;
;	This file is automatically generated
;

tokeniserIntegrated=1

;
;	This is automatically generated.
;
KeywordSet0:
	.text	0,$65,""               ; $80 !0:EOF
	.text	0,$58,""               ; $81 !1:SH1
	.text	0,$5a,""               ; $82 !2:SH2
	.text	4,$fe,"ABS("           ; $83 ABS(
	.text	6,$93,"ALLOC("         ; $84 ALLOC(
	.text	4,$ff,"ASC("           ; $85 ASC(
	.text	5,$29,"CHR$("          ; $86 CHR$(
	.text	6,$aa,"EVENT("         ; $87 EVENT(
	.text	5,$6b,"FALSE"          ; $88 FALSE
	.text	5,$44,"FRAC("          ; $89 FRAC(
	.text	4,$0d,"HIT("           ; $8a HIT(
	.text	4,$13,"INT("           ; $8b INT(
	.text	6,$a7,"ISVAL("         ; $8c ISVAL(
	.text	5,$5c,"JOYB("          ; $8d JOYB(
	.text	5,$72,"JOYX("          ; $8e JOYX(
	.text	5,$73,"JOYY("          ; $8f JOYY(
	.text	6,$77,"LEFT$("         ; $90 LEFT$(
	.text	4,$07,"LEN("           ; $91 LEN(
	.text	4,$0e,"MAX("           ; $92 MAX(
	.text	5,$26,"MID$("          ; $93 MID$(
	.text	4,$0c,"MIN("           ; $94 MIN(
	.text	4,$19,"NOT("           ; $95 NOT(
	.text	7,$e9,"RANDOM("        ; $96 RANDOM(
	.text	7,$ca,"RIGHT$("        ; $97 RIGHT$(
	.text	4,$0c,"RND("           ; $98 RND(
	.text	4,$10,"SGN("           ; $99 SGN(
	.text	4,$0e,"SPC("           ; $9a SPC(
	.text	5,$45,"STR$("          ; $9b STR$(
	.text	6,$a9,"TIMER("         ; $9c TIMER(
	.text	4,$40,"TRUE"           ; $9d TRUE
	.text	4,$0b,"VAL("           ; $9e VAL(
	.text	3,$e7,"FOR"            ; $9f FOR
	.text	2,$8f,"IF"             ; $a0 IF
	.text	4,$34,"PROC"           ; $a1 PROC
	.text	6,$c1,"REPEAT"         ; $a2 REPEAT
	.text	5,$79,"WHILE"          ; $a3 WHILE
	.text	5,$66,"ENDIF"          ; $a4 ENDIF
	.text	7,$0b,"ENDPROC"        ; $a5 ENDPROC
	.text	4,$3f,"NEXT"           ; $a6 NEXT
	.text	4,$2f,"THEN"           ; $a7 THEN
	.text	5,$8c,"UNTIL"          ; $a8 UNTIL
	.text	4,$2e,"WEND"           ; $a9 WEND
	.text	2,$9b,"BY"             ; $aa BY
	.text	4,$1c,"CALL"           ; $ab CALL
	.text	6,$b2,"CIRCLE"         ; $ac CIRCLE
	.text	5,$67,"CLEAR"          ; $ad CLEAR
	.text	3,$e2,"CLS"            ; $ae CLS
	.text	5,$7f,"COLOR"          ; $af COLOR
	.text	6,$d4,"COLOUR"         ; $b0 COLOUR
	.text	4,$1a,"DATA"           ; $b1 DATA
	.text	3,$da,"DIM"            ; $b2 DIM
	.text	6,$db,"DOWNTO"         ; $b3 DOWNTO
	.text	4,$29,"ELSE"           ; $b4 ELSE
	.text	4,$34,"FROM"           ; $b5 FROM
	.text	3,$e5,"GFX"            ; $b6 GFX
	.text	5,$80,"GOSUB"          ; $b7 GOSUB
	.text	4,$39,"GOTO"           ; $b8 GOTO
	.text	4,$24,"HERE"           ; $b9 HERE
	.text	5,$63,"IMAGE"          ; $ba IMAGE
	.text	3,$e5,"LET"            ; $bb LET
	.text	4,$28,"LINE"           ; $bc LINE
	.text	5,$6b,"LOCAL"          ; $bd LOCAL
	.text	3,$db,"OFF"            ; $be OFF
	.text	2,$9d,"ON"             ; $bf ON
	.text	7,$20,"OUTLINE"        ; $c0 OUTLINE
	.text	7,$0f,"PALETTE"        ; $c1 PALETTE
	.text	4,$3f,"PLOT"           ; $c2 PLOT
	.text	5,$8d,"PRINT"          ; $c3 PRINT
	.text	4,$1c,"READ"           ; $c4 READ
	.text	4,$2e,"RECT"           ; $c5 RECT
	.text	3,$e4,"REM"            ; $c6 REM
	.text	6,$e0,"RETURN"         ; $c7 RETURN
	.text	5,$7b,"SOLID"          ; $c8 SOLID
	.text	6,$d7,"SPRITE"         ; $c9 SPRITE
	.text	4,$45,"TEXT"           ; $ca TEXT
	.text	2,$a3,"TO"             ; $cb TO
	.text	$FF
KeywordSet1:
	.text	0,$65,""               ; $80 !0:EOF
	.text	0,$58,""               ; $81 !1:SH1
	.text	0,$5a,""               ; $82 !2:SH2
	.text	8,$4c,"ASSEMBLE"       ; $83 ASSEMBLE
	.text	6,$d2,"ASSERT"         ; $84 ASSERT
	.text	6,$bd,"BITMAP"         ; $85 BITMAP
	.text	3,$d7,"END"            ; $86 END
	.text	4,$3c,"LIST"           ; $87 LIST
	.text	3,$ea,"NEW"            ; $88 NEW
	.text	7,$24,"RESTORE"        ; $89 RESTORE
	.text	3,$f5,"RUN"            ; $8a RUN
	.text	7,$2a,"SPRITES"        ; $8b SPRITES
	.text	4,$46,"STOP"           ; $8c STOP
	.text	$FF
KeywordSet2:
	.text	0,$65,""               ; $80 !0:EOF
	.text	0,$58,""               ; $81 !1:SH1
	.text	0,$5a,""               ; $82 !2:SH2
	.text	3,$c8,"ADC"            ; $83 ADC
	.text	3,$d3,"AND"            ; $84 AND
	.text	3,$e0,"ASL"            ; $85 ASL
	.text	3,$c8,"BCC"            ; $86 BCC
	.text	3,$d8,"BCS"            ; $87 BCS
	.text	3,$d8,"BEQ"            ; $88 BEQ
	.text	3,$df,"BIT"            ; $89 BIT
	.text	3,$d8,"BMI"            ; $8a BMI
	.text	3,$d5,"BNE"            ; $8b BNE
	.text	3,$de,"BPL"            ; $8c BPL
	.text	3,$d5,"BRA"            ; $8d BRA
	.text	3,$df,"BRK"            ; $8e BRK
	.text	3,$db,"BVC"            ; $8f BVC
	.text	3,$eb,"BVS"            ; $90 BVS
	.text	3,$d2,"CLC"            ; $91 CLC
	.text	3,$d3,"CLD"            ; $92 CLD
	.text	3,$d8,"CLI"            ; $93 CLI
	.text	3,$e5,"CLV"            ; $94 CLV
	.text	3,$e0,"CMP"            ; $95 CMP
	.text	3,$eb,"CPX"            ; $96 CPX
	.text	3,$ec,"CPY"            ; $97 CPY
	.text	3,$cc,"DEC"            ; $98 DEC
	.text	3,$e1,"DEX"            ; $99 DEX
	.text	3,$e2,"DEY"            ; $9a DEY
	.text	3,$e6,"EOR"            ; $9b EOR
	.text	3,$da,"INC"            ; $9c INC
	.text	3,$ef,"INX"            ; $9d INX
	.text	3,$f0,"INY"            ; $9e INY
	.text	3,$e7,"JMP"            ; $9f JMP
	.text	3,$ef,"JSR"            ; $a0 JSR
	.text	3,$d1,"LDA"            ; $a1 LDA
	.text	3,$e8,"LDX"            ; $a2 LDX
	.text	3,$e9,"LDY"            ; $a3 LDY
	.text	3,$f1,"LSR"            ; $a4 LSR
	.text	3,$ed,"NOP"            ; $a5 NOP
	.text	3,$e2,"ORA"            ; $a6 ORA
	.text	3,$d9,"PHA"            ; $a7 PHA
	.text	3,$e8,"PHP"            ; $a8 PHP
	.text	3,$f0,"PHX"            ; $a9 PHX
	.text	3,$f1,"PHY"            ; $aa PHY
	.text	3,$dd,"PLA"            ; $ab PLA
	.text	3,$ec,"PLP"            ; $ac PLP
	.text	3,$f4,"PLX"            ; $ad PLX
	.text	3,$f5,"PLY"            ; $ae PLY
	.text	3,$ed,"ROL"            ; $af ROL
	.text	3,$f3,"ROR"            ; $b0 ROR
	.text	3,$ef,"RTI"            ; $b1 RTI
	.text	3,$f9,"RTS"            ; $b2 RTS
	.text	3,$d8,"SBC"            ; $b3 SBC
	.text	3,$db,"SEC"            ; $b4 SEC
	.text	3,$dc,"SED"            ; $b5 SED
	.text	3,$e1,"SEI"            ; $b6 SEI
	.text	3,$e8,"STA"            ; $b7 STA
	.text	3,$f7,"STP"            ; $b8 STP
	.text	3,$ff,"STX"            ; $b9 STX
	.text	3,$00,"STY"            ; $ba STY
	.text	3,$01,"STZ"            ; $bb STZ
	.text	3,$ed,"TAX"            ; $bc TAX
	.text	3,$ee,"TAY"            ; $bd TAY
	.text	3,$e8,"TRB"            ; $be TRB
	.text	3,$e9,"TSB"            ; $bf TSB
	.text	3,$ff,"TSX"            ; $c0 TSX
	.text	3,$ed,"TXA"            ; $c1 TXA
	.text	3,$ff,"TXS"            ; $c2 TXS
	.text	3,$ee,"TYA"            ; $c3 TYA
	.text	$FF
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		expandline.asm
;		Purpose:	Expand line at code-Ptr to tokenBuffer
;		Created:	4th October 2022
;		Reviewed:
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

setcolour .macro
		lda 	#\1+$80
		jsr 	LCLWrite
		.endm

; ************************************************************************************************
;
;							Convert one line back to text. Indent is A
;
; ************************************************************************************************

ListConvertLine:
		pha 								; save indent on the stack
		stz 	tbOffset
		stz 	tokenBuffer
		ldy 	#2 							; convert line number to string
		.cget
		tax
		dey
		.cget
		jsr 	LCLConvertInt16
		sta 	zTemp0 						; copy number into buffer
		stx 	zTemp0+1
		.setcolour CLINumber
		ldy 	#0
_LCCopyNumber:
		lda 	(zTemp0),y
		jsr 	LCLWrite
		iny
		lda 	(zTemp0),y
		bne 	_LCCopyNumber

		pla 								; adjustment to indent
		pha 								; save on stack
		bpl 	_LCNoAdjust 				; don't adjust indent if +ve, do after.
		clc 								; add to list indent and make 0 if goes -ve.
		adc 	listIndent
		sta 	listIndent
		bpl 	_LCNoAdjust
		stz 	listIndent
_LCNoAdjust:
		clc		 							; work out actual indent.
		lda 	listIndent
		asl 	a
		adc 	#6
		sta 	zTemp0

_LCPadOut:
		lda 	#' '						; pad out to 6 characters
		jsr 	LCLWrite
		lda 	tbOffset
		cmp 	zTemp0
		bne 	_LCPadOut
		ldy 	#3 							; start position.
		;	-------------------------------------------------------------------
		;
		;							Main List Loop
		;
		;	-------------------------------------------------------------------

_LCMainLoop:
		.setcolour CLIPunctuation
		.cget 								; get next character
		cmp 	#KWC_EOL 					; end of line ?
		beq 	_LCExit
		;
		cmp 	#16 						; 0-5 are the double punctuations
		bcc 	_LCDoubles
		cmp 	#32 						; 16-31 are shifted punctuation from 64-91
		bcc 	_LCShiftPunc
		cmp 	#64 						; 32-64 are as stored, punc and digits
		bcc 	_LCPunctuation
		cmp 	#128 						; 64-127 are variable identifiers.
		bcc 	_LCIdentifiers
		cmp 	#254 						; 128-253 are tokenised words
		bcc 	_LCTokens
		jmp 	_LCData 					; 254-5 are data objects
		;
		;		Exit - do +ve indent here.
		;
_LCExit:
		pla 								; get old indent adjust
		bmi 	_LCExit2
		clc 								; add to indent if +ve
		adc 	listIndent
		sta 	listIndent
_LCExit2:
		rts
		;	-------------------------------------------------------------------
		;
		;					  Doubles << >> <= >= <> (0-5)
		;
		;	-------------------------------------------------------------------

_LCDoubles:
		pha
		lsr 	a 							; put bit 2 into bit 1
		and 	#2
		ora 	#60 						; make < >
		jsr 	LCLWrite
		pla 								; restore, do lower bit
		and 	#3
		ora 	#60
		bra		_LCPunctuation 				; print, increment, loop

		;	-------------------------------------------------------------------
		;
		;				Upper punctuation (was 64-127) (16-31)
		;
		;	-------------------------------------------------------------------

_LCShiftPunc:
		tax 								; save in X
		and 	#7 							; lower 3 bits
		beq 	_LCNoAdd
		ora 	#24 						; adds $18 to it.
_LCNoAdd:
		cpx 	#24 						; if >= 24 add $20
		bcc 	_LCNoAdd2
		ora 	#32 						; adds $20
_LCNoAdd2:
		ora 	#$40 						; shift into 64-127 range and fall through.

		;	-------------------------------------------------------------------
		;
		;							Punctuation (32-63)
		;
		;	-------------------------------------------------------------------

_LCPunctuation:
		cmp 	#':' 						; check if :
		bne 	_LCPContinue
		jsr 	LCLDeleteLastSpace
_LCPContinue:
		iny 								; consume character
		jsr 	LCLWrite 					; write it out.
		bra 	_LCMainLoop 				; go round again.

		;	-------------------------------------------------------------------
		;
		;							Identifiers (64-127)
		;
		;	-------------------------------------------------------------------

_LCIdentifiers:
		clc 								; convert to physical address
		adc 	#((VariableSpace >> 8) - $40) & $FF
		sta 	zTemp0+1
		iny
		.cget
		sta 	zTemp0
		iny
		phy 								; save position
		.setcolour CLIIdentifier
		ldy 	#7 							; output the identifier.
_LCOutIdentifier:
		iny
		lda 	(zTemp0),y
		and 	#$7F
		jsr 	LCLLowerCase
		jsr 	LCLWrite
		lda 	(zTemp0),y				 	; ends when bit 7 set.
		bpl 	_LCOutIdentifier
		ply 								; restore position
		bra 	_LCMainLoop

		;	-------------------------------------------------------------------
		;
		;							Tokens (129-253)
		;
		;	-------------------------------------------------------------------

_LCTokens:
		tax 								; token in X
		.set16 	zTemp0,KeywordSet2 			; identify keyword set
		cpx 	#$82
		beq 	_LCUseShift
		.set16 	zTemp0,KeywordSet1
		cpx 	#$81
		beq 	_LCUseShift
		.set16  zTemp0,KeywordSet0
		bra 	_LCNoShift
_LCUseShift:								; skip over token if using $81/$82 shifts
		iny
_LCNoShift:
		jsr 	LCLCheckSpaceRequired 		; do we need a space ?
		.cget 								; get the token again
		tax 								; into X
_LCFindText:
		dex
		bpl 	_LCFoundText 				; found text.
		lda 	(zTemp0) 					; length of text
		inc 	a 							; one extra for size
		sec 								; one extra for checksum
		adc 	zTemp0 						; go to next token
		sta 	zTemp0
		bcc 	_LCFindText
		inc 	zTemp0+1
		bra 	_LCFindText
_LCFoundText:
		phy 								; save List position
		lda 	(zTemp0)					; count to print
		tax
		.setcolour CLIToken
		ldy 	#2
_LCCopyToken:								; copy token out.
		lda 	(zTemp0),y
		jsr 	LCLLowerCase
		jsr 	LCLWrite
		iny
		dex
		bne 	_LCCopyToken
		cmp 	#"(" 						; if last char not ( print a space
		beq 	_LCNoSpace
		lda 	#' '
		jsr 	LCLWrite
_LCNoSpace:
		ply 								; restore position.
		iny 								; consume token
		jmp 	_LCMainLoop 				; and go around again.

		;	-------------------------------------------------------------------
		;
		;							Data (254-5)
		;
		;	-------------------------------------------------------------------

_LCData:
		pha 								; save type $FE/$FF
		ldx 	#'$' 						; figure out $ or "
		cmp 	#$FE
		beq 	_LCHaveOpener
		ldx 	#'"'
		.setcolour CLIData
_LCHaveOpener:
		txa 								; output prefix (# or ")
		jsr 	LCLWrite
		iny 								; get count
		.cget
		tax
		iny 								; point at first character
_LCOutData:
		.cget 								; get next
		cmp 	#0
		beq 	_LCNoPrint
		jsr 	LCLWrite
_LCNoPrint:
		iny
		dex
		bne 	_LCOutData
		pla 								; closing " required ?
		cmp 	#$FF
		bne 	_LCNoQuote
		lda 	#'"'
		jsr 	LCLWrite
_LCNoQuote:
		jmp 	_LCMainLoop

; ************************************************************************************************
;
;									Write to token buffer
;
; ************************************************************************************************

LCLWrite:
		phx
		ldx 	tbOffset
		sta 	tokenBuffer,x
		stz 	tokenBuffer+1,x
		inc 	tbOffset
		ora 	#0 							; don't update if colour data
		bmi 	_LCLNoColour
		sta 	LCLastCharacter
_LCLNoColour:
		plx
		rts

; ************************************************************************************************
;
;								 If last space then delete it.
;
; ************************************************************************************************

LCLDeleteLastSpace:
		pha
		phx
		ldx 	tbOffset
		beq 	_LCDLSExit
		lda 	tokenBuffer-1,x
		cmp 	#' '
		bne 	_LCDLSExit
		dec 	tbOffset
_LCDLSExit:
		plx
		pla
		rts

; ************************************************************************************************
;
;							Is a space required, if so print it
;
; ************************************************************************************************

LCLCheckSpaceRequired:
		lda 	LCLastCharacter 			; check last character
		cmp 	#'$' 						; $ # and ) require that token space.
		beq 	_LCCSRSpace
		cmp 	#')'
		beq 	_LCCSRSpace
		cmp 	#'#'
		beq 	_LCCSRSpace
		jsr 	LCLLowerCase 				; saves a little effort
		cmp 	#"0" 						; check if it was 0-9 A-Z a-z if so need space.
		bcc 	_LCCSRExit
		cmp 	#"9"+1
		bcc 	_LCCSRSpace
		cmp 	#"a"
		bcc 	_LCCSRExit
		cmp 	#"z"+1
		bcs 	_LCCSRExit
_LCCSRSpace: 								; output the space
		lda 	#' '
		jsr 	LCLWrite

_LCCSRExit:
		rts
; ************************************************************************************************
;
;										Convert to L/C or U/C
;
; ************************************************************************************************

LCLLowerCase:
		cmp 	#"A"
		bcc 	_LCLLCOut
		cmp 	#"Z"+1
		bcs 	_LCLLCOut
		adc 	#$20
_LCLLCOut:
		rts

LCLUpperCase:
		cmp 	#"a"
		bcc 	_LCLUCOut
		cmp 	#"z"+1
		bcs 	_LCLUCOut
		sbc 	#$1F
_LCLUCOut:
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		searchtokens.asm
;		Purpose:	Seach token table for a specific identifier
;		Created:	19th September 2022
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;	Search the token table at YA for the currently selected identifier. Returns CS and token ID
; 	in A if found, CC if not found
;
; ************************************************************************************************

TOKSearchTable:
		sty 	zTemp0+1 					; (zTemp0),y points to current token.
		sta 	zTemp0
		ldy 	#0
		lda 	#$80 						; token #
		sta 	zTemp1
		;
		;		Token search loop
		;
_TSTLoop:
		lda 	(zTemp0),y 					; length, 0 (skip) -ve (end)
		bmi 	_TSTFail 					; -ve = end of table
		beq 	_TSTNext 					; zero, check next it's a dummy
		;
		iny 								; get the hash
		lda 	(zTemp0),y
		dey
		cmp 	identHash 					; check they match, if not go to next
		bne 	_TSTNext

		lda 	identTypeEnd 				; length of identifier
		sec
		sbc 	identStart
		cmp 	(zTemp0),y 					; no match, then return.
		bne 	_TSTNext
		;
		phy 								; save Y , we might fail
		iny 								; point to text
		iny
		ldx 	identStart 					; offset in line buffer in X
_TSTCompareName:
		lda 	lineBuffer,x 				; compare text.
		cmp 	(zTemp0),y
		bne 	_TSTNextPullY 				; fail, pullY and do next
		inx
		iny
		cpx 	identTypeEnd 				; complete match.
		bne 	_TSTCompareName
		ply 								; throw Y
		lda 	zTemp1 						; get token #
		sec 								; return with CS = passed.
		rts
_TSTNextPullY:
		ply 								; restore current, fall through.
		;
		;		Go to next token.
		;
_TSTNext:
		inc 	zTemp1 						; token counter
		tya
		clc
		adc 	(zTemp0),y 					; add [Length] + 2 to Y
		inc 	a 							; +1
		inc 	a 							; +2
		tay
		bpl 	_TSTLoop 					; if Y < $80 loop back
		;
		tya 								; add Y to zTemp0 and reset Y
		ldy 	#0   						; so we can use Y to search fast
		clc  								; but have tables > 255 bytes
		adc 	zTemp0 						; when Y gets >= 128 we reset Y
		sta 	zTemp0 						; and adjust the table pointer/
		bcc 	_TSTLoop
		inc 	zTemp0+1
		bra 	_TSTLoop

_TSTFail:
		clc
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		tokenise.asm
;		Purpose:	Tokenise Line
;		Created:	18th September 2022
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;								Tokenise ASCIIZ line in lineBuffer
;
; ************************************************************************************************

TokeniseLine:
		;
		;		Make the line buffer UpperCase outside quoted strings
		;
		jsr 	LCLFixLineBufferCase 		; fix line case
		;
		;		Erase the tokenised line to empty
		;
		lda 	#3 							; reset the token buffer to empty
		sta 	tokenOffset
		stz 	tokenLineNumber
		stz 	tokenLineNumber+1
		;
		;		Find the first non space character
		;
		ldx 	#$FF
_TKFindFirst:
		inx
		lda 	lineBuffer,x
		beq 	_TKExit
		cmp 	#' '
		bcc 	_TKFindFirst
		;
		;		If it is 0-9 extract a 2 byte integer into the token line number
		;
		cmp 	#'0'
		bcc 	_TKNoLineNumber
		cmp 	#'9'+1
		bcs 	_TKNoLineNumber
		jsr 	TOKExtractLineNumber
_TKNoLineNumber:
		;----------------------------------------------------------------------------------------
		;
		;							Main tokenising loop
		;
		;----------------------------------------------------------------------------------------

_TKTokeniseLoop:
		lda 	lineBuffer,x 				; next character, exit if zero EOL.
		beq 	_TKExit
		inx
		cmp 	#' '
		beq 	_TKTokeniseLoop 			; keep looping if space found.
		dex 								; undo last get, A contains character, X is position.
		;
		cmp 	#'_'						; _ A-Z is identifier *or* token
		beq 	_TKTokeniseIdentifier
		cmp 	#'A'
		bcc 	_TKTokenisePunctuation
		cmp 	#'Z'+1
		bcc 	_TKTokeniseIdentifier

		;----------------------------------------------------------------------------------------
		;
		;		So we now have a punctuation character. Special cases are those >= 64 and < or > followed by = > or <
		;		and quoted strings. For 64 conversion see the punctuation.ods
		;
		;----------------------------------------------------------------------------------------

_TKTokenisePunctuation:
		cmp 	#'"'						; quoted string ?
		beq 	_TKString
		cmp 	#'$'						; hexadecimal constant (# only appears at end of identifiers)
		beq 	_TKHexConstant
		cmp 	#'<' 						; check for < > handlers.
		beq 	_TKCheckDouble
		cmp 	#'>'
		beq 	_TKCheckDouble
_TKStandardPunctuation:
		lda 	lineBuffer,x 				; get it back.
		cmp 	#64 						; are we >= 64
		bcc 	_TKNoShift
		pha 								; save
		and 	#7 							; lower 3 bits in zTemp0
		sta 	zTemp0
		pla
		and 	#32 						; bit 5
		lsr 	a 							; shift into bit 3
		lsr 	a
		ora 	zTemp0
		ora 	#$10						; now in the range 16-31
_TKNoShift:
		jsr 	TOKWriteByte 				; write the punctuation character
		inx 								; consume the character
		bra 	_TKTokeniseLoop 			; and loop round again.

_TKString: 									; tokenise a string "Hello world"
		jsr 	TOKTokenString
		bra 	_TKTokeniseLoop
_TKHexConstant: 							; tokenise hex constant #A277
		jsr 	TOKHexConstant
		bra 	_TKTokeniseLoop

		;----------------------------------------------------------------------------------------
		;
		;		Have < or >. Check following character is < = >. These are mapped onto
		;		codes 0-5 for << >> <= >= <> , see punctuation.ods
		;
		;----------------------------------------------------------------------------------------

_TKCheckDouble:
		lda 	lineBuffer+1,x 				; get next character
		cmp 	#'<'						; if not < = > which are ASCII consecutive go back
		bcc 	_TKStandardPunctuation
		cmp 	#'>'+1
		bcs 	_TKStandardPunctuation
		;
		lda 	lineBuffer,x 				; this is < (60) or > (62)
		and 	#2 							; now < (0) or > (2)
		asl 	a 							; now < (0) or > (4), CC also
		adc 	lineBuffer+1,x 				; add < = > codes - < code
		sec
		sbc 	#'<'
		jsr 	TOKWriteByte 				; this is in the range 0-7
		inx 								; consume both
		inx
		bra 	_TKTokeniseLoop

		;----------------------------------------------------------------------------------------
		;
		;		Exit point, writes EOL and returns
		;
		;----------------------------------------------------------------------------------------

_TKExit:lda 	#KWC_EOL 					; write end of line byte
		jsr 	TOKWriteByte
		rts

		;----------------------------------------------------------------------------------------
		;
		;		Found _ or A..Z, which means an identifier or a token.
		;
		;----------------------------------------------------------------------------------------

_TKTokeniseIdentifier:
		stx 	identStart 					; save start
		stz 	identTypeByte 				; zero the type byte
_TKCheckLoop:
		inx 								; look at next, we know first is identifier.
		lda  	lineBuffer,x
		cmp 	#"_" 						; legal char _ 0-9 A-Z
		beq 	_TKCheckLoop
		cmp	 	#"0"
		bcc 	_TKEndIdentifier
		cmp 	#"9"+1
		bcc 	_TKCheckLoop
		cmp	 	#"A"
		bcc 	_TKEndIdentifier
		cmp 	#"Z"+1
		bcc 	_TKCheckLoop
_TKEndIdentifier:
		stx 	identTypeStart 				; save start of type text (if any !)
		;
		ldy 	#$08 						; this is the identifier type byte for #
		cmp 	#"#"						; followed by #
		beq 	_TKHasTypeCharacter
		ldy 	#$10 						; this is the identifier type byte for $
		cmp 	#"$"						; followed by $ or #
		bne 	_TKNoTypeCharacter
_TKHasTypeCharacter:
		sty 	identTypeByte 				; has # or $, save the type
		inx 								; read next
		lda 	lineBuffer,x
_TKNoTypeCharacter:
		cmp 	#"("						; is it open parenthesis (e.g. array)
		bne 	_TKNoArray
		inx 								; skip the (
		lda 	identTypeByte 				; set bit 2 (e.g. array)
		ora 	#$04
		sta 	identTypeByte
_TKNoArray:
		stx 	identTypeEnd 				; save end marker, e.g. continue from here.
		jsr 	TOKCalculateHash 			; calculate the has for those tokens

		;----------------------------------------------------------------------------------------
		;
		;			Search the token tables.
		;
		;----------------------------------------------------------------------------------------

checktokens .macro
		ldy 	#(\1) >> 8
		lda 	#(\1) & $FF
		jsr 	TOKSearchTable
		.endm

		.checktokens KeywordSet0			; check the three token tables for the keyword.
		ldx 	#0
		bcs 	_TKFoundToken
		.checktokens KeywordSet1
		ldx 	#$81
		bcs 	_TKFoundToken
		.checktokens KeywordSet2
		ldx 	#$82
		bcs 	_TKFoundToken

		;----------------------------------------------------------------------------------------
		;
		;			 No shift found, so it's a procedure or a variable declaration
		;
		;----------------------------------------------------------------------------------------

		jsr 	TOKCheckCreateVariableRecord ; failed all, it's a variable, create record if does not exist.
		ldx 	identTypeEnd 				; X points to following byte
		jmp 	_TKTokeniseLoop 			; and go round again.

		;----------------------------------------------------------------------------------------
		;
		;				Found a token, X contains the shift (or 0), A the token
		;
		;----------------------------------------------------------------------------------------

_TKFoundToken:
		pha 								; save token
		txa 								; shift in X, is there one ?
		beq 	_TKNoTShift
		jsr 	TOKWriteByte 				; if so, write it out
_TKNoTShift:
		pla 								; restore and write token
		jsr 	TOKWriteByte
		ldx 	identTypeEnd 				; X points to following byte
		jmp 	_TKTokeniseLoop 			; and go round again.

; ************************************************************************************************
;
;									Tokenise a string.
;
; ************************************************************************************************

TOKTokenString:
		lda 	#KWC_STRING 				; string token.
		jsr 	TOKWriteByte
		inx									; start of quoted string.
		phx 								; push start of string on top
		dex
_TSFindEnd:
		inx
		lda 	lineBuffer,x 				; next character
		beq 	_TSEndOfString
		cmp 	#'"'
		bne 	_TSFindEnd
_TSEndOfString:
		ply  								; so now Y is first character, X is character after end.
		pha 								; save terminating character
		jsr 	TOKWriteBlockXY 			; write X to Y as a data block
		pla 								; terminating character
		beq 	_TSNotQuote					; if it wasn't EOS skip it
		inx
_TSNotQuote:
		rts
;
;		Write Y to X with a trailing NULL.
;
TOKWriteBlockXY:
		stx 	zTemp0 						; write end character
		tya
		eor 	#$FF
		sec
		adc 	zTemp0
		inc 	a 							; one extra for NULL
		jsr 	TOKWriteByte
_TOBlockLoop:
		cpy 	zTemp0
		beq 	_TOBlockExit
		lda 	lineBuffer,y
		jsr 	TOKWriteByte
		iny
		bra 	_TOBlockLoop
_TOBlockExit:
		lda 	#0
		jsr 	TOKWriteByte
		rts

; ************************************************************************************************
;
;									Tokenise a hex constant
;
; ************************************************************************************************

TOKHexConstant:
		lda 	#KWC_HEXCONST 				; hex constant token.
		jsr 	TOKWriteByte
		inx									; start of quoted string.
		phx 								; push start of constant on top
		dex
_THFindLoop:
		inx
		lda 	lineBuffer,x
		cmp 	#"0"
		bcc 	_THFoundEnd
		cmp 	#"9"+1
		bcc 	_THFindLoop
		cmp 	#"A"
		bcc 	_THFoundEnd
		cmp 	#"F"+1
		bcc 	_THFindLoop
_THFoundEnd:
		ply 								; restore start
		jsr 	TOKWriteBlockXY 			; output the block
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		utility.asm
;		Purpose:	Tokeniser Utilities
;		Created:	19th September 2022
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;					   Calculate Hash of part of buffer selected for identifier
;
; ************************************************************************************************

TOKCalculateHash:
		phx
		ldx 	identStart 					; needs to be same as in tokens.py - simple sum
		lda 	#0
_TCHLoop:
		clc
		adc 	lineBuffer,x
		inx
		cpx 	identTypeEnd 				; do the whole thing including type and array markers.
		bne 	_TCHLoop
		sta 	identHash 					; save the hash
		plx
		rts

; ************************************************************************************************
;
;					   Fix case of line in LineBuffer to U/C outside quotes
;
; ************************************************************************************************

LCLFixLineBufferCase:
		ldx 	#0
_FLBCLoop:
		lda 	lineBuffer,x 				; get next character
		beq 	_FLBCExit 					; end of string.
		cmp 	#'"'						; quote, go to in quotes
		beq 	_FLBCInQuotes
		inx
		cmp 	#'a'						; needs capitalising ?
		bcc 	_FLBCLoop
		cmp 	#'z'+1
		bcs 	_FLBCLoop
		sec 								; make U/C
		sbc 	#32
		sta	 	lineBuffer-1,x 				; write back
		bra 	_FLBCLoop
		;
_FLBCInQuotes:
		inx 								; advance
		lda 	lineBuffer,x 				; get next
		beq 	_FLBCExit 					; exit on EOS
		cmp 	#'"' 				 		; until " found
		bne 	_FLBCInQuotes
		inx 								; skip over it
		bra 	_FLBCLoop
		;
_FLBCExit:
		rts

; ************************************************************************************************
;
;		  Extract line number from lineBuffer,x - we know there's at least *one* digit
;		  (this code is seperate so that the tokenising code could be in its own page)
;
; ************************************************************************************************

TOKExtractLineNumber:
		lda 	tokenLineNumber+1 			; push current value on stack
		pha
		lda 	tokenLineNumber
		pha
		jsr 	_LCLNTimes2 				; line # x 4
		jsr 	_LCLNTimes2 				; line # x 2
		;
		clc 								; add stacked value
		pla
		adc 	tokenLineNumber
		sta 	tokenLineNumber
		pla
		adc 	tokenLineNumber+1
		sta 	tokenLineNumber+1 			; line # x 5
		jsr 	_LCLNTimes2 				; line # x 10
		;
		lda 	lineBuffer,x 				; get and consume character
		inx
		and 	#15 						; add to line #
		clc
		adc 	tokenLineNumber
		sta 	tokenLineNumber
		bcc 	_TLENNoCarry
		inc 	tokenLineNumber+1
_TLENNoCarry:
		lda 	lineBuffer,x 				; more digits ?
		cmp 	#'0'
		bcc 	_TLENExit
		cmp 	#'9'+1
		bcc 	TOKExtractLineNumber
_TLENExit:
		rts
_LCLNTimes2:
		asl 	tokenLineNumber
		rol 	tokenLineNumber+1
		rts

; ************************************************************************************************
;
;								Write Byte to tokenBuffer
;
; ************************************************************************************************

TOKWriteByte:
		phx
		ldx 	tokenOffset 				; next slot to write to
		sta 	tokenOffset,x 				; write byte out
		inc 	tokenOffset 				; advance slot.
		plx
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		variablerecord.asm
;		Purpose:	Handle a possibly new variable identifier
;		Created:	19th September 2022
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;		Check to see if the currently specified identifier is in the table.  If not, create it
; 		as specified.
;
;		Then compile a reference to it in the tokenised code.
;
; ************************************************************************************************

TOKCheckCreateVariableRecord:
		.set16 	zTemp0,VariableSpace 		; initialise pointer
		;
		;		Search the variable table to see if it already exists
		;
_CCVSearch:
		lda 	(zTemp0) 					; end of list
		beq 	_CCVFail
		ldy 	#1 							; read the hash
		lda 	(zTemp0),y 					; does it match ?
		cmp 	identHash
		bne 	_CCVNext
		;
		;		Compare the identifier to the variable record. We don't match
		; 		types because these could be reset in the procedure code.
		;
		ldy 	#8 							; name in variable record
		ldx 	identStart
_CCVCompare:
		lda 	lineBuffer,x 				; xor them. zero if the same, except
		eor 	(zTemp0),y 					; bit 7 is used for EOS.
		inx 								; advance pointers
		iny
		asl 	a 							; A = 0 if they match, CS if end.
		bne 	_CCVNext  					; didn't match go to next.
		bcc 	_CCVCompare 				; not finished yet.
		;
		cpx 	identTypeEnd 				; matched whole thing ?
		beq 	_CCVFound 					; yes, we were successful
		;
_CCVNext:
		clc
		lda 	(zTemp0) 					; add offset to pointer
		adc 	zTemp0
		sta 	zTemp0
		bcc 	_CCVSearch
		inc 	zTemp0+1
		bra 	_CCVSearch
		;
		;		Could not find the identifier. zTemp0 points to the free space in the
		;		variable storage, conveniently.
		;
_CCVFail:
		ldy 	#1 							; create the new record. Offset 1 is hash
		lda 	identHash
		sta 	(zTemp0),y
		iny 								; offset 2 is the type byte
		lda 	identTypeByte
		sta 	(zTemp0),y
		iny
_CCVData:
		lda 	#0 							; erase data 3-7
		sta 	(zTemp0),y
		iny
		cpy 	#8
		bcc 	_CCVData
		ldx 	identStart 					; copy name into 8 on.
_CCVCopyName:
		lda 	lineBuffer,x
		sta 	(zTemp0),y
		inx
		iny
		cpx 	identTypeEnd
		bne 	_CCVCopyName
		;
		tya 								; patch offset
		sta 	(zTemp0)
		lda 	#0 							; offset for next is zero.
		sta 	(zTemp0),y
		;
		dey
		lda 	(zTemp0),y 					; set bit 7 of last bit
		ora 	#$80
		sta 	(zTemp0),y
		;
		;
		;		Variable record at zTemp0 - output to tokeniser
		;
_CCVFound:
		lda 	zTemp0+1 					; write out MSB
		sec
		sbc 	#(VariableSpace >> 8) 		; offset from the start
		ora 	#$40 						; make it a writeable token
		jsr 	TOKWriteByte
		lda 	zTemp0 						; write out LSB
		jsr 	TOKWriteByte
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
