;
;	This file is automatically generated
;

tokeniserIntegrated=1

;
;	This is automatically generated.
;
	.section code
KeywordSet0:
	.text	0,$65,""               ; $80 !0:EOF
	.text	0,$58,""               ; $81 !1:SH1
	.text	0,$5a,""               ; $82 !2:SH2
	.text	4,$fe,"ABS("           ; $83 ABS(
	.text	6,$93,"ALLOC("         ; $84 ALLOC(
	.text	4,$ff,"ASC("           ; $85 ASC(
	.text	5,$29,"CHR$("          ; $86 CHR$(
	.text	6,$aa,"EVENT("         ; $87 EVENT(
	.text	5,$6b,"FALSE"          ; $88 FALSE
	.text	5,$44,"FRAC("          ; $89 FRAC(
	.text	5,$2c,"GET$("          ; $8a GET$(
	.text	4,$08,"GET("           ; $8b GET(
	.text	9,$4a,"GETDATE$("      ; $8c GETDATE$(
	.text	9,$5b,"GETTIME$("      ; $8d GETTIME$(
	.text	4,$0d,"HIT("           ; $8e HIT(
	.text	7,$cc,"INKEY$("        ; $8f INKEY$(
	.text	6,$a8,"INKEY("         ; $90 INKEY(
	.text	4,$13,"INT("           ; $91 INT(
	.text	6,$a7,"ISVAL("         ; $92 ISVAL(
	.text	10,$e0,"ITEMCOUNT("     ; $93 ITEMCOUNT(
	.text	9,$5b,"ITEMGET$("      ; $94 ITEMGET$(
	.text	5,$5c,"JOYB("          ; $95 JOYB(
	.text	5,$72,"JOYX("          ; $96 JOYX(
	.text	5,$73,"JOYY("          ; $97 JOYY(
	.text	8,$49,"KEYDOWN("       ; $98 KEYDOWN(
	.text	6,$77,"LEFT$("         ; $99 LEFT$(
	.text	4,$07,"LEN("           ; $9a LEN(
	.text	4,$0e,"MAX("           ; $9b MAX(
	.text	5,$26,"MID$("          ; $9c MID$(
	.text	4,$0c,"MIN("           ; $9d MIN(
	.text	4,$19,"NOT("           ; $9e NOT(
	.text	5,$4d,"PEEK("          ; $9f PEEK(
	.text	6,$91,"PEEKD("         ; $a0 PEEKD(
	.text	6,$99,"PEEKL("         ; $a1 PEEKL(
	.text	6,$a4,"PEEKW("         ; $a2 PEEKW(
	.text	8,$3c,"PLAYING("       ; $a3 PLAYING(
	.text	7,$e9,"RANDOM("        ; $a4 RANDOM(
	.text	7,$ca,"RIGHT$("        ; $a5 RIGHT$(
	.text	4,$0c,"RND("           ; $a6 RND(
	.text	4,$10,"SGN("           ; $a7 SGN(
	.text	4,$0e,"SPC("           ; $a8 SPC(
	.text	5,$45,"STR$("          ; $a9 STR$(
	.text	5,$56,"TILE("          ; $aa TILE(
	.text	6,$a9,"TIMER("         ; $ab TIMER(
	.text	4,$40,"TRUE"           ; $ac TRUE
	.text	4,$0b,"VAL("           ; $ad VAL(
	.text	3,$e7,"FOR"            ; $ae FOR
	.text	2,$8f,"IF"             ; $af IF
	.text	4,$34,"PROC"           ; $b0 PROC
	.text	6,$c1,"REPEAT"         ; $b1 REPEAT
	.text	5,$79,"WHILE"          ; $b2 WHILE
	.text	5,$66,"ENDIF"          ; $b3 ENDIF
	.text	7,$0b,"ENDPROC"        ; $b4 ENDPROC
	.text	4,$3f,"NEXT"           ; $b5 NEXT
	.text	4,$2f,"THEN"           ; $b6 THEN
	.text	5,$8c,"UNTIL"          ; $b7 UNTIL
	.text	4,$2e,"WEND"           ; $b8 WEND
	.text	2,$95,"AT"             ; $b9 AT
	.text	2,$9b,"BY"             ; $ba BY
	.text	4,$1c,"CALL"           ; $bb CALL
	.text	6,$b2,"CIRCLE"         ; $bc CIRCLE
	.text	5,$67,"CLEAR"          ; $bd CLEAR
	.text	5,$7f,"COLOR"          ; $be COLOR
	.text	6,$d4,"COLOUR"         ; $bf COLOUR
	.text	4,$1a,"DATA"           ; $c0 DATA
	.text	3,$da,"DIM"            ; $c1 DIM
	.text	6,$db,"DOWNTO"         ; $c2 DOWNTO
	.text	4,$29,"ELSE"           ; $c3 ELSE
	.text	4,$34,"FROM"           ; $c4 FROM
	.text	3,$e5,"GFX"            ; $c5 GFX
	.text	4,$24,"HERE"           ; $c6 HERE
	.text	5,$63,"IMAGE"          ; $c7 IMAGE
	.text	3,$e5,"LET"            ; $c8 LET
	.text	4,$28,"LINE"           ; $c9 LINE
	.text	5,$6b,"LOCAL"          ; $ca LOCAL
	.text	7,$1a,"MEMCOPY"        ; $cb MEMCOPY
	.text	3,$db,"OFF"            ; $cc OFF
	.text	2,$9d,"ON"             ; $cd ON
	.text	7,$20,"OUTLINE"        ; $ce OUTLINE
	.text	7,$0f,"PALETTE"        ; $cf PALETTE
	.text	4,$3f,"PLOT"           ; $d0 PLOT
	.text	4,$2f,"POKE"           ; $d1 POKE
	.text	5,$73,"POKED"          ; $d2 POKED
	.text	5,$7b,"POKEL"          ; $d3 POKEL
	.text	5,$86,"POKEW"          ; $d4 POKEW
	.text	4,$1c,"READ"           ; $d5 READ
	.text	4,$2e,"RECT"           ; $d6 RECT
	.text	3,$e4,"REM"            ; $d7 REM
	.text	5,$7b,"SOLID"          ; $d8 SOLID
	.text	5,$89,"SOUND"          ; $d9 SOUND
	.text	6,$d7,"SPRITE"         ; $da SPRITE
	.text	4,$45,"TEXT"           ; $db TEXT
	.text	2,$a3,"TO"             ; $dc TO
	.text	$FF
KeywordSet1:
	.text	0,$65,""               ; $80 !0:EOF
	.text	0,$58,""               ; $81 !1:SH1
	.text	0,$5a,""               ; $82 !2:SH2
	.text	8,$4c,"ASSEMBLE"       ; $83 ASSEMBLE
	.text	6,$d2,"ASSERT"         ; $84 ASSERT
	.text	6,$bd,"BITMAP"         ; $85 BITMAP
	.text	5,$62,"BLOAD"          ; $86 BLOAD
	.text	5,$71,"BSAVE"          ; $87 BSAVE
	.text	3,$e2,"CLS"            ; $88 CLS
	.text	6,$d0,"CPRINT"         ; $89 CPRINT
	.text	6,$de,"CURSOR"         ; $8a CURSOR
	.text	3,$df,"DIR"            ; $8b DIR
	.text	5,$7a,"DRIVE"          ; $8c DRIVE
	.text	3,$d7,"END"            ; $8d END
	.text	7,$11,"EXPLODE"        ; $8e EXPLODE
	.text	2,$96,"GO"             ; $8f GO
	.text	5,$80,"GOSUB"          ; $90 GOSUB
	.text	4,$39,"GOTO"           ; $91 GOTO
	.text	5,$70,"HIMEM"          ; $92 HIMEM
	.text	5,$90,"INPUT"          ; $93 INPUT
	.text	4,$3c,"LIST"           ; $94 LIST
	.text	4,$20,"LOAD"           ; $95 LOAD
	.text	6,$b7,"MDELTA"         ; $96 MDELTA
	.text	5,$89,"MOUSE"          ; $97 MOUSE
	.text	3,$ea,"NEW"            ; $98 NEW
	.text	6,$d9,"OPTION"         ; $99 OPTION
	.text	4,$2e,"PING"           ; $9a PING
	.text	5,$8d,"PRINT"          ; $9b PRINT
	.text	7,$24,"RESTORE"        ; $9c RESTORE
	.text	6,$e0,"RETURN"         ; $9d RETURN
	.text	3,$f5,"RUN"            ; $9e RUN
	.text	4,$2f,"SAVE"           ; $9f SAVE
	.text	7,$0a,"SETDATE"        ; $a0 SETDATE
	.text	7,$1b,"SETTIME"        ; $a1 SETTIME
	.text	5,$8d,"SHOOT"          ; $a2 SHOOT
	.text	7,$2a,"SPRITES"        ; $a3 SPRITES
	.text	4,$46,"STOP"           ; $a4 STOP
	.text	4,$2e,"TILE"           ; $a5 TILE
	.text	5,$81,"TILES"          ; $a6 TILES
	.text	3,$ff,"TRY"            ; $a7 TRY
	.text	6,$d5,"VERIFY"         ; $a8 VERIFY
	.text	3,$ee,"XGO"            ; $a9 XGO
	.text	5,$78,"XLOAD"          ; $aa XLOAD
	.text	3,$eb,"ZAP"            ; $ab ZAP
	.text	$FF
KeywordSet2:
	.text	0,$65,""               ; $80 !0:EOF
	.text	0,$58,""               ; $81 !1:SH1
	.text	0,$5a,""               ; $82 !2:SH2
	.text	3,$c8,"ADC"            ; $83 ADC
	.text	3,$d3,"AND"            ; $84 AND
	.text	3,$e0,"ASL"            ; $85 ASL
	.text	3,$c8,"BCC"            ; $86 BCC
	.text	3,$d8,"BCS"            ; $87 BCS
	.text	3,$d8,"BEQ"            ; $88 BEQ
	.text	3,$df,"BIT"            ; $89 BIT
	.text	3,$d8,"BMI"            ; $8a BMI
	.text	3,$d5,"BNE"            ; $8b BNE
	.text	3,$de,"BPL"            ; $8c BPL
	.text	3,$d5,"BRA"            ; $8d BRA
	.text	3,$df,"BRK"            ; $8e BRK
	.text	3,$db,"BVC"            ; $8f BVC
	.text	3,$eb,"BVS"            ; $90 BVS
	.text	3,$d2,"CLC"            ; $91 CLC
	.text	3,$d3,"CLD"            ; $92 CLD
	.text	3,$d8,"CLI"            ; $93 CLI
	.text	3,$e5,"CLV"            ; $94 CLV
	.text	3,$e0,"CMP"            ; $95 CMP
	.text	3,$eb,"CPX"            ; $96 CPX
	.text	3,$ec,"CPY"            ; $97 CPY
	.text	3,$cc,"DEC"            ; $98 DEC
	.text	3,$e1,"DEX"            ; $99 DEX
	.text	3,$e2,"DEY"            ; $9a DEY
	.text	3,$e6,"EOR"            ; $9b EOR
	.text	3,$da,"INC"            ; $9c INC
	.text	3,$ef,"INX"            ; $9d INX
	.text	3,$f0,"INY"            ; $9e INY
	.text	3,$e7,"JMP"            ; $9f JMP
	.text	3,$ef,"JSR"            ; $a0 JSR
	.text	3,$d1,"LDA"            ; $a1 LDA
	.text	3,$e8,"LDX"            ; $a2 LDX
	.text	3,$e9,"LDY"            ; $a3 LDY
	.text	3,$f1,"LSR"            ; $a4 LSR
	.text	3,$ed,"NOP"            ; $a5 NOP
	.text	3,$e2,"ORA"            ; $a6 ORA
	.text	3,$d9,"PHA"            ; $a7 PHA
	.text	3,$e8,"PHP"            ; $a8 PHP
	.text	3,$f0,"PHX"            ; $a9 PHX
	.text	3,$f1,"PHY"            ; $aa PHY
	.text	3,$dd,"PLA"            ; $ab PLA
	.text	3,$ec,"PLP"            ; $ac PLP
	.text	3,$f4,"PLX"            ; $ad PLX
	.text	3,$f5,"PLY"            ; $ae PLY
	.text	3,$ed,"ROL"            ; $af ROL
	.text	3,$f3,"ROR"            ; $b0 ROR
	.text	3,$ef,"RTI"            ; $b1 RTI
	.text	3,$f9,"RTS"            ; $b2 RTS
	.text	3,$d8,"SBC"            ; $b3 SBC
	.text	3,$db,"SEC"            ; $b4 SEC
	.text	3,$dc,"SED"            ; $b5 SED
	.text	3,$e1,"SEI"            ; $b6 SEI
	.text	3,$e8,"STA"            ; $b7 STA
	.text	3,$f7,"STP"            ; $b8 STP
	.text	3,$ff,"STX"            ; $b9 STX
	.text	3,$00,"STY"            ; $ba STY
	.text	3,$01,"STZ"            ; $bb STZ
	.text	3,$ed,"TAX"            ; $bc TAX
	.text	3,$ee,"TAY"            ; $bd TAY
	.text	3,$e8,"TRB"            ; $be TRB
	.text	3,$e9,"TSB"            ; $bf TSB
	.text	3,$ff,"TSX"            ; $c0 TSX
	.text	3,$ed,"TXA"            ; $c1 TXA
	.text	3,$ff,"TXS"            ; $c2 TXS
	.text	3,$ee,"TYA"            ; $c3 TYA
	.text	$FF
	.send code
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		expandline.asm
;		Purpose:	Expand line at code-Ptr to tokenBuffer
;		Created:	4th October 2022
;		Reviewed:	26th November 2022
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

setcolour .macro
		lda 	\1
		jsr 	LCLWriteColour
		.endm

; ************************************************************************************************
;
;									Reset tokeniser/detokeniser
;
; ************************************************************************************************

Export_TKInitialise:
		ldx 	#7
_ETKISetDefault:
		lda 	CLIDefault,x
		sta 	CLIFComment,x
		dex
		bpl 	_ETKISetDefault
		rts


; ************************************************************************************************
;
;							Convert one line back to text. Indent is A
;
; ************************************************************************************************

Export_TKListConvertLine:
		pha 								; save indent on the stack
		stz 	tbOffset
		stz 	tokenBuffer
		stz 	currentListColour
		.setcolour CLILineNumber
		;
		;		Do the line number
		;
		ldy 	#2 							; convert line number to string
		.cget
		tax
		dey
		.cget
		jsr 	LCLWriteNumberXA
				;
		;		Pad out for indentation.
		;
		pla 								; adjustment to indent
		pha 								; save on stack
		bpl 	_LCNoAdjust 				; don't adjust indent if +ve, do after.
		clc 								; add to list indent and make 0 if goes -ve.
		adc 	listIndent
		sta 	listIndent
		bpl 	_LCNoAdjust
		stz 	listIndent
_LCNoAdjust:
		clc		 							; work out actual indent.
		lda 	listIndent
		asl 	a
		adc 	#7
		sta 	zTemp0

_LCPadOut:
		lda 	#' '						; pad out to 6+indent characters
		jsr 	LCLWrite
		lda 	tbOffset
		cmp 	zTemp0
		bne 	_LCPadOut
		ldy 	#3 							; start position.
		;	-------------------------------------------------------------------
		;
		;							Main List Loop
		;
		;	-------------------------------------------------------------------

_LCMainLoop:
		.setcolour CLIPunctuation 			; default listing colour
		.cget 								; get next character
		cmp 	#KWC_EOL 					; end of line ?
		beq 	_LCExit
		;
		cmp 	#16 						; 0-5 are the double punctuations
		bcc 	_LCDoubles
		cmp 	#32 						; 16-31 are shifted punctuation from 64-91
		bcc 	_LCShiftPunc
		cmp 	#64 						; 32-64 are as stored, punc and digits
		bcc 	_LCPunctuation
		cmp 	#128 						; 64-127 are variable identifiers.
		bcc 	_LCIdentifiers
		cmp 	#254 						; 128-253 are tokenised words
		bcc 	_LCTokens
		jmp 	_LCData 					; 254-5 are data objects
		;
		;		Exit - do +ve indent here.
		;
_LCExit:
		pla 								; get old indent adjust
		bmi 	_LCExit2
		clc 								; add to indent if +ve
		adc 	listIndent
		sta 	listIndent
_LCExit2:
		rts
		;	-------------------------------------------------------------------
		;
		;					  Doubles << >> <= >= <> (0-5)
		;
		;	-------------------------------------------------------------------

_LCDoubles:
		pha
		lsr 	a 							; put bit 2 into bit 1
		and 	#2
		ora 	#60 						; make < >
		jsr 	LCLWrite
		pla 								; restore, do lower bit
		and 	#3
		ora 	#60
		bra		_LCPunctuation 				; print, increment, loop

		;	-------------------------------------------------------------------
		;
		;				Upper punctuation (was 64-127) (16-31)
		;
		;	-------------------------------------------------------------------

_LCShiftPunc:
		tax 								; save in X
		and 	#7 							; lower 3 bits
		beq 	_LCNoAdd
		ora 	#24 						; adds $18 to it.
_LCNoAdd:
		cpx 	#24 						; if >= 24 add $20
		bcc 	_LCNoAdd2
		ora 	#32 						; adds $20
_LCNoAdd2:
		ora 	#$40 						; shift into 64-127 range and fall through.

		;	-------------------------------------------------------------------
		;
		;							Punctuation (32-63)
		;
		;	-------------------------------------------------------------------

_LCPunctuation:
		cmp 	#':' 						; check if :
		bne 	_LCPContinue
		jsr 	LCLDeleteLastSpace 			; if so delete any preceding spaces
_LCPContinue:
		cmp 	#'.'
		beq 	_LCPIsConstant
		cmp 	#'0'
		bcc 	_LCPNotConstant
		cmp 	#'9'+1
		bcs 	_LCPNotConstant
_LCPIsConstant:
		pha
		.setcolour CLIConstant
		pla
_LCPNotConstant:
		iny 								; consume character
		jsr 	LCLWrite 					; write it out.
		bra 	_LCMainLoop 				; go round again.

		;	-------------------------------------------------------------------
		;
		;							Identifiers (64-127)
		;
		;	-------------------------------------------------------------------

_LCIdentifiers:
		clc 								; convert to physical address
		adc 	#((VariableSpace >> 8) - $40) & $FF
		sta 	zTemp0+1
		iny
		.cget
		sta 	zTemp0
		iny
		phy 								; save position
		.setcolour CLIIdentifier 			; set list colour
		ldy 	#7 							; output the identifier at +8
_LCOutIdentifier:
		iny
		lda 	(zTemp0),y					; bit 7 set = end.
		and 	#$7F
		jsr 	LCLLowerCase
		jsr 	LCLWrite
		lda 	(zTemp0),y				 	; ends when bit 7 set.
		bpl 	_LCOutIdentifier
		ply 								; restore position
		jmp 	_LCMainLoop

		;	-------------------------------------------------------------------
		;
		;							Tokens (129-253)
		;
		;	-------------------------------------------------------------------

_LCTokens:
		tax 								; token in X
		.set16 	zTemp0,KeywordSet2 			; identify keyword set
		cpx 	#$82
		beq 	_LCUseShift
		.set16 	zTemp0,KeywordSet1
		cpx 	#$81
		beq 	_LCUseShift
		.set16  zTemp0,KeywordSet0
		bra 	_LCNoShift
_LCUseShift:								; skip over token if using $81/$82 shifts
		iny
_LCNoShift:
		jsr 	LCLCheckSpaceRequired 		; do we need a space ?
		.cget 								; get the token again
		tax 								; into X
_LCFindText:
		dex
		bpl 	_LCFoundText 				; found text.
		lda 	(zTemp0) 					; length of text
		inc 	a 							; one extra for size
		sec 								; one extra for checksum
		adc 	zTemp0 						; go to next token
		sta 	zTemp0
		bcc 	_LCFindText
		inc 	zTemp0+1
		bra 	_LCFindText
_LCFoundText:
		phy 								; save List position
		lda 	(zTemp0)					; count to print
		tax
		.setcolour CLIToken
		ldy 	#2
_LCCopyToken:								; copy token out.
		lda 	(zTemp0),y
		jsr 	LCLLowerCase
		jsr 	LCLWrite
		iny
		dex
		bne 	_LCCopyToken
		cmp 	#"(" 						; if last char not ( print a space
		beq 	_LCNoSpace
		lda 	#' '
		jsr 	LCLWrite
_LCNoSpace:
		ply 								; restore position.
		iny 								; consume token
		jmp 	_LCMainLoop 				; and go around again.

		;	-------------------------------------------------------------------
		;
		;							Data (254-5)
		;
		;	-------------------------------------------------------------------

_LCData:
		pha 								; save type $FE/$FF
		ldx 	#'$' 						; figure out $ or "
		cmp 	#$FE
		beq 	_LCHaveOpener
		ldx 	#'"'
		.setcolour CLIData
		;
		;		Check for comment on line by itself.
		;
		cpy 	#4 							; must be 2nd thing on line
		bne 	_LCHaveOpener
		dey 								; what precedes it ?
		.cget
		iny
		cmp 	#KWD_QUOTE 					; if quote
		bne 	_LCHaveOpener
		lda 	#9 							; tab
		jsr 	LCLWrite
		lda 	CLIBComment
		bmi 	_LCHaveOpener
		ora 	#$90
		jsr 	LCLWrite
		.setcolour CLIFComment
_LCHaveOpener:
		txa 								; output prefix (# or ")
		jsr 	LCLWrite
		iny 								; get count
		.cget
		tax
		iny 								; point at first character
_LCOutData:
		.cget 								; get next
		cmp 	#0
		beq 	_LCNoPrint
		jsr 	LCLWrite
_LCNoPrint:
		iny
		dex
		bne 	_LCOutData
		pla 								; closing " required ?
		cmp 	#$FF 						; not required for hex constant.
		bne 	_LCNoQuote
		lda 	#'"'
		jsr 	LCLWrite
		lda 	EXTTextColour
		and 	#$0F
		ora 	#$90
		jsr 	LCLWrite
_LCNoQuote:
		jmp 	_LCMainLoop

; ************************************************************************************************
;
;					Output write colour ($80-$8F) only if it has changed
;
; ************************************************************************************************

LCLWriteColour:
		and 	#$0F
		ora 	#$80
		cmp 	currentListColour 			; has the colour changed
		sta 	currentListColour 			; (update it anyway)
		bne 	LCLWrite 					; if different, output it
		rts

; ************************************************************************************************
;
;									Write to token buffer
;
; ************************************************************************************************

LCLWrite:
		phx
		ldx 	tbOffset 					; write out make ASCIIZ
		sta 	tokenBuffer,x
		stz 	tokenBuffer+1,x
		inc 	tbOffset 					; bump the position
		ora 	#0 							; don't update last character if colour data
		bmi 	_LCLNoColour
		sta 	lcLastCharacter
_LCLNoColour:
		plx
		rts

; ************************************************************************************************
;
;								 If last space then delete it.
;
; ************************************************************************************************

LCLDeleteLastSpace:
		pha
		phx
		ldx 	tbOffset
		beq 	_LCDLSExit
		lda 	tokenBuffer-1,x
		cmp 	#' '
		bne 	_LCDLSExit
		dec 	tbOffset
_LCDLSExit:
		plx
		pla
		rts

; ************************************************************************************************
;
;							Is a space required, if so print it
;
; ************************************************************************************************

LCLCheckSpaceRequired:
		lda 	lcLastCharacter 			; check last character
		cmp 	#'$' 						; $ # and ) require that token space.
		beq 	_LCCSRSpace
		cmp 	#')'
		beq 	_LCCSRSpace
		cmp 	#'#'
		beq 	_LCCSRSpace
		jsr 	LCLLowerCase 				; saves a little effort
		cmp 	#"0" 						; check if it was 0-9 A-Z a-z if so need space.
		bcc 	_LCCSRExit
		cmp 	#"9"+1
		bcc 	_LCCSRSpace
		cmp 	#"a"
		bcc 	_LCCSRExit
		cmp 	#"z"+1
		bcs 	_LCCSRExit
_LCCSRSpace: 								; output the space
		lda 	#' '
		jsr 	LCLWrite

_LCCSRExit:
		rts

; ************************************************************************************************
;
;										Convert to L/C or U/C
;
; ************************************************************************************************

LCLLowerCase:
		cmp 	#"A"
		bcc 	_LCLLCOut
		cmp 	#"Z"+1
		bcs 	_LCLLCOut
		adc 	#$20
_LCLLCOut:
		rts

LCLUpperCase:
		cmp 	#"a"
		bcc 	_LCLUCOut
		cmp 	#"z"+1
		bcs 	_LCLUCOut
		sbc 	#$1F
_LCLUCOut:
		rts

; ************************************************************************************************
;
;										Write out XA as string
;
; ************************************************************************************************

LCLWriteNumberXA:
		stz 	zTemp0+1 					; index into digit table.
_LCLWNLoop1:
		stz 	zTemp0 						; subtraction count.
_LCLWNLoop2:
		pha 								; save initial LSB
		sec
		ldy 	zTemp0+1 					; position in table.
		sbc 	_LCLWNTable,y
		pha
		txa
		sbc 	_LCLWNTable+1,y
		bcc 	_LCLWNUnderflow
		;
		inc 	zTemp0  					; subtracted one without borrow.
		tax 								; update X
		pla 								; restore A
		ply 								; throw original
		bra 	_LCLWNLoop2 				; try again.
_LCLWNUnderflow:
		ldy 	zTemp0 						; count of subtractions.
		bne 	_LCLWNOut
		lda 	tbOffset 					; suppress leading zeroes
		dec 	a
		beq 	_LCLWNNext
_LCLWNOut:
		tya
		jsr 	_LCLWNOutDigit
_LCLWNNext:
		ply 							 	; restore original value.
		pla
		ldy 	zTemp0+1  					; bump the index
		iny
		iny
		sty 	zTemp0+1
		cpy 	#8 							; done all 4
		bne 	_LCLWNLoop1
_LCLWNOutDigit:
		ora 	#'0'
		jsr 	LCLWrite
		rts

_LCLWNTable:
		.word 	10000
		.word 	1000
		.word 	100
		.word 	10

; ************************************************************************************************
;
;								   LIST syntax colouring
;
; ************************************************************************************************

CLIDefault:
		.byte	CONBrown, CONYellow, CONRed, CONOrange, CONCyan, CONYellow, CONPink, CONWhite

		.send code

; ************************************************************************************************
;
;								  LIST syntax values (in control storage)
;
; ************************************************************************************************

CLIFComment = ControlStorage + 0
CLIBComment = ControlStorage + 1
CLILineNumber = ControlStorage + 2
CLIToken = ControlStorage + 3
CLIConstant = ControlStorage + 4
CLIIdentifier = ControlStorage + 5
CLIPunctuation = ControlStorage + 6
CLIData = ControlStorage + 7

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;		26/11/22 		Added LCLWriteColour to minimise colour changes, e.g. not one for each
;						punctuation character etc.
;		26/11/22 		Tweaked coloring of constants (test for 0-9 and . in punctuation)
;		26/11/22 		Highlighting SOL comments
;		27/11/22 		Added LCLWriteNumberXA to decouple module from the main body of code
;						(was using ConvertInt16)
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		searchtokens.asm
;		Purpose:	Seach token table for a specific identifier
;		Created:	19th September 2022
;		Reviewed: 	23rd November 2022
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;	Search the token table at YA for the currently selected identifier. Returns CS and token ID
; 	in A if found, CC if not found
;
; ************************************************************************************************

TOKSearchTable:
		sty 	zTemp0+1 					; (zTemp0),y points to current token being tested.
		sta 	zTemp0
		ldy 	#0
		lda 	#$80 						; token # so we know which one we are looking at
		sta 	zTemp1
		;
		;		Token search loop
		;
_TSTLoop:
		lda 	(zTemp0),y 					; length, 0 (skip) -ve (end)
		bmi 	_TSTFail 					; -ve = end of table, so fail.
		beq 	_TSTNext 					; zero, check next as it's a dummy (e.g. EOL, SHIFT)
		;
		; 		Hash match ?
		;
		iny 								; get the hash
		lda 	(zTemp0),y
		dey
		cmp 	identHash 					; check they match with the identifier hash, if not go to next
		bne 	_TSTNext
		;
		;		Length match
		;
		lda 	identTypeEnd 				; get length of identifier from end-start
		sec
		sbc 	identStart
		cmp 	(zTemp0),y 					; compare against the length in the table, no match, then return.
		bne 	_TSTNext
		;
		;		Hash and length match, now compare actual text
		;
		phy 								; save Y , we might fail to match.
		iny 								; point to text
		iny
		ldx 	identStart 					; offset in line buffer in X
_TSTCompareName:
		lda 	lineBuffer,x 				; compare text.
		cmp 	(zTemp0),y
		bne 	_TSTNextPullY 				; fail, pullY and do next
		inx
		iny
		cpx 	identTypeEnd 				; complete match.
		bne 	_TSTCompareName
		ply 								; throw Y
		lda 	zTemp1 						; get token #
		sec 								; return with CS = passed.
		rts
		;
		;		Go onto next token, optionally restoring Y
		;
_TSTNextPullY:
		ply 								; restore current, fall through.
		;
		;		Go to next token.
		;
_TSTNext:
		inc 	zTemp1 						; token counter
		tya
		clc
		adc 	(zTemp0),y 					; add [Length] + 2 to Y
		inc 	a 							; +1
		inc 	a 							; +2
		tay
		bpl 	_TSTLoop 					; if Y < $80 loop back
		;
		;		The index into the token table is > 128, we now adjust this so
		;		this value is always < 128, allowing us to use fast index lookups.
		;
		tya 								; add Y to zTemp0 and reset Y
		ldy 	#0   						; so we can use Y to search fast
		clc  								; but have tables > 255 bytes
		adc 	zTemp0 						; when Y gets >= 128 we reset Y
		sta 	zTemp0 						; and adjust the table pointer/
		bcc 	_TSTLoop
		inc 	zTemp0+1
		bra 	_TSTLoop

_TSTFail:
		clc
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		tokenise.asm
;		Purpose:	Tokenise Line
;		Created:	18th September 2022
;		Reviewed: 	23rd November 2022
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code


; ************************************************************************************************
;
;								Tokenise ASCIIZ line in lineBuffer
;
; ************************************************************************************************

Export_TKTokeniseLine:
		;
		;		Make the line buffer UpperCase outside quoted strings
		;
		jsr 	LCLFixLineBufferCase 		; fix line case
		;
		;		Erase the tokenised line to empty
		;
		lda 	#3 							; reset the token buffer to empty
		sta 	tokenOffset 				; (3 bytes for line number & offset)
		stz 	tokenLineNumber
		stz 	tokenLineNumber+1
		;
		;		Find the first non space character
		;
		ldx 	#$FF
_TKFindFirst:
		inx
		lda 	lineBuffer,x
		beq 	_TKExit
		cmp 	#' '
		bcc 	_TKFindFirst
		;
		;		If it is 0-9 extract a 2 byte integer into the token line number
		;		(because the input line is an editing one)
		;
		cmp 	#'0'
		bcc 	_TKNoLineNumber
		cmp 	#'9'+1
		bcs 	_TKNoLineNumber
		jsr 	TOKExtractLineNumber
_TKNoLineNumber:
		;----------------------------------------------------------------------------------------
		;
		;							Main tokenising loop
		;
		;----------------------------------------------------------------------------------------

_TKTokeniseLoop:
		lda 	lineBuffer,x 				; next character, exit if zero EOL.
		beq 	_TKExit
		inx
		cmp 	#' '
		beq 	_TKTokeniseLoop 			; keep looping if space found.
		dex 								; undo last get, A contains character, X is position.
		;
		cmp 	#'_'						; _ A-Z is identifier *or* token
		beq 	_TKTokeniseIdentifier 		; (already case converted outside string constants)
		cmp 	#'A'
		bcc 	_TKTokenisePunctuation
		cmp 	#'Z'+1
		bcc 	_TKTokeniseIdentifier

		;----------------------------------------------------------------------------------------
		;
		;		So we now have a punctuation character. Special cases are those >= 64 and < or >
		;		followed by = > or < and quoted strings.
		;
		; 		For 64 conversion see the punctuation.ods
		;
		;----------------------------------------------------------------------------------------

_TKTokenisePunctuation:
		cmp 	#'"'						; quoted string ?
		beq 	_TKString
		cmp 	#'$'						; hexadecimal constant ($ only appears at end of identifiers)
		beq 	_TKHexConstant
		cmp 	#'<' 						; check for < > handlers - these are for <> <= >= >> <<
		beq 	_TKCheckDouble
		cmp 	#'>'
		beq 	_TKCheckDouble
_TKStandardPunctuation:
		lda 	lineBuffer,x 				; get the punctuation token back.
		cmp 	#64 						; are we >= 64
		bcc 	_TKNoShift
		pha 								; save. we are about to convert this punctuation token from
											; 64-127 to 16-31 (see punctuation.ods)
		and 	#7 							; lower 3 bits in zTemp0
		sta 	zTemp0
		pla
		and 	#32 						; bit 5
		lsr 	a 							; shift into bit 3
		lsr 	a
		ora 	zTemp0
		ora 	#$10						; now in the range 16-31
_TKNoShift:
		jsr 	TOKWriteByte 				; write the punctuation character
		inx 								; consume the character
		cmp 	#KWD_QUOTE 					; quote found ?
		bne 	_TKTokeniseLoop 			; and loop round again.
		jsr 	TOKCheckComment 			; comment checl
		bra 	_TKTokeniseLoop
		;
		;		String tokeniser.
		;
_TKString: 									; tokenise a string "Hello world"
		jsr 	TOKTokenString
		bra 	_TKTokeniseLoop
_TKHexConstant: 							; tokenise hex constant #A277
		jsr 	TOKHexConstant
		bra 	_TKTokeniseLoop

		;----------------------------------------------------------------------------------------
		;
		;		Exit point, writes EOL and returns
		;
		;----------------------------------------------------------------------------------------

_TKExit:lda 	#KWC_EOL 					; write end of line byte
		jsr 	TOKWriteByte
		rts

		;----------------------------------------------------------------------------------------
		;
		;		Have < or >. Check following character is < = >. These are mapped onto
		;		codes 0-5 for << >> <= >= <> , see punctuation.ods
		;
		;----------------------------------------------------------------------------------------

_TKCheckDouble:
		lda 	lineBuffer+1,x 				; get next character
		cmp 	#'<'						; if not < = > which are ASCII consecutive go back
		bcc 	_TKStandardPunctuation 		; and do the normal punctuation handler.
		cmp 	#'>'+1
		bcs 	_TKStandardPunctuation
		;
		lda 	lineBuffer,x 				; this is < (60) or > (62)
		and 	#2 							; now < (0) or > (2)
		asl 	a 							; now < (0) or > (4), CC also
		adc 	lineBuffer+1,x 				; add < = > codes - < code
		sec
		sbc 	#'<'
		jsr 	TOKWriteByte 				; this is in the range 0-7
		inx 								; consume both
		inx
		bra 	_TKTokeniseLoop

		;----------------------------------------------------------------------------------------
		;
		;		Found _ or A..Z, which means an identifier or a token.
		;
		;----------------------------------------------------------------------------------------

_TKTokeniseIdentifier:
		stx 	identStart 					; save start
		stz 	identTypeByte 				; zero the type byte
_TKCheckLoop:
		inx 								; look at next, we know first is identifier already.
		lda  	lineBuffer,x
		cmp 	#"_" 						; legal char _ 0-9 A-Z
		beq 	_TKCheckLoop
		cmp	 	#"0"
		bcc 	_TKEndIdentifier
		cmp 	#"9"+1
		bcc 	_TKCheckLoop
		cmp	 	#"A"
		bcc 	_TKEndIdentifier
		cmp 	#"Z"+1
		bcc 	_TKCheckLoop
_TKEndIdentifier:
		;
		;		Look for # or $ type
		;
		stx 	identTypeStart 				; save start of type text (if any !)
		;
		ldy 	#$08 						; this is the identifier type byte for #
		cmp 	#"#"						; followed by #
		beq 	_TKHasTypeCharacter
		ldy 	#$10 						; this is the identifier type byte for $
		cmp 	#"$"						; followed by $ or #
		bne 	_TKNoTypeCharacter
_TKHasTypeCharacter:
		sty 	identTypeByte 				; has # or $, save the type
		inx 								; consume the type character
		lda 	lineBuffer,x
		;
		;		Look for array
		;
_TKNoTypeCharacter:
		cmp 	#"("						; is it open parenthesis (e.g. array)
		bne 	_TKNoArray
		inx 								; skip the (
		lda 	identTypeByte 				; set bit 2 (e.g. array) in type byte
		ora 	#$04
		sta 	identTypeByte
_TKNoArray:
		stx 	identTypeEnd 				; save end marker, e.g. continue from here.
		jsr 	TOKCalculateHash 			; calculate the has for those tokens

		;----------------------------------------------------------------------------------------
		;
		;			Search the token tables, to see if this is actually a keyword.
		;			*all* keywords are identifier-compliant.
		;
		;----------------------------------------------------------------------------------------

checktokens .macro
		ldy 	#(\1) >> 8
		lda 	#(\1) & $FF
		jsr 	TOKSearchTable
		.endm

		.checktokens KeywordSet0			; check the three token tables for the keyword.
		ldx 	#0
		bcs 	_TKFoundToken
		.checktokens KeywordSet1
		ldx 	#$81
		bcs 	_TKFoundToken
		.checktokens KeywordSet2
		ldx 	#$82
		bcs 	_TKFoundToken

		;----------------------------------------------------------------------------------------
		;
		;			 No shift found, so it's a procedure or a variable declaration
		;
		;----------------------------------------------------------------------------------------

		jsr 	TOKCheckCreateVariableRecord ; failed all, it's a variable, create record if does not exist.
		ldx 	identTypeEnd 				; X points to following byte
		jmp 	_TKTokeniseLoop 			; and go round again.

		;----------------------------------------------------------------------------------------
		;
		;			Found a token, X contains the shift ($8x or 0), A the token
		;
		;----------------------------------------------------------------------------------------

_TKFoundToken:
		pha 								; save token
		txa 								; shift in X, is there one ?
		beq 	_TKNoTShift
		jsr 	TOKWriteByte 				; if so, write it out
_TKNoTShift:
		pla 								; restore and write token
		jsr 	TOKWriteByte
		cpx 	#0 							; check for REM and '
		bne 	_TKNotRem 			 		; not shifted ?
		cmp 	#KWD_REM
		bne 	_TKNotRem
		ldx 	identTypeEnd 				; check if comment follows.
		jsr 	TOKCheckComment
		jmp 	_TKTokeniseLoop

_TKNotRem:
		ldx 	identTypeEnd 				; X points to following byte
		jmp 	_TKTokeniseLoop 			; and go round again.

; ************************************************************************************************
;
;		Comment check for REM and ' - check if quoted string/EOL follows, if not, insert
;		rest of line as comment.
;
; ************************************************************************************************

TOKCheckComment:
		lda 	lineBuffer,x 				; skip over space
		inx
		cmp 	#' '
		beq 	TOKCheckComment
		dex 								; first non space character
		cmp 	#'"'						; quote mark
		beq 	_TOKCCExit 					; then we are okay
		cmp 	#0 							; EOL
		beq 	_TOKCCExit 					; then we are okay
		phx
_TOKCCLowerCase: 							; the pre-processing capitalises it. I did think
		lda 	lineBuffer,x 				; about making it lower case it all, but I thought
		cmp 	#"A"		 				; that was a bit risky. So it's converted to L/C here.
		bcc 	_TOKKCNotUC
		cmp 	#"Z"+1
		bcs 	_TOKKCNotUC
		eor 	#$20
		sta 	lineBuffer,x
_TOKKCNotUC:
		inx
		cmp 	#0
		bne 	_TOKCCLowerCase
		plx
		dex 								; tokenise string expects initial skip.
		jsr 	TOKTokenString 				; tokenise rest of line as a string.
_TOKCCExit:
		rts

; ************************************************************************************************
;
;									Tokenise a string.
;
; ************************************************************************************************

TOKTokenString:
		lda 	#KWC_STRING 				; string token.
		jsr 	TOKWriteByte
		inx									; start of quoted string.
		phx 								; push start of string on top
		dex 								; because we pre-increment
_TSFindEnd:
		inx
		lda 	lineBuffer,x 				; next character
		beq 	_TSEndOfString 				; no matching quote, we don't mind.
		cmp 	#'"' 						; go back if quote not found
		bne 	_TSFindEnd
		;
_TSEndOfString:
		ply  								; so now Y is first character, X is character after end.
		pha 								; save terminating character
		jsr 	TOKWriteBlockXY 			; write X to Y as a data block
		pla 								; terminating character
		beq 	_TSNotQuote					; if it wasn't EOS skip it
		inx
_TSNotQuote:
		rts

; ************************************************************************************************
;
;				Write Y to X with a trailing NULL - used for any block data.
;
; ************************************************************************************************

TOKWriteBlockXY:
		stx 	zTemp0 						; save end character
		tya 								; use 2's complement to work out the byte size
		eor 	#$FF
		sec
		adc 	zTemp0
		inc 	a 							; one extra for NULL
		jsr 	TOKWriteByte
_TOBlockLoop:
		cpy 	zTemp0 						; exit if reached the end
		beq 	_TOBlockExit
		lda 	lineBuffer,y 				; write byte out.
		jsr 	TOKWriteByte
		iny
		bra 	_TOBlockLoop
_TOBlockExit:
		lda 	#0 							; add NULL.
		jsr 	TOKWriteByte
		rts

; ************************************************************************************************
;
;									Tokenise a hex constant
;
; ************************************************************************************************

TOKHexConstant:
		lda 	#KWC_HEXCONST 				; hex constant token.
		jsr 	TOKWriteByte
		inx									; start of quoted string.
		phx 								; push start of constant on top
		dex
_THFindLoop:
		inx 	 							; this is stored in a block, so find out how long
		lda 	lineBuffer,x 				; the hex constant is.
		cmp 	#"0"
		bcc 	_THFoundEnd
		cmp 	#"9"+1
		bcc 	_THFindLoop
		cmp 	#"A"
		bcc 	_THFoundEnd
		cmp 	#"F"+1
		bcc 	_THFindLoop
_THFoundEnd:
		ply 								; restore start
		jsr 	TOKWriteBlockXY 			; output the block
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
; 		17/12/22 		Added TOKCheckComment which checks for non-quoted comments. Inserted at
;						2 positions are checks - end of tokenising and end of punctuation processing.
; 		30/12/22 		dex before call to tokenise just before _TOKCCExit - rem abcd was tokenising
;						as rem "bcd" e.g. missing the first character.
; 		04/03/23 		Changed to allow modification to colourising of listings.
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		utility.asm
;		Purpose:	Tokeniser Utilities
;		Created:	19th September 2022
;		Reviewed: 	23rd November 2022
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;					   Calculate Hash of part of buffer selected for identifier
;
; ************************************************************************************************

TOKCalculateHash:
		phx
		ldx 	identStart 					; needs to be same as in tokens.py - simple sum at present.
		lda 	#0
_TCHLoop:
		clc
		adc 	lineBuffer,x
		inx
		cpx 	identTypeEnd 				; do the whole thing including type and array markers.
		bne 	_TCHLoop
		sta 	identHash 					; save the hash
		plx
		rts

; ************************************************************************************************
;
;					   Fix case of line in LineBuffer to U/C outside quotes
;
; ************************************************************************************************

LCLFixLineBufferCase:
		ldx 	#0
		;
		;		Loop (out of quotes)
		;
_FLBCLoop:
		lda 	lineBuffer,x 				; get next character
		beq 	_FLBCExit 					; end of string.
		cmp 	#'"'						; quote, go to in quotes
		beq 	_FLBCInQuotes
		inx
		cmp 	#'a'						; needs capitalising ?
		bcc 	_FLBCLoop
		cmp 	#'z'+1
		bcs 	_FLBCLoop
		sec 								; make U/C
		sbc 	#32
		sta	 	lineBuffer-1,x 				; write back
		bra 	_FLBCLoop
		;
		;		Loop (in quotes)
		;
_FLBCInQuotes:
		inx 								; advance
		lda 	lineBuffer,x 				; get next
		beq 	_FLBCExit 					; exit on EOS
		cmp 	#'"' 				 		; until " found
		bne 	_FLBCInQuotes
		inx 								; skip over it
		bra 	_FLBCLoop
		;
_FLBCExit:
		rts

; ************************************************************************************************
;
;		  Extract line number from lineBuffer,x - we know there's at least *one* digit
;		 				Does not zero the initial value (in tokenLineNumber)
;
; ************************************************************************************************

TOKExtractLineNumber:
		lda 	tokenLineNumber+1 			; push current value on stack
		pha
		lda 	tokenLineNumber
		pha
		jsr 	_LCLNTimes2 				; line # x 2
		jsr 	_LCLNTimes2 				; line # x 4
		;
		clc 								; add stacked value
		pla
		adc 	tokenLineNumber
		sta 	tokenLineNumber
		pla
		adc 	tokenLineNumber+1
		sta 	tokenLineNumber+1 			; line # x 5
		jsr 	_LCLNTimes2 				; line # x 10
		;
		lda 	lineBuffer,x 				; get and consume character
		inx
		and 	#15 						; add to line #
		clc
		adc 	tokenLineNumber
		sta 	tokenLineNumber
		bcc 	_TLENNoCarry
		inc 	tokenLineNumber+1
_TLENNoCarry:
		lda 	lineBuffer,x 				; more digits ?
		cmp 	#'0'
		bcc 	_TLENExit
		cmp 	#'9'+1
		bcc 	TOKExtractLineNumber
_TLENExit:
		rts

_LCLNTimes2:
		asl 	tokenLineNumber 			; doubles tokenLineNumber.
		rol 	tokenLineNumber+1
		rts

; ************************************************************************************************
;
;								Write Byte to tokenBuffer
;
; ************************************************************************************************

TOKWriteByte:
		phx
		ldx 	tokenOffset 				; next slot to write to
		sta 	tokenOffset,x 				; write byte out
		inc 	tokenOffset 				; advance slot.
		plx
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		variablerecord.asm
;		Purpose:	Handle a possibly new variable identifier
;		Created:	19th September 2022
;		Reviewed: 	26th November 2022
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;		Check to see if the currently specified identifier is in the table.  If not, create it
; 		as specified.
;
;		Then compile a reference to it in the tokenised code.
;
; ************************************************************************************************

TOKCheckCreateVariableRecord:
		.set16 	zTemp0,VariableSpace 		; initialise pointer
		;
		;		Search the variable table to see if it already exists
		;
_CCVSearch:
		lda 	(zTemp0) 					; end of list
		beq 	_CCVFail
		ldy 	#1 							; read the hash
		lda 	(zTemp0),y 					; does it match ?
		cmp 	identHash 	  				; if not, try the next.
		bne 	_CCVNext
		;
		;		Compare the identifier to the variable record.
		;
		ldy 	#8 							; name in variable record
		ldx 	identStart
_CCVCompare:
		lda 	lineBuffer,x 				; xor them. zero if the same, except
		eor 	(zTemp0),y 					; bit 7 is used for EOS.
		inx 								; advance pointers
		iny
		asl 	a 							; A = 0 if they match, CS if end.
		bne 	_CCVNext  					; didn't match go to next.
		bcc 	_CCVCompare 				; not finished yet.
		;
		cpx 	identTypeEnd 				; matched whole thing ?
		beq 	_CCVFound 					; yes, we were successful
		;
		;		Next Record
		;
_CCVNext:
		clc 								; go to next record.
		lda 	(zTemp0) 					; add offset to pointer
		adc 	zTemp0
		sta 	zTemp0
		bcc 	_CCVSearch
		inc 	zTemp0+1
		bra 	_CCVSearch
		;
		;		Could not find the identifier. zTemp0 points to the free space in the
		;		variable storage, conveniently.
		;
		;		So we create a new record.
		;
_CCVFail:
		ldy 	#1 							; create the new record. Offset 1 is hash
		lda 	identHash
		sta 	(zTemp0),y
		iny 								; offset 2 is the type byte
		lda 	identTypeByte
		sta 	(zTemp0),y
		iny
_CCVData:
		lda 	#0 							; erase data 3-7 (the 5 value bytes)
		sta 	(zTemp0),y
		iny
		cpy 	#8
		bcc 	_CCVData
		ldx 	identStart 					; copy name into 8 on.
_CCVCopyName:
		lda 	lineBuffer,x
		sta 	(zTemp0),y
		inx
		iny
		cpx 	identTypeEnd
		bne 	_CCVCopyName
		;
		tya 								; patch offset
		sta 	(zTemp0)
		lda 	#0 							; offset for next is zero.
		sta 	(zTemp0),y
		;
		dey
		lda 	(zTemp0),y 					; set bit 7 of last bit
		ora 	#$80
		sta 	(zTemp0),y
		;
		;
		;		Variable record at zTemp0 - output to tokeniser
		;
_CCVFound:
		lda 	zTemp0+1 					; write out MSB
		sec
		sbc 	#(VariableSpace >> 8) 		; offset from the start of the variable token
		ora 	#$40 						; make it a writeable token $4000-$7FFF
		jsr 	TOKWriteByte
		lda 	zTemp0 						; write out LSB
		jsr 	TOKWriteByte
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
