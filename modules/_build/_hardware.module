;
;	This file is automatically generated
;

hardwareIntegrated=1

; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		colours.inc
;		Purpose:	Console colour scheme
;		Created:	17th November 2022
;		Reviewed:
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

CONBlack = 0
CONGrey = 1
CONDarkBlue = 2
CONGreen = 3
CONPurple = 4
CONBrown = 5
CONOrange = 6
CONCyan = 7
CONDarkGrey = 8
CONLightGrey = 9
CONLightBlue = 10
CONLightGreen = 11
CONPink = 12
CONRed = 13
CONYellow = 14
CONWhite = 15

CONForeground = CONLightGrey
CONBackground = CONDarkBlue

CLICommandLine = CONLightGrey

CLIFComment = CONBrown
CLIBComment = CONYellow

CLILineNumber = CONRed
CLIToken = CONOrange
CLIConstant = CONCyan
CLIIdentifier = CONYellow
CLIPunctuation = CONPink
CLIData = CONWhite

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		charout.asm
;		Purpose:	Output character
;		Created:	14th November 2022
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;									Output Character A
;
;		control+'a'  ($01)  begin
;		control+'b'  ($02)  left
;		control+'e'  ($05)  end
;		control+'f'  ($06)  right
;		control+'h'  ($08)  backspace
;		control+'i'  ($09)  tab
;		control+'l'  ($0C)  ff
;		control+'m'  ($0D)  cr
;		control+'n'  ($0E)  down
;		control+'p'  ($10)  up
;					  $8x 	set background
;					  $9x 	set foreground
;
; ************************************************************************************************

Export_EXTPrintCharacter:
PAGEDPrintCharacter:
		pha
		phx
		phy

		ldx 	1
		phx

		ldy 	EXTColumn 					; Y = Row, e.g. points to character.

		ora 	#$00 						; check $80-$FF
		bmi 	_EXPCColour
		cmp 	#$20 						; check $00-$1F
		bcc 	_EXPCControl
		;
		;		Handle character.
		;
		ldx 	#2 							; select char memory
		stx 	1
		sta 	(EXTAddress),y
		inc 	1 							; select colour memory
		lda 	EXTTextColour
		sta 	(EXTAddress),y
		;
		iny 								; advance horizontal position
		sty 	EXTColumn
		cpy 	EXTScreenWidth 				; reached RHS ?
		bcc 	_EXPCExit 					; no, then exit.
		;
		;		Carriage return.
		;
_EXPCCRLF:
		inc 	EXTRow  					; bump row
		stz 	EXTColumn 					; back to column 0
		lda 	EXTRow 						; check if reached the bottom ?
		cmp 	EXTScreenHeight 			; if so, then scroll.
		beq 	_EXPCScroll
		;
		clc 								; add width to address.
		lda 	EXTAddress
		adc 	EXTScreenWidth
		sta 	EXTAddress
		bcc 	_EXPCExit
		inc 	EXTAddress+1
		bra 	_EXPCExit
		;
		;		Move left / beginning of line.
		;
_EXPCLeft:
		dec 	EXTColumn
		bpl 	_EXPCExit
_EXPCBegin:
		stz 	EXTColumn
		bra 	_EXPCExit
		;
		;		Scroll screen up, blank line.
		;
_EXPCScroll:
		dec 	EXTRow 						; the height-1 th line.
		jsr 	EXTScreenScroll 			; scroll the screen
		bra 	_EXPCExit
		;
		;		Set FGR/BGR colour
		;
_EXPCColour:
		cmp 	#$A0						; 80-9F set foreground/background
		bcs 	_EXPCExit
		jsr 	_EXPCHandleColour
		bra 	_EXPCExit
		;
		;		Handle control characters 00-1F 80-FF
		;
_EXPCControl:
		cmp 	#$11 						; only handle 00-10.
		bcs 	_EXPCExit
		asl 	a 							; double into X
		tax
		jmp 	(_EXPCActionTable,x) 		; and execute code.
		;
		;		Up
		;
_EXPCUp:
		lda 	EXTRow 						; already at top ?
		beq 	_EXPCExit
		dec 	EXTRow 						; up one in position/address
		sec
		lda 	EXTAddress
		sbc 	EXTScreenWidth
		sta 	EXTAddress
		bcs 	_EXPCExit
		dec 	EXTAddress+1
		bra 	_EXPCExit
		;
		;		Right/End of line
		;
_EXPCRight:
		iny
		sty 	EXTColumn
		cpy 	EXTScreenWidth
		bne 	_EXPCExit
		dey
_EXPCSetColumnY: 							; set column to Y
		sty 	EXTColumn
		;
		;		Exit
		;
_EXPCExit:
		jsr 	EXTSetHardwareCursor 		; place the physical cursor.
		pla
		sta 	1
		ply
		plx
		pla
		rts
		;
		;		Clear
		;
_EXPCClearScreen:
		jsr		EXTClearScreenCode
		bra 	_EXPCExit
		;
		;		Down
		;
_EXPCDown:
		lda 	EXTScreenHeight 			; at the bottom
		dec 	a
		cmp 	EXTRow
		beq 	_EXPCExit
		inc 	EXTRow 						; down one in position/address
		clc
		lda 	EXTAddress
		adc 	EXTScreenWidth
		sta 	EXTAddress
		bcc 	_EXPCExit
		inc 	EXTAddress+1
		bra 	_EXPCExit
		;
		;		Tab
		;
_EXPCTab:
		lda 	EXTColumn 					; next tab stop
		and 	#$F8
		clc
		adc 	#8
		sta 	EXTColumn
		cmp 	EXTScreenWidth 				; too far, stick end of line.
		bcc 	_EXPCExit
		bra 	_EXPCEnd
		;
		;		Backspace
		;
_EXPCBackSpace:
		dey
		bmi 	_EXPCExit
		dec 	EXTColumn
		lda 	#2
		sta 	1
		lda 	#32
		sta 	(EXTAddress),y
		bra 	_EXPCExit
		;
		;		End of line
		;
_EXPCEnd:
		lda 	#2 							; access text screen
		sta 	1
		ldy 	EXTScreenWidth 				; point to last character
		dey
_EXPCEndSearch:
		dey 								; if past start, move to col 0.
		bmi 	_EXPCFound
		lda 	(EXTAddress),y 				; keep going back till non space found
		cmp 	#' '
		beq 	_EXPCEndSearch
_EXPCFound:
		iny 								; move to following cell.
		bra 	_EXPCSetColumnY
		;
		;		Clear to end of line
		;
_EXPCClearEOL:
		lda 	#2 							; access character RAM
		sta 	1
		lda 	#' ' 						; write space
		sta 	(EXTAddress),y
		iny
		cpy 	EXTScreenWidth 				; until RHS of screen.
		bcc 	_EXPCClearEOL
		bra 	_EXPCExit
		;
		;		Vector table for CTRL+A to CTRL+P
		;
_EXPCActionTable:
		.word 	_EXPCExit 					; 00
		.word 	_EXPCBegin 					; 01 A Start of Line
		.word 	_EXPCLeft 					; 02 B Left
		.word 	_EXPCExit 					; 03 <Break>
		.word 	_EXPCExit 					; 04
		.word 	_EXPCEnd 					; 05 E End of Line
		.word 	_EXPCRight 					; 06 F Right
		.word 	_EXPCExit 					; 07
		.word 	_EXPCBackspace 				; 08 H Backspace
		.word 	_EXPCTab 					; 09 I Tab
		.word 	_EXPCExit 					; 0A
		.word 	_EXPCClearEOL 				; 0B K Clear to EOL
		.word 	_EXPCClearScreen			; 0C L CLS
		.word 	_EXPCCRLF 					; 0D M CR/LF
		.word 	_EXPCDown 					; 0E N Down
		.word 	_EXPCExit 					; 0F
		.word 	_EXPCUp 					; 10 P Up
;
;		Handle colour change (80-9F)
;
_EXPCHandleColour
		cmp 	#$90 						; 8x foreground 9x background
		bcs 	_EXPCBackground
		;
		asl 	a 							; shift it 4 bits to the right.
		asl 	a
		asl 	a
		asl 	a
		ldx 	#$0F 						; Mask in X
_EXPCUpdate:
		pha 								; save new colour
		txa 								; get mask
		and 	EXTTextColour 				; mask out old.
		sta 	EXTTextColour
		pla 								; or in new colour
		ora 	EXTTextColour
		sta 	EXTTextColour
		rts
_EXPCBackground:
		and 	#$0F 						; get the colour
		ldx 	#$F0 						; mask
		bra 	_EXPCUpdate

EXTScreenScroll:
		lda 	#2 							; select text page
		sta 	1
		lda		#32 						; fill with space
		jsr 	EXTScrollFill
		inc 	1 							; select colour page
		lda 	EXTTextColour
		jsr 	EXTScrollFill
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;		27/11/22 		Changed End so to end of text line, e.g. after last non space
;						Added Ctrl+K delete to EOL suggested by Jessie O.
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		cls.asm
;		Purpose:	Clear Screen
;		Created:	14th November 2022
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;									Clear the display
;
; ************************************************************************************************

EXTClearScreenCode:
		;
		lda 	#2 							; select text page
		sta 	1
		lda		#32 						; fill with space
		jsr 	_EXTCSFill
		inc 	1 							; select colour page
		lda 	EXTTextColour
		jsr 	_EXTCSFill
		bra 	EXTHomeCursor
		;
		;		Fill all text memory C000-D2FF with A - page set by caller
		;
_EXTCSFill:
		tax
		lda 	#EXTMemory & $FF
		sta 	EXTAddress
		lda 	#EXTMemory >> 8
		sta 	EXTAddress+1
_EXTCSFill1:
		ldy 	#0
		txa
_EXTCSFill2:
		sta 	(EXTAddress),y
		iny
		bne 	_EXTCSFill2
		inc 	EXTAddress+1
		lda 	EXTAddress+1
		cmp 	#$D2
		bne 	_EXTCSFill1
		txa
_EXTCSFill3:
		sta 	(EXTAddress),y
		iny
		cpy 	#$C0
		bne 	_EXTCSFill3
		rts

; ************************************************************************************************
;
;									Home the cursor
;
; ************************************************************************************************

EXTHomeCursor:
		stz 	EXTRow 						; reset row & column
		stz 	EXTColumn
		lda 	#EXTMemory & $FF 			; set address
		sta 	EXTAddress
		lda 	#EXTMemory >> 8
		sta 	EXTAddress+1

; ************************************************************************************************
;
;									Position the cursor
;
; ************************************************************************************************

EXTSetHardwareCursor:
		stz 	1 							; I/O Page zero
		lda 	#1+4 						; enable cursor
		sta 	$D010
		lda 	#179
		sta 	$D012
		lda 	EXTColumn
		sta 	$D014 						; set cursor position
		stz 	$D015
		lda 	EXTRow
		sta 	$D016
		stz 	$D017
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		input.asm
;		Purpose:	Input one line, screen scrape
;		Created:	17th November 2022
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;									Input line into lineBuffer
;
;		This can use ExtInputSingleCharacter *or* $FFCF, the screen editor or similar.
;
; ************************************************************************************************

Export_EXTInputLine:
		pha
		phx
		phy

		lda 	1 							; save I/O page
		pha
_EILLoop:
		jsr 	PagedInputSingleCharacter
		cmp 	#13 						; scrape line if exit.
		beq 	_EILExit
		cmp 	#4 							; Ctrl+D delete at cursor
		beq 	_EILDelete
		cmp 	#8 							; Ctrl+H backspace
		beq 	_EILBackspace
		cmp 	#' '						; < space, print it
		bcc 	_EILPrintLoop
		cmp 	#$7F 						; if -ve print it
		bcs 	_EILPrintLoop
		;
		pha 								; save character
		lda 	#2  						; insert a space
		sta 	1
		jsr 	EXTILInsert 				; insert in text screen
		inc 	1
		jsr 	EXTILInsert 				; insert in colour screen
		pla 								; get character back.
_EILPrintLoop:
		jsr 	PagedPrintCharacter
		bra 	_EILLoop
		rts
		;
		;		Backspace
		;
_EILBackspace:
		lda 	EXTColumn					; can we backspace ?
		beq 	_EILLoop
		lda 	#2 							; move cursor left
		jsr 	PagedPrintCharacter
_EILDelete
		;
		lda 	#2 							; text block
		sta 	1
		lda 	#' ' 						; backspace text.
		jsr 	EXTILDelete
		;
		inc 	1 							; colour block
		ldy 	EXTColumn 					; get attribute of last character
		dey
		lda 	(EXTAddress),y
		jsr 	EXTILDelete 				; backspace attribute
		bra 	_EILLoop 					; and go round.
		;
		;		Copy line from screen into input buffer and right trim.
		;
_EILExit:
		lda 	#2 							; switch to page 2
		sta 	1
		ldy 	#0 							; copy current line into buffer.
_EILScrapeLine:
		lda 	(EXTAddress),y
		sta 	lineBuffer,y
		iny
		cpy 	EXTScreenWidth
		bne 	_EILScrapeLine
		;
_EILTrimSpaces: 							; right trim
		dey
		beq 	_EILEndTrim
		lda 	lineBuffer,y
		cmp 	#' '
		beq 	_EILTrimSpaces
		iny 								; trim after non space character.
_EILEndTrim:
		lda 	#0 							; trim here.
		sta 	lineBuffer,y
		lda 	#13 						; echo the RETURN
		jsr 	PagedPrintCharacter
		pla 								; reset I/O page
		sta 	1

		ply
		plx
		pla
		rts
;
;		Backspace from current position, put A on the end
;
EXTILDelete:
		pha 								; save the new character
		ldy 	EXTColumn 					; start copying from here.
_EXTDLoop:
		iny 								; copy one byte down.
		lda 	(EXTAddress),y
		dey
		sta 	(EXTAddress),y
		;
		iny 								; do till end of line.
		cpy 	EXTScreenWidth
		bcc 	_EXTDLoop
		;
		dey 	 							; write in last slot.
		pla
		sta 	(EXTAddress),y
		rts
;
;		Insert at current position.
;
EXTILInsert:
		ldy 	EXTScreenWidth 				; end position
_EXTILoop:
		dey 								; back one
		cpy 	EXTColumn 					; exit if reached insert point.
		beq 	_EXTIExit
		dey 								; copy one byte up.
		lda 	(EXTAddress),y
		iny
		sta 	(EXTAddress),y
		bra 	_EXTILoop
_EXTIExit:
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;		27/11/22 		Added Ctrl+D Delete at character
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		scroll.asm
;		Purpose:	Scroll one part of screen
;		Created:	16th November 2022
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;						Scroll screen in current i/o page, fill with A
;
; ************************************************************************************************

EXTScrollFill:
		tax									; save value to fill with

		lda 	zTemp0 						; save zTemp0 (dest) zTemp1 (src)
		pha
		lda 	zTemp0+1
		pha
		lda 	zTemp1
		pha
		lda 	zTemp1+1
		pha

		lda 	#$C0 						; copy from C000+length to C000
		sta 	zTemp0+1
		sta 	zTemp1+1
		stz 	zTemp0
		lda 	EXTScreenWidth
		sta 	zTemp1
		ldy 	#0
_EXSFCopy1: 								; do one page
		lda 	(zTemp1),y
		sta 	(zTemp0),y
		iny
		bne 	_EXSFCopy1
		inc 	zTemp0+1 					; next page
		inc 	zTemp1+1
		lda 	zTemp1+1
		cmp 	#$D3
		bne 	_EXSFCopy1

		ldy 	EXTScreenWidth 				; blank the bottom line.
		txa
_EXSFFill1:
		dey
		sta 	(EXTAddress),y
		cpy 	#0
		bpl 	_EXSFFill1

		pla
		sta 	zTemp1+1
		pla
		sta 	zTemp1
		pla
		sta 	zTemp0+1
		pla
		sta 	zTemp0

		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		data.asm
;		Purpose:	Console Data
;		Created:	14th November 2022
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section storage

EXTMemory = $C000
EXTTextPage = $02
EXTColourPage = $03

EXTDummySpace = 1 							; fake-space for CR character.
EXTCBlack = 0

EXTRow: 									; current row
		.fill 	1
EXTColumn: 									; current column
		.fill 	1
EXTTextColour: 								; current colour
		.fill 	1
EXTScreenWidth:	 							; screen size
		.fill 	1
EXTScreenHeight:
		.fill 	1

		.send storage

		.section zeropage

EXTAddress: 								; current address on screen of start of line.
		.fill 	2

		.send zeropage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		extern.asm
;		Purpose:	External functions
;		Created:	29th September 2022
;		Reviewed: 	27th November 2022
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;									Any required initialisation
;
; ************************************************************************************************

Export_EXTInitialise:
		stz 	1 							; Access I/O page 0
		stz 	$D004 						; Disable border
		stz 	$D008
		stz 	$D009
		lda 	#1+8						; Timer On at 70Hz counting up.
		sta 	$D658
		;
		lda 	#$52
		sta 	EXTTextColour
		;
		lda 	#80 						; set screen dimensions.
		sta 	EXTScreenWidth
		lda 	#60
		sta 	EXTScreenHeight

		jsr 	EXTClearScreenCode 			; clear the screen

_EXMoveDown: 								; move down past prompt
		lda 	#13
		jsr 	PAGEDPrintCharacter
		lda 	EXTRow
		cmp 	#Header_Height+1
		bne 	_EXMoveDown
		jsr 	EXTShowHeader
		stz 	1
		rts

; ************************************************************************************************
;
;											Get Character
;
;	Returns:
;			8 		Backspace, if not far left
;			9 		Tab spacing (Ctrl+I)
;			13 		CR/LF with scrolling if required
;			32..127	Corresponding ASCII character
;
; ************************************************************************************************

Export_EXTInputSingleCharacter:
PagedInputSingleCharacter:
		phx
		phy
_EISCWait:
		.tickcheck PagedSNDUpdate 			; sound processing carries on.
		jsr 	$FFE4 						; get a key
		cmp 	#0 							; loop back if none pressed.
		beq 	_EISCWait
		ply
		plx
		rts

; ************************************************************************************************
;
;				Break Check. Checks Ctrl+C, Escape or whatever. Returns Z if pressed
;
; ************************************************************************************************

Export_EXTBreakCheck:
		jmp		$FFE1

; ************************************************************************************************
;
;						Read Game Controller A -> A (Button1/Right/Left/Down/Up)
;
; ************************************************************************************************

Export_EXTReadController:
		phx
		ldx 	1 							; save current I/O in X
		stz 	1 							; switch to I/O 0
		lda 	$DC00  						; read VIA register
		stx 	1 							; repair old I/O and exit
		plx
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;		27/11/22 		Rather than clearing screen, it now goes to line 6 after initialising.
; 		20/12/22 		Joystick data now read from $DC00
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		header.asm
;		Purpose:	Display the header/boot display
;		Created:	14th December 2022
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;											Show header
;
; ************************************************************************************************

EXTShowHeader:
		lda 	1
		pha
		;
		lda 	#2
		ldx 	#(Header_Chars & $FF)
		ldy 	#(Header_Chars >> 8)
		jsr 	_ESHCopyBlock
		;
		lda 	#3
		ldx 	#(Header_Attrs & $FF)
		ldy 	#(Header_Attrs >> 8)
		jsr 	_ESHCopyBlock
		;
		stz 	1
		ldx 	#16*4-1
_EXTCopyLUT:
		lda 	Header_Palette,x
		sta 	$D800,x
		sta 	$D840,x
		dex
		bpl 	_EXTCopyLUT
		pla
		rts

_ESHCopyBlock:
		sta 	1
		stx 	zTemp0 						; zTemp0 is RLE packed data
		sty 	zTemp0+1
		.set16 	zTemp1,$C000 				; where it goes.
_ESHCopyLoop:
		lda 	(zTemp0) 					; get next character
		cmp 	#Header_RLE 				; packed ?
		beq 	_ESHUnpack
		sta 	(zTemp1) 					; copy it out.
		lda 	#1 							; source add 1
		ldy 	#1 							; dest add 1
_ESHNext:
		clc 								; zTemp0 + A
		adc 	zTemp0
		sta 	zTemp0
		bcc 	_ESHNoCarry
		inc 	zTemp0+1
_ESHNoCarry:
		tya 								; zTemp1 + Y
		clc
		adc 	zTemp1
		sta 	zTemp1
		bcc 	_ESHCopyLoop
		inc 	zTemp1+1
		bra 	_ESHCopyLoop
		;
_ESHUnpack:
		ldy 	#2 							; get count into X
		lda 	(zTemp0),y
		tax
		dey 								; byte into A
		lda 	(zTemp0),y
		beq 	_ESHExit 					; exit if zero.
		ldy 	#0 							; copy start position
_ESHCopyOut:
		sta 	(zTemp1),y
		iny
		dex
		bne 	_ESHCopyOut
		lda 	#3 							; Y is bytes on screen, 3 bytes from source
		bra 	_ESHNext
		;
_ESHExit:
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
;
;	Automatically generated.
;
	.section code

Header_Height = 14

Header_RLE = 255

Header_attrs:
	.byte	255,82,89,82,255,216,7,216,255,82,2,82,255,216,6,216,255,82,2,82,255,216,7,216,255,82,2,82,255,216,6,216,255,82,8,82,210,210,82,82,255,210,7,210,255,82,19,82,104,104,255,82,7,82,104,104,255,82,4,82,104,104,82,82,104,104,255,82,7,82,104,104,255,82,4,82,104,104,255,82,7,82,210,210,82,82,210,210,255,82,4,82,210,210,255,82,18,82,232,232,255,82,14,82,232,232,82,82,232,232,255,82,7,82,232,232,255,82,14,82,210,210,82,82,210,210,255,82,4,82,210,210,255,82,18,82,255,56,5,56,255,82,4,82,255,56,6,56,255,82,2,82,255,56,6,56,255,82,2,82,255,56,7,56,255,82,8,82,210,210,82,82,255,210,7,210,255,82,19,82,120,120,255,82,7,82,120,120,255,82,14,82,120,120,82,82,120,120,255,82,4,82,120,120,82,82,210,210,255,82,3,82,210,210,82,82,210,210,255,82,2,82,210,210,255,82,20,82,168,168,255,82,7,82,168,168,255,82,8,82,168,168,255,82,3,82,168,168,82,82,168,168,255,82,4,82,168,168,82,82,210,210,255,82,3,82,210,210,82,82,210,210,255,82,3,82,210,210,255,82,19,82,72,72,255,82,7,82,255,72,8,72,82,66,82,255,72,5,72,255,82,3,82,255,72,6,72,255,82,3,82,255,210,5,210,255,82,2,82,210,210,255,82,4,82,210,210,255,82,88,82,255,114,80,114,255,226,7,226,255,146,19,146,114,255,146,4,146,255,114,18,114,255,194,24,194,114,114,255,226,10,226,255,146,16,146,114,255,146,4,146,255,114,18,114,255,194,24,194,114,114,255,226,9,226,255,146,17,146,114,255,146,4,146,255,114,18,114,255,194,24,194,255,114,80,114,255,0

Header_chars:
	.byte	255,32,89,32,255,8,7,8,255,32,2,32,255,8,6,8,255,32,2,32,255,8,7,8,255,32,2,32,255,8,6,8,255,32,8,32,252,252,32,32,255,252,7,252,255,32,19,32,8,8,255,32,7,32,8,8,255,32,4,32,8,8,32,32,8,8,255,32,7,32,8,8,255,32,4,32,8,8,255,32,7,32,252,252,32,32,252,252,255,32,4,32,252,252,255,32,18,32,8,8,255,32,14,32,8,8,32,32,8,8,255,32,7,32,8,8,255,32,14,32,252,252,32,32,252,252,255,32,4,32,252,252,255,32,18,32,255,8,5,8,255,32,4,32,255,8,6,8,255,32,2,32,255,8,6,8,255,32,2,32,255,8,7,8,255,32,8,32,252,252,32,32,255,252,7,252,255,32,19,32,8,8,255,32,7,32,8,8,255,32,14,32,8,8,32,32,8,8,255,32,4,32,8,8,32,32,252,252,255,32,3,32,252,252,32,32,252,252,255,32,2,32,252,252,255,32,20,32,8,8,255,32,7,32,8,8,255,32,8,32,8,8,255,32,3,32,8,8,32,32,8,8,255,32,4,32,8,8,32,32,252,252,255,32,3,32,252,252,32,32,252,252,255,32,3,32,252,252,255,32,19,32,8,8,255,32,7,32,255,8,8,8,255,32,2,32,255,8,5,8,255,32,3,32,255,8,6,8,255,32,3,32,255,252,5,252,255,32,2,32,252,252,255,32,4,32,252,252,255,32,88,32,160,255,150,27,150,155,255,150,22,150,155,255,150,24,150,161,130,72,97,114,100,119,97,114,101,255,32,19,32,130,221,50,48,50,50,32,83,116,101,102,97,110,121,32,65,108,108,97,105,114,101,32,32,130,99,50,53,54,102,111,101,110,105,120,46,99,111,109,47,102,50,53,54,45,106,114,255,32,2,32,130,130,77,105,99,114,111,75,101,114,110,101,108,255,32,16,32,130,221,50,48,50,50,32,74,101,115,115,105,101,32,79,98,101,114,114,101,117,116,101,114,130,71,97,100,103,101,116,64,72,97,99,107,119,114,101,110,99,104,76,97,98,115,46,99,111,109,130,130,83,117,112,101,114,66,65,83,73,67,255,32,17,32,130,221,50,48,50,50,32,80,97,117,108,32,82,111,98,115,111,110,255,32,5,32,130,80,97,117,108,64,82,111,98,115,111,110,115,46,111,114,103,46,117,107,255,32,5,32,130,162,255,150,27,150,157,255,150,22,150,157,255,150,24,150,163,255,0

Header_Palette:
	.dword $000000
	.dword $666666
	.dword $0000aa
	.dword $00aa00
	.dword $c041ea
	.dword $874800
	.dword $ff9c00
	.dword $57dbff
	.dword $3f3f28
	.dword $aaaa8a
	.dword $5555ff
	.dword $55ff55
	.dword $ff8ded
	.dword $ff0000
	.dword $ffff55
	.dword $ffffff
	.dword $ffffff
	.dword $ffffff
	.send code

