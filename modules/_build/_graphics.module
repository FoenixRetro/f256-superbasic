;
;	This file is automatically generated
;

graphicsIntegrated=1

;
;	This file is automatically generated
;
GCMD_Initialise = 0*2
GCMD_BitmapCtl = 1*2
GCMD_SpriteCtl = 2*2
GCMD_Clear = 3*2
GCMD_Colour = 4*2
GCMD_DrawFont = 5*2
GCMD_DrawSprite = 6*2
GCMD_SpriteUse = 7*2
GCMD_SpriteImage = 8*2
GCMD_SpriteCollide = 9*2
GCMD_TileCtl = 10*2
GCMD_TileSize = 11*2
GCMD_TileScrollX = 12*2
GCMD_TileScrollY = 13*2
GCMD_TilePos = 14*2
GCMD_TileWrite = 15*2
GCMD_TileRead = 16*2
GCMD_Move = 32*2
GCMD_Line = 33*2
GCMD_FrameRect = 34*2
GCMD_FillRect = 35*2
GCMD_FrameCircle = 36*2
GCMD_FillCircle = 37*2
GCMD_Plot = 40*2
GCMD_SpriteMove = 41*2
;
;	This file is automatically generated
;

GRFirstFreeCode = 42

	.section code
GRVectorTable:
	.word	GXInitialise             ; $00 Initialise
	.word	GXControlBitmap          ; $01 BitmapCtl
	.word	GXControlSprite          ; $02 SpriteCtl
	.word	GXClearBitmap            ; $03 Clear
	.word	GXSetColourMode          ; $04 Colour
	.word	GXFontHandler            ; $05 DrawFont
	.word	GXSpriteHandler          ; $06 DrawSprite
	.word	GXSelect                 ; $07 SpriteUse
	.word	GXSelectImage            ; $08 SpriteImage
	.word	GXCollide                ; $09 SpriteCollide
	.word	GXControlTilemap         ; $0a TileCtl
	.word	GXControlTileSize        ; $0b TileSize
	.word	GXControlTileScrollX     ; $0c TileScrollX
	.word	GXControlTileScrollY     ; $0d TileScrollY
	.word	GXSelectTile             ; $0e TilePos
	.word	GXSTWriteTile            ; $0f TileWrite
	.word	GXSTReadTile             ; $10 TileRead
	.word	GRUndefined              ; $11
	.word	GRUndefined              ; $12
	.word	GRUndefined              ; $13
	.word	GRUndefined              ; $14
	.word	GRUndefined              ; $15
	.word	GRUndefined              ; $16
	.word	GRUndefined              ; $17
	.word	GRUndefined              ; $18
	.word	GRUndefined              ; $19
	.word	GRUndefined              ; $1a
	.word	GRUndefined              ; $1b
	.word	GRUndefined              ; $1c
	.word	GRUndefined              ; $1d
	.word	GRUndefined              ; $1e
	.word	GRUndefined              ; $1f
	.word	GXMove                   ; $20 Move
	.word	GXLine                   ; $21 Line
	.word	GXFrameRectangle         ; $22 FrameRect
	.word	GXFillRectangle          ; $23 FillRect
	.word	GXFrameCircle            ; $24 FrameCircle
	.word	GXFillCircle             ; $25 FillCircle
	.word	GRUndefined              ; $26
	.word	GRUndefined              ; $27
	.word	GXPlotPoint              ; $28 Plot
	.word	GXMoveSprite             ; $29 SpriteMove
	.send code
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		aa.data.asm
;		Purpose:	Data use for Graphics
;		Created:	6th October 2022
;		Reviewed: 	9th February 2023
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************
;
;		Page number to map in/out
;
GXMappingPage = 3
;
;		Address of that page in 6502 space.
;
GXMappingAddress = ($2000 * GXMappingPage)
;
;		LUT Edit slot
;
GXEditSlot = 8 + GXMappingPage

; ************************************************************************************************
;
;									Allocate or Re-Use memory
;
; ************************************************************************************************

.if graphicsIntegrated==1
;
;		Zero Page (reuse BASIC temps)
;
gxzTemp0 = zTemp0
gxzTemp1 = zTemp1
gxzTemp2 = zTemp2
gxzScreen = zsTemp
;
;		Buffer for pixel data. Needs to be 32 pixels minimum. (Reusing number conversion buffer)
;		When rendering character or sprite, this is used to do a line at a time.
;
gxPixelBuffer = numberBuffer
.else
.endif

; ************************************************************************************************
;
;										Drawing macro
;
; ************************************************************************************************

plotpixel .macro
		and 	gxANDValue
		eor 	gxEORValue
		.endm

; ************************************************************************************************
;											DRAWING MODES
; ************************************************************************************************
;
;		Mode 0: AND 0 EOR Colour 				Sets Colour
;		Mode 1: AND $FF EOR Colour 				Exclusive Or Colour
; 		Mode 2: And Colour:EOR 0 				AND with Colour.
;		Mode 3: AND ~Colour EOR Colour 			Or Colour
;
; ************************************************************************************************

		.section storage

; ************************************************************************************************
;
;										Graphics data area
;								(maintain order for first section)
;
; ************************************************************************************************
;
;		current X/Y coordinates
;
gxCurrentX:
		.fill 	2
gxCurrentY:
		.fill 	2
;
;		last pair of X/Y coordinates
;
gxLastX:
		.fill 	2
gxLastY:
		.fill 	2
;
;		Working coordinate sets
;
gxX0:
		.fill 	2
gxY0:
		.fill 	2
gxX1:
		.fill 	2
gxY1:
		.fill 	2
;
;		Sprites/Bitmaps/Tiles on flags
;
gxSpritesOn:
		.fill 	1
gxBitmapsOn:
		.fill 	1
gxTilesOn:
		.fill 	1
;
;		Base page of bitmap
;
gxBasePage:
		.fill 	1
;
;		Base page of sprite Data
;
gxSpritePage:
		.fill 	1
;
;		Base page of tile image data
;
gxTileImagePage:
		.fill 	1
;
;		Base page of tile map data
;
gxTileMapPage:
		.fill 	1
;
;		Tile map size
;
gxTileMapWidth:
		.fill 	1
gxTileMapHeight:
		.fill 	1
;
;		Height of screen
;
gxHeight:
		.fill 	1
;
;		Mode byte for sprites/chars (vflip|hflip|size2|size1|size0|-|s1|s2)
;
gxMode:
		.fill 	1
;
;		Colours
;
gxColour:
		.fill 	1
gxEORValue:
		.fill 	1
gxANDValue:
		.fill 	1
;
;		Original LUT setting
;
gxOriginalLUTValue:
		.fill 	1
;
;		Offset in calculation.
;
gxOffset:
		.fill 	1
;
;		ID and Address of current selected sprite in I/O (MSB=0 => None)
;
GSCurrentSpriteID:
		.fill 	1
GSCurrentSpriteAddr:
		.fill 	2
;
;		Base address for sprite area
;
gxSpriteOffsetBase:
		.fill 	2
;
;		Sprite location store
;
;		Low <Hidden bit> <X Position >> 2>
; 		High <Size (00=8,01=16,10=24,11=32)> <Y Position >> 2>
;
gxSpriteLow:
		.fill 	64
gxSpriteHigh:
		.fill 	64
;
;		Tile read/write address. Not accessible if page = 0
;
gxTileAccessPage:
		.fill 	1
gxTileAccessAddress:
		.fill 	2

		.send storage


; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		main.asm
;		Purpose:	Graphics main entry point.
;		Created:	6th October 2022
;		Reviewed: 	9th February 2022
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;									Graphics Plot Routine
;
; ************************************************************************************************

Export_GXGraphicDraw:
		cmp 	#GCMD_Move					; low value instructions don't use coordinates
		bcs 	_GDCoordinate 				; (see graphics.txt)
		;
		;		Non coordinate functions
		;
		stx 	gxzTemp0 					; save X/Y
		sty 	gxzTemp0+1
		bra 	_GDExecuteA 				; and execute
		;
		;		Coordinate functions
		;
_GDCoordinate:
		pha 								; save AXY
		phx
		phy
		ldx 	#3 							; copy currentX to lastX
_GDCopy1:
		lda 	gxCurrentX,x
		sta 	gxLastX,x
		dex
		bpl 	_GDCopy1
		;
		;		Update Y
		;
		pla
		sta 	gxCurrentY
		stz 	gxCurrentY+1
		;
		;		Update X, which uses a bit from A.
		;
		pla
		sta 	gxCurrentX
		pla 								; get A (command+X.1) back
		pha
		and 	#1 							; put LSB as MSB of Current.X
		sta 	gxCurrentX+1
		;
		;		Check if we are clipping X,Y (everything except sprite move)
		;
		pla 								; get command back
		and 	#$FE 						; lose LSB, chuck the stray X bit
		pha 								; push back.
		cmp 	#GCMD_SpriteMove 			; move sprite does not clip.
		beq 	_GDCopyToWorkArea
		;
		;		See if coordinate is in range, if so, reject it as error.
		;
		lda 	gxCurrentX+1 				; X < 256 X okay
		beq 	_GDCheckY
		lda 	gxCurrentX 					; otherwise X < 320 = 256 + 64
		cmp 	#64
		bcs 	_GDError1
_GDCheckY:
		lda 	gxCurrentY 					; check Y < Height.
		cmp 	gxHeight
		bcc 	_GDCopyToWorkArea
_GDError1:
		pla
_GDError2:
		sec
		rts
		;
		;		Copy the sprite current/last to the work area where we can manipulate it.
		;
_GDCopyToWorkArea:
		;
		ldx 	#7 							; copy current and last to gxXY/12 work area
_GDCopy2:
		lda 	gxCurrentX,x
		sta 	gxX0,x
		dex
		bpl 	_GDCopy2
		;
		;		Execute command X
		;
		pla 								; get command
_GDExecuteA:
		cmp 	#GRFirstFreeCode*2 			; bad command ?
		bcs 	_GDError2
		tax 								; go execute the command.
		jmp 	(GRVectorTable,x)

GXMove: ;; <32:Move>
		clc
		rts

GRUndefined:
		sec
		rts

; ************************************************************************************************
;											DRAWING MODES
; ************************************************************************************************
;
;		Mode 0: AND 0 EOR Colour 				Sets Colour
;		Mode 1: AND $FF EOR Colour 				Exclusive Or Colour
; 		Mode 2: And Colour:EOR 0 				AND with Colour.
;		Mode 3: AND ~Colour EOR Colour 			Or Colour
;
; ************************************************************************************************

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
; 		21/02/23 		Added exit code for bad GFX commands.
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		circle.asm
;		Purpose:	Circle drawing code
;		Created:	9th October 2022
;		Reviewed: 	17th February 2022
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;									Draw/Fill Circle
;
; ************************************************************************************************

GXFillCircle: ;; <37:FillCircle>
		lda 	#255 						; A determines fill or not
		bra 	GXCircle
GXFrameCircle: ;; <36:FrameCircle>
		lda 	#0
GXCircle:
		sta 	gxIsFillMode				; save Fill flag
		lda 	gxBitmapsOn
		beq 	_GXCFail
		jsr 	GXSortXY 					; topleft/bottomright
		jsr 	GXOpenBitmap 				; start drawing
		jsr 	GXCircleSetup 				; set up for drawing
		stz 	gxYChanged
_GXCircleDraw:
		lda 	gxxCentre					; while x <= y
		cmp 	gxYCentre
		bcc 	_GXCircleContinue
		bne 	_GXNoLast  					; fix up if x < y
		jsr 	GXPlot1
_GXNoLast:
		jsr 	GXCloseBitmap 				; close the bitmap
		clc
		rts

_GXCircleContinue:
		jsr 	GXPlot2 					; draw it
		jsr 	GXCircleMove 				; adjust the coordinates
		bra 	_GXCircleDraw

_GXCFail:
		sec
		rts

; ************************************************************************************************
;
;									Plot line/points
;
; ************************************************************************************************

GXPlot2:
		jsr 	GXPlot1 						; plot and swap, fall through does twice
GXPlot1:
		lda 	gxYCentre 						; if y = 0, don't do it twice (xor)
		beq 	_GXPlot1Only
		jsr 	GXPlot0 						; plot and negate
_GXPlot1Only:
		jsr 	GXPlot0 						; twice, undoing negation
		lda 	gxxCentre 						; swap X and Y
		ldx	 	gxYCentre
		sta 	gxYCentre
		stx 	gxxCentre
		lda 	gxYChanged 						; toggle Y Changed flag
		lda 	#$FF
		sta 	gxYChanged
		rts
		jsr 	GXPlot0 						; do once

		rts

		;
		;		Draw offset gX (always +ve) gY (can be -ve)
		;
GXPlot0:lda 	gxIsFillMode 					; outline mode, always draw as X or Y will change
		beq 	_GXPlot0Always
		lda 	gxYChanged						; fill mode, only draw if changed.
		beq 	GXPlot0Exit
_GXPlot0Always:
		ldx 	#2 								; copy Y1-A => Y0
		lda 	gxYCentre
		jsr 	GXSubCopy
		ldx 	#0 								; copy X1-A => X0,
		lda 	gxxCentre
		jsr 	GXSubCopy
		pha 									; save last offset X
		jsr 	gxPositionCalc 					; calculate position/offset.
		pla
		;
		asl 	a 								; store 2 x last offset in gxzTemp0
		sta 	gxzTemp0
		stz 	gxzTemp0+1
		rol 	gxzTemp0+1
		;
		lda 	gxIsFillMode
		adc 	#128
		jsr 	GXDrawLineTemp0 				; routine from Rectangle.
		sec 									; GY = -GY
		lda 	#0
		sbc 	gxYCentre
		sta 	gxYCentre
GXPlot0Exit:
		rts
;
;		16 bit calc of XY1 - A => XY0 ; A is in gxzTemp0
;
GXSubCopy:
		sta 	gxzTemp0
		stz 	gxzTemp0+1
		and 	#$80
		beq 	_GXNoSx
		dec 	gxzTemp0+1
_GXNoSx:
		;
		sec
		lda 	gxX1,x
		sbc 	gxzTemp0
		sta 	gxX0,x
		lda 	gxX1+1,x
		sbc 	gxzTemp0+1
		sta 	gxX0+1,x
		lda 	gxzTemp0 						; return A
		rts

; ************************************************************************************************
;
;						Adjust coordinates (e.g. the coord change part)
;
; ************************************************************************************************

GXCircleMove:
		stz 	gxYChanged 					; clear Y changed flag
		lda 	gxzTemp1+1 					; check sign of D
		bpl 	_GXEMPositive
		;
		;		D < 0 : inc X, add 4x+6
		;
		inc 	gxxCentre 					; X++
		lda 	gxxCentre
		jsr 	_GXAdd4TimesToD 			; add 4 x A to D
		lda 	#6  						; and add 6
		bra 	_GXEMAddD
		;
		;		D >= 0 : inc X, dec Y, add 4(x-y)+10
		;
_GXEMPositive:
		inc 	gxxCentre					; X++
		dec 	gxYCentre 					; Y--
		;
		sec 								; calculate X-Y
		lda 	gxxCentre
		sbc 	gxYCentre
		jsr 	_GXAdd4TimesToD 			; add 4 x A to D
		lda 	#10  						; and add 10
		dec 	gxYChanged
_GXEMAddD:
		clc
		adc 	gxzTemp1
		sta 	gxzTemp1
		bcc 	_GXEMNoCarry
		inc 	gxzTemp1+1
_GXEMNoCarry:
		rts
;
;		Add 4 x A (signed) to D
;
_GXAdd4TimesToD:
		sta 	gxzTemp0 					; make 16 bit signed.
		and 	#$80
		beq 	_GXA4Unsigned
		lda 	#$FF
_GXA4Unsigned:
		sta 	gxzTemp0+1
		;
		asl 	gxzTemp0  					; x 4
		rol 	gxzTemp0+1
		asl 	gxzTemp0
		rol 	gxzTemp0+1
		;
		clc 								; add
		lda		gxzTemp0
		adc 	gxzTemp1
		sta 	gxzTemp1
		lda		gxzTemp0+1
		adc 	gxzTemp1+1
		sta 	gxzTemp1+1
		rts

; ************************************************************************************************
;
;										Circle setup
;
; ************************************************************************************************

GXCircleSetup:
		;
		;		Calculate R (y1-y0)/2, height in slot 1
		;
		sec
		lda 	gxY1
		sbc 	gxY0
		lsr 	a
		sta 	gxRadius
		;
		;		Calculate centres (x0+x1)/2
		;
		ldx 	#0
		jsr 	_GXCalculateCentre
		ldx 	#2
		jsr 	_GXCalculateCentre
		;
		;		X = 0, Y = R
		;
		stz 	gxxCentre
		lda 	gxRadius
		sta 	gxYCentre
		;
		;		d = 3 - 2 x R
		;
		asl 	a 							; R x 2
		sta 	gxzTemp0
		sec
		lda 	#3
		sbc 	gxzTemp0
		sta 	gxzTemp1
		lda 	#0
		sbc 	#0
		sta 	gxzTemp1+1
		rts
;
;		Calculates midpoint for X/Y
;
_GXCalculateCentre:
		sec
		lda 	gxX1,x
		adc 	gxX0,x
		sta 	gxX1,x
		lda 	gxX1+1,x
		adc 	gxX0+1,x
		lsr 	a
		sta 	gxX1+1,x
		ror 	gxX1,x
		rts

		.send code

		.section storage
gxRadius:
		.fill 	1
gxxCentre:
		.fill 	1
gxYCentre:
		.fill 	1
gxIsFillMode:
		.fill 	1
gxYChanged:
		.fill  	1
		.send storage

; ************************************************************************************************
;
;		Usage
;			gxzScreen and gxOffset are used as usual
;			gxzTemp0 holds the line length and is general workspace.
;			x1,y1 hold the circle centre
;			gX,gY are the coordinates x,y (note x, y both < 128)
;			d is stored in gxzTemp1 (2 bytes)
;			r is stored in gxRadius
;
; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		clear.asm
;		Purpose:	Clear Screen
;		Created:	6th October 2022
;		Reviewed: 	9th February 2023
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

ScreenSize200 = 320 * 200
ScreenSize240 = 320 * 240

		.section code

; ************************************************************************************************
;
;								Clear bitmap to colour gxzTemp0
;
; ************************************************************************************************

GXClearBitmap: ;; <3:Clear>
		lda 	gxBitmapsOn 				; check BMP turned on.
		beq 	_GXCBFail
		jsr 	GXOpenBitmap 				; start access
		ldy 	#ScreenSize200 / 8192 		; X is pages to clear as 2 graphic heights.
		lda 	gxHeight
		cmp 	#200 						; 200 ?
		beq 	_GXCalcLastPage
		ldy 	#ScreenSize240 / 8192
_GXCalcLastPage:

		tya 								; add to base page
		clc
		adc 	gxBasePage
		sta 	GXEditSlot  				; clear from this page back

_GXClearAll:
		jsr 	_GXClearBlock 				; clear 8k block
		dec 	GXEditSlot  				; back to previous
		lda 	GXEditSlot
		cmp 	gxBasePage 					; until before base page
		bcs 	_GXClearAll
		jsr 	GXCloseBitmap	 			; stop access
		clc
		rts
_GXCBFail:
		sec
		rts

_GXClearBlock:
;
;		Clear 1 8k block
;
		.set16 	gxzTemp1,GXMappingAddress
_GXCB0:
		lda 	gxzTemp0 					; clear colour
		ldy 	#0
_GXCB1: 									; do 4 chunks at a time, really should DMA this.
		sta 	(gxzTemp1),y
		iny
		sta 	(gxzTemp1),y
		iny
		sta 	(gxzTemp1),y
		iny
		sta 	(gxzTemp1),y
		iny
		bne 	_GXCB1
		inc 	gxzTemp1+1
		lda 	gxzTemp1+1
		cmp	 	#(GXMappingAddress >> 8)+$20
		bne 	_GXCB0
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;		9/2/23 			beq _GXCalcLastPage added as was clearing 240 rows irrespective of height
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		control.asm
;		Purpose:	Graphics control.
;		Created:	11th October 2022
;		Reviewed: 	17th February 2022
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;										Initialise:
;
; ************************************************************************************************

GXInitialise: ;; <0:Initialise>
		stz 	1 							; access I/O
		lda 	#1 							; reset bitmap address
		sta 	$D000
		clc
		stz 	gxSpritesOn					; sprites/bitmaps/tiles off.
		stz 	gxBitmapsOn
		stz 	gxTilesOn
		ldx 	#15 						; erase work area
_GXIClear:
		stz 	gxCurrentX,x
		dex
		bpl 	_GXIClear
		jsr 	GXClearSpriteStore 			; clear sprite backup space.

		lda 	#$40                   		; Layer 0 = Bitmap 0, Layer 1 = Tile map 0
		sta 	$D002
		lda 	#$15                   		; Layer 2 = Tile Map 1
		sta 	$D003
		rts

; ************************************************************************************************
;
;										Bitmap Control
;
; ************************************************************************************************

GXControlBitmap: ;; <1:BitmapCtl>
		stz 	1

		lda 	gxzTemp0 					; get control bits
		and 	#1 							; get bitmap flag (is enabled)
		sta 	gxBitmapsOn
		lsr 	a 							; bit 0 into carry.
		lda 	$D000 						; read Vicky MCR
		ora 	#7 							; turn graphics, text, textoverlay on.
		and 	#$F7 						; clear bitmap bit
		bcc 	_CBNotOn
		ora 	#$08 						; bitmap on if 1 on 0 off
_CBNotOn:
		sta 	$D000 						; update Vicky MCR
		;
		lda 	gxzTemp0 					; get control settings (bits 0-2)
		and 	#7
		sta 	$D100 						; write in Vicky Bitmap Control Register #0

		lda 	gxzTemp0+1 					; get the base page requested
		bne 	_CBNotDefault
		lda 	#8  						; if zero, use default 8 e.g. bitmap at $10000
_CBNotDefault:
		sta 	gxBasePage 					; save as bitmap base page.

		jsr 	GXCalculateBaseAddress 	 	; convert page# to address
		lda 	gxzTemp0+1 					; copy address into Bitmap address registers
		sta 	$D103
		lda 	gxzTemp0
		sta 	$D102
		stz 	$D101

		ldx 	#240 						; height is 240 or 200 ?
		lda 	$D001 						; read MCR bit 0
		and 	#1
		beq 	_CBHaveHeight
		ldx 	#200 						; if bit 0 set 320x200
_CBHaveHeight
		stx 	gxHeight
		clc
		rts

; ************************************************************************************************
;
;										Sprite Control
;
; ************************************************************************************************

GXControlSprite: ;; <2:SpriteCtl>
		stz 	1
		lda 	gxzTemp0 					; get control bits
		and 	#1 							; set sprites flag
		sta 	gxSpritesOn
		lsr 	a 							; bit 0 into carry

		lda 	$D000 						; read Vicky MCR
		ora 	#7 							; turn graphics, text, textoverlay on.
		and 	#$DF 						; clear sprite bit
		bcc 	_CSNotOn
		ora 	#$20 						; sprite on if 1 on 0 off
_CSNotOn:
		sta 	$D000 						; update Vicky MCR


		lda 	gxzTemp0+1 					; get the base page
		bne 	_CSNotDefault
		lda 	#24  						; if zero, use 24 e.g. sprites at $30000
_CSNotDefault:
		sta 	gxSpritePage

		jsr 	GXCalculateBaseAddress 	 	; convert page# to address
		lda 	gxzTemp0 					; save this so we know where the sprites are.
		sta 	gxSpriteOffsetBase
		lda 	gxzTemp0+1
		sta 	gxSpriteOffsetBase+1
		;
		ldx 	#0 							; disable all sprites, clears all sprite memory.
_CSClear:
		stz 	$D900,x
		stz 	$DA00,x
		dex
		bne 	_CSClear
		;
		stz 	GSCurrentSpriteAddr+1 		; no sprite selected.
		jsr 	GXClearSpriteStore
		clc
		rts

; ************************************************************************************************
;
;								Control the tile map
;
; ************************************************************************************************

GXControlTilemap: ;; <10:TileCtl>
		stz 	1 							; access I/O
		lda 	gxzTemp0 					; get the Map Page/Enable
		bmi 	_GXCTOn
		;
		lda 	$D000 						; turn off bitmap enable bit in MCR
		and 	#$EF 						; clear bit 4
		sta 	$D000
		stz 	gxTilesOn 					; clear tiles on flag.
		clc
		rts
		;
_GXCTOn:
		sta 	gxTilesOn 					; set tiles on flag.
		;
		lda 	$D000	 					; turn tilemap on
		ora 	#$17
		sta 	$D000
		stz 	$D2C0 						; turn off tilemap#1 and tilemap#2
		stz 	$D218
		;
		lda 	#64 						; default size of 64x32
		sta 	gxTileMapWidth
		lda		#32
		sta 	gxTileMapHeight
		;
		lda 	gxTilesOn 					; set the tile map page
		and 	#$7F
		bne	 	_GXCTNotMapDefault 			; check for default
		lda 	#TILEMAP_ADDRESS >> 13
_GXCTNotMapDefault:
		sta 	gxTileMapPage
		;
		lda 	gxzTemp0+1 					; set the tile image page
		bne 	_GXCTNotImgDefault 			; check for default
		lda 	#TILEIMAGES_ADDRESS >> 13
_GXCTNotImgDefault:
		sta 	gxTileImagePage
		;
		lda 	#$11 						; set tilemap#0 on and 8x8
		sta 	$D200
		;
		lda 	gxTileMapPage 				; put tile map address in.
		jsr		GXCalculateBaseAddress
		stz 	$D201
		lda 	gxzTemp0
		sta 	$D202
		lda 	gxzTemp0+1
		sta 	$D203
		;
		lda 	gxTileMapWidth	 			; set tilemap size.
		sta 	$D204
		lda 	gxTileMapHeight
		sta 	$D206
		;
		stz 	$D208 						; clear scrolling register
		stz 	$D209
		stz 	$D20A
		stz 	$D20B
		;
		lda 	gxTileImagePage 			; set the tile image address
		jsr 	GXCalculateBaseAddress
		stz 	$D280
		lda 	gxzTemp0
		sta 	$D281
		lda 	gxzTemp0+1
		sta 	$D282
		clc
		rts

; ************************************************************************************************
;
;								Control the tile map size
;
; ************************************************************************************************

GXControlTileSize: ;; <11:TileSize>
		lda 	gxTilesOn 					; check on
		sec
		beq 	_GXCTSExit

		stz 	1 							; access I/O 0

		lda 	gxzTemp0 					; save parameter to registes
		sta 	gxTileMapWidth
		sta 	$D204

		lda 	gxzTemp0+1
		sta 	gxTileMapHeight
		sta 	$D206

		clc
_GXCTSExit:
		rts

; ************************************************************************************************
;
;								Convert page number to an address
;
; ************************************************************************************************

GXCalculateBaseAddress:
		sta 	gxzTemp0
		stz 	gxzTemp0+1
		lda 	#5
_GXShift:
		asl 	gxzTemp0
		rol 	gxzTemp0+1
		dec		a
		bne 	_GXShift
		rts

; ************************************************************************************************
;
;							Reset the sprite location store
;
; ************************************************************************************************

GXClearSpriteStore:
		ldx 	#63 						; erase 64 sprite store elements
_GXCSSLoop:
		stz 	gxSpriteHigh,x
		lda 	#$80 						; set the 'hidden' bit.
		sta 	gxSpriteLow,x
		dex
		bpl 	_GXCSSLoop
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;		20/02/23 		Added control functionality for tile on/off/location and size of map.
; 		22/02/23 		Fixed bug no defaults on setting tilemap page defaults.
;
; ************************************************************************************************

; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		line.asm
;		Purpose:	Line drawing code
;		Created:	6th October 2022
;		Reviewed: 	17th February 2023
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;									Draw line (see lines2.py)
;
; ************************************************************************************************

GXLine: ;; <33:Line>
		lda 	gxBitmapsOn					; check bitmap on.
		beq 	_GXLFail
		jsr 	GXOpenBitmap 				; access it.
		jsr 	GXSortY						; sort pairs so Y1 >= Y0 e.g. top to bottom.
		jsr 	GXLineSetup 				; the calculations in the linescanner constructor
		jsr 	gxPositionCalc 				; calculate position/offset.
_GXDrawLoop:
		ldy 	gxOffset 					; draw the pixel
		lda 	(gxzScreen),y
		.plotpixel
		sta 	(gxzScreen),y

		jsr 	GXLineIsComplete 			; is the line complete ?
		beq 	_GXLExit
		jsr 	GXLineAdvance 				; code as per advance method
		bra 	_GXDrawLoop
_GXLExit:
		jsr 	GXCloseBitmap 				; restore and return success.
		clc
		rts
_GXLFail:
		sec
		rts

; ************************************************************************************************
;
;								Is line complete , return Z if so
;
; ************************************************************************************************

GXLineIsComplete:
		lda 	gxIsDiffYLarger 			; is dy larger
		bne 	_GXLICCompareY 				; if so compare Y1 versus Y0

		lda 	gxX0 						; compare X, LSB and MSB
		eor 	gxX1
		bne 	_GXLICExit
		lda 	gxX0+1
		eor 	gxX1+1
_GXLICExit:
		rts

_GXLICCompareY: 							; compare Y
		lda 	gxY1
		eor 	gxY0
		rts

; ************************************************************************************************
;
;								  Advance the line position
;
; ************************************************************************************************

GXLineAdvance:
		clc 								; add adjust to position
		lda 	gxPosition
		adc 	gxAdjust
		sta 	gxPosition
		stz 	gxAddSelect 				; clear add select flag
		bcs 	_GXLAOverflow 				; if carry out, overflowed.
		cmp 	gxTotal 					; if exceeded total
		bcc 	_GXLANoExtra
_GXLAOverflow:
		dec 	gxAddSelect 				; set addselect to $FF
		sec 								; subtract total and write back
		sbc 	gxTotal
		sta 	gxPosition
		;
_GXLANoExtra:
		lda 	gxIsDiffYLarger
		beq 	_GXDXLarger
		;
		;		dy larger, so always do y and sometimes x
		;
		jsr 	GXIncrementY
		lda 	gxAddSelect
		beq 	_GXLAExit
		jsr 	gxAdjustX
		bra 	_GXLAExit
		;
		;		dx larger, so always do x and sometimes Y
		;
_GXDXLarger:
		jsr 	gxAdjustX
		lda 	gxAddSelect
		beq 	_GXLAExit
		jsr 	GXIncrementY
_GXLAExit:
		rts

; ************************************************************************************************
;
;										 Advance X/Y
;
; ************************************************************************************************

gxAdjustX:
		lda 	gxDXNegative
		bpl 	_GXAXRight
		;
		;		Go left.
		;
		lda 	gxX0
		bne 	_GXAXNoBorrow
		dec 	gxX0+1
_GXAXNoBorrow:
		dec 	gxX0
		;
		dec 	gxOffset 					; pixel left
		lda 	gxOffset
		cmp 	#$FF
		bne 	_GXAYExit 					; underflow
		dec 	gxzScreen+1 					; borrow
		lda 	gxzScreen+1 					; gone off page
		cmp 	#GXMappingAddress >> 8
		bcs 	_GXAYExit
		clc
		adc 	#$20 						; fix up
		sta 	gxzScreen+1
		dec 	GXEditSlot 				; back one page
_GXAYExit:
		rts
		;
		;		Go right.
		;
_GXAXRight:
		inc 	gxX0
		bne 	_GXAXNoCarry
		inc 	gxX0+1
_GXAXNoCarry:
		inc 	gxOffset 					; pixel right
		bne 	_GXAXExit 					; if not overflowed, exit.
		inc 	gxzScreen+1 					; next line
		lda 	gxzScreen+1
		cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
		bcc 	_GXAXExit
		sbc 	#$20 						; fix up
		sta 	gxzScreen+1
		inc 	GXEditSlot 				; next page
_GXAXExit:
		rts

GXIncrementY:
		inc 	gxY0
		jsr 	GXMovePositionDown
		rts


; ************************************************************************************************
;
;										Set up the draw
;
; ************************************************************************************************

GXLineSetup:
		;
		; 		diffY = (y1 - y0) / 2
		;
		lda 	gxY1
		sec
		sbc 	gxY0
		lsr 	a
		sta 	gxDiffY
		;
		; 		diffX = |(x1-x0)|/2 , and set the flag for dX being negative.
		;
		stz 	gxDXNegative 				; clear -ve flag
		sec
		lda 	gxX1
		sbc 	gxX0
		sta 	gxDiffX
		;
		lda 	gxX1+1 						; calculate MSB
		sbc 	gxX0+1
		ror 	a 							; rotate bit into DiffX halving it
		ror 	gxDiffX
		asl 	a
		bpl 	_GDXNotNegative
		lda 	#0 							; make absolute value of |dx|
		sec
		sbc 	gxDiffX
		sta 	gxDiffX
		dec 	gxDXNegative 				; -ve flag = $FF.
_GDXNotNegative:
		;
		; 		See if dy > dx, and set adjust and total accordingly.
		;
		stz 	gxIsDiffYLarger 			; clear larger flag

		lda 	gxDiffY 					; set adjust and total.
		sta 	gxAdjust
		lda 	gxDiffX
		sta 	gxTotal

		lda 	gxDiffY 					; if dy > dx
		cmp 	gxDiffX
		bcc 	_GDXNotLarger
		dec 	gxIsDiffYLarger 			; set the dy larger flag
		lda 	gxDiffX 					; set adjust and total other way round
		sta 	gxAdjust
		lda 	gxDiffY
		sta 	gxTotal
_GDXNotLarger:
		;
		;		Pos = total / 2
		;
		lda 	gxTotal
		lsr 	a
		sta 	gxPosition
		rts

		.send code

; ************************************************************************************************
;
;										Data for Line drawing
;
; ************************************************************************************************

		.section storage
gxDiffX:
		.fill 	1
gxDiffY:
		.fill 	1
gxIsDiffYLarger:
		.fill 	1
gxDXNegative:
		.fill 	1
gxPosition:
		.fill 	1
gxAdjust:
		.fill 	1
gxTotal:
		.fill 	1
gxAddSelect:
		.fill 	1

		.send storage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		mode.asm
;		Purpose:	Graphics set drawing mode
;		Created:	11th October 2022
;		Reviewed: 	17th February 2023
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;								Set colour, mode (bits 0 & 1)
;
;				  Sets AND value and EOR value to access mode (see below)
;
; ************************************************************************************************

GXSetColourMode: ;; <4:Colour>
		ldx 	gxzTemp0
		stx 	gxColour 								; set colour
		lda 	gxzTemp0+1 								;
		sta 	gxMode 									; set mode
		;
		;		Now process bits 0/1 to set the drawing type. Normal (0) EOR (1) AND (2) OR (3)
		;
		and 	#3 										; only interested in bits 0-3
		stz 	gxANDValue 								; initially AND with 0, and EOR with Colour
		ldx 	gxColour
		stx 	gxEORValue
		cmp 	#2 										; if mode 2/3 And with colour
		bcc 	_GXSDCNotAndColour
		stx 	gxANDValue
_GXSDCNotAndColour:
		bne 	_GXSDCNotAnd 							; mode 2, Don't EOR with colour
		stz 	gxEORValue
_GXSDCNotAnd:
		lsr 	a 										; if bit 0 set, 1's complement AND value
		bcc 	_GXSDCNoFlip
		lda	 	gxANDValue
		eor 	#$FF
		sta 	gxANDValue
_GXSDCNoFlip:
		clc
		rts

; ************************************************************************************************
;											DRAWING MODES
; ************************************************************************************************
;
;		Mode 0: AND 0 EOR Colour 				Sets Colour
;		Mode 1: AND $FF EOR Colour 				Exclusive Or Colour
; 		Mode 2: And Colour:EOR 0 				AND with Colour.
;		Mode 3: AND ~Colour EOR Colour 			Or Colour
;
; ************************************************************************************************

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		plot.asm
;		Purpose:	Plot point
;		Created:	11th October 2022
;		Reviewed: 	17th February 2023
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;									Draw Point
;
; ************************************************************************************************

GXPlotPoint: ;; <40:Plot>
		jsr 	GXOpenBitmap 				; start drawing
		jsr 	gxPositionCalc 				; setup gxzScreen, gxOffset and the position.
		ldy 	gxOffset
		lda 	(gxzScreen),y 				; set pixel on the right
		.plotpixel
		sta 	(gxzScreen),y
		jsr 	GXCloseBitmap 				; stop drawing and exit
		clc
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		rect.asm
;		Purpose:	Rectangle/Solid Rectangle drawing code
;		Created:	8th October 2022
;		Reviewed: 	17th February 2022
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;									Draw/Fill Rectangle
;
; ************************************************************************************************

GXFillRectangle: ;; <35:FillRect>
		sec 								; pass carry in for fill/frame
		bra 	GXRectangle
GXFrameRectangle: ;; <34:FrameRect>
		clc
GXRectangle:
		lda 	gxBitmapsOn 				; exit if off.
		beq 	_GXRFail
		php 								; save Fill flag (CS)
		jsr 	GXOpenBitmap 				; start drawing
		jsr 	GXSortXY 					; sort both X and Y so top left/bottom right
		;
		;		Do the top line first.
		;
		jsr 	gxPositionCalc 				; setup gxzScreen, gxOffset and the position.
		sec 								; sec = Draw line
		jsr 	GXDrawLineX1X0 				; draw a line length X1-X0

		lda 	gxY0 						; reached end of rectangle ?
		cmp 	gxY1 						; e.g. 1 pixel high.
		beq 	_GXRectangleExit
_GXRectLoop:
		jsr 	GXMovePositionDown 			; down one.
		inc 	gxY0 						; change Y pos
		lda 	gxY0 						; reached last line
		cmp 	gxY1
		beq 	_GXLastLine
		plp 								; get flag back for solid/edged
		php
		jsr 	GXDrawLineX1X0 				; draw horizontal line
		bra 	_GXRectLoop

_GXLastLine: 								; draw the last solid line.
		sec
		jsr 	GXDrawLineX1X0
_GXRectangleExit:
		pla 								; throw fill flag.
		jsr 	GXCloseBitmap 				; stop drawing and exit
		clc
		rts

_GXRFail:
		sec
		rts

; ************************************************************************************************
;
;					Draw solid line/ends from current position length x1-x0
;
; ************************************************************************************************

GXDrawLineX1X0:
		php 								; save solid/either-end
		sec 								; calculate x1-x0
		lda		gxX1
		sbc 	gxX0
		sta 	gxzTemp0
		lda 	gxX1+1
		sbc 	gxX0+1
		sta 	gxzTemp0+1
		plp
		;
; ************************************************************************************************
;
;					Draw solid line/ends from current position length gxzTemp0
;
; ************************************************************************************************

GXDrawLineTemp0:

		lda 	gxzScreen 					; push gxzScreen, gxOffset and GXEditSlot on stack
		pha
		lda 	gxzScreen+1
		pha
		lda 	gxOffset
		pha
		lda 	GXEditSlot
		pha
		ldy 	gxOffset 					; Y offset
		bcc 	_GXDLTEndPoints 			; if CC draw end points only.
		;
		;		Draw solid line.
		;
_GXDLTLine:
		lda 	(gxzScreen),y 				; set pixel
		.plotpixel
		sta 	(gxzScreen),y
		;
		lda 	gxzTemp0 					; decrement counter
		bne 	_GXDLTNoBorrow
		dec 	gxzTemp0+1 					; borrow, if goes -ve then exit
		bmi 	_GXDLTExit
_GXDLTNoBorrow:
		dec 	gxzTemp0
		iny 								; next slot.
		bne 	_GXDLTLine
		inc 	gxzScreen+1 				; carry to next
		jsr 	GXDLTCheckWrap				; check for new page.
		bra 	_GXDLTLine
		;
		;		Draw end points only.
		;
_GXDLTEndPoints:
		lda 	(gxzScreen),y 				; set pixel
		.plotpixel
		sta 	(gxzScreen),y
		;
		tya 								; advance to right side
		clc
		adc 	gxzTemp0
		tay
		lda 	gxzScreen+1
		adc 	gxzTemp0+1
		sta 	gxzScreen+1
		jsr 	GXDLTCheckWrap 				; fix up.

		lda 	(gxzScreen),y 				; set pixel on the right
		.plotpixel
		sta 	(gxzScreen),y

_GXDLTExit: 								; restore screen position.
		pla
		sta 	GXEditSlot
		pla
		sta 	gxOffset
		pla
		sta 	gxzScreen+1
		pla
		sta 	gxzScreen
		rts
;
;		Check if gxzScreen needs wrapping round.
;
GXDLTCheckWrap:
		lda 	gxzScreen+1 				; check end of page
		cmp 	#((GXMappingAddress+$2000) >> 8)
		bcc 	_GXDLTCWExit
		sbc 	#$20 						; fix up
		sta 	gxzScreen+1
		inc 	GXEditSlot 					; next bitmap vram page.
_GXDLTCWExit:
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		render.asm
;		Purpose:	Graphic Renderer
;		Created:	9th October 2022
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;							Render : A (size) YX (Data retrival)
;
; ************************************************************************************************

GXDrawGraphicElement:
		sta 	gxSize 						; save size
		dec 	a
		sta 	gxMask 						; and mask

		lda 	gxBitmapsOn 				; check BMP on
		beq 	_GXSLFail

		lda 	gxY0 						; push Y on stack
		pha

		sty 	gxAcquireVector+1 			; and acquisition vector
		stx 	gxAcquireVector
		jsr 	GXOpenBitmap 				; open the bitmap.

		lda 	gxUseMode 					; scale bits
		lsr 	a
		lsr 	a
		lsr 	a
		and		#7
		inc 	a
		sta 	gxScale

		stz 	gxzTemp1					; start first line
_GXGELoop:
		lda 	gxzTemp1 					; current line number to read.
		bit 	gxUseMode 					; check for flip.
		bpl		_GXNoVFlip
		lda 	gxMask
		sec
		sbc 	gxzTemp1
_GXNoVFlip:

		tax 								; get the Xth line.
		jsr 	_GXCallAcquire 				; get that data.
		lda 	gxScale 					; do scale identical copies of that line.
		sta 	gxzTemp1+1
_GXGELoop2:
		lda 	gxY0 						; off screen
		cmp 	gxHeight
		bcs 	_GXDGEExit

		jsr 	GXRenderOneLine 			; render line
		dec 	gxzTemp1+1 					; scale times.
		bne 	_GXGELoop2
		inc 	gxzTemp1 					; done all lines.
		lda 	gxzTemp1
		cmp 	gxSize
		bne 	_GXGELoop
_GXDGEExit:
		pla 								; restore Y for next time
		sta 	gxY0
		;
		ldx 	gxScale 					; get scale (1-8)
_GXShiftLeft:
		clc
		lda 	gxSize
		adc 	gxX0
		sta 	gxX0
		bcc 	_GXSLNoCarry
		inc 	gxX0+1
_GXSLNoCarry:
		dex
		bne 	_GXShiftLeft

		jsr 	GXCloseBitmap
		clc
		rts
_GXSLFail:
		sec
		rts

_GXCallAcquire:
		jmp 	(gxAcquireVector)

; ************************************************************************************************
;
;										Render one line.
;
; ************************************************************************************************

GXRenderOneLine:
		jsr 	gxPositionCalc 				; calculate position/offset.
		ldy 	gxOffset 					; Y contains position.
		stz 	gxzTemp2 					; do size pixels
_GXROLLoop1:
		lda 	gxScale 					; set to do 'scale' times
		sta 	gxzTemp2+1
_GXROLLoop2:
		lda 	gxzTemp2 					; get current pixel
		bit 	gxMode 						; check H Flip
		bvc 	_GXNoHFlip
		lda 	gxMask
		sec
		sbc 	gxzTemp2
_GXNoHFlip:
		tax 								; read from the pixel buffer
		lda 	gxPixelBuffer,x
		bne 	_GXDraw 					; draw if non zero
		lda 	gxUseMode 					; check to see if solid background
		and 	#4
		beq 	_GXZeroPixel
_GXDraw:
		lda 	(gxzScreen),y
		and 	gxANDValue
		eor 	gxPixelBuffer,x
		sta 	(gxzScreen),y
_GXZeroPixel:
		iny 								; advance pointer
		bne 	_GXNoShift
		inc 	gxzScreen+1 				; carry to next
		jsr 	GXDLTCheckWrap				; check for new page.
_GXNoShift:
		dec 	gxzTemp2+1 					; do the inner loop gxScale times.
		bne 	_GXROLLoop2
		inc 	gxzTemp2 					; next pixel.
		lda 	gxzTemp2
		cmp 	gxSize
		bne 	_GXROLLoop1
		inc 	gxY0
		rts

		.send code

		.section storage
gxSize:
		.fill 	1
gxMask:
		.fill 	1
gxAcquireVector:
		.fill 	2
gxScale:
		.fill 	1
gxUseMode:
		.fill 	1
		.send storage


; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		scroll.asm
;		Purpose:	Scroll tilemap code.
;		Created:	21st February 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;								Set the tilemap scroll.
;
; ************************************************************************************************

GXControlTileScrollX: ;; <12:TileScrollX>
		lda 	gxTileMapWidth 				; comparator value (max X tile)
		jsr 	GXScrollProcessor 			; scroll processing.
		bcs 	_GXCTSExit
		stz 	1 							; write it out.
		stx 	$D208
		sty 	$D209
_GXCTSExit:
		rts

GXControlTileScrollY: ;; <13:TileScrollY>
		lda 	gxTileMapHeight 			; comparator value (max X tile)
		jsr 	GXScrollProcessor 			; scroll processing.
		bcs 	_GXCTSExit
		stz 	1 							; write it out.
		stx 	$D20A
		sty 	$D20B
_GXCTSExit:
		rts

; ************************************************************************************************
;
;		gxzTemp0 contains a scroll offset, A the max tile size. Check tilemap is on
;		and scroll in range ; then calculate actual scrolling value and return in YX
;		CS = Fail.
;
; ************************************************************************************************

GXScrollProcessor:
		sta 	gxzTemp1 					; save max tile value.
		lda 	gxTilesOn 					; check tile map is on.
		sec
		beq 	_GXSPExit
		;
		stz 	gxzTemp1+1 					; convert tile size to a pixel scroll.
		ldx 	#3
_GXCalcMaxPixelScroll:
		asl 	gxzTemp1
		rol 	gxzTemp1+1
		dex
		bne 	_GXCalcMaxPixelScroll
		;
		lda 	gxzTemp0 					; check scroll in range.
		cmp 	gxzTemp1
		lda 	gxzTemp0+1
		sbc 	gxzTemp1+1
		bcs		_GXSPExit

		lda 	gxzTemp0 	 				; save fine scroll.
		and		#7
		sta 	gxzTemp1

		asl 	gxzTemp0 					; shift left one, as whole tiles are 8 pixels.
		rol 	gxzTemp0+1
		lda 	gxzTemp0+1 					; MSB is the upper byte.
		and 	#$0F
		tay
		;
		lda 	gxzTemp0 					; get coarse scroll
		and 	#$F0
		ora 	gxzTemp1 					; OR in fine scroll.
		tax 								; return in X

		clc
_GXSPExit:
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		font.asm
;		Purpose:	Font source handler
;		Created:	9th October 2022
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;									Access from font memory
;
; ************************************************************************************************

GXFontHandler: ;; <5:DrawFont>
		lda 	gxzTemp0+1 					; eor with mode
		eor 	gxMode
		sta 	gxUseMode

		stz 	gxzTemp0+1 					; gxzTemp0 is font #
		asl	 	gxzTemp0 					; x 2
		rol	 	gxzTemp0+1
		asl	 	gxzTemp0 					; x 4
		rol	 	gxzTemp0+1
		asl	 	gxzTemp0 					; x 8
		rol	 	gxzTemp0+1

		lda 	gxzTemp0+1 					; put in page C0
		ora 	#$C0
		sta 	gxzTemp0+1

		lda 	#8 							; size 8x8
		ldx 	#GXGetGraphicDataFont & $FF ; XY = Graphic Data retrieval routine
		ldy 	#GXGetGraphicDataFont >> 8
		jsr 	GXDrawGraphicElement
		rts
;
;		Get line X of the graphics into the Pixel Buffer
;
GXGetGraphicDataFont:
		txa 								; X->Y
		tay
		ldx 	1 							; preserve old value
		lda 	#1 							; access page 1 (font memory)
		sta 	1
		lda 	(gxzTemp0),y 				; read the font element.
		stx 	1 							; put old value back.
		ldx 	#0 							; do 8 times
_GXExpand:
		stz 	gxPixelBuffer,x 			; zero in pixel buffer
		asl 	a 							; shift bit 7 into C
		bcc 	_GXNoPixel
		pha 								; if set, set pixel buffer to current colour.
		lda 	gxColour
		sta 	gxPixelBuffer,x
		pla
_GXNoPixel:
		inx 								; do the whole byte.
		cpx 	#8
		bne 	_GXExpand
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		sprite.asm
;		Purpose:	Sprite Source Handler
;		Created:	9th October 2022
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;								Access from Sprite Memory
;
; ************************************************************************************************

GXSpriteHandler: ;; <6:DrawSprite>
		lda 	gxSpritesOn 				; sprites on ?
		beq 	_GXSHExit
		;
		lda 	gxzTemp0+1 					; eor with mode
		eor 	gxMode
		sta 	gxUseMode

		ldx 	gxzTemp0 					; sprite #
		phx
		jsr 	GXOpenBitmap 				; can access sprite information
		pla
		jsr 	GXFindSprite 				; get the sprite address
		php
		jsr 	GXCloseBitmap
		plp
		bcs		_GXSHExit 					; exit if find failed.

		lda 	gxSizePixels 				; return size
		ldx 	#GXSpriteAcquire & $FF
		ldy 	#GXSpriteAcquire >> 8
		jsr 	GXDrawGraphicElement
_GXSHExit:
		rts

GXSpriteAcquire:
		lda 	gxSpritePage				; point to base page
		sta 	GXEditSlot
		;
		;		Multiply Row Number by Sprite Size (0,1,2,3) + 1 * 8 e.g. 8,16,24 or 32
		;
		stx 	gxzTemp0 					; row number x 1,2,3,4
		lda 	#0
		ldx 	gxSizeBits
_GXTimesRowNumber:
		clc
		adc 	gxzTemp0
		dex
		bpl 	_GXTimesRowNumber
		stz 	gxzTemp0+1
		asl 	a 							; row x 2,4,6,8
		rol 	gxzTemp0+1
		asl 	a 							; row x 4,8,12,16
		rol 	gxzTemp0+1
		asl 	a 							; row x 8,16,24,32
		rol 	gxzTemp0+1
		sta 	gxzTemp0
		;
		;		Add base address of sprite
		;
		clc 								; add base address.
		lda 	gxzTemp0
		adc 	gxSpriteOffset
		sta 	gxzTemp0
		lda 	gxzTemp0+1
		adc 	gxSpriteOffset+1
		;
		; 		Get MSB in range $00-$1F, e.g. in the current page, bumping the selected page.
		;
_GXSAFindPage:
		cmp 	#$20 						; on this page
		bcc 	_GXSAFoundPage
		sbc 	#$20 						; forward one page
		inc 	GXEditSlot
		bra 	_GXSAFindPage
_GXSAFoundPage:
		;
		;		Make gxzTemp0 point to the sprite data, then copy it in.
		;
		ora 	#(GXMappingAddress >> 8) 	; physical address of page.
		sta 	gxzTemp0+1 					; gxzTemp0 now points to the page
		;
		ldy 	#0
_GXSACopyLoop:
		lda 	(gxzTemp0),y
		sta 	gxPixelBuffer,y
		iny
		cpy 	gxSizePixels
		bne 	_GXSACopyLoop
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;		27/11/22 		Do nothing if sprites off.
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		sprite.asm
;		Purpose:	Sprite Functions
;		Created:	11th October 2022
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;									Select sprite
;
; ************************************************************************************************

GXSelect: ;; <7:SpriteUse>
		lda 	gxSpritesOn
		beq 	_GXSFail

		lda 	gxzTemp0 					; illegal sprite #
		cmp 	#64
		bcs 	_GXSFail
		sta 	GSCurrentSpriteID

		ldy 	gxzTemp0+1 					; control value.
		lda  	#0 							; multiply sprite # x 8 => A
		asl 	gxzTemp0
		asl 	gxzTemp0
		asl 	gxzTemp0
		rol 	a
		adc 	#$D9 						; sprite area
		sta 	GSCurrentSpriteAddr+1 		; address to GSCurrentSprite and gxzTemp
		sta 	gxzTemp0+1
		lda 	gxzTemp0
		sta 	GSCurrentSpriteAddr
		clc
		rts

_GXSFail:
		sec
		rts

; ************************************************************************************************
;
;							Select sprite image enable/disable control
;
; ************************************************************************************************

GXSelectImage: ;; <8:SpriteImage>
		lda 	gxSpritesOn
		beq 	_GXSIFail

		lda 	GSCurrentSpriteAddr+1 		; check sprite selected
		beq 	_GXSIFail 					; (checking the MSB)

		stz 	1

		lda 	gxzTemp0+1 					; push show/hide on the stack.
		bne 	_GXSIHide

		lda 	gxzTemp0 					; sprite image
		pha
		jsr 	GXOpenBitmap
		pla
		jsr 	GXFindSprite
		bcs 	_GXSICloseFail 				; no image

		ldy 	#1
		lda 	GSCurrentSpriteAddr
		sta 	gxzTemp0
		lda 	GSCurrentSpriteAddr+1
		sta 	gxzTemp0+1

		lda 	gxSpriteOffset
		sta	 	(gxzTemp0),y
		clc
		lda 	gxSpriteOffset+1
		adc 	gxSpriteOffsetBase
		iny
		sta	 	(gxzTemp0),y

		lda 	gxSpriteOffsetBase+1
		adc 	#0
		iny
		sta	 	(gxzTemp0),y

		lda 	gxSizeBits 					; get raw size
		eor 	#3 							; make it right (00=32 etc.)
		rol 	a 							; x 2
		asl 	a 							; x 4
		asl 	a 							; x 8
		asl 	a 							; x 16
		ora 	gxSpriteLUT 				; Or with LUT
		asl 	a 							; 1 shift
		ora 	#1 							; enable sprite.
		sta 	(gxzTemp0) 					; and write back
		jsr 	GXCloseBitmap
		;
		ldx 	GSCurrentSpriteID 			; point to sprite entries.
		lda 	gxSpriteHigh,x 				; clear upper two bits of size
		and 	#$3F
		sta 	gxSpriteHigh,x
		lda 	gxSizeBits 					; get bit size
		ror 	a 							; shift into bits 6/7
		ror 	a
		ror 	a
		and 	#$C0
		ora 	gxSpriteHigh,x 				; put in  upper 2 bits of sprite data
		sta 	gxSpriteHigh,x
		;
		lda 	gxSpriteLow,x 				; clear hidden flag.
		and 	#$7F
		sta 	gxSpriteLow,x
		clc
		rts

_GXSICloseFail:
		jsr 	GXCloseBitmap
_GXSIFail:
		sec
		rts

_GXSIHide:
		lda 	GSCurrentSpriteAddr  		; get Sprite h/w address and write there
		sta 	gxzTemp0
		lda 	GSCurrentSpriteAddr+1
		sta 	gxzTemp0+1
		lda 	#0
		sta 	(gxzTemp0)
		ldx 	GSCurrentSpriteID 			; get sprite ID
		lda 	gxSpriteLow,x 				; set the hidden bit.
		ora 	#$80
		sta 	gxSpriteLow,x
		clc
		rts


; ************************************************************************************************
;
;									Move Sprite
;
; ************************************************************************************************

GXMoveSprite: ;; <41:SpriteMove>
		lda 	gxSpritesOn
		beq 	_GXSIFail

		lda 	GSCurrentSpriteAddr+1 		; check sprite selected
		beq 	_GXSIFail

		sta 	gxzTemp0+1
		ldy 	#4
		lda 	GSCurrentSpriteAddr
		sta 	gxzTemp0
		;
		ldx 	GSCurrentSpriteID 			; get the size from the upper two bits
		lda 	gxSpriteHigh,x
		rol 	a	 						; into bits 0,1.
		rol 	a
		rol 	a
		and 	#3
		tax
		lda 	_GXMSOffset,x 				; get 32-SpriteSize/2
		pha
		;
		clc
		adc 	gxX0						; copy position.
		sta 	(gxzTemp0),y
		iny
		lda 	gxX0+1
		adc 	#0
		sta 	(gxzTemp0),y
		iny
		pla
		clc
		adc 	gxY0
		sta 	(gxzTemp0),y
		lda 	#0
		adc 	#0
		iny
		sta 	(gxzTemp0),y
		;
		lsr 	gxX0+1 						; divide X by 4
		ror 	gxX0
		lsr 	gxX0
		;
		lsr 	gxY0 						; divide Y by 4
		lsr 	gxY0

		ldx 	GSCurrentSpriteID 			; copy X/4 and Y/4 into the status bytes
		lda 	gxSpriteLow,x
		and 	#$80
		ora 	gxX0
		sta 	gxSpriteLow,x

		lda 	gxSpriteHigh,x
		and 	#$C0
		ora 	gxY0
		sta 	gxSpriteHigh,x
		clc
		rts

_GXSIFail:
		sec
		rts

_GXMSOffset:
		.byte 	32-8/2
		.byte 	32-16/2
		.byte 	32-24/2
		.byte 	32-32/2
		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		tiles.asm
;		Purpose:	Tile update Functions
;		Created:	22nd February 2022
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;											Select tile
;
; ************************************************************************************************

GXSelectTile: ;; <14:TilePos>
		lda 	gxTilesOn 					; check tilemap in use
		beq 	_GXSFail


		lda 	gxzTemp0 					; check X and Y in range
		cmp 	gxTileMapWidth
		bcs 	_GXSFail
		lda 	gxzTemp0+1
		cmp 	gxTileMapHeight
		bcs 	_GXSFail

		lda 	gxTileMapPage 				; page to access = tile access page.
		sta 	gxTileAccessPage
		;
		;		Calculate tilemapwidth . y + x
		;
		ldx 	gxTileMapWidth 				; YX is the additive, e.g. shifted left. gxzTemp0+1 is shifted right.
		ldy 	#0

		lda 	gxzTemp0 					; initial result is X
		sta 	gxTileAccessAddress
		stz  	gxTileAccessAddress+1
_GXSTMultiply:
		lsr 	gxzTemp0+1 					; shift Y right
		bcc 	_GXSTNoAdd 					; add if CS

		clc 								; add YX to result
		txa
		adc 	gxTileAccessAddress
		sta 	gxTileAccessAddress
		tya
		adc 	gxTileAccessAddress+1
		sta 	gxTileAccessAddress+1
_GXSTNoAdd:
		txa 								; shift YX left
		asl 	a
		tax
		tya
		rol 	a
		tay
		lda 	gxzTemp0+1 					; multiply complete
		bne 	_GXSTMultiply

		asl 	gxTileAccessAddress 		; double it, as it is a word array.
		rol 	gxTileAccessAddress+1

_GXSTFixAddressLoop: 						; force address into page range and adjust page
		jsr 	GXSTFixAddress
		bcs 	_GXSTFixAddressLoop
		clc
		rts
_GXSFail:
		sec
		rts

; ************************************************************************************************
;
;						Adjust page:address so it is a valid page:address offset
;
; ************************************************************************************************

GXSTFixAddress:
		pha
		lda 	gxTileAccessAddress+1 		; in legal page range e.g. $0000-$1FFF
		cmp 	#$20
		bcc 	_GXSTFAExit
		sbc 	#$20 						; adjust address
		inc 	gxTileAccessPage 			; adjust page up.
		sec
_GXSTFAExit:
		pla
		rts

; ************************************************************************************************
;
;								Write a tile and advance
;
; ************************************************************************************************

GXSTWriteTile: ;; <15:TileWrite>
		sec 								; CS = update flag
		bra 	GXSTTileAccess
GXSTReadTile: ;; <16:TileRead>
		clc
GXSTTileAccess:
		lda 	GXEditSlot 					; save oroginal page
		pha
		php 								; save update flag
		;
		lda 	gxTileAccessPage 			; access the tile page.
		sta 	GXEditSlot
		;
		ldx 	gxzTemp0 					; X = New value
		;
		lda 	gxTileAccessAddress 		; set gxzTemp0 to point there
		sta 	gxzTemp0
		lda 	gxTileAccessAddress+1
		ora 	#(GXMappingAddress >> 8)
		sta 	gxzTemp0+1
		;
		plp 								; get flag
		bcc 	_GXSNoUpdate 				; updating the tile map ?
		;
		txa 								; new value
		sta 	(gxzTemp0) 					; write it out, as a word.
		ldy 	#1
		lda 	#0
		sta 	(gxzTemp0),y
_GXSNoUpdate:
		lda 	(gxzTemp0) 					; read the value

		plx 								; restore old page
		stx 	GXEditSlot

		inc 	gxTileAccessAddress 		; advance tile ptr by 2 - will always be even.
		inc 	gxTileAccessAddress
		bne 	_GXSNoCarry
		inc 	gxTileAccessAddress+1
_GXSNoCarry:
		jsr 	GXSTFixAddress 				; fix address if required.

		clc 								; return with ok flag.
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		access.asm
;		Purpose:	Lock/Unlock bitmap access
;		Created:	6th October 2022
;		Reviewed: 	9th February 2023
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;							Set up ready to access the bitmap
;
; ************************************************************************************************

GXOpenBitmap:
		sei 								; no interrupts here
		lda 	GXEditSlot 					; Save the original LUT slot value
		sta 	gxOriginalLUTValue
		cli
		rts

; ************************************************************************************************
;
;							Tidy up after accessing the bitmap
;
; ************************************************************************************************

GXCloseBitmap:
		sei
		lda 	gxOriginalLUTValue 			; restore LUT slot value
		sta 	GXEditSlot
		cli
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		line.asm
;		Purpose:	Line drawing code
;		Created:	6th October 2022
;		Reviewed: 	9th February 2023
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;		For gxX0,gxY0 calculate position in gxzScreen, offset in gxOffset and select current
;		segment.
;
; ************************************************************************************************
;
;		The main calculation is gxY0*320 = gxY0 * 5 * 64
;
gxPositionCalc:
		lda 	gxzTemp0 						; save temp memory slot
		pha
		;
		;		Calculate gxY0 * 5 => gxzScreen
		;
		lda 	gxY0 							; gxzScreen = Y0
		sta 	gxzScreen
		stz 	gxzScreen+1
		;
		asl 	gxzScreen 						; gxzScreen = Y0 * 4
		rol 	gxzScreen+1
		asl 	gxzScreen
		rol 	gxzScreen+1
		;
		clc 									; gxzScreen = Y0 * 5, as it's still in A
		adc 	gxzScreen
		sta 	gxzScreen
		bcc 	_GXPCNoCarry
		inc 	gxzScreen+1
_GXPCNoCarry:
		;
		;		Calculate gxY0 * 10
		;
		asl 	gxzScreen 						; now Y0 * 10
		rol 	gxzScreen+1
		;
		; 		Save MSB and zero it. Think of s+1.s+0 as a decimal fraction of 32nds. The LSB multiplied
		;		by 32 gives range 0..8191 (255*32 so 8160 technically). The MSB would be multiplied by 32*256
		;		to give an address, but then redivided by 32*256 to give the page offset.
		;
		lda	 	gxzScreen+1
		sta 	gxzTemp0 						; the page offset.
		stz 	gxzScreen+1
		;
		;		Multiply by 32 (e.g. 2^5)
		;
		lda 	#5 								; now multiply by 32, this puts this in the range 0..8191
_GXPCMultiply32:
		asl 	gxzScreen
		rol 	gxzScreen+1
		dec 	a
		bne 	_GXPCMultiply32
		;
		;		Add gxX0 to this, then split it into the offset (LSB) and address (MSB) because when we are writing to (xx),y
		;		xx.0 is always zero, to improve tracking of page changes.
		;
		clc
		lda 	gxX0 						; add X to this value, put the result in gxOffset, gxzScreen has to be on a page boundary
		adc 	gxzScreen
		sta 	gxOffset
		lda 	gxX0+1
		adc 	gxzScreen+1
		;
		;		Adding could shift into the next page, so if >$20 shift into range and adjust the page number.
		;
		cmp 	#$20 						; has it overflowed into the next one ?
		bcc 	_GXPCNoOverflow
		and 	#$1F 						; fix it up
		inc 	gxzTemp0 					; add 1 to the page number
_GXPCNoOverflow:
		;
		;		Make it a real address in zero page with the LSB,0, provideing page gxzTemp0 is selected.
		;
		ora 	#(GXMappingAddress >> 8) 	; make it the address mapped in.
		sta 	gxzScreen+1
		stz 	gxzScreen
		;
		;		Add the page offset to the base page and map it in.
		;
		clc
		lda 	gxzTemp0 					; get the page number
		adc 	gxBasePage 					; by adding the base page
		sta 	GXEditSlot 					; and map it into memory.
		;
		pla
		sta 	gxzTemp0
		rts

; ************************************************************************************************
;
;						Move the (gxzScreen),gxOffset down one line
;
; ************************************************************************************************

GXMovePositionDown:
		clc 								; add 320 to offset/temp+1
		lda 	gxOffset
		adc 	#64
		sta 	gxOffset
		lda 	gxzScreen+1
		adc 	#1
		sta 	gxzScreen+1
		cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
		bcc 	_GXMPDExit
		sec  								; next page, adjust address
		sbc 	#$20
		sta 	gxzScreen+1
		inc 	GXEditSlot 					; bump page
_GXMPDExit:
		rts
		.send 	code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		collide.asm
;		Purpose:	Check if two sprites collide.
;		Created:	1st November 2022
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;					 				Collision of Sprites
;
; ************************************************************************************************

GXCollide: 	;; <9:SpriteCollide>
		lda 	gxzTemp0 					; check if sprite numbers are legal.
		tax
		ora 	gxzTemp0+1
		and 	#$C0
		sec
		bne 	_GXCollideFail 				; if either >= 64, fail.
		ldy 	gxzTemp0+1 					; at this point X is 1st sprite and Y is 2nd sprite.
		;
		lda 	gxSpriteLow,y 				; check if either hidden bit is set
		ora 	gxSpriteLow,x
		bmi 	_GXOkayFail 				; if either hidden, then they cannot collide.
		;
		clc 								; need to calculate sum of sizes.
		lda 	gxSpriteHigh,y
		adc 	gxSpriteHigh,x 				; at this point, CS, Bit 6 and 7 contain that sum.
		;
		;		So for 24 (10) and 32 (11) after AND CS:A is 1:0100 0000
		;		After the shifts it is 1:0100 (20)
		;		Adding the 8 (allowing for 00) => 28 which is (24+32)/2
		;
		;		Then adjust for coordinates being stored / 2
		;
		and 	#$C0 					 	; mask off
		ror 	a 							; 5/6/7
		lsr 	a 							; 4/5/6
		lsr 	a 							; 3/4/5
		lsr 	a 							; 2/3/4
		clc
		adc 	#$08
		lsr 	a 							; adjust because all coordinates are divided by 4 to store.
		lsr 	a
		sta 	gxzTemp1 					; so the difference between the centres has to be less than this.
		;
		lda 	gxSpriteHigh,y 				; calculate y1-y0
		and 	#$3F
		sta 	gxzTemp1+1
		sec
		lda 	gxSpriteHigh,x
		and 	#$3F
		sbc 	gxzTemp1+1
		bcs 	_GXCAbs1 					; calculate |y1-y0|
		eor 	#$FF
		inc 	a
_GXCAbs1:
		cmp 	gxzTemp1 					; if >= difference then no overlap
		bcs 	_GXOkayFail
		sta 	gxzTemp1+1 					; save |y1-y0|
		;
		sec 								; calculate |x1-x0|
		lda 	gxSpriteLow,y
		sbc 	gxSpriteLow,x
		bcs 	_GXCAbs2
		eor 	#$FF
		inc 	a
_GXCAbs2:
		cmp 	gxzTemp1 					; if >= difference then no overlap
		bcs 	_GXOkayFail
		;
		cmp 	gxzTemp1+1 					; is it less than the previous one.
		bcc 	_GXCHaveLowest
		lda 	gxzTemp1+1 					; if not, that's the smallest difference.
_GXCHaveLowest:
		asl 	a 							; scale to allow for >> 2
		asl 	a
		clc
		rts

_GXOkayFail:
		clc
_GXCollideFail:
		lda 	#$FF
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		find.asm
;		Purpose:	Get address, size and LUT of sprite (address is offset from base)
;		Created:	10th October 2022
;		Reviewed: 	17th February 2022
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;					Get address, size and LUT of sprite A (assume already opened)
;					in sprite data structure. Returns CS if bad sprite, CC if okay.
;
; ************************************************************************************************

GXFindSprite:
		tax  								; sprite index in X

		stz 	gxSpriteOffset 				; sprite offset is the offset in the sprite list.
		stz 	gxSpriteOffset+1

		stz 	gxzTemp1 					; zTemp1 is the address in memory, given the current selected page.
		lda 	#GXMappingAddress >> 8
		sta 	gxzTemp1+1

		lda 	gxSpritePage 				; and point to the sprite page.
		sta 	GXEditSlot

		lda 	(gxzTemp1) 					; get the first sprite record header, identifying the format.
		cmp 	#$11						; should be $11
		bne 	_GXFSFail 					; if not, fail

		jsr 	_GXFSIncrement 				; increment pointers.
		;
		;		Main search loop
		;
_GXFindLoop:
		lda 	(gxzTemp1) 					; reached the end, if so then failed.
		cmp 	#$80
		beq 	_GXFSFail
		cpx 	#0 							; if zero, then found.
		beq 	_GXFSFound
		dex 								; decrement count.

		asl 	a 							; index into table
		tay 								; so we can look it up.

		clc 								; add LSB
		lda 	gxSpriteOffset
		adc 	_GXFSSizeTable,y
		sta 	gxSpriteOffset 				; these two should move in lock step.
		sta 	gxzTemp1
		bcc 	_GXNextNoCarry 				; adjust for carry as we add the MSB seperately.
		inc 	gxSpriteOffset+1
		inc 	gxzTemp1+1
_GXNextNoCarry:
		clc
		lda 	gxzTemp1+1 					; add MSB
		adc 	_GXFSSizeTable+1,y
		sta 	gxzTemp1+1
		lda 	gxSpriteOffset+1
		adc 	_GXFSSizeTable+1,y
		sta 	gxSpriteOffset+1
		jsr 	_GXFSNormalise 				; and normalise the page address.
		bra 	_GXFindLoop 				; and go round again.
		;
		;		Found the sprite, copy the data out.
		;
_GXFSFound:
		lda 	(gxzTemp1)					; get the bit size (e.g. 0-3)
		sta 	gxSizeBits
		inc 	a 							; 1,2,3,4 - calculating pixel size
		asl 	a 							; 2,4,6,8
		asl 	a 							; 4,8,12,16
		asl 	a 							; 8,16,24,32
		sta 	gxSizePixels

		jsr 	_GXFSIncrement 				; and to the LUT
		lda 	(gxzTemp1) 					; copy that out.
		sta 	gxSpriteLUT

		jsr 	_GXFSIncrement 				; and it now points to the first graphic data byte
		clc
		rts
;
;		Advance offset/address by 1.
;
_GXFSIncrement:
		inc 	gxSpriteOffset 				; these two should move in sync
		inc 	gxzTemp1
		bne 	_GXFSNormalise
		inc 	gxSpriteOffset+1
		inc 	gxzTemp1+1
;
;		If overflow, adjust back.
;
_GXFSNormalise:
		lda 	gxzTemp1+1 					; are we out of range.
		cmp 	#(GXMappingAddress >> 8)+$20
		bcc 	_GXFSOkay
		inc 	GXEditSlot 					; next 8k page
		sec 								; adjust page address back
		sbc 	#$20
		sta 	gxzTemp1+1
_GXFSOkay:
		rts

_GXFSFail:
		sec
		rts
;
;		Total size of each sprite entry (pixel size^2 + lut + size)
;
_GXFSSizeTable:
		.word 	8*8+2,16*16+2,24*24+2,32*32+2

		.send code

		.section storage

gxSizePixels: 									; sprite size (in pixels)
		.fill 	1
gxSizeBits: 								; size (0-3)
		.fill 	1
gxSpriteLUT: 									; LUT to use
		.fill 	1
gxSpriteOffset: 								; offset from base page.
		.fill 	2

		.send storage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		sort.asm
;		Purpose:	Coordinate sorting code
;		Created:	6th October 2022
;		Reviewed: 	9th February 2023
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;			Sort X and Y coordinates - topleft/bottom right - rectangles, circles etc.
;
; ************************************************************************************************

GXSortXY:
		jsr 	GXSortY 					; will be sorted on Y now
		lda 	gxX0 						; compare X0 v X1
		cmp 	gxX1
		lda 	gxX0+1
		sbc 	gxX1+1
		bcc 	_GXSXYExit 					; X0 < X1 exit
		ldx 	#0 							; swap them over
		ldy 	#4
		jsr 	GXSwapXY
		inx
		iny
		jsr 	GXSwapXY
_GXSXYExit:
		rts

; ************************************************************************************************
;
;			Sort coordinate pairs so Y1 >= Y0, swaps X as well keeping pairs together
;
; ************************************************************************************************

GXSortY:
		lda 	gxY0 						; if Y0 >= Y1
		cmp 	gxY1
		bcc 	_GXSYSorted
		;
		ldx 	#3 							; swap 3-0 - for lines we want to sort but keep lines together
		ldy 	#7 							; with 4-7
_GXSwap1:
		jsr 	GXSwapXY
		dey
		dex
		bpl 	_GXSwap1
_GXSYSorted:
		rts

; ************************************************************************************************
;
;								Swap offset X,Y from gxX0
;
; ************************************************************************************************

GXSwapXY:
		lda 	gxX0,x
		pha
		lda 	gxX0,y
		sta 	gxX0,x
		pla
		sta 	gxX0,y
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
