;
;	This file is automatically generated
;

kernelIntegrated=1

; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		io.asm
;		Purpose:	Input/Output kernel commands
;		Created:	22nd December 2022
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;											Get Character
;
;	Returns:
;			8 		Backspace, if not far left
;			9 		Tab spacing (Ctrl+I)
;			13 		CR/LF with scrolling if required
;			32..127	Corresponding ASCII character
;
; ************************************************************************************************

Export_KNLInputSingleCharacter:
PagedInputSingleCharacter:
		phx
		phy
_EISCWait:
		.tickcheck PagedSNDUpdate 			; sound processing carries on.
		jsr 	CheckKeyPressed
		cmp 	#0 							; loop back if none pressed.
		beq 	_EISCWait
		ply
		plx
		rts

; ************************************************************************************************
;
;									Check if keyboard pressed.
;
; ************************************************************************************************

Export_KNLInkey:
CheckKeyPressed:
;		jmp 	$FFE4						; *** remove to use kernel functionality ***

		lda     #<event 					; tell kernel where events go.
		sta     kernel.args.events+0
		lda     #>event
		sta     kernel.args.events+1

		jsr     kernel.NextEvent 			; get next event
		bcs 	_CKPNoEvent 				; no event
		lda     event.type
		cmp     #kernel.event.key.PRESSED 	; must be a pressed event.
		bne 	_CKPNoEvent
		lda     event.key.ascii
		rts
_CKPNoEvent:
		lda 	#0
		rts

; ************************************************************************************************
;
;				Break Check. Checks Ctrl+C, Escape or whatever. Returns Z if pressed
;
; ************************************************************************************************

Export_EXTBreakCheck:
		jmp		$FFE1

; ************************************************************************************************
;
;						Read Game Controller A -> A (Button1/Right/Left/Down/Up)
;
; ************************************************************************************************

Export_EXTReadController:
		phx
		ldx 	1 							; save current I/O in X
		stz 	1 							; switch to I/O 0
		lda 	$DC00  						; read VIA register
		stx 	1 							; repair old I/O and exit
		plx
		rts
		.send code

		.section storage
event       .dstruct    kernel.event.event_t
		.send storage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		openclose.asm
;		Purpose:	File Input/Output commands
;		Created:	30th December 2022
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;				Set errors so not directly accessing variables.
;
; ************************************************************************************************

KERR_GENERAL = kernel.event.file.ERROR 		; Event $38
KERR_CLOSED = kernel.event.file.CLOSED 		; Event $32
KERR_NOTFOUND = kernel.event.file.NOT_FOUND ; Event $28
KERR_EOF = kernel.event.file.EOF 			; Event $30

; ************************************************************************************************
;
;				Open file for input/output, CS = failed (drive/file not found likely)
;
; ************************************************************************************************

Export_KNLOpenFileRead:
		pha
        lda     #kernel.args.file.open.READ ; set READ mode.
        sta     kernel.args.file.open.mode
        pla

		jsr 	KNLSetupFileName

        lda     #event & $FF 				; tell kernel where to store event data
        sta     kernel.args.events+0
        lda     #event >> 8
        sta     kernel.args.events+1

		lda 	#0 							; currently drive zero only.
		sta 	kernel.args.file.open.drive

        jsr     kernel.File.Open 			; open the file and exit.
        rts

; ************************************************************************************************
;
;									Close currently open file
;
; ************************************************************************************************

Export_KNLCloseFile:
		lda     event.file.stream 			; close the stream
		sta     kernel.args.file.close.stream
		jsr     kernel.File.Close
		rts

; ************************************************************************************************
;
;					Converts ASCIIZ filename in XA to Kernel internal format.
;
; ************************************************************************************************

KNLSetupFileName:
		phy 								; save Y on stack
		sta 	zTemp0 						; save filename position in temp, and in kenrel slot
		stx 	zTemp0+1
        sta     kernel.args.file.open.fname+0
        stx     kernel.args.file.open.fname+1
        ;
        ldy 	#$FF 						; get the filename length => Kernel slot
_KNLGetLength:
		iny
		lda 	(zTemp0),y
		bne 	_KNLGetLength
		sty 	kernel.args.file.open.fname_len
		ply
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		readbyte.asm
;		Purpose:	Read a single byte from the currently open file.
;		Created:	30th December 2022
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;				Read one character into A. CC = succeeded, CS = failed, A = Event error
;
; ************************************************************************************************

Export_KNLReadByte:

EventLoop:
		jsr     kernel.Yield    			; event wait
		jsr     kernel.NextEvent
		bcs     EventLoop
		lda 	event.type 					; get event
		;
		;		One of the error events.
		;
		cmp     #kernel.event.file.ERROR
		beq 	_KNLRBFail
		cmp     #kernel.event.file.CLOSED
		beq     _KNLRBFail
		cmp     #kernel.event.file.NOT_FOUND
		beq 	_KNLRBFail
		cmp     #kernel.event.file.EOF
		beq 	_KNLRBFail

		cmp     #kernel.event.file.OPENED 	; opened, do first read
		beq     _KNLRBRequestData
		cmp     #kernel.event.file.DATA 	; data, return data
		beq     _KNLRBAcquireData

		bra 	EventLoop
		;
		;		OPENED received, request first byte, then wait for it.
		;
_KNLRBRequestData:
		jsr 	KNLRequestNextByte
		bra 	EventLoop
		;
		;		DATA received, retrieve first byte, request next and return.
		;
_KNLRBAcquireData:
		lda 	#1 							; want a single character
        sta     kernel.args.recv.buflen

        lda     #zTemp0 & $FF 				; read it to zTemp0
        sta     kernel.args.recv.buf+0
        lda     #zTemp0 >> 8
        sta     kernel.args.recv.buf+1

        jsr     kernel.ReadData				; read the data into the buffer.
        lda 	zTemp0						; get it
        pha 								; save it
        jsr 	KNLRequestNextByte 			; request next byte.
        pla
        clc 								; return CC
        rts

_KNLRBFail:
		sec
		rts

KNLRequestNextByte:
        lda     event.file.stream 			; read which stream ?
        sta     kernel.args.file.read.stream

        lda     #1 							; so one byte at a time.
        sta     kernel.args.file.read.buflen

        jsr     kernel.File.Read 			; read request
        rts


		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
