;
;	This file is automatically generated
;

kernelIntegrated=1

; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		io.asm
;		Purpose:	Input/Output kernel commands
;		Created:	22nd December 2022
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;											Get Character
;
;	Returns:
;			8 		Backspace, if not far left
;			9 		Tab spacing (Ctrl+I)
;			13 		CR/LF with scrolling if required
;			32..127	Corresponding ASCII character
;
; ************************************************************************************************

Export_KNLInputSingleCharacter:
PagedInputSingleCharacter:
		phx
		phy
_EISCWait:
		.tickcheck PagedSNDUpdate 			; sound processing carries on.
		jsr 	CheckKeyPressed
		cmp 	#0 							; loop back if none pressed.
		beq 	_EISCWait
		ply
		plx
		rts

; ************************************************************************************************
;
;									Check if keyboard pressed.
;
; ************************************************************************************************

Export_KNLInkey:
CheckKeyPressed:
;		jmp 	$FFE4						; *** remove to use kernel functionality ***

		lda     #<event 					; tell kernel where events go.
		sta     kernel.args.events+0
		lda     #>event
		sta     kernel.args.events+1

		jsr     kernel.NextEvent 			; get next event
		bcs 	_CKPNoEvent 				; no event
		lda     event.type
		cmp     #kernel.event.key.PRESSED 	; must be a pressed event.
		bne 	_CKPNoEvent
		lda     event.key.ascii
		rts
_CKPNoEvent:
		lda 	#0
		rts

; ************************************************************************************************
;
;				Break Check. Checks Ctrl+C, Escape or whatever. Returns Z if pressed
;
; ************************************************************************************************

Export_EXTBreakCheck:
		jmp		$FFE1

; ************************************************************************************************
;
;						Read Game Controller A -> A (Button1/Right/Left/Down/Up)
;
; ************************************************************************************************

Export_EXTReadController:
		phx
		ldx 	1 							; save current I/O in X
		stz 	1 							; switch to I/O 0
		lda 	$DC00  						; read VIA register
		stx 	1 							; repair old I/O and exit
		plx
		rts
		.send code

		.section storage
event       .dstruct    kernel.event.event_t
		.send storage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		openclose.asm
;		Purpose:	File Input/Output commands
;		Created:	30th December 2022
;		Reviewed: 	No
;		Authors:	Paul Robson (paul@robsons.org.uk)
;					Jessie Oberreuter (gadget@hackwrenchlabs.com)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;						Set errors so not directly accessing variables.
;
; ************************************************************************************************

KERR_GENERAL = kernel.event.file.ERROR 		; Event $38
KERR_CLOSED = kernel.event.file.CLOSED 		; Event $32
KERR_NOTFOUND = kernel.event.file.NOT_FOUND ; Event $28
KERR_EOF = kernel.event.file.EOF 			; Event $30

; ************************************************************************************************
;
;									Open file for input/output
;
;		Succeeded : Carry Clear, A contains stream to read.
;		Failed :	Carry Set, A contains error event.
;
; ************************************************************************************************

Export_KNLOpenFileWrite:
		pha
		lda 	#kernel.args.file.open.WRITE
		bra 	KNLOpenStart

Export_KNLOpenFileRead:
		pha
		lda     #kernel.args.file.open.READ ; set READ mode.
KNLOpenStart:
		sta     kernel.args.file.open.mode
		pla

		jsr 	KNLSetupFileName

		lda     #event & $FF 				; tell kernel where to store event data
		sta     kernel.args.events+0
		lda     #event >> 8
		sta     kernel.args.events+1

		lda 	DefaultDrive 				; currently drive zero only.
		sta 	kernel.args.file.open.drive

		jsr     kernel.File.Open 			; open the file and exit.
		lda     #kernel.event.file.ERROR
		bcs     _out

_loop
		jsr     kernel.Yield    			; event wait
		jsr     kernel.NextEvent
		bcs     _loop

		lda 	event.type
		cmp     #kernel.event.file.OPENED
		beq 	_success
		cmp     #kernel.event.file.NOT_FOUND
		beq 	_out
		cmp     #kernel.event.file.ERROR
		beq 	_out
		bra     _loop

_success
		lda     event.file.stream
		clc
_out
		rts

; ************************************************************************************************
;
;						Close currently open file - A should countain stream
;
; ************************************************************************************************

Export_KNLCloseFile:
		sta     kernel.args.file.close.stream
		jsr     kernel.File.Close
		rts

; ************************************************************************************************
;
;					Converts ASCIIZ filename in XA to Kernel internal format.
;
; ************************************************************************************************

KNLSetupFileName:
		phy 								; save Y on stack
		sta 	zTemp0 						; save filename position in temp, and in kenrel slot
		stx 	zTemp0+1
		sta     kernel.args.file.open.fname+0
		stx     kernel.args.file.open.fname+1
		;
		ldy 	#$FF 						; get the filename length => Kernel slot
_KNLGetLength:
		iny
		lda 	(zTemp0),y
		bne 	_KNLGetLength
		sty 	kernel.args.file.open.fname_len
		ply
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		readbyte.asm
;		Purpose:	Read a single byte from the currently open file.
;		Created:	30th December 2022
;		Reviewed: 	No
;		Authors:	Paul Robson (paul@robsons.org.uk)
;                   Jessie Oberreuter (gadget@hackwrenchlabs.com)
;
; ************************************************************************************************
; ************************************************************************************************

KNLBufLen = 64 								; read buffer size.

		.section storage

KNLStream:   								; stream to read from
		.byte   ?
KNLBuf:      								; buffer
		.fill   KNLBufLen
KNLNext:     								; next byte to return
		.byte   ?
KNLEnd:      								; end of bytes available.
		.byte   ?

		.send storage

		.section code

; ************************************************************************************************
;
;				Init the reader.  A = file stream; can't fail.
;
; ************************************************************************************************

Export_KNLReadByteInit:
		sta     KNLStream 					; save stream
		stz     KNLNext 					; reset buffer
		stz     KNLEnd
		rts

; ************************************************************************************************
;
;				Read one character into A. CC = succeeded, CS = failed, A = Event error
;               Stream closed and CS when finished (A = EOF)
;
; ************************************************************************************************

Export_KNLReadByte:
		phx

		ldx     KNLNext 					; all data consumed ?
		cpx     KNLEnd
		bne     _KNLRBGetNextByte
		;
	  	; 		Buffer empty; try to fetch more.
	  	;
		jsr     KNLRBGetNextBlock 			; read next chunk from the stream
		bcs     _KNLRBError 				; error has occurred on read.
		;
		sta     KNLEnd 						; # read is the number available
		ldx     #0 							; reset the read pointer.
		stx     KNLNext
		;
		;		Get next byte from the buffer
		;
_KNLRBGetNextByte:
		lda     KNLBuf,x 					; get the next data item
		inc     KNLNext 					; and advance the index
		clc 								; succeeded
_KNLRBError:
		plx
		rts

; ************************************************************************************************
;
;								Read next block from the stream
;
; ************************************************************************************************

KNLRBGetNextBlock:
		lda     KNLStream 					; set stream to read from
		sta     kernel.args.file.read.stream

		lda     #KNLBufLen 					; set bytes to read.
		sta     kernel.args.file.read.buflen

		jsr     kernel.File.Read 			; read request
		lda     #kernel.event.file.ERROR    ; Kernel out of events/buffers; shouldn't happen
		bcs     _KGNBExitFail               ; report as general error

_KGRBEventLoop:
		jsr     kernel.Yield    			; event wait
		jsr     kernel.NextEvent
		bcs     _KGRBEventLoop

		lda 	event.type 					; get event

		cmp     #kernel.event.file.DATA 	; data, return data
		beq     _KNLRBGetNextByte

		cmp     #kernel.event.file.ERROR  	; errors on file i/o, return as appropriate.
		beq 	_KGNBExitFail

		cmp     #kernel.event.file.EOF
		beq 	_KGNBExitFail

		bra 	_KGRBEventLoop
		;
		;		Get the next data block into the buffer
		;
_KNLRBGetNextByte:

		lda     #<KNLBuf 					; Set the target buffer
		sta     kernel.args.recv.buf+0
		lda     #>KNLBuf
		sta     kernel.args.recv.buf+1

		lda     event.file.data.read 		; Set the target length
		sta     kernel.args.recv.buflen

		jsr     kernel.ReadData		       	; Get the data from the kernel  (Synchronous call, no error)
		lda     event.file.data.read 		; Return # of bytes read (in A)

		clc
		rts

_KGNBExitFail:
		sec
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		writeblock.asm
;		Purpose:	Wrote a block of memory to
;		Created:	30th December 2022
;		Reviewed: 	No
;		Authors:	Paul Robson (paul@robsons.org.uk)
;                   Jessie Oberreuter (gadget@hackwrenchlabs.com)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;							Write data at (zTemp0) to Stream A, X bytes.
;
;					  On error CS ; A = code. On success, CC, A = bytes read.
;
; ************************************************************************************************

Export_KNLWriteBlock:
		phx
		phy
		;
		;		Already handled OPENED so can write out.
		;
		sta     kernel.args.file.write.stream ; save the stream.

		lda     zTemp0 						; save the data location.
		sta     kernel.args.file.write.buf+0
		lda     zTemp0+1
		sta     kernel.args.file.write.buf+1

		stx     kernel.args.file.write.buflen ; Set the buffer length

		jsr     kernel.File.Write 			; write it out.
		lda 	#kernel.event.file.ERROR 	; in case it fails.
		bcs 	_KWBFailed

_KNLWLoop:									; wait for an event.
		jsr     kernel.Yield
		jsr     kernel.NextEvent
		bcs     _KNLWLoop

		lda     event.type 					; various errors.
		cmp     #kernel.event.file.CLOSED
		beq 	_KWBFailed
		cmp     #kernel.event.file.ERROR
		beq 	_KWBFailed
		cmp     #kernel.event.file.EOF
		beq 	_KWBFailed

		cmp     #kernel.event.file.WROTE 	; wait until block write succeeds
		bne 	_KNLWLoop
		clc
		lda    event.file.wrote.wrote 		; get bytes written.
		bra 	_KWBExit

_KWBFailed:
		sec
_KWBExit:
		ply
		plx
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
