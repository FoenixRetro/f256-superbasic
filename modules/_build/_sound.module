;
;	This file is automatically generated
;

soundIntegrated=1

; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		checkchannel.asm
;		Purpose:	Check if channel should play a note
;		Created:	21st November 2022
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;		For channel A, if off, check if there is a sound request in the queue and set up
;		appropriately.
;
; ************************************************************************************************

SNDCheckChannel:
		tax
		lda 	SNDTimeLeft,x 				; currently playing a note
		bne 	_SNDCCExit
		;
		phx 								; save current channel
		txa 								; put in A
		jsr 	SNDFindNextNoteForA 		; is there a note for A in the queue ?
		pla 								; channel # in A
		bcc 	_SNDCCExit  				; nothing in the queue for this channel, exit.
		;
		tay 								; Y is the channel #
		;
		lda 	SNDQueue+1,x 				; copy data into the slot.
		sta 	SNDPitchLow,y
		lda 	SNDQueue+2,x
		sta 	SNDPitchHigh,y
		lda 	SNDQueue+3,x
		sta 	SNDVolume,y
		lda 	SNDQueue+4,x
		sta 	SNDTimeLeft,y
		lda 	SNDQueue+5,x
		sta 	SNDAdjustLow,y
		lda 	SNDQueue+6,x
		sta 	SNDAdjustHigh,y
		;
		phy 								; save channel #
		jsr 	SNDDeleteXFromQueue 		; delete record at X from queue
		dec 	SNDLength 					; reduce the queue length.
		pla
		jsr 	SNDUpdateNote 				; update channel A
		;
_SNDCCExit:
		rts

; ************************************************************************************************
;
;									Update note A from status
;
; ************************************************************************************************

SNDUpdateNote:
		tax 								; so we can access records

		asl 	a 							; convert it to a channel bit pair in 5,6
		asl 	a
		asl 	a
		asl 	a
		asl 	a
		sta 	SNDChannelBits

		lda 	SNDTimeLeft,x 				; are we silent
		beq 	_SNDUNIsSilent
		;
		;		Turn on
		;
		lda 	SNDChannelBits 				; push channel bits on stack
		pha
		;
		lda 	SNDPitchLow,x 				; get 4 lowest bits of pitch.
		and 	#$0F
		ora 	SNDChannelBits 				; set channel bits
		ora 	#$80 						; write to pitch register
		jsr 	SNDWritePorts
		;
		lda 	SNDPitchHigh,x 				; pitch high => channel temp.
		sta 	SNDChannelBits
		lda 	SNDPitchLow,x
		;
		lsr 	SNDChannelBits 				; shift 2 LSBs into MSB of A
		ror 	a
		lsr 	SNDChannelBits
		ror 	a
		;
		lsr 	a 							; put in bits 0-5
		lsr 	a
		jsr 	SNDWritePorts 				; write as rest of pitch register
		;
		pla
		ora 	#$90 						; set to write minimum attentuation.
		jsr 	SNDWritePorts
		rts
		;
		;		Turn off
		;
_SNDUNIsSilent:
		lda 	SNDChannelBits 				; channel bits
		ora 	#$9F 						; maximum attenuation
		jsr 	SNDWritePorts 				; write to the ports
		rts

; ************************************************************************************************
;
;		Find next note for channel A in the Queue. If found, X is the 'slot' and CS, else CC.
;
; ************************************************************************************************

SNDFindNextNoteForA:
		ldy 	SNDLength 					; queue size into Y
		beq 	_SNDFNNFail 				; queue empty.
		ldx 	#0
_SNDFNNSearch:
		cmp 	SNDQueue,x 					; does it match the channel
		sec
		beq 	_SNDFNNExit 				; if so exit with CS.
		;
		inx 								; next queue slot.
		inx
		inx
		inx

		inx
		inx
		inx
		inx

		dey 								; done the whole queue
		bne 	_SNDFNNSearch 				; no, go back.
_SNDFNNFail:
		clc
_SNDFNNExit:
		rts

; ************************************************************************************************
;
;							Delete record offset X from queue
;
; ************************************************************************************************

SNDDeleteXFromQueue:
		cpx 	#SNDQueueSize*8-8 			; reached the end.
		beq 	_SNDDXExit
		lda 	SNDQueue+8,x
		sta 	SNDQueue,x
		inx
		bra 	SNDDeleteXFromQueue
_SNDDXExit:
		rts
		.send code

		.section storage
SNDChannelBits:
		.fill 	1
		.send storage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		enqueue.asm
;		Purpose:	Queue a channel request
;		Created:	21st November 2022
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;									Queue a sound command to YX
;
; ************************************************************************************************

SNDQueueRequest:
		stx 	zTemp0						; save queue address
		sty 	zTemp0+1
		;
		ldx 	SNDLength 					; queue is full, can't take any more.
		cpx 	#SNDQueueSize
		beq 	_SNDQRExit
		;
		and 	#3	 						; channel # and push on stack
		pha
		;
		txa  								; get offset in queue buffer/
		asl 	a
		asl 	a
		asl 	a
		tax
		;
		pla 								; get back and push again
		pha
		sta 	SNDQueue+0,x 				; save the channel #
		ldy 	#0 							; copy the rest in.
_SNDQCopy:
		lda 	(zTemp0),y
		inx
		iny
		sta 	SNDQueue,x
		cpy 	#6
		bne 	_SNDQCopy
		;
		inc 	SNDLength 					; bump queue length.
		;
		pla 								; get channel # back
		jsr 	SNDCheckChannel 			; check if channel needs refreshing.

_SNDQRExit:
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		silence.asm
;		Purpose:	Silence a channel
;		Created:	21st November 2022
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;									Silence a channel A
;
; ************************************************************************************************

SNDSilenceChannel:
		tax 								; zero time left.
		stz 	SNDTimeLeft,x
		;
		;		We do not remove queued entries for this channel because cannot currently silence
		; 		individual channels.
		;
		asl 	a 							; shift into position
		asl 	a
		asl 	a
		asl 	a
		asl 	a
		ora 	#$9F 						; write register attenuation $F
		jsr 	SNDWritePorts
		rts

; ************************************************************************************************
;
;									Write byte to left and right SN76489
;
; ************************************************************************************************

SNDWritePorts:
		phx 								; save X
		ldx 	1 							; save I/O status
		stz 	1 							; access I/O page 0
		sta 	$D600 						; write to both
		sta 	$D610
		stx 	1 							; restore I/O
		plx 								; restore X
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		sound.asm
;		Purpose:	Sound module entry point
;		Created:	21st November 2022
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;									Entry Point (command)
;
; ************************************************************************************************

Export_SNDCommand:
		phx 								; save XY
		phy

		cmp 	#$0F 						; $0F is initialise
		beq 	_SNDInitialise
		bcc 	_SNDExit
		cmp 	#$3F 						; $3F is silence all
		beq 	_SNDSilence
		bcs 	_SNDExit
		cmp 	#$20 						; $2x is check playing => A
		bcs 	_SNDQueryPlay
		cmp 	#$14 						; $10-$13 is queue sound
		bcs 	_SNDExit
		jsr 	SNDQueueRequest
		bra 	_SNDExit
;
;		Return A != 0 if channel currently playing a note.
;
_SNDQueryPlay:
		and 	#3 							; get channel #
		tax
		lda 	SNDTimeLeft,x 				; read time left, if zero then silent
		bra 	_SNDExit
;
;		Initialisation code (currently same as silence code)
;
_SNDInitialise:
;
;		Silence code
;
_SNDSilence:
		stz 	SNDLength 					; empty the queue.
		lda 	#$3 						; silence channel 0-3.
_SNDSilenceLoop:
		pha
		jsr 	SNDSilenceChannel
		pla
		dec 	a
		bpl 	_SNDSilenceLoop
_SNDExit:
		ply
		plx
		rts

		.send code

; ************************************************************************************************
;
;										Data area
;
; ************************************************************************************************

		.section storage
;
;		Queue of sounds to play
;
SNDQueueSize = 32 							; number of queue entries

SNDLength: 									; count currently in queue
		.fill 	1
SNDQueue: 	 								; 8 bytes per queue entry.
		.fill 	SNDQueueSize * 8
;
;		Current state of the four channels.
;
SNDPitchLow: 								; current pitch
		.fill 	4
SNDPitchHigh:
		.fill 	4

SNDVolume: 									; volume 0-15.
		.fill 	4

SNDTimeLeft: 								; time remaining, zero = no sound/get next
		.fill 	4

SNDAdjustLow:								; current slide
		.fill 	4
SNDAdjustHigh:
		.fill 	4

		.send 	storage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		update.asm
;		Purpose:	Possibly update all channels
;		Created:	21st November 2022
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;									Update / check all 4 channels
;
; ************************************************************************************************

Export_SNDUpdate:
PagedSNDUpdate:
		lda 	SNDTimeLeft+0 				; look at time remaining
		beq 	_SNDUNot0 					; not playing
		ldx 	#0 							; so we know which channel to update
		jsr 	SNDUpdateChannel 			; update it.
_SNDUNot0:

		lda 	SNDTimeLeft+1
		beq 	_SNDUNot1
		ldx 	#1
		jsr 	SNDUpdateChannel
_SNDUNot1:

		lda 	SNDTimeLeft+2
		beq 	_SNDUNot2
		ldx 	#2
		jsr 	SNDUpdateChannel
_SNDUNot2:

		lda 	SNDTimeLeft+3
		beq 	_SNDUNot3
		ldx 	#3
		jsr 	SNDUpdateChannel
_SNDUNot3:
		rts

; ************************************************************************************************
;
;									Update Channel X
;
; ************************************************************************************************

SNDUpdateChannel:
		cmp 	#$FF 						; sound $FF play forever until turned off manually
		beq 	_SNDUCExit
		dec 	a 							; decrement and update timer
		sta 	SNDTimeLeft,x
		beq 	_SNDUCUpdate 				; if zero, silence channel
		;
		lda 	SNDAdjustLow,x 				; adjust ?
		ora 	SNDAdjustHigh,x
		beq 	_SNDUCExit 					; if zero carry on at current tone.

		clc 								; add adjust, forcing into a 10 bit range
		lda 	SNDPitchLow,x
		adc 	SNDAdjustLow,x
		sta 	SNDPitchLow,x
		lda 	SNDPitchHigh,x
		adc 	SNDAdjustHigh,x
		and 	#3
		sta 	SNDPitchHigh,x

_SNDUCUpdate:
		txa 								; which channel.
		pha
		jsr 	SNDUpdateNote 				; update the current note
		pla
		jsr 	SNDCheckChannel 			; more to do ?
_SNDUCExit:
		rts
		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
