"""Build the module's output assembly file from `.asm`/`.inc` files.

Generates a single assembly build file by concatenating all source files from
a module directory, and creates a corresponding exports file listing all
exported functions found in the source code.

Generated files:
    <module_name>.module.asm    - Combined assembly source file
    <module_name>.exports       - List of exported function names, if any
"""

import os
import re
import sys
from pathlib import Path
from typing import TextIO

# regex for exported labels
export_re = re.compile(r"^\s*Export_(\w+)\s*:\s*(;.*)?$")


def main(*, module_name: str, build_dir: Path, page: int = 1) -> None:
    """Generate a single assembly build file for the specified module."""
    if not build_dir.exists():
        build_dir.mkdir(parents=True, exist_ok=True)

    sources = collect_sources(module_name)

    if page == 2:
        output_path = build_dir / (module_name + "_p2.module.asm")
    else:
        output_path = build_dir / (module_name + ".module.asm")

    with open(output_path, "w", encoding="utf-8") as out:
        # Write the output assembly file header
        out.write(";\n;\tThis file is automatically generated\n;\n")
        out.write(f"\n{module_name}Integrated=1\n\n")

        module_exports: list[str] = []
        for src in sources:
            # Scan each source file line-by-line, accumulating its exports
            # and writing its contents to the output.
            file_exports = process_source(src, out, page=page)
            module_exports.extend(file_exports)

        # Dump the collected exports to a file
        dump_exports(build_dir, module_name, module_exports, page=page)


def process_source(path: Path, out: TextIO, *, page: int = 1) -> list[str]:
    """Process a single source file, extracting exports and writing to output."""
    exports: list[str] = []

    with open(path, encoding="utf-8") as src:
        for line in src:
            if m := export_re.match(line):
                exports.append(m.group(1))

            if page == 2:
                normalized = " ".join(line.split())
                if normalized == ".section code":
                    out.write("\t\t.section page2\n")
                    out.write("\t\t.logical * + $6000\n")
                    continue
                elif normalized == ".send code":
                    out.write("\t\t.here\n")
                    out.write("\t\t.send page2\n")
                    continue

            out.write(f"{line.rstrip()}\n")

    return exports


def dump_exports(build_dir: Path, module_name: str, exports: list[str], *, page: int = 1) -> None:
    """Save module exports to the corresponding `.exports` file."""
    if not exports:
        return

    suffix = "_p2" if page == 2 else ""
    with open(build_dir / (module_name + suffix + ".exports"), "w", encoding="utf-8") as out:
        for export in exports:
            out.write(f"{export}\n")


def collect_sources(module_name: str) -> list[Path]:
    """Collects all source files for the given module."""
    source_files: list[Path] = []
    include_files: list[Path] = []

    # Collect all .asm and .inc files from the module directory
    for root, _dirs, files in os.walk(module_name):
        for file in files:
            file_name = Path(root) / file
            if file_name.suffix == ".asm":
                source_files.append(file_name)
            elif file_name.suffix == ".inc":
                include_files.append(file_name)

    # Sort the files to ensure a consistent build order
    include_files.sort()
    source_files.sort()

    return include_files + source_files


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Build module assembly file")
    parser.add_argument("module_name", help="Name of the module to build")
    parser.add_argument("build_dir", nargs="?", default=".build", help="Build output directory")
    parser.add_argument("--page", type=int, default=1, choices=[1, 2], help="Module page (1 or 2)")
    args = parser.parse_args()

    main(
        module_name=args.module_name,
        build_dir=Path(args.build_dir),
        page=args.page,
    )
