"""Build the module's output assembly file from `.asm`/`.inc` files.

Generates a single assembly build file by concatenating all source files from
a module directory, and creates a corresponding exports file listing all
exported functions found in the source code.

Generated files:
    <module_name>.module.asm    - Combined assembly source file
    <module_name>.exports       - List of exported function names, if any
"""

import os
import re
import sys
from pathlib import Path
from typing import TextIO

# regex for exported labels
export_re = re.compile(r"^\s*Export_(\w+)\s*:\s*(;.*)?$")


def main(*, module_name: str, build_dir: Path) -> None:
    """Generate a single assembly build file for the specified module."""
    if not build_dir.exists():
        build_dir.mkdir(parents=True, exist_ok=True)

    sources = collect_sources(module_name)
    output_path = build_dir / (module_name + ".module.asm")

    with open(output_path, "w", encoding="utf-8") as out:
        # Write the output assembly file header
        out.write(";\n;\tThis file is automatically generated\n;\n")
        out.write(f"\n{module_name}Integrated=1\n\n")

        module_exports: list[str] = []
        for src in sources:
            # Scan each source file line-by-line, accumulating its exports
            # and writing its contents to the output.
            file_exports = process_source(src, out)
            module_exports.extend(file_exports)

        # Dump the collected exports to a file
        dump_exports(build_dir, module_name, module_exports)


def process_source(path: Path, out: TextIO) -> list[str]:
    """Process a single source file, extracting exports and writing to output."""
    exports: list[str] = []

    with open(path, encoding="utf-8") as src:
        for line in src:
            if m := export_re.match(line):
                exports.append(m.group(1))

            out.write(f"{line.rstrip()}\n")

    return exports


def dump_exports(build_dir: Path, module_name: str, exports: list[str]) -> None:
    """Save module exports to the corresponding `.exports` file."""
    if not exports:
        return

    with open(build_dir / (module_name + ".exports"), "w", encoding="utf-8") as out:
        for export in exports:
            out.write(f"{export}\n")


def collect_sources(module_name: str) -> list[Path]:
    """Collects all source files for the given module."""
    source_files: list[Path] = []
    include_files: list[Path] = []

    # Collect all .asm and .inc files from the module directory
    for root, _dirs, files in os.walk(module_name):
        for file in files:
            file_name = Path(root) / file
            if file_name.suffix == ".asm":
                source_files.append(file_name)
            elif file_name.suffix == ".inc":
                include_files.append(file_name)

    # Sort the files to ensure a consistent build order
    include_files.sort()
    source_files.sort()

    return include_files + source_files


if __name__ == "__main__":
    if len(sys.argv) < 2:
        print(
            "Usage: python3 makebuild.py <module_name> [<build_directory>]",
            file=sys.stderr,
        )
        sys.exit(1)

    main(
        module_name=sys.argv[1],
        build_dir=Path(sys.argv[2] if len(sys.argv) > 2 else ".build"),
    )
