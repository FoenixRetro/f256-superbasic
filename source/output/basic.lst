
; 64tass Turbo Assembler Macro V1.57.2900 listing file
; 64tass -D AUTORUN=0 "-D MONITOR_ADDRESS=\$E000" "-D LOCKOUT_ADDRESS=\$F000" "-D BASIC_ADDRESS=\$38000" "-D SOURCE_ADDRESS=\$28000" "-D SPRITE_ADDRESS=\$30000" -q -b -Wall -c -D "HARDWARE=0 $'\x9'$'\x9'$'\x9'$'\x9'$'\x9'$'\x9'" -L output/basic.lst -l output/basic.lbl -Wall -o build/basic.rom _basic.asm
; Thu Dec  8 10:36:08 2022

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=0					AUTORUN=0
=$e000					 MONITOR_ADDRESS=$E000
=$f000					 LOCKOUT_ADDRESS=$F000
=$38000					 BASIC_ADDRESS=$38000
=$28000					 SOURCE_ADDRESS=$28000
=$30000					 SPRITE_ADDRESS=$30000
=0					HARDWARE=0

;******  Processing input file: _basic.asm


;******  Processing file: ./common/aa.system/01common.inc

=$30					ZeroPageMandatory = $30
=$50					ZeroPagePreference = $50
=$400					MemoryStorage = $400
=$2000					BasicStart = $2000
=$8000					BasicEnd = $8000
=$8000					CodeStart = $8000
=$1000					VariableSpace = $1000
=$2000					EndVariableSpace = $2000
=8					MathStackSize = 8
=512					BasicStackSize = 512
=3584					BasicStackBase = $1000-BasicStackSize
=80					MaxLineSize = 80

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/02macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/04data.inc

.0030					codePtr:
>0030							.fill 	4
.0034					basicStack:
>0034							.fill 	2
.0036					zTemp0:
>0036							.fill 	2
.0038					zTemp1:
>0038							.fill 	2
.003a					zTemp2:
>003a							.fill 	2
.003c					zsTemp:
>003c							.fill 	2
.003e					zaTemp:
>003e							.fill 	2
=$30					safePtr = codePtr 							; minimise direct tinkering
=$80					NSBIsNegative = $80 						; bit 7 : sign of mantissa (where numeric)
=$20					NSBIsReference = $20 						; bit 5 : is a reference
=$10					NSBIsString = $10 							; bit 4 : set if string (procedures don't go on the stack)
=$18					NSBTypeMask = $18 							; bits 4,3 : 00 int 01 float 10 string 11 procedure
=$03					NSBRefMask = $03 							; bits 0,1 : Bytes of reference, 00 = 4,01 = 1,10=2
=$04					NSBIsArray = $04
=$00					NSTInteger = $00 							; base types for bits 3..4
=$08					NSTFloat = $08
=$10					NSTString = $10
=$18					NSTProcedure = $18
.0050					NSStatus:
>0050							.fill 	MathStackSize
.0058					NSMantissa0:
>0058							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0060					NSMantissa1:
>0060							.fill 	MathStackSize
.0068					NSMantissa2:
>0068							.fill 	MathStackSize
.0070					NSMantissa3:
>0070							.fill 	MathStackSize
.0078					NSExponent:
>0078							.fill 	MathStackSize
.0400					identStart:
>0400							.fill 	1
.0401					identTypeStart:
>0401							.fill 	1
.0402					identTypeEnd:
>0402							.fill 	1
.0403					identHash:
>0403							.fill 	1
.0404					identTypeByte:
>0404							.fill 	1	 						; (see tokenising.pdf)
.0405					encodeState:
>0405							.fill 	1
.0406					digitTemp:
>0406							.fill 	1
.0407					decimalCount:
>0407							.fill 	1
.0408					randomSeed:
>0408							.fill 	4
.040c					lowMemPtr:
>040c							.fill 	2
.040e					stringMemory:
>040e							.fill 	2
.0410					stringInitialised:
>0410							.fill 	1
.0411					stringTempPointer:
>0411							.fill 	2
.0413					breakCheck:
>0413							.fill 	1
.0414					decimalPlaces:
>0414							.fill 	1
.0415					dbOffset:
>0415							.fill 	1
.0416					lastParameter:
>0416							.fill 	1
.0417					dataPointer:
>0417							.fill 	5
.041c					inDataStatement:
>041c							.fill 	1
.041d					tbOffset:
>041d							.fill 	1
.041e					AssemblerAddress:
>041e							.fill 	2
.0420					AssemblerControl:
>0420							.fill 	1
.0421					ParamStart:
>0421							.fill 	2
.0423					IsGroup1:
>0423							.fill 	1
.0424					BaseOpcode:
>0424							.fill 	1
.0425					ModeMask:
>0425							.fill 	1
.0426					listIndent:
>0426							.fill 	1
.0427					lcLastCharacter:
>0427							.fill 	1
.0428					isInputFlag:
>0428							.fill 	1
.0429					currentListColour:
>0429							.fill 	1
.042a					tokenOffset:
>042a							.fill 	1
.042b					tokenLineNumber:
>042b							.fill 	2
.042d					tokenBuffer:
>042d							.fill 	253
.052a					lineBuffer:
>052a							.fill 	253
.0627					numberBuffer:
>0627							.fill 	34
.0649					decimalBuffer:
>0649							.fill 	16

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/constants.inc

=$80					AM_ISZP = $80
=$40					AM_ISG1 = $40
=$20					AM_ISG2 = $20
=224					AM_IMMEDIATE = AM_ISZP+AM_ISG1+AM_ISG2+$00
=228					AM_ZEROPAGE = AM_ISZP+AM_ISG1+AM_ISG2+$04
=40					AM_ACC = AM_ISG2+$08
=108					AM_ABS = AM_ISG1+AM_ISG2+$0C
=208					AM_INDY = AM_ISZP+AM_ISG1+$10
=244					AM_ZEROX = AM_ISZP+AM_ISG1+AM_ISG2+$14
=120					AM_ABSY = AM_ISG1+AM_ISG2+$18
=124					AM_ABSX = AM_ISG1+AM_ISG2+$1C
=209					AM_IND = AM_ISZP+AM_ISG1+$11
=$80					AM_ZEROY = AM_ISZP
=$01					AM_INDABS = $01
=$02					AM_INDABSX = $02
=192					AM_INDX = AM_ISZP+AM_ISG1+$00

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/handlers.inc


;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.inc

=1					ERRID_BREAK = 1
=2					ERRID_SYNTAX = 2
=3					ERRID_DIVZERO = 3
=4					ERRID_RANGE = 4
=5					ERRID_TYPE = 5
=6					ERRID_MEMORY = 6
=7					ERRID_ARGUMENT = 7
=8					ERRID_STOP = 8
=9					ERRID_STRING = 9
=10					ERRID_ASSERT = 10
=11					ERRID_DATA = 11
=12					ERRID_NOTDONE = 12
=13					ERRID_LINE = 13
=14					ERRID_GOSUB = 14
=15					ERRID_REPEAT = 15
=16					ERRID_WHILE = 16
=17					ERRID_FOR = 17
=18					ERRID_STACK = 18
=19					ERRID_STRUCT = 19
=20					ERRID_PROC = 20
=21					ERRID_REDEFINE = 21
=22					ERRID_ARRAYSIZE = 22
=23					ERRID_ARRAYIDX = 23
=24					ERRID_ARRAYDEC = 24

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst.inc

=$00					KWD_LESSLESS                         = $00; $00 <<
=$01					KWD_LESSEQUAL                        = $01; $01 <=
=$02					KWD_LESSGREATER                      = $02; $02 <>
=$03					KWD_PLINGPLING3                      = $03; $03 !!3
=$04					KWD_GREATERLESS                      = $04; $04 ><
=$05					KWD_GREATEREQUAL                     = $05; $05 >=
=$06					KWD_GREATERGREATER                   = $06; $06 >>
=$07					KWD_PLINGPLING7                      = $07; $07 !!7
=$08					KWD_PLINGPLING8                      = $08; $08 !!8
=$09					KWD_PLINGPLING9                      = $09; $09 !!9
=$0a					KWD_PLINGPLING10                     = $0a; $0a !!10
=$0b					KWD_PLINGPLING11                     = $0b; $0b !!11
=$0c					KWD_PLINGPLING12                     = $0c; $0c !!12
=$0d					KWD_PLINGPLING13                     = $0d; $0d !!13
=$0e					KWD_PLINGPLING14                     = $0e; $0e !!14
=$0f					KWD_PLINGPLING15                     = $0f; $0f !!15
=$10					KWD_AT                               = $10; $10 @
=$11					KWD_PLINGPLING17                     = $11; $11 !!17
=$12					KWD_PLINGPLING18                     = $12; $12 !!18
=$13					KWD_LSQPAREN                         = $13; $13 [
=$14					KWD_BACKSLASH                        = $14; $14 \
=$15					KWD_RSQPAREN                         = $15; $15 ]
=$16					KWD_HAT                              = $16; $16 ^
=$17					KWD_UNDERSCORE                       = $17; $17 _
=$18					KWD_BQUOTE                           = $18; $18 `
=$19					KWD_PLINGPLING25                     = $19; $19 !!25
=$1a					KWD_PLINGPLING26                     = $1a; $1a !!26
=$1b					KWD_LCURLY                           = $1b; $1b {
=$1c					KWD_BAR                              = $1c; $1c |
=$1d					KWD_RCURLY                           = $1d; $1d }
=$1e					KWD_TILDE                            = $1e; $1e ~
=$21					KWD_PLING                            = $21; $21 !
=$22					KWD_DQUOTE                           = $22; $22 "
=$23					KWD_HASH                             = $23; $23 #
=$24					KWD_DOLLAR                           = $24; $24 $
=$25					KWD_PERCENT                          = $25; $25 %
=$26					KWD_AMPERSAND                        = $26; $26 &
=$27					KWD_QUOTE                            = $27; $27 '
=$28					KWD_LPAREN                           = $28; $28 (
=$29					KWD_RPAREN                           = $29; $29 )
=$2a					KWD_STAR                             = $2a; $2a *
=$2b					KWD_PLUS                             = $2b; $2b +
=$2c					KWD_COMMA                            = $2c; $2c ,
=$2d					KWD_MINUS                            = $2d; $2d -
=$2e					KWD_PERIOD                           = $2e; $2e .
=$2f					KWD_SLASH                            = $2f; $2f /
=$30					KWD_0                                = $30; $30 0
=$31					KWD_1                                = $31; $31 1
=$32					KWD_2                                = $32; $32 2
=$33					KWD_3                                = $33; $33 3
=$34					KWD_4                                = $34; $34 4
=$35					KWD_5                                = $35; $35 5
=$36					KWD_6                                = $36; $36 6
=$37					KWD_7                                = $37; $37 7
=$38					KWD_8                                = $38; $38 8
=$39					KWD_9                                = $39; $39 9
=$3a					KWD_COLON                            = $3a; $3a :
=$3b					KWD_SEMICOLON                        = $3b; $3b ;
=$3c					KWD_LESS                             = $3c; $3c <
=$3d					KWD_EQUAL                            = $3d; $3d =
=$3e					KWD_GREATER                          = $3e; $3e >
=$3f					KWD_QMARK                            = $3f; $3f ?
=$83					KWD_ABSLPAREN                        = $83; $83 ABS(
=$84					KWD_ALLOCLPAREN                      = $84; $84 ALLOC(
=$85					KWD_ASCLPAREN                        = $85; $85 ASC(
=$86					KWD_CHRDOLLARLPAREN                  = $86; $86 CHR$(
=$87					KWD_DEEKLPAREN                       = $87; $87 DEEK(
=$88					KWD_EVENTLPAREN                      = $88; $88 EVENT(
=$89					KWD_FALSE                            = $89; $89 FALSE
=$8a					KWD_FRACLPAREN                       = $8a; $8a FRAC(
=$8b					KWD_HITLPAREN                        = $8b; $8b HIT(
=$8c					KWD_INTLPAREN                        = $8c; $8c INT(
=$8d					KWD_ISVALLPAREN                      = $8d; $8d ISVAL(
=$8e					KWD_JOYBLPAREN                       = $8e; $8e JOYB(
=$8f					KWD_JOYXLPAREN                       = $8f; $8f JOYX(
=$90					KWD_JOYYLPAREN                       = $90; $90 JOYY(
=$91					KWD_LEFTDOLLARLPAREN                 = $91; $91 LEFT$(
=$92					KWD_LENLPAREN                        = $92; $92 LEN(
=$93					KWD_MAXLPAREN                        = $93; $93 MAX(
=$94					KWD_MIDDOLLARLPAREN                  = $94; $94 MID$(
=$95					KWD_MINLPAREN                        = $95; $95 MIN(
=$96					KWD_NOTLPAREN                        = $96; $96 NOT(
=$97					KWD_PEEKLPAREN                       = $97; $97 PEEK(
=$98					KWD_PLAYINGLPAREN                    = $98; $98 PLAYING(
=$99					KWD_RANDOMLPAREN                     = $99; $99 RANDOM(
=$9a					KWD_RIGHTDOLLARLPAREN                = $9a; $9a RIGHT$(
=$9b					KWD_RNDLPAREN                        = $9b; $9b RND(
=$9c					KWD_SGNLPAREN                        = $9c; $9c SGN(
=$9d					KWD_SPCLPAREN                        = $9d; $9d SPC(
=$9e					KWD_STRDOLLARLPAREN                  = $9e; $9e STR$(
=$9f					KWD_TIMERLPAREN                      = $9f; $9f TIMER(
=$a0					KWD_TRUE                             = $a0; $a0 TRUE
=$a1					KWD_VALLPAREN                        = $a1; $a1 VAL(
=$a2					KWD_FOR                              = $a2; $a2 FOR
=$a3					KWD_IF                               = $a3; $a3 IF
=$a4					KWD_PROC                             = $a4; $a4 PROC
=$a5					KWD_REPEAT                           = $a5; $a5 REPEAT
=$a6					KWD_WHILE                            = $a6; $a6 WHILE
=$a7					KWD_ENDIF                            = $a7; $a7 ENDIF
=$a8					KWD_ENDPROC                          = $a8; $a8 ENDPROC
=$a9					KWD_NEXT                             = $a9; $a9 NEXT
=$aa					KWD_THEN                             = $aa; $aa THEN
=$ab					KWD_UNTIL                            = $ab; $ab UNTIL
=$ac					KWD_WEND                             = $ac; $ac WEND
=$ad					KWD_BY                               = $ad; $ad BY
=$ae					KWD_CALL                             = $ae; $ae CALL
=$af					KWD_CIRCLE                           = $af; $af CIRCLE
=$b0					KWD_CLEAR                            = $b0; $b0 CLEAR
=$b1					KWD_CLS                              = $b1; $b1 CLS
=$b2					KWD_COLOR                            = $b2; $b2 COLOR
=$b3					KWD_COLOUR                           = $b3; $b3 COLOUR
=$b4					KWD_DATA                             = $b4; $b4 DATA
=$b5					KWD_DIM                              = $b5; $b5 DIM
=$b6					KWD_DOKE                             = $b6; $b6 DOKE
=$b7					KWD_DOWNTO                           = $b7; $b7 DOWNTO
=$b8					KWD_ELSE                             = $b8; $b8 ELSE
=$b9					KWD_FROM                             = $b9; $b9 FROM
=$ba					KWD_GFX                              = $ba; $ba GFX
=$bb					KWD_GOSUB                            = $bb; $bb GOSUB
=$bc					KWD_GOTO                             = $bc; $bc GOTO
=$bd					KWD_HERE                             = $bd; $bd HERE
=$be					KWD_IMAGE                            = $be; $be IMAGE
=$bf					KWD_INPUT                            = $bf; $bf INPUT
=$c0					KWD_LET                              = $c0; $c0 LET
=$c1					KWD_LINE                             = $c1; $c1 LINE
=$c2					KWD_LOCAL                            = $c2; $c2 LOCAL
=$c3					KWD_OFF                              = $c3; $c3 OFF
=$c4					KWD_ON                               = $c4; $c4 ON
=$c5					KWD_OUTLINE                          = $c5; $c5 OUTLINE
=$c6					KWD_PALETTE                          = $c6; $c6 PALETTE
=$c7					KWD_PLOT                             = $c7; $c7 PLOT
=$c8					KWD_POKE                             = $c8; $c8 POKE
=$c9					KWD_PRINT                            = $c9; $c9 PRINT
=$ca					KWD_READ                             = $ca; $ca READ
=$cb					KWD_RECT                             = $cb; $cb RECT
=$cc					KWD_REM                              = $cc; $cc REM
=$cd					KWD_RETURN                           = $cd; $cd RETURN
=$ce					KWD_SOLID                            = $ce; $ce SOLID
=$cf					KWD_SOUND                            = $cf; $cf SOUND
=$d0					KWD_SPRITE                           = $d0; $d0 SPRITE
=$d1					KWD_TEXT                             = $d1; $d1 TEXT
=$d2					KWD_TO                               = $d2; $d2 TO

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst0.inc

=$80					KWC_EOL = $80
=$ff					KWC_STRING = $FF
=$fe					KWC_HEXCONST = $FE
=$a2					KWC_FIRST_STRUCTURE = $a2
=$a7					KWC_FIRST_STRUCTURE_DEC = $a7
=$ac					KWC_LAST_STRUCTURE = $ac
=$83					KWC_FIRST_UNARY = $83
=$a1					KWC_LAST_UNARY = $a1

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/access.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/stack.inc

=$e0					STK_GOSUB = $E0
=$d0					STK_FOR = $D0
=$c0					STK_REPEAT = $C0
=$b0					STK_PROC = $B0
=$a0					STK_WHILE = $A0
=$01					STK_LOCALN = $01
=$02					STK_LOCALS = $02

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/00start.asm

.8000	4c 24 80	jmp $8024	Boot:	jmp 	Start

;******  Processing file: ./common/aa.system/../../../modules/_build/_linker.module

=0					PagingEnabled = 0
.8003					EXTPrintCharacter:
.8003	4c 00 a8	jmp $a800		jmp	Export_EXTPrintCharacter
.8006					EXTInitialise:
.8006	4c 99 aa	jmp $aa99		jmp	Export_EXTInitialise
.8009					EXTInputSingleCharacter:
.8009	4c cf aa	jmp $aacf		jmp	Export_EXTInputSingleCharacter
.800c					EXTBreakCheck:
.800c	4c f5 aa	jmp $aaf5		jmp	Export_EXTBreakCheck
.800f					EXTReadController:
.800f	4c f8 aa	jmp $aaf8		jmp	Export_EXTReadController
.8012					EXTInputLine:
.8012	4c af a9	jmp $a9af		jmp	Export_EXTInputLine
.8015					GXGraphicDraw:
.8015	4c 93 ab	jmp $ab93		jmp	Export_GXGraphicDraw
.8018					SNDCommand:
.8018	4c 78 be	jmp $be78		jmp	Export_SNDCommand
.801b					SNDUpdate:
.801b	4c ab be	jmp $beab		jmp	Export_SNDUpdate
.801e					TKListConvertLine:
.801e	4c 6e b8	jmp $b86e		jmp	Export_TKListConvertLine
.8021					TKTokeniseLine:
.8021	4c 02 bb	jmp $bb02		jmp	Export_TKTokeniseLine

;******  Return to file: ./common/aa.system/00start.asm

.8024	a2 ff		ldx #$ff	Start:	ldx 	#$FF 						; stack reset
.8026	9a		txs				txs
.8027	20 0c 80	jsr $800c			jsr 	EXTBreakCheck 				; added to stop initial break bug.
.802a	a5 00		lda $00				lda 	0  							; turn on editing of MMU LUT
.802c	09 80		ora #$80			ora 	#$80
.802e	85 00		sta $00				sta 	0
.8030	20 06 80	jsr $8006			jsr 	EXTInitialise 				; hardware initialise
.8033	a9 00		lda #$00			lda 	#0 							; graphics system initialise.
.8035	aa		tax				tax
.8036	a8		tay				tay
.8037	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.803a	a9 0f		lda #$0f			lda 	#$0F 						; initialise sound system
.803c	20 18 80	jsr $8018			jsr 	SNDCommand
.803f	a2 80		ldx #$80			ldx 	#Prompt >> 8 				; display prompt
.8041	a9 4f		lda #$4f			lda 	#Prompt & $FF
.8043	20 58 8f	jsr $8f58			jsr 	PrintStringXA
.8046	20 34 8a	jsr $8a34			jsr 	NewProgram 					; erase current program
.8049	4c dd 83	jmp $83dd			jmp 	WarmStart					; make same size.
.804c	4c dd 83	jmp $83dd			jmp 	WarmStart
>804f	36 35 30 32 20 53 75 70		Prompt:	.text 	"6502 SuperBASIC ("
>8057	65 72 42 41 53 49 43 20 28
>8060	31 36						.text 	"16"
>8062	6b 29 0d					.text 	"k)",13
>8065	43 6f 70 79 72 69 67 68				.text 	"Copyright 2022 Paul Robson",13
>806d	74 20 32 30 32 32 20 50 61 75 6c 20 52 6f 62 73
>807d	6f 6e 0d
>8080	50 61 75 6c 40 52 6f 62				.text  	"Paul@Robsons.org.uk",13
>8088	73 6f 6e 73 2e 6f 72 67 2e 75 6b 0d
>8094	46 32 35 36 20					.text "F256 "

;******  Processing file: ./common/aa.system/../generated/timestamp.asm

>8099	41 6c 70 68 61 20 31 33			.text "Alpha 13 built 08-Dec-22. "
>80a1	20 62 75 69 6c 74 20 30 38 2d 44 65 63 2d 32 32
>80b1	2e 20

;******  Return to file: ./common/aa.system/00start.asm

>80b3	0d						.byte  	13
>80b4	0d 0d 00					.text 	13,13,0

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/assembler.asm

.80b7					AssembleGroup1:
.80b7	a9 ff		lda #$ff			lda 	#$FF 						; flag for group 1 / mask.
.80b9	8d 25 04	sta $0425			sta 	ModeMask 					; initialise the mode mask - all for all
.80bc	80 02		bra $80c0			bra 	AsmGroup12
.80be					AssembleGroup2:
.80be	a9 00		lda #$00			lda 	#$00 						; flag for group 2
.80c0					AsmGroup12:
.80c0	8d 23 04	sta $0423			sta 	IsGroup1 					; save the 'group 1' flag
.80c3	68		pla				pla 								; pop the return address to access the information following.
.80c4	fa		plx				plx
.80c5	20 4c 81	jsr $814c			jsr 	AccessParameters 			; get opcode and save as base
.80c8	8d 24 04	sta $0424			sta 	BaseOpcode
.80cb	ad 23 04	lda $0423			lda 	IsGroup1 					; skip if group 1 as we don't have a complex mask.
.80ce	d0 08		bne $80d8			bne 	_AG12HaveMask
.80d0	a9 02		lda #$02			lda 	#2 							; if group 2 the second parameter is the mask
.80d2	20 54 81	jsr $8154			jsr 	GetParameter		 		; e.g. which modes are supported for this operand
.80d5	8d 25 04	sta $0425			sta 	ModeMask
.80d8					_AG12HaveMask:
.80d8	20 88 82	jsr $8288			jsr 	TypeAndCalculateOperand 	; get zero page type
.80db	da		phx				phx 								; save found address mode
.80dc	20 b8 81	jsr $81b8			jsr 	AssembleModeX
.80df	fa		plx				plx  								; restore address mode
.80e0	b0 0b		bcs $80ed			bcs 	_AG12Exit
.80e2	20 ee 80	jsr $80ee			jsr 	PromoteToAbsolute  			; promote ZP to ABS and try that
.80e5	20 b8 81	jsr $81b8			jsr 	AssembleModeX
.80e8	b0 03		bcs $80ed			bcs 	_AG12Exit
.80ea	4c a4 9f	jmp $9fa4			jmp 	SyntaxError 				; can't do either, so must be wrong mode/operand.
.80ed					_AG12Exit:
.80ed	60		rts				rts
.80ee					PromoteToAbsolute:
.80ee	a9 6c		lda #$6c			lda 	#AM_ABS 					; lda xx
.80f0	e0 e4		cpx #$e4			cpx 	#AM_ZEROPAGE
.80f2	f0 19		beq $810d			beq 	_PTADo
.80f4	a9 7c		lda #$7c			lda 	#AM_ABSX 					; lda xx,X
.80f6	e0 f4		cpx #$f4			cpx 	#AM_ZEROX
.80f8	f0 13		beq $810d			beq 	_PTADo
.80fa	a9 78		lda #$78			lda 	#AM_ABSY 					; lda xx,Y
.80fc	e0 80		cpx #$80			cpx 	#AM_ZEROY
.80fe	f0 0d		beq $810d			beq 	_PTADo
.8100	a9 01		lda #$01			lda 	#AM_INDABS 					; lda (xx) (jump)
.8102	e0 d1		cpx #$d1			cpx 	#AM_IND
.8104	f0 07		beq $810d			beq 	_PTADo
.8106	a9 02		lda #$02			lda 	#AM_INDABSX 				; lda (xx,x) (jump)
.8108	e0 c0		cpx #$c0			cpx 	#AM_INDX
.810a	f0 01		beq $810d			beq 	_PTADo
.810c	60		rts				rts
.810d					_PTADo:
.810d	aa		tax				tax
.810e	60		rts				rts
.810f					AssembleGroup3:
.810f	68		pla				pla 								; get parameters, which is just the opcode.
.8110	fa		plx				plx
.8111	20 4c 81	jsr $814c			jsr 	AccessParameters 			; get and output opcode
.8114	20 64 81	jsr $8164			jsr 	AssemblerWriteByte
.8117	20 ec 82	jsr $82ec			jsr 	CalculateOperand 			; get a 16 bit operand
.811a	a5 58		lda $58				lda 	NSMantissa0 				; calculate the offset
.811c	38		sec				sec
.811d	ed 1e 04	sbc $041e			sbc 	AssemblerAddress
.8120	48		pha				pha 								; LSB in A
.8121	a5 60		lda $60				lda 	NSMantissa1
.8123	ed 1f 04	sbc $041f			sbc 	AssemblerAddress+1
.8126	aa		tax				tax 								; MSB in X
.8127	68		pla				pla
.8128	18		clc				clc 								; $80 to easy check $80-$7F, plus 1 for offset error
.8129	69 7f		adc #$7f			adc 	#$7F
.812b	90 01		bcc $812e			bcc 	_AG3NoCarry
.812d	e8		inx				inx
.812e					_AG3NoCarry:
.812e	38		sec				sec 								; fix back and write out anyways.
.812f	e9 80		sbc #$80			sbc 	#$80
.8131	20 64 81	jsr $8164			jsr 	AssemblerWriteByte
.8134	e0 00		cpx #$00			cpx 	#0 							; was it in range
.8136	f0 0a		beq $8142			beq 	_AG3Exit
.8138	ad 20 04	lda $0420			lda 	AssemblerControl 			; are we allowing bad values ?
.813b	29 01		and #$01			and 	#1
.813d	f0 03		beq $8142			beq 	_AG3Exit
.813f	4c a9 9f	jmp $9fa9			jmp 	RangeError 					; no, branch is out of range
.8142					_AG3Exit:
.8142	60		rts				rts
.8143					AssembleGroup4:
.8143	68		pla				pla 								; pop address
.8144	fa		plx				plx
.8145	20 4c 81	jsr $814c			jsr 	AccessParameters 			; access and get first
.8148	20 64 81	jsr $8164			jsr 	AssemblerWriteByte 			; output it.
.814b	60		rts				rts
.814c					AccessParameters:
.814c	8d 21 04	sta $0421			sta 	ParamStart
.814f	8e 22 04	stx $0422			stx 	ParamStart+1
.8152	a9 01		lda #$01			lda 	#1
.8154					GetParameter:
.8154	5a		phy				phy
.8155	a8		tay				tay
.8156	ad 21 04	lda $0421			lda 	ParamStart
.8159	85 36		sta $36				sta 	zTemp0
.815b	ad 22 04	lda $0422			lda 	ParamStart+1
.815e	85 37		sta $37				sta 	zTemp0+1
.8160	b1 36		lda ($36),y			lda 	(zTemp0),y
.8162	7a		ply				ply
.8163	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/aswrite.asm

.8164					AssemblerWriteByte:
.8164	48		pha			pha
.8165	ad 20 04	lda $0420		lda 	AssemblerControl 				; check printing bytes ?
.8168	29 02		and #$02		and 	#2
.816a	f0 1b		beq $8187		beq 	_AWBNoPrint
.816c	ad 1f 04	lda $041f		lda		AssemblerAddress+1 				; print address
.816f	20 a2 81	jsr $81a2		jsr 	PrintHex
.8172	ad 1e 04	lda $041e		lda		AssemblerAddress
.8175	20 a2 81	jsr $81a2		jsr 	PrintHex
.8178	a9 20		lda #$20		lda 	#' '
.817a	20 03 80	jsr $8003		jsr 	EXTPrintCharacter
.817d	68		pla			pla 									; print byte
.817e	48		pha			pha
.817f	20 a2 81	jsr $81a2		jsr 	PrintHex
.8182	a9 0d		lda #$0d		lda 	#13
.8184	20 03 80	jsr $8003		jsr 	EXTPrintCharacter
.8187					_AWBNoPrint:
.8187	ad 1e 04	lda $041e		lda		AssemblerAddress				; copy address to zTemp0
.818a	85 36		sta $36			sta 	zTemp0
.818c	ad 1f 04	lda $041f		lda		AssemblerAddress+1
.818f	f0 0e		beq $819f		beq 	_AWBRange
.8191	85 37		sta $37			sta 	zTemp0+1
.8193	68		pla			pla 									; write byte out
.8194	92 36		sta ($36)		sta 	(zTemp0)
.8196	ee 1e 04	inc $041e		inc 	AssemblerAddress 				; bump address
.8199	d0 03		bne $819e		bne 	_AWBNoCarry
.819b	ee 1f 04	inc $041f		inc 	AssemblerAddress+1
.819e					_AWBNoCarry:
.819e	60		rts			rts
.819f					_AWBRange:
.819f	4c a9 9f	jmp $9fa9		jmp 	RangeError
.81a2					PrintHex:
.81a2	48		pha				pha
.81a3	4a		lsr a				lsr 	a
.81a4	4a		lsr a				lsr 	a
.81a5	4a		lsr a				lsr 	a
.81a6	4a		lsr a				lsr 	a
.81a7	20 ab 81	jsr $81ab			jsr 	_PrintNibble
.81aa	68		pla				pla
.81ab					_PrintNibble:
.81ab	29 0f		and #$0f			and 	#15
.81ad	c9 0a		cmp #$0a			cmp 	#10
.81af	90 02		bcc $81b3			bcc 	_NoShift
.81b1	69 06		adc #$06			adc 	#6
.81b3					_NoShift:
.81b3	69 30		adc #$30			adc 	#48
.81b5	4c 03 80	jmp $8003			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/instruction.asm

.81b8					AssembleModeX:
.81b8	5a		phy				phy
.81b9	ad 23 04	lda $0423			lda 	IsGroup1
.81bc	f0 17		beq $81d5			beq 	_AMXGroup2
.81be	8a		txa				txa 							; is it in group # 1
.81bf	29 40		and #$40			and 	#AM_ISG1
.81c1	f0 4d		beq $8210			beq 	_AMXFail 				; no, give up.
.81c3	8a		txa				txa 							; get back.
.81c4	29 1f		and #$1f			and 	#$1F 					; this is now the offset.
.81c6	e0 e0		cpx #$e0			cpx 	#AM_IMMEDIATE 			; if not immediate, we can continue.
.81c8	d0 22		bne $81ec			bne 	_AMXHaveInfo
.81ca	ad 24 04	lda $0424			lda 	BaseOpcode 				; cannot store immediate.
.81cd	c9 81		cmp #$81			cmp 	#$81
.81cf	f0 3f		beq $8210			beq 	_AMXFail
.81d1	a9 08		lda #$08			lda 	#8 						; if immediate we use offset 8.
.81d3	80 17		bra $81ec			bra 	_AMXHaveInfo 			; odd design decision there.
.81d5					_AMXGroup2:
.81d5	8a		txa				txa 							; is it in group 2 ?
.81d6	29 20		and #$20			and 	#AM_ISG2
.81d8	f0 36		beq $8210			beq 	_AMXFail 				; no, give up.
.81da	8a		txa				txa 							; get the offset into Y
.81db	29 1f		and #$1f			and 	#$1F
.81dd	4a		lsr a				lsr 	a 						; make it 0-7.
.81de	4a		lsr a				lsr  	a
.81df	a8		tay				tay
.81e0	ad 25 04	lda $0425			lda 	ModeMask 				; shift the modemask left so you can check it against the requested offset
.81e3					_AMXCheckOkay:
.81e3	0a		asl a				asl 	a 						; shift modemask left enough times to check legitimate.
.81e4	88		dey				dey
.81e5	10 fc		bpl $81e3			bpl 	_AMXCheckOkay
.81e7	90 27		bcc $8210			bcc 	_AMXFail 				; not allowed.
.81e9	8a		txa				txa  							; get mask back
.81ea	29 1f		and #$1f			and 	#$1F
.81ec					_AMXHaveInfo:
.81ec	e0 00		cpx #$00			cpx 	#$00 					; does it *require* an 8 bit operand
.81ee	10 04		bpl $81f4			bpl 	_AMXAnySize 			; checking bit 7, the zero page opcode flag.
.81f0	a4 60		ldy $60				ldy 	NSMantissa1 			; fail if it is outside range, e.g. the MSB is set.
.81f2	d0 1c		bne $8210			bne 	_AMXFail
.81f4					_AMXAnySize:
.81f4	18		clc				clc 							; add offset to the base opcode
.81f5	6d 24 04	adc $0424			adc 	BaseOpcode
.81f8					_AMXOutputCode:
.81f8	20 64 81	jsr $8164			jsr 	AssemblerWriteByte 		; write the opcode out.
.81fb	e0 28		cpx #$28			cpx 	#AM_ACC 				; A mode (e.g. ASL)
.81fd	f0 0e		beq $820d			beq 	_AMXExit
.81ff	a5 58		lda $58				lda 	NSMantissa0 			; write LSB operand
.8201	20 64 81	jsr $8164			jsr 	AssemblerWriteByte
.8204	e0 00		cpx #$00			cpx 	#$00 					; zeropage ?
.8206	30 05		bmi $820d			bmi 	_AMXExit
.8208	a5 60		lda $60				lda 	NSMantissa1 			; write MSB operand
.820a	20 64 81	jsr $8164			jsr 	AssemblerWriteByte
.820d					_AMXExit:
.820d	7a		ply				ply
.820e	38		sec				sec
.820f	60		rts				rts
.8210					_AMXFail:
.8210	a0 00		ldy #$00			ldy 	#0
.8212					_AMXCheckOddities:
.8212	8a		txa				txa
.8213	d9 3a 82	cmp $823a,y			cmp 	ExtraOpcode+2,y 		; match address mode
.8216	d0 15		bne $822d			bne 	_AMXCONext
.8218	b9 38 82	lda $8238,y			lda 	ExtraOpcode+0,y 		; do the base opcodes match
.821b	cd 24 04	cmp $0424			cmp 	BaseOpcode
.821e	d0 0d		bne $822d			bne 	_AMXCONext
.8220	e0 00		cpx #$00			cpx 	#$00 					; requires zero page ?
.8222	10 04		bpl $8228			bpl 	_AMXCONotZero
.8224	a5 60		lda $60				lda 	NSMantissa1
.8226	d0 05		bne $822d			bne 	_AMXCONext
.8228					_AMXCONotZero:
.8228	b9 39 82	lda $8239,y			lda 	ExtraOpcode+1,y 		; get new opcode
.822b	80 cb		bra $81f8			bra 	_AMXOutputCode 			; and assemble it
.822d					_AMXCONext:
.822d	c8		iny				iny
.822e	c8		iny				iny
.822f	c8		iny				iny
.8230	b9 38 82	lda $8238,y			lda 	ExtraOpcode+0,y 		; end of table
.8233	d0 dd		bne $8212			bne 	_AMXCheckOddities
.8235					_AMXCOFail:
.8235	7a		ply				ply
.8236	18		clc				clc
.8237	60		rts				rts
.8238					ExtraOpcode:
>8238	40 6c 01					.byte $40,$6c,AM_INDABS 	; jump
>823b	40 7c 02					.byte $40,$7C,AM_INDABSX 	; jump
>823e	a2 be 78					.byte $a2,$BE,AM_ABSY 		; ldx
>8241	a2 b6 80					.byte $a2,$B6,AM_ZEROY 		; ldx
>8244	82 96 80					.byte $82,$96,AM_ZEROY 		; stx
>8247	e2 1a 28					.byte $e2,$1a,AM_ACC 		; inc
>824a	c2 3a 28					.byte $c2,$3a,AM_ACC 		; dec
>824d	20 89 e0					.byte $20,$89,AM_IMMEDIATE 	; bit
>8250	60 9c 6c					.byte $60,$9c,AM_ABS 		; stz
>8253	60 9e 7c					.byte $60,$9e,AM_ABSX 		; stz
>8256	00						.byte $00

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/label.asm

.8257					LabelHere:
.8257	c8		iny				iny 								; skip .
.8258	a2 00		ldx #$00			ldx 	#0 							; get a term
.825a	20 4d 98	jsr $984d			jsr 	EvaluateTerm
.825d	a5 50		lda $50				lda 	NSStatus 					; needs to be an integer reference.
.825f	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.8261	d0 22		bne $8285			bne 	_ALType 					; otherwise typing error
.8263	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy reference address to zTemp0
.8265	85 36		sta $36				sta 	zTemp0 						; (e.g. where we store the address)
.8267	b5 60		lda $60,x			lda 	NSMantissa1,x
.8269	85 37		sta $37				sta 	zTemp0+1
.826b	5a		phy				phy 								; copy address in (64k)
.826c	a0 01		ldy #$01			ldy 	#1
.826e	ad 1e 04	lda $041e			lda	 	AssemblerAddress
.8271	92 36		sta ($36)			sta 	(zTemp0)
.8273	ad 1f 04	lda $041f			lda	 	AssemblerAddress+1
.8276	91 36		sta ($36),y			sta 	(zTemp0),y
.8278	c8		iny				iny
.8279	a9 00		lda #$00			lda 	#0 							; zero the rest.
.827b	91 36		sta ($36),y			sta 	(zTemp0),y
.827d	c8		iny				iny
.827e	91 36		sta ($36),y			sta 	(zTemp0),y
.8280	c8		iny				iny
.8281	91 36		sta ($36),y			sta 	(zTemp0),y
.8283	7a		ply				ply
.8284	60		rts				rts
.8285					_ALType:
.8285	4c ae 9f	jmp $9fae			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/operands.asm

.8288					TypeAndCalculateOperand:
.8288	b1 30		lda ($30),y			lda 	(codePtr),y
.828a	a2 28		ldx #$28			ldx 	#AM_ACC 					; ACC if : or EOL
.828c	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.828e	f0 5b		beq $82eb			beq 	_TACOExit
.8290	c9 80		cmp #$80			cmp 	#KWC_EOL
.8292	f0 57		beq $82eb			beq 	_TACOExit
.8294	c8		iny				iny
.8295	a2 e0		ldx #$e0			ldx 	#AM_IMMEDIATE
.8297	c9 23		cmp #$23			cmp 	#KWD_HASH 					; if hash, then immediate - constant.
.8299	f0 51		beq $82ec			beq 	CalculateOperand
.829b	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; if ( then check for indirection
.829d	f0 1f		beq $82be			beq 	_TACOIndirect
.829f	88		dey				dey 								; undo get of first character
.82a0	20 ec 82	jsr $82ec			jsr 	CalculateOperand 			; get operand
.82a3	b1 30		lda ($30),y			lda 	(codePtr),y
.82a5	a2 e4		ldx #$e4			ldx 	#AM_ZEROPAGE 				; if not, try zero page (then absolute)
.82a7	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.82a9	d0 40		bne $82eb			bne 	_TACOExit
.82ab	c8		iny				iny
.82ac	20 f6 82	jsr $82f6			jsr 	TACOCheckXY 				; extract X,Y or 0 (neither) from the variable.
.82af	a2 f4		ldx #$f4			ldx 	#AM_ZEROX 					; check for X
.82b1	c9 58		cmp #$58			cmp 	#'X'
.82b3	f0 36		beq $82eb			beq 	_TACOExit
.82b5	a2 80		ldx #$80			ldx 	#AM_ZEROY 					; check for Y
.82b7	c9 59		cmp #$59			cmp 	#'Y'
.82b9	f0 30		beq $82eb			beq 	_TACOExit
.82bb					_TACOSyntax:
.82bb	4c a4 9f	jmp $9fa4			jmp 	SyntaxError
.82be					_TACOIndirect:
.82be	20 ec 82	jsr $82ec			jsr 	CalculateOperand 			; get the operand
.82c1	b1 30		lda ($30),y			lda 	(codePtr),y
.82c3	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if , then it must be ,X)
.82c5	f0 17		beq $82de			beq 	_TACOIndX
.82c7	20 e6 8e	jsr $8ee6			jsr 	CheckRightBracket  			; otherwise must be ) or ),Y
.82ca	b1 30		lda ($30),y			lda 	(codePtr),y
.82cc	a2 d1		ldx #$d1			ldx 	#AM_IND
.82ce	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not comma then exit with (xx)
.82d0	d0 19		bne $82eb			bne 	_TACOExit
.82d2	c8		iny				iny
.82d3	20 f6 82	jsr $82f6			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.82d6	c9 59		cmp #$59			cmp 	#'Y' 						; check Y
.82d8	d0 e1		bne $82bb			bne 	_TACOSyntax
.82da	a2 d0		ldx #$d0			ldx 	#AM_INDY
.82dc	80 0d		bra $82eb			bra 	_TACOExit
.82de					_TACOIndX:
.82de	c8		iny				iny
.82df	20 f6 82	jsr $82f6			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.82e2	c9 58		cmp #$58			cmp 	#'X' 						; check X
.82e4	d0 d5		bne $82bb			bne 	_TACOSyntax
.82e6	20 e6 8e	jsr $8ee6			jsr 	CheckRightBracket			; check )
.82e9	a2 c0		ldx #$c0			ldx 	#AM_INDX
.82eb					_TACOExit:
.82eb	60		rts				rts
.82ec					CalculateOperand:
.82ec	48		pha				pha
.82ed	da		phx				phx
.82ee	a2 00		ldx #$00			ldx 	#0 							; get 16 bit integer in Slot 0
.82f0	20 a6 9d	jsr $9da6			jsr 	Evaluate16BitInteger
.82f3	fa		plx				plx
.82f4	68		pla				pla
.82f5	60		rts				rts
.82f6					TACOCheckXY:
.82f6	b1 30		lda ($30),y			lda 	(codePtr),y
.82f8	29 c0		and #$c0			and 	#$C0 						; check it is an identifier reference.
.82fa	c9 40		cmp #$40			cmp 	#$40
.82fc	d0 21		bne $831f			bne 	_TCXYFail
.82fe	b1 30		lda ($30),y			lda 	(codePtr),y
.8300	18		clc				clc
.8301	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8303	85 37		sta $37				sta 	zTemp0+1
.8305	c8		iny				iny
.8306	b1 30		lda ($30),y			lda 	(codePtr),y
.8308	c8		iny				iny
.8309	85 36		sta $36				sta 	zTemp0
.830b	5a		phy				phy 								; save position
.830c	a0 02		ldy #$02			ldy 	#2 							; type is integer ?
.830e	b1 36		lda ($36),y			lda 	(zTemp0),y
.8310	d0 0c		bne $831e			bne 	_TCXYPopFail
.8312	a0 08		ldy #$08			ldy 	#8 							; get first character, should have bit 7 set as also last.
.8314	b1 36		lda ($36),y			lda 	(zTemp0),y
.8316	c9 d8		cmp #$d8			cmp 	#'X'+$80 					; should be X or Y
.8318	f0 08		beq $8322			beq 	_TCXYFound
.831a	c9 d9		cmp #$d9			cmp 	#'Y'+$80
.831c	f0 04		beq $8322			beq 	_TCXYFound
.831e					_TCXYPopFail:
.831e	7a		ply				ply
.831f					_TCXYFail:
.831f	a9 00		lda #$00			lda 	#0
.8321	60		rts				rts
.8322					_TCXYFound:
.8322	7a		ply				ply 								; restore position
.8323	29 7f		and #$7f			and 	#$7F 						; throw bit 7
.8325	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/backload.asm

.8326					BackloadProgram:
.8326	20 34 8a	jsr $8a34			jsr 	NewProgram 					; does the actual NEW.
.8329	a2 83		ldx #$83			ldx 	#_BLLoad >> 8
.832b	a9 75		lda #$75			lda 	#_BLLoad & $FF
.832d	20 58 8f	jsr $8f58			jsr 	PrintStringXA
.8330	a9 14		lda #$14			lda 	#SOURCE_ADDRESS >> 13 		; start page
.8332	8d 59 06	sta $0659			sta 	BackLoadPage
.8335	a9 00		lda #$00			lda 	#(($6000) & $FF)
.8337	8d 5a 06	sta $065a			sta 	0+BackLoadPointer
.833a	a9 60		lda #$60			lda 	#(($6000) >> 8)
.833c	8d 5b 06	sta $065b			sta 	1+BackLoadPointer
.833f	a9 ff		lda #$ff			lda 	#$FF
.8341	8d fa ff	sta $fffa			sta 	$FFFA
.8344					_BPLoop:
.8344	a2 ff		ldx #$ff			ldx 	#$FF
.8346	20 8a 83	jsr $838a			jsr 	BLReadByte 					; read a byte
.8349	c9 00		cmp #$00			cmp 	#0
.834b	f0 21		beq $836e			beq 	_BPExit 					; if 0 exit
.834d	30 1f		bmi $836e			bmi 	_BPExit 					; if -ve exit
.834f					_BPCopy:
.834f	e8		inx				inx  								; copy byte into the lineBuffer
.8350	9d 2a 05	sta $052a,x			sta 	lineBuffer,x
.8353	9e 2b 05	stz $052b,x			stz 	lineBuffer+1,x
.8356	20 8a 83	jsr $838a			jsr 	BLReadByte 					; read next byte
.8359	30 0a		bmi $8365			bmi 	_BPEndLine 					; -ve = EOL
.835b	c9 09		cmp #$09			cmp 	#9 							; handle TAB, make it space.
.835d	d0 02		bne $8361			bne 	_BPNotTab
.835f	a9 20		lda #$20			lda 	#' '
.8361					_BPNotTab:
.8361	c9 20		cmp #$20			cmp 	#' ' 						; < ' ' = EOL
.8363	b0 ea		bcs $834f			bcs 	_BPCopy 					; until a control character, should be 13 received.
.8365					_BPEndLine:
.8365	20 21 80	jsr $8021			jsr 	TKTokeniseLine 				; tokenise the line.
.8368	38		sec				sec 								; append not insert
.8369	20 fe a4	jsr $a4fe			jsr 	MemoryInsertLine 			; append to current program
.836c	80 d6		bra $8344			bra 	_BPLoop
.836e					_BPExit:
.836e	9c fa ff	stz $fffa			stz 	$FFFA
.8371	20 73 84	jsr $8473			jsr 	ClearCommand 				; clear variables etc.
.8374	60		rts				rts
.8375					_BLLoad:
>8375	4c 6f 61 64 69 6e 67 20				.text 	"Loading from Memory",13,0
>837d	66 72 6f 6d 20 4d 65 6d 6f 72 79 0d 00
.838a					BLReadByte:
.838a	da		phx				phx
.838b	a6 0b		ldx $0b				ldx 	8+3 						; save current mapping for $6000 in X
.838d	ad 59 06	lda $0659			lda 	BackLoadPage	 			; set current page
.8390	85 0b		sta $0b				sta 	8+3
.8392	ad 5a 06	lda $065a			lda 	BackLoadPointer 			; copy pointer to zTemp0
.8395	85 36		sta $36				sta 	zTemp0
.8397	ad 5b 06	lda $065b			lda 	BackLoadPointer+1
.839a	85 37		sta $37				sta 	zTemp0+1
.839c	b2 36		lda ($36)			lda 	(zTemp0) 					; read next byte
.839e	ee 5a 06	inc $065a			inc 	BackLoadPointer 			; bump pointer
.83a1	d0 0f		bne $83b2			bne 	_BLNoCarry
.83a3	ee 5b 06	inc $065b			inc 	BackLoadPointer+1
.83a6	10 0a		bpl $83b2			bpl 	_BLNoCarry 					; need a new page
.83a8	48		pha				pha
.83a9	a9 60		lda #$60			lda 	#$60 						; reset pointer
.83ab	8d 5b 06	sta $065b			sta 	BackLoadPointer+1
.83ae	ee 59 06	inc $0659			inc 	BackLoadPage 				; next page from source.
.83b1	68		pla				pla
.83b2					_BLNoCarry:
.83b2	86 0b		stx $0b				stx 	8+3 						; restore mapping, then X.
.83b4	fa		plx				plx
.83b5	c9 00		cmp #$00			cmp 	#0
.83b7	60		rts				rts
.0659					BackLoadPage:
>0659							.fill  	1
.065a					BackLoadPointer:
>065a							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/editor.asm

.83b8					EditProgramCode:
.83b8	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; try to find the line.
.83bb	ae 2c 04	ldx $042c			ldx 	TokenLineNumber+1
.83be	20 a2 a5	jsr $a5a2			jsr 	MemorySearch
.83c1	90 05		bcc $83c8			bcc 	_EPCNoDelete 				; reached the end : don't delete
.83c3	d0 03		bne $83c8			bne 	_EPCNoDelete 				; found slot but didn't match : no delete
.83c5	20 c7 a4	jsr $a4c7			jsr 	MemoryDeleteLine 			; delete the line
.83c8					_EPCNoDelete:
.83c8	ad 2d 04	lda $042d			lda 	TokenBuffer 				; buffer empty - we just want to delete a line.
.83cb	c9 80		cmp #$80			cmp 	#KWC_EOL
.83cd	f0 0d		beq $83dc			beq 	_EPCNoInsert
.83cf	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; find the line - it cannot exist as we've just deleted it.
.83d2	ae 2c 04	ldx $042c			ldx 	TokenLineNumber+1 			; so this can't fail, it returns some point in the code.
.83d5	20 a2 a5	jsr $a5a2			jsr 	MemorySearch
.83d8	18		clc				clc 								; insert at this point.
.83d9	20 fe a4	jsr $a4fe			jsr 	MemoryInsertLine 			; insert the line
.83dc					_EPCNoInsert:
.83dc	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/warmstart.asm

.83dd					WarmStart:
.83dd	a2 ff		ldx #$ff			ldx 	#$FF
.83df	9a		txs				txs
.83e0	a9 85		lda #$85			lda 	#CLICommandLine+$80 		; set console colour whatever the current colour is.
.83e2	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.83e5	20 12 80	jsr $8012			jsr 	EXTInputLine 				; get line to lineBuffer
.83e8	20 21 80	jsr $8021			jsr 	TKTokeniseLine 				; tokenise the line
.83eb	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; line number <> 0
.83ee	0d 2c 04	ora $042c			ora 	TokenLineNumber+1
.83f1	d0 17		bne $840a			bne 	_WSEditCode 				; if so,edit code.
.83f3	9c 2a 04	stz $042a			stz 	TokenOffset 				; zero the "offset", meaning it only runs one line.
.83f6	a9 2a		lda #$2a			lda 	#((TokenOffset) & $FF)
.83f8	85 30		sta $30				sta 	codePtr
.83fa	a9 04		lda #$04			lda 	#((TokenOffset) >> 8)
.83fc	85 31		sta $31				sta 	codePtr+1
.83fe	ad 2d 04	lda $042d			lda 	TokenBuffer 				; nothing to run
.8401	c9 80		cmp #$80			cmp 	#KWC_EOL
.8403	f0 d8		beq $83dd			beq 	WarmStart
.8405	20 87 8b	jsr $8b87			jsr 	RUNCodePointerLine 			; execute that line.
.8408	80 d3		bra $83dd			bra 	WarmStart
.840a					_WSEditCode:
.840a	20 b8 83	jsr $83b8			jsr 	EditProgramCode 			; edit the program code
.840d	20 73 84	jsr $8473			jsr 	ClearCommand 				; clear all variables etc.
.8410	80 cb		bra $83dd			bra 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assemble.asm

.8412					AssembleCommand:
.8412	a2 00		ldx #$00			ldx 	#0
.8414	20 a6 9d	jsr $9da6			jsr 	Evaluate16BitInteger 		; start address
.8417	a5 58		lda $58				lda 	NSMantissa0
.8419	8d 1e 04	sta $041e			sta 	AssemblerAddress
.841c	a5 60		lda $60				lda 	NSMantissa1
.841e	8d 1f 04	sta $041f			sta 	AssemblerAddress+1
.8421	20 ee 8e	jsr $8eee			jsr 	CheckComma
.8424	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger 		; options 0-3
.8427	a5 58		lda $58				lda 	NSMantissa0
.8429	8d 20 04	sta $0420			sta 	AssemblerControl
.842c	60		rts				rts
.842d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assert.asm

.842e					AssertCommand:
.842e	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.8430	20 93 9d	jsr $9d93			jsr 	EvaluateInteger 			; the assert test
.8433	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; exit if result is non zero.
.8436	d0 05		bne $843d			bne 	_ACExit
.8438	a9 0a		lda #$0a		lda	#10
.843a	4c ff 8e	jmp $8eff		jmp	ErrorHandler
.843d					_ACExit:
.843d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/call.asm

.843e					CallCommand:
.843e	a2 00		ldx #$00			ldx 	#0 							; get the routine address to level 0
.8440	20 a6 9d	jsr $9da6			jsr 	Evaluate16BitInteger
.8443					_CCClear
.8443	e8		inx				inx  								; clear 1,2 and 3 (for A X Y)
.8444	20 26 9e	jsr $9e26			jsr 	NSMSetZero 					; these are optional sequentially.
.8447	e0 04		cpx #$04			cpx 	#4
.8449	d0 f8		bne $8443			bne 	_CCClear
.844b	a2 00		ldx #$00			ldx 	#0 							; and keep trying while there are more values.
.844d					_CCCParam:
.844d	b1 30		lda ($30),y			lda 	(codePtr),y
.844f	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8451	d0 09		bne $845c			bne 	_CCCRun6502
.8453	c8		iny				iny 								; skip comma
.8454	e8		inx				inx	 								; next level
.8455	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger 		; get A/X/Y
.8458	e0 03		cpx #$03			cpx 	#3
.845a	90 f1		bcc $844d			bcc 	_CCCParam 					; done all 3 ?
.845c					_CCCRun6502:
.845c	5a		phy				phy 								; save position
.845d	a5 60		lda $60				lda 	NSMantissa1 				; put address in zTemp0
.845f	85 37		sta $37				sta 	zTemp0+1
.8461	a5 58		lda $58				lda 	NSMantissa0
.8463	85 36		sta $36				sta 	zTemp0
.8465	a5 59		lda $59				lda 	NSMantissa0+1 				; get registers into A X Y
.8467	a6 5a		ldx $5a				ldx 	NSMantissa0+2
.8469	a4 5b		ldy $5b				ldy 	NSMantissa0+3
.846b	20 70 84	jsr $8470			jsr 	_CCCZTemp0 					; call zTemp0
.846e	7a		ply				ply 								; restore position and exit
.846f	60		rts				rts
.8470					_CCCZTemp0:
.8470	6c 36 00	jmp ($0036)			jmp 	(zTemp0)

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/clear.asm

.8473					ClearCommand:
.8473	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.8475	85 36		sta $36				sta 	0+zTemp0
.8477	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.8479	85 37		sta $37				sta 	1+zTemp0
.847b					_ClearZeroLoop:
.847b	b2 36		lda ($36)			lda 	(zTemp0) 					; end of variables if offset is zero.
.847d	f0 24		beq $84a3			beq 	_ClearZeroEnd
.847f	a0 03		ldy #$03			ldy 	#3 							; erase the variables
.8481	a9 00		lda #$00			lda 	#0 							; set all the data to zero.
.8483					_ClearOneVariable:
.8483	91 36		sta ($36),y			sta 	(zTemp0),y
.8485	c8		iny				iny
.8486	c0 08		cpy #$08			cpy 	#8
.8488	d0 f9		bne $8483			bne 	_ClearOneVariable
.848a	a0 02		ldy #$02			ldy 	#2 							; has it been marked procedure
.848c	b1 36		lda ($36),y			lda 	(zTemp0),y
.848e	c9 18		cmp #$18			cmp 	#NSTProcedure
.8490	d0 04		bne $8496			bne 	_ClearNotProcedure
.8492	a9 04		lda #$04			lda 	#NSTInteger+NSBIsArray 		; if so set it back to an integer array
.8494	91 36		sta ($36),y			sta 	(zTemp0),y 					; will be fixed on the pre-run scan.
.8496					_ClearNotProcedure:
.8496	18		clc				clc 								; go to the next variable
.8497	b2 36		lda ($36)			lda 	(zTemp0) 					; offset to next, add to zTemp0
.8499	65 36		adc $36				adc 	zTemp0
.849b	85 36		sta $36				sta 	zTemp0
.849d	90 dc		bcc $847b			bcc 	_ClearZeroLoop
.849f	e6 37		inc $37				inc 	zTemp0+1
.84a1	80 d8		bra $847b			bra 	_ClearZeroLoop
.84a3					_ClearZeroEnd:
.84a3	18		clc				clc
.84a4	a5 36		lda $36				lda 	zTemp0
.84a6	69 01		adc #$01			adc 	#1
.84a8	8d 0c 04	sta $040c			sta 	lowMemPtr
.84ab	a5 37		lda $37				lda 	zTemp0+1
.84ad	69 00		adc #$00			adc 	#0
.84af	8d 0d 04	sta $040d			sta 	lowMemPtr+1
.84b2	20 2e a7	jsr $a72e			jsr 	StackReset
.84b5	20 94 a7	jsr $a794			jsr 	StringSystemInitialise
.84b8	20 ef 8d	jsr $8def			jsr 	ProcedureScan
.84bb	20 36 8b	jsr $8b36			jsr 	Command_Restore
.84be	9c 1e 04	stz $041e			stz 	AssemblerAddress
.84c1	9c 1f 04	stz $041f			stz 	AssemblerAddress+1
.84c4	9c 20 04	stz $0420			stz 	AssemblerControl
.84c7	20 39 9a	jsr $9a39			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.84ca	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/cls.asm

.84cb					ClearScreen:
.84cb	5a		phy				phy
.84cc	a9 0c		lda #$0c			lda 	#12 						; char code 12 clears the screen.
.84ce	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.84d1	7a		ply				ply
.84d2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/data.asm

.84d3					Command_Data:
.84d3	a9 3a		lda #$3a			lda 	#KWD_COLON 					; advance to colon/EOL, e.g. ignore anything till then.
.84d5	a2 80		ldx #$80			ldx 	#KWC_EOL
.84d7	20 41 8e	jsr $8e41			jsr 	ScanForward
.84da	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dim.asm

.84db					DimCommand:
.84db	b1 30		lda ($30),y			lda 	(codePtr),y
.84dd	29 c0		and #$c0			and 	#$C0
.84df	c9 40		cmp #$40			cmp 	#$40
.84e1	d0 7a		bne $855d			bne 	_DCSyntax 				; n o, error.
.84e3	b1 30		lda ($30),y			lda 	(codePtr),y
.84e5	18		clc				clc
.84e6	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.84e8	85 3f		sta $3f				sta 	zaTemp+1
.84ea	c8		iny				iny
.84eb	b1 30		lda ($30),y			lda 	(codePtr),y
.84ed	c8		iny				iny
.84ee	85 3e		sta $3e				sta 	zaTemp
.84f0	5a		phy				phy
.84f1	a0 02		ldy #$02			ldy 	#2 						; read type byte
.84f3	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84f5	29 18		and #$18			and 	#NSBTypeMask 			; check it's not a procedure
.84f7	c9 18		cmp #$18			cmp 	#NSTProcedure
.84f9	f0 62		beq $855d			beq 	_DCSyntax
.84fb	b1 3e		lda ($3e),y			lda 	(zaTemp),y 				; check it's an array
.84fd	29 04		and #$04			and 	#NSBIsArray
.84ff	f0 64		beq $8565			beq 	_DCType
.8501	a0 04		ldy #$04			ldy 	#4 						; check not already defined
.8503	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8505	d0 59		bne $8560			bne 	_DCRedefine
.8507	7a		ply				ply
.8508	20 68 85	jsr $8568			jsr 	_DCGetSize 				; get array size, check it.
.850b	5a		phy				phy
.850c	a0 05		ldy #$05			ldy 	#5 						; store in first array size slot
.850e	91 3e		sta ($3e),y			sta 	(zaTemp),y 				; second will be zero.
.8510	7a		ply				ply 							; is there a second (e.g. ,x)
.8511	b1 30		lda ($30),y			lda 	(codePtr),y
.8513	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8515	d0 0a		bne $8521			bne 	_DCOneDimension
.8517	c8		iny				iny 							; skip comma
.8518	20 68 85	jsr $8568			jsr 	_DCGetSize 				; get 2nd array size
.851b	5a		phy				phy
.851c	a0 06		ldy #$06			ldy 	#6 						; store in 2nd array size
.851e	91 3e		sta ($3e),y			sta 	(zaTemp),y
.8520	7a		ply				ply
.8521					_DCOneDimension:
.8521	5a		phy				phy 							; save position
.8522	a0 05		ldy #$05			ldy 	#5 						; dimensions + 1 in AX (as zero based)
.8524	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8526	aa		tax				tax
.8527	c8		iny				iny
.8528	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.852a	e8		inx				inx 							; bump them.
.852b	1a		inc a				inc 	a
.852c	20 d1 9d	jsr $9dd1			jsr 	Multiply8x8 			; work out the total number of elements -> zTemp0
.852f	a5 37		lda $37				lda 	zTemp0+1 				; don't allow more than 8192 elements whatever
.8531	29 e0		and #$e0			and 	#$E0
.8533	d0 23		bne $8558			bne 	_DCSize
.8535	a0 02		ldy #$02			ldy 	#2 						; get base type
.8537	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8539	20 76 85	jsr $8576			jsr 	ScaleByBaseType 		; scale by base type
.853c	a5 36		lda $36				lda 	zTemp0
.853e	a6 37		ldx $37				ldx 	zTemp0+1
.8540	20 fb 99	jsr $99fb			jsr 	AllocateXABytes 		; allocate memory
.8543	a0 03		ldy #$03			ldy 	#3 						; copy into the address.
.8545	91 3e		sta ($3e),y			sta 	(zaTemp),y
.8547	c8		iny				iny
.8548	8a		txa				txa
.8549	91 3e		sta ($3e),y			sta 	(zaTemp),y
.854b	7a		ply				ply 							; get position back
.854c	20 e6 8e	jsr $8ee6			jsr 	CheckRightBracket 		; check )
.854f	b1 30		lda ($30),y			lda 	(codePtr),y
.8551	c8		iny				iny 							; consume in case
.8552	c9 2c		cmp #$2c			cmp 	#KWD_COMMA		 		; if so do another DIM.
.8554	f0 85		beq $84db			beq 	DimCommand
.8556	88		dey				dey 							; undo consume
.8557	60		rts				rts
.8558					_DCSize:
.8558	a9 16		lda #$16		lda	#22
.855a	4c ff 8e	jmp $8eff		jmp	ErrorHandler
.855d					_DCSyntax:
.855d	4c a4 9f	jmp $9fa4			jmp 	SyntaxError
.8560					_DCRedefine:
.8560	a9 15		lda #$15		lda	#21
.8562	4c ff 8e	jmp $8eff		jmp	ErrorHandler
.8565					_DCType:
.8565	4c ae 9f	jmp $9fae			jmp 	TypeError
.8568					_DCGetSize:
.8568	a2 00		ldx #$00			ldx 	#0 						; get first index.
.856a	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger 	; get array dimension
.856d	c9 00		cmp #$00			cmp 	#0 						; must be 1-254
.856f	f0 e7		beq $8558			beq 	_DCSize
.8571	c9 fe		cmp #$fe			cmp 	#254
.8573	f0 e3		beq $8558			beq 	_DCSize
.8575	60		rts				rts
.8576					ScaleByBaseType:
.8576	29 10		and #$10			and 	#NSBIsString 			; is it string
.8578	d0 19		bne $8593			bne 	_SBBTString
.857a	a5 37		lda $37				lda 	zTemp0+1 				; push value on stack
.857c	48		pha				pha
.857d	a5 36		lda $36				lda 	zTemp0
.857f	48		pha				pha
.8580	06 36		asl $36				asl 	zTemp0 					; x 2
.8582	26 37		rol $37				rol 	zTemp0+1
.8584	06 36		asl $36				asl 	zTemp0 					; x 4
.8586	26 37		rol $37				rol 	zTemp0+1
.8588	68		pla				pla 							; add stacked value = x 5
.8589	65 36		adc $36				adc 	zTemp0
.858b	85 36		sta $36				sta 	zTemp0
.858d	68		pla				pla
.858e	65 37		adc $37				adc 	zTemp0+1
.8590	85 37		sta $37				sta 	zTemp0+1
.8592	60		rts				rts
.8593					_SBBTString:
.8593	06 36		asl $36				asl 	zTemp0
.8595	26 37		rol $37				rol 	zTemp0+1
.8597	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dokepoke.asm

.8598					PokeCommand:
.8598	18		clc				clc
.8599	80 01		bra $859c			bra 	DPCommand
.859b					DokeCommand:
.859b	38		sec				sec
.859c					DPCommand:
.859c	08		php				php									; save on stack, CS = Doke, CC = Poke
.859d	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.859f	20 a6 9d	jsr $9da6			jsr		Evaluate16BitInteger 		; address
.85a2	20 ee 8e	jsr $8eee			jsr 	CheckComma
.85a5	e8		inx				inx
.85a6	20 a6 9d	jsr $9da6			jsr		Evaluate16BitInteger 		; data
.85a9	a5 58		lda $58				lda 	NSMantissa0 				; copy address
.85ab	85 36		sta $36				sta 	zTemp0
.85ad	a5 60		lda $60				lda 	NSMantissa1
.85af	85 37		sta $37				sta 	zTemp0+1
.85b1	a5 59		lda $59				lda 	NSMantissa0+1 				; low byte
.85b3	92 36		sta ($36)			sta 	(zTemp0)
.85b5	28		plp				plp 								; done if POKE
.85b6	90 08		bcc $85c0			bcc 	_DPExit
.85b8	5a		phy				phy 								; write high byte out.
.85b9	a0 01		ldy #$01			ldy 	#1
.85bb	a5 61		lda $61				lda 	NSMantissa1+1
.85bd	91 36		sta ($36),y			sta 	(zTemp0),y
.85bf	7a		ply				ply
.85c0					_DPExit:
.85c0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/end.asm

.85c1					EndCommand:
.85c1	4c dd 83	jmp $83dd			jmp 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/for.asm

.85c4					ForCommand:
.85c4	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; allocate 18 bytes on the return stack (see above).
.85c6	20 c8 a6	jsr $a6c8			jsr 	StackOpen
.85c9	a2 00		ldx #$00			ldx 	#0
.85cb	20 4d 98	jsr $984d			jsr 	EvaluateTerm
.85ce	b5 50		lda $50,x			lda 	NSStatus,x
.85d0	c9 20		cmp #$20			cmp 	#NSBIsReference+NSTInteger 	; do we have an integer 4 byte reference.
.85d2	d0 47		bne $861b			bne		_FCError
.85d4	a9 3d		lda #$3d			lda 	#KWD_EQUAL 					; =
.85d6	20 f6 8e	jsr $8ef6			jsr 	CheckNextA
.85d9	e8		inx				inx
.85da	20 93 9d	jsr $9d93			jsr 	EvaluateInteger 			; <from> in +1
.85dd	b1 30		lda ($30),y			lda 	(codePtr),y
.85df	c8		iny				iny 								; consume it
.85e0	48		pha				pha 								; save on stack for later
.85e1	c9 b7		cmp #$b7			cmp 	#KWD_DOWNTO
.85e3	f0 04		beq $85e9			beq 	_FCNoSyntax
.85e5	c9 d2		cmp #$d2			cmp 	#KWD_TO
.85e7	d0 35		bne $861e			bne 	_FCSyntaxError
.85e9					_FCNoSyntax:
.85e9	e8		inx				inx
.85ea	20 93 9d	jsr $9d93			jsr 	EvaluateInteger
.85ed	20 0d a7	jsr $a70d			jsr 	STKSaveCodePosition 		; save loop back position
.85f0	68		pla				pla 								; restore DOWNTO or TO
.85f1	5a		phy				phy 								; save Y on the stack
.85f2	49 b7		eor #$b7			eor 	#KWD_DOWNTO 				; 0 if DOWNTO, #0 if TO
.85f4	f0 02		beq $85f8			beq 	_FCNotDownTo
.85f6	a9 02		lda #$02			lda 	#2
.85f8					_FCNotDownTo:
.85f8	3a		dec a				dec 	a 							; 255 if DOWNTO, 1 if TO
.85f9	a0 10		ldy #$10			ldy 	#16
.85fb	91 34		sta ($34),y			sta 	(basicStack),y 				; copy that out to the Basic Stack.
.85fd	a0 06		ldy #$06			ldy 	#6 							; this is the address of the loop variable.
.85ff	a5 58		lda $58				lda 	NSMantissa0
.8601	91 34		sta ($34),y			sta 	(basicStack),y
.8603	a5 60		lda $60				lda 	NSMantissa1
.8605	c8		iny				iny
.8606	91 34		sta ($34),y			sta 	(basicStack),y
.8608	a0 08		ldy #$08			ldy 	#8 							; set initial index value
.860a	a2 01		ldx #$01			ldx 	#1
.860c	20 21 86	jsr $8621			jsr 	FCIntegerToStack
.860f	a0 0c		ldy #$0c			ldy 	#12 						; set the terminal value
.8611	a2 02		ldx #$02			ldx 	#2
.8613	20 21 86	jsr $8621			jsr 	FCIntegerToStack
.8616	20 3c 86	jsr $863c			jsr 	CopyIndexToReference
.8619	7a		ply				ply 								; restore position
.861a	60		rts				rts
.861b					_FCError:
.861b	4c ae 9f	jmp $9fae			jmp 	TypeError
.861e					_FCSyntaxError:
.861e	4c a4 9f	jmp $9fa4			jmp 	SyntaxError
.8621					FCIntegerToStack:
.8621	34 50		bit $50,x			bit 	NSStatus,x 					; is the value negative
.8623	10 03		bpl $8628			bpl	 	_FCNotNegative
.8625	20 ef 9d	jsr $9def			jsr 	NSMNegateMantissa 			; if so 2's complement the mantissa
.8628					_FCNotNegative:
.8628	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy out to the basic stack
.862a	91 34		sta ($34),y			sta 	(basicStack),y
.862c	c8		iny				iny
.862d	b5 60		lda $60,x			lda 	NSMantissa1,x
.862f	91 34		sta ($34),y			sta 	(basicStack),y
.8631	c8		iny				iny
.8632	b5 68		lda $68,x			lda 	NSMantissa2,x
.8634	91 34		sta ($34),y			sta 	(basicStack),y
.8636	c8		iny				iny
.8637	b5 70		lda $70,x			lda 	NSMantissa3,x
.8639	91 34		sta ($34),y			sta 	(basicStack),y
.863b	60		rts				rts
.863c					CopyIndexToReference:
.863c	5a		phy				phy
.863d	a0 06		ldy #$06			ldy 	#6 							; copy address-8 to write to zTemp0
.863f	38		sec				sec 								; (because we copy from offset 8)
.8640	b1 34		lda ($34),y			lda 	(basicStack),y
.8642	e9 08		sbc #$08			sbc 	#8
.8644	85 36		sta $36				sta 	zTemp0
.8646	c8		iny				iny
.8647	b1 34		lda ($34),y			lda 	(basicStack),y
.8649	e9 00		sbc #$00			sbc 	#0
.864b	85 37		sta $37				sta 	zTemp0+1
.864d	a2 04		ldx #$04			ldx 	#4 							; this is the copy counter/
.864f	a0 0b		ldy #$0b			ldy 	#8+3 		 				; the MSB of the mantissa
.8651	b1 34		lda ($34),y			lda 	(basicStack),y
.8653	0a		asl a				asl 	a 							; into carry
.8654	a0 08		ldy #$08			ldy 	#8 							; where to copy from.
.8656	90 14		bcc $866c			bcc 	_CITRNormal
.8658	38		sec				sec
.8659					_CITRNegative:
.8659	a9 00		lda #$00			lda 	#0
.865b	f1 34		sbc ($34),y			sbc 	(basicStack),y
.865d	91 36		sta ($36),y			sta 	(zTemp0),y
.865f	c8		iny				iny
.8660	ca		dex				dex
.8661	d0 f6		bne $8659			bne 	_CITRNegative
.8663	88		dey				dey 								; look at MSB of mantissa
.8664	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set the MSB as negative packed.
.8666	09 80		ora #$80			ora 	#$80
.8668	91 36		sta ($36),y			sta 	(zTemp0),y
.866a	7a		ply				ply
.866b	60		rts				rts
.866c					_CITRNormal:
.866c	b1 34		lda ($34),y			lda 	(basicStack),y 				; copy without negation.
.866e	91 36		sta ($36),y			sta 	(zTemp0),y
.8670	c8		iny				iny
.8671	ca		dex				dex
.8672	d0 f8		bne $866c			bne 	_CITRNormal
.8674	7a		ply				ply 								; and exit.
.8675	60		rts				rts
.8676					NextCommand:
.8676	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; check FOR is TOS
.8678	a2 11		ldx #$11			ldx 	#ERRID_FOR 					; this error
.867a	20 f5 a6	jsr $a6f5			jsr 	StackCheckFrame
.867d	5a		phy				phy
.867e	a0 10		ldy #$10			ldy 	#16 						; get the step count
.8680	b1 34		lda ($34),y			lda 	(basicStack),y
.8682	85 36		sta $36				sta 	zTemp0 						; this is the sign extend
.8684	30 02		bmi $8688			bmi 	_NCStepNeg
.8686	64 36		stz $36				stz 	zTemp0 						; which is 0 or 255
.8688					_NCStepNeg:
.8688	a0 08		ldy #$08			ldy 	#8 							; offset to bump
.868a	a2 04		ldx #$04			ldx 	#4 							; count to bump
.868c	18		clc				clc
.868d					_NCBump:
.868d	71 34		adc ($34),y			adc 	(basicStack),y 				; add it
.868f	91 34		sta ($34),y			sta 	(basicStack),y
.8691	a5 36		lda $36				lda 	zTemp0 						; get sign extend for next time.
.8693	c8		iny				iny 								; next byte
.8694	ca		dex				dex 								; do four times
.8695	d0 f6		bne $868d			bne 	_NCBump
.8697	20 3c 86	jsr $863c			jsr		CopyIndexToReference		; copy it to the reference variable.
.869a	a0 10		ldy #$10			ldy 	#16 						; get step count again
.869c	b1 34		lda ($34),y			lda 	(basicStack),y
.869e	0a		asl a				asl 	a 							; sign bit to carry
.869f	a9 0c		lda #$0c			lda 	#12 						; offset of LHS = terminal offset
.86a1	85 38		sta $38				sta 	zTemp1
.86a3	90 02		bcc $86a7			bcc 	_NCCompRev 					; use if step is +ve
.86a5	a9 08		lda #$08			lda 	#8 							; now the LHS = index value
.86a7					_NCCompRev:
.86a7	85 38		sta $38				sta 	zTemp1 						; so zTemp0 is the index for LHS
.86a9	49 04		eor #$04			eor 	#(8^12) 					; and zTemp0+1 is the index for RHS
.86ab	85 39		sta $39				sta 	zTemp1+1
.86ad	a2 04		ldx #$04			ldx 	#4 							; bytes to compare
.86af	38		sec				sec
.86b0					_NCCompare:
.86b0	a4 38		ldy $38				ldy 	zTemp1 						; do compare using the two indices
.86b2	b1 34		lda ($34),y			lda 	(basicStack),y
.86b4	a4 39		ldy $39				ldy 	zTemp1+1
.86b6	f1 34		sbc ($34),y			sbc 	(basicStack),y
.86b8	e6 38		inc $38				inc 	zTemp1 						; bump the indices (inc,dex do not change C or V)
.86ba	e6 39		inc $39				inc 	zTemp1+1
.86bc	ca		dex				dex 								; do it 4 times.
.86bd	d0 f1		bne $86b0			bne 	_NCCompare
.86bf	50 02		bvc $86c3			bvc 	_NCNoOverflow 				; convert to signed comparison
.86c1	49 80		eor #$80			eor 	#$80
.86c3					_NCNoOverflow:
.86c3	7a		ply				ply 								; restore Y position
.86c4	0a		asl a				asl 	a 							; is bit 7 set.
.86c5	90 04		bcc $86cb			bcc 	_NCLoopback 				; if no , >= so loop back
.86c7	20 e7 a6	jsr $a6e7			jsr 	StackClose 					; exit the loop
.86ca	60		rts				rts
.86cb					_NCLoopBack:
.86cb	20 1e a7	jsr $a71e			jsr 	STKLoadCodePosition 		; loop back
.86ce	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/gosub.asm

.86cf					Command_GOSUB:
.86cf	a2 00		ldx #$00			ldx 	#0
.86d1	20 a6 9d	jsr $9da6			jsr 	Evaluate16BitInteger 		; line number in Stack.0
.86d4	a9 e3		lda #$e3			lda 	#STK_GOSUB+3
.86d6	20 c8 a6	jsr $a6c8			jsr 	StackOpen 					; create frame
.86d9	20 0d a7	jsr $a70d			jsr 	STKSaveCodePosition 		; save current position
.86dc	4c f2 86	jmp $86f2			jmp 	GotoStackX
.86df					Command_RETURN:
.86df	a9 e0		lda #$e0			lda 	#STK_GOSUB 					; check TOS is this
.86e1	a2 0e		ldx #$0e			ldx 	#ERRID_GOSUB 				; this error
.86e3	20 f5 a6	jsr $a6f5			jsr 	StackCheckFrame
.86e6	20 1e a7	jsr $a71e			jsr 	STKLoadCodePosition 		; restore code position
.86e9	20 e7 a6	jsr $a6e7			jsr 	StackClose
.86ec	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/goto.asm

.86ed					GotoCommand:
.86ed	a2 00		ldx #$00			ldx 	#0 							; GOTO where
.86ef	20 a6 9d	jsr $9da6			jsr 	Evaluate16BitInteger
.86f2					GotoStackX:
.86f2	b5 60		lda $60,x			lda  	NSMantissa1,x 				; put line # in XA. I'll keep this even though
.86f4	48		pha				pha 								; it is slightly inefficient, just in cases.
.86f5	b5 58		lda $58,x			lda 	NSMantissa0,x
.86f7	fa		plx				plx
.86f8	20 a2 a5	jsr $a5a2			jsr 	MemorySearch 				; transfer to line number AX.
.86fb	90 05		bcc $8702			bcc 	_GotoError 					; not found, off end.
.86fd	d0 03		bne $8702			bne 	_GotoError 					; not found exactly
.86ff	4c 80 8b	jmp $8b80			jmp 	RunNewLine 					; and go straight to new line code.
.8702					_GotoError:
.8702	a9 0d		lda #$0d		lda	#13
.8704	4c ff 8e	jmp $8eff		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/if.asm

.8707					IfCommand:
.8707	a2 00		ldx #$00			ldx 	#0 							; Get the if test.
.8709	20 74 9d	jsr $9d74			jsr 	EvaluateNumber
.870c	b1 30		lda ($30),y			lda 	(codePtr),y
.870e	c9 aa		cmp #$aa			cmp 	#KWD_THEN  					; could be THEN <stuff>
.8710	d0 0a		bne $871c			bne 	_IFStructured 				; we still support it.
.8712	c8		iny				iny 								; consume THEN
.8713	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; is it zero
.8716	f0 01		beq $8719			beq 	_IfFail 					; if fail, go to next line
.8718	60		rts				rts 								; if THEN just continue
.8719					_IfFail:
.8719	4c 68 8b	jmp $8b68			jmp 	EOLCommand
.871c					_IfStructured:
.871c	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; is it zero
.871f	d0 07		bne $8728			bne 	_IfExit 					; if not, then continue normally.
.8721	a9 b8		lda #$b8			lda 	#KWD_ELSE 					; look for else/endif
.8723	a2 a7		ldx #$a7			ldx 	#KWD_ENDIF
.8725	20 41 8e	jsr $8e41			jsr 	ScanForward 				; and run from there
.8728					_IfExit:
.8728	60		rts				rts
.8729					ElseCode:
.8729	a9 a7		lda #$a7			lda 	#KWD_ENDIF 					; else is only run after the if clause succeeds
.872b	aa		tax				tax 								; so just go to the structure exit
.872c	20 41 8e	jsr $8e41			jsr 	ScanForward
.872f	60		rts				rts
.8730					EndIf:
.8730	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/inputprint.asm

.8731					Command_Input:
.8731	a9 ff		lda #$ff			lda 	#$FF 						; set input flag
.8733	8d 28 04	sta $0428			sta 	IsInputFlag
.8736	80 03		bra $873b			bra 	Command_IP_Main
.8738					Command_Print:
.8738	9c 28 04	stz $0428			stz 	IsInputFlag 				; clear input flag
.873b					Command_IP_Main:
.873b	18		clc				clc 								; carry being clear means last print wasn't comma/semicolon
.873c					_CPLoop:
.873c	08		php				php 								; save last action flag
.873d	b1 30		lda ($30),y			lda 	(codePtr),y
.873f	c9 80		cmp #$80			cmp  	#KWC_EOL 					; end of line or colon, exit now.
.8741	f0 54		beq $8797			beq 	_CPExit
.8743	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.8745	f0 50		beq $8797			beq 	_CPExit
.8747	68		pla				pla 								; throw last action flag
.8748	b1 30		lda ($30),y			lda 	(codePtr),y
.874a	c8		iny				iny
.874b	c9 3b		cmp #$3b			cmp 	#KWD_SEMICOLON				; is it a semicolon
.874d	f0 45		beq $8794			beq 	_CPContinueWithSameLine
.874f	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; comma
.8751	f0 3c		beq $878f			beq 	_CPTab
.8753	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; apostrophe (new line)
.8755	f0 34		beq $878b			beq 	_CPNewLine
.8757	88		dey				dey 								; undo the get.
.8758	20 01 94	jsr $9401			jsr 	EvaluateExpressionAt0 		; evaluate expression at 0.
.875b	b5 50		lda $50,x			lda 	NSStatus,x 					; read the status
.875d	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.875f	f0 0d		beq $876e			beq 	_CPIsValue 					; no, display it.
.8761	ad 28 04	lda $0428			lda 	IsInputFlag 				; if print, dereference and print.
.8764	f0 05		beq $876b			beq 	_CPIsPrint 					; otherwise display.
.8766	20 a0 87	jsr $87a0			jsr 	CIInputValue 				; input a value to the reference
.8769	80 20		bra $878b			bra 	_CPNewLine
.876b					_CPIsPrint:
.876b	20 c6 96	jsr $96c6			jsr 	Dereference 				; dereference if required.
.876e					_CPIsValue:
.876e	b5 50		lda $50,x			lda 	NSStatus,x 					; is it a number
.8770	29 10		and #$10			and 	#NSBIsString
.8772	f0 09		beq $877d			beq 	_CPNumber
.8774	a6 60		ldx $60				ldx 	NSMantissa1 				; string, print the text.
.8776	a5 58		lda $58				lda 	NSMantissa0
.8778	20 03 88	jsr $8803			jsr 	CPPrintStringXA
.877b	80 be		bra $873b			bra 	Command_IP_Main 			; loop round clearing carry so NL if end
.877d					_CPNumber:
.877d	a9 05		lda #$05			lda 	#5 							; maximum decimals
.877f	20 5b 9c	jsr $9c5b			jsr 	ConvertNumberToString 		; convert to string (in unary str$() function)
.8782	a2 06		ldx #$06			ldx 	#DecimalBuffer >> 8
.8784	a9 49		lda #$49			lda 	#DecimalBuffer & $FF
.8786	20 03 88	jsr $8803			jsr 	CPPrintStringXA 			; print it.
.8789	80 b0		bra $873b			bra 	Command_IP_Main				; loop round clearing carry so NL if end
.878b					_CPNewLine:
.878b	a9 0d		lda #$0d			lda 	#13
.878d	80 02		bra $8791			bra 	_CPPrintChar
.878f					_CPTab:
.878f	a9 09		lda #$09			lda 	#9 							; print TAB
.8791					_CPPrintChar:
.8791	20 16 88	jsr $8816			jsr 	CPPrintVector
.8794					_CPContinueWithSameLine:
.8794	38		sec				sec 								; loop round with carry set, which
.8795	80 a5		bra $873c			bra 	_CPLoop 					; will inhibit final CR
.8797					_CPExit:
.8797	28		plp				plp 								; get last action flag
.8798	b0 05		bcs $879f			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.879a	a9 0d		lda #$0d			lda 	#13 						; print new line
.879c	20 16 88	jsr $8816			jsr 	CPPrintVector
.879f					_CPExit2:
.879f	60		rts				rts
.87a0					CIInputValue:
.87a0	a2 00		ldx #$00			ldx 	#0 							; input a line.
.87a2					_CIInputLine:
.87a2	20 19 88	jsr $8819			jsr 	CPInputVector 				; get key
.87a5	c9 0d		cmp #$0d			cmp 	#13 						; 13 = End
.87a7	f0 1f		beq $87c8			beq 	_CIHaveValue
.87a9	c9 08		cmp #$08			cmp 	#8 							; 8 = BS
.87ab	f0 11		beq $87be			beq 	_CIBackspace
.87ad	c9 20		cmp #$20			cmp 	#32 						; ignore other control characters
.87af	90 f1		bcc $87a2			bcc 	_CIInputLine
.87b1	e0 50		cpx #$50			cpx 	#80 						; max length
.87b3	b0 ed		bcs $87a2			bcs 	_CIInputLine
.87b5	9d 2a 05	sta $052a,x			sta 	lineBuffer,x
.87b8	e8		inx				inx
.87b9	20 16 88	jsr $8816			jsr 	CPPrintVector 				; echo it.
.87bc	80 e4		bra $87a2			bra 	_CIInputLine
.87be					_CIBackSpace:
.87be	e0 00		cpx #$00			cpx 	#0 							; nothing to delete
.87c0	f0 e0		beq $87a2			beq 	_CIInputLine
.87c2	20 16 88	jsr $8816			jsr 	CPPrintVector 				; echo it.
.87c5	ca		dex				dex
.87c6	80 da		bra $87a2			bra 	_CIInputLine
.87c8					_CIHaveValue:
.87c8	9e 2a 05	stz $052a,x			stz 	LineBuffer,x 				; ASCIIZ string now in line buffer.
.87cb	a5 50		lda $50				lda 	NSStatus 					; was it a string assignment
.87cd	29 10		and #$10			and 	#NSBIsString
.87cf	f0 17		beq $87e8			beq 	_CIAssignNumber 			; assign a number
.87d1	a2 01		ldx #$01			ldx 	#1
.87d3	a9 2a		lda #$2a			lda 	#lineBuffer & $FF 			; set up to point to new string
.87d5	95 58		sta $58,x			sta 	NSMantissa0,x
.87d7	a9 05		lda #$05			lda 	#lineBuffer >> 8
.87d9	95 60		sta $60,x			sta 	NSMantissa1,x
.87db	74 68		stz $68,x			stz 	NSMantissa2,x
.87dd	74 70		stz $70,x			stz 	NSMantissa3,x
.87df	a9 10		lda #$10			lda 	#NSBIsString 				; so it becomes a string value
.87e1	95 50		sta $50,x			sta  	NSStatus,x
.87e3	ca		dex				dex 								; X = 0
.87e4	20 55 88	jsr $8855			jsr 	AssignVariable
.87e7	60		rts				rts
.87e8					_CIAssignNumber:
.87e8	a9 2a		lda #$2a			lda 	#lineBuffer & $FF 			; set up to point to new string
.87ea	85 36		sta $36				sta 	zTemp0
.87ec	a9 05		lda #$05			lda 	#lineBuffer >> 8
.87ee	85 37		sta $37				sta 	zTemp0+1
.87f0	a2 01		ldx #$01			ldx 	#1 							; put in slot 1
.87f2	20 dd 9b	jsr $9bdd			jsr 	ValEvaluateZTemp0 			; use the VAL() code
.87f5	90 07		bcc $87fe			bcc 	_CIIsOkay
.87f7	a9 3f		lda #$3f			lda 	#"?" 						; error ?
.87f9	20 16 88	jsr $8816			jsr 	CPPrintVector
.87fc	80 a2		bra $87a0			bra 	CIInputValue
.87fe					_CIIsOkay:
.87fe	ca		dex				dex 								; X = 0
.87ff	20 55 88	jsr $8855			jsr 	AssignVariable
.8802	60		rts				rts
.8803					CPPrintStringXA:
.8803	5a		phy				phy
.8804	86 37		stx $37				stx 	zTemp0+1
.8806	85 36		sta $36				sta 	zTemp0
.8808	a0 00		ldy #$00			ldy 	#0
.880a					_PSXALoop:
.880a	b1 36		lda ($36),y			lda 	(zTemp0),y
.880c	f0 06		beq $8814			beq 	_PSXAExit
.880e	20 16 88	jsr $8816			jsr 	CPPrintVector
.8811	c8		iny				iny
.8812	80 f6		bra $880a			bra 	_PSXALoop
.8814					_PSXAExit:
.8814	7a		ply				ply
.8815	60		rts				rts
.8816					CPPrintVector:
.8816	4c 03 80	jmp $8003			jmp 	EXTPrintCharacter
.8819					CPInputVector:
.8819	4c 09 80	jmp $8009			jmp 	EXTInputSingleCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/let.asm

.881c					LetCommand:
.881c	a2 00		ldx #$00			ldx 	#0
.881e	b1 30		lda ($30),y			lda 	(codePtr),y
.8820	c9 10		cmp #$10			cmp 	#KWD_AT
.8822	d0 14		bne $8838			bne 	_LCStandard
.8824	c8		iny				iny 								; skip equal
.8825	20 4d 98	jsr $984d			jsr 	EvaluateTerm 				; get a number (the address of the reference)
.8828	20 c6 96	jsr $96c6			jsr 	Dereference 				; dereference it to a value
.882b	b5 50		lda $50,x			lda 	NSStatus,x 					; check integer
.882d	49 20		eor #$20			eor 	#NSBIsReference	 			; toggle reference
.882f	95 50		sta $50,x			sta 	NSStatus,x
.8831	29 20		and #$20			and 	#NSBIsReference 			; if it is now a reference, continue
.8833	d0 0f		bne $8844			bne 	_LCMain
.8835	4c ae 9f	jmp $9fae			jmp 	TypeError 					; was a reference before.
.8838					_LCStandard:
.8838	ad eb 93	lda $93eb			lda 	PrecedenceLevel+"*"			; precedence > this
.883b	20 05 94	jsr $9405			jsr 	EvaluateExpressionAtPrecedence
.883e	b5 50		lda $50,x			lda 	NSStatus,x 					; is it a reference to an array marked as procedure ?
.8840	c9 38		cmp #$38			cmp		#NSTProcedure+NSBIsReference
.8842	f0 0e		beq $8852			beq 	_LetGoProc 					; it's a procedure call.
.8844					_LCMain:
.8844	a9 3d		lda #$3d			lda 	#"=" 						; check =
.8846	20 f6 8e	jsr $8ef6			jsr 	CheckNextA
.8849	e8		inx				inx 								; RHS
.884a	20 6b 9d	jsr $9d6b			jsr 	EvaluateValue
.884d	ca		dex				dex
.884e	20 55 88	jsr $8855			jsr 	AssignVariable
.8851	60		rts				rts
.8852					_LetGoProc:
.8852	4c 3e 8a	jmp $8a3e			jmp 	CallProcedure
.8855					AssignVariable:
.8855	b5 50		lda $50,x			lda 	NSStatus,x 					; check the string/number type bits match
.8857	48		pha				pha 								; save a copy
.8858	55 51		eor $51,x			eor 	NSStatus+1,x
.885a	29 10		and #$10			and 	#NSBIsString
.885c	d0 0b		bne $8869			bne 	_ASError
.885e	68		pla				pla 								; get back
.885f	29 10		and #$10			and 	#NSBIsString 				; check type
.8861	d0 03		bne $8866			bne 	_ASString
.8863	4c 04 96	jmp $9604			jmp 	AssignNumber
.8866					_ASString:
.8866	4c 62 96	jmp $9662			jmp 	AssignString
.8869					_ASError:
.8869	4c ae 9f	jmp $9fae			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/list.asm

.886c					Command_List:
.886c	9c 26 04	stz $0426			stz 	listIndent 					; reset indent.
.886f	b1 30		lda ($30),y			lda 	(codePtr),y
.8871	29 c0		and #$c0			and 	#$C0 				 		; if so, we are list procedure() which is a seperate block
.8873	c9 40		cmp #$40			cmp 	#$40  						; of code.
.8875	f0 6e		beq $88e5			beq 	_CLListProcedure
.8877	64 5c		stz $5c				stz		NSMantissa0+4				; set the lower (slot 4) to 0 and upper (slot 7) to $FFFF
.8879	64 64		stz $64				stz 	NSMantissa1+4 				; these are the default top and bottom.
.887b	a9 ff		lda #$ff			lda 	#$FF
.887d	85 5f		sta $5f				sta 	NSMantissa0+7
.887f	85 67		sta $67				sta 	NSMantissa1+7
.8881	b1 30		lda ($30),y			lda 	(codePtr),y
.8883	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8885	f0 1a		beq $88a1			beq 	_CLSecond
.8887	20 62 89	jsr $8962			jsr 	CLIsDigit 					; if not digit, list all
.888a	b0 20		bcs $88ac			bcs 	_CLStart
.888c	a2 04		ldx #$04			ldx 	#4 							; get 1st range into slot 4
.888e	20 a6 9d	jsr $9da6			jsr 	Evaluate16BitInteger
.8891	b1 30		lda ($30),y			lda 	(codePtr),y
.8893	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8895	f0 0a		beq $88a1			beq 	_CLSecond 					; if so go get it
.8897	a5 5c		lda $5c				lda 	NSMantissa0+4 				; copy 4->7
.8899	85 5f		sta $5f				sta 	NSMantissa0+7
.889b	a5 64		lda $64				lda 	NSMantissa1+4
.889d	85 67		sta $67				sta 	NSMantissa1+7
.889f	80 0b		bra $88ac			bra 	_CLStart
.88a1					_CLSecond:
.88a1	c8		iny				iny 								; consume comma
.88a2	20 62 89	jsr $8962			jsr 	CLIsDigit 					; digit found
.88a5	b0 05		bcs $88ac			bcs 	_CLStart 					; if not, continue listing
.88a7	a2 07		ldx #$07			ldx 	#7 							; load 2nd range into slot 7
.88a9	20 a6 9d	jsr $9da6			jsr 	Evaluate16BitInteger
.88ac					_CLStart
.88ac	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.88ae	85 30		sta $30				sta 	codePtr
.88b0	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.88b2	85 31		sta $31				sta 	codePtr+1
.88b4					_CLLoop:
.88b4	20 0c 80	jsr $800c			jsr 	EXTBreakCheck 				; break check here, as we want the option of breaking out of long lists.
.88b7	f0 27		beq $88e0			beq 	_CLBreak
.88b9	b2 30		lda ($30)			lda 	(codePtr)
.88bb	f0 20		beq $88dd			beq 	_CLExit
.88bd	a2 04		ldx #$04			ldx 	#4 							; check range every time, line numbers aren't in order.
.88bf	20 51 89	jsr $8951			jsr 	CLCompareLineNo
.88c2	90 0c		bcc $88d0			bcc 	_CLNext
.88c4	a2 07		ldx #$07			ldx 	#7
.88c6	20 51 89	jsr $8951			jsr 	CLCompareLineNo
.88c9	f0 02		beq $88cd			beq 	_CLDoThisOne
.88cb	b0 03		bcs $88d0			bcs 	_CLNext
.88cd					_CLDoThisOne:
.88cd	20 3e 89	jsr $893e			jsr 	CLListOneLine 				; routine to list the current line.
.88d0					_CLNext:
.88d0	18		clc				clc
.88d1	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.88d3	65 30		adc $30				adc 	codePtr
.88d5	85 30		sta $30				sta 	codePtr
.88d7	90 02		bcc $88db			bcc 	_CREExit
.88d9	e6 31		inc $31				inc 	codePtr+1 					; carry
.88db					_CREExit:
.88db	80 d7		bra $88b4			bra 	_CLLoop
.88dd					_CLExit:
.88dd	4c dd 83	jmp $83dd			jmp 	WarmStart
.88e0					_CLBreak:
.88e0	a9 01		lda #$01		lda	#1
.88e2	4c ff 8e	jmp $8eff		jmp	ErrorHandler
.88e5					_CLListProcedure:
.88e5	b1 30		lda ($30),y			lda 	(codePtr),y
.88e7	85 38		sta $38				sta 	zTemp1
.88e9	c8		iny				iny
.88ea	b1 30		lda ($30),y			lda 	(codePtr),y
.88ec	85 39		sta $39				sta 	zTemp1+1
.88ee	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.88f0	85 30		sta $30				sta 	codePtr
.88f2	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.88f4	85 31		sta $31				sta 	codePtr+1
.88f6					_CLLPSearch:
.88f6	b2 30		lda ($30)			lda 	(codePtr)
.88f8	c9 00		cmp #$00			cmp 	#0 							; if zero, end
.88fa	f0 e1		beq $88dd			beq 	_CLExit
.88fc	a0 03		ldy #$03			ldy 	#3 							; check if PROC something
.88fe	b1 30		lda ($30),y			lda 	(codePtr),y
.8900	c9 a4		cmp #$a4			cmp 	#KWD_PROC
.8902	d0 0e		bne $8912			bne 	_CLLPNext
.8904	c8		iny				iny 								; check if PROC this.
.8905	b1 30		lda ($30),y			lda 	(codePtr),y
.8907	c5 38		cmp $38				cmp 	zTemp1 						; does it match ?
.8909	d0 07		bne $8912			bne 	_CLLPNext
.890b	c8		iny				iny
.890c	b1 30		lda ($30),y			lda 	(codePtr),y
.890e	c5 39		cmp $39				cmp 	zTemp1+1
.8910	f0 0d		beq $891f			beq 	_CLLPFound
.8912					_CLLPNext:
.8912	18		clc				clc
.8913	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8915	65 30		adc $30				adc 	codePtr
.8917	85 30		sta $30				sta 	codePtr
.8919	90 02		bcc $891d			bcc 	_CREExit
.891b	e6 31		inc $31				inc 	codePtr+1 					; carry
.891d					_CREExit:
.891d	80 d7		bra $88f6			bra 	_CLLPSearch
.891f					_CLLPFound:
.891f	b2 30		lda ($30)			lda 	(codePtr)
.8921	f0 ba		beq $88dd			beq 	_CLExit
.8923	a0 03		ldy #$03			ldy 	#3 							; get first keyword
.8925	b1 30		lda ($30),y			lda 	(codePtr),y
.8927	48		pha				pha
.8928	20 3e 89	jsr $893e			jsr 	CLListOneLine 				; list line and go forward
.892b	18		clc				clc
.892c	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.892e	65 30		adc $30				adc 	codePtr
.8930	85 30		sta $30				sta 	codePtr
.8932	90 02		bcc $8936			bcc 	_CREExit
.8934	e6 31		inc $31				inc 	codePtr+1 					; carry
.8936					_CREExit:
.8936	68		pla				pla 								; reached ENDPROC ?
.8937	c9 a8		cmp #$a8			cmp 	#KWD_ENDPROC
.8939	d0 e4		bne $891f			bne 	_CLLPFound
.893b	4c dd 83	jmp $83dd			jmp 	WarmStart
.893e					CLListOneLine:
.893e	20 a4 8e	jsr $8ea4			jsr 	ScanGetCurrentLineStep 		; get indent adjust.
.8941	20 1e 80	jsr $801e			jsr 	TKListConvertLine 			; convert line into token Buffer
.8944	a2 04		ldx #$04			ldx 	#(tokenBuffer >> 8) 		; print that line
.8946	a9 2d		lda #$2d			lda 	#(tokenBuffer & $FF)
.8948	20 58 8f	jsr $8f58			jsr 	PrintStringXA
.894b	a9 0d		lda #$0d			lda 	#13 						; new line
.894d	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8950	60		rts				rts
.8951					CLCompareLineNo:
.8951	38		sec				sec
.8952	a0 01		ldy #$01			ldy 	#1
.8954	b1 30		lda ($30),y			lda 	(codePtr),y
.8956	f5 58		sbc $58,x			sbc 	NSMantissa0,x
.8958	85 36		sta $36				sta 	zTemp0
.895a	c8		iny				iny
.895b	b1 30		lda ($30),y			lda 	(codePtr),y
.895d	f5 60		sbc $60,x			sbc 	NSMantissa1,x
.895f	05 36		ora $36				ora 	zTemp0
.8961	60		rts				rts
.8962					CLIsDigit:
.8962	b1 30		lda ($30),y			lda 	(codePtr),y
.8964	c9 30		cmp #$30			cmp 	#"0"
.8966	90 03		bcc $896b			bcc	 	_CLIDExitFalse
.8968	c9 3a		cmp #$3a			cmp 	#"9"+1
.896a	60		rts				rts
.896b					_CLIDExitFalse:
.896b	38		sec				sec
.896c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/local.asm

.896d					Command_LOCAL:
.896d	a2 00		ldx #$00			ldx 	#0 							; at level 0
.896f	20 7b 89	jsr $897b			jsr 	LocaliseNextTerm 			; convert term to a local.
.8972	b1 30		lda ($30),y			lda 	(codePtr),y
.8974	c8		iny				iny
.8975	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8977	f0 f4		beq $896d			beq 	Command_LOCAL 				; if so, localise another variable.
.8979	88		dey				dey 								; unpick pre-get
.897a	60		rts				rts
.897b					LocaliseNextTerm:
.897b	20 4d 98	jsr $984d			jsr 	EvaluateTerm 				; evaluate the term
.897e	b5 50		lda $50,x			lda 	NSStatus,x
.8980	29 20		and #$20			and 	#NSBIsReference 			; check it is a reference, must be a variable.
.8982	f0 5c		beq $89e0			beq		_LNTError
.8984	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address of variable to zTemp0
.8986	85 36		sta $36				sta 	zTemp0
.8988	b5 60		lda $60,x			lda 	NSMantissa1,x
.898a	85 37		sta $37				sta  	zTemp0+1
.898c	b5 50		lda $50,x			lda 	NSStatus,x 					; figure out what it is.
.898e	29 10		and #$10			and 	#NSBIsString
.8990	d0 1e		bne $89b0			bne 	_LNTPushString
.8992	5a		phy				phy
.8993	a0 00		ldy #$00			ldy 	#0 							; push 0 to 4 inclusive, the number values, on the stack, and zero them as you go.
.8995					_LNTPushNumLoop:
.8995	b1 36		lda ($36),y			lda		(zTemp0),y
.8997	20 a7 a6	jsr $a6a7			jsr 	StackPushByte
.899a	c8		iny				iny
.899b	c0 05		cpy #$05			cpy 	#5
.899d	d0 f6		bne $8995			bne 	_LNTPushNumLoop
.899f	a5 36		lda $36				lda 	zTemp0 						; push the actual target address to write on the stack
.89a1	20 a7 a6	jsr $a6a7			jsr 	StackPushByte
.89a4	a5 37		lda $37				lda 	zTemp0+1
.89a6	20 a7 a6	jsr $a6a7			jsr 	StackPushByte
.89a9	a9 01		lda #$01			lda 	#STK_LOCALN 				; push local-number marker.
.89ab	20 a7 a6	jsr $a6a7			jsr 	StackPushByte
.89ae	7a		ply				ply
.89af	60		rts				rts
.89b0					_LNTPushString:
.89b0	5a		phy				phy
.89b1	b2 36		lda ($36)			lda 	(zTemp0) 					; put address of string in zTemp1
.89b3	85 38		sta $38				sta 	zTemp1
.89b5	a0 01		ldy #$01			ldy 	#1
.89b7	b1 36		lda ($36),y			lda 	(zTemp0),y
.89b9	85 39		sta $39				sta 	zTemp1+1
.89bb	a0 00		ldy #$00			ldy 	#0 							; output string
.89bd	c9 00		cmp #$00			cmp 	#0 							; if not assigned string
.89bf	f0 0a		beq $89cb			beq 	_LNTStringOut
.89c1					_LNTPushStrLoop:
.89c1	b1 38		lda ($38),y			lda 	(zTemp1),y
.89c3	f0 06		beq $89cb			beq 	_LNTStringOut
.89c5	20 a7 a6	jsr $a6a7			jsr 	StackPushByte
.89c8	c8		iny				iny
.89c9	80 f6		bra $89c1			bra 	_LNTPushStrLoop
.89cb					_LNTStringOut:
.89cb	98		tya				tya									; output length (chars written).
.89cc	20 a7 a6	jsr $a6a7			jsr 	StackPushByte
.89cf	b5 58		lda $58,x			lda 	NSMantissa0,x 				; output address of the string record *not* the string itself
.89d1	20 a7 a6	jsr $a6a7			jsr 	StackPushByte
.89d4	b5 60		lda $60,x			lda 	NSMantissa1,x
.89d6	20 a7 a6	jsr $a6a7			jsr 	StackPushByte
.89d9	a9 02		lda #$02			lda 	#STK_LOCALS 				; push local-string marker.
.89db	20 a7 a6	jsr $a6a7			jsr 	StackPushByte
.89de	7a		ply				ply
.89df	60		rts				rts
.89e0					_LNTError:
.89e0	4c a4 9f	jmp $9fa4			jmp 	SyntaxError
.89e3					LocalPopValue:
.89e3	20 bf a6	jsr $a6bf			jsr 	StackPopByte
.89e6	c9 01		cmp #$01			cmp 	#STK_LOCALN 				; if not local-N
.89e8	d0 17		bne $8a01			bne 	_LPVString
.89ea	20 bf a6	jsr $a6bf			jsr 	StackPopByte 				; address
.89ed	85 37		sta $37				sta 	zTemp0+1
.89ef	20 bf a6	jsr $a6bf			jsr 	StackPopByte
.89f2	85 36		sta $36				sta 	zTemp0
.89f4	5a		phy				phy
.89f5	a0 04		ldy #$04			ldy 	#4 							; copy back
.89f7					_LPVNumberCopy:
.89f7	20 bf a6	jsr $a6bf			jsr 	StackPopByte
.89fa	91 36		sta ($36),y			sta 	(zTemp0),y
.89fc	88		dey				dey
.89fd	10 f8		bpl $89f7			bpl 	_LPVNumberCopy
.89ff	7a		ply				ply 								; and complete
.8a00	60		rts				rts
.8a01					_LPVString:
.8a01	20 bf a6	jsr $a6bf			jsr 	StackPopByte 				; address of record copied to zTemp0
.8a04	85 37		sta $37				sta 	zTemp0+1
.8a06	20 bf a6	jsr $a6bf			jsr 	StackPopByte
.8a09	85 36		sta $36				sta 	zTemp0
.8a0b	5a		phy				phy
.8a0c	b2 36		lda ($36)			lda 	(zTemp0) 					; address to write string to copied to zTemp1
.8a0e	85 38		sta $38				sta 	zTemp1
.8a10	a0 01		ldy #$01			ldy 	#1
.8a12	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a14	85 39		sta $39				sta 	zTemp1+1
.8a16	20 bf a6	jsr $a6bf			jsr 	StackPopByte 				; # chars to get => y
.8a19	a8		tay				tay
.8a1a	a5 39		lda $39				lda 	zTemp1+1 					; if no target (e.g. was "" originally) exit
.8a1c	f0 0e		beq $8a2c			beq 	_LPVStringCopied
.8a1e	a9 00		lda #$00			lda 	#0 							; NULL on end
.8a20	91 38		sta ($38),y			sta 	(zTemp1),y
.8a22					_LPVStringCopy:
.8a22	88		dey				dey
.8a23	30 07		bmi $8a2c			bmi 	_LPVStringCopied
.8a25	20 bf a6	jsr $a6bf			jsr 	StackPopByte
.8a28	91 38		sta ($38),y			sta 	(zTemp1),y
.8a2a	80 f6		bra $8a22			bra 	_LPVStringCopy
.8a2c					_LPVStringCopied:
.8a2c	fa		plx				plx
.8a2d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/new.asm

.8a2e					NewCommand:
.8a2e	20 34 8a	jsr $8a34			jsr 	NewProgram 					; does the actual NEW.
.8a31	4c dd 83	jmp $83dd			jmp 	WarmStart 					; and warm starts straight away.
.8a34					NewProgram:
.8a34	20 84 a5	jsr $a584			jsr 	MemoryNew
.8a37	9c 00 10	stz $1000			stz 	VariableSpace 				; erase all variables.
.8a3a	20 73 84	jsr $8473			jsr 	ClearCommand 				; clear everything.
.8a3d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/procedure.asm

=2					ParameterStackPos = 2
.8a3e					CallProcedure:
.8a3e	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start storing parameters at 2.
.8a40	b1 30		lda ($30),y			lda 	(codePtr),y
.8a42	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.8a44	f0 0c		beq $8a52			beq 	_CPEndParam
.8a46					_CPParamLoop:
.8a46	20 6b 9d	jsr $9d6b			jsr 	EvaluateValue 				; get parameter onto stack
.8a49	e8		inx				inx 								; bump next stack
.8a4a	b1 30		lda ($30),y			lda 	(codePtr),y
.8a4c	c8		iny				iny
.8a4d	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if comma, go back and try again.
.8a4f	f0 f5		beq $8a46			beq 	_CPParamLoop
.8a51	88		dey				dey 								; unpick.
.8a52					_CPEndParam:
.8a52	8e 16 04	stx $0416			stx 	LastParameter 				; save the last parameters index.
.8a55	c8		iny				iny									; skip right bracket
.8a56	a9 b3		lda #$b3			lda 	#STK_PROC+3 				; allocate 6 bytes on the return stack.
.8a58	20 c8 a6	jsr $a6c8			jsr 	StackOpen
.8a5b	20 0d a7	jsr $a70d			jsr 	STKSaveCodePosition 		; save loop position
.8a5e	a5 58		lda $58				lda 	NSMantissa0 				; copy variable (e.g. procedure) address to zTemp0
.8a60	85 36		sta $36				sta 	zTemp0 						; this is the DATA not the RECORD
.8a62	a5 60		lda $60				lda 	NSMantissa1
.8a64	85 37		sta $37				sta 	zTemp0+1
.8a66	a0 01		ldy #$01			ldy 	#1 							; copy code address back.
.8a68	b2 36		lda ($36)			lda 	(zTemp0)
.8a6a	85 30		sta $30				sta 	safePtr
.8a6c	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a6e	85 31		sta $31				sta 	safePtr+1
.8a70	c8		iny				iny
.8a71	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a73	85 32		sta $32				sta 	safePtr+2
.8a75	c8		iny				iny
.8a76	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a78	85 33		sta $33				sta 	safePtr+3
.8a7a	c8		iny				iny 								; get Y offset -> Y
.8a7b	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a7d	a8		tay				tay
.8a7e	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start position of parameters
.8a80	ec 16 04	cpx $0416			cpx	 	LastParameter 				; check zero parameters at the start
.8a83	f0 13		beq $8a98			beq 	_ParamExit 					; if so, exit.
.8a85					_ParamExtract:
.8a85	ca		dex				dex 								; put a local term on the level before
.8a86	20 7b 89	jsr $897b			jsr 	LocaliseNextTerm			; also pushes original param value to basic stack
.8a89	20 55 88	jsr $8855			jsr 	AssignVariable 				; assign stacked value to the variable.
.8a8c	e8		inx				inx 								; advance to next parameter to do.
.8a8d	e8		inx				inx
.8a8e	ec 16 04	cpx $0416			cpx 	LastParameter 				; are we done ?
.8a91	f0 05		beq $8a98			beq 	_ParamExit
.8a93	20 ee 8e	jsr $8eee			jsr 	CheckComma 					; comma seperating parameters
.8a96	80 ed		bra $8a85			bra 	_ParamExtract
.8a98					_ParamExit:
.8a98	20 e6 8e	jsr $8ee6			jsr 	CheckRightBracket 			; check )
.8a9b	60		rts				rts 								; and continue from here
.8a9c					Command_ENDPROC:
.8a9c	a9 b0		lda #$b0			lda 	#STK_PROC 					; check TOS is this
.8a9e	a2 14		ldx #$14			ldx 	#ERRID_PROC
.8aa0	20 f5 a6	jsr $a6f5			jsr 	StackCheckFrame
.8aa3	20 1e a7	jsr $a71e			jsr 	STKLoadCodePosition 		; restore code position
.8aa6	20 e7 a6	jsr $a6e7			jsr 	StackClose
.8aa9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/read.asm

.8aaa					Command_Read:
.8aaa	a2 00		ldx #$00			ldx 	#0 							; evaluate the term which is the var/array element to assign
.8aac	20 4d 98	jsr $984d			jsr 	EvaluateTerm
.8aaf	b5 50		lda $50,x			lda 	NSStatus,x
.8ab1	29 20		and #$20			and 	#NSBIsReference				; get status byte on stack, identifies int, float, string.
.8ab3	f0 4f		beq $8b04			beq 	_CRSyntax 					; check reference (bit 0) fail if not a reference.
.8ab5	20 4d 8b	jsr $8b4d			jsr 	SwapDataCodePtrs 			; swap code and data
.8ab8	ad 1c 04	lda $041c			lda 	inDataStatement 			; if in a data statement, we don't need to search
.8abb	d0 25		bne $8ae2			bne 	_CRContinueData  			; forward for the next one.
.8abd	b2 30		lda ($30)			lda 	(codePtr)
.8abf	f0 1c		beq $8add			beq 	_CRNoData
.8ac1					_CRKeepSearching:
.8ac1	a9 b4		lda #$b4			lda 	#KWD_DATA 					; scan for instruction
.8ac3	a2 80		ldx #$80			ldx 	#KWC_EOL
.8ac5	20 41 8e	jsr $8e41			jsr 	ScanForward
.8ac8	c9 b4		cmp #$b4			cmp 	#KWD_DATA 					; found data ?
.8aca	f0 16		beq $8ae2			beq 	_CRHaveData 				; found it
.8acc	18		clc				clc
.8acd	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8acf	65 30		adc $30				adc 	codePtr
.8ad1	85 30		sta $30				sta 	codePtr
.8ad3	90 02		bcc $8ad7			bcc 	_CREExit
.8ad5	e6 31		inc $31				inc 	codePtr+1 					; carry
.8ad7					_CREExit:
.8ad7	a0 03		ldy #$03			ldy 	#3 							; start of line.
.8ad9	b2 30		lda ($30)			lda 	(codePtr)
.8adb	d0 e4		bne $8ac1			bne 	_CRKeepSearching
.8add					_CRNoData:
.8add	a9 0b		lda #$0b		lda	#11
.8adf	4c ff 8e	jmp $8eff		jmp	ErrorHandler
.8ae2					_CRHaveData:
.8ae2					_CRContinueData:
.8ae2	a2 01		ldx #$01			ldx 	#1
.8ae4	20 6b 9d	jsr $9d6b			jsr 	EvaluateValue 				; evaluate value into slot # 1
.8ae7	ca		dex				dex
.8ae8	20 55 88	jsr $8855			jsr		AssignVariable 				; do the assignment
.8aeb	9c 1c 04	stz $041c			stz 	inDataStatement 			; clear in data flag
.8aee	b1 30		lda ($30),y			lda 	(codePtr),y
.8af0	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not, end of data statement and exit
.8af2	d0 04		bne $8af8			bne 	_CRSwapBack
.8af4	c8		iny				iny 								; consume comma
.8af5	ee 1c 04	inc $041c			inc 	inDataStatement 			; set in data statement currently.
.8af8					_CRSwapBack:
.8af8	20 4d 8b	jsr $8b4d			jsr 	SwapDataCodePtrs			; swap them back.
.8afb	b1 30		lda ($30),y			lda 	(codePtr),y
.8afd	c8		iny				iny
.8afe	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8b00	f0 a8		beq $8aaa			beq 	Command_Read 				; if so go round again.
.8b02	88		dey				dey 								; unpick get.
.8b03	60		rts				rts
.8b04					_CRSyntax:
.8b04	4c a4 9f	jmp $9fa4			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/rem.asm

.8b07					RemCommand:
.8b07	b1 30		lda ($30),y			lda 	(codePtr),y
.8b09	c9 ff		cmp #$ff			cmp 	#KWC_STRING
.8b0b	d0 06		bne $8b13			bne 	_RMExit
.8b0d	c8		iny				iny 								; point to offset
.8b0e	98		tya				tya 								; A = offset position
.8b0f	38		sec				sec 								; add size +1 hence SEC
.8b10	71 30		adc ($30),y			adc 	(codePtr),y
.8b12	a8		tay				tay 								; make current position.
.8b13					_RMExit:
.8b13	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/repeat.asm

.8b14					Command_REPEAT:
.8b14	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; allocate 6 bytes on the return stack.
.8b16	20 c8 a6	jsr $a6c8			jsr 	StackOpen
.8b19	20 0d a7	jsr $a70d			jsr 	STKSaveCodePosition 		; save loop position
.8b1c	60		rts				rts
.8b1d					Command_UNTIL:
.8b1d	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; check REPEAT is TOS
.8b1f	a2 0f		ldx #$0f			ldx 	#ERRID_REPEAT 				; this error
.8b21	20 f5 a6	jsr $a6f5			jsr 	StackCheckFrame
.8b24	a2 00		ldx #$00			ldx 	#0
.8b26	20 74 9d	jsr $9d74			jsr 	EvaluateNumber 				; work out the number
.8b29	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; check if zero
.8b2c	f0 04		beq $8b32			beq 	_CULoopBack 				; if so keep looping
.8b2e	20 e7 a6	jsr $a6e7			jsr 	StackClose		 			; return
.8b31	60		rts				rts
.8b32					_CULoopBack:
.8b32	20 1e a7	jsr $a71e			jsr 	STKLoadCodePosition 		; loop back
.8b35	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/restore.asm

.8b36					Command_Restore:
.8b36	20 4d 8b	jsr $8b4d			jsr 	SwapDataCodePtrs 			; swap code and data
.8b39	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8b3b	85 30		sta $30				sta 	codePtr
.8b3d	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8b3f	85 31		sta $31				sta 	codePtr+1
.8b41	20 4d 8b	jsr $8b4d			jsr 	SwapDataCodePtrs 			; put them back
.8b44	a9 03		lda #$03			lda 	#3 							; start at offset 3, e.g. first instruction of first line.
.8b46	8d 1b 04	sta $041b			sta 	dataPointer+4   			; (read checks not EOF)
.8b49	9c 1c 04	stz $041c			stz 	inDataStatement 			; not in data statement
.8b4c	60		rts				rts
.8b4d					SwapDataCodePtrs:
.8b4d	da		phx				phx
.8b4e	a2 03		ldx #$03			ldx 	#3 							; swap 32 bit code pointer over
.8b50					_SDCPLoop:
.8b50	b5 30		lda $30,x			lda 	safePtr,x
.8b52	48		pha				pha
.8b53	bd 17 04	lda $0417,x			lda 	dataPointer,x
.8b56	95 30		sta $30,x			sta 	safePtr,x
.8b58	68		pla				pla
.8b59	9d 17 04	sta $0417,x			sta 	dataPointer,x
.8b5c	ca		dex				dex
.8b5d	10 f1		bpl $8b50			bpl 	_SDCPLoop
.8b5f	ad 1b 04	lda $041b			lda 	dataPointer+4 				; swap Y position over.
.8b62	8c 1b 04	sty $041b			sty 	dataPointer+4
.8b65	a8		tay				tay
.8b66	fa		plx				plx
.8b67	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/run.asm

.8b68					EOLCommand:
.8b68	18		clc				clc
.8b69	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8b6b	65 30		adc $30				adc 	codePtr
.8b6d	85 30		sta $30				sta 	codePtr
.8b6f	90 02		bcc $8b73			bcc 	_CREExit
.8b71	e6 31		inc $31				inc 	codePtr+1 					; carry
.8b73					_CREExit:
.8b73	80 0b		bra $8b80			bra 	RunNewLine
.8b75					CommandRUN:
.8b75	20 73 84	jsr $8473			jsr 	ClearCommand 				; clear variable/stacks/etc.
.8b78	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8b7a	85 30		sta $30				sta 	codePtr
.8b7c	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8b7e	85 31		sta $31				sta 	codePtr+1
.8b80					RUNNewLine:
.8b80	b2 30		lda ($30)			lda 	(codePtr)
.8b82	f0 7b		beq $8bff			beq 	CRNoProgram         		; no then END.
.8b84	a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack
.8b86	9a		txs				txs
.8b87					RUNCodePointerLine:
.8b87	a0 02		ldy #$02			ldy 	#2 							; start of program
.8b89					_CRIncMainLoop:
.8b89	0e 13 04	asl $0413			asl 	breakCheck 					; clears 1 time in 8
.8b8c	d0 22		bne $8bb0			bne 	_CRNoBreakCheck
.8b8e	ce 13 04	dec $0413			dec	 	breakCheck 					; set it back to $FF
.8b91	20 0c 80	jsr $800c			jsr 	EXTBreakCheck 				; break check
.8b94	f0 64		beq $8bfa			beq 	_CRBreak
.8b96	a5 01		lda $01				lda 	1 							; save I/O 0
.8b98	48		pha				pha
.8b99	64 01		stz $01				stz 	1 							; access I/O Page 0
.8b9b	38		sec				sec 								; calculate timer - LastTick
.8b9c	ad 59 d6	lda $d659			lda 	$D659
.8b9f	aa		tax				tax 								; saving timer in X
.8ba0	ed 5c 06	sbc $065c			sbc 	LastTick
.8ba3	c9 03		cmp #$03			cmp 	#3
.8ba5	90 06		bcc $8bad			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.8ba7	8e 5c 06	stx $065c			stx 	LastTick 					; update last timer
.8baa	20 51 9e	jsr $9e51			jsr 	TickHandler 							; go do the code.
.8bad					_NoFireTick:
.8bad	68		pla				pla 								; restore I/O 0
.8bae	85 01		sta $01				sta 	1
.8bb0					_CRNoBreakCheck:
.8bb0	c8		iny				iny									; next token
.8bb1					_CRMainLoop:
.8bb1	9c 10 04	stz $0410			stz 	stringInitialised 			; clear the temporary string initialised flag.
.8bb4	b1 30		lda ($30),y			lda 	(codePtr),y
.8bb6	10 10		bpl $8bc8			bpl 	_CRNotKeyword				; not a token.
.8bb8	c9 a2		cmp #$a2			cmp 	#KWC_LAST_UNARY+1 			; if after unary, legitimate command
.8bba	b0 04		bcs $8bc0			bcs 	_CRIsKeyword
.8bbc	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if unary, syntax error.
.8bbe	b0 34		bcs $8bf4			bcs		_CRSyntaxError
.8bc0					_CRIsKeyword:
.8bc0	c8		iny				iny 								; consume command
.8bc1	0a		asl a				asl 	a 							; double losing the MSB which is '1' as tokens are $80-$FF
.8bc2	aa		tax				tax 								; put in X for vector jump
.8bc3	20 f7 8b	jsr $8bf7			jsr 	_CRCallVector0 				; call the vector - effectively jsr (vectortable,X)
.8bc6	80 e9		bra $8bb1			bra 	_CRMainLoop 				; and loop round
.8bc8					_CRNotKeyword:
.8bc8	c9 3a		cmp #$3a			cmp 	#KWD_COLON 					; if a :, consume it and go round.
.8bca	f0 bd		beq $8b89			beq 	_CRIncMainLoop
.8bcc	c9 40		cmp #$40			cmp 	#$40 						; variable/call reference
.8bce	90 05		bcc $8bd5			bcc 	_CRNotVariable
.8bd0					_CRGoLet:
.8bd0	20 1c 88	jsr $881c			jsr 	LetCommand
.8bd3	80 dc		bra $8bb1			bra 	_CRMainLoop
.8bd5					_CRNotVariable:
.8bd5	c9 10		cmp #$10			cmp 	#KWD_AT 					; handle @
.8bd7	f0 f7		beq $8bd0			beq 	_CRGoLet
.8bd9	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; handle ? !
.8bdb	f0 f3		beq $8bd0			beq 	_CRGoLet
.8bdd	c9 21		cmp #$21			cmp 	#KWD_PLING
.8bdf	f0 ef		beq $8bd0			beq 	_CRGoLet
.8be1	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; handle ' (comment)
.8be3	f0 09		beq $8bee			beq 	_CRGoRem
.8be5	c9 2e		cmp #$2e			cmp 	#KWD_PERIOD 				; handle . (assembler label)
.8be7	d0 0b		bne $8bf4			bne 	_CRSyntaxError
.8be9	20 57 82	jsr $8257			jsr 	LabelHere
.8bec	80 c3		bra $8bb1			bra 	_CRMainLoop
.8bee					_CRGoRem:
.8bee	c8		iny				iny
.8bef	20 07 8b	jsr $8b07			jsr 	RemCommand
.8bf2	80 bd		bra $8bb1			bra 	_CRMainLoop
.8bf4					_CRSyntaxError:
.8bf4	4c a4 9f	jmp $9fa4			jmp 	SyntaxError
.8bf7					_CRCallVector0:
.8bf7	7c 96 8c	jmp ($8c96,x)			jmp 	(VectorSet0,x)
.8bfa					_CRBreak:
.8bfa	a9 01		lda #$01		lda	#1
.8bfc	4c ff 8e	jmp $8eff		jmp	ErrorHandler
.8bff					CRNoProgram:
.8bff	4c c1 85	jmp $85c1			jmp 	EndCommand
.8c02					Shift1Command:
.8c02	b1 30		lda ($30),y			lda 	(codePtr),y
.8c04	c8		iny				iny
.8c05	0a		asl a				asl 	a
.8c06	aa		tax				tax
.8c07	7c 3c 8d	jmp ($8d3c,x)			jmp 	(VectorSet1,x)
.8c0a					Shift2Command:
.8c0a	b1 30		lda ($30),y			lda 	(codePtr),y
.8c0c	c8		iny				iny
.8c0d	0a		asl a				asl 	a
.8c0e	aa		tax				tax
.8c0f	7c 62 8d	jmp ($8d62,x)			jmp 	(VectorSet2,x)
.8c12					Unused1:
.8c12					Unused2:
.8c12					Unused3:
.8c12					Unused4:
.8c12	4c a4 9f	jmp $9fa4			jmp 	SyntaxError
>8c15							.align 2

;******  Processing file: ./common/commands/../generated/vectors.dat

.8c16					VectorSetPunc:
>8c16	b7 91					.word	ShiftLeft                        ; $00 <<
>8c18	a2 8f					.word	BinaryCompareLessEqual           ; $01 <=
>8c1a	98 8f					.word	BinaryCompareNotEqual            ; $02 <>
>8c1c	a4 9f					.word	SyntaxError                      ; $03 !!3
>8c1e	a4 9f					.word	SyntaxError                      ; $04 ><
>8c20	ac 8f					.word	BinaryCompareGreaterEqual        ; $05 >=
>8c22	ba 91					.word	ShiftRight                       ; $06 >>
>8c24	a4 9f					.word	SyntaxError                      ; $07 !!7
>8c26	a4 9f					.word	SyntaxError                      ; $08 !!8
>8c28	a4 9f					.word	SyntaxError                      ; $09 !!9
>8c2a	a4 9f					.word	SyntaxError                      ; $0a !!10
>8c2c	a4 9f					.word	SyntaxError                      ; $0b !!11
>8c2e	a4 9f					.word	SyntaxError                      ; $0c !!12
>8c30	a4 9f					.word	SyntaxError                      ; $0d !!13
>8c32	a4 9f					.word	SyntaxError                      ; $0e !!14
>8c34	a4 9f					.word	SyntaxError                      ; $0f !!15
>8c36	a4 9f					.word	SyntaxError                      ; $10 @
>8c38	a4 9f					.word	SyntaxError                      ; $11 !!17
>8c3a	a4 9f					.word	SyntaxError                      ; $12 !!18
>8c3c	a4 9f					.word	SyntaxError                      ; $13 [
>8c3e	63 90					.word	IntegerDivide                    ; $14 \
>8c40	a4 9f					.word	SyntaxError                      ; $15 ]
>8c42	f5 92					.word	EorInteger                       ; $16 ^
>8c44	a4 9f					.word	SyntaxError                      ; $17 _
>8c46	a4 9f					.word	SyntaxError                      ; $18 `
>8c48	a4 9f					.word	SyntaxError                      ; $19 !!25
>8c4a	a4 9f					.word	SyntaxError                      ; $1a !!26
>8c4c	a4 9f					.word	SyntaxError                      ; $1b {
>8c4e	c0 92					.word	OraInteger                       ; $1c |
>8c50	a4 9f					.word	SyntaxError                      ; $1d }
>8c52	a4 9f					.word	SyntaxError                      ; $1e ~
>8c54	a4 9f					.word	SyntaxError                      ; $1f [7m<7F>[m
>8c56	a4 9f					.word	SyntaxError                      ; $20
>8c58	2a 93					.word	WordIndirect                     ; $21 !
>8c5a	a4 9f					.word	SyntaxError                      ; $22 "
>8c5c	a4 9f					.word	SyntaxError                      ; $23 #
>8c5e	a4 9f					.word	SyntaxError                      ; $24 $
>8c60	a4 90					.word	IntegerModulus                   ; $25 %
>8c62	8b 92					.word	AndInteger                       ; $26 &
>8c64	a4 9f					.word	SyntaxError                      ; $27 '
>8c66	a4 9f					.word	SyntaxError                      ; $28 (
>8c68	a4 9f					.word	SyntaxError                      ; $29 )
>8c6a	12 91					.word	MulInteger                       ; $2a *
>8c6c	2d 92					.word	AddInteger                       ; $2b +
>8c6e	a4 9f					.word	SyntaxError                      ; $2c ,
>8c70	66 92					.word	SubInteger                       ; $2d -
>8c72	a4 9f					.word	SyntaxError                      ; $2e .
>8c74	e4 94					.word	FDivideCommand                   ; $2f /
>8c76	a4 9f					.word	SyntaxError                      ; $30 0
>8c78	a4 9f					.word	SyntaxError                      ; $31 1
>8c7a	a4 9f					.word	SyntaxError                      ; $32 2
>8c7c	a4 9f					.word	SyntaxError                      ; $33 3
>8c7e	a4 9f					.word	SyntaxError                      ; $34 4
>8c80	a4 9f					.word	SyntaxError                      ; $35 5
>8c82	a4 9f					.word	SyntaxError                      ; $36 6
>8c84	a4 9f					.word	SyntaxError                      ; $37 7
>8c86	a4 9f					.word	SyntaxError                      ; $38 8
>8c88	a4 9f					.word	SyntaxError                      ; $39 9
>8c8a	a4 9f					.word	SyntaxError                      ; $3a :
>8c8c	a4 9f					.word	SyntaxError                      ; $3b ;
>8c8e	84 8f					.word	BinaryCompareLess                ; $3c <
>8c90	7a 8f					.word	BinaryCompareEqual               ; $3d =
>8c92	8e 8f					.word	BinaryCompareGreater             ; $3e >
>8c94	4c 93					.word	ByteIndirect                     ; $3f ?
.8c96					VectorSet0:
>8c96	68 8b					.word	EOLCommand                       ; $80 !0:EOF
>8c98	02 8c					.word	Shift1Command                    ; $81 !1:SH1
>8c9a	0a 8c					.word	Shift2Command                    ; $82 !2:SH2
>8c9c	ce 99					.word	AbsUnary                         ; $83 ABS(
>8c9e	dc 99					.word	AllocUnary                       ; $84 ALLOC(
>8ca0	4c 9a					.word	AscUnary                         ; $85 ASC(
>8ca2	0c 9c					.word	ChrUnary                         ; $86 CHR$(
>8ca4	5c 9a					.word	DeekUnary                        ; $87 DEEK(
>8ca6	04 a4					.word	UnaryEvent                       ; $88 EVENT(
>8ca8	76 8f					.word	UnaryFalse                       ; $89 FALSE
>8caa	6e 9a					.word	FracUnary                        ; $8a FRAC(
>8cac	a0 a3					.word	UnaryHit                         ; $8b HIT(
>8cae	83 9a					.word	IntUnary                         ; $8c INT(
>8cb0	cb 9b					.word	IsValUnary                       ; $8d ISVAL(
>8cb2	88 a4					.word	UnaryJoyB                        ; $8e JOYB(
>8cb4	61 a4					.word	UnaryJoyX                        ; $8f JOYX(
>8cb6	64 a4					.word	UnaryJoyY                        ; $90 JOYY(
>8cb8	df 9c					.word	Unary_Left                       ; $91 LEFT$(
>8cba	94 9a					.word	LenUnary                         ; $92 LEN(
>8cbc	b2 9a					.word	Unary_Max                        ; $93 MAX(
>8cbe	01 9d					.word	Unary_Mid                        ; $94 MID$(
>8cc0	ae 9a					.word	Unary_Min                        ; $95 MIN(
>8cc2	fd 9a					.word	Unary_Not                        ; $96 NOT(
>8cc4	59 9a					.word	PeekUnary                        ; $97 PEEK(
>8cc6	25 a6					.word	UnaryPlaying                     ; $98 PLAYING(
>8cc8	10 9b					.word	Unary_Random                     ; $99 RANDOM(
>8cca	ec 9c					.word	Unary_Right                      ; $9a RIGHT$(
>8ccc	2d 9b					.word	Unary_Rnd                        ; $9b RND(
>8cce	a3 9b					.word	SgnUnary                         ; $9c SGN(
>8cd0	1e 9c					.word	SpcUnary                         ; $9d SPC(
>8cd2	39 9c					.word	Unary_Str                        ; $9e STR$(
>8cd4	ae a4					.word	UnaryTimer                       ; $9f TIMER(
>8cd6	6b 8f					.word	UnaryTrue                        ; $a0 TRUE
>8cd8	c1 9b					.word	ValUnary                         ; $a1 VAL(
>8cda	c4 85					.word	ForCommand                       ; $a2 FOR
>8cdc	07 87					.word	IfCommand                        ; $a3 IF
>8cde	12 8c					.word	Unused1                          ; $a4 PROC
>8ce0	14 8b					.word	Command_REPEAT                   ; $a5 REPEAT
>8ce2	b7 8e					.word	Command_WHILE                    ; $a6 WHILE
>8ce4	30 87					.word	EndIf                            ; $a7 ENDIF
>8ce6	9c 8a					.word	Command_ENDPROC                  ; $a8 ENDPROC
>8ce8	76 86					.word	NextCommand                      ; $a9 NEXT
>8cea	12 8c					.word	Unused4                          ; $aa THEN
>8cec	1d 8b					.word	Command_UNTIL                    ; $ab UNTIL
>8cee	d8 8e					.word	Command_WEND                     ; $ac WEND
>8cf0	a4 9f					.word	SyntaxError                      ; $ad BY
>8cf2	3e 84					.word	CallCommand                      ; $ae CALL
>8cf4	54 a1					.word	CircleCommand                    ; $af CIRCLE
>8cf6	73 84					.word	ClearCommand                     ; $b0 CLEAR
>8cf8	cb 84					.word	ClearScreen                      ; $b1 CLS
>8cfa	a4 9f					.word	SyntaxError                      ; $b2 COLOR
>8cfc	a4 9f					.word	SyntaxError                      ; $b3 COLOUR
>8cfe	d3 84					.word	Command_Data                     ; $b4 DATA
>8d00	db 84					.word	DimCommand                       ; $b5 DIM
>8d02	9b 85					.word	DokeCommand                      ; $b6 DOKE
>8d04	12 8c					.word	Unused3                          ; $b7 DOWNTO
>8d06	29 87					.word	ElseCode                         ; $b8 ELSE
>8d08	a4 9f					.word	SyntaxError                      ; $b9 FROM
>8d0a	73 a3					.word	GfxCommand                       ; $ba GFX
>8d0c	cf 86					.word	Command_GOSUB                    ; $bb GOSUB
>8d0e	ed 86					.word	GotoCommand                      ; $bc GOTO
>8d10	a4 9f					.word	SyntaxError                      ; $bd HERE
>8d12	7d a1					.word	ImageCommand                     ; $be IMAGE
>8d14	31 87					.word	Command_Input                    ; $bf INPUT
>8d16	1c 88					.word	LetCommand                       ; $c0 LET
>8d18	cf a1					.word	LineCommand                      ; $c1 LINE
>8d1a	6d 89					.word	Command_LOCAL                    ; $c2 LOCAL
>8d1c	a4 9f					.word	SyntaxError                      ; $c3 OFF
>8d1e	a4 9f					.word	SyntaxError                      ; $c4 ON
>8d20	a4 9f					.word	SyntaxError                      ; $c5 OUTLINE
>8d22	c4 a3					.word	PaletteCommand                   ; $c6 PALETTE
>8d24	c8 a1					.word	PlotCommand                      ; $c7 PLOT
>8d26	98 85					.word	PokeCommand                      ; $c8 POKE
>8d28	38 87					.word	Command_Print                    ; $c9 PRINT
>8d2a	aa 8a					.word	Command_Read                     ; $ca READ
>8d2c	50 a1					.word	RectangleCommand                 ; $cb RECT
>8d2e	07 8b					.word	RemCommand                       ; $cc REM
>8d30	df 86					.word	Command_RETURN                   ; $cd RETURN
>8d32	a4 9f					.word	SyntaxError                      ; $ce SOLID
>8d34	41 a6					.word	SoundCommand                     ; $cf SOUND
>8d36	5f a1					.word	SpriteCommand                    ; $d0 SPRITE
>8d38	99 a1					.word	TextCommand                      ; $d1 TEXT
>8d3a	12 8c					.word	Unused2                          ; $d2 TO
.8d3c					VectorSet1:
>8d3c	a4 9f					.word	SyntaxError                      ; $80 !0:EOF
>8d3e	a4 9f					.word	SyntaxError                      ; $81 !1:SH1
>8d40	a4 9f					.word	SyntaxError                      ; $82 !2:SH2
>8d42	12 84					.word	AssembleCommand                  ; $83 ASSEMBLE
>8d44	2e 84					.word	AssertCommand                    ; $84 ASSERT
>8d46	13 a3					.word	BitmapCtrl                       ; $85 BITMAP
>8d48	c1 85					.word	EndCommand                       ; $86 END
>8d4a	f9 a5					.word	Explode                          ; $87 EXPLODE
>8d4c	a5 a4					.word	GoCommand                        ; $88 GO
>8d4e	6c 88					.word	Command_List                     ; $89 LIST
>8d50	9c a4					.word	LoadCommand                      ; $8a LOAD
>8d52	2e 8a					.word	NewCommand                       ; $8b NEW
>8d54	d5 a5					.word	PingCommand                      ; $8c PING
>8d56	36 8b					.word	Command_Restore                  ; $8d RESTORE
>8d58	75 8b					.word	CommandRUN                       ; $8e RUN
>8d5a	ed a5					.word	ShootCommand                     ; $8f SHOOT
>8d5c	58 a3					.word	SpritesCtrl                      ; $90 SPRITES
>8d5e	ea 8d					.word	StopCommand                      ; $91 STOP
>8d60	e1 a5					.word	ZapCommand                       ; $92 ZAP
.8d62					VectorSet2:
>8d62	a4 9f					.word	SyntaxError                      ; $80 !0:EOF
>8d64	a4 9f					.word	SyntaxError                      ; $81 !1:SH1
>8d66	a4 9f					.word	SyntaxError                      ; $82 !2:SH2
>8d68	63 9e					.word	Assemble_adc                     ; $83 ADC
>8d6a	5b 9e					.word	Assemble_and                     ; $84 AND
>8d6c	77 9e					.word	Assemble_asl                     ; $85 ASL
>8d6e	e1 9e					.word	Assemble_bcc                     ; $86 BCC
>8d70	e5 9e					.word	Assemble_bcs                     ; $87 BCS
>8d72	ed 9e					.word	Assemble_beq                     ; $88 BEQ
>8d74	a4 9e					.word	Assemble_bit                     ; $89 BIT
>8d76	d5 9e					.word	Assemble_bmi                     ; $8a BMI
>8d78	e9 9e					.word	Assemble_bne                     ; $8b BNE
>8d7a	d1 9e					.word	Assemble_bpl                     ; $8c BPL
>8d7c	f1 9e					.word	Assemble_bra                     ; $8d BRA
>8d7e	f5 9e					.word	Assemble_brk                     ; $8e BRK
>8d80	d9 9e					.word	Assemble_bvc                     ; $8f BVC
>8d82	dd 9e					.word	Assemble_bvs                     ; $90 BVS
>8d84	fd 9e					.word	Assemble_clc                     ; $91 CLC
>8d86	51 9f					.word	Assemble_cld                     ; $92 CLD
>8d88	11 9f					.word	Assemble_cli                     ; $93 CLI
>8d8a	41 9f					.word	Assemble_clv                     ; $94 CLV
>8d8c	6f 9e					.word	Assemble_cmp                     ; $95 CMP
>8d8e	b8 9e					.word	Assemble_cpx                     ; $96 CPX
>8d90	b3 9e					.word	Assemble_cpy                     ; $97 CPY
>8d92	95 9e					.word	Assemble_dec                     ; $98 DEC
>8d94	4d 9f					.word	Assemble_dex                     ; $99 DEX
>8d96	29 9f					.word	Assemble_dey                     ; $9a DEY
>8d98	5f 9e					.word	Assemble_eor                     ; $9b EOR
>8d9a	9a 9e					.word	Assemble_inc                     ; $9c INC
>8d9c	5d 9f					.word	Assemble_inx                     ; $9d INX
>8d9e	49 9f					.word	Assemble_iny                     ; $9e INY
>8da0	cc 9e					.word	Assemble_jmp                     ; $9f JMP
>8da2	c7 9e					.word	Assemble_jsr                     ; $a0 JSR
>8da4	6b 9e					.word	Assemble_lda                     ; $a1 LDA
>8da6	90 9e					.word	Assemble_ldx                     ; $a2 LDX
>8da8	ae 9e					.word	Assemble_ldy                     ; $a3 LDY
>8daa	81 9e					.word	Assemble_lsr                     ; $a4 LSR
>8dac	61 9f					.word	Assemble_nop                     ; $a5 NOP
>8dae	57 9e					.word	Assemble_ora                     ; $a6 ORA
>8db0	0d 9f					.word	Assemble_pha                     ; $a7 PHA
>8db2	f9 9e					.word	Assemble_php                     ; $a8 PHP
>8db4	55 9f					.word	Assemble_phx                     ; $a9 PHX
>8db6	15 9f					.word	Assemble_phy                     ; $aa PHY
>8db8	1d 9f					.word	Assemble_pla                     ; $ab PLA
>8dba	01 9f					.word	Assemble_plp                     ; $ac PLP
>8dbc	69 9f					.word	Assemble_plx                     ; $ad PLX
>8dbe	25 9f					.word	Assemble_ply                     ; $ae PLY
>8dc0	7c 9e					.word	Assemble_rol                     ; $af ROL
>8dc2	86 9e					.word	Assemble_ror                     ; $b0 ROR
>8dc4	09 9f					.word	Assemble_rti                     ; $b1 RTI
>8dc6	19 9f					.word	Assemble_rts                     ; $b2 RTS
>8dc8	73 9e					.word	Assemble_sbc                     ; $b3 SBC
>8dca	05 9f					.word	Assemble_sec                     ; $b4 SEC
>8dcc	65 9f					.word	Assemble_sed                     ; $b5 SED
>8dce	21 9f					.word	Assemble_sei                     ; $b6 SEI
>8dd0	67 9e					.word	Assemble_sta                     ; $b7 STA
>8dd2	59 9f					.word	Assemble_stp                     ; $b8 STP
>8dd4	8b 9e					.word	Assemble_stx                     ; $b9 STX
>8dd6	a9 9e					.word	Assemble_sty                     ; $ba STY
>8dd8	9f 9e					.word	Assemble_stz                     ; $bb STZ
>8dda	3d 9f					.word	Assemble_tax                     ; $bc TAX
>8ddc	39 9f					.word	Assemble_tay                     ; $bd TAY
>8dde	c2 9e					.word	Assemble_trb                     ; $be TRB
>8de0	bd 9e					.word	Assemble_tsb                     ; $bf TSB
>8de2	45 9f					.word	Assemble_tsx                     ; $c0 TSX
>8de4	2d 9f					.word	Assemble_txa                     ; $c1 TXA
>8de6	35 9f					.word	Assemble_txs                     ; $c2 TXS
>8de8	31 9f					.word	Assemble_tya                     ; $c3 TYA

;******  Return to file: ./common/commands/run.asm


;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/stop.asm

.8dea					StopCommand:
.8dea	a9 08		lda #$08		lda	#8
.8dec	4c ff 8e	jmp $8eff		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/procscan.asm

.8def					ProcedureScan:
.8def	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8df1	85 30		sta $30				sta 	codePtr
.8df3	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8df5	85 31		sta $31				sta 	codePtr+1
.8df7					_PSLoop:
.8df7	b2 30		lda ($30)			lda 	(codePtr)
.8df9	f0 42		beq $8e3d			beq 	_PSExit
.8dfb	a0 03		ldy #$03			ldy 	#3 							; is it PROC at start of line ?
.8dfd	b1 30		lda ($30),y			lda 	(codePtr),y
.8dff	c9 a4		cmp #$a4			cmp 	#KWD_PROC
.8e01	d0 2d		bne $8e30			bne 	_PSNext
.8e03	c8		iny				iny 								; get the address of the record to zTemp0 and
.8e04	b1 30		lda ($30),y			lda 	(codePtr),y
.8e06	29 c0		and #$c0			and 	#$C0
.8e08	c9 40		cmp #$40			cmp 	#$40
.8e0a	d0 32		bne $8e3e			bne 	_PSSyntax
.8e0c	b1 30		lda ($30),y			lda 	(codePtr),y
.8e0e	18		clc				clc
.8e0f	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8e11	85 37		sta $37				sta 	zTemp0+1
.8e13	c8		iny				iny 								; LSB
.8e14	b1 30		lda ($30),y			lda 	(codePtr),y
.8e16	85 36		sta $36				sta 	zTemp0
.8e18	c8		iny				iny 								; character after variable call.
.8e19	98		tya				tya 								; save Y offset at +7 (exponent slot)
.8e1a	a0 07		ldy #$07			ldy 	#7
.8e1c	91 36		sta ($36),y			sta 	(zTemp0),y
.8e1e	a9 18		lda #$18			lda 	#NSTProcedure 				; mark it as procedure
.8e20	a0 02		ldy #$02			ldy 	#2
.8e22	91 36		sta ($36),y			sta 	(zTemp0),y
.8e24	a2 00		ldx #$00			ldx 	#0 							; copy code-Ptr into offset 3-6 (mantissa)
.8e26					_PSCopy:
.8e26	b5 30		lda $30,x			lda 	safePtr,x
.8e28	c8		iny				iny
.8e29	91 36		sta ($36),y			sta 	(zTemp0),y
.8e2b	e8		inx				inx
.8e2c	e0 04		cpx #$04			cpx 	#4
.8e2e	d0 f6		bne $8e26			bne 	_PSCopy
.8e30					_PSNext:
.8e30	18		clc				clc
.8e31	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8e33	65 30		adc $30				adc 	codePtr
.8e35	85 30		sta $30				sta 	codePtr
.8e37	90 02		bcc $8e3b			bcc 	_CREExit
.8e39	e6 31		inc $31				inc 	codePtr+1 					; carry
.8e3b					_CREExit:
.8e3b	80 ba		bra $8df7			bra 	_PSLoop
.8e3d					_PSExit:
.8e3d	60		rts				rts
.8e3e					_PSSyntax:
.8e3e	4c a4 9f	jmp $9fa4			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/scanforward.asm

.8e41					ScanForward:
.8e41	64 38		stz $38				stz 	zTemp1 						; zero the structure count - goes up with WHILE/FOR down with WEND/NEXT etc.
.8e43	86 37		stx $37				stx 	zTemp0+1
.8e45	85 36		sta $36				sta 	zTemp0 						; save X & A as the two possible matches.
.8e47					_ScanLoop:
.8e47	b1 30		lda ($30),y			lda 	(codePtr),y
.8e49	c8		iny				iny
.8e4a	a6 38		ldx $38				ldx 	zTemp1 						; if the count is > 0 cannot match as in substructure
.8e4c	d0 0e		bne $8e5c			bne 	_ScanGoNext
.8e4e	c5 36		cmp $36				cmp 	zTemp0 						; see if either matches
.8e50	f0 04		beq $8e56			beq 	_ScanMatch
.8e52	c5 37		cmp $37				cmp 	zTemp0+1
.8e54	d0 06		bne $8e5c			bne 	_ScanGoNext
.8e56					_ScanMatch:
.8e56	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if asked for EOL, backtrack.
.8e58	d0 01		bne $8e5b			bne 	_ScanNotEndEOL
.8e5a	88		dey				dey
.8e5b					_ScanNotEndEOL:
.8e5b	60		rts				rts
.8e5c					_ScanGoNext:
.8e5c	20 61 8e	jsr $8e61			jsr  	ScanForwardOne 				; allows for shifts and so on.
.8e5f	80 e6		bra $8e47			bra 	_ScanLoop
.8e61					ScanForwardOne:
.8e61	c9 40		cmp #$40			cmp 	#$40 						; if 00-3F, punctuation characters, already done.
.8e63	90 3e		bcc $8ea3			bcc 	_SFWExit
.8e65	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if 40-82, skip one extra as these are 2 byte
.8e67	90 18		bcc $8e81			bcc 	_ScanSkipOne	 			; offsets into the identifier table or shifts.
.8e69	c9 fc		cmp #$fc			cmp 	#$FC 						; FC-FF are data skips (hex consts, strings etc.)
.8e6b	b0 2f		bcs $8e9c			bcs 	_ScanSkipData
.8e6d	c9 a2		cmp #$a2			cmp 	#KWC_FIRST_STRUCTURE 		; structure keyword ?
.8e6f	90 32		bcc $8ea3			bcc 	_SFWExit 					; if not, ordinary keywords.
.8e71	c9 ad		cmp #$ad			cmp 	#KWC_LAST_STRUCTURE+1
.8e73	b0 2e		bcs $8ea3			bcs 	_SFWExit
.8e75	c6 38		dec $38				dec 	zTemp1 						; decrement the sructure count
.8e77	c9 a7		cmp #$a7			cmp 	#KWC_FIRST_STRUCTURE_DEC 	; back if it is a dec structure (e.g. WEND/NEXT)
.8e79	b0 28		bcs $8ea3			bcs 	_SFWExit
.8e7b	e6 38		inc $38				inc 	zTemp1 						; so it's an increment structure
.8e7d	e6 38		inc $38				inc 	zTemp1 						; twice to undo the dec
.8e7f	80 22		bra $8ea3			bra 	_SFWExit
.8e81					_ScanSkipOne:
.8e81	c8		iny				iny 								; consume the extra one.
.8e82	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if not EOL loop back
.8e84	d0 1d		bne $8ea3			bne 	_SFWExit
.8e86	18		clc				clc
.8e87	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8e89	65 30		adc $30				adc 	codePtr
.8e8b	85 30		sta $30				sta 	codePtr
.8e8d	90 02		bcc $8e91			bcc 	_CREExit
.8e8f	e6 31		inc $31				inc 	codePtr+1 					; carry
.8e91					_CREExit:
.8e91	a0 03		ldy #$03			ldy 	#3 							; scan start position.
.8e93	b2 30		lda ($30)			lda 	(codePtr)
.8e95	d0 0c		bne $8ea3			bne 	_SFWExit 					; if not zero, more to scan
.8e97	a9 13		lda #$13		lda	#19
.8e99	4c ff 8e	jmp $8eff		jmp	ErrorHandler
.8e9c					_ScanSkipData:
.8e9c	88		dey				dey 								; point at data token
.8e9d	c8		iny				iny 								; point to offset
.8e9e	98		tya				tya 								; A = offset position
.8e9f	38		sec				sec 								; add size +1 hence SEC
.8ea0	71 30		adc ($30),y			adc 	(codePtr),y
.8ea2	a8		tay				tay 								; make current position.
.8ea3					_SFWExit:
.8ea3	60		rts				rts
.8ea4					ScanGetCurrentLineStep:
.8ea4	64 38		stz $38				stz 	zTemp1
.8ea6	a0 03		ldy #$03			ldy 	#3
.8ea8					_SGCLSLoop:
.8ea8	b1 30		lda ($30),y			lda 	(codePtr),y
.8eaa	c8		iny				iny
.8eab	c9 80		cmp #$80			cmp 	#KWC_EOL	 				; if EOL exit
.8ead	f0 05		beq $8eb4			beq 	_SGCLSExit
.8eaf	20 61 8e	jsr $8e61			jsr 	ScanForwardOne
.8eb2	80 f4		bra $8ea8			bra 	_SGCLSLoop
.8eb4					_SGCLSExit:
.8eb4	a5 38		lda $38				lda 	zTemp1 						; return the adjustment
.8eb6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/while.asm

.8eb7					Command_WHILE:
.8eb7	5a		phy				phy 								; save position of the test
.8eb8	a2 00		ldx #$00			ldx 	#0 							; work out the while test.
.8eba	20 74 9d	jsr $9d74			jsr 	EvaluateNumber
.8ebd	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; check if zero
.8ec0	f0 0e		beq $8ed0			beq 	_WHExitLoop 				; if so exit the loop, while has failed.
.8ec2	98		tya				tya 								; position *after* test.
.8ec3	7a		ply				ply 								; restore position before test, at WHILE
.8ec4	88		dey				dey 								; so we execute the WHILE command again.
.8ec5	48		pha				pha 								; push after test on the stack
.8ec6	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; allocate 6 bytes on the return stack.
.8ec8	20 c8 a6	jsr $a6c8			jsr 	StackOpen
.8ecb	20 0d a7	jsr $a70d			jsr 	STKSaveCodePosition 		; save loop position - where the test value expr is.
.8ece	7a		ply				ply 								; restore the position *after* the test
.8ecf	60		rts				rts
.8ed0					_WHExitLoop:
.8ed0	68		pla				pla 								; throw post loop position
.8ed1	a9 ac		lda #$ac			lda 	#KWD_WEND 					; scan forward past WEND
.8ed3	aa		tax				tax
.8ed4	20 41 8e	jsr $8e41			jsr 	ScanForward
.8ed7	60		rts				rts
.8ed8					Command_WEND:
.8ed8	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; check WHILE is TOS e.g. in a while loop :)
.8eda	a2 10		ldx #$10			ldx 	#ERRID_WHILE 				; this error if not.
.8edc	20 f5 a6	jsr $a6f5			jsr 	StackCheckFrame
.8edf	20 1e a7	jsr $a71e			jsr 	STKLoadCodePosition 		; loop back to the WHILE keyword.
.8ee2	20 e7 a6	jsr $a6e7			jsr 	StackClose		 			; erase the frame
.8ee5	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/charcheck.asm

.8ee6					CheckRightBracket:
.8ee6	b1 30		lda ($30),y			lda 	(codePtr),y
.8ee8	c8		iny				iny
.8ee9	c9 29		cmp #$29			cmp 	#KWD_RPAREN 						; exit if matches
.8eeb	d0 0f		bne $8efc			bne 	CNAFail
.8eed	60		rts				rts
.8eee					CheckComma:
.8eee	b1 30		lda ($30),y			lda 	(codePtr),y
.8ef0	c8		iny				iny
.8ef1	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 						; exit if matches
.8ef3	d0 07		bne $8efc			bne 	CNAFail
.8ef5	60		rts				rts
.8ef6					CheckNextA:
.8ef6	d1 30		cmp ($30),y			cmp 	(codePtr),y
.8ef8	d0 02		bne $8efc			bne 	CNAFail
.8efa	c8		iny				iny 								; skip character
.8efb	60		rts				rts 								; and exit
.8efc					CNAFail:
.8efc	4c a4 9f	jmp $9fa4			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/errors.asm

.8eff					ErrorHandler:
.8eff	a8		tay				tay 								; find the error text
.8f00	f0 49		beq $8f4b			beq 	_EHEnd
.8f02	a2 00		ldx #$00			ldx 	#0
.8f04	a9 bd		lda #$bd			lda 	#((ErrorText) & $FF)
.8f06	85 36		sta $36				sta 	0+zTemp0
.8f08	a9 9f		lda #$9f			lda 	#((ErrorText) >> 8)
.8f0a	85 37		sta $37				sta 	1+zTemp0
.8f0c					_EHFind:
.8f0c	88		dey				dey 								; keep looking through text
.8f0d	f0 0e		beq $8f1d			beq 	_EHFound
.8f0f					_EHFindZero:
.8f0f	b2 36		lda ($36)			lda 	(zTemp0) 					; find the next error
.8f11	e6 36		inc $36				inc 	zTemp0
.8f13	d0 02		bne $8f17			bne 	_EHFNoCarry
.8f15	e6 37		inc $37				inc 	zTemp0+1
.8f17					_EHFNoCarry:
.8f17	c9 00		cmp #$00			cmp 	#0
.8f19	d0 f4		bne $8f0f			bne 	_EHFindZero
.8f1b	80 ef		bra $8f0c			bra 	_EHFind
.8f1d					_EHFound:
.8f1d	a5 36		lda $36				lda 	zTemp0 						; print message
.8f1f	a6 37		ldx $37				ldx 	zTemp0+1
.8f21	20 58 8f	jsr $8f58			jsr 	PrintStringXA
.8f24	a0 01		ldy #$01			ldy 	#1 							; if line number zero don't print it
.8f26	b1 30		lda ($30),y			lda 	(codePtr),y
.8f28	d0 05		bne $8f2f			bne 	_EHAtMsg
.8f2a	c8		iny				iny
.8f2b	b1 30		lda ($30),y			lda 	(codePtr),y
.8f2d	f0 17		beq $8f46			beq 	_EHCREnd
.8f2f					_EHAtMsg:
.8f2f	a2 8f		ldx #$8f			ldx 	#_AtMsg >> 8 				; print " at "
.8f31	a9 4e		lda #$4e			lda 	#_AtMsg & $FF
.8f33	20 58 8f	jsr $8f58			jsr 	PrintStringXA
.8f36	a0 01		ldy #$01			ldy 	#1 							; line number into XA
.8f38	b1 30		lda ($30),y			lda 	(codePtr),y
.8f3a	48		pha				pha
.8f3b	c8		iny				iny
.8f3c	b1 30		lda ($30),y			lda 	(codePtr),y
.8f3e	aa		tax				tax
.8f3f	68		pla				pla
.8f40	20 6e 93	jsr $936e			jsr 	ConvertInt16 				; convert XA to string
.8f43	20 58 8f	jsr $8f58			jsr 	PrintStringXA 				; and print it.
.8f46					_EHCREnd:
.8f46	a9 0d		lda #$0d			lda 	#13 						; new line
.8f48	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8f4b					_EHEnd:
.8f4b	4c dd 83	jmp $83dd			jmp 	WarmStart
>8f4e	20 61 74 20 6c 69 6e 65		_AtMsg:	.text 	" at line ",0
>8f56	20 00
.8f58					PrintStringXA:
.8f58	5a		phy				phy
.8f59	86 37		stx $37				stx 	zTemp0+1
.8f5b	85 36		sta $36				sta 	zTemp0
.8f5d	a0 00		ldy #$00			ldy 	#0
.8f5f					_PSXALoop:
.8f5f	b1 36		lda ($36),y			lda 	(zTemp0),y
.8f61	f0 06		beq $8f69			beq 	_PSXAExit
.8f63	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8f66	c8		iny				iny
.8f67	80 f6		bra $8f5f			bra 	_PSXALoop
.8f69					_PSXAExit:
.8f69	7a		ply				ply
.8f6a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/compare.asm

.8f6b					UnaryTrue:
.8f6b	fa		plx				plx
.8f6c					ReturnTrue:
.8f6c	a9 01		lda #$01			lda 	#1  						; set to 1
.8f6e	20 28 9e	jsr $9e28			jsr 	NSMSetByte
.8f71	a9 80		lda #$80			lda 	#$80 						; set sign flag, so it is -1
.8f73	95 50		sta $50,x			sta 	NSStatus,x
.8f75	60		rts				rts
.8f76					UnaryFalse:
.8f76	fa		plx				plx
.8f77					ReturnFalse:
.8f77	4c 26 9e	jmp $9e26			jmp 	NSMSetZero 					; set it all to zero
.8f7a					BinaryCompareEqual:
.8f7a	fa		plx				plx
.8f7b	20 b6 8f	jsr $8fb6			jsr 	CompareBaseCode
.8f7e	c9 00		cmp #$00			cmp 	#0
.8f80	f0 ea		beq $8f6c			beq 	ReturnTrue
.8f82	80 f3		bra $8f77			bra 	ReturnFalse
.8f84					BinaryCompareLess:
.8f84	fa		plx				plx
.8f85	20 b6 8f	jsr $8fb6			jsr 	CompareBaseCode
.8f88	c9 ff		cmp #$ff			cmp 	#$FF
.8f8a	f0 e0		beq $8f6c			beq 	ReturnTrue
.8f8c	80 e9		bra $8f77			bra 	ReturnFalse
.8f8e					BinaryCompareGreater:
.8f8e	fa		plx				plx
.8f8f	20 b6 8f	jsr $8fb6			jsr 	CompareBaseCode
.8f92	c9 01		cmp #$01			cmp 	#1
.8f94	f0 d6		beq $8f6c			beq 	ReturnTrue
.8f96	80 df		bra $8f77			bra 	ReturnFalse
.8f98					BinaryCompareNotEqual:
.8f98	fa		plx				plx
.8f99	20 b6 8f	jsr $8fb6			jsr 	CompareBaseCode
.8f9c	c9 00		cmp #$00			cmp 	#0
.8f9e	d0 cc		bne $8f6c			bne 	ReturnTrue
.8fa0	80 d5		bra $8f77			bra 	ReturnFalse
.8fa2					BinaryCompareLessEqual:
.8fa2	fa		plx				plx
.8fa3	20 b6 8f	jsr $8fb6			jsr 	CompareBaseCode
.8fa6	c9 01		cmp #$01			cmp 	#1
.8fa8	d0 c2		bne $8f6c			bne 	ReturnTrue
.8faa	80 cb		bra $8f77			bra 	ReturnFalse
.8fac					BinaryCompareGreaterEqual:
.8fac	fa		plx				plx
.8fad	20 b6 8f	jsr $8fb6			jsr 	CompareBaseCode
.8fb0	c9 ff		cmp #$ff			cmp 	#$FF
.8fb2	d0 b8		bne $8f6c			bne 	ReturnTrue
.8fb4	80 c1		bra $8f77			bra 	ReturnFalse
.8fb6					CompareBaseCode:
.8fb6	20 c1 96	jsr $96c1			jsr 	DereferenceTopTwo 			; make both values if references.
.8fb9	b5 50		lda $50,x			lda 	NSStatus,x 					; check if either is a string.
.8fbb	15 51		ora $51,x			ora 	NSStatus+1,x
.8fbd	29 10		and #$10			and 	#NSTString
.8fbf	d0 37		bne $8ff8			bne 	_CBCString 					; if so do string code, which will check if both.
.8fc1	b5 78		lda $78,x			lda 	NSExponent,x 				; check both are integers
.8fc3	15 79		ora $79,x			ora 	NSExponent+1,x
.8fc5	d0 34		bne $8ffb			bne 	_CBCFloat
.8fc7	b5 50		lda $50,x			lda 	NSStatus,x
.8fc9	15 51		ora $51,x			ora 	NSStatus+1,x
.8fcb	29 08		and #$08			and 	#NSTFloat
.8fcd	d0 2c		bne $8ffb			bne 	_CBCFloat
.8fcf	20 fe 8f	jsr $8ffe			jsr 	CompareFixMinusZero 		; fix up -0 just in cases.
.8fd2	e8		inx				inx
.8fd3	20 fe 8f	jsr $8ffe			jsr 	CompareFixMinusZero
.8fd6	ca		dex				dex
.8fd7	b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs different ?
.8fd9	55 51		eor $51,x			eor 	NSStatus+1,x
.8fdb	10 0a		bpl $8fe7			bpl 	_CDCSameSign
.8fdd	b5 50		lda $50,x			lda 	NSStatus,x 					; if first one is -ve
.8fdf	30 14		bmi $8ff5			bmi 	_CBCLess 					; return $FF
.8fe1					_CBCGreater:
.8fe1	a9 01		lda #$01			lda 	#1
.8fe3	60		rts				rts
.8fe4					_CBCEqual:
.8fe4	a9 00		lda #$00			lda 	#0
.8fe6	60		rts				rts
.8fe7					_CDCSameSign:
.8fe7	20 13 92	jsr $9213			jsr 	SubTopTwoStack 				; unsigned subtract
.8fea	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; or the mantissa together
.8fed	f0 f5		beq $8fe4			beq 	_CBCEqual 					; -0 == 0
.8fef	b5 70		lda $70,x			lda 	NSMantissa3,x 				; sign of the result. if +ve return $01 else return $FF
.8ff1	55 51		eor $51,x			eor 	NSStatus+1,x 				; however if both were -ve this is inverted
.8ff3	10 ec		bpl $8fe1			bpl 	_CBCGreater
.8ff5					_CBCLess:
.8ff5	a9 ff		lda #$ff			lda 	#$FF
.8ff7	60		rts				rts
.8ff8					_CBCString:
.8ff8	4c 84 91	jmp $9184			jmp 	CompareStrings
.8ffb					_CBCFloat:
.8ffb	4c ce 94	jmp $94ce			jmp 	CompareFloat
.8ffe					CompareFixMinusZero:
.8ffe	20 48 9e	jsr $9e48			jsr 	NSMIsZero
.9001	d0 02		bne $9005			bne 	_CFXMZNotZero
.9003	74 50		stz $50,x			stz 	NSStatus,x
.9005					_CFXMZNotZero:
.9005	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/concat.asm

.9006					StringConcat:
.9006	b5 50		lda $50,x			lda 	NSStatus,x 					; check both strings
.9008	35 51		and $51,x			and 	NSStatus+1,x
.900a	29 18		and #$18			and 	#NSBTypeMask
.900c	c9 10		cmp #$10			cmp 	#NSTString
.900e	d0 50		bne $9060			bne		_SCType
.9010	64 38		stz $38				stz 	zTemp1 						; counting total length
.9012	e8		inx				inx
.9013	20 31 90	jsr $9031			jsr 	_SCSetupZ0 					; setup for second
.9016	20 3a 90	jsr $903a			jsr 	_SCLengthZ0 				; length for second
.9019	ca		dex				dex
.901a	20 31 90	jsr $9031			jsr 	_SCSetupZ0 					; setup for first
.901d	20 3a 90	jsr $903a			jsr 	_SCLengthZ0 				; length for first
.9020	a5 38		lda $38				lda 	zTemp1 						; allocate memory using total.
.9022	20 b8 a7	jsr $a7b8			jsr 	StringTempAllocate
.9025	20 51 90	jsr $9051			jsr 	_SCCopy 					; copy first out, using zTemp0 from above
.9028	e8		inx				inx
.9029	20 31 90	jsr $9031			jsr 	_SCSetupZ0 					; copy second out
.902c	20 51 90	jsr $9051			jsr 	_SCCopy
.902f	ca		dex				dex
.9030	60		rts				rts
.9031					_SCSetupZ0:
.9031	b5 58		lda $58,x			lda 	NSMantissa0,x
.9033	85 36		sta $36				sta 	zTemp0
.9035	b5 60		lda $60,x			lda 	NSMantissa1,x
.9037	85 37		sta $37				sta 	zTemp0+1
.9039	60		rts				rts
.903a					_SCLengthZ0:
.903a	5a		phy				phy
.903b	a0 00		ldy #$00			ldy 	#0
.903d					_SCLenLoop:
.903d	b1 36		lda ($36),y			lda 	(zTemp0),y
.903f	f0 0e		beq $904f			beq 	_SCLExit
.9041	c8		iny				iny
.9042	e6 38		inc $38				inc 	zTemp1
.9044	a5 38		lda $38				lda	 	zTemp1 						; check string too long.
.9046	c9 fd		cmp #$fd			cmp 	#253
.9048	d0 f3		bne $903d			bne		_SCLenLoop
.904a	a9 09		lda #$09		lda	#9
.904c	4c ff 8e	jmp $8eff		jmp	ErrorHandler
.904f					_SCLExit:
.904f	7a		ply				ply
.9050	60		rts				rts
.9051					_SCCopy:
.9051	5a		phy				phy
.9052	a0 00		ldy #$00			ldy 	#0
.9054					_SCCopyLoop:
.9054	b1 36		lda ($36),y			lda 	(zTemp0),y
.9056	f0 06		beq $905e			beq 	_SCCExit
.9058	20 f1 a7	jsr $a7f1			jsr 	StringTempWrite
.905b	c8		iny				iny
.905c	80 f6		bra $9054			bra 	_SCCopyLoop
.905e					_SCCExit:
.905e	7a		ply				ply
.905f	60		rts				rts
.9060					_SCType:
.9060	4c ae 9f	jmp $9fae			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/divide.asm

.9063					IntegerDivide:
.9063	fa		plx				plx
.9064	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9066	15 51		ora $51,x			ora 	NSStatus+1,x
.9068	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9069	0a		asl a				asl 	a
.906a	10 05		bpl $9071			bpl 	_NotRef
.906c	48		pha				pha
.906d	20 c1 96	jsr $96c1			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9070	68		pla				pla
.9071					_NotRef:
.9071	0a		asl a				asl 	a
.9072	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9074	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9076	15 79		ora $79,x			ora 	NSExponent+1,x
.9078	f0 03		beq $907d			beq 	_IntegerCode 				; if clear, then we have two integers
.907a	4c ae 9f	jmp $9fae			jmp 	TypeError 					; anything else, type mismatch.
.907d					_IntegerCode:
.907d	20 97 90	jsr $9097			jsr 	CheckDivideZero 			; do div zero check
.9080	20 c9 90	jsr $90c9			jsr 	Int32Divide 				; do the division
.9083	20 7a 91	jsr $917a			jsr 	CalculateSign 				; calculate result sign
.9086					NSMCopyPlusTwoToZero:
.9086	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.9088	95 58		sta $58,x			sta 	NSMantissa0,x
.908a	b5 62		lda $62,x			lda 	NSMantissa1+2,x
.908c	95 60		sta $60,x			sta 	NSMantissa1,x
.908e	b5 6a		lda $6a,x			lda 	NSMantissa2+2,x
.9090	95 68		sta $68,x			sta 	NSMantissa2,x
.9092	b5 72		lda $72,x			lda 	NSMantissa3+2,x
.9094	95 70		sta $70,x			sta 	NSMantissa3,x
.9096	60		rts				rts
.9097					CheckDivideZero:
.9097	e8		inx				inx
.9098	20 48 9e	jsr $9e48			jsr 	NSMIsZero
.909b	f0 02		beq $909f			beq 	_CDVError
.909d	ca		dex				dex
.909e	60		rts				rts
.909f					_CDVError:
.909f	a9 03		lda #$03		lda	#3
.90a1	4c ff 8e	jmp $8eff		jmp	ErrorHandler
.90a4					IntegerModulus:
.90a4	fa		plx				plx
.90a5	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.90a7	15 51		ora $51,x			ora 	NSStatus+1,x
.90a9	0a		asl a				asl 	a 							; shift reference bit into sign bit
.90aa	0a		asl a				asl 	a
.90ab	10 05		bpl $90b2			bpl 	_NotRef
.90ad	48		pha				pha
.90ae	20 c1 96	jsr $96c1			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.90b1	68		pla				pla
.90b2					_NotRef:
.90b2	0a		asl a				asl 	a
.90b3	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.90b5	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.90b7	15 79		ora $79,x			ora 	NSExponent+1,x
.90b9	f0 03		beq $90be			beq 	_IntegerCode 				; if clear, then we have two integers
.90bb	4c ae 9f	jmp $9fae			jmp 	TypeError 					; anything else, type mismatch.
.90be					_IntegerCode:
.90be					IntegerModulusNoCheck:
.90be	20 97 90	jsr $9097			jsr 	CheckDivideZero 			; do div zero check
.90c1	20 c9 90	jsr $90c9			jsr 	Int32Divide 				; do the division
.90c4	16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.90c6	56 50		lsr $50,x			lsr 	NSStatus,x
.90c8	60		rts				rts
.90c9					Int32Divide:
.90c9	48		pha				pha 								; save AXY
.90ca	5a		phy				phy
.90cb	20 09 9e	jsr $9e09			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.90ce	20 22 9e	jsr $9e22			jsr 	NSMSetZeroMantissaOnly 		; set S[X] to zero
.90d1	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.90d3					_I32DivideLoop:
.90d3	e8		inx				inx
.90d4	e8		inx				inx
.90d5	20 35 9e	jsr $9e35			jsr 	NSMShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.90d8	ca		dex				dex
.90d9	ca		dex				dex
.90da	20 36 9e	jsr $9e36			jsr 	NSMRotateLeft
.90dd	20 08 91	jsr $9108			jsr 	DivideCheckSubtract 		; check if subtract possible
.90e0	90 02		bcc $90e4			bcc 	_I32DivideNoCarryIn
.90e2	f6 5a		inc $5a,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.90e4					_I32DivideNoCarryIn:
.90e4	88		dey				dey 								; loop round till division completed.
.90e5	d0 ec		bne $90d3			bne 	_I32DivideLoop
.90e7	7a		ply				ply 								; restore AXY and exit
.90e8	68		pla				pla
.90e9	60		rts				rts
.90ea					Int32ShiftDivide:
.90ea	48		pha				pha 								; save AY
.90eb	5a		phy				phy
.90ec	e8		inx				inx 								; clear S[X+2]
.90ed	e8		inx				inx
.90ee	20 26 9e	jsr $9e26			jsr 	NSMSetZero
.90f1	ca		dex				dex
.90f2	ca		dex				dex
.90f3	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.90f5					_I32SDLoop:
.90f5	20 08 91	jsr $9108			jsr 	DivideCheckSubtract 		; check if subtract possible
.90f8	e8		inx				inx
.90f9	e8		inx				inx
.90fa	20 36 9e	jsr $9e36			jsr 	NSMRotateLeft				; shift 64 bit FPA left, rotating carry in
.90fd	ca		dex				dex
.90fe	ca		dex				dex
.90ff	20 36 9e	jsr $9e36			jsr 	NSMRotateLeft
.9102	88		dey				dey 	 							; do 31 times
.9103	d0 f0		bne $90f5			bne 	_I32SDLoop
.9105	7a		ply				ply 								; restore AY and exit
.9106	68		pla				pla
.9107	60		rts				rts
.9108					DivideCheckSubtract:
.9108	20 13 92	jsr $9213			jsr 	SubTopTwoStack 				; subtract Stack[X+1] from Stack[X+0]
.910b	b0 04		bcs $9111			bcs 	_DCSExit 					; if carry set, then could do, exit
.910d	20 f9 91	jsr $91f9			jsr 	AddTopTwoStack 				; add it back in
.9110	18		clc				clc 								; and return False
.9111					_DCSExit:
.9111	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/multiply.asm

.9112					MulInteger:
.9112	fa		plx				plx
.9113	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9115	15 51		ora $51,x			ora 	NSStatus+1,x
.9117	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9118	0a		asl a				asl 	a
.9119	10 05		bpl $9120			bpl 	_NotRef
.911b	48		pha				pha
.911c	20 c1 96	jsr $96c1			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.911f	68		pla				pla
.9120					_NotRef:
.9120	0a		asl a				asl 	a 							; put MSB of type into A:7
.9121	30 09		bmi $912c			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9123	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9125	15 79		ora $79,x			ora 	NSExponent+1,x
.9127	f0 06		beq $912f			beq 	_IntegerCode 				; if clear, then we have two integers
.9129	4c 90 95	jmp $9590			jmp 	FloatingPointMultiply 							; otherwise at least one float.
.912c					_StringData:
.912c	4c b8 9f	jmp $9fb8			jmp 	NotDoneError							; at least one string - don't know both are strings.
.912f					_IntegerCode:
.912f	20 3c 91	jsr $913c			jsr 	MultiplyShort
.9132	c9 00		cmp #$00			cmp 	#0
.9134	f0 05		beq $913b			beq 	_MIExit
.9136	a9 04		lda #$04		lda	#4
.9138	4c ff 8e	jmp $8eff		jmp	ErrorHandler
.913b					_MIExit:
.913b	60		rts				rts
.913c					MultiplyShort:
.913c	5a		phy				phy 								; save Y
.913d	20 09 9e	jsr $9e09			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.9140	20 22 9e	jsr $9e22			jsr 	NSMSetZeroMantissaOnly 		; set mantissa S[X] to zero
.9143	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.9145					_I32MLoop:
.9145	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.9147	15 62		ora $62,x			ora 	NSMantissa1+2,x
.9149	15 6a		ora $6a,x			ora 	NSMantissa2+2,x
.914b	15 72		ora $72,x			ora 	NSMantissa3+2,x
.914d	f0 25		beq $9174			beq 	_I32MExit 					; exit if zero
.914f	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.9151	29 01		and #$01			and 	#1
.9153	f0 0d		beq $9162			beq 	_I32MNoAdd
.9155	20 f9 91	jsr $91f9			jsr 	AddTopTwoStack 				; if so add S[X+1] to S[X+0]
.9158	b5 70		lda $70,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.915a	10 06		bpl $9162			bpl 	_I32MNoAdd
.915c					_I32ShiftRight:
.915c	20 3f 9e	jsr $9e3f			jsr 	NSMShiftRight 				; shift S[X] right
.915f	c8		iny				iny 								; increment shift count
.9160	80 09		bra $916b			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.9162					_I32MNoAdd:
.9162	34 71		bit $71,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.9164	70 f6		bvs $915c			bvs 	_I32ShiftRight 				; instead.
.9166	e8		inx				inx
.9167	20 35 9e	jsr $9e35			jsr 	NSMShiftLeft 				; shift additive S[X+1] left
.916a	ca		dex				dex
.916b					_I32MShiftUpper:
.916b	e8		inx				inx 								; shift S[X+2] right
.916c	e8		inx				inx
.916d	20 3f 9e	jsr $9e3f			jsr 	NSMShiftRight
.9170	ca		dex				dex
.9171	ca		dex				dex
.9172	80 d1		bra $9145			bra 	_I32MLoop 					; try again.
.9174					_I32MExit:
.9174	20 7a 91	jsr $917a			jsr 	CalculateSign
.9177	98		tya				tya 								; shift in A
.9178	7a		ply				ply 								; restore Y and exit
.9179	60		rts				rts
.917a					CalculateSign:
.917a	b5 50		lda $50,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.917c	16 50		asl $50,x			asl 	NSStatus,x 					; shift result left
.917e	55 51		eor $51,x			eor 	NSStatus+1,x
.9180	0a		asl a				asl 	a 							; shift bit 7 into carry
.9181	76 50		ror $50,x			ror 	NSStatus,x 					; shift right into status byte.
.9183	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/scompare.asm

.9184					CompareStrings:
.9184	b5 50		lda $50,x			lda 	NSStatus,x 					; check both are strings
.9186	35 51		and $51,x			and 	NSStatus+1,x
.9188	29 10		and #$10			and 	#NSBIsString
.918a	f0 28		beq $91b4			beq 	_CSTypeError
.918c	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy string addresses to zTemp0/1
.918e	85 36		sta $36				sta 	zTemp0
.9190	b5 60		lda $60,x			lda 	NSMantissa1,x
.9192	85 37		sta $37				sta 	zTemp0+1
.9194	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9196	85 38		sta $38				sta 	zTemp1
.9198	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.919a	85 39		sta $39				sta 	zTemp1+1
.919c	5a		phy				phy 								; save Y so we can access strings
.919d	a0 ff		ldy #$ff			ldy 	#$FF 						; -1 for pre increment.
.919f					_CSLoop:
.919f	c8		iny				iny
.91a0	b1 36		lda ($36),y			lda 	(zTemp0),y 					; check if they are the same
.91a2	d1 38		cmp ($38),y			cmp 	(zTemp1),y
.91a4	d0 06		bne $91ac			bne 	_CSDifferent
.91a6	c9 00		cmp #$00			cmp 	#0 							; reached end ?
.91a8	d0 f5		bne $919f			bne 	_CSLoop 					; still comparing
.91aa					_CSExit:
.91aa	7a		ply				ply 								; reached end, return zero in A from EOS
.91ab	60		rts				rts
.91ac					_CSDifferent:
.91ac	a9 ff		lda #$ff			lda 	#255 						; if < return $FF
.91ae	90 fa		bcc $91aa			bcc		_CSExit
.91b0	a9 01		lda #$01			lda 	#1 							; otherwise return 1.
.91b2	80 f6		bra $91aa			bra 	_CSExit
.91b4					_CSTypeError:
.91b4	4c ae 9f	jmp $9fae			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/shifts.asm

.91b7					ShiftLeft:
.91b7	38		sec				sec 								; common code, carry determines which way.
.91b8	80 01		bra $91bb			bra 	ShiftMain
.91ba					ShiftRight:
.91ba	18		clc				clc
.91bb					ShiftMain:
.91bb	fa		plx				plx 								; restore X
.91bc	08		php				php 								; save direction
.91bd	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.91bf	15 51		ora $51,x			ora 	NSStatus+1,x
.91c1	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91c2	0a		asl a				asl 	a
.91c3	10 05		bpl $91ca			bpl 	_NotRef
.91c5	48		pha				pha
.91c6	20 c1 96	jsr $96c1			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91c9	68		pla				pla
.91ca					_NotRef:
.91ca	0a		asl a				asl 	a
.91cb	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.91cd	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91cf	15 79		ora $79,x			ora 	NSExponent+1,x
.91d1	f0 03		beq $91d6			beq 	_IntegerCode 				; if clear, then we have two integers
.91d3	4c ae 9f	jmp $9fae			jmp 	TypeError 					; anything else, type mismatch.
.91d6					_IntegerCode:
.91d6	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; check number < 32
.91d8	29 e0		and #$e0			and 	#$E0
.91da	15 61		ora $61,x			ora 	NSMantissa1+1,x
.91dc	15 69		ora $69,x			ora 	NSMantissa2+1,x
.91de	15 71		ora $71,x			ora 	NSMantissa3+1,x
.91e0	d0 12		bne $91f4			bne 	_SMExit0 					; if >= 32 it will always return zero.
.91e2					_SMLoop:
.91e2	d6 59		dec $59,x			dec 	NSMantissa0+1,x 			; predecrement, could do << 0
.91e4	30 11		bmi $91f7			bmi 	_SMExit 					; exit if done.
.91e6	28		plp				plp 								; restore direction setting
.91e7	08		php				php
.91e8	90 05		bcc $91ef			bcc 	_SMRight
.91ea	20 35 9e	jsr $9e35			jsr 	NSMShiftLeft 				; shift left if CS
.91ed	80 f3		bra $91e2			bra 	_SMLoop
.91ef					_SMRight:
.91ef	20 3f 9e	jsr $9e3f			jsr 	NSMShiftRight 				; shift right if CC
.91f2	80 ee		bra $91e2			bra 	_SMLoop
.91f4					_SMExit0:
.91f4	20 26 9e	jsr $9e26			jsr 	NSMSetZero 					; return zero.
.91f7					_SMExit:
.91f7	28		plp				plp 								; throw direction
.91f8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/simple.asm

.91f9					AddTopTwoStack:
.91f9	18		clc				clc
.91fa	b5 58		lda $58,x			lda		NSMantissa0,x
.91fc	75 59		adc $59,x			adc 		NSMantissa0+1,x
.91fe	95 58		sta $58,x			sta 	NSMantissa0,x
.9200	b5 60		lda $60,x			lda		NSMantissa1,x
.9202	75 61		adc $61,x			adc 		NSMantissa1+1,x
.9204	95 60		sta $60,x			sta 	NSMantissa1,x
.9206	b5 68		lda $68,x			lda		NSMantissa2,x
.9208	75 69		adc $69,x			adc 		NSMantissa2+1,x
.920a	95 68		sta $68,x			sta 	NSMantissa2,x
.920c	b5 70		lda $70,x			lda		NSMantissa3,x
.920e	75 71		adc $71,x			adc 		NSMantissa3+1,x
.9210	95 70		sta $70,x			sta 	NSMantissa3,x
.9212	60		rts				rts
.9213					SubTopTwoStack:
.9213	38		sec				sec
.9214	b5 58		lda $58,x			lda		NSMantissa0,x
.9216	f5 59		sbc $59,x			sbc 		NSMantissa0+1,x
.9218	95 58		sta $58,x			sta 	NSMantissa0,x
.921a	b5 60		lda $60,x			lda		NSMantissa1,x
.921c	f5 61		sbc $61,x			sbc 		NSMantissa1+1,x
.921e	95 60		sta $60,x			sta 	NSMantissa1,x
.9220	b5 68		lda $68,x			lda		NSMantissa2,x
.9222	f5 69		sbc $69,x			sbc 		NSMantissa2+1,x
.9224	95 68		sta $68,x			sta 	NSMantissa2,x
.9226	b5 70		lda $70,x			lda		NSMantissa3,x
.9228	f5 71		sbc $71,x			sbc 		NSMantissa3+1,x
.922a	95 70		sta $70,x			sta 	NSMantissa3,x
.922c	60		rts				rts
.922d					AddInteger:
.922d	fa		plx				plx
.922e	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9230	15 51		ora $51,x			ora 	NSStatus+1,x
.9232	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9233	0a		asl a				asl 	a
.9234	10 05		bpl $923b			bpl 	_NotRef
.9236	48		pha				pha
.9237	20 c1 96	jsr $96c1			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.923a	68		pla				pla
.923b					_NotRef:
.923b	0a		asl a				asl 	a 							; put MSB of type into A:7
.923c	30 09		bmi $9247			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.923e	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9240	15 79		ora $79,x			ora 	NSExponent+1,x
.9242	f0 06		beq $924a			beq 	_IntegerCode 				; if clear, then we have two integers
.9244	4c 40 94	jmp $9440			jmp 	FloatingPointAdd 							; otherwise at least one float.
.9247					_StringData:
.9247	4c 06 90	jmp $9006			jmp 	StringConcat							; at least one string - don't know both are strings.
.924a					_IntegerCode:
.924a					AddCode:
.924a	b5 50		lda $50,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.924c	55 51		eor $51,x			eor 	NSStatus+1,x
.924e	10 a9		bpl $91f9			bpl 	AddTopTwoStack
.9250	20 13 92	jsr $9213			jsr 	SubTopTwoStack 				; do a physical subtraction
.9253	34 70		bit $70,x			bit 	NSMantissa3,x 				; result is +ve, okay
.9255	10 07		bpl $925e			bpl 	_AddExit
.9257	b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign is that of 2nd value
.9259	95 50		sta $50,x			sta 	NSStatus,x
.925b	20 ef 9d	jsr $9def			jsr 	NSMNegateMantissa 			; negate the mantissa and exit
.925e					_AddExit:
.925e	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; check for -0
.9261	d0 02		bne $9265			bne 	_AddNonZero
.9263	74 50		stz $50,x			stz 	NSStatus,x
.9265					_AddNonZero:
.9265	60		rts				rts
.9266					SubInteger:
.9266	fa		plx				plx
.9267	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9269	15 51		ora $51,x			ora 	NSStatus+1,x
.926b	0a		asl a				asl 	a 							; shift reference bit into sign bit
.926c	0a		asl a				asl 	a
.926d	10 05		bpl $9274			bpl 	_NotRef
.926f	48		pha				pha
.9270	20 c1 96	jsr $96c1			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9273	68		pla				pla
.9274					_NotRef:
.9274	0a		asl a				asl 	a 							; put MSB of type into A:7
.9275	30 09		bmi $9280			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9277	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9279	15 79		ora $79,x			ora 	NSExponent+1,x
.927b	f0 06		beq $9283			beq 	_IntegerCode 				; if clear, then we have two integers
.927d	4c 45 94	jmp $9445			jmp 	FloatingPointSub 							; otherwise at least one float.
.9280					_StringData:
.9280	4c b8 9f	jmp $9fb8			jmp 	NotDoneError							; at least one string - don't know both are strings.
.9283					_IntegerCode:
.9283	b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate the second value.
.9285	49 80		eor #$80			eor 	#$80
.9287	95 51		sta $51,x			sta 	NSStatus+1,x
.9289	80 bf		bra $924a			bra 	AddCode 					; and do the same code as add.
.928b					AndInteger:
.928b	fa		plx				plx
.928c	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.928e	15 51		ora $51,x			ora 	NSStatus+1,x
.9290	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9291	0a		asl a				asl 	a
.9292	10 05		bpl $9299			bpl 	_NotRef
.9294	48		pha				pha
.9295	20 c1 96	jsr $96c1			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9298	68		pla				pla
.9299					_NotRef:
.9299	0a		asl a				asl 	a
.929a	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.929c	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.929e	15 79		ora $79,x			ora 	NSExponent+1,x
.92a0	f0 03		beq $92a5			beq 	_IntegerCode 				; if clear, then we have two integers
.92a2	4c ae 9f	jmp $9fae			jmp 	TypeError 					; anything else, type mismatch.
.92a5					_IntegerCode:
.92a5	b5 58		lda $58,x			lda		NSMantissa0,x
.92a7	35 59		and $59,x			and 		NSMantissa0+1,x
.92a9	95 58		sta $58,x			sta 	NSMantissa0,x
.92ab	b5 60		lda $60,x			lda		NSMantissa1,x
.92ad	35 61		and $61,x			and 		NSMantissa1+1,x
.92af	95 60		sta $60,x			sta 	NSMantissa1,x
.92b1	b5 68		lda $68,x			lda		NSMantissa2,x
.92b3	35 69		and $69,x			and 		NSMantissa2+1,x
.92b5	95 68		sta $68,x			sta 	NSMantissa2,x
.92b7	b5 70		lda $70,x			lda		NSMantissa3,x
.92b9	35 71		and $71,x			and 		NSMantissa3+1,x
.92bb	95 70		sta $70,x			sta 	NSMantissa3,x
.92bd	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.92bf	60		rts				rts
.92c0					OraInteger:
.92c0	fa		plx				plx
.92c1	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.92c3	15 51		ora $51,x			ora 	NSStatus+1,x
.92c5	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92c6	0a		asl a				asl 	a
.92c7	10 05		bpl $92ce			bpl 	_NotRef
.92c9	48		pha				pha
.92ca	20 c1 96	jsr $96c1			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92cd	68		pla				pla
.92ce					_NotRef:
.92ce	0a		asl a				asl 	a
.92cf	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.92d1	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92d3	15 79		ora $79,x			ora 	NSExponent+1,x
.92d5	f0 03		beq $92da			beq 	_IntegerCode 				; if clear, then we have two integers
.92d7	4c ae 9f	jmp $9fae			jmp 	TypeError 					; anything else, type mismatch.
.92da					_IntegerCode:
.92da	b5 58		lda $58,x			lda		NSMantissa0,x
.92dc	15 59		ora $59,x			ora 		NSMantissa0+1,x
.92de	95 58		sta $58,x			sta 	NSMantissa0,x
.92e0	b5 60		lda $60,x			lda		NSMantissa1,x
.92e2	15 61		ora $61,x			ora 		NSMantissa1+1,x
.92e4	95 60		sta $60,x			sta 	NSMantissa1,x
.92e6	b5 68		lda $68,x			lda		NSMantissa2,x
.92e8	15 69		ora $69,x			ora 		NSMantissa2+1,x
.92ea	95 68		sta $68,x			sta 	NSMantissa2,x
.92ec	b5 70		lda $70,x			lda		NSMantissa3,x
.92ee	15 71		ora $71,x			ora 		NSMantissa3+1,x
.92f0	95 70		sta $70,x			sta 	NSMantissa3,x
.92f2	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.92f4	60		rts				rts
.92f5					EorInteger:
.92f5	fa		plx				plx
.92f6	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.92f8	15 51		ora $51,x			ora 	NSStatus+1,x
.92fa	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92fb	0a		asl a				asl 	a
.92fc	10 05		bpl $9303			bpl 	_NotRef
.92fe	48		pha				pha
.92ff	20 c1 96	jsr $96c1			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9302	68		pla				pla
.9303					_NotRef:
.9303	0a		asl a				asl 	a
.9304	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9306	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9308	15 79		ora $79,x			ora 	NSExponent+1,x
.930a	f0 03		beq $930f			beq 	_IntegerCode 				; if clear, then we have two integers
.930c	4c ae 9f	jmp $9fae			jmp 	TypeError 					; anything else, type mismatch.
.930f					_IntegerCode:
.930f	b5 58		lda $58,x			lda		NSMantissa0,x
.9311	55 59		eor $59,x			eor 		NSMantissa0+1,x
.9313	95 58		sta $58,x			sta 	NSMantissa0,x
.9315	b5 60		lda $60,x			lda		NSMantissa1,x
.9317	55 61		eor $61,x			eor 		NSMantissa1+1,x
.9319	95 60		sta $60,x			sta 	NSMantissa1,x
.931b	b5 68		lda $68,x			lda		NSMantissa2,x
.931d	55 69		eor $69,x			eor 		NSMantissa2+1,x
.931f	95 68		sta $68,x			sta 	NSMantissa2,x
.9321	b5 70		lda $70,x			lda		NSMantissa3,x
.9323	55 71		eor $71,x			eor 		NSMantissa3+1,x
.9325	95 70		sta $70,x			sta 	NSMantissa3,x
.9327	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.9329	60		rts				rts
.932a					WordIndirect:
.932a	fa		plx				plx
.932b	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.932d	15 51		ora $51,x			ora 	NSStatus+1,x
.932f	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9330	0a		asl a				asl 	a
.9331	10 05		bpl $9338			bpl 	_NotRef
.9333	48		pha				pha
.9334	20 c1 96	jsr $96c1			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9337	68		pla				pla
.9338					_NotRef:
.9338	0a		asl a				asl 	a
.9339	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.933b	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.933d	15 79		ora $79,x			ora 	NSExponent+1,x
.933f	f0 03		beq $9344			beq 	_IntegerCode 				; if clear, then we have two integers
.9341	4c ae 9f	jmp $9fae			jmp 	TypeError 					; anything else, type mismatch.
.9344					_IntegerCode:
.9344	20 4a 92	jsr $924a			jsr 	AddCode 					; add the two values
.9347	a9 22		lda #$22			lda 	#NSBIsReference+2 			; make a 2 byte reference
.9349	95 50		sta $50,x			sta 	NSStatus,x
.934b	60		rts				rts
.934c					ByteIndirect:
.934c	fa		plx				plx
.934d	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.934f	15 51		ora $51,x			ora 	NSStatus+1,x
.9351	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9352	0a		asl a				asl 	a
.9353	10 05		bpl $935a			bpl 	_NotRef
.9355	48		pha				pha
.9356	20 c1 96	jsr $96c1			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9359	68		pla				pla
.935a					_NotRef:
.935a	0a		asl a				asl 	a
.935b	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.935d	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.935f	15 79		ora $79,x			ora 	NSExponent+1,x
.9361	f0 03		beq $9366			beq 	_IntegerCode 				; if clear, then we have two integers
.9363	4c ae 9f	jmp $9fae			jmp 	TypeError 					; anything else, type mismatch.
.9366					_IntegerCode:
.9366	20 4a 92	jsr $924a			jsr 	AddCode 					; add the two values
.9369	a9 21		lda #$21			lda 	#NSBIsReference+1 			; make a 1 byte reference
.936b	95 50		sta $50,x			sta 	NSStatus,x
.936d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/tostring.asm

.936e					ConvertInt16:
.936e	85 58		sta $58				sta 	NSMantissa0 				; set up as 32 bit conversion
.9370	86 60		stx $60				stx 	NSMantissa1
.9372	64 68		stz $68				stz 	NSMantissa2
.9374	64 70		stz $70				stz 	NSMantissa3
.9376	64 50		stz $50				stz 	NSStatus 					; positive integer
.9378	a2 00		ldx #$00			ldx 	#0 							; stack level
.937a	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.937c	80 00		bra $937e			bra 	ConvertInt32
.937e					ConvertInt32:
.937e	5a		phy				phy
.937f	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.9381	24 50		bit $50				bit 	NSStatus 					; output a - if not negative.
.9383	10 08		bpl $938d			bpl 	_CI32NotNeg
.9385	48		pha				pha
.9386	a9 2d		lda #$2d			lda 	#'-'
.9388	99 27 06	sta $0627,y			sta 	NumberBuffer,y
.938b	c8		iny				iny
.938c	68		pla				pla
.938d					_CI32NotNeg:
.938d	20 9b 93	jsr $939b			jsr 	_CI32DivideConvert 			; recursive conversion
.9390	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.9392	99 27 06	sta $0627,y			sta 	NumberBuffer,y
.9395	7a		ply				ply
.9396	a2 06		ldx #$06			ldx 	#NumberBuffer >> 8 			; return address in XA
.9398	a9 27		lda #$27			lda 	#NumberBuffer & $FF
.939a	60		rts				rts
.939b					_CI32DivideConvert:
.939b	e8		inx				inx 								; write to next slot up
.939c	20 28 9e	jsr $9e28			jsr 	NSMSetByte 		 			; write the base out.
.939f	ca		dex				dex
.93a0	20 c9 90	jsr $90c9			jsr 	Int32Divide 				; divide
.93a3	b5 58		lda $58,x			lda 	NSMantissa0,x 				; save remainder
.93a5	48		pha				pha
.93a6	20 86 90	jsr $9086			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.93a9	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; is it zero ?
.93ac	f0 05		beq $93b3			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.93ae	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.93b0	20 9b 93	jsr $939b			jsr 	_CI32DivideConvert 			; and recusrively call.
.93b3					_CI32NoRecurse:
.93b3	68		pla				pla 								; remainder
.93b4	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.93b6	90 02		bcc $93ba			bcc 	_CI32NotHex
.93b8	69 26		adc #$26			adc 	#6+32
.93ba					_CI32NotHex:
.93ba	69 30		adc #$30			adc 	#48
.93bc	99 27 06	sta $0627,y			sta 	NumberBuffer,y 				; write out and exit
.93bf	c8		iny				iny
.93c0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/expression.asm


;******  Processing file: ./common/expressions/../generated/precedence.dat

.93c1					PrecedenceLevel:
>93c1	04					.byte	 4	; $00 <<
>93c2	02					.byte	 2	; $01 <=
>93c3	02					.byte	 2	; $02 <>
>93c4	00					.byte	 0	; $03 !!3
>93c5	00					.byte	 0	; $04 ><
>93c6	02					.byte	 2	; $05 >=
>93c7	04					.byte	 4	; $06 >>
>93c8	00					.byte	 0	; $07 !!7
>93c9	00					.byte	 0	; $08 !!8
>93ca	00					.byte	 0	; $09 !!9
>93cb	00					.byte	 0	; $0a !!10
>93cc	00					.byte	 0	; $0b !!11
>93cd	00					.byte	 0	; $0c !!12
>93ce	00					.byte	 0	; $0d !!13
>93cf	00					.byte	 0	; $0e !!14
>93d0	00					.byte	 0	; $0f !!15
>93d1	00					.byte	 0	; $10 @
>93d2	00					.byte	 0	; $11 !!17
>93d3	00					.byte	 0	; $12 !!18
>93d4	00					.byte	 0	; $13 [
>93d5	04					.byte	 4	; $14 \
>93d6	00					.byte	 0	; $15 ]
>93d7	01					.byte	 1	; $16 ^
>93d8	00					.byte	 0	; $17 _
>93d9	00					.byte	 0	; $18 `
>93da	00					.byte	 0	; $19 !!25
>93db	00					.byte	 0	; $1a !!26
>93dc	00					.byte	 0	; $1b {
>93dd	01					.byte	 1	; $1c |
>93de	00					.byte	 0	; $1d }
>93df	00					.byte	 0	; $1e ~
>93e0	00					.byte	 0	; $1f [7m<7F>[m
>93e1	00					.byte	 0	; $20
>93e2	05					.byte	 5	; $21 !
>93e3	00					.byte	 0	; $22 "
>93e4	00					.byte	 0	; $23 #
>93e5	05					.byte	 5	; $24 $
>93e6	04					.byte	 4	; $25 %
>93e7	01					.byte	 1	; $26 &
>93e8	00					.byte	 0	; $27 '
>93e9	00					.byte	 0	; $28 (
>93ea	00					.byte	 0	; $29 )
>93eb	04					.byte	 4	; $2a *
>93ec	03					.byte	 3	; $2b +
>93ed	00					.byte	 0	; $2c ,
>93ee	03					.byte	 3	; $2d -
>93ef	00					.byte	 0	; $2e .
>93f0	04					.byte	 4	; $2f /
>93f1	00					.byte	 0	; $30 0
>93f2	00					.byte	 0	; $31 1
>93f3	00					.byte	 0	; $32 2
>93f4	00					.byte	 0	; $33 3
>93f5	00					.byte	 0	; $34 4
>93f6	00					.byte	 0	; $35 5
>93f7	00					.byte	 0	; $36 6
>93f8	00					.byte	 0	; $37 7
>93f9	00					.byte	 0	; $38 8
>93fa	00					.byte	 0	; $39 9
>93fb	00					.byte	 0	; $3a :
>93fc	00					.byte	 0	; $3b ;
>93fd	02					.byte	 2	; $3c <
>93fe	02					.byte	 2	; $3d =
>93ff	02					.byte	 2	; $3e >
>9400	05					.byte	 5	; $3f ?

;******  Return to file: ./common/expressions/expression.asm

.9401					EvaluateExpressionAt0:
.9401	a2 00		ldx #$00			ldx 	#0 							; bottom stack level
.9403					EvaluateExpression:
.9403	a9 00		lda #$00			lda 	#0 							; lowest precedence level
.9405					EvaluateExpressionAtPrecedence:
.9405	48		pha				pha 								; save precedence level
.9406	20 4d 98	jsr $984d			jsr 	EvaluateTerm 				; evaluate term into level X.
.9409	68		pla				pla 								; restore precedence level.
.940a					_EXPRLoop:
.940a	85 36		sta $36				sta 	zTemp0 						; save current precedence level.
.940c	b1 30		lda ($30),y			lda 	(codePtr),y
.940e	c9 40		cmp #$40			cmp		#$40 						; if >= $40 cannot be an operator
.9410	b0 25		bcs $9437			bcs 	_EXPRExit
.9412	da		phx				phx 								; read the operator precedence
.9413	aa		tax				tax
.9414	bd c1 93	lda $93c1,x			lda 	PrecedenceLevel,x
.9417	fa		plx				plx
.9418	c9 00		cmp #$00			cmp 	#0							; if zero exit (not an operator)
.941a	f0 1b		beq $9437			beq 	_EXPRExit
.941c	85 37		sta $37				sta 	zTemp0+1 					; save operator precedence level.
.941e	a5 36		lda $36				lda 	zTemp0 						; compare current precedence vs. operator precedence
.9420	c5 37		cmp $37				cmp 	zTemp0+1
.9422	b0 13		bcs $9437			bcs		_EXPRExit 					; if current >= operator exit
.9424	48		pha				pha 								; save current precedence.
.9425	b1 30		lda ($30),y			lda 	(codePtr),y
.9427	c8		iny				iny
.9428	48		pha				pha
.9429	a5 37		lda $37				lda 	zTemp0+1 					; get operator precedence level
.942b	e8		inx				inx 								; work out the right hand side.
.942c	20 05 94	jsr $9405			jsr 	EvaluateExpressionAtPrecedence
.942f	ca		dex				dex
.9430	68		pla				pla 								; get operator, call the code.
.9431	20 3a 94	jsr $943a			jsr 	_EXPRCaller
.9434	68		pla				pla 								; restore precedence level
.9435	80 d3		bra $940a			bra 	_EXPRLoop 					; and go round.
.9437					_EXPRExit:
.9437	a5 36		lda $36				lda 	zTemp0 						; A = current precedence level.
.9439	60		rts				rts
.943a					_EXPRCaller:
.943a	da		phx				phx 								; save on stack, first thing is to restore it
.943b	0a		asl a				asl 	a 							; double so can use vectors into X
.943c	aa		tax				tax
.943d	7c 16 8c	jmp ($8c16,x)			jmp 	(VectorSetPunc,x) 			; and go to the code.

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/addsub.asm

.9440					FloatingPointAdd:
.9440	20 b6 95	jsr $95b6			jsr 	FloatPrepare 				; prepare for floats
.9443	80 09		bra $944e			bra 	FloatAdd
.9445					FloatingPointSub:
.9445	20 b6 95	jsr $95b6			jsr 	FloatPrepare 				; prepare for floats
.9448					FloatSubtract:
.9448	b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate FPB
.944a	49 80		eor #$80			eor 	#$80
.944c	95 51		sta $51,x			sta 	NSStatus+1,x				; and fall through.
.944e					FloatAdd:
.944e	48		pha				pha
.944f	5a		phy				phy
.9450	20 c5 95	jsr $95c5			jsr 	NSNormalise 				; normalise S[X]
.9453	f0 51		beq $94a6			beq 	_FAReturn1
.9455	e8		inx				inx 								; normalise S[X+1]
.9456	20 c5 95	jsr $95c5			jsr 	NSNormalise
.9459	ca		dex				dex
.945a	c9 00		cmp #$00			cmp 	#0
.945c	f0 60		beq $94be			beq 	_FAExit 					; if so, just return A
.945e	b5 78		lda $78,x			lda 	NSExponent,x 				; are the exponents the same ?
.9460	d5 79		cmp $79,x			cmp 	NSExponent+1,x
.9462	f0 18		beq $947c			beq 	_FAExponentsEqual
.9464	b5 78		lda $78,x			lda 	NSExponent,x 				; work out the larger exponent
.9466	a8		tay				tay
.9467	38		sec				sec 								; do a signed comparison of the exponents.
.9468	f5 79		sbc $79,x			sbc 	NSExponent+1,x
.946a	50 02		bvc $946e			bvc 	_FANoSignedChange
.946c	49 80		eor #$80			eor 	#$80
.946e					_FANoSignedChange:
.946e	29 80		and #$80			and 	#$80
.9470	10 02		bpl $9474			bpl 	_FAHaveMax
.9472	b4 79		ldy $79,x			ldy 	NSExponent+1,x
.9474					_FAHaveMax:
.9474	20 c1 94	jsr $94c1			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.9477	e8		inx				inx
.9478	20 c1 94	jsr $94c1			jsr 	_FAShiftToExponent
.947b	ca		dex				dex
.947c					_FAExponentsEqual:
.947c	b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs the same
.947e	55 51		eor $51,x			eor 	NSStatus+1,x
.9480	30 0e		bmi $9490			bmi 	_FADifferentSigns
.9482	20 f9 91	jsr $91f9			jsr 	AddTopTwoStack 				; do the add of the mantissae
.9485	b5 70		lda $70,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.9487	10 35		bpl $94be			bpl 	_FAExit 					; if no, we are done.
.9489	20 3f 9e	jsr $9e3f			jsr 	NSMShiftRight 				; shift A right, renormalising it.
.948c	f6 78		inc $78,x			inc 	NSExponent,x 				; bump the exponent and exit
.948e	80 2e		bra $94be			bra 	_FAExit
.9490					_FADifferentSigns:
.9490	20 13 92	jsr $9213			jsr 	SubTopTwoStack 				; subtract mantissa B from A
.9493	b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the result negative ?
.9495	10 06		bpl $949d			bpl 	_FACheckZero 				; if no, check for -0
.9497	20 e8 9d	jsr $9de8			jsr 	NSMNegate 					; netate result
.949a	20 ef 9d	jsr $9def			jsr 	NSMNegateMantissa 			; negate (2'c) the mantissa
.949d					_FACheckZero:
.949d	20 48 9e	jsr $9e48			jsr 	NSMIsZero	 				; check for -0
.94a0	d0 1c		bne $94be			bne 	_FAExit
.94a2	74 50		stz $50,x			stz 	NSStatus,x
.94a4	80 18		bra $94be			bra 	_FAExit
.94a6					_FAReturn1:
.94a6	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.94a8	95 58		sta $58,x			sta 	NSMantissa0,x
.94aa	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.94ac	95 60		sta $60,x			sta 	NSMantissa1,x
.94ae	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.94b0	95 68		sta $68,x			sta 	NSMantissa2,x
.94b2	b5 71		lda $71,x			lda 	NSMantissa3+1,x
.94b4	95 70		sta $70,x			sta 	NSMantissa3,x
.94b6	b5 79		lda $79,x			lda 	NSExponent+1,x
.94b8	95 78		sta $78,x			sta 	NSExponent,x
.94ba	b5 51		lda $51,x			lda 	NSStatus+1,x
.94bc	95 50		sta $50,x			sta 	NSStatus,x
.94be					_FAExit:
.94be	7a		ply				ply
.94bf	68		pla				pla
.94c0	60		rts				rts
.94c1					_FAShiftToExponent:
.94c1					_FAShiftToExponent2:
.94c1	98		tya				tya 								; compare Y to exponent
.94c2	d5 78		cmp $78,x			cmp 	NSExponent,x 				; reached the exponent required ?
.94c4	f0 07		beq $94cd			beq 	_FASEExit 					; exit if so.
.94c6	20 3f 9e	jsr $9e3f			jsr 	NSMShiftRight	 			; shift the mantissa right
.94c9	f6 78		inc $78,x			inc 	NSExponent,x 				; increment exponent
.94cb	80 f4		bra $94c1			bra 	_FAShiftToExponent2
.94cd					_FASEExit:
.94cd	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/compare.asm

.94ce					CompareFloat:
.94ce	20 48 94	jsr $9448			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.94d1	b5 60		lda $60,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.94d3	29 f8		and #$f8			and 	#$F8
.94d5	15 68		ora $68,x			ora 	NSMantissa2,x
.94d7	15 70		ora $70,x			ora 	NSMantissa3,x
.94d9	f0 08		beq $94e3			beq 	_FCExit 					; zero, so approximately identical
.94db	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.94dd	34 50		bit $50,x			bit 	NSStatus,x
.94df	10 02		bpl $94e3			bpl 	_FCExit
.94e1					_FCNegative:
.94e1	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.94e3					_FCExit:
.94e3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/divide.asm

.94e4					FDivideCommand:
.94e4	fa		plx				plx	 								; restore stack position
.94e5	20 b6 95	jsr $95b6			jsr 	FloatPrepare 				; prepare for floats
.94e8					FloatDivide:
.94e8	48		pha				pha
.94e9	e8		inx				inx
.94ea	20 c5 95	jsr $95c5			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.94ed	ca		dex				dex
.94ee	c9 00		cmp #$00			cmp 	#0
.94f0	f0 1d		beq $950f			beq 	_FDZero
.94f2	20 c5 95	jsr $95c5			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.94f5	f0 16		beq $950d			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.94f7	20 ea 90	jsr $90ea			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.94fa	20 86 90	jsr $9086			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.94fd	20 c5 95	jsr $95c5			jsr		NSNormalise 				; renormalise
.9500	20 7a 91	jsr $917a			jsr 	CalculateSign 				; calculate result sign
.9503	b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent
.9505	38		sec				sec
.9506	f5 79		sbc $79,x			sbc 	NSExponent+1,x
.9508	38		sec				sec
.9509	e9 1e		sbc #$1e			sbc 	#30
.950b	95 78		sta $78,x			sta 	NSExponent,x
.950d					_FDExit:
.950d	68		pla				pla
.950e	60		rts				rts
.950f					_FDZero:
.950f	a9 03		lda #$03		lda	#3
.9511	4c ff 8e	jmp $8eff		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/fractional.asm

.9514					FloatFractionalPart:
.9514	5a		phy				phy
.9515	b5 50		lda $50,x			lda 	NSStatus,x 					; take absolute value
.9517	29 7f		and #$7f			and 	#$7F
.9519	95 50		sta $50,x			sta 	NSStatus,x
.951b	20 c5 95	jsr $95c5			jsr 	NSNormalise
.951e	b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.9520	38		sec				sec
.9521	e9 e0		sbc #$e0			sbc 	#$E0
.9523	90 29		bcc $954e			bcc 	_FFPExit 					; already fractional
.9525	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.9527	b0 22		bcs $954b			bcs 	_FFPZero
.9529	a8		tay				tay 								; put count to do in Y
.952a	b5 70		lda $70,x			lda 	NSMantissa3,x 				; do each in turn.
.952c	20 50 95	jsr $9550			jsr 	_FFPPartial
.952f	95 70		sta $70,x			sta 	NSMantissa3,x
.9531	b5 68		lda $68,x			lda 	NSMantissa2,x
.9533	20 50 95	jsr $9550			jsr 	_FFPPartial
.9536	95 68		sta $68,x			sta 	NSMantissa2,x
.9538	b5 60		lda $60,x			lda 	NSMantissa1,x
.953a	20 50 95	jsr $9550			jsr 	_FFPPartial
.953d	95 60		sta $60,x			sta 	NSMantissa1,x
.953f	b5 58		lda $58,x			lda 	NSMantissa0,x
.9541	20 50 95	jsr $9550			jsr 	_FFPPartial
.9544	95 58		sta $58,x			sta 	NSMantissa0,x
.9546	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; zeroed check.
.9549	d0 03		bne $954e			bne 	_FFPExit
.954b					_FFPZero:
.954b	20 26 9e	jsr $9e26			jsr 	NSMSetZero
.954e					_FFPExit:
.954e	7a		ply				ply
.954f	60		rts				rts
.9550					_FFPPartial:
.9550	c0 00		cpy #$00			cpy 	#0 							; no more to do
.9552	f0 17		beq $956b			beq 	_FFFPPExit
.9554	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.9556	b0 0c		bcs $9564			bcs 	_FFFPPWholeByte
.9558	5a		phy				phy
.9559					_FFFPPLeft:
.9559	0a		asl a				asl 	a
.955a	88		dey				dey
.955b	d0 fc		bne $9559			bne 	_FFFPPLeft
.955d	7a		ply				ply
.955e					_FFFPPRight:
.955e	4a		lsr a				lsr 	a
.955f	88		dey				dey
.9560	d0 fc		bne $955e			bne 	_FFFPPRight
.9562	80 07		bra $956b			bra 	_FFFPPExit
.9564					_FFFPPWholeByte:
.9564	98		tya				tya 								; subtract 8 from count
.9565	38		sec				sec
.9566	e9 08		sbc #$08			sbc 	#8
.9568	a8		tay				tay
.9569	a9 00		lda #$00			lda 	#0 							; and clear all
.956b					_FFFPPExit:
.956b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/integer.asm

.956c					FloatIntegerPart:
.956c	48		pha				pha
.956d	b5 78		lda $78,x			lda 	NSExponent,x 				; is it integer already ?
.956f	f0 1d		beq $958e			beq 	_FIPExit 					; if so do nothing
.9571	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; is it zero ?
.9574	f0 15		beq $958b			beq 	_FIPZero 					; if so return zero.
.9576	20 c5 95	jsr $95c5			jsr 	NSNormalise 				; normalise
.9579	f0 10		beq $958b			beq 	_FIPZero 					; normalised to zero, exit zero
.957b					_FIPShift:
.957b	b5 78		lda $78,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.957d	10 07		bpl $9586			bpl 	_FIPCheckZero
.957f	20 3f 9e	jsr $9e3f			jsr 	NSMShiftRight 				; shift mantissa right
.9582	f6 78		inc $78,x			inc 	NSExponent,x 				; bump exponent
.9584	80 f5		bra $957b			bra 	_FIPShift
.9586					_FIPCheckZero:
.9586	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; avoid -0 problem
.9589	d0 03		bne $958e			bne 	_FIPExit 					; set to zero if mantissa zero.
.958b					_FIPZero:
.958b	20 26 9e	jsr $9e26			jsr 	NSMSetZero
.958e					_FIPExit:
.958e	68		pla				pla
.958f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/multiply.asm

.9590					FloatingPointMultiply:
.9590	20 b6 95	jsr $95b6			jsr 	FloatPrepare 				; prepare for floats
.9593					FloatMultiply:
.9593	48		pha				pha
.9594	20 c5 95	jsr $95c5			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.9597	f0 18		beq $95b1			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.9599	e8		inx				inx
.959a	20 c5 95	jsr $95c5			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.959d	ca		dex				dex
.959e	c9 00		cmp #$00			cmp 	#0
.95a0	f0 0c		beq $95ae			beq 	_FDSetZero
.95a2	20 3c 91	jsr $913c			jsr 	MultiplyShort 				; calculate the result.
.95a5	75 78		adc $78,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.95a7	18		clc				clc
.95a8	75 79		adc $79,x			adc 	NSExponent+1,x
.95aa	95 78		sta $78,x			sta 	NSExponent,x
.95ac	80 03		bra $95b1			bra 	_FDExit
.95ae					_FDSetZero:
.95ae	20 26 9e	jsr $9e26			jsr 	NSMSetZero 					; return 0
.95b1					_FDExit:
.95b1	20 c5 95	jsr $95c5			jsr 	NSNormalise 				; normalise the result
.95b4	68		pla				pla
.95b5	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/utility.asm

.95b6					FloatPrepare:
.95b6	20 c1 96	jsr $96c1			jsr 	DereferenceTopTwo 			; dereference the top two values
.95b9	b5 50		lda $50,x			lda 	NSStatus,x 					; check ints/floats, either will do.
.95bb	15 51		ora $51,x			ora 	NSStatus+1,x
.95bd	29 10		and #$10			and 	#NSBIsString
.95bf	d0 01		bne $95c2			bne 	_FDType
.95c1	60		rts				rts
.95c2					_FDType:
.95c2	4c ae 9f	jmp $9fae			jmp 	TypeError
.95c5					NSNormalise:
.95c5	b5 50		lda $50,x			lda 	NSStatus,x 					; make float, keep sign
.95c7	29 80		and #$80			and 	#$80
.95c9	09 08		ora #$08			ora 	#NSTFloat
.95cb	95 50		sta $50,x			sta 	NSStatus,x
.95cd	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; if zero exit
.95d0	d0 07		bne $95d9			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.95d2	16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.95d4	76 50		ror $50,x			ror 	NSStatus,x 					; (no -0)
.95d6	a9 00		lda #$00			lda 	#0 							; set Z flag
.95d8	60		rts				rts
.95d9					_NSNormaliseOptimise:
.95d9	b5 70		lda $70,x			lda 	NSMantissa3,x 				; upper byte zero ?
.95db	d0 19		bne $95f6			bne 	_NSNormaliseLoop
.95dd	b5 68		lda $68,x			lda 	NSMantissa2,x 				; byte normalise
.95df	30 15		bmi $95f6			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.95e1	95 70		sta $70,x			sta 	NSMantissa3,x
.95e3	b5 60		lda $60,x			lda 	NSMantissa1,x
.95e5	95 68		sta $68,x			sta 	NSMantissa2,x
.95e7	b5 58		lda $58,x			lda 	NSMantissa0,x
.95e9	95 60		sta $60,x			sta 	NSMantissa1,x
.95eb	74 58		stz $58,x			stz 	NSMantissa0,x
.95ed	b5 78		lda $78,x			lda 	NSExponent,x
.95ef	38		sec				sec
.95f0	e9 08		sbc #$08			sbc 	#8
.95f2	95 78		sta $78,x			sta 	NSExponent,x
.95f4	80 e3		bra $95d9			bra 	_NSNormaliseOptimise
.95f6					_NSNormaliseLoop:
.95f6	34 70		bit $70,x			bit 	NSMantissa3,x 				; bit 30 set ?
.95f8	70 07		bvs $9601			bvs 	_NSNExit 					; exit if so with Z flag clear
.95fa	20 35 9e	jsr $9e35			jsr 	NSMShiftLeft 				; shift mantissa left
.95fd	d6 78		dec $78,x			dec 	NSExponent,x 				; adjust exponent
.95ff	80 f5		bra $95f6			bra 	_NSNormaliseLoop
.9601					_NSNExit:
.9601	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.9603	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignnumber.asm

.9604					AssignNumber:
.9604	5a		phy				phy
.9605	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy mantissa0/1 to zTemp0
.9607	85 36		sta $36				sta 	zTemp0
.9609	b5 60		lda $60,x			lda 	NSMantissa1,x
.960b	85 37		sta $37				sta 	zTemp0+1
.960d	b5 50		lda $50,x			lda 	NSStatus,x 					; clear reference bits
.960f	29 df		and #$df			and 	#(NSBIsReference ^ $FF)
.9611	95 50		sta $50,x			sta 	NSStatus,x
.9613	29 18		and #$18			and 	#NSBTypeMask				; assigning to a float ?
.9615	c9 08		cmp #$08			cmp 	#NSTFloat
.9617	f0 24		beq $963d			beq 	_ANFloat
.9619	b5 79		lda $79,x			lda		NSExponent+1,x 				; is it a float
.961b	f0 03		beq $9620			beq		_ANNotFloat
.961d	4c a9 9f	jmp $9fa9			jmp 	RangeError					; if it is, report an error.
.9620					_ANNotFloat:
.9620	b5 50		lda $50,x			lda 	NSStatus,x 					; check if byte/word reference.
.9622	29 03		and #$03			and 	#3
.9624	d0 05		bne $962b			bne 	_ANByteWord
.9626	20 48 96	jsr $9648			jsr 	_ANCopy4PackSign 			; copy all 4 bytes and sign
.9629	80 1b		bra $9646			bra 	_ANExit
.962b					_ANByteWord:
.962b	48		pha				pha 								; save count
.962c	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; do byte
.962e	92 36		sta ($36)			sta 	(zTemp0)
.9630	68		pla				pla
.9631	c9 01		cmp #$01			cmp	 	#1
.9633	f0 11		beq $9646			beq 	_ANExit
.9635	b5 61		lda $61,x			lda 	NSMantissa1+1,x 			; do word
.9637	a0 01		ldy #$01			ldy 	#1
.9639	91 36		sta ($36),y			sta 	(zTemp0),y
.963b	80 09		bra $9646			bra 	_ANExit
.963d					_ANFloat:
.963d	20 48 96	jsr $9648			jsr 	_ANCopy4PackSign 			; write all 4 bytes and packed sign
.9640	b5 79		lda $79,x			lda 	NSExponent+1,x 				; copy exponent to slot 4
.9642	a0 04		ldy #$04			ldy 	#4
.9644	91 36		sta ($36),y			sta 	(zTemp0),y
.9646					_ANExit:
.9646	7a		ply				ply
.9647	60		rts				rts
.9648					_ANCopy4PackSign:
.9648	a0 03		ldy #$03			ldy 	#3
.964a	b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign bit into status
.964c	29 80		and #$80			and 	#$80 						; put into high bit of mantissa 3
.964e	15 71		ora $71,x			ora 	NSMantissa3+1,x
.9650	91 36		sta ($36),y			sta 	(zTemp0),y
.9652	88		dey				dey
.9653	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.9655	91 36		sta ($36),y			sta 	(zTemp0),y
.9657	88		dey				dey
.9658	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.965a	91 36		sta ($36),y			sta 	(zTemp0),y
.965c	88		dey				dey
.965d	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.965f	91 36		sta ($36),y			sta 	(zTemp0),y
.9661	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignstring.asm

.9662					AssignString:
.9662	5a		phy				phy
.9663	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9665	85 38		sta $38				sta 	zTemp1
.9667	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9669	85 39		sta $39				sta 	zTemp1+1
.966b	b5 58		lda $58,x			lda 	NSMantissa0,x
.966d	85 36		sta $36				sta 	zTemp0
.966f	b5 60		lda $60,x			lda 	NSMantissa1,x
.9671	85 37		sta $37				sta 	zTemp0+1
.9673	a0 01		ldy #$01			ldy 	#1 							; the high byte of the target address
.9675	b1 36		lda ($36),y			lda 	(zTemp0),y
.9677	f0 23		beq $969c			beq 	_ASNewStringRequired 		; if zero, a new string is required.
.9679	38		sec				sec 								; put Address-2 in zsTemp - this is the size/status/string record
.967a	b2 36		lda ($36)			lda 	(zTemp0) 					; of concreted strings
.967c	e9 02		sbc #$02			sbc 	#2
.967e	85 3c		sta $3c				sta 	zsTemp
.9680	a0 01		ldy #$01			ldy 	#1
.9682	b1 36		lda ($36),y			lda 	(zTemp0),y
.9684	e9 00		sbc #$00			sbc 	#0
.9686	85 3d		sta $3d				sta 	zsTemp+1
.9688	a0 ff		ldy #$ff			ldy 	#$FF 						; get length of new string
.968a					_ASGetLength:
.968a	c8		iny				iny
.968b	b1 38		lda ($38),y			lda 	(zTemp1),y
.968d	d0 fb		bne $968a			bne 	_ASGetLength
.968f	98		tya				tya 								; is this length <= current length
.9690	d2 3c		cmp ($3c)			cmp 	(zsTemp)
.9692	90 1e		bcc $96b2			bcc 	_ASCopyString
.9694	f0 1c		beq $96b2			beq 	_ASCopyString
.9696	a9 80		lda #$80			lda 	#$80 						; mark as unused.
.9698	a0 01		ldy #$01			ldy 	#1
.969a	91 3c		sta ($3c),y			sta 	(zsTemp),y
.969c					_ASNewStringRequired:
.969c	e8		inx				inx 								; concrete the new string.
.969d	20 3b a7	jsr $a73b			jsr 	StringConcrete				; (breaks zTemp1/2, not zTemp0 and zsTemp)
.96a0	ca		dex				dex
.96a1	18		clc				clc
.96a2	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy that new address to the reference.
.96a4	69 02		adc #$02			adc 	#2 							; add two to point at the data.
.96a6	92 36		sta ($36)			sta 	(zTemp0)
.96a8	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.96aa	69 00		adc #$00			adc 	#0
.96ac	a0 01		ldy #$01			ldy 	#1
.96ae	91 36		sta ($36),y			sta 	(zTemp0),y
.96b0	80 0d		bra $96bf			bra 	_ASExit
.96b2					_ASCopyString:
.96b2	a0 00		ldy #$00			ldy 	#0
.96b4					_ASCopyLoop:
.96b4	b1 38		lda ($38),y			lda 	(zTemp1),y
.96b6	c8		iny				iny
.96b7	c8		iny				iny
.96b8	91 3c		sta ($3c),y			sta 	(zsTemp),y
.96ba	88		dey				dey
.96bb	c9 00		cmp #$00			cmp 	#0
.96bd	d0 f5		bne $96b4			bne 	_ASCopyLoop
.96bf					_ASExit:
.96bf	7a		ply				ply
.96c0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/dereference.asm

.96c1					DereferenceTopTwo:
.96c1	e8		inx				inx
.96c2	20 c6 96	jsr $96c6			jsr 	Dereference 				; deref x+1
.96c5	ca		dex				dex  								; falls through to deref x
.96c6					Dereference:
.96c6	b5 50		lda $50,x			lda 	NSStatus,x 					; get the status byte
.96c8	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.96ca	f0 48		beq $9714			beq 	_DRFExit 					; not a reference, so exit.
.96cc	5a		phy				phy
.96cd	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address to dereference into zTemp0
.96cf	85 36		sta $36				sta 	zTemp0
.96d1	b5 60		lda $60,x			lda 	NSMantissa1,x
.96d3	85 37		sta $37				sta 	zTemp0+1
.96d5	74 60		stz $60,x			stz 	NSMantissa1,x 				; clear second byte.
.96d7	b2 36		lda ($36)			lda 	(zTemp0) 					; do the first byte
.96d9	95 58		sta $58,x			sta 	NSMantissa0,x
.96db	b5 50		lda $50,x			lda 	NSStatus,x 					; get status byte.
.96dd	29 18		and #$18			and 	#NSBTypeMask 				; what type is it ?
.96df	c9 10		cmp #$10			cmp 	#NSTString 					; if string, dereference two
.96e1	f0 0e		beq $96f1			beq 	_DRFDereferenceTwo
.96e3	c9 08		cmp #$08			cmp 	#NSTFloat 					; if float, do full dereference.
.96e5	f0 2f		beq $9716			beq 	_DRFFull
.96e7	b5 50		lda $50,x			lda 	NSStatus,x 					; must be integer - how many bytes ?
.96e9	29 03		and #$03			and 	#3
.96eb	f0 29		beq $9716			beq 	_DRFFull 					; the whole word
.96ed	c9 01		cmp #$01			cmp 	#1 							; is it 10 (e.g. 2 bytes)
.96ef	f0 06		beq $96f7			beq		_DRFClear23 				; no, one byte, clear 2 & 3 and exit
.96f1					_DRFDereferenceTwo:
.96f1	a0 01		ldy #$01			ldy 	#1
.96f3	b1 36		lda ($36),y			lda 	(zTemp0),y
.96f5	95 60		sta $60,x			sta 	NSMantissa1,x
.96f7					_DRFClear23:
.96f7	74 68		stz $68,x			stz 	NSMantissa2,x 				; clear upper bytes, only read 1 or 2 bytes
.96f9	74 70		stz $70,x			stz 	NSMantissa3,x
.96fb	b5 50		lda $50,x			lda 	NSStatus,x 					; make it a value of that type.
.96fd	29 18		and #$18			and 	#NSBTypeMask
.96ff	95 50		sta $50,x			sta 	NSStatus,x 					; and fall through.
.9701	c9 10		cmp #$10			cmp 	#NSTString  				; is it a string
.9703	d0 0e		bne $9713			bne 	_DRFNotString
.9705	b5 58		lda $58,x			lda 	NSMantissa0,x 				; check address is zero
.9707	15 60		ora $60,x			ora 	NSMantissa1,x
.9709	d0 08		bne $9713			bne 	_DRFNotString
.970b	a9 15		lda #$15			lda 	#_DRFNullString & $FF 		; if so, return reference to ""
.970d	95 58		sta $58,x			sta 	NSMantissa0,X
.970f	a9 97		lda #$97			lda 	#_DRFNullString >> 8
.9711	95 60		sta $60,x			sta 	NSMantissa1,X
.9713					_DRFNotString
.9713	7a		ply				ply 								; restore Y and exit
.9714					_DRFExit:
.9714	60		rts				rts
.9715					_DRFNullString:
>9715	00						.byte 	0
.9716					_DRFFull:
.9716	a0 01		ldy #$01			ldy 	#1 							; get remaining 3 bytes.
.9718	b1 36		lda ($36),y			lda 	(zTemp0),y
.971a	95 60		sta $60,x			sta 	NSMantissa1,x
.971c	c8		iny				iny
.971d	b1 36		lda ($36),y			lda 	(zTemp0),y
.971f	95 68		sta $68,x			sta 	NSMantissa2,x
.9721	c8		iny				iny
.9722	b1 36		lda ($36),y			lda 	(zTemp0),y
.9724	95 70		sta $70,x			sta 	NSMantissa3,x
.9726	74 78		stz $78,x			stz 	NSExponent,x 				; clear exponent.
.9728	b5 50		lda $50,x			lda		NSStatus,x 					; see if type is integer
.972a	29 18		and #$18			and 	#NSBTypeMask  				; type information only
.972c	95 50		sta $50,x			sta 	NSStatus,x 					; update it back.
.972e	f0 05		beq $9735			beq 	_DRFNoExponent
.9730	c8		iny				iny 								; if not, read the exponent as well.
.9731	b1 36		lda ($36),y			lda 	(zTemp0),y
.9733	95 78		sta $78,x			sta 	NSExponent,x
.9735					_DRFNoExponent:
.9735	b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the most significant bit set ?
.9737	10 0a		bpl $9743			bpl 	_DRFExit2 					; if not, then exit.
.9739	29 7f		and #$7f			and 	#$7F 						; clear that bit.
.973b	95 70		sta $70,x			sta 	NSMantissa3,x
.973d	b5 50		lda $50,x			lda 	NSStatus,x 					; set the sign flag
.973f	09 80		ora #$80			ora 	#NSBIsNegative
.9741	95 50		sta $50,x			sta 	NSStatus,x
.9743					_DRFExit2:
.9743	7a		ply				ply
.9744	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/number.asm

=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.9745					EncodeNumberStart:
.9745	38		sec				sec
.9746	80 01		bra $9749			bra 	EncodeNumberContinue+1
.9748					EncodeNumberContinue:
.9748	18		clc				clc
.9749					EncodeNumber:
.9749	08		php				php 								; save reset flag.
.974a	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.974c	f0 12		beq $9760			beq 	_ENIsOkay
.974e	c9 30		cmp #$30			cmp 	#"0"
.9750	90 04		bcc $9756			bcc 	_ENBadNumber
.9752	c9 3a		cmp #$3a			cmp 	#"9"+1
.9754	90 0a		bcc $9760			bcc 	_ENIsOkay
.9756					_ENBadNumber:
.9756	28		plp				plp 								; throw saved reset
.9757	ad 05 04	lda $0405			lda 	EncodeState 				; if in decimal mode, construct final number
.975a	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.975c	f0 7b		beq $97d9			beq 	_ENConstructFinal
.975e					_ENFail:
.975e	18		clc				clc 								; not allowed
.975f	60		rts				rts
.9760					_ENIsOkay:
.9760	28		plp				plp 								; are we restarting
.9761	90 15		bcc $9778			bcc 	_ENNoRestart
.9763					_ENStartEncode:
.9763	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.9765	f0 0c		beq $9773			beq 	_ENFirstDP
.9767	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.9769	20 28 9e	jsr $9e28			jsr 	NSMSetByte 					; in single byte mode.
.976c	a9 01		lda #$01			lda 	#ESTA_Low
.976e					_ENExitChange:
.976e	8d 05 04	sta $0405			sta 	EncodeState 				; save new state
.9771	38		sec				sec
.9772	60		rts				rts
.9773					_ENFirstDP:
.9773	20 26 9e	jsr $9e26			jsr 	NSMSetZero 					; clear integer part
.9776	80 3c		bra $97b4			bra 	_ESTASwitchFloat			; go straight to float and exi
.9778					_ENNoRestart:
.9778	48		pha				pha 								; save digit or DP on stack.
.9779	ad 05 04	lda $0405			lda 	EncodeState 				; get current state
.977c	c9 01		cmp #$01			cmp 	#ESTA_Low
.977e	f0 09		beq $9789			beq  	_ESTALowState
.9780	c9 02		cmp #$02			cmp 	#ESTA_High
.9782	f0 26		beq $97aa			beq 	_ESTAHighState
.9784	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.9786	f0 38		beq $97c0			beq 	_ESTADecimalState
>9788	db						.byte 	$DB 						; causes a break in the emulator
.9789					_ESTALowState:
.9789	68		pla				pla 								; get value back
.978a	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.978c	f0 26		beq $97b4			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.978e	29 0f		and #$0f			and 	#15 						; make digit
.9790	8d 06 04	sta $0406			sta 	DigitTemp 					; save it.
.9793	b5 58		lda $58,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.9795	0a		asl a				asl 	a
.9796	0a		asl a				asl 	a
.9797	75 58		adc $58,x			adc 	NSMantissa0,x
.9799	0a		asl a				asl 	a
.979a	6d 06 04	adc $0406			adc 	DigitTemp
.979d	95 58		sta $58,x			sta 	NSMantissa0,x
.979f	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.97a1	90 05		bcc $97a8			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.97a3	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.97a5	8d 05 04	sta $0405			sta 	EncodeState
.97a8					_ESTANoSwitch:
.97a8	38		sec				sec
.97a9	60		rts				rts
.97aa					_ESTAHighState:
.97aa	68		pla				pla 								; get value back
.97ab	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.97ad	f0 05		beq $97b4			beq 	_ESTASwitchFloat
.97af	20 0d 98	jsr $980d			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.97b2	38		sec				sec
.97b3	60		rts				rts
.97b4					_ESTASwitchFloat:
.97b4	9c 07 04	stz $0407			stz 	DecimalCount 				; reset the count of digits - we divide by 10^n at the end.
.97b7	e8		inx				inx 								; zero the decimal additive.
.97b8	20 26 9e	jsr $9e26			jsr 	NSMSetZero
.97bb	ca		dex				dex
.97bc	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.97be	80 ae		bra $976e			bra 	_ENExitChange
.97c0					_ESTADecimalState:
.97c0	68		pla				pla 								; digit.
.97c1	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 2nd decimal point.
.97c3	f0 99		beq $975e			beq 	_ENFail
.97c5	e8		inx				inx 								; put digit into fractional part of X+1
.97c6	20 0d 98	jsr $980d			jsr 	ESTAShiftDigitIntoMantissa
.97c9	ca		dex				dex
.97ca	ee 07 04	inc $0407			inc 	DecimalCount 				; bump the count of decimals
.97cd	ad 07 04	lda $0407			lda 	DecimalCount 				; too many decimal digits.
.97d0	c9 0b		cmp #$0b			cmp 	#11
.97d2	f0 02		beq $97d6			beq 	_ESTADSFail
.97d4	38		sec				sec
.97d5	60		rts				rts
.97d6					_ESTADSFail:
.97d6	4c a9 9f	jmp $9fa9			jmp 	RangeError
.97d9					_ENConstructFinal:
.97d9	ad 07 04	lda $0407			lda 	DecimalCount 				; get decimal count
.97dc	f0 2d		beq $980b			beq 	_ENCFExit 					; no decimals
.97de	5a		phy				phy
.97df	0a		asl a				asl 	a 							; x 4 and CLC
.97e0	0a		asl a				asl 	a
.97e1	6d 07 04	adc $0407			adc 	DecimalCount
.97e4	a8		tay				tay
.97e5	b9 68 9f	lda $9f68,y			lda 	DecimalScalarTable-5,y 		; copy decimal scalar to X+2
.97e8	95 5a		sta $5a,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.97ea	b9 69 9f	lda $9f69,y			lda 	DecimalScalarTable-5+1,y
.97ed	95 62		sta $62,x			sta 	NSMantissa1+2,x
.97ef	b9 6a 9f	lda $9f6a,y			lda 	DecimalScalarTable-5+2,y
.97f2	95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.97f4	b9 6b 9f	lda $9f6b,y			lda 	DecimalScalarTable-5+3,y
.97f7	95 72		sta $72,x			sta 	NSMantissa3+2,x
.97f9	b9 6c 9f	lda $9f6c,y			lda 	DecimalScalarTable-5+4,y
.97fc	95 7a		sta $7a,x			sta 	NSExponent+2,x
.97fe	a9 08		lda #$08			lda 	#NSTFloat
.9800	95 52		sta $52,x			sta 	NSStatus+2,x
.9802	7a		ply				ply
.9803	e8		inx				inx 								; multiply decimal const by decimal scalar
.9804	20 93 95	jsr $9593			jsr 	FloatMultiply
.9807	ca		dex				dex
.9808	20 4e 94	jsr $944e			jsr 	FloatAdd 					; add to integer part.
.980b					_ENCFExit:
.980b	18		clc				clc 								; reject the digit.
.980c	60		rts				rts
.980d					ESTAShiftDigitIntoMantissa:
.980d	29 0f		and #$0f			and 	#15 						; save digit
.980f	48		pha				pha
.9810	b5 70		lda $70,x			lda 	NSMantissa3,x 				; push mantissa on stack
.9812	48		pha				pha
.9813	b5 68		lda $68,x			lda 	NSMantissa2,x
.9815	48		pha				pha
.9816	b5 60		lda $60,x			lda 	NSMantissa1,x
.9818	48		pha				pha
.9819	b5 58		lda $58,x			lda 	NSMantissa0,x
.981b	48		pha				pha
.981c	20 35 9e	jsr $9e35			jsr 	NSMShiftLeft 				; x 2
.981f	20 35 9e	jsr $9e35			jsr 	NSMShiftLeft 				; x 4
.9822	18		clc				clc 								; pop mantissa and add
.9823	68		pla				pla
.9824	75 58		adc $58,x			adc 	NSMantissa0,x
.9826	95 58		sta $58,x			sta 	NSMantissa0,x
.9828	68		pla				pla
.9829	75 60		adc $60,x			adc 	NSMantissa1,x
.982b	95 60		sta $60,x			sta 	NSMantissa1,x
.982d	68		pla				pla
.982e	75 68		adc $68,x			adc 	NSMantissa2,x
.9830	95 68		sta $68,x			sta 	NSMantissa2,x
.9832	68		pla				pla
.9833	75 70		adc $70,x			adc 	NSMantissa3,x
.9835	95 70		sta $70,x			sta 	NSMantissa3,x 				; x 5
.9837	20 35 9e	jsr $9e35			jsr 	NSMShiftLeft 				; x 10
.983a	68		pla				pla 								; add digit
.983b	18		clc				clc
.983c	75 58		adc $58,x			adc 	NSMantissa0,x
.983e	95 58		sta $58,x			sta 	NSMantissa0,x
.9840	90 0a		bcc $984c			bcc 	_ESTASDExit
.9842	f6 60		inc $60,x			inc 	NSMantissa1,x
.9844	d0 06		bne $984c			bne 	_ESTASDExit
.9846	f6 68		inc $68,x			inc 	NSMantissa2,x
.9848	d0 02		bne $984c			bne 	_ESTASDExit
.984a	f6 70		inc $70,x			inc 	NSMantissa3,x
.984c					_ESTASDExit:
.984c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/term.asm

.984d					EvaluateTerm:
.984d	b1 30		lda ($30),y			lda 	(codePtr),y
.984f	30 18		bmi $9869			bmi 	_ETCheckUnary 				; unary function ? (text ones)
.9851	c9 40		cmp #$40			cmp 	#$40 						; 40-7F => identifier reference
.9853	b0 6c		bcs $98c1			bcs 	_ETVariable
.9855	c9 30		cmp #$30			cmp 	#'0' 						; is it a number
.9857	90 6b		bcc $98c4			bcc 	_ETPuncUnary 				; if not it might be a punctuation unary.
.9859	c9 3a		cmp #$3a			cmp 	#'9'+1
.985b	b0 67		bcs $98c4			bcs 	_ETPuncUnary
.985d	20 45 97	jsr $9745			jsr 	EncodeNumberStart 			; can't fail as it's 0-9 !
.9860					_ETNumber:
.9860	c8		iny				iny 								; keep encoding until we have the numbers
.9861	b1 30		lda ($30),y			lda 	(codePtr),y
.9863	20 48 97	jsr $9748			jsr 	EncodeNumberContinue
.9866	b0 f8		bcs $9860			bcs 	_ETNumber 					; go back if accepted.
.9868	60		rts				rts
.9869					_ETCheckUnary:
.9869	c9 ff		cmp #$ff			cmp 	#KWC_STRING 				; string token
.986b	f0 3f		beq $98ac			beq 	_ETString
.986d	c9 fe		cmp #$fe			cmp 	#KWC_HEXCONST 				; hex constant.
.986f	f0 12		beq $9883			beq 	_ETHexConstant
.9871	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; check it actually is a unary function
.9873	90 0b		bcc $9880			bcc 	_ETSyntaxError
.9875	c9 a2		cmp #$a2			cmp 	#KWC_LAST_UNARY+1
.9877	b0 07		bcs $9880			bcs 	_ETSyntaxError
.9879	da		phx				phx 								; push X on the stack
.987a	0a		asl a				asl 	a 							; put vector x 2 into X
.987b	aa		tax				tax
.987c	c8		iny				iny 								; consume unary function token
.987d	7c 96 8c	jmp ($8c96,x)			jmp 	(VectorSet0,x) 				; and do it.
.9880					_ETSyntaxError:
.9880	4c a4 9f	jmp $9fa4			jmp 	SyntaxError
.9883					_ETHexConstant:
.9883	c8		iny				iny 								; skip #
.9884	c8		iny				iny 								; skip count
.9885	20 26 9e	jsr $9e26			jsr 	NSMSetZero 					; clear result
.9888					_ETHLoop:
.9888	b1 30		lda ($30),y			lda 	(codePtr),y
.988a	c8		iny				iny 								; and consume
.988b	c9 00		cmp #$00			cmp 	#0 							; exit if zero
.988d	f0 1c		beq $98ab			beq 	_ETHExit
.988f	48		pha				pha 								; save on stack.
.9890	20 35 9e	jsr $9e35			jsr 	NSMShiftLeft 				; x 2
.9893	20 35 9e	jsr $9e35			jsr 	NSMShiftLeft 				; x 4
.9896	20 35 9e	jsr $9e35			jsr 	NSMShiftLeft 				; x 8
.9899	20 35 9e	jsr $9e35			jsr 	NSMShiftLeft 				; x 16
.989c	68		pla				pla 								; ASCII
.989d	c9 41		cmp #$41			cmp 	#'A'
.989f	90 02		bcc $98a3			bcc 	_ETHNotChar
.98a1	e9 07		sbc #$07			sbc 	#7
.98a3					_ETHNotChar:
.98a3	29 0f		and #$0f			and 	#15 						; digit now
.98a5	15 58		ora $58,x			ora 	NSMantissa0,x 				; put in LS Nibble
.98a7	95 58		sta $58,x			sta 	NSMantissa0,x
.98a9	80 dd		bra $9888			bra 	_ETHLoop 					; go round.
.98ab					_ETHExit:
.98ab	60		rts				rts
.98ac					_ETString:
.98ac	c8		iny				iny 								; look at length
.98ad	b1 30		lda ($30),y			lda 	(codePtr),y
.98af	48		pha				pha
.98b0	c8		iny				iny 								; first character
.98b1	20 91 a5	jsr $a591			jsr 	MemoryInline 				; put address of string at (code-Ptr),y on stack
.98b4	68		pla				pla 								; restore count and save
.98b5	85 36		sta $36				sta 	zTemp0
.98b7	98		tya				tya 								; add length to Y to skip it.
.98b8	18		clc				clc
.98b9	65 36		adc $36				adc 	zTemp0
.98bb	a8		tay				tay
.98bc	a9 10		lda #$10			lda 	#NSTString 					; mark as string
.98be	95 50		sta $50,x			sta 	NSStatus,x
.98c0	60		rts				rts
.98c1					_ETVariable:
.98c1	4c 16 99	jmp $9916			jmp 	VariableHandler
.98c4					_ETPuncUnary:
.98c4	c8		iny				iny 								; consume the unary character
.98c5	c9 2d		cmp #$2d			cmp 	#KWD_MINUS 					; unary minus
.98c7	f0 2b		beq $98f4			beq 	_ETUnaryNegate
.98c9	c9 10		cmp #$10			cmp 	#KWD_AT 					; @ reference -> constant
.98cb	f0 36		beq $9903			beq 	_ETDereference
.98cd	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; parenthesis
.98cf	f0 3e		beq $990f			beq 	_ETParenthesis
.98d1	64 36		stz $36				stz 	zTemp0 						; zTemp0 is the indirection level.
.98d3	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; byte indirection (0) ?
.98d5	f0 06		beq $98dd			beq 	_ETIndirection
.98d7	e6 36		inc $36				inc 	zTemp0
.98d9	c9 21		cmp #$21			cmp 	#KWD_PLING					; word indirection (1) \
.98db	d0 a3		bne $9880			bne 	_ETSyntaxError
.98dd					_ETIndirection:
.98dd	a5 36		lda $36				lda 	zTemp0 						; push indirection amount (0-1) => (1-2) on the stack
.98df	1a		inc a				inc 	a
.98e0	48		pha				pha
.98e1	20 4d 98	jsr $984d			jsr 	EvaluateTerm				; evaluate the term
.98e4	20 c6 96	jsr $96c6			jsr 	Dereference 				; dereference it.
.98e7	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a +ve integer.
.98e9	d0 06		bne $98f1			bne 	_ETTypeMismatch
.98eb	68		pla				pla 								; indirection 1-2
.98ec	09 20		ora #$20			ora 	#NSBIsReference 			; make it a reference.
.98ee	95 50		sta $50,x			sta 	NSStatus,x
.98f0	60		rts				rts
.98f1					_ETTypeMismatch:
.98f1	4c ae 9f	jmp $9fae			jmp 	TypeError
.98f4					_ETUnaryNegate:
.98f4	20 4d 98	jsr $984d			jsr 	EvaluateTerm				; evaluate the term
.98f7	20 c6 96	jsr $96c6			jsr 	Dereference 				; dereference it.
.98fa	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a number
.98fc	29 10		and #$10			and 	#NSTString
.98fe	d0 f1		bne $98f1			bne 	_ETTypeMismatch
.9900	4c e8 9d	jmp $9de8			jmp 	NSMNegate  					; just toggles the sign bit.
.9903					_ETDereference:
.9903	20 4d 98	jsr $984d			jsr 	EvaluateTerm				; evaluate the term
.9906	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a reference
.9908	29 20		and #$20			and 	#NSBIsReference
.990a	f0 e5		beq $98f1			beq 	_ETTypeMismatch
.990c	74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer address
.990e	60		rts				rts
.990f					_ETParenthesis:
.990f	20 03 94	jsr $9403			jsr 	EvaluateExpression 			; evaluate here, from lowest precedence
.9912	20 e6 8e	jsr $8ee6			jsr 	CheckRightBracket 			; check for )
.9915	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/variable.asm

.9916					VariableHandler:
.9916	b1 30		lda ($30),y			lda 	(codePtr),y
.9918	18		clc				clc
.9919	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.991b	85 37		sta $37				sta 	zTemp0+1
.991d	c8		iny				iny
.991e	b1 30		lda ($30),y			lda 	(codePtr),y
.9920	85 36		sta $36				sta 	zTemp0
.9922	c8		iny				iny
.9923	18		clc				clc									; copy variable address+3 to mantissa
.9924	69 03		adc #$03			adc 	#3 							; this is the address of the data.
.9926	95 58		sta $58,x			sta 	NSMantissa0,x
.9928	a5 37		lda $37				lda 	zTemp0+1
.992a	69 00		adc #$00			adc 	#0
.992c	95 60		sta $60,x			sta 	NSMantissa1,x
.992e	74 68		stz $68,x			stz 	NSMantissa2,x
.9930	74 70		stz $70,x			stz 	NSMantissa3,x
.9932	74 78		stz $78,x			stz 	NSExponent,x
.9934	5a		phy				phy
.9935	a0 02		ldy #$02			ldy 	#2 							; read type
.9937	b1 36		lda ($36),y			lda 	(zTemp0),y
.9939	7a		ply				ply
.993a	29 1c		and #$1c			and 	#NSBTypeMask+NSBIsArray 	; get type information
.993c	09 20		ora #$20			ora 	#NSBIsReference 			; make a reference.
.993e	95 50		sta $50,x			sta 	NSStatus,x
.9940	29 04		and #$04			and 	#NSBIsArray
.9942	d0 01		bne $9945			bne 	_VHArray
.9944	60		rts				rts
.9945					_VHArray:
.9945	e8		inx				inx
.9946	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger 		; get the 1st index.
.9949	a9 ff		lda #$ff			lda 	#$FF 						; set Status of X+2 to a duff value so we know if we picked it up.
.994b	95 51		sta $51,x			sta 	NSStatus+1,x
.994d	b1 30		lda ($30),y			lda 	(codePtr),y
.994f	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.9951	d0 06		bne $9959			bne 	_VHNoSecondIndex
.9953	c8		iny				iny 								; skip the comma
.9954	e8		inx				inx
.9955	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger 		; get the 2nd index.
.9958	ca		dex				dex
.9959					_VHNoSecondIndex:
.9959	ca		dex				dex 								; set X back.
.995a	20 e6 8e	jsr $8ee6			jsr 	CheckRightBracket 			; and check the right bracket.
.995d	5a		phy				phy 								; save position
.995e	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy record address to zaTemp (moved 6/12/22)
.9960	85 3e		sta $3e				sta 	zaTemp
.9962	b5 60		lda $60,x			lda 	NSMantissa1,x
.9964	85 3f		sta $3f				sta 	zaTemp+1
.9966	a0 02		ldy #$02			ldy 	#2 							; check first index is not-zero, e.g. array defined
.9968	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.996a	f0 5d		beq $99c9			beq 	_VHBadArray
.996c	a0 03		ldy #$03			ldy 	#3 							; get the second index - which is 0 if there is one index.
.996e	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9970	f0 02		beq $9974			beq 	_VHHas2Mask
.9972	a9 ff		lda #$ff			lda 	#$FF
.9974					_VHHas2Mask:
.9974	d5 52		cmp $52,x			cmp 	NSStatus+2,x 				; so if they are the same there are the wrong number of indices
.9976	f0 4c		beq $99c4			beq 	_VHBadIndex
.9978	0a		asl a				asl 	a 							; carry will be set if a second index
.9979	90 08		bcc $9983			bcc 	_VHCheckFirstIndex
.997b	a0 03		ldy #$03			ldy 	#3 			 				; check the 2nd size >= 2nd index
.997d	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.997f	d5 5a		cmp $5a,x			cmp 	NSMantissa0+2,x
.9981	90 41		bcc $99c4			bcc 	_VHBadIndex
.9983					_VHCheckFirstIndex:
.9983	a0 02		ldy #$02			ldy 	#2 			 				; check the 2nd size >= 2nd index
.9985	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9987	d5 59		cmp $59,x			cmp 	NSMantissa0+1,x
.9989	90 39		bcc $99c4			bcc 	_VHBadIndex
.998b	64 36		stz $36				stz 	zTemp0 						; clear zTemp0 (if 1 index)
.998d	64 37		stz $37				stz 	zTemp0+1
.998f	b5 52		lda $52,x			lda 	NSStatus+2,x 				; if only one index provided, don't need to multiply
.9991	30 0e		bmi $99a1			bmi 	_VHNoMultiply
.9993	da		phx				phx
.9994	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; get 2nd index on stack
.9996	48		pha				pha
.9997	a0 02		ldy #$02			ldy 	#2 							; get 1st size in A
.9999	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.999b	1a		inc a				inc 	a 							; add 1 for zero base
.999c	fa		plx				plx
.999d	20 d1 9d	jsr $9dd1			jsr 	Multiply8x8 				; calculate -> Z0
.99a0	fa		plx				plx
.99a1					_VHNoMultiply:
.99a1	18		clc				clc
.99a2	a5 36		lda $36				lda 	zTemp0
.99a4	75 59		adc $59,x			adc 	NSMantissa0+1,x
.99a6	85 36		sta $36				sta 	zTemp0
.99a8	a5 37		lda $37				lda 	zTemp0+1
.99aa	69 00		adc #$00			adc 	#0
.99ac	85 37		sta $37				sta 	zTemp0+1
.99ae	b5 50		lda $50,x			lda 	NSStatus,x
.99b0	20 76 85	jsr $8576			jsr 	ScaleByBaseType
.99b3	18		clc				clc
.99b4	b2 3e		lda ($3e)			lda 	(zaTemp)
.99b6	65 36		adc $36				adc 	zTemp0
.99b8	95 58		sta $58,x			sta 	NSMantissa0,x
.99ba	a0 01		ldy #$01			ldy 	#1
.99bc	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99be	65 37		adc $37				adc 	zTemp0+1
.99c0	95 60		sta $60,x			sta 	NSMantissa1,x
.99c2	7a		ply				ply 								; restore position
.99c3	60		rts				rts
.99c4					_VHBadIndex:
.99c4	a9 17		lda #$17		lda	#23
.99c6	4c ff 8e	jmp $8eff		jmp	ErrorHandler
.99c9					_VHBadArray:
.99c9	a9 18		lda #$18		lda	#24
.99cb	4c ff 8e	jmp $8eff		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/abs.asm

.99ce					AbsUnary:
.99ce	fa		plx				plx 								; restore stack pos
.99cf	20 74 9d	jsr $9d74			jsr 	EvaluateNumber 				; get a float or int
.99d2	20 e6 8e	jsr $8ee6			jsr 	CheckRightBracket
.99d5	b5 50		lda $50,x			lda 	NSStatus,x 					; clear the sign bit
.99d7	29 7f		and #$7f			and 	#$7F
.99d9	95 50		sta $50,x			sta 	NSStatus,x
.99db	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/alloc.asm

.99dc					AllocUnary:
.99dc	fa		plx				plx 								; restore stack pos
.99dd	20 a6 9d	jsr $9da6			jsr 	Evaluate16BitInteger		; get bytes required.
.99e0	20 e6 8e	jsr $8ee6			jsr 	CheckRightBracket
.99e3	da		phx				phx 								; save X/Y
.99e4	5a		phy				phy
.99e5	8a		txa				txa 								; copy X into Y
.99e6	a8		tay				tay
.99e7	b9 60 00	lda $0060,y			lda		NSMantissa1,y 				; get size into XA
.99ea	aa		tax				tax
.99eb	b9 58 00	lda $0058,y			lda 	NSMantissa0,y
.99ee	20 fb 99	jsr $99fb			jsr 	AllocateXABytes 			; allocate memory
.99f1	99 58 00	sta $0058,y			sta 	NSMantissa0,y 				; write address out.
.99f4	8a		txa				txa 	 							; typing is 16 bit integer.
.99f5	99 60 00	sta $0060,y			sta 	NSMantissa1,y
.99f8	7a		ply				ply
.99f9	fa		plx				plx
.99fa	60		rts				rts
.99fb					AllocateXABytes:
.99fb	5a		phy				phy
.99fc	ac 0c 04	ldy $040c			ldy 	lowMemPtr 					; push current address on stack and to zTemp0
.99ff	84 36		sty $36				sty 	zTemp0
.9a01	5a		phy				phy
.9a02	ac 0d 04	ldy $040d			ldy 	lowMemPtr+1
.9a05	84 37		sty $37				sty 	zTemp0+1
.9a07	5a		phy				phy
.9a08	18		clc				clc 								; add to low memory pointer
.9a09	6d 0c 04	adc $040c			adc 	lowMemPtr
.9a0c	8d 0c 04	sta $040c			sta 	lowMemPtr
.9a0f	8a		txa				txa
.9a10	6d 0d 04	adc $040d			adc 	lowMemPtr+1
.9a13	8d 0d 04	sta $040d			sta 	lowMemPtr+1
.9a16	b0 2f		bcs $9a47			bcs 	CISSMemory
.9a18	20 39 9a	jsr $9a39			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.9a1b					_ClearMemory:
.9a1b	ad 0c 04	lda $040c			lda 	lowMemPtr 					; cleared all memory allocated
.9a1e	c5 36		cmp $36				cmp 	zTemp0
.9a20	d0 07		bne $9a29			bne 	_CMClearNext
.9a22	ad 0d 04	lda $040d			lda 	lowMemPtr+1
.9a25	c5 37		cmp $37				cmp 	zTemp0+1
.9a27	f0 0c		beq $9a35			beq 	_CMExit
.9a29					_CMClearNext:
.9a29	a9 00		lda #$00			lda 	#0 							; clear byte, advance to next.
.9a2b	92 36		sta ($36)			sta 	(zTemp0)
.9a2d	e6 36		inc $36				inc 	zTemp0
.9a2f	d0 ea		bne $9a1b			bne 	_ClearMemory
.9a31	e6 37		inc $37				inc		zTemp0+1
.9a33	80 e6		bra $9a1b			bra 	_ClearMemory
.9a35					_CMExit:
.9a35	fa		plx				plx
.9a36	68		pla				pla
.9a37	7a		ply				ply
.9a38	60		rts				rts
.9a39					CheckIdentifierStringSpace:
.9a39	48		pha				pha
.9a3a	ad 0d 04	lda $040d			lda 	lowMemPtr+1 				; get low memory pointer
.9a3d	18		clc				clc
.9a3e	69 02		adc #$02			adc 	#2 							; need at least 2 256 byte pages
.9a40	cd 0f 04	cmp $040f			cmp 	StringMemory+1 				; is it >= StringMemory
.9a43	b0 02		bcs $9a47			bcs 	CISSMemory
.9a45	68		pla				pla
.9a46	60		rts				rts
.9a47					CISSMemory:
.9a47	a9 06		lda #$06		lda	#6
.9a49	4c ff 8e	jmp $8eff		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/asc.asm

.9a4c					AscUnary:
.9a4c	fa		plx				plx 								; restore stack pos
.9a4d	20 7e 9d	jsr $9d7e			jsr 	EvaluateString 				; get a string
.9a50	b2 36		lda ($36)			lda 	(zTemp0)					; get/return first character
.9a52	20 28 9e	jsr $9e28			jsr 	NSMSetByte 					; ASC("") will return zero.
.9a55	20 e6 8e	jsr $8ee6			jsr 	CheckRightBracket
.9a58	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/deekpeek.asm

.9a59					PeekUnary:
.9a59	18		clc				clc
.9a5a	80 01		bra $9a5d			bra 	DPUnary
.9a5c					DeekUnary:
.9a5c	38		sec				sec
.9a5d					DPUnary:
.9a5d	fa		plx				plx 								; restore position.
.9a5e	08		php				php									; save on stack, CS = Deek, CC = Peek
.9a5f	20 a6 9d	jsr $9da6			jsr		Evaluate16BitInteger 		; address as constant.
.9a62	20 e6 8e	jsr $8ee6			jsr 	CheckRightBracket
.9a65	28		plp				plp 								; function back.
.9a66	a9 21		lda #$21			lda 	#NSBIsReference+NSTInteger+1 ; 1 byte read
.9a68	90 01		bcc $9a6b			bcc 	_DPUpdate
.9a6a	1a		inc a				inc 	a 							; 2 byte read
.9a6b					_DPUpdate:
.9a6b	95 50		sta $50,x			sta 	NSStatus,x 					; set to 1/2 byte reference.
.9a6d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/frac.asm

.9a6e					FracUnary:
.9a6e	fa		plx				plx 								; restore stack pos
.9a6f	20 74 9d	jsr $9d74			jsr 	EvaluateNumber 				; get a float or int
.9a72	20 e6 8e	jsr $8ee6			jsr 	CheckRightBracket
.9a75	b5 50		lda $50,x			lda 	NSStatus,x
.9a77	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9a79	f0 04		beq $9a7f			beq 	_IUZero
.9a7b	20 14 95	jsr $9514			jsr 	FloatFractionalPart 		; if so, get the fractional part.
.9a7e	60		rts				rts
.9a7f					_IUZero:
.9a7f	20 26 9e	jsr $9e26			jsr 	NSMSetZero
.9a82	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/int.asm

.9a83					IntUnary:
.9a83	fa		plx				plx 								; restore stack pos
.9a84	20 74 9d	jsr $9d74			jsr 	EvaluateNumber 				; get a float or int
.9a87	20 e6 8e	jsr $8ee6			jsr 	CheckRightBracket
.9a8a	b5 50		lda $50,x			lda 	NSStatus,x
.9a8c	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9a8e	f0 03		beq $9a93			beq 	_IUExit
.9a90	20 6c 95	jsr $956c			jsr 	FloatIntegerPart 			; if it is get the integer part.
.9a93					_IUExit:
.9a93	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/len.asm

.9a94					LenUnary:
.9a94	fa		plx				plx 								; restore stack pos
.9a95	20 7e 9d	jsr $9d7e			jsr 	EvaluateString 				; get a string
.9a98	5a		phy				phy
.9a99	a0 00		ldy #$00			ldy 	#0 							; find length
.9a9b					_LenFind:
.9a9b	b1 36		lda ($36),y			lda 	(zTemp0),y 					; look for trailing NULL.
.9a9d	f0 06		beq $9aa5			beq 	_LenExit
.9a9f	c8		iny				iny
.9aa0	d0 f9		bne $9a9b			bne 	_LenFind
.9aa2	4c a9 9f	jmp $9fa9			jmp 	RangeError 					; string > 255 - no trailing NULL.
.9aa5					_LenExit:
.9aa5	98		tya				tya		 							; return length
.9aa6	20 28 9e	jsr $9e28			jsr 	NSMSetByte
.9aa9	7a		ply				ply
.9aaa	20 e6 8e	jsr $8ee6			jsr 	CheckRightBracket
.9aad	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/minmax.asm

.9aae					Unary_Min:
.9aae	a9 01		lda #$01			lda 	#1
.9ab0	80 02		bra $9ab4			bra 	UnaryMinMaxMain
.9ab2					Unary_Max:
.9ab2	a9 ff		lda #$ff			lda 	#$FF 						; value from comparator to cause a write
.9ab4					UnaryMinMaxMain:
.9ab4	fa		plx				plx 								; get index on number stack
.9ab5	48		pha				pha 								; save comparator
.9ab6	20 6b 9d	jsr $9d6b			jsr 	EvaluateValue 				; get the first value.
.9ab9					_UMMMLoop:
.9ab9	b1 30		lda ($30),y			lda 	(codePtr),y
.9abb	c9 29		cmp #$29			cmp 	#KWD_RPAREN 				; if right bracket then done.
.9abd	f0 22		beq $9ae1			beq 	_UMMMDone
.9abf	20 ee 8e	jsr $8eee			jsr 	CheckComma 					; must be a comma
.9ac2	e8		inx				inx
.9ac3	20 6b 9d	jsr $9d6b			jsr 	EvaluateValue
.9ac6	ca		dex				dex
.9ac7	20 09 9e	jsr $9e09			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] (Compare is destructive)
.9aca	e8		inx				inx
.9acb	20 09 9e	jsr $9e09			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2], original
.9ace	e8		inx				inx
.9acf	20 b6 8f	jsr $8fb6			jsr 	CompareBaseCode 			; part of > = < etc. code, returns 255,0 or 1
.9ad2	ca		dex				dex
.9ad3	ca		dex				dex
.9ad4	85 36		sta $36				sta 	zTemp0 						; save required result
.9ad6	68		pla				pla 								; get and save comparator
.9ad7	48		pha				pha
.9ad8	c5 36		cmp $36				cmp 	zTemp0 						; if the comparator
.9ada	d0 dd		bne $9ab9			bne 	_UMMMLoop
.9adc	20 e4 9a	jsr $9ae4			jsr 	ExpCopyAboveDown 			; copy next up slot down
.9adf	80 d8		bra $9ab9			bra 	_UMMMLoop
.9ae1					_UMMMDone:
.9ae1	68		pla				pla 								; throw the comparator
.9ae2	c8		iny				iny 								; skip )
.9ae3	60		rts				rts
.9ae4					ExpCopyAboveDown:
.9ae4	b5 51		lda $51,x			lda 	NSStatus+1,x
.9ae6	95 50		sta $50,x			sta 	NSStatus,x
.9ae8	b5 79		lda $79,x			lda 	NSExponent+1,x
.9aea	95 78		sta $78,x			sta 	NSExponent,x
.9aec	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9aee	95 58		sta $58,x			sta 	NSMantissa0,x
.9af0	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9af2	95 60		sta $60,x			sta 	NSMantissa1,x
.9af4	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.9af6	95 68		sta $68,x			sta 	NSMantissa2,x
.9af8	b5 71		lda $71,x			lda 	NSMantissa3+1,x
.9afa	95 70		sta $70,x			sta 	NSMantissa3,x
.9afc	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/not.asm

.9afd					Unary_Not:
.9afd	fa		plx				plx
.9afe	20 93 9d	jsr $9d93			jsr 	EvaluateInteger 			; get integer
.9b01	20 e6 8e	jsr $8ee6			jsr 	CheckRightBracket
.9b04	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; zero mantissa ?
.9b07	f0 04		beq $9b0d			beq 	_NotZero
.9b09	20 26 9e	jsr $9e26			jsr 	NSMSetZero
.9b0c	60		rts				rts
.9b0d					_NotZero:
.9b0d	4c 6c 8f	jmp $8f6c			jmp 	ReturnTrue

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/rnd.asm

.9b10					Unary_Random:
.9b10	fa		plx				plx
.9b11	20 82 9b	jsr $9b82			jsr 	Random32Bit 				; get a random number
.9b14	20 6b 9b	jsr $9b6b			jsr 	URCopyToMantissa  			; put in mantissa
.9b17	b1 30		lda ($30),y			lda 	(codePtr),y
.9b19	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.9b1b	f0 08		beq $9b25			beq 	_URNoModulus 				; then we return a random 30 bit number.
.9b1d	e8		inx				inx
.9b1e	20 a6 9d	jsr $9da6			jsr 	Evaluate16BitInteger 		; put modulus value in +1
.9b21	ca		dex				dex
.9b22	20 be 90	jsr $90be			jsr 	IntegerModulusNoCheck 		; calculate modulus, so now 0 .. n-1
.9b25					_URNoModulus:
.9b25	74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer positive
.9b27	74 78		stz $78,x			stz 	NSExponent,x
.9b29	20 e6 8e	jsr $8ee6			jsr 	CheckRightBracket
.9b2c	60		rts				rts
.9b2d					Unary_Rnd:
.9b2d	fa		plx				plx
.9b2e	20 74 9d	jsr $9d74			jsr 	EvaluateNumber 				; number to use.
.9b31	20 e6 8e	jsr $8ee6			jsr 	CheckRightBracket 			; closing bracket
.9b34	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; if zero, then don't generate a new number
.9b37	f0 26		beq $9b5f			beq 	_URCopySeed
.9b39	b5 50		lda $50,x			lda 	NSStatus,x 					; if -ve, then seed using parameter
.9b3b	10 1f		bpl $9b5c			bpl 	_URDontSeed
.9b3d	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy - value to seed butchering it.
.9b3f	49 17		eor #$17			eor 	#$17
.9b41	8d 08 04	sta $0408			sta 	RandomSeed+0
.9b44	b5 60		lda $60,x			lda 	NSMantissa1,x
.9b46	49 a5		eor #$a5			eor 	#$A5
.9b48	8d 09 04	sta $0409			sta 	RandomSeed+1
.9b4b	b5 68		lda $68,x			lda 	NSMantissa2,x
.9b4d	49 c2		eor #$c2			eor 	#$C2
.9b4f	8d 0a 04	sta $040a			sta 	RandomSeed+2
.9b52	b5 70		lda $70,x			lda 	NSMantissa3,x
.9b54	49 9d		eor #$9d			eor 	#$9D
.9b56	8d 0b 04	sta $040b			sta 	RandomSeed+3
.9b59	20 82 9b	jsr $9b82			jsr 	Random32Bit
.9b5c					_URDontSeed:
.9b5c	20 82 9b	jsr $9b82			jsr 	Random32Bit 				; generate a number
.9b5f					_URCopySeed:
.9b5f	20 6b 9b	jsr $9b6b			jsr 	URCopyToMantissa 			; copy into mantissa
.9b62	a9 e2		lda #$e2			lda 	#-30 						; force into 0-1 range
.9b64	95 78		sta $78,x			sta 	NSExponent,x
.9b66	a9 08		lda #$08			lda 	#NSTFloat
.9b68	95 50		sta $50,x			sta 	NSStatus,x 					; positive float
.9b6a	60		rts				rts
.9b6b					URCopyToMantissa:
.9b6b	ad 08 04	lda $0408			lda 	RandomSeed+0
.9b6e	95 58		sta $58,x			sta 	NSMantissa0,x
.9b70	ad 09 04	lda $0409			lda 	RandomSeed+1
.9b73	95 60		sta $60,x			sta 	NSMantissa1,x
.9b75	ad 0a 04	lda $040a			lda 	RandomSeed+2
.9b78	95 68		sta $68,x			sta 	NSMantissa2,x
.9b7a	ad 0b 04	lda $040b			lda 	RandomSeed+3
.9b7d	29 3f		and #$3f			and 	#$3F 						; make legal mantissa
.9b7f	95 70		sta $70,x			sta 	NSMantissa3,x
.9b81	60		rts				rts
.9b82					Random32Bit:
.9b82	5a		phy				phy
.9b83	a0 07		ldy #$07			ldy 	#7 							; do it 7 times
.9b85	ad 08 04	lda $0408			lda 	RandomSeed+0 				; check the seed isn't zero
.9b88	d0 03		bne $9b8d			bne 	_Random1
.9b8a	a8		tay				tay 								; if so do it 256 times
.9b8b	a9 aa		lda #$aa			lda		#$AA 						; and use this to seed the seed....
.9b8d					_Random1:
.9b8d	0a		asl a				asl 	a 							; LSFR RNG
.9b8e	2e 09 04	rol $0409			rol 	RandomSeed+1
.9b91	2e 0a 04	rol $040a			rol 	RandomSeed+2
.9b94	2e 0b 04	rol $040b			rol 	RandomSeed+3
.9b97	90 02		bcc $9b9b			bcc 	_Random2
.9b99	49 c5		eor #$c5			eor 	#$C5
.9b9b					_Random2:
.9b9b	88		dey				dey
.9b9c	d0 ef		bne $9b8d			bne 	_Random1
.9b9e	8d 08 04	sta $0408			sta 	RandomSeed+0
.9ba1	7a		ply				ply
.9ba2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/sgn.asm

.9ba3					SgnUnary:
.9ba3	fa		plx				plx 								; restore stack pos
.9ba4	20 74 9d	jsr $9d74			jsr 	EvaluateNumber 				; get a float or int
.9ba7	20 e6 8e	jsr $8ee6			jsr 	CheckRightBracket
.9baa	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; if zero
.9bad	f0 0e		beq $9bbd			beq 	_SGZero  					; return Int Zero
.9baf	b5 50		lda $50,x			lda 	NSStatus,x 					; get status w/sign
.9bb1	48		pha				pha
.9bb2	a9 01		lda #$01			lda 	#1 							; set to 1
.9bb4	20 28 9e	jsr $9e28			jsr 	NSMSetByte
.9bb7	68		pla				pla
.9bb8	29 80		and #$80			and		#$80 						; copy the sign byte out
.9bba	95 50		sta $50,x			sta 	NSStatus,x  				; so it will be -1 or 1
.9bbc	60		rts				rts
.9bbd	20 26 9e	jsr $9e26	_SGZero:jsr 	NSMSetZero
.9bc0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/val.asm

.9bc1					ValUnary:
.9bc1	fa		plx				plx 								; restore stack pos
.9bc2	20 d7 9b	jsr $9bd7			jsr 	ValMainCode 				; do the main val() code
.9bc5	b0 01		bcs $9bc8			bcs 	_VUError 					; couldn't convert
.9bc7	60		rts				rts
.9bc8					_VUError:
.9bc8	4c ae 9f	jmp $9fae			jmp 	TypeError
.9bcb					IsValUnary:
.9bcb	fa		plx				plx 								; restore stack pos
.9bcc	20 d7 9b	jsr $9bd7			jsr 	ValMainCode 				; do the main val() code
.9bcf	b0 03		bcs $9bd4			bcs 	_VUBad
.9bd1	4c 6c 8f	jmp $8f6c			jmp 	ReturnTrue
.9bd4					_VUBad:
.9bd4	4c 77 8f	jmp $8f77			jmp 	ReturnFalse
.9bd7					ValMainCode:
.9bd7	20 7e 9d	jsr $9d7e			jsr 	EvaluateString 				; get a string
.9bda	20 e6 8e	jsr $8ee6			jsr 	CheckRightBracket 			; check right bracket present
.9bdd					ValEvaluateZTemp0:
.9bdd	5a		phy				phy
.9bde	b2 36		lda ($36)			lda 	(zTemp0) 					; check not empty string
.9be0	f0 17		beq $9bf9			beq 	_VMCFail2
.9be2	a0 ff		ldy #$ff			ldy 	#$FF 						; start position
.9be4	48		pha				pha 								; save first character
.9be5	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.9be7	d0 01		bne $9bea			bne 	_VMCStart
.9be9	c8		iny				iny 								; skip over -
.9bea					_VMCStart:
.9bea	38		sec				sec 								; initialise first time round.
.9beb					_VMCNext:
.9beb	c8		iny				iny 								; pre-increment
.9bec	b1 36		lda ($36),y			lda 	(zTemp0),y 					; next character = EOS ?
.9bee	f0 0c		beq $9bfc			beq 	_VMCSuccess 				; successful.
.9bf0	20 49 97	jsr $9749			jsr 	EncodeNumber 				; send it to the number-builder
.9bf3	90 03		bcc $9bf8			bcc 	_VMCFail 					; if failed, give up.
.9bf5	18		clc				clc 								; next time round, countinue
.9bf6	80 f3		bra $9beb			bra 	_VMCNext
.9bf8					_VMCFail:
.9bf8	68		pla				pla
.9bf9					_VMCFail2:
.9bf9	7a		ply				ply
.9bfa	38		sec				sec
.9bfb	60		rts				rts
.9bfc					_VMCSuccess:
.9bfc	a9 00		lda #$00			lda 	#0 							; construct final
.9bfe	20 49 97	jsr $9749			jsr 	EncodeNumber 				; by sending a duff value.
.9c01	68		pla				pla 								; if it was -ve
.9c02	c9 2d		cmp #$2d			cmp 	#"-"
.9c04	d0 03		bne $9c09			bne 	_VMCNotNegative
.9c06	20 e8 9d	jsr $9de8			jsr		NSMNegate 					; negate it.
.9c09					_VMCNotNegative:
.9c09	7a		ply				ply
.9c0a	18		clc				clc
.9c0b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/chr.asm

.9c0c					ChrUnary:
.9c0c	fa		plx				plx 								; restore stack pos
.9c0d	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger			; get value (chr$(0) returns an empty string)
.9c10	48		pha				pha
.9c11	20 e6 8e	jsr $8ee6			jsr 	CheckRightBracket
.9c14	a9 01		lda #$01			lda 	#1 							; allocate space for one char
.9c16	20 b8 a7	jsr $a7b8			jsr 	StringTempAllocate
.9c19	68		pla				pla 								; write number to it
.9c1a	20 f1 a7	jsr $a7f1			jsr 	StringTempWrite
.9c1d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/spc.asm

.9c1e					SpcUnary:
.9c1e	fa		plx				plx 								; restore stack pos
.9c1f	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger			; get value
.9c22	5a		phy				phy
.9c23	48		pha				pha 								; save count
.9c24	20 b8 a7	jsr $a7b8			jsr 	StringTempAllocate
.9c27	7a		ply				ply 								; to do count in Y
.9c28					_SpcLoop:
.9c28	c0 00		cpy #$00			cpy 	#0 							; copy Y spaces in.
.9c2a	f0 08		beq $9c34			beq 	_SpcExit
.9c2c	a9 20		lda #$20			lda 	#32
.9c2e	20 f1 a7	jsr $a7f1			jsr 	StringTempWrite
.9c31	88		dey				dey
.9c32	80 f4		bra $9c28			bra 	_SPCLoop
.9c34					_SpcExit:
.9c34	7a		ply				ply
.9c35	20 e6 8e	jsr $8ee6			jsr 	CheckRightBracket
.9c38	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/str.asm

.9c39					Unary_Str:
.9c39	fa		plx				plx
.9c3a	20 74 9d	jsr $9d74			jsr 	EvaluateNumber  			; get number
.9c3d	20 e6 8e	jsr $8ee6			jsr 	CheckRightBracket 			; closing bracket
.9c40	a9 05		lda #$05			lda 	#5 							; maximum decimals, from Basic816
.9c42	20 5b 9c	jsr $9c5b			jsr 	ConvertNumberToString 		; do the conversion.
.9c45	a9 21		lda #$21			lda		#33 						; create buffer
.9c47	20 b8 a7	jsr $a7b8			jsr 	StringTempAllocate 			; allocate memory
.9c4a	da		phx				phx  								; copy the converted string into the buffer.
.9c4b	a2 00		ldx #$00			ldx 	#0
.9c4d					_USCopy:
.9c4d	bd 49 06	lda $0649,x			lda 	DecimalBuffer,x
.9c50	20 f1 a7	jsr $a7f1			jsr 	StringTempWrite
.9c53	e8		inx				inx
.9c54	bd 49 06	lda $0649,x			lda 	DecimalBuffer,x
.9c57	d0 f4		bne $9c4d			bne 	_USCopy
.9c59	fa		plx				plx
.9c5a	60		rts				rts
.9c5b					ConvertNumberToString:
.9c5b	5a		phy				phy 								; save code position
.9c5c	8d 14 04	sta $0414			sta 	DecimalPlaces	 			; save number of DPs.
.9c5f	9c 15 04	stz $0415			stz 	dbOffset 					; offset into decimal buffer = start.
.9c62	b5 50		lda $50,x			lda 	NSStatus,x  				; is it -ve.
.9c64	10 09		bpl $9c6f			bpl 	_CNTSNotNegative
.9c66	29 7f		and #$7f			and 	#$7F 						; make +ve
.9c68	95 50		sta $50,x			sta 	NSStatus,x
.9c6a	a9 2d		lda #$2d			lda 	#"-"
.9c6c	20 d0 9c	jsr $9cd0			jsr 	WriteDecimalBuffer
.9c6f					_CNTSNotNegative:
.9c6f	b5 78		lda $78,x			lda 	NSExponent,x 				; check if decimal
.9c71	f0 12		beq $9c85			beq 	_CNTSNotFloat
.9c73	e8		inx				inx 								; round up so we don't get too many 6.999999
.9c74	a9 01		lda #$01			lda 	#1
.9c76	20 28 9e	jsr $9e28			jsr 	NSMSetByte
.9c79	ca		dex				dex
.9c7a	b5 78		lda $78,x			lda		NSExponent,x
.9c7c	95 79		sta $79,x			sta 	NSExponent+1,x
.9c7e	a9 08		lda #$08			lda 	#NSTFloat
.9c80	95 51		sta $51,x			sta 	NSStatus+1,x
.9c82	20 4e 94	jsr $944e			jsr 	FloatAdd
.9c85					_CNTSNotFloat:
.9c85	20 b2 9c	jsr $9cb2			jsr 	MakePlusTwoString 			; do the integer part.
.9c88	20 14 95	jsr $9514			jsr 	FloatFractionalPart 		; get the fractional part
.9c8b	20 c5 95	jsr $95c5			jsr 	NSNormalise					; normalise , exit if zero
.9c8e	f0 20		beq $9cb0			beq 	_CNTSExit
.9c90	a9 2e		lda #$2e			lda 	#"."
.9c92	20 d0 9c	jsr $9cd0			jsr 	WriteDecimalBuffer 			; write decimal place
.9c95					_CNTSDecimal:
.9c95	ce 14 04	dec $0414			dec 	DecimalPlaces 				; done all the decimals
.9c98	30 16		bmi $9cb0			bmi 	_CNTSExit
.9c9a	e8		inx				inx 								; x 10.0
.9c9b	a9 0a		lda #$0a			lda 	#10
.9c9d	20 28 9e	jsr $9e28			jsr 	NSMSetByte
.9ca0	a9 08		lda #$08			lda 	#NSTFloat
.9ca2	95 50		sta $50,x			sta 	NSStatus,x
.9ca4	ca		dex				dex
.9ca5	20 93 95	jsr $9593			jsr 	FloatMultiply
.9ca8	20 b2 9c	jsr $9cb2			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.9cab	20 14 95	jsr $9514			jsr 	FloatFractionalPart 		; get the fractional part
.9cae	80 e5		bra $9c95			bra 	_CNTSDecimal 				; keep going.
.9cb0					_CNTSExit:
.9cb0	7a		ply				ply
.9cb1	60		rts				rts
.9cb2					MakePlusTwoString:
.9cb2	da		phx				phx
.9cb3	20 09 9e	jsr $9e09			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.9cb6	e8		inx				inx 								; access it
.9cb7	e8		inx				inx
.9cb8	20 6c 95	jsr $956c			jsr 	FloatIntegerPart 			; make it an integer
.9cbb	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.9cbd	20 7e 93	jsr $937e			jsr 	ConvertInt32
.9cc0	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.9cc2					_MPTSCopy:
.9cc2	bd 27 06	lda $0627,x			lda 	NumberBuffer,x
.9cc5	20 d0 9c	jsr $9cd0			jsr 	WriteDecimalBuffer
.9cc8	e8		inx				inx
.9cc9	bd 27 06	lda $0627,x			lda 	NumberBuffer,x
.9ccc	d0 f4		bne $9cc2			bne 	_MPTSCopy
.9cce	fa		plx				plx
.9ccf	60		rts				rts
.9cd0					WriteDecimalBuffer:
.9cd0	da		phx				phx
.9cd1	ae 15 04	ldx $0415			ldx 	dbOffset
.9cd4	9d 49 06	sta $0649,x			sta 	DecimalBuffer,x
.9cd7	9e 4a 06	stz $064a,x			stz 	DecimalBuffer+1,x
.9cda	ee 15 04	inc $0415			inc 	dbOffset
.9cdd	fa		plx				plx
.9cde	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/substring.asm

.9cdf					Unary_Left:
.9cdf	fa		plx				plx
.9ce0	18		clc				clc 								; only one parameter
.9ce1	20 44 9d	jsr $9d44			jsr 	SubstringInitial 			; set up.
.9ce4	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; Param #1 is the length
.9ce6	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9ce8	74 59		stz $59,x			stz 	NSMantissa0+1,x 			; Start is zero.
.9cea	80 25		bra $9d11			bra 	SubstringMain
.9cec					Unary_Right:
.9cec	fa		plx				plx
.9ced	18		clc				clc 								; only one parameter
.9cee	20 44 9d	jsr $9d44			jsr 	SubstringInitial 			; set up.
.9cf1	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; length => param 2
.9cf3	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9cf5	b5 78		lda $78,x			lda 	NSExponent,x 				; total length
.9cf7	f5 59		sbc $59,x			sbc 	NSMantissa0+1,x 			; length - required.
.9cf9	b0 02		bcs $9cfd			bcs 	_URNotUnderflow
.9cfb	a9 00		lda #$00			lda 	#0 							; start from the beginning, as something like right$("AB",3)
.9cfd					_URNotUnderFlow:
.9cfd	95 59		sta $59,x			sta 	NSMantissa0+1,x 			; this is the start position
.9cff	80 10		bra $9d11			bra 	SubStringMain
.9d01					Unary_Mid:
.9d01	fa		plx				plx
.9d02	38		sec				sec 								; two parameters
.9d03	20 44 9d	jsr $9d44			jsr 	SubstringInitial 			; set up.
.9d06	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; first parameter is zero ?
.9d08	f0 04		beq $9d0e			beq 	_UMError
.9d0a	d6 59		dec $59,x			dec 	NSMantissa0+1,x				; reduce initial offset by 1 as MID$(a$,1..) is actually the first character
.9d0c	80 03		bra $9d11			bra 	SubStringMain
.9d0e					_UMError:
.9d0e	4c b3 9f	jmp $9fb3			jmp 	ArgumentError
.9d11					SubStringMain:
.9d11	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; is the initial offset >= the length
.9d13	d5 78		cmp $78,x			cmp 	NSExponent,x
.9d15	b0 27		bcs $9d3e			bcs 	_SSMNull 					; if so, return an empty string.
.9d17	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; if copy count is zero
.9d19	f0 23		beq $9d3e			beq 	_SSMNull 					; return empty string.
.9d1b	18		clc				clc 								; add the offset +1 to the address and
.9d1c	b5 58		lda $58,x			lda	 	NSMantissa0,x 				; put in zTemp, this is the start of the substring to copy.
.9d1e	75 59		adc $59,x			adc 	NSMantissa0+1,x
.9d20	85 36		sta $36				sta 	zTemp0
.9d22	b5 60		lda $60,x			lda	 	NSMantissa1,x
.9d24	69 00		adc #$00			adc 	#0
.9d26	85 37		sta $37				sta 	zTemp0+1
.9d28					_SSMNoCarry:
.9d28	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; characters required.
.9d2a	20 b8 a7	jsr $a7b8			jsr 	StringTempAllocate 			; allocate that many characters
.9d2d	5a		phy				phy 								; save Y
.9d2e	a0 00		ldy #$00			ldy 	#0 							; start copying in.
.9d30					_SSMCopy:
.9d30	b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next character
.9d32	f0 08		beq $9d3c			beq 	_SSMEString 				; no more to copy
.9d34	20 f1 a7	jsr $a7f1			jsr 	StringTempWrite 			; and write it out.
.9d37	c8		iny				iny
.9d38	d6 5a		dec $5a,x			dec 	NSMantissa0+2,x
.9d3a	d0 f4		bne $9d30			bne 	_SSMCopy
.9d3c					_SSMEString:
.9d3c	7a		ply				ply
.9d3d					_SSMExit:
.9d3d	60		rts				rts
.9d3e					_SSMNull:
.9d3e	a9 00		lda #$00			lda 	#0
.9d40	20 b8 a7	jsr $a7b8			jsr 	StringTempAllocate
.9d43	60		rts				rts
.9d44					SubstringInitial:
.9d44	da		phx				phx 								; save initial stack position
.9d45	08		php				php 								; save carry on stack indicating 2 parameters
.9d46	20 7e 9d	jsr $9d7e			jsr 	EvaluateString 				; get a string
.9d49	5a		phy				phy 								; calculate length to exponent.
.9d4a	a0 ff		ldy #$ff			ldy 	#$FF
.9d4c					_SIFindLength:
.9d4c	c8		iny				iny
.9d4d	b1 36		lda ($36),y			lda 	(zTemp0),y
.9d4f	d0 fb		bne $9d4c			bne 	_SIFindLength
.9d51	98		tya				tya
.9d52	95 78		sta $78,x			sta 	NSExponent,x
.9d54	7a		ply				ply
.9d55	e8		inx				inx
.9d56	20 ee 8e	jsr $8eee			jsr 	CheckComma 					; comma next
.9d59	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger 		; get next parameter
.9d5c	28		plp				plp 								; is it the last parameter ?
.9d5d	90 07		bcc $9d66			bcc 	_SSIExit 					; if so, exit.
.9d5f	e8		inx				inx
.9d60	20 ee 8e	jsr $8eee			jsr 	CheckComma 					; comma next
.9d63	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger 		; get last parameter
.9d66					_SSIExit:
.9d66	fa		plx				plx
.9d67	20 e6 8e	jsr $8ee6			jsr 	CheckRightBracket 			; check closing bracket
.9d6a	60		rts				rts 								; exit

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/exprhelper.asm

.9d6b					EvaluateValue:
.9d6b	48		pha				pha
.9d6c	20 03 94	jsr $9403			jsr		EvaluateExpression 			; expression
.9d6f	20 c6 96	jsr $96c6			jsr 	Dereference					; derefernce it
.9d72	68		pla				pla
.9d73	60		rts				rts
.9d74					EvaluateNumber:
.9d74	20 6b 9d	jsr $9d6b			jsr 	EvaluateValue 				; get a value
.9d77	b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.9d79	29 10		and #$10			and 	#NSBIsString
.9d7b	d0 13		bne $9d90			bne 	HelperTypeError
.9d7d	60		rts				rts
.9d7e					EvaluateString:
.9d7e	20 6b 9d	jsr $9d6b			jsr 	EvaluateValue 				; get a value
.9d81	b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.9d83	29 10		and #$10			and 	#NSBIsString
.9d85	f0 09		beq $9d90			beq 	HelperTypeError
.9d87					CopyAddressToTemp0:
.9d87	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address -> zTemp0
.9d89	85 36		sta $36				sta 	zTemp0 						; (so we can do something with it)
.9d8b	b5 60		lda $60,x			lda 	NSMantissa1,x
.9d8d	85 37		sta $37				sta 	zTemp0+1
.9d8f	60		rts				rts
.9d90					HelperTypeError:
.9d90	4c ae 9f	jmp $9fae			jmp 	TypeError
.9d93					EvaluateInteger:
.9d93	20 74 9d	jsr $9d74			jsr 	EvaluateNumber
.9d96	b5 78		lda $78,x			lda 	NSExponent,x 				; check exponent is zero
.9d98	d0 09		bne $9da3			bne 	HelperValueError 			; if not, it's a float.
.9d9a	60		rts				rts
.9d9b					EvaluateUnsignedInteger:
.9d9b	20 93 9d	jsr $9d93			jsr 	EvaluateInteger 			; check integer is +ve
.9d9e	b5 50		lda $50,x			lda 	NSStatus,x
.9da0	30 01		bmi $9da3			bmi 	HelperValueError
.9da2	60		rts				rts
.9da3					HelperValueError:
.9da3	4c b3 9f	jmp $9fb3			jmp 	ArgumentError
.9da6					Evaluate16BitInteger:
.9da6	20 9b 9d	jsr $9d9b			jsr	 	EvaluateUnsignedInteger		; get integer
.9da9	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9dab	15 68		ora $68,x			ora 	NSMantissa2,x
.9dad	d0 f4		bne $9da3			bne 	HelperValueError
.9daf	60		rts				rts
.9db0					Evaluate16BitIntegerSigned:
.9db0	20 93 9d	jsr $9d93			jsr	 	EvaluateInteger				; get integer
.9db3	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9db5	15 68		ora $68,x			ora 	NSMantissa2,x
.9db7	d0 ea		bne $9da3			bne 	HelperValueError
.9db9	b5 50		lda $50,x			lda 	NSStatus,x 					; signed ?
.9dbb	10 03		bpl $9dc0			bpl 	_EISNotSigned
.9dbd	20 ef 9d	jsr $9def			jsr 	NSMNegateMantissa 			; makes it an actual 2's complement value.
.9dc0					_EISNotSigned:
.9dc0	60		rts				rts
.9dc1					Evaluate8BitInteger:
.9dc1	20 9b 9d	jsr $9d9b			jsr	 	EvaluateUnsignedInteger 	; get an integer
.9dc4	d0 dd		bne $9da3			bne 	HelperValueError
.9dc6	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 1, 2 & 3 must be zero
.9dc8	15 68		ora $68,x			ora 	NSMantissa2,x
.9dca	15 60		ora $60,x			ora 	NSMantissa1,x
.9dcc	d0 d5		bne $9da3			bne 	HelperValueError
.9dce	b5 58		lda $58,x			lda 	NSMantissa0,x
.9dd0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/mult8x8.asm

.9dd1					Multiply8x8:
.9dd1	4a		lsr a		  		lsr 	a  							; prime the carry bit for the loop
.9dd2	85 36		sta $36			  	sta 	zTemp0
.9dd4	86 37		stx $37				stx 	zTemp0+1
.9dd6	a9 00		lda #$00			lda 	#0
.9dd8	a2 08		ldx #$08			ldx 	#8
.9dda					_M88Loop:
.9dda	90 03		bcc $9ddf			bcc 	_M88NoAdd
.9ddc	18		clc				clc
.9ddd	65 37		adc $37				adc 	zTemp0+1
.9ddf					_M88NoAdd:
.9ddf	6a		ror a				ror 	a
.9de0	66 36		ror $36				ror 	zTemp0  					; pull another bit out for the next iteration
.9de2	ca		dex				dex         						; inc/dec don't modify carry; only shifts and adds do
.9de3	d0 f5		bne $9dda			bne 	_M88Loop
.9de5	85 37		sta $37				sta 	zTemp0+1 					; store high 8 bits.
.9de7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/utility.asm

.9de8					NSMNegate:
.9de8	b5 50		lda $50,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.9dea	49 80		eor #$80			eor 	#NSBIsNegative  			; toggle the negative flag
.9dec	95 50		sta $50,x			sta 	NSStatus,x
.9dee	60		rts				rts
.9def					NSMNegateMantissa:
.9def	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.9df0	a9 00		lda #$00			lda 	#0
.9df2	f5 58		sbc $58,x			sbc 	NSMantissa0,x
.9df4	95 58		sta $58,x			sta 	NSMantissa0,x
.9df6	a9 00		lda #$00			lda 	#0
.9df8	f5 60		sbc $60,x			sbc 	NSMantissa1,x
.9dfa	95 60		sta $60,x			sta 	NSMantissa1,x
.9dfc	a9 00		lda #$00			lda 	#0
.9dfe	f5 68		sbc $68,x			sbc 	NSMantissa2,x
.9e00	95 68		sta $68,x			sta 	NSMantissa2,x
.9e02	a9 00		lda #$00			lda 	#0
.9e04	f5 70		sbc $70,x			sbc 	NSMantissa3,x
.9e06	95 70		sta $70,x			sta 	NSMantissa3,x
.9e08	60		rts				rts
.9e09					NSMShiftUpTwo:
.9e09	b5 58		lda $58,x			lda 	NSMantissa0,x
.9e0b	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9e0d	b5 60		lda $60,x			lda 	NSMantissa1,x
.9e0f	95 62		sta $62,x			sta 	NSMantissa1+2,x
.9e11	b5 68		lda $68,x			lda 	NSMantissa2,x
.9e13	95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.9e15	b5 70		lda $70,x			lda 	NSMantissa3,x
.9e17	95 72		sta $72,x			sta 	NSMantissa3+2,x
.9e19	b5 78		lda $78,x			lda 	NSExponent,x
.9e1b	95 7a		sta $7a,x			sta 	NSExponent+2,x
.9e1d	b5 50		lda $50,x			lda 	NSStatus,x
.9e1f	95 52		sta $52,x			sta 	NSStatus+2,x
.9e21	60		rts				rts
.9e22					NSMSetZeroMantissaOnly:
.9e22	a9 00		lda #$00			lda 	#0
.9e24	80 06		bra $9e2c			bra 	NSMSetMantissa
.9e26					NSMSetZero:
.9e26	a9 00		lda #$00			lda 	#0
.9e28					NSMSetByte:
.9e28	74 78		stz $78,x			stz 	NSExponent,x 				; zero exponent, as integer.
.9e2a	74 50		stz $50,x			stz 	NSStatus,x 					; status zero (integer)
.9e2c					NSMSetMantissa:
.9e2c	95 58		sta $58,x			sta 	NSMantissa0,x 				; mantissa
.9e2e	74 60		stz $60,x			stz 	NSMantissa1,x
.9e30	74 68		stz $68,x			stz 	NSMantissa2,x
.9e32	74 70		stz $70,x			stz 	NSMantissa3,x
.9e34	60		rts				rts
.9e35					NSMShiftLeft:
.9e35	18		clc				clc
.9e36					NSMRotateLeft:
.9e36	36 58		rol $58,x			rol 	NSMantissa0,x
.9e38	36 60		rol $60,x			rol		NSMantissa1,x
.9e3a	36 68		rol $68,x			rol		NSMantissa2,x
.9e3c	36 70		rol $70,x			rol		NSMantissa3,x
.9e3e	60		rts				rts
.9e3f					NSMShiftRight:
.9e3f	56 70		lsr $70,x			lsr 	NSMantissa3,x
.9e41	76 68		ror $68,x			ror		NSMantissa2,x
.9e43	76 60		ror $60,x			ror		NSMantissa1,x
.9e45	76 58		ror $58,x			ror		NSMantissa0,x
.9e47	60		rts				rts
.9e48					NSMIsZero:
.9e48	b5 70		lda $70,x			lda 	NSMantissa3,x
.9e4a	15 68		ora $68,x			ora		NSMantissa2,x
.9e4c	15 60		ora $60,x			ora		NSMantissa1,x
.9e4e	15 58		ora $58,x			ora		NSMantissa0,x
.9e50	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.asm

.9e51					TickHandler:
.9e51	5a		phy				phy 								; need to preserve Y
.9e52	20 1b 80	jsr $801b			jsr 	SNDUpdate 					; update sound
.9e55	7a		ply				ply
.9e56	60		rts				rts
.065c					LastTick:
>065c							.fill 		1

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/asmcore.asm

.9e57					Assemble_ora:
.9e57	20 b7 80	jsr $80b7		jsr	AssembleGroup1
>9e5a	01					.byte $01
.9e5b					Assemble_and:
.9e5b	20 b7 80	jsr $80b7		jsr	AssembleGroup1
>9e5e	21					.byte $21
.9e5f					Assemble_eor:
.9e5f	20 b7 80	jsr $80b7		jsr	AssembleGroup1
>9e62	41					.byte $41
.9e63					Assemble_adc:
.9e63	20 b7 80	jsr $80b7		jsr	AssembleGroup1
>9e66	61					.byte $61
.9e67					Assemble_sta:
.9e67	20 b7 80	jsr $80b7		jsr	AssembleGroup1
>9e6a	81					.byte $81
.9e6b					Assemble_lda:
.9e6b	20 b7 80	jsr $80b7		jsr	AssembleGroup1
>9e6e	a1					.byte $a1
.9e6f					Assemble_cmp:
.9e6f	20 b7 80	jsr $80b7		jsr	AssembleGroup1
>9e72	c1					.byte $c1
.9e73					Assemble_sbc:
.9e73	20 b7 80	jsr $80b7		jsr	AssembleGroup1
>9e76	e1					.byte $e1
.9e77					Assemble_asl:
.9e77	20 be 80	jsr $80be		jsr	AssembleGroup2
>9e7a	02					.byte $02
>9e7b	75					.byte $75
.9e7c					Assemble_rol:
.9e7c	20 be 80	jsr $80be		jsr	AssembleGroup2
>9e7f	22					.byte $22
>9e80	75					.byte $75
.9e81					Assemble_lsr:
.9e81	20 be 80	jsr $80be		jsr	AssembleGroup2
>9e84	42					.byte $42
>9e85	75					.byte $75
.9e86					Assemble_ror:
.9e86	20 be 80	jsr $80be		jsr	AssembleGroup2
>9e89	62					.byte $62
>9e8a	75					.byte $75
.9e8b					Assemble_stx:
.9e8b	20 be 80	jsr $80be		jsr	AssembleGroup2
>9e8e	82					.byte $82
>9e8f	50					.byte $50
.9e90					Assemble_ldx:
.9e90	20 be 80	jsr $80be		jsr	AssembleGroup2
>9e93	a2					.byte $a2
>9e94	d0					.byte $d0
.9e95					Assemble_dec:
.9e95	20 be 80	jsr $80be		jsr	AssembleGroup2
>9e98	c2					.byte $c2
>9e99	55					.byte $55
.9e9a					Assemble_inc:
.9e9a	20 be 80	jsr $80be		jsr	AssembleGroup2
>9e9d	e2					.byte $e2
>9e9e	55					.byte $55
.9e9f					Assemble_stz:
.9e9f	20 be 80	jsr $80be		jsr	AssembleGroup2
>9ea2	60					.byte $60
>9ea3	44					.byte $44
.9ea4					Assemble_bit:
.9ea4	20 be 80	jsr $80be		jsr	AssembleGroup2
>9ea7	20					.byte $20
>9ea8	55					.byte $55
.9ea9					Assemble_sty:
.9ea9	20 be 80	jsr $80be		jsr	AssembleGroup2
>9eac	80					.byte $80
>9ead	54					.byte $54
.9eae					Assemble_ldy:
.9eae	20 be 80	jsr $80be		jsr	AssembleGroup2
>9eb1	a0					.byte $a0
>9eb2	d5					.byte $d5
.9eb3					Assemble_cpy:
.9eb3	20 be 80	jsr $80be		jsr	AssembleGroup2
>9eb6	c0					.byte $c0
>9eb7	d4					.byte $d4
.9eb8					Assemble_cpx:
.9eb8	20 be 80	jsr $80be		jsr	AssembleGroup2
>9ebb	e0					.byte $e0
>9ebc	d0					.byte $d0
.9ebd					Assemble_tsb:
.9ebd	20 be 80	jsr $80be		jsr	AssembleGroup2
>9ec0	00					.byte $00
>9ec1	50					.byte $50
.9ec2					Assemble_trb:
.9ec2	20 be 80	jsr $80be		jsr	AssembleGroup2
>9ec5	10					.byte $10
>9ec6	50					.byte $50
.9ec7					Assemble_jsr:
.9ec7	20 be 80	jsr $80be		jsr	AssembleGroup2
>9eca	14					.byte $14
>9ecb	10					.byte $10
.9ecc					Assemble_jmp:
.9ecc	20 be 80	jsr $80be		jsr	AssembleGroup2
>9ecf	40					.byte $40
>9ed0	10					.byte $10
.9ed1					Assemble_bpl:
.9ed1	20 0f 81	jsr $810f		jsr	AssembleGroup3
>9ed4	10					.byte $10
.9ed5					Assemble_bmi:
.9ed5	20 0f 81	jsr $810f		jsr	AssembleGroup3
>9ed8	30					.byte $30
.9ed9					Assemble_bvc:
.9ed9	20 0f 81	jsr $810f		jsr	AssembleGroup3
>9edc	50					.byte $50
.9edd					Assemble_bvs:
.9edd	20 0f 81	jsr $810f		jsr	AssembleGroup3
>9ee0	70					.byte $70
.9ee1					Assemble_bcc:
.9ee1	20 0f 81	jsr $810f		jsr	AssembleGroup3
>9ee4	90					.byte $90
.9ee5					Assemble_bcs:
.9ee5	20 0f 81	jsr $810f		jsr	AssembleGroup3
>9ee8	b0					.byte $b0
.9ee9					Assemble_bne:
.9ee9	20 0f 81	jsr $810f		jsr	AssembleGroup3
>9eec	d0					.byte $d0
.9eed					Assemble_beq:
.9eed	20 0f 81	jsr $810f		jsr	AssembleGroup3
>9ef0	f0					.byte $f0
.9ef1					Assemble_bra:
.9ef1	20 0f 81	jsr $810f		jsr	AssembleGroup3
>9ef4	80					.byte $80
.9ef5					Assemble_brk:
.9ef5	20 43 81	jsr $8143		jsr	AssembleGroup4
>9ef8	00					.byte $00
.9ef9					Assemble_php:
.9ef9	20 43 81	jsr $8143		jsr	AssembleGroup4
>9efc	08					.byte $08
.9efd					Assemble_clc:
.9efd	20 43 81	jsr $8143		jsr	AssembleGroup4
>9f00	18					.byte $18
.9f01					Assemble_plp:
.9f01	20 43 81	jsr $8143		jsr	AssembleGroup4
>9f04	28					.byte $28
.9f05					Assemble_sec:
.9f05	20 43 81	jsr $8143		jsr	AssembleGroup4
>9f08	38					.byte $38
.9f09					Assemble_rti:
.9f09	20 43 81	jsr $8143		jsr	AssembleGroup4
>9f0c	40					.byte $40
.9f0d					Assemble_pha:
.9f0d	20 43 81	jsr $8143		jsr	AssembleGroup4
>9f10	48					.byte $48
.9f11					Assemble_cli:
.9f11	20 43 81	jsr $8143		jsr	AssembleGroup4
>9f14	58					.byte $58
.9f15					Assemble_phy:
.9f15	20 43 81	jsr $8143		jsr	AssembleGroup4
>9f18	5a					.byte $5a
.9f19					Assemble_rts:
.9f19	20 43 81	jsr $8143		jsr	AssembleGroup4
>9f1c	60					.byte $60
.9f1d					Assemble_pla:
.9f1d	20 43 81	jsr $8143		jsr	AssembleGroup4
>9f20	68					.byte $68
.9f21					Assemble_sei:
.9f21	20 43 81	jsr $8143		jsr	AssembleGroup4
>9f24	78					.byte $78
.9f25					Assemble_ply:
.9f25	20 43 81	jsr $8143		jsr	AssembleGroup4
>9f28	7a					.byte $7a
.9f29					Assemble_dey:
.9f29	20 43 81	jsr $8143		jsr	AssembleGroup4
>9f2c	88					.byte $88
.9f2d					Assemble_txa:
.9f2d	20 43 81	jsr $8143		jsr	AssembleGroup4
>9f30	8a					.byte $8a
.9f31					Assemble_tya:
.9f31	20 43 81	jsr $8143		jsr	AssembleGroup4
>9f34	98					.byte $98
.9f35					Assemble_txs:
.9f35	20 43 81	jsr $8143		jsr	AssembleGroup4
>9f38	9a					.byte $9a
.9f39					Assemble_tay:
.9f39	20 43 81	jsr $8143		jsr	AssembleGroup4
>9f3c	a8					.byte $a8
.9f3d					Assemble_tax:
.9f3d	20 43 81	jsr $8143		jsr	AssembleGroup4
>9f40	aa					.byte $aa
.9f41					Assemble_clv:
.9f41	20 43 81	jsr $8143		jsr	AssembleGroup4
>9f44	b8					.byte $b8
.9f45					Assemble_tsx:
.9f45	20 43 81	jsr $8143		jsr	AssembleGroup4
>9f48	ba					.byte $ba
.9f49					Assemble_iny:
.9f49	20 43 81	jsr $8143		jsr	AssembleGroup4
>9f4c	c8					.byte $c8
.9f4d					Assemble_dex:
.9f4d	20 43 81	jsr $8143		jsr	AssembleGroup4
>9f50	ca					.byte $ca
.9f51					Assemble_cld:
.9f51	20 43 81	jsr $8143		jsr	AssembleGroup4
>9f54	d8					.byte $d8
.9f55					Assemble_phx:
.9f55	20 43 81	jsr $8143		jsr	AssembleGroup4
>9f58	da					.byte $da
.9f59					Assemble_stp:
.9f59	20 43 81	jsr $8143		jsr	AssembleGroup4
>9f5c	db					.byte $db
.9f5d					Assemble_inx:
.9f5d	20 43 81	jsr $8143		jsr	AssembleGroup4
>9f60	e8					.byte $e8
.9f61					Assemble_nop:
.9f61	20 43 81	jsr $8143		jsr	AssembleGroup4
>9f64	ea					.byte $ea
.9f65					Assemble_sed:
.9f65	20 43 81	jsr $8143		jsr	AssembleGroup4
>9f68	f8					.byte $f8
.9f69					Assemble_plx:
.9f69	20 43 81	jsr $8143		jsr	AssembleGroup4
>9f6c	fa					.byte $fa

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/constants.asm

.9f6d					DecimalScalarTable:
>9f6d	66 66 66 66				.dword $66666666 ; 0.1
>9f71	de					.byte $de
>9f72	1f 85 eb 51				.dword $51eb851f ; 0.01
>9f76	db					.byte $db
>9f77	4c 37 89 41				.dword $4189374c ; 0.001
>9f7b	d8					.byte $d8
>9f7c	ac 8b db 68				.dword $68db8bac ; 0.0001
>9f80	d4					.byte $d4
>9f81	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>9f85	d1					.byte $d1
>9f86	83 de 1b 43				.dword $431bde83 ; 1e-06
>9f8a	ce					.byte $ce
>9f8b	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>9f8f	ca					.byte $ca
>9f90	89 3b e6 55				.dword $55e63b89 ; 1e-08
>9f94	c7					.byte $c7
>9f95	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>9f99	c4					.byte $c4
>9f9a	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>9f9e	c0					.byte $c0
>9f9f	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>9fa3	bd					.byte $bd

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.asm

.9fa4					SyntaxError:
.9fa4	a9 02		lda #$02		lda	#2
.9fa6	4c ff 8e	jmp $8eff		jmp	ErrorHandler
.9fa9					RangeError:
.9fa9	a9 04		lda #$04		lda	#4
.9fab	4c ff 8e	jmp $8eff		jmp	ErrorHandler
.9fae					TypeError:
.9fae	a9 05		lda #$05		lda	#5
.9fb0	4c ff 8e	jmp $8eff		jmp	ErrorHandler
.9fb3					ArgumentError:
.9fb3	a9 07		lda #$07		lda	#7
.9fb5	4c ff 8e	jmp $8eff		jmp	ErrorHandler
.9fb8					NotDoneError:
.9fb8	a9 0c		lda #$0c		lda	#12
.9fba	4c ff 8e	jmp $8eff		jmp	ErrorHandler
.9fbd					ErrorText:
>9fbd	42 72 65 61 6b 00			.text	"Break",0
>9fc3	53 79 6e 74 61 78 20 65			.text	"Syntax error",0
>9fcb	72 72 6f 72 00
>9fd0	44 69 76 69 73 69 6f 6e			.text	"Division by zero",0
>9fd8	20 62 79 20 7a 65 72 6f 00
>9fe1	4f 75 74 20 6f 66 20 52			.text	"Out of Range",0
>9fe9	61 6e 67 65 00
>9fee	54 79 70 65 20 6d 69 73			.text	"Type mismatch",0
>9ff6	6d 61 74 63 68 00
>9ffc	4f 75 74 20 6f 66 20 6d			.text	"Out of memory",0
>a004	65 6d 6f 72 79 00
>a00a	49 6c 6c 65 67 61 6c 20			.text	"Illegal argument",0
>a012	61 72 67 75 6d 65 6e 74 00
>a01b	53 74 6f 70 00				.text	"Stop",0
>a020	53 74 72 69 6e 67 20 74			.text	"String too long",0
>a028	6f 6f 20 6c 6f 6e 67 00
>a030	41 73 73 65 72 74 69 6f			.text	"Assertion failed",0
>a038	6e 20 66 61 69 6c 65 64 00
>a041	4f 75 74 20 6f 66 20 64			.text	"Out of data",0
>a049	61 74 61 00
>a04d	55 6e 69 6d 70 6c 65 6d			.text	"Unimplemented",0
>a055	65 6e 74 65 64 00
>a05b	4e 6f 20 73 75 63 68 20			.text	"No such line number",0
>a063	6c 69 6e 65 20 6e 75 6d 62 65 72 00
>a06f	52 65 74 75 72 6e 20 77			.text	"Return without Gosub",0
>a077	69 74 68 6f 75 74 20 47 6f 73 75 62 00
>a084	55 6e 74 69 6c 20 77 69			.text	"Until without Repeat",0
>a08c	74 68 6f 75 74 20 52 65 70 65 61 74 00
>a099	57 65 6e 64 20 77 69 74			.text	"Wend without While",0
>a0a1	68 6f 75 74 20 57 68 69 6c 65 00
>a0ac	4e 65 78 74 20 77 69 74			.text	"Next without For",0
>a0b4	68 6f 75 74 20 46 6f 72 00
>a0bd	42 41 53 49 43 20 53 74			.text	"BASIC Stack full",0
>a0c5	61 63 6b 20 66 75 6c 6c 00
>a0ce	4f 70 65 6e 20 53 74 72			.text	"Open Structure",0
>a0d6	75 63 74 75 72 65 00
>a0dd	45 6e 64 50 72 6f 63 20			.text	"EndProc without call",0
>a0e5	77 69 74 68 6f 75 74 20 63 61 6c 6c 00
>a0f2	41 72 72 61 79 20 61 6c			.text	"Array already defined",0
>a0fa	72 65 61 64 79 20 64 65 66 69 6e 65 64 00
>a108	41 72 72 61 79 20 73 69			.text	"Array size",0
>a110	7a 65 00
>a113	42 61 64 20 61 72 72 61			.text	"Bad array index",0
>a11b	79 20 69 6e 64 65 78 00
>a123	41 72 72 61 79 20 6e 6f			.text	"Array not declared",0
>a12b	74 20 64 65 63 6c 61 72 65 64 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/timestamp.asm

>a136	41 6c 70 68 61 20 31 33			.text "Alpha 13 built 08-Dec-22. "
>a13e	20 62 75 69 6c 74 20 30 38 2d 44 65 63 2d 32 32
>a14e	2e 20

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcommand.asm

.a150					RectangleCommand:
.a150	a9 44		lda #$44			lda 	#GCMD_FrameRect				; frame rectangle
.a152	80 02		bra $a156			bra 	ShapeDrawCmd
.a154					CircleCommand:
.a154	a9 48		lda #$48			lda 	#GCMD_FrameCircle 				; framed circle
.a156					ShapeDrawCmd:
.a156	20 e0 a1	jsr $a1e0			jsr 	RunGraphicsCommand
.a159					ShapeDraw:
.a159	0d 5e 06	ora $065e			ora 	gxFillSolid  				; adjust AXY for solid fill.
.a15c	4c d4 a1	jmp $a1d4			jmp 	ExecuteGraphicCommand	 	; and complete
.a15f					SpriteCommand:
.a15f	a2 00		ldx #$00			ldx 	#0
.a161	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger 		; get image number.
.a164	5a		phy				phy
.a165	a9 0e		lda #$0e			lda 	#GCMD_SpriteUse 			; use that image.
.a167	a6 58		ldx $58				ldx 	NSMantissa0
.a169	e0 40		cpx #$40			cpx 	#64 						; 0-63 only
.a16b	b0 0d		bcs $a17a			bcs 	_SCRange
.a16d	a0 ff		ldy #$ff			ldy 	#255
.a16f	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a172	a9 52		lda #$52			lda 	#GCMD_SpriteMove
.a174	7a		ply				ply
.a175	20 e0 a1	jsr $a1e0			jsr 	RunGraphicsCommand
.a178	80 5a		bra $a1d4			bra 	ExecuteGraphicCommand
.a17a					_SCRange:
.a17a	4c a9 9f	jmp $9fa9			jmp 	RangeError
.a17d					ImageCommand:
.a17d	a2 00		ldx #$00			ldx 	#0
.a17f	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger 		; get image number.
.a182	20 e0 a1	jsr $a1e0			jsr 	RunGraphicsCommand
.a185					ImageRunDraw:
.a185	09 40		ora #$40			ora 	#GCMD_Move					; move cursor
.a187	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a18a	ad 64 06	lda $0664			lda 	gxDrawScale
.a18d	0a		asl a				asl 	a
.a18e	0a		asl a				asl 	a
.a18f	0a		asl a				asl 	a
.a190	a8		tay				tay
.a191	a9 0c		lda #$0c			lda 	#GCMD_DrawSprite 			; image drawing
.a193	a6 58		ldx $58				ldx 	NSMantissa0
.a195	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a198	60		rts				rts
.a199					TextCommand:
.a199	a2 00		ldx #$00			ldx 	#0
.a19b	20 7e 9d	jsr $9d7e			jsr 	EvaluateString 				; get text
.a19e	20 e0 a1	jsr $a1e0			jsr 	RunGraphicsCommand
.a1a1					TextRunDraw:
.a1a1	09 40		ora #$40			ora 	#GCMD_Move 					; move cursor
.a1a3	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a1a6	a0 00		ldy #$00			ldy 	#0
.a1a8					_IRDLoop:
.a1a8	a5 60		lda $60				lda 	NSMantissa1 				; access character
.a1aa	85 37		sta $37				sta 	zTemp0+1
.a1ac	a5 58		lda $58				lda 	NSMantissa0
.a1ae	85 36		sta $36				sta 	zTemp0
.a1b0	b1 36		lda ($36),y			lda 	(zTemp0),y
.a1b2	f0 13		beq $a1c7			beq 	_IRDExit
.a1b4	5a		phy				phy									; save string pos
.a1b5	48		pha				pha 								; save char
.a1b6	ad 64 06	lda $0664			lda 	gxDrawScale 				; get scale
.a1b9	0a		asl a				asl 	a
.a1ba	0a		asl a				asl 	a
.a1bb	0a		asl a				asl 	a
.a1bc	a8		tay				tay
.a1bd	a9 0a		lda #$0a			lda 	#GCMD_DrawFont 				; char drawing
.a1bf	fa		plx				plx 								; char to draw
.a1c0	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a1c3	7a		ply				ply 								; restore string pos
.a1c4	c8		iny				iny
.a1c5	90 e1		bcc $a1a8			bcc 	_IRDLoop 					; go back if no error.
.a1c7					_IRDExit:
.a1c7	60		rts				rts
.a1c8					PlotCommand:
.a1c8	a9 50		lda #$50			lda 	#GCMD_Plot 					; command ID to use
.a1ca	20 e0 a1	jsr $a1e0			jsr 	RunGraphicsCommand
.a1cd	80 05		bra $a1d4			bra 	ExecuteGraphicCommand
.a1cf					LineCommand:
.a1cf	a9 42		lda #$42			lda 	#GCMD_Line 						; command ID to use
.a1d1	20 e0 a1	jsr $a1e0			jsr 	RunGraphicsCommand
.a1d4					ExecuteGraphicCommand:
.a1d4	0d 5d 06	ora $065d			ora 	gxCommandID 				; make a full command
.a1d7	20 15 80	jsr $8015			jsr 	GXGraphicDraw 				; draw it and exit
.a1da	b0 01		bcs $a1dd			bcs 	_EGCError
.a1dc	60		rts				rts
.a1dd					_EGCError:
.a1dd	4c a4 9f	jmp $9fa4			jmp 	SyntaxError
.a1e0					RunGraphicsCommand:
.a1e0	8d 5d 06	sta $065d			sta 	gxCommandID					; save TODO graphics command.
.a1e3	68		pla				pla 								; pop handler address
.a1e4	fa		plx				plx
.a1e5	1a		inc a				inc 	a
.a1e6	d0 01		bne $a1e9			bne 	_RGINoCarry
.a1e8	e8		inx				inx
.a1e9					_RGINoCarry:
.a1e9	8d 62 06	sta $0662			sta 	GXHandler
.a1ec	8e 63 06	stx $0663			stx 	GXHandler+1
.a1ef					_RGICommandLoop:
.a1ef	b1 30		lda ($30),y			lda 	(codePtr),y
.a1f1	c8		iny				iny
.a1f2	c9 d2		cmp #$d2			cmp 	#KWD_TO						; is it TO x,y
.a1f4	f0 53		beq $a249			beq 	_RGI_To
.a1f6	c9 bd		cmp #$bd			cmp 	#KWD_HERE 					; do it here.
.a1f8	f0 55		beq $a24f			beq 	_RGI_Here
.a1fa	c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL or : , exit
.a1fc	f0 3d		beq $a23b			beq 	_RGI_Exit
.a1fe	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.a200	f0 39		beq $a23b			beq 	_RGI_Exit
.a202	c9 c5		cmp #$c5			cmp 	#KWD_OUTLINE 				; solid or outline
.a204	f0 3e		beq $a244			beq 	_RGI_Frame
.a206	c9 ce		cmp #$ce			cmp 	#KWD_SOLID
.a208	f0 33		beq $a23d			beq 	_RGI_Solid
.a20a	c9 ad		cmp #$ad			cmp 	#KWD_BY 					; by offset
.a20c	f0 4b		beq $a259			beq 	_RGI_By
.a20e	c9 b9		cmp #$b9			cmp 	#KWD_FROM 					; from
.a210	f0 17		beq $a229			beq 	_RGI_Move2
.a212	c9 b5		cmp #$b5			cmp 	#KWD_DIM 					; dim (set scale)
.a214	f0 62		beq $a278			beq 	_RGI_Dim
.a216	c9 b3		cmp #$b3			cmp 	#KWD_COLOUR 				; colour or Color
.a218	f0 74		beq $a28e			beq 	_RGI_Colour
.a21a	c9 b2		cmp #$b2			cmp 	#KWD_COLOR
.a21c	f0 70		beq $a28e			beq 	_RGI_Colour
.a21e	ae 5d 06	ldx $065d			ldx 	gxCommandID
.a221	e0 52		cpx #$52			cpx 	#GCMD_SpriteMove 			; if not sprite
.a223	d0 03		bne $a228			bne 	_RGI_Move 					; move
.a225	4c b6 a2	jmp $a2b6			jmp		_RGI_SpriteInstructions
.a228					_RGI_Move:
.a228	88		dey				dey 								; unpick get.
.a229					_RGI_Move2:
.a229	20 dc a2	jsr $a2dc			jsr 	GCGetCoordinatePair 		; move to here
.a22c	20 03 a3	jsr $a303			jsr 	GCCopyPairToStore 			; save
.a22f	5a		phy				phy
.a230	20 f9 a2	jsr $a2f9			jsr 	GCLoadAXY 					; load in
.a233	09 40		ora #$40			ora 	#GCMD_Move 					; move there
.a235	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a238	7a		ply				ply
.a239	80 b4		bra $a1ef			bra 	_RGICommandLoop 			; and go round
.a23b					_RGI_Exit:
.a23b	88		dey				dey 								; unpick : / EOL
.a23c	60		rts				rts
.a23d					_RGI_Solid:
.a23d	a9 02		lda #$02			lda 	#2
.a23f	8d 5e 06	sta $065e			sta 	gxFillSolid
.a242	80 ab		bra $a1ef			bra 	_RGICommandLoop
.a244					_RGI_Frame:
.a244	9c 5e 06	stz $065e			stz 	gxFillSolid
.a247	80 a6		bra $a1ef			bra 	_RGICommandLoop
.a249					_RGI_To:
.a249	20 dc a2	jsr $a2dc			jsr 	GCGetCoordinatePair 		; get coordinate pair into slot #1,#2
.a24c	20 03 a3	jsr $a303			jsr 	GCCopyPairToStore
.a24f					_RGI_Here:
.a24f	5a		phy				phy
.a250	20 f9 a2	jsr $a2f9			jsr 	GCLoadAXY 					; load it into AXY
.a253	20 b3 a2	jsr $a2b3			jsr 	_RGICallHandler 			; go do whatever it is.
.a256	7a		ply				ply
.a257	80 96		bra $a1ef			bra 	_RGICommandLoop 			; and go round
.a259					_RGI_By:
.a259	20 e9 a2	jsr $a2e9			jsr 	GCSignedCoordinatePair 		; get coordinate pair into slot #1,#2
.a25c	18		clc				clc
.a25d	a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.a25f	6d 5f 06	adc $065f			adc 	gxxPos
.a262	8d 5f 06	sta $065f			sta 	gxXPos
.a265	a5 61		lda $61				lda 	NSMantissa1+1
.a267	6d 60 06	adc $0660			adc 	gxxPos+1
.a26a	8d 60 06	sta $0660			sta 	gxXPos+1
.a26d	a5 5a		lda $5a				lda 	NSMantissa0+2
.a26f	18		clc				clc
.a270	6d 61 06	adc $0661			adc 	gxYPos
.a273	8d 61 06	sta $0661			sta 	gxYPos
.a276	80 d7		bra $a24f			bra 	_RGI_Here
.a278					_RGI_Dim:
.a278	a2 01		ldx #$01			ldx	 	#1
.a27a	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger
.a27d	a5 59		lda $59				lda 	NSMantissa0+1
.a27f	c9 00		cmp #$00			cmp 	#0
.a281	f0 2d		beq $a2b0			beq 	_RGIRange
.a283	c9 09		cmp #$09			cmp 	#8+1
.a285	b0 29		bcs $a2b0			bcs		_RGIRange
.a287	3a		dec a				dec 	a
.a288	8d 64 06	sta $0664			sta 	gxDrawScale
.a28b	4c ef a1	jmp $a1ef			jmp 	_RGICommandLoop
.a28e					_RGI_Colour:
.a28e	a2 01		ldx #$01			ldx 	#1 							; colour
.a290	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger
.a293	a2 02		ldx #$02			ldx 	#2 							; default zero for 2nd parameter
.a295	20 26 9e	jsr $9e26			jsr 	NSMSetZero
.a298	b1 30		lda ($30),y			lda 	(codePtr),y
.a29a	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; check , => mode.
.a29c	d0 04		bne $a2a2			bne 	_RGICDefaultMode
.a29e	c8		iny				iny
.a29f	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger
.a2a2					_RGICDefaultMode:
.a2a2	5a		phy				phy
.a2a3	a9 08		lda #$08			lda 	#GCMD_Colour 				; set colour.
.a2a5	a6 59		ldx $59				ldx 	NSMantissa0+1
.a2a7	a4 5a		ldy $5a				ldy 	NSMantissa0+2
.a2a9	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a2ac	7a		ply				ply
.a2ad	4c ef a1	jmp $a1ef			jmp 	_RGICommandLoop 			; and go round
.a2b0					_RGIRange:
.a2b0	4c a9 9f	jmp $9fa9			jmp 	RangeError
.a2b3					_RGICallHandler:
.a2b3	6c 62 06	jmp ($0662)			jmp 	(GXHandler)
.a2b6					_RGI_SpriteInstructions:
.a2b6	c9 c3		cmp #$c3			cmp 	#KWD_OFF
.a2b8	f0 07		beq $a2c1			beq 	_RGISpriteOff
.a2ba	c9 be		cmp #$be			cmp 	#KWD_IMAGE
.a2bc	f0 13		beq $a2d1			beq 	_RGISetImage
.a2be	4c 28 a2	jmp $a228			jmp 	_RGI_Move
.a2c1					_RGISpriteOff:
.a2c1	5a		phy				phy
.a2c2	a0 01		ldy #$01			ldy 	#1
.a2c4	a2 00		ldx #$00			ldx 	#0
.a2c6					_RGIDoCommandLoop:
.a2c6	a9 10		lda #$10			lda 	#GCMD_SpriteImage
.a2c8	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a2cb	7a		ply				ply
.a2cc	b0 e2		bcs $a2b0			bcs 	_RGIRange
.a2ce	4c ef a1	jmp $a1ef			jmp 	_RGICommandLoop
.a2d1					_RGISetImage:
.a2d1	a2 01		ldx #$01			ldx 	#1
.a2d3	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger
.a2d6	5a		phy				phy
.a2d7	aa		tax				tax
.a2d8	a0 00		ldy #$00			ldy 	#0
.a2da	80 ea		bra $a2c6			bra 	_RGIDoCommandLoop
.a2dc					GCGetCoordinatePair:
.a2dc	a2 01		ldx #$01			ldx 	#1
.a2de	20 a6 9d	jsr $9da6			jsr 	Evaluate16BitInteger
.a2e1	20 ee 8e	jsr $8eee			jsr 	CheckComma
.a2e4	e8		inx				inx
.a2e5	20 a6 9d	jsr $9da6			jsr 	Evaluate16BitInteger
.a2e8	60		rts				rts
.a2e9					GCSignedCoordinatePair:
.a2e9	a2 01		ldx #$01			ldx 	#1
.a2eb	20 b0 9d	jsr $9db0			jsr 	Evaluate16BitIntegerSigned
.a2ee	20 ee 8e	jsr $8eee			jsr 	CheckComma
.a2f1	e8		inx				inx
.a2f2	20 b0 9d	jsr $9db0			jsr 	Evaluate16BitIntegerSigned
.a2f5	60		rts				rts
.a2f6					_GCCPRange:
.a2f6	4c a9 9f	jmp $9fa9			jmp 	RangeError
.a2f9					GCLoadAXY:
.a2f9	ad 60 06	lda $0660			lda 	gxXPos+1
.a2fc	ae 5f 06	ldx $065f			ldx 	gxXPos
.a2ff	ac 61 06	ldy $0661			ldy 	gxYPos
.a302	60		rts				rts
.a303					GCCopyPairToStore:
.a303	a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.a305	8d 5f 06	sta $065f			sta 	gxXPos
.a308	a5 61		lda $61				lda 	NSMantissa1+1
.a30a	8d 60 06	sta $0660			sta 	gxXPos+1
.a30d	a5 5a		lda $5a				lda 	NSMantissa0+2
.a30f	8d 61 06	sta $0661			sta 	gxYPos
.a312	60		rts				rts
.065d					gxCommandID:
>065d							.fill 	1
.065e					gxFillSolid:
>065e							.fill 	1
.065f					gxXPos:
>065f							.fill 	2
.0661					gxYPos:
>0661							.fill 	1
.0662					gxHandler:
>0662							.fill 	2
.0664					gxDrawScale:
>0664							.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcontrol.asm

.a313					BitmapCtrl:
.a313	b1 30		lda ($30),y			lda 	(codePtr),y
.a315	c8		iny				iny
.a316	a2 01		ldx #$01			ldx 	#1
.a318	c9 c4		cmp #$c4			cmp 	#KWD_ON
.a31a	f0 11		beq $a32d			beq 	BitmapSwitch
.a31c	ca		dex				dex
.a31d	c9 c3		cmp #$c3			cmp 	#KWD_OFF
.a31f	f0 0c		beq $a32d			beq 	BitmapSwitch
.a321	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger 		; get the colour
.a324	5a		phy				phy
.a325	aa		tax				tax
.a326	a9 06		lda #$06			lda 	#GCMD_Clear					; clear to that colour
.a328	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a32b	7a		ply				ply
.a32c	60		rts				rts
.a32d					BitmapSwitch:
.a32d	5a		phy				phy
.a32e	a0 00		ldy #$00			ldy 	#0 							; gfx 1,on/off,0
.a330	a9 02		lda #$02			lda 	#GCMD_BitmapCtl
.a332	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a335	a9 08		lda #$08			lda 	#GCMD_Colour				; set colour to $FF
.a337	a0 00		ldy #$00			ldy 	#0
.a339	a2 ff		ldx #$ff			ldx 	#$FF
.a33b	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a33e	9c 5e 06	stz $065e			stz 	gxFillSolid
.a341	9c 5f 06	stz $065f			stz 	gxXPos
.a344	9c 60 06	stz $0660			stz 	gxXPos+1
.a347	9c 61 06	stz $0661			stz 	gxYPos
.a34a	9c 64 06	stz $0664			stz 	gxDrawScale
.a34d	a9 40		lda #$40			lda 	#GCMD_Move 						; home cursor
.a34f	a2 00		ldx #$00			ldx 	#0
.a351	a0 00		ldy #$00			ldy 	#0
.a353	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a356	7a		ply				ply
.a357	60		rts				rts
.a358					SpritesCtrl:
.a358	b1 30		lda ($30),y			lda 	(codePtr),y
.a35a	c8		iny				iny
.a35b	a2 01		ldx #$01			ldx 	#1
.a35d	c9 c4		cmp #$c4			cmp 	#KWD_ON
.a35f	f0 08		beq $a369			beq 	SpriteSwitch
.a361	ca		dex				dex
.a362	c9 c3		cmp #$c3			cmp 	#KWD_OFF
.a364	f0 03		beq $a369			beq 	SpriteSwitch
.a366	4c a4 9f	jmp $9fa4			jmp 	SyntaxError
.a369					SpriteSwitch:
.a369	5a		phy				phy
.a36a	a0 00		ldy #$00			ldy 	#0 							; gfx 2,on/off,0
.a36c	a9 04		lda #$04			lda 	#GCMD_SpriteCtl
.a36e	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a371	7a		ply				ply
.a372	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gfx.asm

.a373					GfxCommand:
.a373	a2 00		ldx #$00			ldx 	#0
.a375	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger 		; command
.a378	20 ee 8e	jsr $8eee			jsr 	CheckComma
.a37b	e8		inx				inx
.a37c	20 a6 9d	jsr $9da6			jsr 	Evaluate16BitInteger 		; X
.a37f	20 ee 8e	jsr $8eee			jsr 	CheckComma
.a382	e8		inx				inx
.a383	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger 		; Y
.a386	a5 61		lda $61				lda 	NSMantissa1+1  				; shift bit 0 of X into CS, should now be zero
.a388	4a		lsr a				lsr 	a
.a389	d0 12		bne $a39d			bne 	_GfxError
.a38b	26 58		rol $58				rol 	NSMantissa0 				; rotate into command
.a38d	b0 0e		bcs $a39d			bcs 	_GfxError 					; bit 7 should have been zero
.a38f	5a		phy				phy 								; save pos
.a390	a5 58		lda $58				lda 	NSMantissa0 				; do the command
.a392	a6 59		ldx $59				ldx 	NSMantissa0+1
.a394	a4 5a		ldy $5a				ldy 	NSMantissa0+2
.a396	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a399	b0 02		bcs $a39d			bcs 	_GfxError
.a39b	7a		ply				ply 								; restore pos and exit.
.a39c	60		rts				rts
.a39d					_GfxError:
.a39d	4c a9 9f	jmp $9fa9			jmp 	RangeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/hit.asm

.a3a0					UnaryHit:
.a3a0	fa		plx				plx
.a3a1	a9 36		lda #$36			lda 	#zTemp0
.a3a3	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger 		; get sprite number 0
.a3a6	20 ee 8e	jsr $8eee			jsr 	CheckComma
.a3a9	e8		inx				inx
.a3aa	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger 		; get sprite number 1
.a3ad	20 e6 8e	jsr $8ee6			jsr		CheckRightBracket
.a3b0	ca		dex				dex 								; fix back up again.
.a3b1	da		phx				phx 								; save X/Y
.a3b2	5a		phy				phy
.a3b3	b4 59		ldy $59,x			ldy 	NSMantissa0+1,x 			; get the sprite numbers into X/Y
.a3b5	b5 58		lda $58,x			lda 	NSMantissa0,x
.a3b7	aa		tax				tax
.a3b8	a9 12		lda #$12			lda 	#GCMD_SpriteCollide 		; command check collision.
.a3ba	20 15 80	jsr $8015			jsr 	GXGraphicDraw 				; calculate result
.a3bd	1a		inc a				inc 	a 							; so 255 (fail) -> 0, otherwise 1,2,3,4 pixels etc.
.a3be	7a		ply				ply 								; restore XY
.a3bf	fa		plx				plx
.a3c0	20 28 9e	jsr $9e28			jsr 	NSMSetByte 					; return the hit result
.a3c3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/palette.asm

.a3c4					PaletteCommand:
.a3c4	a2 00		ldx #$00			ldx 	#0
.a3c6	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger 		; colour
.a3c9	20 ee 8e	jsr $8eee			jsr 	CheckComma
.a3cc	e8		inx				inx
.a3cd	20 a6 9d	jsr $9da6			jsr 	Evaluate16BitInteger 		; r
.a3d0	20 ee 8e	jsr $8eee			jsr 	CheckComma
.a3d3	e8		inx				inx
.a3d4	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger 		; g
.a3d7	20 ee 8e	jsr $8eee			jsr 	CheckComma
.a3da	e8		inx				inx
.a3db	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger 		; b
.a3de	a5 58		lda $58				lda 	NSMantissa0 				; get colour #
.a3e0	85 36		sta $36				sta 	zTemp0
.a3e2	a9 34		lda #$34			lda 	#$D0 >> 2 					; MSB = D0/4
.a3e4	85 37		sta $37				sta 	zTemp0+1
.a3e6	06 36		asl $36				asl 	zTemp0 						; zTemp = $D000+Colour x 4
.a3e8	26 37		rol $37				rol	 	zTemp0+1
.a3ea	06 36		asl $36				asl 	zTemp0
.a3ec	26 37		rol $37				rol	 	zTemp0+1
.a3ee	a9 01		lda #$01			lda 	#1 							; I/O Page 2
.a3f0	85 01		sta $01				sta 	1
.a3f2	5a		phy				phy
.a3f3	a5 5b		lda $5b				lda 	NSMantissa0+3 				; fix to r,g,b
.a3f5	92 36		sta ($36)			sta 	(zTemp0)
.a3f7	a0 01		ldy #$01			ldy 	#1
.a3f9	a5 5a		lda $5a				lda 	NSMantissa0+2
.a3fb	91 36		sta ($36),y			sta 	(zTemp0),y
.a3fd	a5 59		lda $59				lda 	NSMantissa0+1
.a3ff	c8		iny				iny
.a400	91 36		sta ($36),y			sta 	(zTemp0),y
.a402	7a		ply				ply
.a403	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/event.asm

.a404					UnaryEvent:
.a404	fa		plx				plx
.a405	20 b2 a4	jsr $a4b2			jsr 	TimerToStackX 				; timer in +0
.a408	e8		inx				inx  								; put reference into +1
.a409	20 4d 98	jsr $984d			jsr 	EvaluateTerm
.a40c	b5 50		lda $50,x			lda 	NSStatus,x 					; check if is integer reference
.a40e	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.a410	d0 4c		bne $a45e			bne 	_UEType
.a412	e8		inx				inx 								; put the step in +2
.a413	20 ee 8e	jsr $8eee			jsr 	CheckComma
.a416	20 a6 9d	jsr $9da6			jsr 	Evaluate16BitInteger
.a419	20 e6 8e	jsr $8ee6			jsr 	CheckRightBracket
.a41c	ca		dex				dex
.a41d	ca		dex				dex
.a41e	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy reference to zTemp0
.a420	85 36		sta $36				sta 	zTemp0
.a422	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.a424	85 37		sta $37				sta 	zTemp0+1
.a426	5a		phy				phy
.a427	a0 03		ldy #$03			ldy 	#3 							; check bit 7 of last bit, the packed sign bit
.a429	b1 36		lda ($36),y			lda 	(zTemp0),y
.a42b	30 2d		bmi $a45a			bmi 	_UEFalse 					; exit if signed.
.a42d	a0 00		ldy #$00			ldy 	#0 							; has it timed out (24 bit)
.a42f	b5 58		lda $58,x			lda 	NSMantissa0,x
.a431	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.a433	c8		iny				iny
.a434	b5 60		lda $60,x			lda 	NSMantissa1,x
.a436	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a438	c8		iny				iny
.a439	b5 68		lda $68,x			lda 	NSMantissa2,x
.a43b	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a43d	90 1b		bcc $a45a			bcc 	_UEFalse 					; no, return FALSE.
.a43f	18		clc				clc
.a440	a0 00		ldy #$00			ldy 	#0 							; work out new value as timer() + step
.a442	b5 58		lda $58,x			lda 	NSMantissa0,x
.a444	75 5a		adc $5a,x			adc 	NSMantissa0+2,x
.a446	91 36		sta ($36),y			sta 	(zTemp0),y
.a448	c8		iny				iny
.a449	b5 60		lda $60,x			lda 	NSMantissa1,x
.a44b	75 62		adc $62,x			adc 	NSMantissa1+2,x
.a44d	91 36		sta ($36),y			sta 	(zTemp0),y
.a44f	c8		iny				iny
.a450	b5 68		lda $68,x			lda 	NSMantissa2,x
.a452	75 6a		adc $6a,x			adc 	NSMantissa2+2,x
.a454	91 36		sta ($36),y			sta 	(zTemp0),y
.a456	7a		ply				ply
.a457	4c 6c 8f	jmp $8f6c			jmp 	ReturnTrue
.a45a					_UEFalse:
.a45a	7a		ply				ply 								; restore Y
.a45b	4c 77 8f	jmp $8f77			jmp 	ReturnFalse 				; and return False
.a45e					_UEType:
.a45e	4c ae 9f	jmp $9fae			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/joy.asm

.a461					UnaryJoyX:
.a461	18		clc				clc
.a462	80 01		bra $a465			bra 	JoyMain
.a464					UnaryJoyY:
.a464	38		sec				sec
.a465					JoyMain:
.a465	fa		plx				plx 								; get pos
.a466	08		php				php 								; save carry (set for Y)
.a467	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a46a	20 e6 8e	jsr $8ee6			jsr 	CheckRightBracket
.a46d	20 0f 80	jsr $800f			jsr 	EXTReadController 			; read the controller.
.a470	28		plp				plp
.a471	90 02		bcc $a475			bcc 	_JMNoShift 					; if Y then shift bits 3,2 -> 1,0
.a473	4a		lsr a				lsr 	a
.a474	4a		lsr a				lsr 	a
.a475					_JMNoShift:
.a475	4a		lsr a				lsr 	a 							; if bit 0 set then right/down e.g. +1
.a476	b0 0a		bcs $a482			bcs 	_JMIsRight
.a478	4a		lsr a				lsr 	a 							; if bit 1 set then left/up e.g. -1
.a479	b0 04		bcs $a47f			bcs 	_JMIsLeft
.a47b	20 26 9e	jsr $9e26			jsr 	NSMSetZero 					; zero result
.a47e	60		rts				rts
.a47f					_JMIsLeft:
.a47f	4c 6c 8f	jmp $8f6c			jmp 	ReturnTrue
.a482					_JMIsRight:
.a482	a9 01		lda #$01			lda 	#1
.a484	20 28 9e	jsr $9e28			jsr 	NSMSetByte
.a487	60		rts				rts
.a488					UnaryJoyB:
.a488	fa		plx				plx 								; get pos
.a489	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a48c	20 e6 8e	jsr $8ee6			jsr 	CheckRightBracket
.a48f	20 0f 80	jsr $800f			jsr 	EXTReadController 			; read the controller.
.a492	4a		lsr a				lsr 	a
.a493	4a		lsr a				lsr 	a
.a494	4a		lsr a				lsr 	a
.a495	4a		lsr a				lsr 	a
.a496	29 01		and #$01			and 	#1
.a498	20 28 9e	jsr $9e28			jsr 	NSMSetByte
.a49b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/load.asm

.a49c					LoadCommand:
.a49c	20 34 8a	jsr $8a34			jsr 	NewProgram
.a49f	20 26 83	jsr $8326			jsr 	BackLoadProgram
.a4a2	4c dd 83	jmp $83dd			jmp 	WarmStart
.a4a5					GoCommand:
.a4a5	20 34 8a	jsr $8a34			jsr 	NewProgram
.a4a8	20 26 83	jsr $8326			jsr 	BackLoadProgram
.a4ab	4c 75 8b	jmp $8b75			jmp 	CommandRun

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/timer.asm

.a4ae					UnaryTimer:
.a4ae	fa		plx				plx
.a4af	20 e6 8e	jsr $8ee6			jsr 	CheckRightBracket
.a4b2					TimerToStackX:
.a4b2	20 26 9e	jsr $9e26			jsr 	NSMSetZero 					; zero result
.a4b5	64 01		stz $01				stz 	1 							; access I/O
.a4b7	ad 59 d6	lda $d659			lda 	$D659 						; copy timer in
.a4ba	95 58		sta $58,x			sta 	NSMantissa0,x
.a4bc	ad 5a d6	lda $d65a			lda 	$D65A
.a4bf	95 60		sta $60,x			sta 	NSMantissa1,x
.a4c1	ad 5b d6	lda $d65b			lda 	$D65B
.a4c4	95 68		sta $68,x			sta 	NSMantissa2,x
.a4c6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/delete.asm

.a4c7					MemoryDeleteLine:
.a4c7	20 e6 a4	jsr $a4e6			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a4ca	b2 30		lda ($30)			lda 	(codePtr) 					; size to delete => y
.a4cc	a8		tay				tay
.a4cd					_MDDLLoop:
.a4cd	b1 30		lda ($30),y			lda 	(codePtr),y 				; copy down
.a4cf	92 30		sta ($30)			sta 	(codePtr)
.a4d1	a5 30		lda $30				lda 	codePtr 					; check done the lot.
.a4d3	c5 3a		cmp $3a				cmp 	zTemp2
.a4d5	d0 07		bne $a4de			bne 	_MDLDLNext
.a4d7	a5 31		lda $31				lda 	codePtr+1
.a4d9	c5 3b		cmp $3b				cmp 	zTemp2+1
.a4db	d0 01		bne $a4de			bne 	_MDLDLNext
.a4dd					_MDDLExit:
.a4dd	60		rts				rts
.a4de					_MDLDLNext:
.a4de	e6 30		inc $30				inc 	codePtr						; next byte
.a4e0	d0 eb		bne $a4cd			bne 	_MDDLLoop
.a4e2	e6 31		inc $31				inc 	codePtr+1
.a4e4	80 e7		bra $a4cd			bra 	_MDDLLoop
.a4e6					IMemoryFindEnd:
.a4e6	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a4e8	85 3a		sta $3a				sta 	0+zTemp2
.a4ea	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a4ec	85 3b		sta $3b				sta 	1+zTemp2
.a4ee					_MDLFELoop:
.a4ee	b2 3a		lda ($3a)			lda 	(zTemp2)
.a4f0	f0 0b		beq $a4fd			beq 	_MDLFEExit
.a4f2	18		clc				clc
.a4f3	65 3a		adc $3a				adc 	zTemp2
.a4f5	85 3a		sta $3a				sta 	zTemp2
.a4f7	90 f5		bcc $a4ee			bcc 	_MDLFELoop
.a4f9	e6 3b		inc $3b				inc 	zTemp2+1
.a4fb	80 f1		bra $a4ee			bra 	_MDLFELoop
.a4fd					_MDLFEExit:
.a4fd	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/insert.asm

.a4fe					MemoryInsertLine:
.a4fe	08		php				php
.a4ff	20 e6 a4	jsr $a4e6			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a502	a5 3b		lda $3b				lda 	zTemp2+1 					; space ?
.a504	1a		inc a				inc 	a
.a505	c9 7f		cmp #$7f			cmp 	#(BasicEnd >> 8)-1
.a507	b0 36		bcs $a53f			bcs 	_MDLIError
.a509	28		plp				plp
.a50a	90 08		bcc $a514			bcc 	_MDLIFound
.a50c	a5 3a		lda $3a				lda 	zTemp2 						; if CS on entry append.
.a50e	85 30		sta $30				sta 	codePtr
.a510	a5 3b		lda $3b				lda 	zTemp2+1
.a512	85 31		sta $31				sta 	codePtr+1
.a514					_MDLIFound:
.a514	ad 2a 04	lda $042a			lda 	tokenOffset 				; insert gap in Y, the offset, e.g. length of the new line
.a517	a8		tay				tay
.a518					_MDLIInsert:
.a518	b2 3a		lda ($3a)			lda 	(zTemp2) 					; shift one byte up , at least one covers end case.
.a51a	91 3a		sta ($3a),y			sta 	(zTemp2),y 					; work from top down.
.a51c	a5 30		lda $30				lda 	codePtr 					; done insert point ?
.a51e	c5 3a		cmp $3a				cmp 	zTemp2
.a520	d0 06		bne $a528			bne 	_MDLINext
.a522	a5 31		lda $31				lda 	codePtr+1
.a524	c5 3b		cmp $3b				cmp 	zTemp2+1
.a526	f0 0a		beq $a532			beq 	_MDLIHaveSpace
.a528					_MDLINext:
.a528	a5 3a		lda $3a				lda 	zTemp2 						; if no, keep zTemp2 going backwards
.a52a	d0 02		bne $a52e			bne 	_MDLINoBorrow
.a52c	c6 3b		dec $3b				dec 	zTemp2+1
.a52e					_MDLINoBorrow:
.a52e	c6 3a		dec $3a				dec 	zTemp2
.a530	80 e6		bra $a518			bra 	_MDLIInsert
.a532					_MDLIHaveSpace:
.a532	ac 2a 04	ldy $042a			ldy 	tokenOffset 				; bytes to copy
.a535	88		dey				dey 								; from offset-1 to 0
.a536					_MDLICopy:
.a536	b9 2a 04	lda $042a,y			lda 	tokenOffset,y
.a539	91 30		sta ($30),y			sta 	(codePtr),y
.a53b	88		dey				dey
.a53c	10 f8		bpl $a536			bpl 	_MDLICopy
.a53e	60		rts				rts
.a53f					_MDLIError:
.a53f	a9 06		lda #$06		lda	#6
.a541	4c ff 8e	jmp $8eff		jmp	ErrorHandler
.a544					MDLAppendLine:
.a544	86 37		stx $37				stx 	zTemp0+1 					; save new line at zTemp0
.a546	85 36		sta $36				sta 	zTemp0
.a548	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a54a	85 38		sta $38				sta 	0+zTemp1
.a54c	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a54e	85 39		sta $39				sta 	1+zTemp1
.a550	b2 38		lda ($38)			lda 	(zTemp1)
.a552	d0 0a		bne $a55e			bne 	_MDLANoInitialise
.a554	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a556	8d 65 06	sta $0665			sta 	0+AppendPointer
.a559	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a55b	8d 66 06	sta $0666			sta 	1+AppendPointer
.a55e					_MDLANoInitialise:
.a55e	18		clc				clc
.a55f	ad 65 06	lda $0665			lda 	AppendPointer 				; copy append pointer to zTemp1 adding the offset as you go
.a562	85 38		sta $38				sta 	zTemp1
.a564	72 36		adc ($36)			adc 	(zTemp0)
.a566	8d 65 06	sta $0665			sta 	AppendPointer
.a569	ad 66 06	lda $0666			lda 	AppendPointer+1
.a56c	85 39		sta $39				sta 	zTemp1+1
.a56e	69 00		adc #$00			adc 	#0
.a570	8d 66 06	sta $0666			sta 	AppendPointer+1
.a573	a0 00		ldy #$00			ldy 	#0
.a575					_MDLACopy:
.a575	b1 36		lda ($36),y			lda 	(zTemp0),y 					; copy new line in
.a577	91 38		sta ($38),y			sta 	(zTemp1),y
.a579	c8		iny				iny
.a57a	98		tya				tya
.a57b	d2 36		cmp ($36)			cmp 	(zTemp0) 					; done whole line
.a57d	d0 f6		bne $a575			bne 	_MDLACopy
.a57f	a9 00		lda #$00			lda 	#0 							; end of program.
.a581	91 38		sta ($38),y			sta 	(zTemp1),y
.a583	60		rts				rts
.0665					AppendPointer:
>0665							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/memory.asm

.a584					MemoryNew:
.a584	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a586	85 30		sta $30				sta 	codePtr
.a588	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a58a	85 31		sta $31				sta 	codePtr+1
.a58c	a9 00		lda #$00			lda 	#0 							; write zero there erasing the program.
.a58e	92 30		sta ($30)			sta 	(codePtr)
.a590	60		rts				rts
.a591					MemoryInline:
.a591	98		tya				tya 								; put address into stack,x
.a592	18		clc				clc  								; get the offset, add codePtr
.a593	65 30		adc $30				adc 	codePtr
.a595	95 58		sta $58,x			sta 	NSMantissa0,x 				; store the result in the mantissa.
.a597	a5 31		lda $31				lda 	codePtr+1
.a599	69 00		adc #$00			adc 	#0
.a59b	95 60		sta $60,x			sta 	NSMantissa1,x
.a59d	74 68		stz $68,x			stz 	NSMantissa2,x
.a59f	74 70		stz $70,x			stz 	NSMantissa3,x
.a5a1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/search.asm

.a5a2					MemorySearch:
.a5a2	85 36		sta $36				sta 	zTemp0 						; save line number in zTemp0
.a5a4	86 37		stx $37				stx 	zTemp0+1
.a5a6	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a5a8	85 30		sta $30				sta 	codePtr
.a5aa	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a5ac	85 31		sta $31				sta 	codePtr+1
.a5ae					_MTAXLoop:
.a5ae	b2 30		lda ($30)			lda 	(codePtr)
.a5b0	18		clc				clc
.a5b1	f0 21		beq $a5d4			beq 	_MTAXExit 					; reached end, exit with CC.
.a5b3	a0 01		ldy #$01			ldy 	#1 							; calculate current line# - requested line#
.a5b5	b1 30		lda ($30),y			lda 	(codePtr),y
.a5b7	38		sec				sec
.a5b8	e5 36		sbc $36				sbc 	zTemp0
.a5ba	85 38		sta $38				sta 	zTemp1 						; save interim to set Z
.a5bc	c8		iny				iny 								; do the MSB
.a5bd	b1 30		lda ($30),y			lda 	(codePtr),y
.a5bf	e5 37		sbc $37				sbc 	zTemp0+1
.a5c1	05 38		ora $38				ora 	zTemp1 						; will set Z if result is zero, doesn't affect carry flag
.a5c3	f0 0f		beq $a5d4			beq 	_MTAXExit	 				; found so exit (CS will be set)
.a5c5	b0 0d		bcs $a5d4			bcs 	_MTAXExit 					; current < required exit
.a5c7	18		clc				clc
.a5c8	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.a5ca	65 30		adc $30				adc 	codePtr
.a5cc	85 30		sta $30				sta 	codePtr
.a5ce	90 02		bcc $a5d2			bcc 	_CREExit
.a5d0	e6 31		inc $31				inc 	codePtr+1 					; carry
.a5d2					_CREExit:
.a5d2	80 da		bra $a5ae			bra 	_MTAXLoop
.a5d4					_MTAXExit:
.a5d4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/effects.asm

.a5d5					PingCommand:
.a5d5	5a		phy				phy 								; save pos
.a5d6	a9 01		lda #$01			lda 	#1 						; push channel.
.a5d8	48		pha				pha
.a5d9	a9 c8		lda #$c8			lda 	#200 						; pitch LSB
.a5db	a2 03		ldx #$03			ldx 	#3 						; length
.a5dd	a0 00		ldy #$00			ldy 	#0 						; slide LSB
.a5df	80 24		bra $a605			bra 	SoundEffectCommand
.a5e1					ZapCommand:
.a5e1	5a		phy				phy 								; save pos
.a5e2	a9 01		lda #$01			lda 	#1 						; push channel.
.a5e4	48		pha				pha
.a5e5	a9 ff		lda #$ff			lda 	#255 						; pitch LSB
.a5e7	a2 05		ldx #$05			ldx 	#5 						; length
.a5e9	a0 14		ldy #$14			ldy 	#20 						; slide LSB
.a5eb	80 18		bra $a605			bra 	SoundEffectCommand
.a5ed					ShootCommand:
.a5ed	5a		phy				phy 								; save pos
.a5ee	a9 03		lda #$03			lda 	#3 						; push channel.
.a5f0	48		pha				pha
.a5f1	a9 20		lda #$20			lda 	#32 						; pitch LSB
.a5f3	a2 02		ldx #$02			ldx 	#2 						; length
.a5f5	a0 00		ldy #$00			ldy 	#0 						; slide LSB
.a5f7	80 0c		bra $a605			bra 	SoundEffectCommand
.a5f9					Explode:
.a5f9	5a		phy				phy 								; save pos
.a5fa	a9 03		lda #$03			lda 	#3 						; push channel.
.a5fc	48		pha				pha
.a5fd	a9 50		lda #$50			lda 	#80 						; pitch LSB
.a5ff	a2 05		ldx #$05			ldx 	#5 						; length
.a601	a0 00		ldy #$00			ldy 	#0 						; slide LSB
.a603	80 00		bra $a605			bra 	SoundEffectCommand
.a605					SoundEffectCommand:
.a605	8d 67 06	sta $0667			sta 	SoundCommandBlock 			; set up the command block in sound.asm
.a608	9c 68 06	stz $0668			stz 	SoundCommandBlock+1
.a60b	a9 0f		lda #$0f			lda 	#15
.a60d	8d 69 06	sta $0669			sta 	SoundCommandBlock+2
.a610	8e 6a 06	stx $066a			stx 	SoundCommandBlock+3
.a613	8c 6b 06	sty $066b			sty 	SoundCommandBlock+4
.a616	9c 6c 06	stz $066c			stz 	SoundCommandBlock+5
.a619	68		pla				pla
.a61a	09 10		ora #$10			ora 	#$10  						; execute command $11
.a61c	a2 67		ldx #$67			ldx 	#(SoundCommandBlock & $FF)
.a61e	a0 06		ldy #$06			ldy 	#(SoundCommandBlock >> 8)
.a620	20 18 80	jsr $8018			jsr 	SNDCommand
.a623	7a		ply				ply
.a624	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/playing.asm

.a625					UnaryPlaying:
.a625	fa		plx				plx
.a626	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger 		; get channel #
.a629	48		pha				pha
.a62a	20 e6 8e	jsr $8ee6			jsr		CheckRightBracket
.a62d	68		pla				pla
.a62e	c9 04		cmp #$04			cmp 	#4
.a630	b0 0c		bcs $a63e			bcs 	_UPNotPlaying
.a632	09 20		ora #$20			ora 	#$20 						; query playing ?
.a634	20 18 80	jsr $8018			jsr 	SNDCommand
.a637	c9 00		cmp #$00			cmp 	#0
.a639	f0 03		beq $a63e			beq 	_UPNotPlaying
.a63b	4c 6c 8f	jmp $8f6c			jmp 	ReturnTrue
.a63e					_UPNotPlaying:
.a63e	4c 77 8f	jmp $8f77			jmp 	ReturnFalse

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/sound.asm

.a641					SoundCommand:
.a641	b1 30		lda ($30),y			lda 	(codePtr),y
.a643	c9 c3		cmp #$c3			cmp 	#KWD_OFF 					; SOUND OFF ?
.a645	d0 09		bne $a650			bne 	_SNDMain
.a647	c8		iny				iny 								; skip OFF
.a648	a9 3f		lda #$3f			lda 	#$3F 						; call command $3F (silence)
.a64a	5a		phy				phy
.a64b	20 18 80	jsr $8018			jsr 	SNDCommand
.a64e	7a		ply				ply
.a64f	60		rts				rts
.a650					_SNDMain:
.a650	a2 00		ldx #$00			ldx 	#0
.a652	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger 		; channel
.a655	c9 04		cmp #$04			cmp 	#4 							; must be 0-3
.a657	b0 4b		bcs $a6a4			bcs 	_SndError
.a659	e8		inx				inx 								; do the rest in slot 1.
.a65a	20 ee 8e	jsr $8eee			jsr 	CheckComma
.a65d	20 a6 9d	jsr $9da6			jsr 	Evaluate16BitInteger 		; Pitch
.a660	b5 60		lda $60,x			lda 	NSMantissa1,x 				; must be 10 bit
.a662	c9 10		cmp #$10			cmp 	#16
.a664	b0 3e		bcs $a6a4			bcs 	_SndError
.a666	8d 68 06	sta $0668			sta 	SoundCommandBlock+1 		; Pitch (2 bytes + 0)
.a669	b5 58		lda $58,x			lda 	NSMantissa0,x
.a66b	8d 67 06	sta $0667			sta 	SoundCommandBlock
.a66e	20 ee 8e	jsr $8eee			jsr 	CheckComma
.a671	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger 		; Length (1 byte + 3)
.a674	8d 6a 06	sta $066a			sta 	SoundCommandBlock+3
.a677	a9 0f		lda #$0f			lda 	#15
.a679	8d 69 06	sta $0669			sta 	SoundCommandBlock+2 		; Volume (1 byte + 2)
.a67c	9c 6b 06	stz $066b			stz 	SoundCommandBlock+4 		; default slide (2 bytes +4)
.a67f	9c 6c 06	stz $066c			stz 	SoundCommandBlock+5
.a682	b1 30		lda ($30),y			lda 	(codePtr),y
.a684	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.a686	d0 0e		bne $a696			bne 	_SNDPlay
.a688	c8		iny				iny
.a689	20 b0 9d	jsr $9db0			jsr 	Evaluate16BitIntegerSigned 	; Slide
.a68c	b5 58		lda $58,x			lda 	NSMantissa0,x 				; Slide (2 bytes + 4)
.a68e	8d 6b 06	sta $066b			sta 	SoundCommandBlock+4
.a691	b5 60		lda $60,x			lda 	NSMantissa1,x
.a693	8d 6c 06	sta $066c			sta 	SoundCommandBlock+5
.a696					_SNDPlay:
.a696	5a		phy				phy
.a697	a5 58		lda $58				lda 	NSMantissa0 				; channel.
.a699	09 10		ora #$10			ora 	#$10 						; 1x = Queue sound
.a69b	a2 67		ldx #$67			ldx 	#(SoundCommandBlock & $FF)
.a69d	a0 06		ldy #$06			ldy 	#(SoundCommandBlock >> 8)
.a69f	20 18 80	jsr $8018			jsr 	SNDCommand
.a6a2	7a		ply				ply
.a6a3	60		rts				rts
.a6a4					_SndError:
.a6a4	4c a9 9f	jmp $9fa9			jmp 	RangeError
.0667					SoundCommandBlock:
>0667							.fill 	6

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/bytes.asm

.a6a7					StackPushByte:
.a6a7	48		pha				pha 								; save byte on stack
.a6a8	a5 34		lda $34				lda 	BasicStack 					; decrement basic stack pointer
.a6aa	d0 08		bne $a6b4			bne 	_SPBNoBorrow
.a6ac	c6 35		dec $35				dec 	BasicStack+1 				; borrow
.a6ae	a5 35		lda $35				lda 	BasicStack+1 				; check range.
.a6b0	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a6b2	90 06		bcc $a6ba			bcc 	_SPBMemory
.a6b4					_SPBNoBorrow:
.a6b4	c6 34		dec $34				dec 	BasicStack
.a6b6	68		pla				pla 								; get back and write
.a6b7	92 34		sta ($34)			sta 	(BasicStack)
.a6b9	60		rts				rts
.a6ba					_SPBMemory:
.a6ba	a9 12		lda #$12		lda	#18
.a6bc	4c ff 8e	jmp $8eff		jmp	ErrorHandler
.a6bf					StackPopByte:
.a6bf	b2 34		lda ($34)			lda 	(BasicStack) 				; bump the stack pointer.
.a6c1	e6 34		inc $34				inc 	BasicStack
.a6c3	d0 02		bne $a6c7			bne 	_SPBNoCarry
.a6c5	e6 35		inc $35				inc 	BasicStack+1
.a6c7					_SPBNoCarry:
.a6c7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/frames.asm

.a6c8					StackOpen:
.a6c8	48		pha				pha 								; save frame byte
.a6c9	29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.a6cb	0a		asl a				asl 	a 							; claim twice this for storage
.a6cc	49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.a6ce	38		sec				sec 								; so basically subtracting from
.a6cf	65 34		adc $34				adc 	basicStack 	 				; basicStack
.a6d1	85 34		sta $34				sta 	basicStack
.a6d3	b0 09		bcs $a6de			bcs 	_SONoBorrow
>a6d5	db						.byte 	$DB 						; causes a break in the emulator
.a6d6	c6 35		dec $35				dec 	basicStack+1
.a6d8	a5 35		lda $35				lda 	basicStack+1 				; have we reached stack overflow
.a6da	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a6dc	90 04		bcc $a6e2			bcc 	_SOMemory
.a6de					_SONoBorrow:
.a6de	68		pla				pla 								; get marker back and write at TOS
.a6df	92 34		sta ($34)			sta 	(basicStack)
.a6e1	60		rts				rts
.a6e2					_SOMemory:
.a6e2	a9 12		lda #$12		lda	#18
.a6e4	4c ff 8e	jmp $8eff		jmp	ErrorHandler
.a6e7					StackClose:
.a6e7	b2 34		lda ($34)			lda 	(basicStack) 				; get TOS marker
.a6e9	29 0f		and #$0f			and 	#$0F 						; bytes to add back
.a6eb	0a		asl a				asl 	a 							; claim twice this.
.a6ec	65 34		adc $34				adc 	basicStack 					; add to the stack pointer.
.a6ee	85 34		sta $34				sta 	basicStack
.a6f0	90 02		bcc $a6f4			bcc 	_SCExit
.a6f2	e6 35		inc $35				inc 	basicStack+1
.a6f4					_SCExit:
.a6f4	60		rts				rts
.a6f5					StackCheckFrame:
.a6f5	48		pha				pha
.a6f6					_StackRemoveLocals:
.a6f6	b2 34		lda ($34)			lda 	(basicStack) 				; check for local, keep popping them
.a6f8	c9 03		cmp #$03			cmp 	#STK_LOCALS+1 				; is the frame a local ? S or N are 1/0
.a6fa	b0 05		bcs $a701			bcs 	_SCNoLocal
.a6fc	20 e3 89	jsr $89e3			jsr 	LocalPopValue 				; restore the local value
.a6ff	80 f5		bra $a6f6			bra 	_StackRemoveLocals 			; gr round again
.a701					_SCNoLocal:
.a701	68		pla				pla 								; get the frame check.
.a702	52 34		eor ($34)			eor 	(basicStack) 				; xor with toS marker
.a704	29 f0		and #$f0			and 	#$F0 						; check type bits
.a706	d0 01		bne $a709			bne 	_SCFError 					; different, we have structures mixed up
.a708	60		rts				rts
.a709					_SCFError:
.a709	8a		txa				txa 								; report error X
.a70a	4c ff 8e	jmp $8eff			jmp 	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/location.asm

.a70d					STKSaveCodePosition:
.a70d	5a		phy				phy
.a70e	98		tya				tya 								; save Y
.a70f	a0 05		ldy #$05			ldy 	#5
.a711	91 34		sta ($34),y			sta 	(basicStack),y
.a713	88		dey				dey 								; save Code Pointer
.a714					_STKSaveLoop:
.a714	b9 2f 00	lda $002f,y			lda 	safePtr-1,y 				; allows us to access the pointer w/out issues.
.a717	91 34		sta ($34),y			sta 	(basicStack),y
.a719	88		dey				dey
.a71a	d0 f8		bne $a714			bne 	_STKSaveLoop
.a71c	7a		ply				ply
.a71d	60		rts				rts
.a71e					STKLoadCodePosition:
.a71e	a0 01		ldy #$01			ldy 	#1 							; load code pointer back
.a720					_STKLoadLoop:
.a720	b1 34		lda ($34),y			lda 	(basicStack),y
.a722	99 2f 00	sta $002f,y			sta 	safePtr-1,y
.a725	c8		iny				iny
.a726	c0 05		cpy #$05			cpy 	#5
.a728	d0 f6		bne $a720			bne 	_STKLoadLoop
.a72a	b1 34		lda ($34),y			lda 	(basicStack),y 				; get Y offset
.a72c	a8		tay				tay
.a72d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/setup.asm

.a72e					StackReset:
.a72e	a9 ff		lda #$ff			lda 	#((BasicStackBase+BasicStackSize-1) & $FF)
.a730	85 34		sta $34				sta 	0+basicStack
.a732	a9 0f		lda #$0f			lda 	#((BasicStackBase+BasicStackSize-1) >> 8)
.a734	85 35		sta $35				sta 	1+basicStack
.a736	a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.a738	92 34		sta ($34)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.a73a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/concrete.asm

.a73b					StringConcrete:
.a73b	5a		phy				phy 								; save position on stack
.a73c	20 39 9a	jsr $9a39			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a73f	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy target string to zTemp1
.a741	85 38		sta $38				sta 	zTemp1
.a743	b5 60		lda $60,x			lda 	NSMantissa1,x
.a745	85 39		sta $39				sta 	zTemp1+1
.a747	a0 ff		ldy #$ff			ldy 	#$FF	 					; calculate string length
.a749					_SALength:
.a749	c8		iny				iny
.a74a	b1 38		lda ($38),y			lda 	(zTemp1),y
.a74c	d0 fb		bne $a749			bne 	_SALength
.a74e	c0 fd		cpy #$fd			cpy 	#253 						; string too long - cannot concrete.
.a750	b0 3d		bcs $a78f			bcs 	_SALengthError
.a752	98		tya				tya 				 				; length of the new string
.a753	18		clc				clc
.a754	69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.a756	90 02		bcc $a75a			bcc 	_SAHaveLength
.a758	a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.a75a					_SAHaveLength:
.a75a	48		pha				pha 								; save length.
.a75b	38		sec				sec
.a75c	49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.a75e	6d 0e 04	adc $040e			adc 	StringMemory
.a761	8d 0e 04	sta $040e			sta 	StringMemory
.a764	85 3a		sta $3a				sta 	zTemp2 						; update storage address
.a766	95 58		sta $58,x			sta 	NSMantissa0,x 				; update mantissa address
.a768	a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.a76a	6d 0f 04	adc $040f			adc 	StringMemory+1
.a76d	8d 0f 04	sta $040f			sta 	StringMemory+1
.a770	85 3b		sta $3b				sta 	zTemp2+1
.a772	95 60		sta $60,x			sta 	NSMantissa1,x
.a774	68		pla				pla 								; save length-3 (chars allowed) in first byte
.a775	38		sec				sec
.a776	e9 03		sbc #$03			sbc 	#3
.a778	92 3a		sta ($3a)			sta 	(zTemp2)
.a77a	a9 00		lda #$00			lda 	#0 							; clear the status byte.
.a77c	a0 01		ldy #$01			ldy 	#1
.a77e	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a780					_SACopyNewString:
.a780	a0 00		ldy #$00			ldy 	#0
.a782					_SACopyNSLoop:
.a782	b1 38		lda ($38),y			lda 	(zTemp1),y 					; get character
.a784	c8		iny				iny 								; write two on in string storage
.a785	c8		iny				iny
.a786	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a788	88		dey				dey 								; this makes it one one.
.a789	c9 00		cmp #$00			cmp 	#0 							; until EOS copied
.a78b	d0 f5		bne $a782			bne 	_SACopyNSLoop
.a78d	7a		ply				ply
.a78e	60		rts				rts
.a78f					_SALengthError:
.a78f	a9 09		lda #$09		lda	#9
.a791	4c ff 8e	jmp $8eff		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/stringalloc.asm

.a794					StringSystemInitialise:
.a794	a9 ff		lda #$ff			lda 	#((EndVariableSpace-1) & $FF)
.a796	8d 0e 04	sta $040e			sta 	0+StringMemory
.a799	a9 1f		lda #$1f			lda 	#((EndVariableSpace-1) >> 8)
.a79b	8d 0f 04	sta $040f			sta 	1+StringMemory
.a79e	9c ff 1f	stz $1fff			stz 	EndVariableSpace-1 			; put a zero at the end, so know end of string memory.
.a7a1	60		rts				rts
.a7a2					StringSpaceInitialise:
.a7a2	20 39 9a	jsr $9a39			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a7a5	a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.a7a7	8d 10 04	sta $0410			sta 	StringInitialised
.a7aa	ad 0e 04	lda $040e			lda 	StringMemory 				; allocate 256 bytes for one concreted string
.a7ad	8d 11 04	sta $0411			sta 	StringTempPointer 			; so temporary string space is allocated below that.
.a7b0	ad 0f 04	lda $040f			lda 	StringMemory+1
.a7b3	3a		dec a				dec 	a
.a7b4	8d 12 04	sta $0412			sta 	StringTempPointer+1
.a7b7	60		rts				rts
.a7b8					StringTempAllocate:
.a7b8	c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.a7ba	b0 30		bcs $a7ec			bcs 	_STALength
.a7bc	2c 10 04	bit $0410			bit 	StringInitialised 			; already initialised
.a7bf	30 05		bmi $a7c6			bmi 	_STAAllocate
.a7c1	48		pha				pha 								; save value to subtract.
.a7c2	20 a2 a7	jsr $a7a2			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.a7c5	68		pla				pla 								; restore it
.a7c6					_STAAllocate:
.a7c6	49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.a7c8	18		clc				clc  								; deliberate allows one more
.a7c9	6d 11 04	adc $0411			adc 	StringTempPointer 			; subtract from temp pointer
.a7cc	8d 11 04	sta $0411			sta 	StringTempPointer
.a7cf	95 58		sta $58,x			sta 	NSMantissa0,x 				; address in mantissa
.a7d1	85 3c		sta $3c				sta 	zsTemp 						; and zsTemp
.a7d3	ad 12 04	lda $0412			lda 	StringTempPointer+1
.a7d6	69 ff		adc #$ff			adc 	#$FF
.a7d8	8d 12 04	sta $0412			sta 	StringTempPointer+1
.a7db	85 3d		sta $3d				sta 	zsTemp+1
.a7dd	95 60		sta $60,x			sta 	NSMantissa1,x
.a7df	74 68		stz $68,x			stz 	NSMantissa2,x 				; set the typing data and the upper address bytes.
.a7e1	74 70		stz $70,x			stz 	NSMantissa3,x
.a7e3	a9 10		lda #$10			lda 	#NSTString
.a7e5	95 50		sta $50,x			sta 	NSStatus,x
.a7e7	a9 00		lda #$00			lda 	#0 							; clear the target string
.a7e9	92 3c		sta ($3c)			sta 	(zsTemp)
.a7eb	60		rts				rts
.a7ec					_STALength:
.a7ec	a9 09		lda #$09		lda	#9
.a7ee	4c ff 8e	jmp $8eff		jmp	ErrorHandler
.a7f1					StringTempWrite:
.a7f1	48		pha				pha
.a7f2	92 3c		sta ($3c)			sta 	(zsTemp) 					; write byte
.a7f4	e6 3c		inc $3c				inc 	zsTemp 						; bump pointer
.a7f6	d0 02		bne $a7fa			bne 	_STWNoCarry
.a7f8	e6 3d		inc $3d				inc 	zsTemp+1
.a7fa					_STWNoCarry:
.a7fa	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.a7fc	92 3c		sta ($3c)			sta 	(zsTemp)
.a7fe	68		pla				pla
.a7ff	60		rts				rts

;******  Return to file: _basic.asm

.a800					StartModuleCode:

;******  Processing file: ../modules/_build/_hardware.module

=1					hardwareIntegrated=1
=0					CONBlack = 0
=1					CONWhite = 1
=2					CONRed = 2
=3					CONCyan = 3
=4					CONPurple = 4
=5					CONGreen = 5
=6					CONBlue = 6
=7					CONYellow = 7
=8					CONOrange = 8
=9					CONBrown = 9
=10					CONYellowGreen = 10
=11					CONRosa = 11
=12					CONBlueGreen = 12
=13					CONLightBlue = 13
=14					CONPink = 14
=15					CONLightGreen = 15
=7					CONForeground = CONYellow
=6					CONBackground = CONBlue
=5					CLICommandLine = CONGreen
=0					CLIFComment = CONBlack
=7					CLIBComment = CONYellow
=9					CLILineNumber = CONBrown
=3					CLIToken = CONCyan
=13					CLIConstant = CONLightBlue
=7					CLIIdentifier = CONYellow
=10					CLIPunctuation = CONYellowGreen
=1					CLIData = CONWhite
.a800					Export_EXTPrintCharacter:
.a800					PAGEDPrintCharacter:
.a800	48		pha				pha
.a801	da		phx				phx
.a802	5a		phy				phy
.a803	a6 01		ldx $01				ldx 	1
.a805	da		phx				phx
.a806	ac 6e 06	ldy $066e			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.a809	09 00		ora #$00			ora 	#$00 						; check $80-$FF
.a80b	30 48		bmi $a855			bmi 	_EXPCColour
.a80d	c9 20		cmp #$20			cmp 	#$20 						; check $00-$1F
.a80f	90 4d		bcc $a85e			bcc 	_EXPCControl
.a811	a2 02		ldx #$02			ldx 	#2 							; select char memory
.a813	86 01		stx $01				stx 	1
.a815	91 40		sta ($40),y			sta 	(EXTAddress),y
.a817	e6 01		inc $01				inc 	1 							; select colour memory
.a819	ad 6f 06	lda $066f			lda 	EXTTextColour
.a81c	91 40		sta ($40),y			sta 	(EXTAddress),y
.a81e	c8		iny				iny 								; advance horizontal position
.a81f	8c 6e 06	sty $066e			sty 	EXTColumn
.a822	cc 70 06	cpy $0670			cpy 	EXTScreenWidth 				; reached RHS ?
.a825	90 63		bcc $a88a			bcc 	_EXPCExit 					; no, then exit.
.a827					_EXPCCRLF:
.a827	ee 6d 06	inc $066d			inc 	EXTRow  					; bump row
.a82a	9c 6e 06	stz $066e			stz 	EXTColumn 					; back to column 0
.a82d	ad 6d 06	lda $066d			lda 	EXTRow 						; check if reached the bottom ?
.a830	cd 71 06	cmp $0671			cmp 	EXTScreenHeight 			; if so, then scroll.
.a833	f0 18		beq $a84d			beq 	_EXPCScroll
.a835	18		clc				clc 								; add width to address.
.a836	a5 40		lda $40				lda 	EXTAddress
.a838	6d 70 06	adc $0670			adc 	EXTScreenWidth
.a83b	85 40		sta $40				sta 	EXTAddress
.a83d	90 4b		bcc $a88a			bcc 	_EXPCExit
.a83f	e6 41		inc $41				inc 	EXTAddress+1
.a841	80 47		bra $a88a			bra 	_EXPCExit
.a843					_EXPCLeft:
.a843	ce 6e 06	dec $066e			dec 	EXTColumn
.a846	10 42		bpl $a88a			bpl 	_EXPCExit
.a848					_EXPCBegin:
.a848	9c 6e 06	stz $066e			stz 	EXTColumn
.a84b	80 3d		bra $a88a			bra 	_EXPCExit
.a84d					_EXPCScroll:
.a84d	ce 6d 06	dec $066d			dec 	EXTRow 						; the height-1 th line.
.a850	20 3b a9	jsr $a93b			jsr 	EXTScreenScroll 			; scroll the screen
.a853	80 35		bra $a88a			bra 	_EXPCExit
.a855					_EXPCColour:
.a855	c9 a0		cmp #$a0			cmp 	#$A0						; 80-9F set foreground/background
.a857	b0 31		bcs $a88a			bcs 	_EXPCExit
.a859	20 1b a9	jsr $a91b			jsr 	_EXPCHandleColour
.a85c	80 2c		bra $a88a			bra 	_EXPCExit
.a85e					_EXPCControl:
.a85e	c9 11		cmp #$11			cmp 	#$11 						; only handle 00-10.
.a860	b0 28		bcs $a88a			bcs 	_EXPCExit
.a862	0a		asl a				asl 	a 							; double into X
.a863	aa		tax				tax
.a864	7c f9 a8	jmp ($a8f9,x)			jmp 	(_EXPCActionTable,x) 		; and execute code.
.a867					_EXPCUp:
.a867	ad 6d 06	lda $066d			lda 	EXTRow 						; already at top ?
.a86a	f0 1e		beq $a88a			beq 	_EXPCExit
.a86c	ce 6d 06	dec $066d			dec 	EXTRow 						; up one in position/address
.a86f	38		sec				sec
.a870	a5 40		lda $40				lda 	EXTAddress
.a872	ed 70 06	sbc $0670			sbc 	EXTScreenWidth
.a875	85 40		sta $40				sta 	EXTAddress
.a877	b0 11		bcs $a88a			bcs 	_EXPCExit
.a879	c6 41		dec $41				dec 	EXTAddress+1
.a87b	80 0d		bra $a88a			bra 	_EXPCExit
.a87d					_EXPCRight:
.a87d	c8		iny				iny
.a87e	8c 6e 06	sty $066e			sty 	EXTColumn
.a881	cc 70 06	cpy $0670			cpy 	EXTScreenWidth
.a884	d0 04		bne $a88a			bne 	_EXPCExit
.a886	88		dey				dey
.a887					_EXPCSetColumnY:
.a887	8c 6e 06	sty $066e			sty 	EXTColumn
.a88a					_EXPCExit:
.a88a	20 90 a9	jsr $a990			jsr 	EXTSetHardwareCursor 		; place the physical cursor.
.a88d	68		pla				pla
.a88e	85 01		sta $01				sta 	1
.a890	7a		ply				ply
.a891	fa		plx				plx
.a892	68		pla				pla
.a893	60		rts				rts
.a894					_EXPCClearScreen:
.a894	20 4d a9	jsr $a94d			jsr		EXTClearScreenCode
.a897	80 f1		bra $a88a			bra 	_EXPCExit
.a899					_EXPCDown:
.a899	ad 71 06	lda $0671			lda 	EXTScreenHeight 			; at the bottom
.a89c	3a		dec a				dec 	a
.a89d	cd 6d 06	cmp $066d			cmp 	EXTRow
.a8a0	f0 e8		beq $a88a			beq 	_EXPCExit
.a8a2	ee 6d 06	inc $066d			inc 	EXTRow 						; down one in position/address
.a8a5	18		clc				clc
.a8a6	a5 40		lda $40				lda 	EXTAddress
.a8a8	6d 70 06	adc $0670			adc 	EXTScreenWidth
.a8ab	85 40		sta $40				sta 	EXTAddress
.a8ad	90 db		bcc $a88a			bcc 	_EXPCExit
.a8af	e6 41		inc $41				inc 	EXTAddress+1
.a8b1	80 d7		bra $a88a			bra 	_EXPCExit
.a8b3					_EXPCTab:
.a8b3	ad 6e 06	lda $066e			lda 	EXTColumn 					; next tab stop
.a8b6	29 f8		and #$f8			and 	#$F8
.a8b8	18		clc				clc
.a8b9	69 08		adc #$08			adc 	#8
.a8bb	8d 6e 06	sta $066e			sta 	EXTColumn
.a8be	cd 70 06	cmp $0670			cmp 	EXTScreenWidth 				; too far, stick end of line.
.a8c1	90 c7		bcc $a88a			bcc 	_EXPCExit
.a8c3	80 10		bra $a8d5			bra 	_EXPCEnd
.a8c5					_EXPCBackSpace:
.a8c5	88		dey				dey
.a8c6	30 c2		bmi $a88a			bmi 	_EXPCExit
.a8c8	ce 6e 06	dec $066e			dec 	EXTColumn
.a8cb	a9 02		lda #$02			lda 	#2
.a8cd	85 01		sta $01				sta 	1
.a8cf	a9 20		lda #$20			lda 	#32
.a8d1	91 40		sta ($40),y			sta 	(EXTAddress),y
.a8d3	80 b5		bra $a88a			bra 	_EXPCExit
.a8d5					_EXPCEnd:
.a8d5	a9 02		lda #$02			lda 	#2 							; access text screen
.a8d7	85 01		sta $01				sta 	1
.a8d9	ac 70 06	ldy $0670			ldy 	EXTScreenWidth 				; point to last character
.a8dc	88		dey				dey
.a8dd					_EXPCEndSearch:
.a8dd	88		dey				dey 								; if past start, move to col 0.
.a8de	30 06		bmi $a8e6			bmi 	_EXPCFound
.a8e0	b1 40		lda ($40),y			lda 	(EXTAddress),y 				; keep going back till non space found
.a8e2	c9 20		cmp #$20			cmp 	#' '
.a8e4	f0 f7		beq $a8dd			beq 	_EXPCEndSearch
.a8e6					_EXPCFound:
.a8e6	c8		iny				iny 								; move to following cell.
.a8e7	80 9e		bra $a887			bra 	_EXPCSetColumnY
.a8e9					_EXPCClearEOL:
.a8e9	a9 02		lda #$02			lda 	#2 							; access character RAM
.a8eb	85 01		sta $01				sta 	1
.a8ed	a9 20		lda #$20			lda 	#' ' 						; write space
.a8ef	91 40		sta ($40),y			sta 	(EXTAddress),y
.a8f1	c8		iny				iny
.a8f2	cc 70 06	cpy $0670			cpy 	EXTScreenWidth 				; until RHS of screen.
.a8f5	90 f2		bcc $a8e9			bcc 	_EXPCClearEOL
.a8f7	80 91		bra $a88a			bra 	_EXPCExit
.a8f9					_EXPCActionTable:
>a8f9	8a a8						.word 	_EXPCExit 					; 00
>a8fb	48 a8						.word 	_EXPCBegin 					; 01 A Start of Line
>a8fd	43 a8						.word 	_EXPCLeft 					; 02 B Left
>a8ff	8a a8						.word 	_EXPCExit 					; 03 <Break>
>a901	8a a8						.word 	_EXPCExit 					; 04
>a903	d5 a8						.word 	_EXPCEnd 					; 05 E End of Line
>a905	7d a8						.word 	_EXPCRight 					; 06 F Right
>a907	8a a8						.word 	_EXPCExit 					; 07
>a909	c5 a8						.word 	_EXPCBackspace 				; 08 H Backspace
>a90b	b3 a8						.word 	_EXPCTab 					; 09 I Tab
>a90d	8a a8						.word 	_EXPCExit 					; 0A
>a90f	e9 a8						.word 	_EXPCClearEOL 				; 0B K Clear to EOL
>a911	94 a8						.word 	_EXPCClearScreen			; 0C L CLS
>a913	27 a8						.word 	_EXPCCRLF 					; 0D M CR/LF
>a915	99 a8						.word 	_EXPCDown 					; 0E N Down
>a917	8a a8						.word 	_EXPCExit 					; 0F
>a919	67 a8						.word 	_EXPCUp 					; 10 P Up
.a91b					_EXPCHandleColour
.a91b	c9 90		cmp #$90			cmp 	#$90 						; 8x foreground 9x background
.a91d	b0 16		bcs $a935			bcs 	_EXPCBackground
.a91f	0a		asl a				asl 	a 							; shift it 4 bits to the right.
.a920	0a		asl a				asl 	a
.a921	0a		asl a				asl 	a
.a922	0a		asl a				asl 	a
.a923	a2 0f		ldx #$0f			ldx 	#$0F 						; Mask in X
.a925					_EXPCUpdate:
.a925	48		pha				pha 								; save new colour
.a926	8a		txa				txa 								; get mask
.a927	2d 6f 06	and $066f			and 	EXTTextColour 				; mask out old.
.a92a	8d 6f 06	sta $066f			sta 	EXTTextColour
.a92d	68		pla				pla 								; or in new colour
.a92e	0d 6f 06	ora $066f			ora 	EXTTextColour
.a931	8d 6f 06	sta $066f			sta 	EXTTextColour
.a934	60		rts				rts
.a935					_EXPCBackground:
.a935	29 0f		and #$0f			and 	#$0F 						; get the colour
.a937	a2 f0		ldx #$f0			ldx 	#$F0 						; mask
.a939	80 ea		bra $a925			bra 	_EXPCUpdate
.a93b					EXTScreenScroll:
.a93b	a9 02		lda #$02			lda 	#2 							; select text page
.a93d	85 01		sta $01				sta 	1
.a93f	a9 20		lda #$20			lda		#32 						; fill with space
.a941	20 54 aa	jsr $aa54			jsr 	EXTScrollFill
.a944	e6 01		inc $01				inc 	1 							; select colour page
.a946	ad 6f 06	lda $066f			lda 	EXTTextColour
.a949	20 54 aa	jsr $aa54			jsr 	EXTScrollFill
.a94c	60		rts				rts
.a94d					EXTClearScreenCode:
.a94d	a9 02		lda #$02			lda 	#2 							; select text page
.a94f	85 01		sta $01				sta 	1
.a951	a9 20		lda #$20			lda		#32 						; fill with space
.a953	20 60 a9	jsr $a960			jsr 	_EXTCSFill
.a956	e6 01		inc $01				inc 	1 							; select colour page
.a958	ad 6f 06	lda $066f			lda 	EXTTextColour
.a95b	20 60 a9	jsr $a960			jsr 	_EXTCSFill
.a95e	80 22		bra $a982			bra 	EXTHomeCursor
.a960					_EXTCSFill:
.a960	aa		tax				tax
.a961	a9 00		lda #$00			lda 	#EXTMemory & $FF
.a963	85 40		sta $40				sta 	EXTAddress
.a965	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a967	85 41		sta $41				sta 	EXTAddress+1
.a969					_EXTCSFill1:
.a969	a0 00		ldy #$00			ldy 	#0
.a96b	8a		txa				txa
.a96c					_EXTCSFill2:
.a96c	91 40		sta ($40),y			sta 	(EXTAddress),y
.a96e	c8		iny				iny
.a96f	d0 fb		bne $a96c			bne 	_EXTCSFill2
.a971	e6 41		inc $41				inc 	EXTAddress+1
.a973	a5 41		lda $41				lda 	EXTAddress+1
.a975	c9 d2		cmp #$d2			cmp 	#$D2
.a977	d0 f0		bne $a969			bne 	_EXTCSFill1
.a979	8a		txa				txa
.a97a					_EXTCSFill3:
.a97a	91 40		sta ($40),y			sta 	(EXTAddress),y
.a97c	c8		iny				iny
.a97d	c0 c0		cpy #$c0			cpy 	#$C0
.a97f	d0 f9		bne $a97a			bne 	_EXTCSFill3
.a981	60		rts				rts
.a982					EXTHomeCursor:
.a982	9c 6d 06	stz $066d			stz 	EXTRow 						; reset row & column
.a985	9c 6e 06	stz $066e			stz 	EXTColumn
.a988	a9 00		lda #$00			lda 	#EXTMemory & $FF 			; set address
.a98a	85 40		sta $40				sta 	EXTAddress
.a98c	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a98e	85 41		sta $41				sta 	EXTAddress+1
.a990					EXTSetHardwareCursor:
.a990	64 01		stz $01				stz 	1 							; I/O Page zero
.a992	a9 05		lda #$05			lda 	#1+4 						; enable cursor
.a994	8d 10 d0	sta $d010			sta 	$D010
.a997	a9 b1		lda #$b1			lda 	#$B1
.a999	8d 12 d0	sta $d012			sta 	$D012
.a99c	ad 6e 06	lda $066e			lda 	EXTColumn
.a99f	8d 14 d0	sta $d014			sta 	$D014 						; set cursor position
.a9a2	9c 15 d0	stz $d015			stz 	$D015
.a9a5	ad 6d 06	lda $066d			lda 	EXTRow
.a9a8	8d 16 d0	sta $d016			sta 	$D016
.a9ab	9c 17 d0	stz $d017			stz 	$D017
.a9ae	60		rts				rts
.a9af					Export_EXTInputLine:
.a9af	48		pha				pha
.a9b0	da		phx				phx
.a9b1	5a		phy				phy
.a9b2	a5 01		lda $01				lda 	1 							; save I/O page
.a9b4	48		pha				pha
.a9b5					_EILLoop:
.a9b5	20 cf aa	jsr $aacf			jsr 	PagedInputSingleCharacter
.a9b8	c9 0d		cmp #$0d			cmp 	#13 						; scrape line if exit.
.a9ba	f0 44		beq $aa00			beq 	_EILExit
.a9bc	c9 04		cmp #$04			cmp 	#4 							; Ctrl+D delete at cursor
.a9be	f0 2a		beq $a9ea			beq 	_EILDelete
.a9c0	c9 08		cmp #$08			cmp 	#8 							; Ctrl+H backspace
.a9c2	f0 1c		beq $a9e0			beq 	_EILBackspace
.a9c4	c9 20		cmp #$20			cmp 	#' '						; < space, print it
.a9c6	90 12		bcc $a9da			bcc 	_EILPrintLoop
.a9c8	c9 7f		cmp #$7f			cmp 	#$7F 						; if -ve print it
.a9ca	b0 0e		bcs $a9da			bcs 	_EILPrintLoop
.a9cc	48		pha				pha 								; save character
.a9cd	a9 02		lda #$02			lda 	#2  						; insert a space
.a9cf	85 01		sta $01				sta 	1
.a9d1	20 42 aa	jsr $aa42			jsr 	EXTILInsert 				; insert in text screen
.a9d4	e6 01		inc $01				inc 	1
.a9d6	20 42 aa	jsr $aa42			jsr 	EXTILInsert 				; insert in colour screen
.a9d9	68		pla				pla 								; get character back.
.a9da					_EILPrintLoop:
.a9da	20 00 a8	jsr $a800			jsr 	PagedPrintCharacter
.a9dd	80 d6		bra $a9b5			bra 	_EILLoop
.a9df	60		rts				rts
.a9e0					_EILBackspace:
.a9e0	ad 6e 06	lda $066e			lda 	EXTColumn					; can we backspace ?
.a9e3	f0 d0		beq $a9b5			beq 	_EILLoop
.a9e5	a9 02		lda #$02			lda 	#2 							; move cursor left
.a9e7	20 00 a8	jsr $a800			jsr 	PagedPrintCharacter
.a9ea					_EILDelete
.a9ea	a9 02		lda #$02			lda 	#2 							; text block
.a9ec	85 01		sta $01				sta 	1
.a9ee	a9 20		lda #$20			lda 	#' ' 						; backspace text.
.a9f0	20 2d aa	jsr $aa2d			jsr 	EXTILDelete
.a9f3	e6 01		inc $01				inc 	1 							; colour block
.a9f5	ac 6e 06	ldy $066e			ldy 	EXTColumn 					; get attribute of last character
.a9f8	88		dey				dey
.a9f9	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a9fb	20 2d aa	jsr $aa2d			jsr 	EXTILDelete 				; backspace attribute
.a9fe	80 b5		bra $a9b5			bra 	_EILLoop 					; and go round.
.aa00					_EILExit:
.aa00	a9 02		lda #$02			lda 	#2 							; switch to page 2
.aa02	85 01		sta $01				sta 	1
.aa04	a0 00		ldy #$00			ldy 	#0 							; copy current line into buffer.
.aa06					_EILScrapeLine:
.aa06	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa08	99 2a 05	sta $052a,y			sta 	lineBuffer,y
.aa0b	c8		iny				iny
.aa0c	cc 70 06	cpy $0670			cpy 	EXTScreenWidth
.aa0f	d0 f5		bne $aa06			bne 	_EILScrapeLine
.aa11					_EILTrimSpaces:
.aa11	88		dey				dey
.aa12	f0 08		beq $aa1c			beq 	_EILEndTrim
.aa14	b9 2a 05	lda $052a,y			lda 	lineBuffer,y
.aa17	c9 20		cmp #$20			cmp 	#' '
.aa19	f0 f6		beq $aa11			beq 	_EILTrimSpaces
.aa1b	c8		iny				iny 								; trim after non space character.
.aa1c					_EILEndTrim:
.aa1c	a9 00		lda #$00			lda 	#0 							; trim here.
.aa1e	99 2a 05	sta $052a,y			sta 	lineBuffer,y
.aa21	a9 0d		lda #$0d			lda 	#13 						; echo the RETURN
.aa23	20 00 a8	jsr $a800			jsr 	PagedPrintCharacter
.aa26	68		pla				pla 								; reset I/O page
.aa27	85 01		sta $01				sta 	1
.aa29	7a		ply				ply
.aa2a	fa		plx				plx
.aa2b	68		pla				pla
.aa2c	60		rts				rts
.aa2d					EXTILDelete:
.aa2d	48		pha				pha 								; save the new character
.aa2e	ac 6e 06	ldy $066e			ldy 	EXTColumn 					; start copying from here.
.aa31					_EXTDLoop:
.aa31	c8		iny				iny 								; copy one byte down.
.aa32	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa34	88		dey				dey
.aa35	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa37	c8		iny				iny 								; do till end of line.
.aa38	cc 70 06	cpy $0670			cpy 	EXTScreenWidth
.aa3b	90 f4		bcc $aa31			bcc 	_EXTDLoop
.aa3d	88		dey				dey 	 							; write in last slot.
.aa3e	68		pla				pla
.aa3f	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa41	60		rts				rts
.aa42					EXTILInsert:
.aa42	ac 70 06	ldy $0670			ldy 	EXTScreenWidth 				; end position
.aa45					_EXTILoop:
.aa45	88		dey				dey 								; back one
.aa46	cc 6e 06	cpy $066e			cpy 	EXTColumn 					; exit if reached insert point.
.aa49	f0 08		beq $aa53			beq 	_EXTIExit
.aa4b	88		dey				dey 								; copy one byte up.
.aa4c	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa4e	c8		iny				iny
.aa4f	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa51	80 f2		bra $aa45			bra 	_EXTILoop
.aa53					_EXTIExit:
.aa53	60		rts				rts
.aa54					EXTScrollFill:
.aa54	aa		tax				tax									; save value to fill with
.aa55	a5 36		lda $36				lda 	zTemp0 						; save zTemp0 (dest) zTemp1 (src)
.aa57	48		pha				pha
.aa58	a5 37		lda $37				lda 	zTemp0+1
.aa5a	48		pha				pha
.aa5b	a5 38		lda $38				lda 	zTemp1
.aa5d	48		pha				pha
.aa5e	a5 39		lda $39				lda 	zTemp1+1
.aa60	48		pha				pha
.aa61	a9 c0		lda #$c0			lda 	#$C0 						; copy from C000+length to C000
.aa63	85 37		sta $37				sta 	zTemp0+1
.aa65	85 39		sta $39				sta 	zTemp1+1
.aa67	64 36		stz $36				stz 	zTemp0
.aa69	ad 70 06	lda $0670			lda 	EXTScreenWidth
.aa6c	85 38		sta $38				sta 	zTemp1
.aa6e	a0 00		ldy #$00			ldy 	#0
.aa70					_EXSFCopy1:
.aa70	b1 38		lda ($38),y			lda 	(zTemp1),y
.aa72	91 36		sta ($36),y			sta 	(zTemp0),y
.aa74	c8		iny				iny
.aa75	d0 f9		bne $aa70			bne 	_EXSFCopy1
.aa77	e6 37		inc $37				inc 	zTemp0+1 					; next page
.aa79	e6 39		inc $39				inc 	zTemp1+1
.aa7b	a5 39		lda $39				lda 	zTemp1+1
.aa7d	c9 d3		cmp #$d3			cmp 	#$D3
.aa7f	d0 ef		bne $aa70			bne 	_EXSFCopy1
.aa81	ac 70 06	ldy $0670			ldy 	EXTScreenWidth 				; blank the bottom line.
.aa84	8a		txa				txa
.aa85					_EXSFFill1:
.aa85	88		dey				dey
.aa86	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa88	c0 00		cpy #$00			cpy 	#0
.aa8a	10 f9		bpl $aa85			bpl 	_EXSFFill1
.aa8c	68		pla				pla
.aa8d	85 39		sta $39				sta 	zTemp1+1
.aa8f	68		pla				pla
.aa90	85 38		sta $38				sta 	zTemp1
.aa92	68		pla				pla
.aa93	85 37		sta $37				sta 	zTemp0+1
.aa95	68		pla				pla
.aa96	85 36		sta $36				sta 	zTemp0
.aa98	60		rts				rts
=$c000					EXTMemory = $C000
=$02					EXTTextPage = $02
=$03					EXTColourPage = $03
=1					EXTDummySpace = 1 							; fake-space for CR character.
=0					EXTCBlack = 0
.066d					EXTRow:
>066d							.fill 	1
.066e					EXTColumn:
>066e							.fill 	1
.066f					EXTTextColour:
>066f							.fill 	1
.0670					EXTScreenWidth:
>0670							.fill 	1
.0671					EXTScreenHeight:
>0671							.fill 	1
.0040					EXTAddress:
>0040							.fill 	2
.aa99					Export_EXTInitialise:
.aa99	64 01		stz $01				stz 	1 							; Access I/O page 0
.aa9b	9c 04 d0	stz $d004			stz 	$D004 						; Disable border
.aa9e	9c 08 d0	stz $d008			stz 	$D008
.aaa1	9c 09 d0	stz $d009			stz 	$D009
.aaa4	a9 09		lda #$09			lda 	#1+8						; Timer On at 70Hz counting up.
.aaa6	8d 58 d6	sta $d658			sta 	$D658
.aaa9	a9 03		lda #$03			lda 	#3 							; get current text colour from whatever the kernel
.aaab	85 01		sta $01				sta 	1 							; has set it to, looking at top left character
.aaad	ad 00 c0	lda $c000			lda 	$C000
.aab0	8d 6f 06	sta $066f			sta 	EXTTextColour
.aab3	a9 50		lda #$50			lda 	#80 						; set screen dimensions.
.aab5	8d 70 06	sta $0670			sta 	EXTScreenWidth
.aab8	a9 3c		lda #$3c			lda 	#60
.aaba	8d 71 06	sta $0671			sta 	EXTScreenHeight
.aabd	20 82 a9	jsr $a982			jsr 	EXTHomeCursor 				; home cursor
.aac0					_EXMoveDown:
.aac0	a9 0d		lda #$0d			lda 	#13
.aac2	20 00 a8	jsr $a800			jsr 	PAGEDPrintCharacter
.aac5	ad 6d 06	lda $066d			lda 	EXTRow
.aac8	c9 08		cmp #$08			cmp 	#8
.aaca	d0 f4		bne $aac0			bne 	_EXMoveDown
.aacc	64 01		stz $01				stz 	1
.aace	60		rts				rts
.aacf					Export_EXTInputSingleCharacter:
.aacf					PagedInputSingleCharacter:
.aacf	da		phx				phx
.aad0	5a		phy				phy
.aad1					_EISCWait:
.aad1	a5 01		lda $01				lda 	1 							; save I/O 0
.aad3	48		pha				pha
.aad4	64 01		stz $01				stz 	1 							; access I/O Page 0
.aad6	38		sec				sec 								; calculate timer - LastTick
.aad7	ad 59 d6	lda $d659			lda 	$D659
.aada	aa		tax				tax 								; saving timer in X
.aadb	ed 5c 06	sbc $065c			sbc 	LastTick
.aade	c9 03		cmp #$03			cmp 	#3
.aae0	90 06		bcc $aae8			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.aae2	8e 5c 06	stx $065c			stx 	LastTick 					; update last timer
.aae5	20 ab be	jsr $beab			jsr 	PagedSNDUpdate 							; go do the code.
.aae8					_NoFireTick:
.aae8	68		pla				pla 								; restore I/O 0
.aae9	85 01		sta $01				sta 	1
.aaeb	20 e4 ff	jsr $ffe4			jsr 	$FFE4 						; get a key
.aaee	c9 00		cmp #$00			cmp 	#0 							; loop back if none pressed.
.aaf0	f0 df		beq $aad1			beq 	_EISCWait
.aaf2	7a		ply				ply
.aaf3	fa		plx				plx
.aaf4	60		rts				rts
.aaf5					Export_EXTBreakCheck:
.aaf5	4c e1 ff	jmp $ffe1			jmp		$FFE1
.aaf8					Export_EXTReadController:
.aaf8	da		phx				phx
.aaf9	a2 00		ldx #$00			ldx 	#0
.aafb	a9 05		lda #$05			lda 	#(($2D) >> 3)
.aafd	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab00	29 20		and #$20			and 	#($01 << (($2D) & 7))
.ab02	f0 04		beq $ab08			beq 	_NoSet1
.ab04	8a		txa				txa
.ab05	09 01		ora #$01			ora 	#1
.ab07	aa		tax				tax
.ab08					_NoSet1:
.ab08	a9 05		lda #$05			lda 	#(($2C) >> 3)
.ab0a	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab0d	29 10		and #$10			and 	#($01 << (($2C) & 7))
.ab0f	f0 04		beq $ab15			beq 	_NoSet1
.ab11	8a		txa				txa
.ab12	09 02		ora #$02			ora 	#2
.ab14	aa		tax				tax
.ab15					_NoSet1:
.ab15	a9 06		lda #$06			lda 	#(($32) >> 3)
.ab17	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab1a	29 04		and #$04			and 	#($01 << (($32) & 7))
.ab1c	f0 04		beq $ab22			beq 	_NoSet1
.ab1e	8a		txa				txa
.ab1f	09 04		ora #$04			ora 	#4
.ab21	aa		tax				tax
.ab22					_NoSet1:
.ab22	a9 04		lda #$04			lda 	#(($25) >> 3)
.ab24	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab27	29 20		and #$20			and 	#($01 << (($25) & 7))
.ab29	f0 04		beq $ab2f			beq 	_NoSet1
.ab2b	8a		txa				txa
.ab2c	09 08		ora #$08			ora 	#8
.ab2e	aa		tax				tax
.ab2f					_NoSet1:
.ab2f	a9 04		lda #$04			lda 	#(($26) >> 3)
.ab31	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab34	29 40		and #$40			and 	#($01 << (($26) & 7))
.ab36	f0 04		beq $ab3c			beq 	_NoSet1
.ab38	8a		txa				txa
.ab39	09 10		ora #$10			ora 	#16
.ab3b	aa		tax				tax
.ab3c					_NoSet1:
.ab3c	8a		txa				txa
.ab3d	fa		plx				plx
.ab3e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_graphics.module

=1					graphicsIntegrated=1
=0					GCMD_Initialise = 0*2
=2					GCMD_BitmapCtl = 1*2
=4					GCMD_SpriteCtl = 2*2
=6					GCMD_Clear = 3*2
=8					GCMD_Colour = 4*2
=10					GCMD_DrawFont = 5*2
=12					GCMD_DrawSprite = 6*2
=14					GCMD_SpriteUse = 7*2
=16					GCMD_SpriteImage = 8*2
=18					GCMD_SpriteCollide = 9*2
=64					GCMD_Move = 32*2
=66					GCMD_Line = 33*2
=68					GCMD_FrameRect = 34*2
=70					GCMD_FillRect = 35*2
=72					GCMD_FrameCircle = 36*2
=74					GCMD_FillCircle = 37*2
=80					GCMD_Plot = 40*2
=82					GCMD_SpriteMove = 41*2
=42					GRFirstFreeCode = 42
.ab3f					GRVectorTable:
>ab3f	8e ad					.word	GXInitialise             ; $00 Initialise
>ab41	a8 ad					.word	GXControlBitmap          ; $01 BitmapCtl
>ab43	f0 ad					.word	GXControlSprite          ; $02 SpriteCtl
>ab45	40 ad					.word	GXClearBitmap            ; $03 Clear
>ab47	7f af					.word	GXSetColourMode          ; $04 Colour
>ab49	47 b1					.word	GXFontHandler            ; $05 DrawFont
>ab4b	8f b1					.word	GXSpriteHandler          ; $06 DrawSprite
>ab4d	00 b2					.word	GXSelect                 ; $07 SpriteUse
>ab4f	29 b2					.word	GXSelectImage            ; $08 SpriteImage
>ab51	b0 b3					.word	GXCollide                ; $09 SpriteCollide
>ab53	f2 ab					.word	GRUndefined              ; $0a
>ab55	f2 ab					.word	GRUndefined              ; $0b
>ab57	f2 ab					.word	GRUndefined              ; $0c
>ab59	f2 ab					.word	GRUndefined              ; $0d
>ab5b	f2 ab					.word	GRUndefined              ; $0e
>ab5d	f2 ab					.word	GRUndefined              ; $0f
>ab5f	f2 ab					.word	GRUndefined              ; $10
>ab61	f2 ab					.word	GRUndefined              ; $11
>ab63	f2 ab					.word	GRUndefined              ; $12
>ab65	f2 ab					.word	GRUndefined              ; $13
>ab67	f2 ab					.word	GRUndefined              ; $14
>ab69	f2 ab					.word	GRUndefined              ; $15
>ab6b	f2 ab					.word	GRUndefined              ; $16
>ab6d	f2 ab					.word	GRUndefined              ; $17
>ab6f	f2 ab					.word	GRUndefined              ; $18
>ab71	f2 ab					.word	GRUndefined              ; $19
>ab73	f2 ab					.word	GRUndefined              ; $1a
>ab75	f2 ab					.word	GRUndefined              ; $1b
>ab77	f2 ab					.word	GRUndefined              ; $1c
>ab79	f2 ab					.word	GRUndefined              ; $1d
>ab7b	f2 ab					.word	GRUndefined              ; $1e
>ab7d	f2 ab					.word	GRUndefined              ; $1f
>ab7f	f0 ab					.word	GXMove                   ; $20 Move
>ab81	4d ae					.word	GXLine                   ; $21 Line
>ab83	c8 af					.word	GXFrameRectangle         ; $22 FrameRect
>ab85	c5 af					.word	GXFillRectangle          ; $23 FillRect
>ab87	f7 ab					.word	GXFrameCircle            ; $24 FrameCircle
>ab89	f3 ab					.word	GXFillCircle             ; $25 FillCircle
>ab8b	f2 ab					.word	GRUndefined              ; $26
>ab8d	f2 ab					.word	GRUndefined              ; $27
>ab8f	ad af					.word	GXPlotPoint              ; $28 Plot
>ab91	bf b2					.word	GXMoveSprite             ; $29 SpriteMove
=3					GXMappingPage = 3
=24576					GXMappingAddress = ($2000 * GXMappingPage)
=11					GXEditSlot = 8 + GXMappingPage
=$36					gxzTemp0 = zTemp0
=$38					gxzTemp1 = zTemp1
=$3a					gxzTemp2 = zTemp2
=$3c					gxzScreen = zsTemp
=$627					gxPixelBuffer = numberBuffer
.0672					gxCurrentX:
>0672							.fill 	2
.0674					gxCurrentY:
>0674							.fill 	2
.0676					gxLastX:
>0676							.fill 	2
.0678					gxLastY:
>0678							.fill 	2
.067a					gxX0:
>067a							.fill 	2
.067c					gxY0:
>067c							.fill 	2
.067e					gxX1:
>067e							.fill 	2
.0680					gxY1:
>0680							.fill 	2
.0682					gxSpritesOn:
>0682							.fill 	1
.0683					gxBitmapsOn:
>0683							.fill 	1
.0684					gxBasePage:
>0684							.fill 	1
.0685					gxSpritePage:
>0685							.fill 	1
.0686					gxHeight:
>0686							.fill 	1
.0687					gxMode:
>0687							.fill 	1
.0688					gxColour:
>0688							.fill 	1
.0689					gxEORValue:
>0689							.fill 	1
.068a					gxANDValue:
>068a							.fill 	1
.068b					gxOriginalLUTValue:
>068b							.fill 	1
.068c					gsOffset:
>068c							.fill 	1
.068d					GSCurrentSpriteID:
>068d							.fill 	1
.068e					GSCurrentSpriteAddr:
>068e							.fill 	2
.0690					GXSpriteOffsetBase:
>0690							.fill 	2
.0692					GXSpriteLow:
>0692							.fill 	64
.06d2					GXSpriteHigh:
>06d2							.fill 	64
.ab93					Export_GXGraphicDraw:
.ab93	c9 40		cmp #$40			cmp 	#GCMD_Move					; low instructions don't use coordinates
.ab95	b0 06		bcs $ab9d			bcs 	_GDCoordinate
.ab97	86 36		stx $36				stx 	gxzTemp0 					; save X/Y
.ab99	84 37		sty $37				sty 	gxzTemp0+1
.ab9b	80 4b		bra $abe8			bra 	_GDExecuteA 				; and execute
.ab9d					_GDCoordinate:
.ab9d	48		pha				pha 								; save AXY
.ab9e	da		phx				phx
.ab9f	5a		phy				phy
.aba0	a2 03		ldx #$03			ldx 	#3 							; copy currentX to lastX
.aba2					_GDCopy1:
.aba2	bd 72 06	lda $0672,x			lda 	gxCurrentX,x
.aba5	9d 76 06	sta $0676,x			sta 	gxLastX,x
.aba8	ca		dex				dex
.aba9	10 f7		bpl $aba2			bpl 	_GDCopy1
.abab	68		pla				pla 								; update Y
.abac	8d 74 06	sta $0674			sta 	gxCurrentY
.abaf	9c 75 06	stz $0675			stz 	gxCurrentY+1
.abb2	68		pla				pla
.abb3	8d 72 06	sta $0672			sta 	gxCurrentX
.abb6	68		pla				pla 								; get A (command+X.1) back
.abb7	48		pha				pha
.abb8	29 01		and #$01			and 	#1 							; put LSB as MSB of Current.X
.abba	8d 73 06	sta $0673			sta 	gxCurrentX+1
.abbd	68		pla				pla 								; get command back
.abbe	29 fe		and #$fe			and 	#$FE 						; lose LSB, chuck the stray X bit
.abc0	48		pha				pha 								; push back.
.abc1	c9 52		cmp #$52			cmp 	#GCMD_SpriteMove 			; move sprite does not clip.
.abc3	f0 17		beq $abdc			beq 	_GDCopyToWorkArea
.abc5	ad 73 06	lda $0673			lda 	gxCurrentX+1 				; X < 256 X okay
.abc8	f0 07		beq $abd1			beq 	_GDCheckY
.abca	ad 72 06	lda $0672			lda 	gxCurrentX 					; otherwise X < 320 = 256 + 64
.abcd	c9 40		cmp #$40			cmp 	#64
.abcf	b0 08		bcs $abd9			bcs 	_GDError1
.abd1					_GDCheckY:
.abd1	ad 74 06	lda $0674			lda 	gxCurrentY 					; check Y < Height.
.abd4	cd 86 06	cmp $0686			cmp 	gxHeight
.abd7	90 03		bcc $abdc			bcc 	_GDCopyToWorkArea
.abd9					_GDError1:
.abd9	68		pla				pla
.abda					_GDError2:
.abda	38		sec				sec
.abdb	60		rts				rts
.abdc					_GDCopyToWorkArea:
.abdc	a2 07		ldx #$07			ldx 	#7 							; copy current and last to gxXY/12 work area
.abde					_GDCopy2:
.abde	bd 72 06	lda $0672,x			lda 	gxCurrentX,x
.abe1	9d 7a 06	sta $067a,x			sta 	gxX0,x
.abe4	ca		dex				dex
.abe5	10 f7		bpl $abde			bpl 	_GDCopy2
.abe7	68		pla				pla 								; get command
.abe8					_GDExecuteA:
.abe8	c9 54		cmp #$54			cmp 	#GRFirstFreeCode*2 			; bad ?
.abea	b0 ee		bcs $abda			bcs 	_GDError2
.abec	aa		tax				tax
.abed	7c 3f ab	jmp ($ab3f,x)			jmp 	(GRVectorTable,x)
.abf0					GXMove:
.abf0	18		clc				clc
.abf1	60		rts				rts
.abf2					GRUndefined:
>abf2	db						.byte 	$DB 						; causes a break in the emulator
.abf3					GXFillCircle:
.abf3	a9 ff		lda #$ff			lda 	#255
.abf5	80 02		bra $abf9			bra 	GXCircle
.abf7					GXFrameCircle:
.abf7	a9 00		lda #$00			lda 	#0
.abf9					GXCircle:
.abf9	8d 15 07	sta $0715			sta 	gxIsFillMode					; save Fill flag
.abfc	ad 83 06	lda $0683			lda 	gxBitmapsOn
.abff	f0 26		beq $ac27			beq 	_GXCFail
.ac01	20 57 b4	jsr $b457			jsr 	GXSortXY 					; topleft/bottomright
.ac04	20 2f b3	jsr $b32f			jsr 	GXOpenBitmap 				; start drawing
.ac07	20 f9 ac	jsr $acf9			jsr 	GXCircleSetup 				; set up for drawing
.ac0a	9c 16 07	stz $0716			stz 	gxYChanged
.ac0d					_GXCircleDraw:
.ac0d	ad 13 07	lda $0713			lda 	gXCentre					; while x <= y
.ac10	cd 14 07	cmp $0714			cmp 	gYCentre
.ac13	90 0a		bcc $ac1f			bcc 	_GXCircleContinue
.ac15	d0 03		bne $ac1a			bne 	_GXNoLast
.ac17	20 2c ac	jsr $ac2c			jsr 	GXPlot1
.ac1a					_GXNoLast:
.ac1a	20 37 b3	jsr $b337			jsr 	GXCloseBitmap 				; close the bitmap
.ac1d	18		clc				clc
.ac1e	60		rts				rts
.ac1f					_GXCircleContinue:
.ac1f	20 29 ac	jsr $ac29			jsr 	GXPlot2 					; draw it
.ac22	20 a6 ac	jsr $aca6			jsr 	GXCircleMove 				; adjust the coordinates
.ac25	80 e6		bra $ac0d			bra 	_GXCircleDraw
.ac27					_GXCFail:
.ac27	38		sec				sec
.ac28	60		rts				rts
.ac29					GXPlot2:
.ac29	20 2c ac	jsr $ac2c			jsr 	GXPlot1 						; plot and swap, fall through does twice
.ac2c					GXPlot1:
.ac2c	ad 14 07	lda $0714			lda 	gYCentre 						; if y = 0, don't do it twice (xor)
.ac2f	f0 03		beq $ac34			beq 	_GXPlot1Only
.ac31	20 50 ac	jsr $ac50			jsr 	GXPlot0 						; plot and negate
.ac34					_GXPlot1Only:
.ac34	20 50 ac	jsr $ac50			jsr 	GXPlot0 						; twice, undoing negation
.ac37	ad 13 07	lda $0713			lda 	gXCentre 						; swap X and Y
.ac3a	ae 14 07	ldx $0714			ldx	 	gYCentre
.ac3d	8d 14 07	sta $0714			sta 	gYCentre
.ac40	8e 13 07	stx $0713			stx 	gXCentre
.ac43	ad 16 07	lda $0716			lda 	gxYChanged 						; toggle Y Changed flag
.ac46	a9 ff		lda #$ff			lda 	#$FF
.ac48	8d 16 07	sta $0716			sta 	gxYChanged
.ac4b	60		rts				rts
.ac4c	20 50 ac	jsr $ac50			jsr 	GXPlot0 						; do once
.ac4f	60		rts				rts
.ac50	ad 15 07	lda $0715	GXPlot0:lda 	gxIsFillMode 					; outline mode, always draw as X or Y will change
.ac53	f0 05		beq $ac5a			beq 	_GXPlot0Always
.ac55	ad 16 07	lda $0716			lda 	gxYChanged						; fill mode, only draw if changed.
.ac58	f0 2d		beq $ac87			beq 	GXPlot0Exit
.ac5a					_GXPlot0Always:
.ac5a	a2 02		ldx #$02			ldx 	#2 								; copy Y1-A => Y0
.ac5c	ad 14 07	lda $0714			lda 	gYCentre
.ac5f	20 88 ac	jsr $ac88			jsr 	GXSubCopy
.ac62	a2 00		ldx #$00			ldx 	#0 								; copy X1-A => X0,
.ac64	ad 13 07	lda $0713			lda 	gXCentre
.ac67	20 88 ac	jsr $ac88			jsr 	GXSubCopy
.ac6a	48		pha				pha 									; save last offset X
.ac6b	20 3f b3	jsr $b33f			jsr 	GXPositionCalc 					; calculate position/offset.
.ac6e	68		pla				pla
.ac6f	0a		asl a				asl 	a 								; store 2 x last offset in gxzTemp0
.ac70	85 36		sta $36				sta 	gxzTemp0
.ac72	64 37		stz $37				stz 	gxzTemp0+1
.ac74	26 37		rol $37				rol 	gxzTemp0+1
.ac76	ad 15 07	lda $0715			lda 	gxIsFillMode
.ac79	69 80		adc #$80			adc 	#128
.ac7b	20 18 b0	jsr $b018			jsr 	GXDrawLineTemp0 				; routine from Rectangle.
.ac7e	38		sec				sec 									; GY = -GY
.ac7f	a9 00		lda #$00			lda 	#0
.ac81	ed 14 07	sbc $0714			sbc 	gYCentre
.ac84	8d 14 07	sta $0714			sta 	gYCentre
.ac87					GXPlot0Exit:
.ac87	60		rts				rts
.ac88					GXSubCopy:
.ac88	85 36		sta $36				sta 	gxzTemp0
.ac8a	64 37		stz $37				stz 	gxzTemp0+1
.ac8c	29 80		and #$80			and 	#$80
.ac8e	f0 02		beq $ac92			beq 	_GXNoSx
.ac90	c6 37		dec $37				dec 	gxzTemp0+1
.ac92					_GXNoSx:
.ac92	38		sec				sec
.ac93	bd 7e 06	lda $067e,x			lda 	gXX1,x
.ac96	e5 36		sbc $36				sbc 	gxzTemp0
.ac98	9d 7a 06	sta $067a,x			sta 	gXX0,x
.ac9b	bd 7f 06	lda $067f,x			lda 	gXX1+1,x
.ac9e	e5 37		sbc $37				sbc 	gxzTemp0+1
.aca0	9d 7b 06	sta $067b,x			sta 	gXX0+1,x
.aca3	a5 36		lda $36				lda 	gxzTemp0 						; return A
.aca5	60		rts				rts
.aca6					GXCircleMove:
.aca6	9c 16 07	stz $0716			stz 	gxYChanged 					; clear Y changed flag
.aca9	a5 39		lda $39				lda 	gxzTemp1+1 					; check sign of D
.acab	10 0d		bpl $acba			bpl 	_GXEMPositive
.acad	ee 13 07	inc $0713			inc 	gXCentre 					; X++
.acb0	ad 13 07	lda $0713			lda 	gXCentre
.acb3	20 d9 ac	jsr $acd9			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.acb6	a9 06		lda #$06			lda 	#6  						; and add 6
.acb8	80 15		bra $accf			bra 	_GXEMAddD
.acba					_GXEMPositive:
.acba	ee 13 07	inc $0713			inc 	gXCentre					; X++
.acbd	ce 14 07	dec $0714			dec 	gyCentre 					; Y--
.acc0	38		sec				sec 								; calculate X-Y
.acc1	ad 13 07	lda $0713			lda 	gXCentre
.acc4	ed 14 07	sbc $0714			sbc 	gYCentre
.acc7	20 d9 ac	jsr $acd9			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.acca	a9 0a		lda #$0a			lda 	#10  						; and add 10
.accc	ce 16 07	dec $0716			dec 	gxYChanged
.accf					_GXEMAddD:
.accf	18		clc				clc
.acd0	65 38		adc $38				adc 	gxzTemp1
.acd2	85 38		sta $38				sta 	gxzTemp1
.acd4	90 02		bcc $acd8			bcc 	_GXEMNoCarry
.acd6	e6 39		inc $39				inc 	gxzTemp1+1
.acd8					_GXEMNoCarry:
.acd8	60		rts				rts
.acd9					_GXAdd4TimesToD:
.acd9	85 36		sta $36				sta 	gxzTemp0 					; make 16 bit signed.
.acdb	29 80		and #$80			and 	#$80
.acdd	f0 02		beq $ace1			beq 	_GXA4Unsigned
.acdf	a9 ff		lda #$ff			lda 	#$FF
.ace1					_GXA4Unsigned:
.ace1	85 37		sta $37				sta 	gxzTemp0+1
.ace3	06 36		asl $36				asl 	gxzTemp0  					; x 4
.ace5	26 37		rol $37				rol 	gxzTemp0+1
.ace7	06 36		asl $36				asl 	gxzTemp0
.ace9	26 37		rol $37				rol 	gxzTemp0+1
.aceb	18		clc				clc 								; add
.acec	a5 36		lda $36				lda		gxzTemp0
.acee	65 38		adc $38				adc 	gxzTemp1
.acf0	85 38		sta $38				sta 	gxzTemp1
.acf2	a5 37		lda $37				lda		gxzTemp0+1
.acf4	65 39		adc $39				adc 	gxzTemp1+1
.acf6	85 39		sta $39				sta 	gxzTemp1+1
.acf8	60		rts				rts
.acf9					GXCircleSetup:
.acf9	38		sec				sec
.acfa	ad 80 06	lda $0680			lda 	gxY1
.acfd	ed 7c 06	sbc $067c			sbc 	gxY0
.ad00	4a		lsr a				lsr 	a
.ad01	8d 12 07	sta $0712			sta 	gxRadius
.ad04	a2 00		ldx #$00			ldx 	#0
.ad06	20 28 ad	jsr $ad28			jsr 	_GXCalculateCentre
.ad09	a2 02		ldx #$02			ldx 	#2
.ad0b	20 28 ad	jsr $ad28			jsr 	_GXCalculateCentre
.ad0e	9c 13 07	stz $0713			stz 	gXCentre
.ad11	ad 12 07	lda $0712			lda 	gxRadius
.ad14	8d 14 07	sta $0714			sta 	gYCentre
.ad17	0a		asl a				asl 	a 							; R x 2
.ad18	85 36		sta $36				sta 	gxzTemp0
.ad1a	38		sec				sec
.ad1b	a9 03		lda #$03			lda 	#3
.ad1d	e5 36		sbc $36				sbc 	gxzTemp0
.ad1f	85 38		sta $38				sta 	gxzTemp1
.ad21	a9 00		lda #$00			lda 	#0
.ad23	e9 00		sbc #$00			sbc 	#0
.ad25	85 39		sta $39				sta 	gxzTemp1+1
.ad27	60		rts				rts
.ad28					_GXCalculateCentre:
.ad28	38		sec				sec
.ad29	bd 7e 06	lda $067e,x			lda 	gxX1,x
.ad2c	7d 7a 06	adc $067a,x			adc 	gXX0,x
.ad2f	9d 7e 06	sta $067e,x			sta 	gXX1,x
.ad32	bd 7f 06	lda $067f,x			lda 	gXX1+1,x
.ad35	7d 7b 06	adc $067b,x			adc 	gXX0+1,x
.ad38	4a		lsr a				lsr 	a
.ad39	9d 7f 06	sta $067f,x			sta 	gXX1+1,x
.ad3c	7e 7e 06	ror $067e,x			ror 	gXX1,x
.ad3f	60		rts				rts
.0712					gxRadius:
>0712							.fill 	1
.0713					gXCentre:
>0713							.fill 	1
.0714					gYCentre:
>0714							.fill 	1
.0715					gxIsFillMode:
>0715							.fill 	1
.0716					gxYChanged:
>0716							.fill  	1
=64000					ScreenSize200 = 320 * 200
=76800					ScreenSize240 = 320 * 240
.ad40					GXClearBitmap:
.ad40	ad 83 06	lda $0683			lda 	gxBitmapsOn 				; check BMP running.
.ad43	f0 24		beq $ad69			beq 	_GXCBFail
.ad45	20 2f b3	jsr $b32f			jsr 	GXOpenBitmap 				; start access
.ad48	a0 07		ldy #$07			ldy 	#ScreenSize200 / 8192 		; X is pages to clear
.ad4a	ad 86 06	lda $0686			lda 	gxHeight
.ad4d	c9 c8		cmp #$c8			cmp 	#200 						; 200 ?
.ad4f	a0 09		ldy #$09			ldy 	#ScreenSize240 / 8192
.ad51					_GXCalcLastPage:
.ad51	98		tya				tya 								; add to base page
.ad52	18		clc				clc
.ad53	6d 84 06	adc $0684			adc 	gxBasePage
.ad56	85 0b		sta $0b				sta 	GXEditSlot  				; clear from this page back
.ad58					_GXClearAll:
.ad58	20 6b ad	jsr $ad6b			jsr 	_GXClearBlock 				; clear 8k block
.ad5b	c6 0b		dec $0b				dec 	GXEditSlot  				; back to previous
.ad5d	a5 0b		lda $0b				lda 	GXEditSlot
.ad5f	cd 84 06	cmp $0684			cmp 	gxBasePage 					; until before base page
.ad62	b0 f4		bcs $ad58			bcs 	_GXClearAll
.ad64	20 37 b3	jsr $b337			jsr 	GXCloseBitmap	 			; stop access
.ad67	18		clc				clc
.ad68	60		rts				rts
.ad69					_GXCBFail:
.ad69	38		sec				sec
.ad6a	60		rts				rts
.ad6b					_GXClearBlock:
.ad6b	a9 00		lda #$00			lda 	#((GXMappingAddress) & $FF)
.ad6d	85 38		sta $38				sta 	0+gxzTemp1
.ad6f	a9 60		lda #$60			lda 	#((GXMappingAddress) >> 8)
.ad71	85 39		sta $39				sta 	1+gxzTemp1
.ad73					_GXCB0:
.ad73	a5 36		lda $36				lda 	gxzTemp0
.ad75	a0 00		ldy #$00			ldy 	#0
.ad77					_GXCB1:
.ad77	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad79	c8		iny				iny
.ad7a	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad7c	c8		iny				iny
.ad7d	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad7f	c8		iny				iny
.ad80	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad82	c8		iny				iny
.ad83	d0 f2		bne $ad77			bne 	_GXCB1
.ad85	e6 39		inc $39				inc 	gxzTemp1+1
.ad87	a5 39		lda $39				lda 	gxzTemp1+1
.ad89	c9 80		cmp #$80			cmp	 	#(GXMappingAddress >> 8)+$20
.ad8b	d0 e6		bne $ad73			bne 	_GXCB0
.ad8d	60		rts				rts
.ad8e					GXInitialise:
.ad8e	64 01		stz $01				stz 	1
.ad90	a9 01		lda #$01			lda 	#1
.ad92	8d 00 d0	sta $d000			sta 	$D000
.ad95	18		clc				clc
.ad96	9c 82 06	stz $0682			stz 	GXSpritesOn
.ad99	9c 83 06	stz $0683			stz 	GXBitmapsOn
.ad9c	a2 0f		ldx #$0f			ldx 	#15
.ad9e					_GXIClear:
.ad9e	9e 72 06	stz $0672,x			stz 	gxCurrentX,x
.ada1	ca		dex				dex
.ada2	10 fa		bpl $ad9e			bpl 	_GXIClear
.ada4	20 3f ae	jsr $ae3f			jsr 	GXClearSpriteStore
.ada7	60		rts				rts
.ada8					GXControlBitmap:
.ada8	64 01		stz $01				stz 	1
.adaa	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.adac	29 01		and #$01			and 	#1 							; set bitmap flag
.adae	8d 83 06	sta $0683			sta 	gxBitmapsOn
.adb1	4a		lsr a				lsr 	a 							; bit 0 into carry.
.adb2	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.adb5	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.adb7	29 f7		and #$f7			and 	#$F7 						; clear bitmap bit
.adb9	90 02		bcc $adbd			bcc 	_CBNotOn
.adbb	09 08		ora #$08			ora 	#$08 						; bitmap on if 1 on 0 off
.adbd					_CBNotOn:
.adbd	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.adc0	a5 36		lda $36				lda 	gxzTemp0 					; get control settings (bits 0-2)
.adc2	29 07		and #$07			and 	#7
.adc4	8d 00 d1	sta $d100			sta 	$D100 						; write in Vicky Bitmap Control Register #0
.adc7	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.adc9	d0 02		bne $adcd			bne 	_CBNotDefault
.adcb	a9 08		lda #$08			lda 	#8  						; if zero, use 8 e.g. bitmap at $10000
.adcd					_CBNotDefault:
.adcd	8d 84 06	sta $0684			sta 	gxBasePage
.add0	20 31 ae	jsr $ae31			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.add3	a5 37		lda $37				lda 	gxzTemp0+1 					; copy address into Bitmap address registers
.add5	8d 03 d1	sta $d103			sta 	$D103
.add8	a5 36		lda $36				lda 	gxzTemp0
.adda	8d 02 d1	sta $d102			sta 	$D102
.addd	9c 01 d1	stz $d101			stz 	$D101
.ade0	a2 f0		ldx #$f0			ldx 	#240 						; height is 240
.ade2	ad 01 d0	lda $d001			lda 	$D001 						; read MCR bit 0
.ade5	29 01		and #$01			and 	#1
.ade7	f0 02		beq $adeb			beq 	_CBHaveHeight
.ade9	a2 c8		ldx #$c8			ldx 	#200 						; if bit 0 set 320x200
.adeb					_CBHaveHeight
.adeb	8e 86 06	stx $0686			stx 	gxHeight
.adee	18		clc				clc
.adef	60		rts				rts
.adf0					GXControlSprite:
.adf0	64 01		stz $01				stz 	1
.adf2	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.adf4	29 01		and #$01			and 	#1 							; set sprites flag
.adf6	8d 82 06	sta $0682			sta 	gxSpritesOn
.adf9	4a		lsr a				lsr 	a 							; bit 0 into carry.
.adfa	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.adfd	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.adff	29 df		and #$df			and 	#$DF 						; clear sprite bit
.ae01	90 02		bcc $ae05			bcc 	_CSNotOn
.ae03	09 20		ora #$20			ora 	#$20 						; sprite on if 1 on 0 off
.ae05					_CSNotOn:
.ae05	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.ae08	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.ae0a	d0 02		bne $ae0e			bne 	_CSNotDefault
.ae0c	a9 18		lda #$18			lda 	#24  						; if zero, use 24 e.g. sprites at $30000
.ae0e					_CSNotDefault:
.ae0e	8d 85 06	sta $0685			sta 	gxSpritePage
.ae11	20 31 ae	jsr $ae31			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.ae14	a5 36		lda $36				lda 	zTemp0
.ae16	8d 90 06	sta $0690			sta 	GXSpriteOffsetBase
.ae19	a5 37		lda $37				lda 	zTemp0+1
.ae1b	8d 91 06	sta $0691			sta 	GXSpriteOffsetBase+1
.ae1e	a2 00		ldx #$00			ldx 	#0 							; disable all sprites, clears all sprite memory.
.ae20					_CSClear:
.ae20	9e 00 d9	stz $d900,x			stz 	$D900,x
.ae23	9e 00 da	stz $da00,x			stz 	$DA00,x
.ae26	ca		dex				dex
.ae27	d0 f7		bne $ae20			bne 	_CSClear
.ae29	9c 8f 06	stz $068f			stz 	GSCurrentSpriteAddr+1 		; no sprite selected.
.ae2c	20 3f ae	jsr $ae3f			jsr 	GXClearSpriteStore
.ae2f	18		clc				clc
.ae30	60		rts				rts
.ae31					GXCalculateBaseAddress:
.ae31	85 36		sta $36				sta 	gxzTemp0
.ae33	64 37		stz $37				stz 	gxzTemp0+1
.ae35	a9 05		lda #$05			lda 	#5
.ae37					_GXShift:
.ae37	06 36		asl $36				asl 	gxzTemp0
.ae39	26 37		rol $37				rol 	gxzTemp0+1
.ae3b	3a		dec a				dec		a
.ae3c	d0 f9		bne $ae37			bne 	_GXShift
.ae3e	60		rts				rts
.ae3f					GXClearSpriteStore:
.ae3f	a2 3f		ldx #$3f			ldx 	#63 						; erase 64 sprite store elements
.ae41					_GXCSSLoop:
.ae41	9e d2 06	stz $06d2,x			stz 	GXSpriteHigh,x
.ae44	a9 80		lda #$80			lda 	#$80 						; set the 'hidden' bit.
.ae46	9d 92 06	sta $0692,x			sta 	GXSpriteLow,x
.ae49	ca		dex				dex
.ae4a	10 f5		bpl $ae41			bpl 	_GXCSSLoop
.ae4c	60		rts				rts
.ae4d					GXLine:
.ae4d	ad 83 06	lda $0683			lda 	GXBitmapsOn
.ae50	f0 28		beq $ae7a			beq 	_GXLFail
.ae52	20 2f b3	jsr $b32f			jsr 	GXOpenBitmap
.ae55	20 75 b4	jsr $b475			jsr 	GXSortY						; sort pairs so Y1 >= Y0 e.g. top to bottom.
.ae58	20 20 af	jsr $af20			jsr 	GXLineSetup 				; the calculations in the linescanner constructor
.ae5b	20 3f b3	jsr $b33f			jsr 	GXPositionCalc 				; calculate position/offset.
.ae5e					_GXDrawLoop:
.ae5e	ac 8c 06	ldy $068c			ldy 	gsOffset 					; draw the pixel
.ae61	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.ae63	2d 8a 06	and $068a			and 	gxANDValue
.ae66	4d 89 06	eor $0689			eor 	gxEORValue
.ae69	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.ae6b	20 7c ae	jsr $ae7c			jsr 	GXLineIsComplete 			; is the line complete ?
.ae6e	f0 05		beq $ae75			beq 	_GXLExit
.ae70	20 97 ae	jsr $ae97			jsr 	GXLineAdvance 				; code as per advance method
.ae73	80 e9		bra $ae5e			bra 	_GXDrawLoop
.ae75					_GXLExit:
.ae75	20 37 b3	jsr $b337			jsr 	GXCloseBitmap
.ae78	18		clc				clc
.ae79	60		rts				rts
.ae7a					_GXLFail:
.ae7a	38		sec				sec
.ae7b	60		rts				rts
.ae7c					GXLineIsComplete:
.ae7c	ad 19 07	lda $0719			lda 	GXIsDiffYLarger 			; is dy larger
.ae7f	d0 0f		bne $ae90			bne 	_GXLICCompareY 				; if so compare Y1/Y0
.ae81	ad 7a 06	lda $067a			lda 	GXX0 						; compare X, LSB and MSB
.ae84	4d 7e 06	eor $067e			eor 	GXX1
.ae87	d0 06		bne $ae8f			bne 	_GXLICExit
.ae89	ad 7b 06	lda $067b			lda 	GXX0+1
.ae8c	4d 7f 06	eor $067f			eor 	GXX1+1
.ae8f					_GXLICExit:
.ae8f	60		rts				rts
.ae90					_GXLICCompareY:
.ae90	ad 80 06	lda $0680			lda 	GXY1
.ae93	4d 7c 06	eor $067c			eor 	GXY0
.ae96	60		rts				rts
.ae97					GXLineAdvance:
.ae97	18		clc				clc 								; add adjust to position
.ae98	ad 1b 07	lda $071b			lda 	GXPosition
.ae9b	6d 1c 07	adc $071c			adc 	GXAdjust
.ae9e	8d 1b 07	sta $071b			sta 	GXPosition
.aea1	9c 1e 07	stz $071e			stz 	GXAddSelect 				; clear add select flag
.aea4	b0 05		bcs $aeab			bcs 	_GXLAOverflow 				; if carry out, overflowed.
.aea6	cd 1d 07	cmp $071d			cmp 	GXTotal 					; if exceeded total
.aea9	90 0a		bcc $aeb5			bcc 	_GXLANoExtra
.aeab					_GXLAOverflow:
.aeab	ce 1e 07	dec $071e			dec 	GXAddSelect 				; set addselect to $FF
.aeae	38		sec				sec 								; subtract total and write back
.aeaf	ed 1d 07	sbc $071d			sbc 	GXTotal
.aeb2	8d 1b 07	sta $071b			sta 	GXPosition
.aeb5					_GXLANoExtra:
.aeb5	ad 19 07	lda $0719			lda 	GXIsDiffYLarger
.aeb8	f0 0d		beq $aec7			beq 	_GXDXLarger
.aeba	20 19 af	jsr $af19			jsr 	GXIncrementY
.aebd	ad 1e 07	lda $071e			lda 	GXAddSelect
.aec0	f0 10		beq $aed2			beq 	_GXLAExit
.aec2	20 d3 ae	jsr $aed3			jsr 	GXAdjustX
.aec5	80 0b		bra $aed2			bra 	_GXLAExit
.aec7					_GXDXLarger:
.aec7	20 d3 ae	jsr $aed3			jsr 	GXAdjustX
.aeca	ad 1e 07	lda $071e			lda 	GXAddSelect
.aecd	f0 03		beq $aed2			beq 	_GXLAExit
.aecf	20 19 af	jsr $af19			jsr 	GXIncrementY
.aed2					_GXLAExit:
.aed2	60		rts				rts
.aed3					GXAdjustX:
.aed3	ad 1a 07	lda $071a			lda 	GXDXNegative
.aed6	10 25		bpl $aefd			bpl 	_GXAXRight
.aed8	ad 7a 06	lda $067a			lda 	GXX0
.aedb	d0 03		bne $aee0			bne 	_GXAXNoBorrow
.aedd	ce 7b 06	dec $067b			dec 	GXX0+1
.aee0					_GXAXNoBorrow:
.aee0	ce 7a 06	dec $067a			dec 	GXX0
.aee3	ce 8c 06	dec $068c			dec 	gsOffset 					; pixel left
.aee6	ad 8c 06	lda $068c			lda 	gsOffset
.aee9	c9 ff		cmp #$ff			cmp 	#$FF
.aeeb	d0 0f		bne $aefc			bne 	_GXAYExit 					; underflow
.aeed	c6 3d		dec $3d				dec 	gxzScreen+1 					; borrow
.aeef	a5 3d		lda $3d				lda 	gxzScreen+1 					; gone off page
.aef1	c9 60		cmp #$60			cmp 	#GXMappingAddress >> 8
.aef3	b0 07		bcs $aefc			bcs 	_GXAYExit
.aef5	18		clc				clc
.aef6	69 20		adc #$20			adc 	#$20 						; fix up
.aef8	85 3d		sta $3d				sta 	gxzScreen+1
.aefa	c6 0b		dec $0b				dec 	GXEditSlot 				; back one page
.aefc					_GXAYExit:
.aefc	60		rts				rts
.aefd					_GXAXRight:
.aefd	ee 7a 06	inc $067a			inc 	GXX0
.af00	d0 03		bne $af05			bne 	_GXAXNoCarry
.af02	ee 7b 06	inc $067b			inc 	GXX0+1
.af05					_GXAXNoCarry:
.af05	ee 8c 06	inc $068c			inc 	gsOffset 					; pixel right
.af08	d0 0e		bne $af18			bne 	_GXAXExit 					; if not overflowed, exit.
.af0a	e6 3d		inc $3d				inc 	gxzScreen+1 					; next line
.af0c	a5 3d		lda $3d				lda 	gxzScreen+1
.af0e	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.af10	90 06		bcc $af18			bcc 	_GXAXExit
.af12	e9 20		sbc #$20			sbc 	#$20 						; fix up
.af14	85 3d		sta $3d				sta 	gxzScreen+1
.af16	e6 0b		inc $0b				inc 	GXEditSlot 				; next page
.af18					_GXAXExit:
.af18	60		rts				rts
.af19					GXIncrementY:
.af19	ee 7c 06	inc $067c			inc 	GXY0
.af1c	20 95 b3	jsr $b395			jsr 	GXMovePositionDown
.af1f	60		rts				rts
.af20					GXLineSetup:
.af20	ad 80 06	lda $0680			lda 	GXY1
.af23	38		sec				sec
.af24	ed 7c 06	sbc $067c			sbc 	GXY0
.af27	4a		lsr a				lsr 	a
.af28	8d 18 07	sta $0718			sta 	GXDiffY
.af2b	9c 1a 07	stz $071a			stz 	GXDXNegative 				; clear -ve flag
.af2e	38		sec				sec
.af2f	ad 7e 06	lda $067e			lda 	GXX1
.af32	ed 7a 06	sbc $067a			sbc 	GXX0
.af35	8d 17 07	sta $0717			sta 	GXDiffX
.af38	ad 7f 06	lda $067f			lda 	GXX1+1 						; calculate MSB
.af3b	ed 7b 06	sbc $067b			sbc 	GXX0+1
.af3e	6a		ror a				ror 	a 							; rotate bit into DiffX halving it
.af3f	6e 17 07	ror $0717			ror 	GXDiffX
.af42	0a		asl a				asl 	a
.af43	10 0c		bpl $af51			bpl 	_GDXNotNegative
.af45	a9 00		lda #$00			lda 	#0 							; make absolute value of |dx|
.af47	38		sec				sec
.af48	ed 17 07	sbc $0717			sbc 	GXDiffX
.af4b	8d 17 07	sta $0717			sta 	GXDiffX
.af4e	ce 1a 07	dec $071a			dec 	GXDXNegative 				; -ve flag = $FF.
.af51					_GDXNotNegative:
.af51	9c 19 07	stz $0719			stz 	GXIsDiffYLarger 			; clear larger flag
.af54	ad 18 07	lda $0718			lda 	GXDiffY 					; set adjust and total.
.af57	8d 1c 07	sta $071c			sta 	GXAdjust
.af5a	ad 17 07	lda $0717			lda 	GXDiffX
.af5d	8d 1d 07	sta $071d			sta 	GXTotal
.af60	ad 18 07	lda $0718			lda 	GXDiffY 					; if dy > dx
.af63	cd 17 07	cmp $0717			cmp 	GXDiffX
.af66	90 0f		bcc $af77			bcc 	_GDXNotLarger
.af68	ce 19 07	dec $0719			dec 	GXIsDiffYLarger 			; set the dy larger flag
.af6b	ad 17 07	lda $0717			lda 	GXDiffX 					; set adjust and total other way round
.af6e	8d 1c 07	sta $071c			sta 	GXAdjust
.af71	ad 18 07	lda $0718			lda 	GXDiffY
.af74	8d 1d 07	sta $071d			sta 	GXTotal
.af77					_GDXNotLarger:
.af77	ad 1d 07	lda $071d			lda 	GXTotal
.af7a	4a		lsr a				lsr 	a
.af7b	8d 1b 07	sta $071b			sta 	GXPosition
.af7e	60		rts				rts
.0717					GXDiffX:
>0717							.fill 	1
.0718					GXDiffY:
>0718							.fill 	1
.0719					GXIsDiffYLarger:
>0719							.fill 	1
.071a					GXDXNegative:
>071a							.fill 	1
.071b					GXPosition:
>071b							.fill 	1
.071c					GXAdjust:
>071c							.fill 	1
.071d					GXTotal:
>071d							.fill 	1
.071e					GXAddSelect:
>071e							.fill 	1
.af7f					GXSetColourMode:
.af7f	a6 36		ldx $36				ldx 	gxzTemp0
.af81	8e 88 06	stx $0688			stx 	gxColour 								; set colour
.af84	a5 37		lda $37				lda 	gxzTemp0+1 								;
.af86	8d 87 06	sta $0687			sta 	gxMode 									; set mode
.af89	29 03		and #$03			and 	#3 										; only interested in bits 0-3
.af8b	9c 8a 06	stz $068a			stz 	gxANDValue 								; initially AND with 0, and EOR with Colour
.af8e	ae 88 06	ldx $0688			ldx 	gxColour
.af91	8e 89 06	stx $0689			stx 	gxEORValue
.af94	c9 02		cmp #$02			cmp 	#2 										; if mode 2/3 And with colour
.af96	90 03		bcc $af9b			bcc 	_GXSDCNotAndColour
.af98	8e 8a 06	stx $068a			stx 	gxANDValue
.af9b					_GXSDCNotAndColour:
.af9b	d0 03		bne $afa0			bne 	_GXSDCNotAnd 							; mode 2, Don't EOR with colour
.af9d	9c 89 06	stz $0689			stz 	gxEORValue
.afa0					_GXSDCNotAnd:
.afa0	4a		lsr a				lsr 	a 										; if bit 0 set, 1's complement AND value
.afa1	90 08		bcc $afab			bcc 	_GXSDCNoFlip
.afa3	ad 8a 06	lda $068a			lda	 	gxANDValue
.afa6	49 ff		eor #$ff			eor 	#$FF
.afa8	8d 8a 06	sta $068a			sta 	gxANDValue
.afab					_GXSDCNoFlip:
.afab	18		clc				clc
.afac	60		rts				rts
.afad					GXPlotPoint:
.afad	20 2f b3	jsr $b32f			jsr 	GXOpenBitmap 				; start drawing
.afb0	20 3f b3	jsr $b33f			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.afb3	ac 8c 06	ldy $068c			ldy 	gsOffset
.afb6	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.afb8	2d 8a 06	and $068a			and 	gxANDValue
.afbb	4d 89 06	eor $0689			eor 	gxEORValue
.afbe	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.afc0	20 37 b3	jsr $b337			jsr 	GXCloseBitmap 				; stop drawing and exit
.afc3	18		clc				clc
.afc4	60		rts				rts
.afc5					GXFillRectangle:
.afc5	38		sec				sec
.afc6	80 01		bra $afc9			bra 	GXRectangle
.afc8					GXFrameRectangle:
.afc8	18		clc				clc
.afc9					GXRectangle:
.afc9	ad 83 06	lda $0683			lda 	gxBitmapsOn
.afcc	f0 35		beq $b003			beq 	_GXRFail
.afce	08		php				php 								; save Fill flag (CS)
.afcf	20 2f b3	jsr $b32f			jsr 	GXOpenBitmap 				; start drawing
.afd2	20 57 b4	jsr $b457			jsr 	GXSortXY 					; sort both X and Y so top left/bottom right
.afd5	20 3f b3	jsr $b33f			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.afd8	38		sec				sec 								; sec = Draw line
.afd9	20 05 b0	jsr $b005			jsr 	GXDrawLineX1X0 				; draw a line length X1-X0
.afdc	ad 7c 06	lda $067c			lda 	gxY0 						; reached end of rectangle ?
.afdf	cd 80 06	cmp $0680			cmp 	gxY1
.afe2	f0 19		beq $affd			beq 	_GXRectangleExit
.afe4					_GXRectLoop:
.afe4	20 95 b3	jsr $b395			jsr 	GXMovePositionDown 			; down one.
.afe7	ee 7c 06	inc $067c			inc 	gxY0 						; change Y pos
.afea	ad 7c 06	lda $067c			lda 	gxY0 						; reached last line
.afed	cd 80 06	cmp $0680			cmp 	gXY1
.aff0	f0 07		beq $aff9			beq 	_GXLastLine
.aff2	28		plp				plp 								; get flag back
.aff3	08		php				php
.aff4	20 05 b0	jsr $b005			jsr 	GXDrawLineX1X0 				; draw horizontal line
.aff7	80 eb		bra $afe4			bra 	_GXRectLoop
.aff9					_GXLastLine:
.aff9	38		sec				sec
.affa	20 05 b0	jsr $b005			jsr 	GXDrawLineX1X0
.affd					_GXRectangleExit:
.affd	68		pla				pla 								; throw fill flag.
.affe	20 37 b3	jsr $b337			jsr 	GXCloseBitmap 				; stop drawing and exit
.b001	18		clc				clc
.b002	60		rts				rts
.b003					_GXRFail:
.b003	38		sec				sec
.b004	60		rts				rts
.b005					GXDrawLineX1X0:
.b005	08		php				php 								; save solid/either-end
.b006	38		sec				sec
.b007	ad 7e 06	lda $067e			lda		gXX1
.b00a	ed 7a 06	sbc $067a			sbc 	gXX0
.b00d	85 36		sta $36				sta 	gxzTemp0
.b00f	ad 7f 06	lda $067f			lda 	gXX1+1
.b012	ed 7b 06	sbc $067b			sbc 	gXX0+1
.b015	85 37		sta $37				sta 	gxzTemp0+1
.b017	28		plp				plp
.b018					GXDrawLineTemp0:
.b018	a5 3c		lda $3c				lda 	gxzScreen 						; push gxzScreen, gsOffset and GXEditSlot on stack
.b01a	48		pha				pha
.b01b	a5 3d		lda $3d				lda 	gxzScreen+1
.b01d	48		pha				pha
.b01e	ad 8c 06	lda $068c			lda 	gsOffset
.b021	48		pha				pha
.b022	a5 0b		lda $0b				lda 	GXEditSlot
.b024	48		pha				pha
.b025	ac 8c 06	ldy $068c			ldy 	gsOffset 					; Y offset
.b028	90 1e		bcc $b048			bcc 	_GXDLTEndPoints 			; if CC draw end points only.
.b02a					_GXDLTLine:
.b02a	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.b02c	2d 8a 06	and $068a			and 	gxANDValue
.b02f	4d 89 06	eor $0689			eor 	gxEORValue
.b032	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b034	a5 36		lda $36				lda 	gxzTemp0 					; decrement counter
.b036	d0 04		bne $b03c			bne 	_GXDLTNoBorrow
.b038	c6 37		dec $37				dec 	gxzTemp0+1 					; borrow, if goes -ve then exit
.b03a	30 2e		bmi $b06a			bmi 	_GXDLTExit
.b03c					_GXDLTNoBorrow:
.b03c	c6 36		dec $36				dec 	gxzTemp0
.b03e	c8		iny				iny 								; next slot.
.b03f	d0 e9		bne $b02a			bne 	_GXDLTLine
.b041	e6 3d		inc $3d				inc 	gxzScreen+1 					; carry to next
.b043	20 78 b0	jsr $b078			jsr 	GXDLTCheckWrap				; check for new page.
.b046	80 e2		bra $b02a			bra 	_GXDLTLine
.b048					_GXDLTEndPoints:
.b048	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.b04a	2d 8a 06	and $068a			and 	gxANDValue
.b04d	4d 89 06	eor $0689			eor 	gxEORValue
.b050	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b052	98		tya				tya 								; advance to right side
.b053	18		clc				clc
.b054	65 36		adc $36				adc 	gxzTemp0
.b056	a8		tay				tay
.b057	a5 3d		lda $3d				lda 	gxzScreen+1
.b059	65 37		adc $37				adc 	gxzTemp0+1
.b05b	85 3d		sta $3d				sta 	gxzScreen+1
.b05d	20 78 b0	jsr $b078			jsr 	GXDLTCheckWrap 			; fix up.
.b060	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.b062	2d 8a 06	and $068a			and 	gxANDValue
.b065	4d 89 06	eor $0689			eor 	gxEORValue
.b068	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b06a					_GXDLTExit:
.b06a	68		pla				pla
.b06b	85 0b		sta $0b				sta 	GXEditSlot
.b06d	68		pla				pla
.b06e	8d 8c 06	sta $068c			sta 	gsOffset
.b071	68		pla				pla
.b072	85 3d		sta $3d				sta 	gxzScreen+1
.b074	68		pla				pla
.b075	85 3c		sta $3c				sta 	gxzScreen
.b077	60		rts				rts
.b078					GXDLTCheckWrap:
.b078	a5 3d		lda $3d				lda 	gxzScreen+1 					; check end of page
.b07a	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8)
.b07c	90 06		bcc $b084			bcc 	_GXDLTCWExit
.b07e	e9 20		sbc #$20			sbc 	#$20 						; fix up
.b080	85 3d		sta $3d				sta 	gxzScreen+1
.b082	e6 0b		inc $0b				inc 	GXEditSlot
.b084					_GXDLTCWExit:
.b084	60		rts				rts
.b085					GXDrawGraphicElement:
.b085	8d 1f 07	sta $071f			sta 	gxSize 						; save size
.b088	3a		dec a				dec 	a
.b089	8d 20 07	sta $0720			sta 	gxMask 						; and mask
.b08c	ad 83 06	lda $0683			lda 	gxBitmapsOn 				; check BMP on
.b08f	f0 67		beq $b0f8			beq 	_GXSLFail
.b091	ad 7c 06	lda $067c			lda 	gxY0 						; push Y on stack
.b094	48		pha				pha
.b095	8c 22 07	sty $0722			sty 	gxAcquireVector+1 			; and acquisition vector
.b098	8e 21 07	stx $0721			stx 	gxAcquireVector
.b09b	20 2f b3	jsr $b32f			jsr 	gxOpenBitmap 				; open the bitmap.
.b09e	ad 24 07	lda $0724			lda 	gxUseMode 					; scale bits
.b0a1	4a		lsr a				lsr 	a
.b0a2	4a		lsr a				lsr 	a
.b0a3	4a		lsr a				lsr 	a
.b0a4	29 07		and #$07			and		#7
.b0a6	1a		inc a				inc 	a
.b0a7	8d 23 07	sta $0723			sta 	gxScale
.b0aa	64 38		stz $38				stz 	gxzTemp1					; start first line
.b0ac					_GXGELoop:
.b0ac	a5 38		lda $38				lda 	gxzTemp1 					; current line number to read.
.b0ae	2c 24 07	bit $0724			bit 	gxUseMode 					; check for flip.
.b0b1	10 06		bpl $b0b9			bpl		_GXNoVFlip
.b0b3	ad 20 07	lda $0720			lda 	gxMask
.b0b6	38		sec				sec
.b0b7	e5 38		sbc $38				sbc 	gxzTemp1
.b0b9					_GXNoVFlip:
.b0b9	aa		tax				tax 								; get the Xth line.
.b0ba	20 fa b0	jsr $b0fa			jsr 	_GXCallAcquire 				; get that data.
.b0bd	ad 23 07	lda $0723			lda 	gxScale 					; do scale identical copies of that line.
.b0c0	85 39		sta $39				sta 	gxzTemp1+1
.b0c2					_GXGELoop2:
.b0c2	ad 7c 06	lda $067c			lda 	gxY0 						; off screen
.b0c5	cd 86 06	cmp $0686			cmp 	gxHeight
.b0c8	b0 10		bcs $b0da			bcs 	_GXDGEExit
.b0ca	20 fd b0	jsr $b0fd			jsr 	GXRenderOneLine 			; render line
.b0cd	c6 39		dec $39				dec 	gxzTemp1+1 					; scale times.
.b0cf	d0 f1		bne $b0c2			bne 	_GXGELoop2
.b0d1	e6 38		inc $38				inc 	gxzTemp1 					; done all lines.
.b0d3	a5 38		lda $38				lda 	gxzTemp1
.b0d5	cd 1f 07	cmp $071f			cmp 	gxSize
.b0d8	d0 d2		bne $b0ac			bne 	_GXGELoop
.b0da					_GXDGEExit:
.b0da	68		pla				pla 								; restore Y for next time
.b0db	8d 7c 06	sta $067c			sta 	gxY0
.b0de	ae 23 07	ldx $0723			ldx 	gxScale 					; get scale (1-8)
.b0e1					_GXShiftLeft:
.b0e1	18		clc				clc
.b0e2	ad 1f 07	lda $071f			lda 	gxSize
.b0e5	6d 7a 06	adc $067a			adc 	gxX0
.b0e8	8d 7a 06	sta $067a			sta 	gxX0
.b0eb	90 03		bcc $b0f0			bcc 	_GXSLNoCarry
.b0ed	ee 7b 06	inc $067b			inc 	gxX0+1
.b0f0					_GXSLNoCarry:
.b0f0	ca		dex				dex
.b0f1	d0 ee		bne $b0e1			bne 	_GXShiftLeft
.b0f3	20 37 b3	jsr $b337			jsr 	GXCloseBitmap
.b0f6	18		clc				clc
.b0f7	60		rts				rts
.b0f8					_GXSLFail:
.b0f8	38		sec				sec
.b0f9	60		rts				rts
.b0fa					_GXCallAcquire:
.b0fa	6c 21 07	jmp ($0721)			jmp 	(gxAcquireVector)
.b0fd					GXRenderOneLine:
.b0fd	20 3f b3	jsr $b33f			jsr 	GXPositionCalc 				; calculate position/offset.
.b100	ac 8c 06	ldy $068c			ldy 	gsOffset 					; Y contains position.
.b103	64 3a		stz $3a				stz 	gxzTemp2 					; do size pixels
.b105					_GXROLLoop1:
.b105	ad 23 07	lda $0723			lda 	gxScale 					; set to do 'scale' times
.b108	85 3b		sta $3b				sta 	gxzTemp2+1
.b10a					_GXROLLoop2:
.b10a	a5 3a		lda $3a				lda 	gxzTemp2 					; get current pixel
.b10c	2c 87 06	bit $0687			bit 	gxMode 						; check H Flip
.b10f	50 06		bvc $b117			bvc 	_GXNoHFlip
.b111	ad 20 07	lda $0720			lda 	gxMask
.b114	38		sec				sec
.b115	e5 3a		sbc $3a				sbc 	gxzTemp2
.b117					_GXNoHFlip:
.b117	aa		tax				tax 								; read from the pixel buffer
.b118	bd 27 06	lda $0627,x			lda 	gxPixelBuffer,x
.b11b	d0 07		bne $b124			bne 	_GXDraw 					; draw if non zero
.b11d	ad 24 07	lda $0724			lda 	gxUseMode 					; check to see if solid background
.b120	29 04		and #$04			and 	#4
.b122	f0 0a		beq $b12e			beq 	_GXZeroPixel
.b124					_GXDraw:
.b124	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.b126	2d 8a 06	and $068a			and 	gxANDValue
.b129	5d 27 06	eor $0627,x			eor 	gxPixelBuffer,x
.b12c	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b12e					_GXZeroPixel:
.b12e	c8		iny				iny 								; advance pointer
.b12f	d0 05		bne $b136			bne 	_GXNoShift
.b131	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.b133	20 78 b0	jsr $b078			jsr 	GXDLTCheckWrap				; check for new page.
.b136					_GXNoShift:
.b136	c6 3b		dec $3b				dec 	gxzTemp2+1 					; do the inner loop gxScale times.
.b138	d0 d0		bne $b10a			bne 	_GXROLLoop2
.b13a	e6 3a		inc $3a				inc 	gxzTemp2 					; next pixel.
.b13c	a5 3a		lda $3a				lda 	gxzTemp2
.b13e	cd 1f 07	cmp $071f			cmp 	gxSize
.b141	d0 c2		bne $b105			bne 	_GXROLLoop1
.b143	ee 7c 06	inc $067c			inc 	gxY0
.b146	60		rts				rts
.071f					gxSize:
>071f							.fill 	1
.0720					gxMask:
>0720							.fill 	1
.0721					gxAcquireVector:
>0721							.fill 	2
.0723					gxScale:
>0723							.fill 	1
.0724					gxUseMode:
>0724							.fill 	1
.b147					GXFontHandler:
.b147	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b149	4d 87 06	eor $0687			eor 	gxMode
.b14c	8d 24 07	sta $0724			sta 	gxUseMode
.b14f	64 37		stz $37				stz 	gxzTemp0+1 					; gxzTemp0 is font #
.b151	06 36		asl $36				asl	 	gxzTemp0 					; x 2
.b153	26 37		rol $37				rol	 	gxzTemp0+1
.b155	06 36		asl $36				asl	 	gxzTemp0 					; x 4
.b157	26 37		rol $37				rol	 	gxzTemp0+1
.b159	06 36		asl $36				asl	 	gxzTemp0 					; x 8
.b15b	26 37		rol $37				rol	 	gxzTemp0+1
.b15d	a5 37		lda $37				lda 	gxzTemp0+1 					; put in page C0
.b15f	09 c0		ora #$c0			ora 	#$C0
.b161	85 37		sta $37				sta 	gxzTemp0+1
.b163	a9 08		lda #$08			lda 	#8 							; size 8x8
.b165	a2 6d		ldx #$6d			ldx 	#GXGetGraphicDataFont & $FF ; XY = Graphic Data retrieval routine
.b167	a0 b1		ldy #$b1			ldy 	#GXGetGraphicDataFont >> 8
.b169	20 85 b0	jsr $b085			jsr 	GXDrawGraphicElement
.b16c	60		rts				rts
.b16d					GXGetGraphicDataFont:
.b16d	8a		txa				txa 								; X->Y
.b16e	a8		tay				tay
.b16f	a6 01		ldx $01				ldx 	1 							; preserve old value
.b171	a9 01		lda #$01			lda 	#1 							; access page 1 (font memory)
.b173	85 01		sta $01				sta 	1
.b175	b1 36		lda ($36),y			lda 	(gxzTemp0),y 				; read the font element.
.b177	86 01		stx $01				stx 	1 							; put old value back.
.b179	a2 00		ldx #$00			ldx 	#0 							; do 8 times
.b17b					_GXExpand:
.b17b	9e 27 06	stz $0627,x			stz 	gxPixelBuffer,x 			; zero in pixel buffer
.b17e	0a		asl a				asl 	a 							; shift bit 7 into C
.b17f	90 08		bcc $b189			bcc 	_GXNoPixel
.b181	48		pha				pha 								; if set, set pixel buffer to current colour.
.b182	ad 88 06	lda $0688			lda 	gxColour
.b185	9d 27 06	sta $0627,x			sta 	gxPixelBuffer,x
.b188	68		pla				pla
.b189					_GXNoPixel:
.b189	e8		inx				inx 								; do the whole byte.
.b18a	e0 08		cpx #$08			cpx 	#8
.b18c	d0 ed		bne $b17b			bne 	_GXExpand
.b18e	60		rts				rts
.b18f					GXSpriteHandler:
.b18f	ad 82 06	lda $0682			lda 	gxSpritesOn 				; sprites on ?
.b192	f0 23		beq $b1b7			beq 	_GXSHExit
.b194	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b196	4d 87 06	eor $0687			eor 	gxMode
.b199	8d 24 07	sta $0724			sta 	gxUseMode
.b19c	a6 36		ldx $36				ldx 	gxzTemp0 					; sprite #
.b19e	da		phx				phx
.b19f	20 2f b3	jsr $b32f			jsr 	GXOpenBitmap 				; can access sprite information
.b1a2	68		pla				pla
.b1a3	20 10 b4	jsr $b410			jsr 	GXFindSprite 				; get the sprite address
.b1a6	08		php				php
.b1a7	20 37 b3	jsr $b337			jsr 	GXCloseBitmap
.b1aa	28		plp				plp
.b1ab	b0 0a		bcs $b1b7			bcs		_GXSHExit 					; exit if find failed.
.b1ad	ad 25 07	lda $0725			lda 	GXSizePixels 				; return size
.b1b0	a2 b8		ldx #$b8			ldx 	#GXSpriteAcquire & $FF
.b1b2	a0 b1		ldy #$b1			ldy 	#GXSpriteAcquire >> 8
.b1b4	20 85 b0	jsr $b085			jsr 	GXDrawGraphicElement
.b1b7					_GXSHExit:
.b1b7	60		rts				rts
.b1b8					GXSpriteAcquire:
.b1b8	ad 85 06	lda $0685			lda 	GXSpritePage				; point to base page
.b1bb	85 0b		sta $0b				sta 	GXEditSlot
.b1bd	86 36		stx $36				stx 	zTemp0 						; row number x 1,2,3,4
.b1bf	a9 00		lda #$00			lda 	#0
.b1c1	ae 26 07	ldx $0726			ldx 	GXSizeBits
.b1c4					_GXTimesRowNumber:
.b1c4	18		clc				clc
.b1c5	65 36		adc $36				adc 	zTemp0
.b1c7	ca		dex				dex
.b1c8	10 fa		bpl $b1c4			bpl 	_GXTimesRowNumber
.b1ca	64 37		stz $37				stz 	gxzTemp0+1
.b1cc	0a		asl a				asl 	a 							; row x 2,4,6,8
.b1cd	26 37		rol $37				rol 	gxzTemp0+1
.b1cf	0a		asl a				asl 	a 							; row x 4,8,12,16
.b1d0	26 37		rol $37				rol 	gxzTemp0+1
.b1d2	0a		asl a				asl 	a 							; row x 8,16,24,32
.b1d3	26 37		rol $37				rol 	gxzTemp0+1
.b1d5	85 36		sta $36				sta 	gxzTemp0
.b1d7	18		clc				clc 								; add base address.
.b1d8	a5 36		lda $36				lda 	gxzTemp0
.b1da	6d 28 07	adc $0728			adc 	GXSpriteOffset
.b1dd	85 36		sta $36				sta 	gxzTemp0
.b1df	a5 37		lda $37				lda 	gxzTemp0+1
.b1e1	6d 29 07	adc $0729			adc 	GXSpriteOffset+1
.b1e4					_GXSAFindPage:
.b1e4	c9 20		cmp #$20			cmp 	#$20 						; on this page
.b1e6	90 06		bcc $b1ee			bcc 	_GXSAFoundPage
.b1e8	e9 20		sbc #$20			sbc 	#$20 						; forward one page
.b1ea	e6 0b		inc $0b				inc 	GXEditSlot
.b1ec	80 f6		bra $b1e4			bra 	_GXSAFindPage
.b1ee					_GXSAFoundPage:
.b1ee	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; physical address of page.
.b1f0	85 37		sta $37				sta 	gxzTemp0+1 					; gxzTemp0 now points to the page
.b1f2	a0 00		ldy #$00			ldy 	#0
.b1f4					_GXSACopyLoop:
.b1f4	b1 36		lda ($36),y			lda 	(gxzTemp0),y
.b1f6	99 27 06	sta $0627,y			sta 	gxPixelBuffer,y
.b1f9	c8		iny				iny
.b1fa	cc 25 07	cpy $0725			cpy 	GXSizePixels
.b1fd	d0 f5		bne $b1f4			bne 	_GXSACopyLoop
.b1ff	60		rts				rts
.b200					GXSelect:
.b200	ad 82 06	lda $0682			lda 	gxSpritesOn
.b203	f0 22		beq $b227			beq 	_GXSFail
.b205	a5 36		lda $36				lda 	gxzTemp0 					; illegal sprite #
.b207	c9 40		cmp #$40			cmp 	#64
.b209	b0 1c		bcs $b227			bcs 	_GXSFail
.b20b	8d 8d 06	sta $068d			sta 	GSCurrentSpriteID
.b20e	a4 37		ldy $37				ldy 	gxzTemp0+1 					; control value.
.b210	a9 00		lda #$00			lda  	#0 							; multiply sprite # x 8 => A
.b212	06 36		asl $36				asl 	gxzTemp0
.b214	06 36		asl $36				asl 	gxzTemp0
.b216	06 36		asl $36				asl 	gxzTemp0
.b218	2a		rol a				rol 	a
.b219	69 d9		adc #$d9			adc 	#$D9 						; sprite area
.b21b	8d 8f 06	sta $068f			sta 	GSCurrentSpriteAddr+1 		; address to GSCurrentSprite and gxzTemp
.b21e	85 37		sta $37				sta 	gxzTemp0+1
.b220	a5 36		lda $36				lda 	gxzTemp0
.b222	8d 8e 06	sta $068e			sta 	GSCurrentSpriteAddr
.b225	18		clc				clc
.b226	60		rts				rts
.b227					_GXSFail:
.b227	38		sec				sec
.b228	60		rts				rts
.b229					GXSelectImage:
.b229	ad 82 06	lda $0682			lda 	gxSpritesOn
.b22c	f0 74		beq $b2a2			beq 	_GXSIFail
.b22e	ad 8f 06	lda $068f			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b231	f0 6f		beq $b2a2			beq 	_GXSIFail 					; (checking the MSB)
.b233	64 01		stz $01				stz 	1
.b235	a5 37		lda $37				lda 	gxzTemp0+1 					; push show/hide on the stack.
.b237	d0 6b		bne $b2a4			bne 	_GXSIHide
.b239	a5 36		lda $36				lda 	gxzTemp0 					; sprite image
.b23b	48		pha				pha
.b23c	20 2f b3	jsr $b32f			jsr 	GXOpenBitmap
.b23f	68		pla				pla
.b240	20 10 b4	jsr $b410			jsr 	GXFindSprite
.b243	b0 5a		bcs $b29f			bcs 	_GXSICloseFail 				; no image
.b245	a0 01		ldy #$01			ldy 	#1
.b247	ad 8e 06	lda $068e			lda 	GSCurrentSpriteAddr
.b24a	85 36		sta $36				sta 	gxzTemp0
.b24c	ad 8f 06	lda $068f			lda 	GSCurrentSpriteAddr+1
.b24f	85 37		sta $37				sta 	gxzTemp0+1
.b251	ad 28 07	lda $0728			lda 	GXSpriteOffset
.b254	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b256	18		clc				clc
.b257	ad 29 07	lda $0729			lda 	GXSpriteOffset+1
.b25a	6d 90 06	adc $0690			adc 	GXSpriteOffsetBase
.b25d	c8		iny				iny
.b25e	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b260	ad 91 06	lda $0691			lda 	GXSpriteOffsetBase+1
.b263	69 00		adc #$00			adc 	#0
.b265	c8		iny				iny
.b266	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b268	ad 26 07	lda $0726			lda 	GXSizeBits 					; get raw size
.b26b	49 03		eor #$03			eor 	#3 							; make it right (00=32 etc.)
.b26d	2a		rol a				rol 	a 							; x 2
.b26e	0a		asl a				asl 	a 							; x 4
.b26f	0a		asl a				asl 	a 							; x 8
.b270	0a		asl a				asl 	a 							; x 16
.b271	0d 27 07	ora $0727			ora 	GXSpriteLUT 				; Or with LUT
.b274	0a		asl a				asl 	a 							; 1 shift
.b275	09 01		ora #$01			ora 	#1 							; enable sprite.
.b277	92 36		sta ($36)			sta 	(gxzTemp0) 					; and write back
.b279	20 37 b3	jsr $b337			jsr 	GXCloseBitmap
.b27c	ae 8d 06	ldx $068d			ldx 	GSCurrentSpriteID 			; point to sprite entries.
.b27f	bd d2 06	lda $06d2,x			lda 	GXSpriteHigh,x 				; clear upper two bits of size
.b282	29 3f		and #$3f			and 	#$3F
.b284	9d d2 06	sta $06d2,x			sta 	GXSpriteHigh,x
.b287	ad 26 07	lda $0726			lda 	GXSizeBits 					; get bit size
.b28a	6a		ror a				ror 	a 							; shift into bits 6/7
.b28b	6a		ror a				ror 	a
.b28c	6a		ror a				ror 	a
.b28d	29 c0		and #$c0			and 	#$C0
.b28f	1d d2 06	ora $06d2,x			ora 	GXSpriteHigh,x 				; put in  upper 2 bits of sprite data
.b292	9d d2 06	sta $06d2,x			sta 	GXSpriteHigh,x
.b295	bd 92 06	lda $0692,x			lda 	GXSpriteLow,x 				; clear hidden flag.
.b298	29 7f		and #$7f			and 	#$7F
.b29a	9d 92 06	sta $0692,x			sta 	GXSpriteLow,x
.b29d	18		clc				clc
.b29e	60		rts				rts
.b29f					_GXSICloseFail:
.b29f	20 37 b3	jsr $b337			jsr 	GXCloseBitmap
.b2a2					_GXSIFail:
.b2a2	38		sec				sec
.b2a3	60		rts				rts
.b2a4					_GXSIHide:
.b2a4	ad 8e 06	lda $068e			lda 	GSCurrentSpriteAddr  		; get Sprite h/w address and write there
.b2a7	85 36		sta $36				sta 	gxzTemp0
.b2a9	ad 8f 06	lda $068f			lda 	GSCurrentSpriteAddr+1
.b2ac	85 37		sta $37				sta 	gxzTemp0+1
.b2ae	a9 00		lda #$00			lda 	#0
.b2b0	92 36		sta ($36)			sta 	(gxzTemp0)
.b2b2	ae 8d 06	ldx $068d			ldx 	GSCurrentSpriteID 			; get sprite ID
.b2b5	bd 92 06	lda $0692,x			lda 	GXSpriteLow,x 				; set the hidden bit.
.b2b8	09 80		ora #$80			ora 	#$80
.b2ba	9d 92 06	sta $0692,x			sta 	GXSpriteLow,x
.b2bd	18		clc				clc
.b2be	60		rts				rts
.b2bf					GXMoveSprite:
.b2bf	ad 82 06	lda $0682			lda 	gxSpritesOn
.b2c2	f0 65		beq $b329			beq 	_GXSIFail
.b2c4	ad 8f 06	lda $068f			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b2c7	f0 60		beq $b329			beq 	_GXSIFail
.b2c9	85 37		sta $37				sta 	gxzTemp0+1
.b2cb	a0 04		ldy #$04			ldy 	#4
.b2cd	ad 8e 06	lda $068e			lda 	GSCurrentSpriteAddr
.b2d0	85 36		sta $36				sta 	gxzTemp0
.b2d2	ae 8d 06	ldx $068d			ldx 	GSCurrentSpriteID 			; get the size from the upper two bits
.b2d5	bd d2 06	lda $06d2,x			lda 	GXSpriteHigh,x
.b2d8	2a		rol a				rol 	a	 						; into bits 0,1.
.b2d9	2a		rol a				rol 	a
.b2da	2a		rol a				rol 	a
.b2db	29 03		and #$03			and 	#3
.b2dd	aa		tax				tax
.b2de	bd 2b b3	lda $b32b,x			lda 	_GXMSOffset,x 				; get 32-SpriteSize/2
.b2e1	48		pha				pha
.b2e2	18		clc				clc
.b2e3	6d 7a 06	adc $067a			adc 	gxX0						; copy position.
.b2e6	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2e8	c8		iny				iny
.b2e9	ad 7b 06	lda $067b			lda 	gxX0+1
.b2ec	69 00		adc #$00			adc 	#0
.b2ee	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2f0	c8		iny				iny
.b2f1	68		pla				pla
.b2f2	18		clc				clc
.b2f3	6d 7c 06	adc $067c			adc 	gxY0
.b2f6	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2f8	a9 00		lda #$00			lda 	#0
.b2fa	69 00		adc #$00			adc 	#0
.b2fc	c8		iny				iny
.b2fd	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2ff	4e 7b 06	lsr $067b			lsr 	gxX0+1 						; divide X by 4
.b302	6e 7a 06	ror $067a			ror 	gxX0
.b305	4e 7a 06	lsr $067a			lsr 	gxX0
.b308	4e 7c 06	lsr $067c			lsr 	gxY0 						; divide Y by 4
.b30b	4e 7c 06	lsr $067c			lsr 	gxY0
.b30e	ae 8d 06	ldx $068d			ldx 	GSCurrentSpriteID 			; copy X/4 and Y/4 into the status bytes
.b311	bd 92 06	lda $0692,x			lda 	GXSpriteLow,x
.b314	29 80		and #$80			and 	#$80
.b316	0d 7a 06	ora $067a			ora 	gxX0
.b319	9d 92 06	sta $0692,x			sta 	GXSpriteLow,x
.b31c	bd d2 06	lda $06d2,x			lda 	GXSpriteHigh,x
.b31f	29 c0		and #$c0			and 	#$C0
.b321	0d 7c 06	ora $067c			ora 	gxY0
.b324	9d d2 06	sta $06d2,x			sta 	GXSpriteHigh,x
.b327	18		clc				clc
.b328	60		rts				rts
.b329					_GXSIFail:
.b329	38		sec				sec
.b32a	60		rts				rts
.b32b					_GXMSOffset:
>b32b	1c						.byte 	32-8/2
>b32c	18						.byte 	32-16/2
>b32d	14						.byte 	32-24/2
>b32e	10						.byte 	32-32/2
.b32f					GXOpenBitmap:
.b32f	78		sei				sei 								; no interrupts here
.b330	a5 0b		lda $0b				lda 	GXEditSlot 					; Save the original LUT slot value
.b332	8d 8b 06	sta $068b			sta 	gxOriginalLUTValue
.b335	58		cli				cli
.b336	60		rts				rts
.b337					GXCloseBitmap:
.b337	78		sei				sei
.b338	ad 8b 06	lda $068b			lda 	gxOriginalLUTValue 			; restore LUT slot value
.b33b	85 0b		sta $0b				sta 	GXEditSlot
.b33d	58		cli				cli
.b33e	60		rts				rts
.b33f					GXPositionCalc:
.b33f	a5 36		lda $36				lda 	gxzTemp0 					; save temp memory slot
.b341	48		pha				pha
.b342	ad 7c 06	lda $067c			lda 	GXY0 						; gxzScreen = Y0
.b345	85 3c		sta $3c				sta 	gxzScreen
.b347	64 3d		stz $3d				stz 	gxzScreen+1
.b349	06 3c		asl $3c				asl 	gxzScreen 						; gxzScreen = Y0 * 4
.b34b	26 3d		rol $3d				rol 	gxzScreen+1
.b34d	06 3c		asl $3c				asl 	gxzScreen
.b34f	26 3d		rol $3d				rol 	gxzScreen+1
.b351	18		clc				clc 								; gxzScreen = Y0 * 5, as it's still in A
.b352	65 3c		adc $3c				adc 	gxzScreen
.b354	85 3c		sta $3c				sta 	gxzScreen
.b356	90 02		bcc $b35a			bcc 	_GXPCNoCarry
.b358	e6 3d		inc $3d				inc 	gxzScreen+1
.b35a					_GXPCNoCarry:
.b35a	06 3c		asl $3c				asl 	gxzScreen 						; now Y0 * 10. Needs to be multiplied by another
.b35c	26 3d		rol $3d				rol 	gxzScreen+1 					; 32. At this point the MSB contains the offset
.b35e	a5 3d		lda $3d				lda	 	gxzScreen+1 					; so save this in zTemp0 and zero it.
.b360	85 36		sta $36				sta 	gxzTemp0
.b362	64 3d		stz $3d				stz 	gxzScreen+1
.b364	a9 05		lda #$05			lda 	#5 							; now multiply by 32, this puts this in the range 0..8191
.b366					_GXPCMultiply32:
.b366	06 3c		asl $3c				asl 	gxzScreen
.b368	26 3d		rol $3d				rol 	gxzScreen+1
.b36a	3a		dec a				dec 	a
.b36b	d0 f9		bne $b366			bne 	_GXPCMultiply32
.b36d	18		clc				clc
.b36e	ad 7a 06	lda $067a			lda 	GXX0 						; add X to this value, put the result in gsOffset, gxzScreen has to be on a page boundary
.b371	65 3c		adc $3c				adc 	gxzScreen
.b373	8d 8c 06	sta $068c			sta 	gsOffset
.b376	ad 7b 06	lda $067b			lda 	GXX0+1
.b379	65 3d		adc $3d				adc 	gxzScreen+1
.b37b	c9 20		cmp #$20			cmp 	#$20 						; has it overflowed into the next one ?
.b37d	90 04		bcc $b383			bcc 	_GXPCNoOverflow
.b37f	29 1f		and #$1f			and 	#$1F 						; fix it up
.b381	e6 36		inc $36				inc 	gxzTemp0 					; add 1 to the page number
.b383					_GXPCNoOverflow:
.b383	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; make it the address mapped in.
.b385	85 3d		sta $3d				sta 	gxzScreen+1
.b387	64 3c		stz $3c				stz 	gxzScreen
.b389	18		clc				clc
.b38a	a5 36		lda $36				lda 	gxzTemp0 					; get the page number
.b38c	6d 84 06	adc $0684			adc 	gxBasePage 					; by adding the base page
.b38f	85 0b		sta $0b				sta 	GXEditSlot 				; and map it into memory.
.b391	68		pla				pla
.b392	85 36		sta $36				sta 	gxzTemp0
.b394	60		rts				rts
.b395					GXMovePositionDown:
.b395	18		clc				clc 								; add 320 to offset/temp+1
.b396	ad 8c 06	lda $068c			lda 	gsOffset
.b399	69 40		adc #$40			adc 	#64
.b39b	8d 8c 06	sta $068c			sta 	gsOffset
.b39e	a5 3d		lda $3d				lda 	gxzScreen+1
.b3a0	69 01		adc #$01			adc 	#1
.b3a2	85 3d		sta $3d				sta 	gxzScreen+1
.b3a4	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page
.b3a6	90 07		bcc $b3af			bcc 	_GXMPDExit
.b3a8	38		sec				sec  								; next page
.b3a9	e9 20		sbc #$20			sbc 	#$20
.b3ab	85 3d		sta $3d				sta 	gxzScreen+1
.b3ad	e6 0b		inc $0b				inc 	GXEditSlot
.b3af					_GXMPDExit:
.b3af	60		rts				rts
.b3b0					GXCollide:
.b3b0	a5 36		lda $36				lda 	gxzTemp0 					; check if sprite numbers are legal.
.b3b2	aa		tax				tax
.b3b3	05 37		ora $37				ora 	gxzTemp0+1
.b3b5	29 c0		and #$c0			and 	#$C0
.b3b7	38		sec				sec
.b3b8	d0 53		bne $b40d			bne 	_GXCollideFail 				; if either >= 64, fail.
.b3ba	a4 37		ldy $37				ldy 	gxzTemp0+1 					; at this point X is 1st sprite and Y is 2nd sprite.
.b3bc	b9 92 06	lda $0692,y			lda 	GXSpriteLow,y 				; check if either hidden bit is set
.b3bf	1d 92 06	ora $0692,x			ora 	GXSpriteLow,x
.b3c2	30 48		bmi $b40c			bmi 	_GXOkayFail 				; if either hidden, then they cannot collide.
.b3c4	18		clc				clc 								; need to calculate sum of sizes.
.b3c5	b9 d2 06	lda $06d2,y			lda 	GXSpriteHigh,y
.b3c8	7d d2 06	adc $06d2,x			adc 	GXSpriteHigh,x 				; at this point, CS, Bit 6 and 7 contain that sum.
.b3cb	29 c0		and #$c0			and 	#$C0 					 	; mask off
.b3cd	6a		ror a				ror 	a 							; 5/6/7
.b3ce	4a		lsr a				lsr 	a 							; 4/5/6
.b3cf	4a		lsr a				lsr 	a 							; 3/4/5
.b3d0	4a		lsr a				lsr 	a 							; 2/3/4
.b3d1	18		clc				clc
.b3d2	69 08		adc #$08			adc 	#$08
.b3d4	4a		lsr a				lsr 	a 							; adjust because all coordinates are divided by 4 to store.
.b3d5	4a		lsr a				lsr 	a
.b3d6	85 38		sta $38				sta 	gxzTemp1 					; so the difference between the centres has to be less than this.
.b3d8	b9 d2 06	lda $06d2,y			lda 	GXSpriteHigh,y 				; calculate y1-y0
.b3db	29 3f		and #$3f			and 	#$3F
.b3dd	85 39		sta $39				sta 	gxzTemp1+1
.b3df	38		sec				sec
.b3e0	bd d2 06	lda $06d2,x			lda 	GXSpriteHigh,x
.b3e3	29 3f		and #$3f			and 	#$3F
.b3e5	e5 39		sbc $39				sbc 	gxzTemp1+1
.b3e7	b0 03		bcs $b3ec			bcs 	_GXCAbs1 					; calculate |y1-y0|
.b3e9	49 ff		eor #$ff			eor 	#$FF
.b3eb	1a		inc a				inc 	a
.b3ec					_GXCAbs1:
.b3ec	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b3ee	b0 1c		bcs $b40c			bcs 	_GXOkayFail
.b3f0	85 39		sta $39				sta 	gxzTemp1+1 					; save |y1-y0|
.b3f2	38		sec				sec 								; calculate |x1-x0|
.b3f3	b9 92 06	lda $0692,y			lda 	GXSpriteLow,y
.b3f6	fd 92 06	sbc $0692,x			sbc 	GXSpriteLow,x
.b3f9	b0 03		bcs $b3fe			bcs 	_GXCAbs2
.b3fb	49 ff		eor #$ff			eor 	#$FF
.b3fd	1a		inc a				inc 	a
.b3fe					_GXCAbs2:
.b3fe	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b400	b0 0a		bcs $b40c			bcs 	_GXOkayFail
.b402	c5 39		cmp $39				cmp 	gxzTemp1+1 					; is it less than the previous one.
.b404	90 02		bcc $b408			bcc 	_GXCHaveLowest
.b406	a5 39		lda $39				lda 	gxzTemp1+1 					; if not, that's the smallest difference.
.b408					_GXCHaveLowest:
.b408	0a		asl a				asl 	a 							; scale to allow for >> 2
.b409	0a		asl a				asl 	a
.b40a	18		clc				clc
.b40b	60		rts				rts
.b40c					_GXOkayFail:
.b40c	18		clc				clc
.b40d					_GXCollideFail:
.b40d	a9 ff		lda #$ff			lda 	#$FF
.b40f	60		rts				rts
.b410					GXFindSprite:
.b410	aa		tax				tax
.b411	ad 85 06	lda $0685			lda 	GXSpritePage 				; access the base page of the sprite
.b414	85 0b		sta $0b				sta 	GXEditSlot
.b416	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; check a valid sprite
.b419	1d 00 60	ora $6000,x			ora 	GXMappingAddress,x
.b41c	f0 33		beq $b451			beq 	_GXFSFail
.b41e	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; MSB
.b421	8d 29 07	sta $0729			sta 	GXSpriteOffset+1
.b424	bd 00 60	lda $6000,x			lda 	GXMappingAddress,x 			; LSB
.b427	48		pha				pha 								; save twice
.b428	48		pha				pha
.b429	29 03		and #$03			and 	#3 							; get sprite size
.b42b	8d 26 07	sta $0726			sta 	GXSizeBits 					; save raw (0-3)
.b42e	aa		tax				tax
.b42f	bd 53 b4	lda $b453,x			lda 	_GXFXSSTTable,x 			; read sprite size
.b432	8d 25 07	sta $0725			sta 	GXSizePixels 					; save (8/16/24/32)
.b435	68		pla				pla 								; get LUT
.b436	4a		lsr a				lsr		a
.b437	4a		lsr a				lsr		a
.b438	29 03		and #$03			and 	#3
.b43a	8d 27 07	sta $0727			sta 	GXSpriteLUT
.b43d	68		pla				pla 								; address, neeeds to be x 4
.b43e	29 f0		and #$f0			and 	#$F0
.b440	8d 28 07	sta $0728			sta 	GXSpriteOffset
.b443	0e 28 07	asl $0728			asl 	GXSpriteOffset
.b446	2e 29 07	rol $0729			rol 	GXSpriteOffset+1
.b449	0e 28 07	asl $0728			asl 	GXSpriteOffset
.b44c	2e 29 07	rol $0729			rol 	GXSpriteOffset+1
.b44f	18		clc				clc
.b450	60		rts				rts
.b451					_GXFSFail:
.b451	38		sec				sec
.b452	60		rts				rts
.b453					_GXFXSSTTable:
>b453	08 10 18 20					.byte 	8,16,24,32
.0725					GXSizePixels:
>0725							.fill 	1
.0726					GXSizeBits:
>0726							.fill 	1
.0727					GXSpriteLUT:
>0727							.fill 	1
.0728					GXSpriteOffset:
>0728							.fill 	2
.b457					GXSortXY:
.b457	20 75 b4	jsr $b475			jsr 	GXSortY 					; will be sorted on Y now
.b45a	ad 7a 06	lda $067a			lda 	gxX0 						; compare X0 v X1
.b45d	cd 7e 06	cmp $067e			cmp 	gxX1
.b460	ad 7b 06	lda $067b			lda 	gXX0+1
.b463	ed 7f 06	sbc $067f			sbc 	gXX1+1
.b466	90 0c		bcc $b474			bcc 	_GXSXYExit 					; X0 < X1 exit
.b468	a2 00		ldx #$00			ldx 	#0 							; swap them over
.b46a	a0 04		ldy #$04			ldy 	#4
.b46c	20 89 b4	jsr $b489			jsr 	GXSwapXY
.b46f	e8		inx				inx
.b470	c8		iny				iny
.b471	20 89 b4	jsr $b489			jsr 	GXSwapXY
.b474					_GXSXYExit:
.b474	60		rts				rts
.b475					GXSortY:
.b475	ad 7c 06	lda $067c			lda 	gxY0 						; if Y0 >= Y1
.b478	cd 80 06	cmp $0680			cmp 	gxY1
.b47b	90 0b		bcc $b488			bcc 	_GXSYSorted
.b47d	a2 03		ldx #$03			ldx 	#3 							; swap 3-0
.b47f	a0 07		ldy #$07			ldy 	#7 							; with 4-7
.b481					_GXSwap1:
.b481	20 89 b4	jsr $b489			jsr 	GXSwapXY
.b484	88		dey				dey
.b485	ca		dex				dex
.b486	10 f9		bpl $b481			bpl 	_GXSwap1
.b488					_GXSYSorted:
.b488	60		rts				rts
.b489					GXSwapXY:
.b489	bd 7a 06	lda $067a,x			lda 	gxX0,x
.b48c	48		pha				pha
.b48d	b9 7a 06	lda $067a,y			lda 	gxX0,y
.b490	9d 7a 06	sta $067a,x			sta 	gxX0,x
.b493	68		pla				pla
.b494	99 7a 06	sta $067a,y			sta 	gxX0,y
.b497	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_tokeniser.module

=1					tokeniserIntegrated=1
.b498					KeywordSet0:
>b498	00 65					.text	0,$65,""               ; $80 !0:EOF
>b49a	00 58					.text	0,$58,""               ; $81 !1:SH1
>b49c	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b49e	04 fe 41 42 53 28			.text	4,$fe,"ABS("           ; $83 ABS(
>b4a4	06 93 41 4c 4c 4f 43 28			.text	6,$93,"ALLOC("         ; $84 ALLOC(
>b4ac	04 ff 41 53 43 28			.text	4,$ff,"ASC("           ; $85 ASC(
>b4b2	05 29 43 48 52 24 28			.text	5,$29,"CHR$("          ; $86 CHR$(
>b4b9	05 41 44 45 45 4b 28			.text	5,$41,"DEEK("          ; $87 DEEK(
>b4c0	06 aa 45 56 45 4e 54 28			.text	6,$aa,"EVENT("         ; $88 EVENT(
>b4c8	05 6b 46 41 4c 53 45			.text	5,$6b,"FALSE"          ; $89 FALSE
>b4cf	05 44 46 52 41 43 28			.text	5,$44,"FRAC("          ; $8a FRAC(
>b4d6	04 0d 48 49 54 28			.text	4,$0d,"HIT("           ; $8b HIT(
>b4dc	04 13 49 4e 54 28			.text	4,$13,"INT("           ; $8c INT(
>b4e2	06 a7 49 53 56 41 4c 28			.text	6,$a7,"ISVAL("         ; $8d ISVAL(
>b4ea	05 5c 4a 4f 59 42 28			.text	5,$5c,"JOYB("          ; $8e JOYB(
>b4f1	05 72 4a 4f 59 58 28			.text	5,$72,"JOYX("          ; $8f JOYX(
>b4f8	05 73 4a 4f 59 59 28			.text	5,$73,"JOYY("          ; $90 JOYY(
>b4ff	06 77 4c 45 46 54 24 28			.text	6,$77,"LEFT$("         ; $91 LEFT$(
>b507	04 07 4c 45 4e 28			.text	4,$07,"LEN("           ; $92 LEN(
>b50d	04 0e 4d 41 58 28			.text	4,$0e,"MAX("           ; $93 MAX(
>b513	05 26 4d 49 44 24 28			.text	5,$26,"MID$("          ; $94 MID$(
>b51a	04 0c 4d 49 4e 28			.text	4,$0c,"MIN("           ; $95 MIN(
>b520	04 19 4e 4f 54 28			.text	4,$19,"NOT("           ; $96 NOT(
>b526	05 4d 50 45 45 4b 28			.text	5,$4d,"PEEK("          ; $97 PEEK(
>b52d	08 3c 50 4c 41 59 49 4e			.text	8,$3c,"PLAYING("       ; $98 PLAYING(
>b535	47 28
>b537	07 e9 52 41 4e 44 4f 4d			.text	7,$e9,"RANDOM("        ; $99 RANDOM(
>b53f	28
>b540	07 ca 52 49 47 48 54 24			.text	7,$ca,"RIGHT$("        ; $9a RIGHT$(
>b548	28
>b549	04 0c 52 4e 44 28			.text	4,$0c,"RND("           ; $9b RND(
>b54f	04 10 53 47 4e 28			.text	4,$10,"SGN("           ; $9c SGN(
>b555	04 0e 53 50 43 28			.text	4,$0e,"SPC("           ; $9d SPC(
>b55b	05 45 53 54 52 24 28			.text	5,$45,"STR$("          ; $9e STR$(
>b562	06 a9 54 49 4d 45 52 28			.text	6,$a9,"TIMER("         ; $9f TIMER(
>b56a	04 40 54 52 55 45			.text	4,$40,"TRUE"           ; $a0 TRUE
>b570	04 0b 56 41 4c 28			.text	4,$0b,"VAL("           ; $a1 VAL(
>b576	03 e7 46 4f 52				.text	3,$e7,"FOR"            ; $a2 FOR
>b57b	02 8f 49 46				.text	2,$8f,"IF"             ; $a3 IF
>b57f	04 34 50 52 4f 43			.text	4,$34,"PROC"           ; $a4 PROC
>b585	06 c1 52 45 50 45 41 54			.text	6,$c1,"REPEAT"         ; $a5 REPEAT
>b58d	05 79 57 48 49 4c 45			.text	5,$79,"WHILE"          ; $a6 WHILE
>b594	05 66 45 4e 44 49 46			.text	5,$66,"ENDIF"          ; $a7 ENDIF
>b59b	07 0b 45 4e 44 50 52 4f			.text	7,$0b,"ENDPROC"        ; $a8 ENDPROC
>b5a3	43
>b5a4	04 3f 4e 45 58 54			.text	4,$3f,"NEXT"           ; $a9 NEXT
>b5aa	04 2f 54 48 45 4e			.text	4,$2f,"THEN"           ; $aa THEN
>b5b0	05 8c 55 4e 54 49 4c			.text	5,$8c,"UNTIL"          ; $ab UNTIL
>b5b7	04 2e 57 45 4e 44			.text	4,$2e,"WEND"           ; $ac WEND
>b5bd	02 9b 42 59				.text	2,$9b,"BY"             ; $ad BY
>b5c1	04 1c 43 41 4c 4c			.text	4,$1c,"CALL"           ; $ae CALL
>b5c7	06 b2 43 49 52 43 4c 45			.text	6,$b2,"CIRCLE"         ; $af CIRCLE
>b5cf	05 67 43 4c 45 41 52			.text	5,$67,"CLEAR"          ; $b0 CLEAR
>b5d6	03 e2 43 4c 53				.text	3,$e2,"CLS"            ; $b1 CLS
>b5db	05 7f 43 4f 4c 4f 52			.text	5,$7f,"COLOR"          ; $b2 COLOR
>b5e2	06 d4 43 4f 4c 4f 55 52			.text	6,$d4,"COLOUR"         ; $b3 COLOUR
>b5ea	04 1a 44 41 54 41			.text	4,$1a,"DATA"           ; $b4 DATA
>b5f0	03 da 44 49 4d				.text	3,$da,"DIM"            ; $b5 DIM
>b5f5	04 23 44 4f 4b 45			.text	4,$23,"DOKE"           ; $b6 DOKE
>b5fb	06 db 44 4f 57 4e 54 4f			.text	6,$db,"DOWNTO"         ; $b7 DOWNTO
>b603	04 29 45 4c 53 45			.text	4,$29,"ELSE"           ; $b8 ELSE
>b609	04 34 46 52 4f 4d			.text	4,$34,"FROM"           ; $b9 FROM
>b60f	03 e5 47 46 58				.text	3,$e5,"GFX"            ; $ba GFX
>b614	05 80 47 4f 53 55 42			.text	5,$80,"GOSUB"          ; $bb GOSUB
>b61b	04 39 47 4f 54 4f			.text	4,$39,"GOTO"           ; $bc GOTO
>b621	04 24 48 45 52 45			.text	4,$24,"HERE"           ; $bd HERE
>b627	05 63 49 4d 41 47 45			.text	5,$63,"IMAGE"          ; $be IMAGE
>b62e	05 90 49 4e 50 55 54			.text	5,$90,"INPUT"          ; $bf INPUT
>b635	03 e5 4c 45 54				.text	3,$e5,"LET"            ; $c0 LET
>b63a	04 28 4c 49 4e 45			.text	4,$28,"LINE"           ; $c1 LINE
>b640	05 6b 4c 4f 43 41 4c			.text	5,$6b,"LOCAL"          ; $c2 LOCAL
>b647	03 db 4f 46 46				.text	3,$db,"OFF"            ; $c3 OFF
>b64c	02 9d 4f 4e				.text	2,$9d,"ON"             ; $c4 ON
>b650	07 20 4f 55 54 4c 49 4e			.text	7,$20,"OUTLINE"        ; $c5 OUTLINE
>b658	45
>b659	07 0f 50 41 4c 45 54 54			.text	7,$0f,"PALETTE"        ; $c6 PALETTE
>b661	45
>b662	04 3f 50 4c 4f 54			.text	4,$3f,"PLOT"           ; $c7 PLOT
>b668	04 2f 50 4f 4b 45			.text	4,$2f,"POKE"           ; $c8 POKE
>b66e	05 8d 50 52 49 4e 54			.text	5,$8d,"PRINT"          ; $c9 PRINT
>b675	04 1c 52 45 41 44			.text	4,$1c,"READ"           ; $ca READ
>b67b	04 2e 52 45 43 54			.text	4,$2e,"RECT"           ; $cb RECT
>b681	03 e4 52 45 4d				.text	3,$e4,"REM"            ; $cc REM
>b686	06 e0 52 45 54 55 52 4e			.text	6,$e0,"RETURN"         ; $cd RETURN
>b68e	05 7b 53 4f 4c 49 44			.text	5,$7b,"SOLID"          ; $ce SOLID
>b695	05 89 53 4f 55 4e 44			.text	5,$89,"SOUND"          ; $cf SOUND
>b69c	06 d7 53 50 52 49 54 45			.text	6,$d7,"SPRITE"         ; $d0 SPRITE
>b6a4	04 45 54 45 58 54			.text	4,$45,"TEXT"           ; $d1 TEXT
>b6aa	02 a3 54 4f				.text	2,$a3,"TO"             ; $d2 TO
>b6ae	ff					.text	$FF
.b6af					KeywordSet1:
>b6af	00 65					.text	0,$65,""               ; $80 !0:EOF
>b6b1	00 58					.text	0,$58,""               ; $81 !1:SH1
>b6b3	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b6b5	08 4c 41 53 53 45 4d 42			.text	8,$4c,"ASSEMBLE"       ; $83 ASSEMBLE
>b6bd	4c 45
>b6bf	06 d2 41 53 53 45 52 54			.text	6,$d2,"ASSERT"         ; $84 ASSERT
>b6c7	06 bd 42 49 54 4d 41 50			.text	6,$bd,"BITMAP"         ; $85 BITMAP
>b6cf	03 d7 45 4e 44				.text	3,$d7,"END"            ; $86 END
>b6d4	07 11 45 58 50 4c 4f 44			.text	7,$11,"EXPLODE"        ; $87 EXPLODE
>b6dc	45
>b6dd	02 96 47 4f				.text	2,$96,"GO"             ; $88 GO
>b6e1	04 3c 4c 49 53 54			.text	4,$3c,"LIST"           ; $89 LIST
>b6e7	04 20 4c 4f 41 44			.text	4,$20,"LOAD"           ; $8a LOAD
>b6ed	03 ea 4e 45 57				.text	3,$ea,"NEW"            ; $8b NEW
>b6f2	04 2e 50 49 4e 47			.text	4,$2e,"PING"           ; $8c PING
>b6f8	07 24 52 45 53 54 4f 52			.text	7,$24,"RESTORE"        ; $8d RESTORE
>b700	45
>b701	03 f5 52 55 4e				.text	3,$f5,"RUN"            ; $8e RUN
>b706	05 8d 53 48 4f 4f 54			.text	5,$8d,"SHOOT"          ; $8f SHOOT
>b70d	07 2a 53 50 52 49 54 45			.text	7,$2a,"SPRITES"        ; $90 SPRITES
>b715	53
>b716	04 46 53 54 4f 50			.text	4,$46,"STOP"           ; $91 STOP
>b71c	03 eb 5a 41 50				.text	3,$eb,"ZAP"            ; $92 ZAP
>b721	ff					.text	$FF
.b722					KeywordSet2:
>b722	00 65					.text	0,$65,""               ; $80 !0:EOF
>b724	00 58					.text	0,$58,""               ; $81 !1:SH1
>b726	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b728	03 c8 41 44 43				.text	3,$c8,"ADC"            ; $83 ADC
>b72d	03 d3 41 4e 44				.text	3,$d3,"AND"            ; $84 AND
>b732	03 e0 41 53 4c				.text	3,$e0,"ASL"            ; $85 ASL
>b737	03 c8 42 43 43				.text	3,$c8,"BCC"            ; $86 BCC
>b73c	03 d8 42 43 53				.text	3,$d8,"BCS"            ; $87 BCS
>b741	03 d8 42 45 51				.text	3,$d8,"BEQ"            ; $88 BEQ
>b746	03 df 42 49 54				.text	3,$df,"BIT"            ; $89 BIT
>b74b	03 d8 42 4d 49				.text	3,$d8,"BMI"            ; $8a BMI
>b750	03 d5 42 4e 45				.text	3,$d5,"BNE"            ; $8b BNE
>b755	03 de 42 50 4c				.text	3,$de,"BPL"            ; $8c BPL
>b75a	03 d5 42 52 41				.text	3,$d5,"BRA"            ; $8d BRA
>b75f	03 df 42 52 4b				.text	3,$df,"BRK"            ; $8e BRK
>b764	03 db 42 56 43				.text	3,$db,"BVC"            ; $8f BVC
>b769	03 eb 42 56 53				.text	3,$eb,"BVS"            ; $90 BVS
>b76e	03 d2 43 4c 43				.text	3,$d2,"CLC"            ; $91 CLC
>b773	03 d3 43 4c 44				.text	3,$d3,"CLD"            ; $92 CLD
>b778	03 d8 43 4c 49				.text	3,$d8,"CLI"            ; $93 CLI
>b77d	03 e5 43 4c 56				.text	3,$e5,"CLV"            ; $94 CLV
>b782	03 e0 43 4d 50				.text	3,$e0,"CMP"            ; $95 CMP
>b787	03 eb 43 50 58				.text	3,$eb,"CPX"            ; $96 CPX
>b78c	03 ec 43 50 59				.text	3,$ec,"CPY"            ; $97 CPY
>b791	03 cc 44 45 43				.text	3,$cc,"DEC"            ; $98 DEC
>b796	03 e1 44 45 58				.text	3,$e1,"DEX"            ; $99 DEX
>b79b	03 e2 44 45 59				.text	3,$e2,"DEY"            ; $9a DEY
>b7a0	03 e6 45 4f 52				.text	3,$e6,"EOR"            ; $9b EOR
>b7a5	03 da 49 4e 43				.text	3,$da,"INC"            ; $9c INC
>b7aa	03 ef 49 4e 58				.text	3,$ef,"INX"            ; $9d INX
>b7af	03 f0 49 4e 59				.text	3,$f0,"INY"            ; $9e INY
>b7b4	03 e7 4a 4d 50				.text	3,$e7,"JMP"            ; $9f JMP
>b7b9	03 ef 4a 53 52				.text	3,$ef,"JSR"            ; $a0 JSR
>b7be	03 d1 4c 44 41				.text	3,$d1,"LDA"            ; $a1 LDA
>b7c3	03 e8 4c 44 58				.text	3,$e8,"LDX"            ; $a2 LDX
>b7c8	03 e9 4c 44 59				.text	3,$e9,"LDY"            ; $a3 LDY
>b7cd	03 f1 4c 53 52				.text	3,$f1,"LSR"            ; $a4 LSR
>b7d2	03 ed 4e 4f 50				.text	3,$ed,"NOP"            ; $a5 NOP
>b7d7	03 e2 4f 52 41				.text	3,$e2,"ORA"            ; $a6 ORA
>b7dc	03 d9 50 48 41				.text	3,$d9,"PHA"            ; $a7 PHA
>b7e1	03 e8 50 48 50				.text	3,$e8,"PHP"            ; $a8 PHP
>b7e6	03 f0 50 48 58				.text	3,$f0,"PHX"            ; $a9 PHX
>b7eb	03 f1 50 48 59				.text	3,$f1,"PHY"            ; $aa PHY
>b7f0	03 dd 50 4c 41				.text	3,$dd,"PLA"            ; $ab PLA
>b7f5	03 ec 50 4c 50				.text	3,$ec,"PLP"            ; $ac PLP
>b7fa	03 f4 50 4c 58				.text	3,$f4,"PLX"            ; $ad PLX
>b7ff	03 f5 50 4c 59				.text	3,$f5,"PLY"            ; $ae PLY
>b804	03 ed 52 4f 4c				.text	3,$ed,"ROL"            ; $af ROL
>b809	03 f3 52 4f 52				.text	3,$f3,"ROR"            ; $b0 ROR
>b80e	03 ef 52 54 49				.text	3,$ef,"RTI"            ; $b1 RTI
>b813	03 f9 52 54 53				.text	3,$f9,"RTS"            ; $b2 RTS
>b818	03 d8 53 42 43				.text	3,$d8,"SBC"            ; $b3 SBC
>b81d	03 db 53 45 43				.text	3,$db,"SEC"            ; $b4 SEC
>b822	03 dc 53 45 44				.text	3,$dc,"SED"            ; $b5 SED
>b827	03 e1 53 45 49				.text	3,$e1,"SEI"            ; $b6 SEI
>b82c	03 e8 53 54 41				.text	3,$e8,"STA"            ; $b7 STA
>b831	03 f7 53 54 50				.text	3,$f7,"STP"            ; $b8 STP
>b836	03 ff 53 54 58				.text	3,$ff,"STX"            ; $b9 STX
>b83b	03 00 53 54 59				.text	3,$00,"STY"            ; $ba STY
>b840	03 01 53 54 5a				.text	3,$01,"STZ"            ; $bb STZ
>b845	03 ed 54 41 58				.text	3,$ed,"TAX"            ; $bc TAX
>b84a	03 ee 54 41 59				.text	3,$ee,"TAY"            ; $bd TAY
>b84f	03 e8 54 52 42				.text	3,$e8,"TRB"            ; $be TRB
>b854	03 e9 54 53 42				.text	3,$e9,"TSB"            ; $bf TSB
>b859	03 ff 54 53 58				.text	3,$ff,"TSX"            ; $c0 TSX
>b85e	03 ed 54 58 41				.text	3,$ed,"TXA"            ; $c1 TXA
>b863	03 ff 54 58 53				.text	3,$ff,"TXS"            ; $c2 TXS
>b868	03 ee 54 59 41				.text	3,$ee,"TYA"            ; $c3 TYA
>b86d	ff					.text	$FF
.b86e					Export_TKListConvertLine:
.b86e	48		pha				pha 								; save indent on the stack
.b86f	9c 1d 04	stz $041d			stz 	tbOffset
.b872	9c 2d 04	stz $042d			stz 	tokenBuffer
.b875	9c 29 04	stz $0429			stz 	currentListColour
.b878	a9 89		lda #$89			lda 	#CLILineNumber+$80
.b87a	20 f7 b9	jsr $b9f7			jsr 	LCLWriteColour
.b87d	a0 02		ldy #$02			ldy 	#2 							; convert line number to string
.b87f	b1 30		lda ($30),y			lda 	(codePtr),y
.b881	aa		tax				tax
.b882	88		dey				dey
.b883	b1 30		lda ($30),y			lda 	(codePtr),y
.b885	20 68 ba	jsr $ba68			jsr 	LCLWriteNumberXA
.b888	68		pla				pla 								; adjustment to indent
.b889	48		pha				pha 								; save on stack
.b88a	10 0c		bpl $b898			bpl 	_LCNoAdjust 				; don't adjust indent if +ve, do after.
.b88c	18		clc				clc 								; add to list indent and make 0 if goes -ve.
.b88d	6d 26 04	adc $0426			adc 	listIndent
.b890	8d 26 04	sta $0426			sta 	listIndent
.b893	10 03		bpl $b898			bpl 	_LCNoAdjust
.b895	9c 26 04	stz $0426			stz 	listIndent
.b898					_LCNoAdjust:
.b898	18		clc				clc		 							; work out actual indent.
.b899	ad 26 04	lda $0426			lda 	listIndent
.b89c	0a		asl a				asl 	a
.b89d	69 07		adc #$07			adc 	#7
.b89f	85 36		sta $36				sta 	zTemp0
.b8a1					_LCPadOut:
.b8a1	a9 20		lda #$20			lda 	#' '						; pad out to 6+indent characters
.b8a3	20 00 ba	jsr $ba00			jsr 	LCLWrite
.b8a6	ad 1d 04	lda $041d			lda 	tbOffset
.b8a9	c5 36		cmp $36				cmp 	zTemp0
.b8ab	d0 f4		bne $b8a1			bne 	_LCPadOut
.b8ad	a0 03		ldy #$03			ldy 	#3 							; start position.
.b8af					_LCMainLoop:
.b8af	a9 8a		lda #$8a			lda 	#CLIPunctuation+$80
.b8b1	20 f7 b9	jsr $b9f7			jsr 	LCLWriteColour
.b8b4	b1 30		lda ($30),y			lda 	(codePtr),y
.b8b6	c9 80		cmp #$80			cmp 	#KWC_EOL 					; end of line ?
.b8b8	f0 17		beq $b8d1			beq 	_LCExit
.b8ba	c9 10		cmp #$10			cmp 	#16 						; 0-5 are the double punctuations
.b8bc	90 1e		bcc $b8dc			bcc 	_LCDoubles
.b8be	c9 20		cmp #$20			cmp 	#32 						; 16-31 are shifted punctuation from 64-91
.b8c0	90 2a		bcc $b8ec			bcc 	_LCShiftPunc
.b8c2	c9 40		cmp #$40			cmp 	#64 						; 32-64 are as stored, punc and digits
.b8c4	90 35		bcc $b8fb			bcc 	_LCPunctuation
.b8c6	c9 80		cmp #$80			cmp 	#128 						; 64-127 are variable identifiers.
.b8c8	90 51		bcc $b91b			bcc 	_LCIdentifiers
.b8ca	c9 fe		cmp #$fe			cmp 	#254 						; 128-253 are tokenised words
.b8cc	90 73		bcc $b941			bcc 	_LCTokens
.b8ce	4c a1 b9	jmp $b9a1			jmp 	_LCData 					; 254-5 are data objects
.b8d1					_LCExit:
.b8d1	68		pla				pla 								; get old indent adjust
.b8d2	30 07		bmi $b8db			bmi 	_LCExit2
.b8d4	18		clc				clc 								; add to indent if +ve
.b8d5	6d 26 04	adc $0426			adc 	listIndent
.b8d8	8d 26 04	sta $0426			sta 	listIndent
.b8db					_LCExit2:
.b8db	60		rts				rts
.b8dc					_LCDoubles:
.b8dc	48		pha				pha
.b8dd	4a		lsr a				lsr 	a 							; put bit 2 into bit 1
.b8de	29 02		and #$02			and 	#2
.b8e0	09 3c		ora #$3c			ora 	#60 						; make < >
.b8e2	20 00 ba	jsr $ba00			jsr 	LCLWrite
.b8e5	68		pla				pla 								; restore, do lower bit
.b8e6	29 03		and #$03			and 	#3
.b8e8	09 3c		ora #$3c			ora 	#60
.b8ea	80 0f		bra $b8fb			bra		_LCPunctuation 				; print, increment, loop
.b8ec					_LCShiftPunc:
.b8ec	aa		tax				tax 								; save in X
.b8ed	29 07		and #$07			and 	#7 							; lower 3 bits
.b8ef	f0 02		beq $b8f3			beq 	_LCNoAdd
.b8f1	09 18		ora #$18			ora 	#24 						; adds $18 to it.
.b8f3					_LCNoAdd:
.b8f3	e0 18		cpx #$18			cpx 	#24 						; if >= 24 add $20
.b8f5	90 02		bcc $b8f9			bcc 	_LCNoAdd2
.b8f7	09 20		ora #$20			ora 	#32 						; adds $20
.b8f9					_LCNoAdd2:
.b8f9	09 40		ora #$40			ora 	#$40 						; shift into 64-127 range and fall through.
.b8fb					_LCPunctuation:
.b8fb	c9 3a		cmp #$3a			cmp 	#':' 						; check if :
.b8fd	d0 03		bne $b902			bne 	_LCPContinue
.b8ff	20 16 ba	jsr $ba16			jsr 	LCLDeleteLastSpace 			; if so delete any preceding spaces
.b902					_LCPContinue:
.b902	c9 2e		cmp #$2e			cmp 	#'.'
.b904	f0 08		beq $b90e			beq 	_LCPIsConstant
.b906	c9 30		cmp #$30			cmp 	#'0'
.b908	90 0b		bcc $b915			bcc 	_LCPNotConstant
.b90a	c9 3a		cmp #$3a			cmp 	#'9'+1
.b90c	b0 07		bcs $b915			bcs 	_LCPNotConstant
.b90e					_LCPIsConstant:
.b90e	48		pha				pha
.b90f	a9 8d		lda #$8d			lda 	#CLIConstant+$80
.b911	20 f7 b9	jsr $b9f7			jsr 	LCLWriteColour
.b914	68		pla				pla
.b915					_LCPNotConstant:
.b915	c8		iny				iny 								; consume character
.b916	20 00 ba	jsr $ba00			jsr 	LCLWrite 					; write it out.
.b919	80 94		bra $b8af			bra 	_LCMainLoop 				; go round again.
.b91b					_LCIdentifiers:
.b91b	18		clc				clc 								; convert to physical address
.b91c	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.b91e	85 37		sta $37				sta 	zTemp0+1
.b920	c8		iny				iny
.b921	b1 30		lda ($30),y			lda 	(codePtr),y
.b923	85 36		sta $36				sta 	zTemp0
.b925	c8		iny				iny
.b926	5a		phy				phy 								; save position
.b927	a9 87		lda #$87			lda 	#CLIIdentifier+$80
.b929	20 f7 b9	jsr $b9f7			jsr 	LCLWriteColour
.b92c	a0 07		ldy #$07			ldy 	#7 							; output the identifier at +8
.b92e					_LCOutIdentifier:
.b92e	c8		iny				iny
.b92f	b1 36		lda ($36),y			lda 	(zTemp0),y					; bit 7 set = end.
.b931	29 7f		and #$7f			and 	#$7F
.b933	20 52 ba	jsr $ba52			jsr 	LCLLowerCase
.b936	20 00 ba	jsr $ba00			jsr 	LCLWrite
.b939	b1 36		lda ($36),y			lda 	(zTemp0),y				 	; ends when bit 7 set.
.b93b	10 f1		bpl $b92e			bpl 	_LCOutIdentifier
.b93d	7a		ply				ply 								; restore position
.b93e	4c af b8	jmp $b8af			jmp 	_LCMainLoop
.b941					_LCTokens:
.b941	aa		tax				tax 								; token in X
.b942	a9 22		lda #$22			lda 	#((KeywordSet2) & $FF)
.b944	85 36		sta $36				sta 	0+zTemp0
.b946	a9 b7		lda #$b7			lda 	#((KeywordSet2) >> 8)
.b948	85 37		sta $37				sta 	1+zTemp0
.b94a	e0 82		cpx #$82			cpx 	#$82
.b94c	f0 16		beq $b964			beq 	_LCUseShift
.b94e	a9 af		lda #$af			lda 	#((KeywordSet1) & $FF)
.b950	85 36		sta $36				sta 	0+zTemp0
.b952	a9 b6		lda #$b6			lda 	#((KeywordSet1) >> 8)
.b954	85 37		sta $37				sta 	1+zTemp0
.b956	e0 81		cpx #$81			cpx 	#$81
.b958	f0 0a		beq $b964			beq 	_LCUseShift
.b95a	a9 98		lda #$98			lda 	#((KeywordSet0) & $FF)
.b95c	85 36		sta $36				sta 	0+zTemp0
.b95e	a9 b4		lda #$b4			lda 	#((KeywordSet0) >> 8)
.b960	85 37		sta $37				sta 	1+zTemp0
.b962	80 01		bra $b965			bra 	_LCNoShift
.b964					_LCUseShift:
.b964	c8		iny				iny
.b965					_LCNoShift:
.b965	20 2a ba	jsr $ba2a			jsr 	LCLCheckSpaceRequired 		; do we need a space ?
.b968	b1 30		lda ($30),y			lda 	(codePtr),y
.b96a	aa		tax				tax 								; into X
.b96b					_LCFindText:
.b96b	ca		dex				dex
.b96c	10 0e		bpl $b97c			bpl 	_LCFoundText 				; found text.
.b96e	b2 36		lda ($36)			lda 	(zTemp0) 					; length of text
.b970	1a		inc a				inc 	a 							; one extra for size
.b971	38		sec				sec 								; one extra for checksum
.b972	65 36		adc $36				adc 	zTemp0 						; go to next token
.b974	85 36		sta $36				sta 	zTemp0
.b976	90 f3		bcc $b96b			bcc 	_LCFindText
.b978	e6 37		inc $37				inc 	zTemp0+1
.b97a	80 ef		bra $b96b			bra 	_LCFindText
.b97c					_LCFoundText:
.b97c	5a		phy				phy 								; save List position
.b97d	b2 36		lda ($36)			lda 	(zTemp0)					; count to print
.b97f	aa		tax				tax
.b980	a9 83		lda #$83			lda 	#CLIToken+$80
.b982	20 f7 b9	jsr $b9f7			jsr 	LCLWriteColour
.b985	a0 02		ldy #$02			ldy 	#2
.b987					_LCCopyToken:
.b987	b1 36		lda ($36),y			lda 	(zTemp0),y
.b989	20 52 ba	jsr $ba52			jsr 	LCLLowerCase
.b98c	20 00 ba	jsr $ba00			jsr 	LCLWrite
.b98f	c8		iny				iny
.b990	ca		dex				dex
.b991	d0 f4		bne $b987			bne 	_LCCopyToken
.b993	c9 28		cmp #$28			cmp 	#"(" 						; if last char not ( print a space
.b995	f0 05		beq $b99c			beq 	_LCNoSpace
.b997	a9 20		lda #$20			lda 	#' '
.b999	20 00 ba	jsr $ba00			jsr 	LCLWrite
.b99c					_LCNoSpace:
.b99c	7a		ply				ply 								; restore position.
.b99d	c8		iny				iny 								; consume token
.b99e	4c af b8	jmp $b8af			jmp 	_LCMainLoop 				; and go around again.
.b9a1					_LCData:
.b9a1	48		pha				pha 								; save type $FE/$FF
.b9a2	a2 24		ldx #$24			ldx 	#'$' 						; figure out $ or "
.b9a4	c9 fe		cmp #$fe			cmp 	#$FE
.b9a6	f0 22		beq $b9ca			beq 	_LCHaveOpener
.b9a8	a2 22		ldx #$22			ldx 	#'"'
.b9aa	a9 81		lda #$81			lda 	#CLIData+$80
.b9ac	20 f7 b9	jsr $b9f7			jsr 	LCLWriteColour
.b9af	c0 04		cpy #$04			cpy 	#4 							; must be 2nd thing on line
.b9b1	d0 17		bne $b9ca			bne 	_LCHaveOpener
.b9b3	88		dey				dey 								; what precedes it ?
.b9b4	b1 30		lda ($30),y			lda 	(codePtr),y
.b9b6	c8		iny				iny
.b9b7	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; if quote
.b9b9	d0 0f		bne $b9ca			bne 	_LCHaveOpener
.b9bb	a9 09		lda #$09			lda 	#9 							; tab
.b9bd	20 00 ba	jsr $ba00			jsr 	LCLWrite
.b9c0	a9 97		lda #$97			lda 	#$90+CLIBComment
.b9c2	20 00 ba	jsr $ba00			jsr 	LCLWrite
.b9c5	a9 80		lda #$80			lda 	#CLIFComment+$80
.b9c7	20 f7 b9	jsr $b9f7			jsr 	LCLWriteColour
.b9ca					_LCHaveOpener:
.b9ca	8a		txa				txa 								; output prefix (# or ")
.b9cb	20 00 ba	jsr $ba00			jsr 	LCLWrite
.b9ce	c8		iny				iny 								; get count
.b9cf	b1 30		lda ($30),y			lda 	(codePtr),y
.b9d1	aa		tax				tax
.b9d2	c8		iny				iny 								; point at first character
.b9d3					_LCOutData:
.b9d3	b1 30		lda ($30),y			lda 	(codePtr),y
.b9d5	c9 00		cmp #$00			cmp 	#0
.b9d7	f0 03		beq $b9dc			beq 	_LCNoPrint
.b9d9	20 00 ba	jsr $ba00			jsr 	LCLWrite
.b9dc					_LCNoPrint:
.b9dc	c8		iny				iny
.b9dd	ca		dex				dex
.b9de	d0 f3		bne $b9d3			bne 	_LCOutData
.b9e0	68		pla				pla 								; closing " required ?
.b9e1	c9 ff		cmp #$ff			cmp 	#$FF 						; not required for hex constant.
.b9e3	d0 0f		bne $b9f4			bne 	_LCNoQuote
.b9e5	a9 22		lda #$22			lda 	#'"'
.b9e7	20 00 ba	jsr $ba00			jsr 	LCLWrite
.b9ea	ad 6f 06	lda $066f			lda 	EXTTextColour
.b9ed	29 0f		and #$0f			and 	#$0F
.b9ef	09 90		ora #$90			ora 	#$90
.b9f1	20 00 ba	jsr $ba00			jsr 	LCLWrite
.b9f4					_LCNoQuote:
.b9f4	4c af b8	jmp $b8af			jmp 	_LCMainLoop
.b9f7					LCLWriteColour:
.b9f7	cd 29 04	cmp $0429			cmp 	currentListColour 			; has the colour changed
.b9fa	8d 29 04	sta $0429			sta 	currentListColour 			; (update it anyway)
.b9fd	d0 01		bne $ba00			bne 	LCLWrite 					; if different, output it
.b9ff	60		rts				rts
.ba00					LCLWrite:
.ba00	da		phx				phx
.ba01	ae 1d 04	ldx $041d			ldx 	tbOffset 					; write out make ASCIIZ
.ba04	9d 2d 04	sta $042d,x			sta 	tokenBuffer,x
.ba07	9e 2e 04	stz $042e,x			stz 	tokenBuffer+1,x
.ba0a	ee 1d 04	inc $041d			inc 	tbOffset 					; bump the position
.ba0d	09 00		ora #$00			ora 	#0 							; don't update last character if colour data
.ba0f	30 03		bmi $ba14			bmi 	_LCLNoColour
.ba11	8d 27 04	sta $0427			sta 	LCLastCharacter
.ba14					_LCLNoColour:
.ba14	fa		plx				plx
.ba15	60		rts				rts
.ba16					LCLDeleteLastSpace:
.ba16	48		pha				pha
.ba17	da		phx				phx
.ba18	ae 1d 04	ldx $041d			ldx 	tbOffset
.ba1b	f0 0a		beq $ba27			beq 	_LCDLSExit
.ba1d	bd 2c 04	lda $042c,x			lda 	tokenBuffer-1,x
.ba20	c9 20		cmp #$20			cmp 	#' '
.ba22	d0 03		bne $ba27			bne 	_LCDLSExit
.ba24	ce 1d 04	dec $041d			dec 	tbOffset
.ba27					_LCDLSExit:
.ba27	fa		plx				plx
.ba28	68		pla				pla
.ba29	60		rts				rts
.ba2a					LCLCheckSpaceRequired:
.ba2a	ad 27 04	lda $0427			lda 	LCLastCharacter 			; check last character
.ba2d	c9 24		cmp #$24			cmp 	#'$' 						; $ # and ) require that token space.
.ba2f	f0 1b		beq $ba4c			beq 	_LCCSRSpace
.ba31	c9 29		cmp #$29			cmp 	#')'
.ba33	f0 17		beq $ba4c			beq 	_LCCSRSpace
.ba35	c9 23		cmp #$23			cmp 	#'#'
.ba37	f0 13		beq $ba4c			beq 	_LCCSRSpace
.ba39	20 52 ba	jsr $ba52			jsr 	LCLLowerCase 				; saves a little effort
.ba3c	c9 30		cmp #$30			cmp 	#"0" 						; check if it was 0-9 A-Z a-z if so need space.
.ba3e	90 11		bcc $ba51			bcc 	_LCCSRExit
.ba40	c9 3a		cmp #$3a			cmp 	#"9"+1
.ba42	90 08		bcc $ba4c			bcc 	_LCCSRSpace
.ba44	c9 61		cmp #$61			cmp 	#"a"
.ba46	90 09		bcc $ba51			bcc 	_LCCSRExit
.ba48	c9 7b		cmp #$7b			cmp 	#"z"+1
.ba4a	b0 05		bcs $ba51			bcs 	_LCCSRExit
.ba4c					_LCCSRSpace:
.ba4c	a9 20		lda #$20			lda 	#' '
.ba4e	20 00 ba	jsr $ba00			jsr 	LCLWrite
.ba51					_LCCSRExit:
.ba51	60		rts				rts
.ba52					LCLLowerCase:
.ba52	c9 41		cmp #$41			cmp 	#"A"
.ba54	90 06		bcc $ba5c			bcc 	_LCLLCOut
.ba56	c9 5b		cmp #$5b			cmp 	#"Z"+1
.ba58	b0 02		bcs $ba5c			bcs 	_LCLLCOut
.ba5a	69 20		adc #$20			adc 	#$20
.ba5c					_LCLLCOut:
.ba5c	60		rts				rts
.ba5d					LCLUpperCase:
.ba5d	c9 61		cmp #$61			cmp 	#"a"
.ba5f	90 06		bcc $ba67			bcc 	_LCLUCOut
.ba61	c9 7b		cmp #$7b			cmp 	#"z"+1
.ba63	b0 02		bcs $ba67			bcs 	_LCLUCOut
.ba65	e9 1f		sbc #$1f			sbc 	#$1F
.ba67					_LCLUCOut:
.ba67	60		rts				rts
.ba68					LCLWriteNumberXA:
.ba68	64 37		stz $37				stz 	zTemp0+1 					; index into digit table.
.ba6a					_LCLWNLoop1:
.ba6a	64 36		stz $36				stz 	zTemp0 						; subtraction count.
.ba6c					_LCLWNLoop2:
.ba6c	48		pha				pha 								; save initial LSB
.ba6d	38		sec				sec
.ba6e	a4 37		ldy $37				ldy 	zTemp0+1 					; position in table.
.ba70	f9 a1 ba	sbc $baa1,y			sbc 	_LCLWNTable,y
.ba73	48		pha				pha
.ba74	8a		txa				txa
.ba75	f9 a2 ba	sbc $baa2,y			sbc 	_LCLWNTable+1,y
.ba78	90 07		bcc $ba81			bcc 	_LCLWNUnderflow
.ba7a	e6 36		inc $36				inc 	zTemp0  					; subtracted one without borrow.
.ba7c	aa		tax				tax 								; update X
.ba7d	68		pla				pla 								; restore A
.ba7e	7a		ply				ply 								; throw original
.ba7f	80 eb		bra $ba6c			bra 	_LCLWNLoop2 				; try again.
.ba81					_LCLWNUnderflow:
.ba81	a4 36		ldy $36				ldy 	zTemp0 						; count of subtractions.
.ba83	d0 06		bne $ba8b			bne 	_LCLWNOut
.ba85	ad 1d 04	lda $041d			lda 	tbOffset 					; suppress leading zeroes
.ba88	3a		dec a				dec 	a
.ba89	f0 04		beq $ba8f			beq 	_LCLWNNext
.ba8b					_LCLWNOut:
.ba8b	98		tya				tya
.ba8c	20 9b ba	jsr $ba9b			jsr 	_LCLWNOutDigit
.ba8f					_LCLWNNext:
.ba8f	7a		ply				ply 							 	; restore original value.
.ba90	68		pla				pla
.ba91	a4 37		ldy $37				ldy 	zTemp0+1  					; bump the index
.ba93	c8		iny				iny
.ba94	c8		iny				iny
.ba95	84 37		sty $37				sty 	zTemp0+1
.ba97	c0 08		cpy #$08			cpy 	#8 							; done all 4
.ba99	d0 cf		bne $ba6a			bne 	_LCLWNLoop1
.ba9b					_LCLWNOutDigit:
.ba9b	09 30		ora #$30			ora 	#'0'
.ba9d	20 00 ba	jsr $ba00			jsr 	LCLWrite
.baa0	60		rts				rts
.baa1					_LCLWNTable:
>baa1	10 27						.word 	10000
>baa3	e8 03						.word 	1000
>baa5	64 00						.word 	100
>baa7	0a 00						.word 	10
.baa9					TOKSearchTable:
.baa9	84 37		sty $37				sty 	zTemp0+1 					; (zTemp0),y points to current token being tested.
.baab	85 36		sta $36				sta 	zTemp0
.baad	a0 00		ldy #$00			ldy 	#0
.baaf	a9 80		lda #$80			lda 	#$80 						; token # so we know which one we are looking at
.bab1	85 38		sta $38				sta 	zTemp1
.bab3					_TSTLoop:
.bab3	b1 36		lda ($36),y			lda 	(zTemp0),y 					; length, 0 (skip) -ve (end)
.bab5	30 49		bmi $bb00			bmi 	_TSTFail 					; -ve = end of table, so fail.
.bab7	f0 2e		beq $bae7			beq 	_TSTNext 					; zero, check next as it's a dummy (e.g. EOL, SHIFT)
.bab9	c8		iny				iny 								; get the hash
.baba	b1 36		lda ($36),y			lda 	(zTemp0),y
.babc	88		dey				dey
.babd	cd 03 04	cmp $0403			cmp 	identHash 					; check they match with the identifier hash, if not go to next
.bac0	d0 25		bne $bae7			bne 	_TSTNext
.bac2	ad 02 04	lda $0402			lda 	identTypeEnd 				; get length of identifier from end-start
.bac5	38		sec				sec
.bac6	ed 00 04	sbc $0400			sbc 	identStart
.bac9	d1 36		cmp ($36),y			cmp 	(zTemp0),y 					; compare against the length in the table, no match, then return.
.bacb	d0 1a		bne $bae7			bne 	_TSTNext
.bacd	5a		phy				phy 								; save Y , we might fail to match.
.bace	c8		iny				iny 								; point to text
.bacf	c8		iny				iny
.bad0	ae 00 04	ldx $0400			ldx 	identStart 					; offset in line buffer in X
.bad3					_TSTCompareName:
.bad3	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; compare text.
.bad6	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.bad8	d0 0c		bne $bae6			bne 	_TSTNextPullY 				; fail, pullY and do next
.bada	e8		inx				inx
.badb	c8		iny				iny
.badc	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; complete match.
.badf	d0 f2		bne $bad3			bne 	_TSTCompareName
.bae1	7a		ply				ply 								; throw Y
.bae2	a5 38		lda $38				lda 	zTemp1 						; get token #
.bae4	38		sec				sec 								; return with CS = passed.
.bae5	60		rts				rts
.bae6					_TSTNextPullY:
.bae6	7a		ply				ply 								; restore current, fall through.
.bae7					_TSTNext:
.bae7	e6 38		inc $38				inc 	zTemp1 						; token counter
.bae9	98		tya				tya
.baea	18		clc				clc
.baeb	71 36		adc ($36),y			adc 	(zTemp0),y 					; add [Length] + 2 to Y
.baed	1a		inc a				inc 	a 							; +1
.baee	1a		inc a				inc 	a 							; +2
.baef	a8		tay				tay
.baf0	10 c1		bpl $bab3			bpl 	_TSTLoop 					; if Y < $80 loop back
.baf2	98		tya				tya 								; add Y to zTemp0 and reset Y
.baf3	a0 00		ldy #$00			ldy 	#0   						; so we can use Y to search fast
.baf5	18		clc				clc  								; but have tables > 255 bytes
.baf6	65 36		adc $36				adc 	zTemp0 						; when Y gets >= 128 we reset Y
.baf8	85 36		sta $36				sta 	zTemp0 						; and adjust the table pointer/
.bafa	90 b7		bcc $bab3			bcc 	_TSTLoop
.bafc	e6 37		inc $37				inc 	zTemp0+1
.bafe	80 b3		bra $bab3			bra 	_TSTLoop
.bb00					_TSTFail:
.bb00	18		clc				clc
.bb01	60		rts				rts
.bb02					Export_TKTokeniseLine:
.bb02	20 8a bc	jsr $bc8a			jsr 	LCLFixLineBufferCase 		; fix line case
.bb05	a9 03		lda #$03			lda 	#3 							; reset the token buffer to empty
.bb07	8d 2a 04	sta $042a			sta 	tokenOffset 				; (3 bytes for line number & offset)
.bb0a	9c 2b 04	stz $042b			stz 	tokenLineNumber
.bb0d	9c 2c 04	stz $042c			stz 	tokenLineNumber+1
.bb10	a2 ff		ldx #$ff			ldx 	#$FF
.bb12					_TKFindFirst:
.bb12	e8		inx				inx
.bb13	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.bb16	f0 79		beq $bb91			beq 	_TKExit
.bb18	c9 20		cmp #$20			cmp 	#' '
.bb1a	90 f6		bcc $bb12			bcc 	_TKFindFirst
.bb1c	c9 30		cmp #$30			cmp 	#'0'
.bb1e	90 07		bcc $bb27			bcc 	_TKNoLineNumber
.bb20	c9 3a		cmp #$3a			cmp 	#'9'+1
.bb22	b0 03		bcs $bb27			bcs 	_TKNoLineNumber
.bb24	20 b4 bc	jsr $bcb4			jsr 	TOKExtractLineNumber
.bb27					_TKNoLineNumber:
.bb27					_TKTokeniseLoop:
.bb27	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; next character, exit if zero EOL.
.bb2a	f0 65		beq $bb91			beq 	_TKExit
.bb2c	e8		inx				inx
.bb2d	c9 20		cmp #$20			cmp 	#' '
.bb2f	f0 f6		beq $bb27			beq 	_TKTokeniseLoop 			; keep looping if space found.
.bb31	ca		dex				dex 								; undo last get, A contains character, X is position.
.bb32	c9 5f		cmp #$5f			cmp 	#'_'						; _ A-Z is identifier *or* token
.bb34	f0 61		beq $bb97			beq 	_TKTokeniseIdentifier 		; (already case converted outside string constants)
.bb36	c9 41		cmp #$41			cmp 	#'A'
.bb38	90 04		bcc $bb3e			bcc 	_TKTokenisePunctuation
.bb3a	c9 5b		cmp #$5b			cmp 	#'Z'+1
.bb3c	90 59		bcc $bb97			bcc 	_TKTokeniseIdentifier
.bb3e					_TKTokenisePunctuation:
.bb3e	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.bb40	f0 27		beq $bb69			beq 	_TKString
.bb42	c9 24		cmp #$24			cmp 	#'$'						; hexadecimal constant ($ only appears at end of identifiers)
.bb44	f0 28		beq $bb6e			beq 	_TKHexConstant
.bb46	c9 3c		cmp #$3c			cmp 	#'<' 						; check for < > handlers - these are for <> <= >= >> <<
.bb48	f0 29		beq $bb73			beq 	_TKCheckDouble
.bb4a	c9 3e		cmp #$3e			cmp 	#'>'
.bb4c	f0 25		beq $bb73			beq 	_TKCheckDouble
.bb4e					_TKStandardPunctuation:
.bb4e	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get the punctuation token back.
.bb51	c9 40		cmp #$40			cmp 	#64 						; are we >= 64
.bb53	90 0e		bcc $bb63			bcc 	_TKNoShift
.bb55	48		pha				pha 								; save. we are about to convert this punctuation token from
.bb56	29 07		and #$07			and 	#7 							; lower 3 bits in zTemp0
.bb58	85 36		sta $36				sta 	zTemp0
.bb5a	68		pla				pla
.bb5b	29 20		and #$20			and 	#32 						; bit 5
.bb5d	4a		lsr a				lsr 	a 							; shift into bit 3
.bb5e	4a		lsr a				lsr 	a
.bb5f	05 36		ora $36				ora 	zTemp0
.bb61	09 10		ora #$10			ora 	#$10						; now in the range 16-31
.bb63					_TKNoShift:
.bb63	20 f9 bc	jsr $bcf9			jsr 	TOKWriteByte 				; write the punctuation character
.bb66	e8		inx				inx 								; consume the character
.bb67	80 be		bra $bb27			bra 	_TKTokeniseLoop 			; and loop round again.
.bb69					_TKString:
.bb69	20 19 bc	jsr $bc19			jsr 	TOKTokenString
.bb6c	80 b9		bra $bb27			bra 	_TKTokeniseLoop
.bb6e					_TKHexConstant:
.bb6e	20 54 bc	jsr $bc54			jsr 	TOKHexConstant
.bb71	80 b4		bra $bb27			bra 	_TKTokeniseLoop
.bb73					_TKCheckDouble:
.bb73	bd 2b 05	lda $052b,x			lda 	lineBuffer+1,x 				; get next character
.bb76	c9 3c		cmp #$3c			cmp 	#'<'						; if not < = > which are ASCII consecutive go back
.bb78	90 d4		bcc $bb4e			bcc 	_TKStandardPunctuation 		; and do the normal punctuation handler.
.bb7a	c9 3f		cmp #$3f			cmp 	#'>'+1
.bb7c	b0 d0		bcs $bb4e			bcs 	_TKStandardPunctuation
.bb7e	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; this is < (60) or > (62)
.bb81	29 02		and #$02			and 	#2 							; now < (0) or > (2)
.bb83	0a		asl a				asl 	a 							; now < (0) or > (4), CC also
.bb84	7d 2b 05	adc $052b,x			adc 	lineBuffer+1,x 				; add < = > codes - < code
.bb87	38		sec				sec
.bb88	e9 3c		sbc #$3c			sbc 	#'<'
.bb8a	20 f9 bc	jsr $bcf9			jsr 	TOKWriteByte 				; this is in the range 0-7
.bb8d	e8		inx				inx 								; consume both
.bb8e	e8		inx				inx
.bb8f	80 96		bra $bb27			bra 	_TKTokeniseLoop
.bb91	a9 80		lda #$80	_TKExit:lda 	#KWC_EOL 					; write end of line byte
.bb93	20 f9 bc	jsr $bcf9			jsr 	TOKWriteByte
.bb96	60		rts				rts
.bb97					_TKTokeniseIdentifier:
.bb97	8e 00 04	stx $0400			stx 	identStart 					; save start
.bb9a	9c 04 04	stz $0404			stz 	identTypeByte 				; zero the type byte
.bb9d					_TKCheckLoop:
.bb9d	e8		inx				inx 								; look at next, we know first is identifier already.
.bb9e	bd 2a 05	lda $052a,x			lda  	lineBuffer,x
.bba1	c9 5f		cmp #$5f			cmp 	#"_" 						; legal char _ 0-9 A-Z
.bba3	f0 f8		beq $bb9d			beq 	_TKCheckLoop
.bba5	c9 30		cmp #$30			cmp	 	#"0"
.bba7	90 0c		bcc $bbb5			bcc 	_TKEndIdentifier
.bba9	c9 3a		cmp #$3a			cmp 	#"9"+1
.bbab	90 f0		bcc $bb9d			bcc 	_TKCheckLoop
.bbad	c9 41		cmp #$41			cmp	 	#"A"
.bbaf	90 04		bcc $bbb5			bcc 	_TKEndIdentifier
.bbb1	c9 5b		cmp #$5b			cmp 	#"Z"+1
.bbb3	90 e8		bcc $bb9d			bcc 	_TKCheckLoop
.bbb5					_TKEndIdentifier:
.bbb5	8e 01 04	stx $0401			stx 	identTypeStart 				; save start of type text (if any !)
.bbb8	a0 08		ldy #$08			ldy 	#$08 						; this is the identifier type byte for #
.bbba	c9 23		cmp #$23			cmp 	#"#"						; followed by #
.bbbc	f0 06		beq $bbc4			beq 	_TKHasTypeCharacter
.bbbe	a0 10		ldy #$10			ldy 	#$10 						; this is the identifier type byte for $
.bbc0	c9 24		cmp #$24			cmp 	#"$"						; followed by $ or #
.bbc2	d0 07		bne $bbcb			bne 	_TKNoTypeCharacter
.bbc4					_TKHasTypeCharacter:
.bbc4	8c 04 04	sty $0404			sty 	identTypeByte 				; has # or $, save the type
.bbc7	e8		inx				inx 								; consume the type character
.bbc8	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.bbcb					_TKNoTypeCharacter:
.bbcb	c9 28		cmp #$28			cmp 	#"("						; is it open parenthesis (e.g. array)
.bbcd	d0 09		bne $bbd8			bne 	_TKNoArray
.bbcf	e8		inx				inx 								; skip the (
.bbd0	ad 04 04	lda $0404			lda 	identTypeByte 				; set bit 2 (e.g. array) in type byte
.bbd3	09 04		ora #$04			ora 	#$04
.bbd5	8d 04 04	sta $0404			sta 	identTypeByte
.bbd8					_TKNoArray:
.bbd8	8e 02 04	stx $0402			stx 	identTypeEnd 				; save end marker, e.g. continue from here.
.bbdb	20 75 bc	jsr $bc75			jsr 	TOKCalculateHash 			; calculate the has for those tokens
.bbde	a0 b4		ldy #$b4			ldy 	#(KeywordSet0) >> 8
.bbe0	a9 98		lda #$98			lda 	#(KeywordSet0) & $FF
.bbe2	20 a9 ba	jsr $baa9			jsr 	TOKSearchTable
.bbe5	a2 00		ldx #$00			ldx 	#0
.bbe7	b0 1f		bcs $bc08			bcs 	_TKFoundToken
.bbe9	a0 b6		ldy #$b6			ldy 	#(KeywordSet1) >> 8
.bbeb	a9 af		lda #$af			lda 	#(KeywordSet1) & $FF
.bbed	20 a9 ba	jsr $baa9			jsr 	TOKSearchTable
.bbf0	a2 81		ldx #$81			ldx 	#$81
.bbf2	b0 14		bcs $bc08			bcs 	_TKFoundToken
.bbf4	a0 b7		ldy #$b7			ldy 	#(KeywordSet2) >> 8
.bbf6	a9 22		lda #$22			lda 	#(KeywordSet2) & $FF
.bbf8	20 a9 ba	jsr $baa9			jsr 	TOKSearchTable
.bbfb	a2 82		ldx #$82			ldx 	#$82
.bbfd	b0 09		bcs $bc08			bcs 	_TKFoundToken
.bbff	20 05 bd	jsr $bd05			jsr 	TOKCheckCreateVariableRecord ; failed all, it's a variable, create record if does not exist.
.bc02	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.bc05	4c 27 bb	jmp $bb27			jmp 	_TKTokeniseLoop 			; and go round again.
.bc08					_TKFoundToken:
.bc08	48		pha				pha 								; save token
.bc09	8a		txa				txa 								; shift in X, is there one ?
.bc0a	f0 03		beq $bc0f			beq 	_TKNoTShift
.bc0c	20 f9 bc	jsr $bcf9			jsr 	TOKWriteByte 				; if so, write it out
.bc0f					_TKNoTShift:
.bc0f	68		pla				pla 								; restore and write token
.bc10	20 f9 bc	jsr $bcf9			jsr 	TOKWriteByte
.bc13	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.bc16	4c 27 bb	jmp $bb27			jmp 	_TKTokeniseLoop 			; and go round again.
.bc19					TOKTokenString:
.bc19	a9 ff		lda #$ff			lda 	#KWC_STRING 				; string token.
.bc1b	20 f9 bc	jsr $bcf9			jsr 	TOKWriteByte
.bc1e	e8		inx				inx									; start of quoted string.
.bc1f	da		phx				phx 								; push start of string on top
.bc20	ca		dex				dex 								; because we pre-increment
.bc21					_TSFindEnd:
.bc21	e8		inx				inx
.bc22	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; next character
.bc25	f0 04		beq $bc2b			beq 	_TSEndOfString 				; no matching quote, we don't mind.
.bc27	c9 22		cmp #$22			cmp 	#'"' 						; go back if quote not found
.bc29	d0 f6		bne $bc21			bne 	_TSFindEnd
.bc2b					_TSEndOfString:
.bc2b	7a		ply				ply  								; so now Y is first character, X is character after end.
.bc2c	48		pha				pha 								; save terminating character
.bc2d	20 35 bc	jsr $bc35			jsr 	TOKWriteBlockXY 			; write X to Y as a data block
.bc30	68		pla				pla 								; terminating character
.bc31	f0 01		beq $bc34			beq 	_TSNotQuote					; if it wasn't EOS skip it
.bc33	e8		inx				inx
.bc34					_TSNotQuote:
.bc34	60		rts				rts
.bc35					TOKWriteBlockXY:
.bc35	86 36		stx $36				stx 	zTemp0 						; save end character
.bc37	98		tya				tya 								; use 2's complement to work out the byte size
.bc38	49 ff		eor #$ff			eor 	#$FF
.bc3a	38		sec				sec
.bc3b	65 36		adc $36				adc 	zTemp0
.bc3d	1a		inc a				inc 	a 							; one extra for NULL
.bc3e	20 f9 bc	jsr $bcf9			jsr 	TOKWriteByte
.bc41					_TOBlockLoop:
.bc41	c4 36		cpy $36				cpy 	zTemp0 						; exit if reached the end
.bc43	f0 09		beq $bc4e			beq 	_TOBlockExit
.bc45	b9 2a 05	lda $052a,y			lda 	lineBuffer,y 				; write byte out.
.bc48	20 f9 bc	jsr $bcf9			jsr 	TOKWriteByte
.bc4b	c8		iny				iny
.bc4c	80 f3		bra $bc41			bra 	_TOBlockLoop
.bc4e					_TOBlockExit:
.bc4e	a9 00		lda #$00			lda 	#0 							; add NULL.
.bc50	20 f9 bc	jsr $bcf9			jsr 	TOKWriteByte
.bc53	60		rts				rts
.bc54					TOKHexConstant:
.bc54	a9 fe		lda #$fe			lda 	#KWC_HEXCONST 				; hex constant token.
.bc56	20 f9 bc	jsr $bcf9			jsr 	TOKWriteByte
.bc59	e8		inx				inx									; start of quoted string.
.bc5a	da		phx				phx 								; push start of constant on top
.bc5b	ca		dex				dex
.bc5c					_THFindLoop:
.bc5c	e8		inx				inx 	 							; this is stored in a block, so find out how long
.bc5d	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; the hex constant is.
.bc60	c9 30		cmp #$30			cmp 	#"0"
.bc62	90 0c		bcc $bc70			bcc 	_THFoundEnd
.bc64	c9 3a		cmp #$3a			cmp 	#"9"+1
.bc66	90 f4		bcc $bc5c			bcc 	_THFindLoop
.bc68	c9 41		cmp #$41			cmp 	#"A"
.bc6a	90 04		bcc $bc70			bcc 	_THFoundEnd
.bc6c	c9 47		cmp #$47			cmp 	#"F"+1
.bc6e	90 ec		bcc $bc5c			bcc 	_THFindLoop
.bc70					_THFoundEnd:
.bc70	7a		ply				ply 								; restore start
.bc71	20 35 bc	jsr $bc35			jsr 	TOKWriteBlockXY 			; output the block
.bc74	60		rts				rts
.bc75					TOKCalculateHash:
.bc75	da		phx				phx
.bc76	ae 00 04	ldx $0400			ldx 	identStart 					; needs to be same as in tokens.py - simple sum at present.
.bc79	a9 00		lda #$00			lda 	#0
.bc7b					_TCHLoop:
.bc7b	18		clc				clc
.bc7c	7d 2a 05	adc $052a,x			adc 	lineBuffer,x
.bc7f	e8		inx				inx
.bc80	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; do the whole thing including type and array markers.
.bc83	d0 f6		bne $bc7b			bne 	_TCHLoop
.bc85	8d 03 04	sta $0403			sta 	identHash 					; save the hash
.bc88	fa		plx				plx
.bc89	60		rts				rts
.bc8a					LCLFixLineBufferCase:
.bc8a	a2 00		ldx #$00			ldx 	#0
.bc8c					_FLBCLoop:
.bc8c	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get next character
.bc8f	f0 22		beq $bcb3			beq 	_FLBCExit 					; end of string.
.bc91	c9 22		cmp #$22			cmp 	#'"'						; quote, go to in quotes
.bc93	f0 11		beq $bca6			beq 	_FLBCInQuotes
.bc95	e8		inx				inx
.bc96	c9 61		cmp #$61			cmp 	#'a'						; needs capitalising ?
.bc98	90 f2		bcc $bc8c			bcc 	_FLBCLoop
.bc9a	c9 7b		cmp #$7b			cmp 	#'z'+1
.bc9c	b0 ee		bcs $bc8c			bcs 	_FLBCLoop
.bc9e	38		sec				sec 								; make U/C
.bc9f	e9 20		sbc #$20			sbc 	#32
.bca1	9d 29 05	sta $0529,x			sta	 	lineBuffer-1,x 				; write back
.bca4	80 e6		bra $bc8c			bra 	_FLBCLoop
.bca6					_FLBCInQuotes:
.bca6	e8		inx				inx 								; advance
.bca7	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get next
.bcaa	f0 07		beq $bcb3			beq 	_FLBCExit 					; exit on EOS
.bcac	c9 22		cmp #$22			cmp 	#'"' 				 		; until " found
.bcae	d0 f6		bne $bca6			bne 	_FLBCInQuotes
.bcb0	e8		inx				inx 								; skip over it
.bcb1	80 d9		bra $bc8c			bra 	_FLBCLoop
.bcb3					_FLBCExit:
.bcb3	60		rts				rts
.bcb4					TOKExtractLineNumber:
.bcb4	ad 2c 04	lda $042c			lda 	tokenLineNumber+1 			; push current value on stack
.bcb7	48		pha				pha
.bcb8	ad 2b 04	lda $042b			lda 	tokenLineNumber
.bcbb	48		pha				pha
.bcbc	20 f2 bc	jsr $bcf2			jsr 	_LCLNTimes2 				; line # x 2
.bcbf	20 f2 bc	jsr $bcf2			jsr 	_LCLNTimes2 				; line # x 4
.bcc2	18		clc				clc 								; add stacked value
.bcc3	68		pla				pla
.bcc4	6d 2b 04	adc $042b			adc 	tokenLineNumber
.bcc7	8d 2b 04	sta $042b			sta 	tokenLineNumber
.bcca	68		pla				pla
.bccb	6d 2c 04	adc $042c			adc 	tokenLineNumber+1
.bcce	8d 2c 04	sta $042c			sta 	tokenLineNumber+1 			; line # x 5
.bcd1	20 f2 bc	jsr $bcf2			jsr 	_LCLNTimes2 				; line # x 10
.bcd4	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get and consume character
.bcd7	e8		inx				inx
.bcd8	29 0f		and #$0f			and 	#15 						; add to line #
.bcda	18		clc				clc
.bcdb	6d 2b 04	adc $042b			adc 	tokenLineNumber
.bcde	8d 2b 04	sta $042b			sta 	tokenLineNumber
.bce1	90 03		bcc $bce6			bcc 	_TLENNoCarry
.bce3	ee 2c 04	inc $042c			inc 	tokenLineNumber+1
.bce6					_TLENNoCarry:
.bce6	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; more digits ?
.bce9	c9 30		cmp #$30			cmp 	#'0'
.bceb	90 04		bcc $bcf1			bcc 	_TLENExit
.bced	c9 3a		cmp #$3a			cmp 	#'9'+1
.bcef	90 c3		bcc $bcb4			bcc 	TOKExtractLineNumber
.bcf1					_TLENExit:
.bcf1	60		rts				rts
.bcf2					_LCLNTimes2:
.bcf2	0e 2b 04	asl $042b			asl 	tokenLineNumber 			; doubles tokenLineNumber.
.bcf5	2e 2c 04	rol $042c			rol 	tokenLineNumber+1
.bcf8	60		rts				rts
.bcf9					TOKWriteByte:
.bcf9	da		phx				phx
.bcfa	ae 2a 04	ldx $042a			ldx 	tokenOffset 				; next slot to write to
.bcfd	9d 2a 04	sta $042a,x			sta 	tokenOffset,x 				; write byte out
.bd00	ee 2a 04	inc $042a			inc 	tokenOffset 				; advance slot.
.bd03	fa		plx				plx
.bd04	60		rts				rts
.bd05					TOKCheckCreateVariableRecord:
.bd05	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.bd07	85 36		sta $36				sta 	0+zTemp0
.bd09	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.bd0b	85 37		sta $37				sta 	1+zTemp0
.bd0d					_CCVSearch:
.bd0d	b2 36		lda ($36)			lda 	(zTemp0) 					; end of list
.bd0f	f0 2c		beq $bd3d			beq 	_CCVFail
.bd11	a0 01		ldy #$01			ldy 	#1 							; read the hash
.bd13	b1 36		lda ($36),y			lda 	(zTemp0),y 					; does it match ?
.bd15	cd 03 04	cmp $0403			cmp 	identHash 	  				; if not, try the next.
.bd18	d0 16		bne $bd30			bne 	_CCVNext
.bd1a	a0 08		ldy #$08			ldy 	#8 							; name in variable record
.bd1c	ae 00 04	ldx $0400			ldx 	identStart
.bd1f					_CCVCompare:
.bd1f	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; xor them. zero if the same, except
.bd22	51 36		eor ($36),y			eor 	(zTemp0),y 					; bit 7 is used for EOS.
.bd24	e8		inx				inx 								; advance pointers
.bd25	c8		iny				iny
.bd26	0a		asl a				asl 	a 							; A = 0 if they match, CS if end.
.bd27	d0 07		bne $bd30			bne 	_CCVNext  					; didn't match go to next.
.bd29	90 f4		bcc $bd1f			bcc 	_CCVCompare 				; not finished yet.
.bd2b	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; matched whole thing ?
.bd2e	f0 41		beq $bd71			beq 	_CCVFound 					; yes, we were successful
.bd30					_CCVNext:
.bd30	18		clc				clc 								; go to next record.
.bd31	b2 36		lda ($36)			lda 	(zTemp0) 					; add offset to pointer
.bd33	65 36		adc $36				adc 	zTemp0
.bd35	85 36		sta $36				sta 	zTemp0
.bd37	90 d4		bcc $bd0d			bcc 	_CCVSearch
.bd39	e6 37		inc $37				inc 	zTemp0+1
.bd3b	80 d0		bra $bd0d			bra 	_CCVSearch
.bd3d					_CCVFail:
.bd3d	a0 01		ldy #$01			ldy 	#1 							; create the new record. Offset 1 is hash
.bd3f	ad 03 04	lda $0403			lda 	identHash
.bd42	91 36		sta ($36),y			sta 	(zTemp0),y
.bd44	c8		iny				iny 								; offset 2 is the type byte
.bd45	ad 04 04	lda $0404			lda 	identTypeByte
.bd48	91 36		sta ($36),y			sta 	(zTemp0),y
.bd4a	c8		iny				iny
.bd4b					_CCVData:
.bd4b	a9 00		lda #$00			lda 	#0 							; erase data 3-7 (the 5 value bytes)
.bd4d	91 36		sta ($36),y			sta 	(zTemp0),y
.bd4f	c8		iny				iny
.bd50	c0 08		cpy #$08			cpy 	#8
.bd52	90 f7		bcc $bd4b			bcc 	_CCVData
.bd54	ae 00 04	ldx $0400			ldx 	identStart 					; copy name into 8 on.
.bd57					_CCVCopyName:
.bd57	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.bd5a	91 36		sta ($36),y			sta 	(zTemp0),y
.bd5c	e8		inx				inx
.bd5d	c8		iny				iny
.bd5e	ec 02 04	cpx $0402			cpx 	identTypeEnd
.bd61	d0 f4		bne $bd57			bne 	_CCVCopyName
.bd63	98		tya				tya 								; patch offset
.bd64	92 36		sta ($36)			sta 	(zTemp0)
.bd66	a9 00		lda #$00			lda 	#0 							; offset for next is zero.
.bd68	91 36		sta ($36),y			sta 	(zTemp0),y
.bd6a	88		dey				dey
.bd6b	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set bit 7 of last bit
.bd6d	09 80		ora #$80			ora 	#$80
.bd6f	91 36		sta ($36),y			sta 	(zTemp0),y
.bd71					_CCVFound:
.bd71	a5 37		lda $37				lda 	zTemp0+1 					; write out MSB
.bd73	38		sec				sec
.bd74	e9 10		sbc #$10			sbc 	#(VariableSpace >> 8) 		; offset from the start of the variable token
.bd76	09 40		ora #$40			ora 	#$40 						; make it a writeable token $4000-$7FFF
.bd78	20 f9 bc	jsr $bcf9			jsr 	TOKWriteByte
.bd7b	a5 36		lda $36				lda 	zTemp0 						; write out LSB
.bd7d	20 f9 bc	jsr $bcf9			jsr 	TOKWriteByte
.bd80	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_sound.module

=1					soundIntegrated=1
.bd81					SNDCheckChannel:
.bd81	aa		tax				tax
.bd82	bd 38 08	lda $0838,x			lda 	SNDTimeLeft,x 				; currently playing a note
.bd85	d0 38		bne $bdbf			bne 	_SNDCCExit
.bd87	da		phx				phx 								; save current channel
.bd88	8a		txa				txa 								; put in A
.bd89	20 05 be	jsr $be05			jsr 	SNDFindNextNoteForA 		; is there a note for A in the queue ?
.bd8c	68		pla				pla 								; channel # in A
.bd8d	90 30		bcc $bdbf			bcc 	_SNDCCExit  				; nothing in the queue for this channel, exit.
.bd8f	a8		tay				tay 								; Y is the channel #
.bd90	bd 2d 07	lda $072d,x			lda 	SNDQueue+1,x 				; copy data into the slot.
.bd93	99 2c 08	sta $082c,y			sta 	SNDPitchLow,y
.bd96	bd 2e 07	lda $072e,x			lda 	SNDQueue+2,x
.bd99	99 30 08	sta $0830,y			sta 	SNDPitchHigh,y
.bd9c	bd 2f 07	lda $072f,x			lda 	SNDQueue+3,x
.bd9f	99 34 08	sta $0834,y			sta 	SNDVolume,y
.bda2	bd 30 07	lda $0730,x			lda 	SNDQueue+4,x
.bda5	99 38 08	sta $0838,y			sta 	SNDTimeLeft,y
.bda8	bd 31 07	lda $0731,x			lda 	SNDQueue+5,x
.bdab	99 3c 08	sta $083c,y			sta 	SNDAdjustLow,y
.bdae	bd 32 07	lda $0732,x			lda 	SNDQueue+6,x
.bdb1	99 40 08	sta $0840,y			sta 	SNDAdjustHigh,y
.bdb4	5a		phy				phy 								; save channel #
.bdb5	20 1f be	jsr $be1f			jsr 	SNDDeleteXFromQueue 		; delete record at X from queue
.bdb8	ce 2b 07	dec $072b			dec 	SNDLength 					; reduce the queue length.
.bdbb	68		pla				pla
.bdbc	20 c0 bd	jsr $bdc0			jsr 	SNDUpdateNote 				; update channel A
.bdbf					_SNDCCExit:
.bdbf	60		rts				rts
.bdc0					SNDUpdateNote:
.bdc0	aa		tax				tax 								; so we can access records
.bdc1	0a		asl a				asl 	a 							; convert it to a channel bit pair in 5,6
.bdc2	0a		asl a				asl 	a
.bdc3	0a		asl a				asl 	a
.bdc4	0a		asl a				asl 	a
.bdc5	0a		asl a				asl 	a
.bdc6	8d 2a 07	sta $072a			sta 	SNDChannelBits
.bdc9	bd 38 08	lda $0838,x			lda 	SNDTimeLeft,x 				; are we silent
.bdcc	f0 2e		beq $bdfc			beq 	_SNDUNIsSilent
.bdce	ad 2a 07	lda $072a			lda 	SNDChannelBits 				; push channel bits on stack
.bdd1	48		pha				pha
.bdd2	bd 2c 08	lda $082c,x			lda 	SNDPitchLow,x 				; get 4 lowest bits of pitch.
.bdd5	29 0f		and #$0f			and 	#$0F
.bdd7	0d 2a 07	ora $072a			ora 	SNDChannelBits 				; set channel bits
.bdda	09 80		ora #$80			ora 	#$80 						; write to pitch register
.bddc	20 69 be	jsr $be69			jsr 	SNDWritePorts
.bddf	bd 30 08	lda $0830,x			lda 	SNDPitchHigh,x 				; pitch high => channel temp.
.bde2	8d 2a 07	sta $072a			sta 	SNDChannelBits
.bde5	bd 2c 08	lda $082c,x			lda 	SNDPitchLow,x
.bde8	4e 2a 07	lsr $072a			lsr 	SNDChannelBits 				; shift 2 LSBs into MSB of A
.bdeb	6a		ror a				ror 	a
.bdec	4e 2a 07	lsr $072a			lsr 	SNDChannelBits
.bdef	6a		ror a				ror 	a
.bdf0	4a		lsr a				lsr 	a 							; put in bits 0-5
.bdf1	4a		lsr a				lsr 	a
.bdf2	20 69 be	jsr $be69			jsr 	SNDWritePorts 				; write as rest of pitch register
.bdf5	68		pla				pla
.bdf6	09 90		ora #$90			ora 	#$90 						; set to write minimum attentuation.
.bdf8	20 69 be	jsr $be69			jsr 	SNDWritePorts
.bdfb	60		rts				rts
.bdfc					_SNDUNIsSilent:
.bdfc	ad 2a 07	lda $072a			lda 	SNDChannelBits 				; channel bits
.bdff	09 9f		ora #$9f			ora 	#$9F 						; maximum attenuation
.be01	20 69 be	jsr $be69			jsr 	SNDWritePorts 				; write to the ports
.be04	60		rts				rts
.be05					SNDFindNextNoteForA:
.be05	ac 2b 07	ldy $072b			ldy 	SNDLength 					; queue size into Y
.be08	f0 13		beq $be1d			beq 	_SNDFNNFail 				; queue empty.
.be0a	a2 00		ldx #$00			ldx 	#0
.be0c					_SNDFNNSearch:
.be0c	dd 2c 07	cmp $072c,x			cmp 	SNDQueue,x 					; does it match the channel
.be0f	38		sec				sec
.be10	f0 0c		beq $be1e			beq 	_SNDFNNExit 				; if so exit with CS.
.be12	e8		inx				inx 								; next queue slot.
.be13	e8		inx				inx
.be14	e8		inx				inx
.be15	e8		inx				inx
.be16	e8		inx				inx
.be17	e8		inx				inx
.be18	e8		inx				inx
.be19	e8		inx				inx
.be1a	88		dey				dey 								; done the whole queue
.be1b	d0 ef		bne $be0c			bne 	_SNDFNNSearch 				; no, go back.
.be1d					_SNDFNNFail:
.be1d	18		clc				clc
.be1e					_SNDFNNexit:
.be1e	60		rts				rts
.be1f					SNDDeleteXFromQueue:
.be1f	e0 f8		cpx #$f8			cpx 	#SNDQueueSize*8-8 			; reached the end.
.be21	f0 09		beq $be2c			beq 	_SNDDXExit
.be23	bd 34 07	lda $0734,x			lda 	SNDQueue+8,x
.be26	9d 2c 07	sta $072c,x			sta 	SNDQueue,x
.be29	e8		inx				inx
.be2a	80 f3		bra $be1f			bra 	SNDDeleteXFromQueue
.be2c					_SNDDXExit:
.be2c	60		rts				rts
.072a					SNDChannelBits:
>072a							.fill 	1
.be2d					SNDQueueRequest:
.be2d	86 36		stx $36				stx 	zTemp0						; save queue address
.be2f	84 37		sty $37				sty 	zTemp0+1
.be31	ae 2b 07	ldx $072b			ldx 	SNDLength 					; queue is full, can't take any more.
.be34	e0 20		cpx #$20			cpx 	#SNDQueueSize
.be36	f0 21		beq $be59			beq 	_SNDQRExit
.be38	29 03		and #$03			and 	#3	 						; channel # and push on stack
.be3a	48		pha				pha
.be3b	8a		txa				txa  								; get offset in queue buffer/
.be3c	0a		asl a				asl 	a
.be3d	0a		asl a				asl 	a
.be3e	0a		asl a				asl 	a
.be3f	aa		tax				tax
.be40	68		pla				pla 								; get back and push again
.be41	48		pha				pha
.be42	9d 2c 07	sta $072c,x			sta 	SNDQueue+0,x 				; save the channel #
.be45	a0 00		ldy #$00			ldy 	#0 							; copy the rest in.
.be47					_SNDQCopy:
.be47	b1 36		lda ($36),y			lda 	(zTemp0),y
.be49	e8		inx				inx
.be4a	c8		iny				iny
.be4b	9d 2c 07	sta $072c,x			sta 	SNDQueue,x
.be4e	c0 06		cpy #$06			cpy 	#6
.be50	d0 f5		bne $be47			bne 	_SNDQCopy
.be52	ee 2b 07	inc $072b			inc 	SNDLength 					; bump queue length.
.be55	68		pla				pla 								; get channel # back
.be56	20 81 bd	jsr $bd81			jsr 	SNDCheckChannel 			; check if channel needs refreshing.
.be59					_SNDQRExit:
.be59	60		rts				rts
.be5a					SNDSilenceChannel:
.be5a	aa		tax				tax 								; zero time left.
.be5b	9e 38 08	stz $0838,x			stz 	SNDTimeLeft,x
.be5e	0a		asl a				asl 	a 							; shift into position
.be5f	0a		asl a				asl 	a
.be60	0a		asl a				asl 	a
.be61	0a		asl a				asl 	a
.be62	0a		asl a				asl 	a
.be63	09 9f		ora #$9f			ora 	#$9F 						; write register attenuation $F
.be65	20 69 be	jsr $be69			jsr 	SNDWritePorts
.be68	60		rts				rts
.be69					SNDWritePorts:
.be69	da		phx				phx 								; save X
.be6a	a6 01		ldx $01				ldx 	1 							; save I/O status
.be6c	64 01		stz $01				stz 	1 							; access I/O page 0
.be6e	8d 00 d6	sta $d600			sta 	$D600 						; write to both
.be71	8d 10 d6	sta $d610			sta 	$D610
.be74	86 01		stx $01				stx 	1 							; restore I/O
.be76	fa		plx				plx 								; restore X
.be77	60		rts				rts
.be78					Export_SNDCommand:
.be78	da		phx				phx 								; save XY
.be79	5a		phy				phy
.be7a	c9 0f		cmp #$0f			cmp 	#$0F 						; $0F is initialise
.be7c	f0 1d		beq $be9b			beq 	_SNDInitialise
.be7e	90 28		bcc $bea8			bcc 	_SNDExit
.be80	c9 3f		cmp #$3f			cmp 	#$3F 						; $3F is silence all
.be82	f0 17		beq $be9b			beq 	_SNDSilence
.be84	b0 22		bcs $bea8			bcs 	_SNDExit
.be86	c9 20		cmp #$20			cmp 	#$20 						; $2x is check playing => A
.be88	b0 09		bcs $be93			bcs 	_SNDQueryPlay
.be8a	c9 14		cmp #$14			cmp 	#$14 						; $10-$13 is queue sound
.be8c	b0 1a		bcs $bea8			bcs 	_SNDExit
.be8e	20 2d be	jsr $be2d			jsr 	SNDQueueRequest
.be91	80 15		bra $bea8			bra 	_SNDExit
.be93					_SNDQueryPlay:
.be93	29 03		and #$03			and 	#3 							; get channel #
.be95	aa		tax				tax
.be96	bd 38 08	lda $0838,x			lda 	SNDTimeLeft,x 				; read time left, if zero then silent
.be99	80 0d		bra $bea8			bra 	_SNDExit
.be9b					_SNDInitialise:
.be9b					_SNDSilence:
.be9b	9c 2b 07	stz $072b			stz 	SNDLength 					; empty the queue.
.be9e	a9 03		lda #$03			lda 	#$3 						; silence channel 0-3.
.bea0					_SNDSilenceLoop:
.bea0	48		pha				pha
.bea1	20 5a be	jsr $be5a			jsr 	SNDSilenceChannel
.bea4	68		pla				pla
.bea5	3a		dec a				dec 	a
.bea6	10 f8		bpl $bea0			bpl 	_SNDSilenceLoop
.bea8					_SNDExit:
.bea8	7a		ply				ply
.bea9	fa		plx				plx
.beaa	60		rts				rts
=32					SNDQueueSize = 32 							; number of queue entries
.072b					SNDLength:
>072b							.fill 	1
.072c					SNDQueue:
>072c							.fill 	SNDQueueSize * 8
.082c					SNDPitchLow:
>082c							.fill 	4
.0830					SNDPitchHigh:
>0830							.fill 	4
.0834					SNDVolume:
>0834							.fill 	4
.0838					SNDTimeLeft:
>0838							.fill 	4
.083c					SNDAdjustLow:
>083c							.fill 	4
.0840					SNDAdjustHigh:
>0840							.fill 	4
.beab					Export_SNDUpdate:
.beab					PagedSNDUpdate:
.beab	ad 38 08	lda $0838			lda 	SNDTimeLeft+0 				; look at time remaining
.beae	f0 05		beq $beb5			beq 	_SNDUNot0 					; not playing
.beb0	a2 00		ldx #$00			ldx 	#0 							; so we know which channel to update
.beb2	20 d4 be	jsr $bed4			jsr 	SNDUpdateChannel 			; update it.
.beb5					_SNDUNot0:
.beb5	ad 39 08	lda $0839			lda 	SNDTimeLeft+1
.beb8	f0 05		beq $bebf			beq 	_SNDUNot1
.beba	a2 01		ldx #$01			ldx 	#1
.bebc	20 d4 be	jsr $bed4			jsr 	SNDUpdateChannel
.bebf					_SNDUNot1:
.bebf	ad 3a 08	lda $083a			lda 	SNDTimeLeft+2
.bec2	f0 05		beq $bec9			beq 	_SNDUNot2
.bec4	a2 02		ldx #$02			ldx 	#2
.bec6	20 d4 be	jsr $bed4			jsr 	SNDUpdateChannel
.bec9					_SNDUNot2:
.bec9	ad 3b 08	lda $083b			lda 	SNDTimeLeft+3
.becc	f0 05		beq $bed3			beq 	_SNDUNot3
.bece	a2 03		ldx #$03			ldx 	#3
.bed0	20 d4 be	jsr $bed4			jsr 	SNDUpdateChannel
.bed3					_SNDUNot3:
.bed3	60		rts				rts
.bed4					SNDUpdateChannel:
.bed4	c9 ff		cmp #$ff			cmp 	#$FF 						; sound $FF play forever until turned off manually
.bed6	f0 2c		beq $bf04			beq 	_SNDUCExit
.bed8	3a		dec a				dec 	a 							; decrement and update timer
.bed9	9d 38 08	sta $0838,x			sta 	SNDTimeLeft,x
.bedc	f0 1d		beq $befb			beq 	_SNDUCUpdate 				; if zero, silence channel
.bede	bd 3c 08	lda $083c,x			lda 	SNDAdjustLow,x 				; adjust ?
.bee1	1d 40 08	ora $0840,x			ora 	SNDAdjustHigh,x
.bee4	f0 1e		beq $bf04			beq 	_SNDUCExit 					; if zero carry on at current tone.
.bee6	18		clc				clc 								; add adjust, forcing into a 10 bit range
.bee7	bd 2c 08	lda $082c,x			lda 	SNDPitchLow,x
.beea	7d 3c 08	adc $083c,x			adc 	SNDAdjustLow,x
.beed	9d 2c 08	sta $082c,x			sta 	SNDPitchLow,x
.bef0	bd 30 08	lda $0830,x			lda 	SNDPitchHigh,x
.bef3	7d 40 08	adc $0840,x			adc 	SNDAdjustHigh,x
.bef6	29 03		and #$03			and 	#3
.bef8	9d 30 08	sta $0830,x			sta 	SNDPitchHigh,x
.befb					_SNDUCUpdate:
.befb	8a		txa				txa 								; which channel.
.befc	48		pha				pha
.befd	20 c0 bd	jsr $bdc0			jsr 	SNDUpdateNote 				; update the current note
.bf00	68		pla				pla
.bf01	20 81 bd	jsr $bd81			jsr 	SNDCheckChannel 			; more to do ?
.bf04					_SNDUCExit:
.bf04	60		rts				rts

;******  Return to file: _basic.asm


;******  End of listing
