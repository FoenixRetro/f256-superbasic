
; 64tass Turbo Assembler Macro V1.57.2900 listing file
; 64tass -D AUTORUN=0 "-D MONITOR_ADDRESS=\$E000" "-D LOCKOUT_ADDRESS=\$F000" "-D BASIC_ADDRESS=\$38000" "-D SOURCE_ADDRESS=\$3000" "-D SPRITE_ADDRESS=\$30000" -q -b -Wall -c -D "HARDWARE=0 $'\x9'$'\x9'$'\x9'$'\x9'$'\x9'$'\x9'" -L output/basic.lst -l output/basic.lbl -Wall -o basic.rom _basic.asm
; Sat Nov 26 18:06:30 2022

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=0					AUTORUN=0
=$e000					 MONITOR_ADDRESS=$E000
=$f000					 LOCKOUT_ADDRESS=$F000
=$38000					 BASIC_ADDRESS=$38000
=$3000					 SOURCE_ADDRESS=$3000
=$30000					 SPRITE_ADDRESS=$30000
=0					HARDWARE=0

;******  Processing input file: _basic.asm


;******  Processing file: ./common/aa.system/01common.inc

=$30					ZeroPageMandatory = $30
=$50					ZeroPagePreference = $50
=$400					MemoryStorage = $400
=$2000					BasicStart = $2000
=$8000					BasicEnd = $8000
=$8000					CodeStart = $8000
=$1000					VariableSpace = $1000
=$2000					EndVariableSpace = $2000
=8					MathStackSize = 8
=512					BasicStackSize = 512
=3584					BasicStackBase = $1000-BasicStackSize
=80					MaxLineSize = 80

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/02macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/04data.inc

.0030					codePtr:
>0030							.fill 	4
.0034					basicStack:
>0034							.fill 	2
.0036					zTemp0:
>0036							.fill 	2
.0038					zTemp1:
>0038							.fill 	2
.003a					zTemp2:
>003a							.fill 	2
.003c					zsTemp:
>003c							.fill 	2
.003e					zaTemp:
>003e							.fill 	2
=$30					safePtr = codePtr 							; minimise direct tinkering
=$80					NSBIsNegative = $80 						; bit 7 : sign of mantissa (where numeric)
=$20					NSBIsReference = $20 						; bit 5 : is a reference
=$10					NSBIsString = $10 							; bit 4 : set if string (procedures don't go on the stack)
=$18					NSBTypeMask = $18 							; bits 4,3 : 00 int 01 float 10 string 11 procedure
=$03					NSBRefMask = $03 							; bits 0,1 : Bytes of reference, -1 (e.g. 00 = 1 byte, 11 = 4 bytes)
=$04					NSBIsArray = $04
=$00					NSTInteger = $00 							; base types for bits 3..4
=$08					NSTFloat = $08
=$10					NSTString = $10
=$18					NSTProcedure = $18
.0050					NSStatus:
>0050							.fill 	MathStackSize
.0058					NSMantissa0:
>0058							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0060					NSMantissa1:
>0060							.fill 	MathStackSize
.0068					NSMantissa2:
>0068							.fill 	MathStackSize
.0070					NSMantissa3:
>0070							.fill 	MathStackSize
.0078					NSExponent:
>0078							.fill 	MathStackSize
.0400					identStart:
>0400							.fill 	1
.0401					identTypeStart:
>0401							.fill 	1
.0402					identTypeEnd:
>0402							.fill 	1
.0403					identHash:
>0403							.fill 	1
.0404					identTypeByte:
>0404							.fill 	1	 						; (see tokenising.pdf)
.0405					encodeState:
>0405							.fill 	1
.0406					digitTemp:
>0406							.fill 	1
.0407					decimalCount:
>0407							.fill 	1
.0408					randomSeed:
>0408							.fill 	4
.040c					lowMemPtr:
>040c							.fill 	2
.040e					stringMemory:
>040e							.fill 	2
.0410					stringInitialised:
>0410							.fill 	1
.0411					stringTempPointer:
>0411							.fill 	2
.0413					breakCheck:
>0413							.fill 	1
.0414					decimalPlaces:
>0414							.fill 	1
.0415					dbOffset:
>0415							.fill 	1
.0416					lastParameter:
>0416							.fill 	1
.0417					dataPointer:
>0417							.fill 	5
.041c					inDataStatement:
>041c							.fill 	1
.041d					tbOffset:
>041d							.fill 	1
.041e					AssemblerAddress:
>041e							.fill 	2
.0420					AssemblerControl:
>0420							.fill 	1
.0421					ParamStart:
>0421							.fill 	2
.0423					IsGroup1:
>0423							.fill 	1
.0424					BaseOpcode:
>0424							.fill 	1
.0425					ModeMask:
>0425							.fill 	1
.0426					listIndent:
>0426							.fill 	1
.0427					lcLastCharacter:
>0427							.fill 	1
.0428					isInputFlag:
>0428							.fill 	1
.0429					currentListColour:
>0429							.fill 	1
.042a					tokenOffset:
>042a							.fill 	1
.042b					tokenLineNumber:
>042b							.fill 	2
.042d					tokenBuffer:
>042d							.fill 	253
.052a					lineBuffer:
>052a							.fill 	MaxLineSize+1
.057b					numberBuffer:
>057b							.fill 	34
.059d					decimalBuffer:
>059d							.fill 	16

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/constants.inc

=$80					AM_ISZP = $80
=$40					AM_ISG1 = $40
=$20					AM_ISG2 = $20
=224					AM_IMMEDIATE = AM_ISZP+AM_ISG1+AM_ISG2+$00
=228					AM_ZEROPAGE = AM_ISZP+AM_ISG1+AM_ISG2+$04
=40					AM_ACC = AM_ISG2+$08
=108					AM_ABS = AM_ISG1+AM_ISG2+$0C
=208					AM_INDY = AM_ISZP+AM_ISG1+$10
=244					AM_ZEROX = AM_ISZP+AM_ISG1+AM_ISG2+$14
=120					AM_ABSY = AM_ISG1+AM_ISG2+$18
=124					AM_ABSX = AM_ISG1+AM_ISG2+$1C
=209					AM_IND = AM_ISZP+AM_ISG1+$11
=$80					AM_ZEROY = AM_ISZP
=$01					AM_INDABS = $01
=$02					AM_INDABSX = $02
=192					AM_INDX = AM_ISZP+AM_ISG1+$00

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/handlers.inc


;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.inc

=1					ERRID_BREAK = 1
=2					ERRID_SYNTAX = 2
=3					ERRID_DIVZERO = 3
=4					ERRID_RANGE = 4
=5					ERRID_TYPE = 5
=6					ERRID_MEMORY = 6
=7					ERRID_ARGUMENT = 7
=8					ERRID_STOP = 8
=9					ERRID_STRING = 9
=10					ERRID_ASSERT = 10
=11					ERRID_DATA = 11
=12					ERRID_NOTDONE = 12
=13					ERRID_LINE = 13
=14					ERRID_GOSUB = 14
=15					ERRID_REPEAT = 15
=16					ERRID_WHILE = 16
=17					ERRID_FOR = 17
=18					ERRID_STACK = 18
=19					ERRID_STRUCT = 19
=20					ERRID_PROC = 20
=21					ERRID_REDEFINE = 21
=22					ERRID_ARRAYSIZE = 22
=23					ERRID_ARRAYIDX = 23

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst.inc

=$00					KWD_LESSLESS                         = $00; $00 <<
=$01					KWD_LESSEQUAL                        = $01; $01 <=
=$02					KWD_LESSGREATER                      = $02; $02 <>
=$03					KWD_PLINGPLING3                      = $03; $03 !!3
=$04					KWD_GREATERLESS                      = $04; $04 ><
=$05					KWD_GREATEREQUAL                     = $05; $05 >=
=$06					KWD_GREATERGREATER                   = $06; $06 >>
=$07					KWD_PLINGPLING7                      = $07; $07 !!7
=$08					KWD_PLINGPLING8                      = $08; $08 !!8
=$09					KWD_PLINGPLING9                      = $09; $09 !!9
=$0a					KWD_PLINGPLING10                     = $0a; $0a !!10
=$0b					KWD_PLINGPLING11                     = $0b; $0b !!11
=$0c					KWD_PLINGPLING12                     = $0c; $0c !!12
=$0d					KWD_PLINGPLING13                     = $0d; $0d !!13
=$0e					KWD_PLINGPLING14                     = $0e; $0e !!14
=$0f					KWD_PLINGPLING15                     = $0f; $0f !!15
=$10					KWD_AT                               = $10; $10 @
=$11					KWD_PLINGPLING17                     = $11; $11 !!17
=$12					KWD_PLINGPLING18                     = $12; $12 !!18
=$13					KWD_LSQPAREN                         = $13; $13 [
=$14					KWD_BACKSLASH                        = $14; $14 \
=$15					KWD_RSQPAREN                         = $15; $15 ]
=$16					KWD_HAT                              = $16; $16 ^
=$17					KWD_UNDERSCORE                       = $17; $17 _
=$18					KWD_BQUOTE                           = $18; $18 `
=$19					KWD_PLINGPLING25                     = $19; $19 !!25
=$1a					KWD_PLINGPLING26                     = $1a; $1a !!26
=$1b					KWD_LCURLY                           = $1b; $1b {
=$1c					KWD_BAR                              = $1c; $1c |
=$1d					KWD_RCURLY                           = $1d; $1d }
=$1e					KWD_TILDE                            = $1e; $1e ~
=$21					KWD_PLING                            = $21; $21 !
=$22					KWD_DQUOTE                           = $22; $22 "
=$23					KWD_HASH                             = $23; $23 #
=$24					KWD_DOLLAR                           = $24; $24 $
=$25					KWD_PERCENT                          = $25; $25 %
=$26					KWD_AMPERSAND                        = $26; $26 &
=$27					KWD_QUOTE                            = $27; $27 '
=$28					KWD_LPAREN                           = $28; $28 (
=$29					KWD_RPAREN                           = $29; $29 )
=$2a					KWD_STAR                             = $2a; $2a *
=$2b					KWD_PLUS                             = $2b; $2b +
=$2c					KWD_COMMA                            = $2c; $2c ,
=$2d					KWD_MINUS                            = $2d; $2d -
=$2e					KWD_PERIOD                           = $2e; $2e .
=$2f					KWD_SLASH                            = $2f; $2f /
=$30					KWD_0                                = $30; $30 0
=$31					KWD_1                                = $31; $31 1
=$32					KWD_2                                = $32; $32 2
=$33					KWD_3                                = $33; $33 3
=$34					KWD_4                                = $34; $34 4
=$35					KWD_5                                = $35; $35 5
=$36					KWD_6                                = $36; $36 6
=$37					KWD_7                                = $37; $37 7
=$38					KWD_8                                = $38; $38 8
=$39					KWD_9                                = $39; $39 9
=$3a					KWD_COLON                            = $3a; $3a :
=$3b					KWD_SEMICOLON                        = $3b; $3b ;
=$3c					KWD_LESS                             = $3c; $3c <
=$3d					KWD_EQUAL                            = $3d; $3d =
=$3e					KWD_GREATER                          = $3e; $3e >
=$3f					KWD_QMARK                            = $3f; $3f ?
=$83					KWD_ABSLPAREN                        = $83; $83 ABS(
=$84					KWD_ALLOCLPAREN                      = $84; $84 ALLOC(
=$85					KWD_ASCLPAREN                        = $85; $85 ASC(
=$86					KWD_CHRDOLLARLPAREN                  = $86; $86 CHR$(
=$87					KWD_EVENTLPAREN                      = $87; $87 EVENT(
=$88					KWD_FALSE                            = $88; $88 FALSE
=$89					KWD_FRACLPAREN                       = $89; $89 FRAC(
=$8a					KWD_HITLPAREN                        = $8a; $8a HIT(
=$8b					KWD_INTLPAREN                        = $8b; $8b INT(
=$8c					KWD_ISVALLPAREN                      = $8c; $8c ISVAL(
=$8d					KWD_JOYBLPAREN                       = $8d; $8d JOYB(
=$8e					KWD_JOYXLPAREN                       = $8e; $8e JOYX(
=$8f					KWD_JOYYLPAREN                       = $8f; $8f JOYY(
=$90					KWD_LEFTDOLLARLPAREN                 = $90; $90 LEFT$(
=$91					KWD_LENLPAREN                        = $91; $91 LEN(
=$92					KWD_MAXLPAREN                        = $92; $92 MAX(
=$93					KWD_MIDDOLLARLPAREN                  = $93; $93 MID$(
=$94					KWD_MINLPAREN                        = $94; $94 MIN(
=$95					KWD_NOTLPAREN                        = $95; $95 NOT(
=$96					KWD_PLAYINGLPAREN                    = $96; $96 PLAYING(
=$97					KWD_RANDOMLPAREN                     = $97; $97 RANDOM(
=$98					KWD_RIGHTDOLLARLPAREN                = $98; $98 RIGHT$(
=$99					KWD_RNDLPAREN                        = $99; $99 RND(
=$9a					KWD_SGNLPAREN                        = $9a; $9a SGN(
=$9b					KWD_SPCLPAREN                        = $9b; $9b SPC(
=$9c					KWD_STRDOLLARLPAREN                  = $9c; $9c STR$(
=$9d					KWD_TIMERLPAREN                      = $9d; $9d TIMER(
=$9e					KWD_TRUE                             = $9e; $9e TRUE
=$9f					KWD_VALLPAREN                        = $9f; $9f VAL(
=$a0					KWD_FOR                              = $a0; $a0 FOR
=$a1					KWD_IF                               = $a1; $a1 IF
=$a2					KWD_PROC                             = $a2; $a2 PROC
=$a3					KWD_REPEAT                           = $a3; $a3 REPEAT
=$a4					KWD_WHILE                            = $a4; $a4 WHILE
=$a5					KWD_ENDIF                            = $a5; $a5 ENDIF
=$a6					KWD_ENDPROC                          = $a6; $a6 ENDPROC
=$a7					KWD_NEXT                             = $a7; $a7 NEXT
=$a8					KWD_THEN                             = $a8; $a8 THEN
=$a9					KWD_UNTIL                            = $a9; $a9 UNTIL
=$aa					KWD_WEND                             = $aa; $aa WEND
=$ab					KWD_BY                               = $ab; $ab BY
=$ac					KWD_CALL                             = $ac; $ac CALL
=$ad					KWD_CIRCLE                           = $ad; $ad CIRCLE
=$ae					KWD_CLEAR                            = $ae; $ae CLEAR
=$af					KWD_CLS                              = $af; $af CLS
=$b0					KWD_COLOR                            = $b0; $b0 COLOR
=$b1					KWD_COLOUR                           = $b1; $b1 COLOUR
=$b2					KWD_DATA                             = $b2; $b2 DATA
=$b3					KWD_DIM                              = $b3; $b3 DIM
=$b4					KWD_DOWNTO                           = $b4; $b4 DOWNTO
=$b5					KWD_ELSE                             = $b5; $b5 ELSE
=$b6					KWD_FROM                             = $b6; $b6 FROM
=$b7					KWD_GFX                              = $b7; $b7 GFX
=$b8					KWD_GOSUB                            = $b8; $b8 GOSUB
=$b9					KWD_GOTO                             = $b9; $b9 GOTO
=$ba					KWD_HERE                             = $ba; $ba HERE
=$bb					KWD_IMAGE                            = $bb; $bb IMAGE
=$bc					KWD_INPUT                            = $bc; $bc INPUT
=$bd					KWD_LET                              = $bd; $bd LET
=$be					KWD_LINE                             = $be; $be LINE
=$bf					KWD_LOCAL                            = $bf; $bf LOCAL
=$c0					KWD_OFF                              = $c0; $c0 OFF
=$c1					KWD_ON                               = $c1; $c1 ON
=$c2					KWD_OUTLINE                          = $c2; $c2 OUTLINE
=$c3					KWD_PALETTE                          = $c3; $c3 PALETTE
=$c4					KWD_PLOT                             = $c4; $c4 PLOT
=$c5					KWD_PRINT                            = $c5; $c5 PRINT
=$c6					KWD_READ                             = $c6; $c6 READ
=$c7					KWD_RECT                             = $c7; $c7 RECT
=$c8					KWD_REM                              = $c8; $c8 REM
=$c9					KWD_RETURN                           = $c9; $c9 RETURN
=$ca					KWD_SOLID                            = $ca; $ca SOLID
=$cb					KWD_SOUND                            = $cb; $cb SOUND
=$cc					KWD_SPRITE                           = $cc; $cc SPRITE
=$cd					KWD_TEXT                             = $cd; $cd TEXT
=$ce					KWD_TO                               = $ce; $ce TO

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst0.inc

=$80					KWC_EOL = $80
=$ff					KWC_STRING = $FF
=$fe					KWC_HEXCONST = $FE
=$a0					KWC_FIRST_STRUCTURE = $a0
=$a5					KWC_FIRST_STRUCTURE_DEC = $a5
=$aa					KWC_LAST_STRUCTURE = $aa
=$83					KWC_FIRST_UNARY = $83
=$9f					KWC_LAST_UNARY = $9f

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/access.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/stack.inc

=$e0					STK_GOSUB = $E0
=$d0					STK_FOR = $D0
=$c0					STK_REPEAT = $C0
=$b0					STK_PROC = $B0
=$a0					STK_WHILE = $A0
=$01					STK_LOCALN = $01
=$02					STK_LOCALS = $02

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/00start.asm

.8000	a2 ff		ldx #$ff	Start:	ldx 	#$FF 						; stack reset
.8002	9a		txs				txs
.8003	20 99 a9	jsr $a999			jsr 	EXTInitialise 				; hardware initialise
.8006	a2 80		ldx #$80			ldx 	#(Prompt >> 8) 				; prompt display
.8008	a9 22		lda #$22			lda 	#(Prompt & $FF)
.800a	20 fd 8e	jsr $8efd			jsr 	PrintStringXA
.800d	a9 00		lda #$00			lda 	#0 							; graphics system initialise.
.800f	aa		tax				tax
.8010	a8		tay				tay
.8011	20 25 aa	jsr $aa25			jsr 	GXGraphicDraw
.8014	a9 0f		lda #$0f			lda 	#$0F 						; initialise sound system
.8016	20 09 b9	jsr $b909			jsr 	SNDCommand
.8019	20 93 89	jsr $8993			jsr 	NewProgram 					; erase current program
.801c	4c 6a 83	jmp $836a			jmp 	WarmStart					; make same size.
.801f	4c 6a 83	jmp $836a			jmp 	WarmStart
>8022	0c 2a 2a 2a 20 46 32 35		Prompt:	.text 	12,"*** F256 Junior SuperBASIC ***",13,13
>802a	36 20 4a 75 6e 69 6f 72 20 53 75 70 65 72 42 41
>803a	53 49 43 20 2a 2a 2a 0d 0d

;******  Processing file: ./common/aa.system/../generated/timestamp.asm

>8043	52 65 6c 65 61 73 65 20			.text "Release Alpha 6 (26-Nov-22). "
>804b	41 6c 70 68 61 20 36 20 28 32 36 2d 4e 6f 76 2d
>805b	32 32 29 2e 20

;******  Return to file: ./common/aa.system/00start.asm

>8060	0d 0d 00					.byte 	13,13,0

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/assembler.asm

.8063					AssembleGroup1:
.8063	a9 ff		lda #$ff			lda 	#$FF
.8065	8d 25 04	sta $0425			sta 	ModeMask 					; initialise the mode mask - all for all
.8068	80 02		bra $806c			bra 	AsmGroup12
.806a					AssembleGroup2:
.806a	a9 00		lda #$00			lda 	#$00
.806c					AsmGroup12:
.806c	8d 23 04	sta $0423			sta 	IsGroup1 					; save the 'group 1' flag
.806f	68		pla				pla 								; pop the return address to access the information following.
.8070	fa		plx				plx
.8071	20 f8 80	jsr $80f8			jsr 	AccessParameters 			; get opcode and save as base
.8074	8d 24 04	sta $0424			sta 	BaseOpcode
.8077	ad 23 04	lda $0423			lda 	IsGroup1 					; skip if group 1 as we don't have a complex mask.
.807a	d0 08		bne $8084			bne 	_AG12HaveMask
.807c	a9 02		lda #$02			lda 	#2 							; if group 2 the second parameter is the mask
.807e	20 00 81	jsr $8100			jsr 	GetParameter		 		; e.g. which modes are supported for this operand
.8081	8d 25 04	sta $0425			sta 	ModeMask
.8084					_AG12HaveMask:
.8084	20 34 82	jsr $8234			jsr 	TypeAndCalculateOperand 	; get zero page type
.8087	da		phx				phx 								; save found address mode
.8088	20 64 81	jsr $8164			jsr 	AssembleModeX
.808b	fa		plx				plx  								; restore address mode
.808c	b0 0b		bcs $8099			bcs 	_AG12Exit
.808e	20 9a 80	jsr $809a			jsr 	PromoteToAbsolute  			; promote ZP to ABS and try that
.8091	20 64 81	jsr $8164			jsr 	AssembleModeX
.8094	b0 03		bcs $8099			bcs 	_AG12Exit
.8096	4c 29 9f	jmp $9f29			jmp 	SyntaxError 				; can't do either, so must be wrong mode/operand.
.8099					_AG12Exit:
.8099	60		rts				rts
.809a					PromoteToAbsolute:
.809a	a9 6c		lda #$6c			lda 	#AM_ABS 					; lda xx
.809c	e0 e4		cpx #$e4			cpx 	#AM_ZEROPAGE
.809e	f0 19		beq $80b9			beq 	_PTADo
.80a0	a9 7c		lda #$7c			lda 	#AM_ABSX 					; lda xx,X
.80a2	e0 f4		cpx #$f4			cpx 	#AM_ZEROX
.80a4	f0 13		beq $80b9			beq 	_PTADo
.80a6	a9 78		lda #$78			lda 	#AM_ABSY 					; lda xx,Y
.80a8	e0 80		cpx #$80			cpx 	#AM_ZEROY
.80aa	f0 0d		beq $80b9			beq 	_PTADo
.80ac	a9 01		lda #$01			lda 	#AM_INDABS 					; lda (xx) (jump)
.80ae	e0 d1		cpx #$d1			cpx 	#AM_IND
.80b0	f0 07		beq $80b9			beq 	_PTADo
.80b2	a9 02		lda #$02			lda 	#AM_INDABSX 				; lda (xx,x) (jump)
.80b4	e0 c0		cpx #$c0			cpx 	#AM_INDX
.80b6	f0 01		beq $80b9			beq 	_PTADo
.80b8	60		rts				rts
.80b9					_PTADo:
.80b9	aa		tax				tax
.80ba	60		rts				rts
.80bb					AssembleGroup3:
.80bb	68		pla				pla 								; get parameters, which is just the opcode.
.80bc	fa		plx				plx
.80bd	20 f8 80	jsr $80f8			jsr 	AccessParameters 			; get and output opcode
.80c0	20 10 81	jsr $8110			jsr 	AssemblerWriteByte
.80c3	20 98 82	jsr $8298			jsr 	CalculateOperand 			; get a 16 bit operand
.80c6	a5 58		lda $58				lda 	NSMantissa0 				; calculate the offset
.80c8	38		sec				sec
.80c9	ed 1e 04	sbc $041e			sbc 	AssemblerAddress
.80cc	48		pha				pha 								; LSB in A
.80cd	a5 60		lda $60				lda 	NSMantissa1
.80cf	ed 1f 04	sbc $041f			sbc 	AssemblerAddress+1
.80d2	aa		tax				tax 								; MSB in X
.80d3	68		pla				pla
.80d4	18		clc				clc 								; $80 to easy check $80-$7F, plus 1 for offset error
.80d5	69 7f		adc #$7f			adc 	#$7F
.80d7	90 01		bcc $80da			bcc 	_AG3NoCarry
.80d9	e8		inx				inx
.80da					_AG3NoCarry:
.80da	38		sec				sec 								; fix back and write out anyways.
.80db	e9 80		sbc #$80			sbc 	#$80
.80dd	20 10 81	jsr $8110			jsr 	AssemblerWriteByte
.80e0	e0 00		cpx #$00			cpx 	#0 							; was it in range
.80e2	f0 0a		beq $80ee			beq 	_AG3Exit
.80e4	ad 20 04	lda $0420			lda 	AssemblerControl 			; are we allowing bad values ?
.80e7	29 01		and #$01			and 	#1
.80e9	f0 03		beq $80ee			beq 	_AG3Exit
.80eb	4c 2e 9f	jmp $9f2e			jmp 	RangeError 					; no, branch is out of range
.80ee					_AG3Exit:
.80ee	60		rts				rts
.80ef					AssembleGroup4:
.80ef	68		pla				pla 								; pop address
.80f0	fa		plx				plx
.80f1	20 f8 80	jsr $80f8			jsr 	AccessParameters 			; access and get first
.80f4	20 10 81	jsr $8110			jsr 	AssemblerWriteByte 			; output it.
.80f7	60		rts				rts
.80f8					AccessParameters:
.80f8	8d 21 04	sta $0421			sta 	ParamStart
.80fb	8e 22 04	stx $0422			stx 	ParamStart+1
.80fe	a9 01		lda #$01			lda 	#1
.8100					GetParameter:
.8100	5a		phy				phy
.8101	a8		tay				tay
.8102	ad 21 04	lda $0421			lda 	ParamStart
.8105	85 36		sta $36				sta 	zTemp0
.8107	ad 22 04	lda $0422			lda 	ParamStart+1
.810a	85 37		sta $37				sta 	zTemp0+1
.810c	b1 36		lda ($36),y			lda 	(zTemp0),y
.810e	7a		ply				ply
.810f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/aswrite.asm

.8110					AssemblerWriteByte:
.8110	48		pha			pha
.8111	ad 20 04	lda $0420		lda 	AssemblerControl 				; check printing bytes ?
.8114	29 02		and #$02		and 	#2
.8116	f0 1b		beq $8133		beq 	_AWBNoPrint
.8118	ad 1f 04	lda $041f		lda		AssemblerAddress+1 				; print address
.811b	20 4e 81	jsr $814e		jsr 	PrintHex
.811e	ad 1e 04	lda $041e		lda		AssemblerAddress
.8121	20 4e 81	jsr $814e		jsr 	PrintHex
.8124	a9 20		lda #$20		lda 	#' '
.8126	20 25 a7	jsr $a725		jsr 	EXTPrintCharacter
.8129	68		pla			pla 									; print byte
.812a	48		pha			pha
.812b	20 4e 81	jsr $814e		jsr 	PrintHex
.812e	a9 0d		lda #$0d		lda 	#13
.8130	20 25 a7	jsr $a725		jsr 	EXTPrintCharacter
.8133					_AWBNoPrint:
.8133	ad 1e 04	lda $041e		lda		AssemblerAddress				; copy address to zTemp0
.8136	85 36		sta $36			sta 	zTemp0
.8138	ad 1f 04	lda $041f		lda		AssemblerAddress+1
.813b	f0 0e		beq $814b		beq 	_AWBRange
.813d	85 37		sta $37			sta 	zTemp0+1
.813f	68		pla			pla 									; write byte out
.8140	92 36		sta ($36)		sta 	(zTemp0)
.8142	ee 1e 04	inc $041e		inc 	AssemblerAddress 				; bump address
.8145	d0 03		bne $814a		bne 	_AWBNoCarry
.8147	ee 1f 04	inc $041f		inc 	AssemblerAddress+1
.814a					_AWBNoCarry:
.814a	60		rts			rts
.814b					_AWBRange:
.814b	4c 2e 9f	jmp $9f2e		jmp 	RangeError
.814e					PrintHex:
.814e	48		pha				pha
.814f	4a		lsr a				lsr 	a
.8150	4a		lsr a				lsr 	a
.8151	4a		lsr a				lsr 	a
.8152	4a		lsr a				lsr 	a
.8153	20 57 81	jsr $8157			jsr 	_PrintNibble
.8156	68		pla				pla
.8157					_PrintNibble:
.8157	29 0f		and #$0f			and 	#15
.8159	c9 0a		cmp #$0a			cmp 	#10
.815b	90 02		bcc $815f			bcc 	_NoShift
.815d	69 06		adc #$06			adc 	#6
.815f					_NoShift:
.815f	69 30		adc #$30			adc 	#48
.8161	4c 25 a7	jmp $a725			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/instruction.asm

.8164					AssembleModeX:
.8164	5a		phy				phy
.8165	ad 23 04	lda $0423			lda 	IsGroup1
.8168	f0 17		beq $8181			beq 	_AMXGroup2
.816a	8a		txa				txa 							; is it in group # 1
.816b	29 40		and #$40			and 	#AM_ISG1
.816d	f0 4d		beq $81bc			beq 	_AMXFail 				; no, give up.
.816f	8a		txa				txa 							; get back.
.8170	29 1f		and #$1f			and 	#$1F 					; this is now the offset.
.8172	e0 e0		cpx #$e0			cpx 	#AM_IMMEDIATE 			; if not immediate, we can continue.
.8174	d0 22		bne $8198			bne 	_AMXHaveInfo
.8176	ad 24 04	lda $0424			lda 	BaseOpcode 				; cannot store immediate.
.8179	c9 81		cmp #$81			cmp 	#$81
.817b	f0 3f		beq $81bc			beq 	_AMXFail
.817d	a9 08		lda #$08			lda 	#8 						; if immediate we use offset 8.
.817f	80 17		bra $8198			bra 	_AMXHaveInfo 			; odd design decision there.
.8181					_AMXGroup2:
.8181	8a		txa				txa 							; is it in group 2 ?
.8182	29 20		and #$20			and 	#AM_ISG2
.8184	f0 36		beq $81bc			beq 	_AMXFail 				; no, give up.
.8186	8a		txa				txa 							; get the offset into Y
.8187	29 1f		and #$1f			and 	#$1F
.8189	4a		lsr a				lsr 	a 						; make it 0-7.
.818a	4a		lsr a				lsr  	a
.818b	a8		tay				tay
.818c	ad 25 04	lda $0425			lda 	ModeMask 				; shift the modemask left so you can check it against the requested offset
.818f					_AMXCheckOkay:
.818f	0a		asl a				asl 	a 						; shift modemask left enough times to check legitimate.
.8190	88		dey				dey
.8191	10 fc		bpl $818f			bpl 	_AMXCheckOkay
.8193	90 27		bcc $81bc			bcc 	_AMXFail 				; not allowed.
.8195	8a		txa				txa  							; get mask back
.8196	29 1f		and #$1f			and 	#$1F
.8198					_AMXHaveInfo:
.8198	e0 00		cpx #$00			cpx 	#$00 					; does it *require* an 8 bit operand
.819a	10 04		bpl $81a0			bpl 	_AMXAnySize 			; checking bit 7, the zero page opcode flag.
.819c	a4 60		ldy $60				ldy 	NSMantissa1 			; fail if it is outside range, e.g. the MSB is set.
.819e	d0 1c		bne $81bc			bne 	_AMXFail
.81a0					_AMXAnySize:
.81a0	18		clc				clc 							; add offset to the base opcode
.81a1	6d 24 04	adc $0424			adc 	BaseOpcode
.81a4					_AMXOutputCode:
.81a4	20 10 81	jsr $8110			jsr 	AssemblerWriteByte 		; write the opcode out.
.81a7	e0 28		cpx #$28			cpx 	#AM_ACC 				; A mode (e.g. ASL A)
.81a9	f0 0e		beq $81b9			beq 	_AMXExit
.81ab	a5 58		lda $58				lda 	NSMantissa0 				; write LSB operand
.81ad	20 10 81	jsr $8110			jsr 	AssemblerWriteByte
.81b0	e0 00		cpx #$00			cpx 	#$00 					; zeropage ?
.81b2	30 05		bmi $81b9			bmi 	_AMXExit
.81b4	a5 60		lda $60				lda 	NSMantissa1 			; write MSB operand
.81b6	20 10 81	jsr $8110			jsr 	AssemblerWriteByte
.81b9					_AMXExit:
.81b9	7a		ply				ply
.81ba	38		sec				sec
.81bb	60		rts				rts
.81bc					_AMXFail:
.81bc	a0 00		ldy #$00			ldy 	#0
.81be					_AMXCheckOddities:
.81be	8a		txa				txa
.81bf	d9 e6 81	cmp $81e6,y			cmp 	ExtraOpcode+2,y 		; match address mode
.81c2	d0 15		bne $81d9			bne 	_AMXCONext
.81c4	b9 e4 81	lda $81e4,y			lda 	ExtraOpcode+0,y 		; do the base opcodes match
.81c7	cd 24 04	cmp $0424			cmp 	BaseOpcode
.81ca	d0 0d		bne $81d9			bne 	_AMXCONext
.81cc	e0 00		cpx #$00			cpx 	#$00 					; requires zero page ?
.81ce	10 04		bpl $81d4			bpl 	_AMXCONotZero
.81d0	a5 60		lda $60				lda 	NSMantissa1
.81d2	d0 05		bne $81d9			bne 	_AMXCONext
.81d4					_AMXCONotZero:
.81d4	b9 e5 81	lda $81e5,y			lda 	ExtraOpcode+1,y 		; get new opcode
.81d7	80 cb		bra $81a4			bra 	_AMXOutputCode 			; and assemble it
.81d9					_AMXCONext:
.81d9	c8		iny				iny
.81da	c8		iny				iny
.81db	c8		iny				iny
.81dc	b9 e4 81	lda $81e4,y			lda 	ExtraOpcode+0,y 		; end of table
.81df	d0 dd		bne $81be			bne 	_AMXCheckOddities
.81e1					_AMXCOFail:
.81e1	7a		ply				ply
.81e2	18		clc				clc
.81e3	60		rts				rts
.81e4					ExtraOpcode:
>81e4	40 6c 01					.byte $40,$6c,AM_INDABS 	; jmp
>81e7	40 7c 02					.byte $40,$7C,AM_INDABSX 	; jmp
>81ea	a2 be 78					.byte $a2,$BE,AM_ABSY 		; ldx
>81ed	a2 b6 80					.byte $a2,$B6,AM_ZEROY 		; ldx
>81f0	82 96 80					.byte $82,$96,AM_ZEROY 		; stx
>81f3	e2 1a 28					.byte $e2,$1a,AM_ACC 		; inc
>81f6	c2 3a 28					.byte $c2,$3a,AM_ACC 		; dec
>81f9	20 89 e0					.byte $20,$89,AM_IMMEDIATE 	; bit
>81fc	60 9c 6c					.byte $60,$9c,AM_ABS 		; stz
>81ff	60 9e 7c					.byte $60,$9e,AM_ABSX 		; stz
>8202	00						.byte $00

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/label.asm

.8203					LabelHere:
.8203	c8		iny				iny 								; skip .
.8204	a2 00		ldx #$00			ldx 	#0 							; get a term
.8206	20 f2 97	jsr $97f2			jsr 	EvaluateTerm 				; get a term
.8209	a5 50		lda $50				lda 	NSStatus 					; needs to be an integer reference.
.820b	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.820d	d0 22		bne $8231			bne 	_ALType
.820f	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy reference address to zTemp0
.8211	85 36		sta $36				sta 	zTemp0
.8213	b5 60		lda $60,x			lda 	NSMantissa1,x
.8215	85 37		sta $37				sta 	zTemp0+1
.8217	5a		phy				phy 								; copy address in.
.8218	a0 01		ldy #$01			ldy 	#1
.821a	ad 1e 04	lda $041e			lda	 	AssemblerAddress
.821d	92 36		sta ($36)			sta 	(zTemp0)
.821f	ad 1f 04	lda $041f			lda	 	AssemblerAddress+1
.8222	91 36		sta ($36),y			sta 	(zTemp0),y
.8224	c8		iny				iny
.8225	a9 00		lda #$00			lda 	#0
.8227	91 36		sta ($36),y			sta 	(zTemp0),y
.8229	c8		iny				iny
.822a	91 36		sta ($36),y			sta 	(zTemp0),y
.822c	c8		iny				iny
.822d	91 36		sta ($36),y			sta 	(zTemp0),y
.822f	7a		ply				ply
.8230	60		rts				rts
.8231					_ALType:
.8231	4c 33 9f	jmp $9f33			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/operands.asm

.8234					TypeAndCalculateOperand:
.8234	b1 30		lda ($30),y			lda 	(codePtr),y
.8236	a2 28		ldx #$28			ldx 	#AM_ACC 					; ACC if : or EOL
.8238	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.823a	f0 5b		beq $8297			beq 	_TACOExit
.823c	c9 80		cmp #$80			cmp 	#KWC_EOL
.823e	f0 57		beq $8297			beq 	_TACOExit
.8240	c8		iny				iny
.8241	a2 e0		ldx #$e0			ldx 	#AM_IMMEDIATE
.8243	c9 23		cmp #$23			cmp 	#KWD_HASH 					; if hash, then immediate - constant.
.8245	f0 51		beq $8298			beq 	CalculateOperand
.8247	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; if ( then check for indirection
.8249	f0 1f		beq $826a			beq 	_TACOIndirect
.824b	88		dey				dey 								; undo get of first character
.824c	20 98 82	jsr $8298			jsr 	CalculateOperand 			; get operand
.824f	b1 30		lda ($30),y			lda 	(codePtr),y
.8251	a2 e4		ldx #$e4			ldx 	#AM_ZEROPAGE 				; if not, try zero page (then absolute)
.8253	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8255	d0 40		bne $8297			bne 	_TACOExit
.8257	c8		iny				iny
.8258	20 a2 82	jsr $82a2			jsr 	TACOCheckXY 				; extract X,Y or 0 (neither) from the variable.
.825b	a2 f4		ldx #$f4			ldx 	#AM_ZEROX 					; check for X
.825d	c9 58		cmp #$58			cmp 	#'X'
.825f	f0 36		beq $8297			beq 	_TACOExit
.8261	a2 80		ldx #$80			ldx 	#AM_ZEROY 					; check for Y
.8263	c9 59		cmp #$59			cmp 	#'Y'
.8265	f0 30		beq $8297			beq 	_TACOExit
.8267					_TACOSyntax:
.8267	4c 29 9f	jmp $9f29			jmp 	SyntaxError
.826a					_TACOIndirect:
.826a	20 98 82	jsr $8298			jsr 	CalculateOperand 			; get the operand
.826d	b1 30		lda ($30),y			lda 	(codePtr),y
.826f	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if , then it must be ,X)
.8271	f0 17		beq $828a			beq 	_TACOIndX
.8273	20 8b 8e	jsr $8e8b			jsr 	CheckRightBracket  			; otherwise must be ) or ),Y
.8276	b1 30		lda ($30),y			lda 	(codePtr),y
.8278	a2 d1		ldx #$d1			ldx 	#AM_IND
.827a	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not comma then exit with (xx)
.827c	d0 19		bne $8297			bne 	_TACOExit
.827e	c8		iny				iny
.827f	20 a2 82	jsr $82a2			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.8282	c9 59		cmp #$59			cmp 	#'Y' 						; check Y
.8284	d0 e1		bne $8267			bne 	_TACOSyntax
.8286	a2 d0		ldx #$d0			ldx 	#AM_INDY
.8288	80 0d		bra $8297			bra 	_TACOExit
.828a					_TACOIndX:
.828a	c8		iny				iny
.828b	20 a2 82	jsr $82a2			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.828e	c9 58		cmp #$58			cmp 	#'X' 						; check X
.8290	d0 d5		bne $8267			bne 	_TACOSyntax
.8292	20 8b 8e	jsr $8e8b			jsr 	CheckRightBracket			; check )
.8295	a2 c0		ldx #$c0			ldx 	#AM_INDX
.8297					_TACOExit:
.8297	60		rts				rts
.8298					CalculateOperand:
.8298	48		pha				pha
.8299	da		phx				phx
.829a	a2 00		ldx #$00			ldx 	#0 							; get 16 bit integer in Slot 0
.829c	20 31 9d	jsr $9d31			jsr 	Evaluate16BitInteger
.829f	fa		plx				plx
.82a0	68		pla				pla
.82a1	60		rts				rts
.82a2					TACOCheckXY:
.82a2	b1 30		lda ($30),y			lda 	(codePtr),y
.82a4	29 c0		and #$c0			and 	#$C0 						; check it is an identifier reference.
.82a6	c9 40		cmp #$40			cmp 	#$40
.82a8	d0 21		bne $82cb			bne 	_TCXYFail
.82aa	b1 30		lda ($30),y			lda 	(codePtr),y
.82ac	18		clc				clc
.82ad	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.82af	85 37		sta $37				sta 	zTemp0+1
.82b1	c8		iny				iny
.82b2	b1 30		lda ($30),y			lda 	(codePtr),y
.82b4	c8		iny				iny
.82b5	85 36		sta $36				sta 	zTemp0
.82b7	5a		phy				phy 								; save position
.82b8	a0 02		ldy #$02			ldy 	#2 							; type is integer ?
.82ba	b1 36		lda ($36),y			lda 	(zTemp0),y
.82bc	d0 0c		bne $82ca			bne 	_TCXYPopFail
.82be	a0 08		ldy #$08			ldy 	#8 							; get first character, should have bit 7 set as also last.
.82c0	b1 36		lda ($36),y			lda 	(zTemp0),y
.82c2	c9 d8		cmp #$d8			cmp 	#'X'+$80 					; should be X or Y
.82c4	f0 08		beq $82ce			beq 	_TCXYFound
.82c6	c9 d9		cmp #$d9			cmp 	#'Y'+$80
.82c8	f0 04		beq $82ce			beq 	_TCXYFound
.82ca					_TCXYPopFail:
.82ca	7a		ply				ply
.82cb					_TCXYFail:
.82cb	a9 00		lda #$00			lda 	#0
.82cd	60		rts				rts
.82ce					_TCXYFound:
.82ce	7a		ply				ply 								; restore position
.82cf	29 7f		and #$7f			and 	#$7F 						; throw bit 7
.82d1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/backload.asm

.82d2					BackloadProgram:
.82d2	a2 83		ldx #$83			ldx 	#_BLLoad >> 8
.82d4	a9 19		lda #$19			lda 	#_BLLoad & $FF
.82d6	20 fd 8e	jsr $8efd			jsr 	PrintStringXA
.82d9	a9 00		lda #$00			lda 	#((SOURCE_ADDRESS) & $FF)
.82db	8d ad 05	sta $05ad			sta 	0+BackLoadPointer
.82de	a9 30		lda #$30			lda 	#((SOURCE_ADDRESS) >> 8)
.82e0	8d ae 05	sta $05ae			sta 	1+BackLoadPointer
.82e3	a9 ff		lda #$ff			lda 	#$FF
.82e5	8d fa ff	sta $fffa			sta 	$FFFA
.82e8					_BPLoop:
.82e8	a2 ff		ldx #$ff			ldx 	#$FF
.82ea	20 2e 83	jsr $832e			jsr 	BLReadByte 					; read a byte
.82ed	c9 00		cmp #$00			cmp 	#0
.82ef	f0 21		beq $8312			beq 	_BPExit 					; if 0 exit
.82f1	30 1f		bmi $8312			bmi 	_BPExit 					; if -ve exit
.82f3					_BPCopy:
.82f3	e8		inx				inx  								; copy byte into the lineBuffer
.82f4	9d 2a 05	sta $052a,x			sta 	lineBuffer,x
.82f7	9e 2b 05	stz $052b,x			stz 	lineBuffer+1,x
.82fa	20 2e 83	jsr $832e			jsr 	BLReadByte 					; read next byte
.82fd	30 0a		bmi $8309			bmi 	_BPEndLine 					; -ve = EOL
.82ff	c9 09		cmp #$09			cmp 	#9 							; handle TAB, make it space.
.8301	d0 02		bne $8305			bne 	_BPNotTab
.8303	a9 20		lda #$20			lda 	#' '
.8305					_BPNotTab:
.8305	c9 20		cmp #$20			cmp 	#' ' 						; < ' ' = EOL
.8307	b0 ea		bcs $82f3			bcs 	_BPCopy 					; until a control character, should be 13 received.
.8309					_BPEndLine:
.8309	20 88 b5	jsr $b588			jsr 	TokeniseLine 				; tokenise the line.
.830c	38		sec				sec 								; append not insert
.830d	20 73 a4	jsr $a473			jsr 	MemoryInsertLine 			; append to current program
.8310	80 d6		bra $82e8			bra 	_BPLoop
.8312					_BPExit:
.8312	9c fa ff	stz $fffa			stz 	$FFFA
.8315	20 00 84	jsr $8400			jsr 	ClearCommand 				; clear variables etc.
.8318	60		rts				rts
.8319					_BLLoad:
>8319	4c 6f 61 64 69 6e 67 20				.text 	"Loading from Memory",13,0
>8321	66 72 6f 6d 20 4d 65 6d 6f 72 79 0d 00
.832e					BLReadByte:
.832e	ad ad 05	lda $05ad			lda 	BackLoadPointer 			; copy pointer to zTemp0
.8331	85 36		sta $36				sta 	zTemp0
.8333	ad ae 05	lda $05ae			lda 	BackLoadPointer+1
.8336	85 37		sta $37				sta 	zTemp0+1
.8338	b2 36		lda ($36)			lda 	(zTemp0) 					; read next byte
.833a	ee ad 05	inc $05ad			inc 	BackLoadPointer 			; bump pointer
.833d	d0 03		bne $8342			bne 	_BLNoCarry
.833f	ee ae 05	inc $05ae			inc 	BackLoadPointer+1
.8342					_BLNoCarry:
.8342	c9 00		cmp #$00			cmp 	#0
.8344	60		rts				rts
.05ad					BackLoadPointer:
>05ad							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/editor.asm

.8345					EditProgramCode:
.8345	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; find the line.
.8348	ae 2c 04	ldx $042c			ldx 	TokenLineNumber+1
.834b	20 17 a5	jsr $a517			jsr 	MemorySearch
.834e	90 05		bcc $8355			bcc 	_EPCNoDelete 				; reached the end don't delete
.8350	d0 03		bne $8355			bne 	_EPCNoDelete 				; found slot but didn't match, no delete
.8352	20 3c a4	jsr $a43c			jsr 	MemoryDeleteLine 			; delete the line
.8355					_EPCNoDelete:
.8355	ad 2d 04	lda $042d			lda 	TokenBuffer 				; buffer empty
.8358	c9 80		cmp #$80			cmp 	#KWC_EOL
.835a	f0 0d		beq $8369			beq 	_EPCNoInsert
.835c	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; find the line - it cannot exist.
.835f	ae 2c 04	ldx $042c			ldx 	TokenLineNumber+1 			; so this can't fail, it returns some point in the code.
.8362	20 17 a5	jsr $a517			jsr 	MemorySearch
.8365	18		clc				clc 								; insert at this point.
.8366	20 73 a4	jsr $a473			jsr 	MemoryInsertLine 			; insert the line
.8369					_EPCNoInsert:
.8369	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/warmstart.asm

.836a					WarmStart:
.836a	a2 ff		ldx #$ff			ldx 	#$FF
.836c	9a		txs				txs
.836d	a9 85		lda #$85			lda 	#CLICommandLine+$80 		; set console colour
.836f	20 25 a7	jsr $a725			jsr 	EXTPrintCharacter
.8372	20 b3 a8	jsr $a8b3			jsr 	EXTInputLine 				; get line to lineBuffer
.8375	20 88 b5	jsr $b588			jsr 	TokeniseLine 				; tokenise the line
.8378	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; line number ?
.837b	0d 2c 04	ora $042c			ora 	TokenLineNumber+1
.837e	d0 17		bne $8397			bne 	_WSEditCode 				; if so,edit code.
.8380	9c 2a 04	stz $042a			stz 	TokenOffset 				; zero offset, meaning it only runs one line.
.8383	a9 2a		lda #$2a			lda 	#((TokenOffset) & $FF)
.8385	85 30		sta $30				sta 	codePtr
.8387	a9 04		lda #$04			lda 	#((TokenOffset) >> 8)
.8389	85 31		sta $31				sta 	codePtr+1
.838b	ad 2d 04	lda $042d			lda 	TokenBuffer 				; nothing to run
.838e	c9 80		cmp #$80			cmp 	#KWC_EOL
.8390	f0 d8		beq $836a			beq 	WarmStart
.8392	20 e1 8a	jsr $8ae1			jsr 	RUNCodePointerLine 			; execute that line.
.8395	80 d3		bra $836a			bra 	WarmStart
.8397					_WSEditCode:
.8397	20 45 83	jsr $8345			jsr 	EditProgramCode
.839a	20 00 84	jsr $8400			jsr 	ClearCommand
.839d	80 cb		bra $836a			bra 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assemble.asm

.839f					AssembleCommand:
.839f	a2 00		ldx #$00			ldx 	#0
.83a1	20 31 9d	jsr $9d31			jsr 	Evaluate16BitInteger 		; start address
.83a4	a5 58		lda $58				lda 	NSMantissa0
.83a6	8d 1e 04	sta $041e			sta 	AssemblerAddress
.83a9	a5 60		lda $60				lda 	NSMantissa1
.83ab	8d 1f 04	sta $041f			sta 	AssemblerAddress+1
.83ae	20 93 8e	jsr $8e93			jsr 	CheckComma
.83b1	20 4c 9d	jsr $9d4c			jsr 	Evaluate8BitInteger 		; options
.83b4	a5 58		lda $58				lda 	NSMantissa0
.83b6	8d 20 04	sta $0420			sta 	AssemblerControl
.83b9	60		rts				rts
.83ba	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assert.asm

.83bb					AssertCommand:
.83bb	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.83bd	20 1e 9d	jsr $9d1e			jsr 	EvaluateInteger 			; the assert test
.83c0	20 d3 9d	jsr $9dd3			jsr 	NSMIsZero 					; exit if result is non zero.
.83c3	d0 05		bne $83ca			bne 	_ACExit
.83c5	a9 0a		lda #$0a		lda	#10
.83c7	4c a4 8e	jmp $8ea4		jmp	ErrorHandler
.83ca					_ACExit:
.83ca	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/call.asm

.83cb					CallCommand:
.83cb	a2 00		ldx #$00			ldx 	#0 							; get the routine address to level 0
.83cd	20 31 9d	jsr $9d31			jsr 	Evaluate16BitInteger
.83d0					_CCClear
.83d0	e8		inx				inx  								; clear 1,2 and 3 (for A X Y)
.83d1	20 b1 9d	jsr $9db1			jsr 	NSMSetZero 					; these are optional sequentially.
.83d4	e0 04		cpx #$04			cpx 	#4
.83d6	d0 f8		bne $83d0			bne 	_CCClear
.83d8	a2 00		ldx #$00			ldx 	#0 							; and keep trying while there are more values.
.83da					_CCCParam:
.83da	b1 30		lda ($30),y			lda 	(codePtr),y
.83dc	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.83de	d0 09		bne $83e9			bne 	_CCCRun6502
.83e0	c8		iny				iny 								; skip comma
.83e1	e8		inx				inx	 								; next level
.83e2	20 4c 9d	jsr $9d4c			jsr 	Evaluate8BitInteger 		; get A/X/Y
.83e5	e0 03		cpx #$03			cpx 	#3
.83e7	90 f1		bcc $83da			bcc 	_CCCParam 					; done all 3 ?
.83e9					_CCCRun6502:
.83e9	5a		phy				phy 								; save position
.83ea	a5 60		lda $60				lda 	NSMantissa1 				; put address in zTemp0
.83ec	85 37		sta $37				sta 	zTemp0+1
.83ee	a5 58		lda $58				lda 	NSMantissa0
.83f0	85 36		sta $36				sta 	zTemp0
.83f2	a5 59		lda $59				lda 	NSMantissa0+1 				; get registers into A X Y
.83f4	a6 5a		ldx $5a				ldx 	NSMantissa0+2
.83f6	a4 5b		ldy $5b				ldy 	NSMantissa0+3
.83f8	20 fd 83	jsr $83fd			jsr 	_CCCZTemp0 					; call zTemp0
.83fb	7a		ply				ply 								; restore position and exit
.83fc	60		rts				rts
.83fd					_CCCZTemp0:
.83fd	6c 36 00	jmp ($0036)			jmp 	(zTemp0)

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/clear.asm

.8400					ClearCommand:
.8400	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.8402	85 36		sta $36				sta 	0+zTemp0
.8404	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.8406	85 37		sta $37				sta 	1+zTemp0
.8408					_ClearZeroLoop:
.8408	b2 36		lda ($36)			lda 	(zTemp0) 					; end of variables if offset is zero.
.840a	f0 24		beq $8430			beq 	_ClearZeroEnd
.840c	a0 03		ldy #$03			ldy 	#3 							; erase the variables
.840e	a9 00		lda #$00			lda 	#0 							; set all the data to zero.
.8410					_ClearOneVariable:
.8410	91 36		sta ($36),y			sta 	(zTemp0),y
.8412	c8		iny				iny
.8413	c0 08		cpy #$08			cpy 	#8
.8415	d0 f9		bne $8410			bne 	_ClearOneVariable
.8417	a0 02		ldy #$02			ldy 	#2 							; has it been marked procedure
.8419	b1 36		lda ($36),y			lda 	(zTemp0),y
.841b	c9 18		cmp #$18			cmp 	#NSTProcedure
.841d	d0 04		bne $8423			bne 	_ClearNotProcedure
.841f	a9 04		lda #$04			lda 	#NSTInteger+NSBIsArray 		; if so set it back to an integer array
.8421	91 36		sta ($36),y			sta 	(zTemp0),y 					; will be fixed on the pre-run scan.
.8423					_ClearNotProcedure:
.8423	18		clc				clc 								; go to the next variable
.8424	b2 36		lda ($36)			lda 	(zTemp0) 					; offset to next, add to zTemp0
.8426	65 36		adc $36				adc 	zTemp0
.8428	85 36		sta $36				sta 	zTemp0
.842a	90 dc		bcc $8408			bcc 	_ClearZeroLoop
.842c	e6 37		inc $37				inc 	zTemp0+1
.842e	80 d8		bra $8408			bra 	_ClearZeroLoop
.8430					_ClearZeroEnd:
.8430	18		clc				clc
.8431	a5 36		lda $36				lda 	zTemp0
.8433	69 01		adc #$01			adc 	#1
.8435	8d 0c 04	sta $040c			sta 	lowMemPtr
.8438	a5 37		lda $37				lda 	zTemp0+1
.843a	69 00		adc #$00			adc 	#0
.843c	8d 0d 04	sta $040d			sta 	lowMemPtr+1
.843f	20 53 a6	jsr $a653			jsr 	StackReset
.8442	20 b9 a6	jsr $a6b9			jsr 	StringSystemInitialise
.8445	20 31 8d	jsr $8d31			jsr 	ProcedureScan
.8448	20 90 8a	jsr $8a90			jsr 	Command_Restore
.844b	9c 1e 04	stz $041e			stz 	AssemblerAddress
.844e	9c 1f 04	stz $041f			stz 	AssemblerAddress+1
.8451	9c 20 04	stz $0420			stz 	AssemblerControl
.8454	20 d9 99	jsr $99d9			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.8457	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/cls.asm

.8458					ClearScreen:
.8458	5a		phy				phy
.8459	a9 0c		lda #$0c			lda 	#12 						; char code 12 clears the screen.
.845b	20 25 a7	jsr $a725			jsr 	EXTPrintCharacter
.845e	7a		ply				ply
.845f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/data.asm

.8460					Command_Data:
.8460	a9 3a		lda #$3a			lda 	#KWD_COLON 					; advance to colon/EOL
.8462	a2 80		ldx #$80			ldx 	#KWC_EOL
.8464	20 83 8d	jsr $8d83			jsr 	ScanForward
.8467	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dim.asm

.8468					DimCommand:
.8468	b1 30		lda ($30),y			lda 	(codePtr),y
.846a	29 c0		and #$c0			and 	#$C0
.846c	c9 40		cmp #$40			cmp 	#$40
.846e	d0 7a		bne $84ea			bne 	_DCSyntax
.8470	b1 30		lda ($30),y			lda 	(codePtr),y
.8472	18		clc				clc
.8473	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8475	85 3f		sta $3f				sta 	zaTemp+1
.8477	c8		iny				iny
.8478	b1 30		lda ($30),y			lda 	(codePtr),y
.847a	c8		iny				iny
.847b	85 3e		sta $3e				sta 	zaTemp
.847d	5a		phy				phy
.847e	a0 02		ldy #$02			ldy 	#2 						; read type byte
.8480	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8482	29 18		and #$18			and 	#NSBTypeMask 			; check it's not a procedure
.8484	c9 18		cmp #$18			cmp 	#NSTProcedure
.8486	f0 62		beq $84ea			beq 	_DCSyntax
.8488	b1 3e		lda ($3e),y			lda 	(zaTemp),y 				; check it's an array
.848a	29 04		and #$04			and 	#NSBIsArray
.848c	f0 64		beq $84f2			beq 	_DCType
.848e	a0 04		ldy #$04			ldy 	#4 						; check not already defined
.8490	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8492	d0 59		bne $84ed			bne 	_DCRedefine
.8494	7a		ply				ply
.8495	20 f5 84	jsr $84f5			jsr 	_DCGetSize 				; get array size, check it.
.8498	5a		phy				phy
.8499	a0 05		ldy #$05			ldy 	#5 						; store in first array size slot
.849b	91 3e		sta ($3e),y			sta 	(zaTemp),y 				; second will be zero.
.849d	7a		ply				ply 							; is there a second (e.g. ,x)
.849e	b1 30		lda ($30),y			lda 	(codePtr),y
.84a0	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.84a2	d0 0a		bne $84ae			bne 	_DCOneDimension
.84a4	c8		iny				iny 							; skip comma
.84a5	20 f5 84	jsr $84f5			jsr 	_DCGetSize 				; get 2nd array size
.84a8	5a		phy				phy
.84a9	a0 06		ldy #$06			ldy 	#6 						; store in 2nd array size
.84ab	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84ad	7a		ply				ply
.84ae					_DCOneDimension:
.84ae	5a		phy				phy 							; save position
.84af	a0 05		ldy #$05			ldy 	#5 						; dimensions + 1 in AX (as zero based)
.84b1	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84b3	aa		tax				tax
.84b4	c8		iny				iny
.84b5	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84b7	e8		inx				inx 							; bump them.
.84b8	1a		inc a				inc 	a
.84b9	20 5c 9d	jsr $9d5c			jsr 	Multiply8x8 			; work out the total number of elements -> zTemp0
.84bc	a5 37		lda $37				lda 	zTemp0+1 				; don't allow more than 8192 elements whatever
.84be	29 e0		and #$e0			and 	#$E0
.84c0	d0 23		bne $84e5			bne 	_DCSize
.84c2	a0 02		ldy #$02			ldy 	#2 						; get base type
.84c4	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84c6	20 03 85	jsr $8503			jsr 	ScaleByBaseType 		; scale by base type
.84c9	a5 36		lda $36				lda 	zTemp0
.84cb	a6 37		ldx $37				ldx 	zTemp0+1
.84cd	20 9b 99	jsr $999b			jsr 	AllocateXABytes 		; allocate memory
.84d0	a0 03		ldy #$03			ldy 	#3 						; copy into the address.
.84d2	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84d4	c8		iny				iny
.84d5	8a		txa				txa
.84d6	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84d8	7a		ply				ply 							; get position back
.84d9	20 8b 8e	jsr $8e8b			jsr 	CheckRightBracket 		; check )
.84dc	b1 30		lda ($30),y			lda 	(codePtr),y
.84de	c8		iny				iny 							; consume in case
.84df	c9 2c		cmp #$2c			cmp 	#KWD_COMMA		 		; if so do another DIM.
.84e1	f0 85		beq $8468			beq 	DimCommand
.84e3	88		dey				dey 							; undo consume
.84e4	60		rts				rts
.84e5					_DCSize:
.84e5	a9 16		lda #$16		lda	#22
.84e7	4c a4 8e	jmp $8ea4		jmp	ErrorHandler
.84ea					_DCSyntax:
.84ea	4c 29 9f	jmp $9f29			jmp 	SyntaxError
.84ed					_DCRedefine:
.84ed	a9 15		lda #$15		lda	#21
.84ef	4c a4 8e	jmp $8ea4		jmp	ErrorHandler
.84f2					_DCType:
.84f2	4c 33 9f	jmp $9f33			jmp 	TypeError
.84f5					_DCGetSize:
.84f5	a2 00		ldx #$00			ldx 	#0 						; get first index.
.84f7	20 4c 9d	jsr $9d4c			jsr 	Evaluate8BitInteger 	; get array dimension
.84fa	c9 00		cmp #$00			cmp 	#0 						; must be 1-254
.84fc	f0 e7		beq $84e5			beq 	_DCSize
.84fe	c9 fe		cmp #$fe			cmp 	#254
.8500	f0 e3		beq $84e5			beq 	_DCSize
.8502	60		rts				rts
.8503					ScaleByBaseType:
.8503	29 10		and #$10			and 	#NSBIsString 			; is it string
.8505	d0 19		bne $8520			bne 	_SBBTString
.8507	a5 37		lda $37				lda 	zTemp0+1 				; push value on stack
.8509	48		pha				pha
.850a	a5 36		lda $36				lda 	zTemp0
.850c	48		pha				pha
.850d	06 36		asl $36				asl 	zTemp0 					; x 2
.850f	26 37		rol $37				rol 	zTemp0+1
.8511	06 36		asl $36				asl 	zTemp0 					; x 4
.8513	26 37		rol $37				rol 	zTemp0+1
.8515	68		pla				pla 							; add stacked value = x 5
.8516	65 36		adc $36				adc 	zTemp0
.8518	85 36		sta $36				sta 	zTemp0
.851a	68		pla				pla
.851b	65 37		adc $37				adc 	zTemp0+1
.851d	85 37		sta $37				sta 	zTemp0+1
.851f	60		rts				rts
.8520					_SBBTString:
.8520	06 36		asl $36				asl 	zTemp0
.8522	26 37		rol $37				rol 	zTemp0+1
.8524	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/end.asm

.8525					EndCommand:
.8525	4c 6a 83	jmp $836a			jmp 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/for.asm

.8528					ForCommand:
.8528	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; allocate 18 bytes on the return stack.
.852a	20 ee a5	jsr $a5ee			jsr 	StackOpen
.852d	a2 00		ldx #$00			ldx 	#0
.852f	20 f2 97	jsr $97f2			jsr 	EvaluateTerm
.8532	b5 50		lda $50,x			lda 	NSStatus,x
.8534	c9 20		cmp #$20			cmp 	#NSBIsReference+NSTInteger 	; do we have an integer 4 byte reference.
.8536	d0 47		bne $857f			bne		_FCError
.8538	a9 3d		lda #$3d			lda 	#KWD_EQUAL 					; =
.853a	20 9b 8e	jsr $8e9b			jsr 	CheckNextA
.853d	e8		inx				inx
.853e	20 1e 9d	jsr $9d1e			jsr 	EvaluateInteger 			; <from> in +1
.8541	b1 30		lda ($30),y			lda 	(codePtr),y
.8543	c8		iny				iny 								; consume it
.8544	48		pha				pha 								; save on stack for later
.8545	c9 b4		cmp #$b4			cmp 	#KWD_DOWNTO
.8547	f0 04		beq $854d			beq 	_FCNoSyntax
.8549	c9 ce		cmp #$ce			cmp 	#KWD_TO
.854b	d0 35		bne $8582			bne 	_FCSyntaxError
.854d					_FCNoSyntax:
.854d	e8		inx				inx
.854e	20 1e 9d	jsr $9d1e			jsr 	EvaluateInteger
.8551	20 32 a6	jsr $a632			jsr 	STKSaveCodePosition 		; save loop back position
.8554	68		pla				pla 								; restore DOWNTO or TO
.8555	5a		phy				phy 								; save Y on the stack
.8556	49 b4		eor #$b4			eor 	#KWD_DOWNTO 				; 0 if DOWNTO, #0 if TO
.8558	f0 02		beq $855c			beq 	_FCNotDownTo
.855a	a9 02		lda #$02			lda 	#2
.855c					_FCNotDownTo:
.855c	3a		dec a				dec 	a 							; 255 if DOWNTO, 1 if TO
.855d	a0 10		ldy #$10			ldy 	#16
.855f	91 34		sta ($34),y			sta 	(basicStack),y 				; copy that out to the Basic Stack.
.8561	a0 06		ldy #$06			ldy 	#6
.8563	a5 58		lda $58				lda 	NSMantissa0
.8565	91 34		sta ($34),y			sta 	(basicStack),y
.8567	a5 60		lda $60				lda 	NSMantissa1
.8569	c8		iny				iny
.856a	91 34		sta ($34),y			sta 	(basicStack),y
.856c	a0 08		ldy #$08			ldy 	#8 							; set initial index value
.856e	a2 01		ldx #$01			ldx 	#1
.8570	20 85 85	jsr $8585			jsr 	FCIntegerToStack
.8573	a0 0c		ldy #$0c			ldy 	#12 						; set the terminal value
.8575	a2 02		ldx #$02			ldx 	#2
.8577	20 85 85	jsr $8585			jsr 	FCIntegerToStack
.857a	20 a0 85	jsr $85a0			jsr 	CopyIndexToReference
.857d	7a		ply				ply 								; restore position
.857e	60		rts				rts
.857f					_FCError:
.857f	4c 33 9f	jmp $9f33			jmp 	TypeError
.8582					_FCSyntaxError:
.8582	4c 29 9f	jmp $9f29			jmp 	SyntaxError
.8585					FCIntegerToStack:
.8585	34 50		bit $50,x			bit 	NSStatus,x 					; is the value negative
.8587	10 03		bpl $858c			bpl	 	_FCNotNegative
.8589	20 7a 9d	jsr $9d7a			jsr 	NSMNegateMantissa 			; if so 2's complement the mantissa
.858c					_FCNotNegative:
.858c	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy out to the basic stack
.858e	91 34		sta ($34),y			sta 	(basicStack),y
.8590	c8		iny				iny
.8591	b5 60		lda $60,x			lda 	NSMantissa1,x
.8593	91 34		sta ($34),y			sta 	(basicStack),y
.8595	c8		iny				iny
.8596	b5 68		lda $68,x			lda 	NSMantissa2,x
.8598	91 34		sta ($34),y			sta 	(basicStack),y
.859a	c8		iny				iny
.859b	b5 70		lda $70,x			lda 	NSMantissa3,x
.859d	91 34		sta ($34),y			sta 	(basicStack),y
.859f	60		rts				rts
.85a0					CopyIndexToReference:
.85a0	5a		phy				phy
.85a1	a0 06		ldy #$06			ldy 	#6 							; copy address-8 to write to zTemp0
.85a3	38		sec				sec 								; (because we copy from offset 8)
.85a4	b1 34		lda ($34),y			lda 	(basicStack),y
.85a6	e9 08		sbc #$08			sbc 	#8
.85a8	85 36		sta $36				sta 	zTemp0
.85aa	c8		iny				iny
.85ab	b1 34		lda ($34),y			lda 	(basicStack),y
.85ad	e9 00		sbc #$00			sbc 	#0
.85af	85 37		sta $37				sta 	zTemp0+1
.85b1	a2 04		ldx #$04			ldx 	#4 							; this is the copy counter/
.85b3	a0 0b		ldy #$0b			ldy 	#8+3 		 				; the MSB of the mantissa
.85b5	b1 34		lda ($34),y			lda 	(basicStack),y
.85b7	0a		asl a				asl 	a 							; into carry
.85b8	a0 08		ldy #$08			ldy 	#8 							; where to copy from.
.85ba	90 14		bcc $85d0			bcc 	_CITRNormal
.85bc	38		sec				sec
.85bd					_CITRNegative:
.85bd	a9 00		lda #$00			lda 	#0
.85bf	f1 34		sbc ($34),y			sbc 	(basicStack),y
.85c1	91 36		sta ($36),y			sta 	(zTemp0),y
.85c3	c8		iny				iny
.85c4	ca		dex				dex
.85c5	d0 f6		bne $85bd			bne 	_CITRNegative
.85c7	88		dey				dey 								; look at MSB of mantissa
.85c8	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set the MSB as negative packed.
.85ca	09 80		ora #$80			ora 	#$80
.85cc	91 36		sta ($36),y			sta 	(zTemp0),y
.85ce	7a		ply				ply
.85cf	60		rts				rts
.85d0					_CITRNormal:
.85d0	b1 34		lda ($34),y			lda 	(basicStack),y 				; copy without negation.
.85d2	91 36		sta ($36),y			sta 	(zTemp0),y
.85d4	c8		iny				iny
.85d5	ca		dex				dex
.85d6	d0 f8		bne $85d0			bne 	_CITRNormal
.85d8	7a		ply				ply 								; and exit.
.85d9	60		rts				rts
.85da					NextCommand:
.85da	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; check FOR is TOS
.85dc	a2 11		ldx #$11			ldx 	#ERRID_FOR 					; this error
.85de	20 1a a6	jsr $a61a			jsr 	StackCheckFrame
.85e1	5a		phy				phy
.85e2	a0 10		ldy #$10			ldy 	#16 						; get the step count
.85e4	b1 34		lda ($34),y			lda 	(basicStack),y
.85e6	85 36		sta $36				sta 	zTemp0 						; this is the sign extend
.85e8	30 02		bmi $85ec			bmi 	_NCStepNeg
.85ea	64 36		stz $36				stz 	zTemp0 						; which is 0 or 255
.85ec					_NCStepNeg:
.85ec	a0 08		ldy #$08			ldy 	#8 							; offset to bump
.85ee	a2 04		ldx #$04			ldx 	#4 							; count to bump
.85f0	18		clc				clc
.85f1					_NCBump:
.85f1	71 34		adc ($34),y			adc 	(basicStack),y 				; add it
.85f3	91 34		sta ($34),y			sta 	(basicStack),y
.85f5	a5 36		lda $36				lda 	zTemp0 						; get sign extend for next time.
.85f7	c8		iny				iny 								; next byte
.85f8	ca		dex				dex 								; do four times
.85f9	d0 f6		bne $85f1			bne 	_NCBump
.85fb	20 a0 85	jsr $85a0			jsr		CopyIndexToReference		; copy it to the reference variable.
.85fe	a0 10		ldy #$10			ldy 	#16 						; get step count again
.8600	b1 34		lda ($34),y			lda 	(basicStack),y
.8602	0a		asl a				asl 	a 							; sign bit to carry
.8603	a9 0c		lda #$0c			lda 	#12 						; offset of LHS = terminal offset
.8605	85 38		sta $38				sta 	zTemp1
.8607	90 02		bcc $860b			bcc 	_NCCompRev 					; use if step is +ve
.8609	a9 08		lda #$08			lda 	#8 							; now the LHS = index value
.860b					_NCCompRev:
.860b	85 38		sta $38				sta 	zTemp1 						; so zTemp0 is the index for LHS
.860d	49 04		eor #$04			eor 	#(8^12) 					; and zTemp0+1 is the index for RHS
.860f	85 39		sta $39				sta 	zTemp1+1
.8611	a2 04		ldx #$04			ldx 	#4 							; bytes to compare
.8613	38		sec				sec
.8614					_NCCompare:
.8614	a4 38		ldy $38				ldy 	zTemp1 						; do compare using the two indices
.8616	b1 34		lda ($34),y			lda 	(basicStack),y
.8618	a4 39		ldy $39				ldy 	zTemp1+1
.861a	f1 34		sbc ($34),y			sbc 	(basicStack),y
.861c	e6 38		inc $38				inc 	zTemp1 						; bump the indices (inc,dex do not change C or V)
.861e	e6 39		inc $39				inc 	zTemp1+1
.8620	ca		dex				dex 								; do it 4 times.
.8621	d0 f1		bne $8614			bne 	_NCCompare
.8623	50 02		bvc $8627			bvc 	_NCNoOverflow 				; convert to signed comparison
.8625	49 80		eor #$80			eor 	#$80
.8627					_NCNoOverflow:
.8627	7a		ply				ply 								; restore Y position
.8628	0a		asl a				asl 	a 							; is bit 7 set.
.8629	90 04		bcc $862f			bcc 	_NCLoopback 				; if no , >= so loop back
.862b	20 0c a6	jsr $a60c			jsr 	StackClose 					; exit the loop
.862e	60		rts				rts
.862f					_NCLoopBack:
.862f	20 43 a6	jsr $a643			jsr 	STKLoadCodePosition 		; loop back
.8632	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/gosub.asm

.8633					Command_GOSUB:
.8633	a2 00		ldx #$00			ldx 	#0
.8635	20 31 9d	jsr $9d31			jsr 	Evaluate16BitInteger 		; line number in Stack.0
.8638	a9 e3		lda #$e3			lda 	#STK_GOSUB+3
.863a	20 ee a5	jsr $a5ee			jsr 	StackOpen 					; create frame
.863d	20 32 a6	jsr $a632			jsr 	STKSaveCodePosition 		; save current position
.8640	4c 56 86	jmp $8656			jmp 	GotoStackX
.8643					Command_RETURN:
.8643	a9 e0		lda #$e0			lda 	#STK_GOSUB 					; check TOS is this
.8645	a2 0e		ldx #$0e			ldx 	#ERRID_GOSUB 				; this error
.8647	20 1a a6	jsr $a61a			jsr 	StackCheckFrame
.864a	20 43 a6	jsr $a643			jsr 	STKLoadCodePosition 		; restore code position
.864d	20 0c a6	jsr $a60c			jsr 	StackClose
.8650	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/goto.asm

.8651					GotoCommand:
.8651	a2 00		ldx #$00			ldx 	#0 							; GOTO where
.8653	20 31 9d	jsr $9d31			jsr 	Evaluate16BitInteger
.8656					GotoStackX:
.8656	b5 60		lda $60,x			lda  	NSMantissa1,x 				; put line # in XA. I'll keep this even though
.8658	48		pha				pha 								; it is slightly inefficient, just in cases.
.8659	b5 58		lda $58,x			lda 	NSMantissa0,x
.865b	fa		plx				plx
.865c	20 17 a5	jsr $a517			jsr 	MemorySearch 				; transfer to line number AX.
.865f	90 05		bcc $8666			bcc 	_GotoError 					; not found, off end.
.8661	d0 03		bne $8666			bne 	_GotoError 					; not found exactly
.8663	4c da 8a	jmp $8ada			jmp 	RunNewLine 					; and go straight to new line code.
.8666					_GotoError:
.8666	a9 0d		lda #$0d		lda	#13
.8668	4c a4 8e	jmp $8ea4		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/if.asm

.866b					IfCommand:
.866b	a2 00		ldx #$00			ldx 	#0 							; If what.
.866d	20 ff 9c	jsr $9cff			jsr 	EvaluateNumber
.8670	b1 30		lda ($30),y			lda 	(codePtr),y
.8672	c9 a8		cmp #$a8			cmp 	#KWD_THEN  					; could be THEN <stuff> or GOTO
.8674	d0 0a		bne $8680			bne 	_IFStructured
.8676	c8		iny				iny 								; consume THEN
.8677	20 d3 9d	jsr $9dd3			jsr 	NSMIsZero 					; is it zero
.867a	f0 01		beq $867d			beq 	_IfFail 					; if fail, go to next line
.867c	60		rts				rts 								; if THEN just continue
.867d					_IfFail:
.867d	4c c2 8a	jmp $8ac2			jmp 	EOLCommand
.8680					_IfStructured:
.8680	20 d3 9d	jsr $9dd3			jsr 	NSMIsZero 					; is it zero
.8683	d0 07		bne $868c			bne 	_IfExit 					; if not, then continue normally.
.8685	a9 b5		lda #$b5			lda 	#KWD_ELSE 					; look for else/endif
.8687	a2 a5		ldx #$a5			ldx 	#KWD_ENDIF
.8689	20 83 8d	jsr $8d83			jsr 	ScanForward 				; and run from there/
.868c					_IfExit:
.868c	60		rts				rts
.868d					ElseCode:
.868d	a9 a5		lda #$a5			lda 	#KWD_ENDIF 					; else is only run after the if clause succeeds
.868f	aa		tax				tax 								; so just go to the structure exit
.8690	20 83 8d	jsr $8d83			jsr 	ScanForward
.8693	60		rts				rts
.8694					EndIf:
.8694	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/inputprint.asm

.8695					Command_Input:
.8695	a9 ff		lda #$ff			lda 	#$FF
.8697	8d 28 04	sta $0428			sta 	IsInputFlag
.869a	80 03		bra $869f			bra 	Command_IP_Main
.869c					Command_Print:
.869c	9c 28 04	stz $0428			stz 	IsInputFlag
.869f					Command_IP_Main:
.869f	18		clc				clc 								; carry being clear means last print wasn't comma/semicolon
.86a0					_CPLoop:
.86a0	08		php				php 								; save last action flag
.86a1	b1 30		lda ($30),y			lda 	(codePtr),y
.86a3	c9 80		cmp #$80			cmp  	#KWC_EOL 					; end of line or colon, exit now.
.86a5	f0 54		beq $86fb			beq 	_CPExit
.86a7	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.86a9	f0 50		beq $86fb			beq 	_CPExit
.86ab	68		pla				pla 								; throw last action flag
.86ac	b1 30		lda ($30),y			lda 	(codePtr),y
.86ae	c8		iny				iny
.86af	c9 3b		cmp #$3b			cmp 	#KWD_SEMICOLON				; is it a semicolon
.86b1	f0 45		beq $86f8			beq 	_CPContinueWithSameLine
.86b3	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; comma
.86b5	f0 3c		beq $86f3			beq 	_CPTab
.86b7	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; apostrophe (new line)
.86b9	f0 34		beq $86ef			beq 	_CPNewLine
.86bb	88		dey				dey 								; undo the get.
.86bc	20 a6 93	jsr $93a6			jsr 	EvaluateExpressionAt0 		; evaluate expression at 0.
.86bf	b5 50		lda $50,x			lda 	NSStatus,x 					; read the status
.86c1	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.86c3	f0 0d		beq $86d2			beq 	_CPIsValue
.86c5	ad 28 04	lda $0428			lda 	IsInputFlag 				; if print, dereference and print.
.86c8	f0 05		beq $86cf			beq 	_CPIsPrint
.86ca	20 04 87	jsr $8704			jsr 	CIInputValue 				; input a value to the reference
.86cd	80 20		bra $86ef			bra 	_CPNewLine
.86cf					_CPIsPrint:
.86cf	20 6b 96	jsr $966b			jsr 	Dereference
.86d2					_CPIsValue:
.86d2	b5 50		lda $50,x			lda 	NSStatus,x 					; is it a number
.86d4	29 10		and #$10			and 	#NSBIsString
.86d6	f0 09		beq $86e1			beq 	_CPNumber
.86d8	a6 60		ldx $60				ldx 	NSMantissa1 				; string, print the text.
.86da	a5 58		lda $58				lda 	NSMantissa0
.86dc	20 67 87	jsr $8767			jsr 	CPPrintStringXA
.86df	80 be		bra $869f			bra 	Command_IP_Main 			; loop round clearing carry so NL if end
.86e1					_CPNumber:
.86e1	a9 05		lda #$05			lda 	#5 							; maximum decimals
.86e3	20 e6 9b	jsr $9be6			jsr 	ConvertNumberToString 		; convert to string
.86e6	a2 05		ldx #$05			ldx 	#DecimalBuffer >> 8
.86e8	a9 9d		lda #$9d			lda 	#DecimalBuffer & $FF
.86ea	20 67 87	jsr $8767			jsr 	CPPrintStringXA
.86ed	80 b0		bra $869f			bra 	Command_IP_Main				; loop round clearing carry so NL if end
.86ef					_CPNewLine:
.86ef	a9 0d		lda #$0d			lda 	#13
.86f1	80 02		bra $86f5			bra 	_CPPrintChar
.86f3					_CPTab:
.86f3	a9 09		lda #$09			lda 	#9 							; print TAB
.86f5					_CPPrintChar:
.86f5	20 7a 87	jsr $877a			jsr 	CPPrintVector
.86f8					_CPContinueWithSameLine:
.86f8	38		sec				sec 								; loop round with carry set, which
.86f9	80 a5		bra $86a0			bra 	_CPLoop 					; will inhibit final CR
.86fb					_CPExit:
.86fb	28		plp				plp 								; get last action flag
.86fc	b0 05		bcs $8703			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.86fe	a9 0d		lda #$0d			lda 	#13 						; print new line
.8700	20 7a 87	jsr $877a			jsr 	CPPrintVector
.8703					_CPExit2:
.8703	60		rts				rts
.8704					CIInputValue:
.8704	a2 00		ldx #$00			ldx 	#0 							; input a line.
.8706					_CIInputLine:
.8706	20 7d 87	jsr $877d			jsr 	CPInputVector 				; get key
.8709	c9 0d		cmp #$0d			cmp 	#13 						; 13 = End
.870b	f0 1f		beq $872c			beq 	_CIHaveValue
.870d	c9 08		cmp #$08			cmp 	#8 							; 8 = BS
.870f	f0 11		beq $8722			beq 	_CIBackspace
.8711	c9 20		cmp #$20			cmp 	#32 						; ignore other control characters
.8713	90 f1		bcc $8706			bcc 	_CIInputLine
.8715	e0 50		cpx #$50			cpx 	#80 						; max length
.8717	b0 ed		bcs $8706			bcs 	_CIInputLine
.8719	9d 2a 05	sta $052a,x			sta 	lineBuffer,x
.871c	e8		inx				inx
.871d	20 7a 87	jsr $877a			jsr 	CPPrintVector 				; echo it.
.8720	80 e4		bra $8706			bra 	_CIInputLine
.8722					_CIBackSpace:
.8722	e0 00		cpx #$00			cpx 	#0 							; nothing to delete
.8724	f0 e0		beq $8706			beq 	_CIInputLine
.8726	20 7a 87	jsr $877a			jsr 	CPPrintVector 				; echo it.
.8729	ca		dex				dex
.872a	80 da		bra $8706			bra 	_CIInputLine
.872c					_CIHaveValue:
.872c	9e 2a 05	stz $052a,x			stz 	LineBuffer,x 				; ASCIIZ string now in line buffer.
.872f	a5 50		lda $50				lda 	NSStatus 					; was it a string assignment
.8731	29 10		and #$10			and 	#NSBIsString
.8733	f0 17		beq $874c			beq 	_CIAssignNumber 			; assign a number
.8735	a2 01		ldx #$01			ldx 	#1
.8737	a9 2a		lda #$2a			lda 	#lineBuffer & $FF 			; set up to point to new string
.8739	95 58		sta $58,x			sta 	NSMantissa0,x
.873b	a9 05		lda #$05			lda 	#lineBuffer >> 8
.873d	95 60		sta $60,x			sta 	NSMantissa1,x
.873f	74 68		stz $68,x			stz 	NSMantissa2,x
.8741	74 70		stz $70,x			stz 	NSMantissa3,x
.8743	a9 10		lda #$10			lda 	#NSBIsString 				; so it becomes a string value
.8745	95 50		sta $50,x			sta  	NSStatus,x
.8747	ca		dex				dex 								; X = 0
.8748	20 b9 87	jsr $87b9			jsr 	AssignVariable
.874b	60		rts				rts
.874c					_CIAssignNumber:
.874c	a9 2a		lda #$2a			lda 	#lineBuffer & $FF 			; set up to point to new string
.874e	85 36		sta $36				sta 	zTemp0
.8750	a9 05		lda #$05			lda 	#lineBuffer >> 8
.8752	85 37		sta $37				sta 	zTemp0+1
.8754	a2 01		ldx #$01			ldx 	#1 							; put in slot 1
.8756	20 68 9b	jsr $9b68			jsr 	ValEvaluateZTemp0 			; use the VAL() code
.8759	90 07		bcc $8762			bcc 	_CIIsOkay
.875b	a9 3f		lda #$3f			lda 	#"?" 						; error ?
.875d	20 7a 87	jsr $877a			jsr 	CPPrintVector
.8760	80 a2		bra $8704			bra 	CIInputValue
.8762					_CIIsOkay:
.8762	ca		dex				dex 								; X = 0
.8763	20 b9 87	jsr $87b9			jsr 	AssignVariable
.8766	60		rts				rts
.8767					CPPrintStringXA:
.8767	5a		phy				phy
.8768	86 37		stx $37				stx 	zTemp0+1
.876a	85 36		sta $36				sta 	zTemp0
.876c	a0 00		ldy #$00			ldy 	#0
.876e					_PSXALoop:
.876e	b1 36		lda ($36),y			lda 	(zTemp0),y
.8770	f0 06		beq $8778			beq 	_PSXAExit
.8772	20 7a 87	jsr $877a			jsr 	CPPrintVector
.8775	c8		iny				iny
.8776	80 f6		bra $876e			bra 	_PSXALoop
.8778					_PSXAExit:
.8778	7a		ply				ply
.8779	60		rts				rts
.877a					CPPrintVector:
.877a	4c 25 a7	jmp $a725			jmp 	EXTPrintCharacter
.877d					CPInputVector:
.877d	4c bb a9	jmp $a9bb			jmp 	EXTInputSingleCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/let.asm

.8780					LetCommand:
.8780	a2 00		ldx #$00			ldx 	#0
.8782	b1 30		lda ($30),y			lda 	(codePtr),y
.8784	c9 10		cmp #$10			cmp 	#KWD_AT
.8786	d0 14		bne $879c			bne 	_LCStandard
.8788	c8		iny				iny 								; skip equal
.8789	20 f2 97	jsr $97f2			jsr 	EvaluateTerm 				; get a number
.878c	20 6b 96	jsr $966b			jsr 	Dereference 				; dereference it
.878f	b5 50		lda $50,x			lda 	NSStatus,x 					; check integer
.8791	49 20		eor #$20			eor 	#NSBIsReference	 			; toggle reference
.8793	95 50		sta $50,x			sta 	NSStatus,x
.8795	29 20		and #$20			and 	#NSBIsReference 			; if it is now a reference, continue
.8797	d0 0f		bne $87a8			bne 	_LCMain
.8799	4c 33 9f	jmp $9f33			jmp 	TypeError 					; was a reference before.
.879c					_LCStandard:
.879c	ad 90 93	lda $9390			lda 	PrecedenceLevel+"*"			; precedence > this
.879f	20 aa 93	jsr $93aa			jsr 	EvaluateExpressionAtPrecedence
.87a2	b5 50		lda $50,x			lda 	NSStatus,x 					; is it a reference to an array
.87a4	c9 38		cmp #$38			cmp		#NSTProcedure+NSBIsReference
.87a6	f0 0e		beq $87b6			beq 	_LetGoProc 					; it's a procedure call.
.87a8					_LCMain:
.87a8	a9 3d		lda #$3d			lda 	#"=" 						; check =
.87aa	20 9b 8e	jsr $8e9b			jsr 	CheckNextA
.87ad	e8		inx				inx 								; RHS
.87ae	20 f6 9c	jsr $9cf6			jsr 	EvaluateValue
.87b1	ca		dex				dex
.87b2	20 b9 87	jsr $87b9			jsr 	AssignVariable
.87b5	60		rts				rts
.87b6					_LetGoProc:
.87b6	4c 9d 89	jmp $899d			jmp 	CallProcedure
.87b9					AssignVariable:
.87b9	b5 50		lda $50,x			lda 	NSStatus,x 					; check the string/number type bits match
.87bb	48		pha				pha 								; save a copy
.87bc	55 51		eor $51,x			eor 	NSStatus+1,x
.87be	29 10		and #$10			and 	#NSBIsString
.87c0	d0 0b		bne $87cd			bne 	_ASError
.87c2	68		pla				pla 								; get back
.87c3	29 10		and #$10			and 	#NSBIsString 				; check type
.87c5	d0 03		bne $87ca			bne 	_ASString
.87c7	4c a9 95	jmp $95a9			jmp 	AssignNumber
.87ca					_ASString:
.87ca	4c 07 96	jmp $9607			jmp 	AssignString
.87cd					_ASError:
.87cd	4c 33 9f	jmp $9f33			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/list.asm

.87d0					Command_List:
.87d0	9c 26 04	stz $0426			stz 	listIndent 					; reset indent.
.87d3	b1 30		lda ($30),y			lda 	(codePtr),y
.87d5	29 c0		and #$c0			and 	#$C0
.87d7	c9 40		cmp #$40			cmp 	#$40
.87d9	f0 69		beq $8844			beq 	_CLListProcedure
.87db	64 5c		stz $5c				stz		NSMantissa0+4				; set the lower (slot 4) to 0 and upper (slot 7) to $FFFF
.87dd	64 64		stz $64				stz 	NSMantissa1+4
.87df	a9 ff		lda #$ff			lda 	#$FF
.87e1	85 5f		sta $5f				sta 	NSMantissa0+7
.87e3	85 67		sta $67				sta 	NSMantissa1+7
.87e5	b1 30		lda ($30),y			lda 	(codePtr),y
.87e7	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.87e9	f0 1a		beq $8805			beq 	_CLSecond
.87eb	20 c1 88	jsr $88c1			jsr 	CLIsDigit 					; if not digit, list all
.87ee	b0 20		bcs $8810			bcs 	_CLStart
.87f0	a2 04		ldx #$04			ldx 	#4 							; get 1st range into slot 4
.87f2	20 31 9d	jsr $9d31			jsr 	Evaluate16BitInteger
.87f5	b1 30		lda ($30),y			lda 	(codePtr),y
.87f7	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.87f9	f0 0a		beq $8805			beq 	_CLSecond 					; if so go get it
.87fb	a5 5c		lda $5c				lda 	NSMantissa0+4 				; copy 4->7
.87fd	85 5f		sta $5f				sta 	NSMantissa0+7
.87ff	a5 64		lda $64				lda 	NSMantissa1+4
.8801	85 67		sta $67				sta 	NSMantissa1+7
.8803	80 0b		bra $8810			bra 	_CLStart
.8805					_CLSecond:
.8805	c8		iny				iny 								; consume comma
.8806	20 c1 88	jsr $88c1			jsr 	CLIsDigit 					; digit found
.8809	b0 05		bcs $8810			bcs 	_CLStart 					; if not, continue listing
.880b	a2 07		ldx #$07			ldx 	#7 							; load 2nd range into slot 7
.880d	20 31 9d	jsr $9d31			jsr 	Evaluate16BitInteger
.8810					_CLStart
.8810	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8812	85 30		sta $30				sta 	codePtr
.8814	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8816	85 31		sta $31				sta 	codePtr+1
.8818					_CLLoop:
.8818	20 db a9	jsr $a9db			jsr 	EXTBreakCheck 				; break check
.881b	f0 24		beq $8841			beq 	_CLExit
.881d	b2 30		lda ($30)			lda 	(codePtr)
.881f	f0 20		beq $8841			beq 	_CLExit
.8821	a2 04		ldx #$04			ldx 	#4 							; check range every time, line numbers aren't in order.
.8823	20 b0 88	jsr $88b0			jsr 	CLCompareLineNo
.8826	90 0c		bcc $8834			bcc 	_CLNext
.8828	a2 07		ldx #$07			ldx 	#7
.882a	20 b0 88	jsr $88b0			jsr 	CLCompareLineNo
.882d	f0 02		beq $8831			beq 	_CLDoThisOne
.882f	b0 03		bcs $8834			bcs 	_CLNext
.8831					_CLDoThisOne:
.8831	20 9d 88	jsr $889d			jsr 	CLListOneLine
.8834					_CLNext:
.8834	18		clc				clc
.8835	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8837	65 30		adc $30				adc 	codePtr
.8839	85 30		sta $30				sta 	codePtr
.883b	90 02		bcc $883f			bcc 	_CREExit
.883d	e6 31		inc $31				inc 	codePtr+1 					; carry
.883f					_CREExit:
.883f	80 d7		bra $8818			bra 	_CLLoop
.8841					_CLExit:
.8841	4c 6a 83	jmp $836a			jmp 	WarmStart
.8844					_CLListProcedure:
.8844	b1 30		lda ($30),y			lda 	(codePtr),y
.8846	85 38		sta $38				sta 	zTemp1
.8848	c8		iny				iny
.8849	b1 30		lda ($30),y			lda 	(codePtr),y
.884b	85 39		sta $39				sta 	zTemp1+1
.884d	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.884f	85 30		sta $30				sta 	codePtr
.8851	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8853	85 31		sta $31				sta 	codePtr+1
.8855					_CLLPSearch:
.8855	b2 30		lda ($30)			lda 	(codePtr)
.8857	c9 00		cmp #$00			cmp 	#0 							; if zero, end
.8859	f0 e6		beq $8841			beq 	_CLExit
.885b	a0 03		ldy #$03			ldy 	#3 							; check if PROC something
.885d	b1 30		lda ($30),y			lda 	(codePtr),y
.885f	c9 a2		cmp #$a2			cmp 	#KWD_PROC
.8861	d0 0e		bne $8871			bne 	_CLLPNext
.8863	c8		iny				iny 								; check if PROC this.
.8864	b1 30		lda ($30),y			lda 	(codePtr),y
.8866	c5 38		cmp $38				cmp 	zTemp1 						; does it match ?
.8868	d0 07		bne $8871			bne 	_CLLPNext
.886a	c8		iny				iny
.886b	b1 30		lda ($30),y			lda 	(codePtr),y
.886d	c5 39		cmp $39				cmp 	zTemp1+1
.886f	f0 0d		beq $887e			beq 	_CLLPFound
.8871					_CLLPNext:
.8871	18		clc				clc
.8872	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8874	65 30		adc $30				adc 	codePtr
.8876	85 30		sta $30				sta 	codePtr
.8878	90 02		bcc $887c			bcc 	_CREExit
.887a	e6 31		inc $31				inc 	codePtr+1 					; carry
.887c					_CREExit:
.887c	80 d7		bra $8855			bra 	_CLLPSearch
.887e					_CLLPFound:
.887e	b2 30		lda ($30)			lda 	(codePtr)
.8880	f0 bf		beq $8841			beq 	_CLExit
.8882	a0 03		ldy #$03			ldy 	#3 							; get first keyword
.8884	b1 30		lda ($30),y			lda 	(codePtr),y
.8886	48		pha				pha
.8887	20 9d 88	jsr $889d			jsr 	CLListOneLine 				; list line and go forward
.888a	18		clc				clc
.888b	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.888d	65 30		adc $30				adc 	codePtr
.888f	85 30		sta $30				sta 	codePtr
.8891	90 02		bcc $8895			bcc 	_CREExit
.8893	e6 31		inc $31				inc 	codePtr+1 					; carry
.8895					_CREExit:
.8895	68		pla				pla 								; reached ENDPROC ?
.8896	c9 a6		cmp #$a6			cmp 	#KWD_ENDPROC
.8898	d0 e4		bne $887e			bne 	_CLLPFound
.889a	4c 6a 83	jmp $836a			jmp 	WarmStart
.889d					CLListOneLine:
.889d	20 e6 8d	jsr $8de6			jsr 	ScanGetCurrentLineStep 		; get indent adjust.
.88a0	20 25 b3	jsr $b325			jsr 	ListConvertLine 			; convert line into token Buffer
.88a3	a2 04		ldx #$04			ldx 	#(tokenBuffer >> 8) 		; print that line
.88a5	a9 2d		lda #$2d			lda 	#(tokenBuffer & $FF)
.88a7	20 fd 8e	jsr $8efd			jsr 	PrintStringXA
.88aa	a9 0d		lda #$0d			lda 	#13 						; new line
.88ac	20 25 a7	jsr $a725			jsr 	EXTPrintCharacter
.88af	60		rts				rts
.88b0					CLCompareLineNo:
.88b0	38		sec				sec
.88b1	a0 01		ldy #$01			ldy 	#1
.88b3	b1 30		lda ($30),y			lda 	(codePtr),y
.88b5	f5 58		sbc $58,x			sbc 	NSMantissa0,x
.88b7	85 36		sta $36				sta 	zTemp0
.88b9	c8		iny				iny
.88ba	b1 30		lda ($30),y			lda 	(codePtr),y
.88bc	f5 60		sbc $60,x			sbc 	NSMantissa1,x
.88be	05 36		ora $36				ora 	zTemp0
.88c0	60		rts				rts
.88c1					CLIsDigit:
.88c1	b1 30		lda ($30),y			lda 	(codePtr),y
.88c3	c9 30		cmp #$30			cmp 	#"0"
.88c5	90 03		bcc $88ca			bcc	 	_CLIDExitFalse
.88c7	c9 3a		cmp #$3a			cmp 	#"9"+1
.88c9	60		rts				rts
.88ca					_CLIDExitFalse:
.88ca	38		sec				sec
.88cb	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/local.asm

.88cc					Command_LOCAL:
.88cc	a2 00		ldx #$00			ldx 	#0 							; at level 0
.88ce	20 da 88	jsr $88da			jsr 	LocaliseNextTerm 			; convert term to a local.
.88d1	b1 30		lda ($30),y			lda 	(codePtr),y
.88d3	c8		iny				iny
.88d4	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.88d6	f0 f4		beq $88cc			beq 	Command_LOCAL
.88d8	88		dey				dey 								; unpick pre-get
.88d9	60		rts				rts
.88da					LocaliseNextTerm:
.88da	20 f2 97	jsr $97f2			jsr 	EvaluateTerm 				; evaluate the term
.88dd	b5 50		lda $50,x			lda 	NSStatus,x
.88df	29 20		and #$20			and 	#NSBIsReference 			; check it is a reference
.88e1	f0 5c		beq $893f			beq		_LNTError
.88e3	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address of variable to zTemp0
.88e5	85 36		sta $36				sta 	zTemp0
.88e7	b5 60		lda $60,x			lda 	NSMantissa1,x
.88e9	85 37		sta $37				sta  	zTemp0+1
.88eb	b5 50		lda $50,x			lda 	NSStatus,x
.88ed	29 10		and #$10			and 	#NSBIsString
.88ef	d0 1e		bne $890f			bne 	_LNTPushString
.88f1	5a		phy				phy
.88f2	a0 00		ldy #$00			ldy 	#0 							; push 0 to 4 inclusive, the number values, on the stack, and zero them as you go.
.88f4					_LNTPushNumLoop:
.88f4	b1 36		lda ($36),y			lda		(zTemp0),y
.88f6	20 cc a5	jsr $a5cc			jsr 	StackPushByte
.88f9	c8		iny				iny
.88fa	c0 05		cpy #$05			cpy 	#5
.88fc	d0 f6		bne $88f4			bne 	_LNTPushNumLoop
.88fe	a5 36		lda $36				lda 	zTemp0 						; push the actual target address to write on the stack
.8900	20 cc a5	jsr $a5cc			jsr 	StackPushByte
.8903	a5 37		lda $37				lda 	zTemp0+1
.8905	20 cc a5	jsr $a5cc			jsr 	StackPushByte
.8908	a9 01		lda #$01			lda 	#STK_LOCALN 				; push local-number marker.
.890a	20 cc a5	jsr $a5cc			jsr 	StackPushByte
.890d	7a		ply				ply
.890e	60		rts				rts
.890f					_LNTPushString:
.890f	5a		phy				phy
.8910	b2 36		lda ($36)			lda 	(zTemp0) 					; put address of string in zTemp1
.8912	85 38		sta $38				sta 	zTemp1
.8914	a0 01		ldy #$01			ldy 	#1
.8916	b1 36		lda ($36),y			lda 	(zTemp0),y
.8918	85 39		sta $39				sta 	zTemp1+1
.891a	a0 00		ldy #$00			ldy 	#0 							; output string
.891c	c9 00		cmp #$00			cmp 	#0 							; if not assigned strin
.891e	f0 0a		beq $892a			beq 	_LNTStringOut
.8920					_LNTPushStrLoop:
.8920	b1 38		lda ($38),y			lda 	(zTemp1),y
.8922	f0 06		beq $892a			beq 	_LNTStringOut
.8924	20 cc a5	jsr $a5cc			jsr 	StackPushByte
.8927	c8		iny				iny
.8928	80 f6		bra $8920			bra 	_LNTPushStrLoop
.892a					_LNTStringOut:
.892a	98		tya				tya									; output length
.892b	20 cc a5	jsr $a5cc			jsr 	StackPushByte
.892e	b5 58		lda $58,x			lda 	NSMantissa0,x 				; output address of the string record *not* the string itself
.8930	20 cc a5	jsr $a5cc			jsr 	StackPushByte
.8933	b5 60		lda $60,x			lda 	NSMantissa1,x
.8935	20 cc a5	jsr $a5cc			jsr 	StackPushByte
.8938	a9 02		lda #$02			lda 	#STK_LOCALS 				; push local-string marker.
.893a	20 cc a5	jsr $a5cc			jsr 	StackPushByte
.893d	7a		ply				ply
.893e	60		rts				rts
.893f					_LNTError:
.893f	4c 29 9f	jmp $9f29			jmp 	SyntaxError
.8942					LocalPopValue:
.8942	20 e5 a5	jsr $a5e5			jsr 	StackPopByte
.8945	c9 01		cmp #$01			cmp 	#STK_LOCALN 				; if not local-N
.8947	d0 17		bne $8960			bne 	_LPVString
.8949	20 e5 a5	jsr $a5e5			jsr 	StackPopByte 				; address
.894c	85 37		sta $37				sta 	zTemp0+1
.894e	20 e5 a5	jsr $a5e5			jsr 	StackPopByte
.8951	85 36		sta $36				sta 	zTemp0
.8953	5a		phy				phy
.8954	a0 04		ldy #$04			ldy 	#4 							; copy back
.8956					_LPVNumberCopy:
.8956	20 e5 a5	jsr $a5e5			jsr 	StackPopByte
.8959	91 36		sta ($36),y			sta 	(zTemp0),y
.895b	88		dey				dey
.895c	10 f8		bpl $8956			bpl 	_LPVNumberCopy
.895e	7a		ply				ply 								; and complete
.895f	60		rts				rts
.8960					_LPVString:
.8960	20 e5 a5	jsr $a5e5			jsr 	StackPopByte 				; address of record => zTemp0
.8963	85 37		sta $37				sta 	zTemp0+1
.8965	20 e5 a5	jsr $a5e5			jsr 	StackPopByte
.8968	85 36		sta $36				sta 	zTemp0
.896a	5a		phy				phy
.896b	b2 36		lda ($36)			lda 	(zTemp0) 					; address to write string to => zTemp1
.896d	85 38		sta $38				sta 	zTemp1
.896f	a0 01		ldy #$01			ldy 	#1
.8971	b1 36		lda ($36),y			lda 	(zTemp0),y
.8973	85 39		sta $39				sta 	zTemp1+1
.8975	20 e5 a5	jsr $a5e5			jsr 	StackPopByte 				; # to get => y
.8978	a8		tay				tay
.8979	a5 39		lda $39				lda 	zTemp1+1 					; if no target (e.g. was "" originally) exit
.897b	f0 0e		beq $898b			beq 	_LPVStringCopied
.897d	a9 00		lda #$00			lda 	#0 							; NULL on end
.897f	91 38		sta ($38),y			sta 	(zTemp1),y
.8981					_LPVStringCopy:
.8981	88		dey				dey
.8982	30 07		bmi $898b			bmi 	_LPVStringCopied
.8984	20 e5 a5	jsr $a5e5			jsr 	StackPopByte
.8987	91 38		sta ($38),y			sta 	(zTemp1),y
.8989	80 f6		bra $8981			bra 	_LPVStringCopy
.898b					_LPVStringCopied:
.898b	fa		plx				plx
.898c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/new.asm

.898d					NewCommand:
.898d	20 93 89	jsr $8993			jsr 	NewProgram 					; does the actual NEW.
.8990	4c 6a 83	jmp $836a			jmp 	WarmStart 					; and warm starts straight away.
.8993					NewProgram:
.8993	20 f9 a4	jsr $a4f9			jsr 	MemoryNew
.8996	9c 00 10	stz $1000			stz 	VariableSpace 				; erase all variables.
.8999	20 00 84	jsr $8400			jsr 	ClearCommand 				; clear everything.
.899c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/procedure.asm

=2					ParameterStackPos = 2
.899d					CallProcedure:
.899d	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start storing parameters at 2.
.899f	b1 30		lda ($30),y			lda 	(codePtr),y
.89a1	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.89a3	f0 0c		beq $89b1			beq 	_CPEndParam
.89a5					_CPParamLoop:
.89a5	20 f6 9c	jsr $9cf6			jsr 	EvaluateValue 				; get parameter onto stack
.89a8	e8		inx				inx 								; bump next stack
.89a9	b1 30		lda ($30),y			lda 	(codePtr),y
.89ab	c8		iny				iny
.89ac	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if comma, go back and try again.
.89ae	f0 f5		beq $89a5			beq 	_CPParamLoop
.89b0	88		dey				dey 								; unpick.
.89b1					_CPEndParam:
.89b1	8e 16 04	stx $0416			stx 	LastParameter 				; save the last parameters index.
.89b4	c8		iny				iny									; skip right bracket
.89b5	a9 b3		lda #$b3			lda 	#STK_PROC+3 				; allocate 6 bytes on the return stack.
.89b7	20 ee a5	jsr $a5ee			jsr 	StackOpen
.89ba	20 32 a6	jsr $a632			jsr 	STKSaveCodePosition 		; save loop position
.89bd	a5 58		lda $58				lda 	NSMantissa0 				; copy variable (e.g. procedure) address to zTemp0
.89bf	85 36		sta $36				sta 	zTemp0 						; this is the DATA not the RECORD
.89c1	a5 60		lda $60				lda 	NSMantissa1
.89c3	85 37		sta $37				sta 	zTemp0+1
.89c5	a0 01		ldy #$01			ldy 	#1 							; copy code address back.
.89c7	b2 36		lda ($36)			lda 	(zTemp0)
.89c9	85 30		sta $30				sta 	safePtr
.89cb	b1 36		lda ($36),y			lda 	(zTemp0),y
.89cd	85 31		sta $31				sta 	safePtr+1
.89cf	c8		iny				iny
.89d0	b1 36		lda ($36),y			lda 	(zTemp0),y
.89d2	85 32		sta $32				sta 	safePtr+2
.89d4	c8		iny				iny
.89d5	b1 36		lda ($36),y			lda 	(zTemp0),y
.89d7	85 33		sta $33				sta 	safePtr+3
.89d9	c8		iny				iny 								; get Y offset -> Y
.89da	b1 36		lda ($36),y			lda 	(zTemp0),y
.89dc	a8		tay				tay
.89dd	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start position of parameters
.89df	ec 16 04	cpx $0416			cpx	 	LastParameter 				; check no parameters at the start
.89e2	f0 13		beq $89f7			beq 	_ParamExit 					; if so, exit.
.89e4					_ParamExtract:
.89e4	ca		dex				dex 								; put a local term on the level before
.89e5	20 da 88	jsr $88da			jsr 	LocaliseNextTerm			; also pushes original param value to basic stack
.89e8	20 b9 87	jsr $87b9			jsr 	AssignVariable 				; assign stacked value to the variable.
.89eb	e8		inx				inx 								; advance to next parameter to do.
.89ec	e8		inx				inx
.89ed	ec 16 04	cpx $0416			cpx 	LastParameter 				; are we done ?
.89f0	f0 05		beq $89f7			beq 	_ParamExit
.89f2	20 93 8e	jsr $8e93			jsr 	CheckComma 					; comma seperating parameters
.89f5	80 ed		bra $89e4			bra 	_ParamExtract
.89f7					_ParamExit:
.89f7	20 8b 8e	jsr $8e8b			jsr 	CheckRightBracket 			; check )
.89fa	60		rts				rts 								; and continue from here
.89fb					Command_ENDPROC:
.89fb	a9 b0		lda #$b0			lda 	#STK_PROC 					; check TOS is this
.89fd	a2 14		ldx #$14			ldx 	#ERRID_PROC
.89ff	20 1a a6	jsr $a61a			jsr 	StackCheckFrame
.8a02	20 43 a6	jsr $a643			jsr 	STKLoadCodePosition 		; restore code position
.8a05	20 0c a6	jsr $a60c			jsr 	StackClose
.8a08	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/read.asm

.8a09					Command_Read:
.8a09	a2 00		ldx #$00			ldx 	#0 							; evaluate the term which is the var/array element to assign
.8a0b	20 f2 97	jsr $97f2			jsr 	EvaluateTerm
.8a0e	b5 50		lda $50,x			lda 	NSStatus,x
.8a10	29 20		and #$20			and 	#NSBIsReference				; get status byte on stack, identifies int, float, string.
.8a12	f0 4a		beq $8a5e			beq 	_CRSyntax 					; check reference (bit 0)
.8a14	20 a7 8a	jsr $8aa7			jsr 	SwapDataCodePtrs 			; swap code and data
.8a17	ad 1c 04	lda $041c			lda 	inDataStatement 			; if in a data statement, we don't need to search
.8a1a	d0 20		bne $8a3c			bne 	_CRContinueData
.8a1c					_CRKeepSearching:
.8a1c	a9 b2		lda #$b2			lda 	#KWD_DATA 					; scan for instruction
.8a1e	aa		tax				tax
.8a1f	20 83 8d	jsr $8d83			jsr 	ScanForward
.8a22	c9 b2		cmp #$b2			cmp 	#KWD_DATA 					; found data ?
.8a24	f0 16		beq $8a3c			beq 	_CRHaveData 				; found it
.8a26	18		clc				clc
.8a27	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8a29	65 30		adc $30				adc 	codePtr
.8a2b	85 30		sta $30				sta 	codePtr
.8a2d	90 02		bcc $8a31			bcc 	_CREExit
.8a2f	e6 31		inc $31				inc 	codePtr+1 					; carry
.8a31					_CREExit:
.8a31	a0 03		ldy #$03			ldy 	#3 							; start of line.
.8a33	b2 30		lda ($30)			lda 	(codePtr)
.8a35	d0 e5		bne $8a1c			bne 	_CRKeepSearching
.8a37	a9 0b		lda #$0b		lda	#11
.8a39	4c a4 8e	jmp $8ea4		jmp	ErrorHandler
.8a3c					_CRHaveData:
.8a3c					_CRContinueData:
.8a3c	a2 01		ldx #$01			ldx 	#1
.8a3e	20 f6 9c	jsr $9cf6			jsr 	EvaluateValue 				; evaluate value into slot # 1
.8a41	ca		dex				dex
.8a42	20 b9 87	jsr $87b9			jsr		AssignVariable 				; do the assignment
.8a45	9c 1c 04	stz $041c			stz 	inDataStatement 			; clear in data
.8a48	b1 30		lda ($30),y			lda 	(codePtr),y
.8a4a	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not, end of data statement
.8a4c	d0 04		bne $8a52			bne 	_CRSwapBack
.8a4e	c8		iny				iny 								; consume comma
.8a4f	ee 1c 04	inc $041c			inc 	inDataStatement 			; set in data statement currently.
.8a52					_CRSwapBack:
.8a52	20 a7 8a	jsr $8aa7			jsr 	SwapDataCodePtrs			; swap them back.
.8a55	b1 30		lda ($30),y			lda 	(codePtr),y
.8a57	c8		iny				iny
.8a58	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8a5a	f0 ad		beq $8a09			beq 	Command_Read 				; if so go round again.
.8a5c	88		dey				dey 								; unpick get.
.8a5d	60		rts				rts
.8a5e					_CRSyntax:
.8a5e	4c 29 9f	jmp $9f29			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/rem.asm

.8a61					RemCommand:
.8a61	b1 30		lda ($30),y			lda 	(codePtr),y
.8a63	c9 ff		cmp #$ff			cmp 	#KWC_STRING
.8a65	d0 06		bne $8a6d			bne 	_RMExit
.8a67	c8		iny				iny 								; point to offset
.8a68	98		tya				tya 								; A = offset position
.8a69	38		sec				sec 								; add size +1 hence SEC
.8a6a	71 30		adc ($30),y			adc 	(codePtr),y
.8a6c	a8		tay				tay 								; make current position.
.8a6d					_RMExit:
.8a6d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/repeat.asm

.8a6e					Command_REPEAT:
.8a6e	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; allocate 6 bytes on the return stack.
.8a70	20 ee a5	jsr $a5ee			jsr 	StackOpen
.8a73	20 32 a6	jsr $a632			jsr 	STKSaveCodePosition 		; save loop position
.8a76	60		rts				rts
.8a77					Command_UNTIL:
.8a77	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; check REPEAT is TOS
.8a79	a2 0f		ldx #$0f			ldx 	#ERRID_REPEAT 				; this error
.8a7b	20 1a a6	jsr $a61a			jsr 	StackCheckFrame
.8a7e	a2 00		ldx #$00			ldx 	#0
.8a80	20 ff 9c	jsr $9cff			jsr 	EvaluateNumber 				; work out the number
.8a83	20 d3 9d	jsr $9dd3			jsr 	NSMIsZero 					; check if zero
.8a86	f0 04		beq $8a8c			beq 	_CULoopBack 				; if so keep looping
.8a88	20 0c a6	jsr $a60c			jsr 	StackClose		 			; return
.8a8b	60		rts				rts
.8a8c					_CULoopBack:
.8a8c	20 43 a6	jsr $a643			jsr 	STKLoadCodePosition 		; loop back
.8a8f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/restore.asm

.8a90					Command_Restore:
.8a90	20 a7 8a	jsr $8aa7			jsr 	SwapDataCodePtrs 			; swap code and data
.8a93	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8a95	85 30		sta $30				sta 	codePtr
.8a97	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8a99	85 31		sta $31				sta 	codePtr+1
.8a9b	20 a7 8a	jsr $8aa7			jsr 	SwapDataCodePtrs 			; put them back
.8a9e	a9 03		lda #$03			lda 	#3 							; start at offset 3, e.g. first instruction of first line.
.8aa0	8d 1b 04	sta $041b			sta 	dataPointer+4
.8aa3	9c 1c 04	stz $041c			stz 	inDataStatement 			; not in data statement
.8aa6	60		rts				rts
.8aa7					SwapDataCodePtrs:
.8aa7	da		phx				phx
.8aa8	a2 03		ldx #$03			ldx 	#3 							; swap 32 bit code pointer over
.8aaa					_SDCPLoop:
.8aaa	b5 30		lda $30,x			lda 	safePtr,x
.8aac	48		pha				pha
.8aad	bd 17 04	lda $0417,x			lda 	dataPointer,x
.8ab0	95 30		sta $30,x			sta 	safePtr,x
.8ab2	68		pla				pla
.8ab3	9d 17 04	sta $0417,x			sta 	dataPointer,x
.8ab6	ca		dex				dex
.8ab7	10 f1		bpl $8aaa			bpl 	_SDCPLoop
.8ab9	ad 1b 04	lda $041b			lda 	dataPointer+4 				; swap Y position over.
.8abc	8c 1b 04	sty $041b			sty 	dataPointer+4
.8abf	a8		tay				tay
.8ac0	fa		plx				plx
.8ac1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/run.asm

.8ac2					EOLCommand:
.8ac2	18		clc				clc
.8ac3	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8ac5	65 30		adc $30				adc 	codePtr
.8ac7	85 30		sta $30				sta 	codePtr
.8ac9	90 02		bcc $8acd			bcc 	_CREExit
.8acb	e6 31		inc $31				inc 	codePtr+1 					; carry
.8acd					_CREExit:
.8acd	80 0b		bra $8ada			bra 	RunNewLine
.8acf					CommandRUN:
.8acf	20 00 84	jsr $8400			jsr 	ClearCommand 				; clear variable/stacks/etc.
.8ad2	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8ad4	85 30		sta $30				sta 	codePtr
.8ad6	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8ad8	85 31		sta $31				sta 	codePtr+1
.8ada					RUNNewLine:
.8ada	b2 30		lda ($30)			lda 	(codePtr)
.8adc	f0 72		beq $8b50			beq 	CRNoProgram         		; no then END.
.8ade	a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack
.8ae0	9a		txs				txs
.8ae1					RUNCodePointerLine:
.8ae1	a0 02		ldy #$02			ldy 	#2 							; start of program
.8ae3					_CRIncMainLoop:
.8ae3	0e 13 04	asl $0413			asl 	breakCheck 					; clears 1 time in 8
.8ae6	d0 19		bne $8b01			bne 	_CRNoBreakCheck
.8ae8	20 db a9	jsr $a9db			jsr 	EXTBreakCheck 				; break check
.8aeb	f0 5e		beq $8b4b			beq 	_CRBreak
.8aed	64 01		stz $01				stz 	1 							; access I/O Page 0
.8aef	38		sec				sec 								; calculate timer - LastTick
.8af0	ad 59 d6	lda $d659			lda 	$D659
.8af3	aa		tax				tax 								; saving timer in X
.8af4	ed af 05	sbc $05af			sbc 	LastTick
.8af7	c9 03		cmp #$03			cmp 	#3
.8af9	90 06		bcc $8b01			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.8afb	8e af 05	stx $05af			stx 	LastTick 					; update last timer
.8afe	20 96 b9	jsr $b996			jsr 	TickHandler 				; go do the code.
.8b01					_NoFireTick:
.8b01					_CRNoBreakCheck:
.8b01	c8		iny				iny
.8b02					_CRMainLoop:
.8b02	9c 10 04	stz $0410			stz 	stringInitialised 			; clear the temporary string initialised flag.
.8b05	b1 30		lda ($30),y			lda 	(codePtr),y
.8b07	10 10		bpl $8b19			bpl 	_CRNotKeyword
.8b09	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1 			; if after unary, legitimate command
.8b0b	b0 04		bcs $8b11			bcs 	_CRIsKeyword
.8b0d	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if unary, syntax error.
.8b0f	b0 34		bcs $8b45			bcs		_CRSyntaxError
.8b11					_CRIsKeyword:
.8b11	c8		iny				iny 								; consume command
.8b12	0a		asl a				asl 	a 							; double losing the MSB which is '1' as tokens are $80-$FF
.8b13	aa		tax				tax 								; put in X for vector jump
.8b14	20 48 8b	jsr $8b48			jsr 	_CRCallVector0 				; call the vector - effectively jsr (vectortable,X)
.8b17	80 e9		bra $8b02			bra 	_CRMainLoop 				; and loop round
.8b19					_CRNotKeyword:
.8b19	c9 3a		cmp #$3a			cmp 	#KWD_COLON 					; if a :, consume it and go round.
.8b1b	f0 c6		beq $8ae3			beq 	_CRIncMainLoop
.8b1d	c9 40		cmp #$40			cmp 	#$40 						; variable/call reference
.8b1f	90 05		bcc $8b26			bcc 	_CRNotVariable
.8b21					_CRGoLet:
.8b21	20 80 87	jsr $8780			jsr 	LetCommand
.8b24	80 dc		bra $8b02			bra 	_CRMainLoop
.8b26					_CRNotVariable:
.8b26	c9 10		cmp #$10			cmp 	#KWD_AT 					; handle @
.8b28	f0 f7		beq $8b21			beq 	_CRGoLet
.8b2a	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; handle ? !
.8b2c	f0 f3		beq $8b21			beq 	_CRGoLet
.8b2e	c9 21		cmp #$21			cmp 	#KWD_PLING
.8b30	f0 ef		beq $8b21			beq 	_CRGoLet
.8b32	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; handle ' (comment)
.8b34	f0 09		beq $8b3f			beq 	_CRGoRem
.8b36	c9 2e		cmp #$2e			cmp 	#KWD_PERIOD 				; handle . (assembler label)
.8b38	d0 0b		bne $8b45			bne 	_CRSyntaxError
.8b3a	20 03 82	jsr $8203			jsr 	LabelHere
.8b3d	80 c3		bra $8b02			bra 	_CRMainLoop
.8b3f					_CRGoRem:
.8b3f	c8		iny				iny
.8b40	20 61 8a	jsr $8a61			jsr 	RemCommand
.8b43	80 bd		bra $8b02			bra 	_CRMainLoop
.8b45					_CRSyntaxError:
.8b45	4c 29 9f	jmp $9f29			jmp 	SyntaxError
.8b48					_CRCallVector0:
.8b48	7c e6 8b	jmp ($8be6,x)			jmp 	(VectorSet0,x)
.8b4b					_CRBreak:
.8b4b	a9 01		lda #$01		lda	#1
.8b4d	4c a4 8e	jmp $8ea4		jmp	ErrorHandler
.8b50					CRNoProgram:
.8b50	4c 25 85	jmp $8525			jmp 	EndCommand
.8b53					Shift1Command:
.8b53	b1 30		lda ($30),y			lda 	(codePtr),y
.8b55	c8		iny				iny
.8b56	0a		asl a				asl 	a
.8b57	aa		tax				tax
.8b58	7c 84 8c	jmp ($8c84,x)			jmp 	(VectorSet1,x)
.8b5b					Shift2Command:
.8b5b	b1 30		lda ($30),y			lda 	(codePtr),y
.8b5d	c8		iny				iny
.8b5e	0a		asl a				asl 	a
.8b5f	aa		tax				tax
.8b60	7c a4 8c	jmp ($8ca4,x)			jmp 	(VectorSet2,x)
.8b63					Unused1:
.8b63					Unused2:
.8b63					Unused3:
.8b63					Unused4:
.8b63	4c 29 9f	jmp $9f29			jmp 	SyntaxError
>8b66							.align 2

;******  Processing file: ./common/commands/../generated/vectors.dat

.8b66					VectorSetPunc:
>8b66	5c 91					.word	ShiftLeft                        ; $00 <<
>8b68	47 8f					.word	BinaryCompareLessEqual           ; $01 <=
>8b6a	3d 8f					.word	BinaryCompareNotEqual            ; $02 <>
>8b6c	29 9f					.word	SyntaxError                      ; $03 !!3
>8b6e	29 9f					.word	SyntaxError                      ; $04 ><
>8b70	51 8f					.word	BinaryCompareGreaterEqual        ; $05 >=
>8b72	5f 91					.word	ShiftRight                       ; $06 >>
>8b74	29 9f					.word	SyntaxError                      ; $07 !!7
>8b76	29 9f					.word	SyntaxError                      ; $08 !!8
>8b78	29 9f					.word	SyntaxError                      ; $09 !!9
>8b7a	29 9f					.word	SyntaxError                      ; $0a !!10
>8b7c	29 9f					.word	SyntaxError                      ; $0b !!11
>8b7e	29 9f					.word	SyntaxError                      ; $0c !!12
>8b80	29 9f					.word	SyntaxError                      ; $0d !!13
>8b82	29 9f					.word	SyntaxError                      ; $0e !!14
>8b84	29 9f					.word	SyntaxError                      ; $0f !!15
>8b86	29 9f					.word	SyntaxError                      ; $10 @
>8b88	29 9f					.word	SyntaxError                      ; $11 !!17
>8b8a	29 9f					.word	SyntaxError                      ; $12 !!18
>8b8c	29 9f					.word	SyntaxError                      ; $13 [
>8b8e	08 90					.word	IntegerDivide                    ; $14 \
>8b90	29 9f					.word	SyntaxError                      ; $15 ]
>8b92	9a 92					.word	EorInteger                       ; $16 ^
>8b94	29 9f					.word	SyntaxError                      ; $17 _
>8b96	29 9f					.word	SyntaxError                      ; $18 `
>8b98	29 9f					.word	SyntaxError                      ; $19 !!25
>8b9a	29 9f					.word	SyntaxError                      ; $1a !!26
>8b9c	29 9f					.word	SyntaxError                      ; $1b {
>8b9e	65 92					.word	OraInteger                       ; $1c |
>8ba0	29 9f					.word	SyntaxError                      ; $1d }
>8ba2	29 9f					.word	SyntaxError                      ; $1e ~
>8ba4	29 9f					.word	SyntaxError                      ; $1f [7m<7F>[m
>8ba6	29 9f					.word	SyntaxError                      ; $20
>8ba8	cf 92					.word	WordIndirect                     ; $21 !
>8baa	29 9f					.word	SyntaxError                      ; $22 "
>8bac	29 9f					.word	SyntaxError                      ; $23 #
>8bae	29 9f					.word	SyntaxError                      ; $24 $
>8bb0	49 90					.word	IntegerModulus                   ; $25 %
>8bb2	30 92					.word	AndInteger                       ; $26 &
>8bb4	29 9f					.word	SyntaxError                      ; $27 '
>8bb6	29 9f					.word	SyntaxError                      ; $28 (
>8bb8	29 9f					.word	SyntaxError                      ; $29 )
>8bba	b7 90					.word	MulInteger                       ; $2a *
>8bbc	d2 91					.word	AddInteger                       ; $2b +
>8bbe	29 9f					.word	SyntaxError                      ; $2c ,
>8bc0	0b 92					.word	SubInteger                       ; $2d -
>8bc2	29 9f					.word	SyntaxError                      ; $2e .
>8bc4	89 94					.word	FDivideCommand                   ; $2f /
>8bc6	29 9f					.word	SyntaxError                      ; $30 0
>8bc8	29 9f					.word	SyntaxError                      ; $31 1
>8bca	29 9f					.word	SyntaxError                      ; $32 2
>8bcc	29 9f					.word	SyntaxError                      ; $33 3
>8bce	29 9f					.word	SyntaxError                      ; $34 4
>8bd0	29 9f					.word	SyntaxError                      ; $35 5
>8bd2	29 9f					.word	SyntaxError                      ; $36 6
>8bd4	29 9f					.word	SyntaxError                      ; $37 7
>8bd6	29 9f					.word	SyntaxError                      ; $38 8
>8bd8	29 9f					.word	SyntaxError                      ; $39 9
>8bda	29 9f					.word	SyntaxError                      ; $3a :
>8bdc	29 9f					.word	SyntaxError                      ; $3b ;
>8bde	29 8f					.word	BinaryCompareLess                ; $3c <
>8be0	1f 8f					.word	BinaryCompareEqual               ; $3d =
>8be2	33 8f					.word	BinaryCompareGreater             ; $3e >
>8be4	f1 92					.word	ByteIndirect                     ; $3f ?
.8be6					VectorSet0:
>8be6	c2 8a					.word	EOLCommand                       ; $80 !0:EOF
>8be8	53 8b					.word	Shift1Command                    ; $81 !1:SH1
>8bea	5b 8b					.word	Shift2Command                    ; $82 !2:SH2
>8bec	6e 99					.word	AbsUnary                         ; $83 ABS(
>8bee	7c 99					.word	AllocUnary                       ; $84 ALLOC(
>8bf0	ec 99					.word	AscUnary                         ; $85 ASC(
>8bf2	97 9b					.word	ChrUnary                         ; $86 CHR$(
>8bf4	79 a3					.word	UnaryEvent                       ; $87 EVENT(
>8bf6	1b 8f					.word	UnaryFalse                       ; $88 FALSE
>8bf8	f9 99					.word	FracUnary                        ; $89 FRAC(
>8bfa	15 a3					.word	UnaryHit                         ; $8a HIT(
>8bfc	0e 9a					.word	IntUnary                         ; $8b INT(
>8bfe	56 9b					.word	IsValUnary                       ; $8c ISVAL(
>8c00	fd a3					.word	UnaryJoyB                        ; $8d JOYB(
>8c02	d6 a3					.word	UnaryJoyX                        ; $8e JOYX(
>8c04	d9 a3					.word	UnaryJoyY                        ; $8f JOYY(
>8c06	6a 9c					.word	Unary_Left                       ; $90 LEFT$(
>8c08	1f 9a					.word	LenUnary                         ; $91 LEN(
>8c0a	3d 9a					.word	Unary_Max                        ; $92 MAX(
>8c0c	8c 9c					.word	Unary_Mid                        ; $93 MID$(
>8c0e	39 9a					.word	Unary_Min                        ; $94 MIN(
>8c10	88 9a					.word	Unary_Not                        ; $95 NOT(
>8c12	4a a5					.word	UnaryPlaying                     ; $96 PLAYING(
>8c14	9b 9a					.word	Unary_Random                     ; $97 RANDOM(
>8c16	77 9c					.word	Unary_Right                      ; $98 RIGHT$(
>8c18	b8 9a					.word	Unary_Rnd                        ; $99 RND(
>8c1a	2e 9b					.word	SgnUnary                         ; $9a SGN(
>8c1c	a9 9b					.word	SpcUnary                         ; $9b SPC(
>8c1e	c4 9b					.word	Unary_Str                        ; $9c STR$(
>8c20	23 a4					.word	UnaryTimer                       ; $9d TIMER(
>8c22	10 8f					.word	UnaryTrue                        ; $9e TRUE
>8c24	4c 9b					.word	ValUnary                         ; $9f VAL(
>8c26	28 85					.word	ForCommand                       ; $a0 FOR
>8c28	6b 86					.word	IfCommand                        ; $a1 IF
>8c2a	63 8b					.word	Unused1                          ; $a2 PROC
>8c2c	6e 8a					.word	Command_REPEAT                   ; $a3 REPEAT
>8c2e	f9 8d					.word	Command_WHILE                    ; $a4 WHILE
>8c30	94 86					.word	EndIf                            ; $a5 ENDIF
>8c32	fb 89					.word	Command_ENDPROC                  ; $a6 ENDPROC
>8c34	da 85					.word	NextCommand                      ; $a7 NEXT
>8c36	63 8b					.word	Unused4                          ; $a8 THEN
>8c38	77 8a					.word	Command_UNTIL                    ; $a9 UNTIL
>8c3a	1a 8e					.word	Command_WEND                     ; $aa WEND
>8c3c	29 9f					.word	SyntaxError                      ; $ab BY
>8c3e	cb 83					.word	CallCommand                      ; $ac CALL
>8c40	c9 a0					.word	CircleCommand                    ; $ad CIRCLE
>8c42	00 84					.word	ClearCommand                     ; $ae CLEAR
>8c44	58 84					.word	ClearScreen                      ; $af CLS
>8c46	29 9f					.word	SyntaxError                      ; $b0 COLOR
>8c48	29 9f					.word	SyntaxError                      ; $b1 COLOUR
>8c4a	60 84					.word	Command_Data                     ; $b2 DATA
>8c4c	68 84					.word	DimCommand                       ; $b3 DIM
>8c4e	63 8b					.word	Unused3                          ; $b4 DOWNTO
>8c50	8d 86					.word	ElseCode                         ; $b5 ELSE
>8c52	29 9f					.word	SyntaxError                      ; $b6 FROM
>8c54	e8 a2					.word	GfxCommand                       ; $b7 GFX
>8c56	33 86					.word	Command_GOSUB                    ; $b8 GOSUB
>8c58	51 86					.word	GotoCommand                      ; $b9 GOTO
>8c5a	29 9f					.word	SyntaxError                      ; $ba HERE
>8c5c	f2 a0					.word	ImageCommand                     ; $bb IMAGE
>8c5e	95 86					.word	Command_Input                    ; $bc INPUT
>8c60	80 87					.word	LetCommand                       ; $bd LET
>8c62	44 a1					.word	LineCommand                      ; $be LINE
>8c64	cc 88					.word	Command_LOCAL                    ; $bf LOCAL
>8c66	29 9f					.word	SyntaxError                      ; $c0 OFF
>8c68	29 9f					.word	SyntaxError                      ; $c1 ON
>8c6a	29 9f					.word	SyntaxError                      ; $c2 OUTLINE
>8c6c	39 a3					.word	PaletteCommand                   ; $c3 PALETTE
>8c6e	3d a1					.word	PlotCommand                      ; $c4 PLOT
>8c70	9c 86					.word	Command_Print                    ; $c5 PRINT
>8c72	09 8a					.word	Command_Read                     ; $c6 READ
>8c74	c5 a0					.word	RectangleCommand                 ; $c7 RECT
>8c76	61 8a					.word	RemCommand                       ; $c8 REM
>8c78	43 86					.word	Command_RETURN                   ; $c9 RETURN
>8c7a	29 9f					.word	SyntaxError                      ; $ca SOLID
>8c7c	66 a5					.word	SoundCommand                     ; $cb SOUND
>8c7e	d4 a0					.word	SpriteCommand                    ; $cc SPRITE
>8c80	0e a1					.word	TextCommand                      ; $cd TEXT
>8c82	63 8b					.word	Unused2                          ; $ce TO
.8c84					VectorSet1:
>8c84	29 9f					.word	SyntaxError                      ; $80 !0:EOF
>8c86	29 9f					.word	SyntaxError                      ; $81 !1:SH1
>8c88	29 9f					.word	SyntaxError                      ; $82 !2:SH2
>8c8a	9f 83					.word	AssembleCommand                  ; $83 ASSEMBLE
>8c8c	bb 83					.word	AssertCommand                    ; $84 ASSERT
>8c8e	88 a2					.word	BitmapCtrl                       ; $85 BITMAP
>8c90	25 85					.word	EndCommand                       ; $86 END
>8c92	1a a4					.word	GoCommand                        ; $87 GO
>8c94	d0 87					.word	Command_List                     ; $88 LIST
>8c96	11 a4					.word	LoadCommand                      ; $89 LOAD
>8c98	8d 89					.word	NewCommand                       ; $8a NEW
>8c9a	90 8a					.word	Command_Restore                  ; $8b RESTORE
>8c9c	cf 8a					.word	CommandRUN                       ; $8c RUN
>8c9e	cd a2					.word	SpritesCtrl                      ; $8d SPRITES
>8ca0	2c 8d					.word	StopCommand                      ; $8e STOP
>8ca2	28 8e					.word	WhoCommand                       ; $8f WHO
.8ca4					VectorSet2:
>8ca4	29 9f					.word	SyntaxError                      ; $80 !0:EOF
>8ca6	29 9f					.word	SyntaxError                      ; $81 !1:SH1
>8ca8	29 9f					.word	SyntaxError                      ; $82 !2:SH2
>8caa	e8 9d					.word	Assemble_adc                     ; $83 ADC
>8cac	e0 9d					.word	Assemble_and                     ; $84 AND
>8cae	fc 9d					.word	Assemble_asl                     ; $85 ASL
>8cb0	66 9e					.word	Assemble_bcc                     ; $86 BCC
>8cb2	6a 9e					.word	Assemble_bcs                     ; $87 BCS
>8cb4	72 9e					.word	Assemble_beq                     ; $88 BEQ
>8cb6	29 9e					.word	Assemble_bit                     ; $89 BIT
>8cb8	5a 9e					.word	Assemble_bmi                     ; $8a BMI
>8cba	6e 9e					.word	Assemble_bne                     ; $8b BNE
>8cbc	56 9e					.word	Assemble_bpl                     ; $8c BPL
>8cbe	76 9e					.word	Assemble_bra                     ; $8d BRA
>8cc0	7a 9e					.word	Assemble_brk                     ; $8e BRK
>8cc2	5e 9e					.word	Assemble_bvc                     ; $8f BVC
>8cc4	62 9e					.word	Assemble_bvs                     ; $90 BVS
>8cc6	82 9e					.word	Assemble_clc                     ; $91 CLC
>8cc8	d6 9e					.word	Assemble_cld                     ; $92 CLD
>8cca	96 9e					.word	Assemble_cli                     ; $93 CLI
>8ccc	c6 9e					.word	Assemble_clv                     ; $94 CLV
>8cce	f4 9d					.word	Assemble_cmp                     ; $95 CMP
>8cd0	3d 9e					.word	Assemble_cpx                     ; $96 CPX
>8cd2	38 9e					.word	Assemble_cpy                     ; $97 CPY
>8cd4	1a 9e					.word	Assemble_dec                     ; $98 DEC
>8cd6	d2 9e					.word	Assemble_dex                     ; $99 DEX
>8cd8	ae 9e					.word	Assemble_dey                     ; $9a DEY
>8cda	e4 9d					.word	Assemble_eor                     ; $9b EOR
>8cdc	1f 9e					.word	Assemble_inc                     ; $9c INC
>8cde	e2 9e					.word	Assemble_inx                     ; $9d INX
>8ce0	ce 9e					.word	Assemble_iny                     ; $9e INY
>8ce2	51 9e					.word	Assemble_jmp                     ; $9f JMP
>8ce4	4c 9e					.word	Assemble_jsr                     ; $a0 JSR
>8ce6	f0 9d					.word	Assemble_lda                     ; $a1 LDA
>8ce8	15 9e					.word	Assemble_ldx                     ; $a2 LDX
>8cea	33 9e					.word	Assemble_ldy                     ; $a3 LDY
>8cec	06 9e					.word	Assemble_lsr                     ; $a4 LSR
>8cee	e6 9e					.word	Assemble_nop                     ; $a5 NOP
>8cf0	dc 9d					.word	Assemble_ora                     ; $a6 ORA
>8cf2	92 9e					.word	Assemble_pha                     ; $a7 PHA
>8cf4	7e 9e					.word	Assemble_php                     ; $a8 PHP
>8cf6	da 9e					.word	Assemble_phx                     ; $a9 PHX
>8cf8	9a 9e					.word	Assemble_phy                     ; $aa PHY
>8cfa	a2 9e					.word	Assemble_pla                     ; $ab PLA
>8cfc	86 9e					.word	Assemble_plp                     ; $ac PLP
>8cfe	ee 9e					.word	Assemble_plx                     ; $ad PLX
>8d00	aa 9e					.word	Assemble_ply                     ; $ae PLY
>8d02	01 9e					.word	Assemble_rol                     ; $af ROL
>8d04	0b 9e					.word	Assemble_ror                     ; $b0 ROR
>8d06	8e 9e					.word	Assemble_rti                     ; $b1 RTI
>8d08	9e 9e					.word	Assemble_rts                     ; $b2 RTS
>8d0a	f8 9d					.word	Assemble_sbc                     ; $b3 SBC
>8d0c	8a 9e					.word	Assemble_sec                     ; $b4 SEC
>8d0e	ea 9e					.word	Assemble_sed                     ; $b5 SED
>8d10	a6 9e					.word	Assemble_sei                     ; $b6 SEI
>8d12	ec 9d					.word	Assemble_sta                     ; $b7 STA
>8d14	de 9e					.word	Assemble_stp                     ; $b8 STP
>8d16	10 9e					.word	Assemble_stx                     ; $b9 STX
>8d18	2e 9e					.word	Assemble_sty                     ; $ba STY
>8d1a	24 9e					.word	Assemble_stz                     ; $bb STZ
>8d1c	c2 9e					.word	Assemble_tax                     ; $bc TAX
>8d1e	be 9e					.word	Assemble_tay                     ; $bd TAY
>8d20	47 9e					.word	Assemble_trb                     ; $be TRB
>8d22	42 9e					.word	Assemble_tsb                     ; $bf TSB
>8d24	ca 9e					.word	Assemble_tsx                     ; $c0 TSX
>8d26	b2 9e					.word	Assemble_txa                     ; $c1 TXA
>8d28	ba 9e					.word	Assemble_txs                     ; $c2 TXS
>8d2a	b6 9e					.word	Assemble_tya                     ; $c3 TYA

;******  Return to file: ./common/commands/run.asm


;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/stop.asm

.8d2c					StopCommand:
.8d2c	a9 08		lda #$08		lda	#8
.8d2e	4c a4 8e	jmp $8ea4		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/procscan.asm

.8d31					ProcedureScan:
.8d31	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8d33	85 30		sta $30				sta 	codePtr
.8d35	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8d37	85 31		sta $31				sta 	codePtr+1
.8d39					_PSLoop:
.8d39	b2 30		lda ($30)			lda 	(codePtr)
.8d3b	f0 42		beq $8d7f			beq 	_PSExit
.8d3d	a0 03		ldy #$03			ldy 	#3 							; is it PROC ?
.8d3f	b1 30		lda ($30),y			lda 	(codePtr),y
.8d41	c9 a2		cmp #$a2			cmp 	#KWD_PROC
.8d43	d0 2d		bne $8d72			bne 	_PSNext
.8d45	c8		iny				iny 								; get the address of the record to zTemp0 and
.8d46	b1 30		lda ($30),y			lda 	(codePtr),y
.8d48	29 c0		and #$c0			and 	#$C0
.8d4a	c9 40		cmp #$40			cmp 	#$40
.8d4c	d0 32		bne $8d80			bne 	_PSSyntax
.8d4e	b1 30		lda ($30),y			lda 	(codePtr),y
.8d50	18		clc				clc
.8d51	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8d53	85 37		sta $37				sta 	zTemp0+1
.8d55	c8		iny				iny 								; LSB
.8d56	b1 30		lda ($30),y			lda 	(codePtr),y
.8d58	85 36		sta $36				sta 	zTemp0
.8d5a	c8		iny				iny 								; character after variable call.
.8d5b	98		tya				tya 								; save Y offset at +7
.8d5c	a0 07		ldy #$07			ldy 	#7
.8d5e	91 36		sta ($36),y			sta 	(zTemp0),y
.8d60	a9 18		lda #$18			lda 	#NSTProcedure 				; mark it as procedure
.8d62	a0 02		ldy #$02			ldy 	#2
.8d64	91 36		sta ($36),y			sta 	(zTemp0),y
.8d66	a2 00		ldx #$00			ldx 	#0 							; copy code-Ptr in
.8d68					_PSCopy:
.8d68	b5 30		lda $30,x			lda 	safePtr,x
.8d6a	c8		iny				iny
.8d6b	91 36		sta ($36),y			sta 	(zTemp0),y
.8d6d	e8		inx				inx
.8d6e	e0 04		cpx #$04			cpx 	#4
.8d70	d0 f6		bne $8d68			bne 	_PSCopy
.8d72					_PSNext:
.8d72	18		clc				clc
.8d73	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8d75	65 30		adc $30				adc 	codePtr
.8d77	85 30		sta $30				sta 	codePtr
.8d79	90 02		bcc $8d7d			bcc 	_CREExit
.8d7b	e6 31		inc $31				inc 	codePtr+1 					; carry
.8d7d					_CREExit:
.8d7d	80 ba		bra $8d39			bra 	_PSLoop
.8d7f					_PSExit:
.8d7f	60		rts				rts
.8d80					_PSSyntax:
.8d80	4c 29 9f	jmp $9f29			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/scanforward.asm

.8d83					ScanForward:
.8d83	64 38		stz $38				stz 	zTemp1 						; this is the structure count - goes up with WHILE/FOR
.8d85	86 37		stx $37				stx 	zTemp0+1
.8d87	85 36		sta $36				sta 	zTemp0 						; save XA as the two possible matches.
.8d89					_ScanLoop:
.8d89	b1 30		lda ($30),y			lda 	(codePtr),y
.8d8b	c8		iny				iny
.8d8c	a6 38		ldx $38				ldx 	zTemp1 						; if the count is > 0 cannot match as in substructure
.8d8e	d0 0e		bne $8d9e			bne 	_ScanGoNext
.8d90	c5 36		cmp $36				cmp 	zTemp0 						; see if either matches
.8d92	f0 04		beq $8d98			beq 	_ScanMatch
.8d94	c5 37		cmp $37				cmp 	zTemp0+1
.8d96	d0 06		bne $8d9e			bne 	_ScanGoNext
.8d98					_ScanMatch:
.8d98	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if asked for EOL, backtrack.
.8d9a	d0 01		bne $8d9d			bne 	_ScanNotEndEOL
.8d9c	88		dey				dey
.8d9d					_ScanNotEndEOL:
.8d9d	60		rts				rts
.8d9e					_ScanGoNext:
.8d9e	20 a3 8d	jsr $8da3			jsr  	ScanForwardOne
.8da1	80 e6		bra $8d89			bra 	_ScanLoop
.8da3					ScanForwardOne:
.8da3	c9 40		cmp #$40			cmp 	#$40 						; if 00-3F, punctuation characters, loop back
.8da5	90 3e		bcc $8de5			bcc 	_SFWExit
.8da7	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if 40-82, skip one extra.
.8da9	90 18		bcc $8dc3			bcc 	_ScanSkipOne
.8dab	c9 fc		cmp #$fc			cmp 	#$FC 						; FC-FF are data skips
.8dad	b0 2f		bcs $8dde			bcs 	_ScanSkipData
.8daf	c9 a0		cmp #$a0			cmp 	#KWC_FIRST_STRUCTURE 		; structure keyword ?
.8db1	90 32		bcc $8de5			bcc 	_SFWExit 					; if not, ordinary keywords.
.8db3	c9 ab		cmp #$ab			cmp 	#KWC_LAST_STRUCTURE+1
.8db5	b0 2e		bcs $8de5			bcs 	_SFWExit
.8db7	c6 38		dec $38				dec 	zTemp1 						; decrement the sructure count
.8db9	c9 a5		cmp #$a5			cmp 	#KWC_FIRST_STRUCTURE_DEC 	; back if it is a dec structure (e.g. WEND/NEXT)
.8dbb	b0 28		bcs $8de5			bcs 	_SFWExit
.8dbd	e6 38		inc $38				inc 	zTemp1 						; so it's an increment structure
.8dbf	e6 38		inc $38				inc 	zTemp1 						; twice to undo the dec
.8dc1	80 22		bra $8de5			bra 	_SFWExit
.8dc3					_ScanSkipOne:
.8dc3	c8		iny				iny 								; consume the extra one.
.8dc4	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if not EOL loop back
.8dc6	d0 1d		bne $8de5			bne 	_SFWExit
.8dc8	18		clc				clc
.8dc9	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8dcb	65 30		adc $30				adc 	codePtr
.8dcd	85 30		sta $30				sta 	codePtr
.8dcf	90 02		bcc $8dd3			bcc 	_CREExit
.8dd1	e6 31		inc $31				inc 	codePtr+1 					; carry
.8dd3					_CREExit:
.8dd3	a0 03		ldy #$03			ldy 	#3 							; scan start position.
.8dd5	b2 30		lda ($30)			lda 	(codePtr)
.8dd7	d0 0c		bne $8de5			bne 	_SFWExit 					; if not zero, more to scan
.8dd9	a9 13		lda #$13		lda	#19
.8ddb	4c a4 8e	jmp $8ea4		jmp	ErrorHandler
.8dde					_ScanSkipData:
.8dde	88		dey				dey 								; point at data token
.8ddf	c8		iny				iny 								; point to offset
.8de0	98		tya				tya 								; A = offset position
.8de1	38		sec				sec 								; add size +1 hence SEC
.8de2	71 30		adc ($30),y			adc 	(codePtr),y
.8de4	a8		tay				tay 								; make current position.
.8de5					_SFWExit:
.8de5	60		rts				rts
.8de6					ScanGetCurrentLineStep:
.8de6	64 38		stz $38				stz 	zTemp1
.8de8	a0 03		ldy #$03			ldy 	#3
.8dea					_SGCLSLoop:
.8dea	b1 30		lda ($30),y			lda 	(codePtr),y
.8dec	c8		iny				iny
.8ded	c9 80		cmp #$80			cmp 	#KWC_EOL	 				; if EOL exit
.8def	f0 05		beq $8df6			beq 	_SGCLSExit
.8df1	20 a3 8d	jsr $8da3			jsr 	ScanForwardOne
.8df4	80 f4		bra $8dea			bra 	_SGCLSLoop
.8df6					_SGCLSExit:
.8df6	a5 38		lda $38				lda 	zTemp1
.8df8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/while.asm

.8df9					Command_WHILE:
.8df9	5a		phy				phy 								; save position of the test
.8dfa	a2 00		ldx #$00			ldx 	#0
.8dfc	20 ff 9c	jsr $9cff			jsr 	EvaluateNumber 				; work out the number
.8dff	20 d3 9d	jsr $9dd3			jsr 	NSMIsZero 					; check if zero
.8e02	f0 0e		beq $8e12			beq 	_WHExitLoop 				; if so exit the loop
.8e04	98		tya				tya 								; position *after* test.
.8e05	7a		ply				ply 								; restore position before test, at WHILE
.8e06	88		dey				dey
.8e07	48		pha				pha 								; push after test on the stack
.8e08	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; allocate 6 bytes on the return stack.
.8e0a	20 ee a5	jsr $a5ee			jsr 	StackOpen
.8e0d	20 32 a6	jsr $a632			jsr 	STKSaveCodePosition 		; save loop position - where the test value is.
.8e10	7a		ply				ply 								; restore the position *after* the test
.8e11	60		rts				rts
.8e12					_WHExitLoop:
.8e12	68		pla				pla 								; throw post loop position
.8e13	a9 aa		lda #$aa			lda 	#KWD_WEND 					; scan forward past WEND
.8e15	aa		tax				tax
.8e16	20 83 8d	jsr $8d83			jsr 	ScanForward
.8e19	60		rts				rts
.8e1a					Command_WEND:
.8e1a	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; check WHILE is TOS
.8e1c	a2 10		ldx #$10			ldx 	#ERRID_WHILE 				; this error
.8e1e	20 1a a6	jsr $a61a			jsr 	StackCheckFrame
.8e21	20 43 a6	jsr $a643			jsr 	STKLoadCodePosition 		; loop back
.8e24	20 0c a6	jsr $a60c			jsr 	StackClose		 			; erase the frame
.8e27	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/who.asm

.8e28					WhoCommand:
.8e28	a2 8e		ldx #$8e			ldx 	#(_WHOMessage >> 8)
.8e2a	a9 30		lda #$30			lda 	#(_WHOMessage & $FF)
.8e2c	20 fd 8e	jsr $8efd			jsr 	PrintStringXA
.8e2f	60		rts				rts
.8e30					_WHOMessage:
>8e30	81						.byte 	$81
>8e31	42 72 6f 75 67 68 74 20				.text 	"Brought to you by :",13,13
>8e39	74 6f 20 79 6f 75 20 62 79 20 3a 0d 0d
>8e46	09 53 74 65 66 61 6e 79				.text 	9,"Stefany Allaire",13
>8e4e	20 41 6c 6c 61 69 72 65 0d
>8e57	09 4a 65 73 73 69 65 20				.text 	9,"Jessie Oberreuter",13
>8e5f	4f 62 65 72 72 65 75 74 65 72 0d
>8e6a	09 50 61 75 6c 20 52 6f				.text 	9,"Paul Robson",13
>8e72	62 73 6f 6e 0d
>8e77	09 50 65 74 65 72 20 57				.text 	9,"Peter Weingartner",13
>8e7f	65 69 6e 67 61 72 74 6e 65 72 0d
>8e8a	00						.byte 	0

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/charcheck.asm

.8e8b					CheckRightBracket:
.8e8b	b1 30		lda ($30),y			lda 	(codePtr),y
.8e8d	c8		iny				iny
.8e8e	c9 29		cmp #$29			cmp 	#KWD_RPAREN 						; exit if matches
.8e90	d0 0f		bne $8ea1			bne 	CNAFail
.8e92	60		rts				rts
.8e93					CheckComma:
.8e93	b1 30		lda ($30),y			lda 	(codePtr),y
.8e95	c8		iny				iny
.8e96	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 						; exit if matches
.8e98	d0 07		bne $8ea1			bne 	CNAFail
.8e9a	60		rts				rts
.8e9b					CheckNextA:
.8e9b	d1 30		cmp ($30),y			cmp 	(codePtr),y
.8e9d	d0 02		bne $8ea1			bne 	CNAFail
.8e9f	c8		iny				iny 								; skip character
.8ea0	60		rts				rts 								; and exit
.8ea1					CNAFail:
.8ea1	4c 29 9f	jmp $9f29			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/errors.asm

.8ea4					ErrorHandler:
.8ea4	a8		tay				tay 								; find the error text
.8ea5	f0 49		beq $8ef0			beq 	_EHEnd
.8ea7	a2 00		ldx #$00			ldx 	#0
.8ea9	a9 42		lda #$42			lda 	#((ErrorText) & $FF)
.8eab	85 36		sta $36				sta 	0+zTemp0
.8ead	a9 9f		lda #$9f			lda 	#((ErrorText) >> 8)
.8eaf	85 37		sta $37				sta 	1+zTemp0
.8eb1					_EHFind:
.8eb1	88		dey				dey 								; found the error text ?
.8eb2	f0 0e		beq $8ec2			beq 	_EHFound
.8eb4					_EHFindZero:
.8eb4	b2 36		lda ($36)			lda 	(zTemp0) 					; find the next error
.8eb6	e6 36		inc $36				inc 	zTemp0
.8eb8	d0 02		bne $8ebc			bne 	_EHFNoCarry
.8eba	e6 37		inc $37				inc 	zTemp0+1
.8ebc					_EHFNoCarry:
.8ebc	c9 00		cmp #$00			cmp 	#0
.8ebe	d0 f4		bne $8eb4			bne 	_EHFindZero
.8ec0	80 ef		bra $8eb1			bra 	_EHFind
.8ec2					_EHFound:
.8ec2	a5 36		lda $36				lda 	zTemp0 						; print message
.8ec4	a6 37		ldx $37				ldx 	zTemp0+1
.8ec6	20 fd 8e	jsr $8efd			jsr 	PrintStringXA
.8ec9	a0 01		ldy #$01			ldy 	#1 							; if line number zero don't print i
.8ecb	b1 30		lda ($30),y			lda 	(codePtr),y
.8ecd	d0 05		bne $8ed4			bne 	_EHAtMsg
.8ecf	c8		iny				iny
.8ed0	b1 30		lda ($30),y			lda 	(codePtr),y
.8ed2	f0 17		beq $8eeb			beq 	_EHCREnd
.8ed4					_EHAtMsg:
.8ed4	a2 8e		ldx #$8e			ldx 	#_AtMsg >> 8 				; print " at "
.8ed6	a9 f3		lda #$f3			lda 	#_AtMsg & $FF
.8ed8	20 fd 8e	jsr $8efd			jsr 	PrintStringXA
.8edb	a0 01		ldy #$01			ldy 	#1 							; line number into XA
.8edd	b1 30		lda ($30),y			lda 	(codePtr),y
.8edf	48		pha				pha
.8ee0	c8		iny				iny
.8ee1	b1 30		lda ($30),y			lda 	(codePtr),y
.8ee3	aa		tax				tax
.8ee4	68		pla				pla
.8ee5	20 13 93	jsr $9313			jsr 	LCLConvertInt16 				; convert XA to string
.8ee8	20 fd 8e	jsr $8efd			jsr 	PrintStringXA 				; and print it.
.8eeb					_EHCREnd:
.8eeb	a9 0d		lda #$0d			lda 	#13 						; new line
.8eed	20 25 a7	jsr $a725			jsr 	EXTPrintCharacter
.8ef0					_EHEnd:
.8ef0	4c 6a 83	jmp $836a			jmp 	WarmStart
>8ef3	20 61 74 20 6c 69 6e 65		_AtMsg:	.text 	" at line ",0
>8efb	20 00
.8efd					PrintStringXA:
.8efd	5a		phy				phy
.8efe	86 37		stx $37				stx 	zTemp0+1
.8f00	85 36		sta $36				sta 	zTemp0
.8f02	a0 00		ldy #$00			ldy 	#0
.8f04					_PSXALoop:
.8f04	b1 36		lda ($36),y			lda 	(zTemp0),y
.8f06	f0 06		beq $8f0e			beq 	_PSXAExit
.8f08	20 25 a7	jsr $a725			jsr 	EXTPrintCharacter
.8f0b	c8		iny				iny
.8f0c	80 f6		bra $8f04			bra 	_PSXALoop
.8f0e					_PSXAExit:
.8f0e	7a		ply				ply
.8f0f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/compare.asm

.8f10					UnaryTrue:
.8f10	fa		plx				plx
.8f11					ReturnTrue:
.8f11	a9 01		lda #$01			lda 	#1  						; set to 1
.8f13	20 b3 9d	jsr $9db3			jsr 	NSMSetByte
.8f16	a9 80		lda #$80			lda 	#$80 						; set sign flag, so it is -1
.8f18	95 50		sta $50,x			sta 	NSStatus,x
.8f1a	60		rts				rts
.8f1b					UnaryFalse:
.8f1b	fa		plx				plx
.8f1c					ReturnFalse:
.8f1c	4c b1 9d	jmp $9db1			jmp 	NSMSetZero 					; set it all to zero
.8f1f					BinaryCompareEqual:
.8f1f	fa		plx				plx
.8f20	20 5b 8f	jsr $8f5b			jsr 	CompareBaseCode
.8f23	c9 00		cmp #$00			cmp 	#0
.8f25	f0 ea		beq $8f11			beq 	ReturnTrue
.8f27	80 f3		bra $8f1c			bra 	ReturnFalse
.8f29					BinaryCompareLess:
.8f29	fa		plx				plx
.8f2a	20 5b 8f	jsr $8f5b			jsr 	CompareBaseCode
.8f2d	c9 ff		cmp #$ff			cmp 	#$FF
.8f2f	f0 e0		beq $8f11			beq 	ReturnTrue
.8f31	80 e9		bra $8f1c			bra 	ReturnFalse
.8f33					BinaryCompareGreater:
.8f33	fa		plx				plx
.8f34	20 5b 8f	jsr $8f5b			jsr 	CompareBaseCode
.8f37	c9 01		cmp #$01			cmp 	#1
.8f39	f0 d6		beq $8f11			beq 	ReturnTrue
.8f3b	80 df		bra $8f1c			bra 	ReturnFalse
.8f3d					BinaryCompareNotEqual:
.8f3d	fa		plx				plx
.8f3e	20 5b 8f	jsr $8f5b			jsr 	CompareBaseCode
.8f41	c9 00		cmp #$00			cmp 	#0
.8f43	d0 cc		bne $8f11			bne 	ReturnTrue
.8f45	80 d5		bra $8f1c			bra 	ReturnFalse
.8f47					BinaryCompareLessEqual:
.8f47	fa		plx				plx
.8f48	20 5b 8f	jsr $8f5b			jsr 	CompareBaseCode
.8f4b	c9 01		cmp #$01			cmp 	#1
.8f4d	d0 c2		bne $8f11			bne 	ReturnTrue
.8f4f	80 cb		bra $8f1c			bra 	ReturnFalse
.8f51					BinaryCompareGreaterEqual:
.8f51	fa		plx				plx
.8f52	20 5b 8f	jsr $8f5b			jsr 	CompareBaseCode
.8f55	c9 ff		cmp #$ff			cmp 	#$FF
.8f57	d0 b8		bne $8f11			bne 	ReturnTrue
.8f59	80 c1		bra $8f1c			bra 	ReturnFalse
.8f5b					CompareBaseCode:
.8f5b	20 66 96	jsr $9666			jsr 	DereferenceTopTwo 			; make both values if references.
.8f5e	b5 50		lda $50,x			lda 	NSStatus,x 					; check if either is a string.
.8f60	15 51		ora $51,x			ora 	NSStatus+1,x
.8f62	29 10		and #$10			and 	#NSTString
.8f64	d0 37		bne $8f9d			bne 	_CBCString 					; if so do string code, which will check if both.
.8f66	b5 78		lda $78,x			lda 	NSExponent,x 				; check both are integers
.8f68	15 79		ora $79,x			ora 	NSExponent+1,x
.8f6a	d0 34		bne $8fa0			bne 	_CBCFloat
.8f6c	b5 50		lda $50,x			lda 	NSStatus,x
.8f6e	15 51		ora $51,x			ora 	NSStatus+1,x
.8f70	29 08		and #$08			and 	#NSTFloat
.8f72	d0 2c		bne $8fa0			bne 	_CBCFloat
.8f74	20 a3 8f	jsr $8fa3			jsr 	CompareFixMinusZero 		; fix up -0 just in cases.
.8f77	e8		inx				inx
.8f78	20 a3 8f	jsr $8fa3			jsr 	CompareFixMinusZero
.8f7b	ca		dex				dex
.8f7c	b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs different ?
.8f7e	55 51		eor $51,x			eor 	NSStatus+1,x
.8f80	10 0a		bpl $8f8c			bpl 	_CDCSameSign
.8f82	b5 50		lda $50,x			lda 	NSStatus,x 					; if first one is -ve
.8f84	30 14		bmi $8f9a			bmi 	_CBCLess 					; return $FF
.8f86					_CBCGreater:
.8f86	a9 01		lda #$01			lda 	#1
.8f88	60		rts				rts
.8f89					_CBCEqual:
.8f89	a9 00		lda #$00			lda 	#0
.8f8b	60		rts				rts
.8f8c					_CDCSameSign:
.8f8c	20 b8 91	jsr $91b8			jsr 	SubTopTwoStack 				; unsigned subtract
.8f8f	20 d3 9d	jsr $9dd3			jsr 	NSMIsZero 					; or the mantissa together
.8f92	f0 f5		beq $8f89			beq 	_CBCEqual 					; -0 == 0
.8f94	b5 70		lda $70,x			lda 	NSMantissa3,x 				; sign of the result. if +ve return $01 else return $FF
.8f96	55 51		eor $51,x			eor 	NSStatus+1,x 				; however if both were -ve this is inverted
.8f98	10 ec		bpl $8f86			bpl 	_CBCGreater
.8f9a					_CBCLess:
.8f9a	a9 ff		lda #$ff			lda 	#$FF
.8f9c	60		rts				rts
.8f9d					_CBCString:
.8f9d	4c 29 91	jmp $9129			jmp 	CompareStrings
.8fa0					_CBCFloat:
.8fa0	4c 73 94	jmp $9473			jmp 	CompareFloat
.8fa3					CompareFixMinusZero:
.8fa3	20 d3 9d	jsr $9dd3			jsr 	NSMIsZero
.8fa6	d0 02		bne $8faa			bne 	_CFXMZNotZero
.8fa8	74 50		stz $50,x			stz 	NSStatus,x
.8faa					_CFXMZNotZero:
.8faa	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/concat.asm

.8fab					StringConcat:
.8fab	b5 50		lda $50,x			lda 	NSStatus,x 					; check both strings
.8fad	35 51		and $51,x			and 	NSStatus+1,x
.8faf	29 18		and #$18			and 	#NSBTypeMask
.8fb1	c9 10		cmp #$10			cmp 	#NSTString
.8fb3	d0 50		bne $9005			bne		_SCType
.8fb5	64 38		stz $38				stz 	zTemp1 						; counting total length
.8fb7	e8		inx				inx
.8fb8	20 d6 8f	jsr $8fd6			jsr 	_SCSetupZ0 					; setup for second
.8fbb	20 df 8f	jsr $8fdf			jsr 	_SCLengthZ0 				; length for second
.8fbe	ca		dex				dex
.8fbf	20 d6 8f	jsr $8fd6			jsr 	_SCSetupZ0 					; setup for first
.8fc2	20 df 8f	jsr $8fdf			jsr 	_SCLengthZ0 				; length for first
.8fc5	a5 38		lda $38				lda 	zTemp1 						; allocate memory using total.
.8fc7	20 dd a6	jsr $a6dd			jsr 	StringTempAllocate
.8fca	20 f6 8f	jsr $8ff6			jsr 	_SCCopy 					; copy first out, using zTemp0 from above
.8fcd	e8		inx				inx
.8fce	20 d6 8f	jsr $8fd6			jsr 	_SCSetupZ0 					; copy second out
.8fd1	20 f6 8f	jsr $8ff6			jsr 	_SCCopy
.8fd4	ca		dex				dex
.8fd5	60		rts				rts
.8fd6					_SCSetupZ0:
.8fd6	b5 58		lda $58,x			lda 	NSMantissa0,x
.8fd8	85 36		sta $36				sta 	zTemp0
.8fda	b5 60		lda $60,x			lda 	NSMantissa1,x
.8fdc	85 37		sta $37				sta 	zTemp0+1
.8fde	60		rts				rts
.8fdf					_SCLengthZ0:
.8fdf	5a		phy				phy
.8fe0	a0 00		ldy #$00			ldy 	#0
.8fe2					_SCLenLoop:
.8fe2	b1 36		lda ($36),y			lda 	(zTemp0),y
.8fe4	f0 0e		beq $8ff4			beq 	_SCLExit
.8fe6	c8		iny				iny
.8fe7	e6 38		inc $38				inc 	zTemp1
.8fe9	a5 38		lda $38				lda	 	zTemp1 						; check string too long.
.8feb	c9 fd		cmp #$fd			cmp 	#253
.8fed	d0 f3		bne $8fe2			bne		_SCLenLoop
.8fef	a9 09		lda #$09		lda	#9
.8ff1	4c a4 8e	jmp $8ea4		jmp	ErrorHandler
.8ff4					_SCLExit:
.8ff4	7a		ply				ply
.8ff5	60		rts				rts
.8ff6					_SCCopy:
.8ff6	5a		phy				phy
.8ff7	a0 00		ldy #$00			ldy 	#0
.8ff9					_SCCopyLoop:
.8ff9	b1 36		lda ($36),y			lda 	(zTemp0),y
.8ffb	f0 06		beq $9003			beq 	_SCCExit
.8ffd	20 16 a7	jsr $a716			jsr 	StringTempWrite
.9000	c8		iny				iny
.9001	80 f6		bra $8ff9			bra 	_SCCopyLoop
.9003					_SCCExit:
.9003	7a		ply				ply
.9004	60		rts				rts
.9005					_SCType:
.9005	4c 33 9f	jmp $9f33			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/divide.asm

.9008					IntegerDivide:
.9008	fa		plx				plx
.9009	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.900b	15 51		ora $51,x			ora 	NSStatus+1,x
.900d	0a		asl a				asl 	a 							; shift reference bit into sign bit
.900e	0a		asl a				asl 	a
.900f	10 05		bpl $9016			bpl 	_NotRef
.9011	48		pha				pha
.9012	20 66 96	jsr $9666			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9015	68		pla				pla
.9016					_NotRef:
.9016	0a		asl a				asl 	a
.9017	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9019	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.901b	15 79		ora $79,x			ora 	NSExponent+1,x
.901d	f0 03		beq $9022			beq 	_IntegerCode 				; if clear, then we have two integers
.901f	4c 33 9f	jmp $9f33			jmp 	TypeError 					; anything else, type mismatch.
.9022					_IntegerCode:
.9022	20 3c 90	jsr $903c			jsr 	CheckDivideZero 			; do div zero check
.9025	20 6e 90	jsr $906e			jsr 	Int32Divide 				; do the division
.9028	20 1f 91	jsr $911f			jsr 	CalculateSign 				; calculate result sign
.902b					NSMCopyPlusTwoToZero:
.902b	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.902d	95 58		sta $58,x			sta 	NSMantissa0,x
.902f	b5 62		lda $62,x			lda 	NSMantissa1+2,x
.9031	95 60		sta $60,x			sta 	NSMantissa1,x
.9033	b5 6a		lda $6a,x			lda 	NSMantissa2+2,x
.9035	95 68		sta $68,x			sta 	NSMantissa2,x
.9037	b5 72		lda $72,x			lda 	NSMantissa3+2,x
.9039	95 70		sta $70,x			sta 	NSMantissa3,x
.903b	60		rts				rts
.903c					CheckDivideZero:
.903c	e8		inx				inx
.903d	20 d3 9d	jsr $9dd3			jsr 	NSMIsZero
.9040	f0 02		beq $9044			beq 	_CDVError
.9042	ca		dex				dex
.9043	60		rts				rts
.9044					_CDVError:
.9044	a9 03		lda #$03		lda	#3
.9046	4c a4 8e	jmp $8ea4		jmp	ErrorHandler
.9049					IntegerModulus:
.9049	fa		plx				plx
.904a	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.904c	15 51		ora $51,x			ora 	NSStatus+1,x
.904e	0a		asl a				asl 	a 							; shift reference bit into sign bit
.904f	0a		asl a				asl 	a
.9050	10 05		bpl $9057			bpl 	_NotRef
.9052	48		pha				pha
.9053	20 66 96	jsr $9666			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9056	68		pla				pla
.9057					_NotRef:
.9057	0a		asl a				asl 	a
.9058	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.905a	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.905c	15 79		ora $79,x			ora 	NSExponent+1,x
.905e	f0 03		beq $9063			beq 	_IntegerCode 				; if clear, then we have two integers
.9060	4c 33 9f	jmp $9f33			jmp 	TypeError 					; anything else, type mismatch.
.9063					_IntegerCode:
.9063					IntegerModulusNoCheck:
.9063	20 3c 90	jsr $903c			jsr 	CheckDivideZero 			; do div zero check
.9066	20 6e 90	jsr $906e			jsr 	Int32Divide 				; do the division
.9069	16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.906b	56 50		lsr $50,x			lsr 	NSStatus,x
.906d	60		rts				rts
.906e					Int32Divide:
.906e	48		pha				pha 								; save AXY
.906f	5a		phy				phy
.9070	20 94 9d	jsr $9d94			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.9073	20 ad 9d	jsr $9dad			jsr 	NSMSetZeroMantissaOnly 		; set S[X] to zero
.9076	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.9078					_I32DivideLoop:
.9078	e8		inx				inx
.9079	e8		inx				inx
.907a	20 c0 9d	jsr $9dc0			jsr 	NSMShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.907d	ca		dex				dex
.907e	ca		dex				dex
.907f	20 c1 9d	jsr $9dc1			jsr 	NSMRotateLeft
.9082	20 ad 90	jsr $90ad			jsr 	DivideCheckSubtract 		; check if subtract possible
.9085	90 02		bcc $9089			bcc 	_I32DivideNoCarryIn
.9087	f6 5a		inc $5a,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.9089					_I32DivideNoCarryIn:
.9089	88		dey				dey 								; loop round till division completed.
.908a	d0 ec		bne $9078			bne 	_I32DivideLoop
.908c	7a		ply				ply 								; restore AXY and exit
.908d	68		pla				pla
.908e	60		rts				rts
.908f					Int32ShiftDivide:
.908f	48		pha				pha 								; save AY
.9090	5a		phy				phy
.9091	e8		inx				inx 								; clear S[X+2]
.9092	e8		inx				inx
.9093	20 b1 9d	jsr $9db1			jsr 	NSMSetZero
.9096	ca		dex				dex
.9097	ca		dex				dex
.9098	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.909a					_I32SDLoop:
.909a	20 ad 90	jsr $90ad			jsr 	DivideCheckSubtract 		; check if subtract possible
.909d	e8		inx				inx
.909e	e8		inx				inx
.909f	20 c1 9d	jsr $9dc1			jsr 	NSMRotateLeft				; shift 64 bit FPA left, rotating carry in
.90a2	ca		dex				dex
.90a3	ca		dex				dex
.90a4	20 c1 9d	jsr $9dc1			jsr 	NSMRotateLeft
.90a7	88		dey				dey 	 							; do 31 times
.90a8	d0 f0		bne $909a			bne 	_I32SDLoop
.90aa	7a		ply				ply 								; restore AY and exit
.90ab	68		pla				pla
.90ac	60		rts				rts
.90ad					DivideCheckSubtract:
.90ad	20 b8 91	jsr $91b8			jsr 	SubTopTwoStack 				; subtract Stack[X+1] from Stack[X+0]
.90b0	b0 04		bcs $90b6			bcs 	_DCSExit 					; if carry set, then could do, exit
.90b2	20 9e 91	jsr $919e			jsr 	AddTopTwoStack 				; add it back in
.90b5	18		clc				clc 								; and return False
.90b6					_DCSExit:
.90b6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/multiply.asm

.90b7					MulInteger:
.90b7	fa		plx				plx
.90b8	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.90ba	15 51		ora $51,x			ora 	NSStatus+1,x
.90bc	0a		asl a				asl 	a 							; shift reference bit into sign bit
.90bd	0a		asl a				asl 	a
.90be	10 05		bpl $90c5			bpl 	_NotRef
.90c0	48		pha				pha
.90c1	20 66 96	jsr $9666			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.90c4	68		pla				pla
.90c5					_NotRef:
.90c5	0a		asl a				asl 	a 							; put MSB of type into A:7
.90c6	30 09		bmi $90d1			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.90c8	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.90ca	15 79		ora $79,x			ora 	NSExponent+1,x
.90cc	f0 06		beq $90d4			beq 	_IntegerCode 				; if clear, then we have two integers
.90ce	4c 35 95	jmp $9535			jmp 	FloatingPointMultiply 							; otherwise at least one float.
.90d1					_StringData:
.90d1	4c 3d 9f	jmp $9f3d			jmp 	NotDoneError							; at least one string - don't know both are strings.
.90d4					_IntegerCode:
.90d4	20 e1 90	jsr $90e1			jsr 	MultiplyShort
.90d7	c9 00		cmp #$00			cmp 	#0
.90d9	f0 05		beq $90e0			beq 	_MIExit
.90db	a9 04		lda #$04		lda	#4
.90dd	4c a4 8e	jmp $8ea4		jmp	ErrorHandler
.90e0					_MIExit:
.90e0	60		rts				rts
.90e1					MultiplyShort:
.90e1	5a		phy				phy 								; save Y
.90e2	20 94 9d	jsr $9d94			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.90e5	20 ad 9d	jsr $9dad			jsr 	NSMSetZeroMantissaOnly 		; set mantissa S[X] to zero
.90e8	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.90ea					_I32MLoop:
.90ea	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.90ec	15 62		ora $62,x			ora 	NSMantissa1+2,x
.90ee	15 6a		ora $6a,x			ora 	NSMantissa2+2,x
.90f0	15 72		ora $72,x			ora 	NSMantissa3+2,x
.90f2	f0 25		beq $9119			beq 	_I32MExit 					; exit if zero
.90f4	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.90f6	29 01		and #$01			and 	#1
.90f8	f0 0d		beq $9107			beq 	_I32MNoAdd
.90fa	20 9e 91	jsr $919e			jsr 	AddTopTwoStack 				; if so add S[X+1] to S[X+0]
.90fd	b5 70		lda $70,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.90ff	10 06		bpl $9107			bpl 	_I32MNoAdd
.9101					_I32ShiftRight:
.9101	20 ca 9d	jsr $9dca			jsr 	NSMShiftRight 				; shift S[X] right
.9104	c8		iny				iny 								; increment shift count
.9105	80 09		bra $9110			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.9107					_I32MNoAdd:
.9107	34 71		bit $71,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.9109	70 f6		bvs $9101			bvs 	_I32ShiftRight 				; instead.
.910b	e8		inx				inx
.910c	20 c0 9d	jsr $9dc0			jsr 	NSMShiftLeft 				; shift additive S[X+1] left
.910f	ca		dex				dex
.9110					_I32MShiftUpper:
.9110	e8		inx				inx 								; shift S[X+2] right
.9111	e8		inx				inx
.9112	20 ca 9d	jsr $9dca			jsr 	NSMShiftRight
.9115	ca		dex				dex
.9116	ca		dex				dex
.9117	80 d1		bra $90ea			bra 	_I32MLoop 					; try again.
.9119					_I32MExit:
.9119	20 1f 91	jsr $911f			jsr 	CalculateSign
.911c	98		tya				tya 								; shift in A
.911d	7a		ply				ply 								; restore Y and exit
.911e	60		rts				rts
.911f					CalculateSign:
.911f	b5 50		lda $50,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.9121	16 50		asl $50,x			asl 	NSStatus,x 					; shift result left
.9123	55 51		eor $51,x			eor 	NSStatus+1,x
.9125	0a		asl a				asl 	a 							; shift bit 7 into carry
.9126	76 50		ror $50,x			ror 	NSStatus,x 					; shift right into status byte.
.9128	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/scompare.asm

.9129					CompareStrings:
.9129	b5 50		lda $50,x			lda 	NSStatus,x 					; check both are strings
.912b	35 51		and $51,x			and 	NSStatus+1,x
.912d	29 10		and #$10			and 	#NSBIsString
.912f	f0 28		beq $9159			beq 	_CSTypeError
.9131	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy string addresses to zTemp0/1
.9133	85 36		sta $36				sta 	zTemp0
.9135	b5 60		lda $60,x			lda 	NSMantissa1,x
.9137	85 37		sta $37				sta 	zTemp0+1
.9139	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.913b	85 38		sta $38				sta 	zTemp1
.913d	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.913f	85 39		sta $39				sta 	zTemp1+1
.9141	5a		phy				phy 								; save Y so we can access strings
.9142	a0 ff		ldy #$ff			ldy 	#$FF 						; -1 for pre increment.
.9144					_CSLoop:
.9144	c8		iny				iny
.9145	b1 36		lda ($36),y			lda 	(zTemp0),y 					; check if they are the same
.9147	d1 38		cmp ($38),y			cmp 	(zTemp1),y
.9149	d0 06		bne $9151			bne 	_CSDifferent
.914b	c9 00		cmp #$00			cmp 	#0 							; reached end ?
.914d	d0 f5		bne $9144			bne 	_CSLoop 					; still comparing
.914f					_CSExit:
.914f	7a		ply				ply 								; reached end, return zero in A from EOS
.9150	60		rts				rts
.9151					_CSDifferent:
.9151	a9 ff		lda #$ff			lda 	#255 						; if < return $FF
.9153	90 fa		bcc $914f			bcc		_CSExit
.9155	a9 01		lda #$01			lda 	#1 							; otherwise return 1.
.9157	80 f6		bra $914f			bra 	_CSExit
.9159					_CSTypeError:
.9159	4c 33 9f	jmp $9f33			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/shifts.asm

.915c					ShiftLeft:
.915c	38		sec				sec 								; common code, carry determines which way.
.915d	80 01		bra $9160			bra 	ShiftMain
.915f					ShiftRight:
.915f	18		clc				clc
.9160					ShiftMain:
.9160	fa		plx				plx 								; restore X
.9161	08		php				php 								; save direction
.9162	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9164	15 51		ora $51,x			ora 	NSStatus+1,x
.9166	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9167	0a		asl a				asl 	a
.9168	10 05		bpl $916f			bpl 	_NotRef
.916a	48		pha				pha
.916b	20 66 96	jsr $9666			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.916e	68		pla				pla
.916f					_NotRef:
.916f	0a		asl a				asl 	a
.9170	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9172	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9174	15 79		ora $79,x			ora 	NSExponent+1,x
.9176	f0 03		beq $917b			beq 	_IntegerCode 				; if clear, then we have two integers
.9178	4c 33 9f	jmp $9f33			jmp 	TypeError 					; anything else, type mismatch.
.917b					_IntegerCode:
.917b	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; check number < 32
.917d	29 e0		and #$e0			and 	#$E0
.917f	15 61		ora $61,x			ora 	NSMantissa1+1,x
.9181	15 69		ora $69,x			ora 	NSMantissa2+1,x
.9183	15 71		ora $71,x			ora 	NSMantissa3+1,x
.9185	d0 12		bne $9199			bne 	_SMExit0 					; if >= 32 it will always return zero.
.9187					_SMLoop:
.9187	d6 59		dec $59,x			dec 	NSMantissa0+1,x 			; predecrement, could do << 0
.9189	30 11		bmi $919c			bmi 	_SMExit 					; exit if done.
.918b	28		plp				plp 								; restore direction setting
.918c	08		php				php
.918d	90 05		bcc $9194			bcc 	_SMRight
.918f	20 c0 9d	jsr $9dc0			jsr 	NSMShiftLeft 				; shift left if CS
.9192	80 f3		bra $9187			bra 	_SMLoop
.9194					_SMRight:
.9194	20 ca 9d	jsr $9dca			jsr 	NSMShiftRight 				; shift right if CC
.9197	80 ee		bra $9187			bra 	_SMLoop
.9199					_SMExit0:
.9199	20 b1 9d	jsr $9db1			jsr 	NSMSetZero 					; return zero.
.919c					_SMExit:
.919c	28		plp				plp 								; throw direction
.919d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/simple.asm

.919e					AddTopTwoStack:
.919e	18		clc				clc
.919f	b5 58		lda $58,x			lda		NSMantissa0,x
.91a1	75 59		adc $59,x			adc 		NSMantissa0+1,x
.91a3	95 58		sta $58,x			sta 	NSMantissa0,x
.91a5	b5 60		lda $60,x			lda		NSMantissa1,x
.91a7	75 61		adc $61,x			adc 		NSMantissa1+1,x
.91a9	95 60		sta $60,x			sta 	NSMantissa1,x
.91ab	b5 68		lda $68,x			lda		NSMantissa2,x
.91ad	75 69		adc $69,x			adc 		NSMantissa2+1,x
.91af	95 68		sta $68,x			sta 	NSMantissa2,x
.91b1	b5 70		lda $70,x			lda		NSMantissa3,x
.91b3	75 71		adc $71,x			adc 		NSMantissa3+1,x
.91b5	95 70		sta $70,x			sta 	NSMantissa3,x
.91b7	60		rts				rts
.91b8					SubTopTwoStack:
.91b8	38		sec				sec
.91b9	b5 58		lda $58,x			lda		NSMantissa0,x
.91bb	f5 59		sbc $59,x			sbc 		NSMantissa0+1,x
.91bd	95 58		sta $58,x			sta 	NSMantissa0,x
.91bf	b5 60		lda $60,x			lda		NSMantissa1,x
.91c1	f5 61		sbc $61,x			sbc 		NSMantissa1+1,x
.91c3	95 60		sta $60,x			sta 	NSMantissa1,x
.91c5	b5 68		lda $68,x			lda		NSMantissa2,x
.91c7	f5 69		sbc $69,x			sbc 		NSMantissa2+1,x
.91c9	95 68		sta $68,x			sta 	NSMantissa2,x
.91cb	b5 70		lda $70,x			lda		NSMantissa3,x
.91cd	f5 71		sbc $71,x			sbc 		NSMantissa3+1,x
.91cf	95 70		sta $70,x			sta 	NSMantissa3,x
.91d1	60		rts				rts
.91d2					AddInteger:
.91d2	fa		plx				plx
.91d3	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.91d5	15 51		ora $51,x			ora 	NSStatus+1,x
.91d7	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91d8	0a		asl a				asl 	a
.91d9	10 05		bpl $91e0			bpl 	_NotRef
.91db	48		pha				pha
.91dc	20 66 96	jsr $9666			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91df	68		pla				pla
.91e0					_NotRef:
.91e0	0a		asl a				asl 	a 							; put MSB of type into A:7
.91e1	30 09		bmi $91ec			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.91e3	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91e5	15 79		ora $79,x			ora 	NSExponent+1,x
.91e7	f0 06		beq $91ef			beq 	_IntegerCode 				; if clear, then we have two integers
.91e9	4c e5 93	jmp $93e5			jmp 	FloatingPointAdd 							; otherwise at least one float.
.91ec					_StringData:
.91ec	4c ab 8f	jmp $8fab			jmp 	StringConcat							; at least one string - don't know both are strings.
.91ef					_IntegerCode:
.91ef					AddCode:
.91ef	b5 50		lda $50,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.91f1	55 51		eor $51,x			eor 	NSStatus+1,x
.91f3	10 a9		bpl $919e			bpl 	AddTopTwoStack
.91f5	20 b8 91	jsr $91b8			jsr 	SubTopTwoStack 				; do a physical subtraction
.91f8	34 70		bit $70,x			bit 	NSMantissa3,x 				; result is +ve, okay
.91fa	10 07		bpl $9203			bpl 	_AddExit
.91fc	b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign is that of 2nd value
.91fe	95 50		sta $50,x			sta 	NSStatus,x
.9200	20 7a 9d	jsr $9d7a			jsr 	NSMNegateMantissa 			; negate the mantissa and exit
.9203					_AddExit:
.9203	20 d3 9d	jsr $9dd3			jsr 	NSMIsZero 					; check for -0
.9206	d0 02		bne $920a			bne 	_AddNonZero
.9208	74 50		stz $50,x			stz 	NSStatus,x
.920a					_AddNonZero:
.920a	60		rts				rts
.920b					SubInteger:
.920b	fa		plx				plx
.920c	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.920e	15 51		ora $51,x			ora 	NSStatus+1,x
.9210	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9211	0a		asl a				asl 	a
.9212	10 05		bpl $9219			bpl 	_NotRef
.9214	48		pha				pha
.9215	20 66 96	jsr $9666			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9218	68		pla				pla
.9219					_NotRef:
.9219	0a		asl a				asl 	a 							; put MSB of type into A:7
.921a	30 09		bmi $9225			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.921c	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.921e	15 79		ora $79,x			ora 	NSExponent+1,x
.9220	f0 06		beq $9228			beq 	_IntegerCode 				; if clear, then we have two integers
.9222	4c ea 93	jmp $93ea			jmp 	FloatingPointSub 							; otherwise at least one float.
.9225					_StringData:
.9225	4c 3d 9f	jmp $9f3d			jmp 	NotDoneError							; at least one string - don't know both are strings.
.9228					_IntegerCode:
.9228	b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate the second value.
.922a	49 80		eor #$80			eor 	#$80
.922c	95 51		sta $51,x			sta 	NSStatus+1,x
.922e	80 bf		bra $91ef			bra 	AddCode 					; and do the same code as add.
.9230					AndInteger:
.9230	fa		plx				plx
.9231	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9233	15 51		ora $51,x			ora 	NSStatus+1,x
.9235	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9236	0a		asl a				asl 	a
.9237	10 05		bpl $923e			bpl 	_NotRef
.9239	48		pha				pha
.923a	20 66 96	jsr $9666			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.923d	68		pla				pla
.923e					_NotRef:
.923e	0a		asl a				asl 	a
.923f	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9241	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9243	15 79		ora $79,x			ora 	NSExponent+1,x
.9245	f0 03		beq $924a			beq 	_IntegerCode 				; if clear, then we have two integers
.9247	4c 33 9f	jmp $9f33			jmp 	TypeError 					; anything else, type mismatch.
.924a					_IntegerCode:
.924a	b5 58		lda $58,x			lda		NSMantissa0,x
.924c	35 59		and $59,x			and 		NSMantissa0+1,x
.924e	95 58		sta $58,x			sta 	NSMantissa0,x
.9250	b5 60		lda $60,x			lda		NSMantissa1,x
.9252	35 61		and $61,x			and 		NSMantissa1+1,x
.9254	95 60		sta $60,x			sta 	NSMantissa1,x
.9256	b5 68		lda $68,x			lda		NSMantissa2,x
.9258	35 69		and $69,x			and 		NSMantissa2+1,x
.925a	95 68		sta $68,x			sta 	NSMantissa2,x
.925c	b5 70		lda $70,x			lda		NSMantissa3,x
.925e	35 71		and $71,x			and 		NSMantissa3+1,x
.9260	95 70		sta $70,x			sta 	NSMantissa3,x
.9262	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.9264	60		rts				rts
.9265					OraInteger:
.9265	fa		plx				plx
.9266	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9268	15 51		ora $51,x			ora 	NSStatus+1,x
.926a	0a		asl a				asl 	a 							; shift reference bit into sign bit
.926b	0a		asl a				asl 	a
.926c	10 05		bpl $9273			bpl 	_NotRef
.926e	48		pha				pha
.926f	20 66 96	jsr $9666			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9272	68		pla				pla
.9273					_NotRef:
.9273	0a		asl a				asl 	a
.9274	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9276	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9278	15 79		ora $79,x			ora 	NSExponent+1,x
.927a	f0 03		beq $927f			beq 	_IntegerCode 				; if clear, then we have two integers
.927c	4c 33 9f	jmp $9f33			jmp 	TypeError 					; anything else, type mismatch.
.927f					_IntegerCode:
.927f	b5 58		lda $58,x			lda		NSMantissa0,x
.9281	15 59		ora $59,x			ora 		NSMantissa0+1,x
.9283	95 58		sta $58,x			sta 	NSMantissa0,x
.9285	b5 60		lda $60,x			lda		NSMantissa1,x
.9287	15 61		ora $61,x			ora 		NSMantissa1+1,x
.9289	95 60		sta $60,x			sta 	NSMantissa1,x
.928b	b5 68		lda $68,x			lda		NSMantissa2,x
.928d	15 69		ora $69,x			ora 		NSMantissa2+1,x
.928f	95 68		sta $68,x			sta 	NSMantissa2,x
.9291	b5 70		lda $70,x			lda		NSMantissa3,x
.9293	15 71		ora $71,x			ora 		NSMantissa3+1,x
.9295	95 70		sta $70,x			sta 	NSMantissa3,x
.9297	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.9299	60		rts				rts
.929a					EorInteger:
.929a	fa		plx				plx
.929b	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.929d	15 51		ora $51,x			ora 	NSStatus+1,x
.929f	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92a0	0a		asl a				asl 	a
.92a1	10 05		bpl $92a8			bpl 	_NotRef
.92a3	48		pha				pha
.92a4	20 66 96	jsr $9666			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92a7	68		pla				pla
.92a8					_NotRef:
.92a8	0a		asl a				asl 	a
.92a9	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.92ab	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92ad	15 79		ora $79,x			ora 	NSExponent+1,x
.92af	f0 03		beq $92b4			beq 	_IntegerCode 				; if clear, then we have two integers
.92b1	4c 33 9f	jmp $9f33			jmp 	TypeError 					; anything else, type mismatch.
.92b4					_IntegerCode:
.92b4	b5 58		lda $58,x			lda		NSMantissa0,x
.92b6	55 59		eor $59,x			eor 		NSMantissa0+1,x
.92b8	95 58		sta $58,x			sta 	NSMantissa0,x
.92ba	b5 60		lda $60,x			lda		NSMantissa1,x
.92bc	55 61		eor $61,x			eor 		NSMantissa1+1,x
.92be	95 60		sta $60,x			sta 	NSMantissa1,x
.92c0	b5 68		lda $68,x			lda		NSMantissa2,x
.92c2	55 69		eor $69,x			eor 		NSMantissa2+1,x
.92c4	95 68		sta $68,x			sta 	NSMantissa2,x
.92c6	b5 70		lda $70,x			lda		NSMantissa3,x
.92c8	55 71		eor $71,x			eor 		NSMantissa3+1,x
.92ca	95 70		sta $70,x			sta 	NSMantissa3,x
.92cc	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.92ce	60		rts				rts
.92cf					WordIndirect:
.92cf	fa		plx				plx
.92d0	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.92d2	15 51		ora $51,x			ora 	NSStatus+1,x
.92d4	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92d5	0a		asl a				asl 	a
.92d6	10 05		bpl $92dd			bpl 	_NotRef
.92d8	48		pha				pha
.92d9	20 66 96	jsr $9666			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92dc	68		pla				pla
.92dd					_NotRef:
.92dd	0a		asl a				asl 	a
.92de	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.92e0	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92e2	15 79		ora $79,x			ora 	NSExponent+1,x
.92e4	f0 03		beq $92e9			beq 	_IntegerCode 				; if clear, then we have two integers
.92e6	4c 33 9f	jmp $9f33			jmp 	TypeError 					; anything else, type mismatch.
.92e9					_IntegerCode:
.92e9	20 ef 91	jsr $91ef			jsr 	AddCode 					; add the two values
.92ec	a9 22		lda #$22			lda 	#NSBIsReference+2 			; make a 2 byte reference
.92ee	95 50		sta $50,x			sta 	NSStatus,x
.92f0	60		rts				rts
.92f1					ByteIndirect:
.92f1	fa		plx				plx
.92f2	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.92f4	15 51		ora $51,x			ora 	NSStatus+1,x
.92f6	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92f7	0a		asl a				asl 	a
.92f8	10 05		bpl $92ff			bpl 	_NotRef
.92fa	48		pha				pha
.92fb	20 66 96	jsr $9666			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92fe	68		pla				pla
.92ff					_NotRef:
.92ff	0a		asl a				asl 	a
.9300	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9302	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9304	15 79		ora $79,x			ora 	NSExponent+1,x
.9306	f0 03		beq $930b			beq 	_IntegerCode 				; if clear, then we have two integers
.9308	4c 33 9f	jmp $9f33			jmp 	TypeError 					; anything else, type mismatch.
.930b					_IntegerCode:
.930b	20 ef 91	jsr $91ef			jsr 	AddCode 					; add the two values
.930e	a9 21		lda #$21			lda 	#NSBIsReference+1 			; make a 1 byte reference
.9310	95 50		sta $50,x			sta 	NSStatus,x
.9312	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/tostring.asm

.9313					LCLConvertInt16:
.9313	85 58		sta $58				sta 	NSMantissa0 				; set up as 32 bit conversion
.9315	86 60		stx $60				stx 	NSMantissa1
.9317	64 68		stz $68				stz 	NSMantissa2
.9319	64 70		stz $70				stz 	NSMantissa3
.931b	64 50		stz $50				stz 	NSStatus 					; positive integer
.931d	a2 00		ldx #$00			ldx 	#0 							; stack level
.931f	a9 0a		lda #$0a			lda 	#10 						; base
.9321	80 00		bra $9323			bra 	ConvertInt32
.9323					ConvertInt32:
.9323	5a		phy				phy
.9324	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.9326	24 50		bit $50				bit 	NSStatus 					; output a - if not negative.
.9328	10 08		bpl $9332			bpl 	_CI32NotNeg
.932a	48		pha				pha
.932b	a9 2d		lda #$2d			lda 	#'-'
.932d	99 7b 05	sta $057b,y			sta 	NumberBuffer,y
.9330	c8		iny				iny
.9331	68		pla				pla
.9332					_CI32NotNeg:
.9332	20 40 93	jsr $9340			jsr 	_CI32DivideConvert 			; recursive conversion
.9335	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.9337	99 7b 05	sta $057b,y			sta 	NumberBuffer,y
.933a	7a		ply				ply
.933b	a2 05		ldx #$05			ldx 	#NumberBuffer >> 8
.933d	a9 7b		lda #$7b			lda 	#NumberBuffer & $FF
.933f	60		rts				rts
.9340					_CI32DivideConvert:
.9340	e8		inx				inx 								; write to next slot up
.9341	20 b3 9d	jsr $9db3			jsr 	NSMSetByte
.9344	ca		dex				dex
.9345	20 6e 90	jsr $906e			jsr 	Int32Divide 				; divide
.9348	b5 58		lda $58,x			lda 	NSMantissa0,x 				; save remainder
.934a	48		pha				pha
.934b	20 2b 90	jsr $902b			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.934e	20 d3 9d	jsr $9dd3			jsr 	NSMIsZero 					; is it zero ?
.9351	f0 05		beq $9358			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.9353	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.9355	20 40 93	jsr $9340			jsr 	_CI32DivideConvert 			; and recusrively call.
.9358					_CI32NoRecurse:
.9358	68		pla				pla 								; remainder
.9359	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.935b	90 02		bcc $935f			bcc 	_CI32NotHex
.935d	69 26		adc #$26			adc 	#6+32
.935f					_CI32NotHex:
.935f	69 30		adc #$30			adc 	#48
.9361	99 7b 05	sta $057b,y			sta 	NumberBuffer,y 				; write out and exit
.9364	c8		iny				iny
.9365	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/expression.asm


;******  Processing file: ./common/expressions/../generated/precedence.dat

.9366					PrecedenceLevel:
>9366	04					.byte	 4	; $00 <<
>9367	02					.byte	 2	; $01 <=
>9368	02					.byte	 2	; $02 <>
>9369	00					.byte	 0	; $03 !!3
>936a	00					.byte	 0	; $04 ><
>936b	02					.byte	 2	; $05 >=
>936c	04					.byte	 4	; $06 >>
>936d	00					.byte	 0	; $07 !!7
>936e	00					.byte	 0	; $08 !!8
>936f	00					.byte	 0	; $09 !!9
>9370	00					.byte	 0	; $0a !!10
>9371	00					.byte	 0	; $0b !!11
>9372	00					.byte	 0	; $0c !!12
>9373	00					.byte	 0	; $0d !!13
>9374	00					.byte	 0	; $0e !!14
>9375	00					.byte	 0	; $0f !!15
>9376	00					.byte	 0	; $10 @
>9377	00					.byte	 0	; $11 !!17
>9378	00					.byte	 0	; $12 !!18
>9379	00					.byte	 0	; $13 [
>937a	04					.byte	 4	; $14 \
>937b	00					.byte	 0	; $15 ]
>937c	01					.byte	 1	; $16 ^
>937d	00					.byte	 0	; $17 _
>937e	00					.byte	 0	; $18 `
>937f	00					.byte	 0	; $19 !!25
>9380	00					.byte	 0	; $1a !!26
>9381	00					.byte	 0	; $1b {
>9382	01					.byte	 1	; $1c |
>9383	00					.byte	 0	; $1d }
>9384	00					.byte	 0	; $1e ~
>9385	00					.byte	 0	; $1f [7m<7F>[m
>9386	00					.byte	 0	; $20
>9387	05					.byte	 5	; $21 !
>9388	00					.byte	 0	; $22 "
>9389	00					.byte	 0	; $23 #
>938a	05					.byte	 5	; $24 $
>938b	04					.byte	 4	; $25 %
>938c	01					.byte	 1	; $26 &
>938d	00					.byte	 0	; $27 '
>938e	00					.byte	 0	; $28 (
>938f	00					.byte	 0	; $29 )
>9390	04					.byte	 4	; $2a *
>9391	03					.byte	 3	; $2b +
>9392	00					.byte	 0	; $2c ,
>9393	03					.byte	 3	; $2d -
>9394	00					.byte	 0	; $2e .
>9395	04					.byte	 4	; $2f /
>9396	00					.byte	 0	; $30 0
>9397	00					.byte	 0	; $31 1
>9398	00					.byte	 0	; $32 2
>9399	00					.byte	 0	; $33 3
>939a	00					.byte	 0	; $34 4
>939b	00					.byte	 0	; $35 5
>939c	00					.byte	 0	; $36 6
>939d	00					.byte	 0	; $37 7
>939e	00					.byte	 0	; $38 8
>939f	00					.byte	 0	; $39 9
>93a0	00					.byte	 0	; $3a :
>93a1	00					.byte	 0	; $3b ;
>93a2	02					.byte	 2	; $3c <
>93a3	02					.byte	 2	; $3d =
>93a4	02					.byte	 2	; $3e >
>93a5	05					.byte	 5	; $3f ?

;******  Return to file: ./common/expressions/expression.asm

.93a6					EvaluateExpressionAt0:
.93a6	a2 00		ldx #$00			ldx 	#0 							; bottom stack level
.93a8					EvaluateExpression:
.93a8	a9 00		lda #$00			lda 	#0 							; lowest precedence level
.93aa					EvaluateExpressionAtPrecedence:
.93aa	48		pha				pha 								; save precedence level
.93ab	20 f2 97	jsr $97f2			jsr 	EvaluateTerm 				; evaluate term into level X.
.93ae	68		pla				pla 								; restore precedence level.
.93af					_EXPRLoop:
.93af	85 36		sta $36				sta 	zTemp0 						; save current precedence level.
.93b1	b1 30		lda ($30),y			lda 	(codePtr),y
.93b3	c9 40		cmp #$40			cmp		#$40 						; if >= $40 cannot be an operator
.93b5	b0 25		bcs $93dc			bcs 	_EXPRExit
.93b7	da		phx				phx 								; read the operator precedence
.93b8	aa		tax				tax
.93b9	bd 66 93	lda $9366,x			lda 	PrecedenceLevel,x
.93bc	fa		plx				plx
.93bd	c9 00		cmp #$00			cmp 	#0							; if zero exit (not an operator)
.93bf	f0 1b		beq $93dc			beq 	_EXPRExit
.93c1	85 37		sta $37				sta 	zTemp0+1 					; save operator precedence level.
.93c3	a5 36		lda $36				lda 	zTemp0 						; compare current precedence vs. operator precedence
.93c5	c5 37		cmp $37				cmp 	zTemp0+1
.93c7	b0 13		bcs $93dc			bcs		_EXPRExit 					; if current >= operator exit
.93c9	48		pha				pha 								; save current precedence.
.93ca	b1 30		lda ($30),y			lda 	(codePtr),y
.93cc	c8		iny				iny
.93cd	48		pha				pha
.93ce	a5 37		lda $37				lda 	zTemp0+1 					; get operator precedence level
.93d0	e8		inx				inx 								; work out the right hand side.
.93d1	20 aa 93	jsr $93aa			jsr 	EvaluateExpressionAtPrecedence
.93d4	ca		dex				dex
.93d5	68		pla				pla 								; get operator, call the code.
.93d6	20 df 93	jsr $93df			jsr 	_EXPRCaller
.93d9	68		pla				pla 								; restore precedence level
.93da	80 d3		bra $93af			bra 	_EXPRLoop 					; and go round.
.93dc					_EXPRExit:
.93dc	a5 36		lda $36				lda 	zTemp0 						; A = current precedence level.
.93de	60		rts				rts
.93df					_EXPRCaller:
.93df	da		phx				phx 								; save on stack, first thing is to restore it
.93e0	0a		asl a				asl 	a 							; double so can use vectors into X
.93e1	aa		tax				tax
.93e2	7c 66 8b	jmp ($8b66,x)			jmp 	(VectorSetPunc,x) 			; and go to the code.

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/addsub.asm

.93e5					FloatingPointAdd:
.93e5	20 5b 95	jsr $955b			jsr 	FloatPrepare 				; prepare for floats
.93e8	80 09		bra $93f3			bra 	FloatAdd
.93ea					FloatingPointSub:
.93ea	20 5b 95	jsr $955b			jsr 	FloatPrepare 				; prepare for floats
.93ed					FloatSubtract:
.93ed	b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate FPB
.93ef	49 80		eor #$80			eor 	#$80
.93f1	95 51		sta $51,x			sta 	NSStatus+1,x				; and fall through.
.93f3					FloatAdd:
.93f3	48		pha				pha
.93f4	5a		phy				phy
.93f5	20 6a 95	jsr $956a			jsr 	NSNormalise 				; normalise S[X]
.93f8	f0 51		beq $944b			beq 	_FAReturn1
.93fa	e8		inx				inx 								; normalise S[X+1]
.93fb	20 6a 95	jsr $956a			jsr 	NSNormalise
.93fe	ca		dex				dex
.93ff	c9 00		cmp #$00			cmp 	#0
.9401	f0 60		beq $9463			beq 	_FAExit 					; if so, just return A
.9403	b5 78		lda $78,x			lda 	NSExponent,x 				; are the exponents the same ?
.9405	d5 79		cmp $79,x			cmp 	NSExponent+1,x
.9407	f0 18		beq $9421			beq 	_FAExponentsEqual
.9409	b5 78		lda $78,x			lda 	NSExponent,x 				; work out the larger exponent
.940b	a8		tay				tay
.940c	38		sec				sec 								; do a signed comparison of the exponents.
.940d	f5 79		sbc $79,x			sbc 	NSExponent+1,x
.940f	50 02		bvc $9413			bvc 	_FANoSignedChange
.9411	49 80		eor #$80			eor 	#$80
.9413					_FANoSignedChange:
.9413	29 80		and #$80			and 	#$80
.9415	10 02		bpl $9419			bpl 	_FAHaveMax
.9417	b4 79		ldy $79,x			ldy 	NSExponent+1,x
.9419					_FAHaveMax:
.9419	20 66 94	jsr $9466			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.941c	e8		inx				inx
.941d	20 66 94	jsr $9466			jsr 	_FAShiftToExponent
.9420	ca		dex				dex
.9421					_FAExponentsEqual:
.9421	b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs the same
.9423	55 51		eor $51,x			eor 	NSStatus+1,x
.9425	30 0e		bmi $9435			bmi 	_FADifferentSigns
.9427	20 9e 91	jsr $919e			jsr 	AddTopTwoStack 				; do the add of the mantissae
.942a	b5 70		lda $70,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.942c	10 35		bpl $9463			bpl 	_FAExit 					; if no, we are done.
.942e	20 ca 9d	jsr $9dca			jsr 	NSMShiftRight 				; shift A right, renormalising it.
.9431	f6 78		inc $78,x			inc 	NSExponent,x 				; bump the exponent and exit
.9433	80 2e		bra $9463			bra 	_FAExit
.9435					_FADifferentSigns:
.9435	20 b8 91	jsr $91b8			jsr 	SubTopTwoStack 				; subtract mantissa B from A
.9438	b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the result negative ?
.943a	10 06		bpl $9442			bpl 	_FACheckZero 				; if no, check for -0
.943c	20 73 9d	jsr $9d73			jsr 	NSMNegate 					; netate result
.943f	20 7a 9d	jsr $9d7a			jsr 	NSMNegateMantissa 			; negate (2'c) the mantissa
.9442					_FACheckZero:
.9442	20 d3 9d	jsr $9dd3			jsr 	NSMIsZero	 				; check for -0
.9445	d0 1c		bne $9463			bne 	_FAExit
.9447	74 50		stz $50,x			stz 	NSStatus,x
.9449	80 18		bra $9463			bra 	_FAExit
.944b					_FAReturn1:
.944b	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.944d	95 58		sta $58,x			sta 	NSMantissa0,x
.944f	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9451	95 60		sta $60,x			sta 	NSMantissa1,x
.9453	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.9455	95 68		sta $68,x			sta 	NSMantissa2,x
.9457	b5 71		lda $71,x			lda 	NSMantissa3+1,x
.9459	95 70		sta $70,x			sta 	NSMantissa3,x
.945b	b5 79		lda $79,x			lda 	NSExponent+1,x
.945d	95 78		sta $78,x			sta 	NSExponent,x
.945f	b5 51		lda $51,x			lda 	NSStatus+1,x
.9461	95 50		sta $50,x			sta 	NSStatus,x
.9463					_FAExit:
.9463	7a		ply				ply
.9464	68		pla				pla
.9465	60		rts				rts
.9466					_FAShiftToExponent:
.9466					_FAShiftToExponent2:
.9466	98		tya				tya 								; compare Y to exponent
.9467	d5 78		cmp $78,x			cmp 	NSExponent,x 				; reached the exponent required ?
.9469	f0 07		beq $9472			beq 	_FASEExit 					; exit if so.
.946b	20 ca 9d	jsr $9dca			jsr 	NSMShiftRight	 			; shift the mantissa right
.946e	f6 78		inc $78,x			inc 	NSExponent,x 				; increment exponent
.9470	80 f4		bra $9466			bra 	_FAShiftToExponent2
.9472					_FASEExit:
.9472	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/compare.asm

.9473					CompareFloat:
.9473	20 ed 93	jsr $93ed			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.9476	b5 60		lda $60,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.9478	29 f8		and #$f8			and 	#$F8
.947a	15 68		ora $68,x			ora 	NSMantissa2,x
.947c	15 70		ora $70,x			ora 	NSMantissa3,x
.947e	f0 08		beq $9488			beq 	_FCExit 					; zero, so approximately identical
.9480	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.9482	34 50		bit $50,x			bit 	NSStatus,x
.9484	10 02		bpl $9488			bpl 	_FCExit
.9486					_FCNegative:
.9486	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.9488					_FCExit:
.9488	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/divide.asm

.9489					FDivideCommand:
.9489	fa		plx				plx	 								; restore stack position
.948a	20 5b 95	jsr $955b			jsr 	FloatPrepare 				; prepare for floats
.948d					FloatDivide:
.948d	48		pha				pha
.948e	e8		inx				inx
.948f	20 6a 95	jsr $956a			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.9492	ca		dex				dex
.9493	c9 00		cmp #$00			cmp 	#0
.9495	f0 1d		beq $94b4			beq 	_FDZero
.9497	20 6a 95	jsr $956a			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.949a	f0 16		beq $94b2			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.949c	20 8f 90	jsr $908f			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.949f	20 2b 90	jsr $902b			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.94a2	20 6a 95	jsr $956a			jsr		NSNormalise 				; renormalise
.94a5	20 1f 91	jsr $911f			jsr 	CalculateSign 				; calculate result sign
.94a8	b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent
.94aa	38		sec				sec
.94ab	f5 79		sbc $79,x			sbc 	NSExponent+1,x
.94ad	38		sec				sec
.94ae	e9 1e		sbc #$1e			sbc 	#30
.94b0	95 78		sta $78,x			sta 	NSExponent,x
.94b2					_FDExit:
.94b2	68		pla				pla
.94b3	60		rts				rts
.94b4					_FDZero:
.94b4	a9 03		lda #$03		lda	#3
.94b6	4c a4 8e	jmp $8ea4		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/fractional.asm

.94b9					FloatFractionalPart:
.94b9	5a		phy				phy
.94ba	b5 50		lda $50,x			lda 	NSStatus,x 					; take absolute value
.94bc	29 7f		and #$7f			and 	#$7F
.94be	95 50		sta $50,x			sta 	NSStatus,x
.94c0	20 6a 95	jsr $956a			jsr 	NSNormalise
.94c3	b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.94c5	38		sec				sec
.94c6	e9 e0		sbc #$e0			sbc 	#$E0
.94c8	90 29		bcc $94f3			bcc 	_FFPExit 					; already fractional
.94ca	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.94cc	b0 22		bcs $94f0			bcs 	_FFPZero
.94ce	a8		tay				tay 								; put count to do in Y
.94cf	b5 70		lda $70,x			lda 	NSMantissa3,x 				; do each in turn.
.94d1	20 f5 94	jsr $94f5			jsr 	_FFPPartial
.94d4	95 70		sta $70,x			sta 	NSMantissa3,x
.94d6	b5 68		lda $68,x			lda 	NSMantissa2,x
.94d8	20 f5 94	jsr $94f5			jsr 	_FFPPartial
.94db	95 68		sta $68,x			sta 	NSMantissa2,x
.94dd	b5 60		lda $60,x			lda 	NSMantissa1,x
.94df	20 f5 94	jsr $94f5			jsr 	_FFPPartial
.94e2	95 60		sta $60,x			sta 	NSMantissa1,x
.94e4	b5 58		lda $58,x			lda 	NSMantissa0,x
.94e6	20 f5 94	jsr $94f5			jsr 	_FFPPartial
.94e9	95 58		sta $58,x			sta 	NSMantissa0,x
.94eb	20 d3 9d	jsr $9dd3			jsr 	NSMIsZero 					; zeroed check.
.94ee	d0 03		bne $94f3			bne 	_FFPExit
.94f0					_FFPZero:
.94f0	20 b1 9d	jsr $9db1			jsr 	NSMSetZero
.94f3					_FFPExit:
.94f3	7a		ply				ply
.94f4	60		rts				rts
.94f5					_FFPPartial:
.94f5	c0 00		cpy #$00			cpy 	#0 							; no more to do
.94f7	f0 17		beq $9510			beq 	_FFFPPExit
.94f9	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.94fb	b0 0c		bcs $9509			bcs 	_FFFPPWholeByte
.94fd	5a		phy				phy
.94fe					_FFFPPLeft:
.94fe	0a		asl a				asl 	a
.94ff	88		dey				dey
.9500	d0 fc		bne $94fe			bne 	_FFFPPLeft
.9502	7a		ply				ply
.9503					_FFFPPRight:
.9503	4a		lsr a				lsr 	a
.9504	88		dey				dey
.9505	d0 fc		bne $9503			bne 	_FFFPPRight
.9507	80 07		bra $9510			bra 	_FFFPPExit
.9509					_FFFPPWholeByte:
.9509	98		tya				tya 								; subtract 8 from count
.950a	38		sec				sec
.950b	e9 08		sbc #$08			sbc 	#8
.950d	a8		tay				tay
.950e	a9 00		lda #$00			lda 	#0 							; and clear all
.9510					_FFFPPExit:
.9510	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/integer.asm

.9511					FloatIntegerPart:
.9511	48		pha				pha
.9512	b5 78		lda $78,x			lda 	NSExponent,x 				; is it integer already ?
.9514	f0 1d		beq $9533			beq 	_FIPExit 					; if so do nothing
.9516	20 d3 9d	jsr $9dd3			jsr 	NSMIsZero 					; is it zero ?
.9519	f0 15		beq $9530			beq 	_FIPZero 					; if so return zero.
.951b	20 6a 95	jsr $956a			jsr 	NSNormalise 				; normalise
.951e	f0 10		beq $9530			beq 	_FIPZero 					; normalised to zero, exit zero
.9520					_FIPShift:
.9520	b5 78		lda $78,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.9522	10 07		bpl $952b			bpl 	_FIPCheckZero
.9524	20 ca 9d	jsr $9dca			jsr 	NSMShiftRight 				; shift mantissa right
.9527	f6 78		inc $78,x			inc 	NSExponent,x 				; bump exponent
.9529	80 f5		bra $9520			bra 	_FIPShift
.952b					_FIPCheckZero:
.952b	20 d3 9d	jsr $9dd3			jsr 	NSMIsZero 					; avoid -0 problem
.952e	d0 03		bne $9533			bne 	_FIPExit 					; set to zero if mantissa zero.
.9530					_FIPZero:
.9530	20 b1 9d	jsr $9db1			jsr 	NSMSetZero
.9533					_FIPExit:
.9533	68		pla				pla
.9534	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/multiply.asm

.9535					FloatingPointMultiply:
.9535	20 5b 95	jsr $955b			jsr 	FloatPrepare 				; prepare for floats
.9538					FloatMultiply:
.9538	48		pha				pha
.9539	20 6a 95	jsr $956a			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.953c	f0 18		beq $9556			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.953e	e8		inx				inx
.953f	20 6a 95	jsr $956a			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.9542	ca		dex				dex
.9543	c9 00		cmp #$00			cmp 	#0
.9545	f0 0c		beq $9553			beq 	_FDSetZero
.9547	20 e1 90	jsr $90e1			jsr 	MultiplyShort 				; calculate the result.
.954a	75 78		adc $78,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.954c	18		clc				clc
.954d	75 79		adc $79,x			adc 	NSExponent+1,x
.954f	95 78		sta $78,x			sta 	NSExponent,x
.9551	80 03		bra $9556			bra 	_FDExit
.9553					_FDSetZero:
.9553	20 b1 9d	jsr $9db1			jsr 	NSMSetZero 					; return 0
.9556					_FDExit:
.9556	20 6a 95	jsr $956a			jsr 	NSNormalise 				; normalise the result
.9559	68		pla				pla
.955a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/utility.asm

.955b					FloatPrepare:
.955b	20 66 96	jsr $9666			jsr 	DereferenceTopTwo 			; dereference the top two values
.955e	b5 50		lda $50,x			lda 	NSStatus,x 					; check ints/floats
.9560	15 51		ora $51,x			ora 	NSStatus+1,x
.9562	29 10		and #$10			and 	#NSBIsString
.9564	d0 01		bne $9567			bne 	_FDType
.9566	60		rts				rts
.9567					_FDType:
.9567	4c 33 9f	jmp $9f33			jmp 	TypeError
.956a					NSNormalise:
.956a	b5 50		lda $50,x			lda 	NSStatus,x 					; make float, keep sign
.956c	29 80		and #$80			and 	#$80
.956e	09 08		ora #$08			ora 	#NSTFloat
.9570	95 50		sta $50,x			sta 	NSStatus,x
.9572	20 d3 9d	jsr $9dd3			jsr 	NSMIsZero 					; if zero exit
.9575	d0 07		bne $957e			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.9577	16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.9579	76 50		ror $50,x			ror 	NSStatus,x 					; (no -0)
.957b	a9 00		lda #$00			lda 	#0 							; set Z flag
.957d	60		rts				rts
.957e					_NSNormaliseOptimise:
.957e	b5 70		lda $70,x			lda 	NSMantissa3,x 				; upper byte zero ?
.9580	d0 19		bne $959b			bne 	_NSNormaliseLoop
.9582	b5 68		lda $68,x			lda 	NSMantissa2,x 				; byte normalise
.9584	30 15		bmi $959b			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.9586	95 70		sta $70,x			sta 	NSMantissa3,x
.9588	b5 60		lda $60,x			lda 	NSMantissa1,x
.958a	95 68		sta $68,x			sta 	NSMantissa2,x
.958c	b5 58		lda $58,x			lda 	NSMantissa0,x
.958e	95 60		sta $60,x			sta 	NSMantissa1,x
.9590	74 58		stz $58,x			stz 	NSMantissa0,x
.9592	b5 78		lda $78,x			lda 	NSExponent,x
.9594	38		sec				sec
.9595	e9 08		sbc #$08			sbc 	#8
.9597	95 78		sta $78,x			sta 	NSExponent,x
.9599	80 e3		bra $957e			bra 	_NSNormaliseOptimise
.959b					_NSNormaliseLoop:
.959b	34 70		bit $70,x			bit 	NSMantissa3,x 				; bit 30 set ?
.959d	70 07		bvs $95a6			bvs 	_NSNExit 					; exit if so with Z flag clear
.959f	20 c0 9d	jsr $9dc0			jsr 	NSMShiftLeft 				; shift mantissa left
.95a2	d6 78		dec $78,x			dec 	NSExponent,x 				; adjust exponent
.95a4	80 f5		bra $959b			bra 	_NSNormaliseLoop
.95a6					_NSNExit:
.95a6	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.95a8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignnumber.asm

.95a9					AssignNumber:
.95a9	5a		phy				phy
.95aa	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy mantissa0/1 to zTemp0
.95ac	85 36		sta $36				sta 	zTemp0
.95ae	b5 60		lda $60,x			lda 	NSMantissa1,x
.95b0	85 37		sta $37				sta 	zTemp0+1
.95b2	b5 50		lda $50,x			lda 	NSStatus,x 					; clear reference bits
.95b4	29 df		and #$df			and 	#(NSBIsReference ^ $FF)
.95b6	95 50		sta $50,x			sta 	NSStatus,x
.95b8	29 18		and #$18			and 	#NSBTypeMask				; assigning to a float ?
.95ba	c9 08		cmp #$08			cmp 	#NSTFloat
.95bc	f0 24		beq $95e2			beq 	_ANFloat
.95be	b5 79		lda $79,x			lda		NSExponent+1,x 				; is it a float
.95c0	f0 03		beq $95c5			beq		_ANNotFloat
.95c2	4c 2e 9f	jmp $9f2e			jmp 	RangeError
.95c5					_ANNotFloat:
.95c5	b5 50		lda $50,x			lda 	NSStatus,x 					; check if byte/word reference.
.95c7	29 03		and #$03			and 	#3
.95c9	d0 05		bne $95d0			bne 	_ANByteWord
.95cb	20 ed 95	jsr $95ed			jsr 	_ANCopy4PackSign 			; copy all 4 bytes and sign
.95ce	80 1b		bra $95eb			bra 	_ANExit
.95d0					_ANByteWord:
.95d0	48		pha				pha 								; save count
.95d1	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; do byte
.95d3	92 36		sta ($36)			sta 	(zTemp0)
.95d5	68		pla				pla
.95d6	c9 01		cmp #$01			cmp	 	#1
.95d8	f0 11		beq $95eb			beq 	_ANExit
.95da	b5 61		lda $61,x			lda 	NSMantissa1+1,x 			; do word
.95dc	a0 01		ldy #$01			ldy 	#1
.95de	91 36		sta ($36),y			sta 	(zTemp0),y
.95e0	80 09		bra $95eb			bra 	_ANExit
.95e2					_ANFloat:
.95e2	20 ed 95	jsr $95ed			jsr 	_ANCopy4PackSign 			; write all 4 bytes and packed sign
.95e5	b5 79		lda $79,x			lda 	NSExponent+1,x 				; copy exponent to slot 4
.95e7	a0 04		ldy #$04			ldy 	#4
.95e9	91 36		sta ($36),y			sta 	(zTemp0),y
.95eb					_ANExit:
.95eb	7a		ply				ply
.95ec	60		rts				rts
.95ed					_ANCopy4PackSign:
.95ed	a0 03		ldy #$03			ldy 	#3
.95ef	b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign bit into status
.95f1	29 80		and #$80			and 	#$80 						; put into high bit of mantissa 3
.95f3	15 71		ora $71,x			ora 	NSMantissa3+1,x
.95f5	91 36		sta ($36),y			sta 	(zTemp0),y
.95f7	88		dey				dey
.95f8	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.95fa	91 36		sta ($36),y			sta 	(zTemp0),y
.95fc	88		dey				dey
.95fd	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.95ff	91 36		sta ($36),y			sta 	(zTemp0),y
.9601	88		dey				dey
.9602	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9604	91 36		sta ($36),y			sta 	(zTemp0),y
.9606	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignstring.asm

.9607					AssignString:
.9607	5a		phy				phy
.9608	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.960a	85 38		sta $38				sta 	zTemp1
.960c	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.960e	85 39		sta $39				sta 	zTemp1+1
.9610	b5 58		lda $58,x			lda 	NSMantissa0,x
.9612	85 36		sta $36				sta 	zTemp0
.9614	b5 60		lda $60,x			lda 	NSMantissa1,x
.9616	85 37		sta $37				sta 	zTemp0+1
.9618	a0 01		ldy #$01			ldy 	#1 							; the high byte of the target address
.961a	b1 36		lda ($36),y			lda 	(zTemp0),y
.961c	f0 23		beq $9641			beq 	_ASNewStringRequired 		; if zero, a new string is required.
.961e	38		sec				sec 								; put Address-2 in zsTemp - this is the size/status/string record
.961f	b2 36		lda ($36)			lda 	(zTemp0) 					; of concreted strings
.9621	e9 02		sbc #$02			sbc 	#2
.9623	85 3c		sta $3c				sta 	zsTemp
.9625	a0 01		ldy #$01			ldy 	#1
.9627	b1 36		lda ($36),y			lda 	(zTemp0),y
.9629	e9 00		sbc #$00			sbc 	#0
.962b	85 3d		sta $3d				sta 	zsTemp+1
.962d	a0 ff		ldy #$ff			ldy 	#$FF 						; get length of new string
.962f					_ASGetLength:
.962f	c8		iny				iny
.9630	b1 38		lda ($38),y			lda 	(zTemp1),y
.9632	d0 fb		bne $962f			bne 	_ASGetLength
.9634	98		tya				tya 								; is this length <= current length
.9635	d2 3c		cmp ($3c)			cmp 	(zsTemp)
.9637	90 1e		bcc $9657			bcc 	_ASCopyString
.9639	f0 1c		beq $9657			beq 	_ASCopyString
.963b	a9 80		lda #$80			lda 	#$80 						; mark as unused.
.963d	a0 01		ldy #$01			ldy 	#1
.963f	91 3c		sta ($3c),y			sta 	(zsTemp),y
.9641					_ASNewStringRequired:
.9641	e8		inx				inx 								; concrete the new string.
.9642	20 60 a6	jsr $a660			jsr 	StringConcrete				; (breaks zTemp1/2, not zTemp0 and zsTemp)
.9645	ca		dex				dex
.9646	18		clc				clc
.9647	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy that new address to the reference.
.9649	69 02		adc #$02			adc 	#2 							; add two to point at the data.
.964b	92 36		sta ($36)			sta 	(zTemp0)
.964d	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.964f	69 00		adc #$00			adc 	#0
.9651	a0 01		ldy #$01			ldy 	#1
.9653	91 36		sta ($36),y			sta 	(zTemp0),y
.9655	80 0d		bra $9664			bra 	_ASExit
.9657					_ASCopyString:
.9657	a0 00		ldy #$00			ldy 	#0
.9659					_ASCopyLoop:
.9659	b1 38		lda ($38),y			lda 	(zTemp1),y
.965b	c8		iny				iny
.965c	c8		iny				iny
.965d	91 3c		sta ($3c),y			sta 	(zsTemp),y
.965f	88		dey				dey
.9660	c9 00		cmp #$00			cmp 	#0
.9662	d0 f5		bne $9659			bne 	_ASCopyLoop
.9664					_ASExit:
.9664	7a		ply				ply
.9665	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/dereference.asm

.9666					DereferenceTopTwo:
.9666	e8		inx				inx
.9667	20 6b 96	jsr $966b			jsr 	Dereference 				; deref x+1
.966a	ca		dex				dex  								; falls through to deref x
.966b					Dereference:
.966b	b5 50		lda $50,x			lda 	NSStatus,x 					; get the status byte
.966d	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.966f	f0 48		beq $96b9			beq 	_DRFExit 					; not a reference, so exit.
.9671	5a		phy				phy
.9672	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address to dereference into zTemp0
.9674	85 36		sta $36				sta 	zTemp0
.9676	b5 60		lda $60,x			lda 	NSMantissa1,x
.9678	85 37		sta $37				sta 	zTemp0+1
.967a	74 60		stz $60,x			stz 	NSMantissa1,x 				; clear second byte.
.967c	b2 36		lda ($36)			lda 	(zTemp0) 					; do the first byte
.967e	95 58		sta $58,x			sta 	NSMantissa0,x
.9680	b5 50		lda $50,x			lda 	NSStatus,x 					; get status byte.
.9682	29 18		and #$18			and 	#NSBTypeMask 				; what type is it ?
.9684	c9 10		cmp #$10			cmp 	#NSTString 					; if string, dereference two
.9686	f0 0e		beq $9696			beq 	_DRFDereferenceTwo
.9688	c9 08		cmp #$08			cmp 	#NSTFloat 					; if float, do full dereference.
.968a	f0 2f		beq $96bb			beq 	_DRFFull
.968c	b5 50		lda $50,x			lda 	NSStatus,x 					; must be integer - how many bytes ?
.968e	29 03		and #$03			and 	#3
.9690	f0 29		beq $96bb			beq 	_DRFFull 					; the whole word
.9692	c9 01		cmp #$01			cmp 	#1 							; is it 10 (e.g. 2 bytes)
.9694	f0 06		beq $969c			beq		_DRFClear23 				; no, one byte, clear 2 & 3 and exit
.9696					_DRFDereferenceTwo:
.9696	a0 01		ldy #$01			ldy 	#1
.9698	b1 36		lda ($36),y			lda 	(zTemp0),y
.969a	95 60		sta $60,x			sta 	NSMantissa1,x
.969c					_DRFClear23:
.969c	74 68		stz $68,x			stz 	NSMantissa2,x 				; clear upper bytes, only read 1 or 2 bytes
.969e	74 70		stz $70,x			stz 	NSMantissa3,x
.96a0	b5 50		lda $50,x			lda 	NSStatus,x 					; make it a value of that type.
.96a2	29 18		and #$18			and 	#NSBTypeMask
.96a4	95 50		sta $50,x			sta 	NSStatus,x 					; and fall through.
.96a6	c9 10		cmp #$10			cmp 	#NSTString  				; is it a string
.96a8	d0 0e		bne $96b8			bne 	_DRFNotString
.96aa	b5 58		lda $58,x			lda 	NSMantissa0,x 				; check address is zero
.96ac	15 60		ora $60,x			ora 	NSMantissa1,x
.96ae	d0 08		bne $96b8			bne 	_DRFNotString
.96b0	a9 ba		lda #$ba			lda 	#_DRFNullString & $FF 		; if so, return reference to ""
.96b2	95 58		sta $58,x			sta 	NSMantissa0,X
.96b4	a9 96		lda #$96			lda 	#_DRFNullString >> 8
.96b6	95 60		sta $60,x			sta 	NSMantissa1,X
.96b8					_DRFNotString
.96b8	7a		ply				ply 								; restore Y and exit
.96b9					_DRFExit:
.96b9	60		rts				rts
.96ba					_DRFNullString:
>96ba	00						.byte 	0
.96bb					_DRFFull:
.96bb	a0 01		ldy #$01			ldy 	#1 							; get remaining 3 bytes.
.96bd	b1 36		lda ($36),y			lda 	(zTemp0),y
.96bf	95 60		sta $60,x			sta 	NSMantissa1,x
.96c1	c8		iny				iny
.96c2	b1 36		lda ($36),y			lda 	(zTemp0),y
.96c4	95 68		sta $68,x			sta 	NSMantissa2,x
.96c6	c8		iny				iny
.96c7	b1 36		lda ($36),y			lda 	(zTemp0),y
.96c9	95 70		sta $70,x			sta 	NSMantissa3,x
.96cb	74 78		stz $78,x			stz 	NSExponent,x 				; clear exponent.
.96cd	b5 50		lda $50,x			lda		NSStatus,x 					; see if type is integer
.96cf	29 18		and #$18			and 	#NSBTypeMask  				; type information only
.96d1	95 50		sta $50,x			sta 	NSStatus,x 					; update it back.
.96d3	f0 05		beq $96da			beq 	_DRFNoExponent
.96d5	c8		iny				iny 								; if not, read the exponent as well.
.96d6	b1 36		lda ($36),y			lda 	(zTemp0),y
.96d8	95 78		sta $78,x			sta 	NSExponent,x
.96da					_DRFNoExponent:
.96da	b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the most significant bit set ?
.96dc	10 0a		bpl $96e8			bpl 	_DRFExit2 					; if not, then exit.
.96de	29 7f		and #$7f			and 	#$7F 						; clear that bit.
.96e0	95 70		sta $70,x			sta 	NSMantissa3,x
.96e2	b5 50		lda $50,x			lda 	NSStatus,x 					; set the sign flag
.96e4	09 80		ora #$80			ora 	#NSBIsNegative
.96e6	95 50		sta $50,x			sta 	NSStatus,x
.96e8					_DRFExit2:
.96e8	7a		ply				ply
.96e9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/number.asm

=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.96ea					EncodeNumberStart:
.96ea	38		sec				sec
.96eb	80 01		bra $96ee			bra 	EncodeNumberContinue+1
.96ed					EncodeNumberContinue:
.96ed	18		clc				clc
.96ee					EncodeNumber:
.96ee	08		php				php 								; save reset flag.
.96ef	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.96f1	f0 12		beq $9705			beq 	_ENIsOkay
.96f3	c9 30		cmp #$30			cmp 	#"0"
.96f5	90 04		bcc $96fb			bcc 	_ENBadNumber
.96f7	c9 3a		cmp #$3a			cmp 	#"9"+1
.96f9	90 0a		bcc $9705			bcc 	_ENIsOkay
.96fb					_ENBadNumber:
.96fb	28		plp				plp 								; throw saved reset
.96fc	ad 05 04	lda $0405			lda 	EncodeState 				; if in decimal mode, construct final number
.96ff	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.9701	f0 7b		beq $977e			beq 	_ENConstructFinal
.9703					_ENFail:
.9703	18		clc				clc 								; not allowed
.9704	60		rts				rts
.9705					_ENIsOkay:
.9705	28		plp				plp 								; are we restarting
.9706	90 15		bcc $971d			bcc 	_ENNoRestart
.9708					_ENStartEncode:
.9708	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.970a	f0 0c		beq $9718			beq 	_ENFirstDP
.970c	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.970e	20 b3 9d	jsr $9db3			jsr 	NSMSetByte 					; in single byte mode.
.9711	a9 01		lda #$01			lda 	#ESTA_Low
.9713					_ENExitChange:
.9713	8d 05 04	sta $0405			sta 	EncodeState 				; save new state
.9716	38		sec				sec
.9717	60		rts				rts
.9718					_ENFirstDP:
.9718	20 b1 9d	jsr $9db1			jsr 	NSMSetZero 					; clear integer part
.971b	80 3c		bra $9759			bra 	_ESTASwitchFloat			; go straight to float and exi
.971d					_ENNoRestart:
.971d	48		pha				pha 								; save digit or DP on stack.
.971e	ad 05 04	lda $0405			lda 	EncodeState 				; get current state
.9721	c9 01		cmp #$01			cmp 	#ESTA_Low
.9723	f0 09		beq $972e			beq  	_ESTALowState
.9725	c9 02		cmp #$02			cmp 	#ESTA_High
.9727	f0 26		beq $974f			beq 	_ESTAHighState
.9729	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.972b	f0 38		beq $9765			beq 	_ESTADecimalState
>972d	db						.byte 	$DB 						; causes a break in the emulator
.972e					_ESTALowState:
.972e	68		pla				pla 								; get value back
.972f	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.9731	f0 26		beq $9759			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.9733	29 0f		and #$0f			and 	#15 						; make digit
.9735	8d 06 04	sta $0406			sta 	DigitTemp 					; save it.
.9738	b5 58		lda $58,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.973a	0a		asl a				asl 	a
.973b	0a		asl a				asl 	a
.973c	75 58		adc $58,x			adc 	NSMantissa0,x
.973e	0a		asl a				asl 	a
.973f	6d 06 04	adc $0406			adc 	DigitTemp
.9742	95 58		sta $58,x			sta 	NSMantissa0,x
.9744	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.9746	90 05		bcc $974d			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.9748	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.974a	8d 05 04	sta $0405			sta 	EncodeState
.974d					_ESTANoSwitch:
.974d	38		sec				sec
.974e	60		rts				rts
.974f					_ESTAHighState:
.974f	68		pla				pla 								; get value back
.9750	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.9752	f0 05		beq $9759			beq 	_ESTASwitchFloat
.9754	20 b2 97	jsr $97b2			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.9757	38		sec				sec
.9758	60		rts				rts
.9759					_ESTASwitchFloat:
.9759	9c 07 04	stz $0407			stz 	DecimalCount 				; reset the count of digits - we divide by 10^n at the end.
.975c	e8		inx				inx 								; zero the decimal additive.
.975d	20 b1 9d	jsr $9db1			jsr 	NSMSetZero
.9760	ca		dex				dex
.9761	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.9763	80 ae		bra $9713			bra 	_ENExitChange
.9765					_ESTADecimalState:
.9765	68		pla				pla 								; digit.
.9766	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 2nd decimal point.
.9768	f0 99		beq $9703			beq 	_ENFail
.976a	e8		inx				inx 								; put digit into fractional part of X+1
.976b	20 b2 97	jsr $97b2			jsr 	ESTAShiftDigitIntoMantissa
.976e	ca		dex				dex
.976f	ee 07 04	inc $0407			inc 	DecimalCount 				; bump the count of decimals
.9772	ad 07 04	lda $0407			lda 	DecimalCount 				; too many decimal digits.
.9775	c9 0b		cmp #$0b			cmp 	#11
.9777	f0 02		beq $977b			beq 	_ESTADSFail
.9779	38		sec				sec
.977a	60		rts				rts
.977b					_ESTADSFail:
.977b	4c 2e 9f	jmp $9f2e			jmp 	RangeError
.977e					_ENConstructFinal:
.977e	ad 07 04	lda $0407			lda 	DecimalCount 				; get decimal count
.9781	f0 2d		beq $97b0			beq 	_ENCFExit 					; no decimals
.9783	5a		phy				phy
.9784	0a		asl a				asl 	a 							; x 4 and CLC
.9785	0a		asl a				asl 	a
.9786	6d 07 04	adc $0407			adc 	DecimalCount
.9789	a8		tay				tay
.978a	b9 ed 9e	lda $9eed,y			lda 	DecimalScalarTable-5,y 		; copy decimal scalar to X+2
.978d	95 5a		sta $5a,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.978f	b9 ee 9e	lda $9eee,y			lda 	DecimalScalarTable-5+1,y
.9792	95 62		sta $62,x			sta 	NSMantissa1+2,x
.9794	b9 ef 9e	lda $9eef,y			lda 	DecimalScalarTable-5+2,y
.9797	95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.9799	b9 f0 9e	lda $9ef0,y			lda 	DecimalScalarTable-5+3,y
.979c	95 72		sta $72,x			sta 	NSMantissa3+2,x
.979e	b9 f1 9e	lda $9ef1,y			lda 	DecimalScalarTable-5+4,y
.97a1	95 7a		sta $7a,x			sta 	NSExponent+2,x
.97a3	a9 08		lda #$08			lda 	#NSTFloat
.97a5	95 52		sta $52,x			sta 	NSStatus+2,x
.97a7	7a		ply				ply
.97a8	e8		inx				inx 								; multiply decimal const by decimal scalar
.97a9	20 38 95	jsr $9538			jsr 	FloatMultiply
.97ac	ca		dex				dex
.97ad	20 f3 93	jsr $93f3			jsr 	FloatAdd 					; add to integer part.
.97b0					_ENCFExit:
.97b0	18		clc				clc 								; reject the digit.
.97b1	60		rts				rts
.97b2					ESTAShiftDigitIntoMantissa:
.97b2	29 0f		and #$0f			and 	#15 						; save digit
.97b4	48		pha				pha
.97b5	b5 70		lda $70,x			lda 	NSMantissa3,x 				; push mantissa on stack
.97b7	48		pha				pha
.97b8	b5 68		lda $68,x			lda 	NSMantissa2,x
.97ba	48		pha				pha
.97bb	b5 60		lda $60,x			lda 	NSMantissa1,x
.97bd	48		pha				pha
.97be	b5 58		lda $58,x			lda 	NSMantissa0,x
.97c0	48		pha				pha
.97c1	20 c0 9d	jsr $9dc0			jsr 	NSMShiftLeft 				; x 2
.97c4	20 c0 9d	jsr $9dc0			jsr 	NSMShiftLeft 				; x 4
.97c7	18		clc				clc 								; pop mantissa and add
.97c8	68		pla				pla
.97c9	75 58		adc $58,x			adc 	NSMantissa0,x
.97cb	95 58		sta $58,x			sta 	NSMantissa0,x
.97cd	68		pla				pla
.97ce	75 60		adc $60,x			adc 	NSMantissa1,x
.97d0	95 60		sta $60,x			sta 	NSMantissa1,x
.97d2	68		pla				pla
.97d3	75 68		adc $68,x			adc 	NSMantissa2,x
.97d5	95 68		sta $68,x			sta 	NSMantissa2,x
.97d7	68		pla				pla
.97d8	75 70		adc $70,x			adc 	NSMantissa3,x
.97da	95 70		sta $70,x			sta 	NSMantissa3,x 				; x 5
.97dc	20 c0 9d	jsr $9dc0			jsr 	NSMShiftLeft 				; x 10
.97df	68		pla				pla 								; add digit
.97e0	18		clc				clc
.97e1	75 58		adc $58,x			adc 	NSMantissa0,x
.97e3	95 58		sta $58,x			sta 	NSMantissa0,x
.97e5	90 0a		bcc $97f1			bcc 	_ESTASDExit
.97e7	f6 60		inc $60,x			inc 	NSMantissa1,x
.97e9	d0 06		bne $97f1			bne 	_ESTASDExit
.97eb	f6 68		inc $68,x			inc 	NSMantissa2,x
.97ed	d0 02		bne $97f1			bne 	_ESTASDExit
.97ef	f6 70		inc $70,x			inc 	NSMantissa3,x
.97f1					_ESTASDExit:
.97f1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/term.asm

.97f2					EvaluateTerm:
.97f2	b1 30		lda ($30),y			lda 	(codePtr),y
.97f4	30 18		bmi $980e			bmi 	_ETCheckUnary 				; unary function ? (text ones)
.97f6	c9 40		cmp #$40			cmp 	#$40 						; 40-7F => identifier reference
.97f8	b0 6c		bcs $9866			bcs 	_ETVariable
.97fa	c9 30		cmp #$30			cmp 	#'0' 						; is it a number
.97fc	90 6b		bcc $9869			bcc 	_ETPuncUnary 				; if not it might be a punctuation unary.
.97fe	c9 3a		cmp #$3a			cmp 	#'9'+1
.9800	b0 67		bcs $9869			bcs 	_ETPuncUnary
.9802	20 ea 96	jsr $96ea			jsr 	EncodeNumberStart 			; can't fail as it's 0-9 !
.9805					_ETNumber:
.9805	c8		iny				iny 								; keep encoding until we have the numbers
.9806	b1 30		lda ($30),y			lda 	(codePtr),y
.9808	20 ed 96	jsr $96ed			jsr 	EncodeNumberContinue
.980b	b0 f8		bcs $9805			bcs 	_ETNumber 					; go back if accepted.
.980d	60		rts				rts
.980e					_ETCheckUnary:
.980e	c9 ff		cmp #$ff			cmp 	#KWC_STRING 				; string token
.9810	f0 3f		beq $9851			beq 	_ETString
.9812	c9 fe		cmp #$fe			cmp 	#KWC_HEXCONST 				; hex constant.
.9814	f0 12		beq $9828			beq 	_ETHexConstant
.9816	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; check it actually is a unary function
.9818	90 0b		bcc $9825			bcc 	_ETSyntaxError
.981a	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1
.981c	b0 07		bcs $9825			bcs 	_ETSyntaxError
.981e	da		phx				phx 								; push X on the stack
.981f	0a		asl a				asl 	a 							; put vector x 2 into X
.9820	aa		tax				tax
.9821	c8		iny				iny 								; consume unary function token
.9822	7c e6 8b	jmp ($8be6,x)			jmp 	(VectorSet0,x) 				; and do it.
.9825					_ETSyntaxError:
.9825	4c 29 9f	jmp $9f29			jmp 	SyntaxError
.9828					_ETHexConstant:
.9828	c8		iny				iny 								; skip #
.9829	c8		iny				iny 								; skip count
.982a	20 b1 9d	jsr $9db1			jsr 	NSMSetZero 					; clear result
.982d					_ETHLoop:
.982d	b1 30		lda ($30),y			lda 	(codePtr),y
.982f	c8		iny				iny 								; and consume
.9830	c9 00		cmp #$00			cmp 	#0 							; exit if zero
.9832	f0 1c		beq $9850			beq 	_ETHExit
.9834	48		pha				pha 								; save on stack.
.9835	20 c0 9d	jsr $9dc0			jsr 	NSMShiftLeft 				; x 2
.9838	20 c0 9d	jsr $9dc0			jsr 	NSMShiftLeft 				; x 4
.983b	20 c0 9d	jsr $9dc0			jsr 	NSMShiftLeft 				; x 8
.983e	20 c0 9d	jsr $9dc0			jsr 	NSMShiftLeft 				; x 16
.9841	68		pla				pla 								; ASCII
.9842	c9 41		cmp #$41			cmp 	#'A'
.9844	90 02		bcc $9848			bcc 	_ETHNotChar
.9846	e9 07		sbc #$07			sbc 	#7
.9848					_ETHNotChar:
.9848	29 0f		and #$0f			and 	#15 						; digit now
.984a	15 58		ora $58,x			ora 	NSMantissa0,x 				; put in LS Nibble
.984c	95 58		sta $58,x			sta 	NSMantissa0,x
.984e	80 dd		bra $982d			bra 	_ETHLoop 					; go round.
.9850					_ETHExit:
.9850	60		rts				rts
.9851					_ETString:
.9851	c8		iny				iny 								; look at length
.9852	b1 30		lda ($30),y			lda 	(codePtr),y
.9854	48		pha				pha
.9855	c8		iny				iny 								; first character
.9856	20 06 a5	jsr $a506			jsr 	MemoryInline 				; put address of string at (code-Ptr),y on stack
.9859	68		pla				pla 								; restore count and save
.985a	85 36		sta $36				sta 	zTemp0
.985c	98		tya				tya 								; add length to Y to skip it.
.985d	18		clc				clc
.985e	65 36		adc $36				adc 	zTemp0
.9860	a8		tay				tay
.9861	a9 10		lda #$10			lda 	#NSTString 					; mark as string
.9863	95 50		sta $50,x			sta 	NSStatus,x
.9865	60		rts				rts
.9866					_ETVariable:
.9866	4c bb 98	jmp $98bb			jmp 	VariableHandler
.9869					_ETPuncUnary:
.9869	c8		iny				iny 								; consume the unary character
.986a	c9 2d		cmp #$2d			cmp 	#KWD_MINUS 					; unary minus
.986c	f0 2b		beq $9899			beq 	_ETUnaryNegate
.986e	c9 10		cmp #$10			cmp 	#KWD_AT 					; @ reference -> constant
.9870	f0 36		beq $98a8			beq 	_ETDereference
.9872	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; parenthesis
.9874	f0 3e		beq $98b4			beq 	_ETParenthesis
.9876	64 36		stz $36				stz 	zTemp0 						; zTemp0 is the indirection level.
.9878	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; byte indirection (0) ?
.987a	f0 06		beq $9882			beq 	_ETIndirection
.987c	e6 36		inc $36				inc 	zTemp0
.987e	c9 21		cmp #$21			cmp 	#KWD_PLING					; word indirection (1) \
.9880	d0 a3		bne $9825			bne 	_ETSyntaxError
.9882					_ETIndirection:
.9882	a5 36		lda $36				lda 	zTemp0 						; push indirection amount (0-1) => (1-2) on the stack
.9884	1a		inc a				inc 	a
.9885	48		pha				pha
.9886	20 f2 97	jsr $97f2			jsr 	EvaluateTerm				; evaluate the term
.9889	20 6b 96	jsr $966b			jsr 	Dereference 				; dereference it.
.988c	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a +ve integer.
.988e	d0 06		bne $9896			bne 	_ETTypeMismatch
.9890	68		pla				pla 								; indirection 1-2
.9891	09 20		ora #$20			ora 	#NSBIsReference 			; make it a reference.
.9893	95 50		sta $50,x			sta 	NSStatus,x
.9895	60		rts				rts
.9896					_ETTypeMismatch:
.9896	4c 33 9f	jmp $9f33			jmp 	TypeError
.9899					_ETUnaryNegate:
.9899	20 f2 97	jsr $97f2			jsr 	EvaluateTerm				; evaluate the term
.989c	20 6b 96	jsr $966b			jsr 	Dereference 				; dereference it.
.989f	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a number
.98a1	29 10		and #$10			and 	#NSTString
.98a3	d0 f1		bne $9896			bne 	_ETTypeMismatch
.98a5	4c 73 9d	jmp $9d73			jmp 	NSMNegate  					; just toggles the sign bit.
.98a8					_ETDereference:
.98a8	20 f2 97	jsr $97f2			jsr 	EvaluateTerm				; evaluate the term
.98ab	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a reference
.98ad	29 20		and #$20			and 	#NSBIsReference
.98af	f0 e5		beq $9896			beq 	_ETTypeMismatch
.98b1	74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer address
.98b3	60		rts				rts
.98b4					_ETParenthesis:
.98b4	20 a8 93	jsr $93a8			jsr 	EvaluateExpression 			; evaluate here, from lowest precedence
.98b7	20 8b 8e	jsr $8e8b			jsr 	CheckRightBracket 			; check for )
.98ba	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/variable.asm

.98bb					VariableHandler:
.98bb	b1 30		lda ($30),y			lda 	(codePtr),y
.98bd	18		clc				clc
.98be	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.98c0	85 37		sta $37				sta 	zTemp0+1
.98c2	c8		iny				iny
.98c3	b1 30		lda ($30),y			lda 	(codePtr),y
.98c5	85 36		sta $36				sta 	zTemp0
.98c7	c8		iny				iny
.98c8	18		clc				clc									; copy variable address+3 to mantissa
.98c9	69 03		adc #$03			adc 	#3
.98cb	95 58		sta $58,x			sta 	NSMantissa0,x
.98cd	a5 37		lda $37				lda 	zTemp0+1
.98cf	69 00		adc #$00			adc 	#0
.98d1	95 60		sta $60,x			sta 	NSMantissa1,x
.98d3	74 68		stz $68,x			stz 	NSMantissa2,x
.98d5	74 70		stz $70,x			stz 	NSMantissa3,x
.98d7	74 78		stz $78,x			stz 	NSExponent,x
.98d9	5a		phy				phy
.98da	a0 02		ldy #$02			ldy 	#2 							; read type
.98dc	b1 36		lda ($36),y			lda 	(zTemp0),y
.98de	7a		ply				ply
.98df	29 1c		and #$1c			and 	#NSBTypeMask+NSBIsArray 	; get type information
.98e1	09 20		ora #$20			ora 	#NSBIsReference 			; make a reference.
.98e3	95 50		sta $50,x			sta 	NSStatus,x
.98e5	29 04		and #$04			and 	#NSBIsArray
.98e7	d0 01		bne $98ea			bne 	_VHArray
.98e9	60		rts				rts
.98ea					_VHArray:
.98ea	e8		inx				inx
.98eb	20 4c 9d	jsr $9d4c			jsr 	Evaluate8BitInteger 		; get the 1st index.
.98ee	a9 ff		lda #$ff			lda 	#$FF 						; set Status of X+2 to a duff value so we know if we picked it up.
.98f0	95 51		sta $51,x			sta 	NSStatus+1,x
.98f2	b1 30		lda ($30),y			lda 	(codePtr),y
.98f4	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.98f6	d0 06		bne $98fe			bne 	_VHNoSecondIndex
.98f8	c8		iny				iny 								; skip the comma
.98f9	e8		inx				inx
.98fa	20 4c 9d	jsr $9d4c			jsr 	Evaluate8BitInteger 		; get the 2nd index.
.98fd	ca		dex				dex
.98fe					_VHNoSecondIndex:
.98fe	ca		dex				dex 								; set X back.
.98ff	20 8b 8e	jsr $8e8b			jsr 	CheckRightBracket 			; and check the right bracket.
.9902	5a		phy				phy 								; save position
.9903	a0 02		ldy #$02			ldy 	#2 							; check first index is not-zero, e.g. array defined
.9905	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9907	f0 60		beq $9969			beq 	_VHBadIndex
.9909	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy record address to zaTemp
.990b	85 3e		sta $3e				sta 	zaTemp
.990d	b5 60		lda $60,x			lda 	NSMantissa1,x
.990f	85 3f		sta $3f				sta 	zaTemp+1
.9911	a0 03		ldy #$03			ldy 	#3 							; get the second index - which is 0 if there is one index.
.9913	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9915	f0 02		beq $9919			beq 	_VHHas2Mask
.9917	a9 ff		lda #$ff			lda 	#$FF
.9919					_VHHas2Mask:
.9919	d5 52		cmp $52,x			cmp 	NSStatus+2,x 				; so if they are the same there are the wrong number of indices
.991b	f0 4c		beq $9969			beq 	_VHBadIndex
.991d	0a		asl a				asl 	a 							; carry will be set if a second index
.991e	90 08		bcc $9928			bcc 	_VHCheckFirstIndex
.9920	a0 03		ldy #$03			ldy 	#3 			 				; check the 2nd size >= 2nd index
.9922	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9924	d5 5a		cmp $5a,x			cmp 	NSMantissa0+2,x
.9926	90 41		bcc $9969			bcc 	_VHBadIndex
.9928					_VHCheckFirstIndex:
.9928	a0 02		ldy #$02			ldy 	#2 			 				; check the 2nd size >= 2nd index
.992a	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.992c	d5 59		cmp $59,x			cmp 	NSMantissa0+1,x
.992e	90 39		bcc $9969			bcc 	_VHBadIndex
.9930	64 36		stz $36				stz 	zTemp0 						; clear zTemp0 (if 1 index)
.9932	64 37		stz $37				stz 	zTemp0+1
.9934	b5 52		lda $52,x			lda 	NSStatus+2,x 				; if only one index provided, don't need to multiply
.9936	30 0e		bmi $9946			bmi 	_VHNoMultiply
.9938	da		phx				phx
.9939	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; get 2nd index on stack
.993b	48		pha				pha
.993c	a0 02		ldy #$02			ldy 	#2 							; get 1st size in A
.993e	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9940	1a		inc a				inc 	a 							; add 1 for zero base
.9941	fa		plx				plx
.9942	20 5c 9d	jsr $9d5c			jsr 	Multiply8x8 				; calculate -> Z0
.9945	fa		plx				plx
.9946					_VHNoMultiply:
.9946	18		clc				clc
.9947	a5 36		lda $36				lda 	zTemp0
.9949	75 59		adc $59,x			adc 	NSMantissa0+1,x
.994b	85 36		sta $36				sta 	zTemp0
.994d	a5 37		lda $37				lda 	zTemp0+1
.994f	69 00		adc #$00			adc 	#0
.9951	85 37		sta $37				sta 	zTemp0+1
.9953	b5 50		lda $50,x			lda 	NSStatus,x
.9955	20 03 85	jsr $8503			jsr 	ScaleByBaseType
.9958	18		clc				clc
.9959	b2 3e		lda ($3e)			lda 	(zaTemp)
.995b	65 36		adc $36				adc 	zTemp0
.995d	95 58		sta $58,x			sta 	NSMantissa0,x
.995f	a0 01		ldy #$01			ldy 	#1
.9961	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9963	65 37		adc $37				adc 	zTemp0+1
.9965	95 60		sta $60,x			sta 	NSMantissa1,x
.9967	7a		ply				ply 								; restore position
.9968	60		rts				rts
.9969					_VHBadIndex:
.9969	a9 17		lda #$17		lda	#23
.996b	4c a4 8e	jmp $8ea4		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/abs.asm

.996e					AbsUnary:
.996e	fa		plx				plx 								; restore stack pos
.996f	20 ff 9c	jsr $9cff			jsr 	EvaluateNumber 				; get a float or int
.9972	20 8b 8e	jsr $8e8b			jsr 	CheckRightBracket
.9975	b5 50		lda $50,x			lda 	NSStatus,x 					; clear the sign bit
.9977	29 7f		and #$7f			and 	#$7F
.9979	95 50		sta $50,x			sta 	NSStatus,x
.997b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/alloc.asm

.997c					AllocUnary:
.997c	fa		plx				plx 								; restore stack pos
.997d	20 31 9d	jsr $9d31			jsr 	Evaluate16BitInteger		; get bytes required.
.9980	20 8b 8e	jsr $8e8b			jsr 	CheckRightBracket
.9983	da		phx				phx 								; save X/Y
.9984	5a		phy				phy
.9985	8a		txa				txa 								; copy X into Y
.9986	a8		tay				tay
.9987	b9 60 00	lda $0060,y			lda		NSMantissa1,y 				; get size
.998a	aa		tax				tax
.998b	b9 58 00	lda $0058,y			lda 	NSMantissa0,y
.998e	20 9b 99	jsr $999b			jsr 	AllocateXABytes 			; allocate memory
.9991	99 58 00	sta $0058,y			sta 	NSMantissa0,y 				; write address out.
.9994	8a		txa				txa
.9995	99 60 00	sta $0060,y			sta 	NSMantissa1,y
.9998	7a		ply				ply
.9999	fa		plx				plx
.999a	60		rts				rts
.999b					AllocateXABytes:
.999b	5a		phy				phy
.999c	ac 0c 04	ldy $040c			ldy 	lowMemPtr 					; push current address on stack and to zTemp0
.999f	84 36		sty $36				sty 	zTemp0
.99a1	5a		phy				phy
.99a2	ac 0d 04	ldy $040d			ldy 	lowMemPtr+1
.99a5	84 37		sty $37				sty 	zTemp0+1
.99a7	5a		phy				phy
.99a8	18		clc				clc 								; add to low memory pointer
.99a9	6d 0c 04	adc $040c			adc 	lowMemPtr
.99ac	8d 0c 04	sta $040c			sta 	lowMemPtr
.99af	8a		txa				txa
.99b0	6d 0d 04	adc $040d			adc 	lowMemPtr+1
.99b3	8d 0d 04	sta $040d			sta 	lowMemPtr+1
.99b6	b0 2f		bcs $99e7			bcs 	CISSMemory
.99b8	20 d9 99	jsr $99d9			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.99bb					_ClearMemory:
.99bb	ad 0c 04	lda $040c			lda 	lowMemPtr 					; cleared all memory allocated
.99be	c5 36		cmp $36				cmp 	zTemp0
.99c0	d0 07		bne $99c9			bne 	_CMClearNext
.99c2	ad 0d 04	lda $040d			lda 	lowMemPtr+1
.99c5	c5 37		cmp $37				cmp 	zTemp0+1
.99c7	f0 0c		beq $99d5			beq 	_CMExit
.99c9					_CMClearNext:
.99c9	a9 00		lda #$00			lda 	#0 							; clear byte, advance to next.
.99cb	92 36		sta ($36)			sta 	(zTemp0)
.99cd	e6 36		inc $36				inc 	zTemp0
.99cf	d0 ea		bne $99bb			bne 	_ClearMemory
.99d1	e6 37		inc $37				inc		zTemp0+1
.99d3	80 e6		bra $99bb			bra 	_ClearMemory
.99d5					_CMExit:
.99d5	fa		plx				plx
.99d6	68		pla				pla
.99d7	7a		ply				ply
.99d8	60		rts				rts
.99d9					CheckIdentifierStringSpace:
.99d9	48		pha				pha
.99da	ad 0d 04	lda $040d			lda 	lowMemPtr+1 				; get low memory pointer
.99dd	18		clc				clc
.99de	69 02		adc #$02			adc 	#2 							; need at least 2 256 byte pages
.99e0	cd 0f 04	cmp $040f			cmp 	StringMemory+1 				; is it >= StringMemory
.99e3	b0 02		bcs $99e7			bcs 	CISSMemory
.99e5	68		pla				pla
.99e6	60		rts				rts
.99e7					CISSMemory:
.99e7	a9 06		lda #$06		lda	#6
.99e9	4c a4 8e	jmp $8ea4		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/asc.asm

.99ec					AscUnary:
.99ec	fa		plx				plx 								; restore stack pos
.99ed	20 09 9d	jsr $9d09			jsr 	EvaluateString 				; get a string
.99f0	b2 36		lda ($36)			lda 	(zTemp0)					; get/return first character
.99f2	20 b3 9d	jsr $9db3			jsr 	NSMSetByte 					; ASC("") will return zero.
.99f5	20 8b 8e	jsr $8e8b			jsr 	CheckRightBracket
.99f8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/frac.asm

.99f9					FracUnary:
.99f9	fa		plx				plx 								; restore stack pos
.99fa	20 ff 9c	jsr $9cff			jsr 	EvaluateNumber 				; get a float or int
.99fd	20 8b 8e	jsr $8e8b			jsr 	CheckRightBracket
.9a00	b5 50		lda $50,x			lda 	NSStatus,x
.9a02	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9a04	f0 04		beq $9a0a			beq 	_IUZero
.9a06	20 b9 94	jsr $94b9			jsr 	FloatFractionalPart
.9a09	60		rts				rts
.9a0a					_IUZero:
.9a0a	20 b1 9d	jsr $9db1			jsr 	NSMSetZero
.9a0d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/int.asm

.9a0e					IntUnary:
.9a0e	fa		plx				plx 								; restore stack pos
.9a0f	20 ff 9c	jsr $9cff			jsr 	EvaluateNumber 				; get a float or int
.9a12	20 8b 8e	jsr $8e8b			jsr 	CheckRightBracket
.9a15	b5 50		lda $50,x			lda 	NSStatus,x
.9a17	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9a19	f0 03		beq $9a1e			beq 	_IUExit
.9a1b	20 11 95	jsr $9511			jsr 	FloatIntegerPart
.9a1e					_IUExit:
.9a1e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/len.asm

.9a1f					LenUnary:
.9a1f	fa		plx				plx 								; restore stack pos
.9a20	20 09 9d	jsr $9d09			jsr 	EvaluateString 				; get a string
.9a23	5a		phy				phy
.9a24	a0 00		ldy #$00			ldy 	#0 							; find length
.9a26					_LenFind:
.9a26	b1 36		lda ($36),y			lda 	(zTemp0),y 					; look for trailing NULL.
.9a28	f0 06		beq $9a30			beq 	_LenExit
.9a2a	c8		iny				iny
.9a2b	d0 f9		bne $9a26			bne 	_LenFind
.9a2d	4c 2e 9f	jmp $9f2e			jmp 	RangeError 					; string > 255 - no trailing NULL.
.9a30					_LenExit:
.9a30	98		tya				tya		 							; return length
.9a31	20 b3 9d	jsr $9db3			jsr 	NSMSetByte
.9a34	7a		ply				ply
.9a35	20 8b 8e	jsr $8e8b			jsr 	CheckRightBracket
.9a38	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/minmax.asm

.9a39					Unary_Min:
.9a39	a9 01		lda #$01			lda 	#1
.9a3b	80 02		bra $9a3f			bra 	UnaryMinMaxMain
.9a3d					Unary_Max:
.9a3d	a9 ff		lda #$ff			lda 	#$FF 						; value from comparator to cause a write
.9a3f					UnaryMinMaxMain:
.9a3f	fa		plx				plx 								; get index on number stack
.9a40	48		pha				pha 								; save comparator
.9a41	20 f6 9c	jsr $9cf6			jsr 	EvaluateValue 				; get the first value.
.9a44					_UMMMLoop:
.9a44	b1 30		lda ($30),y			lda 	(codePtr),y
.9a46	c9 29		cmp #$29			cmp 	#KWD_RPAREN 				; if right bracket then done.
.9a48	f0 22		beq $9a6c			beq 	_UMMMDone
.9a4a	20 93 8e	jsr $8e93			jsr 	CheckComma 					; must be a comma
.9a4d	e8		inx				inx
.9a4e	20 f6 9c	jsr $9cf6			jsr 	EvaluateValue
.9a51	ca		dex				dex
.9a52	20 94 9d	jsr $9d94			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] (Compare is destructive)
.9a55	e8		inx				inx
.9a56	20 94 9d	jsr $9d94			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2], original
.9a59	e8		inx				inx
.9a5a	20 5b 8f	jsr $8f5b			jsr 	CompareBaseCode 			; part of > = < etc. code, returns 255,0 or 1
.9a5d	ca		dex				dex
.9a5e	ca		dex				dex
.9a5f	85 36		sta $36				sta 	zTemp0 						; save required result
.9a61	68		pla				pla 								; get and save comparator
.9a62	48		pha				pha
.9a63	c5 36		cmp $36				cmp 	zTemp0 						; if the comparator
.9a65	d0 dd		bne $9a44			bne 	_UMMMLoop
.9a67	20 6f 9a	jsr $9a6f			jsr 	ExpCopyAboveDown 			; copy next up slot down
.9a6a	80 d8		bra $9a44			bra 	_UMMMLoop
.9a6c					_UMMMDone:
.9a6c	68		pla				pla 								; throw the comparator
.9a6d	c8		iny				iny 								; skip )
.9a6e	60		rts				rts
.9a6f					ExpCopyAboveDown:
.9a6f	b5 51		lda $51,x			lda 	NSStatus+1,x
.9a71	95 50		sta $50,x			sta 	NSStatus,x
.9a73	b5 79		lda $79,x			lda 	NSExponent+1,x
.9a75	95 78		sta $78,x			sta 	NSExponent,x
.9a77	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9a79	95 58		sta $58,x			sta 	NSMantissa0,x
.9a7b	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9a7d	95 60		sta $60,x			sta 	NSMantissa1,x
.9a7f	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.9a81	95 68		sta $68,x			sta 	NSMantissa2,x
.9a83	b5 71		lda $71,x			lda 	NSMantissa3+1,x
.9a85	95 70		sta $70,x			sta 	NSMantissa3,x
.9a87	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/not.asm

.9a88					Unary_Not:
.9a88	fa		plx				plx
.9a89	20 1e 9d	jsr $9d1e			jsr 	EvaluateInteger 			; get integer
.9a8c	20 8b 8e	jsr $8e8b			jsr 	CheckRightBracket
.9a8f	20 d3 9d	jsr $9dd3			jsr 	NSMIsZero 					; zero mantissa ?
.9a92	f0 04		beq $9a98			beq 	_NotZero
.9a94	20 b1 9d	jsr $9db1			jsr 	NSMSetZero
.9a97	60		rts				rts
.9a98					_NotZero:
.9a98	4c 11 8f	jmp $8f11			jmp 	ReturnTrue

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/rnd.asm

.9a9b					Unary_Random:
.9a9b	fa		plx				plx
.9a9c	20 0d 9b	jsr $9b0d			jsr 	Random32Bit 				; get a random number
.9a9f	20 f6 9a	jsr $9af6			jsr 	URCopyToMantissa  			; put in mantissa
.9aa2	b1 30		lda ($30),y			lda 	(codePtr),y
.9aa4	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.9aa6	f0 08		beq $9ab0			beq 	_URNoModulus 				; then we return a random 30 bit number.
.9aa8	e8		inx				inx
.9aa9	20 31 9d	jsr $9d31			jsr 	Evaluate16BitInteger 		; put modulus value in +1
.9aac	ca		dex				dex
.9aad	20 63 90	jsr $9063			jsr 	IntegerModulusNoCheck 		; calculate modulus, so now 0 .. n-1
.9ab0					_URNoModulus:
.9ab0	74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer positive
.9ab2	74 78		stz $78,x			stz 	NSExponent,x
.9ab4	20 8b 8e	jsr $8e8b			jsr 	CheckRightBracket
.9ab7	60		rts				rts
.9ab8					Unary_Rnd:
.9ab8	fa		plx				plx
.9ab9	20 ff 9c	jsr $9cff			jsr 	EvaluateNumber 				; number to use.
.9abc	20 8b 8e	jsr $8e8b			jsr 	CheckRightBracket 			; closing bracket
.9abf	20 d3 9d	jsr $9dd3			jsr 	NSMIsZero 					; if zero, then don't generate a new number
.9ac2	f0 26		beq $9aea			beq 	_URCopySeed
.9ac4	b5 50		lda $50,x			lda 	NSStatus,x 					; if -ve, then seed using parameter
.9ac6	10 1f		bpl $9ae7			bpl 	_URDontSeed
.9ac8	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy - value to seed butchering it.
.9aca	49 17		eor #$17			eor 	#$17
.9acc	8d 08 04	sta $0408			sta 	RandomSeed+0
.9acf	b5 60		lda $60,x			lda 	NSMantissa1,x
.9ad1	49 a5		eor #$a5			eor 	#$A5
.9ad3	8d 09 04	sta $0409			sta 	RandomSeed+1
.9ad6	b5 68		lda $68,x			lda 	NSMantissa2,x
.9ad8	49 c2		eor #$c2			eor 	#$C2
.9ada	8d 0a 04	sta $040a			sta 	RandomSeed+2
.9add	b5 70		lda $70,x			lda 	NSMantissa3,x
.9adf	49 9d		eor #$9d			eor 	#$9D
.9ae1	8d 0b 04	sta $040b			sta 	RandomSeed+3
.9ae4	20 0d 9b	jsr $9b0d			jsr 	Random32Bit
.9ae7					_URDontSeed:
.9ae7	20 0d 9b	jsr $9b0d			jsr 	Random32Bit 				; generate a number
.9aea					_URCopySeed:
.9aea	20 f6 9a	jsr $9af6			jsr 	URCopyToMantissa 			; copy into mantissa
.9aed	a9 e2		lda #$e2			lda 	#-30 						; force into 0-1 range
.9aef	95 78		sta $78,x			sta 	NSExponent,x
.9af1	a9 08		lda #$08			lda 	#NSTFloat
.9af3	95 50		sta $50,x			sta 	NSStatus,x 					; positive float
.9af5	60		rts				rts
.9af6					URCopyToMantissa:
.9af6	ad 08 04	lda $0408			lda 	RandomSeed+0
.9af9	95 58		sta $58,x			sta 	NSMantissa0,x
.9afb	ad 09 04	lda $0409			lda 	RandomSeed+1
.9afe	95 60		sta $60,x			sta 	NSMantissa1,x
.9b00	ad 0a 04	lda $040a			lda 	RandomSeed+2
.9b03	95 68		sta $68,x			sta 	NSMantissa2,x
.9b05	ad 0b 04	lda $040b			lda 	RandomSeed+3
.9b08	29 3f		and #$3f			and 	#$3F 						; make legal mantissa
.9b0a	95 70		sta $70,x			sta 	NSMantissa3,x
.9b0c	60		rts				rts
.9b0d					Random32Bit:
.9b0d	5a		phy				phy
.9b0e	a0 07		ldy #$07			ldy 	#7 							; do it 7 times
.9b10	ad 08 04	lda $0408			lda 	RandomSeed+0 				; check the seed isn't zero
.9b13	d0 03		bne $9b18			bne 	_Random1
.9b15	a8		tay				tay 								; if so do it 256 times
.9b16	a9 aa		lda #$aa			lda		#$AA 						; and use this to seed the seed....
.9b18					_Random1:
.9b18	0a		asl a				asl 	a 							; LSFR RNG
.9b19	2e 09 04	rol $0409			rol 	RandomSeed+1
.9b1c	2e 0a 04	rol $040a			rol 	RandomSeed+2
.9b1f	2e 0b 04	rol $040b			rol 	RandomSeed+3
.9b22	90 02		bcc $9b26			bcc 	_Random2
.9b24	49 c5		eor #$c5			eor 	#$C5
.9b26					_Random2:
.9b26	88		dey				dey
.9b27	d0 ef		bne $9b18			bne 	_Random1
.9b29	8d 08 04	sta $0408			sta 	RandomSeed+0
.9b2c	7a		ply				ply
.9b2d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/sgn.asm

.9b2e					SgnUnary:
.9b2e	fa		plx				plx 								; restore stack pos
.9b2f	20 ff 9c	jsr $9cff			jsr 	EvaluateNumber 				; get a float or int
.9b32	20 8b 8e	jsr $8e8b			jsr 	CheckRightBracket
.9b35	20 d3 9d	jsr $9dd3			jsr 	NSMIsZero 					; if zero
.9b38	f0 0e		beq $9b48			beq 	_SGZero  					; return Int Zero
.9b3a	b5 50		lda $50,x			lda 	NSStatus,x 					; get status w/sign
.9b3c	48		pha				pha
.9b3d	a9 01		lda #$01			lda 	#1 							; set to 1
.9b3f	20 b3 9d	jsr $9db3			jsr 	NSMSetByte
.9b42	68		pla				pla
.9b43	29 80		and #$80			and		#$80 						; copy the sign byte out
.9b45	95 50		sta $50,x			sta 	NSStatus,x  				; so it will be -1 or 1
.9b47	60		rts				rts
.9b48	20 b1 9d	jsr $9db1	_SGZero:jsr 	NSMSetZero
.9b4b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/val.asm

.9b4c					ValUnary:
.9b4c	fa		plx				plx 								; restore stack pos
.9b4d	20 62 9b	jsr $9b62			jsr 	ValMainCode 				; do the main val() code
.9b50	b0 01		bcs $9b53			bcs 	_VUError 					; couldn't convert
.9b52	60		rts				rts
.9b53					_VUError:
.9b53	4c 33 9f	jmp $9f33			jmp 	TypeError
.9b56					IsValUnary:
.9b56	fa		plx				plx 								; restore stack pos
.9b57	20 62 9b	jsr $9b62			jsr 	ValMainCode 				; do the main val() code
.9b5a	b0 03		bcs $9b5f			bcs 	_VUBad
.9b5c	4c 11 8f	jmp $8f11			jmp 	ReturnTrue
.9b5f					_VUBad:
.9b5f	4c 1c 8f	jmp $8f1c			jmp 	ReturnFalse
.9b62					ValMainCode:
.9b62	20 09 9d	jsr $9d09			jsr 	EvaluateString 				; get a string
.9b65	20 8b 8e	jsr $8e8b			jsr 	CheckRightBracket 			; check right bracket present
.9b68					ValEvaluateZTemp0:
.9b68	5a		phy				phy
.9b69	b2 36		lda ($36)			lda 	(zTemp0) 					; check not empty string
.9b6b	f0 17		beq $9b84			beq 	_VMCFail2
.9b6d	a0 ff		ldy #$ff			ldy 	#$FF 						; start position
.9b6f	48		pha				pha 								; save first character
.9b70	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.9b72	d0 01		bne $9b75			bne 	_VMCStart
.9b74	c8		iny				iny 								; skip over -
.9b75					_VMCStart:
.9b75	38		sec				sec 								; initialise first time round.
.9b76					_VMCNext:
.9b76	c8		iny				iny 								; pre-increment
.9b77	b1 36		lda ($36),y			lda 	(zTemp0),y 					; next character = EOS ?
.9b79	f0 0c		beq $9b87			beq 	_VMCSuccess 				; successful.
.9b7b	20 ee 96	jsr $96ee			jsr 	EncodeNumber 				; send it to the number-builder
.9b7e	90 03		bcc $9b83			bcc 	_VMCFail 					; if failed, give up.
.9b80	18		clc				clc 								; next time round, countinue
.9b81	80 f3		bra $9b76			bra 	_VMCNext
.9b83					_VMCFail:
.9b83	68		pla				pla
.9b84					_VMCFail2:
.9b84	7a		ply				ply
.9b85	38		sec				sec
.9b86	60		rts				rts
.9b87					_VMCSuccess:
.9b87	a9 00		lda #$00			lda 	#0 							; construct final
.9b89	20 ee 96	jsr $96ee			jsr 	EncodeNumber 				; by sending a duff value.
.9b8c	68		pla				pla 								; if it was -ve
.9b8d	c9 2d		cmp #$2d			cmp 	#"-"
.9b8f	d0 03		bne $9b94			bne 	_VMCNotNegative
.9b91	20 73 9d	jsr $9d73			jsr		NSMNegate 					; negate it.
.9b94					_VMCNotNegative:
.9b94	7a		ply				ply
.9b95	18		clc				clc
.9b96	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/chr.asm

.9b97					ChrUnary:
.9b97	fa		plx				plx 								; restore stack pos
.9b98	20 4c 9d	jsr $9d4c			jsr 	Evaluate8BitInteger			; get value
.9b9b	48		pha				pha
.9b9c	20 8b 8e	jsr $8e8b			jsr 	CheckRightBracket
.9b9f	a9 01		lda #$01			lda 	#1 							; allocate space for one char
.9ba1	20 dd a6	jsr $a6dd			jsr 	StringTempAllocate
.9ba4	68		pla				pla 								; write number to it
.9ba5	20 16 a7	jsr $a716			jsr 	StringTempWrite
.9ba8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/spc.asm

.9ba9					SpcUnary:
.9ba9	fa		plx				plx 								; restore stack pos
.9baa	20 4c 9d	jsr $9d4c			jsr 	Evaluate8BitInteger			; get value
.9bad	5a		phy				phy
.9bae	48		pha				pha 								; save count
.9baf	20 dd a6	jsr $a6dd			jsr 	StringTempAllocate
.9bb2	7a		ply				ply 								; to do count in Y
.9bb3					_SpcLoop:
.9bb3	c0 00		cpy #$00			cpy 	#0
.9bb5	f0 08		beq $9bbf			beq 	_SpcExit
.9bb7	a9 20		lda #$20			lda 	#32
.9bb9	20 16 a7	jsr $a716			jsr 	StringTempWrite
.9bbc	88		dey				dey
.9bbd	80 f4		bra $9bb3			bra 	_SPCLoop
.9bbf					_SpcExit:
.9bbf	7a		ply				ply
.9bc0	20 8b 8e	jsr $8e8b			jsr 	CheckRightBracket
.9bc3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/str.asm

.9bc4					Unary_Str:
.9bc4	fa		plx				plx
.9bc5	20 ff 9c	jsr $9cff			jsr 	EvaluateNumber  			; get number
.9bc8	20 8b 8e	jsr $8e8b			jsr 	CheckRightBracket 			; closing bracket
.9bcb	a9 05		lda #$05			lda 	#5 							; maximum decimals, from Basic816
.9bcd	20 e6 9b	jsr $9be6			jsr 	ConvertNumberToString 		; do the conversion.
.9bd0	a9 21		lda #$21			lda		#33 						; create buffer
.9bd2	20 dd a6	jsr $a6dd			jsr 	StringTempAllocate 			; allocate memory
.9bd5	da		phx				phx
.9bd6	a2 00		ldx #$00			ldx 	#0
.9bd8					_USCopy:
.9bd8	bd 9d 05	lda $059d,x			lda 	DecimalBuffer,x
.9bdb	20 16 a7	jsr $a716			jsr 	StringTempWrite
.9bde	e8		inx				inx
.9bdf	bd 9d 05	lda $059d,x			lda 	DecimalBuffer,x
.9be2	d0 f4		bne $9bd8			bne 	_USCopy
.9be4	fa		plx				plx
.9be5	60		rts				rts
.9be6					ConvertNumberToString:
.9be6	5a		phy				phy 								; save code position
.9be7	8d 14 04	sta $0414			sta 	DecimalPlaces	 			; save number of DPs.
.9bea	9c 15 04	stz $0415			stz 	dbOffset 					; offset into decimal buffer = start.
.9bed	b5 50		lda $50,x			lda 	NSStatus,x  				; is it -ve.
.9bef	10 09		bpl $9bfa			bpl 	_CNTSNotNegative
.9bf1	29 7f		and #$7f			and 	#$7F 						; make +ve
.9bf3	95 50		sta $50,x			sta 	NSStatus,x
.9bf5	a9 2d		lda #$2d			lda 	#"-"
.9bf7	20 5b 9c	jsr $9c5b			jsr 	WriteDecimalBuffer
.9bfa					_CNTSNotNegative:
.9bfa	b5 78		lda $78,x			lda 	NSExponent,x 				; check if decimal
.9bfc	f0 12		beq $9c10			beq 	_CNTSNotFloat
.9bfe	e8		inx				inx 								; round up
.9bff	a9 01		lda #$01			lda 	#1
.9c01	20 b3 9d	jsr $9db3			jsr 	NSMSetByte
.9c04	ca		dex				dex
.9c05	b5 78		lda $78,x			lda		NSExponent,x
.9c07	95 79		sta $79,x			sta 	NSExponent+1,x
.9c09	a9 08		lda #$08			lda 	#NSTFloat
.9c0b	95 51		sta $51,x			sta 	NSStatus+1,x
.9c0d	20 f3 93	jsr $93f3			jsr 	FloatAdd
.9c10					_CNTSNotFloat:
.9c10	20 3d 9c	jsr $9c3d			jsr 	MakePlusTwoString
.9c13	20 b9 94	jsr $94b9			jsr 	FloatFractionalPart 		; get the fractional part
.9c16	20 6a 95	jsr $956a			jsr 	NSNormalise					; normalise , exit if zero
.9c19	f0 20		beq $9c3b			beq 	_CNTSExit
.9c1b	a9 2e		lda #$2e			lda 	#"."
.9c1d	20 5b 9c	jsr $9c5b			jsr 	WriteDecimalBuffer 			; write decimal place
.9c20					_CNTSDecimal:
.9c20	ce 14 04	dec $0414			dec 	DecimalPlaces 				; done all the decimals
.9c23	30 16		bmi $9c3b			bmi 	_CNTSExit
.9c25	e8		inx				inx 								; x 10.0
.9c26	a9 0a		lda #$0a			lda 	#10
.9c28	20 b3 9d	jsr $9db3			jsr 	NSMSetByte
.9c2b	a9 08		lda #$08			lda 	#NSTFloat
.9c2d	95 50		sta $50,x			sta 	NSStatus,x
.9c2f	ca		dex				dex
.9c30	20 38 95	jsr $9538			jsr 	FloatMultiply
.9c33	20 3d 9c	jsr $9c3d			jsr 	MakePlusTwoString
.9c36	20 b9 94	jsr $94b9			jsr 	FloatFractionalPart 		; get the fractional part
.9c39	80 e5		bra $9c20			bra 	_CNTSDecimal 				; keep going.
.9c3b					_CNTSExit:
.9c3b	7a		ply				ply
.9c3c	60		rts				rts
.9c3d					MakePlusTwoString:
.9c3d	da		phx				phx
.9c3e	20 94 9d	jsr $9d94			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.9c41	e8		inx				inx 								; access it
.9c42	e8		inx				inx
.9c43	20 11 95	jsr $9511			jsr 	FloatIntegerPart 			; make it an integer
.9c46	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.9c48	20 23 93	jsr $9323			jsr 	ConvertInt32
.9c4b	a2 00		ldx #$00			ldx	 	#0
.9c4d					_MPTSCopy:
.9c4d	bd 7b 05	lda $057b,x			lda 	NumberBuffer,x
.9c50	20 5b 9c	jsr $9c5b			jsr 	WriteDecimalBuffer
.9c53	e8		inx				inx
.9c54	bd 7b 05	lda $057b,x			lda 	NumberBuffer,x
.9c57	d0 f4		bne $9c4d			bne 	_MPTSCopy
.9c59	fa		plx				plx
.9c5a	60		rts				rts
.9c5b					WriteDecimalBuffer:
.9c5b	da		phx				phx
.9c5c	ae 15 04	ldx $0415			ldx 	dbOffset
.9c5f	9d 9d 05	sta $059d,x			sta 	DecimalBuffer,x
.9c62	9e 9e 05	stz $059e,x			stz 	DecimalBuffer+1,x
.9c65	ee 15 04	inc $0415			inc 	dbOffset
.9c68	fa		plx				plx
.9c69	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/substring.asm

.9c6a					Unary_Left:
.9c6a	fa		plx				plx
.9c6b	18		clc				clc 								; only one parameter
.9c6c	20 cf 9c	jsr $9ccf			jsr 	SubstringInitial 			; set up.
.9c6f	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; Param #1 is the length
.9c71	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9c73	74 59		stz $59,x			stz 	NSMantissa0+1,x 			; Start is zero.
.9c75	80 25		bra $9c9c			bra 	SubstringMain
.9c77					Unary_Right:
.9c77	fa		plx				plx
.9c78	18		clc				clc 								; only one parameter
.9c79	20 cf 9c	jsr $9ccf			jsr 	SubstringInitial 			; set up.
.9c7c	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; length => param 2
.9c7e	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9c80	b5 78		lda $78,x			lda 	NSExponent,x 				; total length
.9c82	f5 59		sbc $59,x			sbc 	NSMantissa0+1,x 			; length - required.
.9c84	b0 02		bcs $9c88			bcs 	_URNotUnderflow
.9c86	a9 00		lda #$00			lda 	#0 							; start from the beginning, as something like right$("AB",3)
.9c88					_URNotUnderFlow:
.9c88	95 59		sta $59,x			sta 	NSMantissa0+1,x 			; this is the start position
.9c8a	80 10		bra $9c9c			bra 	SubStringMain
.9c8c					Unary_Mid:
.9c8c	fa		plx				plx
.9c8d	38		sec				sec 								; two parameters
.9c8e	20 cf 9c	jsr $9ccf			jsr 	SubstringInitial 			; set up.
.9c91	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; first parameter is zero ?
.9c93	f0 04		beq $9c99			beq 	_UMError
.9c95	d6 59		dec $59,x			dec 	NSMantissa0+1,x				; reduce initial offset by 1 as MID$(a$,1..) is actually the first character
.9c97	80 03		bra $9c9c			bra 	SubStringMain
.9c99					_UMError:
.9c99	4c 38 9f	jmp $9f38			jmp 	ArgumentError
.9c9c					SubStringMain:
.9c9c	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; is the initial offset >= the length
.9c9e	d5 78		cmp $78,x			cmp 	NSExponent,x
.9ca0	b0 27		bcs $9cc9			bcs 	_SSMNull 					; if so, return an empty string.
.9ca2	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; if copy count is zero
.9ca4	f0 23		beq $9cc9			beq 	_SSMNull 					; return empty string.
.9ca6	18		clc				clc 								; add the offset +1 to the address and
.9ca7	b5 58		lda $58,x			lda	 	NSMantissa0,x 				; put in zTemp
.9ca9	75 59		adc $59,x			adc 	NSMantissa0+1,x
.9cab	85 36		sta $36				sta 	zTemp0
.9cad	b5 60		lda $60,x			lda	 	NSMantissa1,x
.9caf	69 00		adc #$00			adc 	#0
.9cb1	85 37		sta $37				sta 	zTemp0+1
.9cb3					_SSMNoCarry:
.9cb3	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; characters required.
.9cb5	20 dd a6	jsr $a6dd			jsr 	StringTempAllocate 			; allocate that many characters
.9cb8	5a		phy				phy 								; save Y
.9cb9	a0 00		ldy #$00			ldy 	#0 							; start copying in.
.9cbb					_SSMCopy:
.9cbb	b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next character
.9cbd	f0 08		beq $9cc7			beq 	_SSMEString 				; no more to copy
.9cbf	20 16 a7	jsr $a716			jsr 	StringTempWrite 			; and write it out.
.9cc2	c8		iny				iny
.9cc3	d6 5a		dec $5a,x			dec 	NSMantissa0+2,x
.9cc5	d0 f4		bne $9cbb			bne 	_SSMCopy
.9cc7					_SSMEString:
.9cc7	7a		ply				ply
.9cc8					_SSMExit:
.9cc8	60		rts				rts
.9cc9					_SSMNull:
.9cc9	a9 00		lda #$00			lda 	#0
.9ccb	20 dd a6	jsr $a6dd			jsr 	StringTempAllocate
.9cce	60		rts				rts
.9ccf					SubstringInitial:
.9ccf	da		phx				phx 								; save initial stack position
.9cd0	08		php				php 								; save carry on stack indicating 2 parameters
.9cd1	20 09 9d	jsr $9d09			jsr 	EvaluateString 				; get a string
.9cd4	5a		phy				phy 								; calculate length to exponent.
.9cd5	a0 ff		ldy #$ff			ldy 	#$FF
.9cd7					_SIFindLength:
.9cd7	c8		iny				iny
.9cd8	b1 36		lda ($36),y			lda 	(zTemp0),y
.9cda	d0 fb		bne $9cd7			bne 	_SIFindLength
.9cdc	98		tya				tya
.9cdd	95 78		sta $78,x			sta 	NSExponent,x
.9cdf	7a		ply				ply
.9ce0	e8		inx				inx
.9ce1	20 93 8e	jsr $8e93			jsr 	CheckComma 					; comma next
.9ce4	20 4c 9d	jsr $9d4c			jsr 	Evaluate8BitInteger 		; get next parameter
.9ce7	28		plp				plp 								; is it the last parameter ?
.9ce8	90 07		bcc $9cf1			bcc 	_SSIExit 					; if so, exit.
.9cea	e8		inx				inx
.9ceb	20 93 8e	jsr $8e93			jsr 	CheckComma 					; comma next
.9cee	20 4c 9d	jsr $9d4c			jsr 	Evaluate8BitInteger 		; get last parameter
.9cf1					_SSIExit:
.9cf1	fa		plx				plx
.9cf2	20 8b 8e	jsr $8e8b			jsr 	CheckRightBracket 			; check closing bracket
.9cf5	60		rts				rts 								; exit

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/exprhelper.asm

.9cf6					EvaluateValue:
.9cf6	48		pha				pha
.9cf7	20 a8 93	jsr $93a8			jsr		EvaluateExpression 			; expression
.9cfa	20 6b 96	jsr $966b			jsr 	Dereference					; derefernce it
.9cfd	68		pla				pla
.9cfe	60		rts				rts
.9cff					EvaluateNumber:
.9cff	20 f6 9c	jsr $9cf6			jsr 	EvaluateValue 				; get a value
.9d02	b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.9d04	29 10		and #$10			and 	#NSBIsString
.9d06	d0 13		bne $9d1b			bne 	HelperTypeError
.9d08	60		rts				rts
.9d09					EvaluateString:
.9d09	20 f6 9c	jsr $9cf6			jsr 	EvaluateValue 				; get a value
.9d0c	b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.9d0e	29 10		and #$10			and 	#NSBIsString
.9d10	f0 09		beq $9d1b			beq 	HelperTypeError
.9d12					CopyAddressToTemp0:
.9d12	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address -> zTemp0
.9d14	85 36		sta $36				sta 	zTemp0 						; (so we can do something with it)
.9d16	b5 60		lda $60,x			lda 	NSMantissa1,x
.9d18	85 37		sta $37				sta 	zTemp0+1
.9d1a	60		rts				rts
.9d1b					HelperTypeError:
.9d1b	4c 33 9f	jmp $9f33			jmp 	TypeError
.9d1e					EvaluateInteger:
.9d1e	20 ff 9c	jsr $9cff			jsr 	EvaluateNumber
.9d21	b5 78		lda $78,x			lda 	NSExponent,x 				; check exponent is zero
.9d23	d0 09		bne $9d2e			bne 	HelperValueError 			; if not, it's a float.
.9d25	60		rts				rts
.9d26					EvaluateUnsignedInteger:
.9d26	20 1e 9d	jsr $9d1e			jsr 	EvaluateInteger 			; check integer is +ve
.9d29	b5 50		lda $50,x			lda 	NSStatus,x
.9d2b	30 01		bmi $9d2e			bmi 	HelperValueError
.9d2d	60		rts				rts
.9d2e					HelperValueError:
.9d2e	4c 38 9f	jmp $9f38			jmp 	ArgumentError
.9d31						Evaluate16BitInteger:
.9d31	20 26 9d	jsr $9d26			jsr	 	EvaluateUnsignedInteger		; get integer
.9d34	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9d36	15 68		ora $68,x			ora 	NSMantissa2,x
.9d38	d0 f4		bne $9d2e			bne 	HelperValueError
.9d3a	60		rts				rts
.9d3b					Evaluate16BitIntegerSigned:
.9d3b	20 1e 9d	jsr $9d1e			jsr	 	EvaluateInteger				; get integer
.9d3e	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9d40	15 68		ora $68,x			ora 	NSMantissa2,x
.9d42	d0 ea		bne $9d2e			bne 	HelperValueError
.9d44	b5 50		lda $50,x			lda 	NSStatus,x 					; signed ?
.9d46	10 03		bpl $9d4b			bpl 	_EISNotSigned
.9d48	20 7a 9d	jsr $9d7a			jsr 	NSMNegateMantissa 			; makes it an actual 2's complement value.
.9d4b					_EISNotSigned:
.9d4b	60		rts				rts
.9d4c					Evaluate8BitInteger:
.9d4c	20 26 9d	jsr $9d26			jsr	 	EvaluateUnsignedInteger 	; get an integer
.9d4f	d0 dd		bne $9d2e			bne 	HelperValueError
.9d51	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 1, 2 & 3 must be zero
.9d53	15 68		ora $68,x			ora 	NSMantissa2,x
.9d55	15 60		ora $60,x			ora 	NSMantissa1,x
.9d57	d0 d5		bne $9d2e			bne 	HelperValueError
.9d59	b5 58		lda $58,x			lda 	NSMantissa0,x
.9d5b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/mult8x8.asm

.9d5c					Multiply8x8:
.9d5c	4a		lsr a		  		lsr 	a  							; prime the carry bit for the loop
.9d5d	85 36		sta $36			  	sta 	zTemp0
.9d5f	86 37		stx $37				stx 	zTemp0+1
.9d61	a9 00		lda #$00			lda 	#0
.9d63	a2 08		ldx #$08			ldx 	#8
.9d65					_M88Loop:
.9d65	90 03		bcc $9d6a			bcc 	_M88NoAdd
.9d67	18		clc				clc
.9d68	65 37		adc $37				adc 	zTemp0+1
.9d6a					_M88NoAdd:
.9d6a	6a		ror a				ror 	a
.9d6b	66 36		ror $36				ror 	zTemp0  					; pull another bit out for the next iteration
.9d6d	ca		dex				dex         						; inc/dec don't modify carry; only shifts and adds do
.9d6e	d0 f5		bne $9d65			bne 	_M88Loop
.9d70	85 37		sta $37				sta 	zTemp0+1 					; store high 8 bits.
.9d72	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/utility.asm

.9d73					NSMNegate:
.9d73	b5 50		lda $50,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.9d75	49 80		eor #$80			eor 	#NSBIsNegative  			; toggle the negative flag
.9d77	95 50		sta $50,x			sta 	NSStatus,x
.9d79	60		rts				rts
.9d7a					NSMNegateMantissa:
.9d7a	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.9d7b	a9 00		lda #$00			lda 	#0
.9d7d	f5 58		sbc $58,x			sbc 	NSMantissa0,x
.9d7f	95 58		sta $58,x			sta 	NSMantissa0,x
.9d81	a9 00		lda #$00			lda 	#0
.9d83	f5 60		sbc $60,x			sbc 	NSMantissa1,x
.9d85	95 60		sta $60,x			sta 	NSMantissa1,x
.9d87	a9 00		lda #$00			lda 	#0
.9d89	f5 68		sbc $68,x			sbc 	NSMantissa2,x
.9d8b	95 68		sta $68,x			sta 	NSMantissa2,x
.9d8d	a9 00		lda #$00			lda 	#0
.9d8f	f5 70		sbc $70,x			sbc 	NSMantissa3,x
.9d91	95 70		sta $70,x			sta 	NSMantissa3,x
.9d93	60		rts				rts
.9d94					NSMShiftUpTwo:
.9d94	b5 58		lda $58,x			lda 	NSMantissa0,x
.9d96	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9d98	b5 60		lda $60,x			lda 	NSMantissa1,x
.9d9a	95 62		sta $62,x			sta 	NSMantissa1+2,x
.9d9c	b5 68		lda $68,x			lda 	NSMantissa2,x
.9d9e	95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.9da0	b5 70		lda $70,x			lda 	NSMantissa3,x
.9da2	95 72		sta $72,x			sta 	NSMantissa3+2,x
.9da4	b5 78		lda $78,x			lda 	NSExponent,x
.9da6	95 7a		sta $7a,x			sta 	NSExponent+2,x
.9da8	b5 50		lda $50,x			lda 	NSStatus,x
.9daa	95 52		sta $52,x			sta 	NSStatus+2,x
.9dac	60		rts				rts
.9dad					NSMSetZeroMantissaOnly:
.9dad	a9 00		lda #$00			lda 	#0
.9daf	80 06		bra $9db7			bra 	NSMSetMantissa
.9db1					NSMSetZero:
.9db1	a9 00		lda #$00			lda 	#0
.9db3					NSMSetByte:
.9db3	74 78		stz $78,x			stz 	NSExponent,x 				; zero exponent, as integer.
.9db5	74 50		stz $50,x			stz 	NSStatus,x 					; status zero (integer)
.9db7					NSMSetMantissa:
.9db7	95 58		sta $58,x			sta 	NSMantissa0,x 				; mantissa
.9db9	74 60		stz $60,x			stz 	NSMantissa1,x
.9dbb	74 68		stz $68,x			stz 	NSMantissa2,x
.9dbd	74 70		stz $70,x			stz 	NSMantissa3,x
.9dbf	60		rts				rts
.9dc0					NSMShiftLeft:
.9dc0	18		clc				clc
.9dc1					NSMRotateLeft:
.9dc1	36 58		rol $58,x			rol 	NSMantissa0,x
.9dc3	36 60		rol $60,x			rol		NSMantissa1,x
.9dc5	36 68		rol $68,x			rol		NSMantissa2,x
.9dc7	36 70		rol $70,x			rol		NSMantissa3,x
.9dc9	60		rts				rts
.9dca					NSMShiftRight:
.9dca	56 70		lsr $70,x			lsr 	NSMantissa3,x
.9dcc	76 68		ror $68,x			ror		NSMantissa2,x
.9dce	76 60		ror $60,x			ror		NSMantissa1,x
.9dd0	76 58		ror $58,x			ror		NSMantissa0,x
.9dd2	60		rts				rts
.9dd3					NSMIsZero:
.9dd3	b5 70		lda $70,x			lda 	NSMantissa3,x
.9dd5	15 68		ora $68,x			ora		NSMantissa2,x
.9dd7	15 60		ora $60,x			ora		NSMantissa1,x
.9dd9	15 58		ora $58,x			ora		NSMantissa0,x
.9ddb	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.asm

.b996					TickHandler:
.b996	5a		phy				phy 								; need to preserve Y
.b997	20 3c b9	jsr $b93c			jsr 	SNDUpdate 					; update sound
.b99a	7a		ply				ply
.b99b	60		rts				rts
.05af					LastTick:
>05af							.fill 		1

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/asmcore.asm

.9ddc					Assemble_ora:
.9ddc	20 63 80	jsr $8063		jsr	AssembleGroup1
>9ddf	01					.byte $01
.9de0					Assemble_and:
.9de0	20 63 80	jsr $8063		jsr	AssembleGroup1
>9de3	21					.byte $21
.9de4					Assemble_eor:
.9de4	20 63 80	jsr $8063		jsr	AssembleGroup1
>9de7	41					.byte $41
.9de8					Assemble_adc:
.9de8	20 63 80	jsr $8063		jsr	AssembleGroup1
>9deb	61					.byte $61
.9dec					Assemble_sta:
.9dec	20 63 80	jsr $8063		jsr	AssembleGroup1
>9def	81					.byte $81
.9df0					Assemble_lda:
.9df0	20 63 80	jsr $8063		jsr	AssembleGroup1
>9df3	a1					.byte $a1
.9df4					Assemble_cmp:
.9df4	20 63 80	jsr $8063		jsr	AssembleGroup1
>9df7	c1					.byte $c1
.9df8					Assemble_sbc:
.9df8	20 63 80	jsr $8063		jsr	AssembleGroup1
>9dfb	e1					.byte $e1
.9dfc					Assemble_asl:
.9dfc	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9dff	02					.byte $02
>9e00	75					.byte $75
.9e01					Assemble_rol:
.9e01	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9e04	22					.byte $22
>9e05	75					.byte $75
.9e06					Assemble_lsr:
.9e06	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9e09	42					.byte $42
>9e0a	75					.byte $75
.9e0b					Assemble_ror:
.9e0b	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9e0e	62					.byte $62
>9e0f	75					.byte $75
.9e10					Assemble_stx:
.9e10	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9e13	82					.byte $82
>9e14	50					.byte $50
.9e15					Assemble_ldx:
.9e15	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9e18	a2					.byte $a2
>9e19	d0					.byte $d0
.9e1a					Assemble_dec:
.9e1a	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9e1d	c2					.byte $c2
>9e1e	55					.byte $55
.9e1f					Assemble_inc:
.9e1f	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9e22	e2					.byte $e2
>9e23	55					.byte $55
.9e24					Assemble_stz:
.9e24	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9e27	60					.byte $60
>9e28	44					.byte $44
.9e29					Assemble_bit:
.9e29	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9e2c	20					.byte $20
>9e2d	55					.byte $55
.9e2e					Assemble_sty:
.9e2e	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9e31	80					.byte $80
>9e32	54					.byte $54
.9e33					Assemble_ldy:
.9e33	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9e36	a0					.byte $a0
>9e37	d5					.byte $d5
.9e38					Assemble_cpy:
.9e38	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9e3b	c0					.byte $c0
>9e3c	d4					.byte $d4
.9e3d					Assemble_cpx:
.9e3d	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9e40	e0					.byte $e0
>9e41	d0					.byte $d0
.9e42					Assemble_tsb:
.9e42	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9e45	00					.byte $00
>9e46	50					.byte $50
.9e47					Assemble_trb:
.9e47	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9e4a	10					.byte $10
>9e4b	50					.byte $50
.9e4c					Assemble_jsr:
.9e4c	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9e4f	14					.byte $14
>9e50	10					.byte $10
.9e51					Assemble_jmp:
.9e51	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9e54	40					.byte $40
>9e55	10					.byte $10
.9e56					Assemble_bpl:
.9e56	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9e59	10					.byte $10
.9e5a					Assemble_bmi:
.9e5a	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9e5d	30					.byte $30
.9e5e					Assemble_bvc:
.9e5e	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9e61	50					.byte $50
.9e62					Assemble_bvs:
.9e62	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9e65	70					.byte $70
.9e66					Assemble_bcc:
.9e66	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9e69	90					.byte $90
.9e6a					Assemble_bcs:
.9e6a	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9e6d	b0					.byte $b0
.9e6e					Assemble_bne:
.9e6e	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9e71	d0					.byte $d0
.9e72					Assemble_beq:
.9e72	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9e75	f0					.byte $f0
.9e76					Assemble_bra:
.9e76	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9e79	80					.byte $80
.9e7a					Assemble_brk:
.9e7a	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e7d	00					.byte $00
.9e7e					Assemble_php:
.9e7e	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e81	08					.byte $08
.9e82					Assemble_clc:
.9e82	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e85	18					.byte $18
.9e86					Assemble_plp:
.9e86	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e89	28					.byte $28
.9e8a					Assemble_sec:
.9e8a	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e8d	38					.byte $38
.9e8e					Assemble_rti:
.9e8e	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e91	40					.byte $40
.9e92					Assemble_pha:
.9e92	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e95	48					.byte $48
.9e96					Assemble_cli:
.9e96	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e99	58					.byte $58
.9e9a					Assemble_phy:
.9e9a	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e9d	5a					.byte $5a
.9e9e					Assemble_rts:
.9e9e	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9ea1	60					.byte $60
.9ea2					Assemble_pla:
.9ea2	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9ea5	68					.byte $68
.9ea6					Assemble_sei:
.9ea6	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9ea9	78					.byte $78
.9eaa					Assemble_ply:
.9eaa	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9ead	7a					.byte $7a
.9eae					Assemble_dey:
.9eae	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9eb1	88					.byte $88
.9eb2					Assemble_txa:
.9eb2	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9eb5	8a					.byte $8a
.9eb6					Assemble_tya:
.9eb6	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9eb9	98					.byte $98
.9eba					Assemble_txs:
.9eba	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9ebd	9a					.byte $9a
.9ebe					Assemble_tay:
.9ebe	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9ec1	a8					.byte $a8
.9ec2					Assemble_tax:
.9ec2	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9ec5	aa					.byte $aa
.9ec6					Assemble_clv:
.9ec6	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9ec9	b8					.byte $b8
.9eca					Assemble_tsx:
.9eca	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9ecd	ba					.byte $ba
.9ece					Assemble_iny:
.9ece	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9ed1	c8					.byte $c8
.9ed2					Assemble_dex:
.9ed2	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9ed5	ca					.byte $ca
.9ed6					Assemble_cld:
.9ed6	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9ed9	d8					.byte $d8
.9eda					Assemble_phx:
.9eda	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9edd	da					.byte $da
.9ede					Assemble_stp:
.9ede	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9ee1	db					.byte $db
.9ee2					Assemble_inx:
.9ee2	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9ee5	e8					.byte $e8
.9ee6					Assemble_nop:
.9ee6	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9ee9	ea					.byte $ea
.9eea					Assemble_sed:
.9eea	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9eed	f8					.byte $f8
.9eee					Assemble_plx:
.9eee	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9ef1	fa					.byte $fa

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/constants.asm

.9ef2					DecimalScalarTable:
>9ef2	66 66 66 66				.dword $66666666 ; 0.1
>9ef6	de					.byte $de
>9ef7	1f 85 eb 51				.dword $51eb851f ; 0.01
>9efb	db					.byte $db
>9efc	4c 37 89 41				.dword $4189374c ; 0.001
>9f00	d8					.byte $d8
>9f01	ac 8b db 68				.dword $68db8bac ; 0.0001
>9f05	d4					.byte $d4
>9f06	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>9f0a	d1					.byte $d1
>9f0b	83 de 1b 43				.dword $431bde83 ; 1e-06
>9f0f	ce					.byte $ce
>9f10	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>9f14	ca					.byte $ca
>9f15	89 3b e6 55				.dword $55e63b89 ; 1e-08
>9f19	c7					.byte $c7
>9f1a	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>9f1e	c4					.byte $c4
>9f1f	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>9f23	c0					.byte $c0
>9f24	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>9f28	bd					.byte $bd

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.asm

.9f29					SyntaxError:
.9f29	a9 02		lda #$02		lda	#2
.9f2b	4c a4 8e	jmp $8ea4		jmp	ErrorHandler
.9f2e					RangeError:
.9f2e	a9 04		lda #$04		lda	#4
.9f30	4c a4 8e	jmp $8ea4		jmp	ErrorHandler
.9f33					TypeError:
.9f33	a9 05		lda #$05		lda	#5
.9f35	4c a4 8e	jmp $8ea4		jmp	ErrorHandler
.9f38					ArgumentError:
.9f38	a9 07		lda #$07		lda	#7
.9f3a	4c a4 8e	jmp $8ea4		jmp	ErrorHandler
.9f3d					NotDoneError:
.9f3d	a9 0c		lda #$0c		lda	#12
.9f3f	4c a4 8e	jmp $8ea4		jmp	ErrorHandler
.9f42					ErrorText:
>9f42	42 72 65 61 6b 00			.text	"Break",0
>9f48	53 79 6e 74 61 78 20 65			.text	"Syntax error",0
>9f50	72 72 6f 72 00
>9f55	44 69 76 69 73 69 6f 6e			.text	"Division by zero",0
>9f5d	20 62 79 20 7a 65 72 6f 00
>9f66	4f 75 74 20 6f 66 20 52			.text	"Out of Range",0
>9f6e	61 6e 67 65 00
>9f73	54 79 70 65 20 6d 69 73			.text	"Type mismatch",0
>9f7b	6d 61 74 63 68 00
>9f81	4f 75 74 20 6f 66 20 6d			.text	"Out of memory",0
>9f89	65 6d 6f 72 79 00
>9f8f	49 6c 6c 65 67 61 6c 20			.text	"Illegal argument",0
>9f97	61 72 67 75 6d 65 6e 74 00
>9fa0	53 74 6f 70 00				.text	"Stop",0
>9fa5	53 74 72 69 6e 67 20 74			.text	"String too long",0
>9fad	6f 6f 20 6c 6f 6e 67 00
>9fb5	41 73 73 65 72 74 69 6f			.text	"Assertion failed",0
>9fbd	6e 20 66 61 69 6c 65 64 00
>9fc6	4f 75 74 20 6f 66 20 64			.text	"Out of data",0
>9fce	61 74 61 00
>9fd2	55 6e 69 6d 70 6c 65 6d			.text	"Unimplemented",0
>9fda	65 6e 74 65 64 00
>9fe0	4e 6f 20 73 75 63 68 20			.text	"No such line number",0
>9fe8	6c 69 6e 65 20 6e 75 6d 62 65 72 00
>9ff4	52 65 74 75 72 6e 20 77			.text	"Return without Gosub",0
>9ffc	69 74 68 6f 75 74 20 47 6f 73 75 62 00
>a009	55 6e 74 69 6c 20 77 69			.text	"Until without Repeat",0
>a011	74 68 6f 75 74 20 52 65 70 65 61 74 00
>a01e	57 65 6e 64 20 77 69 74			.text	"Wend without While",0
>a026	68 6f 75 74 20 57 68 69 6c 65 00
>a031	4e 65 78 74 20 77 69 74			.text	"Next without For",0
>a039	68 6f 75 74 20 46 6f 72 00
>a042	42 41 53 49 43 20 53 74			.text	"BASIC Stack full",0
>a04a	61 63 6b 20 66 75 6c 6c 00
>a053	4f 70 65 6e 20 53 74 72			.text	"Open Structure",0
>a05b	75 63 74 75 72 65 00
>a062	45 6e 64 50 72 6f 63 20			.text	"EndProc without call",0
>a06a	77 69 74 68 6f 75 74 20 63 61 6c 6c 00
>a077	41 72 72 61 79 20 61 6c			.text	"Array already defined",0
>a07f	72 65 61 64 79 20 64 65 66 69 6e 65 64 00
>a08d	41 72 72 61 79 20 73 69			.text	"Array size",0
>a095	7a 65 00
>a098	42 61 64 20 61 72 72 61			.text	"Bad array index",0
>a0a0	79 20 69 6e 64 65 78 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/timestamp.asm

>a0a8	52 65 6c 65 61 73 65 20			.text "Release Alpha 6 (26-Nov-22). "
>a0b0	41 6c 70 68 61 20 36 20 28 32 36 2d 4e 6f 76 2d
>a0c0	32 32 29 2e 20

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcommand.asm

.a0c5					RectangleCommand:
.a0c5	a9 44		lda #$44			lda 	#GCMD_FrameRect				; frame rectangle
.a0c7	80 02		bra $a0cb			bra 	ShapeDrawCmd
.a0c9					CircleCommand:
.a0c9	a9 48		lda #$48			lda 	#GCMD_FrameCircle 				; framed circle
.a0cb					ShapeDrawCmd:
.a0cb	20 55 a1	jsr $a155			jsr 	RunGraphicsCommand
.a0ce					ShapeDraw:
.a0ce	0d b1 05	ora $05b1			ora 	gxFillSolid  				; adjust AXY for solid fill.
.a0d1	4c 49 a1	jmp $a149			jmp 	ExecuteGraphicCommand	 	; and complete
.a0d4					SpriteCommand:
.a0d4	a2 00		ldx #$00			ldx 	#0
.a0d6	20 4c 9d	jsr $9d4c			jsr 	Evaluate8BitInteger 		; get image number.
.a0d9	5a		phy				phy
.a0da	a9 0e		lda #$0e			lda 	#GCMD_SpriteUse 			; use that image.
.a0dc	a6 58		ldx $58				ldx 	NSMantissa0
.a0de	e0 40		cpx #$40			cpx 	#64 						; 0-63 only
.a0e0	b0 0d		bcs $a0ef			bcs 	_SCRange
.a0e2	a0 ff		ldy #$ff			ldy 	#255
.a0e4	20 25 aa	jsr $aa25			jsr 	GXGraphicDraw
.a0e7	a9 52		lda #$52			lda 	#GCMD_SpriteMove
.a0e9	7a		ply				ply
.a0ea	20 55 a1	jsr $a155			jsr 	RunGraphicsCommand
.a0ed	80 5a		bra $a149			bra 	ExecuteGraphicCommand
.a0ef					_SCRange:
.a0ef	4c 2e 9f	jmp $9f2e			jmp 	RangeError
.a0f2					ImageCommand:
.a0f2	a2 00		ldx #$00			ldx 	#0
.a0f4	20 4c 9d	jsr $9d4c			jsr 	Evaluate8BitInteger 		; get image number.
.a0f7	20 55 a1	jsr $a155			jsr 	RunGraphicsCommand
.a0fa					ImageRunDraw:
.a0fa	09 40		ora #$40			ora 	#GCMD_Move					; move cursor
.a0fc	20 25 aa	jsr $aa25			jsr 	GXGraphicDraw
.a0ff	ad b7 05	lda $05b7			lda 	gxDrawScale
.a102	0a		asl a				asl 	a
.a103	0a		asl a				asl 	a
.a104	0a		asl a				asl 	a
.a105	a8		tay				tay
.a106	a9 0c		lda #$0c			lda 	#GCMD_DrawSprite 			; image drawing
.a108	a6 58		ldx $58				ldx 	NSMantissa0
.a10a	20 25 aa	jsr $aa25			jsr 	GXGraphicDraw
.a10d	60		rts				rts
.a10e					TextCommand:
.a10e	a2 00		ldx #$00			ldx 	#0
.a110	20 09 9d	jsr $9d09			jsr 	EvaluateString 				; get text
.a113	20 55 a1	jsr $a155			jsr 	RunGraphicsCommand
.a116					TextRunDraw:
.a116	09 40		ora #$40			ora 	#GCMD_Move 					; move cursor
.a118	20 25 aa	jsr $aa25			jsr 	GXGraphicDraw
.a11b	a0 00		ldy #$00			ldy 	#0
.a11d					_IRDLoop:
.a11d	a5 60		lda $60				lda 	NSMantissa1 				; access character
.a11f	85 37		sta $37				sta 	zTemp0+1
.a121	a5 58		lda $58				lda 	NSMantissa0
.a123	85 36		sta $36				sta 	zTemp0
.a125	b1 36		lda ($36),y			lda 	(zTemp0),y
.a127	f0 13		beq $a13c			beq 	_IRDExit
.a129	5a		phy				phy									; save string pos
.a12a	48		pha				pha 								; save char
.a12b	ad b7 05	lda $05b7			lda 	gxDrawScale 				; get scale
.a12e	0a		asl a				asl 	a
.a12f	0a		asl a				asl 	a
.a130	0a		asl a				asl 	a
.a131	a8		tay				tay
.a132	a9 0a		lda #$0a			lda 	#GCMD_DrawFont 				; char drawing
.a134	fa		plx				plx 								; char to draw
.a135	20 25 aa	jsr $aa25			jsr 	GXGraphicDraw
.a138	7a		ply				ply 								; restore string pos
.a139	c8		iny				iny
.a13a	90 e1		bcc $a11d			bcc 	_IRDLoop 					; go back if no error.
.a13c					_IRDExit:
.a13c	60		rts				rts
.a13d					PlotCommand:
.a13d	a9 50		lda #$50			lda 	#GCMD_Plot 					; command ID to use
.a13f	20 55 a1	jsr $a155			jsr 	RunGraphicsCommand
.a142	80 05		bra $a149			bra 	ExecuteGraphicCommand
.a144					LineCommand:
.a144	a9 42		lda #$42			lda 	#GCMD_Line 						; command ID to use
.a146	20 55 a1	jsr $a155			jsr 	RunGraphicsCommand
.a149					ExecuteGraphicCommand:
.a149	0d b0 05	ora $05b0			ora 	gxCommandID 				; make a full command
.a14c	20 25 aa	jsr $aa25			jsr 	GXGraphicDraw 				; draw it and exit
.a14f	b0 01		bcs $a152			bcs 	_EGCError
.a151	60		rts				rts
.a152					_EGCError:
.a152	4c 29 9f	jmp $9f29			jmp 	SyntaxError
.a155					RunGraphicsCommand:
.a155	8d b0 05	sta $05b0			sta 	gxCommandID					; save TODO graphics command.
.a158	68		pla				pla 								; pop handler address
.a159	fa		plx				plx
.a15a	1a		inc a				inc 	a
.a15b	d0 01		bne $a15e			bne 	_RGINoCarry
.a15d	e8		inx				inx
.a15e					_RGINoCarry:
.a15e	8d b5 05	sta $05b5			sta 	GXHandler
.a161	8e b6 05	stx $05b6			stx 	GXHandler+1
.a164					_RGICommandLoop:
.a164	b1 30		lda ($30),y			lda 	(codePtr),y
.a166	c8		iny				iny
.a167	c9 ce		cmp #$ce			cmp 	#KWD_TO						; is it TO x,y
.a169	f0 53		beq $a1be			beq 	_RGI_To
.a16b	c9 ba		cmp #$ba			cmp 	#KWD_HERE 					; do it here.
.a16d	f0 55		beq $a1c4			beq 	_RGI_Here
.a16f	c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL or : , exit
.a171	f0 3d		beq $a1b0			beq 	_RGI_Exit
.a173	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.a175	f0 39		beq $a1b0			beq 	_RGI_Exit
.a177	c9 c2		cmp #$c2			cmp 	#KWD_OUTLINE 				; solid or outline
.a179	f0 3e		beq $a1b9			beq 	_RGI_Frame
.a17b	c9 ca		cmp #$ca			cmp 	#KWD_SOLID
.a17d	f0 33		beq $a1b2			beq 	_RGI_Solid
.a17f	c9 ab		cmp #$ab			cmp 	#KWD_BY 					; by offset
.a181	f0 4b		beq $a1ce			beq 	_RGI_By
.a183	c9 b6		cmp #$b6			cmp 	#KWD_FROM 					; from
.a185	f0 17		beq $a19e			beq 	_RGI_Move2
.a187	c9 b3		cmp #$b3			cmp 	#KWD_DIM 					; dim (set scale)
.a189	f0 62		beq $a1ed			beq 	_RGI_Dim
.a18b	c9 b1		cmp #$b1			cmp 	#KWD_COLOUR 				; colour or Color
.a18d	f0 74		beq $a203			beq 	_RGI_Colour
.a18f	c9 b0		cmp #$b0			cmp 	#KWD_COLOR
.a191	f0 70		beq $a203			beq 	_RGI_Colour
.a193	ae b0 05	ldx $05b0			ldx 	gxCommandID
.a196	e0 52		cpx #$52			cpx 	#GCMD_SpriteMove 			; if not sprite
.a198	d0 03		bne $a19d			bne 	_RGI_Move 					; move
.a19a	4c 2b a2	jmp $a22b			jmp		_RGI_SpriteInstructions
.a19d					_RGI_Move:
.a19d	88		dey				dey 								; unpick get.
.a19e					_RGI_Move2:
.a19e	20 51 a2	jsr $a251			jsr 	GCGetCoordinatePair 		; move to here
.a1a1	20 78 a2	jsr $a278			jsr 	GCCopyPairToStore 			; save
.a1a4	5a		phy				phy
.a1a5	20 6e a2	jsr $a26e			jsr 	GCLoadAXY 					; load in
.a1a8	09 40		ora #$40			ora 	#GCMD_Move 					; move there
.a1aa	20 25 aa	jsr $aa25			jsr 	GXGraphicDraw
.a1ad	7a		ply				ply
.a1ae	80 b4		bra $a164			bra 	_RGICommandLoop 			; and go round
.a1b0					_RGI_Exit:
.a1b0	88		dey				dey 								; unpick : / EOL
.a1b1	60		rts				rts
.a1b2					_RGI_Solid:
.a1b2	a9 02		lda #$02			lda 	#2
.a1b4	8d b1 05	sta $05b1			sta 	gxFillSolid
.a1b7	80 ab		bra $a164			bra 	_RGICommandLoop
.a1b9					_RGI_Frame:
.a1b9	9c b1 05	stz $05b1			stz 	gxFillSolid
.a1bc	80 a6		bra $a164			bra 	_RGICommandLoop
.a1be					_RGI_To:
.a1be	20 51 a2	jsr $a251			jsr 	GCGetCoordinatePair 		; get coordinate pair into slot #1,#2
.a1c1	20 78 a2	jsr $a278			jsr 	GCCopyPairToStore
.a1c4					_RGI_Here:
.a1c4	5a		phy				phy
.a1c5	20 6e a2	jsr $a26e			jsr 	GCLoadAXY 					; load it into AXY
.a1c8	20 28 a2	jsr $a228			jsr 	_RGICallHandler 			; go do whatever it is.
.a1cb	7a		ply				ply
.a1cc	80 96		bra $a164			bra 	_RGICommandLoop 			; and go round
.a1ce					_RGI_By:
.a1ce	20 5e a2	jsr $a25e			jsr 	GCSignedCoordinatePair 		; get coordinate pair into slot #1,#2
.a1d1	18		clc				clc
.a1d2	a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.a1d4	6d b2 05	adc $05b2			adc 	gxxPos
.a1d7	8d b2 05	sta $05b2			sta 	gxXPos
.a1da	a5 61		lda $61				lda 	NSMantissa1+1
.a1dc	6d b3 05	adc $05b3			adc 	gxxPos+1
.a1df	8d b3 05	sta $05b3			sta 	gxXPos+1
.a1e2	a5 5a		lda $5a				lda 	NSMantissa0+2
.a1e4	18		clc				clc
.a1e5	6d b4 05	adc $05b4			adc 	gxYPos
.a1e8	8d b4 05	sta $05b4			sta 	gxYPos
.a1eb	80 d7		bra $a1c4			bra 	_RGI_Here
.a1ed					_RGI_Dim:
.a1ed	a2 01		ldx #$01			ldx	 	#1
.a1ef	20 4c 9d	jsr $9d4c			jsr 	Evaluate8BitInteger
.a1f2	a5 59		lda $59				lda 	NSMantissa0+1
.a1f4	c9 00		cmp #$00			cmp 	#0
.a1f6	f0 2d		beq $a225			beq 	_RGIRange
.a1f8	c9 09		cmp #$09			cmp 	#8+1
.a1fa	b0 29		bcs $a225			bcs		_RGIRange
.a1fc	3a		dec a				dec 	a
.a1fd	8d b7 05	sta $05b7			sta 	gxDrawScale
.a200	4c 64 a1	jmp $a164			jmp 	_RGICommandLoop
.a203					_RGI_Colour:
.a203	a2 01		ldx #$01			ldx 	#1 							; colour
.a205	20 4c 9d	jsr $9d4c			jsr 	Evaluate8BitInteger
.a208	a2 02		ldx #$02			ldx 	#2 							; default zero for 2nd parameter
.a20a	20 b1 9d	jsr $9db1			jsr 	NSMSetZero
.a20d	b1 30		lda ($30),y			lda 	(codePtr),y
.a20f	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; check , => mode.
.a211	d0 04		bne $a217			bne 	_RGICDefaultMode
.a213	c8		iny				iny
.a214	20 4c 9d	jsr $9d4c			jsr 	Evaluate8BitInteger
.a217					_RGICDefaultMode:
.a217	5a		phy				phy
.a218	a9 08		lda #$08			lda 	#GCMD_Colour 				; set colour.
.a21a	a6 59		ldx $59				ldx 	NSMantissa0+1
.a21c	a4 5a		ldy $5a				ldy 	NSMantissa0+2
.a21e	20 25 aa	jsr $aa25			jsr 	GXGraphicDraw
.a221	7a		ply				ply
.a222	4c 64 a1	jmp $a164			jmp 	_RGICommandLoop 			; and go round
.a225					_RGIRange:
.a225	4c 2e 9f	jmp $9f2e			jmp 	RangeError
.a228					_RGICallHandler:
.a228	6c b5 05	jmp ($05b5)			jmp 	(GXHandler)
.a22b					_RGI_SpriteInstructions:
.a22b	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a22d	f0 07		beq $a236			beq 	_RGISpriteOff
.a22f	c9 bb		cmp #$bb			cmp 	#KWD_IMAGE
.a231	f0 13		beq $a246			beq 	_RGISetImage
.a233	4c 9d a1	jmp $a19d			jmp 	_RGI_Move
.a236					_RGISpriteOff:
.a236	5a		phy				phy
.a237	a0 01		ldy #$01			ldy 	#1
.a239	a2 00		ldx #$00			ldx 	#0
.a23b					_RGIDoCommandLoop:
.a23b	a9 10		lda #$10			lda 	#GCMD_SpriteImage
.a23d	20 25 aa	jsr $aa25			jsr 	GXGraphicDraw
.a240	7a		ply				ply
.a241	b0 e2		bcs $a225			bcs 	_RGIRange
.a243	4c 64 a1	jmp $a164			jmp 	_RGICommandLoop
.a246					_RGISetImage:
.a246	a2 01		ldx #$01			ldx 	#1
.a248	20 4c 9d	jsr $9d4c			jsr 	Evaluate8BitInteger
.a24b	5a		phy				phy
.a24c	aa		tax				tax
.a24d	a0 00		ldy #$00			ldy 	#0
.a24f	80 ea		bra $a23b			bra 	_RGIDoCommandLoop
.a251					GCGetCoordinatePair:
.a251	a2 01		ldx #$01			ldx 	#1
.a253	20 31 9d	jsr $9d31			jsr 	Evaluate16BitInteger
.a256	20 93 8e	jsr $8e93			jsr 	CheckComma
.a259	e8		inx				inx
.a25a	20 31 9d	jsr $9d31			jsr 	Evaluate16BitInteger
.a25d	60		rts				rts
.a25e					GCSignedCoordinatePair:
.a25e	a2 01		ldx #$01			ldx 	#1
.a260	20 3b 9d	jsr $9d3b			jsr 	Evaluate16BitIntegerSigned
.a263	20 93 8e	jsr $8e93			jsr 	CheckComma
.a266	e8		inx				inx
.a267	20 3b 9d	jsr $9d3b			jsr 	Evaluate16BitIntegerSigned
.a26a	60		rts				rts
.a26b					_GCCPRange:
.a26b	4c 2e 9f	jmp $9f2e			jmp 	RangeError
.a26e					GCLoadAXY:
.a26e	ad b3 05	lda $05b3			lda 	gxXPos+1
.a271	ae b2 05	ldx $05b2			ldx 	gxXPos
.a274	ac b4 05	ldy $05b4			ldy 	gxYPos
.a277	60		rts				rts
.a278					GCCopyPairToStore:
.a278	a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.a27a	8d b2 05	sta $05b2			sta 	gxXPos
.a27d	a5 61		lda $61				lda 	NSMantissa1+1
.a27f	8d b3 05	sta $05b3			sta 	gxXPos+1
.a282	a5 5a		lda $5a				lda 	NSMantissa0+2
.a284	8d b4 05	sta $05b4			sta 	gxYPos
.a287	60		rts				rts
.05b0					gxCommandID:
>05b0							.fill 	1
.05b1					gxFillSolid:
>05b1							.fill 	1
.05b2					gxXPos:
>05b2							.fill 	2
.05b4					gxYPos:
>05b4							.fill 	1
.05b5					gxHandler:
>05b5							.fill 	2
.05b7					gxDrawScale:
>05b7							.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcontrol.asm

.a288					BitmapCtrl:
.a288	b1 30		lda ($30),y			lda 	(codePtr),y
.a28a	c8		iny				iny
.a28b	a2 01		ldx #$01			ldx 	#1
.a28d	c9 c1		cmp #$c1			cmp 	#KWD_ON
.a28f	f0 11		beq $a2a2			beq 	BitmapSwitch
.a291	ca		dex				dex
.a292	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a294	f0 0c		beq $a2a2			beq 	BitmapSwitch
.a296	20 4c 9d	jsr $9d4c			jsr 	Evaluate8BitInteger 		; get the colour
.a299	5a		phy				phy
.a29a	aa		tax				tax
.a29b	a9 06		lda #$06			lda 	#GCMD_Clear					; clear to that colour
.a29d	20 25 aa	jsr $aa25			jsr 	GXGraphicDraw
.a2a0	7a		ply				ply
.a2a1	60		rts				rts
.a2a2					BitmapSwitch:
.a2a2	5a		phy				phy
.a2a3	a0 00		ldy #$00			ldy 	#0 							; gfx 1,on/off,0
.a2a5	a9 02		lda #$02			lda 	#GCMD_BitmapCtl
.a2a7	20 25 aa	jsr $aa25			jsr 	GXGraphicDraw
.a2aa	a9 08		lda #$08			lda 	#GCMD_Colour				; set colour to $FF
.a2ac	a0 00		ldy #$00			ldy 	#0
.a2ae	a2 ff		ldx #$ff			ldx 	#$FF
.a2b0	20 25 aa	jsr $aa25			jsr 	GXGraphicDraw
.a2b3	9c b1 05	stz $05b1			stz 	gxFillSolid
.a2b6	9c b2 05	stz $05b2			stz 	gxXPos
.a2b9	9c b3 05	stz $05b3			stz 	gxXPos+1
.a2bc	9c b4 05	stz $05b4			stz 	gxYPos
.a2bf	9c b7 05	stz $05b7			stz 	gxDrawScale
.a2c2	a9 40		lda #$40			lda 	#GCMD_Move 						; home cursor
.a2c4	a2 00		ldx #$00			ldx 	#0
.a2c6	a0 00		ldy #$00			ldy 	#0
.a2c8	20 25 aa	jsr $aa25			jsr 	GXGraphicDraw
.a2cb	7a		ply				ply
.a2cc	60		rts				rts
.a2cd					SpritesCtrl:
.a2cd	b1 30		lda ($30),y			lda 	(codePtr),y
.a2cf	c8		iny				iny
.a2d0	a2 01		ldx #$01			ldx 	#1
.a2d2	c9 c1		cmp #$c1			cmp 	#KWD_ON
.a2d4	f0 08		beq $a2de			beq 	SpriteSwitch
.a2d6	ca		dex				dex
.a2d7	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a2d9	f0 03		beq $a2de			beq 	SpriteSwitch
.a2db	4c 29 9f	jmp $9f29			jmp 	SyntaxError
.a2de					SpriteSwitch:
.a2de	5a		phy				phy
.a2df	a0 00		ldy #$00			ldy 	#0 							; gfx 2,on/off,0
.a2e1	a9 04		lda #$04			lda 	#GCMD_SpriteCtl
.a2e3	20 25 aa	jsr $aa25			jsr 	GXGraphicDraw
.a2e6	7a		ply				ply
.a2e7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gfx.asm

.a2e8					GfxCommand:
.a2e8	a2 00		ldx #$00			ldx 	#0
.a2ea	20 4c 9d	jsr $9d4c			jsr 	Evaluate8BitInteger 		; command
.a2ed	20 93 8e	jsr $8e93			jsr 	CheckComma
.a2f0	e8		inx				inx
.a2f1	20 31 9d	jsr $9d31			jsr 	Evaluate16BitInteger 		; X
.a2f4	20 93 8e	jsr $8e93			jsr 	CheckComma
.a2f7	e8		inx				inx
.a2f8	20 4c 9d	jsr $9d4c			jsr 	Evaluate8BitInteger 		; Y
.a2fb	a5 61		lda $61				lda 	NSMantissa1+1  				; shift bit 0 of X into CS, should now be zero
.a2fd	4a		lsr a				lsr 	a
.a2fe	d0 12		bne $a312			bne 	_GfxError
.a300	26 58		rol $58				rol 	NSMantissa0 				; rotate into command
.a302	b0 0e		bcs $a312			bcs 	_GfxError 					; bit 7 should have been zero
.a304	5a		phy				phy 								; save pos
.a305	a5 58		lda $58				lda 	NSMantissa0 				; do the command
.a307	a6 59		ldx $59				ldx 	NSMantissa0+1
.a309	a4 5a		ldy $5a				ldy 	NSMantissa0+2
.a30b	20 25 aa	jsr $aa25			jsr 	GXGraphicDraw
.a30e	b0 02		bcs $a312			bcs 	_GfxError
.a310	7a		ply				ply 								; restore pos and exit.
.a311	60		rts				rts
.a312					_GfxError:
.a312	4c 2e 9f	jmp $9f2e			jmp 	RangeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/hit.asm

.a315					UnaryHit:
.a315	fa		plx				plx
.a316	a9 36		lda #$36			lda 	#zTemp0
.a318	20 4c 9d	jsr $9d4c			jsr 	Evaluate8BitInteger 		; get sprite number 0
.a31b	20 93 8e	jsr $8e93			jsr 	CheckComma
.a31e	e8		inx				inx
.a31f	20 4c 9d	jsr $9d4c			jsr 	Evaluate8BitInteger 		; get sprite number 1
.a322	20 8b 8e	jsr $8e8b			jsr		CheckRightBracket
.a325	ca		dex				dex 								; fix back up again.
.a326	da		phx				phx 								; save X/Y
.a327	5a		phy				phy
.a328	b4 59		ldy $59,x			ldy 	NSMantissa0+1,x 			; get the sprite numbers into X/Y
.a32a	b5 58		lda $58,x			lda 	NSMantissa0,x
.a32c	aa		tax				tax
.a32d	a9 12		lda #$12			lda 	#GCMD_SpriteCollide 		; command check collision.
.a32f	20 25 aa	jsr $aa25			jsr 	GXGraphicDraw 				; calculate result
.a332	1a		inc a				inc 	a 							; so 255 (fail) -> 0, otherwise 1,2,3,4 pixels etc.
.a333	7a		ply				ply 								; restore XY
.a334	fa		plx				plx
.a335	20 b3 9d	jsr $9db3			jsr 	NSMSetByte 					; return the hit result
.a338	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/palette.asm

.a339					PaletteCommand:
.a339	a2 00		ldx #$00			ldx 	#0
.a33b	20 4c 9d	jsr $9d4c			jsr 	Evaluate8BitInteger 		; colour
.a33e	20 93 8e	jsr $8e93			jsr 	CheckComma
.a341	e8		inx				inx
.a342	20 31 9d	jsr $9d31			jsr 	Evaluate16BitInteger 		; r
.a345	20 93 8e	jsr $8e93			jsr 	CheckComma
.a348	e8		inx				inx
.a349	20 4c 9d	jsr $9d4c			jsr 	Evaluate8BitInteger 		; g
.a34c	20 93 8e	jsr $8e93			jsr 	CheckComma
.a34f	e8		inx				inx
.a350	20 4c 9d	jsr $9d4c			jsr 	Evaluate8BitInteger 		; b
.a353	a5 58		lda $58				lda 	NSMantissa0 				; get colour #
.a355	85 36		sta $36				sta 	zTemp0
.a357	a9 34		lda #$34			lda 	#$D0 >> 2 					; MSB = D0/4
.a359	85 37		sta $37				sta 	zTemp0+1
.a35b	06 36		asl $36				asl 	zTemp0 						; zTemp = $D000+Colour x 4
.a35d	26 37		rol $37				rol	 	zTemp0+1
.a35f	06 36		asl $36				asl 	zTemp0
.a361	26 37		rol $37				rol	 	zTemp0+1
.a363	a9 01		lda #$01			lda 	#1 							; I/O Page 2
.a365	85 01		sta $01				sta 	1
.a367	5a		phy				phy
.a368	a5 5b		lda $5b				lda 	NSMantissa0+3 				; fix to r,g,b
.a36a	92 36		sta ($36)			sta 	(zTemp0)
.a36c	a0 01		ldy #$01			ldy 	#1
.a36e	a5 5a		lda $5a				lda 	NSMantissa0+2
.a370	91 36		sta ($36),y			sta 	(zTemp0),y
.a372	a5 59		lda $59				lda 	NSMantissa0+1
.a374	c8		iny				iny
.a375	91 36		sta ($36),y			sta 	(zTemp0),y
.a377	7a		ply				ply
.a378	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/event.asm

.a379					UnaryEvent:
.a379	fa		plx				plx
.a37a	20 27 a4	jsr $a427			jsr 	TimerToStackX 				; timer in +0
.a37d	e8		inx				inx  								; put reference into +1
.a37e	20 f2 97	jsr $97f2			jsr 	EvaluateTerm
.a381	b5 50		lda $50,x			lda 	NSStatus,x 					; check if is integer reference
.a383	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.a385	d0 4c		bne $a3d3			bne 	_UEType
.a387	e8		inx				inx 								; put the step in +2
.a388	20 93 8e	jsr $8e93			jsr 	CheckComma
.a38b	20 31 9d	jsr $9d31			jsr 	Evaluate16BitInteger
.a38e	20 8b 8e	jsr $8e8b			jsr 	CheckRightBracket
.a391	ca		dex				dex
.a392	ca		dex				dex
.a393	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy reference to zTemp0
.a395	85 36		sta $36				sta 	zTemp0
.a397	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.a399	85 37		sta $37				sta 	zTemp0+1
.a39b	5a		phy				phy
.a39c	a0 03		ldy #$03			ldy 	#3 							; check bit 7 of last bit, the packed sign bit
.a39e	b1 36		lda ($36),y			lda 	(zTemp0),y
.a3a0	30 2d		bmi $a3cf			bmi 	_UEFalse 					; exit if signed.
.a3a2	a0 00		ldy #$00			ldy 	#0 							; has it timed out (24 bit)
.a3a4	b5 58		lda $58,x			lda 	NSMantissa0,x
.a3a6	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.a3a8	c8		iny				iny
.a3a9	b5 60		lda $60,x			lda 	NSMantissa1,x
.a3ab	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a3ad	c8		iny				iny
.a3ae	b5 68		lda $68,x			lda 	NSMantissa2,x
.a3b0	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a3b2	90 1b		bcc $a3cf			bcc 	_UEFalse 					; no, return FALSE.
.a3b4	18		clc				clc
.a3b5	a0 00		ldy #$00			ldy 	#0 							; work out new value as timer() + step
.a3b7	b5 58		lda $58,x			lda 	NSMantissa0,x
.a3b9	75 5a		adc $5a,x			adc 	NSMantissa0+2,x
.a3bb	91 36		sta ($36),y			sta 	(zTemp0),y
.a3bd	c8		iny				iny
.a3be	b5 60		lda $60,x			lda 	NSMantissa1,x
.a3c0	75 62		adc $62,x			adc 	NSMantissa1+2,x
.a3c2	91 36		sta ($36),y			sta 	(zTemp0),y
.a3c4	c8		iny				iny
.a3c5	b5 68		lda $68,x			lda 	NSMantissa2,x
.a3c7	75 6a		adc $6a,x			adc 	NSMantissa2+2,x
.a3c9	91 36		sta ($36),y			sta 	(zTemp0),y
.a3cb	7a		ply				ply
.a3cc	4c 11 8f	jmp $8f11			jmp 	ReturnTrue
.a3cf					_UEFalse:
.a3cf	7a		ply				ply 								; restore Y
.a3d0	4c 1c 8f	jmp $8f1c			jmp 	ReturnFalse 				; and return False
.a3d3					_UEType:
.a3d3	4c 33 9f	jmp $9f33			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/joy.asm

.a3d6					UnaryJoyX:
.a3d6	18		clc				clc
.a3d7	80 01		bra $a3da			bra 	JoyMain
.a3d9					UnaryJoyY:
.a3d9	38		sec				sec
.a3da					JoyMain:
.a3da	fa		plx				plx 								; get pos
.a3db	08		php				php 								; save carry (set for Y)
.a3dc	20 4c 9d	jsr $9d4c			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a3df	20 8b 8e	jsr $8e8b			jsr 	CheckRightBracket
.a3e2	20 de a9	jsr $a9de			jsr 	EXTReadController 			; read the controller.
.a3e5	28		plp				plp
.a3e6	90 02		bcc $a3ea			bcc 	_JMNoShift 					; if Y then shift bits 3,2 -> 1,0
.a3e8	4a		lsr a				lsr 	a
.a3e9	4a		lsr a				lsr 	a
.a3ea					_JMNoShift:
.a3ea	4a		lsr a				lsr 	a 							; if bit 0 set then right/down e.g. +1
.a3eb	b0 0a		bcs $a3f7			bcs 	_JMIsRight
.a3ed	4a		lsr a				lsr 	a 							; if bit 1 set then left/up e.g. -1
.a3ee	b0 04		bcs $a3f4			bcs 	_JMIsLeft
.a3f0	20 b1 9d	jsr $9db1			jsr 	NSMSetZero 					; zero result
.a3f3	60		rts				rts
.a3f4					_JMIsLeft:
.a3f4	4c 11 8f	jmp $8f11			jmp 	ReturnTrue
.a3f7					_JMIsRight:
.a3f7	a9 01		lda #$01			lda 	#1
.a3f9	20 b3 9d	jsr $9db3			jsr 	NSMSetByte
.a3fc	60		rts				rts
.a3fd					UnaryJoyB:
.a3fd	fa		plx				plx 								; get pos
.a3fe	20 4c 9d	jsr $9d4c			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a401	20 8b 8e	jsr $8e8b			jsr 	CheckRightBracket
.a404	20 de a9	jsr $a9de			jsr 	EXTReadController 			; read the controller.
.a407	4a		lsr a				lsr 	a
.a408	4a		lsr a				lsr 	a
.a409	4a		lsr a				lsr 	a
.a40a	4a		lsr a				lsr 	a
.a40b	29 01		and #$01			and 	#1
.a40d	20 b3 9d	jsr $9db3			jsr 	NSMSetByte
.a410	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/load.asm

.a411					LoadCommand:
.a411	20 93 89	jsr $8993			jsr 	NewProgram
.a414	20 d2 82	jsr $82d2			jsr 	BackLoadProgram
.a417	4c 6a 83	jmp $836a			jmp 	WarmStart
.a41a					GoCommand:
.a41a	20 93 89	jsr $8993			jsr 	NewProgram
.a41d	20 d2 82	jsr $82d2			jsr 	BackLoadProgram
.a420	4c cf 8a	jmp $8acf			jmp 	CommandRun

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/timer.asm

.a423					UnaryTimer:
.a423	fa		plx				plx
.a424	20 8b 8e	jsr $8e8b			jsr 	CheckRightBracket
.a427					TimerToStackX:
.a427	20 b1 9d	jsr $9db1			jsr 	NSMSetZero 					; zero result
.a42a	64 01		stz $01				stz 	1 							; access I/O
.a42c	ad 59 d6	lda $d659			lda 	$D659 						; copy timer in
.a42f	95 58		sta $58,x			sta 	NSMantissa0,x
.a431	ad 5a d6	lda $d65a			lda 	$D65A
.a434	95 60		sta $60,x			sta 	NSMantissa1,x
.a436	ad 5b d6	lda $d65b			lda 	$D65B
.a439	95 68		sta $68,x			sta 	NSMantissa2,x
.a43b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/delete.asm

.a43c					MemoryDeleteLine:
.a43c	20 5b a4	jsr $a45b			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a43f	b2 30		lda ($30)			lda 	(codePtr) 					; size to delete => y
.a441	a8		tay				tay
.a442					_MDDLLoop:
.a442	b1 30		lda ($30),y			lda 	(codePtr),y 				; copy down
.a444	92 30		sta ($30)			sta 	(codePtr)
.a446	a5 30		lda $30				lda 	codePtr 					; check done the lot.
.a448	c5 3a		cmp $3a				cmp 	zTemp2
.a44a	d0 07		bne $a453			bne 	_MDLDLNext
.a44c	a5 31		lda $31				lda 	codePtr+1
.a44e	c5 3b		cmp $3b				cmp 	zTemp2+1
.a450	d0 01		bne $a453			bne 	_MDLDLNext
.a452					_MDDLExit:
.a452	60		rts				rts
.a453					_MDLDLNext:
.a453	e6 30		inc $30				inc 	codePtr						; next byte
.a455	d0 eb		bne $a442			bne 	_MDDLLoop
.a457	e6 31		inc $31				inc 	codePtr+1
.a459	80 e7		bra $a442			bra 	_MDDLLoop
.a45b					IMemoryFindEnd:
.a45b	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a45d	85 3a		sta $3a				sta 	0+zTemp2
.a45f	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a461	85 3b		sta $3b				sta 	1+zTemp2
.a463					_MDLFELoop:
.a463	b2 3a		lda ($3a)			lda 	(zTemp2)
.a465	f0 0b		beq $a472			beq 	_MDLFEExit
.a467	18		clc				clc
.a468	65 3a		adc $3a				adc 	zTemp2
.a46a	85 3a		sta $3a				sta 	zTemp2
.a46c	90 f5		bcc $a463			bcc 	_MDLFELoop
.a46e	e6 3b		inc $3b				inc 	zTemp2+1
.a470	80 f1		bra $a463			bra 	_MDLFELoop
.a472					_MDLFEExit:
.a472	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/insert.asm

.a473					MemoryInsertLine:
.a473	08		php				php
.a474	20 5b a4	jsr $a45b			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a477	a5 3b		lda $3b				lda 	zTemp2+1 					; space ?
.a479	1a		inc a				inc 	a
.a47a	c9 7f		cmp #$7f			cmp 	#(BasicEnd >> 8)-1
.a47c	b0 36		bcs $a4b4			bcs 	_MDLIError
.a47e	28		plp				plp
.a47f	90 08		bcc $a489			bcc 	_MDLIFound
.a481	a5 3a		lda $3a				lda 	zTemp2 						; if CS on entry append.
.a483	85 30		sta $30				sta 	codePtr
.a485	a5 3b		lda $3b				lda 	zTemp2+1
.a487	85 31		sta $31				sta 	codePtr+1
.a489					_MDLIFound:
.a489	ad 2a 04	lda $042a			lda 	tokenOffset 				; insert gap in Y, the offset, e.g. length of the new line
.a48c	a8		tay				tay
.a48d					_MDLIInsert:
.a48d	b2 3a		lda ($3a)			lda 	(zTemp2) 					; shift one byte up , at least one covers end case.
.a48f	91 3a		sta ($3a),y			sta 	(zTemp2),y 					; work from top down.
.a491	a5 30		lda $30				lda 	codePtr 					; done insert point ?
.a493	c5 3a		cmp $3a				cmp 	zTemp2
.a495	d0 06		bne $a49d			bne 	_MDLINext
.a497	a5 31		lda $31				lda 	codePtr+1
.a499	c5 3b		cmp $3b				cmp 	zTemp2+1
.a49b	f0 0a		beq $a4a7			beq 	_MDLIHaveSpace
.a49d					_MDLINext:
.a49d	a5 3a		lda $3a				lda 	zTemp2 						; if no, keep zTemp2 going backwards
.a49f	d0 02		bne $a4a3			bne 	_MDLINoBorrow
.a4a1	c6 3b		dec $3b				dec 	zTemp2+1
.a4a3					_MDLINoBorrow:
.a4a3	c6 3a		dec $3a				dec 	zTemp2
.a4a5	80 e6		bra $a48d			bra 	_MDLIInsert
.a4a7					_MDLIHaveSpace:
.a4a7	ac 2a 04	ldy $042a			ldy 	tokenOffset 				; bytes to copy
.a4aa	88		dey				dey 								; from offset-1 to 0
.a4ab					_MDLICopy:
.a4ab	b9 2a 04	lda $042a,y			lda 	tokenOffset,y
.a4ae	91 30		sta ($30),y			sta 	(codePtr),y
.a4b0	88		dey				dey
.a4b1	10 f8		bpl $a4ab			bpl 	_MDLICopy
.a4b3	60		rts				rts
.a4b4					_MDLIError:
.a4b4	a9 06		lda #$06		lda	#6
.a4b6	4c a4 8e	jmp $8ea4		jmp	ErrorHandler
.a4b9					MDLAppendLine:
.a4b9	86 37		stx $37				stx 	zTemp0+1 					; save new line at zTemp0
.a4bb	85 36		sta $36				sta 	zTemp0
.a4bd	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a4bf	85 38		sta $38				sta 	0+zTemp1
.a4c1	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a4c3	85 39		sta $39				sta 	1+zTemp1
.a4c5	b2 38		lda ($38)			lda 	(zTemp1)
.a4c7	d0 0a		bne $a4d3			bne 	_MDLANoInitialise
.a4c9	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a4cb	8d b8 05	sta $05b8			sta 	0+AppendPointer
.a4ce	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a4d0	8d b9 05	sta $05b9			sta 	1+AppendPointer
.a4d3					_MDLANoInitialise:
.a4d3	18		clc				clc
.a4d4	ad b8 05	lda $05b8			lda 	AppendPointer 				; copy append pointer to zTemp1 adding the offset as you go
.a4d7	85 38		sta $38				sta 	zTemp1
.a4d9	72 36		adc ($36)			adc 	(zTemp0)
.a4db	8d b8 05	sta $05b8			sta 	AppendPointer
.a4de	ad b9 05	lda $05b9			lda 	AppendPointer+1
.a4e1	85 39		sta $39				sta 	zTemp1+1
.a4e3	69 00		adc #$00			adc 	#0
.a4e5	8d b9 05	sta $05b9			sta 	AppendPointer+1
.a4e8	a0 00		ldy #$00			ldy 	#0
.a4ea					_MDLACopy:
.a4ea	b1 36		lda ($36),y			lda 	(zTemp0),y 					; copy new line in
.a4ec	91 38		sta ($38),y			sta 	(zTemp1),y
.a4ee	c8		iny				iny
.a4ef	98		tya				tya
.a4f0	d2 36		cmp ($36)			cmp 	(zTemp0) 					; done whole line
.a4f2	d0 f6		bne $a4ea			bne 	_MDLACopy
.a4f4	a9 00		lda #$00			lda 	#0 							; end of program.
.a4f6	91 38		sta ($38),y			sta 	(zTemp1),y
.a4f8	60		rts				rts
.05b8					AppendPointer:
>05b8							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/memory.asm

.a4f9					MemoryNew:
.a4f9	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a4fb	85 30		sta $30				sta 	codePtr
.a4fd	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a4ff	85 31		sta $31				sta 	codePtr+1
.a501	a9 00		lda #$00			lda 	#0 							; write zero there erasing the program.
.a503	92 30		sta ($30)			sta 	(codePtr)
.a505	60		rts				rts
.a506					MemoryInline:
.a506	98		tya				tya 								; put address into stack,x
.a507	18		clc				clc  								; get the offset, add codePtr
.a508	65 30		adc $30				adc 	codePtr
.a50a	95 58		sta $58,x			sta 	NSMantissa0,x 				; store the result in the mantissa.
.a50c	a5 31		lda $31				lda 	codePtr+1
.a50e	69 00		adc #$00			adc 	#0
.a510	95 60		sta $60,x			sta 	NSMantissa1,x
.a512	74 68		stz $68,x			stz 	NSMantissa2,x
.a514	74 70		stz $70,x			stz 	NSMantissa3,x
.a516	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/search.asm

.a517					MemorySearch:
.a517	85 36		sta $36				sta 	zTemp0 						; save line number in zTemp0
.a519	86 37		stx $37				stx 	zTemp0+1
.a51b	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a51d	85 30		sta $30				sta 	codePtr
.a51f	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a521	85 31		sta $31				sta 	codePtr+1
.a523					_MTAXLoop:
.a523	b2 30		lda ($30)			lda 	(codePtr)
.a525	18		clc				clc
.a526	f0 21		beq $a549			beq 	_MTAXExit 					; reached end, exit with CC.
.a528	a0 01		ldy #$01			ldy 	#1 							; calculate current line# - requested line#
.a52a	b1 30		lda ($30),y			lda 	(codePtr),y
.a52c	38		sec				sec
.a52d	e5 36		sbc $36				sbc 	zTemp0
.a52f	85 38		sta $38				sta 	zTemp1 						; save interim to set Z
.a531	c8		iny				iny 								; do the MSB
.a532	b1 30		lda ($30),y			lda 	(codePtr),y
.a534	e5 37		sbc $37				sbc 	zTemp0+1
.a536	05 38		ora $38				ora 	zTemp1 						; will set Z if result is zero, doesn't affect carry flag
.a538	f0 0f		beq $a549			beq 	_MTAXExit	 				; found so exit (CS will be set)
.a53a	b0 0d		bcs $a549			bcs 	_MTAXExit 					; current < required exit
.a53c	18		clc				clc
.a53d	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.a53f	65 30		adc $30				adc 	codePtr
.a541	85 30		sta $30				sta 	codePtr
.a543	90 02		bcc $a547			bcc 	_CREExit
.a545	e6 31		inc $31				inc 	codePtr+1 					; carry
.a547					_CREExit:
.a547	80 da		bra $a523			bra 	_MTAXLoop
.a549					_MTAXExit:
.a549	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/playing.asm

.a54a					UnaryPlaying:
.a54a	fa		plx				plx
.a54b	20 4c 9d	jsr $9d4c			jsr 	Evaluate8BitInteger 		; get channel #
.a54e	48		pha				pha
.a54f	20 8b 8e	jsr $8e8b			jsr		CheckRightBracket
.a552	68		pla				pla
.a553	c9 04		cmp #$04			cmp 	#4
.a555	b0 0c		bcs $a563			bcs 	_UPNotPlaying
.a557	09 20		ora #$20			ora 	#$20 						; query playing ?
.a559	20 09 b9	jsr $b909			jsr 	SNDCommand
.a55c	c9 00		cmp #$00			cmp 	#0
.a55e	f0 03		beq $a563			beq 	_UPNotPlaying
.a560	4c 11 8f	jmp $8f11			jmp 	ReturnTrue
.a563					_UPNotPlaying:
.a563	4c 1c 8f	jmp $8f1c			jmp 	ReturnFalse

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/sound.asm

.a566					SoundCommand:
.a566	b1 30		lda ($30),y			lda 	(codePtr),y
.a568	c9 c0		cmp #$c0			cmp 	#KWD_OFF 					; SOUND OFF ?
.a56a	d0 09		bne $a575			bne 	_SNDMain
.a56c	c8		iny				iny 								; skip OFF
.a56d	a9 3f		lda #$3f			lda 	#$3F 						; call command $3F (silence)
.a56f	5a		phy				phy
.a570	20 09 b9	jsr $b909			jsr 	SNDCommand
.a573	7a		ply				ply
.a574	60		rts				rts
.a575					_SNDMain:
.a575	a2 00		ldx #$00			ldx 	#0
.a577	20 4c 9d	jsr $9d4c			jsr 	Evaluate8BitInteger 		; channel
.a57a	c9 04		cmp #$04			cmp 	#4 							; must be 0-3
.a57c	b0 4b		bcs $a5c9			bcs 	_SndError
.a57e	e8		inx				inx 								; do the rest in slot 1.
.a57f	20 93 8e	jsr $8e93			jsr 	CheckComma
.a582	20 31 9d	jsr $9d31			jsr 	Evaluate16BitInteger 		; Pitch
.a585	b5 60		lda $60,x			lda 	NSMantissa1,x 				; must be 10 bit
.a587	c9 10		cmp #$10			cmp 	#16
.a589	b0 3e		bcs $a5c9			bcs 	_SndError
.a58b	8d bb 05	sta $05bb			sta 	SoundCommandBlock+1 		; Pitch (2 bytes + 0)
.a58e	b5 58		lda $58,x			lda 	NSMantissa0,x
.a590	8d ba 05	sta $05ba			sta 	SoundCommandBlock
.a593	20 93 8e	jsr $8e93			jsr 	CheckComma
.a596	20 4c 9d	jsr $9d4c			jsr 	Evaluate8BitInteger 		; Length (1 byte + 3)
.a599	8d bd 05	sta $05bd			sta 	SoundCommandBlock+3
.a59c	a9 0f		lda #$0f			lda 	#15
.a59e	8d bc 05	sta $05bc			sta 	SoundCommandBlock+2 		; Volume (1 byte + 2)
.a5a1	9c be 05	stz $05be			stz 	SoundCommandBlock+4 		; default slide (2 bytes +4)
.a5a4	9c bf 05	stz $05bf			stz 	SoundCommandBlock+5
.a5a7	b1 30		lda ($30),y			lda 	(codePtr),y
.a5a9	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.a5ab	d0 0e		bne $a5bb			bne 	_SNDPlay
.a5ad	c8		iny				iny
.a5ae	20 3b 9d	jsr $9d3b			jsr 	Evaluate16BitIntegerSigned 	; Slide
.a5b1	b5 58		lda $58,x			lda 	NSMantissa0,x 				; Slide (2 bytes + 4)
.a5b3	8d be 05	sta $05be			sta 	SoundCommandBlock+4
.a5b6	b5 60		lda $60,x			lda 	NSMantissa1,x
.a5b8	8d bf 05	sta $05bf			sta 	SoundCommandBlock+5
.a5bb					_SNDPlay:
.a5bb	5a		phy				phy
.a5bc	a5 58		lda $58				lda 	NSMantissa0 				; channel.
.a5be	09 10		ora #$10			ora 	#$10 						; 1x = Queue sound
.a5c0	a2 ba		ldx #$ba			ldx 	#(SoundCommandBlock & $FF)
.a5c2	a0 05		ldy #$05			ldy 	#(SoundCommandBlock >> 8)
.a5c4	20 09 b9	jsr $b909			jsr 	SNDCommand
.a5c7	7a		ply				ply
.a5c8	60		rts				rts
.a5c9					_SndError:
.a5c9	4c 2e 9f	jmp $9f2e			jmp 	RangeError
.05ba					SoundCommandBlock:
>05ba							.fill 	6

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/bytes.asm

.a5cc					StackPushByte:
.a5cc	48		pha				pha 								; save byte
.a5cd	a5 34		lda $34				lda 	BasicStack
.a5cf	d0 09		bne $a5da			bne 	_SPBNoBorrow
.a5d1	c6 35		dec $35				dec 	BasicStack+1
.a5d3	48		pha				pha
.a5d4	a5 35		lda $35				lda 	BasicStack+1
.a5d6	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a5d8	90 06		bcc $a5e0			bcc 	_SPBMemory
.a5da					_SPBNoBorrow:
.a5da	c6 34		dec $34				dec 	BasicStack
.a5dc	68		pla				pla 								; get back and write
.a5dd	92 34		sta ($34)			sta 	(BasicStack)
.a5df	60		rts				rts
.a5e0					_SPBMemory:
.a5e0	a9 12		lda #$12		lda	#18
.a5e2	4c a4 8e	jmp $8ea4		jmp	ErrorHandler
.a5e5					StackPopByte:
.a5e5	b2 34		lda ($34)			lda 	(BasicStack)
.a5e7	e6 34		inc $34				inc 	BasicStack
.a5e9	d0 02		bne $a5ed			bne 	_SPBNoCarry
.a5eb	e6 35		inc $35				inc 	BasicStack+1
.a5ed					_SPBNoCarry:
.a5ed	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/frames.asm

.a5ee					StackOpen:
.a5ee	48		pha				pha 								; save frame byte
.a5ef	29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.a5f1	0a		asl a				asl 	a 							; claim twice this for storage
.a5f2	49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.a5f4	38		sec				sec 								; so basically subtracting from
.a5f5	65 34		adc $34				adc 	basicStack 	 				; basicStack
.a5f7	85 34		sta $34				sta 	basicStack
.a5f9	b0 08		bcs $a603			bcs 	_SONoBorrow
.a5fb	c6 35		dec $35				dec 	basicStack+1
.a5fd	a5 35		lda $35				lda 	basicStack+1 				; have we reached stack overflow
.a5ff	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a601	90 04		bcc $a607			bcc 	_SOMemory
.a603					_SONoBorrow:
.a603	68		pla				pla 								; get marker back and write at TOS
.a604	92 34		sta ($34)			sta 	(basicStack)
.a606	60		rts				rts
.a607					_SOMemory:
.a607	a9 12		lda #$12		lda	#18
.a609	4c a4 8e	jmp $8ea4		jmp	ErrorHandler
.a60c					StackClose:
.a60c	b2 34		lda ($34)			lda 	(basicStack) 				; get TOS marker
.a60e	29 0f		and #$0f			and 	#$0F 						; bytes to add back
.a610	0a		asl a				asl 	a 							; claim twice this.
.a611	65 34		adc $34				adc 	basicStack 					; add to the stack pointer.
.a613	85 34		sta $34				sta 	basicStack
.a615	90 02		bcc $a619			bcc 	_SCExit
.a617	e6 35		inc $35				inc 	basicStack+1
.a619					_SCExit:
.a619	60		rts				rts
.a61a					StackCheckFrame:
.a61a	48		pha				pha
.a61b					_StackRemoveLocals:
.a61b	b2 34		lda ($34)			lda 	(basicStack) 				; check for local, keep popping them
.a61d	c9 03		cmp #$03			cmp 	#STK_LOCALS+1
.a61f	b0 05		bcs $a626			bcs 	_SCNoLocal
.a621	20 42 89	jsr $8942			jsr 	LocalPopValue
.a624	80 f5		bra $a61b			bra 	_StackRemoveLocals
.a626					_SCNoLocal:
.a626	68		pla				pla
.a627	52 34		eor ($34)			eor 	(basicStack) 				; xor with toS marker
.a629	29 f0		and #$f0			and 	#$F0 						; check type bits
.a62b	d0 01		bne $a62e			bne 	_SCFError 					; different, we have structures mixed up
.a62d	60		rts				rts
.a62e					_SCFError:
.a62e	8a		txa				txa 								; report error X
.a62f	4c a4 8e	jmp $8ea4			jmp 	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/location.asm

.a632					STKSaveCodePosition:
.a632	5a		phy				phy
.a633	98		tya				tya 								; save Y
.a634	a0 05		ldy #$05			ldy 	#5
.a636	91 34		sta ($34),y			sta 	(basicStack),y
.a638	88		dey				dey 								; save Code Pointer
.a639					_STKSaveLoop:
.a639	b9 2f 00	lda $002f,y			lda 	safePtr-1,y 				; allows us to access the pointer w/out issues.
.a63c	91 34		sta ($34),y			sta 	(basicStack),y
.a63e	88		dey				dey
.a63f	d0 f8		bne $a639			bne 	_STKSaveLoop
.a641	7a		ply				ply
.a642	60		rts				rts
.a643					STKLoadCodePosition:
.a643	a0 01		ldy #$01			ldy 	#1 							; load code pointer back
.a645					_STKLoadLoop:
.a645	b1 34		lda ($34),y			lda 	(basicStack),y
.a647	99 2f 00	sta $002f,y			sta 	safePtr-1,y
.a64a	c8		iny				iny
.a64b	c0 05		cpy #$05			cpy 	#5
.a64d	d0 f6		bne $a645			bne 	_STKLoadLoop
.a64f	b1 34		lda ($34),y			lda 	(basicStack),y 				; get Y offset
.a651	a8		tay				tay
.a652	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/setup.asm

.a653					StackReset:
.a653	a9 ff		lda #$ff			lda 	#((BasicStackBase+BasicStackSize-1) & $FF)
.a655	85 34		sta $34				sta 	0+basicStack
.a657	a9 0f		lda #$0f			lda 	#((BasicStackBase+BasicStackSize-1) >> 8)
.a659	85 35		sta $35				sta 	1+basicStack
.a65b	a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.a65d	92 34		sta ($34)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.a65f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/concrete.asm

.a660					StringConcrete:
.a660	5a		phy				phy 								; save position on stack
.a661	20 d9 99	jsr $99d9			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a664	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy target string to zTemp1
.a666	85 38		sta $38				sta 	zTemp1
.a668	b5 60		lda $60,x			lda 	NSMantissa1,x
.a66a	85 39		sta $39				sta 	zTemp1+1
.a66c	a0 ff		ldy #$ff			ldy 	#$FF	 					; calculate string length
.a66e					_SALength:
.a66e	c8		iny				iny
.a66f	b1 38		lda ($38),y			lda 	(zTemp1),y
.a671	d0 fb		bne $a66e			bne 	_SALength
.a673	c0 fd		cpy #$fd			cpy 	#253 						; string too long
.a675	b0 3d		bcs $a6b4			bcs 	_SALengthError
.a677	98		tya				tya 				 				; length of the new string
.a678	18		clc				clc
.a679	69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.a67b	90 02		bcc $a67f			bcc 	_SAHaveLength
.a67d	a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.a67f					_SAHaveLength:
.a67f	48		pha				pha 								; save length.
.a680	38		sec				sec
.a681	49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.a683	6d 0e 04	adc $040e			adc 	StringMemory
.a686	8d 0e 04	sta $040e			sta 	StringMemory
.a689	85 3a		sta $3a				sta 	zTemp2 						; update storage address
.a68b	95 58		sta $58,x			sta 	NSMantissa0,x 				; update mantissa address
.a68d	a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.a68f	6d 0f 04	adc $040f			adc 	StringMemory+1
.a692	8d 0f 04	sta $040f			sta 	StringMemory+1
.a695	85 3b		sta $3b				sta 	zTemp2+1
.a697	95 60		sta $60,x			sta 	NSMantissa1,x
.a699	68		pla				pla 								; save length-3 (chars allowed) in first byte
.a69a	38		sec				sec
.a69b	e9 03		sbc #$03			sbc 	#3
.a69d	92 3a		sta ($3a)			sta 	(zTemp2)
.a69f	a9 00		lda #$00			lda 	#0 							; clear the status byte.
.a6a1	a0 01		ldy #$01			ldy 	#1
.a6a3	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a6a5					_SACopyNewString:
.a6a5	a0 00		ldy #$00			ldy 	#0
.a6a7					_SACopyNSLoop:
.a6a7	b1 38		lda ($38),y			lda 	(zTemp1),y 					; get character
.a6a9	c8		iny				iny 								; write two on in string storage
.a6aa	c8		iny				iny
.a6ab	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a6ad	88		dey				dey 								; this makes it one one.
.a6ae	c9 00		cmp #$00			cmp 	#0 							; until EOS copied
.a6b0	d0 f5		bne $a6a7			bne 	_SACopyNSLoop
.a6b2	7a		ply				ply
.a6b3	60		rts				rts
.a6b4					_SALengthError:
.a6b4	a9 09		lda #$09		lda	#9
.a6b6	4c a4 8e	jmp $8ea4		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/stringalloc.asm

.a6b9					StringSystemInitialise:
.a6b9	a9 ff		lda #$ff			lda 	#((EndVariableSpace-1) & $FF)
.a6bb	8d 0e 04	sta $040e			sta 	0+StringMemory
.a6be	a9 1f		lda #$1f			lda 	#((EndVariableSpace-1) >> 8)
.a6c0	8d 0f 04	sta $040f			sta 	1+StringMemory
.a6c3	9c ff 1f	stz $1fff			stz 	EndVariableSpace-1 			; put a zero at the end, so know end of string memory.
.a6c6	60		rts				rts
.a6c7					StringSpaceInitialise:
.a6c7	20 d9 99	jsr $99d9			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a6ca	a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.a6cc	8d 10 04	sta $0410			sta 	StringInitialised
.a6cf	ad 0e 04	lda $040e			lda 	StringMemory 				; allocate 256 bytes for one concreted string
.a6d2	8d 11 04	sta $0411			sta 	StringTempPointer
.a6d5	ad 0f 04	lda $040f			lda 	StringMemory+1
.a6d8	3a		dec a				dec 	a
.a6d9	8d 12 04	sta $0412			sta 	StringTempPointer+1
.a6dc	60		rts				rts
.a6dd					StringTempAllocate:
.a6dd	c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.a6df	b0 30		bcs $a711			bcs 	_STALength
.a6e1	2c 10 04	bit $0410			bit 	StringInitialised 			; already initialised
.a6e4	30 05		bmi $a6eb			bmi 	_STAAllocate
.a6e6	48		pha				pha 								; save value to subtract.
.a6e7	20 c7 a6	jsr $a6c7			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.a6ea	68		pla				pla 								; restore it
.a6eb					_STAAllocate:
.a6eb	49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.a6ed	18		clc				clc  								; deliberate allows one more
.a6ee	6d 11 04	adc $0411			adc 	StringTempPointer 			; subtract from temp pointer
.a6f1	8d 11 04	sta $0411			sta 	StringTempPointer
.a6f4	95 58		sta $58,x			sta 	NSMantissa0,x 				; address in mantissa
.a6f6	85 3c		sta $3c				sta 	zsTemp 						; and zsTemp
.a6f8	ad 12 04	lda $0412			lda 	StringTempPointer+1
.a6fb	69 ff		adc #$ff			adc 	#$FF
.a6fd	8d 12 04	sta $0412			sta 	StringTempPointer+1
.a700	85 3d		sta $3d				sta 	zsTemp+1
.a702	95 60		sta $60,x			sta 	NSMantissa1,x
.a704	74 68		stz $68,x			stz 	NSMantissa2,x 				; set the typing data
.a706	74 70		stz $70,x			stz 	NSMantissa3,x
.a708	a9 10		lda #$10			lda 	#NSTString
.a70a	95 50		sta $50,x			sta 	NSStatus,x
.a70c	a9 00		lda #$00			lda 	#0 							; clear the target string
.a70e	92 3c		sta ($3c)			sta 	(zsTemp)
.a710	60		rts				rts
.a711					_STALength:
.a711	a9 09		lda #$09		lda	#9
.a713	4c a4 8e	jmp $8ea4		jmp	ErrorHandler
.a716					StringTempWrite:
.a716	48		pha				pha
.a717	92 3c		sta ($3c)			sta 	(zsTemp)
.a719	e6 3c		inc $3c				inc 	zsTemp
.a71b	d0 02		bne $a71f			bne 	_STWNoCarry
.a71d	e6 3d		inc $3d				inc 	zsTemp+1
.a71f					_STWNoCarry:
.a71f	a9 00		lda #$00			lda 	#0
.a721	92 3c		sta ($3c)			sta 	(zsTemp)
.a723	68		pla				pla
.a724	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_hardware.module

=1					hardwareIntegrated=1
=0					CONBlack = 0
=1					CONWhite = 1
=2					CONRed = 2
=3					CONCyan = 3
=4					CONPurple = 4
=5					CONGreen = 5
=6					CONBlue = 6
=7					CONYellow = 7
=8					CONOrange = 8
=9					CONBrown = 9
=10					CONYellowGreen = 10
=11					CONRosa = 11
=12					CONBlueGreen = 12
=13					CONLightBlue = 13
=14					CONPink = 14
=15					CONLightGreen = 15
=7					CONForeground = CONYellow
=6					CONBackground = CONBlue
=5					CLICommandLine = CONGreen
=0					CLIFComment = CONBlack
=7					CLIBComment = CONYellow
=9					CLINumber = CONBrown
=3					CLIToken = CONCyan
=13					CLIConstant = CONLightBlue
=7					CLIIdentifier = CONYellow
=10					CLIPunctuation = CONYellowGreen
=1					CLIData = CONWhite
.a725					EXTPrintCharacter:
.a725	48		pha				pha
.a726	da		phx				phx
.a727	5a		phy				phy
.a728	a6 01		ldx $01				ldx 	1
.a72a	da		phx				phx
.a72b	ac c1 05	ldy $05c1			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.a72e	09 00		ora #$00			ora 	#$00 						; check $80-$FF
.a730	30 48		bmi $a77a			bmi 	_EXPCColour
.a732	c9 20		cmp #$20			cmp 	#$20 						; check $00-$1F
.a734	90 4d		bcc $a783			bcc 	_EXPCControl
.a736	a2 02		ldx #$02			ldx 	#2 							; select char memory
.a738	86 01		stx $01				stx 	1
.a73a	91 40		sta ($40),y			sta 	(EXTAddress),y
.a73c	e6 01		inc $01				inc 	1 							; select colour memory
.a73e	ad c2 05	lda $05c2			lda 	EXTTextColour
.a741	91 40		sta ($40),y			sta 	(EXTAddress),y
.a743	c8		iny				iny 								; advance horizontal position
.a744	8c c1 05	sty $05c1			sty 	EXTColumn
.a747	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth 				; reached RHS ?
.a74a	90 66		bcc $a7b2			bcc 	_EXPCExit 					; no, then exit.
.a74c					_EXPCCRLF:
.a74c	ee c0 05	inc $05c0			inc 	EXTRow  					; bump row
.a74f	9c c1 05	stz $05c1			stz 	EXTColumn 					; back to column 0
.a752	ad c0 05	lda $05c0			lda 	EXTRow 						; check if reached the bottom ?
.a755	cd c4 05	cmp $05c4			cmp 	EXTScreenHeight 			; if so, then scroll.
.a758	f0 18		beq $a772			beq 	_EXPCScroll
.a75a	18		clc				clc 								; add width to address.
.a75b	a5 40		lda $40				lda 	EXTAddress
.a75d	6d c3 05	adc $05c3			adc 	EXTScreenWidth
.a760	85 40		sta $40				sta 	EXTAddress
.a762	90 4e		bcc $a7b2			bcc 	_EXPCExit
.a764	e6 41		inc $41				inc 	EXTAddress+1
.a766	80 4a		bra $a7b2			bra 	_EXPCExit
.a768					_EXPCLeft:
.a768	ce c1 05	dec $05c1			dec 	EXTColumn
.a76b	10 45		bpl $a7b2			bpl 	_EXPCExit
.a76d					_EXPCBegin:
.a76d	9c c1 05	stz $05c1			stz 	EXTColumn
.a770	80 40		bra $a7b2			bra 	_EXPCExit
.a772					_EXPCScroll:
.a772	ce c0 05	dec $05c0			dec 	EXTRow 						; the height-1 th line.
.a775	20 3f a8	jsr $a83f			jsr 	EXTScreenScroll 			; scroll the screen
.a778	80 38		bra $a7b2			bra 	_EXPCExit
.a77a					_EXPCColour:
.a77a	c9 a0		cmp #$a0			cmp 	#$A0						; 80-9F set foreground/background
.a77c	b0 34		bcs $a7b2			bcs 	_EXPCExit
.a77e	20 1f a8	jsr $a81f			jsr 	_EXPCHandleColour
.a781	80 2f		bra $a7b2			bra 	_EXPCExit
.a783					_EXPCControl:
.a783	c9 11		cmp #$11			cmp 	#$11 						; only handle 00-10.
.a785	b0 2b		bcs $a7b2			bcs 	_EXPCExit
.a787	0a		asl a				asl 	a 							; double into X
.a788	aa		tax				tax
.a789	7c fd a7	jmp ($a7fd,x)			jmp 	(_EXPCActionTable,x) 		; and execute code.
.a78c					_EXPCUp:
.a78c	ad c0 05	lda $05c0			lda 	EXTRow 						; already at top ?
.a78f	f0 21		beq $a7b2			beq 	_EXPCExit
.a791	ce c0 05	dec $05c0			dec 	EXTRow 						; up one in position/address
.a794	38		sec				sec
.a795	a5 40		lda $40				lda 	EXTAddress
.a797	ed c3 05	sbc $05c3			sbc 	EXTScreenWidth
.a79a	85 40		sta $40				sta 	EXTAddress
.a79c	b0 14		bcs $a7b2			bcs 	_EXPCExit
.a79e	c6 41		dec $41				dec 	EXTAddress+1
.a7a0	80 10		bra $a7b2			bra 	_EXPCExit
.a7a2					_EXPCRight:
.a7a2	c8		iny				iny
.a7a3	8c c1 05	sty $05c1			sty 	EXTColumn
.a7a6	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth
.a7a9	d0 07		bne $a7b2			bne 	_EXPCExit
.a7ab					_EXPCEnd:
.a7ab	ad c3 05	lda $05c3			lda 	EXTScreenWidth
.a7ae	3a		dec a				dec 	a
.a7af	8d c1 05	sta $05c1			sta 	EXTColumn
.a7b2					_EXPCExit:
.a7b2	20 94 a8	jsr $a894			jsr 	EXTSetHardwareCursor 		; place the physical cursor.
.a7b5	68		pla				pla
.a7b6	85 01		sta $01				sta 	1
.a7b8	7a		ply				ply
.a7b9	fa		plx				plx
.a7ba	68		pla				pla
.a7bb	60		rts				rts
.a7bc					_EXPCClearScreen:
.a7bc	20 51 a8	jsr $a851			jsr		EXTClearScreenCode
.a7bf	80 f1		bra $a7b2			bra 	_EXPCExit
.a7c1					_EXPCDown:
.a7c1	ad c4 05	lda $05c4			lda 	EXTScreenHeight 			; at the bottom
.a7c4	3a		dec a				dec 	a
.a7c5	cd c0 05	cmp $05c0			cmp 	EXTRow
.a7c8	f0 e8		beq $a7b2			beq 	_EXPCExit
.a7ca	ee c0 05	inc $05c0			inc 	EXTRow 						; down one in position/address
.a7cd	18		clc				clc
.a7ce	a5 40		lda $40				lda 	EXTAddress
.a7d0	6d c3 05	adc $05c3			adc 	EXTScreenWidth
.a7d3	85 40		sta $40				sta 	EXTAddress
.a7d5	90 db		bcc $a7b2			bcc 	_EXPCExit
.a7d7	e6 41		inc $41				inc 	EXTAddress+1
.a7d9	80 d7		bra $a7b2			bra 	_EXPCExit
.a7db					_EXPCTab:
.a7db	ad c1 05	lda $05c1			lda 	EXTColumn 					; next tab stop
.a7de	29 f8		and #$f8			and 	#$F8
.a7e0	18		clc				clc
.a7e1	69 08		adc #$08			adc 	#8
.a7e3	8d c1 05	sta $05c1			sta 	EXTColumn
.a7e6	cd c3 05	cmp $05c3			cmp 	EXTScreenWidth 				; too far, stick end of line.
.a7e9	90 c7		bcc $a7b2			bcc 	_EXPCExit
.a7eb	80 be		bra $a7ab			bra 	_EXPCEnd
.a7ed					_EXPCBackSpace:
.a7ed	88		dey				dey
.a7ee	30 c2		bmi $a7b2			bmi 	_EXPCExit
.a7f0	ce c1 05	dec $05c1			dec 	EXTColumn
.a7f3	a9 02		lda #$02			lda 	#2
.a7f5	85 01		sta $01				sta 	1
.a7f7	a9 20		lda #$20			lda 	#32
.a7f9	91 40		sta ($40),y			sta 	(EXTAddress),y
.a7fb	80 b5		bra $a7b2			bra 	_EXPCExit
.a7fd					_EXPCActionTable:
>a7fd	b2 a7						.word 	_EXPCExit 					; 00
>a7ff	6d a7						.word 	_EXPCBegin 					; 01 A Start of Line
>a801	68 a7						.word 	_EXPCLeft 					; 02 B Left
>a803	b2 a7						.word 	_EXPCExit 					; 03 <Break>
>a805	b2 a7						.word 	_EXPCExit 					; 04
>a807	ab a7						.word 	_EXPCEnd 					; 05 E End of Line
>a809	a2 a7						.word 	_EXPCRight 					; 06 F Right
>a80b	b2 a7						.word 	_EXPCExit 					; 07
>a80d	ed a7						.word 	_EXPCBackspace 				; 08 H Backspace
>a80f	db a7						.word 	_EXPCTab 					; 09 I Tab
>a811	b2 a7						.word 	_EXPCExit 					; 0A
>a813	b2 a7						.word 	_EXPCExit 					; 0B
>a815	bc a7						.word 	_EXPCClearScreen			; 0C L CLS
>a817	4c a7						.word 	_EXPCCRLF 					; 0D M CR/LF
>a819	c1 a7						.word 	_EXPCDown 					; 0E N Down
>a81b	b2 a7						.word 	_EXPCExit 					; 0F
>a81d	8c a7						.word 	_EXPCUp 					; 10 P Up
.a81f					_EXPCHandleColour
.a81f	c9 90		cmp #$90			cmp 	#$90 						; 8x foreground 9x background
.a821	b0 16		bcs $a839			bcs 	_EXPCBackground
.a823	0a		asl a				asl 	a 							; shift it 4 bits to the right.
.a824	0a		asl a				asl 	a
.a825	0a		asl a				asl 	a
.a826	0a		asl a				asl 	a
.a827	a2 0f		ldx #$0f			ldx 	#$0F 						; Mask in X
.a829					_EXPCUpdate:
.a829	48		pha				pha 								; save new colour
.a82a	8a		txa				txa 								; get mask
.a82b	2d c2 05	and $05c2			and 	EXTTextColour 				; mask out old.
.a82e	8d c2 05	sta $05c2			sta 	EXTTextColour
.a831	68		pla				pla 								; or in new colour
.a832	0d c2 05	ora $05c2			ora 	EXTTextColour
.a835	8d c2 05	sta $05c2			sta 	EXTTextColour
.a838	60		rts				rts
.a839					_EXPCBackground:
.a839	29 0f		and #$0f			and 	#$0F 						; get the colour
.a83b	a2 f0		ldx #$f0			ldx 	#$F0 						; mask
.a83d	80 ea		bra $a829			bra 	_EXPCUpdate
.a83f					EXTScreenScroll:
.a83f	a9 02		lda #$02			lda 	#2 							; select text page
.a841	85 01		sta $01				sta 	1
.a843	a9 20		lda #$20			lda		#32 						; fill with space
.a845	20 54 a9	jsr $a954			jsr 	EXTScrollFill
.a848	e6 01		inc $01				inc 	1 							; select colour page
.a84a	ad c2 05	lda $05c2			lda 	EXTTextColour
.a84d	20 54 a9	jsr $a954			jsr 	EXTScrollFill
.a850	60		rts				rts
.a851					EXTClearScreenCode:
.a851	a9 02		lda #$02			lda 	#2 							; select text page
.a853	85 01		sta $01				sta 	1
.a855	a9 20		lda #$20			lda		#32 						; fill with space
.a857	20 64 a8	jsr $a864			jsr 	_EXTCSFill
.a85a	e6 01		inc $01				inc 	1 							; select colour page
.a85c	ad c2 05	lda $05c2			lda 	EXTTextColour
.a85f	20 64 a8	jsr $a864			jsr 	_EXTCSFill
.a862	80 22		bra $a886			bra 	EXTHomeCursor
.a864					_EXTCSFill:
.a864	aa		tax				tax
.a865	a9 00		lda #$00			lda 	#EXTMemory & $FF
.a867	85 40		sta $40				sta 	EXTAddress
.a869	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a86b	85 41		sta $41				sta 	EXTAddress+1
.a86d					_EXTCSFill1:
.a86d	a0 00		ldy #$00			ldy 	#0
.a86f	8a		txa				txa
.a870					_EXTCSFill2:
.a870	91 40		sta ($40),y			sta 	(EXTAddress),y
.a872	c8		iny				iny
.a873	d0 fb		bne $a870			bne 	_EXTCSFill2
.a875	e6 41		inc $41				inc 	EXTAddress+1
.a877	a5 41		lda $41				lda 	EXTAddress+1
.a879	c9 d2		cmp #$d2			cmp 	#$D2
.a87b	d0 f0		bne $a86d			bne 	_EXTCSFill1
.a87d	8a		txa				txa
.a87e					_EXTCSFill3:
.a87e	91 40		sta ($40),y			sta 	(EXTAddress),y
.a880	c8		iny				iny
.a881	c0 c0		cpy #$c0			cpy 	#$C0
.a883	d0 f9		bne $a87e			bne 	_EXTCSFill3
.a885	60		rts				rts
.a886					EXTHomeCursor:
.a886	9c c0 05	stz $05c0			stz 	EXTRow 						; reset row & column
.a889	9c c1 05	stz $05c1			stz 	EXTColumn
.a88c	a9 00		lda #$00			lda 	#EXTMemory & $FF 			; set address
.a88e	85 40		sta $40				sta 	EXTAddress
.a890	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a892	85 41		sta $41				sta 	EXTAddress+1
.a894					EXTSetHardwareCursor:
.a894	64 01		stz $01				stz 	1 							; I/O Page zero
.a896	a9 05		lda #$05			lda 	#1+4 						; enable cursor
.a898	8d 10 d0	sta $d010			sta 	$D010
.a89b	a9 b1		lda #$b1			lda 	#$B1
.a89d	8d 12 d0	sta $d012			sta 	$D012
.a8a0	ad c1 05	lda $05c1			lda 	EXTColumn
.a8a3	8d 14 d0	sta $d014			sta 	$D014 						; set cursor position
.a8a6	9c 15 d0	stz $d015			stz 	$D015
.a8a9	ad c0 05	lda $05c0			lda 	EXTRow
.a8ac	8d 16 d0	sta $d016			sta 	$D016
.a8af	9c 17 d0	stz $d017			stz 	$D017
.a8b2	60		rts				rts
.a8b3					EXTInputLine:
.a8b3	48		pha				pha
.a8b4	da		phx				phx
.a8b5	5a		phy				phy
.a8b6	a5 01		lda $01				lda 	1 							; save I/O page
.a8b8	48		pha				pha
.a8b9					_EILLoop:
.a8b9	20 bb a9	jsr $a9bb			jsr 	ExtInputSingleCharacter
.a8bc	c9 0d		cmp #$0d			cmp 	#13 						; scrape line if exit.
.a8be	f0 40		beq $a900			beq 	_EILExit
.a8c0	c9 08		cmp #$08			cmp 	#8 							; handle backspace
.a8c2	f0 1c		beq $a8e0			beq 	_EILBackspace
.a8c4	c9 20		cmp #$20			cmp 	#' '						; < space, print it
.a8c6	90 12		bcc $a8da			bcc 	_EILPrintLoop
.a8c8	c9 7f		cmp #$7f			cmp 	#$7F 						; if -ve print it
.a8ca	b0 0e		bcs $a8da			bcs 	_EILPrintLoop
.a8cc	48		pha				pha 								; save character
.a8cd	a9 02		lda #$02			lda 	#2  						; insert a space
.a8cf	85 01		sta $01				sta 	1
.a8d1	20 42 a9	jsr $a942			jsr 	EXTILInsert 				; insert in text screen
.a8d4	e6 01		inc $01				inc 	1
.a8d6	20 42 a9	jsr $a942			jsr 	EXTILInsert 				; insert in colour screen
.a8d9	68		pla				pla 								; get character back.
.a8da					_EILPrintLoop:
.a8da	20 25 a7	jsr $a725			jsr 	ExtPrintCharacter
.a8dd	80 da		bra $a8b9			bra 	_EILLoop
.a8df	60		rts				rts
.a8e0					_EILBackspace:
.a8e0	ad c1 05	lda $05c1			lda 	EXTColumn					; can we backspace ?
.a8e3	f0 d4		beq $a8b9			beq 	_EILLoop
.a8e5	a9 02		lda #$02			lda 	#2 							; move cursor left
.a8e7	20 25 a7	jsr $a725			jsr 	EXTPrintCharacter
.a8ea	a9 02		lda #$02			lda 	#2 							; text block
.a8ec	85 01		sta $01				sta 	1
.a8ee	a9 20		lda #$20			lda 	#' ' 						; backspace text.
.a8f0	20 2d a9	jsr $a92d			jsr 	EXTILDelete
.a8f3	e6 01		inc $01				inc 	1 							; colour block
.a8f5	ac c1 05	ldy $05c1			ldy 	EXTColumn 					; get attribute of last character
.a8f8	88		dey				dey
.a8f9	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a8fb	20 2d a9	jsr $a92d			jsr 	EXTILDelete 				; backspace attribute
.a8fe	80 b9		bra $a8b9			bra 	_EILLoop 					; and go round.
.a900					_EILExit:
.a900	a9 02		lda #$02			lda 	#2 							; switch to page 2
.a902	85 01		sta $01				sta 	1
.a904	a0 00		ldy #$00			ldy 	#0 							; copy current line into buffer.
.a906					_EILScrapeLine:
.a906	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a908	99 2a 05	sta $052a,y			sta 	lineBuffer,y
.a90b	c8		iny				iny
.a90c	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth
.a90f	d0 f5		bne $a906			bne 	_EILScrapeLine
.a911					_EILTrimSpaces:
.a911	88		dey				dey
.a912	f0 08		beq $a91c			beq 	_EILEndTrim
.a914	b9 2a 05	lda $052a,y			lda 	lineBuffer,y
.a917	c9 20		cmp #$20			cmp 	#' '
.a919	f0 f6		beq $a911			beq 	_EILTrimSpaces
.a91b	c8		iny				iny 								; trim after non space character.
.a91c					_EILEndTrim:
.a91c	a9 00		lda #$00			lda 	#0 							; trim here.
.a91e	99 2a 05	sta $052a,y			sta 	lineBuffer,y
.a921	a9 0d		lda #$0d			lda 	#13 						; echo the RETURN
.a923	20 25 a7	jsr $a725			jsr 	ExtPrintCharacter
.a926	68		pla				pla 								; reset I/O page
.a927	85 01		sta $01				sta 	1
.a929	7a		ply				ply
.a92a	fa		plx				plx
.a92b	68		pla				pla
.a92c	60		rts				rts
.a92d					EXTILDelete:
.a92d	48		pha				pha 								; save the new character
.a92e	ac c1 05	ldy $05c1			ldy 	EXTColumn 					; start copying from here.
.a931					_EXTDLoop:
.a931	c8		iny				iny 								; copy one byte down.
.a932	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a934	88		dey				dey
.a935	91 40		sta ($40),y			sta 	(EXTAddress),y
.a937	c8		iny				iny 								; do till end of line.
.a938	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth
.a93b	90 f4		bcc $a931			bcc 	_EXTDLoop
.a93d	88		dey				dey 	 							; write in last slot.
.a93e	68		pla				pla
.a93f	91 40		sta ($40),y			sta 	(EXTAddress),y
.a941	60		rts				rts
.a942					EXTILInsert:
.a942	ac c3 05	ldy $05c3			ldy 	EXTScreenWidth 				; end position
.a945					_EXTILoop:
.a945	88		dey				dey 								; back one
.a946	cc c1 05	cpy $05c1			cpy 	EXTColumn 					; exit if reached insert point.
.a949	f0 08		beq $a953			beq 	_EXTIExit
.a94b	88		dey				dey 								; copy one byte up.
.a94c	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a94e	c8		iny				iny
.a94f	91 40		sta ($40),y			sta 	(EXTAddress),y
.a951	80 f2		bra $a945			bra 	_EXTILoop
.a953					_EXTIExit:
.a953	60		rts				rts
.a954					EXTScrollFill:
.a954	aa		tax				tax									; save value to fill with
.a955	a5 36		lda $36				lda 	zTemp0 						; save zTemp0 (dest) zTemp1 (src)
.a957	48		pha				pha
.a958	a5 37		lda $37				lda 	zTemp0+1
.a95a	48		pha				pha
.a95b	a5 38		lda $38				lda 	zTemp1
.a95d	48		pha				pha
.a95e	a5 39		lda $39				lda 	zTemp1+1
.a960	48		pha				pha
.a961	a9 c0		lda #$c0			lda 	#$C0 						; copy from C000+length to C000
.a963	85 37		sta $37				sta 	zTemp0+1
.a965	85 39		sta $39				sta 	zTemp1+1
.a967	64 36		stz $36				stz 	zTemp0
.a969	ad c3 05	lda $05c3			lda 	EXTScreenWidth
.a96c	85 38		sta $38				sta 	zTemp1
.a96e	a0 00		ldy #$00			ldy 	#0
.a970					_EXSFCopy1:
.a970	b1 38		lda ($38),y			lda 	(zTemp1),y
.a972	91 36		sta ($36),y			sta 	(zTemp0),y
.a974	c8		iny				iny
.a975	d0 f9		bne $a970			bne 	_EXSFCopy1
.a977	e6 37		inc $37				inc 	zTemp0+1 					; next page
.a979	e6 39		inc $39				inc 	zTemp1+1
.a97b	a5 39		lda $39				lda 	zTemp1+1
.a97d	c9 d3		cmp #$d3			cmp 	#$D3
.a97f	d0 ef		bne $a970			bne 	_EXSFCopy1
.a981	ac c3 05	ldy $05c3			ldy 	EXTScreenWidth 				; blank the bottom line.
.a984	8a		txa				txa
.a985					_EXSFFill1:
.a985	88		dey				dey
.a986	91 40		sta ($40),y			sta 	(EXTAddress),y
.a988	c0 00		cpy #$00			cpy 	#0
.a98a	10 f9		bpl $a985			bpl 	_EXSFFill1
.a98c	68		pla				pla
.a98d	85 39		sta $39				sta 	zTemp1+1
.a98f	68		pla				pla
.a990	85 38		sta $38				sta 	zTemp1
.a992	68		pla				pla
.a993	85 37		sta $37				sta 	zTemp0+1
.a995	68		pla				pla
.a996	85 36		sta $36				sta 	zTemp0
.a998	60		rts				rts
=$c000					EXTMemory = $C000
=$02					EXTTextPage = $02
=$03					EXTColourPage = $03
=1					EXTDummySpace = 1 							; fake-space for CR character.
=0					EXTCBlack = 0
.05c0					EXTRow:
>05c0							.fill 	1
.05c1					EXTColumn:
>05c1							.fill 	1
.05c2					EXTTextColour:
>05c2							.fill 	1
.05c3					EXTScreenWidth:
>05c3							.fill 	1
.05c4					EXTScreenHeight:
>05c4							.fill 	1
.0040					EXTAddress:
>0040							.fill 	2
.a999					EXTInitialise:
.a999	64 01		stz $01				stz 	1 							; Access I/O
.a99b	9c 04 d0	stz $d004			stz 	$D004 						; Disable border
.a99e	9c 08 d0	stz $d008			stz 	$D008
.a9a1	9c 09 d0	stz $d009			stz 	$D009
.a9a4	a9 09		lda #$09			lda 	#1+8						; Timer On at 70Hz counting up.
.a9a6	8d 58 d6	sta $d658			sta 	$D658
.a9a9	a9 76		lda #$76			lda 	#CONForeground * 16 + CONBackground
.a9ab	8d c2 05	sta $05c2			sta 	EXTTextColour
.a9ae	a9 50		lda #$50			lda 	#80 						; set screen dimensions.
.a9b0	8d c3 05	sta $05c3			sta 	EXTScreenWidth
.a9b3	a9 3c		lda #$3c			lda 	#60
.a9b5	8d c4 05	sta $05c4			sta 	EXTScreenHeight
.a9b8	64 01		stz $01				stz 	1
.a9ba	60		rts				rts
.a9bb					EXTInputSingleCharacter:
.a9bb	da		phx				phx
.a9bc	5a		phy				phy
.a9bd					_EISCWait:
.a9bd	64 01		stz $01				stz 	1 							; access I/O Page 0
.a9bf	38		sec				sec 								; calculate timer - LastTick
.a9c0	ad 59 d6	lda $d659			lda 	$D659
.a9c3	aa		tax				tax 								; saving timer in X
.a9c4	ed af 05	sbc $05af			sbc 	LastTick
.a9c7	c9 03		cmp #$03			cmp 	#3
.a9c9	90 06		bcc $a9d1			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.a9cb	8e af 05	stx $05af			stx 	LastTick 					; update last timer
.a9ce	20 96 b9	jsr $b996			jsr 	TickHandler 				; go do the code.
.a9d1					_NoFireTick:
.a9d1	20 e4 ff	jsr $ffe4			jsr 	$FFE4
.a9d4	c9 00		cmp #$00			cmp 	#0
.a9d6	f0 e5		beq $a9bd			beq 	_EISCWait
.a9d8	7a		ply				ply
.a9d9	fa		plx				plx
.a9da	60		rts				rts
.a9db					EXTBreakCheck:
.a9db	4c e1 ff	jmp $ffe1			jmp		$FFE1
.a9de					EXTReadController:
.a9de	da		phx				phx
.a9df	a2 00		ldx #$00			ldx 	#0
.a9e1	a9 05		lda #$05			lda 	#(($2D) >> 3)
.a9e3	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.a9e6	29 20		and #$20			and 	#($01 << (($2D) & 7))
.a9e8	f0 04		beq $a9ee			beq 	_NoSet1
.a9ea	8a		txa				txa
.a9eb	09 01		ora #$01			ora 	#1
.a9ed	aa		tax				tax
.a9ee					_NoSet1:
.a9ee	a9 05		lda #$05			lda 	#(($2C) >> 3)
.a9f0	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.a9f3	29 10		and #$10			and 	#($01 << (($2C) & 7))
.a9f5	f0 04		beq $a9fb			beq 	_NoSet1
.a9f7	8a		txa				txa
.a9f8	09 02		ora #$02			ora 	#2
.a9fa	aa		tax				tax
.a9fb					_NoSet1:
.a9fb	a9 06		lda #$06			lda 	#(($32) >> 3)
.a9fd	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa00	29 04		and #$04			and 	#($01 << (($32) & 7))
.aa02	f0 04		beq $aa08			beq 	_NoSet1
.aa04	8a		txa				txa
.aa05	09 04		ora #$04			ora 	#4
.aa07	aa		tax				tax
.aa08					_NoSet1:
.aa08	a9 04		lda #$04			lda 	#(($25) >> 3)
.aa0a	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa0d	29 20		and #$20			and 	#($01 << (($25) & 7))
.aa0f	f0 04		beq $aa15			beq 	_NoSet1
.aa11	8a		txa				txa
.aa12	09 08		ora #$08			ora 	#8
.aa14	aa		tax				tax
.aa15					_NoSet1:
.aa15	a9 04		lda #$04			lda 	#(($26) >> 3)
.aa17	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa1a	29 40		and #$40			and 	#($01 << (($26) & 7))
.aa1c	f0 04		beq $aa22			beq 	_NoSet1
.aa1e	8a		txa				txa
.aa1f	09 10		ora #$10			ora 	#16
.aa21	aa		tax				tax
.aa22					_NoSet1:
.aa22	8a		txa				txa
.aa23	fa		plx				plx
.aa24	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_graphics.module

=1					graphicsIntegrated=1
=0					GCMD_Initialise = 0*2
=2					GCMD_BitmapCtl = 1*2
=4					GCMD_SpriteCtl = 2*2
=6					GCMD_Clear = 3*2
=8					GCMD_Colour = 4*2
=10					GCMD_DrawFont = 5*2
=12					GCMD_DrawSprite = 6*2
=14					GCMD_SpriteUse = 7*2
=16					GCMD_SpriteImage = 8*2
=18					GCMD_SpriteCollide = 9*2
=64					GCMD_Move = 32*2
=66					GCMD_Line = 33*2
=68					GCMD_FrameRect = 34*2
=70					GCMD_FillRect = 35*2
=72					GCMD_FrameCircle = 36*2
=74					GCMD_FillCircle = 37*2
=80					GCMD_Plot = 40*2
=82					GCMD_SpriteMove = 41*2
=42					GRFirstFreeCode = 42
.b99c					GRVectorTable:
>b99c	20 ac					.word	GXInitialise             ; $00 Initialise
>b99e	3a ac					.word	GXControlBitmap          ; $01 BitmapCtl
>b9a0	82 ac					.word	GXControlSprite          ; $02 SpriteCtl
>b9a2	d2 ab					.word	GXClearBitmap            ; $03 Clear
>b9a4	11 ae					.word	GXSetColourMode          ; $04 Colour
>b9a6	d9 af					.word	GXFontHandler            ; $05 DrawFont
>b9a8	21 b0					.word	GXSpriteHandler          ; $06 DrawSprite
>b9aa	8d b0					.word	GXSelect                 ; $07 SpriteUse
>b9ac	b6 b0					.word	GXSelectImage            ; $08 SpriteImage
>b9ae	3d b2					.word	GXCollide                ; $09 SpriteCollide
>b9b0	84 aa					.word	GRUndefined              ; $0a
>b9b2	84 aa					.word	GRUndefined              ; $0b
>b9b4	84 aa					.word	GRUndefined              ; $0c
>b9b6	84 aa					.word	GRUndefined              ; $0d
>b9b8	84 aa					.word	GRUndefined              ; $0e
>b9ba	84 aa					.word	GRUndefined              ; $0f
>b9bc	84 aa					.word	GRUndefined              ; $10
>b9be	84 aa					.word	GRUndefined              ; $11
>b9c0	84 aa					.word	GRUndefined              ; $12
>b9c2	84 aa					.word	GRUndefined              ; $13
>b9c4	84 aa					.word	GRUndefined              ; $14
>b9c6	84 aa					.word	GRUndefined              ; $15
>b9c8	84 aa					.word	GRUndefined              ; $16
>b9ca	84 aa					.word	GRUndefined              ; $17
>b9cc	84 aa					.word	GRUndefined              ; $18
>b9ce	84 aa					.word	GRUndefined              ; $19
>b9d0	84 aa					.word	GRUndefined              ; $1a
>b9d2	84 aa					.word	GRUndefined              ; $1b
>b9d4	84 aa					.word	GRUndefined              ; $1c
>b9d6	84 aa					.word	GRUndefined              ; $1d
>b9d8	84 aa					.word	GRUndefined              ; $1e
>b9da	84 aa					.word	GRUndefined              ; $1f
>b9dc	82 aa					.word	GXMove                   ; $20 Move
>b9de	df ac					.word	GXLine                   ; $21 Line
>b9e0	5a ae					.word	GXFrameRectangle         ; $22 FrameRect
>b9e2	57 ae					.word	GXFillRectangle          ; $23 FillRect
>b9e4	89 aa					.word	GXFrameCircle            ; $24 FrameCircle
>b9e6	85 aa					.word	GXFillCircle             ; $25 FillCircle
>b9e8	84 aa					.word	GRUndefined              ; $26
>b9ea	84 aa					.word	GRUndefined              ; $27
>b9ec	3f ae					.word	GXPlotPoint              ; $28 Plot
>b9ee	4c b1					.word	GXMoveSprite             ; $29 SpriteMove
=3					GXMappingPage = 3
=24576					GXMappingAddress = ($2000 * GXMappingPage)
=11					GXEditSlot = 8 + GXMappingPage
=$36					gxzTemp0 = zTemp0
=$38					gxzTemp1 = zTemp1
=$3a					gxzTemp2 = zTemp2
=$3c					gxzScreen = zsTemp
=$57b					gxPixelBuffer = numberBuffer
.05c5					gxCurrentX:
>05c5							.fill 	2
.05c7					gxCurrentY:
>05c7							.fill 	2
.05c9					gxLastX:
>05c9							.fill 	2
.05cb					gxLastY:
>05cb							.fill 	2
.05cd					gxX0:
>05cd							.fill 	2
.05cf					gxY0:
>05cf							.fill 	2
.05d1					gxX1:
>05d1							.fill 	2
.05d3					gxY1:
>05d3							.fill 	2
.05d5					gxSpritesOn:
>05d5							.fill 	1
.05d6					gxBitmapsOn:
>05d6							.fill 	1
.05d7					gxBasePage:
>05d7							.fill 	1
.05d8					gxSpritePage:
>05d8							.fill 	1
.05d9					gxHeight:
>05d9							.fill 	1
.05da					gxMode:
>05da							.fill 	1
.05db					gxColour:
>05db							.fill 	1
.05dc					gxEORValue:
>05dc							.fill 	1
.05dd					gxANDValue:
>05dd							.fill 	1
.05de					gxOriginalLUTValue:
>05de							.fill 	1
.05df					gsOffset:
>05df							.fill 	1
.05e0					GSCurrentSpriteID:
>05e0							.fill 	1
.05e1					GSCurrentSpriteAddr:
>05e1							.fill 	2
.05e3					GXSpriteOffsetBase:
>05e3							.fill 	2
.05e5					GXSpriteLow:
>05e5							.fill 	64
.0625					GXSpriteHigh:
>0625							.fill 	64
.aa25					GXGraphicDraw:
.aa25	c9 40		cmp #$40			cmp 	#GCMD_Move					; low instructions don't use coordinates
.aa27	b0 06		bcs $aa2f			bcs 	_GDCoordinate
.aa29	86 36		stx $36				stx 	gxzTemp0 					; save X/Y
.aa2b	84 37		sty $37				sty 	gxzTemp0+1
.aa2d	80 4b		bra $aa7a			bra 	_GDExecuteA 				; and execute
.aa2f					_GDCoordinate:
.aa2f	48		pha				pha 								; save AXY
.aa30	da		phx				phx
.aa31	5a		phy				phy
.aa32	a2 03		ldx #$03			ldx 	#3 							; copy currentX to lastX
.aa34					_GDCopy1:
.aa34	bd c5 05	lda $05c5,x			lda 	gxCurrentX,x
.aa37	9d c9 05	sta $05c9,x			sta 	gxLastX,x
.aa3a	ca		dex				dex
.aa3b	10 f7		bpl $aa34			bpl 	_GDCopy1
.aa3d	68		pla				pla 								; update Y
.aa3e	8d c7 05	sta $05c7			sta 	gxCurrentY
.aa41	9c c8 05	stz $05c8			stz 	gxCurrentY+1
.aa44	68		pla				pla
.aa45	8d c5 05	sta $05c5			sta 	gxCurrentX
.aa48	68		pla				pla 								; get A (command+X.1) back
.aa49	48		pha				pha
.aa4a	29 01		and #$01			and 	#1 							; put LSB as MSB of Current.X
.aa4c	8d c6 05	sta $05c6			sta 	gxCurrentX+1
.aa4f	68		pla				pla 								; get command back
.aa50	29 fe		and #$fe			and 	#$FE 						; lose LSB, chuck the stray X bit
.aa52	48		pha				pha 								; push back.
.aa53	c9 52		cmp #$52			cmp 	#GCMD_SpriteMove 			; move sprite does not clip.
.aa55	f0 17		beq $aa6e			beq 	_GDCopyToWorkArea
.aa57	ad c6 05	lda $05c6			lda 	gxCurrentX+1 				; X < 256 X okay
.aa5a	f0 07		beq $aa63			beq 	_GDCheckY
.aa5c	ad c5 05	lda $05c5			lda 	gxCurrentX 					; otherwise X < 320 = 256 + 64
.aa5f	c9 40		cmp #$40			cmp 	#64
.aa61	b0 08		bcs $aa6b			bcs 	_GDError1
.aa63					_GDCheckY:
.aa63	ad c7 05	lda $05c7			lda 	gxCurrentY 					; check Y < Height.
.aa66	cd d9 05	cmp $05d9			cmp 	gxHeight
.aa69	90 03		bcc $aa6e			bcc 	_GDCopyToWorkArea
.aa6b					_GDError1:
.aa6b	68		pla				pla
.aa6c					_GDError2:
.aa6c	38		sec				sec
.aa6d	60		rts				rts
.aa6e					_GDCopyToWorkArea:
.aa6e	a2 07		ldx #$07			ldx 	#7 							; copy current and last to gxXY/12 work area
.aa70					_GDCopy2:
.aa70	bd c5 05	lda $05c5,x			lda 	gxCurrentX,x
.aa73	9d cd 05	sta $05cd,x			sta 	gxX0,x
.aa76	ca		dex				dex
.aa77	10 f7		bpl $aa70			bpl 	_GDCopy2
.aa79	68		pla				pla 								; get command
.aa7a					_GDExecuteA:
.aa7a	c9 54		cmp #$54			cmp 	#GRFirstFreeCode*2 			; bad ?
.aa7c	b0 ee		bcs $aa6c			bcs 	_GDError2
.aa7e	aa		tax				tax
.aa7f	7c 9c b9	jmp ($b99c,x)			jmp 	(GRVectorTable,x)
.aa82					GXMove:
.aa82	18		clc				clc
.aa83	60		rts				rts
.aa84					GRUndefined:
>aa84	db						.byte 	$DB 						; causes a break in the emulator
.aa85					GXFillCircle:
.aa85	a9 ff		lda #$ff			lda 	#255
.aa87	80 02		bra $aa8b			bra 	GXCircle
.aa89					GXFrameCircle:
.aa89	a9 00		lda #$00			lda 	#0
.aa8b					GXCircle:
.aa8b	8d 68 06	sta $0668			sta 	gxIsFillMode					; save Fill flag
.aa8e	ad d6 05	lda $05d6			lda 	gxBitmapsOn
.aa91	f0 26		beq $aab9			beq 	_GXCFail
.aa93	20 e4 b2	jsr $b2e4			jsr 	GXSortXY 					; topleft/bottomright
.aa96	20 bc b1	jsr $b1bc			jsr 	GXOpenBitmap 				; start drawing
.aa99	20 8b ab	jsr $ab8b			jsr 	GXCircleSetup 				; set up for drawing
.aa9c	9c 69 06	stz $0669			stz 	gxYChanged
.aa9f					_GXCircleDraw:
.aa9f	ad 66 06	lda $0666			lda 	gXCentre					; while x <= y
.aaa2	cd 67 06	cmp $0667			cmp 	gYCentre
.aaa5	90 0a		bcc $aab1			bcc 	_GXCircleContinue
.aaa7	d0 03		bne $aaac			bne 	_GXNoLast
.aaa9	20 be aa	jsr $aabe			jsr 	GXPlot1
.aaac					_GXNoLast:
.aaac	20 c4 b1	jsr $b1c4			jsr 	GXCloseBitmap 				; close the bitmap
.aaaf	18		clc				clc
.aab0	60		rts				rts
.aab1					_GXCircleContinue:
.aab1	20 bb aa	jsr $aabb			jsr 	GXPlot2 					; draw it
.aab4	20 38 ab	jsr $ab38			jsr 	GXCircleMove 				; adjust the coordinates
.aab7	80 e6		bra $aa9f			bra 	_GXCircleDraw
.aab9					_GXCFail:
.aab9	38		sec				sec
.aaba	60		rts				rts
.aabb					GXPlot2:
.aabb	20 be aa	jsr $aabe			jsr 	GXPlot1 						; plot and swap, fall through does twice
.aabe					GXPlot1:
.aabe	ad 67 06	lda $0667			lda 	gYCentre 						; if y = 0, don't do it twice (xor)
.aac1	f0 03		beq $aac6			beq 	_GXPlot1Only
.aac3	20 e2 aa	jsr $aae2			jsr 	GXPlot0 						; plot and negate
.aac6					_GXPlot1Only:
.aac6	20 e2 aa	jsr $aae2			jsr 	GXPlot0 						; twice, undoing negation
.aac9	ad 66 06	lda $0666			lda 	gXCentre 						; swap X and Y
.aacc	ae 67 06	ldx $0667			ldx	 	gYCentre
.aacf	8d 67 06	sta $0667			sta 	gYCentre
.aad2	8e 66 06	stx $0666			stx 	gXCentre
.aad5	ad 69 06	lda $0669			lda 	gxYChanged 						; toggle Y Changed flag
.aad8	a9 ff		lda #$ff			lda 	#$FF
.aada	8d 69 06	sta $0669			sta 	gxYChanged
.aadd	60		rts				rts
.aade	20 e2 aa	jsr $aae2			jsr 	GXPlot0 						; do once
.aae1	60		rts				rts
.aae2	ad 68 06	lda $0668	GXPlot0:lda 	gxIsFillMode 					; outline mode, always draw as X or Y will change
.aae5	f0 05		beq $aaec			beq 	_GXPlot0Always
.aae7	ad 69 06	lda $0669			lda 	gxYChanged						; fill mode, only draw if changed.
.aaea	f0 2d		beq $ab19			beq 	GXPlot0Exit
.aaec					_GXPlot0Always:
.aaec	a2 02		ldx #$02			ldx 	#2 								; copy Y1-A => Y0
.aaee	ad 67 06	lda $0667			lda 	gYCentre
.aaf1	20 1a ab	jsr $ab1a			jsr 	GXSubCopy
.aaf4	a2 00		ldx #$00			ldx 	#0 								; copy X1-A => X0,
.aaf6	ad 66 06	lda $0666			lda 	gXCentre
.aaf9	20 1a ab	jsr $ab1a			jsr 	GXSubCopy
.aafc	48		pha				pha 									; save last offset X
.aafd	20 cc b1	jsr $b1cc			jsr 	GXPositionCalc 					; calculate position/offset.
.ab00	68		pla				pla
.ab01	0a		asl a				asl 	a 								; store 2 x last offset in gxzTemp0
.ab02	85 36		sta $36				sta 	gxzTemp0
.ab04	64 37		stz $37				stz 	gxzTemp0+1
.ab06	26 37		rol $37				rol 	gxzTemp0+1
.ab08	ad 68 06	lda $0668			lda 	gxIsFillMode
.ab0b	69 80		adc #$80			adc 	#128
.ab0d	20 aa ae	jsr $aeaa			jsr 	GXDrawLineTemp0 				; routine from Rectangle.
.ab10	38		sec				sec 									; GY = -GY
.ab11	a9 00		lda #$00			lda 	#0
.ab13	ed 67 06	sbc $0667			sbc 	gYCentre
.ab16	8d 67 06	sta $0667			sta 	gYCentre
.ab19					GXPlot0Exit:
.ab19	60		rts				rts
.ab1a					GXSubCopy:
.ab1a	85 36		sta $36				sta 	gxzTemp0
.ab1c	64 37		stz $37				stz 	gxzTemp0+1
.ab1e	29 80		and #$80			and 	#$80
.ab20	f0 02		beq $ab24			beq 	_GXNoSx
.ab22	c6 37		dec $37				dec 	gxzTemp0+1
.ab24					_GXNoSx:
.ab24	38		sec				sec
.ab25	bd d1 05	lda $05d1,x			lda 	gXX1,x
.ab28	e5 36		sbc $36				sbc 	gxzTemp0
.ab2a	9d cd 05	sta $05cd,x			sta 	gXX0,x
.ab2d	bd d2 05	lda $05d2,x			lda 	gXX1+1,x
.ab30	e5 37		sbc $37				sbc 	gxzTemp0+1
.ab32	9d ce 05	sta $05ce,x			sta 	gXX0+1,x
.ab35	a5 36		lda $36				lda 	gxzTemp0 						; return A
.ab37	60		rts				rts
.ab38					GXCircleMove:
.ab38	9c 69 06	stz $0669			stz 	gxYChanged 					; clear Y changed flag
.ab3b	a5 39		lda $39				lda 	gxzTemp1+1 					; check sign of D
.ab3d	10 0d		bpl $ab4c			bpl 	_GXEMPositive
.ab3f	ee 66 06	inc $0666			inc 	gXCentre 					; X++
.ab42	ad 66 06	lda $0666			lda 	gXCentre
.ab45	20 6b ab	jsr $ab6b			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.ab48	a9 06		lda #$06			lda 	#6  						; and add 6
.ab4a	80 15		bra $ab61			bra 	_GXEMAddD
.ab4c					_GXEMPositive:
.ab4c	ee 66 06	inc $0666			inc 	gXCentre					; X++
.ab4f	ce 67 06	dec $0667			dec 	gyCentre 					; Y--
.ab52	38		sec				sec 								; calculate X-Y
.ab53	ad 66 06	lda $0666			lda 	gXCentre
.ab56	ed 67 06	sbc $0667			sbc 	gYCentre
.ab59	20 6b ab	jsr $ab6b			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.ab5c	a9 0a		lda #$0a			lda 	#10  						; and add 10
.ab5e	ce 69 06	dec $0669			dec 	gxYChanged
.ab61					_GXEMAddD:
.ab61	18		clc				clc
.ab62	65 38		adc $38				adc 	gxzTemp1
.ab64	85 38		sta $38				sta 	gxzTemp1
.ab66	90 02		bcc $ab6a			bcc 	_GXEMNoCarry
.ab68	e6 39		inc $39				inc 	gxzTemp1+1
.ab6a					_GXEMNoCarry:
.ab6a	60		rts				rts
.ab6b					_GXAdd4TimesToD:
.ab6b	85 36		sta $36				sta 	gxzTemp0 					; make 16 bit signed.
.ab6d	29 80		and #$80			and 	#$80
.ab6f	f0 02		beq $ab73			beq 	_GXA4Unsigned
.ab71	a9 ff		lda #$ff			lda 	#$FF
.ab73					_GXA4Unsigned:
.ab73	85 37		sta $37				sta 	gxzTemp0+1
.ab75	06 36		asl $36				asl 	gxzTemp0  					; x 4
.ab77	26 37		rol $37				rol 	gxzTemp0+1
.ab79	06 36		asl $36				asl 	gxzTemp0
.ab7b	26 37		rol $37				rol 	gxzTemp0+1
.ab7d	18		clc				clc 								; add
.ab7e	a5 36		lda $36				lda		gxzTemp0
.ab80	65 38		adc $38				adc 	gxzTemp1
.ab82	85 38		sta $38				sta 	gxzTemp1
.ab84	a5 37		lda $37				lda		gxzTemp0+1
.ab86	65 39		adc $39				adc 	gxzTemp1+1
.ab88	85 39		sta $39				sta 	gxzTemp1+1
.ab8a	60		rts				rts
.ab8b					GXCircleSetup:
.ab8b	38		sec				sec
.ab8c	ad d3 05	lda $05d3			lda 	gxY1
.ab8f	ed cf 05	sbc $05cf			sbc 	gxY0
.ab92	4a		lsr a				lsr 	a
.ab93	8d 65 06	sta $0665			sta 	gxRadius
.ab96	a2 00		ldx #$00			ldx 	#0
.ab98	20 ba ab	jsr $abba			jsr 	_GXCalculateCentre
.ab9b	a2 02		ldx #$02			ldx 	#2
.ab9d	20 ba ab	jsr $abba			jsr 	_GXCalculateCentre
.aba0	9c 66 06	stz $0666			stz 	gXCentre
.aba3	ad 65 06	lda $0665			lda 	gxRadius
.aba6	8d 67 06	sta $0667			sta 	gYCentre
.aba9	0a		asl a				asl 	a 							; R x 2
.abaa	85 36		sta $36				sta 	gxzTemp0
.abac	38		sec				sec
.abad	a9 03		lda #$03			lda 	#3
.abaf	e5 36		sbc $36				sbc 	gxzTemp0
.abb1	85 38		sta $38				sta 	gxzTemp1
.abb3	a9 00		lda #$00			lda 	#0
.abb5	e9 00		sbc #$00			sbc 	#0
.abb7	85 39		sta $39				sta 	gxzTemp1+1
.abb9	60		rts				rts
.abba					_GXCalculateCentre:
.abba	38		sec				sec
.abbb	bd d1 05	lda $05d1,x			lda 	gxX1,x
.abbe	7d cd 05	adc $05cd,x			adc 	gXX0,x
.abc1	9d d1 05	sta $05d1,x			sta 	gXX1,x
.abc4	bd d2 05	lda $05d2,x			lda 	gXX1+1,x
.abc7	7d ce 05	adc $05ce,x			adc 	gXX0+1,x
.abca	4a		lsr a				lsr 	a
.abcb	9d d2 05	sta $05d2,x			sta 	gXX1+1,x
.abce	7e d1 05	ror $05d1,x			ror 	gXX1,x
.abd1	60		rts				rts
.0665					gxRadius:
>0665							.fill 	1
.0666					gXCentre:
>0666							.fill 	1
.0667					gYCentre:
>0667							.fill 	1
.0668					gxIsFillMode:
>0668							.fill 	1
.0669					gxYChanged:
>0669							.fill  	1
=64000					ScreenSize200 = 320 * 200
=76800					ScreenSize240 = 320 * 240
.abd2					GXClearBitmap:
.abd2	ad d6 05	lda $05d6			lda 	gxBitmapsOn 				; check BMP running.
.abd5	f0 24		beq $abfb			beq 	_GXCBFail
.abd7	20 bc b1	jsr $b1bc			jsr 	GXOpenBitmap 				; start access
.abda	a0 07		ldy #$07			ldy 	#ScreenSize200 / 8192 		; X is pages to clear
.abdc	ad d9 05	lda $05d9			lda 	gxHeight
.abdf	c9 c8		cmp #$c8			cmp 	#200 						; 200 ?
.abe1	a0 09		ldy #$09			ldy 	#ScreenSize240 / 8192
.abe3					_GXCalcLastPage:
.abe3	98		tya				tya 								; add to base page
.abe4	18		clc				clc
.abe5	6d d7 05	adc $05d7			adc 	gxBasePage
.abe8	85 0b		sta $0b				sta 	GXEditSlot  				; clear from this page back
.abea					_GXClearAll:
.abea	20 fd ab	jsr $abfd			jsr 	_GXClearBlock 				; clear 8k block
.abed	c6 0b		dec $0b				dec 	GXEditSlot  				; back to previous
.abef	a5 0b		lda $0b				lda 	GXEditSlot
.abf1	cd d7 05	cmp $05d7			cmp 	gxBasePage 					; until before base page
.abf4	b0 f4		bcs $abea			bcs 	_GXClearAll
.abf6	20 c4 b1	jsr $b1c4			jsr 	GXCloseBitmap	 			; stop access
.abf9	18		clc				clc
.abfa	60		rts				rts
.abfb					_GXCBFail:
.abfb	38		sec				sec
.abfc	60		rts				rts
.abfd					_GXClearBlock:
.abfd	a9 00		lda #$00			lda 	#((GXMappingAddress) & $FF)
.abff	85 38		sta $38				sta 	0+gxzTemp1
.ac01	a9 60		lda #$60			lda 	#((GXMappingAddress) >> 8)
.ac03	85 39		sta $39				sta 	1+gxzTemp1
.ac05					_GXCB0:
.ac05	a5 36		lda $36				lda 	gxzTemp0
.ac07	a0 00		ldy #$00			ldy 	#0
.ac09					_GXCB1:
.ac09	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ac0b	c8		iny				iny
.ac0c	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ac0e	c8		iny				iny
.ac0f	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ac11	c8		iny				iny
.ac12	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ac14	c8		iny				iny
.ac15	d0 f2		bne $ac09			bne 	_GXCB1
.ac17	e6 39		inc $39				inc 	gxzTemp1+1
.ac19	a5 39		lda $39				lda 	gxzTemp1+1
.ac1b	c9 80		cmp #$80			cmp	 	#(GXMappingAddress >> 8)+$20
.ac1d	d0 e6		bne $ac05			bne 	_GXCB0
.ac1f	60		rts				rts
.ac20					GXInitialise:
.ac20	64 01		stz $01				stz 	1
.ac22	a9 01		lda #$01			lda 	#1
.ac24	8d 00 d0	sta $d000			sta 	$D000
.ac27	18		clc				clc
.ac28	9c d5 05	stz $05d5			stz 	GXSpritesOn
.ac2b	9c d6 05	stz $05d6			stz 	GXBitmapsOn
.ac2e	a2 0f		ldx #$0f			ldx 	#15
.ac30					_GXIClear:
.ac30	9e c5 05	stz $05c5,x			stz 	gxCurrentX,x
.ac33	ca		dex				dex
.ac34	10 fa		bpl $ac30			bpl 	_GXIClear
.ac36	20 d1 ac	jsr $acd1			jsr 	GXClearSpriteStore
.ac39	60		rts				rts
.ac3a					GXControlBitmap:
.ac3a	64 01		stz $01				stz 	1
.ac3c	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.ac3e	29 01		and #$01			and 	#1 							; set bitmap flag
.ac40	8d d6 05	sta $05d6			sta 	gxBitmapsOn
.ac43	4a		lsr a				lsr 	a 							; bit 0 into carry.
.ac44	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.ac47	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.ac49	29 f7		and #$f7			and 	#$F7 						; clear bitmap bit
.ac4b	90 02		bcc $ac4f			bcc 	_CBNotOn
.ac4d	09 08		ora #$08			ora 	#$08 						; bitmap on if 1 on 0 off
.ac4f					_CBNotOn:
.ac4f	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.ac52	a5 36		lda $36				lda 	gxzTemp0 					; get control settings (bits 0-2)
.ac54	29 07		and #$07			and 	#7
.ac56	8d 00 d1	sta $d100			sta 	$D100 						; write in Vicky Bitmap Control Register #0
.ac59	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.ac5b	d0 02		bne $ac5f			bne 	_CBNotDefault
.ac5d	a9 08		lda #$08			lda 	#8  						; if zero, use 8 e.g. bitmap at $10000
.ac5f					_CBNotDefault:
.ac5f	8d d7 05	sta $05d7			sta 	gxBasePage
.ac62	20 c3 ac	jsr $acc3			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.ac65	a5 37		lda $37				lda 	gxzTemp0+1 					; copy address into Bitmap address registers
.ac67	8d 03 d1	sta $d103			sta 	$D103
.ac6a	a5 36		lda $36				lda 	gxzTemp0
.ac6c	8d 02 d1	sta $d102			sta 	$D102
.ac6f	9c 01 d1	stz $d101			stz 	$D101
.ac72	a2 f0		ldx #$f0			ldx 	#240 						; height is 240
.ac74	ad 01 d0	lda $d001			lda 	$D001 						; read MCR bit 0
.ac77	29 01		and #$01			and 	#1
.ac79	f0 02		beq $ac7d			beq 	_CBHaveHeight
.ac7b	a2 c8		ldx #$c8			ldx 	#200 						; if bit 0 set 320x200
.ac7d					_CBHaveHeight
.ac7d	8e d9 05	stx $05d9			stx 	gxHeight
.ac80	18		clc				clc
.ac81	60		rts				rts
.ac82					GXControlSprite:
.ac82	64 01		stz $01				stz 	1
.ac84	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.ac86	29 01		and #$01			and 	#1 							; set sprites flag
.ac88	8d d5 05	sta $05d5			sta 	gxSpritesOn
.ac8b	4a		lsr a				lsr 	a 							; bit 0 into carry.
.ac8c	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.ac8f	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.ac91	29 df		and #$df			and 	#$DF 						; clear sprite bit
.ac93	90 02		bcc $ac97			bcc 	_CSNotOn
.ac95	09 20		ora #$20			ora 	#$20 						; sprite on if 1 on 0 off
.ac97					_CSNotOn:
.ac97	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.ac9a	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.ac9c	d0 02		bne $aca0			bne 	_CSNotDefault
.ac9e	a9 18		lda #$18			lda 	#24  						; if zero, use 24 e.g. sprites at $30000
.aca0					_CSNotDefault:
.aca0	8d d8 05	sta $05d8			sta 	gxSpritePage
.aca3	20 c3 ac	jsr $acc3			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.aca6	a5 36		lda $36				lda 	zTemp0
.aca8	8d e3 05	sta $05e3			sta 	GXSpriteOffsetBase
.acab	a5 37		lda $37				lda 	zTemp0+1
.acad	8d e4 05	sta $05e4			sta 	GXSpriteOffsetBase+1
.acb0	a2 00		ldx #$00			ldx 	#0 							; disable all sprites, clears all sprite memory.
.acb2					_CSClear:
.acb2	9e 00 d9	stz $d900,x			stz 	$D900,x
.acb5	9e 00 da	stz $da00,x			stz 	$DA00,x
.acb8	ca		dex				dex
.acb9	d0 f7		bne $acb2			bne 	_CSClear
.acbb	9c e2 05	stz $05e2			stz 	GSCurrentSpriteAddr+1 		; no sprite selected.
.acbe	20 d1 ac	jsr $acd1			jsr 	GXClearSpriteStore
.acc1	18		clc				clc
.acc2	60		rts				rts
.acc3					GXCalculateBaseAddress:
.acc3	85 36		sta $36				sta 	gxzTemp0
.acc5	64 37		stz $37				stz 	gxzTemp0+1
.acc7	a9 05		lda #$05			lda 	#5
.acc9					_GXShift:
.acc9	06 36		asl $36				asl 	gxzTemp0
.accb	26 37		rol $37				rol 	gxzTemp0+1
.accd	3a		dec a				dec		a
.acce	d0 f9		bne $acc9			bne 	_GXShift
.acd0	60		rts				rts
.acd1					GXClearSpriteStore:
.acd1	a2 3f		ldx #$3f			ldx 	#63 						; erase 64 sprite store elements
.acd3					_GXCSSLoop:
.acd3	9e 25 06	stz $0625,x			stz 	GXSpriteHigh,x
.acd6	a9 80		lda #$80			lda 	#$80 						; set the 'hidden' bit.
.acd8	9d e5 05	sta $05e5,x			sta 	GXSpriteLow,x
.acdb	ca		dex				dex
.acdc	10 f5		bpl $acd3			bpl 	_GXCSSLoop
.acde	60		rts				rts
.acdf					GXLine:
.acdf	ad d6 05	lda $05d6			lda 	GXBitmapsOn
.ace2	f0 28		beq $ad0c			beq 	_GXLFail
.ace4	20 bc b1	jsr $b1bc			jsr 	GXOpenBitmap
.ace7	20 02 b3	jsr $b302			jsr 	GXSortY						; sort pairs so Y1 >= Y0 e.g. top to bottom.
.acea	20 b2 ad	jsr $adb2			jsr 	GXLineSetup 				; the calculations in the linescanner constructor
.aced	20 cc b1	jsr $b1cc			jsr 	GXPositionCalc 				; calculate position/offset.
.acf0					_GXDrawLoop:
.acf0	ac df 05	ldy $05df			ldy 	gsOffset 					; draw the pixel
.acf3	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.acf5	2d dd 05	and $05dd			and 	gxANDValue
.acf8	4d dc 05	eor $05dc			eor 	gxEORValue
.acfb	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.acfd	20 0e ad	jsr $ad0e			jsr 	GXLineIsComplete 			; is the line complete ?
.ad00	f0 05		beq $ad07			beq 	_GXLExit
.ad02	20 29 ad	jsr $ad29			jsr 	GXLineAdvance 				; code as per advance method
.ad05	80 e9		bra $acf0			bra 	_GXDrawLoop
.ad07					_GXLExit:
.ad07	20 c4 b1	jsr $b1c4			jsr 	GXCloseBitmap
.ad0a	18		clc				clc
.ad0b	60		rts				rts
.ad0c					_GXLFail:
.ad0c	38		sec				sec
.ad0d	60		rts				rts
.ad0e					GXLineIsComplete:
.ad0e	ad 6c 06	lda $066c			lda 	GXIsDiffYLarger 			; is dy larger
.ad11	d0 0f		bne $ad22			bne 	_GXLICCompareY 				; if so compare Y1/Y0
.ad13	ad cd 05	lda $05cd			lda 	GXX0 						; compare X, LSB and MSB
.ad16	4d d1 05	eor $05d1			eor 	GXX1
.ad19	d0 06		bne $ad21			bne 	_GXLICExit
.ad1b	ad ce 05	lda $05ce			lda 	GXX0+1
.ad1e	4d d2 05	eor $05d2			eor 	GXX1+1
.ad21					_GXLICExit:
.ad21	60		rts				rts
.ad22					_GXLICCompareY:
.ad22	ad d3 05	lda $05d3			lda 	GXY1
.ad25	4d cf 05	eor $05cf			eor 	GXY0
.ad28	60		rts				rts
.ad29					GXLineAdvance:
.ad29	18		clc				clc 								; add adjust to position
.ad2a	ad 6e 06	lda $066e			lda 	GXPosition
.ad2d	6d 6f 06	adc $066f			adc 	GXAdjust
.ad30	8d 6e 06	sta $066e			sta 	GXPosition
.ad33	9c 71 06	stz $0671			stz 	GXAddSelect 				; clear add select flag
.ad36	b0 05		bcs $ad3d			bcs 	_GXLAOverflow 				; if carry out, overflowed.
.ad38	cd 70 06	cmp $0670			cmp 	GXTotal 					; if exceeded total
.ad3b	90 0a		bcc $ad47			bcc 	_GXLANoExtra
.ad3d					_GXLAOverflow:
.ad3d	ce 71 06	dec $0671			dec 	GXAddSelect 				; set addselect to $FF
.ad40	38		sec				sec 								; subtract total and write back
.ad41	ed 70 06	sbc $0670			sbc 	GXTotal
.ad44	8d 6e 06	sta $066e			sta 	GXPosition
.ad47					_GXLANoExtra:
.ad47	ad 6c 06	lda $066c			lda 	GXIsDiffYLarger
.ad4a	f0 0d		beq $ad59			beq 	_GXDXLarger
.ad4c	20 ab ad	jsr $adab			jsr 	GXIncrementY
.ad4f	ad 71 06	lda $0671			lda 	GXAddSelect
.ad52	f0 10		beq $ad64			beq 	_GXLAExit
.ad54	20 65 ad	jsr $ad65			jsr 	GXAdjustX
.ad57	80 0b		bra $ad64			bra 	_GXLAExit
.ad59					_GXDXLarger:
.ad59	20 65 ad	jsr $ad65			jsr 	GXAdjustX
.ad5c	ad 71 06	lda $0671			lda 	GXAddSelect
.ad5f	f0 03		beq $ad64			beq 	_GXLAExit
.ad61	20 ab ad	jsr $adab			jsr 	GXIncrementY
.ad64					_GXLAExit:
.ad64	60		rts				rts
.ad65					GXAdjustX:
.ad65	ad 6d 06	lda $066d			lda 	GXDXNegative
.ad68	10 25		bpl $ad8f			bpl 	_GXAXRight
.ad6a	ad cd 05	lda $05cd			lda 	GXX0
.ad6d	d0 03		bne $ad72			bne 	_GXAXNoBorrow
.ad6f	ce ce 05	dec $05ce			dec 	GXX0+1
.ad72					_GXAXNoBorrow:
.ad72	ce cd 05	dec $05cd			dec 	GXX0
.ad75	ce df 05	dec $05df			dec 	gsOffset 					; pixel left
.ad78	ad df 05	lda $05df			lda 	gsOffset
.ad7b	c9 ff		cmp #$ff			cmp 	#$FF
.ad7d	d0 0f		bne $ad8e			bne 	_GXAYExit 					; underflow
.ad7f	c6 3d		dec $3d				dec 	gxzScreen+1 					; borrow
.ad81	a5 3d		lda $3d				lda 	gxzScreen+1 					; gone off page
.ad83	c9 60		cmp #$60			cmp 	#GXMappingAddress >> 8
.ad85	b0 07		bcs $ad8e			bcs 	_GXAYExit
.ad87	18		clc				clc
.ad88	69 20		adc #$20			adc 	#$20 						; fix up
.ad8a	85 3d		sta $3d				sta 	gxzScreen+1
.ad8c	c6 0b		dec $0b				dec 	GXEditSlot 				; back one page
.ad8e					_GXAYExit:
.ad8e	60		rts				rts
.ad8f					_GXAXRight:
.ad8f	ee cd 05	inc $05cd			inc 	GXX0
.ad92	d0 03		bne $ad97			bne 	_GXAXNoCarry
.ad94	ee ce 05	inc $05ce			inc 	GXX0+1
.ad97					_GXAXNoCarry:
.ad97	ee df 05	inc $05df			inc 	gsOffset 					; pixel right
.ad9a	d0 0e		bne $adaa			bne 	_GXAXExit 					; if not overflowed, exit.
.ad9c	e6 3d		inc $3d				inc 	gxzScreen+1 					; next line
.ad9e	a5 3d		lda $3d				lda 	gxzScreen+1
.ada0	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.ada2	90 06		bcc $adaa			bcc 	_GXAXExit
.ada4	e9 20		sbc #$20			sbc 	#$20 						; fix up
.ada6	85 3d		sta $3d				sta 	gxzScreen+1
.ada8	e6 0b		inc $0b				inc 	GXEditSlot 				; next page
.adaa					_GXAXExit:
.adaa	60		rts				rts
.adab					GXIncrementY:
.adab	ee cf 05	inc $05cf			inc 	GXY0
.adae	20 22 b2	jsr $b222			jsr 	GXMovePositionDown
.adb1	60		rts				rts
.adb2					GXLineSetup:
.adb2	ad d3 05	lda $05d3			lda 	GXY1
.adb5	38		sec				sec
.adb6	ed cf 05	sbc $05cf			sbc 	GXY0
.adb9	4a		lsr a				lsr 	a
.adba	8d 6b 06	sta $066b			sta 	GXDiffY
.adbd	9c 6d 06	stz $066d			stz 	GXDXNegative 				; clear -ve flag
.adc0	38		sec				sec
.adc1	ad d1 05	lda $05d1			lda 	GXX1
.adc4	ed cd 05	sbc $05cd			sbc 	GXX0
.adc7	8d 6a 06	sta $066a			sta 	GXDiffX
.adca	ad d2 05	lda $05d2			lda 	GXX1+1 						; calculate MSB
.adcd	ed ce 05	sbc $05ce			sbc 	GXX0+1
.add0	6a		ror a				ror 	a 							; rotate bit into DiffX halving it
.add1	6e 6a 06	ror $066a			ror 	GXDiffX
.add4	0a		asl a				asl 	a
.add5	10 0c		bpl $ade3			bpl 	_GDXNotNegative
.add7	a9 00		lda #$00			lda 	#0 							; make absolute value of |dx|
.add9	38		sec				sec
.adda	ed 6a 06	sbc $066a			sbc 	GXDiffX
.addd	8d 6a 06	sta $066a			sta 	GXDiffX
.ade0	ce 6d 06	dec $066d			dec 	GXDXNegative 				; -ve flag = $FF.
.ade3					_GDXNotNegative:
.ade3	9c 6c 06	stz $066c			stz 	GXIsDiffYLarger 			; clear larger flag
.ade6	ad 6b 06	lda $066b			lda 	GXDiffY 					; set adjust and total.
.ade9	8d 6f 06	sta $066f			sta 	GXAdjust
.adec	ad 6a 06	lda $066a			lda 	GXDiffX
.adef	8d 70 06	sta $0670			sta 	GXTotal
.adf2	ad 6b 06	lda $066b			lda 	GXDiffY 					; if dy > dx
.adf5	cd 6a 06	cmp $066a			cmp 	GXDiffX
.adf8	90 0f		bcc $ae09			bcc 	_GDXNotLarger
.adfa	ce 6c 06	dec $066c			dec 	GXIsDiffYLarger 			; set the dy larger flag
.adfd	ad 6a 06	lda $066a			lda 	GXDiffX 					; set adjust and total other way round
.ae00	8d 6f 06	sta $066f			sta 	GXAdjust
.ae03	ad 6b 06	lda $066b			lda 	GXDiffY
.ae06	8d 70 06	sta $0670			sta 	GXTotal
.ae09					_GDXNotLarger:
.ae09	ad 70 06	lda $0670			lda 	GXTotal
.ae0c	4a		lsr a				lsr 	a
.ae0d	8d 6e 06	sta $066e			sta 	GXPosition
.ae10	60		rts				rts
.066a					GXDiffX:
>066a							.fill 	1
.066b					GXDiffY:
>066b							.fill 	1
.066c					GXIsDiffYLarger:
>066c							.fill 	1
.066d					GXDXNegative:
>066d							.fill 	1
.066e					GXPosition:
>066e							.fill 	1
.066f					GXAdjust:
>066f							.fill 	1
.0670					GXTotal:
>0670							.fill 	1
.0671					GXAddSelect:
>0671							.fill 	1
.ae11					GXSetColourMode:
.ae11	a6 36		ldx $36				ldx 	gxzTemp0
.ae13	8e db 05	stx $05db			stx 	gxColour 								; set colour
.ae16	a5 37		lda $37				lda 	gxzTemp0+1 								;
.ae18	8d da 05	sta $05da			sta 	gxMode 									; set mode
.ae1b	29 03		and #$03			and 	#3 										; only interested in bits 0-3
.ae1d	9c dd 05	stz $05dd			stz 	gxANDValue 								; initially AND with 0, and EOR with Colour
.ae20	ae db 05	ldx $05db			ldx 	gxColour
.ae23	8e dc 05	stx $05dc			stx 	gxEORValue
.ae26	c9 02		cmp #$02			cmp 	#2 										; if mode 2/3 And with colour
.ae28	90 03		bcc $ae2d			bcc 	_GXSDCNotAndColour
.ae2a	8e dd 05	stx $05dd			stx 	gxANDValue
.ae2d					_GXSDCNotAndColour:
.ae2d	d0 03		bne $ae32			bne 	_GXSDCNotAnd 							; mode 2, Don't EOR with colour
.ae2f	9c dc 05	stz $05dc			stz 	gxEORValue
.ae32					_GXSDCNotAnd:
.ae32	4a		lsr a				lsr 	a 										; if bit 0 set, 1's complement AND value
.ae33	90 08		bcc $ae3d			bcc 	_GXSDCNoFlip
.ae35	ad dd 05	lda $05dd			lda	 	gxANDValue
.ae38	49 ff		eor #$ff			eor 	#$FF
.ae3a	8d dd 05	sta $05dd			sta 	gxANDValue
.ae3d					_GXSDCNoFlip:
.ae3d	18		clc				clc
.ae3e	60		rts				rts
.ae3f					GXPlotPoint:
.ae3f	20 bc b1	jsr $b1bc			jsr 	GXOpenBitmap 				; start drawing
.ae42	20 cc b1	jsr $b1cc			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.ae45	ac df 05	ldy $05df			ldy 	gsOffset
.ae48	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.ae4a	2d dd 05	and $05dd			and 	gxANDValue
.ae4d	4d dc 05	eor $05dc			eor 	gxEORValue
.ae50	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.ae52	20 c4 b1	jsr $b1c4			jsr 	GXCloseBitmap 				; stop drawing and exit
.ae55	18		clc				clc
.ae56	60		rts				rts
.ae57					GXFillRectangle:
.ae57	38		sec				sec
.ae58	80 01		bra $ae5b			bra 	GXRectangle
.ae5a					GXFrameRectangle:
.ae5a	18		clc				clc
.ae5b					GXRectangle:
.ae5b	ad d6 05	lda $05d6			lda 	gxBitmapsOn
.ae5e	f0 35		beq $ae95			beq 	_GXRFail
.ae60	08		php				php 								; save Fill flag (CS)
.ae61	20 bc b1	jsr $b1bc			jsr 	GXOpenBitmap 				; start drawing
.ae64	20 e4 b2	jsr $b2e4			jsr 	GXSortXY 					; sort both X and Y so top left/bottom right
.ae67	20 cc b1	jsr $b1cc			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.ae6a	38		sec				sec 								; sec = Draw line
.ae6b	20 97 ae	jsr $ae97			jsr 	GXDrawLineX1X0 				; draw a line length X1-X0
.ae6e	ad cf 05	lda $05cf			lda 	gxY0 						; reached end of rectangle ?
.ae71	cd d3 05	cmp $05d3			cmp 	gxY1
.ae74	f0 19		beq $ae8f			beq 	_GXRectangleExit
.ae76					_GXRectLoop:
.ae76	20 22 b2	jsr $b222			jsr 	GXMovePositionDown 			; down one.
.ae79	ee cf 05	inc $05cf			inc 	gxY0 						; change Y pos
.ae7c	ad cf 05	lda $05cf			lda 	gxY0 						; reached last line
.ae7f	cd d3 05	cmp $05d3			cmp 	gXY1
.ae82	f0 07		beq $ae8b			beq 	_GXLastLine
.ae84	28		plp				plp 								; get flag back
.ae85	08		php				php
.ae86	20 97 ae	jsr $ae97			jsr 	GXDrawLineX1X0 				; draw horizontal line
.ae89	80 eb		bra $ae76			bra 	_GXRectLoop
.ae8b					_GXLastLine:
.ae8b	38		sec				sec
.ae8c	20 97 ae	jsr $ae97			jsr 	GXDrawLineX1X0
.ae8f					_GXRectangleExit:
.ae8f	68		pla				pla 								; throw fill flag.
.ae90	20 c4 b1	jsr $b1c4			jsr 	GXCloseBitmap 				; stop drawing and exit
.ae93	18		clc				clc
.ae94	60		rts				rts
.ae95					_GXRFail:
.ae95	38		sec				sec
.ae96	60		rts				rts
.ae97					GXDrawLineX1X0:
.ae97	08		php				php 								; save solid/either-end
.ae98	38		sec				sec
.ae99	ad d1 05	lda $05d1			lda		gXX1
.ae9c	ed cd 05	sbc $05cd			sbc 	gXX0
.ae9f	85 36		sta $36				sta 	gxzTemp0
.aea1	ad d2 05	lda $05d2			lda 	gXX1+1
.aea4	ed ce 05	sbc $05ce			sbc 	gXX0+1
.aea7	85 37		sta $37				sta 	gxzTemp0+1
.aea9	28		plp				plp
.aeaa					GXDrawLineTemp0:
.aeaa	a5 3c		lda $3c				lda 	gxzScreen 						; push gxzScreen, gsOffset and GXEditSlot on stack
.aeac	48		pha				pha
.aead	a5 3d		lda $3d				lda 	gxzScreen+1
.aeaf	48		pha				pha
.aeb0	ad df 05	lda $05df			lda 	gsOffset
.aeb3	48		pha				pha
.aeb4	a5 0b		lda $0b				lda 	GXEditSlot
.aeb6	48		pha				pha
.aeb7	ac df 05	ldy $05df			ldy 	gsOffset 					; Y offset
.aeba	90 1e		bcc $aeda			bcc 	_GXDLTEndPoints 			; if CC draw end points only.
.aebc					_GXDLTLine:
.aebc	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.aebe	2d dd 05	and $05dd			and 	gxANDValue
.aec1	4d dc 05	eor $05dc			eor 	gxEORValue
.aec4	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.aec6	a5 36		lda $36				lda 	gxzTemp0 					; decrement counter
.aec8	d0 04		bne $aece			bne 	_GXDLTNoBorrow
.aeca	c6 37		dec $37				dec 	gxzTemp0+1 					; borrow, if goes -ve then exit
.aecc	30 2e		bmi $aefc			bmi 	_GXDLTExit
.aece					_GXDLTNoBorrow:
.aece	c6 36		dec $36				dec 	gxzTemp0
.aed0	c8		iny				iny 								; next slot.
.aed1	d0 e9		bne $aebc			bne 	_GXDLTLine
.aed3	e6 3d		inc $3d				inc 	gxzScreen+1 					; carry to next
.aed5	20 0a af	jsr $af0a			jsr 	GXDLTCheckWrap				; check for new page.
.aed8	80 e2		bra $aebc			bra 	_GXDLTLine
.aeda					_GXDLTEndPoints:
.aeda	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.aedc	2d dd 05	and $05dd			and 	gxANDValue
.aedf	4d dc 05	eor $05dc			eor 	gxEORValue
.aee2	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.aee4	98		tya				tya 								; advance to right side
.aee5	18		clc				clc
.aee6	65 36		adc $36				adc 	gxzTemp0
.aee8	a8		tay				tay
.aee9	a5 3d		lda $3d				lda 	gxzScreen+1
.aeeb	65 37		adc $37				adc 	gxzTemp0+1
.aeed	85 3d		sta $3d				sta 	gxzScreen+1
.aeef	20 0a af	jsr $af0a			jsr 	GXDLTCheckWrap 			; fix up.
.aef2	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.aef4	2d dd 05	and $05dd			and 	gxANDValue
.aef7	4d dc 05	eor $05dc			eor 	gxEORValue
.aefa	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.aefc					_GXDLTExit:
.aefc	68		pla				pla
.aefd	85 0b		sta $0b				sta 	GXEditSlot
.aeff	68		pla				pla
.af00	8d df 05	sta $05df			sta 	gsOffset
.af03	68		pla				pla
.af04	85 3d		sta $3d				sta 	gxzScreen+1
.af06	68		pla				pla
.af07	85 3c		sta $3c				sta 	gxzScreen
.af09	60		rts				rts
.af0a					GXDLTCheckWrap:
.af0a	a5 3d		lda $3d				lda 	gxzScreen+1 					; check end of page
.af0c	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8)
.af0e	90 06		bcc $af16			bcc 	_GXDLTCWExit
.af10	e9 20		sbc #$20			sbc 	#$20 						; fix up
.af12	85 3d		sta $3d				sta 	gxzScreen+1
.af14	e6 0b		inc $0b				inc 	GXEditSlot
.af16					_GXDLTCWExit:
.af16	60		rts				rts
.af17					GXDrawGraphicElement:
.af17	8d 72 06	sta $0672			sta 	gxSize 						; save size
.af1a	3a		dec a				dec 	a
.af1b	8d 73 06	sta $0673			sta 	gxMask 						; and mask
.af1e	ad d6 05	lda $05d6			lda 	gxBitmapsOn 				; check BMP on
.af21	f0 67		beq $af8a			beq 	_GXSLFail
.af23	ad cf 05	lda $05cf			lda 	gxY0 						; push Y on stack
.af26	48		pha				pha
.af27	8c 75 06	sty $0675			sty 	gxAcquireVector+1 			; and acquisition vector
.af2a	8e 74 06	stx $0674			stx 	gxAcquireVector
.af2d	20 bc b1	jsr $b1bc			jsr 	gxOpenBitmap 				; open the bitmap.
.af30	ad 77 06	lda $0677			lda 	gxUseMode 					; scale bits
.af33	4a		lsr a				lsr 	a
.af34	4a		lsr a				lsr 	a
.af35	4a		lsr a				lsr 	a
.af36	29 07		and #$07			and		#7
.af38	1a		inc a				inc 	a
.af39	8d 76 06	sta $0676			sta 	gxScale
.af3c	64 38		stz $38				stz 	gxzTemp1					; start first line
.af3e					_GXGELoop:
.af3e	a5 38		lda $38				lda 	gxzTemp1 					; current line number to read.
.af40	2c 77 06	bit $0677			bit 	gxUseMode 					; check for flip.
.af43	10 06		bpl $af4b			bpl		_GXNoVFlip
.af45	ad 73 06	lda $0673			lda 	gxMask
.af48	38		sec				sec
.af49	e5 38		sbc $38				sbc 	gxzTemp1
.af4b					_GXNoVFlip:
.af4b	aa		tax				tax 								; get the Xth line.
.af4c	20 8c af	jsr $af8c			jsr 	_GXCallAcquire 				; get that data.
.af4f	ad 76 06	lda $0676			lda 	gxScale 					; do scale identical copies of that line.
.af52	85 39		sta $39				sta 	gxzTemp1+1
.af54					_GXGELoop2:
.af54	ad cf 05	lda $05cf			lda 	gxY0 						; off screen
.af57	cd d9 05	cmp $05d9			cmp 	gxHeight
.af5a	b0 10		bcs $af6c			bcs 	_GXDGEExit
.af5c	20 8f af	jsr $af8f			jsr 	GXRenderOneLine 			; render line
.af5f	c6 39		dec $39				dec 	gxzTemp1+1 					; scale times.
.af61	d0 f1		bne $af54			bne 	_GXGELoop2
.af63	e6 38		inc $38				inc 	gxzTemp1 					; done all lines.
.af65	a5 38		lda $38				lda 	gxzTemp1
.af67	cd 72 06	cmp $0672			cmp 	gxSize
.af6a	d0 d2		bne $af3e			bne 	_GXGELoop
.af6c					_GXDGEExit:
.af6c	68		pla				pla 								; restore Y for next time
.af6d	8d cf 05	sta $05cf			sta 	gxY0
.af70	ae 76 06	ldx $0676			ldx 	gxScale 					; get scale (1-8)
.af73					_GXShiftLeft:
.af73	18		clc				clc
.af74	ad 72 06	lda $0672			lda 	gxSize
.af77	6d cd 05	adc $05cd			adc 	gxX0
.af7a	8d cd 05	sta $05cd			sta 	gxX0
.af7d	90 03		bcc $af82			bcc 	_GXSLNoCarry
.af7f	ee ce 05	inc $05ce			inc 	gxX0+1
.af82					_GXSLNoCarry:
.af82	ca		dex				dex
.af83	d0 ee		bne $af73			bne 	_GXShiftLeft
.af85	20 c4 b1	jsr $b1c4			jsr 	GXCloseBitmap
.af88	18		clc				clc
.af89	60		rts				rts
.af8a					_GXSLFail:
.af8a	38		sec				sec
.af8b	60		rts				rts
.af8c					_GXCallAcquire:
.af8c	6c 74 06	jmp ($0674)			jmp 	(gxAcquireVector)
.af8f					GXRenderOneLine:
.af8f	20 cc b1	jsr $b1cc			jsr 	GXPositionCalc 				; calculate position/offset.
.af92	ac df 05	ldy $05df			ldy 	gsOffset 					; Y contains position.
.af95	64 3a		stz $3a				stz 	gxzTemp2 					; do size pixels
.af97					_GXROLLoop1:
.af97	ad 76 06	lda $0676			lda 	gxScale 					; set to do 'scale' times
.af9a	85 3b		sta $3b				sta 	gxzTemp2+1
.af9c					_GXROLLoop2:
.af9c	a5 3a		lda $3a				lda 	gxzTemp2 					; get current pixel
.af9e	2c da 05	bit $05da			bit 	gxMode 						; check H Flip
.afa1	50 06		bvc $afa9			bvc 	_GXNoHFlip
.afa3	ad 73 06	lda $0673			lda 	gxMask
.afa6	38		sec				sec
.afa7	e5 3a		sbc $3a				sbc 	gxzTemp2
.afa9					_GXNoHFlip:
.afa9	aa		tax				tax 								; read from the pixel buffer
.afaa	bd 7b 05	lda $057b,x			lda 	gxPixelBuffer,x
.afad	d0 07		bne $afb6			bne 	_GXDraw 					; draw if non zero
.afaf	ad 77 06	lda $0677			lda 	gxUseMode 					; check to see if solid background
.afb2	29 04		and #$04			and 	#4
.afb4	f0 0a		beq $afc0			beq 	_GXZeroPixel
.afb6					_GXDraw:
.afb6	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.afb8	2d dd 05	and $05dd			and 	gxANDValue
.afbb	5d 7b 05	eor $057b,x			eor 	gxPixelBuffer,x
.afbe	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.afc0					_GXZeroPixel:
.afc0	c8		iny				iny 								; advance pointer
.afc1	d0 05		bne $afc8			bne 	_GXNoShift
.afc3	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.afc5	20 0a af	jsr $af0a			jsr 	GXDLTCheckWrap				; check for new page.
.afc8					_GXNoShift:
.afc8	c6 3b		dec $3b				dec 	gxzTemp2+1 					; do the inner loop gxScale times.
.afca	d0 d0		bne $af9c			bne 	_GXROLLoop2
.afcc	e6 3a		inc $3a				inc 	gxzTemp2 					; next pixel.
.afce	a5 3a		lda $3a				lda 	gxzTemp2
.afd0	cd 72 06	cmp $0672			cmp 	gxSize
.afd3	d0 c2		bne $af97			bne 	_GXROLLoop1
.afd5	ee cf 05	inc $05cf			inc 	gxY0
.afd8	60		rts				rts
.0672					gxSize:
>0672							.fill 	1
.0673					gxMask:
>0673							.fill 	1
.0674					gxAcquireVector:
>0674							.fill 	2
.0676					gxScale:
>0676							.fill 	1
.0677					gxUseMode:
>0677							.fill 	1
.afd9					GXFontHandler:
.afd9	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.afdb	4d da 05	eor $05da			eor 	gxMode
.afde	8d 77 06	sta $0677			sta 	gxUseMode
.afe1	64 37		stz $37				stz 	gxzTemp0+1 					; gxzTemp0 is font #
.afe3	06 36		asl $36				asl	 	gxzTemp0 					; x 2
.afe5	26 37		rol $37				rol	 	gxzTemp0+1
.afe7	06 36		asl $36				asl	 	gxzTemp0 					; x 4
.afe9	26 37		rol $37				rol	 	gxzTemp0+1
.afeb	06 36		asl $36				asl	 	gxzTemp0 					; x 8
.afed	26 37		rol $37				rol	 	gxzTemp0+1
.afef	a5 37		lda $37				lda 	gxzTemp0+1 					; put in page C0
.aff1	09 c0		ora #$c0			ora 	#$C0
.aff3	85 37		sta $37				sta 	gxzTemp0+1
.aff5	a9 08		lda #$08			lda 	#8 							; size 8x8
.aff7	a2 ff		ldx #$ff			ldx 	#GXGetGraphicDataFont & $FF ; XY = Graphic Data retrieval routine
.aff9	a0 af		ldy #$af			ldy 	#GXGetGraphicDataFont >> 8
.affb	20 17 af	jsr $af17			jsr 	GXDrawGraphicElement
.affe	60		rts				rts
.afff					GXGetGraphicDataFont:
.afff	8a		txa				txa 								; X->Y
.b000	a8		tay				tay
.b001	a6 01		ldx $01				ldx 	1 							; preserve old value
.b003	a9 01		lda #$01			lda 	#1 							; access page 1 (font memory)
.b005	85 01		sta $01				sta 	1
.b007	b1 36		lda ($36),y			lda 	(gxzTemp0),y 				; read the font element.
.b009	86 01		stx $01				stx 	1 							; put old value back.
.b00b	a2 00		ldx #$00			ldx 	#0 							; do 8 times
.b00d					_GXExpand:
.b00d	9e 7b 05	stz $057b,x			stz 	gxPixelBuffer,x 			; zero in pixel buffer
.b010	0a		asl a				asl 	a 							; shift bit 7 into C
.b011	90 08		bcc $b01b			bcc 	_GXNoPixel
.b013	48		pha				pha 								; if set, set pixel buffer to current colour.
.b014	ad db 05	lda $05db			lda 	gxColour
.b017	9d 7b 05	sta $057b,x			sta 	gxPixelBuffer,x
.b01a	68		pla				pla
.b01b					_GXNoPixel:
.b01b	e8		inx				inx 								; do the whole byte.
.b01c	e0 08		cpx #$08			cpx 	#8
.b01e	d0 ed		bne $b00d			bne 	_GXExpand
.b020	60		rts				rts
.b021					GXSpriteHandler:
.b021	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b023	4d da 05	eor $05da			eor 	gxMode
.b026	8d 77 06	sta $0677			sta 	gxUseMode
.b029	a6 36		ldx $36				ldx 	gxzTemp0 					; sprite #
.b02b	da		phx				phx
.b02c	20 bc b1	jsr $b1bc			jsr 	GXOpenBitmap 				; can access sprite information
.b02f	68		pla				pla
.b030	20 9d b2	jsr $b29d			jsr 	GXFindSprite 				; get the sprite address
.b033	08		php				php
.b034	20 c4 b1	jsr $b1c4			jsr 	GXCloseBitmap
.b037	28		plp				plp
.b038	b0 0a		bcs $b044			bcs		_GXSHExit 					; exit if find failed.
.b03a	ad 78 06	lda $0678			lda 	GXSizePixels 				; return size
.b03d	a2 45		ldx #$45			ldx 	#GXSpriteAcquire & $FF
.b03f	a0 b0		ldy #$b0			ldy 	#GXSpriteAcquire >> 8
.b041	20 17 af	jsr $af17			jsr 	GXDrawGraphicElement
.b044					_GXSHExit:
.b044	60		rts				rts
.b045					GXSpriteAcquire:
.b045	ad d8 05	lda $05d8			lda 	GXSpritePage				; point to base page
.b048	85 0b		sta $0b				sta 	GXEditSlot
.b04a	86 36		stx $36				stx 	zTemp0 						; row number x 1,2,3,4
.b04c	a9 00		lda #$00			lda 	#0
.b04e	ae 79 06	ldx $0679			ldx 	GXSizeBits
.b051					_GXTimesRowNumber:
.b051	18		clc				clc
.b052	65 36		adc $36				adc 	zTemp0
.b054	ca		dex				dex
.b055	10 fa		bpl $b051			bpl 	_GXTimesRowNumber
.b057	64 37		stz $37				stz 	gxzTemp0+1
.b059	0a		asl a				asl 	a 							; row x 2,4,6,8
.b05a	26 37		rol $37				rol 	gxzTemp0+1
.b05c	0a		asl a				asl 	a 							; row x 4,8,12,16
.b05d	26 37		rol $37				rol 	gxzTemp0+1
.b05f	0a		asl a				asl 	a 							; row x 8,16,24,32
.b060	26 37		rol $37				rol 	gxzTemp0+1
.b062	85 36		sta $36				sta 	gxzTemp0
.b064	18		clc				clc 								; add base address.
.b065	a5 36		lda $36				lda 	gxzTemp0
.b067	6d 7b 06	adc $067b			adc 	GXSpriteOffset
.b06a	85 36		sta $36				sta 	gxzTemp0
.b06c	a5 37		lda $37				lda 	gxzTemp0+1
.b06e	6d 7c 06	adc $067c			adc 	GXSpriteOffset+1
.b071					_GXSAFindPage:
.b071	c9 20		cmp #$20			cmp 	#$20 						; on this page
.b073	90 06		bcc $b07b			bcc 	_GXSAFoundPage
.b075	e9 20		sbc #$20			sbc 	#$20 						; forward one page
.b077	e6 0b		inc $0b				inc 	GXEditSlot
.b079	80 f6		bra $b071			bra 	_GXSAFindPage
.b07b					_GXSAFoundPage:
.b07b	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; physical address of page.
.b07d	85 37		sta $37				sta 	gxzTemp0+1 					; gxzTemp0 now points to the page
.b07f	a0 00		ldy #$00			ldy 	#0
.b081					_GXSACopyLoop:
.b081	b1 36		lda ($36),y			lda 	(gxzTemp0),y
.b083	99 7b 05	sta $057b,y			sta 	gxPixelBuffer,y
.b086	c8		iny				iny
.b087	cc 78 06	cpy $0678			cpy 	GXSizePixels
.b08a	d0 f5		bne $b081			bne 	_GXSACopyLoop
.b08c	60		rts				rts
.b08d					GXSelect:
.b08d	ad d5 05	lda $05d5			lda 	gxSpritesOn
.b090	f0 22		beq $b0b4			beq 	_GXSFail
.b092	a5 36		lda $36				lda 	gxzTemp0 					; illegal sprite #
.b094	c9 40		cmp #$40			cmp 	#64
.b096	b0 1c		bcs $b0b4			bcs 	_GXSFail
.b098	8d e0 05	sta $05e0			sta 	GSCurrentSpriteID
.b09b	a4 37		ldy $37				ldy 	gxzTemp0+1 					; control value.
.b09d	a9 00		lda #$00			lda  	#0 							; multiply sprite # x 8 => A
.b09f	06 36		asl $36				asl 	gxzTemp0
.b0a1	06 36		asl $36				asl 	gxzTemp0
.b0a3	06 36		asl $36				asl 	gxzTemp0
.b0a5	2a		rol a				rol 	a
.b0a6	69 d9		adc #$d9			adc 	#$D9 						; sprite area
.b0a8	8d e2 05	sta $05e2			sta 	GSCurrentSpriteAddr+1 		; address to GSCurrentSprite and gxzTemp
.b0ab	85 37		sta $37				sta 	gxzTemp0+1
.b0ad	a5 36		lda $36				lda 	gxzTemp0
.b0af	8d e1 05	sta $05e1			sta 	GSCurrentSpriteAddr
.b0b2	18		clc				clc
.b0b3	60		rts				rts
.b0b4					_GXSFail:
.b0b4	38		sec				sec
.b0b5	60		rts				rts
.b0b6					GXSelectImage:
.b0b6	ad d5 05	lda $05d5			lda 	gxSpritesOn
.b0b9	f0 74		beq $b12f			beq 	_GXSIFail
.b0bb	ad e2 05	lda $05e2			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b0be	f0 6f		beq $b12f			beq 	_GXSIFail 					; (checking the MSB)
.b0c0	64 01		stz $01				stz 	1
.b0c2	a5 37		lda $37				lda 	gxzTemp0+1 					; push show/hide on the stack.
.b0c4	d0 6b		bne $b131			bne 	_GXSIHide
.b0c6	a5 36		lda $36				lda 	gxzTemp0 					; sprite image
.b0c8	48		pha				pha
.b0c9	20 bc b1	jsr $b1bc			jsr 	GXOpenBitmap
.b0cc	68		pla				pla
.b0cd	20 9d b2	jsr $b29d			jsr 	GXFindSprite
.b0d0	b0 5a		bcs $b12c			bcs 	_GXSICloseFail 				; no image
.b0d2	a0 01		ldy #$01			ldy 	#1
.b0d4	ad e1 05	lda $05e1			lda 	GSCurrentSpriteAddr
.b0d7	85 36		sta $36				sta 	gxzTemp0
.b0d9	ad e2 05	lda $05e2			lda 	GSCurrentSpriteAddr+1
.b0dc	85 37		sta $37				sta 	gxzTemp0+1
.b0de	ad 7b 06	lda $067b			lda 	GXSpriteOffset
.b0e1	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b0e3	18		clc				clc
.b0e4	ad 7c 06	lda $067c			lda 	GXSpriteOffset+1
.b0e7	6d e3 05	adc $05e3			adc 	GXSpriteOffsetBase
.b0ea	c8		iny				iny
.b0eb	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b0ed	ad e4 05	lda $05e4			lda 	GXSpriteOffsetBase+1
.b0f0	69 00		adc #$00			adc 	#0
.b0f2	c8		iny				iny
.b0f3	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b0f5	ad 79 06	lda $0679			lda 	GXSizeBits 					; get raw size
.b0f8	49 03		eor #$03			eor 	#3 							; make it right (00=32 etc.)
.b0fa	2a		rol a				rol 	a 							; x 2
.b0fb	0a		asl a				asl 	a 							; x 4
.b0fc	0a		asl a				asl 	a 							; x 8
.b0fd	0a		asl a				asl 	a 							; x 16
.b0fe	0d 7a 06	ora $067a			ora 	GXSpriteLUT 				; Or with LUT
.b101	0a		asl a				asl 	a 							; 1 shift
.b102	09 01		ora #$01			ora 	#1 							; enable sprite.
.b104	92 36		sta ($36)			sta 	(gxzTemp0) 					; and write back
.b106	20 c4 b1	jsr $b1c4			jsr 	GXCloseBitmap
.b109	ae e0 05	ldx $05e0			ldx 	GSCurrentSpriteID 			; point to sprite entries.
.b10c	bd 25 06	lda $0625,x			lda 	GXSpriteHigh,x 				; clear upper two bits of size
.b10f	29 3f		and #$3f			and 	#$3F
.b111	9d 25 06	sta $0625,x			sta 	GXSpriteHigh,x
.b114	ad 79 06	lda $0679			lda 	GXSizeBits 					; get bit size
.b117	6a		ror a				ror 	a 							; shift into bits 6/7
.b118	6a		ror a				ror 	a
.b119	6a		ror a				ror 	a
.b11a	29 c0		and #$c0			and 	#$C0
.b11c	1d 25 06	ora $0625,x			ora 	GXSpriteHigh,x 				; put in  upper 2 bits of sprite data
.b11f	9d 25 06	sta $0625,x			sta 	GXSpriteHigh,x
.b122	bd e5 05	lda $05e5,x			lda 	GXSpriteLow,x 				; clear hidden flag.
.b125	29 7f		and #$7f			and 	#$7F
.b127	9d e5 05	sta $05e5,x			sta 	GXSpriteLow,x
.b12a	18		clc				clc
.b12b	60		rts				rts
.b12c					_GXSICloseFail:
.b12c	20 c4 b1	jsr $b1c4			jsr 	GXCloseBitmap
.b12f					_GXSIFail:
.b12f	38		sec				sec
.b130	60		rts				rts
.b131					_GXSIHide:
.b131	ad e1 05	lda $05e1			lda 	GSCurrentSpriteAddr  		; get Sprite h/w address and write there
.b134	85 36		sta $36				sta 	gxzTemp0
.b136	ad e2 05	lda $05e2			lda 	GSCurrentSpriteAddr+1
.b139	85 37		sta $37				sta 	gxzTemp0+1
.b13b	a9 00		lda #$00			lda 	#0
.b13d	92 36		sta ($36)			sta 	(gxzTemp0)
.b13f	ae e0 05	ldx $05e0			ldx 	GSCurrentSpriteID 			; get sprite ID
.b142	bd e5 05	lda $05e5,x			lda 	GXSpriteLow,x 				; set the hidden bit.
.b145	09 80		ora #$80			ora 	#$80
.b147	9d e5 05	sta $05e5,x			sta 	GXSpriteLow,x
.b14a	18		clc				clc
.b14b	60		rts				rts
.b14c					GXMoveSprite:
.b14c	ad d5 05	lda $05d5			lda 	gxSpritesOn
.b14f	f0 65		beq $b1b6			beq 	_GXSIFail
.b151	ad e2 05	lda $05e2			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b154	f0 60		beq $b1b6			beq 	_GXSIFail
.b156	85 37		sta $37				sta 	gxzTemp0+1
.b158	a0 04		ldy #$04			ldy 	#4
.b15a	ad e1 05	lda $05e1			lda 	GSCurrentSpriteAddr
.b15d	85 36		sta $36				sta 	gxzTemp0
.b15f	ae e0 05	ldx $05e0			ldx 	GSCurrentSpriteID 			; get the size from the upper two bits
.b162	bd 25 06	lda $0625,x			lda 	GXSpriteHigh,x
.b165	2a		rol a				rol 	a	 						; into bits 0,1.
.b166	2a		rol a				rol 	a
.b167	2a		rol a				rol 	a
.b168	29 03		and #$03			and 	#3
.b16a	aa		tax				tax
.b16b	bd b8 b1	lda $b1b8,x			lda 	_GXMSOffset,x 				; get 32-SpriteSize/2
.b16e	48		pha				pha
.b16f	18		clc				clc
.b170	6d cd 05	adc $05cd			adc 	gxX0						; copy position.
.b173	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b175	c8		iny				iny
.b176	ad ce 05	lda $05ce			lda 	gxX0+1
.b179	69 00		adc #$00			adc 	#0
.b17b	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b17d	c8		iny				iny
.b17e	68		pla				pla
.b17f	18		clc				clc
.b180	6d cf 05	adc $05cf			adc 	gxY0
.b183	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b185	a9 00		lda #$00			lda 	#0
.b187	69 00		adc #$00			adc 	#0
.b189	c8		iny				iny
.b18a	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b18c	4e ce 05	lsr $05ce			lsr 	gxX0+1 						; divide X by 4
.b18f	6e cd 05	ror $05cd			ror 	gxX0
.b192	4e cd 05	lsr $05cd			lsr 	gxX0
.b195	4e cf 05	lsr $05cf			lsr 	gxY0 						; divide Y by 4
.b198	4e cf 05	lsr $05cf			lsr 	gxY0
.b19b	ae e0 05	ldx $05e0			ldx 	GSCurrentSpriteID 			; copy X/4 and Y/4 into the status bytes
.b19e	bd e5 05	lda $05e5,x			lda 	GXSpriteLow,x
.b1a1	29 80		and #$80			and 	#$80
.b1a3	0d cd 05	ora $05cd			ora 	gxX0
.b1a6	9d e5 05	sta $05e5,x			sta 	GXSpriteLow,x
.b1a9	bd 25 06	lda $0625,x			lda 	GXSpriteHigh,x
.b1ac	29 c0		and #$c0			and 	#$C0
.b1ae	0d cf 05	ora $05cf			ora 	gxY0
.b1b1	9d 25 06	sta $0625,x			sta 	GXSpriteHigh,x
.b1b4	18		clc				clc
.b1b5	60		rts				rts
.b1b6					_GXSIFail:
.b1b6	38		sec				sec
.b1b7	60		rts				rts
.b1b8					_GXMSOffset:
>b1b8	1c						.byte 	32-8/2
>b1b9	18						.byte 	32-16/2
>b1ba	14						.byte 	32-24/2
>b1bb	10						.byte 	32-32/2
.b1bc					GXOpenBitmap:
.b1bc	78		sei				sei 								; no interrupts here
.b1bd	a5 0b		lda $0b				lda 	GXEditSlot 					; Save the original LUT slot value
.b1bf	8d de 05	sta $05de			sta 	gxOriginalLUTValue
.b1c2	58		cli				cli
.b1c3	60		rts				rts
.b1c4					GXCloseBitmap:
.b1c4	78		sei				sei
.b1c5	ad de 05	lda $05de			lda 	gxOriginalLUTValue 			; restore LUT slot value
.b1c8	85 0b		sta $0b				sta 	GXEditSlot
.b1ca	58		cli				cli
.b1cb	60		rts				rts
.b1cc					GXPositionCalc:
.b1cc	a5 36		lda $36				lda 	gxzTemp0 					; save temp memory slot
.b1ce	48		pha				pha
.b1cf	ad cf 05	lda $05cf			lda 	GXY0 						; gxzScreen = Y0
.b1d2	85 3c		sta $3c				sta 	gxzScreen
.b1d4	64 3d		stz $3d				stz 	gxzScreen+1
.b1d6	06 3c		asl $3c				asl 	gxzScreen 						; gxzScreen = Y0 * 4
.b1d8	26 3d		rol $3d				rol 	gxzScreen+1
.b1da	06 3c		asl $3c				asl 	gxzScreen
.b1dc	26 3d		rol $3d				rol 	gxzScreen+1
.b1de	18		clc				clc 								; gxzScreen = Y0 * 5, as it's still in A
.b1df	65 3c		adc $3c				adc 	gxzScreen
.b1e1	85 3c		sta $3c				sta 	gxzScreen
.b1e3	90 02		bcc $b1e7			bcc 	_GXPCNoCarry
.b1e5	e6 3d		inc $3d				inc 	gxzScreen+1
.b1e7					_GXPCNoCarry:
.b1e7	06 3c		asl $3c				asl 	gxzScreen 						; now Y0 * 10. Needs to be multiplied by another
.b1e9	26 3d		rol $3d				rol 	gxzScreen+1 					; 32. At this point the MSB contains the offset
.b1eb	a5 3d		lda $3d				lda	 	gxzScreen+1 					; so save this in zTemp0 and zero it.
.b1ed	85 36		sta $36				sta 	gxzTemp0
.b1ef	64 3d		stz $3d				stz 	gxzScreen+1
.b1f1	a9 05		lda #$05			lda 	#5 							; now multiply by 32, this puts this in the range 0..8191
.b1f3					_GXPCMultiply32:
.b1f3	06 3c		asl $3c				asl 	gxzScreen
.b1f5	26 3d		rol $3d				rol 	gxzScreen+1
.b1f7	3a		dec a				dec 	a
.b1f8	d0 f9		bne $b1f3			bne 	_GXPCMultiply32
.b1fa	18		clc				clc
.b1fb	ad cd 05	lda $05cd			lda 	GXX0 						; add X to this value, put the result in gsOffset, gxzScreen has to be on a page boundary
.b1fe	65 3c		adc $3c				adc 	gxzScreen
.b200	8d df 05	sta $05df			sta 	gsOffset
.b203	ad ce 05	lda $05ce			lda 	GXX0+1
.b206	65 3d		adc $3d				adc 	gxzScreen+1
.b208	c9 20		cmp #$20			cmp 	#$20 						; has it overflowed into the next one ?
.b20a	90 04		bcc $b210			bcc 	_GXPCNoOverflow
.b20c	29 1f		and #$1f			and 	#$1F 						; fix it up
.b20e	e6 36		inc $36				inc 	gxzTemp0 					; add 1 to the page number
.b210					_GXPCNoOverflow:
.b210	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; make it the address mapped in.
.b212	85 3d		sta $3d				sta 	gxzScreen+1
.b214	64 3c		stz $3c				stz 	gxzScreen
.b216	18		clc				clc
.b217	a5 36		lda $36				lda 	gxzTemp0 					; get the page number
.b219	6d d7 05	adc $05d7			adc 	gxBasePage 					; by adding the base page
.b21c	85 0b		sta $0b				sta 	GXEditSlot 				; and map it into memory.
.b21e	68		pla				pla
.b21f	85 36		sta $36				sta 	gxzTemp0
.b221	60		rts				rts
.b222					GXMovePositionDown:
.b222	18		clc				clc 								; add 320 to offset/temp+1
.b223	ad df 05	lda $05df			lda 	gsOffset
.b226	69 40		adc #$40			adc 	#64
.b228	8d df 05	sta $05df			sta 	gsOffset
.b22b	a5 3d		lda $3d				lda 	gxzScreen+1
.b22d	69 01		adc #$01			adc 	#1
.b22f	85 3d		sta $3d				sta 	gxzScreen+1
.b231	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page
.b233	90 07		bcc $b23c			bcc 	_GXMPDExit
.b235	38		sec				sec  								; next page
.b236	e9 20		sbc #$20			sbc 	#$20
.b238	85 3d		sta $3d				sta 	gxzScreen+1
.b23a	e6 0b		inc $0b				inc 	GXEditSlot
.b23c					_GXMPDExit:
.b23c	60		rts				rts
.b23d					GXCollide:
.b23d	a5 36		lda $36				lda 	gxzTemp0 					; check if sprite numbers are legal.
.b23f	aa		tax				tax
.b240	05 37		ora $37				ora 	gxzTemp0+1
.b242	29 c0		and #$c0			and 	#$C0
.b244	38		sec				sec
.b245	d0 53		bne $b29a			bne 	_GXCollideFail 				; if either >= 64, fail.
.b247	a4 37		ldy $37				ldy 	gxzTemp0+1 					; at this point X is 1st sprite and Y is 2nd sprite.
.b249	b9 e5 05	lda $05e5,y			lda 	GXSpriteLow,y 				; check if either hidden bit is set
.b24c	1d e5 05	ora $05e5,x			ora 	GXSpriteLow,x
.b24f	30 48		bmi $b299			bmi 	_GXOkayFail 				; if either hidden, then they cannot collide.
.b251	18		clc				clc 								; need to calculate sum of sizes.
.b252	b9 25 06	lda $0625,y			lda 	GXSpriteHigh,y
.b255	7d 25 06	adc $0625,x			adc 	GXSpriteHigh,x 				; at this point, CS, Bit 6 and 7 contain that sum.
.b258	29 c0		and #$c0			and 	#$C0 					 	; mask off
.b25a	6a		ror a				ror 	a 							; 5/6/7
.b25b	4a		lsr a				lsr 	a 							; 4/5/6
.b25c	4a		lsr a				lsr 	a 							; 3/4/5
.b25d	4a		lsr a				lsr 	a 							; 2/3/4
.b25e	18		clc				clc
.b25f	69 08		adc #$08			adc 	#$08
.b261	4a		lsr a				lsr 	a 							; adjust because all coordinates are divided by 4 to store.
.b262	4a		lsr a				lsr 	a
.b263	85 38		sta $38				sta 	gxzTemp1 					; so the difference between the centres has to be less than this.
.b265	b9 25 06	lda $0625,y			lda 	GXSpriteHigh,y 				; calculate y1-y0
.b268	29 3f		and #$3f			and 	#$3F
.b26a	85 39		sta $39				sta 	gxzTemp1+1
.b26c	38		sec				sec
.b26d	bd 25 06	lda $0625,x			lda 	GXSpriteHigh,x
.b270	29 3f		and #$3f			and 	#$3F
.b272	e5 39		sbc $39				sbc 	gxzTemp1+1
.b274	b0 03		bcs $b279			bcs 	_GXCAbs1 					; calculate |y1-y0|
.b276	49 ff		eor #$ff			eor 	#$FF
.b278	1a		inc a				inc 	a
.b279					_GXCAbs1:
.b279	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b27b	b0 1c		bcs $b299			bcs 	_GXOkayFail
.b27d	85 39		sta $39				sta 	gxzTemp1+1 					; save |y1-y0|
.b27f	38		sec				sec 								; calculate |x1-x0|
.b280	b9 e5 05	lda $05e5,y			lda 	GXSpriteLow,y
.b283	fd e5 05	sbc $05e5,x			sbc 	GXSpriteLow,x
.b286	b0 03		bcs $b28b			bcs 	_GXCAbs2
.b288	49 ff		eor #$ff			eor 	#$FF
.b28a	1a		inc a				inc 	a
.b28b					_GXCAbs2:
.b28b	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b28d	b0 0a		bcs $b299			bcs 	_GXOkayFail
.b28f	c5 39		cmp $39				cmp 	gxzTemp1+1 					; is it less than the previous one.
.b291	90 02		bcc $b295			bcc 	_GXCHaveLowest
.b293	a5 39		lda $39				lda 	gxzTemp1+1 					; if not, that's the smallest difference.
.b295					_GXCHaveLowest:
.b295	0a		asl a				asl 	a 							; scale to allow for >> 2
.b296	0a		asl a				asl 	a
.b297	18		clc				clc
.b298	60		rts				rts
.b299					_GXOkayFail:
.b299	18		clc				clc
.b29a					_GXCollideFail:
.b29a	a9 ff		lda #$ff			lda 	#$FF
.b29c	60		rts				rts
.b29d					GXFindSprite:
.b29d	aa		tax				tax
.b29e	ad d8 05	lda $05d8			lda 	GXSpritePage 				; access the base page of the sprite
.b2a1	85 0b		sta $0b				sta 	GXEditSlot
.b2a3	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; check a valid sprite
.b2a6	1d 00 60	ora $6000,x			ora 	GXMappingAddress,x
.b2a9	f0 33		beq $b2de			beq 	_GXFSFail
.b2ab	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; MSB
.b2ae	8d 7c 06	sta $067c			sta 	GXSpriteOffset+1
.b2b1	bd 00 60	lda $6000,x			lda 	GXMappingAddress,x 			; LSB
.b2b4	48		pha				pha 								; save twice
.b2b5	48		pha				pha
.b2b6	29 03		and #$03			and 	#3 							; get sprite size
.b2b8	8d 79 06	sta $0679			sta 	GXSizeBits 					; save raw (0-3)
.b2bb	aa		tax				tax
.b2bc	bd e0 b2	lda $b2e0,x			lda 	_GXFXSSTTable,x 			; read sprite size
.b2bf	8d 78 06	sta $0678			sta 	GXSizePixels 					; save (8/16/24/32)
.b2c2	68		pla				pla 								; get LUT
.b2c3	4a		lsr a				lsr		a
.b2c4	4a		lsr a				lsr		a
.b2c5	29 03		and #$03			and 	#3
.b2c7	8d 7a 06	sta $067a			sta 	GXSpriteLUT
.b2ca	68		pla				pla 								; address, neeeds to be x 4
.b2cb	29 f0		and #$f0			and 	#$F0
.b2cd	8d 7b 06	sta $067b			sta 	GXSpriteOffset
.b2d0	0e 7b 06	asl $067b			asl 	GXSpriteOffset
.b2d3	2e 7c 06	rol $067c			rol 	GXSpriteOffset+1
.b2d6	0e 7b 06	asl $067b			asl 	GXSpriteOffset
.b2d9	2e 7c 06	rol $067c			rol 	GXSpriteOffset+1
.b2dc	18		clc				clc
.b2dd	60		rts				rts
.b2de					_GXFSFail:
.b2de	38		sec				sec
.b2df	60		rts				rts
.b2e0					_GXFXSSTTable:
>b2e0	08 10 18 20					.byte 	8,16,24,32
.0678					GXSizePixels:
>0678							.fill 	1
.0679					GXSizeBits:
>0679							.fill 	1
.067a					GXSpriteLUT:
>067a							.fill 	1
.067b					GXSpriteOffset:
>067b							.fill 	2
.b2e4					GXSortXY:
.b2e4	20 02 b3	jsr $b302			jsr 	GXSortY 					; will be sorted on Y now
.b2e7	ad cd 05	lda $05cd			lda 	gxX0 						; compare X0 v X1
.b2ea	cd d1 05	cmp $05d1			cmp 	gxX1
.b2ed	ad ce 05	lda $05ce			lda 	gXX0+1
.b2f0	ed d2 05	sbc $05d2			sbc 	gXX1+1
.b2f3	90 0c		bcc $b301			bcc 	_GXSXYExit 					; X0 < X1 exit
.b2f5	a2 00		ldx #$00			ldx 	#0 							; swap them over
.b2f7	a0 04		ldy #$04			ldy 	#4
.b2f9	20 16 b3	jsr $b316			jsr 	GXSwapXY
.b2fc	e8		inx				inx
.b2fd	c8		iny				iny
.b2fe	20 16 b3	jsr $b316			jsr 	GXSwapXY
.b301					_GXSXYExit:
.b301	60		rts				rts
.b302					GXSortY:
.b302	ad cf 05	lda $05cf			lda 	gxY0 						; if Y0 >= Y1
.b305	cd d3 05	cmp $05d3			cmp 	gxY1
.b308	90 0b		bcc $b315			bcc 	_GXSYSorted
.b30a	a2 03		ldx #$03			ldx 	#3 							; swap 3-0
.b30c	a0 07		ldy #$07			ldy 	#7 							; with 4-7
.b30e					_GXSwap1:
.b30e	20 16 b3	jsr $b316			jsr 	GXSwapXY
.b311	88		dey				dey
.b312	ca		dex				dex
.b313	10 f9		bpl $b30e			bpl 	_GXSwap1
.b315					_GXSYSorted:
.b315	60		rts				rts
.b316					GXSwapXY:
.b316	bd cd 05	lda $05cd,x			lda 	gxX0,x
.b319	48		pha				pha
.b31a	b9 cd 05	lda $05cd,y			lda 	gxX0,y
.b31d	9d cd 05	sta $05cd,x			sta 	gxX0,x
.b320	68		pla				pla
.b321	99 cd 05	sta $05cd,y			sta 	gxX0,y
.b324	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_tokeniser.module

=1					tokeniserIntegrated=1
.b9f0					KeywordSet0:
>b9f0	00 65					.text	0,$65,""               ; $80 !0:EOF
>b9f2	00 58					.text	0,$58,""               ; $81 !1:SH1
>b9f4	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b9f6	04 fe 41 42 53 28			.text	4,$fe,"ABS("           ; $83 ABS(
>b9fc	06 93 41 4c 4c 4f 43 28			.text	6,$93,"ALLOC("         ; $84 ALLOC(
>ba04	04 ff 41 53 43 28			.text	4,$ff,"ASC("           ; $85 ASC(
>ba0a	05 29 43 48 52 24 28			.text	5,$29,"CHR$("          ; $86 CHR$(
>ba11	06 aa 45 56 45 4e 54 28			.text	6,$aa,"EVENT("         ; $87 EVENT(
>ba19	05 6b 46 41 4c 53 45			.text	5,$6b,"FALSE"          ; $88 FALSE
>ba20	05 44 46 52 41 43 28			.text	5,$44,"FRAC("          ; $89 FRAC(
>ba27	04 0d 48 49 54 28			.text	4,$0d,"HIT("           ; $8a HIT(
>ba2d	04 13 49 4e 54 28			.text	4,$13,"INT("           ; $8b INT(
>ba33	06 a7 49 53 56 41 4c 28			.text	6,$a7,"ISVAL("         ; $8c ISVAL(
>ba3b	05 5c 4a 4f 59 42 28			.text	5,$5c,"JOYB("          ; $8d JOYB(
>ba42	05 72 4a 4f 59 58 28			.text	5,$72,"JOYX("          ; $8e JOYX(
>ba49	05 73 4a 4f 59 59 28			.text	5,$73,"JOYY("          ; $8f JOYY(
>ba50	06 77 4c 45 46 54 24 28			.text	6,$77,"LEFT$("         ; $90 LEFT$(
>ba58	04 07 4c 45 4e 28			.text	4,$07,"LEN("           ; $91 LEN(
>ba5e	04 0e 4d 41 58 28			.text	4,$0e,"MAX("           ; $92 MAX(
>ba64	05 26 4d 49 44 24 28			.text	5,$26,"MID$("          ; $93 MID$(
>ba6b	04 0c 4d 49 4e 28			.text	4,$0c,"MIN("           ; $94 MIN(
>ba71	04 19 4e 4f 54 28			.text	4,$19,"NOT("           ; $95 NOT(
>ba77	08 3c 50 4c 41 59 49 4e			.text	8,$3c,"PLAYING("       ; $96 PLAYING(
>ba7f	47 28
>ba81	07 e9 52 41 4e 44 4f 4d			.text	7,$e9,"RANDOM("        ; $97 RANDOM(
>ba89	28
>ba8a	07 ca 52 49 47 48 54 24			.text	7,$ca,"RIGHT$("        ; $98 RIGHT$(
>ba92	28
>ba93	04 0c 52 4e 44 28			.text	4,$0c,"RND("           ; $99 RND(
>ba99	04 10 53 47 4e 28			.text	4,$10,"SGN("           ; $9a SGN(
>ba9f	04 0e 53 50 43 28			.text	4,$0e,"SPC("           ; $9b SPC(
>baa5	05 45 53 54 52 24 28			.text	5,$45,"STR$("          ; $9c STR$(
>baac	06 a9 54 49 4d 45 52 28			.text	6,$a9,"TIMER("         ; $9d TIMER(
>bab4	04 40 54 52 55 45			.text	4,$40,"TRUE"           ; $9e TRUE
>baba	04 0b 56 41 4c 28			.text	4,$0b,"VAL("           ; $9f VAL(
>bac0	03 e7 46 4f 52				.text	3,$e7,"FOR"            ; $a0 FOR
>bac5	02 8f 49 46				.text	2,$8f,"IF"             ; $a1 IF
>bac9	04 34 50 52 4f 43			.text	4,$34,"PROC"           ; $a2 PROC
>bacf	06 c1 52 45 50 45 41 54			.text	6,$c1,"REPEAT"         ; $a3 REPEAT
>bad7	05 79 57 48 49 4c 45			.text	5,$79,"WHILE"          ; $a4 WHILE
>bade	05 66 45 4e 44 49 46			.text	5,$66,"ENDIF"          ; $a5 ENDIF
>bae5	07 0b 45 4e 44 50 52 4f			.text	7,$0b,"ENDPROC"        ; $a6 ENDPROC
>baed	43
>baee	04 3f 4e 45 58 54			.text	4,$3f,"NEXT"           ; $a7 NEXT
>baf4	04 2f 54 48 45 4e			.text	4,$2f,"THEN"           ; $a8 THEN
>bafa	05 8c 55 4e 54 49 4c			.text	5,$8c,"UNTIL"          ; $a9 UNTIL
>bb01	04 2e 57 45 4e 44			.text	4,$2e,"WEND"           ; $aa WEND
>bb07	02 9b 42 59				.text	2,$9b,"BY"             ; $ab BY
>bb0b	04 1c 43 41 4c 4c			.text	4,$1c,"CALL"           ; $ac CALL
>bb11	06 b2 43 49 52 43 4c 45			.text	6,$b2,"CIRCLE"         ; $ad CIRCLE
>bb19	05 67 43 4c 45 41 52			.text	5,$67,"CLEAR"          ; $ae CLEAR
>bb20	03 e2 43 4c 53				.text	3,$e2,"CLS"            ; $af CLS
>bb25	05 7f 43 4f 4c 4f 52			.text	5,$7f,"COLOR"          ; $b0 COLOR
>bb2c	06 d4 43 4f 4c 4f 55 52			.text	6,$d4,"COLOUR"         ; $b1 COLOUR
>bb34	04 1a 44 41 54 41			.text	4,$1a,"DATA"           ; $b2 DATA
>bb3a	03 da 44 49 4d				.text	3,$da,"DIM"            ; $b3 DIM
>bb3f	06 db 44 4f 57 4e 54 4f			.text	6,$db,"DOWNTO"         ; $b4 DOWNTO
>bb47	04 29 45 4c 53 45			.text	4,$29,"ELSE"           ; $b5 ELSE
>bb4d	04 34 46 52 4f 4d			.text	4,$34,"FROM"           ; $b6 FROM
>bb53	03 e5 47 46 58				.text	3,$e5,"GFX"            ; $b7 GFX
>bb58	05 80 47 4f 53 55 42			.text	5,$80,"GOSUB"          ; $b8 GOSUB
>bb5f	04 39 47 4f 54 4f			.text	4,$39,"GOTO"           ; $b9 GOTO
>bb65	04 24 48 45 52 45			.text	4,$24,"HERE"           ; $ba HERE
>bb6b	05 63 49 4d 41 47 45			.text	5,$63,"IMAGE"          ; $bb IMAGE
>bb72	05 90 49 4e 50 55 54			.text	5,$90,"INPUT"          ; $bc INPUT
>bb79	03 e5 4c 45 54				.text	3,$e5,"LET"            ; $bd LET
>bb7e	04 28 4c 49 4e 45			.text	4,$28,"LINE"           ; $be LINE
>bb84	05 6b 4c 4f 43 41 4c			.text	5,$6b,"LOCAL"          ; $bf LOCAL
>bb8b	03 db 4f 46 46				.text	3,$db,"OFF"            ; $c0 OFF
>bb90	02 9d 4f 4e				.text	2,$9d,"ON"             ; $c1 ON
>bb94	07 20 4f 55 54 4c 49 4e			.text	7,$20,"OUTLINE"        ; $c2 OUTLINE
>bb9c	45
>bb9d	07 0f 50 41 4c 45 54 54			.text	7,$0f,"PALETTE"        ; $c3 PALETTE
>bba5	45
>bba6	04 3f 50 4c 4f 54			.text	4,$3f,"PLOT"           ; $c4 PLOT
>bbac	05 8d 50 52 49 4e 54			.text	5,$8d,"PRINT"          ; $c5 PRINT
>bbb3	04 1c 52 45 41 44			.text	4,$1c,"READ"           ; $c6 READ
>bbb9	04 2e 52 45 43 54			.text	4,$2e,"RECT"           ; $c7 RECT
>bbbf	03 e4 52 45 4d				.text	3,$e4,"REM"            ; $c8 REM
>bbc4	06 e0 52 45 54 55 52 4e			.text	6,$e0,"RETURN"         ; $c9 RETURN
>bbcc	05 7b 53 4f 4c 49 44			.text	5,$7b,"SOLID"          ; $ca SOLID
>bbd3	05 89 53 4f 55 4e 44			.text	5,$89,"SOUND"          ; $cb SOUND
>bbda	06 d7 53 50 52 49 54 45			.text	6,$d7,"SPRITE"         ; $cc SPRITE
>bbe2	04 45 54 45 58 54			.text	4,$45,"TEXT"           ; $cd TEXT
>bbe8	02 a3 54 4f				.text	2,$a3,"TO"             ; $ce TO
>bbec	ff					.text	$FF
.bbed					KeywordSet1:
>bbed	00 65					.text	0,$65,""               ; $80 !0:EOF
>bbef	00 58					.text	0,$58,""               ; $81 !1:SH1
>bbf1	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bbf3	08 4c 41 53 53 45 4d 42			.text	8,$4c,"ASSEMBLE"       ; $83 ASSEMBLE
>bbfb	4c 45
>bbfd	06 d2 41 53 53 45 52 54			.text	6,$d2,"ASSERT"         ; $84 ASSERT
>bc05	06 bd 42 49 54 4d 41 50			.text	6,$bd,"BITMAP"         ; $85 BITMAP
>bc0d	03 d7 45 4e 44				.text	3,$d7,"END"            ; $86 END
>bc12	02 96 47 4f				.text	2,$96,"GO"             ; $87 GO
>bc16	04 3c 4c 49 53 54			.text	4,$3c,"LIST"           ; $88 LIST
>bc1c	04 20 4c 4f 41 44			.text	4,$20,"LOAD"           ; $89 LOAD
>bc22	03 ea 4e 45 57				.text	3,$ea,"NEW"            ; $8a NEW
>bc27	07 24 52 45 53 54 4f 52			.text	7,$24,"RESTORE"        ; $8b RESTORE
>bc2f	45
>bc30	03 f5 52 55 4e				.text	3,$f5,"RUN"            ; $8c RUN
>bc35	07 2a 53 50 52 49 54 45			.text	7,$2a,"SPRITES"        ; $8d SPRITES
>bc3d	53
>bc3e	04 46 53 54 4f 50			.text	4,$46,"STOP"           ; $8e STOP
>bc44	03 ee 57 48 4f				.text	3,$ee,"WHO"            ; $8f WHO
>bc49	ff					.text	$FF
.bc4a					KeywordSet2:
>bc4a	00 65					.text	0,$65,""               ; $80 !0:EOF
>bc4c	00 58					.text	0,$58,""               ; $81 !1:SH1
>bc4e	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bc50	03 c8 41 44 43				.text	3,$c8,"ADC"            ; $83 ADC
>bc55	03 d3 41 4e 44				.text	3,$d3,"AND"            ; $84 AND
>bc5a	03 e0 41 53 4c				.text	3,$e0,"ASL"            ; $85 ASL
>bc5f	03 c8 42 43 43				.text	3,$c8,"BCC"            ; $86 BCC
>bc64	03 d8 42 43 53				.text	3,$d8,"BCS"            ; $87 BCS
>bc69	03 d8 42 45 51				.text	3,$d8,"BEQ"            ; $88 BEQ
>bc6e	03 df 42 49 54				.text	3,$df,"BIT"            ; $89 BIT
>bc73	03 d8 42 4d 49				.text	3,$d8,"BMI"            ; $8a BMI
>bc78	03 d5 42 4e 45				.text	3,$d5,"BNE"            ; $8b BNE
>bc7d	03 de 42 50 4c				.text	3,$de,"BPL"            ; $8c BPL
>bc82	03 d5 42 52 41				.text	3,$d5,"BRA"            ; $8d BRA
>bc87	03 df 42 52 4b				.text	3,$df,"BRK"            ; $8e BRK
>bc8c	03 db 42 56 43				.text	3,$db,"BVC"            ; $8f BVC
>bc91	03 eb 42 56 53				.text	3,$eb,"BVS"            ; $90 BVS
>bc96	03 d2 43 4c 43				.text	3,$d2,"CLC"            ; $91 CLC
>bc9b	03 d3 43 4c 44				.text	3,$d3,"CLD"            ; $92 CLD
>bca0	03 d8 43 4c 49				.text	3,$d8,"CLI"            ; $93 CLI
>bca5	03 e5 43 4c 56				.text	3,$e5,"CLV"            ; $94 CLV
>bcaa	03 e0 43 4d 50				.text	3,$e0,"CMP"            ; $95 CMP
>bcaf	03 eb 43 50 58				.text	3,$eb,"CPX"            ; $96 CPX
>bcb4	03 ec 43 50 59				.text	3,$ec,"CPY"            ; $97 CPY
>bcb9	03 cc 44 45 43				.text	3,$cc,"DEC"            ; $98 DEC
>bcbe	03 e1 44 45 58				.text	3,$e1,"DEX"            ; $99 DEX
>bcc3	03 e2 44 45 59				.text	3,$e2,"DEY"            ; $9a DEY
>bcc8	03 e6 45 4f 52				.text	3,$e6,"EOR"            ; $9b EOR
>bccd	03 da 49 4e 43				.text	3,$da,"INC"            ; $9c INC
>bcd2	03 ef 49 4e 58				.text	3,$ef,"INX"            ; $9d INX
>bcd7	03 f0 49 4e 59				.text	3,$f0,"INY"            ; $9e INY
>bcdc	03 e7 4a 4d 50				.text	3,$e7,"JMP"            ; $9f JMP
>bce1	03 ef 4a 53 52				.text	3,$ef,"JSR"            ; $a0 JSR
>bce6	03 d1 4c 44 41				.text	3,$d1,"LDA"            ; $a1 LDA
>bceb	03 e8 4c 44 58				.text	3,$e8,"LDX"            ; $a2 LDX
>bcf0	03 e9 4c 44 59				.text	3,$e9,"LDY"            ; $a3 LDY
>bcf5	03 f1 4c 53 52				.text	3,$f1,"LSR"            ; $a4 LSR
>bcfa	03 ed 4e 4f 50				.text	3,$ed,"NOP"            ; $a5 NOP
>bcff	03 e2 4f 52 41				.text	3,$e2,"ORA"            ; $a6 ORA
>bd04	03 d9 50 48 41				.text	3,$d9,"PHA"            ; $a7 PHA
>bd09	03 e8 50 48 50				.text	3,$e8,"PHP"            ; $a8 PHP
>bd0e	03 f0 50 48 58				.text	3,$f0,"PHX"            ; $a9 PHX
>bd13	03 f1 50 48 59				.text	3,$f1,"PHY"            ; $aa PHY
>bd18	03 dd 50 4c 41				.text	3,$dd,"PLA"            ; $ab PLA
>bd1d	03 ec 50 4c 50				.text	3,$ec,"PLP"            ; $ac PLP
>bd22	03 f4 50 4c 58				.text	3,$f4,"PLX"            ; $ad PLX
>bd27	03 f5 50 4c 59				.text	3,$f5,"PLY"            ; $ae PLY
>bd2c	03 ed 52 4f 4c				.text	3,$ed,"ROL"            ; $af ROL
>bd31	03 f3 52 4f 52				.text	3,$f3,"ROR"            ; $b0 ROR
>bd36	03 ef 52 54 49				.text	3,$ef,"RTI"            ; $b1 RTI
>bd3b	03 f9 52 54 53				.text	3,$f9,"RTS"            ; $b2 RTS
>bd40	03 d8 53 42 43				.text	3,$d8,"SBC"            ; $b3 SBC
>bd45	03 db 53 45 43				.text	3,$db,"SEC"            ; $b4 SEC
>bd4a	03 dc 53 45 44				.text	3,$dc,"SED"            ; $b5 SED
>bd4f	03 e1 53 45 49				.text	3,$e1,"SEI"            ; $b6 SEI
>bd54	03 e8 53 54 41				.text	3,$e8,"STA"            ; $b7 STA
>bd59	03 f7 53 54 50				.text	3,$f7,"STP"            ; $b8 STP
>bd5e	03 ff 53 54 58				.text	3,$ff,"STX"            ; $b9 STX
>bd63	03 00 53 54 59				.text	3,$00,"STY"            ; $ba STY
>bd68	03 01 53 54 5a				.text	3,$01,"STZ"            ; $bb STZ
>bd6d	03 ed 54 41 58				.text	3,$ed,"TAX"            ; $bc TAX
>bd72	03 ee 54 41 59				.text	3,$ee,"TAY"            ; $bd TAY
>bd77	03 e8 54 52 42				.text	3,$e8,"TRB"            ; $be TRB
>bd7c	03 e9 54 53 42				.text	3,$e9,"TSB"            ; $bf TSB
>bd81	03 ff 54 53 58				.text	3,$ff,"TSX"            ; $c0 TSX
>bd86	03 ed 54 58 41				.text	3,$ed,"TXA"            ; $c1 TXA
>bd8b	03 ff 54 58 53				.text	3,$ff,"TXS"            ; $c2 TXS
>bd90	03 ee 54 59 41				.text	3,$ee,"TYA"            ; $c3 TYA
>bd95	ff					.text	$FF
.b325					ListConvertLine:
.b325	48		pha				pha 								; save indent on the stack
.b326	9c 1d 04	stz $041d			stz 	tbOffset
.b329	9c 2d 04	stz $042d			stz 	tokenBuffer
.b32c	9c 29 04	stz $0429			stz 	currentListColour
.b32f	a0 02		ldy #$02			ldy 	#2 							; convert line number to string
.b331	b1 30		lda ($30),y			lda 	(codePtr),y
.b333	aa		tax				tax
.b334	88		dey				dey
.b335	b1 30		lda ($30),y			lda 	(codePtr),y
.b337	20 13 93	jsr $9313			jsr 	LCLConvertInt16
.b33a	85 36		sta $36				sta 	zTemp0 						; copy number into buffer
.b33c	86 37		stx $37				stx 	zTemp0+1
.b33e	a9 89		lda #$89			lda 	#CLINumber+$80
.b340	20 be b4	jsr $b4be			jsr 	LCLWriteColour
.b343	a0 00		ldy #$00			ldy 	#0
.b345					_LCCopyNumber:
.b345	b1 36		lda ($36),y			lda 	(zTemp0),y
.b347	20 c7 b4	jsr $b4c7			jsr 	LCLWrite
.b34a	c8		iny				iny
.b34b	b1 36		lda ($36),y			lda 	(zTemp0),y
.b34d	d0 f6		bne $b345			bne 	_LCCopyNumber
.b34f	68		pla				pla 								; adjustment to indent
.b350	48		pha				pha 								; save on stack
.b351	10 0c		bpl $b35f			bpl 	_LCNoAdjust 				; don't adjust indent if +ve, do after.
.b353	18		clc				clc 								; add to list indent and make 0 if goes -ve.
.b354	6d 26 04	adc $0426			adc 	listIndent
.b357	8d 26 04	sta $0426			sta 	listIndent
.b35a	10 03		bpl $b35f			bpl 	_LCNoAdjust
.b35c	9c 26 04	stz $0426			stz 	listIndent
.b35f					_LCNoAdjust:
.b35f	18		clc				clc		 							; work out actual indent.
.b360	ad 26 04	lda $0426			lda 	listIndent
.b363	0a		asl a				asl 	a
.b364	69 06		adc #$06			adc 	#6
.b366	85 36		sta $36				sta 	zTemp0
.b368					_LCPadOut:
.b368	a9 20		lda #$20			lda 	#' '						; pad out to 6+indent characters
.b36a	20 c7 b4	jsr $b4c7			jsr 	LCLWrite
.b36d	ad 1d 04	lda $041d			lda 	tbOffset
.b370	c5 36		cmp $36				cmp 	zTemp0
.b372	d0 f4		bne $b368			bne 	_LCPadOut
.b374	a0 03		ldy #$03			ldy 	#3 							; start position.
.b376					_LCMainLoop:
.b376	a9 8a		lda #$8a			lda 	#CLIPunctuation+$80
.b378	20 be b4	jsr $b4be			jsr 	LCLWriteColour
.b37b	b1 30		lda ($30),y			lda 	(codePtr),y
.b37d	c9 80		cmp #$80			cmp 	#KWC_EOL 					; end of line ?
.b37f	f0 17		beq $b398			beq 	_LCExit
.b381	c9 10		cmp #$10			cmp 	#16 						; 0-5 are the double punctuations
.b383	90 1e		bcc $b3a3			bcc 	_LCDoubles
.b385	c9 20		cmp #$20			cmp 	#32 						; 16-31 are shifted punctuation from 64-91
.b387	90 2a		bcc $b3b3			bcc 	_LCShiftPunc
.b389	c9 40		cmp #$40			cmp 	#64 						; 32-64 are as stored, punc and digits
.b38b	90 35		bcc $b3c2			bcc 	_LCPunctuation
.b38d	c9 80		cmp #$80			cmp 	#128 						; 64-127 are variable identifiers.
.b38f	90 51		bcc $b3e2			bcc 	_LCIdentifiers
.b391	c9 fe		cmp #$fe			cmp 	#254 						; 128-253 are tokenised words
.b393	90 73		bcc $b408			bcc 	_LCTokens
.b395	4c 68 b4	jmp $b468			jmp 	_LCData 					; 254-5 are data objects
.b398					_LCExit:
.b398	68		pla				pla 								; get old indent adjust
.b399	30 07		bmi $b3a2			bmi 	_LCExit2
.b39b	18		clc				clc 								; add to indent if +ve
.b39c	6d 26 04	adc $0426			adc 	listIndent
.b39f	8d 26 04	sta $0426			sta 	listIndent
.b3a2					_LCExit2:
.b3a2	60		rts				rts
.b3a3					_LCDoubles:
.b3a3	48		pha				pha
.b3a4	4a		lsr a				lsr 	a 							; put bit 2 into bit 1
.b3a5	29 02		and #$02			and 	#2
.b3a7	09 3c		ora #$3c			ora 	#60 						; make < >
.b3a9	20 c7 b4	jsr $b4c7			jsr 	LCLWrite
.b3ac	68		pla				pla 								; restore, do lower bit
.b3ad	29 03		and #$03			and 	#3
.b3af	09 3c		ora #$3c			ora 	#60
.b3b1	80 0f		bra $b3c2			bra		_LCPunctuation 				; print, increment, loop
.b3b3					_LCShiftPunc:
.b3b3	aa		tax				tax 								; save in X
.b3b4	29 07		and #$07			and 	#7 							; lower 3 bits
.b3b6	f0 02		beq $b3ba			beq 	_LCNoAdd
.b3b8	09 18		ora #$18			ora 	#24 						; adds $18 to it.
.b3ba					_LCNoAdd:
.b3ba	e0 18		cpx #$18			cpx 	#24 						; if >= 24 add $20
.b3bc	90 02		bcc $b3c0			bcc 	_LCNoAdd2
.b3be	09 20		ora #$20			ora 	#32 						; adds $20
.b3c0					_LCNoAdd2:
.b3c0	09 40		ora #$40			ora 	#$40 						; shift into 64-127 range and fall through.
.b3c2					_LCPunctuation:
.b3c2	c9 3a		cmp #$3a			cmp 	#':' 						; check if :
.b3c4	d0 03		bne $b3c9			bne 	_LCPContinue
.b3c6	20 dd b4	jsr $b4dd			jsr 	LCLDeleteLastSpace 			; if so delete any preceding spaces
.b3c9					_LCPContinue:
.b3c9	c9 2e		cmp #$2e			cmp 	#'.'
.b3cb	f0 08		beq $b3d5			beq 	_LCPIsConstant
.b3cd	c9 30		cmp #$30			cmp 	#'0'
.b3cf	90 0b		bcc $b3dc			bcc 	_LCPNotConstant
.b3d1	c9 3a		cmp #$3a			cmp 	#'9'+1
.b3d3	b0 07		bcs $b3dc			bcs 	_LCPNotConstant
.b3d5					_LCPIsConstant:
.b3d5	48		pha				pha
.b3d6	a9 8d		lda #$8d			lda 	#CLIConstant+$80
.b3d8	20 be b4	jsr $b4be			jsr 	LCLWriteColour
.b3db	68		pla				pla
.b3dc					_LCPNotConstant:
.b3dc	c8		iny				iny 								; consume character
.b3dd	20 c7 b4	jsr $b4c7			jsr 	LCLWrite 					; write it out.
.b3e0	80 94		bra $b376			bra 	_LCMainLoop 				; go round again.
.b3e2					_LCIdentifiers:
.b3e2	18		clc				clc 								; convert to physical address
.b3e3	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.b3e5	85 37		sta $37				sta 	zTemp0+1
.b3e7	c8		iny				iny
.b3e8	b1 30		lda ($30),y			lda 	(codePtr),y
.b3ea	85 36		sta $36				sta 	zTemp0
.b3ec	c8		iny				iny
.b3ed	5a		phy				phy 								; save position
.b3ee	a9 87		lda #$87			lda 	#CLIIdentifier+$80
.b3f0	20 be b4	jsr $b4be			jsr 	LCLWriteColour
.b3f3	a0 07		ldy #$07			ldy 	#7 							; output the identifier at +8
.b3f5					_LCOutIdentifier:
.b3f5	c8		iny				iny
.b3f6	b1 36		lda ($36),y			lda 	(zTemp0),y					; bit 7 set = end.
.b3f8	29 7f		and #$7f			and 	#$7F
.b3fa	20 19 b5	jsr $b519			jsr 	LCLLowerCase
.b3fd	20 c7 b4	jsr $b4c7			jsr 	LCLWrite
.b400	b1 36		lda ($36),y			lda 	(zTemp0),y				 	; ends when bit 7 set.
.b402	10 f1		bpl $b3f5			bpl 	_LCOutIdentifier
.b404	7a		ply				ply 								; restore position
.b405	4c 76 b3	jmp $b376			jmp 	_LCMainLoop
.b408					_LCTokens:
.b408	aa		tax				tax 								; token in X
.b409	a9 4a		lda #$4a			lda 	#((KeywordSet2) & $FF)
.b40b	85 36		sta $36				sta 	0+zTemp0
.b40d	a9 bc		lda #$bc			lda 	#((KeywordSet2) >> 8)
.b40f	85 37		sta $37				sta 	1+zTemp0
.b411	e0 82		cpx #$82			cpx 	#$82
.b413	f0 16		beq $b42b			beq 	_LCUseShift
.b415	a9 ed		lda #$ed			lda 	#((KeywordSet1) & $FF)
.b417	85 36		sta $36				sta 	0+zTemp0
.b419	a9 bb		lda #$bb			lda 	#((KeywordSet1) >> 8)
.b41b	85 37		sta $37				sta 	1+zTemp0
.b41d	e0 81		cpx #$81			cpx 	#$81
.b41f	f0 0a		beq $b42b			beq 	_LCUseShift
.b421	a9 f0		lda #$f0			lda 	#((KeywordSet0) & $FF)
.b423	85 36		sta $36				sta 	0+zTemp0
.b425	a9 b9		lda #$b9			lda 	#((KeywordSet0) >> 8)
.b427	85 37		sta $37				sta 	1+zTemp0
.b429	80 01		bra $b42c			bra 	_LCNoShift
.b42b					_LCUseShift:
.b42b	c8		iny				iny
.b42c					_LCNoShift:
.b42c	20 f1 b4	jsr $b4f1			jsr 	LCLCheckSpaceRequired 		; do we need a space ?
.b42f	b1 30		lda ($30),y			lda 	(codePtr),y
.b431	aa		tax				tax 								; into X
.b432					_LCFindText:
.b432	ca		dex				dex
.b433	10 0e		bpl $b443			bpl 	_LCFoundText 				; found text.
.b435	b2 36		lda ($36)			lda 	(zTemp0) 					; length of text
.b437	1a		inc a				inc 	a 							; one extra for size
.b438	38		sec				sec 								; one extra for checksum
.b439	65 36		adc $36				adc 	zTemp0 						; go to next token
.b43b	85 36		sta $36				sta 	zTemp0
.b43d	90 f3		bcc $b432			bcc 	_LCFindText
.b43f	e6 37		inc $37				inc 	zTemp0+1
.b441	80 ef		bra $b432			bra 	_LCFindText
.b443					_LCFoundText:
.b443	5a		phy				phy 								; save List position
.b444	b2 36		lda ($36)			lda 	(zTemp0)					; count to print
.b446	aa		tax				tax
.b447	a9 83		lda #$83			lda 	#CLIToken+$80
.b449	20 be b4	jsr $b4be			jsr 	LCLWriteColour
.b44c	a0 02		ldy #$02			ldy 	#2
.b44e					_LCCopyToken:
.b44e	b1 36		lda ($36),y			lda 	(zTemp0),y
.b450	20 19 b5	jsr $b519			jsr 	LCLLowerCase
.b453	20 c7 b4	jsr $b4c7			jsr 	LCLWrite
.b456	c8		iny				iny
.b457	ca		dex				dex
.b458	d0 f4		bne $b44e			bne 	_LCCopyToken
.b45a	c9 28		cmp #$28			cmp 	#"(" 						; if last char not ( print a space
.b45c	f0 05		beq $b463			beq 	_LCNoSpace
.b45e	a9 20		lda #$20			lda 	#' '
.b460	20 c7 b4	jsr $b4c7			jsr 	LCLWrite
.b463					_LCNoSpace:
.b463	7a		ply				ply 								; restore position.
.b464	c8		iny				iny 								; consume token
.b465	4c 76 b3	jmp $b376			jmp 	_LCMainLoop 				; and go around again.
.b468					_LCData:
.b468	48		pha				pha 								; save type $FE/$FF
.b469	a2 24		ldx #$24			ldx 	#'$' 						; figure out $ or "
.b46b	c9 fe		cmp #$fe			cmp 	#$FE
.b46d	f0 22		beq $b491			beq 	_LCHaveOpener
.b46f	a2 22		ldx #$22			ldx 	#'"'
.b471	a9 81		lda #$81			lda 	#CLIData+$80
.b473	20 be b4	jsr $b4be			jsr 	LCLWriteColour
.b476	c0 04		cpy #$04			cpy 	#4 							; must be 2nd thing on line
.b478	d0 17		bne $b491			bne 	_LCHaveOpener
.b47a	88		dey				dey 								; what precedes it ?
.b47b	b1 30		lda ($30),y			lda 	(codePtr),y
.b47d	c8		iny				iny
.b47e	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; if quote
.b480	d0 0f		bne $b491			bne 	_LCHaveOpener
.b482	a9 09		lda #$09			lda 	#9 							; tab
.b484	20 c7 b4	jsr $b4c7			jsr 	LCLWrite
.b487	a9 97		lda #$97			lda 	#$90+CLIBComment
.b489	20 c7 b4	jsr $b4c7			jsr 	LCLWrite
.b48c	a9 80		lda #$80			lda 	#CLIFComment+$80
.b48e	20 be b4	jsr $b4be			jsr 	LCLWriteColour
.b491					_LCHaveOpener:
.b491	8a		txa				txa 								; output prefix (# or ")
.b492	20 c7 b4	jsr $b4c7			jsr 	LCLWrite
.b495	c8		iny				iny 								; get count
.b496	b1 30		lda ($30),y			lda 	(codePtr),y
.b498	aa		tax				tax
.b499	c8		iny				iny 								; point at first character
.b49a					_LCOutData:
.b49a	b1 30		lda ($30),y			lda 	(codePtr),y
.b49c	c9 00		cmp #$00			cmp 	#0
.b49e	f0 03		beq $b4a3			beq 	_LCNoPrint
.b4a0	20 c7 b4	jsr $b4c7			jsr 	LCLWrite
.b4a3					_LCNoPrint:
.b4a3	c8		iny				iny
.b4a4	ca		dex				dex
.b4a5	d0 f3		bne $b49a			bne 	_LCOutData
.b4a7	68		pla				pla 								; closing " required ?
.b4a8	c9 ff		cmp #$ff			cmp 	#$FF 						; not required for hex constant.
.b4aa	d0 0f		bne $b4bb			bne 	_LCNoQuote
.b4ac	a9 22		lda #$22			lda 	#'"'
.b4ae	20 c7 b4	jsr $b4c7			jsr 	LCLWrite
.b4b1	ad c2 05	lda $05c2			lda 	EXTTextColour
.b4b4	29 0f		and #$0f			and 	#$0F
.b4b6	09 90		ora #$90			ora 	#$90
.b4b8	20 c7 b4	jsr $b4c7			jsr 	LCLWrite
.b4bb					_LCNoQuote:
.b4bb	4c 76 b3	jmp $b376			jmp 	_LCMainLoop
.b4be					LCLWriteColour:
.b4be	cd 29 04	cmp $0429			cmp 	currentListColour 			; has the colour changed
.b4c1	8d 29 04	sta $0429			sta 	currentListColour 			; (update it anyway)
.b4c4	d0 01		bne $b4c7			bne 	LCLWrite 					; if different, output it
.b4c6	60		rts				rts
.b4c7					LCLWrite:
.b4c7	da		phx				phx
.b4c8	ae 1d 04	ldx $041d			ldx 	tbOffset 					; write out make ASCIIZ
.b4cb	9d 2d 04	sta $042d,x			sta 	tokenBuffer,x
.b4ce	9e 2e 04	stz $042e,x			stz 	tokenBuffer+1,x
.b4d1	ee 1d 04	inc $041d			inc 	tbOffset 					; bump the position
.b4d4	09 00		ora #$00			ora 	#0 							; don't update last character if colour data
.b4d6	30 03		bmi $b4db			bmi 	_LCLNoColour
.b4d8	8d 27 04	sta $0427			sta 	LCLastCharacter
.b4db					_LCLNoColour:
.b4db	fa		plx				plx
.b4dc	60		rts				rts
.b4dd					LCLDeleteLastSpace:
.b4dd	48		pha				pha
.b4de	da		phx				phx
.b4df	ae 1d 04	ldx $041d			ldx 	tbOffset
.b4e2	f0 0a		beq $b4ee			beq 	_LCDLSExit
.b4e4	bd 2c 04	lda $042c,x			lda 	tokenBuffer-1,x
.b4e7	c9 20		cmp #$20			cmp 	#' '
.b4e9	d0 03		bne $b4ee			bne 	_LCDLSExit
.b4eb	ce 1d 04	dec $041d			dec 	tbOffset
.b4ee					_LCDLSExit:
.b4ee	fa		plx				plx
.b4ef	68		pla				pla
.b4f0	60		rts				rts
.b4f1					LCLCheckSpaceRequired:
.b4f1	ad 27 04	lda $0427			lda 	LCLastCharacter 			; check last character
.b4f4	c9 24		cmp #$24			cmp 	#'$' 						; $ # and ) require that token space.
.b4f6	f0 1b		beq $b513			beq 	_LCCSRSpace
.b4f8	c9 29		cmp #$29			cmp 	#')'
.b4fa	f0 17		beq $b513			beq 	_LCCSRSpace
.b4fc	c9 23		cmp #$23			cmp 	#'#'
.b4fe	f0 13		beq $b513			beq 	_LCCSRSpace
.b500	20 19 b5	jsr $b519			jsr 	LCLLowerCase 				; saves a little effort
.b503	c9 30		cmp #$30			cmp 	#"0" 						; check if it was 0-9 A-Z a-z if so need space.
.b505	90 11		bcc $b518			bcc 	_LCCSRExit
.b507	c9 3a		cmp #$3a			cmp 	#"9"+1
.b509	90 08		bcc $b513			bcc 	_LCCSRSpace
.b50b	c9 61		cmp #$61			cmp 	#"a"
.b50d	90 09		bcc $b518			bcc 	_LCCSRExit
.b50f	c9 7b		cmp #$7b			cmp 	#"z"+1
.b511	b0 05		bcs $b518			bcs 	_LCCSRExit
.b513					_LCCSRSpace:
.b513	a9 20		lda #$20			lda 	#' '
.b515	20 c7 b4	jsr $b4c7			jsr 	LCLWrite
.b518					_LCCSRExit:
.b518	60		rts				rts
.b519					LCLLowerCase:
.b519	c9 41		cmp #$41			cmp 	#"A"
.b51b	90 06		bcc $b523			bcc 	_LCLLCOut
.b51d	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b51f	b0 02		bcs $b523			bcs 	_LCLLCOut
.b521	69 20		adc #$20			adc 	#$20
.b523					_LCLLCOut:
.b523	60		rts				rts
.b524					LCLUpperCase:
.b524	c9 61		cmp #$61			cmp 	#"a"
.b526	90 06		bcc $b52e			bcc 	_LCLUCOut
.b528	c9 7b		cmp #$7b			cmp 	#"z"+1
.b52a	b0 02		bcs $b52e			bcs 	_LCLUCOut
.b52c	e9 1f		sbc #$1f			sbc 	#$1F
.b52e					_LCLUCOut:
.b52e	60		rts				rts
.b52f					TOKSearchTable:
.b52f	84 37		sty $37				sty 	zTemp0+1 					; (zTemp0),y points to current token being tested.
.b531	85 36		sta $36				sta 	zTemp0
.b533	a0 00		ldy #$00			ldy 	#0
.b535	a9 80		lda #$80			lda 	#$80 						; token # so we know which one we are looking at
.b537	85 38		sta $38				sta 	zTemp1
.b539					_TSTLoop:
.b539	b1 36		lda ($36),y			lda 	(zTemp0),y 					; length, 0 (skip) -ve (end)
.b53b	30 49		bmi $b586			bmi 	_TSTFail 					; -ve = end of table, so fail.
.b53d	f0 2e		beq $b56d			beq 	_TSTNext 					; zero, check next as it's a dummy (e.g. EOL, SHIFT)
.b53f	c8		iny				iny 								; get the hash
.b540	b1 36		lda ($36),y			lda 	(zTemp0),y
.b542	88		dey				dey
.b543	cd 03 04	cmp $0403			cmp 	identHash 					; check they match with the identifier hash, if not go to next
.b546	d0 25		bne $b56d			bne 	_TSTNext
.b548	ad 02 04	lda $0402			lda 	identTypeEnd 				; get length of identifier from end-start
.b54b	38		sec				sec
.b54c	ed 00 04	sbc $0400			sbc 	identStart
.b54f	d1 36		cmp ($36),y			cmp 	(zTemp0),y 					; compare against the length in the table, no match, then return.
.b551	d0 1a		bne $b56d			bne 	_TSTNext
.b553	5a		phy				phy 								; save Y , we might fail to match.
.b554	c8		iny				iny 								; point to text
.b555	c8		iny				iny
.b556	ae 00 04	ldx $0400			ldx 	identStart 					; offset in line buffer in X
.b559					_TSTCompareName:
.b559	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; compare text.
.b55c	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.b55e	d0 0c		bne $b56c			bne 	_TSTNextPullY 				; fail, pullY and do next
.b560	e8		inx				inx
.b561	c8		iny				iny
.b562	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; complete match.
.b565	d0 f2		bne $b559			bne 	_TSTCompareName
.b567	7a		ply				ply 								; throw Y
.b568	a5 38		lda $38				lda 	zTemp1 						; get token #
.b56a	38		sec				sec 								; return with CS = passed.
.b56b	60		rts				rts
.b56c					_TSTNextPullY:
.b56c	7a		ply				ply 								; restore current, fall through.
.b56d					_TSTNext:
.b56d	e6 38		inc $38				inc 	zTemp1 						; token counter
.b56f	98		tya				tya
.b570	18		clc				clc
.b571	71 36		adc ($36),y			adc 	(zTemp0),y 					; add [Length] + 2 to Y
.b573	1a		inc a				inc 	a 							; +1
.b574	1a		inc a				inc 	a 							; +2
.b575	a8		tay				tay
.b576	10 c1		bpl $b539			bpl 	_TSTLoop 					; if Y < $80 loop back
.b578	98		tya				tya 								; add Y to zTemp0 and reset Y
.b579	a0 00		ldy #$00			ldy 	#0   						; so we can use Y to search fast
.b57b	18		clc				clc  								; but have tables > 255 bytes
.b57c	65 36		adc $36				adc 	zTemp0 						; when Y gets >= 128 we reset Y
.b57e	85 36		sta $36				sta 	zTemp0 						; and adjust the table pointer/
.b580	90 b7		bcc $b539			bcc 	_TSTLoop
.b582	e6 37		inc $37				inc 	zTemp0+1
.b584	80 b3		bra $b539			bra 	_TSTLoop
.b586					_TSTFail:
.b586	18		clc				clc
.b587	60		rts				rts
.b588					TokeniseLine:
.b588	20 10 b7	jsr $b710			jsr 	LCLFixLineBufferCase 		; fix line case
.b58b	a9 03		lda #$03			lda 	#3 							; reset the token buffer to empty
.b58d	8d 2a 04	sta $042a			sta 	tokenOffset 				; (3 bytes for line number & offset)
.b590	9c 2b 04	stz $042b			stz 	tokenLineNumber
.b593	9c 2c 04	stz $042c			stz 	tokenLineNumber+1
.b596	a2 ff		ldx #$ff			ldx 	#$FF
.b598					_TKFindFirst:
.b598	e8		inx				inx
.b599	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.b59c	f0 79		beq $b617			beq 	_TKExit
.b59e	c9 20		cmp #$20			cmp 	#' '
.b5a0	90 f6		bcc $b598			bcc 	_TKFindFirst
.b5a2	c9 30		cmp #$30			cmp 	#'0'
.b5a4	90 07		bcc $b5ad			bcc 	_TKNoLineNumber
.b5a6	c9 3a		cmp #$3a			cmp 	#'9'+1
.b5a8	b0 03		bcs $b5ad			bcs 	_TKNoLineNumber
.b5aa	20 3a b7	jsr $b73a			jsr 	TOKExtractLineNumber
.b5ad					_TKNoLineNumber:
.b5ad					_TKTokeniseLoop:
.b5ad	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; next character, exit if zero EOL.
.b5b0	f0 65		beq $b617			beq 	_TKExit
.b5b2	e8		inx				inx
.b5b3	c9 20		cmp #$20			cmp 	#' '
.b5b5	f0 f6		beq $b5ad			beq 	_TKTokeniseLoop 			; keep looping if space found.
.b5b7	ca		dex				dex 								; undo last get, A contains character, X is position.
.b5b8	c9 5f		cmp #$5f			cmp 	#'_'						; _ A-Z is identifier *or* token
.b5ba	f0 61		beq $b61d			beq 	_TKTokeniseIdentifier 		; (already case converted outside string constants)
.b5bc	c9 41		cmp #$41			cmp 	#'A'
.b5be	90 04		bcc $b5c4			bcc 	_TKTokenisePunctuation
.b5c0	c9 5b		cmp #$5b			cmp 	#'Z'+1
.b5c2	90 59		bcc $b61d			bcc 	_TKTokeniseIdentifier
.b5c4					_TKTokenisePunctuation:
.b5c4	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.b5c6	f0 27		beq $b5ef			beq 	_TKString
.b5c8	c9 24		cmp #$24			cmp 	#'$'						; hexadecimal constant ($ only appears at end of identifiers)
.b5ca	f0 28		beq $b5f4			beq 	_TKHexConstant
.b5cc	c9 3c		cmp #$3c			cmp 	#'<' 						; check for < > handlers - these are for <> <= >= >> <<
.b5ce	f0 29		beq $b5f9			beq 	_TKCheckDouble
.b5d0	c9 3e		cmp #$3e			cmp 	#'>'
.b5d2	f0 25		beq $b5f9			beq 	_TKCheckDouble
.b5d4					_TKStandardPunctuation:
.b5d4	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get the punctuation token back.
.b5d7	c9 40		cmp #$40			cmp 	#64 						; are we >= 64
.b5d9	90 0e		bcc $b5e9			bcc 	_TKNoShift
.b5db	48		pha				pha 								; save. we are about to convert this punctuation token from
.b5dc	29 07		and #$07			and 	#7 							; lower 3 bits in zTemp0
.b5de	85 36		sta $36				sta 	zTemp0
.b5e0	68		pla				pla
.b5e1	29 20		and #$20			and 	#32 						; bit 5
.b5e3	4a		lsr a				lsr 	a 							; shift into bit 3
.b5e4	4a		lsr a				lsr 	a
.b5e5	05 36		ora $36				ora 	zTemp0
.b5e7	09 10		ora #$10			ora 	#$10						; now in the range 16-31
.b5e9					_TKNoShift:
.b5e9	20 7f b7	jsr $b77f			jsr 	TOKWriteByte 				; write the punctuation character
.b5ec	e8		inx				inx 								; consume the character
.b5ed	80 be		bra $b5ad			bra 	_TKTokeniseLoop 			; and loop round again.
.b5ef					_TKString:
.b5ef	20 9f b6	jsr $b69f			jsr 	TOKTokenString
.b5f2	80 b9		bra $b5ad			bra 	_TKTokeniseLoop
.b5f4					_TKHexConstant:
.b5f4	20 da b6	jsr $b6da			jsr 	TOKHexConstant
.b5f7	80 b4		bra $b5ad			bra 	_TKTokeniseLoop
.b5f9					_TKCheckDouble:
.b5f9	bd 2b 05	lda $052b,x			lda 	lineBuffer+1,x 				; get next character
.b5fc	c9 3c		cmp #$3c			cmp 	#'<'						; if not < = > which are ASCII consecutive go back
.b5fe	90 d4		bcc $b5d4			bcc 	_TKStandardPunctuation 		; and do the normal punctuation handler.
.b600	c9 3f		cmp #$3f			cmp 	#'>'+1
.b602	b0 d0		bcs $b5d4			bcs 	_TKStandardPunctuation
.b604	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; this is < (60) or > (62)
.b607	29 02		and #$02			and 	#2 							; now < (0) or > (2)
.b609	0a		asl a				asl 	a 							; now < (0) or > (4), CC also
.b60a	7d 2b 05	adc $052b,x			adc 	lineBuffer+1,x 				; add < = > codes - < code
.b60d	38		sec				sec
.b60e	e9 3c		sbc #$3c			sbc 	#'<'
.b610	20 7f b7	jsr $b77f			jsr 	TOKWriteByte 				; this is in the range 0-7
.b613	e8		inx				inx 								; consume both
.b614	e8		inx				inx
.b615	80 96		bra $b5ad			bra 	_TKTokeniseLoop
.b617	a9 80		lda #$80	_TKExit:lda 	#KWC_EOL 					; write end of line byte
.b619	20 7f b7	jsr $b77f			jsr 	TOKWriteByte
.b61c	60		rts				rts
.b61d					_TKTokeniseIdentifier:
.b61d	8e 00 04	stx $0400			stx 	identStart 					; save start
.b620	9c 04 04	stz $0404			stz 	identTypeByte 				; zero the type byte
.b623					_TKCheckLoop:
.b623	e8		inx				inx 								; look at next, we know first is identifier already.
.b624	bd 2a 05	lda $052a,x			lda  	lineBuffer,x
.b627	c9 5f		cmp #$5f			cmp 	#"_" 						; legal char _ 0-9 A-Z
.b629	f0 f8		beq $b623			beq 	_TKCheckLoop
.b62b	c9 30		cmp #$30			cmp	 	#"0"
.b62d	90 0c		bcc $b63b			bcc 	_TKEndIdentifier
.b62f	c9 3a		cmp #$3a			cmp 	#"9"+1
.b631	90 f0		bcc $b623			bcc 	_TKCheckLoop
.b633	c9 41		cmp #$41			cmp	 	#"A"
.b635	90 04		bcc $b63b			bcc 	_TKEndIdentifier
.b637	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b639	90 e8		bcc $b623			bcc 	_TKCheckLoop
.b63b					_TKEndIdentifier:
.b63b	8e 01 04	stx $0401			stx 	identTypeStart 				; save start of type text (if any !)
.b63e	a0 08		ldy #$08			ldy 	#$08 						; this is the identifier type byte for #
.b640	c9 23		cmp #$23			cmp 	#"#"						; followed by #
.b642	f0 06		beq $b64a			beq 	_TKHasTypeCharacter
.b644	a0 10		ldy #$10			ldy 	#$10 						; this is the identifier type byte for $
.b646	c9 24		cmp #$24			cmp 	#"$"						; followed by $ or #
.b648	d0 07		bne $b651			bne 	_TKNoTypeCharacter
.b64a					_TKHasTypeCharacter:
.b64a	8c 04 04	sty $0404			sty 	identTypeByte 				; has # or $, save the type
.b64d	e8		inx				inx 								; consume the type character
.b64e	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.b651					_TKNoTypeCharacter:
.b651	c9 28		cmp #$28			cmp 	#"("						; is it open parenthesis (e.g. array)
.b653	d0 09		bne $b65e			bne 	_TKNoArray
.b655	e8		inx				inx 								; skip the (
.b656	ad 04 04	lda $0404			lda 	identTypeByte 				; set bit 2 (e.g. array) in type byte
.b659	09 04		ora #$04			ora 	#$04
.b65b	8d 04 04	sta $0404			sta 	identTypeByte
.b65e					_TKNoArray:
.b65e	8e 02 04	stx $0402			stx 	identTypeEnd 				; save end marker, e.g. continue from here.
.b661	20 fb b6	jsr $b6fb			jsr 	TOKCalculateHash 			; calculate the has for those tokens
.b664	a0 b9		ldy #$b9			ldy 	#(KeywordSet0) >> 8
.b666	a9 f0		lda #$f0			lda 	#(KeywordSet0) & $FF
.b668	20 2f b5	jsr $b52f			jsr 	TOKSearchTable
.b66b	a2 00		ldx #$00			ldx 	#0
.b66d	b0 1f		bcs $b68e			bcs 	_TKFoundToken
.b66f	a0 bb		ldy #$bb			ldy 	#(KeywordSet1) >> 8
.b671	a9 ed		lda #$ed			lda 	#(KeywordSet1) & $FF
.b673	20 2f b5	jsr $b52f			jsr 	TOKSearchTable
.b676	a2 81		ldx #$81			ldx 	#$81
.b678	b0 14		bcs $b68e			bcs 	_TKFoundToken
.b67a	a0 bc		ldy #$bc			ldy 	#(KeywordSet2) >> 8
.b67c	a9 4a		lda #$4a			lda 	#(KeywordSet2) & $FF
.b67e	20 2f b5	jsr $b52f			jsr 	TOKSearchTable
.b681	a2 82		ldx #$82			ldx 	#$82
.b683	b0 09		bcs $b68e			bcs 	_TKFoundToken
.b685	20 8b b7	jsr $b78b			jsr 	TOKCheckCreateVariableRecord ; failed all, it's a variable, create record if does not exist.
.b688	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.b68b	4c ad b5	jmp $b5ad			jmp 	_TKTokeniseLoop 			; and go round again.
.b68e					_TKFoundToken:
.b68e	48		pha				pha 								; save token
.b68f	8a		txa				txa 								; shift in X, is there one ?
.b690	f0 03		beq $b695			beq 	_TKNoTShift
.b692	20 7f b7	jsr $b77f			jsr 	TOKWriteByte 				; if so, write it out
.b695					_TKNoTShift:
.b695	68		pla				pla 								; restore and write token
.b696	20 7f b7	jsr $b77f			jsr 	TOKWriteByte
.b699	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.b69c	4c ad b5	jmp $b5ad			jmp 	_TKTokeniseLoop 			; and go round again.
.b69f					TOKTokenString:
.b69f	a9 ff		lda #$ff			lda 	#KWC_STRING 				; string token.
.b6a1	20 7f b7	jsr $b77f			jsr 	TOKWriteByte
.b6a4	e8		inx				inx									; start of quoted string.
.b6a5	da		phx				phx 								; push start of string on top
.b6a6	ca		dex				dex 								; because we pre-increment
.b6a7					_TSFindEnd:
.b6a7	e8		inx				inx
.b6a8	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; next character
.b6ab	f0 04		beq $b6b1			beq 	_TSEndOfString 				; no matching quote, we don't mind.
.b6ad	c9 22		cmp #$22			cmp 	#'"' 						; go back if quote not found
.b6af	d0 f6		bne $b6a7			bne 	_TSFindEnd
.b6b1					_TSEndOfString:
.b6b1	7a		ply				ply  								; so now Y is first character, X is character after end.
.b6b2	48		pha				pha 								; save terminating character
.b6b3	20 bb b6	jsr $b6bb			jsr 	TOKWriteBlockXY 			; write X to Y as a data block
.b6b6	68		pla				pla 								; terminating character
.b6b7	f0 01		beq $b6ba			beq 	_TSNotQuote					; if it wasn't EOS skip it
.b6b9	e8		inx				inx
.b6ba					_TSNotQuote:
.b6ba	60		rts				rts
.b6bb					TOKWriteBlockXY:
.b6bb	86 36		stx $36				stx 	zTemp0 						; save end character
.b6bd	98		tya				tya 								; use 2's complement to work out the byte size
.b6be	49 ff		eor #$ff			eor 	#$FF
.b6c0	38		sec				sec
.b6c1	65 36		adc $36				adc 	zTemp0
.b6c3	1a		inc a				inc 	a 							; one extra for NULL
.b6c4	20 7f b7	jsr $b77f			jsr 	TOKWriteByte
.b6c7					_TOBlockLoop:
.b6c7	c4 36		cpy $36				cpy 	zTemp0 						; exit if reached the end
.b6c9	f0 09		beq $b6d4			beq 	_TOBlockExit
.b6cb	b9 2a 05	lda $052a,y			lda 	lineBuffer,y 				; write byte out.
.b6ce	20 7f b7	jsr $b77f			jsr 	TOKWriteByte
.b6d1	c8		iny				iny
.b6d2	80 f3		bra $b6c7			bra 	_TOBlockLoop
.b6d4					_TOBlockExit:
.b6d4	a9 00		lda #$00			lda 	#0 							; add NULL.
.b6d6	20 7f b7	jsr $b77f			jsr 	TOKWriteByte
.b6d9	60		rts				rts
.b6da					TOKHexConstant:
.b6da	a9 fe		lda #$fe			lda 	#KWC_HEXCONST 				; hex constant token.
.b6dc	20 7f b7	jsr $b77f			jsr 	TOKWriteByte
.b6df	e8		inx				inx									; start of quoted string.
.b6e0	da		phx				phx 								; push start of constant on top
.b6e1	ca		dex				dex
.b6e2					_THFindLoop:
.b6e2	e8		inx				inx 	 							; this is stored in a block, so find out how long
.b6e3	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; the hex constant is.
.b6e6	c9 30		cmp #$30			cmp 	#"0"
.b6e8	90 0c		bcc $b6f6			bcc 	_THFoundEnd
.b6ea	c9 3a		cmp #$3a			cmp 	#"9"+1
.b6ec	90 f4		bcc $b6e2			bcc 	_THFindLoop
.b6ee	c9 41		cmp #$41			cmp 	#"A"
.b6f0	90 04		bcc $b6f6			bcc 	_THFoundEnd
.b6f2	c9 47		cmp #$47			cmp 	#"F"+1
.b6f4	90 ec		bcc $b6e2			bcc 	_THFindLoop
.b6f6					_THFoundEnd:
.b6f6	7a		ply				ply 								; restore start
.b6f7	20 bb b6	jsr $b6bb			jsr 	TOKWriteBlockXY 			; output the block
.b6fa	60		rts				rts
.b6fb					TOKCalculateHash:
.b6fb	da		phx				phx
.b6fc	ae 00 04	ldx $0400			ldx 	identStart 					; needs to be same as in tokens.py - simple sum at present.
.b6ff	a9 00		lda #$00			lda 	#0
.b701					_TCHLoop:
.b701	18		clc				clc
.b702	7d 2a 05	adc $052a,x			adc 	lineBuffer,x
.b705	e8		inx				inx
.b706	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; do the whole thing including type and array markers.
.b709	d0 f6		bne $b701			bne 	_TCHLoop
.b70b	8d 03 04	sta $0403			sta 	identHash 					; save the hash
.b70e	fa		plx				plx
.b70f	60		rts				rts
.b710					LCLFixLineBufferCase:
.b710	a2 00		ldx #$00			ldx 	#0
.b712					_FLBCLoop:
.b712	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get next character
.b715	f0 22		beq $b739			beq 	_FLBCExit 					; end of string.
.b717	c9 22		cmp #$22			cmp 	#'"'						; quote, go to in quotes
.b719	f0 11		beq $b72c			beq 	_FLBCInQuotes
.b71b	e8		inx				inx
.b71c	c9 61		cmp #$61			cmp 	#'a'						; needs capitalising ?
.b71e	90 f2		bcc $b712			bcc 	_FLBCLoop
.b720	c9 7b		cmp #$7b			cmp 	#'z'+1
.b722	b0 ee		bcs $b712			bcs 	_FLBCLoop
.b724	38		sec				sec 								; make U/C
.b725	e9 20		sbc #$20			sbc 	#32
.b727	9d 29 05	sta $0529,x			sta	 	lineBuffer-1,x 				; write back
.b72a	80 e6		bra $b712			bra 	_FLBCLoop
.b72c					_FLBCInQuotes:
.b72c	e8		inx				inx 								; advance
.b72d	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get next
.b730	f0 07		beq $b739			beq 	_FLBCExit 					; exit on EOS
.b732	c9 22		cmp #$22			cmp 	#'"' 				 		; until " found
.b734	d0 f6		bne $b72c			bne 	_FLBCInQuotes
.b736	e8		inx				inx 								; skip over it
.b737	80 d9		bra $b712			bra 	_FLBCLoop
.b739					_FLBCExit:
.b739	60		rts				rts
.b73a					TOKExtractLineNumber:
.b73a	ad 2c 04	lda $042c			lda 	tokenLineNumber+1 			; push current value on stack
.b73d	48		pha				pha
.b73e	ad 2b 04	lda $042b			lda 	tokenLineNumber
.b741	48		pha				pha
.b742	20 78 b7	jsr $b778			jsr 	_LCLNTimes2 				; line # x 2
.b745	20 78 b7	jsr $b778			jsr 	_LCLNTimes2 				; line # x 4
.b748	18		clc				clc 								; add stacked value
.b749	68		pla				pla
.b74a	6d 2b 04	adc $042b			adc 	tokenLineNumber
.b74d	8d 2b 04	sta $042b			sta 	tokenLineNumber
.b750	68		pla				pla
.b751	6d 2c 04	adc $042c			adc 	tokenLineNumber+1
.b754	8d 2c 04	sta $042c			sta 	tokenLineNumber+1 			; line # x 5
.b757	20 78 b7	jsr $b778			jsr 	_LCLNTimes2 				; line # x 10
.b75a	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get and consume character
.b75d	e8		inx				inx
.b75e	29 0f		and #$0f			and 	#15 						; add to line #
.b760	18		clc				clc
.b761	6d 2b 04	adc $042b			adc 	tokenLineNumber
.b764	8d 2b 04	sta $042b			sta 	tokenLineNumber
.b767	90 03		bcc $b76c			bcc 	_TLENNoCarry
.b769	ee 2c 04	inc $042c			inc 	tokenLineNumber+1
.b76c					_TLENNoCarry:
.b76c	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; more digits ?
.b76f	c9 30		cmp #$30			cmp 	#'0'
.b771	90 04		bcc $b777			bcc 	_TLENExit
.b773	c9 3a		cmp #$3a			cmp 	#'9'+1
.b775	90 c3		bcc $b73a			bcc 	TOKExtractLineNumber
.b777					_TLENExit:
.b777	60		rts				rts
.b778					_LCLNTimes2:
.b778	0e 2b 04	asl $042b			asl 	tokenLineNumber 			; doubles tokenLineNumber.
.b77b	2e 2c 04	rol $042c			rol 	tokenLineNumber+1
.b77e	60		rts				rts
.b77f					TOKWriteByte:
.b77f	da		phx				phx
.b780	ae 2a 04	ldx $042a			ldx 	tokenOffset 				; next slot to write to
.b783	9d 2a 04	sta $042a,x			sta 	tokenOffset,x 				; write byte out
.b786	ee 2a 04	inc $042a			inc 	tokenOffset 				; advance slot.
.b789	fa		plx				plx
.b78a	60		rts				rts
.b78b					TOKCheckCreateVariableRecord:
.b78b	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.b78d	85 36		sta $36				sta 	0+zTemp0
.b78f	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.b791	85 37		sta $37				sta 	1+zTemp0
.b793					_CCVSearch:
.b793	b2 36		lda ($36)			lda 	(zTemp0) 					; end of list
.b795	f0 2c		beq $b7c3			beq 	_CCVFail
.b797	a0 01		ldy #$01			ldy 	#1 							; read the hash
.b799	b1 36		lda ($36),y			lda 	(zTemp0),y 					; does it match ?
.b79b	cd 03 04	cmp $0403			cmp 	identHash 	  				; if not, try the next.
.b79e	d0 16		bne $b7b6			bne 	_CCVNext
.b7a0	a0 08		ldy #$08			ldy 	#8 							; name in variable record
.b7a2	ae 00 04	ldx $0400			ldx 	identStart
.b7a5					_CCVCompare:
.b7a5	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; xor them. zero if the same, except
.b7a8	51 36		eor ($36),y			eor 	(zTemp0),y 					; bit 7 is used for EOS.
.b7aa	e8		inx				inx 								; advance pointers
.b7ab	c8		iny				iny
.b7ac	0a		asl a				asl 	a 							; A = 0 if they match, CS if end.
.b7ad	d0 07		bne $b7b6			bne 	_CCVNext  					; didn't match go to next.
.b7af	90 f4		bcc $b7a5			bcc 	_CCVCompare 				; not finished yet.
.b7b1	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; matched whole thing ?
.b7b4	f0 47		beq $b7fd			beq 	_CCVFound 					; yes, we were successful
.b7b6					_CCVNext:
.b7b6	18		clc				clc 								; go to next record.
.b7b7	b2 36		lda ($36)			lda 	(zTemp0) 					; add offset to pointer
.b7b9	65 36		adc $36				adc 	zTemp0
.b7bb	85 36		sta $36				sta 	zTemp0
.b7bd	90 d4		bcc $b793			bcc 	_CCVSearch
.b7bf	e6 37		inc $37				inc 	zTemp0+1
.b7c1	80 d0		bra $b793			bra 	_CCVSearch
.b7c3					_CCVFail:
.b7c3	a5 37		lda $37				lda 	zTemp0+1 					; are we out of space
.b7c5	c9 1e		cmp #$1e			cmp 	#(EndVariableSpace-512) >> 8
.b7c7	b0 44		bcs $b80d			bcs 	_CCVMemory
.b7c9	a0 01		ldy #$01			ldy 	#1 							; create the new record. Offset 1 is hash
.b7cb	ad 03 04	lda $0403			lda 	identHash
.b7ce	91 36		sta ($36),y			sta 	(zTemp0),y
.b7d0	c8		iny				iny 								; offset 2 is the type byte
.b7d1	ad 04 04	lda $0404			lda 	identTypeByte
.b7d4	91 36		sta ($36),y			sta 	(zTemp0),y
.b7d6	c8		iny				iny
.b7d7					_CCVData:
.b7d7	a9 00		lda #$00			lda 	#0 							; erase data 3-7 (the 5 value bytes)
.b7d9	91 36		sta ($36),y			sta 	(zTemp0),y
.b7db	c8		iny				iny
.b7dc	c0 08		cpy #$08			cpy 	#8
.b7de	90 f7		bcc $b7d7			bcc 	_CCVData
.b7e0	ae 00 04	ldx $0400			ldx 	identStart 					; copy name into 8 on.
.b7e3					_CCVCopyName:
.b7e3	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.b7e6	91 36		sta ($36),y			sta 	(zTemp0),y
.b7e8	e8		inx				inx
.b7e9	c8		iny				iny
.b7ea	ec 02 04	cpx $0402			cpx 	identTypeEnd
.b7ed	d0 f4		bne $b7e3			bne 	_CCVCopyName
.b7ef	98		tya				tya 								; patch offset
.b7f0	92 36		sta ($36)			sta 	(zTemp0)
.b7f2	a9 00		lda #$00			lda 	#0 							; offset for next is zero.
.b7f4	91 36		sta ($36),y			sta 	(zTemp0),y
.b7f6	88		dey				dey
.b7f7	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set bit 7 of last bit
.b7f9	09 80		ora #$80			ora 	#$80
.b7fb	91 36		sta ($36),y			sta 	(zTemp0),y
.b7fd					_CCVFound:
.b7fd	a5 37		lda $37				lda 	zTemp0+1 					; write out MSB
.b7ff	38		sec				sec
.b800	e9 10		sbc #$10			sbc 	#(VariableSpace >> 8) 		; offset from the start of the variable token
.b802	09 40		ora #$40			ora 	#$40 						; make it a writeable token $4000-$7FFF
.b804	20 7f b7	jsr $b77f			jsr 	TOKWriteByte
.b807	a5 36		lda $36				lda 	zTemp0 						; write out LSB
.b809	20 7f b7	jsr $b77f			jsr 	TOKWriteByte
.b80c	60		rts				rts
.b80d					_CCVMemory:
.b80d	a9 06		lda #$06		lda	#6
.b80f	4c a4 8e	jmp $8ea4		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_sound.module

=1					soundIntegrated=1
.b812					SNDCheckChannel:
.b812	aa		tax				tax
.b813	bd 8b 07	lda $078b,x			lda 	SNDTimeLeft,x 				; currently playing a note
.b816	d0 38		bne $b850			bne 	_SNDCCExit
.b818	da		phx				phx 								; save current channel
.b819	8a		txa				txa 								; put in A
.b81a	20 96 b8	jsr $b896			jsr 	SNDFindNextNoteForA 		; is there a note for A in the queue ?
.b81d	68		pla				pla 								; channel # in A
.b81e	90 30		bcc $b850			bcc 	_SNDCCExit  				; nothing in the queue for this channel, exit.
.b820	a8		tay				tay 								; Y is the channel #
.b821	bd 80 06	lda $0680,x			lda 	SNDQueue+1,x 				; copy data into the slot.
.b824	99 7f 07	sta $077f,y			sta 	SNDPitchLow,y
.b827	bd 81 06	lda $0681,x			lda 	SNDQueue+2,x
.b82a	99 83 07	sta $0783,y			sta 	SNDPitchHigh,y
.b82d	bd 82 06	lda $0682,x			lda 	SNDQueue+3,x
.b830	99 87 07	sta $0787,y			sta 	SNDVolume,y
.b833	bd 83 06	lda $0683,x			lda 	SNDQueue+4,x
.b836	99 8b 07	sta $078b,y			sta 	SNDTimeLeft,y
.b839	bd 84 06	lda $0684,x			lda 	SNDQueue+5,x
.b83c	99 8f 07	sta $078f,y			sta 	SNDAdjustLow,y
.b83f	bd 85 06	lda $0685,x			lda 	SNDQueue+6,x
.b842	99 93 07	sta $0793,y			sta 	SNDAdjustHigh,y
.b845	5a		phy				phy 								; save channel #
.b846	20 b0 b8	jsr $b8b0			jsr 	SNDDeleteXFromQueue 		; delete record at X from queue
.b849	ce 7e 06	dec $067e			dec 	SNDLength 					; reduce the queue length.
.b84c	68		pla				pla
.b84d	20 51 b8	jsr $b851			jsr 	SNDUpdateNote 				; update channel A
.b850					_SNDCCExit:
.b850	60		rts				rts
.b851					SNDUpdateNote:
.b851	aa		tax				tax 								; so we can access records
.b852	0a		asl a				asl 	a 							; convert it to a channel bit pair in 5,6
.b853	0a		asl a				asl 	a
.b854	0a		asl a				asl 	a
.b855	0a		asl a				asl 	a
.b856	0a		asl a				asl 	a
.b857	8d 7d 06	sta $067d			sta 	SNDChannelBits
.b85a	bd 8b 07	lda $078b,x			lda 	SNDTimeLeft,x 				; are we silent
.b85d	f0 2e		beq $b88d			beq 	_SNDUNIsSilent
.b85f	ad 7d 06	lda $067d			lda 	SNDChannelBits 				; push channel bits on stack
.b862	48		pha				pha
.b863	bd 7f 07	lda $077f,x			lda 	SNDPitchLow,x 				; get 4 lowest bits of pitch.
.b866	29 0f		and #$0f			and 	#$0F
.b868	0d 7d 06	ora $067d			ora 	SNDChannelBits 				; set channel bits
.b86b	09 80		ora #$80			ora 	#$80 						; write to pitch register
.b86d	20 fa b8	jsr $b8fa			jsr 	SNDWritePorts
.b870	bd 83 07	lda $0783,x			lda 	SNDPitchHigh,x 				; pitch high => channel temp.
.b873	8d 7d 06	sta $067d			sta 	SNDChannelBits
.b876	bd 7f 07	lda $077f,x			lda 	SNDPitchLow,x
.b879	4e 7d 06	lsr $067d			lsr 	SNDChannelBits 				; shift 2 LSBs into MSB of A
.b87c	6a		ror a				ror 	a
.b87d	4e 7d 06	lsr $067d			lsr 	SNDChannelBits
.b880	6a		ror a				ror 	a
.b881	4a		lsr a				lsr 	a 							; put in bits 0-5
.b882	4a		lsr a				lsr 	a
.b883	20 fa b8	jsr $b8fa			jsr 	SNDWritePorts 				; write as rest of pitch register
.b886	68		pla				pla
.b887	09 90		ora #$90			ora 	#$90 						; set to write minimum attentuation.
.b889	20 fa b8	jsr $b8fa			jsr 	SNDWritePorts
.b88c	60		rts				rts
.b88d					_SNDUNIsSilent:
.b88d	ad 7d 06	lda $067d			lda 	SNDChannelBits 				; channel bits
.b890	09 9f		ora #$9f			ora 	#$9F 						; maximum attenuation
.b892	20 fa b8	jsr $b8fa			jsr 	SNDWritePorts 				; write to the ports
.b895	60		rts				rts
.b896					SNDFindNextNoteForA:
.b896	ac 7e 06	ldy $067e			ldy 	SNDLength 					; queue size into Y
.b899	f0 13		beq $b8ae			beq 	_SNDFNNFail 				; queue empty.
.b89b	a2 00		ldx #$00			ldx 	#0
.b89d					_SNDFNNSearch:
.b89d	dd 7f 06	cmp $067f,x			cmp 	SNDQueue,x 					; does it match the channel
.b8a0	38		sec				sec
.b8a1	f0 0c		beq $b8af			beq 	_SNDFNNExit 				; if so exit with CS.
.b8a3	e8		inx				inx 								; next queue slot.
.b8a4	e8		inx				inx
.b8a5	e8		inx				inx
.b8a6	e8		inx				inx
.b8a7	e8		inx				inx
.b8a8	e8		inx				inx
.b8a9	e8		inx				inx
.b8aa	e8		inx				inx
.b8ab	88		dey				dey 								; done the whole queue
.b8ac	d0 ef		bne $b89d			bne 	_SNDFNNSearch 				; no, go back.
.b8ae					_SNDFNNFail:
.b8ae	18		clc				clc
.b8af					_SNDFNNexit:
.b8af	60		rts				rts
.b8b0					SNDDeleteXFromQueue:
.b8b0	e0 f8		cpx #$f8			cpx 	#SNDQueueSize*8-8 			; reached the end.
.b8b2	f0 09		beq $b8bd			beq 	_SNDDXExit
.b8b4	bd 87 06	lda $0687,x			lda 	SNDQueue+8,x
.b8b7	9d 7f 06	sta $067f,x			sta 	SNDQueue,x
.b8ba	e8		inx				inx
.b8bb	80 f3		bra $b8b0			bra 	SNDDeleteXFromQueue
.b8bd					_SNDDXExit:
.b8bd	60		rts				rts
.067d					SNDChannelBits:
>067d							.fill 	1
.b8be					SNDQueueRequest:
.b8be	86 36		stx $36				stx 	zTemp0						; save queue address
.b8c0	84 37		sty $37				sty 	zTemp0+1
.b8c2	ae 7e 06	ldx $067e			ldx 	SNDLength 					; queue is full, can't take any more.
.b8c5	e0 20		cpx #$20			cpx 	#SNDQueueSize
.b8c7	f0 21		beq $b8ea			beq 	_SNDQRExit
.b8c9	29 03		and #$03			and 	#3	 						; channel # and push on stack
.b8cb	48		pha				pha
.b8cc	8a		txa				txa  								; get offset in queue buffer/
.b8cd	0a		asl a				asl 	a
.b8ce	0a		asl a				asl 	a
.b8cf	0a		asl a				asl 	a
.b8d0	aa		tax				tax
.b8d1	68		pla				pla 								; get back and push again
.b8d2	48		pha				pha
.b8d3	9d 7f 06	sta $067f,x			sta 	SNDQueue+0,x 				; save the channel #
.b8d6	a0 00		ldy #$00			ldy 	#0 							; copy the rest in.
.b8d8					_SNDQCopy:
.b8d8	b1 36		lda ($36),y			lda 	(zTemp0),y
.b8da	e8		inx				inx
.b8db	c8		iny				iny
.b8dc	9d 7f 06	sta $067f,x			sta 	SNDQueue,x
.b8df	c0 06		cpy #$06			cpy 	#6
.b8e1	d0 f5		bne $b8d8			bne 	_SNDQCopy
.b8e3	ee 7e 06	inc $067e			inc 	SNDLength 					; bump queue length.
.b8e6	68		pla				pla 								; get channel # back
.b8e7	20 12 b8	jsr $b812			jsr 	SNDCheckChannel 			; check if channel needs refreshing.
.b8ea					_SNDQRExit:
.b8ea	60		rts				rts
.b8eb					SNDSilenceChannel:
.b8eb	aa		tax				tax 								; zero time left.
.b8ec	9e 8b 07	stz $078b,x			stz 	SNDTimeLeft,x
.b8ef	0a		asl a				asl 	a 							; shift into position
.b8f0	0a		asl a				asl 	a
.b8f1	0a		asl a				asl 	a
.b8f2	0a		asl a				asl 	a
.b8f3	0a		asl a				asl 	a
.b8f4	09 9f		ora #$9f			ora 	#$9F 						; write register attenuation $F
.b8f6	20 fa b8	jsr $b8fa			jsr 	SNDWritePorts
.b8f9	60		rts				rts
.b8fa					SNDWritePorts:
.b8fa	da		phx				phx 								; save X
.b8fb	a6 01		ldx $01				ldx 	1 							; save I/O status
.b8fd	64 01		stz $01				stz 	1 							; access I/O page 0
.b8ff	8d 00 d6	sta $d600			sta 	$D600 						; write to both
.b902	8d 10 d6	sta $d610			sta 	$D610
.b905	86 01		stx $01				stx 	1 							; restore I/O
.b907	fa		plx				plx 								; restore X
.b908	60		rts				rts
.b909					SNDCommand:
.b909	da		phx				phx 								; save XY
.b90a	5a		phy				phy
.b90b	c9 0f		cmp #$0f			cmp 	#$0F 						; $0F is initialise
.b90d	f0 1d		beq $b92c			beq 	_SNDInitialise
.b90f	90 28		bcc $b939			bcc 	_SNDExit
.b911	c9 3f		cmp #$3f			cmp 	#$3F 						; $3F is silence all
.b913	f0 17		beq $b92c			beq 	_SNDSilence
.b915	b0 22		bcs $b939			bcs 	_SNDExit
.b917	c9 20		cmp #$20			cmp 	#$20 						; $2x is check playing => A
.b919	b0 09		bcs $b924			bcs 	_SNDQueryPlay
.b91b	c9 14		cmp #$14			cmp 	#$14 						; $10-$13 is queue sound
.b91d	b0 1a		bcs $b939			bcs 	_SNDExit
.b91f	20 be b8	jsr $b8be			jsr 	SNDQueueRequest
.b922	80 15		bra $b939			bra 	_SNDExit
.b924					_SNDQueryPlay:
.b924	29 03		and #$03			and 	#3 							; get channel #
.b926	aa		tax				tax
.b927	bd 8b 07	lda $078b,x			lda 	SNDTimeLeft,x 				; read time left, if zero then silent
.b92a	80 0d		bra $b939			bra 	_SNDExit
.b92c					_SNDInitialise:
.b92c					_SNDSilence:
.b92c	9c 7e 06	stz $067e			stz 	SNDLength 					; empty the queue.
.b92f	a9 03		lda #$03			lda 	#$3 						; silence channel 0-3.
.b931					_SNDSilenceLoop:
.b931	48		pha				pha
.b932	20 eb b8	jsr $b8eb			jsr 	SNDSilenceChannel
.b935	68		pla				pla
.b936	3a		dec a				dec 	a
.b937	10 f8		bpl $b931			bpl 	_SNDSilenceLoop
.b939					_SNDExit:
.b939	7a		ply				ply
.b93a	fa		plx				plx
.b93b	60		rts				rts
=32					SNDQueueSize = 32 							; number of queue entries
.067e					SNDLength:
>067e							.fill 	1
.067f					SNDQueue:
>067f							.fill 	SNDQueueSize * 8
.077f					SNDPitchLow:
>077f							.fill 	4
.0783					SNDPitchHigh:
>0783							.fill 	4
.0787					SNDVolume:
>0787							.fill 	4
.078b					SNDTimeLeft:
>078b							.fill 	4
.078f					SNDAdjustLow:
>078f							.fill 	4
.0793					SNDAdjustHigh:
>0793							.fill 	4
.b93c					SNDUpdate:
.b93c	ad 8b 07	lda $078b			lda 	SNDTimeLeft+0 				; look at time remaining
.b93f	f0 05		beq $b946			beq 	_SNDUNot0 					; not playing
.b941	a2 00		ldx #$00			ldx 	#0 							; so we know which channel to update
.b943	20 65 b9	jsr $b965			jsr 	SNDUpdateChannel 			; update it.
.b946					_SNDUNot0:
.b946	ad 8c 07	lda $078c			lda 	SNDTimeLeft+1
.b949	f0 05		beq $b950			beq 	_SNDUNot1
.b94b	a2 01		ldx #$01			ldx 	#1
.b94d	20 65 b9	jsr $b965			jsr 	SNDUpdateChannel
.b950					_SNDUNot1:
.b950	ad 8d 07	lda $078d			lda 	SNDTimeLeft+2
.b953	f0 05		beq $b95a			beq 	_SNDUNot2
.b955	a2 02		ldx #$02			ldx 	#2
.b957	20 65 b9	jsr $b965			jsr 	SNDUpdateChannel
.b95a					_SNDUNot2:
.b95a	ad 8e 07	lda $078e			lda 	SNDTimeLeft+3
.b95d	f0 05		beq $b964			beq 	_SNDUNot3
.b95f	a2 03		ldx #$03			ldx 	#3
.b961	20 65 b9	jsr $b965			jsr 	SNDUpdateChannel
.b964					_SNDUNot3:
.b964	60		rts				rts
.b965					SNDUpdateChannel:
.b965	c9 ff		cmp #$ff			cmp 	#$FF 						; sound $FF play forever until turned off manually
.b967	f0 2c		beq $b995			beq 	_SNDUCExit
.b969	3a		dec a				dec 	a 							; decrement and update timer
.b96a	9d 8b 07	sta $078b,x			sta 	SNDTimeLeft,x
.b96d	f0 1d		beq $b98c			beq 	_SNDUCUpdate 				; if zero, silence channel
.b96f	bd 8f 07	lda $078f,x			lda 	SNDAdjustLow,x 				; adjust ?
.b972	1d 93 07	ora $0793,x			ora 	SNDAdjustHigh,x
.b975	f0 1e		beq $b995			beq 	_SNDUCExit 					; if zero carry on at current tone.
.b977	18		clc				clc 								; add adjust, forcing into a 10 bit range
.b978	bd 7f 07	lda $077f,x			lda 	SNDPitchLow,x
.b97b	7d 8f 07	adc $078f,x			adc 	SNDAdjustLow,x
.b97e	9d 7f 07	sta $077f,x			sta 	SNDPitchLow,x
.b981	bd 83 07	lda $0783,x			lda 	SNDPitchHigh,x
.b984	7d 93 07	adc $0793,x			adc 	SNDAdjustHigh,x
.b987	29 03		and #$03			and 	#3
.b989	9d 83 07	sta $0783,x			sta 	SNDPitchHigh,x
.b98c					_SNDUCUpdate:
.b98c	8a		txa				txa 								; which channel.
.b98d	48		pha				pha
.b98e	20 51 b8	jsr $b851			jsr 	SNDUpdateNote 				; update the current note
.b991	68		pla				pla
.b992	20 12 b8	jsr $b812			jsr 	SNDCheckChannel 			; more to do ?
.b995					_SNDUCExit:
.b995	60		rts				rts

;******  Return to file: _basic.asm


;******  End of listing
