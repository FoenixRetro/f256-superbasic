
; 64tass Turbo Assembler Macro V1.57.2900 listing file
; 64tass -D AUTORUN=0 "-D MONITOR_ADDRESS=\$E000" "-D LOCKOUT_ADDRESS=\$F000" "-D BASIC_ADDRESS=\$38000" "-D SOURCE_ADDRESS=\$3000" "-D SPRITE_ADDRESS=\$30000" -q -b -Wall -c -D "HARDWARE=0 $'\x9'$'\x9'$'\x9'$'\x9'$'\x9'$'\x9'" -L output/basic.lst -l output/basic.lbl -Wall -o basic.rom _basic.asm
; Fri Dec  2 10:23:00 2022

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=0					AUTORUN=0
=$e000					 MONITOR_ADDRESS=$E000
=$f000					 LOCKOUT_ADDRESS=$F000
=$38000					 BASIC_ADDRESS=$38000
=$3000					 SOURCE_ADDRESS=$3000
=$30000					 SPRITE_ADDRESS=$30000
=0					HARDWARE=0

;******  Processing input file: _basic.asm


;******  Processing file: ./common/aa.system/01common.inc

=$30					ZeroPageMandatory = $30
=$50					ZeroPagePreference = $50
=$400					MemoryStorage = $400
=$2000					BasicStart = $2000
=$8000					BasicEnd = $8000
=$8000					CodeStart = $8000
=$1000					VariableSpace = $1000
=$2000					EndVariableSpace = $2000
=8					MathStackSize = 8
=512					BasicStackSize = 512
=3584					BasicStackBase = $1000-BasicStackSize
=80					MaxLineSize = 80

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/02macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/04data.inc

.0030					codePtr:
>0030							.fill 	4
.0034					basicStack:
>0034							.fill 	2
.0036					zTemp0:
>0036							.fill 	2
.0038					zTemp1:
>0038							.fill 	2
.003a					zTemp2:
>003a							.fill 	2
.003c					zsTemp:
>003c							.fill 	2
.003e					zaTemp:
>003e							.fill 	2
=$30					safePtr = codePtr 							; minimise direct tinkering
=$80					NSBIsNegative = $80 						; bit 7 : sign of mantissa (where numeric)
=$20					NSBIsReference = $20 						; bit 5 : is a reference
=$10					NSBIsString = $10 							; bit 4 : set if string (procedures don't go on the stack)
=$18					NSBTypeMask = $18 							; bits 4,3 : 00 int 01 float 10 string 11 procedure
=$03					NSBRefMask = $03 							; bits 0,1 : Bytes of reference, 00 = 4,01 = 1,10=2
=$04					NSBIsArray = $04
=$00					NSTInteger = $00 							; base types for bits 3..4
=$08					NSTFloat = $08
=$10					NSTString = $10
=$18					NSTProcedure = $18
.0050					NSStatus:
>0050							.fill 	MathStackSize
.0058					NSMantissa0:
>0058							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0060					NSMantissa1:
>0060							.fill 	MathStackSize
.0068					NSMantissa2:
>0068							.fill 	MathStackSize
.0070					NSMantissa3:
>0070							.fill 	MathStackSize
.0078					NSExponent:
>0078							.fill 	MathStackSize
.0400					identStart:
>0400							.fill 	1
.0401					identTypeStart:
>0401							.fill 	1
.0402					identTypeEnd:
>0402							.fill 	1
.0403					identHash:
>0403							.fill 	1
.0404					identTypeByte:
>0404							.fill 	1	 						; (see tokenising.pdf)
.0405					encodeState:
>0405							.fill 	1
.0406					digitTemp:
>0406							.fill 	1
.0407					decimalCount:
>0407							.fill 	1
.0408					randomSeed:
>0408							.fill 	4
.040c					lowMemPtr:
>040c							.fill 	2
.040e					stringMemory:
>040e							.fill 	2
.0410					stringInitialised:
>0410							.fill 	1
.0411					stringTempPointer:
>0411							.fill 	2
.0413					breakCheck:
>0413							.fill 	1
.0414					decimalPlaces:
>0414							.fill 	1
.0415					dbOffset:
>0415							.fill 	1
.0416					lastParameter:
>0416							.fill 	1
.0417					dataPointer:
>0417							.fill 	5
.041c					inDataStatement:
>041c							.fill 	1
.041d					tbOffset:
>041d							.fill 	1
.041e					AssemblerAddress:
>041e							.fill 	2
.0420					AssemblerControl:
>0420							.fill 	1
.0421					ParamStart:
>0421							.fill 	2
.0423					IsGroup1:
>0423							.fill 	1
.0424					BaseOpcode:
>0424							.fill 	1
.0425					ModeMask:
>0425							.fill 	1
.0426					listIndent:
>0426							.fill 	1
.0427					lcLastCharacter:
>0427							.fill 	1
.0428					isInputFlag:
>0428							.fill 	1
.0429					currentListColour:
>0429							.fill 	1
.042a					tokenOffset:
>042a							.fill 	1
.042b					tokenLineNumber:
>042b							.fill 	2
.042d					tokenBuffer:
>042d							.fill 	253
.052a					lineBuffer:
>052a							.fill 	MaxLineSize+1
.057b					numberBuffer:
>057b							.fill 	34
.059d					decimalBuffer:
>059d							.fill 	16

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/constants.inc

=$80					AM_ISZP = $80
=$40					AM_ISG1 = $40
=$20					AM_ISG2 = $20
=224					AM_IMMEDIATE = AM_ISZP+AM_ISG1+AM_ISG2+$00
=228					AM_ZEROPAGE = AM_ISZP+AM_ISG1+AM_ISG2+$04
=40					AM_ACC = AM_ISG2+$08
=108					AM_ABS = AM_ISG1+AM_ISG2+$0C
=208					AM_INDY = AM_ISZP+AM_ISG1+$10
=244					AM_ZEROX = AM_ISZP+AM_ISG1+AM_ISG2+$14
=120					AM_ABSY = AM_ISG1+AM_ISG2+$18
=124					AM_ABSX = AM_ISG1+AM_ISG2+$1C
=209					AM_IND = AM_ISZP+AM_ISG1+$11
=$80					AM_ZEROY = AM_ISZP
=$01					AM_INDABS = $01
=$02					AM_INDABSX = $02
=192					AM_INDX = AM_ISZP+AM_ISG1+$00

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/handlers.inc


;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.inc

=1					ERRID_BREAK = 1
=2					ERRID_SYNTAX = 2
=3					ERRID_DIVZERO = 3
=4					ERRID_RANGE = 4
=5					ERRID_TYPE = 5
=6					ERRID_MEMORY = 6
=7					ERRID_ARGUMENT = 7
=8					ERRID_STOP = 8
=9					ERRID_STRING = 9
=10					ERRID_ASSERT = 10
=11					ERRID_DATA = 11
=12					ERRID_NOTDONE = 12
=13					ERRID_LINE = 13
=14					ERRID_GOSUB = 14
=15					ERRID_REPEAT = 15
=16					ERRID_WHILE = 16
=17					ERRID_FOR = 17
=18					ERRID_STACK = 18
=19					ERRID_STRUCT = 19
=20					ERRID_PROC = 20
=21					ERRID_REDEFINE = 21
=22					ERRID_ARRAYSIZE = 22
=23					ERRID_ARRAYIDX = 23

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst.inc

=$00					KWD_LESSLESS                         = $00; $00 <<
=$01					KWD_LESSEQUAL                        = $01; $01 <=
=$02					KWD_LESSGREATER                      = $02; $02 <>
=$03					KWD_PLINGPLING3                      = $03; $03 !!3
=$04					KWD_GREATERLESS                      = $04; $04 ><
=$05					KWD_GREATEREQUAL                     = $05; $05 >=
=$06					KWD_GREATERGREATER                   = $06; $06 >>
=$07					KWD_PLINGPLING7                      = $07; $07 !!7
=$08					KWD_PLINGPLING8                      = $08; $08 !!8
=$09					KWD_PLINGPLING9                      = $09; $09 !!9
=$0a					KWD_PLINGPLING10                     = $0a; $0a !!10
=$0b					KWD_PLINGPLING11                     = $0b; $0b !!11
=$0c					KWD_PLINGPLING12                     = $0c; $0c !!12
=$0d					KWD_PLINGPLING13                     = $0d; $0d !!13
=$0e					KWD_PLINGPLING14                     = $0e; $0e !!14
=$0f					KWD_PLINGPLING15                     = $0f; $0f !!15
=$10					KWD_AT                               = $10; $10 @
=$11					KWD_PLINGPLING17                     = $11; $11 !!17
=$12					KWD_PLINGPLING18                     = $12; $12 !!18
=$13					KWD_LSQPAREN                         = $13; $13 [
=$14					KWD_BACKSLASH                        = $14; $14 \
=$15					KWD_RSQPAREN                         = $15; $15 ]
=$16					KWD_HAT                              = $16; $16 ^
=$17					KWD_UNDERSCORE                       = $17; $17 _
=$18					KWD_BQUOTE                           = $18; $18 `
=$19					KWD_PLINGPLING25                     = $19; $19 !!25
=$1a					KWD_PLINGPLING26                     = $1a; $1a !!26
=$1b					KWD_LCURLY                           = $1b; $1b {
=$1c					KWD_BAR                              = $1c; $1c |
=$1d					KWD_RCURLY                           = $1d; $1d }
=$1e					KWD_TILDE                            = $1e; $1e ~
=$21					KWD_PLING                            = $21; $21 !
=$22					KWD_DQUOTE                           = $22; $22 "
=$23					KWD_HASH                             = $23; $23 #
=$24					KWD_DOLLAR                           = $24; $24 $
=$25					KWD_PERCENT                          = $25; $25 %
=$26					KWD_AMPERSAND                        = $26; $26 &
=$27					KWD_QUOTE                            = $27; $27 '
=$28					KWD_LPAREN                           = $28; $28 (
=$29					KWD_RPAREN                           = $29; $29 )
=$2a					KWD_STAR                             = $2a; $2a *
=$2b					KWD_PLUS                             = $2b; $2b +
=$2c					KWD_COMMA                            = $2c; $2c ,
=$2d					KWD_MINUS                            = $2d; $2d -
=$2e					KWD_PERIOD                           = $2e; $2e .
=$2f					KWD_SLASH                            = $2f; $2f /
=$30					KWD_0                                = $30; $30 0
=$31					KWD_1                                = $31; $31 1
=$32					KWD_2                                = $32; $32 2
=$33					KWD_3                                = $33; $33 3
=$34					KWD_4                                = $34; $34 4
=$35					KWD_5                                = $35; $35 5
=$36					KWD_6                                = $36; $36 6
=$37					KWD_7                                = $37; $37 7
=$38					KWD_8                                = $38; $38 8
=$39					KWD_9                                = $39; $39 9
=$3a					KWD_COLON                            = $3a; $3a :
=$3b					KWD_SEMICOLON                        = $3b; $3b ;
=$3c					KWD_LESS                             = $3c; $3c <
=$3d					KWD_EQUAL                            = $3d; $3d =
=$3e					KWD_GREATER                          = $3e; $3e >
=$3f					KWD_QMARK                            = $3f; $3f ?
=$83					KWD_ABSLPAREN                        = $83; $83 ABS(
=$84					KWD_ALLOCLPAREN                      = $84; $84 ALLOC(
=$85					KWD_ASCLPAREN                        = $85; $85 ASC(
=$86					KWD_CHRDOLLARLPAREN                  = $86; $86 CHR$(
=$87					KWD_DEEKLPAREN                       = $87; $87 DEEK(
=$88					KWD_EVENTLPAREN                      = $88; $88 EVENT(
=$89					KWD_FALSE                            = $89; $89 FALSE
=$8a					KWD_FRACLPAREN                       = $8a; $8a FRAC(
=$8b					KWD_HITLPAREN                        = $8b; $8b HIT(
=$8c					KWD_INTLPAREN                        = $8c; $8c INT(
=$8d					KWD_ISVALLPAREN                      = $8d; $8d ISVAL(
=$8e					KWD_JOYBLPAREN                       = $8e; $8e JOYB(
=$8f					KWD_JOYXLPAREN                       = $8f; $8f JOYX(
=$90					KWD_JOYYLPAREN                       = $90; $90 JOYY(
=$91					KWD_LEFTDOLLARLPAREN                 = $91; $91 LEFT$(
=$92					KWD_LENLPAREN                        = $92; $92 LEN(
=$93					KWD_MAXLPAREN                        = $93; $93 MAX(
=$94					KWD_MIDDOLLARLPAREN                  = $94; $94 MID$(
=$95					KWD_MINLPAREN                        = $95; $95 MIN(
=$96					KWD_NOTLPAREN                        = $96; $96 NOT(
=$97					KWD_PEEKLPAREN                       = $97; $97 PEEK(
=$98					KWD_PLAYINGLPAREN                    = $98; $98 PLAYING(
=$99					KWD_RANDOMLPAREN                     = $99; $99 RANDOM(
=$9a					KWD_RIGHTDOLLARLPAREN                = $9a; $9a RIGHT$(
=$9b					KWD_RNDLPAREN                        = $9b; $9b RND(
=$9c					KWD_SGNLPAREN                        = $9c; $9c SGN(
=$9d					KWD_SPCLPAREN                        = $9d; $9d SPC(
=$9e					KWD_STRDOLLARLPAREN                  = $9e; $9e STR$(
=$9f					KWD_TIMERLPAREN                      = $9f; $9f TIMER(
=$a0					KWD_TRUE                             = $a0; $a0 TRUE
=$a1					KWD_VALLPAREN                        = $a1; $a1 VAL(
=$a2					KWD_FOR                              = $a2; $a2 FOR
=$a3					KWD_IF                               = $a3; $a3 IF
=$a4					KWD_PROC                             = $a4; $a4 PROC
=$a5					KWD_REPEAT                           = $a5; $a5 REPEAT
=$a6					KWD_WHILE                            = $a6; $a6 WHILE
=$a7					KWD_ENDIF                            = $a7; $a7 ENDIF
=$a8					KWD_ENDPROC                          = $a8; $a8 ENDPROC
=$a9					KWD_NEXT                             = $a9; $a9 NEXT
=$aa					KWD_THEN                             = $aa; $aa THEN
=$ab					KWD_UNTIL                            = $ab; $ab UNTIL
=$ac					KWD_WEND                             = $ac; $ac WEND
=$ad					KWD_BY                               = $ad; $ad BY
=$ae					KWD_CALL                             = $ae; $ae CALL
=$af					KWD_CIRCLE                           = $af; $af CIRCLE
=$b0					KWD_CLEAR                            = $b0; $b0 CLEAR
=$b1					KWD_CLS                              = $b1; $b1 CLS
=$b2					KWD_COLOR                            = $b2; $b2 COLOR
=$b3					KWD_COLOUR                           = $b3; $b3 COLOUR
=$b4					KWD_DATA                             = $b4; $b4 DATA
=$b5					KWD_DIM                              = $b5; $b5 DIM
=$b6					KWD_DOKE                             = $b6; $b6 DOKE
=$b7					KWD_DOWNTO                           = $b7; $b7 DOWNTO
=$b8					KWD_ELSE                             = $b8; $b8 ELSE
=$b9					KWD_FROM                             = $b9; $b9 FROM
=$ba					KWD_GFX                              = $ba; $ba GFX
=$bb					KWD_GOSUB                            = $bb; $bb GOSUB
=$bc					KWD_GOTO                             = $bc; $bc GOTO
=$bd					KWD_HERE                             = $bd; $bd HERE
=$be					KWD_IMAGE                            = $be; $be IMAGE
=$bf					KWD_INPUT                            = $bf; $bf INPUT
=$c0					KWD_LET                              = $c0; $c0 LET
=$c1					KWD_LINE                             = $c1; $c1 LINE
=$c2					KWD_LOCAL                            = $c2; $c2 LOCAL
=$c3					KWD_OFF                              = $c3; $c3 OFF
=$c4					KWD_ON                               = $c4; $c4 ON
=$c5					KWD_OUTLINE                          = $c5; $c5 OUTLINE
=$c6					KWD_PALETTE                          = $c6; $c6 PALETTE
=$c7					KWD_PLOT                             = $c7; $c7 PLOT
=$c8					KWD_POKE                             = $c8; $c8 POKE
=$c9					KWD_PRINT                            = $c9; $c9 PRINT
=$ca					KWD_READ                             = $ca; $ca READ
=$cb					KWD_RECT                             = $cb; $cb RECT
=$cc					KWD_REM                              = $cc; $cc REM
=$cd					KWD_RETURN                           = $cd; $cd RETURN
=$ce					KWD_SOLID                            = $ce; $ce SOLID
=$cf					KWD_SOUND                            = $cf; $cf SOUND
=$d0					KWD_SPRITE                           = $d0; $d0 SPRITE
=$d1					KWD_TEXT                             = $d1; $d1 TEXT
=$d2					KWD_TO                               = $d2; $d2 TO

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst0.inc

=$80					KWC_EOL = $80
=$ff					KWC_STRING = $FF
=$fe					KWC_HEXCONST = $FE
=$a2					KWC_FIRST_STRUCTURE = $a2
=$a7					KWC_FIRST_STRUCTURE_DEC = $a7
=$ac					KWC_LAST_STRUCTURE = $ac
=$83					KWC_FIRST_UNARY = $83
=$a1					KWC_LAST_UNARY = $a1

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/access.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/stack.inc

=$e0					STK_GOSUB = $E0
=$d0					STK_FOR = $D0
=$c0					STK_REPEAT = $C0
=$b0					STK_PROC = $B0
=$a0					STK_WHILE = $A0
=$01					STK_LOCALN = $01
=$02					STK_LOCALS = $02

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/00start.asm

.8000	4c 24 80	jmp $8024	Boot:	jmp 	Start

;******  Processing file: ./common/aa.system/../../../modules/_build/_linker.module

=0					PagingEnabled = 0
.8003					EXTPrintCharacter:
.8003	4c e6 a7	jmp $a7e6		jmp	Export_EXTPrintCharacter
.8006					EXTInitialise:
.8006	4c 7f aa	jmp $aa7f		jmp	Export_EXTInitialise
.8009					EXTInputSingleCharacter:
.8009	4c b5 aa	jmp $aab5		jmp	Export_EXTInputSingleCharacter
.800c					EXTBreakCheck:
.800c	4c db aa	jmp $aadb		jmp	Export_EXTBreakCheck
.800f					EXTReadController:
.800f	4c de aa	jmp $aade		jmp	Export_EXTReadController
.8012					EXTInputLine:
.8012	4c 95 a9	jmp $a995		jmp	Export_EXTInputLine
.8015					GXGraphicDraw:
.8015	4c 79 ab	jmp $ab79		jmp	Export_GXGraphicDraw
.8018					SNDCommand:
.8018	4c 63 be	jmp $be63		jmp	Export_SNDCommand
.801b					SNDUpdate:
.801b	4c 96 be	jmp $be96		jmp	Export_SNDUpdate
.801e					TKListConvertLine:
.801e	4c 59 b8	jmp $b859		jmp	Export_TKListConvertLine
.8021					TKTokeniseLine:
.8021	4c ed ba	jmp $baed		jmp	Export_TKTokeniseLine

;******  Return to file: ./common/aa.system/00start.asm

.8024	a2 ff		ldx #$ff	Start:	ldx 	#$FF 						; stack reset
.8026	9a		txs				txs
.8027	20 06 80	jsr $8006			jsr 	EXTInitialise 				; hardware initialise
.802a	a9 00		lda #$00			lda 	#0 							; graphics system initialise.
.802c	aa		tax				tax
.802d	a8		tay				tay
.802e	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.8031	a9 0f		lda #$0f			lda 	#$0F 						; initialise sound system
.8033	20 18 80	jsr $8018			jsr 	SNDCommand
.8036	a2 80		ldx #$80			ldx 	#Prompt >> 8 				; display prompt
.8038	a9 46		lda #$46			lda 	#Prompt & $FF
.803a	20 53 8f	jsr $8f53			jsr 	PrintStringXA
.803d	20 ca 89	jsr $89ca			jsr 	NewProgram 					; erase current program
.8040	4c 78 83	jmp $8378			jmp 	WarmStart					; make same size.
.8043	4c 78 83	jmp $8378			jmp 	WarmStart
>8046	46 32 35 36 20 42 41 53		Prompt:	.text 	"F256 BASIC "
>804e	49 43 20

;******  Processing file: ./common/aa.system/../generated/timestamp.asm

>8051	52 65 6c 65 61 73 65 20			.text "Release Alpha 9 (01-Dec-22). "
>8059	41 6c 70 68 61 20 39 20 28 30 31 2d 44 65 63 2d
>8069	32 32 29 2e 20

;******  Return to file: ./common/aa.system/00start.asm

>806e	0d 0d 00					.text 	13,13,0

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/assembler.asm

.8071					AssembleGroup1:
.8071	a9 ff		lda #$ff			lda 	#$FF
.8073	8d 25 04	sta $0425			sta 	ModeMask 					; initialise the mode mask - all for all
.8076	80 02		bra $807a			bra 	AsmGroup12
.8078					AssembleGroup2:
.8078	a9 00		lda #$00			lda 	#$00
.807a					AsmGroup12:
.807a	8d 23 04	sta $0423			sta 	IsGroup1 					; save the 'group 1' flag
.807d	68		pla				pla 								; pop the return address to access the information following.
.807e	fa		plx				plx
.807f	20 06 81	jsr $8106			jsr 	AccessParameters 			; get opcode and save as base
.8082	8d 24 04	sta $0424			sta 	BaseOpcode
.8085	ad 23 04	lda $0423			lda 	IsGroup1 					; skip if group 1 as we don't have a complex mask.
.8088	d0 08		bne $8092			bne 	_AG12HaveMask
.808a	a9 02		lda #$02			lda 	#2 							; if group 2 the second parameter is the mask
.808c	20 0e 81	jsr $810e			jsr 	GetParameter		 		; e.g. which modes are supported for this operand
.808f	8d 25 04	sta $0425			sta 	ModeMask
.8092					_AG12HaveMask:
.8092	20 42 82	jsr $8242			jsr 	TypeAndCalculateOperand 	; get zero page type
.8095	da		phx				phx 								; save found address mode
.8096	20 72 81	jsr $8172			jsr 	AssembleModeX
.8099	fa		plx				plx  								; restore address mode
.809a	b0 0b		bcs $80a7			bcs 	_AG12Exit
.809c	20 a8 80	jsr $80a8			jsr 	PromoteToAbsolute  			; promote ZP to ABS and try that
.809f	20 72 81	jsr $8172			jsr 	AssembleModeX
.80a2	b0 03		bcs $80a7			bcs 	_AG12Exit
.80a4	4c 9a 9f	jmp $9f9a			jmp 	SyntaxError 				; can't do either, so must be wrong mode/operand.
.80a7					_AG12Exit:
.80a7	60		rts				rts
.80a8					PromoteToAbsolute:
.80a8	a9 6c		lda #$6c			lda 	#AM_ABS 					; lda xx
.80aa	e0 e4		cpx #$e4			cpx 	#AM_ZEROPAGE
.80ac	f0 19		beq $80c7			beq 	_PTADo
.80ae	a9 7c		lda #$7c			lda 	#AM_ABSX 					; lda xx,X
.80b0	e0 f4		cpx #$f4			cpx 	#AM_ZEROX
.80b2	f0 13		beq $80c7			beq 	_PTADo
.80b4	a9 78		lda #$78			lda 	#AM_ABSY 					; lda xx,Y
.80b6	e0 80		cpx #$80			cpx 	#AM_ZEROY
.80b8	f0 0d		beq $80c7			beq 	_PTADo
.80ba	a9 01		lda #$01			lda 	#AM_INDABS 					; lda (xx) (jump)
.80bc	e0 d1		cpx #$d1			cpx 	#AM_IND
.80be	f0 07		beq $80c7			beq 	_PTADo
.80c0	a9 02		lda #$02			lda 	#AM_INDABSX 				; lda (xx,x) (jump)
.80c2	e0 c0		cpx #$c0			cpx 	#AM_INDX
.80c4	f0 01		beq $80c7			beq 	_PTADo
.80c6	60		rts				rts
.80c7					_PTADo:
.80c7	aa		tax				tax
.80c8	60		rts				rts
.80c9					AssembleGroup3:
.80c9	68		pla				pla 								; get parameters, which is just the opcode.
.80ca	fa		plx				plx
.80cb	20 06 81	jsr $8106			jsr 	AccessParameters 			; get and output opcode
.80ce	20 1e 81	jsr $811e			jsr 	AssemblerWriteByte
.80d1	20 a6 82	jsr $82a6			jsr 	CalculateOperand 			; get a 16 bit operand
.80d4	a5 58		lda $58				lda 	NSMantissa0 				; calculate the offset
.80d6	38		sec				sec
.80d7	ed 1e 04	sbc $041e			sbc 	AssemblerAddress
.80da	48		pha				pha 								; LSB in A
.80db	a5 60		lda $60				lda 	NSMantissa1
.80dd	ed 1f 04	sbc $041f			sbc 	AssemblerAddress+1
.80e0	aa		tax				tax 								; MSB in X
.80e1	68		pla				pla
.80e2	18		clc				clc 								; $80 to easy check $80-$7F, plus 1 for offset error
.80e3	69 7f		adc #$7f			adc 	#$7F
.80e5	90 01		bcc $80e8			bcc 	_AG3NoCarry
.80e7	e8		inx				inx
.80e8					_AG3NoCarry:
.80e8	38		sec				sec 								; fix back and write out anyways.
.80e9	e9 80		sbc #$80			sbc 	#$80
.80eb	20 1e 81	jsr $811e			jsr 	AssemblerWriteByte
.80ee	e0 00		cpx #$00			cpx 	#0 							; was it in range
.80f0	f0 0a		beq $80fc			beq 	_AG3Exit
.80f2	ad 20 04	lda $0420			lda 	AssemblerControl 			; are we allowing bad values ?
.80f5	29 01		and #$01			and 	#1
.80f7	f0 03		beq $80fc			beq 	_AG3Exit
.80f9	4c 9f 9f	jmp $9f9f			jmp 	RangeError 					; no, branch is out of range
.80fc					_AG3Exit:
.80fc	60		rts				rts
.80fd					AssembleGroup4:
.80fd	68		pla				pla 								; pop address
.80fe	fa		plx				plx
.80ff	20 06 81	jsr $8106			jsr 	AccessParameters 			; access and get first
.8102	20 1e 81	jsr $811e			jsr 	AssemblerWriteByte 			; output it.
.8105	60		rts				rts
.8106					AccessParameters:
.8106	8d 21 04	sta $0421			sta 	ParamStart
.8109	8e 22 04	stx $0422			stx 	ParamStart+1
.810c	a9 01		lda #$01			lda 	#1
.810e					GetParameter:
.810e	5a		phy				phy
.810f	a8		tay				tay
.8110	ad 21 04	lda $0421			lda 	ParamStart
.8113	85 36		sta $36				sta 	zTemp0
.8115	ad 22 04	lda $0422			lda 	ParamStart+1
.8118	85 37		sta $37				sta 	zTemp0+1
.811a	b1 36		lda ($36),y			lda 	(zTemp0),y
.811c	7a		ply				ply
.811d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/aswrite.asm

.811e					AssemblerWriteByte:
.811e	48		pha			pha
.811f	ad 20 04	lda $0420		lda 	AssemblerControl 				; check printing bytes ?
.8122	29 02		and #$02		and 	#2
.8124	f0 1b		beq $8141		beq 	_AWBNoPrint
.8126	ad 1f 04	lda $041f		lda		AssemblerAddress+1 				; print address
.8129	20 5c 81	jsr $815c		jsr 	PrintHex
.812c	ad 1e 04	lda $041e		lda		AssemblerAddress
.812f	20 5c 81	jsr $815c		jsr 	PrintHex
.8132	a9 20		lda #$20		lda 	#' '
.8134	20 03 80	jsr $8003		jsr 	EXTPrintCharacter
.8137	68		pla			pla 									; print byte
.8138	48		pha			pha
.8139	20 5c 81	jsr $815c		jsr 	PrintHex
.813c	a9 0d		lda #$0d		lda 	#13
.813e	20 03 80	jsr $8003		jsr 	EXTPrintCharacter
.8141					_AWBNoPrint:
.8141	ad 1e 04	lda $041e		lda		AssemblerAddress				; copy address to zTemp0
.8144	85 36		sta $36			sta 	zTemp0
.8146	ad 1f 04	lda $041f		lda		AssemblerAddress+1
.8149	f0 0e		beq $8159		beq 	_AWBRange
.814b	85 37		sta $37			sta 	zTemp0+1
.814d	68		pla			pla 									; write byte out
.814e	92 36		sta ($36)		sta 	(zTemp0)
.8150	ee 1e 04	inc $041e		inc 	AssemblerAddress 				; bump address
.8153	d0 03		bne $8158		bne 	_AWBNoCarry
.8155	ee 1f 04	inc $041f		inc 	AssemblerAddress+1
.8158					_AWBNoCarry:
.8158	60		rts			rts
.8159					_AWBRange:
.8159	4c 9f 9f	jmp $9f9f		jmp 	RangeError
.815c					PrintHex:
.815c	48		pha				pha
.815d	4a		lsr a				lsr 	a
.815e	4a		lsr a				lsr 	a
.815f	4a		lsr a				lsr 	a
.8160	4a		lsr a				lsr 	a
.8161	20 65 81	jsr $8165			jsr 	_PrintNibble
.8164	68		pla				pla
.8165					_PrintNibble:
.8165	29 0f		and #$0f			and 	#15
.8167	c9 0a		cmp #$0a			cmp 	#10
.8169	90 02		bcc $816d			bcc 	_NoShift
.816b	69 06		adc #$06			adc 	#6
.816d					_NoShift:
.816d	69 30		adc #$30			adc 	#48
.816f	4c 03 80	jmp $8003			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/instruction.asm

.8172					AssembleModeX:
.8172	5a		phy				phy
.8173	ad 23 04	lda $0423			lda 	IsGroup1
.8176	f0 17		beq $818f			beq 	_AMXGroup2
.8178	8a		txa				txa 							; is it in group # 1
.8179	29 40		and #$40			and 	#AM_ISG1
.817b	f0 4d		beq $81ca			beq 	_AMXFail 				; no, give up.
.817d	8a		txa				txa 							; get back.
.817e	29 1f		and #$1f			and 	#$1F 					; this is now the offset.
.8180	e0 e0		cpx #$e0			cpx 	#AM_IMMEDIATE 			; if not immediate, we can continue.
.8182	d0 22		bne $81a6			bne 	_AMXHaveInfo
.8184	ad 24 04	lda $0424			lda 	BaseOpcode 				; cannot store immediate.
.8187	c9 81		cmp #$81			cmp 	#$81
.8189	f0 3f		beq $81ca			beq 	_AMXFail
.818b	a9 08		lda #$08			lda 	#8 						; if immediate we use offset 8.
.818d	80 17		bra $81a6			bra 	_AMXHaveInfo 			; odd design decision there.
.818f					_AMXGroup2:
.818f	8a		txa				txa 							; is it in group 2 ?
.8190	29 20		and #$20			and 	#AM_ISG2
.8192	f0 36		beq $81ca			beq 	_AMXFail 				; no, give up.
.8194	8a		txa				txa 							; get the offset into Y
.8195	29 1f		and #$1f			and 	#$1F
.8197	4a		lsr a				lsr 	a 						; make it 0-7.
.8198	4a		lsr a				lsr  	a
.8199	a8		tay				tay
.819a	ad 25 04	lda $0425			lda 	ModeMask 				; shift the modemask left so you can check it against the requested offset
.819d					_AMXCheckOkay:
.819d	0a		asl a				asl 	a 						; shift modemask left enough times to check legitimate.
.819e	88		dey				dey
.819f	10 fc		bpl $819d			bpl 	_AMXCheckOkay
.81a1	90 27		bcc $81ca			bcc 	_AMXFail 				; not allowed.
.81a3	8a		txa				txa  							; get mask back
.81a4	29 1f		and #$1f			and 	#$1F
.81a6					_AMXHaveInfo:
.81a6	e0 00		cpx #$00			cpx 	#$00 					; does it *require* an 8 bit operand
.81a8	10 04		bpl $81ae			bpl 	_AMXAnySize 			; checking bit 7, the zero page opcode flag.
.81aa	a4 60		ldy $60				ldy 	NSMantissa1 			; fail if it is outside range, e.g. the MSB is set.
.81ac	d0 1c		bne $81ca			bne 	_AMXFail
.81ae					_AMXAnySize:
.81ae	18		clc				clc 							; add offset to the base opcode
.81af	6d 24 04	adc $0424			adc 	BaseOpcode
.81b2					_AMXOutputCode:
.81b2	20 1e 81	jsr $811e			jsr 	AssemblerWriteByte 		; write the opcode out.
.81b5	e0 28		cpx #$28			cpx 	#AM_ACC 				; A mode (e.g. ASL A)
.81b7	f0 0e		beq $81c7			beq 	_AMXExit
.81b9	a5 58		lda $58				lda 	NSMantissa0 				; write LSB operand
.81bb	20 1e 81	jsr $811e			jsr 	AssemblerWriteByte
.81be	e0 00		cpx #$00			cpx 	#$00 					; zeropage ?
.81c0	30 05		bmi $81c7			bmi 	_AMXExit
.81c2	a5 60		lda $60				lda 	NSMantissa1 			; write MSB operand
.81c4	20 1e 81	jsr $811e			jsr 	AssemblerWriteByte
.81c7					_AMXExit:
.81c7	7a		ply				ply
.81c8	38		sec				sec
.81c9	60		rts				rts
.81ca					_AMXFail:
.81ca	a0 00		ldy #$00			ldy 	#0
.81cc					_AMXCheckOddities:
.81cc	8a		txa				txa
.81cd	d9 f4 81	cmp $81f4,y			cmp 	ExtraOpcode+2,y 		; match address mode
.81d0	d0 15		bne $81e7			bne 	_AMXCONext
.81d2	b9 f2 81	lda $81f2,y			lda 	ExtraOpcode+0,y 		; do the base opcodes match
.81d5	cd 24 04	cmp $0424			cmp 	BaseOpcode
.81d8	d0 0d		bne $81e7			bne 	_AMXCONext
.81da	e0 00		cpx #$00			cpx 	#$00 					; requires zero page ?
.81dc	10 04		bpl $81e2			bpl 	_AMXCONotZero
.81de	a5 60		lda $60				lda 	NSMantissa1
.81e0	d0 05		bne $81e7			bne 	_AMXCONext
.81e2					_AMXCONotZero:
.81e2	b9 f3 81	lda $81f3,y			lda 	ExtraOpcode+1,y 		; get new opcode
.81e5	80 cb		bra $81b2			bra 	_AMXOutputCode 			; and assemble it
.81e7					_AMXCONext:
.81e7	c8		iny				iny
.81e8	c8		iny				iny
.81e9	c8		iny				iny
.81ea	b9 f2 81	lda $81f2,y			lda 	ExtraOpcode+0,y 		; end of table
.81ed	d0 dd		bne $81cc			bne 	_AMXCheckOddities
.81ef					_AMXCOFail:
.81ef	7a		ply				ply
.81f0	18		clc				clc
.81f1	60		rts				rts
.81f2					ExtraOpcode:
>81f2	40 6c 01					.byte $40,$6c,AM_INDABS 	; jump
>81f5	40 7c 02					.byte $40,$7C,AM_INDABSX 	; jump
>81f8	a2 be 78					.byte $a2,$BE,AM_ABSY 		; ldx
>81fb	a2 b6 80					.byte $a2,$B6,AM_ZEROY 		; ldx
>81fe	82 96 80					.byte $82,$96,AM_ZEROY 		; stx
>8201	e2 1a 28					.byte $e2,$1a,AM_ACC 		; inc
>8204	c2 3a 28					.byte $c2,$3a,AM_ACC 		; dec
>8207	20 89 e0					.byte $20,$89,AM_IMMEDIATE 	; bit
>820a	60 9c 6c					.byte $60,$9c,AM_ABS 		; stz
>820d	60 9e 7c					.byte $60,$9e,AM_ABSX 		; stz
>8210	00						.byte $00

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/label.asm

.8211					LabelHere:
.8211	c8		iny				iny 								; skip .
.8212	a2 00		ldx #$00			ldx 	#0 							; get a term
.8214	20 48 98	jsr $9848			jsr 	EvaluateTerm 				; get a term
.8217	a5 50		lda $50				lda 	NSStatus 					; needs to be an integer reference.
.8219	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.821b	d0 22		bne $823f			bne 	_ALType
.821d	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy reference address to zTemp0
.821f	85 36		sta $36				sta 	zTemp0
.8221	b5 60		lda $60,x			lda 	NSMantissa1,x
.8223	85 37		sta $37				sta 	zTemp0+1
.8225	5a		phy				phy 								; copy address in.
.8226	a0 01		ldy #$01			ldy 	#1
.8228	ad 1e 04	lda $041e			lda	 	AssemblerAddress
.822b	92 36		sta ($36)			sta 	(zTemp0)
.822d	ad 1f 04	lda $041f			lda	 	AssemblerAddress+1
.8230	91 36		sta ($36),y			sta 	(zTemp0),y
.8232	c8		iny				iny
.8233	a9 00		lda #$00			lda 	#0
.8235	91 36		sta ($36),y			sta 	(zTemp0),y
.8237	c8		iny				iny
.8238	91 36		sta ($36),y			sta 	(zTemp0),y
.823a	c8		iny				iny
.823b	91 36		sta ($36),y			sta 	(zTemp0),y
.823d	7a		ply				ply
.823e	60		rts				rts
.823f					_ALType:
.823f	4c a4 9f	jmp $9fa4			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/operands.asm

.8242					TypeAndCalculateOperand:
.8242	b1 30		lda ($30),y			lda 	(codePtr),y
.8244	a2 28		ldx #$28			ldx 	#AM_ACC 					; ACC if : or EOL
.8246	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.8248	f0 5b		beq $82a5			beq 	_TACOExit
.824a	c9 80		cmp #$80			cmp 	#KWC_EOL
.824c	f0 57		beq $82a5			beq 	_TACOExit
.824e	c8		iny				iny
.824f	a2 e0		ldx #$e0			ldx 	#AM_IMMEDIATE
.8251	c9 23		cmp #$23			cmp 	#KWD_HASH 					; if hash, then immediate - constant.
.8253	f0 51		beq $82a6			beq 	CalculateOperand
.8255	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; if ( then check for indirection
.8257	f0 1f		beq $8278			beq 	_TACOIndirect
.8259	88		dey				dey 								; undo get of first character
.825a	20 a6 82	jsr $82a6			jsr 	CalculateOperand 			; get operand
.825d	b1 30		lda ($30),y			lda 	(codePtr),y
.825f	a2 e4		ldx #$e4			ldx 	#AM_ZEROPAGE 				; if not, try zero page (then absolute)
.8261	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8263	d0 40		bne $82a5			bne 	_TACOExit
.8265	c8		iny				iny
.8266	20 b0 82	jsr $82b0			jsr 	TACOCheckXY 				; extract X,Y or 0 (neither) from the variable.
.8269	a2 f4		ldx #$f4			ldx 	#AM_ZEROX 					; check for X
.826b	c9 58		cmp #$58			cmp 	#'X'
.826d	f0 36		beq $82a5			beq 	_TACOExit
.826f	a2 80		ldx #$80			ldx 	#AM_ZEROY 					; check for Y
.8271	c9 59		cmp #$59			cmp 	#'Y'
.8273	f0 30		beq $82a5			beq 	_TACOExit
.8275					_TACOSyntax:
.8275	4c 9a 9f	jmp $9f9a			jmp 	SyntaxError
.8278					_TACOIndirect:
.8278	20 a6 82	jsr $82a6			jsr 	CalculateOperand 			; get the operand
.827b	b1 30		lda ($30),y			lda 	(codePtr),y
.827d	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if , then it must be ,X)
.827f	f0 17		beq $8298			beq 	_TACOIndX
.8281	20 e1 8e	jsr $8ee1			jsr 	CheckRightBracket  			; otherwise must be ) or ),Y
.8284	b1 30		lda ($30),y			lda 	(codePtr),y
.8286	a2 d1		ldx #$d1			ldx 	#AM_IND
.8288	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not comma then exit with (xx)
.828a	d0 19		bne $82a5			bne 	_TACOExit
.828c	c8		iny				iny
.828d	20 b0 82	jsr $82b0			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.8290	c9 59		cmp #$59			cmp 	#'Y' 						; check Y
.8292	d0 e1		bne $8275			bne 	_TACOSyntax
.8294	a2 d0		ldx #$d0			ldx 	#AM_INDY
.8296	80 0d		bra $82a5			bra 	_TACOExit
.8298					_TACOIndX:
.8298	c8		iny				iny
.8299	20 b0 82	jsr $82b0			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.829c	c9 58		cmp #$58			cmp 	#'X' 						; check X
.829e	d0 d5		bne $8275			bne 	_TACOSyntax
.82a0	20 e1 8e	jsr $8ee1			jsr 	CheckRightBracket			; check )
.82a3	a2 c0		ldx #$c0			ldx 	#AM_INDX
.82a5					_TACOExit:
.82a5	60		rts				rts
.82a6					CalculateOperand:
.82a6	48		pha				pha
.82a7	da		phx				phx
.82a8	a2 00		ldx #$00			ldx 	#0 							; get 16 bit integer in Slot 0
.82aa	20 9c 9d	jsr $9d9c			jsr 	Evaluate16BitInteger
.82ad	fa		plx				plx
.82ae	68		pla				pla
.82af	60		rts				rts
.82b0					TACOCheckXY:
.82b0	b1 30		lda ($30),y			lda 	(codePtr),y
.82b2	29 c0		and #$c0			and 	#$C0 						; check it is an identifier reference.
.82b4	c9 40		cmp #$40			cmp 	#$40
.82b6	d0 21		bne $82d9			bne 	_TCXYFail
.82b8	b1 30		lda ($30),y			lda 	(codePtr),y
.82ba	18		clc				clc
.82bb	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.82bd	85 37		sta $37				sta 	zTemp0+1
.82bf	c8		iny				iny
.82c0	b1 30		lda ($30),y			lda 	(codePtr),y
.82c2	c8		iny				iny
.82c3	85 36		sta $36				sta 	zTemp0
.82c5	5a		phy				phy 								; save position
.82c6	a0 02		ldy #$02			ldy 	#2 							; type is integer ?
.82c8	b1 36		lda ($36),y			lda 	(zTemp0),y
.82ca	d0 0c		bne $82d8			bne 	_TCXYPopFail
.82cc	a0 08		ldy #$08			ldy 	#8 							; get first character, should have bit 7 set as also last.
.82ce	b1 36		lda ($36),y			lda 	(zTemp0),y
.82d0	c9 d8		cmp #$d8			cmp 	#'X'+$80 					; should be X or Y
.82d2	f0 08		beq $82dc			beq 	_TCXYFound
.82d4	c9 d9		cmp #$d9			cmp 	#'Y'+$80
.82d6	f0 04		beq $82dc			beq 	_TCXYFound
.82d8					_TCXYPopFail:
.82d8	7a		ply				ply
.82d9					_TCXYFail:
.82d9	a9 00		lda #$00			lda 	#0
.82db	60		rts				rts
.82dc					_TCXYFound:
.82dc	7a		ply				ply 								; restore position
.82dd	29 7f		and #$7f			and 	#$7F 						; throw bit 7
.82df	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/backload.asm

.82e0					BackloadProgram:
.82e0	a2 83		ldx #$83			ldx 	#_BLLoad >> 8
.82e2	a9 27		lda #$27			lda 	#_BLLoad & $FF
.82e4	20 53 8f	jsr $8f53			jsr 	PrintStringXA
.82e7	a9 00		lda #$00			lda 	#((SOURCE_ADDRESS) & $FF)
.82e9	8d ad 05	sta $05ad			sta 	0+BackLoadPointer
.82ec	a9 30		lda #$30			lda 	#((SOURCE_ADDRESS) >> 8)
.82ee	8d ae 05	sta $05ae			sta 	1+BackLoadPointer
.82f1	a9 ff		lda #$ff			lda 	#$FF
.82f3	8d fa ff	sta $fffa			sta 	$FFFA
.82f6					_BPLoop:
.82f6	a2 ff		ldx #$ff			ldx 	#$FF
.82f8	20 3c 83	jsr $833c			jsr 	BLReadByte 					; read a byte
.82fb	c9 00		cmp #$00			cmp 	#0
.82fd	f0 21		beq $8320			beq 	_BPExit 					; if 0 exit
.82ff	30 1f		bmi $8320			bmi 	_BPExit 					; if -ve exit
.8301					_BPCopy:
.8301	e8		inx				inx  								; copy byte into the lineBuffer
.8302	9d 2a 05	sta $052a,x			sta 	lineBuffer,x
.8305	9e 2b 05	stz $052b,x			stz 	lineBuffer+1,x
.8308	20 3c 83	jsr $833c			jsr 	BLReadByte 					; read next byte
.830b	30 0a		bmi $8317			bmi 	_BPEndLine 					; -ve = EOL
.830d	c9 09		cmp #$09			cmp 	#9 							; handle TAB, make it space.
.830f	d0 02		bne $8313			bne 	_BPNotTab
.8311	a9 20		lda #$20			lda 	#' '
.8313					_BPNotTab:
.8313	c9 20		cmp #$20			cmp 	#' ' 						; < ' ' = EOL
.8315	b0 ea		bcs $8301			bcs 	_BPCopy 					; until a control character, should be 13 received.
.8317					_BPEndLine:
.8317	20 21 80	jsr $8021			jsr 	TKTokeniseLine 				; tokenise the line.
.831a	38		sec				sec 								; append not insert
.831b	20 e4 a4	jsr $a4e4			jsr 	MemoryInsertLine 			; append to current program
.831e	80 d6		bra $82f6			bra 	_BPLoop
.8320					_BPExit:
.8320	9c fa ff	stz $fffa			stz 	$FFFA
.8323	20 0e 84	jsr $840e			jsr 	ClearCommand 				; clear variables etc.
.8326	60		rts				rts
.8327					_BLLoad:
>8327	4c 6f 61 64 69 6e 67 20				.text 	"Loading from Memory",13,0
>832f	66 72 6f 6d 20 4d 65 6d 6f 72 79 0d 00
.833c					BLReadByte:
.833c	ad ad 05	lda $05ad			lda 	BackLoadPointer 			; copy pointer to zTemp0
.833f	85 36		sta $36				sta 	zTemp0
.8341	ad ae 05	lda $05ae			lda 	BackLoadPointer+1
.8344	85 37		sta $37				sta 	zTemp0+1
.8346	b2 36		lda ($36)			lda 	(zTemp0) 					; read next byte
.8348	ee ad 05	inc $05ad			inc 	BackLoadPointer 			; bump pointer
.834b	d0 03		bne $8350			bne 	_BLNoCarry
.834d	ee ae 05	inc $05ae			inc 	BackLoadPointer+1
.8350					_BLNoCarry:
.8350	c9 00		cmp #$00			cmp 	#0
.8352	60		rts				rts
.05ad					BackLoadPointer:
>05ad							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/editor.asm

.8353					EditProgramCode:
.8353	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; try to find the line.
.8356	ae 2c 04	ldx $042c			ldx 	TokenLineNumber+1
.8359	20 88 a5	jsr $a588			jsr 	MemorySearch
.835c	90 05		bcc $8363			bcc 	_EPCNoDelete 				; reached the end : don't delete
.835e	d0 03		bne $8363			bne 	_EPCNoDelete 				; found slot but didn't match : no delete
.8360	20 ad a4	jsr $a4ad			jsr 	MemoryDeleteLine 			; delete the line
.8363					_EPCNoDelete:
.8363	ad 2d 04	lda $042d			lda 	TokenBuffer 				; buffer empty - we just want to delete a line.
.8366	c9 80		cmp #$80			cmp 	#KWC_EOL
.8368	f0 0d		beq $8377			beq 	_EPCNoInsert
.836a	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; find the line - it cannot exist as we've just deleted it.
.836d	ae 2c 04	ldx $042c			ldx 	TokenLineNumber+1 			; so this can't fail, it returns some point in the code.
.8370	20 88 a5	jsr $a588			jsr 	MemorySearch
.8373	18		clc				clc 								; insert at this point.
.8374	20 e4 a4	jsr $a4e4			jsr 	MemoryInsertLine 			; insert the line
.8377					_EPCNoInsert:
.8377	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/warmstart.asm

.8378					WarmStart:
.8378	a2 ff		ldx #$ff			ldx 	#$FF
.837a	9a		txs				txs
.837b	a9 85		lda #$85			lda 	#CLICommandLine+$80 		; set console colour whatever the current colour is.
.837d	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8380	20 12 80	jsr $8012			jsr 	EXTInputLine 				; get line to lineBuffer
.8383	20 21 80	jsr $8021			jsr 	TKTokeniseLine 				; tokenise the line
.8386	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; line number <> 0
.8389	0d 2c 04	ora $042c			ora 	TokenLineNumber+1
.838c	d0 17		bne $83a5			bne 	_WSEditCode 				; if so,edit code.
.838e	9c 2a 04	stz $042a			stz 	TokenOffset 				; zero the "offset", meaning it only runs one line.
.8391	a9 2a		lda #$2a			lda 	#((TokenOffset) & $FF)
.8393	85 30		sta $30				sta 	codePtr
.8395	a9 04		lda #$04			lda 	#((TokenOffset) >> 8)
.8397	85 31		sta $31				sta 	codePtr+1
.8399	ad 2d 04	lda $042d			lda 	TokenBuffer 				; nothing to run
.839c	c9 80		cmp #$80			cmp 	#KWC_EOL
.839e	f0 d8		beq $8378			beq 	WarmStart
.83a0	20 1d 8b	jsr $8b1d			jsr 	RUNCodePointerLine 			; execute that line.
.83a3	80 d3		bra $8378			bra 	WarmStart
.83a5					_WSEditCode:
.83a5	20 53 83	jsr $8353			jsr 	EditProgramCode 			; edit the program code
.83a8	20 0e 84	jsr $840e			jsr 	ClearCommand 				; clear all variables etc.
.83ab	80 cb		bra $8378			bra 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assemble.asm

.83ad					AssembleCommand:
.83ad	a2 00		ldx #$00			ldx 	#0
.83af	20 9c 9d	jsr $9d9c			jsr 	Evaluate16BitInteger 		; start address
.83b2	a5 58		lda $58				lda 	NSMantissa0
.83b4	8d 1e 04	sta $041e			sta 	AssemblerAddress
.83b7	a5 60		lda $60				lda 	NSMantissa1
.83b9	8d 1f 04	sta $041f			sta 	AssemblerAddress+1
.83bc	20 e9 8e	jsr $8ee9			jsr 	CheckComma
.83bf	20 b7 9d	jsr $9db7			jsr 	Evaluate8BitInteger 		; options 0-3
.83c2	a5 58		lda $58				lda 	NSMantissa0
.83c4	8d 20 04	sta $0420			sta 	AssemblerControl
.83c7	60		rts				rts
.83c8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assert.asm

.83c9					AssertCommand:
.83c9	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.83cb	20 89 9d	jsr $9d89			jsr 	EvaluateInteger 			; the assert test
.83ce	20 3e 9e	jsr $9e3e			jsr 	NSMIsZero 					; exit if result is non zero.
.83d1	d0 05		bne $83d8			bne 	_ACExit
.83d3	a9 0a		lda #$0a		lda	#10
.83d5	4c fa 8e	jmp $8efa		jmp	ErrorHandler
.83d8					_ACExit:
.83d8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/call.asm

.83d9					CallCommand:
.83d9	a2 00		ldx #$00			ldx 	#0 							; get the routine address to level 0
.83db	20 9c 9d	jsr $9d9c			jsr 	Evaluate16BitInteger
.83de					_CCClear
.83de	e8		inx				inx  								; clear 1,2 and 3 (for A X Y)
.83df	20 1c 9e	jsr $9e1c			jsr 	NSMSetZero 					; these are optional sequentially.
.83e2	e0 04		cpx #$04			cpx 	#4
.83e4	d0 f8		bne $83de			bne 	_CCClear
.83e6	a2 00		ldx #$00			ldx 	#0 							; and keep trying while there are more values.
.83e8					_CCCParam:
.83e8	b1 30		lda ($30),y			lda 	(codePtr),y
.83ea	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.83ec	d0 09		bne $83f7			bne 	_CCCRun6502
.83ee	c8		iny				iny 								; skip comma
.83ef	e8		inx				inx	 								; next level
.83f0	20 b7 9d	jsr $9db7			jsr 	Evaluate8BitInteger 		; get A/X/Y
.83f3	e0 03		cpx #$03			cpx 	#3
.83f5	90 f1		bcc $83e8			bcc 	_CCCParam 					; done all 3 ?
.83f7					_CCCRun6502:
.83f7	5a		phy				phy 								; save position
.83f8	a5 60		lda $60				lda 	NSMantissa1 				; put address in zTemp0
.83fa	85 37		sta $37				sta 	zTemp0+1
.83fc	a5 58		lda $58				lda 	NSMantissa0
.83fe	85 36		sta $36				sta 	zTemp0
.8400	a5 59		lda $59				lda 	NSMantissa0+1 				; get registers into A X Y
.8402	a6 5a		ldx $5a				ldx 	NSMantissa0+2
.8404	a4 5b		ldy $5b				ldy 	NSMantissa0+3
.8406	20 0b 84	jsr $840b			jsr 	_CCCZTemp0 					; call zTemp0
.8409	7a		ply				ply 								; restore position and exit
.840a	60		rts				rts
.840b					_CCCZTemp0:
.840b	6c 36 00	jmp ($0036)			jmp 	(zTemp0)

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/clear.asm

.840e					ClearCommand:
.840e	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.8410	85 36		sta $36				sta 	0+zTemp0
.8412	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.8414	85 37		sta $37				sta 	1+zTemp0
.8416					_ClearZeroLoop:
.8416	b2 36		lda ($36)			lda 	(zTemp0) 					; end of variables if offset is zero.
.8418	f0 24		beq $843e			beq 	_ClearZeroEnd
.841a	a0 03		ldy #$03			ldy 	#3 							; erase the variables
.841c	a9 00		lda #$00			lda 	#0 							; set all the data to zero.
.841e					_ClearOneVariable:
.841e	91 36		sta ($36),y			sta 	(zTemp0),y
.8420	c8		iny				iny
.8421	c0 08		cpy #$08			cpy 	#8
.8423	d0 f9		bne $841e			bne 	_ClearOneVariable
.8425	a0 02		ldy #$02			ldy 	#2 							; has it been marked procedure
.8427	b1 36		lda ($36),y			lda 	(zTemp0),y
.8429	c9 18		cmp #$18			cmp 	#NSTProcedure
.842b	d0 04		bne $8431			bne 	_ClearNotProcedure
.842d	a9 04		lda #$04			lda 	#NSTInteger+NSBIsArray 		; if so set it back to an integer array
.842f	91 36		sta ($36),y			sta 	(zTemp0),y 					; will be fixed on the pre-run scan.
.8431					_ClearNotProcedure:
.8431	18		clc				clc 								; go to the next variable
.8432	b2 36		lda ($36)			lda 	(zTemp0) 					; offset to next, add to zTemp0
.8434	65 36		adc $36				adc 	zTemp0
.8436	85 36		sta $36				sta 	zTemp0
.8438	90 dc		bcc $8416			bcc 	_ClearZeroLoop
.843a	e6 37		inc $37				inc 	zTemp0+1
.843c	80 d8		bra $8416			bra 	_ClearZeroLoop
.843e					_ClearZeroEnd:
.843e	18		clc				clc
.843f	a5 36		lda $36				lda 	zTemp0
.8441	69 01		adc #$01			adc 	#1
.8443	8d 0c 04	sta $040c			sta 	lowMemPtr
.8446	a5 37		lda $37				lda 	zTemp0+1
.8448	69 00		adc #$00			adc 	#0
.844a	8d 0d 04	sta $040d			sta 	lowMemPtr+1
.844d	20 14 a7	jsr $a714			jsr 	StackReset
.8450	20 7a a7	jsr $a77a			jsr 	StringSystemInitialise
.8453	20 87 8d	jsr $8d87			jsr 	ProcedureScan
.8456	20 cc 8a	jsr $8acc			jsr 	Command_Restore
.8459	9c 1e 04	stz $041e			stz 	AssemblerAddress
.845c	9c 1f 04	stz $041f			stz 	AssemblerAddress+1
.845f	9c 20 04	stz $0420			stz 	AssemblerControl
.8462	20 2f 9a	jsr $9a2f			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.8465	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/cls.asm

.8466					ClearScreen:
.8466	5a		phy				phy
.8467	a9 0c		lda #$0c			lda 	#12 						; char code 12 clears the screen.
.8469	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.846c	7a		ply				ply
.846d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/data.asm

.846e					Command_Data:
.846e	a9 3a		lda #$3a			lda 	#KWD_COLON 					; advance to colon/EOL, e.g. ignore anything till then.
.8470	a2 80		ldx #$80			ldx 	#KWC_EOL
.8472	20 d9 8d	jsr $8dd9			jsr 	ScanForward
.8475	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dim.asm

.8476					DimCommand:
.8476	b1 30		lda ($30),y			lda 	(codePtr),y
.8478	29 c0		and #$c0			and 	#$C0
.847a	c9 40		cmp #$40			cmp 	#$40
.847c	d0 7a		bne $84f8			bne 	_DCSyntax 				; n o, error.
.847e	b1 30		lda ($30),y			lda 	(codePtr),y
.8480	18		clc				clc
.8481	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8483	85 3f		sta $3f				sta 	zaTemp+1
.8485	c8		iny				iny
.8486	b1 30		lda ($30),y			lda 	(codePtr),y
.8488	c8		iny				iny
.8489	85 3e		sta $3e				sta 	zaTemp
.848b	5a		phy				phy
.848c	a0 02		ldy #$02			ldy 	#2 						; read type byte
.848e	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8490	29 18		and #$18			and 	#NSBTypeMask 			; check it's not a procedure
.8492	c9 18		cmp #$18			cmp 	#NSTProcedure
.8494	f0 62		beq $84f8			beq 	_DCSyntax
.8496	b1 3e		lda ($3e),y			lda 	(zaTemp),y 				; check it's an array
.8498	29 04		and #$04			and 	#NSBIsArray
.849a	f0 64		beq $8500			beq 	_DCType
.849c	a0 04		ldy #$04			ldy 	#4 						; check not already defined
.849e	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84a0	d0 59		bne $84fb			bne 	_DCRedefine
.84a2	7a		ply				ply
.84a3	20 03 85	jsr $8503			jsr 	_DCGetSize 				; get array size, check it.
.84a6	5a		phy				phy
.84a7	a0 05		ldy #$05			ldy 	#5 						; store in first array size slot
.84a9	91 3e		sta ($3e),y			sta 	(zaTemp),y 				; second will be zero.
.84ab	7a		ply				ply 							; is there a second (e.g. ,x)
.84ac	b1 30		lda ($30),y			lda 	(codePtr),y
.84ae	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.84b0	d0 0a		bne $84bc			bne 	_DCOneDimension
.84b2	c8		iny				iny 							; skip comma
.84b3	20 03 85	jsr $8503			jsr 	_DCGetSize 				; get 2nd array size
.84b6	5a		phy				phy
.84b7	a0 06		ldy #$06			ldy 	#6 						; store in 2nd array size
.84b9	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84bb	7a		ply				ply
.84bc					_DCOneDimension:
.84bc	5a		phy				phy 							; save position
.84bd	a0 05		ldy #$05			ldy 	#5 						; dimensions + 1 in AX (as zero based)
.84bf	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84c1	aa		tax				tax
.84c2	c8		iny				iny
.84c3	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84c5	e8		inx				inx 							; bump them.
.84c6	1a		inc a				inc 	a
.84c7	20 c7 9d	jsr $9dc7			jsr 	Multiply8x8 			; work out the total number of elements -> zTemp0
.84ca	a5 37		lda $37				lda 	zTemp0+1 				; don't allow more than 8192 elements whatever
.84cc	29 e0		and #$e0			and 	#$E0
.84ce	d0 23		bne $84f3			bne 	_DCSize
.84d0	a0 02		ldy #$02			ldy 	#2 						; get base type
.84d2	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84d4	20 11 85	jsr $8511			jsr 	ScaleByBaseType 		; scale by base type
.84d7	a5 36		lda $36				lda 	zTemp0
.84d9	a6 37		ldx $37				ldx 	zTemp0+1
.84db	20 f1 99	jsr $99f1			jsr 	AllocateXABytes 		; allocate memory
.84de	a0 03		ldy #$03			ldy 	#3 						; copy into the address.
.84e0	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84e2	c8		iny				iny
.84e3	8a		txa				txa
.84e4	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84e6	7a		ply				ply 							; get position back
.84e7	20 e1 8e	jsr $8ee1			jsr 	CheckRightBracket 		; check )
.84ea	b1 30		lda ($30),y			lda 	(codePtr),y
.84ec	c8		iny				iny 							; consume in case
.84ed	c9 2c		cmp #$2c			cmp 	#KWD_COMMA		 		; if so do another DIM.
.84ef	f0 85		beq $8476			beq 	DimCommand
.84f1	88		dey				dey 							; undo consume
.84f2	60		rts				rts
.84f3					_DCSize:
.84f3	a9 16		lda #$16		lda	#22
.84f5	4c fa 8e	jmp $8efa		jmp	ErrorHandler
.84f8					_DCSyntax:
.84f8	4c 9a 9f	jmp $9f9a			jmp 	SyntaxError
.84fb					_DCRedefine:
.84fb	a9 15		lda #$15		lda	#21
.84fd	4c fa 8e	jmp $8efa		jmp	ErrorHandler
.8500					_DCType:
.8500	4c a4 9f	jmp $9fa4			jmp 	TypeError
.8503					_DCGetSize:
.8503	a2 00		ldx #$00			ldx 	#0 						; get first index.
.8505	20 b7 9d	jsr $9db7			jsr 	Evaluate8BitInteger 	; get array dimension
.8508	c9 00		cmp #$00			cmp 	#0 						; must be 1-254
.850a	f0 e7		beq $84f3			beq 	_DCSize
.850c	c9 fe		cmp #$fe			cmp 	#254
.850e	f0 e3		beq $84f3			beq 	_DCSize
.8510	60		rts				rts
.8511					ScaleByBaseType:
.8511	29 10		and #$10			and 	#NSBIsString 			; is it string
.8513	d0 19		bne $852e			bne 	_SBBTString
.8515	a5 37		lda $37				lda 	zTemp0+1 				; push value on stack
.8517	48		pha				pha
.8518	a5 36		lda $36				lda 	zTemp0
.851a	48		pha				pha
.851b	06 36		asl $36				asl 	zTemp0 					; x 2
.851d	26 37		rol $37				rol 	zTemp0+1
.851f	06 36		asl $36				asl 	zTemp0 					; x 4
.8521	26 37		rol $37				rol 	zTemp0+1
.8523	68		pla				pla 							; add stacked value = x 5
.8524	65 36		adc $36				adc 	zTemp0
.8526	85 36		sta $36				sta 	zTemp0
.8528	68		pla				pla
.8529	65 37		adc $37				adc 	zTemp0+1
.852b	85 37		sta $37				sta 	zTemp0+1
.852d	60		rts				rts
.852e					_SBBTString:
.852e	06 36		asl $36				asl 	zTemp0
.8530	26 37		rol $37				rol 	zTemp0+1
.8532	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dokepoke.asm

.8533					PokeCommand:
.8533	18		clc				clc
.8534	80 01		bra $8537			bra 	DPCommand
.8536					DokeCommand:
.8536	38		sec				sec
.8537					DPCommand:
.8537	08		php				php									; save on stack, CS = Doke, CC = Poke
.8538	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.853a	20 9c 9d	jsr $9d9c			jsr		Evaluate16BitInteger 		; address
.853d	20 e9 8e	jsr $8ee9			jsr 	CheckComma
.8540	e8		inx				inx
.8541	20 9c 9d	jsr $9d9c			jsr		Evaluate16BitInteger 		; data
.8544	a5 58		lda $58				lda 	NSMantissa0 				; copy address
.8546	85 36		sta $36				sta 	zTemp0
.8548	a5 60		lda $60				lda 	NSMantissa1
.854a	85 37		sta $37				sta 	zTemp0+1
.854c	a5 59		lda $59				lda 	NSMantissa0+1 				; low byte
.854e	92 36		sta ($36)			sta 	(zTemp0)
.8550	28		plp				plp 								; done if POKE
.8551	90 08		bcc $855b			bcc 	_DPExit
.8553	5a		phy				phy 								; write high byte out.
.8554	a0 01		ldy #$01			ldy 	#1
.8556	a5 61		lda $61				lda 	NSMantissa1+1
.8558	91 36		sta ($36),y			sta 	(zTemp0),y
.855a	7a		ply				ply
.855b					_DPExit:
.855b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/end.asm

.855c					EndCommand:
.855c	4c 78 83	jmp $8378			jmp 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/for.asm

.855f					ForCommand:
.855f	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; allocate 18 bytes on the return stack (see above).
.8561	20 ae a6	jsr $a6ae			jsr 	StackOpen
.8564	a2 00		ldx #$00			ldx 	#0
.8566	20 48 98	jsr $9848			jsr 	EvaluateTerm
.8569	b5 50		lda $50,x			lda 	NSStatus,x
.856b	c9 20		cmp #$20			cmp 	#NSBIsReference+NSTInteger 	; do we have an integer 4 byte reference.
.856d	d0 47		bne $85b6			bne		_FCError
.856f	a9 3d		lda #$3d			lda 	#KWD_EQUAL 					; =
.8571	20 f1 8e	jsr $8ef1			jsr 	CheckNextA
.8574	e8		inx				inx
.8575	20 89 9d	jsr $9d89			jsr 	EvaluateInteger 			; <from> in +1
.8578	b1 30		lda ($30),y			lda 	(codePtr),y
.857a	c8		iny				iny 								; consume it
.857b	48		pha				pha 								; save on stack for later
.857c	c9 b7		cmp #$b7			cmp 	#KWD_DOWNTO
.857e	f0 04		beq $8584			beq 	_FCNoSyntax
.8580	c9 d2		cmp #$d2			cmp 	#KWD_TO
.8582	d0 35		bne $85b9			bne 	_FCSyntaxError
.8584					_FCNoSyntax:
.8584	e8		inx				inx
.8585	20 89 9d	jsr $9d89			jsr 	EvaluateInteger
.8588	20 f3 a6	jsr $a6f3			jsr 	STKSaveCodePosition 		; save loop back position
.858b	68		pla				pla 								; restore DOWNTO or TO
.858c	5a		phy				phy 								; save Y on the stack
.858d	49 b7		eor #$b7			eor 	#KWD_DOWNTO 				; 0 if DOWNTO, #0 if TO
.858f	f0 02		beq $8593			beq 	_FCNotDownTo
.8591	a9 02		lda #$02			lda 	#2
.8593					_FCNotDownTo:
.8593	3a		dec a				dec 	a 							; 255 if DOWNTO, 1 if TO
.8594	a0 10		ldy #$10			ldy 	#16
.8596	91 34		sta ($34),y			sta 	(basicStack),y 				; copy that out to the Basic Stack.
.8598	a0 06		ldy #$06			ldy 	#6 							; this is the address of the loop variable.
.859a	a5 58		lda $58				lda 	NSMantissa0
.859c	91 34		sta ($34),y			sta 	(basicStack),y
.859e	a5 60		lda $60				lda 	NSMantissa1
.85a0	c8		iny				iny
.85a1	91 34		sta ($34),y			sta 	(basicStack),y
.85a3	a0 08		ldy #$08			ldy 	#8 							; set initial index value
.85a5	a2 01		ldx #$01			ldx 	#1
.85a7	20 bc 85	jsr $85bc			jsr 	FCIntegerToStack
.85aa	a0 0c		ldy #$0c			ldy 	#12 						; set the terminal value
.85ac	a2 02		ldx #$02			ldx 	#2
.85ae	20 bc 85	jsr $85bc			jsr 	FCIntegerToStack
.85b1	20 d7 85	jsr $85d7			jsr 	CopyIndexToReference
.85b4	7a		ply				ply 								; restore position
.85b5	60		rts				rts
.85b6					_FCError:
.85b6	4c a4 9f	jmp $9fa4			jmp 	TypeError
.85b9					_FCSyntaxError:
.85b9	4c 9a 9f	jmp $9f9a			jmp 	SyntaxError
.85bc					FCIntegerToStack:
.85bc	34 50		bit $50,x			bit 	NSStatus,x 					; is the value negative
.85be	10 03		bpl $85c3			bpl	 	_FCNotNegative
.85c0	20 e5 9d	jsr $9de5			jsr 	NSMNegateMantissa 			; if so 2's complement the mantissa
.85c3					_FCNotNegative:
.85c3	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy out to the basic stack
.85c5	91 34		sta ($34),y			sta 	(basicStack),y
.85c7	c8		iny				iny
.85c8	b5 60		lda $60,x			lda 	NSMantissa1,x
.85ca	91 34		sta ($34),y			sta 	(basicStack),y
.85cc	c8		iny				iny
.85cd	b5 68		lda $68,x			lda 	NSMantissa2,x
.85cf	91 34		sta ($34),y			sta 	(basicStack),y
.85d1	c8		iny				iny
.85d2	b5 70		lda $70,x			lda 	NSMantissa3,x
.85d4	91 34		sta ($34),y			sta 	(basicStack),y
.85d6	60		rts				rts
.85d7					CopyIndexToReference:
.85d7	5a		phy				phy
.85d8	a0 06		ldy #$06			ldy 	#6 							; copy address-8 to write to zTemp0
.85da	38		sec				sec 								; (because we copy from offset 8)
.85db	b1 34		lda ($34),y			lda 	(basicStack),y
.85dd	e9 08		sbc #$08			sbc 	#8
.85df	85 36		sta $36				sta 	zTemp0
.85e1	c8		iny				iny
.85e2	b1 34		lda ($34),y			lda 	(basicStack),y
.85e4	e9 00		sbc #$00			sbc 	#0
.85e6	85 37		sta $37				sta 	zTemp0+1
.85e8	a2 04		ldx #$04			ldx 	#4 							; this is the copy counter/
.85ea	a0 0b		ldy #$0b			ldy 	#8+3 		 				; the MSB of the mantissa
.85ec	b1 34		lda ($34),y			lda 	(basicStack),y
.85ee	0a		asl a				asl 	a 							; into carry
.85ef	a0 08		ldy #$08			ldy 	#8 							; where to copy from.
.85f1	90 14		bcc $8607			bcc 	_CITRNormal
.85f3	38		sec				sec
.85f4					_CITRNegative:
.85f4	a9 00		lda #$00			lda 	#0
.85f6	f1 34		sbc ($34),y			sbc 	(basicStack),y
.85f8	91 36		sta ($36),y			sta 	(zTemp0),y
.85fa	c8		iny				iny
.85fb	ca		dex				dex
.85fc	d0 f6		bne $85f4			bne 	_CITRNegative
.85fe	88		dey				dey 								; look at MSB of mantissa
.85ff	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set the MSB as negative packed.
.8601	09 80		ora #$80			ora 	#$80
.8603	91 36		sta ($36),y			sta 	(zTemp0),y
.8605	7a		ply				ply
.8606	60		rts				rts
.8607					_CITRNormal:
.8607	b1 34		lda ($34),y			lda 	(basicStack),y 				; copy without negation.
.8609	91 36		sta ($36),y			sta 	(zTemp0),y
.860b	c8		iny				iny
.860c	ca		dex				dex
.860d	d0 f8		bne $8607			bne 	_CITRNormal
.860f	7a		ply				ply 								; and exit.
.8610	60		rts				rts
.8611					NextCommand:
.8611	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; check FOR is TOS
.8613	a2 11		ldx #$11			ldx 	#ERRID_FOR 					; this error
.8615	20 db a6	jsr $a6db			jsr 	StackCheckFrame
.8618	5a		phy				phy
.8619	a0 10		ldy #$10			ldy 	#16 						; get the step count
.861b	b1 34		lda ($34),y			lda 	(basicStack),y
.861d	85 36		sta $36				sta 	zTemp0 						; this is the sign extend
.861f	30 02		bmi $8623			bmi 	_NCStepNeg
.8621	64 36		stz $36				stz 	zTemp0 						; which is 0 or 255
.8623					_NCStepNeg:
.8623	a0 08		ldy #$08			ldy 	#8 							; offset to bump
.8625	a2 04		ldx #$04			ldx 	#4 							; count to bump
.8627	18		clc				clc
.8628					_NCBump:
.8628	71 34		adc ($34),y			adc 	(basicStack),y 				; add it
.862a	91 34		sta ($34),y			sta 	(basicStack),y
.862c	a5 36		lda $36				lda 	zTemp0 						; get sign extend for next time.
.862e	c8		iny				iny 								; next byte
.862f	ca		dex				dex 								; do four times
.8630	d0 f6		bne $8628			bne 	_NCBump
.8632	20 d7 85	jsr $85d7			jsr		CopyIndexToReference		; copy it to the reference variable.
.8635	a0 10		ldy #$10			ldy 	#16 						; get step count again
.8637	b1 34		lda ($34),y			lda 	(basicStack),y
.8639	0a		asl a				asl 	a 							; sign bit to carry
.863a	a9 0c		lda #$0c			lda 	#12 						; offset of LHS = terminal offset
.863c	85 38		sta $38				sta 	zTemp1
.863e	90 02		bcc $8642			bcc 	_NCCompRev 					; use if step is +ve
.8640	a9 08		lda #$08			lda 	#8 							; now the LHS = index value
.8642					_NCCompRev:
.8642	85 38		sta $38				sta 	zTemp1 						; so zTemp0 is the index for LHS
.8644	49 04		eor #$04			eor 	#(8^12) 					; and zTemp0+1 is the index for RHS
.8646	85 39		sta $39				sta 	zTemp1+1
.8648	a2 04		ldx #$04			ldx 	#4 							; bytes to compare
.864a	38		sec				sec
.864b					_NCCompare:
.864b	a4 38		ldy $38				ldy 	zTemp1 						; do compare using the two indices
.864d	b1 34		lda ($34),y			lda 	(basicStack),y
.864f	a4 39		ldy $39				ldy 	zTemp1+1
.8651	f1 34		sbc ($34),y			sbc 	(basicStack),y
.8653	e6 38		inc $38				inc 	zTemp1 						; bump the indices (inc,dex do not change C or V)
.8655	e6 39		inc $39				inc 	zTemp1+1
.8657	ca		dex				dex 								; do it 4 times.
.8658	d0 f1		bne $864b			bne 	_NCCompare
.865a	50 02		bvc $865e			bvc 	_NCNoOverflow 				; convert to signed comparison
.865c	49 80		eor #$80			eor 	#$80
.865e					_NCNoOverflow:
.865e	7a		ply				ply 								; restore Y position
.865f	0a		asl a				asl 	a 							; is bit 7 set.
.8660	90 04		bcc $8666			bcc 	_NCLoopback 				; if no , >= so loop back
.8662	20 cd a6	jsr $a6cd			jsr 	StackClose 					; exit the loop
.8665	60		rts				rts
.8666					_NCLoopBack:
.8666	20 04 a7	jsr $a704			jsr 	STKLoadCodePosition 		; loop back
.8669	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/gosub.asm

.866a					Command_GOSUB:
.866a	a2 00		ldx #$00			ldx 	#0
.866c	20 9c 9d	jsr $9d9c			jsr 	Evaluate16BitInteger 		; line number in Stack.0
.866f	a9 e3		lda #$e3			lda 	#STK_GOSUB+3
.8671	20 ae a6	jsr $a6ae			jsr 	StackOpen 					; create frame
.8674	20 f3 a6	jsr $a6f3			jsr 	STKSaveCodePosition 		; save current position
.8677	4c 8d 86	jmp $868d			jmp 	GotoStackX
.867a					Command_RETURN:
.867a	a9 e0		lda #$e0			lda 	#STK_GOSUB 					; check TOS is this
.867c	a2 0e		ldx #$0e			ldx 	#ERRID_GOSUB 				; this error
.867e	20 db a6	jsr $a6db			jsr 	StackCheckFrame
.8681	20 04 a7	jsr $a704			jsr 	STKLoadCodePosition 		; restore code position
.8684	20 cd a6	jsr $a6cd			jsr 	StackClose
.8687	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/goto.asm

.8688					GotoCommand:
.8688	a2 00		ldx #$00			ldx 	#0 							; GOTO where
.868a	20 9c 9d	jsr $9d9c			jsr 	Evaluate16BitInteger
.868d					GotoStackX:
.868d	b5 60		lda $60,x			lda  	NSMantissa1,x 				; put line # in XA. I'll keep this even though
.868f	48		pha				pha 								; it is slightly inefficient, just in cases.
.8690	b5 58		lda $58,x			lda 	NSMantissa0,x
.8692	fa		plx				plx
.8693	20 88 a5	jsr $a588			jsr 	MemorySearch 				; transfer to line number AX.
.8696	90 05		bcc $869d			bcc 	_GotoError 					; not found, off end.
.8698	d0 03		bne $869d			bne 	_GotoError 					; not found exactly
.869a	4c 16 8b	jmp $8b16			jmp 	RunNewLine 					; and go straight to new line code.
.869d					_GotoError:
.869d	a9 0d		lda #$0d		lda	#13
.869f	4c fa 8e	jmp $8efa		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/if.asm

.86a2					IfCommand:
.86a2	a2 00		ldx #$00			ldx 	#0 							; Get the if test.
.86a4	20 6a 9d	jsr $9d6a			jsr 	EvaluateNumber
.86a7	b1 30		lda ($30),y			lda 	(codePtr),y
.86a9	c9 aa		cmp #$aa			cmp 	#KWD_THEN  					; could be THEN <stuff>
.86ab	d0 0a		bne $86b7			bne 	_IFStructured 				; we still support it.
.86ad	c8		iny				iny 								; consume THEN
.86ae	20 3e 9e	jsr $9e3e			jsr 	NSMIsZero 					; is it zero
.86b1	f0 01		beq $86b4			beq 	_IfFail 					; if fail, go to next line
.86b3	60		rts				rts 								; if THEN just continue
.86b4					_IfFail:
.86b4	4c fe 8a	jmp $8afe			jmp 	EOLCommand
.86b7					_IfStructured:
.86b7	20 3e 9e	jsr $9e3e			jsr 	NSMIsZero 					; is it zero
.86ba	d0 07		bne $86c3			bne 	_IfExit 					; if not, then continue normally.
.86bc	a9 b8		lda #$b8			lda 	#KWD_ELSE 					; look for else/endif
.86be	a2 a7		ldx #$a7			ldx 	#KWD_ENDIF
.86c0	20 d9 8d	jsr $8dd9			jsr 	ScanForward 				; and run from there
.86c3					_IfExit:
.86c3	60		rts				rts
.86c4					ElseCode:
.86c4	a9 a7		lda #$a7			lda 	#KWD_ENDIF 					; else is only run after the if clause succeeds
.86c6	aa		tax				tax 								; so just go to the structure exit
.86c7	20 d9 8d	jsr $8dd9			jsr 	ScanForward
.86ca	60		rts				rts
.86cb					EndIf:
.86cb	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/inputprint.asm

.86cc					Command_Input:
.86cc	a9 ff		lda #$ff			lda 	#$FF 						; set input flag
.86ce	8d 28 04	sta $0428			sta 	IsInputFlag
.86d1	80 03		bra $86d6			bra 	Command_IP_Main
.86d3					Command_Print:
.86d3	9c 28 04	stz $0428			stz 	IsInputFlag 				; clear input flag
.86d6					Command_IP_Main:
.86d6	18		clc				clc 								; carry being clear means last print wasn't comma/semicolon
.86d7					_CPLoop:
.86d7	08		php				php 								; save last action flag
.86d8	b1 30		lda ($30),y			lda 	(codePtr),y
.86da	c9 80		cmp #$80			cmp  	#KWC_EOL 					; end of line or colon, exit now.
.86dc	f0 54		beq $8732			beq 	_CPExit
.86de	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.86e0	f0 50		beq $8732			beq 	_CPExit
.86e2	68		pla				pla 								; throw last action flag
.86e3	b1 30		lda ($30),y			lda 	(codePtr),y
.86e5	c8		iny				iny
.86e6	c9 3b		cmp #$3b			cmp 	#KWD_SEMICOLON				; is it a semicolon
.86e8	f0 45		beq $872f			beq 	_CPContinueWithSameLine
.86ea	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; comma
.86ec	f0 3c		beq $872a			beq 	_CPTab
.86ee	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; apostrophe (new line)
.86f0	f0 34		beq $8726			beq 	_CPNewLine
.86f2	88		dey				dey 								; undo the get.
.86f3	20 fc 93	jsr $93fc			jsr 	EvaluateExpressionAt0 		; evaluate expression at 0.
.86f6	b5 50		lda $50,x			lda 	NSStatus,x 					; read the status
.86f8	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.86fa	f0 0d		beq $8709			beq 	_CPIsValue 					; no, display it.
.86fc	ad 28 04	lda $0428			lda 	IsInputFlag 				; if print, dereference and print.
.86ff	f0 05		beq $8706			beq 	_CPIsPrint 					; otherwise display.
.8701	20 3b 87	jsr $873b			jsr 	CIInputValue 				; input a value to the reference
.8704	80 20		bra $8726			bra 	_CPNewLine
.8706					_CPIsPrint:
.8706	20 c1 96	jsr $96c1			jsr 	Dereference 				; dereference if required.
.8709					_CPIsValue:
.8709	b5 50		lda $50,x			lda 	NSStatus,x 					; is it a number
.870b	29 10		and #$10			and 	#NSBIsString
.870d	f0 09		beq $8718			beq 	_CPNumber
.870f	a6 60		ldx $60				ldx 	NSMantissa1 				; string, print the text.
.8711	a5 58		lda $58				lda 	NSMantissa0
.8713	20 9e 87	jsr $879e			jsr 	CPPrintStringXA
.8716	80 be		bra $86d6			bra 	Command_IP_Main 			; loop round clearing carry so NL if end
.8718					_CPNumber:
.8718	a9 05		lda #$05			lda 	#5 							; maximum decimals
.871a	20 51 9c	jsr $9c51			jsr 	ConvertNumberToString 		; convert to string (in unary str$() function)
.871d	a2 05		ldx #$05			ldx 	#DecimalBuffer >> 8
.871f	a9 9d		lda #$9d			lda 	#DecimalBuffer & $FF
.8721	20 9e 87	jsr $879e			jsr 	CPPrintStringXA 			; print it.
.8724	80 b0		bra $86d6			bra 	Command_IP_Main				; loop round clearing carry so NL if end
.8726					_CPNewLine:
.8726	a9 0d		lda #$0d			lda 	#13
.8728	80 02		bra $872c			bra 	_CPPrintChar
.872a					_CPTab:
.872a	a9 09		lda #$09			lda 	#9 							; print TAB
.872c					_CPPrintChar:
.872c	20 b1 87	jsr $87b1			jsr 	CPPrintVector
.872f					_CPContinueWithSameLine:
.872f	38		sec				sec 								; loop round with carry set, which
.8730	80 a5		bra $86d7			bra 	_CPLoop 					; will inhibit final CR
.8732					_CPExit:
.8732	28		plp				plp 								; get last action flag
.8733	b0 05		bcs $873a			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.8735	a9 0d		lda #$0d			lda 	#13 						; print new line
.8737	20 b1 87	jsr $87b1			jsr 	CPPrintVector
.873a					_CPExit2:
.873a	60		rts				rts
.873b					CIInputValue:
.873b	a2 00		ldx #$00			ldx 	#0 							; input a line.
.873d					_CIInputLine:
.873d	20 b4 87	jsr $87b4			jsr 	CPInputVector 				; get key
.8740	c9 0d		cmp #$0d			cmp 	#13 						; 13 = End
.8742	f0 1f		beq $8763			beq 	_CIHaveValue
.8744	c9 08		cmp #$08			cmp 	#8 							; 8 = BS
.8746	f0 11		beq $8759			beq 	_CIBackspace
.8748	c9 20		cmp #$20			cmp 	#32 						; ignore other control characters
.874a	90 f1		bcc $873d			bcc 	_CIInputLine
.874c	e0 50		cpx #$50			cpx 	#80 						; max length
.874e	b0 ed		bcs $873d			bcs 	_CIInputLine
.8750	9d 2a 05	sta $052a,x			sta 	lineBuffer,x
.8753	e8		inx				inx
.8754	20 b1 87	jsr $87b1			jsr 	CPPrintVector 				; echo it.
.8757	80 e4		bra $873d			bra 	_CIInputLine
.8759					_CIBackSpace:
.8759	e0 00		cpx #$00			cpx 	#0 							; nothing to delete
.875b	f0 e0		beq $873d			beq 	_CIInputLine
.875d	20 b1 87	jsr $87b1			jsr 	CPPrintVector 				; echo it.
.8760	ca		dex				dex
.8761	80 da		bra $873d			bra 	_CIInputLine
.8763					_CIHaveValue:
.8763	9e 2a 05	stz $052a,x			stz 	LineBuffer,x 				; ASCIIZ string now in line buffer.
.8766	a5 50		lda $50				lda 	NSStatus 					; was it a string assignment
.8768	29 10		and #$10			and 	#NSBIsString
.876a	f0 17		beq $8783			beq 	_CIAssignNumber 			; assign a number
.876c	a2 01		ldx #$01			ldx 	#1
.876e	a9 2a		lda #$2a			lda 	#lineBuffer & $FF 			; set up to point to new string
.8770	95 58		sta $58,x			sta 	NSMantissa0,x
.8772	a9 05		lda #$05			lda 	#lineBuffer >> 8
.8774	95 60		sta $60,x			sta 	NSMantissa1,x
.8776	74 68		stz $68,x			stz 	NSMantissa2,x
.8778	74 70		stz $70,x			stz 	NSMantissa3,x
.877a	a9 10		lda #$10			lda 	#NSBIsString 				; so it becomes a string value
.877c	95 50		sta $50,x			sta  	NSStatus,x
.877e	ca		dex				dex 								; X = 0
.877f	20 f0 87	jsr $87f0			jsr 	AssignVariable
.8782	60		rts				rts
.8783					_CIAssignNumber:
.8783	a9 2a		lda #$2a			lda 	#lineBuffer & $FF 			; set up to point to new string
.8785	85 36		sta $36				sta 	zTemp0
.8787	a9 05		lda #$05			lda 	#lineBuffer >> 8
.8789	85 37		sta $37				sta 	zTemp0+1
.878b	a2 01		ldx #$01			ldx 	#1 							; put in slot 1
.878d	20 d3 9b	jsr $9bd3			jsr 	ValEvaluateZTemp0 			; use the VAL() code
.8790	90 07		bcc $8799			bcc 	_CIIsOkay
.8792	a9 3f		lda #$3f			lda 	#"?" 						; error ?
.8794	20 b1 87	jsr $87b1			jsr 	CPPrintVector
.8797	80 a2		bra $873b			bra 	CIInputValue
.8799					_CIIsOkay:
.8799	ca		dex				dex 								; X = 0
.879a	20 f0 87	jsr $87f0			jsr 	AssignVariable
.879d	60		rts				rts
.879e					CPPrintStringXA:
.879e	5a		phy				phy
.879f	86 37		stx $37				stx 	zTemp0+1
.87a1	85 36		sta $36				sta 	zTemp0
.87a3	a0 00		ldy #$00			ldy 	#0
.87a5					_PSXALoop:
.87a5	b1 36		lda ($36),y			lda 	(zTemp0),y
.87a7	f0 06		beq $87af			beq 	_PSXAExit
.87a9	20 b1 87	jsr $87b1			jsr 	CPPrintVector
.87ac	c8		iny				iny
.87ad	80 f6		bra $87a5			bra 	_PSXALoop
.87af					_PSXAExit:
.87af	7a		ply				ply
.87b0	60		rts				rts
.87b1					CPPrintVector:
.87b1	4c 03 80	jmp $8003			jmp 	EXTPrintCharacter
.87b4					CPInputVector:
.87b4	4c 09 80	jmp $8009			jmp 	EXTInputSingleCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/let.asm

.87b7					LetCommand:
.87b7	a2 00		ldx #$00			ldx 	#0
.87b9	b1 30		lda ($30),y			lda 	(codePtr),y
.87bb	c9 10		cmp #$10			cmp 	#KWD_AT
.87bd	d0 14		bne $87d3			bne 	_LCStandard
.87bf	c8		iny				iny 								; skip equal
.87c0	20 48 98	jsr $9848			jsr 	EvaluateTerm 				; get a number (the address of the reference)
.87c3	20 c1 96	jsr $96c1			jsr 	Dereference 				; dereference it to a value
.87c6	b5 50		lda $50,x			lda 	NSStatus,x 					; check integer
.87c8	49 20		eor #$20			eor 	#NSBIsReference	 			; toggle reference
.87ca	95 50		sta $50,x			sta 	NSStatus,x
.87cc	29 20		and #$20			and 	#NSBIsReference 			; if it is now a reference, continue
.87ce	d0 0f		bne $87df			bne 	_LCMain
.87d0	4c a4 9f	jmp $9fa4			jmp 	TypeError 					; was a reference before.
.87d3					_LCStandard:
.87d3	ad e6 93	lda $93e6			lda 	PrecedenceLevel+"*"			; precedence > this
.87d6	20 00 94	jsr $9400			jsr 	EvaluateExpressionAtPrecedence
.87d9	b5 50		lda $50,x			lda 	NSStatus,x 					; is it a reference to an array marked as procedure ?
.87db	c9 38		cmp #$38			cmp		#NSTProcedure+NSBIsReference
.87dd	f0 0e		beq $87ed			beq 	_LetGoProc 					; it's a procedure call.
.87df					_LCMain:
.87df	a9 3d		lda #$3d			lda 	#"=" 						; check =
.87e1	20 f1 8e	jsr $8ef1			jsr 	CheckNextA
.87e4	e8		inx				inx 								; RHS
.87e5	20 61 9d	jsr $9d61			jsr 	EvaluateValue
.87e8	ca		dex				dex
.87e9	20 f0 87	jsr $87f0			jsr 	AssignVariable
.87ec	60		rts				rts
.87ed					_LetGoProc:
.87ed	4c d4 89	jmp $89d4			jmp 	CallProcedure
.87f0					AssignVariable:
.87f0	b5 50		lda $50,x			lda 	NSStatus,x 					; check the string/number type bits match
.87f2	48		pha				pha 								; save a copy
.87f3	55 51		eor $51,x			eor 	NSStatus+1,x
.87f5	29 10		and #$10			and 	#NSBIsString
.87f7	d0 0b		bne $8804			bne 	_ASError
.87f9	68		pla				pla 								; get back
.87fa	29 10		and #$10			and 	#NSBIsString 				; check type
.87fc	d0 03		bne $8801			bne 	_ASString
.87fe	4c ff 95	jmp $95ff			jmp 	AssignNumber
.8801					_ASString:
.8801	4c 5d 96	jmp $965d			jmp 	AssignString
.8804					_ASError:
.8804	4c a4 9f	jmp $9fa4			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/list.asm

.8807					Command_List:
.8807	9c 26 04	stz $0426			stz 	listIndent 					; reset indent.
.880a	b1 30		lda ($30),y			lda 	(codePtr),y
.880c	29 c0		and #$c0			and 	#$C0 				 		; if so, we are list procedure() which is a seperate block
.880e	c9 40		cmp #$40			cmp 	#$40  						; of code.
.8810	f0 69		beq $887b			beq 	_CLListProcedure
.8812	64 5c		stz $5c				stz		NSMantissa0+4				; set the lower (slot 4) to 0 and upper (slot 7) to $FFFF
.8814	64 64		stz $64				stz 	NSMantissa1+4 				; these are the default top and bottom.
.8816	a9 ff		lda #$ff			lda 	#$FF
.8818	85 5f		sta $5f				sta 	NSMantissa0+7
.881a	85 67		sta $67				sta 	NSMantissa1+7
.881c	b1 30		lda ($30),y			lda 	(codePtr),y
.881e	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8820	f0 1a		beq $883c			beq 	_CLSecond
.8822	20 f8 88	jsr $88f8			jsr 	CLIsDigit 					; if not digit, list all
.8825	b0 20		bcs $8847			bcs 	_CLStart
.8827	a2 04		ldx #$04			ldx 	#4 							; get 1st range into slot 4
.8829	20 9c 9d	jsr $9d9c			jsr 	Evaluate16BitInteger
.882c	b1 30		lda ($30),y			lda 	(codePtr),y
.882e	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8830	f0 0a		beq $883c			beq 	_CLSecond 					; if so go get it
.8832	a5 5c		lda $5c				lda 	NSMantissa0+4 				; copy 4->7
.8834	85 5f		sta $5f				sta 	NSMantissa0+7
.8836	a5 64		lda $64				lda 	NSMantissa1+4
.8838	85 67		sta $67				sta 	NSMantissa1+7
.883a	80 0b		bra $8847			bra 	_CLStart
.883c					_CLSecond:
.883c	c8		iny				iny 								; consume comma
.883d	20 f8 88	jsr $88f8			jsr 	CLIsDigit 					; digit found
.8840	b0 05		bcs $8847			bcs 	_CLStart 					; if not, continue listing
.8842	a2 07		ldx #$07			ldx 	#7 							; load 2nd range into slot 7
.8844	20 9c 9d	jsr $9d9c			jsr 	Evaluate16BitInteger
.8847					_CLStart
.8847	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8849	85 30		sta $30				sta 	codePtr
.884b	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.884d	85 31		sta $31				sta 	codePtr+1
.884f					_CLLoop:
.884f	20 0c 80	jsr $800c			jsr 	EXTBreakCheck 				; break check here, as we want the option of breaking out of long lists.
.8852	f0 24		beq $8878			beq 	_CLExit
.8854	b2 30		lda ($30)			lda 	(codePtr)
.8856	f0 20		beq $8878			beq 	_CLExit
.8858	a2 04		ldx #$04			ldx 	#4 							; check range every time, line numbers aren't in order.
.885a	20 e7 88	jsr $88e7			jsr 	CLCompareLineNo
.885d	90 0c		bcc $886b			bcc 	_CLNext
.885f	a2 07		ldx #$07			ldx 	#7
.8861	20 e7 88	jsr $88e7			jsr 	CLCompareLineNo
.8864	f0 02		beq $8868			beq 	_CLDoThisOne
.8866	b0 03		bcs $886b			bcs 	_CLNext
.8868					_CLDoThisOne:
.8868	20 d4 88	jsr $88d4			jsr 	CLListOneLine 				; routine to list the current line.
.886b					_CLNext:
.886b	18		clc				clc
.886c	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.886e	65 30		adc $30				adc 	codePtr
.8870	85 30		sta $30				sta 	codePtr
.8872	90 02		bcc $8876			bcc 	_CREExit
.8874	e6 31		inc $31				inc 	codePtr+1 					; carry
.8876					_CREExit:
.8876	80 d7		bra $884f			bra 	_CLLoop
.8878					_CLExit:
.8878	4c 78 83	jmp $8378			jmp 	WarmStart
.887b					_CLListProcedure:
.887b	b1 30		lda ($30),y			lda 	(codePtr),y
.887d	85 38		sta $38				sta 	zTemp1
.887f	c8		iny				iny
.8880	b1 30		lda ($30),y			lda 	(codePtr),y
.8882	85 39		sta $39				sta 	zTemp1+1
.8884	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8886	85 30		sta $30				sta 	codePtr
.8888	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.888a	85 31		sta $31				sta 	codePtr+1
.888c					_CLLPSearch:
.888c	b2 30		lda ($30)			lda 	(codePtr)
.888e	c9 00		cmp #$00			cmp 	#0 							; if zero, end
.8890	f0 e6		beq $8878			beq 	_CLExit
.8892	a0 03		ldy #$03			ldy 	#3 							; check if PROC something
.8894	b1 30		lda ($30),y			lda 	(codePtr),y
.8896	c9 a4		cmp #$a4			cmp 	#KWD_PROC
.8898	d0 0e		bne $88a8			bne 	_CLLPNext
.889a	c8		iny				iny 								; check if PROC this.
.889b	b1 30		lda ($30),y			lda 	(codePtr),y
.889d	c5 38		cmp $38				cmp 	zTemp1 						; does it match ?
.889f	d0 07		bne $88a8			bne 	_CLLPNext
.88a1	c8		iny				iny
.88a2	b1 30		lda ($30),y			lda 	(codePtr),y
.88a4	c5 39		cmp $39				cmp 	zTemp1+1
.88a6	f0 0d		beq $88b5			beq 	_CLLPFound
.88a8					_CLLPNext:
.88a8	18		clc				clc
.88a9	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.88ab	65 30		adc $30				adc 	codePtr
.88ad	85 30		sta $30				sta 	codePtr
.88af	90 02		bcc $88b3			bcc 	_CREExit
.88b1	e6 31		inc $31				inc 	codePtr+1 					; carry
.88b3					_CREExit:
.88b3	80 d7		bra $888c			bra 	_CLLPSearch
.88b5					_CLLPFound:
.88b5	b2 30		lda ($30)			lda 	(codePtr)
.88b7	f0 bf		beq $8878			beq 	_CLExit
.88b9	a0 03		ldy #$03			ldy 	#3 							; get first keyword
.88bb	b1 30		lda ($30),y			lda 	(codePtr),y
.88bd	48		pha				pha
.88be	20 d4 88	jsr $88d4			jsr 	CLListOneLine 				; list line and go forward
.88c1	18		clc				clc
.88c2	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.88c4	65 30		adc $30				adc 	codePtr
.88c6	85 30		sta $30				sta 	codePtr
.88c8	90 02		bcc $88cc			bcc 	_CREExit
.88ca	e6 31		inc $31				inc 	codePtr+1 					; carry
.88cc					_CREExit:
.88cc	68		pla				pla 								; reached ENDPROC ?
.88cd	c9 a8		cmp #$a8			cmp 	#KWD_ENDPROC
.88cf	d0 e4		bne $88b5			bne 	_CLLPFound
.88d1	4c 78 83	jmp $8378			jmp 	WarmStart
.88d4					CLListOneLine:
.88d4	20 3c 8e	jsr $8e3c			jsr 	ScanGetCurrentLineStep 		; get indent adjust.
.88d7	20 1e 80	jsr $801e			jsr 	TKListConvertLine 			; convert line into token Buffer
.88da	a2 04		ldx #$04			ldx 	#(tokenBuffer >> 8) 		; print that line
.88dc	a9 2d		lda #$2d			lda 	#(tokenBuffer & $FF)
.88de	20 53 8f	jsr $8f53			jsr 	PrintStringXA
.88e1	a9 0d		lda #$0d			lda 	#13 						; new line
.88e3	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.88e6	60		rts				rts
.88e7					CLCompareLineNo:
.88e7	38		sec				sec
.88e8	a0 01		ldy #$01			ldy 	#1
.88ea	b1 30		lda ($30),y			lda 	(codePtr),y
.88ec	f5 58		sbc $58,x			sbc 	NSMantissa0,x
.88ee	85 36		sta $36				sta 	zTemp0
.88f0	c8		iny				iny
.88f1	b1 30		lda ($30),y			lda 	(codePtr),y
.88f3	f5 60		sbc $60,x			sbc 	NSMantissa1,x
.88f5	05 36		ora $36				ora 	zTemp0
.88f7	60		rts				rts
.88f8					CLIsDigit:
.88f8	b1 30		lda ($30),y			lda 	(codePtr),y
.88fa	c9 30		cmp #$30			cmp 	#"0"
.88fc	90 03		bcc $8901			bcc	 	_CLIDExitFalse
.88fe	c9 3a		cmp #$3a			cmp 	#"9"+1
.8900	60		rts				rts
.8901					_CLIDExitFalse:
.8901	38		sec				sec
.8902	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/local.asm

.8903					Command_LOCAL:
.8903	a2 00		ldx #$00			ldx 	#0 							; at level 0
.8905	20 11 89	jsr $8911			jsr 	LocaliseNextTerm 			; convert term to a local.
.8908	b1 30		lda ($30),y			lda 	(codePtr),y
.890a	c8		iny				iny
.890b	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.890d	f0 f4		beq $8903			beq 	Command_LOCAL 				; if so, localise another variable.
.890f	88		dey				dey 								; unpick pre-get
.8910	60		rts				rts
.8911					LocaliseNextTerm:
.8911	20 48 98	jsr $9848			jsr 	EvaluateTerm 				; evaluate the term
.8914	b5 50		lda $50,x			lda 	NSStatus,x
.8916	29 20		and #$20			and 	#NSBIsReference 			; check it is a reference, must be a variable.
.8918	f0 5c		beq $8976			beq		_LNTError
.891a	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address of variable to zTemp0
.891c	85 36		sta $36				sta 	zTemp0
.891e	b5 60		lda $60,x			lda 	NSMantissa1,x
.8920	85 37		sta $37				sta  	zTemp0+1
.8922	b5 50		lda $50,x			lda 	NSStatus,x 					; figure out what it is.
.8924	29 10		and #$10			and 	#NSBIsString
.8926	d0 1e		bne $8946			bne 	_LNTPushString
.8928	5a		phy				phy
.8929	a0 00		ldy #$00			ldy 	#0 							; push 0 to 4 inclusive, the number values, on the stack, and zero them as you go.
.892b					_LNTPushNumLoop:
.892b	b1 36		lda ($36),y			lda		(zTemp0),y
.892d	20 8d a6	jsr $a68d			jsr 	StackPushByte
.8930	c8		iny				iny
.8931	c0 05		cpy #$05			cpy 	#5
.8933	d0 f6		bne $892b			bne 	_LNTPushNumLoop
.8935	a5 36		lda $36				lda 	zTemp0 						; push the actual target address to write on the stack
.8937	20 8d a6	jsr $a68d			jsr 	StackPushByte
.893a	a5 37		lda $37				lda 	zTemp0+1
.893c	20 8d a6	jsr $a68d			jsr 	StackPushByte
.893f	a9 01		lda #$01			lda 	#STK_LOCALN 				; push local-number marker.
.8941	20 8d a6	jsr $a68d			jsr 	StackPushByte
.8944	7a		ply				ply
.8945	60		rts				rts
.8946					_LNTPushString:
.8946	5a		phy				phy
.8947	b2 36		lda ($36)			lda 	(zTemp0) 					; put address of string in zTemp1
.8949	85 38		sta $38				sta 	zTemp1
.894b	a0 01		ldy #$01			ldy 	#1
.894d	b1 36		lda ($36),y			lda 	(zTemp0),y
.894f	85 39		sta $39				sta 	zTemp1+1
.8951	a0 00		ldy #$00			ldy 	#0 							; output string
.8953	c9 00		cmp #$00			cmp 	#0 							; if not assigned string
.8955	f0 0a		beq $8961			beq 	_LNTStringOut
.8957					_LNTPushStrLoop:
.8957	b1 38		lda ($38),y			lda 	(zTemp1),y
.8959	f0 06		beq $8961			beq 	_LNTStringOut
.895b	20 8d a6	jsr $a68d			jsr 	StackPushByte
.895e	c8		iny				iny
.895f	80 f6		bra $8957			bra 	_LNTPushStrLoop
.8961					_LNTStringOut:
.8961	98		tya				tya									; output length (chars written).
.8962	20 8d a6	jsr $a68d			jsr 	StackPushByte
.8965	b5 58		lda $58,x			lda 	NSMantissa0,x 				; output address of the string record *not* the string itself
.8967	20 8d a6	jsr $a68d			jsr 	StackPushByte
.896a	b5 60		lda $60,x			lda 	NSMantissa1,x
.896c	20 8d a6	jsr $a68d			jsr 	StackPushByte
.896f	a9 02		lda #$02			lda 	#STK_LOCALS 				; push local-string marker.
.8971	20 8d a6	jsr $a68d			jsr 	StackPushByte
.8974	7a		ply				ply
.8975	60		rts				rts
.8976					_LNTError:
.8976	4c 9a 9f	jmp $9f9a			jmp 	SyntaxError
.8979					LocalPopValue:
.8979	20 a5 a6	jsr $a6a5			jsr 	StackPopByte
.897c	c9 01		cmp #$01			cmp 	#STK_LOCALN 				; if not local-N
.897e	d0 17		bne $8997			bne 	_LPVString
.8980	20 a5 a6	jsr $a6a5			jsr 	StackPopByte 				; address
.8983	85 37		sta $37				sta 	zTemp0+1
.8985	20 a5 a6	jsr $a6a5			jsr 	StackPopByte
.8988	85 36		sta $36				sta 	zTemp0
.898a	5a		phy				phy
.898b	a0 04		ldy #$04			ldy 	#4 							; copy back
.898d					_LPVNumberCopy:
.898d	20 a5 a6	jsr $a6a5			jsr 	StackPopByte
.8990	91 36		sta ($36),y			sta 	(zTemp0),y
.8992	88		dey				dey
.8993	10 f8		bpl $898d			bpl 	_LPVNumberCopy
.8995	7a		ply				ply 								; and complete
.8996	60		rts				rts
.8997					_LPVString:
.8997	20 a5 a6	jsr $a6a5			jsr 	StackPopByte 				; address of record copied to zTemp0
.899a	85 37		sta $37				sta 	zTemp0+1
.899c	20 a5 a6	jsr $a6a5			jsr 	StackPopByte
.899f	85 36		sta $36				sta 	zTemp0
.89a1	5a		phy				phy
.89a2	b2 36		lda ($36)			lda 	(zTemp0) 					; address to write string to copied to zTemp1
.89a4	85 38		sta $38				sta 	zTemp1
.89a6	a0 01		ldy #$01			ldy 	#1
.89a8	b1 36		lda ($36),y			lda 	(zTemp0),y
.89aa	85 39		sta $39				sta 	zTemp1+1
.89ac	20 a5 a6	jsr $a6a5			jsr 	StackPopByte 				; # chars to get => y
.89af	a8		tay				tay
.89b0	a5 39		lda $39				lda 	zTemp1+1 					; if no target (e.g. was "" originally) exit
.89b2	f0 0e		beq $89c2			beq 	_LPVStringCopied
.89b4	a9 00		lda #$00			lda 	#0 							; NULL on end
.89b6	91 38		sta ($38),y			sta 	(zTemp1),y
.89b8					_LPVStringCopy:
.89b8	88		dey				dey
.89b9	30 07		bmi $89c2			bmi 	_LPVStringCopied
.89bb	20 a5 a6	jsr $a6a5			jsr 	StackPopByte
.89be	91 38		sta ($38),y			sta 	(zTemp1),y
.89c0	80 f6		bra $89b8			bra 	_LPVStringCopy
.89c2					_LPVStringCopied:
.89c2	fa		plx				plx
.89c3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/new.asm

.89c4					NewCommand:
.89c4	20 ca 89	jsr $89ca			jsr 	NewProgram 					; does the actual NEW.
.89c7	4c 78 83	jmp $8378			jmp 	WarmStart 					; and warm starts straight away.
.89ca					NewProgram:
.89ca	20 6a a5	jsr $a56a			jsr 	MemoryNew
.89cd	9c 00 10	stz $1000			stz 	VariableSpace 				; erase all variables.
.89d0	20 0e 84	jsr $840e			jsr 	ClearCommand 				; clear everything.
.89d3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/procedure.asm

=2					ParameterStackPos = 2
.89d4					CallProcedure:
.89d4	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start storing parameters at 2.
.89d6	b1 30		lda ($30),y			lda 	(codePtr),y
.89d8	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.89da	f0 0c		beq $89e8			beq 	_CPEndParam
.89dc					_CPParamLoop:
.89dc	20 61 9d	jsr $9d61			jsr 	EvaluateValue 				; get parameter onto stack
.89df	e8		inx				inx 								; bump next stack
.89e0	b1 30		lda ($30),y			lda 	(codePtr),y
.89e2	c8		iny				iny
.89e3	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if comma, go back and try again.
.89e5	f0 f5		beq $89dc			beq 	_CPParamLoop
.89e7	88		dey				dey 								; unpick.
.89e8					_CPEndParam:
.89e8	8e 16 04	stx $0416			stx 	LastParameter 				; save the last parameters index.
.89eb	c8		iny				iny									; skip right bracket
.89ec	a9 b3		lda #$b3			lda 	#STK_PROC+3 				; allocate 6 bytes on the return stack.
.89ee	20 ae a6	jsr $a6ae			jsr 	StackOpen
.89f1	20 f3 a6	jsr $a6f3			jsr 	STKSaveCodePosition 		; save loop position
.89f4	a5 58		lda $58				lda 	NSMantissa0 				; copy variable (e.g. procedure) address to zTemp0
.89f6	85 36		sta $36				sta 	zTemp0 						; this is the DATA not the RECORD
.89f8	a5 60		lda $60				lda 	NSMantissa1
.89fa	85 37		sta $37				sta 	zTemp0+1
.89fc	a0 01		ldy #$01			ldy 	#1 							; copy code address back.
.89fe	b2 36		lda ($36)			lda 	(zTemp0)
.8a00	85 30		sta $30				sta 	safePtr
.8a02	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a04	85 31		sta $31				sta 	safePtr+1
.8a06	c8		iny				iny
.8a07	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a09	85 32		sta $32				sta 	safePtr+2
.8a0b	c8		iny				iny
.8a0c	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a0e	85 33		sta $33				sta 	safePtr+3
.8a10	c8		iny				iny 								; get Y offset -> Y
.8a11	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a13	a8		tay				tay
.8a14	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start position of parameters
.8a16	ec 16 04	cpx $0416			cpx	 	LastParameter 				; check zero parameters at the start
.8a19	f0 13		beq $8a2e			beq 	_ParamExit 					; if so, exit.
.8a1b					_ParamExtract:
.8a1b	ca		dex				dex 								; put a local term on the level before
.8a1c	20 11 89	jsr $8911			jsr 	LocaliseNextTerm			; also pushes original param value to basic stack
.8a1f	20 f0 87	jsr $87f0			jsr 	AssignVariable 				; assign stacked value to the variable.
.8a22	e8		inx				inx 								; advance to next parameter to do.
.8a23	e8		inx				inx
.8a24	ec 16 04	cpx $0416			cpx 	LastParameter 				; are we done ?
.8a27	f0 05		beq $8a2e			beq 	_ParamExit
.8a29	20 e9 8e	jsr $8ee9			jsr 	CheckComma 					; comma seperating parameters
.8a2c	80 ed		bra $8a1b			bra 	_ParamExtract
.8a2e					_ParamExit:
.8a2e	20 e1 8e	jsr $8ee1			jsr 	CheckRightBracket 			; check )
.8a31	60		rts				rts 								; and continue from here
.8a32					Command_ENDPROC:
.8a32	a9 b0		lda #$b0			lda 	#STK_PROC 					; check TOS is this
.8a34	a2 14		ldx #$14			ldx 	#ERRID_PROC
.8a36	20 db a6	jsr $a6db			jsr 	StackCheckFrame
.8a39	20 04 a7	jsr $a704			jsr 	STKLoadCodePosition 		; restore code position
.8a3c	20 cd a6	jsr $a6cd			jsr 	StackClose
.8a3f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/read.asm

.8a40					Command_Read:
.8a40	a2 00		ldx #$00			ldx 	#0 							; evaluate the term which is the var/array element to assign
.8a42	20 48 98	jsr $9848			jsr 	EvaluateTerm
.8a45	b5 50		lda $50,x			lda 	NSStatus,x
.8a47	29 20		and #$20			and 	#NSBIsReference				; get status byte on stack, identifies int, float, string.
.8a49	f0 4f		beq $8a9a			beq 	_CRSyntax 					; check reference (bit 0) fail if not a reference.
.8a4b	20 e3 8a	jsr $8ae3			jsr 	SwapDataCodePtrs 			; swap code and data
.8a4e	ad 1c 04	lda $041c			lda 	inDataStatement 			; if in a data statement, we don't need to search
.8a51	d0 25		bne $8a78			bne 	_CRContinueData  			; forward for the next one.
.8a53	b2 30		lda ($30)			lda 	(codePtr)
.8a55	f0 1c		beq $8a73			beq 	_CRNoData
.8a57					_CRKeepSearching:
.8a57	a9 b4		lda #$b4			lda 	#KWD_DATA 					; scan for instruction
.8a59	a2 80		ldx #$80			ldx 	#KWC_EOL
.8a5b	20 d9 8d	jsr $8dd9			jsr 	ScanForward
.8a5e	c9 b4		cmp #$b4			cmp 	#KWD_DATA 					; found data ?
.8a60	f0 16		beq $8a78			beq 	_CRHaveData 				; found it
.8a62	18		clc				clc
.8a63	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8a65	65 30		adc $30				adc 	codePtr
.8a67	85 30		sta $30				sta 	codePtr
.8a69	90 02		bcc $8a6d			bcc 	_CREExit
.8a6b	e6 31		inc $31				inc 	codePtr+1 					; carry
.8a6d					_CREExit:
.8a6d	a0 03		ldy #$03			ldy 	#3 							; start of line.
.8a6f	b2 30		lda ($30)			lda 	(codePtr)
.8a71	d0 e4		bne $8a57			bne 	_CRKeepSearching
.8a73					_CRNoData:
.8a73	a9 0b		lda #$0b		lda	#11
.8a75	4c fa 8e	jmp $8efa		jmp	ErrorHandler
.8a78					_CRHaveData:
.8a78					_CRContinueData:
.8a78	a2 01		ldx #$01			ldx 	#1
.8a7a	20 61 9d	jsr $9d61			jsr 	EvaluateValue 				; evaluate value into slot # 1
.8a7d	ca		dex				dex
.8a7e	20 f0 87	jsr $87f0			jsr		AssignVariable 				; do the assignment
.8a81	9c 1c 04	stz $041c			stz 	inDataStatement 			; clear in data flag
.8a84	b1 30		lda ($30),y			lda 	(codePtr),y
.8a86	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not, end of data statement and exit
.8a88	d0 04		bne $8a8e			bne 	_CRSwapBack
.8a8a	c8		iny				iny 								; consume comma
.8a8b	ee 1c 04	inc $041c			inc 	inDataStatement 			; set in data statement currently.
.8a8e					_CRSwapBack:
.8a8e	20 e3 8a	jsr $8ae3			jsr 	SwapDataCodePtrs			; swap them back.
.8a91	b1 30		lda ($30),y			lda 	(codePtr),y
.8a93	c8		iny				iny
.8a94	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8a96	f0 a8		beq $8a40			beq 	Command_Read 				; if so go round again.
.8a98	88		dey				dey 								; unpick get.
.8a99	60		rts				rts
.8a9a					_CRSyntax:
.8a9a	4c 9a 9f	jmp $9f9a			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/rem.asm

.8a9d					RemCommand:
.8a9d	b1 30		lda ($30),y			lda 	(codePtr),y
.8a9f	c9 ff		cmp #$ff			cmp 	#KWC_STRING
.8aa1	d0 06		bne $8aa9			bne 	_RMExit
.8aa3	c8		iny				iny 								; point to offset
.8aa4	98		tya				tya 								; A = offset position
.8aa5	38		sec				sec 								; add size +1 hence SEC
.8aa6	71 30		adc ($30),y			adc 	(codePtr),y
.8aa8	a8		tay				tay 								; make current position.
.8aa9					_RMExit:
.8aa9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/repeat.asm

.8aaa					Command_REPEAT:
.8aaa	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; allocate 6 bytes on the return stack.
.8aac	20 ae a6	jsr $a6ae			jsr 	StackOpen
.8aaf	20 f3 a6	jsr $a6f3			jsr 	STKSaveCodePosition 		; save loop position
.8ab2	60		rts				rts
.8ab3					Command_UNTIL:
.8ab3	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; check REPEAT is TOS
.8ab5	a2 0f		ldx #$0f			ldx 	#ERRID_REPEAT 				; this error
.8ab7	20 db a6	jsr $a6db			jsr 	StackCheckFrame
.8aba	a2 00		ldx #$00			ldx 	#0
.8abc	20 6a 9d	jsr $9d6a			jsr 	EvaluateNumber 				; work out the number
.8abf	20 3e 9e	jsr $9e3e			jsr 	NSMIsZero 					; check if zero
.8ac2	f0 04		beq $8ac8			beq 	_CULoopBack 				; if so keep looping
.8ac4	20 cd a6	jsr $a6cd			jsr 	StackClose		 			; return
.8ac7	60		rts				rts
.8ac8					_CULoopBack:
.8ac8	20 04 a7	jsr $a704			jsr 	STKLoadCodePosition 		; loop back
.8acb	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/restore.asm

.8acc					Command_Restore:
.8acc	20 e3 8a	jsr $8ae3			jsr 	SwapDataCodePtrs 			; swap code and data
.8acf	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8ad1	85 30		sta $30				sta 	codePtr
.8ad3	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8ad5	85 31		sta $31				sta 	codePtr+1
.8ad7	20 e3 8a	jsr $8ae3			jsr 	SwapDataCodePtrs 			; put them back
.8ada	a9 03		lda #$03			lda 	#3 							; start at offset 3, e.g. first instruction of first line.
.8adc	8d 1b 04	sta $041b			sta 	dataPointer+4   			; (read checks not EOF)
.8adf	9c 1c 04	stz $041c			stz 	inDataStatement 			; not in data statement
.8ae2	60		rts				rts
.8ae3					SwapDataCodePtrs:
.8ae3	da		phx				phx
.8ae4	a2 03		ldx #$03			ldx 	#3 							; swap 32 bit code pointer over
.8ae6					_SDCPLoop:
.8ae6	b5 30		lda $30,x			lda 	safePtr,x
.8ae8	48		pha				pha
.8ae9	bd 17 04	lda $0417,x			lda 	dataPointer,x
.8aec	95 30		sta $30,x			sta 	safePtr,x
.8aee	68		pla				pla
.8aef	9d 17 04	sta $0417,x			sta 	dataPointer,x
.8af2	ca		dex				dex
.8af3	10 f1		bpl $8ae6			bpl 	_SDCPLoop
.8af5	ad 1b 04	lda $041b			lda 	dataPointer+4 				; swap Y position over.
.8af8	8c 1b 04	sty $041b			sty 	dataPointer+4
.8afb	a8		tay				tay
.8afc	fa		plx				plx
.8afd	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/run.asm

.8afe					EOLCommand:
.8afe	18		clc				clc
.8aff	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8b01	65 30		adc $30				adc 	codePtr
.8b03	85 30		sta $30				sta 	codePtr
.8b05	90 02		bcc $8b09			bcc 	_CREExit
.8b07	e6 31		inc $31				inc 	codePtr+1 					; carry
.8b09					_CREExit:
.8b09	80 0b		bra $8b16			bra 	RunNewLine
.8b0b					CommandRUN:
.8b0b	20 0e 84	jsr $840e			jsr 	ClearCommand 				; clear variable/stacks/etc.
.8b0e	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8b10	85 30		sta $30				sta 	codePtr
.8b12	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8b14	85 31		sta $31				sta 	codePtr+1
.8b16					RUNNewLine:
.8b16	b2 30		lda ($30)			lda 	(codePtr)
.8b18	f0 7b		beq $8b95			beq 	CRNoProgram         		; no then END.
.8b1a	a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack
.8b1c	9a		txs				txs
.8b1d					RUNCodePointerLine:
.8b1d	a0 02		ldy #$02			ldy 	#2 							; start of program
.8b1f					_CRIncMainLoop:
.8b1f	0e 13 04	asl $0413			asl 	breakCheck 					; clears 1 time in 8
.8b22	d0 22		bne $8b46			bne 	_CRNoBreakCheck
.8b24	ce 13 04	dec $0413			dec	 	breakCheck 					; set it back to $FF
.8b27	20 0c 80	jsr $800c			jsr 	EXTBreakCheck 				; break check
.8b2a	f0 64		beq $8b90			beq 	_CRBreak
.8b2c	a5 01		lda $01				lda 	1 							; save I/O 0
.8b2e	48		pha				pha
.8b2f	64 01		stz $01				stz 	1 							; access I/O Page 0
.8b31	38		sec				sec 								; calculate timer - LastTick
.8b32	ad 59 d6	lda $d659			lda 	$D659
.8b35	aa		tax				tax 								; saving timer in X
.8b36	ed af 05	sbc $05af			sbc 	LastTick
.8b39	c9 03		cmp #$03			cmp 	#3
.8b3b	90 06		bcc $8b43			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.8b3d	8e af 05	stx $05af			stx 	LastTick 					; update last timer
.8b40	20 47 9e	jsr $9e47			jsr 	TickHandler 							; go do the code.
.8b43					_NoFireTick:
.8b43	68		pla				pla 								; restore I/O 0
.8b44	85 01		sta $01				sta 	1
.8b46					_CRNoBreakCheck:
.8b46	c8		iny				iny									; next token
.8b47					_CRMainLoop:
.8b47	9c 10 04	stz $0410			stz 	stringInitialised 			; clear the temporary string initialised flag.
.8b4a	b1 30		lda ($30),y			lda 	(codePtr),y
.8b4c	10 10		bpl $8b5e			bpl 	_CRNotKeyword				; not a token.
.8b4e	c9 a2		cmp #$a2			cmp 	#KWC_LAST_UNARY+1 			; if after unary, legitimate command
.8b50	b0 04		bcs $8b56			bcs 	_CRIsKeyword
.8b52	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if unary, syntax error.
.8b54	b0 34		bcs $8b8a			bcs		_CRSyntaxError
.8b56					_CRIsKeyword:
.8b56	c8		iny				iny 								; consume command
.8b57	0a		asl a				asl 	a 							; double losing the MSB which is '1' as tokens are $80-$FF
.8b58	aa		tax				tax 								; put in X for vector jump
.8b59	20 8d 8b	jsr $8b8d			jsr 	_CRCallVector0 				; call the vector - effectively jsr (vectortable,X)
.8b5c	80 e9		bra $8b47			bra 	_CRMainLoop 				; and loop round
.8b5e					_CRNotKeyword:
.8b5e	c9 3a		cmp #$3a			cmp 	#KWD_COLON 					; if a :, consume it and go round.
.8b60	f0 bd		beq $8b1f			beq 	_CRIncMainLoop
.8b62	c9 40		cmp #$40			cmp 	#$40 						; variable/call reference
.8b64	90 05		bcc $8b6b			bcc 	_CRNotVariable
.8b66					_CRGoLet:
.8b66	20 b7 87	jsr $87b7			jsr 	LetCommand
.8b69	80 dc		bra $8b47			bra 	_CRMainLoop
.8b6b					_CRNotVariable:
.8b6b	c9 10		cmp #$10			cmp 	#KWD_AT 					; handle @
.8b6d	f0 f7		beq $8b66			beq 	_CRGoLet
.8b6f	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; handle ? !
.8b71	f0 f3		beq $8b66			beq 	_CRGoLet
.8b73	c9 21		cmp #$21			cmp 	#KWD_PLING
.8b75	f0 ef		beq $8b66			beq 	_CRGoLet
.8b77	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; handle ' (comment)
.8b79	f0 09		beq $8b84			beq 	_CRGoRem
.8b7b	c9 2e		cmp #$2e			cmp 	#KWD_PERIOD 				; handle . (assembler label)
.8b7d	d0 0b		bne $8b8a			bne 	_CRSyntaxError
.8b7f	20 11 82	jsr $8211			jsr 	LabelHere
.8b82	80 c3		bra $8b47			bra 	_CRMainLoop
.8b84					_CRGoRem:
.8b84	c8		iny				iny
.8b85	20 9d 8a	jsr $8a9d			jsr 	RemCommand
.8b88	80 bd		bra $8b47			bra 	_CRMainLoop
.8b8a					_CRSyntaxError:
.8b8a	4c 9a 9f	jmp $9f9a			jmp 	SyntaxError
.8b8d					_CRCallVector0:
.8b8d	7c 2c 8c	jmp ($8c2c,x)			jmp 	(VectorSet0,x)
.8b90					_CRBreak:
.8b90	a9 01		lda #$01		lda	#1
.8b92	4c fa 8e	jmp $8efa		jmp	ErrorHandler
.8b95					CRNoProgram:
.8b95	4c 5c 85	jmp $855c			jmp 	EndCommand
.8b98					Shift1Command:
.8b98	b1 30		lda ($30),y			lda 	(codePtr),y
.8b9a	c8		iny				iny
.8b9b	0a		asl a				asl 	a
.8b9c	aa		tax				tax
.8b9d	7c d2 8c	jmp ($8cd2,x)			jmp 	(VectorSet1,x)
.8ba0					Shift2Command:
.8ba0	b1 30		lda ($30),y			lda 	(codePtr),y
.8ba2	c8		iny				iny
.8ba3	0a		asl a				asl 	a
.8ba4	aa		tax				tax
.8ba5	7c fa 8c	jmp ($8cfa,x)			jmp 	(VectorSet2,x)
.8ba8					Unused1:
.8ba8					Unused2:
.8ba8					Unused3:
.8ba8					Unused4:
.8ba8	4c 9a 9f	jmp $9f9a			jmp 	SyntaxError
>8bab							.align 2

;******  Processing file: ./common/commands/../generated/vectors.dat

.8bac					VectorSetPunc:
>8bac	b2 91					.word	ShiftLeft                        ; $00 <<
>8bae	9d 8f					.word	BinaryCompareLessEqual           ; $01 <=
>8bb0	93 8f					.word	BinaryCompareNotEqual            ; $02 <>
>8bb2	9a 9f					.word	SyntaxError                      ; $03 !!3
>8bb4	9a 9f					.word	SyntaxError                      ; $04 ><
>8bb6	a7 8f					.word	BinaryCompareGreaterEqual        ; $05 >=
>8bb8	b5 91					.word	ShiftRight                       ; $06 >>
>8bba	9a 9f					.word	SyntaxError                      ; $07 !!7
>8bbc	9a 9f					.word	SyntaxError                      ; $08 !!8
>8bbe	9a 9f					.word	SyntaxError                      ; $09 !!9
>8bc0	9a 9f					.word	SyntaxError                      ; $0a !!10
>8bc2	9a 9f					.word	SyntaxError                      ; $0b !!11
>8bc4	9a 9f					.word	SyntaxError                      ; $0c !!12
>8bc6	9a 9f					.word	SyntaxError                      ; $0d !!13
>8bc8	9a 9f					.word	SyntaxError                      ; $0e !!14
>8bca	9a 9f					.word	SyntaxError                      ; $0f !!15
>8bcc	9a 9f					.word	SyntaxError                      ; $10 @
>8bce	9a 9f					.word	SyntaxError                      ; $11 !!17
>8bd0	9a 9f					.word	SyntaxError                      ; $12 !!18
>8bd2	9a 9f					.word	SyntaxError                      ; $13 [
>8bd4	5e 90					.word	IntegerDivide                    ; $14 \
>8bd6	9a 9f					.word	SyntaxError                      ; $15 ]
>8bd8	f0 92					.word	EorInteger                       ; $16 ^
>8bda	9a 9f					.word	SyntaxError                      ; $17 _
>8bdc	9a 9f					.word	SyntaxError                      ; $18 `
>8bde	9a 9f					.word	SyntaxError                      ; $19 !!25
>8be0	9a 9f					.word	SyntaxError                      ; $1a !!26
>8be2	9a 9f					.word	SyntaxError                      ; $1b {
>8be4	bb 92					.word	OraInteger                       ; $1c |
>8be6	9a 9f					.word	SyntaxError                      ; $1d }
>8be8	9a 9f					.word	SyntaxError                      ; $1e ~
>8bea	9a 9f					.word	SyntaxError                      ; $1f [7m<7F>[m
>8bec	9a 9f					.word	SyntaxError                      ; $20
>8bee	25 93					.word	WordIndirect                     ; $21 !
>8bf0	9a 9f					.word	SyntaxError                      ; $22 "
>8bf2	9a 9f					.word	SyntaxError                      ; $23 #
>8bf4	9a 9f					.word	SyntaxError                      ; $24 $
>8bf6	9f 90					.word	IntegerModulus                   ; $25 %
>8bf8	86 92					.word	AndInteger                       ; $26 &
>8bfa	9a 9f					.word	SyntaxError                      ; $27 '
>8bfc	9a 9f					.word	SyntaxError                      ; $28 (
>8bfe	9a 9f					.word	SyntaxError                      ; $29 )
>8c00	0d 91					.word	MulInteger                       ; $2a *
>8c02	28 92					.word	AddInteger                       ; $2b +
>8c04	9a 9f					.word	SyntaxError                      ; $2c ,
>8c06	61 92					.word	SubInteger                       ; $2d -
>8c08	9a 9f					.word	SyntaxError                      ; $2e .
>8c0a	df 94					.word	FDivideCommand                   ; $2f /
>8c0c	9a 9f					.word	SyntaxError                      ; $30 0
>8c0e	9a 9f					.word	SyntaxError                      ; $31 1
>8c10	9a 9f					.word	SyntaxError                      ; $32 2
>8c12	9a 9f					.word	SyntaxError                      ; $33 3
>8c14	9a 9f					.word	SyntaxError                      ; $34 4
>8c16	9a 9f					.word	SyntaxError                      ; $35 5
>8c18	9a 9f					.word	SyntaxError                      ; $36 6
>8c1a	9a 9f					.word	SyntaxError                      ; $37 7
>8c1c	9a 9f					.word	SyntaxError                      ; $38 8
>8c1e	9a 9f					.word	SyntaxError                      ; $39 9
>8c20	9a 9f					.word	SyntaxError                      ; $3a :
>8c22	9a 9f					.word	SyntaxError                      ; $3b ;
>8c24	7f 8f					.word	BinaryCompareLess                ; $3c <
>8c26	75 8f					.word	BinaryCompareEqual               ; $3d =
>8c28	89 8f					.word	BinaryCompareGreater             ; $3e >
>8c2a	47 93					.word	ByteIndirect                     ; $3f ?
.8c2c					VectorSet0:
>8c2c	fe 8a					.word	EOLCommand                       ; $80 !0:EOF
>8c2e	98 8b					.word	Shift1Command                    ; $81 !1:SH1
>8c30	a0 8b					.word	Shift2Command                    ; $82 !2:SH2
>8c32	c4 99					.word	AbsUnary                         ; $83 ABS(
>8c34	d2 99					.word	AllocUnary                       ; $84 ALLOC(
>8c36	42 9a					.word	AscUnary                         ; $85 ASC(
>8c38	02 9c					.word	ChrUnary                         ; $86 CHR$(
>8c3a	52 9a					.word	DeekUnary                        ; $87 DEEK(
>8c3c	ea a3					.word	UnaryEvent                       ; $88 EVENT(
>8c3e	71 8f					.word	UnaryFalse                       ; $89 FALSE
>8c40	64 9a					.word	FracUnary                        ; $8a FRAC(
>8c42	86 a3					.word	UnaryHit                         ; $8b HIT(
>8c44	79 9a					.word	IntUnary                         ; $8c INT(
>8c46	c1 9b					.word	IsValUnary                       ; $8d ISVAL(
>8c48	6e a4					.word	UnaryJoyB                        ; $8e JOYB(
>8c4a	47 a4					.word	UnaryJoyX                        ; $8f JOYX(
>8c4c	4a a4					.word	UnaryJoyY                        ; $90 JOYY(
>8c4e	d5 9c					.word	Unary_Left                       ; $91 LEFT$(
>8c50	8a 9a					.word	LenUnary                         ; $92 LEN(
>8c52	a8 9a					.word	Unary_Max                        ; $93 MAX(
>8c54	f7 9c					.word	Unary_Mid                        ; $94 MID$(
>8c56	a4 9a					.word	Unary_Min                        ; $95 MIN(
>8c58	f3 9a					.word	Unary_Not                        ; $96 NOT(
>8c5a	4f 9a					.word	PeekUnary                        ; $97 PEEK(
>8c5c	0b a6					.word	UnaryPlaying                     ; $98 PLAYING(
>8c5e	06 9b					.word	Unary_Random                     ; $99 RANDOM(
>8c60	e2 9c					.word	Unary_Right                      ; $9a RIGHT$(
>8c62	23 9b					.word	Unary_Rnd                        ; $9b RND(
>8c64	99 9b					.word	SgnUnary                         ; $9c SGN(
>8c66	14 9c					.word	SpcUnary                         ; $9d SPC(
>8c68	2f 9c					.word	Unary_Str                        ; $9e STR$(
>8c6a	94 a4					.word	UnaryTimer                       ; $9f TIMER(
>8c6c	66 8f					.word	UnaryTrue                        ; $a0 TRUE
>8c6e	b7 9b					.word	ValUnary                         ; $a1 VAL(
>8c70	5f 85					.word	ForCommand                       ; $a2 FOR
>8c72	a2 86					.word	IfCommand                        ; $a3 IF
>8c74	a8 8b					.word	Unused1                          ; $a4 PROC
>8c76	aa 8a					.word	Command_REPEAT                   ; $a5 REPEAT
>8c78	4f 8e					.word	Command_WHILE                    ; $a6 WHILE
>8c7a	cb 86					.word	EndIf                            ; $a7 ENDIF
>8c7c	32 8a					.word	Command_ENDPROC                  ; $a8 ENDPROC
>8c7e	11 86					.word	NextCommand                      ; $a9 NEXT
>8c80	a8 8b					.word	Unused4                          ; $aa THEN
>8c82	b3 8a					.word	Command_UNTIL                    ; $ab UNTIL
>8c84	70 8e					.word	Command_WEND                     ; $ac WEND
>8c86	9a 9f					.word	SyntaxError                      ; $ad BY
>8c88	d9 83					.word	CallCommand                      ; $ae CALL
>8c8a	3a a1					.word	CircleCommand                    ; $af CIRCLE
>8c8c	0e 84					.word	ClearCommand                     ; $b0 CLEAR
>8c8e	66 84					.word	ClearScreen                      ; $b1 CLS
>8c90	9a 9f					.word	SyntaxError                      ; $b2 COLOR
>8c92	9a 9f					.word	SyntaxError                      ; $b3 COLOUR
>8c94	6e 84					.word	Command_Data                     ; $b4 DATA
>8c96	76 84					.word	DimCommand                       ; $b5 DIM
>8c98	36 85					.word	DokeCommand                      ; $b6 DOKE
>8c9a	a8 8b					.word	Unused3                          ; $b7 DOWNTO
>8c9c	c4 86					.word	ElseCode                         ; $b8 ELSE
>8c9e	9a 9f					.word	SyntaxError                      ; $b9 FROM
>8ca0	59 a3					.word	GfxCommand                       ; $ba GFX
>8ca2	6a 86					.word	Command_GOSUB                    ; $bb GOSUB
>8ca4	88 86					.word	GotoCommand                      ; $bc GOTO
>8ca6	9a 9f					.word	SyntaxError                      ; $bd HERE
>8ca8	63 a1					.word	ImageCommand                     ; $be IMAGE
>8caa	cc 86					.word	Command_Input                    ; $bf INPUT
>8cac	b7 87					.word	LetCommand                       ; $c0 LET
>8cae	b5 a1					.word	LineCommand                      ; $c1 LINE
>8cb0	03 89					.word	Command_LOCAL                    ; $c2 LOCAL
>8cb2	9a 9f					.word	SyntaxError                      ; $c3 OFF
>8cb4	9a 9f					.word	SyntaxError                      ; $c4 ON
>8cb6	9a 9f					.word	SyntaxError                      ; $c5 OUTLINE
>8cb8	aa a3					.word	PaletteCommand                   ; $c6 PALETTE
>8cba	ae a1					.word	PlotCommand                      ; $c7 PLOT
>8cbc	33 85					.word	PokeCommand                      ; $c8 POKE
>8cbe	d3 86					.word	Command_Print                    ; $c9 PRINT
>8cc0	40 8a					.word	Command_Read                     ; $ca READ
>8cc2	36 a1					.word	RectangleCommand                 ; $cb RECT
>8cc4	9d 8a					.word	RemCommand                       ; $cc REM
>8cc6	7a 86					.word	Command_RETURN                   ; $cd RETURN
>8cc8	9a 9f					.word	SyntaxError                      ; $ce SOLID
>8cca	27 a6					.word	SoundCommand                     ; $cf SOUND
>8ccc	45 a1					.word	SpriteCommand                    ; $d0 SPRITE
>8cce	7f a1					.word	TextCommand                      ; $d1 TEXT
>8cd0	a8 8b					.word	Unused2                          ; $d2 TO
.8cd2					VectorSet1:
>8cd2	9a 9f					.word	SyntaxError                      ; $80 !0:EOF
>8cd4	9a 9f					.word	SyntaxError                      ; $81 !1:SH1
>8cd6	9a 9f					.word	SyntaxError                      ; $82 !2:SH2
>8cd8	ad 83					.word	AssembleCommand                  ; $83 ASSEMBLE
>8cda	c9 83					.word	AssertCommand                    ; $84 ASSERT
>8cdc	f9 a2					.word	BitmapCtrl                       ; $85 BITMAP
>8cde	5c 85					.word	EndCommand                       ; $86 END
>8ce0	df a5					.word	Explode                          ; $87 EXPLODE
>8ce2	8b a4					.word	GoCommand                        ; $88 GO
>8ce4	07 88					.word	Command_List                     ; $89 LIST
>8ce6	82 a4					.word	LoadCommand                      ; $8a LOAD
>8ce8	c4 89					.word	NewCommand                       ; $8b NEW
>8cea	bb a5					.word	PingCommand                      ; $8c PING
>8cec	cc 8a					.word	Command_Restore                  ; $8d RESTORE
>8cee	0b 8b					.word	CommandRUN                       ; $8e RUN
>8cf0	d3 a5					.word	ShootCommand                     ; $8f SHOOT
>8cf2	3e a3					.word	SpritesCtrl                      ; $90 SPRITES
>8cf4	82 8d					.word	StopCommand                      ; $91 STOP
>8cf6	7e 8e					.word	WhoCommand                       ; $92 WHO
>8cf8	c7 a5					.word	ZapCommand                       ; $93 ZAP
.8cfa					VectorSet2:
>8cfa	9a 9f					.word	SyntaxError                      ; $80 !0:EOF
>8cfc	9a 9f					.word	SyntaxError                      ; $81 !1:SH1
>8cfe	9a 9f					.word	SyntaxError                      ; $82 !2:SH2
>8d00	59 9e					.word	Assemble_adc                     ; $83 ADC
>8d02	51 9e					.word	Assemble_and                     ; $84 AND
>8d04	6d 9e					.word	Assemble_asl                     ; $85 ASL
>8d06	d7 9e					.word	Assemble_bcc                     ; $86 BCC
>8d08	db 9e					.word	Assemble_bcs                     ; $87 BCS
>8d0a	e3 9e					.word	Assemble_beq                     ; $88 BEQ
>8d0c	9a 9e					.word	Assemble_bit                     ; $89 BIT
>8d0e	cb 9e					.word	Assemble_bmi                     ; $8a BMI
>8d10	df 9e					.word	Assemble_bne                     ; $8b BNE
>8d12	c7 9e					.word	Assemble_bpl                     ; $8c BPL
>8d14	e7 9e					.word	Assemble_bra                     ; $8d BRA
>8d16	eb 9e					.word	Assemble_brk                     ; $8e BRK
>8d18	cf 9e					.word	Assemble_bvc                     ; $8f BVC
>8d1a	d3 9e					.word	Assemble_bvs                     ; $90 BVS
>8d1c	f3 9e					.word	Assemble_clc                     ; $91 CLC
>8d1e	47 9f					.word	Assemble_cld                     ; $92 CLD
>8d20	07 9f					.word	Assemble_cli                     ; $93 CLI
>8d22	37 9f					.word	Assemble_clv                     ; $94 CLV
>8d24	65 9e					.word	Assemble_cmp                     ; $95 CMP
>8d26	ae 9e					.word	Assemble_cpx                     ; $96 CPX
>8d28	a9 9e					.word	Assemble_cpy                     ; $97 CPY
>8d2a	8b 9e					.word	Assemble_dec                     ; $98 DEC
>8d2c	43 9f					.word	Assemble_dex                     ; $99 DEX
>8d2e	1f 9f					.word	Assemble_dey                     ; $9a DEY
>8d30	55 9e					.word	Assemble_eor                     ; $9b EOR
>8d32	90 9e					.word	Assemble_inc                     ; $9c INC
>8d34	53 9f					.word	Assemble_inx                     ; $9d INX
>8d36	3f 9f					.word	Assemble_iny                     ; $9e INY
>8d38	c2 9e					.word	Assemble_jmp                     ; $9f JMP
>8d3a	bd 9e					.word	Assemble_jsr                     ; $a0 JSR
>8d3c	61 9e					.word	Assemble_lda                     ; $a1 LDA
>8d3e	86 9e					.word	Assemble_ldx                     ; $a2 LDX
>8d40	a4 9e					.word	Assemble_ldy                     ; $a3 LDY
>8d42	77 9e					.word	Assemble_lsr                     ; $a4 LSR
>8d44	57 9f					.word	Assemble_nop                     ; $a5 NOP
>8d46	4d 9e					.word	Assemble_ora                     ; $a6 ORA
>8d48	03 9f					.word	Assemble_pha                     ; $a7 PHA
>8d4a	ef 9e					.word	Assemble_php                     ; $a8 PHP
>8d4c	4b 9f					.word	Assemble_phx                     ; $a9 PHX
>8d4e	0b 9f					.word	Assemble_phy                     ; $aa PHY
>8d50	13 9f					.word	Assemble_pla                     ; $ab PLA
>8d52	f7 9e					.word	Assemble_plp                     ; $ac PLP
>8d54	5f 9f					.word	Assemble_plx                     ; $ad PLX
>8d56	1b 9f					.word	Assemble_ply                     ; $ae PLY
>8d58	72 9e					.word	Assemble_rol                     ; $af ROL
>8d5a	7c 9e					.word	Assemble_ror                     ; $b0 ROR
>8d5c	ff 9e					.word	Assemble_rti                     ; $b1 RTI
>8d5e	0f 9f					.word	Assemble_rts                     ; $b2 RTS
>8d60	69 9e					.word	Assemble_sbc                     ; $b3 SBC
>8d62	fb 9e					.word	Assemble_sec                     ; $b4 SEC
>8d64	5b 9f					.word	Assemble_sed                     ; $b5 SED
>8d66	17 9f					.word	Assemble_sei                     ; $b6 SEI
>8d68	5d 9e					.word	Assemble_sta                     ; $b7 STA
>8d6a	4f 9f					.word	Assemble_stp                     ; $b8 STP
>8d6c	81 9e					.word	Assemble_stx                     ; $b9 STX
>8d6e	9f 9e					.word	Assemble_sty                     ; $ba STY
>8d70	95 9e					.word	Assemble_stz                     ; $bb STZ
>8d72	33 9f					.word	Assemble_tax                     ; $bc TAX
>8d74	2f 9f					.word	Assemble_tay                     ; $bd TAY
>8d76	b8 9e					.word	Assemble_trb                     ; $be TRB
>8d78	b3 9e					.word	Assemble_tsb                     ; $bf TSB
>8d7a	3b 9f					.word	Assemble_tsx                     ; $c0 TSX
>8d7c	23 9f					.word	Assemble_txa                     ; $c1 TXA
>8d7e	2b 9f					.word	Assemble_txs                     ; $c2 TXS
>8d80	27 9f					.word	Assemble_tya                     ; $c3 TYA

;******  Return to file: ./common/commands/run.asm


;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/stop.asm

.8d82					StopCommand:
.8d82	a9 08		lda #$08		lda	#8
.8d84	4c fa 8e	jmp $8efa		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/procscan.asm

.8d87					ProcedureScan:
.8d87	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8d89	85 30		sta $30				sta 	codePtr
.8d8b	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8d8d	85 31		sta $31				sta 	codePtr+1
.8d8f					_PSLoop:
.8d8f	b2 30		lda ($30)			lda 	(codePtr)
.8d91	f0 42		beq $8dd5			beq 	_PSExit
.8d93	a0 03		ldy #$03			ldy 	#3 							; is it PROC at start of line ?
.8d95	b1 30		lda ($30),y			lda 	(codePtr),y
.8d97	c9 a4		cmp #$a4			cmp 	#KWD_PROC
.8d99	d0 2d		bne $8dc8			bne 	_PSNext
.8d9b	c8		iny				iny 								; get the address of the record to zTemp0 and
.8d9c	b1 30		lda ($30),y			lda 	(codePtr),y
.8d9e	29 c0		and #$c0			and 	#$C0
.8da0	c9 40		cmp #$40			cmp 	#$40
.8da2	d0 32		bne $8dd6			bne 	_PSSyntax
.8da4	b1 30		lda ($30),y			lda 	(codePtr),y
.8da6	18		clc				clc
.8da7	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8da9	85 37		sta $37				sta 	zTemp0+1
.8dab	c8		iny				iny 								; LSB
.8dac	b1 30		lda ($30),y			lda 	(codePtr),y
.8dae	85 36		sta $36				sta 	zTemp0
.8db0	c8		iny				iny 								; character after variable call.
.8db1	98		tya				tya 								; save Y offset at +7 (exponent slot)
.8db2	a0 07		ldy #$07			ldy 	#7
.8db4	91 36		sta ($36),y			sta 	(zTemp0),y
.8db6	a9 18		lda #$18			lda 	#NSTProcedure 				; mark it as procedure
.8db8	a0 02		ldy #$02			ldy 	#2
.8dba	91 36		sta ($36),y			sta 	(zTemp0),y
.8dbc	a2 00		ldx #$00			ldx 	#0 							; copy code-Ptr into offset 3-6 (mantissa)
.8dbe					_PSCopy:
.8dbe	b5 30		lda $30,x			lda 	safePtr,x
.8dc0	c8		iny				iny
.8dc1	91 36		sta ($36),y			sta 	(zTemp0),y
.8dc3	e8		inx				inx
.8dc4	e0 04		cpx #$04			cpx 	#4
.8dc6	d0 f6		bne $8dbe			bne 	_PSCopy
.8dc8					_PSNext:
.8dc8	18		clc				clc
.8dc9	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8dcb	65 30		adc $30				adc 	codePtr
.8dcd	85 30		sta $30				sta 	codePtr
.8dcf	90 02		bcc $8dd3			bcc 	_CREExit
.8dd1	e6 31		inc $31				inc 	codePtr+1 					; carry
.8dd3					_CREExit:
.8dd3	80 ba		bra $8d8f			bra 	_PSLoop
.8dd5					_PSExit:
.8dd5	60		rts				rts
.8dd6					_PSSyntax:
.8dd6	4c 9a 9f	jmp $9f9a			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/scanforward.asm

.8dd9					ScanForward:
.8dd9	64 38		stz $38				stz 	zTemp1 						; zero the structure count - goes up with WHILE/FOR down with WEND/NEXT etc.
.8ddb	86 37		stx $37				stx 	zTemp0+1
.8ddd	85 36		sta $36				sta 	zTemp0 						; save X & A as the two possible matches.
.8ddf					_ScanLoop:
.8ddf	b1 30		lda ($30),y			lda 	(codePtr),y
.8de1	c8		iny				iny
.8de2	a6 38		ldx $38				ldx 	zTemp1 						; if the count is > 0 cannot match as in substructure
.8de4	d0 0e		bne $8df4			bne 	_ScanGoNext
.8de6	c5 36		cmp $36				cmp 	zTemp0 						; see if either matches
.8de8	f0 04		beq $8dee			beq 	_ScanMatch
.8dea	c5 37		cmp $37				cmp 	zTemp0+1
.8dec	d0 06		bne $8df4			bne 	_ScanGoNext
.8dee					_ScanMatch:
.8dee	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if asked for EOL, backtrack.
.8df0	d0 01		bne $8df3			bne 	_ScanNotEndEOL
.8df2	88		dey				dey
.8df3					_ScanNotEndEOL:
.8df3	60		rts				rts
.8df4					_ScanGoNext:
.8df4	20 f9 8d	jsr $8df9			jsr  	ScanForwardOne 				; allows for shifts and so on.
.8df7	80 e6		bra $8ddf			bra 	_ScanLoop
.8df9					ScanForwardOne:
.8df9	c9 40		cmp #$40			cmp 	#$40 						; if 00-3F, punctuation characters, already done.
.8dfb	90 3e		bcc $8e3b			bcc 	_SFWExit
.8dfd	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if 40-82, skip one extra as these are 2 byte
.8dff	90 18		bcc $8e19			bcc 	_ScanSkipOne	 			; offsets into the identifier table or shifts.
.8e01	c9 fc		cmp #$fc			cmp 	#$FC 						; FC-FF are data skips (hex consts, strings etc.)
.8e03	b0 2f		bcs $8e34			bcs 	_ScanSkipData
.8e05	c9 a2		cmp #$a2			cmp 	#KWC_FIRST_STRUCTURE 		; structure keyword ?
.8e07	90 32		bcc $8e3b			bcc 	_SFWExit 					; if not, ordinary keywords.
.8e09	c9 ad		cmp #$ad			cmp 	#KWC_LAST_STRUCTURE+1
.8e0b	b0 2e		bcs $8e3b			bcs 	_SFWExit
.8e0d	c6 38		dec $38				dec 	zTemp1 						; decrement the sructure count
.8e0f	c9 a7		cmp #$a7			cmp 	#KWC_FIRST_STRUCTURE_DEC 	; back if it is a dec structure (e.g. WEND/NEXT)
.8e11	b0 28		bcs $8e3b			bcs 	_SFWExit
.8e13	e6 38		inc $38				inc 	zTemp1 						; so it's an increment structure
.8e15	e6 38		inc $38				inc 	zTemp1 						; twice to undo the dec
.8e17	80 22		bra $8e3b			bra 	_SFWExit
.8e19					_ScanSkipOne:
.8e19	c8		iny				iny 								; consume the extra one.
.8e1a	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if not EOL loop back
.8e1c	d0 1d		bne $8e3b			bne 	_SFWExit
.8e1e	18		clc				clc
.8e1f	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8e21	65 30		adc $30				adc 	codePtr
.8e23	85 30		sta $30				sta 	codePtr
.8e25	90 02		bcc $8e29			bcc 	_CREExit
.8e27	e6 31		inc $31				inc 	codePtr+1 					; carry
.8e29					_CREExit:
.8e29	a0 03		ldy #$03			ldy 	#3 							; scan start position.
.8e2b	b2 30		lda ($30)			lda 	(codePtr)
.8e2d	d0 0c		bne $8e3b			bne 	_SFWExit 					; if not zero, more to scan
.8e2f	a9 13		lda #$13		lda	#19
.8e31	4c fa 8e	jmp $8efa		jmp	ErrorHandler
.8e34					_ScanSkipData:
.8e34	88		dey				dey 								; point at data token
.8e35	c8		iny				iny 								; point to offset
.8e36	98		tya				tya 								; A = offset position
.8e37	38		sec				sec 								; add size +1 hence SEC
.8e38	71 30		adc ($30),y			adc 	(codePtr),y
.8e3a	a8		tay				tay 								; make current position.
.8e3b					_SFWExit:
.8e3b	60		rts				rts
.8e3c					ScanGetCurrentLineStep:
.8e3c	64 38		stz $38				stz 	zTemp1
.8e3e	a0 03		ldy #$03			ldy 	#3
.8e40					_SGCLSLoop:
.8e40	b1 30		lda ($30),y			lda 	(codePtr),y
.8e42	c8		iny				iny
.8e43	c9 80		cmp #$80			cmp 	#KWC_EOL	 				; if EOL exit
.8e45	f0 05		beq $8e4c			beq 	_SGCLSExit
.8e47	20 f9 8d	jsr $8df9			jsr 	ScanForwardOne
.8e4a	80 f4		bra $8e40			bra 	_SGCLSLoop
.8e4c					_SGCLSExit:
.8e4c	a5 38		lda $38				lda 	zTemp1 						; return the adjustment
.8e4e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/while.asm

.8e4f					Command_WHILE:
.8e4f	5a		phy				phy 								; save position of the test
.8e50	a2 00		ldx #$00			ldx 	#0 							; work out the while test.
.8e52	20 6a 9d	jsr $9d6a			jsr 	EvaluateNumber
.8e55	20 3e 9e	jsr $9e3e			jsr 	NSMIsZero 					; check if zero
.8e58	f0 0e		beq $8e68			beq 	_WHExitLoop 				; if so exit the loop, while has failed.
.8e5a	98		tya				tya 								; position *after* test.
.8e5b	7a		ply				ply 								; restore position before test, at WHILE
.8e5c	88		dey				dey 								; so we execute the WHILE command again.
.8e5d	48		pha				pha 								; push after test on the stack
.8e5e	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; allocate 6 bytes on the return stack.
.8e60	20 ae a6	jsr $a6ae			jsr 	StackOpen
.8e63	20 f3 a6	jsr $a6f3			jsr 	STKSaveCodePosition 		; save loop position - where the test value expr is.
.8e66	7a		ply				ply 								; restore the position *after* the test
.8e67	60		rts				rts
.8e68					_WHExitLoop:
.8e68	68		pla				pla 								; throw post loop position
.8e69	a9 ac		lda #$ac			lda 	#KWD_WEND 					; scan forward past WEND
.8e6b	aa		tax				tax
.8e6c	20 d9 8d	jsr $8dd9			jsr 	ScanForward
.8e6f	60		rts				rts
.8e70					Command_WEND:
.8e70	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; check WHILE is TOS e.g. in a while loop :)
.8e72	a2 10		ldx #$10			ldx 	#ERRID_WHILE 				; this error if not.
.8e74	20 db a6	jsr $a6db			jsr 	StackCheckFrame
.8e77	20 04 a7	jsr $a704			jsr 	STKLoadCodePosition 		; loop back to the WHILE keyword.
.8e7a	20 cd a6	jsr $a6cd			jsr 	StackClose		 			; erase the frame
.8e7d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/who.asm

.8e7e					WhoCommand:
.8e7e	a2 8e		ldx #$8e			ldx 	#(_WHOMessage >> 8)
.8e80	a9 86		lda #$86			lda 	#(_WHOMessage & $FF)
.8e82	20 53 8f	jsr $8f53			jsr 	PrintStringXA
.8e85	60		rts				rts
.8e86					_WHOMessage:
>8e86	81						.byte 	$81
>8e87	42 72 6f 75 67 68 74 20				.text 	"Brought to you by :",13,13
>8e8f	74 6f 20 79 6f 75 20 62 79 20 3a 0d 0d
>8e9c	09 53 74 65 66 61 6e 79				.text 	9,"Stefany Allaire",13
>8ea4	20 41 6c 6c 61 69 72 65 0d
>8ead	09 4a 65 73 73 69 65 20				.text 	9,"Jessie Oberreuter",13
>8eb5	4f 62 65 72 72 65 75 74 65 72 0d
>8ec0	09 50 61 75 6c 20 52 6f				.text 	9,"Paul Robson",13
>8ec8	62 73 6f 6e 0d
>8ecd	09 50 65 74 65 72 20 57				.text 	9,"Peter Weingartner",13
>8ed5	65 69 6e 67 61 72 74 6e 65 72 0d
>8ee0	00						.byte 	0

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/charcheck.asm

.8ee1					CheckRightBracket:
.8ee1	b1 30		lda ($30),y			lda 	(codePtr),y
.8ee3	c8		iny				iny
.8ee4	c9 29		cmp #$29			cmp 	#KWD_RPAREN 						; exit if matches
.8ee6	d0 0f		bne $8ef7			bne 	CNAFail
.8ee8	60		rts				rts
.8ee9					CheckComma:
.8ee9	b1 30		lda ($30),y			lda 	(codePtr),y
.8eeb	c8		iny				iny
.8eec	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 						; exit if matches
.8eee	d0 07		bne $8ef7			bne 	CNAFail
.8ef0	60		rts				rts
.8ef1					CheckNextA:
.8ef1	d1 30		cmp ($30),y			cmp 	(codePtr),y
.8ef3	d0 02		bne $8ef7			bne 	CNAFail
.8ef5	c8		iny				iny 								; skip character
.8ef6	60		rts				rts 								; and exit
.8ef7					CNAFail:
.8ef7	4c 9a 9f	jmp $9f9a			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/errors.asm

.8efa					ErrorHandler:
.8efa	a8		tay				tay 								; find the error text
.8efb	f0 49		beq $8f46			beq 	_EHEnd
.8efd	a2 00		ldx #$00			ldx 	#0
.8eff	a9 b3		lda #$b3			lda 	#((ErrorText) & $FF)
.8f01	85 36		sta $36				sta 	0+zTemp0
.8f03	a9 9f		lda #$9f			lda 	#((ErrorText) >> 8)
.8f05	85 37		sta $37				sta 	1+zTemp0
.8f07					_EHFind:
.8f07	88		dey				dey 								; keep looking through text
.8f08	f0 0e		beq $8f18			beq 	_EHFound
.8f0a					_EHFindZero:
.8f0a	b2 36		lda ($36)			lda 	(zTemp0) 					; find the next error
.8f0c	e6 36		inc $36				inc 	zTemp0
.8f0e	d0 02		bne $8f12			bne 	_EHFNoCarry
.8f10	e6 37		inc $37				inc 	zTemp0+1
.8f12					_EHFNoCarry:
.8f12	c9 00		cmp #$00			cmp 	#0
.8f14	d0 f4		bne $8f0a			bne 	_EHFindZero
.8f16	80 ef		bra $8f07			bra 	_EHFind
.8f18					_EHFound:
.8f18	a5 36		lda $36				lda 	zTemp0 						; print message
.8f1a	a6 37		ldx $37				ldx 	zTemp0+1
.8f1c	20 53 8f	jsr $8f53			jsr 	PrintStringXA
.8f1f	a0 01		ldy #$01			ldy 	#1 							; if line number zero don't print it
.8f21	b1 30		lda ($30),y			lda 	(codePtr),y
.8f23	d0 05		bne $8f2a			bne 	_EHAtMsg
.8f25	c8		iny				iny
.8f26	b1 30		lda ($30),y			lda 	(codePtr),y
.8f28	f0 17		beq $8f41			beq 	_EHCREnd
.8f2a					_EHAtMsg:
.8f2a	a2 8f		ldx #$8f			ldx 	#_AtMsg >> 8 				; print " at "
.8f2c	a9 49		lda #$49			lda 	#_AtMsg & $FF
.8f2e	20 53 8f	jsr $8f53			jsr 	PrintStringXA
.8f31	a0 01		ldy #$01			ldy 	#1 							; line number into XA
.8f33	b1 30		lda ($30),y			lda 	(codePtr),y
.8f35	48		pha				pha
.8f36	c8		iny				iny
.8f37	b1 30		lda ($30),y			lda 	(codePtr),y
.8f39	aa		tax				tax
.8f3a	68		pla				pla
.8f3b	20 69 93	jsr $9369			jsr 	ConvertInt16 				; convert XA to string
.8f3e	20 53 8f	jsr $8f53			jsr 	PrintStringXA 				; and print it.
.8f41					_EHCREnd:
.8f41	a9 0d		lda #$0d			lda 	#13 						; new line
.8f43	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8f46					_EHEnd:
.8f46	4c 78 83	jmp $8378			jmp 	WarmStart
>8f49	20 61 74 20 6c 69 6e 65		_AtMsg:	.text 	" at line ",0
>8f51	20 00
.8f53					PrintStringXA:
.8f53	5a		phy				phy
.8f54	86 37		stx $37				stx 	zTemp0+1
.8f56	85 36		sta $36				sta 	zTemp0
.8f58	a0 00		ldy #$00			ldy 	#0
.8f5a					_PSXALoop:
.8f5a	b1 36		lda ($36),y			lda 	(zTemp0),y
.8f5c	f0 06		beq $8f64			beq 	_PSXAExit
.8f5e	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8f61	c8		iny				iny
.8f62	80 f6		bra $8f5a			bra 	_PSXALoop
.8f64					_PSXAExit:
.8f64	7a		ply				ply
.8f65	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/compare.asm

.8f66					UnaryTrue:
.8f66	fa		plx				plx
.8f67					ReturnTrue:
.8f67	a9 01		lda #$01			lda 	#1  						; set to 1
.8f69	20 1e 9e	jsr $9e1e			jsr 	NSMSetByte
.8f6c	a9 80		lda #$80			lda 	#$80 						; set sign flag, so it is -1
.8f6e	95 50		sta $50,x			sta 	NSStatus,x
.8f70	60		rts				rts
.8f71					UnaryFalse:
.8f71	fa		plx				plx
.8f72					ReturnFalse:
.8f72	4c 1c 9e	jmp $9e1c			jmp 	NSMSetZero 					; set it all to zero
.8f75					BinaryCompareEqual:
.8f75	fa		plx				plx
.8f76	20 b1 8f	jsr $8fb1			jsr 	CompareBaseCode
.8f79	c9 00		cmp #$00			cmp 	#0
.8f7b	f0 ea		beq $8f67			beq 	ReturnTrue
.8f7d	80 f3		bra $8f72			bra 	ReturnFalse
.8f7f					BinaryCompareLess:
.8f7f	fa		plx				plx
.8f80	20 b1 8f	jsr $8fb1			jsr 	CompareBaseCode
.8f83	c9 ff		cmp #$ff			cmp 	#$FF
.8f85	f0 e0		beq $8f67			beq 	ReturnTrue
.8f87	80 e9		bra $8f72			bra 	ReturnFalse
.8f89					BinaryCompareGreater:
.8f89	fa		plx				plx
.8f8a	20 b1 8f	jsr $8fb1			jsr 	CompareBaseCode
.8f8d	c9 01		cmp #$01			cmp 	#1
.8f8f	f0 d6		beq $8f67			beq 	ReturnTrue
.8f91	80 df		bra $8f72			bra 	ReturnFalse
.8f93					BinaryCompareNotEqual:
.8f93	fa		plx				plx
.8f94	20 b1 8f	jsr $8fb1			jsr 	CompareBaseCode
.8f97	c9 00		cmp #$00			cmp 	#0
.8f99	d0 cc		bne $8f67			bne 	ReturnTrue
.8f9b	80 d5		bra $8f72			bra 	ReturnFalse
.8f9d					BinaryCompareLessEqual:
.8f9d	fa		plx				plx
.8f9e	20 b1 8f	jsr $8fb1			jsr 	CompareBaseCode
.8fa1	c9 01		cmp #$01			cmp 	#1
.8fa3	d0 c2		bne $8f67			bne 	ReturnTrue
.8fa5	80 cb		bra $8f72			bra 	ReturnFalse
.8fa7					BinaryCompareGreaterEqual:
.8fa7	fa		plx				plx
.8fa8	20 b1 8f	jsr $8fb1			jsr 	CompareBaseCode
.8fab	c9 ff		cmp #$ff			cmp 	#$FF
.8fad	d0 b8		bne $8f67			bne 	ReturnTrue
.8faf	80 c1		bra $8f72			bra 	ReturnFalse
.8fb1					CompareBaseCode:
.8fb1	20 bc 96	jsr $96bc			jsr 	DereferenceTopTwo 			; make both values if references.
.8fb4	b5 50		lda $50,x			lda 	NSStatus,x 					; check if either is a string.
.8fb6	15 51		ora $51,x			ora 	NSStatus+1,x
.8fb8	29 10		and #$10			and 	#NSTString
.8fba	d0 37		bne $8ff3			bne 	_CBCString 					; if so do string code, which will check if both.
.8fbc	b5 78		lda $78,x			lda 	NSExponent,x 				; check both are integers
.8fbe	15 79		ora $79,x			ora 	NSExponent+1,x
.8fc0	d0 34		bne $8ff6			bne 	_CBCFloat
.8fc2	b5 50		lda $50,x			lda 	NSStatus,x
.8fc4	15 51		ora $51,x			ora 	NSStatus+1,x
.8fc6	29 08		and #$08			and 	#NSTFloat
.8fc8	d0 2c		bne $8ff6			bne 	_CBCFloat
.8fca	20 f9 8f	jsr $8ff9			jsr 	CompareFixMinusZero 		; fix up -0 just in cases.
.8fcd	e8		inx				inx
.8fce	20 f9 8f	jsr $8ff9			jsr 	CompareFixMinusZero
.8fd1	ca		dex				dex
.8fd2	b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs different ?
.8fd4	55 51		eor $51,x			eor 	NSStatus+1,x
.8fd6	10 0a		bpl $8fe2			bpl 	_CDCSameSign
.8fd8	b5 50		lda $50,x			lda 	NSStatus,x 					; if first one is -ve
.8fda	30 14		bmi $8ff0			bmi 	_CBCLess 					; return $FF
.8fdc					_CBCGreater:
.8fdc	a9 01		lda #$01			lda 	#1
.8fde	60		rts				rts
.8fdf					_CBCEqual:
.8fdf	a9 00		lda #$00			lda 	#0
.8fe1	60		rts				rts
.8fe2					_CDCSameSign:
.8fe2	20 0e 92	jsr $920e			jsr 	SubTopTwoStack 				; unsigned subtract
.8fe5	20 3e 9e	jsr $9e3e			jsr 	NSMIsZero 					; or the mantissa together
.8fe8	f0 f5		beq $8fdf			beq 	_CBCEqual 					; -0 == 0
.8fea	b5 70		lda $70,x			lda 	NSMantissa3,x 				; sign of the result. if +ve return $01 else return $FF
.8fec	55 51		eor $51,x			eor 	NSStatus+1,x 				; however if both were -ve this is inverted
.8fee	10 ec		bpl $8fdc			bpl 	_CBCGreater
.8ff0					_CBCLess:
.8ff0	a9 ff		lda #$ff			lda 	#$FF
.8ff2	60		rts				rts
.8ff3					_CBCString:
.8ff3	4c 7f 91	jmp $917f			jmp 	CompareStrings
.8ff6					_CBCFloat:
.8ff6	4c c9 94	jmp $94c9			jmp 	CompareFloat
.8ff9					CompareFixMinusZero:
.8ff9	20 3e 9e	jsr $9e3e			jsr 	NSMIsZero
.8ffc	d0 02		bne $9000			bne 	_CFXMZNotZero
.8ffe	74 50		stz $50,x			stz 	NSStatus,x
.9000					_CFXMZNotZero:
.9000	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/concat.asm

.9001					StringConcat:
.9001	b5 50		lda $50,x			lda 	NSStatus,x 					; check both strings
.9003	35 51		and $51,x			and 	NSStatus+1,x
.9005	29 18		and #$18			and 	#NSBTypeMask
.9007	c9 10		cmp #$10			cmp 	#NSTString
.9009	d0 50		bne $905b			bne		_SCType
.900b	64 38		stz $38				stz 	zTemp1 						; counting total length
.900d	e8		inx				inx
.900e	20 2c 90	jsr $902c			jsr 	_SCSetupZ0 					; setup for second
.9011	20 35 90	jsr $9035			jsr 	_SCLengthZ0 				; length for second
.9014	ca		dex				dex
.9015	20 2c 90	jsr $902c			jsr 	_SCSetupZ0 					; setup for first
.9018	20 35 90	jsr $9035			jsr 	_SCLengthZ0 				; length for first
.901b	a5 38		lda $38				lda 	zTemp1 						; allocate memory using total.
.901d	20 9e a7	jsr $a79e			jsr 	StringTempAllocate
.9020	20 4c 90	jsr $904c			jsr 	_SCCopy 					; copy first out, using zTemp0 from above
.9023	e8		inx				inx
.9024	20 2c 90	jsr $902c			jsr 	_SCSetupZ0 					; copy second out
.9027	20 4c 90	jsr $904c			jsr 	_SCCopy
.902a	ca		dex				dex
.902b	60		rts				rts
.902c					_SCSetupZ0:
.902c	b5 58		lda $58,x			lda 	NSMantissa0,x
.902e	85 36		sta $36				sta 	zTemp0
.9030	b5 60		lda $60,x			lda 	NSMantissa1,x
.9032	85 37		sta $37				sta 	zTemp0+1
.9034	60		rts				rts
.9035					_SCLengthZ0:
.9035	5a		phy				phy
.9036	a0 00		ldy #$00			ldy 	#0
.9038					_SCLenLoop:
.9038	b1 36		lda ($36),y			lda 	(zTemp0),y
.903a	f0 0e		beq $904a			beq 	_SCLExit
.903c	c8		iny				iny
.903d	e6 38		inc $38				inc 	zTemp1
.903f	a5 38		lda $38				lda	 	zTemp1 						; check string too long.
.9041	c9 fd		cmp #$fd			cmp 	#253
.9043	d0 f3		bne $9038			bne		_SCLenLoop
.9045	a9 09		lda #$09		lda	#9
.9047	4c fa 8e	jmp $8efa		jmp	ErrorHandler
.904a					_SCLExit:
.904a	7a		ply				ply
.904b	60		rts				rts
.904c					_SCCopy:
.904c	5a		phy				phy
.904d	a0 00		ldy #$00			ldy 	#0
.904f					_SCCopyLoop:
.904f	b1 36		lda ($36),y			lda 	(zTemp0),y
.9051	f0 06		beq $9059			beq 	_SCCExit
.9053	20 d7 a7	jsr $a7d7			jsr 	StringTempWrite
.9056	c8		iny				iny
.9057	80 f6		bra $904f			bra 	_SCCopyLoop
.9059					_SCCExit:
.9059	7a		ply				ply
.905a	60		rts				rts
.905b					_SCType:
.905b	4c a4 9f	jmp $9fa4			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/divide.asm

.905e					IntegerDivide:
.905e	fa		plx				plx
.905f	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9061	15 51		ora $51,x			ora 	NSStatus+1,x
.9063	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9064	0a		asl a				asl 	a
.9065	10 05		bpl $906c			bpl 	_NotRef
.9067	48		pha				pha
.9068	20 bc 96	jsr $96bc			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.906b	68		pla				pla
.906c					_NotRef:
.906c	0a		asl a				asl 	a
.906d	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.906f	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9071	15 79		ora $79,x			ora 	NSExponent+1,x
.9073	f0 03		beq $9078			beq 	_IntegerCode 				; if clear, then we have two integers
.9075	4c a4 9f	jmp $9fa4			jmp 	TypeError 					; anything else, type mismatch.
.9078					_IntegerCode:
.9078	20 92 90	jsr $9092			jsr 	CheckDivideZero 			; do div zero check
.907b	20 c4 90	jsr $90c4			jsr 	Int32Divide 				; do the division
.907e	20 75 91	jsr $9175			jsr 	CalculateSign 				; calculate result sign
.9081					NSMCopyPlusTwoToZero:
.9081	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.9083	95 58		sta $58,x			sta 	NSMantissa0,x
.9085	b5 62		lda $62,x			lda 	NSMantissa1+2,x
.9087	95 60		sta $60,x			sta 	NSMantissa1,x
.9089	b5 6a		lda $6a,x			lda 	NSMantissa2+2,x
.908b	95 68		sta $68,x			sta 	NSMantissa2,x
.908d	b5 72		lda $72,x			lda 	NSMantissa3+2,x
.908f	95 70		sta $70,x			sta 	NSMantissa3,x
.9091	60		rts				rts
.9092					CheckDivideZero:
.9092	e8		inx				inx
.9093	20 3e 9e	jsr $9e3e			jsr 	NSMIsZero
.9096	f0 02		beq $909a			beq 	_CDVError
.9098	ca		dex				dex
.9099	60		rts				rts
.909a					_CDVError:
.909a	a9 03		lda #$03		lda	#3
.909c	4c fa 8e	jmp $8efa		jmp	ErrorHandler
.909f					IntegerModulus:
.909f	fa		plx				plx
.90a0	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.90a2	15 51		ora $51,x			ora 	NSStatus+1,x
.90a4	0a		asl a				asl 	a 							; shift reference bit into sign bit
.90a5	0a		asl a				asl 	a
.90a6	10 05		bpl $90ad			bpl 	_NotRef
.90a8	48		pha				pha
.90a9	20 bc 96	jsr $96bc			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.90ac	68		pla				pla
.90ad					_NotRef:
.90ad	0a		asl a				asl 	a
.90ae	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.90b0	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.90b2	15 79		ora $79,x			ora 	NSExponent+1,x
.90b4	f0 03		beq $90b9			beq 	_IntegerCode 				; if clear, then we have two integers
.90b6	4c a4 9f	jmp $9fa4			jmp 	TypeError 					; anything else, type mismatch.
.90b9					_IntegerCode:
.90b9					IntegerModulusNoCheck:
.90b9	20 92 90	jsr $9092			jsr 	CheckDivideZero 			; do div zero check
.90bc	20 c4 90	jsr $90c4			jsr 	Int32Divide 				; do the division
.90bf	16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.90c1	56 50		lsr $50,x			lsr 	NSStatus,x
.90c3	60		rts				rts
.90c4					Int32Divide:
.90c4	48		pha				pha 								; save AXY
.90c5	5a		phy				phy
.90c6	20 ff 9d	jsr $9dff			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.90c9	20 18 9e	jsr $9e18			jsr 	NSMSetZeroMantissaOnly 		; set S[X] to zero
.90cc	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.90ce					_I32DivideLoop:
.90ce	e8		inx				inx
.90cf	e8		inx				inx
.90d0	20 2b 9e	jsr $9e2b			jsr 	NSMShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.90d3	ca		dex				dex
.90d4	ca		dex				dex
.90d5	20 2c 9e	jsr $9e2c			jsr 	NSMRotateLeft
.90d8	20 03 91	jsr $9103			jsr 	DivideCheckSubtract 		; check if subtract possible
.90db	90 02		bcc $90df			bcc 	_I32DivideNoCarryIn
.90dd	f6 5a		inc $5a,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.90df					_I32DivideNoCarryIn:
.90df	88		dey				dey 								; loop round till division completed.
.90e0	d0 ec		bne $90ce			bne 	_I32DivideLoop
.90e2	7a		ply				ply 								; restore AXY and exit
.90e3	68		pla				pla
.90e4	60		rts				rts
.90e5					Int32ShiftDivide:
.90e5	48		pha				pha 								; save AY
.90e6	5a		phy				phy
.90e7	e8		inx				inx 								; clear S[X+2]
.90e8	e8		inx				inx
.90e9	20 1c 9e	jsr $9e1c			jsr 	NSMSetZero
.90ec	ca		dex				dex
.90ed	ca		dex				dex
.90ee	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.90f0					_I32SDLoop:
.90f0	20 03 91	jsr $9103			jsr 	DivideCheckSubtract 		; check if subtract possible
.90f3	e8		inx				inx
.90f4	e8		inx				inx
.90f5	20 2c 9e	jsr $9e2c			jsr 	NSMRotateLeft				; shift 64 bit FPA left, rotating carry in
.90f8	ca		dex				dex
.90f9	ca		dex				dex
.90fa	20 2c 9e	jsr $9e2c			jsr 	NSMRotateLeft
.90fd	88		dey				dey 	 							; do 31 times
.90fe	d0 f0		bne $90f0			bne 	_I32SDLoop
.9100	7a		ply				ply 								; restore AY and exit
.9101	68		pla				pla
.9102	60		rts				rts
.9103					DivideCheckSubtract:
.9103	20 0e 92	jsr $920e			jsr 	SubTopTwoStack 				; subtract Stack[X+1] from Stack[X+0]
.9106	b0 04		bcs $910c			bcs 	_DCSExit 					; if carry set, then could do, exit
.9108	20 f4 91	jsr $91f4			jsr 	AddTopTwoStack 				; add it back in
.910b	18		clc				clc 								; and return False
.910c					_DCSExit:
.910c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/multiply.asm

.910d					MulInteger:
.910d	fa		plx				plx
.910e	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9110	15 51		ora $51,x			ora 	NSStatus+1,x
.9112	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9113	0a		asl a				asl 	a
.9114	10 05		bpl $911b			bpl 	_NotRef
.9116	48		pha				pha
.9117	20 bc 96	jsr $96bc			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.911a	68		pla				pla
.911b					_NotRef:
.911b	0a		asl a				asl 	a 							; put MSB of type into A:7
.911c	30 09		bmi $9127			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.911e	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9120	15 79		ora $79,x			ora 	NSExponent+1,x
.9122	f0 06		beq $912a			beq 	_IntegerCode 				; if clear, then we have two integers
.9124	4c 8b 95	jmp $958b			jmp 	FloatingPointMultiply 							; otherwise at least one float.
.9127					_StringData:
.9127	4c ae 9f	jmp $9fae			jmp 	NotDoneError							; at least one string - don't know both are strings.
.912a					_IntegerCode:
.912a	20 37 91	jsr $9137			jsr 	MultiplyShort
.912d	c9 00		cmp #$00			cmp 	#0
.912f	f0 05		beq $9136			beq 	_MIExit
.9131	a9 04		lda #$04		lda	#4
.9133	4c fa 8e	jmp $8efa		jmp	ErrorHandler
.9136					_MIExit:
.9136	60		rts				rts
.9137					MultiplyShort:
.9137	5a		phy				phy 								; save Y
.9138	20 ff 9d	jsr $9dff			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.913b	20 18 9e	jsr $9e18			jsr 	NSMSetZeroMantissaOnly 		; set mantissa S[X] to zero
.913e	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.9140					_I32MLoop:
.9140	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.9142	15 62		ora $62,x			ora 	NSMantissa1+2,x
.9144	15 6a		ora $6a,x			ora 	NSMantissa2+2,x
.9146	15 72		ora $72,x			ora 	NSMantissa3+2,x
.9148	f0 25		beq $916f			beq 	_I32MExit 					; exit if zero
.914a	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.914c	29 01		and #$01			and 	#1
.914e	f0 0d		beq $915d			beq 	_I32MNoAdd
.9150	20 f4 91	jsr $91f4			jsr 	AddTopTwoStack 				; if so add S[X+1] to S[X+0]
.9153	b5 70		lda $70,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.9155	10 06		bpl $915d			bpl 	_I32MNoAdd
.9157					_I32ShiftRight:
.9157	20 35 9e	jsr $9e35			jsr 	NSMShiftRight 				; shift S[X] right
.915a	c8		iny				iny 								; increment shift count
.915b	80 09		bra $9166			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.915d					_I32MNoAdd:
.915d	34 71		bit $71,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.915f	70 f6		bvs $9157			bvs 	_I32ShiftRight 				; instead.
.9161	e8		inx				inx
.9162	20 2b 9e	jsr $9e2b			jsr 	NSMShiftLeft 				; shift additive S[X+1] left
.9165	ca		dex				dex
.9166					_I32MShiftUpper:
.9166	e8		inx				inx 								; shift S[X+2] right
.9167	e8		inx				inx
.9168	20 35 9e	jsr $9e35			jsr 	NSMShiftRight
.916b	ca		dex				dex
.916c	ca		dex				dex
.916d	80 d1		bra $9140			bra 	_I32MLoop 					; try again.
.916f					_I32MExit:
.916f	20 75 91	jsr $9175			jsr 	CalculateSign
.9172	98		tya				tya 								; shift in A
.9173	7a		ply				ply 								; restore Y and exit
.9174	60		rts				rts
.9175					CalculateSign:
.9175	b5 50		lda $50,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.9177	16 50		asl $50,x			asl 	NSStatus,x 					; shift result left
.9179	55 51		eor $51,x			eor 	NSStatus+1,x
.917b	0a		asl a				asl 	a 							; shift bit 7 into carry
.917c	76 50		ror $50,x			ror 	NSStatus,x 					; shift right into status byte.
.917e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/scompare.asm

.917f					CompareStrings:
.917f	b5 50		lda $50,x			lda 	NSStatus,x 					; check both are strings
.9181	35 51		and $51,x			and 	NSStatus+1,x
.9183	29 10		and #$10			and 	#NSBIsString
.9185	f0 28		beq $91af			beq 	_CSTypeError
.9187	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy string addresses to zTemp0/1
.9189	85 36		sta $36				sta 	zTemp0
.918b	b5 60		lda $60,x			lda 	NSMantissa1,x
.918d	85 37		sta $37				sta 	zTemp0+1
.918f	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9191	85 38		sta $38				sta 	zTemp1
.9193	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9195	85 39		sta $39				sta 	zTemp1+1
.9197	5a		phy				phy 								; save Y so we can access strings
.9198	a0 ff		ldy #$ff			ldy 	#$FF 						; -1 for pre increment.
.919a					_CSLoop:
.919a	c8		iny				iny
.919b	b1 36		lda ($36),y			lda 	(zTemp0),y 					; check if they are the same
.919d	d1 38		cmp ($38),y			cmp 	(zTemp1),y
.919f	d0 06		bne $91a7			bne 	_CSDifferent
.91a1	c9 00		cmp #$00			cmp 	#0 							; reached end ?
.91a3	d0 f5		bne $919a			bne 	_CSLoop 					; still comparing
.91a5					_CSExit:
.91a5	7a		ply				ply 								; reached end, return zero in A from EOS
.91a6	60		rts				rts
.91a7					_CSDifferent:
.91a7	a9 ff		lda #$ff			lda 	#255 						; if < return $FF
.91a9	90 fa		bcc $91a5			bcc		_CSExit
.91ab	a9 01		lda #$01			lda 	#1 							; otherwise return 1.
.91ad	80 f6		bra $91a5			bra 	_CSExit
.91af					_CSTypeError:
.91af	4c a4 9f	jmp $9fa4			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/shifts.asm

.91b2					ShiftLeft:
.91b2	38		sec				sec 								; common code, carry determines which way.
.91b3	80 01		bra $91b6			bra 	ShiftMain
.91b5					ShiftRight:
.91b5	18		clc				clc
.91b6					ShiftMain:
.91b6	fa		plx				plx 								; restore X
.91b7	08		php				php 								; save direction
.91b8	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.91ba	15 51		ora $51,x			ora 	NSStatus+1,x
.91bc	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91bd	0a		asl a				asl 	a
.91be	10 05		bpl $91c5			bpl 	_NotRef
.91c0	48		pha				pha
.91c1	20 bc 96	jsr $96bc			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91c4	68		pla				pla
.91c5					_NotRef:
.91c5	0a		asl a				asl 	a
.91c6	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.91c8	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91ca	15 79		ora $79,x			ora 	NSExponent+1,x
.91cc	f0 03		beq $91d1			beq 	_IntegerCode 				; if clear, then we have two integers
.91ce	4c a4 9f	jmp $9fa4			jmp 	TypeError 					; anything else, type mismatch.
.91d1					_IntegerCode:
.91d1	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; check number < 32
.91d3	29 e0		and #$e0			and 	#$E0
.91d5	15 61		ora $61,x			ora 	NSMantissa1+1,x
.91d7	15 69		ora $69,x			ora 	NSMantissa2+1,x
.91d9	15 71		ora $71,x			ora 	NSMantissa3+1,x
.91db	d0 12		bne $91ef			bne 	_SMExit0 					; if >= 32 it will always return zero.
.91dd					_SMLoop:
.91dd	d6 59		dec $59,x			dec 	NSMantissa0+1,x 			; predecrement, could do << 0
.91df	30 11		bmi $91f2			bmi 	_SMExit 					; exit if done.
.91e1	28		plp				plp 								; restore direction setting
.91e2	08		php				php
.91e3	90 05		bcc $91ea			bcc 	_SMRight
.91e5	20 2b 9e	jsr $9e2b			jsr 	NSMShiftLeft 				; shift left if CS
.91e8	80 f3		bra $91dd			bra 	_SMLoop
.91ea					_SMRight:
.91ea	20 35 9e	jsr $9e35			jsr 	NSMShiftRight 				; shift right if CC
.91ed	80 ee		bra $91dd			bra 	_SMLoop
.91ef					_SMExit0:
.91ef	20 1c 9e	jsr $9e1c			jsr 	NSMSetZero 					; return zero.
.91f2					_SMExit:
.91f2	28		plp				plp 								; throw direction
.91f3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/simple.asm

.91f4					AddTopTwoStack:
.91f4	18		clc				clc
.91f5	b5 58		lda $58,x			lda		NSMantissa0,x
.91f7	75 59		adc $59,x			adc 		NSMantissa0+1,x
.91f9	95 58		sta $58,x			sta 	NSMantissa0,x
.91fb	b5 60		lda $60,x			lda		NSMantissa1,x
.91fd	75 61		adc $61,x			adc 		NSMantissa1+1,x
.91ff	95 60		sta $60,x			sta 	NSMantissa1,x
.9201	b5 68		lda $68,x			lda		NSMantissa2,x
.9203	75 69		adc $69,x			adc 		NSMantissa2+1,x
.9205	95 68		sta $68,x			sta 	NSMantissa2,x
.9207	b5 70		lda $70,x			lda		NSMantissa3,x
.9209	75 71		adc $71,x			adc 		NSMantissa3+1,x
.920b	95 70		sta $70,x			sta 	NSMantissa3,x
.920d	60		rts				rts
.920e					SubTopTwoStack:
.920e	38		sec				sec
.920f	b5 58		lda $58,x			lda		NSMantissa0,x
.9211	f5 59		sbc $59,x			sbc 		NSMantissa0+1,x
.9213	95 58		sta $58,x			sta 	NSMantissa0,x
.9215	b5 60		lda $60,x			lda		NSMantissa1,x
.9217	f5 61		sbc $61,x			sbc 		NSMantissa1+1,x
.9219	95 60		sta $60,x			sta 	NSMantissa1,x
.921b	b5 68		lda $68,x			lda		NSMantissa2,x
.921d	f5 69		sbc $69,x			sbc 		NSMantissa2+1,x
.921f	95 68		sta $68,x			sta 	NSMantissa2,x
.9221	b5 70		lda $70,x			lda		NSMantissa3,x
.9223	f5 71		sbc $71,x			sbc 		NSMantissa3+1,x
.9225	95 70		sta $70,x			sta 	NSMantissa3,x
.9227	60		rts				rts
.9228					AddInteger:
.9228	fa		plx				plx
.9229	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.922b	15 51		ora $51,x			ora 	NSStatus+1,x
.922d	0a		asl a				asl 	a 							; shift reference bit into sign bit
.922e	0a		asl a				asl 	a
.922f	10 05		bpl $9236			bpl 	_NotRef
.9231	48		pha				pha
.9232	20 bc 96	jsr $96bc			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9235	68		pla				pla
.9236					_NotRef:
.9236	0a		asl a				asl 	a 							; put MSB of type into A:7
.9237	30 09		bmi $9242			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9239	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.923b	15 79		ora $79,x			ora 	NSExponent+1,x
.923d	f0 06		beq $9245			beq 	_IntegerCode 				; if clear, then we have two integers
.923f	4c 3b 94	jmp $943b			jmp 	FloatingPointAdd 							; otherwise at least one float.
.9242					_StringData:
.9242	4c 01 90	jmp $9001			jmp 	StringConcat							; at least one string - don't know both are strings.
.9245					_IntegerCode:
.9245					AddCode:
.9245	b5 50		lda $50,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.9247	55 51		eor $51,x			eor 	NSStatus+1,x
.9249	10 a9		bpl $91f4			bpl 	AddTopTwoStack
.924b	20 0e 92	jsr $920e			jsr 	SubTopTwoStack 				; do a physical subtraction
.924e	34 70		bit $70,x			bit 	NSMantissa3,x 				; result is +ve, okay
.9250	10 07		bpl $9259			bpl 	_AddExit
.9252	b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign is that of 2nd value
.9254	95 50		sta $50,x			sta 	NSStatus,x
.9256	20 e5 9d	jsr $9de5			jsr 	NSMNegateMantissa 			; negate the mantissa and exit
.9259					_AddExit:
.9259	20 3e 9e	jsr $9e3e			jsr 	NSMIsZero 					; check for -0
.925c	d0 02		bne $9260			bne 	_AddNonZero
.925e	74 50		stz $50,x			stz 	NSStatus,x
.9260					_AddNonZero:
.9260	60		rts				rts
.9261					SubInteger:
.9261	fa		plx				plx
.9262	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9264	15 51		ora $51,x			ora 	NSStatus+1,x
.9266	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9267	0a		asl a				asl 	a
.9268	10 05		bpl $926f			bpl 	_NotRef
.926a	48		pha				pha
.926b	20 bc 96	jsr $96bc			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.926e	68		pla				pla
.926f					_NotRef:
.926f	0a		asl a				asl 	a 							; put MSB of type into A:7
.9270	30 09		bmi $927b			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9272	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9274	15 79		ora $79,x			ora 	NSExponent+1,x
.9276	f0 06		beq $927e			beq 	_IntegerCode 				; if clear, then we have two integers
.9278	4c 40 94	jmp $9440			jmp 	FloatingPointSub 							; otherwise at least one float.
.927b					_StringData:
.927b	4c ae 9f	jmp $9fae			jmp 	NotDoneError							; at least one string - don't know both are strings.
.927e					_IntegerCode:
.927e	b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate the second value.
.9280	49 80		eor #$80			eor 	#$80
.9282	95 51		sta $51,x			sta 	NSStatus+1,x
.9284	80 bf		bra $9245			bra 	AddCode 					; and do the same code as add.
.9286					AndInteger:
.9286	fa		plx				plx
.9287	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9289	15 51		ora $51,x			ora 	NSStatus+1,x
.928b	0a		asl a				asl 	a 							; shift reference bit into sign bit
.928c	0a		asl a				asl 	a
.928d	10 05		bpl $9294			bpl 	_NotRef
.928f	48		pha				pha
.9290	20 bc 96	jsr $96bc			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9293	68		pla				pla
.9294					_NotRef:
.9294	0a		asl a				asl 	a
.9295	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9297	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9299	15 79		ora $79,x			ora 	NSExponent+1,x
.929b	f0 03		beq $92a0			beq 	_IntegerCode 				; if clear, then we have two integers
.929d	4c a4 9f	jmp $9fa4			jmp 	TypeError 					; anything else, type mismatch.
.92a0					_IntegerCode:
.92a0	b5 58		lda $58,x			lda		NSMantissa0,x
.92a2	35 59		and $59,x			and 		NSMantissa0+1,x
.92a4	95 58		sta $58,x			sta 	NSMantissa0,x
.92a6	b5 60		lda $60,x			lda		NSMantissa1,x
.92a8	35 61		and $61,x			and 		NSMantissa1+1,x
.92aa	95 60		sta $60,x			sta 	NSMantissa1,x
.92ac	b5 68		lda $68,x			lda		NSMantissa2,x
.92ae	35 69		and $69,x			and 		NSMantissa2+1,x
.92b0	95 68		sta $68,x			sta 	NSMantissa2,x
.92b2	b5 70		lda $70,x			lda		NSMantissa3,x
.92b4	35 71		and $71,x			and 		NSMantissa3+1,x
.92b6	95 70		sta $70,x			sta 	NSMantissa3,x
.92b8	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.92ba	60		rts				rts
.92bb					OraInteger:
.92bb	fa		plx				plx
.92bc	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.92be	15 51		ora $51,x			ora 	NSStatus+1,x
.92c0	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92c1	0a		asl a				asl 	a
.92c2	10 05		bpl $92c9			bpl 	_NotRef
.92c4	48		pha				pha
.92c5	20 bc 96	jsr $96bc			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92c8	68		pla				pla
.92c9					_NotRef:
.92c9	0a		asl a				asl 	a
.92ca	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.92cc	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92ce	15 79		ora $79,x			ora 	NSExponent+1,x
.92d0	f0 03		beq $92d5			beq 	_IntegerCode 				; if clear, then we have two integers
.92d2	4c a4 9f	jmp $9fa4			jmp 	TypeError 					; anything else, type mismatch.
.92d5					_IntegerCode:
.92d5	b5 58		lda $58,x			lda		NSMantissa0,x
.92d7	15 59		ora $59,x			ora 		NSMantissa0+1,x
.92d9	95 58		sta $58,x			sta 	NSMantissa0,x
.92db	b5 60		lda $60,x			lda		NSMantissa1,x
.92dd	15 61		ora $61,x			ora 		NSMantissa1+1,x
.92df	95 60		sta $60,x			sta 	NSMantissa1,x
.92e1	b5 68		lda $68,x			lda		NSMantissa2,x
.92e3	15 69		ora $69,x			ora 		NSMantissa2+1,x
.92e5	95 68		sta $68,x			sta 	NSMantissa2,x
.92e7	b5 70		lda $70,x			lda		NSMantissa3,x
.92e9	15 71		ora $71,x			ora 		NSMantissa3+1,x
.92eb	95 70		sta $70,x			sta 	NSMantissa3,x
.92ed	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.92ef	60		rts				rts
.92f0					EorInteger:
.92f0	fa		plx				plx
.92f1	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.92f3	15 51		ora $51,x			ora 	NSStatus+1,x
.92f5	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92f6	0a		asl a				asl 	a
.92f7	10 05		bpl $92fe			bpl 	_NotRef
.92f9	48		pha				pha
.92fa	20 bc 96	jsr $96bc			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92fd	68		pla				pla
.92fe					_NotRef:
.92fe	0a		asl a				asl 	a
.92ff	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9301	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9303	15 79		ora $79,x			ora 	NSExponent+1,x
.9305	f0 03		beq $930a			beq 	_IntegerCode 				; if clear, then we have two integers
.9307	4c a4 9f	jmp $9fa4			jmp 	TypeError 					; anything else, type mismatch.
.930a					_IntegerCode:
.930a	b5 58		lda $58,x			lda		NSMantissa0,x
.930c	55 59		eor $59,x			eor 		NSMantissa0+1,x
.930e	95 58		sta $58,x			sta 	NSMantissa0,x
.9310	b5 60		lda $60,x			lda		NSMantissa1,x
.9312	55 61		eor $61,x			eor 		NSMantissa1+1,x
.9314	95 60		sta $60,x			sta 	NSMantissa1,x
.9316	b5 68		lda $68,x			lda		NSMantissa2,x
.9318	55 69		eor $69,x			eor 		NSMantissa2+1,x
.931a	95 68		sta $68,x			sta 	NSMantissa2,x
.931c	b5 70		lda $70,x			lda		NSMantissa3,x
.931e	55 71		eor $71,x			eor 		NSMantissa3+1,x
.9320	95 70		sta $70,x			sta 	NSMantissa3,x
.9322	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.9324	60		rts				rts
.9325					WordIndirect:
.9325	fa		plx				plx
.9326	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9328	15 51		ora $51,x			ora 	NSStatus+1,x
.932a	0a		asl a				asl 	a 							; shift reference bit into sign bit
.932b	0a		asl a				asl 	a
.932c	10 05		bpl $9333			bpl 	_NotRef
.932e	48		pha				pha
.932f	20 bc 96	jsr $96bc			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9332	68		pla				pla
.9333					_NotRef:
.9333	0a		asl a				asl 	a
.9334	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9336	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9338	15 79		ora $79,x			ora 	NSExponent+1,x
.933a	f0 03		beq $933f			beq 	_IntegerCode 				; if clear, then we have two integers
.933c	4c a4 9f	jmp $9fa4			jmp 	TypeError 					; anything else, type mismatch.
.933f					_IntegerCode:
.933f	20 45 92	jsr $9245			jsr 	AddCode 					; add the two values
.9342	a9 22		lda #$22			lda 	#NSBIsReference+2 			; make a 2 byte reference
.9344	95 50		sta $50,x			sta 	NSStatus,x
.9346	60		rts				rts
.9347					ByteIndirect:
.9347	fa		plx				plx
.9348	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.934a	15 51		ora $51,x			ora 	NSStatus+1,x
.934c	0a		asl a				asl 	a 							; shift reference bit into sign bit
.934d	0a		asl a				asl 	a
.934e	10 05		bpl $9355			bpl 	_NotRef
.9350	48		pha				pha
.9351	20 bc 96	jsr $96bc			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9354	68		pla				pla
.9355					_NotRef:
.9355	0a		asl a				asl 	a
.9356	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9358	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.935a	15 79		ora $79,x			ora 	NSExponent+1,x
.935c	f0 03		beq $9361			beq 	_IntegerCode 				; if clear, then we have two integers
.935e	4c a4 9f	jmp $9fa4			jmp 	TypeError 					; anything else, type mismatch.
.9361					_IntegerCode:
.9361	20 45 92	jsr $9245			jsr 	AddCode 					; add the two values
.9364	a9 21		lda #$21			lda 	#NSBIsReference+1 			; make a 1 byte reference
.9366	95 50		sta $50,x			sta 	NSStatus,x
.9368	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/tostring.asm

.9369					ConvertInt16:
.9369	85 58		sta $58				sta 	NSMantissa0 				; set up as 32 bit conversion
.936b	86 60		stx $60				stx 	NSMantissa1
.936d	64 68		stz $68				stz 	NSMantissa2
.936f	64 70		stz $70				stz 	NSMantissa3
.9371	64 50		stz $50				stz 	NSStatus 					; positive integer
.9373	a2 00		ldx #$00			ldx 	#0 							; stack level
.9375	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.9377	80 00		bra $9379			bra 	ConvertInt32
.9379					ConvertInt32:
.9379	5a		phy				phy
.937a	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.937c	24 50		bit $50				bit 	NSStatus 					; output a - if not negative.
.937e	10 08		bpl $9388			bpl 	_CI32NotNeg
.9380	48		pha				pha
.9381	a9 2d		lda #$2d			lda 	#'-'
.9383	99 7b 05	sta $057b,y			sta 	NumberBuffer,y
.9386	c8		iny				iny
.9387	68		pla				pla
.9388					_CI32NotNeg:
.9388	20 96 93	jsr $9396			jsr 	_CI32DivideConvert 			; recursive conversion
.938b	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.938d	99 7b 05	sta $057b,y			sta 	NumberBuffer,y
.9390	7a		ply				ply
.9391	a2 05		ldx #$05			ldx 	#NumberBuffer >> 8 			; return address in XA
.9393	a9 7b		lda #$7b			lda 	#NumberBuffer & $FF
.9395	60		rts				rts
.9396					_CI32DivideConvert:
.9396	e8		inx				inx 								; write to next slot up
.9397	20 1e 9e	jsr $9e1e			jsr 	NSMSetByte 		 			; write the base out.
.939a	ca		dex				dex
.939b	20 c4 90	jsr $90c4			jsr 	Int32Divide 				; divide
.939e	b5 58		lda $58,x			lda 	NSMantissa0,x 				; save remainder
.93a0	48		pha				pha
.93a1	20 81 90	jsr $9081			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.93a4	20 3e 9e	jsr $9e3e			jsr 	NSMIsZero 					; is it zero ?
.93a7	f0 05		beq $93ae			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.93a9	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.93ab	20 96 93	jsr $9396			jsr 	_CI32DivideConvert 			; and recusrively call.
.93ae					_CI32NoRecurse:
.93ae	68		pla				pla 								; remainder
.93af	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.93b1	90 02		bcc $93b5			bcc 	_CI32NotHex
.93b3	69 26		adc #$26			adc 	#6+32
.93b5					_CI32NotHex:
.93b5	69 30		adc #$30			adc 	#48
.93b7	99 7b 05	sta $057b,y			sta 	NumberBuffer,y 				; write out and exit
.93ba	c8		iny				iny
.93bb	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/expression.asm


;******  Processing file: ./common/expressions/../generated/precedence.dat

.93bc					PrecedenceLevel:
>93bc	04					.byte	 4	; $00 <<
>93bd	02					.byte	 2	; $01 <=
>93be	02					.byte	 2	; $02 <>
>93bf	00					.byte	 0	; $03 !!3
>93c0	00					.byte	 0	; $04 ><
>93c1	02					.byte	 2	; $05 >=
>93c2	04					.byte	 4	; $06 >>
>93c3	00					.byte	 0	; $07 !!7
>93c4	00					.byte	 0	; $08 !!8
>93c5	00					.byte	 0	; $09 !!9
>93c6	00					.byte	 0	; $0a !!10
>93c7	00					.byte	 0	; $0b !!11
>93c8	00					.byte	 0	; $0c !!12
>93c9	00					.byte	 0	; $0d !!13
>93ca	00					.byte	 0	; $0e !!14
>93cb	00					.byte	 0	; $0f !!15
>93cc	00					.byte	 0	; $10 @
>93cd	00					.byte	 0	; $11 !!17
>93ce	00					.byte	 0	; $12 !!18
>93cf	00					.byte	 0	; $13 [
>93d0	04					.byte	 4	; $14 \
>93d1	00					.byte	 0	; $15 ]
>93d2	01					.byte	 1	; $16 ^
>93d3	00					.byte	 0	; $17 _
>93d4	00					.byte	 0	; $18 `
>93d5	00					.byte	 0	; $19 !!25
>93d6	00					.byte	 0	; $1a !!26
>93d7	00					.byte	 0	; $1b {
>93d8	01					.byte	 1	; $1c |
>93d9	00					.byte	 0	; $1d }
>93da	00					.byte	 0	; $1e ~
>93db	00					.byte	 0	; $1f [7m<7F>[m
>93dc	00					.byte	 0	; $20
>93dd	05					.byte	 5	; $21 !
>93de	00					.byte	 0	; $22 "
>93df	00					.byte	 0	; $23 #
>93e0	05					.byte	 5	; $24 $
>93e1	04					.byte	 4	; $25 %
>93e2	01					.byte	 1	; $26 &
>93e3	00					.byte	 0	; $27 '
>93e4	00					.byte	 0	; $28 (
>93e5	00					.byte	 0	; $29 )
>93e6	04					.byte	 4	; $2a *
>93e7	03					.byte	 3	; $2b +
>93e8	00					.byte	 0	; $2c ,
>93e9	03					.byte	 3	; $2d -
>93ea	00					.byte	 0	; $2e .
>93eb	04					.byte	 4	; $2f /
>93ec	00					.byte	 0	; $30 0
>93ed	00					.byte	 0	; $31 1
>93ee	00					.byte	 0	; $32 2
>93ef	00					.byte	 0	; $33 3
>93f0	00					.byte	 0	; $34 4
>93f1	00					.byte	 0	; $35 5
>93f2	00					.byte	 0	; $36 6
>93f3	00					.byte	 0	; $37 7
>93f4	00					.byte	 0	; $38 8
>93f5	00					.byte	 0	; $39 9
>93f6	00					.byte	 0	; $3a :
>93f7	00					.byte	 0	; $3b ;
>93f8	02					.byte	 2	; $3c <
>93f9	02					.byte	 2	; $3d =
>93fa	02					.byte	 2	; $3e >
>93fb	05					.byte	 5	; $3f ?

;******  Return to file: ./common/expressions/expression.asm

.93fc					EvaluateExpressionAt0:
.93fc	a2 00		ldx #$00			ldx 	#0 							; bottom stack level
.93fe					EvaluateExpression:
.93fe	a9 00		lda #$00			lda 	#0 							; lowest precedence level
.9400					EvaluateExpressionAtPrecedence:
.9400	48		pha				pha 								; save precedence level
.9401	20 48 98	jsr $9848			jsr 	EvaluateTerm 				; evaluate term into level X.
.9404	68		pla				pla 								; restore precedence level.
.9405					_EXPRLoop:
.9405	85 36		sta $36				sta 	zTemp0 						; save current precedence level.
.9407	b1 30		lda ($30),y			lda 	(codePtr),y
.9409	c9 40		cmp #$40			cmp		#$40 						; if >= $40 cannot be an operator
.940b	b0 25		bcs $9432			bcs 	_EXPRExit
.940d	da		phx				phx 								; read the operator precedence
.940e	aa		tax				tax
.940f	bd bc 93	lda $93bc,x			lda 	PrecedenceLevel,x
.9412	fa		plx				plx
.9413	c9 00		cmp #$00			cmp 	#0							; if zero exit (not an operator)
.9415	f0 1b		beq $9432			beq 	_EXPRExit
.9417	85 37		sta $37				sta 	zTemp0+1 					; save operator precedence level.
.9419	a5 36		lda $36				lda 	zTemp0 						; compare current precedence vs. operator precedence
.941b	c5 37		cmp $37				cmp 	zTemp0+1
.941d	b0 13		bcs $9432			bcs		_EXPRExit 					; if current >= operator exit
.941f	48		pha				pha 								; save current precedence.
.9420	b1 30		lda ($30),y			lda 	(codePtr),y
.9422	c8		iny				iny
.9423	48		pha				pha
.9424	a5 37		lda $37				lda 	zTemp0+1 					; get operator precedence level
.9426	e8		inx				inx 								; work out the right hand side.
.9427	20 00 94	jsr $9400			jsr 	EvaluateExpressionAtPrecedence
.942a	ca		dex				dex
.942b	68		pla				pla 								; get operator, call the code.
.942c	20 35 94	jsr $9435			jsr 	_EXPRCaller
.942f	68		pla				pla 								; restore precedence level
.9430	80 d3		bra $9405			bra 	_EXPRLoop 					; and go round.
.9432					_EXPRExit:
.9432	a5 36		lda $36				lda 	zTemp0 						; A = current precedence level.
.9434	60		rts				rts
.9435					_EXPRCaller:
.9435	da		phx				phx 								; save on stack, first thing is to restore it
.9436	0a		asl a				asl 	a 							; double so can use vectors into X
.9437	aa		tax				tax
.9438	7c ac 8b	jmp ($8bac,x)			jmp 	(VectorSetPunc,x) 			; and go to the code.

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/addsub.asm

.943b					FloatingPointAdd:
.943b	20 b1 95	jsr $95b1			jsr 	FloatPrepare 				; prepare for floats
.943e	80 09		bra $9449			bra 	FloatAdd
.9440					FloatingPointSub:
.9440	20 b1 95	jsr $95b1			jsr 	FloatPrepare 				; prepare for floats
.9443					FloatSubtract:
.9443	b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate FPB
.9445	49 80		eor #$80			eor 	#$80
.9447	95 51		sta $51,x			sta 	NSStatus+1,x				; and fall through.
.9449					FloatAdd:
.9449	48		pha				pha
.944a	5a		phy				phy
.944b	20 c0 95	jsr $95c0			jsr 	NSNormalise 				; normalise S[X]
.944e	f0 51		beq $94a1			beq 	_FAReturn1
.9450	e8		inx				inx 								; normalise S[X+1]
.9451	20 c0 95	jsr $95c0			jsr 	NSNormalise
.9454	ca		dex				dex
.9455	c9 00		cmp #$00			cmp 	#0
.9457	f0 60		beq $94b9			beq 	_FAExit 					; if so, just return A
.9459	b5 78		lda $78,x			lda 	NSExponent,x 				; are the exponents the same ?
.945b	d5 79		cmp $79,x			cmp 	NSExponent+1,x
.945d	f0 18		beq $9477			beq 	_FAExponentsEqual
.945f	b5 78		lda $78,x			lda 	NSExponent,x 				; work out the larger exponent
.9461	a8		tay				tay
.9462	38		sec				sec 								; do a signed comparison of the exponents.
.9463	f5 79		sbc $79,x			sbc 	NSExponent+1,x
.9465	50 02		bvc $9469			bvc 	_FANoSignedChange
.9467	49 80		eor #$80			eor 	#$80
.9469					_FANoSignedChange:
.9469	29 80		and #$80			and 	#$80
.946b	10 02		bpl $946f			bpl 	_FAHaveMax
.946d	b4 79		ldy $79,x			ldy 	NSExponent+1,x
.946f					_FAHaveMax:
.946f	20 bc 94	jsr $94bc			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.9472	e8		inx				inx
.9473	20 bc 94	jsr $94bc			jsr 	_FAShiftToExponent
.9476	ca		dex				dex
.9477					_FAExponentsEqual:
.9477	b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs the same
.9479	55 51		eor $51,x			eor 	NSStatus+1,x
.947b	30 0e		bmi $948b			bmi 	_FADifferentSigns
.947d	20 f4 91	jsr $91f4			jsr 	AddTopTwoStack 				; do the add of the mantissae
.9480	b5 70		lda $70,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.9482	10 35		bpl $94b9			bpl 	_FAExit 					; if no, we are done.
.9484	20 35 9e	jsr $9e35			jsr 	NSMShiftRight 				; shift A right, renormalising it.
.9487	f6 78		inc $78,x			inc 	NSExponent,x 				; bump the exponent and exit
.9489	80 2e		bra $94b9			bra 	_FAExit
.948b					_FADifferentSigns:
.948b	20 0e 92	jsr $920e			jsr 	SubTopTwoStack 				; subtract mantissa B from A
.948e	b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the result negative ?
.9490	10 06		bpl $9498			bpl 	_FACheckZero 				; if no, check for -0
.9492	20 de 9d	jsr $9dde			jsr 	NSMNegate 					; netate result
.9495	20 e5 9d	jsr $9de5			jsr 	NSMNegateMantissa 			; negate (2'c) the mantissa
.9498					_FACheckZero:
.9498	20 3e 9e	jsr $9e3e			jsr 	NSMIsZero	 				; check for -0
.949b	d0 1c		bne $94b9			bne 	_FAExit
.949d	74 50		stz $50,x			stz 	NSStatus,x
.949f	80 18		bra $94b9			bra 	_FAExit
.94a1					_FAReturn1:
.94a1	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.94a3	95 58		sta $58,x			sta 	NSMantissa0,x
.94a5	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.94a7	95 60		sta $60,x			sta 	NSMantissa1,x
.94a9	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.94ab	95 68		sta $68,x			sta 	NSMantissa2,x
.94ad	b5 71		lda $71,x			lda 	NSMantissa3+1,x
.94af	95 70		sta $70,x			sta 	NSMantissa3,x
.94b1	b5 79		lda $79,x			lda 	NSExponent+1,x
.94b3	95 78		sta $78,x			sta 	NSExponent,x
.94b5	b5 51		lda $51,x			lda 	NSStatus+1,x
.94b7	95 50		sta $50,x			sta 	NSStatus,x
.94b9					_FAExit:
.94b9	7a		ply				ply
.94ba	68		pla				pla
.94bb	60		rts				rts
.94bc					_FAShiftToExponent:
.94bc					_FAShiftToExponent2:
.94bc	98		tya				tya 								; compare Y to exponent
.94bd	d5 78		cmp $78,x			cmp 	NSExponent,x 				; reached the exponent required ?
.94bf	f0 07		beq $94c8			beq 	_FASEExit 					; exit if so.
.94c1	20 35 9e	jsr $9e35			jsr 	NSMShiftRight	 			; shift the mantissa right
.94c4	f6 78		inc $78,x			inc 	NSExponent,x 				; increment exponent
.94c6	80 f4		bra $94bc			bra 	_FAShiftToExponent2
.94c8					_FASEExit:
.94c8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/compare.asm

.94c9					CompareFloat:
.94c9	20 43 94	jsr $9443			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.94cc	b5 60		lda $60,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.94ce	29 f8		and #$f8			and 	#$F8
.94d0	15 68		ora $68,x			ora 	NSMantissa2,x
.94d2	15 70		ora $70,x			ora 	NSMantissa3,x
.94d4	f0 08		beq $94de			beq 	_FCExit 					; zero, so approximately identical
.94d6	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.94d8	34 50		bit $50,x			bit 	NSStatus,x
.94da	10 02		bpl $94de			bpl 	_FCExit
.94dc					_FCNegative:
.94dc	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.94de					_FCExit:
.94de	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/divide.asm

.94df					FDivideCommand:
.94df	fa		plx				plx	 								; restore stack position
.94e0	20 b1 95	jsr $95b1			jsr 	FloatPrepare 				; prepare for floats
.94e3					FloatDivide:
.94e3	48		pha				pha
.94e4	e8		inx				inx
.94e5	20 c0 95	jsr $95c0			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.94e8	ca		dex				dex
.94e9	c9 00		cmp #$00			cmp 	#0
.94eb	f0 1d		beq $950a			beq 	_FDZero
.94ed	20 c0 95	jsr $95c0			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.94f0	f0 16		beq $9508			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.94f2	20 e5 90	jsr $90e5			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.94f5	20 81 90	jsr $9081			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.94f8	20 c0 95	jsr $95c0			jsr		NSNormalise 				; renormalise
.94fb	20 75 91	jsr $9175			jsr 	CalculateSign 				; calculate result sign
.94fe	b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent
.9500	38		sec				sec
.9501	f5 79		sbc $79,x			sbc 	NSExponent+1,x
.9503	38		sec				sec
.9504	e9 1e		sbc #$1e			sbc 	#30
.9506	95 78		sta $78,x			sta 	NSExponent,x
.9508					_FDExit:
.9508	68		pla				pla
.9509	60		rts				rts
.950a					_FDZero:
.950a	a9 03		lda #$03		lda	#3
.950c	4c fa 8e	jmp $8efa		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/fractional.asm

.950f					FloatFractionalPart:
.950f	5a		phy				phy
.9510	b5 50		lda $50,x			lda 	NSStatus,x 					; take absolute value
.9512	29 7f		and #$7f			and 	#$7F
.9514	95 50		sta $50,x			sta 	NSStatus,x
.9516	20 c0 95	jsr $95c0			jsr 	NSNormalise
.9519	b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.951b	38		sec				sec
.951c	e9 e0		sbc #$e0			sbc 	#$E0
.951e	90 29		bcc $9549			bcc 	_FFPExit 					; already fractional
.9520	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.9522	b0 22		bcs $9546			bcs 	_FFPZero
.9524	a8		tay				tay 								; put count to do in Y
.9525	b5 70		lda $70,x			lda 	NSMantissa3,x 				; do each in turn.
.9527	20 4b 95	jsr $954b			jsr 	_FFPPartial
.952a	95 70		sta $70,x			sta 	NSMantissa3,x
.952c	b5 68		lda $68,x			lda 	NSMantissa2,x
.952e	20 4b 95	jsr $954b			jsr 	_FFPPartial
.9531	95 68		sta $68,x			sta 	NSMantissa2,x
.9533	b5 60		lda $60,x			lda 	NSMantissa1,x
.9535	20 4b 95	jsr $954b			jsr 	_FFPPartial
.9538	95 60		sta $60,x			sta 	NSMantissa1,x
.953a	b5 58		lda $58,x			lda 	NSMantissa0,x
.953c	20 4b 95	jsr $954b			jsr 	_FFPPartial
.953f	95 58		sta $58,x			sta 	NSMantissa0,x
.9541	20 3e 9e	jsr $9e3e			jsr 	NSMIsZero 					; zeroed check.
.9544	d0 03		bne $9549			bne 	_FFPExit
.9546					_FFPZero:
.9546	20 1c 9e	jsr $9e1c			jsr 	NSMSetZero
.9549					_FFPExit:
.9549	7a		ply				ply
.954a	60		rts				rts
.954b					_FFPPartial:
.954b	c0 00		cpy #$00			cpy 	#0 							; no more to do
.954d	f0 17		beq $9566			beq 	_FFFPPExit
.954f	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.9551	b0 0c		bcs $955f			bcs 	_FFFPPWholeByte
.9553	5a		phy				phy
.9554					_FFFPPLeft:
.9554	0a		asl a				asl 	a
.9555	88		dey				dey
.9556	d0 fc		bne $9554			bne 	_FFFPPLeft
.9558	7a		ply				ply
.9559					_FFFPPRight:
.9559	4a		lsr a				lsr 	a
.955a	88		dey				dey
.955b	d0 fc		bne $9559			bne 	_FFFPPRight
.955d	80 07		bra $9566			bra 	_FFFPPExit
.955f					_FFFPPWholeByte:
.955f	98		tya				tya 								; subtract 8 from count
.9560	38		sec				sec
.9561	e9 08		sbc #$08			sbc 	#8
.9563	a8		tay				tay
.9564	a9 00		lda #$00			lda 	#0 							; and clear all
.9566					_FFFPPExit:
.9566	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/integer.asm

.9567					FloatIntegerPart:
.9567	48		pha				pha
.9568	b5 78		lda $78,x			lda 	NSExponent,x 				; is it integer already ?
.956a	f0 1d		beq $9589			beq 	_FIPExit 					; if so do nothing
.956c	20 3e 9e	jsr $9e3e			jsr 	NSMIsZero 					; is it zero ?
.956f	f0 15		beq $9586			beq 	_FIPZero 					; if so return zero.
.9571	20 c0 95	jsr $95c0			jsr 	NSNormalise 				; normalise
.9574	f0 10		beq $9586			beq 	_FIPZero 					; normalised to zero, exit zero
.9576					_FIPShift:
.9576	b5 78		lda $78,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.9578	10 07		bpl $9581			bpl 	_FIPCheckZero
.957a	20 35 9e	jsr $9e35			jsr 	NSMShiftRight 				; shift mantissa right
.957d	f6 78		inc $78,x			inc 	NSExponent,x 				; bump exponent
.957f	80 f5		bra $9576			bra 	_FIPShift
.9581					_FIPCheckZero:
.9581	20 3e 9e	jsr $9e3e			jsr 	NSMIsZero 					; avoid -0 problem
.9584	d0 03		bne $9589			bne 	_FIPExit 					; set to zero if mantissa zero.
.9586					_FIPZero:
.9586	20 1c 9e	jsr $9e1c			jsr 	NSMSetZero
.9589					_FIPExit:
.9589	68		pla				pla
.958a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/multiply.asm

.958b					FloatingPointMultiply:
.958b	20 b1 95	jsr $95b1			jsr 	FloatPrepare 				; prepare for floats
.958e					FloatMultiply:
.958e	48		pha				pha
.958f	20 c0 95	jsr $95c0			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.9592	f0 18		beq $95ac			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.9594	e8		inx				inx
.9595	20 c0 95	jsr $95c0			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.9598	ca		dex				dex
.9599	c9 00		cmp #$00			cmp 	#0
.959b	f0 0c		beq $95a9			beq 	_FDSetZero
.959d	20 37 91	jsr $9137			jsr 	MultiplyShort 				; calculate the result.
.95a0	75 78		adc $78,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.95a2	18		clc				clc
.95a3	75 79		adc $79,x			adc 	NSExponent+1,x
.95a5	95 78		sta $78,x			sta 	NSExponent,x
.95a7	80 03		bra $95ac			bra 	_FDExit
.95a9					_FDSetZero:
.95a9	20 1c 9e	jsr $9e1c			jsr 	NSMSetZero 					; return 0
.95ac					_FDExit:
.95ac	20 c0 95	jsr $95c0			jsr 	NSNormalise 				; normalise the result
.95af	68		pla				pla
.95b0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/utility.asm

.95b1					FloatPrepare:
.95b1	20 bc 96	jsr $96bc			jsr 	DereferenceTopTwo 			; dereference the top two values
.95b4	b5 50		lda $50,x			lda 	NSStatus,x 					; check ints/floats, either will do.
.95b6	15 51		ora $51,x			ora 	NSStatus+1,x
.95b8	29 10		and #$10			and 	#NSBIsString
.95ba	d0 01		bne $95bd			bne 	_FDType
.95bc	60		rts				rts
.95bd					_FDType:
.95bd	4c a4 9f	jmp $9fa4			jmp 	TypeError
.95c0					NSNormalise:
.95c0	b5 50		lda $50,x			lda 	NSStatus,x 					; make float, keep sign
.95c2	29 80		and #$80			and 	#$80
.95c4	09 08		ora #$08			ora 	#NSTFloat
.95c6	95 50		sta $50,x			sta 	NSStatus,x
.95c8	20 3e 9e	jsr $9e3e			jsr 	NSMIsZero 					; if zero exit
.95cb	d0 07		bne $95d4			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.95cd	16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.95cf	76 50		ror $50,x			ror 	NSStatus,x 					; (no -0)
.95d1	a9 00		lda #$00			lda 	#0 							; set Z flag
.95d3	60		rts				rts
.95d4					_NSNormaliseOptimise:
.95d4	b5 70		lda $70,x			lda 	NSMantissa3,x 				; upper byte zero ?
.95d6	d0 19		bne $95f1			bne 	_NSNormaliseLoop
.95d8	b5 68		lda $68,x			lda 	NSMantissa2,x 				; byte normalise
.95da	30 15		bmi $95f1			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.95dc	95 70		sta $70,x			sta 	NSMantissa3,x
.95de	b5 60		lda $60,x			lda 	NSMantissa1,x
.95e0	95 68		sta $68,x			sta 	NSMantissa2,x
.95e2	b5 58		lda $58,x			lda 	NSMantissa0,x
.95e4	95 60		sta $60,x			sta 	NSMantissa1,x
.95e6	74 58		stz $58,x			stz 	NSMantissa0,x
.95e8	b5 78		lda $78,x			lda 	NSExponent,x
.95ea	38		sec				sec
.95eb	e9 08		sbc #$08			sbc 	#8
.95ed	95 78		sta $78,x			sta 	NSExponent,x
.95ef	80 e3		bra $95d4			bra 	_NSNormaliseOptimise
.95f1					_NSNormaliseLoop:
.95f1	34 70		bit $70,x			bit 	NSMantissa3,x 				; bit 30 set ?
.95f3	70 07		bvs $95fc			bvs 	_NSNExit 					; exit if so with Z flag clear
.95f5	20 2b 9e	jsr $9e2b			jsr 	NSMShiftLeft 				; shift mantissa left
.95f8	d6 78		dec $78,x			dec 	NSExponent,x 				; adjust exponent
.95fa	80 f5		bra $95f1			bra 	_NSNormaliseLoop
.95fc					_NSNExit:
.95fc	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.95fe	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignnumber.asm

.95ff					AssignNumber:
.95ff	5a		phy				phy
.9600	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy mantissa0/1 to zTemp0
.9602	85 36		sta $36				sta 	zTemp0
.9604	b5 60		lda $60,x			lda 	NSMantissa1,x
.9606	85 37		sta $37				sta 	zTemp0+1
.9608	b5 50		lda $50,x			lda 	NSStatus,x 					; clear reference bits
.960a	29 df		and #$df			and 	#(NSBIsReference ^ $FF)
.960c	95 50		sta $50,x			sta 	NSStatus,x
.960e	29 18		and #$18			and 	#NSBTypeMask				; assigning to a float ?
.9610	c9 08		cmp #$08			cmp 	#NSTFloat
.9612	f0 24		beq $9638			beq 	_ANFloat
.9614	b5 79		lda $79,x			lda		NSExponent+1,x 				; is it a float
.9616	f0 03		beq $961b			beq		_ANNotFloat
.9618	4c 9f 9f	jmp $9f9f			jmp 	RangeError					; if it is, report an error.
.961b					_ANNotFloat:
.961b	b5 50		lda $50,x			lda 	NSStatus,x 					; check if byte/word reference.
.961d	29 03		and #$03			and 	#3
.961f	d0 05		bne $9626			bne 	_ANByteWord
.9621	20 43 96	jsr $9643			jsr 	_ANCopy4PackSign 			; copy all 4 bytes and sign
.9624	80 1b		bra $9641			bra 	_ANExit
.9626					_ANByteWord:
.9626	48		pha				pha 								; save count
.9627	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; do byte
.9629	92 36		sta ($36)			sta 	(zTemp0)
.962b	68		pla				pla
.962c	c9 01		cmp #$01			cmp	 	#1
.962e	f0 11		beq $9641			beq 	_ANExit
.9630	b5 61		lda $61,x			lda 	NSMantissa1+1,x 			; do word
.9632	a0 01		ldy #$01			ldy 	#1
.9634	91 36		sta ($36),y			sta 	(zTemp0),y
.9636	80 09		bra $9641			bra 	_ANExit
.9638					_ANFloat:
.9638	20 43 96	jsr $9643			jsr 	_ANCopy4PackSign 			; write all 4 bytes and packed sign
.963b	b5 79		lda $79,x			lda 	NSExponent+1,x 				; copy exponent to slot 4
.963d	a0 04		ldy #$04			ldy 	#4
.963f	91 36		sta ($36),y			sta 	(zTemp0),y
.9641					_ANExit:
.9641	7a		ply				ply
.9642	60		rts				rts
.9643					_ANCopy4PackSign:
.9643	a0 03		ldy #$03			ldy 	#3
.9645	b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign bit into status
.9647	29 80		and #$80			and 	#$80 						; put into high bit of mantissa 3
.9649	15 71		ora $71,x			ora 	NSMantissa3+1,x
.964b	91 36		sta ($36),y			sta 	(zTemp0),y
.964d	88		dey				dey
.964e	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.9650	91 36		sta ($36),y			sta 	(zTemp0),y
.9652	88		dey				dey
.9653	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9655	91 36		sta ($36),y			sta 	(zTemp0),y
.9657	88		dey				dey
.9658	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.965a	91 36		sta ($36),y			sta 	(zTemp0),y
.965c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignstring.asm

.965d					AssignString:
.965d	5a		phy				phy
.965e	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9660	85 38		sta $38				sta 	zTemp1
.9662	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9664	85 39		sta $39				sta 	zTemp1+1
.9666	b5 58		lda $58,x			lda 	NSMantissa0,x
.9668	85 36		sta $36				sta 	zTemp0
.966a	b5 60		lda $60,x			lda 	NSMantissa1,x
.966c	85 37		sta $37				sta 	zTemp0+1
.966e	a0 01		ldy #$01			ldy 	#1 							; the high byte of the target address
.9670	b1 36		lda ($36),y			lda 	(zTemp0),y
.9672	f0 23		beq $9697			beq 	_ASNewStringRequired 		; if zero, a new string is required.
.9674	38		sec				sec 								; put Address-2 in zsTemp - this is the size/status/string record
.9675	b2 36		lda ($36)			lda 	(zTemp0) 					; of concreted strings
.9677	e9 02		sbc #$02			sbc 	#2
.9679	85 3c		sta $3c				sta 	zsTemp
.967b	a0 01		ldy #$01			ldy 	#1
.967d	b1 36		lda ($36),y			lda 	(zTemp0),y
.967f	e9 00		sbc #$00			sbc 	#0
.9681	85 3d		sta $3d				sta 	zsTemp+1
.9683	a0 ff		ldy #$ff			ldy 	#$FF 						; get length of new string
.9685					_ASGetLength:
.9685	c8		iny				iny
.9686	b1 38		lda ($38),y			lda 	(zTemp1),y
.9688	d0 fb		bne $9685			bne 	_ASGetLength
.968a	98		tya				tya 								; is this length <= current length
.968b	d2 3c		cmp ($3c)			cmp 	(zsTemp)
.968d	90 1e		bcc $96ad			bcc 	_ASCopyString
.968f	f0 1c		beq $96ad			beq 	_ASCopyString
.9691	a9 80		lda #$80			lda 	#$80 						; mark as unused.
.9693	a0 01		ldy #$01			ldy 	#1
.9695	91 3c		sta ($3c),y			sta 	(zsTemp),y
.9697					_ASNewStringRequired:
.9697	e8		inx				inx 								; concrete the new string.
.9698	20 21 a7	jsr $a721			jsr 	StringConcrete				; (breaks zTemp1/2, not zTemp0 and zsTemp)
.969b	ca		dex				dex
.969c	18		clc				clc
.969d	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy that new address to the reference.
.969f	69 02		adc #$02			adc 	#2 							; add two to point at the data.
.96a1	92 36		sta ($36)			sta 	(zTemp0)
.96a3	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.96a5	69 00		adc #$00			adc 	#0
.96a7	a0 01		ldy #$01			ldy 	#1
.96a9	91 36		sta ($36),y			sta 	(zTemp0),y
.96ab	80 0d		bra $96ba			bra 	_ASExit
.96ad					_ASCopyString:
.96ad	a0 00		ldy #$00			ldy 	#0
.96af					_ASCopyLoop:
.96af	b1 38		lda ($38),y			lda 	(zTemp1),y
.96b1	c8		iny				iny
.96b2	c8		iny				iny
.96b3	91 3c		sta ($3c),y			sta 	(zsTemp),y
.96b5	88		dey				dey
.96b6	c9 00		cmp #$00			cmp 	#0
.96b8	d0 f5		bne $96af			bne 	_ASCopyLoop
.96ba					_ASExit:
.96ba	7a		ply				ply
.96bb	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/dereference.asm

.96bc					DereferenceTopTwo:
.96bc	e8		inx				inx
.96bd	20 c1 96	jsr $96c1			jsr 	Dereference 				; deref x+1
.96c0	ca		dex				dex  								; falls through to deref x
.96c1					Dereference:
.96c1	b5 50		lda $50,x			lda 	NSStatus,x 					; get the status byte
.96c3	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.96c5	f0 48		beq $970f			beq 	_DRFExit 					; not a reference, so exit.
.96c7	5a		phy				phy
.96c8	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address to dereference into zTemp0
.96ca	85 36		sta $36				sta 	zTemp0
.96cc	b5 60		lda $60,x			lda 	NSMantissa1,x
.96ce	85 37		sta $37				sta 	zTemp0+1
.96d0	74 60		stz $60,x			stz 	NSMantissa1,x 				; clear second byte.
.96d2	b2 36		lda ($36)			lda 	(zTemp0) 					; do the first byte
.96d4	95 58		sta $58,x			sta 	NSMantissa0,x
.96d6	b5 50		lda $50,x			lda 	NSStatus,x 					; get status byte.
.96d8	29 18		and #$18			and 	#NSBTypeMask 				; what type is it ?
.96da	c9 10		cmp #$10			cmp 	#NSTString 					; if string, dereference two
.96dc	f0 0e		beq $96ec			beq 	_DRFDereferenceTwo
.96de	c9 08		cmp #$08			cmp 	#NSTFloat 					; if float, do full dereference.
.96e0	f0 2f		beq $9711			beq 	_DRFFull
.96e2	b5 50		lda $50,x			lda 	NSStatus,x 					; must be integer - how many bytes ?
.96e4	29 03		and #$03			and 	#3
.96e6	f0 29		beq $9711			beq 	_DRFFull 					; the whole word
.96e8	c9 01		cmp #$01			cmp 	#1 							; is it 10 (e.g. 2 bytes)
.96ea	f0 06		beq $96f2			beq		_DRFClear23 				; no, one byte, clear 2 & 3 and exit
.96ec					_DRFDereferenceTwo:
.96ec	a0 01		ldy #$01			ldy 	#1
.96ee	b1 36		lda ($36),y			lda 	(zTemp0),y
.96f0	95 60		sta $60,x			sta 	NSMantissa1,x
.96f2					_DRFClear23:
.96f2	74 68		stz $68,x			stz 	NSMantissa2,x 				; clear upper bytes, only read 1 or 2 bytes
.96f4	74 70		stz $70,x			stz 	NSMantissa3,x
.96f6	b5 50		lda $50,x			lda 	NSStatus,x 					; make it a value of that type.
.96f8	29 18		and #$18			and 	#NSBTypeMask
.96fa	95 50		sta $50,x			sta 	NSStatus,x 					; and fall through.
.96fc	c9 10		cmp #$10			cmp 	#NSTString  				; is it a string
.96fe	d0 0e		bne $970e			bne 	_DRFNotString
.9700	b5 58		lda $58,x			lda 	NSMantissa0,x 				; check address is zero
.9702	15 60		ora $60,x			ora 	NSMantissa1,x
.9704	d0 08		bne $970e			bne 	_DRFNotString
.9706	a9 10		lda #$10			lda 	#_DRFNullString & $FF 		; if so, return reference to ""
.9708	95 58		sta $58,x			sta 	NSMantissa0,X
.970a	a9 97		lda #$97			lda 	#_DRFNullString >> 8
.970c	95 60		sta $60,x			sta 	NSMantissa1,X
.970e					_DRFNotString
.970e	7a		ply				ply 								; restore Y and exit
.970f					_DRFExit:
.970f	60		rts				rts
.9710					_DRFNullString:
>9710	00						.byte 	0
.9711					_DRFFull:
.9711	a0 01		ldy #$01			ldy 	#1 							; get remaining 3 bytes.
.9713	b1 36		lda ($36),y			lda 	(zTemp0),y
.9715	95 60		sta $60,x			sta 	NSMantissa1,x
.9717	c8		iny				iny
.9718	b1 36		lda ($36),y			lda 	(zTemp0),y
.971a	95 68		sta $68,x			sta 	NSMantissa2,x
.971c	c8		iny				iny
.971d	b1 36		lda ($36),y			lda 	(zTemp0),y
.971f	95 70		sta $70,x			sta 	NSMantissa3,x
.9721	74 78		stz $78,x			stz 	NSExponent,x 				; clear exponent.
.9723	b5 50		lda $50,x			lda		NSStatus,x 					; see if type is integer
.9725	29 18		and #$18			and 	#NSBTypeMask  				; type information only
.9727	95 50		sta $50,x			sta 	NSStatus,x 					; update it back.
.9729	f0 05		beq $9730			beq 	_DRFNoExponent
.972b	c8		iny				iny 								; if not, read the exponent as well.
.972c	b1 36		lda ($36),y			lda 	(zTemp0),y
.972e	95 78		sta $78,x			sta 	NSExponent,x
.9730					_DRFNoExponent:
.9730	b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the most significant bit set ?
.9732	10 0a		bpl $973e			bpl 	_DRFExit2 					; if not, then exit.
.9734	29 7f		and #$7f			and 	#$7F 						; clear that bit.
.9736	95 70		sta $70,x			sta 	NSMantissa3,x
.9738	b5 50		lda $50,x			lda 	NSStatus,x 					; set the sign flag
.973a	09 80		ora #$80			ora 	#NSBIsNegative
.973c	95 50		sta $50,x			sta 	NSStatus,x
.973e					_DRFExit2:
.973e	7a		ply				ply
.973f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/number.asm

=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.9740					EncodeNumberStart:
.9740	38		sec				sec
.9741	80 01		bra $9744			bra 	EncodeNumberContinue+1
.9743					EncodeNumberContinue:
.9743	18		clc				clc
.9744					EncodeNumber:
.9744	08		php				php 								; save reset flag.
.9745	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.9747	f0 12		beq $975b			beq 	_ENIsOkay
.9749	c9 30		cmp #$30			cmp 	#"0"
.974b	90 04		bcc $9751			bcc 	_ENBadNumber
.974d	c9 3a		cmp #$3a			cmp 	#"9"+1
.974f	90 0a		bcc $975b			bcc 	_ENIsOkay
.9751					_ENBadNumber:
.9751	28		plp				plp 								; throw saved reset
.9752	ad 05 04	lda $0405			lda 	EncodeState 				; if in decimal mode, construct final number
.9755	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.9757	f0 7b		beq $97d4			beq 	_ENConstructFinal
.9759					_ENFail:
.9759	18		clc				clc 								; not allowed
.975a	60		rts				rts
.975b					_ENIsOkay:
.975b	28		plp				plp 								; are we restarting
.975c	90 15		bcc $9773			bcc 	_ENNoRestart
.975e					_ENStartEncode:
.975e	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.9760	f0 0c		beq $976e			beq 	_ENFirstDP
.9762	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.9764	20 1e 9e	jsr $9e1e			jsr 	NSMSetByte 					; in single byte mode.
.9767	a9 01		lda #$01			lda 	#ESTA_Low
.9769					_ENExitChange:
.9769	8d 05 04	sta $0405			sta 	EncodeState 				; save new state
.976c	38		sec				sec
.976d	60		rts				rts
.976e					_ENFirstDP:
.976e	20 1c 9e	jsr $9e1c			jsr 	NSMSetZero 					; clear integer part
.9771	80 3c		bra $97af			bra 	_ESTASwitchFloat			; go straight to float and exi
.9773					_ENNoRestart:
.9773	48		pha				pha 								; save digit or DP on stack.
.9774	ad 05 04	lda $0405			lda 	EncodeState 				; get current state
.9777	c9 01		cmp #$01			cmp 	#ESTA_Low
.9779	f0 09		beq $9784			beq  	_ESTALowState
.977b	c9 02		cmp #$02			cmp 	#ESTA_High
.977d	f0 26		beq $97a5			beq 	_ESTAHighState
.977f	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.9781	f0 38		beq $97bb			beq 	_ESTADecimalState
>9783	db						.byte 	$DB 						; causes a break in the emulator
.9784					_ESTALowState:
.9784	68		pla				pla 								; get value back
.9785	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.9787	f0 26		beq $97af			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.9789	29 0f		and #$0f			and 	#15 						; make digit
.978b	8d 06 04	sta $0406			sta 	DigitTemp 					; save it.
.978e	b5 58		lda $58,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.9790	0a		asl a				asl 	a
.9791	0a		asl a				asl 	a
.9792	75 58		adc $58,x			adc 	NSMantissa0,x
.9794	0a		asl a				asl 	a
.9795	6d 06 04	adc $0406			adc 	DigitTemp
.9798	95 58		sta $58,x			sta 	NSMantissa0,x
.979a	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.979c	90 05		bcc $97a3			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.979e	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.97a0	8d 05 04	sta $0405			sta 	EncodeState
.97a3					_ESTANoSwitch:
.97a3	38		sec				sec
.97a4	60		rts				rts
.97a5					_ESTAHighState:
.97a5	68		pla				pla 								; get value back
.97a6	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.97a8	f0 05		beq $97af			beq 	_ESTASwitchFloat
.97aa	20 08 98	jsr $9808			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.97ad	38		sec				sec
.97ae	60		rts				rts
.97af					_ESTASwitchFloat:
.97af	9c 07 04	stz $0407			stz 	DecimalCount 				; reset the count of digits - we divide by 10^n at the end.
.97b2	e8		inx				inx 								; zero the decimal additive.
.97b3	20 1c 9e	jsr $9e1c			jsr 	NSMSetZero
.97b6	ca		dex				dex
.97b7	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.97b9	80 ae		bra $9769			bra 	_ENExitChange
.97bb					_ESTADecimalState:
.97bb	68		pla				pla 								; digit.
.97bc	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 2nd decimal point.
.97be	f0 99		beq $9759			beq 	_ENFail
.97c0	e8		inx				inx 								; put digit into fractional part of X+1
.97c1	20 08 98	jsr $9808			jsr 	ESTAShiftDigitIntoMantissa
.97c4	ca		dex				dex
.97c5	ee 07 04	inc $0407			inc 	DecimalCount 				; bump the count of decimals
.97c8	ad 07 04	lda $0407			lda 	DecimalCount 				; too many decimal digits.
.97cb	c9 0b		cmp #$0b			cmp 	#11
.97cd	f0 02		beq $97d1			beq 	_ESTADSFail
.97cf	38		sec				sec
.97d0	60		rts				rts
.97d1					_ESTADSFail:
.97d1	4c 9f 9f	jmp $9f9f			jmp 	RangeError
.97d4					_ENConstructFinal:
.97d4	ad 07 04	lda $0407			lda 	DecimalCount 				; get decimal count
.97d7	f0 2d		beq $9806			beq 	_ENCFExit 					; no decimals
.97d9	5a		phy				phy
.97da	0a		asl a				asl 	a 							; x 4 and CLC
.97db	0a		asl a				asl 	a
.97dc	6d 07 04	adc $0407			adc 	DecimalCount
.97df	a8		tay				tay
.97e0	b9 5e 9f	lda $9f5e,y			lda 	DecimalScalarTable-5,y 		; copy decimal scalar to X+2
.97e3	95 5a		sta $5a,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.97e5	b9 5f 9f	lda $9f5f,y			lda 	DecimalScalarTable-5+1,y
.97e8	95 62		sta $62,x			sta 	NSMantissa1+2,x
.97ea	b9 60 9f	lda $9f60,y			lda 	DecimalScalarTable-5+2,y
.97ed	95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.97ef	b9 61 9f	lda $9f61,y			lda 	DecimalScalarTable-5+3,y
.97f2	95 72		sta $72,x			sta 	NSMantissa3+2,x
.97f4	b9 62 9f	lda $9f62,y			lda 	DecimalScalarTable-5+4,y
.97f7	95 7a		sta $7a,x			sta 	NSExponent+2,x
.97f9	a9 08		lda #$08			lda 	#NSTFloat
.97fb	95 52		sta $52,x			sta 	NSStatus+2,x
.97fd	7a		ply				ply
.97fe	e8		inx				inx 								; multiply decimal const by decimal scalar
.97ff	20 8e 95	jsr $958e			jsr 	FloatMultiply
.9802	ca		dex				dex
.9803	20 49 94	jsr $9449			jsr 	FloatAdd 					; add to integer part.
.9806					_ENCFExit:
.9806	18		clc				clc 								; reject the digit.
.9807	60		rts				rts
.9808					ESTAShiftDigitIntoMantissa:
.9808	29 0f		and #$0f			and 	#15 						; save digit
.980a	48		pha				pha
.980b	b5 70		lda $70,x			lda 	NSMantissa3,x 				; push mantissa on stack
.980d	48		pha				pha
.980e	b5 68		lda $68,x			lda 	NSMantissa2,x
.9810	48		pha				pha
.9811	b5 60		lda $60,x			lda 	NSMantissa1,x
.9813	48		pha				pha
.9814	b5 58		lda $58,x			lda 	NSMantissa0,x
.9816	48		pha				pha
.9817	20 2b 9e	jsr $9e2b			jsr 	NSMShiftLeft 				; x 2
.981a	20 2b 9e	jsr $9e2b			jsr 	NSMShiftLeft 				; x 4
.981d	18		clc				clc 								; pop mantissa and add
.981e	68		pla				pla
.981f	75 58		adc $58,x			adc 	NSMantissa0,x
.9821	95 58		sta $58,x			sta 	NSMantissa0,x
.9823	68		pla				pla
.9824	75 60		adc $60,x			adc 	NSMantissa1,x
.9826	95 60		sta $60,x			sta 	NSMantissa1,x
.9828	68		pla				pla
.9829	75 68		adc $68,x			adc 	NSMantissa2,x
.982b	95 68		sta $68,x			sta 	NSMantissa2,x
.982d	68		pla				pla
.982e	75 70		adc $70,x			adc 	NSMantissa3,x
.9830	95 70		sta $70,x			sta 	NSMantissa3,x 				; x 5
.9832	20 2b 9e	jsr $9e2b			jsr 	NSMShiftLeft 				; x 10
.9835	68		pla				pla 								; add digit
.9836	18		clc				clc
.9837	75 58		adc $58,x			adc 	NSMantissa0,x
.9839	95 58		sta $58,x			sta 	NSMantissa0,x
.983b	90 0a		bcc $9847			bcc 	_ESTASDExit
.983d	f6 60		inc $60,x			inc 	NSMantissa1,x
.983f	d0 06		bne $9847			bne 	_ESTASDExit
.9841	f6 68		inc $68,x			inc 	NSMantissa2,x
.9843	d0 02		bne $9847			bne 	_ESTASDExit
.9845	f6 70		inc $70,x			inc 	NSMantissa3,x
.9847					_ESTASDExit:
.9847	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/term.asm

.9848					EvaluateTerm:
.9848	b1 30		lda ($30),y			lda 	(codePtr),y
.984a	30 18		bmi $9864			bmi 	_ETCheckUnary 				; unary function ? (text ones)
.984c	c9 40		cmp #$40			cmp 	#$40 						; 40-7F => identifier reference
.984e	b0 6c		bcs $98bc			bcs 	_ETVariable
.9850	c9 30		cmp #$30			cmp 	#'0' 						; is it a number
.9852	90 6b		bcc $98bf			bcc 	_ETPuncUnary 				; if not it might be a punctuation unary.
.9854	c9 3a		cmp #$3a			cmp 	#'9'+1
.9856	b0 67		bcs $98bf			bcs 	_ETPuncUnary
.9858	20 40 97	jsr $9740			jsr 	EncodeNumberStart 			; can't fail as it's 0-9 !
.985b					_ETNumber:
.985b	c8		iny				iny 								; keep encoding until we have the numbers
.985c	b1 30		lda ($30),y			lda 	(codePtr),y
.985e	20 43 97	jsr $9743			jsr 	EncodeNumberContinue
.9861	b0 f8		bcs $985b			bcs 	_ETNumber 					; go back if accepted.
.9863	60		rts				rts
.9864					_ETCheckUnary:
.9864	c9 ff		cmp #$ff			cmp 	#KWC_STRING 				; string token
.9866	f0 3f		beq $98a7			beq 	_ETString
.9868	c9 fe		cmp #$fe			cmp 	#KWC_HEXCONST 				; hex constant.
.986a	f0 12		beq $987e			beq 	_ETHexConstant
.986c	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; check it actually is a unary function
.986e	90 0b		bcc $987b			bcc 	_ETSyntaxError
.9870	c9 a2		cmp #$a2			cmp 	#KWC_LAST_UNARY+1
.9872	b0 07		bcs $987b			bcs 	_ETSyntaxError
.9874	da		phx				phx 								; push X on the stack
.9875	0a		asl a				asl 	a 							; put vector x 2 into X
.9876	aa		tax				tax
.9877	c8		iny				iny 								; consume unary function token
.9878	7c 2c 8c	jmp ($8c2c,x)			jmp 	(VectorSet0,x) 				; and do it.
.987b					_ETSyntaxError:
.987b	4c 9a 9f	jmp $9f9a			jmp 	SyntaxError
.987e					_ETHexConstant:
.987e	c8		iny				iny 								; skip #
.987f	c8		iny				iny 								; skip count
.9880	20 1c 9e	jsr $9e1c			jsr 	NSMSetZero 					; clear result
.9883					_ETHLoop:
.9883	b1 30		lda ($30),y			lda 	(codePtr),y
.9885	c8		iny				iny 								; and consume
.9886	c9 00		cmp #$00			cmp 	#0 							; exit if zero
.9888	f0 1c		beq $98a6			beq 	_ETHExit
.988a	48		pha				pha 								; save on stack.
.988b	20 2b 9e	jsr $9e2b			jsr 	NSMShiftLeft 				; x 2
.988e	20 2b 9e	jsr $9e2b			jsr 	NSMShiftLeft 				; x 4
.9891	20 2b 9e	jsr $9e2b			jsr 	NSMShiftLeft 				; x 8
.9894	20 2b 9e	jsr $9e2b			jsr 	NSMShiftLeft 				; x 16
.9897	68		pla				pla 								; ASCII
.9898	c9 41		cmp #$41			cmp 	#'A'
.989a	90 02		bcc $989e			bcc 	_ETHNotChar
.989c	e9 07		sbc #$07			sbc 	#7
.989e					_ETHNotChar:
.989e	29 0f		and #$0f			and 	#15 						; digit now
.98a0	15 58		ora $58,x			ora 	NSMantissa0,x 				; put in LS Nibble
.98a2	95 58		sta $58,x			sta 	NSMantissa0,x
.98a4	80 dd		bra $9883			bra 	_ETHLoop 					; go round.
.98a6					_ETHExit:
.98a6	60		rts				rts
.98a7					_ETString:
.98a7	c8		iny				iny 								; look at length
.98a8	b1 30		lda ($30),y			lda 	(codePtr),y
.98aa	48		pha				pha
.98ab	c8		iny				iny 								; first character
.98ac	20 77 a5	jsr $a577			jsr 	MemoryInline 				; put address of string at (code-Ptr),y on stack
.98af	68		pla				pla 								; restore count and save
.98b0	85 36		sta $36				sta 	zTemp0
.98b2	98		tya				tya 								; add length to Y to skip it.
.98b3	18		clc				clc
.98b4	65 36		adc $36				adc 	zTemp0
.98b6	a8		tay				tay
.98b7	a9 10		lda #$10			lda 	#NSTString 					; mark as string
.98b9	95 50		sta $50,x			sta 	NSStatus,x
.98bb	60		rts				rts
.98bc					_ETVariable:
.98bc	4c 11 99	jmp $9911			jmp 	VariableHandler
.98bf					_ETPuncUnary:
.98bf	c8		iny				iny 								; consume the unary character
.98c0	c9 2d		cmp #$2d			cmp 	#KWD_MINUS 					; unary minus
.98c2	f0 2b		beq $98ef			beq 	_ETUnaryNegate
.98c4	c9 10		cmp #$10			cmp 	#KWD_AT 					; @ reference -> constant
.98c6	f0 36		beq $98fe			beq 	_ETDereference
.98c8	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; parenthesis
.98ca	f0 3e		beq $990a			beq 	_ETParenthesis
.98cc	64 36		stz $36				stz 	zTemp0 						; zTemp0 is the indirection level.
.98ce	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; byte indirection (0) ?
.98d0	f0 06		beq $98d8			beq 	_ETIndirection
.98d2	e6 36		inc $36				inc 	zTemp0
.98d4	c9 21		cmp #$21			cmp 	#KWD_PLING					; word indirection (1) \
.98d6	d0 a3		bne $987b			bne 	_ETSyntaxError
.98d8					_ETIndirection:
.98d8	a5 36		lda $36				lda 	zTemp0 						; push indirection amount (0-1) => (1-2) on the stack
.98da	1a		inc a				inc 	a
.98db	48		pha				pha
.98dc	20 48 98	jsr $9848			jsr 	EvaluateTerm				; evaluate the term
.98df	20 c1 96	jsr $96c1			jsr 	Dereference 				; dereference it.
.98e2	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a +ve integer.
.98e4	d0 06		bne $98ec			bne 	_ETTypeMismatch
.98e6	68		pla				pla 								; indirection 1-2
.98e7	09 20		ora #$20			ora 	#NSBIsReference 			; make it a reference.
.98e9	95 50		sta $50,x			sta 	NSStatus,x
.98eb	60		rts				rts
.98ec					_ETTypeMismatch:
.98ec	4c a4 9f	jmp $9fa4			jmp 	TypeError
.98ef					_ETUnaryNegate:
.98ef	20 48 98	jsr $9848			jsr 	EvaluateTerm				; evaluate the term
.98f2	20 c1 96	jsr $96c1			jsr 	Dereference 				; dereference it.
.98f5	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a number
.98f7	29 10		and #$10			and 	#NSTString
.98f9	d0 f1		bne $98ec			bne 	_ETTypeMismatch
.98fb	4c de 9d	jmp $9dde			jmp 	NSMNegate  					; just toggles the sign bit.
.98fe					_ETDereference:
.98fe	20 48 98	jsr $9848			jsr 	EvaluateTerm				; evaluate the term
.9901	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a reference
.9903	29 20		and #$20			and 	#NSBIsReference
.9905	f0 e5		beq $98ec			beq 	_ETTypeMismatch
.9907	74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer address
.9909	60		rts				rts
.990a					_ETParenthesis:
.990a	20 fe 93	jsr $93fe			jsr 	EvaluateExpression 			; evaluate here, from lowest precedence
.990d	20 e1 8e	jsr $8ee1			jsr 	CheckRightBracket 			; check for )
.9910	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/variable.asm

.9911					VariableHandler:
.9911	b1 30		lda ($30),y			lda 	(codePtr),y
.9913	18		clc				clc
.9914	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.9916	85 37		sta $37				sta 	zTemp0+1
.9918	c8		iny				iny
.9919	b1 30		lda ($30),y			lda 	(codePtr),y
.991b	85 36		sta $36				sta 	zTemp0
.991d	c8		iny				iny
.991e	18		clc				clc									; copy variable address+3 to mantissa
.991f	69 03		adc #$03			adc 	#3 							; this is the address of the data.
.9921	95 58		sta $58,x			sta 	NSMantissa0,x
.9923	a5 37		lda $37				lda 	zTemp0+1
.9925	69 00		adc #$00			adc 	#0
.9927	95 60		sta $60,x			sta 	NSMantissa1,x
.9929	74 68		stz $68,x			stz 	NSMantissa2,x
.992b	74 70		stz $70,x			stz 	NSMantissa3,x
.992d	74 78		stz $78,x			stz 	NSExponent,x
.992f	5a		phy				phy
.9930	a0 02		ldy #$02			ldy 	#2 							; read type
.9932	b1 36		lda ($36),y			lda 	(zTemp0),y
.9934	7a		ply				ply
.9935	29 1c		and #$1c			and 	#NSBTypeMask+NSBIsArray 	; get type information
.9937	09 20		ora #$20			ora 	#NSBIsReference 			; make a reference.
.9939	95 50		sta $50,x			sta 	NSStatus,x
.993b	29 04		and #$04			and 	#NSBIsArray
.993d	d0 01		bne $9940			bne 	_VHArray
.993f	60		rts				rts
.9940					_VHArray:
.9940	e8		inx				inx
.9941	20 b7 9d	jsr $9db7			jsr 	Evaluate8BitInteger 		; get the 1st index.
.9944	a9 ff		lda #$ff			lda 	#$FF 						; set Status of X+2 to a duff value so we know if we picked it up.
.9946	95 51		sta $51,x			sta 	NSStatus+1,x
.9948	b1 30		lda ($30),y			lda 	(codePtr),y
.994a	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.994c	d0 06		bne $9954			bne 	_VHNoSecondIndex
.994e	c8		iny				iny 								; skip the comma
.994f	e8		inx				inx
.9950	20 b7 9d	jsr $9db7			jsr 	Evaluate8BitInteger 		; get the 2nd index.
.9953	ca		dex				dex
.9954					_VHNoSecondIndex:
.9954	ca		dex				dex 								; set X back.
.9955	20 e1 8e	jsr $8ee1			jsr 	CheckRightBracket 			; and check the right bracket.
.9958	5a		phy				phy 								; save position
.9959	a0 02		ldy #$02			ldy 	#2 							; check first index is not-zero, e.g. array defined
.995b	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.995d	f0 60		beq $99bf			beq 	_VHBadIndex
.995f	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy record address to zaTemp
.9961	85 3e		sta $3e				sta 	zaTemp
.9963	b5 60		lda $60,x			lda 	NSMantissa1,x
.9965	85 3f		sta $3f				sta 	zaTemp+1
.9967	a0 03		ldy #$03			ldy 	#3 							; get the second index - which is 0 if there is one index.
.9969	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.996b	f0 02		beq $996f			beq 	_VHHas2Mask
.996d	a9 ff		lda #$ff			lda 	#$FF
.996f					_VHHas2Mask:
.996f	d5 52		cmp $52,x			cmp 	NSStatus+2,x 				; so if they are the same there are the wrong number of indices
.9971	f0 4c		beq $99bf			beq 	_VHBadIndex
.9973	0a		asl a				asl 	a 							; carry will be set if a second index
.9974	90 08		bcc $997e			bcc 	_VHCheckFirstIndex
.9976	a0 03		ldy #$03			ldy 	#3 			 				; check the 2nd size >= 2nd index
.9978	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.997a	d5 5a		cmp $5a,x			cmp 	NSMantissa0+2,x
.997c	90 41		bcc $99bf			bcc 	_VHBadIndex
.997e					_VHCheckFirstIndex:
.997e	a0 02		ldy #$02			ldy 	#2 			 				; check the 2nd size >= 2nd index
.9980	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9982	d5 59		cmp $59,x			cmp 	NSMantissa0+1,x
.9984	90 39		bcc $99bf			bcc 	_VHBadIndex
.9986	64 36		stz $36				stz 	zTemp0 						; clear zTemp0 (if 1 index)
.9988	64 37		stz $37				stz 	zTemp0+1
.998a	b5 52		lda $52,x			lda 	NSStatus+2,x 				; if only one index provided, don't need to multiply
.998c	30 0e		bmi $999c			bmi 	_VHNoMultiply
.998e	da		phx				phx
.998f	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; get 2nd index on stack
.9991	48		pha				pha
.9992	a0 02		ldy #$02			ldy 	#2 							; get 1st size in A
.9994	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9996	1a		inc a				inc 	a 							; add 1 for zero base
.9997	fa		plx				plx
.9998	20 c7 9d	jsr $9dc7			jsr 	Multiply8x8 				; calculate -> Z0
.999b	fa		plx				plx
.999c					_VHNoMultiply:
.999c	18		clc				clc
.999d	a5 36		lda $36				lda 	zTemp0
.999f	75 59		adc $59,x			adc 	NSMantissa0+1,x
.99a1	85 36		sta $36				sta 	zTemp0
.99a3	a5 37		lda $37				lda 	zTemp0+1
.99a5	69 00		adc #$00			adc 	#0
.99a7	85 37		sta $37				sta 	zTemp0+1
.99a9	b5 50		lda $50,x			lda 	NSStatus,x
.99ab	20 11 85	jsr $8511			jsr 	ScaleByBaseType
.99ae	18		clc				clc
.99af	b2 3e		lda ($3e)			lda 	(zaTemp)
.99b1	65 36		adc $36				adc 	zTemp0
.99b3	95 58		sta $58,x			sta 	NSMantissa0,x
.99b5	a0 01		ldy #$01			ldy 	#1
.99b7	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99b9	65 37		adc $37				adc 	zTemp0+1
.99bb	95 60		sta $60,x			sta 	NSMantissa1,x
.99bd	7a		ply				ply 								; restore position
.99be	60		rts				rts
.99bf					_VHBadIndex:
.99bf	a9 17		lda #$17		lda	#23
.99c1	4c fa 8e	jmp $8efa		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/abs.asm

.99c4					AbsUnary:
.99c4	fa		plx				plx 								; restore stack pos
.99c5	20 6a 9d	jsr $9d6a			jsr 	EvaluateNumber 				; get a float or int
.99c8	20 e1 8e	jsr $8ee1			jsr 	CheckRightBracket
.99cb	b5 50		lda $50,x			lda 	NSStatus,x 					; clear the sign bit
.99cd	29 7f		and #$7f			and 	#$7F
.99cf	95 50		sta $50,x			sta 	NSStatus,x
.99d1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/alloc.asm

.99d2					AllocUnary:
.99d2	fa		plx				plx 								; restore stack pos
.99d3	20 9c 9d	jsr $9d9c			jsr 	Evaluate16BitInteger		; get bytes required.
.99d6	20 e1 8e	jsr $8ee1			jsr 	CheckRightBracket
.99d9	da		phx				phx 								; save X/Y
.99da	5a		phy				phy
.99db	8a		txa				txa 								; copy X into Y
.99dc	a8		tay				tay
.99dd	b9 60 00	lda $0060,y			lda		NSMantissa1,y 				; get size into XA
.99e0	aa		tax				tax
.99e1	b9 58 00	lda $0058,y			lda 	NSMantissa0,y
.99e4	20 f1 99	jsr $99f1			jsr 	AllocateXABytes 			; allocate memory
.99e7	99 58 00	sta $0058,y			sta 	NSMantissa0,y 				; write address out.
.99ea	8a		txa				txa 	 							; typing is 16 bit integer.
.99eb	99 60 00	sta $0060,y			sta 	NSMantissa1,y
.99ee	7a		ply				ply
.99ef	fa		plx				plx
.99f0	60		rts				rts
.99f1					AllocateXABytes:
.99f1	5a		phy				phy
.99f2	ac 0c 04	ldy $040c			ldy 	lowMemPtr 					; push current address on stack and to zTemp0
.99f5	84 36		sty $36				sty 	zTemp0
.99f7	5a		phy				phy
.99f8	ac 0d 04	ldy $040d			ldy 	lowMemPtr+1
.99fb	84 37		sty $37				sty 	zTemp0+1
.99fd	5a		phy				phy
.99fe	18		clc				clc 								; add to low memory pointer
.99ff	6d 0c 04	adc $040c			adc 	lowMemPtr
.9a02	8d 0c 04	sta $040c			sta 	lowMemPtr
.9a05	8a		txa				txa
.9a06	6d 0d 04	adc $040d			adc 	lowMemPtr+1
.9a09	8d 0d 04	sta $040d			sta 	lowMemPtr+1
.9a0c	b0 2f		bcs $9a3d			bcs 	CISSMemory
.9a0e	20 2f 9a	jsr $9a2f			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.9a11					_ClearMemory:
.9a11	ad 0c 04	lda $040c			lda 	lowMemPtr 					; cleared all memory allocated
.9a14	c5 36		cmp $36				cmp 	zTemp0
.9a16	d0 07		bne $9a1f			bne 	_CMClearNext
.9a18	ad 0d 04	lda $040d			lda 	lowMemPtr+1
.9a1b	c5 37		cmp $37				cmp 	zTemp0+1
.9a1d	f0 0c		beq $9a2b			beq 	_CMExit
.9a1f					_CMClearNext:
.9a1f	a9 00		lda #$00			lda 	#0 							; clear byte, advance to next.
.9a21	92 36		sta ($36)			sta 	(zTemp0)
.9a23	e6 36		inc $36				inc 	zTemp0
.9a25	d0 ea		bne $9a11			bne 	_ClearMemory
.9a27	e6 37		inc $37				inc		zTemp0+1
.9a29	80 e6		bra $9a11			bra 	_ClearMemory
.9a2b					_CMExit:
.9a2b	fa		plx				plx
.9a2c	68		pla				pla
.9a2d	7a		ply				ply
.9a2e	60		rts				rts
.9a2f					CheckIdentifierStringSpace:
.9a2f	48		pha				pha
.9a30	ad 0d 04	lda $040d			lda 	lowMemPtr+1 				; get low memory pointer
.9a33	18		clc				clc
.9a34	69 02		adc #$02			adc 	#2 							; need at least 2 256 byte pages
.9a36	cd 0f 04	cmp $040f			cmp 	StringMemory+1 				; is it >= StringMemory
.9a39	b0 02		bcs $9a3d			bcs 	CISSMemory
.9a3b	68		pla				pla
.9a3c	60		rts				rts
.9a3d					CISSMemory:
.9a3d	a9 06		lda #$06		lda	#6
.9a3f	4c fa 8e	jmp $8efa		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/asc.asm

.9a42					AscUnary:
.9a42	fa		plx				plx 								; restore stack pos
.9a43	20 74 9d	jsr $9d74			jsr 	EvaluateString 				; get a string
.9a46	b2 36		lda ($36)			lda 	(zTemp0)					; get/return first character
.9a48	20 1e 9e	jsr $9e1e			jsr 	NSMSetByte 					; ASC("") will return zero.
.9a4b	20 e1 8e	jsr $8ee1			jsr 	CheckRightBracket
.9a4e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/deekpeek.asm

.9a4f					PeekUnary:
.9a4f	18		clc				clc
.9a50	80 01		bra $9a53			bra 	DPUnary
.9a52					DeekUnary:
.9a52	38		sec				sec
.9a53					DPUnary:
.9a53	fa		plx				plx 								; restore position.
.9a54	08		php				php									; save on stack, CS = Deek, CC = Peek
.9a55	20 9c 9d	jsr $9d9c			jsr		Evaluate16BitInteger 		; address as constant.
.9a58	20 e1 8e	jsr $8ee1			jsr 	CheckRightBracket
.9a5b	28		plp				plp 								; function back.
.9a5c	a9 21		lda #$21			lda 	#NSBIsReference+NSTInteger+1 ; 1 byte read
.9a5e	90 01		bcc $9a61			bcc 	_DPUpdate
.9a60	1a		inc a				inc 	a 							; 2 byte read
.9a61					_DPUpdate:
.9a61	95 50		sta $50,x			sta 	NSStatus,x 					; set to 1/2 byte reference.
.9a63	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/frac.asm

.9a64					FracUnary:
.9a64	fa		plx				plx 								; restore stack pos
.9a65	20 6a 9d	jsr $9d6a			jsr 	EvaluateNumber 				; get a float or int
.9a68	20 e1 8e	jsr $8ee1			jsr 	CheckRightBracket
.9a6b	b5 50		lda $50,x			lda 	NSStatus,x
.9a6d	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9a6f	f0 04		beq $9a75			beq 	_IUZero
.9a71	20 0f 95	jsr $950f			jsr 	FloatFractionalPart 		; if so, get the fractional part.
.9a74	60		rts				rts
.9a75					_IUZero:
.9a75	20 1c 9e	jsr $9e1c			jsr 	NSMSetZero
.9a78	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/int.asm

.9a79					IntUnary:
.9a79	fa		plx				plx 								; restore stack pos
.9a7a	20 6a 9d	jsr $9d6a			jsr 	EvaluateNumber 				; get a float or int
.9a7d	20 e1 8e	jsr $8ee1			jsr 	CheckRightBracket
.9a80	b5 50		lda $50,x			lda 	NSStatus,x
.9a82	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9a84	f0 03		beq $9a89			beq 	_IUExit
.9a86	20 67 95	jsr $9567			jsr 	FloatIntegerPart 			; if it is get the integer part.
.9a89					_IUExit:
.9a89	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/len.asm

.9a8a					LenUnary:
.9a8a	fa		plx				plx 								; restore stack pos
.9a8b	20 74 9d	jsr $9d74			jsr 	EvaluateString 				; get a string
.9a8e	5a		phy				phy
.9a8f	a0 00		ldy #$00			ldy 	#0 							; find length
.9a91					_LenFind:
.9a91	b1 36		lda ($36),y			lda 	(zTemp0),y 					; look for trailing NULL.
.9a93	f0 06		beq $9a9b			beq 	_LenExit
.9a95	c8		iny				iny
.9a96	d0 f9		bne $9a91			bne 	_LenFind
.9a98	4c 9f 9f	jmp $9f9f			jmp 	RangeError 					; string > 255 - no trailing NULL.
.9a9b					_LenExit:
.9a9b	98		tya				tya		 							; return length
.9a9c	20 1e 9e	jsr $9e1e			jsr 	NSMSetByte
.9a9f	7a		ply				ply
.9aa0	20 e1 8e	jsr $8ee1			jsr 	CheckRightBracket
.9aa3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/minmax.asm

.9aa4					Unary_Min:
.9aa4	a9 01		lda #$01			lda 	#1
.9aa6	80 02		bra $9aaa			bra 	UnaryMinMaxMain
.9aa8					Unary_Max:
.9aa8	a9 ff		lda #$ff			lda 	#$FF 						; value from comparator to cause a write
.9aaa					UnaryMinMaxMain:
.9aaa	fa		plx				plx 								; get index on number stack
.9aab	48		pha				pha 								; save comparator
.9aac	20 61 9d	jsr $9d61			jsr 	EvaluateValue 				; get the first value.
.9aaf					_UMMMLoop:
.9aaf	b1 30		lda ($30),y			lda 	(codePtr),y
.9ab1	c9 29		cmp #$29			cmp 	#KWD_RPAREN 				; if right bracket then done.
.9ab3	f0 22		beq $9ad7			beq 	_UMMMDone
.9ab5	20 e9 8e	jsr $8ee9			jsr 	CheckComma 					; must be a comma
.9ab8	e8		inx				inx
.9ab9	20 61 9d	jsr $9d61			jsr 	EvaluateValue
.9abc	ca		dex				dex
.9abd	20 ff 9d	jsr $9dff			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] (Compare is destructive)
.9ac0	e8		inx				inx
.9ac1	20 ff 9d	jsr $9dff			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2], original
.9ac4	e8		inx				inx
.9ac5	20 b1 8f	jsr $8fb1			jsr 	CompareBaseCode 			; part of > = < etc. code, returns 255,0 or 1
.9ac8	ca		dex				dex
.9ac9	ca		dex				dex
.9aca	85 36		sta $36				sta 	zTemp0 						; save required result
.9acc	68		pla				pla 								; get and save comparator
.9acd	48		pha				pha
.9ace	c5 36		cmp $36				cmp 	zTemp0 						; if the comparator
.9ad0	d0 dd		bne $9aaf			bne 	_UMMMLoop
.9ad2	20 da 9a	jsr $9ada			jsr 	ExpCopyAboveDown 			; copy next up slot down
.9ad5	80 d8		bra $9aaf			bra 	_UMMMLoop
.9ad7					_UMMMDone:
.9ad7	68		pla				pla 								; throw the comparator
.9ad8	c8		iny				iny 								; skip )
.9ad9	60		rts				rts
.9ada					ExpCopyAboveDown:
.9ada	b5 51		lda $51,x			lda 	NSStatus+1,x
.9adc	95 50		sta $50,x			sta 	NSStatus,x
.9ade	b5 79		lda $79,x			lda 	NSExponent+1,x
.9ae0	95 78		sta $78,x			sta 	NSExponent,x
.9ae2	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9ae4	95 58		sta $58,x			sta 	NSMantissa0,x
.9ae6	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9ae8	95 60		sta $60,x			sta 	NSMantissa1,x
.9aea	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.9aec	95 68		sta $68,x			sta 	NSMantissa2,x
.9aee	b5 71		lda $71,x			lda 	NSMantissa3+1,x
.9af0	95 70		sta $70,x			sta 	NSMantissa3,x
.9af2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/not.asm

.9af3					Unary_Not:
.9af3	fa		plx				plx
.9af4	20 89 9d	jsr $9d89			jsr 	EvaluateInteger 			; get integer
.9af7	20 e1 8e	jsr $8ee1			jsr 	CheckRightBracket
.9afa	20 3e 9e	jsr $9e3e			jsr 	NSMIsZero 					; zero mantissa ?
.9afd	f0 04		beq $9b03			beq 	_NotZero
.9aff	20 1c 9e	jsr $9e1c			jsr 	NSMSetZero
.9b02	60		rts				rts
.9b03					_NotZero:
.9b03	4c 67 8f	jmp $8f67			jmp 	ReturnTrue

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/rnd.asm

.9b06					Unary_Random:
.9b06	fa		plx				plx
.9b07	20 78 9b	jsr $9b78			jsr 	Random32Bit 				; get a random number
.9b0a	20 61 9b	jsr $9b61			jsr 	URCopyToMantissa  			; put in mantissa
.9b0d	b1 30		lda ($30),y			lda 	(codePtr),y
.9b0f	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.9b11	f0 08		beq $9b1b			beq 	_URNoModulus 				; then we return a random 30 bit number.
.9b13	e8		inx				inx
.9b14	20 9c 9d	jsr $9d9c			jsr 	Evaluate16BitInteger 		; put modulus value in +1
.9b17	ca		dex				dex
.9b18	20 b9 90	jsr $90b9			jsr 	IntegerModulusNoCheck 		; calculate modulus, so now 0 .. n-1
.9b1b					_URNoModulus:
.9b1b	74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer positive
.9b1d	74 78		stz $78,x			stz 	NSExponent,x
.9b1f	20 e1 8e	jsr $8ee1			jsr 	CheckRightBracket
.9b22	60		rts				rts
.9b23					Unary_Rnd:
.9b23	fa		plx				plx
.9b24	20 6a 9d	jsr $9d6a			jsr 	EvaluateNumber 				; number to use.
.9b27	20 e1 8e	jsr $8ee1			jsr 	CheckRightBracket 			; closing bracket
.9b2a	20 3e 9e	jsr $9e3e			jsr 	NSMIsZero 					; if zero, then don't generate a new number
.9b2d	f0 26		beq $9b55			beq 	_URCopySeed
.9b2f	b5 50		lda $50,x			lda 	NSStatus,x 					; if -ve, then seed using parameter
.9b31	10 1f		bpl $9b52			bpl 	_URDontSeed
.9b33	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy - value to seed butchering it.
.9b35	49 17		eor #$17			eor 	#$17
.9b37	8d 08 04	sta $0408			sta 	RandomSeed+0
.9b3a	b5 60		lda $60,x			lda 	NSMantissa1,x
.9b3c	49 a5		eor #$a5			eor 	#$A5
.9b3e	8d 09 04	sta $0409			sta 	RandomSeed+1
.9b41	b5 68		lda $68,x			lda 	NSMantissa2,x
.9b43	49 c2		eor #$c2			eor 	#$C2
.9b45	8d 0a 04	sta $040a			sta 	RandomSeed+2
.9b48	b5 70		lda $70,x			lda 	NSMantissa3,x
.9b4a	49 9d		eor #$9d			eor 	#$9D
.9b4c	8d 0b 04	sta $040b			sta 	RandomSeed+3
.9b4f	20 78 9b	jsr $9b78			jsr 	Random32Bit
.9b52					_URDontSeed:
.9b52	20 78 9b	jsr $9b78			jsr 	Random32Bit 				; generate a number
.9b55					_URCopySeed:
.9b55	20 61 9b	jsr $9b61			jsr 	URCopyToMantissa 			; copy into mantissa
.9b58	a9 e2		lda #$e2			lda 	#-30 						; force into 0-1 range
.9b5a	95 78		sta $78,x			sta 	NSExponent,x
.9b5c	a9 08		lda #$08			lda 	#NSTFloat
.9b5e	95 50		sta $50,x			sta 	NSStatus,x 					; positive float
.9b60	60		rts				rts
.9b61					URCopyToMantissa:
.9b61	ad 08 04	lda $0408			lda 	RandomSeed+0
.9b64	95 58		sta $58,x			sta 	NSMantissa0,x
.9b66	ad 09 04	lda $0409			lda 	RandomSeed+1
.9b69	95 60		sta $60,x			sta 	NSMantissa1,x
.9b6b	ad 0a 04	lda $040a			lda 	RandomSeed+2
.9b6e	95 68		sta $68,x			sta 	NSMantissa2,x
.9b70	ad 0b 04	lda $040b			lda 	RandomSeed+3
.9b73	29 3f		and #$3f			and 	#$3F 						; make legal mantissa
.9b75	95 70		sta $70,x			sta 	NSMantissa3,x
.9b77	60		rts				rts
.9b78					Random32Bit:
.9b78	5a		phy				phy
.9b79	a0 07		ldy #$07			ldy 	#7 							; do it 7 times
.9b7b	ad 08 04	lda $0408			lda 	RandomSeed+0 				; check the seed isn't zero
.9b7e	d0 03		bne $9b83			bne 	_Random1
.9b80	a8		tay				tay 								; if so do it 256 times
.9b81	a9 aa		lda #$aa			lda		#$AA 						; and use this to seed the seed....
.9b83					_Random1:
.9b83	0a		asl a				asl 	a 							; LSFR RNG
.9b84	2e 09 04	rol $0409			rol 	RandomSeed+1
.9b87	2e 0a 04	rol $040a			rol 	RandomSeed+2
.9b8a	2e 0b 04	rol $040b			rol 	RandomSeed+3
.9b8d	90 02		bcc $9b91			bcc 	_Random2
.9b8f	49 c5		eor #$c5			eor 	#$C5
.9b91					_Random2:
.9b91	88		dey				dey
.9b92	d0 ef		bne $9b83			bne 	_Random1
.9b94	8d 08 04	sta $0408			sta 	RandomSeed+0
.9b97	7a		ply				ply
.9b98	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/sgn.asm

.9b99					SgnUnary:
.9b99	fa		plx				plx 								; restore stack pos
.9b9a	20 6a 9d	jsr $9d6a			jsr 	EvaluateNumber 				; get a float or int
.9b9d	20 e1 8e	jsr $8ee1			jsr 	CheckRightBracket
.9ba0	20 3e 9e	jsr $9e3e			jsr 	NSMIsZero 					; if zero
.9ba3	f0 0e		beq $9bb3			beq 	_SGZero  					; return Int Zero
.9ba5	b5 50		lda $50,x			lda 	NSStatus,x 					; get status w/sign
.9ba7	48		pha				pha
.9ba8	a9 01		lda #$01			lda 	#1 							; set to 1
.9baa	20 1e 9e	jsr $9e1e			jsr 	NSMSetByte
.9bad	68		pla				pla
.9bae	29 80		and #$80			and		#$80 						; copy the sign byte out
.9bb0	95 50		sta $50,x			sta 	NSStatus,x  				; so it will be -1 or 1
.9bb2	60		rts				rts
.9bb3	20 1c 9e	jsr $9e1c	_SGZero:jsr 	NSMSetZero
.9bb6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/val.asm

.9bb7					ValUnary:
.9bb7	fa		plx				plx 								; restore stack pos
.9bb8	20 cd 9b	jsr $9bcd			jsr 	ValMainCode 				; do the main val() code
.9bbb	b0 01		bcs $9bbe			bcs 	_VUError 					; couldn't convert
.9bbd	60		rts				rts
.9bbe					_VUError:
.9bbe	4c a4 9f	jmp $9fa4			jmp 	TypeError
.9bc1					IsValUnary:
.9bc1	fa		plx				plx 								; restore stack pos
.9bc2	20 cd 9b	jsr $9bcd			jsr 	ValMainCode 				; do the main val() code
.9bc5	b0 03		bcs $9bca			bcs 	_VUBad
.9bc7	4c 67 8f	jmp $8f67			jmp 	ReturnTrue
.9bca					_VUBad:
.9bca	4c 72 8f	jmp $8f72			jmp 	ReturnFalse
.9bcd					ValMainCode:
.9bcd	20 74 9d	jsr $9d74			jsr 	EvaluateString 				; get a string
.9bd0	20 e1 8e	jsr $8ee1			jsr 	CheckRightBracket 			; check right bracket present
.9bd3					ValEvaluateZTemp0:
.9bd3	5a		phy				phy
.9bd4	b2 36		lda ($36)			lda 	(zTemp0) 					; check not empty string
.9bd6	f0 17		beq $9bef			beq 	_VMCFail2
.9bd8	a0 ff		ldy #$ff			ldy 	#$FF 						; start position
.9bda	48		pha				pha 								; save first character
.9bdb	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.9bdd	d0 01		bne $9be0			bne 	_VMCStart
.9bdf	c8		iny				iny 								; skip over -
.9be0					_VMCStart:
.9be0	38		sec				sec 								; initialise first time round.
.9be1					_VMCNext:
.9be1	c8		iny				iny 								; pre-increment
.9be2	b1 36		lda ($36),y			lda 	(zTemp0),y 					; next character = EOS ?
.9be4	f0 0c		beq $9bf2			beq 	_VMCSuccess 				; successful.
.9be6	20 44 97	jsr $9744			jsr 	EncodeNumber 				; send it to the number-builder
.9be9	90 03		bcc $9bee			bcc 	_VMCFail 					; if failed, give up.
.9beb	18		clc				clc 								; next time round, countinue
.9bec	80 f3		bra $9be1			bra 	_VMCNext
.9bee					_VMCFail:
.9bee	68		pla				pla
.9bef					_VMCFail2:
.9bef	7a		ply				ply
.9bf0	38		sec				sec
.9bf1	60		rts				rts
.9bf2					_VMCSuccess:
.9bf2	a9 00		lda #$00			lda 	#0 							; construct final
.9bf4	20 44 97	jsr $9744			jsr 	EncodeNumber 				; by sending a duff value.
.9bf7	68		pla				pla 								; if it was -ve
.9bf8	c9 2d		cmp #$2d			cmp 	#"-"
.9bfa	d0 03		bne $9bff			bne 	_VMCNotNegative
.9bfc	20 de 9d	jsr $9dde			jsr		NSMNegate 					; negate it.
.9bff					_VMCNotNegative:
.9bff	7a		ply				ply
.9c00	18		clc				clc
.9c01	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/chr.asm

.9c02					ChrUnary:
.9c02	fa		plx				plx 								; restore stack pos
.9c03	20 b7 9d	jsr $9db7			jsr 	Evaluate8BitInteger			; get value (chr$(0) returns an empty string)
.9c06	48		pha				pha
.9c07	20 e1 8e	jsr $8ee1			jsr 	CheckRightBracket
.9c0a	a9 01		lda #$01			lda 	#1 							; allocate space for one char
.9c0c	20 9e a7	jsr $a79e			jsr 	StringTempAllocate
.9c0f	68		pla				pla 								; write number to it
.9c10	20 d7 a7	jsr $a7d7			jsr 	StringTempWrite
.9c13	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/spc.asm

.9c14					SpcUnary:
.9c14	fa		plx				plx 								; restore stack pos
.9c15	20 b7 9d	jsr $9db7			jsr 	Evaluate8BitInteger			; get value
.9c18	5a		phy				phy
.9c19	48		pha				pha 								; save count
.9c1a	20 9e a7	jsr $a79e			jsr 	StringTempAllocate
.9c1d	7a		ply				ply 								; to do count in Y
.9c1e					_SpcLoop:
.9c1e	c0 00		cpy #$00			cpy 	#0 							; copy Y spaces in.
.9c20	f0 08		beq $9c2a			beq 	_SpcExit
.9c22	a9 20		lda #$20			lda 	#32
.9c24	20 d7 a7	jsr $a7d7			jsr 	StringTempWrite
.9c27	88		dey				dey
.9c28	80 f4		bra $9c1e			bra 	_SPCLoop
.9c2a					_SpcExit:
.9c2a	7a		ply				ply
.9c2b	20 e1 8e	jsr $8ee1			jsr 	CheckRightBracket
.9c2e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/str.asm

.9c2f					Unary_Str:
.9c2f	fa		plx				plx
.9c30	20 6a 9d	jsr $9d6a			jsr 	EvaluateNumber  			; get number
.9c33	20 e1 8e	jsr $8ee1			jsr 	CheckRightBracket 			; closing bracket
.9c36	a9 05		lda #$05			lda 	#5 							; maximum decimals, from Basic816
.9c38	20 51 9c	jsr $9c51			jsr 	ConvertNumberToString 		; do the conversion.
.9c3b	a9 21		lda #$21			lda		#33 						; create buffer
.9c3d	20 9e a7	jsr $a79e			jsr 	StringTempAllocate 			; allocate memory
.9c40	da		phx				phx  								; copy the converted string into the buffer.
.9c41	a2 00		ldx #$00			ldx 	#0
.9c43					_USCopy:
.9c43	bd 9d 05	lda $059d,x			lda 	DecimalBuffer,x
.9c46	20 d7 a7	jsr $a7d7			jsr 	StringTempWrite
.9c49	e8		inx				inx
.9c4a	bd 9d 05	lda $059d,x			lda 	DecimalBuffer,x
.9c4d	d0 f4		bne $9c43			bne 	_USCopy
.9c4f	fa		plx				plx
.9c50	60		rts				rts
.9c51					ConvertNumberToString:
.9c51	5a		phy				phy 								; save code position
.9c52	8d 14 04	sta $0414			sta 	DecimalPlaces	 			; save number of DPs.
.9c55	9c 15 04	stz $0415			stz 	dbOffset 					; offset into decimal buffer = start.
.9c58	b5 50		lda $50,x			lda 	NSStatus,x  				; is it -ve.
.9c5a	10 09		bpl $9c65			bpl 	_CNTSNotNegative
.9c5c	29 7f		and #$7f			and 	#$7F 						; make +ve
.9c5e	95 50		sta $50,x			sta 	NSStatus,x
.9c60	a9 2d		lda #$2d			lda 	#"-"
.9c62	20 c6 9c	jsr $9cc6			jsr 	WriteDecimalBuffer
.9c65					_CNTSNotNegative:
.9c65	b5 78		lda $78,x			lda 	NSExponent,x 				; check if decimal
.9c67	f0 12		beq $9c7b			beq 	_CNTSNotFloat
.9c69	e8		inx				inx 								; round up so we don't get too many 6.999999
.9c6a	a9 01		lda #$01			lda 	#1
.9c6c	20 1e 9e	jsr $9e1e			jsr 	NSMSetByte
.9c6f	ca		dex				dex
.9c70	b5 78		lda $78,x			lda		NSExponent,x
.9c72	95 79		sta $79,x			sta 	NSExponent+1,x
.9c74	a9 08		lda #$08			lda 	#NSTFloat
.9c76	95 51		sta $51,x			sta 	NSStatus+1,x
.9c78	20 49 94	jsr $9449			jsr 	FloatAdd
.9c7b					_CNTSNotFloat:
.9c7b	20 a8 9c	jsr $9ca8			jsr 	MakePlusTwoString 			; do the integer part.
.9c7e	20 0f 95	jsr $950f			jsr 	FloatFractionalPart 		; get the fractional part
.9c81	20 c0 95	jsr $95c0			jsr 	NSNormalise					; normalise , exit if zero
.9c84	f0 20		beq $9ca6			beq 	_CNTSExit
.9c86	a9 2e		lda #$2e			lda 	#"."
.9c88	20 c6 9c	jsr $9cc6			jsr 	WriteDecimalBuffer 			; write decimal place
.9c8b					_CNTSDecimal:
.9c8b	ce 14 04	dec $0414			dec 	DecimalPlaces 				; done all the decimals
.9c8e	30 16		bmi $9ca6			bmi 	_CNTSExit
.9c90	e8		inx				inx 								; x 10.0
.9c91	a9 0a		lda #$0a			lda 	#10
.9c93	20 1e 9e	jsr $9e1e			jsr 	NSMSetByte
.9c96	a9 08		lda #$08			lda 	#NSTFloat
.9c98	95 50		sta $50,x			sta 	NSStatus,x
.9c9a	ca		dex				dex
.9c9b	20 8e 95	jsr $958e			jsr 	FloatMultiply
.9c9e	20 a8 9c	jsr $9ca8			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.9ca1	20 0f 95	jsr $950f			jsr 	FloatFractionalPart 		; get the fractional part
.9ca4	80 e5		bra $9c8b			bra 	_CNTSDecimal 				; keep going.
.9ca6					_CNTSExit:
.9ca6	7a		ply				ply
.9ca7	60		rts				rts
.9ca8					MakePlusTwoString:
.9ca8	da		phx				phx
.9ca9	20 ff 9d	jsr $9dff			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.9cac	e8		inx				inx 								; access it
.9cad	e8		inx				inx
.9cae	20 67 95	jsr $9567			jsr 	FloatIntegerPart 			; make it an integer
.9cb1	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.9cb3	20 79 93	jsr $9379			jsr 	ConvertInt32
.9cb6	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.9cb8					_MPTSCopy:
.9cb8	bd 7b 05	lda $057b,x			lda 	NumberBuffer,x
.9cbb	20 c6 9c	jsr $9cc6			jsr 	WriteDecimalBuffer
.9cbe	e8		inx				inx
.9cbf	bd 7b 05	lda $057b,x			lda 	NumberBuffer,x
.9cc2	d0 f4		bne $9cb8			bne 	_MPTSCopy
.9cc4	fa		plx				plx
.9cc5	60		rts				rts
.9cc6					WriteDecimalBuffer:
.9cc6	da		phx				phx
.9cc7	ae 15 04	ldx $0415			ldx 	dbOffset
.9cca	9d 9d 05	sta $059d,x			sta 	DecimalBuffer,x
.9ccd	9e 9e 05	stz $059e,x			stz 	DecimalBuffer+1,x
.9cd0	ee 15 04	inc $0415			inc 	dbOffset
.9cd3	fa		plx				plx
.9cd4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/substring.asm

.9cd5					Unary_Left:
.9cd5	fa		plx				plx
.9cd6	18		clc				clc 								; only one parameter
.9cd7	20 3a 9d	jsr $9d3a			jsr 	SubstringInitial 			; set up.
.9cda	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; Param #1 is the length
.9cdc	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9cde	74 59		stz $59,x			stz 	NSMantissa0+1,x 			; Start is zero.
.9ce0	80 25		bra $9d07			bra 	SubstringMain
.9ce2					Unary_Right:
.9ce2	fa		plx				plx
.9ce3	18		clc				clc 								; only one parameter
.9ce4	20 3a 9d	jsr $9d3a			jsr 	SubstringInitial 			; set up.
.9ce7	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; length => param 2
.9ce9	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9ceb	b5 78		lda $78,x			lda 	NSExponent,x 				; total length
.9ced	f5 59		sbc $59,x			sbc 	NSMantissa0+1,x 			; length - required.
.9cef	b0 02		bcs $9cf3			bcs 	_URNotUnderflow
.9cf1	a9 00		lda #$00			lda 	#0 							; start from the beginning, as something like right$("AB",3)
.9cf3					_URNotUnderFlow:
.9cf3	95 59		sta $59,x			sta 	NSMantissa0+1,x 			; this is the start position
.9cf5	80 10		bra $9d07			bra 	SubStringMain
.9cf7					Unary_Mid:
.9cf7	fa		plx				plx
.9cf8	38		sec				sec 								; two parameters
.9cf9	20 3a 9d	jsr $9d3a			jsr 	SubstringInitial 			; set up.
.9cfc	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; first parameter is zero ?
.9cfe	f0 04		beq $9d04			beq 	_UMError
.9d00	d6 59		dec $59,x			dec 	NSMantissa0+1,x				; reduce initial offset by 1 as MID$(a$,1..) is actually the first character
.9d02	80 03		bra $9d07			bra 	SubStringMain
.9d04					_UMError:
.9d04	4c a9 9f	jmp $9fa9			jmp 	ArgumentError
.9d07					SubStringMain:
.9d07	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; is the initial offset >= the length
.9d09	d5 78		cmp $78,x			cmp 	NSExponent,x
.9d0b	b0 27		bcs $9d34			bcs 	_SSMNull 					; if so, return an empty string.
.9d0d	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; if copy count is zero
.9d0f	f0 23		beq $9d34			beq 	_SSMNull 					; return empty string.
.9d11	18		clc				clc 								; add the offset +1 to the address and
.9d12	b5 58		lda $58,x			lda	 	NSMantissa0,x 				; put in zTemp, this is the start of the substring to copy.
.9d14	75 59		adc $59,x			adc 	NSMantissa0+1,x
.9d16	85 36		sta $36				sta 	zTemp0
.9d18	b5 60		lda $60,x			lda	 	NSMantissa1,x
.9d1a	69 00		adc #$00			adc 	#0
.9d1c	85 37		sta $37				sta 	zTemp0+1
.9d1e					_SSMNoCarry:
.9d1e	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; characters required.
.9d20	20 9e a7	jsr $a79e			jsr 	StringTempAllocate 			; allocate that many characters
.9d23	5a		phy				phy 								; save Y
.9d24	a0 00		ldy #$00			ldy 	#0 							; start copying in.
.9d26					_SSMCopy:
.9d26	b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next character
.9d28	f0 08		beq $9d32			beq 	_SSMEString 				; no more to copy
.9d2a	20 d7 a7	jsr $a7d7			jsr 	StringTempWrite 			; and write it out.
.9d2d	c8		iny				iny
.9d2e	d6 5a		dec $5a,x			dec 	NSMantissa0+2,x
.9d30	d0 f4		bne $9d26			bne 	_SSMCopy
.9d32					_SSMEString:
.9d32	7a		ply				ply
.9d33					_SSMExit:
.9d33	60		rts				rts
.9d34					_SSMNull:
.9d34	a9 00		lda #$00			lda 	#0
.9d36	20 9e a7	jsr $a79e			jsr 	StringTempAllocate
.9d39	60		rts				rts
.9d3a					SubstringInitial:
.9d3a	da		phx				phx 								; save initial stack position
.9d3b	08		php				php 								; save carry on stack indicating 2 parameters
.9d3c	20 74 9d	jsr $9d74			jsr 	EvaluateString 				; get a string
.9d3f	5a		phy				phy 								; calculate length to exponent.
.9d40	a0 ff		ldy #$ff			ldy 	#$FF
.9d42					_SIFindLength:
.9d42	c8		iny				iny
.9d43	b1 36		lda ($36),y			lda 	(zTemp0),y
.9d45	d0 fb		bne $9d42			bne 	_SIFindLength
.9d47	98		tya				tya
.9d48	95 78		sta $78,x			sta 	NSExponent,x
.9d4a	7a		ply				ply
.9d4b	e8		inx				inx
.9d4c	20 e9 8e	jsr $8ee9			jsr 	CheckComma 					; comma next
.9d4f	20 b7 9d	jsr $9db7			jsr 	Evaluate8BitInteger 		; get next parameter
.9d52	28		plp				plp 								; is it the last parameter ?
.9d53	90 07		bcc $9d5c			bcc 	_SSIExit 					; if so, exit.
.9d55	e8		inx				inx
.9d56	20 e9 8e	jsr $8ee9			jsr 	CheckComma 					; comma next
.9d59	20 b7 9d	jsr $9db7			jsr 	Evaluate8BitInteger 		; get last parameter
.9d5c					_SSIExit:
.9d5c	fa		plx				plx
.9d5d	20 e1 8e	jsr $8ee1			jsr 	CheckRightBracket 			; check closing bracket
.9d60	60		rts				rts 								; exit

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/exprhelper.asm

.9d61					EvaluateValue:
.9d61	48		pha				pha
.9d62	20 fe 93	jsr $93fe			jsr		EvaluateExpression 			; expression
.9d65	20 c1 96	jsr $96c1			jsr 	Dereference					; derefernce it
.9d68	68		pla				pla
.9d69	60		rts				rts
.9d6a					EvaluateNumber:
.9d6a	20 61 9d	jsr $9d61			jsr 	EvaluateValue 				; get a value
.9d6d	b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.9d6f	29 10		and #$10			and 	#NSBIsString
.9d71	d0 13		bne $9d86			bne 	HelperTypeError
.9d73	60		rts				rts
.9d74					EvaluateString:
.9d74	20 61 9d	jsr $9d61			jsr 	EvaluateValue 				; get a value
.9d77	b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.9d79	29 10		and #$10			and 	#NSBIsString
.9d7b	f0 09		beq $9d86			beq 	HelperTypeError
.9d7d					CopyAddressToTemp0:
.9d7d	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address -> zTemp0
.9d7f	85 36		sta $36				sta 	zTemp0 						; (so we can do something with it)
.9d81	b5 60		lda $60,x			lda 	NSMantissa1,x
.9d83	85 37		sta $37				sta 	zTemp0+1
.9d85	60		rts				rts
.9d86					HelperTypeError:
.9d86	4c a4 9f	jmp $9fa4			jmp 	TypeError
.9d89					EvaluateInteger:
.9d89	20 6a 9d	jsr $9d6a			jsr 	EvaluateNumber
.9d8c	b5 78		lda $78,x			lda 	NSExponent,x 				; check exponent is zero
.9d8e	d0 09		bne $9d99			bne 	HelperValueError 			; if not, it's a float.
.9d90	60		rts				rts
.9d91					EvaluateUnsignedInteger:
.9d91	20 89 9d	jsr $9d89			jsr 	EvaluateInteger 			; check integer is +ve
.9d94	b5 50		lda $50,x			lda 	NSStatus,x
.9d96	30 01		bmi $9d99			bmi 	HelperValueError
.9d98	60		rts				rts
.9d99					HelperValueError:
.9d99	4c a9 9f	jmp $9fa9			jmp 	ArgumentError
.9d9c					Evaluate16BitInteger:
.9d9c	20 91 9d	jsr $9d91			jsr	 	EvaluateUnsignedInteger		; get integer
.9d9f	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9da1	15 68		ora $68,x			ora 	NSMantissa2,x
.9da3	d0 f4		bne $9d99			bne 	HelperValueError
.9da5	60		rts				rts
.9da6					Evaluate16BitIntegerSigned:
.9da6	20 89 9d	jsr $9d89			jsr	 	EvaluateInteger				; get integer
.9da9	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9dab	15 68		ora $68,x			ora 	NSMantissa2,x
.9dad	d0 ea		bne $9d99			bne 	HelperValueError
.9daf	b5 50		lda $50,x			lda 	NSStatus,x 					; signed ?
.9db1	10 03		bpl $9db6			bpl 	_EISNotSigned
.9db3	20 e5 9d	jsr $9de5			jsr 	NSMNegateMantissa 			; makes it an actual 2's complement value.
.9db6					_EISNotSigned:
.9db6	60		rts				rts
.9db7					Evaluate8BitInteger:
.9db7	20 91 9d	jsr $9d91			jsr	 	EvaluateUnsignedInteger 	; get an integer
.9dba	d0 dd		bne $9d99			bne 	HelperValueError
.9dbc	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 1, 2 & 3 must be zero
.9dbe	15 68		ora $68,x			ora 	NSMantissa2,x
.9dc0	15 60		ora $60,x			ora 	NSMantissa1,x
.9dc2	d0 d5		bne $9d99			bne 	HelperValueError
.9dc4	b5 58		lda $58,x			lda 	NSMantissa0,x
.9dc6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/mult8x8.asm

.9dc7					Multiply8x8:
.9dc7	4a		lsr a		  		lsr 	a  							; prime the carry bit for the loop
.9dc8	85 36		sta $36			  	sta 	zTemp0
.9dca	86 37		stx $37				stx 	zTemp0+1
.9dcc	a9 00		lda #$00			lda 	#0
.9dce	a2 08		ldx #$08			ldx 	#8
.9dd0					_M88Loop:
.9dd0	90 03		bcc $9dd5			bcc 	_M88NoAdd
.9dd2	18		clc				clc
.9dd3	65 37		adc $37				adc 	zTemp0+1
.9dd5					_M88NoAdd:
.9dd5	6a		ror a				ror 	a
.9dd6	66 36		ror $36				ror 	zTemp0  					; pull another bit out for the next iteration
.9dd8	ca		dex				dex         						; inc/dec don't modify carry; only shifts and adds do
.9dd9	d0 f5		bne $9dd0			bne 	_M88Loop
.9ddb	85 37		sta $37				sta 	zTemp0+1 					; store high 8 bits.
.9ddd	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/utility.asm

.9dde					NSMNegate:
.9dde	b5 50		lda $50,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.9de0	49 80		eor #$80			eor 	#NSBIsNegative  			; toggle the negative flag
.9de2	95 50		sta $50,x			sta 	NSStatus,x
.9de4	60		rts				rts
.9de5					NSMNegateMantissa:
.9de5	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.9de6	a9 00		lda #$00			lda 	#0
.9de8	f5 58		sbc $58,x			sbc 	NSMantissa0,x
.9dea	95 58		sta $58,x			sta 	NSMantissa0,x
.9dec	a9 00		lda #$00			lda 	#0
.9dee	f5 60		sbc $60,x			sbc 	NSMantissa1,x
.9df0	95 60		sta $60,x			sta 	NSMantissa1,x
.9df2	a9 00		lda #$00			lda 	#0
.9df4	f5 68		sbc $68,x			sbc 	NSMantissa2,x
.9df6	95 68		sta $68,x			sta 	NSMantissa2,x
.9df8	a9 00		lda #$00			lda 	#0
.9dfa	f5 70		sbc $70,x			sbc 	NSMantissa3,x
.9dfc	95 70		sta $70,x			sta 	NSMantissa3,x
.9dfe	60		rts				rts
.9dff					NSMShiftUpTwo:
.9dff	b5 58		lda $58,x			lda 	NSMantissa0,x
.9e01	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9e03	b5 60		lda $60,x			lda 	NSMantissa1,x
.9e05	95 62		sta $62,x			sta 	NSMantissa1+2,x
.9e07	b5 68		lda $68,x			lda 	NSMantissa2,x
.9e09	95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.9e0b	b5 70		lda $70,x			lda 	NSMantissa3,x
.9e0d	95 72		sta $72,x			sta 	NSMantissa3+2,x
.9e0f	b5 78		lda $78,x			lda 	NSExponent,x
.9e11	95 7a		sta $7a,x			sta 	NSExponent+2,x
.9e13	b5 50		lda $50,x			lda 	NSStatus,x
.9e15	95 52		sta $52,x			sta 	NSStatus+2,x
.9e17	60		rts				rts
.9e18					NSMSetZeroMantissaOnly:
.9e18	a9 00		lda #$00			lda 	#0
.9e1a	80 06		bra $9e22			bra 	NSMSetMantissa
.9e1c					NSMSetZero:
.9e1c	a9 00		lda #$00			lda 	#0
.9e1e					NSMSetByte:
.9e1e	74 78		stz $78,x			stz 	NSExponent,x 				; zero exponent, as integer.
.9e20	74 50		stz $50,x			stz 	NSStatus,x 					; status zero (integer)
.9e22					NSMSetMantissa:
.9e22	95 58		sta $58,x			sta 	NSMantissa0,x 				; mantissa
.9e24	74 60		stz $60,x			stz 	NSMantissa1,x
.9e26	74 68		stz $68,x			stz 	NSMantissa2,x
.9e28	74 70		stz $70,x			stz 	NSMantissa3,x
.9e2a	60		rts				rts
.9e2b					NSMShiftLeft:
.9e2b	18		clc				clc
.9e2c					NSMRotateLeft:
.9e2c	36 58		rol $58,x			rol 	NSMantissa0,x
.9e2e	36 60		rol $60,x			rol		NSMantissa1,x
.9e30	36 68		rol $68,x			rol		NSMantissa2,x
.9e32	36 70		rol $70,x			rol		NSMantissa3,x
.9e34	60		rts				rts
.9e35					NSMShiftRight:
.9e35	56 70		lsr $70,x			lsr 	NSMantissa3,x
.9e37	76 68		ror $68,x			ror		NSMantissa2,x
.9e39	76 60		ror $60,x			ror		NSMantissa1,x
.9e3b	76 58		ror $58,x			ror		NSMantissa0,x
.9e3d	60		rts				rts
.9e3e					NSMIsZero:
.9e3e	b5 70		lda $70,x			lda 	NSMantissa3,x
.9e40	15 68		ora $68,x			ora		NSMantissa2,x
.9e42	15 60		ora $60,x			ora		NSMantissa1,x
.9e44	15 58		ora $58,x			ora		NSMantissa0,x
.9e46	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.asm

.9e47					TickHandler:
.9e47	5a		phy				phy 								; need to preserve Y
.9e48	20 1b 80	jsr $801b			jsr 	SNDUpdate 					; update sound
.9e4b	7a		ply				ply
.9e4c	60		rts				rts
.05af					LastTick:
>05af							.fill 		1

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/asmcore.asm

.9e4d					Assemble_ora:
.9e4d	20 71 80	jsr $8071		jsr	AssembleGroup1
>9e50	01					.byte $01
.9e51					Assemble_and:
.9e51	20 71 80	jsr $8071		jsr	AssembleGroup1
>9e54	21					.byte $21
.9e55					Assemble_eor:
.9e55	20 71 80	jsr $8071		jsr	AssembleGroup1
>9e58	41					.byte $41
.9e59					Assemble_adc:
.9e59	20 71 80	jsr $8071		jsr	AssembleGroup1
>9e5c	61					.byte $61
.9e5d					Assemble_sta:
.9e5d	20 71 80	jsr $8071		jsr	AssembleGroup1
>9e60	81					.byte $81
.9e61					Assemble_lda:
.9e61	20 71 80	jsr $8071		jsr	AssembleGroup1
>9e64	a1					.byte $a1
.9e65					Assemble_cmp:
.9e65	20 71 80	jsr $8071		jsr	AssembleGroup1
>9e68	c1					.byte $c1
.9e69					Assemble_sbc:
.9e69	20 71 80	jsr $8071		jsr	AssembleGroup1
>9e6c	e1					.byte $e1
.9e6d					Assemble_asl:
.9e6d	20 78 80	jsr $8078		jsr	AssembleGroup2
>9e70	02					.byte $02
>9e71	75					.byte $75
.9e72					Assemble_rol:
.9e72	20 78 80	jsr $8078		jsr	AssembleGroup2
>9e75	22					.byte $22
>9e76	75					.byte $75
.9e77					Assemble_lsr:
.9e77	20 78 80	jsr $8078		jsr	AssembleGroup2
>9e7a	42					.byte $42
>9e7b	75					.byte $75
.9e7c					Assemble_ror:
.9e7c	20 78 80	jsr $8078		jsr	AssembleGroup2
>9e7f	62					.byte $62
>9e80	75					.byte $75
.9e81					Assemble_stx:
.9e81	20 78 80	jsr $8078		jsr	AssembleGroup2
>9e84	82					.byte $82
>9e85	50					.byte $50
.9e86					Assemble_ldx:
.9e86	20 78 80	jsr $8078		jsr	AssembleGroup2
>9e89	a2					.byte $a2
>9e8a	d0					.byte $d0
.9e8b					Assemble_dec:
.9e8b	20 78 80	jsr $8078		jsr	AssembleGroup2
>9e8e	c2					.byte $c2
>9e8f	55					.byte $55
.9e90					Assemble_inc:
.9e90	20 78 80	jsr $8078		jsr	AssembleGroup2
>9e93	e2					.byte $e2
>9e94	55					.byte $55
.9e95					Assemble_stz:
.9e95	20 78 80	jsr $8078		jsr	AssembleGroup2
>9e98	60					.byte $60
>9e99	44					.byte $44
.9e9a					Assemble_bit:
.9e9a	20 78 80	jsr $8078		jsr	AssembleGroup2
>9e9d	20					.byte $20
>9e9e	55					.byte $55
.9e9f					Assemble_sty:
.9e9f	20 78 80	jsr $8078		jsr	AssembleGroup2
>9ea2	80					.byte $80
>9ea3	54					.byte $54
.9ea4					Assemble_ldy:
.9ea4	20 78 80	jsr $8078		jsr	AssembleGroup2
>9ea7	a0					.byte $a0
>9ea8	d5					.byte $d5
.9ea9					Assemble_cpy:
.9ea9	20 78 80	jsr $8078		jsr	AssembleGroup2
>9eac	c0					.byte $c0
>9ead	d4					.byte $d4
.9eae					Assemble_cpx:
.9eae	20 78 80	jsr $8078		jsr	AssembleGroup2
>9eb1	e0					.byte $e0
>9eb2	d0					.byte $d0
.9eb3					Assemble_tsb:
.9eb3	20 78 80	jsr $8078		jsr	AssembleGroup2
>9eb6	00					.byte $00
>9eb7	50					.byte $50
.9eb8					Assemble_trb:
.9eb8	20 78 80	jsr $8078		jsr	AssembleGroup2
>9ebb	10					.byte $10
>9ebc	50					.byte $50
.9ebd					Assemble_jsr:
.9ebd	20 78 80	jsr $8078		jsr	AssembleGroup2
>9ec0	14					.byte $14
>9ec1	10					.byte $10
.9ec2					Assemble_jmp:
.9ec2	20 78 80	jsr $8078		jsr	AssembleGroup2
>9ec5	40					.byte $40
>9ec6	10					.byte $10
.9ec7					Assemble_bpl:
.9ec7	20 c9 80	jsr $80c9		jsr	AssembleGroup3
>9eca	10					.byte $10
.9ecb					Assemble_bmi:
.9ecb	20 c9 80	jsr $80c9		jsr	AssembleGroup3
>9ece	30					.byte $30
.9ecf					Assemble_bvc:
.9ecf	20 c9 80	jsr $80c9		jsr	AssembleGroup3
>9ed2	50					.byte $50
.9ed3					Assemble_bvs:
.9ed3	20 c9 80	jsr $80c9		jsr	AssembleGroup3
>9ed6	70					.byte $70
.9ed7					Assemble_bcc:
.9ed7	20 c9 80	jsr $80c9		jsr	AssembleGroup3
>9eda	90					.byte $90
.9edb					Assemble_bcs:
.9edb	20 c9 80	jsr $80c9		jsr	AssembleGroup3
>9ede	b0					.byte $b0
.9edf					Assemble_bne:
.9edf	20 c9 80	jsr $80c9		jsr	AssembleGroup3
>9ee2	d0					.byte $d0
.9ee3					Assemble_beq:
.9ee3	20 c9 80	jsr $80c9		jsr	AssembleGroup3
>9ee6	f0					.byte $f0
.9ee7					Assemble_bra:
.9ee7	20 c9 80	jsr $80c9		jsr	AssembleGroup3
>9eea	80					.byte $80
.9eeb					Assemble_brk:
.9eeb	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9eee	00					.byte $00
.9eef					Assemble_php:
.9eef	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9ef2	08					.byte $08
.9ef3					Assemble_clc:
.9ef3	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9ef6	18					.byte $18
.9ef7					Assemble_plp:
.9ef7	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9efa	28					.byte $28
.9efb					Assemble_sec:
.9efb	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9efe	38					.byte $38
.9eff					Assemble_rti:
.9eff	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9f02	40					.byte $40
.9f03					Assemble_pha:
.9f03	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9f06	48					.byte $48
.9f07					Assemble_cli:
.9f07	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9f0a	58					.byte $58
.9f0b					Assemble_phy:
.9f0b	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9f0e	5a					.byte $5a
.9f0f					Assemble_rts:
.9f0f	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9f12	60					.byte $60
.9f13					Assemble_pla:
.9f13	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9f16	68					.byte $68
.9f17					Assemble_sei:
.9f17	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9f1a	78					.byte $78
.9f1b					Assemble_ply:
.9f1b	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9f1e	7a					.byte $7a
.9f1f					Assemble_dey:
.9f1f	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9f22	88					.byte $88
.9f23					Assemble_txa:
.9f23	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9f26	8a					.byte $8a
.9f27					Assemble_tya:
.9f27	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9f2a	98					.byte $98
.9f2b					Assemble_txs:
.9f2b	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9f2e	9a					.byte $9a
.9f2f					Assemble_tay:
.9f2f	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9f32	a8					.byte $a8
.9f33					Assemble_tax:
.9f33	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9f36	aa					.byte $aa
.9f37					Assemble_clv:
.9f37	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9f3a	b8					.byte $b8
.9f3b					Assemble_tsx:
.9f3b	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9f3e	ba					.byte $ba
.9f3f					Assemble_iny:
.9f3f	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9f42	c8					.byte $c8
.9f43					Assemble_dex:
.9f43	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9f46	ca					.byte $ca
.9f47					Assemble_cld:
.9f47	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9f4a	d8					.byte $d8
.9f4b					Assemble_phx:
.9f4b	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9f4e	da					.byte $da
.9f4f					Assemble_stp:
.9f4f	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9f52	db					.byte $db
.9f53					Assemble_inx:
.9f53	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9f56	e8					.byte $e8
.9f57					Assemble_nop:
.9f57	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9f5a	ea					.byte $ea
.9f5b					Assemble_sed:
.9f5b	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9f5e	f8					.byte $f8
.9f5f					Assemble_plx:
.9f5f	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9f62	fa					.byte $fa

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/constants.asm

.9f63					DecimalScalarTable:
>9f63	66 66 66 66				.dword $66666666 ; 0.1
>9f67	de					.byte $de
>9f68	1f 85 eb 51				.dword $51eb851f ; 0.01
>9f6c	db					.byte $db
>9f6d	4c 37 89 41				.dword $4189374c ; 0.001
>9f71	d8					.byte $d8
>9f72	ac 8b db 68				.dword $68db8bac ; 0.0001
>9f76	d4					.byte $d4
>9f77	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>9f7b	d1					.byte $d1
>9f7c	83 de 1b 43				.dword $431bde83 ; 1e-06
>9f80	ce					.byte $ce
>9f81	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>9f85	ca					.byte $ca
>9f86	89 3b e6 55				.dword $55e63b89 ; 1e-08
>9f8a	c7					.byte $c7
>9f8b	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>9f8f	c4					.byte $c4
>9f90	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>9f94	c0					.byte $c0
>9f95	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>9f99	bd					.byte $bd

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.asm

.9f9a					SyntaxError:
.9f9a	a9 02		lda #$02		lda	#2
.9f9c	4c fa 8e	jmp $8efa		jmp	ErrorHandler
.9f9f					RangeError:
.9f9f	a9 04		lda #$04		lda	#4
.9fa1	4c fa 8e	jmp $8efa		jmp	ErrorHandler
.9fa4					TypeError:
.9fa4	a9 05		lda #$05		lda	#5
.9fa6	4c fa 8e	jmp $8efa		jmp	ErrorHandler
.9fa9					ArgumentError:
.9fa9	a9 07		lda #$07		lda	#7
.9fab	4c fa 8e	jmp $8efa		jmp	ErrorHandler
.9fae					NotDoneError:
.9fae	a9 0c		lda #$0c		lda	#12
.9fb0	4c fa 8e	jmp $8efa		jmp	ErrorHandler
.9fb3					ErrorText:
>9fb3	42 72 65 61 6b 00			.text	"Break",0
>9fb9	53 79 6e 74 61 78 20 65			.text	"Syntax error",0
>9fc1	72 72 6f 72 00
>9fc6	44 69 76 69 73 69 6f 6e			.text	"Division by zero",0
>9fce	20 62 79 20 7a 65 72 6f 00
>9fd7	4f 75 74 20 6f 66 20 52			.text	"Out of Range",0
>9fdf	61 6e 67 65 00
>9fe4	54 79 70 65 20 6d 69 73			.text	"Type mismatch",0
>9fec	6d 61 74 63 68 00
>9ff2	4f 75 74 20 6f 66 20 6d			.text	"Out of memory",0
>9ffa	65 6d 6f 72 79 00
>a000	49 6c 6c 65 67 61 6c 20			.text	"Illegal argument",0
>a008	61 72 67 75 6d 65 6e 74 00
>a011	53 74 6f 70 00				.text	"Stop",0
>a016	53 74 72 69 6e 67 20 74			.text	"String too long",0
>a01e	6f 6f 20 6c 6f 6e 67 00
>a026	41 73 73 65 72 74 69 6f			.text	"Assertion failed",0
>a02e	6e 20 66 61 69 6c 65 64 00
>a037	4f 75 74 20 6f 66 20 64			.text	"Out of data",0
>a03f	61 74 61 00
>a043	55 6e 69 6d 70 6c 65 6d			.text	"Unimplemented",0
>a04b	65 6e 74 65 64 00
>a051	4e 6f 20 73 75 63 68 20			.text	"No such line number",0
>a059	6c 69 6e 65 20 6e 75 6d 62 65 72 00
>a065	52 65 74 75 72 6e 20 77			.text	"Return without Gosub",0
>a06d	69 74 68 6f 75 74 20 47 6f 73 75 62 00
>a07a	55 6e 74 69 6c 20 77 69			.text	"Until without Repeat",0
>a082	74 68 6f 75 74 20 52 65 70 65 61 74 00
>a08f	57 65 6e 64 20 77 69 74			.text	"Wend without While",0
>a097	68 6f 75 74 20 57 68 69 6c 65 00
>a0a2	4e 65 78 74 20 77 69 74			.text	"Next without For",0
>a0aa	68 6f 75 74 20 46 6f 72 00
>a0b3	42 41 53 49 43 20 53 74			.text	"BASIC Stack full",0
>a0bb	61 63 6b 20 66 75 6c 6c 00
>a0c4	4f 70 65 6e 20 53 74 72			.text	"Open Structure",0
>a0cc	75 63 74 75 72 65 00
>a0d3	45 6e 64 50 72 6f 63 20			.text	"EndProc without call",0
>a0db	77 69 74 68 6f 75 74 20 63 61 6c 6c 00
>a0e8	41 72 72 61 79 20 61 6c			.text	"Array already defined",0
>a0f0	72 65 61 64 79 20 64 65 66 69 6e 65 64 00
>a0fe	41 72 72 61 79 20 73 69			.text	"Array size",0
>a106	7a 65 00
>a109	42 61 64 20 61 72 72 61			.text	"Bad array index",0
>a111	79 20 69 6e 64 65 78 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/timestamp.asm

>a119	52 65 6c 65 61 73 65 20			.text "Release Alpha 9 (01-Dec-22). "
>a121	41 6c 70 68 61 20 39 20 28 30 31 2d 44 65 63 2d
>a131	32 32 29 2e 20

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcommand.asm

.a136					RectangleCommand:
.a136	a9 44		lda #$44			lda 	#GCMD_FrameRect				; frame rectangle
.a138	80 02		bra $a13c			bra 	ShapeDrawCmd
.a13a					CircleCommand:
.a13a	a9 48		lda #$48			lda 	#GCMD_FrameCircle 				; framed circle
.a13c					ShapeDrawCmd:
.a13c	20 c6 a1	jsr $a1c6			jsr 	RunGraphicsCommand
.a13f					ShapeDraw:
.a13f	0d b1 05	ora $05b1			ora 	gxFillSolid  				; adjust AXY for solid fill.
.a142	4c ba a1	jmp $a1ba			jmp 	ExecuteGraphicCommand	 	; and complete
.a145					SpriteCommand:
.a145	a2 00		ldx #$00			ldx 	#0
.a147	20 b7 9d	jsr $9db7			jsr 	Evaluate8BitInteger 		; get image number.
.a14a	5a		phy				phy
.a14b	a9 0e		lda #$0e			lda 	#GCMD_SpriteUse 			; use that image.
.a14d	a6 58		ldx $58				ldx 	NSMantissa0
.a14f	e0 40		cpx #$40			cpx 	#64 						; 0-63 only
.a151	b0 0d		bcs $a160			bcs 	_SCRange
.a153	a0 ff		ldy #$ff			ldy 	#255
.a155	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a158	a9 52		lda #$52			lda 	#GCMD_SpriteMove
.a15a	7a		ply				ply
.a15b	20 c6 a1	jsr $a1c6			jsr 	RunGraphicsCommand
.a15e	80 5a		bra $a1ba			bra 	ExecuteGraphicCommand
.a160					_SCRange:
.a160	4c 9f 9f	jmp $9f9f			jmp 	RangeError
.a163					ImageCommand:
.a163	a2 00		ldx #$00			ldx 	#0
.a165	20 b7 9d	jsr $9db7			jsr 	Evaluate8BitInteger 		; get image number.
.a168	20 c6 a1	jsr $a1c6			jsr 	RunGraphicsCommand
.a16b					ImageRunDraw:
.a16b	09 40		ora #$40			ora 	#GCMD_Move					; move cursor
.a16d	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a170	ad b7 05	lda $05b7			lda 	gxDrawScale
.a173	0a		asl a				asl 	a
.a174	0a		asl a				asl 	a
.a175	0a		asl a				asl 	a
.a176	a8		tay				tay
.a177	a9 0c		lda #$0c			lda 	#GCMD_DrawSprite 			; image drawing
.a179	a6 58		ldx $58				ldx 	NSMantissa0
.a17b	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a17e	60		rts				rts
.a17f					TextCommand:
.a17f	a2 00		ldx #$00			ldx 	#0
.a181	20 74 9d	jsr $9d74			jsr 	EvaluateString 				; get text
.a184	20 c6 a1	jsr $a1c6			jsr 	RunGraphicsCommand
.a187					TextRunDraw:
.a187	09 40		ora #$40			ora 	#GCMD_Move 					; move cursor
.a189	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a18c	a0 00		ldy #$00			ldy 	#0
.a18e					_IRDLoop:
.a18e	a5 60		lda $60				lda 	NSMantissa1 				; access character
.a190	85 37		sta $37				sta 	zTemp0+1
.a192	a5 58		lda $58				lda 	NSMantissa0
.a194	85 36		sta $36				sta 	zTemp0
.a196	b1 36		lda ($36),y			lda 	(zTemp0),y
.a198	f0 13		beq $a1ad			beq 	_IRDExit
.a19a	5a		phy				phy									; save string pos
.a19b	48		pha				pha 								; save char
.a19c	ad b7 05	lda $05b7			lda 	gxDrawScale 				; get scale
.a19f	0a		asl a				asl 	a
.a1a0	0a		asl a				asl 	a
.a1a1	0a		asl a				asl 	a
.a1a2	a8		tay				tay
.a1a3	a9 0a		lda #$0a			lda 	#GCMD_DrawFont 				; char drawing
.a1a5	fa		plx				plx 								; char to draw
.a1a6	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a1a9	7a		ply				ply 								; restore string pos
.a1aa	c8		iny				iny
.a1ab	90 e1		bcc $a18e			bcc 	_IRDLoop 					; go back if no error.
.a1ad					_IRDExit:
.a1ad	60		rts				rts
.a1ae					PlotCommand:
.a1ae	a9 50		lda #$50			lda 	#GCMD_Plot 					; command ID to use
.a1b0	20 c6 a1	jsr $a1c6			jsr 	RunGraphicsCommand
.a1b3	80 05		bra $a1ba			bra 	ExecuteGraphicCommand
.a1b5					LineCommand:
.a1b5	a9 42		lda #$42			lda 	#GCMD_Line 						; command ID to use
.a1b7	20 c6 a1	jsr $a1c6			jsr 	RunGraphicsCommand
.a1ba					ExecuteGraphicCommand:
.a1ba	0d b0 05	ora $05b0			ora 	gxCommandID 				; make a full command
.a1bd	20 15 80	jsr $8015			jsr 	GXGraphicDraw 				; draw it and exit
.a1c0	b0 01		bcs $a1c3			bcs 	_EGCError
.a1c2	60		rts				rts
.a1c3					_EGCError:
.a1c3	4c 9a 9f	jmp $9f9a			jmp 	SyntaxError
.a1c6					RunGraphicsCommand:
.a1c6	8d b0 05	sta $05b0			sta 	gxCommandID					; save TODO graphics command.
.a1c9	68		pla				pla 								; pop handler address
.a1ca	fa		plx				plx
.a1cb	1a		inc a				inc 	a
.a1cc	d0 01		bne $a1cf			bne 	_RGINoCarry
.a1ce	e8		inx				inx
.a1cf					_RGINoCarry:
.a1cf	8d b5 05	sta $05b5			sta 	GXHandler
.a1d2	8e b6 05	stx $05b6			stx 	GXHandler+1
.a1d5					_RGICommandLoop:
.a1d5	b1 30		lda ($30),y			lda 	(codePtr),y
.a1d7	c8		iny				iny
.a1d8	c9 d2		cmp #$d2			cmp 	#KWD_TO						; is it TO x,y
.a1da	f0 53		beq $a22f			beq 	_RGI_To
.a1dc	c9 bd		cmp #$bd			cmp 	#KWD_HERE 					; do it here.
.a1de	f0 55		beq $a235			beq 	_RGI_Here
.a1e0	c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL or : , exit
.a1e2	f0 3d		beq $a221			beq 	_RGI_Exit
.a1e4	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.a1e6	f0 39		beq $a221			beq 	_RGI_Exit
.a1e8	c9 c5		cmp #$c5			cmp 	#KWD_OUTLINE 				; solid or outline
.a1ea	f0 3e		beq $a22a			beq 	_RGI_Frame
.a1ec	c9 ce		cmp #$ce			cmp 	#KWD_SOLID
.a1ee	f0 33		beq $a223			beq 	_RGI_Solid
.a1f0	c9 ad		cmp #$ad			cmp 	#KWD_BY 					; by offset
.a1f2	f0 4b		beq $a23f			beq 	_RGI_By
.a1f4	c9 b9		cmp #$b9			cmp 	#KWD_FROM 					; from
.a1f6	f0 17		beq $a20f			beq 	_RGI_Move2
.a1f8	c9 b5		cmp #$b5			cmp 	#KWD_DIM 					; dim (set scale)
.a1fa	f0 62		beq $a25e			beq 	_RGI_Dim
.a1fc	c9 b3		cmp #$b3			cmp 	#KWD_COLOUR 				; colour or Color
.a1fe	f0 74		beq $a274			beq 	_RGI_Colour
.a200	c9 b2		cmp #$b2			cmp 	#KWD_COLOR
.a202	f0 70		beq $a274			beq 	_RGI_Colour
.a204	ae b0 05	ldx $05b0			ldx 	gxCommandID
.a207	e0 52		cpx #$52			cpx 	#GCMD_SpriteMove 			; if not sprite
.a209	d0 03		bne $a20e			bne 	_RGI_Move 					; move
.a20b	4c 9c a2	jmp $a29c			jmp		_RGI_SpriteInstructions
.a20e					_RGI_Move:
.a20e	88		dey				dey 								; unpick get.
.a20f					_RGI_Move2:
.a20f	20 c2 a2	jsr $a2c2			jsr 	GCGetCoordinatePair 		; move to here
.a212	20 e9 a2	jsr $a2e9			jsr 	GCCopyPairToStore 			; save
.a215	5a		phy				phy
.a216	20 df a2	jsr $a2df			jsr 	GCLoadAXY 					; load in
.a219	09 40		ora #$40			ora 	#GCMD_Move 					; move there
.a21b	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a21e	7a		ply				ply
.a21f	80 b4		bra $a1d5			bra 	_RGICommandLoop 			; and go round
.a221					_RGI_Exit:
.a221	88		dey				dey 								; unpick : / EOL
.a222	60		rts				rts
.a223					_RGI_Solid:
.a223	a9 02		lda #$02			lda 	#2
.a225	8d b1 05	sta $05b1			sta 	gxFillSolid
.a228	80 ab		bra $a1d5			bra 	_RGICommandLoop
.a22a					_RGI_Frame:
.a22a	9c b1 05	stz $05b1			stz 	gxFillSolid
.a22d	80 a6		bra $a1d5			bra 	_RGICommandLoop
.a22f					_RGI_To:
.a22f	20 c2 a2	jsr $a2c2			jsr 	GCGetCoordinatePair 		; get coordinate pair into slot #1,#2
.a232	20 e9 a2	jsr $a2e9			jsr 	GCCopyPairToStore
.a235					_RGI_Here:
.a235	5a		phy				phy
.a236	20 df a2	jsr $a2df			jsr 	GCLoadAXY 					; load it into AXY
.a239	20 99 a2	jsr $a299			jsr 	_RGICallHandler 			; go do whatever it is.
.a23c	7a		ply				ply
.a23d	80 96		bra $a1d5			bra 	_RGICommandLoop 			; and go round
.a23f					_RGI_By:
.a23f	20 cf a2	jsr $a2cf			jsr 	GCSignedCoordinatePair 		; get coordinate pair into slot #1,#2
.a242	18		clc				clc
.a243	a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.a245	6d b2 05	adc $05b2			adc 	gxxPos
.a248	8d b2 05	sta $05b2			sta 	gxXPos
.a24b	a5 61		lda $61				lda 	NSMantissa1+1
.a24d	6d b3 05	adc $05b3			adc 	gxxPos+1
.a250	8d b3 05	sta $05b3			sta 	gxXPos+1
.a253	a5 5a		lda $5a				lda 	NSMantissa0+2
.a255	18		clc				clc
.a256	6d b4 05	adc $05b4			adc 	gxYPos
.a259	8d b4 05	sta $05b4			sta 	gxYPos
.a25c	80 d7		bra $a235			bra 	_RGI_Here
.a25e					_RGI_Dim:
.a25e	a2 01		ldx #$01			ldx	 	#1
.a260	20 b7 9d	jsr $9db7			jsr 	Evaluate8BitInteger
.a263	a5 59		lda $59				lda 	NSMantissa0+1
.a265	c9 00		cmp #$00			cmp 	#0
.a267	f0 2d		beq $a296			beq 	_RGIRange
.a269	c9 09		cmp #$09			cmp 	#8+1
.a26b	b0 29		bcs $a296			bcs		_RGIRange
.a26d	3a		dec a				dec 	a
.a26e	8d b7 05	sta $05b7			sta 	gxDrawScale
.a271	4c d5 a1	jmp $a1d5			jmp 	_RGICommandLoop
.a274					_RGI_Colour:
.a274	a2 01		ldx #$01			ldx 	#1 							; colour
.a276	20 b7 9d	jsr $9db7			jsr 	Evaluate8BitInteger
.a279	a2 02		ldx #$02			ldx 	#2 							; default zero for 2nd parameter
.a27b	20 1c 9e	jsr $9e1c			jsr 	NSMSetZero
.a27e	b1 30		lda ($30),y			lda 	(codePtr),y
.a280	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; check , => mode.
.a282	d0 04		bne $a288			bne 	_RGICDefaultMode
.a284	c8		iny				iny
.a285	20 b7 9d	jsr $9db7			jsr 	Evaluate8BitInteger
.a288					_RGICDefaultMode:
.a288	5a		phy				phy
.a289	a9 08		lda #$08			lda 	#GCMD_Colour 				; set colour.
.a28b	a6 59		ldx $59				ldx 	NSMantissa0+1
.a28d	a4 5a		ldy $5a				ldy 	NSMantissa0+2
.a28f	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a292	7a		ply				ply
.a293	4c d5 a1	jmp $a1d5			jmp 	_RGICommandLoop 			; and go round
.a296					_RGIRange:
.a296	4c 9f 9f	jmp $9f9f			jmp 	RangeError
.a299					_RGICallHandler:
.a299	6c b5 05	jmp ($05b5)			jmp 	(GXHandler)
.a29c					_RGI_SpriteInstructions:
.a29c	c9 c3		cmp #$c3			cmp 	#KWD_OFF
.a29e	f0 07		beq $a2a7			beq 	_RGISpriteOff
.a2a0	c9 be		cmp #$be			cmp 	#KWD_IMAGE
.a2a2	f0 13		beq $a2b7			beq 	_RGISetImage
.a2a4	4c 0e a2	jmp $a20e			jmp 	_RGI_Move
.a2a7					_RGISpriteOff:
.a2a7	5a		phy				phy
.a2a8	a0 01		ldy #$01			ldy 	#1
.a2aa	a2 00		ldx #$00			ldx 	#0
.a2ac					_RGIDoCommandLoop:
.a2ac	a9 10		lda #$10			lda 	#GCMD_SpriteImage
.a2ae	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a2b1	7a		ply				ply
.a2b2	b0 e2		bcs $a296			bcs 	_RGIRange
.a2b4	4c d5 a1	jmp $a1d5			jmp 	_RGICommandLoop
.a2b7					_RGISetImage:
.a2b7	a2 01		ldx #$01			ldx 	#1
.a2b9	20 b7 9d	jsr $9db7			jsr 	Evaluate8BitInteger
.a2bc	5a		phy				phy
.a2bd	aa		tax				tax
.a2be	a0 00		ldy #$00			ldy 	#0
.a2c0	80 ea		bra $a2ac			bra 	_RGIDoCommandLoop
.a2c2					GCGetCoordinatePair:
.a2c2	a2 01		ldx #$01			ldx 	#1
.a2c4	20 9c 9d	jsr $9d9c			jsr 	Evaluate16BitInteger
.a2c7	20 e9 8e	jsr $8ee9			jsr 	CheckComma
.a2ca	e8		inx				inx
.a2cb	20 9c 9d	jsr $9d9c			jsr 	Evaluate16BitInteger
.a2ce	60		rts				rts
.a2cf					GCSignedCoordinatePair:
.a2cf	a2 01		ldx #$01			ldx 	#1
.a2d1	20 a6 9d	jsr $9da6			jsr 	Evaluate16BitIntegerSigned
.a2d4	20 e9 8e	jsr $8ee9			jsr 	CheckComma
.a2d7	e8		inx				inx
.a2d8	20 a6 9d	jsr $9da6			jsr 	Evaluate16BitIntegerSigned
.a2db	60		rts				rts
.a2dc					_GCCPRange:
.a2dc	4c 9f 9f	jmp $9f9f			jmp 	RangeError
.a2df					GCLoadAXY:
.a2df	ad b3 05	lda $05b3			lda 	gxXPos+1
.a2e2	ae b2 05	ldx $05b2			ldx 	gxXPos
.a2e5	ac b4 05	ldy $05b4			ldy 	gxYPos
.a2e8	60		rts				rts
.a2e9					GCCopyPairToStore:
.a2e9	a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.a2eb	8d b2 05	sta $05b2			sta 	gxXPos
.a2ee	a5 61		lda $61				lda 	NSMantissa1+1
.a2f0	8d b3 05	sta $05b3			sta 	gxXPos+1
.a2f3	a5 5a		lda $5a				lda 	NSMantissa0+2
.a2f5	8d b4 05	sta $05b4			sta 	gxYPos
.a2f8	60		rts				rts
.05b0					gxCommandID:
>05b0							.fill 	1
.05b1					gxFillSolid:
>05b1							.fill 	1
.05b2					gxXPos:
>05b2							.fill 	2
.05b4					gxYPos:
>05b4							.fill 	1
.05b5					gxHandler:
>05b5							.fill 	2
.05b7					gxDrawScale:
>05b7							.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcontrol.asm

.a2f9					BitmapCtrl:
.a2f9	b1 30		lda ($30),y			lda 	(codePtr),y
.a2fb	c8		iny				iny
.a2fc	a2 01		ldx #$01			ldx 	#1
.a2fe	c9 c4		cmp #$c4			cmp 	#KWD_ON
.a300	f0 11		beq $a313			beq 	BitmapSwitch
.a302	ca		dex				dex
.a303	c9 c3		cmp #$c3			cmp 	#KWD_OFF
.a305	f0 0c		beq $a313			beq 	BitmapSwitch
.a307	20 b7 9d	jsr $9db7			jsr 	Evaluate8BitInteger 		; get the colour
.a30a	5a		phy				phy
.a30b	aa		tax				tax
.a30c	a9 06		lda #$06			lda 	#GCMD_Clear					; clear to that colour
.a30e	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a311	7a		ply				ply
.a312	60		rts				rts
.a313					BitmapSwitch:
.a313	5a		phy				phy
.a314	a0 00		ldy #$00			ldy 	#0 							; gfx 1,on/off,0
.a316	a9 02		lda #$02			lda 	#GCMD_BitmapCtl
.a318	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a31b	a9 08		lda #$08			lda 	#GCMD_Colour				; set colour to $FF
.a31d	a0 00		ldy #$00			ldy 	#0
.a31f	a2 ff		ldx #$ff			ldx 	#$FF
.a321	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a324	9c b1 05	stz $05b1			stz 	gxFillSolid
.a327	9c b2 05	stz $05b2			stz 	gxXPos
.a32a	9c b3 05	stz $05b3			stz 	gxXPos+1
.a32d	9c b4 05	stz $05b4			stz 	gxYPos
.a330	9c b7 05	stz $05b7			stz 	gxDrawScale
.a333	a9 40		lda #$40			lda 	#GCMD_Move 						; home cursor
.a335	a2 00		ldx #$00			ldx 	#0
.a337	a0 00		ldy #$00			ldy 	#0
.a339	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a33c	7a		ply				ply
.a33d	60		rts				rts
.a33e					SpritesCtrl:
.a33e	b1 30		lda ($30),y			lda 	(codePtr),y
.a340	c8		iny				iny
.a341	a2 01		ldx #$01			ldx 	#1
.a343	c9 c4		cmp #$c4			cmp 	#KWD_ON
.a345	f0 08		beq $a34f			beq 	SpriteSwitch
.a347	ca		dex				dex
.a348	c9 c3		cmp #$c3			cmp 	#KWD_OFF
.a34a	f0 03		beq $a34f			beq 	SpriteSwitch
.a34c	4c 9a 9f	jmp $9f9a			jmp 	SyntaxError
.a34f					SpriteSwitch:
.a34f	5a		phy				phy
.a350	a0 00		ldy #$00			ldy 	#0 							; gfx 2,on/off,0
.a352	a9 04		lda #$04			lda 	#GCMD_SpriteCtl
.a354	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a357	7a		ply				ply
.a358	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gfx.asm

.a359					GfxCommand:
.a359	a2 00		ldx #$00			ldx 	#0
.a35b	20 b7 9d	jsr $9db7			jsr 	Evaluate8BitInteger 		; command
.a35e	20 e9 8e	jsr $8ee9			jsr 	CheckComma
.a361	e8		inx				inx
.a362	20 9c 9d	jsr $9d9c			jsr 	Evaluate16BitInteger 		; X
.a365	20 e9 8e	jsr $8ee9			jsr 	CheckComma
.a368	e8		inx				inx
.a369	20 b7 9d	jsr $9db7			jsr 	Evaluate8BitInteger 		; Y
.a36c	a5 61		lda $61				lda 	NSMantissa1+1  				; shift bit 0 of X into CS, should now be zero
.a36e	4a		lsr a				lsr 	a
.a36f	d0 12		bne $a383			bne 	_GfxError
.a371	26 58		rol $58				rol 	NSMantissa0 				; rotate into command
.a373	b0 0e		bcs $a383			bcs 	_GfxError 					; bit 7 should have been zero
.a375	5a		phy				phy 								; save pos
.a376	a5 58		lda $58				lda 	NSMantissa0 				; do the command
.a378	a6 59		ldx $59				ldx 	NSMantissa0+1
.a37a	a4 5a		ldy $5a				ldy 	NSMantissa0+2
.a37c	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a37f	b0 02		bcs $a383			bcs 	_GfxError
.a381	7a		ply				ply 								; restore pos and exit.
.a382	60		rts				rts
.a383					_GfxError:
.a383	4c 9f 9f	jmp $9f9f			jmp 	RangeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/hit.asm

.a386					UnaryHit:
.a386	fa		plx				plx
.a387	a9 36		lda #$36			lda 	#zTemp0
.a389	20 b7 9d	jsr $9db7			jsr 	Evaluate8BitInteger 		; get sprite number 0
.a38c	20 e9 8e	jsr $8ee9			jsr 	CheckComma
.a38f	e8		inx				inx
.a390	20 b7 9d	jsr $9db7			jsr 	Evaluate8BitInteger 		; get sprite number 1
.a393	20 e1 8e	jsr $8ee1			jsr		CheckRightBracket
.a396	ca		dex				dex 								; fix back up again.
.a397	da		phx				phx 								; save X/Y
.a398	5a		phy				phy
.a399	b4 59		ldy $59,x			ldy 	NSMantissa0+1,x 			; get the sprite numbers into X/Y
.a39b	b5 58		lda $58,x			lda 	NSMantissa0,x
.a39d	aa		tax				tax
.a39e	a9 12		lda #$12			lda 	#GCMD_SpriteCollide 		; command check collision.
.a3a0	20 15 80	jsr $8015			jsr 	GXGraphicDraw 				; calculate result
.a3a3	1a		inc a				inc 	a 							; so 255 (fail) -> 0, otherwise 1,2,3,4 pixels etc.
.a3a4	7a		ply				ply 								; restore XY
.a3a5	fa		plx				plx
.a3a6	20 1e 9e	jsr $9e1e			jsr 	NSMSetByte 					; return the hit result
.a3a9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/palette.asm

.a3aa					PaletteCommand:
.a3aa	a2 00		ldx #$00			ldx 	#0
.a3ac	20 b7 9d	jsr $9db7			jsr 	Evaluate8BitInteger 		; colour
.a3af	20 e9 8e	jsr $8ee9			jsr 	CheckComma
.a3b2	e8		inx				inx
.a3b3	20 9c 9d	jsr $9d9c			jsr 	Evaluate16BitInteger 		; r
.a3b6	20 e9 8e	jsr $8ee9			jsr 	CheckComma
.a3b9	e8		inx				inx
.a3ba	20 b7 9d	jsr $9db7			jsr 	Evaluate8BitInteger 		; g
.a3bd	20 e9 8e	jsr $8ee9			jsr 	CheckComma
.a3c0	e8		inx				inx
.a3c1	20 b7 9d	jsr $9db7			jsr 	Evaluate8BitInteger 		; b
.a3c4	a5 58		lda $58				lda 	NSMantissa0 				; get colour #
.a3c6	85 36		sta $36				sta 	zTemp0
.a3c8	a9 34		lda #$34			lda 	#$D0 >> 2 					; MSB = D0/4
.a3ca	85 37		sta $37				sta 	zTemp0+1
.a3cc	06 36		asl $36				asl 	zTemp0 						; zTemp = $D000+Colour x 4
.a3ce	26 37		rol $37				rol	 	zTemp0+1
.a3d0	06 36		asl $36				asl 	zTemp0
.a3d2	26 37		rol $37				rol	 	zTemp0+1
.a3d4	a9 01		lda #$01			lda 	#1 							; I/O Page 2
.a3d6	85 01		sta $01				sta 	1
.a3d8	5a		phy				phy
.a3d9	a5 5b		lda $5b				lda 	NSMantissa0+3 				; fix to r,g,b
.a3db	92 36		sta ($36)			sta 	(zTemp0)
.a3dd	a0 01		ldy #$01			ldy 	#1
.a3df	a5 5a		lda $5a				lda 	NSMantissa0+2
.a3e1	91 36		sta ($36),y			sta 	(zTemp0),y
.a3e3	a5 59		lda $59				lda 	NSMantissa0+1
.a3e5	c8		iny				iny
.a3e6	91 36		sta ($36),y			sta 	(zTemp0),y
.a3e8	7a		ply				ply
.a3e9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/event.asm

.a3ea					UnaryEvent:
.a3ea	fa		plx				plx
.a3eb	20 98 a4	jsr $a498			jsr 	TimerToStackX 				; timer in +0
.a3ee	e8		inx				inx  								; put reference into +1
.a3ef	20 48 98	jsr $9848			jsr 	EvaluateTerm
.a3f2	b5 50		lda $50,x			lda 	NSStatus,x 					; check if is integer reference
.a3f4	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.a3f6	d0 4c		bne $a444			bne 	_UEType
.a3f8	e8		inx				inx 								; put the step in +2
.a3f9	20 e9 8e	jsr $8ee9			jsr 	CheckComma
.a3fc	20 9c 9d	jsr $9d9c			jsr 	Evaluate16BitInteger
.a3ff	20 e1 8e	jsr $8ee1			jsr 	CheckRightBracket
.a402	ca		dex				dex
.a403	ca		dex				dex
.a404	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy reference to zTemp0
.a406	85 36		sta $36				sta 	zTemp0
.a408	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.a40a	85 37		sta $37				sta 	zTemp0+1
.a40c	5a		phy				phy
.a40d	a0 03		ldy #$03			ldy 	#3 							; check bit 7 of last bit, the packed sign bit
.a40f	b1 36		lda ($36),y			lda 	(zTemp0),y
.a411	30 2d		bmi $a440			bmi 	_UEFalse 					; exit if signed.
.a413	a0 00		ldy #$00			ldy 	#0 							; has it timed out (24 bit)
.a415	b5 58		lda $58,x			lda 	NSMantissa0,x
.a417	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.a419	c8		iny				iny
.a41a	b5 60		lda $60,x			lda 	NSMantissa1,x
.a41c	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a41e	c8		iny				iny
.a41f	b5 68		lda $68,x			lda 	NSMantissa2,x
.a421	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a423	90 1b		bcc $a440			bcc 	_UEFalse 					; no, return FALSE.
.a425	18		clc				clc
.a426	a0 00		ldy #$00			ldy 	#0 							; work out new value as timer() + step
.a428	b5 58		lda $58,x			lda 	NSMantissa0,x
.a42a	75 5a		adc $5a,x			adc 	NSMantissa0+2,x
.a42c	91 36		sta ($36),y			sta 	(zTemp0),y
.a42e	c8		iny				iny
.a42f	b5 60		lda $60,x			lda 	NSMantissa1,x
.a431	75 62		adc $62,x			adc 	NSMantissa1+2,x
.a433	91 36		sta ($36),y			sta 	(zTemp0),y
.a435	c8		iny				iny
.a436	b5 68		lda $68,x			lda 	NSMantissa2,x
.a438	75 6a		adc $6a,x			adc 	NSMantissa2+2,x
.a43a	91 36		sta ($36),y			sta 	(zTemp0),y
.a43c	7a		ply				ply
.a43d	4c 67 8f	jmp $8f67			jmp 	ReturnTrue
.a440					_UEFalse:
.a440	7a		ply				ply 								; restore Y
.a441	4c 72 8f	jmp $8f72			jmp 	ReturnFalse 				; and return False
.a444					_UEType:
.a444	4c a4 9f	jmp $9fa4			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/joy.asm

.a447					UnaryJoyX:
.a447	18		clc				clc
.a448	80 01		bra $a44b			bra 	JoyMain
.a44a					UnaryJoyY:
.a44a	38		sec				sec
.a44b					JoyMain:
.a44b	fa		plx				plx 								; get pos
.a44c	08		php				php 								; save carry (set for Y)
.a44d	20 b7 9d	jsr $9db7			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a450	20 e1 8e	jsr $8ee1			jsr 	CheckRightBracket
.a453	20 0f 80	jsr $800f			jsr 	EXTReadController 			; read the controller.
.a456	28		plp				plp
.a457	90 02		bcc $a45b			bcc 	_JMNoShift 					; if Y then shift bits 3,2 -> 1,0
.a459	4a		lsr a				lsr 	a
.a45a	4a		lsr a				lsr 	a
.a45b					_JMNoShift:
.a45b	4a		lsr a				lsr 	a 							; if bit 0 set then right/down e.g. +1
.a45c	b0 0a		bcs $a468			bcs 	_JMIsRight
.a45e	4a		lsr a				lsr 	a 							; if bit 1 set then left/up e.g. -1
.a45f	b0 04		bcs $a465			bcs 	_JMIsLeft
.a461	20 1c 9e	jsr $9e1c			jsr 	NSMSetZero 					; zero result
.a464	60		rts				rts
.a465					_JMIsLeft:
.a465	4c 67 8f	jmp $8f67			jmp 	ReturnTrue
.a468					_JMIsRight:
.a468	a9 01		lda #$01			lda 	#1
.a46a	20 1e 9e	jsr $9e1e			jsr 	NSMSetByte
.a46d	60		rts				rts
.a46e					UnaryJoyB:
.a46e	fa		plx				plx 								; get pos
.a46f	20 b7 9d	jsr $9db7			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a472	20 e1 8e	jsr $8ee1			jsr 	CheckRightBracket
.a475	20 0f 80	jsr $800f			jsr 	EXTReadController 			; read the controller.
.a478	4a		lsr a				lsr 	a
.a479	4a		lsr a				lsr 	a
.a47a	4a		lsr a				lsr 	a
.a47b	4a		lsr a				lsr 	a
.a47c	29 01		and #$01			and 	#1
.a47e	20 1e 9e	jsr $9e1e			jsr 	NSMSetByte
.a481	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/load.asm

.a482					LoadCommand:
.a482	20 ca 89	jsr $89ca			jsr 	NewProgram
.a485	20 e0 82	jsr $82e0			jsr 	BackLoadProgram
.a488	4c 78 83	jmp $8378			jmp 	WarmStart
.a48b					GoCommand:
.a48b	20 ca 89	jsr $89ca			jsr 	NewProgram
.a48e	20 e0 82	jsr $82e0			jsr 	BackLoadProgram
.a491	4c 0b 8b	jmp $8b0b			jmp 	CommandRun

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/timer.asm

.a494					UnaryTimer:
.a494	fa		plx				plx
.a495	20 e1 8e	jsr $8ee1			jsr 	CheckRightBracket
.a498					TimerToStackX:
.a498	20 1c 9e	jsr $9e1c			jsr 	NSMSetZero 					; zero result
.a49b	64 01		stz $01				stz 	1 							; access I/O
.a49d	ad 59 d6	lda $d659			lda 	$D659 						; copy timer in
.a4a0	95 58		sta $58,x			sta 	NSMantissa0,x
.a4a2	ad 5a d6	lda $d65a			lda 	$D65A
.a4a5	95 60		sta $60,x			sta 	NSMantissa1,x
.a4a7	ad 5b d6	lda $d65b			lda 	$D65B
.a4aa	95 68		sta $68,x			sta 	NSMantissa2,x
.a4ac	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/delete.asm

.a4ad					MemoryDeleteLine:
.a4ad	20 cc a4	jsr $a4cc			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a4b0	b2 30		lda ($30)			lda 	(codePtr) 					; size to delete => y
.a4b2	a8		tay				tay
.a4b3					_MDDLLoop:
.a4b3	b1 30		lda ($30),y			lda 	(codePtr),y 				; copy down
.a4b5	92 30		sta ($30)			sta 	(codePtr)
.a4b7	a5 30		lda $30				lda 	codePtr 					; check done the lot.
.a4b9	c5 3a		cmp $3a				cmp 	zTemp2
.a4bb	d0 07		bne $a4c4			bne 	_MDLDLNext
.a4bd	a5 31		lda $31				lda 	codePtr+1
.a4bf	c5 3b		cmp $3b				cmp 	zTemp2+1
.a4c1	d0 01		bne $a4c4			bne 	_MDLDLNext
.a4c3					_MDDLExit:
.a4c3	60		rts				rts
.a4c4					_MDLDLNext:
.a4c4	e6 30		inc $30				inc 	codePtr						; next byte
.a4c6	d0 eb		bne $a4b3			bne 	_MDDLLoop
.a4c8	e6 31		inc $31				inc 	codePtr+1
.a4ca	80 e7		bra $a4b3			bra 	_MDDLLoop
.a4cc					IMemoryFindEnd:
.a4cc	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a4ce	85 3a		sta $3a				sta 	0+zTemp2
.a4d0	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a4d2	85 3b		sta $3b				sta 	1+zTemp2
.a4d4					_MDLFELoop:
.a4d4	b2 3a		lda ($3a)			lda 	(zTemp2)
.a4d6	f0 0b		beq $a4e3			beq 	_MDLFEExit
.a4d8	18		clc				clc
.a4d9	65 3a		adc $3a				adc 	zTemp2
.a4db	85 3a		sta $3a				sta 	zTemp2
.a4dd	90 f5		bcc $a4d4			bcc 	_MDLFELoop
.a4df	e6 3b		inc $3b				inc 	zTemp2+1
.a4e1	80 f1		bra $a4d4			bra 	_MDLFELoop
.a4e3					_MDLFEExit:
.a4e3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/insert.asm

.a4e4					MemoryInsertLine:
.a4e4	08		php				php
.a4e5	20 cc a4	jsr $a4cc			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a4e8	a5 3b		lda $3b				lda 	zTemp2+1 					; space ?
.a4ea	1a		inc a				inc 	a
.a4eb	c9 7f		cmp #$7f			cmp 	#(BasicEnd >> 8)-1
.a4ed	b0 36		bcs $a525			bcs 	_MDLIError
.a4ef	28		plp				plp
.a4f0	90 08		bcc $a4fa			bcc 	_MDLIFound
.a4f2	a5 3a		lda $3a				lda 	zTemp2 						; if CS on entry append.
.a4f4	85 30		sta $30				sta 	codePtr
.a4f6	a5 3b		lda $3b				lda 	zTemp2+1
.a4f8	85 31		sta $31				sta 	codePtr+1
.a4fa					_MDLIFound:
.a4fa	ad 2a 04	lda $042a			lda 	tokenOffset 				; insert gap in Y, the offset, e.g. length of the new line
.a4fd	a8		tay				tay
.a4fe					_MDLIInsert:
.a4fe	b2 3a		lda ($3a)			lda 	(zTemp2) 					; shift one byte up , at least one covers end case.
.a500	91 3a		sta ($3a),y			sta 	(zTemp2),y 					; work from top down.
.a502	a5 30		lda $30				lda 	codePtr 					; done insert point ?
.a504	c5 3a		cmp $3a				cmp 	zTemp2
.a506	d0 06		bne $a50e			bne 	_MDLINext
.a508	a5 31		lda $31				lda 	codePtr+1
.a50a	c5 3b		cmp $3b				cmp 	zTemp2+1
.a50c	f0 0a		beq $a518			beq 	_MDLIHaveSpace
.a50e					_MDLINext:
.a50e	a5 3a		lda $3a				lda 	zTemp2 						; if no, keep zTemp2 going backwards
.a510	d0 02		bne $a514			bne 	_MDLINoBorrow
.a512	c6 3b		dec $3b				dec 	zTemp2+1
.a514					_MDLINoBorrow:
.a514	c6 3a		dec $3a				dec 	zTemp2
.a516	80 e6		bra $a4fe			bra 	_MDLIInsert
.a518					_MDLIHaveSpace:
.a518	ac 2a 04	ldy $042a			ldy 	tokenOffset 				; bytes to copy
.a51b	88		dey				dey 								; from offset-1 to 0
.a51c					_MDLICopy:
.a51c	b9 2a 04	lda $042a,y			lda 	tokenOffset,y
.a51f	91 30		sta ($30),y			sta 	(codePtr),y
.a521	88		dey				dey
.a522	10 f8		bpl $a51c			bpl 	_MDLICopy
.a524	60		rts				rts
.a525					_MDLIError:
.a525	a9 06		lda #$06		lda	#6
.a527	4c fa 8e	jmp $8efa		jmp	ErrorHandler
.a52a					MDLAppendLine:
.a52a	86 37		stx $37				stx 	zTemp0+1 					; save new line at zTemp0
.a52c	85 36		sta $36				sta 	zTemp0
.a52e	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a530	85 38		sta $38				sta 	0+zTemp1
.a532	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a534	85 39		sta $39				sta 	1+zTemp1
.a536	b2 38		lda ($38)			lda 	(zTemp1)
.a538	d0 0a		bne $a544			bne 	_MDLANoInitialise
.a53a	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a53c	8d b8 05	sta $05b8			sta 	0+AppendPointer
.a53f	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a541	8d b9 05	sta $05b9			sta 	1+AppendPointer
.a544					_MDLANoInitialise:
.a544	18		clc				clc
.a545	ad b8 05	lda $05b8			lda 	AppendPointer 				; copy append pointer to zTemp1 adding the offset as you go
.a548	85 38		sta $38				sta 	zTemp1
.a54a	72 36		adc ($36)			adc 	(zTemp0)
.a54c	8d b8 05	sta $05b8			sta 	AppendPointer
.a54f	ad b9 05	lda $05b9			lda 	AppendPointer+1
.a552	85 39		sta $39				sta 	zTemp1+1
.a554	69 00		adc #$00			adc 	#0
.a556	8d b9 05	sta $05b9			sta 	AppendPointer+1
.a559	a0 00		ldy #$00			ldy 	#0
.a55b					_MDLACopy:
.a55b	b1 36		lda ($36),y			lda 	(zTemp0),y 					; copy new line in
.a55d	91 38		sta ($38),y			sta 	(zTemp1),y
.a55f	c8		iny				iny
.a560	98		tya				tya
.a561	d2 36		cmp ($36)			cmp 	(zTemp0) 					; done whole line
.a563	d0 f6		bne $a55b			bne 	_MDLACopy
.a565	a9 00		lda #$00			lda 	#0 							; end of program.
.a567	91 38		sta ($38),y			sta 	(zTemp1),y
.a569	60		rts				rts
.05b8					AppendPointer:
>05b8							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/memory.asm

.a56a					MemoryNew:
.a56a	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a56c	85 30		sta $30				sta 	codePtr
.a56e	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a570	85 31		sta $31				sta 	codePtr+1
.a572	a9 00		lda #$00			lda 	#0 							; write zero there erasing the program.
.a574	92 30		sta ($30)			sta 	(codePtr)
.a576	60		rts				rts
.a577					MemoryInline:
.a577	98		tya				tya 								; put address into stack,x
.a578	18		clc				clc  								; get the offset, add codePtr
.a579	65 30		adc $30				adc 	codePtr
.a57b	95 58		sta $58,x			sta 	NSMantissa0,x 				; store the result in the mantissa.
.a57d	a5 31		lda $31				lda 	codePtr+1
.a57f	69 00		adc #$00			adc 	#0
.a581	95 60		sta $60,x			sta 	NSMantissa1,x
.a583	74 68		stz $68,x			stz 	NSMantissa2,x
.a585	74 70		stz $70,x			stz 	NSMantissa3,x
.a587	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/search.asm

.a588					MemorySearch:
.a588	85 36		sta $36				sta 	zTemp0 						; save line number in zTemp0
.a58a	86 37		stx $37				stx 	zTemp0+1
.a58c	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a58e	85 30		sta $30				sta 	codePtr
.a590	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a592	85 31		sta $31				sta 	codePtr+1
.a594					_MTAXLoop:
.a594	b2 30		lda ($30)			lda 	(codePtr)
.a596	18		clc				clc
.a597	f0 21		beq $a5ba			beq 	_MTAXExit 					; reached end, exit with CC.
.a599	a0 01		ldy #$01			ldy 	#1 							; calculate current line# - requested line#
.a59b	b1 30		lda ($30),y			lda 	(codePtr),y
.a59d	38		sec				sec
.a59e	e5 36		sbc $36				sbc 	zTemp0
.a5a0	85 38		sta $38				sta 	zTemp1 						; save interim to set Z
.a5a2	c8		iny				iny 								; do the MSB
.a5a3	b1 30		lda ($30),y			lda 	(codePtr),y
.a5a5	e5 37		sbc $37				sbc 	zTemp0+1
.a5a7	05 38		ora $38				ora 	zTemp1 						; will set Z if result is zero, doesn't affect carry flag
.a5a9	f0 0f		beq $a5ba			beq 	_MTAXExit	 				; found so exit (CS will be set)
.a5ab	b0 0d		bcs $a5ba			bcs 	_MTAXExit 					; current < required exit
.a5ad	18		clc				clc
.a5ae	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.a5b0	65 30		adc $30				adc 	codePtr
.a5b2	85 30		sta $30				sta 	codePtr
.a5b4	90 02		bcc $a5b8			bcc 	_CREExit
.a5b6	e6 31		inc $31				inc 	codePtr+1 					; carry
.a5b8					_CREExit:
.a5b8	80 da		bra $a594			bra 	_MTAXLoop
.a5ba					_MTAXExit:
.a5ba	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/effects.asm

.a5bb					PingCommand:
.a5bb	5a		phy				phy 								; save pos
.a5bc	a9 01		lda #$01			lda 	#1 						; push channel.
.a5be	48		pha				pha
.a5bf	a9 c8		lda #$c8			lda 	#200 						; pitch LSB
.a5c1	a2 03		ldx #$03			ldx 	#3 						; length
.a5c3	a0 00		ldy #$00			ldy 	#0 						; slide LSB
.a5c5	80 24		bra $a5eb			bra 	SoundEffectCommand
.a5c7					ZapCommand:
.a5c7	5a		phy				phy 								; save pos
.a5c8	a9 01		lda #$01			lda 	#1 						; push channel.
.a5ca	48		pha				pha
.a5cb	a9 ff		lda #$ff			lda 	#255 						; pitch LSB
.a5cd	a2 05		ldx #$05			ldx 	#5 						; length
.a5cf	a0 14		ldy #$14			ldy 	#20 						; slide LSB
.a5d1	80 18		bra $a5eb			bra 	SoundEffectCommand
.a5d3					ShootCommand:
.a5d3	5a		phy				phy 								; save pos
.a5d4	a9 03		lda #$03			lda 	#3 						; push channel.
.a5d6	48		pha				pha
.a5d7	a9 20		lda #$20			lda 	#32 						; pitch LSB
.a5d9	a2 02		ldx #$02			ldx 	#2 						; length
.a5db	a0 00		ldy #$00			ldy 	#0 						; slide LSB
.a5dd	80 0c		bra $a5eb			bra 	SoundEffectCommand
.a5df					Explode:
.a5df	5a		phy				phy 								; save pos
.a5e0	a9 03		lda #$03			lda 	#3 						; push channel.
.a5e2	48		pha				pha
.a5e3	a9 50		lda #$50			lda 	#80 						; pitch LSB
.a5e5	a2 05		ldx #$05			ldx 	#5 						; length
.a5e7	a0 00		ldy #$00			ldy 	#0 						; slide LSB
.a5e9	80 00		bra $a5eb			bra 	SoundEffectCommand
.a5eb					SoundEffectCommand:
.a5eb	8d ba 05	sta $05ba			sta 	SoundCommandBlock 			; set up the command block in sound.asm
.a5ee	9c bb 05	stz $05bb			stz 	SoundCommandBlock+1
.a5f1	a9 0f		lda #$0f			lda 	#15
.a5f3	8d bc 05	sta $05bc			sta 	SoundCommandBlock+2
.a5f6	8e bd 05	stx $05bd			stx 	SoundCommandBlock+3
.a5f9	8c be 05	sty $05be			sty 	SoundCommandBlock+4
.a5fc	9c bf 05	stz $05bf			stz 	SoundCommandBlock+5
.a5ff	68		pla				pla
.a600	09 10		ora #$10			ora 	#$10  						; execute command $11
.a602	a2 ba		ldx #$ba			ldx 	#(SoundCommandBlock & $FF)
.a604	a0 05		ldy #$05			ldy 	#(SoundCommandBlock >> 8)
.a606	20 18 80	jsr $8018			jsr 	SNDCommand
.a609	7a		ply				ply
.a60a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/playing.asm

.a60b					UnaryPlaying:
.a60b	fa		plx				plx
.a60c	20 b7 9d	jsr $9db7			jsr 	Evaluate8BitInteger 		; get channel #
.a60f	48		pha				pha
.a610	20 e1 8e	jsr $8ee1			jsr		CheckRightBracket
.a613	68		pla				pla
.a614	c9 04		cmp #$04			cmp 	#4
.a616	b0 0c		bcs $a624			bcs 	_UPNotPlaying
.a618	09 20		ora #$20			ora 	#$20 						; query playing ?
.a61a	20 18 80	jsr $8018			jsr 	SNDCommand
.a61d	c9 00		cmp #$00			cmp 	#0
.a61f	f0 03		beq $a624			beq 	_UPNotPlaying
.a621	4c 67 8f	jmp $8f67			jmp 	ReturnTrue
.a624					_UPNotPlaying:
.a624	4c 72 8f	jmp $8f72			jmp 	ReturnFalse

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/sound.asm

.a627					SoundCommand:
.a627	b1 30		lda ($30),y			lda 	(codePtr),y
.a629	c9 c3		cmp #$c3			cmp 	#KWD_OFF 					; SOUND OFF ?
.a62b	d0 09		bne $a636			bne 	_SNDMain
.a62d	c8		iny				iny 								; skip OFF
.a62e	a9 3f		lda #$3f			lda 	#$3F 						; call command $3F (silence)
.a630	5a		phy				phy
.a631	20 18 80	jsr $8018			jsr 	SNDCommand
.a634	7a		ply				ply
.a635	60		rts				rts
.a636					_SNDMain:
.a636	a2 00		ldx #$00			ldx 	#0
.a638	20 b7 9d	jsr $9db7			jsr 	Evaluate8BitInteger 		; channel
.a63b	c9 04		cmp #$04			cmp 	#4 							; must be 0-3
.a63d	b0 4b		bcs $a68a			bcs 	_SndError
.a63f	e8		inx				inx 								; do the rest in slot 1.
.a640	20 e9 8e	jsr $8ee9			jsr 	CheckComma
.a643	20 9c 9d	jsr $9d9c			jsr 	Evaluate16BitInteger 		; Pitch
.a646	b5 60		lda $60,x			lda 	NSMantissa1,x 				; must be 10 bit
.a648	c9 10		cmp #$10			cmp 	#16
.a64a	b0 3e		bcs $a68a			bcs 	_SndError
.a64c	8d bb 05	sta $05bb			sta 	SoundCommandBlock+1 		; Pitch (2 bytes + 0)
.a64f	b5 58		lda $58,x			lda 	NSMantissa0,x
.a651	8d ba 05	sta $05ba			sta 	SoundCommandBlock
.a654	20 e9 8e	jsr $8ee9			jsr 	CheckComma
.a657	20 b7 9d	jsr $9db7			jsr 	Evaluate8BitInteger 		; Length (1 byte + 3)
.a65a	8d bd 05	sta $05bd			sta 	SoundCommandBlock+3
.a65d	a9 0f		lda #$0f			lda 	#15
.a65f	8d bc 05	sta $05bc			sta 	SoundCommandBlock+2 		; Volume (1 byte + 2)
.a662	9c be 05	stz $05be			stz 	SoundCommandBlock+4 		; default slide (2 bytes +4)
.a665	9c bf 05	stz $05bf			stz 	SoundCommandBlock+5
.a668	b1 30		lda ($30),y			lda 	(codePtr),y
.a66a	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.a66c	d0 0e		bne $a67c			bne 	_SNDPlay
.a66e	c8		iny				iny
.a66f	20 a6 9d	jsr $9da6			jsr 	Evaluate16BitIntegerSigned 	; Slide
.a672	b5 58		lda $58,x			lda 	NSMantissa0,x 				; Slide (2 bytes + 4)
.a674	8d be 05	sta $05be			sta 	SoundCommandBlock+4
.a677	b5 60		lda $60,x			lda 	NSMantissa1,x
.a679	8d bf 05	sta $05bf			sta 	SoundCommandBlock+5
.a67c					_SNDPlay:
.a67c	5a		phy				phy
.a67d	a5 58		lda $58				lda 	NSMantissa0 				; channel.
.a67f	09 10		ora #$10			ora 	#$10 						; 1x = Queue sound
.a681	a2 ba		ldx #$ba			ldx 	#(SoundCommandBlock & $FF)
.a683	a0 05		ldy #$05			ldy 	#(SoundCommandBlock >> 8)
.a685	20 18 80	jsr $8018			jsr 	SNDCommand
.a688	7a		ply				ply
.a689	60		rts				rts
.a68a					_SndError:
.a68a	4c 9f 9f	jmp $9f9f			jmp 	RangeError
.05ba					SoundCommandBlock:
>05ba							.fill 	6

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/bytes.asm

.a68d					StackPushByte:
.a68d	48		pha				pha 								; save byte on stack
.a68e	a5 34		lda $34				lda 	BasicStack 					; decrement basic stack pointer
.a690	d0 08		bne $a69a			bne 	_SPBNoBorrow
.a692	c6 35		dec $35				dec 	BasicStack+1 				; borrow
.a694	a5 35		lda $35				lda 	BasicStack+1 				; check range.
.a696	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a698	90 06		bcc $a6a0			bcc 	_SPBMemory
.a69a					_SPBNoBorrow:
.a69a	c6 34		dec $34				dec 	BasicStack
.a69c	68		pla				pla 								; get back and write
.a69d	92 34		sta ($34)			sta 	(BasicStack)
.a69f	60		rts				rts
.a6a0					_SPBMemory:
.a6a0	a9 12		lda #$12		lda	#18
.a6a2	4c fa 8e	jmp $8efa		jmp	ErrorHandler
.a6a5					StackPopByte:
.a6a5	b2 34		lda ($34)			lda 	(BasicStack) 				; bump the stack pointer.
.a6a7	e6 34		inc $34				inc 	BasicStack
.a6a9	d0 02		bne $a6ad			bne 	_SPBNoCarry
.a6ab	e6 35		inc $35				inc 	BasicStack+1
.a6ad					_SPBNoCarry:
.a6ad	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/frames.asm

.a6ae					StackOpen:
.a6ae	48		pha				pha 								; save frame byte
.a6af	29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.a6b1	0a		asl a				asl 	a 							; claim twice this for storage
.a6b2	49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.a6b4	38		sec				sec 								; so basically subtracting from
.a6b5	65 34		adc $34				adc 	basicStack 	 				; basicStack
.a6b7	85 34		sta $34				sta 	basicStack
.a6b9	b0 09		bcs $a6c4			bcs 	_SONoBorrow
>a6bb	db						.byte 	$DB 						; causes a break in the emulator
.a6bc	c6 35		dec $35				dec 	basicStack+1
.a6be	a5 35		lda $35				lda 	basicStack+1 				; have we reached stack overflow
.a6c0	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a6c2	90 04		bcc $a6c8			bcc 	_SOMemory
.a6c4					_SONoBorrow:
.a6c4	68		pla				pla 								; get marker back and write at TOS
.a6c5	92 34		sta ($34)			sta 	(basicStack)
.a6c7	60		rts				rts
.a6c8					_SOMemory:
.a6c8	a9 12		lda #$12		lda	#18
.a6ca	4c fa 8e	jmp $8efa		jmp	ErrorHandler
.a6cd					StackClose:
.a6cd	b2 34		lda ($34)			lda 	(basicStack) 				; get TOS marker
.a6cf	29 0f		and #$0f			and 	#$0F 						; bytes to add back
.a6d1	0a		asl a				asl 	a 							; claim twice this.
.a6d2	65 34		adc $34				adc 	basicStack 					; add to the stack pointer.
.a6d4	85 34		sta $34				sta 	basicStack
.a6d6	90 02		bcc $a6da			bcc 	_SCExit
.a6d8	e6 35		inc $35				inc 	basicStack+1
.a6da					_SCExit:
.a6da	60		rts				rts
.a6db					StackCheckFrame:
.a6db	48		pha				pha
.a6dc					_StackRemoveLocals:
.a6dc	b2 34		lda ($34)			lda 	(basicStack) 				; check for local, keep popping them
.a6de	c9 03		cmp #$03			cmp 	#STK_LOCALS+1 				; is the frame a local ? S or N are 1/0
.a6e0	b0 05		bcs $a6e7			bcs 	_SCNoLocal
.a6e2	20 79 89	jsr $8979			jsr 	LocalPopValue 				; restore the local value
.a6e5	80 f5		bra $a6dc			bra 	_StackRemoveLocals 			; gr round again
.a6e7					_SCNoLocal:
.a6e7	68		pla				pla 								; get the frame check.
.a6e8	52 34		eor ($34)			eor 	(basicStack) 				; xor with toS marker
.a6ea	29 f0		and #$f0			and 	#$F0 						; check type bits
.a6ec	d0 01		bne $a6ef			bne 	_SCFError 					; different, we have structures mixed up
.a6ee	60		rts				rts
.a6ef					_SCFError:
.a6ef	8a		txa				txa 								; report error X
.a6f0	4c fa 8e	jmp $8efa			jmp 	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/location.asm

.a6f3					STKSaveCodePosition:
.a6f3	5a		phy				phy
.a6f4	98		tya				tya 								; save Y
.a6f5	a0 05		ldy #$05			ldy 	#5
.a6f7	91 34		sta ($34),y			sta 	(basicStack),y
.a6f9	88		dey				dey 								; save Code Pointer
.a6fa					_STKSaveLoop:
.a6fa	b9 2f 00	lda $002f,y			lda 	safePtr-1,y 				; allows us to access the pointer w/out issues.
.a6fd	91 34		sta ($34),y			sta 	(basicStack),y
.a6ff	88		dey				dey
.a700	d0 f8		bne $a6fa			bne 	_STKSaveLoop
.a702	7a		ply				ply
.a703	60		rts				rts
.a704					STKLoadCodePosition:
.a704	a0 01		ldy #$01			ldy 	#1 							; load code pointer back
.a706					_STKLoadLoop:
.a706	b1 34		lda ($34),y			lda 	(basicStack),y
.a708	99 2f 00	sta $002f,y			sta 	safePtr-1,y
.a70b	c8		iny				iny
.a70c	c0 05		cpy #$05			cpy 	#5
.a70e	d0 f6		bne $a706			bne 	_STKLoadLoop
.a710	b1 34		lda ($34),y			lda 	(basicStack),y 				; get Y offset
.a712	a8		tay				tay
.a713	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/setup.asm

.a714					StackReset:
.a714	a9 ff		lda #$ff			lda 	#((BasicStackBase+BasicStackSize-1) & $FF)
.a716	85 34		sta $34				sta 	0+basicStack
.a718	a9 0f		lda #$0f			lda 	#((BasicStackBase+BasicStackSize-1) >> 8)
.a71a	85 35		sta $35				sta 	1+basicStack
.a71c	a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.a71e	92 34		sta ($34)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.a720	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/concrete.asm

.a721					StringConcrete:
.a721	5a		phy				phy 								; save position on stack
.a722	20 2f 9a	jsr $9a2f			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a725	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy target string to zTemp1
.a727	85 38		sta $38				sta 	zTemp1
.a729	b5 60		lda $60,x			lda 	NSMantissa1,x
.a72b	85 39		sta $39				sta 	zTemp1+1
.a72d	a0 ff		ldy #$ff			ldy 	#$FF	 					; calculate string length
.a72f					_SALength:
.a72f	c8		iny				iny
.a730	b1 38		lda ($38),y			lda 	(zTemp1),y
.a732	d0 fb		bne $a72f			bne 	_SALength
.a734	c0 fd		cpy #$fd			cpy 	#253 						; string too long - cannot concrete.
.a736	b0 3d		bcs $a775			bcs 	_SALengthError
.a738	98		tya				tya 				 				; length of the new string
.a739	18		clc				clc
.a73a	69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.a73c	90 02		bcc $a740			bcc 	_SAHaveLength
.a73e	a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.a740					_SAHaveLength:
.a740	48		pha				pha 								; save length.
.a741	38		sec				sec
.a742	49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.a744	6d 0e 04	adc $040e			adc 	StringMemory
.a747	8d 0e 04	sta $040e			sta 	StringMemory
.a74a	85 3a		sta $3a				sta 	zTemp2 						; update storage address
.a74c	95 58		sta $58,x			sta 	NSMantissa0,x 				; update mantissa address
.a74e	a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.a750	6d 0f 04	adc $040f			adc 	StringMemory+1
.a753	8d 0f 04	sta $040f			sta 	StringMemory+1
.a756	85 3b		sta $3b				sta 	zTemp2+1
.a758	95 60		sta $60,x			sta 	NSMantissa1,x
.a75a	68		pla				pla 								; save length-3 (chars allowed) in first byte
.a75b	38		sec				sec
.a75c	e9 03		sbc #$03			sbc 	#3
.a75e	92 3a		sta ($3a)			sta 	(zTemp2)
.a760	a9 00		lda #$00			lda 	#0 							; clear the status byte.
.a762	a0 01		ldy #$01			ldy 	#1
.a764	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a766					_SACopyNewString:
.a766	a0 00		ldy #$00			ldy 	#0
.a768					_SACopyNSLoop:
.a768	b1 38		lda ($38),y			lda 	(zTemp1),y 					; get character
.a76a	c8		iny				iny 								; write two on in string storage
.a76b	c8		iny				iny
.a76c	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a76e	88		dey				dey 								; this makes it one one.
.a76f	c9 00		cmp #$00			cmp 	#0 							; until EOS copied
.a771	d0 f5		bne $a768			bne 	_SACopyNSLoop
.a773	7a		ply				ply
.a774	60		rts				rts
.a775					_SALengthError:
.a775	a9 09		lda #$09		lda	#9
.a777	4c fa 8e	jmp $8efa		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/stringalloc.asm

.a77a					StringSystemInitialise:
.a77a	a9 ff		lda #$ff			lda 	#((EndVariableSpace-1) & $FF)
.a77c	8d 0e 04	sta $040e			sta 	0+StringMemory
.a77f	a9 1f		lda #$1f			lda 	#((EndVariableSpace-1) >> 8)
.a781	8d 0f 04	sta $040f			sta 	1+StringMemory
.a784	9c ff 1f	stz $1fff			stz 	EndVariableSpace-1 			; put a zero at the end, so know end of string memory.
.a787	60		rts				rts
.a788					StringSpaceInitialise:
.a788	20 2f 9a	jsr $9a2f			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a78b	a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.a78d	8d 10 04	sta $0410			sta 	StringInitialised
.a790	ad 0e 04	lda $040e			lda 	StringMemory 				; allocate 256 bytes for one concreted string
.a793	8d 11 04	sta $0411			sta 	StringTempPointer 			; so temporary string space is allocated below that.
.a796	ad 0f 04	lda $040f			lda 	StringMemory+1
.a799	3a		dec a				dec 	a
.a79a	8d 12 04	sta $0412			sta 	StringTempPointer+1
.a79d	60		rts				rts
.a79e					StringTempAllocate:
.a79e	c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.a7a0	b0 30		bcs $a7d2			bcs 	_STALength
.a7a2	2c 10 04	bit $0410			bit 	StringInitialised 			; already initialised
.a7a5	30 05		bmi $a7ac			bmi 	_STAAllocate
.a7a7	48		pha				pha 								; save value to subtract.
.a7a8	20 88 a7	jsr $a788			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.a7ab	68		pla				pla 								; restore it
.a7ac					_STAAllocate:
.a7ac	49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.a7ae	18		clc				clc  								; deliberate allows one more
.a7af	6d 11 04	adc $0411			adc 	StringTempPointer 			; subtract from temp pointer
.a7b2	8d 11 04	sta $0411			sta 	StringTempPointer
.a7b5	95 58		sta $58,x			sta 	NSMantissa0,x 				; address in mantissa
.a7b7	85 3c		sta $3c				sta 	zsTemp 						; and zsTemp
.a7b9	ad 12 04	lda $0412			lda 	StringTempPointer+1
.a7bc	69 ff		adc #$ff			adc 	#$FF
.a7be	8d 12 04	sta $0412			sta 	StringTempPointer+1
.a7c1	85 3d		sta $3d				sta 	zsTemp+1
.a7c3	95 60		sta $60,x			sta 	NSMantissa1,x
.a7c5	74 68		stz $68,x			stz 	NSMantissa2,x 				; set the typing data and the upper address bytes.
.a7c7	74 70		stz $70,x			stz 	NSMantissa3,x
.a7c9	a9 10		lda #$10			lda 	#NSTString
.a7cb	95 50		sta $50,x			sta 	NSStatus,x
.a7cd	a9 00		lda #$00			lda 	#0 							; clear the target string
.a7cf	92 3c		sta ($3c)			sta 	(zsTemp)
.a7d1	60		rts				rts
.a7d2					_STALength:
.a7d2	a9 09		lda #$09		lda	#9
.a7d4	4c fa 8e	jmp $8efa		jmp	ErrorHandler
.a7d7					StringTempWrite:
.a7d7	48		pha				pha
.a7d8	92 3c		sta ($3c)			sta 	(zsTemp) 					; write byte
.a7da	e6 3c		inc $3c				inc 	zsTemp 						; bump pointer
.a7dc	d0 02		bne $a7e0			bne 	_STWNoCarry
.a7de	e6 3d		inc $3d				inc 	zsTemp+1
.a7e0					_STWNoCarry:
.a7e0	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.a7e2	92 3c		sta ($3c)			sta 	(zsTemp)
.a7e4	68		pla				pla
.a7e5	60		rts				rts

;******  Return to file: _basic.asm

.a7e6					StartModuleCode:

;******  Processing file: ../modules/_build/_hardware.module

=1					hardwareIntegrated=1
=0					CONBlack = 0
=1					CONWhite = 1
=2					CONRed = 2
=3					CONCyan = 3
=4					CONPurple = 4
=5					CONGreen = 5
=6					CONBlue = 6
=7					CONYellow = 7
=8					CONOrange = 8
=9					CONBrown = 9
=10					CONYellowGreen = 10
=11					CONRosa = 11
=12					CONBlueGreen = 12
=13					CONLightBlue = 13
=14					CONPink = 14
=15					CONLightGreen = 15
=7					CONForeground = CONYellow
=6					CONBackground = CONBlue
=5					CLICommandLine = CONGreen
=0					CLIFComment = CONBlack
=7					CLIBComment = CONYellow
=9					CLILineNumber = CONBrown
=3					CLIToken = CONCyan
=13					CLIConstant = CONLightBlue
=7					CLIIdentifier = CONYellow
=10					CLIPunctuation = CONYellowGreen
=1					CLIData = CONWhite
.a7e6					Export_EXTPrintCharacter:
.a7e6					PAGEDPrintCharacter:
.a7e6	48		pha				pha
.a7e7	da		phx				phx
.a7e8	5a		phy				phy
.a7e9	a6 01		ldx $01				ldx 	1
.a7eb	da		phx				phx
.a7ec	ac c1 05	ldy $05c1			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.a7ef	09 00		ora #$00			ora 	#$00 						; check $80-$FF
.a7f1	30 48		bmi $a83b			bmi 	_EXPCColour
.a7f3	c9 20		cmp #$20			cmp 	#$20 						; check $00-$1F
.a7f5	90 4d		bcc $a844			bcc 	_EXPCControl
.a7f7	a2 02		ldx #$02			ldx 	#2 							; select char memory
.a7f9	86 01		stx $01				stx 	1
.a7fb	91 40		sta ($40),y			sta 	(EXTAddress),y
.a7fd	e6 01		inc $01				inc 	1 							; select colour memory
.a7ff	ad c2 05	lda $05c2			lda 	EXTTextColour
.a802	91 40		sta ($40),y			sta 	(EXTAddress),y
.a804	c8		iny				iny 								; advance horizontal position
.a805	8c c1 05	sty $05c1			sty 	EXTColumn
.a808	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth 				; reached RHS ?
.a80b	90 63		bcc $a870			bcc 	_EXPCExit 					; no, then exit.
.a80d					_EXPCCRLF:
.a80d	ee c0 05	inc $05c0			inc 	EXTRow  					; bump row
.a810	9c c1 05	stz $05c1			stz 	EXTColumn 					; back to column 0
.a813	ad c0 05	lda $05c0			lda 	EXTRow 						; check if reached the bottom ?
.a816	cd c4 05	cmp $05c4			cmp 	EXTScreenHeight 			; if so, then scroll.
.a819	f0 18		beq $a833			beq 	_EXPCScroll
.a81b	18		clc				clc 								; add width to address.
.a81c	a5 40		lda $40				lda 	EXTAddress
.a81e	6d c3 05	adc $05c3			adc 	EXTScreenWidth
.a821	85 40		sta $40				sta 	EXTAddress
.a823	90 4b		bcc $a870			bcc 	_EXPCExit
.a825	e6 41		inc $41				inc 	EXTAddress+1
.a827	80 47		bra $a870			bra 	_EXPCExit
.a829					_EXPCLeft:
.a829	ce c1 05	dec $05c1			dec 	EXTColumn
.a82c	10 42		bpl $a870			bpl 	_EXPCExit
.a82e					_EXPCBegin:
.a82e	9c c1 05	stz $05c1			stz 	EXTColumn
.a831	80 3d		bra $a870			bra 	_EXPCExit
.a833					_EXPCScroll:
.a833	ce c0 05	dec $05c0			dec 	EXTRow 						; the height-1 th line.
.a836	20 21 a9	jsr $a921			jsr 	EXTScreenScroll 			; scroll the screen
.a839	80 35		bra $a870			bra 	_EXPCExit
.a83b					_EXPCColour:
.a83b	c9 a0		cmp #$a0			cmp 	#$A0						; 80-9F set foreground/background
.a83d	b0 31		bcs $a870			bcs 	_EXPCExit
.a83f	20 01 a9	jsr $a901			jsr 	_EXPCHandleColour
.a842	80 2c		bra $a870			bra 	_EXPCExit
.a844					_EXPCControl:
.a844	c9 11		cmp #$11			cmp 	#$11 						; only handle 00-10.
.a846	b0 28		bcs $a870			bcs 	_EXPCExit
.a848	0a		asl a				asl 	a 							; double into X
.a849	aa		tax				tax
.a84a	7c df a8	jmp ($a8df,x)			jmp 	(_EXPCActionTable,x) 		; and execute code.
.a84d					_EXPCUp:
.a84d	ad c0 05	lda $05c0			lda 	EXTRow 						; already at top ?
.a850	f0 1e		beq $a870			beq 	_EXPCExit
.a852	ce c0 05	dec $05c0			dec 	EXTRow 						; up one in position/address
.a855	38		sec				sec
.a856	a5 40		lda $40				lda 	EXTAddress
.a858	ed c3 05	sbc $05c3			sbc 	EXTScreenWidth
.a85b	85 40		sta $40				sta 	EXTAddress
.a85d	b0 11		bcs $a870			bcs 	_EXPCExit
.a85f	c6 41		dec $41				dec 	EXTAddress+1
.a861	80 0d		bra $a870			bra 	_EXPCExit
.a863					_EXPCRight:
.a863	c8		iny				iny
.a864	8c c1 05	sty $05c1			sty 	EXTColumn
.a867	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth
.a86a	d0 04		bne $a870			bne 	_EXPCExit
.a86c	88		dey				dey
.a86d					_EXPCSetColumnY:
.a86d	8c c1 05	sty $05c1			sty 	EXTColumn
.a870					_EXPCExit:
.a870	20 76 a9	jsr $a976			jsr 	EXTSetHardwareCursor 		; place the physical cursor.
.a873	68		pla				pla
.a874	85 01		sta $01				sta 	1
.a876	7a		ply				ply
.a877	fa		plx				plx
.a878	68		pla				pla
.a879	60		rts				rts
.a87a					_EXPCClearScreen:
.a87a	20 33 a9	jsr $a933			jsr		EXTClearScreenCode
.a87d	80 f1		bra $a870			bra 	_EXPCExit
.a87f					_EXPCDown:
.a87f	ad c4 05	lda $05c4			lda 	EXTScreenHeight 			; at the bottom
.a882	3a		dec a				dec 	a
.a883	cd c0 05	cmp $05c0			cmp 	EXTRow
.a886	f0 e8		beq $a870			beq 	_EXPCExit
.a888	ee c0 05	inc $05c0			inc 	EXTRow 						; down one in position/address
.a88b	18		clc				clc
.a88c	a5 40		lda $40				lda 	EXTAddress
.a88e	6d c3 05	adc $05c3			adc 	EXTScreenWidth
.a891	85 40		sta $40				sta 	EXTAddress
.a893	90 db		bcc $a870			bcc 	_EXPCExit
.a895	e6 41		inc $41				inc 	EXTAddress+1
.a897	80 d7		bra $a870			bra 	_EXPCExit
.a899					_EXPCTab:
.a899	ad c1 05	lda $05c1			lda 	EXTColumn 					; next tab stop
.a89c	29 f8		and #$f8			and 	#$F8
.a89e	18		clc				clc
.a89f	69 08		adc #$08			adc 	#8
.a8a1	8d c1 05	sta $05c1			sta 	EXTColumn
.a8a4	cd c3 05	cmp $05c3			cmp 	EXTScreenWidth 				; too far, stick end of line.
.a8a7	90 c7		bcc $a870			bcc 	_EXPCExit
.a8a9	80 10		bra $a8bb			bra 	_EXPCEnd
.a8ab					_EXPCBackSpace:
.a8ab	88		dey				dey
.a8ac	30 c2		bmi $a870			bmi 	_EXPCExit
.a8ae	ce c1 05	dec $05c1			dec 	EXTColumn
.a8b1	a9 02		lda #$02			lda 	#2
.a8b3	85 01		sta $01				sta 	1
.a8b5	a9 20		lda #$20			lda 	#32
.a8b7	91 40		sta ($40),y			sta 	(EXTAddress),y
.a8b9	80 b5		bra $a870			bra 	_EXPCExit
.a8bb					_EXPCEnd:
.a8bb	a9 02		lda #$02			lda 	#2 							; access text screen
.a8bd	85 01		sta $01				sta 	1
.a8bf	ac c3 05	ldy $05c3			ldy 	EXTScreenWidth 				; point to last character
.a8c2	88		dey				dey
.a8c3					_EXPCEndSearch:
.a8c3	88		dey				dey 								; if past start, move to col 0.
.a8c4	30 06		bmi $a8cc			bmi 	_EXPCFound
.a8c6	b1 40		lda ($40),y			lda 	(EXTAddress),y 				; keep going back till non space found
.a8c8	c9 20		cmp #$20			cmp 	#' '
.a8ca	f0 f7		beq $a8c3			beq 	_EXPCEndSearch
.a8cc					_EXPCFound:
.a8cc	c8		iny				iny 								; move to following cell.
.a8cd	80 9e		bra $a86d			bra 	_EXPCSetColumnY
.a8cf					_EXPCClearEOL:
.a8cf	a9 02		lda #$02			lda 	#2 							; access character RAM
.a8d1	85 01		sta $01				sta 	1
.a8d3	a9 20		lda #$20			lda 	#' ' 						; write space
.a8d5	91 40		sta ($40),y			sta 	(EXTAddress),y
.a8d7	c8		iny				iny
.a8d8	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth 				; until RHS of screen.
.a8db	90 f2		bcc $a8cf			bcc 	_EXPCClearEOL
.a8dd	80 91		bra $a870			bra 	_EXPCExit
.a8df					_EXPCActionTable:
>a8df	70 a8						.word 	_EXPCExit 					; 00
>a8e1	2e a8						.word 	_EXPCBegin 					; 01 A Start of Line
>a8e3	29 a8						.word 	_EXPCLeft 					; 02 B Left
>a8e5	70 a8						.word 	_EXPCExit 					; 03 <Break>
>a8e7	70 a8						.word 	_EXPCExit 					; 04
>a8e9	bb a8						.word 	_EXPCEnd 					; 05 E End of Line
>a8eb	63 a8						.word 	_EXPCRight 					; 06 F Right
>a8ed	70 a8						.word 	_EXPCExit 					; 07
>a8ef	ab a8						.word 	_EXPCBackspace 				; 08 H Backspace
>a8f1	99 a8						.word 	_EXPCTab 					; 09 I Tab
>a8f3	70 a8						.word 	_EXPCExit 					; 0A
>a8f5	cf a8						.word 	_EXPCClearEOL 				; 0B K Clear to EOL
>a8f7	7a a8						.word 	_EXPCClearScreen			; 0C L CLS
>a8f9	0d a8						.word 	_EXPCCRLF 					; 0D M CR/LF
>a8fb	7f a8						.word 	_EXPCDown 					; 0E N Down
>a8fd	70 a8						.word 	_EXPCExit 					; 0F
>a8ff	4d a8						.word 	_EXPCUp 					; 10 P Up
.a901					_EXPCHandleColour
.a901	c9 90		cmp #$90			cmp 	#$90 						; 8x foreground 9x background
.a903	b0 16		bcs $a91b			bcs 	_EXPCBackground
.a905	0a		asl a				asl 	a 							; shift it 4 bits to the right.
.a906	0a		asl a				asl 	a
.a907	0a		asl a				asl 	a
.a908	0a		asl a				asl 	a
.a909	a2 0f		ldx #$0f			ldx 	#$0F 						; Mask in X
.a90b					_EXPCUpdate:
.a90b	48		pha				pha 								; save new colour
.a90c	8a		txa				txa 								; get mask
.a90d	2d c2 05	and $05c2			and 	EXTTextColour 				; mask out old.
.a910	8d c2 05	sta $05c2			sta 	EXTTextColour
.a913	68		pla				pla 								; or in new colour
.a914	0d c2 05	ora $05c2			ora 	EXTTextColour
.a917	8d c2 05	sta $05c2			sta 	EXTTextColour
.a91a	60		rts				rts
.a91b					_EXPCBackground:
.a91b	29 0f		and #$0f			and 	#$0F 						; get the colour
.a91d	a2 f0		ldx #$f0			ldx 	#$F0 						; mask
.a91f	80 ea		bra $a90b			bra 	_EXPCUpdate
.a921					EXTScreenScroll:
.a921	a9 02		lda #$02			lda 	#2 							; select text page
.a923	85 01		sta $01				sta 	1
.a925	a9 20		lda #$20			lda		#32 						; fill with space
.a927	20 3a aa	jsr $aa3a			jsr 	EXTScrollFill
.a92a	e6 01		inc $01				inc 	1 							; select colour page
.a92c	ad c2 05	lda $05c2			lda 	EXTTextColour
.a92f	20 3a aa	jsr $aa3a			jsr 	EXTScrollFill
.a932	60		rts				rts
.a933					EXTClearScreenCode:
.a933	a9 02		lda #$02			lda 	#2 							; select text page
.a935	85 01		sta $01				sta 	1
.a937	a9 20		lda #$20			lda		#32 						; fill with space
.a939	20 46 a9	jsr $a946			jsr 	_EXTCSFill
.a93c	e6 01		inc $01				inc 	1 							; select colour page
.a93e	ad c2 05	lda $05c2			lda 	EXTTextColour
.a941	20 46 a9	jsr $a946			jsr 	_EXTCSFill
.a944	80 22		bra $a968			bra 	EXTHomeCursor
.a946					_EXTCSFill:
.a946	aa		tax				tax
.a947	a9 00		lda #$00			lda 	#EXTMemory & $FF
.a949	85 40		sta $40				sta 	EXTAddress
.a94b	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a94d	85 41		sta $41				sta 	EXTAddress+1
.a94f					_EXTCSFill1:
.a94f	a0 00		ldy #$00			ldy 	#0
.a951	8a		txa				txa
.a952					_EXTCSFill2:
.a952	91 40		sta ($40),y			sta 	(EXTAddress),y
.a954	c8		iny				iny
.a955	d0 fb		bne $a952			bne 	_EXTCSFill2
.a957	e6 41		inc $41				inc 	EXTAddress+1
.a959	a5 41		lda $41				lda 	EXTAddress+1
.a95b	c9 d2		cmp #$d2			cmp 	#$D2
.a95d	d0 f0		bne $a94f			bne 	_EXTCSFill1
.a95f	8a		txa				txa
.a960					_EXTCSFill3:
.a960	91 40		sta ($40),y			sta 	(EXTAddress),y
.a962	c8		iny				iny
.a963	c0 c0		cpy #$c0			cpy 	#$C0
.a965	d0 f9		bne $a960			bne 	_EXTCSFill3
.a967	60		rts				rts
.a968					EXTHomeCursor:
.a968	9c c0 05	stz $05c0			stz 	EXTRow 						; reset row & column
.a96b	9c c1 05	stz $05c1			stz 	EXTColumn
.a96e	a9 00		lda #$00			lda 	#EXTMemory & $FF 			; set address
.a970	85 40		sta $40				sta 	EXTAddress
.a972	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a974	85 41		sta $41				sta 	EXTAddress+1
.a976					EXTSetHardwareCursor:
.a976	64 01		stz $01				stz 	1 							; I/O Page zero
.a978	a9 05		lda #$05			lda 	#1+4 						; enable cursor
.a97a	8d 10 d0	sta $d010			sta 	$D010
.a97d	a9 b1		lda #$b1			lda 	#$B1
.a97f	8d 12 d0	sta $d012			sta 	$D012
.a982	ad c1 05	lda $05c1			lda 	EXTColumn
.a985	8d 14 d0	sta $d014			sta 	$D014 						; set cursor position
.a988	9c 15 d0	stz $d015			stz 	$D015
.a98b	ad c0 05	lda $05c0			lda 	EXTRow
.a98e	8d 16 d0	sta $d016			sta 	$D016
.a991	9c 17 d0	stz $d017			stz 	$D017
.a994	60		rts				rts
.a995					Export_EXTInputLine:
.a995	48		pha				pha
.a996	da		phx				phx
.a997	5a		phy				phy
.a998	a5 01		lda $01				lda 	1 							; save I/O page
.a99a	48		pha				pha
.a99b					_EILLoop:
.a99b	20 b5 aa	jsr $aab5			jsr 	PagedInputSingleCharacter
.a99e	c9 0d		cmp #$0d			cmp 	#13 						; scrape line if exit.
.a9a0	f0 44		beq $a9e6			beq 	_EILExit
.a9a2	c9 04		cmp #$04			cmp 	#4 							; Ctrl+D delete at cursor
.a9a4	f0 2a		beq $a9d0			beq 	_EILDelete
.a9a6	c9 08		cmp #$08			cmp 	#8 							; Ctrl+H backspace
.a9a8	f0 1c		beq $a9c6			beq 	_EILBackspace
.a9aa	c9 20		cmp #$20			cmp 	#' '						; < space, print it
.a9ac	90 12		bcc $a9c0			bcc 	_EILPrintLoop
.a9ae	c9 7f		cmp #$7f			cmp 	#$7F 						; if -ve print it
.a9b0	b0 0e		bcs $a9c0			bcs 	_EILPrintLoop
.a9b2	48		pha				pha 								; save character
.a9b3	a9 02		lda #$02			lda 	#2  						; insert a space
.a9b5	85 01		sta $01				sta 	1
.a9b7	20 28 aa	jsr $aa28			jsr 	EXTILInsert 				; insert in text screen
.a9ba	e6 01		inc $01				inc 	1
.a9bc	20 28 aa	jsr $aa28			jsr 	EXTILInsert 				; insert in colour screen
.a9bf	68		pla				pla 								; get character back.
.a9c0					_EILPrintLoop:
.a9c0	20 e6 a7	jsr $a7e6			jsr 	PagedPrintCharacter
.a9c3	80 d6		bra $a99b			bra 	_EILLoop
.a9c5	60		rts				rts
.a9c6					_EILBackspace:
.a9c6	ad c1 05	lda $05c1			lda 	EXTColumn					; can we backspace ?
.a9c9	f0 d0		beq $a99b			beq 	_EILLoop
.a9cb	a9 02		lda #$02			lda 	#2 							; move cursor left
.a9cd	20 e6 a7	jsr $a7e6			jsr 	PagedPrintCharacter
.a9d0					_EILDelete
.a9d0	a9 02		lda #$02			lda 	#2 							; text block
.a9d2	85 01		sta $01				sta 	1
.a9d4	a9 20		lda #$20			lda 	#' ' 						; backspace text.
.a9d6	20 13 aa	jsr $aa13			jsr 	EXTILDelete
.a9d9	e6 01		inc $01				inc 	1 							; colour block
.a9db	ac c1 05	ldy $05c1			ldy 	EXTColumn 					; get attribute of last character
.a9de	88		dey				dey
.a9df	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a9e1	20 13 aa	jsr $aa13			jsr 	EXTILDelete 				; backspace attribute
.a9e4	80 b5		bra $a99b			bra 	_EILLoop 					; and go round.
.a9e6					_EILExit:
.a9e6	a9 02		lda #$02			lda 	#2 							; switch to page 2
.a9e8	85 01		sta $01				sta 	1
.a9ea	a0 00		ldy #$00			ldy 	#0 							; copy current line into buffer.
.a9ec					_EILScrapeLine:
.a9ec	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a9ee	99 2a 05	sta $052a,y			sta 	lineBuffer,y
.a9f1	c8		iny				iny
.a9f2	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth
.a9f5	d0 f5		bne $a9ec			bne 	_EILScrapeLine
.a9f7					_EILTrimSpaces:
.a9f7	88		dey				dey
.a9f8	f0 08		beq $aa02			beq 	_EILEndTrim
.a9fa	b9 2a 05	lda $052a,y			lda 	lineBuffer,y
.a9fd	c9 20		cmp #$20			cmp 	#' '
.a9ff	f0 f6		beq $a9f7			beq 	_EILTrimSpaces
.aa01	c8		iny				iny 								; trim after non space character.
.aa02					_EILEndTrim:
.aa02	a9 00		lda #$00			lda 	#0 							; trim here.
.aa04	99 2a 05	sta $052a,y			sta 	lineBuffer,y
.aa07	a9 0d		lda #$0d			lda 	#13 						; echo the RETURN
.aa09	20 e6 a7	jsr $a7e6			jsr 	PagedPrintCharacter
.aa0c	68		pla				pla 								; reset I/O page
.aa0d	85 01		sta $01				sta 	1
.aa0f	7a		ply				ply
.aa10	fa		plx				plx
.aa11	68		pla				pla
.aa12	60		rts				rts
.aa13					EXTILDelete:
.aa13	48		pha				pha 								; save the new character
.aa14	ac c1 05	ldy $05c1			ldy 	EXTColumn 					; start copying from here.
.aa17					_EXTDLoop:
.aa17	c8		iny				iny 								; copy one byte down.
.aa18	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa1a	88		dey				dey
.aa1b	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa1d	c8		iny				iny 								; do till end of line.
.aa1e	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth
.aa21	90 f4		bcc $aa17			bcc 	_EXTDLoop
.aa23	88		dey				dey 	 							; write in last slot.
.aa24	68		pla				pla
.aa25	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa27	60		rts				rts
.aa28					EXTILInsert:
.aa28	ac c3 05	ldy $05c3			ldy 	EXTScreenWidth 				; end position
.aa2b					_EXTILoop:
.aa2b	88		dey				dey 								; back one
.aa2c	cc c1 05	cpy $05c1			cpy 	EXTColumn 					; exit if reached insert point.
.aa2f	f0 08		beq $aa39			beq 	_EXTIExit
.aa31	88		dey				dey 								; copy one byte up.
.aa32	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa34	c8		iny				iny
.aa35	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa37	80 f2		bra $aa2b			bra 	_EXTILoop
.aa39					_EXTIExit:
.aa39	60		rts				rts
.aa3a					EXTScrollFill:
.aa3a	aa		tax				tax									; save value to fill with
.aa3b	a5 36		lda $36				lda 	zTemp0 						; save zTemp0 (dest) zTemp1 (src)
.aa3d	48		pha				pha
.aa3e	a5 37		lda $37				lda 	zTemp0+1
.aa40	48		pha				pha
.aa41	a5 38		lda $38				lda 	zTemp1
.aa43	48		pha				pha
.aa44	a5 39		lda $39				lda 	zTemp1+1
.aa46	48		pha				pha
.aa47	a9 c0		lda #$c0			lda 	#$C0 						; copy from C000+length to C000
.aa49	85 37		sta $37				sta 	zTemp0+1
.aa4b	85 39		sta $39				sta 	zTemp1+1
.aa4d	64 36		stz $36				stz 	zTemp0
.aa4f	ad c3 05	lda $05c3			lda 	EXTScreenWidth
.aa52	85 38		sta $38				sta 	zTemp1
.aa54	a0 00		ldy #$00			ldy 	#0
.aa56					_EXSFCopy1:
.aa56	b1 38		lda ($38),y			lda 	(zTemp1),y
.aa58	91 36		sta ($36),y			sta 	(zTemp0),y
.aa5a	c8		iny				iny
.aa5b	d0 f9		bne $aa56			bne 	_EXSFCopy1
.aa5d	e6 37		inc $37				inc 	zTemp0+1 					; next page
.aa5f	e6 39		inc $39				inc 	zTemp1+1
.aa61	a5 39		lda $39				lda 	zTemp1+1
.aa63	c9 d3		cmp #$d3			cmp 	#$D3
.aa65	d0 ef		bne $aa56			bne 	_EXSFCopy1
.aa67	ac c3 05	ldy $05c3			ldy 	EXTScreenWidth 				; blank the bottom line.
.aa6a	8a		txa				txa
.aa6b					_EXSFFill1:
.aa6b	88		dey				dey
.aa6c	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa6e	c0 00		cpy #$00			cpy 	#0
.aa70	10 f9		bpl $aa6b			bpl 	_EXSFFill1
.aa72	68		pla				pla
.aa73	85 39		sta $39				sta 	zTemp1+1
.aa75	68		pla				pla
.aa76	85 38		sta $38				sta 	zTemp1
.aa78	68		pla				pla
.aa79	85 37		sta $37				sta 	zTemp0+1
.aa7b	68		pla				pla
.aa7c	85 36		sta $36				sta 	zTemp0
.aa7e	60		rts				rts
=$c000					EXTMemory = $C000
=$02					EXTTextPage = $02
=$03					EXTColourPage = $03
=1					EXTDummySpace = 1 							; fake-space for CR character.
=0					EXTCBlack = 0
.05c0					EXTRow:
>05c0							.fill 	1
.05c1					EXTColumn:
>05c1							.fill 	1
.05c2					EXTTextColour:
>05c2							.fill 	1
.05c3					EXTScreenWidth:
>05c3							.fill 	1
.05c4					EXTScreenHeight:
>05c4							.fill 	1
.0040					EXTAddress:
>0040							.fill 	2
.aa7f					Export_EXTInitialise:
.aa7f	64 01		stz $01				stz 	1 							; Access I/O page 0
.aa81	9c 04 d0	stz $d004			stz 	$D004 						; Disable border
.aa84	9c 08 d0	stz $d008			stz 	$D008
.aa87	9c 09 d0	stz $d009			stz 	$D009
.aa8a	a9 09		lda #$09			lda 	#1+8						; Timer On at 70Hz counting up.
.aa8c	8d 58 d6	sta $d658			sta 	$D658
.aa8f	a9 03		lda #$03			lda 	#3 							; get current text colour from whatever the kernel
.aa91	85 01		sta $01				sta 	1 							; has set it to, looking at top left character
.aa93	ad 00 c0	lda $c000			lda 	$C000
.aa96	8d c2 05	sta $05c2			sta 	EXTTextColour
.aa99	a9 50		lda #$50			lda 	#80 						; set screen dimensions.
.aa9b	8d c3 05	sta $05c3			sta 	EXTScreenWidth
.aa9e	a9 3c		lda #$3c			lda 	#60
.aaa0	8d c4 05	sta $05c4			sta 	EXTScreenHeight
.aaa3	20 68 a9	jsr $a968			jsr 	EXTHomeCursor 				; home cursor
.aaa6					_EXMoveDown:
.aaa6	a9 0d		lda #$0d			lda 	#13
.aaa8	20 e6 a7	jsr $a7e6			jsr 	PAGEDPrintCharacter
.aaab	ad c0 05	lda $05c0			lda 	EXTRow
.aaae	c9 06		cmp #$06			cmp 	#6
.aab0	d0 f4		bne $aaa6			bne 	_EXMoveDown
.aab2	64 01		stz $01				stz 	1
.aab4	60		rts				rts
.aab5					Export_EXTInputSingleCharacter:
.aab5					PagedInputSingleCharacter:
.aab5	da		phx				phx
.aab6	5a		phy				phy
.aab7					_EISCWait:
.aab7	a5 01		lda $01				lda 	1 							; save I/O 0
.aab9	48		pha				pha
.aaba	64 01		stz $01				stz 	1 							; access I/O Page 0
.aabc	38		sec				sec 								; calculate timer - LastTick
.aabd	ad 59 d6	lda $d659			lda 	$D659
.aac0	aa		tax				tax 								; saving timer in X
.aac1	ed af 05	sbc $05af			sbc 	LastTick
.aac4	c9 03		cmp #$03			cmp 	#3
.aac6	90 06		bcc $aace			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.aac8	8e af 05	stx $05af			stx 	LastTick 					; update last timer
.aacb	20 96 be	jsr $be96			jsr 	PagedSNDUpdate 							; go do the code.
.aace					_NoFireTick:
.aace	68		pla				pla 								; restore I/O 0
.aacf	85 01		sta $01				sta 	1
.aad1	20 e4 ff	jsr $ffe4			jsr 	$FFE4 						; get a key
.aad4	c9 00		cmp #$00			cmp 	#0 							; loop back if none pressed.
.aad6	f0 df		beq $aab7			beq 	_EISCWait
.aad8	7a		ply				ply
.aad9	fa		plx				plx
.aada	60		rts				rts
.aadb					Export_EXTBreakCheck:
.aadb	4c e1 ff	jmp $ffe1			jmp		$FFE1
.aade					Export_EXTReadController:
.aade	da		phx				phx
.aadf	a2 00		ldx #$00			ldx 	#0
.aae1	a9 05		lda #$05			lda 	#(($2D) >> 3)
.aae3	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aae6	29 20		and #$20			and 	#($01 << (($2D) & 7))
.aae8	f0 04		beq $aaee			beq 	_NoSet1
.aaea	8a		txa				txa
.aaeb	09 01		ora #$01			ora 	#1
.aaed	aa		tax				tax
.aaee					_NoSet1:
.aaee	a9 05		lda #$05			lda 	#(($2C) >> 3)
.aaf0	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aaf3	29 10		and #$10			and 	#($01 << (($2C) & 7))
.aaf5	f0 04		beq $aafb			beq 	_NoSet1
.aaf7	8a		txa				txa
.aaf8	09 02		ora #$02			ora 	#2
.aafa	aa		tax				tax
.aafb					_NoSet1:
.aafb	a9 06		lda #$06			lda 	#(($32) >> 3)
.aafd	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab00	29 04		and #$04			and 	#($01 << (($32) & 7))
.ab02	f0 04		beq $ab08			beq 	_NoSet1
.ab04	8a		txa				txa
.ab05	09 04		ora #$04			ora 	#4
.ab07	aa		tax				tax
.ab08					_NoSet1:
.ab08	a9 04		lda #$04			lda 	#(($25) >> 3)
.ab0a	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab0d	29 20		and #$20			and 	#($01 << (($25) & 7))
.ab0f	f0 04		beq $ab15			beq 	_NoSet1
.ab11	8a		txa				txa
.ab12	09 08		ora #$08			ora 	#8
.ab14	aa		tax				tax
.ab15					_NoSet1:
.ab15	a9 04		lda #$04			lda 	#(($26) >> 3)
.ab17	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab1a	29 40		and #$40			and 	#($01 << (($26) & 7))
.ab1c	f0 04		beq $ab22			beq 	_NoSet1
.ab1e	8a		txa				txa
.ab1f	09 10		ora #$10			ora 	#16
.ab21	aa		tax				tax
.ab22					_NoSet1:
.ab22	8a		txa				txa
.ab23	fa		plx				plx
.ab24	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_graphics.module

=1					graphicsIntegrated=1
=0					GCMD_Initialise = 0*2
=2					GCMD_BitmapCtl = 1*2
=4					GCMD_SpriteCtl = 2*2
=6					GCMD_Clear = 3*2
=8					GCMD_Colour = 4*2
=10					GCMD_DrawFont = 5*2
=12					GCMD_DrawSprite = 6*2
=14					GCMD_SpriteUse = 7*2
=16					GCMD_SpriteImage = 8*2
=18					GCMD_SpriteCollide = 9*2
=64					GCMD_Move = 32*2
=66					GCMD_Line = 33*2
=68					GCMD_FrameRect = 34*2
=70					GCMD_FillRect = 35*2
=72					GCMD_FrameCircle = 36*2
=74					GCMD_FillCircle = 37*2
=80					GCMD_Plot = 40*2
=82					GCMD_SpriteMove = 41*2
=42					GRFirstFreeCode = 42
.ab25					GRVectorTable:
>ab25	74 ad					.word	GXInitialise             ; $00 Initialise
>ab27	8e ad					.word	GXControlBitmap          ; $01 BitmapCtl
>ab29	d6 ad					.word	GXControlSprite          ; $02 SpriteCtl
>ab2b	26 ad					.word	GXClearBitmap            ; $03 Clear
>ab2d	65 af					.word	GXSetColourMode          ; $04 Colour
>ab2f	2d b1					.word	GXFontHandler            ; $05 DrawFont
>ab31	75 b1					.word	GXSpriteHandler          ; $06 DrawSprite
>ab33	e6 b1					.word	GXSelect                 ; $07 SpriteUse
>ab35	0f b2					.word	GXSelectImage            ; $08 SpriteImage
>ab37	96 b3					.word	GXCollide                ; $09 SpriteCollide
>ab39	d8 ab					.word	GRUndefined              ; $0a
>ab3b	d8 ab					.word	GRUndefined              ; $0b
>ab3d	d8 ab					.word	GRUndefined              ; $0c
>ab3f	d8 ab					.word	GRUndefined              ; $0d
>ab41	d8 ab					.word	GRUndefined              ; $0e
>ab43	d8 ab					.word	GRUndefined              ; $0f
>ab45	d8 ab					.word	GRUndefined              ; $10
>ab47	d8 ab					.word	GRUndefined              ; $11
>ab49	d8 ab					.word	GRUndefined              ; $12
>ab4b	d8 ab					.word	GRUndefined              ; $13
>ab4d	d8 ab					.word	GRUndefined              ; $14
>ab4f	d8 ab					.word	GRUndefined              ; $15
>ab51	d8 ab					.word	GRUndefined              ; $16
>ab53	d8 ab					.word	GRUndefined              ; $17
>ab55	d8 ab					.word	GRUndefined              ; $18
>ab57	d8 ab					.word	GRUndefined              ; $19
>ab59	d8 ab					.word	GRUndefined              ; $1a
>ab5b	d8 ab					.word	GRUndefined              ; $1b
>ab5d	d8 ab					.word	GRUndefined              ; $1c
>ab5f	d8 ab					.word	GRUndefined              ; $1d
>ab61	d8 ab					.word	GRUndefined              ; $1e
>ab63	d8 ab					.word	GRUndefined              ; $1f
>ab65	d6 ab					.word	GXMove                   ; $20 Move
>ab67	33 ae					.word	GXLine                   ; $21 Line
>ab69	ae af					.word	GXFrameRectangle         ; $22 FrameRect
>ab6b	ab af					.word	GXFillRectangle          ; $23 FillRect
>ab6d	dd ab					.word	GXFrameCircle            ; $24 FrameCircle
>ab6f	d9 ab					.word	GXFillCircle             ; $25 FillCircle
>ab71	d8 ab					.word	GRUndefined              ; $26
>ab73	d8 ab					.word	GRUndefined              ; $27
>ab75	93 af					.word	GXPlotPoint              ; $28 Plot
>ab77	a5 b2					.word	GXMoveSprite             ; $29 SpriteMove
=3					GXMappingPage = 3
=24576					GXMappingAddress = ($2000 * GXMappingPage)
=11					GXEditSlot = 8 + GXMappingPage
=$36					gxzTemp0 = zTemp0
=$38					gxzTemp1 = zTemp1
=$3a					gxzTemp2 = zTemp2
=$3c					gxzScreen = zsTemp
=$57b					gxPixelBuffer = numberBuffer
.05c5					gxCurrentX:
>05c5							.fill 	2
.05c7					gxCurrentY:
>05c7							.fill 	2
.05c9					gxLastX:
>05c9							.fill 	2
.05cb					gxLastY:
>05cb							.fill 	2
.05cd					gxX0:
>05cd							.fill 	2
.05cf					gxY0:
>05cf							.fill 	2
.05d1					gxX1:
>05d1							.fill 	2
.05d3					gxY1:
>05d3							.fill 	2
.05d5					gxSpritesOn:
>05d5							.fill 	1
.05d6					gxBitmapsOn:
>05d6							.fill 	1
.05d7					gxBasePage:
>05d7							.fill 	1
.05d8					gxSpritePage:
>05d8							.fill 	1
.05d9					gxHeight:
>05d9							.fill 	1
.05da					gxMode:
>05da							.fill 	1
.05db					gxColour:
>05db							.fill 	1
.05dc					gxEORValue:
>05dc							.fill 	1
.05dd					gxANDValue:
>05dd							.fill 	1
.05de					gxOriginalLUTValue:
>05de							.fill 	1
.05df					gsOffset:
>05df							.fill 	1
.05e0					GSCurrentSpriteID:
>05e0							.fill 	1
.05e1					GSCurrentSpriteAddr:
>05e1							.fill 	2
.05e3					GXSpriteOffsetBase:
>05e3							.fill 	2
.05e5					GXSpriteLow:
>05e5							.fill 	64
.0625					GXSpriteHigh:
>0625							.fill 	64
.ab79					Export_GXGraphicDraw:
.ab79	c9 40		cmp #$40			cmp 	#GCMD_Move					; low instructions don't use coordinates
.ab7b	b0 06		bcs $ab83			bcs 	_GDCoordinate
.ab7d	86 36		stx $36				stx 	gxzTemp0 					; save X/Y
.ab7f	84 37		sty $37				sty 	gxzTemp0+1
.ab81	80 4b		bra $abce			bra 	_GDExecuteA 				; and execute
.ab83					_GDCoordinate:
.ab83	48		pha				pha 								; save AXY
.ab84	da		phx				phx
.ab85	5a		phy				phy
.ab86	a2 03		ldx #$03			ldx 	#3 							; copy currentX to lastX
.ab88					_GDCopy1:
.ab88	bd c5 05	lda $05c5,x			lda 	gxCurrentX,x
.ab8b	9d c9 05	sta $05c9,x			sta 	gxLastX,x
.ab8e	ca		dex				dex
.ab8f	10 f7		bpl $ab88			bpl 	_GDCopy1
.ab91	68		pla				pla 								; update Y
.ab92	8d c7 05	sta $05c7			sta 	gxCurrentY
.ab95	9c c8 05	stz $05c8			stz 	gxCurrentY+1
.ab98	68		pla				pla
.ab99	8d c5 05	sta $05c5			sta 	gxCurrentX
.ab9c	68		pla				pla 								; get A (command+X.1) back
.ab9d	48		pha				pha
.ab9e	29 01		and #$01			and 	#1 							; put LSB as MSB of Current.X
.aba0	8d c6 05	sta $05c6			sta 	gxCurrentX+1
.aba3	68		pla				pla 								; get command back
.aba4	29 fe		and #$fe			and 	#$FE 						; lose LSB, chuck the stray X bit
.aba6	48		pha				pha 								; push back.
.aba7	c9 52		cmp #$52			cmp 	#GCMD_SpriteMove 			; move sprite does not clip.
.aba9	f0 17		beq $abc2			beq 	_GDCopyToWorkArea
.abab	ad c6 05	lda $05c6			lda 	gxCurrentX+1 				; X < 256 X okay
.abae	f0 07		beq $abb7			beq 	_GDCheckY
.abb0	ad c5 05	lda $05c5			lda 	gxCurrentX 					; otherwise X < 320 = 256 + 64
.abb3	c9 40		cmp #$40			cmp 	#64
.abb5	b0 08		bcs $abbf			bcs 	_GDError1
.abb7					_GDCheckY:
.abb7	ad c7 05	lda $05c7			lda 	gxCurrentY 					; check Y < Height.
.abba	cd d9 05	cmp $05d9			cmp 	gxHeight
.abbd	90 03		bcc $abc2			bcc 	_GDCopyToWorkArea
.abbf					_GDError1:
.abbf	68		pla				pla
.abc0					_GDError2:
.abc0	38		sec				sec
.abc1	60		rts				rts
.abc2					_GDCopyToWorkArea:
.abc2	a2 07		ldx #$07			ldx 	#7 							; copy current and last to gxXY/12 work area
.abc4					_GDCopy2:
.abc4	bd c5 05	lda $05c5,x			lda 	gxCurrentX,x
.abc7	9d cd 05	sta $05cd,x			sta 	gxX0,x
.abca	ca		dex				dex
.abcb	10 f7		bpl $abc4			bpl 	_GDCopy2
.abcd	68		pla				pla 								; get command
.abce					_GDExecuteA:
.abce	c9 54		cmp #$54			cmp 	#GRFirstFreeCode*2 			; bad ?
.abd0	b0 ee		bcs $abc0			bcs 	_GDError2
.abd2	aa		tax				tax
.abd3	7c 25 ab	jmp ($ab25,x)			jmp 	(GRVectorTable,x)
.abd6					GXMove:
.abd6	18		clc				clc
.abd7	60		rts				rts
.abd8					GRUndefined:
>abd8	db						.byte 	$DB 						; causes a break in the emulator
.abd9					GXFillCircle:
.abd9	a9 ff		lda #$ff			lda 	#255
.abdb	80 02		bra $abdf			bra 	GXCircle
.abdd					GXFrameCircle:
.abdd	a9 00		lda #$00			lda 	#0
.abdf					GXCircle:
.abdf	8d 68 06	sta $0668			sta 	gxIsFillMode					; save Fill flag
.abe2	ad d6 05	lda $05d6			lda 	gxBitmapsOn
.abe5	f0 26		beq $ac0d			beq 	_GXCFail
.abe7	20 3d b4	jsr $b43d			jsr 	GXSortXY 					; topleft/bottomright
.abea	20 15 b3	jsr $b315			jsr 	GXOpenBitmap 				; start drawing
.abed	20 df ac	jsr $acdf			jsr 	GXCircleSetup 				; set up for drawing
.abf0	9c 69 06	stz $0669			stz 	gxYChanged
.abf3					_GXCircleDraw:
.abf3	ad 66 06	lda $0666			lda 	gXCentre					; while x <= y
.abf6	cd 67 06	cmp $0667			cmp 	gYCentre
.abf9	90 0a		bcc $ac05			bcc 	_GXCircleContinue
.abfb	d0 03		bne $ac00			bne 	_GXNoLast
.abfd	20 12 ac	jsr $ac12			jsr 	GXPlot1
.ac00					_GXNoLast:
.ac00	20 1d b3	jsr $b31d			jsr 	GXCloseBitmap 				; close the bitmap
.ac03	18		clc				clc
.ac04	60		rts				rts
.ac05					_GXCircleContinue:
.ac05	20 0f ac	jsr $ac0f			jsr 	GXPlot2 					; draw it
.ac08	20 8c ac	jsr $ac8c			jsr 	GXCircleMove 				; adjust the coordinates
.ac0b	80 e6		bra $abf3			bra 	_GXCircleDraw
.ac0d					_GXCFail:
.ac0d	38		sec				sec
.ac0e	60		rts				rts
.ac0f					GXPlot2:
.ac0f	20 12 ac	jsr $ac12			jsr 	GXPlot1 						; plot and swap, fall through does twice
.ac12					GXPlot1:
.ac12	ad 67 06	lda $0667			lda 	gYCentre 						; if y = 0, don't do it twice (xor)
.ac15	f0 03		beq $ac1a			beq 	_GXPlot1Only
.ac17	20 36 ac	jsr $ac36			jsr 	GXPlot0 						; plot and negate
.ac1a					_GXPlot1Only:
.ac1a	20 36 ac	jsr $ac36			jsr 	GXPlot0 						; twice, undoing negation
.ac1d	ad 66 06	lda $0666			lda 	gXCentre 						; swap X and Y
.ac20	ae 67 06	ldx $0667			ldx	 	gYCentre
.ac23	8d 67 06	sta $0667			sta 	gYCentre
.ac26	8e 66 06	stx $0666			stx 	gXCentre
.ac29	ad 69 06	lda $0669			lda 	gxYChanged 						; toggle Y Changed flag
.ac2c	a9 ff		lda #$ff			lda 	#$FF
.ac2e	8d 69 06	sta $0669			sta 	gxYChanged
.ac31	60		rts				rts
.ac32	20 36 ac	jsr $ac36			jsr 	GXPlot0 						; do once
.ac35	60		rts				rts
.ac36	ad 68 06	lda $0668	GXPlot0:lda 	gxIsFillMode 					; outline mode, always draw as X or Y will change
.ac39	f0 05		beq $ac40			beq 	_GXPlot0Always
.ac3b	ad 69 06	lda $0669			lda 	gxYChanged						; fill mode, only draw if changed.
.ac3e	f0 2d		beq $ac6d			beq 	GXPlot0Exit
.ac40					_GXPlot0Always:
.ac40	a2 02		ldx #$02			ldx 	#2 								; copy Y1-A => Y0
.ac42	ad 67 06	lda $0667			lda 	gYCentre
.ac45	20 6e ac	jsr $ac6e			jsr 	GXSubCopy
.ac48	a2 00		ldx #$00			ldx 	#0 								; copy X1-A => X0,
.ac4a	ad 66 06	lda $0666			lda 	gXCentre
.ac4d	20 6e ac	jsr $ac6e			jsr 	GXSubCopy
.ac50	48		pha				pha 									; save last offset X
.ac51	20 25 b3	jsr $b325			jsr 	GXPositionCalc 					; calculate position/offset.
.ac54	68		pla				pla
.ac55	0a		asl a				asl 	a 								; store 2 x last offset in gxzTemp0
.ac56	85 36		sta $36				sta 	gxzTemp0
.ac58	64 37		stz $37				stz 	gxzTemp0+1
.ac5a	26 37		rol $37				rol 	gxzTemp0+1
.ac5c	ad 68 06	lda $0668			lda 	gxIsFillMode
.ac5f	69 80		adc #$80			adc 	#128
.ac61	20 fe af	jsr $affe			jsr 	GXDrawLineTemp0 				; routine from Rectangle.
.ac64	38		sec				sec 									; GY = -GY
.ac65	a9 00		lda #$00			lda 	#0
.ac67	ed 67 06	sbc $0667			sbc 	gYCentre
.ac6a	8d 67 06	sta $0667			sta 	gYCentre
.ac6d					GXPlot0Exit:
.ac6d	60		rts				rts
.ac6e					GXSubCopy:
.ac6e	85 36		sta $36				sta 	gxzTemp0
.ac70	64 37		stz $37				stz 	gxzTemp0+1
.ac72	29 80		and #$80			and 	#$80
.ac74	f0 02		beq $ac78			beq 	_GXNoSx
.ac76	c6 37		dec $37				dec 	gxzTemp0+1
.ac78					_GXNoSx:
.ac78	38		sec				sec
.ac79	bd d1 05	lda $05d1,x			lda 	gXX1,x
.ac7c	e5 36		sbc $36				sbc 	gxzTemp0
.ac7e	9d cd 05	sta $05cd,x			sta 	gXX0,x
.ac81	bd d2 05	lda $05d2,x			lda 	gXX1+1,x
.ac84	e5 37		sbc $37				sbc 	gxzTemp0+1
.ac86	9d ce 05	sta $05ce,x			sta 	gXX0+1,x
.ac89	a5 36		lda $36				lda 	gxzTemp0 						; return A
.ac8b	60		rts				rts
.ac8c					GXCircleMove:
.ac8c	9c 69 06	stz $0669			stz 	gxYChanged 					; clear Y changed flag
.ac8f	a5 39		lda $39				lda 	gxzTemp1+1 					; check sign of D
.ac91	10 0d		bpl $aca0			bpl 	_GXEMPositive
.ac93	ee 66 06	inc $0666			inc 	gXCentre 					; X++
.ac96	ad 66 06	lda $0666			lda 	gXCentre
.ac99	20 bf ac	jsr $acbf			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.ac9c	a9 06		lda #$06			lda 	#6  						; and add 6
.ac9e	80 15		bra $acb5			bra 	_GXEMAddD
.aca0					_GXEMPositive:
.aca0	ee 66 06	inc $0666			inc 	gXCentre					; X++
.aca3	ce 67 06	dec $0667			dec 	gyCentre 					; Y--
.aca6	38		sec				sec 								; calculate X-Y
.aca7	ad 66 06	lda $0666			lda 	gXCentre
.acaa	ed 67 06	sbc $0667			sbc 	gYCentre
.acad	20 bf ac	jsr $acbf			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.acb0	a9 0a		lda #$0a			lda 	#10  						; and add 10
.acb2	ce 69 06	dec $0669			dec 	gxYChanged
.acb5					_GXEMAddD:
.acb5	18		clc				clc
.acb6	65 38		adc $38				adc 	gxzTemp1
.acb8	85 38		sta $38				sta 	gxzTemp1
.acba	90 02		bcc $acbe			bcc 	_GXEMNoCarry
.acbc	e6 39		inc $39				inc 	gxzTemp1+1
.acbe					_GXEMNoCarry:
.acbe	60		rts				rts
.acbf					_GXAdd4TimesToD:
.acbf	85 36		sta $36				sta 	gxzTemp0 					; make 16 bit signed.
.acc1	29 80		and #$80			and 	#$80
.acc3	f0 02		beq $acc7			beq 	_GXA4Unsigned
.acc5	a9 ff		lda #$ff			lda 	#$FF
.acc7					_GXA4Unsigned:
.acc7	85 37		sta $37				sta 	gxzTemp0+1
.acc9	06 36		asl $36				asl 	gxzTemp0  					; x 4
.accb	26 37		rol $37				rol 	gxzTemp0+1
.accd	06 36		asl $36				asl 	gxzTemp0
.accf	26 37		rol $37				rol 	gxzTemp0+1
.acd1	18		clc				clc 								; add
.acd2	a5 36		lda $36				lda		gxzTemp0
.acd4	65 38		adc $38				adc 	gxzTemp1
.acd6	85 38		sta $38				sta 	gxzTemp1
.acd8	a5 37		lda $37				lda		gxzTemp0+1
.acda	65 39		adc $39				adc 	gxzTemp1+1
.acdc	85 39		sta $39				sta 	gxzTemp1+1
.acde	60		rts				rts
.acdf					GXCircleSetup:
.acdf	38		sec				sec
.ace0	ad d3 05	lda $05d3			lda 	gxY1
.ace3	ed cf 05	sbc $05cf			sbc 	gxY0
.ace6	4a		lsr a				lsr 	a
.ace7	8d 65 06	sta $0665			sta 	gxRadius
.acea	a2 00		ldx #$00			ldx 	#0
.acec	20 0e ad	jsr $ad0e			jsr 	_GXCalculateCentre
.acef	a2 02		ldx #$02			ldx 	#2
.acf1	20 0e ad	jsr $ad0e			jsr 	_GXCalculateCentre
.acf4	9c 66 06	stz $0666			stz 	gXCentre
.acf7	ad 65 06	lda $0665			lda 	gxRadius
.acfa	8d 67 06	sta $0667			sta 	gYCentre
.acfd	0a		asl a				asl 	a 							; R x 2
.acfe	85 36		sta $36				sta 	gxzTemp0
.ad00	38		sec				sec
.ad01	a9 03		lda #$03			lda 	#3
.ad03	e5 36		sbc $36				sbc 	gxzTemp0
.ad05	85 38		sta $38				sta 	gxzTemp1
.ad07	a9 00		lda #$00			lda 	#0
.ad09	e9 00		sbc #$00			sbc 	#0
.ad0b	85 39		sta $39				sta 	gxzTemp1+1
.ad0d	60		rts				rts
.ad0e					_GXCalculateCentre:
.ad0e	38		sec				sec
.ad0f	bd d1 05	lda $05d1,x			lda 	gxX1,x
.ad12	7d cd 05	adc $05cd,x			adc 	gXX0,x
.ad15	9d d1 05	sta $05d1,x			sta 	gXX1,x
.ad18	bd d2 05	lda $05d2,x			lda 	gXX1+1,x
.ad1b	7d ce 05	adc $05ce,x			adc 	gXX0+1,x
.ad1e	4a		lsr a				lsr 	a
.ad1f	9d d2 05	sta $05d2,x			sta 	gXX1+1,x
.ad22	7e d1 05	ror $05d1,x			ror 	gXX1,x
.ad25	60		rts				rts
.0665					gxRadius:
>0665							.fill 	1
.0666					gXCentre:
>0666							.fill 	1
.0667					gYCentre:
>0667							.fill 	1
.0668					gxIsFillMode:
>0668							.fill 	1
.0669					gxYChanged:
>0669							.fill  	1
=64000					ScreenSize200 = 320 * 200
=76800					ScreenSize240 = 320 * 240
.ad26					GXClearBitmap:
.ad26	ad d6 05	lda $05d6			lda 	gxBitmapsOn 				; check BMP running.
.ad29	f0 24		beq $ad4f			beq 	_GXCBFail
.ad2b	20 15 b3	jsr $b315			jsr 	GXOpenBitmap 				; start access
.ad2e	a0 07		ldy #$07			ldy 	#ScreenSize200 / 8192 		; X is pages to clear
.ad30	ad d9 05	lda $05d9			lda 	gxHeight
.ad33	c9 c8		cmp #$c8			cmp 	#200 						; 200 ?
.ad35	a0 09		ldy #$09			ldy 	#ScreenSize240 / 8192
.ad37					_GXCalcLastPage:
.ad37	98		tya				tya 								; add to base page
.ad38	18		clc				clc
.ad39	6d d7 05	adc $05d7			adc 	gxBasePage
.ad3c	85 0b		sta $0b				sta 	GXEditSlot  				; clear from this page back
.ad3e					_GXClearAll:
.ad3e	20 51 ad	jsr $ad51			jsr 	_GXClearBlock 				; clear 8k block
.ad41	c6 0b		dec $0b				dec 	GXEditSlot  				; back to previous
.ad43	a5 0b		lda $0b				lda 	GXEditSlot
.ad45	cd d7 05	cmp $05d7			cmp 	gxBasePage 					; until before base page
.ad48	b0 f4		bcs $ad3e			bcs 	_GXClearAll
.ad4a	20 1d b3	jsr $b31d			jsr 	GXCloseBitmap	 			; stop access
.ad4d	18		clc				clc
.ad4e	60		rts				rts
.ad4f					_GXCBFail:
.ad4f	38		sec				sec
.ad50	60		rts				rts
.ad51					_GXClearBlock:
.ad51	a9 00		lda #$00			lda 	#((GXMappingAddress) & $FF)
.ad53	85 38		sta $38				sta 	0+gxzTemp1
.ad55	a9 60		lda #$60			lda 	#((GXMappingAddress) >> 8)
.ad57	85 39		sta $39				sta 	1+gxzTemp1
.ad59					_GXCB0:
.ad59	a5 36		lda $36				lda 	gxzTemp0
.ad5b	a0 00		ldy #$00			ldy 	#0
.ad5d					_GXCB1:
.ad5d	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad5f	c8		iny				iny
.ad60	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad62	c8		iny				iny
.ad63	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad65	c8		iny				iny
.ad66	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad68	c8		iny				iny
.ad69	d0 f2		bne $ad5d			bne 	_GXCB1
.ad6b	e6 39		inc $39				inc 	gxzTemp1+1
.ad6d	a5 39		lda $39				lda 	gxzTemp1+1
.ad6f	c9 80		cmp #$80			cmp	 	#(GXMappingAddress >> 8)+$20
.ad71	d0 e6		bne $ad59			bne 	_GXCB0
.ad73	60		rts				rts
.ad74					GXInitialise:
.ad74	64 01		stz $01				stz 	1
.ad76	a9 01		lda #$01			lda 	#1
.ad78	8d 00 d0	sta $d000			sta 	$D000
.ad7b	18		clc				clc
.ad7c	9c d5 05	stz $05d5			stz 	GXSpritesOn
.ad7f	9c d6 05	stz $05d6			stz 	GXBitmapsOn
.ad82	a2 0f		ldx #$0f			ldx 	#15
.ad84					_GXIClear:
.ad84	9e c5 05	stz $05c5,x			stz 	gxCurrentX,x
.ad87	ca		dex				dex
.ad88	10 fa		bpl $ad84			bpl 	_GXIClear
.ad8a	20 25 ae	jsr $ae25			jsr 	GXClearSpriteStore
.ad8d	60		rts				rts
.ad8e					GXControlBitmap:
.ad8e	64 01		stz $01				stz 	1
.ad90	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.ad92	29 01		and #$01			and 	#1 							; set bitmap flag
.ad94	8d d6 05	sta $05d6			sta 	gxBitmapsOn
.ad97	4a		lsr a				lsr 	a 							; bit 0 into carry.
.ad98	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.ad9b	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.ad9d	29 f7		and #$f7			and 	#$F7 						; clear bitmap bit
.ad9f	90 02		bcc $ada3			bcc 	_CBNotOn
.ada1	09 08		ora #$08			ora 	#$08 						; bitmap on if 1 on 0 off
.ada3					_CBNotOn:
.ada3	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.ada6	a5 36		lda $36				lda 	gxzTemp0 					; get control settings (bits 0-2)
.ada8	29 07		and #$07			and 	#7
.adaa	8d 00 d1	sta $d100			sta 	$D100 						; write in Vicky Bitmap Control Register #0
.adad	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.adaf	d0 02		bne $adb3			bne 	_CBNotDefault
.adb1	a9 08		lda #$08			lda 	#8  						; if zero, use 8 e.g. bitmap at $10000
.adb3					_CBNotDefault:
.adb3	8d d7 05	sta $05d7			sta 	gxBasePage
.adb6	20 17 ae	jsr $ae17			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.adb9	a5 37		lda $37				lda 	gxzTemp0+1 					; copy address into Bitmap address registers
.adbb	8d 03 d1	sta $d103			sta 	$D103
.adbe	a5 36		lda $36				lda 	gxzTemp0
.adc0	8d 02 d1	sta $d102			sta 	$D102
.adc3	9c 01 d1	stz $d101			stz 	$D101
.adc6	a2 f0		ldx #$f0			ldx 	#240 						; height is 240
.adc8	ad 01 d0	lda $d001			lda 	$D001 						; read MCR bit 0
.adcb	29 01		and #$01			and 	#1
.adcd	f0 02		beq $add1			beq 	_CBHaveHeight
.adcf	a2 c8		ldx #$c8			ldx 	#200 						; if bit 0 set 320x200
.add1					_CBHaveHeight
.add1	8e d9 05	stx $05d9			stx 	gxHeight
.add4	18		clc				clc
.add5	60		rts				rts
.add6					GXControlSprite:
.add6	64 01		stz $01				stz 	1
.add8	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.adda	29 01		and #$01			and 	#1 							; set sprites flag
.addc	8d d5 05	sta $05d5			sta 	gxSpritesOn
.addf	4a		lsr a				lsr 	a 							; bit 0 into carry.
.ade0	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.ade3	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.ade5	29 df		and #$df			and 	#$DF 						; clear sprite bit
.ade7	90 02		bcc $adeb			bcc 	_CSNotOn
.ade9	09 20		ora #$20			ora 	#$20 						; sprite on if 1 on 0 off
.adeb					_CSNotOn:
.adeb	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.adee	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.adf0	d0 02		bne $adf4			bne 	_CSNotDefault
.adf2	a9 18		lda #$18			lda 	#24  						; if zero, use 24 e.g. sprites at $30000
.adf4					_CSNotDefault:
.adf4	8d d8 05	sta $05d8			sta 	gxSpritePage
.adf7	20 17 ae	jsr $ae17			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.adfa	a5 36		lda $36				lda 	zTemp0
.adfc	8d e3 05	sta $05e3			sta 	GXSpriteOffsetBase
.adff	a5 37		lda $37				lda 	zTemp0+1
.ae01	8d e4 05	sta $05e4			sta 	GXSpriteOffsetBase+1
.ae04	a2 00		ldx #$00			ldx 	#0 							; disable all sprites, clears all sprite memory.
.ae06					_CSClear:
.ae06	9e 00 d9	stz $d900,x			stz 	$D900,x
.ae09	9e 00 da	stz $da00,x			stz 	$DA00,x
.ae0c	ca		dex				dex
.ae0d	d0 f7		bne $ae06			bne 	_CSClear
.ae0f	9c e2 05	stz $05e2			stz 	GSCurrentSpriteAddr+1 		; no sprite selected.
.ae12	20 25 ae	jsr $ae25			jsr 	GXClearSpriteStore
.ae15	18		clc				clc
.ae16	60		rts				rts
.ae17					GXCalculateBaseAddress:
.ae17	85 36		sta $36				sta 	gxzTemp0
.ae19	64 37		stz $37				stz 	gxzTemp0+1
.ae1b	a9 05		lda #$05			lda 	#5
.ae1d					_GXShift:
.ae1d	06 36		asl $36				asl 	gxzTemp0
.ae1f	26 37		rol $37				rol 	gxzTemp0+1
.ae21	3a		dec a				dec		a
.ae22	d0 f9		bne $ae1d			bne 	_GXShift
.ae24	60		rts				rts
.ae25					GXClearSpriteStore:
.ae25	a2 3f		ldx #$3f			ldx 	#63 						; erase 64 sprite store elements
.ae27					_GXCSSLoop:
.ae27	9e 25 06	stz $0625,x			stz 	GXSpriteHigh,x
.ae2a	a9 80		lda #$80			lda 	#$80 						; set the 'hidden' bit.
.ae2c	9d e5 05	sta $05e5,x			sta 	GXSpriteLow,x
.ae2f	ca		dex				dex
.ae30	10 f5		bpl $ae27			bpl 	_GXCSSLoop
.ae32	60		rts				rts
.ae33					GXLine:
.ae33	ad d6 05	lda $05d6			lda 	GXBitmapsOn
.ae36	f0 28		beq $ae60			beq 	_GXLFail
.ae38	20 15 b3	jsr $b315			jsr 	GXOpenBitmap
.ae3b	20 5b b4	jsr $b45b			jsr 	GXSortY						; sort pairs so Y1 >= Y0 e.g. top to bottom.
.ae3e	20 06 af	jsr $af06			jsr 	GXLineSetup 				; the calculations in the linescanner constructor
.ae41	20 25 b3	jsr $b325			jsr 	GXPositionCalc 				; calculate position/offset.
.ae44					_GXDrawLoop:
.ae44	ac df 05	ldy $05df			ldy 	gsOffset 					; draw the pixel
.ae47	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.ae49	2d dd 05	and $05dd			and 	gxANDValue
.ae4c	4d dc 05	eor $05dc			eor 	gxEORValue
.ae4f	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.ae51	20 62 ae	jsr $ae62			jsr 	GXLineIsComplete 			; is the line complete ?
.ae54	f0 05		beq $ae5b			beq 	_GXLExit
.ae56	20 7d ae	jsr $ae7d			jsr 	GXLineAdvance 				; code as per advance method
.ae59	80 e9		bra $ae44			bra 	_GXDrawLoop
.ae5b					_GXLExit:
.ae5b	20 1d b3	jsr $b31d			jsr 	GXCloseBitmap
.ae5e	18		clc				clc
.ae5f	60		rts				rts
.ae60					_GXLFail:
.ae60	38		sec				sec
.ae61	60		rts				rts
.ae62					GXLineIsComplete:
.ae62	ad 6c 06	lda $066c			lda 	GXIsDiffYLarger 			; is dy larger
.ae65	d0 0f		bne $ae76			bne 	_GXLICCompareY 				; if so compare Y1/Y0
.ae67	ad cd 05	lda $05cd			lda 	GXX0 						; compare X, LSB and MSB
.ae6a	4d d1 05	eor $05d1			eor 	GXX1
.ae6d	d0 06		bne $ae75			bne 	_GXLICExit
.ae6f	ad ce 05	lda $05ce			lda 	GXX0+1
.ae72	4d d2 05	eor $05d2			eor 	GXX1+1
.ae75					_GXLICExit:
.ae75	60		rts				rts
.ae76					_GXLICCompareY:
.ae76	ad d3 05	lda $05d3			lda 	GXY1
.ae79	4d cf 05	eor $05cf			eor 	GXY0
.ae7c	60		rts				rts
.ae7d					GXLineAdvance:
.ae7d	18		clc				clc 								; add adjust to position
.ae7e	ad 6e 06	lda $066e			lda 	GXPosition
.ae81	6d 6f 06	adc $066f			adc 	GXAdjust
.ae84	8d 6e 06	sta $066e			sta 	GXPosition
.ae87	9c 71 06	stz $0671			stz 	GXAddSelect 				; clear add select flag
.ae8a	b0 05		bcs $ae91			bcs 	_GXLAOverflow 				; if carry out, overflowed.
.ae8c	cd 70 06	cmp $0670			cmp 	GXTotal 					; if exceeded total
.ae8f	90 0a		bcc $ae9b			bcc 	_GXLANoExtra
.ae91					_GXLAOverflow:
.ae91	ce 71 06	dec $0671			dec 	GXAddSelect 				; set addselect to $FF
.ae94	38		sec				sec 								; subtract total and write back
.ae95	ed 70 06	sbc $0670			sbc 	GXTotal
.ae98	8d 6e 06	sta $066e			sta 	GXPosition
.ae9b					_GXLANoExtra:
.ae9b	ad 6c 06	lda $066c			lda 	GXIsDiffYLarger
.ae9e	f0 0d		beq $aead			beq 	_GXDXLarger
.aea0	20 ff ae	jsr $aeff			jsr 	GXIncrementY
.aea3	ad 71 06	lda $0671			lda 	GXAddSelect
.aea6	f0 10		beq $aeb8			beq 	_GXLAExit
.aea8	20 b9 ae	jsr $aeb9			jsr 	GXAdjustX
.aeab	80 0b		bra $aeb8			bra 	_GXLAExit
.aead					_GXDXLarger:
.aead	20 b9 ae	jsr $aeb9			jsr 	GXAdjustX
.aeb0	ad 71 06	lda $0671			lda 	GXAddSelect
.aeb3	f0 03		beq $aeb8			beq 	_GXLAExit
.aeb5	20 ff ae	jsr $aeff			jsr 	GXIncrementY
.aeb8					_GXLAExit:
.aeb8	60		rts				rts
.aeb9					GXAdjustX:
.aeb9	ad 6d 06	lda $066d			lda 	GXDXNegative
.aebc	10 25		bpl $aee3			bpl 	_GXAXRight
.aebe	ad cd 05	lda $05cd			lda 	GXX0
.aec1	d0 03		bne $aec6			bne 	_GXAXNoBorrow
.aec3	ce ce 05	dec $05ce			dec 	GXX0+1
.aec6					_GXAXNoBorrow:
.aec6	ce cd 05	dec $05cd			dec 	GXX0
.aec9	ce df 05	dec $05df			dec 	gsOffset 					; pixel left
.aecc	ad df 05	lda $05df			lda 	gsOffset
.aecf	c9 ff		cmp #$ff			cmp 	#$FF
.aed1	d0 0f		bne $aee2			bne 	_GXAYExit 					; underflow
.aed3	c6 3d		dec $3d				dec 	gxzScreen+1 					; borrow
.aed5	a5 3d		lda $3d				lda 	gxzScreen+1 					; gone off page
.aed7	c9 60		cmp #$60			cmp 	#GXMappingAddress >> 8
.aed9	b0 07		bcs $aee2			bcs 	_GXAYExit
.aedb	18		clc				clc
.aedc	69 20		adc #$20			adc 	#$20 						; fix up
.aede	85 3d		sta $3d				sta 	gxzScreen+1
.aee0	c6 0b		dec $0b				dec 	GXEditSlot 				; back one page
.aee2					_GXAYExit:
.aee2	60		rts				rts
.aee3					_GXAXRight:
.aee3	ee cd 05	inc $05cd			inc 	GXX0
.aee6	d0 03		bne $aeeb			bne 	_GXAXNoCarry
.aee8	ee ce 05	inc $05ce			inc 	GXX0+1
.aeeb					_GXAXNoCarry:
.aeeb	ee df 05	inc $05df			inc 	gsOffset 					; pixel right
.aeee	d0 0e		bne $aefe			bne 	_GXAXExit 					; if not overflowed, exit.
.aef0	e6 3d		inc $3d				inc 	gxzScreen+1 					; next line
.aef2	a5 3d		lda $3d				lda 	gxzScreen+1
.aef4	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.aef6	90 06		bcc $aefe			bcc 	_GXAXExit
.aef8	e9 20		sbc #$20			sbc 	#$20 						; fix up
.aefa	85 3d		sta $3d				sta 	gxzScreen+1
.aefc	e6 0b		inc $0b				inc 	GXEditSlot 				; next page
.aefe					_GXAXExit:
.aefe	60		rts				rts
.aeff					GXIncrementY:
.aeff	ee cf 05	inc $05cf			inc 	GXY0
.af02	20 7b b3	jsr $b37b			jsr 	GXMovePositionDown
.af05	60		rts				rts
.af06					GXLineSetup:
.af06	ad d3 05	lda $05d3			lda 	GXY1
.af09	38		sec				sec
.af0a	ed cf 05	sbc $05cf			sbc 	GXY0
.af0d	4a		lsr a				lsr 	a
.af0e	8d 6b 06	sta $066b			sta 	GXDiffY
.af11	9c 6d 06	stz $066d			stz 	GXDXNegative 				; clear -ve flag
.af14	38		sec				sec
.af15	ad d1 05	lda $05d1			lda 	GXX1
.af18	ed cd 05	sbc $05cd			sbc 	GXX0
.af1b	8d 6a 06	sta $066a			sta 	GXDiffX
.af1e	ad d2 05	lda $05d2			lda 	GXX1+1 						; calculate MSB
.af21	ed ce 05	sbc $05ce			sbc 	GXX0+1
.af24	6a		ror a				ror 	a 							; rotate bit into DiffX halving it
.af25	6e 6a 06	ror $066a			ror 	GXDiffX
.af28	0a		asl a				asl 	a
.af29	10 0c		bpl $af37			bpl 	_GDXNotNegative
.af2b	a9 00		lda #$00			lda 	#0 							; make absolute value of |dx|
.af2d	38		sec				sec
.af2e	ed 6a 06	sbc $066a			sbc 	GXDiffX
.af31	8d 6a 06	sta $066a			sta 	GXDiffX
.af34	ce 6d 06	dec $066d			dec 	GXDXNegative 				; -ve flag = $FF.
.af37					_GDXNotNegative:
.af37	9c 6c 06	stz $066c			stz 	GXIsDiffYLarger 			; clear larger flag
.af3a	ad 6b 06	lda $066b			lda 	GXDiffY 					; set adjust and total.
.af3d	8d 6f 06	sta $066f			sta 	GXAdjust
.af40	ad 6a 06	lda $066a			lda 	GXDiffX
.af43	8d 70 06	sta $0670			sta 	GXTotal
.af46	ad 6b 06	lda $066b			lda 	GXDiffY 					; if dy > dx
.af49	cd 6a 06	cmp $066a			cmp 	GXDiffX
.af4c	90 0f		bcc $af5d			bcc 	_GDXNotLarger
.af4e	ce 6c 06	dec $066c			dec 	GXIsDiffYLarger 			; set the dy larger flag
.af51	ad 6a 06	lda $066a			lda 	GXDiffX 					; set adjust and total other way round
.af54	8d 6f 06	sta $066f			sta 	GXAdjust
.af57	ad 6b 06	lda $066b			lda 	GXDiffY
.af5a	8d 70 06	sta $0670			sta 	GXTotal
.af5d					_GDXNotLarger:
.af5d	ad 70 06	lda $0670			lda 	GXTotal
.af60	4a		lsr a				lsr 	a
.af61	8d 6e 06	sta $066e			sta 	GXPosition
.af64	60		rts				rts
.066a					GXDiffX:
>066a							.fill 	1
.066b					GXDiffY:
>066b							.fill 	1
.066c					GXIsDiffYLarger:
>066c							.fill 	1
.066d					GXDXNegative:
>066d							.fill 	1
.066e					GXPosition:
>066e							.fill 	1
.066f					GXAdjust:
>066f							.fill 	1
.0670					GXTotal:
>0670							.fill 	1
.0671					GXAddSelect:
>0671							.fill 	1
.af65					GXSetColourMode:
.af65	a6 36		ldx $36				ldx 	gxzTemp0
.af67	8e db 05	stx $05db			stx 	gxColour 								; set colour
.af6a	a5 37		lda $37				lda 	gxzTemp0+1 								;
.af6c	8d da 05	sta $05da			sta 	gxMode 									; set mode
.af6f	29 03		and #$03			and 	#3 										; only interested in bits 0-3
.af71	9c dd 05	stz $05dd			stz 	gxANDValue 								; initially AND with 0, and EOR with Colour
.af74	ae db 05	ldx $05db			ldx 	gxColour
.af77	8e dc 05	stx $05dc			stx 	gxEORValue
.af7a	c9 02		cmp #$02			cmp 	#2 										; if mode 2/3 And with colour
.af7c	90 03		bcc $af81			bcc 	_GXSDCNotAndColour
.af7e	8e dd 05	stx $05dd			stx 	gxANDValue
.af81					_GXSDCNotAndColour:
.af81	d0 03		bne $af86			bne 	_GXSDCNotAnd 							; mode 2, Don't EOR with colour
.af83	9c dc 05	stz $05dc			stz 	gxEORValue
.af86					_GXSDCNotAnd:
.af86	4a		lsr a				lsr 	a 										; if bit 0 set, 1's complement AND value
.af87	90 08		bcc $af91			bcc 	_GXSDCNoFlip
.af89	ad dd 05	lda $05dd			lda	 	gxANDValue
.af8c	49 ff		eor #$ff			eor 	#$FF
.af8e	8d dd 05	sta $05dd			sta 	gxANDValue
.af91					_GXSDCNoFlip:
.af91	18		clc				clc
.af92	60		rts				rts
.af93					GXPlotPoint:
.af93	20 15 b3	jsr $b315			jsr 	GXOpenBitmap 				; start drawing
.af96	20 25 b3	jsr $b325			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.af99	ac df 05	ldy $05df			ldy 	gsOffset
.af9c	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.af9e	2d dd 05	and $05dd			and 	gxANDValue
.afa1	4d dc 05	eor $05dc			eor 	gxEORValue
.afa4	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.afa6	20 1d b3	jsr $b31d			jsr 	GXCloseBitmap 				; stop drawing and exit
.afa9	18		clc				clc
.afaa	60		rts				rts
.afab					GXFillRectangle:
.afab	38		sec				sec
.afac	80 01		bra $afaf			bra 	GXRectangle
.afae					GXFrameRectangle:
.afae	18		clc				clc
.afaf					GXRectangle:
.afaf	ad d6 05	lda $05d6			lda 	gxBitmapsOn
.afb2	f0 35		beq $afe9			beq 	_GXRFail
.afb4	08		php				php 								; save Fill flag (CS)
.afb5	20 15 b3	jsr $b315			jsr 	GXOpenBitmap 				; start drawing
.afb8	20 3d b4	jsr $b43d			jsr 	GXSortXY 					; sort both X and Y so top left/bottom right
.afbb	20 25 b3	jsr $b325			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.afbe	38		sec				sec 								; sec = Draw line
.afbf	20 eb af	jsr $afeb			jsr 	GXDrawLineX1X0 				; draw a line length X1-X0
.afc2	ad cf 05	lda $05cf			lda 	gxY0 						; reached end of rectangle ?
.afc5	cd d3 05	cmp $05d3			cmp 	gxY1
.afc8	f0 19		beq $afe3			beq 	_GXRectangleExit
.afca					_GXRectLoop:
.afca	20 7b b3	jsr $b37b			jsr 	GXMovePositionDown 			; down one.
.afcd	ee cf 05	inc $05cf			inc 	gxY0 						; change Y pos
.afd0	ad cf 05	lda $05cf			lda 	gxY0 						; reached last line
.afd3	cd d3 05	cmp $05d3			cmp 	gXY1
.afd6	f0 07		beq $afdf			beq 	_GXLastLine
.afd8	28		plp				plp 								; get flag back
.afd9	08		php				php
.afda	20 eb af	jsr $afeb			jsr 	GXDrawLineX1X0 				; draw horizontal line
.afdd	80 eb		bra $afca			bra 	_GXRectLoop
.afdf					_GXLastLine:
.afdf	38		sec				sec
.afe0	20 eb af	jsr $afeb			jsr 	GXDrawLineX1X0
.afe3					_GXRectangleExit:
.afe3	68		pla				pla 								; throw fill flag.
.afe4	20 1d b3	jsr $b31d			jsr 	GXCloseBitmap 				; stop drawing and exit
.afe7	18		clc				clc
.afe8	60		rts				rts
.afe9					_GXRFail:
.afe9	38		sec				sec
.afea	60		rts				rts
.afeb					GXDrawLineX1X0:
.afeb	08		php				php 								; save solid/either-end
.afec	38		sec				sec
.afed	ad d1 05	lda $05d1			lda		gXX1
.aff0	ed cd 05	sbc $05cd			sbc 	gXX0
.aff3	85 36		sta $36				sta 	gxzTemp0
.aff5	ad d2 05	lda $05d2			lda 	gXX1+1
.aff8	ed ce 05	sbc $05ce			sbc 	gXX0+1
.affb	85 37		sta $37				sta 	gxzTemp0+1
.affd	28		plp				plp
.affe					GXDrawLineTemp0:
.affe	a5 3c		lda $3c				lda 	gxzScreen 						; push gxzScreen, gsOffset and GXEditSlot on stack
.b000	48		pha				pha
.b001	a5 3d		lda $3d				lda 	gxzScreen+1
.b003	48		pha				pha
.b004	ad df 05	lda $05df			lda 	gsOffset
.b007	48		pha				pha
.b008	a5 0b		lda $0b				lda 	GXEditSlot
.b00a	48		pha				pha
.b00b	ac df 05	ldy $05df			ldy 	gsOffset 					; Y offset
.b00e	90 1e		bcc $b02e			bcc 	_GXDLTEndPoints 			; if CC draw end points only.
.b010					_GXDLTLine:
.b010	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.b012	2d dd 05	and $05dd			and 	gxANDValue
.b015	4d dc 05	eor $05dc			eor 	gxEORValue
.b018	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b01a	a5 36		lda $36				lda 	gxzTemp0 					; decrement counter
.b01c	d0 04		bne $b022			bne 	_GXDLTNoBorrow
.b01e	c6 37		dec $37				dec 	gxzTemp0+1 					; borrow, if goes -ve then exit
.b020	30 2e		bmi $b050			bmi 	_GXDLTExit
.b022					_GXDLTNoBorrow:
.b022	c6 36		dec $36				dec 	gxzTemp0
.b024	c8		iny				iny 								; next slot.
.b025	d0 e9		bne $b010			bne 	_GXDLTLine
.b027	e6 3d		inc $3d				inc 	gxzScreen+1 					; carry to next
.b029	20 5e b0	jsr $b05e			jsr 	GXDLTCheckWrap				; check for new page.
.b02c	80 e2		bra $b010			bra 	_GXDLTLine
.b02e					_GXDLTEndPoints:
.b02e	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.b030	2d dd 05	and $05dd			and 	gxANDValue
.b033	4d dc 05	eor $05dc			eor 	gxEORValue
.b036	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b038	98		tya				tya 								; advance to right side
.b039	18		clc				clc
.b03a	65 36		adc $36				adc 	gxzTemp0
.b03c	a8		tay				tay
.b03d	a5 3d		lda $3d				lda 	gxzScreen+1
.b03f	65 37		adc $37				adc 	gxzTemp0+1
.b041	85 3d		sta $3d				sta 	gxzScreen+1
.b043	20 5e b0	jsr $b05e			jsr 	GXDLTCheckWrap 			; fix up.
.b046	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.b048	2d dd 05	and $05dd			and 	gxANDValue
.b04b	4d dc 05	eor $05dc			eor 	gxEORValue
.b04e	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b050					_GXDLTExit:
.b050	68		pla				pla
.b051	85 0b		sta $0b				sta 	GXEditSlot
.b053	68		pla				pla
.b054	8d df 05	sta $05df			sta 	gsOffset
.b057	68		pla				pla
.b058	85 3d		sta $3d				sta 	gxzScreen+1
.b05a	68		pla				pla
.b05b	85 3c		sta $3c				sta 	gxzScreen
.b05d	60		rts				rts
.b05e					GXDLTCheckWrap:
.b05e	a5 3d		lda $3d				lda 	gxzScreen+1 					; check end of page
.b060	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8)
.b062	90 06		bcc $b06a			bcc 	_GXDLTCWExit
.b064	e9 20		sbc #$20			sbc 	#$20 						; fix up
.b066	85 3d		sta $3d				sta 	gxzScreen+1
.b068	e6 0b		inc $0b				inc 	GXEditSlot
.b06a					_GXDLTCWExit:
.b06a	60		rts				rts
.b06b					GXDrawGraphicElement:
.b06b	8d 72 06	sta $0672			sta 	gxSize 						; save size
.b06e	3a		dec a				dec 	a
.b06f	8d 73 06	sta $0673			sta 	gxMask 						; and mask
.b072	ad d6 05	lda $05d6			lda 	gxBitmapsOn 				; check BMP on
.b075	f0 67		beq $b0de			beq 	_GXSLFail
.b077	ad cf 05	lda $05cf			lda 	gxY0 						; push Y on stack
.b07a	48		pha				pha
.b07b	8c 75 06	sty $0675			sty 	gxAcquireVector+1 			; and acquisition vector
.b07e	8e 74 06	stx $0674			stx 	gxAcquireVector
.b081	20 15 b3	jsr $b315			jsr 	gxOpenBitmap 				; open the bitmap.
.b084	ad 77 06	lda $0677			lda 	gxUseMode 					; scale bits
.b087	4a		lsr a				lsr 	a
.b088	4a		lsr a				lsr 	a
.b089	4a		lsr a				lsr 	a
.b08a	29 07		and #$07			and		#7
.b08c	1a		inc a				inc 	a
.b08d	8d 76 06	sta $0676			sta 	gxScale
.b090	64 38		stz $38				stz 	gxzTemp1					; start first line
.b092					_GXGELoop:
.b092	a5 38		lda $38				lda 	gxzTemp1 					; current line number to read.
.b094	2c 77 06	bit $0677			bit 	gxUseMode 					; check for flip.
.b097	10 06		bpl $b09f			bpl		_GXNoVFlip
.b099	ad 73 06	lda $0673			lda 	gxMask
.b09c	38		sec				sec
.b09d	e5 38		sbc $38				sbc 	gxzTemp1
.b09f					_GXNoVFlip:
.b09f	aa		tax				tax 								; get the Xth line.
.b0a0	20 e0 b0	jsr $b0e0			jsr 	_GXCallAcquire 				; get that data.
.b0a3	ad 76 06	lda $0676			lda 	gxScale 					; do scale identical copies of that line.
.b0a6	85 39		sta $39				sta 	gxzTemp1+1
.b0a8					_GXGELoop2:
.b0a8	ad cf 05	lda $05cf			lda 	gxY0 						; off screen
.b0ab	cd d9 05	cmp $05d9			cmp 	gxHeight
.b0ae	b0 10		bcs $b0c0			bcs 	_GXDGEExit
.b0b0	20 e3 b0	jsr $b0e3			jsr 	GXRenderOneLine 			; render line
.b0b3	c6 39		dec $39				dec 	gxzTemp1+1 					; scale times.
.b0b5	d0 f1		bne $b0a8			bne 	_GXGELoop2
.b0b7	e6 38		inc $38				inc 	gxzTemp1 					; done all lines.
.b0b9	a5 38		lda $38				lda 	gxzTemp1
.b0bb	cd 72 06	cmp $0672			cmp 	gxSize
.b0be	d0 d2		bne $b092			bne 	_GXGELoop
.b0c0					_GXDGEExit:
.b0c0	68		pla				pla 								; restore Y for next time
.b0c1	8d cf 05	sta $05cf			sta 	gxY0
.b0c4	ae 76 06	ldx $0676			ldx 	gxScale 					; get scale (1-8)
.b0c7					_GXShiftLeft:
.b0c7	18		clc				clc
.b0c8	ad 72 06	lda $0672			lda 	gxSize
.b0cb	6d cd 05	adc $05cd			adc 	gxX0
.b0ce	8d cd 05	sta $05cd			sta 	gxX0
.b0d1	90 03		bcc $b0d6			bcc 	_GXSLNoCarry
.b0d3	ee ce 05	inc $05ce			inc 	gxX0+1
.b0d6					_GXSLNoCarry:
.b0d6	ca		dex				dex
.b0d7	d0 ee		bne $b0c7			bne 	_GXShiftLeft
.b0d9	20 1d b3	jsr $b31d			jsr 	GXCloseBitmap
.b0dc	18		clc				clc
.b0dd	60		rts				rts
.b0de					_GXSLFail:
.b0de	38		sec				sec
.b0df	60		rts				rts
.b0e0					_GXCallAcquire:
.b0e0	6c 74 06	jmp ($0674)			jmp 	(gxAcquireVector)
.b0e3					GXRenderOneLine:
.b0e3	20 25 b3	jsr $b325			jsr 	GXPositionCalc 				; calculate position/offset.
.b0e6	ac df 05	ldy $05df			ldy 	gsOffset 					; Y contains position.
.b0e9	64 3a		stz $3a				stz 	gxzTemp2 					; do size pixels
.b0eb					_GXROLLoop1:
.b0eb	ad 76 06	lda $0676			lda 	gxScale 					; set to do 'scale' times
.b0ee	85 3b		sta $3b				sta 	gxzTemp2+1
.b0f0					_GXROLLoop2:
.b0f0	a5 3a		lda $3a				lda 	gxzTemp2 					; get current pixel
.b0f2	2c da 05	bit $05da			bit 	gxMode 						; check H Flip
.b0f5	50 06		bvc $b0fd			bvc 	_GXNoHFlip
.b0f7	ad 73 06	lda $0673			lda 	gxMask
.b0fa	38		sec				sec
.b0fb	e5 3a		sbc $3a				sbc 	gxzTemp2
.b0fd					_GXNoHFlip:
.b0fd	aa		tax				tax 								; read from the pixel buffer
.b0fe	bd 7b 05	lda $057b,x			lda 	gxPixelBuffer,x
.b101	d0 07		bne $b10a			bne 	_GXDraw 					; draw if non zero
.b103	ad 77 06	lda $0677			lda 	gxUseMode 					; check to see if solid background
.b106	29 04		and #$04			and 	#4
.b108	f0 0a		beq $b114			beq 	_GXZeroPixel
.b10a					_GXDraw:
.b10a	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.b10c	2d dd 05	and $05dd			and 	gxANDValue
.b10f	5d 7b 05	eor $057b,x			eor 	gxPixelBuffer,x
.b112	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b114					_GXZeroPixel:
.b114	c8		iny				iny 								; advance pointer
.b115	d0 05		bne $b11c			bne 	_GXNoShift
.b117	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.b119	20 5e b0	jsr $b05e			jsr 	GXDLTCheckWrap				; check for new page.
.b11c					_GXNoShift:
.b11c	c6 3b		dec $3b				dec 	gxzTemp2+1 					; do the inner loop gxScale times.
.b11e	d0 d0		bne $b0f0			bne 	_GXROLLoop2
.b120	e6 3a		inc $3a				inc 	gxzTemp2 					; next pixel.
.b122	a5 3a		lda $3a				lda 	gxzTemp2
.b124	cd 72 06	cmp $0672			cmp 	gxSize
.b127	d0 c2		bne $b0eb			bne 	_GXROLLoop1
.b129	ee cf 05	inc $05cf			inc 	gxY0
.b12c	60		rts				rts
.0672					gxSize:
>0672							.fill 	1
.0673					gxMask:
>0673							.fill 	1
.0674					gxAcquireVector:
>0674							.fill 	2
.0676					gxScale:
>0676							.fill 	1
.0677					gxUseMode:
>0677							.fill 	1
.b12d					GXFontHandler:
.b12d	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b12f	4d da 05	eor $05da			eor 	gxMode
.b132	8d 77 06	sta $0677			sta 	gxUseMode
.b135	64 37		stz $37				stz 	gxzTemp0+1 					; gxzTemp0 is font #
.b137	06 36		asl $36				asl	 	gxzTemp0 					; x 2
.b139	26 37		rol $37				rol	 	gxzTemp0+1
.b13b	06 36		asl $36				asl	 	gxzTemp0 					; x 4
.b13d	26 37		rol $37				rol	 	gxzTemp0+1
.b13f	06 36		asl $36				asl	 	gxzTemp0 					; x 8
.b141	26 37		rol $37				rol	 	gxzTemp0+1
.b143	a5 37		lda $37				lda 	gxzTemp0+1 					; put in page C0
.b145	09 c0		ora #$c0			ora 	#$C0
.b147	85 37		sta $37				sta 	gxzTemp0+1
.b149	a9 08		lda #$08			lda 	#8 							; size 8x8
.b14b	a2 53		ldx #$53			ldx 	#GXGetGraphicDataFont & $FF ; XY = Graphic Data retrieval routine
.b14d	a0 b1		ldy #$b1			ldy 	#GXGetGraphicDataFont >> 8
.b14f	20 6b b0	jsr $b06b			jsr 	GXDrawGraphicElement
.b152	60		rts				rts
.b153					GXGetGraphicDataFont:
.b153	8a		txa				txa 								; X->Y
.b154	a8		tay				tay
.b155	a6 01		ldx $01				ldx 	1 							; preserve old value
.b157	a9 01		lda #$01			lda 	#1 							; access page 1 (font memory)
.b159	85 01		sta $01				sta 	1
.b15b	b1 36		lda ($36),y			lda 	(gxzTemp0),y 				; read the font element.
.b15d	86 01		stx $01				stx 	1 							; put old value back.
.b15f	a2 00		ldx #$00			ldx 	#0 							; do 8 times
.b161					_GXExpand:
.b161	9e 7b 05	stz $057b,x			stz 	gxPixelBuffer,x 			; zero in pixel buffer
.b164	0a		asl a				asl 	a 							; shift bit 7 into C
.b165	90 08		bcc $b16f			bcc 	_GXNoPixel
.b167	48		pha				pha 								; if set, set pixel buffer to current colour.
.b168	ad db 05	lda $05db			lda 	gxColour
.b16b	9d 7b 05	sta $057b,x			sta 	gxPixelBuffer,x
.b16e	68		pla				pla
.b16f					_GXNoPixel:
.b16f	e8		inx				inx 								; do the whole byte.
.b170	e0 08		cpx #$08			cpx 	#8
.b172	d0 ed		bne $b161			bne 	_GXExpand
.b174	60		rts				rts
.b175					GXSpriteHandler:
.b175	ad d5 05	lda $05d5			lda 	gxSpritesOn 				; sprites on ?
.b178	f0 23		beq $b19d			beq 	_GXSHExit
.b17a	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b17c	4d da 05	eor $05da			eor 	gxMode
.b17f	8d 77 06	sta $0677			sta 	gxUseMode
.b182	a6 36		ldx $36				ldx 	gxzTemp0 					; sprite #
.b184	da		phx				phx
.b185	20 15 b3	jsr $b315			jsr 	GXOpenBitmap 				; can access sprite information
.b188	68		pla				pla
.b189	20 f6 b3	jsr $b3f6			jsr 	GXFindSprite 				; get the sprite address
.b18c	08		php				php
.b18d	20 1d b3	jsr $b31d			jsr 	GXCloseBitmap
.b190	28		plp				plp
.b191	b0 0a		bcs $b19d			bcs		_GXSHExit 					; exit if find failed.
.b193	ad 78 06	lda $0678			lda 	GXSizePixels 				; return size
.b196	a2 9e		ldx #$9e			ldx 	#GXSpriteAcquire & $FF
.b198	a0 b1		ldy #$b1			ldy 	#GXSpriteAcquire >> 8
.b19a	20 6b b0	jsr $b06b			jsr 	GXDrawGraphicElement
.b19d					_GXSHExit:
.b19d	60		rts				rts
.b19e					GXSpriteAcquire:
.b19e	ad d8 05	lda $05d8			lda 	GXSpritePage				; point to base page
.b1a1	85 0b		sta $0b				sta 	GXEditSlot
.b1a3	86 36		stx $36				stx 	zTemp0 						; row number x 1,2,3,4
.b1a5	a9 00		lda #$00			lda 	#0
.b1a7	ae 79 06	ldx $0679			ldx 	GXSizeBits
.b1aa					_GXTimesRowNumber:
.b1aa	18		clc				clc
.b1ab	65 36		adc $36				adc 	zTemp0
.b1ad	ca		dex				dex
.b1ae	10 fa		bpl $b1aa			bpl 	_GXTimesRowNumber
.b1b0	64 37		stz $37				stz 	gxzTemp0+1
.b1b2	0a		asl a				asl 	a 							; row x 2,4,6,8
.b1b3	26 37		rol $37				rol 	gxzTemp0+1
.b1b5	0a		asl a				asl 	a 							; row x 4,8,12,16
.b1b6	26 37		rol $37				rol 	gxzTemp0+1
.b1b8	0a		asl a				asl 	a 							; row x 8,16,24,32
.b1b9	26 37		rol $37				rol 	gxzTemp0+1
.b1bb	85 36		sta $36				sta 	gxzTemp0
.b1bd	18		clc				clc 								; add base address.
.b1be	a5 36		lda $36				lda 	gxzTemp0
.b1c0	6d 7b 06	adc $067b			adc 	GXSpriteOffset
.b1c3	85 36		sta $36				sta 	gxzTemp0
.b1c5	a5 37		lda $37				lda 	gxzTemp0+1
.b1c7	6d 7c 06	adc $067c			adc 	GXSpriteOffset+1
.b1ca					_GXSAFindPage:
.b1ca	c9 20		cmp #$20			cmp 	#$20 						; on this page
.b1cc	90 06		bcc $b1d4			bcc 	_GXSAFoundPage
.b1ce	e9 20		sbc #$20			sbc 	#$20 						; forward one page
.b1d0	e6 0b		inc $0b				inc 	GXEditSlot
.b1d2	80 f6		bra $b1ca			bra 	_GXSAFindPage
.b1d4					_GXSAFoundPage:
.b1d4	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; physical address of page.
.b1d6	85 37		sta $37				sta 	gxzTemp0+1 					; gxzTemp0 now points to the page
.b1d8	a0 00		ldy #$00			ldy 	#0
.b1da					_GXSACopyLoop:
.b1da	b1 36		lda ($36),y			lda 	(gxzTemp0),y
.b1dc	99 7b 05	sta $057b,y			sta 	gxPixelBuffer,y
.b1df	c8		iny				iny
.b1e0	cc 78 06	cpy $0678			cpy 	GXSizePixels
.b1e3	d0 f5		bne $b1da			bne 	_GXSACopyLoop
.b1e5	60		rts				rts
.b1e6					GXSelect:
.b1e6	ad d5 05	lda $05d5			lda 	gxSpritesOn
.b1e9	f0 22		beq $b20d			beq 	_GXSFail
.b1eb	a5 36		lda $36				lda 	gxzTemp0 					; illegal sprite #
.b1ed	c9 40		cmp #$40			cmp 	#64
.b1ef	b0 1c		bcs $b20d			bcs 	_GXSFail
.b1f1	8d e0 05	sta $05e0			sta 	GSCurrentSpriteID
.b1f4	a4 37		ldy $37				ldy 	gxzTemp0+1 					; control value.
.b1f6	a9 00		lda #$00			lda  	#0 							; multiply sprite # x 8 => A
.b1f8	06 36		asl $36				asl 	gxzTemp0
.b1fa	06 36		asl $36				asl 	gxzTemp0
.b1fc	06 36		asl $36				asl 	gxzTemp0
.b1fe	2a		rol a				rol 	a
.b1ff	69 d9		adc #$d9			adc 	#$D9 						; sprite area
.b201	8d e2 05	sta $05e2			sta 	GSCurrentSpriteAddr+1 		; address to GSCurrentSprite and gxzTemp
.b204	85 37		sta $37				sta 	gxzTemp0+1
.b206	a5 36		lda $36				lda 	gxzTemp0
.b208	8d e1 05	sta $05e1			sta 	GSCurrentSpriteAddr
.b20b	18		clc				clc
.b20c	60		rts				rts
.b20d					_GXSFail:
.b20d	38		sec				sec
.b20e	60		rts				rts
.b20f					GXSelectImage:
.b20f	ad d5 05	lda $05d5			lda 	gxSpritesOn
.b212	f0 74		beq $b288			beq 	_GXSIFail
.b214	ad e2 05	lda $05e2			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b217	f0 6f		beq $b288			beq 	_GXSIFail 					; (checking the MSB)
.b219	64 01		stz $01				stz 	1
.b21b	a5 37		lda $37				lda 	gxzTemp0+1 					; push show/hide on the stack.
.b21d	d0 6b		bne $b28a			bne 	_GXSIHide
.b21f	a5 36		lda $36				lda 	gxzTemp0 					; sprite image
.b221	48		pha				pha
.b222	20 15 b3	jsr $b315			jsr 	GXOpenBitmap
.b225	68		pla				pla
.b226	20 f6 b3	jsr $b3f6			jsr 	GXFindSprite
.b229	b0 5a		bcs $b285			bcs 	_GXSICloseFail 				; no image
.b22b	a0 01		ldy #$01			ldy 	#1
.b22d	ad e1 05	lda $05e1			lda 	GSCurrentSpriteAddr
.b230	85 36		sta $36				sta 	gxzTemp0
.b232	ad e2 05	lda $05e2			lda 	GSCurrentSpriteAddr+1
.b235	85 37		sta $37				sta 	gxzTemp0+1
.b237	ad 7b 06	lda $067b			lda 	GXSpriteOffset
.b23a	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b23c	18		clc				clc
.b23d	ad 7c 06	lda $067c			lda 	GXSpriteOffset+1
.b240	6d e3 05	adc $05e3			adc 	GXSpriteOffsetBase
.b243	c8		iny				iny
.b244	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b246	ad e4 05	lda $05e4			lda 	GXSpriteOffsetBase+1
.b249	69 00		adc #$00			adc 	#0
.b24b	c8		iny				iny
.b24c	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b24e	ad 79 06	lda $0679			lda 	GXSizeBits 					; get raw size
.b251	49 03		eor #$03			eor 	#3 							; make it right (00=32 etc.)
.b253	2a		rol a				rol 	a 							; x 2
.b254	0a		asl a				asl 	a 							; x 4
.b255	0a		asl a				asl 	a 							; x 8
.b256	0a		asl a				asl 	a 							; x 16
.b257	0d 7a 06	ora $067a			ora 	GXSpriteLUT 				; Or with LUT
.b25a	0a		asl a				asl 	a 							; 1 shift
.b25b	09 01		ora #$01			ora 	#1 							; enable sprite.
.b25d	92 36		sta ($36)			sta 	(gxzTemp0) 					; and write back
.b25f	20 1d b3	jsr $b31d			jsr 	GXCloseBitmap
.b262	ae e0 05	ldx $05e0			ldx 	GSCurrentSpriteID 			; point to sprite entries.
.b265	bd 25 06	lda $0625,x			lda 	GXSpriteHigh,x 				; clear upper two bits of size
.b268	29 3f		and #$3f			and 	#$3F
.b26a	9d 25 06	sta $0625,x			sta 	GXSpriteHigh,x
.b26d	ad 79 06	lda $0679			lda 	GXSizeBits 					; get bit size
.b270	6a		ror a				ror 	a 							; shift into bits 6/7
.b271	6a		ror a				ror 	a
.b272	6a		ror a				ror 	a
.b273	29 c0		and #$c0			and 	#$C0
.b275	1d 25 06	ora $0625,x			ora 	GXSpriteHigh,x 				; put in  upper 2 bits of sprite data
.b278	9d 25 06	sta $0625,x			sta 	GXSpriteHigh,x
.b27b	bd e5 05	lda $05e5,x			lda 	GXSpriteLow,x 				; clear hidden flag.
.b27e	29 7f		and #$7f			and 	#$7F
.b280	9d e5 05	sta $05e5,x			sta 	GXSpriteLow,x
.b283	18		clc				clc
.b284	60		rts				rts
.b285					_GXSICloseFail:
.b285	20 1d b3	jsr $b31d			jsr 	GXCloseBitmap
.b288					_GXSIFail:
.b288	38		sec				sec
.b289	60		rts				rts
.b28a					_GXSIHide:
.b28a	ad e1 05	lda $05e1			lda 	GSCurrentSpriteAddr  		; get Sprite h/w address and write there
.b28d	85 36		sta $36				sta 	gxzTemp0
.b28f	ad e2 05	lda $05e2			lda 	GSCurrentSpriteAddr+1
.b292	85 37		sta $37				sta 	gxzTemp0+1
.b294	a9 00		lda #$00			lda 	#0
.b296	92 36		sta ($36)			sta 	(gxzTemp0)
.b298	ae e0 05	ldx $05e0			ldx 	GSCurrentSpriteID 			; get sprite ID
.b29b	bd e5 05	lda $05e5,x			lda 	GXSpriteLow,x 				; set the hidden bit.
.b29e	09 80		ora #$80			ora 	#$80
.b2a0	9d e5 05	sta $05e5,x			sta 	GXSpriteLow,x
.b2a3	18		clc				clc
.b2a4	60		rts				rts
.b2a5					GXMoveSprite:
.b2a5	ad d5 05	lda $05d5			lda 	gxSpritesOn
.b2a8	f0 65		beq $b30f			beq 	_GXSIFail
.b2aa	ad e2 05	lda $05e2			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b2ad	f0 60		beq $b30f			beq 	_GXSIFail
.b2af	85 37		sta $37				sta 	gxzTemp0+1
.b2b1	a0 04		ldy #$04			ldy 	#4
.b2b3	ad e1 05	lda $05e1			lda 	GSCurrentSpriteAddr
.b2b6	85 36		sta $36				sta 	gxzTemp0
.b2b8	ae e0 05	ldx $05e0			ldx 	GSCurrentSpriteID 			; get the size from the upper two bits
.b2bb	bd 25 06	lda $0625,x			lda 	GXSpriteHigh,x
.b2be	2a		rol a				rol 	a	 						; into bits 0,1.
.b2bf	2a		rol a				rol 	a
.b2c0	2a		rol a				rol 	a
.b2c1	29 03		and #$03			and 	#3
.b2c3	aa		tax				tax
.b2c4	bd 11 b3	lda $b311,x			lda 	_GXMSOffset,x 				; get 32-SpriteSize/2
.b2c7	48		pha				pha
.b2c8	18		clc				clc
.b2c9	6d cd 05	adc $05cd			adc 	gxX0						; copy position.
.b2cc	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2ce	c8		iny				iny
.b2cf	ad ce 05	lda $05ce			lda 	gxX0+1
.b2d2	69 00		adc #$00			adc 	#0
.b2d4	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2d6	c8		iny				iny
.b2d7	68		pla				pla
.b2d8	18		clc				clc
.b2d9	6d cf 05	adc $05cf			adc 	gxY0
.b2dc	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2de	a9 00		lda #$00			lda 	#0
.b2e0	69 00		adc #$00			adc 	#0
.b2e2	c8		iny				iny
.b2e3	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2e5	4e ce 05	lsr $05ce			lsr 	gxX0+1 						; divide X by 4
.b2e8	6e cd 05	ror $05cd			ror 	gxX0
.b2eb	4e cd 05	lsr $05cd			lsr 	gxX0
.b2ee	4e cf 05	lsr $05cf			lsr 	gxY0 						; divide Y by 4
.b2f1	4e cf 05	lsr $05cf			lsr 	gxY0
.b2f4	ae e0 05	ldx $05e0			ldx 	GSCurrentSpriteID 			; copy X/4 and Y/4 into the status bytes
.b2f7	bd e5 05	lda $05e5,x			lda 	GXSpriteLow,x
.b2fa	29 80		and #$80			and 	#$80
.b2fc	0d cd 05	ora $05cd			ora 	gxX0
.b2ff	9d e5 05	sta $05e5,x			sta 	GXSpriteLow,x
.b302	bd 25 06	lda $0625,x			lda 	GXSpriteHigh,x
.b305	29 c0		and #$c0			and 	#$C0
.b307	0d cf 05	ora $05cf			ora 	gxY0
.b30a	9d 25 06	sta $0625,x			sta 	GXSpriteHigh,x
.b30d	18		clc				clc
.b30e	60		rts				rts
.b30f					_GXSIFail:
.b30f	38		sec				sec
.b310	60		rts				rts
.b311					_GXMSOffset:
>b311	1c						.byte 	32-8/2
>b312	18						.byte 	32-16/2
>b313	14						.byte 	32-24/2
>b314	10						.byte 	32-32/2
.b315					GXOpenBitmap:
.b315	78		sei				sei 								; no interrupts here
.b316	a5 0b		lda $0b				lda 	GXEditSlot 					; Save the original LUT slot value
.b318	8d de 05	sta $05de			sta 	gxOriginalLUTValue
.b31b	58		cli				cli
.b31c	60		rts				rts
.b31d					GXCloseBitmap:
.b31d	78		sei				sei
.b31e	ad de 05	lda $05de			lda 	gxOriginalLUTValue 			; restore LUT slot value
.b321	85 0b		sta $0b				sta 	GXEditSlot
.b323	58		cli				cli
.b324	60		rts				rts
.b325					GXPositionCalc:
.b325	a5 36		lda $36				lda 	gxzTemp0 					; save temp memory slot
.b327	48		pha				pha
.b328	ad cf 05	lda $05cf			lda 	GXY0 						; gxzScreen = Y0
.b32b	85 3c		sta $3c				sta 	gxzScreen
.b32d	64 3d		stz $3d				stz 	gxzScreen+1
.b32f	06 3c		asl $3c				asl 	gxzScreen 						; gxzScreen = Y0 * 4
.b331	26 3d		rol $3d				rol 	gxzScreen+1
.b333	06 3c		asl $3c				asl 	gxzScreen
.b335	26 3d		rol $3d				rol 	gxzScreen+1
.b337	18		clc				clc 								; gxzScreen = Y0 * 5, as it's still in A
.b338	65 3c		adc $3c				adc 	gxzScreen
.b33a	85 3c		sta $3c				sta 	gxzScreen
.b33c	90 02		bcc $b340			bcc 	_GXPCNoCarry
.b33e	e6 3d		inc $3d				inc 	gxzScreen+1
.b340					_GXPCNoCarry:
.b340	06 3c		asl $3c				asl 	gxzScreen 						; now Y0 * 10. Needs to be multiplied by another
.b342	26 3d		rol $3d				rol 	gxzScreen+1 					; 32. At this point the MSB contains the offset
.b344	a5 3d		lda $3d				lda	 	gxzScreen+1 					; so save this in zTemp0 and zero it.
.b346	85 36		sta $36				sta 	gxzTemp0
.b348	64 3d		stz $3d				stz 	gxzScreen+1
.b34a	a9 05		lda #$05			lda 	#5 							; now multiply by 32, this puts this in the range 0..8191
.b34c					_GXPCMultiply32:
.b34c	06 3c		asl $3c				asl 	gxzScreen
.b34e	26 3d		rol $3d				rol 	gxzScreen+1
.b350	3a		dec a				dec 	a
.b351	d0 f9		bne $b34c			bne 	_GXPCMultiply32
.b353	18		clc				clc
.b354	ad cd 05	lda $05cd			lda 	GXX0 						; add X to this value, put the result in gsOffset, gxzScreen has to be on a page boundary
.b357	65 3c		adc $3c				adc 	gxzScreen
.b359	8d df 05	sta $05df			sta 	gsOffset
.b35c	ad ce 05	lda $05ce			lda 	GXX0+1
.b35f	65 3d		adc $3d				adc 	gxzScreen+1
.b361	c9 20		cmp #$20			cmp 	#$20 						; has it overflowed into the next one ?
.b363	90 04		bcc $b369			bcc 	_GXPCNoOverflow
.b365	29 1f		and #$1f			and 	#$1F 						; fix it up
.b367	e6 36		inc $36				inc 	gxzTemp0 					; add 1 to the page number
.b369					_GXPCNoOverflow:
.b369	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; make it the address mapped in.
.b36b	85 3d		sta $3d				sta 	gxzScreen+1
.b36d	64 3c		stz $3c				stz 	gxzScreen
.b36f	18		clc				clc
.b370	a5 36		lda $36				lda 	gxzTemp0 					; get the page number
.b372	6d d7 05	adc $05d7			adc 	gxBasePage 					; by adding the base page
.b375	85 0b		sta $0b				sta 	GXEditSlot 				; and map it into memory.
.b377	68		pla				pla
.b378	85 36		sta $36				sta 	gxzTemp0
.b37a	60		rts				rts
.b37b					GXMovePositionDown:
.b37b	18		clc				clc 								; add 320 to offset/temp+1
.b37c	ad df 05	lda $05df			lda 	gsOffset
.b37f	69 40		adc #$40			adc 	#64
.b381	8d df 05	sta $05df			sta 	gsOffset
.b384	a5 3d		lda $3d				lda 	gxzScreen+1
.b386	69 01		adc #$01			adc 	#1
.b388	85 3d		sta $3d				sta 	gxzScreen+1
.b38a	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page
.b38c	90 07		bcc $b395			bcc 	_GXMPDExit
.b38e	38		sec				sec  								; next page
.b38f	e9 20		sbc #$20			sbc 	#$20
.b391	85 3d		sta $3d				sta 	gxzScreen+1
.b393	e6 0b		inc $0b				inc 	GXEditSlot
.b395					_GXMPDExit:
.b395	60		rts				rts
.b396					GXCollide:
.b396	a5 36		lda $36				lda 	gxzTemp0 					; check if sprite numbers are legal.
.b398	aa		tax				tax
.b399	05 37		ora $37				ora 	gxzTemp0+1
.b39b	29 c0		and #$c0			and 	#$C0
.b39d	38		sec				sec
.b39e	d0 53		bne $b3f3			bne 	_GXCollideFail 				; if either >= 64, fail.
.b3a0	a4 37		ldy $37				ldy 	gxzTemp0+1 					; at this point X is 1st sprite and Y is 2nd sprite.
.b3a2	b9 e5 05	lda $05e5,y			lda 	GXSpriteLow,y 				; check if either hidden bit is set
.b3a5	1d e5 05	ora $05e5,x			ora 	GXSpriteLow,x
.b3a8	30 48		bmi $b3f2			bmi 	_GXOkayFail 				; if either hidden, then they cannot collide.
.b3aa	18		clc				clc 								; need to calculate sum of sizes.
.b3ab	b9 25 06	lda $0625,y			lda 	GXSpriteHigh,y
.b3ae	7d 25 06	adc $0625,x			adc 	GXSpriteHigh,x 				; at this point, CS, Bit 6 and 7 contain that sum.
.b3b1	29 c0		and #$c0			and 	#$C0 					 	; mask off
.b3b3	6a		ror a				ror 	a 							; 5/6/7
.b3b4	4a		lsr a				lsr 	a 							; 4/5/6
.b3b5	4a		lsr a				lsr 	a 							; 3/4/5
.b3b6	4a		lsr a				lsr 	a 							; 2/3/4
.b3b7	18		clc				clc
.b3b8	69 08		adc #$08			adc 	#$08
.b3ba	4a		lsr a				lsr 	a 							; adjust because all coordinates are divided by 4 to store.
.b3bb	4a		lsr a				lsr 	a
.b3bc	85 38		sta $38				sta 	gxzTemp1 					; so the difference between the centres has to be less than this.
.b3be	b9 25 06	lda $0625,y			lda 	GXSpriteHigh,y 				; calculate y1-y0
.b3c1	29 3f		and #$3f			and 	#$3F
.b3c3	85 39		sta $39				sta 	gxzTemp1+1
.b3c5	38		sec				sec
.b3c6	bd 25 06	lda $0625,x			lda 	GXSpriteHigh,x
.b3c9	29 3f		and #$3f			and 	#$3F
.b3cb	e5 39		sbc $39				sbc 	gxzTemp1+1
.b3cd	b0 03		bcs $b3d2			bcs 	_GXCAbs1 					; calculate |y1-y0|
.b3cf	49 ff		eor #$ff			eor 	#$FF
.b3d1	1a		inc a				inc 	a
.b3d2					_GXCAbs1:
.b3d2	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b3d4	b0 1c		bcs $b3f2			bcs 	_GXOkayFail
.b3d6	85 39		sta $39				sta 	gxzTemp1+1 					; save |y1-y0|
.b3d8	38		sec				sec 								; calculate |x1-x0|
.b3d9	b9 e5 05	lda $05e5,y			lda 	GXSpriteLow,y
.b3dc	fd e5 05	sbc $05e5,x			sbc 	GXSpriteLow,x
.b3df	b0 03		bcs $b3e4			bcs 	_GXCAbs2
.b3e1	49 ff		eor #$ff			eor 	#$FF
.b3e3	1a		inc a				inc 	a
.b3e4					_GXCAbs2:
.b3e4	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b3e6	b0 0a		bcs $b3f2			bcs 	_GXOkayFail
.b3e8	c5 39		cmp $39				cmp 	gxzTemp1+1 					; is it less than the previous one.
.b3ea	90 02		bcc $b3ee			bcc 	_GXCHaveLowest
.b3ec	a5 39		lda $39				lda 	gxzTemp1+1 					; if not, that's the smallest difference.
.b3ee					_GXCHaveLowest:
.b3ee	0a		asl a				asl 	a 							; scale to allow for >> 2
.b3ef	0a		asl a				asl 	a
.b3f0	18		clc				clc
.b3f1	60		rts				rts
.b3f2					_GXOkayFail:
.b3f2	18		clc				clc
.b3f3					_GXCollideFail:
.b3f3	a9 ff		lda #$ff			lda 	#$FF
.b3f5	60		rts				rts
.b3f6					GXFindSprite:
.b3f6	aa		tax				tax
.b3f7	ad d8 05	lda $05d8			lda 	GXSpritePage 				; access the base page of the sprite
.b3fa	85 0b		sta $0b				sta 	GXEditSlot
.b3fc	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; check a valid sprite
.b3ff	1d 00 60	ora $6000,x			ora 	GXMappingAddress,x
.b402	f0 33		beq $b437			beq 	_GXFSFail
.b404	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; MSB
.b407	8d 7c 06	sta $067c			sta 	GXSpriteOffset+1
.b40a	bd 00 60	lda $6000,x			lda 	GXMappingAddress,x 			; LSB
.b40d	48		pha				pha 								; save twice
.b40e	48		pha				pha
.b40f	29 03		and #$03			and 	#3 							; get sprite size
.b411	8d 79 06	sta $0679			sta 	GXSizeBits 					; save raw (0-3)
.b414	aa		tax				tax
.b415	bd 39 b4	lda $b439,x			lda 	_GXFXSSTTable,x 			; read sprite size
.b418	8d 78 06	sta $0678			sta 	GXSizePixels 					; save (8/16/24/32)
.b41b	68		pla				pla 								; get LUT
.b41c	4a		lsr a				lsr		a
.b41d	4a		lsr a				lsr		a
.b41e	29 03		and #$03			and 	#3
.b420	8d 7a 06	sta $067a			sta 	GXSpriteLUT
.b423	68		pla				pla 								; address, neeeds to be x 4
.b424	29 f0		and #$f0			and 	#$F0
.b426	8d 7b 06	sta $067b			sta 	GXSpriteOffset
.b429	0e 7b 06	asl $067b			asl 	GXSpriteOffset
.b42c	2e 7c 06	rol $067c			rol 	GXSpriteOffset+1
.b42f	0e 7b 06	asl $067b			asl 	GXSpriteOffset
.b432	2e 7c 06	rol $067c			rol 	GXSpriteOffset+1
.b435	18		clc				clc
.b436	60		rts				rts
.b437					_GXFSFail:
.b437	38		sec				sec
.b438	60		rts				rts
.b439					_GXFXSSTTable:
>b439	08 10 18 20					.byte 	8,16,24,32
.0678					GXSizePixels:
>0678							.fill 	1
.0679					GXSizeBits:
>0679							.fill 	1
.067a					GXSpriteLUT:
>067a							.fill 	1
.067b					GXSpriteOffset:
>067b							.fill 	2
.b43d					GXSortXY:
.b43d	20 5b b4	jsr $b45b			jsr 	GXSortY 					; will be sorted on Y now
.b440	ad cd 05	lda $05cd			lda 	gxX0 						; compare X0 v X1
.b443	cd d1 05	cmp $05d1			cmp 	gxX1
.b446	ad ce 05	lda $05ce			lda 	gXX0+1
.b449	ed d2 05	sbc $05d2			sbc 	gXX1+1
.b44c	90 0c		bcc $b45a			bcc 	_GXSXYExit 					; X0 < X1 exit
.b44e	a2 00		ldx #$00			ldx 	#0 							; swap them over
.b450	a0 04		ldy #$04			ldy 	#4
.b452	20 6f b4	jsr $b46f			jsr 	GXSwapXY
.b455	e8		inx				inx
.b456	c8		iny				iny
.b457	20 6f b4	jsr $b46f			jsr 	GXSwapXY
.b45a					_GXSXYExit:
.b45a	60		rts				rts
.b45b					GXSortY:
.b45b	ad cf 05	lda $05cf			lda 	gxY0 						; if Y0 >= Y1
.b45e	cd d3 05	cmp $05d3			cmp 	gxY1
.b461	90 0b		bcc $b46e			bcc 	_GXSYSorted
.b463	a2 03		ldx #$03			ldx 	#3 							; swap 3-0
.b465	a0 07		ldy #$07			ldy 	#7 							; with 4-7
.b467					_GXSwap1:
.b467	20 6f b4	jsr $b46f			jsr 	GXSwapXY
.b46a	88		dey				dey
.b46b	ca		dex				dex
.b46c	10 f9		bpl $b467			bpl 	_GXSwap1
.b46e					_GXSYSorted:
.b46e	60		rts				rts
.b46f					GXSwapXY:
.b46f	bd cd 05	lda $05cd,x			lda 	gxX0,x
.b472	48		pha				pha
.b473	b9 cd 05	lda $05cd,y			lda 	gxX0,y
.b476	9d cd 05	sta $05cd,x			sta 	gxX0,x
.b479	68		pla				pla
.b47a	99 cd 05	sta $05cd,y			sta 	gxX0,y
.b47d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_tokeniser.module

=1					tokeniserIntegrated=1
.b47e					KeywordSet0:
>b47e	00 65					.text	0,$65,""               ; $80 !0:EOF
>b480	00 58					.text	0,$58,""               ; $81 !1:SH1
>b482	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b484	04 fe 41 42 53 28			.text	4,$fe,"ABS("           ; $83 ABS(
>b48a	06 93 41 4c 4c 4f 43 28			.text	6,$93,"ALLOC("         ; $84 ALLOC(
>b492	04 ff 41 53 43 28			.text	4,$ff,"ASC("           ; $85 ASC(
>b498	05 29 43 48 52 24 28			.text	5,$29,"CHR$("          ; $86 CHR$(
>b49f	05 41 44 45 45 4b 28			.text	5,$41,"DEEK("          ; $87 DEEK(
>b4a6	06 aa 45 56 45 4e 54 28			.text	6,$aa,"EVENT("         ; $88 EVENT(
>b4ae	05 6b 46 41 4c 53 45			.text	5,$6b,"FALSE"          ; $89 FALSE
>b4b5	05 44 46 52 41 43 28			.text	5,$44,"FRAC("          ; $8a FRAC(
>b4bc	04 0d 48 49 54 28			.text	4,$0d,"HIT("           ; $8b HIT(
>b4c2	04 13 49 4e 54 28			.text	4,$13,"INT("           ; $8c INT(
>b4c8	06 a7 49 53 56 41 4c 28			.text	6,$a7,"ISVAL("         ; $8d ISVAL(
>b4d0	05 5c 4a 4f 59 42 28			.text	5,$5c,"JOYB("          ; $8e JOYB(
>b4d7	05 72 4a 4f 59 58 28			.text	5,$72,"JOYX("          ; $8f JOYX(
>b4de	05 73 4a 4f 59 59 28			.text	5,$73,"JOYY("          ; $90 JOYY(
>b4e5	06 77 4c 45 46 54 24 28			.text	6,$77,"LEFT$("         ; $91 LEFT$(
>b4ed	04 07 4c 45 4e 28			.text	4,$07,"LEN("           ; $92 LEN(
>b4f3	04 0e 4d 41 58 28			.text	4,$0e,"MAX("           ; $93 MAX(
>b4f9	05 26 4d 49 44 24 28			.text	5,$26,"MID$("          ; $94 MID$(
>b500	04 0c 4d 49 4e 28			.text	4,$0c,"MIN("           ; $95 MIN(
>b506	04 19 4e 4f 54 28			.text	4,$19,"NOT("           ; $96 NOT(
>b50c	05 4d 50 45 45 4b 28			.text	5,$4d,"PEEK("          ; $97 PEEK(
>b513	08 3c 50 4c 41 59 49 4e			.text	8,$3c,"PLAYING("       ; $98 PLAYING(
>b51b	47 28
>b51d	07 e9 52 41 4e 44 4f 4d			.text	7,$e9,"RANDOM("        ; $99 RANDOM(
>b525	28
>b526	07 ca 52 49 47 48 54 24			.text	7,$ca,"RIGHT$("        ; $9a RIGHT$(
>b52e	28
>b52f	04 0c 52 4e 44 28			.text	4,$0c,"RND("           ; $9b RND(
>b535	04 10 53 47 4e 28			.text	4,$10,"SGN("           ; $9c SGN(
>b53b	04 0e 53 50 43 28			.text	4,$0e,"SPC("           ; $9d SPC(
>b541	05 45 53 54 52 24 28			.text	5,$45,"STR$("          ; $9e STR$(
>b548	06 a9 54 49 4d 45 52 28			.text	6,$a9,"TIMER("         ; $9f TIMER(
>b550	04 40 54 52 55 45			.text	4,$40,"TRUE"           ; $a0 TRUE
>b556	04 0b 56 41 4c 28			.text	4,$0b,"VAL("           ; $a1 VAL(
>b55c	03 e7 46 4f 52				.text	3,$e7,"FOR"            ; $a2 FOR
>b561	02 8f 49 46				.text	2,$8f,"IF"             ; $a3 IF
>b565	04 34 50 52 4f 43			.text	4,$34,"PROC"           ; $a4 PROC
>b56b	06 c1 52 45 50 45 41 54			.text	6,$c1,"REPEAT"         ; $a5 REPEAT
>b573	05 79 57 48 49 4c 45			.text	5,$79,"WHILE"          ; $a6 WHILE
>b57a	05 66 45 4e 44 49 46			.text	5,$66,"ENDIF"          ; $a7 ENDIF
>b581	07 0b 45 4e 44 50 52 4f			.text	7,$0b,"ENDPROC"        ; $a8 ENDPROC
>b589	43
>b58a	04 3f 4e 45 58 54			.text	4,$3f,"NEXT"           ; $a9 NEXT
>b590	04 2f 54 48 45 4e			.text	4,$2f,"THEN"           ; $aa THEN
>b596	05 8c 55 4e 54 49 4c			.text	5,$8c,"UNTIL"          ; $ab UNTIL
>b59d	04 2e 57 45 4e 44			.text	4,$2e,"WEND"           ; $ac WEND
>b5a3	02 9b 42 59				.text	2,$9b,"BY"             ; $ad BY
>b5a7	04 1c 43 41 4c 4c			.text	4,$1c,"CALL"           ; $ae CALL
>b5ad	06 b2 43 49 52 43 4c 45			.text	6,$b2,"CIRCLE"         ; $af CIRCLE
>b5b5	05 67 43 4c 45 41 52			.text	5,$67,"CLEAR"          ; $b0 CLEAR
>b5bc	03 e2 43 4c 53				.text	3,$e2,"CLS"            ; $b1 CLS
>b5c1	05 7f 43 4f 4c 4f 52			.text	5,$7f,"COLOR"          ; $b2 COLOR
>b5c8	06 d4 43 4f 4c 4f 55 52			.text	6,$d4,"COLOUR"         ; $b3 COLOUR
>b5d0	04 1a 44 41 54 41			.text	4,$1a,"DATA"           ; $b4 DATA
>b5d6	03 da 44 49 4d				.text	3,$da,"DIM"            ; $b5 DIM
>b5db	04 23 44 4f 4b 45			.text	4,$23,"DOKE"           ; $b6 DOKE
>b5e1	06 db 44 4f 57 4e 54 4f			.text	6,$db,"DOWNTO"         ; $b7 DOWNTO
>b5e9	04 29 45 4c 53 45			.text	4,$29,"ELSE"           ; $b8 ELSE
>b5ef	04 34 46 52 4f 4d			.text	4,$34,"FROM"           ; $b9 FROM
>b5f5	03 e5 47 46 58				.text	3,$e5,"GFX"            ; $ba GFX
>b5fa	05 80 47 4f 53 55 42			.text	5,$80,"GOSUB"          ; $bb GOSUB
>b601	04 39 47 4f 54 4f			.text	4,$39,"GOTO"           ; $bc GOTO
>b607	04 24 48 45 52 45			.text	4,$24,"HERE"           ; $bd HERE
>b60d	05 63 49 4d 41 47 45			.text	5,$63,"IMAGE"          ; $be IMAGE
>b614	05 90 49 4e 50 55 54			.text	5,$90,"INPUT"          ; $bf INPUT
>b61b	03 e5 4c 45 54				.text	3,$e5,"LET"            ; $c0 LET
>b620	04 28 4c 49 4e 45			.text	4,$28,"LINE"           ; $c1 LINE
>b626	05 6b 4c 4f 43 41 4c			.text	5,$6b,"LOCAL"          ; $c2 LOCAL
>b62d	03 db 4f 46 46				.text	3,$db,"OFF"            ; $c3 OFF
>b632	02 9d 4f 4e				.text	2,$9d,"ON"             ; $c4 ON
>b636	07 20 4f 55 54 4c 49 4e			.text	7,$20,"OUTLINE"        ; $c5 OUTLINE
>b63e	45
>b63f	07 0f 50 41 4c 45 54 54			.text	7,$0f,"PALETTE"        ; $c6 PALETTE
>b647	45
>b648	04 3f 50 4c 4f 54			.text	4,$3f,"PLOT"           ; $c7 PLOT
>b64e	04 2f 50 4f 4b 45			.text	4,$2f,"POKE"           ; $c8 POKE
>b654	05 8d 50 52 49 4e 54			.text	5,$8d,"PRINT"          ; $c9 PRINT
>b65b	04 1c 52 45 41 44			.text	4,$1c,"READ"           ; $ca READ
>b661	04 2e 52 45 43 54			.text	4,$2e,"RECT"           ; $cb RECT
>b667	03 e4 52 45 4d				.text	3,$e4,"REM"            ; $cc REM
>b66c	06 e0 52 45 54 55 52 4e			.text	6,$e0,"RETURN"         ; $cd RETURN
>b674	05 7b 53 4f 4c 49 44			.text	5,$7b,"SOLID"          ; $ce SOLID
>b67b	05 89 53 4f 55 4e 44			.text	5,$89,"SOUND"          ; $cf SOUND
>b682	06 d7 53 50 52 49 54 45			.text	6,$d7,"SPRITE"         ; $d0 SPRITE
>b68a	04 45 54 45 58 54			.text	4,$45,"TEXT"           ; $d1 TEXT
>b690	02 a3 54 4f				.text	2,$a3,"TO"             ; $d2 TO
>b694	ff					.text	$FF
.b695					KeywordSet1:
>b695	00 65					.text	0,$65,""               ; $80 !0:EOF
>b697	00 58					.text	0,$58,""               ; $81 !1:SH1
>b699	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b69b	08 4c 41 53 53 45 4d 42			.text	8,$4c,"ASSEMBLE"       ; $83 ASSEMBLE
>b6a3	4c 45
>b6a5	06 d2 41 53 53 45 52 54			.text	6,$d2,"ASSERT"         ; $84 ASSERT
>b6ad	06 bd 42 49 54 4d 41 50			.text	6,$bd,"BITMAP"         ; $85 BITMAP
>b6b5	03 d7 45 4e 44				.text	3,$d7,"END"            ; $86 END
>b6ba	07 11 45 58 50 4c 4f 44			.text	7,$11,"EXPLODE"        ; $87 EXPLODE
>b6c2	45
>b6c3	02 96 47 4f				.text	2,$96,"GO"             ; $88 GO
>b6c7	04 3c 4c 49 53 54			.text	4,$3c,"LIST"           ; $89 LIST
>b6cd	04 20 4c 4f 41 44			.text	4,$20,"LOAD"           ; $8a LOAD
>b6d3	03 ea 4e 45 57				.text	3,$ea,"NEW"            ; $8b NEW
>b6d8	04 2e 50 49 4e 47			.text	4,$2e,"PING"           ; $8c PING
>b6de	07 24 52 45 53 54 4f 52			.text	7,$24,"RESTORE"        ; $8d RESTORE
>b6e6	45
>b6e7	03 f5 52 55 4e				.text	3,$f5,"RUN"            ; $8e RUN
>b6ec	05 8d 53 48 4f 4f 54			.text	5,$8d,"SHOOT"          ; $8f SHOOT
>b6f3	07 2a 53 50 52 49 54 45			.text	7,$2a,"SPRITES"        ; $90 SPRITES
>b6fb	53
>b6fc	04 46 53 54 4f 50			.text	4,$46,"STOP"           ; $91 STOP
>b702	03 ee 57 48 4f				.text	3,$ee,"WHO"            ; $92 WHO
>b707	03 eb 5a 41 50				.text	3,$eb,"ZAP"            ; $93 ZAP
>b70c	ff					.text	$FF
.b70d					KeywordSet2:
>b70d	00 65					.text	0,$65,""               ; $80 !0:EOF
>b70f	00 58					.text	0,$58,""               ; $81 !1:SH1
>b711	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b713	03 c8 41 44 43				.text	3,$c8,"ADC"            ; $83 ADC
>b718	03 d3 41 4e 44				.text	3,$d3,"AND"            ; $84 AND
>b71d	03 e0 41 53 4c				.text	3,$e0,"ASL"            ; $85 ASL
>b722	03 c8 42 43 43				.text	3,$c8,"BCC"            ; $86 BCC
>b727	03 d8 42 43 53				.text	3,$d8,"BCS"            ; $87 BCS
>b72c	03 d8 42 45 51				.text	3,$d8,"BEQ"            ; $88 BEQ
>b731	03 df 42 49 54				.text	3,$df,"BIT"            ; $89 BIT
>b736	03 d8 42 4d 49				.text	3,$d8,"BMI"            ; $8a BMI
>b73b	03 d5 42 4e 45				.text	3,$d5,"BNE"            ; $8b BNE
>b740	03 de 42 50 4c				.text	3,$de,"BPL"            ; $8c BPL
>b745	03 d5 42 52 41				.text	3,$d5,"BRA"            ; $8d BRA
>b74a	03 df 42 52 4b				.text	3,$df,"BRK"            ; $8e BRK
>b74f	03 db 42 56 43				.text	3,$db,"BVC"            ; $8f BVC
>b754	03 eb 42 56 53				.text	3,$eb,"BVS"            ; $90 BVS
>b759	03 d2 43 4c 43				.text	3,$d2,"CLC"            ; $91 CLC
>b75e	03 d3 43 4c 44				.text	3,$d3,"CLD"            ; $92 CLD
>b763	03 d8 43 4c 49				.text	3,$d8,"CLI"            ; $93 CLI
>b768	03 e5 43 4c 56				.text	3,$e5,"CLV"            ; $94 CLV
>b76d	03 e0 43 4d 50				.text	3,$e0,"CMP"            ; $95 CMP
>b772	03 eb 43 50 58				.text	3,$eb,"CPX"            ; $96 CPX
>b777	03 ec 43 50 59				.text	3,$ec,"CPY"            ; $97 CPY
>b77c	03 cc 44 45 43				.text	3,$cc,"DEC"            ; $98 DEC
>b781	03 e1 44 45 58				.text	3,$e1,"DEX"            ; $99 DEX
>b786	03 e2 44 45 59				.text	3,$e2,"DEY"            ; $9a DEY
>b78b	03 e6 45 4f 52				.text	3,$e6,"EOR"            ; $9b EOR
>b790	03 da 49 4e 43				.text	3,$da,"INC"            ; $9c INC
>b795	03 ef 49 4e 58				.text	3,$ef,"INX"            ; $9d INX
>b79a	03 f0 49 4e 59				.text	3,$f0,"INY"            ; $9e INY
>b79f	03 e7 4a 4d 50				.text	3,$e7,"JMP"            ; $9f JMP
>b7a4	03 ef 4a 53 52				.text	3,$ef,"JSR"            ; $a0 JSR
>b7a9	03 d1 4c 44 41				.text	3,$d1,"LDA"            ; $a1 LDA
>b7ae	03 e8 4c 44 58				.text	3,$e8,"LDX"            ; $a2 LDX
>b7b3	03 e9 4c 44 59				.text	3,$e9,"LDY"            ; $a3 LDY
>b7b8	03 f1 4c 53 52				.text	3,$f1,"LSR"            ; $a4 LSR
>b7bd	03 ed 4e 4f 50				.text	3,$ed,"NOP"            ; $a5 NOP
>b7c2	03 e2 4f 52 41				.text	3,$e2,"ORA"            ; $a6 ORA
>b7c7	03 d9 50 48 41				.text	3,$d9,"PHA"            ; $a7 PHA
>b7cc	03 e8 50 48 50				.text	3,$e8,"PHP"            ; $a8 PHP
>b7d1	03 f0 50 48 58				.text	3,$f0,"PHX"            ; $a9 PHX
>b7d6	03 f1 50 48 59				.text	3,$f1,"PHY"            ; $aa PHY
>b7db	03 dd 50 4c 41				.text	3,$dd,"PLA"            ; $ab PLA
>b7e0	03 ec 50 4c 50				.text	3,$ec,"PLP"            ; $ac PLP
>b7e5	03 f4 50 4c 58				.text	3,$f4,"PLX"            ; $ad PLX
>b7ea	03 f5 50 4c 59				.text	3,$f5,"PLY"            ; $ae PLY
>b7ef	03 ed 52 4f 4c				.text	3,$ed,"ROL"            ; $af ROL
>b7f4	03 f3 52 4f 52				.text	3,$f3,"ROR"            ; $b0 ROR
>b7f9	03 ef 52 54 49				.text	3,$ef,"RTI"            ; $b1 RTI
>b7fe	03 f9 52 54 53				.text	3,$f9,"RTS"            ; $b2 RTS
>b803	03 d8 53 42 43				.text	3,$d8,"SBC"            ; $b3 SBC
>b808	03 db 53 45 43				.text	3,$db,"SEC"            ; $b4 SEC
>b80d	03 dc 53 45 44				.text	3,$dc,"SED"            ; $b5 SED
>b812	03 e1 53 45 49				.text	3,$e1,"SEI"            ; $b6 SEI
>b817	03 e8 53 54 41				.text	3,$e8,"STA"            ; $b7 STA
>b81c	03 f7 53 54 50				.text	3,$f7,"STP"            ; $b8 STP
>b821	03 ff 53 54 58				.text	3,$ff,"STX"            ; $b9 STX
>b826	03 00 53 54 59				.text	3,$00,"STY"            ; $ba STY
>b82b	03 01 53 54 5a				.text	3,$01,"STZ"            ; $bb STZ
>b830	03 ed 54 41 58				.text	3,$ed,"TAX"            ; $bc TAX
>b835	03 ee 54 41 59				.text	3,$ee,"TAY"            ; $bd TAY
>b83a	03 e8 54 52 42				.text	3,$e8,"TRB"            ; $be TRB
>b83f	03 e9 54 53 42				.text	3,$e9,"TSB"            ; $bf TSB
>b844	03 ff 54 53 58				.text	3,$ff,"TSX"            ; $c0 TSX
>b849	03 ed 54 58 41				.text	3,$ed,"TXA"            ; $c1 TXA
>b84e	03 ff 54 58 53				.text	3,$ff,"TXS"            ; $c2 TXS
>b853	03 ee 54 59 41				.text	3,$ee,"TYA"            ; $c3 TYA
>b858	ff					.text	$FF
.b859					Export_TKListConvertLine:
.b859	48		pha				pha 								; save indent on the stack
.b85a	9c 1d 04	stz $041d			stz 	tbOffset
.b85d	9c 2d 04	stz $042d			stz 	tokenBuffer
.b860	9c 29 04	stz $0429			stz 	currentListColour
.b863	a9 89		lda #$89			lda 	#CLILineNumber+$80
.b865	20 e2 b9	jsr $b9e2			jsr 	LCLWriteColour
.b868	a0 02		ldy #$02			ldy 	#2 							; convert line number to string
.b86a	b1 30		lda ($30),y			lda 	(codePtr),y
.b86c	aa		tax				tax
.b86d	88		dey				dey
.b86e	b1 30		lda ($30),y			lda 	(codePtr),y
.b870	20 53 ba	jsr $ba53			jsr 	LCLWriteNumberXA
.b873	68		pla				pla 								; adjustment to indent
.b874	48		pha				pha 								; save on stack
.b875	10 0c		bpl $b883			bpl 	_LCNoAdjust 				; don't adjust indent if +ve, do after.
.b877	18		clc				clc 								; add to list indent and make 0 if goes -ve.
.b878	6d 26 04	adc $0426			adc 	listIndent
.b87b	8d 26 04	sta $0426			sta 	listIndent
.b87e	10 03		bpl $b883			bpl 	_LCNoAdjust
.b880	9c 26 04	stz $0426			stz 	listIndent
.b883					_LCNoAdjust:
.b883	18		clc				clc		 							; work out actual indent.
.b884	ad 26 04	lda $0426			lda 	listIndent
.b887	0a		asl a				asl 	a
.b888	69 07		adc #$07			adc 	#7
.b88a	85 36		sta $36				sta 	zTemp0
.b88c					_LCPadOut:
.b88c	a9 20		lda #$20			lda 	#' '						; pad out to 6+indent characters
.b88e	20 eb b9	jsr $b9eb			jsr 	LCLWrite
.b891	ad 1d 04	lda $041d			lda 	tbOffset
.b894	c5 36		cmp $36				cmp 	zTemp0
.b896	d0 f4		bne $b88c			bne 	_LCPadOut
.b898	a0 03		ldy #$03			ldy 	#3 							; start position.
.b89a					_LCMainLoop:
.b89a	a9 8a		lda #$8a			lda 	#CLIPunctuation+$80
.b89c	20 e2 b9	jsr $b9e2			jsr 	LCLWriteColour
.b89f	b1 30		lda ($30),y			lda 	(codePtr),y
.b8a1	c9 80		cmp #$80			cmp 	#KWC_EOL 					; end of line ?
.b8a3	f0 17		beq $b8bc			beq 	_LCExit
.b8a5	c9 10		cmp #$10			cmp 	#16 						; 0-5 are the double punctuations
.b8a7	90 1e		bcc $b8c7			bcc 	_LCDoubles
.b8a9	c9 20		cmp #$20			cmp 	#32 						; 16-31 are shifted punctuation from 64-91
.b8ab	90 2a		bcc $b8d7			bcc 	_LCShiftPunc
.b8ad	c9 40		cmp #$40			cmp 	#64 						; 32-64 are as stored, punc and digits
.b8af	90 35		bcc $b8e6			bcc 	_LCPunctuation
.b8b1	c9 80		cmp #$80			cmp 	#128 						; 64-127 are variable identifiers.
.b8b3	90 51		bcc $b906			bcc 	_LCIdentifiers
.b8b5	c9 fe		cmp #$fe			cmp 	#254 						; 128-253 are tokenised words
.b8b7	90 73		bcc $b92c			bcc 	_LCTokens
.b8b9	4c 8c b9	jmp $b98c			jmp 	_LCData 					; 254-5 are data objects
.b8bc					_LCExit:
.b8bc	68		pla				pla 								; get old indent adjust
.b8bd	30 07		bmi $b8c6			bmi 	_LCExit2
.b8bf	18		clc				clc 								; add to indent if +ve
.b8c0	6d 26 04	adc $0426			adc 	listIndent
.b8c3	8d 26 04	sta $0426			sta 	listIndent
.b8c6					_LCExit2:
.b8c6	60		rts				rts
.b8c7					_LCDoubles:
.b8c7	48		pha				pha
.b8c8	4a		lsr a				lsr 	a 							; put bit 2 into bit 1
.b8c9	29 02		and #$02			and 	#2
.b8cb	09 3c		ora #$3c			ora 	#60 						; make < >
.b8cd	20 eb b9	jsr $b9eb			jsr 	LCLWrite
.b8d0	68		pla				pla 								; restore, do lower bit
.b8d1	29 03		and #$03			and 	#3
.b8d3	09 3c		ora #$3c			ora 	#60
.b8d5	80 0f		bra $b8e6			bra		_LCPunctuation 				; print, increment, loop
.b8d7					_LCShiftPunc:
.b8d7	aa		tax				tax 								; save in X
.b8d8	29 07		and #$07			and 	#7 							; lower 3 bits
.b8da	f0 02		beq $b8de			beq 	_LCNoAdd
.b8dc	09 18		ora #$18			ora 	#24 						; adds $18 to it.
.b8de					_LCNoAdd:
.b8de	e0 18		cpx #$18			cpx 	#24 						; if >= 24 add $20
.b8e0	90 02		bcc $b8e4			bcc 	_LCNoAdd2
.b8e2	09 20		ora #$20			ora 	#32 						; adds $20
.b8e4					_LCNoAdd2:
.b8e4	09 40		ora #$40			ora 	#$40 						; shift into 64-127 range and fall through.
.b8e6					_LCPunctuation:
.b8e6	c9 3a		cmp #$3a			cmp 	#':' 						; check if :
.b8e8	d0 03		bne $b8ed			bne 	_LCPContinue
.b8ea	20 01 ba	jsr $ba01			jsr 	LCLDeleteLastSpace 			; if so delete any preceding spaces
.b8ed					_LCPContinue:
.b8ed	c9 2e		cmp #$2e			cmp 	#'.'
.b8ef	f0 08		beq $b8f9			beq 	_LCPIsConstant
.b8f1	c9 30		cmp #$30			cmp 	#'0'
.b8f3	90 0b		bcc $b900			bcc 	_LCPNotConstant
.b8f5	c9 3a		cmp #$3a			cmp 	#'9'+1
.b8f7	b0 07		bcs $b900			bcs 	_LCPNotConstant
.b8f9					_LCPIsConstant:
.b8f9	48		pha				pha
.b8fa	a9 8d		lda #$8d			lda 	#CLIConstant+$80
.b8fc	20 e2 b9	jsr $b9e2			jsr 	LCLWriteColour
.b8ff	68		pla				pla
.b900					_LCPNotConstant:
.b900	c8		iny				iny 								; consume character
.b901	20 eb b9	jsr $b9eb			jsr 	LCLWrite 					; write it out.
.b904	80 94		bra $b89a			bra 	_LCMainLoop 				; go round again.
.b906					_LCIdentifiers:
.b906	18		clc				clc 								; convert to physical address
.b907	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.b909	85 37		sta $37				sta 	zTemp0+1
.b90b	c8		iny				iny
.b90c	b1 30		lda ($30),y			lda 	(codePtr),y
.b90e	85 36		sta $36				sta 	zTemp0
.b910	c8		iny				iny
.b911	5a		phy				phy 								; save position
.b912	a9 87		lda #$87			lda 	#CLIIdentifier+$80
.b914	20 e2 b9	jsr $b9e2			jsr 	LCLWriteColour
.b917	a0 07		ldy #$07			ldy 	#7 							; output the identifier at +8
.b919					_LCOutIdentifier:
.b919	c8		iny				iny
.b91a	b1 36		lda ($36),y			lda 	(zTemp0),y					; bit 7 set = end.
.b91c	29 7f		and #$7f			and 	#$7F
.b91e	20 3d ba	jsr $ba3d			jsr 	LCLLowerCase
.b921	20 eb b9	jsr $b9eb			jsr 	LCLWrite
.b924	b1 36		lda ($36),y			lda 	(zTemp0),y				 	; ends when bit 7 set.
.b926	10 f1		bpl $b919			bpl 	_LCOutIdentifier
.b928	7a		ply				ply 								; restore position
.b929	4c 9a b8	jmp $b89a			jmp 	_LCMainLoop
.b92c					_LCTokens:
.b92c	aa		tax				tax 								; token in X
.b92d	a9 0d		lda #$0d			lda 	#((KeywordSet2) & $FF)
.b92f	85 36		sta $36				sta 	0+zTemp0
.b931	a9 b7		lda #$b7			lda 	#((KeywordSet2) >> 8)
.b933	85 37		sta $37				sta 	1+zTemp0
.b935	e0 82		cpx #$82			cpx 	#$82
.b937	f0 16		beq $b94f			beq 	_LCUseShift
.b939	a9 95		lda #$95			lda 	#((KeywordSet1) & $FF)
.b93b	85 36		sta $36				sta 	0+zTemp0
.b93d	a9 b6		lda #$b6			lda 	#((KeywordSet1) >> 8)
.b93f	85 37		sta $37				sta 	1+zTemp0
.b941	e0 81		cpx #$81			cpx 	#$81
.b943	f0 0a		beq $b94f			beq 	_LCUseShift
.b945	a9 7e		lda #$7e			lda 	#((KeywordSet0) & $FF)
.b947	85 36		sta $36				sta 	0+zTemp0
.b949	a9 b4		lda #$b4			lda 	#((KeywordSet0) >> 8)
.b94b	85 37		sta $37				sta 	1+zTemp0
.b94d	80 01		bra $b950			bra 	_LCNoShift
.b94f					_LCUseShift:
.b94f	c8		iny				iny
.b950					_LCNoShift:
.b950	20 15 ba	jsr $ba15			jsr 	LCLCheckSpaceRequired 		; do we need a space ?
.b953	b1 30		lda ($30),y			lda 	(codePtr),y
.b955	aa		tax				tax 								; into X
.b956					_LCFindText:
.b956	ca		dex				dex
.b957	10 0e		bpl $b967			bpl 	_LCFoundText 				; found text.
.b959	b2 36		lda ($36)			lda 	(zTemp0) 					; length of text
.b95b	1a		inc a				inc 	a 							; one extra for size
.b95c	38		sec				sec 								; one extra for checksum
.b95d	65 36		adc $36				adc 	zTemp0 						; go to next token
.b95f	85 36		sta $36				sta 	zTemp0
.b961	90 f3		bcc $b956			bcc 	_LCFindText
.b963	e6 37		inc $37				inc 	zTemp0+1
.b965	80 ef		bra $b956			bra 	_LCFindText
.b967					_LCFoundText:
.b967	5a		phy				phy 								; save List position
.b968	b2 36		lda ($36)			lda 	(zTemp0)					; count to print
.b96a	aa		tax				tax
.b96b	a9 83		lda #$83			lda 	#CLIToken+$80
.b96d	20 e2 b9	jsr $b9e2			jsr 	LCLWriteColour
.b970	a0 02		ldy #$02			ldy 	#2
.b972					_LCCopyToken:
.b972	b1 36		lda ($36),y			lda 	(zTemp0),y
.b974	20 3d ba	jsr $ba3d			jsr 	LCLLowerCase
.b977	20 eb b9	jsr $b9eb			jsr 	LCLWrite
.b97a	c8		iny				iny
.b97b	ca		dex				dex
.b97c	d0 f4		bne $b972			bne 	_LCCopyToken
.b97e	c9 28		cmp #$28			cmp 	#"(" 						; if last char not ( print a space
.b980	f0 05		beq $b987			beq 	_LCNoSpace
.b982	a9 20		lda #$20			lda 	#' '
.b984	20 eb b9	jsr $b9eb			jsr 	LCLWrite
.b987					_LCNoSpace:
.b987	7a		ply				ply 								; restore position.
.b988	c8		iny				iny 								; consume token
.b989	4c 9a b8	jmp $b89a			jmp 	_LCMainLoop 				; and go around again.
.b98c					_LCData:
.b98c	48		pha				pha 								; save type $FE/$FF
.b98d	a2 24		ldx #$24			ldx 	#'$' 						; figure out $ or "
.b98f	c9 fe		cmp #$fe			cmp 	#$FE
.b991	f0 22		beq $b9b5			beq 	_LCHaveOpener
.b993	a2 22		ldx #$22			ldx 	#'"'
.b995	a9 81		lda #$81			lda 	#CLIData+$80
.b997	20 e2 b9	jsr $b9e2			jsr 	LCLWriteColour
.b99a	c0 04		cpy #$04			cpy 	#4 							; must be 2nd thing on line
.b99c	d0 17		bne $b9b5			bne 	_LCHaveOpener
.b99e	88		dey				dey 								; what precedes it ?
.b99f	b1 30		lda ($30),y			lda 	(codePtr),y
.b9a1	c8		iny				iny
.b9a2	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; if quote
.b9a4	d0 0f		bne $b9b5			bne 	_LCHaveOpener
.b9a6	a9 09		lda #$09			lda 	#9 							; tab
.b9a8	20 eb b9	jsr $b9eb			jsr 	LCLWrite
.b9ab	a9 97		lda #$97			lda 	#$90+CLIBComment
.b9ad	20 eb b9	jsr $b9eb			jsr 	LCLWrite
.b9b0	a9 80		lda #$80			lda 	#CLIFComment+$80
.b9b2	20 e2 b9	jsr $b9e2			jsr 	LCLWriteColour
.b9b5					_LCHaveOpener:
.b9b5	8a		txa				txa 								; output prefix (# or ")
.b9b6	20 eb b9	jsr $b9eb			jsr 	LCLWrite
.b9b9	c8		iny				iny 								; get count
.b9ba	b1 30		lda ($30),y			lda 	(codePtr),y
.b9bc	aa		tax				tax
.b9bd	c8		iny				iny 								; point at first character
.b9be					_LCOutData:
.b9be	b1 30		lda ($30),y			lda 	(codePtr),y
.b9c0	c9 00		cmp #$00			cmp 	#0
.b9c2	f0 03		beq $b9c7			beq 	_LCNoPrint
.b9c4	20 eb b9	jsr $b9eb			jsr 	LCLWrite
.b9c7					_LCNoPrint:
.b9c7	c8		iny				iny
.b9c8	ca		dex				dex
.b9c9	d0 f3		bne $b9be			bne 	_LCOutData
.b9cb	68		pla				pla 								; closing " required ?
.b9cc	c9 ff		cmp #$ff			cmp 	#$FF 						; not required for hex constant.
.b9ce	d0 0f		bne $b9df			bne 	_LCNoQuote
.b9d0	a9 22		lda #$22			lda 	#'"'
.b9d2	20 eb b9	jsr $b9eb			jsr 	LCLWrite
.b9d5	ad c2 05	lda $05c2			lda 	EXTTextColour
.b9d8	29 0f		and #$0f			and 	#$0F
.b9da	09 90		ora #$90			ora 	#$90
.b9dc	20 eb b9	jsr $b9eb			jsr 	LCLWrite
.b9df					_LCNoQuote:
.b9df	4c 9a b8	jmp $b89a			jmp 	_LCMainLoop
.b9e2					LCLWriteColour:
.b9e2	cd 29 04	cmp $0429			cmp 	currentListColour 			; has the colour changed
.b9e5	8d 29 04	sta $0429			sta 	currentListColour 			; (update it anyway)
.b9e8	d0 01		bne $b9eb			bne 	LCLWrite 					; if different, output it
.b9ea	60		rts				rts
.b9eb					LCLWrite:
.b9eb	da		phx				phx
.b9ec	ae 1d 04	ldx $041d			ldx 	tbOffset 					; write out make ASCIIZ
.b9ef	9d 2d 04	sta $042d,x			sta 	tokenBuffer,x
.b9f2	9e 2e 04	stz $042e,x			stz 	tokenBuffer+1,x
.b9f5	ee 1d 04	inc $041d			inc 	tbOffset 					; bump the position
.b9f8	09 00		ora #$00			ora 	#0 							; don't update last character if colour data
.b9fa	30 03		bmi $b9ff			bmi 	_LCLNoColour
.b9fc	8d 27 04	sta $0427			sta 	LCLastCharacter
.b9ff					_LCLNoColour:
.b9ff	fa		plx				plx
.ba00	60		rts				rts
.ba01					LCLDeleteLastSpace:
.ba01	48		pha				pha
.ba02	da		phx				phx
.ba03	ae 1d 04	ldx $041d			ldx 	tbOffset
.ba06	f0 0a		beq $ba12			beq 	_LCDLSExit
.ba08	bd 2c 04	lda $042c,x			lda 	tokenBuffer-1,x
.ba0b	c9 20		cmp #$20			cmp 	#' '
.ba0d	d0 03		bne $ba12			bne 	_LCDLSExit
.ba0f	ce 1d 04	dec $041d			dec 	tbOffset
.ba12					_LCDLSExit:
.ba12	fa		plx				plx
.ba13	68		pla				pla
.ba14	60		rts				rts
.ba15					LCLCheckSpaceRequired:
.ba15	ad 27 04	lda $0427			lda 	LCLastCharacter 			; check last character
.ba18	c9 24		cmp #$24			cmp 	#'$' 						; $ # and ) require that token space.
.ba1a	f0 1b		beq $ba37			beq 	_LCCSRSpace
.ba1c	c9 29		cmp #$29			cmp 	#')'
.ba1e	f0 17		beq $ba37			beq 	_LCCSRSpace
.ba20	c9 23		cmp #$23			cmp 	#'#'
.ba22	f0 13		beq $ba37			beq 	_LCCSRSpace
.ba24	20 3d ba	jsr $ba3d			jsr 	LCLLowerCase 				; saves a little effort
.ba27	c9 30		cmp #$30			cmp 	#"0" 						; check if it was 0-9 A-Z a-z if so need space.
.ba29	90 11		bcc $ba3c			bcc 	_LCCSRExit
.ba2b	c9 3a		cmp #$3a			cmp 	#"9"+1
.ba2d	90 08		bcc $ba37			bcc 	_LCCSRSpace
.ba2f	c9 61		cmp #$61			cmp 	#"a"
.ba31	90 09		bcc $ba3c			bcc 	_LCCSRExit
.ba33	c9 7b		cmp #$7b			cmp 	#"z"+1
.ba35	b0 05		bcs $ba3c			bcs 	_LCCSRExit
.ba37					_LCCSRSpace:
.ba37	a9 20		lda #$20			lda 	#' '
.ba39	20 eb b9	jsr $b9eb			jsr 	LCLWrite
.ba3c					_LCCSRExit:
.ba3c	60		rts				rts
.ba3d					LCLLowerCase:
.ba3d	c9 41		cmp #$41			cmp 	#"A"
.ba3f	90 06		bcc $ba47			bcc 	_LCLLCOut
.ba41	c9 5b		cmp #$5b			cmp 	#"Z"+1
.ba43	b0 02		bcs $ba47			bcs 	_LCLLCOut
.ba45	69 20		adc #$20			adc 	#$20
.ba47					_LCLLCOut:
.ba47	60		rts				rts
.ba48					LCLUpperCase:
.ba48	c9 61		cmp #$61			cmp 	#"a"
.ba4a	90 06		bcc $ba52			bcc 	_LCLUCOut
.ba4c	c9 7b		cmp #$7b			cmp 	#"z"+1
.ba4e	b0 02		bcs $ba52			bcs 	_LCLUCOut
.ba50	e9 1f		sbc #$1f			sbc 	#$1F
.ba52					_LCLUCOut:
.ba52	60		rts				rts
.ba53					LCLWriteNumberXA:
.ba53	64 37		stz $37				stz 	zTemp0+1 					; index into digit table.
.ba55					_LCLWNLoop1:
.ba55	64 36		stz $36				stz 	zTemp0 						; subtraction count.
.ba57					_LCLWNLoop2:
.ba57	48		pha				pha 								; save initial LSB
.ba58	38		sec				sec
.ba59	a4 37		ldy $37				ldy 	zTemp0+1 					; position in table.
.ba5b	f9 8c ba	sbc $ba8c,y			sbc 	_LCLWNTable,y
.ba5e	48		pha				pha
.ba5f	8a		txa				txa
.ba60	f9 8d ba	sbc $ba8d,y			sbc 	_LCLWNTable+1,y
.ba63	90 07		bcc $ba6c			bcc 	_LCLWNUnderflow
.ba65	e6 36		inc $36				inc 	zTemp0  					; subtracted one without borrow.
.ba67	aa		tax				tax 								; update X
.ba68	68		pla				pla 								; restore A
.ba69	7a		ply				ply 								; throw original
.ba6a	80 eb		bra $ba57			bra 	_LCLWNLoop2 				; try again.
.ba6c					_LCLWNUnderflow:
.ba6c	a4 36		ldy $36				ldy 	zTemp0 						; count of subtractions.
.ba6e	d0 06		bne $ba76			bne 	_LCLWNOut
.ba70	ad 1d 04	lda $041d			lda 	tbOffset 					; suppress leading zeroes
.ba73	3a		dec a				dec 	a
.ba74	f0 04		beq $ba7a			beq 	_LCLWNNext
.ba76					_LCLWNOut:
.ba76	98		tya				tya
.ba77	20 86 ba	jsr $ba86			jsr 	_LCLWNOutDigit
.ba7a					_LCLWNNext:
.ba7a	7a		ply				ply 							 	; restore original value.
.ba7b	68		pla				pla
.ba7c	a4 37		ldy $37				ldy 	zTemp0+1  					; bump the index
.ba7e	c8		iny				iny
.ba7f	c8		iny				iny
.ba80	84 37		sty $37				sty 	zTemp0+1
.ba82	c0 08		cpy #$08			cpy 	#8 							; done all 4
.ba84	d0 cf		bne $ba55			bne 	_LCLWNLoop1
.ba86					_LCLWNOutDigit:
.ba86	09 30		ora #$30			ora 	#'0'
.ba88	20 eb b9	jsr $b9eb			jsr 	LCLWrite
.ba8b	60		rts				rts
.ba8c					_LCLWNTable:
>ba8c	10 27						.word 	10000
>ba8e	e8 03						.word 	1000
>ba90	64 00						.word 	100
>ba92	0a 00						.word 	10
.ba94					TOKSearchTable:
.ba94	84 37		sty $37				sty 	zTemp0+1 					; (zTemp0),y points to current token being tested.
.ba96	85 36		sta $36				sta 	zTemp0
.ba98	a0 00		ldy #$00			ldy 	#0
.ba9a	a9 80		lda #$80			lda 	#$80 						; token # so we know which one we are looking at
.ba9c	85 38		sta $38				sta 	zTemp1
.ba9e					_TSTLoop:
.ba9e	b1 36		lda ($36),y			lda 	(zTemp0),y 					; length, 0 (skip) -ve (end)
.baa0	30 49		bmi $baeb			bmi 	_TSTFail 					; -ve = end of table, so fail.
.baa2	f0 2e		beq $bad2			beq 	_TSTNext 					; zero, check next as it's a dummy (e.g. EOL, SHIFT)
.baa4	c8		iny				iny 								; get the hash
.baa5	b1 36		lda ($36),y			lda 	(zTemp0),y
.baa7	88		dey				dey
.baa8	cd 03 04	cmp $0403			cmp 	identHash 					; check they match with the identifier hash, if not go to next
.baab	d0 25		bne $bad2			bne 	_TSTNext
.baad	ad 02 04	lda $0402			lda 	identTypeEnd 				; get length of identifier from end-start
.bab0	38		sec				sec
.bab1	ed 00 04	sbc $0400			sbc 	identStart
.bab4	d1 36		cmp ($36),y			cmp 	(zTemp0),y 					; compare against the length in the table, no match, then return.
.bab6	d0 1a		bne $bad2			bne 	_TSTNext
.bab8	5a		phy				phy 								; save Y , we might fail to match.
.bab9	c8		iny				iny 								; point to text
.baba	c8		iny				iny
.babb	ae 00 04	ldx $0400			ldx 	identStart 					; offset in line buffer in X
.babe					_TSTCompareName:
.babe	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; compare text.
.bac1	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.bac3	d0 0c		bne $bad1			bne 	_TSTNextPullY 				; fail, pullY and do next
.bac5	e8		inx				inx
.bac6	c8		iny				iny
.bac7	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; complete match.
.baca	d0 f2		bne $babe			bne 	_TSTCompareName
.bacc	7a		ply				ply 								; throw Y
.bacd	a5 38		lda $38				lda 	zTemp1 						; get token #
.bacf	38		sec				sec 								; return with CS = passed.
.bad0	60		rts				rts
.bad1					_TSTNextPullY:
.bad1	7a		ply				ply 								; restore current, fall through.
.bad2					_TSTNext:
.bad2	e6 38		inc $38				inc 	zTemp1 						; token counter
.bad4	98		tya				tya
.bad5	18		clc				clc
.bad6	71 36		adc ($36),y			adc 	(zTemp0),y 					; add [Length] + 2 to Y
.bad8	1a		inc a				inc 	a 							; +1
.bad9	1a		inc a				inc 	a 							; +2
.bada	a8		tay				tay
.badb	10 c1		bpl $ba9e			bpl 	_TSTLoop 					; if Y < $80 loop back
.badd	98		tya				tya 								; add Y to zTemp0 and reset Y
.bade	a0 00		ldy #$00			ldy 	#0   						; so we can use Y to search fast
.bae0	18		clc				clc  								; but have tables > 255 bytes
.bae1	65 36		adc $36				adc 	zTemp0 						; when Y gets >= 128 we reset Y
.bae3	85 36		sta $36				sta 	zTemp0 						; and adjust the table pointer/
.bae5	90 b7		bcc $ba9e			bcc 	_TSTLoop
.bae7	e6 37		inc $37				inc 	zTemp0+1
.bae9	80 b3		bra $ba9e			bra 	_TSTLoop
.baeb					_TSTFail:
.baeb	18		clc				clc
.baec	60		rts				rts
.baed					Export_TKTokeniseLine:
.baed	20 75 bc	jsr $bc75			jsr 	LCLFixLineBufferCase 		; fix line case
.baf0	a9 03		lda #$03			lda 	#3 							; reset the token buffer to empty
.baf2	8d 2a 04	sta $042a			sta 	tokenOffset 				; (3 bytes for line number & offset)
.baf5	9c 2b 04	stz $042b			stz 	tokenLineNumber
.baf8	9c 2c 04	stz $042c			stz 	tokenLineNumber+1
.bafb	a2 ff		ldx #$ff			ldx 	#$FF
.bafd					_TKFindFirst:
.bafd	e8		inx				inx
.bafe	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.bb01	f0 79		beq $bb7c			beq 	_TKExit
.bb03	c9 20		cmp #$20			cmp 	#' '
.bb05	90 f6		bcc $bafd			bcc 	_TKFindFirst
.bb07	c9 30		cmp #$30			cmp 	#'0'
.bb09	90 07		bcc $bb12			bcc 	_TKNoLineNumber
.bb0b	c9 3a		cmp #$3a			cmp 	#'9'+1
.bb0d	b0 03		bcs $bb12			bcs 	_TKNoLineNumber
.bb0f	20 9f bc	jsr $bc9f			jsr 	TOKExtractLineNumber
.bb12					_TKNoLineNumber:
.bb12					_TKTokeniseLoop:
.bb12	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; next character, exit if zero EOL.
.bb15	f0 65		beq $bb7c			beq 	_TKExit
.bb17	e8		inx				inx
.bb18	c9 20		cmp #$20			cmp 	#' '
.bb1a	f0 f6		beq $bb12			beq 	_TKTokeniseLoop 			; keep looping if space found.
.bb1c	ca		dex				dex 								; undo last get, A contains character, X is position.
.bb1d	c9 5f		cmp #$5f			cmp 	#'_'						; _ A-Z is identifier *or* token
.bb1f	f0 61		beq $bb82			beq 	_TKTokeniseIdentifier 		; (already case converted outside string constants)
.bb21	c9 41		cmp #$41			cmp 	#'A'
.bb23	90 04		bcc $bb29			bcc 	_TKTokenisePunctuation
.bb25	c9 5b		cmp #$5b			cmp 	#'Z'+1
.bb27	90 59		bcc $bb82			bcc 	_TKTokeniseIdentifier
.bb29					_TKTokenisePunctuation:
.bb29	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.bb2b	f0 27		beq $bb54			beq 	_TKString
.bb2d	c9 24		cmp #$24			cmp 	#'$'						; hexadecimal constant ($ only appears at end of identifiers)
.bb2f	f0 28		beq $bb59			beq 	_TKHexConstant
.bb31	c9 3c		cmp #$3c			cmp 	#'<' 						; check for < > handlers - these are for <> <= >= >> <<
.bb33	f0 29		beq $bb5e			beq 	_TKCheckDouble
.bb35	c9 3e		cmp #$3e			cmp 	#'>'
.bb37	f0 25		beq $bb5e			beq 	_TKCheckDouble
.bb39					_TKStandardPunctuation:
.bb39	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get the punctuation token back.
.bb3c	c9 40		cmp #$40			cmp 	#64 						; are we >= 64
.bb3e	90 0e		bcc $bb4e			bcc 	_TKNoShift
.bb40	48		pha				pha 								; save. we are about to convert this punctuation token from
.bb41	29 07		and #$07			and 	#7 							; lower 3 bits in zTemp0
.bb43	85 36		sta $36				sta 	zTemp0
.bb45	68		pla				pla
.bb46	29 20		and #$20			and 	#32 						; bit 5
.bb48	4a		lsr a				lsr 	a 							; shift into bit 3
.bb49	4a		lsr a				lsr 	a
.bb4a	05 36		ora $36				ora 	zTemp0
.bb4c	09 10		ora #$10			ora 	#$10						; now in the range 16-31
.bb4e					_TKNoShift:
.bb4e	20 e4 bc	jsr $bce4			jsr 	TOKWriteByte 				; write the punctuation character
.bb51	e8		inx				inx 								; consume the character
.bb52	80 be		bra $bb12			bra 	_TKTokeniseLoop 			; and loop round again.
.bb54					_TKString:
.bb54	20 04 bc	jsr $bc04			jsr 	TOKTokenString
.bb57	80 b9		bra $bb12			bra 	_TKTokeniseLoop
.bb59					_TKHexConstant:
.bb59	20 3f bc	jsr $bc3f			jsr 	TOKHexConstant
.bb5c	80 b4		bra $bb12			bra 	_TKTokeniseLoop
.bb5e					_TKCheckDouble:
.bb5e	bd 2b 05	lda $052b,x			lda 	lineBuffer+1,x 				; get next character
.bb61	c9 3c		cmp #$3c			cmp 	#'<'						; if not < = > which are ASCII consecutive go back
.bb63	90 d4		bcc $bb39			bcc 	_TKStandardPunctuation 		; and do the normal punctuation handler.
.bb65	c9 3f		cmp #$3f			cmp 	#'>'+1
.bb67	b0 d0		bcs $bb39			bcs 	_TKStandardPunctuation
.bb69	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; this is < (60) or > (62)
.bb6c	29 02		and #$02			and 	#2 							; now < (0) or > (2)
.bb6e	0a		asl a				asl 	a 							; now < (0) or > (4), CC also
.bb6f	7d 2b 05	adc $052b,x			adc 	lineBuffer+1,x 				; add < = > codes - < code
.bb72	38		sec				sec
.bb73	e9 3c		sbc #$3c			sbc 	#'<'
.bb75	20 e4 bc	jsr $bce4			jsr 	TOKWriteByte 				; this is in the range 0-7
.bb78	e8		inx				inx 								; consume both
.bb79	e8		inx				inx
.bb7a	80 96		bra $bb12			bra 	_TKTokeniseLoop
.bb7c	a9 80		lda #$80	_TKExit:lda 	#KWC_EOL 					; write end of line byte
.bb7e	20 e4 bc	jsr $bce4			jsr 	TOKWriteByte
.bb81	60		rts				rts
.bb82					_TKTokeniseIdentifier:
.bb82	8e 00 04	stx $0400			stx 	identStart 					; save start
.bb85	9c 04 04	stz $0404			stz 	identTypeByte 				; zero the type byte
.bb88					_TKCheckLoop:
.bb88	e8		inx				inx 								; look at next, we know first is identifier already.
.bb89	bd 2a 05	lda $052a,x			lda  	lineBuffer,x
.bb8c	c9 5f		cmp #$5f			cmp 	#"_" 						; legal char _ 0-9 A-Z
.bb8e	f0 f8		beq $bb88			beq 	_TKCheckLoop
.bb90	c9 30		cmp #$30			cmp	 	#"0"
.bb92	90 0c		bcc $bba0			bcc 	_TKEndIdentifier
.bb94	c9 3a		cmp #$3a			cmp 	#"9"+1
.bb96	90 f0		bcc $bb88			bcc 	_TKCheckLoop
.bb98	c9 41		cmp #$41			cmp	 	#"A"
.bb9a	90 04		bcc $bba0			bcc 	_TKEndIdentifier
.bb9c	c9 5b		cmp #$5b			cmp 	#"Z"+1
.bb9e	90 e8		bcc $bb88			bcc 	_TKCheckLoop
.bba0					_TKEndIdentifier:
.bba0	8e 01 04	stx $0401			stx 	identTypeStart 				; save start of type text (if any !)
.bba3	a0 08		ldy #$08			ldy 	#$08 						; this is the identifier type byte for #
.bba5	c9 23		cmp #$23			cmp 	#"#"						; followed by #
.bba7	f0 06		beq $bbaf			beq 	_TKHasTypeCharacter
.bba9	a0 10		ldy #$10			ldy 	#$10 						; this is the identifier type byte for $
.bbab	c9 24		cmp #$24			cmp 	#"$"						; followed by $ or #
.bbad	d0 07		bne $bbb6			bne 	_TKNoTypeCharacter
.bbaf					_TKHasTypeCharacter:
.bbaf	8c 04 04	sty $0404			sty 	identTypeByte 				; has # or $, save the type
.bbb2	e8		inx				inx 								; consume the type character
.bbb3	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.bbb6					_TKNoTypeCharacter:
.bbb6	c9 28		cmp #$28			cmp 	#"("						; is it open parenthesis (e.g. array)
.bbb8	d0 09		bne $bbc3			bne 	_TKNoArray
.bbba	e8		inx				inx 								; skip the (
.bbbb	ad 04 04	lda $0404			lda 	identTypeByte 				; set bit 2 (e.g. array) in type byte
.bbbe	09 04		ora #$04			ora 	#$04
.bbc0	8d 04 04	sta $0404			sta 	identTypeByte
.bbc3					_TKNoArray:
.bbc3	8e 02 04	stx $0402			stx 	identTypeEnd 				; save end marker, e.g. continue from here.
.bbc6	20 60 bc	jsr $bc60			jsr 	TOKCalculateHash 			; calculate the has for those tokens
.bbc9	a0 b4		ldy #$b4			ldy 	#(KeywordSet0) >> 8
.bbcb	a9 7e		lda #$7e			lda 	#(KeywordSet0) & $FF
.bbcd	20 94 ba	jsr $ba94			jsr 	TOKSearchTable
.bbd0	a2 00		ldx #$00			ldx 	#0
.bbd2	b0 1f		bcs $bbf3			bcs 	_TKFoundToken
.bbd4	a0 b6		ldy #$b6			ldy 	#(KeywordSet1) >> 8
.bbd6	a9 95		lda #$95			lda 	#(KeywordSet1) & $FF
.bbd8	20 94 ba	jsr $ba94			jsr 	TOKSearchTable
.bbdb	a2 81		ldx #$81			ldx 	#$81
.bbdd	b0 14		bcs $bbf3			bcs 	_TKFoundToken
.bbdf	a0 b7		ldy #$b7			ldy 	#(KeywordSet2) >> 8
.bbe1	a9 0d		lda #$0d			lda 	#(KeywordSet2) & $FF
.bbe3	20 94 ba	jsr $ba94			jsr 	TOKSearchTable
.bbe6	a2 82		ldx #$82			ldx 	#$82
.bbe8	b0 09		bcs $bbf3			bcs 	_TKFoundToken
.bbea	20 f0 bc	jsr $bcf0			jsr 	TOKCheckCreateVariableRecord ; failed all, it's a variable, create record if does not exist.
.bbed	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.bbf0	4c 12 bb	jmp $bb12			jmp 	_TKTokeniseLoop 			; and go round again.
.bbf3					_TKFoundToken:
.bbf3	48		pha				pha 								; save token
.bbf4	8a		txa				txa 								; shift in X, is there one ?
.bbf5	f0 03		beq $bbfa			beq 	_TKNoTShift
.bbf7	20 e4 bc	jsr $bce4			jsr 	TOKWriteByte 				; if so, write it out
.bbfa					_TKNoTShift:
.bbfa	68		pla				pla 								; restore and write token
.bbfb	20 e4 bc	jsr $bce4			jsr 	TOKWriteByte
.bbfe	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.bc01	4c 12 bb	jmp $bb12			jmp 	_TKTokeniseLoop 			; and go round again.
.bc04					TOKTokenString:
.bc04	a9 ff		lda #$ff			lda 	#KWC_STRING 				; string token.
.bc06	20 e4 bc	jsr $bce4			jsr 	TOKWriteByte
.bc09	e8		inx				inx									; start of quoted string.
.bc0a	da		phx				phx 								; push start of string on top
.bc0b	ca		dex				dex 								; because we pre-increment
.bc0c					_TSFindEnd:
.bc0c	e8		inx				inx
.bc0d	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; next character
.bc10	f0 04		beq $bc16			beq 	_TSEndOfString 				; no matching quote, we don't mind.
.bc12	c9 22		cmp #$22			cmp 	#'"' 						; go back if quote not found
.bc14	d0 f6		bne $bc0c			bne 	_TSFindEnd
.bc16					_TSEndOfString:
.bc16	7a		ply				ply  								; so now Y is first character, X is character after end.
.bc17	48		pha				pha 								; save terminating character
.bc18	20 20 bc	jsr $bc20			jsr 	TOKWriteBlockXY 			; write X to Y as a data block
.bc1b	68		pla				pla 								; terminating character
.bc1c	f0 01		beq $bc1f			beq 	_TSNotQuote					; if it wasn't EOS skip it
.bc1e	e8		inx				inx
.bc1f					_TSNotQuote:
.bc1f	60		rts				rts
.bc20					TOKWriteBlockXY:
.bc20	86 36		stx $36				stx 	zTemp0 						; save end character
.bc22	98		tya				tya 								; use 2's complement to work out the byte size
.bc23	49 ff		eor #$ff			eor 	#$FF
.bc25	38		sec				sec
.bc26	65 36		adc $36				adc 	zTemp0
.bc28	1a		inc a				inc 	a 							; one extra for NULL
.bc29	20 e4 bc	jsr $bce4			jsr 	TOKWriteByte
.bc2c					_TOBlockLoop:
.bc2c	c4 36		cpy $36				cpy 	zTemp0 						; exit if reached the end
.bc2e	f0 09		beq $bc39			beq 	_TOBlockExit
.bc30	b9 2a 05	lda $052a,y			lda 	lineBuffer,y 				; write byte out.
.bc33	20 e4 bc	jsr $bce4			jsr 	TOKWriteByte
.bc36	c8		iny				iny
.bc37	80 f3		bra $bc2c			bra 	_TOBlockLoop
.bc39					_TOBlockExit:
.bc39	a9 00		lda #$00			lda 	#0 							; add NULL.
.bc3b	20 e4 bc	jsr $bce4			jsr 	TOKWriteByte
.bc3e	60		rts				rts
.bc3f					TOKHexConstant:
.bc3f	a9 fe		lda #$fe			lda 	#KWC_HEXCONST 				; hex constant token.
.bc41	20 e4 bc	jsr $bce4			jsr 	TOKWriteByte
.bc44	e8		inx				inx									; start of quoted string.
.bc45	da		phx				phx 								; push start of constant on top
.bc46	ca		dex				dex
.bc47					_THFindLoop:
.bc47	e8		inx				inx 	 							; this is stored in a block, so find out how long
.bc48	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; the hex constant is.
.bc4b	c9 30		cmp #$30			cmp 	#"0"
.bc4d	90 0c		bcc $bc5b			bcc 	_THFoundEnd
.bc4f	c9 3a		cmp #$3a			cmp 	#"9"+1
.bc51	90 f4		bcc $bc47			bcc 	_THFindLoop
.bc53	c9 41		cmp #$41			cmp 	#"A"
.bc55	90 04		bcc $bc5b			bcc 	_THFoundEnd
.bc57	c9 47		cmp #$47			cmp 	#"F"+1
.bc59	90 ec		bcc $bc47			bcc 	_THFindLoop
.bc5b					_THFoundEnd:
.bc5b	7a		ply				ply 								; restore start
.bc5c	20 20 bc	jsr $bc20			jsr 	TOKWriteBlockXY 			; output the block
.bc5f	60		rts				rts
.bc60					TOKCalculateHash:
.bc60	da		phx				phx
.bc61	ae 00 04	ldx $0400			ldx 	identStart 					; needs to be same as in tokens.py - simple sum at present.
.bc64	a9 00		lda #$00			lda 	#0
.bc66					_TCHLoop:
.bc66	18		clc				clc
.bc67	7d 2a 05	adc $052a,x			adc 	lineBuffer,x
.bc6a	e8		inx				inx
.bc6b	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; do the whole thing including type and array markers.
.bc6e	d0 f6		bne $bc66			bne 	_TCHLoop
.bc70	8d 03 04	sta $0403			sta 	identHash 					; save the hash
.bc73	fa		plx				plx
.bc74	60		rts				rts
.bc75					LCLFixLineBufferCase:
.bc75	a2 00		ldx #$00			ldx 	#0
.bc77					_FLBCLoop:
.bc77	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get next character
.bc7a	f0 22		beq $bc9e			beq 	_FLBCExit 					; end of string.
.bc7c	c9 22		cmp #$22			cmp 	#'"'						; quote, go to in quotes
.bc7e	f0 11		beq $bc91			beq 	_FLBCInQuotes
.bc80	e8		inx				inx
.bc81	c9 61		cmp #$61			cmp 	#'a'						; needs capitalising ?
.bc83	90 f2		bcc $bc77			bcc 	_FLBCLoop
.bc85	c9 7b		cmp #$7b			cmp 	#'z'+1
.bc87	b0 ee		bcs $bc77			bcs 	_FLBCLoop
.bc89	38		sec				sec 								; make U/C
.bc8a	e9 20		sbc #$20			sbc 	#32
.bc8c	9d 29 05	sta $0529,x			sta	 	lineBuffer-1,x 				; write back
.bc8f	80 e6		bra $bc77			bra 	_FLBCLoop
.bc91					_FLBCInQuotes:
.bc91	e8		inx				inx 								; advance
.bc92	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get next
.bc95	f0 07		beq $bc9e			beq 	_FLBCExit 					; exit on EOS
.bc97	c9 22		cmp #$22			cmp 	#'"' 				 		; until " found
.bc99	d0 f6		bne $bc91			bne 	_FLBCInQuotes
.bc9b	e8		inx				inx 								; skip over it
.bc9c	80 d9		bra $bc77			bra 	_FLBCLoop
.bc9e					_FLBCExit:
.bc9e	60		rts				rts
.bc9f					TOKExtractLineNumber:
.bc9f	ad 2c 04	lda $042c			lda 	tokenLineNumber+1 			; push current value on stack
.bca2	48		pha				pha
.bca3	ad 2b 04	lda $042b			lda 	tokenLineNumber
.bca6	48		pha				pha
.bca7	20 dd bc	jsr $bcdd			jsr 	_LCLNTimes2 				; line # x 2
.bcaa	20 dd bc	jsr $bcdd			jsr 	_LCLNTimes2 				; line # x 4
.bcad	18		clc				clc 								; add stacked value
.bcae	68		pla				pla
.bcaf	6d 2b 04	adc $042b			adc 	tokenLineNumber
.bcb2	8d 2b 04	sta $042b			sta 	tokenLineNumber
.bcb5	68		pla				pla
.bcb6	6d 2c 04	adc $042c			adc 	tokenLineNumber+1
.bcb9	8d 2c 04	sta $042c			sta 	tokenLineNumber+1 			; line # x 5
.bcbc	20 dd bc	jsr $bcdd			jsr 	_LCLNTimes2 				; line # x 10
.bcbf	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get and consume character
.bcc2	e8		inx				inx
.bcc3	29 0f		and #$0f			and 	#15 						; add to line #
.bcc5	18		clc				clc
.bcc6	6d 2b 04	adc $042b			adc 	tokenLineNumber
.bcc9	8d 2b 04	sta $042b			sta 	tokenLineNumber
.bccc	90 03		bcc $bcd1			bcc 	_TLENNoCarry
.bcce	ee 2c 04	inc $042c			inc 	tokenLineNumber+1
.bcd1					_TLENNoCarry:
.bcd1	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; more digits ?
.bcd4	c9 30		cmp #$30			cmp 	#'0'
.bcd6	90 04		bcc $bcdc			bcc 	_TLENExit
.bcd8	c9 3a		cmp #$3a			cmp 	#'9'+1
.bcda	90 c3		bcc $bc9f			bcc 	TOKExtractLineNumber
.bcdc					_TLENExit:
.bcdc	60		rts				rts
.bcdd					_LCLNTimes2:
.bcdd	0e 2b 04	asl $042b			asl 	tokenLineNumber 			; doubles tokenLineNumber.
.bce0	2e 2c 04	rol $042c			rol 	tokenLineNumber+1
.bce3	60		rts				rts
.bce4					TOKWriteByte:
.bce4	da		phx				phx
.bce5	ae 2a 04	ldx $042a			ldx 	tokenOffset 				; next slot to write to
.bce8	9d 2a 04	sta $042a,x			sta 	tokenOffset,x 				; write byte out
.bceb	ee 2a 04	inc $042a			inc 	tokenOffset 				; advance slot.
.bcee	fa		plx				plx
.bcef	60		rts				rts
.bcf0					TOKCheckCreateVariableRecord:
.bcf0	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.bcf2	85 36		sta $36				sta 	0+zTemp0
.bcf4	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.bcf6	85 37		sta $37				sta 	1+zTemp0
.bcf8					_CCVSearch:
.bcf8	b2 36		lda ($36)			lda 	(zTemp0) 					; end of list
.bcfa	f0 2c		beq $bd28			beq 	_CCVFail
.bcfc	a0 01		ldy #$01			ldy 	#1 							; read the hash
.bcfe	b1 36		lda ($36),y			lda 	(zTemp0),y 					; does it match ?
.bd00	cd 03 04	cmp $0403			cmp 	identHash 	  				; if not, try the next.
.bd03	d0 16		bne $bd1b			bne 	_CCVNext
.bd05	a0 08		ldy #$08			ldy 	#8 							; name in variable record
.bd07	ae 00 04	ldx $0400			ldx 	identStart
.bd0a					_CCVCompare:
.bd0a	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; xor them. zero if the same, except
.bd0d	51 36		eor ($36),y			eor 	(zTemp0),y 					; bit 7 is used for EOS.
.bd0f	e8		inx				inx 								; advance pointers
.bd10	c8		iny				iny
.bd11	0a		asl a				asl 	a 							; A = 0 if they match, CS if end.
.bd12	d0 07		bne $bd1b			bne 	_CCVNext  					; didn't match go to next.
.bd14	90 f4		bcc $bd0a			bcc 	_CCVCompare 				; not finished yet.
.bd16	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; matched whole thing ?
.bd19	f0 41		beq $bd5c			beq 	_CCVFound 					; yes, we were successful
.bd1b					_CCVNext:
.bd1b	18		clc				clc 								; go to next record.
.bd1c	b2 36		lda ($36)			lda 	(zTemp0) 					; add offset to pointer
.bd1e	65 36		adc $36				adc 	zTemp0
.bd20	85 36		sta $36				sta 	zTemp0
.bd22	90 d4		bcc $bcf8			bcc 	_CCVSearch
.bd24	e6 37		inc $37				inc 	zTemp0+1
.bd26	80 d0		bra $bcf8			bra 	_CCVSearch
.bd28					_CCVFail:
.bd28	a0 01		ldy #$01			ldy 	#1 							; create the new record. Offset 1 is hash
.bd2a	ad 03 04	lda $0403			lda 	identHash
.bd2d	91 36		sta ($36),y			sta 	(zTemp0),y
.bd2f	c8		iny				iny 								; offset 2 is the type byte
.bd30	ad 04 04	lda $0404			lda 	identTypeByte
.bd33	91 36		sta ($36),y			sta 	(zTemp0),y
.bd35	c8		iny				iny
.bd36					_CCVData:
.bd36	a9 00		lda #$00			lda 	#0 							; erase data 3-7 (the 5 value bytes)
.bd38	91 36		sta ($36),y			sta 	(zTemp0),y
.bd3a	c8		iny				iny
.bd3b	c0 08		cpy #$08			cpy 	#8
.bd3d	90 f7		bcc $bd36			bcc 	_CCVData
.bd3f	ae 00 04	ldx $0400			ldx 	identStart 					; copy name into 8 on.
.bd42					_CCVCopyName:
.bd42	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.bd45	91 36		sta ($36),y			sta 	(zTemp0),y
.bd47	e8		inx				inx
.bd48	c8		iny				iny
.bd49	ec 02 04	cpx $0402			cpx 	identTypeEnd
.bd4c	d0 f4		bne $bd42			bne 	_CCVCopyName
.bd4e	98		tya				tya 								; patch offset
.bd4f	92 36		sta ($36)			sta 	(zTemp0)
.bd51	a9 00		lda #$00			lda 	#0 							; offset for next is zero.
.bd53	91 36		sta ($36),y			sta 	(zTemp0),y
.bd55	88		dey				dey
.bd56	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set bit 7 of last bit
.bd58	09 80		ora #$80			ora 	#$80
.bd5a	91 36		sta ($36),y			sta 	(zTemp0),y
.bd5c					_CCVFound:
.bd5c	a5 37		lda $37				lda 	zTemp0+1 					; write out MSB
.bd5e	38		sec				sec
.bd5f	e9 10		sbc #$10			sbc 	#(VariableSpace >> 8) 		; offset from the start of the variable token
.bd61	09 40		ora #$40			ora 	#$40 						; make it a writeable token $4000-$7FFF
.bd63	20 e4 bc	jsr $bce4			jsr 	TOKWriteByte
.bd66	a5 36		lda $36				lda 	zTemp0 						; write out LSB
.bd68	20 e4 bc	jsr $bce4			jsr 	TOKWriteByte
.bd6b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_sound.module

=1					soundIntegrated=1
.bd6c					SNDCheckChannel:
.bd6c	aa		tax				tax
.bd6d	bd 8b 07	lda $078b,x			lda 	SNDTimeLeft,x 				; currently playing a note
.bd70	d0 38		bne $bdaa			bne 	_SNDCCExit
.bd72	da		phx				phx 								; save current channel
.bd73	8a		txa				txa 								; put in A
.bd74	20 f0 bd	jsr $bdf0			jsr 	SNDFindNextNoteForA 		; is there a note for A in the queue ?
.bd77	68		pla				pla 								; channel # in A
.bd78	90 30		bcc $bdaa			bcc 	_SNDCCExit  				; nothing in the queue for this channel, exit.
.bd7a	a8		tay				tay 								; Y is the channel #
.bd7b	bd 80 06	lda $0680,x			lda 	SNDQueue+1,x 				; copy data into the slot.
.bd7e	99 7f 07	sta $077f,y			sta 	SNDPitchLow,y
.bd81	bd 81 06	lda $0681,x			lda 	SNDQueue+2,x
.bd84	99 83 07	sta $0783,y			sta 	SNDPitchHigh,y
.bd87	bd 82 06	lda $0682,x			lda 	SNDQueue+3,x
.bd8a	99 87 07	sta $0787,y			sta 	SNDVolume,y
.bd8d	bd 83 06	lda $0683,x			lda 	SNDQueue+4,x
.bd90	99 8b 07	sta $078b,y			sta 	SNDTimeLeft,y
.bd93	bd 84 06	lda $0684,x			lda 	SNDQueue+5,x
.bd96	99 8f 07	sta $078f,y			sta 	SNDAdjustLow,y
.bd99	bd 85 06	lda $0685,x			lda 	SNDQueue+6,x
.bd9c	99 93 07	sta $0793,y			sta 	SNDAdjustHigh,y
.bd9f	5a		phy				phy 								; save channel #
.bda0	20 0a be	jsr $be0a			jsr 	SNDDeleteXFromQueue 		; delete record at X from queue
.bda3	ce 7e 06	dec $067e			dec 	SNDLength 					; reduce the queue length.
.bda6	68		pla				pla
.bda7	20 ab bd	jsr $bdab			jsr 	SNDUpdateNote 				; update channel A
.bdaa					_SNDCCExit:
.bdaa	60		rts				rts
.bdab					SNDUpdateNote:
.bdab	aa		tax				tax 								; so we can access records
.bdac	0a		asl a				asl 	a 							; convert it to a channel bit pair in 5,6
.bdad	0a		asl a				asl 	a
.bdae	0a		asl a				asl 	a
.bdaf	0a		asl a				asl 	a
.bdb0	0a		asl a				asl 	a
.bdb1	8d 7d 06	sta $067d			sta 	SNDChannelBits
.bdb4	bd 8b 07	lda $078b,x			lda 	SNDTimeLeft,x 				; are we silent
.bdb7	f0 2e		beq $bde7			beq 	_SNDUNIsSilent
.bdb9	ad 7d 06	lda $067d			lda 	SNDChannelBits 				; push channel bits on stack
.bdbc	48		pha				pha
.bdbd	bd 7f 07	lda $077f,x			lda 	SNDPitchLow,x 				; get 4 lowest bits of pitch.
.bdc0	29 0f		and #$0f			and 	#$0F
.bdc2	0d 7d 06	ora $067d			ora 	SNDChannelBits 				; set channel bits
.bdc5	09 80		ora #$80			ora 	#$80 						; write to pitch register
.bdc7	20 54 be	jsr $be54			jsr 	SNDWritePorts
.bdca	bd 83 07	lda $0783,x			lda 	SNDPitchHigh,x 				; pitch high => channel temp.
.bdcd	8d 7d 06	sta $067d			sta 	SNDChannelBits
.bdd0	bd 7f 07	lda $077f,x			lda 	SNDPitchLow,x
.bdd3	4e 7d 06	lsr $067d			lsr 	SNDChannelBits 				; shift 2 LSBs into MSB of A
.bdd6	6a		ror a				ror 	a
.bdd7	4e 7d 06	lsr $067d			lsr 	SNDChannelBits
.bdda	6a		ror a				ror 	a
.bddb	4a		lsr a				lsr 	a 							; put in bits 0-5
.bddc	4a		lsr a				lsr 	a
.bddd	20 54 be	jsr $be54			jsr 	SNDWritePorts 				; write as rest of pitch register
.bde0	68		pla				pla
.bde1	09 90		ora #$90			ora 	#$90 						; set to write minimum attentuation.
.bde3	20 54 be	jsr $be54			jsr 	SNDWritePorts
.bde6	60		rts				rts
.bde7					_SNDUNIsSilent:
.bde7	ad 7d 06	lda $067d			lda 	SNDChannelBits 				; channel bits
.bdea	09 9f		ora #$9f			ora 	#$9F 						; maximum attenuation
.bdec	20 54 be	jsr $be54			jsr 	SNDWritePorts 				; write to the ports
.bdef	60		rts				rts
.bdf0					SNDFindNextNoteForA:
.bdf0	ac 7e 06	ldy $067e			ldy 	SNDLength 					; queue size into Y
.bdf3	f0 13		beq $be08			beq 	_SNDFNNFail 				; queue empty.
.bdf5	a2 00		ldx #$00			ldx 	#0
.bdf7					_SNDFNNSearch:
.bdf7	dd 7f 06	cmp $067f,x			cmp 	SNDQueue,x 					; does it match the channel
.bdfa	38		sec				sec
.bdfb	f0 0c		beq $be09			beq 	_SNDFNNExit 				; if so exit with CS.
.bdfd	e8		inx				inx 								; next queue slot.
.bdfe	e8		inx				inx
.bdff	e8		inx				inx
.be00	e8		inx				inx
.be01	e8		inx				inx
.be02	e8		inx				inx
.be03	e8		inx				inx
.be04	e8		inx				inx
.be05	88		dey				dey 								; done the whole queue
.be06	d0 ef		bne $bdf7			bne 	_SNDFNNSearch 				; no, go back.
.be08					_SNDFNNFail:
.be08	18		clc				clc
.be09					_SNDFNNexit:
.be09	60		rts				rts
.be0a					SNDDeleteXFromQueue:
.be0a	e0 f8		cpx #$f8			cpx 	#SNDQueueSize*8-8 			; reached the end.
.be0c	f0 09		beq $be17			beq 	_SNDDXExit
.be0e	bd 87 06	lda $0687,x			lda 	SNDQueue+8,x
.be11	9d 7f 06	sta $067f,x			sta 	SNDQueue,x
.be14	e8		inx				inx
.be15	80 f3		bra $be0a			bra 	SNDDeleteXFromQueue
.be17					_SNDDXExit:
.be17	60		rts				rts
.067d					SNDChannelBits:
>067d							.fill 	1
.be18					SNDQueueRequest:
.be18	86 36		stx $36				stx 	zTemp0						; save queue address
.be1a	84 37		sty $37				sty 	zTemp0+1
.be1c	ae 7e 06	ldx $067e			ldx 	SNDLength 					; queue is full, can't take any more.
.be1f	e0 20		cpx #$20			cpx 	#SNDQueueSize
.be21	f0 21		beq $be44			beq 	_SNDQRExit
.be23	29 03		and #$03			and 	#3	 						; channel # and push on stack
.be25	48		pha				pha
.be26	8a		txa				txa  								; get offset in queue buffer/
.be27	0a		asl a				asl 	a
.be28	0a		asl a				asl 	a
.be29	0a		asl a				asl 	a
.be2a	aa		tax				tax
.be2b	68		pla				pla 								; get back and push again
.be2c	48		pha				pha
.be2d	9d 7f 06	sta $067f,x			sta 	SNDQueue+0,x 				; save the channel #
.be30	a0 00		ldy #$00			ldy 	#0 							; copy the rest in.
.be32					_SNDQCopy:
.be32	b1 36		lda ($36),y			lda 	(zTemp0),y
.be34	e8		inx				inx
.be35	c8		iny				iny
.be36	9d 7f 06	sta $067f,x			sta 	SNDQueue,x
.be39	c0 06		cpy #$06			cpy 	#6
.be3b	d0 f5		bne $be32			bne 	_SNDQCopy
.be3d	ee 7e 06	inc $067e			inc 	SNDLength 					; bump queue length.
.be40	68		pla				pla 								; get channel # back
.be41	20 6c bd	jsr $bd6c			jsr 	SNDCheckChannel 			; check if channel needs refreshing.
.be44					_SNDQRExit:
.be44	60		rts				rts
.be45					SNDSilenceChannel:
.be45	aa		tax				tax 								; zero time left.
.be46	9e 8b 07	stz $078b,x			stz 	SNDTimeLeft,x
.be49	0a		asl a				asl 	a 							; shift into position
.be4a	0a		asl a				asl 	a
.be4b	0a		asl a				asl 	a
.be4c	0a		asl a				asl 	a
.be4d	0a		asl a				asl 	a
.be4e	09 9f		ora #$9f			ora 	#$9F 						; write register attenuation $F
.be50	20 54 be	jsr $be54			jsr 	SNDWritePorts
.be53	60		rts				rts
.be54					SNDWritePorts:
.be54	da		phx				phx 								; save X
.be55	a6 01		ldx $01				ldx 	1 							; save I/O status
.be57	64 01		stz $01				stz 	1 							; access I/O page 0
.be59	8d 00 d6	sta $d600			sta 	$D600 						; write to both
.be5c	8d 10 d6	sta $d610			sta 	$D610
.be5f	86 01		stx $01				stx 	1 							; restore I/O
.be61	fa		plx				plx 								; restore X
.be62	60		rts				rts
.be63					Export_SNDCommand:
.be63	da		phx				phx 								; save XY
.be64	5a		phy				phy
.be65	c9 0f		cmp #$0f			cmp 	#$0F 						; $0F is initialise
.be67	f0 1d		beq $be86			beq 	_SNDInitialise
.be69	90 28		bcc $be93			bcc 	_SNDExit
.be6b	c9 3f		cmp #$3f			cmp 	#$3F 						; $3F is silence all
.be6d	f0 17		beq $be86			beq 	_SNDSilence
.be6f	b0 22		bcs $be93			bcs 	_SNDExit
.be71	c9 20		cmp #$20			cmp 	#$20 						; $2x is check playing => A
.be73	b0 09		bcs $be7e			bcs 	_SNDQueryPlay
.be75	c9 14		cmp #$14			cmp 	#$14 						; $10-$13 is queue sound
.be77	b0 1a		bcs $be93			bcs 	_SNDExit
.be79	20 18 be	jsr $be18			jsr 	SNDQueueRequest
.be7c	80 15		bra $be93			bra 	_SNDExit
.be7e					_SNDQueryPlay:
.be7e	29 03		and #$03			and 	#3 							; get channel #
.be80	aa		tax				tax
.be81	bd 8b 07	lda $078b,x			lda 	SNDTimeLeft,x 				; read time left, if zero then silent
.be84	80 0d		bra $be93			bra 	_SNDExit
.be86					_SNDInitialise:
.be86					_SNDSilence:
.be86	9c 7e 06	stz $067e			stz 	SNDLength 					; empty the queue.
.be89	a9 03		lda #$03			lda 	#$3 						; silence channel 0-3.
.be8b					_SNDSilenceLoop:
.be8b	48		pha				pha
.be8c	20 45 be	jsr $be45			jsr 	SNDSilenceChannel
.be8f	68		pla				pla
.be90	3a		dec a				dec 	a
.be91	10 f8		bpl $be8b			bpl 	_SNDSilenceLoop
.be93					_SNDExit:
.be93	7a		ply				ply
.be94	fa		plx				plx
.be95	60		rts				rts
=32					SNDQueueSize = 32 							; number of queue entries
.067e					SNDLength:
>067e							.fill 	1
.067f					SNDQueue:
>067f							.fill 	SNDQueueSize * 8
.077f					SNDPitchLow:
>077f							.fill 	4
.0783					SNDPitchHigh:
>0783							.fill 	4
.0787					SNDVolume:
>0787							.fill 	4
.078b					SNDTimeLeft:
>078b							.fill 	4
.078f					SNDAdjustLow:
>078f							.fill 	4
.0793					SNDAdjustHigh:
>0793							.fill 	4
.be96					Export_SNDUpdate:
.be96					PagedSNDUpdate:
.be96	ad 8b 07	lda $078b			lda 	SNDTimeLeft+0 				; look at time remaining
.be99	f0 05		beq $bea0			beq 	_SNDUNot0 					; not playing
.be9b	a2 00		ldx #$00			ldx 	#0 							; so we know which channel to update
.be9d	20 bf be	jsr $bebf			jsr 	SNDUpdateChannel 			; update it.
.bea0					_SNDUNot0:
.bea0	ad 8c 07	lda $078c			lda 	SNDTimeLeft+1
.bea3	f0 05		beq $beaa			beq 	_SNDUNot1
.bea5	a2 01		ldx #$01			ldx 	#1
.bea7	20 bf be	jsr $bebf			jsr 	SNDUpdateChannel
.beaa					_SNDUNot1:
.beaa	ad 8d 07	lda $078d			lda 	SNDTimeLeft+2
.bead	f0 05		beq $beb4			beq 	_SNDUNot2
.beaf	a2 02		ldx #$02			ldx 	#2
.beb1	20 bf be	jsr $bebf			jsr 	SNDUpdateChannel
.beb4					_SNDUNot2:
.beb4	ad 8e 07	lda $078e			lda 	SNDTimeLeft+3
.beb7	f0 05		beq $bebe			beq 	_SNDUNot3
.beb9	a2 03		ldx #$03			ldx 	#3
.bebb	20 bf be	jsr $bebf			jsr 	SNDUpdateChannel
.bebe					_SNDUNot3:
.bebe	60		rts				rts
.bebf					SNDUpdateChannel:
.bebf	c9 ff		cmp #$ff			cmp 	#$FF 						; sound $FF play forever until turned off manually
.bec1	f0 2c		beq $beef			beq 	_SNDUCExit
.bec3	3a		dec a				dec 	a 							; decrement and update timer
.bec4	9d 8b 07	sta $078b,x			sta 	SNDTimeLeft,x
.bec7	f0 1d		beq $bee6			beq 	_SNDUCUpdate 				; if zero, silence channel
.bec9	bd 8f 07	lda $078f,x			lda 	SNDAdjustLow,x 				; adjust ?
.becc	1d 93 07	ora $0793,x			ora 	SNDAdjustHigh,x
.becf	f0 1e		beq $beef			beq 	_SNDUCExit 					; if zero carry on at current tone.
.bed1	18		clc				clc 								; add adjust, forcing into a 10 bit range
.bed2	bd 7f 07	lda $077f,x			lda 	SNDPitchLow,x
.bed5	7d 8f 07	adc $078f,x			adc 	SNDAdjustLow,x
.bed8	9d 7f 07	sta $077f,x			sta 	SNDPitchLow,x
.bedb	bd 83 07	lda $0783,x			lda 	SNDPitchHigh,x
.bede	7d 93 07	adc $0793,x			adc 	SNDAdjustHigh,x
.bee1	29 03		and #$03			and 	#3
.bee3	9d 83 07	sta $0783,x			sta 	SNDPitchHigh,x
.bee6					_SNDUCUpdate:
.bee6	8a		txa				txa 								; which channel.
.bee7	48		pha				pha
.bee8	20 ab bd	jsr $bdab			jsr 	SNDUpdateNote 				; update the current note
.beeb	68		pla				pla
.beec	20 6c bd	jsr $bd6c			jsr 	SNDCheckChannel 			; more to do ?
.beef					_SNDUCExit:
.beef	60		rts				rts

;******  Return to file: _basic.asm


;******  End of listing
