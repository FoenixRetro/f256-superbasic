
; 64tass Turbo Assembler Macro V1.57.2900 listing file
; 64tass -D AUTORUN=1 "-D MONITOR_ADDRESS=\$E000" "-D LOCKOUT_ADDRESS=\$F000" "-D BASIC_ADDRESS=\$38000" "-D SOURCE_ADDRESS=\$28000" "-D SPRITE_ADDRESS=\$30000" -q -b -Wall -c -D "HARDWARE=0 $'\x9'$'\x9'$'\x9'$'\x9'$'\x9'$'\x9'" -L output/basic.lst -l output/basic.lbl -Wall -o basic.rom _basic.asm
; Fri Dec  2 17:45:15 2022

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=1					AUTORUN=1
=$e000					 MONITOR_ADDRESS=$E000
=$f000					 LOCKOUT_ADDRESS=$F000
=$38000					 BASIC_ADDRESS=$38000
=$28000					 SOURCE_ADDRESS=$28000
=$30000					 SPRITE_ADDRESS=$30000
=0					HARDWARE=0

;******  Processing input file: _basic.asm


;******  Processing file: ./common/aa.system/01common.inc

=$30					ZeroPageMandatory = $30
=$50					ZeroPagePreference = $50
=$400					MemoryStorage = $400
=$2000					BasicStart = $2000
=$8000					BasicEnd = $8000
=$8000					CodeStart = $8000
=$1000					VariableSpace = $1000
=$2000					EndVariableSpace = $2000
=8					MathStackSize = 8
=512					BasicStackSize = 512
=3584					BasicStackBase = $1000-BasicStackSize
=80					MaxLineSize = 80

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/02macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/04data.inc

.0030					codePtr:
>0030							.fill 	4
.0034					basicStack:
>0034							.fill 	2
.0036					zTemp0:
>0036							.fill 	2
.0038					zTemp1:
>0038							.fill 	2
.003a					zTemp2:
>003a							.fill 	2
.003c					zsTemp:
>003c							.fill 	2
.003e					zaTemp:
>003e							.fill 	2
=$30					safePtr = codePtr 							; minimise direct tinkering
=$80					NSBIsNegative = $80 						; bit 7 : sign of mantissa (where numeric)
=$20					NSBIsReference = $20 						; bit 5 : is a reference
=$10					NSBIsString = $10 							; bit 4 : set if string (procedures don't go on the stack)
=$18					NSBTypeMask = $18 							; bits 4,3 : 00 int 01 float 10 string 11 procedure
=$03					NSBRefMask = $03 							; bits 0,1 : Bytes of reference, 00 = 4,01 = 1,10=2
=$04					NSBIsArray = $04
=$00					NSTInteger = $00 							; base types for bits 3..4
=$08					NSTFloat = $08
=$10					NSTString = $10
=$18					NSTProcedure = $18
.0050					NSStatus:
>0050							.fill 	MathStackSize
.0058					NSMantissa0:
>0058							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0060					NSMantissa1:
>0060							.fill 	MathStackSize
.0068					NSMantissa2:
>0068							.fill 	MathStackSize
.0070					NSMantissa3:
>0070							.fill 	MathStackSize
.0078					NSExponent:
>0078							.fill 	MathStackSize
.0400					identStart:
>0400							.fill 	1
.0401					identTypeStart:
>0401							.fill 	1
.0402					identTypeEnd:
>0402							.fill 	1
.0403					identHash:
>0403							.fill 	1
.0404					identTypeByte:
>0404							.fill 	1	 						; (see tokenising.pdf)
.0405					encodeState:
>0405							.fill 	1
.0406					digitTemp:
>0406							.fill 	1
.0407					decimalCount:
>0407							.fill 	1
.0408					randomSeed:
>0408							.fill 	4
.040c					lowMemPtr:
>040c							.fill 	2
.040e					stringMemory:
>040e							.fill 	2
.0410					stringInitialised:
>0410							.fill 	1
.0411					stringTempPointer:
>0411							.fill 	2
.0413					breakCheck:
>0413							.fill 	1
.0414					decimalPlaces:
>0414							.fill 	1
.0415					dbOffset:
>0415							.fill 	1
.0416					lastParameter:
>0416							.fill 	1
.0417					dataPointer:
>0417							.fill 	5
.041c					inDataStatement:
>041c							.fill 	1
.041d					tbOffset:
>041d							.fill 	1
.041e					AssemblerAddress:
>041e							.fill 	2
.0420					AssemblerControl:
>0420							.fill 	1
.0421					ParamStart:
>0421							.fill 	2
.0423					IsGroup1:
>0423							.fill 	1
.0424					BaseOpcode:
>0424							.fill 	1
.0425					ModeMask:
>0425							.fill 	1
.0426					listIndent:
>0426							.fill 	1
.0427					lcLastCharacter:
>0427							.fill 	1
.0428					isInputFlag:
>0428							.fill 	1
.0429					currentListColour:
>0429							.fill 	1
.042a					tokenOffset:
>042a							.fill 	1
.042b					tokenLineNumber:
>042b							.fill 	2
.042d					tokenBuffer:
>042d							.fill 	253
.052a					lineBuffer:
>052a							.fill 	253
.0627					numberBuffer:
>0627							.fill 	34
.0649					decimalBuffer:
>0649							.fill 	16

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/constants.inc

=$80					AM_ISZP = $80
=$40					AM_ISG1 = $40
=$20					AM_ISG2 = $20
=224					AM_IMMEDIATE = AM_ISZP+AM_ISG1+AM_ISG2+$00
=228					AM_ZEROPAGE = AM_ISZP+AM_ISG1+AM_ISG2+$04
=40					AM_ACC = AM_ISG2+$08
=108					AM_ABS = AM_ISG1+AM_ISG2+$0C
=208					AM_INDY = AM_ISZP+AM_ISG1+$10
=244					AM_ZEROX = AM_ISZP+AM_ISG1+AM_ISG2+$14
=120					AM_ABSY = AM_ISG1+AM_ISG2+$18
=124					AM_ABSX = AM_ISG1+AM_ISG2+$1C
=209					AM_IND = AM_ISZP+AM_ISG1+$11
=$80					AM_ZEROY = AM_ISZP
=$01					AM_INDABS = $01
=$02					AM_INDABSX = $02
=192					AM_INDX = AM_ISZP+AM_ISG1+$00

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/handlers.inc


;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.inc

=1					ERRID_BREAK = 1
=2					ERRID_SYNTAX = 2
=3					ERRID_DIVZERO = 3
=4					ERRID_RANGE = 4
=5					ERRID_TYPE = 5
=6					ERRID_MEMORY = 6
=7					ERRID_ARGUMENT = 7
=8					ERRID_STOP = 8
=9					ERRID_STRING = 9
=10					ERRID_ASSERT = 10
=11					ERRID_DATA = 11
=12					ERRID_NOTDONE = 12
=13					ERRID_LINE = 13
=14					ERRID_GOSUB = 14
=15					ERRID_REPEAT = 15
=16					ERRID_WHILE = 16
=17					ERRID_FOR = 17
=18					ERRID_STACK = 18
=19					ERRID_STRUCT = 19
=20					ERRID_PROC = 20
=21					ERRID_REDEFINE = 21
=22					ERRID_ARRAYSIZE = 22
=23					ERRID_ARRAYIDX = 23

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst.inc

=$00					KWD_LESSLESS                         = $00; $00 <<
=$01					KWD_LESSEQUAL                        = $01; $01 <=
=$02					KWD_LESSGREATER                      = $02; $02 <>
=$03					KWD_PLINGPLING3                      = $03; $03 !!3
=$04					KWD_GREATERLESS                      = $04; $04 ><
=$05					KWD_GREATEREQUAL                     = $05; $05 >=
=$06					KWD_GREATERGREATER                   = $06; $06 >>
=$07					KWD_PLINGPLING7                      = $07; $07 !!7
=$08					KWD_PLINGPLING8                      = $08; $08 !!8
=$09					KWD_PLINGPLING9                      = $09; $09 !!9
=$0a					KWD_PLINGPLING10                     = $0a; $0a !!10
=$0b					KWD_PLINGPLING11                     = $0b; $0b !!11
=$0c					KWD_PLINGPLING12                     = $0c; $0c !!12
=$0d					KWD_PLINGPLING13                     = $0d; $0d !!13
=$0e					KWD_PLINGPLING14                     = $0e; $0e !!14
=$0f					KWD_PLINGPLING15                     = $0f; $0f !!15
=$10					KWD_AT                               = $10; $10 @
=$11					KWD_PLINGPLING17                     = $11; $11 !!17
=$12					KWD_PLINGPLING18                     = $12; $12 !!18
=$13					KWD_LSQPAREN                         = $13; $13 [
=$14					KWD_BACKSLASH                        = $14; $14 \
=$15					KWD_RSQPAREN                         = $15; $15 ]
=$16					KWD_HAT                              = $16; $16 ^
=$17					KWD_UNDERSCORE                       = $17; $17 _
=$18					KWD_BQUOTE                           = $18; $18 `
=$19					KWD_PLINGPLING25                     = $19; $19 !!25
=$1a					KWD_PLINGPLING26                     = $1a; $1a !!26
=$1b					KWD_LCURLY                           = $1b; $1b {
=$1c					KWD_BAR                              = $1c; $1c |
=$1d					KWD_RCURLY                           = $1d; $1d }
=$1e					KWD_TILDE                            = $1e; $1e ~
=$21					KWD_PLING                            = $21; $21 !
=$22					KWD_DQUOTE                           = $22; $22 "
=$23					KWD_HASH                             = $23; $23 #
=$24					KWD_DOLLAR                           = $24; $24 $
=$25					KWD_PERCENT                          = $25; $25 %
=$26					KWD_AMPERSAND                        = $26; $26 &
=$27					KWD_QUOTE                            = $27; $27 '
=$28					KWD_LPAREN                           = $28; $28 (
=$29					KWD_RPAREN                           = $29; $29 )
=$2a					KWD_STAR                             = $2a; $2a *
=$2b					KWD_PLUS                             = $2b; $2b +
=$2c					KWD_COMMA                            = $2c; $2c ,
=$2d					KWD_MINUS                            = $2d; $2d -
=$2e					KWD_PERIOD                           = $2e; $2e .
=$2f					KWD_SLASH                            = $2f; $2f /
=$30					KWD_0                                = $30; $30 0
=$31					KWD_1                                = $31; $31 1
=$32					KWD_2                                = $32; $32 2
=$33					KWD_3                                = $33; $33 3
=$34					KWD_4                                = $34; $34 4
=$35					KWD_5                                = $35; $35 5
=$36					KWD_6                                = $36; $36 6
=$37					KWD_7                                = $37; $37 7
=$38					KWD_8                                = $38; $38 8
=$39					KWD_9                                = $39; $39 9
=$3a					KWD_COLON                            = $3a; $3a :
=$3b					KWD_SEMICOLON                        = $3b; $3b ;
=$3c					KWD_LESS                             = $3c; $3c <
=$3d					KWD_EQUAL                            = $3d; $3d =
=$3e					KWD_GREATER                          = $3e; $3e >
=$3f					KWD_QMARK                            = $3f; $3f ?
=$83					KWD_ABSLPAREN                        = $83; $83 ABS(
=$84					KWD_ALLOCLPAREN                      = $84; $84 ALLOC(
=$85					KWD_ASCLPAREN                        = $85; $85 ASC(
=$86					KWD_CHRDOLLARLPAREN                  = $86; $86 CHR$(
=$87					KWD_DEEKLPAREN                       = $87; $87 DEEK(
=$88					KWD_EVENTLPAREN                      = $88; $88 EVENT(
=$89					KWD_FALSE                            = $89; $89 FALSE
=$8a					KWD_FRACLPAREN                       = $8a; $8a FRAC(
=$8b					KWD_HITLPAREN                        = $8b; $8b HIT(
=$8c					KWD_INTLPAREN                        = $8c; $8c INT(
=$8d					KWD_ISVALLPAREN                      = $8d; $8d ISVAL(
=$8e					KWD_JOYBLPAREN                       = $8e; $8e JOYB(
=$8f					KWD_JOYXLPAREN                       = $8f; $8f JOYX(
=$90					KWD_JOYYLPAREN                       = $90; $90 JOYY(
=$91					KWD_LEFTDOLLARLPAREN                 = $91; $91 LEFT$(
=$92					KWD_LENLPAREN                        = $92; $92 LEN(
=$93					KWD_MAXLPAREN                        = $93; $93 MAX(
=$94					KWD_MIDDOLLARLPAREN                  = $94; $94 MID$(
=$95					KWD_MINLPAREN                        = $95; $95 MIN(
=$96					KWD_NOTLPAREN                        = $96; $96 NOT(
=$97					KWD_PEEKLPAREN                       = $97; $97 PEEK(
=$98					KWD_PLAYINGLPAREN                    = $98; $98 PLAYING(
=$99					KWD_RANDOMLPAREN                     = $99; $99 RANDOM(
=$9a					KWD_RIGHTDOLLARLPAREN                = $9a; $9a RIGHT$(
=$9b					KWD_RNDLPAREN                        = $9b; $9b RND(
=$9c					KWD_SGNLPAREN                        = $9c; $9c SGN(
=$9d					KWD_SPCLPAREN                        = $9d; $9d SPC(
=$9e					KWD_STRDOLLARLPAREN                  = $9e; $9e STR$(
=$9f					KWD_TIMERLPAREN                      = $9f; $9f TIMER(
=$a0					KWD_TRUE                             = $a0; $a0 TRUE
=$a1					KWD_VALLPAREN                        = $a1; $a1 VAL(
=$a2					KWD_FOR                              = $a2; $a2 FOR
=$a3					KWD_IF                               = $a3; $a3 IF
=$a4					KWD_PROC                             = $a4; $a4 PROC
=$a5					KWD_REPEAT                           = $a5; $a5 REPEAT
=$a6					KWD_WHILE                            = $a6; $a6 WHILE
=$a7					KWD_ENDIF                            = $a7; $a7 ENDIF
=$a8					KWD_ENDPROC                          = $a8; $a8 ENDPROC
=$a9					KWD_NEXT                             = $a9; $a9 NEXT
=$aa					KWD_THEN                             = $aa; $aa THEN
=$ab					KWD_UNTIL                            = $ab; $ab UNTIL
=$ac					KWD_WEND                             = $ac; $ac WEND
=$ad					KWD_BY                               = $ad; $ad BY
=$ae					KWD_CALL                             = $ae; $ae CALL
=$af					KWD_CIRCLE                           = $af; $af CIRCLE
=$b0					KWD_CLEAR                            = $b0; $b0 CLEAR
=$b1					KWD_CLS                              = $b1; $b1 CLS
=$b2					KWD_COLOR                            = $b2; $b2 COLOR
=$b3					KWD_COLOUR                           = $b3; $b3 COLOUR
=$b4					KWD_DATA                             = $b4; $b4 DATA
=$b5					KWD_DIM                              = $b5; $b5 DIM
=$b6					KWD_DOKE                             = $b6; $b6 DOKE
=$b7					KWD_DOWNTO                           = $b7; $b7 DOWNTO
=$b8					KWD_ELSE                             = $b8; $b8 ELSE
=$b9					KWD_FROM                             = $b9; $b9 FROM
=$ba					KWD_GFX                              = $ba; $ba GFX
=$bb					KWD_GOSUB                            = $bb; $bb GOSUB
=$bc					KWD_GOTO                             = $bc; $bc GOTO
=$bd					KWD_HERE                             = $bd; $bd HERE
=$be					KWD_IMAGE                            = $be; $be IMAGE
=$bf					KWD_INPUT                            = $bf; $bf INPUT
=$c0					KWD_LET                              = $c0; $c0 LET
=$c1					KWD_LINE                             = $c1; $c1 LINE
=$c2					KWD_LOCAL                            = $c2; $c2 LOCAL
=$c3					KWD_OFF                              = $c3; $c3 OFF
=$c4					KWD_ON                               = $c4; $c4 ON
=$c5					KWD_OUTLINE                          = $c5; $c5 OUTLINE
=$c6					KWD_PALETTE                          = $c6; $c6 PALETTE
=$c7					KWD_PLOT                             = $c7; $c7 PLOT
=$c8					KWD_POKE                             = $c8; $c8 POKE
=$c9					KWD_PRINT                            = $c9; $c9 PRINT
=$ca					KWD_READ                             = $ca; $ca READ
=$cb					KWD_RECT                             = $cb; $cb RECT
=$cc					KWD_REM                              = $cc; $cc REM
=$cd					KWD_RETURN                           = $cd; $cd RETURN
=$ce					KWD_SOLID                            = $ce; $ce SOLID
=$cf					KWD_SOUND                            = $cf; $cf SOUND
=$d0					KWD_SPRITE                           = $d0; $d0 SPRITE
=$d1					KWD_TEXT                             = $d1; $d1 TEXT
=$d2					KWD_TO                               = $d2; $d2 TO

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst0.inc

=$80					KWC_EOL = $80
=$ff					KWC_STRING = $FF
=$fe					KWC_HEXCONST = $FE
=$a2					KWC_FIRST_STRUCTURE = $a2
=$a7					KWC_FIRST_STRUCTURE_DEC = $a7
=$ac					KWC_LAST_STRUCTURE = $ac
=$83					KWC_FIRST_UNARY = $83
=$a1					KWC_LAST_UNARY = $a1

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/access.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/stack.inc

=$e0					STK_GOSUB = $E0
=$d0					STK_FOR = $D0
=$c0					STK_REPEAT = $C0
=$b0					STK_PROC = $B0
=$a0					STK_WHILE = $A0
=$01					STK_LOCALN = $01
=$02					STK_LOCALS = $02

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/00start.asm

.8000	4c 24 80	jmp $8024	Boot:	jmp 	Start

;******  Processing file: ./common/aa.system/../../../modules/_build/_linker.module

=0					PagingEnabled = 0
.8003					EXTPrintCharacter:
.8003	4c f1 a7	jmp $a7f1		jmp	Export_EXTPrintCharacter
.8006					EXTInitialise:
.8006	4c 8a aa	jmp $aa8a		jmp	Export_EXTInitialise
.8009					EXTInputSingleCharacter:
.8009	4c c0 aa	jmp $aac0		jmp	Export_EXTInputSingleCharacter
.800c					EXTBreakCheck:
.800c	4c e6 aa	jmp $aae6		jmp	Export_EXTBreakCheck
.800f					EXTReadController:
.800f	4c e9 aa	jmp $aae9		jmp	Export_EXTReadController
.8012					EXTInputLine:
.8012	4c a0 a9	jmp $a9a0		jmp	Export_EXTInputLine
.8015					GXGraphicDraw:
.8015	4c 84 ab	jmp $ab84		jmp	Export_GXGraphicDraw
.8018					SNDCommand:
.8018	4c 6e be	jmp $be6e		jmp	Export_SNDCommand
.801b					SNDUpdate:
.801b	4c a1 be	jmp $bea1		jmp	Export_SNDUpdate
.801e					TKListConvertLine:
.801e	4c 64 b8	jmp $b864		jmp	Export_TKListConvertLine
.8021					TKTokeniseLine:
.8021	4c f8 ba	jmp $baf8		jmp	Export_TKTokeniseLine

;******  Return to file: ./common/aa.system/00start.asm

.8024	a2 ff		ldx #$ff	Start:	ldx 	#$FF 						; stack reset
.8026	9a		txs				txs
.8027	20 06 80	jsr $8006			jsr 	EXTInitialise 				; hardware initialise
.802a	a9 00		lda #$00			lda 	#0 							; graphics system initialise.
.802c	aa		tax				tax
.802d	a8		tay				tay
.802e	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.8031	a9 0f		lda #$0f			lda 	#$0F 						; initialise sound system
.8033	20 18 80	jsr $8018			jsr 	SNDCommand
.8036	a2 80		ldx #$80			ldx 	#Prompt >> 8 				; display prompt
.8038	a9 46		lda #$46			lda 	#Prompt & $FF
.803a	20 5d 8f	jsr $8f5d			jsr 	PrintStringXA
.803d	20 d5 89	jsr $89d5			jsr 	NewProgram 					; erase current program
.8040	20 e1 82	jsr $82e1			jsr 	BackloadProgram
.8043	4c 16 8b	jmp $8b16			jmp 	CommandRun
>8046	46 32 35 36 20 42 41 53		Prompt:	.text 	"F256 BASIC "
>804e	49 43 20

;******  Processing file: ./common/aa.system/../generated/timestamp.asm

>8051	52 65 6c 65 61 73 65 20			.text "Release Alpha 10 (02-Dec-22). "
>8059	41 6c 70 68 61 20 31 30 20 28 30 32 2d 44 65 63
>8069	2d 32 32 29 2e 20

;******  Return to file: ./common/aa.system/00start.asm

>806f	0d 0d 00					.text 	13,13,0

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/assembler.asm

.8072					AssembleGroup1:
.8072	a9 ff		lda #$ff			lda 	#$FF
.8074	8d 25 04	sta $0425			sta 	ModeMask 					; initialise the mode mask - all for all
.8077	80 02		bra $807b			bra 	AsmGroup12
.8079					AssembleGroup2:
.8079	a9 00		lda #$00			lda 	#$00
.807b					AsmGroup12:
.807b	8d 23 04	sta $0423			sta 	IsGroup1 					; save the 'group 1' flag
.807e	68		pla				pla 								; pop the return address to access the information following.
.807f	fa		plx				plx
.8080	20 07 81	jsr $8107			jsr 	AccessParameters 			; get opcode and save as base
.8083	8d 24 04	sta $0424			sta 	BaseOpcode
.8086	ad 23 04	lda $0423			lda 	IsGroup1 					; skip if group 1 as we don't have a complex mask.
.8089	d0 08		bne $8093			bne 	_AG12HaveMask
.808b	a9 02		lda #$02			lda 	#2 							; if group 2 the second parameter is the mask
.808d	20 0f 81	jsr $810f			jsr 	GetParameter		 		; e.g. which modes are supported for this operand
.8090	8d 25 04	sta $0425			sta 	ModeMask
.8093					_AG12HaveMask:
.8093	20 43 82	jsr $8243			jsr 	TypeAndCalculateOperand 	; get zero page type
.8096	da		phx				phx 								; save found address mode
.8097	20 73 81	jsr $8173			jsr 	AssembleModeX
.809a	fa		plx				plx  								; restore address mode
.809b	b0 0b		bcs $80a8			bcs 	_AG12Exit
.809d	20 a9 80	jsr $80a9			jsr 	PromoteToAbsolute  			; promote ZP to ABS and try that
.80a0	20 73 81	jsr $8173			jsr 	AssembleModeX
.80a3	b0 03		bcs $80a8			bcs 	_AG12Exit
.80a5	4c a4 9f	jmp $9fa4			jmp 	SyntaxError 				; can't do either, so must be wrong mode/operand.
.80a8					_AG12Exit:
.80a8	60		rts				rts
.80a9					PromoteToAbsolute:
.80a9	a9 6c		lda #$6c			lda 	#AM_ABS 					; lda xx
.80ab	e0 e4		cpx #$e4			cpx 	#AM_ZEROPAGE
.80ad	f0 19		beq $80c8			beq 	_PTADo
.80af	a9 7c		lda #$7c			lda 	#AM_ABSX 					; lda xx,X
.80b1	e0 f4		cpx #$f4			cpx 	#AM_ZEROX
.80b3	f0 13		beq $80c8			beq 	_PTADo
.80b5	a9 78		lda #$78			lda 	#AM_ABSY 					; lda xx,Y
.80b7	e0 80		cpx #$80			cpx 	#AM_ZEROY
.80b9	f0 0d		beq $80c8			beq 	_PTADo
.80bb	a9 01		lda #$01			lda 	#AM_INDABS 					; lda (xx) (jump)
.80bd	e0 d1		cpx #$d1			cpx 	#AM_IND
.80bf	f0 07		beq $80c8			beq 	_PTADo
.80c1	a9 02		lda #$02			lda 	#AM_INDABSX 				; lda (xx,x) (jump)
.80c3	e0 c0		cpx #$c0			cpx 	#AM_INDX
.80c5	f0 01		beq $80c8			beq 	_PTADo
.80c7	60		rts				rts
.80c8					_PTADo:
.80c8	aa		tax				tax
.80c9	60		rts				rts
.80ca					AssembleGroup3:
.80ca	68		pla				pla 								; get parameters, which is just the opcode.
.80cb	fa		plx				plx
.80cc	20 07 81	jsr $8107			jsr 	AccessParameters 			; get and output opcode
.80cf	20 1f 81	jsr $811f			jsr 	AssemblerWriteByte
.80d2	20 a7 82	jsr $82a7			jsr 	CalculateOperand 			; get a 16 bit operand
.80d5	a5 58		lda $58				lda 	NSMantissa0 				; calculate the offset
.80d7	38		sec				sec
.80d8	ed 1e 04	sbc $041e			sbc 	AssemblerAddress
.80db	48		pha				pha 								; LSB in A
.80dc	a5 60		lda $60				lda 	NSMantissa1
.80de	ed 1f 04	sbc $041f			sbc 	AssemblerAddress+1
.80e1	aa		tax				tax 								; MSB in X
.80e2	68		pla				pla
.80e3	18		clc				clc 								; $80 to easy check $80-$7F, plus 1 for offset error
.80e4	69 7f		adc #$7f			adc 	#$7F
.80e6	90 01		bcc $80e9			bcc 	_AG3NoCarry
.80e8	e8		inx				inx
.80e9					_AG3NoCarry:
.80e9	38		sec				sec 								; fix back and write out anyways.
.80ea	e9 80		sbc #$80			sbc 	#$80
.80ec	20 1f 81	jsr $811f			jsr 	AssemblerWriteByte
.80ef	e0 00		cpx #$00			cpx 	#0 							; was it in range
.80f1	f0 0a		beq $80fd			beq 	_AG3Exit
.80f3	ad 20 04	lda $0420			lda 	AssemblerControl 			; are we allowing bad values ?
.80f6	29 01		and #$01			and 	#1
.80f8	f0 03		beq $80fd			beq 	_AG3Exit
.80fa	4c a9 9f	jmp $9fa9			jmp 	RangeError 					; no, branch is out of range
.80fd					_AG3Exit:
.80fd	60		rts				rts
.80fe					AssembleGroup4:
.80fe	68		pla				pla 								; pop address
.80ff	fa		plx				plx
.8100	20 07 81	jsr $8107			jsr 	AccessParameters 			; access and get first
.8103	20 1f 81	jsr $811f			jsr 	AssemblerWriteByte 			; output it.
.8106	60		rts				rts
.8107					AccessParameters:
.8107	8d 21 04	sta $0421			sta 	ParamStart
.810a	8e 22 04	stx $0422			stx 	ParamStart+1
.810d	a9 01		lda #$01			lda 	#1
.810f					GetParameter:
.810f	5a		phy				phy
.8110	a8		tay				tay
.8111	ad 21 04	lda $0421			lda 	ParamStart
.8114	85 36		sta $36				sta 	zTemp0
.8116	ad 22 04	lda $0422			lda 	ParamStart+1
.8119	85 37		sta $37				sta 	zTemp0+1
.811b	b1 36		lda ($36),y			lda 	(zTemp0),y
.811d	7a		ply				ply
.811e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/aswrite.asm

.811f					AssemblerWriteByte:
.811f	48		pha			pha
.8120	ad 20 04	lda $0420		lda 	AssemblerControl 				; check printing bytes ?
.8123	29 02		and #$02		and 	#2
.8125	f0 1b		beq $8142		beq 	_AWBNoPrint
.8127	ad 1f 04	lda $041f		lda		AssemblerAddress+1 				; print address
.812a	20 5d 81	jsr $815d		jsr 	PrintHex
.812d	ad 1e 04	lda $041e		lda		AssemblerAddress
.8130	20 5d 81	jsr $815d		jsr 	PrintHex
.8133	a9 20		lda #$20		lda 	#' '
.8135	20 03 80	jsr $8003		jsr 	EXTPrintCharacter
.8138	68		pla			pla 									; print byte
.8139	48		pha			pha
.813a	20 5d 81	jsr $815d		jsr 	PrintHex
.813d	a9 0d		lda #$0d		lda 	#13
.813f	20 03 80	jsr $8003		jsr 	EXTPrintCharacter
.8142					_AWBNoPrint:
.8142	ad 1e 04	lda $041e		lda		AssemblerAddress				; copy address to zTemp0
.8145	85 36		sta $36			sta 	zTemp0
.8147	ad 1f 04	lda $041f		lda		AssemblerAddress+1
.814a	f0 0e		beq $815a		beq 	_AWBRange
.814c	85 37		sta $37			sta 	zTemp0+1
.814e	68		pla			pla 									; write byte out
.814f	92 36		sta ($36)		sta 	(zTemp0)
.8151	ee 1e 04	inc $041e		inc 	AssemblerAddress 				; bump address
.8154	d0 03		bne $8159		bne 	_AWBNoCarry
.8156	ee 1f 04	inc $041f		inc 	AssemblerAddress+1
.8159					_AWBNoCarry:
.8159	60		rts			rts
.815a					_AWBRange:
.815a	4c a9 9f	jmp $9fa9		jmp 	RangeError
.815d					PrintHex:
.815d	48		pha				pha
.815e	4a		lsr a				lsr 	a
.815f	4a		lsr a				lsr 	a
.8160	4a		lsr a				lsr 	a
.8161	4a		lsr a				lsr 	a
.8162	20 66 81	jsr $8166			jsr 	_PrintNibble
.8165	68		pla				pla
.8166					_PrintNibble:
.8166	29 0f		and #$0f			and 	#15
.8168	c9 0a		cmp #$0a			cmp 	#10
.816a	90 02		bcc $816e			bcc 	_NoShift
.816c	69 06		adc #$06			adc 	#6
.816e					_NoShift:
.816e	69 30		adc #$30			adc 	#48
.8170	4c 03 80	jmp $8003			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/instruction.asm

.8173					AssembleModeX:
.8173	5a		phy				phy
.8174	ad 23 04	lda $0423			lda 	IsGroup1
.8177	f0 17		beq $8190			beq 	_AMXGroup2
.8179	8a		txa				txa 							; is it in group # 1
.817a	29 40		and #$40			and 	#AM_ISG1
.817c	f0 4d		beq $81cb			beq 	_AMXFail 				; no, give up.
.817e	8a		txa				txa 							; get back.
.817f	29 1f		and #$1f			and 	#$1F 					; this is now the offset.
.8181	e0 e0		cpx #$e0			cpx 	#AM_IMMEDIATE 			; if not immediate, we can continue.
.8183	d0 22		bne $81a7			bne 	_AMXHaveInfo
.8185	ad 24 04	lda $0424			lda 	BaseOpcode 				; cannot store immediate.
.8188	c9 81		cmp #$81			cmp 	#$81
.818a	f0 3f		beq $81cb			beq 	_AMXFail
.818c	a9 08		lda #$08			lda 	#8 						; if immediate we use offset 8.
.818e	80 17		bra $81a7			bra 	_AMXHaveInfo 			; odd design decision there.
.8190					_AMXGroup2:
.8190	8a		txa				txa 							; is it in group 2 ?
.8191	29 20		and #$20			and 	#AM_ISG2
.8193	f0 36		beq $81cb			beq 	_AMXFail 				; no, give up.
.8195	8a		txa				txa 							; get the offset into Y
.8196	29 1f		and #$1f			and 	#$1F
.8198	4a		lsr a				lsr 	a 						; make it 0-7.
.8199	4a		lsr a				lsr  	a
.819a	a8		tay				tay
.819b	ad 25 04	lda $0425			lda 	ModeMask 				; shift the modemask left so you can check it against the requested offset
.819e					_AMXCheckOkay:
.819e	0a		asl a				asl 	a 						; shift modemask left enough times to check legitimate.
.819f	88		dey				dey
.81a0	10 fc		bpl $819e			bpl 	_AMXCheckOkay
.81a2	90 27		bcc $81cb			bcc 	_AMXFail 				; not allowed.
.81a4	8a		txa				txa  							; get mask back
.81a5	29 1f		and #$1f			and 	#$1F
.81a7					_AMXHaveInfo:
.81a7	e0 00		cpx #$00			cpx 	#$00 					; does it *require* an 8 bit operand
.81a9	10 04		bpl $81af			bpl 	_AMXAnySize 			; checking bit 7, the zero page opcode flag.
.81ab	a4 60		ldy $60				ldy 	NSMantissa1 			; fail if it is outside range, e.g. the MSB is set.
.81ad	d0 1c		bne $81cb			bne 	_AMXFail
.81af					_AMXAnySize:
.81af	18		clc				clc 							; add offset to the base opcode
.81b0	6d 24 04	adc $0424			adc 	BaseOpcode
.81b3					_AMXOutputCode:
.81b3	20 1f 81	jsr $811f			jsr 	AssemblerWriteByte 		; write the opcode out.
.81b6	e0 28		cpx #$28			cpx 	#AM_ACC 				; A mode (e.g. ASL A)
.81b8	f0 0e		beq $81c8			beq 	_AMXExit
.81ba	a5 58		lda $58				lda 	NSMantissa0 				; write LSB operand
.81bc	20 1f 81	jsr $811f			jsr 	AssemblerWriteByte
.81bf	e0 00		cpx #$00			cpx 	#$00 					; zeropage ?
.81c1	30 05		bmi $81c8			bmi 	_AMXExit
.81c3	a5 60		lda $60				lda 	NSMantissa1 			; write MSB operand
.81c5	20 1f 81	jsr $811f			jsr 	AssemblerWriteByte
.81c8					_AMXExit:
.81c8	7a		ply				ply
.81c9	38		sec				sec
.81ca	60		rts				rts
.81cb					_AMXFail:
.81cb	a0 00		ldy #$00			ldy 	#0
.81cd					_AMXCheckOddities:
.81cd	8a		txa				txa
.81ce	d9 f5 81	cmp $81f5,y			cmp 	ExtraOpcode+2,y 		; match address mode
.81d1	d0 15		bne $81e8			bne 	_AMXCONext
.81d3	b9 f3 81	lda $81f3,y			lda 	ExtraOpcode+0,y 		; do the base opcodes match
.81d6	cd 24 04	cmp $0424			cmp 	BaseOpcode
.81d9	d0 0d		bne $81e8			bne 	_AMXCONext
.81db	e0 00		cpx #$00			cpx 	#$00 					; requires zero page ?
.81dd	10 04		bpl $81e3			bpl 	_AMXCONotZero
.81df	a5 60		lda $60				lda 	NSMantissa1
.81e1	d0 05		bne $81e8			bne 	_AMXCONext
.81e3					_AMXCONotZero:
.81e3	b9 f4 81	lda $81f4,y			lda 	ExtraOpcode+1,y 		; get new opcode
.81e6	80 cb		bra $81b3			bra 	_AMXOutputCode 			; and assemble it
.81e8					_AMXCONext:
.81e8	c8		iny				iny
.81e9	c8		iny				iny
.81ea	c8		iny				iny
.81eb	b9 f3 81	lda $81f3,y			lda 	ExtraOpcode+0,y 		; end of table
.81ee	d0 dd		bne $81cd			bne 	_AMXCheckOddities
.81f0					_AMXCOFail:
.81f0	7a		ply				ply
.81f1	18		clc				clc
.81f2	60		rts				rts
.81f3					ExtraOpcode:
>81f3	40 6c 01					.byte $40,$6c,AM_INDABS 	; jump
>81f6	40 7c 02					.byte $40,$7C,AM_INDABSX 	; jump
>81f9	a2 be 78					.byte $a2,$BE,AM_ABSY 		; ldx
>81fc	a2 b6 80					.byte $a2,$B6,AM_ZEROY 		; ldx
>81ff	82 96 80					.byte $82,$96,AM_ZEROY 		; stx
>8202	e2 1a 28					.byte $e2,$1a,AM_ACC 		; inc
>8205	c2 3a 28					.byte $c2,$3a,AM_ACC 		; dec
>8208	20 89 e0					.byte $20,$89,AM_IMMEDIATE 	; bit
>820b	60 9c 6c					.byte $60,$9c,AM_ABS 		; stz
>820e	60 9e 7c					.byte $60,$9e,AM_ABSX 		; stz
>8211	00						.byte $00

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/label.asm

.8212					LabelHere:
.8212	c8		iny				iny 								; skip .
.8213	a2 00		ldx #$00			ldx 	#0 							; get a term
.8215	20 52 98	jsr $9852			jsr 	EvaluateTerm 				; get a term
.8218	a5 50		lda $50				lda 	NSStatus 					; needs to be an integer reference.
.821a	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.821c	d0 22		bne $8240			bne 	_ALType
.821e	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy reference address to zTemp0
.8220	85 36		sta $36				sta 	zTemp0
.8222	b5 60		lda $60,x			lda 	NSMantissa1,x
.8224	85 37		sta $37				sta 	zTemp0+1
.8226	5a		phy				phy 								; copy address in.
.8227	a0 01		ldy #$01			ldy 	#1
.8229	ad 1e 04	lda $041e			lda	 	AssemblerAddress
.822c	92 36		sta ($36)			sta 	(zTemp0)
.822e	ad 1f 04	lda $041f			lda	 	AssemblerAddress+1
.8231	91 36		sta ($36),y			sta 	(zTemp0),y
.8233	c8		iny				iny
.8234	a9 00		lda #$00			lda 	#0
.8236	91 36		sta ($36),y			sta 	(zTemp0),y
.8238	c8		iny				iny
.8239	91 36		sta ($36),y			sta 	(zTemp0),y
.823b	c8		iny				iny
.823c	91 36		sta ($36),y			sta 	(zTemp0),y
.823e	7a		ply				ply
.823f	60		rts				rts
.8240					_ALType:
.8240	4c ae 9f	jmp $9fae			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/operands.asm

.8243					TypeAndCalculateOperand:
.8243	b1 30		lda ($30),y			lda 	(codePtr),y
.8245	a2 28		ldx #$28			ldx 	#AM_ACC 					; ACC if : or EOL
.8247	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.8249	f0 5b		beq $82a6			beq 	_TACOExit
.824b	c9 80		cmp #$80			cmp 	#KWC_EOL
.824d	f0 57		beq $82a6			beq 	_TACOExit
.824f	c8		iny				iny
.8250	a2 e0		ldx #$e0			ldx 	#AM_IMMEDIATE
.8252	c9 23		cmp #$23			cmp 	#KWD_HASH 					; if hash, then immediate - constant.
.8254	f0 51		beq $82a7			beq 	CalculateOperand
.8256	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; if ( then check for indirection
.8258	f0 1f		beq $8279			beq 	_TACOIndirect
.825a	88		dey				dey 								; undo get of first character
.825b	20 a7 82	jsr $82a7			jsr 	CalculateOperand 			; get operand
.825e	b1 30		lda ($30),y			lda 	(codePtr),y
.8260	a2 e4		ldx #$e4			ldx 	#AM_ZEROPAGE 				; if not, try zero page (then absolute)
.8262	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8264	d0 40		bne $82a6			bne 	_TACOExit
.8266	c8		iny				iny
.8267	20 b1 82	jsr $82b1			jsr 	TACOCheckXY 				; extract X,Y or 0 (neither) from the variable.
.826a	a2 f4		ldx #$f4			ldx 	#AM_ZEROX 					; check for X
.826c	c9 58		cmp #$58			cmp 	#'X'
.826e	f0 36		beq $82a6			beq 	_TACOExit
.8270	a2 80		ldx #$80			ldx 	#AM_ZEROY 					; check for Y
.8272	c9 59		cmp #$59			cmp 	#'Y'
.8274	f0 30		beq $82a6			beq 	_TACOExit
.8276					_TACOSyntax:
.8276	4c a4 9f	jmp $9fa4			jmp 	SyntaxError
.8279					_TACOIndirect:
.8279	20 a7 82	jsr $82a7			jsr 	CalculateOperand 			; get the operand
.827c	b1 30		lda ($30),y			lda 	(codePtr),y
.827e	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if , then it must be ,X)
.8280	f0 17		beq $8299			beq 	_TACOIndX
.8282	20 eb 8e	jsr $8eeb			jsr 	CheckRightBracket  			; otherwise must be ) or ),Y
.8285	b1 30		lda ($30),y			lda 	(codePtr),y
.8287	a2 d1		ldx #$d1			ldx 	#AM_IND
.8289	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not comma then exit with (xx)
.828b	d0 19		bne $82a6			bne 	_TACOExit
.828d	c8		iny				iny
.828e	20 b1 82	jsr $82b1			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.8291	c9 59		cmp #$59			cmp 	#'Y' 						; check Y
.8293	d0 e1		bne $8276			bne 	_TACOSyntax
.8295	a2 d0		ldx #$d0			ldx 	#AM_INDY
.8297	80 0d		bra $82a6			bra 	_TACOExit
.8299					_TACOIndX:
.8299	c8		iny				iny
.829a	20 b1 82	jsr $82b1			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.829d	c9 58		cmp #$58			cmp 	#'X' 						; check X
.829f	d0 d5		bne $8276			bne 	_TACOSyntax
.82a1	20 eb 8e	jsr $8eeb			jsr 	CheckRightBracket			; check )
.82a4	a2 c0		ldx #$c0			ldx 	#AM_INDX
.82a6					_TACOExit:
.82a6	60		rts				rts
.82a7					CalculateOperand:
.82a7	48		pha				pha
.82a8	da		phx				phx
.82a9	a2 00		ldx #$00			ldx 	#0 							; get 16 bit integer in Slot 0
.82ab	20 a6 9d	jsr $9da6			jsr 	Evaluate16BitInteger
.82ae	fa		plx				plx
.82af	68		pla				pla
.82b0	60		rts				rts
.82b1					TACOCheckXY:
.82b1	b1 30		lda ($30),y			lda 	(codePtr),y
.82b3	29 c0		and #$c0			and 	#$C0 						; check it is an identifier reference.
.82b5	c9 40		cmp #$40			cmp 	#$40
.82b7	d0 21		bne $82da			bne 	_TCXYFail
.82b9	b1 30		lda ($30),y			lda 	(codePtr),y
.82bb	18		clc				clc
.82bc	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.82be	85 37		sta $37				sta 	zTemp0+1
.82c0	c8		iny				iny
.82c1	b1 30		lda ($30),y			lda 	(codePtr),y
.82c3	c8		iny				iny
.82c4	85 36		sta $36				sta 	zTemp0
.82c6	5a		phy				phy 								; save position
.82c7	a0 02		ldy #$02			ldy 	#2 							; type is integer ?
.82c9	b1 36		lda ($36),y			lda 	(zTemp0),y
.82cb	d0 0c		bne $82d9			bne 	_TCXYPopFail
.82cd	a0 08		ldy #$08			ldy 	#8 							; get first character, should have bit 7 set as also last.
.82cf	b1 36		lda ($36),y			lda 	(zTemp0),y
.82d1	c9 d8		cmp #$d8			cmp 	#'X'+$80 					; should be X or Y
.82d3	f0 08		beq $82dd			beq 	_TCXYFound
.82d5	c9 d9		cmp #$d9			cmp 	#'Y'+$80
.82d7	f0 04		beq $82dd			beq 	_TCXYFound
.82d9					_TCXYPopFail:
.82d9	7a		ply				ply
.82da					_TCXYFail:
.82da	a9 00		lda #$00			lda 	#0
.82dc	60		rts				rts
.82dd					_TCXYFound:
.82dd	7a		ply				ply 								; restore position
.82de	29 7f		and #$7f			and 	#$7F 						; throw bit 7
.82e0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/backload.asm

.82e1					BackloadProgram:
.82e1	a2 83		ldx #$83			ldx 	#_BLLoad >> 8
.82e3	a9 32		lda #$32			lda 	#_BLLoad & $FF
.82e5	20 5d 8f	jsr $8f5d			jsr 	PrintStringXA
.82e8	a5 0b		lda $0b				lda 	8+3 						; save current mapping for $6000
.82ea	48		pha				pha
.82eb	a9 14		lda #$14			lda 	#SOURCE_ADDRESS >> 13 		; map source code in there.
.82ed	85 0b		sta $0b				sta 	8+3
.82ef	a9 00		lda #$00			lda 	#(($6000) & $FF)
.82f1	8d 59 06	sta $0659			sta 	0+BackLoadPointer
.82f4	a9 60		lda #$60			lda 	#(($6000) >> 8)
.82f6	8d 5a 06	sta $065a			sta 	1+BackLoadPointer
.82f9	a9 ff		lda #$ff			lda 	#$FF
.82fb	8d fa ff	sta $fffa			sta 	$FFFA
.82fe					_BPLoop:
.82fe	a2 ff		ldx #$ff			ldx 	#$FF
.8300	20 47 83	jsr $8347			jsr 	BLReadByte 					; read a byte
.8303	c9 00		cmp #$00			cmp 	#0
.8305	f0 21		beq $8328			beq 	_BPExit 					; if 0 exit
.8307	30 1f		bmi $8328			bmi 	_BPExit 					; if -ve exit
.8309					_BPCopy:
.8309	e8		inx				inx  								; copy byte into the lineBuffer
.830a	9d 2a 05	sta $052a,x			sta 	lineBuffer,x
.830d	9e 2b 05	stz $052b,x			stz 	lineBuffer+1,x
.8310	20 47 83	jsr $8347			jsr 	BLReadByte 					; read next byte
.8313	30 0a		bmi $831f			bmi 	_BPEndLine 					; -ve = EOL
.8315	c9 09		cmp #$09			cmp 	#9 							; handle TAB, make it space.
.8317	d0 02		bne $831b			bne 	_BPNotTab
.8319	a9 20		lda #$20			lda 	#' '
.831b					_BPNotTab:
.831b	c9 20		cmp #$20			cmp 	#' ' 						; < ' ' = EOL
.831d	b0 ea		bcs $8309			bcs 	_BPCopy 					; until a control character, should be 13 received.
.831f					_BPEndLine:
.831f	20 21 80	jsr $8021			jsr 	TKTokeniseLine 				; tokenise the line.
.8322	ea		nop				nop
.8323	20 5e 83	jsr $835e			jsr 	EditProgramCode
.8326	80 d6		bra $82fe			bra 	_BPLoop
.8328					_BPExit:
.8328	68		pla				pla 								; restore memory setup.
.8329	85 0b		sta $0b				sta 	8+3
.832b	9c fa ff	stz $fffa			stz 	$FFFA
.832e	20 19 84	jsr $8419			jsr 	ClearCommand 				; clear variables etc.
.8331	60		rts				rts
.8332					_BLLoad:
>8332	4c 6f 61 64 69 6e 67 20				.text 	"Loading from Memory",13,0
>833a	66 72 6f 6d 20 4d 65 6d 6f 72 79 0d 00
.8347					BLReadByte:
.8347	ad 59 06	lda $0659			lda 	BackLoadPointer 			; copy pointer to zTemp0
.834a	85 36		sta $36				sta 	zTemp0
.834c	ad 5a 06	lda $065a			lda 	BackLoadPointer+1
.834f	85 37		sta $37				sta 	zTemp0+1
.8351	b2 36		lda ($36)			lda 	(zTemp0) 					; read next byte
.8353	ee 59 06	inc $0659			inc 	BackLoadPointer 			; bump pointer
.8356	d0 03		bne $835b			bne 	_BLNoCarry
.8358	ee 5a 06	inc $065a			inc 	BackLoadPointer+1
.835b					_BLNoCarry:
.835b	c9 00		cmp #$00			cmp 	#0
.835d	60		rts				rts
.0659					BackLoadPointer:
>0659							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/editor.asm

.835e					EditProgramCode:
.835e	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; try to find the line.
.8361	ae 2c 04	ldx $042c			ldx 	TokenLineNumber+1
.8364	20 93 a5	jsr $a593			jsr 	MemorySearch
.8367	90 05		bcc $836e			bcc 	_EPCNoDelete 				; reached the end : don't delete
.8369	d0 03		bne $836e			bne 	_EPCNoDelete 				; found slot but didn't match : no delete
.836b	20 b8 a4	jsr $a4b8			jsr 	MemoryDeleteLine 			; delete the line
.836e					_EPCNoDelete:
.836e	ad 2d 04	lda $042d			lda 	TokenBuffer 				; buffer empty - we just want to delete a line.
.8371	c9 80		cmp #$80			cmp 	#KWC_EOL
.8373	f0 0d		beq $8382			beq 	_EPCNoInsert
.8375	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; find the line - it cannot exist as we've just deleted it.
.8378	ae 2c 04	ldx $042c			ldx 	TokenLineNumber+1 			; so this can't fail, it returns some point in the code.
.837b	20 93 a5	jsr $a593			jsr 	MemorySearch
.837e	18		clc				clc 								; insert at this point.
.837f	20 ef a4	jsr $a4ef			jsr 	MemoryInsertLine 			; insert the line
.8382					_EPCNoInsert:
.8382	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/warmstart.asm

.8383					WarmStart:
.8383	a2 ff		ldx #$ff			ldx 	#$FF
.8385	9a		txs				txs
.8386	a9 85		lda #$85			lda 	#CLICommandLine+$80 		; set console colour whatever the current colour is.
.8388	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.838b	20 12 80	jsr $8012			jsr 	EXTInputLine 				; get line to lineBuffer
.838e	20 21 80	jsr $8021			jsr 	TKTokeniseLine 				; tokenise the line
.8391	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; line number <> 0
.8394	0d 2c 04	ora $042c			ora 	TokenLineNumber+1
.8397	d0 17		bne $83b0			bne 	_WSEditCode 				; if so,edit code.
.8399	9c 2a 04	stz $042a			stz 	TokenOffset 				; zero the "offset", meaning it only runs one line.
.839c	a9 2a		lda #$2a			lda 	#((TokenOffset) & $FF)
.839e	85 30		sta $30				sta 	codePtr
.83a0	a9 04		lda #$04			lda 	#((TokenOffset) >> 8)
.83a2	85 31		sta $31				sta 	codePtr+1
.83a4	ad 2d 04	lda $042d			lda 	TokenBuffer 				; nothing to run
.83a7	c9 80		cmp #$80			cmp 	#KWC_EOL
.83a9	f0 d8		beq $8383			beq 	WarmStart
.83ab	20 28 8b	jsr $8b28			jsr 	RUNCodePointerLine 			; execute that line.
.83ae	80 d3		bra $8383			bra 	WarmStart
.83b0					_WSEditCode:
.83b0	20 5e 83	jsr $835e			jsr 	EditProgramCode 			; edit the program code
.83b3	20 19 84	jsr $8419			jsr 	ClearCommand 				; clear all variables etc.
.83b6	80 cb		bra $8383			bra 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assemble.asm

.83b8					AssembleCommand:
.83b8	a2 00		ldx #$00			ldx 	#0
.83ba	20 a6 9d	jsr $9da6			jsr 	Evaluate16BitInteger 		; start address
.83bd	a5 58		lda $58				lda 	NSMantissa0
.83bf	8d 1e 04	sta $041e			sta 	AssemblerAddress
.83c2	a5 60		lda $60				lda 	NSMantissa1
.83c4	8d 1f 04	sta $041f			sta 	AssemblerAddress+1
.83c7	20 f3 8e	jsr $8ef3			jsr 	CheckComma
.83ca	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger 		; options 0-3
.83cd	a5 58		lda $58				lda 	NSMantissa0
.83cf	8d 20 04	sta $0420			sta 	AssemblerControl
.83d2	60		rts				rts
.83d3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assert.asm

.83d4					AssertCommand:
.83d4	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.83d6	20 93 9d	jsr $9d93			jsr 	EvaluateInteger 			; the assert test
.83d9	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; exit if result is non zero.
.83dc	d0 05		bne $83e3			bne 	_ACExit
.83de	a9 0a		lda #$0a		lda	#10
.83e0	4c 04 8f	jmp $8f04		jmp	ErrorHandler
.83e3					_ACExit:
.83e3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/call.asm

.83e4					CallCommand:
.83e4	a2 00		ldx #$00			ldx 	#0 							; get the routine address to level 0
.83e6	20 a6 9d	jsr $9da6			jsr 	Evaluate16BitInteger
.83e9					_CCClear
.83e9	e8		inx				inx  								; clear 1,2 and 3 (for A X Y)
.83ea	20 26 9e	jsr $9e26			jsr 	NSMSetZero 					; these are optional sequentially.
.83ed	e0 04		cpx #$04			cpx 	#4
.83ef	d0 f8		bne $83e9			bne 	_CCClear
.83f1	a2 00		ldx #$00			ldx 	#0 							; and keep trying while there are more values.
.83f3					_CCCParam:
.83f3	b1 30		lda ($30),y			lda 	(codePtr),y
.83f5	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.83f7	d0 09		bne $8402			bne 	_CCCRun6502
.83f9	c8		iny				iny 								; skip comma
.83fa	e8		inx				inx	 								; next level
.83fb	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger 		; get A/X/Y
.83fe	e0 03		cpx #$03			cpx 	#3
.8400	90 f1		bcc $83f3			bcc 	_CCCParam 					; done all 3 ?
.8402					_CCCRun6502:
.8402	5a		phy				phy 								; save position
.8403	a5 60		lda $60				lda 	NSMantissa1 				; put address in zTemp0
.8405	85 37		sta $37				sta 	zTemp0+1
.8407	a5 58		lda $58				lda 	NSMantissa0
.8409	85 36		sta $36				sta 	zTemp0
.840b	a5 59		lda $59				lda 	NSMantissa0+1 				; get registers into A X Y
.840d	a6 5a		ldx $5a				ldx 	NSMantissa0+2
.840f	a4 5b		ldy $5b				ldy 	NSMantissa0+3
.8411	20 16 84	jsr $8416			jsr 	_CCCZTemp0 					; call zTemp0
.8414	7a		ply				ply 								; restore position and exit
.8415	60		rts				rts
.8416					_CCCZTemp0:
.8416	6c 36 00	jmp ($0036)			jmp 	(zTemp0)

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/clear.asm

.8419					ClearCommand:
.8419	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.841b	85 36		sta $36				sta 	0+zTemp0
.841d	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.841f	85 37		sta $37				sta 	1+zTemp0
.8421					_ClearZeroLoop:
.8421	b2 36		lda ($36)			lda 	(zTemp0) 					; end of variables if offset is zero.
.8423	f0 24		beq $8449			beq 	_ClearZeroEnd
.8425	a0 03		ldy #$03			ldy 	#3 							; erase the variables
.8427	a9 00		lda #$00			lda 	#0 							; set all the data to zero.
.8429					_ClearOneVariable:
.8429	91 36		sta ($36),y			sta 	(zTemp0),y
.842b	c8		iny				iny
.842c	c0 08		cpy #$08			cpy 	#8
.842e	d0 f9		bne $8429			bne 	_ClearOneVariable
.8430	a0 02		ldy #$02			ldy 	#2 							; has it been marked procedure
.8432	b1 36		lda ($36),y			lda 	(zTemp0),y
.8434	c9 18		cmp #$18			cmp 	#NSTProcedure
.8436	d0 04		bne $843c			bne 	_ClearNotProcedure
.8438	a9 04		lda #$04			lda 	#NSTInteger+NSBIsArray 		; if so set it back to an integer array
.843a	91 36		sta ($36),y			sta 	(zTemp0),y 					; will be fixed on the pre-run scan.
.843c					_ClearNotProcedure:
.843c	18		clc				clc 								; go to the next variable
.843d	b2 36		lda ($36)			lda 	(zTemp0) 					; offset to next, add to zTemp0
.843f	65 36		adc $36				adc 	zTemp0
.8441	85 36		sta $36				sta 	zTemp0
.8443	90 dc		bcc $8421			bcc 	_ClearZeroLoop
.8445	e6 37		inc $37				inc 	zTemp0+1
.8447	80 d8		bra $8421			bra 	_ClearZeroLoop
.8449					_ClearZeroEnd:
.8449	18		clc				clc
.844a	a5 36		lda $36				lda 	zTemp0
.844c	69 01		adc #$01			adc 	#1
.844e	8d 0c 04	sta $040c			sta 	lowMemPtr
.8451	a5 37		lda $37				lda 	zTemp0+1
.8453	69 00		adc #$00			adc 	#0
.8455	8d 0d 04	sta $040d			sta 	lowMemPtr+1
.8458	20 1f a7	jsr $a71f			jsr 	StackReset
.845b	20 85 a7	jsr $a785			jsr 	StringSystemInitialise
.845e	20 91 8d	jsr $8d91			jsr 	ProcedureScan
.8461	20 d7 8a	jsr $8ad7			jsr 	Command_Restore
.8464	9c 1e 04	stz $041e			stz 	AssemblerAddress
.8467	9c 1f 04	stz $041f			stz 	AssemblerAddress+1
.846a	9c 20 04	stz $0420			stz 	AssemblerControl
.846d	20 39 9a	jsr $9a39			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.8470	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/cls.asm

.8471					ClearScreen:
.8471	5a		phy				phy
.8472	a9 0c		lda #$0c			lda 	#12 						; char code 12 clears the screen.
.8474	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8477	7a		ply				ply
.8478	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/data.asm

.8479					Command_Data:
.8479	a9 3a		lda #$3a			lda 	#KWD_COLON 					; advance to colon/EOL, e.g. ignore anything till then.
.847b	a2 80		ldx #$80			ldx 	#KWC_EOL
.847d	20 e3 8d	jsr $8de3			jsr 	ScanForward
.8480	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dim.asm

.8481					DimCommand:
.8481	b1 30		lda ($30),y			lda 	(codePtr),y
.8483	29 c0		and #$c0			and 	#$C0
.8485	c9 40		cmp #$40			cmp 	#$40
.8487	d0 7a		bne $8503			bne 	_DCSyntax 				; n o, error.
.8489	b1 30		lda ($30),y			lda 	(codePtr),y
.848b	18		clc				clc
.848c	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.848e	85 3f		sta $3f				sta 	zaTemp+1
.8490	c8		iny				iny
.8491	b1 30		lda ($30),y			lda 	(codePtr),y
.8493	c8		iny				iny
.8494	85 3e		sta $3e				sta 	zaTemp
.8496	5a		phy				phy
.8497	a0 02		ldy #$02			ldy 	#2 						; read type byte
.8499	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.849b	29 18		and #$18			and 	#NSBTypeMask 			; check it's not a procedure
.849d	c9 18		cmp #$18			cmp 	#NSTProcedure
.849f	f0 62		beq $8503			beq 	_DCSyntax
.84a1	b1 3e		lda ($3e),y			lda 	(zaTemp),y 				; check it's an array
.84a3	29 04		and #$04			and 	#NSBIsArray
.84a5	f0 64		beq $850b			beq 	_DCType
.84a7	a0 04		ldy #$04			ldy 	#4 						; check not already defined
.84a9	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84ab	d0 59		bne $8506			bne 	_DCRedefine
.84ad	7a		ply				ply
.84ae	20 0e 85	jsr $850e			jsr 	_DCGetSize 				; get array size, check it.
.84b1	5a		phy				phy
.84b2	a0 05		ldy #$05			ldy 	#5 						; store in first array size slot
.84b4	91 3e		sta ($3e),y			sta 	(zaTemp),y 				; second will be zero.
.84b6	7a		ply				ply 							; is there a second (e.g. ,x)
.84b7	b1 30		lda ($30),y			lda 	(codePtr),y
.84b9	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.84bb	d0 0a		bne $84c7			bne 	_DCOneDimension
.84bd	c8		iny				iny 							; skip comma
.84be	20 0e 85	jsr $850e			jsr 	_DCGetSize 				; get 2nd array size
.84c1	5a		phy				phy
.84c2	a0 06		ldy #$06			ldy 	#6 						; store in 2nd array size
.84c4	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84c6	7a		ply				ply
.84c7					_DCOneDimension:
.84c7	5a		phy				phy 							; save position
.84c8	a0 05		ldy #$05			ldy 	#5 						; dimensions + 1 in AX (as zero based)
.84ca	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84cc	aa		tax				tax
.84cd	c8		iny				iny
.84ce	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84d0	e8		inx				inx 							; bump them.
.84d1	1a		inc a				inc 	a
.84d2	20 d1 9d	jsr $9dd1			jsr 	Multiply8x8 			; work out the total number of elements -> zTemp0
.84d5	a5 37		lda $37				lda 	zTemp0+1 				; don't allow more than 8192 elements whatever
.84d7	29 e0		and #$e0			and 	#$E0
.84d9	d0 23		bne $84fe			bne 	_DCSize
.84db	a0 02		ldy #$02			ldy 	#2 						; get base type
.84dd	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84df	20 1c 85	jsr $851c			jsr 	ScaleByBaseType 		; scale by base type
.84e2	a5 36		lda $36				lda 	zTemp0
.84e4	a6 37		ldx $37				ldx 	zTemp0+1
.84e6	20 fb 99	jsr $99fb			jsr 	AllocateXABytes 		; allocate memory
.84e9	a0 03		ldy #$03			ldy 	#3 						; copy into the address.
.84eb	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84ed	c8		iny				iny
.84ee	8a		txa				txa
.84ef	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84f1	7a		ply				ply 							; get position back
.84f2	20 eb 8e	jsr $8eeb			jsr 	CheckRightBracket 		; check )
.84f5	b1 30		lda ($30),y			lda 	(codePtr),y
.84f7	c8		iny				iny 							; consume in case
.84f8	c9 2c		cmp #$2c			cmp 	#KWD_COMMA		 		; if so do another DIM.
.84fa	f0 85		beq $8481			beq 	DimCommand
.84fc	88		dey				dey 							; undo consume
.84fd	60		rts				rts
.84fe					_DCSize:
.84fe	a9 16		lda #$16		lda	#22
.8500	4c 04 8f	jmp $8f04		jmp	ErrorHandler
.8503					_DCSyntax:
.8503	4c a4 9f	jmp $9fa4			jmp 	SyntaxError
.8506					_DCRedefine:
.8506	a9 15		lda #$15		lda	#21
.8508	4c 04 8f	jmp $8f04		jmp	ErrorHandler
.850b					_DCType:
.850b	4c ae 9f	jmp $9fae			jmp 	TypeError
.850e					_DCGetSize:
.850e	a2 00		ldx #$00			ldx 	#0 						; get first index.
.8510	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger 	; get array dimension
.8513	c9 00		cmp #$00			cmp 	#0 						; must be 1-254
.8515	f0 e7		beq $84fe			beq 	_DCSize
.8517	c9 fe		cmp #$fe			cmp 	#254
.8519	f0 e3		beq $84fe			beq 	_DCSize
.851b	60		rts				rts
.851c					ScaleByBaseType:
.851c	29 10		and #$10			and 	#NSBIsString 			; is it string
.851e	d0 19		bne $8539			bne 	_SBBTString
.8520	a5 37		lda $37				lda 	zTemp0+1 				; push value on stack
.8522	48		pha				pha
.8523	a5 36		lda $36				lda 	zTemp0
.8525	48		pha				pha
.8526	06 36		asl $36				asl 	zTemp0 					; x 2
.8528	26 37		rol $37				rol 	zTemp0+1
.852a	06 36		asl $36				asl 	zTemp0 					; x 4
.852c	26 37		rol $37				rol 	zTemp0+1
.852e	68		pla				pla 							; add stacked value = x 5
.852f	65 36		adc $36				adc 	zTemp0
.8531	85 36		sta $36				sta 	zTemp0
.8533	68		pla				pla
.8534	65 37		adc $37				adc 	zTemp0+1
.8536	85 37		sta $37				sta 	zTemp0+1
.8538	60		rts				rts
.8539					_SBBTString:
.8539	06 36		asl $36				asl 	zTemp0
.853b	26 37		rol $37				rol 	zTemp0+1
.853d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dokepoke.asm

.853e					PokeCommand:
.853e	18		clc				clc
.853f	80 01		bra $8542			bra 	DPCommand
.8541					DokeCommand:
.8541	38		sec				sec
.8542					DPCommand:
.8542	08		php				php									; save on stack, CS = Doke, CC = Poke
.8543	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.8545	20 a6 9d	jsr $9da6			jsr		Evaluate16BitInteger 		; address
.8548	20 f3 8e	jsr $8ef3			jsr 	CheckComma
.854b	e8		inx				inx
.854c	20 a6 9d	jsr $9da6			jsr		Evaluate16BitInteger 		; data
.854f	a5 58		lda $58				lda 	NSMantissa0 				; copy address
.8551	85 36		sta $36				sta 	zTemp0
.8553	a5 60		lda $60				lda 	NSMantissa1
.8555	85 37		sta $37				sta 	zTemp0+1
.8557	a5 59		lda $59				lda 	NSMantissa0+1 				; low byte
.8559	92 36		sta ($36)			sta 	(zTemp0)
.855b	28		plp				plp 								; done if POKE
.855c	90 08		bcc $8566			bcc 	_DPExit
.855e	5a		phy				phy 								; write high byte out.
.855f	a0 01		ldy #$01			ldy 	#1
.8561	a5 61		lda $61				lda 	NSMantissa1+1
.8563	91 36		sta ($36),y			sta 	(zTemp0),y
.8565	7a		ply				ply
.8566					_DPExit:
.8566	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/end.asm

.8567					EndCommand:
.8567	4c 83 83	jmp $8383			jmp 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/for.asm

.856a					ForCommand:
.856a	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; allocate 18 bytes on the return stack (see above).
.856c	20 b9 a6	jsr $a6b9			jsr 	StackOpen
.856f	a2 00		ldx #$00			ldx 	#0
.8571	20 52 98	jsr $9852			jsr 	EvaluateTerm
.8574	b5 50		lda $50,x			lda 	NSStatus,x
.8576	c9 20		cmp #$20			cmp 	#NSBIsReference+NSTInteger 	; do we have an integer 4 byte reference.
.8578	d0 47		bne $85c1			bne		_FCError
.857a	a9 3d		lda #$3d			lda 	#KWD_EQUAL 					; =
.857c	20 fb 8e	jsr $8efb			jsr 	CheckNextA
.857f	e8		inx				inx
.8580	20 93 9d	jsr $9d93			jsr 	EvaluateInteger 			; <from> in +1
.8583	b1 30		lda ($30),y			lda 	(codePtr),y
.8585	c8		iny				iny 								; consume it
.8586	48		pha				pha 								; save on stack for later
.8587	c9 b7		cmp #$b7			cmp 	#KWD_DOWNTO
.8589	f0 04		beq $858f			beq 	_FCNoSyntax
.858b	c9 d2		cmp #$d2			cmp 	#KWD_TO
.858d	d0 35		bne $85c4			bne 	_FCSyntaxError
.858f					_FCNoSyntax:
.858f	e8		inx				inx
.8590	20 93 9d	jsr $9d93			jsr 	EvaluateInteger
.8593	20 fe a6	jsr $a6fe			jsr 	STKSaveCodePosition 		; save loop back position
.8596	68		pla				pla 								; restore DOWNTO or TO
.8597	5a		phy				phy 								; save Y on the stack
.8598	49 b7		eor #$b7			eor 	#KWD_DOWNTO 				; 0 if DOWNTO, #0 if TO
.859a	f0 02		beq $859e			beq 	_FCNotDownTo
.859c	a9 02		lda #$02			lda 	#2
.859e					_FCNotDownTo:
.859e	3a		dec a				dec 	a 							; 255 if DOWNTO, 1 if TO
.859f	a0 10		ldy #$10			ldy 	#16
.85a1	91 34		sta ($34),y			sta 	(basicStack),y 				; copy that out to the Basic Stack.
.85a3	a0 06		ldy #$06			ldy 	#6 							; this is the address of the loop variable.
.85a5	a5 58		lda $58				lda 	NSMantissa0
.85a7	91 34		sta ($34),y			sta 	(basicStack),y
.85a9	a5 60		lda $60				lda 	NSMantissa1
.85ab	c8		iny				iny
.85ac	91 34		sta ($34),y			sta 	(basicStack),y
.85ae	a0 08		ldy #$08			ldy 	#8 							; set initial index value
.85b0	a2 01		ldx #$01			ldx 	#1
.85b2	20 c7 85	jsr $85c7			jsr 	FCIntegerToStack
.85b5	a0 0c		ldy #$0c			ldy 	#12 						; set the terminal value
.85b7	a2 02		ldx #$02			ldx 	#2
.85b9	20 c7 85	jsr $85c7			jsr 	FCIntegerToStack
.85bc	20 e2 85	jsr $85e2			jsr 	CopyIndexToReference
.85bf	7a		ply				ply 								; restore position
.85c0	60		rts				rts
.85c1					_FCError:
.85c1	4c ae 9f	jmp $9fae			jmp 	TypeError
.85c4					_FCSyntaxError:
.85c4	4c a4 9f	jmp $9fa4			jmp 	SyntaxError
.85c7					FCIntegerToStack:
.85c7	34 50		bit $50,x			bit 	NSStatus,x 					; is the value negative
.85c9	10 03		bpl $85ce			bpl	 	_FCNotNegative
.85cb	20 ef 9d	jsr $9def			jsr 	NSMNegateMantissa 			; if so 2's complement the mantissa
.85ce					_FCNotNegative:
.85ce	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy out to the basic stack
.85d0	91 34		sta ($34),y			sta 	(basicStack),y
.85d2	c8		iny				iny
.85d3	b5 60		lda $60,x			lda 	NSMantissa1,x
.85d5	91 34		sta ($34),y			sta 	(basicStack),y
.85d7	c8		iny				iny
.85d8	b5 68		lda $68,x			lda 	NSMantissa2,x
.85da	91 34		sta ($34),y			sta 	(basicStack),y
.85dc	c8		iny				iny
.85dd	b5 70		lda $70,x			lda 	NSMantissa3,x
.85df	91 34		sta ($34),y			sta 	(basicStack),y
.85e1	60		rts				rts
.85e2					CopyIndexToReference:
.85e2	5a		phy				phy
.85e3	a0 06		ldy #$06			ldy 	#6 							; copy address-8 to write to zTemp0
.85e5	38		sec				sec 								; (because we copy from offset 8)
.85e6	b1 34		lda ($34),y			lda 	(basicStack),y
.85e8	e9 08		sbc #$08			sbc 	#8
.85ea	85 36		sta $36				sta 	zTemp0
.85ec	c8		iny				iny
.85ed	b1 34		lda ($34),y			lda 	(basicStack),y
.85ef	e9 00		sbc #$00			sbc 	#0
.85f1	85 37		sta $37				sta 	zTemp0+1
.85f3	a2 04		ldx #$04			ldx 	#4 							; this is the copy counter/
.85f5	a0 0b		ldy #$0b			ldy 	#8+3 		 				; the MSB of the mantissa
.85f7	b1 34		lda ($34),y			lda 	(basicStack),y
.85f9	0a		asl a				asl 	a 							; into carry
.85fa	a0 08		ldy #$08			ldy 	#8 							; where to copy from.
.85fc	90 14		bcc $8612			bcc 	_CITRNormal
.85fe	38		sec				sec
.85ff					_CITRNegative:
.85ff	a9 00		lda #$00			lda 	#0
.8601	f1 34		sbc ($34),y			sbc 	(basicStack),y
.8603	91 36		sta ($36),y			sta 	(zTemp0),y
.8605	c8		iny				iny
.8606	ca		dex				dex
.8607	d0 f6		bne $85ff			bne 	_CITRNegative
.8609	88		dey				dey 								; look at MSB of mantissa
.860a	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set the MSB as negative packed.
.860c	09 80		ora #$80			ora 	#$80
.860e	91 36		sta ($36),y			sta 	(zTemp0),y
.8610	7a		ply				ply
.8611	60		rts				rts
.8612					_CITRNormal:
.8612	b1 34		lda ($34),y			lda 	(basicStack),y 				; copy without negation.
.8614	91 36		sta ($36),y			sta 	(zTemp0),y
.8616	c8		iny				iny
.8617	ca		dex				dex
.8618	d0 f8		bne $8612			bne 	_CITRNormal
.861a	7a		ply				ply 								; and exit.
.861b	60		rts				rts
.861c					NextCommand:
.861c	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; check FOR is TOS
.861e	a2 11		ldx #$11			ldx 	#ERRID_FOR 					; this error
.8620	20 e6 a6	jsr $a6e6			jsr 	StackCheckFrame
.8623	5a		phy				phy
.8624	a0 10		ldy #$10			ldy 	#16 						; get the step count
.8626	b1 34		lda ($34),y			lda 	(basicStack),y
.8628	85 36		sta $36				sta 	zTemp0 						; this is the sign extend
.862a	30 02		bmi $862e			bmi 	_NCStepNeg
.862c	64 36		stz $36				stz 	zTemp0 						; which is 0 or 255
.862e					_NCStepNeg:
.862e	a0 08		ldy #$08			ldy 	#8 							; offset to bump
.8630	a2 04		ldx #$04			ldx 	#4 							; count to bump
.8632	18		clc				clc
.8633					_NCBump:
.8633	71 34		adc ($34),y			adc 	(basicStack),y 				; add it
.8635	91 34		sta ($34),y			sta 	(basicStack),y
.8637	a5 36		lda $36				lda 	zTemp0 						; get sign extend for next time.
.8639	c8		iny				iny 								; next byte
.863a	ca		dex				dex 								; do four times
.863b	d0 f6		bne $8633			bne 	_NCBump
.863d	20 e2 85	jsr $85e2			jsr		CopyIndexToReference		; copy it to the reference variable.
.8640	a0 10		ldy #$10			ldy 	#16 						; get step count again
.8642	b1 34		lda ($34),y			lda 	(basicStack),y
.8644	0a		asl a				asl 	a 							; sign bit to carry
.8645	a9 0c		lda #$0c			lda 	#12 						; offset of LHS = terminal offset
.8647	85 38		sta $38				sta 	zTemp1
.8649	90 02		bcc $864d			bcc 	_NCCompRev 					; use if step is +ve
.864b	a9 08		lda #$08			lda 	#8 							; now the LHS = index value
.864d					_NCCompRev:
.864d	85 38		sta $38				sta 	zTemp1 						; so zTemp0 is the index for LHS
.864f	49 04		eor #$04			eor 	#(8^12) 					; and zTemp0+1 is the index for RHS
.8651	85 39		sta $39				sta 	zTemp1+1
.8653	a2 04		ldx #$04			ldx 	#4 							; bytes to compare
.8655	38		sec				sec
.8656					_NCCompare:
.8656	a4 38		ldy $38				ldy 	zTemp1 						; do compare using the two indices
.8658	b1 34		lda ($34),y			lda 	(basicStack),y
.865a	a4 39		ldy $39				ldy 	zTemp1+1
.865c	f1 34		sbc ($34),y			sbc 	(basicStack),y
.865e	e6 38		inc $38				inc 	zTemp1 						; bump the indices (inc,dex do not change C or V)
.8660	e6 39		inc $39				inc 	zTemp1+1
.8662	ca		dex				dex 								; do it 4 times.
.8663	d0 f1		bne $8656			bne 	_NCCompare
.8665	50 02		bvc $8669			bvc 	_NCNoOverflow 				; convert to signed comparison
.8667	49 80		eor #$80			eor 	#$80
.8669					_NCNoOverflow:
.8669	7a		ply				ply 								; restore Y position
.866a	0a		asl a				asl 	a 							; is bit 7 set.
.866b	90 04		bcc $8671			bcc 	_NCLoopback 				; if no , >= so loop back
.866d	20 d8 a6	jsr $a6d8			jsr 	StackClose 					; exit the loop
.8670	60		rts				rts
.8671					_NCLoopBack:
.8671	20 0f a7	jsr $a70f			jsr 	STKLoadCodePosition 		; loop back
.8674	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/gosub.asm

.8675					Command_GOSUB:
.8675	a2 00		ldx #$00			ldx 	#0
.8677	20 a6 9d	jsr $9da6			jsr 	Evaluate16BitInteger 		; line number in Stack.0
.867a	a9 e3		lda #$e3			lda 	#STK_GOSUB+3
.867c	20 b9 a6	jsr $a6b9			jsr 	StackOpen 					; create frame
.867f	20 fe a6	jsr $a6fe			jsr 	STKSaveCodePosition 		; save current position
.8682	4c 98 86	jmp $8698			jmp 	GotoStackX
.8685					Command_RETURN:
.8685	a9 e0		lda #$e0			lda 	#STK_GOSUB 					; check TOS is this
.8687	a2 0e		ldx #$0e			ldx 	#ERRID_GOSUB 				; this error
.8689	20 e6 a6	jsr $a6e6			jsr 	StackCheckFrame
.868c	20 0f a7	jsr $a70f			jsr 	STKLoadCodePosition 		; restore code position
.868f	20 d8 a6	jsr $a6d8			jsr 	StackClose
.8692	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/goto.asm

.8693					GotoCommand:
.8693	a2 00		ldx #$00			ldx 	#0 							; GOTO where
.8695	20 a6 9d	jsr $9da6			jsr 	Evaluate16BitInteger
.8698					GotoStackX:
.8698	b5 60		lda $60,x			lda  	NSMantissa1,x 				; put line # in XA. I'll keep this even though
.869a	48		pha				pha 								; it is slightly inefficient, just in cases.
.869b	b5 58		lda $58,x			lda 	NSMantissa0,x
.869d	fa		plx				plx
.869e	20 93 a5	jsr $a593			jsr 	MemorySearch 				; transfer to line number AX.
.86a1	90 05		bcc $86a8			bcc 	_GotoError 					; not found, off end.
.86a3	d0 03		bne $86a8			bne 	_GotoError 					; not found exactly
.86a5	4c 21 8b	jmp $8b21			jmp 	RunNewLine 					; and go straight to new line code.
.86a8					_GotoError:
.86a8	a9 0d		lda #$0d		lda	#13
.86aa	4c 04 8f	jmp $8f04		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/if.asm

.86ad					IfCommand:
.86ad	a2 00		ldx #$00			ldx 	#0 							; Get the if test.
.86af	20 74 9d	jsr $9d74			jsr 	EvaluateNumber
.86b2	b1 30		lda ($30),y			lda 	(codePtr),y
.86b4	c9 aa		cmp #$aa			cmp 	#KWD_THEN  					; could be THEN <stuff>
.86b6	d0 0a		bne $86c2			bne 	_IFStructured 				; we still support it.
.86b8	c8		iny				iny 								; consume THEN
.86b9	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; is it zero
.86bc	f0 01		beq $86bf			beq 	_IfFail 					; if fail, go to next line
.86be	60		rts				rts 								; if THEN just continue
.86bf					_IfFail:
.86bf	4c 09 8b	jmp $8b09			jmp 	EOLCommand
.86c2					_IfStructured:
.86c2	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; is it zero
.86c5	d0 07		bne $86ce			bne 	_IfExit 					; if not, then continue normally.
.86c7	a9 b8		lda #$b8			lda 	#KWD_ELSE 					; look for else/endif
.86c9	a2 a7		ldx #$a7			ldx 	#KWD_ENDIF
.86cb	20 e3 8d	jsr $8de3			jsr 	ScanForward 				; and run from there
.86ce					_IfExit:
.86ce	60		rts				rts
.86cf					ElseCode:
.86cf	a9 a7		lda #$a7			lda 	#KWD_ENDIF 					; else is only run after the if clause succeeds
.86d1	aa		tax				tax 								; so just go to the structure exit
.86d2	20 e3 8d	jsr $8de3			jsr 	ScanForward
.86d5	60		rts				rts
.86d6					EndIf:
.86d6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/inputprint.asm

.86d7					Command_Input:
.86d7	a9 ff		lda #$ff			lda 	#$FF 						; set input flag
.86d9	8d 28 04	sta $0428			sta 	IsInputFlag
.86dc	80 03		bra $86e1			bra 	Command_IP_Main
.86de					Command_Print:
.86de	9c 28 04	stz $0428			stz 	IsInputFlag 				; clear input flag
.86e1					Command_IP_Main:
.86e1	18		clc				clc 								; carry being clear means last print wasn't comma/semicolon
.86e2					_CPLoop:
.86e2	08		php				php 								; save last action flag
.86e3	b1 30		lda ($30),y			lda 	(codePtr),y
.86e5	c9 80		cmp #$80			cmp  	#KWC_EOL 					; end of line or colon, exit now.
.86e7	f0 54		beq $873d			beq 	_CPExit
.86e9	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.86eb	f0 50		beq $873d			beq 	_CPExit
.86ed	68		pla				pla 								; throw last action flag
.86ee	b1 30		lda ($30),y			lda 	(codePtr),y
.86f0	c8		iny				iny
.86f1	c9 3b		cmp #$3b			cmp 	#KWD_SEMICOLON				; is it a semicolon
.86f3	f0 45		beq $873a			beq 	_CPContinueWithSameLine
.86f5	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; comma
.86f7	f0 3c		beq $8735			beq 	_CPTab
.86f9	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; apostrophe (new line)
.86fb	f0 34		beq $8731			beq 	_CPNewLine
.86fd	88		dey				dey 								; undo the get.
.86fe	20 06 94	jsr $9406			jsr 	EvaluateExpressionAt0 		; evaluate expression at 0.
.8701	b5 50		lda $50,x			lda 	NSStatus,x 					; read the status
.8703	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.8705	f0 0d		beq $8714			beq 	_CPIsValue 					; no, display it.
.8707	ad 28 04	lda $0428			lda 	IsInputFlag 				; if print, dereference and print.
.870a	f0 05		beq $8711			beq 	_CPIsPrint 					; otherwise display.
.870c	20 46 87	jsr $8746			jsr 	CIInputValue 				; input a value to the reference
.870f	80 20		bra $8731			bra 	_CPNewLine
.8711					_CPIsPrint:
.8711	20 cb 96	jsr $96cb			jsr 	Dereference 				; dereference if required.
.8714					_CPIsValue:
.8714	b5 50		lda $50,x			lda 	NSStatus,x 					; is it a number
.8716	29 10		and #$10			and 	#NSBIsString
.8718	f0 09		beq $8723			beq 	_CPNumber
.871a	a6 60		ldx $60				ldx 	NSMantissa1 				; string, print the text.
.871c	a5 58		lda $58				lda 	NSMantissa0
.871e	20 a9 87	jsr $87a9			jsr 	CPPrintStringXA
.8721	80 be		bra $86e1			bra 	Command_IP_Main 			; loop round clearing carry so NL if end
.8723					_CPNumber:
.8723	a9 05		lda #$05			lda 	#5 							; maximum decimals
.8725	20 5b 9c	jsr $9c5b			jsr 	ConvertNumberToString 		; convert to string (in unary str$() function)
.8728	a2 06		ldx #$06			ldx 	#DecimalBuffer >> 8
.872a	a9 49		lda #$49			lda 	#DecimalBuffer & $FF
.872c	20 a9 87	jsr $87a9			jsr 	CPPrintStringXA 			; print it.
.872f	80 b0		bra $86e1			bra 	Command_IP_Main				; loop round clearing carry so NL if end
.8731					_CPNewLine:
.8731	a9 0d		lda #$0d			lda 	#13
.8733	80 02		bra $8737			bra 	_CPPrintChar
.8735					_CPTab:
.8735	a9 09		lda #$09			lda 	#9 							; print TAB
.8737					_CPPrintChar:
.8737	20 bc 87	jsr $87bc			jsr 	CPPrintVector
.873a					_CPContinueWithSameLine:
.873a	38		sec				sec 								; loop round with carry set, which
.873b	80 a5		bra $86e2			bra 	_CPLoop 					; will inhibit final CR
.873d					_CPExit:
.873d	28		plp				plp 								; get last action flag
.873e	b0 05		bcs $8745			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.8740	a9 0d		lda #$0d			lda 	#13 						; print new line
.8742	20 bc 87	jsr $87bc			jsr 	CPPrintVector
.8745					_CPExit2:
.8745	60		rts				rts
.8746					CIInputValue:
.8746	a2 00		ldx #$00			ldx 	#0 							; input a line.
.8748					_CIInputLine:
.8748	20 bf 87	jsr $87bf			jsr 	CPInputVector 				; get key
.874b	c9 0d		cmp #$0d			cmp 	#13 						; 13 = End
.874d	f0 1f		beq $876e			beq 	_CIHaveValue
.874f	c9 08		cmp #$08			cmp 	#8 							; 8 = BS
.8751	f0 11		beq $8764			beq 	_CIBackspace
.8753	c9 20		cmp #$20			cmp 	#32 						; ignore other control characters
.8755	90 f1		bcc $8748			bcc 	_CIInputLine
.8757	e0 50		cpx #$50			cpx 	#80 						; max length
.8759	b0 ed		bcs $8748			bcs 	_CIInputLine
.875b	9d 2a 05	sta $052a,x			sta 	lineBuffer,x
.875e	e8		inx				inx
.875f	20 bc 87	jsr $87bc			jsr 	CPPrintVector 				; echo it.
.8762	80 e4		bra $8748			bra 	_CIInputLine
.8764					_CIBackSpace:
.8764	e0 00		cpx #$00			cpx 	#0 							; nothing to delete
.8766	f0 e0		beq $8748			beq 	_CIInputLine
.8768	20 bc 87	jsr $87bc			jsr 	CPPrintVector 				; echo it.
.876b	ca		dex				dex
.876c	80 da		bra $8748			bra 	_CIInputLine
.876e					_CIHaveValue:
.876e	9e 2a 05	stz $052a,x			stz 	LineBuffer,x 				; ASCIIZ string now in line buffer.
.8771	a5 50		lda $50				lda 	NSStatus 					; was it a string assignment
.8773	29 10		and #$10			and 	#NSBIsString
.8775	f0 17		beq $878e			beq 	_CIAssignNumber 			; assign a number
.8777	a2 01		ldx #$01			ldx 	#1
.8779	a9 2a		lda #$2a			lda 	#lineBuffer & $FF 			; set up to point to new string
.877b	95 58		sta $58,x			sta 	NSMantissa0,x
.877d	a9 05		lda #$05			lda 	#lineBuffer >> 8
.877f	95 60		sta $60,x			sta 	NSMantissa1,x
.8781	74 68		stz $68,x			stz 	NSMantissa2,x
.8783	74 70		stz $70,x			stz 	NSMantissa3,x
.8785	a9 10		lda #$10			lda 	#NSBIsString 				; so it becomes a string value
.8787	95 50		sta $50,x			sta  	NSStatus,x
.8789	ca		dex				dex 								; X = 0
.878a	20 fb 87	jsr $87fb			jsr 	AssignVariable
.878d	60		rts				rts
.878e					_CIAssignNumber:
.878e	a9 2a		lda #$2a			lda 	#lineBuffer & $FF 			; set up to point to new string
.8790	85 36		sta $36				sta 	zTemp0
.8792	a9 05		lda #$05			lda 	#lineBuffer >> 8
.8794	85 37		sta $37				sta 	zTemp0+1
.8796	a2 01		ldx #$01			ldx 	#1 							; put in slot 1
.8798	20 dd 9b	jsr $9bdd			jsr 	ValEvaluateZTemp0 			; use the VAL() code
.879b	90 07		bcc $87a4			bcc 	_CIIsOkay
.879d	a9 3f		lda #$3f			lda 	#"?" 						; error ?
.879f	20 bc 87	jsr $87bc			jsr 	CPPrintVector
.87a2	80 a2		bra $8746			bra 	CIInputValue
.87a4					_CIIsOkay:
.87a4	ca		dex				dex 								; X = 0
.87a5	20 fb 87	jsr $87fb			jsr 	AssignVariable
.87a8	60		rts				rts
.87a9					CPPrintStringXA:
.87a9	5a		phy				phy
.87aa	86 37		stx $37				stx 	zTemp0+1
.87ac	85 36		sta $36				sta 	zTemp0
.87ae	a0 00		ldy #$00			ldy 	#0
.87b0					_PSXALoop:
.87b0	b1 36		lda ($36),y			lda 	(zTemp0),y
.87b2	f0 06		beq $87ba			beq 	_PSXAExit
.87b4	20 bc 87	jsr $87bc			jsr 	CPPrintVector
.87b7	c8		iny				iny
.87b8	80 f6		bra $87b0			bra 	_PSXALoop
.87ba					_PSXAExit:
.87ba	7a		ply				ply
.87bb	60		rts				rts
.87bc					CPPrintVector:
.87bc	4c 03 80	jmp $8003			jmp 	EXTPrintCharacter
.87bf					CPInputVector:
.87bf	4c 09 80	jmp $8009			jmp 	EXTInputSingleCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/let.asm

.87c2					LetCommand:
.87c2	a2 00		ldx #$00			ldx 	#0
.87c4	b1 30		lda ($30),y			lda 	(codePtr),y
.87c6	c9 10		cmp #$10			cmp 	#KWD_AT
.87c8	d0 14		bne $87de			bne 	_LCStandard
.87ca	c8		iny				iny 								; skip equal
.87cb	20 52 98	jsr $9852			jsr 	EvaluateTerm 				; get a number (the address of the reference)
.87ce	20 cb 96	jsr $96cb			jsr 	Dereference 				; dereference it to a value
.87d1	b5 50		lda $50,x			lda 	NSStatus,x 					; check integer
.87d3	49 20		eor #$20			eor 	#NSBIsReference	 			; toggle reference
.87d5	95 50		sta $50,x			sta 	NSStatus,x
.87d7	29 20		and #$20			and 	#NSBIsReference 			; if it is now a reference, continue
.87d9	d0 0f		bne $87ea			bne 	_LCMain
.87db	4c ae 9f	jmp $9fae			jmp 	TypeError 					; was a reference before.
.87de					_LCStandard:
.87de	ad f0 93	lda $93f0			lda 	PrecedenceLevel+"*"			; precedence > this
.87e1	20 0a 94	jsr $940a			jsr 	EvaluateExpressionAtPrecedence
.87e4	b5 50		lda $50,x			lda 	NSStatus,x 					; is it a reference to an array marked as procedure ?
.87e6	c9 38		cmp #$38			cmp		#NSTProcedure+NSBIsReference
.87e8	f0 0e		beq $87f8			beq 	_LetGoProc 					; it's a procedure call.
.87ea					_LCMain:
.87ea	a9 3d		lda #$3d			lda 	#"=" 						; check =
.87ec	20 fb 8e	jsr $8efb			jsr 	CheckNextA
.87ef	e8		inx				inx 								; RHS
.87f0	20 6b 9d	jsr $9d6b			jsr 	EvaluateValue
.87f3	ca		dex				dex
.87f4	20 fb 87	jsr $87fb			jsr 	AssignVariable
.87f7	60		rts				rts
.87f8					_LetGoProc:
.87f8	4c df 89	jmp $89df			jmp 	CallProcedure
.87fb					AssignVariable:
.87fb	b5 50		lda $50,x			lda 	NSStatus,x 					; check the string/number type bits match
.87fd	48		pha				pha 								; save a copy
.87fe	55 51		eor $51,x			eor 	NSStatus+1,x
.8800	29 10		and #$10			and 	#NSBIsString
.8802	d0 0b		bne $880f			bne 	_ASError
.8804	68		pla				pla 								; get back
.8805	29 10		and #$10			and 	#NSBIsString 				; check type
.8807	d0 03		bne $880c			bne 	_ASString
.8809	4c 09 96	jmp $9609			jmp 	AssignNumber
.880c					_ASString:
.880c	4c 67 96	jmp $9667			jmp 	AssignString
.880f					_ASError:
.880f	4c ae 9f	jmp $9fae			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/list.asm

.8812					Command_List:
.8812	9c 26 04	stz $0426			stz 	listIndent 					; reset indent.
.8815	b1 30		lda ($30),y			lda 	(codePtr),y
.8817	29 c0		and #$c0			and 	#$C0 				 		; if so, we are list procedure() which is a seperate block
.8819	c9 40		cmp #$40			cmp 	#$40  						; of code.
.881b	f0 69		beq $8886			beq 	_CLListProcedure
.881d	64 5c		stz $5c				stz		NSMantissa0+4				; set the lower (slot 4) to 0 and upper (slot 7) to $FFFF
.881f	64 64		stz $64				stz 	NSMantissa1+4 				; these are the default top and bottom.
.8821	a9 ff		lda #$ff			lda 	#$FF
.8823	85 5f		sta $5f				sta 	NSMantissa0+7
.8825	85 67		sta $67				sta 	NSMantissa1+7
.8827	b1 30		lda ($30),y			lda 	(codePtr),y
.8829	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.882b	f0 1a		beq $8847			beq 	_CLSecond
.882d	20 03 89	jsr $8903			jsr 	CLIsDigit 					; if not digit, list all
.8830	b0 20		bcs $8852			bcs 	_CLStart
.8832	a2 04		ldx #$04			ldx 	#4 							; get 1st range into slot 4
.8834	20 a6 9d	jsr $9da6			jsr 	Evaluate16BitInteger
.8837	b1 30		lda ($30),y			lda 	(codePtr),y
.8839	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.883b	f0 0a		beq $8847			beq 	_CLSecond 					; if so go get it
.883d	a5 5c		lda $5c				lda 	NSMantissa0+4 				; copy 4->7
.883f	85 5f		sta $5f				sta 	NSMantissa0+7
.8841	a5 64		lda $64				lda 	NSMantissa1+4
.8843	85 67		sta $67				sta 	NSMantissa1+7
.8845	80 0b		bra $8852			bra 	_CLStart
.8847					_CLSecond:
.8847	c8		iny				iny 								; consume comma
.8848	20 03 89	jsr $8903			jsr 	CLIsDigit 					; digit found
.884b	b0 05		bcs $8852			bcs 	_CLStart 					; if not, continue listing
.884d	a2 07		ldx #$07			ldx 	#7 							; load 2nd range into slot 7
.884f	20 a6 9d	jsr $9da6			jsr 	Evaluate16BitInteger
.8852					_CLStart
.8852	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8854	85 30		sta $30				sta 	codePtr
.8856	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8858	85 31		sta $31				sta 	codePtr+1
.885a					_CLLoop:
.885a	20 0c 80	jsr $800c			jsr 	EXTBreakCheck 				; break check here, as we want the option of breaking out of long lists.
.885d	f0 24		beq $8883			beq 	_CLExit
.885f	b2 30		lda ($30)			lda 	(codePtr)
.8861	f0 20		beq $8883			beq 	_CLExit
.8863	a2 04		ldx #$04			ldx 	#4 							; check range every time, line numbers aren't in order.
.8865	20 f2 88	jsr $88f2			jsr 	CLCompareLineNo
.8868	90 0c		bcc $8876			bcc 	_CLNext
.886a	a2 07		ldx #$07			ldx 	#7
.886c	20 f2 88	jsr $88f2			jsr 	CLCompareLineNo
.886f	f0 02		beq $8873			beq 	_CLDoThisOne
.8871	b0 03		bcs $8876			bcs 	_CLNext
.8873					_CLDoThisOne:
.8873	20 df 88	jsr $88df			jsr 	CLListOneLine 				; routine to list the current line.
.8876					_CLNext:
.8876	18		clc				clc
.8877	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8879	65 30		adc $30				adc 	codePtr
.887b	85 30		sta $30				sta 	codePtr
.887d	90 02		bcc $8881			bcc 	_CREExit
.887f	e6 31		inc $31				inc 	codePtr+1 					; carry
.8881					_CREExit:
.8881	80 d7		bra $885a			bra 	_CLLoop
.8883					_CLExit:
.8883	4c 83 83	jmp $8383			jmp 	WarmStart
.8886					_CLListProcedure:
.8886	b1 30		lda ($30),y			lda 	(codePtr),y
.8888	85 38		sta $38				sta 	zTemp1
.888a	c8		iny				iny
.888b	b1 30		lda ($30),y			lda 	(codePtr),y
.888d	85 39		sta $39				sta 	zTemp1+1
.888f	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8891	85 30		sta $30				sta 	codePtr
.8893	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8895	85 31		sta $31				sta 	codePtr+1
.8897					_CLLPSearch:
.8897	b2 30		lda ($30)			lda 	(codePtr)
.8899	c9 00		cmp #$00			cmp 	#0 							; if zero, end
.889b	f0 e6		beq $8883			beq 	_CLExit
.889d	a0 03		ldy #$03			ldy 	#3 							; check if PROC something
.889f	b1 30		lda ($30),y			lda 	(codePtr),y
.88a1	c9 a4		cmp #$a4			cmp 	#KWD_PROC
.88a3	d0 0e		bne $88b3			bne 	_CLLPNext
.88a5	c8		iny				iny 								; check if PROC this.
.88a6	b1 30		lda ($30),y			lda 	(codePtr),y
.88a8	c5 38		cmp $38				cmp 	zTemp1 						; does it match ?
.88aa	d0 07		bne $88b3			bne 	_CLLPNext
.88ac	c8		iny				iny
.88ad	b1 30		lda ($30),y			lda 	(codePtr),y
.88af	c5 39		cmp $39				cmp 	zTemp1+1
.88b1	f0 0d		beq $88c0			beq 	_CLLPFound
.88b3					_CLLPNext:
.88b3	18		clc				clc
.88b4	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.88b6	65 30		adc $30				adc 	codePtr
.88b8	85 30		sta $30				sta 	codePtr
.88ba	90 02		bcc $88be			bcc 	_CREExit
.88bc	e6 31		inc $31				inc 	codePtr+1 					; carry
.88be					_CREExit:
.88be	80 d7		bra $8897			bra 	_CLLPSearch
.88c0					_CLLPFound:
.88c0	b2 30		lda ($30)			lda 	(codePtr)
.88c2	f0 bf		beq $8883			beq 	_CLExit
.88c4	a0 03		ldy #$03			ldy 	#3 							; get first keyword
.88c6	b1 30		lda ($30),y			lda 	(codePtr),y
.88c8	48		pha				pha
.88c9	20 df 88	jsr $88df			jsr 	CLListOneLine 				; list line and go forward
.88cc	18		clc				clc
.88cd	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.88cf	65 30		adc $30				adc 	codePtr
.88d1	85 30		sta $30				sta 	codePtr
.88d3	90 02		bcc $88d7			bcc 	_CREExit
.88d5	e6 31		inc $31				inc 	codePtr+1 					; carry
.88d7					_CREExit:
.88d7	68		pla				pla 								; reached ENDPROC ?
.88d8	c9 a8		cmp #$a8			cmp 	#KWD_ENDPROC
.88da	d0 e4		bne $88c0			bne 	_CLLPFound
.88dc	4c 83 83	jmp $8383			jmp 	WarmStart
.88df					CLListOneLine:
.88df	20 46 8e	jsr $8e46			jsr 	ScanGetCurrentLineStep 		; get indent adjust.
.88e2	20 1e 80	jsr $801e			jsr 	TKListConvertLine 			; convert line into token Buffer
.88e5	a2 04		ldx #$04			ldx 	#(tokenBuffer >> 8) 		; print that line
.88e7	a9 2d		lda #$2d			lda 	#(tokenBuffer & $FF)
.88e9	20 5d 8f	jsr $8f5d			jsr 	PrintStringXA
.88ec	a9 0d		lda #$0d			lda 	#13 						; new line
.88ee	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.88f1	60		rts				rts
.88f2					CLCompareLineNo:
.88f2	38		sec				sec
.88f3	a0 01		ldy #$01			ldy 	#1
.88f5	b1 30		lda ($30),y			lda 	(codePtr),y
.88f7	f5 58		sbc $58,x			sbc 	NSMantissa0,x
.88f9	85 36		sta $36				sta 	zTemp0
.88fb	c8		iny				iny
.88fc	b1 30		lda ($30),y			lda 	(codePtr),y
.88fe	f5 60		sbc $60,x			sbc 	NSMantissa1,x
.8900	05 36		ora $36				ora 	zTemp0
.8902	60		rts				rts
.8903					CLIsDigit:
.8903	b1 30		lda ($30),y			lda 	(codePtr),y
.8905	c9 30		cmp #$30			cmp 	#"0"
.8907	90 03		bcc $890c			bcc	 	_CLIDExitFalse
.8909	c9 3a		cmp #$3a			cmp 	#"9"+1
.890b	60		rts				rts
.890c					_CLIDExitFalse:
.890c	38		sec				sec
.890d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/local.asm

.890e					Command_LOCAL:
.890e	a2 00		ldx #$00			ldx 	#0 							; at level 0
.8910	20 1c 89	jsr $891c			jsr 	LocaliseNextTerm 			; convert term to a local.
.8913	b1 30		lda ($30),y			lda 	(codePtr),y
.8915	c8		iny				iny
.8916	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8918	f0 f4		beq $890e			beq 	Command_LOCAL 				; if so, localise another variable.
.891a	88		dey				dey 								; unpick pre-get
.891b	60		rts				rts
.891c					LocaliseNextTerm:
.891c	20 52 98	jsr $9852			jsr 	EvaluateTerm 				; evaluate the term
.891f	b5 50		lda $50,x			lda 	NSStatus,x
.8921	29 20		and #$20			and 	#NSBIsReference 			; check it is a reference, must be a variable.
.8923	f0 5c		beq $8981			beq		_LNTError
.8925	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address of variable to zTemp0
.8927	85 36		sta $36				sta 	zTemp0
.8929	b5 60		lda $60,x			lda 	NSMantissa1,x
.892b	85 37		sta $37				sta  	zTemp0+1
.892d	b5 50		lda $50,x			lda 	NSStatus,x 					; figure out what it is.
.892f	29 10		and #$10			and 	#NSBIsString
.8931	d0 1e		bne $8951			bne 	_LNTPushString
.8933	5a		phy				phy
.8934	a0 00		ldy #$00			ldy 	#0 							; push 0 to 4 inclusive, the number values, on the stack, and zero them as you go.
.8936					_LNTPushNumLoop:
.8936	b1 36		lda ($36),y			lda		(zTemp0),y
.8938	20 98 a6	jsr $a698			jsr 	StackPushByte
.893b	c8		iny				iny
.893c	c0 05		cpy #$05			cpy 	#5
.893e	d0 f6		bne $8936			bne 	_LNTPushNumLoop
.8940	a5 36		lda $36				lda 	zTemp0 						; push the actual target address to write on the stack
.8942	20 98 a6	jsr $a698			jsr 	StackPushByte
.8945	a5 37		lda $37				lda 	zTemp0+1
.8947	20 98 a6	jsr $a698			jsr 	StackPushByte
.894a	a9 01		lda #$01			lda 	#STK_LOCALN 				; push local-number marker.
.894c	20 98 a6	jsr $a698			jsr 	StackPushByte
.894f	7a		ply				ply
.8950	60		rts				rts
.8951					_LNTPushString:
.8951	5a		phy				phy
.8952	b2 36		lda ($36)			lda 	(zTemp0) 					; put address of string in zTemp1
.8954	85 38		sta $38				sta 	zTemp1
.8956	a0 01		ldy #$01			ldy 	#1
.8958	b1 36		lda ($36),y			lda 	(zTemp0),y
.895a	85 39		sta $39				sta 	zTemp1+1
.895c	a0 00		ldy #$00			ldy 	#0 							; output string
.895e	c9 00		cmp #$00			cmp 	#0 							; if not assigned string
.8960	f0 0a		beq $896c			beq 	_LNTStringOut
.8962					_LNTPushStrLoop:
.8962	b1 38		lda ($38),y			lda 	(zTemp1),y
.8964	f0 06		beq $896c			beq 	_LNTStringOut
.8966	20 98 a6	jsr $a698			jsr 	StackPushByte
.8969	c8		iny				iny
.896a	80 f6		bra $8962			bra 	_LNTPushStrLoop
.896c					_LNTStringOut:
.896c	98		tya				tya									; output length (chars written).
.896d	20 98 a6	jsr $a698			jsr 	StackPushByte
.8970	b5 58		lda $58,x			lda 	NSMantissa0,x 				; output address of the string record *not* the string itself
.8972	20 98 a6	jsr $a698			jsr 	StackPushByte
.8975	b5 60		lda $60,x			lda 	NSMantissa1,x
.8977	20 98 a6	jsr $a698			jsr 	StackPushByte
.897a	a9 02		lda #$02			lda 	#STK_LOCALS 				; push local-string marker.
.897c	20 98 a6	jsr $a698			jsr 	StackPushByte
.897f	7a		ply				ply
.8980	60		rts				rts
.8981					_LNTError:
.8981	4c a4 9f	jmp $9fa4			jmp 	SyntaxError
.8984					LocalPopValue:
.8984	20 b0 a6	jsr $a6b0			jsr 	StackPopByte
.8987	c9 01		cmp #$01			cmp 	#STK_LOCALN 				; if not local-N
.8989	d0 17		bne $89a2			bne 	_LPVString
.898b	20 b0 a6	jsr $a6b0			jsr 	StackPopByte 				; address
.898e	85 37		sta $37				sta 	zTemp0+1
.8990	20 b0 a6	jsr $a6b0			jsr 	StackPopByte
.8993	85 36		sta $36				sta 	zTemp0
.8995	5a		phy				phy
.8996	a0 04		ldy #$04			ldy 	#4 							; copy back
.8998					_LPVNumberCopy:
.8998	20 b0 a6	jsr $a6b0			jsr 	StackPopByte
.899b	91 36		sta ($36),y			sta 	(zTemp0),y
.899d	88		dey				dey
.899e	10 f8		bpl $8998			bpl 	_LPVNumberCopy
.89a0	7a		ply				ply 								; and complete
.89a1	60		rts				rts
.89a2					_LPVString:
.89a2	20 b0 a6	jsr $a6b0			jsr 	StackPopByte 				; address of record copied to zTemp0
.89a5	85 37		sta $37				sta 	zTemp0+1
.89a7	20 b0 a6	jsr $a6b0			jsr 	StackPopByte
.89aa	85 36		sta $36				sta 	zTemp0
.89ac	5a		phy				phy
.89ad	b2 36		lda ($36)			lda 	(zTemp0) 					; address to write string to copied to zTemp1
.89af	85 38		sta $38				sta 	zTemp1
.89b1	a0 01		ldy #$01			ldy 	#1
.89b3	b1 36		lda ($36),y			lda 	(zTemp0),y
.89b5	85 39		sta $39				sta 	zTemp1+1
.89b7	20 b0 a6	jsr $a6b0			jsr 	StackPopByte 				; # chars to get => y
.89ba	a8		tay				tay
.89bb	a5 39		lda $39				lda 	zTemp1+1 					; if no target (e.g. was "" originally) exit
.89bd	f0 0e		beq $89cd			beq 	_LPVStringCopied
.89bf	a9 00		lda #$00			lda 	#0 							; NULL on end
.89c1	91 38		sta ($38),y			sta 	(zTemp1),y
.89c3					_LPVStringCopy:
.89c3	88		dey				dey
.89c4	30 07		bmi $89cd			bmi 	_LPVStringCopied
.89c6	20 b0 a6	jsr $a6b0			jsr 	StackPopByte
.89c9	91 38		sta ($38),y			sta 	(zTemp1),y
.89cb	80 f6		bra $89c3			bra 	_LPVStringCopy
.89cd					_LPVStringCopied:
.89cd	fa		plx				plx
.89ce	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/new.asm

.89cf					NewCommand:
.89cf	20 d5 89	jsr $89d5			jsr 	NewProgram 					; does the actual NEW.
.89d2	4c 83 83	jmp $8383			jmp 	WarmStart 					; and warm starts straight away.
.89d5					NewProgram:
.89d5	20 75 a5	jsr $a575			jsr 	MemoryNew
.89d8	9c 00 10	stz $1000			stz 	VariableSpace 				; erase all variables.
.89db	20 19 84	jsr $8419			jsr 	ClearCommand 				; clear everything.
.89de	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/procedure.asm

=2					ParameterStackPos = 2
.89df					CallProcedure:
.89df	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start storing parameters at 2.
.89e1	b1 30		lda ($30),y			lda 	(codePtr),y
.89e3	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.89e5	f0 0c		beq $89f3			beq 	_CPEndParam
.89e7					_CPParamLoop:
.89e7	20 6b 9d	jsr $9d6b			jsr 	EvaluateValue 				; get parameter onto stack
.89ea	e8		inx				inx 								; bump next stack
.89eb	b1 30		lda ($30),y			lda 	(codePtr),y
.89ed	c8		iny				iny
.89ee	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if comma, go back and try again.
.89f0	f0 f5		beq $89e7			beq 	_CPParamLoop
.89f2	88		dey				dey 								; unpick.
.89f3					_CPEndParam:
.89f3	8e 16 04	stx $0416			stx 	LastParameter 				; save the last parameters index.
.89f6	c8		iny				iny									; skip right bracket
.89f7	a9 b3		lda #$b3			lda 	#STK_PROC+3 				; allocate 6 bytes on the return stack.
.89f9	20 b9 a6	jsr $a6b9			jsr 	StackOpen
.89fc	20 fe a6	jsr $a6fe			jsr 	STKSaveCodePosition 		; save loop position
.89ff	a5 58		lda $58				lda 	NSMantissa0 				; copy variable (e.g. procedure) address to zTemp0
.8a01	85 36		sta $36				sta 	zTemp0 						; this is the DATA not the RECORD
.8a03	a5 60		lda $60				lda 	NSMantissa1
.8a05	85 37		sta $37				sta 	zTemp0+1
.8a07	a0 01		ldy #$01			ldy 	#1 							; copy code address back.
.8a09	b2 36		lda ($36)			lda 	(zTemp0)
.8a0b	85 30		sta $30				sta 	safePtr
.8a0d	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a0f	85 31		sta $31				sta 	safePtr+1
.8a11	c8		iny				iny
.8a12	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a14	85 32		sta $32				sta 	safePtr+2
.8a16	c8		iny				iny
.8a17	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a19	85 33		sta $33				sta 	safePtr+3
.8a1b	c8		iny				iny 								; get Y offset -> Y
.8a1c	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a1e	a8		tay				tay
.8a1f	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start position of parameters
.8a21	ec 16 04	cpx $0416			cpx	 	LastParameter 				; check zero parameters at the start
.8a24	f0 13		beq $8a39			beq 	_ParamExit 					; if so, exit.
.8a26					_ParamExtract:
.8a26	ca		dex				dex 								; put a local term on the level before
.8a27	20 1c 89	jsr $891c			jsr 	LocaliseNextTerm			; also pushes original param value to basic stack
.8a2a	20 fb 87	jsr $87fb			jsr 	AssignVariable 				; assign stacked value to the variable.
.8a2d	e8		inx				inx 								; advance to next parameter to do.
.8a2e	e8		inx				inx
.8a2f	ec 16 04	cpx $0416			cpx 	LastParameter 				; are we done ?
.8a32	f0 05		beq $8a39			beq 	_ParamExit
.8a34	20 f3 8e	jsr $8ef3			jsr 	CheckComma 					; comma seperating parameters
.8a37	80 ed		bra $8a26			bra 	_ParamExtract
.8a39					_ParamExit:
.8a39	20 eb 8e	jsr $8eeb			jsr 	CheckRightBracket 			; check )
.8a3c	60		rts				rts 								; and continue from here
.8a3d					Command_ENDPROC:
.8a3d	a9 b0		lda #$b0			lda 	#STK_PROC 					; check TOS is this
.8a3f	a2 14		ldx #$14			ldx 	#ERRID_PROC
.8a41	20 e6 a6	jsr $a6e6			jsr 	StackCheckFrame
.8a44	20 0f a7	jsr $a70f			jsr 	STKLoadCodePosition 		; restore code position
.8a47	20 d8 a6	jsr $a6d8			jsr 	StackClose
.8a4a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/read.asm

.8a4b					Command_Read:
.8a4b	a2 00		ldx #$00			ldx 	#0 							; evaluate the term which is the var/array element to assign
.8a4d	20 52 98	jsr $9852			jsr 	EvaluateTerm
.8a50	b5 50		lda $50,x			lda 	NSStatus,x
.8a52	29 20		and #$20			and 	#NSBIsReference				; get status byte on stack, identifies int, float, string.
.8a54	f0 4f		beq $8aa5			beq 	_CRSyntax 					; check reference (bit 0) fail if not a reference.
.8a56	20 ee 8a	jsr $8aee			jsr 	SwapDataCodePtrs 			; swap code and data
.8a59	ad 1c 04	lda $041c			lda 	inDataStatement 			; if in a data statement, we don't need to search
.8a5c	d0 25		bne $8a83			bne 	_CRContinueData  			; forward for the next one.
.8a5e	b2 30		lda ($30)			lda 	(codePtr)
.8a60	f0 1c		beq $8a7e			beq 	_CRNoData
.8a62					_CRKeepSearching:
.8a62	a9 b4		lda #$b4			lda 	#KWD_DATA 					; scan for instruction
.8a64	a2 80		ldx #$80			ldx 	#KWC_EOL
.8a66	20 e3 8d	jsr $8de3			jsr 	ScanForward
.8a69	c9 b4		cmp #$b4			cmp 	#KWD_DATA 					; found data ?
.8a6b	f0 16		beq $8a83			beq 	_CRHaveData 				; found it
.8a6d	18		clc				clc
.8a6e	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8a70	65 30		adc $30				adc 	codePtr
.8a72	85 30		sta $30				sta 	codePtr
.8a74	90 02		bcc $8a78			bcc 	_CREExit
.8a76	e6 31		inc $31				inc 	codePtr+1 					; carry
.8a78					_CREExit:
.8a78	a0 03		ldy #$03			ldy 	#3 							; start of line.
.8a7a	b2 30		lda ($30)			lda 	(codePtr)
.8a7c	d0 e4		bne $8a62			bne 	_CRKeepSearching
.8a7e					_CRNoData:
.8a7e	a9 0b		lda #$0b		lda	#11
.8a80	4c 04 8f	jmp $8f04		jmp	ErrorHandler
.8a83					_CRHaveData:
.8a83					_CRContinueData:
.8a83	a2 01		ldx #$01			ldx 	#1
.8a85	20 6b 9d	jsr $9d6b			jsr 	EvaluateValue 				; evaluate value into slot # 1
.8a88	ca		dex				dex
.8a89	20 fb 87	jsr $87fb			jsr		AssignVariable 				; do the assignment
.8a8c	9c 1c 04	stz $041c			stz 	inDataStatement 			; clear in data flag
.8a8f	b1 30		lda ($30),y			lda 	(codePtr),y
.8a91	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not, end of data statement and exit
.8a93	d0 04		bne $8a99			bne 	_CRSwapBack
.8a95	c8		iny				iny 								; consume comma
.8a96	ee 1c 04	inc $041c			inc 	inDataStatement 			; set in data statement currently.
.8a99					_CRSwapBack:
.8a99	20 ee 8a	jsr $8aee			jsr 	SwapDataCodePtrs			; swap them back.
.8a9c	b1 30		lda ($30),y			lda 	(codePtr),y
.8a9e	c8		iny				iny
.8a9f	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8aa1	f0 a8		beq $8a4b			beq 	Command_Read 				; if so go round again.
.8aa3	88		dey				dey 								; unpick get.
.8aa4	60		rts				rts
.8aa5					_CRSyntax:
.8aa5	4c a4 9f	jmp $9fa4			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/rem.asm

.8aa8					RemCommand:
.8aa8	b1 30		lda ($30),y			lda 	(codePtr),y
.8aaa	c9 ff		cmp #$ff			cmp 	#KWC_STRING
.8aac	d0 06		bne $8ab4			bne 	_RMExit
.8aae	c8		iny				iny 								; point to offset
.8aaf	98		tya				tya 								; A = offset position
.8ab0	38		sec				sec 								; add size +1 hence SEC
.8ab1	71 30		adc ($30),y			adc 	(codePtr),y
.8ab3	a8		tay				tay 								; make current position.
.8ab4					_RMExit:
.8ab4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/repeat.asm

.8ab5					Command_REPEAT:
.8ab5	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; allocate 6 bytes on the return stack.
.8ab7	20 b9 a6	jsr $a6b9			jsr 	StackOpen
.8aba	20 fe a6	jsr $a6fe			jsr 	STKSaveCodePosition 		; save loop position
.8abd	60		rts				rts
.8abe					Command_UNTIL:
.8abe	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; check REPEAT is TOS
.8ac0	a2 0f		ldx #$0f			ldx 	#ERRID_REPEAT 				; this error
.8ac2	20 e6 a6	jsr $a6e6			jsr 	StackCheckFrame
.8ac5	a2 00		ldx #$00			ldx 	#0
.8ac7	20 74 9d	jsr $9d74			jsr 	EvaluateNumber 				; work out the number
.8aca	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; check if zero
.8acd	f0 04		beq $8ad3			beq 	_CULoopBack 				; if so keep looping
.8acf	20 d8 a6	jsr $a6d8			jsr 	StackClose		 			; return
.8ad2	60		rts				rts
.8ad3					_CULoopBack:
.8ad3	20 0f a7	jsr $a70f			jsr 	STKLoadCodePosition 		; loop back
.8ad6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/restore.asm

.8ad7					Command_Restore:
.8ad7	20 ee 8a	jsr $8aee			jsr 	SwapDataCodePtrs 			; swap code and data
.8ada	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8adc	85 30		sta $30				sta 	codePtr
.8ade	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8ae0	85 31		sta $31				sta 	codePtr+1
.8ae2	20 ee 8a	jsr $8aee			jsr 	SwapDataCodePtrs 			; put them back
.8ae5	a9 03		lda #$03			lda 	#3 							; start at offset 3, e.g. first instruction of first line.
.8ae7	8d 1b 04	sta $041b			sta 	dataPointer+4   			; (read checks not EOF)
.8aea	9c 1c 04	stz $041c			stz 	inDataStatement 			; not in data statement
.8aed	60		rts				rts
.8aee					SwapDataCodePtrs:
.8aee	da		phx				phx
.8aef	a2 03		ldx #$03			ldx 	#3 							; swap 32 bit code pointer over
.8af1					_SDCPLoop:
.8af1	b5 30		lda $30,x			lda 	safePtr,x
.8af3	48		pha				pha
.8af4	bd 17 04	lda $0417,x			lda 	dataPointer,x
.8af7	95 30		sta $30,x			sta 	safePtr,x
.8af9	68		pla				pla
.8afa	9d 17 04	sta $0417,x			sta 	dataPointer,x
.8afd	ca		dex				dex
.8afe	10 f1		bpl $8af1			bpl 	_SDCPLoop
.8b00	ad 1b 04	lda $041b			lda 	dataPointer+4 				; swap Y position over.
.8b03	8c 1b 04	sty $041b			sty 	dataPointer+4
.8b06	a8		tay				tay
.8b07	fa		plx				plx
.8b08	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/run.asm

.8b09					EOLCommand:
.8b09	18		clc				clc
.8b0a	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8b0c	65 30		adc $30				adc 	codePtr
.8b0e	85 30		sta $30				sta 	codePtr
.8b10	90 02		bcc $8b14			bcc 	_CREExit
.8b12	e6 31		inc $31				inc 	codePtr+1 					; carry
.8b14					_CREExit:
.8b14	80 0b		bra $8b21			bra 	RunNewLine
.8b16					CommandRUN:
.8b16	20 19 84	jsr $8419			jsr 	ClearCommand 				; clear variable/stacks/etc.
.8b19	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8b1b	85 30		sta $30				sta 	codePtr
.8b1d	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8b1f	85 31		sta $31				sta 	codePtr+1
.8b21					RUNNewLine:
.8b21	b2 30		lda ($30)			lda 	(codePtr)
.8b23	f0 7b		beq $8ba0			beq 	CRNoProgram         		; no then END.
.8b25	a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack
.8b27	9a		txs				txs
.8b28					RUNCodePointerLine:
.8b28	a0 02		ldy #$02			ldy 	#2 							; start of program
.8b2a					_CRIncMainLoop:
.8b2a	0e 13 04	asl $0413			asl 	breakCheck 					; clears 1 time in 8
.8b2d	d0 22		bne $8b51			bne 	_CRNoBreakCheck
.8b2f	ce 13 04	dec $0413			dec	 	breakCheck 					; set it back to $FF
.8b32	20 0c 80	jsr $800c			jsr 	EXTBreakCheck 				; break check
.8b35	f0 64		beq $8b9b			beq 	_CRBreak
.8b37	a5 01		lda $01				lda 	1 							; save I/O 0
.8b39	48		pha				pha
.8b3a	64 01		stz $01				stz 	1 							; access I/O Page 0
.8b3c	38		sec				sec 								; calculate timer - LastTick
.8b3d	ad 59 d6	lda $d659			lda 	$D659
.8b40	aa		tax				tax 								; saving timer in X
.8b41	ed 5b 06	sbc $065b			sbc 	LastTick
.8b44	c9 03		cmp #$03			cmp 	#3
.8b46	90 06		bcc $8b4e			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.8b48	8e 5b 06	stx $065b			stx 	LastTick 					; update last timer
.8b4b	20 51 9e	jsr $9e51			jsr 	TickHandler 							; go do the code.
.8b4e					_NoFireTick:
.8b4e	68		pla				pla 								; restore I/O 0
.8b4f	85 01		sta $01				sta 	1
.8b51					_CRNoBreakCheck:
.8b51	c8		iny				iny									; next token
.8b52					_CRMainLoop:
.8b52	9c 10 04	stz $0410			stz 	stringInitialised 			; clear the temporary string initialised flag.
.8b55	b1 30		lda ($30),y			lda 	(codePtr),y
.8b57	10 10		bpl $8b69			bpl 	_CRNotKeyword				; not a token.
.8b59	c9 a2		cmp #$a2			cmp 	#KWC_LAST_UNARY+1 			; if after unary, legitimate command
.8b5b	b0 04		bcs $8b61			bcs 	_CRIsKeyword
.8b5d	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if unary, syntax error.
.8b5f	b0 34		bcs $8b95			bcs		_CRSyntaxError
.8b61					_CRIsKeyword:
.8b61	c8		iny				iny 								; consume command
.8b62	0a		asl a				asl 	a 							; double losing the MSB which is '1' as tokens are $80-$FF
.8b63	aa		tax				tax 								; put in X for vector jump
.8b64	20 98 8b	jsr $8b98			jsr 	_CRCallVector0 				; call the vector - effectively jsr (vectortable,X)
.8b67	80 e9		bra $8b52			bra 	_CRMainLoop 				; and loop round
.8b69					_CRNotKeyword:
.8b69	c9 3a		cmp #$3a			cmp 	#KWD_COLON 					; if a :, consume it and go round.
.8b6b	f0 bd		beq $8b2a			beq 	_CRIncMainLoop
.8b6d	c9 40		cmp #$40			cmp 	#$40 						; variable/call reference
.8b6f	90 05		bcc $8b76			bcc 	_CRNotVariable
.8b71					_CRGoLet:
.8b71	20 c2 87	jsr $87c2			jsr 	LetCommand
.8b74	80 dc		bra $8b52			bra 	_CRMainLoop
.8b76					_CRNotVariable:
.8b76	c9 10		cmp #$10			cmp 	#KWD_AT 					; handle @
.8b78	f0 f7		beq $8b71			beq 	_CRGoLet
.8b7a	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; handle ? !
.8b7c	f0 f3		beq $8b71			beq 	_CRGoLet
.8b7e	c9 21		cmp #$21			cmp 	#KWD_PLING
.8b80	f0 ef		beq $8b71			beq 	_CRGoLet
.8b82	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; handle ' (comment)
.8b84	f0 09		beq $8b8f			beq 	_CRGoRem
.8b86	c9 2e		cmp #$2e			cmp 	#KWD_PERIOD 				; handle . (assembler label)
.8b88	d0 0b		bne $8b95			bne 	_CRSyntaxError
.8b8a	20 12 82	jsr $8212			jsr 	LabelHere
.8b8d	80 c3		bra $8b52			bra 	_CRMainLoop
.8b8f					_CRGoRem:
.8b8f	c8		iny				iny
.8b90	20 a8 8a	jsr $8aa8			jsr 	RemCommand
.8b93	80 bd		bra $8b52			bra 	_CRMainLoop
.8b95					_CRSyntaxError:
.8b95	4c a4 9f	jmp $9fa4			jmp 	SyntaxError
.8b98					_CRCallVector0:
.8b98	7c 36 8c	jmp ($8c36,x)			jmp 	(VectorSet0,x)
.8b9b					_CRBreak:
.8b9b	a9 01		lda #$01		lda	#1
.8b9d	4c 04 8f	jmp $8f04		jmp	ErrorHandler
.8ba0					CRNoProgram:
.8ba0	4c 67 85	jmp $8567			jmp 	EndCommand
.8ba3					Shift1Command:
.8ba3	b1 30		lda ($30),y			lda 	(codePtr),y
.8ba5	c8		iny				iny
.8ba6	0a		asl a				asl 	a
.8ba7	aa		tax				tax
.8ba8	7c dc 8c	jmp ($8cdc,x)			jmp 	(VectorSet1,x)
.8bab					Shift2Command:
.8bab	b1 30		lda ($30),y			lda 	(codePtr),y
.8bad	c8		iny				iny
.8bae	0a		asl a				asl 	a
.8baf	aa		tax				tax
.8bb0	7c 04 8d	jmp ($8d04,x)			jmp 	(VectorSet2,x)
.8bb3					Unused1:
.8bb3					Unused2:
.8bb3					Unused3:
.8bb3					Unused4:
.8bb3	4c a4 9f	jmp $9fa4			jmp 	SyntaxError
>8bb6							.align 2

;******  Processing file: ./common/commands/../generated/vectors.dat

.8bb6					VectorSetPunc:
>8bb6	bc 91					.word	ShiftLeft                        ; $00 <<
>8bb8	a7 8f					.word	BinaryCompareLessEqual           ; $01 <=
>8bba	9d 8f					.word	BinaryCompareNotEqual            ; $02 <>
>8bbc	a4 9f					.word	SyntaxError                      ; $03 !!3
>8bbe	a4 9f					.word	SyntaxError                      ; $04 ><
>8bc0	b1 8f					.word	BinaryCompareGreaterEqual        ; $05 >=
>8bc2	bf 91					.word	ShiftRight                       ; $06 >>
>8bc4	a4 9f					.word	SyntaxError                      ; $07 !!7
>8bc6	a4 9f					.word	SyntaxError                      ; $08 !!8
>8bc8	a4 9f					.word	SyntaxError                      ; $09 !!9
>8bca	a4 9f					.word	SyntaxError                      ; $0a !!10
>8bcc	a4 9f					.word	SyntaxError                      ; $0b !!11
>8bce	a4 9f					.word	SyntaxError                      ; $0c !!12
>8bd0	a4 9f					.word	SyntaxError                      ; $0d !!13
>8bd2	a4 9f					.word	SyntaxError                      ; $0e !!14
>8bd4	a4 9f					.word	SyntaxError                      ; $0f !!15
>8bd6	a4 9f					.word	SyntaxError                      ; $10 @
>8bd8	a4 9f					.word	SyntaxError                      ; $11 !!17
>8bda	a4 9f					.word	SyntaxError                      ; $12 !!18
>8bdc	a4 9f					.word	SyntaxError                      ; $13 [
>8bde	68 90					.word	IntegerDivide                    ; $14 \
>8be0	a4 9f					.word	SyntaxError                      ; $15 ]
>8be2	fa 92					.word	EorInteger                       ; $16 ^
>8be4	a4 9f					.word	SyntaxError                      ; $17 _
>8be6	a4 9f					.word	SyntaxError                      ; $18 `
>8be8	a4 9f					.word	SyntaxError                      ; $19 !!25
>8bea	a4 9f					.word	SyntaxError                      ; $1a !!26
>8bec	a4 9f					.word	SyntaxError                      ; $1b {
>8bee	c5 92					.word	OraInteger                       ; $1c |
>8bf0	a4 9f					.word	SyntaxError                      ; $1d }
>8bf2	a4 9f					.word	SyntaxError                      ; $1e ~
>8bf4	a4 9f					.word	SyntaxError                      ; $1f [7m<7F>[m
>8bf6	a4 9f					.word	SyntaxError                      ; $20
>8bf8	2f 93					.word	WordIndirect                     ; $21 !
>8bfa	a4 9f					.word	SyntaxError                      ; $22 "
>8bfc	a4 9f					.word	SyntaxError                      ; $23 #
>8bfe	a4 9f					.word	SyntaxError                      ; $24 $
>8c00	a9 90					.word	IntegerModulus                   ; $25 %
>8c02	90 92					.word	AndInteger                       ; $26 &
>8c04	a4 9f					.word	SyntaxError                      ; $27 '
>8c06	a4 9f					.word	SyntaxError                      ; $28 (
>8c08	a4 9f					.word	SyntaxError                      ; $29 )
>8c0a	17 91					.word	MulInteger                       ; $2a *
>8c0c	32 92					.word	AddInteger                       ; $2b +
>8c0e	a4 9f					.word	SyntaxError                      ; $2c ,
>8c10	6b 92					.word	SubInteger                       ; $2d -
>8c12	a4 9f					.word	SyntaxError                      ; $2e .
>8c14	e9 94					.word	FDivideCommand                   ; $2f /
>8c16	a4 9f					.word	SyntaxError                      ; $30 0
>8c18	a4 9f					.word	SyntaxError                      ; $31 1
>8c1a	a4 9f					.word	SyntaxError                      ; $32 2
>8c1c	a4 9f					.word	SyntaxError                      ; $33 3
>8c1e	a4 9f					.word	SyntaxError                      ; $34 4
>8c20	a4 9f					.word	SyntaxError                      ; $35 5
>8c22	a4 9f					.word	SyntaxError                      ; $36 6
>8c24	a4 9f					.word	SyntaxError                      ; $37 7
>8c26	a4 9f					.word	SyntaxError                      ; $38 8
>8c28	a4 9f					.word	SyntaxError                      ; $39 9
>8c2a	a4 9f					.word	SyntaxError                      ; $3a :
>8c2c	a4 9f					.word	SyntaxError                      ; $3b ;
>8c2e	89 8f					.word	BinaryCompareLess                ; $3c <
>8c30	7f 8f					.word	BinaryCompareEqual               ; $3d =
>8c32	93 8f					.word	BinaryCompareGreater             ; $3e >
>8c34	51 93					.word	ByteIndirect                     ; $3f ?
.8c36					VectorSet0:
>8c36	09 8b					.word	EOLCommand                       ; $80 !0:EOF
>8c38	a3 8b					.word	Shift1Command                    ; $81 !1:SH1
>8c3a	ab 8b					.word	Shift2Command                    ; $82 !2:SH2
>8c3c	ce 99					.word	AbsUnary                         ; $83 ABS(
>8c3e	dc 99					.word	AllocUnary                       ; $84 ALLOC(
>8c40	4c 9a					.word	AscUnary                         ; $85 ASC(
>8c42	0c 9c					.word	ChrUnary                         ; $86 CHR$(
>8c44	5c 9a					.word	DeekUnary                        ; $87 DEEK(
>8c46	f5 a3					.word	UnaryEvent                       ; $88 EVENT(
>8c48	7b 8f					.word	UnaryFalse                       ; $89 FALSE
>8c4a	6e 9a					.word	FracUnary                        ; $8a FRAC(
>8c4c	91 a3					.word	UnaryHit                         ; $8b HIT(
>8c4e	83 9a					.word	IntUnary                         ; $8c INT(
>8c50	cb 9b					.word	IsValUnary                       ; $8d ISVAL(
>8c52	79 a4					.word	UnaryJoyB                        ; $8e JOYB(
>8c54	52 a4					.word	UnaryJoyX                        ; $8f JOYX(
>8c56	55 a4					.word	UnaryJoyY                        ; $90 JOYY(
>8c58	df 9c					.word	Unary_Left                       ; $91 LEFT$(
>8c5a	94 9a					.word	LenUnary                         ; $92 LEN(
>8c5c	b2 9a					.word	Unary_Max                        ; $93 MAX(
>8c5e	01 9d					.word	Unary_Mid                        ; $94 MID$(
>8c60	ae 9a					.word	Unary_Min                        ; $95 MIN(
>8c62	fd 9a					.word	Unary_Not                        ; $96 NOT(
>8c64	59 9a					.word	PeekUnary                        ; $97 PEEK(
>8c66	16 a6					.word	UnaryPlaying                     ; $98 PLAYING(
>8c68	10 9b					.word	Unary_Random                     ; $99 RANDOM(
>8c6a	ec 9c					.word	Unary_Right                      ; $9a RIGHT$(
>8c6c	2d 9b					.word	Unary_Rnd                        ; $9b RND(
>8c6e	a3 9b					.word	SgnUnary                         ; $9c SGN(
>8c70	1e 9c					.word	SpcUnary                         ; $9d SPC(
>8c72	39 9c					.word	Unary_Str                        ; $9e STR$(
>8c74	9f a4					.word	UnaryTimer                       ; $9f TIMER(
>8c76	70 8f					.word	UnaryTrue                        ; $a0 TRUE
>8c78	c1 9b					.word	ValUnary                         ; $a1 VAL(
>8c7a	6a 85					.word	ForCommand                       ; $a2 FOR
>8c7c	ad 86					.word	IfCommand                        ; $a3 IF
>8c7e	b3 8b					.word	Unused1                          ; $a4 PROC
>8c80	b5 8a					.word	Command_REPEAT                   ; $a5 REPEAT
>8c82	59 8e					.word	Command_WHILE                    ; $a6 WHILE
>8c84	d6 86					.word	EndIf                            ; $a7 ENDIF
>8c86	3d 8a					.word	Command_ENDPROC                  ; $a8 ENDPROC
>8c88	1c 86					.word	NextCommand                      ; $a9 NEXT
>8c8a	b3 8b					.word	Unused4                          ; $aa THEN
>8c8c	be 8a					.word	Command_UNTIL                    ; $ab UNTIL
>8c8e	7a 8e					.word	Command_WEND                     ; $ac WEND
>8c90	a4 9f					.word	SyntaxError                      ; $ad BY
>8c92	e4 83					.word	CallCommand                      ; $ae CALL
>8c94	45 a1					.word	CircleCommand                    ; $af CIRCLE
>8c96	19 84					.word	ClearCommand                     ; $b0 CLEAR
>8c98	71 84					.word	ClearScreen                      ; $b1 CLS
>8c9a	a4 9f					.word	SyntaxError                      ; $b2 COLOR
>8c9c	a4 9f					.word	SyntaxError                      ; $b3 COLOUR
>8c9e	79 84					.word	Command_Data                     ; $b4 DATA
>8ca0	81 84					.word	DimCommand                       ; $b5 DIM
>8ca2	41 85					.word	DokeCommand                      ; $b6 DOKE
>8ca4	b3 8b					.word	Unused3                          ; $b7 DOWNTO
>8ca6	cf 86					.word	ElseCode                         ; $b8 ELSE
>8ca8	a4 9f					.word	SyntaxError                      ; $b9 FROM
>8caa	64 a3					.word	GfxCommand                       ; $ba GFX
>8cac	75 86					.word	Command_GOSUB                    ; $bb GOSUB
>8cae	93 86					.word	GotoCommand                      ; $bc GOTO
>8cb0	a4 9f					.word	SyntaxError                      ; $bd HERE
>8cb2	6e a1					.word	ImageCommand                     ; $be IMAGE
>8cb4	d7 86					.word	Command_Input                    ; $bf INPUT
>8cb6	c2 87					.word	LetCommand                       ; $c0 LET
>8cb8	c0 a1					.word	LineCommand                      ; $c1 LINE
>8cba	0e 89					.word	Command_LOCAL                    ; $c2 LOCAL
>8cbc	a4 9f					.word	SyntaxError                      ; $c3 OFF
>8cbe	a4 9f					.word	SyntaxError                      ; $c4 ON
>8cc0	a4 9f					.word	SyntaxError                      ; $c5 OUTLINE
>8cc2	b5 a3					.word	PaletteCommand                   ; $c6 PALETTE
>8cc4	b9 a1					.word	PlotCommand                      ; $c7 PLOT
>8cc6	3e 85					.word	PokeCommand                      ; $c8 POKE
>8cc8	de 86					.word	Command_Print                    ; $c9 PRINT
>8cca	4b 8a					.word	Command_Read                     ; $ca READ
>8ccc	41 a1					.word	RectangleCommand                 ; $cb RECT
>8cce	a8 8a					.word	RemCommand                       ; $cc REM
>8cd0	85 86					.word	Command_RETURN                   ; $cd RETURN
>8cd2	a4 9f					.word	SyntaxError                      ; $ce SOLID
>8cd4	32 a6					.word	SoundCommand                     ; $cf SOUND
>8cd6	50 a1					.word	SpriteCommand                    ; $d0 SPRITE
>8cd8	8a a1					.word	TextCommand                      ; $d1 TEXT
>8cda	b3 8b					.word	Unused2                          ; $d2 TO
.8cdc					VectorSet1:
>8cdc	a4 9f					.word	SyntaxError                      ; $80 !0:EOF
>8cde	a4 9f					.word	SyntaxError                      ; $81 !1:SH1
>8ce0	a4 9f					.word	SyntaxError                      ; $82 !2:SH2
>8ce2	b8 83					.word	AssembleCommand                  ; $83 ASSEMBLE
>8ce4	d4 83					.word	AssertCommand                    ; $84 ASSERT
>8ce6	04 a3					.word	BitmapCtrl                       ; $85 BITMAP
>8ce8	67 85					.word	EndCommand                       ; $86 END
>8cea	ea a5					.word	Explode                          ; $87 EXPLODE
>8cec	96 a4					.word	GoCommand                        ; $88 GO
>8cee	12 88					.word	Command_List                     ; $89 LIST
>8cf0	8d a4					.word	LoadCommand                      ; $8a LOAD
>8cf2	cf 89					.word	NewCommand                       ; $8b NEW
>8cf4	c6 a5					.word	PingCommand                      ; $8c PING
>8cf6	d7 8a					.word	Command_Restore                  ; $8d RESTORE
>8cf8	16 8b					.word	CommandRUN                       ; $8e RUN
>8cfa	de a5					.word	ShootCommand                     ; $8f SHOOT
>8cfc	49 a3					.word	SpritesCtrl                      ; $90 SPRITES
>8cfe	8c 8d					.word	StopCommand                      ; $91 STOP
>8d00	88 8e					.word	WhoCommand                       ; $92 WHO
>8d02	d2 a5					.word	ZapCommand                       ; $93 ZAP
.8d04					VectorSet2:
>8d04	a4 9f					.word	SyntaxError                      ; $80 !0:EOF
>8d06	a4 9f					.word	SyntaxError                      ; $81 !1:SH1
>8d08	a4 9f					.word	SyntaxError                      ; $82 !2:SH2
>8d0a	63 9e					.word	Assemble_adc                     ; $83 ADC
>8d0c	5b 9e					.word	Assemble_and                     ; $84 AND
>8d0e	77 9e					.word	Assemble_asl                     ; $85 ASL
>8d10	e1 9e					.word	Assemble_bcc                     ; $86 BCC
>8d12	e5 9e					.word	Assemble_bcs                     ; $87 BCS
>8d14	ed 9e					.word	Assemble_beq                     ; $88 BEQ
>8d16	a4 9e					.word	Assemble_bit                     ; $89 BIT
>8d18	d5 9e					.word	Assemble_bmi                     ; $8a BMI
>8d1a	e9 9e					.word	Assemble_bne                     ; $8b BNE
>8d1c	d1 9e					.word	Assemble_bpl                     ; $8c BPL
>8d1e	f1 9e					.word	Assemble_bra                     ; $8d BRA
>8d20	f5 9e					.word	Assemble_brk                     ; $8e BRK
>8d22	d9 9e					.word	Assemble_bvc                     ; $8f BVC
>8d24	dd 9e					.word	Assemble_bvs                     ; $90 BVS
>8d26	fd 9e					.word	Assemble_clc                     ; $91 CLC
>8d28	51 9f					.word	Assemble_cld                     ; $92 CLD
>8d2a	11 9f					.word	Assemble_cli                     ; $93 CLI
>8d2c	41 9f					.word	Assemble_clv                     ; $94 CLV
>8d2e	6f 9e					.word	Assemble_cmp                     ; $95 CMP
>8d30	b8 9e					.word	Assemble_cpx                     ; $96 CPX
>8d32	b3 9e					.word	Assemble_cpy                     ; $97 CPY
>8d34	95 9e					.word	Assemble_dec                     ; $98 DEC
>8d36	4d 9f					.word	Assemble_dex                     ; $99 DEX
>8d38	29 9f					.word	Assemble_dey                     ; $9a DEY
>8d3a	5f 9e					.word	Assemble_eor                     ; $9b EOR
>8d3c	9a 9e					.word	Assemble_inc                     ; $9c INC
>8d3e	5d 9f					.word	Assemble_inx                     ; $9d INX
>8d40	49 9f					.word	Assemble_iny                     ; $9e INY
>8d42	cc 9e					.word	Assemble_jmp                     ; $9f JMP
>8d44	c7 9e					.word	Assemble_jsr                     ; $a0 JSR
>8d46	6b 9e					.word	Assemble_lda                     ; $a1 LDA
>8d48	90 9e					.word	Assemble_ldx                     ; $a2 LDX
>8d4a	ae 9e					.word	Assemble_ldy                     ; $a3 LDY
>8d4c	81 9e					.word	Assemble_lsr                     ; $a4 LSR
>8d4e	61 9f					.word	Assemble_nop                     ; $a5 NOP
>8d50	57 9e					.word	Assemble_ora                     ; $a6 ORA
>8d52	0d 9f					.word	Assemble_pha                     ; $a7 PHA
>8d54	f9 9e					.word	Assemble_php                     ; $a8 PHP
>8d56	55 9f					.word	Assemble_phx                     ; $a9 PHX
>8d58	15 9f					.word	Assemble_phy                     ; $aa PHY
>8d5a	1d 9f					.word	Assemble_pla                     ; $ab PLA
>8d5c	01 9f					.word	Assemble_plp                     ; $ac PLP
>8d5e	69 9f					.word	Assemble_plx                     ; $ad PLX
>8d60	25 9f					.word	Assemble_ply                     ; $ae PLY
>8d62	7c 9e					.word	Assemble_rol                     ; $af ROL
>8d64	86 9e					.word	Assemble_ror                     ; $b0 ROR
>8d66	09 9f					.word	Assemble_rti                     ; $b1 RTI
>8d68	19 9f					.word	Assemble_rts                     ; $b2 RTS
>8d6a	73 9e					.word	Assemble_sbc                     ; $b3 SBC
>8d6c	05 9f					.word	Assemble_sec                     ; $b4 SEC
>8d6e	65 9f					.word	Assemble_sed                     ; $b5 SED
>8d70	21 9f					.word	Assemble_sei                     ; $b6 SEI
>8d72	67 9e					.word	Assemble_sta                     ; $b7 STA
>8d74	59 9f					.word	Assemble_stp                     ; $b8 STP
>8d76	8b 9e					.word	Assemble_stx                     ; $b9 STX
>8d78	a9 9e					.word	Assemble_sty                     ; $ba STY
>8d7a	9f 9e					.word	Assemble_stz                     ; $bb STZ
>8d7c	3d 9f					.word	Assemble_tax                     ; $bc TAX
>8d7e	39 9f					.word	Assemble_tay                     ; $bd TAY
>8d80	c2 9e					.word	Assemble_trb                     ; $be TRB
>8d82	bd 9e					.word	Assemble_tsb                     ; $bf TSB
>8d84	45 9f					.word	Assemble_tsx                     ; $c0 TSX
>8d86	2d 9f					.word	Assemble_txa                     ; $c1 TXA
>8d88	35 9f					.word	Assemble_txs                     ; $c2 TXS
>8d8a	31 9f					.word	Assemble_tya                     ; $c3 TYA

;******  Return to file: ./common/commands/run.asm


;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/stop.asm

.8d8c					StopCommand:
.8d8c	a9 08		lda #$08		lda	#8
.8d8e	4c 04 8f	jmp $8f04		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/procscan.asm

.8d91					ProcedureScan:
.8d91	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8d93	85 30		sta $30				sta 	codePtr
.8d95	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8d97	85 31		sta $31				sta 	codePtr+1
.8d99					_PSLoop:
.8d99	b2 30		lda ($30)			lda 	(codePtr)
.8d9b	f0 42		beq $8ddf			beq 	_PSExit
.8d9d	a0 03		ldy #$03			ldy 	#3 							; is it PROC at start of line ?
.8d9f	b1 30		lda ($30),y			lda 	(codePtr),y
.8da1	c9 a4		cmp #$a4			cmp 	#KWD_PROC
.8da3	d0 2d		bne $8dd2			bne 	_PSNext
.8da5	c8		iny				iny 								; get the address of the record to zTemp0 and
.8da6	b1 30		lda ($30),y			lda 	(codePtr),y
.8da8	29 c0		and #$c0			and 	#$C0
.8daa	c9 40		cmp #$40			cmp 	#$40
.8dac	d0 32		bne $8de0			bne 	_PSSyntax
.8dae	b1 30		lda ($30),y			lda 	(codePtr),y
.8db0	18		clc				clc
.8db1	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8db3	85 37		sta $37				sta 	zTemp0+1
.8db5	c8		iny				iny 								; LSB
.8db6	b1 30		lda ($30),y			lda 	(codePtr),y
.8db8	85 36		sta $36				sta 	zTemp0
.8dba	c8		iny				iny 								; character after variable call.
.8dbb	98		tya				tya 								; save Y offset at +7 (exponent slot)
.8dbc	a0 07		ldy #$07			ldy 	#7
.8dbe	91 36		sta ($36),y			sta 	(zTemp0),y
.8dc0	a9 18		lda #$18			lda 	#NSTProcedure 				; mark it as procedure
.8dc2	a0 02		ldy #$02			ldy 	#2
.8dc4	91 36		sta ($36),y			sta 	(zTemp0),y
.8dc6	a2 00		ldx #$00			ldx 	#0 							; copy code-Ptr into offset 3-6 (mantissa)
.8dc8					_PSCopy:
.8dc8	b5 30		lda $30,x			lda 	safePtr,x
.8dca	c8		iny				iny
.8dcb	91 36		sta ($36),y			sta 	(zTemp0),y
.8dcd	e8		inx				inx
.8dce	e0 04		cpx #$04			cpx 	#4
.8dd0	d0 f6		bne $8dc8			bne 	_PSCopy
.8dd2					_PSNext:
.8dd2	18		clc				clc
.8dd3	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8dd5	65 30		adc $30				adc 	codePtr
.8dd7	85 30		sta $30				sta 	codePtr
.8dd9	90 02		bcc $8ddd			bcc 	_CREExit
.8ddb	e6 31		inc $31				inc 	codePtr+1 					; carry
.8ddd					_CREExit:
.8ddd	80 ba		bra $8d99			bra 	_PSLoop
.8ddf					_PSExit:
.8ddf	60		rts				rts
.8de0					_PSSyntax:
.8de0	4c a4 9f	jmp $9fa4			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/scanforward.asm

.8de3					ScanForward:
.8de3	64 38		stz $38				stz 	zTemp1 						; zero the structure count - goes up with WHILE/FOR down with WEND/NEXT etc.
.8de5	86 37		stx $37				stx 	zTemp0+1
.8de7	85 36		sta $36				sta 	zTemp0 						; save X & A as the two possible matches.
.8de9					_ScanLoop:
.8de9	b1 30		lda ($30),y			lda 	(codePtr),y
.8deb	c8		iny				iny
.8dec	a6 38		ldx $38				ldx 	zTemp1 						; if the count is > 0 cannot match as in substructure
.8dee	d0 0e		bne $8dfe			bne 	_ScanGoNext
.8df0	c5 36		cmp $36				cmp 	zTemp0 						; see if either matches
.8df2	f0 04		beq $8df8			beq 	_ScanMatch
.8df4	c5 37		cmp $37				cmp 	zTemp0+1
.8df6	d0 06		bne $8dfe			bne 	_ScanGoNext
.8df8					_ScanMatch:
.8df8	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if asked for EOL, backtrack.
.8dfa	d0 01		bne $8dfd			bne 	_ScanNotEndEOL
.8dfc	88		dey				dey
.8dfd					_ScanNotEndEOL:
.8dfd	60		rts				rts
.8dfe					_ScanGoNext:
.8dfe	20 03 8e	jsr $8e03			jsr  	ScanForwardOne 				; allows for shifts and so on.
.8e01	80 e6		bra $8de9			bra 	_ScanLoop
.8e03					ScanForwardOne:
.8e03	c9 40		cmp #$40			cmp 	#$40 						; if 00-3F, punctuation characters, already done.
.8e05	90 3e		bcc $8e45			bcc 	_SFWExit
.8e07	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if 40-82, skip one extra as these are 2 byte
.8e09	90 18		bcc $8e23			bcc 	_ScanSkipOne	 			; offsets into the identifier table or shifts.
.8e0b	c9 fc		cmp #$fc			cmp 	#$FC 						; FC-FF are data skips (hex consts, strings etc.)
.8e0d	b0 2f		bcs $8e3e			bcs 	_ScanSkipData
.8e0f	c9 a2		cmp #$a2			cmp 	#KWC_FIRST_STRUCTURE 		; structure keyword ?
.8e11	90 32		bcc $8e45			bcc 	_SFWExit 					; if not, ordinary keywords.
.8e13	c9 ad		cmp #$ad			cmp 	#KWC_LAST_STRUCTURE+1
.8e15	b0 2e		bcs $8e45			bcs 	_SFWExit
.8e17	c6 38		dec $38				dec 	zTemp1 						; decrement the sructure count
.8e19	c9 a7		cmp #$a7			cmp 	#KWC_FIRST_STRUCTURE_DEC 	; back if it is a dec structure (e.g. WEND/NEXT)
.8e1b	b0 28		bcs $8e45			bcs 	_SFWExit
.8e1d	e6 38		inc $38				inc 	zTemp1 						; so it's an increment structure
.8e1f	e6 38		inc $38				inc 	zTemp1 						; twice to undo the dec
.8e21	80 22		bra $8e45			bra 	_SFWExit
.8e23					_ScanSkipOne:
.8e23	c8		iny				iny 								; consume the extra one.
.8e24	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if not EOL loop back
.8e26	d0 1d		bne $8e45			bne 	_SFWExit
.8e28	18		clc				clc
.8e29	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8e2b	65 30		adc $30				adc 	codePtr
.8e2d	85 30		sta $30				sta 	codePtr
.8e2f	90 02		bcc $8e33			bcc 	_CREExit
.8e31	e6 31		inc $31				inc 	codePtr+1 					; carry
.8e33					_CREExit:
.8e33	a0 03		ldy #$03			ldy 	#3 							; scan start position.
.8e35	b2 30		lda ($30)			lda 	(codePtr)
.8e37	d0 0c		bne $8e45			bne 	_SFWExit 					; if not zero, more to scan
.8e39	a9 13		lda #$13		lda	#19
.8e3b	4c 04 8f	jmp $8f04		jmp	ErrorHandler
.8e3e					_ScanSkipData:
.8e3e	88		dey				dey 								; point at data token
.8e3f	c8		iny				iny 								; point to offset
.8e40	98		tya				tya 								; A = offset position
.8e41	38		sec				sec 								; add size +1 hence SEC
.8e42	71 30		adc ($30),y			adc 	(codePtr),y
.8e44	a8		tay				tay 								; make current position.
.8e45					_SFWExit:
.8e45	60		rts				rts
.8e46					ScanGetCurrentLineStep:
.8e46	64 38		stz $38				stz 	zTemp1
.8e48	a0 03		ldy #$03			ldy 	#3
.8e4a					_SGCLSLoop:
.8e4a	b1 30		lda ($30),y			lda 	(codePtr),y
.8e4c	c8		iny				iny
.8e4d	c9 80		cmp #$80			cmp 	#KWC_EOL	 				; if EOL exit
.8e4f	f0 05		beq $8e56			beq 	_SGCLSExit
.8e51	20 03 8e	jsr $8e03			jsr 	ScanForwardOne
.8e54	80 f4		bra $8e4a			bra 	_SGCLSLoop
.8e56					_SGCLSExit:
.8e56	a5 38		lda $38				lda 	zTemp1 						; return the adjustment
.8e58	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/while.asm

.8e59					Command_WHILE:
.8e59	5a		phy				phy 								; save position of the test
.8e5a	a2 00		ldx #$00			ldx 	#0 							; work out the while test.
.8e5c	20 74 9d	jsr $9d74			jsr 	EvaluateNumber
.8e5f	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; check if zero
.8e62	f0 0e		beq $8e72			beq 	_WHExitLoop 				; if so exit the loop, while has failed.
.8e64	98		tya				tya 								; position *after* test.
.8e65	7a		ply				ply 								; restore position before test, at WHILE
.8e66	88		dey				dey 								; so we execute the WHILE command again.
.8e67	48		pha				pha 								; push after test on the stack
.8e68	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; allocate 6 bytes on the return stack.
.8e6a	20 b9 a6	jsr $a6b9			jsr 	StackOpen
.8e6d	20 fe a6	jsr $a6fe			jsr 	STKSaveCodePosition 		; save loop position - where the test value expr is.
.8e70	7a		ply				ply 								; restore the position *after* the test
.8e71	60		rts				rts
.8e72					_WHExitLoop:
.8e72	68		pla				pla 								; throw post loop position
.8e73	a9 ac		lda #$ac			lda 	#KWD_WEND 					; scan forward past WEND
.8e75	aa		tax				tax
.8e76	20 e3 8d	jsr $8de3			jsr 	ScanForward
.8e79	60		rts				rts
.8e7a					Command_WEND:
.8e7a	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; check WHILE is TOS e.g. in a while loop :)
.8e7c	a2 10		ldx #$10			ldx 	#ERRID_WHILE 				; this error if not.
.8e7e	20 e6 a6	jsr $a6e6			jsr 	StackCheckFrame
.8e81	20 0f a7	jsr $a70f			jsr 	STKLoadCodePosition 		; loop back to the WHILE keyword.
.8e84	20 d8 a6	jsr $a6d8			jsr 	StackClose		 			; erase the frame
.8e87	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/who.asm

.8e88					WhoCommand:
.8e88	a2 8e		ldx #$8e			ldx 	#(_WHOMessage >> 8)
.8e8a	a9 90		lda #$90			lda 	#(_WHOMessage & $FF)
.8e8c	20 5d 8f	jsr $8f5d			jsr 	PrintStringXA
.8e8f	60		rts				rts
.8e90					_WHOMessage:
>8e90	81						.byte 	$81
>8e91	42 72 6f 75 67 68 74 20				.text 	"Brought to you by :",13,13
>8e99	74 6f 20 79 6f 75 20 62 79 20 3a 0d 0d
>8ea6	09 53 74 65 66 61 6e 79				.text 	9,"Stefany Allaire",13
>8eae	20 41 6c 6c 61 69 72 65 0d
>8eb7	09 4a 65 73 73 69 65 20				.text 	9,"Jessie Oberreuter",13
>8ebf	4f 62 65 72 72 65 75 74 65 72 0d
>8eca	09 50 61 75 6c 20 52 6f				.text 	9,"Paul Robson",13
>8ed2	62 73 6f 6e 0d
>8ed7	09 50 65 74 65 72 20 57				.text 	9,"Peter Weingartner",13
>8edf	65 69 6e 67 61 72 74 6e 65 72 0d
>8eea	00						.byte 	0

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/charcheck.asm

.8eeb					CheckRightBracket:
.8eeb	b1 30		lda ($30),y			lda 	(codePtr),y
.8eed	c8		iny				iny
.8eee	c9 29		cmp #$29			cmp 	#KWD_RPAREN 						; exit if matches
.8ef0	d0 0f		bne $8f01			bne 	CNAFail
.8ef2	60		rts				rts
.8ef3					CheckComma:
.8ef3	b1 30		lda ($30),y			lda 	(codePtr),y
.8ef5	c8		iny				iny
.8ef6	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 						; exit if matches
.8ef8	d0 07		bne $8f01			bne 	CNAFail
.8efa	60		rts				rts
.8efb					CheckNextA:
.8efb	d1 30		cmp ($30),y			cmp 	(codePtr),y
.8efd	d0 02		bne $8f01			bne 	CNAFail
.8eff	c8		iny				iny 								; skip character
.8f00	60		rts				rts 								; and exit
.8f01					CNAFail:
.8f01	4c a4 9f	jmp $9fa4			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/errors.asm

.8f04					ErrorHandler:
.8f04	a8		tay				tay 								; find the error text
.8f05	f0 49		beq $8f50			beq 	_EHEnd
.8f07	a2 00		ldx #$00			ldx 	#0
.8f09	a9 bd		lda #$bd			lda 	#((ErrorText) & $FF)
.8f0b	85 36		sta $36				sta 	0+zTemp0
.8f0d	a9 9f		lda #$9f			lda 	#((ErrorText) >> 8)
.8f0f	85 37		sta $37				sta 	1+zTemp0
.8f11					_EHFind:
.8f11	88		dey				dey 								; keep looking through text
.8f12	f0 0e		beq $8f22			beq 	_EHFound
.8f14					_EHFindZero:
.8f14	b2 36		lda ($36)			lda 	(zTemp0) 					; find the next error
.8f16	e6 36		inc $36				inc 	zTemp0
.8f18	d0 02		bne $8f1c			bne 	_EHFNoCarry
.8f1a	e6 37		inc $37				inc 	zTemp0+1
.8f1c					_EHFNoCarry:
.8f1c	c9 00		cmp #$00			cmp 	#0
.8f1e	d0 f4		bne $8f14			bne 	_EHFindZero
.8f20	80 ef		bra $8f11			bra 	_EHFind
.8f22					_EHFound:
.8f22	a5 36		lda $36				lda 	zTemp0 						; print message
.8f24	a6 37		ldx $37				ldx 	zTemp0+1
.8f26	20 5d 8f	jsr $8f5d			jsr 	PrintStringXA
.8f29	a0 01		ldy #$01			ldy 	#1 							; if line number zero don't print it
.8f2b	b1 30		lda ($30),y			lda 	(codePtr),y
.8f2d	d0 05		bne $8f34			bne 	_EHAtMsg
.8f2f	c8		iny				iny
.8f30	b1 30		lda ($30),y			lda 	(codePtr),y
.8f32	f0 17		beq $8f4b			beq 	_EHCREnd
.8f34					_EHAtMsg:
.8f34	a2 8f		ldx #$8f			ldx 	#_AtMsg >> 8 				; print " at "
.8f36	a9 53		lda #$53			lda 	#_AtMsg & $FF
.8f38	20 5d 8f	jsr $8f5d			jsr 	PrintStringXA
.8f3b	a0 01		ldy #$01			ldy 	#1 							; line number into XA
.8f3d	b1 30		lda ($30),y			lda 	(codePtr),y
.8f3f	48		pha				pha
.8f40	c8		iny				iny
.8f41	b1 30		lda ($30),y			lda 	(codePtr),y
.8f43	aa		tax				tax
.8f44	68		pla				pla
.8f45	20 73 93	jsr $9373			jsr 	ConvertInt16 				; convert XA to string
.8f48	20 5d 8f	jsr $8f5d			jsr 	PrintStringXA 				; and print it.
.8f4b					_EHCREnd:
.8f4b	a9 0d		lda #$0d			lda 	#13 						; new line
.8f4d	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8f50					_EHEnd:
.8f50	4c 83 83	jmp $8383			jmp 	WarmStart
>8f53	20 61 74 20 6c 69 6e 65		_AtMsg:	.text 	" at line ",0
>8f5b	20 00
.8f5d					PrintStringXA:
.8f5d	5a		phy				phy
.8f5e	86 37		stx $37				stx 	zTemp0+1
.8f60	85 36		sta $36				sta 	zTemp0
.8f62	a0 00		ldy #$00			ldy 	#0
.8f64					_PSXALoop:
.8f64	b1 36		lda ($36),y			lda 	(zTemp0),y
.8f66	f0 06		beq $8f6e			beq 	_PSXAExit
.8f68	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8f6b	c8		iny				iny
.8f6c	80 f6		bra $8f64			bra 	_PSXALoop
.8f6e					_PSXAExit:
.8f6e	7a		ply				ply
.8f6f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/compare.asm

.8f70					UnaryTrue:
.8f70	fa		plx				plx
.8f71					ReturnTrue:
.8f71	a9 01		lda #$01			lda 	#1  						; set to 1
.8f73	20 28 9e	jsr $9e28			jsr 	NSMSetByte
.8f76	a9 80		lda #$80			lda 	#$80 						; set sign flag, so it is -1
.8f78	95 50		sta $50,x			sta 	NSStatus,x
.8f7a	60		rts				rts
.8f7b					UnaryFalse:
.8f7b	fa		plx				plx
.8f7c					ReturnFalse:
.8f7c	4c 26 9e	jmp $9e26			jmp 	NSMSetZero 					; set it all to zero
.8f7f					BinaryCompareEqual:
.8f7f	fa		plx				plx
.8f80	20 bb 8f	jsr $8fbb			jsr 	CompareBaseCode
.8f83	c9 00		cmp #$00			cmp 	#0
.8f85	f0 ea		beq $8f71			beq 	ReturnTrue
.8f87	80 f3		bra $8f7c			bra 	ReturnFalse
.8f89					BinaryCompareLess:
.8f89	fa		plx				plx
.8f8a	20 bb 8f	jsr $8fbb			jsr 	CompareBaseCode
.8f8d	c9 ff		cmp #$ff			cmp 	#$FF
.8f8f	f0 e0		beq $8f71			beq 	ReturnTrue
.8f91	80 e9		bra $8f7c			bra 	ReturnFalse
.8f93					BinaryCompareGreater:
.8f93	fa		plx				plx
.8f94	20 bb 8f	jsr $8fbb			jsr 	CompareBaseCode
.8f97	c9 01		cmp #$01			cmp 	#1
.8f99	f0 d6		beq $8f71			beq 	ReturnTrue
.8f9b	80 df		bra $8f7c			bra 	ReturnFalse
.8f9d					BinaryCompareNotEqual:
.8f9d	fa		plx				plx
.8f9e	20 bb 8f	jsr $8fbb			jsr 	CompareBaseCode
.8fa1	c9 00		cmp #$00			cmp 	#0
.8fa3	d0 cc		bne $8f71			bne 	ReturnTrue
.8fa5	80 d5		bra $8f7c			bra 	ReturnFalse
.8fa7					BinaryCompareLessEqual:
.8fa7	fa		plx				plx
.8fa8	20 bb 8f	jsr $8fbb			jsr 	CompareBaseCode
.8fab	c9 01		cmp #$01			cmp 	#1
.8fad	d0 c2		bne $8f71			bne 	ReturnTrue
.8faf	80 cb		bra $8f7c			bra 	ReturnFalse
.8fb1					BinaryCompareGreaterEqual:
.8fb1	fa		plx				plx
.8fb2	20 bb 8f	jsr $8fbb			jsr 	CompareBaseCode
.8fb5	c9 ff		cmp #$ff			cmp 	#$FF
.8fb7	d0 b8		bne $8f71			bne 	ReturnTrue
.8fb9	80 c1		bra $8f7c			bra 	ReturnFalse
.8fbb					CompareBaseCode:
.8fbb	20 c6 96	jsr $96c6			jsr 	DereferenceTopTwo 			; make both values if references.
.8fbe	b5 50		lda $50,x			lda 	NSStatus,x 					; check if either is a string.
.8fc0	15 51		ora $51,x			ora 	NSStatus+1,x
.8fc2	29 10		and #$10			and 	#NSTString
.8fc4	d0 37		bne $8ffd			bne 	_CBCString 					; if so do string code, which will check if both.
.8fc6	b5 78		lda $78,x			lda 	NSExponent,x 				; check both are integers
.8fc8	15 79		ora $79,x			ora 	NSExponent+1,x
.8fca	d0 34		bne $9000			bne 	_CBCFloat
.8fcc	b5 50		lda $50,x			lda 	NSStatus,x
.8fce	15 51		ora $51,x			ora 	NSStatus+1,x
.8fd0	29 08		and #$08			and 	#NSTFloat
.8fd2	d0 2c		bne $9000			bne 	_CBCFloat
.8fd4	20 03 90	jsr $9003			jsr 	CompareFixMinusZero 		; fix up -0 just in cases.
.8fd7	e8		inx				inx
.8fd8	20 03 90	jsr $9003			jsr 	CompareFixMinusZero
.8fdb	ca		dex				dex
.8fdc	b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs different ?
.8fde	55 51		eor $51,x			eor 	NSStatus+1,x
.8fe0	10 0a		bpl $8fec			bpl 	_CDCSameSign
.8fe2	b5 50		lda $50,x			lda 	NSStatus,x 					; if first one is -ve
.8fe4	30 14		bmi $8ffa			bmi 	_CBCLess 					; return $FF
.8fe6					_CBCGreater:
.8fe6	a9 01		lda #$01			lda 	#1
.8fe8	60		rts				rts
.8fe9					_CBCEqual:
.8fe9	a9 00		lda #$00			lda 	#0
.8feb	60		rts				rts
.8fec					_CDCSameSign:
.8fec	20 18 92	jsr $9218			jsr 	SubTopTwoStack 				; unsigned subtract
.8fef	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; or the mantissa together
.8ff2	f0 f5		beq $8fe9			beq 	_CBCEqual 					; -0 == 0
.8ff4	b5 70		lda $70,x			lda 	NSMantissa3,x 				; sign of the result. if +ve return $01 else return $FF
.8ff6	55 51		eor $51,x			eor 	NSStatus+1,x 				; however if both were -ve this is inverted
.8ff8	10 ec		bpl $8fe6			bpl 	_CBCGreater
.8ffa					_CBCLess:
.8ffa	a9 ff		lda #$ff			lda 	#$FF
.8ffc	60		rts				rts
.8ffd					_CBCString:
.8ffd	4c 89 91	jmp $9189			jmp 	CompareStrings
.9000					_CBCFloat:
.9000	4c d3 94	jmp $94d3			jmp 	CompareFloat
.9003					CompareFixMinusZero:
.9003	20 48 9e	jsr $9e48			jsr 	NSMIsZero
.9006	d0 02		bne $900a			bne 	_CFXMZNotZero
.9008	74 50		stz $50,x			stz 	NSStatus,x
.900a					_CFXMZNotZero:
.900a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/concat.asm

.900b					StringConcat:
.900b	b5 50		lda $50,x			lda 	NSStatus,x 					; check both strings
.900d	35 51		and $51,x			and 	NSStatus+1,x
.900f	29 18		and #$18			and 	#NSBTypeMask
.9011	c9 10		cmp #$10			cmp 	#NSTString
.9013	d0 50		bne $9065			bne		_SCType
.9015	64 38		stz $38				stz 	zTemp1 						; counting total length
.9017	e8		inx				inx
.9018	20 36 90	jsr $9036			jsr 	_SCSetupZ0 					; setup for second
.901b	20 3f 90	jsr $903f			jsr 	_SCLengthZ0 				; length for second
.901e	ca		dex				dex
.901f	20 36 90	jsr $9036			jsr 	_SCSetupZ0 					; setup for first
.9022	20 3f 90	jsr $903f			jsr 	_SCLengthZ0 				; length for first
.9025	a5 38		lda $38				lda 	zTemp1 						; allocate memory using total.
.9027	20 a9 a7	jsr $a7a9			jsr 	StringTempAllocate
.902a	20 56 90	jsr $9056			jsr 	_SCCopy 					; copy first out, using zTemp0 from above
.902d	e8		inx				inx
.902e	20 36 90	jsr $9036			jsr 	_SCSetupZ0 					; copy second out
.9031	20 56 90	jsr $9056			jsr 	_SCCopy
.9034	ca		dex				dex
.9035	60		rts				rts
.9036					_SCSetupZ0:
.9036	b5 58		lda $58,x			lda 	NSMantissa0,x
.9038	85 36		sta $36				sta 	zTemp0
.903a	b5 60		lda $60,x			lda 	NSMantissa1,x
.903c	85 37		sta $37				sta 	zTemp0+1
.903e	60		rts				rts
.903f					_SCLengthZ0:
.903f	5a		phy				phy
.9040	a0 00		ldy #$00			ldy 	#0
.9042					_SCLenLoop:
.9042	b1 36		lda ($36),y			lda 	(zTemp0),y
.9044	f0 0e		beq $9054			beq 	_SCLExit
.9046	c8		iny				iny
.9047	e6 38		inc $38				inc 	zTemp1
.9049	a5 38		lda $38				lda	 	zTemp1 						; check string too long.
.904b	c9 fd		cmp #$fd			cmp 	#253
.904d	d0 f3		bne $9042			bne		_SCLenLoop
.904f	a9 09		lda #$09		lda	#9
.9051	4c 04 8f	jmp $8f04		jmp	ErrorHandler
.9054					_SCLExit:
.9054	7a		ply				ply
.9055	60		rts				rts
.9056					_SCCopy:
.9056	5a		phy				phy
.9057	a0 00		ldy #$00			ldy 	#0
.9059					_SCCopyLoop:
.9059	b1 36		lda ($36),y			lda 	(zTemp0),y
.905b	f0 06		beq $9063			beq 	_SCCExit
.905d	20 e2 a7	jsr $a7e2			jsr 	StringTempWrite
.9060	c8		iny				iny
.9061	80 f6		bra $9059			bra 	_SCCopyLoop
.9063					_SCCExit:
.9063	7a		ply				ply
.9064	60		rts				rts
.9065					_SCType:
.9065	4c ae 9f	jmp $9fae			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/divide.asm

.9068					IntegerDivide:
.9068	fa		plx				plx
.9069	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.906b	15 51		ora $51,x			ora 	NSStatus+1,x
.906d	0a		asl a				asl 	a 							; shift reference bit into sign bit
.906e	0a		asl a				asl 	a
.906f	10 05		bpl $9076			bpl 	_NotRef
.9071	48		pha				pha
.9072	20 c6 96	jsr $96c6			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9075	68		pla				pla
.9076					_NotRef:
.9076	0a		asl a				asl 	a
.9077	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9079	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.907b	15 79		ora $79,x			ora 	NSExponent+1,x
.907d	f0 03		beq $9082			beq 	_IntegerCode 				; if clear, then we have two integers
.907f	4c ae 9f	jmp $9fae			jmp 	TypeError 					; anything else, type mismatch.
.9082					_IntegerCode:
.9082	20 9c 90	jsr $909c			jsr 	CheckDivideZero 			; do div zero check
.9085	20 ce 90	jsr $90ce			jsr 	Int32Divide 				; do the division
.9088	20 7f 91	jsr $917f			jsr 	CalculateSign 				; calculate result sign
.908b					NSMCopyPlusTwoToZero:
.908b	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.908d	95 58		sta $58,x			sta 	NSMantissa0,x
.908f	b5 62		lda $62,x			lda 	NSMantissa1+2,x
.9091	95 60		sta $60,x			sta 	NSMantissa1,x
.9093	b5 6a		lda $6a,x			lda 	NSMantissa2+2,x
.9095	95 68		sta $68,x			sta 	NSMantissa2,x
.9097	b5 72		lda $72,x			lda 	NSMantissa3+2,x
.9099	95 70		sta $70,x			sta 	NSMantissa3,x
.909b	60		rts				rts
.909c					CheckDivideZero:
.909c	e8		inx				inx
.909d	20 48 9e	jsr $9e48			jsr 	NSMIsZero
.90a0	f0 02		beq $90a4			beq 	_CDVError
.90a2	ca		dex				dex
.90a3	60		rts				rts
.90a4					_CDVError:
.90a4	a9 03		lda #$03		lda	#3
.90a6	4c 04 8f	jmp $8f04		jmp	ErrorHandler
.90a9					IntegerModulus:
.90a9	fa		plx				plx
.90aa	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.90ac	15 51		ora $51,x			ora 	NSStatus+1,x
.90ae	0a		asl a				asl 	a 							; shift reference bit into sign bit
.90af	0a		asl a				asl 	a
.90b0	10 05		bpl $90b7			bpl 	_NotRef
.90b2	48		pha				pha
.90b3	20 c6 96	jsr $96c6			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.90b6	68		pla				pla
.90b7					_NotRef:
.90b7	0a		asl a				asl 	a
.90b8	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.90ba	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.90bc	15 79		ora $79,x			ora 	NSExponent+1,x
.90be	f0 03		beq $90c3			beq 	_IntegerCode 				; if clear, then we have two integers
.90c0	4c ae 9f	jmp $9fae			jmp 	TypeError 					; anything else, type mismatch.
.90c3					_IntegerCode:
.90c3					IntegerModulusNoCheck:
.90c3	20 9c 90	jsr $909c			jsr 	CheckDivideZero 			; do div zero check
.90c6	20 ce 90	jsr $90ce			jsr 	Int32Divide 				; do the division
.90c9	16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.90cb	56 50		lsr $50,x			lsr 	NSStatus,x
.90cd	60		rts				rts
.90ce					Int32Divide:
.90ce	48		pha				pha 								; save AXY
.90cf	5a		phy				phy
.90d0	20 09 9e	jsr $9e09			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.90d3	20 22 9e	jsr $9e22			jsr 	NSMSetZeroMantissaOnly 		; set S[X] to zero
.90d6	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.90d8					_I32DivideLoop:
.90d8	e8		inx				inx
.90d9	e8		inx				inx
.90da	20 35 9e	jsr $9e35			jsr 	NSMShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.90dd	ca		dex				dex
.90de	ca		dex				dex
.90df	20 36 9e	jsr $9e36			jsr 	NSMRotateLeft
.90e2	20 0d 91	jsr $910d			jsr 	DivideCheckSubtract 		; check if subtract possible
.90e5	90 02		bcc $90e9			bcc 	_I32DivideNoCarryIn
.90e7	f6 5a		inc $5a,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.90e9					_I32DivideNoCarryIn:
.90e9	88		dey				dey 								; loop round till division completed.
.90ea	d0 ec		bne $90d8			bne 	_I32DivideLoop
.90ec	7a		ply				ply 								; restore AXY and exit
.90ed	68		pla				pla
.90ee	60		rts				rts
.90ef					Int32ShiftDivide:
.90ef	48		pha				pha 								; save AY
.90f0	5a		phy				phy
.90f1	e8		inx				inx 								; clear S[X+2]
.90f2	e8		inx				inx
.90f3	20 26 9e	jsr $9e26			jsr 	NSMSetZero
.90f6	ca		dex				dex
.90f7	ca		dex				dex
.90f8	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.90fa					_I32SDLoop:
.90fa	20 0d 91	jsr $910d			jsr 	DivideCheckSubtract 		; check if subtract possible
.90fd	e8		inx				inx
.90fe	e8		inx				inx
.90ff	20 36 9e	jsr $9e36			jsr 	NSMRotateLeft				; shift 64 bit FPA left, rotating carry in
.9102	ca		dex				dex
.9103	ca		dex				dex
.9104	20 36 9e	jsr $9e36			jsr 	NSMRotateLeft
.9107	88		dey				dey 	 							; do 31 times
.9108	d0 f0		bne $90fa			bne 	_I32SDLoop
.910a	7a		ply				ply 								; restore AY and exit
.910b	68		pla				pla
.910c	60		rts				rts
.910d					DivideCheckSubtract:
.910d	20 18 92	jsr $9218			jsr 	SubTopTwoStack 				; subtract Stack[X+1] from Stack[X+0]
.9110	b0 04		bcs $9116			bcs 	_DCSExit 					; if carry set, then could do, exit
.9112	20 fe 91	jsr $91fe			jsr 	AddTopTwoStack 				; add it back in
.9115	18		clc				clc 								; and return False
.9116					_DCSExit:
.9116	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/multiply.asm

.9117					MulInteger:
.9117	fa		plx				plx
.9118	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.911a	15 51		ora $51,x			ora 	NSStatus+1,x
.911c	0a		asl a				asl 	a 							; shift reference bit into sign bit
.911d	0a		asl a				asl 	a
.911e	10 05		bpl $9125			bpl 	_NotRef
.9120	48		pha				pha
.9121	20 c6 96	jsr $96c6			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9124	68		pla				pla
.9125					_NotRef:
.9125	0a		asl a				asl 	a 							; put MSB of type into A:7
.9126	30 09		bmi $9131			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9128	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.912a	15 79		ora $79,x			ora 	NSExponent+1,x
.912c	f0 06		beq $9134			beq 	_IntegerCode 				; if clear, then we have two integers
.912e	4c 95 95	jmp $9595			jmp 	FloatingPointMultiply 							; otherwise at least one float.
.9131					_StringData:
.9131	4c b8 9f	jmp $9fb8			jmp 	NotDoneError							; at least one string - don't know both are strings.
.9134					_IntegerCode:
.9134	20 41 91	jsr $9141			jsr 	MultiplyShort
.9137	c9 00		cmp #$00			cmp 	#0
.9139	f0 05		beq $9140			beq 	_MIExit
.913b	a9 04		lda #$04		lda	#4
.913d	4c 04 8f	jmp $8f04		jmp	ErrorHandler
.9140					_MIExit:
.9140	60		rts				rts
.9141					MultiplyShort:
.9141	5a		phy				phy 								; save Y
.9142	20 09 9e	jsr $9e09			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.9145	20 22 9e	jsr $9e22			jsr 	NSMSetZeroMantissaOnly 		; set mantissa S[X] to zero
.9148	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.914a					_I32MLoop:
.914a	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.914c	15 62		ora $62,x			ora 	NSMantissa1+2,x
.914e	15 6a		ora $6a,x			ora 	NSMantissa2+2,x
.9150	15 72		ora $72,x			ora 	NSMantissa3+2,x
.9152	f0 25		beq $9179			beq 	_I32MExit 					; exit if zero
.9154	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.9156	29 01		and #$01			and 	#1
.9158	f0 0d		beq $9167			beq 	_I32MNoAdd
.915a	20 fe 91	jsr $91fe			jsr 	AddTopTwoStack 				; if so add S[X+1] to S[X+0]
.915d	b5 70		lda $70,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.915f	10 06		bpl $9167			bpl 	_I32MNoAdd
.9161					_I32ShiftRight:
.9161	20 3f 9e	jsr $9e3f			jsr 	NSMShiftRight 				; shift S[X] right
.9164	c8		iny				iny 								; increment shift count
.9165	80 09		bra $9170			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.9167					_I32MNoAdd:
.9167	34 71		bit $71,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.9169	70 f6		bvs $9161			bvs 	_I32ShiftRight 				; instead.
.916b	e8		inx				inx
.916c	20 35 9e	jsr $9e35			jsr 	NSMShiftLeft 				; shift additive S[X+1] left
.916f	ca		dex				dex
.9170					_I32MShiftUpper:
.9170	e8		inx				inx 								; shift S[X+2] right
.9171	e8		inx				inx
.9172	20 3f 9e	jsr $9e3f			jsr 	NSMShiftRight
.9175	ca		dex				dex
.9176	ca		dex				dex
.9177	80 d1		bra $914a			bra 	_I32MLoop 					; try again.
.9179					_I32MExit:
.9179	20 7f 91	jsr $917f			jsr 	CalculateSign
.917c	98		tya				tya 								; shift in A
.917d	7a		ply				ply 								; restore Y and exit
.917e	60		rts				rts
.917f					CalculateSign:
.917f	b5 50		lda $50,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.9181	16 50		asl $50,x			asl 	NSStatus,x 					; shift result left
.9183	55 51		eor $51,x			eor 	NSStatus+1,x
.9185	0a		asl a				asl 	a 							; shift bit 7 into carry
.9186	76 50		ror $50,x			ror 	NSStatus,x 					; shift right into status byte.
.9188	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/scompare.asm

.9189					CompareStrings:
.9189	b5 50		lda $50,x			lda 	NSStatus,x 					; check both are strings
.918b	35 51		and $51,x			and 	NSStatus+1,x
.918d	29 10		and #$10			and 	#NSBIsString
.918f	f0 28		beq $91b9			beq 	_CSTypeError
.9191	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy string addresses to zTemp0/1
.9193	85 36		sta $36				sta 	zTemp0
.9195	b5 60		lda $60,x			lda 	NSMantissa1,x
.9197	85 37		sta $37				sta 	zTemp0+1
.9199	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.919b	85 38		sta $38				sta 	zTemp1
.919d	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.919f	85 39		sta $39				sta 	zTemp1+1
.91a1	5a		phy				phy 								; save Y so we can access strings
.91a2	a0 ff		ldy #$ff			ldy 	#$FF 						; -1 for pre increment.
.91a4					_CSLoop:
.91a4	c8		iny				iny
.91a5	b1 36		lda ($36),y			lda 	(zTemp0),y 					; check if they are the same
.91a7	d1 38		cmp ($38),y			cmp 	(zTemp1),y
.91a9	d0 06		bne $91b1			bne 	_CSDifferent
.91ab	c9 00		cmp #$00			cmp 	#0 							; reached end ?
.91ad	d0 f5		bne $91a4			bne 	_CSLoop 					; still comparing
.91af					_CSExit:
.91af	7a		ply				ply 								; reached end, return zero in A from EOS
.91b0	60		rts				rts
.91b1					_CSDifferent:
.91b1	a9 ff		lda #$ff			lda 	#255 						; if < return $FF
.91b3	90 fa		bcc $91af			bcc		_CSExit
.91b5	a9 01		lda #$01			lda 	#1 							; otherwise return 1.
.91b7	80 f6		bra $91af			bra 	_CSExit
.91b9					_CSTypeError:
.91b9	4c ae 9f	jmp $9fae			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/shifts.asm

.91bc					ShiftLeft:
.91bc	38		sec				sec 								; common code, carry determines which way.
.91bd	80 01		bra $91c0			bra 	ShiftMain
.91bf					ShiftRight:
.91bf	18		clc				clc
.91c0					ShiftMain:
.91c0	fa		plx				plx 								; restore X
.91c1	08		php				php 								; save direction
.91c2	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.91c4	15 51		ora $51,x			ora 	NSStatus+1,x
.91c6	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91c7	0a		asl a				asl 	a
.91c8	10 05		bpl $91cf			bpl 	_NotRef
.91ca	48		pha				pha
.91cb	20 c6 96	jsr $96c6			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91ce	68		pla				pla
.91cf					_NotRef:
.91cf	0a		asl a				asl 	a
.91d0	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.91d2	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91d4	15 79		ora $79,x			ora 	NSExponent+1,x
.91d6	f0 03		beq $91db			beq 	_IntegerCode 				; if clear, then we have two integers
.91d8	4c ae 9f	jmp $9fae			jmp 	TypeError 					; anything else, type mismatch.
.91db					_IntegerCode:
.91db	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; check number < 32
.91dd	29 e0		and #$e0			and 	#$E0
.91df	15 61		ora $61,x			ora 	NSMantissa1+1,x
.91e1	15 69		ora $69,x			ora 	NSMantissa2+1,x
.91e3	15 71		ora $71,x			ora 	NSMantissa3+1,x
.91e5	d0 12		bne $91f9			bne 	_SMExit0 					; if >= 32 it will always return zero.
.91e7					_SMLoop:
.91e7	d6 59		dec $59,x			dec 	NSMantissa0+1,x 			; predecrement, could do << 0
.91e9	30 11		bmi $91fc			bmi 	_SMExit 					; exit if done.
.91eb	28		plp				plp 								; restore direction setting
.91ec	08		php				php
.91ed	90 05		bcc $91f4			bcc 	_SMRight
.91ef	20 35 9e	jsr $9e35			jsr 	NSMShiftLeft 				; shift left if CS
.91f2	80 f3		bra $91e7			bra 	_SMLoop
.91f4					_SMRight:
.91f4	20 3f 9e	jsr $9e3f			jsr 	NSMShiftRight 				; shift right if CC
.91f7	80 ee		bra $91e7			bra 	_SMLoop
.91f9					_SMExit0:
.91f9	20 26 9e	jsr $9e26			jsr 	NSMSetZero 					; return zero.
.91fc					_SMExit:
.91fc	28		plp				plp 								; throw direction
.91fd	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/simple.asm

.91fe					AddTopTwoStack:
.91fe	18		clc				clc
.91ff	b5 58		lda $58,x			lda		NSMantissa0,x
.9201	75 59		adc $59,x			adc 		NSMantissa0+1,x
.9203	95 58		sta $58,x			sta 	NSMantissa0,x
.9205	b5 60		lda $60,x			lda		NSMantissa1,x
.9207	75 61		adc $61,x			adc 		NSMantissa1+1,x
.9209	95 60		sta $60,x			sta 	NSMantissa1,x
.920b	b5 68		lda $68,x			lda		NSMantissa2,x
.920d	75 69		adc $69,x			adc 		NSMantissa2+1,x
.920f	95 68		sta $68,x			sta 	NSMantissa2,x
.9211	b5 70		lda $70,x			lda		NSMantissa3,x
.9213	75 71		adc $71,x			adc 		NSMantissa3+1,x
.9215	95 70		sta $70,x			sta 	NSMantissa3,x
.9217	60		rts				rts
.9218					SubTopTwoStack:
.9218	38		sec				sec
.9219	b5 58		lda $58,x			lda		NSMantissa0,x
.921b	f5 59		sbc $59,x			sbc 		NSMantissa0+1,x
.921d	95 58		sta $58,x			sta 	NSMantissa0,x
.921f	b5 60		lda $60,x			lda		NSMantissa1,x
.9221	f5 61		sbc $61,x			sbc 		NSMantissa1+1,x
.9223	95 60		sta $60,x			sta 	NSMantissa1,x
.9225	b5 68		lda $68,x			lda		NSMantissa2,x
.9227	f5 69		sbc $69,x			sbc 		NSMantissa2+1,x
.9229	95 68		sta $68,x			sta 	NSMantissa2,x
.922b	b5 70		lda $70,x			lda		NSMantissa3,x
.922d	f5 71		sbc $71,x			sbc 		NSMantissa3+1,x
.922f	95 70		sta $70,x			sta 	NSMantissa3,x
.9231	60		rts				rts
.9232					AddInteger:
.9232	fa		plx				plx
.9233	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9235	15 51		ora $51,x			ora 	NSStatus+1,x
.9237	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9238	0a		asl a				asl 	a
.9239	10 05		bpl $9240			bpl 	_NotRef
.923b	48		pha				pha
.923c	20 c6 96	jsr $96c6			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.923f	68		pla				pla
.9240					_NotRef:
.9240	0a		asl a				asl 	a 							; put MSB of type into A:7
.9241	30 09		bmi $924c			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9243	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9245	15 79		ora $79,x			ora 	NSExponent+1,x
.9247	f0 06		beq $924f			beq 	_IntegerCode 				; if clear, then we have two integers
.9249	4c 45 94	jmp $9445			jmp 	FloatingPointAdd 							; otherwise at least one float.
.924c					_StringData:
.924c	4c 0b 90	jmp $900b			jmp 	StringConcat							; at least one string - don't know both are strings.
.924f					_IntegerCode:
.924f					AddCode:
.924f	b5 50		lda $50,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.9251	55 51		eor $51,x			eor 	NSStatus+1,x
.9253	10 a9		bpl $91fe			bpl 	AddTopTwoStack
.9255	20 18 92	jsr $9218			jsr 	SubTopTwoStack 				; do a physical subtraction
.9258	34 70		bit $70,x			bit 	NSMantissa3,x 				; result is +ve, okay
.925a	10 07		bpl $9263			bpl 	_AddExit
.925c	b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign is that of 2nd value
.925e	95 50		sta $50,x			sta 	NSStatus,x
.9260	20 ef 9d	jsr $9def			jsr 	NSMNegateMantissa 			; negate the mantissa and exit
.9263					_AddExit:
.9263	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; check for -0
.9266	d0 02		bne $926a			bne 	_AddNonZero
.9268	74 50		stz $50,x			stz 	NSStatus,x
.926a					_AddNonZero:
.926a	60		rts				rts
.926b					SubInteger:
.926b	fa		plx				plx
.926c	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.926e	15 51		ora $51,x			ora 	NSStatus+1,x
.9270	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9271	0a		asl a				asl 	a
.9272	10 05		bpl $9279			bpl 	_NotRef
.9274	48		pha				pha
.9275	20 c6 96	jsr $96c6			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9278	68		pla				pla
.9279					_NotRef:
.9279	0a		asl a				asl 	a 							; put MSB of type into A:7
.927a	30 09		bmi $9285			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.927c	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.927e	15 79		ora $79,x			ora 	NSExponent+1,x
.9280	f0 06		beq $9288			beq 	_IntegerCode 				; if clear, then we have two integers
.9282	4c 4a 94	jmp $944a			jmp 	FloatingPointSub 							; otherwise at least one float.
.9285					_StringData:
.9285	4c b8 9f	jmp $9fb8			jmp 	NotDoneError							; at least one string - don't know both are strings.
.9288					_IntegerCode:
.9288	b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate the second value.
.928a	49 80		eor #$80			eor 	#$80
.928c	95 51		sta $51,x			sta 	NSStatus+1,x
.928e	80 bf		bra $924f			bra 	AddCode 					; and do the same code as add.
.9290					AndInteger:
.9290	fa		plx				plx
.9291	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9293	15 51		ora $51,x			ora 	NSStatus+1,x
.9295	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9296	0a		asl a				asl 	a
.9297	10 05		bpl $929e			bpl 	_NotRef
.9299	48		pha				pha
.929a	20 c6 96	jsr $96c6			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.929d	68		pla				pla
.929e					_NotRef:
.929e	0a		asl a				asl 	a
.929f	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.92a1	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92a3	15 79		ora $79,x			ora 	NSExponent+1,x
.92a5	f0 03		beq $92aa			beq 	_IntegerCode 				; if clear, then we have two integers
.92a7	4c ae 9f	jmp $9fae			jmp 	TypeError 					; anything else, type mismatch.
.92aa					_IntegerCode:
.92aa	b5 58		lda $58,x			lda		NSMantissa0,x
.92ac	35 59		and $59,x			and 		NSMantissa0+1,x
.92ae	95 58		sta $58,x			sta 	NSMantissa0,x
.92b0	b5 60		lda $60,x			lda		NSMantissa1,x
.92b2	35 61		and $61,x			and 		NSMantissa1+1,x
.92b4	95 60		sta $60,x			sta 	NSMantissa1,x
.92b6	b5 68		lda $68,x			lda		NSMantissa2,x
.92b8	35 69		and $69,x			and 		NSMantissa2+1,x
.92ba	95 68		sta $68,x			sta 	NSMantissa2,x
.92bc	b5 70		lda $70,x			lda		NSMantissa3,x
.92be	35 71		and $71,x			and 		NSMantissa3+1,x
.92c0	95 70		sta $70,x			sta 	NSMantissa3,x
.92c2	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.92c4	60		rts				rts
.92c5					OraInteger:
.92c5	fa		plx				plx
.92c6	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.92c8	15 51		ora $51,x			ora 	NSStatus+1,x
.92ca	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92cb	0a		asl a				asl 	a
.92cc	10 05		bpl $92d3			bpl 	_NotRef
.92ce	48		pha				pha
.92cf	20 c6 96	jsr $96c6			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92d2	68		pla				pla
.92d3					_NotRef:
.92d3	0a		asl a				asl 	a
.92d4	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.92d6	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92d8	15 79		ora $79,x			ora 	NSExponent+1,x
.92da	f0 03		beq $92df			beq 	_IntegerCode 				; if clear, then we have two integers
.92dc	4c ae 9f	jmp $9fae			jmp 	TypeError 					; anything else, type mismatch.
.92df					_IntegerCode:
.92df	b5 58		lda $58,x			lda		NSMantissa0,x
.92e1	15 59		ora $59,x			ora 		NSMantissa0+1,x
.92e3	95 58		sta $58,x			sta 	NSMantissa0,x
.92e5	b5 60		lda $60,x			lda		NSMantissa1,x
.92e7	15 61		ora $61,x			ora 		NSMantissa1+1,x
.92e9	95 60		sta $60,x			sta 	NSMantissa1,x
.92eb	b5 68		lda $68,x			lda		NSMantissa2,x
.92ed	15 69		ora $69,x			ora 		NSMantissa2+1,x
.92ef	95 68		sta $68,x			sta 	NSMantissa2,x
.92f1	b5 70		lda $70,x			lda		NSMantissa3,x
.92f3	15 71		ora $71,x			ora 		NSMantissa3+1,x
.92f5	95 70		sta $70,x			sta 	NSMantissa3,x
.92f7	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.92f9	60		rts				rts
.92fa					EorInteger:
.92fa	fa		plx				plx
.92fb	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.92fd	15 51		ora $51,x			ora 	NSStatus+1,x
.92ff	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9300	0a		asl a				asl 	a
.9301	10 05		bpl $9308			bpl 	_NotRef
.9303	48		pha				pha
.9304	20 c6 96	jsr $96c6			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9307	68		pla				pla
.9308					_NotRef:
.9308	0a		asl a				asl 	a
.9309	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.930b	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.930d	15 79		ora $79,x			ora 	NSExponent+1,x
.930f	f0 03		beq $9314			beq 	_IntegerCode 				; if clear, then we have two integers
.9311	4c ae 9f	jmp $9fae			jmp 	TypeError 					; anything else, type mismatch.
.9314					_IntegerCode:
.9314	b5 58		lda $58,x			lda		NSMantissa0,x
.9316	55 59		eor $59,x			eor 		NSMantissa0+1,x
.9318	95 58		sta $58,x			sta 	NSMantissa0,x
.931a	b5 60		lda $60,x			lda		NSMantissa1,x
.931c	55 61		eor $61,x			eor 		NSMantissa1+1,x
.931e	95 60		sta $60,x			sta 	NSMantissa1,x
.9320	b5 68		lda $68,x			lda		NSMantissa2,x
.9322	55 69		eor $69,x			eor 		NSMantissa2+1,x
.9324	95 68		sta $68,x			sta 	NSMantissa2,x
.9326	b5 70		lda $70,x			lda		NSMantissa3,x
.9328	55 71		eor $71,x			eor 		NSMantissa3+1,x
.932a	95 70		sta $70,x			sta 	NSMantissa3,x
.932c	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.932e	60		rts				rts
.932f					WordIndirect:
.932f	fa		plx				plx
.9330	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9332	15 51		ora $51,x			ora 	NSStatus+1,x
.9334	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9335	0a		asl a				asl 	a
.9336	10 05		bpl $933d			bpl 	_NotRef
.9338	48		pha				pha
.9339	20 c6 96	jsr $96c6			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.933c	68		pla				pla
.933d					_NotRef:
.933d	0a		asl a				asl 	a
.933e	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9340	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9342	15 79		ora $79,x			ora 	NSExponent+1,x
.9344	f0 03		beq $9349			beq 	_IntegerCode 				; if clear, then we have two integers
.9346	4c ae 9f	jmp $9fae			jmp 	TypeError 					; anything else, type mismatch.
.9349					_IntegerCode:
.9349	20 4f 92	jsr $924f			jsr 	AddCode 					; add the two values
.934c	a9 22		lda #$22			lda 	#NSBIsReference+2 			; make a 2 byte reference
.934e	95 50		sta $50,x			sta 	NSStatus,x
.9350	60		rts				rts
.9351					ByteIndirect:
.9351	fa		plx				plx
.9352	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9354	15 51		ora $51,x			ora 	NSStatus+1,x
.9356	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9357	0a		asl a				asl 	a
.9358	10 05		bpl $935f			bpl 	_NotRef
.935a	48		pha				pha
.935b	20 c6 96	jsr $96c6			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.935e	68		pla				pla
.935f					_NotRef:
.935f	0a		asl a				asl 	a
.9360	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9362	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9364	15 79		ora $79,x			ora 	NSExponent+1,x
.9366	f0 03		beq $936b			beq 	_IntegerCode 				; if clear, then we have two integers
.9368	4c ae 9f	jmp $9fae			jmp 	TypeError 					; anything else, type mismatch.
.936b					_IntegerCode:
.936b	20 4f 92	jsr $924f			jsr 	AddCode 					; add the two values
.936e	a9 21		lda #$21			lda 	#NSBIsReference+1 			; make a 1 byte reference
.9370	95 50		sta $50,x			sta 	NSStatus,x
.9372	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/tostring.asm

.9373					ConvertInt16:
.9373	85 58		sta $58				sta 	NSMantissa0 				; set up as 32 bit conversion
.9375	86 60		stx $60				stx 	NSMantissa1
.9377	64 68		stz $68				stz 	NSMantissa2
.9379	64 70		stz $70				stz 	NSMantissa3
.937b	64 50		stz $50				stz 	NSStatus 					; positive integer
.937d	a2 00		ldx #$00			ldx 	#0 							; stack level
.937f	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.9381	80 00		bra $9383			bra 	ConvertInt32
.9383					ConvertInt32:
.9383	5a		phy				phy
.9384	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.9386	24 50		bit $50				bit 	NSStatus 					; output a - if not negative.
.9388	10 08		bpl $9392			bpl 	_CI32NotNeg
.938a	48		pha				pha
.938b	a9 2d		lda #$2d			lda 	#'-'
.938d	99 27 06	sta $0627,y			sta 	NumberBuffer,y
.9390	c8		iny				iny
.9391	68		pla				pla
.9392					_CI32NotNeg:
.9392	20 a0 93	jsr $93a0			jsr 	_CI32DivideConvert 			; recursive conversion
.9395	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.9397	99 27 06	sta $0627,y			sta 	NumberBuffer,y
.939a	7a		ply				ply
.939b	a2 06		ldx #$06			ldx 	#NumberBuffer >> 8 			; return address in XA
.939d	a9 27		lda #$27			lda 	#NumberBuffer & $FF
.939f	60		rts				rts
.93a0					_CI32DivideConvert:
.93a0	e8		inx				inx 								; write to next slot up
.93a1	20 28 9e	jsr $9e28			jsr 	NSMSetByte 		 			; write the base out.
.93a4	ca		dex				dex
.93a5	20 ce 90	jsr $90ce			jsr 	Int32Divide 				; divide
.93a8	b5 58		lda $58,x			lda 	NSMantissa0,x 				; save remainder
.93aa	48		pha				pha
.93ab	20 8b 90	jsr $908b			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.93ae	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; is it zero ?
.93b1	f0 05		beq $93b8			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.93b3	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.93b5	20 a0 93	jsr $93a0			jsr 	_CI32DivideConvert 			; and recusrively call.
.93b8					_CI32NoRecurse:
.93b8	68		pla				pla 								; remainder
.93b9	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.93bb	90 02		bcc $93bf			bcc 	_CI32NotHex
.93bd	69 26		adc #$26			adc 	#6+32
.93bf					_CI32NotHex:
.93bf	69 30		adc #$30			adc 	#48
.93c1	99 27 06	sta $0627,y			sta 	NumberBuffer,y 				; write out and exit
.93c4	c8		iny				iny
.93c5	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/expression.asm


;******  Processing file: ./common/expressions/../generated/precedence.dat

.93c6					PrecedenceLevel:
>93c6	04					.byte	 4	; $00 <<
>93c7	02					.byte	 2	; $01 <=
>93c8	02					.byte	 2	; $02 <>
>93c9	00					.byte	 0	; $03 !!3
>93ca	00					.byte	 0	; $04 ><
>93cb	02					.byte	 2	; $05 >=
>93cc	04					.byte	 4	; $06 >>
>93cd	00					.byte	 0	; $07 !!7
>93ce	00					.byte	 0	; $08 !!8
>93cf	00					.byte	 0	; $09 !!9
>93d0	00					.byte	 0	; $0a !!10
>93d1	00					.byte	 0	; $0b !!11
>93d2	00					.byte	 0	; $0c !!12
>93d3	00					.byte	 0	; $0d !!13
>93d4	00					.byte	 0	; $0e !!14
>93d5	00					.byte	 0	; $0f !!15
>93d6	00					.byte	 0	; $10 @
>93d7	00					.byte	 0	; $11 !!17
>93d8	00					.byte	 0	; $12 !!18
>93d9	00					.byte	 0	; $13 [
>93da	04					.byte	 4	; $14 \
>93db	00					.byte	 0	; $15 ]
>93dc	01					.byte	 1	; $16 ^
>93dd	00					.byte	 0	; $17 _
>93de	00					.byte	 0	; $18 `
>93df	00					.byte	 0	; $19 !!25
>93e0	00					.byte	 0	; $1a !!26
>93e1	00					.byte	 0	; $1b {
>93e2	01					.byte	 1	; $1c |
>93e3	00					.byte	 0	; $1d }
>93e4	00					.byte	 0	; $1e ~
>93e5	00					.byte	 0	; $1f [7m<7F>[m
>93e6	00					.byte	 0	; $20
>93e7	05					.byte	 5	; $21 !
>93e8	00					.byte	 0	; $22 "
>93e9	00					.byte	 0	; $23 #
>93ea	05					.byte	 5	; $24 $
>93eb	04					.byte	 4	; $25 %
>93ec	01					.byte	 1	; $26 &
>93ed	00					.byte	 0	; $27 '
>93ee	00					.byte	 0	; $28 (
>93ef	00					.byte	 0	; $29 )
>93f0	04					.byte	 4	; $2a *
>93f1	03					.byte	 3	; $2b +
>93f2	00					.byte	 0	; $2c ,
>93f3	03					.byte	 3	; $2d -
>93f4	00					.byte	 0	; $2e .
>93f5	04					.byte	 4	; $2f /
>93f6	00					.byte	 0	; $30 0
>93f7	00					.byte	 0	; $31 1
>93f8	00					.byte	 0	; $32 2
>93f9	00					.byte	 0	; $33 3
>93fa	00					.byte	 0	; $34 4
>93fb	00					.byte	 0	; $35 5
>93fc	00					.byte	 0	; $36 6
>93fd	00					.byte	 0	; $37 7
>93fe	00					.byte	 0	; $38 8
>93ff	00					.byte	 0	; $39 9
>9400	00					.byte	 0	; $3a :
>9401	00					.byte	 0	; $3b ;
>9402	02					.byte	 2	; $3c <
>9403	02					.byte	 2	; $3d =
>9404	02					.byte	 2	; $3e >
>9405	05					.byte	 5	; $3f ?

;******  Return to file: ./common/expressions/expression.asm

.9406					EvaluateExpressionAt0:
.9406	a2 00		ldx #$00			ldx 	#0 							; bottom stack level
.9408					EvaluateExpression:
.9408	a9 00		lda #$00			lda 	#0 							; lowest precedence level
.940a					EvaluateExpressionAtPrecedence:
.940a	48		pha				pha 								; save precedence level
.940b	20 52 98	jsr $9852			jsr 	EvaluateTerm 				; evaluate term into level X.
.940e	68		pla				pla 								; restore precedence level.
.940f					_EXPRLoop:
.940f	85 36		sta $36				sta 	zTemp0 						; save current precedence level.
.9411	b1 30		lda ($30),y			lda 	(codePtr),y
.9413	c9 40		cmp #$40			cmp		#$40 						; if >= $40 cannot be an operator
.9415	b0 25		bcs $943c			bcs 	_EXPRExit
.9417	da		phx				phx 								; read the operator precedence
.9418	aa		tax				tax
.9419	bd c6 93	lda $93c6,x			lda 	PrecedenceLevel,x
.941c	fa		plx				plx
.941d	c9 00		cmp #$00			cmp 	#0							; if zero exit (not an operator)
.941f	f0 1b		beq $943c			beq 	_EXPRExit
.9421	85 37		sta $37				sta 	zTemp0+1 					; save operator precedence level.
.9423	a5 36		lda $36				lda 	zTemp0 						; compare current precedence vs. operator precedence
.9425	c5 37		cmp $37				cmp 	zTemp0+1
.9427	b0 13		bcs $943c			bcs		_EXPRExit 					; if current >= operator exit
.9429	48		pha				pha 								; save current precedence.
.942a	b1 30		lda ($30),y			lda 	(codePtr),y
.942c	c8		iny				iny
.942d	48		pha				pha
.942e	a5 37		lda $37				lda 	zTemp0+1 					; get operator precedence level
.9430	e8		inx				inx 								; work out the right hand side.
.9431	20 0a 94	jsr $940a			jsr 	EvaluateExpressionAtPrecedence
.9434	ca		dex				dex
.9435	68		pla				pla 								; get operator, call the code.
.9436	20 3f 94	jsr $943f			jsr 	_EXPRCaller
.9439	68		pla				pla 								; restore precedence level
.943a	80 d3		bra $940f			bra 	_EXPRLoop 					; and go round.
.943c					_EXPRExit:
.943c	a5 36		lda $36				lda 	zTemp0 						; A = current precedence level.
.943e	60		rts				rts
.943f					_EXPRCaller:
.943f	da		phx				phx 								; save on stack, first thing is to restore it
.9440	0a		asl a				asl 	a 							; double so can use vectors into X
.9441	aa		tax				tax
.9442	7c b6 8b	jmp ($8bb6,x)			jmp 	(VectorSetPunc,x) 			; and go to the code.

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/addsub.asm

.9445					FloatingPointAdd:
.9445	20 bb 95	jsr $95bb			jsr 	FloatPrepare 				; prepare for floats
.9448	80 09		bra $9453			bra 	FloatAdd
.944a					FloatingPointSub:
.944a	20 bb 95	jsr $95bb			jsr 	FloatPrepare 				; prepare for floats
.944d					FloatSubtract:
.944d	b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate FPB
.944f	49 80		eor #$80			eor 	#$80
.9451	95 51		sta $51,x			sta 	NSStatus+1,x				; and fall through.
.9453					FloatAdd:
.9453	48		pha				pha
.9454	5a		phy				phy
.9455	20 ca 95	jsr $95ca			jsr 	NSNormalise 				; normalise S[X]
.9458	f0 51		beq $94ab			beq 	_FAReturn1
.945a	e8		inx				inx 								; normalise S[X+1]
.945b	20 ca 95	jsr $95ca			jsr 	NSNormalise
.945e	ca		dex				dex
.945f	c9 00		cmp #$00			cmp 	#0
.9461	f0 60		beq $94c3			beq 	_FAExit 					; if so, just return A
.9463	b5 78		lda $78,x			lda 	NSExponent,x 				; are the exponents the same ?
.9465	d5 79		cmp $79,x			cmp 	NSExponent+1,x
.9467	f0 18		beq $9481			beq 	_FAExponentsEqual
.9469	b5 78		lda $78,x			lda 	NSExponent,x 				; work out the larger exponent
.946b	a8		tay				tay
.946c	38		sec				sec 								; do a signed comparison of the exponents.
.946d	f5 79		sbc $79,x			sbc 	NSExponent+1,x
.946f	50 02		bvc $9473			bvc 	_FANoSignedChange
.9471	49 80		eor #$80			eor 	#$80
.9473					_FANoSignedChange:
.9473	29 80		and #$80			and 	#$80
.9475	10 02		bpl $9479			bpl 	_FAHaveMax
.9477	b4 79		ldy $79,x			ldy 	NSExponent+1,x
.9479					_FAHaveMax:
.9479	20 c6 94	jsr $94c6			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.947c	e8		inx				inx
.947d	20 c6 94	jsr $94c6			jsr 	_FAShiftToExponent
.9480	ca		dex				dex
.9481					_FAExponentsEqual:
.9481	b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs the same
.9483	55 51		eor $51,x			eor 	NSStatus+1,x
.9485	30 0e		bmi $9495			bmi 	_FADifferentSigns
.9487	20 fe 91	jsr $91fe			jsr 	AddTopTwoStack 				; do the add of the mantissae
.948a	b5 70		lda $70,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.948c	10 35		bpl $94c3			bpl 	_FAExit 					; if no, we are done.
.948e	20 3f 9e	jsr $9e3f			jsr 	NSMShiftRight 				; shift A right, renormalising it.
.9491	f6 78		inc $78,x			inc 	NSExponent,x 				; bump the exponent and exit
.9493	80 2e		bra $94c3			bra 	_FAExit
.9495					_FADifferentSigns:
.9495	20 18 92	jsr $9218			jsr 	SubTopTwoStack 				; subtract mantissa B from A
.9498	b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the result negative ?
.949a	10 06		bpl $94a2			bpl 	_FACheckZero 				; if no, check for -0
.949c	20 e8 9d	jsr $9de8			jsr 	NSMNegate 					; netate result
.949f	20 ef 9d	jsr $9def			jsr 	NSMNegateMantissa 			; negate (2'c) the mantissa
.94a2					_FACheckZero:
.94a2	20 48 9e	jsr $9e48			jsr 	NSMIsZero	 				; check for -0
.94a5	d0 1c		bne $94c3			bne 	_FAExit
.94a7	74 50		stz $50,x			stz 	NSStatus,x
.94a9	80 18		bra $94c3			bra 	_FAExit
.94ab					_FAReturn1:
.94ab	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.94ad	95 58		sta $58,x			sta 	NSMantissa0,x
.94af	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.94b1	95 60		sta $60,x			sta 	NSMantissa1,x
.94b3	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.94b5	95 68		sta $68,x			sta 	NSMantissa2,x
.94b7	b5 71		lda $71,x			lda 	NSMantissa3+1,x
.94b9	95 70		sta $70,x			sta 	NSMantissa3,x
.94bb	b5 79		lda $79,x			lda 	NSExponent+1,x
.94bd	95 78		sta $78,x			sta 	NSExponent,x
.94bf	b5 51		lda $51,x			lda 	NSStatus+1,x
.94c1	95 50		sta $50,x			sta 	NSStatus,x
.94c3					_FAExit:
.94c3	7a		ply				ply
.94c4	68		pla				pla
.94c5	60		rts				rts
.94c6					_FAShiftToExponent:
.94c6					_FAShiftToExponent2:
.94c6	98		tya				tya 								; compare Y to exponent
.94c7	d5 78		cmp $78,x			cmp 	NSExponent,x 				; reached the exponent required ?
.94c9	f0 07		beq $94d2			beq 	_FASEExit 					; exit if so.
.94cb	20 3f 9e	jsr $9e3f			jsr 	NSMShiftRight	 			; shift the mantissa right
.94ce	f6 78		inc $78,x			inc 	NSExponent,x 				; increment exponent
.94d0	80 f4		bra $94c6			bra 	_FAShiftToExponent2
.94d2					_FASEExit:
.94d2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/compare.asm

.94d3					CompareFloat:
.94d3	20 4d 94	jsr $944d			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.94d6	b5 60		lda $60,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.94d8	29 f8		and #$f8			and 	#$F8
.94da	15 68		ora $68,x			ora 	NSMantissa2,x
.94dc	15 70		ora $70,x			ora 	NSMantissa3,x
.94de	f0 08		beq $94e8			beq 	_FCExit 					; zero, so approximately identical
.94e0	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.94e2	34 50		bit $50,x			bit 	NSStatus,x
.94e4	10 02		bpl $94e8			bpl 	_FCExit
.94e6					_FCNegative:
.94e6	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.94e8					_FCExit:
.94e8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/divide.asm

.94e9					FDivideCommand:
.94e9	fa		plx				plx	 								; restore stack position
.94ea	20 bb 95	jsr $95bb			jsr 	FloatPrepare 				; prepare for floats
.94ed					FloatDivide:
.94ed	48		pha				pha
.94ee	e8		inx				inx
.94ef	20 ca 95	jsr $95ca			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.94f2	ca		dex				dex
.94f3	c9 00		cmp #$00			cmp 	#0
.94f5	f0 1d		beq $9514			beq 	_FDZero
.94f7	20 ca 95	jsr $95ca			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.94fa	f0 16		beq $9512			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.94fc	20 ef 90	jsr $90ef			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.94ff	20 8b 90	jsr $908b			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.9502	20 ca 95	jsr $95ca			jsr		NSNormalise 				; renormalise
.9505	20 7f 91	jsr $917f			jsr 	CalculateSign 				; calculate result sign
.9508	b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent
.950a	38		sec				sec
.950b	f5 79		sbc $79,x			sbc 	NSExponent+1,x
.950d	38		sec				sec
.950e	e9 1e		sbc #$1e			sbc 	#30
.9510	95 78		sta $78,x			sta 	NSExponent,x
.9512					_FDExit:
.9512	68		pla				pla
.9513	60		rts				rts
.9514					_FDZero:
.9514	a9 03		lda #$03		lda	#3
.9516	4c 04 8f	jmp $8f04		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/fractional.asm

.9519					FloatFractionalPart:
.9519	5a		phy				phy
.951a	b5 50		lda $50,x			lda 	NSStatus,x 					; take absolute value
.951c	29 7f		and #$7f			and 	#$7F
.951e	95 50		sta $50,x			sta 	NSStatus,x
.9520	20 ca 95	jsr $95ca			jsr 	NSNormalise
.9523	b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.9525	38		sec				sec
.9526	e9 e0		sbc #$e0			sbc 	#$E0
.9528	90 29		bcc $9553			bcc 	_FFPExit 					; already fractional
.952a	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.952c	b0 22		bcs $9550			bcs 	_FFPZero
.952e	a8		tay				tay 								; put count to do in Y
.952f	b5 70		lda $70,x			lda 	NSMantissa3,x 				; do each in turn.
.9531	20 55 95	jsr $9555			jsr 	_FFPPartial
.9534	95 70		sta $70,x			sta 	NSMantissa3,x
.9536	b5 68		lda $68,x			lda 	NSMantissa2,x
.9538	20 55 95	jsr $9555			jsr 	_FFPPartial
.953b	95 68		sta $68,x			sta 	NSMantissa2,x
.953d	b5 60		lda $60,x			lda 	NSMantissa1,x
.953f	20 55 95	jsr $9555			jsr 	_FFPPartial
.9542	95 60		sta $60,x			sta 	NSMantissa1,x
.9544	b5 58		lda $58,x			lda 	NSMantissa0,x
.9546	20 55 95	jsr $9555			jsr 	_FFPPartial
.9549	95 58		sta $58,x			sta 	NSMantissa0,x
.954b	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; zeroed check.
.954e	d0 03		bne $9553			bne 	_FFPExit
.9550					_FFPZero:
.9550	20 26 9e	jsr $9e26			jsr 	NSMSetZero
.9553					_FFPExit:
.9553	7a		ply				ply
.9554	60		rts				rts
.9555					_FFPPartial:
.9555	c0 00		cpy #$00			cpy 	#0 							; no more to do
.9557	f0 17		beq $9570			beq 	_FFFPPExit
.9559	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.955b	b0 0c		bcs $9569			bcs 	_FFFPPWholeByte
.955d	5a		phy				phy
.955e					_FFFPPLeft:
.955e	0a		asl a				asl 	a
.955f	88		dey				dey
.9560	d0 fc		bne $955e			bne 	_FFFPPLeft
.9562	7a		ply				ply
.9563					_FFFPPRight:
.9563	4a		lsr a				lsr 	a
.9564	88		dey				dey
.9565	d0 fc		bne $9563			bne 	_FFFPPRight
.9567	80 07		bra $9570			bra 	_FFFPPExit
.9569					_FFFPPWholeByte:
.9569	98		tya				tya 								; subtract 8 from count
.956a	38		sec				sec
.956b	e9 08		sbc #$08			sbc 	#8
.956d	a8		tay				tay
.956e	a9 00		lda #$00			lda 	#0 							; and clear all
.9570					_FFFPPExit:
.9570	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/integer.asm

.9571					FloatIntegerPart:
.9571	48		pha				pha
.9572	b5 78		lda $78,x			lda 	NSExponent,x 				; is it integer already ?
.9574	f0 1d		beq $9593			beq 	_FIPExit 					; if so do nothing
.9576	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; is it zero ?
.9579	f0 15		beq $9590			beq 	_FIPZero 					; if so return zero.
.957b	20 ca 95	jsr $95ca			jsr 	NSNormalise 				; normalise
.957e	f0 10		beq $9590			beq 	_FIPZero 					; normalised to zero, exit zero
.9580					_FIPShift:
.9580	b5 78		lda $78,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.9582	10 07		bpl $958b			bpl 	_FIPCheckZero
.9584	20 3f 9e	jsr $9e3f			jsr 	NSMShiftRight 				; shift mantissa right
.9587	f6 78		inc $78,x			inc 	NSExponent,x 				; bump exponent
.9589	80 f5		bra $9580			bra 	_FIPShift
.958b					_FIPCheckZero:
.958b	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; avoid -0 problem
.958e	d0 03		bne $9593			bne 	_FIPExit 					; set to zero if mantissa zero.
.9590					_FIPZero:
.9590	20 26 9e	jsr $9e26			jsr 	NSMSetZero
.9593					_FIPExit:
.9593	68		pla				pla
.9594	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/multiply.asm

.9595					FloatingPointMultiply:
.9595	20 bb 95	jsr $95bb			jsr 	FloatPrepare 				; prepare for floats
.9598					FloatMultiply:
.9598	48		pha				pha
.9599	20 ca 95	jsr $95ca			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.959c	f0 18		beq $95b6			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.959e	e8		inx				inx
.959f	20 ca 95	jsr $95ca			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.95a2	ca		dex				dex
.95a3	c9 00		cmp #$00			cmp 	#0
.95a5	f0 0c		beq $95b3			beq 	_FDSetZero
.95a7	20 41 91	jsr $9141			jsr 	MultiplyShort 				; calculate the result.
.95aa	75 78		adc $78,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.95ac	18		clc				clc
.95ad	75 79		adc $79,x			adc 	NSExponent+1,x
.95af	95 78		sta $78,x			sta 	NSExponent,x
.95b1	80 03		bra $95b6			bra 	_FDExit
.95b3					_FDSetZero:
.95b3	20 26 9e	jsr $9e26			jsr 	NSMSetZero 					; return 0
.95b6					_FDExit:
.95b6	20 ca 95	jsr $95ca			jsr 	NSNormalise 				; normalise the result
.95b9	68		pla				pla
.95ba	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/utility.asm

.95bb					FloatPrepare:
.95bb	20 c6 96	jsr $96c6			jsr 	DereferenceTopTwo 			; dereference the top two values
.95be	b5 50		lda $50,x			lda 	NSStatus,x 					; check ints/floats, either will do.
.95c0	15 51		ora $51,x			ora 	NSStatus+1,x
.95c2	29 10		and #$10			and 	#NSBIsString
.95c4	d0 01		bne $95c7			bne 	_FDType
.95c6	60		rts				rts
.95c7					_FDType:
.95c7	4c ae 9f	jmp $9fae			jmp 	TypeError
.95ca					NSNormalise:
.95ca	b5 50		lda $50,x			lda 	NSStatus,x 					; make float, keep sign
.95cc	29 80		and #$80			and 	#$80
.95ce	09 08		ora #$08			ora 	#NSTFloat
.95d0	95 50		sta $50,x			sta 	NSStatus,x
.95d2	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; if zero exit
.95d5	d0 07		bne $95de			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.95d7	16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.95d9	76 50		ror $50,x			ror 	NSStatus,x 					; (no -0)
.95db	a9 00		lda #$00			lda 	#0 							; set Z flag
.95dd	60		rts				rts
.95de					_NSNormaliseOptimise:
.95de	b5 70		lda $70,x			lda 	NSMantissa3,x 				; upper byte zero ?
.95e0	d0 19		bne $95fb			bne 	_NSNormaliseLoop
.95e2	b5 68		lda $68,x			lda 	NSMantissa2,x 				; byte normalise
.95e4	30 15		bmi $95fb			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.95e6	95 70		sta $70,x			sta 	NSMantissa3,x
.95e8	b5 60		lda $60,x			lda 	NSMantissa1,x
.95ea	95 68		sta $68,x			sta 	NSMantissa2,x
.95ec	b5 58		lda $58,x			lda 	NSMantissa0,x
.95ee	95 60		sta $60,x			sta 	NSMantissa1,x
.95f0	74 58		stz $58,x			stz 	NSMantissa0,x
.95f2	b5 78		lda $78,x			lda 	NSExponent,x
.95f4	38		sec				sec
.95f5	e9 08		sbc #$08			sbc 	#8
.95f7	95 78		sta $78,x			sta 	NSExponent,x
.95f9	80 e3		bra $95de			bra 	_NSNormaliseOptimise
.95fb					_NSNormaliseLoop:
.95fb	34 70		bit $70,x			bit 	NSMantissa3,x 				; bit 30 set ?
.95fd	70 07		bvs $9606			bvs 	_NSNExit 					; exit if so with Z flag clear
.95ff	20 35 9e	jsr $9e35			jsr 	NSMShiftLeft 				; shift mantissa left
.9602	d6 78		dec $78,x			dec 	NSExponent,x 				; adjust exponent
.9604	80 f5		bra $95fb			bra 	_NSNormaliseLoop
.9606					_NSNExit:
.9606	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.9608	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignnumber.asm

.9609					AssignNumber:
.9609	5a		phy				phy
.960a	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy mantissa0/1 to zTemp0
.960c	85 36		sta $36				sta 	zTemp0
.960e	b5 60		lda $60,x			lda 	NSMantissa1,x
.9610	85 37		sta $37				sta 	zTemp0+1
.9612	b5 50		lda $50,x			lda 	NSStatus,x 					; clear reference bits
.9614	29 df		and #$df			and 	#(NSBIsReference ^ $FF)
.9616	95 50		sta $50,x			sta 	NSStatus,x
.9618	29 18		and #$18			and 	#NSBTypeMask				; assigning to a float ?
.961a	c9 08		cmp #$08			cmp 	#NSTFloat
.961c	f0 24		beq $9642			beq 	_ANFloat
.961e	b5 79		lda $79,x			lda		NSExponent+1,x 				; is it a float
.9620	f0 03		beq $9625			beq		_ANNotFloat
.9622	4c a9 9f	jmp $9fa9			jmp 	RangeError					; if it is, report an error.
.9625					_ANNotFloat:
.9625	b5 50		lda $50,x			lda 	NSStatus,x 					; check if byte/word reference.
.9627	29 03		and #$03			and 	#3
.9629	d0 05		bne $9630			bne 	_ANByteWord
.962b	20 4d 96	jsr $964d			jsr 	_ANCopy4PackSign 			; copy all 4 bytes and sign
.962e	80 1b		bra $964b			bra 	_ANExit
.9630					_ANByteWord:
.9630	48		pha				pha 								; save count
.9631	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; do byte
.9633	92 36		sta ($36)			sta 	(zTemp0)
.9635	68		pla				pla
.9636	c9 01		cmp #$01			cmp	 	#1
.9638	f0 11		beq $964b			beq 	_ANExit
.963a	b5 61		lda $61,x			lda 	NSMantissa1+1,x 			; do word
.963c	a0 01		ldy #$01			ldy 	#1
.963e	91 36		sta ($36),y			sta 	(zTemp0),y
.9640	80 09		bra $964b			bra 	_ANExit
.9642					_ANFloat:
.9642	20 4d 96	jsr $964d			jsr 	_ANCopy4PackSign 			; write all 4 bytes and packed sign
.9645	b5 79		lda $79,x			lda 	NSExponent+1,x 				; copy exponent to slot 4
.9647	a0 04		ldy #$04			ldy 	#4
.9649	91 36		sta ($36),y			sta 	(zTemp0),y
.964b					_ANExit:
.964b	7a		ply				ply
.964c	60		rts				rts
.964d					_ANCopy4PackSign:
.964d	a0 03		ldy #$03			ldy 	#3
.964f	b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign bit into status
.9651	29 80		and #$80			and 	#$80 						; put into high bit of mantissa 3
.9653	15 71		ora $71,x			ora 	NSMantissa3+1,x
.9655	91 36		sta ($36),y			sta 	(zTemp0),y
.9657	88		dey				dey
.9658	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.965a	91 36		sta ($36),y			sta 	(zTemp0),y
.965c	88		dey				dey
.965d	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.965f	91 36		sta ($36),y			sta 	(zTemp0),y
.9661	88		dey				dey
.9662	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9664	91 36		sta ($36),y			sta 	(zTemp0),y
.9666	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignstring.asm

.9667					AssignString:
.9667	5a		phy				phy
.9668	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.966a	85 38		sta $38				sta 	zTemp1
.966c	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.966e	85 39		sta $39				sta 	zTemp1+1
.9670	b5 58		lda $58,x			lda 	NSMantissa0,x
.9672	85 36		sta $36				sta 	zTemp0
.9674	b5 60		lda $60,x			lda 	NSMantissa1,x
.9676	85 37		sta $37				sta 	zTemp0+1
.9678	a0 01		ldy #$01			ldy 	#1 							; the high byte of the target address
.967a	b1 36		lda ($36),y			lda 	(zTemp0),y
.967c	f0 23		beq $96a1			beq 	_ASNewStringRequired 		; if zero, a new string is required.
.967e	38		sec				sec 								; put Address-2 in zsTemp - this is the size/status/string record
.967f	b2 36		lda ($36)			lda 	(zTemp0) 					; of concreted strings
.9681	e9 02		sbc #$02			sbc 	#2
.9683	85 3c		sta $3c				sta 	zsTemp
.9685	a0 01		ldy #$01			ldy 	#1
.9687	b1 36		lda ($36),y			lda 	(zTemp0),y
.9689	e9 00		sbc #$00			sbc 	#0
.968b	85 3d		sta $3d				sta 	zsTemp+1
.968d	a0 ff		ldy #$ff			ldy 	#$FF 						; get length of new string
.968f					_ASGetLength:
.968f	c8		iny				iny
.9690	b1 38		lda ($38),y			lda 	(zTemp1),y
.9692	d0 fb		bne $968f			bne 	_ASGetLength
.9694	98		tya				tya 								; is this length <= current length
.9695	d2 3c		cmp ($3c)			cmp 	(zsTemp)
.9697	90 1e		bcc $96b7			bcc 	_ASCopyString
.9699	f0 1c		beq $96b7			beq 	_ASCopyString
.969b	a9 80		lda #$80			lda 	#$80 						; mark as unused.
.969d	a0 01		ldy #$01			ldy 	#1
.969f	91 3c		sta ($3c),y			sta 	(zsTemp),y
.96a1					_ASNewStringRequired:
.96a1	e8		inx				inx 								; concrete the new string.
.96a2	20 2c a7	jsr $a72c			jsr 	StringConcrete				; (breaks zTemp1/2, not zTemp0 and zsTemp)
.96a5	ca		dex				dex
.96a6	18		clc				clc
.96a7	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy that new address to the reference.
.96a9	69 02		adc #$02			adc 	#2 							; add two to point at the data.
.96ab	92 36		sta ($36)			sta 	(zTemp0)
.96ad	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.96af	69 00		adc #$00			adc 	#0
.96b1	a0 01		ldy #$01			ldy 	#1
.96b3	91 36		sta ($36),y			sta 	(zTemp0),y
.96b5	80 0d		bra $96c4			bra 	_ASExit
.96b7					_ASCopyString:
.96b7	a0 00		ldy #$00			ldy 	#0
.96b9					_ASCopyLoop:
.96b9	b1 38		lda ($38),y			lda 	(zTemp1),y
.96bb	c8		iny				iny
.96bc	c8		iny				iny
.96bd	91 3c		sta ($3c),y			sta 	(zsTemp),y
.96bf	88		dey				dey
.96c0	c9 00		cmp #$00			cmp 	#0
.96c2	d0 f5		bne $96b9			bne 	_ASCopyLoop
.96c4					_ASExit:
.96c4	7a		ply				ply
.96c5	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/dereference.asm

.96c6					DereferenceTopTwo:
.96c6	e8		inx				inx
.96c7	20 cb 96	jsr $96cb			jsr 	Dereference 				; deref x+1
.96ca	ca		dex				dex  								; falls through to deref x
.96cb					Dereference:
.96cb	b5 50		lda $50,x			lda 	NSStatus,x 					; get the status byte
.96cd	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.96cf	f0 48		beq $9719			beq 	_DRFExit 					; not a reference, so exit.
.96d1	5a		phy				phy
.96d2	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address to dereference into zTemp0
.96d4	85 36		sta $36				sta 	zTemp0
.96d6	b5 60		lda $60,x			lda 	NSMantissa1,x
.96d8	85 37		sta $37				sta 	zTemp0+1
.96da	74 60		stz $60,x			stz 	NSMantissa1,x 				; clear second byte.
.96dc	b2 36		lda ($36)			lda 	(zTemp0) 					; do the first byte
.96de	95 58		sta $58,x			sta 	NSMantissa0,x
.96e0	b5 50		lda $50,x			lda 	NSStatus,x 					; get status byte.
.96e2	29 18		and #$18			and 	#NSBTypeMask 				; what type is it ?
.96e4	c9 10		cmp #$10			cmp 	#NSTString 					; if string, dereference two
.96e6	f0 0e		beq $96f6			beq 	_DRFDereferenceTwo
.96e8	c9 08		cmp #$08			cmp 	#NSTFloat 					; if float, do full dereference.
.96ea	f0 2f		beq $971b			beq 	_DRFFull
.96ec	b5 50		lda $50,x			lda 	NSStatus,x 					; must be integer - how many bytes ?
.96ee	29 03		and #$03			and 	#3
.96f0	f0 29		beq $971b			beq 	_DRFFull 					; the whole word
.96f2	c9 01		cmp #$01			cmp 	#1 							; is it 10 (e.g. 2 bytes)
.96f4	f0 06		beq $96fc			beq		_DRFClear23 				; no, one byte, clear 2 & 3 and exit
.96f6					_DRFDereferenceTwo:
.96f6	a0 01		ldy #$01			ldy 	#1
.96f8	b1 36		lda ($36),y			lda 	(zTemp0),y
.96fa	95 60		sta $60,x			sta 	NSMantissa1,x
.96fc					_DRFClear23:
.96fc	74 68		stz $68,x			stz 	NSMantissa2,x 				; clear upper bytes, only read 1 or 2 bytes
.96fe	74 70		stz $70,x			stz 	NSMantissa3,x
.9700	b5 50		lda $50,x			lda 	NSStatus,x 					; make it a value of that type.
.9702	29 18		and #$18			and 	#NSBTypeMask
.9704	95 50		sta $50,x			sta 	NSStatus,x 					; and fall through.
.9706	c9 10		cmp #$10			cmp 	#NSTString  				; is it a string
.9708	d0 0e		bne $9718			bne 	_DRFNotString
.970a	b5 58		lda $58,x			lda 	NSMantissa0,x 				; check address is zero
.970c	15 60		ora $60,x			ora 	NSMantissa1,x
.970e	d0 08		bne $9718			bne 	_DRFNotString
.9710	a9 1a		lda #$1a			lda 	#_DRFNullString & $FF 		; if so, return reference to ""
.9712	95 58		sta $58,x			sta 	NSMantissa0,X
.9714	a9 97		lda #$97			lda 	#_DRFNullString >> 8
.9716	95 60		sta $60,x			sta 	NSMantissa1,X
.9718					_DRFNotString
.9718	7a		ply				ply 								; restore Y and exit
.9719					_DRFExit:
.9719	60		rts				rts
.971a					_DRFNullString:
>971a	00						.byte 	0
.971b					_DRFFull:
.971b	a0 01		ldy #$01			ldy 	#1 							; get remaining 3 bytes.
.971d	b1 36		lda ($36),y			lda 	(zTemp0),y
.971f	95 60		sta $60,x			sta 	NSMantissa1,x
.9721	c8		iny				iny
.9722	b1 36		lda ($36),y			lda 	(zTemp0),y
.9724	95 68		sta $68,x			sta 	NSMantissa2,x
.9726	c8		iny				iny
.9727	b1 36		lda ($36),y			lda 	(zTemp0),y
.9729	95 70		sta $70,x			sta 	NSMantissa3,x
.972b	74 78		stz $78,x			stz 	NSExponent,x 				; clear exponent.
.972d	b5 50		lda $50,x			lda		NSStatus,x 					; see if type is integer
.972f	29 18		and #$18			and 	#NSBTypeMask  				; type information only
.9731	95 50		sta $50,x			sta 	NSStatus,x 					; update it back.
.9733	f0 05		beq $973a			beq 	_DRFNoExponent
.9735	c8		iny				iny 								; if not, read the exponent as well.
.9736	b1 36		lda ($36),y			lda 	(zTemp0),y
.9738	95 78		sta $78,x			sta 	NSExponent,x
.973a					_DRFNoExponent:
.973a	b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the most significant bit set ?
.973c	10 0a		bpl $9748			bpl 	_DRFExit2 					; if not, then exit.
.973e	29 7f		and #$7f			and 	#$7F 						; clear that bit.
.9740	95 70		sta $70,x			sta 	NSMantissa3,x
.9742	b5 50		lda $50,x			lda 	NSStatus,x 					; set the sign flag
.9744	09 80		ora #$80			ora 	#NSBIsNegative
.9746	95 50		sta $50,x			sta 	NSStatus,x
.9748					_DRFExit2:
.9748	7a		ply				ply
.9749	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/number.asm

=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.974a					EncodeNumberStart:
.974a	38		sec				sec
.974b	80 01		bra $974e			bra 	EncodeNumberContinue+1
.974d					EncodeNumberContinue:
.974d	18		clc				clc
.974e					EncodeNumber:
.974e	08		php				php 								; save reset flag.
.974f	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.9751	f0 12		beq $9765			beq 	_ENIsOkay
.9753	c9 30		cmp #$30			cmp 	#"0"
.9755	90 04		bcc $975b			bcc 	_ENBadNumber
.9757	c9 3a		cmp #$3a			cmp 	#"9"+1
.9759	90 0a		bcc $9765			bcc 	_ENIsOkay
.975b					_ENBadNumber:
.975b	28		plp				plp 								; throw saved reset
.975c	ad 05 04	lda $0405			lda 	EncodeState 				; if in decimal mode, construct final number
.975f	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.9761	f0 7b		beq $97de			beq 	_ENConstructFinal
.9763					_ENFail:
.9763	18		clc				clc 								; not allowed
.9764	60		rts				rts
.9765					_ENIsOkay:
.9765	28		plp				plp 								; are we restarting
.9766	90 15		bcc $977d			bcc 	_ENNoRestart
.9768					_ENStartEncode:
.9768	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.976a	f0 0c		beq $9778			beq 	_ENFirstDP
.976c	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.976e	20 28 9e	jsr $9e28			jsr 	NSMSetByte 					; in single byte mode.
.9771	a9 01		lda #$01			lda 	#ESTA_Low
.9773					_ENExitChange:
.9773	8d 05 04	sta $0405			sta 	EncodeState 				; save new state
.9776	38		sec				sec
.9777	60		rts				rts
.9778					_ENFirstDP:
.9778	20 26 9e	jsr $9e26			jsr 	NSMSetZero 					; clear integer part
.977b	80 3c		bra $97b9			bra 	_ESTASwitchFloat			; go straight to float and exi
.977d					_ENNoRestart:
.977d	48		pha				pha 								; save digit or DP on stack.
.977e	ad 05 04	lda $0405			lda 	EncodeState 				; get current state
.9781	c9 01		cmp #$01			cmp 	#ESTA_Low
.9783	f0 09		beq $978e			beq  	_ESTALowState
.9785	c9 02		cmp #$02			cmp 	#ESTA_High
.9787	f0 26		beq $97af			beq 	_ESTAHighState
.9789	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.978b	f0 38		beq $97c5			beq 	_ESTADecimalState
>978d	db						.byte 	$DB 						; causes a break in the emulator
.978e					_ESTALowState:
.978e	68		pla				pla 								; get value back
.978f	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.9791	f0 26		beq $97b9			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.9793	29 0f		and #$0f			and 	#15 						; make digit
.9795	8d 06 04	sta $0406			sta 	DigitTemp 					; save it.
.9798	b5 58		lda $58,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.979a	0a		asl a				asl 	a
.979b	0a		asl a				asl 	a
.979c	75 58		adc $58,x			adc 	NSMantissa0,x
.979e	0a		asl a				asl 	a
.979f	6d 06 04	adc $0406			adc 	DigitTemp
.97a2	95 58		sta $58,x			sta 	NSMantissa0,x
.97a4	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.97a6	90 05		bcc $97ad			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.97a8	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.97aa	8d 05 04	sta $0405			sta 	EncodeState
.97ad					_ESTANoSwitch:
.97ad	38		sec				sec
.97ae	60		rts				rts
.97af					_ESTAHighState:
.97af	68		pla				pla 								; get value back
.97b0	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.97b2	f0 05		beq $97b9			beq 	_ESTASwitchFloat
.97b4	20 12 98	jsr $9812			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.97b7	38		sec				sec
.97b8	60		rts				rts
.97b9					_ESTASwitchFloat:
.97b9	9c 07 04	stz $0407			stz 	DecimalCount 				; reset the count of digits - we divide by 10^n at the end.
.97bc	e8		inx				inx 								; zero the decimal additive.
.97bd	20 26 9e	jsr $9e26			jsr 	NSMSetZero
.97c0	ca		dex				dex
.97c1	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.97c3	80 ae		bra $9773			bra 	_ENExitChange
.97c5					_ESTADecimalState:
.97c5	68		pla				pla 								; digit.
.97c6	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 2nd decimal point.
.97c8	f0 99		beq $9763			beq 	_ENFail
.97ca	e8		inx				inx 								; put digit into fractional part of X+1
.97cb	20 12 98	jsr $9812			jsr 	ESTAShiftDigitIntoMantissa
.97ce	ca		dex				dex
.97cf	ee 07 04	inc $0407			inc 	DecimalCount 				; bump the count of decimals
.97d2	ad 07 04	lda $0407			lda 	DecimalCount 				; too many decimal digits.
.97d5	c9 0b		cmp #$0b			cmp 	#11
.97d7	f0 02		beq $97db			beq 	_ESTADSFail
.97d9	38		sec				sec
.97da	60		rts				rts
.97db					_ESTADSFail:
.97db	4c a9 9f	jmp $9fa9			jmp 	RangeError
.97de					_ENConstructFinal:
.97de	ad 07 04	lda $0407			lda 	DecimalCount 				; get decimal count
.97e1	f0 2d		beq $9810			beq 	_ENCFExit 					; no decimals
.97e3	5a		phy				phy
.97e4	0a		asl a				asl 	a 							; x 4 and CLC
.97e5	0a		asl a				asl 	a
.97e6	6d 07 04	adc $0407			adc 	DecimalCount
.97e9	a8		tay				tay
.97ea	b9 68 9f	lda $9f68,y			lda 	DecimalScalarTable-5,y 		; copy decimal scalar to X+2
.97ed	95 5a		sta $5a,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.97ef	b9 69 9f	lda $9f69,y			lda 	DecimalScalarTable-5+1,y
.97f2	95 62		sta $62,x			sta 	NSMantissa1+2,x
.97f4	b9 6a 9f	lda $9f6a,y			lda 	DecimalScalarTable-5+2,y
.97f7	95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.97f9	b9 6b 9f	lda $9f6b,y			lda 	DecimalScalarTable-5+3,y
.97fc	95 72		sta $72,x			sta 	NSMantissa3+2,x
.97fe	b9 6c 9f	lda $9f6c,y			lda 	DecimalScalarTable-5+4,y
.9801	95 7a		sta $7a,x			sta 	NSExponent+2,x
.9803	a9 08		lda #$08			lda 	#NSTFloat
.9805	95 52		sta $52,x			sta 	NSStatus+2,x
.9807	7a		ply				ply
.9808	e8		inx				inx 								; multiply decimal const by decimal scalar
.9809	20 98 95	jsr $9598			jsr 	FloatMultiply
.980c	ca		dex				dex
.980d	20 53 94	jsr $9453			jsr 	FloatAdd 					; add to integer part.
.9810					_ENCFExit:
.9810	18		clc				clc 								; reject the digit.
.9811	60		rts				rts
.9812					ESTAShiftDigitIntoMantissa:
.9812	29 0f		and #$0f			and 	#15 						; save digit
.9814	48		pha				pha
.9815	b5 70		lda $70,x			lda 	NSMantissa3,x 				; push mantissa on stack
.9817	48		pha				pha
.9818	b5 68		lda $68,x			lda 	NSMantissa2,x
.981a	48		pha				pha
.981b	b5 60		lda $60,x			lda 	NSMantissa1,x
.981d	48		pha				pha
.981e	b5 58		lda $58,x			lda 	NSMantissa0,x
.9820	48		pha				pha
.9821	20 35 9e	jsr $9e35			jsr 	NSMShiftLeft 				; x 2
.9824	20 35 9e	jsr $9e35			jsr 	NSMShiftLeft 				; x 4
.9827	18		clc				clc 								; pop mantissa and add
.9828	68		pla				pla
.9829	75 58		adc $58,x			adc 	NSMantissa0,x
.982b	95 58		sta $58,x			sta 	NSMantissa0,x
.982d	68		pla				pla
.982e	75 60		adc $60,x			adc 	NSMantissa1,x
.9830	95 60		sta $60,x			sta 	NSMantissa1,x
.9832	68		pla				pla
.9833	75 68		adc $68,x			adc 	NSMantissa2,x
.9835	95 68		sta $68,x			sta 	NSMantissa2,x
.9837	68		pla				pla
.9838	75 70		adc $70,x			adc 	NSMantissa3,x
.983a	95 70		sta $70,x			sta 	NSMantissa3,x 				; x 5
.983c	20 35 9e	jsr $9e35			jsr 	NSMShiftLeft 				; x 10
.983f	68		pla				pla 								; add digit
.9840	18		clc				clc
.9841	75 58		adc $58,x			adc 	NSMantissa0,x
.9843	95 58		sta $58,x			sta 	NSMantissa0,x
.9845	90 0a		bcc $9851			bcc 	_ESTASDExit
.9847	f6 60		inc $60,x			inc 	NSMantissa1,x
.9849	d0 06		bne $9851			bne 	_ESTASDExit
.984b	f6 68		inc $68,x			inc 	NSMantissa2,x
.984d	d0 02		bne $9851			bne 	_ESTASDExit
.984f	f6 70		inc $70,x			inc 	NSMantissa3,x
.9851					_ESTASDExit:
.9851	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/term.asm

.9852					EvaluateTerm:
.9852	b1 30		lda ($30),y			lda 	(codePtr),y
.9854	30 18		bmi $986e			bmi 	_ETCheckUnary 				; unary function ? (text ones)
.9856	c9 40		cmp #$40			cmp 	#$40 						; 40-7F => identifier reference
.9858	b0 6c		bcs $98c6			bcs 	_ETVariable
.985a	c9 30		cmp #$30			cmp 	#'0' 						; is it a number
.985c	90 6b		bcc $98c9			bcc 	_ETPuncUnary 				; if not it might be a punctuation unary.
.985e	c9 3a		cmp #$3a			cmp 	#'9'+1
.9860	b0 67		bcs $98c9			bcs 	_ETPuncUnary
.9862	20 4a 97	jsr $974a			jsr 	EncodeNumberStart 			; can't fail as it's 0-9 !
.9865					_ETNumber:
.9865	c8		iny				iny 								; keep encoding until we have the numbers
.9866	b1 30		lda ($30),y			lda 	(codePtr),y
.9868	20 4d 97	jsr $974d			jsr 	EncodeNumberContinue
.986b	b0 f8		bcs $9865			bcs 	_ETNumber 					; go back if accepted.
.986d	60		rts				rts
.986e					_ETCheckUnary:
.986e	c9 ff		cmp #$ff			cmp 	#KWC_STRING 				; string token
.9870	f0 3f		beq $98b1			beq 	_ETString
.9872	c9 fe		cmp #$fe			cmp 	#KWC_HEXCONST 				; hex constant.
.9874	f0 12		beq $9888			beq 	_ETHexConstant
.9876	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; check it actually is a unary function
.9878	90 0b		bcc $9885			bcc 	_ETSyntaxError
.987a	c9 a2		cmp #$a2			cmp 	#KWC_LAST_UNARY+1
.987c	b0 07		bcs $9885			bcs 	_ETSyntaxError
.987e	da		phx				phx 								; push X on the stack
.987f	0a		asl a				asl 	a 							; put vector x 2 into X
.9880	aa		tax				tax
.9881	c8		iny				iny 								; consume unary function token
.9882	7c 36 8c	jmp ($8c36,x)			jmp 	(VectorSet0,x) 				; and do it.
.9885					_ETSyntaxError:
.9885	4c a4 9f	jmp $9fa4			jmp 	SyntaxError
.9888					_ETHexConstant:
.9888	c8		iny				iny 								; skip #
.9889	c8		iny				iny 								; skip count
.988a	20 26 9e	jsr $9e26			jsr 	NSMSetZero 					; clear result
.988d					_ETHLoop:
.988d	b1 30		lda ($30),y			lda 	(codePtr),y
.988f	c8		iny				iny 								; and consume
.9890	c9 00		cmp #$00			cmp 	#0 							; exit if zero
.9892	f0 1c		beq $98b0			beq 	_ETHExit
.9894	48		pha				pha 								; save on stack.
.9895	20 35 9e	jsr $9e35			jsr 	NSMShiftLeft 				; x 2
.9898	20 35 9e	jsr $9e35			jsr 	NSMShiftLeft 				; x 4
.989b	20 35 9e	jsr $9e35			jsr 	NSMShiftLeft 				; x 8
.989e	20 35 9e	jsr $9e35			jsr 	NSMShiftLeft 				; x 16
.98a1	68		pla				pla 								; ASCII
.98a2	c9 41		cmp #$41			cmp 	#'A'
.98a4	90 02		bcc $98a8			bcc 	_ETHNotChar
.98a6	e9 07		sbc #$07			sbc 	#7
.98a8					_ETHNotChar:
.98a8	29 0f		and #$0f			and 	#15 						; digit now
.98aa	15 58		ora $58,x			ora 	NSMantissa0,x 				; put in LS Nibble
.98ac	95 58		sta $58,x			sta 	NSMantissa0,x
.98ae	80 dd		bra $988d			bra 	_ETHLoop 					; go round.
.98b0					_ETHExit:
.98b0	60		rts				rts
.98b1					_ETString:
.98b1	c8		iny				iny 								; look at length
.98b2	b1 30		lda ($30),y			lda 	(codePtr),y
.98b4	48		pha				pha
.98b5	c8		iny				iny 								; first character
.98b6	20 82 a5	jsr $a582			jsr 	MemoryInline 				; put address of string at (code-Ptr),y on stack
.98b9	68		pla				pla 								; restore count and save
.98ba	85 36		sta $36				sta 	zTemp0
.98bc	98		tya				tya 								; add length to Y to skip it.
.98bd	18		clc				clc
.98be	65 36		adc $36				adc 	zTemp0
.98c0	a8		tay				tay
.98c1	a9 10		lda #$10			lda 	#NSTString 					; mark as string
.98c3	95 50		sta $50,x			sta 	NSStatus,x
.98c5	60		rts				rts
.98c6					_ETVariable:
.98c6	4c 1b 99	jmp $991b			jmp 	VariableHandler
.98c9					_ETPuncUnary:
.98c9	c8		iny				iny 								; consume the unary character
.98ca	c9 2d		cmp #$2d			cmp 	#KWD_MINUS 					; unary minus
.98cc	f0 2b		beq $98f9			beq 	_ETUnaryNegate
.98ce	c9 10		cmp #$10			cmp 	#KWD_AT 					; @ reference -> constant
.98d0	f0 36		beq $9908			beq 	_ETDereference
.98d2	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; parenthesis
.98d4	f0 3e		beq $9914			beq 	_ETParenthesis
.98d6	64 36		stz $36				stz 	zTemp0 						; zTemp0 is the indirection level.
.98d8	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; byte indirection (0) ?
.98da	f0 06		beq $98e2			beq 	_ETIndirection
.98dc	e6 36		inc $36				inc 	zTemp0
.98de	c9 21		cmp #$21			cmp 	#KWD_PLING					; word indirection (1) \
.98e0	d0 a3		bne $9885			bne 	_ETSyntaxError
.98e2					_ETIndirection:
.98e2	a5 36		lda $36				lda 	zTemp0 						; push indirection amount (0-1) => (1-2) on the stack
.98e4	1a		inc a				inc 	a
.98e5	48		pha				pha
.98e6	20 52 98	jsr $9852			jsr 	EvaluateTerm				; evaluate the term
.98e9	20 cb 96	jsr $96cb			jsr 	Dereference 				; dereference it.
.98ec	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a +ve integer.
.98ee	d0 06		bne $98f6			bne 	_ETTypeMismatch
.98f0	68		pla				pla 								; indirection 1-2
.98f1	09 20		ora #$20			ora 	#NSBIsReference 			; make it a reference.
.98f3	95 50		sta $50,x			sta 	NSStatus,x
.98f5	60		rts				rts
.98f6					_ETTypeMismatch:
.98f6	4c ae 9f	jmp $9fae			jmp 	TypeError
.98f9					_ETUnaryNegate:
.98f9	20 52 98	jsr $9852			jsr 	EvaluateTerm				; evaluate the term
.98fc	20 cb 96	jsr $96cb			jsr 	Dereference 				; dereference it.
.98ff	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a number
.9901	29 10		and #$10			and 	#NSTString
.9903	d0 f1		bne $98f6			bne 	_ETTypeMismatch
.9905	4c e8 9d	jmp $9de8			jmp 	NSMNegate  					; just toggles the sign bit.
.9908					_ETDereference:
.9908	20 52 98	jsr $9852			jsr 	EvaluateTerm				; evaluate the term
.990b	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a reference
.990d	29 20		and #$20			and 	#NSBIsReference
.990f	f0 e5		beq $98f6			beq 	_ETTypeMismatch
.9911	74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer address
.9913	60		rts				rts
.9914					_ETParenthesis:
.9914	20 08 94	jsr $9408			jsr 	EvaluateExpression 			; evaluate here, from lowest precedence
.9917	20 eb 8e	jsr $8eeb			jsr 	CheckRightBracket 			; check for )
.991a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/variable.asm

.991b					VariableHandler:
.991b	b1 30		lda ($30),y			lda 	(codePtr),y
.991d	18		clc				clc
.991e	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.9920	85 37		sta $37				sta 	zTemp0+1
.9922	c8		iny				iny
.9923	b1 30		lda ($30),y			lda 	(codePtr),y
.9925	85 36		sta $36				sta 	zTemp0
.9927	c8		iny				iny
.9928	18		clc				clc									; copy variable address+3 to mantissa
.9929	69 03		adc #$03			adc 	#3 							; this is the address of the data.
.992b	95 58		sta $58,x			sta 	NSMantissa0,x
.992d	a5 37		lda $37				lda 	zTemp0+1
.992f	69 00		adc #$00			adc 	#0
.9931	95 60		sta $60,x			sta 	NSMantissa1,x
.9933	74 68		stz $68,x			stz 	NSMantissa2,x
.9935	74 70		stz $70,x			stz 	NSMantissa3,x
.9937	74 78		stz $78,x			stz 	NSExponent,x
.9939	5a		phy				phy
.993a	a0 02		ldy #$02			ldy 	#2 							; read type
.993c	b1 36		lda ($36),y			lda 	(zTemp0),y
.993e	7a		ply				ply
.993f	29 1c		and #$1c			and 	#NSBTypeMask+NSBIsArray 	; get type information
.9941	09 20		ora #$20			ora 	#NSBIsReference 			; make a reference.
.9943	95 50		sta $50,x			sta 	NSStatus,x
.9945	29 04		and #$04			and 	#NSBIsArray
.9947	d0 01		bne $994a			bne 	_VHArray
.9949	60		rts				rts
.994a					_VHArray:
.994a	e8		inx				inx
.994b	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger 		; get the 1st index.
.994e	a9 ff		lda #$ff			lda 	#$FF 						; set Status of X+2 to a duff value so we know if we picked it up.
.9950	95 51		sta $51,x			sta 	NSStatus+1,x
.9952	b1 30		lda ($30),y			lda 	(codePtr),y
.9954	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.9956	d0 06		bne $995e			bne 	_VHNoSecondIndex
.9958	c8		iny				iny 								; skip the comma
.9959	e8		inx				inx
.995a	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger 		; get the 2nd index.
.995d	ca		dex				dex
.995e					_VHNoSecondIndex:
.995e	ca		dex				dex 								; set X back.
.995f	20 eb 8e	jsr $8eeb			jsr 	CheckRightBracket 			; and check the right bracket.
.9962	5a		phy				phy 								; save position
.9963	a0 02		ldy #$02			ldy 	#2 							; check first index is not-zero, e.g. array defined
.9965	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9967	f0 60		beq $99c9			beq 	_VHBadIndex
.9969	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy record address to zaTemp
.996b	85 3e		sta $3e				sta 	zaTemp
.996d	b5 60		lda $60,x			lda 	NSMantissa1,x
.996f	85 3f		sta $3f				sta 	zaTemp+1
.9971	a0 03		ldy #$03			ldy 	#3 							; get the second index - which is 0 if there is one index.
.9973	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9975	f0 02		beq $9979			beq 	_VHHas2Mask
.9977	a9 ff		lda #$ff			lda 	#$FF
.9979					_VHHas2Mask:
.9979	d5 52		cmp $52,x			cmp 	NSStatus+2,x 				; so if they are the same there are the wrong number of indices
.997b	f0 4c		beq $99c9			beq 	_VHBadIndex
.997d	0a		asl a				asl 	a 							; carry will be set if a second index
.997e	90 08		bcc $9988			bcc 	_VHCheckFirstIndex
.9980	a0 03		ldy #$03			ldy 	#3 			 				; check the 2nd size >= 2nd index
.9982	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9984	d5 5a		cmp $5a,x			cmp 	NSMantissa0+2,x
.9986	90 41		bcc $99c9			bcc 	_VHBadIndex
.9988					_VHCheckFirstIndex:
.9988	a0 02		ldy #$02			ldy 	#2 			 				; check the 2nd size >= 2nd index
.998a	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.998c	d5 59		cmp $59,x			cmp 	NSMantissa0+1,x
.998e	90 39		bcc $99c9			bcc 	_VHBadIndex
.9990	64 36		stz $36				stz 	zTemp0 						; clear zTemp0 (if 1 index)
.9992	64 37		stz $37				stz 	zTemp0+1
.9994	b5 52		lda $52,x			lda 	NSStatus+2,x 				; if only one index provided, don't need to multiply
.9996	30 0e		bmi $99a6			bmi 	_VHNoMultiply
.9998	da		phx				phx
.9999	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; get 2nd index on stack
.999b	48		pha				pha
.999c	a0 02		ldy #$02			ldy 	#2 							; get 1st size in A
.999e	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99a0	1a		inc a				inc 	a 							; add 1 for zero base
.99a1	fa		plx				plx
.99a2	20 d1 9d	jsr $9dd1			jsr 	Multiply8x8 				; calculate -> Z0
.99a5	fa		plx				plx
.99a6					_VHNoMultiply:
.99a6	18		clc				clc
.99a7	a5 36		lda $36				lda 	zTemp0
.99a9	75 59		adc $59,x			adc 	NSMantissa0+1,x
.99ab	85 36		sta $36				sta 	zTemp0
.99ad	a5 37		lda $37				lda 	zTemp0+1
.99af	69 00		adc #$00			adc 	#0
.99b1	85 37		sta $37				sta 	zTemp0+1
.99b3	b5 50		lda $50,x			lda 	NSStatus,x
.99b5	20 1c 85	jsr $851c			jsr 	ScaleByBaseType
.99b8	18		clc				clc
.99b9	b2 3e		lda ($3e)			lda 	(zaTemp)
.99bb	65 36		adc $36				adc 	zTemp0
.99bd	95 58		sta $58,x			sta 	NSMantissa0,x
.99bf	a0 01		ldy #$01			ldy 	#1
.99c1	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99c3	65 37		adc $37				adc 	zTemp0+1
.99c5	95 60		sta $60,x			sta 	NSMantissa1,x
.99c7	7a		ply				ply 								; restore position
.99c8	60		rts				rts
.99c9					_VHBadIndex:
.99c9	a9 17		lda #$17		lda	#23
.99cb	4c 04 8f	jmp $8f04		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/abs.asm

.99ce					AbsUnary:
.99ce	fa		plx				plx 								; restore stack pos
.99cf	20 74 9d	jsr $9d74			jsr 	EvaluateNumber 				; get a float or int
.99d2	20 eb 8e	jsr $8eeb			jsr 	CheckRightBracket
.99d5	b5 50		lda $50,x			lda 	NSStatus,x 					; clear the sign bit
.99d7	29 7f		and #$7f			and 	#$7F
.99d9	95 50		sta $50,x			sta 	NSStatus,x
.99db	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/alloc.asm

.99dc					AllocUnary:
.99dc	fa		plx				plx 								; restore stack pos
.99dd	20 a6 9d	jsr $9da6			jsr 	Evaluate16BitInteger		; get bytes required.
.99e0	20 eb 8e	jsr $8eeb			jsr 	CheckRightBracket
.99e3	da		phx				phx 								; save X/Y
.99e4	5a		phy				phy
.99e5	8a		txa				txa 								; copy X into Y
.99e6	a8		tay				tay
.99e7	b9 60 00	lda $0060,y			lda		NSMantissa1,y 				; get size into XA
.99ea	aa		tax				tax
.99eb	b9 58 00	lda $0058,y			lda 	NSMantissa0,y
.99ee	20 fb 99	jsr $99fb			jsr 	AllocateXABytes 			; allocate memory
.99f1	99 58 00	sta $0058,y			sta 	NSMantissa0,y 				; write address out.
.99f4	8a		txa				txa 	 							; typing is 16 bit integer.
.99f5	99 60 00	sta $0060,y			sta 	NSMantissa1,y
.99f8	7a		ply				ply
.99f9	fa		plx				plx
.99fa	60		rts				rts
.99fb					AllocateXABytes:
.99fb	5a		phy				phy
.99fc	ac 0c 04	ldy $040c			ldy 	lowMemPtr 					; push current address on stack and to zTemp0
.99ff	84 36		sty $36				sty 	zTemp0
.9a01	5a		phy				phy
.9a02	ac 0d 04	ldy $040d			ldy 	lowMemPtr+1
.9a05	84 37		sty $37				sty 	zTemp0+1
.9a07	5a		phy				phy
.9a08	18		clc				clc 								; add to low memory pointer
.9a09	6d 0c 04	adc $040c			adc 	lowMemPtr
.9a0c	8d 0c 04	sta $040c			sta 	lowMemPtr
.9a0f	8a		txa				txa
.9a10	6d 0d 04	adc $040d			adc 	lowMemPtr+1
.9a13	8d 0d 04	sta $040d			sta 	lowMemPtr+1
.9a16	b0 2f		bcs $9a47			bcs 	CISSMemory
.9a18	20 39 9a	jsr $9a39			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.9a1b					_ClearMemory:
.9a1b	ad 0c 04	lda $040c			lda 	lowMemPtr 					; cleared all memory allocated
.9a1e	c5 36		cmp $36				cmp 	zTemp0
.9a20	d0 07		bne $9a29			bne 	_CMClearNext
.9a22	ad 0d 04	lda $040d			lda 	lowMemPtr+1
.9a25	c5 37		cmp $37				cmp 	zTemp0+1
.9a27	f0 0c		beq $9a35			beq 	_CMExit
.9a29					_CMClearNext:
.9a29	a9 00		lda #$00			lda 	#0 							; clear byte, advance to next.
.9a2b	92 36		sta ($36)			sta 	(zTemp0)
.9a2d	e6 36		inc $36				inc 	zTemp0
.9a2f	d0 ea		bne $9a1b			bne 	_ClearMemory
.9a31	e6 37		inc $37				inc		zTemp0+1
.9a33	80 e6		bra $9a1b			bra 	_ClearMemory
.9a35					_CMExit:
.9a35	fa		plx				plx
.9a36	68		pla				pla
.9a37	7a		ply				ply
.9a38	60		rts				rts
.9a39					CheckIdentifierStringSpace:
.9a39	48		pha				pha
.9a3a	ad 0d 04	lda $040d			lda 	lowMemPtr+1 				; get low memory pointer
.9a3d	18		clc				clc
.9a3e	69 02		adc #$02			adc 	#2 							; need at least 2 256 byte pages
.9a40	cd 0f 04	cmp $040f			cmp 	StringMemory+1 				; is it >= StringMemory
.9a43	b0 02		bcs $9a47			bcs 	CISSMemory
.9a45	68		pla				pla
.9a46	60		rts				rts
.9a47					CISSMemory:
.9a47	a9 06		lda #$06		lda	#6
.9a49	4c 04 8f	jmp $8f04		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/asc.asm

.9a4c					AscUnary:
.9a4c	fa		plx				plx 								; restore stack pos
.9a4d	20 7e 9d	jsr $9d7e			jsr 	EvaluateString 				; get a string
.9a50	b2 36		lda ($36)			lda 	(zTemp0)					; get/return first character
.9a52	20 28 9e	jsr $9e28			jsr 	NSMSetByte 					; ASC("") will return zero.
.9a55	20 eb 8e	jsr $8eeb			jsr 	CheckRightBracket
.9a58	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/deekpeek.asm

.9a59					PeekUnary:
.9a59	18		clc				clc
.9a5a	80 01		bra $9a5d			bra 	DPUnary
.9a5c					DeekUnary:
.9a5c	38		sec				sec
.9a5d					DPUnary:
.9a5d	fa		plx				plx 								; restore position.
.9a5e	08		php				php									; save on stack, CS = Deek, CC = Peek
.9a5f	20 a6 9d	jsr $9da6			jsr		Evaluate16BitInteger 		; address as constant.
.9a62	20 eb 8e	jsr $8eeb			jsr 	CheckRightBracket
.9a65	28		plp				plp 								; function back.
.9a66	a9 21		lda #$21			lda 	#NSBIsReference+NSTInteger+1 ; 1 byte read
.9a68	90 01		bcc $9a6b			bcc 	_DPUpdate
.9a6a	1a		inc a				inc 	a 							; 2 byte read
.9a6b					_DPUpdate:
.9a6b	95 50		sta $50,x			sta 	NSStatus,x 					; set to 1/2 byte reference.
.9a6d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/frac.asm

.9a6e					FracUnary:
.9a6e	fa		plx				plx 								; restore stack pos
.9a6f	20 74 9d	jsr $9d74			jsr 	EvaluateNumber 				; get a float or int
.9a72	20 eb 8e	jsr $8eeb			jsr 	CheckRightBracket
.9a75	b5 50		lda $50,x			lda 	NSStatus,x
.9a77	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9a79	f0 04		beq $9a7f			beq 	_IUZero
.9a7b	20 19 95	jsr $9519			jsr 	FloatFractionalPart 		; if so, get the fractional part.
.9a7e	60		rts				rts
.9a7f					_IUZero:
.9a7f	20 26 9e	jsr $9e26			jsr 	NSMSetZero
.9a82	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/int.asm

.9a83					IntUnary:
.9a83	fa		plx				plx 								; restore stack pos
.9a84	20 74 9d	jsr $9d74			jsr 	EvaluateNumber 				; get a float or int
.9a87	20 eb 8e	jsr $8eeb			jsr 	CheckRightBracket
.9a8a	b5 50		lda $50,x			lda 	NSStatus,x
.9a8c	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9a8e	f0 03		beq $9a93			beq 	_IUExit
.9a90	20 71 95	jsr $9571			jsr 	FloatIntegerPart 			; if it is get the integer part.
.9a93					_IUExit:
.9a93	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/len.asm

.9a94					LenUnary:
.9a94	fa		plx				plx 								; restore stack pos
.9a95	20 7e 9d	jsr $9d7e			jsr 	EvaluateString 				; get a string
.9a98	5a		phy				phy
.9a99	a0 00		ldy #$00			ldy 	#0 							; find length
.9a9b					_LenFind:
.9a9b	b1 36		lda ($36),y			lda 	(zTemp0),y 					; look for trailing NULL.
.9a9d	f0 06		beq $9aa5			beq 	_LenExit
.9a9f	c8		iny				iny
.9aa0	d0 f9		bne $9a9b			bne 	_LenFind
.9aa2	4c a9 9f	jmp $9fa9			jmp 	RangeError 					; string > 255 - no trailing NULL.
.9aa5					_LenExit:
.9aa5	98		tya				tya		 							; return length
.9aa6	20 28 9e	jsr $9e28			jsr 	NSMSetByte
.9aa9	7a		ply				ply
.9aaa	20 eb 8e	jsr $8eeb			jsr 	CheckRightBracket
.9aad	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/minmax.asm

.9aae					Unary_Min:
.9aae	a9 01		lda #$01			lda 	#1
.9ab0	80 02		bra $9ab4			bra 	UnaryMinMaxMain
.9ab2					Unary_Max:
.9ab2	a9 ff		lda #$ff			lda 	#$FF 						; value from comparator to cause a write
.9ab4					UnaryMinMaxMain:
.9ab4	fa		plx				plx 								; get index on number stack
.9ab5	48		pha				pha 								; save comparator
.9ab6	20 6b 9d	jsr $9d6b			jsr 	EvaluateValue 				; get the first value.
.9ab9					_UMMMLoop:
.9ab9	b1 30		lda ($30),y			lda 	(codePtr),y
.9abb	c9 29		cmp #$29			cmp 	#KWD_RPAREN 				; if right bracket then done.
.9abd	f0 22		beq $9ae1			beq 	_UMMMDone
.9abf	20 f3 8e	jsr $8ef3			jsr 	CheckComma 					; must be a comma
.9ac2	e8		inx				inx
.9ac3	20 6b 9d	jsr $9d6b			jsr 	EvaluateValue
.9ac6	ca		dex				dex
.9ac7	20 09 9e	jsr $9e09			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] (Compare is destructive)
.9aca	e8		inx				inx
.9acb	20 09 9e	jsr $9e09			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2], original
.9ace	e8		inx				inx
.9acf	20 bb 8f	jsr $8fbb			jsr 	CompareBaseCode 			; part of > = < etc. code, returns 255,0 or 1
.9ad2	ca		dex				dex
.9ad3	ca		dex				dex
.9ad4	85 36		sta $36				sta 	zTemp0 						; save required result
.9ad6	68		pla				pla 								; get and save comparator
.9ad7	48		pha				pha
.9ad8	c5 36		cmp $36				cmp 	zTemp0 						; if the comparator
.9ada	d0 dd		bne $9ab9			bne 	_UMMMLoop
.9adc	20 e4 9a	jsr $9ae4			jsr 	ExpCopyAboveDown 			; copy next up slot down
.9adf	80 d8		bra $9ab9			bra 	_UMMMLoop
.9ae1					_UMMMDone:
.9ae1	68		pla				pla 								; throw the comparator
.9ae2	c8		iny				iny 								; skip )
.9ae3	60		rts				rts
.9ae4					ExpCopyAboveDown:
.9ae4	b5 51		lda $51,x			lda 	NSStatus+1,x
.9ae6	95 50		sta $50,x			sta 	NSStatus,x
.9ae8	b5 79		lda $79,x			lda 	NSExponent+1,x
.9aea	95 78		sta $78,x			sta 	NSExponent,x
.9aec	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9aee	95 58		sta $58,x			sta 	NSMantissa0,x
.9af0	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9af2	95 60		sta $60,x			sta 	NSMantissa1,x
.9af4	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.9af6	95 68		sta $68,x			sta 	NSMantissa2,x
.9af8	b5 71		lda $71,x			lda 	NSMantissa3+1,x
.9afa	95 70		sta $70,x			sta 	NSMantissa3,x
.9afc	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/not.asm

.9afd					Unary_Not:
.9afd	fa		plx				plx
.9afe	20 93 9d	jsr $9d93			jsr 	EvaluateInteger 			; get integer
.9b01	20 eb 8e	jsr $8eeb			jsr 	CheckRightBracket
.9b04	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; zero mantissa ?
.9b07	f0 04		beq $9b0d			beq 	_NotZero
.9b09	20 26 9e	jsr $9e26			jsr 	NSMSetZero
.9b0c	60		rts				rts
.9b0d					_NotZero:
.9b0d	4c 71 8f	jmp $8f71			jmp 	ReturnTrue

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/rnd.asm

.9b10					Unary_Random:
.9b10	fa		plx				plx
.9b11	20 82 9b	jsr $9b82			jsr 	Random32Bit 				; get a random number
.9b14	20 6b 9b	jsr $9b6b			jsr 	URCopyToMantissa  			; put in mantissa
.9b17	b1 30		lda ($30),y			lda 	(codePtr),y
.9b19	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.9b1b	f0 08		beq $9b25			beq 	_URNoModulus 				; then we return a random 30 bit number.
.9b1d	e8		inx				inx
.9b1e	20 a6 9d	jsr $9da6			jsr 	Evaluate16BitInteger 		; put modulus value in +1
.9b21	ca		dex				dex
.9b22	20 c3 90	jsr $90c3			jsr 	IntegerModulusNoCheck 		; calculate modulus, so now 0 .. n-1
.9b25					_URNoModulus:
.9b25	74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer positive
.9b27	74 78		stz $78,x			stz 	NSExponent,x
.9b29	20 eb 8e	jsr $8eeb			jsr 	CheckRightBracket
.9b2c	60		rts				rts
.9b2d					Unary_Rnd:
.9b2d	fa		plx				plx
.9b2e	20 74 9d	jsr $9d74			jsr 	EvaluateNumber 				; number to use.
.9b31	20 eb 8e	jsr $8eeb			jsr 	CheckRightBracket 			; closing bracket
.9b34	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; if zero, then don't generate a new number
.9b37	f0 26		beq $9b5f			beq 	_URCopySeed
.9b39	b5 50		lda $50,x			lda 	NSStatus,x 					; if -ve, then seed using parameter
.9b3b	10 1f		bpl $9b5c			bpl 	_URDontSeed
.9b3d	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy - value to seed butchering it.
.9b3f	49 17		eor #$17			eor 	#$17
.9b41	8d 08 04	sta $0408			sta 	RandomSeed+0
.9b44	b5 60		lda $60,x			lda 	NSMantissa1,x
.9b46	49 a5		eor #$a5			eor 	#$A5
.9b48	8d 09 04	sta $0409			sta 	RandomSeed+1
.9b4b	b5 68		lda $68,x			lda 	NSMantissa2,x
.9b4d	49 c2		eor #$c2			eor 	#$C2
.9b4f	8d 0a 04	sta $040a			sta 	RandomSeed+2
.9b52	b5 70		lda $70,x			lda 	NSMantissa3,x
.9b54	49 9d		eor #$9d			eor 	#$9D
.9b56	8d 0b 04	sta $040b			sta 	RandomSeed+3
.9b59	20 82 9b	jsr $9b82			jsr 	Random32Bit
.9b5c					_URDontSeed:
.9b5c	20 82 9b	jsr $9b82			jsr 	Random32Bit 				; generate a number
.9b5f					_URCopySeed:
.9b5f	20 6b 9b	jsr $9b6b			jsr 	URCopyToMantissa 			; copy into mantissa
.9b62	a9 e2		lda #$e2			lda 	#-30 						; force into 0-1 range
.9b64	95 78		sta $78,x			sta 	NSExponent,x
.9b66	a9 08		lda #$08			lda 	#NSTFloat
.9b68	95 50		sta $50,x			sta 	NSStatus,x 					; positive float
.9b6a	60		rts				rts
.9b6b					URCopyToMantissa:
.9b6b	ad 08 04	lda $0408			lda 	RandomSeed+0
.9b6e	95 58		sta $58,x			sta 	NSMantissa0,x
.9b70	ad 09 04	lda $0409			lda 	RandomSeed+1
.9b73	95 60		sta $60,x			sta 	NSMantissa1,x
.9b75	ad 0a 04	lda $040a			lda 	RandomSeed+2
.9b78	95 68		sta $68,x			sta 	NSMantissa2,x
.9b7a	ad 0b 04	lda $040b			lda 	RandomSeed+3
.9b7d	29 3f		and #$3f			and 	#$3F 						; make legal mantissa
.9b7f	95 70		sta $70,x			sta 	NSMantissa3,x
.9b81	60		rts				rts
.9b82					Random32Bit:
.9b82	5a		phy				phy
.9b83	a0 07		ldy #$07			ldy 	#7 							; do it 7 times
.9b85	ad 08 04	lda $0408			lda 	RandomSeed+0 				; check the seed isn't zero
.9b88	d0 03		bne $9b8d			bne 	_Random1
.9b8a	a8		tay				tay 								; if so do it 256 times
.9b8b	a9 aa		lda #$aa			lda		#$AA 						; and use this to seed the seed....
.9b8d					_Random1:
.9b8d	0a		asl a				asl 	a 							; LSFR RNG
.9b8e	2e 09 04	rol $0409			rol 	RandomSeed+1
.9b91	2e 0a 04	rol $040a			rol 	RandomSeed+2
.9b94	2e 0b 04	rol $040b			rol 	RandomSeed+3
.9b97	90 02		bcc $9b9b			bcc 	_Random2
.9b99	49 c5		eor #$c5			eor 	#$C5
.9b9b					_Random2:
.9b9b	88		dey				dey
.9b9c	d0 ef		bne $9b8d			bne 	_Random1
.9b9e	8d 08 04	sta $0408			sta 	RandomSeed+0
.9ba1	7a		ply				ply
.9ba2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/sgn.asm

.9ba3					SgnUnary:
.9ba3	fa		plx				plx 								; restore stack pos
.9ba4	20 74 9d	jsr $9d74			jsr 	EvaluateNumber 				; get a float or int
.9ba7	20 eb 8e	jsr $8eeb			jsr 	CheckRightBracket
.9baa	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; if zero
.9bad	f0 0e		beq $9bbd			beq 	_SGZero  					; return Int Zero
.9baf	b5 50		lda $50,x			lda 	NSStatus,x 					; get status w/sign
.9bb1	48		pha				pha
.9bb2	a9 01		lda #$01			lda 	#1 							; set to 1
.9bb4	20 28 9e	jsr $9e28			jsr 	NSMSetByte
.9bb7	68		pla				pla
.9bb8	29 80		and #$80			and		#$80 						; copy the sign byte out
.9bba	95 50		sta $50,x			sta 	NSStatus,x  				; so it will be -1 or 1
.9bbc	60		rts				rts
.9bbd	20 26 9e	jsr $9e26	_SGZero:jsr 	NSMSetZero
.9bc0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/val.asm

.9bc1					ValUnary:
.9bc1	fa		plx				plx 								; restore stack pos
.9bc2	20 d7 9b	jsr $9bd7			jsr 	ValMainCode 				; do the main val() code
.9bc5	b0 01		bcs $9bc8			bcs 	_VUError 					; couldn't convert
.9bc7	60		rts				rts
.9bc8					_VUError:
.9bc8	4c ae 9f	jmp $9fae			jmp 	TypeError
.9bcb					IsValUnary:
.9bcb	fa		plx				plx 								; restore stack pos
.9bcc	20 d7 9b	jsr $9bd7			jsr 	ValMainCode 				; do the main val() code
.9bcf	b0 03		bcs $9bd4			bcs 	_VUBad
.9bd1	4c 71 8f	jmp $8f71			jmp 	ReturnTrue
.9bd4					_VUBad:
.9bd4	4c 7c 8f	jmp $8f7c			jmp 	ReturnFalse
.9bd7					ValMainCode:
.9bd7	20 7e 9d	jsr $9d7e			jsr 	EvaluateString 				; get a string
.9bda	20 eb 8e	jsr $8eeb			jsr 	CheckRightBracket 			; check right bracket present
.9bdd					ValEvaluateZTemp0:
.9bdd	5a		phy				phy
.9bde	b2 36		lda ($36)			lda 	(zTemp0) 					; check not empty string
.9be0	f0 17		beq $9bf9			beq 	_VMCFail2
.9be2	a0 ff		ldy #$ff			ldy 	#$FF 						; start position
.9be4	48		pha				pha 								; save first character
.9be5	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.9be7	d0 01		bne $9bea			bne 	_VMCStart
.9be9	c8		iny				iny 								; skip over -
.9bea					_VMCStart:
.9bea	38		sec				sec 								; initialise first time round.
.9beb					_VMCNext:
.9beb	c8		iny				iny 								; pre-increment
.9bec	b1 36		lda ($36),y			lda 	(zTemp0),y 					; next character = EOS ?
.9bee	f0 0c		beq $9bfc			beq 	_VMCSuccess 				; successful.
.9bf0	20 4e 97	jsr $974e			jsr 	EncodeNumber 				; send it to the number-builder
.9bf3	90 03		bcc $9bf8			bcc 	_VMCFail 					; if failed, give up.
.9bf5	18		clc				clc 								; next time round, countinue
.9bf6	80 f3		bra $9beb			bra 	_VMCNext
.9bf8					_VMCFail:
.9bf8	68		pla				pla
.9bf9					_VMCFail2:
.9bf9	7a		ply				ply
.9bfa	38		sec				sec
.9bfb	60		rts				rts
.9bfc					_VMCSuccess:
.9bfc	a9 00		lda #$00			lda 	#0 							; construct final
.9bfe	20 4e 97	jsr $974e			jsr 	EncodeNumber 				; by sending a duff value.
.9c01	68		pla				pla 								; if it was -ve
.9c02	c9 2d		cmp #$2d			cmp 	#"-"
.9c04	d0 03		bne $9c09			bne 	_VMCNotNegative
.9c06	20 e8 9d	jsr $9de8			jsr		NSMNegate 					; negate it.
.9c09					_VMCNotNegative:
.9c09	7a		ply				ply
.9c0a	18		clc				clc
.9c0b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/chr.asm

.9c0c					ChrUnary:
.9c0c	fa		plx				plx 								; restore stack pos
.9c0d	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger			; get value (chr$(0) returns an empty string)
.9c10	48		pha				pha
.9c11	20 eb 8e	jsr $8eeb			jsr 	CheckRightBracket
.9c14	a9 01		lda #$01			lda 	#1 							; allocate space for one char
.9c16	20 a9 a7	jsr $a7a9			jsr 	StringTempAllocate
.9c19	68		pla				pla 								; write number to it
.9c1a	20 e2 a7	jsr $a7e2			jsr 	StringTempWrite
.9c1d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/spc.asm

.9c1e					SpcUnary:
.9c1e	fa		plx				plx 								; restore stack pos
.9c1f	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger			; get value
.9c22	5a		phy				phy
.9c23	48		pha				pha 								; save count
.9c24	20 a9 a7	jsr $a7a9			jsr 	StringTempAllocate
.9c27	7a		ply				ply 								; to do count in Y
.9c28					_SpcLoop:
.9c28	c0 00		cpy #$00			cpy 	#0 							; copy Y spaces in.
.9c2a	f0 08		beq $9c34			beq 	_SpcExit
.9c2c	a9 20		lda #$20			lda 	#32
.9c2e	20 e2 a7	jsr $a7e2			jsr 	StringTempWrite
.9c31	88		dey				dey
.9c32	80 f4		bra $9c28			bra 	_SPCLoop
.9c34					_SpcExit:
.9c34	7a		ply				ply
.9c35	20 eb 8e	jsr $8eeb			jsr 	CheckRightBracket
.9c38	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/str.asm

.9c39					Unary_Str:
.9c39	fa		plx				plx
.9c3a	20 74 9d	jsr $9d74			jsr 	EvaluateNumber  			; get number
.9c3d	20 eb 8e	jsr $8eeb			jsr 	CheckRightBracket 			; closing bracket
.9c40	a9 05		lda #$05			lda 	#5 							; maximum decimals, from Basic816
.9c42	20 5b 9c	jsr $9c5b			jsr 	ConvertNumberToString 		; do the conversion.
.9c45	a9 21		lda #$21			lda		#33 						; create buffer
.9c47	20 a9 a7	jsr $a7a9			jsr 	StringTempAllocate 			; allocate memory
.9c4a	da		phx				phx  								; copy the converted string into the buffer.
.9c4b	a2 00		ldx #$00			ldx 	#0
.9c4d					_USCopy:
.9c4d	bd 49 06	lda $0649,x			lda 	DecimalBuffer,x
.9c50	20 e2 a7	jsr $a7e2			jsr 	StringTempWrite
.9c53	e8		inx				inx
.9c54	bd 49 06	lda $0649,x			lda 	DecimalBuffer,x
.9c57	d0 f4		bne $9c4d			bne 	_USCopy
.9c59	fa		plx				plx
.9c5a	60		rts				rts
.9c5b					ConvertNumberToString:
.9c5b	5a		phy				phy 								; save code position
.9c5c	8d 14 04	sta $0414			sta 	DecimalPlaces	 			; save number of DPs.
.9c5f	9c 15 04	stz $0415			stz 	dbOffset 					; offset into decimal buffer = start.
.9c62	b5 50		lda $50,x			lda 	NSStatus,x  				; is it -ve.
.9c64	10 09		bpl $9c6f			bpl 	_CNTSNotNegative
.9c66	29 7f		and #$7f			and 	#$7F 						; make +ve
.9c68	95 50		sta $50,x			sta 	NSStatus,x
.9c6a	a9 2d		lda #$2d			lda 	#"-"
.9c6c	20 d0 9c	jsr $9cd0			jsr 	WriteDecimalBuffer
.9c6f					_CNTSNotNegative:
.9c6f	b5 78		lda $78,x			lda 	NSExponent,x 				; check if decimal
.9c71	f0 12		beq $9c85			beq 	_CNTSNotFloat
.9c73	e8		inx				inx 								; round up so we don't get too many 6.999999
.9c74	a9 01		lda #$01			lda 	#1
.9c76	20 28 9e	jsr $9e28			jsr 	NSMSetByte
.9c79	ca		dex				dex
.9c7a	b5 78		lda $78,x			lda		NSExponent,x
.9c7c	95 79		sta $79,x			sta 	NSExponent+1,x
.9c7e	a9 08		lda #$08			lda 	#NSTFloat
.9c80	95 51		sta $51,x			sta 	NSStatus+1,x
.9c82	20 53 94	jsr $9453			jsr 	FloatAdd
.9c85					_CNTSNotFloat:
.9c85	20 b2 9c	jsr $9cb2			jsr 	MakePlusTwoString 			; do the integer part.
.9c88	20 19 95	jsr $9519			jsr 	FloatFractionalPart 		; get the fractional part
.9c8b	20 ca 95	jsr $95ca			jsr 	NSNormalise					; normalise , exit if zero
.9c8e	f0 20		beq $9cb0			beq 	_CNTSExit
.9c90	a9 2e		lda #$2e			lda 	#"."
.9c92	20 d0 9c	jsr $9cd0			jsr 	WriteDecimalBuffer 			; write decimal place
.9c95					_CNTSDecimal:
.9c95	ce 14 04	dec $0414			dec 	DecimalPlaces 				; done all the decimals
.9c98	30 16		bmi $9cb0			bmi 	_CNTSExit
.9c9a	e8		inx				inx 								; x 10.0
.9c9b	a9 0a		lda #$0a			lda 	#10
.9c9d	20 28 9e	jsr $9e28			jsr 	NSMSetByte
.9ca0	a9 08		lda #$08			lda 	#NSTFloat
.9ca2	95 50		sta $50,x			sta 	NSStatus,x
.9ca4	ca		dex				dex
.9ca5	20 98 95	jsr $9598			jsr 	FloatMultiply
.9ca8	20 b2 9c	jsr $9cb2			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.9cab	20 19 95	jsr $9519			jsr 	FloatFractionalPart 		; get the fractional part
.9cae	80 e5		bra $9c95			bra 	_CNTSDecimal 				; keep going.
.9cb0					_CNTSExit:
.9cb0	7a		ply				ply
.9cb1	60		rts				rts
.9cb2					MakePlusTwoString:
.9cb2	da		phx				phx
.9cb3	20 09 9e	jsr $9e09			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.9cb6	e8		inx				inx 								; access it
.9cb7	e8		inx				inx
.9cb8	20 71 95	jsr $9571			jsr 	FloatIntegerPart 			; make it an integer
.9cbb	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.9cbd	20 83 93	jsr $9383			jsr 	ConvertInt32
.9cc0	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.9cc2					_MPTSCopy:
.9cc2	bd 27 06	lda $0627,x			lda 	NumberBuffer,x
.9cc5	20 d0 9c	jsr $9cd0			jsr 	WriteDecimalBuffer
.9cc8	e8		inx				inx
.9cc9	bd 27 06	lda $0627,x			lda 	NumberBuffer,x
.9ccc	d0 f4		bne $9cc2			bne 	_MPTSCopy
.9cce	fa		plx				plx
.9ccf	60		rts				rts
.9cd0					WriteDecimalBuffer:
.9cd0	da		phx				phx
.9cd1	ae 15 04	ldx $0415			ldx 	dbOffset
.9cd4	9d 49 06	sta $0649,x			sta 	DecimalBuffer,x
.9cd7	9e 4a 06	stz $064a,x			stz 	DecimalBuffer+1,x
.9cda	ee 15 04	inc $0415			inc 	dbOffset
.9cdd	fa		plx				plx
.9cde	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/substring.asm

.9cdf					Unary_Left:
.9cdf	fa		plx				plx
.9ce0	18		clc				clc 								; only one parameter
.9ce1	20 44 9d	jsr $9d44			jsr 	SubstringInitial 			; set up.
.9ce4	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; Param #1 is the length
.9ce6	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9ce8	74 59		stz $59,x			stz 	NSMantissa0+1,x 			; Start is zero.
.9cea	80 25		bra $9d11			bra 	SubstringMain
.9cec					Unary_Right:
.9cec	fa		plx				plx
.9ced	18		clc				clc 								; only one parameter
.9cee	20 44 9d	jsr $9d44			jsr 	SubstringInitial 			; set up.
.9cf1	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; length => param 2
.9cf3	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9cf5	b5 78		lda $78,x			lda 	NSExponent,x 				; total length
.9cf7	f5 59		sbc $59,x			sbc 	NSMantissa0+1,x 			; length - required.
.9cf9	b0 02		bcs $9cfd			bcs 	_URNotUnderflow
.9cfb	a9 00		lda #$00			lda 	#0 							; start from the beginning, as something like right$("AB",3)
.9cfd					_URNotUnderFlow:
.9cfd	95 59		sta $59,x			sta 	NSMantissa0+1,x 			; this is the start position
.9cff	80 10		bra $9d11			bra 	SubStringMain
.9d01					Unary_Mid:
.9d01	fa		plx				plx
.9d02	38		sec				sec 								; two parameters
.9d03	20 44 9d	jsr $9d44			jsr 	SubstringInitial 			; set up.
.9d06	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; first parameter is zero ?
.9d08	f0 04		beq $9d0e			beq 	_UMError
.9d0a	d6 59		dec $59,x			dec 	NSMantissa0+1,x				; reduce initial offset by 1 as MID$(a$,1..) is actually the first character
.9d0c	80 03		bra $9d11			bra 	SubStringMain
.9d0e					_UMError:
.9d0e	4c b3 9f	jmp $9fb3			jmp 	ArgumentError
.9d11					SubStringMain:
.9d11	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; is the initial offset >= the length
.9d13	d5 78		cmp $78,x			cmp 	NSExponent,x
.9d15	b0 27		bcs $9d3e			bcs 	_SSMNull 					; if so, return an empty string.
.9d17	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; if copy count is zero
.9d19	f0 23		beq $9d3e			beq 	_SSMNull 					; return empty string.
.9d1b	18		clc				clc 								; add the offset +1 to the address and
.9d1c	b5 58		lda $58,x			lda	 	NSMantissa0,x 				; put in zTemp, this is the start of the substring to copy.
.9d1e	75 59		adc $59,x			adc 	NSMantissa0+1,x
.9d20	85 36		sta $36				sta 	zTemp0
.9d22	b5 60		lda $60,x			lda	 	NSMantissa1,x
.9d24	69 00		adc #$00			adc 	#0
.9d26	85 37		sta $37				sta 	zTemp0+1
.9d28					_SSMNoCarry:
.9d28	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; characters required.
.9d2a	20 a9 a7	jsr $a7a9			jsr 	StringTempAllocate 			; allocate that many characters
.9d2d	5a		phy				phy 								; save Y
.9d2e	a0 00		ldy #$00			ldy 	#0 							; start copying in.
.9d30					_SSMCopy:
.9d30	b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next character
.9d32	f0 08		beq $9d3c			beq 	_SSMEString 				; no more to copy
.9d34	20 e2 a7	jsr $a7e2			jsr 	StringTempWrite 			; and write it out.
.9d37	c8		iny				iny
.9d38	d6 5a		dec $5a,x			dec 	NSMantissa0+2,x
.9d3a	d0 f4		bne $9d30			bne 	_SSMCopy
.9d3c					_SSMEString:
.9d3c	7a		ply				ply
.9d3d					_SSMExit:
.9d3d	60		rts				rts
.9d3e					_SSMNull:
.9d3e	a9 00		lda #$00			lda 	#0
.9d40	20 a9 a7	jsr $a7a9			jsr 	StringTempAllocate
.9d43	60		rts				rts
.9d44					SubstringInitial:
.9d44	da		phx				phx 								; save initial stack position
.9d45	08		php				php 								; save carry on stack indicating 2 parameters
.9d46	20 7e 9d	jsr $9d7e			jsr 	EvaluateString 				; get a string
.9d49	5a		phy				phy 								; calculate length to exponent.
.9d4a	a0 ff		ldy #$ff			ldy 	#$FF
.9d4c					_SIFindLength:
.9d4c	c8		iny				iny
.9d4d	b1 36		lda ($36),y			lda 	(zTemp0),y
.9d4f	d0 fb		bne $9d4c			bne 	_SIFindLength
.9d51	98		tya				tya
.9d52	95 78		sta $78,x			sta 	NSExponent,x
.9d54	7a		ply				ply
.9d55	e8		inx				inx
.9d56	20 f3 8e	jsr $8ef3			jsr 	CheckComma 					; comma next
.9d59	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger 		; get next parameter
.9d5c	28		plp				plp 								; is it the last parameter ?
.9d5d	90 07		bcc $9d66			bcc 	_SSIExit 					; if so, exit.
.9d5f	e8		inx				inx
.9d60	20 f3 8e	jsr $8ef3			jsr 	CheckComma 					; comma next
.9d63	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger 		; get last parameter
.9d66					_SSIExit:
.9d66	fa		plx				plx
.9d67	20 eb 8e	jsr $8eeb			jsr 	CheckRightBracket 			; check closing bracket
.9d6a	60		rts				rts 								; exit

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/exprhelper.asm

.9d6b					EvaluateValue:
.9d6b	48		pha				pha
.9d6c	20 08 94	jsr $9408			jsr		EvaluateExpression 			; expression
.9d6f	20 cb 96	jsr $96cb			jsr 	Dereference					; derefernce it
.9d72	68		pla				pla
.9d73	60		rts				rts
.9d74					EvaluateNumber:
.9d74	20 6b 9d	jsr $9d6b			jsr 	EvaluateValue 				; get a value
.9d77	b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.9d79	29 10		and #$10			and 	#NSBIsString
.9d7b	d0 13		bne $9d90			bne 	HelperTypeError
.9d7d	60		rts				rts
.9d7e					EvaluateString:
.9d7e	20 6b 9d	jsr $9d6b			jsr 	EvaluateValue 				; get a value
.9d81	b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.9d83	29 10		and #$10			and 	#NSBIsString
.9d85	f0 09		beq $9d90			beq 	HelperTypeError
.9d87					CopyAddressToTemp0:
.9d87	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address -> zTemp0
.9d89	85 36		sta $36				sta 	zTemp0 						; (so we can do something with it)
.9d8b	b5 60		lda $60,x			lda 	NSMantissa1,x
.9d8d	85 37		sta $37				sta 	zTemp0+1
.9d8f	60		rts				rts
.9d90					HelperTypeError:
.9d90	4c ae 9f	jmp $9fae			jmp 	TypeError
.9d93					EvaluateInteger:
.9d93	20 74 9d	jsr $9d74			jsr 	EvaluateNumber
.9d96	b5 78		lda $78,x			lda 	NSExponent,x 				; check exponent is zero
.9d98	d0 09		bne $9da3			bne 	HelperValueError 			; if not, it's a float.
.9d9a	60		rts				rts
.9d9b					EvaluateUnsignedInteger:
.9d9b	20 93 9d	jsr $9d93			jsr 	EvaluateInteger 			; check integer is +ve
.9d9e	b5 50		lda $50,x			lda 	NSStatus,x
.9da0	30 01		bmi $9da3			bmi 	HelperValueError
.9da2	60		rts				rts
.9da3					HelperValueError:
.9da3	4c b3 9f	jmp $9fb3			jmp 	ArgumentError
.9da6					Evaluate16BitInteger:
.9da6	20 9b 9d	jsr $9d9b			jsr	 	EvaluateUnsignedInteger		; get integer
.9da9	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9dab	15 68		ora $68,x			ora 	NSMantissa2,x
.9dad	d0 f4		bne $9da3			bne 	HelperValueError
.9daf	60		rts				rts
.9db0					Evaluate16BitIntegerSigned:
.9db0	20 93 9d	jsr $9d93			jsr	 	EvaluateInteger				; get integer
.9db3	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9db5	15 68		ora $68,x			ora 	NSMantissa2,x
.9db7	d0 ea		bne $9da3			bne 	HelperValueError
.9db9	b5 50		lda $50,x			lda 	NSStatus,x 					; signed ?
.9dbb	10 03		bpl $9dc0			bpl 	_EISNotSigned
.9dbd	20 ef 9d	jsr $9def			jsr 	NSMNegateMantissa 			; makes it an actual 2's complement value.
.9dc0					_EISNotSigned:
.9dc0	60		rts				rts
.9dc1					Evaluate8BitInteger:
.9dc1	20 9b 9d	jsr $9d9b			jsr	 	EvaluateUnsignedInteger 	; get an integer
.9dc4	d0 dd		bne $9da3			bne 	HelperValueError
.9dc6	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 1, 2 & 3 must be zero
.9dc8	15 68		ora $68,x			ora 	NSMantissa2,x
.9dca	15 60		ora $60,x			ora 	NSMantissa1,x
.9dcc	d0 d5		bne $9da3			bne 	HelperValueError
.9dce	b5 58		lda $58,x			lda 	NSMantissa0,x
.9dd0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/mult8x8.asm

.9dd1					Multiply8x8:
.9dd1	4a		lsr a		  		lsr 	a  							; prime the carry bit for the loop
.9dd2	85 36		sta $36			  	sta 	zTemp0
.9dd4	86 37		stx $37				stx 	zTemp0+1
.9dd6	a9 00		lda #$00			lda 	#0
.9dd8	a2 08		ldx #$08			ldx 	#8
.9dda					_M88Loop:
.9dda	90 03		bcc $9ddf			bcc 	_M88NoAdd
.9ddc	18		clc				clc
.9ddd	65 37		adc $37				adc 	zTemp0+1
.9ddf					_M88NoAdd:
.9ddf	6a		ror a				ror 	a
.9de0	66 36		ror $36				ror 	zTemp0  					; pull another bit out for the next iteration
.9de2	ca		dex				dex         						; inc/dec don't modify carry; only shifts and adds do
.9de3	d0 f5		bne $9dda			bne 	_M88Loop
.9de5	85 37		sta $37				sta 	zTemp0+1 					; store high 8 bits.
.9de7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/utility.asm

.9de8					NSMNegate:
.9de8	b5 50		lda $50,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.9dea	49 80		eor #$80			eor 	#NSBIsNegative  			; toggle the negative flag
.9dec	95 50		sta $50,x			sta 	NSStatus,x
.9dee	60		rts				rts
.9def					NSMNegateMantissa:
.9def	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.9df0	a9 00		lda #$00			lda 	#0
.9df2	f5 58		sbc $58,x			sbc 	NSMantissa0,x
.9df4	95 58		sta $58,x			sta 	NSMantissa0,x
.9df6	a9 00		lda #$00			lda 	#0
.9df8	f5 60		sbc $60,x			sbc 	NSMantissa1,x
.9dfa	95 60		sta $60,x			sta 	NSMantissa1,x
.9dfc	a9 00		lda #$00			lda 	#0
.9dfe	f5 68		sbc $68,x			sbc 	NSMantissa2,x
.9e00	95 68		sta $68,x			sta 	NSMantissa2,x
.9e02	a9 00		lda #$00			lda 	#0
.9e04	f5 70		sbc $70,x			sbc 	NSMantissa3,x
.9e06	95 70		sta $70,x			sta 	NSMantissa3,x
.9e08	60		rts				rts
.9e09					NSMShiftUpTwo:
.9e09	b5 58		lda $58,x			lda 	NSMantissa0,x
.9e0b	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9e0d	b5 60		lda $60,x			lda 	NSMantissa1,x
.9e0f	95 62		sta $62,x			sta 	NSMantissa1+2,x
.9e11	b5 68		lda $68,x			lda 	NSMantissa2,x
.9e13	95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.9e15	b5 70		lda $70,x			lda 	NSMantissa3,x
.9e17	95 72		sta $72,x			sta 	NSMantissa3+2,x
.9e19	b5 78		lda $78,x			lda 	NSExponent,x
.9e1b	95 7a		sta $7a,x			sta 	NSExponent+2,x
.9e1d	b5 50		lda $50,x			lda 	NSStatus,x
.9e1f	95 52		sta $52,x			sta 	NSStatus+2,x
.9e21	60		rts				rts
.9e22					NSMSetZeroMantissaOnly:
.9e22	a9 00		lda #$00			lda 	#0
.9e24	80 06		bra $9e2c			bra 	NSMSetMantissa
.9e26					NSMSetZero:
.9e26	a9 00		lda #$00			lda 	#0
.9e28					NSMSetByte:
.9e28	74 78		stz $78,x			stz 	NSExponent,x 				; zero exponent, as integer.
.9e2a	74 50		stz $50,x			stz 	NSStatus,x 					; status zero (integer)
.9e2c					NSMSetMantissa:
.9e2c	95 58		sta $58,x			sta 	NSMantissa0,x 				; mantissa
.9e2e	74 60		stz $60,x			stz 	NSMantissa1,x
.9e30	74 68		stz $68,x			stz 	NSMantissa2,x
.9e32	74 70		stz $70,x			stz 	NSMantissa3,x
.9e34	60		rts				rts
.9e35					NSMShiftLeft:
.9e35	18		clc				clc
.9e36					NSMRotateLeft:
.9e36	36 58		rol $58,x			rol 	NSMantissa0,x
.9e38	36 60		rol $60,x			rol		NSMantissa1,x
.9e3a	36 68		rol $68,x			rol		NSMantissa2,x
.9e3c	36 70		rol $70,x			rol		NSMantissa3,x
.9e3e	60		rts				rts
.9e3f					NSMShiftRight:
.9e3f	56 70		lsr $70,x			lsr 	NSMantissa3,x
.9e41	76 68		ror $68,x			ror		NSMantissa2,x
.9e43	76 60		ror $60,x			ror		NSMantissa1,x
.9e45	76 58		ror $58,x			ror		NSMantissa0,x
.9e47	60		rts				rts
.9e48					NSMIsZero:
.9e48	b5 70		lda $70,x			lda 	NSMantissa3,x
.9e4a	15 68		ora $68,x			ora		NSMantissa2,x
.9e4c	15 60		ora $60,x			ora		NSMantissa1,x
.9e4e	15 58		ora $58,x			ora		NSMantissa0,x
.9e50	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.asm

.9e51					TickHandler:
.9e51	5a		phy				phy 								; need to preserve Y
.9e52	20 1b 80	jsr $801b			jsr 	SNDUpdate 					; update sound
.9e55	7a		ply				ply
.9e56	60		rts				rts
.065b					LastTick:
>065b							.fill 		1

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/asmcore.asm

.9e57					Assemble_ora:
.9e57	20 72 80	jsr $8072		jsr	AssembleGroup1
>9e5a	01					.byte $01
.9e5b					Assemble_and:
.9e5b	20 72 80	jsr $8072		jsr	AssembleGroup1
>9e5e	21					.byte $21
.9e5f					Assemble_eor:
.9e5f	20 72 80	jsr $8072		jsr	AssembleGroup1
>9e62	41					.byte $41
.9e63					Assemble_adc:
.9e63	20 72 80	jsr $8072		jsr	AssembleGroup1
>9e66	61					.byte $61
.9e67					Assemble_sta:
.9e67	20 72 80	jsr $8072		jsr	AssembleGroup1
>9e6a	81					.byte $81
.9e6b					Assemble_lda:
.9e6b	20 72 80	jsr $8072		jsr	AssembleGroup1
>9e6e	a1					.byte $a1
.9e6f					Assemble_cmp:
.9e6f	20 72 80	jsr $8072		jsr	AssembleGroup1
>9e72	c1					.byte $c1
.9e73					Assemble_sbc:
.9e73	20 72 80	jsr $8072		jsr	AssembleGroup1
>9e76	e1					.byte $e1
.9e77					Assemble_asl:
.9e77	20 79 80	jsr $8079		jsr	AssembleGroup2
>9e7a	02					.byte $02
>9e7b	75					.byte $75
.9e7c					Assemble_rol:
.9e7c	20 79 80	jsr $8079		jsr	AssembleGroup2
>9e7f	22					.byte $22
>9e80	75					.byte $75
.9e81					Assemble_lsr:
.9e81	20 79 80	jsr $8079		jsr	AssembleGroup2
>9e84	42					.byte $42
>9e85	75					.byte $75
.9e86					Assemble_ror:
.9e86	20 79 80	jsr $8079		jsr	AssembleGroup2
>9e89	62					.byte $62
>9e8a	75					.byte $75
.9e8b					Assemble_stx:
.9e8b	20 79 80	jsr $8079		jsr	AssembleGroup2
>9e8e	82					.byte $82
>9e8f	50					.byte $50
.9e90					Assemble_ldx:
.9e90	20 79 80	jsr $8079		jsr	AssembleGroup2
>9e93	a2					.byte $a2
>9e94	d0					.byte $d0
.9e95					Assemble_dec:
.9e95	20 79 80	jsr $8079		jsr	AssembleGroup2
>9e98	c2					.byte $c2
>9e99	55					.byte $55
.9e9a					Assemble_inc:
.9e9a	20 79 80	jsr $8079		jsr	AssembleGroup2
>9e9d	e2					.byte $e2
>9e9e	55					.byte $55
.9e9f					Assemble_stz:
.9e9f	20 79 80	jsr $8079		jsr	AssembleGroup2
>9ea2	60					.byte $60
>9ea3	44					.byte $44
.9ea4					Assemble_bit:
.9ea4	20 79 80	jsr $8079		jsr	AssembleGroup2
>9ea7	20					.byte $20
>9ea8	55					.byte $55
.9ea9					Assemble_sty:
.9ea9	20 79 80	jsr $8079		jsr	AssembleGroup2
>9eac	80					.byte $80
>9ead	54					.byte $54
.9eae					Assemble_ldy:
.9eae	20 79 80	jsr $8079		jsr	AssembleGroup2
>9eb1	a0					.byte $a0
>9eb2	d5					.byte $d5
.9eb3					Assemble_cpy:
.9eb3	20 79 80	jsr $8079		jsr	AssembleGroup2
>9eb6	c0					.byte $c0
>9eb7	d4					.byte $d4
.9eb8					Assemble_cpx:
.9eb8	20 79 80	jsr $8079		jsr	AssembleGroup2
>9ebb	e0					.byte $e0
>9ebc	d0					.byte $d0
.9ebd					Assemble_tsb:
.9ebd	20 79 80	jsr $8079		jsr	AssembleGroup2
>9ec0	00					.byte $00
>9ec1	50					.byte $50
.9ec2					Assemble_trb:
.9ec2	20 79 80	jsr $8079		jsr	AssembleGroup2
>9ec5	10					.byte $10
>9ec6	50					.byte $50
.9ec7					Assemble_jsr:
.9ec7	20 79 80	jsr $8079		jsr	AssembleGroup2
>9eca	14					.byte $14
>9ecb	10					.byte $10
.9ecc					Assemble_jmp:
.9ecc	20 79 80	jsr $8079		jsr	AssembleGroup2
>9ecf	40					.byte $40
>9ed0	10					.byte $10
.9ed1					Assemble_bpl:
.9ed1	20 ca 80	jsr $80ca		jsr	AssembleGroup3
>9ed4	10					.byte $10
.9ed5					Assemble_bmi:
.9ed5	20 ca 80	jsr $80ca		jsr	AssembleGroup3
>9ed8	30					.byte $30
.9ed9					Assemble_bvc:
.9ed9	20 ca 80	jsr $80ca		jsr	AssembleGroup3
>9edc	50					.byte $50
.9edd					Assemble_bvs:
.9edd	20 ca 80	jsr $80ca		jsr	AssembleGroup3
>9ee0	70					.byte $70
.9ee1					Assemble_bcc:
.9ee1	20 ca 80	jsr $80ca		jsr	AssembleGroup3
>9ee4	90					.byte $90
.9ee5					Assemble_bcs:
.9ee5	20 ca 80	jsr $80ca		jsr	AssembleGroup3
>9ee8	b0					.byte $b0
.9ee9					Assemble_bne:
.9ee9	20 ca 80	jsr $80ca		jsr	AssembleGroup3
>9eec	d0					.byte $d0
.9eed					Assemble_beq:
.9eed	20 ca 80	jsr $80ca		jsr	AssembleGroup3
>9ef0	f0					.byte $f0
.9ef1					Assemble_bra:
.9ef1	20 ca 80	jsr $80ca		jsr	AssembleGroup3
>9ef4	80					.byte $80
.9ef5					Assemble_brk:
.9ef5	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9ef8	00					.byte $00
.9ef9					Assemble_php:
.9ef9	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9efc	08					.byte $08
.9efd					Assemble_clc:
.9efd	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f00	18					.byte $18
.9f01					Assemble_plp:
.9f01	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f04	28					.byte $28
.9f05					Assemble_sec:
.9f05	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f08	38					.byte $38
.9f09					Assemble_rti:
.9f09	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f0c	40					.byte $40
.9f0d					Assemble_pha:
.9f0d	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f10	48					.byte $48
.9f11					Assemble_cli:
.9f11	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f14	58					.byte $58
.9f15					Assemble_phy:
.9f15	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f18	5a					.byte $5a
.9f19					Assemble_rts:
.9f19	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f1c	60					.byte $60
.9f1d					Assemble_pla:
.9f1d	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f20	68					.byte $68
.9f21					Assemble_sei:
.9f21	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f24	78					.byte $78
.9f25					Assemble_ply:
.9f25	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f28	7a					.byte $7a
.9f29					Assemble_dey:
.9f29	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f2c	88					.byte $88
.9f2d					Assemble_txa:
.9f2d	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f30	8a					.byte $8a
.9f31					Assemble_tya:
.9f31	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f34	98					.byte $98
.9f35					Assemble_txs:
.9f35	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f38	9a					.byte $9a
.9f39					Assemble_tay:
.9f39	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f3c	a8					.byte $a8
.9f3d					Assemble_tax:
.9f3d	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f40	aa					.byte $aa
.9f41					Assemble_clv:
.9f41	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f44	b8					.byte $b8
.9f45					Assemble_tsx:
.9f45	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f48	ba					.byte $ba
.9f49					Assemble_iny:
.9f49	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f4c	c8					.byte $c8
.9f4d					Assemble_dex:
.9f4d	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f50	ca					.byte $ca
.9f51					Assemble_cld:
.9f51	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f54	d8					.byte $d8
.9f55					Assemble_phx:
.9f55	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f58	da					.byte $da
.9f59					Assemble_stp:
.9f59	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f5c	db					.byte $db
.9f5d					Assemble_inx:
.9f5d	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f60	e8					.byte $e8
.9f61					Assemble_nop:
.9f61	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f64	ea					.byte $ea
.9f65					Assemble_sed:
.9f65	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f68	f8					.byte $f8
.9f69					Assemble_plx:
.9f69	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f6c	fa					.byte $fa

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/constants.asm

.9f6d					DecimalScalarTable:
>9f6d	66 66 66 66				.dword $66666666 ; 0.1
>9f71	de					.byte $de
>9f72	1f 85 eb 51				.dword $51eb851f ; 0.01
>9f76	db					.byte $db
>9f77	4c 37 89 41				.dword $4189374c ; 0.001
>9f7b	d8					.byte $d8
>9f7c	ac 8b db 68				.dword $68db8bac ; 0.0001
>9f80	d4					.byte $d4
>9f81	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>9f85	d1					.byte $d1
>9f86	83 de 1b 43				.dword $431bde83 ; 1e-06
>9f8a	ce					.byte $ce
>9f8b	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>9f8f	ca					.byte $ca
>9f90	89 3b e6 55				.dword $55e63b89 ; 1e-08
>9f94	c7					.byte $c7
>9f95	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>9f99	c4					.byte $c4
>9f9a	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>9f9e	c0					.byte $c0
>9f9f	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>9fa3	bd					.byte $bd

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.asm

.9fa4					SyntaxError:
.9fa4	a9 02		lda #$02		lda	#2
.9fa6	4c 04 8f	jmp $8f04		jmp	ErrorHandler
.9fa9					RangeError:
.9fa9	a9 04		lda #$04		lda	#4
.9fab	4c 04 8f	jmp $8f04		jmp	ErrorHandler
.9fae					TypeError:
.9fae	a9 05		lda #$05		lda	#5
.9fb0	4c 04 8f	jmp $8f04		jmp	ErrorHandler
.9fb3					ArgumentError:
.9fb3	a9 07		lda #$07		lda	#7
.9fb5	4c 04 8f	jmp $8f04		jmp	ErrorHandler
.9fb8					NotDoneError:
.9fb8	a9 0c		lda #$0c		lda	#12
.9fba	4c 04 8f	jmp $8f04		jmp	ErrorHandler
.9fbd					ErrorText:
>9fbd	42 72 65 61 6b 00			.text	"Break",0
>9fc3	53 79 6e 74 61 78 20 65			.text	"Syntax error",0
>9fcb	72 72 6f 72 00
>9fd0	44 69 76 69 73 69 6f 6e			.text	"Division by zero",0
>9fd8	20 62 79 20 7a 65 72 6f 00
>9fe1	4f 75 74 20 6f 66 20 52			.text	"Out of Range",0
>9fe9	61 6e 67 65 00
>9fee	54 79 70 65 20 6d 69 73			.text	"Type mismatch",0
>9ff6	6d 61 74 63 68 00
>9ffc	4f 75 74 20 6f 66 20 6d			.text	"Out of memory",0
>a004	65 6d 6f 72 79 00
>a00a	49 6c 6c 65 67 61 6c 20			.text	"Illegal argument",0
>a012	61 72 67 75 6d 65 6e 74 00
>a01b	53 74 6f 70 00				.text	"Stop",0
>a020	53 74 72 69 6e 67 20 74			.text	"String too long",0
>a028	6f 6f 20 6c 6f 6e 67 00
>a030	41 73 73 65 72 74 69 6f			.text	"Assertion failed",0
>a038	6e 20 66 61 69 6c 65 64 00
>a041	4f 75 74 20 6f 66 20 64			.text	"Out of data",0
>a049	61 74 61 00
>a04d	55 6e 69 6d 70 6c 65 6d			.text	"Unimplemented",0
>a055	65 6e 74 65 64 00
>a05b	4e 6f 20 73 75 63 68 20			.text	"No such line number",0
>a063	6c 69 6e 65 20 6e 75 6d 62 65 72 00
>a06f	52 65 74 75 72 6e 20 77			.text	"Return without Gosub",0
>a077	69 74 68 6f 75 74 20 47 6f 73 75 62 00
>a084	55 6e 74 69 6c 20 77 69			.text	"Until without Repeat",0
>a08c	74 68 6f 75 74 20 52 65 70 65 61 74 00
>a099	57 65 6e 64 20 77 69 74			.text	"Wend without While",0
>a0a1	68 6f 75 74 20 57 68 69 6c 65 00
>a0ac	4e 65 78 74 20 77 69 74			.text	"Next without For",0
>a0b4	68 6f 75 74 20 46 6f 72 00
>a0bd	42 41 53 49 43 20 53 74			.text	"BASIC Stack full",0
>a0c5	61 63 6b 20 66 75 6c 6c 00
>a0ce	4f 70 65 6e 20 53 74 72			.text	"Open Structure",0
>a0d6	75 63 74 75 72 65 00
>a0dd	45 6e 64 50 72 6f 63 20			.text	"EndProc without call",0
>a0e5	77 69 74 68 6f 75 74 20 63 61 6c 6c 00
>a0f2	41 72 72 61 79 20 61 6c			.text	"Array already defined",0
>a0fa	72 65 61 64 79 20 64 65 66 69 6e 65 64 00
>a108	41 72 72 61 79 20 73 69			.text	"Array size",0
>a110	7a 65 00
>a113	42 61 64 20 61 72 72 61			.text	"Bad array index",0
>a11b	79 20 69 6e 64 65 78 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/timestamp.asm

>a123	52 65 6c 65 61 73 65 20			.text "Release Alpha 10 (02-Dec-22). "
>a12b	41 6c 70 68 61 20 31 30 20 28 30 32 2d 44 65 63
>a13b	2d 32 32 29 2e 20

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcommand.asm

.a141					RectangleCommand:
.a141	a9 44		lda #$44			lda 	#GCMD_FrameRect				; frame rectangle
.a143	80 02		bra $a147			bra 	ShapeDrawCmd
.a145					CircleCommand:
.a145	a9 48		lda #$48			lda 	#GCMD_FrameCircle 				; framed circle
.a147					ShapeDrawCmd:
.a147	20 d1 a1	jsr $a1d1			jsr 	RunGraphicsCommand
.a14a					ShapeDraw:
.a14a	0d 5d 06	ora $065d			ora 	gxFillSolid  				; adjust AXY for solid fill.
.a14d	4c c5 a1	jmp $a1c5			jmp 	ExecuteGraphicCommand	 	; and complete
.a150					SpriteCommand:
.a150	a2 00		ldx #$00			ldx 	#0
.a152	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger 		; get image number.
.a155	5a		phy				phy
.a156	a9 0e		lda #$0e			lda 	#GCMD_SpriteUse 			; use that image.
.a158	a6 58		ldx $58				ldx 	NSMantissa0
.a15a	e0 40		cpx #$40			cpx 	#64 						; 0-63 only
.a15c	b0 0d		bcs $a16b			bcs 	_SCRange
.a15e	a0 ff		ldy #$ff			ldy 	#255
.a160	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a163	a9 52		lda #$52			lda 	#GCMD_SpriteMove
.a165	7a		ply				ply
.a166	20 d1 a1	jsr $a1d1			jsr 	RunGraphicsCommand
.a169	80 5a		bra $a1c5			bra 	ExecuteGraphicCommand
.a16b					_SCRange:
.a16b	4c a9 9f	jmp $9fa9			jmp 	RangeError
.a16e					ImageCommand:
.a16e	a2 00		ldx #$00			ldx 	#0
.a170	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger 		; get image number.
.a173	20 d1 a1	jsr $a1d1			jsr 	RunGraphicsCommand
.a176					ImageRunDraw:
.a176	09 40		ora #$40			ora 	#GCMD_Move					; move cursor
.a178	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a17b	ad 63 06	lda $0663			lda 	gxDrawScale
.a17e	0a		asl a				asl 	a
.a17f	0a		asl a				asl 	a
.a180	0a		asl a				asl 	a
.a181	a8		tay				tay
.a182	a9 0c		lda #$0c			lda 	#GCMD_DrawSprite 			; image drawing
.a184	a6 58		ldx $58				ldx 	NSMantissa0
.a186	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a189	60		rts				rts
.a18a					TextCommand:
.a18a	a2 00		ldx #$00			ldx 	#0
.a18c	20 7e 9d	jsr $9d7e			jsr 	EvaluateString 				; get text
.a18f	20 d1 a1	jsr $a1d1			jsr 	RunGraphicsCommand
.a192					TextRunDraw:
.a192	09 40		ora #$40			ora 	#GCMD_Move 					; move cursor
.a194	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a197	a0 00		ldy #$00			ldy 	#0
.a199					_IRDLoop:
.a199	a5 60		lda $60				lda 	NSMantissa1 				; access character
.a19b	85 37		sta $37				sta 	zTemp0+1
.a19d	a5 58		lda $58				lda 	NSMantissa0
.a19f	85 36		sta $36				sta 	zTemp0
.a1a1	b1 36		lda ($36),y			lda 	(zTemp0),y
.a1a3	f0 13		beq $a1b8			beq 	_IRDExit
.a1a5	5a		phy				phy									; save string pos
.a1a6	48		pha				pha 								; save char
.a1a7	ad 63 06	lda $0663			lda 	gxDrawScale 				; get scale
.a1aa	0a		asl a				asl 	a
.a1ab	0a		asl a				asl 	a
.a1ac	0a		asl a				asl 	a
.a1ad	a8		tay				tay
.a1ae	a9 0a		lda #$0a			lda 	#GCMD_DrawFont 				; char drawing
.a1b0	fa		plx				plx 								; char to draw
.a1b1	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a1b4	7a		ply				ply 								; restore string pos
.a1b5	c8		iny				iny
.a1b6	90 e1		bcc $a199			bcc 	_IRDLoop 					; go back if no error.
.a1b8					_IRDExit:
.a1b8	60		rts				rts
.a1b9					PlotCommand:
.a1b9	a9 50		lda #$50			lda 	#GCMD_Plot 					; command ID to use
.a1bb	20 d1 a1	jsr $a1d1			jsr 	RunGraphicsCommand
.a1be	80 05		bra $a1c5			bra 	ExecuteGraphicCommand
.a1c0					LineCommand:
.a1c0	a9 42		lda #$42			lda 	#GCMD_Line 						; command ID to use
.a1c2	20 d1 a1	jsr $a1d1			jsr 	RunGraphicsCommand
.a1c5					ExecuteGraphicCommand:
.a1c5	0d 5c 06	ora $065c			ora 	gxCommandID 				; make a full command
.a1c8	20 15 80	jsr $8015			jsr 	GXGraphicDraw 				; draw it and exit
.a1cb	b0 01		bcs $a1ce			bcs 	_EGCError
.a1cd	60		rts				rts
.a1ce					_EGCError:
.a1ce	4c a4 9f	jmp $9fa4			jmp 	SyntaxError
.a1d1					RunGraphicsCommand:
.a1d1	8d 5c 06	sta $065c			sta 	gxCommandID					; save TODO graphics command.
.a1d4	68		pla				pla 								; pop handler address
.a1d5	fa		plx				plx
.a1d6	1a		inc a				inc 	a
.a1d7	d0 01		bne $a1da			bne 	_RGINoCarry
.a1d9	e8		inx				inx
.a1da					_RGINoCarry:
.a1da	8d 61 06	sta $0661			sta 	GXHandler
.a1dd	8e 62 06	stx $0662			stx 	GXHandler+1
.a1e0					_RGICommandLoop:
.a1e0	b1 30		lda ($30),y			lda 	(codePtr),y
.a1e2	c8		iny				iny
.a1e3	c9 d2		cmp #$d2			cmp 	#KWD_TO						; is it TO x,y
.a1e5	f0 53		beq $a23a			beq 	_RGI_To
.a1e7	c9 bd		cmp #$bd			cmp 	#KWD_HERE 					; do it here.
.a1e9	f0 55		beq $a240			beq 	_RGI_Here
.a1eb	c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL or : , exit
.a1ed	f0 3d		beq $a22c			beq 	_RGI_Exit
.a1ef	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.a1f1	f0 39		beq $a22c			beq 	_RGI_Exit
.a1f3	c9 c5		cmp #$c5			cmp 	#KWD_OUTLINE 				; solid or outline
.a1f5	f0 3e		beq $a235			beq 	_RGI_Frame
.a1f7	c9 ce		cmp #$ce			cmp 	#KWD_SOLID
.a1f9	f0 33		beq $a22e			beq 	_RGI_Solid
.a1fb	c9 ad		cmp #$ad			cmp 	#KWD_BY 					; by offset
.a1fd	f0 4b		beq $a24a			beq 	_RGI_By
.a1ff	c9 b9		cmp #$b9			cmp 	#KWD_FROM 					; from
.a201	f0 17		beq $a21a			beq 	_RGI_Move2
.a203	c9 b5		cmp #$b5			cmp 	#KWD_DIM 					; dim (set scale)
.a205	f0 62		beq $a269			beq 	_RGI_Dim
.a207	c9 b3		cmp #$b3			cmp 	#KWD_COLOUR 				; colour or Color
.a209	f0 74		beq $a27f			beq 	_RGI_Colour
.a20b	c9 b2		cmp #$b2			cmp 	#KWD_COLOR
.a20d	f0 70		beq $a27f			beq 	_RGI_Colour
.a20f	ae 5c 06	ldx $065c			ldx 	gxCommandID
.a212	e0 52		cpx #$52			cpx 	#GCMD_SpriteMove 			; if not sprite
.a214	d0 03		bne $a219			bne 	_RGI_Move 					; move
.a216	4c a7 a2	jmp $a2a7			jmp		_RGI_SpriteInstructions
.a219					_RGI_Move:
.a219	88		dey				dey 								; unpick get.
.a21a					_RGI_Move2:
.a21a	20 cd a2	jsr $a2cd			jsr 	GCGetCoordinatePair 		; move to here
.a21d	20 f4 a2	jsr $a2f4			jsr 	GCCopyPairToStore 			; save
.a220	5a		phy				phy
.a221	20 ea a2	jsr $a2ea			jsr 	GCLoadAXY 					; load in
.a224	09 40		ora #$40			ora 	#GCMD_Move 					; move there
.a226	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a229	7a		ply				ply
.a22a	80 b4		bra $a1e0			bra 	_RGICommandLoop 			; and go round
.a22c					_RGI_Exit:
.a22c	88		dey				dey 								; unpick : / EOL
.a22d	60		rts				rts
.a22e					_RGI_Solid:
.a22e	a9 02		lda #$02			lda 	#2
.a230	8d 5d 06	sta $065d			sta 	gxFillSolid
.a233	80 ab		bra $a1e0			bra 	_RGICommandLoop
.a235					_RGI_Frame:
.a235	9c 5d 06	stz $065d			stz 	gxFillSolid
.a238	80 a6		bra $a1e0			bra 	_RGICommandLoop
.a23a					_RGI_To:
.a23a	20 cd a2	jsr $a2cd			jsr 	GCGetCoordinatePair 		; get coordinate pair into slot #1,#2
.a23d	20 f4 a2	jsr $a2f4			jsr 	GCCopyPairToStore
.a240					_RGI_Here:
.a240	5a		phy				phy
.a241	20 ea a2	jsr $a2ea			jsr 	GCLoadAXY 					; load it into AXY
.a244	20 a4 a2	jsr $a2a4			jsr 	_RGICallHandler 			; go do whatever it is.
.a247	7a		ply				ply
.a248	80 96		bra $a1e0			bra 	_RGICommandLoop 			; and go round
.a24a					_RGI_By:
.a24a	20 da a2	jsr $a2da			jsr 	GCSignedCoordinatePair 		; get coordinate pair into slot #1,#2
.a24d	18		clc				clc
.a24e	a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.a250	6d 5e 06	adc $065e			adc 	gxxPos
.a253	8d 5e 06	sta $065e			sta 	gxXPos
.a256	a5 61		lda $61				lda 	NSMantissa1+1
.a258	6d 5f 06	adc $065f			adc 	gxxPos+1
.a25b	8d 5f 06	sta $065f			sta 	gxXPos+1
.a25e	a5 5a		lda $5a				lda 	NSMantissa0+2
.a260	18		clc				clc
.a261	6d 60 06	adc $0660			adc 	gxYPos
.a264	8d 60 06	sta $0660			sta 	gxYPos
.a267	80 d7		bra $a240			bra 	_RGI_Here
.a269					_RGI_Dim:
.a269	a2 01		ldx #$01			ldx	 	#1
.a26b	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger
.a26e	a5 59		lda $59				lda 	NSMantissa0+1
.a270	c9 00		cmp #$00			cmp 	#0
.a272	f0 2d		beq $a2a1			beq 	_RGIRange
.a274	c9 09		cmp #$09			cmp 	#8+1
.a276	b0 29		bcs $a2a1			bcs		_RGIRange
.a278	3a		dec a				dec 	a
.a279	8d 63 06	sta $0663			sta 	gxDrawScale
.a27c	4c e0 a1	jmp $a1e0			jmp 	_RGICommandLoop
.a27f					_RGI_Colour:
.a27f	a2 01		ldx #$01			ldx 	#1 							; colour
.a281	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger
.a284	a2 02		ldx #$02			ldx 	#2 							; default zero for 2nd parameter
.a286	20 26 9e	jsr $9e26			jsr 	NSMSetZero
.a289	b1 30		lda ($30),y			lda 	(codePtr),y
.a28b	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; check , => mode.
.a28d	d0 04		bne $a293			bne 	_RGICDefaultMode
.a28f	c8		iny				iny
.a290	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger
.a293					_RGICDefaultMode:
.a293	5a		phy				phy
.a294	a9 08		lda #$08			lda 	#GCMD_Colour 				; set colour.
.a296	a6 59		ldx $59				ldx 	NSMantissa0+1
.a298	a4 5a		ldy $5a				ldy 	NSMantissa0+2
.a29a	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a29d	7a		ply				ply
.a29e	4c e0 a1	jmp $a1e0			jmp 	_RGICommandLoop 			; and go round
.a2a1					_RGIRange:
.a2a1	4c a9 9f	jmp $9fa9			jmp 	RangeError
.a2a4					_RGICallHandler:
.a2a4	6c 61 06	jmp ($0661)			jmp 	(GXHandler)
.a2a7					_RGI_SpriteInstructions:
.a2a7	c9 c3		cmp #$c3			cmp 	#KWD_OFF
.a2a9	f0 07		beq $a2b2			beq 	_RGISpriteOff
.a2ab	c9 be		cmp #$be			cmp 	#KWD_IMAGE
.a2ad	f0 13		beq $a2c2			beq 	_RGISetImage
.a2af	4c 19 a2	jmp $a219			jmp 	_RGI_Move
.a2b2					_RGISpriteOff:
.a2b2	5a		phy				phy
.a2b3	a0 01		ldy #$01			ldy 	#1
.a2b5	a2 00		ldx #$00			ldx 	#0
.a2b7					_RGIDoCommandLoop:
.a2b7	a9 10		lda #$10			lda 	#GCMD_SpriteImage
.a2b9	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a2bc	7a		ply				ply
.a2bd	b0 e2		bcs $a2a1			bcs 	_RGIRange
.a2bf	4c e0 a1	jmp $a1e0			jmp 	_RGICommandLoop
.a2c2					_RGISetImage:
.a2c2	a2 01		ldx #$01			ldx 	#1
.a2c4	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger
.a2c7	5a		phy				phy
.a2c8	aa		tax				tax
.a2c9	a0 00		ldy #$00			ldy 	#0
.a2cb	80 ea		bra $a2b7			bra 	_RGIDoCommandLoop
.a2cd					GCGetCoordinatePair:
.a2cd	a2 01		ldx #$01			ldx 	#1
.a2cf	20 a6 9d	jsr $9da6			jsr 	Evaluate16BitInteger
.a2d2	20 f3 8e	jsr $8ef3			jsr 	CheckComma
.a2d5	e8		inx				inx
.a2d6	20 a6 9d	jsr $9da6			jsr 	Evaluate16BitInteger
.a2d9	60		rts				rts
.a2da					GCSignedCoordinatePair:
.a2da	a2 01		ldx #$01			ldx 	#1
.a2dc	20 b0 9d	jsr $9db0			jsr 	Evaluate16BitIntegerSigned
.a2df	20 f3 8e	jsr $8ef3			jsr 	CheckComma
.a2e2	e8		inx				inx
.a2e3	20 b0 9d	jsr $9db0			jsr 	Evaluate16BitIntegerSigned
.a2e6	60		rts				rts
.a2e7					_GCCPRange:
.a2e7	4c a9 9f	jmp $9fa9			jmp 	RangeError
.a2ea					GCLoadAXY:
.a2ea	ad 5f 06	lda $065f			lda 	gxXPos+1
.a2ed	ae 5e 06	ldx $065e			ldx 	gxXPos
.a2f0	ac 60 06	ldy $0660			ldy 	gxYPos
.a2f3	60		rts				rts
.a2f4					GCCopyPairToStore:
.a2f4	a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.a2f6	8d 5e 06	sta $065e			sta 	gxXPos
.a2f9	a5 61		lda $61				lda 	NSMantissa1+1
.a2fb	8d 5f 06	sta $065f			sta 	gxXPos+1
.a2fe	a5 5a		lda $5a				lda 	NSMantissa0+2
.a300	8d 60 06	sta $0660			sta 	gxYPos
.a303	60		rts				rts
.065c					gxCommandID:
>065c							.fill 	1
.065d					gxFillSolid:
>065d							.fill 	1
.065e					gxXPos:
>065e							.fill 	2
.0660					gxYPos:
>0660							.fill 	1
.0661					gxHandler:
>0661							.fill 	2
.0663					gxDrawScale:
>0663							.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcontrol.asm

.a304					BitmapCtrl:
.a304	b1 30		lda ($30),y			lda 	(codePtr),y
.a306	c8		iny				iny
.a307	a2 01		ldx #$01			ldx 	#1
.a309	c9 c4		cmp #$c4			cmp 	#KWD_ON
.a30b	f0 11		beq $a31e			beq 	BitmapSwitch
.a30d	ca		dex				dex
.a30e	c9 c3		cmp #$c3			cmp 	#KWD_OFF
.a310	f0 0c		beq $a31e			beq 	BitmapSwitch
.a312	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger 		; get the colour
.a315	5a		phy				phy
.a316	aa		tax				tax
.a317	a9 06		lda #$06			lda 	#GCMD_Clear					; clear to that colour
.a319	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a31c	7a		ply				ply
.a31d	60		rts				rts
.a31e					BitmapSwitch:
.a31e	5a		phy				phy
.a31f	a0 00		ldy #$00			ldy 	#0 							; gfx 1,on/off,0
.a321	a9 02		lda #$02			lda 	#GCMD_BitmapCtl
.a323	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a326	a9 08		lda #$08			lda 	#GCMD_Colour				; set colour to $FF
.a328	a0 00		ldy #$00			ldy 	#0
.a32a	a2 ff		ldx #$ff			ldx 	#$FF
.a32c	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a32f	9c 5d 06	stz $065d			stz 	gxFillSolid
.a332	9c 5e 06	stz $065e			stz 	gxXPos
.a335	9c 5f 06	stz $065f			stz 	gxXPos+1
.a338	9c 60 06	stz $0660			stz 	gxYPos
.a33b	9c 63 06	stz $0663			stz 	gxDrawScale
.a33e	a9 40		lda #$40			lda 	#GCMD_Move 						; home cursor
.a340	a2 00		ldx #$00			ldx 	#0
.a342	a0 00		ldy #$00			ldy 	#0
.a344	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a347	7a		ply				ply
.a348	60		rts				rts
.a349					SpritesCtrl:
.a349	b1 30		lda ($30),y			lda 	(codePtr),y
.a34b	c8		iny				iny
.a34c	a2 01		ldx #$01			ldx 	#1
.a34e	c9 c4		cmp #$c4			cmp 	#KWD_ON
.a350	f0 08		beq $a35a			beq 	SpriteSwitch
.a352	ca		dex				dex
.a353	c9 c3		cmp #$c3			cmp 	#KWD_OFF
.a355	f0 03		beq $a35a			beq 	SpriteSwitch
.a357	4c a4 9f	jmp $9fa4			jmp 	SyntaxError
.a35a					SpriteSwitch:
.a35a	5a		phy				phy
.a35b	a0 00		ldy #$00			ldy 	#0 							; gfx 2,on/off,0
.a35d	a9 04		lda #$04			lda 	#GCMD_SpriteCtl
.a35f	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a362	7a		ply				ply
.a363	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gfx.asm

.a364					GfxCommand:
.a364	a2 00		ldx #$00			ldx 	#0
.a366	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger 		; command
.a369	20 f3 8e	jsr $8ef3			jsr 	CheckComma
.a36c	e8		inx				inx
.a36d	20 a6 9d	jsr $9da6			jsr 	Evaluate16BitInteger 		; X
.a370	20 f3 8e	jsr $8ef3			jsr 	CheckComma
.a373	e8		inx				inx
.a374	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger 		; Y
.a377	a5 61		lda $61				lda 	NSMantissa1+1  				; shift bit 0 of X into CS, should now be zero
.a379	4a		lsr a				lsr 	a
.a37a	d0 12		bne $a38e			bne 	_GfxError
.a37c	26 58		rol $58				rol 	NSMantissa0 				; rotate into command
.a37e	b0 0e		bcs $a38e			bcs 	_GfxError 					; bit 7 should have been zero
.a380	5a		phy				phy 								; save pos
.a381	a5 58		lda $58				lda 	NSMantissa0 				; do the command
.a383	a6 59		ldx $59				ldx 	NSMantissa0+1
.a385	a4 5a		ldy $5a				ldy 	NSMantissa0+2
.a387	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a38a	b0 02		bcs $a38e			bcs 	_GfxError
.a38c	7a		ply				ply 								; restore pos and exit.
.a38d	60		rts				rts
.a38e					_GfxError:
.a38e	4c a9 9f	jmp $9fa9			jmp 	RangeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/hit.asm

.a391					UnaryHit:
.a391	fa		plx				plx
.a392	a9 36		lda #$36			lda 	#zTemp0
.a394	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger 		; get sprite number 0
.a397	20 f3 8e	jsr $8ef3			jsr 	CheckComma
.a39a	e8		inx				inx
.a39b	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger 		; get sprite number 1
.a39e	20 eb 8e	jsr $8eeb			jsr		CheckRightBracket
.a3a1	ca		dex				dex 								; fix back up again.
.a3a2	da		phx				phx 								; save X/Y
.a3a3	5a		phy				phy
.a3a4	b4 59		ldy $59,x			ldy 	NSMantissa0+1,x 			; get the sprite numbers into X/Y
.a3a6	b5 58		lda $58,x			lda 	NSMantissa0,x
.a3a8	aa		tax				tax
.a3a9	a9 12		lda #$12			lda 	#GCMD_SpriteCollide 		; command check collision.
.a3ab	20 15 80	jsr $8015			jsr 	GXGraphicDraw 				; calculate result
.a3ae	1a		inc a				inc 	a 							; so 255 (fail) -> 0, otherwise 1,2,3,4 pixels etc.
.a3af	7a		ply				ply 								; restore XY
.a3b0	fa		plx				plx
.a3b1	20 28 9e	jsr $9e28			jsr 	NSMSetByte 					; return the hit result
.a3b4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/palette.asm

.a3b5					PaletteCommand:
.a3b5	a2 00		ldx #$00			ldx 	#0
.a3b7	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger 		; colour
.a3ba	20 f3 8e	jsr $8ef3			jsr 	CheckComma
.a3bd	e8		inx				inx
.a3be	20 a6 9d	jsr $9da6			jsr 	Evaluate16BitInteger 		; r
.a3c1	20 f3 8e	jsr $8ef3			jsr 	CheckComma
.a3c4	e8		inx				inx
.a3c5	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger 		; g
.a3c8	20 f3 8e	jsr $8ef3			jsr 	CheckComma
.a3cb	e8		inx				inx
.a3cc	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger 		; b
.a3cf	a5 58		lda $58				lda 	NSMantissa0 				; get colour #
.a3d1	85 36		sta $36				sta 	zTemp0
.a3d3	a9 34		lda #$34			lda 	#$D0 >> 2 					; MSB = D0/4
.a3d5	85 37		sta $37				sta 	zTemp0+1
.a3d7	06 36		asl $36				asl 	zTemp0 						; zTemp = $D000+Colour x 4
.a3d9	26 37		rol $37				rol	 	zTemp0+1
.a3db	06 36		asl $36				asl 	zTemp0
.a3dd	26 37		rol $37				rol	 	zTemp0+1
.a3df	a9 01		lda #$01			lda 	#1 							; I/O Page 2
.a3e1	85 01		sta $01				sta 	1
.a3e3	5a		phy				phy
.a3e4	a5 5b		lda $5b				lda 	NSMantissa0+3 				; fix to r,g,b
.a3e6	92 36		sta ($36)			sta 	(zTemp0)
.a3e8	a0 01		ldy #$01			ldy 	#1
.a3ea	a5 5a		lda $5a				lda 	NSMantissa0+2
.a3ec	91 36		sta ($36),y			sta 	(zTemp0),y
.a3ee	a5 59		lda $59				lda 	NSMantissa0+1
.a3f0	c8		iny				iny
.a3f1	91 36		sta ($36),y			sta 	(zTemp0),y
.a3f3	7a		ply				ply
.a3f4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/event.asm

.a3f5					UnaryEvent:
.a3f5	fa		plx				plx
.a3f6	20 a3 a4	jsr $a4a3			jsr 	TimerToStackX 				; timer in +0
.a3f9	e8		inx				inx  								; put reference into +1
.a3fa	20 52 98	jsr $9852			jsr 	EvaluateTerm
.a3fd	b5 50		lda $50,x			lda 	NSStatus,x 					; check if is integer reference
.a3ff	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.a401	d0 4c		bne $a44f			bne 	_UEType
.a403	e8		inx				inx 								; put the step in +2
.a404	20 f3 8e	jsr $8ef3			jsr 	CheckComma
.a407	20 a6 9d	jsr $9da6			jsr 	Evaluate16BitInteger
.a40a	20 eb 8e	jsr $8eeb			jsr 	CheckRightBracket
.a40d	ca		dex				dex
.a40e	ca		dex				dex
.a40f	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy reference to zTemp0
.a411	85 36		sta $36				sta 	zTemp0
.a413	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.a415	85 37		sta $37				sta 	zTemp0+1
.a417	5a		phy				phy
.a418	a0 03		ldy #$03			ldy 	#3 							; check bit 7 of last bit, the packed sign bit
.a41a	b1 36		lda ($36),y			lda 	(zTemp0),y
.a41c	30 2d		bmi $a44b			bmi 	_UEFalse 					; exit if signed.
.a41e	a0 00		ldy #$00			ldy 	#0 							; has it timed out (24 bit)
.a420	b5 58		lda $58,x			lda 	NSMantissa0,x
.a422	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.a424	c8		iny				iny
.a425	b5 60		lda $60,x			lda 	NSMantissa1,x
.a427	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a429	c8		iny				iny
.a42a	b5 68		lda $68,x			lda 	NSMantissa2,x
.a42c	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a42e	90 1b		bcc $a44b			bcc 	_UEFalse 					; no, return FALSE.
.a430	18		clc				clc
.a431	a0 00		ldy #$00			ldy 	#0 							; work out new value as timer() + step
.a433	b5 58		lda $58,x			lda 	NSMantissa0,x
.a435	75 5a		adc $5a,x			adc 	NSMantissa0+2,x
.a437	91 36		sta ($36),y			sta 	(zTemp0),y
.a439	c8		iny				iny
.a43a	b5 60		lda $60,x			lda 	NSMantissa1,x
.a43c	75 62		adc $62,x			adc 	NSMantissa1+2,x
.a43e	91 36		sta ($36),y			sta 	(zTemp0),y
.a440	c8		iny				iny
.a441	b5 68		lda $68,x			lda 	NSMantissa2,x
.a443	75 6a		adc $6a,x			adc 	NSMantissa2+2,x
.a445	91 36		sta ($36),y			sta 	(zTemp0),y
.a447	7a		ply				ply
.a448	4c 71 8f	jmp $8f71			jmp 	ReturnTrue
.a44b					_UEFalse:
.a44b	7a		ply				ply 								; restore Y
.a44c	4c 7c 8f	jmp $8f7c			jmp 	ReturnFalse 				; and return False
.a44f					_UEType:
.a44f	4c ae 9f	jmp $9fae			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/joy.asm

.a452					UnaryJoyX:
.a452	18		clc				clc
.a453	80 01		bra $a456			bra 	JoyMain
.a455					UnaryJoyY:
.a455	38		sec				sec
.a456					JoyMain:
.a456	fa		plx				plx 								; get pos
.a457	08		php				php 								; save carry (set for Y)
.a458	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a45b	20 eb 8e	jsr $8eeb			jsr 	CheckRightBracket
.a45e	20 0f 80	jsr $800f			jsr 	EXTReadController 			; read the controller.
.a461	28		plp				plp
.a462	90 02		bcc $a466			bcc 	_JMNoShift 					; if Y then shift bits 3,2 -> 1,0
.a464	4a		lsr a				lsr 	a
.a465	4a		lsr a				lsr 	a
.a466					_JMNoShift:
.a466	4a		lsr a				lsr 	a 							; if bit 0 set then right/down e.g. +1
.a467	b0 0a		bcs $a473			bcs 	_JMIsRight
.a469	4a		lsr a				lsr 	a 							; if bit 1 set then left/up e.g. -1
.a46a	b0 04		bcs $a470			bcs 	_JMIsLeft
.a46c	20 26 9e	jsr $9e26			jsr 	NSMSetZero 					; zero result
.a46f	60		rts				rts
.a470					_JMIsLeft:
.a470	4c 71 8f	jmp $8f71			jmp 	ReturnTrue
.a473					_JMIsRight:
.a473	a9 01		lda #$01			lda 	#1
.a475	20 28 9e	jsr $9e28			jsr 	NSMSetByte
.a478	60		rts				rts
.a479					UnaryJoyB:
.a479	fa		plx				plx 								; get pos
.a47a	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a47d	20 eb 8e	jsr $8eeb			jsr 	CheckRightBracket
.a480	20 0f 80	jsr $800f			jsr 	EXTReadController 			; read the controller.
.a483	4a		lsr a				lsr 	a
.a484	4a		lsr a				lsr 	a
.a485	4a		lsr a				lsr 	a
.a486	4a		lsr a				lsr 	a
.a487	29 01		and #$01			and 	#1
.a489	20 28 9e	jsr $9e28			jsr 	NSMSetByte
.a48c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/load.asm

.a48d					LoadCommand:
.a48d	20 d5 89	jsr $89d5			jsr 	NewProgram
.a490	20 e1 82	jsr $82e1			jsr 	BackLoadProgram
.a493	4c 83 83	jmp $8383			jmp 	WarmStart
.a496					GoCommand:
.a496	20 d5 89	jsr $89d5			jsr 	NewProgram
.a499	20 e1 82	jsr $82e1			jsr 	BackLoadProgram
.a49c	4c 16 8b	jmp $8b16			jmp 	CommandRun

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/timer.asm

.a49f					UnaryTimer:
.a49f	fa		plx				plx
.a4a0	20 eb 8e	jsr $8eeb			jsr 	CheckRightBracket
.a4a3					TimerToStackX:
.a4a3	20 26 9e	jsr $9e26			jsr 	NSMSetZero 					; zero result
.a4a6	64 01		stz $01				stz 	1 							; access I/O
.a4a8	ad 59 d6	lda $d659			lda 	$D659 						; copy timer in
.a4ab	95 58		sta $58,x			sta 	NSMantissa0,x
.a4ad	ad 5a d6	lda $d65a			lda 	$D65A
.a4b0	95 60		sta $60,x			sta 	NSMantissa1,x
.a4b2	ad 5b d6	lda $d65b			lda 	$D65B
.a4b5	95 68		sta $68,x			sta 	NSMantissa2,x
.a4b7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/delete.asm

.a4b8					MemoryDeleteLine:
.a4b8	20 d7 a4	jsr $a4d7			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a4bb	b2 30		lda ($30)			lda 	(codePtr) 					; size to delete => y
.a4bd	a8		tay				tay
.a4be					_MDDLLoop:
.a4be	b1 30		lda ($30),y			lda 	(codePtr),y 				; copy down
.a4c0	92 30		sta ($30)			sta 	(codePtr)
.a4c2	a5 30		lda $30				lda 	codePtr 					; check done the lot.
.a4c4	c5 3a		cmp $3a				cmp 	zTemp2
.a4c6	d0 07		bne $a4cf			bne 	_MDLDLNext
.a4c8	a5 31		lda $31				lda 	codePtr+1
.a4ca	c5 3b		cmp $3b				cmp 	zTemp2+1
.a4cc	d0 01		bne $a4cf			bne 	_MDLDLNext
.a4ce					_MDDLExit:
.a4ce	60		rts				rts
.a4cf					_MDLDLNext:
.a4cf	e6 30		inc $30				inc 	codePtr						; next byte
.a4d1	d0 eb		bne $a4be			bne 	_MDDLLoop
.a4d3	e6 31		inc $31				inc 	codePtr+1
.a4d5	80 e7		bra $a4be			bra 	_MDDLLoop
.a4d7					IMemoryFindEnd:
.a4d7	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a4d9	85 3a		sta $3a				sta 	0+zTemp2
.a4db	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a4dd	85 3b		sta $3b				sta 	1+zTemp2
.a4df					_MDLFELoop:
.a4df	b2 3a		lda ($3a)			lda 	(zTemp2)
.a4e1	f0 0b		beq $a4ee			beq 	_MDLFEExit
.a4e3	18		clc				clc
.a4e4	65 3a		adc $3a				adc 	zTemp2
.a4e6	85 3a		sta $3a				sta 	zTemp2
.a4e8	90 f5		bcc $a4df			bcc 	_MDLFELoop
.a4ea	e6 3b		inc $3b				inc 	zTemp2+1
.a4ec	80 f1		bra $a4df			bra 	_MDLFELoop
.a4ee					_MDLFEExit:
.a4ee	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/insert.asm

.a4ef					MemoryInsertLine:
.a4ef	08		php				php
.a4f0	20 d7 a4	jsr $a4d7			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a4f3	a5 3b		lda $3b				lda 	zTemp2+1 					; space ?
.a4f5	1a		inc a				inc 	a
.a4f6	c9 7f		cmp #$7f			cmp 	#(BasicEnd >> 8)-1
.a4f8	b0 36		bcs $a530			bcs 	_MDLIError
.a4fa	28		plp				plp
.a4fb	90 08		bcc $a505			bcc 	_MDLIFound
.a4fd	a5 3a		lda $3a				lda 	zTemp2 						; if CS on entry append.
.a4ff	85 30		sta $30				sta 	codePtr
.a501	a5 3b		lda $3b				lda 	zTemp2+1
.a503	85 31		sta $31				sta 	codePtr+1
.a505					_MDLIFound:
.a505	ad 2a 04	lda $042a			lda 	tokenOffset 				; insert gap in Y, the offset, e.g. length of the new line
.a508	a8		tay				tay
.a509					_MDLIInsert:
.a509	b2 3a		lda ($3a)			lda 	(zTemp2) 					; shift one byte up , at least one covers end case.
.a50b	91 3a		sta ($3a),y			sta 	(zTemp2),y 					; work from top down.
.a50d	a5 30		lda $30				lda 	codePtr 					; done insert point ?
.a50f	c5 3a		cmp $3a				cmp 	zTemp2
.a511	d0 06		bne $a519			bne 	_MDLINext
.a513	a5 31		lda $31				lda 	codePtr+1
.a515	c5 3b		cmp $3b				cmp 	zTemp2+1
.a517	f0 0a		beq $a523			beq 	_MDLIHaveSpace
.a519					_MDLINext:
.a519	a5 3a		lda $3a				lda 	zTemp2 						; if no, keep zTemp2 going backwards
.a51b	d0 02		bne $a51f			bne 	_MDLINoBorrow
.a51d	c6 3b		dec $3b				dec 	zTemp2+1
.a51f					_MDLINoBorrow:
.a51f	c6 3a		dec $3a				dec 	zTemp2
.a521	80 e6		bra $a509			bra 	_MDLIInsert
.a523					_MDLIHaveSpace:
.a523	ac 2a 04	ldy $042a			ldy 	tokenOffset 				; bytes to copy
.a526	88		dey				dey 								; from offset-1 to 0
.a527					_MDLICopy:
.a527	b9 2a 04	lda $042a,y			lda 	tokenOffset,y
.a52a	91 30		sta ($30),y			sta 	(codePtr),y
.a52c	88		dey				dey
.a52d	10 f8		bpl $a527			bpl 	_MDLICopy
.a52f	60		rts				rts
.a530					_MDLIError:
.a530	a9 06		lda #$06		lda	#6
.a532	4c 04 8f	jmp $8f04		jmp	ErrorHandler
.a535					MDLAppendLine:
.a535	86 37		stx $37				stx 	zTemp0+1 					; save new line at zTemp0
.a537	85 36		sta $36				sta 	zTemp0
.a539	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a53b	85 38		sta $38				sta 	0+zTemp1
.a53d	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a53f	85 39		sta $39				sta 	1+zTemp1
.a541	b2 38		lda ($38)			lda 	(zTemp1)
.a543	d0 0a		bne $a54f			bne 	_MDLANoInitialise
.a545	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a547	8d 64 06	sta $0664			sta 	0+AppendPointer
.a54a	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a54c	8d 65 06	sta $0665			sta 	1+AppendPointer
.a54f					_MDLANoInitialise:
.a54f	18		clc				clc
.a550	ad 64 06	lda $0664			lda 	AppendPointer 				; copy append pointer to zTemp1 adding the offset as you go
.a553	85 38		sta $38				sta 	zTemp1
.a555	72 36		adc ($36)			adc 	(zTemp0)
.a557	8d 64 06	sta $0664			sta 	AppendPointer
.a55a	ad 65 06	lda $0665			lda 	AppendPointer+1
.a55d	85 39		sta $39				sta 	zTemp1+1
.a55f	69 00		adc #$00			adc 	#0
.a561	8d 65 06	sta $0665			sta 	AppendPointer+1
.a564	a0 00		ldy #$00			ldy 	#0
.a566					_MDLACopy:
.a566	b1 36		lda ($36),y			lda 	(zTemp0),y 					; copy new line in
.a568	91 38		sta ($38),y			sta 	(zTemp1),y
.a56a	c8		iny				iny
.a56b	98		tya				tya
.a56c	d2 36		cmp ($36)			cmp 	(zTemp0) 					; done whole line
.a56e	d0 f6		bne $a566			bne 	_MDLACopy
.a570	a9 00		lda #$00			lda 	#0 							; end of program.
.a572	91 38		sta ($38),y			sta 	(zTemp1),y
.a574	60		rts				rts
.0664					AppendPointer:
>0664							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/memory.asm

.a575					MemoryNew:
.a575	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a577	85 30		sta $30				sta 	codePtr
.a579	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a57b	85 31		sta $31				sta 	codePtr+1
.a57d	a9 00		lda #$00			lda 	#0 							; write zero there erasing the program.
.a57f	92 30		sta ($30)			sta 	(codePtr)
.a581	60		rts				rts
.a582					MemoryInline:
.a582	98		tya				tya 								; put address into stack,x
.a583	18		clc				clc  								; get the offset, add codePtr
.a584	65 30		adc $30				adc 	codePtr
.a586	95 58		sta $58,x			sta 	NSMantissa0,x 				; store the result in the mantissa.
.a588	a5 31		lda $31				lda 	codePtr+1
.a58a	69 00		adc #$00			adc 	#0
.a58c	95 60		sta $60,x			sta 	NSMantissa1,x
.a58e	74 68		stz $68,x			stz 	NSMantissa2,x
.a590	74 70		stz $70,x			stz 	NSMantissa3,x
.a592	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/search.asm

.a593					MemorySearch:
.a593	85 36		sta $36				sta 	zTemp0 						; save line number in zTemp0
.a595	86 37		stx $37				stx 	zTemp0+1
.a597	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a599	85 30		sta $30				sta 	codePtr
.a59b	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a59d	85 31		sta $31				sta 	codePtr+1
.a59f					_MTAXLoop:
.a59f	b2 30		lda ($30)			lda 	(codePtr)
.a5a1	18		clc				clc
.a5a2	f0 21		beq $a5c5			beq 	_MTAXExit 					; reached end, exit with CC.
.a5a4	a0 01		ldy #$01			ldy 	#1 							; calculate current line# - requested line#
.a5a6	b1 30		lda ($30),y			lda 	(codePtr),y
.a5a8	38		sec				sec
.a5a9	e5 36		sbc $36				sbc 	zTemp0
.a5ab	85 38		sta $38				sta 	zTemp1 						; save interim to set Z
.a5ad	c8		iny				iny 								; do the MSB
.a5ae	b1 30		lda ($30),y			lda 	(codePtr),y
.a5b0	e5 37		sbc $37				sbc 	zTemp0+1
.a5b2	05 38		ora $38				ora 	zTemp1 						; will set Z if result is zero, doesn't affect carry flag
.a5b4	f0 0f		beq $a5c5			beq 	_MTAXExit	 				; found so exit (CS will be set)
.a5b6	b0 0d		bcs $a5c5			bcs 	_MTAXExit 					; current < required exit
.a5b8	18		clc				clc
.a5b9	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.a5bb	65 30		adc $30				adc 	codePtr
.a5bd	85 30		sta $30				sta 	codePtr
.a5bf	90 02		bcc $a5c3			bcc 	_CREExit
.a5c1	e6 31		inc $31				inc 	codePtr+1 					; carry
.a5c3					_CREExit:
.a5c3	80 da		bra $a59f			bra 	_MTAXLoop
.a5c5					_MTAXExit:
.a5c5	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/effects.asm

.a5c6					PingCommand:
.a5c6	5a		phy				phy 								; save pos
.a5c7	a9 01		lda #$01			lda 	#1 						; push channel.
.a5c9	48		pha				pha
.a5ca	a9 c8		lda #$c8			lda 	#200 						; pitch LSB
.a5cc	a2 03		ldx #$03			ldx 	#3 						; length
.a5ce	a0 00		ldy #$00			ldy 	#0 						; slide LSB
.a5d0	80 24		bra $a5f6			bra 	SoundEffectCommand
.a5d2					ZapCommand:
.a5d2	5a		phy				phy 								; save pos
.a5d3	a9 01		lda #$01			lda 	#1 						; push channel.
.a5d5	48		pha				pha
.a5d6	a9 ff		lda #$ff			lda 	#255 						; pitch LSB
.a5d8	a2 05		ldx #$05			ldx 	#5 						; length
.a5da	a0 14		ldy #$14			ldy 	#20 						; slide LSB
.a5dc	80 18		bra $a5f6			bra 	SoundEffectCommand
.a5de					ShootCommand:
.a5de	5a		phy				phy 								; save pos
.a5df	a9 03		lda #$03			lda 	#3 						; push channel.
.a5e1	48		pha				pha
.a5e2	a9 20		lda #$20			lda 	#32 						; pitch LSB
.a5e4	a2 02		ldx #$02			ldx 	#2 						; length
.a5e6	a0 00		ldy #$00			ldy 	#0 						; slide LSB
.a5e8	80 0c		bra $a5f6			bra 	SoundEffectCommand
.a5ea					Explode:
.a5ea	5a		phy				phy 								; save pos
.a5eb	a9 03		lda #$03			lda 	#3 						; push channel.
.a5ed	48		pha				pha
.a5ee	a9 50		lda #$50			lda 	#80 						; pitch LSB
.a5f0	a2 05		ldx #$05			ldx 	#5 						; length
.a5f2	a0 00		ldy #$00			ldy 	#0 						; slide LSB
.a5f4	80 00		bra $a5f6			bra 	SoundEffectCommand
.a5f6					SoundEffectCommand:
.a5f6	8d 66 06	sta $0666			sta 	SoundCommandBlock 			; set up the command block in sound.asm
.a5f9	9c 67 06	stz $0667			stz 	SoundCommandBlock+1
.a5fc	a9 0f		lda #$0f			lda 	#15
.a5fe	8d 68 06	sta $0668			sta 	SoundCommandBlock+2
.a601	8e 69 06	stx $0669			stx 	SoundCommandBlock+3
.a604	8c 6a 06	sty $066a			sty 	SoundCommandBlock+4
.a607	9c 6b 06	stz $066b			stz 	SoundCommandBlock+5
.a60a	68		pla				pla
.a60b	09 10		ora #$10			ora 	#$10  						; execute command $11
.a60d	a2 66		ldx #$66			ldx 	#(SoundCommandBlock & $FF)
.a60f	a0 06		ldy #$06			ldy 	#(SoundCommandBlock >> 8)
.a611	20 18 80	jsr $8018			jsr 	SNDCommand
.a614	7a		ply				ply
.a615	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/playing.asm

.a616					UnaryPlaying:
.a616	fa		plx				plx
.a617	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger 		; get channel #
.a61a	48		pha				pha
.a61b	20 eb 8e	jsr $8eeb			jsr		CheckRightBracket
.a61e	68		pla				pla
.a61f	c9 04		cmp #$04			cmp 	#4
.a621	b0 0c		bcs $a62f			bcs 	_UPNotPlaying
.a623	09 20		ora #$20			ora 	#$20 						; query playing ?
.a625	20 18 80	jsr $8018			jsr 	SNDCommand
.a628	c9 00		cmp #$00			cmp 	#0
.a62a	f0 03		beq $a62f			beq 	_UPNotPlaying
.a62c	4c 71 8f	jmp $8f71			jmp 	ReturnTrue
.a62f					_UPNotPlaying:
.a62f	4c 7c 8f	jmp $8f7c			jmp 	ReturnFalse

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/sound.asm

.a632					SoundCommand:
.a632	b1 30		lda ($30),y			lda 	(codePtr),y
.a634	c9 c3		cmp #$c3			cmp 	#KWD_OFF 					; SOUND OFF ?
.a636	d0 09		bne $a641			bne 	_SNDMain
.a638	c8		iny				iny 								; skip OFF
.a639	a9 3f		lda #$3f			lda 	#$3F 						; call command $3F (silence)
.a63b	5a		phy				phy
.a63c	20 18 80	jsr $8018			jsr 	SNDCommand
.a63f	7a		ply				ply
.a640	60		rts				rts
.a641					_SNDMain:
.a641	a2 00		ldx #$00			ldx 	#0
.a643	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger 		; channel
.a646	c9 04		cmp #$04			cmp 	#4 							; must be 0-3
.a648	b0 4b		bcs $a695			bcs 	_SndError
.a64a	e8		inx				inx 								; do the rest in slot 1.
.a64b	20 f3 8e	jsr $8ef3			jsr 	CheckComma
.a64e	20 a6 9d	jsr $9da6			jsr 	Evaluate16BitInteger 		; Pitch
.a651	b5 60		lda $60,x			lda 	NSMantissa1,x 				; must be 10 bit
.a653	c9 10		cmp #$10			cmp 	#16
.a655	b0 3e		bcs $a695			bcs 	_SndError
.a657	8d 67 06	sta $0667			sta 	SoundCommandBlock+1 		; Pitch (2 bytes + 0)
.a65a	b5 58		lda $58,x			lda 	NSMantissa0,x
.a65c	8d 66 06	sta $0666			sta 	SoundCommandBlock
.a65f	20 f3 8e	jsr $8ef3			jsr 	CheckComma
.a662	20 c1 9d	jsr $9dc1			jsr 	Evaluate8BitInteger 		; Length (1 byte + 3)
.a665	8d 69 06	sta $0669			sta 	SoundCommandBlock+3
.a668	a9 0f		lda #$0f			lda 	#15
.a66a	8d 68 06	sta $0668			sta 	SoundCommandBlock+2 		; Volume (1 byte + 2)
.a66d	9c 6a 06	stz $066a			stz 	SoundCommandBlock+4 		; default slide (2 bytes +4)
.a670	9c 6b 06	stz $066b			stz 	SoundCommandBlock+5
.a673	b1 30		lda ($30),y			lda 	(codePtr),y
.a675	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.a677	d0 0e		bne $a687			bne 	_SNDPlay
.a679	c8		iny				iny
.a67a	20 b0 9d	jsr $9db0			jsr 	Evaluate16BitIntegerSigned 	; Slide
.a67d	b5 58		lda $58,x			lda 	NSMantissa0,x 				; Slide (2 bytes + 4)
.a67f	8d 6a 06	sta $066a			sta 	SoundCommandBlock+4
.a682	b5 60		lda $60,x			lda 	NSMantissa1,x
.a684	8d 6b 06	sta $066b			sta 	SoundCommandBlock+5
.a687					_SNDPlay:
.a687	5a		phy				phy
.a688	a5 58		lda $58				lda 	NSMantissa0 				; channel.
.a68a	09 10		ora #$10			ora 	#$10 						; 1x = Queue sound
.a68c	a2 66		ldx #$66			ldx 	#(SoundCommandBlock & $FF)
.a68e	a0 06		ldy #$06			ldy 	#(SoundCommandBlock >> 8)
.a690	20 18 80	jsr $8018			jsr 	SNDCommand
.a693	7a		ply				ply
.a694	60		rts				rts
.a695					_SndError:
.a695	4c a9 9f	jmp $9fa9			jmp 	RangeError
.0666					SoundCommandBlock:
>0666							.fill 	6

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/bytes.asm

.a698					StackPushByte:
.a698	48		pha				pha 								; save byte on stack
.a699	a5 34		lda $34				lda 	BasicStack 					; decrement basic stack pointer
.a69b	d0 08		bne $a6a5			bne 	_SPBNoBorrow
.a69d	c6 35		dec $35				dec 	BasicStack+1 				; borrow
.a69f	a5 35		lda $35				lda 	BasicStack+1 				; check range.
.a6a1	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a6a3	90 06		bcc $a6ab			bcc 	_SPBMemory
.a6a5					_SPBNoBorrow:
.a6a5	c6 34		dec $34				dec 	BasicStack
.a6a7	68		pla				pla 								; get back and write
.a6a8	92 34		sta ($34)			sta 	(BasicStack)
.a6aa	60		rts				rts
.a6ab					_SPBMemory:
.a6ab	a9 12		lda #$12		lda	#18
.a6ad	4c 04 8f	jmp $8f04		jmp	ErrorHandler
.a6b0					StackPopByte:
.a6b0	b2 34		lda ($34)			lda 	(BasicStack) 				; bump the stack pointer.
.a6b2	e6 34		inc $34				inc 	BasicStack
.a6b4	d0 02		bne $a6b8			bne 	_SPBNoCarry
.a6b6	e6 35		inc $35				inc 	BasicStack+1
.a6b8					_SPBNoCarry:
.a6b8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/frames.asm

.a6b9					StackOpen:
.a6b9	48		pha				pha 								; save frame byte
.a6ba	29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.a6bc	0a		asl a				asl 	a 							; claim twice this for storage
.a6bd	49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.a6bf	38		sec				sec 								; so basically subtracting from
.a6c0	65 34		adc $34				adc 	basicStack 	 				; basicStack
.a6c2	85 34		sta $34				sta 	basicStack
.a6c4	b0 09		bcs $a6cf			bcs 	_SONoBorrow
>a6c6	db						.byte 	$DB 						; causes a break in the emulator
.a6c7	c6 35		dec $35				dec 	basicStack+1
.a6c9	a5 35		lda $35				lda 	basicStack+1 				; have we reached stack overflow
.a6cb	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a6cd	90 04		bcc $a6d3			bcc 	_SOMemory
.a6cf					_SONoBorrow:
.a6cf	68		pla				pla 								; get marker back and write at TOS
.a6d0	92 34		sta ($34)			sta 	(basicStack)
.a6d2	60		rts				rts
.a6d3					_SOMemory:
.a6d3	a9 12		lda #$12		lda	#18
.a6d5	4c 04 8f	jmp $8f04		jmp	ErrorHandler
.a6d8					StackClose:
.a6d8	b2 34		lda ($34)			lda 	(basicStack) 				; get TOS marker
.a6da	29 0f		and #$0f			and 	#$0F 						; bytes to add back
.a6dc	0a		asl a				asl 	a 							; claim twice this.
.a6dd	65 34		adc $34				adc 	basicStack 					; add to the stack pointer.
.a6df	85 34		sta $34				sta 	basicStack
.a6e1	90 02		bcc $a6e5			bcc 	_SCExit
.a6e3	e6 35		inc $35				inc 	basicStack+1
.a6e5					_SCExit:
.a6e5	60		rts				rts
.a6e6					StackCheckFrame:
.a6e6	48		pha				pha
.a6e7					_StackRemoveLocals:
.a6e7	b2 34		lda ($34)			lda 	(basicStack) 				; check for local, keep popping them
.a6e9	c9 03		cmp #$03			cmp 	#STK_LOCALS+1 				; is the frame a local ? S or N are 1/0
.a6eb	b0 05		bcs $a6f2			bcs 	_SCNoLocal
.a6ed	20 84 89	jsr $8984			jsr 	LocalPopValue 				; restore the local value
.a6f0	80 f5		bra $a6e7			bra 	_StackRemoveLocals 			; gr round again
.a6f2					_SCNoLocal:
.a6f2	68		pla				pla 								; get the frame check.
.a6f3	52 34		eor ($34)			eor 	(basicStack) 				; xor with toS marker
.a6f5	29 f0		and #$f0			and 	#$F0 						; check type bits
.a6f7	d0 01		bne $a6fa			bne 	_SCFError 					; different, we have structures mixed up
.a6f9	60		rts				rts
.a6fa					_SCFError:
.a6fa	8a		txa				txa 								; report error X
.a6fb	4c 04 8f	jmp $8f04			jmp 	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/location.asm

.a6fe					STKSaveCodePosition:
.a6fe	5a		phy				phy
.a6ff	98		tya				tya 								; save Y
.a700	a0 05		ldy #$05			ldy 	#5
.a702	91 34		sta ($34),y			sta 	(basicStack),y
.a704	88		dey				dey 								; save Code Pointer
.a705					_STKSaveLoop:
.a705	b9 2f 00	lda $002f,y			lda 	safePtr-1,y 				; allows us to access the pointer w/out issues.
.a708	91 34		sta ($34),y			sta 	(basicStack),y
.a70a	88		dey				dey
.a70b	d0 f8		bne $a705			bne 	_STKSaveLoop
.a70d	7a		ply				ply
.a70e	60		rts				rts
.a70f					STKLoadCodePosition:
.a70f	a0 01		ldy #$01			ldy 	#1 							; load code pointer back
.a711					_STKLoadLoop:
.a711	b1 34		lda ($34),y			lda 	(basicStack),y
.a713	99 2f 00	sta $002f,y			sta 	safePtr-1,y
.a716	c8		iny				iny
.a717	c0 05		cpy #$05			cpy 	#5
.a719	d0 f6		bne $a711			bne 	_STKLoadLoop
.a71b	b1 34		lda ($34),y			lda 	(basicStack),y 				; get Y offset
.a71d	a8		tay				tay
.a71e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/setup.asm

.a71f					StackReset:
.a71f	a9 ff		lda #$ff			lda 	#((BasicStackBase+BasicStackSize-1) & $FF)
.a721	85 34		sta $34				sta 	0+basicStack
.a723	a9 0f		lda #$0f			lda 	#((BasicStackBase+BasicStackSize-1) >> 8)
.a725	85 35		sta $35				sta 	1+basicStack
.a727	a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.a729	92 34		sta ($34)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.a72b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/concrete.asm

.a72c					StringConcrete:
.a72c	5a		phy				phy 								; save position on stack
.a72d	20 39 9a	jsr $9a39			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a730	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy target string to zTemp1
.a732	85 38		sta $38				sta 	zTemp1
.a734	b5 60		lda $60,x			lda 	NSMantissa1,x
.a736	85 39		sta $39				sta 	zTemp1+1
.a738	a0 ff		ldy #$ff			ldy 	#$FF	 					; calculate string length
.a73a					_SALength:
.a73a	c8		iny				iny
.a73b	b1 38		lda ($38),y			lda 	(zTemp1),y
.a73d	d0 fb		bne $a73a			bne 	_SALength
.a73f	c0 fd		cpy #$fd			cpy 	#253 						; string too long - cannot concrete.
.a741	b0 3d		bcs $a780			bcs 	_SALengthError
.a743	98		tya				tya 				 				; length of the new string
.a744	18		clc				clc
.a745	69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.a747	90 02		bcc $a74b			bcc 	_SAHaveLength
.a749	a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.a74b					_SAHaveLength:
.a74b	48		pha				pha 								; save length.
.a74c	38		sec				sec
.a74d	49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.a74f	6d 0e 04	adc $040e			adc 	StringMemory
.a752	8d 0e 04	sta $040e			sta 	StringMemory
.a755	85 3a		sta $3a				sta 	zTemp2 						; update storage address
.a757	95 58		sta $58,x			sta 	NSMantissa0,x 				; update mantissa address
.a759	a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.a75b	6d 0f 04	adc $040f			adc 	StringMemory+1
.a75e	8d 0f 04	sta $040f			sta 	StringMemory+1
.a761	85 3b		sta $3b				sta 	zTemp2+1
.a763	95 60		sta $60,x			sta 	NSMantissa1,x
.a765	68		pla				pla 								; save length-3 (chars allowed) in first byte
.a766	38		sec				sec
.a767	e9 03		sbc #$03			sbc 	#3
.a769	92 3a		sta ($3a)			sta 	(zTemp2)
.a76b	a9 00		lda #$00			lda 	#0 							; clear the status byte.
.a76d	a0 01		ldy #$01			ldy 	#1
.a76f	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a771					_SACopyNewString:
.a771	a0 00		ldy #$00			ldy 	#0
.a773					_SACopyNSLoop:
.a773	b1 38		lda ($38),y			lda 	(zTemp1),y 					; get character
.a775	c8		iny				iny 								; write two on in string storage
.a776	c8		iny				iny
.a777	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a779	88		dey				dey 								; this makes it one one.
.a77a	c9 00		cmp #$00			cmp 	#0 							; until EOS copied
.a77c	d0 f5		bne $a773			bne 	_SACopyNSLoop
.a77e	7a		ply				ply
.a77f	60		rts				rts
.a780					_SALengthError:
.a780	a9 09		lda #$09		lda	#9
.a782	4c 04 8f	jmp $8f04		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/stringalloc.asm

.a785					StringSystemInitialise:
.a785	a9 ff		lda #$ff			lda 	#((EndVariableSpace-1) & $FF)
.a787	8d 0e 04	sta $040e			sta 	0+StringMemory
.a78a	a9 1f		lda #$1f			lda 	#((EndVariableSpace-1) >> 8)
.a78c	8d 0f 04	sta $040f			sta 	1+StringMemory
.a78f	9c ff 1f	stz $1fff			stz 	EndVariableSpace-1 			; put a zero at the end, so know end of string memory.
.a792	60		rts				rts
.a793					StringSpaceInitialise:
.a793	20 39 9a	jsr $9a39			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a796	a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.a798	8d 10 04	sta $0410			sta 	StringInitialised
.a79b	ad 0e 04	lda $040e			lda 	StringMemory 				; allocate 256 bytes for one concreted string
.a79e	8d 11 04	sta $0411			sta 	StringTempPointer 			; so temporary string space is allocated below that.
.a7a1	ad 0f 04	lda $040f			lda 	StringMemory+1
.a7a4	3a		dec a				dec 	a
.a7a5	8d 12 04	sta $0412			sta 	StringTempPointer+1
.a7a8	60		rts				rts
.a7a9					StringTempAllocate:
.a7a9	c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.a7ab	b0 30		bcs $a7dd			bcs 	_STALength
.a7ad	2c 10 04	bit $0410			bit 	StringInitialised 			; already initialised
.a7b0	30 05		bmi $a7b7			bmi 	_STAAllocate
.a7b2	48		pha				pha 								; save value to subtract.
.a7b3	20 93 a7	jsr $a793			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.a7b6	68		pla				pla 								; restore it
.a7b7					_STAAllocate:
.a7b7	49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.a7b9	18		clc				clc  								; deliberate allows one more
.a7ba	6d 11 04	adc $0411			adc 	StringTempPointer 			; subtract from temp pointer
.a7bd	8d 11 04	sta $0411			sta 	StringTempPointer
.a7c0	95 58		sta $58,x			sta 	NSMantissa0,x 				; address in mantissa
.a7c2	85 3c		sta $3c				sta 	zsTemp 						; and zsTemp
.a7c4	ad 12 04	lda $0412			lda 	StringTempPointer+1
.a7c7	69 ff		adc #$ff			adc 	#$FF
.a7c9	8d 12 04	sta $0412			sta 	StringTempPointer+1
.a7cc	85 3d		sta $3d				sta 	zsTemp+1
.a7ce	95 60		sta $60,x			sta 	NSMantissa1,x
.a7d0	74 68		stz $68,x			stz 	NSMantissa2,x 				; set the typing data and the upper address bytes.
.a7d2	74 70		stz $70,x			stz 	NSMantissa3,x
.a7d4	a9 10		lda #$10			lda 	#NSTString
.a7d6	95 50		sta $50,x			sta 	NSStatus,x
.a7d8	a9 00		lda #$00			lda 	#0 							; clear the target string
.a7da	92 3c		sta ($3c)			sta 	(zsTemp)
.a7dc	60		rts				rts
.a7dd					_STALength:
.a7dd	a9 09		lda #$09		lda	#9
.a7df	4c 04 8f	jmp $8f04		jmp	ErrorHandler
.a7e2					StringTempWrite:
.a7e2	48		pha				pha
.a7e3	92 3c		sta ($3c)			sta 	(zsTemp) 					; write byte
.a7e5	e6 3c		inc $3c				inc 	zsTemp 						; bump pointer
.a7e7	d0 02		bne $a7eb			bne 	_STWNoCarry
.a7e9	e6 3d		inc $3d				inc 	zsTemp+1
.a7eb					_STWNoCarry:
.a7eb	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.a7ed	92 3c		sta ($3c)			sta 	(zsTemp)
.a7ef	68		pla				pla
.a7f0	60		rts				rts

;******  Return to file: _basic.asm

.a7f1					StartModuleCode:

;******  Processing file: ../modules/_build/_hardware.module

=1					hardwareIntegrated=1
=0					CONBlack = 0
=1					CONWhite = 1
=2					CONRed = 2
=3					CONCyan = 3
=4					CONPurple = 4
=5					CONGreen = 5
=6					CONBlue = 6
=7					CONYellow = 7
=8					CONOrange = 8
=9					CONBrown = 9
=10					CONYellowGreen = 10
=11					CONRosa = 11
=12					CONBlueGreen = 12
=13					CONLightBlue = 13
=14					CONPink = 14
=15					CONLightGreen = 15
=7					CONForeground = CONYellow
=6					CONBackground = CONBlue
=5					CLICommandLine = CONGreen
=0					CLIFComment = CONBlack
=7					CLIBComment = CONYellow
=9					CLILineNumber = CONBrown
=3					CLIToken = CONCyan
=13					CLIConstant = CONLightBlue
=7					CLIIdentifier = CONYellow
=10					CLIPunctuation = CONYellowGreen
=1					CLIData = CONWhite
.a7f1					Export_EXTPrintCharacter:
.a7f1					PAGEDPrintCharacter:
.a7f1	48		pha				pha
.a7f2	da		phx				phx
.a7f3	5a		phy				phy
.a7f4	a6 01		ldx $01				ldx 	1
.a7f6	da		phx				phx
.a7f7	ac 6d 06	ldy $066d			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.a7fa	09 00		ora #$00			ora 	#$00 						; check $80-$FF
.a7fc	30 48		bmi $a846			bmi 	_EXPCColour
.a7fe	c9 20		cmp #$20			cmp 	#$20 						; check $00-$1F
.a800	90 4d		bcc $a84f			bcc 	_EXPCControl
.a802	a2 02		ldx #$02			ldx 	#2 							; select char memory
.a804	86 01		stx $01				stx 	1
.a806	91 40		sta ($40),y			sta 	(EXTAddress),y
.a808	e6 01		inc $01				inc 	1 							; select colour memory
.a80a	ad 6e 06	lda $066e			lda 	EXTTextColour
.a80d	91 40		sta ($40),y			sta 	(EXTAddress),y
.a80f	c8		iny				iny 								; advance horizontal position
.a810	8c 6d 06	sty $066d			sty 	EXTColumn
.a813	cc 6f 06	cpy $066f			cpy 	EXTScreenWidth 				; reached RHS ?
.a816	90 63		bcc $a87b			bcc 	_EXPCExit 					; no, then exit.
.a818					_EXPCCRLF:
.a818	ee 6c 06	inc $066c			inc 	EXTRow  					; bump row
.a81b	9c 6d 06	stz $066d			stz 	EXTColumn 					; back to column 0
.a81e	ad 6c 06	lda $066c			lda 	EXTRow 						; check if reached the bottom ?
.a821	cd 70 06	cmp $0670			cmp 	EXTScreenHeight 			; if so, then scroll.
.a824	f0 18		beq $a83e			beq 	_EXPCScroll
.a826	18		clc				clc 								; add width to address.
.a827	a5 40		lda $40				lda 	EXTAddress
.a829	6d 6f 06	adc $066f			adc 	EXTScreenWidth
.a82c	85 40		sta $40				sta 	EXTAddress
.a82e	90 4b		bcc $a87b			bcc 	_EXPCExit
.a830	e6 41		inc $41				inc 	EXTAddress+1
.a832	80 47		bra $a87b			bra 	_EXPCExit
.a834					_EXPCLeft:
.a834	ce 6d 06	dec $066d			dec 	EXTColumn
.a837	10 42		bpl $a87b			bpl 	_EXPCExit
.a839					_EXPCBegin:
.a839	9c 6d 06	stz $066d			stz 	EXTColumn
.a83c	80 3d		bra $a87b			bra 	_EXPCExit
.a83e					_EXPCScroll:
.a83e	ce 6c 06	dec $066c			dec 	EXTRow 						; the height-1 th line.
.a841	20 2c a9	jsr $a92c			jsr 	EXTScreenScroll 			; scroll the screen
.a844	80 35		bra $a87b			bra 	_EXPCExit
.a846					_EXPCColour:
.a846	c9 a0		cmp #$a0			cmp 	#$A0						; 80-9F set foreground/background
.a848	b0 31		bcs $a87b			bcs 	_EXPCExit
.a84a	20 0c a9	jsr $a90c			jsr 	_EXPCHandleColour
.a84d	80 2c		bra $a87b			bra 	_EXPCExit
.a84f					_EXPCControl:
.a84f	c9 11		cmp #$11			cmp 	#$11 						; only handle 00-10.
.a851	b0 28		bcs $a87b			bcs 	_EXPCExit
.a853	0a		asl a				asl 	a 							; double into X
.a854	aa		tax				tax
.a855	7c ea a8	jmp ($a8ea,x)			jmp 	(_EXPCActionTable,x) 		; and execute code.
.a858					_EXPCUp:
.a858	ad 6c 06	lda $066c			lda 	EXTRow 						; already at top ?
.a85b	f0 1e		beq $a87b			beq 	_EXPCExit
.a85d	ce 6c 06	dec $066c			dec 	EXTRow 						; up one in position/address
.a860	38		sec				sec
.a861	a5 40		lda $40				lda 	EXTAddress
.a863	ed 6f 06	sbc $066f			sbc 	EXTScreenWidth
.a866	85 40		sta $40				sta 	EXTAddress
.a868	b0 11		bcs $a87b			bcs 	_EXPCExit
.a86a	c6 41		dec $41				dec 	EXTAddress+1
.a86c	80 0d		bra $a87b			bra 	_EXPCExit
.a86e					_EXPCRight:
.a86e	c8		iny				iny
.a86f	8c 6d 06	sty $066d			sty 	EXTColumn
.a872	cc 6f 06	cpy $066f			cpy 	EXTScreenWidth
.a875	d0 04		bne $a87b			bne 	_EXPCExit
.a877	88		dey				dey
.a878					_EXPCSetColumnY:
.a878	8c 6d 06	sty $066d			sty 	EXTColumn
.a87b					_EXPCExit:
.a87b	20 81 a9	jsr $a981			jsr 	EXTSetHardwareCursor 		; place the physical cursor.
.a87e	68		pla				pla
.a87f	85 01		sta $01				sta 	1
.a881	7a		ply				ply
.a882	fa		plx				plx
.a883	68		pla				pla
.a884	60		rts				rts
.a885					_EXPCClearScreen:
.a885	20 3e a9	jsr $a93e			jsr		EXTClearScreenCode
.a888	80 f1		bra $a87b			bra 	_EXPCExit
.a88a					_EXPCDown:
.a88a	ad 70 06	lda $0670			lda 	EXTScreenHeight 			; at the bottom
.a88d	3a		dec a				dec 	a
.a88e	cd 6c 06	cmp $066c			cmp 	EXTRow
.a891	f0 e8		beq $a87b			beq 	_EXPCExit
.a893	ee 6c 06	inc $066c			inc 	EXTRow 						; down one in position/address
.a896	18		clc				clc
.a897	a5 40		lda $40				lda 	EXTAddress
.a899	6d 6f 06	adc $066f			adc 	EXTScreenWidth
.a89c	85 40		sta $40				sta 	EXTAddress
.a89e	90 db		bcc $a87b			bcc 	_EXPCExit
.a8a0	e6 41		inc $41				inc 	EXTAddress+1
.a8a2	80 d7		bra $a87b			bra 	_EXPCExit
.a8a4					_EXPCTab:
.a8a4	ad 6d 06	lda $066d			lda 	EXTColumn 					; next tab stop
.a8a7	29 f8		and #$f8			and 	#$F8
.a8a9	18		clc				clc
.a8aa	69 08		adc #$08			adc 	#8
.a8ac	8d 6d 06	sta $066d			sta 	EXTColumn
.a8af	cd 6f 06	cmp $066f			cmp 	EXTScreenWidth 				; too far, stick end of line.
.a8b2	90 c7		bcc $a87b			bcc 	_EXPCExit
.a8b4	80 10		bra $a8c6			bra 	_EXPCEnd
.a8b6					_EXPCBackSpace:
.a8b6	88		dey				dey
.a8b7	30 c2		bmi $a87b			bmi 	_EXPCExit
.a8b9	ce 6d 06	dec $066d			dec 	EXTColumn
.a8bc	a9 02		lda #$02			lda 	#2
.a8be	85 01		sta $01				sta 	1
.a8c0	a9 20		lda #$20			lda 	#32
.a8c2	91 40		sta ($40),y			sta 	(EXTAddress),y
.a8c4	80 b5		bra $a87b			bra 	_EXPCExit
.a8c6					_EXPCEnd:
.a8c6	a9 02		lda #$02			lda 	#2 							; access text screen
.a8c8	85 01		sta $01				sta 	1
.a8ca	ac 6f 06	ldy $066f			ldy 	EXTScreenWidth 				; point to last character
.a8cd	88		dey				dey
.a8ce					_EXPCEndSearch:
.a8ce	88		dey				dey 								; if past start, move to col 0.
.a8cf	30 06		bmi $a8d7			bmi 	_EXPCFound
.a8d1	b1 40		lda ($40),y			lda 	(EXTAddress),y 				; keep going back till non space found
.a8d3	c9 20		cmp #$20			cmp 	#' '
.a8d5	f0 f7		beq $a8ce			beq 	_EXPCEndSearch
.a8d7					_EXPCFound:
.a8d7	c8		iny				iny 								; move to following cell.
.a8d8	80 9e		bra $a878			bra 	_EXPCSetColumnY
.a8da					_EXPCClearEOL:
.a8da	a9 02		lda #$02			lda 	#2 							; access character RAM
.a8dc	85 01		sta $01				sta 	1
.a8de	a9 20		lda #$20			lda 	#' ' 						; write space
.a8e0	91 40		sta ($40),y			sta 	(EXTAddress),y
.a8e2	c8		iny				iny
.a8e3	cc 6f 06	cpy $066f			cpy 	EXTScreenWidth 				; until RHS of screen.
.a8e6	90 f2		bcc $a8da			bcc 	_EXPCClearEOL
.a8e8	80 91		bra $a87b			bra 	_EXPCExit
.a8ea					_EXPCActionTable:
>a8ea	7b a8						.word 	_EXPCExit 					; 00
>a8ec	39 a8						.word 	_EXPCBegin 					; 01 A Start of Line
>a8ee	34 a8						.word 	_EXPCLeft 					; 02 B Left
>a8f0	7b a8						.word 	_EXPCExit 					; 03 <Break>
>a8f2	7b a8						.word 	_EXPCExit 					; 04
>a8f4	c6 a8						.word 	_EXPCEnd 					; 05 E End of Line
>a8f6	6e a8						.word 	_EXPCRight 					; 06 F Right
>a8f8	7b a8						.word 	_EXPCExit 					; 07
>a8fa	b6 a8						.word 	_EXPCBackspace 				; 08 H Backspace
>a8fc	a4 a8						.word 	_EXPCTab 					; 09 I Tab
>a8fe	7b a8						.word 	_EXPCExit 					; 0A
>a900	da a8						.word 	_EXPCClearEOL 				; 0B K Clear to EOL
>a902	85 a8						.word 	_EXPCClearScreen			; 0C L CLS
>a904	18 a8						.word 	_EXPCCRLF 					; 0D M CR/LF
>a906	8a a8						.word 	_EXPCDown 					; 0E N Down
>a908	7b a8						.word 	_EXPCExit 					; 0F
>a90a	58 a8						.word 	_EXPCUp 					; 10 P Up
.a90c					_EXPCHandleColour
.a90c	c9 90		cmp #$90			cmp 	#$90 						; 8x foreground 9x background
.a90e	b0 16		bcs $a926			bcs 	_EXPCBackground
.a910	0a		asl a				asl 	a 							; shift it 4 bits to the right.
.a911	0a		asl a				asl 	a
.a912	0a		asl a				asl 	a
.a913	0a		asl a				asl 	a
.a914	a2 0f		ldx #$0f			ldx 	#$0F 						; Mask in X
.a916					_EXPCUpdate:
.a916	48		pha				pha 								; save new colour
.a917	8a		txa				txa 								; get mask
.a918	2d 6e 06	and $066e			and 	EXTTextColour 				; mask out old.
.a91b	8d 6e 06	sta $066e			sta 	EXTTextColour
.a91e	68		pla				pla 								; or in new colour
.a91f	0d 6e 06	ora $066e			ora 	EXTTextColour
.a922	8d 6e 06	sta $066e			sta 	EXTTextColour
.a925	60		rts				rts
.a926					_EXPCBackground:
.a926	29 0f		and #$0f			and 	#$0F 						; get the colour
.a928	a2 f0		ldx #$f0			ldx 	#$F0 						; mask
.a92a	80 ea		bra $a916			bra 	_EXPCUpdate
.a92c					EXTScreenScroll:
.a92c	a9 02		lda #$02			lda 	#2 							; select text page
.a92e	85 01		sta $01				sta 	1
.a930	a9 20		lda #$20			lda		#32 						; fill with space
.a932	20 45 aa	jsr $aa45			jsr 	EXTScrollFill
.a935	e6 01		inc $01				inc 	1 							; select colour page
.a937	ad 6e 06	lda $066e			lda 	EXTTextColour
.a93a	20 45 aa	jsr $aa45			jsr 	EXTScrollFill
.a93d	60		rts				rts
.a93e					EXTClearScreenCode:
.a93e	a9 02		lda #$02			lda 	#2 							; select text page
.a940	85 01		sta $01				sta 	1
.a942	a9 20		lda #$20			lda		#32 						; fill with space
.a944	20 51 a9	jsr $a951			jsr 	_EXTCSFill
.a947	e6 01		inc $01				inc 	1 							; select colour page
.a949	ad 6e 06	lda $066e			lda 	EXTTextColour
.a94c	20 51 a9	jsr $a951			jsr 	_EXTCSFill
.a94f	80 22		bra $a973			bra 	EXTHomeCursor
.a951					_EXTCSFill:
.a951	aa		tax				tax
.a952	a9 00		lda #$00			lda 	#EXTMemory & $FF
.a954	85 40		sta $40				sta 	EXTAddress
.a956	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a958	85 41		sta $41				sta 	EXTAddress+1
.a95a					_EXTCSFill1:
.a95a	a0 00		ldy #$00			ldy 	#0
.a95c	8a		txa				txa
.a95d					_EXTCSFill2:
.a95d	91 40		sta ($40),y			sta 	(EXTAddress),y
.a95f	c8		iny				iny
.a960	d0 fb		bne $a95d			bne 	_EXTCSFill2
.a962	e6 41		inc $41				inc 	EXTAddress+1
.a964	a5 41		lda $41				lda 	EXTAddress+1
.a966	c9 d2		cmp #$d2			cmp 	#$D2
.a968	d0 f0		bne $a95a			bne 	_EXTCSFill1
.a96a	8a		txa				txa
.a96b					_EXTCSFill3:
.a96b	91 40		sta ($40),y			sta 	(EXTAddress),y
.a96d	c8		iny				iny
.a96e	c0 c0		cpy #$c0			cpy 	#$C0
.a970	d0 f9		bne $a96b			bne 	_EXTCSFill3
.a972	60		rts				rts
.a973					EXTHomeCursor:
.a973	9c 6c 06	stz $066c			stz 	EXTRow 						; reset row & column
.a976	9c 6d 06	stz $066d			stz 	EXTColumn
.a979	a9 00		lda #$00			lda 	#EXTMemory & $FF 			; set address
.a97b	85 40		sta $40				sta 	EXTAddress
.a97d	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a97f	85 41		sta $41				sta 	EXTAddress+1
.a981					EXTSetHardwareCursor:
.a981	64 01		stz $01				stz 	1 							; I/O Page zero
.a983	a9 05		lda #$05			lda 	#1+4 						; enable cursor
.a985	8d 10 d0	sta $d010			sta 	$D010
.a988	a9 b1		lda #$b1			lda 	#$B1
.a98a	8d 12 d0	sta $d012			sta 	$D012
.a98d	ad 6d 06	lda $066d			lda 	EXTColumn
.a990	8d 14 d0	sta $d014			sta 	$D014 						; set cursor position
.a993	9c 15 d0	stz $d015			stz 	$D015
.a996	ad 6c 06	lda $066c			lda 	EXTRow
.a999	8d 16 d0	sta $d016			sta 	$D016
.a99c	9c 17 d0	stz $d017			stz 	$D017
.a99f	60		rts				rts
.a9a0					Export_EXTInputLine:
.a9a0	48		pha				pha
.a9a1	da		phx				phx
.a9a2	5a		phy				phy
.a9a3	a5 01		lda $01				lda 	1 							; save I/O page
.a9a5	48		pha				pha
.a9a6					_EILLoop:
.a9a6	20 c0 aa	jsr $aac0			jsr 	PagedInputSingleCharacter
.a9a9	c9 0d		cmp #$0d			cmp 	#13 						; scrape line if exit.
.a9ab	f0 44		beq $a9f1			beq 	_EILExit
.a9ad	c9 04		cmp #$04			cmp 	#4 							; Ctrl+D delete at cursor
.a9af	f0 2a		beq $a9db			beq 	_EILDelete
.a9b1	c9 08		cmp #$08			cmp 	#8 							; Ctrl+H backspace
.a9b3	f0 1c		beq $a9d1			beq 	_EILBackspace
.a9b5	c9 20		cmp #$20			cmp 	#' '						; < space, print it
.a9b7	90 12		bcc $a9cb			bcc 	_EILPrintLoop
.a9b9	c9 7f		cmp #$7f			cmp 	#$7F 						; if -ve print it
.a9bb	b0 0e		bcs $a9cb			bcs 	_EILPrintLoop
.a9bd	48		pha				pha 								; save character
.a9be	a9 02		lda #$02			lda 	#2  						; insert a space
.a9c0	85 01		sta $01				sta 	1
.a9c2	20 33 aa	jsr $aa33			jsr 	EXTILInsert 				; insert in text screen
.a9c5	e6 01		inc $01				inc 	1
.a9c7	20 33 aa	jsr $aa33			jsr 	EXTILInsert 				; insert in colour screen
.a9ca	68		pla				pla 								; get character back.
.a9cb					_EILPrintLoop:
.a9cb	20 f1 a7	jsr $a7f1			jsr 	PagedPrintCharacter
.a9ce	80 d6		bra $a9a6			bra 	_EILLoop
.a9d0	60		rts				rts
.a9d1					_EILBackspace:
.a9d1	ad 6d 06	lda $066d			lda 	EXTColumn					; can we backspace ?
.a9d4	f0 d0		beq $a9a6			beq 	_EILLoop
.a9d6	a9 02		lda #$02			lda 	#2 							; move cursor left
.a9d8	20 f1 a7	jsr $a7f1			jsr 	PagedPrintCharacter
.a9db					_EILDelete
.a9db	a9 02		lda #$02			lda 	#2 							; text block
.a9dd	85 01		sta $01				sta 	1
.a9df	a9 20		lda #$20			lda 	#' ' 						; backspace text.
.a9e1	20 1e aa	jsr $aa1e			jsr 	EXTILDelete
.a9e4	e6 01		inc $01				inc 	1 							; colour block
.a9e6	ac 6d 06	ldy $066d			ldy 	EXTColumn 					; get attribute of last character
.a9e9	88		dey				dey
.a9ea	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a9ec	20 1e aa	jsr $aa1e			jsr 	EXTILDelete 				; backspace attribute
.a9ef	80 b5		bra $a9a6			bra 	_EILLoop 					; and go round.
.a9f1					_EILExit:
.a9f1	a9 02		lda #$02			lda 	#2 							; switch to page 2
.a9f3	85 01		sta $01				sta 	1
.a9f5	a0 00		ldy #$00			ldy 	#0 							; copy current line into buffer.
.a9f7					_EILScrapeLine:
.a9f7	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a9f9	99 2a 05	sta $052a,y			sta 	lineBuffer,y
.a9fc	c8		iny				iny
.a9fd	cc 6f 06	cpy $066f			cpy 	EXTScreenWidth
.aa00	d0 f5		bne $a9f7			bne 	_EILScrapeLine
.aa02					_EILTrimSpaces:
.aa02	88		dey				dey
.aa03	f0 08		beq $aa0d			beq 	_EILEndTrim
.aa05	b9 2a 05	lda $052a,y			lda 	lineBuffer,y
.aa08	c9 20		cmp #$20			cmp 	#' '
.aa0a	f0 f6		beq $aa02			beq 	_EILTrimSpaces
.aa0c	c8		iny				iny 								; trim after non space character.
.aa0d					_EILEndTrim:
.aa0d	a9 00		lda #$00			lda 	#0 							; trim here.
.aa0f	99 2a 05	sta $052a,y			sta 	lineBuffer,y
.aa12	a9 0d		lda #$0d			lda 	#13 						; echo the RETURN
.aa14	20 f1 a7	jsr $a7f1			jsr 	PagedPrintCharacter
.aa17	68		pla				pla 								; reset I/O page
.aa18	85 01		sta $01				sta 	1
.aa1a	7a		ply				ply
.aa1b	fa		plx				plx
.aa1c	68		pla				pla
.aa1d	60		rts				rts
.aa1e					EXTILDelete:
.aa1e	48		pha				pha 								; save the new character
.aa1f	ac 6d 06	ldy $066d			ldy 	EXTColumn 					; start copying from here.
.aa22					_EXTDLoop:
.aa22	c8		iny				iny 								; copy one byte down.
.aa23	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa25	88		dey				dey
.aa26	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa28	c8		iny				iny 								; do till end of line.
.aa29	cc 6f 06	cpy $066f			cpy 	EXTScreenWidth
.aa2c	90 f4		bcc $aa22			bcc 	_EXTDLoop
.aa2e	88		dey				dey 	 							; write in last slot.
.aa2f	68		pla				pla
.aa30	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa32	60		rts				rts
.aa33					EXTILInsert:
.aa33	ac 6f 06	ldy $066f			ldy 	EXTScreenWidth 				; end position
.aa36					_EXTILoop:
.aa36	88		dey				dey 								; back one
.aa37	cc 6d 06	cpy $066d			cpy 	EXTColumn 					; exit if reached insert point.
.aa3a	f0 08		beq $aa44			beq 	_EXTIExit
.aa3c	88		dey				dey 								; copy one byte up.
.aa3d	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa3f	c8		iny				iny
.aa40	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa42	80 f2		bra $aa36			bra 	_EXTILoop
.aa44					_EXTIExit:
.aa44	60		rts				rts
.aa45					EXTScrollFill:
.aa45	aa		tax				tax									; save value to fill with
.aa46	a5 36		lda $36				lda 	zTemp0 						; save zTemp0 (dest) zTemp1 (src)
.aa48	48		pha				pha
.aa49	a5 37		lda $37				lda 	zTemp0+1
.aa4b	48		pha				pha
.aa4c	a5 38		lda $38				lda 	zTemp1
.aa4e	48		pha				pha
.aa4f	a5 39		lda $39				lda 	zTemp1+1
.aa51	48		pha				pha
.aa52	a9 c0		lda #$c0			lda 	#$C0 						; copy from C000+length to C000
.aa54	85 37		sta $37				sta 	zTemp0+1
.aa56	85 39		sta $39				sta 	zTemp1+1
.aa58	64 36		stz $36				stz 	zTemp0
.aa5a	ad 6f 06	lda $066f			lda 	EXTScreenWidth
.aa5d	85 38		sta $38				sta 	zTemp1
.aa5f	a0 00		ldy #$00			ldy 	#0
.aa61					_EXSFCopy1:
.aa61	b1 38		lda ($38),y			lda 	(zTemp1),y
.aa63	91 36		sta ($36),y			sta 	(zTemp0),y
.aa65	c8		iny				iny
.aa66	d0 f9		bne $aa61			bne 	_EXSFCopy1
.aa68	e6 37		inc $37				inc 	zTemp0+1 					; next page
.aa6a	e6 39		inc $39				inc 	zTemp1+1
.aa6c	a5 39		lda $39				lda 	zTemp1+1
.aa6e	c9 d3		cmp #$d3			cmp 	#$D3
.aa70	d0 ef		bne $aa61			bne 	_EXSFCopy1
.aa72	ac 6f 06	ldy $066f			ldy 	EXTScreenWidth 				; blank the bottom line.
.aa75	8a		txa				txa
.aa76					_EXSFFill1:
.aa76	88		dey				dey
.aa77	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa79	c0 00		cpy #$00			cpy 	#0
.aa7b	10 f9		bpl $aa76			bpl 	_EXSFFill1
.aa7d	68		pla				pla
.aa7e	85 39		sta $39				sta 	zTemp1+1
.aa80	68		pla				pla
.aa81	85 38		sta $38				sta 	zTemp1
.aa83	68		pla				pla
.aa84	85 37		sta $37				sta 	zTemp0+1
.aa86	68		pla				pla
.aa87	85 36		sta $36				sta 	zTemp0
.aa89	60		rts				rts
=$c000					EXTMemory = $C000
=$02					EXTTextPage = $02
=$03					EXTColourPage = $03
=1					EXTDummySpace = 1 							; fake-space for CR character.
=0					EXTCBlack = 0
.066c					EXTRow:
>066c							.fill 	1
.066d					EXTColumn:
>066d							.fill 	1
.066e					EXTTextColour:
>066e							.fill 	1
.066f					EXTScreenWidth:
>066f							.fill 	1
.0670					EXTScreenHeight:
>0670							.fill 	1
.0040					EXTAddress:
>0040							.fill 	2
.aa8a					Export_EXTInitialise:
.aa8a	64 01		stz $01				stz 	1 							; Access I/O page 0
.aa8c	9c 04 d0	stz $d004			stz 	$D004 						; Disable border
.aa8f	9c 08 d0	stz $d008			stz 	$D008
.aa92	9c 09 d0	stz $d009			stz 	$D009
.aa95	a9 09		lda #$09			lda 	#1+8						; Timer On at 70Hz counting up.
.aa97	8d 58 d6	sta $d658			sta 	$D658
.aa9a	a9 03		lda #$03			lda 	#3 							; get current text colour from whatever the kernel
.aa9c	85 01		sta $01				sta 	1 							; has set it to, looking at top left character
.aa9e	ad 00 c0	lda $c000			lda 	$C000
.aaa1	8d 6e 06	sta $066e			sta 	EXTTextColour
.aaa4	a9 50		lda #$50			lda 	#80 						; set screen dimensions.
.aaa6	8d 6f 06	sta $066f			sta 	EXTScreenWidth
.aaa9	a9 3c		lda #$3c			lda 	#60
.aaab	8d 70 06	sta $0670			sta 	EXTScreenHeight
.aaae	20 73 a9	jsr $a973			jsr 	EXTHomeCursor 				; home cursor
.aab1					_EXMoveDown:
.aab1	a9 0d		lda #$0d			lda 	#13
.aab3	20 f1 a7	jsr $a7f1			jsr 	PAGEDPrintCharacter
.aab6	ad 6c 06	lda $066c			lda 	EXTRow
.aab9	c9 06		cmp #$06			cmp 	#6
.aabb	d0 f4		bne $aab1			bne 	_EXMoveDown
.aabd	64 01		stz $01				stz 	1
.aabf	60		rts				rts
.aac0					Export_EXTInputSingleCharacter:
.aac0					PagedInputSingleCharacter:
.aac0	da		phx				phx
.aac1	5a		phy				phy
.aac2					_EISCWait:
.aac2	a5 01		lda $01				lda 	1 							; save I/O 0
.aac4	48		pha				pha
.aac5	64 01		stz $01				stz 	1 							; access I/O Page 0
.aac7	38		sec				sec 								; calculate timer - LastTick
.aac8	ad 59 d6	lda $d659			lda 	$D659
.aacb	aa		tax				tax 								; saving timer in X
.aacc	ed 5b 06	sbc $065b			sbc 	LastTick
.aacf	c9 03		cmp #$03			cmp 	#3
.aad1	90 06		bcc $aad9			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.aad3	8e 5b 06	stx $065b			stx 	LastTick 					; update last timer
.aad6	20 a1 be	jsr $bea1			jsr 	PagedSNDUpdate 							; go do the code.
.aad9					_NoFireTick:
.aad9	68		pla				pla 								; restore I/O 0
.aada	85 01		sta $01				sta 	1
.aadc	20 e4 ff	jsr $ffe4			jsr 	$FFE4 						; get a key
.aadf	c9 00		cmp #$00			cmp 	#0 							; loop back if none pressed.
.aae1	f0 df		beq $aac2			beq 	_EISCWait
.aae3	7a		ply				ply
.aae4	fa		plx				plx
.aae5	60		rts				rts
.aae6					Export_EXTBreakCheck:
.aae6	4c e1 ff	jmp $ffe1			jmp		$FFE1
.aae9					Export_EXTReadController:
.aae9	da		phx				phx
.aaea	a2 00		ldx #$00			ldx 	#0
.aaec	a9 05		lda #$05			lda 	#(($2D) >> 3)
.aaee	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aaf1	29 20		and #$20			and 	#($01 << (($2D) & 7))
.aaf3	f0 04		beq $aaf9			beq 	_NoSet1
.aaf5	8a		txa				txa
.aaf6	09 01		ora #$01			ora 	#1
.aaf8	aa		tax				tax
.aaf9					_NoSet1:
.aaf9	a9 05		lda #$05			lda 	#(($2C) >> 3)
.aafb	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aafe	29 10		and #$10			and 	#($01 << (($2C) & 7))
.ab00	f0 04		beq $ab06			beq 	_NoSet1
.ab02	8a		txa				txa
.ab03	09 02		ora #$02			ora 	#2
.ab05	aa		tax				tax
.ab06					_NoSet1:
.ab06	a9 06		lda #$06			lda 	#(($32) >> 3)
.ab08	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab0b	29 04		and #$04			and 	#($01 << (($32) & 7))
.ab0d	f0 04		beq $ab13			beq 	_NoSet1
.ab0f	8a		txa				txa
.ab10	09 04		ora #$04			ora 	#4
.ab12	aa		tax				tax
.ab13					_NoSet1:
.ab13	a9 04		lda #$04			lda 	#(($25) >> 3)
.ab15	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab18	29 20		and #$20			and 	#($01 << (($25) & 7))
.ab1a	f0 04		beq $ab20			beq 	_NoSet1
.ab1c	8a		txa				txa
.ab1d	09 08		ora #$08			ora 	#8
.ab1f	aa		tax				tax
.ab20					_NoSet1:
.ab20	a9 04		lda #$04			lda 	#(($26) >> 3)
.ab22	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab25	29 40		and #$40			and 	#($01 << (($26) & 7))
.ab27	f0 04		beq $ab2d			beq 	_NoSet1
.ab29	8a		txa				txa
.ab2a	09 10		ora #$10			ora 	#16
.ab2c	aa		tax				tax
.ab2d					_NoSet1:
.ab2d	8a		txa				txa
.ab2e	fa		plx				plx
.ab2f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_graphics.module

=1					graphicsIntegrated=1
=0					GCMD_Initialise = 0*2
=2					GCMD_BitmapCtl = 1*2
=4					GCMD_SpriteCtl = 2*2
=6					GCMD_Clear = 3*2
=8					GCMD_Colour = 4*2
=10					GCMD_DrawFont = 5*2
=12					GCMD_DrawSprite = 6*2
=14					GCMD_SpriteUse = 7*2
=16					GCMD_SpriteImage = 8*2
=18					GCMD_SpriteCollide = 9*2
=64					GCMD_Move = 32*2
=66					GCMD_Line = 33*2
=68					GCMD_FrameRect = 34*2
=70					GCMD_FillRect = 35*2
=72					GCMD_FrameCircle = 36*2
=74					GCMD_FillCircle = 37*2
=80					GCMD_Plot = 40*2
=82					GCMD_SpriteMove = 41*2
=42					GRFirstFreeCode = 42
.ab30					GRVectorTable:
>ab30	7f ad					.word	GXInitialise             ; $00 Initialise
>ab32	99 ad					.word	GXControlBitmap          ; $01 BitmapCtl
>ab34	e1 ad					.word	GXControlSprite          ; $02 SpriteCtl
>ab36	31 ad					.word	GXClearBitmap            ; $03 Clear
>ab38	70 af					.word	GXSetColourMode          ; $04 Colour
>ab3a	38 b1					.word	GXFontHandler            ; $05 DrawFont
>ab3c	80 b1					.word	GXSpriteHandler          ; $06 DrawSprite
>ab3e	f1 b1					.word	GXSelect                 ; $07 SpriteUse
>ab40	1a b2					.word	GXSelectImage            ; $08 SpriteImage
>ab42	a1 b3					.word	GXCollide                ; $09 SpriteCollide
>ab44	e3 ab					.word	GRUndefined              ; $0a
>ab46	e3 ab					.word	GRUndefined              ; $0b
>ab48	e3 ab					.word	GRUndefined              ; $0c
>ab4a	e3 ab					.word	GRUndefined              ; $0d
>ab4c	e3 ab					.word	GRUndefined              ; $0e
>ab4e	e3 ab					.word	GRUndefined              ; $0f
>ab50	e3 ab					.word	GRUndefined              ; $10
>ab52	e3 ab					.word	GRUndefined              ; $11
>ab54	e3 ab					.word	GRUndefined              ; $12
>ab56	e3 ab					.word	GRUndefined              ; $13
>ab58	e3 ab					.word	GRUndefined              ; $14
>ab5a	e3 ab					.word	GRUndefined              ; $15
>ab5c	e3 ab					.word	GRUndefined              ; $16
>ab5e	e3 ab					.word	GRUndefined              ; $17
>ab60	e3 ab					.word	GRUndefined              ; $18
>ab62	e3 ab					.word	GRUndefined              ; $19
>ab64	e3 ab					.word	GRUndefined              ; $1a
>ab66	e3 ab					.word	GRUndefined              ; $1b
>ab68	e3 ab					.word	GRUndefined              ; $1c
>ab6a	e3 ab					.word	GRUndefined              ; $1d
>ab6c	e3 ab					.word	GRUndefined              ; $1e
>ab6e	e3 ab					.word	GRUndefined              ; $1f
>ab70	e1 ab					.word	GXMove                   ; $20 Move
>ab72	3e ae					.word	GXLine                   ; $21 Line
>ab74	b9 af					.word	GXFrameRectangle         ; $22 FrameRect
>ab76	b6 af					.word	GXFillRectangle          ; $23 FillRect
>ab78	e8 ab					.word	GXFrameCircle            ; $24 FrameCircle
>ab7a	e4 ab					.word	GXFillCircle             ; $25 FillCircle
>ab7c	e3 ab					.word	GRUndefined              ; $26
>ab7e	e3 ab					.word	GRUndefined              ; $27
>ab80	9e af					.word	GXPlotPoint              ; $28 Plot
>ab82	b0 b2					.word	GXMoveSprite             ; $29 SpriteMove
=3					GXMappingPage = 3
=24576					GXMappingAddress = ($2000 * GXMappingPage)
=11					GXEditSlot = 8 + GXMappingPage
=$36					gxzTemp0 = zTemp0
=$38					gxzTemp1 = zTemp1
=$3a					gxzTemp2 = zTemp2
=$3c					gxzScreen = zsTemp
=$627					gxPixelBuffer = numberBuffer
.0671					gxCurrentX:
>0671							.fill 	2
.0673					gxCurrentY:
>0673							.fill 	2
.0675					gxLastX:
>0675							.fill 	2
.0677					gxLastY:
>0677							.fill 	2
.0679					gxX0:
>0679							.fill 	2
.067b					gxY0:
>067b							.fill 	2
.067d					gxX1:
>067d							.fill 	2
.067f					gxY1:
>067f							.fill 	2
.0681					gxSpritesOn:
>0681							.fill 	1
.0682					gxBitmapsOn:
>0682							.fill 	1
.0683					gxBasePage:
>0683							.fill 	1
.0684					gxSpritePage:
>0684							.fill 	1
.0685					gxHeight:
>0685							.fill 	1
.0686					gxMode:
>0686							.fill 	1
.0687					gxColour:
>0687							.fill 	1
.0688					gxEORValue:
>0688							.fill 	1
.0689					gxANDValue:
>0689							.fill 	1
.068a					gxOriginalLUTValue:
>068a							.fill 	1
.068b					gsOffset:
>068b							.fill 	1
.068c					GSCurrentSpriteID:
>068c							.fill 	1
.068d					GSCurrentSpriteAddr:
>068d							.fill 	2
.068f					GXSpriteOffsetBase:
>068f							.fill 	2
.0691					GXSpriteLow:
>0691							.fill 	64
.06d1					GXSpriteHigh:
>06d1							.fill 	64
.ab84					Export_GXGraphicDraw:
.ab84	c9 40		cmp #$40			cmp 	#GCMD_Move					; low instructions don't use coordinates
.ab86	b0 06		bcs $ab8e			bcs 	_GDCoordinate
.ab88	86 36		stx $36				stx 	gxzTemp0 					; save X/Y
.ab8a	84 37		sty $37				sty 	gxzTemp0+1
.ab8c	80 4b		bra $abd9			bra 	_GDExecuteA 				; and execute
.ab8e					_GDCoordinate:
.ab8e	48		pha				pha 								; save AXY
.ab8f	da		phx				phx
.ab90	5a		phy				phy
.ab91	a2 03		ldx #$03			ldx 	#3 							; copy currentX to lastX
.ab93					_GDCopy1:
.ab93	bd 71 06	lda $0671,x			lda 	gxCurrentX,x
.ab96	9d 75 06	sta $0675,x			sta 	gxLastX,x
.ab99	ca		dex				dex
.ab9a	10 f7		bpl $ab93			bpl 	_GDCopy1
.ab9c	68		pla				pla 								; update Y
.ab9d	8d 73 06	sta $0673			sta 	gxCurrentY
.aba0	9c 74 06	stz $0674			stz 	gxCurrentY+1
.aba3	68		pla				pla
.aba4	8d 71 06	sta $0671			sta 	gxCurrentX
.aba7	68		pla				pla 								; get A (command+X.1) back
.aba8	48		pha				pha
.aba9	29 01		and #$01			and 	#1 							; put LSB as MSB of Current.X
.abab	8d 72 06	sta $0672			sta 	gxCurrentX+1
.abae	68		pla				pla 								; get command back
.abaf	29 fe		and #$fe			and 	#$FE 						; lose LSB, chuck the stray X bit
.abb1	48		pha				pha 								; push back.
.abb2	c9 52		cmp #$52			cmp 	#GCMD_SpriteMove 			; move sprite does not clip.
.abb4	f0 17		beq $abcd			beq 	_GDCopyToWorkArea
.abb6	ad 72 06	lda $0672			lda 	gxCurrentX+1 				; X < 256 X okay
.abb9	f0 07		beq $abc2			beq 	_GDCheckY
.abbb	ad 71 06	lda $0671			lda 	gxCurrentX 					; otherwise X < 320 = 256 + 64
.abbe	c9 40		cmp #$40			cmp 	#64
.abc0	b0 08		bcs $abca			bcs 	_GDError1
.abc2					_GDCheckY:
.abc2	ad 73 06	lda $0673			lda 	gxCurrentY 					; check Y < Height.
.abc5	cd 85 06	cmp $0685			cmp 	gxHeight
.abc8	90 03		bcc $abcd			bcc 	_GDCopyToWorkArea
.abca					_GDError1:
.abca	68		pla				pla
.abcb					_GDError2:
.abcb	38		sec				sec
.abcc	60		rts				rts
.abcd					_GDCopyToWorkArea:
.abcd	a2 07		ldx #$07			ldx 	#7 							; copy current and last to gxXY/12 work area
.abcf					_GDCopy2:
.abcf	bd 71 06	lda $0671,x			lda 	gxCurrentX,x
.abd2	9d 79 06	sta $0679,x			sta 	gxX0,x
.abd5	ca		dex				dex
.abd6	10 f7		bpl $abcf			bpl 	_GDCopy2
.abd8	68		pla				pla 								; get command
.abd9					_GDExecuteA:
.abd9	c9 54		cmp #$54			cmp 	#GRFirstFreeCode*2 			; bad ?
.abdb	b0 ee		bcs $abcb			bcs 	_GDError2
.abdd	aa		tax				tax
.abde	7c 30 ab	jmp ($ab30,x)			jmp 	(GRVectorTable,x)
.abe1					GXMove:
.abe1	18		clc				clc
.abe2	60		rts				rts
.abe3					GRUndefined:
>abe3	db						.byte 	$DB 						; causes a break in the emulator
.abe4					GXFillCircle:
.abe4	a9 ff		lda #$ff			lda 	#255
.abe6	80 02		bra $abea			bra 	GXCircle
.abe8					GXFrameCircle:
.abe8	a9 00		lda #$00			lda 	#0
.abea					GXCircle:
.abea	8d 14 07	sta $0714			sta 	gxIsFillMode					; save Fill flag
.abed	ad 82 06	lda $0682			lda 	gxBitmapsOn
.abf0	f0 26		beq $ac18			beq 	_GXCFail
.abf2	20 48 b4	jsr $b448			jsr 	GXSortXY 					; topleft/bottomright
.abf5	20 20 b3	jsr $b320			jsr 	GXOpenBitmap 				; start drawing
.abf8	20 ea ac	jsr $acea			jsr 	GXCircleSetup 				; set up for drawing
.abfb	9c 15 07	stz $0715			stz 	gxYChanged
.abfe					_GXCircleDraw:
.abfe	ad 12 07	lda $0712			lda 	gXCentre					; while x <= y
.ac01	cd 13 07	cmp $0713			cmp 	gYCentre
.ac04	90 0a		bcc $ac10			bcc 	_GXCircleContinue
.ac06	d0 03		bne $ac0b			bne 	_GXNoLast
.ac08	20 1d ac	jsr $ac1d			jsr 	GXPlot1
.ac0b					_GXNoLast:
.ac0b	20 28 b3	jsr $b328			jsr 	GXCloseBitmap 				; close the bitmap
.ac0e	18		clc				clc
.ac0f	60		rts				rts
.ac10					_GXCircleContinue:
.ac10	20 1a ac	jsr $ac1a			jsr 	GXPlot2 					; draw it
.ac13	20 97 ac	jsr $ac97			jsr 	GXCircleMove 				; adjust the coordinates
.ac16	80 e6		bra $abfe			bra 	_GXCircleDraw
.ac18					_GXCFail:
.ac18	38		sec				sec
.ac19	60		rts				rts
.ac1a					GXPlot2:
.ac1a	20 1d ac	jsr $ac1d			jsr 	GXPlot1 						; plot and swap, fall through does twice
.ac1d					GXPlot1:
.ac1d	ad 13 07	lda $0713			lda 	gYCentre 						; if y = 0, don't do it twice (xor)
.ac20	f0 03		beq $ac25			beq 	_GXPlot1Only
.ac22	20 41 ac	jsr $ac41			jsr 	GXPlot0 						; plot and negate
.ac25					_GXPlot1Only:
.ac25	20 41 ac	jsr $ac41			jsr 	GXPlot0 						; twice, undoing negation
.ac28	ad 12 07	lda $0712			lda 	gXCentre 						; swap X and Y
.ac2b	ae 13 07	ldx $0713			ldx	 	gYCentre
.ac2e	8d 13 07	sta $0713			sta 	gYCentre
.ac31	8e 12 07	stx $0712			stx 	gXCentre
.ac34	ad 15 07	lda $0715			lda 	gxYChanged 						; toggle Y Changed flag
.ac37	a9 ff		lda #$ff			lda 	#$FF
.ac39	8d 15 07	sta $0715			sta 	gxYChanged
.ac3c	60		rts				rts
.ac3d	20 41 ac	jsr $ac41			jsr 	GXPlot0 						; do once
.ac40	60		rts				rts
.ac41	ad 14 07	lda $0714	GXPlot0:lda 	gxIsFillMode 					; outline mode, always draw as X or Y will change
.ac44	f0 05		beq $ac4b			beq 	_GXPlot0Always
.ac46	ad 15 07	lda $0715			lda 	gxYChanged						; fill mode, only draw if changed.
.ac49	f0 2d		beq $ac78			beq 	GXPlot0Exit
.ac4b					_GXPlot0Always:
.ac4b	a2 02		ldx #$02			ldx 	#2 								; copy Y1-A => Y0
.ac4d	ad 13 07	lda $0713			lda 	gYCentre
.ac50	20 79 ac	jsr $ac79			jsr 	GXSubCopy
.ac53	a2 00		ldx #$00			ldx 	#0 								; copy X1-A => X0,
.ac55	ad 12 07	lda $0712			lda 	gXCentre
.ac58	20 79 ac	jsr $ac79			jsr 	GXSubCopy
.ac5b	48		pha				pha 									; save last offset X
.ac5c	20 30 b3	jsr $b330			jsr 	GXPositionCalc 					; calculate position/offset.
.ac5f	68		pla				pla
.ac60	0a		asl a				asl 	a 								; store 2 x last offset in gxzTemp0
.ac61	85 36		sta $36				sta 	gxzTemp0
.ac63	64 37		stz $37				stz 	gxzTemp0+1
.ac65	26 37		rol $37				rol 	gxzTemp0+1
.ac67	ad 14 07	lda $0714			lda 	gxIsFillMode
.ac6a	69 80		adc #$80			adc 	#128
.ac6c	20 09 b0	jsr $b009			jsr 	GXDrawLineTemp0 				; routine from Rectangle.
.ac6f	38		sec				sec 									; GY = -GY
.ac70	a9 00		lda #$00			lda 	#0
.ac72	ed 13 07	sbc $0713			sbc 	gYCentre
.ac75	8d 13 07	sta $0713			sta 	gYCentre
.ac78					GXPlot0Exit:
.ac78	60		rts				rts
.ac79					GXSubCopy:
.ac79	85 36		sta $36				sta 	gxzTemp0
.ac7b	64 37		stz $37				stz 	gxzTemp0+1
.ac7d	29 80		and #$80			and 	#$80
.ac7f	f0 02		beq $ac83			beq 	_GXNoSx
.ac81	c6 37		dec $37				dec 	gxzTemp0+1
.ac83					_GXNoSx:
.ac83	38		sec				sec
.ac84	bd 7d 06	lda $067d,x			lda 	gXX1,x
.ac87	e5 36		sbc $36				sbc 	gxzTemp0
.ac89	9d 79 06	sta $0679,x			sta 	gXX0,x
.ac8c	bd 7e 06	lda $067e,x			lda 	gXX1+1,x
.ac8f	e5 37		sbc $37				sbc 	gxzTemp0+1
.ac91	9d 7a 06	sta $067a,x			sta 	gXX0+1,x
.ac94	a5 36		lda $36				lda 	gxzTemp0 						; return A
.ac96	60		rts				rts
.ac97					GXCircleMove:
.ac97	9c 15 07	stz $0715			stz 	gxYChanged 					; clear Y changed flag
.ac9a	a5 39		lda $39				lda 	gxzTemp1+1 					; check sign of D
.ac9c	10 0d		bpl $acab			bpl 	_GXEMPositive
.ac9e	ee 12 07	inc $0712			inc 	gXCentre 					; X++
.aca1	ad 12 07	lda $0712			lda 	gXCentre
.aca4	20 ca ac	jsr $acca			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.aca7	a9 06		lda #$06			lda 	#6  						; and add 6
.aca9	80 15		bra $acc0			bra 	_GXEMAddD
.acab					_GXEMPositive:
.acab	ee 12 07	inc $0712			inc 	gXCentre					; X++
.acae	ce 13 07	dec $0713			dec 	gyCentre 					; Y--
.acb1	38		sec				sec 								; calculate X-Y
.acb2	ad 12 07	lda $0712			lda 	gXCentre
.acb5	ed 13 07	sbc $0713			sbc 	gYCentre
.acb8	20 ca ac	jsr $acca			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.acbb	a9 0a		lda #$0a			lda 	#10  						; and add 10
.acbd	ce 15 07	dec $0715			dec 	gxYChanged
.acc0					_GXEMAddD:
.acc0	18		clc				clc
.acc1	65 38		adc $38				adc 	gxzTemp1
.acc3	85 38		sta $38				sta 	gxzTemp1
.acc5	90 02		bcc $acc9			bcc 	_GXEMNoCarry
.acc7	e6 39		inc $39				inc 	gxzTemp1+1
.acc9					_GXEMNoCarry:
.acc9	60		rts				rts
.acca					_GXAdd4TimesToD:
.acca	85 36		sta $36				sta 	gxzTemp0 					; make 16 bit signed.
.accc	29 80		and #$80			and 	#$80
.acce	f0 02		beq $acd2			beq 	_GXA4Unsigned
.acd0	a9 ff		lda #$ff			lda 	#$FF
.acd2					_GXA4Unsigned:
.acd2	85 37		sta $37				sta 	gxzTemp0+1
.acd4	06 36		asl $36				asl 	gxzTemp0  					; x 4
.acd6	26 37		rol $37				rol 	gxzTemp0+1
.acd8	06 36		asl $36				asl 	gxzTemp0
.acda	26 37		rol $37				rol 	gxzTemp0+1
.acdc	18		clc				clc 								; add
.acdd	a5 36		lda $36				lda		gxzTemp0
.acdf	65 38		adc $38				adc 	gxzTemp1
.ace1	85 38		sta $38				sta 	gxzTemp1
.ace3	a5 37		lda $37				lda		gxzTemp0+1
.ace5	65 39		adc $39				adc 	gxzTemp1+1
.ace7	85 39		sta $39				sta 	gxzTemp1+1
.ace9	60		rts				rts
.acea					GXCircleSetup:
.acea	38		sec				sec
.aceb	ad 7f 06	lda $067f			lda 	gxY1
.acee	ed 7b 06	sbc $067b			sbc 	gxY0
.acf1	4a		lsr a				lsr 	a
.acf2	8d 11 07	sta $0711			sta 	gxRadius
.acf5	a2 00		ldx #$00			ldx 	#0
.acf7	20 19 ad	jsr $ad19			jsr 	_GXCalculateCentre
.acfa	a2 02		ldx #$02			ldx 	#2
.acfc	20 19 ad	jsr $ad19			jsr 	_GXCalculateCentre
.acff	9c 12 07	stz $0712			stz 	gXCentre
.ad02	ad 11 07	lda $0711			lda 	gxRadius
.ad05	8d 13 07	sta $0713			sta 	gYCentre
.ad08	0a		asl a				asl 	a 							; R x 2
.ad09	85 36		sta $36				sta 	gxzTemp0
.ad0b	38		sec				sec
.ad0c	a9 03		lda #$03			lda 	#3
.ad0e	e5 36		sbc $36				sbc 	gxzTemp0
.ad10	85 38		sta $38				sta 	gxzTemp1
.ad12	a9 00		lda #$00			lda 	#0
.ad14	e9 00		sbc #$00			sbc 	#0
.ad16	85 39		sta $39				sta 	gxzTemp1+1
.ad18	60		rts				rts
.ad19					_GXCalculateCentre:
.ad19	38		sec				sec
.ad1a	bd 7d 06	lda $067d,x			lda 	gxX1,x
.ad1d	7d 79 06	adc $0679,x			adc 	gXX0,x
.ad20	9d 7d 06	sta $067d,x			sta 	gXX1,x
.ad23	bd 7e 06	lda $067e,x			lda 	gXX1+1,x
.ad26	7d 7a 06	adc $067a,x			adc 	gXX0+1,x
.ad29	4a		lsr a				lsr 	a
.ad2a	9d 7e 06	sta $067e,x			sta 	gXX1+1,x
.ad2d	7e 7d 06	ror $067d,x			ror 	gXX1,x
.ad30	60		rts				rts
.0711					gxRadius:
>0711							.fill 	1
.0712					gXCentre:
>0712							.fill 	1
.0713					gYCentre:
>0713							.fill 	1
.0714					gxIsFillMode:
>0714							.fill 	1
.0715					gxYChanged:
>0715							.fill  	1
=64000					ScreenSize200 = 320 * 200
=76800					ScreenSize240 = 320 * 240
.ad31					GXClearBitmap:
.ad31	ad 82 06	lda $0682			lda 	gxBitmapsOn 				; check BMP running.
.ad34	f0 24		beq $ad5a			beq 	_GXCBFail
.ad36	20 20 b3	jsr $b320			jsr 	GXOpenBitmap 				; start access
.ad39	a0 07		ldy #$07			ldy 	#ScreenSize200 / 8192 		; X is pages to clear
.ad3b	ad 85 06	lda $0685			lda 	gxHeight
.ad3e	c9 c8		cmp #$c8			cmp 	#200 						; 200 ?
.ad40	a0 09		ldy #$09			ldy 	#ScreenSize240 / 8192
.ad42					_GXCalcLastPage:
.ad42	98		tya				tya 								; add to base page
.ad43	18		clc				clc
.ad44	6d 83 06	adc $0683			adc 	gxBasePage
.ad47	85 0b		sta $0b				sta 	GXEditSlot  				; clear from this page back
.ad49					_GXClearAll:
.ad49	20 5c ad	jsr $ad5c			jsr 	_GXClearBlock 				; clear 8k block
.ad4c	c6 0b		dec $0b				dec 	GXEditSlot  				; back to previous
.ad4e	a5 0b		lda $0b				lda 	GXEditSlot
.ad50	cd 83 06	cmp $0683			cmp 	gxBasePage 					; until before base page
.ad53	b0 f4		bcs $ad49			bcs 	_GXClearAll
.ad55	20 28 b3	jsr $b328			jsr 	GXCloseBitmap	 			; stop access
.ad58	18		clc				clc
.ad59	60		rts				rts
.ad5a					_GXCBFail:
.ad5a	38		sec				sec
.ad5b	60		rts				rts
.ad5c					_GXClearBlock:
.ad5c	a9 00		lda #$00			lda 	#((GXMappingAddress) & $FF)
.ad5e	85 38		sta $38				sta 	0+gxzTemp1
.ad60	a9 60		lda #$60			lda 	#((GXMappingAddress) >> 8)
.ad62	85 39		sta $39				sta 	1+gxzTemp1
.ad64					_GXCB0:
.ad64	a5 36		lda $36				lda 	gxzTemp0
.ad66	a0 00		ldy #$00			ldy 	#0
.ad68					_GXCB1:
.ad68	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad6a	c8		iny				iny
.ad6b	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad6d	c8		iny				iny
.ad6e	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad70	c8		iny				iny
.ad71	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad73	c8		iny				iny
.ad74	d0 f2		bne $ad68			bne 	_GXCB1
.ad76	e6 39		inc $39				inc 	gxzTemp1+1
.ad78	a5 39		lda $39				lda 	gxzTemp1+1
.ad7a	c9 80		cmp #$80			cmp	 	#(GXMappingAddress >> 8)+$20
.ad7c	d0 e6		bne $ad64			bne 	_GXCB0
.ad7e	60		rts				rts
.ad7f					GXInitialise:
.ad7f	64 01		stz $01				stz 	1
.ad81	a9 01		lda #$01			lda 	#1
.ad83	8d 00 d0	sta $d000			sta 	$D000
.ad86	18		clc				clc
.ad87	9c 81 06	stz $0681			stz 	GXSpritesOn
.ad8a	9c 82 06	stz $0682			stz 	GXBitmapsOn
.ad8d	a2 0f		ldx #$0f			ldx 	#15
.ad8f					_GXIClear:
.ad8f	9e 71 06	stz $0671,x			stz 	gxCurrentX,x
.ad92	ca		dex				dex
.ad93	10 fa		bpl $ad8f			bpl 	_GXIClear
.ad95	20 30 ae	jsr $ae30			jsr 	GXClearSpriteStore
.ad98	60		rts				rts
.ad99					GXControlBitmap:
.ad99	64 01		stz $01				stz 	1
.ad9b	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.ad9d	29 01		and #$01			and 	#1 							; set bitmap flag
.ad9f	8d 82 06	sta $0682			sta 	gxBitmapsOn
.ada2	4a		lsr a				lsr 	a 							; bit 0 into carry.
.ada3	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.ada6	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.ada8	29 f7		and #$f7			and 	#$F7 						; clear bitmap bit
.adaa	90 02		bcc $adae			bcc 	_CBNotOn
.adac	09 08		ora #$08			ora 	#$08 						; bitmap on if 1 on 0 off
.adae					_CBNotOn:
.adae	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.adb1	a5 36		lda $36				lda 	gxzTemp0 					; get control settings (bits 0-2)
.adb3	29 07		and #$07			and 	#7
.adb5	8d 00 d1	sta $d100			sta 	$D100 						; write in Vicky Bitmap Control Register #0
.adb8	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.adba	d0 02		bne $adbe			bne 	_CBNotDefault
.adbc	a9 08		lda #$08			lda 	#8  						; if zero, use 8 e.g. bitmap at $10000
.adbe					_CBNotDefault:
.adbe	8d 83 06	sta $0683			sta 	gxBasePage
.adc1	20 22 ae	jsr $ae22			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.adc4	a5 37		lda $37				lda 	gxzTemp0+1 					; copy address into Bitmap address registers
.adc6	8d 03 d1	sta $d103			sta 	$D103
.adc9	a5 36		lda $36				lda 	gxzTemp0
.adcb	8d 02 d1	sta $d102			sta 	$D102
.adce	9c 01 d1	stz $d101			stz 	$D101
.add1	a2 f0		ldx #$f0			ldx 	#240 						; height is 240
.add3	ad 01 d0	lda $d001			lda 	$D001 						; read MCR bit 0
.add6	29 01		and #$01			and 	#1
.add8	f0 02		beq $addc			beq 	_CBHaveHeight
.adda	a2 c8		ldx #$c8			ldx 	#200 						; if bit 0 set 320x200
.addc					_CBHaveHeight
.addc	8e 85 06	stx $0685			stx 	gxHeight
.addf	18		clc				clc
.ade0	60		rts				rts
.ade1					GXControlSprite:
.ade1	64 01		stz $01				stz 	1
.ade3	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.ade5	29 01		and #$01			and 	#1 							; set sprites flag
.ade7	8d 81 06	sta $0681			sta 	gxSpritesOn
.adea	4a		lsr a				lsr 	a 							; bit 0 into carry.
.adeb	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.adee	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.adf0	29 df		and #$df			and 	#$DF 						; clear sprite bit
.adf2	90 02		bcc $adf6			bcc 	_CSNotOn
.adf4	09 20		ora #$20			ora 	#$20 						; sprite on if 1 on 0 off
.adf6					_CSNotOn:
.adf6	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.adf9	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.adfb	d0 02		bne $adff			bne 	_CSNotDefault
.adfd	a9 18		lda #$18			lda 	#24  						; if zero, use 24 e.g. sprites at $30000
.adff					_CSNotDefault:
.adff	8d 84 06	sta $0684			sta 	gxSpritePage
.ae02	20 22 ae	jsr $ae22			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.ae05	a5 36		lda $36				lda 	zTemp0
.ae07	8d 8f 06	sta $068f			sta 	GXSpriteOffsetBase
.ae0a	a5 37		lda $37				lda 	zTemp0+1
.ae0c	8d 90 06	sta $0690			sta 	GXSpriteOffsetBase+1
.ae0f	a2 00		ldx #$00			ldx 	#0 							; disable all sprites, clears all sprite memory.
.ae11					_CSClear:
.ae11	9e 00 d9	stz $d900,x			stz 	$D900,x
.ae14	9e 00 da	stz $da00,x			stz 	$DA00,x
.ae17	ca		dex				dex
.ae18	d0 f7		bne $ae11			bne 	_CSClear
.ae1a	9c 8e 06	stz $068e			stz 	GSCurrentSpriteAddr+1 		; no sprite selected.
.ae1d	20 30 ae	jsr $ae30			jsr 	GXClearSpriteStore
.ae20	18		clc				clc
.ae21	60		rts				rts
.ae22					GXCalculateBaseAddress:
.ae22	85 36		sta $36				sta 	gxzTemp0
.ae24	64 37		stz $37				stz 	gxzTemp0+1
.ae26	a9 05		lda #$05			lda 	#5
.ae28					_GXShift:
.ae28	06 36		asl $36				asl 	gxzTemp0
.ae2a	26 37		rol $37				rol 	gxzTemp0+1
.ae2c	3a		dec a				dec		a
.ae2d	d0 f9		bne $ae28			bne 	_GXShift
.ae2f	60		rts				rts
.ae30					GXClearSpriteStore:
.ae30	a2 3f		ldx #$3f			ldx 	#63 						; erase 64 sprite store elements
.ae32					_GXCSSLoop:
.ae32	9e d1 06	stz $06d1,x			stz 	GXSpriteHigh,x
.ae35	a9 80		lda #$80			lda 	#$80 						; set the 'hidden' bit.
.ae37	9d 91 06	sta $0691,x			sta 	GXSpriteLow,x
.ae3a	ca		dex				dex
.ae3b	10 f5		bpl $ae32			bpl 	_GXCSSLoop
.ae3d	60		rts				rts
.ae3e					GXLine:
.ae3e	ad 82 06	lda $0682			lda 	GXBitmapsOn
.ae41	f0 28		beq $ae6b			beq 	_GXLFail
.ae43	20 20 b3	jsr $b320			jsr 	GXOpenBitmap
.ae46	20 66 b4	jsr $b466			jsr 	GXSortY						; sort pairs so Y1 >= Y0 e.g. top to bottom.
.ae49	20 11 af	jsr $af11			jsr 	GXLineSetup 				; the calculations in the linescanner constructor
.ae4c	20 30 b3	jsr $b330			jsr 	GXPositionCalc 				; calculate position/offset.
.ae4f					_GXDrawLoop:
.ae4f	ac 8b 06	ldy $068b			ldy 	gsOffset 					; draw the pixel
.ae52	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.ae54	2d 89 06	and $0689			and 	gxANDValue
.ae57	4d 88 06	eor $0688			eor 	gxEORValue
.ae5a	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.ae5c	20 6d ae	jsr $ae6d			jsr 	GXLineIsComplete 			; is the line complete ?
.ae5f	f0 05		beq $ae66			beq 	_GXLExit
.ae61	20 88 ae	jsr $ae88			jsr 	GXLineAdvance 				; code as per advance method
.ae64	80 e9		bra $ae4f			bra 	_GXDrawLoop
.ae66					_GXLExit:
.ae66	20 28 b3	jsr $b328			jsr 	GXCloseBitmap
.ae69	18		clc				clc
.ae6a	60		rts				rts
.ae6b					_GXLFail:
.ae6b	38		sec				sec
.ae6c	60		rts				rts
.ae6d					GXLineIsComplete:
.ae6d	ad 18 07	lda $0718			lda 	GXIsDiffYLarger 			; is dy larger
.ae70	d0 0f		bne $ae81			bne 	_GXLICCompareY 				; if so compare Y1/Y0
.ae72	ad 79 06	lda $0679			lda 	GXX0 						; compare X, LSB and MSB
.ae75	4d 7d 06	eor $067d			eor 	GXX1
.ae78	d0 06		bne $ae80			bne 	_GXLICExit
.ae7a	ad 7a 06	lda $067a			lda 	GXX0+1
.ae7d	4d 7e 06	eor $067e			eor 	GXX1+1
.ae80					_GXLICExit:
.ae80	60		rts				rts
.ae81					_GXLICCompareY:
.ae81	ad 7f 06	lda $067f			lda 	GXY1
.ae84	4d 7b 06	eor $067b			eor 	GXY0
.ae87	60		rts				rts
.ae88					GXLineAdvance:
.ae88	18		clc				clc 								; add adjust to position
.ae89	ad 1a 07	lda $071a			lda 	GXPosition
.ae8c	6d 1b 07	adc $071b			adc 	GXAdjust
.ae8f	8d 1a 07	sta $071a			sta 	GXPosition
.ae92	9c 1d 07	stz $071d			stz 	GXAddSelect 				; clear add select flag
.ae95	b0 05		bcs $ae9c			bcs 	_GXLAOverflow 				; if carry out, overflowed.
.ae97	cd 1c 07	cmp $071c			cmp 	GXTotal 					; if exceeded total
.ae9a	90 0a		bcc $aea6			bcc 	_GXLANoExtra
.ae9c					_GXLAOverflow:
.ae9c	ce 1d 07	dec $071d			dec 	GXAddSelect 				; set addselect to $FF
.ae9f	38		sec				sec 								; subtract total and write back
.aea0	ed 1c 07	sbc $071c			sbc 	GXTotal
.aea3	8d 1a 07	sta $071a			sta 	GXPosition
.aea6					_GXLANoExtra:
.aea6	ad 18 07	lda $0718			lda 	GXIsDiffYLarger
.aea9	f0 0d		beq $aeb8			beq 	_GXDXLarger
.aeab	20 0a af	jsr $af0a			jsr 	GXIncrementY
.aeae	ad 1d 07	lda $071d			lda 	GXAddSelect
.aeb1	f0 10		beq $aec3			beq 	_GXLAExit
.aeb3	20 c4 ae	jsr $aec4			jsr 	GXAdjustX
.aeb6	80 0b		bra $aec3			bra 	_GXLAExit
.aeb8					_GXDXLarger:
.aeb8	20 c4 ae	jsr $aec4			jsr 	GXAdjustX
.aebb	ad 1d 07	lda $071d			lda 	GXAddSelect
.aebe	f0 03		beq $aec3			beq 	_GXLAExit
.aec0	20 0a af	jsr $af0a			jsr 	GXIncrementY
.aec3					_GXLAExit:
.aec3	60		rts				rts
.aec4					GXAdjustX:
.aec4	ad 19 07	lda $0719			lda 	GXDXNegative
.aec7	10 25		bpl $aeee			bpl 	_GXAXRight
.aec9	ad 79 06	lda $0679			lda 	GXX0
.aecc	d0 03		bne $aed1			bne 	_GXAXNoBorrow
.aece	ce 7a 06	dec $067a			dec 	GXX0+1
.aed1					_GXAXNoBorrow:
.aed1	ce 79 06	dec $0679			dec 	GXX0
.aed4	ce 8b 06	dec $068b			dec 	gsOffset 					; pixel left
.aed7	ad 8b 06	lda $068b			lda 	gsOffset
.aeda	c9 ff		cmp #$ff			cmp 	#$FF
.aedc	d0 0f		bne $aeed			bne 	_GXAYExit 					; underflow
.aede	c6 3d		dec $3d				dec 	gxzScreen+1 					; borrow
.aee0	a5 3d		lda $3d				lda 	gxzScreen+1 					; gone off page
.aee2	c9 60		cmp #$60			cmp 	#GXMappingAddress >> 8
.aee4	b0 07		bcs $aeed			bcs 	_GXAYExit
.aee6	18		clc				clc
.aee7	69 20		adc #$20			adc 	#$20 						; fix up
.aee9	85 3d		sta $3d				sta 	gxzScreen+1
.aeeb	c6 0b		dec $0b				dec 	GXEditSlot 				; back one page
.aeed					_GXAYExit:
.aeed	60		rts				rts
.aeee					_GXAXRight:
.aeee	ee 79 06	inc $0679			inc 	GXX0
.aef1	d0 03		bne $aef6			bne 	_GXAXNoCarry
.aef3	ee 7a 06	inc $067a			inc 	GXX0+1
.aef6					_GXAXNoCarry:
.aef6	ee 8b 06	inc $068b			inc 	gsOffset 					; pixel right
.aef9	d0 0e		bne $af09			bne 	_GXAXExit 					; if not overflowed, exit.
.aefb	e6 3d		inc $3d				inc 	gxzScreen+1 					; next line
.aefd	a5 3d		lda $3d				lda 	gxzScreen+1
.aeff	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.af01	90 06		bcc $af09			bcc 	_GXAXExit
.af03	e9 20		sbc #$20			sbc 	#$20 						; fix up
.af05	85 3d		sta $3d				sta 	gxzScreen+1
.af07	e6 0b		inc $0b				inc 	GXEditSlot 				; next page
.af09					_GXAXExit:
.af09	60		rts				rts
.af0a					GXIncrementY:
.af0a	ee 7b 06	inc $067b			inc 	GXY0
.af0d	20 86 b3	jsr $b386			jsr 	GXMovePositionDown
.af10	60		rts				rts
.af11					GXLineSetup:
.af11	ad 7f 06	lda $067f			lda 	GXY1
.af14	38		sec				sec
.af15	ed 7b 06	sbc $067b			sbc 	GXY0
.af18	4a		lsr a				lsr 	a
.af19	8d 17 07	sta $0717			sta 	GXDiffY
.af1c	9c 19 07	stz $0719			stz 	GXDXNegative 				; clear -ve flag
.af1f	38		sec				sec
.af20	ad 7d 06	lda $067d			lda 	GXX1
.af23	ed 79 06	sbc $0679			sbc 	GXX0
.af26	8d 16 07	sta $0716			sta 	GXDiffX
.af29	ad 7e 06	lda $067e			lda 	GXX1+1 						; calculate MSB
.af2c	ed 7a 06	sbc $067a			sbc 	GXX0+1
.af2f	6a		ror a				ror 	a 							; rotate bit into DiffX halving it
.af30	6e 16 07	ror $0716			ror 	GXDiffX
.af33	0a		asl a				asl 	a
.af34	10 0c		bpl $af42			bpl 	_GDXNotNegative
.af36	a9 00		lda #$00			lda 	#0 							; make absolute value of |dx|
.af38	38		sec				sec
.af39	ed 16 07	sbc $0716			sbc 	GXDiffX
.af3c	8d 16 07	sta $0716			sta 	GXDiffX
.af3f	ce 19 07	dec $0719			dec 	GXDXNegative 				; -ve flag = $FF.
.af42					_GDXNotNegative:
.af42	9c 18 07	stz $0718			stz 	GXIsDiffYLarger 			; clear larger flag
.af45	ad 17 07	lda $0717			lda 	GXDiffY 					; set adjust and total.
.af48	8d 1b 07	sta $071b			sta 	GXAdjust
.af4b	ad 16 07	lda $0716			lda 	GXDiffX
.af4e	8d 1c 07	sta $071c			sta 	GXTotal
.af51	ad 17 07	lda $0717			lda 	GXDiffY 					; if dy > dx
.af54	cd 16 07	cmp $0716			cmp 	GXDiffX
.af57	90 0f		bcc $af68			bcc 	_GDXNotLarger
.af59	ce 18 07	dec $0718			dec 	GXIsDiffYLarger 			; set the dy larger flag
.af5c	ad 16 07	lda $0716			lda 	GXDiffX 					; set adjust and total other way round
.af5f	8d 1b 07	sta $071b			sta 	GXAdjust
.af62	ad 17 07	lda $0717			lda 	GXDiffY
.af65	8d 1c 07	sta $071c			sta 	GXTotal
.af68					_GDXNotLarger:
.af68	ad 1c 07	lda $071c			lda 	GXTotal
.af6b	4a		lsr a				lsr 	a
.af6c	8d 1a 07	sta $071a			sta 	GXPosition
.af6f	60		rts				rts
.0716					GXDiffX:
>0716							.fill 	1
.0717					GXDiffY:
>0717							.fill 	1
.0718					GXIsDiffYLarger:
>0718							.fill 	1
.0719					GXDXNegative:
>0719							.fill 	1
.071a					GXPosition:
>071a							.fill 	1
.071b					GXAdjust:
>071b							.fill 	1
.071c					GXTotal:
>071c							.fill 	1
.071d					GXAddSelect:
>071d							.fill 	1
.af70					GXSetColourMode:
.af70	a6 36		ldx $36				ldx 	gxzTemp0
.af72	8e 87 06	stx $0687			stx 	gxColour 								; set colour
.af75	a5 37		lda $37				lda 	gxzTemp0+1 								;
.af77	8d 86 06	sta $0686			sta 	gxMode 									; set mode
.af7a	29 03		and #$03			and 	#3 										; only interested in bits 0-3
.af7c	9c 89 06	stz $0689			stz 	gxANDValue 								; initially AND with 0, and EOR with Colour
.af7f	ae 87 06	ldx $0687			ldx 	gxColour
.af82	8e 88 06	stx $0688			stx 	gxEORValue
.af85	c9 02		cmp #$02			cmp 	#2 										; if mode 2/3 And with colour
.af87	90 03		bcc $af8c			bcc 	_GXSDCNotAndColour
.af89	8e 89 06	stx $0689			stx 	gxANDValue
.af8c					_GXSDCNotAndColour:
.af8c	d0 03		bne $af91			bne 	_GXSDCNotAnd 							; mode 2, Don't EOR with colour
.af8e	9c 88 06	stz $0688			stz 	gxEORValue
.af91					_GXSDCNotAnd:
.af91	4a		lsr a				lsr 	a 										; if bit 0 set, 1's complement AND value
.af92	90 08		bcc $af9c			bcc 	_GXSDCNoFlip
.af94	ad 89 06	lda $0689			lda	 	gxANDValue
.af97	49 ff		eor #$ff			eor 	#$FF
.af99	8d 89 06	sta $0689			sta 	gxANDValue
.af9c					_GXSDCNoFlip:
.af9c	18		clc				clc
.af9d	60		rts				rts
.af9e					GXPlotPoint:
.af9e	20 20 b3	jsr $b320			jsr 	GXOpenBitmap 				; start drawing
.afa1	20 30 b3	jsr $b330			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.afa4	ac 8b 06	ldy $068b			ldy 	gsOffset
.afa7	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.afa9	2d 89 06	and $0689			and 	gxANDValue
.afac	4d 88 06	eor $0688			eor 	gxEORValue
.afaf	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.afb1	20 28 b3	jsr $b328			jsr 	GXCloseBitmap 				; stop drawing and exit
.afb4	18		clc				clc
.afb5	60		rts				rts
.afb6					GXFillRectangle:
.afb6	38		sec				sec
.afb7	80 01		bra $afba			bra 	GXRectangle
.afb9					GXFrameRectangle:
.afb9	18		clc				clc
.afba					GXRectangle:
.afba	ad 82 06	lda $0682			lda 	gxBitmapsOn
.afbd	f0 35		beq $aff4			beq 	_GXRFail
.afbf	08		php				php 								; save Fill flag (CS)
.afc0	20 20 b3	jsr $b320			jsr 	GXOpenBitmap 				; start drawing
.afc3	20 48 b4	jsr $b448			jsr 	GXSortXY 					; sort both X and Y so top left/bottom right
.afc6	20 30 b3	jsr $b330			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.afc9	38		sec				sec 								; sec = Draw line
.afca	20 f6 af	jsr $aff6			jsr 	GXDrawLineX1X0 				; draw a line length X1-X0
.afcd	ad 7b 06	lda $067b			lda 	gxY0 						; reached end of rectangle ?
.afd0	cd 7f 06	cmp $067f			cmp 	gxY1
.afd3	f0 19		beq $afee			beq 	_GXRectangleExit
.afd5					_GXRectLoop:
.afd5	20 86 b3	jsr $b386			jsr 	GXMovePositionDown 			; down one.
.afd8	ee 7b 06	inc $067b			inc 	gxY0 						; change Y pos
.afdb	ad 7b 06	lda $067b			lda 	gxY0 						; reached last line
.afde	cd 7f 06	cmp $067f			cmp 	gXY1
.afe1	f0 07		beq $afea			beq 	_GXLastLine
.afe3	28		plp				plp 								; get flag back
.afe4	08		php				php
.afe5	20 f6 af	jsr $aff6			jsr 	GXDrawLineX1X0 				; draw horizontal line
.afe8	80 eb		bra $afd5			bra 	_GXRectLoop
.afea					_GXLastLine:
.afea	38		sec				sec
.afeb	20 f6 af	jsr $aff6			jsr 	GXDrawLineX1X0
.afee					_GXRectangleExit:
.afee	68		pla				pla 								; throw fill flag.
.afef	20 28 b3	jsr $b328			jsr 	GXCloseBitmap 				; stop drawing and exit
.aff2	18		clc				clc
.aff3	60		rts				rts
.aff4					_GXRFail:
.aff4	38		sec				sec
.aff5	60		rts				rts
.aff6					GXDrawLineX1X0:
.aff6	08		php				php 								; save solid/either-end
.aff7	38		sec				sec
.aff8	ad 7d 06	lda $067d			lda		gXX1
.affb	ed 79 06	sbc $0679			sbc 	gXX0
.affe	85 36		sta $36				sta 	gxzTemp0
.b000	ad 7e 06	lda $067e			lda 	gXX1+1
.b003	ed 7a 06	sbc $067a			sbc 	gXX0+1
.b006	85 37		sta $37				sta 	gxzTemp0+1
.b008	28		plp				plp
.b009					GXDrawLineTemp0:
.b009	a5 3c		lda $3c				lda 	gxzScreen 						; push gxzScreen, gsOffset and GXEditSlot on stack
.b00b	48		pha				pha
.b00c	a5 3d		lda $3d				lda 	gxzScreen+1
.b00e	48		pha				pha
.b00f	ad 8b 06	lda $068b			lda 	gsOffset
.b012	48		pha				pha
.b013	a5 0b		lda $0b				lda 	GXEditSlot
.b015	48		pha				pha
.b016	ac 8b 06	ldy $068b			ldy 	gsOffset 					; Y offset
.b019	90 1e		bcc $b039			bcc 	_GXDLTEndPoints 			; if CC draw end points only.
.b01b					_GXDLTLine:
.b01b	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.b01d	2d 89 06	and $0689			and 	gxANDValue
.b020	4d 88 06	eor $0688			eor 	gxEORValue
.b023	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b025	a5 36		lda $36				lda 	gxzTemp0 					; decrement counter
.b027	d0 04		bne $b02d			bne 	_GXDLTNoBorrow
.b029	c6 37		dec $37				dec 	gxzTemp0+1 					; borrow, if goes -ve then exit
.b02b	30 2e		bmi $b05b			bmi 	_GXDLTExit
.b02d					_GXDLTNoBorrow:
.b02d	c6 36		dec $36				dec 	gxzTemp0
.b02f	c8		iny				iny 								; next slot.
.b030	d0 e9		bne $b01b			bne 	_GXDLTLine
.b032	e6 3d		inc $3d				inc 	gxzScreen+1 					; carry to next
.b034	20 69 b0	jsr $b069			jsr 	GXDLTCheckWrap				; check for new page.
.b037	80 e2		bra $b01b			bra 	_GXDLTLine
.b039					_GXDLTEndPoints:
.b039	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.b03b	2d 89 06	and $0689			and 	gxANDValue
.b03e	4d 88 06	eor $0688			eor 	gxEORValue
.b041	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b043	98		tya				tya 								; advance to right side
.b044	18		clc				clc
.b045	65 36		adc $36				adc 	gxzTemp0
.b047	a8		tay				tay
.b048	a5 3d		lda $3d				lda 	gxzScreen+1
.b04a	65 37		adc $37				adc 	gxzTemp0+1
.b04c	85 3d		sta $3d				sta 	gxzScreen+1
.b04e	20 69 b0	jsr $b069			jsr 	GXDLTCheckWrap 			; fix up.
.b051	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.b053	2d 89 06	and $0689			and 	gxANDValue
.b056	4d 88 06	eor $0688			eor 	gxEORValue
.b059	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b05b					_GXDLTExit:
.b05b	68		pla				pla
.b05c	85 0b		sta $0b				sta 	GXEditSlot
.b05e	68		pla				pla
.b05f	8d 8b 06	sta $068b			sta 	gsOffset
.b062	68		pla				pla
.b063	85 3d		sta $3d				sta 	gxzScreen+1
.b065	68		pla				pla
.b066	85 3c		sta $3c				sta 	gxzScreen
.b068	60		rts				rts
.b069					GXDLTCheckWrap:
.b069	a5 3d		lda $3d				lda 	gxzScreen+1 					; check end of page
.b06b	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8)
.b06d	90 06		bcc $b075			bcc 	_GXDLTCWExit
.b06f	e9 20		sbc #$20			sbc 	#$20 						; fix up
.b071	85 3d		sta $3d				sta 	gxzScreen+1
.b073	e6 0b		inc $0b				inc 	GXEditSlot
.b075					_GXDLTCWExit:
.b075	60		rts				rts
.b076					GXDrawGraphicElement:
.b076	8d 1e 07	sta $071e			sta 	gxSize 						; save size
.b079	3a		dec a				dec 	a
.b07a	8d 1f 07	sta $071f			sta 	gxMask 						; and mask
.b07d	ad 82 06	lda $0682			lda 	gxBitmapsOn 				; check BMP on
.b080	f0 67		beq $b0e9			beq 	_GXSLFail
.b082	ad 7b 06	lda $067b			lda 	gxY0 						; push Y on stack
.b085	48		pha				pha
.b086	8c 21 07	sty $0721			sty 	gxAcquireVector+1 			; and acquisition vector
.b089	8e 20 07	stx $0720			stx 	gxAcquireVector
.b08c	20 20 b3	jsr $b320			jsr 	gxOpenBitmap 				; open the bitmap.
.b08f	ad 23 07	lda $0723			lda 	gxUseMode 					; scale bits
.b092	4a		lsr a				lsr 	a
.b093	4a		lsr a				lsr 	a
.b094	4a		lsr a				lsr 	a
.b095	29 07		and #$07			and		#7
.b097	1a		inc a				inc 	a
.b098	8d 22 07	sta $0722			sta 	gxScale
.b09b	64 38		stz $38				stz 	gxzTemp1					; start first line
.b09d					_GXGELoop:
.b09d	a5 38		lda $38				lda 	gxzTemp1 					; current line number to read.
.b09f	2c 23 07	bit $0723			bit 	gxUseMode 					; check for flip.
.b0a2	10 06		bpl $b0aa			bpl		_GXNoVFlip
.b0a4	ad 1f 07	lda $071f			lda 	gxMask
.b0a7	38		sec				sec
.b0a8	e5 38		sbc $38				sbc 	gxzTemp1
.b0aa					_GXNoVFlip:
.b0aa	aa		tax				tax 								; get the Xth line.
.b0ab	20 eb b0	jsr $b0eb			jsr 	_GXCallAcquire 				; get that data.
.b0ae	ad 22 07	lda $0722			lda 	gxScale 					; do scale identical copies of that line.
.b0b1	85 39		sta $39				sta 	gxzTemp1+1
.b0b3					_GXGELoop2:
.b0b3	ad 7b 06	lda $067b			lda 	gxY0 						; off screen
.b0b6	cd 85 06	cmp $0685			cmp 	gxHeight
.b0b9	b0 10		bcs $b0cb			bcs 	_GXDGEExit
.b0bb	20 ee b0	jsr $b0ee			jsr 	GXRenderOneLine 			; render line
.b0be	c6 39		dec $39				dec 	gxzTemp1+1 					; scale times.
.b0c0	d0 f1		bne $b0b3			bne 	_GXGELoop2
.b0c2	e6 38		inc $38				inc 	gxzTemp1 					; done all lines.
.b0c4	a5 38		lda $38				lda 	gxzTemp1
.b0c6	cd 1e 07	cmp $071e			cmp 	gxSize
.b0c9	d0 d2		bne $b09d			bne 	_GXGELoop
.b0cb					_GXDGEExit:
.b0cb	68		pla				pla 								; restore Y for next time
.b0cc	8d 7b 06	sta $067b			sta 	gxY0
.b0cf	ae 22 07	ldx $0722			ldx 	gxScale 					; get scale (1-8)
.b0d2					_GXShiftLeft:
.b0d2	18		clc				clc
.b0d3	ad 1e 07	lda $071e			lda 	gxSize
.b0d6	6d 79 06	adc $0679			adc 	gxX0
.b0d9	8d 79 06	sta $0679			sta 	gxX0
.b0dc	90 03		bcc $b0e1			bcc 	_GXSLNoCarry
.b0de	ee 7a 06	inc $067a			inc 	gxX0+1
.b0e1					_GXSLNoCarry:
.b0e1	ca		dex				dex
.b0e2	d0 ee		bne $b0d2			bne 	_GXShiftLeft
.b0e4	20 28 b3	jsr $b328			jsr 	GXCloseBitmap
.b0e7	18		clc				clc
.b0e8	60		rts				rts
.b0e9					_GXSLFail:
.b0e9	38		sec				sec
.b0ea	60		rts				rts
.b0eb					_GXCallAcquire:
.b0eb	6c 20 07	jmp ($0720)			jmp 	(gxAcquireVector)
.b0ee					GXRenderOneLine:
.b0ee	20 30 b3	jsr $b330			jsr 	GXPositionCalc 				; calculate position/offset.
.b0f1	ac 8b 06	ldy $068b			ldy 	gsOffset 					; Y contains position.
.b0f4	64 3a		stz $3a				stz 	gxzTemp2 					; do size pixels
.b0f6					_GXROLLoop1:
.b0f6	ad 22 07	lda $0722			lda 	gxScale 					; set to do 'scale' times
.b0f9	85 3b		sta $3b				sta 	gxzTemp2+1
.b0fb					_GXROLLoop2:
.b0fb	a5 3a		lda $3a				lda 	gxzTemp2 					; get current pixel
.b0fd	2c 86 06	bit $0686			bit 	gxMode 						; check H Flip
.b100	50 06		bvc $b108			bvc 	_GXNoHFlip
.b102	ad 1f 07	lda $071f			lda 	gxMask
.b105	38		sec				sec
.b106	e5 3a		sbc $3a				sbc 	gxzTemp2
.b108					_GXNoHFlip:
.b108	aa		tax				tax 								; read from the pixel buffer
.b109	bd 27 06	lda $0627,x			lda 	gxPixelBuffer,x
.b10c	d0 07		bne $b115			bne 	_GXDraw 					; draw if non zero
.b10e	ad 23 07	lda $0723			lda 	gxUseMode 					; check to see if solid background
.b111	29 04		and #$04			and 	#4
.b113	f0 0a		beq $b11f			beq 	_GXZeroPixel
.b115					_GXDraw:
.b115	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.b117	2d 89 06	and $0689			and 	gxANDValue
.b11a	5d 27 06	eor $0627,x			eor 	gxPixelBuffer,x
.b11d	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b11f					_GXZeroPixel:
.b11f	c8		iny				iny 								; advance pointer
.b120	d0 05		bne $b127			bne 	_GXNoShift
.b122	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.b124	20 69 b0	jsr $b069			jsr 	GXDLTCheckWrap				; check for new page.
.b127					_GXNoShift:
.b127	c6 3b		dec $3b				dec 	gxzTemp2+1 					; do the inner loop gxScale times.
.b129	d0 d0		bne $b0fb			bne 	_GXROLLoop2
.b12b	e6 3a		inc $3a				inc 	gxzTemp2 					; next pixel.
.b12d	a5 3a		lda $3a				lda 	gxzTemp2
.b12f	cd 1e 07	cmp $071e			cmp 	gxSize
.b132	d0 c2		bne $b0f6			bne 	_GXROLLoop1
.b134	ee 7b 06	inc $067b			inc 	gxY0
.b137	60		rts				rts
.071e					gxSize:
>071e							.fill 	1
.071f					gxMask:
>071f							.fill 	1
.0720					gxAcquireVector:
>0720							.fill 	2
.0722					gxScale:
>0722							.fill 	1
.0723					gxUseMode:
>0723							.fill 	1
.b138					GXFontHandler:
.b138	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b13a	4d 86 06	eor $0686			eor 	gxMode
.b13d	8d 23 07	sta $0723			sta 	gxUseMode
.b140	64 37		stz $37				stz 	gxzTemp0+1 					; gxzTemp0 is font #
.b142	06 36		asl $36				asl	 	gxzTemp0 					; x 2
.b144	26 37		rol $37				rol	 	gxzTemp0+1
.b146	06 36		asl $36				asl	 	gxzTemp0 					; x 4
.b148	26 37		rol $37				rol	 	gxzTemp0+1
.b14a	06 36		asl $36				asl	 	gxzTemp0 					; x 8
.b14c	26 37		rol $37				rol	 	gxzTemp0+1
.b14e	a5 37		lda $37				lda 	gxzTemp0+1 					; put in page C0
.b150	09 c0		ora #$c0			ora 	#$C0
.b152	85 37		sta $37				sta 	gxzTemp0+1
.b154	a9 08		lda #$08			lda 	#8 							; size 8x8
.b156	a2 5e		ldx #$5e			ldx 	#GXGetGraphicDataFont & $FF ; XY = Graphic Data retrieval routine
.b158	a0 b1		ldy #$b1			ldy 	#GXGetGraphicDataFont >> 8
.b15a	20 76 b0	jsr $b076			jsr 	GXDrawGraphicElement
.b15d	60		rts				rts
.b15e					GXGetGraphicDataFont:
.b15e	8a		txa				txa 								; X->Y
.b15f	a8		tay				tay
.b160	a6 01		ldx $01				ldx 	1 							; preserve old value
.b162	a9 01		lda #$01			lda 	#1 							; access page 1 (font memory)
.b164	85 01		sta $01				sta 	1
.b166	b1 36		lda ($36),y			lda 	(gxzTemp0),y 				; read the font element.
.b168	86 01		stx $01				stx 	1 							; put old value back.
.b16a	a2 00		ldx #$00			ldx 	#0 							; do 8 times
.b16c					_GXExpand:
.b16c	9e 27 06	stz $0627,x			stz 	gxPixelBuffer,x 			; zero in pixel buffer
.b16f	0a		asl a				asl 	a 							; shift bit 7 into C
.b170	90 08		bcc $b17a			bcc 	_GXNoPixel
.b172	48		pha				pha 								; if set, set pixel buffer to current colour.
.b173	ad 87 06	lda $0687			lda 	gxColour
.b176	9d 27 06	sta $0627,x			sta 	gxPixelBuffer,x
.b179	68		pla				pla
.b17a					_GXNoPixel:
.b17a	e8		inx				inx 								; do the whole byte.
.b17b	e0 08		cpx #$08			cpx 	#8
.b17d	d0 ed		bne $b16c			bne 	_GXExpand
.b17f	60		rts				rts
.b180					GXSpriteHandler:
.b180	ad 81 06	lda $0681			lda 	gxSpritesOn 				; sprites on ?
.b183	f0 23		beq $b1a8			beq 	_GXSHExit
.b185	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b187	4d 86 06	eor $0686			eor 	gxMode
.b18a	8d 23 07	sta $0723			sta 	gxUseMode
.b18d	a6 36		ldx $36				ldx 	gxzTemp0 					; sprite #
.b18f	da		phx				phx
.b190	20 20 b3	jsr $b320			jsr 	GXOpenBitmap 				; can access sprite information
.b193	68		pla				pla
.b194	20 01 b4	jsr $b401			jsr 	GXFindSprite 				; get the sprite address
.b197	08		php				php
.b198	20 28 b3	jsr $b328			jsr 	GXCloseBitmap
.b19b	28		plp				plp
.b19c	b0 0a		bcs $b1a8			bcs		_GXSHExit 					; exit if find failed.
.b19e	ad 24 07	lda $0724			lda 	GXSizePixels 				; return size
.b1a1	a2 a9		ldx #$a9			ldx 	#GXSpriteAcquire & $FF
.b1a3	a0 b1		ldy #$b1			ldy 	#GXSpriteAcquire >> 8
.b1a5	20 76 b0	jsr $b076			jsr 	GXDrawGraphicElement
.b1a8					_GXSHExit:
.b1a8	60		rts				rts
.b1a9					GXSpriteAcquire:
.b1a9	ad 84 06	lda $0684			lda 	GXSpritePage				; point to base page
.b1ac	85 0b		sta $0b				sta 	GXEditSlot
.b1ae	86 36		stx $36				stx 	zTemp0 						; row number x 1,2,3,4
.b1b0	a9 00		lda #$00			lda 	#0
.b1b2	ae 25 07	ldx $0725			ldx 	GXSizeBits
.b1b5					_GXTimesRowNumber:
.b1b5	18		clc				clc
.b1b6	65 36		adc $36				adc 	zTemp0
.b1b8	ca		dex				dex
.b1b9	10 fa		bpl $b1b5			bpl 	_GXTimesRowNumber
.b1bb	64 37		stz $37				stz 	gxzTemp0+1
.b1bd	0a		asl a				asl 	a 							; row x 2,4,6,8
.b1be	26 37		rol $37				rol 	gxzTemp0+1
.b1c0	0a		asl a				asl 	a 							; row x 4,8,12,16
.b1c1	26 37		rol $37				rol 	gxzTemp0+1
.b1c3	0a		asl a				asl 	a 							; row x 8,16,24,32
.b1c4	26 37		rol $37				rol 	gxzTemp0+1
.b1c6	85 36		sta $36				sta 	gxzTemp0
.b1c8	18		clc				clc 								; add base address.
.b1c9	a5 36		lda $36				lda 	gxzTemp0
.b1cb	6d 27 07	adc $0727			adc 	GXSpriteOffset
.b1ce	85 36		sta $36				sta 	gxzTemp0
.b1d0	a5 37		lda $37				lda 	gxzTemp0+1
.b1d2	6d 28 07	adc $0728			adc 	GXSpriteOffset+1
.b1d5					_GXSAFindPage:
.b1d5	c9 20		cmp #$20			cmp 	#$20 						; on this page
.b1d7	90 06		bcc $b1df			bcc 	_GXSAFoundPage
.b1d9	e9 20		sbc #$20			sbc 	#$20 						; forward one page
.b1db	e6 0b		inc $0b				inc 	GXEditSlot
.b1dd	80 f6		bra $b1d5			bra 	_GXSAFindPage
.b1df					_GXSAFoundPage:
.b1df	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; physical address of page.
.b1e1	85 37		sta $37				sta 	gxzTemp0+1 					; gxzTemp0 now points to the page
.b1e3	a0 00		ldy #$00			ldy 	#0
.b1e5					_GXSACopyLoop:
.b1e5	b1 36		lda ($36),y			lda 	(gxzTemp0),y
.b1e7	99 27 06	sta $0627,y			sta 	gxPixelBuffer,y
.b1ea	c8		iny				iny
.b1eb	cc 24 07	cpy $0724			cpy 	GXSizePixels
.b1ee	d0 f5		bne $b1e5			bne 	_GXSACopyLoop
.b1f0	60		rts				rts
.b1f1					GXSelect:
.b1f1	ad 81 06	lda $0681			lda 	gxSpritesOn
.b1f4	f0 22		beq $b218			beq 	_GXSFail
.b1f6	a5 36		lda $36				lda 	gxzTemp0 					; illegal sprite #
.b1f8	c9 40		cmp #$40			cmp 	#64
.b1fa	b0 1c		bcs $b218			bcs 	_GXSFail
.b1fc	8d 8c 06	sta $068c			sta 	GSCurrentSpriteID
.b1ff	a4 37		ldy $37				ldy 	gxzTemp0+1 					; control value.
.b201	a9 00		lda #$00			lda  	#0 							; multiply sprite # x 8 => A
.b203	06 36		asl $36				asl 	gxzTemp0
.b205	06 36		asl $36				asl 	gxzTemp0
.b207	06 36		asl $36				asl 	gxzTemp0
.b209	2a		rol a				rol 	a
.b20a	69 d9		adc #$d9			adc 	#$D9 						; sprite area
.b20c	8d 8e 06	sta $068e			sta 	GSCurrentSpriteAddr+1 		; address to GSCurrentSprite and gxzTemp
.b20f	85 37		sta $37				sta 	gxzTemp0+1
.b211	a5 36		lda $36				lda 	gxzTemp0
.b213	8d 8d 06	sta $068d			sta 	GSCurrentSpriteAddr
.b216	18		clc				clc
.b217	60		rts				rts
.b218					_GXSFail:
.b218	38		sec				sec
.b219	60		rts				rts
.b21a					GXSelectImage:
.b21a	ad 81 06	lda $0681			lda 	gxSpritesOn
.b21d	f0 74		beq $b293			beq 	_GXSIFail
.b21f	ad 8e 06	lda $068e			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b222	f0 6f		beq $b293			beq 	_GXSIFail 					; (checking the MSB)
.b224	64 01		stz $01				stz 	1
.b226	a5 37		lda $37				lda 	gxzTemp0+1 					; push show/hide on the stack.
.b228	d0 6b		bne $b295			bne 	_GXSIHide
.b22a	a5 36		lda $36				lda 	gxzTemp0 					; sprite image
.b22c	48		pha				pha
.b22d	20 20 b3	jsr $b320			jsr 	GXOpenBitmap
.b230	68		pla				pla
.b231	20 01 b4	jsr $b401			jsr 	GXFindSprite
.b234	b0 5a		bcs $b290			bcs 	_GXSICloseFail 				; no image
.b236	a0 01		ldy #$01			ldy 	#1
.b238	ad 8d 06	lda $068d			lda 	GSCurrentSpriteAddr
.b23b	85 36		sta $36				sta 	gxzTemp0
.b23d	ad 8e 06	lda $068e			lda 	GSCurrentSpriteAddr+1
.b240	85 37		sta $37				sta 	gxzTemp0+1
.b242	ad 27 07	lda $0727			lda 	GXSpriteOffset
.b245	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b247	18		clc				clc
.b248	ad 28 07	lda $0728			lda 	GXSpriteOffset+1
.b24b	6d 8f 06	adc $068f			adc 	GXSpriteOffsetBase
.b24e	c8		iny				iny
.b24f	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b251	ad 90 06	lda $0690			lda 	GXSpriteOffsetBase+1
.b254	69 00		adc #$00			adc 	#0
.b256	c8		iny				iny
.b257	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b259	ad 25 07	lda $0725			lda 	GXSizeBits 					; get raw size
.b25c	49 03		eor #$03			eor 	#3 							; make it right (00=32 etc.)
.b25e	2a		rol a				rol 	a 							; x 2
.b25f	0a		asl a				asl 	a 							; x 4
.b260	0a		asl a				asl 	a 							; x 8
.b261	0a		asl a				asl 	a 							; x 16
.b262	0d 26 07	ora $0726			ora 	GXSpriteLUT 				; Or with LUT
.b265	0a		asl a				asl 	a 							; 1 shift
.b266	09 01		ora #$01			ora 	#1 							; enable sprite.
.b268	92 36		sta ($36)			sta 	(gxzTemp0) 					; and write back
.b26a	20 28 b3	jsr $b328			jsr 	GXCloseBitmap
.b26d	ae 8c 06	ldx $068c			ldx 	GSCurrentSpriteID 			; point to sprite entries.
.b270	bd d1 06	lda $06d1,x			lda 	GXSpriteHigh,x 				; clear upper two bits of size
.b273	29 3f		and #$3f			and 	#$3F
.b275	9d d1 06	sta $06d1,x			sta 	GXSpriteHigh,x
.b278	ad 25 07	lda $0725			lda 	GXSizeBits 					; get bit size
.b27b	6a		ror a				ror 	a 							; shift into bits 6/7
.b27c	6a		ror a				ror 	a
.b27d	6a		ror a				ror 	a
.b27e	29 c0		and #$c0			and 	#$C0
.b280	1d d1 06	ora $06d1,x			ora 	GXSpriteHigh,x 				; put in  upper 2 bits of sprite data
.b283	9d d1 06	sta $06d1,x			sta 	GXSpriteHigh,x
.b286	bd 91 06	lda $0691,x			lda 	GXSpriteLow,x 				; clear hidden flag.
.b289	29 7f		and #$7f			and 	#$7F
.b28b	9d 91 06	sta $0691,x			sta 	GXSpriteLow,x
.b28e	18		clc				clc
.b28f	60		rts				rts
.b290					_GXSICloseFail:
.b290	20 28 b3	jsr $b328			jsr 	GXCloseBitmap
.b293					_GXSIFail:
.b293	38		sec				sec
.b294	60		rts				rts
.b295					_GXSIHide:
.b295	ad 8d 06	lda $068d			lda 	GSCurrentSpriteAddr  		; get Sprite h/w address and write there
.b298	85 36		sta $36				sta 	gxzTemp0
.b29a	ad 8e 06	lda $068e			lda 	GSCurrentSpriteAddr+1
.b29d	85 37		sta $37				sta 	gxzTemp0+1
.b29f	a9 00		lda #$00			lda 	#0
.b2a1	92 36		sta ($36)			sta 	(gxzTemp0)
.b2a3	ae 8c 06	ldx $068c			ldx 	GSCurrentSpriteID 			; get sprite ID
.b2a6	bd 91 06	lda $0691,x			lda 	GXSpriteLow,x 				; set the hidden bit.
.b2a9	09 80		ora #$80			ora 	#$80
.b2ab	9d 91 06	sta $0691,x			sta 	GXSpriteLow,x
.b2ae	18		clc				clc
.b2af	60		rts				rts
.b2b0					GXMoveSprite:
.b2b0	ad 81 06	lda $0681			lda 	gxSpritesOn
.b2b3	f0 65		beq $b31a			beq 	_GXSIFail
.b2b5	ad 8e 06	lda $068e			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b2b8	f0 60		beq $b31a			beq 	_GXSIFail
.b2ba	85 37		sta $37				sta 	gxzTemp0+1
.b2bc	a0 04		ldy #$04			ldy 	#4
.b2be	ad 8d 06	lda $068d			lda 	GSCurrentSpriteAddr
.b2c1	85 36		sta $36				sta 	gxzTemp0
.b2c3	ae 8c 06	ldx $068c			ldx 	GSCurrentSpriteID 			; get the size from the upper two bits
.b2c6	bd d1 06	lda $06d1,x			lda 	GXSpriteHigh,x
.b2c9	2a		rol a				rol 	a	 						; into bits 0,1.
.b2ca	2a		rol a				rol 	a
.b2cb	2a		rol a				rol 	a
.b2cc	29 03		and #$03			and 	#3
.b2ce	aa		tax				tax
.b2cf	bd 1c b3	lda $b31c,x			lda 	_GXMSOffset,x 				; get 32-SpriteSize/2
.b2d2	48		pha				pha
.b2d3	18		clc				clc
.b2d4	6d 79 06	adc $0679			adc 	gxX0						; copy position.
.b2d7	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2d9	c8		iny				iny
.b2da	ad 7a 06	lda $067a			lda 	gxX0+1
.b2dd	69 00		adc #$00			adc 	#0
.b2df	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2e1	c8		iny				iny
.b2e2	68		pla				pla
.b2e3	18		clc				clc
.b2e4	6d 7b 06	adc $067b			adc 	gxY0
.b2e7	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2e9	a9 00		lda #$00			lda 	#0
.b2eb	69 00		adc #$00			adc 	#0
.b2ed	c8		iny				iny
.b2ee	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2f0	4e 7a 06	lsr $067a			lsr 	gxX0+1 						; divide X by 4
.b2f3	6e 79 06	ror $0679			ror 	gxX0
.b2f6	4e 79 06	lsr $0679			lsr 	gxX0
.b2f9	4e 7b 06	lsr $067b			lsr 	gxY0 						; divide Y by 4
.b2fc	4e 7b 06	lsr $067b			lsr 	gxY0
.b2ff	ae 8c 06	ldx $068c			ldx 	GSCurrentSpriteID 			; copy X/4 and Y/4 into the status bytes
.b302	bd 91 06	lda $0691,x			lda 	GXSpriteLow,x
.b305	29 80		and #$80			and 	#$80
.b307	0d 79 06	ora $0679			ora 	gxX0
.b30a	9d 91 06	sta $0691,x			sta 	GXSpriteLow,x
.b30d	bd d1 06	lda $06d1,x			lda 	GXSpriteHigh,x
.b310	29 c0		and #$c0			and 	#$C0
.b312	0d 7b 06	ora $067b			ora 	gxY0
.b315	9d d1 06	sta $06d1,x			sta 	GXSpriteHigh,x
.b318	18		clc				clc
.b319	60		rts				rts
.b31a					_GXSIFail:
.b31a	38		sec				sec
.b31b	60		rts				rts
.b31c					_GXMSOffset:
>b31c	1c						.byte 	32-8/2
>b31d	18						.byte 	32-16/2
>b31e	14						.byte 	32-24/2
>b31f	10						.byte 	32-32/2
.b320					GXOpenBitmap:
.b320	78		sei				sei 								; no interrupts here
.b321	a5 0b		lda $0b				lda 	GXEditSlot 					; Save the original LUT slot value
.b323	8d 8a 06	sta $068a			sta 	gxOriginalLUTValue
.b326	58		cli				cli
.b327	60		rts				rts
.b328					GXCloseBitmap:
.b328	78		sei				sei
.b329	ad 8a 06	lda $068a			lda 	gxOriginalLUTValue 			; restore LUT slot value
.b32c	85 0b		sta $0b				sta 	GXEditSlot
.b32e	58		cli				cli
.b32f	60		rts				rts
.b330					GXPositionCalc:
.b330	a5 36		lda $36				lda 	gxzTemp0 					; save temp memory slot
.b332	48		pha				pha
.b333	ad 7b 06	lda $067b			lda 	GXY0 						; gxzScreen = Y0
.b336	85 3c		sta $3c				sta 	gxzScreen
.b338	64 3d		stz $3d				stz 	gxzScreen+1
.b33a	06 3c		asl $3c				asl 	gxzScreen 						; gxzScreen = Y0 * 4
.b33c	26 3d		rol $3d				rol 	gxzScreen+1
.b33e	06 3c		asl $3c				asl 	gxzScreen
.b340	26 3d		rol $3d				rol 	gxzScreen+1
.b342	18		clc				clc 								; gxzScreen = Y0 * 5, as it's still in A
.b343	65 3c		adc $3c				adc 	gxzScreen
.b345	85 3c		sta $3c				sta 	gxzScreen
.b347	90 02		bcc $b34b			bcc 	_GXPCNoCarry
.b349	e6 3d		inc $3d				inc 	gxzScreen+1
.b34b					_GXPCNoCarry:
.b34b	06 3c		asl $3c				asl 	gxzScreen 						; now Y0 * 10. Needs to be multiplied by another
.b34d	26 3d		rol $3d				rol 	gxzScreen+1 					; 32. At this point the MSB contains the offset
.b34f	a5 3d		lda $3d				lda	 	gxzScreen+1 					; so save this in zTemp0 and zero it.
.b351	85 36		sta $36				sta 	gxzTemp0
.b353	64 3d		stz $3d				stz 	gxzScreen+1
.b355	a9 05		lda #$05			lda 	#5 							; now multiply by 32, this puts this in the range 0..8191
.b357					_GXPCMultiply32:
.b357	06 3c		asl $3c				asl 	gxzScreen
.b359	26 3d		rol $3d				rol 	gxzScreen+1
.b35b	3a		dec a				dec 	a
.b35c	d0 f9		bne $b357			bne 	_GXPCMultiply32
.b35e	18		clc				clc
.b35f	ad 79 06	lda $0679			lda 	GXX0 						; add X to this value, put the result in gsOffset, gxzScreen has to be on a page boundary
.b362	65 3c		adc $3c				adc 	gxzScreen
.b364	8d 8b 06	sta $068b			sta 	gsOffset
.b367	ad 7a 06	lda $067a			lda 	GXX0+1
.b36a	65 3d		adc $3d				adc 	gxzScreen+1
.b36c	c9 20		cmp #$20			cmp 	#$20 						; has it overflowed into the next one ?
.b36e	90 04		bcc $b374			bcc 	_GXPCNoOverflow
.b370	29 1f		and #$1f			and 	#$1F 						; fix it up
.b372	e6 36		inc $36				inc 	gxzTemp0 					; add 1 to the page number
.b374					_GXPCNoOverflow:
.b374	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; make it the address mapped in.
.b376	85 3d		sta $3d				sta 	gxzScreen+1
.b378	64 3c		stz $3c				stz 	gxzScreen
.b37a	18		clc				clc
.b37b	a5 36		lda $36				lda 	gxzTemp0 					; get the page number
.b37d	6d 83 06	adc $0683			adc 	gxBasePage 					; by adding the base page
.b380	85 0b		sta $0b				sta 	GXEditSlot 				; and map it into memory.
.b382	68		pla				pla
.b383	85 36		sta $36				sta 	gxzTemp0
.b385	60		rts				rts
.b386					GXMovePositionDown:
.b386	18		clc				clc 								; add 320 to offset/temp+1
.b387	ad 8b 06	lda $068b			lda 	gsOffset
.b38a	69 40		adc #$40			adc 	#64
.b38c	8d 8b 06	sta $068b			sta 	gsOffset
.b38f	a5 3d		lda $3d				lda 	gxzScreen+1
.b391	69 01		adc #$01			adc 	#1
.b393	85 3d		sta $3d				sta 	gxzScreen+1
.b395	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page
.b397	90 07		bcc $b3a0			bcc 	_GXMPDExit
.b399	38		sec				sec  								; next page
.b39a	e9 20		sbc #$20			sbc 	#$20
.b39c	85 3d		sta $3d				sta 	gxzScreen+1
.b39e	e6 0b		inc $0b				inc 	GXEditSlot
.b3a0					_GXMPDExit:
.b3a0	60		rts				rts
.b3a1					GXCollide:
.b3a1	a5 36		lda $36				lda 	gxzTemp0 					; check if sprite numbers are legal.
.b3a3	aa		tax				tax
.b3a4	05 37		ora $37				ora 	gxzTemp0+1
.b3a6	29 c0		and #$c0			and 	#$C0
.b3a8	38		sec				sec
.b3a9	d0 53		bne $b3fe			bne 	_GXCollideFail 				; if either >= 64, fail.
.b3ab	a4 37		ldy $37				ldy 	gxzTemp0+1 					; at this point X is 1st sprite and Y is 2nd sprite.
.b3ad	b9 91 06	lda $0691,y			lda 	GXSpriteLow,y 				; check if either hidden bit is set
.b3b0	1d 91 06	ora $0691,x			ora 	GXSpriteLow,x
.b3b3	30 48		bmi $b3fd			bmi 	_GXOkayFail 				; if either hidden, then they cannot collide.
.b3b5	18		clc				clc 								; need to calculate sum of sizes.
.b3b6	b9 d1 06	lda $06d1,y			lda 	GXSpriteHigh,y
.b3b9	7d d1 06	adc $06d1,x			adc 	GXSpriteHigh,x 				; at this point, CS, Bit 6 and 7 contain that sum.
.b3bc	29 c0		and #$c0			and 	#$C0 					 	; mask off
.b3be	6a		ror a				ror 	a 							; 5/6/7
.b3bf	4a		lsr a				lsr 	a 							; 4/5/6
.b3c0	4a		lsr a				lsr 	a 							; 3/4/5
.b3c1	4a		lsr a				lsr 	a 							; 2/3/4
.b3c2	18		clc				clc
.b3c3	69 08		adc #$08			adc 	#$08
.b3c5	4a		lsr a				lsr 	a 							; adjust because all coordinates are divided by 4 to store.
.b3c6	4a		lsr a				lsr 	a
.b3c7	85 38		sta $38				sta 	gxzTemp1 					; so the difference between the centres has to be less than this.
.b3c9	b9 d1 06	lda $06d1,y			lda 	GXSpriteHigh,y 				; calculate y1-y0
.b3cc	29 3f		and #$3f			and 	#$3F
.b3ce	85 39		sta $39				sta 	gxzTemp1+1
.b3d0	38		sec				sec
.b3d1	bd d1 06	lda $06d1,x			lda 	GXSpriteHigh,x
.b3d4	29 3f		and #$3f			and 	#$3F
.b3d6	e5 39		sbc $39				sbc 	gxzTemp1+1
.b3d8	b0 03		bcs $b3dd			bcs 	_GXCAbs1 					; calculate |y1-y0|
.b3da	49 ff		eor #$ff			eor 	#$FF
.b3dc	1a		inc a				inc 	a
.b3dd					_GXCAbs1:
.b3dd	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b3df	b0 1c		bcs $b3fd			bcs 	_GXOkayFail
.b3e1	85 39		sta $39				sta 	gxzTemp1+1 					; save |y1-y0|
.b3e3	38		sec				sec 								; calculate |x1-x0|
.b3e4	b9 91 06	lda $0691,y			lda 	GXSpriteLow,y
.b3e7	fd 91 06	sbc $0691,x			sbc 	GXSpriteLow,x
.b3ea	b0 03		bcs $b3ef			bcs 	_GXCAbs2
.b3ec	49 ff		eor #$ff			eor 	#$FF
.b3ee	1a		inc a				inc 	a
.b3ef					_GXCAbs2:
.b3ef	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b3f1	b0 0a		bcs $b3fd			bcs 	_GXOkayFail
.b3f3	c5 39		cmp $39				cmp 	gxzTemp1+1 					; is it less than the previous one.
.b3f5	90 02		bcc $b3f9			bcc 	_GXCHaveLowest
.b3f7	a5 39		lda $39				lda 	gxzTemp1+1 					; if not, that's the smallest difference.
.b3f9					_GXCHaveLowest:
.b3f9	0a		asl a				asl 	a 							; scale to allow for >> 2
.b3fa	0a		asl a				asl 	a
.b3fb	18		clc				clc
.b3fc	60		rts				rts
.b3fd					_GXOkayFail:
.b3fd	18		clc				clc
.b3fe					_GXCollideFail:
.b3fe	a9 ff		lda #$ff			lda 	#$FF
.b400	60		rts				rts
.b401					GXFindSprite:
.b401	aa		tax				tax
.b402	ad 84 06	lda $0684			lda 	GXSpritePage 				; access the base page of the sprite
.b405	85 0b		sta $0b				sta 	GXEditSlot
.b407	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; check a valid sprite
.b40a	1d 00 60	ora $6000,x			ora 	GXMappingAddress,x
.b40d	f0 33		beq $b442			beq 	_GXFSFail
.b40f	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; MSB
.b412	8d 28 07	sta $0728			sta 	GXSpriteOffset+1
.b415	bd 00 60	lda $6000,x			lda 	GXMappingAddress,x 			; LSB
.b418	48		pha				pha 								; save twice
.b419	48		pha				pha
.b41a	29 03		and #$03			and 	#3 							; get sprite size
.b41c	8d 25 07	sta $0725			sta 	GXSizeBits 					; save raw (0-3)
.b41f	aa		tax				tax
.b420	bd 44 b4	lda $b444,x			lda 	_GXFXSSTTable,x 			; read sprite size
.b423	8d 24 07	sta $0724			sta 	GXSizePixels 					; save (8/16/24/32)
.b426	68		pla				pla 								; get LUT
.b427	4a		lsr a				lsr		a
.b428	4a		lsr a				lsr		a
.b429	29 03		and #$03			and 	#3
.b42b	8d 26 07	sta $0726			sta 	GXSpriteLUT
.b42e	68		pla				pla 								; address, neeeds to be x 4
.b42f	29 f0		and #$f0			and 	#$F0
.b431	8d 27 07	sta $0727			sta 	GXSpriteOffset
.b434	0e 27 07	asl $0727			asl 	GXSpriteOffset
.b437	2e 28 07	rol $0728			rol 	GXSpriteOffset+1
.b43a	0e 27 07	asl $0727			asl 	GXSpriteOffset
.b43d	2e 28 07	rol $0728			rol 	GXSpriteOffset+1
.b440	18		clc				clc
.b441	60		rts				rts
.b442					_GXFSFail:
.b442	38		sec				sec
.b443	60		rts				rts
.b444					_GXFXSSTTable:
>b444	08 10 18 20					.byte 	8,16,24,32
.0724					GXSizePixels:
>0724							.fill 	1
.0725					GXSizeBits:
>0725							.fill 	1
.0726					GXSpriteLUT:
>0726							.fill 	1
.0727					GXSpriteOffset:
>0727							.fill 	2
.b448					GXSortXY:
.b448	20 66 b4	jsr $b466			jsr 	GXSortY 					; will be sorted on Y now
.b44b	ad 79 06	lda $0679			lda 	gxX0 						; compare X0 v X1
.b44e	cd 7d 06	cmp $067d			cmp 	gxX1
.b451	ad 7a 06	lda $067a			lda 	gXX0+1
.b454	ed 7e 06	sbc $067e			sbc 	gXX1+1
.b457	90 0c		bcc $b465			bcc 	_GXSXYExit 					; X0 < X1 exit
.b459	a2 00		ldx #$00			ldx 	#0 							; swap them over
.b45b	a0 04		ldy #$04			ldy 	#4
.b45d	20 7a b4	jsr $b47a			jsr 	GXSwapXY
.b460	e8		inx				inx
.b461	c8		iny				iny
.b462	20 7a b4	jsr $b47a			jsr 	GXSwapXY
.b465					_GXSXYExit:
.b465	60		rts				rts
.b466					GXSortY:
.b466	ad 7b 06	lda $067b			lda 	gxY0 						; if Y0 >= Y1
.b469	cd 7f 06	cmp $067f			cmp 	gxY1
.b46c	90 0b		bcc $b479			bcc 	_GXSYSorted
.b46e	a2 03		ldx #$03			ldx 	#3 							; swap 3-0
.b470	a0 07		ldy #$07			ldy 	#7 							; with 4-7
.b472					_GXSwap1:
.b472	20 7a b4	jsr $b47a			jsr 	GXSwapXY
.b475	88		dey				dey
.b476	ca		dex				dex
.b477	10 f9		bpl $b472			bpl 	_GXSwap1
.b479					_GXSYSorted:
.b479	60		rts				rts
.b47a					GXSwapXY:
.b47a	bd 79 06	lda $0679,x			lda 	gxX0,x
.b47d	48		pha				pha
.b47e	b9 79 06	lda $0679,y			lda 	gxX0,y
.b481	9d 79 06	sta $0679,x			sta 	gxX0,x
.b484	68		pla				pla
.b485	99 79 06	sta $0679,y			sta 	gxX0,y
.b488	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_tokeniser.module

=1					tokeniserIntegrated=1
.b489					KeywordSet0:
>b489	00 65					.text	0,$65,""               ; $80 !0:EOF
>b48b	00 58					.text	0,$58,""               ; $81 !1:SH1
>b48d	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b48f	04 fe 41 42 53 28			.text	4,$fe,"ABS("           ; $83 ABS(
>b495	06 93 41 4c 4c 4f 43 28			.text	6,$93,"ALLOC("         ; $84 ALLOC(
>b49d	04 ff 41 53 43 28			.text	4,$ff,"ASC("           ; $85 ASC(
>b4a3	05 29 43 48 52 24 28			.text	5,$29,"CHR$("          ; $86 CHR$(
>b4aa	05 41 44 45 45 4b 28			.text	5,$41,"DEEK("          ; $87 DEEK(
>b4b1	06 aa 45 56 45 4e 54 28			.text	6,$aa,"EVENT("         ; $88 EVENT(
>b4b9	05 6b 46 41 4c 53 45			.text	5,$6b,"FALSE"          ; $89 FALSE
>b4c0	05 44 46 52 41 43 28			.text	5,$44,"FRAC("          ; $8a FRAC(
>b4c7	04 0d 48 49 54 28			.text	4,$0d,"HIT("           ; $8b HIT(
>b4cd	04 13 49 4e 54 28			.text	4,$13,"INT("           ; $8c INT(
>b4d3	06 a7 49 53 56 41 4c 28			.text	6,$a7,"ISVAL("         ; $8d ISVAL(
>b4db	05 5c 4a 4f 59 42 28			.text	5,$5c,"JOYB("          ; $8e JOYB(
>b4e2	05 72 4a 4f 59 58 28			.text	5,$72,"JOYX("          ; $8f JOYX(
>b4e9	05 73 4a 4f 59 59 28			.text	5,$73,"JOYY("          ; $90 JOYY(
>b4f0	06 77 4c 45 46 54 24 28			.text	6,$77,"LEFT$("         ; $91 LEFT$(
>b4f8	04 07 4c 45 4e 28			.text	4,$07,"LEN("           ; $92 LEN(
>b4fe	04 0e 4d 41 58 28			.text	4,$0e,"MAX("           ; $93 MAX(
>b504	05 26 4d 49 44 24 28			.text	5,$26,"MID$("          ; $94 MID$(
>b50b	04 0c 4d 49 4e 28			.text	4,$0c,"MIN("           ; $95 MIN(
>b511	04 19 4e 4f 54 28			.text	4,$19,"NOT("           ; $96 NOT(
>b517	05 4d 50 45 45 4b 28			.text	5,$4d,"PEEK("          ; $97 PEEK(
>b51e	08 3c 50 4c 41 59 49 4e			.text	8,$3c,"PLAYING("       ; $98 PLAYING(
>b526	47 28
>b528	07 e9 52 41 4e 44 4f 4d			.text	7,$e9,"RANDOM("        ; $99 RANDOM(
>b530	28
>b531	07 ca 52 49 47 48 54 24			.text	7,$ca,"RIGHT$("        ; $9a RIGHT$(
>b539	28
>b53a	04 0c 52 4e 44 28			.text	4,$0c,"RND("           ; $9b RND(
>b540	04 10 53 47 4e 28			.text	4,$10,"SGN("           ; $9c SGN(
>b546	04 0e 53 50 43 28			.text	4,$0e,"SPC("           ; $9d SPC(
>b54c	05 45 53 54 52 24 28			.text	5,$45,"STR$("          ; $9e STR$(
>b553	06 a9 54 49 4d 45 52 28			.text	6,$a9,"TIMER("         ; $9f TIMER(
>b55b	04 40 54 52 55 45			.text	4,$40,"TRUE"           ; $a0 TRUE
>b561	04 0b 56 41 4c 28			.text	4,$0b,"VAL("           ; $a1 VAL(
>b567	03 e7 46 4f 52				.text	3,$e7,"FOR"            ; $a2 FOR
>b56c	02 8f 49 46				.text	2,$8f,"IF"             ; $a3 IF
>b570	04 34 50 52 4f 43			.text	4,$34,"PROC"           ; $a4 PROC
>b576	06 c1 52 45 50 45 41 54			.text	6,$c1,"REPEAT"         ; $a5 REPEAT
>b57e	05 79 57 48 49 4c 45			.text	5,$79,"WHILE"          ; $a6 WHILE
>b585	05 66 45 4e 44 49 46			.text	5,$66,"ENDIF"          ; $a7 ENDIF
>b58c	07 0b 45 4e 44 50 52 4f			.text	7,$0b,"ENDPROC"        ; $a8 ENDPROC
>b594	43
>b595	04 3f 4e 45 58 54			.text	4,$3f,"NEXT"           ; $a9 NEXT
>b59b	04 2f 54 48 45 4e			.text	4,$2f,"THEN"           ; $aa THEN
>b5a1	05 8c 55 4e 54 49 4c			.text	5,$8c,"UNTIL"          ; $ab UNTIL
>b5a8	04 2e 57 45 4e 44			.text	4,$2e,"WEND"           ; $ac WEND
>b5ae	02 9b 42 59				.text	2,$9b,"BY"             ; $ad BY
>b5b2	04 1c 43 41 4c 4c			.text	4,$1c,"CALL"           ; $ae CALL
>b5b8	06 b2 43 49 52 43 4c 45			.text	6,$b2,"CIRCLE"         ; $af CIRCLE
>b5c0	05 67 43 4c 45 41 52			.text	5,$67,"CLEAR"          ; $b0 CLEAR
>b5c7	03 e2 43 4c 53				.text	3,$e2,"CLS"            ; $b1 CLS
>b5cc	05 7f 43 4f 4c 4f 52			.text	5,$7f,"COLOR"          ; $b2 COLOR
>b5d3	06 d4 43 4f 4c 4f 55 52			.text	6,$d4,"COLOUR"         ; $b3 COLOUR
>b5db	04 1a 44 41 54 41			.text	4,$1a,"DATA"           ; $b4 DATA
>b5e1	03 da 44 49 4d				.text	3,$da,"DIM"            ; $b5 DIM
>b5e6	04 23 44 4f 4b 45			.text	4,$23,"DOKE"           ; $b6 DOKE
>b5ec	06 db 44 4f 57 4e 54 4f			.text	6,$db,"DOWNTO"         ; $b7 DOWNTO
>b5f4	04 29 45 4c 53 45			.text	4,$29,"ELSE"           ; $b8 ELSE
>b5fa	04 34 46 52 4f 4d			.text	4,$34,"FROM"           ; $b9 FROM
>b600	03 e5 47 46 58				.text	3,$e5,"GFX"            ; $ba GFX
>b605	05 80 47 4f 53 55 42			.text	5,$80,"GOSUB"          ; $bb GOSUB
>b60c	04 39 47 4f 54 4f			.text	4,$39,"GOTO"           ; $bc GOTO
>b612	04 24 48 45 52 45			.text	4,$24,"HERE"           ; $bd HERE
>b618	05 63 49 4d 41 47 45			.text	5,$63,"IMAGE"          ; $be IMAGE
>b61f	05 90 49 4e 50 55 54			.text	5,$90,"INPUT"          ; $bf INPUT
>b626	03 e5 4c 45 54				.text	3,$e5,"LET"            ; $c0 LET
>b62b	04 28 4c 49 4e 45			.text	4,$28,"LINE"           ; $c1 LINE
>b631	05 6b 4c 4f 43 41 4c			.text	5,$6b,"LOCAL"          ; $c2 LOCAL
>b638	03 db 4f 46 46				.text	3,$db,"OFF"            ; $c3 OFF
>b63d	02 9d 4f 4e				.text	2,$9d,"ON"             ; $c4 ON
>b641	07 20 4f 55 54 4c 49 4e			.text	7,$20,"OUTLINE"        ; $c5 OUTLINE
>b649	45
>b64a	07 0f 50 41 4c 45 54 54			.text	7,$0f,"PALETTE"        ; $c6 PALETTE
>b652	45
>b653	04 3f 50 4c 4f 54			.text	4,$3f,"PLOT"           ; $c7 PLOT
>b659	04 2f 50 4f 4b 45			.text	4,$2f,"POKE"           ; $c8 POKE
>b65f	05 8d 50 52 49 4e 54			.text	5,$8d,"PRINT"          ; $c9 PRINT
>b666	04 1c 52 45 41 44			.text	4,$1c,"READ"           ; $ca READ
>b66c	04 2e 52 45 43 54			.text	4,$2e,"RECT"           ; $cb RECT
>b672	03 e4 52 45 4d				.text	3,$e4,"REM"            ; $cc REM
>b677	06 e0 52 45 54 55 52 4e			.text	6,$e0,"RETURN"         ; $cd RETURN
>b67f	05 7b 53 4f 4c 49 44			.text	5,$7b,"SOLID"          ; $ce SOLID
>b686	05 89 53 4f 55 4e 44			.text	5,$89,"SOUND"          ; $cf SOUND
>b68d	06 d7 53 50 52 49 54 45			.text	6,$d7,"SPRITE"         ; $d0 SPRITE
>b695	04 45 54 45 58 54			.text	4,$45,"TEXT"           ; $d1 TEXT
>b69b	02 a3 54 4f				.text	2,$a3,"TO"             ; $d2 TO
>b69f	ff					.text	$FF
.b6a0					KeywordSet1:
>b6a0	00 65					.text	0,$65,""               ; $80 !0:EOF
>b6a2	00 58					.text	0,$58,""               ; $81 !1:SH1
>b6a4	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b6a6	08 4c 41 53 53 45 4d 42			.text	8,$4c,"ASSEMBLE"       ; $83 ASSEMBLE
>b6ae	4c 45
>b6b0	06 d2 41 53 53 45 52 54			.text	6,$d2,"ASSERT"         ; $84 ASSERT
>b6b8	06 bd 42 49 54 4d 41 50			.text	6,$bd,"BITMAP"         ; $85 BITMAP
>b6c0	03 d7 45 4e 44				.text	3,$d7,"END"            ; $86 END
>b6c5	07 11 45 58 50 4c 4f 44			.text	7,$11,"EXPLODE"        ; $87 EXPLODE
>b6cd	45
>b6ce	02 96 47 4f				.text	2,$96,"GO"             ; $88 GO
>b6d2	04 3c 4c 49 53 54			.text	4,$3c,"LIST"           ; $89 LIST
>b6d8	04 20 4c 4f 41 44			.text	4,$20,"LOAD"           ; $8a LOAD
>b6de	03 ea 4e 45 57				.text	3,$ea,"NEW"            ; $8b NEW
>b6e3	04 2e 50 49 4e 47			.text	4,$2e,"PING"           ; $8c PING
>b6e9	07 24 52 45 53 54 4f 52			.text	7,$24,"RESTORE"        ; $8d RESTORE
>b6f1	45
>b6f2	03 f5 52 55 4e				.text	3,$f5,"RUN"            ; $8e RUN
>b6f7	05 8d 53 48 4f 4f 54			.text	5,$8d,"SHOOT"          ; $8f SHOOT
>b6fe	07 2a 53 50 52 49 54 45			.text	7,$2a,"SPRITES"        ; $90 SPRITES
>b706	53
>b707	04 46 53 54 4f 50			.text	4,$46,"STOP"           ; $91 STOP
>b70d	03 ee 57 48 4f				.text	3,$ee,"WHO"            ; $92 WHO
>b712	03 eb 5a 41 50				.text	3,$eb,"ZAP"            ; $93 ZAP
>b717	ff					.text	$FF
.b718					KeywordSet2:
>b718	00 65					.text	0,$65,""               ; $80 !0:EOF
>b71a	00 58					.text	0,$58,""               ; $81 !1:SH1
>b71c	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b71e	03 c8 41 44 43				.text	3,$c8,"ADC"            ; $83 ADC
>b723	03 d3 41 4e 44				.text	3,$d3,"AND"            ; $84 AND
>b728	03 e0 41 53 4c				.text	3,$e0,"ASL"            ; $85 ASL
>b72d	03 c8 42 43 43				.text	3,$c8,"BCC"            ; $86 BCC
>b732	03 d8 42 43 53				.text	3,$d8,"BCS"            ; $87 BCS
>b737	03 d8 42 45 51				.text	3,$d8,"BEQ"            ; $88 BEQ
>b73c	03 df 42 49 54				.text	3,$df,"BIT"            ; $89 BIT
>b741	03 d8 42 4d 49				.text	3,$d8,"BMI"            ; $8a BMI
>b746	03 d5 42 4e 45				.text	3,$d5,"BNE"            ; $8b BNE
>b74b	03 de 42 50 4c				.text	3,$de,"BPL"            ; $8c BPL
>b750	03 d5 42 52 41				.text	3,$d5,"BRA"            ; $8d BRA
>b755	03 df 42 52 4b				.text	3,$df,"BRK"            ; $8e BRK
>b75a	03 db 42 56 43				.text	3,$db,"BVC"            ; $8f BVC
>b75f	03 eb 42 56 53				.text	3,$eb,"BVS"            ; $90 BVS
>b764	03 d2 43 4c 43				.text	3,$d2,"CLC"            ; $91 CLC
>b769	03 d3 43 4c 44				.text	3,$d3,"CLD"            ; $92 CLD
>b76e	03 d8 43 4c 49				.text	3,$d8,"CLI"            ; $93 CLI
>b773	03 e5 43 4c 56				.text	3,$e5,"CLV"            ; $94 CLV
>b778	03 e0 43 4d 50				.text	3,$e0,"CMP"            ; $95 CMP
>b77d	03 eb 43 50 58				.text	3,$eb,"CPX"            ; $96 CPX
>b782	03 ec 43 50 59				.text	3,$ec,"CPY"            ; $97 CPY
>b787	03 cc 44 45 43				.text	3,$cc,"DEC"            ; $98 DEC
>b78c	03 e1 44 45 58				.text	3,$e1,"DEX"            ; $99 DEX
>b791	03 e2 44 45 59				.text	3,$e2,"DEY"            ; $9a DEY
>b796	03 e6 45 4f 52				.text	3,$e6,"EOR"            ; $9b EOR
>b79b	03 da 49 4e 43				.text	3,$da,"INC"            ; $9c INC
>b7a0	03 ef 49 4e 58				.text	3,$ef,"INX"            ; $9d INX
>b7a5	03 f0 49 4e 59				.text	3,$f0,"INY"            ; $9e INY
>b7aa	03 e7 4a 4d 50				.text	3,$e7,"JMP"            ; $9f JMP
>b7af	03 ef 4a 53 52				.text	3,$ef,"JSR"            ; $a0 JSR
>b7b4	03 d1 4c 44 41				.text	3,$d1,"LDA"            ; $a1 LDA
>b7b9	03 e8 4c 44 58				.text	3,$e8,"LDX"            ; $a2 LDX
>b7be	03 e9 4c 44 59				.text	3,$e9,"LDY"            ; $a3 LDY
>b7c3	03 f1 4c 53 52				.text	3,$f1,"LSR"            ; $a4 LSR
>b7c8	03 ed 4e 4f 50				.text	3,$ed,"NOP"            ; $a5 NOP
>b7cd	03 e2 4f 52 41				.text	3,$e2,"ORA"            ; $a6 ORA
>b7d2	03 d9 50 48 41				.text	3,$d9,"PHA"            ; $a7 PHA
>b7d7	03 e8 50 48 50				.text	3,$e8,"PHP"            ; $a8 PHP
>b7dc	03 f0 50 48 58				.text	3,$f0,"PHX"            ; $a9 PHX
>b7e1	03 f1 50 48 59				.text	3,$f1,"PHY"            ; $aa PHY
>b7e6	03 dd 50 4c 41				.text	3,$dd,"PLA"            ; $ab PLA
>b7eb	03 ec 50 4c 50				.text	3,$ec,"PLP"            ; $ac PLP
>b7f0	03 f4 50 4c 58				.text	3,$f4,"PLX"            ; $ad PLX
>b7f5	03 f5 50 4c 59				.text	3,$f5,"PLY"            ; $ae PLY
>b7fa	03 ed 52 4f 4c				.text	3,$ed,"ROL"            ; $af ROL
>b7ff	03 f3 52 4f 52				.text	3,$f3,"ROR"            ; $b0 ROR
>b804	03 ef 52 54 49				.text	3,$ef,"RTI"            ; $b1 RTI
>b809	03 f9 52 54 53				.text	3,$f9,"RTS"            ; $b2 RTS
>b80e	03 d8 53 42 43				.text	3,$d8,"SBC"            ; $b3 SBC
>b813	03 db 53 45 43				.text	3,$db,"SEC"            ; $b4 SEC
>b818	03 dc 53 45 44				.text	3,$dc,"SED"            ; $b5 SED
>b81d	03 e1 53 45 49				.text	3,$e1,"SEI"            ; $b6 SEI
>b822	03 e8 53 54 41				.text	3,$e8,"STA"            ; $b7 STA
>b827	03 f7 53 54 50				.text	3,$f7,"STP"            ; $b8 STP
>b82c	03 ff 53 54 58				.text	3,$ff,"STX"            ; $b9 STX
>b831	03 00 53 54 59				.text	3,$00,"STY"            ; $ba STY
>b836	03 01 53 54 5a				.text	3,$01,"STZ"            ; $bb STZ
>b83b	03 ed 54 41 58				.text	3,$ed,"TAX"            ; $bc TAX
>b840	03 ee 54 41 59				.text	3,$ee,"TAY"            ; $bd TAY
>b845	03 e8 54 52 42				.text	3,$e8,"TRB"            ; $be TRB
>b84a	03 e9 54 53 42				.text	3,$e9,"TSB"            ; $bf TSB
>b84f	03 ff 54 53 58				.text	3,$ff,"TSX"            ; $c0 TSX
>b854	03 ed 54 58 41				.text	3,$ed,"TXA"            ; $c1 TXA
>b859	03 ff 54 58 53				.text	3,$ff,"TXS"            ; $c2 TXS
>b85e	03 ee 54 59 41				.text	3,$ee,"TYA"            ; $c3 TYA
>b863	ff					.text	$FF
.b864					Export_TKListConvertLine:
.b864	48		pha				pha 								; save indent on the stack
.b865	9c 1d 04	stz $041d			stz 	tbOffset
.b868	9c 2d 04	stz $042d			stz 	tokenBuffer
.b86b	9c 29 04	stz $0429			stz 	currentListColour
.b86e	a9 89		lda #$89			lda 	#CLILineNumber+$80
.b870	20 ed b9	jsr $b9ed			jsr 	LCLWriteColour
.b873	a0 02		ldy #$02			ldy 	#2 							; convert line number to string
.b875	b1 30		lda ($30),y			lda 	(codePtr),y
.b877	aa		tax				tax
.b878	88		dey				dey
.b879	b1 30		lda ($30),y			lda 	(codePtr),y
.b87b	20 5e ba	jsr $ba5e			jsr 	LCLWriteNumberXA
.b87e	68		pla				pla 								; adjustment to indent
.b87f	48		pha				pha 								; save on stack
.b880	10 0c		bpl $b88e			bpl 	_LCNoAdjust 				; don't adjust indent if +ve, do after.
.b882	18		clc				clc 								; add to list indent and make 0 if goes -ve.
.b883	6d 26 04	adc $0426			adc 	listIndent
.b886	8d 26 04	sta $0426			sta 	listIndent
.b889	10 03		bpl $b88e			bpl 	_LCNoAdjust
.b88b	9c 26 04	stz $0426			stz 	listIndent
.b88e					_LCNoAdjust:
.b88e	18		clc				clc		 							; work out actual indent.
.b88f	ad 26 04	lda $0426			lda 	listIndent
.b892	0a		asl a				asl 	a
.b893	69 07		adc #$07			adc 	#7
.b895	85 36		sta $36				sta 	zTemp0
.b897					_LCPadOut:
.b897	a9 20		lda #$20			lda 	#' '						; pad out to 6+indent characters
.b899	20 f6 b9	jsr $b9f6			jsr 	LCLWrite
.b89c	ad 1d 04	lda $041d			lda 	tbOffset
.b89f	c5 36		cmp $36				cmp 	zTemp0
.b8a1	d0 f4		bne $b897			bne 	_LCPadOut
.b8a3	a0 03		ldy #$03			ldy 	#3 							; start position.
.b8a5					_LCMainLoop:
.b8a5	a9 8a		lda #$8a			lda 	#CLIPunctuation+$80
.b8a7	20 ed b9	jsr $b9ed			jsr 	LCLWriteColour
.b8aa	b1 30		lda ($30),y			lda 	(codePtr),y
.b8ac	c9 80		cmp #$80			cmp 	#KWC_EOL 					; end of line ?
.b8ae	f0 17		beq $b8c7			beq 	_LCExit
.b8b0	c9 10		cmp #$10			cmp 	#16 						; 0-5 are the double punctuations
.b8b2	90 1e		bcc $b8d2			bcc 	_LCDoubles
.b8b4	c9 20		cmp #$20			cmp 	#32 						; 16-31 are shifted punctuation from 64-91
.b8b6	90 2a		bcc $b8e2			bcc 	_LCShiftPunc
.b8b8	c9 40		cmp #$40			cmp 	#64 						; 32-64 are as stored, punc and digits
.b8ba	90 35		bcc $b8f1			bcc 	_LCPunctuation
.b8bc	c9 80		cmp #$80			cmp 	#128 						; 64-127 are variable identifiers.
.b8be	90 51		bcc $b911			bcc 	_LCIdentifiers
.b8c0	c9 fe		cmp #$fe			cmp 	#254 						; 128-253 are tokenised words
.b8c2	90 73		bcc $b937			bcc 	_LCTokens
.b8c4	4c 97 b9	jmp $b997			jmp 	_LCData 					; 254-5 are data objects
.b8c7					_LCExit:
.b8c7	68		pla				pla 								; get old indent adjust
.b8c8	30 07		bmi $b8d1			bmi 	_LCExit2
.b8ca	18		clc				clc 								; add to indent if +ve
.b8cb	6d 26 04	adc $0426			adc 	listIndent
.b8ce	8d 26 04	sta $0426			sta 	listIndent
.b8d1					_LCExit2:
.b8d1	60		rts				rts
.b8d2					_LCDoubles:
.b8d2	48		pha				pha
.b8d3	4a		lsr a				lsr 	a 							; put bit 2 into bit 1
.b8d4	29 02		and #$02			and 	#2
.b8d6	09 3c		ora #$3c			ora 	#60 						; make < >
.b8d8	20 f6 b9	jsr $b9f6			jsr 	LCLWrite
.b8db	68		pla				pla 								; restore, do lower bit
.b8dc	29 03		and #$03			and 	#3
.b8de	09 3c		ora #$3c			ora 	#60
.b8e0	80 0f		bra $b8f1			bra		_LCPunctuation 				; print, increment, loop
.b8e2					_LCShiftPunc:
.b8e2	aa		tax				tax 								; save in X
.b8e3	29 07		and #$07			and 	#7 							; lower 3 bits
.b8e5	f0 02		beq $b8e9			beq 	_LCNoAdd
.b8e7	09 18		ora #$18			ora 	#24 						; adds $18 to it.
.b8e9					_LCNoAdd:
.b8e9	e0 18		cpx #$18			cpx 	#24 						; if >= 24 add $20
.b8eb	90 02		bcc $b8ef			bcc 	_LCNoAdd2
.b8ed	09 20		ora #$20			ora 	#32 						; adds $20
.b8ef					_LCNoAdd2:
.b8ef	09 40		ora #$40			ora 	#$40 						; shift into 64-127 range and fall through.
.b8f1					_LCPunctuation:
.b8f1	c9 3a		cmp #$3a			cmp 	#':' 						; check if :
.b8f3	d0 03		bne $b8f8			bne 	_LCPContinue
.b8f5	20 0c ba	jsr $ba0c			jsr 	LCLDeleteLastSpace 			; if so delete any preceding spaces
.b8f8					_LCPContinue:
.b8f8	c9 2e		cmp #$2e			cmp 	#'.'
.b8fa	f0 08		beq $b904			beq 	_LCPIsConstant
.b8fc	c9 30		cmp #$30			cmp 	#'0'
.b8fe	90 0b		bcc $b90b			bcc 	_LCPNotConstant
.b900	c9 3a		cmp #$3a			cmp 	#'9'+1
.b902	b0 07		bcs $b90b			bcs 	_LCPNotConstant
.b904					_LCPIsConstant:
.b904	48		pha				pha
.b905	a9 8d		lda #$8d			lda 	#CLIConstant+$80
.b907	20 ed b9	jsr $b9ed			jsr 	LCLWriteColour
.b90a	68		pla				pla
.b90b					_LCPNotConstant:
.b90b	c8		iny				iny 								; consume character
.b90c	20 f6 b9	jsr $b9f6			jsr 	LCLWrite 					; write it out.
.b90f	80 94		bra $b8a5			bra 	_LCMainLoop 				; go round again.
.b911					_LCIdentifiers:
.b911	18		clc				clc 								; convert to physical address
.b912	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.b914	85 37		sta $37				sta 	zTemp0+1
.b916	c8		iny				iny
.b917	b1 30		lda ($30),y			lda 	(codePtr),y
.b919	85 36		sta $36				sta 	zTemp0
.b91b	c8		iny				iny
.b91c	5a		phy				phy 								; save position
.b91d	a9 87		lda #$87			lda 	#CLIIdentifier+$80
.b91f	20 ed b9	jsr $b9ed			jsr 	LCLWriteColour
.b922	a0 07		ldy #$07			ldy 	#7 							; output the identifier at +8
.b924					_LCOutIdentifier:
.b924	c8		iny				iny
.b925	b1 36		lda ($36),y			lda 	(zTemp0),y					; bit 7 set = end.
.b927	29 7f		and #$7f			and 	#$7F
.b929	20 48 ba	jsr $ba48			jsr 	LCLLowerCase
.b92c	20 f6 b9	jsr $b9f6			jsr 	LCLWrite
.b92f	b1 36		lda ($36),y			lda 	(zTemp0),y				 	; ends when bit 7 set.
.b931	10 f1		bpl $b924			bpl 	_LCOutIdentifier
.b933	7a		ply				ply 								; restore position
.b934	4c a5 b8	jmp $b8a5			jmp 	_LCMainLoop
.b937					_LCTokens:
.b937	aa		tax				tax 								; token in X
.b938	a9 18		lda #$18			lda 	#((KeywordSet2) & $FF)
.b93a	85 36		sta $36				sta 	0+zTemp0
.b93c	a9 b7		lda #$b7			lda 	#((KeywordSet2) >> 8)
.b93e	85 37		sta $37				sta 	1+zTemp0
.b940	e0 82		cpx #$82			cpx 	#$82
.b942	f0 16		beq $b95a			beq 	_LCUseShift
.b944	a9 a0		lda #$a0			lda 	#((KeywordSet1) & $FF)
.b946	85 36		sta $36				sta 	0+zTemp0
.b948	a9 b6		lda #$b6			lda 	#((KeywordSet1) >> 8)
.b94a	85 37		sta $37				sta 	1+zTemp0
.b94c	e0 81		cpx #$81			cpx 	#$81
.b94e	f0 0a		beq $b95a			beq 	_LCUseShift
.b950	a9 89		lda #$89			lda 	#((KeywordSet0) & $FF)
.b952	85 36		sta $36				sta 	0+zTemp0
.b954	a9 b4		lda #$b4			lda 	#((KeywordSet0) >> 8)
.b956	85 37		sta $37				sta 	1+zTemp0
.b958	80 01		bra $b95b			bra 	_LCNoShift
.b95a					_LCUseShift:
.b95a	c8		iny				iny
.b95b					_LCNoShift:
.b95b	20 20 ba	jsr $ba20			jsr 	LCLCheckSpaceRequired 		; do we need a space ?
.b95e	b1 30		lda ($30),y			lda 	(codePtr),y
.b960	aa		tax				tax 								; into X
.b961					_LCFindText:
.b961	ca		dex				dex
.b962	10 0e		bpl $b972			bpl 	_LCFoundText 				; found text.
.b964	b2 36		lda ($36)			lda 	(zTemp0) 					; length of text
.b966	1a		inc a				inc 	a 							; one extra for size
.b967	38		sec				sec 								; one extra for checksum
.b968	65 36		adc $36				adc 	zTemp0 						; go to next token
.b96a	85 36		sta $36				sta 	zTemp0
.b96c	90 f3		bcc $b961			bcc 	_LCFindText
.b96e	e6 37		inc $37				inc 	zTemp0+1
.b970	80 ef		bra $b961			bra 	_LCFindText
.b972					_LCFoundText:
.b972	5a		phy				phy 								; save List position
.b973	b2 36		lda ($36)			lda 	(zTemp0)					; count to print
.b975	aa		tax				tax
.b976	a9 83		lda #$83			lda 	#CLIToken+$80
.b978	20 ed b9	jsr $b9ed			jsr 	LCLWriteColour
.b97b	a0 02		ldy #$02			ldy 	#2
.b97d					_LCCopyToken:
.b97d	b1 36		lda ($36),y			lda 	(zTemp0),y
.b97f	20 48 ba	jsr $ba48			jsr 	LCLLowerCase
.b982	20 f6 b9	jsr $b9f6			jsr 	LCLWrite
.b985	c8		iny				iny
.b986	ca		dex				dex
.b987	d0 f4		bne $b97d			bne 	_LCCopyToken
.b989	c9 28		cmp #$28			cmp 	#"(" 						; if last char not ( print a space
.b98b	f0 05		beq $b992			beq 	_LCNoSpace
.b98d	a9 20		lda #$20			lda 	#' '
.b98f	20 f6 b9	jsr $b9f6			jsr 	LCLWrite
.b992					_LCNoSpace:
.b992	7a		ply				ply 								; restore position.
.b993	c8		iny				iny 								; consume token
.b994	4c a5 b8	jmp $b8a5			jmp 	_LCMainLoop 				; and go around again.
.b997					_LCData:
.b997	48		pha				pha 								; save type $FE/$FF
.b998	a2 24		ldx #$24			ldx 	#'$' 						; figure out $ or "
.b99a	c9 fe		cmp #$fe			cmp 	#$FE
.b99c	f0 22		beq $b9c0			beq 	_LCHaveOpener
.b99e	a2 22		ldx #$22			ldx 	#'"'
.b9a0	a9 81		lda #$81			lda 	#CLIData+$80
.b9a2	20 ed b9	jsr $b9ed			jsr 	LCLWriteColour
.b9a5	c0 04		cpy #$04			cpy 	#4 							; must be 2nd thing on line
.b9a7	d0 17		bne $b9c0			bne 	_LCHaveOpener
.b9a9	88		dey				dey 								; what precedes it ?
.b9aa	b1 30		lda ($30),y			lda 	(codePtr),y
.b9ac	c8		iny				iny
.b9ad	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; if quote
.b9af	d0 0f		bne $b9c0			bne 	_LCHaveOpener
.b9b1	a9 09		lda #$09			lda 	#9 							; tab
.b9b3	20 f6 b9	jsr $b9f6			jsr 	LCLWrite
.b9b6	a9 97		lda #$97			lda 	#$90+CLIBComment
.b9b8	20 f6 b9	jsr $b9f6			jsr 	LCLWrite
.b9bb	a9 80		lda #$80			lda 	#CLIFComment+$80
.b9bd	20 ed b9	jsr $b9ed			jsr 	LCLWriteColour
.b9c0					_LCHaveOpener:
.b9c0	8a		txa				txa 								; output prefix (# or ")
.b9c1	20 f6 b9	jsr $b9f6			jsr 	LCLWrite
.b9c4	c8		iny				iny 								; get count
.b9c5	b1 30		lda ($30),y			lda 	(codePtr),y
.b9c7	aa		tax				tax
.b9c8	c8		iny				iny 								; point at first character
.b9c9					_LCOutData:
.b9c9	b1 30		lda ($30),y			lda 	(codePtr),y
.b9cb	c9 00		cmp #$00			cmp 	#0
.b9cd	f0 03		beq $b9d2			beq 	_LCNoPrint
.b9cf	20 f6 b9	jsr $b9f6			jsr 	LCLWrite
.b9d2					_LCNoPrint:
.b9d2	c8		iny				iny
.b9d3	ca		dex				dex
.b9d4	d0 f3		bne $b9c9			bne 	_LCOutData
.b9d6	68		pla				pla 								; closing " required ?
.b9d7	c9 ff		cmp #$ff			cmp 	#$FF 						; not required for hex constant.
.b9d9	d0 0f		bne $b9ea			bne 	_LCNoQuote
.b9db	a9 22		lda #$22			lda 	#'"'
.b9dd	20 f6 b9	jsr $b9f6			jsr 	LCLWrite
.b9e0	ad 6e 06	lda $066e			lda 	EXTTextColour
.b9e3	29 0f		and #$0f			and 	#$0F
.b9e5	09 90		ora #$90			ora 	#$90
.b9e7	20 f6 b9	jsr $b9f6			jsr 	LCLWrite
.b9ea					_LCNoQuote:
.b9ea	4c a5 b8	jmp $b8a5			jmp 	_LCMainLoop
.b9ed					LCLWriteColour:
.b9ed	cd 29 04	cmp $0429			cmp 	currentListColour 			; has the colour changed
.b9f0	8d 29 04	sta $0429			sta 	currentListColour 			; (update it anyway)
.b9f3	d0 01		bne $b9f6			bne 	LCLWrite 					; if different, output it
.b9f5	60		rts				rts
.b9f6					LCLWrite:
.b9f6	da		phx				phx
.b9f7	ae 1d 04	ldx $041d			ldx 	tbOffset 					; write out make ASCIIZ
.b9fa	9d 2d 04	sta $042d,x			sta 	tokenBuffer,x
.b9fd	9e 2e 04	stz $042e,x			stz 	tokenBuffer+1,x
.ba00	ee 1d 04	inc $041d			inc 	tbOffset 					; bump the position
.ba03	09 00		ora #$00			ora 	#0 							; don't update last character if colour data
.ba05	30 03		bmi $ba0a			bmi 	_LCLNoColour
.ba07	8d 27 04	sta $0427			sta 	LCLastCharacter
.ba0a					_LCLNoColour:
.ba0a	fa		plx				plx
.ba0b	60		rts				rts
.ba0c					LCLDeleteLastSpace:
.ba0c	48		pha				pha
.ba0d	da		phx				phx
.ba0e	ae 1d 04	ldx $041d			ldx 	tbOffset
.ba11	f0 0a		beq $ba1d			beq 	_LCDLSExit
.ba13	bd 2c 04	lda $042c,x			lda 	tokenBuffer-1,x
.ba16	c9 20		cmp #$20			cmp 	#' '
.ba18	d0 03		bne $ba1d			bne 	_LCDLSExit
.ba1a	ce 1d 04	dec $041d			dec 	tbOffset
.ba1d					_LCDLSExit:
.ba1d	fa		plx				plx
.ba1e	68		pla				pla
.ba1f	60		rts				rts
.ba20					LCLCheckSpaceRequired:
.ba20	ad 27 04	lda $0427			lda 	LCLastCharacter 			; check last character
.ba23	c9 24		cmp #$24			cmp 	#'$' 						; $ # and ) require that token space.
.ba25	f0 1b		beq $ba42			beq 	_LCCSRSpace
.ba27	c9 29		cmp #$29			cmp 	#')'
.ba29	f0 17		beq $ba42			beq 	_LCCSRSpace
.ba2b	c9 23		cmp #$23			cmp 	#'#'
.ba2d	f0 13		beq $ba42			beq 	_LCCSRSpace
.ba2f	20 48 ba	jsr $ba48			jsr 	LCLLowerCase 				; saves a little effort
.ba32	c9 30		cmp #$30			cmp 	#"0" 						; check if it was 0-9 A-Z a-z if so need space.
.ba34	90 11		bcc $ba47			bcc 	_LCCSRExit
.ba36	c9 3a		cmp #$3a			cmp 	#"9"+1
.ba38	90 08		bcc $ba42			bcc 	_LCCSRSpace
.ba3a	c9 61		cmp #$61			cmp 	#"a"
.ba3c	90 09		bcc $ba47			bcc 	_LCCSRExit
.ba3e	c9 7b		cmp #$7b			cmp 	#"z"+1
.ba40	b0 05		bcs $ba47			bcs 	_LCCSRExit
.ba42					_LCCSRSpace:
.ba42	a9 20		lda #$20			lda 	#' '
.ba44	20 f6 b9	jsr $b9f6			jsr 	LCLWrite
.ba47					_LCCSRExit:
.ba47	60		rts				rts
.ba48					LCLLowerCase:
.ba48	c9 41		cmp #$41			cmp 	#"A"
.ba4a	90 06		bcc $ba52			bcc 	_LCLLCOut
.ba4c	c9 5b		cmp #$5b			cmp 	#"Z"+1
.ba4e	b0 02		bcs $ba52			bcs 	_LCLLCOut
.ba50	69 20		adc #$20			adc 	#$20
.ba52					_LCLLCOut:
.ba52	60		rts				rts
.ba53					LCLUpperCase:
.ba53	c9 61		cmp #$61			cmp 	#"a"
.ba55	90 06		bcc $ba5d			bcc 	_LCLUCOut
.ba57	c9 7b		cmp #$7b			cmp 	#"z"+1
.ba59	b0 02		bcs $ba5d			bcs 	_LCLUCOut
.ba5b	e9 1f		sbc #$1f			sbc 	#$1F
.ba5d					_LCLUCOut:
.ba5d	60		rts				rts
.ba5e					LCLWriteNumberXA:
.ba5e	64 37		stz $37				stz 	zTemp0+1 					; index into digit table.
.ba60					_LCLWNLoop1:
.ba60	64 36		stz $36				stz 	zTemp0 						; subtraction count.
.ba62					_LCLWNLoop2:
.ba62	48		pha				pha 								; save initial LSB
.ba63	38		sec				sec
.ba64	a4 37		ldy $37				ldy 	zTemp0+1 					; position in table.
.ba66	f9 97 ba	sbc $ba97,y			sbc 	_LCLWNTable,y
.ba69	48		pha				pha
.ba6a	8a		txa				txa
.ba6b	f9 98 ba	sbc $ba98,y			sbc 	_LCLWNTable+1,y
.ba6e	90 07		bcc $ba77			bcc 	_LCLWNUnderflow
.ba70	e6 36		inc $36				inc 	zTemp0  					; subtracted one without borrow.
.ba72	aa		tax				tax 								; update X
.ba73	68		pla				pla 								; restore A
.ba74	7a		ply				ply 								; throw original
.ba75	80 eb		bra $ba62			bra 	_LCLWNLoop2 				; try again.
.ba77					_LCLWNUnderflow:
.ba77	a4 36		ldy $36				ldy 	zTemp0 						; count of subtractions.
.ba79	d0 06		bne $ba81			bne 	_LCLWNOut
.ba7b	ad 1d 04	lda $041d			lda 	tbOffset 					; suppress leading zeroes
.ba7e	3a		dec a				dec 	a
.ba7f	f0 04		beq $ba85			beq 	_LCLWNNext
.ba81					_LCLWNOut:
.ba81	98		tya				tya
.ba82	20 91 ba	jsr $ba91			jsr 	_LCLWNOutDigit
.ba85					_LCLWNNext:
.ba85	7a		ply				ply 							 	; restore original value.
.ba86	68		pla				pla
.ba87	a4 37		ldy $37				ldy 	zTemp0+1  					; bump the index
.ba89	c8		iny				iny
.ba8a	c8		iny				iny
.ba8b	84 37		sty $37				sty 	zTemp0+1
.ba8d	c0 08		cpy #$08			cpy 	#8 							; done all 4
.ba8f	d0 cf		bne $ba60			bne 	_LCLWNLoop1
.ba91					_LCLWNOutDigit:
.ba91	09 30		ora #$30			ora 	#'0'
.ba93	20 f6 b9	jsr $b9f6			jsr 	LCLWrite
.ba96	60		rts				rts
.ba97					_LCLWNTable:
>ba97	10 27						.word 	10000
>ba99	e8 03						.word 	1000
>ba9b	64 00						.word 	100
>ba9d	0a 00						.word 	10
.ba9f					TOKSearchTable:
.ba9f	84 37		sty $37				sty 	zTemp0+1 					; (zTemp0),y points to current token being tested.
.baa1	85 36		sta $36				sta 	zTemp0
.baa3	a0 00		ldy #$00			ldy 	#0
.baa5	a9 80		lda #$80			lda 	#$80 						; token # so we know which one we are looking at
.baa7	85 38		sta $38				sta 	zTemp1
.baa9					_TSTLoop:
.baa9	b1 36		lda ($36),y			lda 	(zTemp0),y 					; length, 0 (skip) -ve (end)
.baab	30 49		bmi $baf6			bmi 	_TSTFail 					; -ve = end of table, so fail.
.baad	f0 2e		beq $badd			beq 	_TSTNext 					; zero, check next as it's a dummy (e.g. EOL, SHIFT)
.baaf	c8		iny				iny 								; get the hash
.bab0	b1 36		lda ($36),y			lda 	(zTemp0),y
.bab2	88		dey				dey
.bab3	cd 03 04	cmp $0403			cmp 	identHash 					; check they match with the identifier hash, if not go to next
.bab6	d0 25		bne $badd			bne 	_TSTNext
.bab8	ad 02 04	lda $0402			lda 	identTypeEnd 				; get length of identifier from end-start
.babb	38		sec				sec
.babc	ed 00 04	sbc $0400			sbc 	identStart
.babf	d1 36		cmp ($36),y			cmp 	(zTemp0),y 					; compare against the length in the table, no match, then return.
.bac1	d0 1a		bne $badd			bne 	_TSTNext
.bac3	5a		phy				phy 								; save Y , we might fail to match.
.bac4	c8		iny				iny 								; point to text
.bac5	c8		iny				iny
.bac6	ae 00 04	ldx $0400			ldx 	identStart 					; offset in line buffer in X
.bac9					_TSTCompareName:
.bac9	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; compare text.
.bacc	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.bace	d0 0c		bne $badc			bne 	_TSTNextPullY 				; fail, pullY and do next
.bad0	e8		inx				inx
.bad1	c8		iny				iny
.bad2	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; complete match.
.bad5	d0 f2		bne $bac9			bne 	_TSTCompareName
.bad7	7a		ply				ply 								; throw Y
.bad8	a5 38		lda $38				lda 	zTemp1 						; get token #
.bada	38		sec				sec 								; return with CS = passed.
.badb	60		rts				rts
.badc					_TSTNextPullY:
.badc	7a		ply				ply 								; restore current, fall through.
.badd					_TSTNext:
.badd	e6 38		inc $38				inc 	zTemp1 						; token counter
.badf	98		tya				tya
.bae0	18		clc				clc
.bae1	71 36		adc ($36),y			adc 	(zTemp0),y 					; add [Length] + 2 to Y
.bae3	1a		inc a				inc 	a 							; +1
.bae4	1a		inc a				inc 	a 							; +2
.bae5	a8		tay				tay
.bae6	10 c1		bpl $baa9			bpl 	_TSTLoop 					; if Y < $80 loop back
.bae8	98		tya				tya 								; add Y to zTemp0 and reset Y
.bae9	a0 00		ldy #$00			ldy 	#0   						; so we can use Y to search fast
.baeb	18		clc				clc  								; but have tables > 255 bytes
.baec	65 36		adc $36				adc 	zTemp0 						; when Y gets >= 128 we reset Y
.baee	85 36		sta $36				sta 	zTemp0 						; and adjust the table pointer/
.baf0	90 b7		bcc $baa9			bcc 	_TSTLoop
.baf2	e6 37		inc $37				inc 	zTemp0+1
.baf4	80 b3		bra $baa9			bra 	_TSTLoop
.baf6					_TSTFail:
.baf6	18		clc				clc
.baf7	60		rts				rts
.baf8					Export_TKTokeniseLine:
.baf8	20 80 bc	jsr $bc80			jsr 	LCLFixLineBufferCase 		; fix line case
.bafb	a9 03		lda #$03			lda 	#3 							; reset the token buffer to empty
.bafd	8d 2a 04	sta $042a			sta 	tokenOffset 				; (3 bytes for line number & offset)
.bb00	9c 2b 04	stz $042b			stz 	tokenLineNumber
.bb03	9c 2c 04	stz $042c			stz 	tokenLineNumber+1
.bb06	a2 ff		ldx #$ff			ldx 	#$FF
.bb08					_TKFindFirst:
.bb08	e8		inx				inx
.bb09	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.bb0c	f0 79		beq $bb87			beq 	_TKExit
.bb0e	c9 20		cmp #$20			cmp 	#' '
.bb10	90 f6		bcc $bb08			bcc 	_TKFindFirst
.bb12	c9 30		cmp #$30			cmp 	#'0'
.bb14	90 07		bcc $bb1d			bcc 	_TKNoLineNumber
.bb16	c9 3a		cmp #$3a			cmp 	#'9'+1
.bb18	b0 03		bcs $bb1d			bcs 	_TKNoLineNumber
.bb1a	20 aa bc	jsr $bcaa			jsr 	TOKExtractLineNumber
.bb1d					_TKNoLineNumber:
.bb1d					_TKTokeniseLoop:
.bb1d	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; next character, exit if zero EOL.
.bb20	f0 65		beq $bb87			beq 	_TKExit
.bb22	e8		inx				inx
.bb23	c9 20		cmp #$20			cmp 	#' '
.bb25	f0 f6		beq $bb1d			beq 	_TKTokeniseLoop 			; keep looping if space found.
.bb27	ca		dex				dex 								; undo last get, A contains character, X is position.
.bb28	c9 5f		cmp #$5f			cmp 	#'_'						; _ A-Z is identifier *or* token
.bb2a	f0 61		beq $bb8d			beq 	_TKTokeniseIdentifier 		; (already case converted outside string constants)
.bb2c	c9 41		cmp #$41			cmp 	#'A'
.bb2e	90 04		bcc $bb34			bcc 	_TKTokenisePunctuation
.bb30	c9 5b		cmp #$5b			cmp 	#'Z'+1
.bb32	90 59		bcc $bb8d			bcc 	_TKTokeniseIdentifier
.bb34					_TKTokenisePunctuation:
.bb34	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.bb36	f0 27		beq $bb5f			beq 	_TKString
.bb38	c9 24		cmp #$24			cmp 	#'$'						; hexadecimal constant ($ only appears at end of identifiers)
.bb3a	f0 28		beq $bb64			beq 	_TKHexConstant
.bb3c	c9 3c		cmp #$3c			cmp 	#'<' 						; check for < > handlers - these are for <> <= >= >> <<
.bb3e	f0 29		beq $bb69			beq 	_TKCheckDouble
.bb40	c9 3e		cmp #$3e			cmp 	#'>'
.bb42	f0 25		beq $bb69			beq 	_TKCheckDouble
.bb44					_TKStandardPunctuation:
.bb44	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get the punctuation token back.
.bb47	c9 40		cmp #$40			cmp 	#64 						; are we >= 64
.bb49	90 0e		bcc $bb59			bcc 	_TKNoShift
.bb4b	48		pha				pha 								; save. we are about to convert this punctuation token from
.bb4c	29 07		and #$07			and 	#7 							; lower 3 bits in zTemp0
.bb4e	85 36		sta $36				sta 	zTemp0
.bb50	68		pla				pla
.bb51	29 20		and #$20			and 	#32 						; bit 5
.bb53	4a		lsr a				lsr 	a 							; shift into bit 3
.bb54	4a		lsr a				lsr 	a
.bb55	05 36		ora $36				ora 	zTemp0
.bb57	09 10		ora #$10			ora 	#$10						; now in the range 16-31
.bb59					_TKNoShift:
.bb59	20 ef bc	jsr $bcef			jsr 	TOKWriteByte 				; write the punctuation character
.bb5c	e8		inx				inx 								; consume the character
.bb5d	80 be		bra $bb1d			bra 	_TKTokeniseLoop 			; and loop round again.
.bb5f					_TKString:
.bb5f	20 0f bc	jsr $bc0f			jsr 	TOKTokenString
.bb62	80 b9		bra $bb1d			bra 	_TKTokeniseLoop
.bb64					_TKHexConstant:
.bb64	20 4a bc	jsr $bc4a			jsr 	TOKHexConstant
.bb67	80 b4		bra $bb1d			bra 	_TKTokeniseLoop
.bb69					_TKCheckDouble:
.bb69	bd 2b 05	lda $052b,x			lda 	lineBuffer+1,x 				; get next character
.bb6c	c9 3c		cmp #$3c			cmp 	#'<'						; if not < = > which are ASCII consecutive go back
.bb6e	90 d4		bcc $bb44			bcc 	_TKStandardPunctuation 		; and do the normal punctuation handler.
.bb70	c9 3f		cmp #$3f			cmp 	#'>'+1
.bb72	b0 d0		bcs $bb44			bcs 	_TKStandardPunctuation
.bb74	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; this is < (60) or > (62)
.bb77	29 02		and #$02			and 	#2 							; now < (0) or > (2)
.bb79	0a		asl a				asl 	a 							; now < (0) or > (4), CC also
.bb7a	7d 2b 05	adc $052b,x			adc 	lineBuffer+1,x 				; add < = > codes - < code
.bb7d	38		sec				sec
.bb7e	e9 3c		sbc #$3c			sbc 	#'<'
.bb80	20 ef bc	jsr $bcef			jsr 	TOKWriteByte 				; this is in the range 0-7
.bb83	e8		inx				inx 								; consume both
.bb84	e8		inx				inx
.bb85	80 96		bra $bb1d			bra 	_TKTokeniseLoop
.bb87	a9 80		lda #$80	_TKExit:lda 	#KWC_EOL 					; write end of line byte
.bb89	20 ef bc	jsr $bcef			jsr 	TOKWriteByte
.bb8c	60		rts				rts
.bb8d					_TKTokeniseIdentifier:
.bb8d	8e 00 04	stx $0400			stx 	identStart 					; save start
.bb90	9c 04 04	stz $0404			stz 	identTypeByte 				; zero the type byte
.bb93					_TKCheckLoop:
.bb93	e8		inx				inx 								; look at next, we know first is identifier already.
.bb94	bd 2a 05	lda $052a,x			lda  	lineBuffer,x
.bb97	c9 5f		cmp #$5f			cmp 	#"_" 						; legal char _ 0-9 A-Z
.bb99	f0 f8		beq $bb93			beq 	_TKCheckLoop
.bb9b	c9 30		cmp #$30			cmp	 	#"0"
.bb9d	90 0c		bcc $bbab			bcc 	_TKEndIdentifier
.bb9f	c9 3a		cmp #$3a			cmp 	#"9"+1
.bba1	90 f0		bcc $bb93			bcc 	_TKCheckLoop
.bba3	c9 41		cmp #$41			cmp	 	#"A"
.bba5	90 04		bcc $bbab			bcc 	_TKEndIdentifier
.bba7	c9 5b		cmp #$5b			cmp 	#"Z"+1
.bba9	90 e8		bcc $bb93			bcc 	_TKCheckLoop
.bbab					_TKEndIdentifier:
.bbab	8e 01 04	stx $0401			stx 	identTypeStart 				; save start of type text (if any !)
.bbae	a0 08		ldy #$08			ldy 	#$08 						; this is the identifier type byte for #
.bbb0	c9 23		cmp #$23			cmp 	#"#"						; followed by #
.bbb2	f0 06		beq $bbba			beq 	_TKHasTypeCharacter
.bbb4	a0 10		ldy #$10			ldy 	#$10 						; this is the identifier type byte for $
.bbb6	c9 24		cmp #$24			cmp 	#"$"						; followed by $ or #
.bbb8	d0 07		bne $bbc1			bne 	_TKNoTypeCharacter
.bbba					_TKHasTypeCharacter:
.bbba	8c 04 04	sty $0404			sty 	identTypeByte 				; has # or $, save the type
.bbbd	e8		inx				inx 								; consume the type character
.bbbe	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.bbc1					_TKNoTypeCharacter:
.bbc1	c9 28		cmp #$28			cmp 	#"("						; is it open parenthesis (e.g. array)
.bbc3	d0 09		bne $bbce			bne 	_TKNoArray
.bbc5	e8		inx				inx 								; skip the (
.bbc6	ad 04 04	lda $0404			lda 	identTypeByte 				; set bit 2 (e.g. array) in type byte
.bbc9	09 04		ora #$04			ora 	#$04
.bbcb	8d 04 04	sta $0404			sta 	identTypeByte
.bbce					_TKNoArray:
.bbce	8e 02 04	stx $0402			stx 	identTypeEnd 				; save end marker, e.g. continue from here.
.bbd1	20 6b bc	jsr $bc6b			jsr 	TOKCalculateHash 			; calculate the has for those tokens
.bbd4	a0 b4		ldy #$b4			ldy 	#(KeywordSet0) >> 8
.bbd6	a9 89		lda #$89			lda 	#(KeywordSet0) & $FF
.bbd8	20 9f ba	jsr $ba9f			jsr 	TOKSearchTable
.bbdb	a2 00		ldx #$00			ldx 	#0
.bbdd	b0 1f		bcs $bbfe			bcs 	_TKFoundToken
.bbdf	a0 b6		ldy #$b6			ldy 	#(KeywordSet1) >> 8
.bbe1	a9 a0		lda #$a0			lda 	#(KeywordSet1) & $FF
.bbe3	20 9f ba	jsr $ba9f			jsr 	TOKSearchTable
.bbe6	a2 81		ldx #$81			ldx 	#$81
.bbe8	b0 14		bcs $bbfe			bcs 	_TKFoundToken
.bbea	a0 b7		ldy #$b7			ldy 	#(KeywordSet2) >> 8
.bbec	a9 18		lda #$18			lda 	#(KeywordSet2) & $FF
.bbee	20 9f ba	jsr $ba9f			jsr 	TOKSearchTable
.bbf1	a2 82		ldx #$82			ldx 	#$82
.bbf3	b0 09		bcs $bbfe			bcs 	_TKFoundToken
.bbf5	20 fb bc	jsr $bcfb			jsr 	TOKCheckCreateVariableRecord ; failed all, it's a variable, create record if does not exist.
.bbf8	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.bbfb	4c 1d bb	jmp $bb1d			jmp 	_TKTokeniseLoop 			; and go round again.
.bbfe					_TKFoundToken:
.bbfe	48		pha				pha 								; save token
.bbff	8a		txa				txa 								; shift in X, is there one ?
.bc00	f0 03		beq $bc05			beq 	_TKNoTShift
.bc02	20 ef bc	jsr $bcef			jsr 	TOKWriteByte 				; if so, write it out
.bc05					_TKNoTShift:
.bc05	68		pla				pla 								; restore and write token
.bc06	20 ef bc	jsr $bcef			jsr 	TOKWriteByte
.bc09	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.bc0c	4c 1d bb	jmp $bb1d			jmp 	_TKTokeniseLoop 			; and go round again.
.bc0f					TOKTokenString:
.bc0f	a9 ff		lda #$ff			lda 	#KWC_STRING 				; string token.
.bc11	20 ef bc	jsr $bcef			jsr 	TOKWriteByte
.bc14	e8		inx				inx									; start of quoted string.
.bc15	da		phx				phx 								; push start of string on top
.bc16	ca		dex				dex 								; because we pre-increment
.bc17					_TSFindEnd:
.bc17	e8		inx				inx
.bc18	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; next character
.bc1b	f0 04		beq $bc21			beq 	_TSEndOfString 				; no matching quote, we don't mind.
.bc1d	c9 22		cmp #$22			cmp 	#'"' 						; go back if quote not found
.bc1f	d0 f6		bne $bc17			bne 	_TSFindEnd
.bc21					_TSEndOfString:
.bc21	7a		ply				ply  								; so now Y is first character, X is character after end.
.bc22	48		pha				pha 								; save terminating character
.bc23	20 2b bc	jsr $bc2b			jsr 	TOKWriteBlockXY 			; write X to Y as a data block
.bc26	68		pla				pla 								; terminating character
.bc27	f0 01		beq $bc2a			beq 	_TSNotQuote					; if it wasn't EOS skip it
.bc29	e8		inx				inx
.bc2a					_TSNotQuote:
.bc2a	60		rts				rts
.bc2b					TOKWriteBlockXY:
.bc2b	86 36		stx $36				stx 	zTemp0 						; save end character
.bc2d	98		tya				tya 								; use 2's complement to work out the byte size
.bc2e	49 ff		eor #$ff			eor 	#$FF
.bc30	38		sec				sec
.bc31	65 36		adc $36				adc 	zTemp0
.bc33	1a		inc a				inc 	a 							; one extra for NULL
.bc34	20 ef bc	jsr $bcef			jsr 	TOKWriteByte
.bc37					_TOBlockLoop:
.bc37	c4 36		cpy $36				cpy 	zTemp0 						; exit if reached the end
.bc39	f0 09		beq $bc44			beq 	_TOBlockExit
.bc3b	b9 2a 05	lda $052a,y			lda 	lineBuffer,y 				; write byte out.
.bc3e	20 ef bc	jsr $bcef			jsr 	TOKWriteByte
.bc41	c8		iny				iny
.bc42	80 f3		bra $bc37			bra 	_TOBlockLoop
.bc44					_TOBlockExit:
.bc44	a9 00		lda #$00			lda 	#0 							; add NULL.
.bc46	20 ef bc	jsr $bcef			jsr 	TOKWriteByte
.bc49	60		rts				rts
.bc4a					TOKHexConstant:
.bc4a	a9 fe		lda #$fe			lda 	#KWC_HEXCONST 				; hex constant token.
.bc4c	20 ef bc	jsr $bcef			jsr 	TOKWriteByte
.bc4f	e8		inx				inx									; start of quoted string.
.bc50	da		phx				phx 								; push start of constant on top
.bc51	ca		dex				dex
.bc52					_THFindLoop:
.bc52	e8		inx				inx 	 							; this is stored in a block, so find out how long
.bc53	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; the hex constant is.
.bc56	c9 30		cmp #$30			cmp 	#"0"
.bc58	90 0c		bcc $bc66			bcc 	_THFoundEnd
.bc5a	c9 3a		cmp #$3a			cmp 	#"9"+1
.bc5c	90 f4		bcc $bc52			bcc 	_THFindLoop
.bc5e	c9 41		cmp #$41			cmp 	#"A"
.bc60	90 04		bcc $bc66			bcc 	_THFoundEnd
.bc62	c9 47		cmp #$47			cmp 	#"F"+1
.bc64	90 ec		bcc $bc52			bcc 	_THFindLoop
.bc66					_THFoundEnd:
.bc66	7a		ply				ply 								; restore start
.bc67	20 2b bc	jsr $bc2b			jsr 	TOKWriteBlockXY 			; output the block
.bc6a	60		rts				rts
.bc6b					TOKCalculateHash:
.bc6b	da		phx				phx
.bc6c	ae 00 04	ldx $0400			ldx 	identStart 					; needs to be same as in tokens.py - simple sum at present.
.bc6f	a9 00		lda #$00			lda 	#0
.bc71					_TCHLoop:
.bc71	18		clc				clc
.bc72	7d 2a 05	adc $052a,x			adc 	lineBuffer,x
.bc75	e8		inx				inx
.bc76	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; do the whole thing including type and array markers.
.bc79	d0 f6		bne $bc71			bne 	_TCHLoop
.bc7b	8d 03 04	sta $0403			sta 	identHash 					; save the hash
.bc7e	fa		plx				plx
.bc7f	60		rts				rts
.bc80					LCLFixLineBufferCase:
.bc80	a2 00		ldx #$00			ldx 	#0
.bc82					_FLBCLoop:
.bc82	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get next character
.bc85	f0 22		beq $bca9			beq 	_FLBCExit 					; end of string.
.bc87	c9 22		cmp #$22			cmp 	#'"'						; quote, go to in quotes
.bc89	f0 11		beq $bc9c			beq 	_FLBCInQuotes
.bc8b	e8		inx				inx
.bc8c	c9 61		cmp #$61			cmp 	#'a'						; needs capitalising ?
.bc8e	90 f2		bcc $bc82			bcc 	_FLBCLoop
.bc90	c9 7b		cmp #$7b			cmp 	#'z'+1
.bc92	b0 ee		bcs $bc82			bcs 	_FLBCLoop
.bc94	38		sec				sec 								; make U/C
.bc95	e9 20		sbc #$20			sbc 	#32
.bc97	9d 29 05	sta $0529,x			sta	 	lineBuffer-1,x 				; write back
.bc9a	80 e6		bra $bc82			bra 	_FLBCLoop
.bc9c					_FLBCInQuotes:
.bc9c	e8		inx				inx 								; advance
.bc9d	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get next
.bca0	f0 07		beq $bca9			beq 	_FLBCExit 					; exit on EOS
.bca2	c9 22		cmp #$22			cmp 	#'"' 				 		; until " found
.bca4	d0 f6		bne $bc9c			bne 	_FLBCInQuotes
.bca6	e8		inx				inx 								; skip over it
.bca7	80 d9		bra $bc82			bra 	_FLBCLoop
.bca9					_FLBCExit:
.bca9	60		rts				rts
.bcaa					TOKExtractLineNumber:
.bcaa	ad 2c 04	lda $042c			lda 	tokenLineNumber+1 			; push current value on stack
.bcad	48		pha				pha
.bcae	ad 2b 04	lda $042b			lda 	tokenLineNumber
.bcb1	48		pha				pha
.bcb2	20 e8 bc	jsr $bce8			jsr 	_LCLNTimes2 				; line # x 2
.bcb5	20 e8 bc	jsr $bce8			jsr 	_LCLNTimes2 				; line # x 4
.bcb8	18		clc				clc 								; add stacked value
.bcb9	68		pla				pla
.bcba	6d 2b 04	adc $042b			adc 	tokenLineNumber
.bcbd	8d 2b 04	sta $042b			sta 	tokenLineNumber
.bcc0	68		pla				pla
.bcc1	6d 2c 04	adc $042c			adc 	tokenLineNumber+1
.bcc4	8d 2c 04	sta $042c			sta 	tokenLineNumber+1 			; line # x 5
.bcc7	20 e8 bc	jsr $bce8			jsr 	_LCLNTimes2 				; line # x 10
.bcca	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get and consume character
.bccd	e8		inx				inx
.bcce	29 0f		and #$0f			and 	#15 						; add to line #
.bcd0	18		clc				clc
.bcd1	6d 2b 04	adc $042b			adc 	tokenLineNumber
.bcd4	8d 2b 04	sta $042b			sta 	tokenLineNumber
.bcd7	90 03		bcc $bcdc			bcc 	_TLENNoCarry
.bcd9	ee 2c 04	inc $042c			inc 	tokenLineNumber+1
.bcdc					_TLENNoCarry:
.bcdc	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; more digits ?
.bcdf	c9 30		cmp #$30			cmp 	#'0'
.bce1	90 04		bcc $bce7			bcc 	_TLENExit
.bce3	c9 3a		cmp #$3a			cmp 	#'9'+1
.bce5	90 c3		bcc $bcaa			bcc 	TOKExtractLineNumber
.bce7					_TLENExit:
.bce7	60		rts				rts
.bce8					_LCLNTimes2:
.bce8	0e 2b 04	asl $042b			asl 	tokenLineNumber 			; doubles tokenLineNumber.
.bceb	2e 2c 04	rol $042c			rol 	tokenLineNumber+1
.bcee	60		rts				rts
.bcef					TOKWriteByte:
.bcef	da		phx				phx
.bcf0	ae 2a 04	ldx $042a			ldx 	tokenOffset 				; next slot to write to
.bcf3	9d 2a 04	sta $042a,x			sta 	tokenOffset,x 				; write byte out
.bcf6	ee 2a 04	inc $042a			inc 	tokenOffset 				; advance slot.
.bcf9	fa		plx				plx
.bcfa	60		rts				rts
.bcfb					TOKCheckCreateVariableRecord:
.bcfb	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.bcfd	85 36		sta $36				sta 	0+zTemp0
.bcff	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.bd01	85 37		sta $37				sta 	1+zTemp0
.bd03					_CCVSearch:
.bd03	b2 36		lda ($36)			lda 	(zTemp0) 					; end of list
.bd05	f0 2c		beq $bd33			beq 	_CCVFail
.bd07	a0 01		ldy #$01			ldy 	#1 							; read the hash
.bd09	b1 36		lda ($36),y			lda 	(zTemp0),y 					; does it match ?
.bd0b	cd 03 04	cmp $0403			cmp 	identHash 	  				; if not, try the next.
.bd0e	d0 16		bne $bd26			bne 	_CCVNext
.bd10	a0 08		ldy #$08			ldy 	#8 							; name in variable record
.bd12	ae 00 04	ldx $0400			ldx 	identStart
.bd15					_CCVCompare:
.bd15	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; xor them. zero if the same, except
.bd18	51 36		eor ($36),y			eor 	(zTemp0),y 					; bit 7 is used for EOS.
.bd1a	e8		inx				inx 								; advance pointers
.bd1b	c8		iny				iny
.bd1c	0a		asl a				asl 	a 							; A = 0 if they match, CS if end.
.bd1d	d0 07		bne $bd26			bne 	_CCVNext  					; didn't match go to next.
.bd1f	90 f4		bcc $bd15			bcc 	_CCVCompare 				; not finished yet.
.bd21	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; matched whole thing ?
.bd24	f0 41		beq $bd67			beq 	_CCVFound 					; yes, we were successful
.bd26					_CCVNext:
.bd26	18		clc				clc 								; go to next record.
.bd27	b2 36		lda ($36)			lda 	(zTemp0) 					; add offset to pointer
.bd29	65 36		adc $36				adc 	zTemp0
.bd2b	85 36		sta $36				sta 	zTemp0
.bd2d	90 d4		bcc $bd03			bcc 	_CCVSearch
.bd2f	e6 37		inc $37				inc 	zTemp0+1
.bd31	80 d0		bra $bd03			bra 	_CCVSearch
.bd33					_CCVFail:
.bd33	a0 01		ldy #$01			ldy 	#1 							; create the new record. Offset 1 is hash
.bd35	ad 03 04	lda $0403			lda 	identHash
.bd38	91 36		sta ($36),y			sta 	(zTemp0),y
.bd3a	c8		iny				iny 								; offset 2 is the type byte
.bd3b	ad 04 04	lda $0404			lda 	identTypeByte
.bd3e	91 36		sta ($36),y			sta 	(zTemp0),y
.bd40	c8		iny				iny
.bd41					_CCVData:
.bd41	a9 00		lda #$00			lda 	#0 							; erase data 3-7 (the 5 value bytes)
.bd43	91 36		sta ($36),y			sta 	(zTemp0),y
.bd45	c8		iny				iny
.bd46	c0 08		cpy #$08			cpy 	#8
.bd48	90 f7		bcc $bd41			bcc 	_CCVData
.bd4a	ae 00 04	ldx $0400			ldx 	identStart 					; copy name into 8 on.
.bd4d					_CCVCopyName:
.bd4d	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.bd50	91 36		sta ($36),y			sta 	(zTemp0),y
.bd52	e8		inx				inx
.bd53	c8		iny				iny
.bd54	ec 02 04	cpx $0402			cpx 	identTypeEnd
.bd57	d0 f4		bne $bd4d			bne 	_CCVCopyName
.bd59	98		tya				tya 								; patch offset
.bd5a	92 36		sta ($36)			sta 	(zTemp0)
.bd5c	a9 00		lda #$00			lda 	#0 							; offset for next is zero.
.bd5e	91 36		sta ($36),y			sta 	(zTemp0),y
.bd60	88		dey				dey
.bd61	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set bit 7 of last bit
.bd63	09 80		ora #$80			ora 	#$80
.bd65	91 36		sta ($36),y			sta 	(zTemp0),y
.bd67					_CCVFound:
.bd67	a5 37		lda $37				lda 	zTemp0+1 					; write out MSB
.bd69	38		sec				sec
.bd6a	e9 10		sbc #$10			sbc 	#(VariableSpace >> 8) 		; offset from the start of the variable token
.bd6c	09 40		ora #$40			ora 	#$40 						; make it a writeable token $4000-$7FFF
.bd6e	20 ef bc	jsr $bcef			jsr 	TOKWriteByte
.bd71	a5 36		lda $36				lda 	zTemp0 						; write out LSB
.bd73	20 ef bc	jsr $bcef			jsr 	TOKWriteByte
.bd76	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_sound.module

=1					soundIntegrated=1
.bd77					SNDCheckChannel:
.bd77	aa		tax				tax
.bd78	bd 37 08	lda $0837,x			lda 	SNDTimeLeft,x 				; currently playing a note
.bd7b	d0 38		bne $bdb5			bne 	_SNDCCExit
.bd7d	da		phx				phx 								; save current channel
.bd7e	8a		txa				txa 								; put in A
.bd7f	20 fb bd	jsr $bdfb			jsr 	SNDFindNextNoteForA 		; is there a note for A in the queue ?
.bd82	68		pla				pla 								; channel # in A
.bd83	90 30		bcc $bdb5			bcc 	_SNDCCExit  				; nothing in the queue for this channel, exit.
.bd85	a8		tay				tay 								; Y is the channel #
.bd86	bd 2c 07	lda $072c,x			lda 	SNDQueue+1,x 				; copy data into the slot.
.bd89	99 2b 08	sta $082b,y			sta 	SNDPitchLow,y
.bd8c	bd 2d 07	lda $072d,x			lda 	SNDQueue+2,x
.bd8f	99 2f 08	sta $082f,y			sta 	SNDPitchHigh,y
.bd92	bd 2e 07	lda $072e,x			lda 	SNDQueue+3,x
.bd95	99 33 08	sta $0833,y			sta 	SNDVolume,y
.bd98	bd 2f 07	lda $072f,x			lda 	SNDQueue+4,x
.bd9b	99 37 08	sta $0837,y			sta 	SNDTimeLeft,y
.bd9e	bd 30 07	lda $0730,x			lda 	SNDQueue+5,x
.bda1	99 3b 08	sta $083b,y			sta 	SNDAdjustLow,y
.bda4	bd 31 07	lda $0731,x			lda 	SNDQueue+6,x
.bda7	99 3f 08	sta $083f,y			sta 	SNDAdjustHigh,y
.bdaa	5a		phy				phy 								; save channel #
.bdab	20 15 be	jsr $be15			jsr 	SNDDeleteXFromQueue 		; delete record at X from queue
.bdae	ce 2a 07	dec $072a			dec 	SNDLength 					; reduce the queue length.
.bdb1	68		pla				pla
.bdb2	20 b6 bd	jsr $bdb6			jsr 	SNDUpdateNote 				; update channel A
.bdb5					_SNDCCExit:
.bdb5	60		rts				rts
.bdb6					SNDUpdateNote:
.bdb6	aa		tax				tax 								; so we can access records
.bdb7	0a		asl a				asl 	a 							; convert it to a channel bit pair in 5,6
.bdb8	0a		asl a				asl 	a
.bdb9	0a		asl a				asl 	a
.bdba	0a		asl a				asl 	a
.bdbb	0a		asl a				asl 	a
.bdbc	8d 29 07	sta $0729			sta 	SNDChannelBits
.bdbf	bd 37 08	lda $0837,x			lda 	SNDTimeLeft,x 				; are we silent
.bdc2	f0 2e		beq $bdf2			beq 	_SNDUNIsSilent
.bdc4	ad 29 07	lda $0729			lda 	SNDChannelBits 				; push channel bits on stack
.bdc7	48		pha				pha
.bdc8	bd 2b 08	lda $082b,x			lda 	SNDPitchLow,x 				; get 4 lowest bits of pitch.
.bdcb	29 0f		and #$0f			and 	#$0F
.bdcd	0d 29 07	ora $0729			ora 	SNDChannelBits 				; set channel bits
.bdd0	09 80		ora #$80			ora 	#$80 						; write to pitch register
.bdd2	20 5f be	jsr $be5f			jsr 	SNDWritePorts
.bdd5	bd 2f 08	lda $082f,x			lda 	SNDPitchHigh,x 				; pitch high => channel temp.
.bdd8	8d 29 07	sta $0729			sta 	SNDChannelBits
.bddb	bd 2b 08	lda $082b,x			lda 	SNDPitchLow,x
.bdde	4e 29 07	lsr $0729			lsr 	SNDChannelBits 				; shift 2 LSBs into MSB of A
.bde1	6a		ror a				ror 	a
.bde2	4e 29 07	lsr $0729			lsr 	SNDChannelBits
.bde5	6a		ror a				ror 	a
.bde6	4a		lsr a				lsr 	a 							; put in bits 0-5
.bde7	4a		lsr a				lsr 	a
.bde8	20 5f be	jsr $be5f			jsr 	SNDWritePorts 				; write as rest of pitch register
.bdeb	68		pla				pla
.bdec	09 90		ora #$90			ora 	#$90 						; set to write minimum attentuation.
.bdee	20 5f be	jsr $be5f			jsr 	SNDWritePorts
.bdf1	60		rts				rts
.bdf2					_SNDUNIsSilent:
.bdf2	ad 29 07	lda $0729			lda 	SNDChannelBits 				; channel bits
.bdf5	09 9f		ora #$9f			ora 	#$9F 						; maximum attenuation
.bdf7	20 5f be	jsr $be5f			jsr 	SNDWritePorts 				; write to the ports
.bdfa	60		rts				rts
.bdfb					SNDFindNextNoteForA:
.bdfb	ac 2a 07	ldy $072a			ldy 	SNDLength 					; queue size into Y
.bdfe	f0 13		beq $be13			beq 	_SNDFNNFail 				; queue empty.
.be00	a2 00		ldx #$00			ldx 	#0
.be02					_SNDFNNSearch:
.be02	dd 2b 07	cmp $072b,x			cmp 	SNDQueue,x 					; does it match the channel
.be05	38		sec				sec
.be06	f0 0c		beq $be14			beq 	_SNDFNNExit 				; if so exit with CS.
.be08	e8		inx				inx 								; next queue slot.
.be09	e8		inx				inx
.be0a	e8		inx				inx
.be0b	e8		inx				inx
.be0c	e8		inx				inx
.be0d	e8		inx				inx
.be0e	e8		inx				inx
.be0f	e8		inx				inx
.be10	88		dey				dey 								; done the whole queue
.be11	d0 ef		bne $be02			bne 	_SNDFNNSearch 				; no, go back.
.be13					_SNDFNNFail:
.be13	18		clc				clc
.be14					_SNDFNNexit:
.be14	60		rts				rts
.be15					SNDDeleteXFromQueue:
.be15	e0 f8		cpx #$f8			cpx 	#SNDQueueSize*8-8 			; reached the end.
.be17	f0 09		beq $be22			beq 	_SNDDXExit
.be19	bd 33 07	lda $0733,x			lda 	SNDQueue+8,x
.be1c	9d 2b 07	sta $072b,x			sta 	SNDQueue,x
.be1f	e8		inx				inx
.be20	80 f3		bra $be15			bra 	SNDDeleteXFromQueue
.be22					_SNDDXExit:
.be22	60		rts				rts
.0729					SNDChannelBits:
>0729							.fill 	1
.be23					SNDQueueRequest:
.be23	86 36		stx $36				stx 	zTemp0						; save queue address
.be25	84 37		sty $37				sty 	zTemp0+1
.be27	ae 2a 07	ldx $072a			ldx 	SNDLength 					; queue is full, can't take any more.
.be2a	e0 20		cpx #$20			cpx 	#SNDQueueSize
.be2c	f0 21		beq $be4f			beq 	_SNDQRExit
.be2e	29 03		and #$03			and 	#3	 						; channel # and push on stack
.be30	48		pha				pha
.be31	8a		txa				txa  								; get offset in queue buffer/
.be32	0a		asl a				asl 	a
.be33	0a		asl a				asl 	a
.be34	0a		asl a				asl 	a
.be35	aa		tax				tax
.be36	68		pla				pla 								; get back and push again
.be37	48		pha				pha
.be38	9d 2b 07	sta $072b,x			sta 	SNDQueue+0,x 				; save the channel #
.be3b	a0 00		ldy #$00			ldy 	#0 							; copy the rest in.
.be3d					_SNDQCopy:
.be3d	b1 36		lda ($36),y			lda 	(zTemp0),y
.be3f	e8		inx				inx
.be40	c8		iny				iny
.be41	9d 2b 07	sta $072b,x			sta 	SNDQueue,x
.be44	c0 06		cpy #$06			cpy 	#6
.be46	d0 f5		bne $be3d			bne 	_SNDQCopy
.be48	ee 2a 07	inc $072a			inc 	SNDLength 					; bump queue length.
.be4b	68		pla				pla 								; get channel # back
.be4c	20 77 bd	jsr $bd77			jsr 	SNDCheckChannel 			; check if channel needs refreshing.
.be4f					_SNDQRExit:
.be4f	60		rts				rts
.be50					SNDSilenceChannel:
.be50	aa		tax				tax 								; zero time left.
.be51	9e 37 08	stz $0837,x			stz 	SNDTimeLeft,x
.be54	0a		asl a				asl 	a 							; shift into position
.be55	0a		asl a				asl 	a
.be56	0a		asl a				asl 	a
.be57	0a		asl a				asl 	a
.be58	0a		asl a				asl 	a
.be59	09 9f		ora #$9f			ora 	#$9F 						; write register attenuation $F
.be5b	20 5f be	jsr $be5f			jsr 	SNDWritePorts
.be5e	60		rts				rts
.be5f					SNDWritePorts:
.be5f	da		phx				phx 								; save X
.be60	a6 01		ldx $01				ldx 	1 							; save I/O status
.be62	64 01		stz $01				stz 	1 							; access I/O page 0
.be64	8d 00 d6	sta $d600			sta 	$D600 						; write to both
.be67	8d 10 d6	sta $d610			sta 	$D610
.be6a	86 01		stx $01				stx 	1 							; restore I/O
.be6c	fa		plx				plx 								; restore X
.be6d	60		rts				rts
.be6e					Export_SNDCommand:
.be6e	da		phx				phx 								; save XY
.be6f	5a		phy				phy
.be70	c9 0f		cmp #$0f			cmp 	#$0F 						; $0F is initialise
.be72	f0 1d		beq $be91			beq 	_SNDInitialise
.be74	90 28		bcc $be9e			bcc 	_SNDExit
.be76	c9 3f		cmp #$3f			cmp 	#$3F 						; $3F is silence all
.be78	f0 17		beq $be91			beq 	_SNDSilence
.be7a	b0 22		bcs $be9e			bcs 	_SNDExit
.be7c	c9 20		cmp #$20			cmp 	#$20 						; $2x is check playing => A
.be7e	b0 09		bcs $be89			bcs 	_SNDQueryPlay
.be80	c9 14		cmp #$14			cmp 	#$14 						; $10-$13 is queue sound
.be82	b0 1a		bcs $be9e			bcs 	_SNDExit
.be84	20 23 be	jsr $be23			jsr 	SNDQueueRequest
.be87	80 15		bra $be9e			bra 	_SNDExit
.be89					_SNDQueryPlay:
.be89	29 03		and #$03			and 	#3 							; get channel #
.be8b	aa		tax				tax
.be8c	bd 37 08	lda $0837,x			lda 	SNDTimeLeft,x 				; read time left, if zero then silent
.be8f	80 0d		bra $be9e			bra 	_SNDExit
.be91					_SNDInitialise:
.be91					_SNDSilence:
.be91	9c 2a 07	stz $072a			stz 	SNDLength 					; empty the queue.
.be94	a9 03		lda #$03			lda 	#$3 						; silence channel 0-3.
.be96					_SNDSilenceLoop:
.be96	48		pha				pha
.be97	20 50 be	jsr $be50			jsr 	SNDSilenceChannel
.be9a	68		pla				pla
.be9b	3a		dec a				dec 	a
.be9c	10 f8		bpl $be96			bpl 	_SNDSilenceLoop
.be9e					_SNDExit:
.be9e	7a		ply				ply
.be9f	fa		plx				plx
.bea0	60		rts				rts
=32					SNDQueueSize = 32 							; number of queue entries
.072a					SNDLength:
>072a							.fill 	1
.072b					SNDQueue:
>072b							.fill 	SNDQueueSize * 8
.082b					SNDPitchLow:
>082b							.fill 	4
.082f					SNDPitchHigh:
>082f							.fill 	4
.0833					SNDVolume:
>0833							.fill 	4
.0837					SNDTimeLeft:
>0837							.fill 	4
.083b					SNDAdjustLow:
>083b							.fill 	4
.083f					SNDAdjustHigh:
>083f							.fill 	4
.bea1					Export_SNDUpdate:
.bea1					PagedSNDUpdate:
.bea1	ad 37 08	lda $0837			lda 	SNDTimeLeft+0 				; look at time remaining
.bea4	f0 05		beq $beab			beq 	_SNDUNot0 					; not playing
.bea6	a2 00		ldx #$00			ldx 	#0 							; so we know which channel to update
.bea8	20 ca be	jsr $beca			jsr 	SNDUpdateChannel 			; update it.
.beab					_SNDUNot0:
.beab	ad 38 08	lda $0838			lda 	SNDTimeLeft+1
.beae	f0 05		beq $beb5			beq 	_SNDUNot1
.beb0	a2 01		ldx #$01			ldx 	#1
.beb2	20 ca be	jsr $beca			jsr 	SNDUpdateChannel
.beb5					_SNDUNot1:
.beb5	ad 39 08	lda $0839			lda 	SNDTimeLeft+2
.beb8	f0 05		beq $bebf			beq 	_SNDUNot2
.beba	a2 02		ldx #$02			ldx 	#2
.bebc	20 ca be	jsr $beca			jsr 	SNDUpdateChannel
.bebf					_SNDUNot2:
.bebf	ad 3a 08	lda $083a			lda 	SNDTimeLeft+3
.bec2	f0 05		beq $bec9			beq 	_SNDUNot3
.bec4	a2 03		ldx #$03			ldx 	#3
.bec6	20 ca be	jsr $beca			jsr 	SNDUpdateChannel
.bec9					_SNDUNot3:
.bec9	60		rts				rts
.beca					SNDUpdateChannel:
.beca	c9 ff		cmp #$ff			cmp 	#$FF 						; sound $FF play forever until turned off manually
.becc	f0 2c		beq $befa			beq 	_SNDUCExit
.bece	3a		dec a				dec 	a 							; decrement and update timer
.becf	9d 37 08	sta $0837,x			sta 	SNDTimeLeft,x
.bed2	f0 1d		beq $bef1			beq 	_SNDUCUpdate 				; if zero, silence channel
.bed4	bd 3b 08	lda $083b,x			lda 	SNDAdjustLow,x 				; adjust ?
.bed7	1d 3f 08	ora $083f,x			ora 	SNDAdjustHigh,x
.beda	f0 1e		beq $befa			beq 	_SNDUCExit 					; if zero carry on at current tone.
.bedc	18		clc				clc 								; add adjust, forcing into a 10 bit range
.bedd	bd 2b 08	lda $082b,x			lda 	SNDPitchLow,x
.bee0	7d 3b 08	adc $083b,x			adc 	SNDAdjustLow,x
.bee3	9d 2b 08	sta $082b,x			sta 	SNDPitchLow,x
.bee6	bd 2f 08	lda $082f,x			lda 	SNDPitchHigh,x
.bee9	7d 3f 08	adc $083f,x			adc 	SNDAdjustHigh,x
.beec	29 03		and #$03			and 	#3
.beee	9d 2f 08	sta $082f,x			sta 	SNDPitchHigh,x
.bef1					_SNDUCUpdate:
.bef1	8a		txa				txa 								; which channel.
.bef2	48		pha				pha
.bef3	20 b6 bd	jsr $bdb6			jsr 	SNDUpdateNote 				; update the current note
.bef6	68		pla				pla
.bef7	20 77 bd	jsr $bd77			jsr 	SNDCheckChannel 			; more to do ?
.befa					_SNDUCExit:
.befa	60		rts				rts

;******  Return to file: _basic.asm


;******  End of listing
