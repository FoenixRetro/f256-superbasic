
; 64tass Turbo Assembler Macro V1.57.2900 listing file
; 64tass -D AUTORUN=1 "-D MONITOR_ADDRESS=\$E000" "-D LOCKOUT_ADDRESS=\$F000" "-D BASIC_ADDRESS=\$38000" "-D SOURCE_ADDRESS=\$3000" "-D SPRITE_ADDRESS=\$30000" -q -b -Wall -c -L output/basic.lst -l output/basic.lbl -Wall -o basic.rom _basic.asm
; Mon Nov 21 12:13:42 2022

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=1					AUTORUN=1
=$e000					 MONITOR_ADDRESS=$E000
=$f000					 LOCKOUT_ADDRESS=$F000
=$38000					 BASIC_ADDRESS=$38000
=$3000					 SOURCE_ADDRESS=$3000
=$30000					 SPRITE_ADDRESS=$30000

;******  Processing input file: _basic.asm


;******  Processing file: ./common/aa.system/01common.inc

=$30					ZeroPageMandatory = $30
=$400					ZeroPagePreference = $400
=$480					MemoryStorage = $480
=$2000					BasicStart = $2000
=$8000					BasicEnd = $8000
=$8000					CodeStart = $8000
=$1000					VariableSpace = $1000
=$2000					EndVariableSpace = $2000
=8					MathStackSize = 8
=512					BasicStackSize = 512
=3584					BasicStackBase = $1000-BasicStackSize
=80					MaxLineSize = 80

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/02macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/04data.inc

.0030					codePtr:
>0030							.fill 	4
.0034					basicStack:
>0034							.fill 	2
.0036					zTemp0:
>0036							.fill 	2
.0038					zTemp1:
>0038							.fill 	2
.003a					zTemp2:
>003a							.fill 	2
.003c					zsTemp:
>003c							.fill 	2
.003e					zaTemp:
>003e							.fill 	2
=$30					safePtr = codePtr 							; minimise direct tinkering
=$80					NSBIsNegative = $80 						; bit 7 : sign of mantissa (where numeric)
=$20					NSBIsReference = $20 						; bit 5 : is a reference
=$10					NSBIsString = $10 							; bit 4 : set if string (procedures don't go on the stack)
=$18					NSBTypeMask = $18 							; bits 4,3 : 00 int 01 float 10 string 11 procedure
=$03					NSBRefMask = $03 							; bits 0,1 : Bytes of reference, -1 (e.g. 00 = 1 byte, 11 = 4 bytes)
=$04					NSBIsArray = $04
=$00					NSTInteger = $00 							; base types for bits 3..4
=$08					NSTFloat = $08
=$10					NSTString = $10
=$18					NSTProcedure = $18
.0400					NSStatus:
>0400							.fill 	MathStackSize
.0408					NSMantissa0:
>0408							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0410					NSMantissa1:
>0410							.fill 	MathStackSize
.0418					NSMantissa2:
>0418							.fill 	MathStackSize
.0420					NSMantissa3:
>0420							.fill 	MathStackSize
.0428					NSExponent:
>0428							.fill 	MathStackSize
.0480					identStart:
>0480							.fill 	1
.0481					identTypeStart:
>0481							.fill 	1
.0482					identTypeEnd:
>0482							.fill 	1
.0483					identHash:
>0483							.fill 	1
.0484					identTypeByte:
>0484							.fill 	1	 						; (see tokenising.pdf)
.0485					encodeState:
>0485							.fill 	1
.0486					digitTemp:
>0486							.fill 	1
.0487					decimalCount:
>0487							.fill 	1
.0488					randomSeed:
>0488							.fill 	4
.048c					lowMemPtr:
>048c							.fill 	2
.048e					stringMemory:
>048e							.fill 	2
.0490					stringInitialised:
>0490							.fill 	1
.0491					stringTempPointer:
>0491							.fill 	2
.0493					breakCheck:
>0493							.fill 	1
.0494					decimalPlaces:
>0494							.fill 	1
.0495					dbOffset:
>0495							.fill 	1
.0496					lastParameter:
>0496							.fill 	1
.0497					dataPointer:
>0497							.fill 	5
.049c					inDataStatement:
>049c							.fill 	1
.049d					tbOffset:
>049d							.fill 	1
.049e					AssemblerAddress:
>049e							.fill 	2
.04a0					AssemblerControl:
>04a0							.fill 	1
.04a1					ParamStart:
>04a1							.fill 	2
.04a3					IsGroup1:
>04a3							.fill 	1
.04a4					BaseOpcode:
>04a4							.fill 	1
.04a5					ModeMask:
>04a5							.fill 	1
.04a6					listIndent:
>04a6							.fill 	1
.04a7					lcLastCharacter:
>04a7							.fill 	1
.04a8					tokenOffset:
>04a8							.fill 	1
.04a9					tokenLineNumber:
>04a9							.fill 	2
.04ab					tokenBuffer:
>04ab							.fill 	253
.05a8					lineBuffer:
>05a8							.fill 	MaxLineSize+1
.05f9					numberBuffer:
>05f9							.fill 	34
.061b					decimalBuffer:
>061b							.fill 	16

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/constants.inc

=$80					AM_ISZP = $80
=$40					AM_ISG1 = $40
=$20					AM_ISG2 = $20
=224					AM_IMMEDIATE = AM_ISZP+AM_ISG1+AM_ISG2+$00
=228					AM_ZEROPAGE = AM_ISZP+AM_ISG1+AM_ISG2+$04
=40					AM_ACC = AM_ISG2+$08
=108					AM_ABS = AM_ISG1+AM_ISG2+$0C
=208					AM_INDY = AM_ISZP+AM_ISG1+$10
=244					AM_ZEROX = AM_ISZP+AM_ISG1+AM_ISG2+$14
=120					AM_ABSY = AM_ISG1+AM_ISG2+$18
=124					AM_ABSX = AM_ISG1+AM_ISG2+$1C
=209					AM_IND = AM_ISZP+AM_ISG1+$11
=$80					AM_ZEROY = AM_ISZP
=$01					AM_INDABS = $01
=$02					AM_INDABSX = $02
=192					AM_INDX = AM_ISZP+AM_ISG1+$00

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/handlers.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.inc

=1					ERRID_BREAK = 1
=2					ERRID_SYNTAX = 2
=3					ERRID_DIVZERO = 3
=4					ERRID_RANGE = 4
=5					ERRID_TYPE = 5
=6					ERRID_MEMORY = 6
=7					ERRID_ARGUMENT = 7
=8					ERRID_STOP = 8
=9					ERRID_STRING = 9
=10					ERRID_ASSERT = 10
=11					ERRID_DATA = 11
=12					ERRID_NOTDONE = 12
=13					ERRID_LINE = 13
=14					ERRID_GOSUB = 14
=15					ERRID_REPEAT = 15
=16					ERRID_WHILE = 16
=17					ERRID_FOR = 17
=18					ERRID_STACK = 18
=19					ERRID_STRUCT = 19
=20					ERRID_PROC = 20
=21					ERRID_REDEFINE = 21
=22					ERRID_ARRAYSIZE = 22
=23					ERRID_ARRAYIDX = 23

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst.inc

=$00					KWD_LESSLESS                         = $00; $00 <<
=$01					KWD_LESSEQUAL                        = $01; $01 <=
=$02					KWD_LESSGREATER                      = $02; $02 <>
=$03					KWD_PLINGPLING3                      = $03; $03 !!3
=$04					KWD_GREATERLESS                      = $04; $04 ><
=$05					KWD_GREATEREQUAL                     = $05; $05 >=
=$06					KWD_GREATERGREATER                   = $06; $06 >>
=$07					KWD_PLINGPLING7                      = $07; $07 !!7
=$08					KWD_PLINGPLING8                      = $08; $08 !!8
=$09					KWD_PLINGPLING9                      = $09; $09 !!9
=$0a					KWD_PLINGPLING10                     = $0a; $0a !!10
=$0b					KWD_PLINGPLING11                     = $0b; $0b !!11
=$0c					KWD_PLINGPLING12                     = $0c; $0c !!12
=$0d					KWD_PLINGPLING13                     = $0d; $0d !!13
=$0e					KWD_PLINGPLING14                     = $0e; $0e !!14
=$0f					KWD_PLINGPLING15                     = $0f; $0f !!15
=$10					KWD_AT                               = $10; $10 @
=$11					KWD_PLINGPLING17                     = $11; $11 !!17
=$12					KWD_PLINGPLING18                     = $12; $12 !!18
=$13					KWD_LSQPAREN                         = $13; $13 [
=$14					KWD_BACKSLASH                        = $14; $14 \
=$15					KWD_RSQPAREN                         = $15; $15 ]
=$16					KWD_HAT                              = $16; $16 ^
=$17					KWD_UNDERSCORE                       = $17; $17 _
=$18					KWD_BQUOTE                           = $18; $18 `
=$19					KWD_PLINGPLING25                     = $19; $19 !!25
=$1a					KWD_PLINGPLING26                     = $1a; $1a !!26
=$1b					KWD_LCURLY                           = $1b; $1b {
=$1c					KWD_BAR                              = $1c; $1c |
=$1d					KWD_RCURLY                           = $1d; $1d }
=$1e					KWD_TILDE                            = $1e; $1e ~
=$21					KWD_PLING                            = $21; $21 !
=$22					KWD_DQUOTE                           = $22; $22 "
=$23					KWD_HASH                             = $23; $23 #
=$24					KWD_DOLLAR                           = $24; $24 $
=$25					KWD_PERCENT                          = $25; $25 %
=$26					KWD_AMPERSAND                        = $26; $26 &
=$27					KWD_QUOTE                            = $27; $27 '
=$28					KWD_LPAREN                           = $28; $28 (
=$29					KWD_RPAREN                           = $29; $29 )
=$2a					KWD_STAR                             = $2a; $2a *
=$2b					KWD_PLUS                             = $2b; $2b +
=$2c					KWD_COMMA                            = $2c; $2c ,
=$2d					KWD_MINUS                            = $2d; $2d -
=$2e					KWD_PERIOD                           = $2e; $2e .
=$2f					KWD_SLASH                            = $2f; $2f /
=$30					KWD_0                                = $30; $30 0
=$31					KWD_1                                = $31; $31 1
=$32					KWD_2                                = $32; $32 2
=$33					KWD_3                                = $33; $33 3
=$34					KWD_4                                = $34; $34 4
=$35					KWD_5                                = $35; $35 5
=$36					KWD_6                                = $36; $36 6
=$37					KWD_7                                = $37; $37 7
=$38					KWD_8                                = $38; $38 8
=$39					KWD_9                                = $39; $39 9
=$3a					KWD_COLON                            = $3a; $3a :
=$3b					KWD_SEMICOLON                        = $3b; $3b ;
=$3c					KWD_LESS                             = $3c; $3c <
=$3d					KWD_EQUAL                            = $3d; $3d =
=$3e					KWD_GREATER                          = $3e; $3e >
=$3f					KWD_QMARK                            = $3f; $3f ?
=$83					KWD_ABSLPAREN                        = $83; $83 ABS(
=$84					KWD_ALLOCLPAREN                      = $84; $84 ALLOC(
=$85					KWD_ASCLPAREN                        = $85; $85 ASC(
=$86					KWD_CHRDOLLARLPAREN                  = $86; $86 CHR$(
=$87					KWD_EVENTLPAREN                      = $87; $87 EVENT(
=$88					KWD_FALSE                            = $88; $88 FALSE
=$89					KWD_FRACLPAREN                       = $89; $89 FRAC(
=$8a					KWD_HITLPAREN                        = $8a; $8a HIT(
=$8b					KWD_INTLPAREN                        = $8b; $8b INT(
=$8c					KWD_ISVALLPAREN                      = $8c; $8c ISVAL(
=$8d					KWD_JOYBLPAREN                       = $8d; $8d JOYB(
=$8e					KWD_JOYXLPAREN                       = $8e; $8e JOYX(
=$8f					KWD_JOYYLPAREN                       = $8f; $8f JOYY(
=$90					KWD_LEFTDOLLARLPAREN                 = $90; $90 LEFT$(
=$91					KWD_LENLPAREN                        = $91; $91 LEN(
=$92					KWD_MAXLPAREN                        = $92; $92 MAX(
=$93					KWD_MIDDOLLARLPAREN                  = $93; $93 MID$(
=$94					KWD_MINLPAREN                        = $94; $94 MIN(
=$95					KWD_NOTLPAREN                        = $95; $95 NOT(
=$96					KWD_PLAYINGLPAREN                    = $96; $96 PLAYING(
=$97					KWD_RANDOMLPAREN                     = $97; $97 RANDOM(
=$98					KWD_RIGHTDOLLARLPAREN                = $98; $98 RIGHT$(
=$99					KWD_RNDLPAREN                        = $99; $99 RND(
=$9a					KWD_SGNLPAREN                        = $9a; $9a SGN(
=$9b					KWD_SPCLPAREN                        = $9b; $9b SPC(
=$9c					KWD_STRDOLLARLPAREN                  = $9c; $9c STR$(
=$9d					KWD_TIMERLPAREN                      = $9d; $9d TIMER(
=$9e					KWD_TRUE                             = $9e; $9e TRUE
=$9f					KWD_VALLPAREN                        = $9f; $9f VAL(
=$a0					KWD_FOR                              = $a0; $a0 FOR
=$a1					KWD_IF                               = $a1; $a1 IF
=$a2					KWD_PROC                             = $a2; $a2 PROC
=$a3					KWD_REPEAT                           = $a3; $a3 REPEAT
=$a4					KWD_WHILE                            = $a4; $a4 WHILE
=$a5					KWD_ENDIF                            = $a5; $a5 ENDIF
=$a6					KWD_ENDPROC                          = $a6; $a6 ENDPROC
=$a7					KWD_NEXT                             = $a7; $a7 NEXT
=$a8					KWD_THEN                             = $a8; $a8 THEN
=$a9					KWD_UNTIL                            = $a9; $a9 UNTIL
=$aa					KWD_WEND                             = $aa; $aa WEND
=$ab					KWD_BY                               = $ab; $ab BY
=$ac					KWD_CALL                             = $ac; $ac CALL
=$ad					KWD_CIRCLE                           = $ad; $ad CIRCLE
=$ae					KWD_CLEAR                            = $ae; $ae CLEAR
=$af					KWD_CLS                              = $af; $af CLS
=$b0					KWD_COLOR                            = $b0; $b0 COLOR
=$b1					KWD_COLOUR                           = $b1; $b1 COLOUR
=$b2					KWD_DATA                             = $b2; $b2 DATA
=$b3					KWD_DIM                              = $b3; $b3 DIM
=$b4					KWD_DOWNTO                           = $b4; $b4 DOWNTO
=$b5					KWD_ELSE                             = $b5; $b5 ELSE
=$b6					KWD_FROM                             = $b6; $b6 FROM
=$b7					KWD_GFX                              = $b7; $b7 GFX
=$b8					KWD_GOSUB                            = $b8; $b8 GOSUB
=$b9					KWD_GOTO                             = $b9; $b9 GOTO
=$ba					KWD_HERE                             = $ba; $ba HERE
=$bb					KWD_IMAGE                            = $bb; $bb IMAGE
=$bc					KWD_LET                              = $bc; $bc LET
=$bd					KWD_LINE                             = $bd; $bd LINE
=$be					KWD_LOCAL                            = $be; $be LOCAL
=$bf					KWD_OFF                              = $bf; $bf OFF
=$c0					KWD_ON                               = $c0; $c0 ON
=$c1					KWD_OUTLINE                          = $c1; $c1 OUTLINE
=$c2					KWD_PALETTE                          = $c2; $c2 PALETTE
=$c3					KWD_PLOT                             = $c3; $c3 PLOT
=$c4					KWD_PRINT                            = $c4; $c4 PRINT
=$c5					KWD_READ                             = $c5; $c5 READ
=$c6					KWD_RECT                             = $c6; $c6 RECT
=$c7					KWD_REM                              = $c7; $c7 REM
=$c8					KWD_RETURN                           = $c8; $c8 RETURN
=$c9					KWD_SOLID                            = $c9; $c9 SOLID
=$ca					KWD_SOUND                            = $ca; $ca SOUND
=$cb					KWD_SPRITE                           = $cb; $cb SPRITE
=$cc					KWD_TEXT                             = $cc; $cc TEXT
=$cd					KWD_TO                               = $cd; $cd TO

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst0.inc

=$80					KWC_EOL = $80
=$ff					KWC_STRING = $FF
=$fe					KWC_HEXCONST = $FE
=$a0					KWC_FIRST_STRUCTURE = $a0
=$a5					KWC_FIRST_STRUCTURE_DEC = $a5
=$aa					KWC_LAST_STRUCTURE = $aa
=$83					KWC_FIRST_UNARY = $83
=$9f					KWC_LAST_UNARY = $9f

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/access.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/stack.inc

=$e0					STK_GOSUB = $E0
=$d0					STK_FOR = $D0
=$c0					STK_REPEAT = $C0
=$b0					STK_PROC = $B0
=$a0					STK_WHILE = $A0
=$01					STK_LOCALN = $01
=$02					STK_LOCALS = $02

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/00start.asm

.8000	a2 ff		ldx #$ff	Start:	ldx 	#$FF 						; stack reset
.8002	9a		txs				txs
.8003	20 25 aa	jsr $aa25			jsr 	EXTInitialise 				; hardware initialise
.8006	a2 80		ldx #$80			ldx 	#(Prompt >> 8) 				; prompt
.8008	a9 22		lda #$22			lda 	#(Prompt & $FF)
.800a	20 ae 8d	jsr $8dae			jsr 	PrintStringXA
.800d	a9 00		lda #$00			lda 	#0 							; graphics system initialise.
.800f	aa		tax				tax
.8010	a8		tay				tay
.8011	20 9d aa	jsr $aa9d			jsr 	GXGraphicDraw
.8014	a9 0f		lda #$0f			lda 	#$0F 						; initialise sound system
.8016	20 2b b9	jsr $b92b			jsr 	SNDCommand
.8019	20 53 88	jsr $8853			jsr 	NewProgram 					; erase current program
.801c	20 e3 82	jsr $82e3			jsr 	BackloadProgram
.801f	4c f2 89	jmp $89f2			jmp 	CommandRun
>8022	0c 2a 2a 2a 20 46 32 35		Prompt:	.text 	12,"*** F256 Junior SuperBASIC ***",13,13
>802a	36 20 4a 75 6e 69 6f 72 20 53 75 70 65 72 42 41
>803a	53 49 43 20 2a 2a 2a 0d 0d

;******  Processing file: ./common/aa.system/../generated/timestamp.asm

>8043	42 75 69 6c 74 20 4d 6f			.text "Built Monday 21-Nov-2022. Build 3432."
>804b	6e 64 61 79 20 32 31 2d 4e 6f 76 2d 32 30 32 32
>805b	2e 20 42 75 69 6c 64 20 33 34 33 32 2e

;******  Return to file: ./common/aa.system/00start.asm

>8068	0d 0d 00					.byte 	13,13,0

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/assembler.asm

.806b					AssembleGroup1:
.806b	a9 ff		lda #$ff			lda 	#$FF
.806d	8d a5 04	sta $04a5			sta 	ModeMask 					; initialise the mode mask - all for all
.8070	80 02		bra $8074			bra 	AsmGroup12
.8072					AssembleGroup2:
.8072	a9 00		lda #$00			lda 	#$00
.8074					AsmGroup12:
.8074	8d a3 04	sta $04a3			sta 	IsGroup1 					; save the 'group 1' flag
.8077	68		pla				pla 								; pop the return address to access the information following.
.8078	fa		plx				plx
.8079	20 02 81	jsr $8102			jsr 	AccessParameters 			; get opcode and save as base
.807c	8d a4 04	sta $04a4			sta 	BaseOpcode
.807f	ad a3 04	lda $04a3			lda 	IsGroup1 					; skip if group 1 as we don't have a complex mask.
.8082	d0 08		bne $808c			bne 	_AG12HaveMask
.8084	a9 02		lda #$02			lda 	#2 							; if group 2 the second parameter is the mask
.8086	20 0a 81	jsr $810a			jsr 	GetParameter		 		; e.g. which modes are supported for this operand
.8089	8d a5 04	sta $04a5			sta 	ModeMask
.808c					_AG12HaveMask:
.808c	20 45 82	jsr $8245			jsr 	TypeAndCalculateOperand 	; get zero page type
.808f	da		phx				phx 								; save found address mode
.8090	20 6e 81	jsr $816e			jsr 	AssembleModeX
.8093	fa		plx				plx  								; restore address mode
.8094	b0 0b		bcs $80a1			bcs 	_AG12Exit
.8096	20 a2 80	jsr $80a2			jsr 	PromoteToAbsolute  			; promote ZP to ABS and try that
.8099	20 6e 81	jsr $816e			jsr 	AssembleModeX
.809c	b0 03		bcs $80a1			bcs 	_AG12Exit
.809e	4c a2 9f	jmp $9fa2			jmp 	SyntaxError 				; can't do either, so must be wrong mode/operand.
.80a1					_AG12Exit:
.80a1	60		rts				rts
.80a2					PromoteToAbsolute:
.80a2	a9 6c		lda #$6c			lda 	#AM_ABS 					; lda xx
.80a4	e0 e4		cpx #$e4			cpx 	#AM_ZEROPAGE
.80a6	f0 19		beq $80c1			beq 	_PTADo
.80a8	a9 7c		lda #$7c			lda 	#AM_ABSX 					; lda xx,X
.80aa	e0 f4		cpx #$f4			cpx 	#AM_ZEROX
.80ac	f0 13		beq $80c1			beq 	_PTADo
.80ae	a9 78		lda #$78			lda 	#AM_ABSY 					; lda xx,Y
.80b0	e0 80		cpx #$80			cpx 	#AM_ZEROY
.80b2	f0 0d		beq $80c1			beq 	_PTADo
.80b4	a9 01		lda #$01			lda 	#AM_INDABS 					; lda (xx) (jump)
.80b6	e0 d1		cpx #$d1			cpx 	#AM_IND
.80b8	f0 07		beq $80c1			beq 	_PTADo
.80ba	a9 02		lda #$02			lda 	#AM_INDABSX 				; lda (xx,x) (jump)
.80bc	e0 c0		cpx #$c0			cpx 	#AM_INDX
.80be	f0 01		beq $80c1			beq 	_PTADo
.80c0	60		rts				rts
.80c1					_PTADo:
.80c1	aa		tax				tax
.80c2	60		rts				rts
.80c3					AssembleGroup3:
.80c3	68		pla				pla 								; get parameters, which is just the opcode.
.80c4	fa		plx				plx
.80c5	20 02 81	jsr $8102			jsr 	AccessParameters 			; get and output opcode
.80c8	20 1a 81	jsr $811a			jsr 	AssemblerWriteByte
.80cb	20 a9 82	jsr $82a9			jsr 	CalculateOperand 			; get a 16 bit operand
.80ce	ad 08 04	lda $0408			lda 	NSMantissa0 				; calculate the offset
.80d1	38		sec				sec
.80d2	ed 9e 04	sbc $049e			sbc 	AssemblerAddress
.80d5	48		pha				pha 								; LSB in A
.80d6	ad 10 04	lda $0410			lda 	NSMantissa1
.80d9	ed 9f 04	sbc $049f			sbc 	AssemblerAddress+1
.80dc	aa		tax				tax 								; MSB in X
.80dd	68		pla				pla
.80de	18		clc				clc 								; $80 to easy check $80-$7F, plus 1 for offset error
.80df	69 7f		adc #$7f			adc 	#$7F
.80e1	90 01		bcc $80e4			bcc 	_AG3NoCarry
.80e3	e8		inx				inx
.80e4					_AG3NoCarry:
.80e4	38		sec				sec 								; fix back and write out anyways.
.80e5	e9 80		sbc #$80			sbc 	#$80
.80e7	20 1a 81	jsr $811a			jsr 	AssemblerWriteByte
.80ea	e0 00		cpx #$00			cpx 	#0 							; was it in range
.80ec	f0 0a		beq $80f8			beq 	_AG3Exit
.80ee	ad a0 04	lda $04a0			lda 	AssemblerControl 			; are we allowing bad values ?
.80f1	29 01		and #$01			and 	#1
.80f3	f0 03		beq $80f8			beq 	_AG3Exit
.80f5	4c a7 9f	jmp $9fa7			jmp 	RangeError 					; no, branch is out of range
.80f8					_AG3Exit:
.80f8	60		rts				rts
.80f9					AssembleGroup4:
.80f9	68		pla				pla 								; pop address
.80fa	fa		plx				plx
.80fb	20 02 81	jsr $8102			jsr 	AccessParameters 			; access and get first
.80fe	20 1a 81	jsr $811a			jsr 	AssemblerWriteByte 			; output it.
.8101	60		rts				rts
.8102					AccessParameters:
.8102	8d a1 04	sta $04a1			sta 	ParamStart
.8105	8e a2 04	stx $04a2			stx 	ParamStart+1
.8108	a9 01		lda #$01			lda 	#1
.810a					GetParameter:
.810a	5a		phy				phy
.810b	a8		tay				tay
.810c	ad a1 04	lda $04a1			lda 	ParamStart
.810f	85 36		sta $36				sta 	zTemp0
.8111	ad a2 04	lda $04a2			lda 	ParamStart+1
.8114	85 37		sta $37				sta 	zTemp0+1
.8116	b1 36		lda ($36),y			lda 	(zTemp0),y
.8118	7a		ply				ply
.8119	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/aswrite.asm

.811a					AssemblerWriteByte:
.811a	48		pha			pha
.811b	ad a0 04	lda $04a0		lda 	AssemblerControl 				; check printing bytes ?
.811e	29 02		and #$02		and 	#2
.8120	f0 1b		beq $813d		beq 	_AWBNoPrint
.8122	ad 9f 04	lda $049f		lda		AssemblerAddress+1 				; print address
.8125	20 58 81	jsr $8158		jsr 	PrintHex
.8128	ad 9e 04	lda $049e		lda		AssemblerAddress
.812b	20 58 81	jsr $8158		jsr 	PrintHex
.812e	a9 20		lda #$20		lda 	#' '
.8130	20 b1 a7	jsr $a7b1		jsr 	EXTPrintCharacter
.8133	68		pla			pla 									; print byte
.8134	48		pha			pha
.8135	20 58 81	jsr $8158		jsr 	PrintHex
.8138	a9 0d		lda #$0d		lda 	#13
.813a	20 b1 a7	jsr $a7b1		jsr 	EXTPrintCharacter
.813d					_AWBNoPrint:
.813d	ad 9e 04	lda $049e		lda		AssemblerAddress				; copy address to zTemp0
.8140	85 36		sta $36			sta 	zTemp0
.8142	ad 9f 04	lda $049f		lda		AssemblerAddress+1
.8145	f0 0e		beq $8155		beq 	_AWBRange
.8147	85 37		sta $37			sta 	zTemp0+1
.8149	68		pla			pla 									; write byte out
.814a	92 36		sta ($36)		sta 	(zTemp0)
.814c	ee 9e 04	inc $049e		inc 	AssemblerAddress 				; bump address
.814f	d0 03		bne $8154		bne 	_AWBNoCarry
.8151	ee 9f 04	inc $049f		inc 	AssemblerAddress+1
.8154					_AWBNoCarry:
.8154	60		rts			rts
.8155					_AWBRange:
.8155	4c a7 9f	jmp $9fa7		jmp 	RangeError
.8158					PrintHex:
.8158	48		pha				pha
.8159	4a		lsr a				lsr 	a
.815a	4a		lsr a				lsr 	a
.815b	4a		lsr a				lsr 	a
.815c	4a		lsr a				lsr 	a
.815d	20 61 81	jsr $8161			jsr 	_PrintNibble
.8160	68		pla				pla
.8161					_PrintNibble:
.8161	29 0f		and #$0f			and 	#15
.8163	c9 0a		cmp #$0a			cmp 	#10
.8165	90 02		bcc $8169			bcc 	_NoShift
.8167	69 06		adc #$06			adc 	#6
.8169					_NoShift:
.8169	69 30		adc #$30			adc 	#48
.816b	4c b1 a7	jmp $a7b1			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/instruction.asm

.816e					AssembleModeX:
.816e	5a		phy				phy
.816f	ad a3 04	lda $04a3			lda 	IsGroup1
.8172	f0 17		beq $818b			beq 	_AMXGroup2
.8174	8a		txa				txa 							; is it in group # 1
.8175	29 40		and #$40			and 	#AM_ISG1
.8177	f0 50		beq $81c9			beq 	_AMXFail 				; no, give up.
.8179	8a		txa				txa 							; get back.
.817a	29 1f		and #$1f			and 	#$1F 					; this is now the offset.
.817c	e0 e0		cpx #$e0			cpx 	#AM_IMMEDIATE 			; if not immediate, we can continue.
.817e	d0 22		bne $81a2			bne 	_AMXHaveInfo
.8180	ad a4 04	lda $04a4			lda 	BaseOpcode 				; cannot store immediate.
.8183	c9 81		cmp #$81			cmp 	#$81
.8185	f0 42		beq $81c9			beq 	_AMXFail
.8187	a9 08		lda #$08			lda 	#8 						; if immediate we use offset 8.
.8189	80 17		bra $81a2			bra 	_AMXHaveInfo 			; odd design decision there.
.818b					_AMXGroup2:
.818b	8a		txa				txa 							; is it in group 2 ?
.818c	29 20		and #$20			and 	#AM_ISG2
.818e	f0 39		beq $81c9			beq 	_AMXFail 				; no, give up.
.8190	8a		txa				txa 							; get the offset into Y
.8191	29 1f		and #$1f			and 	#$1F
.8193	4a		lsr a				lsr 	a 						; make it 0-7.
.8194	4a		lsr a				lsr  	a
.8195	a8		tay				tay
.8196	ad a5 04	lda $04a5			lda 	ModeMask 				; shift the modemask left so you can check it against the requested offset
.8199					_AMXCheckOkay:
.8199	0a		asl a				asl 	a 						; shift modemask left enough times to check legitimate.
.819a	88		dey				dey
.819b	10 fc		bpl $8199			bpl 	_AMXCheckOkay
.819d	90 2a		bcc $81c9			bcc 	_AMXFail 				; not allowed.
.819f	8a		txa				txa  							; get mask back
.81a0	29 1f		and #$1f			and 	#$1F
.81a2					_AMXHaveInfo:
.81a2	e0 00		cpx #$00			cpx 	#$00 					; does it *require* an 8 bit operand
.81a4	10 05		bpl $81ab			bpl 	_AMXAnySize 			; checking bit 7, the zero page opcode flag.
.81a6	ac 10 04	ldy $0410			ldy 	NSMantissa1 			; fail if it is outside range, e.g. the MSB is set.
.81a9	d0 1e		bne $81c9			bne 	_AMXFail
.81ab					_AMXAnySize:
.81ab	18		clc				clc 							; add offset to the base opcode
.81ac	6d a4 04	adc $04a4			adc 	BaseOpcode
.81af					_AMXOutputCode:
.81af	20 1a 81	jsr $811a			jsr 	AssemblerWriteByte 		; write the opcode out.
.81b2	e0 28		cpx #$28			cpx 	#AM_ACC 				; A mode (e.g. ASL A)
.81b4	f0 10		beq $81c6			beq 	_AMXExit
.81b6	ad 08 04	lda $0408			lda 	NSMantissa0 				; write LSB operand
.81b9	20 1a 81	jsr $811a			jsr 	AssemblerWriteByte
.81bc	e0 00		cpx #$00			cpx 	#$00 					; zeropage ?
.81be	30 06		bmi $81c6			bmi 	_AMXExit
.81c0	ad 10 04	lda $0410			lda 	NSMantissa1 			; write MSB operand
.81c3	20 1a 81	jsr $811a			jsr 	AssemblerWriteByte
.81c6					_AMXExit:
.81c6	7a		ply				ply
.81c7	38		sec				sec
.81c8	60		rts				rts
.81c9					_AMXFail:
.81c9	a0 00		ldy #$00			ldy 	#0
.81cb					_AMXCheckOddities:
.81cb	8a		txa				txa
.81cc	d9 f4 81	cmp $81f4,y			cmp 	ExtraOpcode+2,y 		; match address mode
.81cf	d0 16		bne $81e7			bne 	_AMXCONext
.81d1	b9 f2 81	lda $81f2,y			lda 	ExtraOpcode+0,y 		; do the base opcodes match
.81d4	cd a4 04	cmp $04a4			cmp 	BaseOpcode
.81d7	d0 0e		bne $81e7			bne 	_AMXCONext
.81d9	e0 00		cpx #$00			cpx 	#$00 					; requires zero page ?
.81db	10 05		bpl $81e2			bpl 	_AMXCONotZero
.81dd	ad 10 04	lda $0410			lda 	NSMantissa1
.81e0	d0 05		bne $81e7			bne 	_AMXCONext
.81e2					_AMXCONotZero:
.81e2	b9 f3 81	lda $81f3,y			lda 	ExtraOpcode+1,y 		; get new opcode
.81e5	80 c8		bra $81af			bra 	_AMXOutputCode 			; and assemble it
.81e7					_AMXCONext:
.81e7	c8		iny				iny
.81e8	c8		iny				iny
.81e9	c8		iny				iny
.81ea	b9 f2 81	lda $81f2,y			lda 	ExtraOpcode+0,y 		; end of table
.81ed	d0 dc		bne $81cb			bne 	_AMXCheckOddities
.81ef					_AMXCOFail:
.81ef	7a		ply				ply
.81f0	18		clc				clc
.81f1	60		rts				rts
.81f2					ExtraOpcode:
>81f2	40 6c 01					.byte $40,$6c,AM_INDABS 	; jmp
>81f5	40 7c 02					.byte $40,$7C,AM_INDABSX 	; jmp
>81f8	a2 be 78					.byte $a2,$BE,AM_ABSY 		; ldx
>81fb	a2 b6 80					.byte $a2,$B6,AM_ZEROY 		; ldx
>81fe	82 96 80					.byte $82,$96,AM_ZEROY 		; stx
>8201	e2 1a 28					.byte $e2,$1a,AM_ACC 		; inc
>8204	c2 3a 28					.byte $c2,$3a,AM_ACC 		; dec
>8207	20 89 e0					.byte $20,$89,AM_IMMEDIATE 	; bit
>820a	60 9c 6c					.byte $60,$9c,AM_ABS 		; stz
>820d	60 9e 7c					.byte $60,$9e,AM_ABSX 		; stz
>8210	00						.byte $00

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/label.asm

.8211					LabelHere:
.8211	c8		iny				iny 								; skip .
.8212	a2 00		ldx #$00			ldx 	#0 							; get a term
.8214	20 de 97	jsr $97de			jsr 	EvaluateTerm 				; get a term
.8217	ad 00 04	lda $0400			lda 	NSStatus 					; needs to be an integer reference.
.821a	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.821c	d0 24		bne $8242			bne 	_ALType
.821e	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy reference address to zTemp0
.8221	85 36		sta $36				sta 	zTemp0
.8223	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.8226	85 37		sta $37				sta 	zTemp0+1
.8228	5a		phy				phy 								; copy address in.
.8229	a0 01		ldy #$01			ldy 	#1
.822b	ad 9e 04	lda $049e			lda	 	AssemblerAddress
.822e	92 36		sta ($36)			sta 	(zTemp0)
.8230	ad 9f 04	lda $049f			lda	 	AssemblerAddress+1
.8233	91 36		sta ($36),y			sta 	(zTemp0),y
.8235	c8		iny				iny
.8236	a9 00		lda #$00			lda 	#0
.8238	91 36		sta ($36),y			sta 	(zTemp0),y
.823a	c8		iny				iny
.823b	91 36		sta ($36),y			sta 	(zTemp0),y
.823d	c8		iny				iny
.823e	91 36		sta ($36),y			sta 	(zTemp0),y
.8240	7a		ply				ply
.8241	60		rts				rts
.8242					_ALType:
.8242	4c ac 9f	jmp $9fac			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/operands.asm

.8245					TypeAndCalculateOperand:
.8245	b1 30		lda ($30),y			lda 	(codePtr),y
.8247	a2 28		ldx #$28			ldx 	#AM_ACC 					; ACC if : or EOL
.8249	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.824b	f0 5b		beq $82a8			beq 	_TACOExit
.824d	c9 80		cmp #$80			cmp 	#KWC_EOL
.824f	f0 57		beq $82a8			beq 	_TACOExit
.8251	c8		iny				iny
.8252	a2 e0		ldx #$e0			ldx 	#AM_IMMEDIATE
.8254	c9 23		cmp #$23			cmp 	#KWD_HASH 					; if hash, then immediate - constant.
.8256	f0 51		beq $82a9			beq 	CalculateOperand
.8258	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; if ( then check for indirection
.825a	f0 1f		beq $827b			beq 	_TACOIndirect
.825c	88		dey				dey 								; undo get of first character
.825d	20 a9 82	jsr $82a9			jsr 	CalculateOperand 			; get operand
.8260	b1 30		lda ($30),y			lda 	(codePtr),y
.8262	a2 e4		ldx #$e4			ldx 	#AM_ZEROPAGE 				; if not, try zero page (then absolute)
.8264	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8266	d0 40		bne $82a8			bne 	_TACOExit
.8268	c8		iny				iny
.8269	20 b3 82	jsr $82b3			jsr 	TACOCheckXY 				; extract X,Y or 0 (neither) from the variable.
.826c	a2 f4		ldx #$f4			ldx 	#AM_ZEROX 					; check for X
.826e	c9 58		cmp #$58			cmp 	#'X'
.8270	f0 36		beq $82a8			beq 	_TACOExit
.8272	a2 80		ldx #$80			ldx 	#AM_ZEROY 					; check for Y
.8274	c9 59		cmp #$59			cmp 	#'Y'
.8276	f0 30		beq $82a8			beq 	_TACOExit
.8278					_TACOSyntax:
.8278	4c a2 9f	jmp $9fa2			jmp 	SyntaxError
.827b					_TACOIndirect:
.827b	20 a9 82	jsr $82a9			jsr 	CalculateOperand 			; get the operand
.827e	b1 30		lda ($30),y			lda 	(codePtr),y
.8280	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if , then it must be ,X)
.8282	f0 17		beq $829b			beq 	_TACOIndX
.8284	20 3c 8d	jsr $8d3c			jsr 	CheckRightBracket  			; otherwise must be ) or ),Y
.8287	b1 30		lda ($30),y			lda 	(codePtr),y
.8289	a2 d1		ldx #$d1			ldx 	#AM_IND
.828b	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not comma then exit with (xx)
.828d	d0 19		bne $82a8			bne 	_TACOExit
.828f	c8		iny				iny
.8290	20 b3 82	jsr $82b3			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.8293	c9 59		cmp #$59			cmp 	#'Y' 						; check Y
.8295	d0 e1		bne $8278			bne 	_TACOSyntax
.8297	a2 d0		ldx #$d0			ldx 	#AM_INDY
.8299	80 0d		bra $82a8			bra 	_TACOExit
.829b					_TACOIndX:
.829b	c8		iny				iny
.829c	20 b3 82	jsr $82b3			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.829f	c9 58		cmp #$58			cmp 	#'X' 						; check X
.82a1	d0 d5		bne $8278			bne 	_TACOSyntax
.82a3	20 3c 8d	jsr $8d3c			jsr 	CheckRightBracket			; check )
.82a6	a2 c0		ldx #$c0			ldx 	#AM_INDX
.82a8					_TACOExit:
.82a8	60		rts				rts
.82a9					CalculateOperand:
.82a9	48		pha				pha
.82aa	da		phx				phx
.82ab	a2 00		ldx #$00			ldx 	#0 							; get 16 bit integer in Slot 0
.82ad	20 79 9d	jsr $9d79			jsr 	Evaluate16BitInteger
.82b0	fa		plx				plx
.82b1	68		pla				pla
.82b2	60		rts				rts
.82b3					TACOCheckXY:
.82b3	b1 30		lda ($30),y			lda 	(codePtr),y
.82b5	29 c0		and #$c0			and 	#$C0 						; check it is an identifier reference.
.82b7	c9 40		cmp #$40			cmp 	#$40
.82b9	d0 21		bne $82dc			bne 	_TCXYFail
.82bb	b1 30		lda ($30),y			lda 	(codePtr),y
.82bd	18		clc				clc
.82be	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.82c0	85 37		sta $37				sta 	zTemp0+1
.82c2	c8		iny				iny
.82c3	b1 30		lda ($30),y			lda 	(codePtr),y
.82c5	c8		iny				iny
.82c6	85 36		sta $36				sta 	zTemp0
.82c8	5a		phy				phy 								; save position
.82c9	a0 02		ldy #$02			ldy 	#2 							; type is integer ?
.82cb	b1 36		lda ($36),y			lda 	(zTemp0),y
.82cd	d0 0c		bne $82db			bne 	_TCXYPopFail
.82cf	a0 08		ldy #$08			ldy 	#8 							; get first character, should have bit 7 set as also last.
.82d1	b1 36		lda ($36),y			lda 	(zTemp0),y
.82d3	c9 d8		cmp #$d8			cmp 	#'X'+$80 					; should be X or Y
.82d5	f0 08		beq $82df			beq 	_TCXYFound
.82d7	c9 d9		cmp #$d9			cmp 	#'Y'+$80
.82d9	f0 04		beq $82df			beq 	_TCXYFound
.82db					_TCXYPopFail:
.82db	7a		ply				ply
.82dc					_TCXYFail:
.82dc	a9 00		lda #$00			lda 	#0
.82de	60		rts				rts
.82df					_TCXYFound:
.82df	7a		ply				ply 								; restore position
.82e0	29 7f		and #$7f			and 	#$7F 						; throw bit 7
.82e2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/backload.asm

.82e3					BackloadProgram:
.82e3	a9 00		lda #$00			lda 	#((SOURCE_ADDRESS) & $FF)
.82e5	8d 2b 06	sta $062b			sta 	0+BackLoadPointer
.82e8	a9 30		lda #$30			lda 	#((SOURCE_ADDRESS) >> 8)
.82ea	8d 2c 06	sta $062c			sta 	1+BackLoadPointer
.82ed					_BPLoop:
.82ed	a2 ff		ldx #$ff			ldx 	#$FF
.82ef	8e fa ff	stx $fffa			stx 	$FFFA 						; fast mode (autorun only)
.82f2	20 1c 83	jsr $831c			jsr 	BLReadByte
.82f5	30 1e		bmi $8315			bmi 	_BPExit
.82f7					_BPCopy:
.82f7	e8		inx				inx  								; copy byte in
.82f8	9d a8 05	sta $05a8,x			sta 	lineBuffer,x
.82fb	9e a9 05	stz $05a9,x			stz 	lineBuffer+1,x
.82fe	20 1c 83	jsr $831c			jsr 	BLReadByte 					; read next byte
.8301	30 0a		bmi $830d			bmi 	_BPEndLine 					; -ve = EOL
.8303	c9 09		cmp #$09			cmp 	#9 							; handle TAB
.8305	d0 02		bne $8309			bne 	_BPNotTab
.8307	a9 20		lda #$20			lda 	#' '
.8309					_BPNotTab:
.8309	c9 20		cmp #$20			cmp 	#' ' 						; < ' ' = EOL
.830b	b0 ea		bcs $82f7			bcs 	_BPCopy
.830d					_BPEndLine:
.830d	20 bb b5	jsr $b5bb			jsr 	TokeniseLine 				; tokenise the line.
.8310	20 33 83	jsr $8333			jsr 	EditProgramCode
.8313	80 d8		bra $82ed			bra 	_BPLoop
.8315					_BPExit:
.8315	9c fa ff	stz $fffa			stz 	$FFFA 						; clear fast mode (autorun only)
.8318	20 f1 83	jsr $83f1			jsr 	ClearCommand 				; clear variables etc.
.831b	60		rts				rts
.831c					BLReadByte:
.831c	ad 2b 06	lda $062b			lda 	BackLoadPointer
.831f	85 36		sta $36				sta 	zTemp0
.8321	ad 2c 06	lda $062c			lda 	BackLoadPointer+1
.8324	85 37		sta $37				sta 	zTemp0+1
.8326	b2 36		lda ($36)			lda 	(zTemp0)
.8328	ee 2b 06	inc $062b			inc 	BackLoadPointer
.832b	d0 03		bne $8330			bne 	_BLNoCarry
.832d	ee 2c 06	inc $062c			inc 	BackLoadPointer+1
.8330					_BLNoCarry:
.8330	c9 00		cmp #$00			cmp 	#0
.8332	60		rts				rts
.062b					BackLoadPointer:
>062b							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/editor.asm

.8333					EditProgramCode:
.8333	ad a9 04	lda $04a9			lda 	TokenLineNumber 			; find the line.
.8336	ae aa 04	ldx $04aa			ldx 	TokenLineNumber+1
.8339	20 25 a2	jsr $a225			jsr 	MemorySearch
.833c	90 05		bcc $8343			bcc 	_EPCNoDelete 				; reached the end don't delete
.833e	d0 03		bne $8343			bne 	_EPCNoDelete 				; found slot but didn't match, no delete
.8340	20 46 a1	jsr $a146			jsr 	MemoryDeleteLine 			; delete the line
.8343					_EPCNoDelete:
.8343	ad ab 04	lda $04ab			lda 	TokenBuffer 				; buffer empty
.8346	c9 80		cmp #$80			cmp 	#KWC_EOL
.8348	f0 0d		beq $8357			beq 	_EPCNoInsert
.834a	ad a9 04	lda $04a9			lda 	TokenLineNumber 			; find the line - it cannot exist.
.834d	ae aa 04	ldx $04aa			ldx 	TokenLineNumber+1 			; so this can't fail, it returns some point in the code.
.8350	20 25 a2	jsr $a225			jsr 	MemorySearch
.8353	18		clc				clc 								; insert at this point.
.8354	20 7d a1	jsr $a17d			jsr 	MemoryInsertLine 			; insert the line
.8357					_EPCNoInsert:
.8357	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/warmstart.asm

.8358					WarmStart:
.8358	a2 ff		ldx #$ff			ldx 	#$FF
.835a	9a		txs				txs
.835b	20 3f a9	jsr $a93f			jsr 	EXTInputLine 				; get line to lineBuffer
.835e	20 bb b5	jsr $b5bb			jsr 	TokeniseLine 				; tokenise the line
.8361	ad a9 04	lda $04a9			lda 	TokenLineNumber 			; line number ?
.8364	0d aa 04	ora $04aa			ora 	TokenLineNumber+1
.8367	d0 17		bne $8380			bne 	_WSEditCode 				; if so,edit code.
.8369	9c a8 04	stz $04a8			stz 	TokenOffset 				; zero offset, meaning it only runs one line.
.836c	a9 a8		lda #$a8			lda 	#((TokenOffset) & $FF)
.836e	85 30		sta $30				sta 	codePtr
.8370	a9 04		lda #$04			lda 	#((TokenOffset) >> 8)
.8372	85 31		sta $31				sta 	codePtr+1
.8374	ad ab 04	lda $04ab			lda 	TokenBuffer 				; nothing to run
.8377	c9 80		cmp #$80			cmp 	#KWC_EOL
.8379	f0 dd		beq $8358			beq 	WarmStart
.837b	20 04 8a	jsr $8a04			jsr 	RUNCodePointerLine 			; execute that line.
.837e	80 d8		bra $8358			bra 	WarmStart
.8380					_WSEditCode:
.8380	20 33 83	jsr $8333			jsr 	EditProgramCode
.8383	20 f1 83	jsr $83f1			jsr 	ClearCommand
.8386	80 d0		bra $8358			bra 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assemble.asm

.8388					AssembleCommand:
.8388	a2 00		ldx #$00			ldx 	#0
.838a	20 79 9d	jsr $9d79			jsr 	Evaluate16BitInteger 		; start address
.838d	ad 08 04	lda $0408			lda 	NSMantissa0
.8390	8d 9e 04	sta $049e			sta 	AssemblerAddress
.8393	ad 10 04	lda $0410			lda 	NSMantissa1
.8396	8d 9f 04	sta $049f			sta 	AssemblerAddress+1
.8399	20 44 8d	jsr $8d44			jsr 	CheckComma
.839c	20 99 9d	jsr $9d99			jsr 	Evaluate8BitInteger 		; options
.839f	ad 08 04	lda $0408			lda 	NSMantissa0
.83a2	8d a0 04	sta $04a0			sta 	AssemblerControl
.83a5	60		rts				rts
.83a6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assert.asm

.83a7					AssertCommand:
.83a7	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.83a9	20 64 9d	jsr $9d64			jsr 	EvaluateInteger 			; the assert test
.83ac	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; exit if result is non zero.
.83af	d0 05		bne $83b6			bne 	_ACExit
.83b1	a9 0a		lda #$0a		lda	#10
.83b3	4c 55 8d	jmp $8d55		jmp	ErrorHandler
.83b6					_ACExit:
.83b6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/call.asm

.83b7					CallCommand:
.83b7	a2 00		ldx #$00			ldx 	#0
.83b9	20 79 9d	jsr $9d79			jsr 	Evaluate16BitInteger
.83bc					_CCClear
.83bc	e8		inx				inx  								; clear 1,2 and 3 (for A X Y)
.83bd	20 18 9e	jsr $9e18			jsr 	NSMSetZero
.83c0	e0 04		cpx #$04			cpx 	#4
.83c2	d0 f8		bne $83bc			bne 	_CCClear
.83c4	a2 00		ldx #$00			ldx 	#0 							; and keep trying
.83c6					_CCCParam:
.83c6	b1 30		lda ($30),y			lda 	(codePtr),y
.83c8	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.83ca	d0 09		bne $83d5			bne 	_CCCRun6502
.83cc	c8		iny				iny 								; skip comma
.83cd	e8		inx				inx	 								; next level
.83ce	20 99 9d	jsr $9d99			jsr 	Evaluate8BitInteger 		; get A/X/Y
.83d1	e0 03		cpx #$03			cpx 	#3
.83d3	90 f1		bcc $83c6			bcc 	_CCCParam 					; done all 3 ?
.83d5					_CCCRun6502:
.83d5	5a		phy				phy 								; save position
.83d6	ad 10 04	lda $0410			lda 	NSMantissa1 				; put address in zTemp0
.83d9	85 37		sta $37				sta 	zTemp0+1
.83db	ad 08 04	lda $0408			lda 	NSMantissa0
.83de	85 36		sta $36				sta 	zTemp0
.83e0	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; get registers
.83e3	ae 0a 04	ldx $040a			ldx 	NSMantissa0+2
.83e6	ac 0b 04	ldy $040b			ldy 	NSMantissa0+3
.83e9	20 ee 83	jsr $83ee			jsr 	_CCCZTemp0 					; call zTemp0
.83ec	7a		ply				ply 								; restore position and exit
.83ed	60		rts				rts
.83ee					_CCCZTemp0:
.83ee	6c 36 00	jmp ($0036)			jmp 	(zTemp0)

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/clear.asm

.83f1					ClearCommand:
.83f1	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.83f3	85 36		sta $36				sta 	0+zTemp0
.83f5	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.83f7	85 37		sta $37				sta 	1+zTemp0
.83f9					_ClearZeroLoop:
.83f9	b2 36		lda ($36)			lda 	(zTemp0) 					; end of variables
.83fb	f0 24		beq $8421			beq 	_ClearZeroEnd
.83fd	a0 03		ldy #$03			ldy 	#3 							; erase the variables
.83ff	a9 00		lda #$00			lda 	#0
.8401					_ClearOneVariable:
.8401	91 36		sta ($36),y			sta 	(zTemp0),y
.8403	c8		iny				iny
.8404	c0 08		cpy #$08			cpy 	#8
.8406	d0 f9		bne $8401			bne 	_ClearOneVariable
.8408	a0 02		ldy #$02			ldy 	#2 							; has it been marked procedure
.840a	b1 36		lda ($36),y			lda 	(zTemp0),y
.840c	c9 18		cmp #$18			cmp 	#NSTProcedure
.840e	d0 04		bne $8414			bne 	_ClearNotProcedure
.8410	a9 04		lda #$04			lda 	#NSTInteger+NSBIsArray 		; set it back to an integer array
.8412	91 36		sta ($36),y			sta 	(zTemp0),y
.8414					_ClearNotProcedure:
.8414	18		clc				clc 								; go to the next variable
.8415	b2 36		lda ($36)			lda 	(zTemp0)
.8417	65 36		adc $36				adc 	zTemp0
.8419	85 36		sta $36				sta 	zTemp0
.841b	90 dc		bcc $83f9			bcc 	_ClearZeroLoop
.841d	e6 37		inc $37				inc 	zTemp0+1
.841f	80 d8		bra $83f9			bra 	_ClearZeroLoop
.8421					_ClearZeroEnd:
.8421	18		clc				clc
.8422	a5 36		lda $36				lda 	zTemp0
.8424	69 01		adc #$01			adc 	#1
.8426	8d 8c 04	sta $048c			sta 	lowMemPtr
.8429	a5 37		lda $37				lda 	zTemp0+1
.842b	69 00		adc #$00			adc 	#0
.842d	8d 8d 04	sta $048d			sta 	lowMemPtr+1
.8430	20 d6 a6	jsr $a6d6			jsr 	StackReset
.8433	20 40 a7	jsr $a740			jsr 	StringSystemInitialise
.8436	20 45 8c	jsr $8c45			jsr 	ProcedureScan
.8439	20 c0 89	jsr $89c0			jsr 	Command_Restore
.843c	9c 9e 04	stz $049e			stz 	AssemblerAddress
.843f	9c 9f 04	stz $049f			stz 	AssemblerAddress+1
.8442	9c a0 04	stz $04a0			stz 	AssemblerControl
.8445	20 e1 99	jsr $99e1			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.8448	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/cls.asm

.8449					ClearScreen:
.8449	5a		phy				phy
.844a	a9 0c		lda #$0c			lda 	#12 						; char code 12 clears the screen.
.844c	20 b1 a7	jsr $a7b1			jsr 	EXTPrintCharacter
.844f	7a		ply				ply
.8450	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/data.asm

.8451					Command_Data:
.8451	a9 3a		lda #$3a			lda 	#KWD_COLON 					; advance to colon/EOL
.8453	a2 80		ldx #$80			ldx 	#KWC_EOL
.8455	20 97 8c	jsr $8c97			jsr 	ScanForward
.8458	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dim.asm

.8459					DimCommand:
.8459	b1 30		lda ($30),y			lda 	(codePtr),y
.845b	29 c0		and #$c0			and 	#$C0
.845d	c9 40		cmp #$40			cmp 	#$40
.845f	d0 7a		bne $84db			bne 	_DCSyntax
.8461	b1 30		lda ($30),y			lda 	(codePtr),y
.8463	18		clc				clc
.8464	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8466	85 3f		sta $3f				sta 	zaTemp+1
.8468	c8		iny				iny
.8469	b1 30		lda ($30),y			lda 	(codePtr),y
.846b	c8		iny				iny
.846c	85 3e		sta $3e				sta 	zaTemp
.846e	5a		phy				phy
.846f	a0 02		ldy #$02			ldy 	#2 						; read type byte
.8471	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8473	29 18		and #$18			and 	#NSBTypeMask 			; check it's not a procedure
.8475	c9 18		cmp #$18			cmp 	#NSTProcedure
.8477	f0 62		beq $84db			beq 	_DCSyntax
.8479	b1 3e		lda ($3e),y			lda 	(zaTemp),y 				; check it's an array
.847b	29 04		and #$04			and 	#NSBIsArray
.847d	f0 64		beq $84e3			beq 	_DCType
.847f	a0 04		ldy #$04			ldy 	#4 						; check not already defined
.8481	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8483	d0 59		bne $84de			bne 	_DCRedefine
.8485	7a		ply				ply
.8486	20 e6 84	jsr $84e6			jsr 	_DCGetSize 				; get array size, check it.
.8489	5a		phy				phy
.848a	a0 05		ldy #$05			ldy 	#5 						; store in first array size slot
.848c	91 3e		sta ($3e),y			sta 	(zaTemp),y 				; second will be zero.
.848e	7a		ply				ply 							; is there a second (e.g. ,x)
.848f	b1 30		lda ($30),y			lda 	(codePtr),y
.8491	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8493	d0 0a		bne $849f			bne 	_DCOneDimension
.8495	c8		iny				iny 							; skip comma
.8496	20 e6 84	jsr $84e6			jsr 	_DCGetSize 				; get 2nd array size
.8499	5a		phy				phy
.849a	a0 06		ldy #$06			ldy 	#6 						; store in 2nd array size
.849c	91 3e		sta ($3e),y			sta 	(zaTemp),y
.849e	7a		ply				ply
.849f					_DCOneDimension:
.849f	5a		phy				phy 							; save position
.84a0	a0 05		ldy #$05			ldy 	#5 						; dimensions + 1 in AX (as zero based)
.84a2	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84a4	aa		tax				tax
.84a5	c8		iny				iny
.84a6	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84a8	e8		inx				inx 							; bump them.
.84a9	1a		inc a				inc 	a
.84aa	20 ad 9d	jsr $9dad			jsr 	Multiply8x8 			; work out the total number of elements -> zTemp0
.84ad	a5 37		lda $37				lda 	zTemp0+1 				; don't allow more than 8192 elements whatever
.84af	29 e0		and #$e0			and 	#$E0
.84b1	d0 23		bne $84d6			bne 	_DCSize
.84b3	a0 02		ldy #$02			ldy 	#2 						; get base type
.84b5	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84b7	20 f4 84	jsr $84f4			jsr 	ScaleByBaseType 		; scale by base type
.84ba	a5 36		lda $36				lda 	zTemp0
.84bc	a6 37		ldx $37				ldx 	zTemp0+1
.84be	20 a3 99	jsr $99a3			jsr 	AllocateXABytes 		; allocate memory
.84c1	a0 03		ldy #$03			ldy 	#3 						; copy into the address.
.84c3	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84c5	c8		iny				iny
.84c6	8a		txa				txa
.84c7	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84c9	7a		ply				ply 							; get position back
.84ca	20 3c 8d	jsr $8d3c			jsr 	CheckRightBracket 		; check )
.84cd	b1 30		lda ($30),y			lda 	(codePtr),y
.84cf	c8		iny				iny 							; consume in case
.84d0	c9 2c		cmp #$2c			cmp 	#KWD_COMMA		 		; if so do another DIM.
.84d2	f0 85		beq $8459			beq 	DimCommand
.84d4	88		dey				dey 							; undo consume
.84d5	60		rts				rts
.84d6					_DCSize:
.84d6	a9 16		lda #$16		lda	#22
.84d8	4c 55 8d	jmp $8d55		jmp	ErrorHandler
.84db					_DCSyntax:
.84db	4c a2 9f	jmp $9fa2			jmp 	SyntaxError
.84de					_DCRedefine:
.84de	a9 15		lda #$15		lda	#21
.84e0	4c 55 8d	jmp $8d55		jmp	ErrorHandler
.84e3					_DCType:
.84e3	4c ac 9f	jmp $9fac			jmp 	TypeError
.84e6					_DCGetSize:
.84e6	a2 00		ldx #$00			ldx 	#0 						; get first index.
.84e8	20 99 9d	jsr $9d99			jsr 	Evaluate8BitInteger 	; get array dimension
.84eb	c9 00		cmp #$00			cmp 	#0 						; must be 1-254
.84ed	f0 e7		beq $84d6			beq 	_DCSize
.84ef	c9 fe		cmp #$fe			cmp 	#254
.84f1	f0 e3		beq $84d6			beq 	_DCSize
.84f3	60		rts				rts
.84f4					ScaleByBaseType:
.84f4	29 10		and #$10			and 	#NSBIsString 			; is it string
.84f6	d0 19		bne $8511			bne 	_SBBTString
.84f8	a5 37		lda $37				lda 	zTemp0+1 				; push value on stack
.84fa	48		pha				pha
.84fb	a5 36		lda $36				lda 	zTemp0
.84fd	48		pha				pha
.84fe	06 36		asl $36				asl 	zTemp0 					; x 2
.8500	26 37		rol $37				rol 	zTemp0+1
.8502	06 36		asl $36				asl 	zTemp0 					; x 4
.8504	26 37		rol $37				rol 	zTemp0+1
.8506	68		pla				pla 							; add stacked value = x 5
.8507	65 36		adc $36				adc 	zTemp0
.8509	85 36		sta $36				sta 	zTemp0
.850b	68		pla				pla
.850c	65 37		adc $37				adc 	zTemp0+1
.850e	85 37		sta $37				sta 	zTemp0+1
.8510	60		rts				rts
.8511					_SBBTString:
.8511	06 36		asl $36				asl 	zTemp0
.8513	26 37		rol $37				rol 	zTemp0+1
.8515	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/end.asm

.8516					EndCommand:
.8516	4c 58 83	jmp $8358			jmp 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/for.asm

.8519					ForCommand:
.8519	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; allocate 18 bytes on the return stack.
.851b	20 71 a6	jsr $a671			jsr 	StackOpen
.851e	a2 00		ldx #$00			ldx 	#0
.8520	20 de 97	jsr $97de			jsr 	EvaluateTerm
.8523	bd 00 04	lda $0400,x			lda 	NSStatus,x
.8526	c9 20		cmp #$20			cmp 	#NSBIsReference+NSTInteger 	; do we have an integer 4 byte reference.
.8528	d0 49		bne $8573			bne		_FCError
.852a	a9 3d		lda #$3d			lda 	#KWD_EQUAL 					; =
.852c	20 4c 8d	jsr $8d4c			jsr 	CheckNextA
.852f	e8		inx				inx
.8530	20 64 9d	jsr $9d64			jsr 	EvaluateInteger 			; <from> in +1
.8533	b1 30		lda ($30),y			lda 	(codePtr),y
.8535	c8		iny				iny 								; consume it
.8536	48		pha				pha 								; save on stack for later
.8537	c9 b4		cmp #$b4			cmp 	#KWD_DOWNTO
.8539	f0 04		beq $853f			beq 	_FCNoSyntax
.853b	c9 cd		cmp #$cd			cmp 	#KWD_TO
.853d	d0 37		bne $8576			bne 	_FCSyntaxError
.853f					_FCNoSyntax:
.853f	e8		inx				inx
.8540	20 64 9d	jsr $9d64			jsr 	EvaluateInteger
.8543	20 b5 a6	jsr $a6b5			jsr 	STKSaveCodePosition 		; save loop back position
.8546	68		pla				pla 								; restore DOWNTO or TO
.8547	5a		phy				phy 								; save Y on the stack
.8548	49 b4		eor #$b4			eor 	#KWD_DOWNTO 				; 0 if DOWNTO, #0 if TO
.854a	f0 02		beq $854e			beq 	_FCNotDownTo
.854c	a9 02		lda #$02			lda 	#2
.854e					_FCNotDownTo:
.854e	3a		dec a				dec 	a 							; 255 if DOWNTO, 1 if TO
.854f	a0 10		ldy #$10			ldy 	#16
.8551	91 34		sta ($34),y			sta 	(basicStack),y 				; copy that out to the Basic Stack.
.8553	a0 06		ldy #$06			ldy 	#6
.8555	ad 08 04	lda $0408			lda 	NSMantissa0
.8558	91 34		sta ($34),y			sta 	(basicStack),y
.855a	ad 10 04	lda $0410			lda 	NSMantissa1
.855d	c8		iny				iny
.855e	91 34		sta ($34),y			sta 	(basicStack),y
.8560	a0 08		ldy #$08			ldy 	#8 							; set initial index value
.8562	a2 01		ldx #$01			ldx 	#1
.8564	20 79 85	jsr $8579			jsr 	FCIntegerToStack
.8567	a0 0c		ldy #$0c			ldy 	#12 						; set the terminal value
.8569	a2 02		ldx #$02			ldx 	#2
.856b	20 79 85	jsr $8579			jsr 	FCIntegerToStack
.856e	20 99 85	jsr $8599			jsr 	CopyIndexToReference
.8571	7a		ply				ply 								; restore position
.8572	60		rts				rts
.8573					_FCError:
.8573	4c ac 9f	jmp $9fac			jmp 	TypeError
.8576					_FCSyntaxError:
.8576	4c a2 9f	jmp $9fa2			jmp 	SyntaxError
.8579					FCIntegerToStack:
.8579	3c 00 04	bit $0400,x			bit 	NSStatus,x 					; is the value negative
.857c	10 03		bpl $8581			bpl	 	_FCNotNegative
.857e	20 cd 9d	jsr $9dcd			jsr 	NSMNegateMantissa 			; if so 2's complement the mantissa
.8581					_FCNotNegative:
.8581	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy out to the basic stack
.8584	91 34		sta ($34),y			sta 	(basicStack),y
.8586	c8		iny				iny
.8587	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.858a	91 34		sta ($34),y			sta 	(basicStack),y
.858c	c8		iny				iny
.858d	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.8590	91 34		sta ($34),y			sta 	(basicStack),y
.8592	c8		iny				iny
.8593	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.8596	91 34		sta ($34),y			sta 	(basicStack),y
.8598	60		rts				rts
.8599					CopyIndexToReference:
.8599	5a		phy				phy
.859a	a0 06		ldy #$06			ldy 	#6 							; copy address-8 to write to zTemp0
.859c	38		sec				sec 								; (because we copy from offset 8)
.859d	b1 34		lda ($34),y			lda 	(basicStack),y
.859f	e9 08		sbc #$08			sbc 	#8
.85a1	85 36		sta $36				sta 	zTemp0
.85a3	c8		iny				iny
.85a4	b1 34		lda ($34),y			lda 	(basicStack),y
.85a6	e9 00		sbc #$00			sbc 	#0
.85a8	85 37		sta $37				sta 	zTemp0+1
.85aa	a2 04		ldx #$04			ldx 	#4 							; this is the copy counter/
.85ac	a0 0b		ldy #$0b			ldy 	#8+3 		 				; the MSB of the mantissa
.85ae	b1 34		lda ($34),y			lda 	(basicStack),y
.85b0	0a		asl a				asl 	a 							; into carry
.85b1	a0 08		ldy #$08			ldy 	#8 							; where to copy from.
.85b3	90 14		bcc $85c9			bcc 	_CITRNormal
.85b5	38		sec				sec
.85b6					_CITRNegative:
.85b6	a9 00		lda #$00			lda 	#0
.85b8	f1 34		sbc ($34),y			sbc 	(basicStack),y
.85ba	91 36		sta ($36),y			sta 	(zTemp0),y
.85bc	c8		iny				iny
.85bd	ca		dex				dex
.85be	d0 f6		bne $85b6			bne 	_CITRNegative
.85c0	88		dey				dey 								; look at MSB of mantissa
.85c1	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set the MSB as negative packed.
.85c3	09 80		ora #$80			ora 	#$80
.85c5	91 36		sta ($36),y			sta 	(zTemp0),y
.85c7	7a		ply				ply
.85c8	60		rts				rts
.85c9					_CITRNormal:
.85c9	b1 34		lda ($34),y			lda 	(basicStack),y 				; copy without negation.
.85cb	91 36		sta ($36),y			sta 	(zTemp0),y
.85cd	c8		iny				iny
.85ce	ca		dex				dex
.85cf	d0 f8		bne $85c9			bne 	_CITRNormal
.85d1	7a		ply				ply 								; and exit.
.85d2	60		rts				rts
.85d3					NextCommand:
.85d3	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; check FOR is TOS
.85d5	a2 11		ldx #$11			ldx 	#ERRID_FOR 					; this error
.85d7	20 9d a6	jsr $a69d			jsr 	StackCheckFrame
.85da	5a		phy				phy
.85db	a0 10		ldy #$10			ldy 	#16 						; get the step count
.85dd	b1 34		lda ($34),y			lda 	(basicStack),y
.85df	85 36		sta $36				sta 	zTemp0 						; this is the sign extend
.85e1	30 02		bmi $85e5			bmi 	_NCStepNeg
.85e3	64 36		stz $36				stz 	zTemp0 						; which is 0 or 255
.85e5					_NCStepNeg:
.85e5	a0 08		ldy #$08			ldy 	#8 							; offset to bump
.85e7	a2 04		ldx #$04			ldx 	#4 							; count to bump
.85e9	18		clc				clc
.85ea					_NCBump:
.85ea	71 34		adc ($34),y			adc 	(basicStack),y 				; add it
.85ec	91 34		sta ($34),y			sta 	(basicStack),y
.85ee	a5 36		lda $36				lda 	zTemp0 						; get sign extend for next time.
.85f0	c8		iny				iny 								; next byte
.85f1	ca		dex				dex 								; do four times
.85f2	d0 f6		bne $85ea			bne 	_NCBump
.85f4	20 99 85	jsr $8599			jsr		CopyIndexToReference		; copy it to the reference variable.
.85f7	a0 10		ldy #$10			ldy 	#16 						; get step count again
.85f9	b1 34		lda ($34),y			lda 	(basicStack),y
.85fb	0a		asl a				asl 	a 							; sign bit to carry
.85fc	a9 0c		lda #$0c			lda 	#12 						; offset of LHS = terminal offset
.85fe	85 38		sta $38				sta 	zTemp1
.8600	90 02		bcc $8604			bcc 	_NCCompRev 					; use if step is +ve
.8602	a9 08		lda #$08			lda 	#8 							; now the LHS = index value
.8604					_NCCompRev:
.8604	85 38		sta $38				sta 	zTemp1 						; so zTemp0 is the index for LHS
.8606	49 04		eor #$04			eor 	#(8^12) 					; and zTemp0+1 is the index for RHS
.8608	85 39		sta $39				sta 	zTemp1+1
.860a	a2 04		ldx #$04			ldx 	#4 							; bytes to compare
.860c	38		sec				sec
.860d					_NCCompare:
.860d	a4 38		ldy $38				ldy 	zTemp1 						; do compare using the two indices
.860f	b1 34		lda ($34),y			lda 	(basicStack),y
.8611	a4 39		ldy $39				ldy 	zTemp1+1
.8613	f1 34		sbc ($34),y			sbc 	(basicStack),y
.8615	e6 38		inc $38				inc 	zTemp1 						; bump the indices (inc,dex do not change C or V)
.8617	e6 39		inc $39				inc 	zTemp1+1
.8619	ca		dex				dex 								; do it 4 times.
.861a	d0 f1		bne $860d			bne 	_NCCompare
.861c	50 02		bvc $8620			bvc 	_NCNoOverflow 				; convert to signed comparison
.861e	49 80		eor #$80			eor 	#$80
.8620					_NCNoOverflow:
.8620	7a		ply				ply 								; restore Y position
.8621	0a		asl a				asl 	a 							; is bit 7 set.
.8622	90 04		bcc $8628			bcc 	_NCLoopback 				; if no , >= so loop back
.8624	20 8f a6	jsr $a68f			jsr 	StackClose 					; exit the loop
.8627	60		rts				rts
.8628					_NCLoopBack:
.8628	20 c6 a6	jsr $a6c6			jsr 	STKLoadCodePosition 		; loop back
.862b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/gosub.asm

.862c					Command_GOSUB:
.862c	a2 00		ldx #$00			ldx 	#0
.862e	20 79 9d	jsr $9d79			jsr 	Evaluate16BitInteger 		; line number in Stack.0
.8631	a9 e3		lda #$e3			lda 	#STK_GOSUB+3
.8633	20 71 a6	jsr $a671			jsr 	StackOpen 					; create frame
.8636	20 b5 a6	jsr $a6b5			jsr 	STKSaveCodePosition 		; save current position
.8639	4c 4f 86	jmp $864f			jmp 	GotoStackX
.863c					Command_RETURN:
.863c	a9 e0		lda #$e0			lda 	#STK_GOSUB 					; check TOS is this
.863e	a2 0e		ldx #$0e			ldx 	#ERRID_GOSUB 				; this error
.8640	20 9d a6	jsr $a69d			jsr 	StackCheckFrame
.8643	20 c6 a6	jsr $a6c6			jsr 	STKLoadCodePosition 		; restore code position
.8646	20 8f a6	jsr $a68f			jsr 	StackClose
.8649	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/goto.asm

.864a					GotoCommand:
.864a	a2 00		ldx #$00			ldx 	#0 							; GOTO where
.864c	20 79 9d	jsr $9d79			jsr 	Evaluate16BitInteger
.864f					GotoStackX:
.864f	bd 10 04	lda $0410,x			lda  	NSMantissa1,x 				; put line # in XA. I'll keep this even though
.8652	48		pha				pha 								; it is slightly inefficient, just in cases.
.8653	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.8656	fa		plx				plx
.8657	20 25 a2	jsr $a225			jsr 	MemorySearch 				; transfer to line number AX.
.865a	90 05		bcc $8661			bcc 	_GotoError 					; not found, off end.
.865c	d0 03		bne $8661			bne 	_GotoError 					; not found exactly
.865e	4c fd 89	jmp $89fd			jmp 	RunNewLine 					; and go straight to new line code.
.8661					_GotoError:
.8661	a9 0d		lda #$0d		lda	#13
.8663	4c 55 8d	jmp $8d55		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/if.asm

.8666					IfCommand:
.8666	a2 00		ldx #$00			ldx 	#0 							; If what.
.8668	20 41 9d	jsr $9d41			jsr 	EvaluateNumber
.866b	b1 30		lda ($30),y			lda 	(codePtr),y
.866d	c9 a8		cmp #$a8			cmp 	#KWD_THEN  					; could be THEN <stuff> or GOTO
.866f	d0 0a		bne $867b			bne 	_IFStructured
.8671	c8		iny				iny 								; consume THEN
.8672	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; is it zero
.8675	f0 01		beq $8678			beq 	_IfFail 					; if fail, go to next line
.8677	60		rts				rts 								; if THEN just continue
.8678					_IfFail:
.8678	4c 62 8a	jmp $8a62			jmp 	EOLCommand
.867b					_IfStructured:
.867b	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; is it zero
.867e	d0 07		bne $8687			bne 	_IfExit 					; if not, then continue normally.
.8680	a9 b5		lda #$b5			lda 	#KWD_ELSE 					; look for else/endif
.8682	a2 a5		ldx #$a5			ldx 	#KWD_ENDIF
.8684	20 97 8c	jsr $8c97			jsr 	ScanForward 				; and run from there/
.8687					_IfExit:
.8687	60		rts				rts
.8688					ElseCode:
.8688	a9 a5		lda #$a5			lda 	#KWD_ENDIF 					; else is only run after the if clause succeeds
.868a	aa		tax				tax 								; so just go to the structure exit
.868b	20 97 8c	jsr $8c97			jsr 	ScanForward
.868e	60		rts				rts
.868f					EndIf:
.868f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/let.asm

.8690					LetCommand:
.8690	a2 00		ldx #$00			ldx 	#0
.8692	b1 30		lda ($30),y			lda 	(codePtr),y
.8694	c9 10		cmp #$10			cmp 	#KWD_AT
.8696	d0 16		bne $86ae			bne 	_LCStandard
.8698	c8		iny				iny 								; skip equal
.8699	20 de 97	jsr $97de			jsr 	EvaluateTerm 				; get a number
.869c	20 22 96	jsr $9622			jsr 	Dereference 				; dereference it
.869f	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check integer
.86a2	49 20		eor #$20			eor 	#NSBIsReference	 			; toggle reference
.86a4	9d 00 04	sta $0400,x			sta 	NSStatus,x
.86a7	29 20		and #$20			and 	#NSBIsReference 			; if it is now a reference, continue
.86a9	d0 10		bne $86bb			bne 	_LCMain
.86ab	4c ac 9f	jmp $9fac			jmp 	TypeError 					; was a reference before.
.86ae					_LCStandard:
.86ae	ad ec 92	lda $92ec			lda 	PrecedenceLevel+"*"			; precedence > this
.86b1	20 06 93	jsr $9306			jsr 	EvaluateExpressionAtPrecedence
.86b4	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; is it a reference to an array
.86b7	c9 38		cmp #$38			cmp		#NSTProcedure+NSBIsReference
.86b9	f0 0e		beq $86c9			beq 	_LetGoProc 					; it's a procedure call.
.86bb					_LCMain:
.86bb	a9 3d		lda #$3d			lda 	#"=" 						; check =
.86bd	20 4c 8d	jsr $8d4c			jsr 	CheckNextA
.86c0	e8		inx				inx 								; RHS
.86c1	20 38 9d	jsr $9d38			jsr 	EvaluateValue
.86c4	ca		dex				dex
.86c5	20 cc 86	jsr $86cc			jsr 	AssignVariable
.86c8	60		rts				rts
.86c9					_LetGoProc:
.86c9	4c ca 88	jmp $88ca			jmp 	CallProcedure
.86cc					AssignVariable:
.86cc	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check the string/number type bits match
.86cf	48		pha				pha 								; save a copy
.86d0	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.86d3	29 10		and #$10			and 	#NSBIsString
.86d5	d0 0b		bne $86e2			bne 	_ASError
.86d7	68		pla				pla 								; get back
.86d8	29 10		and #$10			and 	#NSBIsString 				; check type
.86da	d0 03		bne $86df			bne 	_ASString
.86dc	4c 4a 95	jmp $954a			jmp 	AssignNumber
.86df					_ASString:
.86df	4c b8 95	jmp $95b8			jmp 	AssignString
.86e2					_ASError:
.86e2	4c ac 9f	jmp $9fac			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/list.asm

.86e5					Command_List:
.86e5	9c a6 04	stz $04a6			stz 	listIndent 					; reset indent.
.86e8	9c 0c 04	stz $040c			stz		NSMantissa0+4				; set the lower (slot 4) to 0 and upper (slot 7) to $FFFF
.86eb	9c 14 04	stz $0414			stz 	NSMantissa1+4
.86ee	a9 ff		lda #$ff			lda 	#$FF
.86f0	8d 0f 04	sta $040f			sta 	NSMantissa0+7
.86f3	8d 17 04	sta $0417			sta 	NSMantissa1+7
.86f6	b1 30		lda ($30),y			lda 	(codePtr),y
.86f8	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.86fa	f0 1e		beq $871a			beq 	_CLSecond
.86fc	20 7b 87	jsr $877b			jsr 	CLIsDigit 					; if not digit, list all
.86ff	b0 24		bcs $8725			bcs 	_CLStart
.8701	a2 04		ldx #$04			ldx 	#4 							; get 1st range into slot 4
.8703	20 79 9d	jsr $9d79			jsr 	Evaluate16BitInteger
.8706	b1 30		lda ($30),y			lda 	(codePtr),y
.8708	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.870a	f0 0e		beq $871a			beq 	_CLSecond 					; if so go get it
.870c	ad 0c 04	lda $040c			lda 	NSMantissa0+4 				; copy 4->7
.870f	8d 0f 04	sta $040f			sta 	NSMantissa0+7
.8712	ad 14 04	lda $0414			lda 	NSMantissa1+4
.8715	8d 17 04	sta $0417			sta 	NSMantissa1+7
.8718	80 0b		bra $8725			bra 	_CLStart
.871a					_CLSecond:
.871a	c8		iny				iny 								; consume comma
.871b	20 7b 87	jsr $877b			jsr 	CLIsDigit 					; digit found
.871e	b0 05		bcs $8725			bcs 	_CLStart 					; if not, continue listing
.8720	a2 07		ldx #$07			ldx 	#7 							; load 2nd range into slot 7
.8722	20 79 9d	jsr $9d79			jsr 	Evaluate16BitInteger
.8725					_CLStart
.8725	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8727	85 30		sta $30				sta 	codePtr
.8729	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.872b	85 31		sta $31				sta 	codePtr+1
.872d					_CLLoop:
.872d	20 53 aa	jsr $aa53			jsr 	EXTBreakCheck 				; break check
.8730	f0 33		beq $8765			beq 	_CLExit
.8732	b2 30		lda ($30)			lda 	(codePtr)
.8734	f0 2f		beq $8765			beq 	_CLExit
.8736	a2 04		ldx #$04			ldx 	#4 							; check range every time, line numbers aren't in order.
.8738	20 68 87	jsr $8768			jsr 	CLCompareLineNo
.873b	90 1b		bcc $8758			bcc 	_CLNext
.873d	a2 07		ldx #$07			ldx 	#7
.873f	20 68 87	jsr $8768			jsr 	CLCompareLineNo
.8742	f0 02		beq $8746			beq 	_CLDoThisOne
.8744	b0 12		bcs $8758			bcs 	_CLNext
.8746					_CLDoThisOne:
.8746	20 fa 8c	jsr $8cfa			jsr 	ScanGetCurrentLineStep 		; get indent adjust.
.8749	20 9d b3	jsr $b39d			jsr 	ListConvertLine 			; convert line into token Buffer
.874c	a2 04		ldx #$04			ldx 	#(tokenBuffer >> 8) 		; print that line
.874e	a9 ab		lda #$ab			lda 	#(tokenBuffer & $FF)
.8750	20 ae 8d	jsr $8dae			jsr 	PrintStringXA
.8753	a9 0d		lda #$0d			lda 	#13 						; new line
.8755	20 b1 a7	jsr $a7b1			jsr 	EXTPrintCharacter
.8758					_CLNext:
.8758	18		clc				clc
.8759	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.875b	65 30		adc $30				adc 	codePtr
.875d	85 30		sta $30				sta 	codePtr
.875f	90 02		bcc $8763			bcc 	_CREExit
.8761	e6 31		inc $31				inc 	codePtr+1
.8763					_CREExit:
.8763	80 c8		bra $872d			bra 	_CLLoop
.8765					_CLExit:
.8765	4c 58 83	jmp $8358			jmp 	WarmStart
.8768					CLCompareLineNo:
.8768	38		sec				sec
.8769	a0 01		ldy #$01			ldy 	#1
.876b	b1 30		lda ($30),y			lda 	(codePtr),y
.876d	fd 08 04	sbc $0408,x			sbc 	NSMantissa0,x
.8770	85 36		sta $36				sta 	zTemp0
.8772	c8		iny				iny
.8773	b1 30		lda ($30),y			lda 	(codePtr),y
.8775	fd 10 04	sbc $0410,x			sbc 	NSMantissa1,x
.8778	05 36		ora $36				ora 	zTemp0
.877a	60		rts				rts
.877b					CLIsDigit:
.877b	b1 30		lda ($30),y			lda 	(codePtr),y
.877d	c9 30		cmp #$30			cmp 	#"0"
.877f	90 03		bcc $8784			bcc	 	_CLIDExitFalse
.8781	c9 3a		cmp #$3a			cmp 	#"9"+1
.8783	60		rts				rts
.8784					_CLIDExitFalse:
.8784	38		sec				sec
.8785	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/local.asm

.8786					Command_LOCAL:
.8786	a2 00		ldx #$00			ldx 	#0 							; at level 0
.8788	20 94 87	jsr $8794			jsr 	LocaliseNextTerm 			; convert term to a local.
.878b	b1 30		lda ($30),y			lda 	(codePtr),y
.878d	c8		iny				iny
.878e	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8790	f0 f4		beq $8786			beq 	Command_LOCAL
.8792	88		dey				dey 								; unpick pre-get
.8793	60		rts				rts
.8794					LocaliseNextTerm:
.8794	20 de 97	jsr $97de			jsr 	EvaluateTerm 				; evaluate the term
.8797	bd 00 04	lda $0400,x			lda 	NSStatus,x
.879a	29 20		and #$20			and 	#NSBIsReference 			; check it is a reference
.879c	f0 61		beq $87ff			beq		_LNTError
.879e	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address of variable to zTemp0
.87a1	85 36		sta $36				sta 	zTemp0
.87a3	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.87a6	85 37		sta $37				sta  	zTemp0+1
.87a8	bd 00 04	lda $0400,x			lda 	NSStatus,x
.87ab	29 10		and #$10			and 	#NSBIsString
.87ad	d0 1e		bne $87cd			bne 	_LNTPushString
.87af	5a		phy				phy
.87b0	a0 00		ldy #$00			ldy 	#0 							; push 0 to 4 inclusive, the number values, on the stack, and zero them as you go.
.87b2					_LNTPushNumLoop:
.87b2	b1 36		lda ($36),y			lda		(zTemp0),y
.87b4	20 4f a6	jsr $a64f			jsr 	StackPushByte
.87b7	c8		iny				iny
.87b8	c0 05		cpy #$05			cpy 	#5
.87ba	d0 f6		bne $87b2			bne 	_LNTPushNumLoop
.87bc	a5 36		lda $36				lda 	zTemp0 						; push the actual target address to write on the stack
.87be	20 4f a6	jsr $a64f			jsr 	StackPushByte
.87c1	a5 37		lda $37				lda 	zTemp0+1
.87c3	20 4f a6	jsr $a64f			jsr 	StackPushByte
.87c6	a9 01		lda #$01			lda 	#STK_LOCALN 				; push local-number marker.
.87c8	20 4f a6	jsr $a64f			jsr 	StackPushByte
.87cb	7a		ply				ply
.87cc	60		rts				rts
.87cd					_LNTPushString:
.87cd	5a		phy				phy
.87ce	b2 36		lda ($36)			lda 	(zTemp0) 					; put address of string in zTemp1
.87d0	85 38		sta $38				sta 	zTemp1
.87d2	a0 01		ldy #$01			ldy 	#1
.87d4	b1 36		lda ($36),y			lda 	(zTemp0),y
.87d6	85 39		sta $39				sta 	zTemp1+1
.87d8	a0 00		ldy #$00			ldy 	#0 							; output string
.87da	c9 00		cmp #$00			cmp 	#0 							; if not assigned strin
.87dc	f0 0a		beq $87e8			beq 	_LNTStringOut
.87de					_LNTPushStrLoop:
.87de	b1 38		lda ($38),y			lda 	(zTemp1),y
.87e0	f0 06		beq $87e8			beq 	_LNTStringOut
.87e2	20 4f a6	jsr $a64f			jsr 	StackPushByte
.87e5	c8		iny				iny
.87e6	80 f6		bra $87de			bra 	_LNTPushStrLoop
.87e8					_LNTStringOut:
.87e8	98		tya				tya									; output length
.87e9	20 4f a6	jsr $a64f			jsr 	StackPushByte
.87ec	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; output address of the string record *not* the string itself
.87ef	20 4f a6	jsr $a64f			jsr 	StackPushByte
.87f2	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.87f5	20 4f a6	jsr $a64f			jsr 	StackPushByte
.87f8	a9 02		lda #$02			lda 	#STK_LOCALS 				; push local-string marker.
.87fa	20 4f a6	jsr $a64f			jsr 	StackPushByte
.87fd	7a		ply				ply
.87fe	60		rts				rts
.87ff					_LNTError:
.87ff	4c a2 9f	jmp $9fa2			jmp 	SyntaxError
.8802					LocalPopValue:
.8802	20 68 a6	jsr $a668			jsr 	StackPopByte
.8805	c9 01		cmp #$01			cmp 	#STK_LOCALN 				; if not local-N
.8807	d0 17		bne $8820			bne 	_LPVString
.8809	20 68 a6	jsr $a668			jsr 	StackPopByte 				; address
.880c	85 37		sta $37				sta 	zTemp0+1
.880e	20 68 a6	jsr $a668			jsr 	StackPopByte
.8811	85 36		sta $36				sta 	zTemp0
.8813	5a		phy				phy
.8814	a0 04		ldy #$04			ldy 	#4 							; copy back
.8816					_LPVNumberCopy:
.8816	20 68 a6	jsr $a668			jsr 	StackPopByte
.8819	91 36		sta ($36),y			sta 	(zTemp0),y
.881b	88		dey				dey
.881c	10 f8		bpl $8816			bpl 	_LPVNumberCopy
.881e	7a		ply				ply 								; and complete
.881f	60		rts				rts
.8820					_LPVString:
.8820	20 68 a6	jsr $a668			jsr 	StackPopByte 				; address of record => zTemp0
.8823	85 37		sta $37				sta 	zTemp0+1
.8825	20 68 a6	jsr $a668			jsr 	StackPopByte
.8828	85 36		sta $36				sta 	zTemp0
.882a	5a		phy				phy
.882b	b2 36		lda ($36)			lda 	(zTemp0) 					; address to write string to => zTemp1
.882d	85 38		sta $38				sta 	zTemp1
.882f	a0 01		ldy #$01			ldy 	#1
.8831	b1 36		lda ($36),y			lda 	(zTemp0),y
.8833	85 39		sta $39				sta 	zTemp1+1
.8835	20 68 a6	jsr $a668			jsr 	StackPopByte 				; # to get => y
.8838	a8		tay				tay
.8839	a5 39		lda $39				lda 	zTemp1+1 					; if no target (e.g. was "" originally) exit
.883b	f0 0e		beq $884b			beq 	_LPVStringCopied
.883d	a9 00		lda #$00			lda 	#0 							; NULL on end
.883f	91 38		sta ($38),y			sta 	(zTemp1),y
.8841					_LPVStringCopy:
.8841	88		dey				dey
.8842	30 07		bmi $884b			bmi 	_LPVStringCopied
.8844	20 68 a6	jsr $a668			jsr 	StackPopByte
.8847	91 38		sta ($38),y			sta 	(zTemp1),y
.8849	80 f6		bra $8841			bra 	_LPVStringCopy
.884b					_LPVStringCopied:
.884b	fa		plx				plx
.884c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/new.asm

.884d					NewCommand:
.884d	20 53 88	jsr $8853			jsr 	NewProgram
.8850	4c 58 83	jmp $8358			jmp 	WarmStart
.8853					NewProgram:
.8853	20 03 a2	jsr $a203			jsr 	MemoryNew
.8856	9c 00 10	stz $1000			stz 	VariableSpace 				; erase all variables.
.8859	20 f1 83	jsr $83f1			jsr 	ClearCommand 				; clear everything.
.885c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/print.asm

.885d					Command_Print:
.885d	18		clc				clc 								; carry being clear means last print wasn't comma/semicolon
.885e					_CPLoop:
.885e	08		php				php 								; save last action flag
.885f	b1 30		lda ($30),y			lda 	(codePtr),y
.8861	c9 80		cmp #$80			cmp  	#KWC_EOL 					; end of line or colon, exit now.
.8863	f0 46		beq $88ab			beq 	_CPExit
.8865	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.8867	f0 42		beq $88ab			beq 	_CPExit
.8869	68		pla				pla 								; throw last action flag
.886a	b1 30		lda ($30),y			lda 	(codePtr),y
.886c	c8		iny				iny
.886d	c9 3b		cmp #$3b			cmp 	#KWD_SEMICOLON				; is it a semicolon
.886f	f0 37		beq $88a8			beq 	_CPContinueWithSameLine
.8871	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; comma
.8873	f0 2e		beq $88a3			beq 	_CPTab
.8875	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; apostrophe (new line)
.8877	f0 26		beq $889f			beq 	_CPNewLine
.8879	88		dey				dey 								; undo the get.
.887a	a2 00		ldx #$00			ldx 	#0
.887c	20 38 9d	jsr $9d38			jsr 	EvaluateValue 				; get a value into slot 0
.887f	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; is it a number
.8882	29 10		and #$10			and 	#NSBIsString
.8884	f0 0b		beq $8891			beq 	_CPNumber
.8886	ae 10 04	ldx $0410			ldx 	NSMantissa1 				; string, print the text.
.8889	ad 08 04	lda $0408			lda 	NSMantissa0
.888c	20 b4 88	jsr $88b4			jsr 	CPPrintStringXA
.888f	80 cc		bra $885d			bra 	Command_Print 				; loop round clearing carry so NL if end
.8891					_CPNumber:
.8891	a9 05		lda #$05			lda 	#5 							; maximum decimals
.8893	20 0e 9c	jsr $9c0e			jsr 	ConvertNumberToString 		; convert to string
.8896	a2 06		ldx #$06			ldx 	#DecimalBuffer >> 8
.8898	a9 1b		lda #$1b			lda 	#DecimalBuffer & $FF
.889a	20 b4 88	jsr $88b4			jsr 	CPPrintStringXA
.889d	80 be		bra $885d			bra 	Command_Print 				; loop round clearing carry so NL if end
.889f					_CPNewLine:
.889f	a9 0d		lda #$0d			lda 	#13
.88a1	80 02		bra $88a5			bra 	_CPPrintChar
.88a3					_CPTab:
.88a3	a9 09		lda #$09			lda 	#9 							; print TAB
.88a5					_CPPrintChar:
.88a5	20 c7 88	jsr $88c7			jsr 	CPPrintVector
.88a8					_CPContinueWithSameLine:
.88a8	38		sec				sec 								; loop round with carry set, which
.88a9	80 b3		bra $885e			bra 	_CPLoop 					; will inhibit final CR
.88ab					_CPExit:
.88ab	28		plp				plp 								; get last action flag
.88ac	b0 05		bcs $88b3			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.88ae	a9 0d		lda #$0d			lda 	#13 						; print new line
.88b0	20 c7 88	jsr $88c7			jsr 	CPPrintVector
.88b3					_CPExit2:
.88b3	60		rts				rts
.88b4					CPPrintStringXA:
.88b4	5a		phy				phy
.88b5	86 37		stx $37				stx 	zTemp0+1
.88b7	85 36		sta $36				sta 	zTemp0
.88b9	a0 00		ldy #$00			ldy 	#0
.88bb					_PSXALoop:
.88bb	b1 36		lda ($36),y			lda 	(zTemp0),y
.88bd	f0 06		beq $88c5			beq 	_PSXAExit
.88bf	20 c7 88	jsr $88c7			jsr 	CPPrintVector
.88c2	c8		iny				iny
.88c3	80 f6		bra $88bb			bra 	_PSXALoop
.88c5					_PSXAExit:
.88c5	7a		ply				ply
.88c6	60		rts				rts
.88c7					CPPrintVector:
.88c7	4c b1 a7	jmp $a7b1			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/procedure.asm

=2					ParameterStackPos = 2
.88ca					CallProcedure:
.88ca	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start storing parameters at 2.
.88cc	b1 30		lda ($30),y			lda 	(codePtr),y
.88ce	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.88d0	f0 0c		beq $88de			beq 	_CPEndParam
.88d2					_CPParamLoop:
.88d2	20 38 9d	jsr $9d38			jsr 	EvaluateValue 				; get parameter onto stack
.88d5	e8		inx				inx 								; bump next stack
.88d6	b1 30		lda ($30),y			lda 	(codePtr),y
.88d8	c8		iny				iny
.88d9	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if comma, go back and try again.
.88db	f0 f5		beq $88d2			beq 	_CPParamLoop
.88dd	88		dey				dey 								; unpick.
.88de					_CPEndParam:
.88de	8e 96 04	stx $0496			stx 	LastParameter 				; save the last parameters index.
.88e1	c8		iny				iny									; skip right bracket
.88e2	a9 b3		lda #$b3			lda 	#STK_PROC+3 				; allocate 6 bytes on the return stack.
.88e4	20 71 a6	jsr $a671			jsr 	StackOpen
.88e7	20 b5 a6	jsr $a6b5			jsr 	STKSaveCodePosition 		; save loop position
.88ea	ad 08 04	lda $0408			lda 	NSMantissa0 				; copy variable (e.g. procedure) address to zTemp0
.88ed	85 36		sta $36				sta 	zTemp0 						; this is the DATA not the RECORD
.88ef	ad 10 04	lda $0410			lda 	NSMantissa1
.88f2	85 37		sta $37				sta 	zTemp0+1
.88f4	a0 01		ldy #$01			ldy 	#1 							; copy code address back.
.88f6	b2 36		lda ($36)			lda 	(zTemp0)
.88f8	85 30		sta $30				sta 	safePtr
.88fa	b1 36		lda ($36),y			lda 	(zTemp0),y
.88fc	85 31		sta $31				sta 	safePtr+1
.88fe	c8		iny				iny
.88ff	b1 36		lda ($36),y			lda 	(zTemp0),y
.8901	85 32		sta $32				sta 	safePtr+2
.8903	c8		iny				iny
.8904	b1 36		lda ($36),y			lda 	(zTemp0),y
.8906	85 33		sta $33				sta 	safePtr+3
.8908	c8		iny				iny 								; get Y offset -> Y
.8909	b1 36		lda ($36),y			lda 	(zTemp0),y
.890b	a8		tay				tay
.890c	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start position of parameters
.890e	ec 96 04	cpx $0496			cpx	 	LastParameter 				; check no parameters at the start
.8911	f0 13		beq $8926			beq 	_ParamExit 					; if so, exit.
.8913					_ParamExtract:
.8913	ca		dex				dex 								; put a local term on the level before
.8914	20 94 87	jsr $8794			jsr 	LocaliseNextTerm			; also pushes original param value to basic stack
.8917	20 cc 86	jsr $86cc			jsr 	AssignVariable 				; assign stacked value to the variable.
.891a	e8		inx				inx 								; advance to next parameter to do.
.891b	e8		inx				inx
.891c	ec 96 04	cpx $0496			cpx 	LastParameter 				; are we done ?
.891f	f0 05		beq $8926			beq 	_ParamExit
.8921	20 44 8d	jsr $8d44			jsr 	CheckComma 					; comma seperating parameters
.8924	80 ed		bra $8913			bra 	_ParamExtract
.8926					_ParamExit:
.8926	20 3c 8d	jsr $8d3c			jsr 	CheckRightBracket 			; check )
.8929	60		rts				rts 								; and continue from here
.892a					Command_ENDPROC:
.892a	a9 b0		lda #$b0			lda 	#STK_PROC 					; check TOS is this
.892c	a2 14		ldx #$14			ldx 	#ERRID_PROC
.892e	20 9d a6	jsr $a69d			jsr 	StackCheckFrame
.8931	20 c6 a6	jsr $a6c6			jsr 	STKLoadCodePosition 		; restore code position
.8934	20 8f a6	jsr $a68f			jsr 	StackClose
.8937	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/read.asm

.8938					Command_Read:
.8938	a2 00		ldx #$00			ldx 	#0 							; evaluate the term which is the var/array element to assign
.893a	20 de 97	jsr $97de			jsr 	EvaluateTerm
.893d	bd 00 04	lda $0400,x			lda 	NSStatus,x
.8940	29 20		and #$20			and 	#NSBIsReference				; get status byte on stack, identifies int, float, string.
.8942	f0 4a		beq $898e			beq 	_CRSyntax 					; check reference (bit 0)
.8944	20 d7 89	jsr $89d7			jsr 	SwapDataCodePtrs 			; swap code and data
.8947	ad 9c 04	lda $049c			lda 	inDataStatement 			; if in a data statement, we don't need to search
.894a	d0 20		bne $896c			bne 	_CRContinueData
.894c					_CRKeepSearching:
.894c	a9 b2		lda #$b2			lda 	#KWD_DATA 					; scan for instruction
.894e	aa		tax				tax
.894f	20 97 8c	jsr $8c97			jsr 	ScanForward
.8952	c9 b2		cmp #$b2			cmp 	#KWD_DATA 					; found data ?
.8954	f0 16		beq $896c			beq 	_CRHaveData 				; found it
.8956	18		clc				clc
.8957	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.8959	65 30		adc $30				adc 	codePtr
.895b	85 30		sta $30				sta 	codePtr
.895d	90 02		bcc $8961			bcc 	_CREExit
.895f	e6 31		inc $31				inc 	codePtr+1
.8961					_CREExit:
.8961	a0 03		ldy #$03			ldy 	#3 							; start of line.
.8963	b2 30		lda ($30)			lda 	(codePtr)
.8965	d0 e5		bne $894c			bne 	_CRKeepSearching
.8967	a9 0b		lda #$0b		lda	#11
.8969	4c 55 8d	jmp $8d55		jmp	ErrorHandler
.896c					_CRHaveData:
.896c					_CRContinueData:
.896c	a2 01		ldx #$01			ldx 	#1
.896e	20 38 9d	jsr $9d38			jsr 	EvaluateValue 				; evaluate value into slot # 1
.8971	ca		dex				dex
.8972	20 cc 86	jsr $86cc			jsr		AssignVariable 				; do the assignment
.8975	9c 9c 04	stz $049c			stz 	inDataStatement 			; clear in data
.8978	b1 30		lda ($30),y			lda 	(codePtr),y
.897a	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not, end of data statement
.897c	d0 04		bne $8982			bne 	_CRSwapBack
.897e	c8		iny				iny 								; consume comma
.897f	ee 9c 04	inc $049c			inc 	inDataStatement 			; set in data statement currently.
.8982					_CRSwapBack:
.8982	20 d7 89	jsr $89d7			jsr 	SwapDataCodePtrs			; swap them back.
.8985	b1 30		lda ($30),y			lda 	(codePtr),y
.8987	c8		iny				iny
.8988	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.898a	f0 ac		beq $8938			beq 	Command_Read 				; if so go round again.
.898c	88		dey				dey 								; unpick get.
.898d	60		rts				rts
.898e					_CRSyntax:
.898e	4c a2 9f	jmp $9fa2			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/rem.asm

.8991					RemCommand:
.8991	b1 30		lda ($30),y			lda 	(codePtr),y
.8993	c9 ff		cmp #$ff			cmp 	#KWC_STRING
.8995	d0 06		bne $899d			bne 	_RMExit
.8997	c8		iny				iny
.8998	98		tya				tya
.8999	38		sec				sec
.899a	71 30		adc ($30),y			adc 	(codePtr),y
.899c	a8		tay				tay
.899d					_RMExit:
.899d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/repeat.asm

.899e					Command_REPEAT:
.899e	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; allocate 6 bytes on the return stack.
.89a0	20 71 a6	jsr $a671			jsr 	StackOpen
.89a3	20 b5 a6	jsr $a6b5			jsr 	STKSaveCodePosition 		; save loop position
.89a6	60		rts				rts
.89a7					Command_UNTIL:
.89a7	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; check REPEAT is TOS
.89a9	a2 0f		ldx #$0f			ldx 	#ERRID_REPEAT 				; this error
.89ab	20 9d a6	jsr $a69d			jsr 	StackCheckFrame
.89ae	a2 00		ldx #$00			ldx 	#0
.89b0	20 41 9d	jsr $9d41			jsr 	EvaluateNumber 				; work out the number
.89b3	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; check if zero
.89b6	f0 04		beq $89bc			beq 	_CULoopBack 				; if so keep looping
.89b8	20 8f a6	jsr $a68f			jsr 	StackClose		 			; return
.89bb	60		rts				rts
.89bc					_CULoopBack:
.89bc	20 c6 a6	jsr $a6c6			jsr 	STKLoadCodePosition 		; loop back
.89bf	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/restore.asm

.89c0					Command_Restore:
.89c0	20 d7 89	jsr $89d7			jsr 	SwapDataCodePtrs 			; swap code and data
.89c3	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.89c5	85 30		sta $30				sta 	codePtr
.89c7	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.89c9	85 31		sta $31				sta 	codePtr+1
.89cb	20 d7 89	jsr $89d7			jsr 	SwapDataCodePtrs 			; put them back
.89ce	a9 03		lda #$03			lda 	#3 							; start at offset 3, e.g. first instruction of first line.
.89d0	8d 9b 04	sta $049b			sta 	dataPointer+4
.89d3	9c 9c 04	stz $049c			stz 	inDataStatement 			; not in data statement
.89d6	60		rts				rts
.89d7					SwapDataCodePtrs:
.89d7	da		phx				phx
.89d8	a2 03		ldx #$03			ldx 	#3 							; swap 32 bit code pointer over
.89da					_SDCPLoop:
.89da	b5 30		lda $30,x			lda 	safePtr,x
.89dc	48		pha				pha
.89dd	bd 97 04	lda $0497,x			lda 	dataPointer,x
.89e0	95 30		sta $30,x			sta 	safePtr,x
.89e2	68		pla				pla
.89e3	9d 97 04	sta $0497,x			sta 	dataPointer,x
.89e6	ca		dex				dex
.89e7	10 f1		bpl $89da			bpl 	_SDCPLoop
.89e9	ad 9b 04	lda $049b			lda 	dataPointer+4 				; swap Y position over.
.89ec	8c 9b 04	sty $049b			sty 	dataPointer+4
.89ef	a8		tay				tay
.89f0	fa		plx				plx
.89f1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/run.asm

.89f2					CommandRUN:
.89f2	20 f1 83	jsr $83f1			jsr 	ClearCommand 				; clear variable/stacks/etc.
.89f5	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.89f7	85 30		sta $30				sta 	codePtr
.89f9	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.89fb	85 31		sta $31				sta 	codePtr+1
.89fd					RUNNewLine:
.89fd	b2 30		lda ($30)			lda 	(codePtr)
.89ff	f0 5e		beq $8a5f			beq 	CRNoProgram         		; no then END.
.8a01	a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack
.8a03	9a		txs				txs
.8a04					RUNCodePointerLine:
.8a04	a0 02		ldy #$02			ldy 	#2 							; start of program
.8a06					_CRIncMainLoop:
.8a06	0e 93 04	asl $0493			asl 	breakCheck 					; clears 1 time in 8
.8a09	d0 05		bne $8a10			bne 	_CRNoBreakCheck
.8a0b	20 53 aa	jsr $aa53			jsr 	EXTBreakCheck 				; break check
.8a0e	f0 4a		beq $8a5a			beq 	_CRBreak
.8a10					_CRNoBreakCheck:
.8a10	c8		iny				iny
.8a11					_CRMainLoop:
.8a11	9c 90 04	stz $0490			stz 	stringInitialised 			; clear the temporary string initialised flag.
.8a14	b1 30		lda ($30),y			lda 	(codePtr),y
.8a16	10 10		bpl $8a28			bpl 	_CRNotKeyword
.8a18	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1 			; if after unary, legitimate command
.8a1a	b0 04		bcs $8a20			bcs 	_CRIsKeyword
.8a1c	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if unary, syntax error.
.8a1e	b0 34		bcs $8a54			bcs		_CRSyntaxError
.8a20					_CRIsKeyword:
.8a20	c8		iny				iny 								; consume command
.8a21	0a		asl a				asl 	a 							; double losing the MSB which is '1' as tokens are $80-$FF
.8a22	aa		tax				tax 								; put in X for vector jump
.8a23	20 57 8a	jsr $8a57			jsr 	_CRCallVector0 				; call the vector - effectively jsr (vectortable,X)
.8a26	80 e9		bra $8a11			bra 	_CRMainLoop 				; and loop round
.8a28					_CRNotKeyword:
.8a28	c9 3a		cmp #$3a			cmp 	#KWD_COLON 					; if a :, consume it and go round.
.8a2a	f0 da		beq $8a06			beq 	_CRIncMainLoop
.8a2c	c9 40		cmp #$40			cmp 	#$40 						; variable/call reference
.8a2e	90 05		bcc $8a35			bcc 	_CRNotVariable
.8a30					_CRGoLet:
.8a30	20 90 86	jsr $8690			jsr 	LetCommand
.8a33	80 dc		bra $8a11			bra 	_CRMainLoop
.8a35					_CRNotVariable:
.8a35	c9 10		cmp #$10			cmp 	#KWD_AT 					; handle @
.8a37	f0 f7		beq $8a30			beq 	_CRGoLet
.8a39	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; handle ? !
.8a3b	f0 f3		beq $8a30			beq 	_CRGoLet
.8a3d	c9 21		cmp #$21			cmp 	#KWD_PLING
.8a3f	f0 ef		beq $8a30			beq 	_CRGoLet
.8a41	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; handle ' (comment)
.8a43	f0 09		beq $8a4e			beq 	_CRGoRem
.8a45	c9 2e		cmp #$2e			cmp 	#KWD_PERIOD 				; handle . (assembler label)
.8a47	d0 0b		bne $8a54			bne 	_CRSyntaxError
.8a49	20 11 82	jsr $8211			jsr 	LabelHere
.8a4c	80 c3		bra $8a11			bra 	_CRMainLoop
.8a4e					_CRGoRem:
.8a4e	c8		iny				iny
.8a4f	20 91 89	jsr $8991			jsr 	RemCommand
.8a52	80 bd		bra $8a11			bra 	_CRMainLoop
.8a54					_CRSyntaxError:
.8a54	4c a2 9f	jmp $9fa2			jmp 	SyntaxError
.8a57					_CRCallVector0:
.8a57	7c 02 8b	jmp ($8b02,x)			jmp 	(VectorSet0,x)
.8a5a					_CRBreak:
.8a5a	a9 01		lda #$01		lda	#1
.8a5c	4c 55 8d	jmp $8d55		jmp	ErrorHandler
.8a5f					CRNoProgram:
.8a5f	4c 16 85	jmp $8516			jmp 	EndCommand
.8a62					EOLCommand:
.8a62	18		clc				clc
.8a63	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.8a65	65 30		adc $30				adc 	codePtr
.8a67	85 30		sta $30				sta 	codePtr
.8a69	90 02		bcc $8a6d			bcc 	_CREExit
.8a6b	e6 31		inc $31				inc 	codePtr+1
.8a6d					_CREExit:
.8a6d	80 8e		bra $89fd			bra 	RunNewLine
.8a6f					Shift1Command:
.8a6f	b1 30		lda ($30),y			lda 	(codePtr),y
.8a71	c8		iny				iny
.8a72	0a		asl a				asl 	a
.8a73	aa		tax				tax
.8a74	7c 9e 8b	jmp ($8b9e,x)			jmp 	(VectorSet1,x)
.8a77					Shift2Command:
.8a77	b1 30		lda ($30),y			lda 	(codePtr),y
.8a79	c8		iny				iny
.8a7a	0a		asl a				asl 	a
.8a7b	aa		tax				tax
.8a7c	7c b8 8b	jmp ($8bb8,x)			jmp 	(VectorSet2,x)
.8a7f					Unused1:
.8a7f					Unused2:
.8a7f					Unused3:
.8a7f					Unused4:
.8a7f	4c a2 9f	jmp $9fa2			jmp 	SyntaxError
>8a82							.align 2

;******  Processing file: ./common/commands/../generated/vectors.dat

.8a82					VectorSetPunc:
>8a82	42 90					.word	ShiftLeft                        ; $00 <<
>8a84	f9 8d					.word	BinaryCompareLessEqual           ; $01 <=
>8a86	ef 8d					.word	BinaryCompareNotEqual            ; $02 <>
>8a88	a2 9f					.word	SyntaxError                      ; $03 !!3
>8a8a	a2 9f					.word	SyntaxError                      ; $04 ><
>8a8c	03 8e					.word	BinaryCompareGreaterEqual        ; $05 >=
>8a8e	45 90					.word	ShiftRight                       ; $06 >>
>8a90	a2 9f					.word	SyntaxError                      ; $07 !!7
>8a92	a2 9f					.word	SyntaxError                      ; $08 !!8
>8a94	a2 9f					.word	SyntaxError                      ; $09 !!9
>8a96	a2 9f					.word	SyntaxError                      ; $0a !!10
>8a98	a2 9f					.word	SyntaxError                      ; $0b !!11
>8a9a	a2 9f					.word	SyntaxError                      ; $0c !!12
>8a9c	a2 9f					.word	SyntaxError                      ; $0d !!13
>8a9e	a2 9f					.word	SyntaxError                      ; $0e !!14
>8aa0	a2 9f					.word	SyntaxError                      ; $0f !!15
>8aa2	a2 9f					.word	SyntaxError                      ; $10 @
>8aa4	a2 9f					.word	SyntaxError                      ; $11 !!17
>8aa6	a2 9f					.word	SyntaxError                      ; $12 !!18
>8aa8	a2 9f					.word	SyntaxError                      ; $13 [
>8aaa	c6 8e					.word	IntegerDivide                    ; $14 \
>8aac	a2 9f					.word	SyntaxError                      ; $15 ]
>8aae	d3 91					.word	EorInteger                       ; $16 ^
>8ab0	a2 9f					.word	SyntaxError                      ; $17 _
>8ab2	a2 9f					.word	SyntaxError                      ; $18 `
>8ab4	a2 9f					.word	SyntaxError                      ; $19 !!25
>8ab6	a2 9f					.word	SyntaxError                      ; $1a !!26
>8ab8	a2 9f					.word	SyntaxError                      ; $1b {
>8aba	8d 91					.word	OraInteger                       ; $1c |
>8abc	a2 9f					.word	SyntaxError                      ; $1d }
>8abe	a2 9f					.word	SyntaxError                      ; $1e ~
>8ac0	a2 9f					.word	SyntaxError                      ; $1f [7m<7F>[m
>8ac2	a2 9f					.word	SyntaxError                      ; $20
>8ac4	19 92					.word	WordIndirect                     ; $21 !
>8ac6	a2 9f					.word	SyntaxError                      ; $22 "
>8ac8	a2 9f					.word	SyntaxError                      ; $23 #
>8aca	a2 9f					.word	SyntaxError                      ; $24 $
>8acc	13 8f					.word	IntegerModulus                   ; $25 %
>8ace	47 91					.word	AndInteger                       ; $26 &
>8ad0	a2 9f					.word	SyntaxError                      ; $27 '
>8ad2	a2 9f					.word	SyntaxError                      ; $28 (
>8ad4	a2 9f					.word	SyntaxError                      ; $29 )
>8ad6	88 8f					.word	MulInteger                       ; $2a *
>8ad8	d9 90					.word	AddInteger                       ; $2b +
>8ada	a2 9f					.word	SyntaxError                      ; $2c ,
>8adc	1c 91					.word	SubInteger                       ; $2d -
>8ade	a2 9f					.word	SyntaxError                      ; $2e .
>8ae0	04 94					.word	FDivideCommand                   ; $2f /
>8ae2	a2 9f					.word	SyntaxError                      ; $30 0
>8ae4	a2 9f					.word	SyntaxError                      ; $31 1
>8ae6	a2 9f					.word	SyntaxError                      ; $32 2
>8ae8	a2 9f					.word	SyntaxError                      ; $33 3
>8aea	a2 9f					.word	SyntaxError                      ; $34 4
>8aec	a2 9f					.word	SyntaxError                      ; $35 5
>8aee	a2 9f					.word	SyntaxError                      ; $36 6
>8af0	a2 9f					.word	SyntaxError                      ; $37 7
>8af2	a2 9f					.word	SyntaxError                      ; $38 8
>8af4	a2 9f					.word	SyntaxError                      ; $39 9
>8af6	a2 9f					.word	SyntaxError                      ; $3a :
>8af8	a2 9f					.word	SyntaxError                      ; $3b ;
>8afa	db 8d					.word	BinaryCompareLess                ; $3c <
>8afc	d1 8d					.word	BinaryCompareEqual               ; $3d =
>8afe	e5 8d					.word	BinaryCompareGreater             ; $3e >
>8b00	40 92					.word	ByteIndirect                     ; $3f ?
.8b02					VectorSet0:
>8b02	62 8a					.word	EOLCommand                       ; $80 !0:EOF
>8b04	6f 8a					.word	Shift1Command                    ; $81 !1:SH1
>8b06	77 8a					.word	Shift2Command                    ; $82 !2:SH2
>8b08	74 99					.word	AbsUnary                         ; $83 ABS(
>8b0a	84 99					.word	AllocUnary                       ; $84 ALLOC(
>8b0c	f4 99					.word	AscUnary                         ; $85 ASC(
>8b0e	bf 9b					.word	ChrUnary                         ; $86 CHR$(
>8b10	24 a5					.word	UnaryEvent                       ; $87 EVENT(
>8b12	cd 8d					.word	UnaryFalse                       ; $88 FALSE
>8b14	01 9a					.word	FracUnary                        ; $89 FRAC(
>8b16	ba a4					.word	UnaryHit                         ; $8a HIT(
>8b18	17 9a					.word	IntUnary                         ; $8b INT(
>8b1a	7e 9b					.word	IsValUnary                       ; $8c ISVAL(
>8b1c	b4 a5					.word	UnaryJoyB                        ; $8d JOYB(
>8b1e	8d a5					.word	UnaryJoyX                        ; $8e JOYX(
>8b20	90 a5					.word	UnaryJoyY                        ; $8f JOYY(
>8b22	99 9c					.word	Unary_Left                       ; $90 LEFT$(
>8b24	29 9a					.word	LenUnary                         ; $91 LEN(
>8b26	47 9a					.word	Unary_Max                        ; $92 MAX(
>8b28	c3 9c					.word	Unary_Mid                        ; $93 MID$(
>8b2a	43 9a					.word	Unary_Min                        ; $94 MIN(
>8b2c	9e 9a					.word	Unary_Not                        ; $95 NOT(
>8b2e	a2 9f					.word	SyntaxError                      ; $96 PLAYING(
>8b30	b4 9a					.word	Unary_Random                     ; $97 RANDOM(
>8b32	a9 9c					.word	Unary_Right                      ; $98 RIGHT$(
>8b34	d3 9a					.word	Unary_Rnd                        ; $99 RND(
>8b36	54 9b					.word	SgnUnary                         ; $9a SGN(
>8b38	d1 9b					.word	SpcUnary                         ; $9b SPC(
>8b3a	ec 9b					.word	Unary_Str                        ; $9c STR$(
>8b3c	c8 a5					.word	UnaryTimer                       ; $9d TIMER(
>8b3e	c1 8d					.word	UnaryTrue                        ; $9e TRUE
>8b40	74 9b					.word	ValUnary                         ; $9f VAL(
>8b42	19 85					.word	ForCommand                       ; $a0 FOR
>8b44	66 86					.word	IfCommand                        ; $a1 IF
>8b46	7f 8a					.word	Unused1                          ; $a2 PROC
>8b48	9e 89					.word	Command_REPEAT                   ; $a3 REPEAT
>8b4a	0d 8d					.word	Command_WHILE                    ; $a4 WHILE
>8b4c	8f 86					.word	EndIf                            ; $a5 ENDIF
>8b4e	2a 89					.word	Command_ENDPROC                  ; $a6 ENDPROC
>8b50	d3 85					.word	NextCommand                      ; $a7 NEXT
>8b52	7f 8a					.word	Unused4                          ; $a8 THEN
>8b54	a7 89					.word	Command_UNTIL                    ; $a9 UNTIL
>8b56	2e 8d					.word	Command_WEND                     ; $aa WEND
>8b58	a2 9f					.word	SyntaxError                      ; $ab BY
>8b5a	b7 83					.word	CallCommand                      ; $ac CALL
>8b5c	5c a2					.word	CircleCommand                    ; $ad CIRCLE
>8b5e	f1 83					.word	ClearCommand                     ; $ae CLEAR
>8b60	49 84					.word	ClearScreen                      ; $af CLS
>8b62	a2 9f					.word	SyntaxError                      ; $b0 COLOR
>8b64	a2 9f					.word	SyntaxError                      ; $b1 COLOUR
>8b66	51 84					.word	Command_Data                     ; $b2 DATA
>8b68	59 84					.word	DimCommand                       ; $b3 DIM
>8b6a	7f 8a					.word	Unused3                          ; $b4 DOWNTO
>8b6c	88 86					.word	ElseCode                         ; $b5 ELSE
>8b6e	a2 9f					.word	SyntaxError                      ; $b6 FROM
>8b70	88 a4					.word	GfxCommand                       ; $b7 GFX
>8b72	2c 86					.word	Command_GOSUB                    ; $b8 GOSUB
>8b74	4a 86					.word	GotoCommand                      ; $b9 GOTO
>8b76	a2 9f					.word	SyntaxError                      ; $ba HERE
>8b78	86 a2					.word	ImageCommand                     ; $bb IMAGE
>8b7a	90 86					.word	LetCommand                       ; $bc LET
>8b7c	db a2					.word	LineCommand                      ; $bd LINE
>8b7e	86 87					.word	Command_LOCAL                    ; $be LOCAL
>8b80	a2 9f					.word	SyntaxError                      ; $bf OFF
>8b82	a2 9f					.word	SyntaxError                      ; $c0 ON
>8b84	a2 9f					.word	SyntaxError                      ; $c1 OUTLINE
>8b86	e0 a4					.word	PaletteCommand                   ; $c2 PALETTE
>8b88	d4 a2					.word	PlotCommand                      ; $c3 PLOT
>8b8a	5d 88					.word	Command_Print                    ; $c4 PRINT
>8b8c	38 89					.word	Command_Read                     ; $c5 READ
>8b8e	58 a2					.word	RectangleCommand                 ; $c6 RECT
>8b90	91 89					.word	RemCommand                       ; $c7 REM
>8b92	3c 86					.word	Command_RETURN                   ; $c8 RETURN
>8b94	a2 9f					.word	SyntaxError                      ; $c9 SOLID
>8b96	e4 a5					.word	SoundCommand                     ; $ca SOUND
>8b98	67 a2					.word	SpriteCommand                    ; $cb SPRITE
>8b9a	a3 a2					.word	TextCommand                      ; $cc TEXT
>8b9c	7f 8a					.word	Unused2                          ; $cd TO
.8b9e					VectorSet1:
>8b9e	a2 9f					.word	SyntaxError                      ; $80 !0:EOF
>8ba0	a2 9f					.word	SyntaxError                      ; $81 !1:SH1
>8ba2	a2 9f					.word	SyntaxError                      ; $82 !2:SH2
>8ba4	88 83					.word	AssembleCommand                  ; $83 ASSEMBLE
>8ba6	a7 83					.word	AssertCommand                    ; $84 ASSERT
>8ba8	28 a4					.word	BitmapCtrl                       ; $85 BITMAP
>8baa	16 85					.word	EndCommand                       ; $86 END
>8bac	e5 86					.word	Command_List                     ; $87 LIST
>8bae	4d 88					.word	NewCommand                       ; $88 NEW
>8bb0	c0 89					.word	Command_Restore                  ; $89 RESTORE
>8bb2	f2 89					.word	CommandRUN                       ; $8a RUN
>8bb4	6d a4					.word	SpritesCtrl                      ; $8b SPRITES
>8bb6	40 8c					.word	StopCommand                      ; $8c STOP
.8bb8					VectorSet2:
>8bb8	a2 9f					.word	SyntaxError                      ; $80 !0:EOF
>8bba	a2 9f					.word	SyntaxError                      ; $81 !1:SH1
>8bbc	a2 9f					.word	SyntaxError                      ; $82 !2:SH2
>8bbe	61 9e					.word	Assemble_adc                     ; $83 ADC
>8bc0	59 9e					.word	Assemble_and                     ; $84 AND
>8bc2	75 9e					.word	Assemble_asl                     ; $85 ASL
>8bc4	df 9e					.word	Assemble_bcc                     ; $86 BCC
>8bc6	e3 9e					.word	Assemble_bcs                     ; $87 BCS
>8bc8	eb 9e					.word	Assemble_beq                     ; $88 BEQ
>8bca	a2 9e					.word	Assemble_bit                     ; $89 BIT
>8bcc	d3 9e					.word	Assemble_bmi                     ; $8a BMI
>8bce	e7 9e					.word	Assemble_bne                     ; $8b BNE
>8bd0	cf 9e					.word	Assemble_bpl                     ; $8c BPL
>8bd2	ef 9e					.word	Assemble_bra                     ; $8d BRA
>8bd4	f3 9e					.word	Assemble_brk                     ; $8e BRK
>8bd6	d7 9e					.word	Assemble_bvc                     ; $8f BVC
>8bd8	db 9e					.word	Assemble_bvs                     ; $90 BVS
>8bda	fb 9e					.word	Assemble_clc                     ; $91 CLC
>8bdc	4f 9f					.word	Assemble_cld                     ; $92 CLD
>8bde	0f 9f					.word	Assemble_cli                     ; $93 CLI
>8be0	3f 9f					.word	Assemble_clv                     ; $94 CLV
>8be2	6d 9e					.word	Assemble_cmp                     ; $95 CMP
>8be4	b6 9e					.word	Assemble_cpx                     ; $96 CPX
>8be6	b1 9e					.word	Assemble_cpy                     ; $97 CPY
>8be8	93 9e					.word	Assemble_dec                     ; $98 DEC
>8bea	4b 9f					.word	Assemble_dex                     ; $99 DEX
>8bec	27 9f					.word	Assemble_dey                     ; $9a DEY
>8bee	5d 9e					.word	Assemble_eor                     ; $9b EOR
>8bf0	98 9e					.word	Assemble_inc                     ; $9c INC
>8bf2	5b 9f					.word	Assemble_inx                     ; $9d INX
>8bf4	47 9f					.word	Assemble_iny                     ; $9e INY
>8bf6	ca 9e					.word	Assemble_jmp                     ; $9f JMP
>8bf8	c5 9e					.word	Assemble_jsr                     ; $a0 JSR
>8bfa	69 9e					.word	Assemble_lda                     ; $a1 LDA
>8bfc	8e 9e					.word	Assemble_ldx                     ; $a2 LDX
>8bfe	ac 9e					.word	Assemble_ldy                     ; $a3 LDY
>8c00	7f 9e					.word	Assemble_lsr                     ; $a4 LSR
>8c02	5f 9f					.word	Assemble_nop                     ; $a5 NOP
>8c04	55 9e					.word	Assemble_ora                     ; $a6 ORA
>8c06	0b 9f					.word	Assemble_pha                     ; $a7 PHA
>8c08	f7 9e					.word	Assemble_php                     ; $a8 PHP
>8c0a	53 9f					.word	Assemble_phx                     ; $a9 PHX
>8c0c	13 9f					.word	Assemble_phy                     ; $aa PHY
>8c0e	1b 9f					.word	Assemble_pla                     ; $ab PLA
>8c10	ff 9e					.word	Assemble_plp                     ; $ac PLP
>8c12	67 9f					.word	Assemble_plx                     ; $ad PLX
>8c14	23 9f					.word	Assemble_ply                     ; $ae PLY
>8c16	7a 9e					.word	Assemble_rol                     ; $af ROL
>8c18	84 9e					.word	Assemble_ror                     ; $b0 ROR
>8c1a	07 9f					.word	Assemble_rti                     ; $b1 RTI
>8c1c	17 9f					.word	Assemble_rts                     ; $b2 RTS
>8c1e	71 9e					.word	Assemble_sbc                     ; $b3 SBC
>8c20	03 9f					.word	Assemble_sec                     ; $b4 SEC
>8c22	63 9f					.word	Assemble_sed                     ; $b5 SED
>8c24	1f 9f					.word	Assemble_sei                     ; $b6 SEI
>8c26	65 9e					.word	Assemble_sta                     ; $b7 STA
>8c28	57 9f					.word	Assemble_stp                     ; $b8 STP
>8c2a	89 9e					.word	Assemble_stx                     ; $b9 STX
>8c2c	a7 9e					.word	Assemble_sty                     ; $ba STY
>8c2e	9d 9e					.word	Assemble_stz                     ; $bb STZ
>8c30	3b 9f					.word	Assemble_tax                     ; $bc TAX
>8c32	37 9f					.word	Assemble_tay                     ; $bd TAY
>8c34	c0 9e					.word	Assemble_trb                     ; $be TRB
>8c36	bb 9e					.word	Assemble_tsb                     ; $bf TSB
>8c38	43 9f					.word	Assemble_tsx                     ; $c0 TSX
>8c3a	2b 9f					.word	Assemble_txa                     ; $c1 TXA
>8c3c	33 9f					.word	Assemble_txs                     ; $c2 TXS
>8c3e	2f 9f					.word	Assemble_tya                     ; $c3 TYA

;******  Return to file: ./common/commands/run.asm


;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/stop.asm

.8c40					StopCommand:
.8c40	a9 08		lda #$08		lda	#8
.8c42	4c 55 8d	jmp $8d55		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/procscan.asm

.8c45					ProcedureScan:
.8c45	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8c47	85 30		sta $30				sta 	codePtr
.8c49	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8c4b	85 31		sta $31				sta 	codePtr+1
.8c4d					_PSLoop:
.8c4d	b2 30		lda ($30)			lda 	(codePtr)
.8c4f	f0 42		beq $8c93			beq 	_PSExit
.8c51	a0 03		ldy #$03			ldy 	#3 							; is it PROC ?
.8c53	b1 30		lda ($30),y			lda 	(codePtr),y
.8c55	c9 a2		cmp #$a2			cmp 	#KWD_PROC
.8c57	d0 2d		bne $8c86			bne 	_PSNext
.8c59	c8		iny				iny 								; get the address of the record to zTemp0 and
.8c5a	b1 30		lda ($30),y			lda 	(codePtr),y
.8c5c	29 c0		and #$c0			and 	#$C0
.8c5e	c9 40		cmp #$40			cmp 	#$40
.8c60	d0 32		bne $8c94			bne 	_PSSyntax
.8c62	b1 30		lda ($30),y			lda 	(codePtr),y
.8c64	18		clc				clc
.8c65	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8c67	85 37		sta $37				sta 	zTemp0+1
.8c69	c8		iny				iny 								; LSB
.8c6a	b1 30		lda ($30),y			lda 	(codePtr),y
.8c6c	85 36		sta $36				sta 	zTemp0
.8c6e	c8		iny				iny 								; character after variable call.
.8c6f	98		tya				tya 								; save Y offset at +7
.8c70	a0 07		ldy #$07			ldy 	#7
.8c72	91 36		sta ($36),y			sta 	(zTemp0),y
.8c74	a9 18		lda #$18			lda 	#NSTProcedure 				; mark it as procedure
.8c76	a0 02		ldy #$02			ldy 	#2
.8c78	91 36		sta ($36),y			sta 	(zTemp0),y
.8c7a	a2 00		ldx #$00			ldx 	#0 							; copy code-Ptr in
.8c7c					_PSCopy:
.8c7c	b5 30		lda $30,x			lda 	safePtr,x
.8c7e	c8		iny				iny
.8c7f	91 36		sta ($36),y			sta 	(zTemp0),y
.8c81	e8		inx				inx
.8c82	e0 04		cpx #$04			cpx 	#4
.8c84	d0 f6		bne $8c7c			bne 	_PSCopy
.8c86					_PSNext:
.8c86	18		clc				clc
.8c87	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.8c89	65 30		adc $30				adc 	codePtr
.8c8b	85 30		sta $30				sta 	codePtr
.8c8d	90 02		bcc $8c91			bcc 	_CREExit
.8c8f	e6 31		inc $31				inc 	codePtr+1
.8c91					_CREExit:
.8c91	80 ba		bra $8c4d			bra 	_PSLoop
.8c93					_PSExit:
.8c93	60		rts				rts
.8c94					_PSSyntax:
.8c94	4c a2 9f	jmp $9fa2			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/scanforward.asm

.8c97					ScanForward:
.8c97	64 38		stz $38				stz 	zTemp1 						; this is the structure count - goes up with WHILE/FOR
.8c99	86 37		stx $37				stx 	zTemp0+1
.8c9b	85 36		sta $36				sta 	zTemp0 						; save XA as the two possible matches.
.8c9d					_ScanLoop:
.8c9d	b1 30		lda ($30),y			lda 	(codePtr),y
.8c9f	c8		iny				iny
.8ca0	a6 38		ldx $38				ldx 	zTemp1 						; if the count is > 0 cannot match as in substructure
.8ca2	d0 0e		bne $8cb2			bne 	_ScanGoNext
.8ca4	c5 36		cmp $36				cmp 	zTemp0 						; see if either matches
.8ca6	f0 04		beq $8cac			beq 	_ScanMatch
.8ca8	c5 37		cmp $37				cmp 	zTemp0+1
.8caa	d0 06		bne $8cb2			bne 	_ScanGoNext
.8cac					_ScanMatch:
.8cac	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if asked for EOL, backtrack.
.8cae	d0 01		bne $8cb1			bne 	_ScanNotEndEOL
.8cb0	88		dey				dey
.8cb1					_ScanNotEndEOL:
.8cb1	60		rts				rts
.8cb2					_ScanGoNext:
.8cb2	20 b7 8c	jsr $8cb7			jsr  	ScanForwardOne
.8cb5	80 e6		bra $8c9d			bra 	_ScanLoop
.8cb7					ScanForwardOne:
.8cb7	c9 40		cmp #$40			cmp 	#$40 						; if 00-3F, punctuation characters, loop back
.8cb9	90 3e		bcc $8cf9			bcc 	_SFWExit
.8cbb	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if 40-82, skip one extra.
.8cbd	90 18		bcc $8cd7			bcc 	_ScanSkipOne
.8cbf	c9 fc		cmp #$fc			cmp 	#$FC 						; FC-FF are data skips
.8cc1	b0 2f		bcs $8cf2			bcs 	_ScanSkipData
.8cc3	c9 a0		cmp #$a0			cmp 	#KWC_FIRST_STRUCTURE 		; structure keyword ?
.8cc5	90 32		bcc $8cf9			bcc 	_SFWExit 					; if not, ordinary keywords.
.8cc7	c9 ab		cmp #$ab			cmp 	#KWC_LAST_STRUCTURE+1
.8cc9	b0 2e		bcs $8cf9			bcs 	_SFWExit
.8ccb	c6 38		dec $38				dec 	zTemp1 						; decrement the sructure count
.8ccd	c9 a5		cmp #$a5			cmp 	#KWC_FIRST_STRUCTURE_DEC 	; back if it is a dec structure (e.g. WEND/NEXT)
.8ccf	b0 28		bcs $8cf9			bcs 	_SFWExit
.8cd1	e6 38		inc $38				inc 	zTemp1 						; so it's an increment structure
.8cd3	e6 38		inc $38				inc 	zTemp1 						; twice to undo the dec
.8cd5	80 22		bra $8cf9			bra 	_SFWExit
.8cd7					_ScanSkipOne:
.8cd7	c8		iny				iny 								; consume the extra one.
.8cd8	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if not EOL loop back
.8cda	d0 1d		bne $8cf9			bne 	_SFWExit
.8cdc	18		clc				clc
.8cdd	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.8cdf	65 30		adc $30				adc 	codePtr
.8ce1	85 30		sta $30				sta 	codePtr
.8ce3	90 02		bcc $8ce7			bcc 	_CREExit
.8ce5	e6 31		inc $31				inc 	codePtr+1
.8ce7					_CREExit:
.8ce7	a0 03		ldy #$03			ldy 	#3 							; scan start position.
.8ce9	b2 30		lda ($30)			lda 	(codePtr)
.8ceb	d0 0c		bne $8cf9			bne 	_SFWExit 					; if not zero, more to scan
.8ced	a9 13		lda #$13		lda	#19
.8cef	4c 55 8d	jmp $8d55		jmp	ErrorHandler
.8cf2					_ScanSkipData:
.8cf2	88		dey				dey 								; point at data token
.8cf3	c8		iny				iny
.8cf4	98		tya				tya
.8cf5	38		sec				sec
.8cf6	71 30		adc ($30),y			adc 	(codePtr),y
.8cf8	a8		tay				tay
.8cf9					_SFWExit:
.8cf9	60		rts				rts
.8cfa					ScanGetCurrentLineStep:
.8cfa	64 38		stz $38				stz 	zTemp1
.8cfc	a0 03		ldy #$03			ldy 	#3
.8cfe					_SGCLSLoop:
.8cfe	b1 30		lda ($30),y			lda 	(codePtr),y
.8d00	c8		iny				iny
.8d01	c9 80		cmp #$80			cmp 	#KWC_EOL	 				; if EOL exit
.8d03	f0 05		beq $8d0a			beq 	_SGCLSExit
.8d05	20 b7 8c	jsr $8cb7			jsr 	ScanForwardOne
.8d08	80 f4		bra $8cfe			bra 	_SGCLSLoop
.8d0a					_SGCLSExit:
.8d0a	a5 38		lda $38				lda 	zTemp1
.8d0c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/while.asm

.8d0d					Command_WHILE:
.8d0d	5a		phy				phy 								; save position of the test
.8d0e	a2 00		ldx #$00			ldx 	#0
.8d10	20 41 9d	jsr $9d41			jsr 	EvaluateNumber 				; work out the number
.8d13	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; check if zero
.8d16	f0 0e		beq $8d26			beq 	_WHExitLoop 				; if so exit the loop
.8d18	98		tya				tya 								; position *after* test.
.8d19	7a		ply				ply 								; restore position before test, at WHILE
.8d1a	88		dey				dey
.8d1b	48		pha				pha 								; push after test on the stack
.8d1c	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; allocate 6 bytes on the return stack.
.8d1e	20 71 a6	jsr $a671			jsr 	StackOpen
.8d21	20 b5 a6	jsr $a6b5			jsr 	STKSaveCodePosition 		; save loop position - where the test value is.
.8d24	7a		ply				ply 								; restore the position *after* the test
.8d25	60		rts				rts
.8d26					_WHExitLoop:
.8d26	68		pla				pla 								; throw post loop position
.8d27	a9 aa		lda #$aa			lda 	#KWD_WEND 					; scan forward past WEND
.8d29	aa		tax				tax
.8d2a	20 97 8c	jsr $8c97			jsr 	ScanForward
.8d2d	60		rts				rts
.8d2e					Command_WEND:
.8d2e	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; check WHILE is TOS
.8d30	a2 10		ldx #$10			ldx 	#ERRID_WHILE 				; this error
.8d32	20 9d a6	jsr $a69d			jsr 	StackCheckFrame
.8d35	20 c6 a6	jsr $a6c6			jsr 	STKLoadCodePosition 		; loop back
.8d38	20 8f a6	jsr $a68f			jsr 	StackClose		 			; erase the frame
.8d3b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/charcheck.asm

.8d3c					CheckRightBracket:
.8d3c	b1 30		lda ($30),y			lda 	(codePtr),y
.8d3e	c8		iny				iny
.8d3f	c9 29		cmp #$29			cmp 	#KWD_RPAREN 						; exit if matches
.8d41	d0 0f		bne $8d52			bne 	CNAFail
.8d43	60		rts				rts
.8d44					CheckComma:
.8d44	b1 30		lda ($30),y			lda 	(codePtr),y
.8d46	c8		iny				iny
.8d47	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 						; exit if matches
.8d49	d0 07		bne $8d52			bne 	CNAFail
.8d4b	60		rts				rts
.8d4c					CheckNextA:
.8d4c	d1 30		cmp ($30),y			cmp 	(codePtr),y
.8d4e	d0 02		bne $8d52			bne 	CNAFail
.8d50	c8		iny				iny 								; skip character
.8d51	60		rts				rts 								; and exit
.8d52					CNAFail:
.8d52	4c a2 9f	jmp $9fa2			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/errors.asm

.8d55					ErrorHandler:
.8d55	a8		tay				tay 								; find the error text
.8d56	f0 49		beq $8da1			beq 	_EHEnd
.8d58	a2 00		ldx #$00			ldx 	#0
.8d5a	a9 bb		lda #$bb			lda 	#((ErrorText) & $FF)
.8d5c	85 36		sta $36				sta 	0+zTemp0
.8d5e	a9 9f		lda #$9f			lda 	#((ErrorText) >> 8)
.8d60	85 37		sta $37				sta 	1+zTemp0
.8d62					_EHFind:
.8d62	88		dey				dey 								; found the error text ?
.8d63	f0 0e		beq $8d73			beq 	_EHFound
.8d65					_EHFindZero:
.8d65	b2 36		lda ($36)			lda 	(zTemp0) 					; find the next error
.8d67	e6 36		inc $36				inc 	zTemp0
.8d69	d0 02		bne $8d6d			bne 	_EHFNoCarry
.8d6b	e6 37		inc $37				inc 	zTemp0+1
.8d6d					_EHFNoCarry:
.8d6d	c9 00		cmp #$00			cmp 	#0
.8d6f	d0 f4		bne $8d65			bne 	_EHFindZero
.8d71	80 ef		bra $8d62			bra 	_EHFind
.8d73					_EHFound:
.8d73	a5 36		lda $36				lda 	zTemp0 						; print message
.8d75	a6 37		ldx $37				ldx 	zTemp0+1
.8d77	20 ae 8d	jsr $8dae			jsr 	PrintStringXA
.8d7a	a0 01		ldy #$01			ldy 	#1 							; if line number zero don't print i
.8d7c	b1 30		lda ($30),y			lda 	(codePtr),y
.8d7e	d0 05		bne $8d85			bne 	_EHAtMsg
.8d80	c8		iny				iny
.8d81	b1 30		lda ($30),y			lda 	(codePtr),y
.8d83	f0 17		beq $8d9c			beq 	_EHCREnd
.8d85					_EHAtMsg:
.8d85	a2 8d		ldx #$8d			ldx 	#_AtMsg >> 8 				; print " at "
.8d87	a9 a4		lda #$a4			lda 	#_AtMsg & $FF
.8d89	20 ae 8d	jsr $8dae			jsr 	PrintStringXA
.8d8c	a0 01		ldy #$01			ldy 	#1 							; line number into XA
.8d8e	b1 30		lda ($30),y			lda 	(codePtr),y
.8d90	48		pha				pha
.8d91	c8		iny				iny
.8d92	b1 30		lda ($30),y			lda 	(codePtr),y
.8d94	aa		tax				tax
.8d95	68		pla				pla
.8d96	20 67 92	jsr $9267			jsr 	LCLConvertInt16 				; convert XA to string
.8d99	20 ae 8d	jsr $8dae			jsr 	PrintStringXA 				; and print it.
.8d9c					_EHCREnd:
.8d9c	a9 0d		lda #$0d			lda 	#13 						; new line
.8d9e	20 b1 a7	jsr $a7b1			jsr 	EXTPrintCharacter
.8da1					_EHEnd:
.8da1	4c 58 83	jmp $8358			jmp 	WarmStart
>8da4	20 61 74 20 6c 69 6e 65		_AtMsg:	.text 	" at line ",0
>8dac	20 00
.8dae					PrintStringXA:
.8dae	5a		phy				phy
.8daf	86 37		stx $37				stx 	zTemp0+1
.8db1	85 36		sta $36				sta 	zTemp0
.8db3	a0 00		ldy #$00			ldy 	#0
.8db5					_PSXALoop:
.8db5	b1 36		lda ($36),y			lda 	(zTemp0),y
.8db7	f0 06		beq $8dbf			beq 	_PSXAExit
.8db9	20 b1 a7	jsr $a7b1			jsr 	EXTPrintCharacter
.8dbc	c8		iny				iny
.8dbd	80 f6		bra $8db5			bra 	_PSXALoop
.8dbf					_PSXAExit:
.8dbf	7a		ply				ply
.8dc0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/compare.asm

.8dc1					UnaryTrue:
.8dc1	fa		plx				plx
.8dc2					ReturnTrue:
.8dc2	a9 01		lda #$01			lda 	#1  						; set to 1
.8dc4	20 1a 9e	jsr $9e1a			jsr 	NSMSetByte
.8dc7	a9 80		lda #$80			lda 	#$80 						; set sign flag, so it is -1
.8dc9	9d 00 04	sta $0400,x			sta 	NSStatus,x
.8dcc	60		rts				rts
.8dcd					UnaryFalse:
.8dcd	fa		plx				plx
.8dce					ReturnFalse:
.8dce	4c 18 9e	jmp $9e18			jmp 	NSMSetZero 					; set it all to zero
.8dd1					BinaryCompareEqual:
.8dd1	fa		plx				plx
.8dd2	20 0d 8e	jsr $8e0d			jsr 	CompareBaseCode
.8dd5	c9 00		cmp #$00			cmp 	#0
.8dd7	f0 e9		beq $8dc2			beq 	ReturnTrue
.8dd9	80 f3		bra $8dce			bra 	ReturnFalse
.8ddb					BinaryCompareLess:
.8ddb	fa		plx				plx
.8ddc	20 0d 8e	jsr $8e0d			jsr 	CompareBaseCode
.8ddf	c9 ff		cmp #$ff			cmp 	#$FF
.8de1	f0 df		beq $8dc2			beq 	ReturnTrue
.8de3	80 e9		bra $8dce			bra 	ReturnFalse
.8de5					BinaryCompareGreater:
.8de5	fa		plx				plx
.8de6	20 0d 8e	jsr $8e0d			jsr 	CompareBaseCode
.8de9	c9 01		cmp #$01			cmp 	#1
.8deb	f0 d5		beq $8dc2			beq 	ReturnTrue
.8ded	80 df		bra $8dce			bra 	ReturnFalse
.8def					BinaryCompareNotEqual:
.8def	fa		plx				plx
.8df0	20 0d 8e	jsr $8e0d			jsr 	CompareBaseCode
.8df3	c9 00		cmp #$00			cmp 	#0
.8df5	d0 cb		bne $8dc2			bne 	ReturnTrue
.8df7	80 d5		bra $8dce			bra 	ReturnFalse
.8df9					BinaryCompareLessEqual:
.8df9	fa		plx				plx
.8dfa	20 0d 8e	jsr $8e0d			jsr 	CompareBaseCode
.8dfd	c9 01		cmp #$01			cmp 	#1
.8dff	d0 c1		bne $8dc2			bne 	ReturnTrue
.8e01	80 cb		bra $8dce			bra 	ReturnFalse
.8e03					BinaryCompareGreaterEqual:
.8e03	fa		plx				plx
.8e04	20 0d 8e	jsr $8e0d			jsr 	CompareBaseCode
.8e07	c9 ff		cmp #$ff			cmp 	#$FF
.8e09	d0 b7		bne $8dc2			bne 	ReturnTrue
.8e0b	80 c1		bra $8dce			bra 	ReturnFalse
.8e0d					CompareBaseCode:
.8e0d	20 1d 96	jsr $961d			jsr 	DereferenceTopTwo 			; make both values if references.
.8e10	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if either is a string.
.8e13	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8e16	29 10		and #$10			and 	#NSTString
.8e18	d0 40		bne $8e5a			bne 	_CBCString
.8e1a	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check both are integers
.8e1d	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8e20	d0 3b		bne $8e5d			bne 	_CBCFloat
.8e22	bd 00 04	lda $0400,x			lda 	NSStatus,x
.8e25	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8e28	29 08		and #$08			and 	#NSTFloat
.8e2a	d0 31		bne $8e5d			bne 	_CBCFloat
.8e2c	20 60 8e	jsr $8e60			jsr 	CompareFixMinusZero
.8e2f	e8		inx				inx
.8e30	20 60 8e	jsr $8e60			jsr 	CompareFixMinusZero
.8e33	ca		dex				dex
.8e34	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; are the signs different ?
.8e37	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.8e3a	10 0b		bpl $8e47			bpl 	_CDCSameSign
.8e3c	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; if first one is -ve
.8e3f	30 16		bmi $8e57			bmi 	_CBCLess 					; return $FF
.8e41					_CBCGreater:
.8e41	a9 01		lda #$01			lda 	#1
.8e43	60		rts				rts
.8e44					_CBCEqual:
.8e44	a9 00		lda #$00			lda 	#0
.8e46	60		rts				rts
.8e47					_CDCSameSign:
.8e47	20 b3 90	jsr $90b3			jsr 	SubTopTwoStack 				; unsigned subtract
.8e4a	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; or the mantissa together
.8e4d	f0 f5		beq $8e44			beq 	_CBCEqual 					; -0 == 0
.8e4f	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; sign of the result. if +ve return $01 else return $FF
.8e52	5d 01 04	eor $0401,x			eor 	NSStatus+1,x 				; however if both were -ve this is inverted
.8e55	10 ea		bpl $8e41			bpl 	_CBCGreater
.8e57					_CBCLess:
.8e57	a9 ff		lda #$ff			lda 	#$FF
.8e59	60		rts				rts
.8e5a					_CBCString:
.8e5a	4c 09 90	jmp $9009			jmp 	CompareStrings
.8e5d					_CBCFloat:
.8e5d	4c ea 93	jmp $93ea			jmp 	CompareFloat
.8e60					CompareFixMinusZero:
.8e60	20 48 9e	jsr $9e48			jsr 	NSMIsZero
.8e63	d0 03		bne $8e68			bne 	_CFXMZNotZero
.8e65	9e 00 04	stz $0400,x			stz 	NSStatus,x
.8e68					_CFXMZNotZero:
.8e68	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/concat.asm

.8e69					StringConcat:
.8e69	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check both strings
.8e6c	3d 01 04	and $0401,x			and 	NSStatus+1,x
.8e6f	29 18		and #$18			and 	#NSBTypeMask
.8e71	c9 10		cmp #$10			cmp 	#NSTString
.8e73	d0 4e		bne $8ec3			bne		_SCType
.8e75	64 38		stz $38				stz 	zTemp1 						; counting total length
.8e77	e8		inx				inx
.8e78	20 96 8e	jsr $8e96			jsr 	_SCSetupZ0 					; setup for second
.8e7b	20 a1 8e	jsr $8ea1			jsr 	_SCLengthZ0 				; length for second
.8e7e	ca		dex				dex
.8e7f	20 96 8e	jsr $8e96			jsr 	_SCSetupZ0 					; setup for first
.8e82	20 a1 8e	jsr $8ea1			jsr 	_SCLengthZ0 				; length for first
.8e85	a5 38		lda $38				lda 	zTemp1 						; allocate memory
.8e87	20 64 a7	jsr $a764			jsr 	StringTempAllocate
.8e8a	20 b4 8e	jsr $8eb4			jsr 	_SCCopy 					; copy first out, using zTemp0 from above
.8e8d	e8		inx				inx
.8e8e	20 96 8e	jsr $8e96			jsr 	_SCSetupZ0 					; copy second out
.8e91	20 b4 8e	jsr $8eb4			jsr 	_SCCopy
.8e94	ca		dex				dex
.8e95	60		rts				rts
.8e96					_SCSetupZ0:
.8e96	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.8e99	85 36		sta $36				sta 	zTemp0
.8e9b	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.8e9e	85 37		sta $37				sta 	zTemp0+1
.8ea0	60		rts				rts
.8ea1					_SCLengthZ0:
.8ea1	5a		phy				phy
.8ea2	a0 00		ldy #$00			ldy 	#0
.8ea4					_SCLenLoop:
.8ea4	b1 36		lda ($36),y			lda 	(zTemp0),y
.8ea6	f0 0a		beq $8eb2			beq 	_SCLExit
.8ea8	c8		iny				iny
.8ea9	e6 38		inc $38				inc 	zTemp1
.8eab	10 f7		bpl $8ea4			bpl		_SCLenLoop
.8ead	a9 09		lda #$09		lda	#9
.8eaf	4c 55 8d	jmp $8d55		jmp	ErrorHandler
.8eb2					_SCLExit:
.8eb2	7a		ply				ply
.8eb3	60		rts				rts
.8eb4					_SCCopy:
.8eb4	5a		phy				phy
.8eb5	a0 00		ldy #$00			ldy 	#0
.8eb7					_SCCopyLoop:
.8eb7	b1 36		lda ($36),y			lda 	(zTemp0),y
.8eb9	f0 06		beq $8ec1			beq 	_SCCExit
.8ebb	20 a2 a7	jsr $a7a2			jsr 	StringTempWrite
.8ebe	c8		iny				iny
.8ebf	80 f6		bra $8eb7			bra 	_SCCopyLoop
.8ec1					_SCCExit:
.8ec1	7a		ply				ply
.8ec2	60		rts				rts
.8ec3					_SCType:
.8ec3	4c ac 9f	jmp $9fac			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/divide.asm

.8ec6					IntegerDivide:
.8ec6	fa		plx				plx
.8ec7	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.8eca	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8ecd	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8ece	0a		asl a				asl 	a
.8ecf	10 05		bpl $8ed6			bpl 	_NotRef
.8ed1	48		pha				pha
.8ed2	20 1d 96	jsr $961d			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8ed5	68		pla				pla
.8ed6					_NotRef:
.8ed6	0a		asl a				asl 	a
.8ed7	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.8ed9	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8edc	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8edf	f0 03		beq $8ee4			beq 	_IntegerCode 				; if clear, then we have two integers
.8ee1	4c ac 9f	jmp $9fac			jmp 	TypeError 					; anything else, type mismatch.
.8ee4					_IntegerCode:
.8ee4	20 06 8f	jsr $8f06			jsr 	CheckDivideZero 			; do div zero check
.8ee7	20 3e 8f	jsr $8f3e			jsr 	Int32Divide 				; do the division
.8eea	20 fb 8f	jsr $8ffb			jsr 	CalculateSign 				; calculate result sign
.8eed					NSMCopyPlusTwoToZero:
.8eed	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.8ef0	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.8ef3	bd 12 04	lda $0412,x			lda 	NSMantissa1+2,x
.8ef6	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.8ef9	bd 1a 04	lda $041a,x			lda 	NSMantissa2+2,x
.8efc	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.8eff	bd 22 04	lda $0422,x			lda 	NSMantissa3+2,x
.8f02	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.8f05	60		rts				rts
.8f06					CheckDivideZero:
.8f06	e8		inx				inx
.8f07	20 48 9e	jsr $9e48			jsr 	NSMIsZero
.8f0a	f0 02		beq $8f0e			beq 	_CDVError
.8f0c	ca		dex				dex
.8f0d	60		rts				rts
.8f0e					_CDVError:
.8f0e	a9 03		lda #$03		lda	#3
.8f10	4c 55 8d	jmp $8d55		jmp	ErrorHandler
.8f13					IntegerModulus:
.8f13	fa		plx				plx
.8f14	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.8f17	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8f1a	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8f1b	0a		asl a				asl 	a
.8f1c	10 05		bpl $8f23			bpl 	_NotRef
.8f1e	48		pha				pha
.8f1f	20 1d 96	jsr $961d			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8f22	68		pla				pla
.8f23					_NotRef:
.8f23	0a		asl a				asl 	a
.8f24	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.8f26	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8f29	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8f2c	f0 03		beq $8f31			beq 	_IntegerCode 				; if clear, then we have two integers
.8f2e	4c ac 9f	jmp $9fac			jmp 	TypeError 					; anything else, type mismatch.
.8f31					_IntegerCode:
.8f31					IntegerModulusNoCheck:
.8f31	20 06 8f	jsr $8f06			jsr 	CheckDivideZero 			; do div zero check
.8f34	20 3e 8f	jsr $8f3e			jsr 	Int32Divide 				; do the division
.8f37	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; clear the sign bit.
.8f3a	5e 00 04	lsr $0400,x			lsr 	NSStatus,x
.8f3d	60		rts				rts
.8f3e					Int32Divide:
.8f3e	48		pha				pha 								; save AXY
.8f3f	5a		phy				phy
.8f40	20 ef 9d	jsr $9def			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.8f43	20 14 9e	jsr $9e14			jsr 	NSMSetZeroMantissaOnly 		; set S[X] to zero
.8f46	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.8f48					_I32DivideLoop:
.8f48	e8		inx				inx
.8f49	e8		inx				inx
.8f4a	20 2d 9e	jsr $9e2d			jsr 	NSMShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.8f4d	ca		dex				dex
.8f4e	ca		dex				dex
.8f4f	20 2e 9e	jsr $9e2e			jsr 	NSMRotateLeft
.8f52	20 7e 8f	jsr $8f7e			jsr 	DivideCheckSubtract 		; check if subtract possible
.8f55	90 03		bcc $8f5a			bcc 	_I32DivideNoCarryIn
.8f57	fe 0a 04	inc $040a,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.8f5a					_I32DivideNoCarryIn:
.8f5a	88		dey				dey 								; loop round till division completed.
.8f5b	d0 eb		bne $8f48			bne 	_I32DivideLoop
.8f5d	7a		ply				ply 								; restore AXY and exit
.8f5e	68		pla				pla
.8f5f	60		rts				rts
.8f60					Int32ShiftDivide:
.8f60	48		pha				pha 								; save AY
.8f61	5a		phy				phy
.8f62	e8		inx				inx 								; clear S[X+2]
.8f63	e8		inx				inx
.8f64	20 18 9e	jsr $9e18			jsr 	NSMSetZero
.8f67	ca		dex				dex
.8f68	ca		dex				dex
.8f69	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.8f6b					_I32SDLoop:
.8f6b	20 7e 8f	jsr $8f7e			jsr 	DivideCheckSubtract 		; check if subtract possible
.8f6e	e8		inx				inx
.8f6f	e8		inx				inx
.8f70	20 2e 9e	jsr $9e2e			jsr 	NSMRotateLeft				; shift 64 bit FPA left, rotating carry in
.8f73	ca		dex				dex
.8f74	ca		dex				dex
.8f75	20 2e 9e	jsr $9e2e			jsr 	NSMRotateLeft
.8f78	88		dey				dey 	 							; do 31 times
.8f79	d0 f0		bne $8f6b			bne 	_I32SDLoop
.8f7b	7a		ply				ply 								; restore AY and exit
.8f7c	68		pla				pla
.8f7d	60		rts				rts
.8f7e					DivideCheckSubtract:
.8f7e	20 b3 90	jsr $90b3			jsr 	SubTopTwoStack 				; subtract Stack[X+1] from Stack[X+0]
.8f81	b0 04		bcs $8f87			bcs 	_DCSExit 					; if carry set, then could do, exit
.8f83	20 8d 90	jsr $908d			jsr 	AddTopTwoStack 				; add it back in
.8f86	18		clc				clc 								; and return False
.8f87					_DCSExit:
.8f87	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/multiply.asm

.8f88					MulInteger:
.8f88	fa		plx				plx
.8f89	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.8f8c	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8f8f	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8f90	0a		asl a				asl 	a
.8f91	10 05		bpl $8f98			bpl 	_NotRef
.8f93	48		pha				pha
.8f94	20 1d 96	jsr $961d			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8f97	68		pla				pla
.8f98					_NotRef:
.8f98	0a		asl a				asl 	a 							; put MSB of type into A:7
.8f99	30 0b		bmi $8fa6			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.8f9b	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8f9e	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8fa1	f0 06		beq $8fa9			beq 	_IntegerCode 				; if clear, then we have two integers
.8fa3	4c c1 94	jmp $94c1			jmp 	FloatingPointMultiply 							; otherwise at least one float.
.8fa6					_StringData:
.8fa6	4c b6 9f	jmp $9fb6			jmp 	NotDoneError							; at least one string - don't know both are strings.
.8fa9					_IntegerCode:
.8fa9	20 b6 8f	jsr $8fb6			jsr 	MultiplyShort
.8fac	c9 00		cmp #$00			cmp 	#0
.8fae	f0 05		beq $8fb5			beq 	_MIExit
.8fb0	a9 04		lda #$04		lda	#4
.8fb2	4c 55 8d	jmp $8d55		jmp	ErrorHandler
.8fb5					_MIExit:
.8fb5	60		rts				rts
.8fb6					MultiplyShort:
.8fb6	5a		phy				phy 								; save Y
.8fb7	20 ef 9d	jsr $9def			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.8fba	20 14 9e	jsr $9e14			jsr 	NSMSetZeroMantissaOnly 		; set mantissa S[X] to zero
.8fbd	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.8fbf					_I32MLoop:
.8fbf	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.8fc2	1d 12 04	ora $0412,x			ora 	NSMantissa1+2,x
.8fc5	1d 1a 04	ora $041a,x			ora 	NSMantissa2+2,x
.8fc8	1d 22 04	ora $0422,x			ora 	NSMantissa3+2,x
.8fcb	f0 28		beq $8ff5			beq 	_I32MExit 					; exit if zero
.8fcd	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.8fd0	29 01		and #$01			and 	#1
.8fd2	f0 0e		beq $8fe2			beq 	_I32MNoAdd
.8fd4	20 8d 90	jsr $908d			jsr 	AddTopTwoStack 				; if so add S[X+1] to S[X+0]
.8fd7	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.8fda	10 06		bpl $8fe2			bpl 	_I32MNoAdd
.8fdc					_I32ShiftRight:
.8fdc	20 3b 9e	jsr $9e3b			jsr 	NSMShiftRight 				; shift S[X] right
.8fdf	c8		iny				iny 								; increment shift count
.8fe0	80 0a		bra $8fec			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.8fe2					_I32MNoAdd:
.8fe2	3c 21 04	bit $0421,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.8fe5	70 f5		bvs $8fdc			bvs 	_I32ShiftRight 				; instead.
.8fe7	e8		inx				inx
.8fe8	20 2d 9e	jsr $9e2d			jsr 	NSMShiftLeft 				; shift additive S[X+1] left
.8feb	ca		dex				dex
.8fec					_I32MShiftUpper:
.8fec	e8		inx				inx 								; shift S[X+2] right
.8fed	e8		inx				inx
.8fee	20 3b 9e	jsr $9e3b			jsr 	NSMShiftRight
.8ff1	ca		dex				dex
.8ff2	ca		dex				dex
.8ff3	80 ca		bra $8fbf			bra 	_I32MLoop 					; try again.
.8ff5					_I32MExit:
.8ff5	20 fb 8f	jsr $8ffb			jsr 	CalculateSign
.8ff8	98		tya				tya 								; shift in A
.8ff9	7a		ply				ply 								; restore Y and exit
.8ffa	60		rts				rts
.8ffb					CalculateSign:
.8ffb	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.8ffe	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; shift result left
.9001	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.9004	0a		asl a				asl 	a 							; shift bit 7 into carry
.9005	7e 00 04	ror $0400,x			ror 	NSStatus,x 					; shift right into status byte.
.9008	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/scompare.asm

.9009					CompareStrings:
.9009	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check both are strings
.900c	3d 01 04	and $0401,x			and 	NSStatus+1,x
.900f	29 10		and #$10			and 	#NSBIsString
.9011	f0 2c		beq $903f			beq 	_CSTypeError
.9013	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy string addresses to zTemp0/1
.9016	85 36		sta $36				sta 	zTemp0
.9018	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.901b	85 37		sta $37				sta 	zTemp0+1
.901d	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.9020	85 38		sta $38				sta 	zTemp1
.9022	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.9025	85 39		sta $39				sta 	zTemp1+1
.9027	5a		phy				phy 								; save Y so we can access strings
.9028	a0 ff		ldy #$ff			ldy 	#$FF 						; -1 for pre increment.
.902a					_CSLoop:
.902a	c8		iny				iny
.902b	b1 36		lda ($36),y			lda 	(zTemp0),y 					; check if they are the same
.902d	d1 38		cmp ($38),y			cmp 	(zTemp1),y
.902f	d0 06		bne $9037			bne 	_CSDifferent
.9031	c9 00		cmp #$00			cmp 	#0 							; reached end ?
.9033	d0 f5		bne $902a			bne 	_CSLoop 					; still comparing
.9035					_CSExit:
.9035	7a		ply				ply 								; reached end, return zero in A from EOS
.9036	60		rts				rts
.9037					_CSDifferent:
.9037	a9 ff		lda #$ff			lda 	#255 						; if < return $FF
.9039	90 fa		bcc $9035			bcc		_CSExit
.903b	a9 01		lda #$01			lda 	#1 							; otherwise return 1.
.903d	80 f6		bra $9035			bra 	_CSExit
.903f					_CSTypeError:
.903f	4c ac 9f	jmp $9fac			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/shifts.asm

.9042					ShiftLeft:
.9042	38		sec				sec
.9043	80 01		bra $9046			bra 	ShiftMain
.9045					ShiftRight:
.9045	18		clc				clc
.9046					ShiftMain:
.9046	fa		plx				plx 								; restore X
.9047	08		php				php 								; save direction
.9048	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.904b	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.904e	0a		asl a				asl 	a 							; shift reference bit into sign bit
.904f	0a		asl a				asl 	a
.9050	10 05		bpl $9057			bpl 	_NotRef
.9052	48		pha				pha
.9053	20 1d 96	jsr $961d			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9056	68		pla				pla
.9057					_NotRef:
.9057	0a		asl a				asl 	a
.9058	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.905a	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.905d	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9060	f0 03		beq $9065			beq 	_IntegerCode 				; if clear, then we have two integers
.9062	4c ac 9f	jmp $9fac			jmp 	TypeError 					; anything else, type mismatch.
.9065					_IntegerCode:
.9065	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; check number < 32
.9068	29 e0		and #$e0			and 	#$E0
.906a	1d 11 04	ora $0411,x			ora 	NSMantissa1+1,x
.906d	1d 19 04	ora $0419,x			ora 	NSMantissa2+1,x
.9070	1d 21 04	ora $0421,x			ora 	NSMantissa3+1,x
.9073	d0 13		bne $9088			bne 	_SMExit0 					; if >= 32 it will always return zero.
.9075					_SMLoop:
.9075	de 09 04	dec $0409,x			dec 	NSMantissa0+1,x 			; predecrement, could do << 0
.9078	30 11		bmi $908b			bmi 	_SMExit 					; exit if done.
.907a	28		plp				plp 								; restore direcition setting
.907b	08		php				php
.907c	90 05		bcc $9083			bcc 	_SMRight
.907e	20 2d 9e	jsr $9e2d			jsr 	NSMShiftLeft 				; shift left if CS
.9081	80 f2		bra $9075			bra 	_SMLoop
.9083					_SMRight:
.9083	20 3b 9e	jsr $9e3b			jsr 	NSMShiftRight 				; shift right if CC
.9086	80 ed		bra $9075			bra 	_SMLoop
.9088					_SMExit0:
.9088	20 18 9e	jsr $9e18			jsr 	NSMSetZero 					; return zero.
.908b					_SMExit:
.908b	28		plp				plp 								; throw direction
.908c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/simple.asm

.908d					AddTopTwoStack:
.908d	18		clc				clc
.908e	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.9091	7d 09 04	adc $0409,x			adc 		NSMantissa0+1,x
.9094	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9097	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.909a	7d 11 04	adc $0411,x			adc 		NSMantissa1+1,x
.909d	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.90a0	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.90a3	7d 19 04	adc $0419,x			adc 		NSMantissa2+1,x
.90a6	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.90a9	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.90ac	7d 21 04	adc $0421,x			adc 		NSMantissa3+1,x
.90af	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.90b2	60		rts				rts
.90b3					SubTopTwoStack:
.90b3	38		sec				sec
.90b4	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.90b7	fd 09 04	sbc $0409,x			sbc 		NSMantissa0+1,x
.90ba	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.90bd	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.90c0	fd 11 04	sbc $0411,x			sbc 		NSMantissa1+1,x
.90c3	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.90c6	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.90c9	fd 19 04	sbc $0419,x			sbc 		NSMantissa2+1,x
.90cc	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.90cf	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.90d2	fd 21 04	sbc $0421,x			sbc 		NSMantissa3+1,x
.90d5	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.90d8	60		rts				rts
.90d9					AddInteger:
.90d9	fa		plx				plx
.90da	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.90dd	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.90e0	0a		asl a				asl 	a 							; shift reference bit into sign bit
.90e1	0a		asl a				asl 	a
.90e2	10 05		bpl $90e9			bpl 	_NotRef
.90e4	48		pha				pha
.90e5	20 1d 96	jsr $961d			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.90e8	68		pla				pla
.90e9					_NotRef:
.90e9	0a		asl a				asl 	a 							; put MSB of type into A:7
.90ea	30 0b		bmi $90f7			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.90ec	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.90ef	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.90f2	f0 06		beq $90fa			beq 	_IntegerCode 				; if clear, then we have two integers
.90f4	4c 41 93	jmp $9341			jmp 	FloatingPointAdd 							; otherwise at least one float.
.90f7					_StringData:
.90f7	4c 69 8e	jmp $8e69			jmp 	StringConcat							; at least one string - don't know both are strings.
.90fa					_IntegerCode:
.90fa					AddCode:
.90fa	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.90fd	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.9100	10 8b		bpl $908d			bpl 	AddTopTwoStack
.9102	20 b3 90	jsr $90b3			jsr 	SubTopTwoStack 				; do a physical subtraction
.9105	3c 20 04	bit $0420,x			bit 	NSMantissa3,x 				; result is +ve, okay
.9108	10 09		bpl $9113			bpl 	_AddExit
.910a	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; sign is that of 2nd value
.910d	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9110	20 cd 9d	jsr $9dcd			jsr 	NSMNegateMantissa 			; negate the mantissa and exit
.9113					_AddExit:
.9113	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; check for -0
.9116	d0 03		bne $911b			bne 	_AddNonZero
.9118	9e 00 04	stz $0400,x			stz 	NSStatus,x
.911b					_AddNonZero:
.911b	60		rts				rts
.911c					SubInteger:
.911c	fa		plx				plx
.911d	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9120	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9123	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9124	0a		asl a				asl 	a
.9125	10 05		bpl $912c			bpl 	_NotRef
.9127	48		pha				pha
.9128	20 1d 96	jsr $961d			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.912b	68		pla				pla
.912c					_NotRef:
.912c	0a		asl a				asl 	a 							; put MSB of type into A:7
.912d	30 0b		bmi $913a			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.912f	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9132	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9135	f0 06		beq $913d			beq 	_IntegerCode 				; if clear, then we have two integers
.9137	4c 46 93	jmp $9346			jmp 	FloatingPointSub 							; otherwise at least one float.
.913a					_StringData:
.913a	4c b6 9f	jmp $9fb6			jmp 	NotDoneError							; at least one string - don't know both are strings.
.913d					_IntegerCode:
.913d	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; negate the second value.
.9140	49 80		eor #$80			eor 	#$80
.9142	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.9145	80 b3		bra $90fa			bra 	AddCode 					; and do the same code as add.
.9147					AndInteger:
.9147	fa		plx				plx
.9148	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.914b	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.914e	0a		asl a				asl 	a 							; shift reference bit into sign bit
.914f	0a		asl a				asl 	a
.9150	10 05		bpl $9157			bpl 	_NotRef
.9152	48		pha				pha
.9153	20 1d 96	jsr $961d			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9156	68		pla				pla
.9157					_NotRef:
.9157	0a		asl a				asl 	a
.9158	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.915a	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.915d	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9160	f0 03		beq $9165			beq 	_IntegerCode 				; if clear, then we have two integers
.9162	4c ac 9f	jmp $9fac			jmp 	TypeError 					; anything else, type mismatch.
.9165					_IntegerCode:
.9165	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.9168	3d 09 04	and $0409,x			and 		NSMantissa0+1,x
.916b	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.916e	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.9171	3d 11 04	and $0411,x			and 		NSMantissa1+1,x
.9174	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9177	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.917a	3d 19 04	and $0419,x			and 		NSMantissa2+1,x
.917d	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9180	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.9183	3d 21 04	and $0421,x			and 		NSMantissa3+1,x
.9186	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9189	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.918c	60		rts				rts
.918d					OraInteger:
.918d	fa		plx				plx
.918e	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9191	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9194	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9195	0a		asl a				asl 	a
.9196	10 05		bpl $919d			bpl 	_NotRef
.9198	48		pha				pha
.9199	20 1d 96	jsr $961d			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.919c	68		pla				pla
.919d					_NotRef:
.919d	0a		asl a				asl 	a
.919e	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.91a0	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91a3	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.91a6	f0 03		beq $91ab			beq 	_IntegerCode 				; if clear, then we have two integers
.91a8	4c ac 9f	jmp $9fac			jmp 	TypeError 					; anything else, type mismatch.
.91ab					_IntegerCode:
.91ab	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.91ae	1d 09 04	ora $0409,x			ora 		NSMantissa0+1,x
.91b1	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.91b4	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.91b7	1d 11 04	ora $0411,x			ora 		NSMantissa1+1,x
.91ba	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.91bd	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.91c0	1d 19 04	ora $0419,x			ora 		NSMantissa2+1,x
.91c3	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.91c6	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.91c9	1d 21 04	ora $0421,x			ora 		NSMantissa3+1,x
.91cc	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.91cf	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.91d2	60		rts				rts
.91d3					EorInteger:
.91d3	fa		plx				plx
.91d4	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.91d7	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.91da	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91db	0a		asl a				asl 	a
.91dc	10 05		bpl $91e3			bpl 	_NotRef
.91de	48		pha				pha
.91df	20 1d 96	jsr $961d			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91e2	68		pla				pla
.91e3					_NotRef:
.91e3	0a		asl a				asl 	a
.91e4	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.91e6	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91e9	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.91ec	f0 03		beq $91f1			beq 	_IntegerCode 				; if clear, then we have two integers
.91ee	4c ac 9f	jmp $9fac			jmp 	TypeError 					; anything else, type mismatch.
.91f1					_IntegerCode:
.91f1	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.91f4	5d 09 04	eor $0409,x			eor 		NSMantissa0+1,x
.91f7	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.91fa	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.91fd	5d 11 04	eor $0411,x			eor 		NSMantissa1+1,x
.9200	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9203	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.9206	5d 19 04	eor $0419,x			eor 		NSMantissa2+1,x
.9209	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.920c	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.920f	5d 21 04	eor $0421,x			eor 		NSMantissa3+1,x
.9212	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9215	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.9218	60		rts				rts
.9219					WordIndirect:
.9219	fa		plx				plx
.921a	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.921d	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9220	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9221	0a		asl a				asl 	a
.9222	10 05		bpl $9229			bpl 	_NotRef
.9224	48		pha				pha
.9225	20 1d 96	jsr $961d			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9228	68		pla				pla
.9229					_NotRef:
.9229	0a		asl a				asl 	a
.922a	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.922c	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.922f	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9232	f0 03		beq $9237			beq 	_IntegerCode 				; if clear, then we have two integers
.9234	4c ac 9f	jmp $9fac			jmp 	TypeError 					; anything else, type mismatch.
.9237					_IntegerCode:
.9237	20 fa 90	jsr $90fa			jsr 	AddCode 					; add the two values
.923a	a9 22		lda #$22			lda 	#NSBIsReference+2 			; make a 2 byte reference
.923c	9d 00 04	sta $0400,x			sta 	NSStatus,x
.923f	60		rts				rts
.9240					ByteIndirect:
.9240	fa		plx				plx
.9241	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9244	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9247	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9248	0a		asl a				asl 	a
.9249	10 05		bpl $9250			bpl 	_NotRef
.924b	48		pha				pha
.924c	20 1d 96	jsr $961d			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.924f	68		pla				pla
.9250					_NotRef:
.9250	0a		asl a				asl 	a
.9251	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9253	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9256	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9259	f0 03		beq $925e			beq 	_IntegerCode 				; if clear, then we have two integers
.925b	4c ac 9f	jmp $9fac			jmp 	TypeError 					; anything else, type mismatch.
.925e					_IntegerCode:
.925e	20 fa 90	jsr $90fa			jsr 	AddCode 					; add the two values
.9261	a9 21		lda #$21			lda 	#NSBIsReference+1 			; make a 1 byte reference
.9263	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9266	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/tostring.asm

.9267					LCLConvertInt16:
.9267	8d 08 04	sta $0408			sta 	NSMantissa0 				; set up as 32 bit conversion
.926a	8e 10 04	stx $0410			stx 	NSMantissa1
.926d	9c 18 04	stz $0418			stz 	NSMantissa2
.9270	9c 20 04	stz $0420			stz 	NSMantissa3
.9273	9c 00 04	stz $0400			stz 	NSStatus 					; positive integer
.9276	a2 00		ldx #$00			ldx 	#0 							; stack level
.9278	a9 0a		lda #$0a			lda 	#10 						; base
.927a	80 00		bra $927c			bra 	ConvertInt32
.927c					ConvertInt32:
.927c	5a		phy				phy
.927d	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.927f	2c 00 04	bit $0400			bit 	NSStatus 					; output a - if not negative.
.9282	10 08		bpl $928c			bpl 	_CI32NotNeg
.9284	48		pha				pha
.9285	a9 2d		lda #$2d			lda 	#'-'
.9287	99 f9 05	sta $05f9,y			sta 	NumberBuffer,y
.928a	c8		iny				iny
.928b	68		pla				pla
.928c					_CI32NotNeg:
.928c	20 9a 92	jsr $929a			jsr 	_CI32DivideConvert 			; recursive conversion
.928f	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.9291	99 f9 05	sta $05f9,y			sta 	NumberBuffer,y
.9294	7a		ply				ply
.9295	a2 05		ldx #$05			ldx 	#NumberBuffer >> 8
.9297	a9 f9		lda #$f9			lda 	#NumberBuffer & $FF
.9299	60		rts				rts
.929a					_CI32DivideConvert:
.929a	e8		inx				inx 								; write to next slot up
.929b	20 1a 9e	jsr $9e1a			jsr 	NSMSetByte
.929e	ca		dex				dex
.929f	20 3e 8f	jsr $8f3e			jsr 	Int32Divide 				; divide
.92a2	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; save remainder
.92a5	48		pha				pha
.92a6	20 ed 8e	jsr $8eed			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.92a9	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; is it zero ?
.92ac	f0 06		beq $92b4			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.92ae	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.92b1	20 9a 92	jsr $929a			jsr 	_CI32DivideConvert 			; and recusrively call.
.92b4					_CI32NoRecurse:
.92b4	68		pla				pla 								; remainder
.92b5	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.92b7	90 02		bcc $92bb			bcc 	_CI32NotHex
.92b9	69 26		adc #$26			adc 	#6+32
.92bb					_CI32NotHex:
.92bb	69 30		adc #$30			adc 	#48
.92bd	99 f9 05	sta $05f9,y			sta 	NumberBuffer,y 				; write out and exit
.92c0	c8		iny				iny
.92c1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/expression.asm


;******  Processing file: ./common/expressions/../generated/precedence.dat

.92c2					PrecedenceLevel:
>92c2	04					.byte	 4	; $00 <<
>92c3	02					.byte	 2	; $01 <=
>92c4	02					.byte	 2	; $02 <>
>92c5	00					.byte	 0	; $03 !!3
>92c6	00					.byte	 0	; $04 ><
>92c7	02					.byte	 2	; $05 >=
>92c8	04					.byte	 4	; $06 >>
>92c9	00					.byte	 0	; $07 !!7
>92ca	00					.byte	 0	; $08 !!8
>92cb	00					.byte	 0	; $09 !!9
>92cc	00					.byte	 0	; $0a !!10
>92cd	00					.byte	 0	; $0b !!11
>92ce	00					.byte	 0	; $0c !!12
>92cf	00					.byte	 0	; $0d !!13
>92d0	00					.byte	 0	; $0e !!14
>92d1	00					.byte	 0	; $0f !!15
>92d2	00					.byte	 0	; $10 @
>92d3	00					.byte	 0	; $11 !!17
>92d4	00					.byte	 0	; $12 !!18
>92d5	00					.byte	 0	; $13 [
>92d6	04					.byte	 4	; $14 \
>92d7	00					.byte	 0	; $15 ]
>92d8	01					.byte	 1	; $16 ^
>92d9	00					.byte	 0	; $17 _
>92da	00					.byte	 0	; $18 `
>92db	00					.byte	 0	; $19 !!25
>92dc	00					.byte	 0	; $1a !!26
>92dd	00					.byte	 0	; $1b {
>92de	01					.byte	 1	; $1c |
>92df	00					.byte	 0	; $1d }
>92e0	00					.byte	 0	; $1e ~
>92e1	00					.byte	 0	; $1f [7m<7F>[m
>92e2	00					.byte	 0	; $20
>92e3	05					.byte	 5	; $21 !
>92e4	00					.byte	 0	; $22 "
>92e5	00					.byte	 0	; $23 #
>92e6	05					.byte	 5	; $24 $
>92e7	04					.byte	 4	; $25 %
>92e8	01					.byte	 1	; $26 &
>92e9	00					.byte	 0	; $27 '
>92ea	00					.byte	 0	; $28 (
>92eb	00					.byte	 0	; $29 )
>92ec	04					.byte	 4	; $2a *
>92ed	03					.byte	 3	; $2b +
>92ee	00					.byte	 0	; $2c ,
>92ef	03					.byte	 3	; $2d -
>92f0	00					.byte	 0	; $2e .
>92f1	04					.byte	 4	; $2f /
>92f2	00					.byte	 0	; $30 0
>92f3	00					.byte	 0	; $31 1
>92f4	00					.byte	 0	; $32 2
>92f5	00					.byte	 0	; $33 3
>92f6	00					.byte	 0	; $34 4
>92f7	00					.byte	 0	; $35 5
>92f8	00					.byte	 0	; $36 6
>92f9	00					.byte	 0	; $37 7
>92fa	00					.byte	 0	; $38 8
>92fb	00					.byte	 0	; $39 9
>92fc	00					.byte	 0	; $3a :
>92fd	00					.byte	 0	; $3b ;
>92fe	02					.byte	 2	; $3c <
>92ff	02					.byte	 2	; $3d =
>9300	02					.byte	 2	; $3e >
>9301	05					.byte	 5	; $3f ?

;******  Return to file: ./common/expressions/expression.asm

.9302					EvaluateExpressionAt0:
.9302	a2 00		ldx #$00			ldx 	#0 							; bottom stack level
.9304					EvaluateExpression:
.9304	a9 00		lda #$00			lda 	#0 							; lowest precedence level
.9306					EvaluateExpressionAtPrecedence:
.9306	48		pha				pha 								; save precedence level
.9307	20 de 97	jsr $97de			jsr 	EvaluateTerm 				; evaluate term into level X.
.930a	68		pla				pla 								; restore precedence level.
.930b					_EXPRLoop:
.930b	85 36		sta $36				sta 	zTemp0 						; save current precedence level.
.930d	b1 30		lda ($30),y			lda 	(codePtr),y
.930f	c9 40		cmp #$40			cmp		#$40 						; if >= $40 cannot be an operator
.9311	b0 25		bcs $9338			bcs 	_EXPRExit
.9313	da		phx				phx 								; read the operator precedence
.9314	aa		tax				tax
.9315	bd c2 92	lda $92c2,x			lda 	PrecedenceLevel,x
.9318	fa		plx				plx
.9319	c9 00		cmp #$00			cmp 	#0							; if zero exit (not an operator)
.931b	f0 1b		beq $9338			beq 	_EXPRExit
.931d	85 37		sta $37				sta 	zTemp0+1 					; save operator precedence level.
.931f	a5 36		lda $36				lda 	zTemp0 						; compare current precedence vs. operator precedence
.9321	c5 37		cmp $37				cmp 	zTemp0+1
.9323	b0 13		bcs $9338			bcs		_EXPRExit 					; if current >= operator exit
.9325	48		pha				pha 								; save current precedence.
.9326	b1 30		lda ($30),y			lda 	(codePtr),y
.9328	c8		iny				iny
.9329	48		pha				pha
.932a	a5 37		lda $37				lda 	zTemp0+1 					; get operator precedence level
.932c	e8		inx				inx 								; work out the right hand side.
.932d	20 06 93	jsr $9306			jsr 	EvaluateExpressionAtPrecedence
.9330	ca		dex				dex
.9331	68		pla				pla 								; get operator, call the code.
.9332	20 3b 93	jsr $933b			jsr 	_EXPRCaller
.9335	68		pla				pla 								; restore precedence level
.9336	80 d3		bra $930b			bra 	_EXPRLoop 					; and go round.
.9338					_EXPRExit:
.9338	a5 36		lda $36				lda 	zTemp0 						; A = current precedence level.
.933a	60		rts				rts
.933b					_EXPRCaller:
.933b	da		phx				phx 								; save on stack, first thing is to restore it
.933c	0a		asl a				asl 	a 							; double so can use vectors into X
.933d	aa		tax				tax
.933e	7c 82 8a	jmp ($8a82,x)			jmp 	(VectorSetPunc,x) 			; and go to the code.

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/addsub.asm

.9341					FloatingPointAdd:
.9341	20 ea 94	jsr $94ea			jsr 	FloatPrepare 				; prepare for floats
.9344	80 0b		bra $9351			bra 	FloatAdd
.9346					FloatingPointSub:
.9346	20 ea 94	jsr $94ea			jsr 	FloatPrepare 				; prepare for floats
.9349					FloatSubtract:
.9349	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; negate FPB
.934c	49 80		eor #$80			eor 	#$80
.934e	9d 01 04	sta $0401,x			sta 	NSStatus+1,x				; and fall through.
.9351					FloatAdd:
.9351	48		pha				pha
.9352	5a		phy				phy
.9353	20 fb 94	jsr $94fb			jsr 	NSNormalise 				; normalise S[X]
.9356	f0 5c		beq $93b4			beq 	_FAReturn1
.9358	e8		inx				inx 								; normalise S[X+1]
.9359	20 fb 94	jsr $94fb			jsr 	NSNormalise
.935c	ca		dex				dex
.935d	c9 00		cmp #$00			cmp 	#0
.935f	f0 77		beq $93d8			beq 	_FAExit 					; if so, just return A
.9361	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; are the exponents the same ?
.9364	dd 29 04	cmp $0429,x			cmp 	NSExponent+1,x
.9367	f0 1b		beq $9384			beq 	_FAExponentsEqual
.9369	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; work out the larger exponent
.936c	a8		tay				tay
.936d	38		sec				sec 								; do a signed comparison of the exponents.
.936e	fd 29 04	sbc $0429,x			sbc 	NSExponent+1,x
.9371	50 02		bvc $9375			bvc 	_FANoSignedChange
.9373	49 80		eor #$80			eor 	#$80
.9375					_FANoSignedChange:
.9375	29 80		and #$80			and 	#$80
.9377	10 03		bpl $937c			bpl 	_FAHaveMax
.9379	bc 29 04	ldy $0429,x			ldy 	NSExponent+1,x
.937c					_FAHaveMax:
.937c	20 db 93	jsr $93db			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.937f	e8		inx				inx
.9380	20 db 93	jsr $93db			jsr 	_FAShiftToExponent
.9383	ca		dex				dex
.9384					_FAExponentsEqual:
.9384	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; are the signs the same
.9387	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.938a	30 10		bmi $939c			bmi 	_FADifferentSigns
.938c	20 8d 90	jsr $908d			jsr 	AddTopTwoStack 				; do the add of the mantissae
.938f	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.9392	10 44		bpl $93d8			bpl 	_FAExit 					; if no, we are done.
.9394	20 3b 9e	jsr $9e3b			jsr 	NSMShiftRight 				; shift A right, renormalising it.
.9397	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; bump the exponent and exit
.939a	80 3c		bra $93d8			bra 	_FAExit
.939c					_FADifferentSigns:
.939c	20 b3 90	jsr $90b3			jsr 	SubTopTwoStack 				; subtract mantissa B from A
.939f	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; is the result negative ?
.93a2	10 06		bpl $93aa			bpl 	_FACheckZero 				; if no, check for -0
.93a4	20 c4 9d	jsr $9dc4			jsr 	NSMNegate 					; netate result
.93a7	20 cd 9d	jsr $9dcd			jsr 	NSMNegateMantissa 			; negate (2'c) the mantissa
.93aa					_FACheckZero:
.93aa	20 48 9e	jsr $9e48			jsr 	NSMIsZero	 				; check for -0
.93ad	d0 29		bne $93d8			bne 	_FAExit
.93af	9e 00 04	stz $0400,x			stz 	NSStatus,x
.93b2	80 24		bra $93d8			bra 	_FAExit
.93b4					_FAReturn1:
.93b4	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.93b7	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.93ba	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.93bd	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.93c0	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.93c3	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.93c6	bd 21 04	lda $0421,x			lda 	NSMantissa3+1,x
.93c9	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.93cc	bd 29 04	lda $0429,x			lda 	NSExponent+1,x
.93cf	9d 28 04	sta $0428,x			sta 	NSExponent,x
.93d2	bd 01 04	lda $0401,x			lda 	NSStatus+1,x
.93d5	9d 00 04	sta $0400,x			sta 	NSStatus,x
.93d8					_FAExit:
.93d8	7a		ply				ply
.93d9	68		pla				pla
.93da	60		rts				rts
.93db					_FAShiftToExponent:
.93db					_FAShiftToExponent2:
.93db	98		tya				tya 								; compare Y to exponent
.93dc	dd 28 04	cmp $0428,x			cmp 	NSExponent,x 				; reached the exponent required ?
.93df	f0 08		beq $93e9			beq 	_FASEExit 					; exit if so.
.93e1	20 3b 9e	jsr $9e3b			jsr 	NSMShiftRight	 			; shift the mantissa right
.93e4	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; increment exponent
.93e7	80 f2		bra $93db			bra 	_FAShiftToExponent2
.93e9					_FASEExit:
.93e9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/compare.asm

.93ea					CompareFloat:
.93ea	20 49 93	jsr $9349			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.93ed	bd 10 04	lda $0410,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.93f0	29 f8		and #$f8			and 	#$F8
.93f2	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.93f5	1d 20 04	ora $0420,x			ora 	NSMantissa3,x
.93f8	f0 09		beq $9403			beq 	_FCExit 					; zero, so approximately identical
.93fa	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.93fc	3c 00 04	bit $0400,x			bit 	NSStatus,x
.93ff	10 02		bpl $9403			bpl 	_FCExit
.9401					_FCNegative:
.9401	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.9403					_FCExit:
.9403	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/divide.asm

.9404					FDivideCommand:
.9404	fa		plx				plx	 								; restore stack position
.9405	20 ea 94	jsr $94ea			jsr 	FloatPrepare 				; prepare for floats
.9408					FloatDivide:
.9408	48		pha				pha
.9409	e8		inx				inx
.940a	20 fb 94	jsr $94fb			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.940d	ca		dex				dex
.940e	c9 00		cmp #$00			cmp 	#0
.9410	f0 20		beq $9432			beq 	_FDZero
.9412	20 fb 94	jsr $94fb			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.9415	f0 19		beq $9430			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.9417	20 60 8f	jsr $8f60			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.941a	20 ed 8e	jsr $8eed			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.941d	20 fb 94	jsr $94fb			jsr		NSNormalise 				; renormalise
.9420	20 fb 8f	jsr $8ffb			jsr 	CalculateSign 				; calculate result sign
.9423	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; calculate exponent
.9426	38		sec				sec
.9427	fd 29 04	sbc $0429,x			sbc 	NSExponent+1,x
.942a	38		sec				sec
.942b	e9 1e		sbc #$1e			sbc 	#30
.942d	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9430					_FDExit:
.9430	68		pla				pla
.9431	60		rts				rts
.9432					_FDZero:
.9432	a9 03		lda #$03		lda	#3
.9434	4c 55 8d	jmp $8d55		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/fractional.asm

.9437					FloatFractionalPart:
.9437	5a		phy				phy
.9438	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; take absolute value
.943b	29 7f		and #$7f			and 	#$7F
.943d	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9440	20 fb 94	jsr $94fb			jsr 	NSNormalise
.9443	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.9446	38		sec				sec
.9447	e9 e0		sbc #$e0			sbc 	#$E0
.9449	90 31		bcc $947c			bcc 	_FFPExit 					; already fractional
.944b	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.944d	b0 2a		bcs $9479			bcs 	_FFPZero
.944f	a8		tay				tay 								; put count to do in Y
.9450	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; do each in turn.
.9453	20 7e 94	jsr $947e			jsr 	_FFPPartial
.9456	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9459	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.945c	20 7e 94	jsr $947e			jsr 	_FFPPartial
.945f	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9462	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9465	20 7e 94	jsr $947e			jsr 	_FFPPartial
.9468	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.946b	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.946e	20 7e 94	jsr $947e			jsr 	_FFPPartial
.9471	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9474	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; zeroed check.
.9477	d0 03		bne $947c			bne 	_FFPExit
.9479					_FFPZero:
.9479	20 18 9e	jsr $9e18			jsr 	NSMSetZero
.947c					_FFPExit:
.947c	7a		ply				ply
.947d	60		rts				rts
.947e					_FFPPartial:
.947e	c0 00		cpy #$00			cpy 	#0 							; no more to do
.9480	f0 17		beq $9499			beq 	_FFFPPExit
.9482	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.9484	b0 0c		bcs $9492			bcs 	_FFFPPWholeByte
.9486	5a		phy				phy
.9487					_FFFPPLeft:
.9487	0a		asl a				asl 	a
.9488	88		dey				dey
.9489	d0 fc		bne $9487			bne 	_FFFPPLeft
.948b	7a		ply				ply
.948c					_FFFPPRight:
.948c	4a		lsr a				lsr 	a
.948d	88		dey				dey
.948e	d0 fc		bne $948c			bne 	_FFFPPRight
.9490	80 07		bra $9499			bra 	_FFFPPExit
.9492					_FFFPPWholeByte:
.9492	98		tya				tya 								; subtract 8 from count
.9493	38		sec				sec
.9494	e9 08		sbc #$08			sbc 	#8
.9496	a8		tay				tay
.9497	a9 00		lda #$00			lda 	#0 							; and clear all
.9499					_FFFPPExit:
.9499	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/integer.asm

.949a					FloatIntegerPart:
.949a	48		pha				pha
.949b	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; is it integer already ?
.949e	f0 1f		beq $94bf			beq 	_FIPExit 					; if so do nothing
.94a0	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; is it zero ?
.94a3	f0 17		beq $94bc			beq 	_FIPZero 					; if so return zero.
.94a5	20 fb 94	jsr $94fb			jsr 	NSNormalise 				; normalise
.94a8	f0 12		beq $94bc			beq 	_FIPZero 					; normalised to zero, exit zero
.94aa					_FIPShift:
.94aa	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.94ad	10 08		bpl $94b7			bpl 	_FIPCheckZero
.94af	20 3b 9e	jsr $9e3b			jsr 	NSMShiftRight 				; shift mantissa right
.94b2	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; bump exponent
.94b5	80 f3		bra $94aa			bra 	_FIPShift
.94b7					_FIPCheckZero:
.94b7	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; avoid -0 problem
.94ba	d0 03		bne $94bf			bne 	_FIPExit 					; set to zero if mantissa zero.
.94bc					_FIPZero:
.94bc	20 18 9e	jsr $9e18			jsr 	NSMSetZero
.94bf					_FIPExit:
.94bf	68		pla				pla
.94c0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/multiply.asm

.94c1					FloatingPointMultiply:
.94c1	20 ea 94	jsr $94ea			jsr 	FloatPrepare 				; prepare for floats
.94c4					FloatMultiply:
.94c4	48		pha				pha
.94c5	20 fb 94	jsr $94fb			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.94c8	f0 1b		beq $94e5			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.94ca	e8		inx				inx
.94cb	20 fb 94	jsr $94fb			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.94ce	ca		dex				dex
.94cf	c9 00		cmp #$00			cmp 	#0
.94d1	f0 0f		beq $94e2			beq 	_FDSetZero
.94d3	20 b6 8f	jsr $8fb6			jsr 	MultiplyShort 				; calculate the result.
.94d6	7d 28 04	adc $0428,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.94d9	18		clc				clc
.94da	7d 29 04	adc $0429,x			adc 	NSExponent+1,x
.94dd	9d 28 04	sta $0428,x			sta 	NSExponent,x
.94e0	80 03		bra $94e5			bra 	_FDExit
.94e2					_FDSetZero:
.94e2	20 18 9e	jsr $9e18			jsr 	NSMSetZero 					; return 0
.94e5					_FDExit:
.94e5	20 fb 94	jsr $94fb			jsr 	NSNormalise 				; normalise the result
.94e8	68		pla				pla
.94e9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/utility.asm

.94ea					FloatPrepare:
.94ea	20 1d 96	jsr $961d			jsr 	DereferenceTopTwo 			; dereference the top two values
.94ed	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check ints/floats
.94f0	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.94f3	29 10		and #$10			and 	#NSBIsString
.94f5	d0 01		bne $94f8			bne 	_FDType
.94f7	60		rts				rts
.94f8					_FDType:
.94f8	4c ac 9f	jmp $9fac			jmp 	TypeError
.94fb					NSNormalise:
.94fb	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; make float, keep sign
.94fe	29 80		and #$80			and 	#$80
.9500	09 08		ora #$08			ora 	#NSTFloat
.9502	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9505	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; if zero exit
.9508	d0 09		bne $9513			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.950a	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; clear the sign bit.
.950d	7e 00 04	ror $0400,x			ror 	NSStatus,x 					; (no -0)
.9510	a9 00		lda #$00			lda 	#0 							; set Z flag
.9512	60		rts				rts
.9513					_NSNormaliseOptimise:
.9513	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; upper byte zero ?
.9516	d0 22		bne $953a			bne 	_NSNormaliseLoop
.9518	bd 18 04	lda $0418,x			lda 	NSMantissa2,x 				; byte normalise
.951b	30 1d		bmi $953a			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.951d	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9520	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9523	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9526	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9529	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.952c	9e 08 04	stz $0408,x			stz 	NSMantissa0,x
.952f	bd 28 04	lda $0428,x			lda 	NSExponent,x
.9532	38		sec				sec
.9533	e9 08		sbc #$08			sbc 	#8
.9535	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9538	80 d9		bra $9513			bra 	_NSNormaliseOptimise
.953a					_NSNormaliseLoop:
.953a	3c 20 04	bit $0420,x			bit 	NSMantissa3,x 				; bit 30 set ?
.953d	70 08		bvs $9547			bvs 	_NSNExit 					; exit if so with Z flag clear
.953f	20 2d 9e	jsr $9e2d			jsr 	NSMShiftLeft 				; shift mantissa left
.9542	de 28 04	dec $0428,x			dec 	NSExponent,x 				; adjust exponent
.9545	80 f3		bra $953a			bra 	_NSNormaliseLoop
.9547					_NSNExit:
.9547	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.9549	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignnumber.asm

.954a					AssignNumber:
.954a	5a		phy				phy
.954b	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy mantissa0/1 to zTemp0
.954e	85 36		sta $36				sta 	zTemp0
.9550	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9553	85 37		sta $37				sta 	zTemp0+1
.9555	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; clear reference bits
.9558	29 df		and #$df			and 	#(NSBIsReference ^ $FF)
.955a	9d 00 04	sta $0400,x			sta 	NSStatus,x
.955d	29 18		and #$18			and 	#NSBTypeMask				; assigning to a float ?
.955f	c9 08		cmp #$08			cmp 	#NSTFloat
.9561	f0 2a		beq $958d			beq 	_ANFloat
.9563	bd 29 04	lda $0429,x			lda		NSExponent+1,x 				; is it a float
.9566	f0 05		beq $956d			beq		_ANNotFloat
.9568	e8		inx				inx
.9569	20 9a 94	jsr $949a			jsr 	FloatIntegerPart 			; make it an integer
.956c	ca		dex				dex
.956d					_ANNotFloat:
.956d	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if byte/word reference.
.9570	29 03		and #$03			and 	#3
.9572	d0 05		bne $9579			bne 	_ANByteWord
.9574	20 99 95	jsr $9599			jsr 	_ANCopy4PackSign 			; copy all 4 bytes and sign
.9577	80 1e		bra $9597			bra 	_ANExit
.9579					_ANByteWord:
.9579	48		pha				pha 								; save count
.957a	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; do byte
.957d	92 36		sta ($36)			sta 	(zTemp0)
.957f	68		pla				pla
.9580	c9 01		cmp #$01			cmp	 	#1
.9582	f0 13		beq $9597			beq 	_ANExit
.9584	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x 			; do word
.9587	a0 01		ldy #$01			ldy 	#1
.9589	91 36		sta ($36),y			sta 	(zTemp0),y
.958b	80 0a		bra $9597			bra 	_ANExit
.958d					_ANFloat:
.958d	20 99 95	jsr $9599			jsr 	_ANCopy4PackSign 			; write all 4 bytes and packed sign
.9590	bd 29 04	lda $0429,x			lda 	NSExponent+1,x 				; copy exponent to slot 4
.9593	a0 04		ldy #$04			ldy 	#4
.9595	91 36		sta ($36),y			sta 	(zTemp0),y
.9597					_ANExit:
.9597	7a		ply				ply
.9598	60		rts				rts
.9599					_ANCopy4PackSign:
.9599	a0 03		ldy #$03			ldy 	#3
.959b	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; sign bit into status
.959e	29 80		and #$80			and 	#$80 						; put into high bit of mantissa 3
.95a0	1d 21 04	ora $0421,x			ora 	NSMantissa3+1,x
.95a3	91 36		sta ($36),y			sta 	(zTemp0),y
.95a5	88		dey				dey
.95a6	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.95a9	91 36		sta ($36),y			sta 	(zTemp0),y
.95ab	88		dey				dey
.95ac	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.95af	91 36		sta ($36),y			sta 	(zTemp0),y
.95b1	88		dey				dey
.95b2	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.95b5	91 36		sta ($36),y			sta 	(zTemp0),y
.95b7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignstring.asm

.95b8					AssignString:
.95b8	5a		phy				phy
.95b9	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.95bc	85 38		sta $38				sta 	zTemp1
.95be	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.95c1	85 39		sta $39				sta 	zTemp1+1
.95c3	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.95c6	85 36		sta $36				sta 	zTemp0
.95c8	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.95cb	85 37		sta $37				sta 	zTemp0+1
.95cd	a0 01		ldy #$01			ldy 	#1 							; the high byte of the target address
.95cf	b1 36		lda ($36),y			lda 	(zTemp0),y
.95d1	f0 23		beq $95f6			beq 	_ASNewStringRequired 		; if zero, a new string is required.
.95d3	38		sec				sec 								; put Address-2 in zsTemp - this is the size/status/string record
.95d4	b2 36		lda ($36)			lda 	(zTemp0) 					; of concreted strings
.95d6	e9 02		sbc #$02			sbc 	#2
.95d8	85 3c		sta $3c				sta 	zsTemp
.95da	a0 01		ldy #$01			ldy 	#1
.95dc	b1 36		lda ($36),y			lda 	(zTemp0),y
.95de	e9 00		sbc #$00			sbc 	#0
.95e0	85 3d		sta $3d				sta 	zsTemp+1
.95e2	a0 ff		ldy #$ff			ldy 	#$FF 						; get length of new string
.95e4					_ASGetLength:
.95e4	c8		iny				iny
.95e5	b1 38		lda ($38),y			lda 	(zTemp1),y
.95e7	d0 fb		bne $95e4			bne 	_ASGetLength
.95e9	98		tya				tya 								; is this length <= current length
.95ea	d2 3c		cmp ($3c)			cmp 	(zsTemp)
.95ec	90 20		bcc $960e			bcc 	_ASCopyString
.95ee	f0 1e		beq $960e			beq 	_ASCopyString
.95f0	a9 80		lda #$80			lda 	#$80 						; mark as unused.
.95f2	a0 01		ldy #$01			ldy 	#1
.95f4	91 3c		sta ($3c),y			sta 	(zsTemp),y
.95f6					_ASNewStringRequired:
.95f6	e8		inx				inx 								; concrete the new string.
.95f7	20 e3 a6	jsr $a6e3			jsr 	StringConcrete				; (breaks zTemp1/2, not zTemp0 and zsTemp)
.95fa	ca		dex				dex
.95fb	18		clc				clc
.95fc	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; copy that new address to the reference.
.95ff	69 02		adc #$02			adc 	#2 							; add two to point at the data.
.9601	92 36		sta ($36)			sta 	(zTemp0)
.9603	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.9606	69 00		adc #$00			adc 	#0
.9608	a0 01		ldy #$01			ldy 	#1
.960a	91 36		sta ($36),y			sta 	(zTemp0),y
.960c	80 0d		bra $961b			bra 	_ASExit
.960e					_ASCopyString:
.960e	a0 00		ldy #$00			ldy 	#0
.9610					_ASCopyLoop:
.9610	b1 38		lda ($38),y			lda 	(zTemp1),y
.9612	c8		iny				iny
.9613	c8		iny				iny
.9614	91 3c		sta ($3c),y			sta 	(zsTemp),y
.9616	88		dey				dey
.9617	c9 00		cmp #$00			cmp 	#0
.9619	d0 f5		bne $9610			bne 	_ASCopyLoop
.961b					_ASExit:
.961b	7a		ply				ply
.961c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/dereference.asm

.961d					DereferenceTopTwo:
.961d	e8		inx				inx
.961e	20 22 96	jsr $9622			jsr 	Dereference 				; deref x+1
.9621	ca		dex				dex  								; falls through to deref x
.9622					Dereference:
.9622	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get the status byte
.9625	29 20		and #$20			and 	#NSBIsReference 			; shift sign bit to carry, reference to bit 7
.9627	f0 57		beq $9680			beq 	_DRFExit 					; not a reference
.9629	5a		phy				phy
.962a	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address to dereference into zTemp0
.962d	85 36		sta $36				sta 	zTemp0
.962f	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9632	85 37		sta $37				sta 	zTemp0+1
.9634	9e 10 04	stz $0410,x			stz 	NSMantissa1,x 				; clear second byte.
.9637	b2 36		lda ($36)			lda 	(zTemp0) 					; do the first byte
.9639	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.963c	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get status byte.
.963f	29 18		and #$18			and 	#NSBTypeMask 				; what type is it ?
.9641	c9 10		cmp #$10			cmp 	#NSTString 					; if string, dereference two
.9643	f0 0f		beq $9654			beq 	_DRFDereferenceTwo
.9645	c9 08		cmp #$08			cmp 	#NSTFloat 					; if float, do full dereference.
.9647	f0 39		beq $9682			beq 	_DRFFull
.9649	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be integer - how many bytes ?
.964c	29 03		and #$03			and 	#3
.964e	f0 32		beq $9682			beq 	_DRFFull 					; the whole word
.9650	c9 01		cmp #$01			cmp 	#1 							; is it 10 (e.g. 2 bytes)
.9652	f0 07		beq $965b			beq		_DRFClear23 				; no, one byte, clear 2 & 3 and exit
.9654					_DRFDereferenceTwo:
.9654	a0 01		ldy #$01			ldy 	#1
.9656	b1 36		lda ($36),y			lda 	(zTemp0),y
.9658	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.965b					_DRFClear23:
.965b	9e 18 04	stz $0418,x			stz 	NSMantissa2,x 				; clear upper bytes, only read 1 or 2 bytes
.965e	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.9661	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; make it a value of that type.
.9664	29 18		and #$18			and 	#NSBTypeMask
.9666	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9669	c9 10		cmp #$10			cmp 	#NSTString  				; is it a string
.966b	d0 12		bne $967f			bne 	_DRFNotString
.966d	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; check address is zero
.9670	1d 10 04	ora $0410,x			ora 	NSMantissa1,x
.9673	d0 0a		bne $967f			bne 	_DRFNotString
.9675	a9 81		lda #$81			lda 	#_DRFNullString & $FF 		; if so, return reference to ""
.9677	9d 08 04	sta $0408,x			sta 	NSMantissa0,X
.967a	a9 96		lda #$96			lda 	#_DRFNullString >> 8
.967c	9d 10 04	sta $0410,x			sta 	NSMantissa1,X
.967f					_DRFNotString
.967f	7a		ply				ply 								; restore Y and exit
.9680					_DRFExit:
.9680	60		rts				rts
.9681					_DRFNullString:
>9681	00						.byte 	0
.9682					_DRFFull:
.9682	a0 01		ldy #$01			ldy 	#1 							; get remaining 3 bytes.
.9684	b1 36		lda ($36),y			lda 	(zTemp0),y
.9686	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9689	c8		iny				iny
.968a	b1 36		lda ($36),y			lda 	(zTemp0),y
.968c	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.968f	c8		iny				iny
.9690	b1 36		lda ($36),y			lda 	(zTemp0),y
.9692	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9695	9e 28 04	stz $0428,x			stz 	NSExponent,x 				; clear exponent.
.9698	bd 00 04	lda $0400,x			lda		NSStatus,x 					; see if type is integer
.969b	29 18		and #$18			and 	#NSBTypeMask  				; type information only
.969d	9d 00 04	sta $0400,x			sta 	NSStatus,x 					; update it back.
.96a0	f0 06		beq $96a8			beq 	_DRFNoExponent
.96a2	c8		iny				iny 								; if not, read the exponent as well.
.96a3	b1 36		lda ($36),y			lda 	(zTemp0),y
.96a5	9d 28 04	sta $0428,x			sta 	NSExponent,x
.96a8					_DRFNoExponent:
.96a8	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; is the most significant bit set ?
.96ab	10 0d		bpl $96ba			bpl 	_DRFExit2 					; if not, then exit.
.96ad	29 7f		and #$7f			and 	#$7F 						; clear that bit.
.96af	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.96b2	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; set the sign flag
.96b5	09 80		ora #$80			ora 	#NSBIsNegative
.96b7	9d 00 04	sta $0400,x			sta 	NSStatus,x
.96ba					_DRFExit2:
.96ba	7a		ply				ply
.96bb	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/number.asm

=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.96bc					EncodeNumberStart:
.96bc	38		sec				sec
.96bd	80 01		bra $96c0			bra 	EncodeNumberContinue+1
.96bf					EncodeNumberContinue:
.96bf	18		clc				clc
.96c0					EncodeNumber:
.96c0	08		php				php 								; save reset.
.96c1	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.96c3	f0 12		beq $96d7			beq 	_ENIsOkay
.96c5	c9 30		cmp #$30			cmp 	#"0"
.96c7	90 04		bcc $96cd			bcc 	_ENBadNumber
.96c9	c9 3a		cmp #$3a			cmp 	#"9"+1
.96cb	90 0a		bcc $96d7			bcc 	_ENIsOkay
.96cd					_ENBadNumber:
.96cd	28		plp				plp 								; throw saved reset
.96ce	ad 85 04	lda $0485			lda 	EncodeState 				; decimal mode, construct final number
.96d1	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.96d3	f0 7e		beq $9753			beq 	_ENConstructFinal
.96d5					_ENFail:
.96d5	18		clc				clc 								; not allowed
.96d6	60		rts				rts
.96d7					_ENIsOkay:
.96d7	28		plp				plp 								; are we restarting
.96d8	90 15		bcc $96ef			bcc 	_ENNoRestart
.96da					_ENStartEncode:
.96da	c9 2e		cmp #$2e			cmp 	#'.'						; first is DP
.96dc	f0 0c		beq $96ea			beq 	_ENFirstDP
.96de	29 0f		and #$0f			and 	#15 						; put digit in mantissa
.96e0	20 1a 9e	jsr $9e1a			jsr 	NSMSetByte
.96e3	a9 01		lda #$01			lda 	#ESTA_Low
.96e5					_ENExitChange:
.96e5	8d 85 04	sta $0485			sta 	EncodeState 				; save new state
.96e8	38		sec				sec
.96e9	60		rts				rts
.96ea					_ENFirstDP:
.96ea	20 18 9e	jsr $9e18			jsr 	NSMSetZero 					; clear integer part
.96ed	80 3f		bra $972e			bra 	_ESTASwitchFloat			; go straight to float and exi
.96ef					_ENNoRestart:
.96ef	48		pha				pha 								; save on stack.
.96f0	ad 85 04	lda $0485			lda 	EncodeState 				; get current state
.96f3	c9 01		cmp #$01			cmp 	#ESTA_Low
.96f5	f0 09		beq $9700			beq  	_ESTALowState
.96f7	c9 02		cmp #$02			cmp 	#ESTA_High
.96f9	f0 29		beq $9724			beq 	_ESTAHighState
.96fb	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.96fd	f0 3b		beq $973a			beq 	_ESTADecimalState
>96ff	db						.byte 	$DB 						; causes a break in the emulator
.9700					_ESTALowState:
.9700	68		pla				pla 								; get value back
.9701	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.9703	f0 29		beq $972e			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.9705	29 0f		and #$0f			and 	#15 						; make digit
.9707	8d 86 04	sta $0486			sta 	DigitTemp 					; save it.
.970a	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.970d	0a		asl a				asl 	a
.970e	0a		asl a				asl 	a
.970f	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.9712	0a		asl a				asl 	a
.9713	6d 86 04	adc $0486			adc 	DigitTemp
.9716	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9719	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.971b	90 05		bcc $9722			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.971d	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.971f	8d 85 04	sta $0485			sta 	EncodeState
.9722					_ESTANoSwitch:
.9722	38		sec				sec
.9723	60		rts				rts
.9724					_ESTAHighState:
.9724	68		pla				pla 								; get value back
.9725	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.9727	f0 05		beq $972e			beq 	_ESTASwitchFloat
.9729	20 8d 97	jsr $978d			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.972c	38		sec				sec
.972d	60		rts				rts
.972e					_ESTASwitchFloat:
.972e	9c 87 04	stz $0487			stz 	DecimalCount
.9731	e8		inx				inx 								; zero the decimal additive.
.9732	20 18 9e	jsr $9e18			jsr 	NSMSetZero
.9735	ca		dex				dex
.9736	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.9738	80 ab		bra $96e5			bra 	_ENExitChange
.973a					_ESTADecimalState:
.973a	68		pla				pla 								; digit.
.973b	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 2nd decimal point.
.973d	f0 96		beq $96d5			beq 	_ENFail
.973f	e8		inx				inx 								; put digit into fractional part of X+1
.9740	20 8d 97	jsr $978d			jsr 	ESTAShiftDigitIntoMantissa
.9743	ca		dex				dex
.9744	ee 87 04	inc $0487			inc 	DecimalCount 				; bump the count of decimals
.9747	ad 87 04	lda $0487			lda 	DecimalCount
.974a	c9 0b		cmp #$0b			cmp 	#11
.974c	f0 02		beq $9750			beq 	_ESTADSFail
.974e	38		sec				sec
.974f	60		rts				rts
.9750					_ESTADSFail:
.9750	4c a7 9f	jmp $9fa7			jmp 	RangeError
.9753					_ENConstructFinal:
.9753	ad 87 04	lda $0487			lda 	DecimalCount 				; get decimal count
.9756	f0 33		beq $978b			beq 	_ENCFExit 					; no decimals
.9758	5a		phy				phy
.9759	0a		asl a				asl 	a 							; x 4 and CLC
.975a	0a		asl a				asl 	a
.975b	6d 87 04	adc $0487			adc 	DecimalCount
.975e	a8		tay				tay
.975f	b9 66 9f	lda $9f66,y			lda 	DecimalScalarTable-5,y 		; copy decimal scalar to X+2
.9762	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9765	b9 67 9f	lda $9f67,y			lda 	DecimalScalarTable-5+1,y
.9768	9d 12 04	sta $0412,x			sta 	NSMantissa1+2,x
.976b	b9 68 9f	lda $9f68,y			lda 	DecimalScalarTable-5+2,y
.976e	9d 1a 04	sta $041a,x			sta 	NSMantissa2+2,x
.9771	b9 69 9f	lda $9f69,y			lda 	DecimalScalarTable-5+3,y
.9774	9d 22 04	sta $0422,x			sta 	NSMantissa3+2,x
.9777	b9 6a 9f	lda $9f6a,y			lda 	DecimalScalarTable-5+4,y
.977a	9d 2a 04	sta $042a,x			sta 	NSExponent+2,x
.977d	a9 08		lda #$08			lda 	#NSTFloat
.977f	9d 02 04	sta $0402,x			sta 	NSStatus+2,x
.9782	7a		ply				ply
.9783	e8		inx				inx 								; multiply decimal const by decimal scalar
.9784	20 c4 94	jsr $94c4			jsr 	FloatMultiply
.9787	ca		dex				dex
.9788	20 51 93	jsr $9351			jsr 	FloatAdd 					; add to integer part.
.978b					_ENCFExit:
.978b	18		clc				clc 								; reject the digit.
.978c	60		rts				rts
.978d					ESTAShiftDigitIntoMantissa:
.978d	29 0f		and #$0f			and 	#15 						; save digit
.978f	48		pha				pha
.9790	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; push mantissa on stack
.9793	48		pha				pha
.9794	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9797	48		pha				pha
.9798	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.979b	48		pha				pha
.979c	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.979f	48		pha				pha
.97a0	20 2d 9e	jsr $9e2d			jsr 	NSMShiftLeft 				; x 2
.97a3	20 2d 9e	jsr $9e2d			jsr 	NSMShiftLeft 				; x 4
.97a6	18		clc				clc 								; pop mantissa and add
.97a7	68		pla				pla
.97a8	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.97ab	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.97ae	68		pla				pla
.97af	7d 10 04	adc $0410,x			adc 	NSMantissa1,x
.97b2	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.97b5	68		pla				pla
.97b6	7d 18 04	adc $0418,x			adc 	NSMantissa2,x
.97b9	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.97bc	68		pla				pla
.97bd	7d 20 04	adc $0420,x			adc 	NSMantissa3,x
.97c0	9d 20 04	sta $0420,x			sta 	NSMantissa3,x 				; x 5
.97c3	20 2d 9e	jsr $9e2d			jsr 	NSMShiftLeft 				; x 10
.97c6	68		pla				pla 								; add digit
.97c7	18		clc				clc
.97c8	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.97cb	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.97ce	90 0d		bcc $97dd			bcc 	_ESTASDExit
.97d0	fe 10 04	inc $0410,x			inc 	NSMantissa1,x
.97d3	d0 08		bne $97dd			bne 	_ESTASDExit
.97d5	fe 18 04	inc $0418,x			inc 	NSMantissa2,x
.97d8	d0 03		bne $97dd			bne 	_ESTASDExit
.97da	fe 20 04	inc $0420,x			inc 	NSMantissa3,x
.97dd					_ESTASDExit:
.97dd	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/term.asm

.97de					EvaluateTerm:
.97de	b1 30		lda ($30),y			lda 	(codePtr),y
.97e0	30 18		bmi $97fa			bmi 	_ETCheckUnary 				; unary function ? (text ones)
.97e2	c9 40		cmp #$40			cmp 	#$40 						; 40-7F => identifier reference
.97e4	b0 6f		bcs $9855			bcs 	_ETVariable
.97e6	c9 30		cmp #$30			cmp 	#'0' 						; is it a number
.97e8	90 6e		bcc $9858			bcc 	_ETPuncUnary 				; if not it might be a punctuation unary.
.97ea	c9 3a		cmp #$3a			cmp 	#'9'+1
.97ec	b0 6a		bcs $9858			bcs 	_ETPuncUnary
.97ee	20 bc 96	jsr $96bc			jsr 	EncodeNumberStart 			; can't fail as it's 0-9 !
.97f1					_ETNumber:
.97f1	c8		iny				iny 								; keep encoding until we have the numbers
.97f2	b1 30		lda ($30),y			lda 	(codePtr),y
.97f4	20 bf 96	jsr $96bf			jsr 	EncodeNumberContinue
.97f7	b0 f8		bcs $97f1			bcs 	_ETNumber 					; go back if accepted.
.97f9	60		rts				rts
.97fa					_ETCheckUnary:
.97fa	c9 ff		cmp #$ff			cmp 	#KWC_STRING 				; string token
.97fc	f0 41		beq $983f			beq 	_ETString
.97fe	c9 fe		cmp #$fe			cmp 	#KWC_HEXCONST 				; hex constant.
.9800	f0 12		beq $9814			beq 	_ETHexConstant
.9802	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; check it actually is a unary function
.9804	90 0b		bcc $9811			bcc 	_ETSyntaxError
.9806	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1
.9808	b0 07		bcs $9811			bcs 	_ETSyntaxError
.980a	da		phx				phx 								; push X on the stack
.980b	0a		asl a				asl 	a 							; put vector x 2 into X
.980c	aa		tax				tax
.980d	c8		iny				iny 								; consume unary function token
.980e	7c 02 8b	jmp ($8b02,x)			jmp 	(VectorSet0,x) 				; and do it.
.9811					_ETSyntaxError:
.9811	4c a2 9f	jmp $9fa2			jmp 	SyntaxError
.9814					_ETHexConstant:
.9814	c8		iny				iny 								; skip #
.9815	c8		iny				iny 								; skip count
.9816	20 18 9e	jsr $9e18			jsr 	NSMSetZero 					; clear result
.9819					_ETHLoop:
.9819	b1 30		lda ($30),y			lda 	(codePtr),y
.981b	c8		iny				iny 								; and consume
.981c	c9 00		cmp #$00			cmp 	#0 							; exit if zero
.981e	f0 1e		beq $983e			beq 	_ETHExit
.9820	48		pha				pha 								; save on stack.
.9821	20 2d 9e	jsr $9e2d			jsr 	NSMShiftLeft 				; x 2
.9824	20 2d 9e	jsr $9e2d			jsr 	NSMShiftLeft 				; x 4
.9827	20 2d 9e	jsr $9e2d			jsr 	NSMShiftLeft 				; x 8
.982a	20 2d 9e	jsr $9e2d			jsr 	NSMShiftLeft 				; x 16
.982d	68		pla				pla 								; ASCII
.982e	c9 41		cmp #$41			cmp 	#'A'
.9830	90 02		bcc $9834			bcc 	_ETHNotChar
.9832	e9 07		sbc #$07			sbc 	#7
.9834					_ETHNotChar:
.9834	29 0f		and #$0f			and 	#15 						; digit now
.9836	1d 08 04	ora $0408,x			ora 	NSMantissa0,x 				; put in LS Nibble
.9839	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.983c	80 db		bra $9819			bra 	_ETHLoop 					; go round.
.983e					_ETHExit:
.983e	60		rts				rts
.983f					_ETString:
.983f	c8		iny				iny 								; look at length
.9840	b1 30		lda ($30),y			lda 	(codePtr),y
.9842	48		pha				pha
.9843	c8		iny				iny 								; first character
.9844	20 10 a2	jsr $a210			jsr 	MemoryInline 				; put address of string at (code-Ptr),y on stack
.9847	68		pla				pla 								; restore count and save
.9848	85 36		sta $36				sta 	zTemp0
.984a	98		tya				tya 								; add length to Y to skip it.
.984b	18		clc				clc
.984c	65 36		adc $36				adc 	zTemp0
.984e	a8		tay				tay
.984f	a9 10		lda #$10			lda 	#NSTString 					; mark as string
.9851	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9854	60		rts				rts
.9855					_ETVariable:
.9855	4c af 98	jmp $98af			jmp 	VariableHandler
.9858					_ETPuncUnary:
.9858	c8		iny				iny 								; consume the unary character
.9859	c9 2d		cmp #$2d			cmp 	#KWD_MINUS 					; unary minus
.985b	f0 2d		beq $988a			beq 	_ETUnaryNegate
.985d	c9 10		cmp #$10			cmp 	#KWD_AT 					; @ reference -> constant
.985f	f0 39		beq $989a			beq 	_ETDereference
.9861	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; parenthesis
.9863	f0 43		beq $98a8			beq 	_ETParenthesis
.9865	64 36		stz $36				stz 	zTemp0 						; zTemp0 is the indirection level.
.9867	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; byte indirection (0) ?
.9869	f0 06		beq $9871			beq 	_ETIndirection
.986b	e6 36		inc $36				inc 	zTemp0
.986d	c9 21		cmp #$21			cmp 	#KWD_PLING					; word indirection (1) \
.986f	d0 a0		bne $9811			bne 	_ETSyntaxError
.9871					_ETIndirection:
.9871	a5 36		lda $36				lda 	zTemp0 						; push indirection amount (0-1) => (1-2) on the stack
.9873	1a		inc a				inc 	a
.9874	48		pha				pha
.9875	20 de 97	jsr $97de			jsr 	EvaluateTerm				; evaluate the term
.9878	20 22 96	jsr $9622			jsr 	Dereference 				; dereference it.
.987b	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a +ve integer.
.987e	d0 07		bne $9887			bne 	_ETTypeMismatch
.9880	68		pla				pla 								; indirection 1-2
.9881	09 20		ora #$20			ora 	#NSBIsReference 			; make it a reference.
.9883	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9886	60		rts				rts
.9887					_ETTypeMismatch:
.9887	4c ac 9f	jmp $9fac			jmp 	TypeError
.988a					_ETUnaryNegate:
.988a	20 de 97	jsr $97de			jsr 	EvaluateTerm				; evaluate the term
.988d	20 22 96	jsr $9622			jsr 	Dereference 				; dereference it.
.9890	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a number
.9893	29 10		and #$10			and 	#NSTString
.9895	d0 f0		bne $9887			bne 	_ETTypeMismatch
.9897	4c c4 9d	jmp $9dc4			jmp 	NSMNegate  					; just toggles the sign bit.
.989a					_ETDereference:
.989a	20 de 97	jsr $97de			jsr 	EvaluateTerm				; evaluate the term
.989d	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a reference
.98a0	29 20		and #$20			and 	#NSBIsReference
.98a2	f0 e3		beq $9887			beq 	_ETTypeMismatch
.98a4	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; make it an integer address
.98a7	60		rts				rts
.98a8					_ETParenthesis:
.98a8	20 04 93	jsr $9304			jsr 	EvaluateExpression 			; evaluate here, from lowest precedence
.98ab	20 3c 8d	jsr $8d3c			jsr 	CheckRightBracket 			; check for )
.98ae	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/variable.asm

.98af					VariableHandler:
.98af	b1 30		lda ($30),y			lda 	(codePtr),y
.98b1	18		clc				clc
.98b2	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.98b4	85 37		sta $37				sta 	zTemp0+1
.98b6	c8		iny				iny
.98b7	b1 30		lda ($30),y			lda 	(codePtr),y
.98b9	85 36		sta $36				sta 	zTemp0
.98bb	c8		iny				iny
.98bc	18		clc				clc									; copy variable address+3 to mantissa
.98bd	69 03		adc #$03			adc 	#3
.98bf	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.98c2	a5 37		lda $37				lda 	zTemp0+1
.98c4	69 00		adc #$00			adc 	#0
.98c6	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.98c9	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.98cc	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.98cf	9e 28 04	stz $0428,x			stz 	NSExponent,x
.98d2	5a		phy				phy
.98d3	a0 02		ldy #$02			ldy 	#2 							; read type
.98d5	b1 36		lda ($36),y			lda 	(zTemp0),y
.98d7	7a		ply				ply
.98d8	29 1c		and #$1c			and 	#NSBTypeMask+NSBIsArray 	; get type information
.98da	09 20		ora #$20			ora 	#NSBIsReference 			; make a reference.
.98dc	9d 00 04	sta $0400,x			sta 	NSStatus,x
.98df	29 04		and #$04			and 	#NSBIsArray
.98e1	d0 01		bne $98e4			bne 	_VHArray
.98e3	60		rts				rts
.98e4					_VHArray:
.98e4	e8		inx				inx
.98e5	20 99 9d	jsr $9d99			jsr 	Evaluate8BitInteger 		; get the 1st index.
.98e8	a9 ff		lda #$ff			lda 	#$FF 						; set Status of X+2 to a duff value so we know if we picked it up.
.98ea	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.98ed	b1 30		lda ($30),y			lda 	(codePtr),y
.98ef	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.98f1	d0 06		bne $98f9			bne 	_VHNoSecondIndex
.98f3	c8		iny				iny 								; skip the comma
.98f4	e8		inx				inx
.98f5	20 99 9d	jsr $9d99			jsr 	Evaluate8BitInteger 		; get the 2nd index.
.98f8	ca		dex				dex
.98f9					_VHNoSecondIndex:
.98f9	ca		dex				dex 								; set X back.
.98fa	20 3c 8d	jsr $8d3c			jsr 	CheckRightBracket 			; and check the right bracket.
.98fd	5a		phy				phy 								; save position
.98fe	a0 02		ldy #$02			ldy 	#2 							; check first index is not-zero, e.g. array defined
.9900	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9902	f0 6b		beq $996f			beq 	_VHBadIndex
.9904	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy record address to zaTemp
.9907	85 3e		sta $3e				sta 	zaTemp
.9909	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.990c	85 3f		sta $3f				sta 	zaTemp+1
.990e	a0 03		ldy #$03			ldy 	#3 							; get the second index - which is 0 if there is one index.
.9910	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9912	f0 02		beq $9916			beq 	_VHHas2Mask
.9914	a9 ff		lda #$ff			lda 	#$FF
.9916					_VHHas2Mask:
.9916	dd 02 04	cmp $0402,x			cmp 	NSStatus+2,x 				; so if they are the same there are the wrong number of indices
.9919	f0 54		beq $996f			beq 	_VHBadIndex
.991b	0a		asl a				asl 	a 							; carry will be set if a second index
.991c	90 09		bcc $9927			bcc 	_VHCheckFirstIndex
.991e	a0 03		ldy #$03			ldy 	#3 			 				; check the 2nd size >= 2nd index
.9920	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9922	dd 0a 04	cmp $040a,x			cmp 	NSMantissa0+2,x
.9925	90 48		bcc $996f			bcc 	_VHBadIndex
.9927					_VHCheckFirstIndex:
.9927	a0 02		ldy #$02			ldy 	#2 			 				; check the 2nd size >= 2nd index
.9929	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.992b	dd 09 04	cmp $0409,x			cmp 	NSMantissa0+1,x
.992e	90 3f		bcc $996f			bcc 	_VHBadIndex
.9930	64 36		stz $36				stz 	zTemp0 						; clear zTemp0 (if 1 index)
.9932	64 37		stz $37				stz 	zTemp0+1
.9934	bd 02 04	lda $0402,x			lda 	NSStatus+2,x 				; if only one index provided, don't need to multiply
.9937	30 0f		bmi $9948			bmi 	_VHNoMultiply
.9939	da		phx				phx
.993a	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; get 2nd index on stack
.993d	48		pha				pha
.993e	a0 02		ldy #$02			ldy 	#2 							; get 1st size in A
.9940	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9942	1a		inc a				inc 	a 							; add 1 for zero base
.9943	fa		plx				plx
.9944	20 ad 9d	jsr $9dad			jsr 	Multiply8x8 				; calculate -> Z0
.9947	fa		plx				plx
.9948					_VHNoMultiply:
.9948	18		clc				clc
.9949	a5 36		lda $36				lda 	zTemp0
.994b	7d 09 04	adc $0409,x			adc 	NSMantissa0+1,x
.994e	85 36		sta $36				sta 	zTemp0
.9950	a5 37		lda $37				lda 	zTemp0+1
.9952	69 00		adc #$00			adc 	#0
.9954	85 37		sta $37				sta 	zTemp0+1
.9956	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9959	20 f4 84	jsr $84f4			jsr 	ScaleByBaseType
.995c	18		clc				clc
.995d	b2 3e		lda ($3e)			lda 	(zaTemp)
.995f	65 36		adc $36				adc 	zTemp0
.9961	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9964	a0 01		ldy #$01			ldy 	#1
.9966	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9968	65 37		adc $37				adc 	zTemp0+1
.996a	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.996d	7a		ply				ply 								; restore position
.996e	60		rts				rts
.996f					_VHBadIndex:
.996f	a9 17		lda #$17		lda	#23
.9971	4c 55 8d	jmp $8d55		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/abs.asm

.9974					AbsUnary:
.9974	fa		plx				plx 								; restore stack pos
.9975	20 41 9d	jsr $9d41			jsr 	EvaluateNumber 				; get a float or int
.9978	20 3c 8d	jsr $8d3c			jsr 	CheckRightBracket
.997b	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; clear the sign bit
.997e	29 7f		and #$7f			and 	#$7F
.9980	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9983	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/alloc.asm

.9984					AllocUnary:
.9984	fa		plx				plx 								; restore stack pos
.9985	20 79 9d	jsr $9d79			jsr 	Evaluate16BitInteger		; get bytes required.
.9988	20 3c 8d	jsr $8d3c			jsr 	CheckRightBracket
.998b	da		phx				phx 								; save X/Y
.998c	5a		phy				phy
.998d	8a		txa				txa 								; copy X into Y
.998e	a8		tay				tay
.998f	b9 10 04	lda $0410,y			lda		NSMantissa1,y 				; get size
.9992	aa		tax				tax
.9993	b9 08 04	lda $0408,y			lda 	NSMantissa0,y
.9996	20 a3 99	jsr $99a3			jsr 	AllocateXABytes 			; allocate memory
.9999	99 08 04	sta $0408,y			sta 	NSMantissa0,y 				; write address out.
.999c	8a		txa				txa
.999d	99 10 04	sta $0410,y			sta 	NSMantissa1,y
.99a0	7a		ply				ply
.99a1	fa		plx				plx
.99a2	60		rts				rts
.99a3					AllocateXABytes:
.99a3	5a		phy				phy
.99a4	ac 8c 04	ldy $048c			ldy 	lowMemPtr 					; push current address on stack and to zTemp0
.99a7	84 36		sty $36				sty 	zTemp0
.99a9	5a		phy				phy
.99aa	ac 8d 04	ldy $048d			ldy 	lowMemPtr+1
.99ad	84 37		sty $37				sty 	zTemp0+1
.99af	5a		phy				phy
.99b0	18		clc				clc 								; add to low memory pointer
.99b1	6d 8c 04	adc $048c			adc 	lowMemPtr
.99b4	8d 8c 04	sta $048c			sta 	lowMemPtr
.99b7	8a		txa				txa
.99b8	6d 8d 04	adc $048d			adc 	lowMemPtr+1
.99bb	8d 8d 04	sta $048d			sta 	lowMemPtr+1
.99be	b0 2f		bcs $99ef			bcs 	CISSMemory
.99c0	20 e1 99	jsr $99e1			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.99c3					_ClearMemory:
.99c3	ad 8c 04	lda $048c			lda 	lowMemPtr 					; cleared all memory allocated
.99c6	c5 36		cmp $36				cmp 	zTemp0
.99c8	d0 07		bne $99d1			bne 	_CMClearNext
.99ca	ad 8d 04	lda $048d			lda 	lowMemPtr+1
.99cd	c5 37		cmp $37				cmp 	zTemp0+1
.99cf	f0 0c		beq $99dd			beq 	_CMExit
.99d1					_CMClearNext:
.99d1	a9 00		lda #$00			lda 	#0 							; clear byte, advance to next.
.99d3	92 36		sta ($36)			sta 	(zTemp0)
.99d5	e6 36		inc $36				inc 	zTemp0
.99d7	d0 ea		bne $99c3			bne 	_ClearMemory
.99d9	e6 37		inc $37				inc		zTemp0+1
.99db	80 e6		bra $99c3			bra 	_ClearMemory
.99dd					_CMExit:
.99dd	fa		plx				plx
.99de	68		pla				pla
.99df	7a		ply				ply
.99e0	60		rts				rts
.99e1					CheckIdentifierStringSpace:
.99e1	48		pha				pha
.99e2	ad 8d 04	lda $048d			lda 	lowMemPtr+1 				; get low memory pointer
.99e5	18		clc				clc
.99e6	69 02		adc #$02			adc 	#2 							; need at least 2 256 byte pages
.99e8	cd 8f 04	cmp $048f			cmp 	StringMemory+1 				; is it >= StringMemory
.99eb	b0 02		bcs $99ef			bcs 	CISSMemory
.99ed	68		pla				pla
.99ee	60		rts				rts
.99ef					CISSMemory:
.99ef	a9 06		lda #$06		lda	#6
.99f1	4c 55 8d	jmp $8d55		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/asc.asm

.99f4					AscUnary:
.99f4	fa		plx				plx 								; restore stack pos
.99f5	20 4c 9d	jsr $9d4c			jsr 	EvaluateString 				; get a string
.99f8	b2 36		lda ($36)			lda 	(zTemp0)					; get/return firs character
.99fa	20 1a 9e	jsr $9e1a			jsr 	NSMSetByte
.99fd	20 3c 8d	jsr $8d3c			jsr 	CheckRightBracket
.9a00	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/frac.asm

.9a01					FracUnary:
.9a01	fa		plx				plx 								; restore stack pos
.9a02	20 41 9d	jsr $9d41			jsr 	EvaluateNumber 				; get a float or int
.9a05	20 3c 8d	jsr $8d3c			jsr 	CheckRightBracket
.9a08	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9a0b	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9a0d	f0 04		beq $9a13			beq 	_IUZero
.9a0f	20 37 94	jsr $9437			jsr 	FloatFractionalPart
.9a12	60		rts				rts
.9a13					_IUZero:
.9a13	20 18 9e	jsr $9e18			jsr 	NSMSetZero
.9a16	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/int.asm

.9a17					IntUnary:
.9a17	fa		plx				plx 								; restore stack pos
.9a18	20 41 9d	jsr $9d41			jsr 	EvaluateNumber 				; get a float or int
.9a1b	20 3c 8d	jsr $8d3c			jsr 	CheckRightBracket
.9a1e	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9a21	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9a23	f0 03		beq $9a28			beq 	_IUExit
.9a25	20 9a 94	jsr $949a			jsr 	FloatIntegerPart
.9a28					_IUExit:
.9a28	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/len.asm

.9a29					LenUnary:
.9a29	fa		plx				plx 								; restore stack pos
.9a2a	20 4c 9d	jsr $9d4c			jsr 	EvaluateString 				; get a string
.9a2d	5a		phy				phy
.9a2e	a0 00		ldy #$00			ldy 	#0 							; find length
.9a30					_LenFind:
.9a30	b1 36		lda ($36),y			lda 	(zTemp0),y
.9a32	f0 06		beq $9a3a			beq 	_LenExit
.9a34	c8		iny				iny
.9a35	d0 f9		bne $9a30			bne 	_LenFind
.9a37	4c a7 9f	jmp $9fa7			jmp 	RangeError 					; string > 255
.9a3a					_LenExit:
.9a3a	98		tya				tya
.9a3b	20 1a 9e	jsr $9e1a			jsr 	NSMSetByte
.9a3e	7a		ply				ply
.9a3f	20 3c 8d	jsr $8d3c			jsr 	CheckRightBracket
.9a42	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/minmax.asm

.9a43					Unary_Min:
.9a43	a9 01		lda #$01			lda 	#1
.9a45	80 02		bra $9a49			bra 	UnaryMinMaxMain
.9a47					Unary_Max:
.9a47	a9 ff		lda #$ff			lda 	#$FF 						; value from comparator to cause a write
.9a49					UnaryMinMaxMain:
.9a49	fa		plx				plx 								; get index on number stack
.9a4a	48		pha				pha 								; save comparator
.9a4b	20 38 9d	jsr $9d38			jsr 	EvaluateValue 				; get the first value.
.9a4e					_UMMMLoop:
.9a4e	b1 30		lda ($30),y			lda 	(codePtr),y
.9a50	c9 29		cmp #$29			cmp 	#KWD_RPAREN 				; if right bracket then done.
.9a52	f0 22		beq $9a76			beq 	_UMMMDone
.9a54	20 44 8d	jsr $8d44			jsr 	CheckComma 					; must be a comma
.9a57	e8		inx				inx
.9a58	20 38 9d	jsr $9d38			jsr 	EvaluateValue
.9a5b	ca		dex				dex
.9a5c	20 ef 9d	jsr $9def			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] (Compare is destructive)
.9a5f	e8		inx				inx
.9a60	20 ef 9d	jsr $9def			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2], original
.9a63	e8		inx				inx
.9a64	20 0d 8e	jsr $8e0d			jsr 	CompareBaseCode 			; part of > = < etc. code, returns 255,0 or 1
.9a67	ca		dex				dex
.9a68	ca		dex				dex
.9a69	85 36		sta $36				sta 	zTemp0 						; save required result
.9a6b	68		pla				pla 								; get and save comparator
.9a6c	48		pha				pha
.9a6d	c5 36		cmp $36				cmp 	zTemp0 						; if the comparator
.9a6f	d0 dd		bne $9a4e			bne 	_UMMMLoop
.9a71	20 79 9a	jsr $9a79			jsr 	ExpCopyAboveDown 			; copy next up slot down
.9a74	80 d8		bra $9a4e			bra 	_UMMMLoop
.9a76					_UMMMDone:
.9a76	68		pla				pla 								; throw the comparator
.9a77	c8		iny				iny 								; skip )
.9a78	60		rts				rts
.9a79					ExpCopyAboveDown:
.9a79	bd 01 04	lda $0401,x			lda 	NSStatus+1,x
.9a7c	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9a7f	bd 29 04	lda $0429,x			lda 	NSExponent+1,x
.9a82	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9a85	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.9a88	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9a8b	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.9a8e	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9a91	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.9a94	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9a97	bd 21 04	lda $0421,x			lda 	NSMantissa3+1,x
.9a9a	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9a9d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/not.asm

.9a9e					Unary_Not:
.9a9e	fa		plx				plx
.9a9f	20 64 9d	jsr $9d64			jsr 	EvaluateInteger 			; get integer
.9aa2	20 3c 8d	jsr $8d3c			jsr 	CheckRightBracket
.9aa5	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; zero mantissa ?
.9aa8	f0 04		beq $9aae			beq 	_NotZero
.9aaa	20 18 9e	jsr $9e18			jsr 	NSMSetZero
.9aad	60		rts				rts
.9aae					_NotZero:
.9aae	4c c2 8d	jmp $8dc2			jmp 	ReturnTrue
.9ab1					_UNBad:
.9ab1	4c b1 9f	jmp $9fb1			jmp 	ArgumentError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/rnd.asm

.9ab4					Unary_Random:
.9ab4	fa		plx				plx
.9ab5	20 33 9b	jsr $9b33			jsr 	Random32Bit 				; get a random number
.9ab8	20 18 9b	jsr $9b18			jsr 	URCopyToMantissa  			; put in mantissa
.9abb	b1 30		lda ($30),y			lda 	(codePtr),y
.9abd	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.9abf	f0 08		beq $9ac9			beq 	_URNoModulus
.9ac1	e8		inx				inx
.9ac2	20 79 9d	jsr $9d79			jsr 	Evaluate16BitInteger 		; put modulus value in +1
.9ac5	ca		dex				dex
.9ac6	20 31 8f	jsr $8f31			jsr 	IntegerModulusNoCheck 		; calculate modulus
.9ac9					_URNoModulus:
.9ac9	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; make it an integer positive
.9acc	9e 28 04	stz $0428,x			stz 	NSExponent,x
.9acf	20 3c 8d	jsr $8d3c			jsr 	CheckRightBracket
.9ad2	60		rts				rts
.9ad3					Unary_Rnd:
.9ad3	fa		plx				plx
.9ad4	20 41 9d	jsr $9d41			jsr 	EvaluateNumber 				; number to use.
.9ad7	20 3c 8d	jsr $8d3c			jsr 	CheckRightBracket 			; closing bracket
.9ada	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; if zero, then don't generate a new number
.9add	f0 2b		beq $9b0a			beq 	_URCopySeed
.9adf	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; if -ve, then seed using parameter
.9ae2	10 23		bpl $9b07			bpl 	_URDontSeed
.9ae4	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy - value to seed butchering it.
.9ae7	49 17		eor #$17			eor 	#$17
.9ae9	8d 88 04	sta $0488			sta 	RandomSeed+0
.9aec	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9aef	49 a5		eor #$a5			eor 	#$A5
.9af1	8d 89 04	sta $0489			sta 	RandomSeed+1
.9af4	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9af7	49 c2		eor #$c2			eor 	#$C2
.9af9	8d 8a 04	sta $048a			sta 	RandomSeed+2
.9afc	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9aff	49 9d		eor #$9d			eor 	#$9D
.9b01	8d 8b 04	sta $048b			sta 	RandomSeed+3
.9b04	20 33 9b	jsr $9b33			jsr 	Random32Bit
.9b07					_URDontSeed:
.9b07	20 33 9b	jsr $9b33			jsr 	Random32Bit 				; generate a number.
.9b0a					_URCopySeed:
.9b0a	20 18 9b	jsr $9b18			jsr 	URCopyToMantissa 			; copy into mantissa
.9b0d	a9 e1		lda #$e1			lda 	#-31 						; force into 0-1 range
.9b0f	8d 28 04	sta $0428			sta 	NSExponent
.9b12	a9 08		lda #$08			lda 	#NSTFloat
.9b14	8d 00 04	sta $0400			sta 	NSStatus 					; positive.
.9b17	60		rts				rts
.9b18					URCopyToMantissa:
.9b18	ad 88 04	lda $0488			lda 	RandomSeed+0
.9b1b	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9b1e	ad 89 04	lda $0489			lda 	RandomSeed+1
.9b21	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9b24	ad 8a 04	lda $048a			lda 	RandomSeed+2
.9b27	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9b2a	ad 8b 04	lda $048b			lda 	RandomSeed+3
.9b2d	29 3f		and #$3f			and 	#$3F 						; make legal mantissa
.9b2f	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9b32	60		rts				rts
.9b33					Random32Bit:
.9b33	5a		phy				phy
.9b34	a0 07		ldy #$07			ldy 	#7 							; do it 7 times
.9b36	ad 88 04	lda $0488			lda 	RandomSeed+0 				; check the seed isn't zero
.9b39	d0 03		bne $9b3e			bne 	_Random1
.9b3b	a8		tay				tay 								; if so do it 256 times
.9b3c	a9 aa		lda #$aa			lda		#$AA 						; and use this to seed the seed....
.9b3e					_Random1:
.9b3e	0a		asl a				asl 	a 							; LSFR RNG
.9b3f	2e 89 04	rol $0489			rol 	RandomSeed+1
.9b42	2e 8a 04	rol $048a			rol 	RandomSeed+2
.9b45	2e 8b 04	rol $048b			rol 	RandomSeed+3
.9b48	90 02		bcc $9b4c			bcc 	_Random2
.9b4a	49 c5		eor #$c5			eor 	#$C5
.9b4c					_Random2:
.9b4c	88		dey				dey
.9b4d	d0 ef		bne $9b3e			bne 	_Random1
.9b4f	8d 88 04	sta $0488			sta 	RandomSeed+0
.9b52	7a		ply				ply
.9b53	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/sgn.asm

.9b54					SgnUnary:
.9b54	fa		plx				plx 								; restore stack pos
.9b55	20 41 9d	jsr $9d41			jsr 	EvaluateNumber 				; get a float or int
.9b58	20 3c 8d	jsr $8d3c			jsr 	CheckRightBracket
.9b5b	20 48 9e	jsr $9e48			jsr 	NSMIsZero 					; if zero
.9b5e	f0 10		beq $9b70			beq 	_SGZero  					; return Int Zero
.9b60	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get status w/sign
.9b63	48		pha				pha
.9b64	a9 01		lda #$01			lda 	#1 							; set to 1
.9b66	20 1a 9e	jsr $9e1a			jsr 	NSMSetByte
.9b69	68		pla				pla
.9b6a	29 80		and #$80			and		#$80 						; copy the sign byte out
.9b6c	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9b6f	60		rts				rts
.9b70	20 18 9e	jsr $9e18	_SGZero:jsr 	NSMSetZero
.9b73	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/val.asm

.9b74					ValUnary:
.9b74	fa		plx				plx 								; restore stack pos
.9b75	20 8a 9b	jsr $9b8a			jsr 	ValMainCode 				; do the main val() code
.9b78	b0 01		bcs $9b7b			bcs 	_VUError 					; couldn't convert
.9b7a	60		rts				rts
.9b7b					_VUError:
.9b7b	4c ac 9f	jmp $9fac			jmp 	TypeError
.9b7e					IsValUnary:
.9b7e	fa		plx				plx 								; restore stack pos
.9b7f	20 8a 9b	jsr $9b8a			jsr 	ValMainCode 				; do the main val() code
.9b82	b0 03		bcs $9b87			bcs 	_VUBad
.9b84	4c c2 8d	jmp $8dc2			jmp 	ReturnTrue
.9b87					_VUBad:
.9b87	4c ce 8d	jmp $8dce			jmp 	ReturnFalse
.9b8a					ValMainCode:
.9b8a	20 4c 9d	jsr $9d4c			jsr 	EvaluateString 				; get a string
.9b8d	20 3c 8d	jsr $8d3c			jsr 	CheckRightBracket 			; check right bracket present
.9b90	5a		phy				phy
.9b91	b2 36		lda ($36)			lda 	(zTemp0) 					; check not empty string
.9b93	f0 17		beq $9bac			beq 	_VMCFail2
.9b95	a0 ff		ldy #$ff			ldy 	#$FF 						; start position
.9b97	48		pha				pha 								; save first character
.9b98	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it -
.9b9a	d0 01		bne $9b9d			bne 	_VMCStart
.9b9c	c8		iny				iny 								; skip over -
.9b9d					_VMCStart:
.9b9d	38		sec				sec 								; initialise first time round.
.9b9e					_VMCNext:
.9b9e	c8		iny				iny 								; pre-increment
.9b9f	b1 36		lda ($36),y			lda 	(zTemp0),y 					; next character
.9ba1	f0 0c		beq $9baf			beq 	_VMCSuccess 				; successful.
.9ba3	20 c0 96	jsr $96c0			jsr 	EncodeNumber 				; send it to the number-builder
.9ba6	90 03		bcc $9bab			bcc 	_VMCFail 					; if failed, give up.
.9ba8	18		clc				clc 								; next time round, countinue
.9ba9	80 f3		bra $9b9e			bra 	_VMCNext
.9bab					_VMCFail:
.9bab	68		pla				pla
.9bac					_VMCFail2:
.9bac	7a		ply				ply
.9bad	38		sec				sec
.9bae	60		rts				rts
.9baf					_VMCSuccess:
.9baf	a9 00		lda #$00			lda 	#0 							; construct final
.9bb1	20 c0 96	jsr $96c0			jsr 	EncodeNumber
.9bb4	68		pla				pla
.9bb5	c9 2d		cmp #$2d			cmp 	#"-"
.9bb7	d0 03		bne $9bbc			bne 	_VMCNotNegative
.9bb9	20 c4 9d	jsr $9dc4			jsr		NSMNegate
.9bbc					_VMCNotNegative:
.9bbc	7a		ply				ply
.9bbd	18		clc				clc
.9bbe	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/chr.asm

.9bbf					ChrUnary:
.9bbf	fa		plx				plx 								; restore stack pos
.9bc0	20 99 9d	jsr $9d99			jsr 	Evaluate8BitInteger			; get value
.9bc3	48		pha				pha
.9bc4	20 3c 8d	jsr $8d3c			jsr 	CheckRightBracket
.9bc7	a9 01		lda #$01			lda 	#1 							; allocate space for one char
.9bc9	20 64 a7	jsr $a764			jsr 	StringTempAllocate
.9bcc	68		pla				pla 								; write number to it
.9bcd	20 a2 a7	jsr $a7a2			jsr 	StringTempWrite
.9bd0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/spc.asm

.9bd1					SpcUnary:
.9bd1	fa		plx				plx 								; restore stack pos
.9bd2	20 99 9d	jsr $9d99			jsr 	Evaluate8BitInteger			; get value
.9bd5	5a		phy				phy
.9bd6	48		pha				pha 								; save count
.9bd7	20 64 a7	jsr $a764			jsr 	StringTempAllocate
.9bda	7a		ply				ply 								; to do count in Y
.9bdb					_SpcLoop:
.9bdb	c0 00		cpy #$00			cpy 	#0
.9bdd	f0 08		beq $9be7			beq 	_SpcExit
.9bdf	a9 20		lda #$20			lda 	#32
.9be1	20 a2 a7	jsr $a7a2			jsr 	StringTempWrite
.9be4	88		dey				dey
.9be5	80 f4		bra $9bdb			bra 	_SPCLoop
.9be7					_SpcExit:
.9be7	7a		ply				ply
.9be8	20 3c 8d	jsr $8d3c			jsr 	CheckRightBracket
.9beb	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/str.asm

.9bec					Unary_Str:
.9bec	fa		plx				plx
.9bed	20 41 9d	jsr $9d41			jsr 	EvaluateNumber  			; get number
.9bf0	20 3c 8d	jsr $8d3c			jsr 	CheckRightBracket 			; closing bracket
.9bf3	a9 05		lda #$05			lda 	#5 							; maximum decimals, from Basic816
.9bf5	20 0e 9c	jsr $9c0e			jsr 	ConvertNumberToString 		; do the conversion.
.9bf8	a9 21		lda #$21			lda		#33 						; create buffer
.9bfa	20 64 a7	jsr $a764			jsr 	StringTempAllocate 			; allocate memory
.9bfd	da		phx				phx
.9bfe	a2 00		ldx #$00			ldx 	#0
.9c00					_USCopy:
.9c00	bd 1b 06	lda $061b,x			lda 	DecimalBuffer,x
.9c03	20 a2 a7	jsr $a7a2			jsr 	StringTempWrite
.9c06	e8		inx				inx
.9c07	bd 1b 06	lda $061b,x			lda 	DecimalBuffer,x
.9c0a	d0 f4		bne $9c00			bne 	_USCopy
.9c0c	fa		plx				plx
.9c0d	60		rts				rts
.9c0e					ConvertNumberToString:
.9c0e	5a		phy				phy 								; save code position
.9c0f	8d 94 04	sta $0494			sta 	DecimalPlaces	 			; save number of DPs.
.9c12	9c 95 04	stz $0495			stz 	dbOffset 					; offset into decimal buffer = start.
.9c15	bd 00 04	lda $0400,x			lda 	NSStatus,x  				; is it -ve.
.9c18	10 0a		bpl $9c24			bpl 	_CNTSNotNegative
.9c1a	29 7f		and #$7f			and 	#$7F 						; make +ve
.9c1c	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9c1f	a9 2d		lda #$2d			lda 	#"-"
.9c21	20 8a 9c	jsr $9c8a			jsr 	WriteDecimalBuffer
.9c24					_CNTSNotNegative:
.9c24	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if decimal
.9c27	f0 15		beq $9c3e			beq 	_CNTSNotFloat
.9c29	e8		inx				inx 								; round up
.9c2a	a9 01		lda #$01			lda 	#1
.9c2c	20 1a 9e	jsr $9e1a			jsr 	NSMSetByte
.9c2f	ca		dex				dex
.9c30	bd 28 04	lda $0428,x			lda		NSExponent,x
.9c33	9d 29 04	sta $0429,x			sta 	NSExponent+1,x
.9c36	a9 08		lda #$08			lda 	#NSTFloat
.9c38	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.9c3b	20 51 93	jsr $9351			jsr 	FloatAdd
.9c3e					_CNTSNotFloat:
.9c3e	20 6c 9c	jsr $9c6c			jsr 	MakePlusTwoString
.9c41	20 37 94	jsr $9437			jsr 	FloatFractionalPart 		; get the fractional part
.9c44	20 fb 94	jsr $94fb			jsr 	NSNormalise					; normalise , exit if zero
.9c47	f0 21		beq $9c6a			beq 	_CNTSExit
.9c49	a9 2e		lda #$2e			lda 	#"."
.9c4b	20 8a 9c	jsr $9c8a			jsr 	WriteDecimalBuffer 			; write decimal place
.9c4e					_CNTSDecimal:
.9c4e	ce 94 04	dec $0494			dec 	DecimalPlaces 				; done all the decimals
.9c51	30 17		bmi $9c6a			bmi 	_CNTSExit
.9c53	e8		inx				inx 								; x 10.0
.9c54	a9 0a		lda #$0a			lda 	#10
.9c56	20 1a 9e	jsr $9e1a			jsr 	NSMSetByte
.9c59	a9 08		lda #$08			lda 	#NSTFloat
.9c5b	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9c5e	ca		dex				dex
.9c5f	20 c4 94	jsr $94c4			jsr 	FloatMultiply
.9c62	20 6c 9c	jsr $9c6c			jsr 	MakePlusTwoString
.9c65	20 37 94	jsr $9437			jsr 	FloatFractionalPart 		; get the fractional part
.9c68	80 e4		bra $9c4e			bra 	_CNTSDecimal 				; keep going.
.9c6a					_CNTSExit:
.9c6a	7a		ply				ply
.9c6b	60		rts				rts
.9c6c					MakePlusTwoString:
.9c6c	da		phx				phx
.9c6d	20 ef 9d	jsr $9def			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.9c70	e8		inx				inx 								; access it
.9c71	e8		inx				inx
.9c72	20 9a 94	jsr $949a			jsr 	FloatIntegerPart 			; make it an integer
.9c75	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.9c77	20 7c 92	jsr $927c			jsr 	ConvertInt32
.9c7a	a2 00		ldx #$00			ldx	 	#0
.9c7c					_MPTSCopy:
.9c7c	bd f9 05	lda $05f9,x			lda 	NumberBuffer,x
.9c7f	20 8a 9c	jsr $9c8a			jsr 	WriteDecimalBuffer
.9c82	e8		inx				inx
.9c83	bd f9 05	lda $05f9,x			lda 	NumberBuffer,x
.9c86	d0 f4		bne $9c7c			bne 	_MPTSCopy
.9c88	fa		plx				plx
.9c89	60		rts				rts
.9c8a					WriteDecimalBuffer:
.9c8a	da		phx				phx
.9c8b	ae 95 04	ldx $0495			ldx 	dbOffset
.9c8e	9d 1b 06	sta $061b,x			sta 	DecimalBuffer,x
.9c91	9e 1c 06	stz $061c,x			stz 	DecimalBuffer+1,x
.9c94	ee 95 04	inc $0495			inc 	dbOffset
.9c97	fa		plx				plx
.9c98	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/substring.asm

.9c99					Unary_Left:
.9c99	fa		plx				plx
.9c9a	18		clc				clc 								; only one parameter
.9c9b	20 10 9d	jsr $9d10			jsr 	SubstringInitial 			; set up.
.9c9e	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; Param #1 is the length
.9ca1	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9ca4	9e 09 04	stz $0409,x			stz 	NSMantissa0+1,x 			; Start is zero.
.9ca7	80 2c		bra $9cd5			bra 	SubstringMain
.9ca9					Unary_Right:
.9ca9	fa		plx				plx
.9caa	18		clc				clc 								; only one parameter
.9cab	20 10 9d	jsr $9d10			jsr 	SubstringInitial 			; set up.
.9cae	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; length => param 2
.9cb1	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9cb4	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; total length
.9cb7	fd 09 04	sbc $0409,x			sbc 	NSMantissa0+1,x 			; length - required.
.9cba	b0 02		bcs $9cbe			bcs 	_URNotUnderflow
.9cbc	a9 00		lda #$00			lda 	#0 							; start from the beginning, as something like right$("AB",3)
.9cbe					_URNotUnderFlow:
.9cbe	9d 09 04	sta $0409,x			sta 	NSMantissa0+1,x 			; this is the start position
.9cc1	80 12		bra $9cd5			bra 	SubStringMain
.9cc3					Unary_Mid:
.9cc3	fa		plx				plx
.9cc4	38		sec				sec 								; two parameters
.9cc5	20 10 9d	jsr $9d10			jsr 	SubstringInitial 			; set up.
.9cc8	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; first parameter is zero ?
.9ccb	f0 05		beq $9cd2			beq 	_UMError
.9ccd	de 09 04	dec $0409,x			dec 	NSMantissa0+1,x				; reduce initial offset by 1 as MID$(a$,1..) is actually the first character
.9cd0	80 03		bra $9cd5			bra 	SubStringMain
.9cd2					_UMError:
.9cd2	4c b1 9f	jmp $9fb1			jmp 	ArgumentError
.9cd5					SubStringMain:
.9cd5	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; is the initial offset >= the length
.9cd8	dd 28 04	cmp $0428,x			cmp 	NSExponent,x
.9cdb	b0 2d		bcs $9d0a			bcs 	_SSMNull 					; if so, return an empty string.
.9cdd	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; if copy count is zero
.9ce0	f0 28		beq $9d0a			beq 	_SSMNull 					; return empty string.
.9ce2	18		clc				clc 								; add the offset +1 to the address and
.9ce3	bd 08 04	lda $0408,x			lda	 	NSMantissa0,x 				; put in zTemp
.9ce6	7d 09 04	adc $0409,x			adc 	NSMantissa0+1,x
.9ce9	85 36		sta $36				sta 	zTemp0
.9ceb	bd 10 04	lda $0410,x			lda	 	NSMantissa1,x
.9cee	69 00		adc #$00			adc 	#0
.9cf0	85 37		sta $37				sta 	zTemp0+1
.9cf2					_SSMNoCarry:
.9cf2	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; characters required.
.9cf5	20 64 a7	jsr $a764			jsr 	StringTempAllocate 			; allocate that many characters
.9cf8	5a		phy				phy 								; save Y
.9cf9	a0 00		ldy #$00			ldy 	#0 							; start copying in.
.9cfb					_SSMCopy:
.9cfb	b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next character
.9cfd	f0 09		beq $9d08			beq 	_SSMEString 				; no more to copy
.9cff	20 a2 a7	jsr $a7a2			jsr 	StringTempWrite 			; and write it out.
.9d02	c8		iny				iny
.9d03	de 0a 04	dec $040a,x			dec 	NSMantissa0+2,x
.9d06	d0 f3		bne $9cfb			bne 	_SSMCopy
.9d08					_SSMEString:
.9d08	7a		ply				ply
.9d09					_SSMExit:
.9d09	60		rts				rts
.9d0a					_SSMNull:
.9d0a	a9 00		lda #$00			lda 	#0
.9d0c	20 64 a7	jsr $a764			jsr 	StringTempAllocate
.9d0f	60		rts				rts
.9d10					SubstringInitial:
.9d10	da		phx				phx 								; save initial stack position
.9d11	08		php				php 								; save carry on stack indicating 2 parameters
.9d12	20 4c 9d	jsr $9d4c			jsr 	EvaluateString 				; get a string
.9d15	5a		phy				phy 								; calculate length to exponent.
.9d16	a0 ff		ldy #$ff			ldy 	#$FF
.9d18					_SIFindLength:
.9d18	c8		iny				iny
.9d19	b1 36		lda ($36),y			lda 	(zTemp0),y
.9d1b	d0 fb		bne $9d18			bne 	_SIFindLength
.9d1d	98		tya				tya
.9d1e	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9d21	7a		ply				ply
.9d22	e8		inx				inx
.9d23	20 44 8d	jsr $8d44			jsr 	CheckComma 					; comma next
.9d26	20 99 9d	jsr $9d99			jsr 	Evaluate8BitInteger 		; get next parameter
.9d29	28		plp				plp 								; is it the last parameter ?
.9d2a	90 07		bcc $9d33			bcc 	_SSIExit 					; if so, exit.
.9d2c	e8		inx				inx
.9d2d	20 44 8d	jsr $8d44			jsr 	CheckComma 					; comma next
.9d30	20 99 9d	jsr $9d99			jsr 	Evaluate8BitInteger 		; get last parameter
.9d33					_SSIExit:
.9d33	fa		plx				plx
.9d34	20 3c 8d	jsr $8d3c			jsr 	CheckRightBracket 			; check closing bracket
.9d37	60		rts				rts 								; exit

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/exprhelper.asm

.9d38					EvaluateValue:
.9d38	48		pha				pha
.9d39	20 04 93	jsr $9304			jsr		EvaluateExpression 			; expression
.9d3c	20 22 96	jsr $9622			jsr 	Dereference					; derefernce it
.9d3f	68		pla				pla
.9d40	60		rts				rts
.9d41					EvaluateNumber:
.9d41	20 38 9d	jsr $9d38			jsr 	EvaluateValue 				; get a value
.9d44	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if string.
.9d47	29 10		and #$10			and 	#NSBIsString
.9d49	d0 16		bne $9d61			bne 	HelperTypeError
.9d4b	60		rts				rts
.9d4c					EvaluateString:
.9d4c	20 38 9d	jsr $9d38			jsr 	EvaluateValue 				; get a value
.9d4f	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if string.
.9d52	29 10		and #$10			and 	#NSBIsString
.9d54	f0 0b		beq $9d61			beq 	HelperTypeError
.9d56					CopyAddressToTemp0:
.9d56	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address -> zTemp0
.9d59	85 36		sta $36				sta 	zTemp0
.9d5b	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9d5e	85 37		sta $37				sta 	zTemp0+1
.9d60	60		rts				rts
.9d61					HelperTypeError:
.9d61	4c ac 9f	jmp $9fac			jmp 	TypeError
.9d64					EvaluateInteger:
.9d64	20 41 9d	jsr $9d41			jsr 	EvaluateNumber
.9d67	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check exponent is zero
.9d6a	d0 0a		bne $9d76			bne 	HelperValueError 			; if not, it's a float.
.9d6c	60		rts				rts
.9d6d					EvaluateUnsignedInteger:
.9d6d	20 64 9d	jsr $9d64			jsr 	EvaluateInteger 			; check integer is +ve
.9d70	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9d73	30 01		bmi $9d76			bmi 	HelperValueError
.9d75	60		rts				rts
.9d76					HelperValueError:
.9d76	4c b1 9f	jmp $9fb1			jmp 	ArgumentError
.9d79					Evaluate16BitInteger:
.9d79	20 6d 9d	jsr $9d6d			jsr	 	EvaluateUnsignedInteger		; get integer
.9d7c	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9d7f	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9d82	d0 f2		bne $9d76			bne 	HelperValueError
.9d84	60		rts				rts
.9d85					Evaluate16BitIntegerSigned:
.9d85	20 64 9d	jsr $9d64			jsr	 	EvaluateInteger				; get integer
.9d88	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9d8b	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9d8e	d0 e6		bne $9d76			bne 	HelperValueError
.9d90	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; signed ?
.9d93	10 03		bpl $9d98			bpl 	_EISNotSigned
.9d95	20 cd 9d	jsr $9dcd			jsr 	NSMNegateMantissa
.9d98					_EISNotSigned:
.9d98	60		rts				rts
.9d99					Evaluate8BitInteger:
.9d99	20 6d 9d	jsr $9d6d			jsr	 	EvaluateUnsignedInteger 	; get an integer
.9d9c	d0 d8		bne $9d76			bne 	HelperValueError
.9d9e	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 1, 2 & 3 must be zero
.9da1	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9da4	1d 10 04	ora $0410,x			ora 	NSMantissa1,x
.9da7	d0 cd		bne $9d76			bne 	HelperValueError
.9da9	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9dac	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/mult8x8.asm

.9dad					Multiply8x8:
.9dad	4a		lsr a		  		lsr 	a  							; prime the carry bit for the loop
.9dae	85 36		sta $36			  	sta 	zTemp0
.9db0	86 37		stx $37				stx 	zTemp0+1
.9db2	a9 00		lda #$00			lda 	#0
.9db4	a2 08		ldx #$08			ldx 	#8
.9db6					_M88Loop:
.9db6	90 03		bcc $9dbb			bcc 	_M88NoAdd
.9db8	18		clc				clc
.9db9	65 37		adc $37				adc 	zTemp0+1
.9dbb					_M88NoAdd:
.9dbb	6a		ror a				ror 	a
.9dbc	66 36		ror $36				ror 	zTemp0  					; pull another bit out for the next iteration
.9dbe	ca		dex				dex         						; inc/dec don't modify carry; only shifts and adds do
.9dbf	d0 f5		bne $9db6			bne 	_M88Loop
.9dc1	85 37		sta $37				sta 	zTemp0+1 					; store high 8 bits.
.9dc3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/utility.asm

.9dc4					NSMNegate:
.9dc4	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9dc7	49 80		eor #$80			eor 	#NSBIsNegative
.9dc9	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9dcc	60		rts				rts
.9dcd					NSMNegateMantissa:
.9dcd	38		sec				sec
.9dce	a9 00		lda #$00			lda 	#0
.9dd0	fd 08 04	sbc $0408,x			sbc 	NSMantissa0,x
.9dd3	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9dd6	a9 00		lda #$00			lda 	#0
.9dd8	fd 10 04	sbc $0410,x			sbc 	NSMantissa1,x
.9ddb	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9dde	a9 00		lda #$00			lda 	#0
.9de0	fd 18 04	sbc $0418,x			sbc 	NSMantissa2,x
.9de3	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9de6	a9 00		lda #$00			lda 	#0
.9de8	fd 20 04	sbc $0420,x			sbc 	NSMantissa3,x
.9deb	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9dee	60		rts				rts
.9def					NSMShiftUpTwo:
.9def	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9df2	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9df5	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9df8	9d 12 04	sta $0412,x			sta 	NSMantissa1+2,x
.9dfb	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9dfe	9d 1a 04	sta $041a,x			sta 	NSMantissa2+2,x
.9e01	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9e04	9d 22 04	sta $0422,x			sta 	NSMantissa3+2,x
.9e07	bd 28 04	lda $0428,x			lda 	NSExponent,x
.9e0a	9d 2a 04	sta $042a,x			sta 	NSExponent+2,x
.9e0d	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9e10	9d 02 04	sta $0402,x			sta 	NSStatus+2,x
.9e13	60		rts				rts
.9e14					NSMSetZeroMantissaOnly:
.9e14	a9 00		lda #$00			lda 	#0
.9e16	80 08		bra $9e20			bra 	NSMSetMantissa
.9e18					NSMSetZero:
.9e18	a9 00		lda #$00			lda 	#0
.9e1a					NSMSetByte:
.9e1a	9e 28 04	stz $0428,x			stz 	NSExponent,x 				; zero exponent, as integer.
.9e1d	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; status zero (integer)
.9e20					NSMSetMantissa:
.9e20	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; mantissa
.9e23	9e 10 04	stz $0410,x			stz 	NSMantissa1,x
.9e26	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.9e29	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.9e2c	60		rts				rts
.9e2d					NSMShiftLeft:
.9e2d	18		clc				clc
.9e2e					NSMRotateLeft:
.9e2e	3e 08 04	rol $0408,x			rol 	NSMantissa0,x
.9e31	3e 10 04	rol $0410,x			rol		NSMantissa1,x
.9e34	3e 18 04	rol $0418,x			rol		NSMantissa2,x
.9e37	3e 20 04	rol $0420,x			rol		NSMantissa3,x
.9e3a	60		rts				rts
.9e3b					NSMShiftRight:
.9e3b	5e 20 04	lsr $0420,x			lsr 	NSMantissa3,x
.9e3e	7e 18 04	ror $0418,x			ror		NSMantissa2,x
.9e41	7e 10 04	ror $0410,x			ror		NSMantissa1,x
.9e44	7e 08 04	ror $0408,x			ror		NSMantissa0,x
.9e47	60		rts				rts
.9e48					NSMIsZero:
.9e48	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9e4b	1d 18 04	ora $0418,x			ora		NSMantissa2,x
.9e4e	1d 10 04	ora $0410,x			ora		NSMantissa1,x
.9e51	1d 08 04	ora $0408,x			ora		NSMantissa0,x
.9e54	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/asmcore.asm

.9e55					Assemble_ora:
.9e55	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9e58	01					.byte $01
.9e59					Assemble_and:
.9e59	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9e5c	21					.byte $21
.9e5d					Assemble_eor:
.9e5d	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9e60	41					.byte $41
.9e61					Assemble_adc:
.9e61	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9e64	61					.byte $61
.9e65					Assemble_sta:
.9e65	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9e68	81					.byte $81
.9e69					Assemble_lda:
.9e69	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9e6c	a1					.byte $a1
.9e6d					Assemble_cmp:
.9e6d	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9e70	c1					.byte $c1
.9e71					Assemble_sbc:
.9e71	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9e74	e1					.byte $e1
.9e75					Assemble_asl:
.9e75	20 72 80	jsr $8072		jsr	AssembleGroup2
>9e78	02					.byte $02
>9e79	75					.byte $75
.9e7a					Assemble_rol:
.9e7a	20 72 80	jsr $8072		jsr	AssembleGroup2
>9e7d	22					.byte $22
>9e7e	75					.byte $75
.9e7f					Assemble_lsr:
.9e7f	20 72 80	jsr $8072		jsr	AssembleGroup2
>9e82	42					.byte $42
>9e83	75					.byte $75
.9e84					Assemble_ror:
.9e84	20 72 80	jsr $8072		jsr	AssembleGroup2
>9e87	62					.byte $62
>9e88	75					.byte $75
.9e89					Assemble_stx:
.9e89	20 72 80	jsr $8072		jsr	AssembleGroup2
>9e8c	82					.byte $82
>9e8d	50					.byte $50
.9e8e					Assemble_ldx:
.9e8e	20 72 80	jsr $8072		jsr	AssembleGroup2
>9e91	a2					.byte $a2
>9e92	d0					.byte $d0
.9e93					Assemble_dec:
.9e93	20 72 80	jsr $8072		jsr	AssembleGroup2
>9e96	c2					.byte $c2
>9e97	55					.byte $55
.9e98					Assemble_inc:
.9e98	20 72 80	jsr $8072		jsr	AssembleGroup2
>9e9b	e2					.byte $e2
>9e9c	55					.byte $55
.9e9d					Assemble_stz:
.9e9d	20 72 80	jsr $8072		jsr	AssembleGroup2
>9ea0	60					.byte $60
>9ea1	44					.byte $44
.9ea2					Assemble_bit:
.9ea2	20 72 80	jsr $8072		jsr	AssembleGroup2
>9ea5	20					.byte $20
>9ea6	55					.byte $55
.9ea7					Assemble_sty:
.9ea7	20 72 80	jsr $8072		jsr	AssembleGroup2
>9eaa	80					.byte $80
>9eab	54					.byte $54
.9eac					Assemble_ldy:
.9eac	20 72 80	jsr $8072		jsr	AssembleGroup2
>9eaf	a0					.byte $a0
>9eb0	d5					.byte $d5
.9eb1					Assemble_cpy:
.9eb1	20 72 80	jsr $8072		jsr	AssembleGroup2
>9eb4	c0					.byte $c0
>9eb5	d4					.byte $d4
.9eb6					Assemble_cpx:
.9eb6	20 72 80	jsr $8072		jsr	AssembleGroup2
>9eb9	e0					.byte $e0
>9eba	d0					.byte $d0
.9ebb					Assemble_tsb:
.9ebb	20 72 80	jsr $8072		jsr	AssembleGroup2
>9ebe	00					.byte $00
>9ebf	50					.byte $50
.9ec0					Assemble_trb:
.9ec0	20 72 80	jsr $8072		jsr	AssembleGroup2
>9ec3	10					.byte $10
>9ec4	50					.byte $50
.9ec5					Assemble_jsr:
.9ec5	20 72 80	jsr $8072		jsr	AssembleGroup2
>9ec8	14					.byte $14
>9ec9	10					.byte $10
.9eca					Assemble_jmp:
.9eca	20 72 80	jsr $8072		jsr	AssembleGroup2
>9ecd	40					.byte $40
>9ece	10					.byte $10
.9ecf					Assemble_bpl:
.9ecf	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9ed2	10					.byte $10
.9ed3					Assemble_bmi:
.9ed3	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9ed6	30					.byte $30
.9ed7					Assemble_bvc:
.9ed7	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9eda	50					.byte $50
.9edb					Assemble_bvs:
.9edb	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9ede	70					.byte $70
.9edf					Assemble_bcc:
.9edf	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9ee2	90					.byte $90
.9ee3					Assemble_bcs:
.9ee3	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9ee6	b0					.byte $b0
.9ee7					Assemble_bne:
.9ee7	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9eea	d0					.byte $d0
.9eeb					Assemble_beq:
.9eeb	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9eee	f0					.byte $f0
.9eef					Assemble_bra:
.9eef	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9ef2	80					.byte $80
.9ef3					Assemble_brk:
.9ef3	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9ef6	00					.byte $00
.9ef7					Assemble_php:
.9ef7	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9efa	08					.byte $08
.9efb					Assemble_clc:
.9efb	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9efe	18					.byte $18
.9eff					Assemble_plp:
.9eff	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f02	28					.byte $28
.9f03					Assemble_sec:
.9f03	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f06	38					.byte $38
.9f07					Assemble_rti:
.9f07	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f0a	40					.byte $40
.9f0b					Assemble_pha:
.9f0b	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f0e	48					.byte $48
.9f0f					Assemble_cli:
.9f0f	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f12	58					.byte $58
.9f13					Assemble_phy:
.9f13	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f16	5a					.byte $5a
.9f17					Assemble_rts:
.9f17	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f1a	60					.byte $60
.9f1b					Assemble_pla:
.9f1b	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f1e	68					.byte $68
.9f1f					Assemble_sei:
.9f1f	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f22	78					.byte $78
.9f23					Assemble_ply:
.9f23	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f26	7a					.byte $7a
.9f27					Assemble_dey:
.9f27	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f2a	88					.byte $88
.9f2b					Assemble_txa:
.9f2b	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f2e	8a					.byte $8a
.9f2f					Assemble_tya:
.9f2f	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f32	98					.byte $98
.9f33					Assemble_txs:
.9f33	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f36	9a					.byte $9a
.9f37					Assemble_tay:
.9f37	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f3a	a8					.byte $a8
.9f3b					Assemble_tax:
.9f3b	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f3e	aa					.byte $aa
.9f3f					Assemble_clv:
.9f3f	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f42	b8					.byte $b8
.9f43					Assemble_tsx:
.9f43	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f46	ba					.byte $ba
.9f47					Assemble_iny:
.9f47	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f4a	c8					.byte $c8
.9f4b					Assemble_dex:
.9f4b	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f4e	ca					.byte $ca
.9f4f					Assemble_cld:
.9f4f	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f52	d8					.byte $d8
.9f53					Assemble_phx:
.9f53	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f56	da					.byte $da
.9f57					Assemble_stp:
.9f57	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f5a	db					.byte $db
.9f5b					Assemble_inx:
.9f5b	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f5e	e8					.byte $e8
.9f5f					Assemble_nop:
.9f5f	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f62	ea					.byte $ea
.9f63					Assemble_sed:
.9f63	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f66	f8					.byte $f8
.9f67					Assemble_plx:
.9f67	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f6a	fa					.byte $fa

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/constants.asm

.9f6b					DecimalScalarTable:
>9f6b	66 66 66 66				.dword $66666666 ; 0.1
>9f6f	de					.byte $de
>9f70	1f 85 eb 51				.dword $51eb851f ; 0.01
>9f74	db					.byte $db
>9f75	4c 37 89 41				.dword $4189374c ; 0.001
>9f79	d8					.byte $d8
>9f7a	ac 8b db 68				.dword $68db8bac ; 0.0001
>9f7e	d4					.byte $d4
>9f7f	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>9f83	d1					.byte $d1
>9f84	83 de 1b 43				.dword $431bde83 ; 1e-06
>9f88	ce					.byte $ce
>9f89	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>9f8d	ca					.byte $ca
>9f8e	89 3b e6 55				.dword $55e63b89 ; 1e-08
>9f92	c7					.byte $c7
>9f93	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>9f97	c4					.byte $c4
>9f98	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>9f9c	c0					.byte $c0
>9f9d	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>9fa1	bd					.byte $bd

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.asm

.9fa2					SyntaxError:
.9fa2	a9 02		lda #$02		lda	#2
.9fa4	4c 55 8d	jmp $8d55		jmp	ErrorHandler
.9fa7					RangeError:
.9fa7	a9 04		lda #$04		lda	#4
.9fa9	4c 55 8d	jmp $8d55		jmp	ErrorHandler
.9fac					TypeError:
.9fac	a9 05		lda #$05		lda	#5
.9fae	4c 55 8d	jmp $8d55		jmp	ErrorHandler
.9fb1					ArgumentError:
.9fb1	a9 07		lda #$07		lda	#7
.9fb3	4c 55 8d	jmp $8d55		jmp	ErrorHandler
.9fb6					NotDoneError:
.9fb6	a9 0c		lda #$0c		lda	#12
.9fb8	4c 55 8d	jmp $8d55		jmp	ErrorHandler
.9fbb					ErrorText:
>9fbb	42 72 65 61 6b 00			.text	"Break",0
>9fc1	53 79 6e 74 61 78 20 65			.text	"Syntax error",0
>9fc9	72 72 6f 72 00
>9fce	44 69 76 69 73 69 6f 6e			.text	"Division by zero",0
>9fd6	20 62 79 20 7a 65 72 6f 00
>9fdf	4f 75 74 20 6f 66 20 52			.text	"Out of Range",0
>9fe7	61 6e 67 65 00
>9fec	54 79 70 65 20 6d 69 73			.text	"Type mismatch",0
>9ff4	6d 61 74 63 68 00
>9ffa	4f 75 74 20 6f 66 20 6d			.text	"Out of memory",0
>a002	65 6d 6f 72 79 00
>a008	49 6c 6c 65 67 61 6c 20			.text	"Illegal argument",0
>a010	61 72 67 75 6d 65 6e 74 00
>a019	53 74 6f 70 00				.text	"Stop",0
>a01e	53 74 72 69 6e 67 20 74			.text	"String too long",0
>a026	6f 6f 20 6c 6f 6e 67 00
>a02e	41 73 73 65 72 74 69 6f			.text	"Assertion failed",0
>a036	6e 20 66 61 69 6c 65 64 00
>a03f	4f 75 74 20 6f 66 20 64			.text	"Out of data",0
>a047	61 74 61 00
>a04b	55 6e 69 6d 70 6c 65 6d			.text	"Unimplemented",0
>a053	65 6e 74 65 64 00
>a059	4e 6f 20 73 75 63 68 20			.text	"No such line number",0
>a061	6c 69 6e 65 20 6e 75 6d 62 65 72 00
>a06d	52 65 74 75 72 6e 20 77			.text	"Return without Gosub",0
>a075	69 74 68 6f 75 74 20 47 6f 73 75 62 00
>a082	55 6e 74 69 6c 20 77 69			.text	"Until without Repeat",0
>a08a	74 68 6f 75 74 20 52 65 70 65 61 74 00
>a097	57 65 6e 64 20 77 69 74			.text	"Wend without While",0
>a09f	68 6f 75 74 20 57 68 69 6c 65 00
>a0aa	4e 65 78 74 20 77 69 74			.text	"Next without For",0
>a0b2	68 6f 75 74 20 46 6f 72 00
>a0bb	42 41 53 49 43 20 53 74			.text	"BASIC Stack full",0
>a0c3	61 63 6b 20 66 75 6c 6c 00
>a0cc	4f 70 65 6e 20 53 74 72			.text	"Open Structure",0
>a0d4	75 63 74 75 72 65 00
>a0db	45 6e 64 50 72 6f 63 20			.text	"EndProc without call",0
>a0e3	77 69 74 68 6f 75 74 20 63 61 6c 6c 00
>a0f0	41 72 72 61 79 20 61 6c			.text	"Array already defined",0
>a0f8	72 65 61 64 79 20 64 65 66 69 6e 65 64 00
>a106	41 72 72 61 79 20 73 69			.text	"Array size",0
>a10e	7a 65 00
>a111	42 61 64 20 61 72 72 61			.text	"Bad array index",0
>a119	79 20 69 6e 64 65 78 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/timestamp.asm

>a121	42 75 69 6c 74 20 4d 6f			.text "Built Monday 21-Nov-2022. Build 3432."
>a129	6e 64 61 79 20 32 31 2d 4e 6f 76 2d 32 30 32 32
>a139	2e 20 42 75 69 6c 64 20 33 34 33 32 2e

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/delete.asm

.a146					MemoryDeleteLine:
.a146	20 65 a1	jsr $a165			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a149	b2 30		lda ($30)			lda 	(codePtr) 					; size to delete => y
.a14b	a8		tay				tay
.a14c					_MDDLLoop:
.a14c	b1 30		lda ($30),y			lda 	(codePtr),y 				; copy down
.a14e	92 30		sta ($30)			sta 	(codePtr)
.a150	a5 30		lda $30				lda 	codePtr 					; check done the lot.
.a152	c5 3a		cmp $3a				cmp 	zTemp2
.a154	d0 07		bne $a15d			bne 	_MDLDLNext
.a156	a5 31		lda $31				lda 	codePtr+1
.a158	c5 3b		cmp $3b				cmp 	zTemp2+1
.a15a	d0 01		bne $a15d			bne 	_MDLDLNext
.a15c					_MDDLExit:
.a15c	60		rts				rts
.a15d					_MDLDLNext:
.a15d	e6 30		inc $30				inc 	codePtr						; next byte
.a15f	d0 eb		bne $a14c			bne 	_MDDLLoop
.a161	e6 31		inc $31				inc 	codePtr+1
.a163	80 e7		bra $a14c			bra 	_MDDLLoop
.a165					IMemoryFindEnd:
.a165	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a167	85 3a		sta $3a				sta 	0+zTemp2
.a169	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a16b	85 3b		sta $3b				sta 	1+zTemp2
.a16d					_MDLFELoop:
.a16d	b2 3a		lda ($3a)			lda 	(zTemp2)
.a16f	f0 0b		beq $a17c			beq 	_MDLFEExit
.a171	18		clc				clc
.a172	65 3a		adc $3a				adc 	zTemp2
.a174	85 3a		sta $3a				sta 	zTemp2
.a176	90 f5		bcc $a16d			bcc 	_MDLFELoop
.a178	e6 3b		inc $3b				inc 	zTemp2+1
.a17a	80 f1		bra $a16d			bra 	_MDLFELoop
.a17c					_MDLFEExit:
.a17c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/insert.asm

.a17d					MemoryInsertLine:
.a17d	08		php				php
.a17e	20 65 a1	jsr $a165			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a181	a5 3b		lda $3b				lda 	zTemp2+1 					; space ?
.a183	1a		inc a				inc 	a
.a184	c9 7f		cmp #$7f			cmp 	#(BasicEnd >> 8)-1
.a186	b0 36		bcs $a1be			bcs 	_MDLIError
.a188	28		plp				plp
.a189	90 08		bcc $a193			bcc 	_MDLIFound
.a18b	a5 3a		lda $3a				lda 	zTemp2 						; if CS on entry append.
.a18d	85 30		sta $30				sta 	codePtr
.a18f	a5 3b		lda $3b				lda 	zTemp2+1
.a191	85 31		sta $31				sta 	codePtr+1
.a193					_MDLIFound:
.a193	ad a8 04	lda $04a8			lda 	tokenOffset 				; insert gap in Y, the offset, e.g. length of the new line
.a196	a8		tay				tay
.a197					_MDLIInsert:
.a197	b2 3a		lda ($3a)			lda 	(zTemp2) 					; shift one byte up , at least one covers end case.
.a199	91 3a		sta ($3a),y			sta 	(zTemp2),y 					; work from top down.
.a19b	a5 30		lda $30				lda 	codePtr 					; done insert point ?
.a19d	c5 3a		cmp $3a				cmp 	zTemp2
.a19f	d0 06		bne $a1a7			bne 	_MDLINext
.a1a1	a5 31		lda $31				lda 	codePtr+1
.a1a3	c5 3b		cmp $3b				cmp 	zTemp2+1
.a1a5	f0 0a		beq $a1b1			beq 	_MDLIHaveSpace
.a1a7					_MDLINext:
.a1a7	a5 3a		lda $3a				lda 	zTemp2 						; if no, keep zTemp2 going backwards
.a1a9	d0 02		bne $a1ad			bne 	_MDLINoBorrow
.a1ab	c6 3b		dec $3b				dec 	zTemp2+1
.a1ad					_MDLINoBorrow:
.a1ad	c6 3a		dec $3a				dec 	zTemp2
.a1af	80 e6		bra $a197			bra 	_MDLIInsert
.a1b1					_MDLIHaveSpace:
.a1b1	ac a8 04	ldy $04a8			ldy 	tokenOffset 				; bytes to copy
.a1b4	88		dey				dey 								; from offset-1 to 0
.a1b5					_MDLICopy:
.a1b5	b9 a8 04	lda $04a8,y			lda 	tokenOffset,y
.a1b8	91 30		sta ($30),y			sta 	(codePtr),y
.a1ba	88		dey				dey
.a1bb	10 f8		bpl $a1b5			bpl 	_MDLICopy
.a1bd	60		rts				rts
.a1be					_MDLIError:
.a1be	a9 06		lda #$06		lda	#6
.a1c0	4c 55 8d	jmp $8d55		jmp	ErrorHandler
.a1c3					MDLAppendLine:
.a1c3	86 37		stx $37				stx 	zTemp0+1 					; save new line at zTemp0
.a1c5	85 36		sta $36				sta 	zTemp0
.a1c7	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a1c9	85 38		sta $38				sta 	0+zTemp1
.a1cb	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a1cd	85 39		sta $39				sta 	1+zTemp1
.a1cf	b2 38		lda ($38)			lda 	(zTemp1)
.a1d1	d0 0a		bne $a1dd			bne 	_MDLANoInitialise
.a1d3	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a1d5	8d 2d 06	sta $062d			sta 	0+AppendPointer
.a1d8	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a1da	8d 2e 06	sta $062e			sta 	1+AppendPointer
.a1dd					_MDLANoInitialise:
.a1dd	18		clc				clc
.a1de	ad 2d 06	lda $062d			lda 	AppendPointer 				; copy append pointer to zTemp1 adding the offset as you go
.a1e1	85 38		sta $38				sta 	zTemp1
.a1e3	72 36		adc ($36)			adc 	(zTemp0)
.a1e5	8d 2d 06	sta $062d			sta 	AppendPointer
.a1e8	ad 2e 06	lda $062e			lda 	AppendPointer+1
.a1eb	85 39		sta $39				sta 	zTemp1+1
.a1ed	69 00		adc #$00			adc 	#0
.a1ef	8d 2e 06	sta $062e			sta 	AppendPointer+1
.a1f2	a0 00		ldy #$00			ldy 	#0
.a1f4					_MDLACopy:
.a1f4	b1 36		lda ($36),y			lda 	(zTemp0),y 					; copy new line in
.a1f6	91 38		sta ($38),y			sta 	(zTemp1),y
.a1f8	c8		iny				iny
.a1f9	98		tya				tya
.a1fa	d2 36		cmp ($36)			cmp 	(zTemp0) 					; done whole line
.a1fc	d0 f6		bne $a1f4			bne 	_MDLACopy
.a1fe	a9 00		lda #$00			lda 	#0 							; end of program.
.a200	91 38		sta ($38),y			sta 	(zTemp1),y
.a202	60		rts				rts
.062d					AppendPointer:
>062d							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/memory.asm

.a203					MemoryNew:
.a203	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a205	85 30		sta $30				sta 	codePtr
.a207	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a209	85 31		sta $31				sta 	codePtr+1
.a20b	a9 00		lda #$00			lda 	#0 							; write zero there erasing the program.
.a20d	92 30		sta ($30)			sta 	(codePtr)
.a20f	60		rts				rts
.a210					MemoryInline:
.a210	98		tya				tya 								; put address into stack,x
.a211	18		clc				clc
.a212	65 30		adc $30				adc 	codePtr
.a214	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.a217	a5 31		lda $31				lda 	codePtr+1
.a219	69 00		adc #$00			adc 	#0
.a21b	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a21e	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.a221	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.a224	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/search.asm

.a225					MemorySearch:
.a225	85 36		sta $36				sta 	zTemp0 						; save line number zTemp0
.a227	86 37		stx $37				stx 	zTemp0+1
.a229	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a22b	85 30		sta $30				sta 	codePtr
.a22d	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a22f	85 31		sta $31				sta 	codePtr+1
.a231					_MTAXLoop:
.a231	b2 30		lda ($30)			lda 	(codePtr)
.a233	18		clc				clc
.a234	f0 21		beq $a257			beq 	_MTAXExit 					; reached end, exit with CC.
.a236	a0 01		ldy #$01			ldy 	#1 							; calculate current line# - requested line#
.a238	b1 30		lda ($30),y			lda 	(codePtr),y
.a23a	38		sec				sec
.a23b	e5 36		sbc $36				sbc 	zTemp0
.a23d	85 38		sta $38				sta 	zTemp1 						; save interim to set Z
.a23f	c8		iny				iny 								; do the MSB
.a240	b1 30		lda ($30),y			lda 	(codePtr),y
.a242	e5 37		sbc $37				sbc 	zTemp0+1
.a244	05 38		ora $38				ora 	zTemp1
.a246	f0 0f		beq $a257			beq 	_MTAXExit	 				; found
.a248	b0 0d		bcs $a257			bcs 	_MTAXExit 					; current < required exit
.a24a	18		clc				clc
.a24b	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.a24d	65 30		adc $30				adc 	codePtr
.a24f	85 30		sta $30				sta 	codePtr
.a251	90 02		bcc $a255			bcc 	_CREExit
.a253	e6 31		inc $31				inc 	codePtr+1
.a255					_CREExit:
.a255	80 da		bra $a231			bra 	_MTAXLoop
.a257					_MTAXExit:
.a257	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/module.interface/graphics/gcommand.asm

.a258					RectangleCommand:
.a258	a9 44		lda #$44			lda 	#GCMD_FrameRect				; frame rectangle
.a25a	80 02		bra $a25e			bra 	ShapeDrawCmd
.a25c					CircleCommand:
.a25c	a9 48		lda #$48			lda 	#GCMD_FrameCircle 				; framed circle
.a25e					ShapeDrawCmd:
.a25e	20 ec a2	jsr $a2ec			jsr 	RunGraphicsCommand
.a261					ShapeDraw:
.a261	0d 30 06	ora $0630			ora 	gxFillSolid  				; adjust AXY for solid fill.
.a264	4c e0 a2	jmp $a2e0			jmp 	ExecuteGraphicCommand	 	; and complete
.a267					SpriteCommand:
.a267	a2 00		ldx #$00			ldx 	#0
.a269	20 99 9d	jsr $9d99			jsr 	Evaluate8BitInteger 		; get image number.
.a26c	5a		phy				phy
.a26d	a9 0e		lda #$0e			lda 	#GCMD_SpriteUse 			; use that image.
.a26f	ae 08 04	ldx $0408			ldx 	NSMantissa0
.a272	e0 40		cpx #$40			cpx 	#64 						; 0-63 only
.a274	b0 0d		bcs $a283			bcs 	_SCRange
.a276	a0 ff		ldy #$ff			ldy 	#255
.a278	20 9d aa	jsr $aa9d			jsr 	GXGraphicDraw
.a27b	a9 52		lda #$52			lda 	#GCMD_SpriteMove
.a27d	7a		ply				ply
.a27e	20 ec a2	jsr $a2ec			jsr 	RunGraphicsCommand
.a281	80 5d		bra $a2e0			bra 	ExecuteGraphicCommand
.a283					_SCRange:
.a283	4c a7 9f	jmp $9fa7			jmp 	RangeError
.a286					ImageCommand:
.a286	a2 00		ldx #$00			ldx 	#0
.a288	20 99 9d	jsr $9d99			jsr 	Evaluate8BitInteger 		; get image number.
.a28b	20 ec a2	jsr $a2ec			jsr 	RunGraphicsCommand
.a28e					ImageRunDraw:
.a28e	09 40		ora #$40			ora 	#GCMD_Move					; move cursor
.a290	20 9d aa	jsr $aa9d			jsr 	GXGraphicDraw
.a293	ad 36 06	lda $0636			lda 	gxDrawScale
.a296	0a		asl a				asl 	a
.a297	0a		asl a				asl 	a
.a298	0a		asl a				asl 	a
.a299	a8		tay				tay
.a29a	a9 0c		lda #$0c			lda 	#GCMD_DrawSprite 			; image drawing
.a29c	ae 08 04	ldx $0408			ldx 	NSMantissa0
.a29f	20 9d aa	jsr $aa9d			jsr 	GXGraphicDraw
.a2a2	60		rts				rts
.a2a3					TextCommand:
.a2a3	a2 00		ldx #$00			ldx 	#0
.a2a5	20 4c 9d	jsr $9d4c			jsr 	EvaluateString 				; get text
.a2a8	20 ec a2	jsr $a2ec			jsr 	RunGraphicsCommand
.a2ab					TextRunDraw:
.a2ab	09 40		ora #$40			ora 	#GCMD_Move 					; move cursor
.a2ad	20 9d aa	jsr $aa9d			jsr 	GXGraphicDraw
.a2b0	a0 00		ldy #$00			ldy 	#0
.a2b2					_IRDLoop:
.a2b2	ad 10 04	lda $0410			lda 	NSMantissa1 				; access character
.a2b5	85 37		sta $37				sta 	zTemp0+1
.a2b7	ad 08 04	lda $0408			lda 	NSMantissa0
.a2ba	85 36		sta $36				sta 	zTemp0
.a2bc	b1 36		lda ($36),y			lda 	(zTemp0),y
.a2be	f0 13		beq $a2d3			beq 	_IRDExit
.a2c0	5a		phy				phy									; save string pos
.a2c1	48		pha				pha 								; save char
.a2c2	ad 36 06	lda $0636			lda 	gxDrawScale 				; get scale
.a2c5	0a		asl a				asl 	a
.a2c6	0a		asl a				asl 	a
.a2c7	0a		asl a				asl 	a
.a2c8	a8		tay				tay
.a2c9	a9 0a		lda #$0a			lda 	#GCMD_DrawFont 				; char drawing
.a2cb	fa		plx				plx 								; char to draw
.a2cc	20 9d aa	jsr $aa9d			jsr 	GXGraphicDraw
.a2cf	7a		ply				ply 								; restore string pos
.a2d0	c8		iny				iny
.a2d1	90 df		bcc $a2b2			bcc 	_IRDLoop 					; go back if no error.
.a2d3					_IRDExit:
.a2d3	60		rts				rts
.a2d4					PlotCommand:
.a2d4	a9 50		lda #$50			lda 	#GCMD_Plot 					; command ID to use
.a2d6	20 ec a2	jsr $a2ec			jsr 	RunGraphicsCommand
.a2d9	80 05		bra $a2e0			bra 	ExecuteGraphicCommand
.a2db					LineCommand:
.a2db	a9 42		lda #$42			lda 	#GCMD_Line 						; command ID to use
.a2dd	20 ec a2	jsr $a2ec			jsr 	RunGraphicsCommand
.a2e0					ExecuteGraphicCommand:
.a2e0	0d 2f 06	ora $062f			ora 	gxCommandID 				; make a full command
.a2e3	20 9d aa	jsr $aa9d			jsr 	GXGraphicDraw 				; draw it and exit
.a2e6	b0 01		bcs $a2e9			bcs 	_EGCError
.a2e8	60		rts				rts
.a2e9					_EGCError:
.a2e9	4c a2 9f	jmp $9fa2			jmp 	SyntaxError
.a2ec					RunGraphicsCommand:
.a2ec	8d 2f 06	sta $062f			sta 	gxCommandID					; save TODO graphics command.
.a2ef	68		pla				pla 								; pop handler address
.a2f0	fa		plx				plx
.a2f1	1a		inc a				inc 	a
.a2f2	d0 01		bne $a2f5			bne 	_RGINoCarry
.a2f4	e8		inx				inx
.a2f5					_RGINoCarry:
.a2f5	8d 34 06	sta $0634			sta 	GXHandler
.a2f8	8e 35 06	stx $0635			stx 	GXHandler+1
.a2fb					_RGICommandLoop:
.a2fb	b1 30		lda ($30),y			lda 	(codePtr),y
.a2fd	c8		iny				iny
.a2fe	c9 cd		cmp #$cd			cmp 	#KWD_TO						; is it TO x,y
.a300	f0 53		beq $a355			beq 	_RGI_To
.a302	c9 ba		cmp #$ba			cmp 	#KWD_HERE 					; do it here.
.a304	f0 55		beq $a35b			beq 	_RGI_Here
.a306	c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL or : , exit
.a308	f0 3d		beq $a347			beq 	_RGI_Exit
.a30a	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.a30c	f0 39		beq $a347			beq 	_RGI_Exit
.a30e	c9 c1		cmp #$c1			cmp 	#KWD_OUTLINE 				; solid or outline
.a310	f0 3e		beq $a350			beq 	_RGI_Frame
.a312	c9 c9		cmp #$c9			cmp 	#KWD_SOLID
.a314	f0 33		beq $a349			beq 	_RGI_Solid
.a316	c9 ab		cmp #$ab			cmp 	#KWD_BY 					; by offset
.a318	f0 4b		beq $a365			beq 	_RGI_By
.a31a	c9 b6		cmp #$b6			cmp 	#KWD_FROM 					; from
.a31c	f0 17		beq $a335			beq 	_RGI_Move2
.a31e	c9 b3		cmp #$b3			cmp 	#KWD_DIM 					; dim (set scale)
.a320	f0 65		beq $a387			beq 	_RGI_Dim
.a322	c9 b1		cmp #$b1			cmp 	#KWD_COLOUR 				; colour or Color
.a324	f0 78		beq $a39e			beq 	_RGI_Colour
.a326	c9 b0		cmp #$b0			cmp 	#KWD_COLOR
.a328	f0 74		beq $a39e			beq 	_RGI_Colour
.a32a	ae 2f 06	ldx $062f			ldx 	gxCommandID
.a32d	e0 52		cpx #$52			cpx 	#GCMD_SpriteMove 			; if not sprite
.a32f	d0 03		bne $a334			bne 	_RGI_Move 					; move
.a331	4c c8 a3	jmp $a3c8			jmp		_RGI_SpriteInstructions
.a334					_RGI_Move:
.a334	88		dey				dey 								; unpick get.
.a335					_RGI_Move2:
.a335	20 ee a3	jsr $a3ee			jsr 	GCGetCoordinatePair 		; move to here
.a338	20 15 a4	jsr $a415			jsr 	GCCopyPairToStore 			; save
.a33b	5a		phy				phy
.a33c	20 0b a4	jsr $a40b			jsr 	GCLoadAXY 					; load in
.a33f	09 40		ora #$40			ora 	#GCMD_Move 					; move there
.a341	20 9d aa	jsr $aa9d			jsr 	GXGraphicDraw
.a344	7a		ply				ply
.a345	80 b4		bra $a2fb			bra 	_RGICommandLoop 			; and go round
.a347					_RGI_Exit:
.a347	88		dey				dey 								; unpick : / EOL
.a348	60		rts				rts
.a349					_RGI_Solid:
.a349	a9 02		lda #$02			lda 	#2
.a34b	8d 30 06	sta $0630			sta 	gxFillSolid
.a34e	80 ab		bra $a2fb			bra 	_RGICommandLoop
.a350					_RGI_Frame:
.a350	9c 30 06	stz $0630			stz 	gxFillSolid
.a353	80 a6		bra $a2fb			bra 	_RGICommandLoop
.a355					_RGI_To:
.a355	20 ee a3	jsr $a3ee			jsr 	GCGetCoordinatePair 		; get coordinate pair into slot #1,#2
.a358	20 15 a4	jsr $a415			jsr 	GCCopyPairToStore
.a35b					_RGI_Here:
.a35b	5a		phy				phy
.a35c	20 0b a4	jsr $a40b			jsr 	GCLoadAXY 					; load it into AXY
.a35f	20 c5 a3	jsr $a3c5			jsr 	_RGICallHandler 			; go do whatever it is.
.a362	7a		ply				ply
.a363	80 96		bra $a2fb			bra 	_RGICommandLoop 			; and go round
.a365					_RGI_By:
.a365	20 fb a3	jsr $a3fb			jsr 	GCSignedCoordinatePair 		; get coordinate pair into slot #1,#2
.a368	18		clc				clc
.a369	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; copy it into space.
.a36c	6d 31 06	adc $0631			adc 	gxxPos
.a36f	8d 31 06	sta $0631			sta 	gxXPos
.a372	ad 11 04	lda $0411			lda 	NSMantissa1+1
.a375	6d 32 06	adc $0632			adc 	gxxPos+1
.a378	8d 32 06	sta $0632			sta 	gxXPos+1
.a37b	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a37e	18		clc				clc
.a37f	6d 33 06	adc $0633			adc 	gxYPos
.a382	8d 33 06	sta $0633			sta 	gxYPos
.a385	80 d4		bra $a35b			bra 	_RGI_Here
.a387					_RGI_Dim:
.a387	a2 01		ldx #$01			ldx	 	#1
.a389	20 99 9d	jsr $9d99			jsr 	Evaluate8BitInteger
.a38c	ad 09 04	lda $0409			lda 	NSMantissa0+1
.a38f	c9 00		cmp #$00			cmp 	#0
.a391	f0 2f		beq $a3c2			beq 	_RGIRange
.a393	c9 09		cmp #$09			cmp 	#8+1
.a395	b0 2b		bcs $a3c2			bcs		_RGIRange
.a397	3a		dec a				dec 	a
.a398	8d 36 06	sta $0636			sta 	gxDrawScale
.a39b	4c fb a2	jmp $a2fb			jmp 	_RGICommandLoop
.a39e					_RGI_Colour:
.a39e	a2 01		ldx #$01			ldx 	#1 							; colour
.a3a0	20 99 9d	jsr $9d99			jsr 	Evaluate8BitInteger
.a3a3	a2 02		ldx #$02			ldx 	#2 							; default zero for 2nd parameter
.a3a5	20 18 9e	jsr $9e18			jsr 	NSMSetZero
.a3a8	b1 30		lda ($30),y			lda 	(codePtr),y
.a3aa	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; check , => mode.
.a3ac	d0 04		bne $a3b2			bne 	_RGICDefaultMode
.a3ae	c8		iny				iny
.a3af	20 99 9d	jsr $9d99			jsr 	Evaluate8BitInteger
.a3b2					_RGICDefaultMode:
.a3b2	5a		phy				phy
.a3b3	a9 08		lda #$08			lda 	#GCMD_Colour 				; set colour.
.a3b5	ae 09 04	ldx $0409			ldx 	NSMantissa0+1
.a3b8	ac 0a 04	ldy $040a			ldy 	NSMantissa0+2
.a3bb	20 9d aa	jsr $aa9d			jsr 	GXGraphicDraw
.a3be	7a		ply				ply
.a3bf	4c fb a2	jmp $a2fb			jmp 	_RGICommandLoop 			; and go round
.a3c2					_RGIRange:
.a3c2	4c a7 9f	jmp $9fa7			jmp 	RangeError
.a3c5					_RGICallHandler:
.a3c5	6c 34 06	jmp ($0634)			jmp 	(GXHandler)
.a3c8					_RGI_SpriteInstructions:
.a3c8	c9 bf		cmp #$bf			cmp 	#KWD_OFF
.a3ca	f0 07		beq $a3d3			beq 	_RGISpriteOff
.a3cc	c9 bb		cmp #$bb			cmp 	#KWD_IMAGE
.a3ce	f0 13		beq $a3e3			beq 	_RGISetImage
.a3d0	4c 34 a3	jmp $a334			jmp 	_RGI_Move
.a3d3					_RGISpriteOff:
.a3d3	5a		phy				phy
.a3d4	a0 01		ldy #$01			ldy 	#1
.a3d6	a2 00		ldx #$00			ldx 	#0
.a3d8					_RGIDoCommandLoop:
.a3d8	a9 10		lda #$10			lda 	#GCMD_SpriteImage
.a3da	20 9d aa	jsr $aa9d			jsr 	GXGraphicDraw
.a3dd	7a		ply				ply
.a3de	b0 e2		bcs $a3c2			bcs 	_RGIRange
.a3e0	4c fb a2	jmp $a2fb			jmp 	_RGICommandLoop
.a3e3					_RGISetImage:
.a3e3	a2 01		ldx #$01			ldx 	#1
.a3e5	20 99 9d	jsr $9d99			jsr 	Evaluate8BitInteger
.a3e8	5a		phy				phy
.a3e9	aa		tax				tax
.a3ea	a0 00		ldy #$00			ldy 	#0
.a3ec	80 ea		bra $a3d8			bra 	_RGIDoCommandLoop
.a3ee					GCGetCoordinatePair:
.a3ee	a2 01		ldx #$01			ldx 	#1
.a3f0	20 79 9d	jsr $9d79			jsr 	Evaluate16BitInteger
.a3f3	20 44 8d	jsr $8d44			jsr 	CheckComma
.a3f6	e8		inx				inx
.a3f7	20 79 9d	jsr $9d79			jsr 	Evaluate16BitInteger
.a3fa	60		rts				rts
.a3fb					GCSignedCoordinatePair:
.a3fb	a2 01		ldx #$01			ldx 	#1
.a3fd	20 85 9d	jsr $9d85			jsr 	Evaluate16BitIntegerSigned
.a400	20 44 8d	jsr $8d44			jsr 	CheckComma
.a403	e8		inx				inx
.a404	20 85 9d	jsr $9d85			jsr 	Evaluate16BitIntegerSigned
.a407	60		rts				rts
.a408					_GCCPRange:
.a408	4c a7 9f	jmp $9fa7			jmp 	RangeError
.a40b					GCLoadAXY:
.a40b	ad 32 06	lda $0632			lda 	gxXPos+1
.a40e	ae 31 06	ldx $0631			ldx 	gxXPos
.a411	ac 33 06	ldy $0633			ldy 	gxYPos
.a414	60		rts				rts
.a415					GCCopyPairToStore:
.a415	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; copy it into space.
.a418	8d 31 06	sta $0631			sta 	gxXPos
.a41b	ad 11 04	lda $0411			lda 	NSMantissa1+1
.a41e	8d 32 06	sta $0632			sta 	gxXPos+1
.a421	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a424	8d 33 06	sta $0633			sta 	gxYPos
.a427	60		rts				rts
.062f					gxCommandID:
>062f							.fill 	1
.0630					gxFillSolid:
>0630							.fill 	1
.0631					gxXPos:
>0631							.fill 	2
.0633					gxYPos:
>0633							.fill 	1
.0634					gxHandler:
>0634							.fill 	2
.0636					gxDrawScale:
>0636							.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./common/module.interface/graphics/gcontrol.asm

.a428					BitmapCtrl:
.a428	b1 30		lda ($30),y			lda 	(codePtr),y
.a42a	c8		iny				iny
.a42b	a2 01		ldx #$01			ldx 	#1
.a42d	c9 c0		cmp #$c0			cmp 	#KWD_ON
.a42f	f0 11		beq $a442			beq 	BitmapSwitch
.a431	ca		dex				dex
.a432	c9 bf		cmp #$bf			cmp 	#KWD_OFF
.a434	f0 0c		beq $a442			beq 	BitmapSwitch
.a436	20 99 9d	jsr $9d99			jsr 	Evaluate8BitInteger 		; get the colour
.a439	5a		phy				phy
.a43a	aa		tax				tax
.a43b	a9 06		lda #$06			lda 	#GCMD_Clear					; clear to that colour
.a43d	20 9d aa	jsr $aa9d			jsr 	GXGraphicDraw
.a440	7a		ply				ply
.a441	60		rts				rts
.a442					BitmapSwitch:
.a442	5a		phy				phy
.a443	a0 00		ldy #$00			ldy 	#0 							; gfx 1,on/off,0
.a445	a9 02		lda #$02			lda 	#GCMD_BitmapCtl
.a447	20 9d aa	jsr $aa9d			jsr 	GXGraphicDraw
.a44a	a9 08		lda #$08			lda 	#GCMD_Colour				; set colour to $FF
.a44c	a0 00		ldy #$00			ldy 	#0
.a44e	a2 ff		ldx #$ff			ldx 	#$FF
.a450	20 9d aa	jsr $aa9d			jsr 	GXGraphicDraw
.a453	9c 30 06	stz $0630			stz 	gxFillSolid
.a456	9c 31 06	stz $0631			stz 	gxXPos
.a459	9c 32 06	stz $0632			stz 	gxXPos+1
.a45c	9c 33 06	stz $0633			stz 	gxYPos
.a45f	9c 36 06	stz $0636			stz 	gxDrawScale
.a462	a9 40		lda #$40			lda 	#GCMD_Move 						; home cursor
.a464	a2 00		ldx #$00			ldx 	#0
.a466	a0 00		ldy #$00			ldy 	#0
.a468	20 9d aa	jsr $aa9d			jsr 	GXGraphicDraw
.a46b	7a		ply				ply
.a46c	60		rts				rts
.a46d					SpritesCtrl:
.a46d	b1 30		lda ($30),y			lda 	(codePtr),y
.a46f	c8		iny				iny
.a470	a2 01		ldx #$01			ldx 	#1
.a472	c9 c0		cmp #$c0			cmp 	#KWD_ON
.a474	f0 08		beq $a47e			beq 	SpriteSwitch
.a476	ca		dex				dex
.a477	c9 bf		cmp #$bf			cmp 	#KWD_OFF
.a479	f0 03		beq $a47e			beq 	SpriteSwitch
.a47b	4c a2 9f	jmp $9fa2			jmp 	SyntaxError
.a47e					SpriteSwitch:
.a47e	5a		phy				phy
.a47f	a0 00		ldy #$00			ldy 	#0 							; gfx 2,on/off,0
.a481	a9 04		lda #$04			lda 	#GCMD_SpriteCtl
.a483	20 9d aa	jsr $aa9d			jsr 	GXGraphicDraw
.a486	7a		ply				ply
.a487	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/module.interface/graphics/gfx.asm

.a488					GfxCommand:
.a488	a2 00		ldx #$00			ldx 	#0
.a48a	20 99 9d	jsr $9d99			jsr 	Evaluate8BitInteger 		; command
.a48d	20 44 8d	jsr $8d44			jsr 	CheckComma
.a490	e8		inx				inx
.a491	20 79 9d	jsr $9d79			jsr 	Evaluate16BitInteger 		; X
.a494	20 44 8d	jsr $8d44			jsr 	CheckComma
.a497	e8		inx				inx
.a498	20 99 9d	jsr $9d99			jsr 	Evaluate8BitInteger 		; Y
.a49b	ad 11 04	lda $0411			lda 	NSMantissa1+1  				; shift bit 0 of X into CS, should now be zero
.a49e	4a		lsr a				lsr 	a
.a49f	d0 16		bne $a4b7			bne 	_GfxError
.a4a1	2e 08 04	rol $0408			rol 	NSMantissa0 				; rotate into command
.a4a4	b0 11		bcs $a4b7			bcs 	_GfxError 					; bit 7 should have been zero
.a4a6	5a		phy				phy 								; save pos
.a4a7	ad 08 04	lda $0408			lda 	NSMantissa0 				; do the command
.a4aa	ae 09 04	ldx $0409			ldx 	NSMantissa0+1
.a4ad	ac 0a 04	ldy $040a			ldy 	NSMantissa0+2
.a4b0	20 9d aa	jsr $aa9d			jsr 	GXGraphicDraw
.a4b3	b0 02		bcs $a4b7			bcs 	_GfxError
.a4b5	7a		ply				ply 								; restore pos and exit.
.a4b6	60		rts				rts
.a4b7					_GfxError:
.a4b7	4c a7 9f	jmp $9fa7			jmp 	RangeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/module.interface/graphics/hit.asm

.a4ba					UnaryHit:
.a4ba	fa		plx				plx
.a4bb	a9 36		lda #$36			lda 	#zTemp0
.a4bd	20 99 9d	jsr $9d99			jsr 	Evaluate8BitInteger 		; get sprite number 0
.a4c0	20 44 8d	jsr $8d44			jsr 	CheckComma
.a4c3	e8		inx				inx
.a4c4	20 99 9d	jsr $9d99			jsr 	Evaluate8BitInteger 		; get sprite number 1
.a4c7	20 3c 8d	jsr $8d3c			jsr		CheckRightBracket
.a4ca	ca		dex				dex 								; fix back up again.
.a4cb	da		phx				phx 								; save X/Y
.a4cc	5a		phy				phy
.a4cd	bc 09 04	ldy $0409,x			ldy 	NSMantissa0+1,x 			; get the sprite numbers into X/Y
.a4d0	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a4d3	aa		tax				tax
.a4d4	a9 12		lda #$12			lda 	#GCMD_SpriteCollide 		; command check collision.
.a4d6	20 9d aa	jsr $aa9d			jsr 	GXGraphicDraw 				; calculate result
.a4d9	1a		inc a				inc 	a 							; so 255 (fail) -> 0, otherwise 1,2,3,4 pixels etc.
.a4da	7a		ply				ply 								; restore XY
.a4db	fa		plx				plx
.a4dc	20 1a 9e	jsr $9e1a			jsr 	NSMSetByte 					; return the hit result
.a4df	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/module.interface/graphics/palette.asm

.a4e0					PaletteCommand:
.a4e0	a2 00		ldx #$00			ldx 	#0
.a4e2	20 99 9d	jsr $9d99			jsr 	Evaluate8BitInteger 		; colour
.a4e5	20 44 8d	jsr $8d44			jsr 	CheckComma
.a4e8	e8		inx				inx
.a4e9	20 79 9d	jsr $9d79			jsr 	Evaluate16BitInteger 		; r
.a4ec	20 44 8d	jsr $8d44			jsr 	CheckComma
.a4ef	e8		inx				inx
.a4f0	20 99 9d	jsr $9d99			jsr 	Evaluate8BitInteger 		; g
.a4f3	20 44 8d	jsr $8d44			jsr 	CheckComma
.a4f6	e8		inx				inx
.a4f7	20 99 9d	jsr $9d99			jsr 	Evaluate8BitInteger 		; b
.a4fa	ad 08 04	lda $0408			lda 	NSMantissa0 				; get colour #
.a4fd	85 36		sta $36				sta 	zTemp0
.a4ff	a9 34		lda #$34			lda 	#$D0 >> 2 					; MSB = D0/4
.a501	85 37		sta $37				sta 	zTemp0+1
.a503	06 36		asl $36				asl 	zTemp0 						; zTemp = $D000+Colour x 4
.a505	26 37		rol $37				rol	 	zTemp0+1
.a507	06 36		asl $36				asl 	zTemp0
.a509	26 37		rol $37				rol	 	zTemp0+1
.a50b	a9 01		lda #$01			lda 	#1 							; I/O Page 2
.a50d	85 01		sta $01				sta 	1
.a50f	5a		phy				phy
.a510	ad 0b 04	lda $040b			lda 	NSMantissa0+3 				; fix to r,g,b
.a513	92 36		sta ($36)			sta 	(zTemp0)
.a515	a0 01		ldy #$01			ldy 	#1
.a517	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a51a	91 36		sta ($36),y			sta 	(zTemp0),y
.a51c	ad 09 04	lda $0409			lda 	NSMantissa0+1
.a51f	c8		iny				iny
.a520	91 36		sta ($36),y			sta 	(zTemp0),y
.a522	7a		ply				ply
.a523	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/module.interface/hardware/event.asm

.a524					UnaryEvent:
.a524	fa		plx				plx
.a525	20 cc a5	jsr $a5cc			jsr 	TimerToStackX 				; timer in +0
.a528	e8		inx				inx  								; put reference into +1
.a529	20 de 97	jsr $97de			jsr 	EvaluateTerm
.a52c	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if is integer reference
.a52f	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.a531	d0 57		bne $a58a			bne 	_UEType
.a533	e8		inx				inx 								; put the step in +2
.a534	20 44 8d	jsr $8d44			jsr 	CheckComma
.a537	20 79 9d	jsr $9d79			jsr 	Evaluate16BitInteger
.a53a	20 3c 8d	jsr $8d3c			jsr 	CheckRightBracket
.a53d	ca		dex				dex
.a53e	ca		dex				dex
.a53f	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; copy reference to zTemp0
.a542	85 36		sta $36				sta 	zTemp0
.a544	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.a547	85 37		sta $37				sta 	zTemp0+1
.a549	5a		phy				phy
.a54a	a0 03		ldy #$03			ldy 	#3 							; check bit 7 of last bit, the packed sign bit
.a54c	b1 36		lda ($36),y			lda 	(zTemp0),y
.a54e	30 36		bmi $a586			bmi 	_UEFalse 					; exit if signed.
.a550	a0 00		ldy #$00			ldy 	#0 							; has it timed out (24 bit)
.a552	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a555	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.a557	c8		iny				iny
.a558	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a55b	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a55d	c8		iny				iny
.a55e	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.a561	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a563	90 21		bcc $a586			bcc 	_UEFalse 					; no, return FALSE.
.a565	18		clc				clc
.a566	a0 00		ldy #$00			ldy 	#0 							; work out new value as timer() + step
.a568	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a56b	7d 0a 04	adc $040a,x			adc 	NSMantissa0+2,x
.a56e	91 36		sta ($36),y			sta 	(zTemp0),y
.a570	c8		iny				iny
.a571	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a574	7d 12 04	adc $0412,x			adc 	NSMantissa1+2,x
.a577	91 36		sta ($36),y			sta 	(zTemp0),y
.a579	c8		iny				iny
.a57a	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.a57d	7d 1a 04	adc $041a,x			adc 	NSMantissa2+2,x
.a580	91 36		sta ($36),y			sta 	(zTemp0),y
.a582	7a		ply				ply
.a583	4c c2 8d	jmp $8dc2			jmp 	ReturnTrue
.a586					_UEFalse:
.a586	7a		ply				ply 								; restore Y
.a587	4c ce 8d	jmp $8dce			jmp 	ReturnFalse 				; and return False
.a58a					_UEType:
.a58a	4c ac 9f	jmp $9fac			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/module.interface/hardware/joy.asm

.a58d					UnaryJoyX:
.a58d	18		clc				clc
.a58e	80 01		bra $a591			bra 	JoyMain
.a590					UnaryJoyY:
.a590	38		sec				sec
.a591					JoyMain:
.a591	fa		plx				plx 								; get pos
.a592	08		php				php 								; save carry (set for Y)
.a593	20 99 9d	jsr $9d99			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a596	20 3c 8d	jsr $8d3c			jsr 	CheckRightBracket
.a599	20 56 aa	jsr $aa56			jsr 	EXTReadController 			; read the controller.
.a59c	28		plp				plp
.a59d	90 02		bcc $a5a1			bcc 	_JMNoShift 					; if Y then shift bits 3,2 -> 1,0
.a59f	4a		lsr a				lsr 	a
.a5a0	4a		lsr a				lsr 	a
.a5a1					_JMNoShift:
.a5a1	4a		lsr a				lsr 	a 							; if bit 0 set then right/down e.g. +1
.a5a2	b0 0a		bcs $a5ae			bcs 	_JMIsRight
.a5a4	4a		lsr a				lsr 	a 							; if bit 1 set then left/up e.g. -1
.a5a5	b0 04		bcs $a5ab			bcs 	_JMIsLeft
.a5a7	20 18 9e	jsr $9e18			jsr 	NSMSetZero 					; zero result
.a5aa	60		rts				rts
.a5ab					_JMIsLeft:
.a5ab	4c c2 8d	jmp $8dc2			jmp 	ReturnTrue
.a5ae					_JMIsRight:
.a5ae	a9 01		lda #$01			lda 	#1
.a5b0	20 1a 9e	jsr $9e1a			jsr 	NSMSetByte
.a5b3	60		rts				rts
.a5b4					UnaryJoyB:
.a5b4	fa		plx				plx 								; get pos
.a5b5	20 99 9d	jsr $9d99			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a5b8	20 3c 8d	jsr $8d3c			jsr 	CheckRightBracket
.a5bb	20 56 aa	jsr $aa56			jsr 	EXTReadController 			; read the controller.
.a5be	4a		lsr a				lsr 	a
.a5bf	4a		lsr a				lsr 	a
.a5c0	4a		lsr a				lsr 	a
.a5c1	4a		lsr a				lsr 	a
.a5c2	29 01		and #$01			and 	#1
.a5c4	20 1a 9e	jsr $9e1a			jsr 	NSMSetByte
.a5c7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/module.interface/hardware/timer.asm

.a5c8					UnaryTimer:
.a5c8	fa		plx				plx
.a5c9	20 3c 8d	jsr $8d3c			jsr 	CheckRightBracket
.a5cc					TimerToStackX:
.a5cc	20 18 9e	jsr $9e18			jsr 	NSMSetZero 					; zero result
.a5cf	64 01		stz $01				stz 	1 							; access I/O
.a5d1	ad 59 d6	lda $d659			lda 	$D659 						; copy timer in
.a5d4	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.a5d7	ad 5a d6	lda $d65a			lda 	$D65A
.a5da	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a5dd	ad 5b d6	lda $d65b			lda 	$D65B
.a5e0	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.a5e3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/module.interface/sound/sound.asm

.a5e4					SoundCommand:
.a5e4	b1 30		lda ($30),y			lda 	(codePtr),y
.a5e6	c9 bf		cmp #$bf			cmp 	#KWD_OFF 					; SOUND OFF ?
.a5e8	d0 09		bne $a5f3			bne 	_SNDMain
.a5ea	c8		iny				iny 								; skip OFF
.a5eb	a9 3f		lda #$3f			lda 	#$3F 						; call command $3F (silence)
.a5ed	5a		phy				phy
.a5ee	20 2b b9	jsr $b92b			jsr 	SNDCommand
.a5f1	7a		ply				ply
.a5f2	60		rts				rts
.a5f3					_SNDMain:
.a5f3	a2 00		ldx #$00			ldx 	#0
.a5f5	20 99 9d	jsr $9d99			jsr 	Evaluate8BitInteger 		; channel
.a5f8	c9 04		cmp #$04			cmp 	#4 							; must be 0-3
.a5fa	b0 50		bcs $a64c			bcs 	_SndError
.a5fc	e8		inx				inx 								; do the rest in slot 1.
.a5fd	20 44 8d	jsr $8d44			jsr 	CheckComma
.a600	20 79 9d	jsr $9d79			jsr 	Evaluate16BitInteger 		; Pitch
.a603	bd 10 04	lda $0410,x			lda 	NSMantissa1,x 				; must be 10 bit
.a606	c9 10		cmp #$10			cmp 	#16
.a608	b0 42		bcs $a64c			bcs 	_SndError
.a60a	8d 38 06	sta $0638			sta 	SoundCommandBlock+1 		; Pitch (2 bytes + 0)
.a60d	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a610	8d 37 06	sta $0637			sta 	SoundCommandBlock
.a613	20 44 8d	jsr $8d44			jsr 	CheckComma
.a616	20 99 9d	jsr $9d99			jsr 	Evaluate8BitInteger 		; Length (1 byte + 3)
.a619	8d 3a 06	sta $063a			sta 	SoundCommandBlock+3
.a61c	a9 0f		lda #$0f			lda 	#15
.a61e	8d 39 06	sta $0639			sta 	SoundCommandBlock+2 		; Volume (1 byte + 2)
.a621	9c 3b 06	stz $063b			stz 	SoundCommandBlock+4 		; default slide (2 bytes +4)
.a624	9c 3c 06	stz $063c			stz 	SoundCommandBlock+5
.a627	b1 30		lda ($30),y			lda 	(codePtr),y
.a629	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.a62b	d0 10		bne $a63d			bne 	_SNDPlay
.a62d	c8		iny				iny
.a62e	20 85 9d	jsr $9d85			jsr 	Evaluate16BitIntegerSigned 	; Slide
.a631	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; Slide (2 bytes + 4)
.a634	8d 3b 06	sta $063b			sta 	SoundCommandBlock+4
.a637	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a63a	8d 3c 06	sta $063c			sta 	SoundCommandBlock+5
.a63d					_SNDPlay:
.a63d	5a		phy				phy
.a63e	ad 08 04	lda $0408			lda 	NSMantissa0 				; channel.
.a641	09 10		ora #$10			ora 	#$10 						; 1x = Queue sound
.a643	a2 37		ldx #$37			ldx 	#(SoundCommandBlock & $FF)
.a645	a0 06		ldy #$06			ldy 	#(SoundCommandBlock >> 8)
.a647	20 2b b9	jsr $b92b			jsr 	SNDCommand
.a64a	7a		ply				ply
.a64b	60		rts				rts
.a64c					_SndError:
.a64c	4c a7 9f	jmp $9fa7			jmp 	RangeError
.0637					SoundCommandBlock:
>0637							.fill 	6

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/bytes.asm

.a64f					StackPushByte:
.a64f	48		pha				pha 								; save byte
.a650	a5 34		lda $34				lda 	BasicStack
.a652	d0 09		bne $a65d			bne 	_SPBNoBorrow
.a654	c6 35		dec $35				dec 	BasicStack+1
.a656	48		pha				pha
.a657	a5 35		lda $35				lda 	BasicStack+1
.a659	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a65b	90 06		bcc $a663			bcc 	_SPBMemory
.a65d					_SPBNoBorrow:
.a65d	c6 34		dec $34				dec 	BasicStack
.a65f	68		pla				pla 								; get back and write
.a660	92 34		sta ($34)			sta 	(BasicStack)
.a662	60		rts				rts
.a663					_SPBMemory:
.a663	a9 12		lda #$12		lda	#18
.a665	4c 55 8d	jmp $8d55		jmp	ErrorHandler
.a668					StackPopByte:
.a668	b2 34		lda ($34)			lda 	(BasicStack)
.a66a	e6 34		inc $34				inc 	BasicStack
.a66c	d0 02		bne $a670			bne 	_SPBNoCarry
.a66e	e6 35		inc $35				inc 	BasicStack+1
.a670					_SPBNoCarry:
.a670	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/frames.asm

.a671					StackOpen:
.a671	48		pha				pha 								; save frame byte
.a672	29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.a674	0a		asl a				asl 	a 							; claim twice this for storage
.a675	49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.a677	38		sec				sec 								; so basically subtracting from
.a678	65 34		adc $34				adc 	basicStack 	 				; basicStack
.a67a	85 34		sta $34				sta 	basicStack
.a67c	b0 08		bcs $a686			bcs 	_SONoBorrow
.a67e	c6 35		dec $35				dec 	basicStack+1
.a680	a5 35		lda $35				lda 	basicStack+1 				; have we reached stack overflow
.a682	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a684	90 04		bcc $a68a			bcc 	_SOMemory
.a686					_SONoBorrow:
.a686	68		pla				pla 								; get marker back and write at TOS
.a687	92 34		sta ($34)			sta 	(basicStack)
.a689	60		rts				rts
.a68a					_SOMemory:
.a68a	a9 12		lda #$12		lda	#18
.a68c	4c 55 8d	jmp $8d55		jmp	ErrorHandler
.a68f					StackClose:
.a68f	b2 34		lda ($34)			lda 	(basicStack) 				; get TOS marker
.a691	29 0f		and #$0f			and 	#$0F 						; bytes to add back
.a693	0a		asl a				asl 	a 							; claim twice this.
.a694	65 34		adc $34				adc 	basicStack 					; add to the stack pointer.
.a696	85 34		sta $34				sta 	basicStack
.a698	90 02		bcc $a69c			bcc 	_SCExit
.a69a	e6 35		inc $35				inc 	basicStack+1
.a69c					_SCExit:
.a69c	60		rts				rts
.a69d					StackCheckFrame:
.a69d	48		pha				pha
.a69e					_StackRemoveLocals:
.a69e	b2 34		lda ($34)			lda 	(basicStack) 				; check for local, keep popping them
.a6a0	c9 03		cmp #$03			cmp 	#STK_LOCALS+1
.a6a2	b0 05		bcs $a6a9			bcs 	_SCNoLocal
.a6a4	20 02 88	jsr $8802			jsr 	LocalPopValue
.a6a7	80 f5		bra $a69e			bra 	_StackRemoveLocals
.a6a9					_SCNoLocal:
.a6a9	68		pla				pla
.a6aa	52 34		eor ($34)			eor 	(basicStack) 				; xor with toS marker
.a6ac	29 f0		and #$f0			and 	#$F0 						; check type bits
.a6ae	d0 01		bne $a6b1			bne 	_SCFError 					; different, we have structures mixed up
.a6b0	60		rts				rts
.a6b1					_SCFError:
.a6b1	8a		txa				txa 								; report error X
.a6b2	4c 55 8d	jmp $8d55			jmp 	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/location.asm

.a6b5					STKSaveCodePosition:
.a6b5	5a		phy				phy
.a6b6	98		tya				tya 								; save Y
.a6b7	a0 05		ldy #$05			ldy 	#5
.a6b9	91 34		sta ($34),y			sta 	(basicStack),y
.a6bb	88		dey				dey 								; save Code Pointer
.a6bc					_STKSaveLoop:
.a6bc	b9 2f 00	lda $002f,y			lda 	safePtr-1,y 				; allows us to access the pointer w/out issues.
.a6bf	91 34		sta ($34),y			sta 	(basicStack),y
.a6c1	88		dey				dey
.a6c2	d0 f8		bne $a6bc			bne 	_STKSaveLoop
.a6c4	7a		ply				ply
.a6c5	60		rts				rts
.a6c6					STKLoadCodePosition:
.a6c6	a0 01		ldy #$01			ldy 	#1 							; load code pointer back
.a6c8					_STKLoadLoop:
.a6c8	b1 34		lda ($34),y			lda 	(basicStack),y
.a6ca	99 2f 00	sta $002f,y			sta 	safePtr-1,y
.a6cd	c8		iny				iny
.a6ce	c0 05		cpy #$05			cpy 	#5
.a6d0	d0 f6		bne $a6c8			bne 	_STKLoadLoop
.a6d2	b1 34		lda ($34),y			lda 	(basicStack),y 				; get Y offset
.a6d4	a8		tay				tay
.a6d5	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/setup.asm

.a6d6					StackReset:
.a6d6	a9 ff		lda #$ff			lda 	#((BasicStackBase+BasicStackSize-1) & $FF)
.a6d8	85 34		sta $34				sta 	0+basicStack
.a6da	a9 0f		lda #$0f			lda 	#((BasicStackBase+BasicStackSize-1) >> 8)
.a6dc	85 35		sta $35				sta 	1+basicStack
.a6de	a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.a6e0	92 34		sta ($34)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.a6e2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/concrete.asm

.a6e3					StringConcrete:
.a6e3	5a		phy				phy 								; save position on stack
.a6e4	20 e1 99	jsr $99e1			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a6e7	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy target string to zTemp1
.a6ea	85 38		sta $38				sta 	zTemp1
.a6ec	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a6ef	85 39		sta $39				sta 	zTemp1+1
.a6f1	a0 ff		ldy #$ff			ldy 	#$FF	 					; calculate string length
.a6f3					_SALength:
.a6f3	c8		iny				iny
.a6f4	b1 38		lda ($38),y			lda 	(zTemp1),y
.a6f6	d0 fb		bne $a6f3			bne 	_SALength
.a6f8	c0 fd		cpy #$fd			cpy 	#253 						; string too long
.a6fa	b0 3f		bcs $a73b			bcs 	_SALengthError
.a6fc	98		tya				tya 				 				; length of the new string
.a6fd	18		clc				clc
.a6fe	69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.a700	90 02		bcc $a704			bcc 	_SAHaveLength
.a702	a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.a704					_SAHaveLength:
.a704	48		pha				pha 								; save length.
.a705	38		sec				sec
.a706	49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.a708	6d 8e 04	adc $048e			adc 	StringMemory
.a70b	8d 8e 04	sta $048e			sta 	StringMemory
.a70e	85 3a		sta $3a				sta 	zTemp2 						; update storage address
.a710	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; update mantissa address
.a713	a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.a715	6d 8f 04	adc $048f			adc 	StringMemory+1
.a718	8d 8f 04	sta $048f			sta 	StringMemory+1
.a71b	85 3b		sta $3b				sta 	zTemp2+1
.a71d	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a720	68		pla				pla 								; save length-3 (chars allowed) in first byte
.a721	38		sec				sec
.a722	e9 03		sbc #$03			sbc 	#3
.a724	92 3a		sta ($3a)			sta 	(zTemp2)
.a726	a9 00		lda #$00			lda 	#0 							; clear the status byte.
.a728	a0 01		ldy #$01			ldy 	#1
.a72a	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a72c					_SACopyNewString:
.a72c	a0 00		ldy #$00			ldy 	#0
.a72e					_SACopyNSLoop:
.a72e	b1 38		lda ($38),y			lda 	(zTemp1),y 					; get character
.a730	c8		iny				iny 								; write two on in string storage
.a731	c8		iny				iny
.a732	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a734	88		dey				dey 								; this makes it one one.
.a735	c9 00		cmp #$00			cmp 	#0 							; until EOS copied
.a737	d0 f5		bne $a72e			bne 	_SACopyNSLoop
.a739	7a		ply				ply
.a73a	60		rts				rts
.a73b					_SALengthError:
.a73b	a9 09		lda #$09		lda	#9
.a73d	4c 55 8d	jmp $8d55		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/stringalloc.asm

.a740					StringSystemInitialise:
.a740	a9 ff		lda #$ff			lda 	#((EndVariableSpace-1) & $FF)
.a742	8d 8e 04	sta $048e			sta 	0+StringMemory
.a745	a9 1f		lda #$1f			lda 	#((EndVariableSpace-1) >> 8)
.a747	8d 8f 04	sta $048f			sta 	1+StringMemory
.a74a	9c ff 1f	stz $1fff			stz 	EndVariableSpace-1 			; put a zero at the end, so know end of string memory.
.a74d	60		rts				rts
.a74e					StringSpaceInitialise:
.a74e	20 e1 99	jsr $99e1			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a751	a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.a753	8d 90 04	sta $0490			sta 	StringInitialised
.a756	ad 8e 04	lda $048e			lda 	StringMemory 				; allocate 256 bytes for one concreted string
.a759	8d 91 04	sta $0491			sta 	StringTempPointer
.a75c	ad 8f 04	lda $048f			lda 	StringMemory+1
.a75f	3a		dec a				dec 	a
.a760	8d 92 04	sta $0492			sta 	StringTempPointer+1
.a763	60		rts				rts
.a764					StringTempAllocate:
.a764	c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.a766	b0 35		bcs $a79d			bcs 	_STALength
.a768	2c 90 04	bit $0490			bit 	StringInitialised 			; already initialised
.a76b	30 05		bmi $a772			bmi 	_STAAllocate
.a76d	48		pha				pha 								; save value to subtract.
.a76e	20 4e a7	jsr $a74e			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.a771	68		pla				pla 								; restore it
.a772					_STAAllocate:
.a772	49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.a774	18		clc				clc  								; deliberate allows one more
.a775	6d 91 04	adc $0491			adc 	StringTempPointer 			; subtract from temp pointer
.a778	8d 91 04	sta $0491			sta 	StringTempPointer
.a77b	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; address in mantissa
.a77e	85 3c		sta $3c				sta 	zsTemp 						; and zsTemp
.a780	ad 92 04	lda $0492			lda 	StringTempPointer+1
.a783	69 ff		adc #$ff			adc 	#$FF
.a785	8d 92 04	sta $0492			sta 	StringTempPointer+1
.a788	85 3d		sta $3d				sta 	zsTemp+1
.a78a	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a78d	9e 18 04	stz $0418,x			stz 	NSMantissa2,x 				; set the typing data
.a790	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.a793	a9 10		lda #$10			lda 	#NSTString
.a795	9d 00 04	sta $0400,x			sta 	NSStatus,x
.a798	a9 00		lda #$00			lda 	#0 							; clear the target string
.a79a	92 3c		sta ($3c)			sta 	(zsTemp)
.a79c	60		rts				rts
.a79d					_STALength:
.a79d	a9 09		lda #$09		lda	#9
.a79f	4c 55 8d	jmp $8d55		jmp	ErrorHandler
.a7a2					StringTempWrite:
.a7a2	48		pha				pha
.a7a3	92 3c		sta ($3c)			sta 	(zsTemp)
.a7a5	e6 3c		inc $3c				inc 	zsTemp
.a7a7	d0 02		bne $a7ab			bne 	_STWNoCarry
.a7a9	e6 3d		inc $3d				inc 	zsTemp+1
.a7ab					_STWNoCarry:
.a7ab	a9 00		lda #$00			lda 	#0
.a7ad	92 3c		sta ($3c)			sta 	(zsTemp)
.a7af	68		pla				pla
.a7b0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_hardware.module

=1					hardwareIntegrated=1
=0					CONBlack = 0
=1					CONWhite = 1
=2					CONRed = 2
=3					CONCyan = 3
=4					CONPurple = 4
=5					CONGreen = 5
=6					CONBlue = 6
=7					CONYellow = 7
=8					CONOrange = 8
=9					CONBrown = 9
=10					CONYellowGreen = 10
=11					CONRosa = 11
=12					CONBlueGreen = 12
=13					CONLightBlue = 13
=14					CONPink = 14
=15					CONLightGreen = 15
=7					CONForeground = CONYellow
=6					CONBackground = CONBlue
=12					CLINumber = CONBlueGreen
=3					CLIToken = CONCyan
=13					CLIConstant = CONLightBlue
=7					CLIIdentifier = CONYellow
=10					CLIPunctuation = CONYellowGreen
=1					CLIData = CONWhite
.a7b1					EXTPrintCharacter:
.a7b1	48		pha				pha
.a7b2	da		phx				phx
.a7b3	5a		phy				phy
.a7b4	a6 01		ldx $01				ldx 	1
.a7b6	da		phx				phx
.a7b7	ac 3e 06	ldy $063e			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.a7ba	09 00		ora #$00			ora 	#$00 						; check $80-$FF
.a7bc	30 48		bmi $a806			bmi 	_EXPCColour
.a7be	c9 20		cmp #$20			cmp 	#$20 						; check $00-$1F
.a7c0	90 4d		bcc $a80f			bcc 	_EXPCControl
.a7c2	a2 02		ldx #$02			ldx 	#2 							; select char memory
.a7c4	86 01		stx $01				stx 	1
.a7c6	91 40		sta ($40),y			sta 	(EXTAddress),y
.a7c8	e6 01		inc $01				inc 	1 							; select colour memory
.a7ca	ad 3f 06	lda $063f			lda 	EXTTextColour
.a7cd	91 40		sta ($40),y			sta 	(EXTAddress),y
.a7cf	c8		iny				iny 								; advance horizontal position
.a7d0	8c 3e 06	sty $063e			sty 	EXTColumn
.a7d3	cc 40 06	cpy $0640			cpy 	EXTScreenWidth 				; reached RHS ?
.a7d6	90 66		bcc $a83e			bcc 	_EXPCExit 					; no, then exit.
.a7d8					_EXPCCRLF:
.a7d8	ee 3d 06	inc $063d			inc 	EXTRow  					; bump row
.a7db	9c 3e 06	stz $063e			stz 	EXTColumn 					; back to column 0
.a7de	ad 3d 06	lda $063d			lda 	EXTRow 						; check if reached the bottom ?
.a7e1	cd 41 06	cmp $0641			cmp 	EXTScreenHeight 			; if so, then scroll.
.a7e4	f0 18		beq $a7fe			beq 	_EXPCScroll
.a7e6	18		clc				clc 								; add width to address.
.a7e7	a5 40		lda $40				lda 	EXTAddress
.a7e9	6d 40 06	adc $0640			adc 	EXTScreenWidth
.a7ec	85 40		sta $40				sta 	EXTAddress
.a7ee	90 4e		bcc $a83e			bcc 	_EXPCExit
.a7f0	e6 41		inc $41				inc 	EXTAddress+1
.a7f2	80 4a		bra $a83e			bra 	_EXPCExit
.a7f4					_EXPCLeft:
.a7f4	ce 3e 06	dec $063e			dec 	EXTColumn
.a7f7	10 45		bpl $a83e			bpl 	_EXPCExit
.a7f9					_EXPCBegin:
.a7f9	9c 3e 06	stz $063e			stz 	EXTColumn
.a7fc	80 40		bra $a83e			bra 	_EXPCExit
.a7fe					_EXPCScroll:
.a7fe	ce 3d 06	dec $063d			dec 	EXTRow 						; the height-1 th line.
.a801	20 cb a8	jsr $a8cb			jsr 	EXTScreenScroll 			; scroll the screen
.a804	80 38		bra $a83e			bra 	_EXPCExit
.a806					_EXPCColour:
.a806	c9 a0		cmp #$a0			cmp 	#$A0						; 80-9F set foreground/background
.a808	b0 34		bcs $a83e			bcs 	_EXPCExit
.a80a	20 ab a8	jsr $a8ab			jsr 	_EXPCHandleColour
.a80d	80 2f		bra $a83e			bra 	_EXPCExit
.a80f					_EXPCControl:
.a80f	c9 11		cmp #$11			cmp 	#$11 						; only handle 00-10.
.a811	b0 2b		bcs $a83e			bcs 	_EXPCExit
.a813	0a		asl a				asl 	a 							; double into X
.a814	aa		tax				tax
.a815	7c 89 a8	jmp ($a889,x)			jmp 	(_EXPCActionTable,x) 		; and execute code.
.a818					_EXPCUp:
.a818	ad 3d 06	lda $063d			lda 	EXTRow 						; already at top ?
.a81b	f0 21		beq $a83e			beq 	_EXPCExit
.a81d	ce 3d 06	dec $063d			dec 	EXTRow 						; up one in position/address
.a820	38		sec				sec
.a821	a5 40		lda $40				lda 	EXTAddress
.a823	ed 40 06	sbc $0640			sbc 	EXTScreenWidth
.a826	85 40		sta $40				sta 	EXTAddress
.a828	b0 14		bcs $a83e			bcs 	_EXPCExit
.a82a	c6 41		dec $41				dec 	EXTAddress+1
.a82c	80 10		bra $a83e			bra 	_EXPCExit
.a82e					_EXPCRight:
.a82e	c8		iny				iny
.a82f	8c 3e 06	sty $063e			sty 	EXTColumn
.a832	cc 40 06	cpy $0640			cpy 	EXTScreenWidth
.a835	d0 07		bne $a83e			bne 	_EXPCExit
.a837					_EXPCEnd:
.a837	ad 40 06	lda $0640			lda 	EXTScreenWidth
.a83a	3a		dec a				dec 	a
.a83b	8d 3e 06	sta $063e			sta 	EXTColumn
.a83e					_EXPCExit:
.a83e	20 20 a9	jsr $a920			jsr 	EXTSetHardwareCursor 		; place the physical cursor.
.a841	68		pla				pla
.a842	85 01		sta $01				sta 	1
.a844	7a		ply				ply
.a845	fa		plx				plx
.a846	68		pla				pla
.a847	60		rts				rts
.a848					_EXPCClearScreen:
.a848	20 dd a8	jsr $a8dd			jsr		EXTClearScreenCode
.a84b	80 f1		bra $a83e			bra 	_EXPCExit
.a84d					_EXPCDown:
.a84d	ad 41 06	lda $0641			lda 	EXTScreenHeight 			; at the bottom
.a850	3a		dec a				dec 	a
.a851	cd 3d 06	cmp $063d			cmp 	EXTRow
.a854	f0 e8		beq $a83e			beq 	_EXPCExit
.a856	ee 3d 06	inc $063d			inc 	EXTRow 						; down one in position/address
.a859	18		clc				clc
.a85a	a5 40		lda $40				lda 	EXTAddress
.a85c	6d 40 06	adc $0640			adc 	EXTScreenWidth
.a85f	85 40		sta $40				sta 	EXTAddress
.a861	90 db		bcc $a83e			bcc 	_EXPCExit
.a863	e6 41		inc $41				inc 	EXTAddress+1
.a865	80 d7		bra $a83e			bra 	_EXPCExit
.a867					_EXPCTab:
.a867	ad 3e 06	lda $063e			lda 	EXTColumn 					; next tab stop
.a86a	29 f8		and #$f8			and 	#$F8
.a86c	18		clc				clc
.a86d	69 08		adc #$08			adc 	#8
.a86f	8d 3e 06	sta $063e			sta 	EXTColumn
.a872	cd 40 06	cmp $0640			cmp 	EXTScreenWidth 				; too far, stick end of line.
.a875	90 c7		bcc $a83e			bcc 	_EXPCExit
.a877	80 be		bra $a837			bra 	_EXPCEnd
.a879					_EXPCBackSpace:
.a879	88		dey				dey
.a87a	30 c2		bmi $a83e			bmi 	_EXPCExit
.a87c	ce 3e 06	dec $063e			dec 	EXTColumn
.a87f	a9 02		lda #$02			lda 	#2
.a881	85 01		sta $01				sta 	1
.a883	a9 20		lda #$20			lda 	#32
.a885	91 40		sta ($40),y			sta 	(EXTAddress),y
.a887	80 b5		bra $a83e			bra 	_EXPCExit
.a889					_EXPCActionTable:
>a889	3e a8						.word 	_EXPCExit 					; 00
>a88b	f9 a7						.word 	_EXPCBegin 					; 01 A Start of Line
>a88d	f4 a7						.word 	_EXPCLeft 					; 02 B Left
>a88f	3e a8						.word 	_EXPCExit 					; 03 <Break>
>a891	3e a8						.word 	_EXPCExit 					; 04
>a893	37 a8						.word 	_EXPCEnd 					; 05 E End of Line
>a895	2e a8						.word 	_EXPCRight 					; 06 F Right
>a897	3e a8						.word 	_EXPCExit 					; 07
>a899	79 a8						.word 	_EXPCBackspace 				; 08 H Backspace
>a89b	67 a8						.word 	_EXPCTab 					; 09 I Tab
>a89d	3e a8						.word 	_EXPCExit 					; 0A
>a89f	3e a8						.word 	_EXPCExit 					; 0B
>a8a1	48 a8						.word 	_EXPCClearScreen			; 0C L CLS
>a8a3	d8 a7						.word 	_EXPCCRLF 					; 0D M CR/LF
>a8a5	4d a8						.word 	_EXPCDown 					; 0E N Down
>a8a7	3e a8						.word 	_EXPCExit 					; 0F
>a8a9	18 a8						.word 	_EXPCUp 					; 10 P Up
.a8ab					_EXPCHandleColour
.a8ab	c9 90		cmp #$90			cmp 	#$90 						; 8x foreground 9x background
.a8ad	b0 16		bcs $a8c5			bcs 	_EXPCBackground
.a8af	0a		asl a				asl 	a 							; shift it 4 bits to the right.
.a8b0	0a		asl a				asl 	a
.a8b1	0a		asl a				asl 	a
.a8b2	0a		asl a				asl 	a
.a8b3	a2 0f		ldx #$0f			ldx 	#$0F 						; Mask in X
.a8b5					_EXPCUpdate:
.a8b5	48		pha				pha 								; save new colour
.a8b6	8a		txa				txa 								; get mask
.a8b7	2d 3f 06	and $063f			and 	EXTTextColour 				; mask out old.
.a8ba	8d 3f 06	sta $063f			sta 	EXTTextColour
.a8bd	68		pla				pla 								; or in new colour
.a8be	0d 3f 06	ora $063f			ora 	EXTTextColour
.a8c1	8d 3f 06	sta $063f			sta 	EXTTextColour
.a8c4	60		rts				rts
.a8c5					_EXPCBackground:
.a8c5	29 0f		and #$0f			and 	#$0F 						; get the colour
.a8c7	a2 f0		ldx #$f0			ldx 	#$F0 						; mask
.a8c9	80 ea		bra $a8b5			bra 	_EXPCUpdate
.a8cb					EXTScreenScroll:
.a8cb	a9 02		lda #$02			lda 	#2 							; select text page
.a8cd	85 01		sta $01				sta 	1
.a8cf	a9 20		lda #$20			lda		#32 						; fill with space
.a8d1	20 e0 a9	jsr $a9e0			jsr 	EXTScrollFill
.a8d4	e6 01		inc $01				inc 	1 							; select colour page
.a8d6	ad 3f 06	lda $063f			lda 	EXTTextColour
.a8d9	20 e0 a9	jsr $a9e0			jsr 	EXTScrollFill
.a8dc	60		rts				rts
.a8dd					EXTClearScreenCode:
.a8dd	a9 02		lda #$02			lda 	#2 							; select text page
.a8df	85 01		sta $01				sta 	1
.a8e1	a9 20		lda #$20			lda		#32 						; fill with space
.a8e3	20 f0 a8	jsr $a8f0			jsr 	_EXTCSFill
.a8e6	e6 01		inc $01				inc 	1 							; select colour page
.a8e8	ad 3f 06	lda $063f			lda 	EXTTextColour
.a8eb	20 f0 a8	jsr $a8f0			jsr 	_EXTCSFill
.a8ee	80 22		bra $a912			bra 	EXTHomeCursor
.a8f0					_EXTCSFill:
.a8f0	aa		tax				tax
.a8f1	a9 00		lda #$00			lda 	#EXTMemory & $FF
.a8f3	85 40		sta $40				sta 	EXTAddress
.a8f5	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a8f7	85 41		sta $41				sta 	EXTAddress+1
.a8f9					_EXTCSFill1:
.a8f9	a0 00		ldy #$00			ldy 	#0
.a8fb	8a		txa				txa
.a8fc					_EXTCSFill2:
.a8fc	91 40		sta ($40),y			sta 	(EXTAddress),y
.a8fe	c8		iny				iny
.a8ff	d0 fb		bne $a8fc			bne 	_EXTCSFill2
.a901	e6 41		inc $41				inc 	EXTAddress+1
.a903	a5 41		lda $41				lda 	EXTAddress+1
.a905	c9 d2		cmp #$d2			cmp 	#$D2
.a907	d0 f0		bne $a8f9			bne 	_EXTCSFill1
.a909	8a		txa				txa
.a90a					_EXTCSFill3:
.a90a	91 40		sta ($40),y			sta 	(EXTAddress),y
.a90c	c8		iny				iny
.a90d	c0 c0		cpy #$c0			cpy 	#$C0
.a90f	d0 f9		bne $a90a			bne 	_EXTCSFill3
.a911	60		rts				rts
.a912					EXTHomeCursor:
.a912	9c 3d 06	stz $063d			stz 	EXTRow 						; reset row & column
.a915	9c 3e 06	stz $063e			stz 	EXTColumn
.a918	a9 00		lda #$00			lda 	#EXTMemory & $FF 			; set address
.a91a	85 40		sta $40				sta 	EXTAddress
.a91c	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a91e	85 41		sta $41				sta 	EXTAddress+1
.a920					EXTSetHardwareCursor:
.a920	64 01		stz $01				stz 	1 							; I/O Page zero
.a922	a9 05		lda #$05			lda 	#1+4 						; enable cursor
.a924	8d 10 d0	sta $d010			sta 	$D010
.a927	a9 b1		lda #$b1			lda 	#$B1
.a929	8d 12 d0	sta $d012			sta 	$D012
.a92c	ad 3e 06	lda $063e			lda 	EXTColumn
.a92f	8d 14 d0	sta $d014			sta 	$D014 						; set cursor position
.a932	9c 15 d0	stz $d015			stz 	$D015
.a935	ad 3d 06	lda $063d			lda 	EXTRow
.a938	8d 16 d0	sta $d016			sta 	$D016
.a93b	9c 17 d0	stz $d017			stz 	$D017
.a93e	60		rts				rts
.a93f					EXTInputLine:
.a93f	48		pha				pha
.a940	da		phx				phx
.a941	5a		phy				phy
.a942	a5 01		lda $01				lda 	1 							; save I/O page
.a944	48		pha				pha
.a945					_EILLoop:
.a945	20 47 aa	jsr $aa47			jsr 	ExtInputSingleCharacter
.a948	c9 0d		cmp #$0d			cmp 	#13 						; scrape line if exit.
.a94a	f0 40		beq $a98c			beq 	_EILExit
.a94c	c9 08		cmp #$08			cmp 	#8 							; handle backspace
.a94e	f0 1c		beq $a96c			beq 	_EILBackspace
.a950	c9 20		cmp #$20			cmp 	#' '						; < space, print it
.a952	90 12		bcc $a966			bcc 	_EILPrintLoop
.a954	c9 7f		cmp #$7f			cmp 	#$7F 						; if -ve print it
.a956	b0 0e		bcs $a966			bcs 	_EILPrintLoop
.a958	48		pha				pha 								; save character
.a959	a9 02		lda #$02			lda 	#2  						; insert a space
.a95b	85 01		sta $01				sta 	1
.a95d	20 ce a9	jsr $a9ce			jsr 	EXTILInsert 				; insert in text screen
.a960	e6 01		inc $01				inc 	1
.a962	20 ce a9	jsr $a9ce			jsr 	EXTILInsert 				; insert in colour screen
.a965	68		pla				pla 								; get character back.
.a966					_EILPrintLoop:
.a966	20 b1 a7	jsr $a7b1			jsr 	ExtPrintCharacter
.a969	80 da		bra $a945			bra 	_EILLoop
.a96b	60		rts				rts
.a96c					_EILBackspace:
.a96c	ad 3e 06	lda $063e			lda 	EXTColumn					; can we backspace ?
.a96f	f0 d4		beq $a945			beq 	_EILLoop
.a971	a9 02		lda #$02			lda 	#2 							; move cursor left
.a973	20 b1 a7	jsr $a7b1			jsr 	EXTPrintCharacter
.a976	a9 02		lda #$02			lda 	#2 							; text block
.a978	85 01		sta $01				sta 	1
.a97a	a9 20		lda #$20			lda 	#' ' 						; backspace text.
.a97c	20 b9 a9	jsr $a9b9			jsr 	EXTILDelete
.a97f	e6 01		inc $01				inc 	1 							; colour block
.a981	ac 3e 06	ldy $063e			ldy 	EXTColumn 					; get attribute of last character
.a984	88		dey				dey
.a985	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a987	20 b9 a9	jsr $a9b9			jsr 	EXTILDelete 				; backspace attribute
.a98a	80 b9		bra $a945			bra 	_EILLoop 					; and go round.
.a98c					_EILExit:
.a98c	a9 02		lda #$02			lda 	#2 							; switch to page 2
.a98e	85 01		sta $01				sta 	1
.a990	a0 00		ldy #$00			ldy 	#0 							; copy current line into buffer.
.a992					_EILScrapeLine:
.a992	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a994	99 a8 05	sta $05a8,y			sta 	lineBuffer,y
.a997	c8		iny				iny
.a998	cc 40 06	cpy $0640			cpy 	EXTScreenWidth
.a99b	d0 f5		bne $a992			bne 	_EILScrapeLine
.a99d					_EILTrimSpaces:
.a99d	88		dey				dey
.a99e	f0 08		beq $a9a8			beq 	_EILEndTrim
.a9a0	b9 a8 05	lda $05a8,y			lda 	lineBuffer,y
.a9a3	c9 20		cmp #$20			cmp 	#' '
.a9a5	f0 f6		beq $a99d			beq 	_EILTrimSpaces
.a9a7	c8		iny				iny 								; trim after non space character.
.a9a8					_EILEndTrim:
.a9a8	a9 00		lda #$00			lda 	#0 							; trim here.
.a9aa	99 a8 05	sta $05a8,y			sta 	lineBuffer,y
.a9ad	a9 0d		lda #$0d			lda 	#13 						; echo the RETURN
.a9af	20 b1 a7	jsr $a7b1			jsr 	ExtPrintCharacter
.a9b2	68		pla				pla 								; reset I/O page
.a9b3	85 01		sta $01				sta 	1
.a9b5	7a		ply				ply
.a9b6	fa		plx				plx
.a9b7	68		pla				pla
.a9b8	60		rts				rts
.a9b9					EXTILDelete:
.a9b9	48		pha				pha 								; save the new character
.a9ba	ac 3e 06	ldy $063e			ldy 	EXTColumn 					; start copying from here.
.a9bd					_EXTDLoop:
.a9bd	c8		iny				iny 								; copy one byte down.
.a9be	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a9c0	88		dey				dey
.a9c1	91 40		sta ($40),y			sta 	(EXTAddress),y
.a9c3	c8		iny				iny 								; do till end of line.
.a9c4	cc 40 06	cpy $0640			cpy 	EXTScreenWidth
.a9c7	90 f4		bcc $a9bd			bcc 	_EXTDLoop
.a9c9	88		dey				dey 	 							; write in last slot.
.a9ca	68		pla				pla
.a9cb	91 40		sta ($40),y			sta 	(EXTAddress),y
.a9cd	60		rts				rts
.a9ce					EXTILInsert:
.a9ce	ac 40 06	ldy $0640			ldy 	EXTScreenWidth 				; end position
.a9d1					_EXTILoop:
.a9d1	88		dey				dey 								; back one
.a9d2	cc 3e 06	cpy $063e			cpy 	EXTColumn 					; exit if reached insert point.
.a9d5	f0 08		beq $a9df			beq 	_EXTIExit
.a9d7	88		dey				dey 								; copy one byte up.
.a9d8	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a9da	c8		iny				iny
.a9db	91 40		sta ($40),y			sta 	(EXTAddress),y
.a9dd	80 f2		bra $a9d1			bra 	_EXTILoop
.a9df					_EXTIExit:
.a9df	60		rts				rts
.a9e0					EXTScrollFill:
.a9e0	aa		tax				tax									; save value to fill with
.a9e1	a5 36		lda $36				lda 	zTemp0 						; save zTemp0 (dest) zTemp1 (src)
.a9e3	48		pha				pha
.a9e4	a5 37		lda $37				lda 	zTemp0+1
.a9e6	48		pha				pha
.a9e7	a5 38		lda $38				lda 	zTemp1
.a9e9	48		pha				pha
.a9ea	a5 39		lda $39				lda 	zTemp1+1
.a9ec	48		pha				pha
.a9ed	a9 c0		lda #$c0			lda 	#$C0 						; copy from C000+length to C000
.a9ef	85 37		sta $37				sta 	zTemp0+1
.a9f1	85 39		sta $39				sta 	zTemp1+1
.a9f3	64 36		stz $36				stz 	zTemp0
.a9f5	ad 40 06	lda $0640			lda 	EXTScreenWidth
.a9f8	85 38		sta $38				sta 	zTemp1
.a9fa	a0 00		ldy #$00			ldy 	#0
.a9fc					_EXSFCopy1:
.a9fc	b1 38		lda ($38),y			lda 	(zTemp1),y
.a9fe	91 36		sta ($36),y			sta 	(zTemp0),y
.aa00	c8		iny				iny
.aa01	d0 f9		bne $a9fc			bne 	_EXSFCopy1
.aa03	e6 37		inc $37				inc 	zTemp0+1 					; next page
.aa05	e6 39		inc $39				inc 	zTemp1+1
.aa07	a5 39		lda $39				lda 	zTemp1+1
.aa09	c9 d3		cmp #$d3			cmp 	#$D3
.aa0b	d0 ef		bne $a9fc			bne 	_EXSFCopy1
.aa0d	ac 40 06	ldy $0640			ldy 	EXTScreenWidth 				; blank the bottom line.
.aa10	8a		txa				txa
.aa11					_EXSFFill1:
.aa11	88		dey				dey
.aa12	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa14	c0 00		cpy #$00			cpy 	#0
.aa16	10 f9		bpl $aa11			bpl 	_EXSFFill1
.aa18	68		pla				pla
.aa19	85 39		sta $39				sta 	zTemp1+1
.aa1b	68		pla				pla
.aa1c	85 38		sta $38				sta 	zTemp1
.aa1e	68		pla				pla
.aa1f	85 37		sta $37				sta 	zTemp0+1
.aa21	68		pla				pla
.aa22	85 36		sta $36				sta 	zTemp0
.aa24	60		rts				rts
=$c000					EXTMemory = $C000
=$02					EXTTextPage = $02
=$03					EXTColourPage = $03
=1					EXTDummySpace = 1 							; fake-space for CR character.
=0					EXTCBlack = 0
.063d					EXTRow:
>063d							.fill 	1
.063e					EXTColumn:
>063e							.fill 	1
.063f					EXTTextColour:
>063f							.fill 	1
.0640					EXTScreenWidth:
>0640							.fill 	1
.0641					EXTScreenHeight:
>0641							.fill 	1
.0040					EXTAddress:
>0040							.fill 	2
.aa25					EXTInitialise:
.aa25	64 01		stz $01				stz 	1 							; Access I/O
.aa27	9c 04 d0	stz $d004			stz 	$D004 						; Disable border
.aa2a	9c 08 d0	stz $d008			stz 	$D008
.aa2d	9c 09 d0	stz $d009			stz 	$D009
.aa30	a9 09		lda #$09			lda 	#1+8						; Timer On at 70Hz counting up.
.aa32	8d 58 d6	sta $d658			sta 	$D658
.aa35	a9 76		lda #$76			lda 	#CONForeground * 16 + CONBackground
.aa37	8d 3f 06	sta $063f			sta 	EXTTextColour
.aa3a	a9 50		lda #$50			lda 	#80 						; set screen dimensions.
.aa3c	8d 40 06	sta $0640			sta 	EXTScreenWidth
.aa3f	a9 3c		lda #$3c			lda 	#60
.aa41	8d 41 06	sta $0641			sta 	EXTScreenHeight
.aa44	64 01		stz $01				stz 	1
.aa46	60		rts				rts
.aa47					EXTInputSingleCharacter:
.aa47	da		phx				phx
.aa48	5a		phy				phy
.aa49					_EISCWait:
.aa49	20 e4 ff	jsr $ffe4			jsr 	$FFE4
.aa4c	c9 00		cmp #$00			cmp 	#0
.aa4e	f0 f9		beq $aa49			beq 	_EISCWait
.aa50	7a		ply				ply
.aa51	fa		plx				plx
.aa52	60		rts				rts
.aa53					EXTBreakCheck:
.aa53	4c e1 ff	jmp $ffe1			jmp		$FFE1
.aa56					EXTReadController:
.aa56	da		phx				phx
.aa57	a2 00		ldx #$00			ldx 	#0
.aa59	a9 05		lda #$05			lda 	#(($2D) >> 3)
.aa5b	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa5e	29 20		and #$20			and 	#($01 << (($2D) & 7))
.aa60	f0 04		beq $aa66			beq 	_NoSet1
.aa62	8a		txa				txa
.aa63	09 01		ora #$01			ora 	#1
.aa65	aa		tax				tax
.aa66					_NoSet1:
.aa66	a9 05		lda #$05			lda 	#(($2C) >> 3)
.aa68	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa6b	29 10		and #$10			and 	#($01 << (($2C) & 7))
.aa6d	f0 04		beq $aa73			beq 	_NoSet1
.aa6f	8a		txa				txa
.aa70	09 02		ora #$02			ora 	#2
.aa72	aa		tax				tax
.aa73					_NoSet1:
.aa73	a9 06		lda #$06			lda 	#(($32) >> 3)
.aa75	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa78	29 04		and #$04			and 	#($01 << (($32) & 7))
.aa7a	f0 04		beq $aa80			beq 	_NoSet1
.aa7c	8a		txa				txa
.aa7d	09 04		ora #$04			ora 	#4
.aa7f	aa		tax				tax
.aa80					_NoSet1:
.aa80	a9 04		lda #$04			lda 	#(($25) >> 3)
.aa82	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa85	29 20		and #$20			and 	#($01 << (($25) & 7))
.aa87	f0 04		beq $aa8d			beq 	_NoSet1
.aa89	8a		txa				txa
.aa8a	09 08		ora #$08			ora 	#8
.aa8c	aa		tax				tax
.aa8d					_NoSet1:
.aa8d	a9 04		lda #$04			lda 	#(($26) >> 3)
.aa8f	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa92	29 40		and #$40			and 	#($01 << (($26) & 7))
.aa94	f0 04		beq $aa9a			beq 	_NoSet1
.aa96	8a		txa				txa
.aa97	09 10		ora #$10			ora 	#16
.aa99	aa		tax				tax
.aa9a					_NoSet1:
.aa9a	8a		txa				txa
.aa9b	fa		plx				plx
.aa9c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_graphics.module

=1					graphicsIntegrated=1
=0					GCMD_Initialise = 0*2
=2					GCMD_BitmapCtl = 1*2
=4					GCMD_SpriteCtl = 2*2
=6					GCMD_Clear = 3*2
=8					GCMD_Colour = 4*2
=10					GCMD_DrawFont = 5*2
=12					GCMD_DrawSprite = 6*2
=14					GCMD_SpriteUse = 7*2
=16					GCMD_SpriteImage = 8*2
=18					GCMD_SpriteCollide = 9*2
=64					GCMD_Move = 32*2
=66					GCMD_Line = 33*2
=68					GCMD_FrameRect = 34*2
=70					GCMD_FillRect = 35*2
=72					GCMD_FrameCircle = 36*2
=74					GCMD_FillCircle = 37*2
=80					GCMD_Plot = 40*2
=82					GCMD_SpriteMove = 41*2
=42					GRFirstFreeCode = 42
.b959					GRVectorTable:
>b959	98 ac					.word	GXInitialise             ; $00 Initialise
>b95b	b2 ac					.word	GXControlBitmap          ; $01 BitmapCtl
>b95d	fa ac					.word	GXControlSprite          ; $02 SpriteCtl
>b95f	4a ac					.word	GXClearBitmap            ; $03 Clear
>b961	89 ae					.word	GXSetColourMode          ; $04 Colour
>b963	51 b0					.word	GXFontHandler            ; $05 DrawFont
>b965	99 b0					.word	GXSpriteHandler          ; $06 DrawSprite
>b967	05 b1					.word	GXSelect                 ; $07 SpriteUse
>b969	2e b1					.word	GXSelectImage            ; $08 SpriteImage
>b96b	b5 b2					.word	GXCollide                ; $09 SpriteCollide
>b96d	fc aa					.word	GRUndefined              ; $0a
>b96f	fc aa					.word	GRUndefined              ; $0b
>b971	fc aa					.word	GRUndefined              ; $0c
>b973	fc aa					.word	GRUndefined              ; $0d
>b975	fc aa					.word	GRUndefined              ; $0e
>b977	fc aa					.word	GRUndefined              ; $0f
>b979	fc aa					.word	GRUndefined              ; $10
>b97b	fc aa					.word	GRUndefined              ; $11
>b97d	fc aa					.word	GRUndefined              ; $12
>b97f	fc aa					.word	GRUndefined              ; $13
>b981	fc aa					.word	GRUndefined              ; $14
>b983	fc aa					.word	GRUndefined              ; $15
>b985	fc aa					.word	GRUndefined              ; $16
>b987	fc aa					.word	GRUndefined              ; $17
>b989	fc aa					.word	GRUndefined              ; $18
>b98b	fc aa					.word	GRUndefined              ; $19
>b98d	fc aa					.word	GRUndefined              ; $1a
>b98f	fc aa					.word	GRUndefined              ; $1b
>b991	fc aa					.word	GRUndefined              ; $1c
>b993	fc aa					.word	GRUndefined              ; $1d
>b995	fc aa					.word	GRUndefined              ; $1e
>b997	fc aa					.word	GRUndefined              ; $1f
>b999	fa aa					.word	GXMove                   ; $20 Move
>b99b	57 ad					.word	GXLine                   ; $21 Line
>b99d	d2 ae					.word	GXFrameRectangle         ; $22 FrameRect
>b99f	cf ae					.word	GXFillRectangle          ; $23 FillRect
>b9a1	01 ab					.word	GXFrameCircle            ; $24 FrameCircle
>b9a3	fd aa					.word	GXFillCircle             ; $25 FillCircle
>b9a5	fc aa					.word	GRUndefined              ; $26
>b9a7	fc aa					.word	GRUndefined              ; $27
>b9a9	b7 ae					.word	GXPlotPoint              ; $28 Plot
>b9ab	c4 b1					.word	GXMoveSprite             ; $29 SpriteMove
=3					GXMappingPage = 3
=24576					GXMappingAddress = ($2000 * GXMappingPage)
=11					GXEditSlot = 8 + GXMappingPage
=$36					gxzTemp0 = zTemp0
=$38					gxzTemp1 = zTemp1
=$3a					gxzTemp2 = zTemp2
=$3c					gxzScreen = zsTemp
=$5f9					gxPixelBuffer = numberBuffer
.0642					gxCurrentX:
>0642							.fill 	2
.0644					gxCurrentY:
>0644							.fill 	2
.0646					gxLastX:
>0646							.fill 	2
.0648					gxLastY:
>0648							.fill 	2
.064a					gxX0:
>064a							.fill 	2
.064c					gxY0:
>064c							.fill 	2
.064e					gxX1:
>064e							.fill 	2
.0650					gxY1:
>0650							.fill 	2
.0652					gxSpritesOn:
>0652							.fill 	1
.0653					gxBitmapsOn:
>0653							.fill 	1
.0654					gxBasePage:
>0654							.fill 	1
.0655					gxSpritePage:
>0655							.fill 	1
.0656					gxHeight:
>0656							.fill 	1
.0657					gxMode:
>0657							.fill 	1
.0658					gxColour:
>0658							.fill 	1
.0659					gxEORValue:
>0659							.fill 	1
.065a					gxANDValue:
>065a							.fill 	1
.065b					gxOriginalLUTValue:
>065b							.fill 	1
.065c					gsOffset:
>065c							.fill 	1
.065d					GSCurrentSpriteID:
>065d							.fill 	1
.065e					GSCurrentSpriteAddr:
>065e							.fill 	2
.0660					GXSpriteOffsetBase:
>0660							.fill 	2
.0662					GXSpriteLow:
>0662							.fill 	64
.06a2					GXSpriteHigh:
>06a2							.fill 	64
.aa9d					GXGraphicDraw:
.aa9d	c9 40		cmp #$40			cmp 	#GCMD_Move					; low instructions don't use coordinates
.aa9f	b0 06		bcs $aaa7			bcs 	_GDCoordinate
.aaa1	86 36		stx $36				stx 	gxzTemp0 					; save X/Y
.aaa3	84 37		sty $37				sty 	gxzTemp0+1
.aaa5	80 4b		bra $aaf2			bra 	_GDExecuteA 				; and execute
.aaa7					_GDCoordinate:
.aaa7	48		pha				pha 								; save AXY
.aaa8	da		phx				phx
.aaa9	5a		phy				phy
.aaaa	a2 03		ldx #$03			ldx 	#3 							; copy currentX to lastX
.aaac					_GDCopy1:
.aaac	bd 42 06	lda $0642,x			lda 	gxCurrentX,x
.aaaf	9d 46 06	sta $0646,x			sta 	gxLastX,x
.aab2	ca		dex				dex
.aab3	10 f7		bpl $aaac			bpl 	_GDCopy1
.aab5	68		pla				pla 								; update Y
.aab6	8d 44 06	sta $0644			sta 	gxCurrentY
.aab9	9c 45 06	stz $0645			stz 	gxCurrentY+1
.aabc	68		pla				pla
.aabd	8d 42 06	sta $0642			sta 	gxCurrentX
.aac0	68		pla				pla 								; get A (command+X.1) back
.aac1	48		pha				pha
.aac2	29 01		and #$01			and 	#1 							; put LSB as MSB of Current.X
.aac4	8d 43 06	sta $0643			sta 	gxCurrentX+1
.aac7	68		pla				pla 								; get command back
.aac8	29 fe		and #$fe			and 	#$FE 						; lose LSB, chuck the stray X bit
.aaca	48		pha				pha 								; push back.
.aacb	c9 52		cmp #$52			cmp 	#GCMD_SpriteMove 			; move sprite does not clip.
.aacd	f0 17		beq $aae6			beq 	_GDCopyToWorkArea
.aacf	ad 43 06	lda $0643			lda 	gxCurrentX+1 				; X < 256 X okay
.aad2	f0 07		beq $aadb			beq 	_GDCheckY
.aad4	ad 42 06	lda $0642			lda 	gxCurrentX 					; otherwise X < 320 = 256 + 64
.aad7	c9 40		cmp #$40			cmp 	#64
.aad9	b0 08		bcs $aae3			bcs 	_GDError1
.aadb					_GDCheckY:
.aadb	ad 44 06	lda $0644			lda 	gxCurrentY 					; check Y < Height.
.aade	cd 56 06	cmp $0656			cmp 	gxHeight
.aae1	90 03		bcc $aae6			bcc 	_GDCopyToWorkArea
.aae3					_GDError1:
.aae3	68		pla				pla
.aae4					_GDError2:
.aae4	38		sec				sec
.aae5	60		rts				rts
.aae6					_GDCopyToWorkArea:
.aae6	a2 07		ldx #$07			ldx 	#7 							; copy current and last to gxXY/12 work area
.aae8					_GDCopy2:
.aae8	bd 42 06	lda $0642,x			lda 	gxCurrentX,x
.aaeb	9d 4a 06	sta $064a,x			sta 	gxX0,x
.aaee	ca		dex				dex
.aaef	10 f7		bpl $aae8			bpl 	_GDCopy2
.aaf1	68		pla				pla 								; get command
.aaf2					_GDExecuteA:
.aaf2	c9 54		cmp #$54			cmp 	#GRFirstFreeCode*2 			; bad ?
.aaf4	b0 ee		bcs $aae4			bcs 	_GDError2
.aaf6	aa		tax				tax
.aaf7	7c 59 b9	jmp ($b959,x)			jmp 	(GRVectorTable,x)
.aafa					GXMove:
.aafa	18		clc				clc
.aafb	60		rts				rts
.aafc					GRUndefined:
>aafc	db						.byte 	$DB 						; causes a break in the emulator
.aafd					GXFillCircle:
.aafd	a9 ff		lda #$ff			lda 	#255
.aaff	80 02		bra $ab03			bra 	GXCircle
.ab01					GXFrameCircle:
.ab01	a9 00		lda #$00			lda 	#0
.ab03					GXCircle:
.ab03	8d e5 06	sta $06e5			sta 	gxIsFillMode					; save Fill flag
.ab06	ad 53 06	lda $0653			lda 	gxBitmapsOn
.ab09	f0 26		beq $ab31			beq 	_GXCFail
.ab0b	20 5c b3	jsr $b35c			jsr 	GXSortXY 					; topleft/bottomright
.ab0e	20 34 b2	jsr $b234			jsr 	GXOpenBitmap 				; start drawing
.ab11	20 03 ac	jsr $ac03			jsr 	GXCircleSetup 				; set up for drawing
.ab14	9c e6 06	stz $06e6			stz 	gxYChanged
.ab17					_GXCircleDraw:
.ab17	ad e3 06	lda $06e3			lda 	gXCentre					; while x <= y
.ab1a	cd e4 06	cmp $06e4			cmp 	gYCentre
.ab1d	90 0a		bcc $ab29			bcc 	_GXCircleContinue
.ab1f	d0 03		bne $ab24			bne 	_GXNoLast
.ab21	20 36 ab	jsr $ab36			jsr 	GXPlot1
.ab24					_GXNoLast:
.ab24	20 3c b2	jsr $b23c			jsr 	GXCloseBitmap 				; close the bitmap
.ab27	18		clc				clc
.ab28	60		rts				rts
.ab29					_GXCircleContinue:
.ab29	20 33 ab	jsr $ab33			jsr 	GXPlot2 					; draw it
.ab2c	20 b0 ab	jsr $abb0			jsr 	GXCircleMove 				; adjust the coordinates
.ab2f	80 e6		bra $ab17			bra 	_GXCircleDraw
.ab31					_GXCFail:
.ab31	38		sec				sec
.ab32	60		rts				rts
.ab33					GXPlot2:
.ab33	20 36 ab	jsr $ab36			jsr 	GXPlot1 						; plot and swap, fall through does twice
.ab36					GXPlot1:
.ab36	ad e4 06	lda $06e4			lda 	gYCentre 						; if y = 0, don't do it twice (xor)
.ab39	f0 03		beq $ab3e			beq 	_GXPlot1Only
.ab3b	20 5a ab	jsr $ab5a			jsr 	GXPlot0 						; plot and negate
.ab3e					_GXPlot1Only:
.ab3e	20 5a ab	jsr $ab5a			jsr 	GXPlot0 						; twice, undoing negation
.ab41	ad e3 06	lda $06e3			lda 	gXCentre 						; swap X and Y
.ab44	ae e4 06	ldx $06e4			ldx	 	gYCentre
.ab47	8d e4 06	sta $06e4			sta 	gYCentre
.ab4a	8e e3 06	stx $06e3			stx 	gXCentre
.ab4d	ad e6 06	lda $06e6			lda 	gxYChanged 						; toggle Y Changed flag
.ab50	a9 ff		lda #$ff			lda 	#$FF
.ab52	8d e6 06	sta $06e6			sta 	gxYChanged
.ab55	60		rts				rts
.ab56	20 5a ab	jsr $ab5a			jsr 	GXPlot0 						; do once
.ab59	60		rts				rts
.ab5a	ad e5 06	lda $06e5	GXPlot0:lda 	gxIsFillMode 					; outline mode, always draw as X or Y will change
.ab5d	f0 05		beq $ab64			beq 	_GXPlot0Always
.ab5f	ad e6 06	lda $06e6			lda 	gxYChanged						; fill mode, only draw if changed.
.ab62	f0 2d		beq $ab91			beq 	GXPlot0Exit
.ab64					_GXPlot0Always:
.ab64	a2 02		ldx #$02			ldx 	#2 								; copy Y1-A => Y0
.ab66	ad e4 06	lda $06e4			lda 	gYCentre
.ab69	20 92 ab	jsr $ab92			jsr 	GXSubCopy
.ab6c	a2 00		ldx #$00			ldx 	#0 								; copy X1-A => X0,
.ab6e	ad e3 06	lda $06e3			lda 	gXCentre
.ab71	20 92 ab	jsr $ab92			jsr 	GXSubCopy
.ab74	48		pha				pha 									; save last offset X
.ab75	20 44 b2	jsr $b244			jsr 	GXPositionCalc 					; calculate position/offset.
.ab78	68		pla				pla
.ab79	0a		asl a				asl 	a 								; store 2 x last offset in gxzTemp0
.ab7a	85 36		sta $36				sta 	gxzTemp0
.ab7c	64 37		stz $37				stz 	gxzTemp0+1
.ab7e	26 37		rol $37				rol 	gxzTemp0+1
.ab80	ad e5 06	lda $06e5			lda 	gxIsFillMode
.ab83	69 80		adc #$80			adc 	#128
.ab85	20 22 af	jsr $af22			jsr 	GXDrawLineTemp0 				; routine from Rectangle.
.ab88	38		sec				sec 									; GY = -GY
.ab89	a9 00		lda #$00			lda 	#0
.ab8b	ed e4 06	sbc $06e4			sbc 	gYCentre
.ab8e	8d e4 06	sta $06e4			sta 	gYCentre
.ab91					GXPlot0Exit:
.ab91	60		rts				rts
.ab92					GXSubCopy:
.ab92	85 36		sta $36				sta 	gxzTemp0
.ab94	64 37		stz $37				stz 	gxzTemp0+1
.ab96	29 80		and #$80			and 	#$80
.ab98	f0 02		beq $ab9c			beq 	_GXNoSx
.ab9a	c6 37		dec $37				dec 	gxzTemp0+1
.ab9c					_GXNoSx:
.ab9c	38		sec				sec
.ab9d	bd 4e 06	lda $064e,x			lda 	gXX1,x
.aba0	e5 36		sbc $36				sbc 	gxzTemp0
.aba2	9d 4a 06	sta $064a,x			sta 	gXX0,x
.aba5	bd 4f 06	lda $064f,x			lda 	gXX1+1,x
.aba8	e5 37		sbc $37				sbc 	gxzTemp0+1
.abaa	9d 4b 06	sta $064b,x			sta 	gXX0+1,x
.abad	a5 36		lda $36				lda 	gxzTemp0 						; return A
.abaf	60		rts				rts
.abb0					GXCircleMove:
.abb0	9c e6 06	stz $06e6			stz 	gxYChanged 					; clear Y changed flag
.abb3	a5 39		lda $39				lda 	gxzTemp1+1 					; check sign of D
.abb5	10 0d		bpl $abc4			bpl 	_GXEMPositive
.abb7	ee e3 06	inc $06e3			inc 	gXCentre 					; X++
.abba	ad e3 06	lda $06e3			lda 	gXCentre
.abbd	20 e3 ab	jsr $abe3			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.abc0	a9 06		lda #$06			lda 	#6  						; and add 6
.abc2	80 15		bra $abd9			bra 	_GXEMAddD
.abc4					_GXEMPositive:
.abc4	ee e3 06	inc $06e3			inc 	gXCentre					; X++
.abc7	ce e4 06	dec $06e4			dec 	gyCentre 					; Y--
.abca	38		sec				sec 								; calculate X-Y
.abcb	ad e3 06	lda $06e3			lda 	gXCentre
.abce	ed e4 06	sbc $06e4			sbc 	gYCentre
.abd1	20 e3 ab	jsr $abe3			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.abd4	a9 0a		lda #$0a			lda 	#10  						; and add 10
.abd6	ce e6 06	dec $06e6			dec 	gxYChanged
.abd9					_GXEMAddD:
.abd9	18		clc				clc
.abda	65 38		adc $38				adc 	gxzTemp1
.abdc	85 38		sta $38				sta 	gxzTemp1
.abde	90 02		bcc $abe2			bcc 	_GXEMNoCarry
.abe0	e6 39		inc $39				inc 	gxzTemp1+1
.abe2					_GXEMNoCarry:
.abe2	60		rts				rts
.abe3					_GXAdd4TimesToD:
.abe3	85 36		sta $36				sta 	gxzTemp0 					; make 16 bit signed.
.abe5	29 80		and #$80			and 	#$80
.abe7	f0 02		beq $abeb			beq 	_GXA4Unsigned
.abe9	a9 ff		lda #$ff			lda 	#$FF
.abeb					_GXA4Unsigned:
.abeb	85 37		sta $37				sta 	gxzTemp0+1
.abed	06 36		asl $36				asl 	gxzTemp0  					; x 4
.abef	26 37		rol $37				rol 	gxzTemp0+1
.abf1	06 36		asl $36				asl 	gxzTemp0
.abf3	26 37		rol $37				rol 	gxzTemp0+1
.abf5	18		clc				clc 								; add
.abf6	a5 36		lda $36				lda		gxzTemp0
.abf8	65 38		adc $38				adc 	gxzTemp1
.abfa	85 38		sta $38				sta 	gxzTemp1
.abfc	a5 37		lda $37				lda		gxzTemp0+1
.abfe	65 39		adc $39				adc 	gxzTemp1+1
.ac00	85 39		sta $39				sta 	gxzTemp1+1
.ac02	60		rts				rts
.ac03					GXCircleSetup:
.ac03	38		sec				sec
.ac04	ad 50 06	lda $0650			lda 	gxY1
.ac07	ed 4c 06	sbc $064c			sbc 	gxY0
.ac0a	4a		lsr a				lsr 	a
.ac0b	8d e2 06	sta $06e2			sta 	gxRadius
.ac0e	a2 00		ldx #$00			ldx 	#0
.ac10	20 32 ac	jsr $ac32			jsr 	_GXCalculateCentre
.ac13	a2 02		ldx #$02			ldx 	#2
.ac15	20 32 ac	jsr $ac32			jsr 	_GXCalculateCentre
.ac18	9c e3 06	stz $06e3			stz 	gXCentre
.ac1b	ad e2 06	lda $06e2			lda 	gxRadius
.ac1e	8d e4 06	sta $06e4			sta 	gYCentre
.ac21	0a		asl a				asl 	a 							; R x 2
.ac22	85 36		sta $36				sta 	gxzTemp0
.ac24	38		sec				sec
.ac25	a9 03		lda #$03			lda 	#3
.ac27	e5 36		sbc $36				sbc 	gxzTemp0
.ac29	85 38		sta $38				sta 	gxzTemp1
.ac2b	a9 00		lda #$00			lda 	#0
.ac2d	e9 00		sbc #$00			sbc 	#0
.ac2f	85 39		sta $39				sta 	gxzTemp1+1
.ac31	60		rts				rts
.ac32					_GXCalculateCentre:
.ac32	38		sec				sec
.ac33	bd 4e 06	lda $064e,x			lda 	gxX1,x
.ac36	7d 4a 06	adc $064a,x			adc 	gXX0,x
.ac39	9d 4e 06	sta $064e,x			sta 	gXX1,x
.ac3c	bd 4f 06	lda $064f,x			lda 	gXX1+1,x
.ac3f	7d 4b 06	adc $064b,x			adc 	gXX0+1,x
.ac42	4a		lsr a				lsr 	a
.ac43	9d 4f 06	sta $064f,x			sta 	gXX1+1,x
.ac46	7e 4e 06	ror $064e,x			ror 	gXX1,x
.ac49	60		rts				rts
.06e2					gxRadius:
>06e2							.fill 	1
.06e3					gXCentre:
>06e3							.fill 	1
.06e4					gYCentre:
>06e4							.fill 	1
.06e5					gxIsFillMode:
>06e5							.fill 	1
.06e6					gxYChanged:
>06e6							.fill  	1
=64000					ScreenSize200 = 320 * 200
=76800					ScreenSize240 = 320 * 240
.ac4a					GXClearBitmap:
.ac4a	ad 53 06	lda $0653			lda 	gxBitmapsOn 				; check BMP running.
.ac4d	f0 24		beq $ac73			beq 	_GXCBFail
.ac4f	20 34 b2	jsr $b234			jsr 	GXOpenBitmap 				; start access
.ac52	a0 07		ldy #$07			ldy 	#ScreenSize200 / 8192 		; X is pages to clear
.ac54	ad 56 06	lda $0656			lda 	gxHeight
.ac57	c9 c8		cmp #$c8			cmp 	#200 						; 200 ?
.ac59	a0 09		ldy #$09			ldy 	#ScreenSize240 / 8192
.ac5b					_GXCalcLastPage:
.ac5b	98		tya				tya 								; add to base page
.ac5c	18		clc				clc
.ac5d	6d 54 06	adc $0654			adc 	gxBasePage
.ac60	85 0b		sta $0b				sta 	GXEditSlot  				; clear from this page back
.ac62					_GXClearAll:
.ac62	20 75 ac	jsr $ac75			jsr 	_GXClearBlock 				; clear 8k block
.ac65	c6 0b		dec $0b				dec 	GXEditSlot  				; back to previous
.ac67	a5 0b		lda $0b				lda 	GXEditSlot
.ac69	cd 54 06	cmp $0654			cmp 	gxBasePage 					; until before base page
.ac6c	b0 f4		bcs $ac62			bcs 	_GXClearAll
.ac6e	20 3c b2	jsr $b23c			jsr 	GXCloseBitmap	 			; stop access
.ac71	18		clc				clc
.ac72	60		rts				rts
.ac73					_GXCBFail:
.ac73	38		sec				sec
.ac74	60		rts				rts
.ac75					_GXClearBlock:
.ac75	a9 00		lda #$00			lda 	#((GXMappingAddress) & $FF)
.ac77	85 38		sta $38				sta 	0+gxzTemp1
.ac79	a9 60		lda #$60			lda 	#((GXMappingAddress) >> 8)
.ac7b	85 39		sta $39				sta 	1+gxzTemp1
.ac7d					_GXCB0:
.ac7d	a5 36		lda $36				lda 	gxzTemp0
.ac7f	a0 00		ldy #$00			ldy 	#0
.ac81					_GXCB1:
.ac81	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ac83	c8		iny				iny
.ac84	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ac86	c8		iny				iny
.ac87	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ac89	c8		iny				iny
.ac8a	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ac8c	c8		iny				iny
.ac8d	d0 f2		bne $ac81			bne 	_GXCB1
.ac8f	e6 39		inc $39				inc 	gxzTemp1+1
.ac91	a5 39		lda $39				lda 	gxzTemp1+1
.ac93	c9 80		cmp #$80			cmp	 	#(GXMappingAddress >> 8)+$20
.ac95	d0 e6		bne $ac7d			bne 	_GXCB0
.ac97	60		rts				rts
.ac98					GXInitialise:
.ac98	64 01		stz $01				stz 	1
.ac9a	a9 01		lda #$01			lda 	#1
.ac9c	8d 00 d0	sta $d000			sta 	$D000
.ac9f	18		clc				clc
.aca0	9c 52 06	stz $0652			stz 	GXSpritesOn
.aca3	9c 53 06	stz $0653			stz 	GXBitmapsOn
.aca6	a2 0f		ldx #$0f			ldx 	#15
.aca8					_GXIClear:
.aca8	9e 42 06	stz $0642,x			stz 	gxCurrentX,x
.acab	ca		dex				dex
.acac	10 fa		bpl $aca8			bpl 	_GXIClear
.acae	20 49 ad	jsr $ad49			jsr 	GXClearSpriteStore
.acb1	60		rts				rts
.acb2					GXControlBitmap:
.acb2	64 01		stz $01				stz 	1
.acb4	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.acb6	29 01		and #$01			and 	#1 							; set bitmap flag
.acb8	8d 53 06	sta $0653			sta 	gxBitmapsOn
.acbb	4a		lsr a				lsr 	a 							; bit 0 into carry.
.acbc	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.acbf	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.acc1	29 f7		and #$f7			and 	#$F7 						; clear bitmap bit
.acc3	90 02		bcc $acc7			bcc 	_CBNotOn
.acc5	09 08		ora #$08			ora 	#$08 						; bitmap on if 1 on 0 off
.acc7					_CBNotOn:
.acc7	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.acca	a5 36		lda $36				lda 	gxzTemp0 					; get control settings (bits 0-2)
.accc	29 07		and #$07			and 	#7
.acce	8d 00 d1	sta $d100			sta 	$D100 						; write in Vicky Bitmap Control Register #0
.acd1	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.acd3	d0 02		bne $acd7			bne 	_CBNotDefault
.acd5	a9 08		lda #$08			lda 	#8  						; if zero, use 8 e.g. bitmap at $10000
.acd7					_CBNotDefault:
.acd7	8d 54 06	sta $0654			sta 	gxBasePage
.acda	20 3b ad	jsr $ad3b			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.acdd	a5 37		lda $37				lda 	gxzTemp0+1 					; copy address into Bitmap address registers
.acdf	8d 03 d1	sta $d103			sta 	$D103
.ace2	a5 36		lda $36				lda 	gxzTemp0
.ace4	8d 02 d1	sta $d102			sta 	$D102
.ace7	9c 01 d1	stz $d101			stz 	$D101
.acea	a2 f0		ldx #$f0			ldx 	#240 						; height is 240
.acec	ad 01 d0	lda $d001			lda 	$D001 						; read MCR bit 0
.acef	29 01		and #$01			and 	#1
.acf1	f0 02		beq $acf5			beq 	_CBHaveHeight
.acf3	a2 c8		ldx #$c8			ldx 	#200 						; if bit 0 set 320x200
.acf5					_CBHaveHeight
.acf5	8e 56 06	stx $0656			stx 	gxHeight
.acf8	18		clc				clc
.acf9	60		rts				rts
.acfa					GXControlSprite:
.acfa	64 01		stz $01				stz 	1
.acfc	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.acfe	29 01		and #$01			and 	#1 							; set sprites flag
.ad00	8d 52 06	sta $0652			sta 	gxSpritesOn
.ad03	4a		lsr a				lsr 	a 							; bit 0 into carry.
.ad04	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.ad07	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.ad09	29 df		and #$df			and 	#$DF 						; clear sprite bit
.ad0b	90 02		bcc $ad0f			bcc 	_CSNotOn
.ad0d	09 20		ora #$20			ora 	#$20 						; sprite on if 1 on 0 off
.ad0f					_CSNotOn:
.ad0f	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.ad12	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.ad14	d0 02		bne $ad18			bne 	_CSNotDefault
.ad16	a9 18		lda #$18			lda 	#24  						; if zero, use 24 e.g. sprites at $30000
.ad18					_CSNotDefault:
.ad18	8d 55 06	sta $0655			sta 	gxSpritePage
.ad1b	20 3b ad	jsr $ad3b			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.ad1e	a5 36		lda $36				lda 	zTemp0
.ad20	8d 60 06	sta $0660			sta 	GXSpriteOffsetBase
.ad23	a5 37		lda $37				lda 	zTemp0+1
.ad25	8d 61 06	sta $0661			sta 	GXSpriteOffsetBase+1
.ad28	a2 00		ldx #$00			ldx 	#0 							; disable all sprites, clears all sprite memory.
.ad2a					_CSClear:
.ad2a	9e 00 d9	stz $d900,x			stz 	$D900,x
.ad2d	9e 00 da	stz $da00,x			stz 	$DA00,x
.ad30	ca		dex				dex
.ad31	d0 f7		bne $ad2a			bne 	_CSClear
.ad33	9c 5f 06	stz $065f			stz 	GSCurrentSpriteAddr+1 		; no sprite selected.
.ad36	20 49 ad	jsr $ad49			jsr 	GXClearSpriteStore
.ad39	18		clc				clc
.ad3a	60		rts				rts
.ad3b					GXCalculateBaseAddress:
.ad3b	85 36		sta $36				sta 	gxzTemp0
.ad3d	64 37		stz $37				stz 	gxzTemp0+1
.ad3f	a9 05		lda #$05			lda 	#5
.ad41					_GXShift:
.ad41	06 36		asl $36				asl 	gxzTemp0
.ad43	26 37		rol $37				rol 	gxzTemp0+1
.ad45	3a		dec a				dec		a
.ad46	d0 f9		bne $ad41			bne 	_GXShift
.ad48	60		rts				rts
.ad49					GXClearSpriteStore:
.ad49	a2 3f		ldx #$3f			ldx 	#63 						; erase 64 sprite store elements
.ad4b					_GXCSSLoop:
.ad4b	9e a2 06	stz $06a2,x			stz 	GXSpriteHigh,x
.ad4e	a9 80		lda #$80			lda 	#$80 						; set the 'hidden' bit.
.ad50	9d 62 06	sta $0662,x			sta 	GXSpriteLow,x
.ad53	ca		dex				dex
.ad54	10 f5		bpl $ad4b			bpl 	_GXCSSLoop
.ad56	60		rts				rts
.ad57					GXLine:
.ad57	ad 53 06	lda $0653			lda 	GXBitmapsOn
.ad5a	f0 28		beq $ad84			beq 	_GXLFail
.ad5c	20 34 b2	jsr $b234			jsr 	GXOpenBitmap
.ad5f	20 7a b3	jsr $b37a			jsr 	GXSortY						; sort pairs so Y1 >= Y0 e.g. top to bottom.
.ad62	20 2a ae	jsr $ae2a			jsr 	GXLineSetup 				; the calculations in the linescanner constructor
.ad65	20 44 b2	jsr $b244			jsr 	GXPositionCalc 				; calculate position/offset.
.ad68					_GXDrawLoop:
.ad68	ac 5c 06	ldy $065c			ldy 	gsOffset 					; draw the pixel
.ad6b	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.ad6d	2d 5a 06	and $065a			and 	gxANDValue
.ad70	4d 59 06	eor $0659			eor 	gxEORValue
.ad73	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.ad75	20 86 ad	jsr $ad86			jsr 	GXLineIsComplete 			; is the line complete ?
.ad78	f0 05		beq $ad7f			beq 	_GXLExit
.ad7a	20 a1 ad	jsr $ada1			jsr 	GXLineAdvance 				; code as per advance method
.ad7d	80 e9		bra $ad68			bra 	_GXDrawLoop
.ad7f					_GXLExit:
.ad7f	20 3c b2	jsr $b23c			jsr 	GXCloseBitmap
.ad82	18		clc				clc
.ad83	60		rts				rts
.ad84					_GXLFail:
.ad84	38		sec				sec
.ad85	60		rts				rts
.ad86					GXLineIsComplete:
.ad86	ad e9 06	lda $06e9			lda 	GXIsDiffYLarger 			; is dy larger
.ad89	d0 0f		bne $ad9a			bne 	_GXLICCompareY 				; if so compare Y1/Y0
.ad8b	ad 4a 06	lda $064a			lda 	GXX0 						; compare X, LSB and MSB
.ad8e	4d 4e 06	eor $064e			eor 	GXX1
.ad91	d0 06		bne $ad99			bne 	_GXLICExit
.ad93	ad 4b 06	lda $064b			lda 	GXX0+1
.ad96	4d 4f 06	eor $064f			eor 	GXX1+1
.ad99					_GXLICExit:
.ad99	60		rts				rts
.ad9a					_GXLICCompareY:
.ad9a	ad 50 06	lda $0650			lda 	GXY1
.ad9d	4d 4c 06	eor $064c			eor 	GXY0
.ada0	60		rts				rts
.ada1					GXLineAdvance:
.ada1	18		clc				clc 								; add adjust to position
.ada2	ad eb 06	lda $06eb			lda 	GXPosition
.ada5	6d ec 06	adc $06ec			adc 	GXAdjust
.ada8	8d eb 06	sta $06eb			sta 	GXPosition
.adab	9c ee 06	stz $06ee			stz 	GXAddSelect 				; clear add select flag
.adae	b0 05		bcs $adb5			bcs 	_GXLAOverflow 				; if carry out, overflowed.
.adb0	cd ed 06	cmp $06ed			cmp 	GXTotal 					; if exceeded total
.adb3	90 0a		bcc $adbf			bcc 	_GXLANoExtra
.adb5					_GXLAOverflow:
.adb5	ce ee 06	dec $06ee			dec 	GXAddSelect 				; set addselect to $FF
.adb8	38		sec				sec 								; subtract total and write back
.adb9	ed ed 06	sbc $06ed			sbc 	GXTotal
.adbc	8d eb 06	sta $06eb			sta 	GXPosition
.adbf					_GXLANoExtra:
.adbf	ad e9 06	lda $06e9			lda 	GXIsDiffYLarger
.adc2	f0 0d		beq $add1			beq 	_GXDXLarger
.adc4	20 23 ae	jsr $ae23			jsr 	GXIncrementY
.adc7	ad ee 06	lda $06ee			lda 	GXAddSelect
.adca	f0 10		beq $addc			beq 	_GXLAExit
.adcc	20 dd ad	jsr $addd			jsr 	GXAdjustX
.adcf	80 0b		bra $addc			bra 	_GXLAExit
.add1					_GXDXLarger:
.add1	20 dd ad	jsr $addd			jsr 	GXAdjustX
.add4	ad ee 06	lda $06ee			lda 	GXAddSelect
.add7	f0 03		beq $addc			beq 	_GXLAExit
.add9	20 23 ae	jsr $ae23			jsr 	GXIncrementY
.addc					_GXLAExit:
.addc	60		rts				rts
.addd					GXAdjustX:
.addd	ad ea 06	lda $06ea			lda 	GXDXNegative
.ade0	10 25		bpl $ae07			bpl 	_GXAXRight
.ade2	ad 4a 06	lda $064a			lda 	GXX0
.ade5	d0 03		bne $adea			bne 	_GXAXNoBorrow
.ade7	ce 4b 06	dec $064b			dec 	GXX0+1
.adea					_GXAXNoBorrow:
.adea	ce 4a 06	dec $064a			dec 	GXX0
.aded	ce 5c 06	dec $065c			dec 	gsOffset 					; pixel left
.adf0	ad 5c 06	lda $065c			lda 	gsOffset
.adf3	c9 ff		cmp #$ff			cmp 	#$FF
.adf5	d0 0f		bne $ae06			bne 	_GXAYExit 					; underflow
.adf7	c6 3d		dec $3d				dec 	gxzScreen+1 					; borrow
.adf9	a5 3d		lda $3d				lda 	gxzScreen+1 					; gone off page
.adfb	c9 60		cmp #$60			cmp 	#GXMappingAddress >> 8
.adfd	b0 07		bcs $ae06			bcs 	_GXAYExit
.adff	18		clc				clc
.ae00	69 20		adc #$20			adc 	#$20 						; fix up
.ae02	85 3d		sta $3d				sta 	gxzScreen+1
.ae04	c6 0b		dec $0b				dec 	GXEditSlot 				; back one page
.ae06					_GXAYExit:
.ae06	60		rts				rts
.ae07					_GXAXRight:
.ae07	ee 4a 06	inc $064a			inc 	GXX0
.ae0a	d0 03		bne $ae0f			bne 	_GXAXNoCarry
.ae0c	ee 4b 06	inc $064b			inc 	GXX0+1
.ae0f					_GXAXNoCarry:
.ae0f	ee 5c 06	inc $065c			inc 	gsOffset 					; pixel right
.ae12	d0 0e		bne $ae22			bne 	_GXAXExit 					; if not overflowed, exit.
.ae14	e6 3d		inc $3d				inc 	gxzScreen+1 					; next line
.ae16	a5 3d		lda $3d				lda 	gxzScreen+1
.ae18	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.ae1a	90 06		bcc $ae22			bcc 	_GXAXExit
.ae1c	e9 20		sbc #$20			sbc 	#$20 						; fix up
.ae1e	85 3d		sta $3d				sta 	gxzScreen+1
.ae20	e6 0b		inc $0b				inc 	GXEditSlot 				; next page
.ae22					_GXAXExit:
.ae22	60		rts				rts
.ae23					GXIncrementY:
.ae23	ee 4c 06	inc $064c			inc 	GXY0
.ae26	20 9a b2	jsr $b29a			jsr 	GXMovePositionDown
.ae29	60		rts				rts
.ae2a					GXLineSetup:
.ae2a	ad 50 06	lda $0650			lda 	GXY1
.ae2d	38		sec				sec
.ae2e	ed 4c 06	sbc $064c			sbc 	GXY0
.ae31	4a		lsr a				lsr 	a
.ae32	8d e8 06	sta $06e8			sta 	GXDiffY
.ae35	9c ea 06	stz $06ea			stz 	GXDXNegative 				; clear -ve flag
.ae38	38		sec				sec
.ae39	ad 4e 06	lda $064e			lda 	GXX1
.ae3c	ed 4a 06	sbc $064a			sbc 	GXX0
.ae3f	8d e7 06	sta $06e7			sta 	GXDiffX
.ae42	ad 4f 06	lda $064f			lda 	GXX1+1 						; calculate MSB
.ae45	ed 4b 06	sbc $064b			sbc 	GXX0+1
.ae48	6a		ror a				ror 	a 							; rotate bit into DiffX halving it
.ae49	6e e7 06	ror $06e7			ror 	GXDiffX
.ae4c	0a		asl a				asl 	a
.ae4d	10 0c		bpl $ae5b			bpl 	_GDXNotNegative
.ae4f	a9 00		lda #$00			lda 	#0 							; make absolute value of |dx|
.ae51	38		sec				sec
.ae52	ed e7 06	sbc $06e7			sbc 	GXDiffX
.ae55	8d e7 06	sta $06e7			sta 	GXDiffX
.ae58	ce ea 06	dec $06ea			dec 	GXDXNegative 				; -ve flag = $FF.
.ae5b					_GDXNotNegative:
.ae5b	9c e9 06	stz $06e9			stz 	GXIsDiffYLarger 			; clear larger flag
.ae5e	ad e8 06	lda $06e8			lda 	GXDiffY 					; set adjust and total.
.ae61	8d ec 06	sta $06ec			sta 	GXAdjust
.ae64	ad e7 06	lda $06e7			lda 	GXDiffX
.ae67	8d ed 06	sta $06ed			sta 	GXTotal
.ae6a	ad e8 06	lda $06e8			lda 	GXDiffY 					; if dy > dx
.ae6d	cd e7 06	cmp $06e7			cmp 	GXDiffX
.ae70	90 0f		bcc $ae81			bcc 	_GDXNotLarger
.ae72	ce e9 06	dec $06e9			dec 	GXIsDiffYLarger 			; set the dy larger flag
.ae75	ad e7 06	lda $06e7			lda 	GXDiffX 					; set adjust and total other way round
.ae78	8d ec 06	sta $06ec			sta 	GXAdjust
.ae7b	ad e8 06	lda $06e8			lda 	GXDiffY
.ae7e	8d ed 06	sta $06ed			sta 	GXTotal
.ae81					_GDXNotLarger:
.ae81	ad ed 06	lda $06ed			lda 	GXTotal
.ae84	4a		lsr a				lsr 	a
.ae85	8d eb 06	sta $06eb			sta 	GXPosition
.ae88	60		rts				rts
.06e7					GXDiffX:
>06e7							.fill 	1
.06e8					GXDiffY:
>06e8							.fill 	1
.06e9					GXIsDiffYLarger:
>06e9							.fill 	1
.06ea					GXDXNegative:
>06ea							.fill 	1
.06eb					GXPosition:
>06eb							.fill 	1
.06ec					GXAdjust:
>06ec							.fill 	1
.06ed					GXTotal:
>06ed							.fill 	1
.06ee					GXAddSelect:
>06ee							.fill 	1
.ae89					GXSetColourMode:
.ae89	a6 36		ldx $36				ldx 	gxzTemp0
.ae8b	8e 58 06	stx $0658			stx 	gxColour 								; set colour
.ae8e	a5 37		lda $37				lda 	gxzTemp0+1 								;
.ae90	8d 57 06	sta $0657			sta 	gxMode 									; set mode
.ae93	29 03		and #$03			and 	#3 										; only interested in bits 0-3
.ae95	9c 5a 06	stz $065a			stz 	gxANDValue 								; initially AND with 0, and EOR with Colour
.ae98	ae 58 06	ldx $0658			ldx 	gxColour
.ae9b	8e 59 06	stx $0659			stx 	gxEORValue
.ae9e	c9 02		cmp #$02			cmp 	#2 										; if mode 2/3 And with colour
.aea0	90 03		bcc $aea5			bcc 	_GXSDCNotAndColour
.aea2	8e 5a 06	stx $065a			stx 	gxANDValue
.aea5					_GXSDCNotAndColour:
.aea5	d0 03		bne $aeaa			bne 	_GXSDCNotAnd 							; mode 2, Don't EOR with colour
.aea7	9c 59 06	stz $0659			stz 	gxEORValue
.aeaa					_GXSDCNotAnd:
.aeaa	4a		lsr a				lsr 	a 										; if bit 0 set, 1's complement AND value
.aeab	90 08		bcc $aeb5			bcc 	_GXSDCNoFlip
.aead	ad 5a 06	lda $065a			lda	 	gxANDValue
.aeb0	49 ff		eor #$ff			eor 	#$FF
.aeb2	8d 5a 06	sta $065a			sta 	gxANDValue
.aeb5					_GXSDCNoFlip:
.aeb5	18		clc				clc
.aeb6	60		rts				rts
.aeb7					GXPlotPoint:
.aeb7	20 34 b2	jsr $b234			jsr 	GXOpenBitmap 				; start drawing
.aeba	20 44 b2	jsr $b244			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.aebd	ac 5c 06	ldy $065c			ldy 	gsOffset
.aec0	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.aec2	2d 5a 06	and $065a			and 	gxANDValue
.aec5	4d 59 06	eor $0659			eor 	gxEORValue
.aec8	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.aeca	20 3c b2	jsr $b23c			jsr 	GXCloseBitmap 				; stop drawing and exit
.aecd	18		clc				clc
.aece	60		rts				rts
.aecf					GXFillRectangle:
.aecf	38		sec				sec
.aed0	80 01		bra $aed3			bra 	GXRectangle
.aed2					GXFrameRectangle:
.aed2	18		clc				clc
.aed3					GXRectangle:
.aed3	ad 53 06	lda $0653			lda 	gxBitmapsOn
.aed6	f0 35		beq $af0d			beq 	_GXRFail
.aed8	08		php				php 								; save Fill flag (CS)
.aed9	20 34 b2	jsr $b234			jsr 	GXOpenBitmap 				; start drawing
.aedc	20 5c b3	jsr $b35c			jsr 	GXSortXY 					; sort both X and Y so top left/bottom right
.aedf	20 44 b2	jsr $b244			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.aee2	38		sec				sec 								; sec = Draw line
.aee3	20 0f af	jsr $af0f			jsr 	GXDrawLineX1X0 				; draw a line length X1-X0
.aee6	ad 4c 06	lda $064c			lda 	gxY0 						; reached end of rectangle ?
.aee9	cd 50 06	cmp $0650			cmp 	gxY1
.aeec	f0 19		beq $af07			beq 	_GXRectangleExit
.aeee					_GXRectLoop:
.aeee	20 9a b2	jsr $b29a			jsr 	GXMovePositionDown 			; down one.
.aef1	ee 4c 06	inc $064c			inc 	gxY0 						; change Y pos
.aef4	ad 4c 06	lda $064c			lda 	gxY0 						; reached last line
.aef7	cd 50 06	cmp $0650			cmp 	gXY1
.aefa	f0 07		beq $af03			beq 	_GXLastLine
.aefc	28		plp				plp 								; get flag back
.aefd	08		php				php
.aefe	20 0f af	jsr $af0f			jsr 	GXDrawLineX1X0 				; draw horizontal line
.af01	80 eb		bra $aeee			bra 	_GXRectLoop
.af03					_GXLastLine:
.af03	38		sec				sec
.af04	20 0f af	jsr $af0f			jsr 	GXDrawLineX1X0
.af07					_GXRectangleExit:
.af07	68		pla				pla 								; throw fill flag.
.af08	20 3c b2	jsr $b23c			jsr 	GXCloseBitmap 				; stop drawing and exit
.af0b	18		clc				clc
.af0c	60		rts				rts
.af0d					_GXRFail:
.af0d	38		sec				sec
.af0e	60		rts				rts
.af0f					GXDrawLineX1X0:
.af0f	08		php				php 								; save solid/either-end
.af10	38		sec				sec
.af11	ad 4e 06	lda $064e			lda		gXX1
.af14	ed 4a 06	sbc $064a			sbc 	gXX0
.af17	85 36		sta $36				sta 	gxzTemp0
.af19	ad 4f 06	lda $064f			lda 	gXX1+1
.af1c	ed 4b 06	sbc $064b			sbc 	gXX0+1
.af1f	85 37		sta $37				sta 	gxzTemp0+1
.af21	28		plp				plp
.af22					GXDrawLineTemp0:
.af22	a5 3c		lda $3c				lda 	gxzScreen 						; push gxzScreen, gsOffset and GXEditSlot on stack
.af24	48		pha				pha
.af25	a5 3d		lda $3d				lda 	gxzScreen+1
.af27	48		pha				pha
.af28	ad 5c 06	lda $065c			lda 	gsOffset
.af2b	48		pha				pha
.af2c	a5 0b		lda $0b				lda 	GXEditSlot
.af2e	48		pha				pha
.af2f	ac 5c 06	ldy $065c			ldy 	gsOffset 					; Y offset
.af32	90 1e		bcc $af52			bcc 	_GXDLTEndPoints 			; if CC draw end points only.
.af34					_GXDLTLine:
.af34	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.af36	2d 5a 06	and $065a			and 	gxANDValue
.af39	4d 59 06	eor $0659			eor 	gxEORValue
.af3c	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.af3e	a5 36		lda $36				lda 	gxzTemp0 					; decrement counter
.af40	d0 04		bne $af46			bne 	_GXDLTNoBorrow
.af42	c6 37		dec $37				dec 	gxzTemp0+1 					; borrow, if goes -ve then exit
.af44	30 2e		bmi $af74			bmi 	_GXDLTExit
.af46					_GXDLTNoBorrow:
.af46	c6 36		dec $36				dec 	gxzTemp0
.af48	c8		iny				iny 								; next slot.
.af49	d0 e9		bne $af34			bne 	_GXDLTLine
.af4b	e6 3d		inc $3d				inc 	gxzScreen+1 					; carry to next
.af4d	20 82 af	jsr $af82			jsr 	GXDLTCheckWrap				; check for new page.
.af50	80 e2		bra $af34			bra 	_GXDLTLine
.af52					_GXDLTEndPoints:
.af52	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.af54	2d 5a 06	and $065a			and 	gxANDValue
.af57	4d 59 06	eor $0659			eor 	gxEORValue
.af5a	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.af5c	98		tya				tya 								; advance to right side
.af5d	18		clc				clc
.af5e	65 36		adc $36				adc 	gxzTemp0
.af60	a8		tay				tay
.af61	a5 3d		lda $3d				lda 	gxzScreen+1
.af63	65 37		adc $37				adc 	gxzTemp0+1
.af65	85 3d		sta $3d				sta 	gxzScreen+1
.af67	20 82 af	jsr $af82			jsr 	GXDLTCheckWrap 			; fix up.
.af6a	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.af6c	2d 5a 06	and $065a			and 	gxANDValue
.af6f	4d 59 06	eor $0659			eor 	gxEORValue
.af72	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.af74					_GXDLTExit:
.af74	68		pla				pla
.af75	85 0b		sta $0b				sta 	GXEditSlot
.af77	68		pla				pla
.af78	8d 5c 06	sta $065c			sta 	gsOffset
.af7b	68		pla				pla
.af7c	85 3d		sta $3d				sta 	gxzScreen+1
.af7e	68		pla				pla
.af7f	85 3c		sta $3c				sta 	gxzScreen
.af81	60		rts				rts
.af82					GXDLTCheckWrap:
.af82	a5 3d		lda $3d				lda 	gxzScreen+1 					; check end of page
.af84	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8)
.af86	90 06		bcc $af8e			bcc 	_GXDLTCWExit
.af88	e9 20		sbc #$20			sbc 	#$20 						; fix up
.af8a	85 3d		sta $3d				sta 	gxzScreen+1
.af8c	e6 0b		inc $0b				inc 	GXEditSlot
.af8e					_GXDLTCWExit:
.af8e	60		rts				rts
.af8f					GXDrawGraphicElement:
.af8f	8d ef 06	sta $06ef			sta 	gxSize 						; save size
.af92	3a		dec a				dec 	a
.af93	8d f0 06	sta $06f0			sta 	gxMask 						; and mask
.af96	ad 53 06	lda $0653			lda 	gxBitmapsOn 				; check BMP on
.af99	f0 67		beq $b002			beq 	_GXSLFail
.af9b	ad 4c 06	lda $064c			lda 	gxY0 						; push Y on stack
.af9e	48		pha				pha
.af9f	8c f2 06	sty $06f2			sty 	gxAcquireVector+1 			; and acquisition vector
.afa2	8e f1 06	stx $06f1			stx 	gxAcquireVector
.afa5	20 34 b2	jsr $b234			jsr 	gxOpenBitmap 				; open the bitmap.
.afa8	ad f4 06	lda $06f4			lda 	gxUseMode 					; scale bits
.afab	4a		lsr a				lsr 	a
.afac	4a		lsr a				lsr 	a
.afad	4a		lsr a				lsr 	a
.afae	29 07		and #$07			and		#7
.afb0	1a		inc a				inc 	a
.afb1	8d f3 06	sta $06f3			sta 	gxScale
.afb4	64 38		stz $38				stz 	gxzTemp1					; start first line
.afb6					_GXGELoop:
.afb6	a5 38		lda $38				lda 	gxzTemp1 					; current line number to read.
.afb8	2c f4 06	bit $06f4			bit 	gxUseMode 					; check for flip.
.afbb	10 06		bpl $afc3			bpl		_GXNoVFlip
.afbd	ad f0 06	lda $06f0			lda 	gxMask
.afc0	38		sec				sec
.afc1	e5 38		sbc $38				sbc 	gxzTemp1
.afc3					_GXNoVFlip:
.afc3	aa		tax				tax 								; get the Xth line.
.afc4	20 04 b0	jsr $b004			jsr 	_GXCallAcquire 				; get that data.
.afc7	ad f3 06	lda $06f3			lda 	gxScale 					; do scale identical copies of that line.
.afca	85 39		sta $39				sta 	gxzTemp1+1
.afcc					_GXGELoop2:
.afcc	ad 4c 06	lda $064c			lda 	gxY0 						; off screen
.afcf	cd 56 06	cmp $0656			cmp 	gxHeight
.afd2	b0 10		bcs $afe4			bcs 	_GXDGEExit
.afd4	20 07 b0	jsr $b007			jsr 	GXRenderOneLine 			; render line
.afd7	c6 39		dec $39				dec 	gxzTemp1+1 					; scale times.
.afd9	d0 f1		bne $afcc			bne 	_GXGELoop2
.afdb	e6 38		inc $38				inc 	gxzTemp1 					; done all lines.
.afdd	a5 38		lda $38				lda 	gxzTemp1
.afdf	cd ef 06	cmp $06ef			cmp 	gxSize
.afe2	d0 d2		bne $afb6			bne 	_GXGELoop
.afe4					_GXDGEExit:
.afe4	68		pla				pla 								; restore Y for next time
.afe5	8d 4c 06	sta $064c			sta 	gxY0
.afe8	ae f3 06	ldx $06f3			ldx 	gxScale 					; get scale (1-8)
.afeb					_GXShiftLeft:
.afeb	18		clc				clc
.afec	ad ef 06	lda $06ef			lda 	gxSize
.afef	6d 4a 06	adc $064a			adc 	gxX0
.aff2	8d 4a 06	sta $064a			sta 	gxX0
.aff5	90 03		bcc $affa			bcc 	_GXSLNoCarry
.aff7	ee 4b 06	inc $064b			inc 	gxX0+1
.affa					_GXSLNoCarry:
.affa	ca		dex				dex
.affb	d0 ee		bne $afeb			bne 	_GXShiftLeft
.affd	20 3c b2	jsr $b23c			jsr 	GXCloseBitmap
.b000	18		clc				clc
.b001	60		rts				rts
.b002					_GXSLFail:
.b002	38		sec				sec
.b003	60		rts				rts
.b004					_GXCallAcquire:
.b004	6c f1 06	jmp ($06f1)			jmp 	(gxAcquireVector)
.b007					GXRenderOneLine:
.b007	20 44 b2	jsr $b244			jsr 	GXPositionCalc 				; calculate position/offset.
.b00a	ac 5c 06	ldy $065c			ldy 	gsOffset 					; Y contains position.
.b00d	64 3a		stz $3a				stz 	gxzTemp2 					; do size pixels
.b00f					_GXROLLoop1:
.b00f	ad f3 06	lda $06f3			lda 	gxScale 					; set to do 'scale' times
.b012	85 3b		sta $3b				sta 	gxzTemp2+1
.b014					_GXROLLoop2:
.b014	a5 3a		lda $3a				lda 	gxzTemp2 					; get current pixel
.b016	2c 57 06	bit $0657			bit 	gxMode 						; check H Flip
.b019	50 06		bvc $b021			bvc 	_GXNoHFlip
.b01b	ad f0 06	lda $06f0			lda 	gxMask
.b01e	38		sec				sec
.b01f	e5 3a		sbc $3a				sbc 	gxzTemp2
.b021					_GXNoHFlip:
.b021	aa		tax				tax 								; read from the pixel buffer
.b022	bd f9 05	lda $05f9,x			lda 	gxPixelBuffer,x
.b025	d0 07		bne $b02e			bne 	_GXDraw 					; draw if non zero
.b027	ad f4 06	lda $06f4			lda 	gxUseMode 					; check to see if solid background
.b02a	29 04		and #$04			and 	#4
.b02c	f0 0a		beq $b038			beq 	_GXZeroPixel
.b02e					_GXDraw:
.b02e	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.b030	2d 5a 06	and $065a			and 	gxANDValue
.b033	5d f9 05	eor $05f9,x			eor 	gxPixelBuffer,x
.b036	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b038					_GXZeroPixel:
.b038	c8		iny				iny 								; advance pointer
.b039	d0 05		bne $b040			bne 	_GXNoShift
.b03b	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.b03d	20 82 af	jsr $af82			jsr 	GXDLTCheckWrap				; check for new page.
.b040					_GXNoShift:
.b040	c6 3b		dec $3b				dec 	gxzTemp2+1 					; do the inner loop gxScale times.
.b042	d0 d0		bne $b014			bne 	_GXROLLoop2
.b044	e6 3a		inc $3a				inc 	gxzTemp2 					; next pixel.
.b046	a5 3a		lda $3a				lda 	gxzTemp2
.b048	cd ef 06	cmp $06ef			cmp 	gxSize
.b04b	d0 c2		bne $b00f			bne 	_GXROLLoop1
.b04d	ee 4c 06	inc $064c			inc 	gxY0
.b050	60		rts				rts
.06ef					gxSize:
>06ef							.fill 	1
.06f0					gxMask:
>06f0							.fill 	1
.06f1					gxAcquireVector:
>06f1							.fill 	2
.06f3					gxScale:
>06f3							.fill 	1
.06f4					gxUseMode:
>06f4							.fill 	1
.b051					GXFontHandler:
.b051	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b053	4d 57 06	eor $0657			eor 	gxMode
.b056	8d f4 06	sta $06f4			sta 	gxUseMode
.b059	64 37		stz $37				stz 	gxzTemp0+1 					; gxzTemp0 is font #
.b05b	06 36		asl $36				asl	 	gxzTemp0 					; x 2
.b05d	26 37		rol $37				rol	 	gxzTemp0+1
.b05f	06 36		asl $36				asl	 	gxzTemp0 					; x 4
.b061	26 37		rol $37				rol	 	gxzTemp0+1
.b063	06 36		asl $36				asl	 	gxzTemp0 					; x 8
.b065	26 37		rol $37				rol	 	gxzTemp0+1
.b067	a5 37		lda $37				lda 	gxzTemp0+1 					; put in page C0
.b069	09 c0		ora #$c0			ora 	#$C0
.b06b	85 37		sta $37				sta 	gxzTemp0+1
.b06d	a9 08		lda #$08			lda 	#8 							; size 8x8
.b06f	a2 77		ldx #$77			ldx 	#GXGetGraphicDataFont & $FF ; XY = Graphic Data retrieval routine
.b071	a0 b0		ldy #$b0			ldy 	#GXGetGraphicDataFont >> 8
.b073	20 8f af	jsr $af8f			jsr 	GXDrawGraphicElement
.b076	60		rts				rts
.b077					GXGetGraphicDataFont:
.b077	8a		txa				txa 								; X->Y
.b078	a8		tay				tay
.b079	a6 01		ldx $01				ldx 	1 							; preserve old value
.b07b	a9 01		lda #$01			lda 	#1 							; access page 1 (font memory)
.b07d	85 01		sta $01				sta 	1
.b07f	b1 36		lda ($36),y			lda 	(gxzTemp0),y 				; read the font element.
.b081	86 01		stx $01				stx 	1 							; put old value back.
.b083	a2 00		ldx #$00			ldx 	#0 							; do 8 times
.b085					_GXExpand:
.b085	9e f9 05	stz $05f9,x			stz 	gxPixelBuffer,x 			; zero in pixel buffer
.b088	0a		asl a				asl 	a 							; shift bit 7 into C
.b089	90 08		bcc $b093			bcc 	_GXNoPixel
.b08b	48		pha				pha 								; if set, set pixel buffer to current colour.
.b08c	ad 58 06	lda $0658			lda 	gxColour
.b08f	9d f9 05	sta $05f9,x			sta 	gxPixelBuffer,x
.b092	68		pla				pla
.b093					_GXNoPixel:
.b093	e8		inx				inx 								; do the whole byte.
.b094	e0 08		cpx #$08			cpx 	#8
.b096	d0 ed		bne $b085			bne 	_GXExpand
.b098	60		rts				rts
.b099					GXSpriteHandler:
.b099	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b09b	4d 57 06	eor $0657			eor 	gxMode
.b09e	8d f4 06	sta $06f4			sta 	gxUseMode
.b0a1	a6 36		ldx $36				ldx 	gxzTemp0 					; sprite #
.b0a3	da		phx				phx
.b0a4	20 34 b2	jsr $b234			jsr 	GXOpenBitmap 				; can access sprite information
.b0a7	68		pla				pla
.b0a8	20 15 b3	jsr $b315			jsr 	GXFindSprite 				; get the sprite address
.b0ab	08		php				php
.b0ac	20 3c b2	jsr $b23c			jsr 	GXCloseBitmap
.b0af	28		plp				plp
.b0b0	b0 0a		bcs $b0bc			bcs		_GXSHExit 					; exit if find failed.
.b0b2	ad f5 06	lda $06f5			lda 	GXSizePixels 				; return size
.b0b5	a2 bd		ldx #$bd			ldx 	#GXSpriteAcquire & $FF
.b0b7	a0 b0		ldy #$b0			ldy 	#GXSpriteAcquire >> 8
.b0b9	20 8f af	jsr $af8f			jsr 	GXDrawGraphicElement
.b0bc					_GXSHExit:
.b0bc	60		rts				rts
.b0bd					GXSpriteAcquire:
.b0bd	ad 55 06	lda $0655			lda 	GXSpritePage				; point to base page
.b0c0	85 0b		sta $0b				sta 	GXEditSlot
.b0c2	86 36		stx $36				stx 	zTemp0 						; row number x 1,2,3,4
.b0c4	a9 00		lda #$00			lda 	#0
.b0c6	ae f6 06	ldx $06f6			ldx 	GXSizeBits
.b0c9					_GXTimesRowNumber:
.b0c9	18		clc				clc
.b0ca	65 36		adc $36				adc 	zTemp0
.b0cc	ca		dex				dex
.b0cd	10 fa		bpl $b0c9			bpl 	_GXTimesRowNumber
.b0cf	64 37		stz $37				stz 	gxzTemp0+1
.b0d1	0a		asl a				asl 	a 							; row x 2,4,6,8
.b0d2	26 37		rol $37				rol 	gxzTemp0+1
.b0d4	0a		asl a				asl 	a 							; row x 4,8,12,16
.b0d5	26 37		rol $37				rol 	gxzTemp0+1
.b0d7	0a		asl a				asl 	a 							; row x 8,16,24,32
.b0d8	26 37		rol $37				rol 	gxzTemp0+1
.b0da	85 36		sta $36				sta 	gxzTemp0
.b0dc	18		clc				clc 								; add base address.
.b0dd	a5 36		lda $36				lda 	gxzTemp0
.b0df	6d f8 06	adc $06f8			adc 	GXSpriteOffset
.b0e2	85 36		sta $36				sta 	gxzTemp0
.b0e4	a5 37		lda $37				lda 	gxzTemp0+1
.b0e6	6d f9 06	adc $06f9			adc 	GXSpriteOffset+1
.b0e9					_GXSAFindPage:
.b0e9	c9 20		cmp #$20			cmp 	#$20 						; on this page
.b0eb	90 06		bcc $b0f3			bcc 	_GXSAFoundPage
.b0ed	e9 20		sbc #$20			sbc 	#$20 						; forward one page
.b0ef	e6 0b		inc $0b				inc 	GXEditSlot
.b0f1	80 f6		bra $b0e9			bra 	_GXSAFindPage
.b0f3					_GXSAFoundPage:
.b0f3	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; physical address of page.
.b0f5	85 37		sta $37				sta 	gxzTemp0+1 					; gxzTemp0 now points to the page
.b0f7	a0 00		ldy #$00			ldy 	#0
.b0f9					_GXSACopyLoop:
.b0f9	b1 36		lda ($36),y			lda 	(gxzTemp0),y
.b0fb	99 f9 05	sta $05f9,y			sta 	gxPixelBuffer,y
.b0fe	c8		iny				iny
.b0ff	cc f5 06	cpy $06f5			cpy 	GXSizePixels
.b102	d0 f5		bne $b0f9			bne 	_GXSACopyLoop
.b104	60		rts				rts
.b105					GXSelect:
.b105	ad 52 06	lda $0652			lda 	gxSpritesOn
.b108	f0 22		beq $b12c			beq 	_GXSFail
.b10a	a5 36		lda $36				lda 	gxzTemp0 					; illegal sprite #
.b10c	c9 40		cmp #$40			cmp 	#64
.b10e	b0 1c		bcs $b12c			bcs 	_GXSFail
.b110	8d 5d 06	sta $065d			sta 	GSCurrentSpriteID
.b113	a4 37		ldy $37				ldy 	gxzTemp0+1 					; control value.
.b115	a9 00		lda #$00			lda  	#0 							; multiply sprite # x 8 => A
.b117	06 36		asl $36				asl 	gxzTemp0
.b119	06 36		asl $36				asl 	gxzTemp0
.b11b	06 36		asl $36				asl 	gxzTemp0
.b11d	2a		rol a				rol 	a
.b11e	69 d9		adc #$d9			adc 	#$D9 						; sprite area
.b120	8d 5f 06	sta $065f			sta 	GSCurrentSpriteAddr+1 		; address to GSCurrentSprite and gxzTemp
.b123	85 37		sta $37				sta 	gxzTemp0+1
.b125	a5 36		lda $36				lda 	gxzTemp0
.b127	8d 5e 06	sta $065e			sta 	GSCurrentSpriteAddr
.b12a	18		clc				clc
.b12b	60		rts				rts
.b12c					_GXSFail:
.b12c	38		sec				sec
.b12d	60		rts				rts
.b12e					GXSelectImage:
.b12e	ad 52 06	lda $0652			lda 	gxSpritesOn
.b131	f0 74		beq $b1a7			beq 	_GXSIFail
.b133	ad 5f 06	lda $065f			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b136	f0 6f		beq $b1a7			beq 	_GXSIFail 					; (checking the MSB)
.b138	64 01		stz $01				stz 	1
.b13a	a5 37		lda $37				lda 	gxzTemp0+1 					; push show/hide on the stack.
.b13c	d0 6b		bne $b1a9			bne 	_GXSIHide
.b13e	a5 36		lda $36				lda 	gxzTemp0 					; sprite image
.b140	48		pha				pha
.b141	20 34 b2	jsr $b234			jsr 	GXOpenBitmap
.b144	68		pla				pla
.b145	20 15 b3	jsr $b315			jsr 	GXFindSprite
.b148	b0 5a		bcs $b1a4			bcs 	_GXSICloseFail 				; no image
.b14a	a0 01		ldy #$01			ldy 	#1
.b14c	ad 5e 06	lda $065e			lda 	GSCurrentSpriteAddr
.b14f	85 36		sta $36				sta 	gxzTemp0
.b151	ad 5f 06	lda $065f			lda 	GSCurrentSpriteAddr+1
.b154	85 37		sta $37				sta 	gxzTemp0+1
.b156	ad f8 06	lda $06f8			lda 	GXSpriteOffset
.b159	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b15b	18		clc				clc
.b15c	ad f9 06	lda $06f9			lda 	GXSpriteOffset+1
.b15f	6d 60 06	adc $0660			adc 	GXSpriteOffsetBase
.b162	c8		iny				iny
.b163	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b165	ad 61 06	lda $0661			lda 	GXSpriteOffsetBase+1
.b168	69 00		adc #$00			adc 	#0
.b16a	c8		iny				iny
.b16b	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b16d	ad f6 06	lda $06f6			lda 	GXSizeBits 					; get raw size
.b170	49 03		eor #$03			eor 	#3 							; make it right (00=32 etc.)
.b172	2a		rol a				rol 	a 							; x 2
.b173	0a		asl a				asl 	a 							; x 4
.b174	0a		asl a				asl 	a 							; x 8
.b175	0a		asl a				asl 	a 							; x 16
.b176	0d f7 06	ora $06f7			ora 	GXSpriteLUT 				; Or with LUT
.b179	0a		asl a				asl 	a 							; 1 shift
.b17a	09 01		ora #$01			ora 	#1 							; enable sprite.
.b17c	92 36		sta ($36)			sta 	(gxzTemp0) 					; and write back
.b17e	20 3c b2	jsr $b23c			jsr 	GXCloseBitmap
.b181	ae 5d 06	ldx $065d			ldx 	GSCurrentSpriteID 			; point to sprite entries.
.b184	bd a2 06	lda $06a2,x			lda 	GXSpriteHigh,x 				; clear upper two bits of size
.b187	29 3f		and #$3f			and 	#$3F
.b189	9d a2 06	sta $06a2,x			sta 	GXSpriteHigh,x
.b18c	ad f6 06	lda $06f6			lda 	GXSizeBits 					; get bit size
.b18f	6a		ror a				ror 	a 							; shift into bits 6/7
.b190	6a		ror a				ror 	a
.b191	6a		ror a				ror 	a
.b192	29 c0		and #$c0			and 	#$C0
.b194	1d a2 06	ora $06a2,x			ora 	GXSpriteHigh,x 				; put in  upper 2 bits of sprite data
.b197	9d a2 06	sta $06a2,x			sta 	GXSpriteHigh,x
.b19a	bd 62 06	lda $0662,x			lda 	GXSpriteLow,x 				; clear hidden flag.
.b19d	29 7f		and #$7f			and 	#$7F
.b19f	9d 62 06	sta $0662,x			sta 	GXSpriteLow,x
.b1a2	18		clc				clc
.b1a3	60		rts				rts
.b1a4					_GXSICloseFail:
.b1a4	20 3c b2	jsr $b23c			jsr 	GXCloseBitmap
.b1a7					_GXSIFail:
.b1a7	38		sec				sec
.b1a8	60		rts				rts
.b1a9					_GXSIHide:
.b1a9	ad 5e 06	lda $065e			lda 	GSCurrentSpriteAddr  		; get Sprite h/w address and write there
.b1ac	85 36		sta $36				sta 	gxzTemp0
.b1ae	ad 5f 06	lda $065f			lda 	GSCurrentSpriteAddr+1
.b1b1	85 37		sta $37				sta 	gxzTemp0+1
.b1b3	a9 00		lda #$00			lda 	#0
.b1b5	92 36		sta ($36)			sta 	(gxzTemp0)
.b1b7	ae 5d 06	ldx $065d			ldx 	GSCurrentSpriteID 			; get sprite ID
.b1ba	bd 62 06	lda $0662,x			lda 	GXSpriteLow,x 				; set the hidden bit.
.b1bd	09 80		ora #$80			ora 	#$80
.b1bf	9d 62 06	sta $0662,x			sta 	GXSpriteLow,x
.b1c2	18		clc				clc
.b1c3	60		rts				rts
.b1c4					GXMoveSprite:
.b1c4	ad 52 06	lda $0652			lda 	gxSpritesOn
.b1c7	f0 65		beq $b22e			beq 	_GXSIFail
.b1c9	ad 5f 06	lda $065f			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b1cc	f0 60		beq $b22e			beq 	_GXSIFail
.b1ce	85 37		sta $37				sta 	gxzTemp0+1
.b1d0	a0 04		ldy #$04			ldy 	#4
.b1d2	ad 5e 06	lda $065e			lda 	GSCurrentSpriteAddr
.b1d5	85 36		sta $36				sta 	gxzTemp0
.b1d7	ae 5d 06	ldx $065d			ldx 	GSCurrentSpriteID 			; get the size from the upper two bits
.b1da	bd a2 06	lda $06a2,x			lda 	GXSpriteHigh,x
.b1dd	2a		rol a				rol 	a	 						; into bits 0,1.
.b1de	2a		rol a				rol 	a
.b1df	2a		rol a				rol 	a
.b1e0	29 03		and #$03			and 	#3
.b1e2	aa		tax				tax
.b1e3	bd 30 b2	lda $b230,x			lda 	_GXMSOffset,x 				; get 32-SpriteSize/2
.b1e6	48		pha				pha
.b1e7	18		clc				clc
.b1e8	6d 4a 06	adc $064a			adc 	gxX0						; copy position.
.b1eb	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b1ed	c8		iny				iny
.b1ee	ad 4b 06	lda $064b			lda 	gxX0+1
.b1f1	69 00		adc #$00			adc 	#0
.b1f3	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b1f5	c8		iny				iny
.b1f6	68		pla				pla
.b1f7	18		clc				clc
.b1f8	6d 4c 06	adc $064c			adc 	gxY0
.b1fb	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b1fd	a9 00		lda #$00			lda 	#0
.b1ff	69 00		adc #$00			adc 	#0
.b201	c8		iny				iny
.b202	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b204	4e 4b 06	lsr $064b			lsr 	gxX0+1 						; divide X by 4
.b207	6e 4a 06	ror $064a			ror 	gxX0
.b20a	4e 4a 06	lsr $064a			lsr 	gxX0
.b20d	4e 4c 06	lsr $064c			lsr 	gxY0 						; divide Y by 4
.b210	4e 4c 06	lsr $064c			lsr 	gxY0
.b213	ae 5d 06	ldx $065d			ldx 	GSCurrentSpriteID 			; copy X/4 and Y/4 into the status bytes
.b216	bd 62 06	lda $0662,x			lda 	GXSpriteLow,x
.b219	29 80		and #$80			and 	#$80
.b21b	0d 4a 06	ora $064a			ora 	gxX0
.b21e	9d 62 06	sta $0662,x			sta 	GXSpriteLow,x
.b221	bd a2 06	lda $06a2,x			lda 	GXSpriteHigh,x
.b224	29 c0		and #$c0			and 	#$C0
.b226	0d 4c 06	ora $064c			ora 	gxY0
.b229	9d a2 06	sta $06a2,x			sta 	GXSpriteHigh,x
.b22c	18		clc				clc
.b22d	60		rts				rts
.b22e					_GXSIFail:
.b22e	38		sec				sec
.b22f	60		rts				rts
.b230					_GXMSOffset:
>b230	1c						.byte 	32-8/2
>b231	18						.byte 	32-16/2
>b232	14						.byte 	32-24/2
>b233	10						.byte 	32-32/2
.b234					GXOpenBitmap:
.b234	78		sei				sei 								; no interrupts here
.b235	a5 0b		lda $0b				lda 	GXEditSlot 					; Save the original LUT slot value
.b237	8d 5b 06	sta $065b			sta 	gxOriginalLUTValue
.b23a	58		cli				cli
.b23b	60		rts				rts
.b23c					GXCloseBitmap:
.b23c	78		sei				sei
.b23d	ad 5b 06	lda $065b			lda 	gxOriginalLUTValue 			; restore LUT slot value
.b240	85 0b		sta $0b				sta 	GXEditSlot
.b242	58		cli				cli
.b243	60		rts				rts
.b244					GXPositionCalc:
.b244	a5 36		lda $36				lda 	gxzTemp0 					; save temp memory slot
.b246	48		pha				pha
.b247	ad 4c 06	lda $064c			lda 	GXY0 						; gxzScreen = Y0
.b24a	85 3c		sta $3c				sta 	gxzScreen
.b24c	64 3d		stz $3d				stz 	gxzScreen+1
.b24e	06 3c		asl $3c				asl 	gxzScreen 						; gxzScreen = Y0 * 4
.b250	26 3d		rol $3d				rol 	gxzScreen+1
.b252	06 3c		asl $3c				asl 	gxzScreen
.b254	26 3d		rol $3d				rol 	gxzScreen+1
.b256	18		clc				clc 								; gxzScreen = Y0 * 5, as it's still in A
.b257	65 3c		adc $3c				adc 	gxzScreen
.b259	85 3c		sta $3c				sta 	gxzScreen
.b25b	90 02		bcc $b25f			bcc 	_GXPCNoCarry
.b25d	e6 3d		inc $3d				inc 	gxzScreen+1
.b25f					_GXPCNoCarry:
.b25f	06 3c		asl $3c				asl 	gxzScreen 						; now Y0 * 10. Needs to be multiplied by another
.b261	26 3d		rol $3d				rol 	gxzScreen+1 					; 32. At this point the MSB contains the offset
.b263	a5 3d		lda $3d				lda	 	gxzScreen+1 					; so save this in zTemp0 and zero it.
.b265	85 36		sta $36				sta 	gxzTemp0
.b267	64 3d		stz $3d				stz 	gxzScreen+1
.b269	a9 05		lda #$05			lda 	#5 							; now multiply by 32, this puts this in the range 0..8191
.b26b					_GXPCMultiply32:
.b26b	06 3c		asl $3c				asl 	gxzScreen
.b26d	26 3d		rol $3d				rol 	gxzScreen+1
.b26f	3a		dec a				dec 	a
.b270	d0 f9		bne $b26b			bne 	_GXPCMultiply32
.b272	18		clc				clc
.b273	ad 4a 06	lda $064a			lda 	GXX0 						; add X to this value, put the result in gsOffset, gxzScreen has to be on a page boundary
.b276	65 3c		adc $3c				adc 	gxzScreen
.b278	8d 5c 06	sta $065c			sta 	gsOffset
.b27b	ad 4b 06	lda $064b			lda 	GXX0+1
.b27e	65 3d		adc $3d				adc 	gxzScreen+1
.b280	c9 20		cmp #$20			cmp 	#$20 						; has it overflowed into the next one ?
.b282	90 04		bcc $b288			bcc 	_GXPCNoOverflow
.b284	29 1f		and #$1f			and 	#$1F 						; fix it up
.b286	e6 36		inc $36				inc 	gxzTemp0 					; add 1 to the page number
.b288					_GXPCNoOverflow:
.b288	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; make it the address mapped in.
.b28a	85 3d		sta $3d				sta 	gxzScreen+1
.b28c	64 3c		stz $3c				stz 	gxzScreen
.b28e	18		clc				clc
.b28f	a5 36		lda $36				lda 	gxzTemp0 					; get the page number
.b291	6d 54 06	adc $0654			adc 	gxBasePage 					; by adding the base page
.b294	85 0b		sta $0b				sta 	GXEditSlot 				; and map it into memory.
.b296	68		pla				pla
.b297	85 36		sta $36				sta 	gxzTemp0
.b299	60		rts				rts
.b29a					GXMovePositionDown:
.b29a	18		clc				clc 								; add 320 to offset/temp+1
.b29b	ad 5c 06	lda $065c			lda 	gsOffset
.b29e	69 40		adc #$40			adc 	#64
.b2a0	8d 5c 06	sta $065c			sta 	gsOffset
.b2a3	a5 3d		lda $3d				lda 	gxzScreen+1
.b2a5	69 01		adc #$01			adc 	#1
.b2a7	85 3d		sta $3d				sta 	gxzScreen+1
.b2a9	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page
.b2ab	90 07		bcc $b2b4			bcc 	_GXMPDExit
.b2ad	38		sec				sec  								; next page
.b2ae	e9 20		sbc #$20			sbc 	#$20
.b2b0	85 3d		sta $3d				sta 	gxzScreen+1
.b2b2	e6 0b		inc $0b				inc 	GXEditSlot
.b2b4					_GXMPDExit:
.b2b4	60		rts				rts
.b2b5					GXCollide:
.b2b5	a5 36		lda $36				lda 	gxzTemp0 					; check if sprite numbers are legal.
.b2b7	aa		tax				tax
.b2b8	05 37		ora $37				ora 	gxzTemp0+1
.b2ba	29 c0		and #$c0			and 	#$C0
.b2bc	38		sec				sec
.b2bd	d0 53		bne $b312			bne 	_GXCollideFail 				; if either >= 64, fail.
.b2bf	a4 37		ldy $37				ldy 	gxzTemp0+1 					; at this point X is 1st sprite and Y is 2nd sprite.
.b2c1	b9 62 06	lda $0662,y			lda 	GXSpriteLow,y 				; check if either hidden bit is set
.b2c4	1d 62 06	ora $0662,x			ora 	GXSpriteLow,x
.b2c7	30 48		bmi $b311			bmi 	_GXOkayFail 				; if either hidden, then they cannot collide.
.b2c9	18		clc				clc 								; need to calculate sum of sizes.
.b2ca	b9 a2 06	lda $06a2,y			lda 	GXSpriteHigh,y
.b2cd	7d a2 06	adc $06a2,x			adc 	GXSpriteHigh,x 				; at this point, CS, Bit 6 and 7 contain that sum.
.b2d0	29 c0		and #$c0			and 	#$C0 					 	; mask off
.b2d2	6a		ror a				ror 	a 							; 5/6/7
.b2d3	4a		lsr a				lsr 	a 							; 4/5/6
.b2d4	4a		lsr a				lsr 	a 							; 3/4/5
.b2d5	4a		lsr a				lsr 	a 							; 2/3/4
.b2d6	18		clc				clc
.b2d7	69 08		adc #$08			adc 	#$08
.b2d9	4a		lsr a				lsr 	a 							; adjust because all coordinates are divided by 4 to store.
.b2da	4a		lsr a				lsr 	a
.b2db	85 38		sta $38				sta 	gxzTemp1 					; so the difference between the centres has to be less than this.
.b2dd	b9 a2 06	lda $06a2,y			lda 	GXSpriteHigh,y 				; calculate y1-y0
.b2e0	29 3f		and #$3f			and 	#$3F
.b2e2	85 39		sta $39				sta 	gxzTemp1+1
.b2e4	38		sec				sec
.b2e5	bd a2 06	lda $06a2,x			lda 	GXSpriteHigh,x
.b2e8	29 3f		and #$3f			and 	#$3F
.b2ea	e5 39		sbc $39				sbc 	gxzTemp1+1
.b2ec	b0 03		bcs $b2f1			bcs 	_GXCAbs1 					; calculate |y1-y0|
.b2ee	49 ff		eor #$ff			eor 	#$FF
.b2f0	1a		inc a				inc 	a
.b2f1					_GXCAbs1:
.b2f1	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b2f3	b0 1c		bcs $b311			bcs 	_GXOkayFail
.b2f5	85 39		sta $39				sta 	gxzTemp1+1 					; save |y1-y0|
.b2f7	38		sec				sec 								; calculate |x1-x0|
.b2f8	b9 62 06	lda $0662,y			lda 	GXSpriteLow,y
.b2fb	fd 62 06	sbc $0662,x			sbc 	GXSpriteLow,x
.b2fe	b0 03		bcs $b303			bcs 	_GXCAbs2
.b300	49 ff		eor #$ff			eor 	#$FF
.b302	1a		inc a				inc 	a
.b303					_GXCAbs2:
.b303	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b305	b0 0a		bcs $b311			bcs 	_GXOkayFail
.b307	c5 39		cmp $39				cmp 	gxzTemp1+1 					; is it less than the previous one.
.b309	90 02		bcc $b30d			bcc 	_GXCHaveLowest
.b30b	a5 39		lda $39				lda 	gxzTemp1+1 					; if not, that's the smallest difference.
.b30d					_GXCHaveLowest:
.b30d	0a		asl a				asl 	a 							; scale to allow for >> 2
.b30e	0a		asl a				asl 	a
.b30f	18		clc				clc
.b310	60		rts				rts
.b311					_GXOkayFail:
.b311	18		clc				clc
.b312					_GXCollideFail:
.b312	a9 ff		lda #$ff			lda 	#$FF
.b314	60		rts				rts
.b315					GXFindSprite:
.b315	aa		tax				tax
.b316	ad 55 06	lda $0655			lda 	GXSpritePage 				; access the base page of the sprite
.b319	85 0b		sta $0b				sta 	GXEditSlot
.b31b	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; check a valid sprite
.b31e	1d 00 60	ora $6000,x			ora 	GXMappingAddress,x
.b321	f0 33		beq $b356			beq 	_GXFSFail
.b323	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; MSB
.b326	8d f9 06	sta $06f9			sta 	GXSpriteOffset+1
.b329	bd 00 60	lda $6000,x			lda 	GXMappingAddress,x 			; LSB
.b32c	48		pha				pha 								; save twice
.b32d	48		pha				pha
.b32e	29 03		and #$03			and 	#3 							; get sprite size
.b330	8d f6 06	sta $06f6			sta 	GXSizeBits 					; save raw (0-3)
.b333	aa		tax				tax
.b334	bd 58 b3	lda $b358,x			lda 	_GXFXSSTTable,x 			; read sprite size
.b337	8d f5 06	sta $06f5			sta 	GXSizePixels 					; save (8/16/24/32)
.b33a	68		pla				pla 								; get LUT
.b33b	4a		lsr a				lsr		a
.b33c	4a		lsr a				lsr		a
.b33d	29 03		and #$03			and 	#3
.b33f	8d f7 06	sta $06f7			sta 	GXSpriteLUT
.b342	68		pla				pla 								; address, neeeds to be x 4
.b343	29 f0		and #$f0			and 	#$F0
.b345	8d f8 06	sta $06f8			sta 	GXSpriteOffset
.b348	0e f8 06	asl $06f8			asl 	GXSpriteOffset
.b34b	2e f9 06	rol $06f9			rol 	GXSpriteOffset+1
.b34e	0e f8 06	asl $06f8			asl 	GXSpriteOffset
.b351	2e f9 06	rol $06f9			rol 	GXSpriteOffset+1
.b354	18		clc				clc
.b355	60		rts				rts
.b356					_GXFSFail:
.b356	38		sec				sec
.b357	60		rts				rts
.b358					_GXFXSSTTable:
>b358	08 10 18 20					.byte 	8,16,24,32
.06f5					GXSizePixels:
>06f5							.fill 	1
.06f6					GXSizeBits:
>06f6							.fill 	1
.06f7					GXSpriteLUT:
>06f7							.fill 	1
.06f8					GXSpriteOffset:
>06f8							.fill 	2
.b35c					GXSortXY:
.b35c	20 7a b3	jsr $b37a			jsr 	GXSortY 					; will be sorted on Y now
.b35f	ad 4a 06	lda $064a			lda 	gxX0 						; compare X0 v X1
.b362	cd 4e 06	cmp $064e			cmp 	gxX1
.b365	ad 4b 06	lda $064b			lda 	gXX0+1
.b368	ed 4f 06	sbc $064f			sbc 	gXX1+1
.b36b	90 0c		bcc $b379			bcc 	_GXSXYExit 					; X0 < X1 exit
.b36d	a2 00		ldx #$00			ldx 	#0 							; swap them over
.b36f	a0 04		ldy #$04			ldy 	#4
.b371	20 8e b3	jsr $b38e			jsr 	GXSwapXY
.b374	e8		inx				inx
.b375	c8		iny				iny
.b376	20 8e b3	jsr $b38e			jsr 	GXSwapXY
.b379					_GXSXYExit:
.b379	60		rts				rts
.b37a					GXSortY:
.b37a	ad 4c 06	lda $064c			lda 	gxY0 						; if Y0 >= Y1
.b37d	cd 50 06	cmp $0650			cmp 	gxY1
.b380	90 0b		bcc $b38d			bcc 	_GXSYSorted
.b382	a2 03		ldx #$03			ldx 	#3 							; swap 3-0
.b384	a0 07		ldy #$07			ldy 	#7 							; with 4-7
.b386					_GXSwap1:
.b386	20 8e b3	jsr $b38e			jsr 	GXSwapXY
.b389	88		dey				dey
.b38a	ca		dex				dex
.b38b	10 f9		bpl $b386			bpl 	_GXSwap1
.b38d					_GXSYSorted:
.b38d	60		rts				rts
.b38e					GXSwapXY:
.b38e	bd 4a 06	lda $064a,x			lda 	gxX0,x
.b391	48		pha				pha
.b392	b9 4a 06	lda $064a,y			lda 	gxX0,y
.b395	9d 4a 06	sta $064a,x			sta 	gxX0,x
.b398	68		pla				pla
.b399	99 4a 06	sta $064a,y			sta 	gxX0,y
.b39c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_tokeniser.module

=1					tokeniserIntegrated=1
.b9ad					KeywordSet0:
>b9ad	00 65					.text	0,$65,""               ; $80 !0:EOF
>b9af	00 58					.text	0,$58,""               ; $81 !1:SH1
>b9b1	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b9b3	04 fe 41 42 53 28			.text	4,$fe,"ABS("           ; $83 ABS(
>b9b9	06 93 41 4c 4c 4f 43 28			.text	6,$93,"ALLOC("         ; $84 ALLOC(
>b9c1	04 ff 41 53 43 28			.text	4,$ff,"ASC("           ; $85 ASC(
>b9c7	05 29 43 48 52 24 28			.text	5,$29,"CHR$("          ; $86 CHR$(
>b9ce	06 aa 45 56 45 4e 54 28			.text	6,$aa,"EVENT("         ; $87 EVENT(
>b9d6	05 6b 46 41 4c 53 45			.text	5,$6b,"FALSE"          ; $88 FALSE
>b9dd	05 44 46 52 41 43 28			.text	5,$44,"FRAC("          ; $89 FRAC(
>b9e4	04 0d 48 49 54 28			.text	4,$0d,"HIT("           ; $8a HIT(
>b9ea	04 13 49 4e 54 28			.text	4,$13,"INT("           ; $8b INT(
>b9f0	06 a7 49 53 56 41 4c 28			.text	6,$a7,"ISVAL("         ; $8c ISVAL(
>b9f8	05 5c 4a 4f 59 42 28			.text	5,$5c,"JOYB("          ; $8d JOYB(
>b9ff	05 72 4a 4f 59 58 28			.text	5,$72,"JOYX("          ; $8e JOYX(
>ba06	05 73 4a 4f 59 59 28			.text	5,$73,"JOYY("          ; $8f JOYY(
>ba0d	06 77 4c 45 46 54 24 28			.text	6,$77,"LEFT$("         ; $90 LEFT$(
>ba15	04 07 4c 45 4e 28			.text	4,$07,"LEN("           ; $91 LEN(
>ba1b	04 0e 4d 41 58 28			.text	4,$0e,"MAX("           ; $92 MAX(
>ba21	05 26 4d 49 44 24 28			.text	5,$26,"MID$("          ; $93 MID$(
>ba28	04 0c 4d 49 4e 28			.text	4,$0c,"MIN("           ; $94 MIN(
>ba2e	04 19 4e 4f 54 28			.text	4,$19,"NOT("           ; $95 NOT(
>ba34	08 3c 50 4c 41 59 49 4e			.text	8,$3c,"PLAYING("       ; $96 PLAYING(
>ba3c	47 28
>ba3e	07 e9 52 41 4e 44 4f 4d			.text	7,$e9,"RANDOM("        ; $97 RANDOM(
>ba46	28
>ba47	07 ca 52 49 47 48 54 24			.text	7,$ca,"RIGHT$("        ; $98 RIGHT$(
>ba4f	28
>ba50	04 0c 52 4e 44 28			.text	4,$0c,"RND("           ; $99 RND(
>ba56	04 10 53 47 4e 28			.text	4,$10,"SGN("           ; $9a SGN(
>ba5c	04 0e 53 50 43 28			.text	4,$0e,"SPC("           ; $9b SPC(
>ba62	05 45 53 54 52 24 28			.text	5,$45,"STR$("          ; $9c STR$(
>ba69	06 a9 54 49 4d 45 52 28			.text	6,$a9,"TIMER("         ; $9d TIMER(
>ba71	04 40 54 52 55 45			.text	4,$40,"TRUE"           ; $9e TRUE
>ba77	04 0b 56 41 4c 28			.text	4,$0b,"VAL("           ; $9f VAL(
>ba7d	03 e7 46 4f 52				.text	3,$e7,"FOR"            ; $a0 FOR
>ba82	02 8f 49 46				.text	2,$8f,"IF"             ; $a1 IF
>ba86	04 34 50 52 4f 43			.text	4,$34,"PROC"           ; $a2 PROC
>ba8c	06 c1 52 45 50 45 41 54			.text	6,$c1,"REPEAT"         ; $a3 REPEAT
>ba94	05 79 57 48 49 4c 45			.text	5,$79,"WHILE"          ; $a4 WHILE
>ba9b	05 66 45 4e 44 49 46			.text	5,$66,"ENDIF"          ; $a5 ENDIF
>baa2	07 0b 45 4e 44 50 52 4f			.text	7,$0b,"ENDPROC"        ; $a6 ENDPROC
>baaa	43
>baab	04 3f 4e 45 58 54			.text	4,$3f,"NEXT"           ; $a7 NEXT
>bab1	04 2f 54 48 45 4e			.text	4,$2f,"THEN"           ; $a8 THEN
>bab7	05 8c 55 4e 54 49 4c			.text	5,$8c,"UNTIL"          ; $a9 UNTIL
>babe	04 2e 57 45 4e 44			.text	4,$2e,"WEND"           ; $aa WEND
>bac4	02 9b 42 59				.text	2,$9b,"BY"             ; $ab BY
>bac8	04 1c 43 41 4c 4c			.text	4,$1c,"CALL"           ; $ac CALL
>bace	06 b2 43 49 52 43 4c 45			.text	6,$b2,"CIRCLE"         ; $ad CIRCLE
>bad6	05 67 43 4c 45 41 52			.text	5,$67,"CLEAR"          ; $ae CLEAR
>badd	03 e2 43 4c 53				.text	3,$e2,"CLS"            ; $af CLS
>bae2	05 7f 43 4f 4c 4f 52			.text	5,$7f,"COLOR"          ; $b0 COLOR
>bae9	06 d4 43 4f 4c 4f 55 52			.text	6,$d4,"COLOUR"         ; $b1 COLOUR
>baf1	04 1a 44 41 54 41			.text	4,$1a,"DATA"           ; $b2 DATA
>baf7	03 da 44 49 4d				.text	3,$da,"DIM"            ; $b3 DIM
>bafc	06 db 44 4f 57 4e 54 4f			.text	6,$db,"DOWNTO"         ; $b4 DOWNTO
>bb04	04 29 45 4c 53 45			.text	4,$29,"ELSE"           ; $b5 ELSE
>bb0a	04 34 46 52 4f 4d			.text	4,$34,"FROM"           ; $b6 FROM
>bb10	03 e5 47 46 58				.text	3,$e5,"GFX"            ; $b7 GFX
>bb15	05 80 47 4f 53 55 42			.text	5,$80,"GOSUB"          ; $b8 GOSUB
>bb1c	04 39 47 4f 54 4f			.text	4,$39,"GOTO"           ; $b9 GOTO
>bb22	04 24 48 45 52 45			.text	4,$24,"HERE"           ; $ba HERE
>bb28	05 63 49 4d 41 47 45			.text	5,$63,"IMAGE"          ; $bb IMAGE
>bb2f	03 e5 4c 45 54				.text	3,$e5,"LET"            ; $bc LET
>bb34	04 28 4c 49 4e 45			.text	4,$28,"LINE"           ; $bd LINE
>bb3a	05 6b 4c 4f 43 41 4c			.text	5,$6b,"LOCAL"          ; $be LOCAL
>bb41	03 db 4f 46 46				.text	3,$db,"OFF"            ; $bf OFF
>bb46	02 9d 4f 4e				.text	2,$9d,"ON"             ; $c0 ON
>bb4a	07 20 4f 55 54 4c 49 4e			.text	7,$20,"OUTLINE"        ; $c1 OUTLINE
>bb52	45
>bb53	07 0f 50 41 4c 45 54 54			.text	7,$0f,"PALETTE"        ; $c2 PALETTE
>bb5b	45
>bb5c	04 3f 50 4c 4f 54			.text	4,$3f,"PLOT"           ; $c3 PLOT
>bb62	05 8d 50 52 49 4e 54			.text	5,$8d,"PRINT"          ; $c4 PRINT
>bb69	04 1c 52 45 41 44			.text	4,$1c,"READ"           ; $c5 READ
>bb6f	04 2e 52 45 43 54			.text	4,$2e,"RECT"           ; $c6 RECT
>bb75	03 e4 52 45 4d				.text	3,$e4,"REM"            ; $c7 REM
>bb7a	06 e0 52 45 54 55 52 4e			.text	6,$e0,"RETURN"         ; $c8 RETURN
>bb82	05 7b 53 4f 4c 49 44			.text	5,$7b,"SOLID"          ; $c9 SOLID
>bb89	05 89 53 4f 55 4e 44			.text	5,$89,"SOUND"          ; $ca SOUND
>bb90	06 d7 53 50 52 49 54 45			.text	6,$d7,"SPRITE"         ; $cb SPRITE
>bb98	04 45 54 45 58 54			.text	4,$45,"TEXT"           ; $cc TEXT
>bb9e	02 a3 54 4f				.text	2,$a3,"TO"             ; $cd TO
>bba2	ff					.text	$FF
.bba3					KeywordSet1:
>bba3	00 65					.text	0,$65,""               ; $80 !0:EOF
>bba5	00 58					.text	0,$58,""               ; $81 !1:SH1
>bba7	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bba9	08 4c 41 53 53 45 4d 42			.text	8,$4c,"ASSEMBLE"       ; $83 ASSEMBLE
>bbb1	4c 45
>bbb3	06 d2 41 53 53 45 52 54			.text	6,$d2,"ASSERT"         ; $84 ASSERT
>bbbb	06 bd 42 49 54 4d 41 50			.text	6,$bd,"BITMAP"         ; $85 BITMAP
>bbc3	03 d7 45 4e 44				.text	3,$d7,"END"            ; $86 END
>bbc8	04 3c 4c 49 53 54			.text	4,$3c,"LIST"           ; $87 LIST
>bbce	03 ea 4e 45 57				.text	3,$ea,"NEW"            ; $88 NEW
>bbd3	07 24 52 45 53 54 4f 52			.text	7,$24,"RESTORE"        ; $89 RESTORE
>bbdb	45
>bbdc	03 f5 52 55 4e				.text	3,$f5,"RUN"            ; $8a RUN
>bbe1	07 2a 53 50 52 49 54 45			.text	7,$2a,"SPRITES"        ; $8b SPRITES
>bbe9	53
>bbea	04 46 53 54 4f 50			.text	4,$46,"STOP"           ; $8c STOP
>bbf0	ff					.text	$FF
.bbf1					KeywordSet2:
>bbf1	00 65					.text	0,$65,""               ; $80 !0:EOF
>bbf3	00 58					.text	0,$58,""               ; $81 !1:SH1
>bbf5	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bbf7	03 c8 41 44 43				.text	3,$c8,"ADC"            ; $83 ADC
>bbfc	03 d3 41 4e 44				.text	3,$d3,"AND"            ; $84 AND
>bc01	03 e0 41 53 4c				.text	3,$e0,"ASL"            ; $85 ASL
>bc06	03 c8 42 43 43				.text	3,$c8,"BCC"            ; $86 BCC
>bc0b	03 d8 42 43 53				.text	3,$d8,"BCS"            ; $87 BCS
>bc10	03 d8 42 45 51				.text	3,$d8,"BEQ"            ; $88 BEQ
>bc15	03 df 42 49 54				.text	3,$df,"BIT"            ; $89 BIT
>bc1a	03 d8 42 4d 49				.text	3,$d8,"BMI"            ; $8a BMI
>bc1f	03 d5 42 4e 45				.text	3,$d5,"BNE"            ; $8b BNE
>bc24	03 de 42 50 4c				.text	3,$de,"BPL"            ; $8c BPL
>bc29	03 d5 42 52 41				.text	3,$d5,"BRA"            ; $8d BRA
>bc2e	03 df 42 52 4b				.text	3,$df,"BRK"            ; $8e BRK
>bc33	03 db 42 56 43				.text	3,$db,"BVC"            ; $8f BVC
>bc38	03 eb 42 56 53				.text	3,$eb,"BVS"            ; $90 BVS
>bc3d	03 d2 43 4c 43				.text	3,$d2,"CLC"            ; $91 CLC
>bc42	03 d3 43 4c 44				.text	3,$d3,"CLD"            ; $92 CLD
>bc47	03 d8 43 4c 49				.text	3,$d8,"CLI"            ; $93 CLI
>bc4c	03 e5 43 4c 56				.text	3,$e5,"CLV"            ; $94 CLV
>bc51	03 e0 43 4d 50				.text	3,$e0,"CMP"            ; $95 CMP
>bc56	03 eb 43 50 58				.text	3,$eb,"CPX"            ; $96 CPX
>bc5b	03 ec 43 50 59				.text	3,$ec,"CPY"            ; $97 CPY
>bc60	03 cc 44 45 43				.text	3,$cc,"DEC"            ; $98 DEC
>bc65	03 e1 44 45 58				.text	3,$e1,"DEX"            ; $99 DEX
>bc6a	03 e2 44 45 59				.text	3,$e2,"DEY"            ; $9a DEY
>bc6f	03 e6 45 4f 52				.text	3,$e6,"EOR"            ; $9b EOR
>bc74	03 da 49 4e 43				.text	3,$da,"INC"            ; $9c INC
>bc79	03 ef 49 4e 58				.text	3,$ef,"INX"            ; $9d INX
>bc7e	03 f0 49 4e 59				.text	3,$f0,"INY"            ; $9e INY
>bc83	03 e7 4a 4d 50				.text	3,$e7,"JMP"            ; $9f JMP
>bc88	03 ef 4a 53 52				.text	3,$ef,"JSR"            ; $a0 JSR
>bc8d	03 d1 4c 44 41				.text	3,$d1,"LDA"            ; $a1 LDA
>bc92	03 e8 4c 44 58				.text	3,$e8,"LDX"            ; $a2 LDX
>bc97	03 e9 4c 44 59				.text	3,$e9,"LDY"            ; $a3 LDY
>bc9c	03 f1 4c 53 52				.text	3,$f1,"LSR"            ; $a4 LSR
>bca1	03 ed 4e 4f 50				.text	3,$ed,"NOP"            ; $a5 NOP
>bca6	03 e2 4f 52 41				.text	3,$e2,"ORA"            ; $a6 ORA
>bcab	03 d9 50 48 41				.text	3,$d9,"PHA"            ; $a7 PHA
>bcb0	03 e8 50 48 50				.text	3,$e8,"PHP"            ; $a8 PHP
>bcb5	03 f0 50 48 58				.text	3,$f0,"PHX"            ; $a9 PHX
>bcba	03 f1 50 48 59				.text	3,$f1,"PHY"            ; $aa PHY
>bcbf	03 dd 50 4c 41				.text	3,$dd,"PLA"            ; $ab PLA
>bcc4	03 ec 50 4c 50				.text	3,$ec,"PLP"            ; $ac PLP
>bcc9	03 f4 50 4c 58				.text	3,$f4,"PLX"            ; $ad PLX
>bcce	03 f5 50 4c 59				.text	3,$f5,"PLY"            ; $ae PLY
>bcd3	03 ed 52 4f 4c				.text	3,$ed,"ROL"            ; $af ROL
>bcd8	03 f3 52 4f 52				.text	3,$f3,"ROR"            ; $b0 ROR
>bcdd	03 ef 52 54 49				.text	3,$ef,"RTI"            ; $b1 RTI
>bce2	03 f9 52 54 53				.text	3,$f9,"RTS"            ; $b2 RTS
>bce7	03 d8 53 42 43				.text	3,$d8,"SBC"            ; $b3 SBC
>bcec	03 db 53 45 43				.text	3,$db,"SEC"            ; $b4 SEC
>bcf1	03 dc 53 45 44				.text	3,$dc,"SED"            ; $b5 SED
>bcf6	03 e1 53 45 49				.text	3,$e1,"SEI"            ; $b6 SEI
>bcfb	03 e8 53 54 41				.text	3,$e8,"STA"            ; $b7 STA
>bd00	03 f7 53 54 50				.text	3,$f7,"STP"            ; $b8 STP
>bd05	03 ff 53 54 58				.text	3,$ff,"STX"            ; $b9 STX
>bd0a	03 00 53 54 59				.text	3,$00,"STY"            ; $ba STY
>bd0f	03 01 53 54 5a				.text	3,$01,"STZ"            ; $bb STZ
>bd14	03 ed 54 41 58				.text	3,$ed,"TAX"            ; $bc TAX
>bd19	03 ee 54 41 59				.text	3,$ee,"TAY"            ; $bd TAY
>bd1e	03 e8 54 52 42				.text	3,$e8,"TRB"            ; $be TRB
>bd23	03 e9 54 53 42				.text	3,$e9,"TSB"            ; $bf TSB
>bd28	03 ff 54 53 58				.text	3,$ff,"TSX"            ; $c0 TSX
>bd2d	03 ed 54 58 41				.text	3,$ed,"TXA"            ; $c1 TXA
>bd32	03 ff 54 58 53				.text	3,$ff,"TXS"            ; $c2 TXS
>bd37	03 ee 54 59 41				.text	3,$ee,"TYA"            ; $c3 TYA
>bd3c	ff					.text	$FF
.b39d					ListConvertLine:
.b39d	48		pha				pha 								; save indent on the stack
.b39e	9c 9d 04	stz $049d			stz 	tbOffset
.b3a1	9c ab 04	stz $04ab			stz 	tokenBuffer
.b3a4	a0 02		ldy #$02			ldy 	#2 							; convert line number to string
.b3a6	b1 30		lda ($30),y			lda 	(codePtr),y
.b3a8	aa		tax				tax
.b3a9	88		dey				dey
.b3aa	b1 30		lda ($30),y			lda 	(codePtr),y
.b3ac	20 67 92	jsr $9267			jsr 	LCLConvertInt16
.b3af	85 36		sta $36				sta 	zTemp0 						; copy number into buffer
.b3b1	86 37		stx $37				stx 	zTemp0+1
.b3b3	a9 8c		lda #$8c			lda 	#CLINumber+$80
.b3b5	20 fa b4	jsr $b4fa			jsr 	LCLWrite
.b3b8	a0 00		ldy #$00			ldy 	#0
.b3ba					_LCCopyNumber:
.b3ba	b1 36		lda ($36),y			lda 	(zTemp0),y
.b3bc	20 fa b4	jsr $b4fa			jsr 	LCLWrite
.b3bf	c8		iny				iny
.b3c0	b1 36		lda ($36),y			lda 	(zTemp0),y
.b3c2	d0 f6		bne $b3ba			bne 	_LCCopyNumber
.b3c4	68		pla				pla 								; adjustment to indent
.b3c5	48		pha				pha 								; save on stack
.b3c6	10 0c		bpl $b3d4			bpl 	_LCNoAdjust 				; don't adjust indent if +ve, do after.
.b3c8	18		clc				clc 								; add to list indent and make 0 if goes -ve.
.b3c9	6d a6 04	adc $04a6			adc 	listIndent
.b3cc	8d a6 04	sta $04a6			sta 	listIndent
.b3cf	10 03		bpl $b3d4			bpl 	_LCNoAdjust
.b3d1	9c a6 04	stz $04a6			stz 	listIndent
.b3d4					_LCNoAdjust:
.b3d4	18		clc				clc		 							; work out actual indent.
.b3d5	ad a6 04	lda $04a6			lda 	listIndent
.b3d8	0a		asl a				asl 	a
.b3d9	69 06		adc #$06			adc 	#6
.b3db	85 36		sta $36				sta 	zTemp0
.b3dd					_LCPadOut:
.b3dd	a9 20		lda #$20			lda 	#' '						; pad out to 6 characters
.b3df	20 fa b4	jsr $b4fa			jsr 	LCLWrite
.b3e2	ad 9d 04	lda $049d			lda 	tbOffset
.b3e5	c5 36		cmp $36				cmp 	zTemp0
.b3e7	d0 f4		bne $b3dd			bne 	_LCPadOut
.b3e9	a0 03		ldy #$03			ldy 	#3 							; start position.
.b3eb					_LCMainLoop:
.b3eb	a9 8a		lda #$8a			lda 	#CLIPunctuation+$80
.b3ed	20 fa b4	jsr $b4fa			jsr 	LCLWrite
.b3f0	b1 30		lda ($30),y			lda 	(codePtr),y
.b3f2	c9 80		cmp #$80			cmp 	#KWC_EOL 					; end of line ?
.b3f4	f0 17		beq $b40d			beq 	_LCExit
.b3f6	c9 10		cmp #$10			cmp 	#16 						; 0-5 are the double punctuations
.b3f8	90 1e		bcc $b418			bcc 	_LCDoubles
.b3fa	c9 20		cmp #$20			cmp 	#32 						; 16-31 are shifted punctuation from 64-91
.b3fc	90 2a		bcc $b428			bcc 	_LCShiftPunc
.b3fe	c9 40		cmp #$40			cmp 	#64 						; 32-64 are as stored, punc and digits
.b400	90 35		bcc $b437			bcc 	_LCPunctuation
.b402	c9 80		cmp #$80			cmp 	#128 						; 64-127 are variable identifiers.
.b404	90 3e		bcc $b444			bcc 	_LCIdentifiers
.b406	c9 fe		cmp #$fe			cmp 	#254 						; 128-253 are tokenised words
.b408	90 5f		bcc $b469			bcc 	_LCTokens
.b40a	4c c9 b4	jmp $b4c9			jmp 	_LCData 					; 254-5 are data objects
.b40d					_LCExit:
.b40d	68		pla				pla 								; get old indent adjust
.b40e	30 07		bmi $b417			bmi 	_LCExit2
.b410	18		clc				clc 								; add to indent if +ve
.b411	6d a6 04	adc $04a6			adc 	listIndent
.b414	8d a6 04	sta $04a6			sta 	listIndent
.b417					_LCExit2:
.b417	60		rts				rts
.b418					_LCDoubles:
.b418	48		pha				pha
.b419	4a		lsr a				lsr 	a 							; put bit 2 into bit 1
.b41a	29 02		and #$02			and 	#2
.b41c	09 3c		ora #$3c			ora 	#60 						; make < >
.b41e	20 fa b4	jsr $b4fa			jsr 	LCLWrite
.b421	68		pla				pla 								; restore, do lower bit
.b422	29 03		and #$03			and 	#3
.b424	09 3c		ora #$3c			ora 	#60
.b426	80 0f		bra $b437			bra		_LCPunctuation 				; print, increment, loop
.b428					_LCShiftPunc:
.b428	aa		tax				tax 								; save in X
.b429	29 07		and #$07			and 	#7 							; lower 3 bits
.b42b	f0 02		beq $b42f			beq 	_LCNoAdd
.b42d	09 18		ora #$18			ora 	#24 						; adds $18 to it.
.b42f					_LCNoAdd:
.b42f	e0 18		cpx #$18			cpx 	#24 						; if >= 24 add $20
.b431	90 02		bcc $b435			bcc 	_LCNoAdd2
.b433	09 20		ora #$20			ora 	#32 						; adds $20
.b435					_LCNoAdd2:
.b435	09 40		ora #$40			ora 	#$40 						; shift into 64-127 range and fall through.
.b437					_LCPunctuation:
.b437	c9 3a		cmp #$3a			cmp 	#':' 						; check if :
.b439	d0 03		bne $b43e			bne 	_LCPContinue
.b43b	20 10 b5	jsr $b510			jsr 	LCLDeleteLastSpace
.b43e					_LCPContinue:
.b43e	c8		iny				iny 								; consume character
.b43f	20 fa b4	jsr $b4fa			jsr 	LCLWrite 					; write it out.
.b442	80 a7		bra $b3eb			bra 	_LCMainLoop 				; go round again.
.b444					_LCIdentifiers:
.b444	18		clc				clc 								; convert to physical address
.b445	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.b447	85 37		sta $37				sta 	zTemp0+1
.b449	c8		iny				iny
.b44a	b1 30		lda ($30),y			lda 	(codePtr),y
.b44c	85 36		sta $36				sta 	zTemp0
.b44e	c8		iny				iny
.b44f	5a		phy				phy 								; save position
.b450	a9 87		lda #$87			lda 	#CLIIdentifier+$80
.b452	20 fa b4	jsr $b4fa			jsr 	LCLWrite
.b455	a0 07		ldy #$07			ldy 	#7 							; output the identifier.
.b457					_LCOutIdentifier:
.b457	c8		iny				iny
.b458	b1 36		lda ($36),y			lda 	(zTemp0),y
.b45a	29 7f		and #$7f			and 	#$7F
.b45c	20 4c b5	jsr $b54c			jsr 	LCLLowerCase
.b45f	20 fa b4	jsr $b4fa			jsr 	LCLWrite
.b462	b1 36		lda ($36),y			lda 	(zTemp0),y				 	; ends when bit 7 set.
.b464	10 f1		bpl $b457			bpl 	_LCOutIdentifier
.b466	7a		ply				ply 								; restore position
.b467	80 82		bra $b3eb			bra 	_LCMainLoop
.b469					_LCTokens:
.b469	aa		tax				tax 								; token in X
.b46a	a9 f1		lda #$f1			lda 	#((KeywordSet2) & $FF)
.b46c	85 36		sta $36				sta 	0+zTemp0
.b46e	a9 bb		lda #$bb			lda 	#((KeywordSet2) >> 8)
.b470	85 37		sta $37				sta 	1+zTemp0
.b472	e0 82		cpx #$82			cpx 	#$82
.b474	f0 16		beq $b48c			beq 	_LCUseShift
.b476	a9 a3		lda #$a3			lda 	#((KeywordSet1) & $FF)
.b478	85 36		sta $36				sta 	0+zTemp0
.b47a	a9 bb		lda #$bb			lda 	#((KeywordSet1) >> 8)
.b47c	85 37		sta $37				sta 	1+zTemp0
.b47e	e0 81		cpx #$81			cpx 	#$81
.b480	f0 0a		beq $b48c			beq 	_LCUseShift
.b482	a9 ad		lda #$ad			lda 	#((KeywordSet0) & $FF)
.b484	85 36		sta $36				sta 	0+zTemp0
.b486	a9 b9		lda #$b9			lda 	#((KeywordSet0) >> 8)
.b488	85 37		sta $37				sta 	1+zTemp0
.b48a	80 01		bra $b48d			bra 	_LCNoShift
.b48c					_LCUseShift:
.b48c	c8		iny				iny
.b48d					_LCNoShift:
.b48d	20 24 b5	jsr $b524			jsr 	LCLCheckSpaceRequired 		; do we need a space ?
.b490	b1 30		lda ($30),y			lda 	(codePtr),y
.b492	aa		tax				tax 								; into X
.b493					_LCFindText:
.b493	ca		dex				dex
.b494	10 0e		bpl $b4a4			bpl 	_LCFoundText 				; found text.
.b496	b2 36		lda ($36)			lda 	(zTemp0) 					; length of text
.b498	1a		inc a				inc 	a 							; one extra for size
.b499	38		sec				sec 								; one extra for checksum
.b49a	65 36		adc $36				adc 	zTemp0 						; go to next token
.b49c	85 36		sta $36				sta 	zTemp0
.b49e	90 f3		bcc $b493			bcc 	_LCFindText
.b4a0	e6 37		inc $37				inc 	zTemp0+1
.b4a2	80 ef		bra $b493			bra 	_LCFindText
.b4a4					_LCFoundText:
.b4a4	5a		phy				phy 								; save List position
.b4a5	b2 36		lda ($36)			lda 	(zTemp0)					; count to print
.b4a7	aa		tax				tax
.b4a8	a9 83		lda #$83			lda 	#CLIToken+$80
.b4aa	20 fa b4	jsr $b4fa			jsr 	LCLWrite
.b4ad	a0 02		ldy #$02			ldy 	#2
.b4af					_LCCopyToken:
.b4af	b1 36		lda ($36),y			lda 	(zTemp0),y
.b4b1	20 4c b5	jsr $b54c			jsr 	LCLLowerCase
.b4b4	20 fa b4	jsr $b4fa			jsr 	LCLWrite
.b4b7	c8		iny				iny
.b4b8	ca		dex				dex
.b4b9	d0 f4		bne $b4af			bne 	_LCCopyToken
.b4bb	c9 28		cmp #$28			cmp 	#"(" 						; if last char not ( print a space
.b4bd	f0 05		beq $b4c4			beq 	_LCNoSpace
.b4bf	a9 20		lda #$20			lda 	#' '
.b4c1	20 fa b4	jsr $b4fa			jsr 	LCLWrite
.b4c4					_LCNoSpace:
.b4c4	7a		ply				ply 								; restore position.
.b4c5	c8		iny				iny 								; consume token
.b4c6	4c eb b3	jmp $b3eb			jmp 	_LCMainLoop 				; and go around again.
.b4c9					_LCData:
.b4c9	48		pha				pha 								; save type $FE/$FF
.b4ca	a2 24		ldx #$24			ldx 	#'$' 						; figure out $ or "
.b4cc	c9 fe		cmp #$fe			cmp 	#$FE
.b4ce	f0 07		beq $b4d7			beq 	_LCHaveOpener
.b4d0	a2 22		ldx #$22			ldx 	#'"'
.b4d2	a9 81		lda #$81			lda 	#CLIData+$80
.b4d4	20 fa b4	jsr $b4fa			jsr 	LCLWrite
.b4d7					_LCHaveOpener:
.b4d7	8a		txa				txa 								; output prefix (# or ")
.b4d8	20 fa b4	jsr $b4fa			jsr 	LCLWrite
.b4db	c8		iny				iny 								; get count
.b4dc	b1 30		lda ($30),y			lda 	(codePtr),y
.b4de	aa		tax				tax
.b4df	c8		iny				iny 								; point at first character
.b4e0					_LCOutData:
.b4e0	b1 30		lda ($30),y			lda 	(codePtr),y
.b4e2	c9 00		cmp #$00			cmp 	#0
.b4e4	f0 03		beq $b4e9			beq 	_LCNoPrint
.b4e6	20 fa b4	jsr $b4fa			jsr 	LCLWrite
.b4e9					_LCNoPrint:
.b4e9	c8		iny				iny
.b4ea	ca		dex				dex
.b4eb	d0 f3		bne $b4e0			bne 	_LCOutData
.b4ed	68		pla				pla 								; closing " required ?
.b4ee	c9 ff		cmp #$ff			cmp 	#$FF
.b4f0	d0 05		bne $b4f7			bne 	_LCNoQuote
.b4f2	a9 22		lda #$22			lda 	#'"'
.b4f4	20 fa b4	jsr $b4fa			jsr 	LCLWrite
.b4f7					_LCNoQuote:
.b4f7	4c eb b3	jmp $b3eb			jmp 	_LCMainLoop
.b4fa					LCLWrite:
.b4fa	da		phx				phx
.b4fb	ae 9d 04	ldx $049d			ldx 	tbOffset
.b4fe	9d ab 04	sta $04ab,x			sta 	tokenBuffer,x
.b501	9e ac 04	stz $04ac,x			stz 	tokenBuffer+1,x
.b504	ee 9d 04	inc $049d			inc 	tbOffset
.b507	09 00		ora #$00			ora 	#0 							; don't update if colour data
.b509	30 03		bmi $b50e			bmi 	_LCLNoColour
.b50b	8d a7 04	sta $04a7			sta 	LCLastCharacter
.b50e					_LCLNoColour:
.b50e	fa		plx				plx
.b50f	60		rts				rts
.b510					LCLDeleteLastSpace:
.b510	48		pha				pha
.b511	da		phx				phx
.b512	ae 9d 04	ldx $049d			ldx 	tbOffset
.b515	f0 0a		beq $b521			beq 	_LCDLSExit
.b517	bd aa 04	lda $04aa,x			lda 	tokenBuffer-1,x
.b51a	c9 20		cmp #$20			cmp 	#' '
.b51c	d0 03		bne $b521			bne 	_LCDLSExit
.b51e	ce 9d 04	dec $049d			dec 	tbOffset
.b521					_LCDLSExit:
.b521	fa		plx				plx
.b522	68		pla				pla
.b523	60		rts				rts
.b524					LCLCheckSpaceRequired:
.b524	ad a7 04	lda $04a7			lda 	LCLastCharacter 			; check last character
.b527	c9 24		cmp #$24			cmp 	#'$' 						; $ # and ) require that token space.
.b529	f0 1b		beq $b546			beq 	_LCCSRSpace
.b52b	c9 29		cmp #$29			cmp 	#')'
.b52d	f0 17		beq $b546			beq 	_LCCSRSpace
.b52f	c9 23		cmp #$23			cmp 	#'#'
.b531	f0 13		beq $b546			beq 	_LCCSRSpace
.b533	20 4c b5	jsr $b54c			jsr 	LCLLowerCase 				; saves a little effort
.b536	c9 30		cmp #$30			cmp 	#"0" 						; check if it was 0-9 A-Z a-z if so need space.
.b538	90 11		bcc $b54b			bcc 	_LCCSRExit
.b53a	c9 3a		cmp #$3a			cmp 	#"9"+1
.b53c	90 08		bcc $b546			bcc 	_LCCSRSpace
.b53e	c9 61		cmp #$61			cmp 	#"a"
.b540	90 09		bcc $b54b			bcc 	_LCCSRExit
.b542	c9 7b		cmp #$7b			cmp 	#"z"+1
.b544	b0 05		bcs $b54b			bcs 	_LCCSRExit
.b546					_LCCSRSpace:
.b546	a9 20		lda #$20			lda 	#' '
.b548	20 fa b4	jsr $b4fa			jsr 	LCLWrite
.b54b					_LCCSRExit:
.b54b	60		rts				rts
.b54c					LCLLowerCase:
.b54c	c9 41		cmp #$41			cmp 	#"A"
.b54e	90 06		bcc $b556			bcc 	_LCLLCOut
.b550	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b552	b0 02		bcs $b556			bcs 	_LCLLCOut
.b554	69 20		adc #$20			adc 	#$20
.b556					_LCLLCOut:
.b556	60		rts				rts
.b557					LCLUpperCase:
.b557	c9 61		cmp #$61			cmp 	#"a"
.b559	90 06		bcc $b561			bcc 	_LCLUCOut
.b55b	c9 7b		cmp #$7b			cmp 	#"z"+1
.b55d	b0 02		bcs $b561			bcs 	_LCLUCOut
.b55f	e9 1f		sbc #$1f			sbc 	#$1F
.b561					_LCLUCOut:
.b561	60		rts				rts
.b562					TOKSearchTable:
.b562	84 37		sty $37				sty 	zTemp0+1 					; (zTemp0),y points to current token.
.b564	85 36		sta $36				sta 	zTemp0
.b566	a0 00		ldy #$00			ldy 	#0
.b568	a9 80		lda #$80			lda 	#$80 						; token #
.b56a	85 38		sta $38				sta 	zTemp1
.b56c					_TSTLoop:
.b56c	b1 36		lda ($36),y			lda 	(zTemp0),y 					; length, 0 (skip) -ve (end)
.b56e	30 49		bmi $b5b9			bmi 	_TSTFail 					; -ve = end of table
.b570	f0 2e		beq $b5a0			beq 	_TSTNext 					; zero, check next it's a dummy
.b572	c8		iny				iny 								; get the hash
.b573	b1 36		lda ($36),y			lda 	(zTemp0),y
.b575	88		dey				dey
.b576	cd 83 04	cmp $0483			cmp 	identHash 					; check they match, if not go to next
.b579	d0 25		bne $b5a0			bne 	_TSTNext
.b57b	ad 82 04	lda $0482			lda 	identTypeEnd 				; length of identifier
.b57e	38		sec				sec
.b57f	ed 80 04	sbc $0480			sbc 	identStart
.b582	d1 36		cmp ($36),y			cmp 	(zTemp0),y 					; no match, then return.
.b584	d0 1a		bne $b5a0			bne 	_TSTNext
.b586	5a		phy				phy 								; save Y , we might fail
.b587	c8		iny				iny 								; point to text
.b588	c8		iny				iny
.b589	ae 80 04	ldx $0480			ldx 	identStart 					; offset in line buffer in X
.b58c					_TSTCompareName:
.b58c	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; compare text.
.b58f	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.b591	d0 0c		bne $b59f			bne 	_TSTNextPullY 				; fail, pullY and do next
.b593	e8		inx				inx
.b594	c8		iny				iny
.b595	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; complete match.
.b598	d0 f2		bne $b58c			bne 	_TSTCompareName
.b59a	7a		ply				ply 								; throw Y
.b59b	a5 38		lda $38				lda 	zTemp1 						; get token #
.b59d	38		sec				sec 								; return with CS = passed.
.b59e	60		rts				rts
.b59f					_TSTNextPullY:
.b59f	7a		ply				ply 								; restore current, fall through.
.b5a0					_TSTNext:
.b5a0	e6 38		inc $38				inc 	zTemp1 						; token counter
.b5a2	98		tya				tya
.b5a3	18		clc				clc
.b5a4	71 36		adc ($36),y			adc 	(zTemp0),y 					; add [Length] + 2 to Y
.b5a6	1a		inc a				inc 	a 							; +1
.b5a7	1a		inc a				inc 	a 							; +2
.b5a8	a8		tay				tay
.b5a9	10 c1		bpl $b56c			bpl 	_TSTLoop 					; if Y < $80 loop back
.b5ab	98		tya				tya 								; add Y to zTemp0 and reset Y
.b5ac	a0 00		ldy #$00			ldy 	#0   						; so we can use Y to search fast
.b5ae	18		clc				clc  								; but have tables > 255 bytes
.b5af	65 36		adc $36				adc 	zTemp0 						; when Y gets >= 128 we reset Y
.b5b1	85 36		sta $36				sta 	zTemp0 						; and adjust the table pointer/
.b5b3	90 b7		bcc $b56c			bcc 	_TSTLoop
.b5b5	e6 37		inc $37				inc 	zTemp0+1
.b5b7	80 b3		bra $b56c			bra 	_TSTLoop
.b5b9					_TSTFail:
.b5b9	18		clc				clc
.b5ba	60		rts				rts
.b5bb					TokeniseLine:
.b5bb	20 43 b7	jsr $b743			jsr 	LCLFixLineBufferCase 		; fix line case
.b5be	a9 03		lda #$03			lda 	#3 							; reset the token buffer to empty
.b5c0	8d a8 04	sta $04a8			sta 	tokenOffset
.b5c3	9c a9 04	stz $04a9			stz 	tokenLineNumber
.b5c6	9c aa 04	stz $04aa			stz 	tokenLineNumber+1
.b5c9	a2 ff		ldx #$ff			ldx 	#$FF
.b5cb					_TKFindFirst:
.b5cb	e8		inx				inx
.b5cc	bd a8 05	lda $05a8,x			lda 	lineBuffer,x
.b5cf	f0 79		beq $b64a			beq 	_TKExit
.b5d1	c9 20		cmp #$20			cmp 	#' '
.b5d3	90 f6		bcc $b5cb			bcc 	_TKFindFirst
.b5d5	c9 30		cmp #$30			cmp 	#'0'
.b5d7	90 07		bcc $b5e0			bcc 	_TKNoLineNumber
.b5d9	c9 3a		cmp #$3a			cmp 	#'9'+1
.b5db	b0 03		bcs $b5e0			bcs 	_TKNoLineNumber
.b5dd	20 6d b7	jsr $b76d			jsr 	TOKExtractLineNumber
.b5e0					_TKNoLineNumber:
.b5e0					_TKTokeniseLoop:
.b5e0	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; next character, exit if zero EOL.
.b5e3	f0 65		beq $b64a			beq 	_TKExit
.b5e5	e8		inx				inx
.b5e6	c9 20		cmp #$20			cmp 	#' '
.b5e8	f0 f6		beq $b5e0			beq 	_TKTokeniseLoop 			; keep looping if space found.
.b5ea	ca		dex				dex 								; undo last get, A contains character, X is position.
.b5eb	c9 5f		cmp #$5f			cmp 	#'_'						; _ A-Z is identifier *or* token
.b5ed	f0 61		beq $b650			beq 	_TKTokeniseIdentifier
.b5ef	c9 41		cmp #$41			cmp 	#'A'
.b5f1	90 04		bcc $b5f7			bcc 	_TKTokenisePunctuation
.b5f3	c9 5b		cmp #$5b			cmp 	#'Z'+1
.b5f5	90 59		bcc $b650			bcc 	_TKTokeniseIdentifier
.b5f7					_TKTokenisePunctuation:
.b5f7	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.b5f9	f0 27		beq $b622			beq 	_TKString
.b5fb	c9 24		cmp #$24			cmp 	#'$'						; hexadecimal constant (# only appears at end of identifiers)
.b5fd	f0 28		beq $b627			beq 	_TKHexConstant
.b5ff	c9 3c		cmp #$3c			cmp 	#'<' 						; check for < > handlers.
.b601	f0 29		beq $b62c			beq 	_TKCheckDouble
.b603	c9 3e		cmp #$3e			cmp 	#'>'
.b605	f0 25		beq $b62c			beq 	_TKCheckDouble
.b607					_TKStandardPunctuation:
.b607	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; get it back.
.b60a	c9 40		cmp #$40			cmp 	#64 						; are we >= 64
.b60c	90 0e		bcc $b61c			bcc 	_TKNoShift
.b60e	48		pha				pha 								; save
.b60f	29 07		and #$07			and 	#7 							; lower 3 bits in zTemp0
.b611	85 36		sta $36				sta 	zTemp0
.b613	68		pla				pla
.b614	29 20		and #$20			and 	#32 						; bit 5
.b616	4a		lsr a				lsr 	a 							; shift into bit 3
.b617	4a		lsr a				lsr 	a
.b618	05 36		ora $36				ora 	zTemp0
.b61a	09 10		ora #$10			ora 	#$10						; now in the range 16-31
.b61c					_TKNoShift:
.b61c	20 b2 b7	jsr $b7b2			jsr 	TOKWriteByte 				; write the punctuation character
.b61f	e8		inx				inx 								; consume the character
.b620	80 be		bra $b5e0			bra 	_TKTokeniseLoop 			; and loop round again.
.b622					_TKString:
.b622	20 d2 b6	jsr $b6d2			jsr 	TOKTokenString
.b625	80 b9		bra $b5e0			bra 	_TKTokeniseLoop
.b627					_TKHexConstant:
.b627	20 0d b7	jsr $b70d			jsr 	TOKHexConstant
.b62a	80 b4		bra $b5e0			bra 	_TKTokeniseLoop
.b62c					_TKCheckDouble:
.b62c	bd a9 05	lda $05a9,x			lda 	lineBuffer+1,x 				; get next character
.b62f	c9 3c		cmp #$3c			cmp 	#'<'						; if not < = > which are ASCII consecutive go back
.b631	90 d4		bcc $b607			bcc 	_TKStandardPunctuation
.b633	c9 3f		cmp #$3f			cmp 	#'>'+1
.b635	b0 d0		bcs $b607			bcs 	_TKStandardPunctuation
.b637	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; this is < (60) or > (62)
.b63a	29 02		and #$02			and 	#2 							; now < (0) or > (2)
.b63c	0a		asl a				asl 	a 							; now < (0) or > (4), CC also
.b63d	7d a9 05	adc $05a9,x			adc 	lineBuffer+1,x 				; add < = > codes - < code
.b640	38		sec				sec
.b641	e9 3c		sbc #$3c			sbc 	#'<'
.b643	20 b2 b7	jsr $b7b2			jsr 	TOKWriteByte 				; this is in the range 0-7
.b646	e8		inx				inx 								; consume both
.b647	e8		inx				inx
.b648	80 96		bra $b5e0			bra 	_TKTokeniseLoop
.b64a	a9 80		lda #$80	_TKExit:lda 	#KWC_EOL 					; write end of line byte
.b64c	20 b2 b7	jsr $b7b2			jsr 	TOKWriteByte
.b64f	60		rts				rts
.b650					_TKTokeniseIdentifier:
.b650	8e 80 04	stx $0480			stx 	identStart 					; save start
.b653	9c 84 04	stz $0484			stz 	identTypeByte 				; zero the type byte
.b656					_TKCheckLoop:
.b656	e8		inx				inx 								; look at next, we know first is identifier.
.b657	bd a8 05	lda $05a8,x			lda  	lineBuffer,x
.b65a	c9 5f		cmp #$5f			cmp 	#"_" 						; legal char _ 0-9 A-Z
.b65c	f0 f8		beq $b656			beq 	_TKCheckLoop
.b65e	c9 30		cmp #$30			cmp	 	#"0"
.b660	90 0c		bcc $b66e			bcc 	_TKEndIdentifier
.b662	c9 3a		cmp #$3a			cmp 	#"9"+1
.b664	90 f0		bcc $b656			bcc 	_TKCheckLoop
.b666	c9 41		cmp #$41			cmp	 	#"A"
.b668	90 04		bcc $b66e			bcc 	_TKEndIdentifier
.b66a	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b66c	90 e8		bcc $b656			bcc 	_TKCheckLoop
.b66e					_TKEndIdentifier:
.b66e	8e 81 04	stx $0481			stx 	identTypeStart 				; save start of type text (if any !)
.b671	a0 08		ldy #$08			ldy 	#$08 						; this is the identifier type byte for #
.b673	c9 23		cmp #$23			cmp 	#"#"						; followed by #
.b675	f0 06		beq $b67d			beq 	_TKHasTypeCharacter
.b677	a0 10		ldy #$10			ldy 	#$10 						; this is the identifier type byte for $
.b679	c9 24		cmp #$24			cmp 	#"$"						; followed by $ or #
.b67b	d0 07		bne $b684			bne 	_TKNoTypeCharacter
.b67d					_TKHasTypeCharacter:
.b67d	8c 84 04	sty $0484			sty 	identTypeByte 				; has # or $, save the type
.b680	e8		inx				inx 								; read next
.b681	bd a8 05	lda $05a8,x			lda 	lineBuffer,x
.b684					_TKNoTypeCharacter:
.b684	c9 28		cmp #$28			cmp 	#"("						; is it open parenthesis (e.g. array)
.b686	d0 09		bne $b691			bne 	_TKNoArray
.b688	e8		inx				inx 								; skip the (
.b689	ad 84 04	lda $0484			lda 	identTypeByte 				; set bit 2 (e.g. array)
.b68c	09 04		ora #$04			ora 	#$04
.b68e	8d 84 04	sta $0484			sta 	identTypeByte
.b691					_TKNoArray:
.b691	8e 82 04	stx $0482			stx 	identTypeEnd 				; save end marker, e.g. continue from here.
.b694	20 2e b7	jsr $b72e			jsr 	TOKCalculateHash 			; calculate the has for those tokens
.b697	a0 b9		ldy #$b9			ldy 	#(KeywordSet0) >> 8
.b699	a9 ad		lda #$ad			lda 	#(KeywordSet0) & $FF
.b69b	20 62 b5	jsr $b562			jsr 	TOKSearchTable
.b69e	a2 00		ldx #$00			ldx 	#0
.b6a0	b0 1f		bcs $b6c1			bcs 	_TKFoundToken
.b6a2	a0 bb		ldy #$bb			ldy 	#(KeywordSet1) >> 8
.b6a4	a9 a3		lda #$a3			lda 	#(KeywordSet1) & $FF
.b6a6	20 62 b5	jsr $b562			jsr 	TOKSearchTable
.b6a9	a2 81		ldx #$81			ldx 	#$81
.b6ab	b0 14		bcs $b6c1			bcs 	_TKFoundToken
.b6ad	a0 bb		ldy #$bb			ldy 	#(KeywordSet2) >> 8
.b6af	a9 f1		lda #$f1			lda 	#(KeywordSet2) & $FF
.b6b1	20 62 b5	jsr $b562			jsr 	TOKSearchTable
.b6b4	a2 82		ldx #$82			ldx 	#$82
.b6b6	b0 09		bcs $b6c1			bcs 	_TKFoundToken
.b6b8	20 be b7	jsr $b7be			jsr 	TOKCheckCreateVariableRecord ; failed all, it's a variable, create record if does not exist.
.b6bb	ae 82 04	ldx $0482			ldx 	identTypeEnd 				; X points to following byte
.b6be	4c e0 b5	jmp $b5e0			jmp 	_TKTokeniseLoop 			; and go round again.
.b6c1					_TKFoundToken:
.b6c1	48		pha				pha 								; save token
.b6c2	8a		txa				txa 								; shift in X, is there one ?
.b6c3	f0 03		beq $b6c8			beq 	_TKNoTShift
.b6c5	20 b2 b7	jsr $b7b2			jsr 	TOKWriteByte 				; if so, write it out
.b6c8					_TKNoTShift:
.b6c8	68		pla				pla 								; restore and write token
.b6c9	20 b2 b7	jsr $b7b2			jsr 	TOKWriteByte
.b6cc	ae 82 04	ldx $0482			ldx 	identTypeEnd 				; X points to following byte
.b6cf	4c e0 b5	jmp $b5e0			jmp 	_TKTokeniseLoop 			; and go round again.
.b6d2					TOKTokenString:
.b6d2	a9 ff		lda #$ff			lda 	#KWC_STRING 				; string token.
.b6d4	20 b2 b7	jsr $b7b2			jsr 	TOKWriteByte
.b6d7	e8		inx				inx									; start of quoted string.
.b6d8	da		phx				phx 								; push start of string on top
.b6d9	ca		dex				dex
.b6da					_TSFindEnd:
.b6da	e8		inx				inx
.b6db	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; next character
.b6de	f0 04		beq $b6e4			beq 	_TSEndOfString
.b6e0	c9 22		cmp #$22			cmp 	#'"'
.b6e2	d0 f6		bne $b6da			bne 	_TSFindEnd
.b6e4					_TSEndOfString:
.b6e4	7a		ply				ply  								; so now Y is first character, X is character after end.
.b6e5	48		pha				pha 								; save terminating character
.b6e6	20 ee b6	jsr $b6ee			jsr 	TOKWriteBlockXY 			; write X to Y as a data block
.b6e9	68		pla				pla 								; terminating character
.b6ea	f0 01		beq $b6ed			beq 	_TSNotQuote					; if it wasn't EOS skip it
.b6ec	e8		inx				inx
.b6ed					_TSNotQuote:
.b6ed	60		rts				rts
.b6ee					TOKWriteBlockXY:
.b6ee	86 36		stx $36				stx 	zTemp0 						; write end character
.b6f0	98		tya				tya
.b6f1	49 ff		eor #$ff			eor 	#$FF
.b6f3	38		sec				sec
.b6f4	65 36		adc $36				adc 	zTemp0
.b6f6	1a		inc a				inc 	a 							; one extra for NULL
.b6f7	20 b2 b7	jsr $b7b2			jsr 	TOKWriteByte
.b6fa					_TOBlockLoop:
.b6fa	c4 36		cpy $36				cpy 	zTemp0
.b6fc	f0 09		beq $b707			beq 	_TOBlockExit
.b6fe	b9 a8 05	lda $05a8,y			lda 	lineBuffer,y
.b701	20 b2 b7	jsr $b7b2			jsr 	TOKWriteByte
.b704	c8		iny				iny
.b705	80 f3		bra $b6fa			bra 	_TOBlockLoop
.b707					_TOBlockExit:
.b707	a9 00		lda #$00			lda 	#0
.b709	20 b2 b7	jsr $b7b2			jsr 	TOKWriteByte
.b70c	60		rts				rts
.b70d					TOKHexConstant:
.b70d	a9 fe		lda #$fe			lda 	#KWC_HEXCONST 				; hex constant token.
.b70f	20 b2 b7	jsr $b7b2			jsr 	TOKWriteByte
.b712	e8		inx				inx									; start of quoted string.
.b713	da		phx				phx 								; push start of constant on top
.b714	ca		dex				dex
.b715					_THFindLoop:
.b715	e8		inx				inx
.b716	bd a8 05	lda $05a8,x			lda 	lineBuffer,x
.b719	c9 30		cmp #$30			cmp 	#"0"
.b71b	90 0c		bcc $b729			bcc 	_THFoundEnd
.b71d	c9 3a		cmp #$3a			cmp 	#"9"+1
.b71f	90 f4		bcc $b715			bcc 	_THFindLoop
.b721	c9 41		cmp #$41			cmp 	#"A"
.b723	90 04		bcc $b729			bcc 	_THFoundEnd
.b725	c9 47		cmp #$47			cmp 	#"F"+1
.b727	90 ec		bcc $b715			bcc 	_THFindLoop
.b729					_THFoundEnd:
.b729	7a		ply				ply 								; restore start
.b72a	20 ee b6	jsr $b6ee			jsr 	TOKWriteBlockXY 			; output the block
.b72d	60		rts				rts
.b72e					TOKCalculateHash:
.b72e	da		phx				phx
.b72f	ae 80 04	ldx $0480			ldx 	identStart 					; needs to be same as in tokens.py - simple sum
.b732	a9 00		lda #$00			lda 	#0
.b734					_TCHLoop:
.b734	18		clc				clc
.b735	7d a8 05	adc $05a8,x			adc 	lineBuffer,x
.b738	e8		inx				inx
.b739	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; do the whole thing including type and array markers.
.b73c	d0 f6		bne $b734			bne 	_TCHLoop
.b73e	8d 83 04	sta $0483			sta 	identHash 					; save the hash
.b741	fa		plx				plx
.b742	60		rts				rts
.b743					LCLFixLineBufferCase:
.b743	a2 00		ldx #$00			ldx 	#0
.b745					_FLBCLoop:
.b745	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; get next character
.b748	f0 22		beq $b76c			beq 	_FLBCExit 					; end of string.
.b74a	c9 22		cmp #$22			cmp 	#'"'						; quote, go to in quotes
.b74c	f0 11		beq $b75f			beq 	_FLBCInQuotes
.b74e	e8		inx				inx
.b74f	c9 61		cmp #$61			cmp 	#'a'						; needs capitalising ?
.b751	90 f2		bcc $b745			bcc 	_FLBCLoop
.b753	c9 7b		cmp #$7b			cmp 	#'z'+1
.b755	b0 ee		bcs $b745			bcs 	_FLBCLoop
.b757	38		sec				sec 								; make U/C
.b758	e9 20		sbc #$20			sbc 	#32
.b75a	9d a7 05	sta $05a7,x			sta	 	lineBuffer-1,x 				; write back
.b75d	80 e6		bra $b745			bra 	_FLBCLoop
.b75f					_FLBCInQuotes:
.b75f	e8		inx				inx 								; advance
.b760	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; get next
.b763	f0 07		beq $b76c			beq 	_FLBCExit 					; exit on EOS
.b765	c9 22		cmp #$22			cmp 	#'"' 				 		; until " found
.b767	d0 f6		bne $b75f			bne 	_FLBCInQuotes
.b769	e8		inx				inx 								; skip over it
.b76a	80 d9		bra $b745			bra 	_FLBCLoop
.b76c					_FLBCExit:
.b76c	60		rts				rts
.b76d					TOKExtractLineNumber:
.b76d	ad aa 04	lda $04aa			lda 	tokenLineNumber+1 			; push current value on stack
.b770	48		pha				pha
.b771	ad a9 04	lda $04a9			lda 	tokenLineNumber
.b774	48		pha				pha
.b775	20 ab b7	jsr $b7ab			jsr 	_LCLNTimes2 				; line # x 4
.b778	20 ab b7	jsr $b7ab			jsr 	_LCLNTimes2 				; line # x 2
.b77b	18		clc				clc 								; add stacked value
.b77c	68		pla				pla
.b77d	6d a9 04	adc $04a9			adc 	tokenLineNumber
.b780	8d a9 04	sta $04a9			sta 	tokenLineNumber
.b783	68		pla				pla
.b784	6d aa 04	adc $04aa			adc 	tokenLineNumber+1
.b787	8d aa 04	sta $04aa			sta 	tokenLineNumber+1 			; line # x 5
.b78a	20 ab b7	jsr $b7ab			jsr 	_LCLNTimes2 				; line # x 10
.b78d	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; get and consume character
.b790	e8		inx				inx
.b791	29 0f		and #$0f			and 	#15 						; add to line #
.b793	18		clc				clc
.b794	6d a9 04	adc $04a9			adc 	tokenLineNumber
.b797	8d a9 04	sta $04a9			sta 	tokenLineNumber
.b79a	90 03		bcc $b79f			bcc 	_TLENNoCarry
.b79c	ee aa 04	inc $04aa			inc 	tokenLineNumber+1
.b79f					_TLENNoCarry:
.b79f	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; more digits ?
.b7a2	c9 30		cmp #$30			cmp 	#'0'
.b7a4	90 04		bcc $b7aa			bcc 	_TLENExit
.b7a6	c9 3a		cmp #$3a			cmp 	#'9'+1
.b7a8	90 c3		bcc $b76d			bcc 	TOKExtractLineNumber
.b7aa					_TLENExit:
.b7aa	60		rts				rts
.b7ab					_LCLNTimes2:
.b7ab	0e a9 04	asl $04a9			asl 	tokenLineNumber
.b7ae	2e aa 04	rol $04aa			rol 	tokenLineNumber+1
.b7b1	60		rts				rts
.b7b2					TOKWriteByte:
.b7b2	da		phx				phx
.b7b3	ae a8 04	ldx $04a8			ldx 	tokenOffset 				; next slot to write to
.b7b6	9d a8 04	sta $04a8,x			sta 	tokenOffset,x 				; write byte out
.b7b9	ee a8 04	inc $04a8			inc 	tokenOffset 				; advance slot.
.b7bc	fa		plx				plx
.b7bd	60		rts				rts
.b7be					TOKCheckCreateVariableRecord:
.b7be	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.b7c0	85 36		sta $36				sta 	0+zTemp0
.b7c2	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.b7c4	85 37		sta $37				sta 	1+zTemp0
.b7c6					_CCVSearch:
.b7c6	b2 36		lda ($36)			lda 	(zTemp0) 					; end of list
.b7c8	f0 2c		beq $b7f6			beq 	_CCVFail
.b7ca	a0 01		ldy #$01			ldy 	#1 							; read the hash
.b7cc	b1 36		lda ($36),y			lda 	(zTemp0),y 					; does it match ?
.b7ce	cd 83 04	cmp $0483			cmp 	identHash
.b7d1	d0 16		bne $b7e9			bne 	_CCVNext
.b7d3	a0 08		ldy #$08			ldy 	#8 							; name in variable record
.b7d5	ae 80 04	ldx $0480			ldx 	identStart
.b7d8					_CCVCompare:
.b7d8	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; xor them. zero if the same, except
.b7db	51 36		eor ($36),y			eor 	(zTemp0),y 					; bit 7 is used for EOS.
.b7dd	e8		inx				inx 								; advance pointers
.b7de	c8		iny				iny
.b7df	0a		asl a				asl 	a 							; A = 0 if they match, CS if end.
.b7e0	d0 07		bne $b7e9			bne 	_CCVNext  					; didn't match go to next.
.b7e2	90 f4		bcc $b7d8			bcc 	_CCVCompare 				; not finished yet.
.b7e4	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; matched whole thing ?
.b7e7	f0 41		beq $b82a			beq 	_CCVFound 					; yes, we were successful
.b7e9					_CCVNext:
.b7e9	18		clc				clc
.b7ea	b2 36		lda ($36)			lda 	(zTemp0) 					; add offset to pointer
.b7ec	65 36		adc $36				adc 	zTemp0
.b7ee	85 36		sta $36				sta 	zTemp0
.b7f0	90 d4		bcc $b7c6			bcc 	_CCVSearch
.b7f2	e6 37		inc $37				inc 	zTemp0+1
.b7f4	80 d0		bra $b7c6			bra 	_CCVSearch
.b7f6					_CCVFail:
.b7f6	a0 01		ldy #$01			ldy 	#1 							; create the new record. Offset 1 is hash
.b7f8	ad 83 04	lda $0483			lda 	identHash
.b7fb	91 36		sta ($36),y			sta 	(zTemp0),y
.b7fd	c8		iny				iny 								; offset 2 is the type byte
.b7fe	ad 84 04	lda $0484			lda 	identTypeByte
.b801	91 36		sta ($36),y			sta 	(zTemp0),y
.b803	c8		iny				iny
.b804					_CCVData:
.b804	a9 00		lda #$00			lda 	#0 							; erase data 3-7
.b806	91 36		sta ($36),y			sta 	(zTemp0),y
.b808	c8		iny				iny
.b809	c0 08		cpy #$08			cpy 	#8
.b80b	90 f7		bcc $b804			bcc 	_CCVData
.b80d	ae 80 04	ldx $0480			ldx 	identStart 					; copy name into 8 on.
.b810					_CCVCopyName:
.b810	bd a8 05	lda $05a8,x			lda 	lineBuffer,x
.b813	91 36		sta ($36),y			sta 	(zTemp0),y
.b815	e8		inx				inx
.b816	c8		iny				iny
.b817	ec 82 04	cpx $0482			cpx 	identTypeEnd
.b81a	d0 f4		bne $b810			bne 	_CCVCopyName
.b81c	98		tya				tya 								; patch offset
.b81d	92 36		sta ($36)			sta 	(zTemp0)
.b81f	a9 00		lda #$00			lda 	#0 							; offset for next is zero.
.b821	91 36		sta ($36),y			sta 	(zTemp0),y
.b823	88		dey				dey
.b824	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set bit 7 of last bit
.b826	09 80		ora #$80			ora 	#$80
.b828	91 36		sta ($36),y			sta 	(zTemp0),y
.b82a					_CCVFound:
.b82a	a5 37		lda $37				lda 	zTemp0+1 					; write out MSB
.b82c	38		sec				sec
.b82d	e9 10		sbc #$10			sbc 	#(VariableSpace >> 8) 		; offset from the start
.b82f	09 40		ora #$40			ora 	#$40 						; make it a writeable token
.b831	20 b2 b7	jsr $b7b2			jsr 	TOKWriteByte
.b834	a5 36		lda $36				lda 	zTemp0 						; write out LSB
.b836	20 b2 b7	jsr $b7b2			jsr 	TOKWriteByte
.b839	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_sound.module

=1					soundIntegrated=1
.b83a					SNDCheckChannel:
.b83a	aa		tax				tax
.b83b	bd 08 08	lda $0808,x			lda 	SNDTimeLeft,x 				; currently playing a note
.b83e	d0 38		bne $b878			bne 	_SNDCCExit
.b840	da		phx				phx 								; save current channel
.b841	8a		txa				txa 								; put in A
.b842	20 be b8	jsr $b8be			jsr 	SNDFindNextNoteForA 		; is there a note for A in the queue ?
.b845	68		pla				pla 								; channel # in A
.b846	90 30		bcc $b878			bcc 	_SNDCCExit
.b848	a8		tay				tay 								; Y is the channel #
.b849	bd fd 06	lda $06fd,x			lda 	SNDQueue+1,x 				; copy data into the slot.
.b84c	99 fc 07	sta $07fc,y			sta 	SNDPitchLow,y
.b84f	bd fe 06	lda $06fe,x			lda 	SNDQueue+2,x
.b852	99 00 08	sta $0800,y			sta 	SNDPitchHigh,y
.b855	bd ff 06	lda $06ff,x			lda 	SNDQueue+3,x
.b858	99 04 08	sta $0804,y			sta 	SNDVolume,y
.b85b	bd 00 07	lda $0700,x			lda 	SNDQueue+4,x
.b85e	99 08 08	sta $0808,y			sta 	SNDTimeLeft,y
.b861	bd 01 07	lda $0701,x			lda 	SNDQueue+5,x
.b864	99 0c 08	sta $080c,y			sta 	SNDAdjustLow,y
.b867	bd 02 07	lda $0702,x			lda 	SNDQueue+6,x
.b86a	99 10 08	sta $0810,y			sta 	SNDAdjustHigh,y
.b86d	5a		phy				phy 								; save channel #
.b86e	20 d8 b8	jsr $b8d8			jsr 	SNDDeleteXFromQueue 		; delete record at X from queue
.b871	ce fb 06	dec $06fb			dec 	SNDLength 					; reduce the queue length.
.b874	68		pla				pla
.b875	20 79 b8	jsr $b879			jsr 	SNDUpdateNote 				; update channel A
.b878					_SNDCCExit:
.b878	60		rts				rts
.b879					SNDUpdateNote:
.b879	aa		tax				tax 								; so we can access records
.b87a	0a		asl a				asl 	a 							; convert it to a channel bit pair in 5,6
.b87b	0a		asl a				asl 	a
.b87c	0a		asl a				asl 	a
.b87d	0a		asl a				asl 	a
.b87e	0a		asl a				asl 	a
.b87f	8d fa 06	sta $06fa			sta 	SNDChannelBits
.b882	bd 08 08	lda $0808,x			lda 	SNDTimeLeft,x 				; are we silent
.b885	f0 2e		beq $b8b5			beq 	_SNDUNIsSilent
.b887	ad fa 06	lda $06fa			lda 	SNDChannelBits 				; push channel bits on stack
.b88a	48		pha				pha
.b88b	bd fc 07	lda $07fc,x			lda 	SNDPitchLow,x 				; get 4 lowest bits of pitch.
.b88e	29 0f		and #$0f			and 	#$0F
.b890	0d fa 06	ora $06fa			ora 	SNDChannelBits 				; set channel bits
.b893	09 80		ora #$80			ora 	#$80 						; write to pitch register
.b895	20 22 b9	jsr $b922			jsr 	SNDWritePorts
.b898	bd 00 08	lda $0800,x			lda 	SNDPitchHigh,x 				; pitch high => channel temp.
.b89b	8d fa 06	sta $06fa			sta 	SNDChannelBits
.b89e	bd fc 07	lda $07fc,x			lda 	SNDPitchLow,x
.b8a1	4e fa 06	lsr $06fa			lsr 	SNDChannelBits 				; shift 2 LSBs into MSB of A
.b8a4	6a		ror a				ror 	a
.b8a5	4e fa 06	lsr $06fa			lsr 	SNDChannelBits
.b8a8	6a		ror a				ror 	a
.b8a9	4a		lsr a				lsr 	a 							; put in bits 0-5
.b8aa	4a		lsr a				lsr 	a
.b8ab	20 22 b9	jsr $b922			jsr 	SNDWritePorts 				; write as rest of pitch register
.b8ae	68		pla				pla
.b8af	09 90		ora #$90			ora 	#$90 						; set to write minimum attentuation.
.b8b1	20 22 b9	jsr $b922			jsr 	SNDWritePorts
.b8b4	60		rts				rts
.b8b5					_SNDUNIsSilent:
.b8b5	ad fa 06	lda $06fa			lda 	SNDChannelBits 				; channel bits
.b8b8	09 9f		ora #$9f			ora 	#$9F 						; maximum attenuation
.b8ba	20 22 b9	jsr $b922			jsr 	SNDWritePorts 				; write to the ports
.b8bd	60		rts				rts
.b8be					SNDFindNextNoteForA:
.b8be	ac fb 06	ldy $06fb			ldy 	SNDLength 					; queue size into Y
.b8c1	f0 13		beq $b8d6			beq 	_SNDFNNFail 				; queue empty.
.b8c3	a2 00		ldx #$00			ldx 	#0
.b8c5					_SNDFNNSearch:
.b8c5	dd fc 06	cmp $06fc,x			cmp 	SNDQueue,x 					; does it match the channel
.b8c8	38		sec				sec
.b8c9	f0 0c		beq $b8d7			beq 	_SNDFNNExit 				; if so exit with CS.
.b8cb	e8		inx				inx 								; next queue slot.
.b8cc	e8		inx				inx
.b8cd	e8		inx				inx
.b8ce	e8		inx				inx
.b8cf	e8		inx				inx
.b8d0	e8		inx				inx
.b8d1	e8		inx				inx
.b8d2	e8		inx				inx
.b8d3	88		dey				dey 								; done the whole queue
.b8d4	d0 ef		bne $b8c5			bne 	_SNDFNNSearch 				; no, go back.
.b8d6					_SNDFNNFail:
.b8d6	18		clc				clc
.b8d7					_SNDFNNexit:
.b8d7	60		rts				rts
.b8d8					SNDDeleteXFromQueue:
.b8d8	e0 f8		cpx #$f8			cpx 	#SNDQueueSize*8-8 			; reached the end.
.b8da	f0 09		beq $b8e5			beq 	_SNDDXExit
.b8dc	bd 04 07	lda $0704,x			lda 	SNDQueue+8,x
.b8df	9d fc 06	sta $06fc,x			sta 	SNDQueue,x
.b8e2	e8		inx				inx
.b8e3	80 f3		bra $b8d8			bra 	SNDDeleteXFromQueue
.b8e5					_SNDDXExit:
.b8e5	60		rts				rts
.06fa					SNDChannelBits:
>06fa							.fill 	1
.b8e6					SNDQueueRequest:
.b8e6	86 36		stx $36				stx 	zTemp0						; save queue address
.b8e8	84 37		sty $37				sty 	zTemp0+1
.b8ea	ae fb 06	ldx $06fb			ldx 	SNDLength 					; queue is full, can't take any more.
.b8ed	e0 20		cpx #$20			cpx 	#SNDQueueSize
.b8ef	f0 21		beq $b912			beq 	_SNDQRExit
.b8f1	29 03		and #$03			and 	#3	 						; channel # and push on stack
.b8f3	48		pha				pha
.b8f4	8a		txa				txa  								; get offset in queue buffer/
.b8f5	0a		asl a				asl 	a
.b8f6	0a		asl a				asl 	a
.b8f7	0a		asl a				asl 	a
.b8f8	aa		tax				tax
.b8f9	68		pla				pla 								; get back and push again
.b8fa	48		pha				pha
.b8fb	9d fc 06	sta $06fc,x			sta 	SNDQueue+0,x 				; save the channel #
.b8fe	a0 00		ldy #$00			ldy 	#0 							; copy the rest in.
.b900					_SNDQCopy:
.b900	b1 36		lda ($36),y			lda 	(zTemp0),y
.b902	e8		inx				inx
.b903	c8		iny				iny
.b904	9d fc 06	sta $06fc,x			sta 	SNDQueue,x
.b907	c0 06		cpy #$06			cpy 	#6
.b909	d0 f5		bne $b900			bne 	_SNDQCopy
.b90b	ee fb 06	inc $06fb			inc 	SNDLength 					; bump queue length.
.b90e	68		pla				pla 								; get channel # back
.b90f	20 3a b8	jsr $b83a			jsr 	SNDCheckChannel 			; check if channel needs refreshing.
.b912					_SNDQRExit:
.b912	60		rts				rts
.b913					SNDSilenceChannel:
.b913	aa		tax				tax 								; zero time left.
.b914	9e 08 08	stz $0808,x			stz 	SNDTimeLeft,x
.b917	0a		asl a				asl 	a 							; shift into position
.b918	0a		asl a				asl 	a
.b919	0a		asl a				asl 	a
.b91a	0a		asl a				asl 	a
.b91b	0a		asl a				asl 	a
.b91c	09 9f		ora #$9f			ora 	#$9F 						; write register attenuation $F
.b91e	20 22 b9	jsr $b922			jsr 	SNDWritePorts
.b921	60		rts				rts
.b922					SNDWritePorts:
.b922	64 01		stz $01				stz 	1
.b924	8d 00 d6	sta $d600			sta 	$D600
.b927	8d 10 d6	sta $d610			sta 	$D610
.b92a	60		rts				rts
.b92b					SNDCommand:
.b92b	c9 0f		cmp #$0f			cmp 	#$0F 						; $0F is initialise
.b92d	f0 1c		beq $b94b			beq 	_SNDInitialise
.b92f	90 27		bcc $b958			bcc 	_SNDExit
.b931	c9 3f		cmp #$3f			cmp 	#$3F 						; $3F is silence all
.b933	f0 16		beq $b94b			beq 	_SNDSilence
.b935	b0 21		bcs $b958			bcs 	_SNDExit
.b937	c9 20		cmp #$20			cmp 	#$20 						; $2x is check playing => A
.b939	b0 09		bcs $b944			bcs 	_SNDQueryPlay
.b93b	c9 14		cmp #$14			cmp 	#$14 						; $10-$13 is queue sound
.b93d	b0 19		bcs $b958			bcs 	_SNDExit
.b93f	20 e6 b8	jsr $b8e6			jsr 	SNDQueueRequest
.b942	80 14		bra $b958			bra 	_SNDExit
.b944					_SNDQueryPlay:
.b944	29 03		and #$03			and 	#3 							; get channel #
.b946	bd 08 08	lda $0808,x			lda 	SNDTimeLeft,x 				; read time left, if zero then silent
.b949	80 0d		bra $b958			bra 	_SNDExit
.b94b					_SNDInitialise:
.b94b					_SNDSilence:
.b94b	9c fb 06	stz $06fb			stz 	SNDLength 					; empty the queue.
.b94e	a9 03		lda #$03			lda 	#$3 						; silence channel 0-3.
.b950					_SNDSilenceLoop:
.b950	48		pha				pha
.b951	20 13 b9	jsr $b913			jsr 	SNDSilenceChannel
.b954	68		pla				pla
.b955	3a		dec a				dec 	a
.b956	10 f8		bpl $b950			bpl 	_SNDSilenceLoop
.b958					_SNDExit:
.b958	60		rts				rts
=32					SNDQueueSize = 32 							; number of queue entries
.06fb					SNDLength:
>06fb							.fill 	1
.06fc					SNDQueue:
>06fc							.fill 	SNDQueueSize * 8
.07fc					SNDPitchLow:
>07fc							.fill 	4
.0800					SNDPitchHigh:
>0800							.fill 	4
.0804					SNDVolume:
>0804							.fill 	4
.0808					SNDTimeLeft:
>0808							.fill 	4
.080c					SNDAdjustLow:
>080c							.fill 	4
.0810					SNDAdjustHigh:
>0810							.fill 	4

;******  Return to file: _basic.asm


;******  End of listing
