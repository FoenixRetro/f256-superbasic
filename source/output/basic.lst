
; 64tass Turbo Assembler Macro V1.58.2974? listing file
; 64tass -D AUTORUN=0 "-D MONITOR_ADDRESS=\$E000" "-D LOCKOUT_ADDRESS=\$F000" "-D BASIC_ADDRESS=\$34000" "-D SOURCE_ADDRESS=\$28000" "-D SPRITE_ADDRESS=\$30000" -q -b -Wall -c -C -D "HARDWARE=0 $'\x9'$'\x9'$'\x9'$'\x9'$'\x9'$'\x9'" -L output/basic.lst -l output/basic.lbl -Wall -o build/basic.rom _basic.asm
; Wed Feb  8 17:41:12 2023

;Offset	;PC	;Hex		;Monitor	;Source

;******  Command line definitions

=0						AUTORUN=0
=$e000						 MONITOR_ADDRESS=$E000
=$f000						 LOCKOUT_ADDRESS=$F000
=$34000						 BASIC_ADDRESS=$34000
=$28000						 SOURCE_ADDRESS=$28000
=$30000						 SPRITE_ADDRESS=$30000
=0						HARDWARE=0

;******  Processing input file: _basic.asm


;******  Processing file: ./common/aa.system/01common.inc

=$30						ZeroPageMandatory = $30
=$50						ZeroPagePreference = $50
=$400						MemoryStorage = $400
=$2000						BasicStart = $2000
=$8000						BasicEnd = $8000
=$8000						CodeStart = $8000
=$1000						VariableSpace = $1000
=$2000						EndVariableSpace = $2000
=8						MathStackSize = 8
=512						BasicStackSize = 512
=3584						BasicStackBase = $1000-BasicStackSize
=80						MaxLineSize = 80

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/02macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/04data.inc

.0030						codePtr:
>0030								.fill 	4
.0034						basicStack:
>0034								.fill 	2
.0036						zTemp0:
>0036								.fill 	2
.0038						zTemp1:
>0038								.fill 	2
.003a						zTemp2:
>003a								.fill 	2
.003c						zsTemp:
>003c								.fill 	2
.003e						zaTemp:
>003e								.fill 	2
=$30						safePtr = codePtr 							; minimise direct tinkering
=$80						NSBIsNegative = $80 						; bit 7 : sign of mantissa (where numeric)
=$20						NSBIsReference = $20 						; bit 5 : is a reference
=$10						NSBIsString = $10 							; bit 4 : set if string (procedures don't go on the stack)
=$18						NSBTypeMask = $18 							; bits 4,3 : 00 int 01 float 10 string 11 procedure
=$03						NSBRefMask = $03 							; bits 0,1 : Bytes of reference, 00 = 4,01 = 1,10=2
=$04						NSBIsArray = $04
=$00						NSTInteger = $00 							; base types for bits 3..4
=$08						NSTFloat = $08
=$10						NSTString = $10
=$18						NSTProcedure = $18
.0050						NSStatus:
>0050								.fill 	MathStackSize
.0058						NSMantissa0:
>0058								.fill 	MathStackSize 				; (this is my integer mantissa system)
.0060						NSMantissa1:
>0060								.fill 	MathStackSize
.0068						NSMantissa2:
>0068								.fill 	MathStackSize
.0070						NSMantissa3:
>0070								.fill 	MathStackSize
.0078						NSExponent:
>0078								.fill 	MathStackSize
.0400						identStart:
>0400								.fill 	1
.0401						identTypeStart:
>0401								.fill 	1
.0402						identTypeEnd:
>0402								.fill 	1
.0403						identHash:
>0403								.fill 	1
.0404						identTypeByte:
>0404								.fill 	1	 						; (see tokenising.pdf)
.0405						encodeState:
>0405								.fill 	1
.0406						digitTemp:
>0406								.fill 	1
.0407						decimalCount:
>0407								.fill 	1
.0408						lowMemPtr:
>0408								.fill 	2
.040a						stringMemory:
>040a								.fill 	2
.040c						stringInitialised:
>040c								.fill 	1
.040d						stringTempPointer:
>040d								.fill 	2
.040f						breakCheck:
>040f								.fill 	1
.0410						decimalPlaces:
>0410								.fill 	1
.0411						dbOffset:
>0411								.fill 	1
.0412						lastParameter:
>0412								.fill 	1
.0413						dataPointer:
>0413								.fill 	5
.0418						inDataStatement:
>0418								.fill 	1
.0419						tbOffset:
>0419								.fill 	1
.041a						AssemblerAddress:
>041a								.fill 	2
.041c						AssemblerControl:
>041c								.fill 	1
.041d						ParamStart:
>041d								.fill 	2
.041f						IsGroup1:
>041f								.fill 	1
.0420						BaseOpcode:
>0420								.fill 	1
.0421						ModeMask:
>0421								.fill 	1
.0422						listIndent:
>0422								.fill 	1
.0423						lcLastCharacter:
>0423								.fill 	1
.0424						isPrintFlag:
>0424								.fill 	1
.0425						currentListColour:
>0425								.fill 	1
.0426						tokenOffset:
>0426								.fill 	1
.0427						tokenLineNumber:
>0427								.fill 	2
.0429						tokenBuffer:
>0429								.fill 	253
.0526						lineBuffer:
>0526								.fill 	253
.0623						numberBuffer:
>0623								.fill 	34
.0645						decimalBuffer:
>0645								.fill 	16

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/ab.system/macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/ab.system/ticktask.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/constants.inc

=$80						AM_ISZP = $80
=$40						AM_ISG1 = $40
=$20						AM_ISG2 = $20
=224						AM_IMMEDIATE = AM_ISZP+AM_ISG1+AM_ISG2+$00
=228						AM_ZEROPAGE = AM_ISZP+AM_ISG1+AM_ISG2+$04
=40						AM_ACC = AM_ISG2+$08
=108						AM_ABS = AM_ISG1+AM_ISG2+$0C
=208						AM_INDY = AM_ISZP+AM_ISG1+$10
=244						AM_ZEROX = AM_ISZP+AM_ISG1+AM_ISG2+$14
=120						AM_ABSY = AM_ISG1+AM_ISG2+$18
=124						AM_ABSX = AM_ISG1+AM_ISG2+$1C
=209						AM_IND = AM_ISZP+AM_ISG1+$11
=$80						AM_ZEROY = AM_ISZP
=$01						AM_INDABS = $01
=$02						AM_INDABSX = $02
=192						AM_INDX = AM_ISZP+AM_ISG1+$00

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/handlers.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.inc

=1						ERRID_BREAK = 1
=2						ERRID_SYNTAX = 2
=3						ERRID_DIVZERO = 3
=4						ERRID_RANGE = 4
=5						ERRID_TYPE = 5
=6						ERRID_MEMORY = 6
=7						ERRID_ARGUMENT = 7
=8						ERRID_STOP = 8
=9						ERRID_STRING = 9
=10						ERRID_ASSERT = 10
=11						ERRID_DATA = 11
=12						ERRID_NOTDONE = 12
=13						ERRID_LINE = 13
=14						ERRID_GOSUB = 14
=15						ERRID_REPEAT = 15
=16						ERRID_WHILE = 16
=17						ERRID_FOR = 17
=18						ERRID_STACK = 18
=19						ERRID_STRUCT = 19
=20						ERRID_PROC = 20
=21						ERRID_REDEFINE = 21
=22						ERRID_ARRAYSIZE = 22
=23						ERRID_ARRAYIDX = 23
=24						ERRID_ARRAYDEC = 24
=25						ERRID_NOTFOUND = 25
=26						ERRID_DRIVEIO = 26
=27						ERRID_VERIFY = 27

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst.inc

=$00						KWD_LESSLESS                         = $00; $00 <<
=$01						KWD_LESSEQUAL                        = $01; $01 <=
=$02						KWD_LESSGREATER                      = $02; $02 <>
=$03						KWD_PLINGPLING3                      = $03; $03 !!3
=$04						KWD_GREATERLESS                      = $04; $04 ><
=$05						KWD_GREATEREQUAL                     = $05; $05 >=
=$06						KWD_GREATERGREATER                   = $06; $06 >>
=$07						KWD_PLINGPLING7                      = $07; $07 !!7
=$08						KWD_PLINGPLING8                      = $08; $08 !!8
=$09						KWD_PLINGPLING9                      = $09; $09 !!9
=$0a						KWD_PLINGPLING10                     = $0a; $0a !!10
=$0b						KWD_PLINGPLING11                     = $0b; $0b !!11
=$0c						KWD_PLINGPLING12                     = $0c; $0c !!12
=$0d						KWD_PLINGPLING13                     = $0d; $0d !!13
=$0e						KWD_PLINGPLING14                     = $0e; $0e !!14
=$0f						KWD_PLINGPLING15                     = $0f; $0f !!15
=$10						KWD_ATCH                             = $10; $10 @
=$11						KWD_PLINGPLING17                     = $11; $11 !!17
=$12						KWD_PLINGPLING18                     = $12; $12 !!18
=$13						KWD_LSQPAREN                         = $13; $13 [
=$14						KWD_BACKSLASH                        = $14; $14 \
=$15						KWD_RSQPAREN                         = $15; $15 ]
=$16						KWD_HAT                              = $16; $16 ^
=$17						KWD_UNDERSCORE                       = $17; $17 _
=$18						KWD_BQUOTE                           = $18; $18 `
=$19						KWD_PLINGPLING25                     = $19; $19 !!25
=$1a						KWD_PLINGPLING26                     = $1a; $1a !!26
=$1b						KWD_LCURLY                           = $1b; $1b {
=$1c						KWD_BAR                              = $1c; $1c |
=$1d						KWD_RCURLY                           = $1d; $1d }
=$1e						KWD_TILDE                            = $1e; $1e ~
=$21						KWD_PLING                            = $21; $21 !
=$22						KWD_DQUOTE                           = $22; $22 "
=$23						KWD_HASH                             = $23; $23 #
=$24						KWD_DOLLAR                           = $24; $24 $
=$25						KWD_PERCENT                          = $25; $25 %
=$26						KWD_AMPERSAND                        = $26; $26 &
=$27						KWD_QUOTE                            = $27; $27 '
=$28						KWD_LPAREN                           = $28; $28 (
=$29						KWD_RPAREN                           = $29; $29 )
=$2a						KWD_STAR                             = $2a; $2a *
=$2b						KWD_PLUS                             = $2b; $2b +
=$2c						KWD_COMMA                            = $2c; $2c ,
=$2d						KWD_MINUS                            = $2d; $2d -
=$2e						KWD_PERIOD                           = $2e; $2e .
=$2f						KWD_SLASH                            = $2f; $2f /
=$30						KWD_0                                = $30; $30 0
=$31						KWD_1                                = $31; $31 1
=$32						KWD_2                                = $32; $32 2
=$33						KWD_3                                = $33; $33 3
=$34						KWD_4                                = $34; $34 4
=$35						KWD_5                                = $35; $35 5
=$36						KWD_6                                = $36; $36 6
=$37						KWD_7                                = $37; $37 7
=$38						KWD_8                                = $38; $38 8
=$39						KWD_9                                = $39; $39 9
=$3a						KWD_COLON                            = $3a; $3a :
=$3b						KWD_SEMICOLON                        = $3b; $3b ;
=$3c						KWD_LESS                             = $3c; $3c <
=$3d						KWD_EQUAL                            = $3d; $3d =
=$3e						KWD_GREATER                          = $3e; $3e >
=$3f						KWD_QMARK                            = $3f; $3f ?
=$83						KWD_ABSLPAREN                        = $83; $83 ABS(
=$84						KWD_ALLOCLPAREN                      = $84; $84 ALLOC(
=$85						KWD_ASCLPAREN                        = $85; $85 ASC(
=$86						KWD_CHRDOLLARLPAREN                  = $86; $86 CHR$(
=$87						KWD_EVENTLPAREN                      = $87; $87 EVENT(
=$88						KWD_FALSE                            = $88; $88 FALSE
=$89						KWD_FRACLPAREN                       = $89; $89 FRAC(
=$8a						KWD_GETDOLLARLPAREN                  = $8a; $8a GET$(
=$8b						KWD_GETLPAREN                        = $8b; $8b GET(
=$8c						KWD_GETDATEDOLLARLPAREN              = $8c; $8c GETDATE$(
=$8d						KWD_GETTIMEDOLLARLPAREN              = $8d; $8d GETTIME$(
=$8e						KWD_HITLPAREN                        = $8e; $8e HIT(
=$8f						KWD_INKEYDOLLARLPAREN                = $8f; $8f INKEY$(
=$90						KWD_INKEYLPAREN                      = $90; $90 INKEY(
=$91						KWD_INTLPAREN                        = $91; $91 INT(
=$92						KWD_ISVALLPAREN                      = $92; $92 ISVAL(
=$93						KWD_ITEMCOUNTLPAREN                  = $93; $93 ITEMCOUNT(
=$94						KWD_ITEMGETDOLLARLPAREN              = $94; $94 ITEMGET$(
=$95						KWD_JOYBLPAREN                       = $95; $95 JOYB(
=$96						KWD_JOYXLPAREN                       = $96; $96 JOYX(
=$97						KWD_JOYYLPAREN                       = $97; $97 JOYY(
=$98						KWD_KEYDOWNLPAREN                    = $98; $98 KEYDOWN(
=$99						KWD_LEFTDOLLARLPAREN                 = $99; $99 LEFT$(
=$9a						KWD_LENLPAREN                        = $9a; $9a LEN(
=$9b						KWD_MAXLPAREN                        = $9b; $9b MAX(
=$9c						KWD_MIDDOLLARLPAREN                  = $9c; $9c MID$(
=$9d						KWD_MINLPAREN                        = $9d; $9d MIN(
=$9e						KWD_NOTLPAREN                        = $9e; $9e NOT(
=$9f						KWD_PEEKLPAREN                       = $9f; $9f PEEK(
=$a0						KWD_PEEKDLPAREN                      = $a0; $a0 PEEKD(
=$a1						KWD_PEEKLLPAREN                      = $a1; $a1 PEEKL(
=$a2						KWD_PEEKWLPAREN                      = $a2; $a2 PEEKW(
=$a3						KWD_PLAYINGLPAREN                    = $a3; $a3 PLAYING(
=$a4						KWD_RANDOMLPAREN                     = $a4; $a4 RANDOM(
=$a5						KWD_RIGHTDOLLARLPAREN                = $a5; $a5 RIGHT$(
=$a6						KWD_RNDLPAREN                        = $a6; $a6 RND(
=$a7						KWD_SGNLPAREN                        = $a7; $a7 SGN(
=$a8						KWD_SPCLPAREN                        = $a8; $a8 SPC(
=$a9						KWD_STRDOLLARLPAREN                  = $a9; $a9 STR$(
=$aa						KWD_TIMERLPAREN                      = $aa; $aa TIMER(
=$ab						KWD_TRUE                             = $ab; $ab TRUE
=$ac						KWD_VALLPAREN                        = $ac; $ac VAL(
=$ad						KWD_FOR                              = $ad; $ad FOR
=$ae						KWD_IF                               = $ae; $ae IF
=$af						KWD_PROC                             = $af; $af PROC
=$b0						KWD_REPEAT                           = $b0; $b0 REPEAT
=$b1						KWD_WHILE                            = $b1; $b1 WHILE
=$b2						KWD_ENDIF                            = $b2; $b2 ENDIF
=$b3						KWD_ENDPROC                          = $b3; $b3 ENDPROC
=$b4						KWD_NEXT                             = $b4; $b4 NEXT
=$b5						KWD_THEN                             = $b5; $b5 THEN
=$b6						KWD_UNTIL                            = $b6; $b6 UNTIL
=$b7						KWD_WEND                             = $b7; $b7 WEND
=$b8						KWD_AT                               = $b8; $b8 AT
=$b9						KWD_BY                               = $b9; $b9 BY
=$ba						KWD_CALL                             = $ba; $ba CALL
=$bb						KWD_CIRCLE                           = $bb; $bb CIRCLE
=$bc						KWD_CLEAR                            = $bc; $bc CLEAR
=$bd						KWD_COLOR                            = $bd; $bd COLOR
=$be						KWD_COLOUR                           = $be; $be COLOUR
=$bf						KWD_DATA                             = $bf; $bf DATA
=$c0						KWD_DIM                              = $c0; $c0 DIM
=$c1						KWD_DOWNTO                           = $c1; $c1 DOWNTO
=$c2						KWD_ELSE                             = $c2; $c2 ELSE
=$c3						KWD_FROM                             = $c3; $c3 FROM
=$c4						KWD_GFX                              = $c4; $c4 GFX
=$c5						KWD_HERE                             = $c5; $c5 HERE
=$c6						KWD_IMAGE                            = $c6; $c6 IMAGE
=$c7						KWD_LET                              = $c7; $c7 LET
=$c8						KWD_LINE                             = $c8; $c8 LINE
=$c9						KWD_LOCAL                            = $c9; $c9 LOCAL
=$ca						KWD_MEMCOPY                          = $ca; $ca MEMCOPY
=$cb						KWD_OFF                              = $cb; $cb OFF
=$cc						KWD_ON                               = $cc; $cc ON
=$cd						KWD_OUTLINE                          = $cd; $cd OUTLINE
=$ce						KWD_PALETTE                          = $ce; $ce PALETTE
=$cf						KWD_PLOT                             = $cf; $cf PLOT
=$d0						KWD_POKE                             = $d0; $d0 POKE
=$d1						KWD_POKED                            = $d1; $d1 POKED
=$d2						KWD_POKEL                            = $d2; $d2 POKEL
=$d3						KWD_POKEW                            = $d3; $d3 POKEW
=$d4						KWD_READ                             = $d4; $d4 READ
=$d5						KWD_RECT                             = $d5; $d5 RECT
=$d6						KWD_REM                              = $d6; $d6 REM
=$d7						KWD_SOLID                            = $d7; $d7 SOLID
=$d8						KWD_SOUND                            = $d8; $d8 SOUND
=$d9						KWD_SPRITE                           = $d9; $d9 SPRITE
=$da						KWD_TEXT                             = $da; $da TEXT
=$db						KWD_TO                               = $db; $db TO

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst0.inc

=$80						KWC_EOL = $80
=$ff						KWC_STRING = $FF
=$fe						KWC_HEXCONST = $FE
=$ad						KWC_FIRST_STRUCTURE = $ad
=$b2						KWC_FIRST_STRUCTURE_DEC = $b2
=$b7						KWC_LAST_STRUCTURE = $b7
=$83						KWC_FIRST_UNARY = $83
=$ac						KWC_LAST_UNARY = $ac

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/memory/memory.flat/access.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/stack.inc

=$e0						STK_GOSUB = $E0
=$d0						STK_FOR = $D0
=$c0						STK_REPEAT = $C0
=$b0						STK_PROC = $B0
=$a0						STK_WHILE = $A0
=$01						STK_LOCALN = $01
=$02						STK_LOCALS = $02

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/00start.asm

.8000						F256Header:
>8000		f2 56						.text	$f2,$56         			; Signature
>8002		04						.byte   4               			; 4 blocks
>8003		04						.byte   4               			; mount at $8000
>8004		40 80						.word   Boot 	      				; Start here
>8006		00 00						.word   0 			               	; version
>8008		00 00						.word   0               			; kernel
>800a		53 75 70 65 72 42 41 53				.text   "SuperBASIC",0 				; name of program.
>8012		49 43 00
.8040		4c 93 80	jmp $8093	Boot:	jmp 	Start

;******  Processing file: ./common/aa.system/../../../modules/_build/_linker.module

=1						PagingEnabled = 1
.8043						EXTPrintCharacter:
.8043		e6 0d		inc $0d			inc 8+5
.8045		20 0b a0	jsr $a00b		jsr	Export_EXTPrintCharacter
.8048		08		php			php
.8049		c6 0d		dec $0d			dec 8+5
.804b		28		plp			plp
.804c		60		rts			rts
.804d						EXTPrintNoControl:
.804d		e6 0d		inc $0d			inc 8+5
.804f		20 00 a0	jsr $a000		jsr	Export_EXTPrintNoControl
.8052		08		php			php
.8053		c6 0d		dec $0d			dec 8+5
.8055		28		plp			plp
.8056		60		rts			rts
.8057						EXTInitialise:
.8057		e6 0d		inc $0d			inc 8+5
.8059		20 da a1	jsr $a1da		jsr	Export_EXTInitialise
.805c		08		php			php
.805d		c6 0d		dec $0d			dec 8+5
.805f		28		plp			plp
.8060		60		rts			rts
.8061						GXGraphicDraw:
.8061		e6 0d		inc $0d			inc 8+5
.8063		20 3b a3	jsr $a33b		jsr	Export_GXGraphicDraw
.8066		08		php			php
.8067		c6 0d		dec $0d			dec 8+5
.8069		28		plp			plp
.806a		60		rts			rts
.806b						SNDCommand:
.806b		e6 0d		inc $0d			inc 8+5
.806d		20 50 b7	jsr $b750		jsr	Export_SNDCommand
.8070		08		php			php
.8071		c6 0d		dec $0d			dec 8+5
.8073		28		plp			plp
.8074		60		rts			rts
.8075						SNDUpdate:
.8075		e6 0d		inc $0d			inc 8+5
.8077		20 83 b7	jsr $b783		jsr	Export_SNDUpdate
.807a		08		php			php
.807b		c6 0d		dec $0d			dec 8+5
.807d		28		plp			plp
.807e		60		rts			rts
.807f						TKListConvertLine:
.807f		e6 0d		inc $0d			inc 8+5
.8081		20 01 b1	jsr $b101		jsr	Export_TKListConvertLine
.8084		08		php			php
.8085		c6 0d		dec $0d			dec 8+5
.8087		28		plp			plp
.8088		60		rts			rts
.8089						TKTokeniseLine:
.8089		e6 0d		inc $0d			inc 8+5
.808b		20 95 b3	jsr $b395		jsr	Export_TKTokeniseLine
.808e		08		php			php
.808f		c6 0d		dec $0d			dec 8+5
.8091		28		plp			plp
.8092		60		rts			rts

;******  Return to file: ./common/aa.system/00start.asm

.8093		a2 ff		ldx #$ff	Start:	ldx 	#$FF 						; stack reset
.8095		9a		txs				txs
.8096		20 57 80	jsr $8057			jsr 	EXTInitialise 				; hardware initialise
.8099		a5 00		lda $00				lda 	0  							; turn on editing of MMU LUT
.809b		09 80		ora #$80			ora 	#$80
.809d		85 00		sta $00				sta 	0
.809f		ad 02 20	lda $2002			lda 	$2002 						; if $2002..5 is BT65 then jump to $2000
.80a2		c9 42		cmp #$42			cmp 	#"B"
.80a4		d0 18		bne $80be			bne 	_NoMachineCode
.80a6		ad 03 20	lda $2003			lda 	$2003
.80a9		c9 54		cmp #$54			cmp 	#"T"
.80ab		d0 11		bne $80be			bne 	_NoMachineCode
.80ad		ad 04 20	lda $2004			lda 	$2004
.80b0		c9 36		cmp #$36			cmp 	#"6"
.80b2		d0 0a		bne $80be			bne 	_NoMachineCode
.80b4		ad 05 20	lda $2005			lda 	$2005
.80b7		c9 35		cmp #$35			cmp 	#"5"
.80b9		d0 03		bne $80be			bne 	_NoMachineCode
.80bb		4c 00 20	jmp $2000			jmp 	$2000
.80be						_NoMachineCode:
.80be		a9 00		lda #$00			lda 	#0 							; zero the default drive.
.80c0		20 9e 83	jsr $839e			jsr 	KNLSetDrive
.80c3		a9 00		lda #$00			lda 	#0 							; graphics system initialise.
.80c5		aa		tax				tax
.80c6		a8		tay				tay
.80c7		20 61 80	jsr $8061			jsr 	GXGraphicDraw
.80ca		a9 0f		lda #$0f			lda 	#$0F 						; initialise sound system
.80cc		20 6b 80	jsr $806b			jsr 	SNDCommand
.80cf		a9 8d		lda #$8d			lda 	#128+13 					; Display FPGA information.
.80d1		20 43 80	jsr $8043			jsr 	EXTPrintCharacter
.80d4		a9 09		lda #$09			lda 	#9
.80d6		20 43 80	jsr $8043			jsr 	EXTPrintCharacter
.80d9		20 43 80	jsr $8043			jsr 	EXTPrintCharacter
.80dc		64 01		stz $01				stz 	1
.80de		ad ad d6	lda $d6ad			lda 	$D6AD
.80e1		20 73 85	jsr $8573			jsr 	PrintHex
.80e4		ad ac d6	lda $d6ac			lda 	$D6AC
.80e7		20 73 85	jsr $8573			jsr 	PrintHex
.80ea		ad ab d6	lda $d6ab			lda 	$D6AB
.80ed		20 73 85	jsr $8573			jsr 	PrintHex
.80f0		ad aa d6	lda $d6aa			lda 	$D6AA
.80f3		20 73 85	jsr $8573			jsr 	PrintHex
.80f6		a9 20		lda #$20			lda 	#32
.80f8		20 43 80	jsr $8043			jsr 	EXTPrintCharacter
.80fb		ad a8 d6	lda $d6a8			lda 	$D6A8
.80fe		20 43 80	jsr $8043			jsr 	EXTPrintCharacter
.8101		ad a9 d6	lda $d6a9			lda 	$D6A9
.8104		20 43 80	jsr $8043			jsr 	EXTPrintCharacter
.8107		a2 81		ldx #$81			ldx 	#Prompt >> 8 				; display prompt
.8109		a9 1a		lda #$1a			lda 	#Prompt & $FF
.810b		20 56 9a	jsr $9a56			jsr 	PrintStringXA
.810e		20 55 82	jsr $8255			jsr 	ResetIOTracking 			; reset the I/O tracking.
.8111		20 bf 93	jsr $93bf			jsr 	NewProgram 					; erase current program
.8114		4c df 87	jmp $87df			jmp 	WarmStart					; make same size.
.8117		4c df 87	jmp $87df			jmp 	WarmStart
>811a		0d 0d				Prompt:	.text 	13,13

;******  Processing file: ./common/aa.system/../generated/timestamp.asm

>811c		09 09 30 38 2f 30 32 2f			.text 9,9,"08/02/23 33"
>8124		32 33 20 33 33

;******  Return to file: ./common/aa.system/00start.asm

>8129		0d 0d 0d 00					.text 	13,13,13,0

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/ab.system/events.asm

.812d						ProcessEvents:
.812d		20 dd 83	jsr $83dd			jsr 	KNLSetEventPointer
.8130		20 5e 82	jsr $825e			jsr     GetNextEvent 				; get next event
.8133		b0 27		bcs $815c			bcs 	_PEExitZ 					; nothing left to process.
.8135		ad 9b 07	lda $079b			lda 	KNLEvent.type 				; go back if event not key.pressed.
.8138		c9 08		cmp #$08			cmp 	#kernel.event.key.PRESSED
.813a		d0 f1		bne $812d			bne 	ProcessEvents
.813c		ad a1 07	lda $07a1			lda	 	KNLEvent.key.flags 			; is KNLEvent.key.flags = 0 ?
.813f		d0 ec		bne $812d			bne 	ProcessEvents
.8141		ad a0 07	lda $07a0			lda 	KNLEvent.key.ascii 			; is it Ctrl+C
.8144		c9 03		cmp #$03			cmp 	#3
.8146		f0 11		beq $8159			beq 	_PEReturnBreak  			; no, keep going.
.8148		da		phx				phx
.8149		ae 5d 06	ldx $065d			ldx 	KeyboardQueueEntries 		; get keyboard queue size into X
.814c		e0 08		cpx #$08			cpx 	#KBDQueueSize 				; if full, then ignore
.814e		f0 06		beq $8156			beq 	_PENoQueue
.8150		9d 55 06	sta $0655,x			sta 	KeyboardQueue,x 			; write into queue
.8153		ee 5d 06	inc $065d			inc 	KeyboardQueueEntries 		; bump count
.8156						_PENoQueue:
.8156		fa		plx				plx
.8157		80 d4		bra $812d			bra 	ProcessEvents
.8159						_PEReturnBreak:
.8159		a9 ff		lda #$ff			lda 	#255 						; return with NZ state
.815b		60		rts				rts
.815c						_PEExitZ:
.815c		a9 00		lda #$00			lda 	#0
.815e		60		rts				rts
.815f						PopKeyboardQueue:
.815f		ad 5d 06	lda $065d			lda 	KeyboardQueueEntries 		; get keyboard queue entries.
.8162		f0 17		beq $817b			beq 	_PKQExit 					; zero, then exit.
.8164		ad 55 06	lda $0655			lda 	KeyboardQueue 				; save head of keyboard queue
.8167		48		pha				pha
.8168		da		phx				phx 								; drop head of queue
.8169		a2 00		ldx #$00			ldx 	#0
.816b						_PKQLoop:
.816b		bd 56 06	lda $0656,x			lda 	KeyboardQueue+1,x 			; shift everything back one.
.816e		9d 55 06	sta $0655,x			sta 	KeyboardQueue,x  			; not efficient but doesn't matter.
.8171		e8		inx				inx
.8172		e0 07		cpx #$07			cpx 	#7
.8174		d0 f5		bne $816b			bne 	_PKQLoop
.8176		fa		plx				plx
.8177		ce 5d 06	dec $065d			dec 	KeyboardQueueEntries 		; one fewer in queue.
.817a		68		pla				pla 								; restore head of queue.
.817b						_PKQExit:
.817b		60		rts				rts
.817c						KNLGetKeyPressed:
.817c		a5 01		lda $01				lda 	1 							; save I/O 0
.817e		48		pha				pha
.817f		64 01		stz $01				stz 	1 							; access I/O Page 0
.8181		38		sec				sec 								; calculate timer - LastTick
.8182		ad 59 d6	lda $d659			lda 	$D659
.8185		cd 5e 06	cmp $065e			cmp 	LastTick
.8188		f0 06		beq $8190			beq 	_NoFireTick 				; if < 3 clocks don't fire.
.818a		8d 5e 06	sta $065e			sta 	LastTick 					; update last timer
.818d		20 4d 82	jsr $824d			jsr 	TickHandler 							; go do the code.
.8190						_NoFireTick:
.8190		68		pla				pla 								; restore I/O 0
.8191		85 01		sta $01				sta 	1
.8193		ad 5d 06	lda $065d			lda 	KeyboardQueueEntries 		; something in the queue
.8196		d0 c7		bne $815f			bne 	PopKeyboardQueue 			; if so, pop and return it
.8198		20 2d 81	jsr $812d			jsr 	ProcessEvents 				; process any outstanding events
.819b		a9 00		lda #$00			lda 	#0
.819d		60		rts				rts
.819e						KNLGetSingleCharacter:
.819e		20 7c 81	jsr $817c			jsr 	KNLGetKeyPressed
.81a1		c9 00		cmp #$00			cmp 	#0
.81a3		f0 f9		beq $819e			beq 	KNLGetSingleCharacter
.81a5		60		rts				rts
=8						KBDQueueSize = 8
.0655						KeyboardQueue:
>0655								.fill 	KBDQueueSize
.065d						KeyboardQueueEntries:
>065d								.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/ab.system/input.asm

.81a6						EXTInputLine:
.81a6		48		pha				pha
.81a7		da		phx				phx
.81a8		5a		phy				phy
.81a9		a5 01		lda $01				lda 	1 							; save I/O page
.81ab		48		pha				pha
.81ac						_EILLoop:
.81ac		20 9e 81	jsr $819e			jsr 	KNLGetSingleCharacter 		; get one single character
.81af		c9 0d		cmp #$0d			cmp 	#13 						; scrape line if exit.
.81b1		f0 44		beq $81f7			beq 	_EILExit
.81b3		c9 04		cmp #$04			cmp 	#4 							; Ctrl+D delete at cursor
.81b5		f0 2a		beq $81e1			beq 	_EILDelete
.81b7		c9 08		cmp #$08			cmp 	#8 							; Ctrl+H backspace
.81b9		f0 1c		beq $81d7			beq 	_EILBackspace
.81bb		c9 20		cmp #$20			cmp 	#' '						; < space, print it
.81bd		90 12		bcc $81d1			bcc 	_EILPrintLoop
.81bf		c9 7f		cmp #$7f			cmp 	#$7F 						; if -ve print it
.81c1		b0 0e		bcs $81d1			bcs 	_EILPrintLoop
.81c3		48		pha				pha 								; save character
.81c4		a9 02		lda #$02			lda 	#2  						; insert a space
.81c6		85 01		sta $01				sta 	1
.81c8		20 3b 82	jsr $823b			jsr 	EXTILInsert 				; insert in text screen
.81cb		e6 01		inc $01				inc 	1
.81cd		20 3b 82	jsr $823b			jsr 	EXTILInsert 				; insert in colour screen
.81d0		68		pla				pla 								; get character back.
.81d1						_EILPrintLoop:
.81d1		20 43 80	jsr $8043			jsr 	EXTPrintCharacter
.81d4		80 d6		bra $81ac			bra 	_EILLoop
.81d6		60		rts				rts
.81d7						_EILBackspace:
.81d7		ad c2 07	lda $07c2			lda 	EXTColumn					; can we backspace ?
.81da		f0 d0		beq $81ac			beq 	_EILLoop
.81dc		a9 02		lda #$02			lda 	#2 							; move cursor left
.81de		20 43 80	jsr $8043			jsr 	EXTPrintCharacter
.81e1						_EILDelete
.81e1		a9 02		lda #$02			lda 	#2 							; text block
.81e3		85 01		sta $01				sta 	1
.81e5		a9 20		lda #$20			lda 	#' ' 						; backspace text.
.81e7		20 26 82	jsr $8226			jsr 	EXTILDelete
.81ea		e6 01		inc $01				inc 	1 							; colour block
.81ec		ac c2 07	ldy $07c2			ldy 	EXTColumn 					; get attribute of last character
.81ef		88		dey				dey
.81f0		b1 40		lda ($40),y			lda 	(EXTAddress),y
.81f2		20 26 82	jsr $8226			jsr 	EXTILDelete 				; backspace attribute
.81f5		80 b5		bra $81ac			bra 	_EILLoop 					; and go round.
.81f7						_EILExit:
.81f7		a9 02		lda #$02			lda 	#2 							; switch to page 2
.81f9		85 01		sta $01				sta 	1
.81fb		a0 00		ldy #$00			ldy 	#0 							; copy current line into buffer.
.81fd						_EILScrapeLine:
.81fd		b1 40		lda ($40),y			lda 	(EXTAddress),y
.81ff		99 26 05	sta $0526,y			sta 	lineBuffer,y
.8202		c8		iny				iny
.8203		cc c4 07	cpy $07c4			cpy 	EXTScreenWidth
.8206		d0 f5		bne $81fd			bne 	_EILScrapeLine
.8208						_EILTrimSpaces:
.8208		88		dey				dey
.8209		c0 ff		cpy #$ff			cpy 	#$FF 						; back past the start
.820b		f0 07		beq $8214			beq 	_EILEndTrim		 			; zero the input line.
.820d		b9 26 05	lda $0526,y			lda 	lineBuffer,y
.8210		c9 20		cmp #$20			cmp 	#' '
.8212		f0 f4		beq $8208			beq 	_EILTrimSpaces 				; if fail this found non space character
.8214						_EILEndTrim:
.8214		c8		iny				iny 								; trim after non space character.
.8215		a9 00		lda #$00			lda 	#0 							; trim here.
.8217		99 26 05	sta $0526,y			sta 	lineBuffer,y
.821a		a9 0d		lda #$0d			lda 	#13 						; echo the RETURN
.821c		20 43 80	jsr $8043			jsr 	EXTPrintCharacter
.821f		68		pla				pla 								; reset I/O page
.8220		85 01		sta $01				sta 	1
.8222		7a		ply				ply
.8223		fa		plx				plx
.8224		68		pla				pla
.8225		60		rts				rts
.8226						EXTILDelete:
.8226		48		pha				pha 								; save the new character
.8227		ac c2 07	ldy $07c2			ldy 	EXTColumn 					; start copying from here.
.822a						_EXTDLoop:
.822a		c8		iny				iny 								; copy one byte down.
.822b		b1 40		lda ($40),y			lda 	(EXTAddress),y
.822d		88		dey				dey
.822e		91 40		sta ($40),y			sta 	(EXTAddress),y
.8230		c8		iny				iny 								; do till end of line.
.8231		cc c4 07	cpy $07c4			cpy 	EXTScreenWidth
.8234		90 f4		bcc $822a			bcc 	_EXTDLoop
.8236		88		dey				dey 	 							; write in last slot.
.8237		68		pla				pla
.8238		91 40		sta ($40),y			sta 	(EXTAddress),y
.823a		60		rts				rts
.823b						EXTILInsert:
.823b		ac c4 07	ldy $07c4			ldy 	EXTScreenWidth 				; end position
.823e						_EXTILoop:
.823e		88		dey				dey 								; back one
.823f		cc c2 07	cpy $07c2			cpy 	EXTColumn 					; exit if reached insert point.
.8242		f0 08		beq $824c			beq 	_EXTIExit
.8244		88		dey				dey 								; copy one byte up.
.8245		b1 40		lda ($40),y			lda 	(EXTAddress),y
.8247		c8		iny				iny
.8248		91 40		sta ($40),y			sta 	(EXTAddress),y
.824a		80 f2		bra $823e			bra 	_EXTILoop
.824c						_EXTIExit:
.824c		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/ab.system/ticktask.asm

.824d						TickHandler:
.824d		da		phx				phx
.824e		5a		phy				phy 								; need to preserve Y
.824f		20 75 80	jsr $8075			jsr 	SNDUpdate 					; update sound
.8252		7a		ply				ply
.8253		fa		plx				plx
.8254		60		rts				rts
.065e						LastTick:
>065e								.fill 		1

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/ab.system/trackio.asm

.8255						ResetIOTracking:
.8255		a2 3a		ldx #$3a			ldx 	#GNEEnd-GNEBegin-1
.8257						_RIOLoop:
.8257		9e 5f 06	stz $065f,x			stz 	GNEBegin,x
.825a		ca		dex				dex
.825b		10 fa		bpl $8257			bpl 	_RIOLoop
.825d		60		rts				rts
.825e						GetNextEvent:
.825e		20 00 ff	jsr $ff00			jsr 	kernel.NextEvent 			; get event
.8261		08		php				php									; save yes/no flag.
.8262		b0 29		bcs $828d			bcs 	_GNEExit
.8264		48		pha				pha 								; save registers
.8265		da		phx				phx
.8266		5a		phy				phy
.8267		ad 9b 07	lda $079b			lda 	KNLEvent.type	 			; check for PRESSED or RELEASED
.826a		c9 08		cmp #$08			cmp 	#kernel.event.key.PRESSED
.826c		f0 04		beq $8272			beq 	_GNEKeyEvent
.826e		c9 0a		cmp #$0a			cmp 	#kernel.event.key.RELEASED
.8270		d0 08		bne $827a			bne 	_GNECheckMouseEvent
.8272						_GNEKeyEvent:
.8272		20 4c 83	jsr $834c			jsr 	ProcessKeyboardEvent 		; process keyboard up/down.
.8275		20 69 83	jsr $8369			jsr 	UpdateKeyboardJoystick 		; update the keyboard-joystick.
.8278		80 10		bra $828a			bra 	_GNEEventExit
.827a						_GNECheckMouseEvent:
.827a		c9 0c		cmp #$0c			cmp 	#kernel.event.mouse.DELTA 	; check for move events
.827c		d0 05		bne $8283			bne 	_GNENotDelta
.827e		20 8f 82	jsr $828f			jsr 	ProcessMouseDeltaEvent 		; process them.
.8281		80 07		bra $828a			bra 	_GNEEventExit
.8283						_GNENotDelta:
.8283		c9 0e		cmp #$0e			cmp 	#kernel.event.mouse.CLICKS 	; check for click events
.8285		d0 03		bne $828a			bne 	_GNEEventExit
.8287		20 be 82	jsr $82be			jsr 	ProcessMouseClickEvent 		; process them.
.828a						_GNEEventExit:
.828a		7a		ply				ply 								; restore registers
.828b		fa		plx				plx
.828c		68		pla				pla
.828d						_GNEExit:
.828d		28		plp				plp
.828e		60		rts				rts
.828f						ProcessMouseDeltaEvent:
.828f		a2 23		ldx #$23			ldx 	#MouseDeltaX-GNEBegin
.8291		ad 9e 07	lda $079e			lda 	KNLEvent.mouse.delta.x
.8294		20 e5 82	jsr $82e5			jsr 	PMKAdjustTotal
.8297		20 28 83	jsr $8328			jsr 	PMKAddSubtract
.829a		ad 9f 07	lda $079f			lda 	KNLEvent.mouse.delta.y
.829d		20 e5 82	jsr $82e5			jsr 	PMKAdjustTotal
.82a0		20 28 83	jsr $8328			jsr 	PMKAddSubtract
.82a3		ad a0 07	lda $07a0			lda 	KNLEvent.mouse.delta.z
.82a6		20 e5 82	jsr $82e5			jsr 	PMKAdjustTotal
.82a9		20 28 83	jsr $8328			jsr 	PMKAddSubtract
.82ac		ad a1 07	lda $07a1			lda 	KNLEvent.mouse.delta.buttons
.82af		a2 35		ldx #$35			ldx 	#MouseStatusX-GNEBegin
.82b1		20 d3 82	jsr $82d3			jsr 	PMKOutputButton
.82b4		20 d3 82	jsr $82d3			jsr 	PMKOutputButton
.82b7		20 d3 82	jsr $82d3			jsr 	PMKOutputButton
.82ba		20 f4 82	jsr $82f4			jsr 	PMKClipMouseCoord
.82bd		60		rts				rts
.82be						ProcessMouseClickEvent:
.82be		a2 29		ldx #$29			ldx 	#MouseCountInner-GNEBegin
.82c0		ad 9e 07	lda $079e			lda 	KNLEvent.mouse.clicks.inner
.82c3		20 2c 83	jsr $832c			jsr 	PMKAdd
.82c6		ad 9f 07	lda $079f			lda 	KNLEvent.mouse.clicks.middle
.82c9		20 2c 83	jsr $832c			jsr 	PMKAdd
.82cc		ad a0 07	lda $07a0			lda 	KNLEvent.mouse.clicks.outer
.82cf		20 2c 83	jsr $832c			jsr 	PMKAdd
.82d2		60		rts				rts
.82d3						PMKOutputButton:
.82d3		9e 5f 06	stz $065f,x			stz 	GNEBegin,x 					; button to zero
.82d6		9e 60 06	stz $0660,x			stz 	GNEBegin+1,x
.82d9		6a		ror a				ror 	a 							; shift LSB into carry
.82da		90 06		bcc $82e2			bcc 	_PMKOBExit
.82dc		de 5f 06	dec $065f,x			dec 	GNEBegin,x 					; if set then set to -1
.82df		de 60 06	dec $0660,x			dec 	GNEBegin+1,x
.82e2						_PMKOBExit:
.82e2		e8		inx				inx  								; next button
.82e3		e8		inx				inx
.82e4		60		rts				rts
.82e5						PMKAdjustTotal:
.82e5		48		pha				pha 								; save offset A index X
.82e6		da		phx				phx
.82e7		48		pha				pha 								; point X to the position
.82e8		8a		txa				txa
.82e9		18		clc				clc
.82ea		69 0c		adc #$0c			adc 	#MousePosX-MouseDeltaX
.82ec		aa		tax				tax
.82ed		68		pla				pla
.82ee		20 28 83	jsr $8328			jsr 	PMKAddSubtract 				; reuse the addition code.
.82f1		fa		plx				plx 								; restore XA
.82f2		68		pla				pla
.82f3		60		rts				rts
.82f4						PMKClipMouseCoord:
.82f4		a2 00		ldx #$00			ldx 	#0
.82f6						_PCMCLoop:
.82f6		bd 8f 06	lda $068f,x			lda 	MousePosX+1,x 				; check if -ve
.82f9		10 06		bpl $8301			bpl 	_PCMCNotNeg
.82fb		9e 8e 06	stz $068e,x			stz 	MousePosX,x 				; if so zero position.
.82fe		9e 8f 06	stz $068f,x			stz 	MousePosX+1,x
.8301						_PCMCNotNeg:
.8301		bd 8e 06	lda $068e,x			lda 	MousePosX,x 				; compare pos vs extent
.8304		dd 22 83	cmp $8322,x			cmp 	_PCMCExtent,x
.8307		bd 8f 06	lda $068f,x			lda 	MousePosX+1,x
.830a		fd 23 83	sbc $8323,x			sbc 	_PCMCExtent+1,x
.830d		90 0c		bcc $831b			bcc 	_PCMCNotOver 				; in range ?
.830f		bd 22 83	lda $8322,x			lda 	_PCMCExtent,x 				; no, set to X limit.
.8312		9d 8e 06	sta $068e,x			sta 	MousePosX,x
.8315		bd 23 83	lda $8323,x			lda 	_PCMCExtent+1,x
.8318		9d 8f 06	sta $068f,x			sta 	MousePosX+1,x
.831b						_PCMCNotOver:
.831b		e8		inx				inx
.831c		e8		inx				inx
.831d		e0 06		cpx #$06			cpx 	#3*2
.831f		d0 d5		bne $82f6			bne 	_PCMCLoop
.8321		60		rts				rts
.8322						_PCMCExtent:
>8322		3f 01 ef 00 ff 00				.word 	319,239,255
.8328						PMKAddSubtract:
.8328		c9 00		cmp #$00			cmp 	#0 							; subtracting ?
.832a		30 0e		bmi $833a			bmi 	PMKSubtract
.832c						PMKAdd:
.832c		18		clc				clc
.832d		7d 5f 06	adc $065f,x			adc 	GNEBegin,x
.8330		9d 5f 06	sta $065f,x			sta 	GNEBegin,x
.8333		90 14		bcc $8349			bcc 	PMKExit
.8335		fe 60 06	inc $0660,x			inc 	GNEBegin+1,x
.8338		80 0f		bra $8349			bra 	PMKExit
.833a						PMKSubtract:
.833a		18		clc				clc
.833b		7d 5f 06	adc $065f,x			adc 	GNEBegin,x
.833e		9d 5f 06	sta $065f,x			sta 	GNEBegin,x
.8341		bd 60 06	lda $0660,x			lda 	GNEBegin+1,x
.8344		69 ff		adc #$ff			adc 	#$FF
.8346		9d 60 06	sta $0660,x			sta 	GNEBegin+1,x
.8349						PMKExit:
.8349		e8		inx				inx 								; next slot ?
.834a		e8		inx				inx
.834b		60		rts				rts
.834c						ProcessKeyboardEvent:
.834c		ad 9f 07	lda $079f			lda 	KNLEvent.key.raw 			; raw key code.
.834f		20 8a 83	jsr $838a			jsr 	KeyboardConvertXA  			; convert to index in X, mask in A
.8352		ac 9b 07	ldy $079b			ldy 	KNLEvent.type
.8355		c0 0a		cpy #$0a			cpy 	#kernel.event.key.RELEASED 	; check if pressed/released
.8357		f0 07		beq $8360			beq 	_PKERelease
.8359		1d 60 06	ora $0660,x			ora 	KeyStatus,x 				; set bit
.835c		9d 60 06	sta $0660,x			sta 	KeyStatus,x
.835f		60		rts				rts
.8360						_PKERelease:
.8360		49 ff		eor #$ff			eor 	#$FF						; clear bit
.8362		3d 60 06	and $0660,x			and 	KeyStatus,x
.8365		9d 60 06	sta $0660,x			sta 	KeyStatus,x
.8368		60		rts				rts
.8369						UpdateKeyboardJoystick:
.8369		9c 81 06	stz $0681			stz 	KeyJoystick
.836c		a2 00		ldx #$00			ldx 	#0
.836e						_UKJLoop:
.836e		bd 85 83	lda $8385,x			lda 	_UKJKeys,x 					; which key
.8371		29 1f		and #$1f			and 	#$1F
.8373		a8		tay				tay
.8374		b9 60 06	lda $0660,y			lda 	KeyStatus,y 				; get status
.8377		29 10		and #$10			and 	#$10 						; letters always bit 4 (actually ASCII of L/C)
.8379		18		clc				clc  								; set C if bit set
.837a		69 ff		adc #$ff			adc 	#$FF
.837c		2e 81 06	rol $0681			rol 	KeyJoystick 				; shift into place
.837f		e8		inx				inx
.8380		e0 05		cpx #$05			cpx 	#5 							; do all 5
.8382		d0 ea		bne $836e			bne 	_UKJLoop
.8384		60		rts				rts
.8385						_UKJKeys:
>8385		4c 58 5a 4d 4b					.byte	'L','X','Z','M','K'
.838a						KeyboardConvertXA:
.838a		a2 01		ldx #$01			ldx 	#1 							; set the mask temp to %00000001
.838c		8e 80 06	stx $0680			stx 	KeyMaskTemp
.838f						_KCCALoop:
.838f		18		clc				clc
.8390		69 20		adc #$20			adc 	#$20 						; upper 3 bits are the mask, if causes CS A will be in the range 00-1F
.8392		b0 05		bcs $8399			bcs 	_KCCADone
.8394		0e 80 06	asl $0680			asl 	KeyMaskTemp 				; shift the mask temp
.8397		80 f6		bra $838f			bra 	_KCCALoop
.8399						_KCCADone:
.8399		aa		tax				tax 								; table entry in X
.839a		ad 80 06	lda $0680			lda 	KeyMaskTemp 				; mask temp in A.
.839d		60		rts				rts
.065f						GNEBegin:
.065f						CMDMouseFlag:
>065f								.fill 	1
.0660						KeyStatus:
>0660								.fill 	32
.0680						KeyMaskTemp:
>0680								.fill 	1
.0681						KeyJoystick:
>0681								.fill 	1
.0682						MouseDeltaX:
>0682								.fill 	2
.0684						MouseDeltaY:
>0684								.fill 	2
.0686						MouseDeltaZ:
>0686								.fill 	2
.0688						MouseCountInner:
>0688								.fill 	2
.068a						MouseCountMiddle:
>068a								.fill 	2
.068c						MouseCountOuter:
>068c								.fill 	2
.068e						MousePosX:
>068e								.fill 	2
.0690						MousePosY:
>0690								.fill 	2
.0692						MousePosZ:
>0692								.fill 	2
.0694						MouseStatusX:
>0694								.fill 	2
.0696						MouseStatusY:
>0696								.fill 	2
.0698						MouseStatusZ:
>0698								.fill 	2
.069a						GNEEnd:

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/ab.system/wrapper.asm

=56						KERR_GENERAL = kernel.event.file.ERROR 		; Event $38
=50						KERR_CLOSED = kernel.event.file.CLOSED 		; Event $32
=40						KERR_NOTFOUND = kernel.event.file.NOT_FOUND ; Event $28
=48						KERR_EOF = kernel.event.file.EOF 			; Event $30
=64						KNLReadBufferLen = 64 								; read buffer size.
.839e						KNLSetDrive:
.839e		8d 9a 07	sta $079a			sta 	KNLDefaultDrive
.83a1		60		rts				rts
.83a2						KNLOpenFileWrite:
.83a2		48		pha				pha
.83a3		a9 01		lda #$01			lda 	#kernel.args.file.open.WRITE
.83a5		80 03		bra $83aa			bra 	KNLOpenStart
.83a7						KNLOpenFileRead:
.83a7		48		pha				pha
.83a8		a9 00		lda #$00			lda     #kernel.args.file.open.READ ; set READ mode.
.83aa						KNLOpenStart:
.83aa		85 f5		sta $f5				sta     kernel.args.file.open.mode
.83ac		68		pla				pla
.83ad		20 e8 83	jsr $83e8			jsr 	KNLSetupFileName
.83b0		20 dd 83	jsr $83dd			jsr 	KNLSetEventPointer
.83b3		ad 9a 07	lda $079a			lda 	KNLDefaultDrive 			; currently drive zero only.
.83b6		85 f3		sta $f3				sta 	kernel.args.file.open.drive
.83b8		20 5c ff	jsr $ff5c			jsr     kernel.File.Open 			; open the file and exit.
.83bb		a9 38		lda #$38			lda     #kernel.event.file.ERROR
.83bd		b0 1d		bcs $83dc			bcs     _out
.83bf						_loop
.83bf		20 0c ff	jsr $ff0c			jsr     kernel.Yield    			; event wait
.83c2		20 5e 82	jsr $825e			jsr     GetNextEvent
.83c5		b0 f8		bcs $83bf			bcs     _loop
.83c7		ad 9b 07	lda $079b			lda 	KNLEvent.type
.83ca		c9 2a		cmp #$2a			cmp     #kernel.event.file.OPENED
.83cc		f0 0a		beq $83d8			beq 	_success
.83ce		c9 28		cmp #$28			cmp     #kernel.event.file.NOT_FOUND
.83d0		f0 0a		beq $83dc			beq 	_out
.83d2		c9 38		cmp #$38			cmp     #kernel.event.file.ERROR
.83d4		f0 06		beq $83dc			beq 	_out
.83d6		80 e7		bra $83bf			bra     _loop
.83d8						_success
.83d8		ad 9e 07	lda $079e			lda     KNLEvent.file.stream
.83db		18		clc				clc
.83dc						_out
.83dc		60		rts				rts
.83dd						KNLSetEventPointer:
.83dd		48		pha				pha
.83de		a9 9b		lda #$9b			lda     #KNLEvent & $FF 			; tell kernel where to store event data
.83e0		85 f0		sta $f0				sta     kernel.args.events+0
.83e2		a9 07		lda #$07			lda     #KNLEvent >> 8
.83e4		85 f1		sta $f1				sta     kernel.args.events+1
.83e6		68		pla				pla
.83e7		60		rts				rts
.83e8						KNLSetupFileName:
.83e8		5a		phy				phy 								; save Y on stack
.83e9		85 36		sta $36				sta 	zTemp0 						; save filename position in temp, and in kenrel slot
.83eb		86 37		stx $37				stx 	zTemp0+1
.83ed		85 fb		sta $fb				sta     kernel.args.file.open.fname+0
.83ef		86 fc		stx $fc				stx     kernel.args.file.open.fname+1
.83f1		a0 ff		ldy #$ff			ldy 	#$FF 						; get the filename length => Kernel slot
.83f3						_KNLGetLength:
.83f3		c8		iny				iny
.83f4		b1 36		lda ($36),y			lda 	(zTemp0),y
.83f6		d0 fb		bne $83f3			bne 	_KNLGetLength
.83f8		84 fd		sty $fd				sty 	kernel.args.file.open.fname_len
.83fa		7a		ply				ply
.83fb		60		rts				rts
.83fc						KNLReadBlock:
.83fc		85 f3		sta $f3				sta     kernel.args.file.read.stream
.83fe		86 f4		stx $f4				stx     kernel.args.file.read.buflen
.8400		20 60 ff	jsr $ff60			jsr     kernel.File.Read 			; read request
.8403		a9 38		lda #$38			lda     #kernel.event.file.ERROR    ; Kernel out of events/buffers; shouldn't happen
.8405		b0 2e		bcs $8435			bcs     _KGNBExitFail               ; report as general error
.8407						_KGRBEventLoop:
.8407		20 0c ff	jsr $ff0c			jsr     kernel.Yield    			; event wait
.840a		20 5e 82	jsr $825e			jsr     GetNextEvent
.840d		b0 f8		bcs $8407			bcs     _KGRBEventLoop
.840f		ad 9b 07	lda $079b			lda 	KNLEvent.type 				; get event
.8412		c9 2c		cmp #$2c			cmp     #kernel.event.file.DATA 	; data, return data
.8414		f0 0a		beq $8420			beq     _KNLRBGetNextByte
.8416		c9 38		cmp #$38			cmp     #kernel.event.file.ERROR  	; errors on file i/o, return as appropriate.
.8418		f0 1b		beq $8435			beq 	_KGNBExitFail
.841a		c9 30		cmp #$30			cmp     #kernel.event.file.EOF
.841c		f0 17		beq $8435			beq 	_KGNBExitFail
.841e		80 e7		bra $8407			bra 	_KGRBEventLoop
.8420						_KNLRBGetNextByte:
.8420		a9 9a		lda #$9a			lda     #<KNLReadBuffer 			; Set the target buffer
.8422		85 fb		sta $fb				sta     kernel.args.recv.buf+0
.8424		a9 06		lda #$06			lda     #>KNLReadBuffer
.8426		85 fc		sta $fc				sta     kernel.args.recv.buf+1
.8428		ad a1 07	lda $07a1			lda     KNLEvent.file.data.read 	; Set the target length
.842b		85 fd		sta $fd				sta     kernel.args.recv.buflen
.842d		20 04 ff	jsr $ff04			jsr     kernel.ReadData		       	; Get the data from the kernel  (Synchronous call, no error)
.8430		ad a1 07	lda $07a1			lda     KNLEvent.file.data.read 	; Return # of bytes read (in A)
.8433		18		clc				clc
.8434		60		rts				rts
.8435						_KGNBExitFail:
.8435		38		sec				sec
.8436		60		rts				rts
.8437						KNLWriteBlock:
.8437		da		phx				phx
.8438		5a		phy				phy
.8439		85 f3		sta $f3				sta     kernel.args.file.write.stream ; save the stream.
.843b		a5 36		lda $36				lda     zTemp0 						; save the data location.
.843d		85 fb		sta $fb				sta     kernel.args.file.write.buf+0
.843f		a5 37		lda $37				lda     zTemp0+1
.8441		85 fc		sta $fc				sta     kernel.args.file.write.buf+1
.8443		86 fd		stx $fd				stx     kernel.args.file.write.buflen ; Set the buffer length
.8445		20 64 ff	jsr $ff64			jsr     kernel.File.Write 			; write it out.
.8448		a9 38		lda #$38			lda 	#kernel.event.file.ERROR 	; in case it fails.
.844a		b0 21		bcs $846d			bcs 	_KWBFailed
.844c						_KNLWLoop:
.844c		20 0c ff	jsr $ff0c			jsr     kernel.Yield
.844f		20 5e 82	jsr $825e			jsr     GetNextEvent
.8452		b0 f8		bcs $844c			bcs     _KNLWLoop
.8454		ad 9b 07	lda $079b			lda     KNLEvent.type 				; various errors.
.8457		c9 32		cmp #$32			cmp     #kernel.event.file.CLOSED
.8459		f0 12		beq $846d			beq 	_KWBFailed
.845b		c9 38		cmp #$38			cmp     #kernel.event.file.ERROR
.845d		f0 0e		beq $846d			beq 	_KWBFailed
.845f		c9 30		cmp #$30			cmp     #kernel.event.file.EOF
.8461		f0 0a		beq $846d			beq 	_KWBFailed
.8463		c9 2e		cmp #$2e			cmp     #kernel.event.file.WROTE 	; wait until block write succeeds
.8465		d0 e5		bne $844c			bne 	_KNLWLoop
.8467		18		clc				clc
.8468		ad a1 07	lda $07a1			lda    KNLEvent.file.wrote.wrote 	; get bytes written.
.846b		80 01		bra $846e			bra 	_KWBExit
.846d						_KWBFailed:
.846d		38		sec				sec
.846e						_KWBExit:
.846e		7a		ply				ply
.846f		fa		plx				plx
.8470		60		rts				rts
.8471						KNLCloseFile:
.8471		85 f3		sta $f3				sta     kernel.args.file.close.stream
.8473		20 68 ff	jsr $ff68			jsr     kernel.File.Close
.8476		60		rts				rts
.8477						KNLReadController:
.8477		da		phx				phx
.8478		a6 01		ldx $01				ldx 	1 							; save current I/O in X
.847a		64 01		stz $01				stz 	1 							; switch to I/O 0
.847c		ad 00 dc	lda $dc00			lda 	$DC00  						; read VIA register
.847f		49 ff		eor #$ff			eor 	#$FF 						; make active '1'
.8481		0d 81 06	ora $0681			ora 	KeyJoystick 				; use key joystick.
.8484		86 01		stx $01				stx 	1 							; repair old I/O and exit
.8486		fa		plx				plx
.8487		60		rts				rts
.069a						KNLReadBuffer:
>069a								.fill   256
.079a						KNLDefaultDrive:
>079a								.byte 	?
.079b						KNLEvent
>079b						type        .byte   ?   ; Enum above
>079c						buf         .byte   ?   ; page id or zero
>079d						ext         .byte   ?   ; page id or zero
.079e						key
>079e						keyboard    .byte   ?   ; Keyboard ID
>079f						raw         .byte   ?   ; Raw key ID
>07a0						ascii       .byte   ?   ; ASCII value
>07a1						flags       .byte   ?   ; Flags (META)
=$80						META        = $80       ; Meta key; no associated ASCII value.
.079e						mouse
.079e						delta
>079e						x           .byte   ?
>079f						y           .byte   ?
>07a0						z           .byte   ?
>07a1						buttons     .byte   ?
.079e						clicks
>079e						inner       .byte   ?
>079f						middle      .byte   ?
>07a0						outer       .byte   ?
.079e						joystick
>079e						joy0        .byte   ?
>079f						joy1        .byte   ?
.079e						udp
>079e						token       .byte   ?   ; TODO: break out into fields
.079e						file
>079e						stream      .byte   ?
>079f						cookie      .byte   ?
.07a0						data
>07a0						requested   .byte   ?   ; Requested number of bytes to read
>07a1						read        .byte   ?   ; Number of bytes actually read
.07a0						wrote
>07a0						requested   .byte   ?   ; Requested number of bytes to read
>07a1						wrote       .byte   ?   ; Number of bytes actually read
.079e						directory
>079e						stream      .byte   ?
>079f						cookie      .byte   ?
.07a0						volume
>07a0						len         .byte   ?   ; Length of volname (in buf)
>07a1						flags       .byte   ?   ; block size, text encoding
.07a0						file
>07a0						len         .byte   ?
>07a1						flags       .byte   ?   ; block scale, text encoding, approx size
.07a0						free
>07a0						flags       .byte   ?   ; block scale, text encoding, approx size

;******  Return to file: _basic.asm


;******  Processing file: ./common/api/api.asm

>ff00						NextEvent   .fill   4   ; Copy the next event into user-space.
>ff04						ReadData    .fill   4   ; Copy primary bulk event data into user-space
>ff08						ReadExt     .fill   4   ; Copy secondary bolk event data into user-space
>ff0c						Yield       .fill   4   ; Give unused time to the kernel.
>ff10						Putch       .fill   4   ; deprecated
>ff14						Basic       .fill   4   ; deprecated
>ff18						RunNamed    .fill   4   ; Chain to resident program by name.
>ff1c						            .fill   4   ; reserved
>ff20						List        .fill   4   ; Returns a bit-set of available block-accessible devices.
>ff24						GetName     .fill   4   ; Gets the hardware level name of the given block device or media.
>ff28						GetSize     .fill   4   ; Get the number of raw sectors (48 bits) for the given device
>ff2c						Read        .fill   4   ; Read a raw sector (48 bit LBA)
>ff30						Write       .fill   4   ; Write a raw sector (48 bit LBA)
>ff34						Format      .fill   4   ; Perform a low-level format if the media support it.
>ff38						Export      .fill   4   ; Update the FileSystem table with the partition table (if present).
>ff3c						List        .fill   4   ; Returns a bit-set of available logical devices.
>ff40						GetSize     .fill   4   ; Get the size of the partition or logical device in sectors.
>ff44						MkFS        .fill   4   ; Creates a new file-system on the logical device.
>ff48						CheckFS     .fill   4   ; Checks the file-system for errors and corrects them.
>ff4c						Mount       .fill   4   ; Mark the file-system as available for File and Directory operations.
>ff50						Unmount     .fill   4   ; Mark the file-system as unavailable for File and Directory operations.
>ff54						ReadBlock   .fill   4   ; Read a partition-local raw sector on an unmounted device.
>ff58						WriteBlock  .fill   4   ; Write a partition-local raw sector on an unmounted device.
>ff5c						Open        .fill   4   ; Open the given file for read, create, or append.
>ff60						Read        .fill   4   ; Request bytes from a file opened for reading.
>ff64						Write       .fill   4   ; Write bytes to a file opened for create or append.
>ff68						Close       .fill   4   ; Close an open file.
>ff6c						Rename      .fill   4   ; Rename a closed file.
>ff70						Delete      .fill   4   ; Delete a closed file.
>ff74						Open        .fill   4   ; Open a directory for reading.
>ff78						Read        .fill   4   ; Read a directory entry; may also return VOLUME and FREE events.
>ff7c						Close       .fill   4   ; Close a directory once finished reading.
>ff80						            .fill   4   ; call gate
>ff84						Reset       .fill   4   ; Re-init the display
>ff88						GetSize     .fill   4   ; Returns rows/cols in kernel args.
>ff8c						DrawRow     .fill   4   ; Draw text/color buffers left-to-right
>ff90						DrawColumn  .fill   4   ; Draw text/color buffers top-to-bottom
>ff94						GetIP       .fill   4   ; Get the local IP address.
>ff98						SetIP       .fill   4   ; Set the local IP address.
>ff9c						GetDNS      .fill   4   ; Get the configured DNS IP address.
>ffa0						SetDNS      .fill   4   ; Set the configured DNS IP address.
>ffa4						GetTime     .fill   4
>ffa8						SetTime     .fill   4
>ffac						GetSysInfo  .fill   4
>ffb0						SetBPS      .fill   4   ; Set the serial BPS (should match the SLIP router's speed).
>ffb4						InitUDP     .fill   4
>ffb8						SendUDP     .fill   4
>ffbc						RecvUDP     .fill   4
>ffc0						InitTCP     .fill   4
>ffc4						SendTCP     .fill   4
>ffc8						RecvTCP     .fill   4
>ffcc						SendICMP    .fill   4
>ffd0						RecvICMP    .fill   4
.00f0						args
.00f0						events
>00f0						dest        .word       ?   ; GetNextEvent copies event data here
>00f2						pending     .byte       ?   ; Negative count of pending events
.00f3						end
.00f3						recv
=$fb						buf         = args.buf
=$fd						buflen      = args.buflen
.00f3						fs
.00f3						format
>00f3						drive       .byte       ?
>00f4						cookie      .byte       ?
=$fb						label       = args.buf
=$fd						label_len   = args.buflen
.00f3						mkfs
>00f3						drive       .byte       ?
>00f4						cookie      .byte       ?
=$fb						label       = args.buf
=$fd						label_len   = args.buflen
.00f3						file
.00f3						open
>00f3						drive       .byte       ?
>00f4						cookie      .byte       ?
=$fb						fname       = args.buf
=$fd						fname_len   = args.buflen
>00f5						mode        .byte       ?
=0						READ        = 0
=1						WRITE       = 1
=2						END         = 2
.00f3						read
>00f3						stream      .byte       ?
>00f4						buflen      .byte       ?
.00f3						write
>00f3						stream      .byte       ?
=$fb						buf         = args.buf
=$fd						buflen      = args.buflen
.00f3						close
>00f3						stream      .byte       ?
.00f3						rename
>00f3						drive       .byte       ?
>00f4						cookie      .byte       ?
=$fb						old         = args.buf
=$fd						old_len     = args.buflen
=$f8						new         = args.ext
=$fa						new_len     = args.extlen
.00f3						delete
>00f3						drive       .byte       ?
>00f4						cookie      .byte       ?
=$fb						fname       = args.buf
=$fd						fname_len   = args.buflen
>00f5						mode        .byte       ?
=0						READ        = 0
=1						WRITE       = 1
=2						END         = 2
.00f3						directory
.00f3						open
>00f3						drive       .byte       ?
>00f4						cookie      .byte       ?
=$fb						path        = args.buf
=$fd						path_len    = args.buflen
.00f3						read
>00f3						stream      .byte       ?
>00f4						buflen      .byte       ?
.00f3						close
>00f3						stream      .byte       ?
.00f3						display
>00f3						x           .byte       ?   ; coordinate or size
>00f4						y           .byte       ?   ; coordinate or size
=$fb						text        = args.buf      ; text
=$f8						color       = args.ext      ; color
=$fb						buf         = args.buf      ; deprecated
=$f8						buf2        = args.ext      ; deprecated
=$fd						buflen      = args.buflen
.00f3						net
=$fb						socket      = args.buf
>00f3						src_port    .word       ?
>00f5						dest_port   .word       ?
>00f7						dest_ip     .fill       4
>00f3						accepted    .byte       ?
=$f8						buf         = args.ext
=$fa						buflen      = args.extlen
=$f8						ext         = $f8
=$fa						extlen      = $fa
=$fb						buf         = $fb
=$fd						buflen      = $fd
=$fe						ptr         = $fe
.0000						args_t
.0000						events
>0000						dest        .word       ?   ; GetNextEvent copies event data here
>0002						pending     .byte       ?   ; Negative count of pending events
.0003						end
.0003						recv
=$fb						buf         = args.buf
=$fd						buflen      = args.buflen
.0003						fs
.0003						format
>0003						drive       .byte       ?
>0004						cookie      .byte       ?
=$fb						label       = args.buf
=$fd						label_len   = args.buflen
.0003						mkfs
>0003						drive       .byte       ?
>0004						cookie      .byte       ?
=$fb						label       = args.buf
=$fd						label_len   = args.buflen
.0003						file
.0003						open
>0003						drive       .byte       ?
>0004						cookie      .byte       ?
=$fb						fname       = args.buf
=$fd						fname_len   = args.buflen
>0005						mode        .byte       ?
=0						READ        = 0
=1						WRITE       = 1
=2						END         = 2
.0003						read
>0003						stream      .byte       ?
>0004						buflen      .byte       ?
.0003						write
>0003						stream      .byte       ?
=$fb						buf         = args.buf
=$fd						buflen      = args.buflen
.0003						close
>0003						stream      .byte       ?
.0003						rename
>0003						drive       .byte       ?
>0004						cookie      .byte       ?
=$fb						old         = args.buf
=$fd						old_len     = args.buflen
=$f8						new         = args.ext
=$fa						new_len     = args.extlen
.0003						delete
>0003						drive       .byte       ?
>0004						cookie      .byte       ?
=$fb						fname       = args.buf
=$fd						fname_len   = args.buflen
>0005						mode        .byte       ?
=0						READ        = 0
=1						WRITE       = 1
=2						END         = 2
.0003						directory
.0003						open
>0003						drive       .byte       ?
>0004						cookie      .byte       ?
=$fb						path        = args.buf
=$fd						path_len    = args.buflen
.0003						read
>0003						stream      .byte       ?
>0004						buflen      .byte       ?
.0003						close
>0003						stream      .byte       ?
.0003						display
>0003						x           .byte       ?   ; coordinate or size
>0004						y           .byte       ?   ; coordinate or size
=$fb						text        = args.buf      ; text
=$f8						color       = args.ext      ; color
=$fb						buf         = args.buf      ; deprecated
=$f8						buf2        = args.ext      ; deprecated
=$fd						buflen      = args.buflen
.0003						net
=$fb						socket      = args.buf
>0003						src_port    .word       ?
>0005						dest_port   .word       ?
>0007						dest_ip     .fill       4
>0003						accepted    .byte       ?
=$f8						buf         = args.ext
=$fa						buflen      = args.extlen
=$f8						ext         = $f8
=$fa						extlen      = $fa
=$fb						buf         = $fb
=$fd						buflen      = $fd
=$fe						ptr         = $fe
.0000						event_t
>0000						dest        .word       ?   ; GetNextEvent copies event data here
>0002						pending     .byte       ?   ; Negative count of pending events
.0003						end
.0000						recv_t
=$fb						buf         = args.buf
=$fd						buflen      = args.buflen
.0000						fs_t
.0000						format
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						label       = args.buf
=$fd						label_len   = args.buflen
.0000						mkfs
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						label       = args.buf
=$fd						label_len   = args.buflen
.0000						fs_mkfs_t
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						label       = args.buf
=$fd						label_len   = args.buflen
.0000						file_t
.0000						open
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						fname       = args.buf
=$fd						fname_len   = args.buflen
>0002						mode        .byte       ?
=0						READ        = 0
=1						WRITE       = 1
=2						END         = 2
.0000						read
>0000						stream      .byte       ?
>0001						buflen      .byte       ?
.0000						write
>0000						stream      .byte       ?
=$fb						buf         = args.buf
=$fd						buflen      = args.buflen
.0000						close
>0000						stream      .byte       ?
.0000						rename
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						old         = args.buf
=$fd						old_len     = args.buflen
=$f8						new         = args.ext
=$fa						new_len     = args.extlen
.0000						delete
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						fname       = args.buf
=$fd						fname_len   = args.buflen
>0002						mode        .byte       ?
=0						READ        = 0
=1						WRITE       = 1
=2						END         = 2
.0000						fs_open_t
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						fname       = args.buf
=$fd						fname_len   = args.buflen
>0002						mode        .byte       ?
=0						READ        = 0
=1						WRITE       = 1
=2						END         = 2
.0000						fs_read_t
>0000						stream      .byte       ?
>0001						buflen      .byte       ?
.0000						fs_write_t
>0000						stream      .byte       ?
=$fb						buf         = args.buf
=$fd						buflen      = args.buflen
.0000						fs_close_t
>0000						stream      .byte       ?
.0000						fs_rename_t
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						old         = args.buf
=$fd						old_len     = args.buflen
=$f8						new         = args.ext
=$fa						new_len     = args.extlen
.0000						fs_delete_t
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						fnane       = args.buf
=$fd						fname_len   = args.buflen
.0000						dir_t
.0000						open
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						path        = args.buf
=$fd						path_len    = args.buflen
.0000						read
>0000						stream      .byte       ?
>0001						buflen      .byte       ?
.0000						close
>0000						stream      .byte       ?
.0000						dir_open_t
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						path        = args.buf
=$fd						path_len    = args.buflen
.0000						dir_read_t
>0000						stream      .byte       ?
>0001						buflen      .byte       ?
.0000						dir_close_t
>0000						stream      .byte       ?
.0000						display_t
>0000						x           .byte       ?   ; coordinate or size
>0001						y           .byte       ?   ; coordinate or size
=$fb						text        = args.buf      ; text
=$f8						color       = args.ext      ; color
=$fb						buf         = args.buf      ; deprecated
=$f8						buf2        = args.ext      ; deprecated
=$fd						buflen      = args.buflen
.0000						net_t
=$fb						socket      = args.buf
>0000						src_port    .word       ?
>0002						dest_port   .word       ?
>0004						dest_ip     .fill       4
>0000						accepted    .byte       ?
=$f8						buf         = args.ext
=$fa						buflen      = args.extlen
>0000						            .word   ?   ; Reserved
>0002						            .word   ?   ; Deprecated
>0004						JOYSTICK    .word   ?   ; Game Controller changes.
>0006						DEVICE      .word   ?   ; Device added/removed.
>0008						PRESSED     .word   ?   ; Key pressed
>000a						RELEASED    .word   ?   ; Key released.
>000c						DELTA       .word   ?   ; Regular mouse move and button state
>000e						CLICKS      .word   ?   ; Click counts
>0010						NAME        .word   ?
>0012						SIZE        .word   ?
>0014						DATA        .word   ?   ; The read request has succeeded.
>0016						WROTE       .word   ?   ; The write request has completed.
>0018						FORMATTED   .word   ?   ; The low-level format has completed.
>001a						ERROR       .word   ?
>001c						SIZE        .word   ?
>001e						CREATED     .word   ?
>0020						CHECKED     .word   ?
>0022						DATA        .word   ?   ; The read request has succeeded.
>0024						WROTE       .word   ?   ; The write request has completed.
>0026						ERROR       .word   ?
>0028						NOT_FOUND   .word   ?   ; The file file was not found.
>002a						OPENED      .word   ?   ; The file was successfully opened.
>002c						DATA        .word   ?   ; The read request has succeeded.
>002e						WROTE       .word   ?   ; The write request has completed.
>0030						EOF         .word   ?   ; All file data has been read.
>0032						CLOSED      .word   ?   ; The close request has completed.
>0034						RENAMED     .word   ?   ; The rename request has completed.
>0036						DELETED     .word   ?   ; The delete request has completed.
>0038						ERROR       .word   ?   ; An error occured; close the file if opened.
>003a						OPENED      .word   ?   ; The directory open request succeeded.
>003c						VOLUME      .word   ?   ; A volume record was found.
>003e						FILE        .word   ?   ; A file record was found.
>0040						FREE        .word   ?   ; A file-system free-space record was found.
>0042						EOF         .word   ?   ; All data has been read.
>0044						CLOSED      .word   ?   ; The directory file has been closed.
>0046						ERROR       .word   ?   ; An error occured; user should close.
>0048						TCP         .word   ?
>004a						UDP         .word   ?
.0000						event_t
>0000						type        .byte   ?   ; Enum above
>0001						buf         .byte   ?   ; page id or zero
>0002						ext         .byte   ?   ; page id or zero
.0003						key
>0003						keyboard    .byte   ?   ; Keyboard ID
>0004						raw         .byte   ?   ; Raw key ID
>0005						ascii       .byte   ?   ; ASCII value
>0006						flags       .byte   ?   ; Flags (META)
=$80						META        = $80       ; Meta key; no associated ASCII value.
.0003						mouse
.0003						delta
>0003						x           .byte   ?
>0004						y           .byte   ?
>0005						z           .byte   ?
>0006						buttons     .byte   ?
.0003						clicks
>0003						inner       .byte   ?
>0004						middle      .byte   ?
>0005						outer       .byte   ?
.0003						joystick
>0003						joy0        .byte   ?
>0004						joy1        .byte   ?
.0003						udp
>0003						token       .byte   ?   ; TODO: break out into fields
.0003						file
>0003						stream      .byte   ?
>0004						cookie      .byte   ?
.0005						data
>0005						requested   .byte   ?   ; Requested number of bytes to read
>0006						read        .byte   ?   ; Number of bytes actually read
.0005						wrote
>0005						requested   .byte   ?   ; Requested number of bytes to read
>0006						wrote       .byte   ?   ; Number of bytes actually read
.0003						directory
>0003						stream      .byte   ?
>0004						cookie      .byte   ?
.0005						volume
>0005						len         .byte   ?   ; Length of volname (in buf)
>0006						flags       .byte   ?   ; block size, text encoding
.0005						file
>0005						len         .byte   ?
>0006						flags       .byte   ?   ; block scale, text encoding, approx size
.0005						free
>0005						flags       .byte   ?   ; block scale, text encoding, approx size
.0000						key_t
>0000						keyboard    .byte   ?   ; Keyboard ID
>0001						raw         .byte   ?   ; Raw key ID
>0002						ascii       .byte   ?   ; ASCII value
>0003						flags       .byte   ?   ; Flags (META)
=$80						META        = $80       ; Meta key; no associated ASCII value.
.0000						mouse_t
.0000						delta
>0000						x           .byte   ?
>0001						y           .byte   ?
>0002						z           .byte   ?
>0003						buttons     .byte   ?
.0000						clicks
>0000						inner       .byte   ?
>0001						middle      .byte   ?
>0002						outer       .byte   ?
.0000						m_delta_t
>0000						x           .byte   ?
>0001						y           .byte   ?
>0002						z           .byte   ?
>0003						buttons     .byte   ?
.0000						m_clicks_t
>0000						inner       .byte   ?
>0001						middle      .byte   ?
>0002						outer       .byte   ?
.0000						joystick_t
>0000						joy0        .byte   ?
>0001						joy1        .byte   ?
.0000						file_t
>0000						stream      .byte   ?
>0001						cookie      .byte   ?
.0002						data
>0002						requested   .byte   ?   ; Requested number of bytes to read
>0003						read        .byte   ?   ; Number of bytes actually read
.0002						wrote
>0002						requested   .byte   ?   ; Requested number of bytes to read
>0003						wrote       .byte   ?   ; Number of bytes actually read
.0000						fs_data_t
>0000						requested   .byte   ?   ; Requested number of bytes to read
>0001						read        .byte   ?   ; Number of bytes actually read
.0000						fs_wrote_t
>0000						requested   .byte   ?   ; Requested number of bytes to read
>0001						wrote       .byte   ?   ; Number of bytes actually read
.0000						dir_t
>0000						stream      .byte   ?
>0001						cookie      .byte   ?
.0002						volume
>0002						len         .byte   ?   ; Length of volname (in buf)
>0003						flags       .byte   ?   ; block size, text encoding
.0002						file
>0002						len         .byte   ?
>0003						flags       .byte   ?   ; block scale, text encoding, approx size
.0002						free
>0002						flags       .byte   ?   ; block scale, text encoding, approx size
.0000						dir_vol_t
>0000						len         .byte   ?   ; Length of volname (in buf)
>0001						flags       .byte   ?   ; block size, text encoding
.0000						dir_file_t
>0000						len         .byte   ?
>0001						flags       .byte   ?   ; block scale, text encoding, approx size
.0000						dir_free_t
>0000						flags       .byte   ?   ; block scale, text encoding, approx size
.0000						dir_ext_t
>0000						free        .fill   6   ; blocks used/free
.0000						udp_t
>0000						token       .byte   ?   ; TODO: break out into fields

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/assembler.asm

.8488						AssembleGroup1:
.8488		a9 ff		lda #$ff			lda 	#$FF 						; flag for group 1 / mask.
.848a		8d 21 04	sta $0421			sta 	ModeMask 					; initialise the mode mask - all for all
.848d		80 02		bra $8491			bra 	AsmGroup12
.848f						AssembleGroup2:
.848f		a9 00		lda #$00			lda 	#$00 						; flag for group 2
.8491						AsmGroup12:
.8491		8d 1f 04	sta $041f			sta 	IsGroup1 					; save the 'group 1' flag
.8494		68		pla				pla 								; pop the return address to access the information following.
.8495		fa		plx				plx
.8496		20 1d 85	jsr $851d			jsr 	AccessParameters 			; get opcode and save as base
.8499		8d 20 04	sta $0420			sta 	BaseOpcode
.849c		ad 1f 04	lda $041f			lda 	IsGroup1 					; skip if group 1 as we don't have a complex mask.
.849f		d0 08		bne $84a9			bne 	_AG12HaveMask
.84a1		a9 02		lda #$02			lda 	#2 							; if group 2 the second parameter is the mask
.84a3		20 25 85	jsr $8525			jsr 	GetParameter		 		; e.g. which modes are supported for this operand
.84a6		8d 21 04	sta $0421			sta 	ModeMask
.84a9						_AG12HaveMask:
.84a9		20 59 86	jsr $8659			jsr 	TypeAndCalculateOperand 	; get zero page type
.84ac		da		phx				phx 								; save found address mode
.84ad		20 89 85	jsr $8589			jsr 	AssembleModeX
.84b0		fa		plx				plx  								; restore address mode
.84b1		b0 0b		bcs $84be			bcs 	_AG12Exit
.84b3		20 bf 84	jsr $84bf			jsr 	PromoteToAbsolute  			; promote ZP to ABS and try that
.84b6		20 89 85	jsr $8589			jsr 	AssembleModeX
.84b9		b0 03		bcs $84be			bcs 	_AG12Exit
.84bb		4c f3 ab	jmp $abf3			jmp 	SyntaxError 				; can't do either, so must be wrong mode/operand.
.84be						_AG12Exit:
.84be		60		rts				rts
.84bf						PromoteToAbsolute:
.84bf		a9 6c		lda #$6c			lda 	#AM_ABS 					; lda xx
.84c1		e0 e4		cpx #$e4			cpx 	#AM_ZEROPAGE
.84c3		f0 19		beq $84de			beq 	_PTADo
.84c5		a9 7c		lda #$7c			lda 	#AM_ABSX 					; lda xx,X
.84c7		e0 f4		cpx #$f4			cpx 	#AM_ZEROX
.84c9		f0 13		beq $84de			beq 	_PTADo
.84cb		a9 78		lda #$78			lda 	#AM_ABSY 					; lda xx,Y
.84cd		e0 80		cpx #$80			cpx 	#AM_ZEROY
.84cf		f0 0d		beq $84de			beq 	_PTADo
.84d1		a9 01		lda #$01			lda 	#AM_INDABS 					; lda (xx) (jump)
.84d3		e0 d1		cpx #$d1			cpx 	#AM_IND
.84d5		f0 07		beq $84de			beq 	_PTADo
.84d7		a9 02		lda #$02			lda 	#AM_INDABSX 				; lda (xx,x) (jump)
.84d9		e0 c0		cpx #$c0			cpx 	#AM_INDX
.84db		f0 01		beq $84de			beq 	_PTADo
.84dd		60		rts				rts
.84de						_PTADo:
.84de		aa		tax				tax
.84df		60		rts				rts
.84e0						AssembleGroup3:
.84e0		68		pla				pla 								; get parameters, which is just the opcode.
.84e1		fa		plx				plx
.84e2		20 1d 85	jsr $851d			jsr 	AccessParameters 			; get and output opcode
.84e5		20 35 85	jsr $8535			jsr 	AssemblerWriteByte
.84e8		20 bd 86	jsr $86bd			jsr 	CalculateOperand 			; get a 16 bit operand
.84eb		a5 58		lda $58				lda 	NSMantissa0 				; calculate the offset
.84ed		38		sec				sec
.84ee		ed 1a 04	sbc $041a			sbc 	AssemblerAddress
.84f1		48		pha				pha 								; LSB in A
.84f2		a5 60		lda $60				lda 	NSMantissa1
.84f4		ed 1b 04	sbc $041b			sbc 	AssemblerAddress+1
.84f7		aa		tax				tax 								; MSB in X
.84f8		68		pla				pla
.84f9		18		clc				clc 								; $80 to easy check $80-$7F, plus 1 for offset error
.84fa		69 7f		adc #$7f			adc 	#$7F
.84fc		90 01		bcc $84ff			bcc 	_AG3NoCarry
.84fe		e8		inx				inx
.84ff						_AG3NoCarry:
.84ff		38		sec				sec 								; fix back and write out anyways.
.8500		e9 80		sbc #$80			sbc 	#$80
.8502		20 35 85	jsr $8535			jsr 	AssemblerWriteByte
.8505		e0 00		cpx #$00			cpx 	#0 							; was it in range
.8507		f0 0a		beq $8513			beq 	_AG3Exit
.8509		ad 1c 04	lda $041c			lda 	AssemblerControl 			; are we allowing bad values ?
.850c		29 01		and #$01			and 	#1
.850e		f0 03		beq $8513			beq 	_AG3Exit
.8510		4c f8 ab	jmp $abf8			jmp 	RangeError 					; no, branch is out of range
.8513						_AG3Exit:
.8513		60		rts				rts
.8514						AssembleGroup4:
.8514		68		pla				pla 								; pop address
.8515		fa		plx				plx
.8516		20 1d 85	jsr $851d			jsr 	AccessParameters 			; access and get first
.8519		20 35 85	jsr $8535			jsr 	AssemblerWriteByte 			; output it.
.851c		60		rts				rts
.851d						AccessParameters:
.851d		8d 1d 04	sta $041d			sta 	ParamStart
.8520		8e 1e 04	stx $041e			stx 	ParamStart+1
.8523		a9 01		lda #$01			lda 	#1
.8525						GetParameter:
.8525		5a		phy				phy
.8526		a8		tay				tay
.8527		ad 1d 04	lda $041d			lda 	ParamStart
.852a		85 36		sta $36				sta 	zTemp0
.852c		ad 1e 04	lda $041e			lda 	ParamStart+1
.852f		85 37		sta $37				sta 	zTemp0+1
.8531		b1 36		lda ($36),y			lda 	(zTemp0),y
.8533		7a		ply				ply
.8534		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/aswrite.asm

.8535						AssemblerWriteByte:
.8535		48		pha			pha
.8536		ad 1c 04	lda $041c		lda 	AssemblerControl 				; check printing bytes ?
.8539		29 02		and #$02		and 	#2
.853b		f0 1b		beq $8558		beq 	_AWBNoPrint
.853d		ad 1b 04	lda $041b		lda		AssemblerAddress+1 				; print address
.8540		20 73 85	jsr $8573		jsr 	PrintHex
.8543		ad 1a 04	lda $041a		lda		AssemblerAddress
.8546		20 73 85	jsr $8573		jsr 	PrintHex
.8549		a9 20		lda #$20		lda 	#' '
.854b		20 43 80	jsr $8043		jsr 	EXTPrintCharacter
.854e		68		pla			pla 									; print byte
.854f		48		pha			pha
.8550		20 73 85	jsr $8573		jsr 	PrintHex
.8553		a9 0d		lda #$0d		lda 	#13
.8555		20 43 80	jsr $8043		jsr 	EXTPrintCharacter
.8558						_AWBNoPrint:
.8558		ad 1a 04	lda $041a		lda		AssemblerAddress				; copy address to zTemp0
.855b		85 36		sta $36			sta 	zTemp0
.855d		ad 1b 04	lda $041b		lda		AssemblerAddress+1
.8560		f0 0e		beq $8570		beq 	_AWBRange
.8562		85 37		sta $37			sta 	zTemp0+1
.8564		68		pla			pla 									; write byte out
.8565		92 36		sta ($36)		sta 	(zTemp0)
.8567		ee 1a 04	inc $041a		inc 	AssemblerAddress 				; bump address
.856a		d0 03		bne $856f		bne 	_AWBNoCarry
.856c		ee 1b 04	inc $041b		inc 	AssemblerAddress+1
.856f						_AWBNoCarry:
.856f		60		rts			rts
.8570						_AWBRange:
.8570		4c f8 ab	jmp $abf8		jmp 	RangeError
.8573						PrintHex:
.8573		48		pha				pha
.8574		4a		lsr a				lsr 	a
.8575		4a		lsr a				lsr 	a
.8576		4a		lsr a				lsr 	a
.8577		4a		lsr a				lsr 	a
.8578		20 7c 85	jsr $857c			jsr 	_PrintNibble
.857b		68		pla				pla
.857c						_PrintNibble:
.857c		29 0f		and #$0f			and 	#15
.857e		c9 0a		cmp #$0a			cmp 	#10
.8580		90 02		bcc $8584			bcc 	_NoShift
.8582		69 06		adc #$06			adc 	#6
.8584						_NoShift:
.8584		69 30		adc #$30			adc 	#48
.8586		4c 43 80	jmp $8043			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/instruction.asm

.8589						AssembleModeX:
.8589		5a		phy				phy
.858a		ad 1f 04	lda $041f			lda 	IsGroup1
.858d		f0 17		beq $85a6			beq 	_AMXGroup2
.858f		8a		txa				txa 							; is it in group # 1
.8590		29 40		and #$40			and 	#AM_ISG1
.8592		f0 4d		beq $85e1			beq 	_AMXFail 				; no, give up.
.8594		8a		txa				txa 							; get back.
.8595		29 1f		and #$1f			and 	#$1F 					; this is now the offset.
.8597		e0 e0		cpx #$e0			cpx 	#AM_IMMEDIATE 			; if not immediate, we can continue.
.8599		d0 22		bne $85bd			bne 	_AMXHaveInfo
.859b		ad 20 04	lda $0420			lda 	BaseOpcode 				; cannot store immediate.
.859e		c9 81		cmp #$81			cmp 	#$81
.85a0		f0 3f		beq $85e1			beq 	_AMXFail
.85a2		a9 08		lda #$08			lda 	#8 						; if immediate we use offset 8.
.85a4		80 17		bra $85bd			bra 	_AMXHaveInfo 			; odd design decision there.
.85a6						_AMXGroup2:
.85a6		8a		txa				txa 							; is it in group 2 ?
.85a7		29 20		and #$20			and 	#AM_ISG2
.85a9		f0 36		beq $85e1			beq 	_AMXFail 				; no, give up.
.85ab		8a		txa				txa 							; get the offset into Y
.85ac		29 1f		and #$1f			and 	#$1F
.85ae		4a		lsr a				lsr 	a 						; make it 0-7.
.85af		4a		lsr a				lsr  	a
.85b0		a8		tay				tay
.85b1		ad 21 04	lda $0421			lda 	ModeMask 				; shift the modemask left so you can check it against the requested offset
.85b4						_AMXCheckOkay:
.85b4		0a		asl a				asl 	a 						; shift modemask left enough times to check legitimate.
.85b5		88		dey				dey
.85b6		10 fc		bpl $85b4			bpl 	_AMXCheckOkay
.85b8		90 27		bcc $85e1			bcc 	_AMXFail 				; not allowed.
.85ba		8a		txa				txa  							; get mask back
.85bb		29 1f		and #$1f			and 	#$1F
.85bd						_AMXHaveInfo:
.85bd		e0 00		cpx #$00			cpx 	#$00 					; does it *require* an 8 bit operand
.85bf		10 04		bpl $85c5			bpl 	_AMXAnySize 			; checking bit 7, the zero page opcode flag.
.85c1		a4 60		ldy $60				ldy 	NSMantissa1 			; fail if it is outside range, e.g. the MSB is set.
.85c3		d0 1c		bne $85e1			bne 	_AMXFail
.85c5						_AMXAnySize:
.85c5		18		clc				clc 							; add offset to the base opcode
.85c6		6d 20 04	adc $0420			adc 	BaseOpcode
.85c9						_AMXOutputCode:
.85c9		20 35 85	jsr $8535			jsr 	AssemblerWriteByte 		; write the opcode out.
.85cc		e0 28		cpx #$28			cpx 	#AM_ACC 				; A mode (e.g. ASL)
.85ce		f0 0e		beq $85de			beq 	_AMXExit
.85d0		a5 58		lda $58				lda 	NSMantissa0 			; write LSB operand
.85d2		20 35 85	jsr $8535			jsr 	AssemblerWriteByte
.85d5		e0 00		cpx #$00			cpx 	#$00 					; zeropage ?
.85d7		30 05		bmi $85de			bmi 	_AMXExit
.85d9		a5 60		lda $60				lda 	NSMantissa1 			; write MSB operand
.85db		20 35 85	jsr $8535			jsr 	AssemblerWriteByte
.85de						_AMXExit:
.85de		7a		ply				ply
.85df		38		sec				sec
.85e0		60		rts				rts
.85e1						_AMXFail:
.85e1		a0 00		ldy #$00			ldy 	#0
.85e3						_AMXCheckOddities:
.85e3		8a		txa				txa
.85e4		d9 0b 86	cmp $860b,y			cmp 	ExtraOpcode+2,y 		; match address mode
.85e7		d0 15		bne $85fe			bne 	_AMXCONext
.85e9		b9 09 86	lda $8609,y			lda 	ExtraOpcode+0,y 		; do the base opcodes match
.85ec		cd 20 04	cmp $0420			cmp 	BaseOpcode
.85ef		d0 0d		bne $85fe			bne 	_AMXCONext
.85f1		e0 00		cpx #$00			cpx 	#$00 					; requires zero page ?
.85f3		10 04		bpl $85f9			bpl 	_AMXCONotZero
.85f5		a5 60		lda $60				lda 	NSMantissa1
.85f7		d0 05		bne $85fe			bne 	_AMXCONext
.85f9						_AMXCONotZero:
.85f9		b9 0a 86	lda $860a,y			lda 	ExtraOpcode+1,y 		; get new opcode
.85fc		80 cb		bra $85c9			bra 	_AMXOutputCode 			; and assemble it
.85fe						_AMXCONext:
.85fe		c8		iny				iny
.85ff		c8		iny				iny
.8600		c8		iny				iny
.8601		b9 09 86	lda $8609,y			lda 	ExtraOpcode+0,y 		; end of table
.8604		d0 dd		bne $85e3			bne 	_AMXCheckOddities
.8606						_AMXCOFail:
.8606		7a		ply				ply
.8607		18		clc				clc
.8608		60		rts				rts
.8609						ExtraOpcode:
>8609		40 6c 01					.byte $40,$6c,AM_INDABS 	; jump
>860c		40 7c 02					.byte $40,$7C,AM_INDABSX 	; jump
>860f		a2 be 78					.byte $a2,$BE,AM_ABSY 		; ldx
>8612		a2 b6 80					.byte $a2,$B6,AM_ZEROY 		; ldx
>8615		82 96 80					.byte $82,$96,AM_ZEROY 		; stx
>8618		e2 1a 28					.byte $e2,$1a,AM_ACC 		; inc
>861b		c2 3a 28					.byte $c2,$3a,AM_ACC 		; dec
>861e		20 89 e0					.byte $20,$89,AM_IMMEDIATE 	; bit
>8621		60 9c 6c					.byte $60,$9c,AM_ABS 		; stz
>8624		60 9e 7c					.byte $60,$9e,AM_ABSX 		; stz
>8627		00						.byte $00

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/label.asm

.8628						LabelHere:
.8628		c8		iny				iny 								; skip .
.8629		a2 00		ldx #$00			ldx 	#0 							; get a term
.862b		20 4b a3	jsr $a34b			jsr 	EvaluateTerm
.862e		a5 50		lda $50				lda 	NSStatus 					; needs to be an integer reference.
.8630		c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.8632		d0 22		bne $8656			bne 	_ALType 					; otherwise typing error
.8634		b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy reference address to zTemp0
.8636		85 36		sta $36				sta 	zTemp0 						; (e.g. where we store the address)
.8638		b5 60		lda $60,x			lda 	NSMantissa1,x
.863a		85 37		sta $37				sta 	zTemp0+1
.863c		5a		phy				phy 								; copy address in (64k)
.863d		a0 01		ldy #$01			ldy 	#1
.863f		ad 1a 04	lda $041a			lda	 	AssemblerAddress
.8642		92 36		sta ($36)			sta 	(zTemp0)
.8644		ad 1b 04	lda $041b			lda	 	AssemblerAddress+1
.8647		91 36		sta ($36),y			sta 	(zTemp0),y
.8649		c8		iny				iny
.864a		a9 00		lda #$00			lda 	#0 							; zero the rest.
.864c		91 36		sta ($36),y			sta 	(zTemp0),y
.864e		c8		iny				iny
.864f		91 36		sta ($36),y			sta 	(zTemp0),y
.8651		c8		iny				iny
.8652		91 36		sta ($36),y			sta 	(zTemp0),y
.8654		7a		ply				ply
.8655		60		rts				rts
.8656						_ALType:
.8656		4c fd ab	jmp $abfd			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/operands.asm

.8659						TypeAndCalculateOperand:
.8659		b1 30		lda ($30),y			lda 	(codePtr),y
.865b		a2 28		ldx #$28			ldx 	#AM_ACC 					; ACC if : or EOL
.865d		c9 3a		cmp #$3a			cmp 	#KWD_COLON
.865f		f0 5b		beq $86bc			beq 	_TACOExit
.8661		c9 80		cmp #$80			cmp 	#KWC_EOL
.8663		f0 57		beq $86bc			beq 	_TACOExit
.8665		c8		iny				iny
.8666		a2 e0		ldx #$e0			ldx 	#AM_IMMEDIATE
.8668		c9 23		cmp #$23			cmp 	#KWD_HASH 					; if hash, then immediate - constant.
.866a		f0 51		beq $86bd			beq 	CalculateOperand
.866c		c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; if ( then check for indirection
.866e		f0 1f		beq $868f			beq 	_TACOIndirect
.8670		88		dey				dey 								; undo get of first character
.8671		20 bd 86	jsr $86bd			jsr 	CalculateOperand 			; get operand
.8674		b1 30		lda ($30),y			lda 	(codePtr),y
.8676		a2 e4		ldx #$e4			ldx 	#AM_ZEROPAGE 				; if not, try zero page (then absolute)
.8678		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.867a		d0 40		bne $86bc			bne 	_TACOExit
.867c		c8		iny				iny
.867d		20 c7 86	jsr $86c7			jsr 	TACOCheckXY 				; extract X,Y or 0 (neither) from the variable.
.8680		a2 f4		ldx #$f4			ldx 	#AM_ZEROX 					; check for X
.8682		c9 58		cmp #$58			cmp 	#'X'
.8684		f0 36		beq $86bc			beq 	_TACOExit
.8686		a2 80		ldx #$80			ldx 	#AM_ZEROY 					; check for Y
.8688		c9 59		cmp #$59			cmp 	#'Y'
.868a		f0 30		beq $86bc			beq 	_TACOExit
.868c						_TACOSyntax:
.868c		4c f3 ab	jmp $abf3			jmp 	SyntaxError
.868f						_TACOIndirect:
.868f		20 bd 86	jsr $86bd			jsr 	CalculateOperand 			; get the operand
.8692		b1 30		lda ($30),y			lda 	(codePtr),y
.8694		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if , then it must be ,X)
.8696		f0 17		beq $86af			beq 	_TACOIndX
.8698		20 de 99	jsr $99de			jsr 	CheckRightBracket  			; otherwise must be ) or ),Y
.869b		b1 30		lda ($30),y			lda 	(codePtr),y
.869d		a2 d1		ldx #$d1			ldx 	#AM_IND
.869f		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not comma then exit with (xx)
.86a1		d0 19		bne $86bc			bne 	_TACOExit
.86a3		c8		iny				iny
.86a4		20 c7 86	jsr $86c7			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.86a7		c9 59		cmp #$59			cmp 	#'Y' 						; check Y
.86a9		d0 e1		bne $868c			bne 	_TACOSyntax
.86ab		a2 d0		ldx #$d0			ldx 	#AM_INDY
.86ad		80 0d		bra $86bc			bra 	_TACOExit
.86af						_TACOIndX:
.86af		c8		iny				iny
.86b0		20 c7 86	jsr $86c7			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.86b3		c9 58		cmp #$58			cmp 	#'X' 						; check X
.86b5		d0 d5		bne $868c			bne 	_TACOSyntax
.86b7		20 de 99	jsr $99de			jsr 	CheckRightBracket			; check )
.86ba		a2 c0		ldx #$c0			ldx 	#AM_INDX
.86bc						_TACOExit:
.86bc		60		rts				rts
.86bd						CalculateOperand:
.86bd		48		pha				pha
.86be		da		phx				phx
.86bf		a2 00		ldx #$00			ldx 	#0 							; get 16 bit integer in Slot 0
.86c1		20 d7 a8	jsr $a8d7			jsr 	Evaluate16BitInteger
.86c4		fa		plx				plx
.86c5		68		pla				pla
.86c6		60		rts				rts
.86c7						TACOCheckXY:
.86c7		b1 30		lda ($30),y			lda 	(codePtr),y
.86c9		29 c0		and #$c0			and 	#$C0 						; check it is an identifier reference.
.86cb		c9 40		cmp #$40			cmp 	#$40
.86cd		d0 21		bne $86f0			bne 	_TCXYFail
.86cf		b1 30		lda ($30),y			lda 	(codePtr),y
.86d1		18		clc				clc
.86d2		69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.86d4		85 37		sta $37				sta 	zTemp0+1
.86d6		c8		iny				iny
.86d7		b1 30		lda ($30),y			lda 	(codePtr),y
.86d9		c8		iny				iny
.86da		85 36		sta $36				sta 	zTemp0
.86dc		5a		phy				phy 								; save position
.86dd		a0 02		ldy #$02			ldy 	#2 							; type is integer ?
.86df		b1 36		lda ($36),y			lda 	(zTemp0),y
.86e1		d0 0c		bne $86ef			bne 	_TCXYPopFail
.86e3		a0 08		ldy #$08			ldy 	#8 							; get first character, should have bit 7 set as also last.
.86e5		b1 36		lda ($36),y			lda 	(zTemp0),y
.86e7		c9 d8		cmp #$d8			cmp 	#'X'+$80 					; should be X or Y
.86e9		f0 08		beq $86f3			beq 	_TCXYFound
.86eb		c9 d9		cmp #$d9			cmp 	#'Y'+$80
.86ed		f0 04		beq $86f3			beq 	_TCXYFound
.86ef						_TCXYPopFail:
.86ef		7a		ply				ply
.86f0						_TCXYFail:
.86f0		a9 00		lda #$00			lda 	#0
.86f2		60		rts				rts
.86f3						_TCXYFound:
.86f3		7a		ply				ply 								; restore position
.86f4		29 7f		and #$7f			and 	#$7F 						; throw bit 7
.86f6		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/backload.asm

.86f7						BackloadProgram:
.86f7		20 bf 93	jsr $93bf			jsr 	NewProgram 					; does the actual NEW.
.86fa		a2 87		ldx #$87			ldx 	#_BLLoad >> 8
.86fc		a9 57		lda #$57			lda 	#_BLLoad & $FF
.86fe		20 56 9a	jsr $9a56			jsr 	PrintStringXA
.8701		a9 14		lda #$14			lda 	#SOURCE_ADDRESS >> 13 		; start page
.8703		8d a2 07	sta $07a2			sta 	BackLoadPage
.8706		a9 00		lda #$00			lda 	#(($6000) & $FF)
.8708		8d a3 07	sta $07a3			sta 	0+BackLoadPointer
.870b		a9 60		lda #$60			lda 	#(($6000) >> 8)
.870d		8d a4 07	sta $07a4			sta 	1+BackLoadPointer
.8710		9c a5 07	stz $07a5			stz 	BackLoadLast 				; reset backload last.
.8713		9c a6 07	stz $07a6			stz 	BackLoadLast+1
.8716		a9 ff		lda #$ff			lda 	#$FF
.8718		8d fa ff	sta $fffa			sta 	$FFFA
.871b						_BPLoop:
.871b		a2 ff		ldx #$ff			ldx 	#$FF
.871d		20 8c 87	jsr $878c			jsr 	BLReadByte 					; read a byte
.8720		c9 00		cmp #$00			cmp 	#0
.8722		f0 2c		beq $8750			beq 	_BPExit 					; if 0 exit
.8724		30 2a		bmi $8750			bmi 	_BPExit 					; if -ve exit
.8726						_BPCopy:
.8726		e8		inx				inx  								; copy byte into the lineBuffer
.8727		9d 26 05	sta $0526,x			sta 	lineBuffer,x
.872a		9e 27 05	stz $0527,x			stz 	lineBuffer+1,x
.872d		20 8c 87	jsr $878c			jsr 	BLReadByte 					; read next byte
.8730		30 0a		bmi $873c			bmi 	_BPEndLine 					; -ve = EOL
.8732		c9 09		cmp #$09			cmp 	#9 							; handle TAB, make it space.
.8734		d0 02		bne $8738			bne 	_BPNotTab
.8736		a9 20		lda #$20			lda 	#' '
.8738						_BPNotTab:
.8738		c9 20		cmp #$20			cmp 	#' ' 						; < ' ' = EOL
.873a		b0 ea		bcs $8726			bcs 	_BPCopy 					; until a control character, should be 13 received.
.873c						_BPEndLine:
.873c		20 89 80	jsr $8089			jsr 	TKTokeniseLine 				; tokenise the line.
.873f		ad 27 04	lda $0427			lda 	tokenLineNumber 			; line number = 0
.8742		0d 28 04	ora $0428			ora 	tokenLineNumber+1
.8745		f0 d4		beq $871b			beq 	_BPLoop 					; not legal code, blank line or maybe a comment.
.8747		20 6c 87	jsr $876c			jsr 	BLCheckLast 				; check last backload okay.
.874a		38		sec				sec 								; append not insert
.874b		20 e7 ad	jsr $ade7			jsr 	MemoryInsertLine 			; append to current program
.874e		80 cb		bra $871b			bra 	_BPLoop
.8750						_BPExit:
.8750		9c fa ff	stz $fffa			stz 	$FFFA
.8753		20 86 98	jsr $9886			jsr 	ClearSystem 				; clear variables etc.
.8756		60		rts				rts
.8757						_BLLoad:
>8757		4c 6f 61 64 69 6e 67 20				.text 	"Loading from Memory",13,0
>875f		66 72 6f 6d 20 4d 65 6d 6f 72 79 0d 00
.876c						BLCheckLast:
.876c		ad a5 07	lda $07a5			lda 	BackLoadLast 				; check last < current
.876f		cd 27 04	cmp $0427			cmp 	tokenLineNumber
.8772		ad a6 07	lda $07a6			lda 	BackLoadLast+1
.8775		ed 28 04	sbc $0428			sbc 	tokenLineNumber+1
.8778		b0 0d		bcs $8787			bcs 	_BLCheckFail
.877a		ad 27 04	lda $0427			lda 	tokenLineNumber 			; update
.877d		8d a5 07	sta $07a5			sta 	BackLoadLast
.8780		ad 28 04	lda $0428			lda 	tokenLineNumber+1
.8783		8d a6 07	sta $07a6			sta 	BackLoadLast+1
.8786		60		rts				rts
.8787						_BLCheckFail:
.8787		a9 02		lda #$02		lda	#2
.8789		4c f7 99	jmp $99f7		jmp	ErrorHandler
.878c						BLReadByte:
.878c		da		phx				phx
.878d		a6 0b		ldx $0b				ldx 	8+3 						; save current mapping for $6000 in X
.878f		ad a2 07	lda $07a2			lda 	BackLoadPage	 			; set current page
.8792		85 0b		sta $0b				sta 	8+3
.8794		ad a3 07	lda $07a3			lda 	BackLoadPointer 			; copy pointer to zTemp0
.8797		85 36		sta $36				sta 	zTemp0
.8799		ad a4 07	lda $07a4			lda 	BackLoadPointer+1
.879c		85 37		sta $37				sta 	zTemp0+1
.879e		b2 36		lda ($36)			lda 	(zTemp0) 					; read next byte
.87a0		ee a3 07	inc $07a3			inc 	BackLoadPointer 			; bump pointer
.87a3		d0 0f		bne $87b4			bne 	_BLNoCarry
.87a5		ee a4 07	inc $07a4			inc 	BackLoadPointer+1
.87a8		10 0a		bpl $87b4			bpl 	_BLNoCarry 					; need a new page
.87aa		48		pha				pha
.87ab		a9 60		lda #$60			lda 	#$60 						; reset pointer
.87ad		8d a4 07	sta $07a4			sta 	BackLoadPointer+1
.87b0		ee a2 07	inc $07a2			inc 	BackLoadPage 				; next page from source.
.87b3		68		pla				pla
.87b4						_BLNoCarry:
.87b4		86 0b		stx $0b				stx 	8+3 						; restore mapping, then X.
.87b6		fa		plx				plx
.87b7		c9 00		cmp #$00			cmp 	#0
.87b9		60		rts				rts
.07a2						BackLoadPage:
>07a2								.fill  	1
.07a3						BackLoadPointer:
>07a3								.fill 	2
.07a5						BackLoadLast:
>07a5								.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/editor.asm

.87ba						EditProgramCode:
.87ba		ad 27 04	lda $0427			lda 	tokenLineNumber 			; try to find the line.
.87bd		ae 28 04	ldx $0428			ldx 	tokenLineNumber+1
.87c0		20 8b ae	jsr $ae8b			jsr 	MemorySearch
.87c3		90 05		bcc $87ca			bcc 	_EPCNoDelete 				; reached the end : don't delete
.87c5		d0 03		bne $87ca			bne 	_EPCNoDelete 				; found slot but didn't match : no delete
.87c7		20 b0 ad	jsr $adb0			jsr 	MemoryDeleteLine 			; delete the line
.87ca						_EPCNoDelete:
.87ca		ad 29 04	lda $0429			lda 	tokenBuffer 				; buffer empty - we just want to delete a line.
.87cd		c9 80		cmp #$80			cmp 	#KWC_EOL
.87cf		f0 0d		beq $87de			beq 	_EPCNoInsert
.87d1		ad 27 04	lda $0427			lda 	tokenLineNumber 			; find the line - it cannot exist as we've just deleted it.
.87d4		ae 28 04	ldx $0428			ldx 	tokenLineNumber+1 			; so this can't fail, it returns some point in the code.
.87d7		20 8b ae	jsr $ae8b			jsr 	MemorySearch
.87da		18		clc				clc 								; insert at this point.
.87db		20 e7 ad	jsr $ade7			jsr 	MemoryInsertLine 			; insert the line
.87de						_EPCNoInsert:
.87de		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/warmstart.asm

.87df						WarmStart:
.87df		a2 ff		ldx #$ff			ldx 	#$FF
.87e1		9a		txs				txs
.87e2		a9 89		lda #$89			lda 	#CLICommandLine+$80 		; set console colour whatever the current colour is.
.87e4		20 43 80	jsr $8043			jsr 	EXTPrintCharacter
.87e7		20 a6 81	jsr $81a6			jsr 	EXTInputLine 				; get line to lineBuffer
.87ea		20 89 80	jsr $8089			jsr 	TKTokeniseLine 				; tokenise the line
.87ed		ad 27 04	lda $0427			lda 	tokenLineNumber 			; line number <> 0
.87f0		0d 28 04	ora $0428			ora 	tokenLineNumber+1
.87f3		d0 17		bne $880c			bne 	_WSEditCode 				; if so,edit code.
.87f5		9c 26 04	stz $0426			stz 	tokenOffset 				; zero the "offset", meaning it only runs one line.
.87f8		a9 26		lda #$26			lda 	#((tokenOffset) & $FF)
.87fa		85 30		sta $30				sta 	codePtr
.87fc		a9 04		lda #$04			lda 	#((tokenOffset) >> 8)
.87fe		85 31		sta $31				sta 	codePtr+1
.8800		ad 29 04	lda $0429			lda 	tokenBuffer 				; nothing to run
.8803		c9 80		cmp #$80			cmp 	#KWC_EOL
.8805		f0 d8		beq $87df			beq 	WarmStart
.8807		20 5c 95	jsr $955c			jsr 	RUNCodePointerLine 			; execute that line.
.880a		80 d3		bra $87df			bra 	WarmStart
.880c						_WSEditCode:
.880c		20 ba 87	jsr $87ba			jsr 	EditProgramCode 			; edit the program code
.880f		20 86 98	jsr $9886			jsr 	ClearSystem 				; clear all variables etc.
.8812		80 cb		bra $87df			bra 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assemble.asm

.8814						AssembleCommand:
.8814		a2 00		ldx #$00			ldx 	#0
.8816		20 d7 a8	jsr $a8d7			jsr 	Evaluate16BitInteger 		; start address
.8819		a5 58		lda $58				lda 	NSMantissa0
.881b		8d 1a 04	sta $041a			sta 	AssemblerAddress
.881e		a5 60		lda $60				lda 	NSMantissa1
.8820		8d 1b 04	sta $041b			sta 	AssemblerAddress+1
.8823		20 e6 99	jsr $99e6			jsr 	CheckComma
.8826		20 f2 a8	jsr $a8f2			jsr 	Evaluate8BitInteger 		; options 0-3
.8829		a5 58		lda $58				lda 	NSMantissa0
.882b		8d 1c 04	sta $041c			sta 	AssemblerControl
.882e		60		rts				rts
.882f		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assert.asm

.8830						AssertCommand:
.8830		a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.8832		20 c4 a8	jsr $a8c4			jsr 	EvaluateInteger 			; the assert test
.8835		20 79 a9	jsr $a979			jsr 	NSMIsZero 					; exit if result is non zero.
.8838		d0 05		bne $883f			bne 	_ACExit
.883a		a9 0a		lda #$0a		lda	#10
.883c		4c f7 99	jmp $99f7		jmp	ErrorHandler
.883f						_ACExit:
.883f		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/call.asm

.8840						CallCommand:
.8840		a2 00		ldx #$00			ldx 	#0 							; get the routine address to level 0
.8842		20 d7 a8	jsr $a8d7			jsr 	Evaluate16BitInteger
.8845						_CCClear
.8845		e8		inx				inx  								; clear 1,2 and 3 (for A X Y)
.8846		20 57 a9	jsr $a957			jsr 	NSMSetZero 					; these are optional sequentially.
.8849		e0 04		cpx #$04			cpx 	#4
.884b		d0 f8		bne $8845			bne 	_CCClear
.884d		a2 00		ldx #$00			ldx 	#0 							; and keep trying while there are more values.
.884f						_CCCParam:
.884f		b1 30		lda ($30),y			lda 	(codePtr),y
.8851		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8853		d0 09		bne $885e			bne 	_CCCRun6502
.8855		c8		iny				iny 								; skip comma
.8856		e8		inx				inx	 								; next level
.8857		20 f2 a8	jsr $a8f2			jsr 	Evaluate8BitInteger 		; get A/X/Y
.885a		e0 03		cpx #$03			cpx 	#3
.885c		90 f1		bcc $884f			bcc 	_CCCParam 					; done all 3 ?
.885e						_CCCRun6502:
.885e		5a		phy				phy 								; save position
.885f		a5 60		lda $60				lda 	NSMantissa1 				; put address in zTemp0
.8861		85 37		sta $37				sta 	zTemp0+1
.8863		a5 58		lda $58				lda 	NSMantissa0
.8865		85 36		sta $36				sta 	zTemp0
.8867		a5 59		lda $59				lda 	NSMantissa0+1 				; get registers into A X Y
.8869		a6 5a		ldx $5a				ldx 	NSMantissa0+2
.886b		a4 5b		ldy $5b				ldy 	NSMantissa0+3
.886d		20 72 88	jsr $8872			jsr 	_CCCZTemp0 					; call zTemp0
.8870		7a		ply				ply 								; restore position and exit
.8871		60		rts				rts
.8872						_CCCZTemp0:
.8872		6c 36 00	jmp ($0036)			jmp 	(zTemp0)

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/commands/crossdev.asm

.8875						XLoadCommand:
.8875		20 bf 93	jsr $93bf			jsr 	NewProgram
.8878		20 f7 86	jsr $86f7			jsr 	BackloadProgram
.887b		4c df 87	jmp $87df			jmp 	WarmStart
.887e						XGoCommand:
.887e		20 bf 93	jsr $93bf			jsr 	NewProgram
.8881		20 f7 86	jsr $86f7			jsr 	BackloadProgram
.8884		4c 4a 95	jmp $954a			jmp 	RunCurrentProgram

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/data.asm

.8887						Command_Data:
.8887		a9 3a		lda #$3a			lda 	#KWD_COLON 					; advance to colon/EOL, e.g. ignore anything till then.
.8889		a2 80		ldx #$80			ldx 	#KWC_EOL
.888b		20 39 99	jsr $9939			jsr 	ScanForward
.888e		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dim.asm

.888f						DimCommand:
.888f		b1 30		lda ($30),y			lda 	(codePtr),y
.8891		29 c0		and #$c0			and 	#$C0
.8893		c9 40		cmp #$40			cmp 	#$40
.8895		d0 7a		bne $8911			bne 	_DCSyntax 				; n o, error.
.8897		b1 30		lda ($30),y			lda 	(codePtr),y
.8899		18		clc				clc
.889a		69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.889c		85 3f		sta $3f				sta 	zaTemp+1
.889e		c8		iny				iny
.889f		b1 30		lda ($30),y			lda 	(codePtr),y
.88a1		c8		iny				iny
.88a2		85 3e		sta $3e				sta 	zaTemp
.88a4		5a		phy				phy
.88a5		a0 02		ldy #$02			ldy 	#2 						; read type byte
.88a7		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.88a9		29 18		and #$18			and 	#NSBTypeMask 			; check it's not a procedure
.88ab		c9 18		cmp #$18			cmp 	#NSTProcedure
.88ad		f0 62		beq $8911			beq 	_DCSyntax
.88af		b1 3e		lda ($3e),y			lda 	(zaTemp),y 				; check it's an array
.88b1		29 04		and #$04			and 	#NSBIsArray
.88b3		f0 64		beq $8919			beq 	_DCType
.88b5		a0 04		ldy #$04			ldy 	#4 						; check not already defined
.88b7		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.88b9		d0 59		bne $8914			bne 	_DCRedefine
.88bb		7a		ply				ply
.88bc		20 1c 89	jsr $891c			jsr 	_DCGetSize 				; get array size, check it.
.88bf		5a		phy				phy
.88c0		a0 05		ldy #$05			ldy 	#5 						; store in first array size slot
.88c2		91 3e		sta ($3e),y			sta 	(zaTemp),y 				; second will be zero.
.88c4		7a		ply				ply 							; is there a second (e.g. ,x)
.88c5		b1 30		lda ($30),y			lda 	(codePtr),y
.88c7		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.88c9		d0 0a		bne $88d5			bne 	_DCOneDimension
.88cb		c8		iny				iny 							; skip comma
.88cc		20 1c 89	jsr $891c			jsr 	_DCGetSize 				; get 2nd array size
.88cf		5a		phy				phy
.88d0		a0 06		ldy #$06			ldy 	#6 						; store in 2nd array size
.88d2		91 3e		sta ($3e),y			sta 	(zaTemp),y
.88d4		7a		ply				ply
.88d5						_DCOneDimension:
.88d5		5a		phy				phy 							; save position
.88d6		a0 05		ldy #$05			ldy 	#5 						; dimensions + 1 in AX (as zero based)
.88d8		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.88da		aa		tax				tax
.88db		c8		iny				iny
.88dc		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.88de		e8		inx				inx 							; bump them.
.88df		1a		inc a				inc 	a
.88e0		20 02 a9	jsr $a902			jsr 	Multiply8x8 			; work out the total number of elements -> zTemp0
.88e3		a5 37		lda $37				lda 	zTemp0+1 				; don't allow more than 8192 elements whatever
.88e5		29 e0		and #$e0			and 	#$E0
.88e7		d0 23		bne $890c			bne 	_DCSize
.88e9		a0 02		ldy #$02			ldy 	#2 						; get base type
.88eb		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.88ed		20 2a 89	jsr $892a			jsr 	ScaleByBaseType 		; scale by base type
.88f0		a5 36		lda $36				lda 	zTemp0
.88f2		a6 37		ldx $37				ldx 	zTemp0+1
.88f4		20 f9 a4	jsr $a4f9			jsr 	AllocateXABytes 		; allocate memory
.88f7		a0 03		ldy #$03			ldy 	#3 						; copy into the address.
.88f9		91 3e		sta ($3e),y			sta 	(zaTemp),y
.88fb		c8		iny				iny
.88fc		8a		txa				txa
.88fd		91 3e		sta ($3e),y			sta 	(zaTemp),y
.88ff		7a		ply				ply 							; get position back
.8900		20 de 99	jsr $99de			jsr 	CheckRightBracket 		; check )
.8903		b1 30		lda ($30),y			lda 	(codePtr),y
.8905		c8		iny				iny 							; consume in case
.8906		c9 2c		cmp #$2c			cmp 	#KWD_COMMA		 		; if so do another DIM.
.8908		f0 85		beq $888f			beq 	DimCommand
.890a		88		dey				dey 							; undo consume
.890b		60		rts				rts
.890c						_DCSize:
.890c		a9 16		lda #$16		lda	#22
.890e		4c f7 99	jmp $99f7		jmp	ErrorHandler
.8911						_DCSyntax:
.8911		4c f3 ab	jmp $abf3			jmp 	SyntaxError
.8914						_DCRedefine:
.8914		a9 15		lda #$15		lda	#21
.8916		4c f7 99	jmp $99f7		jmp	ErrorHandler
.8919						_DCType:
.8919		4c fd ab	jmp $abfd			jmp 	TypeError
.891c						_DCGetSize:
.891c		a2 00		ldx #$00			ldx 	#0 						; get first index.
.891e		20 f2 a8	jsr $a8f2			jsr 	Evaluate8BitInteger 	; get array dimension
.8921		c9 00		cmp #$00			cmp 	#0 						; must be 1-254
.8923		f0 e7		beq $890c			beq 	_DCSize
.8925		c9 fe		cmp #$fe			cmp 	#254
.8927		f0 e3		beq $890c			beq 	_DCSize
.8929		60		rts				rts
.892a						ScaleByBaseType:
.892a		29 10		and #$10			and 	#NSBIsString 			; is it string
.892c		d0 19		bne $8947			bne 	_SBBTString
.892e		a5 37		lda $37				lda 	zTemp0+1 				; push value on stack
.8930		48		pha				pha
.8931		a5 36		lda $36				lda 	zTemp0
.8933		48		pha				pha
.8934		06 36		asl $36				asl 	zTemp0 					; x 2
.8936		26 37		rol $37				rol 	zTemp0+1
.8938		06 36		asl $36				asl 	zTemp0 					; x 4
.893a		26 37		rol $37				rol 	zTemp0+1
.893c		68		pla				pla 							; add stacked value = x 5
.893d		65 36		adc $36				adc 	zTemp0
.893f		85 36		sta $36				sta 	zTemp0
.8941		68		pla				pla
.8942		65 37		adc $37				adc 	zTemp0+1
.8944		85 37		sta $37				sta 	zTemp0+1
.8946		60		rts				rts
.8947						_SBBTString:
.8947		06 36		asl $36				asl 	zTemp0
.8949		26 37		rol $37				rol 	zTemp0+1
.894b		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/commands/dos.asm

.894c						BootDOS:
.894c		a9 5a		lda #$5a	            lda     #dosName & $FF
.894e		85 fb		sta $fb		            sta     kernel.args.buf+0
.8950		a9 89		lda #$89	            lda     #dosName >> 8
.8952		85 fc		sta $fc		            sta     kernel.args.buf+1
.8954		20 18 ff	jsr $ff18	            jsr     kernel.RunNamed
.8957		4c df 87	jmp $87df	            jmp 	WarmStart
>895a		44 4f 53 00			dosName:	.text 	"DOS",0

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/end.asm

.895e						EndCommand:
.895e		4c df 87	jmp $87df			jmp 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/commands/event.asm

.8961						UnaryEvent:
.8961		fa		plx				plx
.8962		20 71 98	jsr $9871			jsr 	TimerToStackX 				; timer in +0
.8965		e8		inx				inx  								; put reference into +1
.8966		20 4b a3	jsr $a34b			jsr 	EvaluateTerm
.8969		b5 50		lda $50,x			lda 	NSStatus,x 					; check if is integer reference
.896b		c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.896d		d0 4c		bne $89bb			bne 	_UEType
.896f		e8		inx				inx 								; put the step in +2
.8970		20 e6 99	jsr $99e6			jsr 	CheckComma
.8973		20 d7 a8	jsr $a8d7			jsr 	Evaluate16BitInteger
.8976		20 de 99	jsr $99de			jsr 	CheckRightBracket
.8979		ca		dex				dex
.897a		ca		dex				dex
.897b		b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy reference to zTemp0
.897d		85 36		sta $36				sta 	zTemp0
.897f		b5 61		lda $61,x			lda 	NSMantissa1+1,x
.8981		85 37		sta $37				sta 	zTemp0+1
.8983		5a		phy				phy
.8984		a0 03		ldy #$03			ldy 	#3 							; check bit 7 of last bit, the packed sign bit
.8986		b1 36		lda ($36),y			lda 	(zTemp0),y
.8988		30 2d		bmi $89b7			bmi 	_UEFalse 					; exit if signed.
.898a		a0 00		ldy #$00			ldy 	#0 							; has it timed out (24 bit)
.898c		b5 58		lda $58,x			lda 	NSMantissa0,x
.898e		d1 36		cmp ($36),y			cmp 	(zTemp0),y
.8990		c8		iny				iny
.8991		b5 60		lda $60,x			lda 	NSMantissa1,x
.8993		f1 36		sbc ($36),y			sbc		(zTemp0),y
.8995		c8		iny				iny
.8996		b5 68		lda $68,x			lda 	NSMantissa2,x
.8998		f1 36		sbc ($36),y			sbc		(zTemp0),y
.899a		90 1b		bcc $89b7			bcc 	_UEFalse 					; no, return FALSE.
.899c		18		clc				clc
.899d		a0 00		ldy #$00			ldy 	#0 							; work out new value as timer() + step
.899f		b5 58		lda $58,x			lda 	NSMantissa0,x
.89a1		75 5a		adc $5a,x			adc 	NSMantissa0+2,x
.89a3		91 36		sta ($36),y			sta 	(zTemp0),y
.89a5		c8		iny				iny
.89a6		b5 60		lda $60,x			lda 	NSMantissa1,x
.89a8		75 62		adc $62,x			adc 	NSMantissa1+2,x
.89aa		91 36		sta ($36),y			sta 	(zTemp0),y
.89ac		c8		iny				iny
.89ad		b5 68		lda $68,x			lda 	NSMantissa2,x
.89af		75 6a		adc $6a,x			adc 	NSMantissa2+2,x
.89b1		91 36		sta ($36),y			sta 	(zTemp0),y
.89b3		7a		ply				ply
.89b4		4c 6a 9a	jmp $9a6a			jmp 	ReturnTrue
.89b7						_UEFalse:
.89b7		7a		ply				ply 								; restore Y
.89b8		4c 75 9a	jmp $9a75			jmp 	ReturnFalse 				; and return False
.89bb						_UEType:
.89bb		4c fd ab	jmp $abfd			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/commands/files/bload.asm

.89be						Command_BLoad:
.89be		20 c9 89	jsr $89c9			jsr 	BLOADHandler
.89c1		c9 00		cmp #$00			cmp 	#0
.89c3		d0 01		bne $89c6			bne 	_BLError
.89c5		60		rts				rts
.89c6						_BLError:
.89c6		4c 18 8c	jmp $8c18			jmp 	CLErrorHandler
.89c9						BLOADHandler:
.89c9		a2 00		ldx #$00			ldx 	#0
.89cb		20 af a8	jsr $a8af			jsr 	EvaluateString 				; file name to load
.89ce		20 e6 99	jsr $99e6			jsr 	CheckComma 					; consume comma
.89d1		e8		inx				inx
.89d2		20 c4 a8	jsr $a8c4			jsr 	EvaluateInteger 			; load address (full physical address)
.89d5		5a		phy				phy
.89d6		a5 58		lda $58				lda 	NSMantissa0					; file name -> XA
.89d8		a6 60		ldx $60				ldx 	NSMantissa1
.89da		20 a7 83	jsr $83a7			jsr 	KNLOpenFileRead 			; open file for reading
.89dd		b0 50		bcs $8a2f			bcs 	_BLErrorExit 				; error, so fail.
.89df		8d ab 07	sta $07ab			sta 	BasicFileStream 			; save the reading stream.
.89e2		a2 01		ldx #$01			ldx 	#1 							; address is in slot # 1
.89e4		20 31 8a	jsr $8a31			jsr 	BLOpenPhysicalMemory 		; open for access.
.89e7						_BLReadFile:
.89e7		ad ab 07	lda $07ab			lda 	BasicFileStream
.89ea		a2 40		ldx #$40			ldx     #KNLReadBufferLen 			; set bytes to read.
.89ec		20 fc 83	jsr $83fc			jsr 	KNLReadBlock 				; read next block
.89ef		b0 22		bcs $8a13			bcs 	_BLFileError 				; file error, which might be EOF.
.89f1		c9 00		cmp #$00			cmp 	#0 							; read nothing.
.89f3		f0 f2		beq $89e7			beq 	_BLReadFile
.89f5		8d a9 07	sta $07a9			sta 	BLCopyCounter 				; counter.
.89f8		ac a8 07	ldy $07a8			ldy 	BLYOffset 					; copy the buffer out here
.89fb		a2 00		ldx #$00			ldx 	#0 							; offset in buffer.
.89fd						_BLCopyLoop:
.89fd		bd 9a 06	lda $069a,x			lda 	KNLReadBuffer,x 			; copy byte and advance
.8a00		91 3a		sta ($3a),y			sta 	(zTemp2),y
.8a02		c8		iny				iny
.8a03		d0 03		bne $8a08			bne 	_BLNoAdjust 				; check changed 256 byte or 8k page.
.8a05		20 59 8a	jsr $8a59			jsr 	BLAdvancePhysicalMemory
.8a08						_BLNoAdjust:
.8a08		e8		inx				inx
.8a09		ce a9 07	dec $07a9			dec 	BLCopyCounter
.8a0c		d0 ef		bne $89fd			bne 	_BLCopyLoop
.8a0e		8c a8 07	sty $07a8			sty 	BLYOffset 					; update Y offset
.8a11		80 d4		bra $89e7			bra 	_BLReadFile 				; go ask for more.
.8a13						_BLFileError:
.8a13		c9 30		cmp #$30			cmp 	#KERR_EOF 					; End of file
.8a15		d0 0d		bne $8a24			bne 	_BLErrorHandler				; no, it's an actual error
.8a17		20 53 8a	jsr $8a53			jsr 	BLClosePhysicalMemory 		; close the access.
.8a1a		ad ab 07	lda $07ab			lda 	BasicFileStream 			; close the file
.8a1d		20 71 84	jsr $8471			jsr 	KNLCloseFile
.8a20		a9 00		lda #$00			lda 	#0 							; and return zero.
.8a22		7a		ply				ply
.8a23		60		rts				rts
.8a24						_BLErrorHandler:
.8a24		48		pha				pha 								; save code
.8a25		20 53 8a	jsr $8a53			jsr 	BLClosePhysicalMemory 		; close access
.8a28		ad ab 07	lda $07ab			lda 	BasicFileStream 			; close the open file
.8a2b		20 71 84	jsr $8471			jsr 	KNLCloseFile
.8a2e		68		pla				pla 								; get error code
.8a2f						_BLErrorExit:
.8a2f		7a		ply				ply 								; restore position and exit.
.8a30		60		rts				rts
=3						BLAccessPage = 3 							; page to use for actual memory.
.8a31						BLOpenPhysicalMemory:
.8a31		a5 0b		lda $0b				lda 	BLAccessPage+8 				; save current mapping
.8a33		8d a7 07	sta $07a7			sta 	BLNormalMapping
.8a36		b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address, 13 bit adjusted for page -> (zTemp2),BLYOffset
.8a38		8d a8 07	sta $07a8			sta 	BLYOffset 					; zTemp2 0 is *always* zero.
.8a3b		64 3a		stz $3a				stz 	zTemp2
.8a3d		b5 60		lda $60,x			lda 	NSMantissa1,x
.8a3f		29 1f		and #$1f			and 	#$1F
.8a41		09 60		ora #$60			ora 	#BLAccessPage << 5
.8a43		85 3b		sta $3b				sta 	zTemp2+1
.8a45		b5 68		lda $68,x			lda 	NSMantissa2,x 				; shift M2:M1 right 3 times to give page # required
.8a47		16 60		asl $60,x			asl 	NSMantissa1,x
.8a49		2a		rol a				rol 	a
.8a4a		16 60		asl $60,x			asl 	NSMantissa1,x
.8a4c		2a		rol a				rol 	a
.8a4d		16 60		asl $60,x			asl 	NSMantissa1,x
.8a4f		2a		rol a				rol 	a
.8a50		85 0b		sta $0b				sta 	BLAccessPage+8 				; access that page
.8a52		60		rts				rts
.8a53						BLClosePhysicalMemory:
.8a53		ad a7 07	lda $07a7			lda 	BLNormalMapping
.8a56		85 0b		sta $0b				sta 	BLAccessPage+8
.8a58		60		rts				rts
.8a59						BLAdvancePhysicalMemory:
.8a59		48		pha				pha
.8a5a		e6 3b		inc $3b				inc		zTemp2+1 					; bump MSB
.8a5c		a5 3b		lda $3b				lda 	zTemp2+1
.8a5e		c9 80		cmp #$80			cmp 	#(BLAccessPage+1) << 5 		; reached next page ?
.8a60		d0 06		bne $8a68			bne 	_BLAPMExit 					; (e.g. end of the mapped page.)
.8a62		e6 0b		inc $0b				inc 	BLAccessPage+8 				; next physical page
.8a64		a9 60		lda #$60			lda 	#BLAccessPage << 5 			; page back to start of transfer page
.8a66		85 3b		sta $3b				sta 	zTemp2+1
.8a68						_BLAPMExit:
.8a68		68		pla				pla
.8a69		60		rts				rts
.07a7						BLNormalMapping:
>07a7								.fill 	1
.07a8						BLYOffset:
>07a8								.fill 	1
.07a9						BLCopyCounter:
>07a9								.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/commands/files/bsave.asm

.8a6a						Command_BSave:
.8a6a		20 75 8a	jsr $8a75			jsr 	BSaveHandler
.8a6d		c9 00		cmp #$00			cmp 	#0
.8a6f		d0 01		bne $8a72			bne 	_BSError
.8a71		60		rts				rts
.8a72						_BSError:
.8a72		4c 18 8c	jmp $8c18			jmp 	CLErrorHandler
.8a75						BSaveHandler:
.8a75		a2 00		ldx #$00			ldx 	#0
.8a77		20 af a8	jsr $a8af			jsr 	EvaluateString 				; file name to load
.8a7a		20 e6 99	jsr $99e6			jsr 	CheckComma 					; consume comma
.8a7d		e8		inx				inx
.8a7e		20 c4 a8	jsr $a8c4			jsr 	EvaluateInteger 			; load address (full physical address)
.8a81		20 e6 99	jsr $99e6			jsr 	CheckComma 					; consume comma
.8a84		e8		inx				inx
.8a85		20 c4 a8	jsr $a8c4			jsr 	EvaluateInteger 			; data length (3 bytes only)
.8a88		5a		phy				phy
.8a89		a5 58		lda $58				lda 	NSMantissa0					; file name -> XA
.8a8b		a6 60		ldx $60				ldx 	NSMantissa1
.8a8d		20 a2 83	jsr $83a2			jsr 	KNLOpenFileWrite 			; open file for reading
.8a90		b0 47		bcs $8ad9			bcs 	_BSErrorExit 				; error, so fail.
.8a92		8d ab 07	sta $07ab			sta 	BasicFileStream 			; save the reading stream.
.8a95		a2 01		ldx #$01			ldx 	#1 							; address is in slot # 1
.8a97		20 31 8a	jsr $8a31			jsr 	BLOpenPhysicalMemory 		; open for access.
.8a9a		a2 00		ldx #$00			ldx 	#0 							; number of bytes in kernel buffer
.8a9c		ac a8 07	ldy $07a8			ldy 	BLYOffset 					; used for data offset.
.8a9f						_BSWriteToFileLoop:
.8a9f		38		sec				sec 								; pre decrement count.
.8aa0		a5 5a		lda $5a				lda 	NSMantissa0+2
.8aa2		e9 01		sbc #$01			sbc 	#1
.8aa4		85 5a		sta $5a				sta 	NSMantissa0+2
.8aa6		a5 62		lda $62				lda 	NSMantissa1+2
.8aa8		e9 00		sbc #$00			sbc 	#0
.8aaa		85 62		sta $62				sta 	NSMantissa1+2
.8aac		a5 6a		lda $6a				lda 	NSMantissa2+2
.8aae		e9 00		sbc #$00			sbc 	#0
.8ab0		85 6a		sta $6a				sta 	NSMantissa2+2
.8ab2		30 15		bmi $8ac9			bmi 	_BSFileComplete 			; undercounted, so exit.
.8ab4		b1 3a		lda ($3a),y			lda 	(zTemp2),y 					; get byte to save
.8ab6		9d 9a 06	sta $069a,x			sta 	KNLReadBuffer,x 			; save in the buffer and bump buffer index
.8ab9		e8		inx				inx
.8aba		c8		iny				iny 								; next byte
.8abb		d0 03		bne $8ac0			bne 	_BSNoCheck
.8abd		20 59 8a	jsr $8a59			jsr 	BLAdvancePhysicalMemory 	; check not gone to next page.
.8ac0						_BSNoCheck:
.8ac0		e0 40		cpx #$40			cpx 	#KNLReadBufferLen 			; done the whole buffer
.8ac2		d0 db		bne $8a9f			bne 	_BSWriteToFileLoop 			; no , do the next byte.
.8ac4		20 db 8a	jsr $8adb			jsr 	BSFlushBuffer 				; yes, flush the buffer
.8ac7		80 d6		bra $8a9f			bra 	_BSWriteToFileLoop 			; and keep on going
.8ac9						_BSFileComplete:
.8ac9		20 db 8a	jsr $8adb			jsr 	BSFlushBuffer 				; write the buffer remainder.
.8acc		20 53 8a	jsr $8a53			jsr 	BLClosePhysicalMemory 		; close the access.
.8acf		ad ab 07	lda $07ab			lda 	BasicFileStream 			; close the file
.8ad2		20 71 84	jsr $8471			jsr 	KNLCloseFile
.8ad5		a9 00		lda #$00			lda 	#0
.8ad7		7a		ply				ply
.8ad8		60		rts				rts
.8ad9						_BSErrorExit:
.8ad9		7a		ply				ply
.8ada		60		rts				rts
.8adb						BSFlushBuffer:
.8adb		e0 00		cpx #$00			cpx 	#0 							; buffer empty ?
.8add		f0 0d		beq $8aec			beq 	_BSFBExit 					; if so, exit.
.8adf		a9 9a		lda #$9a			lda 	#KNLReadBuffer & $FF 		; where to write from.
.8ae1		85 36		sta $36				sta 	zTemp0
.8ae3		a9 06		lda #$06			lda 	#KNLReadBuffer >> 8
.8ae5		85 37		sta $37				sta 	zTemp0+1 					; # of bytes in X
.8ae7		20 d4 8c	jsr $8cd4			jsr 	CLWriteByteBlock 			; write it.
.8aea		a2 00		ldx #$00			ldx 	#0 							; buffer is empty.
.8aec						_BSFBExit:
.8aec		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/commands/files/dir.asm

.8aed						Command_Dir:
.8aed		ad 9a 07	lda $079a			lda     KNLDefaultDrive				; set drive to list.
.8af0		85 f3		sta $f3				sta     kernel.args.directory.open.drive
.8af2		64 fd		stz $fd				stz     kernel.args.directory.open.path_len
.8af4		20 74 ff	jsr $ff74			jsr     kernel.Directory.Open
.8af7		b0 4f		bcs $8b48			bcs     _CDExit
.8af9						_CDEventLoop:
.8af9		20 0c ff	jsr $ff0c			jsr     kernel.Yield        		; Polite, not actually needed.
.8afc		20 5e 82	jsr $825e			jsr     GetNextEvent
.8aff		b0 f8		bcs $8af9			bcs     _CDEventLoop
.8b01		ad 9b 07	lda $079b			lda     KNLEvent.type
.8b04		c9 44		cmp #$44			cmp     #kernel.event.directory.CLOSED
.8b06		f0 40		beq $8b48			beq    	_CDExit
.8b08		20 0d 8b	jsr $8b0d			jsr     _CDMessages 				; handle various messages
.8b0b		80 ec		bra $8af9			bra     _CDEventLoop
.8b0d						_CDMessages:
.8b0d		c9 3a		cmp #$3a			cmp     #kernel.event.directory.OPENED
.8b0f		f0 15		beq $8b26			beq     _CDEVRead
.8b11		c9 3c		cmp #$3c			cmp     #kernel.event.directory.VOLUME
.8b13		f0 19		beq $8b2e			beq     _CDEVVolume
.8b15		c9 3e		cmp #$3e			cmp     #kernel.event.directory.FILE
.8b17		f0 32		beq $8b4b			beq     _CDEVFile
.8b19		c9 40		cmp #$40			cmp     #kernel.event.directory.FREE
.8b1b		f0 70		beq $8b8d			beq     _CDEVFree
.8b1d		c9 42		cmp #$42			cmp     #kernel.event.directory.EOF
.8b1f		f0 6e		beq $8b8f			beq     _CDEVEOF
.8b21		c9 46		cmp #$46			cmp     #kernel.event.directory.ERROR
.8b23		f0 6a		beq $8b8f			beq     _CDEVEOF
.8b25		60		rts				rts
.8b26						_CDEVRead:
.8b26		ad 9e 07	lda $079e			lda     KNLEvent.directory.stream
.8b29		85 f3		sta $f3				sta     kernel.args.directory.read.stream
.8b2b		4c 78 ff	jmp $ff78			jmp     kernel.Directory.Read
.8b2e						_CDEVVolume:
.8b2e		a9 5b		lda #$5b			lda 	#"["
.8b30		20 43 80	jsr $8043			jsr 	EXTPrintCharacter
.8b33		ad a0 07	lda $07a0			lda     KNLEvent.directory.volume.len
.8b36		20 97 8b	jsr $8b97			jsr     _CDReadData
.8b39		20 56 9a	jsr $9a56			jsr 	PrintStringXA
.8b3c		a9 5d		lda #$5d			lda 	#"]"
.8b3e		20 43 80	jsr $8043			jsr 	EXTPrintCharacter
.8b41		a9 0d		lda #$0d			lda 	#13
.8b43		20 43 80	jsr $8043			jsr 	EXTPrintCharacter
.8b46		80 de		bra $8b26			bra     _CDEVRead
.8b48						_CDExit:
.8b48		4c df 87	jmp $87df			jmp 	WarmStart
.8b4b						_CDEVFile:
.8b4b		a9 20		lda #$20			lda 	#32
.8b4d		20 43 80	jsr $8043			jsr 	EXTPrintCharacter
.8b50		ad a0 07	lda $07a0			lda     KNLEvent.directory.file.len
.8b53		48		pha				pha
.8b54		20 97 8b	jsr $8b97			jsr     _CDReadData
.8b57		20 56 9a	jsr $9a56			jsr 	PrintStringXA
.8b5a		68		pla				pla
.8b5b		49 ff		eor #$ff			eor 	#$FF
.8b5d		38		sec				sec
.8b5e		69 10		adc #$10			adc 	#16
.8b60		aa		tax				tax
.8b61						_CDEVTab:
.8b61		a9 20		lda #$20			lda 	#32
.8b63		20 43 80	jsr $8043			jsr 	EXTPrintCharacter
.8b66		ca		dex				dex
.8b67		10 f8		bpl $8b61			bpl 	_CDEVTab
.8b69		20 ae 8b	jsr $8bae			jsr 	_CDReadExtended
.8b6c		ad 26 05	lda $0526			lda 	lineBuffer
.8b6f		ae 27 05	ldx $0527			ldx 	lineBuffer+1
.8b72		20 6c 9e	jsr $9e6c			jsr 	ConvertInt16
.8b75		20 56 9a	jsr $9a56			jsr 	PrintStringXA
.8b78		a2 8b		ldx #$8b			ldx 	#_CDEVFMessage >> 8
.8b7a		a9 81		lda #$81			lda 	#_CDEVFMessage & $FF
.8b7c		20 56 9a	jsr $9a56			jsr 	PrintStringXA
.8b7f		80 a5		bra $8b26			bra     _CDEVRead
.8b81						_CDEVFMessage:
>8b81		20 62 6c 6f 63 6b 28 73				.text 	" block(s).",13,0
>8b89		29 2e 0d 00
.8b8d						_CDEVFree:
.8b8d		80 00		bra $8b8f			bra     _CDEVEOF
.8b8f						_CDEVEOF:
.8b8f		ad 9e 07	lda $079e			lda     KNLEvent.directory.stream
.8b92		85 f3		sta $f3				sta     kernel.args.directory.close.stream
.8b94		4c 7c ff	jmp $ff7c			jmp     kernel.Directory.Close
.8b97						_CDReadData:
.8b97		85 fd		sta $fd				sta     kernel.args.recv.buflen
.8b99		a9 26		lda #$26			lda     #lineBuffer & $FF
.8b9b		85 fb		sta $fb				sta     kernel.args.recv.buf+0
.8b9d		a9 05		lda #$05			lda     #lineBuffer >> 8
.8b9f		85 fc		sta $fc				sta     kernel.args.recv.buf+1
.8ba1		20 04 ff	jsr $ff04			jsr     kernel.ReadData
.8ba4		a6 fd		ldx $fd				ldx     kernel.args.recv.buflen
.8ba6		9e 26 05	stz $0526,x			stz     lineBuffer,x
.8ba9		a9 26		lda #$26			lda 	#lineBuffer & $FF
.8bab		a2 05		ldx #$05			ldx 	#lineBuffer >> 8
.8bad		60		rts				rts
.8bae						_CDReadExtended:
.8bae		a9 02		lda #$02			lda     #2
.8bb0		85 fd		sta $fd				sta     kernel.args.recv.buflen
.8bb2		a9 26		lda #$26			lda     #lineBuffer & $FF
.8bb4		85 fb		sta $fb				sta     kernel.args.recv.buf+0
.8bb6		a9 05		lda #$05			lda     #lineBuffer >> 8
.8bb8		85 fc		sta $fc				sta     kernel.args.recv.buf+1
.8bba		4c 08 ff	jmp $ff08			jmp     kernel.ReadExt

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/commands/files/drive.asm

.8bbd						Command_Drive:
.8bbd		20 f2 a8	jsr $a8f2			jsr 	Evaluate8BitInteger
.8bc0		20 9e 83	jsr $839e			jsr 	KNLSetDrive
.8bc3		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/commands/files/load.asm

.8bc4						Command_Load:
.8bc4		20 ca 8b	jsr $8bca			jsr 	LoadFile
.8bc7		4c df 87	jmp $87df			jmp 	WarmStart
.8bca						LoadFile:
.8bca		20 af a8	jsr $a8af			jsr 	EvaluateString 				; file name to load
.8bcd		a6 37		ldx $37				ldx 	zTemp0+1					; zTemp0 -> XA
.8bcf		a5 36		lda $36				lda 	zTemp0
.8bd1		20 a7 83	jsr $83a7			jsr 	KNLOpenFileRead 			; open file for reading
.8bd4		b0 42		bcs $8c18			bcs 	CLErrorHandler 				; error, so fail.
.8bd6		8d ab 07	sta $07ab			sta 	BasicFileStream 			; save the reading stream.
.8bd9		20 68 8c	jsr $8c68			jsr     LoadReadByteInit            ; Init reader with the stream
.8bdc		20 bf 93	jsr $93bf			jsr 	NewProgram 					; does the actual NEW.
.8bdf		9c aa 07	stz $07aa			stz 	LoadEOFFlag 				; clear EOF Flag.
.8be2						_CLLoop:
.8be2		20 26 8c	jsr $8c26			jsr 	LoadReadLine 				; get next line.
.8be5		f0 10		beq $8bf7			beq 	_CLExit 					; end, exit.
.8be7		20 89 80	jsr $8089			jsr 	TKTokeniseLine 				; tokenise the line.
.8bea		ad 27 04	lda $0427			lda 	tokenLineNumber 			; line number = 0
.8bed		0d 28 04	ora $0428			ora 	tokenLineNumber+1
.8bf0		f0 f0		beq $8be2			beq 	_CLLoop 					; not legal code, blank line or maybe a comment.
.8bf2		20 ba 87	jsr $87ba			jsr 	EditProgramCode 			; do the editing etc.
.8bf5		80 eb		bra $8be2			bra 	_CLLoop
.8bf7						_CLExit:
.8bf7		ad ab 07	lda $07ab			lda 	BasicFileStream
.8bfa		20 71 84	jsr $8471			jsr 	KNLCloseFile
.8bfd						CLComplete:
.8bfd		a9 05		lda #$05			lda 	#_CLCMsg & $FF
.8bff		a2 8c		ldx #$8c			ldx 	#_CLCMsg >> 8
.8c01		20 56 9a	jsr $9a56			jsr 	PrintStringXA
.8c04		60		rts				rts
.8c05						_CLCMsg:
>8c05		43 6f 6d 70 6c 65 74 65				.text 	"Complete.",13,0
>8c0d		2e 0d 00
.8c10						CLCloseError:
.8c10		48		pha				pha
.8c11		ad ab 07	lda $07ab			lda 	BasicFileStream
.8c14		20 71 84	jsr $8471			jsr 	KNLCloseFile
.8c17		68		pla				pla
.8c18						CLErrorHandler:
.8c18		c9 28		cmp #$28			cmp 	#KERR_NOTFOUND
.8c1a		f0 05		beq $8c21			beq 	_CLEHNotFound
.8c1c		a9 1a		lda #$1a		lda	#26
.8c1e		4c f7 99	jmp $99f7		jmp	ErrorHandler
.8c21						_CLEHNotFound:
.8c21		a9 19		lda #$19		lda	#25
.8c23		4c f7 99	jmp $99f7		jmp	ErrorHandler
.8c26						LoadReadLine:
.8c26		a2 00		ldx #$00			ldx 	#0 							; look for first character non space/ctl
.8c28		20 42 8c	jsr $8c42			jsr 	LoadReadCharacter
.8c2b		f0 14		beq $8c41			beq 	_LRLExit 					; eof ?
.8c2d		c9 21		cmp #$21			cmp 	#' '+1 						; space control tab skip
.8c2f		90 f5		bcc $8c26			bcc 	LoadReadLine
.8c31						_LRLLoop:
.8c31		9d 26 05	sta $0526,x			sta 	lineBuffer,x 				; write into line buffer
.8c34		9e 27 05	stz $0527,x			stz 	lineBuffer+1,x 				; make ASCIIZ
.8c37		e8		inx				inx
.8c38		20 42 8c	jsr $8c42			jsr 	LoadReadCharacter 			; next line
.8c3b		c9 20		cmp #$20			cmp 	#32 						; until < space ctrl/eof.
.8c3d		b0 f2		bcs $8c31			bcs 	_LRLLoop
.8c3f		a9 01		lda #$01			lda 	#1 							; return code 1, okay.
.8c41						_LRLExit:
.8c41		60		rts				rts
.8c42						LoadReadCharacter:
.8c42		da		phx				phx
.8c43		5a		phy				phy
.8c44		ad aa 07	lda $07aa			lda 	LoadEOFFlag 				; already done EOF.
.8c47		d0 0c		bne $8c55			bne 	_LRCIsEOF
.8c49		20 72 8c	jsr $8c72			jsr 	LoadReadByte 				; read a byte
.8c4c		90 09		bcc $8c57			bcc		_LRCExit 					; read okay.
.8c4e		c9 30		cmp #$30			cmp 	#KERR_EOF 					; if error not EOF it's an actual error.
.8c50		d0 be		bne $8c10			bne 	CLCloseError
.8c52		ce aa 07	dec $07aa			dec 	LoadEOFFlag
.8c55						_LRCIsEOF:
.8c55		a9 00		lda #$00			lda 	#0
.8c57						_LRCExit:
.8c57		c9 09		cmp #$09			cmp 	#9 							; convert tab to space
.8c59		d0 02		bne $8c5d			bne 	_LRCNotTab
.8c5b		a9 20		lda #$20			lda 	#' '
.8c5d						_LRCNotTab:
.8c5d		c9 0a		cmp #$0a			cmp 	#$0A
.8c5f		d0 02		bne $8c63			bne 	_LRCNotLF
.8c61		a9 0d		lda #$0d			lda 	#$0D
.8c63						_LRCNotLF:
.8c63		7a		ply				ply
.8c64		fa		plx				plx
.8c65		c9 00		cmp #$00			cmp 	#0 							; set Z flag if EOF.
.8c67		60		rts				rts
.8c68						LoadReadByteInit:
.8c68		8d ac 07	sta $07ac			sta     LoadFileStream 				; save stream
.8c6b		9c ad 07	stz $07ad			stz     LoadNextCharacter 			; reset buffer
.8c6e		9c ae 07	stz $07ae			stz     LoadEndCharacter
.8c71		60		rts				rts
.8c72						LoadReadByte:
.8c72		da		phx				phx
.8c73		ae ad 07	ldx $07ad			ldx     LoadNextCharacter 					; all data consumed ?
.8c76		ec ae 07	cpx $07ae			cpx     LoadEndCharacter
.8c79		d0 12		bne $8c8d			bne     _KNLRBGetNextByte
.8c7b		ad ac 07	lda $07ac			lda     LoadFileStream
.8c7e		a2 40		ldx #$40			ldx     #KNLReadBufferLen 			; set bytes to read.
.8c80		20 fc 83	jsr $83fc			jsr     KNLReadBlock 				; read next chunk from the stream
.8c83		b0 0f		bcs $8c94			bcs     _KNLRBError 				; error has occurred on read.
.8c85		8d ae 07	sta $07ae			sta     LoadEndCharacter 						; # read is the number available
.8c88		a2 00		ldx #$00			ldx     #0 							; reset the read pointer.
.8c8a		8e ad 07	stx $07ad			stx     LoadNextCharacter
.8c8d						_KNLRBGetNextByte:
.8c8d		bd 9a 06	lda $069a,x			lda     KNLReadBuffer,x 			; get the next data item
.8c90		ee ad 07	inc $07ad			inc     LoadNextCharacter 					; and advance the index
.8c93		18		clc				clc 								; succeeded
.8c94						_KNLRBError:
.8c94		fa		plx				plx
.8c95		60		rts				rts
.07aa						LoadEOFFlag:
>07aa								.fill 	1
.07ab						BasicFileStream:
>07ab								.fill 	1
.07ac						LoadFileStream:
>07ac								.byte   ?
.07ad						LoadNextCharacter:
>07ad								.byte   ?
.07ae						LoadEndCharacter:
>07ae								.byte   ?

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/commands/files/save.asm

.8c96						Command_Save:
.8c96		20 af a8	jsr $a8af			jsr 	EvaluateString 				; file name to load
.8c99		a6 37		ldx $37				ldx 	zTemp0+1					; zTemp0 -> XA
.8c9b		a5 36		lda $36				lda 	zTemp0
.8c9d		20 a2 83	jsr $83a2			jsr 	KNLOpenFileWrite 			; open file for writing
.8ca0		b0 2f		bcs $8cd1			bcs 	CSErrorHandler 				; error, so fail.
.8ca2		8d ab 07	sta $07ab			sta 	BasicFileStream 			; save the reading stream.
.8ca5		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8ca7		85 30		sta $30				sta 	codePtr
.8ca9		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8cab		85 31		sta $31				sta 	codePtr+1
.8cad						_CSLoop:
.8cad		b2 30		lda ($30)			lda 	(codePtr)
.8caf		f0 17		beq $8cc8			beq 	_CSExit
.8cb1		20 f5 8c	jsr $8cf5			jsr 	CSGetCleanLine
.8cb4		84 37		sty $37				sty 	zTemp0+1 					; save write address of data
.8cb6		85 36		sta $36				sta 	zTemp0
.8cb8		20 d4 8c	jsr $8cd4			jsr 	CLWriteByteBlock 			; write the block out.
.8cbb		18		clc				clc
.8cbc		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8cbe		65 30		adc $30				adc 	codePtr
.8cc0		85 30		sta $30				sta 	codePtr
.8cc2		90 02		bcc $8cc6			bcc 	_CREExit
.8cc4		e6 31		inc $31				inc 	codePtr+1 					; carry
.8cc6						_CREExit:
.8cc6		80 e5		bra $8cad			bra 	_CSLoop
.8cc8						_CSExit:
.8cc8		ad ab 07	lda $07ab			lda 	BasicFileStream 			; close file
.8ccb		20 71 84	jsr $8471			jsr 	KNLCloseFile
.8cce		4c fd 8b	jmp $8bfd			jmp 	CLComplete 					; display complete message.
.8cd1						CSErrorHandler:
.8cd1		4c 18 8c	jmp $8c18			jmp 	CLErrorHandler
.8cd4						CLWriteByteBlock:
.8cd4		e0 00		cpx #$00			cpx 	#0 							; written the lot ?
.8cd6		f0 1c		beq $8cf4			beq 	_CLWBBExit					; if so, exit
.8cd8		ad ab 07	lda $07ab			lda 	BasicFileStream 			; stream to write, count in X
.8cdb		20 37 84	jsr $8437			jsr 	KNLWriteBlock 				; call one write attempt
.8cde		b0 f1		bcs $8cd1			bcs 	CSErrorHandler 				; error occurred
.8ce0		85 38		sta $38				sta 	zTemp1 						; save bytes written.
.8ce2		8a		txa				txa 								; subtract bytes written from X, total count.
.8ce3		38		sec				sec
.8ce4		e5 38		sbc $38				sbc 	zTemp1
.8ce6		aa		tax				tax
.8ce7		18		clc				clc 								; advance zTemp0 pointer by bytes written.
.8ce8		a5 36		lda $36				lda 	zTemp0
.8cea		65 38		adc $38				adc 	zTemp1
.8cec		85 36		sta $36				sta 	zTemp0
.8cee		90 e4		bcc $8cd4			bcc 	CLWriteByteBlock
.8cf0		e6 37		inc $37				inc 	zTemp0+1
.8cf2		80 e0		bra $8cd4			bra 	CLWriteByteBlock 			; and retry write out.
.8cf4						_CLWBBExit:
.8cf4		60		rts				rts
.8cf5						CSGetCleanLine:
.8cf5		a9 00		lda #$00			lda 	#0 							; no indent.
.8cf7		20 7f 80	jsr $807f			jsr 	TKListConvertLine 			; convert line into token Buffer
.8cfa		a2 00		ldx #$00			ldx 	#0 							; copy stripping controls.
.8cfc		a0 00		ldy #$00			ldy 	#0
.8cfe						_CSClean:
.8cfe		b9 29 04	lda $0429,y			lda 	tokenBuffer,y
.8d01		f0 09		beq $8d0c			beq 	_CSDoneClean
.8d03		30 04		bmi $8d09			bmi 	_CSIgnoreCharacter
.8d05		9d 26 05	sta $0526,x			sta 	lineBuffer,x
.8d08		e8		inx				inx
.8d09						_CSIgnoreCharacter:
.8d09		c8		iny				iny
.8d0a		80 f2		bra $8cfe			bra 	_CSClean
.8d0c						_CSDoneClean:
.8d0c		a9 0d		lda #$0d			lda 	#13 						; add CR, length now in X and ASCIIZ.
.8d0e		9d 26 05	sta $0526,x			sta 	lineBuffer,x
.8d11		e8		inx				inx
.8d12		9e 26 05	stz $0526,x			stz 	lineBuffer,x
.8d15		a0 05		ldy #$05			ldy 	#(lineBuffer >> 8) 			; line address in YA
.8d17		a9 26		lda #$26			lda 	#(lineBuffer & $FF)
.8d19		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/commands/files/verify.asm

.e7fa						m
.8d1a						Command_VERIFY:
.8d1a		20 af a8	jsr $a8af			jsr 	EvaluateString 				; file name to verify
.8d1d		a6 37		ldx $37				ldx 	zTemp0+1					; zTemp0 -> XA
.8d1f		a5 36		lda $36				lda 	zTemp0
.8d21		20 a7 83	jsr $83a7			jsr 	KNLOpenFileRead 			; open file for reading
.8d24		b0 4b		bcs $8d71			bcs 	_CVErrorHandler 			; error, so fail.
.8d26		8d ab 07	sta $07ab			sta 	BasicFileStream 			; save the reading stream.
.8d29		20 68 8c	jsr $8c68			jsr     LoadReadByteInit            ; Init reader with the stream
.8d2c		9c aa 07	stz $07aa			stz 	LoadEOFFlag 				; clear EOF Flag.
.8d2f		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8d31		85 30		sta $30				sta 	codePtr
.8d33		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8d35		85 31		sta $31				sta 	codePtr+1
.8d37						_CVLoop:
.8d37		20 26 8c	jsr $8c26			jsr 	LoadReadLine 				; get next line.
.8d3a		f0 27		beq $8d63			beq 	_CVExit 					; end, exit.
.8d3c		20 89 80	jsr $8089			jsr 	TKTokeniseLine 				; tokenise the line.
.8d3f		ad 27 04	lda $0427			lda 	tokenLineNumber 			; line number = 0
.8d42		0d 28 04	ora $0428			ora 	tokenLineNumber+1
.8d45		f0 f0		beq $8d37			beq 	_CVLoop 					; not legal code, blank line or maybe a comment.
.8d47		a0 00		ldy #$00			ldy 	#0 							; start compare
.8d49						_CVCompareLoop:
.8d49		b1 30		lda ($30),y			lda 	(codePtr),y
.8d4b		d9 26 04	cmp $0426,y			cmp 	tokenOffset,y 				; compare against actual code.
.8d4e		d0 1c		bne $8d6c			bne 	_CVCompareError
.8d50		c8		iny				iny
.8d51		cc 26 04	cpy $0426			cpy 	tokenOffset 				; until done whole line of code
.8d54		d0 f3		bne $8d49			bne 	_CVCompareLoop
.8d56		18		clc				clc
.8d57		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8d59		65 30		adc $30				adc 	codePtr
.8d5b		85 30		sta $30				sta 	codePtr
.8d5d		90 02		bcc $8d61			bcc 	_CREExit
.8d5f		e6 31		inc $31				inc 	codePtr+1 					; carry
.8d61						_CREExit:
.8d61		80 d4		bra $8d37			bra 	_CVLoop
.8d63						_CVExit:
.8d63		ad ab 07	lda $07ab			lda 	BasicFileStream
.8d66		20 71 84	jsr $8471			jsr 	KNLCloseFile
.8d69		4c fd 8b	jmp $8bfd			jmp 	CLComplete
.8d6c						_CVCompareError:
.8d6c		a9 1b		lda #$1b		lda	#27
.8d6e		4c f7 99	jmp $99f7		jmp	ErrorHandler
.8d71						_CVErrorHandler:
.8d71		4c 18 8c	jmp $8c18			jmp 	CLErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/for.asm

.8d74						ForCommand:
.8d74		a9 d9		lda #$d9			lda 	#STK_FOR+9 					; allocate 18 bytes on the return stack (see above).
.8d76		20 6d b2	jsr $b26d			jsr 	StackOpen
.8d79		a2 00		ldx #$00			ldx 	#0
.8d7b		20 4b a3	jsr $a34b			jsr 	EvaluateTerm
.8d7e		b5 50		lda $50,x			lda 	NSStatus,x
.8d80		c9 20		cmp #$20			cmp 	#NSBIsReference+NSTInteger 	; do we have an integer 4 byte reference.
.8d82		d0 47		bne $8dcb			bne		_FCError
.8d84		a9 3d		lda #$3d			lda 	#KWD_EQUAL 					; =
.8d86		20 ee 99	jsr $99ee			jsr 	CheckNextA
.8d89		e8		inx				inx
.8d8a		20 c4 a8	jsr $a8c4			jsr 	EvaluateInteger 			; <from> in +1
.8d8d		b1 30		lda ($30),y			lda 	(codePtr),y
.8d8f		c8		iny				iny 								; consume it
.8d90		48		pha				pha 								; save on stack for later
.8d91		c9 c1		cmp #$c1			cmp 	#KWD_DOWNTO
.8d93		f0 04		beq $8d99			beq 	_FCNoSyntax
.8d95		c9 db		cmp #$db			cmp 	#KWD_TO
.8d97		d0 35		bne $8dce			bne 	_FCSyntaxError
.8d99						_FCNoSyntax:
.8d99		e8		inx				inx
.8d9a		20 c4 a8	jsr $a8c4			jsr 	EvaluateInteger
.8d9d		20 b2 b2	jsr $b2b2			jsr 	STKSaveCodePosition 		; save loop back position
.8da0		68		pla				pla 								; restore DOWNTO or TO
.8da1		5a		phy				phy 								; save Y on the stack
.8da2		49 c1		eor #$c1			eor 	#KWD_DOWNTO 				; 0 if DOWNTO, #0 if TO
.8da4		f0 02		beq $8da8			beq 	_FCNotDownTo
.8da6		a9 02		lda #$02			lda 	#2
.8da8						_FCNotDownTo:
.8da8		3a		dec a				dec 	a 							; 255 if DOWNTO, 1 if TO
.8da9		a0 10		ldy #$10			ldy 	#16
.8dab		91 34		sta ($34),y			sta 	(basicStack),y 				; copy that out to the Basic Stack.
.8dad		a0 06		ldy #$06			ldy 	#6 							; this is the address of the loop variable.
.8daf		a5 58		lda $58				lda 	NSMantissa0
.8db1		91 34		sta ($34),y			sta 	(basicStack),y
.8db3		a5 60		lda $60				lda 	NSMantissa1
.8db5		c8		iny				iny
.8db6		91 34		sta ($34),y			sta 	(basicStack),y
.8db8		a0 08		ldy #$08			ldy 	#8 							; set initial index value
.8dba		a2 01		ldx #$01			ldx 	#1
.8dbc		20 d1 8d	jsr $8dd1			jsr 	FCIntegerToStack
.8dbf		a0 0c		ldy #$0c			ldy 	#12 						; set the terminal value
.8dc1		a2 02		ldx #$02			ldx 	#2
.8dc3		20 d1 8d	jsr $8dd1			jsr 	FCIntegerToStack
.8dc6		20 ec 8d	jsr $8dec			jsr 	CopyIndexToReference
.8dc9		7a		ply				ply 								; restore position
.8dca		60		rts				rts
.8dcb						_FCError:
.8dcb		4c fd ab	jmp $abfd			jmp 	TypeError
.8dce						_FCSyntaxError:
.8dce		4c f3 ab	jmp $abf3			jmp 	SyntaxError
.8dd1						FCIntegerToStack:
.8dd1		34 50		bit $50,x			bit 	NSStatus,x 					; is the value negative
.8dd3		10 03		bpl $8dd8			bpl	 	_FCNotNegative
.8dd5		20 20 a9	jsr $a920			jsr 	NSMNegateMantissa 			; if so 2's complement the mantissa
.8dd8						_FCNotNegative:
.8dd8		b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy out to the basic stack
.8dda		91 34		sta ($34),y			sta 	(basicStack),y
.8ddc		c8		iny				iny
.8ddd		b5 60		lda $60,x			lda 	NSMantissa1,x
.8ddf		91 34		sta ($34),y			sta 	(basicStack),y
.8de1		c8		iny				iny
.8de2		b5 68		lda $68,x			lda 	NSMantissa2,x
.8de4		91 34		sta ($34),y			sta 	(basicStack),y
.8de6		c8		iny				iny
.8de7		b5 70		lda $70,x			lda 	NSMantissa3,x
.8de9		91 34		sta ($34),y			sta 	(basicStack),y
.8deb		60		rts				rts
.8dec						CopyIndexToReference:
.8dec		5a		phy				phy
.8ded		a0 06		ldy #$06			ldy 	#6 							; copy address-8 to write to zTemp0
.8def		38		sec				sec 								; (because we copy from offset 8)
.8df0		b1 34		lda ($34),y			lda 	(basicStack),y
.8df2		e9 08		sbc #$08			sbc 	#8
.8df4		85 36		sta $36				sta 	zTemp0
.8df6		c8		iny				iny
.8df7		b1 34		lda ($34),y			lda 	(basicStack),y
.8df9		e9 00		sbc #$00			sbc 	#0
.8dfb		85 37		sta $37				sta 	zTemp0+1
.8dfd		a2 04		ldx #$04			ldx 	#4 							; this is the copy counter/
.8dff		a0 0b		ldy #$0b			ldy 	#8+3 		 				; the MSB of the mantissa
.8e01		b1 34		lda ($34),y			lda 	(basicStack),y
.8e03		0a		asl a				asl 	a 							; into carry
.8e04		a0 08		ldy #$08			ldy 	#8 							; where to copy from.
.8e06		90 14		bcc $8e1c			bcc 	_CITRNormal
.8e08		38		sec				sec
.8e09						_CITRNegative:
.8e09		a9 00		lda #$00			lda 	#0
.8e0b		f1 34		sbc ($34),y			sbc 	(basicStack),y
.8e0d		91 36		sta ($36),y			sta 	(zTemp0),y
.8e0f		c8		iny				iny
.8e10		ca		dex				dex
.8e11		d0 f6		bne $8e09			bne 	_CITRNegative
.8e13		88		dey				dey 								; look at MSB of mantissa
.8e14		b1 36		lda ($36),y			lda 	(zTemp0),y 					; set the MSB as negative packed.
.8e16		09 80		ora #$80			ora 	#$80
.8e18		91 36		sta ($36),y			sta 	(zTemp0),y
.8e1a		7a		ply				ply
.8e1b		60		rts				rts
.8e1c						_CITRNormal:
.8e1c		b1 34		lda ($34),y			lda 	(basicStack),y 				; copy without negation.
.8e1e		91 36		sta ($36),y			sta 	(zTemp0),y
.8e20		c8		iny				iny
.8e21		ca		dex				dex
.8e22		d0 f8		bne $8e1c			bne 	_CITRNormal
.8e24		7a		ply				ply 								; and exit.
.8e25		60		rts				rts
.8e26						NextCommand:
.8e26		a9 d9		lda #$d9			lda 	#STK_FOR+9 					; check FOR is TOS
.8e28		a2 11		ldx #$11			ldx 	#ERRID_FOR 					; this error
.8e2a		20 9a b2	jsr $b29a			jsr 	StackCheckFrame
.8e2d		5a		phy				phy
.8e2e		a0 10		ldy #$10			ldy 	#16 						; get the step count
.8e30		b1 34		lda ($34),y			lda 	(basicStack),y
.8e32		85 36		sta $36				sta 	zTemp0 						; this is the sign extend
.8e34		30 02		bmi $8e38			bmi 	_NCStepNeg
.8e36		64 36		stz $36				stz 	zTemp0 						; which is 0 or 255
.8e38						_NCStepNeg:
.8e38		a0 08		ldy #$08			ldy 	#8 							; offset to bump
.8e3a		a2 04		ldx #$04			ldx 	#4 							; count to bump
.8e3c		18		clc				clc
.8e3d						_NCBump:
.8e3d		71 34		adc ($34),y			adc 	(basicStack),y 				; add it
.8e3f		91 34		sta ($34),y			sta 	(basicStack),y
.8e41		a5 36		lda $36				lda 	zTemp0 						; get sign extend for next time.
.8e43		c8		iny				iny 								; next byte
.8e44		ca		dex				dex 								; do four times
.8e45		d0 f6		bne $8e3d			bne 	_NCBump
.8e47		20 ec 8d	jsr $8dec			jsr		CopyIndexToReference		; copy it to the reference variable.
.8e4a		a0 10		ldy #$10			ldy 	#16 						; get step count again
.8e4c		b1 34		lda ($34),y			lda 	(basicStack),y
.8e4e		0a		asl a				asl 	a 							; sign bit to carry
.8e4f		a9 0c		lda #$0c			lda 	#12 						; offset of LHS = terminal offset
.8e51		85 38		sta $38				sta 	zTemp1
.8e53		90 02		bcc $8e57			bcc 	_NCCompRev 					; use if step is +ve
.8e55		a9 08		lda #$08			lda 	#8 							; now the LHS = index value
.8e57						_NCCompRev:
.8e57		85 38		sta $38				sta 	zTemp1 						; so zTemp0 is the index for LHS
.8e59		49 04		eor #$04			eor 	#(8^12) 					; and zTemp0+1 is the index for RHS
.8e5b		85 39		sta $39				sta 	zTemp1+1
.8e5d		a2 04		ldx #$04			ldx 	#4 							; bytes to compare
.8e5f		38		sec				sec
.8e60						_NCCompare:
.8e60		a4 38		ldy $38				ldy 	zTemp1 						; do compare using the two indices
.8e62		b1 34		lda ($34),y			lda 	(basicStack),y
.8e64		a4 39		ldy $39				ldy 	zTemp1+1
.8e66		f1 34		sbc ($34),y			sbc 	(basicStack),y
.8e68		e6 38		inc $38				inc 	zTemp1 						; bump the indices (inc,dex do not change C or V)
.8e6a		e6 39		inc $39				inc 	zTemp1+1
.8e6c		ca		dex				dex 								; do it 4 times.
.8e6d		d0 f1		bne $8e60			bne 	_NCCompare
.8e6f		50 02		bvc $8e73			bvc 	_NCNoOverflow 				; convert to signed comparison
.8e71		49 80		eor #$80			eor 	#$80
.8e73						_NCNoOverflow:
.8e73		7a		ply				ply 								; restore Y position
.8e74		0a		asl a				asl 	a 							; is bit 7 set.
.8e75		90 04		bcc $8e7b			bcc 	_NCLoopBack 				; if no , >= so loop back
.8e77		20 8c b2	jsr $b28c			jsr 	StackClose 					; exit the loop
.8e7a		60		rts				rts
.8e7b						_NCLoopBack:
.8e7b		20 c3 b2	jsr $b2c3			jsr 	STKLoadCodePosition 		; loop back
.8e7e		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/gosub.asm

.8e7f						Command_GOSUB:
.8e7f		a2 00		ldx #$00			ldx 	#0
.8e81		20 d7 a8	jsr $a8d7			jsr 	Evaluate16BitInteger 		; line number in Stack.0
.8e84		a9 e3		lda #$e3			lda 	#STK_GOSUB+3
.8e86		20 6d b2	jsr $b26d			jsr 	StackOpen 					; create frame
.8e89		20 b2 b2	jsr $b2b2			jsr 	STKSaveCodePosition 		; save current position
.8e8c		4c a2 8e	jmp $8ea2			jmp 	GotoStackX
.8e8f						Command_RETURN:
.8e8f		a9 e0		lda #$e0			lda 	#STK_GOSUB 					; check TOS is this
.8e91		a2 0e		ldx #$0e			ldx 	#ERRID_GOSUB 				; this error
.8e93		20 9a b2	jsr $b29a			jsr 	StackCheckFrame
.8e96		20 c3 b2	jsr $b2c3			jsr 	STKLoadCodePosition 		; restore code position
.8e99		20 8c b2	jsr $b28c			jsr 	StackClose
.8e9c		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/goto.asm

.8e9d						GotoCommand:
.8e9d		a2 00		ldx #$00			ldx 	#0 							; GOTO where
.8e9f		20 d7 a8	jsr $a8d7			jsr 	Evaluate16BitInteger
.8ea2						GotoStackX:
.8ea2		b5 60		lda $60,x			lda  	NSMantissa1,x 				; put line # in XA. I'll keep this even though
.8ea4		48		pha				pha 								; it is slightly inefficient, just in cases.
.8ea5		b5 58		lda $58,x			lda 	NSMantissa0,x
.8ea7		fa		plx				plx
.8ea8		20 8b ae	jsr $ae8b			jsr 	MemorySearch 				; transfer to line number AX.
.8eab		90 05		bcc $8eb2			bcc 	_GotoError 					; not found, off end.
.8ead		d0 03		bne $8eb2			bne 	_GotoError 					; not found exactly
.8eaf		4c 55 95	jmp $9555			jmp 	RunNewLine 					; and go straight to new line code.
.8eb2						_GotoError:
.8eb2		a9 0d		lda #$0d		lda	#13
.8eb4		4c f7 99	jmp $99f7		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/if.asm

.8eb7						IfCommand:
.8eb7		a2 00		ldx #$00			ldx 	#0 							; Get the if test.
.8eb9		20 a5 a8	jsr $a8a5			jsr 	EvaluateNumber
.8ebc		b1 30		lda ($30),y			lda 	(codePtr),y
.8ebe		c9 b5		cmp #$b5			cmp 	#KWD_THEN  					; could be THEN <stuff>
.8ec0		d0 0a		bne $8ecc			bne 	_IfStructured 				; we still support it.
.8ec2		c8		iny				iny 								; consume THEN
.8ec3		20 79 a9	jsr $a979			jsr 	NSMIsZero 					; is it zero
.8ec6		f0 01		beq $8ec9			beq 	_IfFail 					; if fail, go to next line
.8ec8		60		rts				rts 								; if THEN just continue
.8ec9						_IfFail:
.8ec9		4c 30 95	jmp $9530			jmp 	EOLCommand
.8ecc						_IfStructured:
.8ecc		20 79 a9	jsr $a979			jsr 	NSMIsZero 					; is it zero
.8ecf		d0 07		bne $8ed8			bne 	_IfExit 					; if not, then continue normally.
.8ed1		a9 c2		lda #$c2			lda 	#KWD_ELSE 					; look for else/endif
.8ed3		a2 b2		ldx #$b2			ldx 	#KWD_ENDIF
.8ed5		20 39 99	jsr $9939			jsr 	ScanForward 				; and run from there
.8ed8						_IfExit:
.8ed8		60		rts				rts
.8ed9						ElseCode:
.8ed9		a9 b2		lda #$b2			lda 	#KWD_ENDIF 					; else is only run after the if clause succeeds
.8edb		aa		tax				tax 								; so just go to the structure exit
.8edc		20 39 99	jsr $9939			jsr 	ScanForward
.8edf		60		rts				rts
.8ee0						EndIf:
.8ee0		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/inputprint.asm

.8ee1						Command_Input:
.8ee1		9c 24 04	stz $0424			stz 	isPrintFlag
.8ee4		80 0c		bra $8ef2			bra 	Command_IP_Main
.8ee6						Command_CPrint:
.8ee6		a9 7f		lda #$7f			lda 	#$7F 						; set input flag to character mode
.8ee8		8d 24 04	sta $0424			sta 	isPrintFlag 				; clear input flag
.8eeb		80 05		bra $8ef2			bra 	Command_IP_Main
.8eed						Command_Print:
.8eed		a9 ff		lda #$ff			lda 	#$FF 						; set input flag
.8eef		8d 24 04	sta $0424			sta 	isPrintFlag 				; clear input flag
.8ef2						Command_IP_Main:
.8ef2		18		clc				clc 								; carry being clear means last print wasn't comma/semicolon
.8ef3						_CPLoop:
.8ef3		08		php				php 								; save last action flag
.8ef4		b1 30		lda ($30),y			lda 	(codePtr),y
.8ef6		c9 80		cmp #$80			cmp  	#KWC_EOL 					; end of line or colon, exit now.
.8ef8		f0 54		beq $8f4e			beq 	_CPExit
.8efa		c9 3a		cmp #$3a			cmp 	#KWD_COLON
.8efc		f0 50		beq $8f4e			beq 	_CPExit
.8efe		68		pla				pla 								; throw last action flag
.8eff		b1 30		lda ($30),y			lda 	(codePtr),y
.8f01		c8		iny				iny
.8f02		c9 3b		cmp #$3b			cmp 	#KWD_SEMICOLON				; is it a semicolon
.8f04		f0 45		beq $8f4b			beq 	_CPContinueWithSameLine
.8f06		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; comma
.8f08		f0 3c		beq $8f46			beq 	_CPTab
.8f0a		c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; apostrophe (new line)
.8f0c		f0 34		beq $8f42			beq 	_CPNewLine
.8f0e		88		dey				dey 								; undo the get.
.8f0f		20 ff 9e	jsr $9eff			jsr 	EvaluateExpressionAt0 		; evaluate expression at 0.
.8f12		b5 50		lda $50,x			lda 	NSStatus,x 					; read the status
.8f14		29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.8f16		f0 0d		beq $8f25			beq 	_CPIsValue 					; no, display it.
.8f18		ad 24 04	lda $0424			lda 	isPrintFlag 				; if print, dereference and print.
.8f1b		d0 05		bne $8f22			bne 	_CPIsPrint 					; otherwise display.
.8f1d		20 57 8f	jsr $8f57			jsr 	CIInputValue 				; input a value to the reference
.8f20		80 20		bra $8f42			bra 	_CPNewLine
.8f22						_CPIsPrint:
.8f22		20 c4 a1	jsr $a1c4			jsr 	Dereference 				; dereference if required.
.8f25						_CPIsValue:
.8f25		b5 50		lda $50,x			lda 	NSStatus,x 					; is it a number
.8f27		29 10		and #$10			and 	#NSBIsString
.8f29		f0 09		beq $8f34			beq 	_CPNumber
.8f2b		a6 60		ldx $60				ldx 	NSMantissa1 				; string, print the text.
.8f2d		a5 58		lda $58				lda 	NSMantissa0
.8f2f		20 ba 8f	jsr $8fba			jsr 	CPPrintStringXA
.8f32		80 be		bra $8ef2			bra 	Command_IP_Main 			; loop round clearing carry so NL if end
.8f34						_CPNumber:
.8f34		a9 05		lda #$05			lda 	#5 							; maximum decimals
.8f36		20 8c a7	jsr $a78c			jsr 	ConvertNumberToString 		; convert to string (in unary str$() function)
.8f39		a2 06		ldx #$06			ldx 	#decimalBuffer >> 8
.8f3b		a9 45		lda #$45			lda 	#decimalBuffer & $FF
.8f3d		20 ba 8f	jsr $8fba			jsr 	CPPrintStringXA 			; print it.
.8f40		80 b0		bra $8ef2			bra 	Command_IP_Main				; loop round clearing carry so NL if end
.8f42						_CPNewLine:
.8f42		a9 0d		lda #$0d			lda 	#13
.8f44		80 02		bra $8f48			bra 	_CPPrintCharDirect
.8f46						_CPTab:
.8f46		a9 09		lda #$09			lda 	#9 							; print TAB
.8f48						_CPPrintCharDirect:
.8f48		20 d5 8f	jsr $8fd5			jsr 	CPPVControl 				; print TAB/CR using the non PETSCII
.8f4b						_CPContinueWithSameLine:
.8f4b		38		sec				sec 								; loop round with carry set, which
.8f4c		80 a5		bra $8ef3			bra 	_CPLoop 					; will inhibit final CR
.8f4e						_CPExit:
.8f4e		28		plp				plp 								; get last action flag
.8f4f		b0 05		bcs $8f56			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.8f51		a9 0d		lda #$0d			lda 	#13 						; print new line
.8f53		20 d5 8f	jsr $8fd5			jsr 	CPPVControl
.8f56						_CPExit2:
.8f56		60		rts				rts
.8f57						CIInputValue:
.8f57		a2 00		ldx #$00			ldx 	#0 							; input a line.
.8f59						_CIInputLine:
.8f59		20 d8 8f	jsr $8fd8			jsr 	CPInputVector 				; get key
.8f5c		c9 0d		cmp #$0d			cmp 	#13 						; 13 = End
.8f5e		f0 1f		beq $8f7f			beq 	_CIHaveValue
.8f60		c9 08		cmp #$08			cmp 	#8 							; 8 = BS
.8f62		f0 11		beq $8f75			beq 	_CIBackspace
.8f64		c9 20		cmp #$20			cmp 	#32 						; ignore other control characters
.8f66		90 f1		bcc $8f59			bcc 	_CIInputLine
.8f68		e0 50		cpx #$50			cpx 	#80 						; max length
.8f6a		b0 ed		bcs $8f59			bcs 	_CIInputLine
.8f6c		9d 26 05	sta $0526,x			sta 	lineBuffer,x
.8f6f		e8		inx				inx
.8f70		20 43 80	jsr $8043			jsr 	EXTPrintCharacter 			; echo it.
.8f73		80 e4		bra $8f59			bra 	_CIInputLine
.8f75						_CIBackspace:
.8f75		e0 00		cpx #$00			cpx 	#0 							; nothing to delete
.8f77		f0 e0		beq $8f59			beq 	_CIInputLine
.8f79		20 43 80	jsr $8043			jsr 	EXTPrintCharacter 			; echo it.
.8f7c		ca		dex				dex
.8f7d		80 da		bra $8f59			bra 	_CIInputLine
.8f7f						_CIHaveValue:
.8f7f		9e 26 05	stz $0526,x			stz 	lineBuffer,x 				; ASCIIZ string now in line buffer.
.8f82		a5 50		lda $50				lda 	NSStatus 					; was it a string assignment
.8f84		29 10		and #$10			and 	#NSBIsString
.8f86		f0 17		beq $8f9f			beq 	_CIAssignNumber 			; assign a number
.8f88		a2 01		ldx #$01			ldx 	#1
.8f8a		a9 26		lda #$26			lda 	#lineBuffer & $FF 			; set up to point to new string
.8f8c		95 58		sta $58,x			sta 	NSMantissa0,x
.8f8e		a9 05		lda #$05			lda 	#lineBuffer >> 8
.8f90		95 60		sta $60,x			sta 	NSMantissa1,x
.8f92		74 68		stz $68,x			stz 	NSMantissa2,x
.8f94		74 70		stz $70,x			stz 	NSMantissa3,x
.8f96		a9 10		lda #$10			lda 	#NSBIsString 				; so it becomes a string value
.8f98		95 50		sta $50,x			sta  	NSStatus,x
.8f9a		ca		dex				dex 								; X = 0
.8f9b		20 4d 90	jsr $904d			jsr 	AssignVariable
.8f9e		60		rts				rts
.8f9f						_CIAssignNumber:
.8f9f		a9 26		lda #$26			lda 	#lineBuffer & $FF 			; set up to point to new string
.8fa1		85 36		sta $36				sta 	zTemp0
.8fa3		a9 05		lda #$05			lda 	#lineBuffer >> 8
.8fa5		85 37		sta $37				sta 	zTemp0+1
.8fa7		a2 01		ldx #$01			ldx 	#1 							; put in slot 1
.8fa9		20 6c a6	jsr $a66c			jsr 	ValEvaluateZTemp0 			; use the VAL() code
.8fac		90 07		bcc $8fb5			bcc 	_CIIsOkay
.8fae		a9 3f		lda #$3f			lda 	#"?" 						; error ?
.8fb0		20 cd 8f	jsr $8fcd			jsr 	CPPrintVector
.8fb3		80 a2		bra $8f57			bra 	CIInputValue
.8fb5						_CIIsOkay:
.8fb5		ca		dex				dex 								; X = 0
.8fb6		20 4d 90	jsr $904d			jsr 	AssignVariable
.8fb9		60		rts				rts
.8fba						CPPrintStringXA:
.8fba		5a		phy				phy
.8fbb		86 37		stx $37				stx 	zTemp0+1
.8fbd		85 36		sta $36				sta 	zTemp0
.8fbf		a0 00		ldy #$00			ldy 	#0
.8fc1						_PSXALoop:
.8fc1		b1 36		lda ($36),y			lda 	(zTemp0),y
.8fc3		f0 06		beq $8fcb			beq 	_PSXAExit
.8fc5		20 cd 8f	jsr $8fcd			jsr 	CPPrintVector
.8fc8		c8		iny				iny
.8fc9		80 f6		bra $8fc1			bra 	_PSXALoop
.8fcb						_PSXAExit:
.8fcb		7a		ply				ply
.8fcc		60		rts				rts
.8fcd						CPPrintVector:
.8fcd		2c 24 04	bit $0424			bit 	isPrintFlag 				; check if char only mode and call appropriate handler.
.8fd0		30 03		bmi $8fd5			bmi 	CPPVControl
.8fd2		4c 4d 80	jmp $804d			jmp 	EXTPrintNoControl
.8fd5						CPPVControl:
.8fd5		4c 43 80	jmp $8043			jmp 	EXTPrintCharacter
.8fd8						CPInputVector:
.8fd8		4c 9e 81	jmp $819e			jmp 	KNLGetSingleCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/commands/joy.asm

.8fdb						UnaryJoyX:
.8fdb		18		clc				clc
.8fdc		80 01		bra $8fdf			bra 	JoyMain
.8fde						UnaryJoyY:
.8fde		38		sec				sec
.8fdf						JoyMain:
.8fdf		fa		plx				plx 								; get pos
.8fe0		08		php				php 								; save carry (set for Y)
.8fe1		20 f2 a8	jsr $a8f2			jsr 	Evaluate8BitInteger 		; ignore the parameter
.8fe4		20 de 99	jsr $99de			jsr 	CheckRightBracket
.8fe7		20 77 84	jsr $8477			jsr 	KNLReadController 			; read the controller.
.8fea		28		plp				plp
.8feb		b0 02		bcs $8fef			bcs 	_JMNoShift 					; if X then shift bits 3,2 -> 1,0
.8fed		4a		lsr a				lsr 	a
.8fee		4a		lsr a				lsr 	a
.8fef						_JMNoShift:
.8fef		4a		lsr a				lsr 	a 							; if bit 0 set then left/up e.g. -1
.8ff0		b0 07		bcs $8ff9			bcs 	JMIsLeft
.8ff2		4a		lsr a				lsr 	a 							; if bit 1 set then right/down e.g. +1
.8ff3		b0 07		bcs $8ffc			bcs 	JMIsRight
.8ff5		20 57 a9	jsr $a957			jsr 	NSMSetZero 					; zero result
.8ff8		60		rts				rts
.8ff9						JMIsLeft:
.8ff9		4c 6a 9a	jmp $9a6a			jmp 	ReturnTrue
.8ffc						JMIsRight:
.8ffc		a9 01		lda #$01			lda 	#1
.8ffe		20 59 a9	jsr $a959			jsr 	NSMSetByte
.9001		60		rts				rts
.9002						UnaryJoyB:
.9002		fa		plx				plx 								; get pos
.9003		20 f2 a8	jsr $a8f2			jsr 	Evaluate8BitInteger 		; ignore the parameter
.9006		20 de 99	jsr $99de			jsr 	CheckRightBracket
.9009		20 77 84	jsr $8477			jsr 	KNLReadController 			; read the controller.
.900c		29 10		and #$10			and 	#$10
.900e		d0 e9		bne $8ff9			bne 	JMIsLeft
.9010		20 57 a9	jsr $a957			jsr 	NSMSetZero
.9013		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/let.asm

.9014						LetCommand:
.9014		a2 00		ldx #$00			ldx 	#0
.9016		b1 30		lda ($30),y			lda 	(codePtr),y
.9018		c9 b8		cmp #$b8			cmp 	#KWD_AT
.901a		d0 14		bne $9030			bne 	_LCStandard
.901c		c8		iny				iny 								; skip equal
.901d		20 4b a3	jsr $a34b			jsr 	EvaluateTerm 				; get a number (the address of the reference)
.9020		20 c4 a1	jsr $a1c4			jsr 	Dereference 				; dereference it to a value
.9023		b5 50		lda $50,x			lda 	NSStatus,x 					; check integer
.9025		49 20		eor #$20			eor 	#NSBIsReference	 			; toggle reference
.9027		95 50		sta $50,x			sta 	NSStatus,x
.9029		29 20		and #$20			and 	#NSBIsReference 			; if it is now a reference, continue
.902b		d0 0f		bne $903c			bne 	_LCMain
.902d		4c fd ab	jmp $abfd			jmp 	TypeError 					; was a reference before.
.9030						_LCStandard:
.9030		ad e9 9e	lda $9ee9			lda 	PrecedenceLevel+"*"			; precedence > this
.9033		20 03 9f	jsr $9f03			jsr 	EvaluateExpressionAtPrecedence
.9036		b5 50		lda $50,x			lda 	NSStatus,x 					; is it a reference to an array marked as procedure ?
.9038		c9 38		cmp #$38			cmp		#NSTProcedure+NSBIsReference
.903a		f0 0e		beq $904a			beq 	_LetGoProc 					; it's a procedure call.
.903c						_LCMain:
.903c		a9 3d		lda #$3d			lda 	#"=" 						; check =
.903e		20 ee 99	jsr $99ee			jsr 	CheckNextA
.9041		e8		inx				inx 								; RHS
.9042		20 9c a8	jsr $a89c			jsr 	EvaluateValue
.9045		ca		dex				dex
.9046		20 4d 90	jsr $904d			jsr 	AssignVariable
.9049		60		rts				rts
.904a						_LetGoProc:
.904a		4c 06 94	jmp $9406			jmp 	CallProcedure
.904d						AssignVariable:
.904d		b5 50		lda $50,x			lda 	NSStatus,x 					; check the string/number type bits match
.904f		48		pha				pha 								; save a copy
.9050		55 51		eor $51,x			eor 	NSStatus+1,x
.9052		29 10		and #$10			and 	#NSBIsString
.9054		d0 0b		bne $9061			bne 	_ASError
.9056		68		pla				pla 								; get back
.9057		29 10		and #$10			and 	#NSBIsString 				; check type
.9059		d0 03		bne $905e			bne 	_ASString
.905b		4c 02 a1	jmp $a102			jmp 	AssignNumber
.905e						_ASString:
.905e		4c 60 a1	jmp $a160			jmp 	AssignString
.9061						_ASError:
.9061		4c fd ab	jmp $abfd			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/list.asm

.9064						Command_List:
.9064		9c 22 04	stz $0422			stz 	listIndent 					; reset indent.
.9067		a9 3f		lda #$3f			lda 	#$3F 						; silence at list.
.9069		20 6b 80	jsr $806b			jsr 	SNDCommand
.906c		b1 30		lda ($30),y			lda 	(codePtr),y
.906e		29 c0		and #$c0			and 	#$C0 				 		; if so, we are list procedure() which is a seperate block
.9070		c9 40		cmp #$40			cmp 	#$40  						; of code.
.9072		f0 72		beq $90e6			beq 	_CLListProcedure
.9074		64 5c		stz $5c				stz		NSMantissa0+4				; set the lower (slot 4) to 0 and upper (slot 7) to $FFFF
.9076		64 64		stz $64				stz 	NSMantissa1+4 				; these are the default top and bottom.
.9078		a9 ff		lda #$ff			lda 	#$FF
.907a		85 5f		sta $5f				sta 	NSMantissa0+7
.907c		85 67		sta $67				sta 	NSMantissa1+7
.907e		b1 30		lda ($30),y			lda 	(codePtr),y
.9080		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.9082		f0 1a		beq $909e			beq 	_CLSecond
.9084		20 63 91	jsr $9163			jsr 	CLIsDigit 					; if not digit, list all
.9087		b0 20		bcs $90a9			bcs 	_CLStart
.9089		a2 04		ldx #$04			ldx 	#4 							; get 1st range into slot 4
.908b		20 d7 a8	jsr $a8d7			jsr 	Evaluate16BitInteger
.908e		b1 30		lda ($30),y			lda 	(codePtr),y
.9090		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.9092		f0 0a		beq $909e			beq 	_CLSecond 					; if so go get it
.9094		a5 5c		lda $5c				lda 	NSMantissa0+4 				; copy 4->7
.9096		85 5f		sta $5f				sta 	NSMantissa0+7
.9098		a5 64		lda $64				lda 	NSMantissa1+4
.909a		85 67		sta $67				sta 	NSMantissa1+7
.909c		80 0b		bra $90a9			bra 	_CLStart
.909e						_CLSecond:
.909e		c8		iny				iny 								; consume comma
.909f		20 63 91	jsr $9163			jsr 	CLIsDigit 					; digit found
.90a2		b0 05		bcs $90a9			bcs 	_CLStart 					; if not, continue listing
.90a4		a2 07		ldx #$07			ldx 	#7 							; load 2nd range into slot 7
.90a6		20 d7 a8	jsr $a8d7			jsr 	Evaluate16BitInteger
.90a9						_CLStart
.90a9		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.90ab		85 30		sta $30				sta 	codePtr
.90ad		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.90af		85 31		sta $31				sta 	codePtr+1
.90b1						_CLLoop:
.90b1		a5 f2		lda $f2				lda 	kernel.args.events.pending 	; load pending event count into accumulator
.90b3		f0 03		beq $90b8			beq 	_NoEvents					; if zero, skip with Z flag set.
.90b5		20 2d 81	jsr $812d			jsr 	ProcessEvents
.90b8						_NoEvents:
.90b8		d0 27		bne $90e1			bne 	_CLBreak
.90ba		b2 30		lda ($30)			lda 	(codePtr)
.90bc		f0 20		beq $90de			beq 	_CLExit
.90be		a2 04		ldx #$04			ldx 	#4 							; check range every time, line numbers aren't in order.
.90c0		20 52 91	jsr $9152			jsr 	CLCompareLineNo
.90c3		90 0c		bcc $90d1			bcc 	_CLNext
.90c5		a2 07		ldx #$07			ldx 	#7
.90c7		20 52 91	jsr $9152			jsr 	CLCompareLineNo
.90ca		f0 02		beq $90ce			beq 	_CLDoThisOne
.90cc		b0 03		bcs $90d1			bcs 	_CLNext
.90ce						_CLDoThisOne:
.90ce		20 3f 91	jsr $913f			jsr 	CLListOneLine 				; routine to list the current line.
.90d1						_CLNext:
.90d1		18		clc				clc
.90d2		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.90d4		65 30		adc $30				adc 	codePtr
.90d6		85 30		sta $30				sta 	codePtr
.90d8		90 02		bcc $90dc			bcc 	_CREExit
.90da		e6 31		inc $31				inc 	codePtr+1 					; carry
.90dc						_CREExit:
.90dc		80 d3		bra $90b1			bra 	_CLLoop
.90de						_CLExit:
.90de		4c df 87	jmp $87df			jmp 	WarmStart
.90e1						_CLBreak:
.90e1		a9 01		lda #$01		lda	#1
.90e3		4c f7 99	jmp $99f7		jmp	ErrorHandler
.90e6						_CLListProcedure:
.90e6		b1 30		lda ($30),y			lda 	(codePtr),y
.90e8		85 38		sta $38				sta 	zTemp1
.90ea		c8		iny				iny
.90eb		b1 30		lda ($30),y			lda 	(codePtr),y
.90ed		85 39		sta $39				sta 	zTemp1+1
.90ef		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.90f1		85 30		sta $30				sta 	codePtr
.90f3		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.90f5		85 31		sta $31				sta 	codePtr+1
.90f7						_CLLPSearch:
.90f7		b2 30		lda ($30)			lda 	(codePtr)
.90f9		c9 00		cmp #$00			cmp 	#0 							; if zero, end
.90fb		f0 e1		beq $90de			beq 	_CLExit
.90fd		a0 03		ldy #$03			ldy 	#3 							; check if PROC something
.90ff		b1 30		lda ($30),y			lda 	(codePtr),y
.9101		c9 af		cmp #$af			cmp 	#KWD_PROC
.9103		d0 0e		bne $9113			bne 	_CLLPNext
.9105		c8		iny				iny 								; check if PROC this.
.9106		b1 30		lda ($30),y			lda 	(codePtr),y
.9108		c5 38		cmp $38				cmp 	zTemp1 						; does it match ?
.910a		d0 07		bne $9113			bne 	_CLLPNext
.910c		c8		iny				iny
.910d		b1 30		lda ($30),y			lda 	(codePtr),y
.910f		c5 39		cmp $39				cmp 	zTemp1+1
.9111		f0 0d		beq $9120			beq 	_CLLPFound
.9113						_CLLPNext:
.9113		18		clc				clc
.9114		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.9116		65 30		adc $30				adc 	codePtr
.9118		85 30		sta $30				sta 	codePtr
.911a		90 02		bcc $911e			bcc 	_CREExit
.911c		e6 31		inc $31				inc 	codePtr+1 					; carry
.911e						_CREExit:
.911e		80 d7		bra $90f7			bra 	_CLLPSearch
.9120						_CLLPFound:
.9120		b2 30		lda ($30)			lda 	(codePtr)
.9122		f0 ba		beq $90de			beq 	_CLExit
.9124		a0 03		ldy #$03			ldy 	#3 							; get first keyword
.9126		b1 30		lda ($30),y			lda 	(codePtr),y
.9128		48		pha				pha
.9129		20 3f 91	jsr $913f			jsr 	CLListOneLine 				; list line and go forward
.912c		18		clc				clc
.912d		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.912f		65 30		adc $30				adc 	codePtr
.9131		85 30		sta $30				sta 	codePtr
.9133		90 02		bcc $9137			bcc 	_CREExit
.9135		e6 31		inc $31				inc 	codePtr+1 					; carry
.9137						_CREExit:
.9137		68		pla				pla 								; reached ENDPROC ?
.9138		c9 b3		cmp #$b3			cmp 	#KWD_ENDPROC
.913a		d0 e4		bne $9120			bne 	_CLLPFound
.913c		4c df 87	jmp $87df			jmp 	WarmStart
.913f						CLListOneLine:
.913f		20 9c 99	jsr $999c			jsr 	ScanGetCurrentLineStep 		; get indent adjust.
.9142		20 7f 80	jsr $807f			jsr 	TKListConvertLine 			; convert line into token Buffer
.9145		a2 04		ldx #$04			ldx 	#(tokenBuffer >> 8) 		; print that line
.9147		a9 29		lda #$29			lda 	#(tokenBuffer & $FF)
.9149		20 56 9a	jsr $9a56			jsr 	PrintStringXA
.914c		a9 0d		lda #$0d			lda 	#13 						; new line
.914e		20 43 80	jsr $8043			jsr 	EXTPrintCharacter
.9151		60		rts				rts
.9152						CLCompareLineNo:
.9152		38		sec				sec
.9153		a0 01		ldy #$01			ldy 	#1
.9155		b1 30		lda ($30),y			lda 	(codePtr),y
.9157		f5 58		sbc $58,x			sbc 	NSMantissa0,x
.9159		85 36		sta $36				sta 	zTemp0
.915b		c8		iny				iny
.915c		b1 30		lda ($30),y			lda 	(codePtr),y
.915e		f5 60		sbc $60,x			sbc 	NSMantissa1,x
.9160		05 36		ora $36				ora 	zTemp0
.9162		60		rts				rts
.9163						CLIsDigit:
.9163		b1 30		lda ($30),y			lda 	(codePtr),y
.9165		c9 30		cmp #$30			cmp 	#"0"
.9167		90 03		bcc $916c			bcc	 	_CLIDExitFalse
.9169		c9 3a		cmp #$3a			cmp 	#"9"+1
.916b		60		rts				rts
.916c						_CLIDExitFalse:
.916c		38		sec				sec
.916d		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/local.asm

.916e						Command_LOCAL:
.916e		a2 00		ldx #$00			ldx 	#0 							; at level 0
.9170		20 7c 91	jsr $917c			jsr 	LocaliseNextTerm 			; convert term to a local.
.9173		b1 30		lda ($30),y			lda 	(codePtr),y
.9175		c8		iny				iny
.9176		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.9178		f0 f4		beq $916e			beq 	Command_LOCAL 				; if so, localise another variable.
.917a		88		dey				dey 								; unpick pre-get
.917b		60		rts				rts
.917c						LocaliseNextTerm:
.917c		20 4b a3	jsr $a34b			jsr 	EvaluateTerm 				; evaluate the term
.917f		b5 50		lda $50,x			lda 	NSStatus,x
.9181		29 20		and #$20			and 	#NSBIsReference 			; check it is a reference, must be a variable.
.9183		f0 5c		beq $91e1			beq		_LNTError
.9185		b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address of variable to zTemp0
.9187		85 36		sta $36				sta 	zTemp0
.9189		b5 60		lda $60,x			lda 	NSMantissa1,x
.918b		85 37		sta $37				sta  	zTemp0+1
.918d		b5 50		lda $50,x			lda 	NSStatus,x 					; figure out what it is.
.918f		29 10		and #$10			and 	#NSBIsString
.9191		d0 1e		bne $91b1			bne 	_LNTPushString
.9193		5a		phy				phy
.9194		a0 00		ldy #$00			ldy 	#0 							; push 0 to 4 inclusive, the number values, on the stack, and zero them as you go.
.9196						_LNTPushNumLoop:
.9196		b1 36		lda ($36),y			lda		(zTemp0),y
.9198		20 4c b2	jsr $b24c			jsr 	StackPushByte
.919b		c8		iny				iny
.919c		c0 05		cpy #$05			cpy 	#5
.919e		d0 f6		bne $9196			bne 	_LNTPushNumLoop
.91a0		a5 36		lda $36				lda 	zTemp0 						; push the actual target address to write on the stack
.91a2		20 4c b2	jsr $b24c			jsr 	StackPushByte
.91a5		a5 37		lda $37				lda 	zTemp0+1
.91a7		20 4c b2	jsr $b24c			jsr 	StackPushByte
.91aa		a9 01		lda #$01			lda 	#STK_LOCALN 				; push local-number marker.
.91ac		20 4c b2	jsr $b24c			jsr 	StackPushByte
.91af		7a		ply				ply
.91b0		60		rts				rts
.91b1						_LNTPushString:
.91b1		5a		phy				phy
.91b2		b2 36		lda ($36)			lda 	(zTemp0) 					; put address of string in zTemp1
.91b4		85 38		sta $38				sta 	zTemp1
.91b6		a0 01		ldy #$01			ldy 	#1
.91b8		b1 36		lda ($36),y			lda 	(zTemp0),y
.91ba		85 39		sta $39				sta 	zTemp1+1
.91bc		a0 00		ldy #$00			ldy 	#0 							; output string
.91be		c9 00		cmp #$00			cmp 	#0 							; if not assigned string
.91c0		f0 0a		beq $91cc			beq 	_LNTStringOut
.91c2						_LNTPushStrLoop:
.91c2		b1 38		lda ($38),y			lda 	(zTemp1),y
.91c4		f0 06		beq $91cc			beq 	_LNTStringOut
.91c6		20 4c b2	jsr $b24c			jsr 	StackPushByte
.91c9		c8		iny				iny
.91ca		80 f6		bra $91c2			bra 	_LNTPushStrLoop
.91cc						_LNTStringOut:
.91cc		98		tya				tya									; output length (chars written).
.91cd		20 4c b2	jsr $b24c			jsr 	StackPushByte
.91d0		b5 58		lda $58,x			lda 	NSMantissa0,x 				; output address of the string record *not* the string itself
.91d2		20 4c b2	jsr $b24c			jsr 	StackPushByte
.91d5		b5 60		lda $60,x			lda 	NSMantissa1,x
.91d7		20 4c b2	jsr $b24c			jsr 	StackPushByte
.91da		a9 02		lda #$02			lda 	#STK_LOCALS 				; push local-string marker.
.91dc		20 4c b2	jsr $b24c			jsr 	StackPushByte
.91df		7a		ply				ply
.91e0		60		rts				rts
.91e1						_LNTError:
.91e1		4c f3 ab	jmp $abf3			jmp 	SyntaxError
.91e4						LocalPopValue:
.91e4		20 64 b2	jsr $b264			jsr 	StackPopByte
.91e7		c9 01		cmp #$01			cmp 	#STK_LOCALN 				; if not local-N
.91e9		d0 17		bne $9202			bne 	_LPVString
.91eb		20 64 b2	jsr $b264			jsr 	StackPopByte 				; address
.91ee		85 37		sta $37				sta 	zTemp0+1
.91f0		20 64 b2	jsr $b264			jsr 	StackPopByte
.91f3		85 36		sta $36				sta 	zTemp0
.91f5		5a		phy				phy
.91f6		a0 04		ldy #$04			ldy 	#4 							; copy back
.91f8						_LPVNumberCopy:
.91f8		20 64 b2	jsr $b264			jsr 	StackPopByte
.91fb		91 36		sta ($36),y			sta 	(zTemp0),y
.91fd		88		dey				dey
.91fe		10 f8		bpl $91f8			bpl 	_LPVNumberCopy
.9200		7a		ply				ply 								; and complete
.9201		60		rts				rts
.9202						_LPVString:
.9202		20 64 b2	jsr $b264			jsr 	StackPopByte 				; address of record copied to zTemp0
.9205		85 37		sta $37				sta 	zTemp0+1
.9207		20 64 b2	jsr $b264			jsr 	StackPopByte
.920a		85 36		sta $36				sta 	zTemp0
.920c		5a		phy				phy
.920d		b2 36		lda ($36)			lda 	(zTemp0) 					; address to write string to copied to zTemp1
.920f		85 38		sta $38				sta 	zTemp1
.9211		a0 01		ldy #$01			ldy 	#1
.9213		b1 36		lda ($36),y			lda 	(zTemp0),y
.9215		85 39		sta $39				sta 	zTemp1+1
.9217		20 64 b2	jsr $b264			jsr 	StackPopByte 				; # chars to get => y
.921a		a8		tay				tay
.921b		a5 39		lda $39				lda 	zTemp1+1 					; if no target (e.g. was "" originally) exit
.921d		f0 0e		beq $922d			beq 	_LPVStringCopied
.921f		a9 00		lda #$00			lda 	#0 							; NULL on end
.9221		91 38		sta ($38),y			sta 	(zTemp1),y
.9223						_LPVStringCopy:
.9223		88		dey				dey
.9224		30 07		bmi $922d			bmi 	_LPVStringCopied
.9226		20 64 b2	jsr $b264			jsr 	StackPopByte
.9229		91 38		sta ($38),y			sta 	(zTemp1),y
.922b		80 f6		bra $9223			bra 	_LPVStringCopy
.922d						_LPVStringCopied:
.922d		fa		plx				plx
.922e		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/commands/memcopy.asm

.922f						MCCommand:
.922f		a5 01		lda $01				lda 	1 							; save current I/O ; switch to I/O 0
.9231		48		pha				pha
.9232		64 01		stz $01				stz 	1
.9234		9c 00 df	stz $df00			stz 	$DF00 						; zero control byte.
.9237		a9 81		lda #$81			lda 	#$81 						; standard start byte (DMA Enabled, Start set)
.9239		8d af 07	sta $07af			sta 	DMAControlByte
.923c		20 ea 92	jsr $92ea			jsr 	MCPosition 					; start position
.923f		a2 04		ldx #$04			ldx 	#4 							; write to source AND $DF04 destination address $DF08
.9241		20 bb 92	jsr $92bb			jsr 	MCCopyAddress
.9244		a2 08		ldx #$08			ldx 	#8
.9246		20 bb 92	jsr $92bb			jsr 	MCCopyAddress
.9249		b1 30		lda ($30),y			lda 	(codePtr),y
.924b		c8		iny				iny
.924c		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; , <size>
.924e		f0 09		beq $9259			beq 	_MCSize1D
.9250		c9 d5		cmp #$d5			cmp 	#KWD_RECT 					; RECT <x>,<y>
.9252		f0 11		beq $9265			beq 	_MCRect2D
.9254						_MCSyntax:
.9254		a9 02		lda #$02		lda	#2
.9256		4c f7 99	jmp $99f7		jmp	ErrorHandler
.9259						_MCSize1D:
.9259		a2 00		ldx #$00			ldx 	#0 							; get size
.925b		20 c4 a8	jsr $a8c4			jsr 	EvaluateInteger
.925e		a2 0c		ldx #$0c			ldx 	#$C 						; copy to size $DF0C-E
.9260		20 bb 92	jsr $92bb			jsr 	MCCopyAddress
.9263		80 24		bra $9289			bra 	_MCDestination
.9265						_MCRect2D:
.9265		a2 0c		ldx #$0c			ldx 	#$C 						; width to $DF0C,D
.9267		20 d8 92	jsr $92d8			jsr 	MCEvalCopyData16
.926a		20 e6 99	jsr $99e6			jsr 	CheckComma
.926d		a2 0e		ldx #$0e			ldx 	#$E 						; height to $DF0E,F
.926f		20 d8 92	jsr $92d8			jsr 	MCEvalCopyData16
.9272		a9 b9		lda #$b9			lda 	#KWD_BY 					; BY keyword.
.9274		20 ee 99	jsr $99ee			jsr 	CheckNextA
.9277		a2 10		ldx #$10			ldx 	#$10 						; store source and destination stride
.9279		20 d8 92	jsr $92d8			jsr 	MCEvalCopyData16
.927c		a2 12		ldx #$12			ldx 	#$12
.927e		20 df 92	jsr $92df			jsr 	MCCopyData16
.9281		ad af 07	lda $07af			lda 	DMAControlByte 				; set bit 4 of DMA control indicating 2D.
.9284		09 02		ora #$02			ora 	#$02
.9286		8d af 07	sta $07af			sta 	DMAControlByte
.9289						_MCDestination:
.9289		b1 30		lda ($30),y			lda 	(codePtr),y
.928b		c8		iny				iny
.928c		c9 d0		cmp #$d0			cmp 	#KWD_POKE 					; is it POKE n
.928e		f0 0e		beq $929e			beq 	_MCDestPoke
.9290		c9 db		cmp #$db			cmp 	#KWD_TO 					; is it TO n
.9292		d0 c0		bne $9254			bne 	_MCSyntax
.9294		20 ea 92	jsr $92ea			jsr 	MCPosition 					; get target address
.9297		a2 08		ldx #$08			ldx 	#8							; copy to target address at $DF08-A
.9299		20 bb 92	jsr $92bb			jsr 	MCCopyAddress
.929c		80 0e		bra $92ac			bra 	_MCDoDMA 					; and we can go.
.929e						_MCDestPoke:
.929e		20 f2 a8	jsr $a8f2			jsr 	Evaluate8BitInteger 		; POKE what
.92a1		8d 01 df	sta $df01			sta 	$DF01 						; set the FILL register
.92a4		ad af 07	lda $07af			lda 	DMAControlByte 				; set bit 2 of control byte indicating FILL.
.92a7		09 04		ora #$04			ora 	#$04
.92a9		8d af 07	sta $07af			sta 	DMAControlByte
.92ac						_MCDoDMA:
.92ac		ad af 07	lda $07af			lda 	DMAControlByte 				; set the DMA Control byte to go !
.92af		8d 00 df	sta $df00			sta 	$DF00
.92b2						_MCWaitBUSD:
.92b2		ad 01 df	lda $df01			lda 	$DF01
.92b5		30 fb		bmi $92b2			bmi 	_MCWaitBUSD
.92b7		68		pla				pla 								; restore I/O.
.92b8		85 01		sta $01				sta 	1
.92ba		60		rts				rts
.92bb						MCCopyAddress:
.92bb		a5 68		lda $68				lda 	NSMantissa2 				; check valid vlaue
.92bd		29 fc		and #$fc			and 	#$FC
.92bf		05 70		ora $70				ora 	NSMantissa3
.92c1		d0 10		bne $92d3			bne 	_MCRange
.92c3		a5 58		lda $58				lda 	NSMantissa0
.92c5		9d 00 df	sta $df00,x			sta 	$DF00,x
.92c8		a5 60		lda $60				lda 	NSMantissa1
.92ca		9d 01 df	sta $df01,x			sta 	$DF01,x
.92cd		a5 68		lda $68				lda 	NSMantissa2
.92cf		9d 02 df	sta $df02,x			sta 	$DF02,x
.92d2		60		rts				rts
.92d3						_MCRange:
.92d3		a9 04		lda #$04		lda	#4
.92d5		4c f7 99	jmp $99f7		jmp	ErrorHandler
.92d8						MCEvalCopyData16:
.92d8		da		phx				phx
.92d9		a2 00		ldx #$00			ldx 	#0
.92db		20 d7 a8	jsr $a8d7			jsr 	Evaluate16BitInteger
.92de		fa		plx				plx
.92df						MCCopyData16:
.92df		a5 58		lda $58				lda 	NSMantissa0
.92e1		9d 00 df	sta $df00,x			sta 	$DF00,x
.92e4		a5 60		lda $60				lda 	NSMantissa1
.92e6		9d 01 df	sta $df01,x			sta 	$DF01,x
.92e9		60		rts				rts
.92ea						MCPosition:
.92ea		a2 00		ldx #$00			ldx 	#0 							; get start address.
.92ec		b1 30		lda ($30),y			lda 	(codePtr),y
.92ee		c9 b8		cmp #$b8			cmp 	#KWD_AT
.92f0		f0 04		beq $92f6			beq 	_MCPAt
.92f2		20 c4 a8	jsr $a8c4			jsr 	EvaluateInteger
.92f5		60		rts				rts
.92f6						_MCPAt:
.92f6		c8		iny				iny
.92f7		20 f2 a8	jsr $a8f2			jsr 	Evaluate8BitInteger 		; X position
.92fa		48		pha				pha
.92fb		20 e6 99	jsr $99e6			jsr 	CheckComma
.92fe		e8		inx				inx
.92ff		20 f2 a8	jsr $a8f2			jsr 	Evaluate8BitInteger 		; Y position
.9302		ca		dex				dex
.9303		85 60		sta $60				sta 	NSMantissa1 				; put Y x 64 in Mantissa.0
.9305		64 58		stz $58				stz 	NSMantissa0
.9307		64 68		stz $68				stz 	NSMantissa2
.9309		64 70		stz $70				stz 	NSMantissa3
.930b		46 60		lsr $60				lsr 	NSMantissa1
.930d		66 58		ror $58				ror 	NSMantissa0
.930f		46 60		lsr $60				lsr 	NSMantissa1
.9311		66 58		ror $58				ror 	NSMantissa0
.9313		68		pla				pla
.9314		18		clc				clc
.9315		65 58		adc $58				adc 	NSMantissa0 				; add X, Y * 256 and the
.9317		85 58		sta $58				sta 	NSMantissa0
.9319		a5 60		lda $60				lda 	NSMantissa1
.931b		65 59		adc $59				adc 	NSMantissa0+1
.931d		85 60		sta $60				sta 	NSMantissa1
.931f		90 02		bcc $9323			bcc 	_MCPNoCarry
.9321		e6 68		inc $68				inc 	NSMantissa2
.9323						_MCPNoCarry:
.9323		ad d8 07	lda $07d8			lda 	gxBasePage
.9326		85 69		sta $69				sta 	NSMantissa2+1
.9328		64 59		stz $59				stz 	NSMantissa0+1
.932a		64 61		stz $61				stz 	NSMantissa1+1
.932c		64 71		stz $71				stz 	NSMantissa3+1
.932e		a2 01		ldx #$01			ldx 	#1
.9330		20 70 a9	jsr $a970			jsr 	NSMShiftRight
.9333		20 70 a9	jsr $a970			jsr 	NSMShiftRight
.9336		20 70 a9	jsr $a970			jsr 	NSMShiftRight
.9339		a2 00		ldx #$00			ldx 	#0
.933b		20 f7 9c	jsr $9cf7			jsr 	AddTopTwoStack
.933e		60		rts				rts
.07af						DMAControlByte:
>07af								.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/commands/mouse.asm

.933f						MouseStatus:
.933f		a9 ff		lda #$ff	        lda     #255
.9341		80 02		bra $9345	        bra     MouseCommand
.9343						MouseDeltaStatus:
.9343		a9 00		lda #$00	        lda     #0
.9345						MouseCommand:
.9345		8d 5f 06	sta $065f	        sta     CMDMouseFlag
.9348		a2 00		ldx #$00	        ldx     #0
.934a						_MouseCommandLoop:
.934a		da		phx		        phx                                 ; save slot.
.934b		20 ff 9e	jsr $9eff	        jsr     EvaluateExpressionAt0       ; evaluate a reference.
.934e		a5 50		lda $50		        lda     NSStatus                    ; check it's a reference.
.9350		c9 20		cmp #$20	        cmp     #NSBIsReference
.9352		d0 60		bne $93b4	        bne     _MouseNotRef
.9354		b1 30		lda ($30),y			lda 	(codePtr),y
.9356		c9 2c		cmp #$2c	        cmp     #KWD_COMMA
.9358		d0 01		bne $935b	        bne     _MouseNoSkipComma
.935a		c8		iny		        iny
.935b						_MouseNoSkipComma:
.935b		fa		plx		        plx                                 ; restore X
.935c		5a		phy		        phy                                 ; save Y
.935d		a5 58		lda $58		        lda     NSMantissa0                 ; copy address to zTemp0
.935f		85 36		sta $36		        sta     zTemp0
.9361		a5 60		lda $60		        lda     NSMantissa1
.9363		85 37		sta $37		        sta     zTemp0+1
.9365		a0 04		ldy #$04	        ldy     #4                          ; set exponent, m3, m2 , m1 , m0
.9367		a9 00		lda #$00	        lda     #0
.9369		91 36		sta ($36),y	        sta     (zTemp0),y                  ; exponent
.936b		88		dey		        dey
.936c		91 36		sta ($36),y	        sta     (zTemp0),y                  ; m3
.936e		88		dey		        dey
.936f		91 36		sta ($36),y	        sta     (zTemp0),y                  ; m2
.9371		88		dey		        dey
.9372		2c 5f 06	bit $065f	        bit     CMDMouseFlag                ; mouse or mdelta command
.9375		30 12		bmi $9389	        bmi     _MouseMouseCommand
.9377						_MouseMDeltaCommand:
.9377		bd 82 06	lda $0682,x	        lda     MouseDeltaX,x
.937a		92 36		sta ($36)	        sta     (zTemp0)                    ; m0
.937c		bd 83 06	lda $0683,x	        lda     MouseDeltaX+1,x
.937f		91 36		sta ($36),y	        sta     (zTemp0),y                  ; m1
.9381		9e 82 06	stz $0682,x	        stz     MouseDeltaX,x               ; clear entry in current table
.9384		9e 83 06	stz $0683,x	        stz     MouseDeltaX+1,x
.9387		80 0a		bra $9393	        bra     _MouseProcessData
.9389						_MouseMouseCommand:
.9389		bd 8e 06	lda $068e,x	        lda     MousePosX,x
.938c		92 36		sta ($36)	        sta     (zTemp0)                    ; m0
.938e		bd 8f 06	lda $068f,x	        lda     MousePosX+1,x
.9391		91 36		sta ($36),y	        sta     (zTemp0),y                  ; m1
.9393						_MouseProcessData:
.9393		b1 36		lda ($36),y	        lda     (zTemp0),y
.9395		10 15		bpl $93ac	        bpl     _MouseDataPos               ; signed 16 bit value, so fix up if -ve.
.9397		38		sec		        sec                                 ; negate the mantissa 2 bytes
.9398		a9 00		lda #$00	        lda     #0
.939a		f2 36		sbc ($36)	        sbc     (zTemp0)
.939c		92 36		sta ($36)	        sta     (zTemp0)
.939e		a9 00		lda #$00	        lda     #0
.93a0		f1 36		sbc ($36),y	        sbc     (zTemp0),y
.93a2		91 36		sta ($36),y	        sta     (zTemp0),y
.93a4		a0 03		ldy #$03	        ldy     #3
.93a6		b1 36		lda ($36),y	        lda     (zTemp0),y                  ; set upper bit of mantissa
.93a8		09 80		ora #$80	        ora     #$80
.93aa		91 36		sta ($36),y	        sta     (zTemp0),y
.93ac						_MouseDataPos:
.93ac		7a		ply		        ply                                 ; restore Y.
.93ad		e8		inx		        inx                                 ; next entry
.93ae		e8		inx		        inx
.93af		e0 0c		cpx #$0c	        cpx     #6*2                        ; done 6 reads to variables.
.93b1		d0 97		bne $934a	        bne     _MouseCommandLoop
.93b3		60		rts		        rts
.93b4						_MouseNotRef:
.93b4		a9 07		lda #$07		lda	#7
.93b6		4c f7 99	jmp $99f7		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/new.asm

.93b9						NewCommand:
.93b9		20 bf 93	jsr $93bf			jsr 	NewProgram 					; does the actual NEW.
.93bc		4c df 87	jmp $87df			jmp 	WarmStart 					; and warm starts straight away.
.93bf						NewProgram:
.93bf		20 6d ae	jsr $ae6d			jsr 	MemoryNew
.93c2		9c 00 10	stz $1000			stz 	VariableSpace 				; erase all variables.
.93c5		20 86 98	jsr $9886			jsr 	ClearSystem					; clear everything.
.93c8		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/poke.asm

.93c9						PokeBCommand:
.93c9		a9 01		lda #$01			lda 	#1
.93cb		80 0c		bra $93d9			bra 	PokeCommand
.93cd						PokeWCommand:
.93cd		a9 02		lda #$02			lda 	#2
.93cf		80 08		bra $93d9			bra 	PokeCommand
.93d1						PokeLCommand:
.93d1		a9 03		lda #$03			lda 	#3
.93d3		80 04		bra $93d9			bra 	PokeCommand
.93d5						PokeDCommand:
.93d5		a9 04		lda #$04			lda 	#4
.93d7		80 00		bra $93d9			bra 	PokeCommand
.93d9						PokeCommand:
.93d9		48		pha				pha 								; save count on stack
.93da		a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.93dc		20 d7 a8	jsr $a8d7			jsr		Evaluate16BitInteger 		; address
.93df		20 e6 99	jsr $99e6			jsr 	CheckComma
.93e2		e8		inx				inx
.93e3		20 c4 a8	jsr $a8c4			jsr		EvaluateInteger 			; data
.93e6		a5 58		lda $58				lda 	NSMantissa0 				; copy address
.93e8		85 36		sta $36				sta 	zTemp0
.93ea		a5 60		lda $60				lda 	NSMantissa1
.93ec		85 37		sta $37				sta 	zTemp0+1
.93ee		68		pla				pla 								; count -> zTemp1
.93ef		85 38		sta $38				sta 	zTemp1
.93f1		5a		phy				phy 								; save Y position.
.93f2		a0 00		ldy #$00			ldy 	#0 							; index to write
.93f4		a2 00		ldx #$00			ldx 	#0 							; index to read
.93f6						_PCLoop:
.93f6		b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; read byte from mantissa and copy out
.93f8		91 36		sta ($36),y			sta 	(zTemp0),y
.93fa		c8		iny				iny 								; next byte to write
.93fb		8a		txa				txa 								; next byte to read - stack layout in 04data.inc
.93fc		18		clc				clc
.93fd		69 08		adc #$08			adc 	#MathStackSize
.93ff		aa		tax				tax
.9400		c6 38		dec $38				dec 	zTemp1 						; done them all
.9402		d0 f2		bne $93f6			bne 	_PCLoop
.9404		7a		ply				ply 								; restore position.
.9405		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/procedure.asm

=2						ParameterStackPos = 2
.9406						CallProcedure:
.9406		a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start storing parameters at 2.
.9408		b1 30		lda ($30),y			lda 	(codePtr),y
.940a		c9 29		cmp #$29			cmp 	#KWD_RPAREN
.940c		f0 0c		beq $941a			beq 	_CPEndParam
.940e						_CPParamLoop:
.940e		20 9c a8	jsr $a89c			jsr 	EvaluateValue 				; get parameter onto stack
.9411		e8		inx				inx 								; bump next stack
.9412		b1 30		lda ($30),y			lda 	(codePtr),y
.9414		c8		iny				iny
.9415		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if comma, go back and try again.
.9417		f0 f5		beq $940e			beq 	_CPParamLoop
.9419		88		dey				dey 								; unpick.
.941a						_CPEndParam:
.941a		8e 12 04	stx $0412			stx 	lastParameter 				; save the last parameters index.
.941d		c8		iny				iny									; skip right bracket
.941e		a9 b3		lda #$b3			lda 	#STK_PROC+3 				; allocate 6 bytes on the return stack.
.9420		20 6d b2	jsr $b26d			jsr 	StackOpen
.9423		20 b2 b2	jsr $b2b2			jsr 	STKSaveCodePosition 		; save loop position
.9426		a5 58		lda $58				lda 	NSMantissa0 				; copy variable (e.g. procedure) address to zTemp0
.9428		85 36		sta $36				sta 	zTemp0 						; this is the DATA not the RECORD
.942a		a5 60		lda $60				lda 	NSMantissa1
.942c		85 37		sta $37				sta 	zTemp0+1
.942e		a0 01		ldy #$01			ldy 	#1 							; copy code address back.
.9430		b2 36		lda ($36)			lda 	(zTemp0)
.9432		85 30		sta $30				sta 	safePtr
.9434		b1 36		lda ($36),y			lda 	(zTemp0),y
.9436		85 31		sta $31				sta 	safePtr+1
.9438		c8		iny				iny
.9439		b1 36		lda ($36),y			lda 	(zTemp0),y
.943b		85 32		sta $32				sta 	safePtr+2
.943d		c8		iny				iny
.943e		b1 36		lda ($36),y			lda 	(zTemp0),y
.9440		85 33		sta $33				sta 	safePtr+3
.9442		c8		iny				iny 								; get Y offset -> Y
.9443		b1 36		lda ($36),y			lda 	(zTemp0),y
.9445		a8		tay				tay
.9446		a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start position of parameters
.9448		ec 12 04	cpx $0412			cpx	 	lastParameter 				; check zero parameters at the start
.944b		f0 13		beq $9460			beq 	_ParamExit 					; if so, exit.
.944d						_ParamExtract:
.944d		ca		dex				dex 								; put a local term on the level before
.944e		20 7c 91	jsr $917c			jsr 	LocaliseNextTerm			; also pushes original param value to basic stack
.9451		20 4d 90	jsr $904d			jsr 	AssignVariable 				; assign stacked value to the variable.
.9454		e8		inx				inx 								; advance to next parameter to do.
.9455		e8		inx				inx
.9456		ec 12 04	cpx $0412			cpx 	lastParameter 				; are we done ?
.9459		f0 05		beq $9460			beq 	_ParamExit
.945b		20 e6 99	jsr $99e6			jsr 	CheckComma 					; comma seperating parameters
.945e		80 ed		bra $944d			bra 	_ParamExtract
.9460						_ParamExit:
.9460		20 de 99	jsr $99de			jsr 	CheckRightBracket 			; check )
.9463		60		rts				rts 								; and continue from here
.9464						Command_ENDPROC:
.9464		a9 b0		lda #$b0			lda 	#STK_PROC 					; check TOS is this
.9466		a2 14		ldx #$14			ldx 	#ERRID_PROC
.9468		20 9a b2	jsr $b29a			jsr 	StackCheckFrame
.946b		20 c3 b2	jsr $b2c3			jsr 	STKLoadCodePosition 		; restore code position
.946e		20 8c b2	jsr $b28c			jsr 	StackClose
.9471		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/read.asm

.9472						Command_Read:
.9472		a2 00		ldx #$00			ldx 	#0 							; evaluate the term which is the var/array element to assign
.9474		20 4b a3	jsr $a34b			jsr 	EvaluateTerm
.9477		b5 50		lda $50,x			lda 	NSStatus,x
.9479		29 20		and #$20			and 	#NSBIsReference				; get status byte on stack, identifies int, float, string.
.947b		f0 4f		beq $94cc			beq 	_CRSyntax 					; check reference (bit 0) fail if not a reference.
.947d		20 15 95	jsr $9515			jsr 	SwapDataCodePtrs 			; swap code and data
.9480		ad 18 04	lda $0418			lda 	inDataStatement 			; if in a data statement, we don't need to search
.9483		d0 25		bne $94aa			bne 	_CRContinueData  			; forward for the next one.
.9485		b2 30		lda ($30)			lda 	(codePtr)
.9487		f0 1c		beq $94a5			beq 	_CRNoData
.9489						_CRKeepSearching:
.9489		a9 bf		lda #$bf			lda 	#KWD_DATA 					; scan for instruction
.948b		a2 80		ldx #$80			ldx 	#KWC_EOL
.948d		20 39 99	jsr $9939			jsr 	ScanForward
.9490		c9 bf		cmp #$bf			cmp 	#KWD_DATA 					; found data ?
.9492		f0 16		beq $94aa			beq 	_CRHaveData 				; found it
.9494		18		clc				clc
.9495		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.9497		65 30		adc $30				adc 	codePtr
.9499		85 30		sta $30				sta 	codePtr
.949b		90 02		bcc $949f			bcc 	_CREExit
.949d		e6 31		inc $31				inc 	codePtr+1 					; carry
.949f						_CREExit:
.949f		a0 03		ldy #$03			ldy 	#3 							; start of line.
.94a1		b2 30		lda ($30)			lda 	(codePtr)
.94a3		d0 e4		bne $9489			bne 	_CRKeepSearching
.94a5						_CRNoData:
.94a5		a9 0b		lda #$0b		lda	#11
.94a7		4c f7 99	jmp $99f7		jmp	ErrorHandler
.94aa						_CRHaveData:
.94aa						_CRContinueData:
.94aa		a2 01		ldx #$01			ldx 	#1
.94ac		20 9c a8	jsr $a89c			jsr 	EvaluateValue 				; evaluate value into slot # 1
.94af		ca		dex				dex
.94b0		20 4d 90	jsr $904d			jsr		AssignVariable 				; do the assignment
.94b3		9c 18 04	stz $0418			stz 	inDataStatement 			; clear in data flag
.94b6		b1 30		lda ($30),y			lda 	(codePtr),y
.94b8		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not, end of data statement and exit
.94ba		d0 04		bne $94c0			bne 	_CRSwapBack
.94bc		c8		iny				iny 								; consume comma
.94bd		ee 18 04	inc $0418			inc 	inDataStatement 			; set in data statement currently.
.94c0						_CRSwapBack:
.94c0		20 15 95	jsr $9515			jsr 	SwapDataCodePtrs			; swap them back.
.94c3		b1 30		lda ($30),y			lda 	(codePtr),y
.94c5		c8		iny				iny
.94c6		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.94c8		f0 a8		beq $9472			beq 	Command_Read 				; if so go round again.
.94ca		88		dey				dey 								; unpick get.
.94cb		60		rts				rts
.94cc						_CRSyntax:
.94cc		4c f3 ab	jmp $abf3			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/rem.asm

.94cf						RemCommand:
.94cf		b1 30		lda ($30),y			lda 	(codePtr),y
.94d1		c9 ff		cmp #$ff			cmp 	#KWC_STRING
.94d3		d0 06		bne $94db			bne 	_RMExit
.94d5		c8		iny				iny 								; point to offset
.94d6		98		tya				tya 								; A = offset position
.94d7		38		sec				sec 								; add size +1 hence SEC
.94d8		71 30		adc ($30),y			adc 	(codePtr),y
.94da		a8		tay				tay 								; make current position.
.94db						_RMExit:
.94db		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/repeat.asm

.94dc						Command_REPEAT:
.94dc		a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; allocate 6 bytes on the return stack.
.94de		20 6d b2	jsr $b26d			jsr 	StackOpen
.94e1		20 b2 b2	jsr $b2b2			jsr 	STKSaveCodePosition 		; save loop position
.94e4		60		rts				rts
.94e5						Command_UNTIL:
.94e5		a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; check REPEAT is TOS
.94e7		a2 0f		ldx #$0f			ldx 	#ERRID_REPEAT 				; this error
.94e9		20 9a b2	jsr $b29a			jsr 	StackCheckFrame
.94ec		a2 00		ldx #$00			ldx 	#0
.94ee		20 a5 a8	jsr $a8a5			jsr 	EvaluateNumber 				; work out the number
.94f1		20 79 a9	jsr $a979			jsr 	NSMIsZero 					; check if zero
.94f4		f0 04		beq $94fa			beq 	_CULoopBack 				; if so keep looping
.94f6		20 8c b2	jsr $b28c			jsr 	StackClose		 			; return
.94f9		60		rts				rts
.94fa						_CULoopBack:
.94fa		20 c3 b2	jsr $b2c3			jsr 	STKLoadCodePosition 		; loop back
.94fd		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/restore.asm

.94fe						Command_Restore:
.94fe		20 15 95	jsr $9515			jsr 	SwapDataCodePtrs 			; swap code and data
.9501		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.9503		85 30		sta $30				sta 	codePtr
.9505		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.9507		85 31		sta $31				sta 	codePtr+1
.9509		20 15 95	jsr $9515			jsr 	SwapDataCodePtrs 			; put them back
.950c		a9 03		lda #$03			lda 	#3 							; start at offset 3, e.g. first instruction of first line.
.950e		8d 17 04	sta $0417			sta 	dataPointer+4   			; (read checks not EOF)
.9511		9c 18 04	stz $0418			stz 	inDataStatement 			; not in data statement
.9514		60		rts				rts
.9515						SwapDataCodePtrs:
.9515		da		phx				phx
.9516		a2 03		ldx #$03			ldx 	#3 							; swap 32 bit code pointer over
.9518						_SDCPLoop:
.9518		b5 30		lda $30,x			lda 	safePtr,x
.951a		48		pha				pha
.951b		bd 13 04	lda $0413,x			lda 	dataPointer,x
.951e		95 30		sta $30,x			sta 	safePtr,x
.9520		68		pla				pla
.9521		9d 13 04	sta $0413,x			sta 	dataPointer,x
.9524		ca		dex				dex
.9525		10 f1		bpl $9518			bpl 	_SDCPLoop
.9527		ad 17 04	lda $0417			lda 	dataPointer+4 				; swap Y position over.
.952a		8c 17 04	sty $0417			sty 	dataPointer+4
.952d		a8		tay				tay
.952e		fa		plx				plx
.952f		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/run.asm

.9530						EOLCommand:
.9530		18		clc				clc
.9531		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.9533		65 30		adc $30				adc 	codePtr
.9535		85 30		sta $30				sta 	codePtr
.9537		90 02		bcc $953b			bcc 	_CREExit
.9539		e6 31		inc $31				inc 	codePtr+1 					; carry
.953b						_CREExit:
.953b		80 18		bra $9555			bra 	RunNewLine
.953d						CommandRUNOptLoad:
.953d		b1 30		lda ($30),y			lda 	(codePtr),y
.953f		c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL / : just RUN
.9541		f0 07		beq $954a			beq 	RunCurrentProgram
.9543		c9 3a		cmp #$3a			cmp 	#KWD_COLON
.9545		f0 03		beq $954a			beq 	RunCurrentProgram
.9547		20 ca 8b	jsr $8bca			jsr 	LoadFile 					; load expected name file.
.954a						RunCurrentProgram:
.954a		20 86 98	jsr $9886			jsr 	ClearSystem 				; clear variable/stacks/etc.
.954d		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.954f		85 30		sta $30				sta 	codePtr
.9551		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.9553		85 31		sta $31				sta 	codePtr+1
.9555						RunNewLine:
.9555		b2 30		lda ($30)			lda 	(codePtr)
.9557		f0 74		beq $95cd			beq 	CRNoProgram         		; no then END.
.9559		a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack
.955b		9a		txs				txs
.955c						RUNCodePointerLine:
.955c		a0 02		ldy #$02			ldy 	#2 							; start of program
.955e						_CRIncMainLoop:
.955e		a5 f2		lda $f2				lda 	kernel.args.events.pending 	; load pending event count into accumulator
.9560		f0 03		beq $9565			beq 	_NoEvents					; if zero, skip with Z flag set.
.9562		20 2d 81	jsr $812d			jsr 	ProcessEvents
.9565						_NoEvents:
.9565		d0 61		bne $95c8			bne 	_CRBreak
.9567		a5 01		lda $01				lda 	1 							; save I/O 0
.9569		48		pha				pha
.956a		64 01		stz $01				stz 	1 							; access I/O Page 0
.956c		38		sec				sec 								; calculate timer - LastTick
.956d		ad 59 d6	lda $d659			lda 	$D659
.9570		cd 5e 06	cmp $065e			cmp 	LastTick
.9573		f0 06		beq $957b			beq 	_NoFireTick 				; if < 3 clocks don't fire.
.9575		8d 5e 06	sta $065e			sta 	LastTick 					; update last timer
.9578		20 4d 82	jsr $824d			jsr 	TickHandler 							; go do the code.
.957b						_NoFireTick:
.957b		68		pla				pla 								; restore I/O 0
.957c		85 01		sta $01				sta 	1
.957e						_CRNoBreakCheck:
.957e		c8		iny				iny									; next token
.957f						_CRMainLoop:
.957f		9c 0c 04	stz $040c			stz 	stringInitialised 			; clear the temporary string initialised flag.
.9582		b1 30		lda ($30),y			lda 	(codePtr),y
.9584		10 10		bpl $9596			bpl 	_CRNotKeyword				; not a token.
.9586		c9 ad		cmp #$ad			cmp 	#KWC_LAST_UNARY+1 			; if after unary, legitimate command
.9588		b0 04		bcs $958e			bcs 	_CRIsKeyword
.958a		c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if unary, syntax error.
.958c		b0 34		bcs $95c2			bcs		_CRSyntaxError
.958e						_CRIsKeyword:
.958e		c8		iny				iny 								; consume command
.958f		0a		asl a				asl 	a 							; double losing the MSB which is '1' as tokens are $80-$FF
.9590		aa		tax				tax 								; put in X for vector jump
.9591		20 c5 95	jsr $95c5			jsr 	_CRCallVector0 				; call the vector - effectively jsr (vectortable,X)
.9594		80 e9		bra $957f			bra 	_CRMainLoop 				; and loop round
.9596						_CRNotKeyword:
.9596		c9 3a		cmp #$3a			cmp 	#KWD_COLON 					; if a :, consume it and go round.
.9598		f0 c4		beq $955e			beq 	_CRIncMainLoop
.959a		c9 40		cmp #$40			cmp 	#$40 						; variable/call reference
.959c		90 05		bcc $95a3			bcc 	_CRNotVariable
.959e						_CRGoLet:
.959e		20 14 90	jsr $9014			jsr 	LetCommand
.95a1		80 dc		bra $957f			bra 	_CRMainLoop
.95a3						_CRNotVariable:
.95a3		c9 b8		cmp #$b8			cmp 	#KWD_AT 					; handle @
.95a5		f0 f7		beq $959e			beq 	_CRGoLet
.95a7		c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; handle ? !
.95a9		f0 f3		beq $959e			beq 	_CRGoLet
.95ab		c9 21		cmp #$21			cmp 	#KWD_PLING
.95ad		f0 ef		beq $959e			beq 	_CRGoLet
.95af		c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; handle ' (comment)
.95b1		f0 09		beq $95bc			beq 	_CRGoRem
.95b3		c9 2e		cmp #$2e			cmp 	#KWD_PERIOD 				; handle . (assembler label)
.95b5		d0 0b		bne $95c2			bne 	_CRSyntaxError
.95b7		20 28 86	jsr $8628			jsr 	LabelHere
.95ba		80 c3		bra $957f			bra 	_CRMainLoop
.95bc						_CRGoRem:
.95bc		c8		iny				iny
.95bd		20 cf 94	jsr $94cf			jsr 	RemCommand
.95c0		80 bd		bra $957f			bra 	_CRMainLoop
.95c2						_CRSyntaxError:
.95c2		4c f3 ab	jmp $abf3			jmp 	SyntaxError
.95c5						_CRCallVector0:
.95c5		7c 64 96	jmp ($9664,x)			jmp 	(VectorSet0,x)
.95c8						_CRBreak:
.95c8		a9 01		lda #$01		lda	#1
.95ca		4c f7 99	jmp $99f7		jmp	ErrorHandler
.95cd						CRNoProgram:
.95cd		4c 5e 89	jmp $895e			jmp 	EndCommand
.95d0						Shift1Command:
.95d0		b1 30		lda ($30),y			lda 	(codePtr),y
.95d2		c8		iny				iny
.95d3		0a		asl a				asl 	a
.95d4		aa		tax				tax
.95d5		7c 1c 97	jmp ($971c,x)			jmp 	(VectorSet1,x)
.95d8						Shift2Command:
.95d8		b1 30		lda ($30),y			lda 	(codePtr),y
.95da		c8		iny				iny
.95db		0a		asl a				asl 	a
.95dc		aa		tax				tax
.95dd		7c 6c 97	jmp ($976c,x)			jmp 	(VectorSet2,x)
.95e0						Unused1:
.95e0						Unused2:
.95e0						Unused3:
.95e0						Unused4:
.95e0		4c f3 ab	jmp $abf3			jmp 	SyntaxError
>95e3								.align 2

;******  Processing file: ./common/commands/../generated/vectors.dat

.95e4						VectorSetPunc:
>95e4		b5 9c					.word	ShiftLeft                        ; $00 <<
>95e6		a0 9a					.word	BinaryCompareLessEqual           ; $01 <=
>95e8		96 9a					.word	BinaryCompareNotEqual            ; $02 <>
>95ea		f3 ab					.word	SyntaxError                      ; $03 !!3
>95ec		f3 ab					.word	SyntaxError                      ; $04 ><
>95ee		aa 9a					.word	BinaryCompareGreaterEqual        ; $05 >=
>95f0		b8 9c					.word	ShiftRight                       ; $06 >>
>95f2		f3 ab					.word	SyntaxError                      ; $07 !!7
>95f4		f3 ab					.word	SyntaxError                      ; $08 !!8
>95f6		f3 ab					.word	SyntaxError                      ; $09 !!9
>95f8		f3 ab					.word	SyntaxError                      ; $0a !!10
>95fa		f3 ab					.word	SyntaxError                      ; $0b !!11
>95fc		f3 ab					.word	SyntaxError                      ; $0c !!12
>95fe		f3 ab					.word	SyntaxError                      ; $0d !!13
>9600		f3 ab					.word	SyntaxError                      ; $0e !!14
>9602		f3 ab					.word	SyntaxError                      ; $0f !!15
>9604		f3 ab					.word	SyntaxError                      ; $10 @
>9606		f3 ab					.word	SyntaxError                      ; $11 !!17
>9608		f3 ab					.word	SyntaxError                      ; $12 !!18
>960a		f3 ab					.word	SyntaxError                      ; $13 [
>960c		61 9b					.word	IntegerDivide                    ; $14 \
>960e		f3 ab					.word	SyntaxError                      ; $15 ]
>9610		f3 9d					.word	EorInteger                       ; $16 ^
>9612		f3 ab					.word	SyntaxError                      ; $17 _
>9614		f3 ab					.word	SyntaxError                      ; $18 `
>9616		f3 ab					.word	SyntaxError                      ; $19 !!25
>9618		f3 ab					.word	SyntaxError                      ; $1a !!26
>961a		f3 ab					.word	SyntaxError                      ; $1b {
>961c		be 9d					.word	OraInteger                       ; $1c |
>961e		f3 ab					.word	SyntaxError                      ; $1d }
>9620		f3 ab					.word	SyntaxError                      ; $1e ~
>9622		f3 ab					.word	SyntaxError                      ; $1f <7F>
>9624		f3 ab					.word	SyntaxError                      ; $20
>9626		28 9e					.word	WordIndirect                     ; $21 !
>9628		f3 ab					.word	SyntaxError                      ; $22 "
>962a		f3 ab					.word	SyntaxError                      ; $23 #
>962c		f3 ab					.word	SyntaxError                      ; $24 $
>962e		a2 9b					.word	IntegerModulus                   ; $25 %
>9630		89 9d					.word	AndInteger                       ; $26 &
>9632		f3 ab					.word	SyntaxError                      ; $27 '
>9634		f3 ab					.word	SyntaxError                      ; $28 (
>9636		f3 ab					.word	SyntaxError                      ; $29 )
>9638		10 9c					.word	MulInteger                       ; $2a *
>963a		2b 9d					.word	AddInteger                       ; $2b +
>963c		f3 ab					.word	SyntaxError                      ; $2c ,
>963e		64 9d					.word	SubInteger                       ; $2d -
>9640		f3 ab					.word	SyntaxError                      ; $2e .
>9642		e2 9f					.word	FDivideCommand                   ; $2f /
>9644		f3 ab					.word	SyntaxError                      ; $30 0
>9646		f3 ab					.word	SyntaxError                      ; $31 1
>9648		f3 ab					.word	SyntaxError                      ; $32 2
>964a		f3 ab					.word	SyntaxError                      ; $33 3
>964c		f3 ab					.word	SyntaxError                      ; $34 4
>964e		f3 ab					.word	SyntaxError                      ; $35 5
>9650		f3 ab					.word	SyntaxError                      ; $36 6
>9652		f3 ab					.word	SyntaxError                      ; $37 7
>9654		f3 ab					.word	SyntaxError                      ; $38 8
>9656		f3 ab					.word	SyntaxError                      ; $39 9
>9658		f3 ab					.word	SyntaxError                      ; $3a :
>965a		f3 ab					.word	SyntaxError                      ; $3b ;
>965c		82 9a					.word	BinaryCompareLess                ; $3c <
>965e		78 9a					.word	BinaryCompareEqual               ; $3d =
>9660		8c 9a					.word	BinaryCompareGreater             ; $3e >
>9662		4a 9e					.word	ByteIndirect                     ; $3f ?
.9664						VectorSet0:
>9664		30 95					.word	EOLCommand                       ; $80 !0:EOF
>9666		d0 95					.word	Shift1Command                    ; $81 !1:SH1
>9668		d8 95					.word	Shift2Command                    ; $82 !2:SH2
>966a		cc a4					.word	AbsUnary                         ; $83 ABS(
>966c		da a4					.word	AllocUnary                       ; $84 ALLOC(
>966e		4a a5					.word	AscUnary                         ; $85 ASC(
>9670		9b a6					.word	ChrUnary                         ; $86 CHR$(
>9672		61 89					.word	UnaryEvent                       ; $87 EVENT(
>9674		74 9a					.word	UnaryFalse                       ; $88 FALSE
>9676		57 a5					.word	FracUnary                        ; $89 FRAC(
>9678		f7 a9					.word	ChrGet                           ; $8a GET$(
>967a		dc a9					.word	AscGet                           ; $8b GET(
>967c		86 a9					.word	UnaryGetDate                     ; $8c GETDATE$(
>967e		82 a9					.word	UnaryGetTime                     ; $8d GETTIME$(
>9680		0e b1					.word	UnaryHit                         ; $8e HIT(
>9682		fe a9					.word	ChrInkey                         ; $8f INKEY$(
>9684		ec a9					.word	AscInkey                         ; $90 INKEY(
>9686		6c a5					.word	IntUnary                         ; $91 INT(
>9688		5a a6					.word	IsValUnary                       ; $92 ISVAL(
>968a		ad a6					.word	ItemCountUnary                   ; $93 ITEMCOUNT(
>968c		d1 a6					.word	ItemGetUnary                     ; $94 ITEMGET$(
>968e		02 90					.word	UnaryJoyB                        ; $95 JOYB(
>9690		db 8f					.word	UnaryJoyX                        ; $96 JOYX(
>9692		de 8f					.word	UnaryJoyY                        ; $97 JOYY(
>9694		17 aa					.word	KeyDown                          ; $98 KEYDOWN(
>9696		10 a8					.word	Unary_Left                       ; $99 LEFT$(
>9698		7d a5					.word	LenUnary                         ; $9a LEN(
>969a		9b a5					.word	Unary_Max                        ; $9b MAX(
>969c		32 a8					.word	Unary_Mid                        ; $9c MID$(
>969e		97 a5					.word	Unary_Min                        ; $9d MIN(
>96a0		e6 a5					.word	Unary_Not                        ; $9e NOT(
>96a2		f9 a5					.word	PeekByteUnary                    ; $9f PEEK(
>96a4		05 a6					.word	PeekDUnary                       ; $a0 PEEKD(
>96a6		01 a6					.word	PeekLUnary                       ; $a1 PEEKL(
>96a8		fd a5					.word	PeekWUnary                       ; $a2 PEEKW(
>96aa		ca b1					.word	UnaryPlaying                     ; $a3 PLAYING(
>96ac		31 aa					.word	Unary_Random                     ; $a4 RANDOM(
>96ae		1d a8					.word	Unary_Right                      ; $a5 RIGHT$(
>96b0		4b aa					.word	Unary_Rnd                        ; $a6 RND(
>96b2		32 a6					.word	SgnUnary                         ; $a7 SGN(
>96b4		4f a7					.word	SpcUnary                         ; $a8 SPC(
>96b6		6a a7					.word	Unary_Str                        ; $a9 STR$(
>96b8		6d 98					.word	UnaryTimer                       ; $aa TIMER(
>96ba		69 9a					.word	UnaryTrue                        ; $ab TRUE
>96bc		50 a6					.word	ValUnary                         ; $ac VAL(
>96be		74 8d					.word	ForCommand                       ; $ad FOR
>96c0		b7 8e					.word	IfCommand                        ; $ae IF
>96c2		e0 95					.word	Unused1                          ; $af PROC
>96c4		dc 94					.word	Command_REPEAT                   ; $b0 REPEAT
>96c6		af 99					.word	Command_WHILE                    ; $b1 WHILE
>96c8		e0 8e					.word	EndIf                            ; $b2 ENDIF
>96ca		64 94					.word	Command_ENDPROC                  ; $b3 ENDPROC
>96cc		26 8e					.word	NextCommand                      ; $b4 NEXT
>96ce		e0 95					.word	Unused4                          ; $b5 THEN
>96d0		e5 94					.word	Command_UNTIL                    ; $b6 UNTIL
>96d2		d0 99					.word	Command_WEND                     ; $b7 WEND
>96d4		f3 ab					.word	SyntaxError                      ; $b8 AT
>96d6		f3 ab					.word	SyntaxError                      ; $b9 BY
>96d8		40 88					.word	CallCommand                      ; $ba CALL
>96da		c2 ae					.word	CircleCommand                    ; $bb CIRCLE
>96dc		f3 ab					.word	SyntaxError                      ; $bc CLEAR
>96de		f3 ab					.word	SyntaxError                      ; $bd COLOR
>96e0		f3 ab					.word	SyntaxError                      ; $be COLOUR
>96e2		87 88					.word	Command_Data                     ; $bf DATA
>96e4		8f 88					.word	DimCommand                       ; $c0 DIM
>96e6		e0 95					.word	Unused3                          ; $c1 DOWNTO
>96e8		d9 8e					.word	ElseCode                         ; $c2 ELSE
>96ea		f3 ab					.word	SyntaxError                      ; $c3 FROM
>96ec		e1 b0					.word	GfxCommand                       ; $c4 GFX
>96ee		f3 ab					.word	SyntaxError                      ; $c5 HERE
>96f0		eb ae					.word	ImageCommand                     ; $c6 IMAGE
>96f2		14 90					.word	LetCommand                       ; $c7 LET
>96f4		3d af					.word	LineCommand                      ; $c8 LINE
>96f6		6e 91					.word	Command_LOCAL                    ; $c9 LOCAL
>96f8		2f 92					.word	MCCommand                        ; $ca MEMCOPY
>96fa		f3 ab					.word	SyntaxError                      ; $cb OFF
>96fc		f3 ab					.word	SyntaxError                      ; $cc ON
>96fe		f3 ab					.word	SyntaxError                      ; $cd OUTLINE
>9700		32 b1					.word	PaletteCommand                   ; $ce PALETTE
>9702		36 af					.word	PlotCommand                      ; $cf PLOT
>9704		c9 93					.word	PokeBCommand                     ; $d0 POKE
>9706		d5 93					.word	PokeDCommand                     ; $d1 POKED
>9708		d1 93					.word	PokeLCommand                     ; $d2 POKEL
>970a		cd 93					.word	PokeWCommand                     ; $d3 POKEW
>970c		72 94					.word	Command_Read                     ; $d4 READ
>970e		be ae					.word	RectangleCommand                 ; $d5 RECT
>9710		cf 94					.word	RemCommand                       ; $d6 REM
>9712		f3 ab					.word	SyntaxError                      ; $d7 SOLID
>9714		e6 b1					.word	SoundCommand                     ; $d8 SOUND
>9716		cd ae					.word	SpriteCommand                    ; $d9 SPRITE
>9718		07 af					.word	TextCommand                      ; $da TEXT
>971a		e0 95					.word	Unused2                          ; $db TO
.971c						VectorSet1:
>971c		f3 ab					.word	SyntaxError                      ; $80 !0:EOF
>971e		f3 ab					.word	SyntaxError                      ; $81 !1:SH1
>9720		f3 ab					.word	SyntaxError                      ; $82 !2:SH2
>9722		14 88					.word	AssembleCommand                  ; $83 ASSEMBLE
>9724		30 88					.word	AssertCommand                    ; $84 ASSERT
>9726		81 b0					.word	BitmapCtrl                       ; $85 BITMAP
>9728		be 89					.word	Command_BLoad                    ; $86 BLOAD
>972a		6a 8a					.word	Command_BSave                    ; $87 BSAVE
>972c		72 b1					.word	ClearScreen                      ; $88 CLS
>972e		e6 8e					.word	Command_CPrint                   ; $89 CPRINT
>9730		ed 8a					.word	Command_Dir                      ; $8a DIR
>9732		4c 89					.word	BootDOS                          ; $8b DOS
>9734		bd 8b					.word	Command_Drive                    ; $8c DRIVE
>9736		5e 89					.word	EndCommand                       ; $8d END
>9738		9e b1					.word	Explode                          ; $8e EXPLODE
>973a		f3 ab					.word	SyntaxError                      ; $8f GO
>973c		7f 8e					.word	Command_GOSUB                    ; $90 GOSUB
>973e		9d 8e					.word	GotoCommand                      ; $91 GOTO
>9740		f3 ab					.word	SyntaxError                      ; $92 HIMEM
>9742		e1 8e					.word	Command_Input                    ; $93 INPUT
>9744		64 90					.word	Command_List                     ; $94 LIST
>9746		c4 8b					.word	Command_Load                     ; $95 LOAD
>9748		43 93					.word	MouseDeltaStatus                 ; $96 MDELTA
>974a		3f 93					.word	MouseStatus                      ; $97 MOUSE
>974c		b9 93					.word	NewCommand                       ; $98 NEW
>974e		7a b1					.word	PingCommand                      ; $99 PING
>9750		ed 8e					.word	Command_Print                    ; $9a PRINT
>9752		fe 94					.word	Command_Restore                  ; $9b RESTORE
>9754		8f 8e					.word	Command_RETURN                   ; $9c RETURN
>9756		3d 95					.word	CommandRUNOptLoad                ; $9d RUN
>9758		96 8c					.word	Command_Save                     ; $9e SAVE
>975a		f4 97					.word	CommandSetDate                   ; $9f SETDATE
>975c		f8 97					.word	CommandSetTime                   ; $a0 SETTIME
>975e		92 b1					.word	ShootCommand                     ; $a1 SHOOT
>9760		c6 b0					.word	SpritesCtrl                      ; $a2 SPRITES
>9762		68 98					.word	StopCommand                      ; $a3 STOP
>9764		1a 8d					.word	Command_VERIFY                   ; $a4 VERIFY
>9766		7e 88					.word	XGoCommand                       ; $a5 XGO
>9768		75 88					.word	XLoadCommand                     ; $a6 XLOAD
>976a		86 b1					.word	ZapCommand                       ; $a7 ZAP
.976c						VectorSet2:
>976c		f3 ab					.word	SyntaxError                      ; $80 !0:EOF
>976e		f3 ab					.word	SyntaxError                      ; $81 !1:SH1
>9770		f3 ab					.word	SyntaxError                      ; $82 !2:SH2
>9772		b2 aa					.word	Assemble_adc                     ; $83 ADC
>9774		aa aa					.word	Assemble_and                     ; $84 AND
>9776		c6 aa					.word	Assemble_asl                     ; $85 ASL
>9778		30 ab					.word	Assemble_bcc                     ; $86 BCC
>977a		34 ab					.word	Assemble_bcs                     ; $87 BCS
>977c		3c ab					.word	Assemble_beq                     ; $88 BEQ
>977e		f3 aa					.word	Assemble_bit                     ; $89 BIT
>9780		24 ab					.word	Assemble_bmi                     ; $8a BMI
>9782		38 ab					.word	Assemble_bne                     ; $8b BNE
>9784		20 ab					.word	Assemble_bpl                     ; $8c BPL
>9786		40 ab					.word	Assemble_bra                     ; $8d BRA
>9788		44 ab					.word	Assemble_brk                     ; $8e BRK
>978a		28 ab					.word	Assemble_bvc                     ; $8f BVC
>978c		2c ab					.word	Assemble_bvs                     ; $90 BVS
>978e		4c ab					.word	Assemble_clc                     ; $91 CLC
>9790		a0 ab					.word	Assemble_cld                     ; $92 CLD
>9792		60 ab					.word	Assemble_cli                     ; $93 CLI
>9794		90 ab					.word	Assemble_clv                     ; $94 CLV
>9796		be aa					.word	Assemble_cmp                     ; $95 CMP
>9798		07 ab					.word	Assemble_cpx                     ; $96 CPX
>979a		02 ab					.word	Assemble_cpy                     ; $97 CPY
>979c		e4 aa					.word	Assemble_dec                     ; $98 DEC
>979e		9c ab					.word	Assemble_dex                     ; $99 DEX
>97a0		78 ab					.word	Assemble_dey                     ; $9a DEY
>97a2		ae aa					.word	Assemble_eor                     ; $9b EOR
>97a4		e9 aa					.word	Assemble_inc                     ; $9c INC
>97a6		ac ab					.word	Assemble_inx                     ; $9d INX
>97a8		98 ab					.word	Assemble_iny                     ; $9e INY
>97aa		1b ab					.word	Assemble_jmp                     ; $9f JMP
>97ac		16 ab					.word	Assemble_jsr                     ; $a0 JSR
>97ae		ba aa					.word	Assemble_lda                     ; $a1 LDA
>97b0		df aa					.word	Assemble_ldx                     ; $a2 LDX
>97b2		fd aa					.word	Assemble_ldy                     ; $a3 LDY
>97b4		d0 aa					.word	Assemble_lsr                     ; $a4 LSR
>97b6		b0 ab					.word	Assemble_nop                     ; $a5 NOP
>97b8		a6 aa					.word	Assemble_ora                     ; $a6 ORA
>97ba		5c ab					.word	Assemble_pha                     ; $a7 PHA
>97bc		48 ab					.word	Assemble_php                     ; $a8 PHP
>97be		a4 ab					.word	Assemble_phx                     ; $a9 PHX
>97c0		64 ab					.word	Assemble_phy                     ; $aa PHY
>97c2		6c ab					.word	Assemble_pla                     ; $ab PLA
>97c4		50 ab					.word	Assemble_plp                     ; $ac PLP
>97c6		b8 ab					.word	Assemble_plx                     ; $ad PLX
>97c8		74 ab					.word	Assemble_ply                     ; $ae PLY
>97ca		cb aa					.word	Assemble_rol                     ; $af ROL
>97cc		d5 aa					.word	Assemble_ror                     ; $b0 ROR
>97ce		58 ab					.word	Assemble_rti                     ; $b1 RTI
>97d0		68 ab					.word	Assemble_rts                     ; $b2 RTS
>97d2		c2 aa					.word	Assemble_sbc                     ; $b3 SBC
>97d4		54 ab					.word	Assemble_sec                     ; $b4 SEC
>97d6		b4 ab					.word	Assemble_sed                     ; $b5 SED
>97d8		70 ab					.word	Assemble_sei                     ; $b6 SEI
>97da		b6 aa					.word	Assemble_sta                     ; $b7 STA
>97dc		a8 ab					.word	Assemble_stp                     ; $b8 STP
>97de		da aa					.word	Assemble_stx                     ; $b9 STX
>97e0		f8 aa					.word	Assemble_sty                     ; $ba STY
>97e2		ee aa					.word	Assemble_stz                     ; $bb STZ
>97e4		8c ab					.word	Assemble_tax                     ; $bc TAX
>97e6		88 ab					.word	Assemble_tay                     ; $bd TAY
>97e8		11 ab					.word	Assemble_trb                     ; $be TRB
>97ea		0c ab					.word	Assemble_tsb                     ; $bf TSB
>97ec		94 ab					.word	Assemble_tsx                     ; $c0 TSX
>97ee		7c ab					.word	Assemble_txa                     ; $c1 TXA
>97f0		84 ab					.word	Assemble_txs                     ; $c2 TXS
>97f2		80 ab					.word	Assemble_tya                     ; $c3 TYA

;******  Return to file: ./common/commands/run.asm


;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/commands/setdatetime.asm

.97f4						CommandSetDate:
.97f4		a9 03		lda #$03			lda 	#3
.97f6		80 02		bra $97fa			bra 	CSDTMain
.97f8						CommandSetTime:
.97f8		a9 00		lda #$00			lda 	#0
.97fa						CSDTMain:
.97fa		48		pha				pha 								; save table offsets 0 or 3
.97fb		a2 00		ldx #$00			ldx 	#0 							; input 3 values.
.97fd		20 f2 a8	jsr $a8f2			jsr 	Evaluate8BitInteger
.9800		20 e6 99	jsr $99e6			jsr 	CheckComma
.9803		e8		inx				inx
.9804		20 f2 a8	jsr $a8f2			jsr 	Evaluate8BitInteger
.9807		20 e6 99	jsr $99e6			jsr 	CheckComma
.980a		e8		inx				inx
.980b		20 f2 a8	jsr $a8f2			jsr 	Evaluate8BitInteger
.980e		68		pla				pla 								; table offset in Y, saving Y
.980f		5a		phy				phy
.9810		a8		tay				tay
.9811		a2 00		ldx #$00			ldx 	#0 							; first number
.9813		a5 01		lda $01				lda 	1 							; save I/O page, switch to zero
.9815		48		pha				pha
.9816		64 01		stz $01				stz 	1
.9818						_CSDTCopy:
.9818		b5 58		lda $58,x			lda 	NSMantissa0,x 				; get first number
.981a		d9 5c 98	cmp $985c,y			cmp 	RTCWMinValues,y 			; check range
.981d		90 1b		bcc $983a			bcc 	_CSDTRange
.981f		d9 62 98	cmp $9862,y			cmp 	RTCWMaxValues,y
.9822		b0 16		bcs $983a			bcs 	_CSDTRange
.9824		20 3f 98	jsr $983f			jsr 	CSDTDecimalToBCD
.9827		da		phx				phx 								; save X
.9828		be 56 98	ldx $9856,y			ldx 	RTCWOffset,y 				; offset in RTC in X
.982b		9d 90 d6	sta $d690,x			sta 	$D690,x 					; write to RTC
.982e		fa		plx				plx 								; restore X
.982f		e8		inx				inx 								; next number
.9830		c8		iny				iny 								; next table entries
.9831		e0 03		cpx #$03			cpx 	#3 							; until done all 3.
.9833		d0 e3		bne $9818			bne 	_CSDTCopy
.9835		68		pla				pla 								; restore I/O space
.9836		85 01		sta $01				sta 	1
.9838		7a		ply				ply 								; restore code pos and exit.
.9839		60		rts				rts
.983a						_CSDTRange:
.983a		a9 04		lda #$04		lda	#4
.983c		4c f7 99	jmp $99f7		jmp	ErrorHandler
.983f						CSDTDecimalToBCD:
.983f		da		phx				phx 								; 10 count in X
.9840		a2 00		ldx #$00			ldx 	#0
.9842						_CSDTDBLoop:
.9842		c9 0a		cmp #$0a			cmp 	#10 						; < 10 evaluate result.
.9844		90 05		bcc $984b			bcc 	_CSDTDBExit
.9846		e9 0a		sbc #$0a			sbc 	#10 						; 10 from value
.9848		e8		inx				inx 								; one more 10s.
.9849		80 f7		bra $9842			bra 	_CSDTDBLoop
.984b						_CSDTDBExit:
.984b		85 36		sta $36				sta 	zTemp0 						; units
.984d		8a		txa				txa 								; 10s x 16
.984e		0a		asl a				asl 	a
.984f		0a		asl a				asl 	a
.9850		0a		asl a				asl 	a
.9851		0a		asl a				asl 	a
.9852		05 36		ora $36				ora 	zTemp0 						; BCD result and exit
.9854		fa		plx				plx
.9855		60		rts				rts
.9856						RTCWOffset:
>9856		04 02 00 06 09 0a				.byte 	4,2,0,6,9,10
.985c						RTCWMinValues:
>985c		00 00 00 01 01 00				.byte 	0,0,0,1,1,0
.9862						RTCWMaxValues:
>9862		18 3c 3c 20 0d 64				.byte 	24,60,60,32,13,100

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/stop.asm

.9868						StopCommand:
.9868		a9 08		lda #$08		lda	#8
.986a		4c f7 99	jmp $99f7		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/commands/timer.asm

.986d						UnaryTimer:
.986d		fa		plx				plx
.986e		20 de 99	jsr $99de			jsr 	CheckRightBracket
.9871						TimerToStackX:
.9871		20 57 a9	jsr $a957			jsr 	NSMSetZero 					; zero result
.9874		64 01		stz $01				stz 	1 							; access I/O
.9876		ad 59 d6	lda $d659			lda 	$D659 						; copy timer in
.9879		95 58		sta $58,x			sta 	NSMantissa0,x
.987b		ad 5a d6	lda $d65a			lda 	$D65A
.987e		95 60		sta $60,x			sta 	NSMantissa1,x
.9880		ad 5b d6	lda $d65b			lda 	$D65B
.9883		95 68		sta $68,x			sta 	NSMantissa2,x
.9885		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/clear.asm

.9886						ClearSystem:
.9886		a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.9888		85 36		sta $36				sta 	0+zTemp0
.988a		a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.988c		85 37		sta $37				sta 	1+zTemp0
.988e						_ClearZeroLoop:
.988e		b2 36		lda ($36)			lda 	(zTemp0) 					; end of variables if offset is zero.
.9890		f0 24		beq $98b6			beq 	_ClearZeroEnd
.9892		a0 03		ldy #$03			ldy 	#3 							; erase the variables
.9894		a9 00		lda #$00			lda 	#0 							; set all the data to zero.
.9896						_ClearOneVariable:
.9896		91 36		sta ($36),y			sta 	(zTemp0),y
.9898		c8		iny				iny
.9899		c0 08		cpy #$08			cpy 	#8
.989b		d0 f9		bne $9896			bne 	_ClearOneVariable
.989d		a0 02		ldy #$02			ldy 	#2 							; has it been marked procedure
.989f		b1 36		lda ($36),y			lda 	(zTemp0),y
.98a1		c9 18		cmp #$18			cmp 	#NSTProcedure
.98a3		d0 04		bne $98a9			bne 	_ClearNotProcedure
.98a5		a9 04		lda #$04			lda 	#NSTInteger+NSBIsArray 		; if so set it back to an integer array
.98a7		91 36		sta ($36),y			sta 	(zTemp0),y 					; will be fixed on the pre-run scan.
.98a9						_ClearNotProcedure:
.98a9		18		clc				clc 								; go to the next variable
.98aa		b2 36		lda ($36)			lda 	(zTemp0) 					; offset to next, add to zTemp0
.98ac		65 36		adc $36				adc 	zTemp0
.98ae		85 36		sta $36				sta 	zTemp0
.98b0		90 dc		bcc $988e			bcc 	_ClearZeroLoop
.98b2		e6 37		inc $37				inc 	zTemp0+1
.98b4		80 d8		bra $988e			bra 	_ClearZeroLoop
.98b6						_ClearZeroEnd:
.98b6		18		clc				clc
.98b7		a5 36		lda $36				lda 	zTemp0
.98b9		69 01		adc #$01			adc 	#1
.98bb		8d 08 04	sta $0408			sta 	lowMemPtr
.98be		a5 37		lda $37				lda 	zTemp0+1
.98c0		69 00		adc #$00			adc 	#0
.98c2		8d 09 04	sta $0409			sta 	lowMemPtr+1
.98c5		20 d3 b2	jsr $b2d3			jsr 	StackReset
.98c8		20 39 b3	jsr $b339			jsr 	StringSystemInitialise
.98cb		20 e1 98	jsr $98e1			jsr 	ProcedureScan
.98ce		20 fe 94	jsr $94fe			jsr 	Command_Restore
.98d1		9c 1a 04	stz $041a			stz 	AssemblerAddress
.98d4		9c 1b 04	stz $041b			stz 	AssemblerAddress+1
.98d7		9c 1c 04	stz $041c			stz 	AssemblerControl
.98da		9c 5d 06	stz $065d			stz 	KeyboardQueueEntries
.98dd		20 37 a5	jsr $a537			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.98e0		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/procscan.asm

.98e1						ProcedureScan:
.98e1		20 15 95	jsr $9515			jsr 	SwapDataCodePtrs 			; swap code and data
.98e4		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.98e6		85 30		sta $30				sta 	codePtr
.98e8		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.98ea		85 31		sta $31				sta 	codePtr+1
.98ec						_PSLoop:
.98ec		b2 30		lda ($30)			lda 	(codePtr)
.98ee		f0 42		beq $9932			beq 	_PSExit
.98f0		a0 03		ldy #$03			ldy 	#3 							; is it PROC at start of line ?
.98f2		b1 30		lda ($30),y			lda 	(codePtr),y
.98f4		c9 af		cmp #$af			cmp 	#KWD_PROC
.98f6		d0 2d		bne $9925			bne 	_PSNext
.98f8		c8		iny				iny 								; get the address of the record to zTemp0 and
.98f9		b1 30		lda ($30),y			lda 	(codePtr),y
.98fb		29 c0		and #$c0			and 	#$C0
.98fd		c9 40		cmp #$40			cmp 	#$40
.98ff		d0 35		bne $9936			bne 	_PSSyntax
.9901		b1 30		lda ($30),y			lda 	(codePtr),y
.9903		18		clc				clc
.9904		69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.9906		85 37		sta $37				sta 	zTemp0+1
.9908		c8		iny				iny 								; LSB
.9909		b1 30		lda ($30),y			lda 	(codePtr),y
.990b		85 36		sta $36				sta 	zTemp0
.990d		c8		iny				iny 								; character after variable call.
.990e		98		tya				tya 								; save Y offset at +7 (exponent slot)
.990f		a0 07		ldy #$07			ldy 	#7
.9911		91 36		sta ($36),y			sta 	(zTemp0),y
.9913		a9 18		lda #$18			lda 	#NSTProcedure 				; mark it as procedure
.9915		a0 02		ldy #$02			ldy 	#2
.9917		91 36		sta ($36),y			sta 	(zTemp0),y
.9919		a2 00		ldx #$00			ldx 	#0 							; copy code-Ptr into offset 3-6 (mantissa)
.991b						_PSCopy:
.991b		b5 30		lda $30,x			lda 	safePtr,x
.991d		c8		iny				iny
.991e		91 36		sta ($36),y			sta 	(zTemp0),y
.9920		e8		inx				inx
.9921		e0 04		cpx #$04			cpx 	#4
.9923		d0 f6		bne $991b			bne 	_PSCopy
.9925						_PSNext:
.9925		18		clc				clc
.9926		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.9928		65 30		adc $30				adc 	codePtr
.992a		85 30		sta $30				sta 	codePtr
.992c		90 02		bcc $9930			bcc 	_CREExit
.992e		e6 31		inc $31				inc 	codePtr+1 					; carry
.9930						_CREExit:
.9930		80 ba		bra $98ec			bra 	_PSLoop
.9932						_PSExit:
.9932		20 15 95	jsr $9515			jsr 	SwapDataCodePtrs 			; swap code and data
.9935		60		rts				rts
.9936						_PSSyntax:
.9936		4c f3 ab	jmp $abf3			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/scanforward.asm

.9939						ScanForward:
.9939		64 38		stz $38				stz 	zTemp1 						; zero the structure count - goes up with WHILE/FOR down with WEND/NEXT etc.
.993b		86 37		stx $37				stx 	zTemp0+1
.993d		85 36		sta $36				sta 	zTemp0 						; save X & A as the two possible matches.
.993f						_ScanLoop:
.993f		b1 30		lda ($30),y			lda 	(codePtr),y
.9941		c8		iny				iny
.9942		a6 38		ldx $38				ldx 	zTemp1 						; if the count is > 0 cannot match as in substructure
.9944		d0 0e		bne $9954			bne 	_ScanGoNext
.9946		c5 36		cmp $36				cmp 	zTemp0 						; see if either matches
.9948		f0 04		beq $994e			beq 	_ScanMatch
.994a		c5 37		cmp $37				cmp 	zTemp0+1
.994c		d0 06		bne $9954			bne 	_ScanGoNext
.994e						_ScanMatch:
.994e		c9 80		cmp #$80			cmp 	#KWC_EOL 					; if asked for EOL, backtrack.
.9950		d0 01		bne $9953			bne 	_ScanNotEndEOL
.9952		88		dey				dey
.9953						_ScanNotEndEOL:
.9953		60		rts				rts
.9954						_ScanGoNext:
.9954		20 59 99	jsr $9959			jsr  	ScanForwardOne 				; allows for shifts and so on.
.9957		80 e6		bra $993f			bra 	_ScanLoop
.9959						ScanForwardOne:
.9959		c9 40		cmp #$40			cmp 	#$40 						; if 00-3F, punctuation characters, already done.
.995b		90 3e		bcc $999b			bcc 	_SFWExit
.995d		c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if 40-82, skip one extra as these are 2 byte
.995f		90 18		bcc $9979			bcc 	_ScanSkipOne	 			; offsets into the identifier table or shifts.
.9961		c9 fc		cmp #$fc			cmp 	#$FC 						; FC-FF are data skips (hex consts, strings etc.)
.9963		b0 2f		bcs $9994			bcs 	_ScanSkipData
.9965		c9 ad		cmp #$ad			cmp 	#KWC_FIRST_STRUCTURE 		; structure keyword ?
.9967		90 32		bcc $999b			bcc 	_SFWExit 					; if not, ordinary keywords.
.9969		c9 b8		cmp #$b8			cmp 	#KWC_LAST_STRUCTURE+1
.996b		b0 2e		bcs $999b			bcs 	_SFWExit
.996d		c6 38		dec $38				dec 	zTemp1 						; decrement the sructure count
.996f		c9 b2		cmp #$b2			cmp 	#KWC_FIRST_STRUCTURE_DEC 	; back if it is a dec structure (e.g. WEND/NEXT)
.9971		b0 28		bcs $999b			bcs 	_SFWExit
.9973		e6 38		inc $38				inc 	zTemp1 						; so it's an increment structure
.9975		e6 38		inc $38				inc 	zTemp1 						; twice to undo the dec
.9977		80 22		bra $999b			bra 	_SFWExit
.9979						_ScanSkipOne:
.9979		c8		iny				iny 								; consume the extra one.
.997a		c9 80		cmp #$80			cmp 	#KWC_EOL 					; if not EOL loop back
.997c		d0 1d		bne $999b			bne 	_SFWExit
.997e		18		clc				clc
.997f		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.9981		65 30		adc $30				adc 	codePtr
.9983		85 30		sta $30				sta 	codePtr
.9985		90 02		bcc $9989			bcc 	_CREExit
.9987		e6 31		inc $31				inc 	codePtr+1 					; carry
.9989						_CREExit:
.9989		a0 03		ldy #$03			ldy 	#3 							; scan start position.
.998b		b2 30		lda ($30)			lda 	(codePtr)
.998d		d0 0c		bne $999b			bne 	_SFWExit 					; if not zero, more to scan
.998f		a9 13		lda #$13		lda	#19
.9991		4c f7 99	jmp $99f7		jmp	ErrorHandler
.9994						_ScanSkipData:
.9994		88		dey				dey 								; point at data token
.9995		c8		iny				iny 								; point to offset
.9996		98		tya				tya 								; A = offset position
.9997		38		sec				sec 								; add size +1 hence SEC
.9998		71 30		adc ($30),y			adc 	(codePtr),y
.999a		a8		tay				tay 								; make current position.
.999b						_SFWExit:
.999b		60		rts				rts
.999c						ScanGetCurrentLineStep:
.999c		64 38		stz $38				stz 	zTemp1
.999e		a0 03		ldy #$03			ldy 	#3
.99a0						_SGCLSLoop:
.99a0		b1 30		lda ($30),y			lda 	(codePtr),y
.99a2		c8		iny				iny
.99a3		c9 80		cmp #$80			cmp 	#KWC_EOL	 				; if EOL exit
.99a5		f0 05		beq $99ac			beq 	_SGCLSExit
.99a7		20 59 99	jsr $9959			jsr 	ScanForwardOne
.99aa		80 f4		bra $99a0			bra 	_SGCLSLoop
.99ac						_SGCLSExit:
.99ac		a5 38		lda $38				lda 	zTemp1 						; return the adjustment
.99ae		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/while.asm

.99af						Command_WHILE:
.99af		5a		phy				phy 								; save position of the test
.99b0		a2 00		ldx #$00			ldx 	#0 							; work out the while test.
.99b2		20 a5 a8	jsr $a8a5			jsr 	EvaluateNumber
.99b5		20 79 a9	jsr $a979			jsr 	NSMIsZero 					; check if zero
.99b8		f0 0e		beq $99c8			beq 	_WHExitLoop 				; if so exit the loop, while has failed.
.99ba		98		tya				tya 								; position *after* test.
.99bb		7a		ply				ply 								; restore position before test, at WHILE
.99bc		88		dey				dey 								; so we execute the WHILE command again.
.99bd		48		pha				pha 								; push after test on the stack
.99be		a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; allocate 6 bytes on the return stack.
.99c0		20 6d b2	jsr $b26d			jsr 	StackOpen
.99c3		20 b2 b2	jsr $b2b2			jsr 	STKSaveCodePosition 		; save loop position - where the test value expr is.
.99c6		7a		ply				ply 								; restore the position *after* the test
.99c7		60		rts				rts
.99c8						_WHExitLoop:
.99c8		68		pla				pla 								; throw post loop position
.99c9		a9 b7		lda #$b7			lda 	#KWD_WEND 					; scan forward past WEND
.99cb		aa		tax				tax
.99cc		20 39 99	jsr $9939			jsr 	ScanForward
.99cf		60		rts				rts
.99d0						Command_WEND:
.99d0		a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; check WHILE is TOS e.g. in a while loop :)
.99d2		a2 10		ldx #$10			ldx 	#ERRID_WHILE 				; this error if not.
.99d4		20 9a b2	jsr $b29a			jsr 	StackCheckFrame
.99d7		20 c3 b2	jsr $b2c3			jsr 	STKLoadCodePosition 		; loop back to the WHILE keyword.
.99da		20 8c b2	jsr $b28c			jsr 	StackClose		 			; erase the frame
.99dd		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/charcheck.asm

.99de						CheckRightBracket:
.99de		b1 30		lda ($30),y			lda 	(codePtr),y
.99e0		c8		iny				iny
.99e1		c9 29		cmp #$29			cmp 	#KWD_RPAREN 						; exit if matches
.99e3		d0 0f		bne $99f4			bne 	CNAFail
.99e5		60		rts				rts
.99e6						CheckComma:
.99e6		b1 30		lda ($30),y			lda 	(codePtr),y
.99e8		c8		iny				iny
.99e9		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 						; exit if matches
.99eb		d0 07		bne $99f4			bne 	CNAFail
.99ed		60		rts				rts
.99ee						CheckNextA:
.99ee		d1 30		cmp ($30),y			cmp 	(codePtr),y
.99f0		d0 02		bne $99f4			bne 	CNAFail
.99f2		c8		iny				iny 								; skip character
.99f3		60		rts				rts 								; and exit
.99f4						CNAFail:
.99f4		4c f3 ab	jmp $abf3			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/errors.asm

.99f7						ErrorHandler:
.99f7		48		pha				pha 								; save error #
.99f8		a8		tay				tay 								; find the error text
.99f9		f0 4e		beq $9a49			beq 	_EHEnd
.99fb		a2 00		ldx #$00			ldx 	#0
.99fd		a9 0c		lda #$0c			lda 	#((ErrorText) & $FF)
.99ff		85 36		sta $36				sta 	0+zTemp0
.9a01		a9 ac		lda #$ac			lda 	#((ErrorText) >> 8)
.9a03		85 37		sta $37				sta 	1+zTemp0
.9a05						_EHFind:
.9a05		88		dey				dey 								; keep looking through text
.9a06		f0 0e		beq $9a16			beq 	_EHFound
.9a08						_EHFindZero:
.9a08		b2 36		lda ($36)			lda 	(zTemp0) 					; find the next error
.9a0a		e6 36		inc $36				inc 	zTemp0
.9a0c		d0 02		bne $9a10			bne 	_EHFNoCarry
.9a0e		e6 37		inc $37				inc 	zTemp0+1
.9a10						_EHFNoCarry:
.9a10		c9 00		cmp #$00			cmp 	#0
.9a12		d0 f4		bne $9a08			bne 	_EHFindZero
.9a14		80 ef		bra $9a05			bra 	_EHFind
.9a16						_EHFound:
.9a16		a5 36		lda $36				lda 	zTemp0 						; print message
.9a18		a6 37		ldx $37				ldx 	zTemp0+1
.9a1a		20 56 9a	jsr $9a56			jsr 	PrintStringXA
.9a1d		68		pla				pla  								; check if error is 'open structure'
.9a1e		c9 13		cmp #$13			cmp 	#ERRID_STRUCT
.9a20		f0 22		beq $9a44			beq 	_EHCREnd
.9a22		a0 01		ldy #$01			ldy 	#1 							; if line number zero don't print it
.9a24		b1 30		lda ($30),y			lda 	(codePtr),y
.9a26		d0 05		bne $9a2d			bne 	_EHAtMsg
.9a28		c8		iny				iny
.9a29		b1 30		lda ($30),y			lda 	(codePtr),y
.9a2b		f0 17		beq $9a44			beq 	_EHCREnd
.9a2d						_EHAtMsg:
.9a2d		a2 9a		ldx #$9a			ldx 	#_AtMsg >> 8 				; print " at "
.9a2f		a9 4c		lda #$4c			lda 	#_AtMsg & $FF
.9a31		20 56 9a	jsr $9a56			jsr 	PrintStringXA
.9a34		a0 01		ldy #$01			ldy 	#1 							; line number into XA
.9a36		b1 30		lda ($30),y			lda 	(codePtr),y
.9a38		48		pha				pha
.9a39		c8		iny				iny
.9a3a		b1 30		lda ($30),y			lda 	(codePtr),y
.9a3c		aa		tax				tax
.9a3d		68		pla				pla
.9a3e		20 6c 9e	jsr $9e6c			jsr 	ConvertInt16 				; convert XA to string
.9a41		20 56 9a	jsr $9a56			jsr 	PrintStringXA 				; and print it.
.9a44						_EHCREnd:
.9a44		a9 0d		lda #$0d			lda 	#13 						; new line
.9a46		20 43 80	jsr $8043			jsr 	EXTPrintCharacter
.9a49						_EHEnd:
.9a49		4c df 87	jmp $87df			jmp 	WarmStart
>9a4c		20 61 74 20 6c 69 6e 65		_AtMsg:	.text 	" at line ",0
>9a54		20 00
.9a56						PrintStringXA:
.9a56		5a		phy				phy
.9a57		86 37		stx $37				stx 	zTemp0+1
.9a59		85 36		sta $36				sta 	zTemp0
.9a5b		a0 00		ldy #$00			ldy 	#0
.9a5d						_PSXALoop:
.9a5d		b1 36		lda ($36),y			lda 	(zTemp0),y
.9a5f		f0 06		beq $9a67			beq 	_PSXAExit
.9a61		20 43 80	jsr $8043			jsr 	EXTPrintCharacter
.9a64		c8		iny				iny
.9a65		80 f6		bra $9a5d			bra 	_PSXALoop
.9a67						_PSXAExit:
.9a67		7a		ply				ply
.9a68		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/compare.asm

.9a69						UnaryTrue:
.9a69		fa		plx				plx
.9a6a						ReturnTrue:
.9a6a		a9 01		lda #$01			lda 	#1  						; set to 1
.9a6c		20 59 a9	jsr $a959			jsr 	NSMSetByte
.9a6f		a9 80		lda #$80			lda 	#$80 						; set sign flag, so it is -1
.9a71		95 50		sta $50,x			sta 	NSStatus,x
.9a73		60		rts				rts
.9a74						UnaryFalse:
.9a74		fa		plx				plx
.9a75						ReturnFalse:
.9a75		4c 57 a9	jmp $a957			jmp 	NSMSetZero 					; set it all to zero
.9a78						BinaryCompareEqual:
.9a78		fa		plx				plx
.9a79		20 b4 9a	jsr $9ab4			jsr 	CompareBaseCode
.9a7c		c9 00		cmp #$00			cmp 	#0
.9a7e		f0 ea		beq $9a6a			beq 	ReturnTrue
.9a80		80 f3		bra $9a75			bra 	ReturnFalse
.9a82						BinaryCompareLess:
.9a82		fa		plx				plx
.9a83		20 b4 9a	jsr $9ab4			jsr 	CompareBaseCode
.9a86		c9 ff		cmp #$ff			cmp 	#$FF
.9a88		f0 e0		beq $9a6a			beq 	ReturnTrue
.9a8a		80 e9		bra $9a75			bra 	ReturnFalse
.9a8c						BinaryCompareGreater:
.9a8c		fa		plx				plx
.9a8d		20 b4 9a	jsr $9ab4			jsr 	CompareBaseCode
.9a90		c9 01		cmp #$01			cmp 	#1
.9a92		f0 d6		beq $9a6a			beq 	ReturnTrue
.9a94		80 df		bra $9a75			bra 	ReturnFalse
.9a96						BinaryCompareNotEqual:
.9a96		fa		plx				plx
.9a97		20 b4 9a	jsr $9ab4			jsr 	CompareBaseCode
.9a9a		c9 00		cmp #$00			cmp 	#0
.9a9c		d0 cc		bne $9a6a			bne 	ReturnTrue
.9a9e		80 d5		bra $9a75			bra 	ReturnFalse
.9aa0						BinaryCompareLessEqual:
.9aa0		fa		plx				plx
.9aa1		20 b4 9a	jsr $9ab4			jsr 	CompareBaseCode
.9aa4		c9 01		cmp #$01			cmp 	#1
.9aa6		d0 c2		bne $9a6a			bne 	ReturnTrue
.9aa8		80 cb		bra $9a75			bra 	ReturnFalse
.9aaa						BinaryCompareGreaterEqual:
.9aaa		fa		plx				plx
.9aab		20 b4 9a	jsr $9ab4			jsr 	CompareBaseCode
.9aae		c9 ff		cmp #$ff			cmp 	#$FF
.9ab0		d0 b8		bne $9a6a			bne 	ReturnTrue
.9ab2		80 c1		bra $9a75			bra 	ReturnFalse
.9ab4						CompareBaseCode:
.9ab4		20 bf a1	jsr $a1bf			jsr 	DereferenceTopTwo 			; make both values if references.
.9ab7		b5 50		lda $50,x			lda 	NSStatus,x 					; check if either is a string.
.9ab9		15 51		ora $51,x			ora 	NSStatus+1,x
.9abb		29 10		and #$10			and 	#NSTString
.9abd		d0 37		bne $9af6			bne 	_CBCString 					; if so do string code, which will check if both.
.9abf		b5 78		lda $78,x			lda 	NSExponent,x 				; check both are integers
.9ac1		15 79		ora $79,x			ora 	NSExponent+1,x
.9ac3		d0 34		bne $9af9			bne 	_CBCFloat
.9ac5		b5 50		lda $50,x			lda 	NSStatus,x
.9ac7		15 51		ora $51,x			ora 	NSStatus+1,x
.9ac9		29 08		and #$08			and 	#NSTFloat
.9acb		d0 2c		bne $9af9			bne 	_CBCFloat
.9acd		20 fc 9a	jsr $9afc			jsr 	CompareFixMinusZero 		; fix up -0 just in cases.
.9ad0		e8		inx				inx
.9ad1		20 fc 9a	jsr $9afc			jsr 	CompareFixMinusZero
.9ad4		ca		dex				dex
.9ad5		b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs different ?
.9ad7		55 51		eor $51,x			eor 	NSStatus+1,x
.9ad9		10 0a		bpl $9ae5			bpl 	_CDCSameSign
.9adb		b5 50		lda $50,x			lda 	NSStatus,x 					; if first one is -ve
.9add		30 14		bmi $9af3			bmi 	_CBCLess 					; return $FF
.9adf						_CBCGreater:
.9adf		a9 01		lda #$01			lda 	#1
.9ae1		60		rts				rts
.9ae2						_CBCEqual:
.9ae2		a9 00		lda #$00			lda 	#0
.9ae4		60		rts				rts
.9ae5						_CDCSameSign:
.9ae5		20 11 9d	jsr $9d11			jsr 	SubTopTwoStack 				; unsigned subtract
.9ae8		20 79 a9	jsr $a979			jsr 	NSMIsZero 					; or the mantissa together
.9aeb		f0 f5		beq $9ae2			beq 	_CBCEqual 					; -0 == 0
.9aed		b5 70		lda $70,x			lda 	NSMantissa3,x 				; sign of the result. if +ve return $01 else return $FF
.9aef		55 51		eor $51,x			eor 	NSStatus+1,x 				; however if both were -ve this is inverted
.9af1		10 ec		bpl $9adf			bpl 	_CBCGreater
.9af3						_CBCLess:
.9af3		a9 ff		lda #$ff			lda 	#$FF
.9af5		60		rts				rts
.9af6						_CBCString:
.9af6		4c 82 9c	jmp $9c82			jmp 	CompareStrings
.9af9						_CBCFloat:
.9af9		4c cc 9f	jmp $9fcc			jmp 	CompareFloat
.9afc						CompareFixMinusZero:
.9afc		20 79 a9	jsr $a979			jsr 	NSMIsZero
.9aff		d0 02		bne $9b03			bne 	_CFXMZNotZero
.9b01		74 50		stz $50,x			stz 	NSStatus,x
.9b03						_CFXMZNotZero:
.9b03		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/concat.asm

.9b04						StringConcat:
.9b04		b5 50		lda $50,x			lda 	NSStatus,x 					; check both strings
.9b06		35 51		and $51,x			and 	NSStatus+1,x
.9b08		29 18		and #$18			and 	#NSBTypeMask
.9b0a		c9 10		cmp #$10			cmp 	#NSTString
.9b0c		d0 50		bne $9b5e			bne		_SCType
.9b0e		64 38		stz $38				stz 	zTemp1 						; counting total length
.9b10		e8		inx				inx
.9b11		20 2f 9b	jsr $9b2f			jsr 	_SCSetupZ0 					; setup for second
.9b14		20 38 9b	jsr $9b38			jsr 	_SCLengthZ0 				; length for second
.9b17		ca		dex				dex
.9b18		20 2f 9b	jsr $9b2f			jsr 	_SCSetupZ0 					; setup for first
.9b1b		20 38 9b	jsr $9b38			jsr 	_SCLengthZ0 				; length for first
.9b1e		a5 38		lda $38				lda 	zTemp1 						; allocate memory using total.
.9b20		20 5d b3	jsr $b35d			jsr 	StringTempAllocate
.9b23		20 4f 9b	jsr $9b4f			jsr 	_SCCopy 					; copy first out, using zTemp0 from above
.9b26		e8		inx				inx
.9b27		20 2f 9b	jsr $9b2f			jsr 	_SCSetupZ0 					; copy second out
.9b2a		20 4f 9b	jsr $9b4f			jsr 	_SCCopy
.9b2d		ca		dex				dex
.9b2e		60		rts				rts
.9b2f						_SCSetupZ0:
.9b2f		b5 58		lda $58,x			lda 	NSMantissa0,x
.9b31		85 36		sta $36				sta 	zTemp0
.9b33		b5 60		lda $60,x			lda 	NSMantissa1,x
.9b35		85 37		sta $37				sta 	zTemp0+1
.9b37		60		rts				rts
.9b38						_SCLengthZ0:
.9b38		5a		phy				phy
.9b39		a0 00		ldy #$00			ldy 	#0
.9b3b						_SCLenLoop:
.9b3b		b1 36		lda ($36),y			lda 	(zTemp0),y
.9b3d		f0 0e		beq $9b4d			beq 	_SCLExit
.9b3f		c8		iny				iny
.9b40		e6 38		inc $38				inc 	zTemp1
.9b42		a5 38		lda $38				lda	 	zTemp1 						; check string too long.
.9b44		c9 fd		cmp #$fd			cmp 	#253
.9b46		d0 f3		bne $9b3b			bne		_SCLenLoop
.9b48		a9 09		lda #$09		lda	#9
.9b4a		4c f7 99	jmp $99f7		jmp	ErrorHandler
.9b4d						_SCLExit:
.9b4d		7a		ply				ply
.9b4e		60		rts				rts
.9b4f						_SCCopy:
.9b4f		5a		phy				phy
.9b50		a0 00		ldy #$00			ldy 	#0
.9b52						_SCCopyLoop:
.9b52		b1 36		lda ($36),y			lda 	(zTemp0),y
.9b54		f0 06		beq $9b5c			beq 	_SCCExit
.9b56		20 96 b3	jsr $b396			jsr 	StringTempWrite
.9b59		c8		iny				iny
.9b5a		80 f6		bra $9b52			bra 	_SCCopyLoop
.9b5c						_SCCExit:
.9b5c		7a		ply				ply
.9b5d		60		rts				rts
.9b5e						_SCType:
.9b5e		4c fd ab	jmp $abfd			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/divide.asm

.9b61						IntegerDivide:
.9b61		fa		plx				plx
.9b62		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9b64		15 51		ora $51,x			ora 	NSStatus+1,x
.9b66		0a		asl a				asl 	a 							; shift reference bit into sign bit
.9b67		0a		asl a				asl 	a
.9b68		10 05		bpl $9b6f			bpl 	_NotRef
.9b6a		48		pha				pha
.9b6b		20 bf a1	jsr $a1bf			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9b6e		68		pla				pla
.9b6f						_NotRef:
.9b6f		0a		asl a				asl 	a
.9b70		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9b72		15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9b74		15 79		ora $79,x			ora 	NSExponent+1,x
.9b76		f0 03		beq $9b7b			beq 	_IntegerCode 				; if clear, then we have two integers
.9b78		4c fd ab	jmp $abfd			jmp 	TypeError 					; anything else, type mismatch.
.9b7b						_IntegerCode:
.9b7b		20 95 9b	jsr $9b95			jsr 	CheckDivideZero 			; do div zero check
.9b7e		20 c7 9b	jsr $9bc7			jsr 	Int32Divide 				; do the division
.9b81		20 78 9c	jsr $9c78			jsr 	CalculateSign 				; calculate result sign
.9b84						NSMCopyPlusTwoToZero:
.9b84		b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.9b86		95 58		sta $58,x			sta 	NSMantissa0,x
.9b88		b5 62		lda $62,x			lda 	NSMantissa1+2,x
.9b8a		95 60		sta $60,x			sta 	NSMantissa1,x
.9b8c		b5 6a		lda $6a,x			lda 	NSMantissa2+2,x
.9b8e		95 68		sta $68,x			sta 	NSMantissa2,x
.9b90		b5 72		lda $72,x			lda 	NSMantissa3+2,x
.9b92		95 70		sta $70,x			sta 	NSMantissa3,x
.9b94		60		rts				rts
.9b95						CheckDivideZero:
.9b95		e8		inx				inx
.9b96		20 79 a9	jsr $a979			jsr 	NSMIsZero
.9b99		f0 02		beq $9b9d			beq 	_CDVError
.9b9b		ca		dex				dex
.9b9c		60		rts				rts
.9b9d						_CDVError:
.9b9d		a9 03		lda #$03		lda	#3
.9b9f		4c f7 99	jmp $99f7		jmp	ErrorHandler
.9ba2						IntegerModulus:
.9ba2		fa		plx				plx
.9ba3		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9ba5		15 51		ora $51,x			ora 	NSStatus+1,x
.9ba7		0a		asl a				asl 	a 							; shift reference bit into sign bit
.9ba8		0a		asl a				asl 	a
.9ba9		10 05		bpl $9bb0			bpl 	_NotRef
.9bab		48		pha				pha
.9bac		20 bf a1	jsr $a1bf			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9baf		68		pla				pla
.9bb0						_NotRef:
.9bb0		0a		asl a				asl 	a
.9bb1		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9bb3		15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9bb5		15 79		ora $79,x			ora 	NSExponent+1,x
.9bb7		f0 03		beq $9bbc			beq 	_IntegerCode 				; if clear, then we have two integers
.9bb9		4c fd ab	jmp $abfd			jmp 	TypeError 					; anything else, type mismatch.
.9bbc						_IntegerCode:
.9bbc						IntegerModulusNoCheck:
.9bbc		20 95 9b	jsr $9b95			jsr 	CheckDivideZero 			; do div zero check
.9bbf		20 c7 9b	jsr $9bc7			jsr 	Int32Divide 				; do the division
.9bc2		16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.9bc4		56 50		lsr $50,x			lsr 	NSStatus,x
.9bc6		60		rts				rts
.9bc7						Int32Divide:
.9bc7		48		pha				pha 								; save AXY
.9bc8		5a		phy				phy
.9bc9		20 3a a9	jsr $a93a			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.9bcc		20 53 a9	jsr $a953			jsr 	NSMSetZeroMantissaOnly 		; set S[X] to zero
.9bcf		a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.9bd1						_I32DivideLoop:
.9bd1		e8		inx				inx
.9bd2		e8		inx				inx
.9bd3		20 66 a9	jsr $a966			jsr 	NSMShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.9bd6		ca		dex				dex
.9bd7		ca		dex				dex
.9bd8		20 67 a9	jsr $a967			jsr 	NSMRotateLeft
.9bdb		20 06 9c	jsr $9c06			jsr 	DivideCheckSubtract 		; check if subtract possible
.9bde		90 02		bcc $9be2			bcc 	_I32DivideNoCarryIn
.9be0		f6 5a		inc $5a,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.9be2						_I32DivideNoCarryIn:
.9be2		88		dey				dey 								; loop round till division completed.
.9be3		d0 ec		bne $9bd1			bne 	_I32DivideLoop
.9be5		7a		ply				ply 								; restore AXY and exit
.9be6		68		pla				pla
.9be7		60		rts				rts
.9be8						Int32ShiftDivide:
.9be8		48		pha				pha 								; save AY
.9be9		5a		phy				phy
.9bea		e8		inx				inx 								; clear S[X+2]
.9beb		e8		inx				inx
.9bec		20 57 a9	jsr $a957			jsr 	NSMSetZero
.9bef		ca		dex				dex
.9bf0		ca		dex				dex
.9bf1		a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.9bf3						_I32SDLoop:
.9bf3		20 06 9c	jsr $9c06			jsr 	DivideCheckSubtract 		; check if subtract possible
.9bf6		e8		inx				inx
.9bf7		e8		inx				inx
.9bf8		20 67 a9	jsr $a967			jsr 	NSMRotateLeft				; shift 64 bit FPA left, rotating carry in
.9bfb		ca		dex				dex
.9bfc		ca		dex				dex
.9bfd		20 67 a9	jsr $a967			jsr 	NSMRotateLeft
.9c00		88		dey				dey 	 							; do 31 times
.9c01		d0 f0		bne $9bf3			bne 	_I32SDLoop
.9c03		7a		ply				ply 								; restore AY and exit
.9c04		68		pla				pla
.9c05		60		rts				rts
.9c06						DivideCheckSubtract:
.9c06		20 11 9d	jsr $9d11			jsr 	SubTopTwoStack 				; subtract Stack[X+1] from Stack[X+0]
.9c09		b0 04		bcs $9c0f			bcs 	_DCSExit 					; if carry set, then could do, exit
.9c0b		20 f7 9c	jsr $9cf7			jsr 	AddTopTwoStack 				; add it back in
.9c0e		18		clc				clc 								; and return False
.9c0f						_DCSExit:
.9c0f		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/multiply.asm

.9c10						MulInteger:
.9c10		fa		plx				plx
.9c11		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9c13		15 51		ora $51,x			ora 	NSStatus+1,x
.9c15		0a		asl a				asl 	a 							; shift reference bit into sign bit
.9c16		0a		asl a				asl 	a
.9c17		10 05		bpl $9c1e			bpl 	_NotRef
.9c19		48		pha				pha
.9c1a		20 bf a1	jsr $a1bf			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9c1d		68		pla				pla
.9c1e						_NotRef:
.9c1e		0a		asl a				asl 	a 							; put MSB of type into A:7
.9c1f		30 09		bmi $9c2a			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9c21		b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9c23		15 79		ora $79,x			ora 	NSExponent+1,x
.9c25		f0 06		beq $9c2d			beq 	_IntegerCode 				; if clear, then we have two integers
.9c27		4c 8e a0	jmp $a08e			jmp 	FloatingPointMultiply 							; otherwise at least one float.
.9c2a						_StringData:
.9c2a		4c 07 ac	jmp $ac07			jmp 	NotDoneError							; at least one string - don't know both are strings.
.9c2d						_IntegerCode:
.9c2d		20 3a 9c	jsr $9c3a			jsr 	MultiplyShort
.9c30		c9 00		cmp #$00			cmp 	#0
.9c32		f0 05		beq $9c39			beq 	_MIExit
.9c34		a9 04		lda #$04		lda	#4
.9c36		4c f7 99	jmp $99f7		jmp	ErrorHandler
.9c39						_MIExit:
.9c39		60		rts				rts
.9c3a						MultiplyShort:
.9c3a		5a		phy				phy 								; save Y
.9c3b		20 3a a9	jsr $a93a			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.9c3e		20 53 a9	jsr $a953			jsr 	NSMSetZeroMantissaOnly 		; set mantissa S[X] to zero
.9c41		a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.9c43						_I32MLoop:
.9c43		b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.9c45		15 62		ora $62,x			ora 	NSMantissa1+2,x
.9c47		15 6a		ora $6a,x			ora 	NSMantissa2+2,x
.9c49		15 72		ora $72,x			ora 	NSMantissa3+2,x
.9c4b		f0 25		beq $9c72			beq 	_I32MExit 					; exit if zero
.9c4d		b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.9c4f		29 01		and #$01			and 	#1
.9c51		f0 0d		beq $9c60			beq 	_I32MNoAdd
.9c53		20 f7 9c	jsr $9cf7			jsr 	AddTopTwoStack 				; if so add S[X+1] to S[X+0]
.9c56		b5 70		lda $70,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.9c58		10 06		bpl $9c60			bpl 	_I32MNoAdd
.9c5a						_I32ShiftRight:
.9c5a		20 70 a9	jsr $a970			jsr 	NSMShiftRight 				; shift S[X] right
.9c5d		c8		iny				iny 								; increment shift count
.9c5e		80 09		bra $9c69			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.9c60						_I32MNoAdd:
.9c60		34 71		bit $71,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.9c62		70 f6		bvs $9c5a			bvs 	_I32ShiftRight 				; instead.
.9c64		e8		inx				inx
.9c65		20 66 a9	jsr $a966			jsr 	NSMShiftLeft 				; shift additive S[X+1] left
.9c68		ca		dex				dex
.9c69						_I32MShiftUpper:
.9c69		e8		inx				inx 								; shift S[X+2] right
.9c6a		e8		inx				inx
.9c6b		20 70 a9	jsr $a970			jsr 	NSMShiftRight
.9c6e		ca		dex				dex
.9c6f		ca		dex				dex
.9c70		80 d1		bra $9c43			bra 	_I32MLoop 					; try again.
.9c72						_I32MExit:
.9c72		20 78 9c	jsr $9c78			jsr 	CalculateSign
.9c75		98		tya				tya 								; shift in A
.9c76		7a		ply				ply 								; restore Y and exit
.9c77		60		rts				rts
.9c78						CalculateSign:
.9c78		b5 50		lda $50,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.9c7a		16 50		asl $50,x			asl 	NSStatus,x 					; shift result left
.9c7c		55 51		eor $51,x			eor 	NSStatus+1,x
.9c7e		0a		asl a				asl 	a 							; shift bit 7 into carry
.9c7f		76 50		ror $50,x			ror 	NSStatus,x 					; shift right into status byte.
.9c81		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/scompare.asm

.9c82						CompareStrings:
.9c82		b5 50		lda $50,x			lda 	NSStatus,x 					; check both are strings
.9c84		35 51		and $51,x			and 	NSStatus+1,x
.9c86		29 10		and #$10			and 	#NSBIsString
.9c88		f0 28		beq $9cb2			beq 	_CSTypeError
.9c8a		b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy string addresses to zTemp0/1
.9c8c		85 36		sta $36				sta 	zTemp0
.9c8e		b5 60		lda $60,x			lda 	NSMantissa1,x
.9c90		85 37		sta $37				sta 	zTemp0+1
.9c92		b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9c94		85 38		sta $38				sta 	zTemp1
.9c96		b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9c98		85 39		sta $39				sta 	zTemp1+1
.9c9a		5a		phy				phy 								; save Y so we can access strings
.9c9b		a0 ff		ldy #$ff			ldy 	#$FF 						; -1 for pre increment.
.9c9d						_CSLoop:
.9c9d		c8		iny				iny
.9c9e		b1 36		lda ($36),y			lda 	(zTemp0),y 					; check if they are the same
.9ca0		d1 38		cmp ($38),y			cmp 	(zTemp1),y
.9ca2		d0 06		bne $9caa			bne 	_CSDifferent
.9ca4		c9 00		cmp #$00			cmp 	#0 							; reached end ?
.9ca6		d0 f5		bne $9c9d			bne 	_CSLoop 					; still comparing
.9ca8						_CSExit:
.9ca8		7a		ply				ply 								; reached end, return zero in A from EOS
.9ca9		60		rts				rts
.9caa						_CSDifferent:
.9caa		a9 ff		lda #$ff			lda 	#255 						; if < return $FF
.9cac		90 fa		bcc $9ca8			bcc		_CSExit
.9cae		a9 01		lda #$01			lda 	#1 							; otherwise return 1.
.9cb0		80 f6		bra $9ca8			bra 	_CSExit
.9cb2						_CSTypeError:
.9cb2		4c fd ab	jmp $abfd			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/shifts.asm

.9cb5						ShiftLeft:
.9cb5		38		sec				sec 								; common code, carry determines which way.
.9cb6		80 01		bra $9cb9			bra 	ShiftMain
.9cb8						ShiftRight:
.9cb8		18		clc				clc
.9cb9						ShiftMain:
.9cb9		fa		plx				plx 								; restore X
.9cba		08		php				php 								; save direction
.9cbb		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9cbd		15 51		ora $51,x			ora 	NSStatus+1,x
.9cbf		0a		asl a				asl 	a 							; shift reference bit into sign bit
.9cc0		0a		asl a				asl 	a
.9cc1		10 05		bpl $9cc8			bpl 	_NotRef
.9cc3		48		pha				pha
.9cc4		20 bf a1	jsr $a1bf			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9cc7		68		pla				pla
.9cc8						_NotRef:
.9cc8		0a		asl a				asl 	a
.9cc9		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9ccb		15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9ccd		15 79		ora $79,x			ora 	NSExponent+1,x
.9ccf		f0 03		beq $9cd4			beq 	_IntegerCode 				; if clear, then we have two integers
.9cd1		4c fd ab	jmp $abfd			jmp 	TypeError 					; anything else, type mismatch.
.9cd4						_IntegerCode:
.9cd4		b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; check number < 32
.9cd6		29 e0		and #$e0			and 	#$E0
.9cd8		15 61		ora $61,x			ora 	NSMantissa1+1,x
.9cda		15 69		ora $69,x			ora 	NSMantissa2+1,x
.9cdc		15 71		ora $71,x			ora 	NSMantissa3+1,x
.9cde		d0 12		bne $9cf2			bne 	_SMExit0 					; if >= 32 it will always return zero.
.9ce0						_SMLoop:
.9ce0		d6 59		dec $59,x			dec 	NSMantissa0+1,x 			; predecrement, could do << 0
.9ce2		30 11		bmi $9cf5			bmi 	_SMExit 					; exit if done.
.9ce4		28		plp				plp 								; restore direction setting
.9ce5		08		php				php
.9ce6		90 05		bcc $9ced			bcc 	_SMRight
.9ce8		20 66 a9	jsr $a966			jsr 	NSMShiftLeft 				; shift left if CS
.9ceb		80 f3		bra $9ce0			bra 	_SMLoop
.9ced						_SMRight:
.9ced		20 70 a9	jsr $a970			jsr 	NSMShiftRight 				; shift right if CC
.9cf0		80 ee		bra $9ce0			bra 	_SMLoop
.9cf2						_SMExit0:
.9cf2		20 57 a9	jsr $a957			jsr 	NSMSetZero 					; return zero.
.9cf5						_SMExit:
.9cf5		28		plp				plp 								; throw direction
.9cf6		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/simple.asm

.9cf7						AddTopTwoStack:
.9cf7		18		clc				clc
.9cf8		b5 58		lda $58,x			lda		NSMantissa0,x
.9cfa		75 59		adc $59,x			adc 		NSMantissa0+1,x
.9cfc		95 58		sta $58,x			sta 	NSMantissa0,x
.9cfe		b5 60		lda $60,x			lda		NSMantissa1,x
.9d00		75 61		adc $61,x			adc 		NSMantissa1+1,x
.9d02		95 60		sta $60,x			sta 	NSMantissa1,x
.9d04		b5 68		lda $68,x			lda		NSMantissa2,x
.9d06		75 69		adc $69,x			adc 		NSMantissa2+1,x
.9d08		95 68		sta $68,x			sta 	NSMantissa2,x
.9d0a		b5 70		lda $70,x			lda		NSMantissa3,x
.9d0c		75 71		adc $71,x			adc 		NSMantissa3+1,x
.9d0e		95 70		sta $70,x			sta 	NSMantissa3,x
.9d10		60		rts				rts
.9d11						SubTopTwoStack:
.9d11		38		sec				sec
.9d12		b5 58		lda $58,x			lda		NSMantissa0,x
.9d14		f5 59		sbc $59,x			sbc 		NSMantissa0+1,x
.9d16		95 58		sta $58,x			sta 	NSMantissa0,x
.9d18		b5 60		lda $60,x			lda		NSMantissa1,x
.9d1a		f5 61		sbc $61,x			sbc 		NSMantissa1+1,x
.9d1c		95 60		sta $60,x			sta 	NSMantissa1,x
.9d1e		b5 68		lda $68,x			lda		NSMantissa2,x
.9d20		f5 69		sbc $69,x			sbc 		NSMantissa2+1,x
.9d22		95 68		sta $68,x			sta 	NSMantissa2,x
.9d24		b5 70		lda $70,x			lda		NSMantissa3,x
.9d26		f5 71		sbc $71,x			sbc 		NSMantissa3+1,x
.9d28		95 70		sta $70,x			sta 	NSMantissa3,x
.9d2a		60		rts				rts
.9d2b						AddInteger:
.9d2b		fa		plx				plx
.9d2c		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9d2e		15 51		ora $51,x			ora 	NSStatus+1,x
.9d30		0a		asl a				asl 	a 							; shift reference bit into sign bit
.9d31		0a		asl a				asl 	a
.9d32		10 05		bpl $9d39			bpl 	_NotRef
.9d34		48		pha				pha
.9d35		20 bf a1	jsr $a1bf			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9d38		68		pla				pla
.9d39						_NotRef:
.9d39		0a		asl a				asl 	a 							; put MSB of type into A:7
.9d3a		30 09		bmi $9d45			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9d3c		b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9d3e		15 79		ora $79,x			ora 	NSExponent+1,x
.9d40		f0 06		beq $9d48			beq 	_IntegerCode 				; if clear, then we have two integers
.9d42		4c 3e 9f	jmp $9f3e			jmp 	FloatingPointAdd 							; otherwise at least one float.
.9d45						_StringData:
.9d45		4c 04 9b	jmp $9b04			jmp 	StringConcat							; at least one string - don't know both are strings.
.9d48						_IntegerCode:
.9d48						AddCode:
.9d48		b5 50		lda $50,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.9d4a		55 51		eor $51,x			eor 	NSStatus+1,x
.9d4c		10 a9		bpl $9cf7			bpl 	AddTopTwoStack
.9d4e		20 11 9d	jsr $9d11			jsr 	SubTopTwoStack 				; do a physical subtraction
.9d51		34 70		bit $70,x			bit 	NSMantissa3,x 				; result is +ve, okay
.9d53		10 07		bpl $9d5c			bpl 	_AddExit
.9d55		b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign is that of 2nd value
.9d57		95 50		sta $50,x			sta 	NSStatus,x
.9d59		20 20 a9	jsr $a920			jsr 	NSMNegateMantissa 			; negate the mantissa and exit
.9d5c						_AddExit:
.9d5c		20 79 a9	jsr $a979			jsr 	NSMIsZero 					; check for -0
.9d5f		d0 02		bne $9d63			bne 	_AddNonZero
.9d61		74 50		stz $50,x			stz 	NSStatus,x
.9d63						_AddNonZero:
.9d63		60		rts				rts
.9d64						SubInteger:
.9d64		fa		plx				plx
.9d65		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9d67		15 51		ora $51,x			ora 	NSStatus+1,x
.9d69		0a		asl a				asl 	a 							; shift reference bit into sign bit
.9d6a		0a		asl a				asl 	a
.9d6b		10 05		bpl $9d72			bpl 	_NotRef
.9d6d		48		pha				pha
.9d6e		20 bf a1	jsr $a1bf			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9d71		68		pla				pla
.9d72						_NotRef:
.9d72		0a		asl a				asl 	a 							; put MSB of type into A:7
.9d73		30 09		bmi $9d7e			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9d75		b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9d77		15 79		ora $79,x			ora 	NSExponent+1,x
.9d79		f0 06		beq $9d81			beq 	_IntegerCode 				; if clear, then we have two integers
.9d7b		4c 43 9f	jmp $9f43			jmp 	FloatingPointSub 							; otherwise at least one float.
.9d7e						_StringData:
.9d7e		4c 07 ac	jmp $ac07			jmp 	NotDoneError							; at least one string - don't know both are strings.
.9d81						_IntegerCode:
.9d81		b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate the second value.
.9d83		49 80		eor #$80			eor 	#$80
.9d85		95 51		sta $51,x			sta 	NSStatus+1,x
.9d87		80 bf		bra $9d48			bra 	AddCode 					; and do the same code as add.
.9d89						AndInteger:
.9d89		fa		plx				plx
.9d8a		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9d8c		15 51		ora $51,x			ora 	NSStatus+1,x
.9d8e		0a		asl a				asl 	a 							; shift reference bit into sign bit
.9d8f		0a		asl a				asl 	a
.9d90		10 05		bpl $9d97			bpl 	_NotRef
.9d92		48		pha				pha
.9d93		20 bf a1	jsr $a1bf			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9d96		68		pla				pla
.9d97						_NotRef:
.9d97		0a		asl a				asl 	a
.9d98		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9d9a		15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9d9c		15 79		ora $79,x			ora 	NSExponent+1,x
.9d9e		f0 03		beq $9da3			beq 	_IntegerCode 				; if clear, then we have two integers
.9da0		4c fd ab	jmp $abfd			jmp 	TypeError 					; anything else, type mismatch.
.9da3						_IntegerCode:
.9da3		b5 58		lda $58,x			lda		NSMantissa0,x
.9da5		35 59		and $59,x			and 		NSMantissa0+1,x
.9da7		95 58		sta $58,x			sta 	NSMantissa0,x
.9da9		b5 60		lda $60,x			lda		NSMantissa1,x
.9dab		35 61		and $61,x			and 		NSMantissa1+1,x
.9dad		95 60		sta $60,x			sta 	NSMantissa1,x
.9daf		b5 68		lda $68,x			lda		NSMantissa2,x
.9db1		35 69		and $69,x			and 		NSMantissa2+1,x
.9db3		95 68		sta $68,x			sta 	NSMantissa2,x
.9db5		b5 70		lda $70,x			lda		NSMantissa3,x
.9db7		35 71		and $71,x			and 		NSMantissa3+1,x
.9db9		95 70		sta $70,x			sta 	NSMantissa3,x
.9dbb		74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.9dbd		60		rts				rts
.9dbe						OraInteger:
.9dbe		fa		plx				plx
.9dbf		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9dc1		15 51		ora $51,x			ora 	NSStatus+1,x
.9dc3		0a		asl a				asl 	a 							; shift reference bit into sign bit
.9dc4		0a		asl a				asl 	a
.9dc5		10 05		bpl $9dcc			bpl 	_NotRef
.9dc7		48		pha				pha
.9dc8		20 bf a1	jsr $a1bf			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9dcb		68		pla				pla
.9dcc						_NotRef:
.9dcc		0a		asl a				asl 	a
.9dcd		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9dcf		15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9dd1		15 79		ora $79,x			ora 	NSExponent+1,x
.9dd3		f0 03		beq $9dd8			beq 	_IntegerCode 				; if clear, then we have two integers
.9dd5		4c fd ab	jmp $abfd			jmp 	TypeError 					; anything else, type mismatch.
.9dd8						_IntegerCode:
.9dd8		b5 58		lda $58,x			lda		NSMantissa0,x
.9dda		15 59		ora $59,x			ora 		NSMantissa0+1,x
.9ddc		95 58		sta $58,x			sta 	NSMantissa0,x
.9dde		b5 60		lda $60,x			lda		NSMantissa1,x
.9de0		15 61		ora $61,x			ora 		NSMantissa1+1,x
.9de2		95 60		sta $60,x			sta 	NSMantissa1,x
.9de4		b5 68		lda $68,x			lda		NSMantissa2,x
.9de6		15 69		ora $69,x			ora 		NSMantissa2+1,x
.9de8		95 68		sta $68,x			sta 	NSMantissa2,x
.9dea		b5 70		lda $70,x			lda		NSMantissa3,x
.9dec		15 71		ora $71,x			ora 		NSMantissa3+1,x
.9dee		95 70		sta $70,x			sta 	NSMantissa3,x
.9df0		74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.9df2		60		rts				rts
.9df3						EorInteger:
.9df3		fa		plx				plx
.9df4		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9df6		15 51		ora $51,x			ora 	NSStatus+1,x
.9df8		0a		asl a				asl 	a 							; shift reference bit into sign bit
.9df9		0a		asl a				asl 	a
.9dfa		10 05		bpl $9e01			bpl 	_NotRef
.9dfc		48		pha				pha
.9dfd		20 bf a1	jsr $a1bf			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9e00		68		pla				pla
.9e01						_NotRef:
.9e01		0a		asl a				asl 	a
.9e02		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9e04		15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9e06		15 79		ora $79,x			ora 	NSExponent+1,x
.9e08		f0 03		beq $9e0d			beq 	_IntegerCode 				; if clear, then we have two integers
.9e0a		4c fd ab	jmp $abfd			jmp 	TypeError 					; anything else, type mismatch.
.9e0d						_IntegerCode:
.9e0d		b5 58		lda $58,x			lda		NSMantissa0,x
.9e0f		55 59		eor $59,x			eor 		NSMantissa0+1,x
.9e11		95 58		sta $58,x			sta 	NSMantissa0,x
.9e13		b5 60		lda $60,x			lda		NSMantissa1,x
.9e15		55 61		eor $61,x			eor 		NSMantissa1+1,x
.9e17		95 60		sta $60,x			sta 	NSMantissa1,x
.9e19		b5 68		lda $68,x			lda		NSMantissa2,x
.9e1b		55 69		eor $69,x			eor 		NSMantissa2+1,x
.9e1d		95 68		sta $68,x			sta 	NSMantissa2,x
.9e1f		b5 70		lda $70,x			lda		NSMantissa3,x
.9e21		55 71		eor $71,x			eor 		NSMantissa3+1,x
.9e23		95 70		sta $70,x			sta 	NSMantissa3,x
.9e25		74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.9e27		60		rts				rts
.9e28						WordIndirect:
.9e28		fa		plx				plx
.9e29		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9e2b		15 51		ora $51,x			ora 	NSStatus+1,x
.9e2d		0a		asl a				asl 	a 							; shift reference bit into sign bit
.9e2e		0a		asl a				asl 	a
.9e2f		10 05		bpl $9e36			bpl 	_NotRef
.9e31		48		pha				pha
.9e32		20 bf a1	jsr $a1bf			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9e35		68		pla				pla
.9e36						_NotRef:
.9e36		0a		asl a				asl 	a
.9e37		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9e39		15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9e3b		15 79		ora $79,x			ora 	NSExponent+1,x
.9e3d		f0 03		beq $9e42			beq 	_IntegerCode 				; if clear, then we have two integers
.9e3f		4c fd ab	jmp $abfd			jmp 	TypeError 					; anything else, type mismatch.
.9e42						_IntegerCode:
.9e42		20 48 9d	jsr $9d48			jsr 	AddCode 					; add the two values
.9e45		a9 22		lda #$22			lda 	#NSBIsReference+2 			; make a 2 byte reference
.9e47		95 50		sta $50,x			sta 	NSStatus,x
.9e49		60		rts				rts
.9e4a						ByteIndirect:
.9e4a		fa		plx				plx
.9e4b		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9e4d		15 51		ora $51,x			ora 	NSStatus+1,x
.9e4f		0a		asl a				asl 	a 							; shift reference bit into sign bit
.9e50		0a		asl a				asl 	a
.9e51		10 05		bpl $9e58			bpl 	_NotRef
.9e53		48		pha				pha
.9e54		20 bf a1	jsr $a1bf			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9e57		68		pla				pla
.9e58						_NotRef:
.9e58		0a		asl a				asl 	a
.9e59		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9e5b		15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9e5d		15 79		ora $79,x			ora 	NSExponent+1,x
.9e5f		f0 03		beq $9e64			beq 	_IntegerCode 				; if clear, then we have two integers
.9e61		4c fd ab	jmp $abfd			jmp 	TypeError 					; anything else, type mismatch.
.9e64						_IntegerCode:
.9e64		20 48 9d	jsr $9d48			jsr 	AddCode 					; add the two values
.9e67		a9 21		lda #$21			lda 	#NSBIsReference+1 			; make a 1 byte reference
.9e69		95 50		sta $50,x			sta 	NSStatus,x
.9e6b		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/tostring.asm

.9e6c						ConvertInt16:
.9e6c		85 58		sta $58				sta 	NSMantissa0 				; set up as 32 bit conversion
.9e6e		86 60		stx $60				stx 	NSMantissa1
.9e70		64 68		stz $68				stz 	NSMantissa2
.9e72		64 70		stz $70				stz 	NSMantissa3
.9e74		64 50		stz $50				stz 	NSStatus 					; positive integer
.9e76		a2 00		ldx #$00			ldx 	#0 							; stack level
.9e78		a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.9e7a		80 00		bra $9e7c			bra 	ConvertInt32
.9e7c						ConvertInt32:
.9e7c		5a		phy				phy
.9e7d		a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.9e7f		24 50		bit $50				bit 	NSStatus 					; output a - if not negative.
.9e81		10 08		bpl $9e8b			bpl 	_CI32NotNeg
.9e83		48		pha				pha
.9e84		a9 2d		lda #$2d			lda 	#'-'
.9e86		99 23 06	sta $0623,y			sta 	numberBuffer,y
.9e89		c8		iny				iny
.9e8a		68		pla				pla
.9e8b						_CI32NotNeg:
.9e8b		20 99 9e	jsr $9e99			jsr 	_CI32DivideConvert 			; recursive conversion
.9e8e		a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.9e90		99 23 06	sta $0623,y			sta 	numberBuffer,y
.9e93		7a		ply				ply
.9e94		a2 06		ldx #$06			ldx 	#numberBuffer >> 8 			; return address in XA
.9e96		a9 23		lda #$23			lda 	#numberBuffer & $FF
.9e98		60		rts				rts
.9e99						_CI32DivideConvert:
.9e99		e8		inx				inx 								; write to next slot up
.9e9a		20 59 a9	jsr $a959			jsr 	NSMSetByte 		 			; write the base out.
.9e9d		ca		dex				dex
.9e9e		20 c7 9b	jsr $9bc7			jsr 	Int32Divide 				; divide
.9ea1		b5 58		lda $58,x			lda 	NSMantissa0,x 				; save remainder
.9ea3		48		pha				pha
.9ea4		20 84 9b	jsr $9b84			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.9ea7		20 79 a9	jsr $a979			jsr 	NSMIsZero 					; is it zero ?
.9eaa		f0 05		beq $9eb1			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.9eac		b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.9eae		20 99 9e	jsr $9e99			jsr 	_CI32DivideConvert 			; and recusrively call.
.9eb1						_CI32NoRecurse:
.9eb1		68		pla				pla 								; remainder
.9eb2		c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.9eb4		90 02		bcc $9eb8			bcc 	_CI32NotHex
.9eb6		69 26		adc #$26			adc 	#6+32
.9eb8						_CI32NotHex:
.9eb8		69 30		adc #$30			adc 	#48
.9eba		99 23 06	sta $0623,y			sta 	numberBuffer,y 				; write out and exit
.9ebd		c8		iny				iny
.9ebe		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/expression.asm


;******  Processing file: ./common/expressions/../generated/precedence.dat

.9ebf						PrecedenceLevel:
>9ebf		04					.byte	 4	; $00 <<
>9ec0		02					.byte	 2	; $01 <=
>9ec1		02					.byte	 2	; $02 <>
>9ec2		00					.byte	 0	; $03 !!3
>9ec3		00					.byte	 0	; $04 ><
>9ec4		02					.byte	 2	; $05 >=
>9ec5		04					.byte	 4	; $06 >>
>9ec6		00					.byte	 0	; $07 !!7
>9ec7		00					.byte	 0	; $08 !!8
>9ec8		00					.byte	 0	; $09 !!9
>9ec9		00					.byte	 0	; $0a !!10
>9eca		00					.byte	 0	; $0b !!11
>9ecb		00					.byte	 0	; $0c !!12
>9ecc		00					.byte	 0	; $0d !!13
>9ecd		00					.byte	 0	; $0e !!14
>9ece		00					.byte	 0	; $0f !!15
>9ecf		00					.byte	 0	; $10 @
>9ed0		00					.byte	 0	; $11 !!17
>9ed1		00					.byte	 0	; $12 !!18
>9ed2		00					.byte	 0	; $13 [
>9ed3		04					.byte	 4	; $14 \
>9ed4		00					.byte	 0	; $15 ]
>9ed5		01					.byte	 1	; $16 ^
>9ed6		00					.byte	 0	; $17 _
>9ed7		00					.byte	 0	; $18 `
>9ed8		00					.byte	 0	; $19 !!25
>9ed9		00					.byte	 0	; $1a !!26
>9eda		00					.byte	 0	; $1b {
>9edb		01					.byte	 1	; $1c |
>9edc		00					.byte	 0	; $1d }
>9edd		00					.byte	 0	; $1e ~
>9ede		00					.byte	 0	; $1f <7F>
>9edf		00					.byte	 0	; $20
>9ee0		05					.byte	 5	; $21 !
>9ee1		00					.byte	 0	; $22 "
>9ee2		00					.byte	 0	; $23 #
>9ee3		05					.byte	 5	; $24 $
>9ee4		04					.byte	 4	; $25 %
>9ee5		01					.byte	 1	; $26 &
>9ee6		00					.byte	 0	; $27 '
>9ee7		00					.byte	 0	; $28 (
>9ee8		00					.byte	 0	; $29 )
>9ee9		04					.byte	 4	; $2a *
>9eea		03					.byte	 3	; $2b +
>9eeb		00					.byte	 0	; $2c ,
>9eec		03					.byte	 3	; $2d -
>9eed		00					.byte	 0	; $2e .
>9eee		04					.byte	 4	; $2f /
>9eef		00					.byte	 0	; $30 0
>9ef0		00					.byte	 0	; $31 1
>9ef1		00					.byte	 0	; $32 2
>9ef2		00					.byte	 0	; $33 3
>9ef3		00					.byte	 0	; $34 4
>9ef4		00					.byte	 0	; $35 5
>9ef5		00					.byte	 0	; $36 6
>9ef6		00					.byte	 0	; $37 7
>9ef7		00					.byte	 0	; $38 8
>9ef8		00					.byte	 0	; $39 9
>9ef9		00					.byte	 0	; $3a :
>9efa		00					.byte	 0	; $3b ;
>9efb		02					.byte	 2	; $3c <
>9efc		02					.byte	 2	; $3d =
>9efd		02					.byte	 2	; $3e >
>9efe		05					.byte	 5	; $3f ?

;******  Return to file: ./common/expressions/expression.asm

.9eff						EvaluateExpressionAt0:
.9eff		a2 00		ldx #$00			ldx 	#0 							; bottom stack level
.9f01						EvaluateExpression:
.9f01		a9 00		lda #$00			lda 	#0 							; lowest precedence level
.9f03						EvaluateExpressionAtPrecedence:
.9f03		48		pha				pha 								; save precedence level
.9f04		20 4b a3	jsr $a34b			jsr 	EvaluateTerm 				; evaluate term into level X.
.9f07		68		pla				pla 								; restore precedence level.
.9f08						_EXPRLoop:
.9f08		85 36		sta $36				sta 	zTemp0 						; save current precedence level.
.9f0a		b1 30		lda ($30),y			lda 	(codePtr),y
.9f0c		c9 40		cmp #$40			cmp		#$40 						; if >= $40 cannot be an operator
.9f0e		b0 25		bcs $9f35			bcs 	_EXPRExit
.9f10		da		phx				phx 								; read the operator precedence
.9f11		aa		tax				tax
.9f12		bd bf 9e	lda $9ebf,x			lda 	PrecedenceLevel,x
.9f15		fa		plx				plx
.9f16		c9 00		cmp #$00			cmp 	#0							; if zero exit (not an operator)
.9f18		f0 1b		beq $9f35			beq 	_EXPRExit
.9f1a		85 37		sta $37				sta 	zTemp0+1 					; save operator precedence level.
.9f1c		a5 36		lda $36				lda 	zTemp0 						; compare current precedence vs. operator precedence
.9f1e		c5 37		cmp $37				cmp 	zTemp0+1
.9f20		b0 13		bcs $9f35			bcs		_EXPRExit 					; if current >= operator exit
.9f22		48		pha				pha 								; save current precedence.
.9f23		b1 30		lda ($30),y			lda 	(codePtr),y
.9f25		c8		iny				iny
.9f26		48		pha				pha
.9f27		a5 37		lda $37				lda 	zTemp0+1 					; get operator precedence level
.9f29		e8		inx				inx 								; work out the right hand side.
.9f2a		20 03 9f	jsr $9f03			jsr 	EvaluateExpressionAtPrecedence
.9f2d		ca		dex				dex
.9f2e		68		pla				pla 								; get operator, call the code.
.9f2f		20 38 9f	jsr $9f38			jsr 	_EXPRCaller
.9f32		68		pla				pla 								; restore precedence level
.9f33		80 d3		bra $9f08			bra 	_EXPRLoop 					; and go round.
.9f35						_EXPRExit:
.9f35		a5 36		lda $36				lda 	zTemp0 						; A = current precedence level.
.9f37		60		rts				rts
.9f38						_EXPRCaller:
.9f38		da		phx				phx 								; save on stack, first thing is to restore it
.9f39		0a		asl a				asl 	a 							; double so can use vectors into X
.9f3a		aa		tax				tax
.9f3b		7c e4 95	jmp ($95e4,x)			jmp 	(VectorSetPunc,x) 			; and go to the code.

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/addsub.asm

.9f3e						FloatingPointAdd:
.9f3e		20 b4 a0	jsr $a0b4			jsr 	FloatPrepare 				; prepare for floats
.9f41		80 09		bra $9f4c			bra 	FloatAdd
.9f43						FloatingPointSub:
.9f43		20 b4 a0	jsr $a0b4			jsr 	FloatPrepare 				; prepare for floats
.9f46						FloatSubtract:
.9f46		b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate FPB
.9f48		49 80		eor #$80			eor 	#$80
.9f4a		95 51		sta $51,x			sta 	NSStatus+1,x				; and fall through.
.9f4c						FloatAdd:
.9f4c		48		pha				pha
.9f4d		5a		phy				phy
.9f4e		20 c3 a0	jsr $a0c3			jsr 	NSNormalise 				; normalise S[X]
.9f51		f0 51		beq $9fa4			beq 	_FAReturn1
.9f53		e8		inx				inx 								; normalise S[X+1]
.9f54		20 c3 a0	jsr $a0c3			jsr 	NSNormalise
.9f57		ca		dex				dex
.9f58		c9 00		cmp #$00			cmp 	#0
.9f5a		f0 60		beq $9fbc			beq 	_FAExit 					; if so, just return A
.9f5c		b5 78		lda $78,x			lda 	NSExponent,x 				; are the exponents the same ?
.9f5e		d5 79		cmp $79,x			cmp 	NSExponent+1,x
.9f60		f0 18		beq $9f7a			beq 	_FAExponentsEqual
.9f62		b5 78		lda $78,x			lda 	NSExponent,x 				; work out the larger exponent
.9f64		a8		tay				tay
.9f65		38		sec				sec 								; do a signed comparison of the exponents.
.9f66		f5 79		sbc $79,x			sbc 	NSExponent+1,x
.9f68		50 02		bvc $9f6c			bvc 	_FANoSignedChange
.9f6a		49 80		eor #$80			eor 	#$80
.9f6c						_FANoSignedChange:
.9f6c		29 80		and #$80			and 	#$80
.9f6e		10 02		bpl $9f72			bpl 	_FAHaveMax
.9f70		b4 79		ldy $79,x			ldy 	NSExponent+1,x
.9f72						_FAHaveMax:
.9f72		20 bf 9f	jsr $9fbf			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.9f75		e8		inx				inx
.9f76		20 bf 9f	jsr $9fbf			jsr 	_FAShiftToExponent
.9f79		ca		dex				dex
.9f7a						_FAExponentsEqual:
.9f7a		b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs the same
.9f7c		55 51		eor $51,x			eor 	NSStatus+1,x
.9f7e		30 0e		bmi $9f8e			bmi 	_FADifferentSigns
.9f80		20 f7 9c	jsr $9cf7			jsr 	AddTopTwoStack 				; do the add of the mantissae
.9f83		b5 70		lda $70,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.9f85		10 35		bpl $9fbc			bpl 	_FAExit 					; if no, we are done.
.9f87		20 70 a9	jsr $a970			jsr 	NSMShiftRight 				; shift A right, renormalising it.
.9f8a		f6 78		inc $78,x			inc 	NSExponent,x 				; bump the exponent and exit
.9f8c		80 2e		bra $9fbc			bra 	_FAExit
.9f8e						_FADifferentSigns:
.9f8e		20 11 9d	jsr $9d11			jsr 	SubTopTwoStack 				; subtract mantissa B from A
.9f91		b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the result negative ?
.9f93		10 06		bpl $9f9b			bpl 	_FACheckZero 				; if no, check for -0
.9f95		20 19 a9	jsr $a919			jsr 	NSMNegate 					; netate result
.9f98		20 20 a9	jsr $a920			jsr 	NSMNegateMantissa 			; negate (2'c) the mantissa
.9f9b						_FACheckZero:
.9f9b		20 79 a9	jsr $a979			jsr 	NSMIsZero	 				; check for -0
.9f9e		d0 1c		bne $9fbc			bne 	_FAExit
.9fa0		74 50		stz $50,x			stz 	NSStatus,x
.9fa2		80 18		bra $9fbc			bra 	_FAExit
.9fa4						_FAReturn1:
.9fa4		b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.9fa6		95 58		sta $58,x			sta 	NSMantissa0,x
.9fa8		b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9faa		95 60		sta $60,x			sta 	NSMantissa1,x
.9fac		b5 69		lda $69,x			lda 	NSMantissa2+1,x
.9fae		95 68		sta $68,x			sta 	NSMantissa2,x
.9fb0		b5 71		lda $71,x			lda 	NSMantissa3+1,x
.9fb2		95 70		sta $70,x			sta 	NSMantissa3,x
.9fb4		b5 79		lda $79,x			lda 	NSExponent+1,x
.9fb6		95 78		sta $78,x			sta 	NSExponent,x
.9fb8		b5 51		lda $51,x			lda 	NSStatus+1,x
.9fba		95 50		sta $50,x			sta 	NSStatus,x
.9fbc						_FAExit:
.9fbc		7a		ply				ply
.9fbd		68		pla				pla
.9fbe		60		rts				rts
.9fbf						_FAShiftToExponent:
.9fbf						_FAShiftToExponent2:
.9fbf		98		tya				tya 								; compare Y to exponent
.9fc0		d5 78		cmp $78,x			cmp 	NSExponent,x 				; reached the exponent required ?
.9fc2		f0 07		beq $9fcb			beq 	_FASEExit 					; exit if so.
.9fc4		20 70 a9	jsr $a970			jsr 	NSMShiftRight	 			; shift the mantissa right
.9fc7		f6 78		inc $78,x			inc 	NSExponent,x 				; increment exponent
.9fc9		80 f4		bra $9fbf			bra 	_FAShiftToExponent2
.9fcb						_FASEExit:
.9fcb		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/compare.asm

.9fcc						CompareFloat:
.9fcc		20 46 9f	jsr $9f46			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.9fcf		b5 60		lda $60,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.9fd1		29 f8		and #$f8			and 	#$F8
.9fd3		15 68		ora $68,x			ora 	NSMantissa2,x
.9fd5		15 70		ora $70,x			ora 	NSMantissa3,x
.9fd7		f0 08		beq $9fe1			beq 	_FCExit 					; zero, so approximately identical
.9fd9		a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.9fdb		34 50		bit $50,x			bit 	NSStatus,x
.9fdd		10 02		bpl $9fe1			bpl 	_FCExit
.9fdf						_FCNegative:
.9fdf		a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.9fe1						_FCExit:
.9fe1		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/divide.asm

.9fe2						FDivideCommand:
.9fe2		fa		plx				plx	 								; restore stack position
.9fe3		20 b4 a0	jsr $a0b4			jsr 	FloatPrepare 				; prepare for floats
.9fe6						FloatDivide:
.9fe6		48		pha				pha
.9fe7		e8		inx				inx
.9fe8		20 c3 a0	jsr $a0c3			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.9feb		ca		dex				dex
.9fec		c9 00		cmp #$00			cmp 	#0
.9fee		f0 1d		beq $a00d			beq 	_FDZero
.9ff0		20 c3 a0	jsr $a0c3			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.9ff3		f0 16		beq $a00b			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.9ff5		20 e8 9b	jsr $9be8			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.9ff8		20 84 9b	jsr $9b84			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.9ffb		20 c3 a0	jsr $a0c3			jsr		NSNormalise 				; renormalise
.9ffe		20 78 9c	jsr $9c78			jsr 	CalculateSign 				; calculate result sign
.a001		b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent
.a003		38		sec				sec
.a004		f5 79		sbc $79,x			sbc 	NSExponent+1,x
.a006		38		sec				sec
.a007		e9 1e		sbc #$1e			sbc 	#30
.a009		95 78		sta $78,x			sta 	NSExponent,x
.a00b						_FDExit:
.a00b		68		pla				pla
.a00c		60		rts				rts
.a00d						_FDZero:
.a00d		a9 03		lda #$03		lda	#3
.a00f		4c f7 99	jmp $99f7		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/fractional.asm

.a012						FloatFractionalPart:
.a012		5a		phy				phy
.a013		b5 50		lda $50,x			lda 	NSStatus,x 					; take absolute value
.a015		29 7f		and #$7f			and 	#$7F
.a017		95 50		sta $50,x			sta 	NSStatus,x
.a019		20 c3 a0	jsr $a0c3			jsr 	NSNormalise
.a01c		b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.a01e		38		sec				sec
.a01f		e9 e0		sbc #$e0			sbc 	#$E0
.a021		90 29		bcc $a04c			bcc 	_FFPExit 					; already fractional
.a023		c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.a025		b0 22		bcs $a049			bcs 	_FFPZero
.a027		a8		tay				tay 								; put count to do in Y
.a028		b5 70		lda $70,x			lda 	NSMantissa3,x 				; do each in turn.
.a02a		20 4e a0	jsr $a04e			jsr 	_FFPPartial
.a02d		95 70		sta $70,x			sta 	NSMantissa3,x
.a02f		b5 68		lda $68,x			lda 	NSMantissa2,x
.a031		20 4e a0	jsr $a04e			jsr 	_FFPPartial
.a034		95 68		sta $68,x			sta 	NSMantissa2,x
.a036		b5 60		lda $60,x			lda 	NSMantissa1,x
.a038		20 4e a0	jsr $a04e			jsr 	_FFPPartial
.a03b		95 60		sta $60,x			sta 	NSMantissa1,x
.a03d		b5 58		lda $58,x			lda 	NSMantissa0,x
.a03f		20 4e a0	jsr $a04e			jsr 	_FFPPartial
.a042		95 58		sta $58,x			sta 	NSMantissa0,x
.a044		20 79 a9	jsr $a979			jsr 	NSMIsZero 					; zeroed check.
.a047		d0 03		bne $a04c			bne 	_FFPExit
.a049						_FFPZero:
.a049		20 57 a9	jsr $a957			jsr 	NSMSetZero
.a04c						_FFPExit:
.a04c		7a		ply				ply
.a04d		60		rts				rts
.a04e						_FFPPartial:
.a04e		c0 00		cpy #$00			cpy 	#0 							; no more to do
.a050		f0 17		beq $a069			beq 	_FFFPPExit
.a052		c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.a054		b0 0c		bcs $a062			bcs 	_FFFPPWholeByte
.a056		5a		phy				phy
.a057						_FFFPPLeft:
.a057		0a		asl a				asl 	a
.a058		88		dey				dey
.a059		d0 fc		bne $a057			bne 	_FFFPPLeft
.a05b		7a		ply				ply
.a05c						_FFFPPRight:
.a05c		4a		lsr a				lsr 	a
.a05d		88		dey				dey
.a05e		d0 fc		bne $a05c			bne 	_FFFPPRight
.a060		80 07		bra $a069			bra 	_FFFPPExit
.a062						_FFFPPWholeByte:
.a062		98		tya				tya 								; subtract 8 from count
.a063		38		sec				sec
.a064		e9 08		sbc #$08			sbc 	#8
.a066		a8		tay				tay
.a067		a9 00		lda #$00			lda 	#0 							; and clear all
.a069						_FFFPPExit:
.a069		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/integer.asm

.a06a						FloatIntegerPart:
.a06a		48		pha				pha
.a06b		b5 78		lda $78,x			lda 	NSExponent,x 				; is it integer already ?
.a06d		f0 1d		beq $a08c			beq 	_FIPExit 					; if so do nothing
.a06f		20 79 a9	jsr $a979			jsr 	NSMIsZero 					; is it zero ?
.a072		f0 15		beq $a089			beq 	_FIPZero 					; if so return zero.
.a074		20 c3 a0	jsr $a0c3			jsr 	NSNormalise 				; normalise
.a077		f0 10		beq $a089			beq 	_FIPZero 					; normalised to zero, exit zero
.a079						_FIPShift:
.a079		b5 78		lda $78,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.a07b		10 07		bpl $a084			bpl 	_FIPCheckZero
.a07d		20 70 a9	jsr $a970			jsr 	NSMShiftRight 				; shift mantissa right
.a080		f6 78		inc $78,x			inc 	NSExponent,x 				; bump exponent
.a082		80 f5		bra $a079			bra 	_FIPShift
.a084						_FIPCheckZero:
.a084		20 79 a9	jsr $a979			jsr 	NSMIsZero 					; avoid -0 problem
.a087		d0 03		bne $a08c			bne 	_FIPExit 					; set to zero if mantissa zero.
.a089						_FIPZero:
.a089		20 57 a9	jsr $a957			jsr 	NSMSetZero
.a08c						_FIPExit:
.a08c		68		pla				pla
.a08d		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/multiply.asm

.a08e						FloatingPointMultiply:
.a08e		20 b4 a0	jsr $a0b4			jsr 	FloatPrepare 				; prepare for floats
.a091						FloatMultiply:
.a091		48		pha				pha
.a092		20 c3 a0	jsr $a0c3			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.a095		f0 18		beq $a0af			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.a097		e8		inx				inx
.a098		20 c3 a0	jsr $a0c3			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.a09b		ca		dex				dex
.a09c		c9 00		cmp #$00			cmp 	#0
.a09e		f0 0c		beq $a0ac			beq 	_FDSetZero
.a0a0		20 3a 9c	jsr $9c3a			jsr 	MultiplyShort 				; calculate the result.
.a0a3		75 78		adc $78,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.a0a5		18		clc				clc
.a0a6		75 79		adc $79,x			adc 	NSExponent+1,x
.a0a8		95 78		sta $78,x			sta 	NSExponent,x
.a0aa		80 03		bra $a0af			bra 	_FDExit
.a0ac						_FDSetZero:
.a0ac		20 57 a9	jsr $a957			jsr 	NSMSetZero 					; return 0
.a0af						_FDExit:
.a0af		20 c3 a0	jsr $a0c3			jsr 	NSNormalise 				; normalise the result
.a0b2		68		pla				pla
.a0b3		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/utility.asm

.a0b4						FloatPrepare:
.a0b4		20 bf a1	jsr $a1bf			jsr 	DereferenceTopTwo 			; dereference the top two values
.a0b7		b5 50		lda $50,x			lda 	NSStatus,x 					; check ints/floats, either will do.
.a0b9		15 51		ora $51,x			ora 	NSStatus+1,x
.a0bb		29 10		and #$10			and 	#NSBIsString
.a0bd		d0 01		bne $a0c0			bne 	_FDType
.a0bf		60		rts				rts
.a0c0						_FDType:
.a0c0		4c fd ab	jmp $abfd			jmp 	TypeError
.a0c3						NSNormalise:
.a0c3		b5 50		lda $50,x			lda 	NSStatus,x 					; make float, keep sign
.a0c5		29 80		and #$80			and 	#$80
.a0c7		09 08		ora #$08			ora 	#NSTFloat
.a0c9		95 50		sta $50,x			sta 	NSStatus,x
.a0cb		20 79 a9	jsr $a979			jsr 	NSMIsZero 					; if zero exit
.a0ce		d0 07		bne $a0d7			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.a0d0		16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.a0d2		76 50		ror $50,x			ror 	NSStatus,x 					; (no -0)
.a0d4		a9 00		lda #$00			lda 	#0 							; set Z flag
.a0d6		60		rts				rts
.a0d7						_NSNormaliseOptimise:
.a0d7		b5 70		lda $70,x			lda 	NSMantissa3,x 				; upper byte zero ?
.a0d9		d0 19		bne $a0f4			bne 	_NSNormaliseLoop
.a0db		b5 68		lda $68,x			lda 	NSMantissa2,x 				; byte normalise
.a0dd		30 15		bmi $a0f4			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.a0df		95 70		sta $70,x			sta 	NSMantissa3,x
.a0e1		b5 60		lda $60,x			lda 	NSMantissa1,x
.a0e3		95 68		sta $68,x			sta 	NSMantissa2,x
.a0e5		b5 58		lda $58,x			lda 	NSMantissa0,x
.a0e7		95 60		sta $60,x			sta 	NSMantissa1,x
.a0e9		74 58		stz $58,x			stz 	NSMantissa0,x
.a0eb		b5 78		lda $78,x			lda 	NSExponent,x
.a0ed		38		sec				sec
.a0ee		e9 08		sbc #$08			sbc 	#8
.a0f0		95 78		sta $78,x			sta 	NSExponent,x
.a0f2		80 e3		bra $a0d7			bra 	_NSNormaliseOptimise
.a0f4						_NSNormaliseLoop:
.a0f4		34 70		bit $70,x			bit 	NSMantissa3,x 				; bit 30 set ?
.a0f6		70 07		bvs $a0ff			bvs 	_NSNExit 					; exit if so with Z flag clear
.a0f8		20 66 a9	jsr $a966			jsr 	NSMShiftLeft 				; shift mantissa left
.a0fb		d6 78		dec $78,x			dec 	NSExponent,x 				; adjust exponent
.a0fd		80 f5		bra $a0f4			bra 	_NSNormaliseLoop
.a0ff						_NSNExit:
.a0ff		a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.a101		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignnumber.asm

.a102						AssignNumber:
.a102		5a		phy				phy
.a103		b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy mantissa0/1 to zTemp0
.a105		85 36		sta $36				sta 	zTemp0
.a107		b5 60		lda $60,x			lda 	NSMantissa1,x
.a109		85 37		sta $37				sta 	zTemp0+1
.a10b		b5 50		lda $50,x			lda 	NSStatus,x 					; clear reference bits
.a10d		29 df		and #$df			and 	#(NSBIsReference ^ $FF)
.a10f		95 50		sta $50,x			sta 	NSStatus,x
.a111		29 18		and #$18			and 	#NSBTypeMask				; assigning to a float ?
.a113		c9 08		cmp #$08			cmp 	#NSTFloat
.a115		f0 24		beq $a13b			beq 	_ANFloat
.a117		b5 79		lda $79,x			lda		NSExponent+1,x 				; is it a float
.a119		f0 03		beq $a11e			beq		_ANNotFloat
.a11b		4c f8 ab	jmp $abf8			jmp 	RangeError					; if it is, report an error.
.a11e						_ANNotFloat:
.a11e		b5 50		lda $50,x			lda 	NSStatus,x 					; check if byte/word reference.
.a120		29 03		and #$03			and 	#3
.a122		d0 05		bne $a129			bne 	_ANByteWord
.a124		20 46 a1	jsr $a146			jsr 	_ANCopy4PackSign 			; copy all 4 bytes and sign
.a127		80 1b		bra $a144			bra 	_ANExit
.a129						_ANByteWord:
.a129		48		pha				pha 								; save count
.a12a		b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; do byte
.a12c		92 36		sta ($36)			sta 	(zTemp0)
.a12e		68		pla				pla
.a12f		c9 01		cmp #$01			cmp	 	#1
.a131		f0 11		beq $a144			beq 	_ANExit
.a133		b5 61		lda $61,x			lda 	NSMantissa1+1,x 			; do word
.a135		a0 01		ldy #$01			ldy 	#1
.a137		91 36		sta ($36),y			sta 	(zTemp0),y
.a139		80 09		bra $a144			bra 	_ANExit
.a13b						_ANFloat:
.a13b		20 46 a1	jsr $a146			jsr 	_ANCopy4PackSign 			; write all 4 bytes and packed sign
.a13e		b5 79		lda $79,x			lda 	NSExponent+1,x 				; copy exponent to slot 4
.a140		a0 04		ldy #$04			ldy 	#4
.a142		91 36		sta ($36),y			sta 	(zTemp0),y
.a144						_ANExit:
.a144		7a		ply				ply
.a145		60		rts				rts
.a146						_ANCopy4PackSign:
.a146		a0 03		ldy #$03			ldy 	#3
.a148		b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign bit into status
.a14a		29 80		and #$80			and 	#$80 						; put into high bit of mantissa 3
.a14c		15 71		ora $71,x			ora 	NSMantissa3+1,x
.a14e		91 36		sta ($36),y			sta 	(zTemp0),y
.a150		88		dey				dey
.a151		b5 69		lda $69,x			lda 	NSMantissa2+1,x
.a153		91 36		sta ($36),y			sta 	(zTemp0),y
.a155		88		dey				dey
.a156		b5 61		lda $61,x			lda 	NSMantissa1+1,x
.a158		91 36		sta ($36),y			sta 	(zTemp0),y
.a15a		88		dey				dey
.a15b		b5 59		lda $59,x			lda 	NSMantissa0+1,x
.a15d		91 36		sta ($36),y			sta 	(zTemp0),y
.a15f		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignstring.asm

.a160						AssignString:
.a160		5a		phy				phy
.a161		b5 59		lda $59,x			lda 	NSMantissa0+1,x
.a163		85 38		sta $38				sta 	zTemp1
.a165		b5 61		lda $61,x			lda 	NSMantissa1+1,x
.a167		85 39		sta $39				sta 	zTemp1+1
.a169		b5 58		lda $58,x			lda 	NSMantissa0,x
.a16b		85 36		sta $36				sta 	zTemp0
.a16d		b5 60		lda $60,x			lda 	NSMantissa1,x
.a16f		85 37		sta $37				sta 	zTemp0+1
.a171		a0 01		ldy #$01			ldy 	#1 							; the high byte of the target address
.a173		b1 36		lda ($36),y			lda 	(zTemp0),y
.a175		f0 23		beq $a19a			beq 	_ASNewStringRequired 		; if zero, a new string is required.
.a177		38		sec				sec 								; put Address-2 in zsTemp - this is the size/status/string record
.a178		b2 36		lda ($36)			lda 	(zTemp0) 					; of concreted strings
.a17a		e9 02		sbc #$02			sbc 	#2
.a17c		85 3c		sta $3c				sta 	zsTemp
.a17e		a0 01		ldy #$01			ldy 	#1
.a180		b1 36		lda ($36),y			lda 	(zTemp0),y
.a182		e9 00		sbc #$00			sbc 	#0
.a184		85 3d		sta $3d				sta 	zsTemp+1
.a186		a0 ff		ldy #$ff			ldy 	#$FF 						; get length of new string
.a188						_ASGetLength:
.a188		c8		iny				iny
.a189		b1 38		lda ($38),y			lda 	(zTemp1),y
.a18b		d0 fb		bne $a188			bne 	_ASGetLength
.a18d		98		tya				tya 								; is this length <= current length
.a18e		d2 3c		cmp ($3c)			cmp 	(zsTemp)
.a190		90 1e		bcc $a1b0			bcc 	_ASCopyString
.a192		f0 1c		beq $a1b0			beq 	_ASCopyString
.a194		a9 80		lda #$80			lda 	#$80 						; mark as unused.
.a196		a0 01		ldy #$01			ldy 	#1
.a198		91 3c		sta ($3c),y			sta 	(zsTemp),y
.a19a						_ASNewStringRequired:
.a19a		e8		inx				inx 								; concrete the new string.
.a19b		20 e0 b2	jsr $b2e0			jsr 	StringConcrete				; (breaks zTemp1/2, not zTemp0 and zsTemp)
.a19e		ca		dex				dex
.a19f		18		clc				clc
.a1a0		b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy that new address to the reference.
.a1a2		69 02		adc #$02			adc 	#2 							; add two to point at the data.
.a1a4		92 36		sta ($36)			sta 	(zTemp0)
.a1a6		b5 61		lda $61,x			lda 	NSMantissa1+1,x
.a1a8		69 00		adc #$00			adc 	#0
.a1aa		a0 01		ldy #$01			ldy 	#1
.a1ac		91 36		sta ($36),y			sta 	(zTemp0),y
.a1ae		80 0d		bra $a1bd			bra 	_ASExit
.a1b0						_ASCopyString:
.a1b0		a0 00		ldy #$00			ldy 	#0
.a1b2						_ASCopyLoop:
.a1b2		b1 38		lda ($38),y			lda 	(zTemp1),y
.a1b4		c8		iny				iny
.a1b5		c8		iny				iny
.a1b6		91 3c		sta ($3c),y			sta 	(zsTemp),y
.a1b8		88		dey				dey
.a1b9		c9 00		cmp #$00			cmp 	#0
.a1bb		d0 f5		bne $a1b2			bne 	_ASCopyLoop
.a1bd						_ASExit:
.a1bd		7a		ply				ply
.a1be		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/dereference.asm

.a1bf						DereferenceTopTwo:
.a1bf		e8		inx				inx
.a1c0		20 c4 a1	jsr $a1c4			jsr 	Dereference 				; deref x+1
.a1c3		ca		dex				dex  								; falls through to deref x
.a1c4						Dereference:
.a1c4		b5 50		lda $50,x			lda 	NSStatus,x 					; get the status byte
.a1c6		29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.a1c8		f0 48		beq $a212			beq 	_DRFExit 					; not a reference, so exit.
.a1ca		5a		phy				phy
.a1cb		b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address to dereference into zTemp0
.a1cd		85 36		sta $36				sta 	zTemp0
.a1cf		b5 60		lda $60,x			lda 	NSMantissa1,x
.a1d1		85 37		sta $37				sta 	zTemp0+1
.a1d3		74 60		stz $60,x			stz 	NSMantissa1,x 				; clear second byte.
.a1d5		b2 36		lda ($36)			lda 	(zTemp0) 					; do the first byte
.a1d7		95 58		sta $58,x			sta 	NSMantissa0,x
.a1d9		b5 50		lda $50,x			lda 	NSStatus,x 					; get status byte.
.a1db		29 18		and #$18			and 	#NSBTypeMask 				; what type is it ?
.a1dd		c9 10		cmp #$10			cmp 	#NSTString 					; if string, dereference two
.a1df		f0 0e		beq $a1ef			beq 	_DRFDereferenceTwo
.a1e1		c9 08		cmp #$08			cmp 	#NSTFloat 					; if float, do full dereference.
.a1e3		f0 2f		beq $a214			beq 	_DRFFull
.a1e5		b5 50		lda $50,x			lda 	NSStatus,x 					; must be integer - how many bytes ?
.a1e7		29 03		and #$03			and 	#3
.a1e9		f0 29		beq $a214			beq 	_DRFFull 					; the whole word
.a1eb		c9 01		cmp #$01			cmp 	#1 							; is it 10 (e.g. 2 bytes)
.a1ed		f0 06		beq $a1f5			beq		_DRFClear23 				; no, one byte, clear 2 & 3 and exit
.a1ef						_DRFDereferenceTwo:
.a1ef		a0 01		ldy #$01			ldy 	#1
.a1f1		b1 36		lda ($36),y			lda 	(zTemp0),y
.a1f3		95 60		sta $60,x			sta 	NSMantissa1,x
.a1f5						_DRFClear23:
.a1f5		74 68		stz $68,x			stz 	NSMantissa2,x 				; clear upper bytes, only read 1 or 2 bytes
.a1f7		74 70		stz $70,x			stz 	NSMantissa3,x
.a1f9		b5 50		lda $50,x			lda 	NSStatus,x 					; make it a value of that type.
.a1fb		29 18		and #$18			and 	#NSBTypeMask
.a1fd		95 50		sta $50,x			sta 	NSStatus,x 					; and fall through.
.a1ff		c9 10		cmp #$10			cmp 	#NSTString  				; is it a string
.a201		d0 0e		bne $a211			bne 	_DRFNotString
.a203		b5 58		lda $58,x			lda 	NSMantissa0,x 				; check address is zero
.a205		15 60		ora $60,x			ora 	NSMantissa1,x
.a207		d0 08		bne $a211			bne 	_DRFNotString
.a209		a9 13		lda #$13			lda 	#_DRFNullString & $FF 		; if so, return reference to ""
.a20b		95 58		sta $58,x			sta 	NSMantissa0,x
.a20d		a9 a2		lda #$a2			lda 	#_DRFNullString >> 8
.a20f		95 60		sta $60,x			sta 	NSMantissa1,x
.a211						_DRFNotString
.a211		7a		ply				ply 								; restore Y and exit
.a212						_DRFExit:
.a212		60		rts				rts
.a213						_DRFNullString:
>a213		00						.byte 	0
.a214						_DRFFull:
.a214		a0 01		ldy #$01			ldy 	#1 							; get remaining 3 bytes.
.a216		b1 36		lda ($36),y			lda 	(zTemp0),y
.a218		95 60		sta $60,x			sta 	NSMantissa1,x
.a21a		c8		iny				iny
.a21b		b1 36		lda ($36),y			lda 	(zTemp0),y
.a21d		95 68		sta $68,x			sta 	NSMantissa2,x
.a21f		c8		iny				iny
.a220		b1 36		lda ($36),y			lda 	(zTemp0),y
.a222		95 70		sta $70,x			sta 	NSMantissa3,x
.a224		74 78		stz $78,x			stz 	NSExponent,x 				; clear exponent.
.a226		b5 50		lda $50,x			lda		NSStatus,x 					; see if type is integer
.a228		29 18		and #$18			and 	#NSBTypeMask  				; type information only
.a22a		95 50		sta $50,x			sta 	NSStatus,x 					; update it back.
.a22c		f0 05		beq $a233			beq 	_DRFNoExponent
.a22e		c8		iny				iny 								; if not, read the exponent as well.
.a22f		b1 36		lda ($36),y			lda 	(zTemp0),y
.a231		95 78		sta $78,x			sta 	NSExponent,x
.a233						_DRFNoExponent:
.a233		b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the most significant bit set ?
.a235		10 0a		bpl $a241			bpl 	_DRFExit2 					; if not, then exit.
.a237		29 7f		and #$7f			and 	#$7F 						; clear that bit.
.a239		95 70		sta $70,x			sta 	NSMantissa3,x
.a23b		b5 50		lda $50,x			lda 	NSStatus,x 					; set the sign flag
.a23d		09 80		ora #$80			ora 	#NSBIsNegative
.a23f		95 50		sta $50,x			sta 	NSStatus,x
.a241						_DRFExit2:
.a241		7a		ply				ply
.a242		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/number.asm

=1						ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2						ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3						ESTA_Decimal = 3 							; fractional part.
.a243						EncodeNumberStart:
.a243		38		sec				sec
.a244		80 01		bra $a247			bra 	EncodeNumberContinue+1
.a246						EncodeNumberContinue:
.a246		18		clc				clc
.a247						EncodeNumber:
.a247		08		php				php 								; save reset flag.
.a248		c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.a24a		f0 12		beq $a25e			beq 	_ENIsOkay
.a24c		c9 30		cmp #$30			cmp 	#"0"
.a24e		90 04		bcc $a254			bcc 	_ENBadNumber
.a250		c9 3a		cmp #$3a			cmp 	#"9"+1
.a252		90 0a		bcc $a25e			bcc 	_ENIsOkay
.a254						_ENBadNumber:
.a254		28		plp				plp 								; throw saved reset
.a255		ad 05 04	lda $0405			lda 	encodeState 				; if in decimal mode, construct final number
.a258		c9 03		cmp #$03			cmp 	#ESTA_Decimal
.a25a		f0 7b		beq $a2d7			beq 	_ENConstructFinal
.a25c						_ENFail:
.a25c		18		clc				clc 								; not allowed
.a25d		60		rts				rts
.a25e						_ENIsOkay:
.a25e		28		plp				plp 								; are we restarting
.a25f		90 15		bcc $a276			bcc 	_ENNoRestart
.a261						_ENStartEncode:
.a261		c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.a263		f0 0c		beq $a271			beq 	_ENFirstDP
.a265		29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.a267		20 59 a9	jsr $a959			jsr 	NSMSetByte 					; in single byte mode.
.a26a		a9 01		lda #$01			lda 	#ESTA_Low
.a26c						_ENExitChange:
.a26c		8d 05 04	sta $0405			sta 	encodeState 				; save new state
.a26f		38		sec				sec
.a270		60		rts				rts
.a271						_ENFirstDP:
.a271		20 57 a9	jsr $a957			jsr 	NSMSetZero 					; clear integer part
.a274		80 3c		bra $a2b2			bra 	_ESTASwitchFloat			; go straight to float and exi
.a276						_ENNoRestart:
.a276		48		pha				pha 								; save digit or DP on stack.
.a277		ad 05 04	lda $0405			lda 	encodeState 				; get current state
.a27a		c9 01		cmp #$01			cmp 	#ESTA_Low
.a27c		f0 09		beq $a287			beq  	_ESTALowState
.a27e		c9 02		cmp #$02			cmp 	#ESTA_High
.a280		f0 26		beq $a2a8			beq 	_ESTAHighState
.a282		c9 03		cmp #$03			cmp 	#ESTA_Decimal
.a284		f0 38		beq $a2be			beq 	_ESTADecimalState
>a286		db						.byte 	$DB 						; causes a break in the emulator
.a287						_ESTALowState:
.a287		68		pla				pla 								; get value back
.a288		c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.a28a		f0 26		beq $a2b2			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.a28c		29 0f		and #$0f			and 	#15 						; make digit
.a28e		8d 06 04	sta $0406			sta 	digitTemp 					; save it.
.a291		b5 58		lda $58,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.a293		0a		asl a				asl 	a
.a294		0a		asl a				asl 	a
.a295		75 58		adc $58,x			adc 	NSMantissa0,x
.a297		0a		asl a				asl 	a
.a298		6d 06 04	adc $0406			adc 	digitTemp
.a29b		95 58		sta $58,x			sta 	NSMantissa0,x
.a29d		c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.a29f		90 05		bcc $a2a6			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.a2a1		a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.a2a3		8d 05 04	sta $0405			sta 	encodeState
.a2a6						_ESTANoSwitch:
.a2a6		38		sec				sec
.a2a7		60		rts				rts
.a2a8						_ESTAHighState:
.a2a8		68		pla				pla 								; get value back
.a2a9		c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.a2ab		f0 05		beq $a2b2			beq 	_ESTASwitchFloat
.a2ad		20 0b a3	jsr $a30b			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.a2b0		38		sec				sec
.a2b1		60		rts				rts
.a2b2						_ESTASwitchFloat:
.a2b2		9c 07 04	stz $0407			stz 	decimalCount 				; reset the count of digits - we divide by 10^n at the end.
.a2b5		e8		inx				inx 								; zero the decimal additive.
.a2b6		20 57 a9	jsr $a957			jsr 	NSMSetZero
.a2b9		ca		dex				dex
.a2ba		a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.a2bc		80 ae		bra $a26c			bra 	_ENExitChange
.a2be						_ESTADecimalState:
.a2be		68		pla				pla 								; digit.
.a2bf		c9 2e		cmp #$2e			cmp 	#"." 						; fail on 2nd decimal point.
.a2c1		f0 99		beq $a25c			beq 	_ENFail
.a2c3		e8		inx				inx 								; put digit into fractional part of X+1
.a2c4		20 0b a3	jsr $a30b			jsr 	ESTAShiftDigitIntoMantissa
.a2c7		ca		dex				dex
.a2c8		ee 07 04	inc $0407			inc 	decimalCount 				; bump the count of decimals
.a2cb		ad 07 04	lda $0407			lda 	decimalCount 				; too many decimal digits.
.a2ce		c9 0b		cmp #$0b			cmp 	#11
.a2d0		f0 02		beq $a2d4			beq 	_ESTADSFail
.a2d2		38		sec				sec
.a2d3		60		rts				rts
.a2d4						_ESTADSFail:
.a2d4		4c f8 ab	jmp $abf8			jmp 	RangeError
.a2d7						_ENConstructFinal:
.a2d7		ad 07 04	lda $0407			lda 	decimalCount 				; get decimal count
.a2da		f0 2d		beq $a309			beq 	_ENCFExit 					; no decimals
.a2dc		5a		phy				phy
.a2dd		0a		asl a				asl 	a 							; x 4 and CLC
.a2de		0a		asl a				asl 	a
.a2df		6d 07 04	adc $0407			adc 	decimalCount
.a2e2		a8		tay				tay
.a2e3		b9 b7 ab	lda $abb7,y			lda 	DecimalScalarTable-5,y 		; copy decimal scalar to X+2
.a2e6		95 5a		sta $5a,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.a2e8		b9 b8 ab	lda $abb8,y			lda 	DecimalScalarTable-5+1,y
.a2eb		95 62		sta $62,x			sta 	NSMantissa1+2,x
.a2ed		b9 b9 ab	lda $abb9,y			lda 	DecimalScalarTable-5+2,y
.a2f0		95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.a2f2		b9 ba ab	lda $abba,y			lda 	DecimalScalarTable-5+3,y
.a2f5		95 72		sta $72,x			sta 	NSMantissa3+2,x
.a2f7		b9 bb ab	lda $abbb,y			lda 	DecimalScalarTable-5+4,y
.a2fa		95 7a		sta $7a,x			sta 	NSExponent+2,x
.a2fc		a9 08		lda #$08			lda 	#NSTFloat
.a2fe		95 52		sta $52,x			sta 	NSStatus+2,x
.a300		7a		ply				ply
.a301		e8		inx				inx 								; multiply decimal const by decimal scalar
.a302		20 91 a0	jsr $a091			jsr 	FloatMultiply
.a305		ca		dex				dex
.a306		20 4c 9f	jsr $9f4c			jsr 	FloatAdd 					; add to integer part.
.a309						_ENCFExit:
.a309		18		clc				clc 								; reject the digit.
.a30a		60		rts				rts
.a30b						ESTAShiftDigitIntoMantissa:
.a30b		29 0f		and #$0f			and 	#15 						; save digit
.a30d		48		pha				pha
.a30e		b5 70		lda $70,x			lda 	NSMantissa3,x 				; push mantissa on stack
.a310		48		pha				pha
.a311		b5 68		lda $68,x			lda 	NSMantissa2,x
.a313		48		pha				pha
.a314		b5 60		lda $60,x			lda 	NSMantissa1,x
.a316		48		pha				pha
.a317		b5 58		lda $58,x			lda 	NSMantissa0,x
.a319		48		pha				pha
.a31a		20 66 a9	jsr $a966			jsr 	NSMShiftLeft 				; x 2
.a31d		20 66 a9	jsr $a966			jsr 	NSMShiftLeft 				; x 4
.a320		18		clc				clc 								; pop mantissa and add
.a321		68		pla				pla
.a322		75 58		adc $58,x			adc 	NSMantissa0,x
.a324		95 58		sta $58,x			sta 	NSMantissa0,x
.a326		68		pla				pla
.a327		75 60		adc $60,x			adc 	NSMantissa1,x
.a329		95 60		sta $60,x			sta 	NSMantissa1,x
.a32b		68		pla				pla
.a32c		75 68		adc $68,x			adc 	NSMantissa2,x
.a32e		95 68		sta $68,x			sta 	NSMantissa2,x
.a330		68		pla				pla
.a331		75 70		adc $70,x			adc 	NSMantissa3,x
.a333		95 70		sta $70,x			sta 	NSMantissa3,x 				; x 5
.a335		20 66 a9	jsr $a966			jsr 	NSMShiftLeft 				; x 10
.a338		68		pla				pla 								; add digit
.a339		18		clc				clc
.a33a		75 58		adc $58,x			adc 	NSMantissa0,x
.a33c		95 58		sta $58,x			sta 	NSMantissa0,x
.a33e		90 0a		bcc $a34a			bcc 	_ESTASDExit
.a340		f6 60		inc $60,x			inc 	NSMantissa1,x
.a342		d0 06		bne $a34a			bne 	_ESTASDExit
.a344		f6 68		inc $68,x			inc 	NSMantissa2,x
.a346		d0 02		bne $a34a			bne 	_ESTASDExit
.a348		f6 70		inc $70,x			inc 	NSMantissa3,x
.a34a						_ESTASDExit:
.a34a		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/term.asm

.a34b						EvaluateTerm:
.a34b		b1 30		lda ($30),y			lda 	(codePtr),y
.a34d		30 18		bmi $a367			bmi 	_ETCheckUnary 				; unary function ? (text ones)
.a34f		c9 40		cmp #$40			cmp 	#$40 						; 40-7F => identifier reference
.a351		b0 6c		bcs $a3bf			bcs 	_ETVariable
.a353		c9 30		cmp #$30			cmp 	#'0' 						; is it a number
.a355		90 6b		bcc $a3c2			bcc 	_ETPuncUnary 				; if not it might be a punctuation unary.
.a357		c9 3a		cmp #$3a			cmp 	#'9'+1
.a359		b0 67		bcs $a3c2			bcs 	_ETPuncUnary
.a35b		20 43 a2	jsr $a243			jsr 	EncodeNumberStart 			; can't fail as it's 0-9 !
.a35e						_ETNumber:
.a35e		c8		iny				iny 								; keep encoding until we have the numbers
.a35f		b1 30		lda ($30),y			lda 	(codePtr),y
.a361		20 46 a2	jsr $a246			jsr 	EncodeNumberContinue
.a364		b0 f8		bcs $a35e			bcs 	_ETNumber 					; go back if accepted.
.a366		60		rts				rts
.a367						_ETCheckUnary:
.a367		c9 ff		cmp #$ff			cmp 	#KWC_STRING 				; string token
.a369		f0 3f		beq $a3aa			beq 	_ETString
.a36b		c9 fe		cmp #$fe			cmp 	#KWC_HEXCONST 				; hex constant.
.a36d		f0 12		beq $a381			beq 	_ETHexConstant
.a36f		c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; check it actually is a unary function
.a371		90 0b		bcc $a37e			bcc 	_ETSyntaxError
.a373		c9 ad		cmp #$ad			cmp 	#KWC_LAST_UNARY+1
.a375		b0 07		bcs $a37e			bcs 	_ETSyntaxError
.a377		da		phx				phx 								; push X on the stack
.a378		0a		asl a				asl 	a 							; put vector x 2 into X
.a379		aa		tax				tax
.a37a		c8		iny				iny 								; consume unary function token
.a37b		7c 64 96	jmp ($9664,x)			jmp 	(VectorSet0,x) 				; and do it.
.a37e						_ETSyntaxError:
.a37e		4c f3 ab	jmp $abf3			jmp 	SyntaxError
.a381						_ETHexConstant:
.a381		c8		iny				iny 								; skip #
.a382		c8		iny				iny 								; skip count
.a383		20 57 a9	jsr $a957			jsr 	NSMSetZero 					; clear result
.a386						_ETHLoop:
.a386		b1 30		lda ($30),y			lda 	(codePtr),y
.a388		c8		iny				iny 								; and consume
.a389		c9 00		cmp #$00			cmp 	#0 							; exit if zero
.a38b		f0 1c		beq $a3a9			beq 	_ETHExit
.a38d		48		pha				pha 								; save on stack.
.a38e		20 66 a9	jsr $a966			jsr 	NSMShiftLeft 				; x 2
.a391		20 66 a9	jsr $a966			jsr 	NSMShiftLeft 				; x 4
.a394		20 66 a9	jsr $a966			jsr 	NSMShiftLeft 				; x 8
.a397		20 66 a9	jsr $a966			jsr 	NSMShiftLeft 				; x 16
.a39a		68		pla				pla 								; ASCII
.a39b		c9 41		cmp #$41			cmp 	#'A'
.a39d		90 02		bcc $a3a1			bcc 	_ETHNotChar
.a39f		e9 07		sbc #$07			sbc 	#7
.a3a1						_ETHNotChar:
.a3a1		29 0f		and #$0f			and 	#15 						; digit now
.a3a3		15 58		ora $58,x			ora 	NSMantissa0,x 				; put in LS Nibble
.a3a5		95 58		sta $58,x			sta 	NSMantissa0,x
.a3a7		80 dd		bra $a386			bra 	_ETHLoop 					; go round.
.a3a9						_ETHExit:
.a3a9		60		rts				rts
.a3aa						_ETString:
.a3aa		c8		iny				iny 								; look at length
.a3ab		b1 30		lda ($30),y			lda 	(codePtr),y
.a3ad		48		pha				pha
.a3ae		c8		iny				iny 								; first character
.a3af		20 7a ae	jsr $ae7a			jsr 	MemoryInline 				; put address of string at (code-Ptr),y on stack
.a3b2		68		pla				pla 								; restore count and save
.a3b3		85 36		sta $36				sta 	zTemp0
.a3b5		98		tya				tya 								; add length to Y to skip it.
.a3b6		18		clc				clc
.a3b7		65 36		adc $36				adc 	zTemp0
.a3b9		a8		tay				tay
.a3ba		a9 10		lda #$10			lda 	#NSTString 					; mark as string
.a3bc		95 50		sta $50,x			sta 	NSStatus,x
.a3be		60		rts				rts
.a3bf						_ETVariable:
.a3bf		4c 14 a4	jmp $a414			jmp 	VariableHandler
.a3c2						_ETPuncUnary:
.a3c2		c8		iny				iny 								; consume the unary character
.a3c3		c9 2d		cmp #$2d			cmp 	#KWD_MINUS 					; unary minus
.a3c5		f0 2b		beq $a3f2			beq 	_ETUnaryNegate
.a3c7		c9 b8		cmp #$b8			cmp 	#KWD_AT 					; @ reference -> constant
.a3c9		f0 36		beq $a401			beq 	_ETDereference
.a3cb		c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; parenthesis
.a3cd		f0 3e		beq $a40d			beq 	_ETParenthesis
.a3cf		64 36		stz $36				stz 	zTemp0 						; zTemp0 is the indirection level.
.a3d1		c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; byte indirection (0) ?
.a3d3		f0 06		beq $a3db			beq 	_ETIndirection
.a3d5		e6 36		inc $36				inc 	zTemp0
.a3d7		c9 21		cmp #$21			cmp 	#KWD_PLING					; word indirection (1) \
.a3d9		d0 a3		bne $a37e			bne 	_ETSyntaxError
.a3db						_ETIndirection:
.a3db		a5 36		lda $36				lda 	zTemp0 						; push indirection amount (0-1) => (1-2) on the stack
.a3dd		1a		inc a				inc 	a
.a3de		48		pha				pha
.a3df		20 4b a3	jsr $a34b			jsr 	EvaluateTerm				; evaluate the term
.a3e2		20 c4 a1	jsr $a1c4			jsr 	Dereference 				; dereference it.
.a3e5		b5 50		lda $50,x			lda 	NSStatus,x 					; must be a +ve integer.
.a3e7		d0 06		bne $a3ef			bne 	_ETTypeMismatch
.a3e9		68		pla				pla 								; indirection 1-2
.a3ea		09 20		ora #$20			ora 	#NSBIsReference 			; make it a reference.
.a3ec		95 50		sta $50,x			sta 	NSStatus,x
.a3ee		60		rts				rts
.a3ef						_ETTypeMismatch:
.a3ef		4c fd ab	jmp $abfd			jmp 	TypeError
.a3f2						_ETUnaryNegate:
.a3f2		20 4b a3	jsr $a34b			jsr 	EvaluateTerm				; evaluate the term
.a3f5		20 c4 a1	jsr $a1c4			jsr 	Dereference 				; dereference it.
.a3f8		b5 50		lda $50,x			lda 	NSStatus,x 					; must be a number
.a3fa		29 10		and #$10			and 	#NSTString
.a3fc		d0 f1		bne $a3ef			bne 	_ETTypeMismatch
.a3fe		4c 19 a9	jmp $a919			jmp 	NSMNegate  					; just toggles the sign bit.
.a401						_ETDereference:
.a401		20 4b a3	jsr $a34b			jsr 	EvaluateTerm				; evaluate the term
.a404		b5 50		lda $50,x			lda 	NSStatus,x 					; must be a reference
.a406		29 20		and #$20			and 	#NSBIsReference
.a408		f0 e5		beq $a3ef			beq 	_ETTypeMismatch
.a40a		74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer address
.a40c		60		rts				rts
.a40d						_ETParenthesis:
.a40d		20 01 9f	jsr $9f01			jsr 	EvaluateExpression 			; evaluate here, from lowest precedence
.a410		20 de 99	jsr $99de			jsr 	CheckRightBracket 			; check for )
.a413		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/variable.asm

.a414						VariableHandler:
.a414		b1 30		lda ($30),y			lda 	(codePtr),y
.a416		18		clc				clc
.a417		69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.a419		85 37		sta $37				sta 	zTemp0+1
.a41b		c8		iny				iny
.a41c		b1 30		lda ($30),y			lda 	(codePtr),y
.a41e		85 36		sta $36				sta 	zTemp0
.a420		c8		iny				iny
.a421		18		clc				clc									; copy variable address+3 to mantissa
.a422		69 03		adc #$03			adc 	#3 							; this is the address of the data.
.a424		95 58		sta $58,x			sta 	NSMantissa0,x
.a426		a5 37		lda $37				lda 	zTemp0+1
.a428		69 00		adc #$00			adc 	#0
.a42a		95 60		sta $60,x			sta 	NSMantissa1,x
.a42c		74 68		stz $68,x			stz 	NSMantissa2,x
.a42e		74 70		stz $70,x			stz 	NSMantissa3,x
.a430		74 78		stz $78,x			stz 	NSExponent,x
.a432		5a		phy				phy
.a433		a0 02		ldy #$02			ldy 	#2 							; read type
.a435		b1 36		lda ($36),y			lda 	(zTemp0),y
.a437		7a		ply				ply
.a438		29 1c		and #$1c			and 	#NSBTypeMask+NSBIsArray 	; get type information
.a43a		09 20		ora #$20			ora 	#NSBIsReference 			; make a reference.
.a43c		95 50		sta $50,x			sta 	NSStatus,x
.a43e		29 04		and #$04			and 	#NSBIsArray
.a440		d0 01		bne $a443			bne 	_VHArray
.a442		60		rts				rts
.a443						_VHArray:
.a443		e8		inx				inx
.a444		20 f2 a8	jsr $a8f2			jsr 	Evaluate8BitInteger 		; get the 1st index.
.a447		a9 ff		lda #$ff			lda 	#$FF 						; set Status of X+2 to a duff value so we know if we picked it up.
.a449		95 51		sta $51,x			sta 	NSStatus+1,x
.a44b		b1 30		lda ($30),y			lda 	(codePtr),y
.a44d		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.a44f		d0 06		bne $a457			bne 	_VHNoSecondIndex
.a451		c8		iny				iny 								; skip the comma
.a452		e8		inx				inx
.a453		20 f2 a8	jsr $a8f2			jsr 	Evaluate8BitInteger 		; get the 2nd index.
.a456		ca		dex				dex
.a457						_VHNoSecondIndex:
.a457		ca		dex				dex 								; set X back.
.a458		20 de 99	jsr $99de			jsr 	CheckRightBracket 			; and check the right bracket.
.a45b		5a		phy				phy 								; save position
.a45c		b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy record address to zaTemp (moved 6/12/22)
.a45e		85 3e		sta $3e				sta 	zaTemp
.a460		b5 60		lda $60,x			lda 	NSMantissa1,x
.a462		85 3f		sta $3f				sta 	zaTemp+1
.a464		a0 02		ldy #$02			ldy 	#2 							; check first index is not-zero, e.g. array defined
.a466		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.a468		f0 5d		beq $a4c7			beq 	_VHBadArray
.a46a		a0 03		ldy #$03			ldy 	#3 							; get the second index - which is 0 if there is one index.
.a46c		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.a46e		f0 02		beq $a472			beq 	_VHHas2Mask
.a470		a9 ff		lda #$ff			lda 	#$FF
.a472						_VHHas2Mask:
.a472		d5 52		cmp $52,x			cmp 	NSStatus+2,x 				; so if they are the same there are the wrong number of indices
.a474		f0 4c		beq $a4c2			beq 	_VHBadIndex
.a476		0a		asl a				asl 	a 							; carry will be set if a second index
.a477		90 08		bcc $a481			bcc 	_VHCheckFirstIndex
.a479		a0 03		ldy #$03			ldy 	#3 			 				; check the 2nd size >= 2nd index
.a47b		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.a47d		d5 5a		cmp $5a,x			cmp 	NSMantissa0+2,x
.a47f		90 41		bcc $a4c2			bcc 	_VHBadIndex
.a481						_VHCheckFirstIndex:
.a481		a0 02		ldy #$02			ldy 	#2 			 				; check the 2nd size >= 2nd index
.a483		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.a485		d5 59		cmp $59,x			cmp 	NSMantissa0+1,x
.a487		90 39		bcc $a4c2			bcc 	_VHBadIndex
.a489		64 36		stz $36				stz 	zTemp0 						; clear zTemp0 (if 1 index)
.a48b		64 37		stz $37				stz 	zTemp0+1
.a48d		b5 52		lda $52,x			lda 	NSStatus+2,x 				; if only one index provided, don't need to multiply
.a48f		30 0e		bmi $a49f			bmi 	_VHNoMultiply
.a491		da		phx				phx
.a492		b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; get 2nd index on stack
.a494		48		pha				pha
.a495		a0 02		ldy #$02			ldy 	#2 							; get 1st size in A
.a497		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.a499		1a		inc a				inc 	a 							; add 1 for zero base
.a49a		fa		plx				plx
.a49b		20 02 a9	jsr $a902			jsr 	Multiply8x8 				; calculate -> Z0
.a49e		fa		plx				plx
.a49f						_VHNoMultiply:
.a49f		18		clc				clc
.a4a0		a5 36		lda $36				lda 	zTemp0
.a4a2		75 59		adc $59,x			adc 	NSMantissa0+1,x
.a4a4		85 36		sta $36				sta 	zTemp0
.a4a6		a5 37		lda $37				lda 	zTemp0+1
.a4a8		69 00		adc #$00			adc 	#0
.a4aa		85 37		sta $37				sta 	zTemp0+1
.a4ac		b5 50		lda $50,x			lda 	NSStatus,x
.a4ae		20 2a 89	jsr $892a			jsr 	ScaleByBaseType
.a4b1		18		clc				clc
.a4b2		b2 3e		lda ($3e)			lda 	(zaTemp)
.a4b4		65 36		adc $36				adc 	zTemp0
.a4b6		95 58		sta $58,x			sta 	NSMantissa0,x
.a4b8		a0 01		ldy #$01			ldy 	#1
.a4ba		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.a4bc		65 37		adc $37				adc 	zTemp0+1
.a4be		95 60		sta $60,x			sta 	NSMantissa1,x
.a4c0		7a		ply				ply 								; restore position
.a4c1		60		rts				rts
.a4c2						_VHBadIndex:
.a4c2		a9 17		lda #$17		lda	#23
.a4c4		4c f7 99	jmp $99f7		jmp	ErrorHandler
.a4c7						_VHBadArray:
.a4c7		a9 18		lda #$18		lda	#24
.a4c9		4c f7 99	jmp $99f7		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/abs.asm

.a4cc						AbsUnary:
.a4cc		fa		plx				plx 								; restore stack pos
.a4cd		20 a5 a8	jsr $a8a5			jsr 	EvaluateNumber 				; get a float or int
.a4d0		20 de 99	jsr $99de			jsr 	CheckRightBracket
.a4d3		b5 50		lda $50,x			lda 	NSStatus,x 					; clear the sign bit
.a4d5		29 7f		and #$7f			and 	#$7F
.a4d7		95 50		sta $50,x			sta 	NSStatus,x
.a4d9		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/alloc.asm

.a4da						AllocUnary:
.a4da		fa		plx				plx 								; restore stack pos
.a4db		20 d7 a8	jsr $a8d7			jsr 	Evaluate16BitInteger		; get bytes required.
.a4de		20 de 99	jsr $99de			jsr 	CheckRightBracket
.a4e1		da		phx				phx 								; save X/Y
.a4e2		5a		phy				phy
.a4e3		8a		txa				txa 								; copy X into Y
.a4e4		a8		tay				tay
.a4e5		b9 60 00	lda $0060,y			lda		NSMantissa1,y 				; get size into XA
.a4e8		aa		tax				tax
.a4e9		b9 58 00	lda $0058,y			lda 	NSMantissa0,y
.a4ec		20 f9 a4	jsr $a4f9			jsr 	AllocateXABytes 			; allocate memory
.a4ef		99 58 00	sta $0058,y			sta 	NSMantissa0,y 				; write address out.
.a4f2		8a		txa				txa 	 							; typing is 16 bit integer.
.a4f3		99 60 00	sta $0060,y			sta 	NSMantissa1,y
.a4f6		7a		ply				ply
.a4f7		fa		plx				plx
.a4f8		60		rts				rts
.a4f9						AllocateXABytes:
.a4f9		5a		phy				phy
.a4fa		ac 08 04	ldy $0408			ldy 	lowMemPtr 					; push current address on stack and to zTemp0
.a4fd		84 36		sty $36				sty 	zTemp0
.a4ff		5a		phy				phy
.a500		ac 09 04	ldy $0409			ldy 	lowMemPtr+1
.a503		84 37		sty $37				sty 	zTemp0+1
.a505		5a		phy				phy
.a506		18		clc				clc 								; add to low memory pointer
.a507		6d 08 04	adc $0408			adc 	lowMemPtr
.a50a		8d 08 04	sta $0408			sta 	lowMemPtr
.a50d		8a		txa				txa
.a50e		6d 09 04	adc $0409			adc 	lowMemPtr+1
.a511		8d 09 04	sta $0409			sta 	lowMemPtr+1
.a514		b0 2f		bcs $a545			bcs 	CISSMemory
.a516		20 37 a5	jsr $a537			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.a519						_ClearMemory:
.a519		ad 08 04	lda $0408			lda 	lowMemPtr 					; cleared all memory allocated
.a51c		c5 36		cmp $36				cmp 	zTemp0
.a51e		d0 07		bne $a527			bne 	_CMClearNext
.a520		ad 09 04	lda $0409			lda 	lowMemPtr+1
.a523		c5 37		cmp $37				cmp 	zTemp0+1
.a525		f0 0c		beq $a533			beq 	_CMExit
.a527						_CMClearNext:
.a527		a9 00		lda #$00			lda 	#0 							; clear byte, advance to next.
.a529		92 36		sta ($36)			sta 	(zTemp0)
.a52b		e6 36		inc $36				inc 	zTemp0
.a52d		d0 ea		bne $a519			bne 	_ClearMemory
.a52f		e6 37		inc $37				inc		zTemp0+1
.a531		80 e6		bra $a519			bra 	_ClearMemory
.a533						_CMExit:
.a533		fa		plx				plx
.a534		68		pla				pla
.a535		7a		ply				ply
.a536		60		rts				rts
.a537						CheckIdentifierStringSpace:
.a537		48		pha				pha
.a538		ad 09 04	lda $0409			lda 	lowMemPtr+1 				; get low memory pointer
.a53b		18		clc				clc
.a53c		69 02		adc #$02			adc 	#2 							; need at least 2 256 byte pages
.a53e		cd 0b 04	cmp $040b			cmp 	stringMemory+1 				; is it >= StringMemory
.a541		b0 02		bcs $a545			bcs 	CISSMemory
.a543		68		pla				pla
.a544		60		rts				rts
.a545						CISSMemory:
.a545		a9 06		lda #$06		lda	#6
.a547		4c f7 99	jmp $99f7		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/asc.asm

.a54a						AscUnary:
.a54a		fa		plx				plx 								; restore stack pos
.a54b		20 af a8	jsr $a8af			jsr 	EvaluateString 				; get a string
.a54e		b2 36		lda ($36)			lda 	(zTemp0)					; get/return first character
.a550		20 59 a9	jsr $a959			jsr 	NSMSetByte 					; ASC("") will return zero.
.a553		20 de 99	jsr $99de			jsr 	CheckRightBracket
.a556		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/frac.asm

.a557						FracUnary:
.a557		fa		plx				plx 								; restore stack pos
.a558		20 a5 a8	jsr $a8a5			jsr 	EvaluateNumber 				; get a float or int
.a55b		20 de 99	jsr $99de			jsr 	CheckRightBracket
.a55e		b5 50		lda $50,x			lda 	NSStatus,x
.a560		29 08		and #$08			and 	#NSTFloat 					; check it is a float
.a562		f0 04		beq $a568			beq 	_IUZero
.a564		20 12 a0	jsr $a012			jsr 	FloatFractionalPart 		; if so, get the fractional part.
.a567		60		rts				rts
.a568						_IUZero:
.a568		20 57 a9	jsr $a957			jsr 	NSMSetZero
.a56b		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/int.asm

.a56c						IntUnary:
.a56c		fa		plx				plx 								; restore stack pos
.a56d		20 a5 a8	jsr $a8a5			jsr 	EvaluateNumber 				; get a float or int
.a570		20 de 99	jsr $99de			jsr 	CheckRightBracket
.a573		b5 50		lda $50,x			lda 	NSStatus,x
.a575		29 08		and #$08			and 	#NSTFloat 					; check it is a float
.a577		f0 03		beq $a57c			beq 	_IUExit
.a579		20 6a a0	jsr $a06a			jsr 	FloatIntegerPart 			; if it is get the integer part.
.a57c						_IUExit:
.a57c		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/len.asm

.a57d						LenUnary:
.a57d		fa		plx				plx 								; restore stack pos
.a57e		20 af a8	jsr $a8af			jsr 	EvaluateString 				; get a string
.a581		5a		phy				phy
.a582		a0 00		ldy #$00			ldy 	#0 							; find length
.a584						_LenFind:
.a584		b1 36		lda ($36),y			lda 	(zTemp0),y 					; look for trailing NULL.
.a586		f0 06		beq $a58e			beq 	_LenExit
.a588		c8		iny				iny
.a589		d0 f9		bne $a584			bne 	_LenFind
.a58b		4c f8 ab	jmp $abf8			jmp 	RangeError 					; string > 255 - no trailing NULL.
.a58e						_LenExit:
.a58e		98		tya				tya		 							; return length
.a58f		20 59 a9	jsr $a959			jsr 	NSMSetByte
.a592		7a		ply				ply
.a593		20 de 99	jsr $99de			jsr 	CheckRightBracket
.a596		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/minmax.asm

.a597						Unary_Min:
.a597		a9 01		lda #$01			lda 	#1
.a599		80 02		bra $a59d			bra 	UnaryMinMaxMain
.a59b						Unary_Max:
.a59b		a9 ff		lda #$ff			lda 	#$FF 						; value from comparator to cause a write
.a59d						UnaryMinMaxMain:
.a59d		fa		plx				plx 								; get index on number stack
.a59e		48		pha				pha 								; save comparator
.a59f		20 9c a8	jsr $a89c			jsr 	EvaluateValue 				; get the first value.
.a5a2						_UMMMLoop:
.a5a2		b1 30		lda ($30),y			lda 	(codePtr),y
.a5a4		c9 29		cmp #$29			cmp 	#KWD_RPAREN 				; if right bracket then done.
.a5a6		f0 22		beq $a5ca			beq 	_UMMMDone
.a5a8		20 e6 99	jsr $99e6			jsr 	CheckComma 					; must be a comma
.a5ab		e8		inx				inx
.a5ac		20 9c a8	jsr $a89c			jsr 	EvaluateValue
.a5af		ca		dex				dex
.a5b0		20 3a a9	jsr $a93a			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] (Compare is destructive)
.a5b3		e8		inx				inx
.a5b4		20 3a a9	jsr $a93a			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2], original
.a5b7		e8		inx				inx
.a5b8		20 b4 9a	jsr $9ab4			jsr 	CompareBaseCode 			; part of > = < etc. code, returns 255,0 or 1
.a5bb		ca		dex				dex
.a5bc		ca		dex				dex
.a5bd		85 36		sta $36				sta 	zTemp0 						; save required result
.a5bf		68		pla				pla 								; get and save comparator
.a5c0		48		pha				pha
.a5c1		c5 36		cmp $36				cmp 	zTemp0 						; if the comparator
.a5c3		d0 dd		bne $a5a2			bne 	_UMMMLoop
.a5c5		20 cd a5	jsr $a5cd			jsr 	ExpCopyAboveDown 			; copy next up slot down
.a5c8		80 d8		bra $a5a2			bra 	_UMMMLoop
.a5ca						_UMMMDone:
.a5ca		68		pla				pla 								; throw the comparator
.a5cb		c8		iny				iny 								; skip )
.a5cc		60		rts				rts
.a5cd						ExpCopyAboveDown:
.a5cd		b5 51		lda $51,x			lda 	NSStatus+1,x
.a5cf		95 50		sta $50,x			sta 	NSStatus,x
.a5d1		b5 79		lda $79,x			lda 	NSExponent+1,x
.a5d3		95 78		sta $78,x			sta 	NSExponent,x
.a5d5		b5 59		lda $59,x			lda 	NSMantissa0+1,x
.a5d7		95 58		sta $58,x			sta 	NSMantissa0,x
.a5d9		b5 61		lda $61,x			lda 	NSMantissa1+1,x
.a5db		95 60		sta $60,x			sta 	NSMantissa1,x
.a5dd		b5 69		lda $69,x			lda 	NSMantissa2+1,x
.a5df		95 68		sta $68,x			sta 	NSMantissa2,x
.a5e1		b5 71		lda $71,x			lda 	NSMantissa3+1,x
.a5e3		95 70		sta $70,x			sta 	NSMantissa3,x
.a5e5		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/not.asm

.a5e6						Unary_Not:
.a5e6		fa		plx				plx
.a5e7		20 c4 a8	jsr $a8c4			jsr 	EvaluateInteger 			; get integer
.a5ea		20 de 99	jsr $99de			jsr 	CheckRightBracket
.a5ed		20 79 a9	jsr $a979			jsr 	NSMIsZero 					; zero mantissa ?
.a5f0		f0 04		beq $a5f6			beq 	_NotZero
.a5f2		20 57 a9	jsr $a957			jsr 	NSMSetZero
.a5f5		60		rts				rts
.a5f6						_NotZero:
.a5f6		4c 6a 9a	jmp $9a6a			jmp 	ReturnTrue

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/peek.asm

.a5f9						PeekByteUnary:
.a5f9		a9 01		lda #$01			lda 	#1
.a5fb		80 0a		bra $a607			bra 	PeekUnary
.a5fd						PeekWUnary:
.a5fd		a9 02		lda #$02			lda 	#2
.a5ff		80 06		bra $a607			bra 	PeekUnary
.a601						PeekLUnary:
.a601		a9 03		lda #$03			lda 	#3
.a603		80 02		bra $a607			bra 	PeekUnary
.a605						PeekDUnary:
.a605		a9 04		lda #$04			lda 	#4
.a607						PeekUnary:
.a607		fa		plx				plx 								; restore position.
.a608		48		pha				pha 								; save count to copy on stack
.a609		20 d7 a8	jsr $a8d7			jsr		Evaluate16BitInteger 		; address as constant.
.a60c		20 de 99	jsr $99de			jsr 	CheckRightBracket
.a60f		b5 58		lda $58,x			lda 	NSMantissa0,x 				; save mantissa in zTemp0 as address
.a611		85 36		sta $36				sta 	zTemp0
.a613		b5 60		lda $60,x			lda 	NSMantissa1,x
.a615		85 37		sta $37				sta 	zTemp0+1
.a617		20 57 a9	jsr $a957			jsr 	NSMSetZero 					; clear the result to zero.
.a61a		68		pla				pla 								; count in zTemp2
.a61b		85 3a		sta $3a				sta 	zTemp2
.a61d		da		phx				phx 								; save stack position and offset of read
.a61e		5a		phy				phy
.a61f		a0 00		ldy #$00			ldy 	#0 							; byte read offset.
.a621						_PULoop:
.a621		b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next byte, write to mantissa0,x
.a623		95 58		sta $58,x			sta 	NSMantissa0,x 				; we change X not the index before it.
.a625		c8		iny				iny 								; next byte to write
.a626		8a		txa				txa 								; next byte to read - stack layout in 04data.inc
.a627		18		clc				clc
.a628		69 08		adc #$08			adc 	#MathStackSize
.a62a		aa		tax				tax
.a62b		c6 3a		dec $3a				dec 	zTemp2 						; done them all
.a62d		d0 f2		bne $a621			bne 	_PULoop
.a62f		7a		ply				ply 								; restore stack/code pos and exit.
.a630		fa		plx				plx
.a631		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/sgn.asm

.a632						SgnUnary:
.a632		fa		plx				plx 								; restore stack pos
.a633		20 a5 a8	jsr $a8a5			jsr 	EvaluateNumber 				; get a float or int
.a636		20 de 99	jsr $99de			jsr 	CheckRightBracket
.a639		20 79 a9	jsr $a979			jsr 	NSMIsZero 					; if zero
.a63c		f0 0e		beq $a64c			beq 	_SGZero  					; return Int Zero
.a63e		b5 50		lda $50,x			lda 	NSStatus,x 					; get status w/sign
.a640		48		pha				pha
.a641		a9 01		lda #$01			lda 	#1 							; set to 1
.a643		20 59 a9	jsr $a959			jsr 	NSMSetByte
.a646		68		pla				pla
.a647		29 80		and #$80			and		#$80 						; copy the sign byte out
.a649		95 50		sta $50,x			sta 	NSStatus,x  				; so it will be -1 or 1
.a64b		60		rts				rts
.a64c		20 57 a9	jsr $a957	_SGZero:jsr 	NSMSetZero
.a64f		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/val.asm

.a650						ValUnary:
.a650		fa		plx				plx 								; restore stack pos
.a651		20 66 a6	jsr $a666			jsr 	ValMainCode 				; do the main val() code
.a654		b0 01		bcs $a657			bcs 	_VUError 					; couldn't convert
.a656		60		rts				rts
.a657						_VUError:
.a657		4c fd ab	jmp $abfd			jmp 	TypeError
.a65a						IsValUnary:
.a65a		fa		plx				plx 								; restore stack pos
.a65b		20 66 a6	jsr $a666			jsr 	ValMainCode 				; do the main val() code
.a65e		b0 03		bcs $a663			bcs 	_VUBad
.a660		4c 6a 9a	jmp $9a6a			jmp 	ReturnTrue
.a663						_VUBad:
.a663		4c 75 9a	jmp $9a75			jmp 	ReturnFalse
.a666						ValMainCode:
.a666		20 af a8	jsr $a8af			jsr 	EvaluateString 				; get a string
.a669		20 de 99	jsr $99de			jsr 	CheckRightBracket 			; check right bracket present
.a66c						ValEvaluateZTemp0:
.a66c		5a		phy				phy
.a66d		b2 36		lda ($36)			lda 	(zTemp0) 					; check not empty string
.a66f		f0 17		beq $a688			beq 	_VMCFail2
.a671		a0 ff		ldy #$ff			ldy 	#$FF 						; start position
.a673		48		pha				pha 								; save first character
.a674		c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.a676		d0 01		bne $a679			bne 	_VMCStart
.a678		c8		iny				iny 								; skip over -
.a679						_VMCStart:
.a679		38		sec				sec 								; initialise first time round.
.a67a						_VMCNext:
.a67a		c8		iny				iny 								; pre-increment
.a67b		b1 36		lda ($36),y			lda 	(zTemp0),y 					; next character = EOS ?
.a67d		f0 0c		beq $a68b			beq 	_VMCSuccess 				; successful.
.a67f		20 47 a2	jsr $a247			jsr 	EncodeNumber 				; send it to the number-builder
.a682		90 03		bcc $a687			bcc 	_VMCFail 					; if failed, give up.
.a684		18		clc				clc 								; next time round, countinue
.a685		80 f3		bra $a67a			bra 	_VMCNext
.a687						_VMCFail:
.a687		68		pla				pla
.a688						_VMCFail2:
.a688		7a		ply				ply
.a689		38		sec				sec
.a68a		60		rts				rts
.a68b						_VMCSuccess:
.a68b		a9 00		lda #$00			lda 	#0 							; construct final
.a68d		20 47 a2	jsr $a247			jsr 	EncodeNumber 				; by sending a duff value.
.a690		68		pla				pla 								; if it was -ve
.a691		c9 2d		cmp #$2d			cmp 	#"-"
.a693		d0 03		bne $a698			bne 	_VMCNotNegative
.a695		20 19 a9	jsr $a919			jsr		NSMNegate 					; negate it.
.a698						_VMCNotNegative:
.a698		7a		ply				ply
.a699		18		clc				clc
.a69a		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/chr.asm

.a69b						ChrUnary:
.a69b		fa		plx				plx 								; restore stack pos
.a69c		20 f2 a8	jsr $a8f2			jsr 	Evaluate8BitInteger			; get value (chr$(0) returns an empty string)
.a69f		48		pha				pha
.a6a0		20 de 99	jsr $99de			jsr 	CheckRightBracket
.a6a3		a9 01		lda #$01			lda 	#1 							; allocate space for one char
.a6a5		20 5d b3	jsr $b35d			jsr 	StringTempAllocate
.a6a8		68		pla				pla 								; write number to it
.a6a9		20 96 b3	jsr $b396			jsr 	StringTempWrite
.a6ac		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/items.asm

.a6ad						ItemCountUnary:
.a6ad		fa		plx				plx
.a6ae		20 af a8	jsr $a8af			jsr 	EvaluateString
.a6b1		e8		inx				inx
.a6b2		20 25 a7	jsr $a725			jsr 	ICGetSeperator
.a6b5		ca		dex				dex
.a6b6		20 46 a7	jsr $a746			jsr 	ICSetPointer 				; zTemp0 = (string)
.a6b9		20 57 a9	jsr $a957			jsr 	NSMSetZero 					; zero the result.
.a6bc		5a		phy				phy
.a6bd		a0 ff		ldy #$ff			ldy 	#$FF 						; loop counting seperators in mantissa
.a6bf						_ICULoop:
.a6bf		c8		iny				iny
.a6c0		b1 36		lda ($36),y			lda 	(zTemp0),y
.a6c2		cd b0 07	cmp $07b0			cmp 	ICSeperator
.a6c5		d0 02		bne $a6c9			bne 	_ICUNoMatch
.a6c7		f6 58		inc $58,x			inc 	NSMantissa0,x
.a6c9						_ICUNoMatch:
.a6c9		c9 00		cmp #$00			cmp 	#0
.a6cb		d0 f2		bne $a6bf			bne 	_ICULoop
.a6cd		f6 58		inc $58,x			inc 	NSMantissa0,x 				; +1
.a6cf		7a		ply				ply
.a6d0		60		rts				rts
.a6d1						ItemGetUnary:
.a6d1		fa		plx				plx
.a6d2		20 af a8	jsr $a8af			jsr 	EvaluateString 				; search string
.a6d5		20 e6 99	jsr $99e6			jsr 	CheckComma
.a6d8		e8		inx				inx 								; get count
.a6d9		20 f2 a8	jsr $a8f2			jsr 	Evaluate8BitInteger
.a6dc		c9 00		cmp #$00			cmp 	#0 							; must be > 0, index starts at 1.
.a6de		f0 61		beq $a741			beq 	ICGSRange
.a6e0		e8		inx				inx 								; get seperator.
.a6e1		20 25 a7	jsr $a725			jsr 	ICGetSeperator
.a6e4		ca		dex				dex
.a6e5		ca		dex				dex
.a6e6		5a		phy				phy
.a6e7		20 46 a7	jsr $a746			jsr 	ICSetPointer 				; zTemp0 points to string.
.a6ea		a0 00		ldy #$00			ldy 	#0
.a6ec		d6 59		dec $59,x			dec 	NSMantissa0+1,x 			; first element.
.a6ee		f0 0e		beq $a6fe			beq 	_IGUFoundStart
.a6f0						_IGUFindNext:
.a6f0		b1 36		lda ($36),y			lda 	(zTemp0),y		 			; next
.a6f2		f0 4d		beq $a741			beq 	ICGSRange 					; eol, not found.
.a6f4		c8		iny				iny
.a6f5		cd b0 07	cmp $07b0			cmp 	ICSeperator 				; until found a seperator (or EOS)
.a6f8		d0 f6		bne $a6f0			bne 	_IGUFindNext
.a6fa		d6 59		dec $59,x			dec 	NSMantissa0+1,x
.a6fc		d0 f2		bne $a6f0			bne 	_IGUFindNext
.a6fe						_IGUFoundStart:
.a6fe		84 38		sty $38				sty 	zTemp1 						; save start
.a700		88		dey				dey
.a701						_IGUFindLength:
.a701		c8		iny				iny 								; forward till seperator/EOS
.a702		b1 36		lda ($36),y			lda 	(zTemp0),y
.a704		f0 05		beq $a70b			beq 	_IGUFoundLength
.a706		cd b0 07	cmp $07b0			cmp 	ICSeperator
.a709		d0 f6		bne $a701			bne 	_IGUFindLength
.a70b						_IGUFoundLength:
.a70b		84 39		sty $39				sty 	zTemp1+1 					; save end of copy string
.a70d		98		tya				tya 								; calculate length of new string.
.a70e		38		sec				sec
.a70f		e5 38		sbc $38				sbc 	zTemp1
.a711		20 5d b3	jsr $b35d			jsr 	StringTempAllocate 			; allocate bytes for it.
.a714		a4 38		ldy $38				ldy 	zTemp1
.a716						_IGUCopySub:
.a716		c4 39		cpy $39				cpy 	zTemp1+1
.a718		f0 08		beq $a722			beq 	_IGUCopyOver
.a71a		b1 36		lda ($36),y			lda 	(zTemp0),y
.a71c		20 96 b3	jsr $b396			jsr 	StringTempWrite
.a71f		c8		iny				iny
.a720		80 f4		bra $a716			bra 	_IGUCopySub
.a722						_IGUCopyOver:
.a722		7a		ply				ply
.a723		60		rts				rts
>a724		db						.byte 	$DB 						; causes a break in the emulator
.a725						ICGetSeperator:
.a725		20 e6 99	jsr $99e6			jsr 	CheckComma 					; preceding comma
.a728		20 af a8	jsr $a8af			jsr 	EvaluateString 				; seperator string
.a72b		20 46 a7	jsr $a746			jsr 	ICSetPointer 				; access it
.a72e		b2 36		lda ($36)			lda 	(zTemp0) 					; get sep char
.a730		8d b0 07	sta $07b0			sta 	ICSeperator
.a733		f0 0c		beq $a741			beq 	ICGSRange 					; check LEN(seperator) = 1
.a735		5a		phy				phy
.a736		a0 01		ldy #$01			ldy 	#1
.a738		b1 36		lda ($36),y			lda 	(zTemp0),y
.a73a		d0 05		bne $a741			bne 	ICGSRange
.a73c		7a		ply				ply
.a73d		20 de 99	jsr $99de			jsr 	CheckRightBracket 			; check following )
.a740		60		rts				rts
.a741						ICGSRange:
.a741		a9 04		lda #$04		lda	#4
.a743		4c f7 99	jmp $99f7		jmp	ErrorHandler
.a746						ICSetPointer:
.a746		b5 58		lda $58,x			lda 	NSMantissa0,x 				; set zTemp0 to point to it.
.a748		85 36		sta $36				sta 	zTemp0
.a74a		b5 60		lda $60,x			lda 	NSMantissa1,x
.a74c		85 37		sta $37				sta 	zTemp0+1
.a74e		60		rts				rts
.07b0						ICSeperator:
>07b0								.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/spc.asm

.a74f						SpcUnary:
.a74f		fa		plx				plx 								; restore stack pos
.a750		20 f2 a8	jsr $a8f2			jsr 	Evaluate8BitInteger			; get value
.a753		5a		phy				phy
.a754		48		pha				pha 								; save count
.a755		20 5d b3	jsr $b35d			jsr 	StringTempAllocate
.a758		7a		ply				ply 								; to do count in Y
.a759						_SpcLoop:
.a759		c0 00		cpy #$00			cpy 	#0 							; copy Y spaces in.
.a75b		f0 08		beq $a765			beq 	_SpcExit
.a75d		a9 20		lda #$20			lda 	#32
.a75f		20 96 b3	jsr $b396			jsr 	StringTempWrite
.a762		88		dey				dey
.a763		80 f4		bra $a759			bra 	_SpcLoop
.a765						_SpcExit:
.a765		7a		ply				ply
.a766		20 de 99	jsr $99de			jsr 	CheckRightBracket
.a769		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/str.asm

.a76a						Unary_Str:
.a76a		fa		plx				plx
.a76b		20 a5 a8	jsr $a8a5			jsr 	EvaluateNumber  			; get number
.a76e		20 de 99	jsr $99de			jsr 	CheckRightBracket 			; closing bracket
.a771		a9 05		lda #$05			lda 	#5 							; maximum decimals, from Basic816
.a773		20 8c a7	jsr $a78c			jsr 	ConvertNumberToString 		; do the conversion.
.a776		a9 21		lda #$21			lda		#33 						; create buffer
.a778		20 5d b3	jsr $b35d			jsr 	StringTempAllocate 			; allocate memory
.a77b		da		phx				phx  								; copy the converted string into the buffer.
.a77c		a2 00		ldx #$00			ldx 	#0
.a77e						_USCopy:
.a77e		bd 45 06	lda $0645,x			lda 	decimalBuffer,x
.a781		20 96 b3	jsr $b396			jsr 	StringTempWrite
.a784		e8		inx				inx
.a785		bd 45 06	lda $0645,x			lda 	decimalBuffer,x
.a788		d0 f4		bne $a77e			bne 	_USCopy
.a78a		fa		plx				plx
.a78b		60		rts				rts
.a78c						ConvertNumberToString:
.a78c		5a		phy				phy 								; save code position
.a78d		8d 10 04	sta $0410			sta 	decimalPlaces	 			; save number of DPs.
.a790		9c 11 04	stz $0411			stz 	dbOffset 					; offset into decimal buffer = start.
.a793		b5 50		lda $50,x			lda 	NSStatus,x  				; is it -ve.
.a795		10 09		bpl $a7a0			bpl 	_CNTSNotNegative
.a797		29 7f		and #$7f			and 	#$7F 						; make +ve
.a799		95 50		sta $50,x			sta 	NSStatus,x
.a79b		a9 2d		lda #$2d			lda 	#"-"
.a79d		20 01 a8	jsr $a801			jsr 	WriteDecimalBuffer
.a7a0						_CNTSNotNegative:
.a7a0		b5 78		lda $78,x			lda 	NSExponent,x 				; check if decimal
.a7a2		f0 12		beq $a7b6			beq 	_CNTSNotFloat
.a7a4		e8		inx				inx 								; round up so we don't get too many 6.999999
.a7a5		a9 01		lda #$01			lda 	#1
.a7a7		20 59 a9	jsr $a959			jsr 	NSMSetByte
.a7aa		ca		dex				dex
.a7ab		b5 78		lda $78,x			lda		NSExponent,x
.a7ad		95 79		sta $79,x			sta 	NSExponent+1,x
.a7af		a9 08		lda #$08			lda 	#NSTFloat
.a7b1		95 51		sta $51,x			sta 	NSStatus+1,x
.a7b3		20 4c 9f	jsr $9f4c			jsr 	FloatAdd
.a7b6						_CNTSNotFloat:
.a7b6		20 e3 a7	jsr $a7e3			jsr 	MakePlusTwoString 			; do the integer part.
.a7b9		20 12 a0	jsr $a012			jsr 	FloatFractionalPart 		; get the fractional part
.a7bc		20 c3 a0	jsr $a0c3			jsr 	NSNormalise					; normalise , exit if zero
.a7bf		f0 20		beq $a7e1			beq 	_CNTSExit
.a7c1		a9 2e		lda #$2e			lda 	#"."
.a7c3		20 01 a8	jsr $a801			jsr 	WriteDecimalBuffer 			; write decimal place
.a7c6						_CNTSDecimal:
.a7c6		ce 10 04	dec $0410			dec 	decimalPlaces 				; done all the decimals
.a7c9		30 16		bmi $a7e1			bmi 	_CNTSExit
.a7cb		e8		inx				inx 								; x 10.0
.a7cc		a9 0a		lda #$0a			lda 	#10
.a7ce		20 59 a9	jsr $a959			jsr 	NSMSetByte
.a7d1		a9 08		lda #$08			lda 	#NSTFloat
.a7d3		95 50		sta $50,x			sta 	NSStatus,x
.a7d5		ca		dex				dex
.a7d6		20 91 a0	jsr $a091			jsr 	FloatMultiply
.a7d9		20 e3 a7	jsr $a7e3			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.a7dc		20 12 a0	jsr $a012			jsr 	FloatFractionalPart 		; get the fractional part
.a7df		80 e5		bra $a7c6			bra 	_CNTSDecimal 				; keep going.
.a7e1						_CNTSExit:
.a7e1		7a		ply				ply
.a7e2		60		rts				rts
.a7e3						MakePlusTwoString:
.a7e3		da		phx				phx
.a7e4		20 3a a9	jsr $a93a			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.a7e7		e8		inx				inx 								; access it
.a7e8		e8		inx				inx
.a7e9		20 6a a0	jsr $a06a			jsr 	FloatIntegerPart 			; make it an integer
.a7ec		a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.a7ee		20 7c 9e	jsr $9e7c			jsr 	ConvertInt32
.a7f1		a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.a7f3						_MPTSCopy:
.a7f3		bd 23 06	lda $0623,x			lda 	numberBuffer,x
.a7f6		20 01 a8	jsr $a801			jsr 	WriteDecimalBuffer
.a7f9		e8		inx				inx
.a7fa		bd 23 06	lda $0623,x			lda 	numberBuffer,x
.a7fd		d0 f4		bne $a7f3			bne 	_MPTSCopy
.a7ff		fa		plx				plx
.a800		60		rts				rts
.a801						WriteDecimalBuffer:
.a801		da		phx				phx
.a802		ae 11 04	ldx $0411			ldx 	dbOffset
.a805		9d 45 06	sta $0645,x			sta 	decimalBuffer,x
.a808		9e 46 06	stz $0646,x			stz 	decimalBuffer+1,x
.a80b		ee 11 04	inc $0411			inc 	dbOffset
.a80e		fa		plx				plx
.a80f		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/substring.asm

.a810						Unary_Left:
.a810		fa		plx				plx
.a811		18		clc				clc 								; only one parameter
.a812		20 75 a8	jsr $a875			jsr 	SubstringInitial 			; set up.
.a815		b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; Param #1 is the length
.a817		95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.a819		74 59		stz $59,x			stz 	NSMantissa0+1,x 			; Start is zero.
.a81b		80 25		bra $a842			bra 	SubstringMain
.a81d						Unary_Right:
.a81d		fa		plx				plx
.a81e		18		clc				clc 								; only one parameter
.a81f		20 75 a8	jsr $a875			jsr 	SubstringInitial 			; set up.
.a822		b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; length => param 2
.a824		95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.a826		b5 78		lda $78,x			lda 	NSExponent,x 				; total length
.a828		f5 59		sbc $59,x			sbc 	NSMantissa0+1,x 			; length - required.
.a82a		b0 02		bcs $a82e			bcs 	_URNotUnderflow
.a82c		a9 00		lda #$00			lda 	#0 							; start from the beginning, as something like right$("AB",3)
.a82e						_URNotUnderflow:
.a82e		95 59		sta $59,x			sta 	NSMantissa0+1,x 			; this is the start position
.a830		80 10		bra $a842			bra 	SubstringMain
.a832						Unary_Mid:
.a832		fa		plx				plx
.a833		38		sec				sec 								; two parameters
.a834		20 75 a8	jsr $a875			jsr 	SubstringInitial 			; set up.
.a837		b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; first parameter is zero ?
.a839		f0 04		beq $a83f			beq 	_UMError
.a83b		d6 59		dec $59,x			dec 	NSMantissa0+1,x				; reduce initial offset by 1 as MID$(a$,1..) is actually the first character
.a83d		80 03		bra $a842			bra 	SubstringMain
.a83f						_UMError:
.a83f		4c 02 ac	jmp $ac02			jmp 	ArgumentError
.a842						SubstringMain:
.a842		b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; is the initial offset >= the length
.a844		d5 78		cmp $78,x			cmp 	NSExponent,x
.a846		b0 27		bcs $a86f			bcs 	_SSMNull 					; if so, return an empty string.
.a848		b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; if copy count is zero
.a84a		f0 23		beq $a86f			beq 	_SSMNull 					; return empty string.
.a84c		18		clc				clc 								; add the offset +1 to the address and
.a84d		b5 58		lda $58,x			lda	 	NSMantissa0,x 				; put in zTemp, this is the start of the substring to copy.
.a84f		75 59		adc $59,x			adc 	NSMantissa0+1,x
.a851		85 36		sta $36				sta 	zTemp0
.a853		b5 60		lda $60,x			lda	 	NSMantissa1,x
.a855		69 00		adc #$00			adc 	#0
.a857		85 37		sta $37				sta 	zTemp0+1
.a859						_SSMNoCarry:
.a859		b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; characters required.
.a85b		20 5d b3	jsr $b35d			jsr 	StringTempAllocate 			; allocate that many characters
.a85e		5a		phy				phy 								; save Y
.a85f		a0 00		ldy #$00			ldy 	#0 							; start copying in.
.a861						_SSMCopy:
.a861		b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next character
.a863		f0 08		beq $a86d			beq 	_SSMEString 				; no more to copy
.a865		20 96 b3	jsr $b396			jsr 	StringTempWrite 			; and write it out.
.a868		c8		iny				iny
.a869		d6 5a		dec $5a,x			dec 	NSMantissa0+2,x
.a86b		d0 f4		bne $a861			bne 	_SSMCopy
.a86d						_SSMEString:
.a86d		7a		ply				ply
.a86e						_SSMExit:
.a86e		60		rts				rts
.a86f						_SSMNull:
.a86f		a9 00		lda #$00			lda 	#0
.a871		20 5d b3	jsr $b35d			jsr 	StringTempAllocate
.a874		60		rts				rts
.a875						SubstringInitial:
.a875		da		phx				phx 								; save initial stack position
.a876		08		php				php 								; save carry on stack indicating 2 parameters
.a877		20 af a8	jsr $a8af			jsr 	EvaluateString 				; get a string
.a87a		5a		phy				phy 								; calculate length to exponent.
.a87b		a0 ff		ldy #$ff			ldy 	#$FF
.a87d						_SIFindLength:
.a87d		c8		iny				iny
.a87e		b1 36		lda ($36),y			lda 	(zTemp0),y
.a880		d0 fb		bne $a87d			bne 	_SIFindLength
.a882		98		tya				tya
.a883		95 78		sta $78,x			sta 	NSExponent,x
.a885		7a		ply				ply
.a886		e8		inx				inx
.a887		20 e6 99	jsr $99e6			jsr 	CheckComma 					; comma next
.a88a		20 f2 a8	jsr $a8f2			jsr 	Evaluate8BitInteger 		; get next parameter
.a88d		28		plp				plp 								; is it the last parameter ?
.a88e		90 07		bcc $a897			bcc 	_SSIExit 					; if so, exit.
.a890		e8		inx				inx
.a891		20 e6 99	jsr $99e6			jsr 	CheckComma 					; comma next
.a894		20 f2 a8	jsr $a8f2			jsr 	Evaluate8BitInteger 		; get last parameter
.a897						_SSIExit:
.a897		fa		plx				plx
.a898		20 de 99	jsr $99de			jsr 	CheckRightBracket 			; check closing bracket
.a89b		60		rts				rts 								; exit

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/exprhelper.asm

.a89c						EvaluateValue:
.a89c		48		pha				pha
.a89d		20 01 9f	jsr $9f01			jsr		EvaluateExpression 			; expression
.a8a0		20 c4 a1	jsr $a1c4			jsr 	Dereference					; derefernce it
.a8a3		68		pla				pla
.a8a4		60		rts				rts
.a8a5						EvaluateNumber:
.a8a5		20 9c a8	jsr $a89c			jsr 	EvaluateValue 				; get a value
.a8a8		b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.a8aa		29 10		and #$10			and 	#NSBIsString
.a8ac		d0 13		bne $a8c1			bne 	HelperTypeError
.a8ae		60		rts				rts
.a8af						EvaluateString:
.a8af		20 9c a8	jsr $a89c			jsr 	EvaluateValue 				; get a value
.a8b2		b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.a8b4		29 10		and #$10			and 	#NSBIsString
.a8b6		f0 09		beq $a8c1			beq 	HelperTypeError
.a8b8						CopyAddressToTemp0:
.a8b8		b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address -> zTemp0
.a8ba		85 36		sta $36				sta 	zTemp0 						; (so we can do something with it)
.a8bc		b5 60		lda $60,x			lda 	NSMantissa1,x
.a8be		85 37		sta $37				sta 	zTemp0+1
.a8c0		60		rts				rts
.a8c1						HelperTypeError:
.a8c1		4c fd ab	jmp $abfd			jmp 	TypeError
.a8c4						EvaluateInteger:
.a8c4		20 a5 a8	jsr $a8a5			jsr 	EvaluateNumber
.a8c7		b5 78		lda $78,x			lda 	NSExponent,x 				; check exponent is zero
.a8c9		d0 09		bne $a8d4			bne 	HelperValueError 			; if not, it's a float.
.a8cb		60		rts				rts
.a8cc						EvaluateUnsignedInteger:
.a8cc		20 c4 a8	jsr $a8c4			jsr 	EvaluateInteger 			; check integer is +ve
.a8cf		b5 50		lda $50,x			lda 	NSStatus,x
.a8d1		30 01		bmi $a8d4			bmi 	HelperValueError
.a8d3		60		rts				rts
.a8d4						HelperValueError:
.a8d4		4c 02 ac	jmp $ac02			jmp 	ArgumentError
.a8d7						Evaluate16BitInteger:
.a8d7		20 cc a8	jsr $a8cc			jsr	 	EvaluateUnsignedInteger		; get integer
.a8da		b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.a8dc		15 68		ora $68,x			ora 	NSMantissa2,x
.a8de		d0 f4		bne $a8d4			bne 	HelperValueError
.a8e0		60		rts				rts
.a8e1						Evaluate16BitIntegerSigned:
.a8e1		20 c4 a8	jsr $a8c4			jsr	 	EvaluateInteger				; get integer
.a8e4		b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.a8e6		15 68		ora $68,x			ora 	NSMantissa2,x
.a8e8		d0 ea		bne $a8d4			bne 	HelperValueError
.a8ea		b5 50		lda $50,x			lda 	NSStatus,x 					; signed ?
.a8ec		10 03		bpl $a8f1			bpl 	_EISNotSigned
.a8ee		20 20 a9	jsr $a920			jsr 	NSMNegateMantissa 			; makes it an actual 2's complement value.
.a8f1						_EISNotSigned:
.a8f1		60		rts				rts
.a8f2						Evaluate8BitInteger:
.a8f2		20 cc a8	jsr $a8cc			jsr	 	EvaluateUnsignedInteger 	; get an integer
.a8f5		d0 dd		bne $a8d4			bne 	HelperValueError
.a8f7		b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 1, 2 & 3 must be zero
.a8f9		15 68		ora $68,x			ora 	NSMantissa2,x
.a8fb		15 60		ora $60,x			ora 	NSMantissa1,x
.a8fd		d0 d5		bne $a8d4			bne 	HelperValueError
.a8ff		b5 58		lda $58,x			lda 	NSMantissa0,x
.a901		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/mult8x8.asm

.a902						Multiply8x8:
.a902		4a		lsr a		  		lsr 	a  							; prime the carry bit for the loop
.a903		85 36		sta $36			  	sta 	zTemp0
.a905		86 37		stx $37				stx 	zTemp0+1
.a907		a9 00		lda #$00			lda 	#0
.a909		a2 08		ldx #$08			ldx 	#8
.a90b						_M88Loop:
.a90b		90 03		bcc $a910			bcc 	_M88NoAdd
.a90d		18		clc				clc
.a90e		65 37		adc $37				adc 	zTemp0+1
.a910						_M88NoAdd:
.a910		6a		ror a				ror 	a
.a911		66 36		ror $36				ror 	zTemp0  					; pull another bit out for the next iteration
.a913		ca		dex				dex         						; inc/dec don't modify carry; only shifts and adds do
.a914		d0 f5		bne $a90b			bne 	_M88Loop
.a916		85 37		sta $37				sta 	zTemp0+1 					; store high 8 bits.
.a918		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/utility.asm

.a919						NSMNegate:
.a919		b5 50		lda $50,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.a91b		49 80		eor #$80			eor 	#NSBIsNegative  			; toggle the negative flag
.a91d		95 50		sta $50,x			sta 	NSStatus,x
.a91f		60		rts				rts
.a920						NSMNegateMantissa:
.a920		38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.a921		a9 00		lda #$00			lda 	#0
.a923		f5 58		sbc $58,x			sbc 	NSMantissa0,x
.a925		95 58		sta $58,x			sta 	NSMantissa0,x
.a927		a9 00		lda #$00			lda 	#0
.a929		f5 60		sbc $60,x			sbc 	NSMantissa1,x
.a92b		95 60		sta $60,x			sta 	NSMantissa1,x
.a92d		a9 00		lda #$00			lda 	#0
.a92f		f5 68		sbc $68,x			sbc 	NSMantissa2,x
.a931		95 68		sta $68,x			sta 	NSMantissa2,x
.a933		a9 00		lda #$00			lda 	#0
.a935		f5 70		sbc $70,x			sbc 	NSMantissa3,x
.a937		95 70		sta $70,x			sta 	NSMantissa3,x
.a939		60		rts				rts
.a93a						NSMShiftUpTwo:
.a93a		b5 58		lda $58,x			lda 	NSMantissa0,x
.a93c		95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.a93e		b5 60		lda $60,x			lda 	NSMantissa1,x
.a940		95 62		sta $62,x			sta 	NSMantissa1+2,x
.a942		b5 68		lda $68,x			lda 	NSMantissa2,x
.a944		95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.a946		b5 70		lda $70,x			lda 	NSMantissa3,x
.a948		95 72		sta $72,x			sta 	NSMantissa3+2,x
.a94a		b5 78		lda $78,x			lda 	NSExponent,x
.a94c		95 7a		sta $7a,x			sta 	NSExponent+2,x
.a94e		b5 50		lda $50,x			lda 	NSStatus,x
.a950		95 52		sta $52,x			sta 	NSStatus+2,x
.a952		60		rts				rts
.a953						NSMSetZeroMantissaOnly:
.a953		a9 00		lda #$00			lda 	#0
.a955		80 06		bra $a95d			bra 	NSMSetMantissa
.a957						NSMSetZero:
.a957		a9 00		lda #$00			lda 	#0
.a959						NSMSetByte:
.a959		74 78		stz $78,x			stz 	NSExponent,x 				; zero exponent, as integer.
.a95b		74 50		stz $50,x			stz 	NSStatus,x 					; status zero (integer)
.a95d						NSMSetMantissa:
.a95d		95 58		sta $58,x			sta 	NSMantissa0,x 				; mantissa
.a95f		74 60		stz $60,x			stz 	NSMantissa1,x
.a961		74 68		stz $68,x			stz 	NSMantissa2,x
.a963		74 70		stz $70,x			stz 	NSMantissa3,x
.a965		60		rts				rts
.a966						NSMShiftLeft:
.a966		18		clc				clc
.a967						NSMRotateLeft:
.a967		36 58		rol $58,x			rol 	NSMantissa0,x
.a969		36 60		rol $60,x			rol		NSMantissa1,x
.a96b		36 68		rol $68,x			rol		NSMantissa2,x
.a96d		36 70		rol $70,x			rol		NSMantissa3,x
.a96f		60		rts				rts
.a970						NSMShiftRight:
.a970		56 70		lsr $70,x			lsr 	NSMantissa3,x
.a972		76 68		ror $68,x			ror		NSMantissa2,x
.a974		76 60		ror $60,x			ror		NSMantissa1,x
.a976		76 58		ror $58,x			ror		NSMantissa0,x
.a978		60		rts				rts
.a979						NSMIsZero:
.a979		b5 70		lda $70,x			lda 	NSMantissa3,x
.a97b		15 68		ora $68,x			ora		NSMantissa2,x
.a97d		15 60		ora $60,x			ora		NSMantissa1,x
.a97f		15 58		ora $58,x			ora		NSMantissa0,x
.a981		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/functions/getdatetime.asm

.a982						UnaryGetTime:
.a982		a9 00		lda #$00			lda 	#0
.a984		80 02		bra $a988			bra 	UGDTMain
.a986						UnaryGetDate:
.a986		a9 03		lda #$03			lda 	#3
.a988						UGDTMain:
.a988		fa		plx				plx 								; get stack position back
.a989		48		pha				pha 								; save table offset
.a98a		20 f2 a8	jsr $a8f2			jsr 	Evaluate8BitInteger			; ignored parameter
.a98d		20 de 99	jsr $99de			jsr 	CheckRightBracket 			; closing )
.a990		68		pla				pla 								; table offset in A
.a991		5a		phy				phy 								; saving Y
.a992		a8		tay				tay 								; table offset in Y
.a993		a9 08		lda #$08			lda 	#8							; allocate space for 8 chars DD:MM:YY
.a995		20 5d b3	jsr $b35d			jsr 	StringTempAllocate
.a998		a5 01		lda $01				lda 	1 							; save I/O table and switch to I/O page 0
.a99a		48		pha				pha
.a99b		64 01		stz $01				stz 	1
.a99d		20 b0 a9	jsr $a9b0			jsr 	UGDTDigit 					; do XX:YY:ZZ
.a9a0		20 ab a9	jsr $a9ab			jsr 	UGDTColonDigit
.a9a3		20 ab a9	jsr $a9ab			jsr 	UGDTColonDigit
.a9a6		68		pla				pla 								; restore I/O select
.a9a7		85 01		sta $01				sta 	1
.a9a9		7a		ply				ply  								; restore code position
.a9aa		60		rts				rts
.a9ab						UGDTColonDigit:
.a9ab		a9 3a		lda #$3a			lda 	#':'
.a9ad		20 96 b3	jsr $b396			jsr 	StringTempWrite
.a9b0						UGDTDigit:
.a9b0		da		phx				phx 								; save X
.a9b1		b9 d0 a9	lda $a9d0,y			lda 	RTCROffset,y 				; get offset in RTC register
.a9b4		aa		tax				tax
.a9b5		bd 90 d6	lda $d690,x			lda 	$D690,x 					; read RTC register
.a9b8		39 d6 a9	and $a9d6,y			and 	RTCRMask,y 					; and with Mask.
.a9bb		fa		plx				plx
.a9bc		48		pha				pha 								; output in BCD
.a9bd		4a		lsr a				lsr 	a
.a9be		4a		lsr a				lsr 	a
.a9bf		4a		lsr a				lsr 	a
.a9c0		4a		lsr a				lsr 	a
.a9c1		09 30		ora #$30			ora 	#48
.a9c3		20 96 b3	jsr $b396			jsr 	StringTempWrite
.a9c6		68		pla				pla
.a9c7		29 0f		and #$0f			and 	#15
.a9c9		09 30		ora #$30			ora 	#48
.a9cb		20 96 b3	jsr $b396			jsr 	StringTempWrite
.a9ce		c8		iny				iny
.a9cf		60		rts				rts
.a9d0						RTCROffset:
>a9d0		04 02 00 06 09 0a				.byte 	4,2,0,6,9,10
.a9d6						RTCRMask:
>a9d6		3f 7f 7f 3f 1f 7f				.byte 	$3F,$7F,$7F,$3F,$1F,$7F

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/functions/getinkey.asm

.a9dc						AscGet:
.a9dc		fa		plx				plx 								; restore stack pos
.a9dd						AscGet2:
.a9dd		20 de 99	jsr $99de			jsr 	CheckRightBracket
.a9e0		20 9e 81	jsr $819e			jsr 	KNLGetSingleCharacter
.a9e3		20 59 a9	jsr $a959			jsr 	NSMSetByte
.a9e6		60		rts				rts
.a9e7						_AGBreak:
.a9e7		a9 01		lda #$01		lda	#1
.a9e9		4c f7 99	jmp $99f7		jmp	ErrorHandler
.a9ec						AscInkey:
.a9ec		fa		plx				plx 								; restore stack pos
.a9ed						AscInkey2:
.a9ed		20 de 99	jsr $99de			jsr 	CheckRightBracket
.a9f0		20 7c 81	jsr $817c			jsr 	KNLGetKeyPressed
.a9f3		20 59 a9	jsr $a959			jsr 	NSMSetByte
.a9f6		60		rts				rts
.a9f7						ChrGet:
.a9f7		fa		plx				plx
.a9f8		20 dd a9	jsr $a9dd			jsr 	AscGet2
.a9fb		4c 02 aa	jmp $aa02			jmp 	GetInkeyToString
.a9fe						ChrInkey:
.a9fe		fa		plx				plx
.a9ff		20 ed a9	jsr $a9ed			jsr 	AscInkey2
.aa02						GetInkeyToString:
.aa02		c9 00		cmp #$00			cmp 	#0 							; if zero, return ""
.aa04		f0 0b		beq $aa11			beq 	_GKISNull
.aa06		48		pha				pha
.aa07		a9 01		lda #$01			lda 	#1 							; allocate space for one char
.aa09		20 5d b3	jsr $b35d			jsr 	StringTempAllocate
.aa0c		68		pla				pla 								; write number to it
.aa0d		20 96 b3	jsr $b396			jsr 	StringTempWrite
.aa10		60		rts				rts
.aa11						_GKISNull:
.aa11		a9 00		lda #$00			lda 	#0
.aa13		20 5d b3	jsr $b35d			jsr 	StringTempAllocate
.aa16		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/functions/keydown.asm

.aa17						KeyDown:
.aa17		20 2d 81	jsr $812d			jsr 	ProcessEvents 				; process outstanding events.
.aa1a		fa		plx				plx 								; restore stack pos
.aa1b		20 f2 a8	jsr $a8f2			jsr 	Evaluate8BitInteger 		; key to check.
.aa1e		48		pha				pha 								; check right bracket.
.aa1f		20 de 99	jsr $99de			jsr 	CheckRightBracket
.aa22		68		pla				pla
.aa23		20 8a 83	jsr $838a			jsr 	KeyboardConvertXA 			; get offset and mask.
.aa26		3d 60 06	and $0660,x			and 	KeyStatus,x 				; is it zero ?
.aa29		f0 03		beq $aa2e			beq 	_KeyUp
.aa2b		4c 6a 9a	jmp $9a6a			jmp 	ReturnTrue
.aa2e		4c 75 9a	jmp $9a75	_KeyUp:	jmp 	ReturnFalse

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/functions/rnd.asm

.aa31						Unary_Random:
.aa31		fa		plx				plx
.aa32		20 82 aa	jsr $aa82			jsr 	URCopyToMantissa  			; put random # in mantissa
.aa35		b1 30		lda ($30),y			lda 	(codePtr),y
.aa37		c9 29		cmp #$29			cmp 	#KWD_RPAREN
.aa39		f0 08		beq $aa43			beq 	_URNoModulus 				; then we return a random 30 bit number.
.aa3b		e8		inx				inx
.aa3c		20 d7 a8	jsr $a8d7			jsr 	Evaluate16BitInteger 		; put modulus value in +1
.aa3f		ca		dex				dex
.aa40		20 bc 9b	jsr $9bbc			jsr 	IntegerModulusNoCheck 		; calculate modulus, so now 0 .. n-1
.aa43						_URNoModulus:
.aa43		74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer positive
.aa45		74 78		stz $78,x			stz 	NSExponent,x
.aa47		20 de 99	jsr $99de			jsr 	CheckRightBracket
.aa4a		60		rts				rts
.aa4b						Unary_Rnd:
.aa4b		fa		plx				plx
.aa4c		20 a5 a8	jsr $a8a5			jsr 	EvaluateNumber 				; number to use.
.aa4f		20 de 99	jsr $99de			jsr 	CheckRightBracket 			; closing bracket
.aa52		b5 50		lda $50,x			lda 	NSStatus,x 					; if -ve, then seed using parameter
.aa54		10 20		bpl $aa76			bpl 	_URDontSeed
.aa56		a5 01		lda $01				lda 	1 							; switch to page 0
.aa58		48		pha				pha
.aa59		64 01		stz $01				stz 	1
.aa5b		b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy - value to seed butchering it.
.aa5d		49 17		eor #$17			eor 	#$17
.aa5f		8d a4 d6	sta $d6a4			sta 	$D6A4
.aa62		b5 60		lda $60,x			lda 	NSMantissa1,x
.aa64		49 a5		eor #$a5			eor 	#$A5
.aa66		8d a5 d6	sta $d6a5			sta 	$D6A5
.aa69		a9 03		lda #$03			lda 	#3 							; set bit 1 high/low to set seed.
.aa6b		8d a6 d6	sta $d6a6			sta 	$D6A6
.aa6e		a9 01		lda #$01			lda 	#1
.aa70		8d a6 d6	sta $d6a6			sta 	$D6A6
.aa73		68		pla				pla
.aa74		85 01		sta $01				sta 	1
.aa76						_URDontSeed:
.aa76		20 82 aa	jsr $aa82			jsr 	URCopyToMantissa 			; copy into mantissa
.aa79		a9 e2		lda #$e2			lda 	#-30 						; force into 0-1 range
.aa7b		95 78		sta $78,x			sta 	NSExponent,x
.aa7d		a9 08		lda #$08			lda 	#NSTFloat
.aa7f		95 50		sta $50,x			sta 	NSStatus,x 					; positive float
.aa81		60		rts				rts
.aa82						URCopyToMantissa:
.aa82		a5 01		lda $01				lda 	1 							; switch to I/O page 1
.aa84		48		pha				pha
.aa85		64 01		stz $01				stz 	1
.aa87		a9 01		lda #$01			lda 	#1
.aa89		8d a6 d6	sta $d6a6			sta 	$D6A6 						; enable LFSR
.aa8c		ad a4 d6	lda $d6a4			lda 	$D6A4
.aa8f		95 58		sta $58,x			sta 	NSMantissa0,x
.aa91		ad a5 d6	lda $d6a5			lda 	$D6A5
.aa94		95 60		sta $60,x			sta 	NSMantissa1,x
.aa96		ad a4 d6	lda $d6a4			lda 	$D6A4
.aa99		95 68		sta $68,x			sta 	NSMantissa2,x
.aa9b		ad a5 d6	lda $d6a5			lda 	$D6A5
.aa9e		29 3f		and #$3f			and 	#$3F 						; make legal mantissa
.aaa0		95 70		sta $70,x			sta 	NSMantissa3,x
.aaa2		68		pla				pla
.aaa3		85 01		sta $01				sta 	1
.aaa5		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/asmcore.asm

.aaa6						Assemble_ora:
.aaa6		20 88 84	jsr $8488		jsr	AssembleGroup1
>aaa9		01					.byte $01
.aaaa						Assemble_and:
.aaaa		20 88 84	jsr $8488		jsr	AssembleGroup1
>aaad		21					.byte $21
.aaae						Assemble_eor:
.aaae		20 88 84	jsr $8488		jsr	AssembleGroup1
>aab1		41					.byte $41
.aab2						Assemble_adc:
.aab2		20 88 84	jsr $8488		jsr	AssembleGroup1
>aab5		61					.byte $61
.aab6						Assemble_sta:
.aab6		20 88 84	jsr $8488		jsr	AssembleGroup1
>aab9		81					.byte $81
.aaba						Assemble_lda:
.aaba		20 88 84	jsr $8488		jsr	AssembleGroup1
>aabd		a1					.byte $a1
.aabe						Assemble_cmp:
.aabe		20 88 84	jsr $8488		jsr	AssembleGroup1
>aac1		c1					.byte $c1
.aac2						Assemble_sbc:
.aac2		20 88 84	jsr $8488		jsr	AssembleGroup1
>aac5		e1					.byte $e1
.aac6						Assemble_asl:
.aac6		20 8f 84	jsr $848f		jsr	AssembleGroup2
>aac9		02					.byte $02
>aaca		75					.byte $75
.aacb						Assemble_rol:
.aacb		20 8f 84	jsr $848f		jsr	AssembleGroup2
>aace		22					.byte $22
>aacf		75					.byte $75
.aad0						Assemble_lsr:
.aad0		20 8f 84	jsr $848f		jsr	AssembleGroup2
>aad3		42					.byte $42
>aad4		75					.byte $75
.aad5						Assemble_ror:
.aad5		20 8f 84	jsr $848f		jsr	AssembleGroup2
>aad8		62					.byte $62
>aad9		75					.byte $75
.aada						Assemble_stx:
.aada		20 8f 84	jsr $848f		jsr	AssembleGroup2
>aadd		82					.byte $82
>aade		50					.byte $50
.aadf						Assemble_ldx:
.aadf		20 8f 84	jsr $848f		jsr	AssembleGroup2
>aae2		a2					.byte $a2
>aae3		d0					.byte $d0
.aae4						Assemble_dec:
.aae4		20 8f 84	jsr $848f		jsr	AssembleGroup2
>aae7		c2					.byte $c2
>aae8		55					.byte $55
.aae9						Assemble_inc:
.aae9		20 8f 84	jsr $848f		jsr	AssembleGroup2
>aaec		e2					.byte $e2
>aaed		55					.byte $55
.aaee						Assemble_stz:
.aaee		20 8f 84	jsr $848f		jsr	AssembleGroup2
>aaf1		60					.byte $60
>aaf2		44					.byte $44
.aaf3						Assemble_bit:
.aaf3		20 8f 84	jsr $848f		jsr	AssembleGroup2
>aaf6		20					.byte $20
>aaf7		55					.byte $55
.aaf8						Assemble_sty:
.aaf8		20 8f 84	jsr $848f		jsr	AssembleGroup2
>aafb		80					.byte $80
>aafc		54					.byte $54
.aafd						Assemble_ldy:
.aafd		20 8f 84	jsr $848f		jsr	AssembleGroup2
>ab00		a0					.byte $a0
>ab01		d5					.byte $d5
.ab02						Assemble_cpy:
.ab02		20 8f 84	jsr $848f		jsr	AssembleGroup2
>ab05		c0					.byte $c0
>ab06		d4					.byte $d4
.ab07						Assemble_cpx:
.ab07		20 8f 84	jsr $848f		jsr	AssembleGroup2
>ab0a		e0					.byte $e0
>ab0b		d0					.byte $d0
.ab0c						Assemble_tsb:
.ab0c		20 8f 84	jsr $848f		jsr	AssembleGroup2
>ab0f		00					.byte $00
>ab10		50					.byte $50
.ab11						Assemble_trb:
.ab11		20 8f 84	jsr $848f		jsr	AssembleGroup2
>ab14		10					.byte $10
>ab15		50					.byte $50
.ab16						Assemble_jsr:
.ab16		20 8f 84	jsr $848f		jsr	AssembleGroup2
>ab19		14					.byte $14
>ab1a		10					.byte $10
.ab1b						Assemble_jmp:
.ab1b		20 8f 84	jsr $848f		jsr	AssembleGroup2
>ab1e		40					.byte $40
>ab1f		10					.byte $10
.ab20						Assemble_bpl:
.ab20		20 e0 84	jsr $84e0		jsr	AssembleGroup3
>ab23		10					.byte $10
.ab24						Assemble_bmi:
.ab24		20 e0 84	jsr $84e0		jsr	AssembleGroup3
>ab27		30					.byte $30
.ab28						Assemble_bvc:
.ab28		20 e0 84	jsr $84e0		jsr	AssembleGroup3
>ab2b		50					.byte $50
.ab2c						Assemble_bvs:
.ab2c		20 e0 84	jsr $84e0		jsr	AssembleGroup3
>ab2f		70					.byte $70
.ab30						Assemble_bcc:
.ab30		20 e0 84	jsr $84e0		jsr	AssembleGroup3
>ab33		90					.byte $90
.ab34						Assemble_bcs:
.ab34		20 e0 84	jsr $84e0		jsr	AssembleGroup3
>ab37		b0					.byte $b0
.ab38						Assemble_bne:
.ab38		20 e0 84	jsr $84e0		jsr	AssembleGroup3
>ab3b		d0					.byte $d0
.ab3c						Assemble_beq:
.ab3c		20 e0 84	jsr $84e0		jsr	AssembleGroup3
>ab3f		f0					.byte $f0
.ab40						Assemble_bra:
.ab40		20 e0 84	jsr $84e0		jsr	AssembleGroup3
>ab43		80					.byte $80
.ab44						Assemble_brk:
.ab44		20 14 85	jsr $8514		jsr	AssembleGroup4
>ab47		00					.byte $00
.ab48						Assemble_php:
.ab48		20 14 85	jsr $8514		jsr	AssembleGroup4
>ab4b		08					.byte $08
.ab4c						Assemble_clc:
.ab4c		20 14 85	jsr $8514		jsr	AssembleGroup4
>ab4f		18					.byte $18
.ab50						Assemble_plp:
.ab50		20 14 85	jsr $8514		jsr	AssembleGroup4
>ab53		28					.byte $28
.ab54						Assemble_sec:
.ab54		20 14 85	jsr $8514		jsr	AssembleGroup4
>ab57		38					.byte $38
.ab58						Assemble_rti:
.ab58		20 14 85	jsr $8514		jsr	AssembleGroup4
>ab5b		40					.byte $40
.ab5c						Assemble_pha:
.ab5c		20 14 85	jsr $8514		jsr	AssembleGroup4
>ab5f		48					.byte $48
.ab60						Assemble_cli:
.ab60		20 14 85	jsr $8514		jsr	AssembleGroup4
>ab63		58					.byte $58
.ab64						Assemble_phy:
.ab64		20 14 85	jsr $8514		jsr	AssembleGroup4
>ab67		5a					.byte $5a
.ab68						Assemble_rts:
.ab68		20 14 85	jsr $8514		jsr	AssembleGroup4
>ab6b		60					.byte $60
.ab6c						Assemble_pla:
.ab6c		20 14 85	jsr $8514		jsr	AssembleGroup4
>ab6f		68					.byte $68
.ab70						Assemble_sei:
.ab70		20 14 85	jsr $8514		jsr	AssembleGroup4
>ab73		78					.byte $78
.ab74						Assemble_ply:
.ab74		20 14 85	jsr $8514		jsr	AssembleGroup4
>ab77		7a					.byte $7a
.ab78						Assemble_dey:
.ab78		20 14 85	jsr $8514		jsr	AssembleGroup4
>ab7b		88					.byte $88
.ab7c						Assemble_txa:
.ab7c		20 14 85	jsr $8514		jsr	AssembleGroup4
>ab7f		8a					.byte $8a
.ab80						Assemble_tya:
.ab80		20 14 85	jsr $8514		jsr	AssembleGroup4
>ab83		98					.byte $98
.ab84						Assemble_txs:
.ab84		20 14 85	jsr $8514		jsr	AssembleGroup4
>ab87		9a					.byte $9a
.ab88						Assemble_tay:
.ab88		20 14 85	jsr $8514		jsr	AssembleGroup4
>ab8b		a8					.byte $a8
.ab8c						Assemble_tax:
.ab8c		20 14 85	jsr $8514		jsr	AssembleGroup4
>ab8f		aa					.byte $aa
.ab90						Assemble_clv:
.ab90		20 14 85	jsr $8514		jsr	AssembleGroup4
>ab93		b8					.byte $b8
.ab94						Assemble_tsx:
.ab94		20 14 85	jsr $8514		jsr	AssembleGroup4
>ab97		ba					.byte $ba
.ab98						Assemble_iny:
.ab98		20 14 85	jsr $8514		jsr	AssembleGroup4
>ab9b		c8					.byte $c8
.ab9c						Assemble_dex:
.ab9c		20 14 85	jsr $8514		jsr	AssembleGroup4
>ab9f		ca					.byte $ca
.aba0						Assemble_cld:
.aba0		20 14 85	jsr $8514		jsr	AssembleGroup4
>aba3		d8					.byte $d8
.aba4						Assemble_phx:
.aba4		20 14 85	jsr $8514		jsr	AssembleGroup4
>aba7		da					.byte $da
.aba8						Assemble_stp:
.aba8		20 14 85	jsr $8514		jsr	AssembleGroup4
>abab		db					.byte $db
.abac						Assemble_inx:
.abac		20 14 85	jsr $8514		jsr	AssembleGroup4
>abaf		e8					.byte $e8
.abb0						Assemble_nop:
.abb0		20 14 85	jsr $8514		jsr	AssembleGroup4
>abb3		ea					.byte $ea
.abb4						Assemble_sed:
.abb4		20 14 85	jsr $8514		jsr	AssembleGroup4
>abb7		f8					.byte $f8
.abb8						Assemble_plx:
.abb8		20 14 85	jsr $8514		jsr	AssembleGroup4
>abbb		fa					.byte $fa

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/constants.asm

.abbc						DecimalScalarTable:
>abbc		66 66 66 66				.dword $66666666 ; 0.1
>abc0		de					.byte $de
>abc1		1f 85 eb 51				.dword $51eb851f ; 0.01
>abc5		db					.byte $db
>abc6		4c 37 89 41				.dword $4189374c ; 0.001
>abca		d8					.byte $d8
>abcb		ac 8b db 68				.dword $68db8bac ; 0.0001
>abcf		d4					.byte $d4
>abd0		24 d6 e2 53				.dword $53e2d624 ; 1e-05
>abd4		d1					.byte $d1
>abd5		83 de 1b 43				.dword $431bde83 ; 1e-06
>abd9		ce					.byte $ce
>abda		6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>abde		ca					.byte $ca
>abdf		89 3b e6 55				.dword $55e63b89 ; 1e-08
>abe3		c7					.byte $c7
>abe4		a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>abe8		c4					.byte $c4
>abe9		67 7f f3 6d				.dword $6df37f67 ; 1e-10
>abed		c0					.byte $c0
>abee		86 ff f5 57				.dword $57f5ff86 ; 1e-11
>abf2		bd					.byte $bd

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.asm

.abf3						SyntaxError:
.abf3		a9 02		lda #$02		lda	#2
.abf5		4c f7 99	jmp $99f7		jmp	ErrorHandler
.abf8						RangeError:
.abf8		a9 04		lda #$04		lda	#4
.abfa		4c f7 99	jmp $99f7		jmp	ErrorHandler
.abfd						TypeError:
.abfd		a9 05		lda #$05		lda	#5
.abff		4c f7 99	jmp $99f7		jmp	ErrorHandler
.ac02						ArgumentError:
.ac02		a9 07		lda #$07		lda	#7
.ac04		4c f7 99	jmp $99f7		jmp	ErrorHandler
.ac07						NotDoneError:
.ac07		a9 0c		lda #$0c		lda	#12
.ac09		4c f7 99	jmp $99f7		jmp	ErrorHandler
.ac0c						ErrorText:
>ac0c		42 72 65 61 6b 00			.text	"Break",0
>ac12		53 79 6e 74 61 78 20 65			.text	"Syntax error",0
>ac1a		72 72 6f 72 00
>ac1f		44 69 76 69 73 69 6f 6e			.text	"Division by zero",0
>ac27		20 62 79 20 7a 65 72 6f 00
>ac30		4f 75 74 20 6f 66 20 52			.text	"Out of Range",0
>ac38		61 6e 67 65 00
>ac3d		54 79 70 65 20 6d 69 73			.text	"Type mismatch",0
>ac45		6d 61 74 63 68 00
>ac4b		4f 75 74 20 6f 66 20 6d			.text	"Out of memory",0
>ac53		65 6d 6f 72 79 00
>ac59		49 6c 6c 65 67 61 6c 20			.text	"Illegal argument",0
>ac61		61 72 67 75 6d 65 6e 74 00
>ac6a		53 74 6f 70 00				.text	"Stop",0
>ac6f		53 74 72 69 6e 67 20 74			.text	"String too long",0
>ac77		6f 6f 20 6c 6f 6e 67 00
>ac7f		41 73 73 65 72 74 69 6f			.text	"Assertion failed",0
>ac87		6e 20 66 61 69 6c 65 64 00
>ac90		4f 75 74 20 6f 66 20 64			.text	"Out of data",0
>ac98		61 74 61 00
>ac9c		55 6e 69 6d 70 6c 65 6d			.text	"Unimplemented",0
>aca4		65 6e 74 65 64 00
>acaa		4e 6f 20 73 75 63 68 20			.text	"No such line number",0
>acb2		6c 69 6e 65 20 6e 75 6d 62 65 72 00
>acbe		52 65 74 75 72 6e 20 77			.text	"Return without Gosub",0
>acc6		69 74 68 6f 75 74 20 47 6f 73 75 62 00
>acd3		55 6e 74 69 6c 20 77 69			.text	"Until without Repeat",0
>acdb		74 68 6f 75 74 20 52 65 70 65 61 74 00
>ace8		57 65 6e 64 20 77 69 74			.text	"Wend without While",0
>acf0		68 6f 75 74 20 57 68 69 6c 65 00
>acfb		4e 65 78 74 20 77 69 74			.text	"Next without For",0
>ad03		68 6f 75 74 20 46 6f 72 00
>ad0c		42 41 53 49 43 20 53 74			.text	"BASIC Stack full",0
>ad14		61 63 6b 20 66 75 6c 6c 00
>ad1d		4f 70 65 6e 20 53 74 72			.text	"Open Structure",0
>ad25		75 63 74 75 72 65 00
>ad2c		45 6e 64 50 72 6f 63 20			.text	"EndProc without call",0
>ad34		77 69 74 68 6f 75 74 20 63 61 6c 6c 00
>ad41		41 72 72 61 79 20 61 6c			.text	"Array already defined",0
>ad49		72 65 61 64 79 20 64 65 66 69 6e 65 64 00
>ad57		41 72 72 61 79 20 73 69			.text	"Array size",0
>ad5f		7a 65 00
>ad62		42 61 64 20 61 72 72 61			.text	"Bad array index",0
>ad6a		79 20 69 6e 64 65 78 00
>ad72		41 72 72 61 79 20 6e 6f			.text	"Array not declared",0
>ad7a		74 20 64 65 63 6c 61 72 65 64 00
>ad85		46 69 6c 65 20 6e 6f 74			.text	"File not found",0
>ad8d		20 66 6f 75 6e 64 00
>ad94		53 74 6f 72 61 67 65 20			.text	"Storage error",0
>ad9c		65 72 72 6f 72 00
>ada2		56 65 72 69 66 79 20 66			.text	"Verify failed",0
>adaa		61 69 6c 65 64 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/timestamp.asm

>e7fa		09 09 30 38 2f 30 32 2f			.text 9,9,"08/02/23 33"
>e802		32 33 20 33 33

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/memory/memory.flat/delete.asm

.adb0						MemoryDeleteLine:
.adb0		20 cf ad	jsr $adcf			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.adb3		b2 30		lda ($30)			lda 	(codePtr) 					; size to delete => y
.adb5		a8		tay				tay
.adb6						_MDDLLoop:
.adb6		b1 30		lda ($30),y			lda 	(codePtr),y 				; copy down
.adb8		92 30		sta ($30)			sta 	(codePtr)
.adba		a5 30		lda $30				lda 	codePtr 					; check done the lot.
.adbc		c5 3a		cmp $3a				cmp 	zTemp2 						; has codePtr (copyFrom) reached the last byte to copy.
.adbe		d0 07		bne $adc7			bne 	_MDLDLNext
.adc0		a5 31		lda $31				lda 	codePtr+1
.adc2		c5 3b		cmp $3b				cmp 	zTemp2+1
.adc4		d0 01		bne $adc7			bne 	_MDLDLNext
.adc6						_MDDLExit:
.adc6		60		rts				rts
.adc7						_MDLDLNext:
.adc7		e6 30		inc $30				inc 	codePtr						; next byte
.adc9		d0 eb		bne $adb6			bne 	_MDDLLoop
.adcb		e6 31		inc $31				inc 	codePtr+1
.adcd		80 e7		bra $adb6			bra 	_MDDLLoop
.adcf						IMemoryFindEnd:
.adcf		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.add1		85 3a		sta $3a				sta 	0+zTemp2
.add3		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.add5		85 3b		sta $3b				sta 	1+zTemp2
.add7						_MDLFELoop:
.add7		b2 3a		lda ($3a)			lda 	(zTemp2) 					; scan forward using offsets.
.add9		f0 0b		beq $ade6			beq 	_MDLFEExit
.addb		18		clc				clc
.addc		65 3a		adc $3a				adc 	zTemp2
.adde		85 3a		sta $3a				sta 	zTemp2
.ade0		90 f5		bcc $add7			bcc 	_MDLFELoop
.ade2		e6 3b		inc $3b				inc 	zTemp2+1
.ade4		80 f1		bra $add7			bra 	_MDLFELoop
.ade6						_MDLFEExit:
.ade6		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/memory/memory.flat/insert.asm

.ade7						MemoryInsertLine:
.ade7		08		php				php
.ade8		20 cf ad	jsr $adcf			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.adeb		a5 3b		lda $3b				lda 	zTemp2+1 					; is there space for the new line ?
.aded		1a		inc a				inc 	a
.adee		c9 7f		cmp #$7f			cmp 	#(BasicEnd >> 8)-1
.adf0		b0 36		bcs $ae28			bcs 	_MDLIError 					; no, fail.
.adf2		28		plp				plp 								; do at a specific point or the end ?
.adf3		90 08		bcc $adfd			bcc 	_MDLIFound 					; if specific point already set.
.adf5		a5 3a		lda $3a				lda 	zTemp2 						; if CS on entry append, so put on the
.adf7		85 30		sta $30				sta 	codePtr 					; end.
.adf9		a5 3b		lda $3b				lda 	zTemp2+1
.adfb		85 31		sta $31				sta 	codePtr+1
.adfd						_MDLIFound:
.adfd		ad 26 04	lda $0426			lda 	tokenOffset 				; insert gap in Y, the offset, e.g. length of the new line
.ae00		a8		tay				tay
.ae01						_MDLIInsert:
.ae01		b2 3a		lda ($3a)			lda 	(zTemp2) 					; shift one byte up , at least one covers end case (copying link 0)
.ae03		91 3a		sta ($3a),y			sta 	(zTemp2),y 					; work from top down.
.ae05		a5 30		lda $30				lda 	codePtr 					; reached insert point ?
.ae07		c5 3a		cmp $3a				cmp 	zTemp2
.ae09		d0 06		bne $ae11			bne 	_MDLINext
.ae0b		a5 31		lda $31				lda 	codePtr+1
.ae0d		c5 3b		cmp $3b				cmp 	zTemp2+1
.ae0f		f0 0a		beq $ae1b			beq 	_MDLIHaveSpace
.ae11						_MDLINext:
.ae11		a5 3a		lda $3a				lda 	zTemp2 						; if no, keep zTemp2 going backwards opening up space.
.ae13		d0 02		bne $ae17			bne 	_MDLINoBorrow
.ae15		c6 3b		dec $3b				dec 	zTemp2+1
.ae17						_MDLINoBorrow:
.ae17		c6 3a		dec $3a				dec 	zTemp2
.ae19		80 e6		bra $ae01			bra 	_MDLIInsert
.ae1b						_MDLIHaveSpace:
.ae1b		ac 26 04	ldy $0426			ldy 	tokenOffset 				; bytes to copy
.ae1e		88		dey				dey 								; from offset-1 (last written) to the end of the buffer.
.ae1f						_MDLICopy:
.ae1f		b9 26 04	lda $0426,y			lda 	tokenOffset,y
.ae22		91 30		sta ($30),y			sta 	(codePtr),y
.ae24		88		dey				dey
.ae25		10 f8		bpl $ae1f			bpl 	_MDLICopy
.ae27		60		rts				rts
.ae28						_MDLIError:
.ae28		a9 06		lda #$06		lda	#6
.ae2a		4c f7 99	jmp $99f7		jmp	ErrorHandler
.ae2d						MDLAppendLine:
.ae2d		86 37		stx $37				stx 	zTemp0+1 					; save new line at zTemp0
.ae2f		85 36		sta $36				sta 	zTemp0
.ae31		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.ae33		85 38		sta $38				sta 	0+zTemp1
.ae35		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.ae37		85 39		sta $39				sta 	1+zTemp1
.ae39		b2 38		lda ($38)			lda 	(zTemp1)
.ae3b		d0 0a		bne $ae47			bne 	_MDLANoInitialise
.ae3d		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.ae3f		8d b1 07	sta $07b1			sta 	0+AppendPointer
.ae42		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.ae44		8d b2 07	sta $07b2			sta 	1+AppendPointer
.ae47						_MDLANoInitialise:
.ae47		18		clc				clc
.ae48		ad b1 07	lda $07b1			lda 	AppendPointer 				; copy append pointer to zTemp1 adding the offset as you go
.ae4b		85 38		sta $38				sta 	zTemp1
.ae4d		72 36		adc ($36)			adc 	(zTemp0)
.ae4f		8d b1 07	sta $07b1			sta 	AppendPointer
.ae52		ad b2 07	lda $07b2			lda 	AppendPointer+1
.ae55		85 39		sta $39				sta 	zTemp1+1
.ae57		69 00		adc #$00			adc 	#0
.ae59		8d b2 07	sta $07b2			sta 	AppendPointer+1
.ae5c		a0 00		ldy #$00			ldy 	#0
.ae5e						_MDLACopy:
.ae5e		b1 36		lda ($36),y			lda 	(zTemp0),y 					; copy new line in
.ae60		91 38		sta ($38),y			sta 	(zTemp1),y
.ae62		c8		iny				iny
.ae63		98		tya				tya
.ae64		d2 36		cmp ($36)			cmp 	(zTemp0) 					; done whole line
.ae66		d0 f6		bne $ae5e			bne 	_MDLACopy
.ae68		a9 00		lda #$00			lda 	#0 							; end of program.
.ae6a		91 38		sta ($38),y			sta 	(zTemp1),y
.ae6c		60		rts				rts
.07b1						AppendPointer:
>07b1								.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/memory/memory.flat/memory.asm

.ae6d						MemoryNew:
.ae6d		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.ae6f		85 30		sta $30				sta 	codePtr
.ae71		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.ae73		85 31		sta $31				sta 	codePtr+1
.ae75		a9 00		lda #$00			lda 	#0 							; write zero there erasing the program.
.ae77		92 30		sta ($30)			sta 	(codePtr)
.ae79		60		rts				rts
.ae7a						MemoryInline:
.ae7a		98		tya				tya 								; put address into stack,x
.ae7b		18		clc				clc  								; get the offset, add codePtr
.ae7c		65 30		adc $30				adc 	codePtr
.ae7e		95 58		sta $58,x			sta 	NSMantissa0,x 				; store the result in the mantissa.
.ae80		a5 31		lda $31				lda 	codePtr+1
.ae82		69 00		adc #$00			adc 	#0
.ae84		95 60		sta $60,x			sta 	NSMantissa1,x
.ae86		74 68		stz $68,x			stz 	NSMantissa2,x
.ae88		74 70		stz $70,x			stz 	NSMantissa3,x
.ae8a		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/memory/memory.flat/search.asm

.ae8b						MemorySearch:
.ae8b		85 36		sta $36				sta 	zTemp0 						; save line number in zTemp0
.ae8d		86 37		stx $37				stx 	zTemp0+1
.ae8f		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.ae91		85 30		sta $30				sta 	codePtr
.ae93		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.ae95		85 31		sta $31				sta 	codePtr+1
.ae97						_MTAXLoop:
.ae97		b2 30		lda ($30)			lda 	(codePtr)
.ae99		18		clc				clc
.ae9a		f0 21		beq $aebd			beq 	_MTAXExit 					; reached end, exit with CC.
.ae9c		a0 01		ldy #$01			ldy 	#1 							; calculate current line# - requested line#
.ae9e		b1 30		lda ($30),y			lda 	(codePtr),y
.aea0		38		sec				sec
.aea1		e5 36		sbc $36				sbc 	zTemp0
.aea3		85 38		sta $38				sta 	zTemp1 						; save interim to set Z
.aea5		c8		iny				iny 								; do the MSB
.aea6		b1 30		lda ($30),y			lda 	(codePtr),y
.aea8		e5 37		sbc $37				sbc 	zTemp0+1
.aeaa		05 38		ora $38				ora 	zTemp1 						; will set Z if result is zero, doesn't affect carry flag
.aeac		f0 0f		beq $aebd			beq 	_MTAXExit	 				; found so exit (CS will be set)
.aeae		b0 0d		bcs $aebd			bcs 	_MTAXExit 					; current < required exit
.aeb0		18		clc				clc
.aeb1		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.aeb3		65 30		adc $30				adc 	codePtr
.aeb5		85 30		sta $30				sta 	codePtr
.aeb7		90 02		bcc $aebb			bcc 	_CREExit
.aeb9		e6 31		inc $31				inc 	codePtr+1 					; carry
.aebb						_CREExit:
.aebb		80 da		bra $ae97			bra 	_MTAXLoop
.aebd						_MTAXExit:
.aebd		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/graphics/gcommand.asm

.aebe						RectangleCommand:
.aebe		a9 44		lda #$44			lda 	#GCMD_FrameRect				; frame rectangle
.aec0		80 02		bra $aec4			bra 	ShapeDrawCmd
.aec2						CircleCommand:
.aec2		a9 48		lda #$48			lda 	#GCMD_FrameCircle 				; framed circle
.aec4						ShapeDrawCmd:
.aec4		20 4e af	jsr $af4e			jsr 	RunGraphicsCommand
.aec7						ShapeDraw:
.aec7		0d b4 07	ora $07b4			ora 	gxFillSolid  				; adjust AXY for solid fill.
.aeca		4c 42 af	jmp $af42			jmp 	ExecuteGraphicCommand	 	; and complete
.aecd						SpriteCommand:
.aecd		a2 00		ldx #$00			ldx 	#0
.aecf		20 f2 a8	jsr $a8f2			jsr 	Evaluate8BitInteger 		; get image number.
.aed2		5a		phy				phy
.aed3		a9 0e		lda #$0e			lda 	#GCMD_SpriteUse 			; use that image.
.aed5		a6 58		ldx $58				ldx 	NSMantissa0
.aed7		e0 40		cpx #$40			cpx 	#64 						; 0-63 only
.aed9		b0 0d		bcs $aee8			bcs 	_SCRange
.aedb		a0 ff		ldy #$ff			ldy 	#255
.aedd		20 61 80	jsr $8061			jsr 	GXGraphicDraw
.aee0		a9 52		lda #$52			lda 	#GCMD_SpriteMove
.aee2		7a		ply				ply
.aee3		20 4e af	jsr $af4e			jsr 	RunGraphicsCommand
.aee6		80 5a		bra $af42			bra 	ExecuteGraphicCommand
.aee8						_SCRange:
.aee8		4c f8 ab	jmp $abf8			jmp 	RangeError
.aeeb						ImageCommand:
.aeeb		a2 00		ldx #$00			ldx 	#0
.aeed		20 f2 a8	jsr $a8f2			jsr 	Evaluate8BitInteger 		; get image number.
.aef0		20 4e af	jsr $af4e			jsr 	RunGraphicsCommand
.aef3						ImageRunDraw:
.aef3		09 40		ora #$40			ora 	#GCMD_Move					; move cursor
.aef5		20 61 80	jsr $8061			jsr 	GXGraphicDraw
.aef8		ad ba 07	lda $07ba			lda 	gxDrawScale
.aefb		0a		asl a				asl 	a
.aefc		0a		asl a				asl 	a
.aefd		0a		asl a				asl 	a
.aefe		a8		tay				tay
.aeff		a9 0c		lda #$0c			lda 	#GCMD_DrawSprite 			; image drawing
.af01		a6 58		ldx $58				ldx 	NSMantissa0
.af03		20 61 80	jsr $8061			jsr 	GXGraphicDraw
.af06		60		rts				rts
.af07						TextCommand:
.af07		a2 00		ldx #$00			ldx 	#0
.af09		20 af a8	jsr $a8af			jsr 	EvaluateString 				; get text
.af0c		20 4e af	jsr $af4e			jsr 	RunGraphicsCommand
.af0f						TextRunDraw:
.af0f		09 40		ora #$40			ora 	#GCMD_Move 					; move cursor
.af11		20 61 80	jsr $8061			jsr 	GXGraphicDraw
.af14		a0 00		ldy #$00			ldy 	#0
.af16						_IRDLoop:
.af16		a5 60		lda $60				lda 	NSMantissa1 				; access character
.af18		85 37		sta $37				sta 	zTemp0+1
.af1a		a5 58		lda $58				lda 	NSMantissa0
.af1c		85 36		sta $36				sta 	zTemp0
.af1e		b1 36		lda ($36),y			lda 	(zTemp0),y
.af20		f0 13		beq $af35			beq 	_IRDExit
.af22		5a		phy				phy									; save string pos
.af23		48		pha				pha 								; save char
.af24		ad ba 07	lda $07ba			lda 	gxDrawScale 				; get scale
.af27		0a		asl a				asl 	a
.af28		0a		asl a				asl 	a
.af29		0a		asl a				asl 	a
.af2a		a8		tay				tay
.af2b		a9 0a		lda #$0a			lda 	#GCMD_DrawFont 				; char drawing
.af2d		fa		plx				plx 								; char to draw
.af2e		20 61 80	jsr $8061			jsr 	GXGraphicDraw
.af31		7a		ply				ply 								; restore string pos
.af32		c8		iny				iny
.af33		90 e1		bcc $af16			bcc 	_IRDLoop 					; go back if no error.
.af35						_IRDExit:
.af35		60		rts				rts
.af36						PlotCommand:
.af36		a9 50		lda #$50			lda 	#GCMD_Plot 					; command ID to use
.af38		20 4e af	jsr $af4e			jsr 	RunGraphicsCommand
.af3b		80 05		bra $af42			bra 	ExecuteGraphicCommand
.af3d						LineCommand:
.af3d		a9 42		lda #$42			lda 	#GCMD_Line 						; command ID to use
.af3f		20 4e af	jsr $af4e			jsr 	RunGraphicsCommand
.af42						ExecuteGraphicCommand:
.af42		0d b3 07	ora $07b3			ora 	gxCommandID 				; make a full command
.af45		20 61 80	jsr $8061			jsr 	GXGraphicDraw 				; draw it and exit
.af48		b0 01		bcs $af4b			bcs 	_EGCError
.af4a		60		rts				rts
.af4b						_EGCError:
.af4b		4c f3 ab	jmp $abf3			jmp 	SyntaxError
.af4e						RunGraphicsCommand:
.af4e		8d b3 07	sta $07b3			sta 	gxCommandID					; save TODO graphics command.
.af51		68		pla				pla 								; pop handler address
.af52		fa		plx				plx
.af53		1a		inc a				inc 	a
.af54		d0 01		bne $af57			bne 	_RGINoCarry
.af56		e8		inx				inx
.af57						_RGINoCarry:
.af57		8d b8 07	sta $07b8			sta 	gxHandler
.af5a		8e b9 07	stx $07b9			stx 	gxHandler+1
.af5d						_RGICommandLoop:
.af5d		b1 30		lda ($30),y			lda 	(codePtr),y
.af5f		c8		iny				iny
.af60		c9 db		cmp #$db			cmp 	#KWD_TO						; is it TO x,y
.af62		f0 53		beq $afb7			beq 	_RGI_To
.af64		c9 c5		cmp #$c5			cmp 	#KWD_HERE 					; do it here.
.af66		f0 55		beq $afbd			beq 	_RGI_Here
.af68		c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL or : , exit
.af6a		f0 3d		beq $afa9			beq 	_RGI_Exit
.af6c		c9 3a		cmp #$3a			cmp 	#KWD_COLON
.af6e		f0 39		beq $afa9			beq 	_RGI_Exit
.af70		c9 cd		cmp #$cd			cmp 	#KWD_OUTLINE 				; solid or outline
.af72		f0 3e		beq $afb2			beq 	_RGI_Frame
.af74		c9 d7		cmp #$d7			cmp 	#KWD_SOLID
.af76		f0 33		beq $afab			beq 	_RGI_Solid
.af78		c9 b9		cmp #$b9			cmp 	#KWD_BY 					; by offset
.af7a		f0 4b		beq $afc7			beq 	_RGI_By
.af7c		c9 c3		cmp #$c3			cmp 	#KWD_FROM 					; from
.af7e		f0 17		beq $af97			beq 	_RGI_Move2
.af80		c9 c0		cmp #$c0			cmp 	#KWD_DIM 					; dim (set scale)
.af82		f0 62		beq $afe6			beq 	_RGI_Dim
.af84		c9 be		cmp #$be			cmp 	#KWD_COLOUR 				; colour or Color
.af86		f0 74		beq $affc			beq 	_RGI_Colour
.af88		c9 bd		cmp #$bd			cmp 	#KWD_COLOR
.af8a		f0 70		beq $affc			beq 	_RGI_Colour
.af8c		ae b3 07	ldx $07b3			ldx 	gxCommandID
.af8f		e0 52		cpx #$52			cpx 	#GCMD_SpriteMove 			; if not sprite
.af91		d0 03		bne $af96			bne 	_RGI_Move 					; move
.af93		4c 24 b0	jmp $b024			jmp		_RGI_SpriteInstructions
.af96						_RGI_Move:
.af96		88		dey				dey 								; unpick get.
.af97						_RGI_Move2:
.af97		20 4a b0	jsr $b04a			jsr 	GCGetCoordinatePair 		; move to here
.af9a		20 71 b0	jsr $b071			jsr 	GCCopyPairToStore 			; save
.af9d		5a		phy				phy
.af9e		20 67 b0	jsr $b067			jsr 	GCLoadAXY 					; load in
.afa1		09 40		ora #$40			ora 	#GCMD_Move 					; move there
.afa3		20 61 80	jsr $8061			jsr 	GXGraphicDraw
.afa6		7a		ply				ply
.afa7		80 b4		bra $af5d			bra 	_RGICommandLoop 			; and go round
.afa9						_RGI_Exit:
.afa9		88		dey				dey 								; unpick : / EOL
.afaa		60		rts				rts
.afab						_RGI_Solid:
.afab		a9 02		lda #$02			lda 	#2
.afad		8d b4 07	sta $07b4			sta 	gxFillSolid
.afb0		80 ab		bra $af5d			bra 	_RGICommandLoop
.afb2						_RGI_Frame:
.afb2		9c b4 07	stz $07b4			stz 	gxFillSolid
.afb5		80 a6		bra $af5d			bra 	_RGICommandLoop
.afb7						_RGI_To:
.afb7		20 4a b0	jsr $b04a			jsr 	GCGetCoordinatePair 		; get coordinate pair into slot #1,#2
.afba		20 71 b0	jsr $b071			jsr 	GCCopyPairToStore
.afbd						_RGI_Here:
.afbd		5a		phy				phy
.afbe		20 67 b0	jsr $b067			jsr 	GCLoadAXY 					; load it into AXY
.afc1		20 21 b0	jsr $b021			jsr 	_RGICallHandler 			; go do whatever it is.
.afc4		7a		ply				ply
.afc5		80 96		bra $af5d			bra 	_RGICommandLoop 			; and go round
.afc7						_RGI_By:
.afc7		20 57 b0	jsr $b057			jsr 	GCSignedCoordinatePair 		; get coordinate pair into slot #1,#2
.afca		18		clc				clc
.afcb		a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.afcd		6d b5 07	adc $07b5			adc 	gxXPos
.afd0		8d b5 07	sta $07b5			sta 	gxXPos
.afd3		a5 61		lda $61				lda 	NSMantissa1+1
.afd5		6d b6 07	adc $07b6			adc 	gxXPos+1
.afd8		8d b6 07	sta $07b6			sta 	gxXPos+1
.afdb		a5 5a		lda $5a				lda 	NSMantissa0+2
.afdd		18		clc				clc
.afde		6d b7 07	adc $07b7			adc 	gxYPos
.afe1		8d b7 07	sta $07b7			sta 	gxYPos
.afe4		80 d7		bra $afbd			bra 	_RGI_Here
.afe6						_RGI_Dim:
.afe6		a2 01		ldx #$01			ldx	 	#1
.afe8		20 f2 a8	jsr $a8f2			jsr 	Evaluate8BitInteger
.afeb		a5 59		lda $59				lda 	NSMantissa0+1
.afed		c9 00		cmp #$00			cmp 	#0
.afef		f0 2d		beq $b01e			beq 	_RGIRange
.aff1		c9 09		cmp #$09			cmp 	#8+1
.aff3		b0 29		bcs $b01e			bcs		_RGIRange
.aff5		3a		dec a				dec 	a
.aff6		8d ba 07	sta $07ba			sta 	gxDrawScale
.aff9		4c 5d af	jmp $af5d			jmp 	_RGICommandLoop
.affc						_RGI_Colour:
.affc		a2 01		ldx #$01			ldx 	#1 							; colour
.affe		20 f2 a8	jsr $a8f2			jsr 	Evaluate8BitInteger
.b001		a2 02		ldx #$02			ldx 	#2 							; default zero for 2nd parameter
.b003		20 57 a9	jsr $a957			jsr 	NSMSetZero
.b006		b1 30		lda ($30),y			lda 	(codePtr),y
.b008		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; check , => mode.
.b00a		d0 04		bne $b010			bne 	_RGICDefaultMode
.b00c		c8		iny				iny
.b00d		20 f2 a8	jsr $a8f2			jsr 	Evaluate8BitInteger
.b010						_RGICDefaultMode:
.b010		5a		phy				phy
.b011		a9 08		lda #$08			lda 	#GCMD_Colour 				; set colour.
.b013		a6 59		ldx $59				ldx 	NSMantissa0+1
.b015		a4 5a		ldy $5a				ldy 	NSMantissa0+2
.b017		20 61 80	jsr $8061			jsr 	GXGraphicDraw
.b01a		7a		ply				ply
.b01b		4c 5d af	jmp $af5d			jmp 	_RGICommandLoop 			; and go round
.b01e						_RGIRange:
.b01e		4c f8 ab	jmp $abf8			jmp 	RangeError
.b021						_RGICallHandler:
.b021		6c b8 07	jmp ($07b8)			jmp 	(gxHandler)
.b024						_RGI_SpriteInstructions:
.b024		c9 cb		cmp #$cb			cmp 	#KWD_OFF
.b026		f0 07		beq $b02f			beq 	_RGISpriteOff
.b028		c9 c6		cmp #$c6			cmp 	#KWD_IMAGE
.b02a		f0 13		beq $b03f			beq 	_RGISetImage
.b02c		4c 96 af	jmp $af96			jmp 	_RGI_Move
.b02f						_RGISpriteOff:
.b02f		5a		phy				phy
.b030		a0 01		ldy #$01			ldy 	#1
.b032		a2 00		ldx #$00			ldx 	#0
.b034						_RGIDoCommandLoop:
.b034		a9 10		lda #$10			lda 	#GCMD_SpriteImage
.b036		20 61 80	jsr $8061			jsr 	GXGraphicDraw
.b039		7a		ply				ply
.b03a		b0 e2		bcs $b01e			bcs 	_RGIRange
.b03c		4c 5d af	jmp $af5d			jmp 	_RGICommandLoop
.b03f						_RGISetImage:
.b03f		a2 01		ldx #$01			ldx 	#1
.b041		20 f2 a8	jsr $a8f2			jsr 	Evaluate8BitInteger
.b044		5a		phy				phy
.b045		aa		tax				tax
.b046		a0 00		ldy #$00			ldy 	#0
.b048		80 ea		bra $b034			bra 	_RGIDoCommandLoop
.b04a						GCGetCoordinatePair:
.b04a		a2 01		ldx #$01			ldx 	#1
.b04c		20 d7 a8	jsr $a8d7			jsr 	Evaluate16BitInteger
.b04f		20 e6 99	jsr $99e6			jsr 	CheckComma
.b052		e8		inx				inx
.b053		20 d7 a8	jsr $a8d7			jsr 	Evaluate16BitInteger
.b056		60		rts				rts
.b057						GCSignedCoordinatePair:
.b057		a2 01		ldx #$01			ldx 	#1
.b059		20 e1 a8	jsr $a8e1			jsr 	Evaluate16BitIntegerSigned
.b05c		20 e6 99	jsr $99e6			jsr 	CheckComma
.b05f		e8		inx				inx
.b060		20 e1 a8	jsr $a8e1			jsr 	Evaluate16BitIntegerSigned
.b063		60		rts				rts
.b064						_GCCPRange:
.b064		4c f8 ab	jmp $abf8			jmp 	RangeError
.b067						GCLoadAXY:
.b067		ad b6 07	lda $07b6			lda 	gxXPos+1
.b06a		ae b5 07	ldx $07b5			ldx 	gxXPos
.b06d		ac b7 07	ldy $07b7			ldy 	gxYPos
.b070		60		rts				rts
.b071						GCCopyPairToStore:
.b071		a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.b073		8d b5 07	sta $07b5			sta 	gxXPos
.b076		a5 61		lda $61				lda 	NSMantissa1+1
.b078		8d b6 07	sta $07b6			sta 	gxXPos+1
.b07b		a5 5a		lda $5a				lda 	NSMantissa0+2
.b07d		8d b7 07	sta $07b7			sta 	gxYPos
.b080		60		rts				rts
.07b3						gxCommandID:
>07b3								.fill 	1
.07b4						gxFillSolid:
>07b4								.fill 	1
.07b5						gxXPos:
>07b5								.fill 	2
.07b7						gxYPos:
>07b7								.fill 	1
.07b8						gxHandler:
>07b8								.fill 	2
.07ba						gxDrawScale:
>07ba								.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/graphics/gcontrol.asm

.b081						BitmapCtrl:
.b081		b1 30		lda ($30),y			lda 	(codePtr),y
.b083		c8		iny				iny
.b084		a2 01		ldx #$01			ldx 	#1
.b086		c9 cc		cmp #$cc			cmp 	#KWD_ON
.b088		f0 11		beq $b09b			beq 	BitmapSwitch
.b08a		ca		dex				dex
.b08b		c9 cb		cmp #$cb			cmp 	#KWD_OFF
.b08d		f0 0c		beq $b09b			beq 	BitmapSwitch
.b08f		20 f2 a8	jsr $a8f2			jsr 	Evaluate8BitInteger 		; get the colour
.b092		5a		phy				phy
.b093		aa		tax				tax
.b094		a9 06		lda #$06			lda 	#GCMD_Clear					; clear to that colour
.b096		20 61 80	jsr $8061			jsr 	GXGraphicDraw
.b099		7a		ply				ply
.b09a		60		rts				rts
.b09b						BitmapSwitch:
.b09b		5a		phy				phy
.b09c		a0 00		ldy #$00			ldy 	#0 							; gfx 1,on/off,0
.b09e		a9 02		lda #$02			lda 	#GCMD_BitmapCtl
.b0a0		20 61 80	jsr $8061			jsr 	GXGraphicDraw
.b0a3		a9 08		lda #$08			lda 	#GCMD_Colour				; set colour to $FF
.b0a5		a0 00		ldy #$00			ldy 	#0
.b0a7		a2 ff		ldx #$ff			ldx 	#$FF
.b0a9		20 61 80	jsr $8061			jsr 	GXGraphicDraw
.b0ac		9c b4 07	stz $07b4			stz 	gxFillSolid
.b0af		9c b5 07	stz $07b5			stz 	gxXPos
.b0b2		9c b6 07	stz $07b6			stz 	gxXPos+1
.b0b5		9c b7 07	stz $07b7			stz 	gxYPos
.b0b8		9c ba 07	stz $07ba			stz 	gxDrawScale
.b0bb		a9 40		lda #$40			lda 	#GCMD_Move 						; home cursor
.b0bd		a2 00		ldx #$00			ldx 	#0
.b0bf		a0 00		ldy #$00			ldy 	#0
.b0c1		20 61 80	jsr $8061			jsr 	GXGraphicDraw
.b0c4		7a		ply				ply
.b0c5		60		rts				rts
.b0c6						SpritesCtrl:
.b0c6		b1 30		lda ($30),y			lda 	(codePtr),y
.b0c8		c8		iny				iny
.b0c9		a2 01		ldx #$01			ldx 	#1
.b0cb		c9 cc		cmp #$cc			cmp 	#KWD_ON
.b0cd		f0 08		beq $b0d7			beq 	SpriteSwitch
.b0cf		ca		dex				dex
.b0d0		c9 cb		cmp #$cb			cmp 	#KWD_OFF
.b0d2		f0 03		beq $b0d7			beq 	SpriteSwitch
.b0d4		4c f3 ab	jmp $abf3			jmp 	SyntaxError
.b0d7						SpriteSwitch:
.b0d7		5a		phy				phy
.b0d8		a0 00		ldy #$00			ldy 	#0 							; gfx 2,on/off,0
.b0da		a9 04		lda #$04			lda 	#GCMD_SpriteCtl
.b0dc		20 61 80	jsr $8061			jsr 	GXGraphicDraw
.b0df		7a		ply				ply
.b0e0		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/graphics/gfx.asm

.b0e1						GfxCommand:
.b0e1		a2 00		ldx #$00			ldx 	#0
.b0e3		20 f2 a8	jsr $a8f2			jsr 	Evaluate8BitInteger 		; command
.b0e6		20 e6 99	jsr $99e6			jsr 	CheckComma
.b0e9		e8		inx				inx
.b0ea		20 d7 a8	jsr $a8d7			jsr 	Evaluate16BitInteger 		; X
.b0ed		20 e6 99	jsr $99e6			jsr 	CheckComma
.b0f0		e8		inx				inx
.b0f1		20 f2 a8	jsr $a8f2			jsr 	Evaluate8BitInteger 		; Y
.b0f4		a5 61		lda $61				lda 	NSMantissa1+1  				; shift bit 0 of X into CS, should now be zero
.b0f6		4a		lsr a				lsr 	a
.b0f7		d0 12		bne $b10b			bne 	_GfxError
.b0f9		26 58		rol $58				rol 	NSMantissa0 				; rotate into command
.b0fb		b0 0e		bcs $b10b			bcs 	_GfxError 					; bit 7 should have been zero
.b0fd		5a		phy				phy 								; save pos
.b0fe		a5 58		lda $58				lda 	NSMantissa0 				; do the command
.b100		a6 59		ldx $59				ldx 	NSMantissa0+1
.b102		a4 5a		ldy $5a				ldy 	NSMantissa0+2
.b104		20 61 80	jsr $8061			jsr 	GXGraphicDraw
.b107		b0 02		bcs $b10b			bcs 	_GfxError
.b109		7a		ply				ply 								; restore pos and exit.
.b10a		60		rts				rts
.b10b						_GfxError:
.b10b		4c f8 ab	jmp $abf8			jmp 	RangeError

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/graphics/hit.asm

.b10e						UnaryHit:
.b10e		fa		plx				plx
.b10f		a9 36		lda #$36			lda 	#zTemp0
.b111		20 f2 a8	jsr $a8f2			jsr 	Evaluate8BitInteger 		; get sprite number 0
.b114		20 e6 99	jsr $99e6			jsr 	CheckComma
.b117		e8		inx				inx
.b118		20 f2 a8	jsr $a8f2			jsr 	Evaluate8BitInteger 		; get sprite number 1
.b11b		20 de 99	jsr $99de			jsr		CheckRightBracket
.b11e		ca		dex				dex 								; fix back up again.
.b11f		da		phx				phx 								; save X/Y
.b120		5a		phy				phy
.b121		b4 59		ldy $59,x			ldy 	NSMantissa0+1,x 			; get the sprite numbers into X/Y
.b123		b5 58		lda $58,x			lda 	NSMantissa0,x
.b125		aa		tax				tax
.b126		a9 12		lda #$12			lda 	#GCMD_SpriteCollide 		; command check collision.
.b128		20 61 80	jsr $8061			jsr 	GXGraphicDraw 				; calculate result
.b12b		1a		inc a				inc 	a 							; so 255 (fail) -> 0, otherwise 1,2,3,4 pixels etc.
.b12c		7a		ply				ply 								; restore XY
.b12d		fa		plx				plx
.b12e		20 59 a9	jsr $a959			jsr 	NSMSetByte 					; return the hit result
.b131		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/graphics/palette.asm

.b132						PaletteCommand:
.b132		a2 00		ldx #$00			ldx 	#0
.b134		20 f2 a8	jsr $a8f2			jsr 	Evaluate8BitInteger 		; colour
.b137		20 e6 99	jsr $99e6			jsr 	CheckComma
.b13a		e8		inx				inx
.b13b		20 d7 a8	jsr $a8d7			jsr 	Evaluate16BitInteger 		; r
.b13e		20 e6 99	jsr $99e6			jsr 	CheckComma
.b141		e8		inx				inx
.b142		20 f2 a8	jsr $a8f2			jsr 	Evaluate8BitInteger 		; g
.b145		20 e6 99	jsr $99e6			jsr 	CheckComma
.b148		e8		inx				inx
.b149		20 f2 a8	jsr $a8f2			jsr 	Evaluate8BitInteger 		; b
.b14c		a5 58		lda $58				lda 	NSMantissa0 				; get colour #
.b14e		85 36		sta $36				sta 	zTemp0
.b150		a9 34		lda #$34			lda 	#$D0 >> 2 					; MSB = D0/4
.b152		85 37		sta $37				sta 	zTemp0+1
.b154		06 36		asl $36				asl 	zTemp0 						; zTemp = $D000+Colour x 4
.b156		26 37		rol $37				rol	 	zTemp0+1
.b158		06 36		asl $36				asl 	zTemp0
.b15a		26 37		rol $37				rol	 	zTemp0+1
.b15c		a9 01		lda #$01			lda 	#1 							; I/O Page 2
.b15e		85 01		sta $01				sta 	1
.b160		5a		phy				phy
.b161		a5 5b		lda $5b				lda 	NSMantissa0+3 				; fix to r,g,b
.b163		92 36		sta ($36)			sta 	(zTemp0)
.b165		a0 01		ldy #$01			ldy 	#1
.b167		a5 5a		lda $5a				lda 	NSMantissa0+2
.b169		91 36		sta ($36),y			sta 	(zTemp0),y
.b16b		a5 59		lda $59				lda 	NSMantissa0+1
.b16d		c8		iny				iny
.b16e		91 36		sta ($36),y			sta 	(zTemp0),y
.b170		7a		ply				ply
.b171		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/hardware/cls.asm

.b172						ClearScreen:
.b172		5a		phy				phy
.b173		a9 0c		lda #$0c			lda 	#12 						; char code 12 clears the screen.
.b175		20 43 80	jsr $8043			jsr 	EXTPrintCharacter
.b178		7a		ply				ply
.b179		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/sound/effects.asm

.b17a						PingCommand:
.b17a		5a		phy				phy 								; save pos
.b17b		a9 01		lda #$01			lda 	#1 						; push channel.
.b17d		48		pha				pha
.b17e		a9 c8		lda #$c8			lda 	#200 						; pitch LSB
.b180		a2 06		ldx #$06			ldx 	#6 						; length
.b182		a0 00		ldy #$00			ldy 	#0 						; slide LSB
.b184		80 24		bra $b1aa			bra 	SoundEffectCommand
.b186						ZapCommand:
.b186		5a		phy				phy 								; save pos
.b187		a9 01		lda #$01			lda 	#1 						; push channel.
.b189		48		pha				pha
.b18a		a9 ff		lda #$ff			lda 	#255 						; pitch LSB
.b18c		a2 0a		ldx #$0a			ldx 	#10 						; length
.b18e		a0 0a		ldy #$0a			ldy 	#10 						; slide LSB
.b190		80 18		bra $b1aa			bra 	SoundEffectCommand
.b192						ShootCommand:
.b192		5a		phy				phy 								; save pos
.b193		a9 03		lda #$03			lda 	#3 						; push channel.
.b195		48		pha				pha
.b196		a9 20		lda #$20			lda 	#32 						; pitch LSB
.b198		a2 04		ldx #$04			ldx 	#4 						; length
.b19a		a0 00		ldy #$00			ldy 	#0 						; slide LSB
.b19c		80 0c		bra $b1aa			bra 	SoundEffectCommand
.b19e						Explode:
.b19e		5a		phy				phy 								; save pos
.b19f		a9 03		lda #$03			lda 	#3 						; push channel.
.b1a1		48		pha				pha
.b1a2		a9 50		lda #$50			lda 	#80 						; pitch LSB
.b1a4		a2 0a		ldx #$0a			ldx 	#10 						; length
.b1a6		a0 00		ldy #$00			ldy 	#0 						; slide LSB
.b1a8		80 00		bra $b1aa			bra 	SoundEffectCommand
.b1aa						SoundEffectCommand:
.b1aa		8d bb 07	sta $07bb			sta 	SoundCommandBlock 			; set up the command block in sound.asm
.b1ad		9c bc 07	stz $07bc			stz 	SoundCommandBlock+1
.b1b0		a9 0f		lda #$0f			lda 	#15
.b1b2		8d bd 07	sta $07bd			sta 	SoundCommandBlock+2
.b1b5		8e be 07	stx $07be			stx 	SoundCommandBlock+3
.b1b8		8c bf 07	sty $07bf			sty 	SoundCommandBlock+4
.b1bb		9c c0 07	stz $07c0			stz 	SoundCommandBlock+5
.b1be		68		pla				pla
.b1bf		09 10		ora #$10			ora 	#$10  						; execute command $11
.b1c1		a2 bb		ldx #$bb			ldx 	#(SoundCommandBlock & $FF)
.b1c3		a0 07		ldy #$07			ldy 	#(SoundCommandBlock >> 8)
.b1c5		20 6b 80	jsr $806b			jsr 	SNDCommand
.b1c8		7a		ply				ply
.b1c9		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/sound/playing.asm

.b1ca						UnaryPlaying:
.b1ca		fa		plx				plx
.b1cb		20 f2 a8	jsr $a8f2			jsr 	Evaluate8BitInteger 		; get channel #
.b1ce		48		pha				pha
.b1cf		20 de 99	jsr $99de			jsr		CheckRightBracket
.b1d2		68		pla				pla
.b1d3		c9 04		cmp #$04			cmp 	#4
.b1d5		b0 0c		bcs $b1e3			bcs 	_UPNotPlaying
.b1d7		09 20		ora #$20			ora 	#$20 						; query playing ?
.b1d9		20 6b 80	jsr $806b			jsr 	SNDCommand
.b1dc		c9 00		cmp #$00			cmp 	#0
.b1de		f0 03		beq $b1e3			beq 	_UPNotPlaying
.b1e0		4c 6a 9a	jmp $9a6a			jmp 	ReturnTrue
.b1e3						_UPNotPlaying:
.b1e3		4c 75 9a	jmp $9a75			jmp 	ReturnFalse

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/sound/sound.asm

.b1e6						SoundCommand:
.b1e6		b1 30		lda ($30),y			lda 	(codePtr),y
.b1e8		c9 cb		cmp #$cb			cmp 	#KWD_OFF 					; SOUND OFF ?
.b1ea		d0 09		bne $b1f5			bne 	_SNDMain
.b1ec		c8		iny				iny 								; skip OFF
.b1ed		a9 3f		lda #$3f			lda 	#$3F 						; call command $3F (silence)
.b1ef		5a		phy				phy
.b1f0		20 6b 80	jsr $806b			jsr 	SNDCommand
.b1f3		7a		ply				ply
.b1f4		60		rts				rts
.b1f5						_SNDMain:
.b1f5		a2 00		ldx #$00			ldx 	#0
.b1f7		20 f2 a8	jsr $a8f2			jsr 	Evaluate8BitInteger 		; channel
.b1fa		c9 04		cmp #$04			cmp 	#4 							; must be 0-3
.b1fc		b0 4b		bcs $b249			bcs 	_SndError
.b1fe		e8		inx				inx 								; do the rest in slot 1.
.b1ff		20 e6 99	jsr $99e6			jsr 	CheckComma
.b202		20 d7 a8	jsr $a8d7			jsr 	Evaluate16BitInteger 		; Pitch
.b205		b5 60		lda $60,x			lda 	NSMantissa1,x 				; must be 10 bit
.b207		c9 10		cmp #$10			cmp 	#16
.b209		b0 3e		bcs $b249			bcs 	_SndError
.b20b		8d bc 07	sta $07bc			sta 	SoundCommandBlock+1 		; Pitch (2 bytes + 0)
.b20e		b5 58		lda $58,x			lda 	NSMantissa0,x
.b210		8d bb 07	sta $07bb			sta 	SoundCommandBlock
.b213		20 e6 99	jsr $99e6			jsr 	CheckComma
.b216		20 f2 a8	jsr $a8f2			jsr 	Evaluate8BitInteger 		; Length (1 byte + 3)
.b219		8d be 07	sta $07be			sta 	SoundCommandBlock+3
.b21c		a9 0f		lda #$0f			lda 	#15
.b21e		8d bd 07	sta $07bd			sta 	SoundCommandBlock+2 		; Volume (1 byte + 2)
.b221		9c bf 07	stz $07bf			stz 	SoundCommandBlock+4 		; default slide (2 bytes +4)
.b224		9c c0 07	stz $07c0			stz 	SoundCommandBlock+5
.b227		b1 30		lda ($30),y			lda 	(codePtr),y
.b229		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.b22b		d0 0e		bne $b23b			bne 	_SNDPlay
.b22d		c8		iny				iny
.b22e		20 e1 a8	jsr $a8e1			jsr 	Evaluate16BitIntegerSigned 	; Slide
.b231		b5 58		lda $58,x			lda 	NSMantissa0,x 				; Slide (2 bytes + 4)
.b233		8d bf 07	sta $07bf			sta 	SoundCommandBlock+4
.b236		b5 60		lda $60,x			lda 	NSMantissa1,x
.b238		8d c0 07	sta $07c0			sta 	SoundCommandBlock+5
.b23b						_SNDPlay:
.b23b		5a		phy				phy
.b23c		a5 58		lda $58				lda 	NSMantissa0 				; channel.
.b23e		09 10		ora #$10			ora 	#$10 						; 1x = Queue sound
.b240		a2 bb		ldx #$bb			ldx 	#(SoundCommandBlock & $FF)
.b242		a0 07		ldy #$07			ldy 	#(SoundCommandBlock >> 8)
.b244		20 6b 80	jsr $806b			jsr 	SNDCommand
.b247		7a		ply				ply
.b248		60		rts				rts
.b249						_SndError:
.b249		4c f8 ab	jmp $abf8			jmp 	RangeError
.07bb						SoundCommandBlock:
>07bb								.fill 	6

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/bytes.asm

.b24c						StackPushByte:
.b24c		48		pha				pha 								; save byte on stack
.b24d		a5 34		lda $34				lda 	basicStack 					; decrement basic stack pointer
.b24f		d0 08		bne $b259			bne 	_SPBNoBorrow
.b251		c6 35		dec $35				dec 	basicStack+1 				; borrow
.b253		a5 35		lda $35				lda 	basicStack+1 				; check range.
.b255		c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.b257		90 06		bcc $b25f			bcc 	_SPBMemory
.b259						_SPBNoBorrow:
.b259		c6 34		dec $34				dec 	basicStack
.b25b		68		pla				pla 								; get back and write
.b25c		92 34		sta ($34)			sta 	(basicStack)
.b25e		60		rts				rts
.b25f						_SPBMemory:
.b25f		a9 12		lda #$12		lda	#18
.b261		4c f7 99	jmp $99f7		jmp	ErrorHandler
.b264						StackPopByte:
.b264		b2 34		lda ($34)			lda 	(basicStack) 				; bump the stack pointer.
.b266		e6 34		inc $34				inc 	basicStack
.b268		d0 02		bne $b26c			bne 	_SPBNoCarry
.b26a		e6 35		inc $35				inc 	basicStack+1
.b26c						_SPBNoCarry:
.b26c		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/frames.asm

.b26d						StackOpen:
.b26d		48		pha				pha 								; save frame byte
.b26e		29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.b270		0a		asl a				asl 	a 							; claim twice this for storage
.b271		49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.b273		38		sec				sec 								; so basically subtracting from
.b274		65 34		adc $34				adc 	basicStack 	 				; basicStack
.b276		85 34		sta $34				sta 	basicStack
.b278		b0 09		bcs $b283			bcs 	_SONoBorrow
>b27a		db						.byte 	$DB 						; causes a break in the emulator
.b27b		c6 35		dec $35				dec 	basicStack+1
.b27d		a5 35		lda $35				lda 	basicStack+1 				; have we reached stack overflow
.b27f		c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.b281		90 04		bcc $b287			bcc 	_SOMemory
.b283						_SONoBorrow:
.b283		68		pla				pla 								; get marker back and write at TOS
.b284		92 34		sta ($34)			sta 	(basicStack)
.b286		60		rts				rts
.b287						_SOMemory:
.b287		a9 12		lda #$12		lda	#18
.b289		4c f7 99	jmp $99f7		jmp	ErrorHandler
.b28c						StackClose:
.b28c		b2 34		lda ($34)			lda 	(basicStack) 				; get TOS marker
.b28e		29 0f		and #$0f			and 	#$0F 						; bytes to add back
.b290		0a		asl a				asl 	a 							; claim twice this.
.b291		65 34		adc $34				adc 	basicStack 					; add to the stack pointer.
.b293		85 34		sta $34				sta 	basicStack
.b295		90 02		bcc $b299			bcc 	_SCExit
.b297		e6 35		inc $35				inc 	basicStack+1
.b299						_SCExit:
.b299		60		rts				rts
.b29a						StackCheckFrame:
.b29a		48		pha				pha
.b29b						_StackRemoveLocals:
.b29b		b2 34		lda ($34)			lda 	(basicStack) 				; check for local, keep popping them
.b29d		c9 03		cmp #$03			cmp 	#STK_LOCALS+1 				; is the frame a local ? S or N are 1/0
.b29f		b0 05		bcs $b2a6			bcs 	_SCNoLocal
.b2a1		20 e4 91	jsr $91e4			jsr 	LocalPopValue 				; restore the local value
.b2a4		80 f5		bra $b29b			bra 	_StackRemoveLocals 			; gr round again
.b2a6						_SCNoLocal:
.b2a6		68		pla				pla 								; get the frame check.
.b2a7		52 34		eor ($34)			eor 	(basicStack) 				; xor with toS marker
.b2a9		29 f0		and #$f0			and 	#$F0 						; check type bits
.b2ab		d0 01		bne $b2ae			bne 	_SCFError 					; different, we have structures mixed up
.b2ad		60		rts				rts
.b2ae						_SCFError:
.b2ae		8a		txa				txa 								; report error X
.b2af		4c f7 99	jmp $99f7			jmp 	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/location.asm

.b2b2						STKSaveCodePosition:
.b2b2		5a		phy				phy
.b2b3		98		tya				tya 								; save Y
.b2b4		a0 05		ldy #$05			ldy 	#5
.b2b6		91 34		sta ($34),y			sta 	(basicStack),y
.b2b8		88		dey				dey 								; save Code Pointer
.b2b9						_STKSaveLoop:
.b2b9		b9 2f 00	lda $002f,y			lda 	safePtr-1,y 				; allows us to access the pointer w/out issues.
.b2bc		91 34		sta ($34),y			sta 	(basicStack),y
.b2be		88		dey				dey
.b2bf		d0 f8		bne $b2b9			bne 	_STKSaveLoop
.b2c1		7a		ply				ply
.b2c2		60		rts				rts
.b2c3						STKLoadCodePosition:
.b2c3		a0 01		ldy #$01			ldy 	#1 							; load code pointer back
.b2c5						_STKLoadLoop:
.b2c5		b1 34		lda ($34),y			lda 	(basicStack),y
.b2c7		99 2f 00	sta $002f,y			sta 	safePtr-1,y
.b2ca		c8		iny				iny
.b2cb		c0 05		cpy #$05			cpy 	#5
.b2cd		d0 f6		bne $b2c5			bne 	_STKLoadLoop
.b2cf		b1 34		lda ($34),y			lda 	(basicStack),y 				; get Y offset
.b2d1		a8		tay				tay
.b2d2		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/setup.asm

.b2d3						StackReset:
.b2d3		a9 ff		lda #$ff			lda 	#((BasicStackBase+BasicStackSize-1) & $FF)
.b2d5		85 34		sta $34				sta 	0+basicStack
.b2d7		a9 0f		lda #$0f			lda 	#((BasicStackBase+BasicStackSize-1) >> 8)
.b2d9		85 35		sta $35				sta 	1+basicStack
.b2db		a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.b2dd		92 34		sta ($34)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.b2df		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/concrete.asm

.b2e0						StringConcrete:
.b2e0		5a		phy				phy 								; save position on stack
.b2e1		20 37 a5	jsr $a537			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.b2e4		b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy target string to zTemp1
.b2e6		85 38		sta $38				sta 	zTemp1
.b2e8		b5 60		lda $60,x			lda 	NSMantissa1,x
.b2ea		85 39		sta $39				sta 	zTemp1+1
.b2ec		a0 ff		ldy #$ff			ldy 	#$FF	 					; calculate string length
.b2ee						_SALength:
.b2ee		c8		iny				iny
.b2ef		b1 38		lda ($38),y			lda 	(zTemp1),y
.b2f1		d0 fb		bne $b2ee			bne 	_SALength
.b2f3		c0 fd		cpy #$fd			cpy 	#253 						; string too long - cannot concrete.
.b2f5		b0 3d		bcs $b334			bcs 	_SALengthError
.b2f7		98		tya				tya 				 				; length of the new string
.b2f8		18		clc				clc
.b2f9		69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.b2fb		90 02		bcc $b2ff			bcc 	_SAHaveLength
.b2fd		a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.b2ff						_SAHaveLength:
.b2ff		48		pha				pha 								; save length.
.b300		38		sec				sec
.b301		49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.b303		6d 0a 04	adc $040a			adc 	stringMemory
.b306		8d 0a 04	sta $040a			sta 	stringMemory
.b309		85 3a		sta $3a				sta 	zTemp2 						; update storage address
.b30b		95 58		sta $58,x			sta 	NSMantissa0,x 				; update mantissa address
.b30d		a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.b30f		6d 0b 04	adc $040b			adc 	stringMemory+1
.b312		8d 0b 04	sta $040b			sta 	stringMemory+1
.b315		85 3b		sta $3b				sta 	zTemp2+1
.b317		95 60		sta $60,x			sta 	NSMantissa1,x
.b319		68		pla				pla 								; save length-3 (chars allowed) in first byte
.b31a		38		sec				sec
.b31b		e9 03		sbc #$03			sbc 	#3
.b31d		92 3a		sta ($3a)			sta 	(zTemp2)
.b31f		a9 00		lda #$00			lda 	#0 							; clear the status byte.
.b321		a0 01		ldy #$01			ldy 	#1
.b323		91 3a		sta ($3a),y			sta 	(zTemp2),y
.b325						_SACopyNewString:
.b325		a0 00		ldy #$00			ldy 	#0
.b327						_SACopyNSLoop:
.b327		b1 38		lda ($38),y			lda 	(zTemp1),y 					; get character
.b329		c8		iny				iny 								; write two on in string storage
.b32a		c8		iny				iny
.b32b		91 3a		sta ($3a),y			sta 	(zTemp2),y
.b32d		88		dey				dey 								; this makes it one one.
.b32e		c9 00		cmp #$00			cmp 	#0 							; until EOS copied
.b330		d0 f5		bne $b327			bne 	_SACopyNSLoop
.b332		7a		ply				ply
.b333		60		rts				rts
.b334						_SALengthError:
.b334		a9 09		lda #$09		lda	#9
.b336		4c f7 99	jmp $99f7		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/stringalloc.asm

.b339						StringSystemInitialise:
.b339		a9 ff		lda #$ff			lda 	#((EndVariableSpace-1) & $FF)
.b33b		8d 0a 04	sta $040a			sta 	0+stringMemory
.b33e		a9 1f		lda #$1f			lda 	#((EndVariableSpace-1) >> 8)
.b340		8d 0b 04	sta $040b			sta 	1+stringMemory
.b343		9c ff 1f	stz $1fff			stz 	EndVariableSpace-1 			; put a zero at the end, so know end of string memory.
.b346		60		rts				rts
.b347						StringSpaceInitialise:
.b347		20 37 a5	jsr $a537			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.b34a		a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.b34c		8d 0c 04	sta $040c			sta 	stringInitialised
.b34f		ad 0a 04	lda $040a			lda 	stringMemory 				; allocate 256 bytes for one concreted string
.b352		8d 0d 04	sta $040d			sta 	stringTempPointer 			; so temporary string space is allocated below that.
.b355		ad 0b 04	lda $040b			lda 	stringMemory+1
.b358		3a		dec a				dec 	a
.b359		8d 0e 04	sta $040e			sta 	stringTempPointer+1
.b35c		60		rts				rts
.b35d						StringTempAllocate:
.b35d		c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.b35f		b0 30		bcs $b391			bcs 	_STALength
.b361		2c 0c 04	bit $040c			bit 	stringInitialised 			; already initialised
.b364		30 05		bmi $b36b			bmi 	_STAAllocate
.b366		48		pha				pha 								; save value to subtract.
.b367		20 47 b3	jsr $b347			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.b36a		68		pla				pla 								; restore it
.b36b						_STAAllocate:
.b36b		49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.b36d		18		clc				clc  								; deliberate allows one more
.b36e		6d 0d 04	adc $040d			adc 	stringTempPointer 			; subtract from temp pointer
.b371		8d 0d 04	sta $040d			sta 	stringTempPointer
.b374		95 58		sta $58,x			sta 	NSMantissa0,x 				; address in mantissa
.b376		85 3c		sta $3c				sta 	zsTemp 						; and zsTemp
.b378		ad 0e 04	lda $040e			lda 	stringTempPointer+1
.b37b		69 ff		adc #$ff			adc 	#$FF
.b37d		8d 0e 04	sta $040e			sta 	stringTempPointer+1
.b380		85 3d		sta $3d				sta 	zsTemp+1
.b382		95 60		sta $60,x			sta 	NSMantissa1,x
.b384		74 68		stz $68,x			stz 	NSMantissa2,x 				; set the typing data and the upper address bytes.
.b386		74 70		stz $70,x			stz 	NSMantissa3,x
.b388		a9 10		lda #$10			lda 	#NSTString
.b38a		95 50		sta $50,x			sta 	NSStatus,x
.b38c		a9 00		lda #$00			lda 	#0 							; clear the target string
.b38e		92 3c		sta ($3c)			sta 	(zsTemp)
.b390		60		rts				rts
.b391						_STALength:
.b391		a9 09		lda #$09		lda	#9
.b393		4c f7 99	jmp $99f7		jmp	ErrorHandler
.b396						StringTempWrite:
.b396		48		pha				pha
.b397		92 3c		sta ($3c)			sta 	(zsTemp) 					; write byte
.b399		e6 3c		inc $3c				inc 	zsTemp 						; bump pointer
.b39b		d0 02		bne $b39f			bne 	_STWNoCarry
.b39d		e6 3d		inc $3d				inc 	zsTemp+1
.b39f						_STWNoCarry:
.b39f		a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.b3a1		92 3c		sta ($3c)			sta 	(zsTemp)
.b3a3		68		pla				pla
.b3a4		60		rts				rts

;******  Return to file: _basic.asm

.b3a5						StartModuleCode:

;******  Processing file: ../modules/_build/_hardware.module

=1						hardwareIntegrated=1
=0						CONBlack = 0
=1						CONGrey = 1
=2						CONDarkBlue = 2
=3						CONGreen = 3
=4						CONPurple = 4
=5						CONBrown = 5
=6						CONOrange = 6
=7						CONCyan = 7
=8						CONDarkGrey = 8
=9						CONLightGrey = 9
=10						CONLightBlue = 10
=11						CONLightGreen = 11
=12						CONPink = 12
=13						CONRed = 13
=14						CONYellow = 14
=15						CONWhite = 15
=9						CONForeground = CONLightGrey
=2						CONBackground = CONDarkBlue
=9						CLICommandLine = CONLightGrey
=5						CLIFComment = CONBrown
=14						CLIBComment = CONYellow
=13						CLILineNumber = CONRed
=6						CLIToken = CONOrange
=7						CLIConstant = CONCyan
=14						CLIIdentifier = CONYellow
=12						CLIPunctuation = CONPink
=15						CLIData = CONWhite
.c000	a000					Export_EXTPrintNoControl:
.c000	a000	48		pha				pha
.c001	a001	da		phx				phx
.c002	a002	5a		phy				phy
.c003	a003	a6 01		ldx $01				ldx 	1
.c005	a005	da		phx				phx
.c006	a006	ac c2 07	ldy $07c2			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.c009	a009	80 11		bra $a01c			bra 	PrintCharacterOnly
.c00b	a00b					Export_EXTPrintCharacter:
.c00b	a00b					PAGEDPrintCharacter:
.c00b	a00b	48		pha				pha
.c00c	a00c	da		phx				phx
.c00d	a00d	5a		phy				phy
.c00e	a00e	a6 01		ldx $01				ldx 	1
.c010	a010	da		phx				phx
.c011	a011	ac c2 07	ldy $07c2			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.c014	a014	09 00		ora #$00			ora 	#$00 						; check $80-$FF
.c016	a016	30 48		bmi $a060			bmi 	EXPCColour
.c018	a018	c9 20		cmp #$20			cmp 	#$20 						; check $00-$1F
.c01a	a01a	90 4d		bcc $a069			bcc 	EXPCControl
.c01c	a01c					PrintCharacterOnly:
.c01c	a01c	a2 02		ldx #$02			ldx 	#2 							; select char memory
.c01e	a01e	86 01		stx $01				stx 	1
.c020	a020	91 40		sta ($40),y			sta 	(EXTAddress),y
.c022	a022	e6 01		inc $01				inc 	1 							; select colour memory
.c024	a024	ad c3 07	lda $07c3			lda 	EXTTextColour
.c027	a027	91 40		sta ($40),y			sta 	(EXTAddress),y
.c029	a029	c8		iny				iny 								; advance horizontal position
.c02a	a02a	8c c2 07	sty $07c2			sty 	EXTColumn
.c02d	a02d	cc c4 07	cpy $07c4			cpy 	EXTScreenWidth 				; reached RHS ?
.c030	a030	90 63		bcc $a095			bcc 	EXPCExit 					; no, then exit.
.c032	a032					EXPCCRLF:
.c032	a032	ee c1 07	inc $07c1			inc 	EXTRow  					; bump row
.c035	a035	9c c2 07	stz $07c2			stz 	EXTColumn 					; back to column 0
.c038	a038	ad c1 07	lda $07c1			lda 	EXTRow 						; check if reached the bottom ?
.c03b	a03b	cd c5 07	cmp $07c5			cmp 	EXTScreenHeight 			; if so, then scroll.
.c03e	a03e	f0 18		beq $a058			beq 	EXPCScroll
.c040	a040	18		clc				clc 								; add width to address.
.c041	a041	a5 40		lda $40				lda 	EXTAddress
.c043	a043	6d c4 07	adc $07c4			adc 	EXTScreenWidth
.c046	a046	85 40		sta $40				sta 	EXTAddress
.c048	a048	90 4b		bcc $a095			bcc 	EXPCExit
.c04a	a04a	e6 41		inc $41				inc 	EXTAddress+1
.c04c	a04c	80 47		bra $a095			bra 	EXPCExit
.c04e	a04e					EXPCLeft:
.c04e	a04e	ce c2 07	dec $07c2			dec 	EXTColumn
.c051	a051	10 42		bpl $a095			bpl 	EXPCExit
.c053	a053					EXPCBegin:
.c053	a053	9c c2 07	stz $07c2			stz 	EXTColumn
.c056	a056	80 3d		bra $a095			bra 	EXPCExit
.c058	a058					EXPCScroll:
.c058	a058	ce c1 07	dec $07c1			dec 	EXTRow 						; the height-1 th line.
.c05b	a05b	20 46 a1	jsr $a146			jsr 	EXTScreenScroll 			; scroll the screen
.c05e	a05e	80 35		bra $a095			bra 	EXPCExit
.c060	a060					EXPCColour:
.c060	a060	c9 a0		cmp #$a0			cmp 	#$A0						; 80-9F set foreground/background
.c062	a062	b0 31		bcs $a095			bcs 	EXPCExit
.c064	a064	20 26 a1	jsr $a126			jsr 	EXPCHandleColour
.c067	a067	80 2c		bra $a095			bra 	EXPCExit
.c069	a069					EXPCControl:
.c069	a069	c9 11		cmp #$11			cmp 	#$11 						; only handle 00-10.
.c06b	a06b	b0 28		bcs $a095			bcs 	EXPCExit
.c06d	a06d	0a		asl a				asl 	a 							; double into X
.c06e	a06e	aa		tax				tax
.c06f	a06f	7c 04 a1	jmp ($a104,x)			jmp 	(EXPCActionTable,x) 		; and execute code.
.c072	a072					EXPCUp:
.c072	a072	ad c1 07	lda $07c1			lda 	EXTRow 						; already at top ?
.c075	a075	f0 1e		beq $a095			beq 	EXPCExit
.c077	a077	ce c1 07	dec $07c1			dec 	EXTRow 						; up one in position/address
.c07a	a07a	38		sec				sec
.c07b	a07b	a5 40		lda $40				lda 	EXTAddress
.c07d	a07d	ed c4 07	sbc $07c4			sbc 	EXTScreenWidth
.c080	a080	85 40		sta $40				sta 	EXTAddress
.c082	a082	b0 11		bcs $a095			bcs 	EXPCExit
.c084	a084	c6 41		dec $41				dec 	EXTAddress+1
.c086	a086	80 0d		bra $a095			bra 	EXPCExit
.c088	a088					EXPCRight:
.c088	a088	c8		iny				iny
.c089	a089	8c c2 07	sty $07c2			sty 	EXTColumn
.c08c	a08c	cc c4 07	cpy $07c4			cpy 	EXTScreenWidth
.c08f	a08f	d0 04		bne $a095			bne 	EXPCExit
.c091	a091	88		dey				dey
.c092	a092					EXPCSetColumnY:
.c092	a092	8c c2 07	sty $07c2			sty 	EXTColumn
.c095	a095					EXPCExit:
.c095	a095	20 bb a1	jsr $a1bb			jsr 	EXTSetHardwareCursor 		; place the physical cursor.
.c098	a098	68		pla				pla
.c099	a099	85 01		sta $01				sta 	1
.c09b	a09b	7a		ply				ply
.c09c	a09c	fa		plx				plx
.c09d	a09d	68		pla				pla
.c09e	a09e	60		rts				rts
.c09f	a09f					EXPCClearScreen:
.c09f	a09f	20 78 a1	jsr $a178			jsr		EXTClearScreenCode
.c0a2	a0a2	80 f1		bra $a095			bra 	EXPCExit
.c0a4	a0a4					EXPCDown:
.c0a4	a0a4	ad c5 07	lda $07c5			lda 	EXTScreenHeight 			; at the bottom
.c0a7	a0a7	3a		dec a				dec 	a
.c0a8	a0a8	cd c1 07	cmp $07c1			cmp 	EXTRow
.c0ab	a0ab	f0 e8		beq $a095			beq 	EXPCExit
.c0ad	a0ad	ee c1 07	inc $07c1			inc 	EXTRow 						; down one in position/address
.c0b0	a0b0	18		clc				clc
.c0b1	a0b1	a5 40		lda $40				lda 	EXTAddress
.c0b3	a0b3	6d c4 07	adc $07c4			adc 	EXTScreenWidth
.c0b6	a0b6	85 40		sta $40				sta 	EXTAddress
.c0b8	a0b8	90 db		bcc $a095			bcc 	EXPCExit
.c0ba	a0ba	e6 41		inc $41				inc 	EXTAddress+1
.c0bc	a0bc	80 d7		bra $a095			bra 	EXPCExit
.c0be	a0be					EXPCTab:
.c0be	a0be	ad c2 07	lda $07c2			lda 	EXTColumn 					; next tab stop
.c0c1	a0c1	29 f8		and #$f8			and 	#$F8
.c0c3	a0c3	18		clc				clc
.c0c4	a0c4	69 08		adc #$08			adc 	#8
.c0c6	a0c6	8d c2 07	sta $07c2			sta 	EXTColumn
.c0c9	a0c9	cd c4 07	cmp $07c4			cmp 	EXTScreenWidth 				; too far, stick end of line.
.c0cc	a0cc	90 c7		bcc $a095			bcc 	EXPCExit
.c0ce	a0ce	80 10		bra $a0e0			bra 	EXPCEnd
.c0d0	a0d0					EXPCBackSpace:
.c0d0	a0d0	88		dey				dey
.c0d1	a0d1	30 c2		bmi $a095			bmi 	EXPCExit
.c0d3	a0d3	ce c2 07	dec $07c2			dec 	EXTColumn
.c0d6	a0d6	a9 02		lda #$02			lda 	#2
.c0d8	a0d8	85 01		sta $01				sta 	1
.c0da	a0da	a9 20		lda #$20			lda 	#32
.c0dc	a0dc	91 40		sta ($40),y			sta 	(EXTAddress),y
.c0de	a0de	80 b5		bra $a095			bra 	EXPCExit
.c0e0	a0e0					EXPCEnd:
.c0e0	a0e0	a9 02		lda #$02			lda 	#2 							; access text screen
.c0e2	a0e2	85 01		sta $01				sta 	1
.c0e4	a0e4	ac c4 07	ldy $07c4			ldy 	EXTScreenWidth 				; point to last character
.c0e7	a0e7	88		dey				dey
.c0e8	a0e8					EXPCEndSearch:
.c0e8	a0e8	88		dey				dey 								; if past start, move to col 0.
.c0e9	a0e9	30 06		bmi $a0f1			bmi 	EXPCFound
.c0eb	a0eb	b1 40		lda ($40),y			lda 	(EXTAddress),y 				; keep going back till non space found
.c0ed	a0ed	c9 20		cmp #$20			cmp 	#' '
.c0ef	a0ef	f0 f7		beq $a0e8			beq 	EXPCEndSearch
.c0f1	a0f1					EXPCFound:
.c0f1	a0f1	c8		iny				iny 								; move to following cell.
.c0f2	a0f2	80 9e		bra $a092			bra 	EXPCSetColumnY
.c0f4	a0f4					EXPCClearEOL:
.c0f4	a0f4	a9 02		lda #$02			lda 	#2 							; access character RAM
.c0f6	a0f6	85 01		sta $01				sta 	1
.c0f8	a0f8	a9 20		lda #$20			lda 	#' ' 						; write space
.c0fa	a0fa	91 40		sta ($40),y			sta 	(EXTAddress),y
.c0fc	a0fc	c8		iny				iny
.c0fd	a0fd	cc c4 07	cpy $07c4			cpy 	EXTScreenWidth 				; until RHS of screen.
.c100	a100	90 f2		bcc $a0f4			bcc 	EXPCClearEOL
.c102	a102	80 91		bra $a095			bra 	EXPCExit
.c104	a104					EXPCActionTable:
>c104	a104	95 a0						.word 	EXPCExit 					; 00
>c106	a106	53 a0						.word 	EXPCBegin 					; 01 A Start of Line
>c108	a108	4e a0						.word 	EXPCLeft 					; 02 B Left
>c10a	a10a	95 a0						.word 	EXPCExit 					; 03 <Break>
>c10c	a10c	95 a0						.word 	EXPCExit 					; 04
>c10e	a10e	e0 a0						.word 	EXPCEnd 					; 05 E End of Line
>c110	a110	88 a0						.word 	EXPCRight 					; 06 F Right
>c112	a112	95 a0						.word 	EXPCExit 					; 07
>c114	a114	d0 a0						.word 	EXPCBackSpace 				; 08 H Backspace
>c116	a116	be a0						.word 	EXPCTab 					; 09 I Tab
>c118	a118	95 a0						.word 	EXPCExit 					; 0A
>c11a	a11a	f4 a0						.word 	EXPCClearEOL 				; 0B K Clear to EOL
>c11c	a11c	9f a0						.word 	EXPCClearScreen			; 0C L CLS
>c11e	a11e	32 a0						.word 	EXPCCRLF 					; 0D M CR/LF
>c120	a120	a4 a0						.word 	EXPCDown 					; 0E N Down
>c122	a122	95 a0						.word 	EXPCExit 					; 0F
>c124	a124	72 a0						.word 	EXPCUp 					; 10 P Up
.c126	a126					EXPCHandleColour:
.c126	a126	c9 90		cmp #$90			cmp 	#$90 						; 8x foreground 9x background
.c128	a128	b0 16		bcs $a140			bcs 	EXPCBackground
.c12a	a12a	0a		asl a				asl 	a 							; shift it 4 bits to the right.
.c12b	a12b	0a		asl a				asl 	a
.c12c	a12c	0a		asl a				asl 	a
.c12d	a12d	0a		asl a				asl 	a
.c12e	a12e	a2 0f		ldx #$0f			ldx 	#$0F 						; Mask in X
.c130	a130					EXPCUpdate:
.c130	a130	48		pha				pha 								; save new colour
.c131	a131	8a		txa				txa 								; get mask
.c132	a132	2d c3 07	and $07c3			and 	EXTTextColour 				; mask out old.
.c135	a135	8d c3 07	sta $07c3			sta 	EXTTextColour
.c138	a138	68		pla				pla 								; or in new colour
.c139	a139	0d c3 07	ora $07c3			ora 	EXTTextColour
.c13c	a13c	8d c3 07	sta $07c3			sta 	EXTTextColour
.c13f	a13f	60		rts				rts
.c140	a140					EXPCBackground:
.c140	a140	29 0f		and #$0f			and 	#$0F 						; get the colour
.c142	a142	a2 f0		ldx #$f0			ldx 	#$F0 						; mask
.c144	a144	80 ea		bra $a130			bra 	EXPCUpdate
.c146	a146					EXTScreenScroll:
.c146	a146	a9 02		lda #$02			lda 	#2 							; select text page
.c148	a148	85 01		sta $01				sta 	1
.c14a	a14a	a9 20		lda #$20			lda		#32 						; fill with space
.c14c	a14c	20 a2 a2	jsr $a2a2			jsr 	EXTScrollFill
.c14f	a14f	e6 01		inc $01				inc 	1 							; select colour page
.c151	a151	ad c3 07	lda $07c3			lda 	EXTTextColour
.c154	a154	20 a2 a2	jsr $a2a2			jsr 	EXTScrollFill
.c157	a157	60		rts				rts
.c158	a158					PAGEDPrintHex:
.c158	a158	48		pha				pha
.c159	a159	a9 20		lda #$20			lda 	#' '
.c15b	a15b	20 0b a0	jsr $a00b			jsr 	PAGEDPrintCharacter
.c15e	a15e	68		pla				pla
.c15f	a15f	48		pha				pha
.c160	a160	4a		lsr a				lsr 	a
.c161	a161	4a		lsr a				lsr 	a
.c162	a162	4a		lsr a				lsr 	a
.c163	a163	4a		lsr a				lsr 	a
.c164	a164	20 68 a1	jsr $a168			jsr 	_PPHNibble
.c167	a167	68		pla				pla
.c168	a168					_PPHNibble:
.c168	a168	48		pha				pha
.c169	a169	29 0f		and #$0f			and 	#15
.c16b	a16b	c9 0a		cmp #$0a			cmp 	#10
.c16d	a16d	90 02		bcc $a171			bcc 	_PPHOut
.c16f	a16f	69 06		adc #$06			adc 	#6
.c171	a171	69 30		adc #$30	_PPHOut:adc 	#48
.c173	a173	20 0b a0	jsr $a00b			jsr		PAGEDPrintCharacter
.c176	a176	68		pla				pla
.c177	a177	60		rts				rts
.c178	a178					EXTClearScreenCode:
.c178	a178	a9 02		lda #$02			lda 	#2 							; select text page
.c17a	a17a	85 01		sta $01				sta 	1
.c17c	a17c	a9 20		lda #$20			lda		#32 						; fill with space
.c17e	a17e	20 8b a1	jsr $a18b			jsr 	_EXTCSFill
.c181	a181	e6 01		inc $01				inc 	1 							; select colour page
.c183	a183	ad c3 07	lda $07c3			lda 	EXTTextColour
.c186	a186	20 8b a1	jsr $a18b			jsr 	_EXTCSFill
.c189	a189	80 22		bra $a1ad			bra 	EXTHomeCursor
.c18b	a18b					_EXTCSFill:
.c18b	a18b	aa		tax				tax
.c18c	a18c	a9 00		lda #$00			lda 	#EXTMemory & $FF
.c18e	a18e	85 40		sta $40				sta 	EXTAddress
.c190	a190	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.c192	a192	85 41		sta $41				sta 	EXTAddress+1
.c194	a194					_EXTCSFill1:
.c194	a194	a0 00		ldy #$00			ldy 	#0
.c196	a196	8a		txa				txa
.c197	a197					_EXTCSFill2:
.c197	a197	91 40		sta ($40),y			sta 	(EXTAddress),y
.c199	a199	c8		iny				iny
.c19a	a19a	d0 fb		bne $a197			bne 	_EXTCSFill2
.c19c	a19c	e6 41		inc $41				inc 	EXTAddress+1
.c19e	a19e	a5 41		lda $41				lda 	EXTAddress+1
.c1a0	a1a0	c9 d2		cmp #$d2			cmp 	#$D2
.c1a2	a1a2	d0 f0		bne $a194			bne 	_EXTCSFill1
.c1a4	a1a4	8a		txa				txa
.c1a5	a1a5					_EXTCSFill3:
.c1a5	a1a5	91 40		sta ($40),y			sta 	(EXTAddress),y
.c1a7	a1a7	c8		iny				iny
.c1a8	a1a8	c0 c0		cpy #$c0			cpy 	#$C0
.c1aa	a1aa	d0 f9		bne $a1a5			bne 	_EXTCSFill3
.c1ac	a1ac	60		rts				rts
.c1ad	a1ad					EXTHomeCursor:
.c1ad	a1ad	9c c1 07	stz $07c1			stz 	EXTRow 						; reset row & column
.c1b0	a1b0	9c c2 07	stz $07c2			stz 	EXTColumn
.c1b3	a1b3	a9 00		lda #$00			lda 	#EXTMemory & $FF 			; set address
.c1b5	a1b5	85 40		sta $40				sta 	EXTAddress
.c1b7	a1b7	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.c1b9	a1b9	85 41		sta $41				sta 	EXTAddress+1
.c1bb	a1bb					EXTSetHardwareCursor:
.c1bb	a1bb	64 01		stz $01				stz 	1 							; I/O Page zero
.c1bd	a1bd	a9 05		lda #$05			lda 	#1+4 						; enable cursor
.c1bf	a1bf	8d 10 d0	sta $d010			sta 	$D010
.c1c2	a1c2	a9 d6		lda #$d6			lda 	#214
.c1c4	a1c4	8d 12 d0	sta $d012			sta 	$D012
.c1c7	a1c7	ad c2 07	lda $07c2			lda 	EXTColumn
.c1ca	a1ca	8d 14 d0	sta $d014			sta 	$D014 						; set cursor position
.c1cd	a1cd	9c 15 d0	stz $d015			stz 	$D015
.c1d0	a1d0	ad c1 07	lda $07c1			lda 	EXTRow
.c1d3	a1d3	8d 16 d0	sta $d016			sta 	$D016
.c1d6	a1d6	9c 17 d0	stz $d017			stz 	$D017
.c1d9	a1d9	60		rts				rts
=$c000						EXTMemory = $C000
=$02						EXTTextPage = $02
=$03						EXTColourPage = $03
=1						EXTDummySpace = 1 							; fake-space for CR character.
=0						EXTCBlack = 0
.07c1						EXTRow:
>07c1								.fill 	1
.07c2						EXTColumn:
>07c2								.fill 	1
.07c3						EXTTextColour:
>07c3								.fill 	1
.07c4						EXTScreenWidth:
>07c4								.fill 	1
.07c5						EXTScreenHeight:
>07c5								.fill 	1
.0040						EXTAddress:
>0040								.fill 	2
.c1da	a1da					Export_EXTInitialise:
.c1da	a1da	64 01		stz $01				stz 	1 							; Access I/O page 0
.c1dc	a1dc	9c 04 d0	stz $d004			stz 	$D004 						; Disable border
.c1df	a1df	9c 08 d0	stz $d008			stz 	$D008
.c1e2	a1e2	9c 09 d0	stz $d009			stz 	$D009
.c1e5	a1e5	a9 09		lda #$09			lda 	#1+8						; Timer On at 70Hz counting up.
.c1e7	a1e7	8d 58 d6	sta $d658			sta 	$D658
.c1ea	a1ea	a9 52		lda #$52			lda 	#$52
.c1ec	a1ec	8d c3 07	sta $07c3			sta 	EXTTextColour
.c1ef	a1ef	a9 50		lda #$50			lda 	#80 						; set screen dimensions.
.c1f1	a1f1	8d c4 07	sta $07c4			sta 	EXTScreenWidth
.c1f4	a1f4	a9 3c		lda #$3c			lda 	#60
.c1f6	a1f6	8d c5 07	sta $07c5			sta 	EXTScreenHeight
.c1f9	a1f9	20 78 a1	jsr $a178			jsr 	EXTClearScreenCode 			; clear the screen
.c1fc	a1fc					_EXMoveDown:
.c1fc	a1fc	a9 0d		lda #$0d			lda 	#13
.c1fe	a1fe	20 0b a0	jsr $a00b			jsr 	PAGEDPrintCharacter
.c201	a201	ad c1 07	lda $07c1			lda 	EXTRow
.c204	a204	c9 0a		cmp #$0a			cmp 	#Header_Height-4
.c206	a206	d0 f4		bne $a1fc			bne 	_EXMoveDown
.c208	a208	20 0e a2	jsr $a20e			jsr 	EXTShowHeader
.c20b	a20b	64 01		stz $01				stz 	1
.c20d	a20d	60		rts				rts
.c20e	a20e					EXTShowHeader:
.c20e	a20e	a5 01		lda $01				lda 	1
.c210	a210	48		pha				pha
.c211	a211	a5 0b		lda $0b				lda 	8+3
.c213	a213	48		pha				pha
.c214	a214	a5 0c		lda $0c				lda 	8+4
.c216	a216	18		clc				clc
.c217	a217	69 03		adc #$03			adc 	#3
.c219	a219	85 0b		sta $0b				sta 	8+3
.c21b	a21b	a2 b2		ldx #$b2			ldx 	#(Header_jchars & $FF)
.c21d	a21d	a0 61		ldy #$61			ldy 	#(Header_jchars >> 8)-$40
.c21f	a21f	64 01		stz $01				stz 	1
.c221	a221	ad a7 d6	lda $d6a7			lda 	$D6A7
.c224	a224	29 10		and #$10			and 	#$10
.c226	a226	f0 04		beq $a22c			beq 	_EXTSHNotK1
.c228	a228	a2 b0		ldx #$b0			ldx 	#(Header_kchars & $FF)
.c22a	a22a	a0 65		ldy #$65			ldy 	#(Header_kchars >> 8)-$40
.c22c	a22c					_EXTSHNotK1:
.c22c	a22c	a9 02		lda #$02			lda 	#2
.c22e	a22e	20 5c a2	jsr $a25c			jsr 	_ESHCopyBlock
.c231	a231	a2 00		ldx #$00			ldx 	#(Header_jattrs & $FF)
.c233	a233	a0 60		ldy #$60			ldy 	#(Header_jattrs >> 8)-$40
.c235	a235	64 01		stz $01				stz 	1
.c237	a237	ad a7 d6	lda $d6a7			lda 	$D6A7
.c23a	a23a	29 10		and #$10			and 	#$10
.c23c	a23c	f0 04		beq $a242			beq 	_EXTSHNotK2
.c23e	a23e	a2 e2		ldx #$e2			ldx 	#(Header_kattrs & $FF)
.c240	a240	a0 63		ldy #$63			ldy 	#(Header_kattrs >> 8)-$40
.c242	a242					_EXTSHNotK2:
.c242	a242	a9 03		lda #$03			lda 	#3
.c244	a244	20 5c a2	jsr $a25c			jsr 	_ESHCopyBlock
.c247	a247	64 01		stz $01				stz 	1
.c249	a249	a2 3f		ldx #$3f			ldx 	#16*4-1
.c24b	a24b					_EXTCopyLUT:
.c24b	a24b	bd b2 67	lda $67b2,x			lda 	Header_Palette-$4000,x
.c24e	a24e	9d 00 d8	sta $d800,x			sta 	$D800,x
.c251	a251	9d 40 d8	sta $d840,x			sta 	$D840,x
.c254	a254	ca		dex				dex
.c255	a255	10 f4		bpl $a24b			bpl 	_EXTCopyLUT
.c257	a257	68		pla				pla
.c258	a258	85 0b		sta $0b				sta 	8+3
.c25a	a25a	68		pla				pla
.c25b	a25b	60		rts				rts
.c25c	a25c					_ESHCopyBlock:
.c25c	a25c	85 01		sta $01				sta 	1
.c25e	a25e	86 36		stx $36				stx 	zTemp0 						; zTemp0 is RLE packed data
.c260	a260	84 37		sty $37				sty 	zTemp0+1
.c262	a262	a9 00		lda #$00			lda 	#(($C000) & $FF)
.c264	a264	85 38		sta $38				sta 	0+zTemp1
.c266	a266	a9 c0		lda #$c0			lda 	#(($C000) >> 8)
.c268	a268	85 39		sta $39				sta 	1+zTemp1
.c26a	a26a					_ESHCopyLoop:
.c26a	a26a	b2 36		lda ($36)			lda 	(zTemp0) 					; get next character
.c26c	a26c	c9 ff		cmp #$ff			cmp 	#Header_RLE 				; packed ?
.c26e	a26e	f0 1b		beq $a28b			beq 	_ESHUnpack
.c270	a270	92 38		sta ($38)			sta 	(zTemp1) 					; copy it out.
.c272	a272	a9 01		lda #$01			lda 	#1 							; source add 1
.c274	a274	a0 01		ldy #$01			ldy 	#1 							; dest add 1
.c276	a276					_ESHNext:
.c276	a276	18		clc				clc 								; zTemp0 + A
.c277	a277	65 36		adc $36				adc 	zTemp0
.c279	a279	85 36		sta $36				sta 	zTemp0
.c27b	a27b	90 02		bcc $a27f			bcc 	_ESHNoCarry
.c27d	a27d	e6 37		inc $37				inc 	zTemp0+1
.c27f	a27f					_ESHNoCarry:
.c27f	a27f	98		tya				tya 								; zTemp1 + Y
.c280	a280	18		clc				clc
.c281	a281	65 38		adc $38				adc 	zTemp1
.c283	a283	85 38		sta $38				sta 	zTemp1
.c285	a285	90 e3		bcc $a26a			bcc 	_ESHCopyLoop
.c287	a287	e6 39		inc $39				inc 	zTemp1+1
.c289	a289	80 df		bra $a26a			bra 	_ESHCopyLoop
.c28b	a28b					_ESHUnpack:
.c28b	a28b	a0 02		ldy #$02			ldy 	#2 							; get count into X
.c28d	a28d	b1 36		lda ($36),y			lda 	(zTemp0),y
.c28f	a28f	aa		tax				tax
.c290	a290	88		dey				dey 								; byte into A
.c291	a291	b1 36		lda ($36),y			lda 	(zTemp0),y
.c293	a293	f0 0c		beq $a2a1			beq 	_ESHExit 					; exit if zero.
.c295	a295	a0 00		ldy #$00			ldy 	#0 							; copy start position
.c297	a297					_ESHCopyOut:
.c297	a297	91 38		sta ($38),y			sta 	(zTemp1),y
.c299	a299	c8		iny				iny
.c29a	a29a	ca		dex				dex
.c29b	a29b	d0 fa		bne $a297			bne 	_ESHCopyOut
.c29d	a29d	a9 03		lda #$03			lda 	#3 							; Y is bytes on screen, 3 bytes from source
.c29f	a29f	80 d5		bra $a276			bra 	_ESHNext
.c2a1	a2a1					_ESHExit:
.c2a1	a2a1	60		rts				rts
.c2a2	a2a2					EXTScrollFill:
.c2a2	a2a2	aa		tax				tax									; save value to fill with
.c2a3	a2a3	a5 36		lda $36				lda 	zTemp0 						; save zTemp0 (dest) zTemp1 (src)
.c2a5	a2a5	48		pha				pha
.c2a6	a2a6	a5 37		lda $37				lda 	zTemp0+1
.c2a8	a2a8	48		pha				pha
.c2a9	a2a9	a5 38		lda $38				lda 	zTemp1
.c2ab	a2ab	48		pha				pha
.c2ac	a2ac	a5 39		lda $39				lda 	zTemp1+1
.c2ae	a2ae	48		pha				pha
.c2af	a2af	a9 c0		lda #$c0			lda 	#$C0 						; copy from C000+length to C000
.c2b1	a2b1	85 37		sta $37				sta 	zTemp0+1
.c2b3	a2b3	85 39		sta $39				sta 	zTemp1+1
.c2b5	a2b5	64 36		stz $36				stz 	zTemp0
.c2b7	a2b7	ad c4 07	lda $07c4			lda 	EXTScreenWidth
.c2ba	a2ba	85 38		sta $38				sta 	zTemp1
.c2bc	a2bc	a0 00		ldy #$00			ldy 	#0
.c2be	a2be					_EXSFCopy1:
.c2be	a2be	b1 38		lda ($38),y			lda 	(zTemp1),y
.c2c0	a2c0	91 36		sta ($36),y			sta 	(zTemp0),y
.c2c2	a2c2	c8		iny				iny
.c2c3	a2c3	d0 f9		bne $a2be			bne 	_EXSFCopy1
.c2c5	a2c5	e6 37		inc $37				inc 	zTemp0+1 					; next page
.c2c7	a2c7	e6 39		inc $39				inc 	zTemp1+1
.c2c9	a2c9	a5 39		lda $39				lda 	zTemp1+1
.c2cb	a2cb	c9 d3		cmp #$d3			cmp 	#$D3
.c2cd	a2cd	d0 ef		bne $a2be			bne 	_EXSFCopy1
.c2cf	a2cf	ac c4 07	ldy $07c4			ldy 	EXTScreenWidth 				; blank the bottom line.
.c2d2	a2d2	8a		txa				txa
.c2d3	a2d3					_EXSFFill1:
.c2d3	a2d3	88		dey				dey
.c2d4	a2d4	91 40		sta ($40),y			sta 	(EXTAddress),y
.c2d6	a2d6	c0 00		cpy #$00			cpy 	#0
.c2d8	a2d8	10 f9		bpl $a2d3			bpl 	_EXSFFill1
.c2da	a2da	68		pla				pla
.c2db	a2db	85 39		sta $39				sta 	zTemp1+1
.c2dd	a2dd	68		pla				pla
.c2de	a2de	85 38		sta $38				sta 	zTemp1
.c2e0	a2e0	68		pla				pla
.c2e1	a2e1	85 37		sta $37				sta 	zTemp0+1
.c2e3	a2e3	68		pla				pla
.c2e4	a2e4	85 36		sta $36				sta 	zTemp0
.c2e6	a2e6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_graphics.module

=1						graphicsIntegrated=1
=0						GCMD_Initialise = 0*2
=2						GCMD_BitmapCtl = 1*2
=4						GCMD_SpriteCtl = 2*2
=6						GCMD_Clear = 3*2
=8						GCMD_Colour = 4*2
=10						GCMD_DrawFont = 5*2
=12						GCMD_DrawSprite = 6*2
=14						GCMD_SpriteUse = 7*2
=16						GCMD_SpriteImage = 8*2
=18						GCMD_SpriteCollide = 9*2
=64						GCMD_Move = 32*2
=66						GCMD_Line = 33*2
=68						GCMD_FrameRect = 34*2
=70						GCMD_FillRect = 35*2
=72						GCMD_FrameCircle = 36*2
=74						GCMD_FillCircle = 37*2
=80						GCMD_Plot = 40*2
=82						GCMD_SpriteMove = 41*2
=42						GRFirstFreeCode = 42
.c2e7	a2e7					GRVectorTable:
>c2e7	a2e7	36 a5					.word	GXInitialise             ; $00 Initialise
>c2e9	a2e9	50 a5					.word	GXControlBitmap          ; $01 BitmapCtl
>c2eb	a2eb	98 a5					.word	GXControlSprite          ; $02 SpriteCtl
>c2ed	a2ed	e8 a4					.word	GXClearBitmap            ; $03 Clear
>c2ef	a2ef	27 a7					.word	GXSetColourMode          ; $04 Colour
>c2f1	a2f1	ef a8					.word	GXFontHandler            ; $05 DrawFont
>c2f3	a2f3	37 a9					.word	GXSpriteHandler          ; $06 DrawSprite
>c2f5	a2f5	a8 a9					.word	GXSelect                 ; $07 SpriteUse
>c2f7	a2f7	d1 a9					.word	GXSelectImage            ; $08 SpriteImage
>c2f9	a2f9	58 ab					.word	GXCollide                ; $09 SpriteCollide
>c2fb	a2fb	9a a3					.word	GRUndefined              ; $0a
>c2fd	a2fd	9a a3					.word	GRUndefined              ; $0b
>c2ff	a2ff	9a a3					.word	GRUndefined              ; $0c
>c301	a301	9a a3					.word	GRUndefined              ; $0d
>c303	a303	9a a3					.word	GRUndefined              ; $0e
>c305	a305	9a a3					.word	GRUndefined              ; $0f
>c307	a307	9a a3					.word	GRUndefined              ; $10
>c309	a309	9a a3					.word	GRUndefined              ; $11
>c30b	a30b	9a a3					.word	GRUndefined              ; $12
>c30d	a30d	9a a3					.word	GRUndefined              ; $13
>c30f	a30f	9a a3					.word	GRUndefined              ; $14
>c311	a311	9a a3					.word	GRUndefined              ; $15
>c313	a313	9a a3					.word	GRUndefined              ; $16
>c315	a315	9a a3					.word	GRUndefined              ; $17
>c317	a317	9a a3					.word	GRUndefined              ; $18
>c319	a319	9a a3					.word	GRUndefined              ; $19
>c31b	a31b	9a a3					.word	GRUndefined              ; $1a
>c31d	a31d	9a a3					.word	GRUndefined              ; $1b
>c31f	a31f	9a a3					.word	GRUndefined              ; $1c
>c321	a321	9a a3					.word	GRUndefined              ; $1d
>c323	a323	9a a3					.word	GRUndefined              ; $1e
>c325	a325	9a a3					.word	GRUndefined              ; $1f
>c327	a327	98 a3					.word	GXMove                   ; $20 Move
>c329	a329	f5 a5					.word	GXLine                   ; $21 Line
>c32b	a32b	70 a7					.word	GXFrameRectangle         ; $22 FrameRect
>c32d	a32d	6d a7					.word	GXFillRectangle          ; $23 FillRect
>c32f	a32f	9f a3					.word	GXFrameCircle            ; $24 FrameCircle
>c331	a331	9b a3					.word	GXFillCircle             ; $25 FillCircle
>c333	a333	9a a3					.word	GRUndefined              ; $26
>c335	a335	9a a3					.word	GRUndefined              ; $27
>c337	a337	55 a7					.word	GXPlotPoint              ; $28 Plot
>c339	a339	67 aa					.word	GXMoveSprite             ; $29 SpriteMove
=3						GXMappingPage = 3
=24576						GXMappingAddress = ($2000 * GXMappingPage)
=11						GXEditSlot = 8 + GXMappingPage
=$36						gxzTemp0 = zTemp0
=$38						gxzTemp1 = zTemp1
=$3a						gxzTemp2 = zTemp2
=$3c						gxzScreen = zsTemp
=$623						gxPixelBuffer = numberBuffer
.07c6						gxCurrentX:
>07c6								.fill 	2
.07c8						gxCurrentY:
>07c8								.fill 	2
.07ca						gxLastX:
>07ca								.fill 	2
.07cc						gxLastY:
>07cc								.fill 	2
.07ce						gxX0:
>07ce								.fill 	2
.07d0						gxY0:
>07d0								.fill 	2
.07d2						gxX1:
>07d2								.fill 	2
.07d4						gxY1:
>07d4								.fill 	2
.07d6						gxSpritesOn:
>07d6								.fill 	1
.07d7						gxBitmapsOn:
>07d7								.fill 	1
.07d8						gxBasePage:
>07d8								.fill 	1
.07d9						gxSpritePage:
>07d9								.fill 	1
.07da						gxHeight:
>07da								.fill 	1
.07db						gxMode:
>07db								.fill 	1
.07dc						gxColour:
>07dc								.fill 	1
.07dd						gxEORValue:
>07dd								.fill 	1
.07de						gxANDValue:
>07de								.fill 	1
.07df						gxOriginalLUTValue:
>07df								.fill 	1
.07e0						gxOffset:
>07e0								.fill 	1
.07e1						GSCurrentSpriteID:
>07e1								.fill 	1
.07e2						GSCurrentSpriteAddr:
>07e2								.fill 	2
.07e4						gxSpriteOffsetBase:
>07e4								.fill 	2
.07e6						gxSpriteLow:
>07e6								.fill 	64
.0826						gxSpriteHigh:
>0826								.fill 	64
.c33b	a33b					Export_GXGraphicDraw:
.c33b	a33b	c9 40		cmp #$40			cmp 	#GCMD_Move					; low instructions don't use coordinates
.c33d	a33d	b0 06		bcs $a345			bcs 	_GDCoordinate
.c33f	a33f	86 36		stx $36				stx 	gxzTemp0 					; save X/Y
.c341	a341	84 37		sty $37				sty 	gxzTemp0+1
.c343	a343	80 4b		bra $a390			bra 	_GDExecuteA 				; and execute
.c345	a345					_GDCoordinate:
.c345	a345	48		pha				pha 								; save AXY
.c346	a346	da		phx				phx
.c347	a347	5a		phy				phy
.c348	a348	a2 03		ldx #$03			ldx 	#3 							; copy currentX to lastX
.c34a	a34a					_GDCopy1:
.c34a	a34a	bd c6 07	lda $07c6,x			lda 	gxCurrentX,x
.c34d	a34d	9d ca 07	sta $07ca,x			sta 	gxLastX,x
.c350	a350	ca		dex				dex
.c351	a351	10 f7		bpl $a34a			bpl 	_GDCopy1
.c353	a353	68		pla				pla 								; update Y
.c354	a354	8d c8 07	sta $07c8			sta 	gxCurrentY
.c357	a357	9c c9 07	stz $07c9			stz 	gxCurrentY+1
.c35a	a35a	68		pla				pla
.c35b	a35b	8d c6 07	sta $07c6			sta 	gxCurrentX
.c35e	a35e	68		pla				pla 								; get A (command+X.1) back
.c35f	a35f	48		pha				pha
.c360	a360	29 01		and #$01			and 	#1 							; put LSB as MSB of Current.X
.c362	a362	8d c7 07	sta $07c7			sta 	gxCurrentX+1
.c365	a365	68		pla				pla 								; get command back
.c366	a366	29 fe		and #$fe			and 	#$FE 						; lose LSB, chuck the stray X bit
.c368	a368	48		pha				pha 								; push back.
.c369	a369	c9 52		cmp #$52			cmp 	#GCMD_SpriteMove 			; move sprite does not clip.
.c36b	a36b	f0 17		beq $a384			beq 	_GDCopyToWorkArea
.c36d	a36d	ad c7 07	lda $07c7			lda 	gxCurrentX+1 				; X < 256 X okay
.c370	a370	f0 07		beq $a379			beq 	_GDCheckY
.c372	a372	ad c6 07	lda $07c6			lda 	gxCurrentX 					; otherwise X < 320 = 256 + 64
.c375	a375	c9 40		cmp #$40			cmp 	#64
.c377	a377	b0 08		bcs $a381			bcs 	_GDError1
.c379	a379					_GDCheckY:
.c379	a379	ad c8 07	lda $07c8			lda 	gxCurrentY 					; check Y < Height.
.c37c	a37c	cd da 07	cmp $07da			cmp 	gxHeight
.c37f	a37f	90 03		bcc $a384			bcc 	_GDCopyToWorkArea
.c381	a381					_GDError1:
.c381	a381	68		pla				pla
.c382	a382					_GDError2:
.c382	a382	38		sec				sec
.c383	a383	60		rts				rts
.c384	a384					_GDCopyToWorkArea:
.c384	a384	a2 07		ldx #$07			ldx 	#7 							; copy current and last to gxXY/12 work area
.c386	a386					_GDCopy2:
.c386	a386	bd c6 07	lda $07c6,x			lda 	gxCurrentX,x
.c389	a389	9d ce 07	sta $07ce,x			sta 	gxX0,x
.c38c	a38c	ca		dex				dex
.c38d	a38d	10 f7		bpl $a386			bpl 	_GDCopy2
.c38f	a38f	68		pla				pla 								; get command
.c390	a390					_GDExecuteA:
.c390	a390	c9 54		cmp #$54			cmp 	#GRFirstFreeCode*2 			; bad ?
.c392	a392	b0 ee		bcs $a382			bcs 	_GDError2
.c394	a394	aa		tax				tax
.c395	a395	7c e7 a2	jmp ($a2e7,x)			jmp 	(GRVectorTable,x)
.c398	a398					GXMove:
.c398	a398	18		clc				clc
.c399	a399	60		rts				rts
.c39a	a39a					GRUndefined:
>c39a	a39a	db						.byte 	$DB 						; causes a break in the emulator
.c39b	a39b					GXFillCircle:
.c39b	a39b	a9 ff		lda #$ff			lda 	#255
.c39d	a39d	80 02		bra $a3a1			bra 	GXCircle
.c39f	a39f					GXFrameCircle:
.c39f	a39f	a9 00		lda #$00			lda 	#0
.c3a1	a3a1					GXCircle:
.c3a1	a3a1	8d 69 08	sta $0869			sta 	gxIsFillMode					; save Fill flag
.c3a4	a3a4	ad d7 07	lda $07d7			lda 	gxBitmapsOn
.c3a7	a3a7	f0 26		beq $a3cf			beq 	_GXCFail
.c3a9	a3a9	20 ff ab	jsr $abff			jsr 	GXSortXY 					; topleft/bottomright
.c3ac	a3ac	20 d7 aa	jsr $aad7			jsr 	GXOpenBitmap 				; start drawing
.c3af	a3af	20 a1 a4	jsr $a4a1			jsr 	GXCircleSetup 				; set up for drawing
.c3b2	a3b2	9c 6a 08	stz $086a			stz 	gxYChanged
.c3b5	a3b5					_GXCircleDraw:
.c3b5	a3b5	ad 67 08	lda $0867			lda 	gxxCentre					; while x <= y
.c3b8	a3b8	cd 68 08	cmp $0868			cmp 	gxYCentre
.c3bb	a3bb	90 0a		bcc $a3c7			bcc 	_GXCircleContinue
.c3bd	a3bd	d0 03		bne $a3c2			bne 	_GXNoLast
.c3bf	a3bf	20 d4 a3	jsr $a3d4			jsr 	GXPlot1
.c3c2	a3c2					_GXNoLast:
.c3c2	a3c2	20 df aa	jsr $aadf			jsr 	GXCloseBitmap 				; close the bitmap
.c3c5	a3c5	18		clc				clc
.c3c6	a3c6	60		rts				rts
.c3c7	a3c7					_GXCircleContinue:
.c3c7	a3c7	20 d1 a3	jsr $a3d1			jsr 	GXPlot2 					; draw it
.c3ca	a3ca	20 4e a4	jsr $a44e			jsr 	GXCircleMove 				; adjust the coordinates
.c3cd	a3cd	80 e6		bra $a3b5			bra 	_GXCircleDraw
.c3cf	a3cf					_GXCFail:
.c3cf	a3cf	38		sec				sec
.c3d0	a3d0	60		rts				rts
.c3d1	a3d1					GXPlot2:
.c3d1	a3d1	20 d4 a3	jsr $a3d4			jsr 	GXPlot1 						; plot and swap, fall through does twice
.c3d4	a3d4					GXPlot1:
.c3d4	a3d4	ad 68 08	lda $0868			lda 	gxYCentre 						; if y = 0, don't do it twice (xor)
.c3d7	a3d7	f0 03		beq $a3dc			beq 	_GXPlot1Only
.c3d9	a3d9	20 f8 a3	jsr $a3f8			jsr 	GXPlot0 						; plot and negate
.c3dc	a3dc					_GXPlot1Only:
.c3dc	a3dc	20 f8 a3	jsr $a3f8			jsr 	GXPlot0 						; twice, undoing negation
.c3df	a3df	ad 67 08	lda $0867			lda 	gxxCentre 						; swap X and Y
.c3e2	a3e2	ae 68 08	ldx $0868			ldx	 	gxYCentre
.c3e5	a3e5	8d 68 08	sta $0868			sta 	gxYCentre
.c3e8	a3e8	8e 67 08	stx $0867			stx 	gxxCentre
.c3eb	a3eb	ad 6a 08	lda $086a			lda 	gxYChanged 						; toggle Y Changed flag
.c3ee	a3ee	a9 ff		lda #$ff			lda 	#$FF
.c3f0	a3f0	8d 6a 08	sta $086a			sta 	gxYChanged
.c3f3	a3f3	60		rts				rts
.c3f4	a3f4	20 f8 a3	jsr $a3f8			jsr 	GXPlot0 						; do once
.c3f7	a3f7	60		rts				rts
.c3f8	a3f8	ad 69 08	lda $0869	GXPlot0:lda 	gxIsFillMode 					; outline mode, always draw as X or Y will change
.c3fb	a3fb	f0 05		beq $a402			beq 	_GXPlot0Always
.c3fd	a3fd	ad 6a 08	lda $086a			lda 	gxYChanged						; fill mode, only draw if changed.
.c400	a400	f0 2d		beq $a42f			beq 	GXPlot0Exit
.c402	a402					_GXPlot0Always:
.c402	a402	a2 02		ldx #$02			ldx 	#2 								; copy Y1-A => Y0
.c404	a404	ad 68 08	lda $0868			lda 	gxYCentre
.c407	a407	20 30 a4	jsr $a430			jsr 	GXSubCopy
.c40a	a40a	a2 00		ldx #$00			ldx 	#0 								; copy X1-A => X0,
.c40c	a40c	ad 67 08	lda $0867			lda 	gxxCentre
.c40f	a40f	20 30 a4	jsr $a430			jsr 	GXSubCopy
.c412	a412	48		pha				pha 									; save last offset X
.c413	a413	20 e7 aa	jsr $aae7			jsr 	gxPositionCalc 					; calculate position/offset.
.c416	a416	68		pla				pla
.c417	a417	0a		asl a				asl 	a 								; store 2 x last offset in gxzTemp0
.c418	a418	85 36		sta $36				sta 	gxzTemp0
.c41a	a41a	64 37		stz $37				stz 	gxzTemp0+1
.c41c	a41c	26 37		rol $37				rol 	gxzTemp0+1
.c41e	a41e	ad 69 08	lda $0869			lda 	gxIsFillMode
.c421	a421	69 80		adc #$80			adc 	#128
.c423	a423	20 c0 a7	jsr $a7c0			jsr 	GXDrawLineTemp0 				; routine from Rectangle.
.c426	a426	38		sec				sec 									; GY = -GY
.c427	a427	a9 00		lda #$00			lda 	#0
.c429	a429	ed 68 08	sbc $0868			sbc 	gxYCentre
.c42c	a42c	8d 68 08	sta $0868			sta 	gxYCentre
.c42f	a42f					GXPlot0Exit:
.c42f	a42f	60		rts				rts
.c430	a430					GXSubCopy:
.c430	a430	85 36		sta $36				sta 	gxzTemp0
.c432	a432	64 37		stz $37				stz 	gxzTemp0+1
.c434	a434	29 80		and #$80			and 	#$80
.c436	a436	f0 02		beq $a43a			beq 	_GXNoSx
.c438	a438	c6 37		dec $37				dec 	gxzTemp0+1
.c43a	a43a					_GXNoSx:
.c43a	a43a	38		sec				sec
.c43b	a43b	bd d2 07	lda $07d2,x			lda 	gxX1,x
.c43e	a43e	e5 36		sbc $36				sbc 	gxzTemp0
.c440	a440	9d ce 07	sta $07ce,x			sta 	gxX0,x
.c443	a443	bd d3 07	lda $07d3,x			lda 	gxX1+1,x
.c446	a446	e5 37		sbc $37				sbc 	gxzTemp0+1
.c448	a448	9d cf 07	sta $07cf,x			sta 	gxX0+1,x
.c44b	a44b	a5 36		lda $36				lda 	gxzTemp0 						; return A
.c44d	a44d	60		rts				rts
.c44e	a44e					GXCircleMove:
.c44e	a44e	9c 6a 08	stz $086a			stz 	gxYChanged 					; clear Y changed flag
.c451	a451	a5 39		lda $39				lda 	gxzTemp1+1 					; check sign of D
.c453	a453	10 0d		bpl $a462			bpl 	_GXEMPositive
.c455	a455	ee 67 08	inc $0867			inc 	gxxCentre 					; X++
.c458	a458	ad 67 08	lda $0867			lda 	gxxCentre
.c45b	a45b	20 81 a4	jsr $a481			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.c45e	a45e	a9 06		lda #$06			lda 	#6  						; and add 6
.c460	a460	80 15		bra $a477			bra 	_GXEMAddD
.c462	a462					_GXEMPositive:
.c462	a462	ee 67 08	inc $0867			inc 	gxxCentre					; X++
.c465	a465	ce 68 08	dec $0868			dec 	gxYCentre 					; Y--
.c468	a468	38		sec				sec 								; calculate X-Y
.c469	a469	ad 67 08	lda $0867			lda 	gxxCentre
.c46c	a46c	ed 68 08	sbc $0868			sbc 	gxYCentre
.c46f	a46f	20 81 a4	jsr $a481			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.c472	a472	a9 0a		lda #$0a			lda 	#10  						; and add 10
.c474	a474	ce 6a 08	dec $086a			dec 	gxYChanged
.c477	a477					_GXEMAddD:
.c477	a477	18		clc				clc
.c478	a478	65 38		adc $38				adc 	gxzTemp1
.c47a	a47a	85 38		sta $38				sta 	gxzTemp1
.c47c	a47c	90 02		bcc $a480			bcc 	_GXEMNoCarry
.c47e	a47e	e6 39		inc $39				inc 	gxzTemp1+1
.c480	a480					_GXEMNoCarry:
.c480	a480	60		rts				rts
.c481	a481					_GXAdd4TimesToD:
.c481	a481	85 36		sta $36				sta 	gxzTemp0 					; make 16 bit signed.
.c483	a483	29 80		and #$80			and 	#$80
.c485	a485	f0 02		beq $a489			beq 	_GXA4Unsigned
.c487	a487	a9 ff		lda #$ff			lda 	#$FF
.c489	a489					_GXA4Unsigned:
.c489	a489	85 37		sta $37				sta 	gxzTemp0+1
.c48b	a48b	06 36		asl $36				asl 	gxzTemp0  					; x 4
.c48d	a48d	26 37		rol $37				rol 	gxzTemp0+1
.c48f	a48f	06 36		asl $36				asl 	gxzTemp0
.c491	a491	26 37		rol $37				rol 	gxzTemp0+1
.c493	a493	18		clc				clc 								; add
.c494	a494	a5 36		lda $36				lda		gxzTemp0
.c496	a496	65 38		adc $38				adc 	gxzTemp1
.c498	a498	85 38		sta $38				sta 	gxzTemp1
.c49a	a49a	a5 37		lda $37				lda		gxzTemp0+1
.c49c	a49c	65 39		adc $39				adc 	gxzTemp1+1
.c49e	a49e	85 39		sta $39				sta 	gxzTemp1+1
.c4a0	a4a0	60		rts				rts
.c4a1	a4a1					GXCircleSetup:
.c4a1	a4a1	38		sec				sec
.c4a2	a4a2	ad d4 07	lda $07d4			lda 	gxY1
.c4a5	a4a5	ed d0 07	sbc $07d0			sbc 	gxY0
.c4a8	a4a8	4a		lsr a				lsr 	a
.c4a9	a4a9	8d 66 08	sta $0866			sta 	gxRadius
.c4ac	a4ac	a2 00		ldx #$00			ldx 	#0
.c4ae	a4ae	20 d0 a4	jsr $a4d0			jsr 	_GXCalculateCentre
.c4b1	a4b1	a2 02		ldx #$02			ldx 	#2
.c4b3	a4b3	20 d0 a4	jsr $a4d0			jsr 	_GXCalculateCentre
.c4b6	a4b6	9c 67 08	stz $0867			stz 	gxxCentre
.c4b9	a4b9	ad 66 08	lda $0866			lda 	gxRadius
.c4bc	a4bc	8d 68 08	sta $0868			sta 	gxYCentre
.c4bf	a4bf	0a		asl a				asl 	a 							; R x 2
.c4c0	a4c0	85 36		sta $36				sta 	gxzTemp0
.c4c2	a4c2	38		sec				sec
.c4c3	a4c3	a9 03		lda #$03			lda 	#3
.c4c5	a4c5	e5 36		sbc $36				sbc 	gxzTemp0
.c4c7	a4c7	85 38		sta $38				sta 	gxzTemp1
.c4c9	a4c9	a9 00		lda #$00			lda 	#0
.c4cb	a4cb	e9 00		sbc #$00			sbc 	#0
.c4cd	a4cd	85 39		sta $39				sta 	gxzTemp1+1
.c4cf	a4cf	60		rts				rts
.c4d0	a4d0					_GXCalculateCentre:
.c4d0	a4d0	38		sec				sec
.c4d1	a4d1	bd d2 07	lda $07d2,x			lda 	gxX1,x
.c4d4	a4d4	7d ce 07	adc $07ce,x			adc 	gxX0,x
.c4d7	a4d7	9d d2 07	sta $07d2,x			sta 	gxX1,x
.c4da	a4da	bd d3 07	lda $07d3,x			lda 	gxX1+1,x
.c4dd	a4dd	7d cf 07	adc $07cf,x			adc 	gxX0+1,x
.c4e0	a4e0	4a		lsr a				lsr 	a
.c4e1	a4e1	9d d3 07	sta $07d3,x			sta 	gxX1+1,x
.c4e4	a4e4	7e d2 07	ror $07d2,x			ror 	gxX1,x
.c4e7	a4e7	60		rts				rts
.0866						gxRadius:
>0866								.fill 	1
.0867						gxxCentre:
>0867								.fill 	1
.0868						gxYCentre:
>0868								.fill 	1
.0869						gxIsFillMode:
>0869								.fill 	1
.086a						gxYChanged:
>086a								.fill  	1
=64000						ScreenSize200 = 320 * 200
=76800						ScreenSize240 = 320 * 240
.c4e8	a4e8					GXClearBitmap:
.c4e8	a4e8	ad d7 07	lda $07d7			lda 	gxBitmapsOn 				; check BMP running.
.c4eb	a4eb	f0 24		beq $a511			beq 	_GXCBFail
.c4ed	a4ed	20 d7 aa	jsr $aad7			jsr 	GXOpenBitmap 				; start access
.c4f0	a4f0	a0 07		ldy #$07			ldy 	#ScreenSize200 / 8192 		; X is pages to clear
.c4f2	a4f2	ad da 07	lda $07da			lda 	gxHeight
.c4f5	a4f5	c9 c8		cmp #$c8			cmp 	#200 						; 200 ?
.c4f7	a4f7	a0 09		ldy #$09			ldy 	#ScreenSize240 / 8192
.c4f9	a4f9					_GXCalcLastPage:
.c4f9	a4f9	98		tya				tya 								; add to base page
.c4fa	a4fa	18		clc				clc
.c4fb	a4fb	6d d8 07	adc $07d8			adc 	gxBasePage
.c4fe	a4fe	85 0b		sta $0b				sta 	GXEditSlot  				; clear from this page back
.c500	a500					_GXClearAll:
.c500	a500	20 13 a5	jsr $a513			jsr 	_GXClearBlock 				; clear 8k block
.c503	a503	c6 0b		dec $0b				dec 	GXEditSlot  				; back to previous
.c505	a505	a5 0b		lda $0b				lda 	GXEditSlot
.c507	a507	cd d8 07	cmp $07d8			cmp 	gxBasePage 					; until before base page
.c50a	a50a	b0 f4		bcs $a500			bcs 	_GXClearAll
.c50c	a50c	20 df aa	jsr $aadf			jsr 	GXCloseBitmap	 			; stop access
.c50f	a50f	18		clc				clc
.c510	a510	60		rts				rts
.c511	a511					_GXCBFail:
.c511	a511	38		sec				sec
.c512	a512	60		rts				rts
.c513	a513					_GXClearBlock:
.c513	a513	a9 00		lda #$00			lda 	#((GXMappingAddress) & $FF)
.c515	a515	85 38		sta $38				sta 	0+gxzTemp1
.c517	a517	a9 60		lda #$60			lda 	#((GXMappingAddress) >> 8)
.c519	a519	85 39		sta $39				sta 	1+gxzTemp1
.c51b	a51b					_GXCB0:
.c51b	a51b	a5 36		lda $36				lda 	gxzTemp0
.c51d	a51d	a0 00		ldy #$00			ldy 	#0
.c51f	a51f					_GXCB1:
.c51f	a51f	91 38		sta ($38),y			sta 	(gxzTemp1),y
.c521	a521	c8		iny				iny
.c522	a522	91 38		sta ($38),y			sta 	(gxzTemp1),y
.c524	a524	c8		iny				iny
.c525	a525	91 38		sta ($38),y			sta 	(gxzTemp1),y
.c527	a527	c8		iny				iny
.c528	a528	91 38		sta ($38),y			sta 	(gxzTemp1),y
.c52a	a52a	c8		iny				iny
.c52b	a52b	d0 f2		bne $a51f			bne 	_GXCB1
.c52d	a52d	e6 39		inc $39				inc 	gxzTemp1+1
.c52f	a52f	a5 39		lda $39				lda 	gxzTemp1+1
.c531	a531	c9 80		cmp #$80			cmp	 	#(GXMappingAddress >> 8)+$20
.c533	a533	d0 e6		bne $a51b			bne 	_GXCB0
.c535	a535	60		rts				rts
.c536	a536					GXInitialise:
.c536	a536	64 01		stz $01				stz 	1
.c538	a538	a9 01		lda #$01			lda 	#1
.c53a	a53a	8d 00 d0	sta $d000			sta 	$D000
.c53d	a53d	18		clc				clc
.c53e	a53e	9c d6 07	stz $07d6			stz 	gxSpritesOn
.c541	a541	9c d7 07	stz $07d7			stz 	gxBitmapsOn
.c544	a544	a2 0f		ldx #$0f			ldx 	#15
.c546	a546					_GXIClear:
.c546	a546	9e c6 07	stz $07c6,x			stz 	gxCurrentX,x
.c549	a549	ca		dex				dex
.c54a	a54a	10 fa		bpl $a546			bpl 	_GXIClear
.c54c	a54c	20 e7 a5	jsr $a5e7			jsr 	GXClearSpriteStore
.c54f	a54f	60		rts				rts
.c550	a550					GXControlBitmap:
.c550	a550	64 01		stz $01				stz 	1
.c552	a552	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.c554	a554	29 01		and #$01			and 	#1 							; set bitmap flag
.c556	a556	8d d7 07	sta $07d7			sta 	gxBitmapsOn
.c559	a559	4a		lsr a				lsr 	a 							; bit 0 into carry.
.c55a	a55a	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.c55d	a55d	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.c55f	a55f	29 f7		and #$f7			and 	#$F7 						; clear bitmap bit
.c561	a561	90 02		bcc $a565			bcc 	_CBNotOn
.c563	a563	09 08		ora #$08			ora 	#$08 						; bitmap on if 1 on 0 off
.c565	a565					_CBNotOn:
.c565	a565	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.c568	a568	a5 36		lda $36				lda 	gxzTemp0 					; get control settings (bits 0-2)
.c56a	a56a	29 07		and #$07			and 	#7
.c56c	a56c	8d 00 d1	sta $d100			sta 	$D100 						; write in Vicky Bitmap Control Register #0
.c56f	a56f	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.c571	a571	d0 02		bne $a575			bne 	_CBNotDefault
.c573	a573	a9 08		lda #$08			lda 	#8  						; if zero, use 8 e.g. bitmap at $10000
.c575	a575					_CBNotDefault:
.c575	a575	8d d8 07	sta $07d8			sta 	gxBasePage
.c578	a578	20 d9 a5	jsr $a5d9			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.c57b	a57b	a5 37		lda $37				lda 	gxzTemp0+1 					; copy address into Bitmap address registers
.c57d	a57d	8d 03 d1	sta $d103			sta 	$D103
.c580	a580	a5 36		lda $36				lda 	gxzTemp0
.c582	a582	8d 02 d1	sta $d102			sta 	$D102
.c585	a585	9c 01 d1	stz $d101			stz 	$D101
.c588	a588	a2 f0		ldx #$f0			ldx 	#240 						; height is 240
.c58a	a58a	ad 01 d0	lda $d001			lda 	$D001 						; read MCR bit 0
.c58d	a58d	29 01		and #$01			and 	#1
.c58f	a58f	f0 02		beq $a593			beq 	_CBHaveHeight
.c591	a591	a2 c8		ldx #$c8			ldx 	#200 						; if bit 0 set 320x200
.c593	a593					_CBHaveHeight
.c593	a593	8e da 07	stx $07da			stx 	gxHeight
.c596	a596	18		clc				clc
.c597	a597	60		rts				rts
.c598	a598					GXControlSprite:
.c598	a598	64 01		stz $01				stz 	1
.c59a	a59a	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.c59c	a59c	29 01		and #$01			and 	#1 							; set sprites flag
.c59e	a59e	8d d6 07	sta $07d6			sta 	gxSpritesOn
.c5a1	a5a1	4a		lsr a				lsr 	a 							; bit 0 into carry.
.c5a2	a5a2	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.c5a5	a5a5	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.c5a7	a5a7	29 df		and #$df			and 	#$DF 						; clear sprite bit
.c5a9	a5a9	90 02		bcc $a5ad			bcc 	_CSNotOn
.c5ab	a5ab	09 20		ora #$20			ora 	#$20 						; sprite on if 1 on 0 off
.c5ad	a5ad					_CSNotOn:
.c5ad	a5ad	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.c5b0	a5b0	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.c5b2	a5b2	d0 02		bne $a5b6			bne 	_CSNotDefault
.c5b4	a5b4	a9 18		lda #$18			lda 	#24  						; if zero, use 24 e.g. sprites at $30000
.c5b6	a5b6					_CSNotDefault:
.c5b6	a5b6	8d d9 07	sta $07d9			sta 	gxSpritePage
.c5b9	a5b9	20 d9 a5	jsr $a5d9			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.c5bc	a5bc	a5 36		lda $36				lda 	gxzTemp0
.c5be	a5be	8d e4 07	sta $07e4			sta 	gxSpriteOffsetBase
.c5c1	a5c1	a5 37		lda $37				lda 	gxzTemp0+1
.c5c3	a5c3	8d e5 07	sta $07e5			sta 	gxSpriteOffsetBase+1
.c5c6	a5c6	a2 00		ldx #$00			ldx 	#0 							; disable all sprites, clears all sprite memory.
.c5c8	a5c8					_CSClear:
.c5c8	a5c8	9e 00 d9	stz $d900,x			stz 	$D900,x
.c5cb	a5cb	9e 00 da	stz $da00,x			stz 	$DA00,x
.c5ce	a5ce	ca		dex				dex
.c5cf	a5cf	d0 f7		bne $a5c8			bne 	_CSClear
.c5d1	a5d1	9c e3 07	stz $07e3			stz 	GSCurrentSpriteAddr+1 		; no sprite selected.
.c5d4	a5d4	20 e7 a5	jsr $a5e7			jsr 	GXClearSpriteStore
.c5d7	a5d7	18		clc				clc
.c5d8	a5d8	60		rts				rts
.c5d9	a5d9					GXCalculateBaseAddress:
.c5d9	a5d9	85 36		sta $36				sta 	gxzTemp0
.c5db	a5db	64 37		stz $37				stz 	gxzTemp0+1
.c5dd	a5dd	a9 05		lda #$05			lda 	#5
.c5df	a5df					_GXShift:
.c5df	a5df	06 36		asl $36				asl 	gxzTemp0
.c5e1	a5e1	26 37		rol $37				rol 	gxzTemp0+1
.c5e3	a5e3	3a		dec a				dec		a
.c5e4	a5e4	d0 f9		bne $a5df			bne 	_GXShift
.c5e6	a5e6	60		rts				rts
.c5e7	a5e7					GXClearSpriteStore:
.c5e7	a5e7	a2 3f		ldx #$3f			ldx 	#63 						; erase 64 sprite store elements
.c5e9	a5e9					_GXCSSLoop:
.c5e9	a5e9	9e 26 08	stz $0826,x			stz 	gxSpriteHigh,x
.c5ec	a5ec	a9 80		lda #$80			lda 	#$80 						; set the 'hidden' bit.
.c5ee	a5ee	9d e6 07	sta $07e6,x			sta 	gxSpriteLow,x
.c5f1	a5f1	ca		dex				dex
.c5f2	a5f2	10 f5		bpl $a5e9			bpl 	_GXCSSLoop
.c5f4	a5f4	60		rts				rts
.c5f5	a5f5					GXLine:
.c5f5	a5f5	ad d7 07	lda $07d7			lda 	gxBitmapsOn
.c5f8	a5f8	f0 28		beq $a622			beq 	_GXLFail
.c5fa	a5fa	20 d7 aa	jsr $aad7			jsr 	GXOpenBitmap
.c5fd	a5fd	20 1d ac	jsr $ac1d			jsr 	GXSortY						; sort pairs so Y1 >= Y0 e.g. top to bottom.
.c600	a600	20 c8 a6	jsr $a6c8			jsr 	GXLineSetup 				; the calculations in the linescanner constructor
.c603	a603	20 e7 aa	jsr $aae7			jsr 	gxPositionCalc 				; calculate position/offset.
.c606	a606					_GXDrawLoop:
.c606	a606	ac e0 07	ldy $07e0			ldy 	gxOffset 					; draw the pixel
.c609	a609	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.c60b	a60b	2d de 07	and $07de			and 	gxANDValue
.c60e	a60e	4d dd 07	eor $07dd			eor 	gxEORValue
.c611	a611	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.c613	a613	20 24 a6	jsr $a624			jsr 	GXLineIsComplete 			; is the line complete ?
.c616	a616	f0 05		beq $a61d			beq 	_GXLExit
.c618	a618	20 3f a6	jsr $a63f			jsr 	GXLineAdvance 				; code as per advance method
.c61b	a61b	80 e9		bra $a606			bra 	_GXDrawLoop
.c61d	a61d					_GXLExit:
.c61d	a61d	20 df aa	jsr $aadf			jsr 	GXCloseBitmap
.c620	a620	18		clc				clc
.c621	a621	60		rts				rts
.c622	a622					_GXLFail:
.c622	a622	38		sec				sec
.c623	a623	60		rts				rts
.c624	a624					GXLineIsComplete:
.c624	a624	ad 6d 08	lda $086d			lda 	gxIsDiffYLarger 			; is dy larger
.c627	a627	d0 0f		bne $a638			bne 	_GXLICCompareY 				; if so compare Y1/Y0
.c629	a629	ad ce 07	lda $07ce			lda 	gxX0 						; compare X, LSB and MSB
.c62c	a62c	4d d2 07	eor $07d2			eor 	gxX1
.c62f	a62f	d0 06		bne $a637			bne 	_GXLICExit
.c631	a631	ad cf 07	lda $07cf			lda 	gxX0+1
.c634	a634	4d d3 07	eor $07d3			eor 	gxX1+1
.c637	a637					_GXLICExit:
.c637	a637	60		rts				rts
.c638	a638					_GXLICCompareY:
.c638	a638	ad d4 07	lda $07d4			lda 	gxY1
.c63b	a63b	4d d0 07	eor $07d0			eor 	gxY0
.c63e	a63e	60		rts				rts
.c63f	a63f					GXLineAdvance:
.c63f	a63f	18		clc				clc 								; add adjust to position
.c640	a640	ad 6f 08	lda $086f			lda 	gxPosition
.c643	a643	6d 70 08	adc $0870			adc 	gxAdjust
.c646	a646	8d 6f 08	sta $086f			sta 	gxPosition
.c649	a649	9c 72 08	stz $0872			stz 	gxAddSelect 				; clear add select flag
.c64c	a64c	b0 05		bcs $a653			bcs 	_GXLAOverflow 				; if carry out, overflowed.
.c64e	a64e	cd 71 08	cmp $0871			cmp 	gxTotal 					; if exceeded total
.c651	a651	90 0a		bcc $a65d			bcc 	_GXLANoExtra
.c653	a653					_GXLAOverflow:
.c653	a653	ce 72 08	dec $0872			dec 	gxAddSelect 				; set addselect to $FF
.c656	a656	38		sec				sec 								; subtract total and write back
.c657	a657	ed 71 08	sbc $0871			sbc 	gxTotal
.c65a	a65a	8d 6f 08	sta $086f			sta 	gxPosition
.c65d	a65d					_GXLANoExtra:
.c65d	a65d	ad 6d 08	lda $086d			lda 	gxIsDiffYLarger
.c660	a660	f0 0d		beq $a66f			beq 	_GXDXLarger
.c662	a662	20 c1 a6	jsr $a6c1			jsr 	GXIncrementY
.c665	a665	ad 72 08	lda $0872			lda 	gxAddSelect
.c668	a668	f0 10		beq $a67a			beq 	_GXLAExit
.c66a	a66a	20 7b a6	jsr $a67b			jsr 	gxAdjustX
.c66d	a66d	80 0b		bra $a67a			bra 	_GXLAExit
.c66f	a66f					_GXDXLarger:
.c66f	a66f	20 7b a6	jsr $a67b			jsr 	gxAdjustX
.c672	a672	ad 72 08	lda $0872			lda 	gxAddSelect
.c675	a675	f0 03		beq $a67a			beq 	_GXLAExit
.c677	a677	20 c1 a6	jsr $a6c1			jsr 	GXIncrementY
.c67a	a67a					_GXLAExit:
.c67a	a67a	60		rts				rts
.c67b	a67b					gxAdjustX:
.c67b	a67b	ad 6e 08	lda $086e			lda 	gxDXNegative
.c67e	a67e	10 25		bpl $a6a5			bpl 	_GXAXRight
.c680	a680	ad ce 07	lda $07ce			lda 	gxX0
.c683	a683	d0 03		bne $a688			bne 	_GXAXNoBorrow
.c685	a685	ce cf 07	dec $07cf			dec 	gxX0+1
.c688	a688					_GXAXNoBorrow:
.c688	a688	ce ce 07	dec $07ce			dec 	gxX0
.c68b	a68b	ce e0 07	dec $07e0			dec 	gxOffset 					; pixel left
.c68e	a68e	ad e0 07	lda $07e0			lda 	gxOffset
.c691	a691	c9 ff		cmp #$ff			cmp 	#$FF
.c693	a693	d0 0f		bne $a6a4			bne 	_GXAYExit 					; underflow
.c695	a695	c6 3d		dec $3d				dec 	gxzScreen+1 					; borrow
.c697	a697	a5 3d		lda $3d				lda 	gxzScreen+1 					; gone off page
.c699	a699	c9 60		cmp #$60			cmp 	#GXMappingAddress >> 8
.c69b	a69b	b0 07		bcs $a6a4			bcs 	_GXAYExit
.c69d	a69d	18		clc				clc
.c69e	a69e	69 20		adc #$20			adc 	#$20 						; fix up
.c6a0	a6a0	85 3d		sta $3d				sta 	gxzScreen+1
.c6a2	a6a2	c6 0b		dec $0b				dec 	GXEditSlot 				; back one page
.c6a4	a6a4					_GXAYExit:
.c6a4	a6a4	60		rts				rts
.c6a5	a6a5					_GXAXRight:
.c6a5	a6a5	ee ce 07	inc $07ce			inc 	gxX0
.c6a8	a6a8	d0 03		bne $a6ad			bne 	_GXAXNoCarry
.c6aa	a6aa	ee cf 07	inc $07cf			inc 	gxX0+1
.c6ad	a6ad					_GXAXNoCarry:
.c6ad	a6ad	ee e0 07	inc $07e0			inc 	gxOffset 					; pixel right
.c6b0	a6b0	d0 0e		bne $a6c0			bne 	_GXAXExit 					; if not overflowed, exit.
.c6b2	a6b2	e6 3d		inc $3d				inc 	gxzScreen+1 					; next line
.c6b4	a6b4	a5 3d		lda $3d				lda 	gxzScreen+1
.c6b6	a6b6	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.c6b8	a6b8	90 06		bcc $a6c0			bcc 	_GXAXExit
.c6ba	a6ba	e9 20		sbc #$20			sbc 	#$20 						; fix up
.c6bc	a6bc	85 3d		sta $3d				sta 	gxzScreen+1
.c6be	a6be	e6 0b		inc $0b				inc 	GXEditSlot 				; next page
.c6c0	a6c0					_GXAXExit:
.c6c0	a6c0	60		rts				rts
.c6c1	a6c1					GXIncrementY:
.c6c1	a6c1	ee d0 07	inc $07d0			inc 	gxY0
.c6c4	a6c4	20 3d ab	jsr $ab3d			jsr 	GXMovePositionDown
.c6c7	a6c7	60		rts				rts
.c6c8	a6c8					GXLineSetup:
.c6c8	a6c8	ad d4 07	lda $07d4			lda 	gxY1
.c6cb	a6cb	38		sec				sec
.c6cc	a6cc	ed d0 07	sbc $07d0			sbc 	gxY0
.c6cf	a6cf	4a		lsr a				lsr 	a
.c6d0	a6d0	8d 6c 08	sta $086c			sta 	gxDiffY
.c6d3	a6d3	9c 6e 08	stz $086e			stz 	gxDXNegative 				; clear -ve flag
.c6d6	a6d6	38		sec				sec
.c6d7	a6d7	ad d2 07	lda $07d2			lda 	gxX1
.c6da	a6da	ed ce 07	sbc $07ce			sbc 	gxX0
.c6dd	a6dd	8d 6b 08	sta $086b			sta 	gxDiffX
.c6e0	a6e0	ad d3 07	lda $07d3			lda 	gxX1+1 						; calculate MSB
.c6e3	a6e3	ed cf 07	sbc $07cf			sbc 	gxX0+1
.c6e6	a6e6	6a		ror a				ror 	a 							; rotate bit into DiffX halving it
.c6e7	a6e7	6e 6b 08	ror $086b			ror 	gxDiffX
.c6ea	a6ea	0a		asl a				asl 	a
.c6eb	a6eb	10 0c		bpl $a6f9			bpl 	_GDXNotNegative
.c6ed	a6ed	a9 00		lda #$00			lda 	#0 							; make absolute value of |dx|
.c6ef	a6ef	38		sec				sec
.c6f0	a6f0	ed 6b 08	sbc $086b			sbc 	gxDiffX
.c6f3	a6f3	8d 6b 08	sta $086b			sta 	gxDiffX
.c6f6	a6f6	ce 6e 08	dec $086e			dec 	gxDXNegative 				; -ve flag = $FF.
.c6f9	a6f9					_GDXNotNegative:
.c6f9	a6f9	9c 6d 08	stz $086d			stz 	gxIsDiffYLarger 			; clear larger flag
.c6fc	a6fc	ad 6c 08	lda $086c			lda 	gxDiffY 					; set adjust and total.
.c6ff	a6ff	8d 70 08	sta $0870			sta 	gxAdjust
.c702	a702	ad 6b 08	lda $086b			lda 	gxDiffX
.c705	a705	8d 71 08	sta $0871			sta 	gxTotal
.c708	a708	ad 6c 08	lda $086c			lda 	gxDiffY 					; if dy > dx
.c70b	a70b	cd 6b 08	cmp $086b			cmp 	gxDiffX
.c70e	a70e	90 0f		bcc $a71f			bcc 	_GDXNotLarger
.c710	a710	ce 6d 08	dec $086d			dec 	gxIsDiffYLarger 			; set the dy larger flag
.c713	a713	ad 6b 08	lda $086b			lda 	gxDiffX 					; set adjust and total other way round
.c716	a716	8d 70 08	sta $0870			sta 	gxAdjust
.c719	a719	ad 6c 08	lda $086c			lda 	gxDiffY
.c71c	a71c	8d 71 08	sta $0871			sta 	gxTotal
.c71f	a71f					_GDXNotLarger:
.c71f	a71f	ad 71 08	lda $0871			lda 	gxTotal
.c722	a722	4a		lsr a				lsr 	a
.c723	a723	8d 6f 08	sta $086f			sta 	gxPosition
.c726	a726	60		rts				rts
.086b						gxDiffX:
>086b								.fill 	1
.086c						gxDiffY:
>086c								.fill 	1
.086d						gxIsDiffYLarger:
>086d								.fill 	1
.086e						gxDXNegative:
>086e								.fill 	1
.086f						gxPosition:
>086f								.fill 	1
.0870						gxAdjust:
>0870								.fill 	1
.0871						gxTotal:
>0871								.fill 	1
.0872						gxAddSelect:
>0872								.fill 	1
.c727	a727					GXSetColourMode:
.c727	a727	a6 36		ldx $36				ldx 	gxzTemp0
.c729	a729	8e dc 07	stx $07dc			stx 	gxColour 								; set colour
.c72c	a72c	a5 37		lda $37				lda 	gxzTemp0+1 								;
.c72e	a72e	8d db 07	sta $07db			sta 	gxMode 									; set mode
.c731	a731	29 03		and #$03			and 	#3 										; only interested in bits 0-3
.c733	a733	9c de 07	stz $07de			stz 	gxANDValue 								; initially AND with 0, and EOR with Colour
.c736	a736	ae dc 07	ldx $07dc			ldx 	gxColour
.c739	a739	8e dd 07	stx $07dd			stx 	gxEORValue
.c73c	a73c	c9 02		cmp #$02			cmp 	#2 										; if mode 2/3 And with colour
.c73e	a73e	90 03		bcc $a743			bcc 	_GXSDCNotAndColour
.c740	a740	8e de 07	stx $07de			stx 	gxANDValue
.c743	a743					_GXSDCNotAndColour:
.c743	a743	d0 03		bne $a748			bne 	_GXSDCNotAnd 							; mode 2, Don't EOR with colour
.c745	a745	9c dd 07	stz $07dd			stz 	gxEORValue
.c748	a748					_GXSDCNotAnd:
.c748	a748	4a		lsr a				lsr 	a 										; if bit 0 set, 1's complement AND value
.c749	a749	90 08		bcc $a753			bcc 	_GXSDCNoFlip
.c74b	a74b	ad de 07	lda $07de			lda	 	gxANDValue
.c74e	a74e	49 ff		eor #$ff			eor 	#$FF
.c750	a750	8d de 07	sta $07de			sta 	gxANDValue
.c753	a753					_GXSDCNoFlip:
.c753	a753	18		clc				clc
.c754	a754	60		rts				rts
.c755	a755					GXPlotPoint:
.c755	a755	20 d7 aa	jsr $aad7			jsr 	GXOpenBitmap 				; start drawing
.c758	a758	20 e7 aa	jsr $aae7			jsr 	gxPositionCalc 				; setup gxzScreen, gxOffset and the position.
.c75b	a75b	ac e0 07	ldy $07e0			ldy 	gxOffset
.c75e	a75e	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.c760	a760	2d de 07	and $07de			and 	gxANDValue
.c763	a763	4d dd 07	eor $07dd			eor 	gxEORValue
.c766	a766	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.c768	a768	20 df aa	jsr $aadf			jsr 	GXCloseBitmap 				; stop drawing and exit
.c76b	a76b	18		clc				clc
.c76c	a76c	60		rts				rts
.c76d	a76d					GXFillRectangle:
.c76d	a76d	38		sec				sec
.c76e	a76e	80 01		bra $a771			bra 	GXRectangle
.c770	a770					GXFrameRectangle:
.c770	a770	18		clc				clc
.c771	a771					GXRectangle:
.c771	a771	ad d7 07	lda $07d7			lda 	gxBitmapsOn
.c774	a774	f0 35		beq $a7ab			beq 	_GXRFail
.c776	a776	08		php				php 								; save Fill flag (CS)
.c777	a777	20 d7 aa	jsr $aad7			jsr 	GXOpenBitmap 				; start drawing
.c77a	a77a	20 ff ab	jsr $abff			jsr 	GXSortXY 					; sort both X and Y so top left/bottom right
.c77d	a77d	20 e7 aa	jsr $aae7			jsr 	gxPositionCalc 				; setup gxzScreen, gxOffset and the position.
.c780	a780	38		sec				sec 								; sec = Draw line
.c781	a781	20 ad a7	jsr $a7ad			jsr 	GXDrawLineX1X0 				; draw a line length X1-X0
.c784	a784	ad d0 07	lda $07d0			lda 	gxY0 						; reached end of rectangle ?
.c787	a787	cd d4 07	cmp $07d4			cmp 	gxY1
.c78a	a78a	f0 19		beq $a7a5			beq 	_GXRectangleExit
.c78c	a78c					_GXRectLoop:
.c78c	a78c	20 3d ab	jsr $ab3d			jsr 	GXMovePositionDown 			; down one.
.c78f	a78f	ee d0 07	inc $07d0			inc 	gxY0 						; change Y pos
.c792	a792	ad d0 07	lda $07d0			lda 	gxY0 						; reached last line
.c795	a795	cd d4 07	cmp $07d4			cmp 	gxY1
.c798	a798	f0 07		beq $a7a1			beq 	_GXLastLine
.c79a	a79a	28		plp				plp 								; get flag back
.c79b	a79b	08		php				php
.c79c	a79c	20 ad a7	jsr $a7ad			jsr 	GXDrawLineX1X0 				; draw horizontal line
.c79f	a79f	80 eb		bra $a78c			bra 	_GXRectLoop
.c7a1	a7a1					_GXLastLine:
.c7a1	a7a1	38		sec				sec
.c7a2	a7a2	20 ad a7	jsr $a7ad			jsr 	GXDrawLineX1X0
.c7a5	a7a5					_GXRectangleExit:
.c7a5	a7a5	68		pla				pla 								; throw fill flag.
.c7a6	a7a6	20 df aa	jsr $aadf			jsr 	GXCloseBitmap 				; stop drawing and exit
.c7a9	a7a9	18		clc				clc
.c7aa	a7aa	60		rts				rts
.c7ab	a7ab					_GXRFail:
.c7ab	a7ab	38		sec				sec
.c7ac	a7ac	60		rts				rts
.c7ad	a7ad					GXDrawLineX1X0:
.c7ad	a7ad	08		php				php 								; save solid/either-end
.c7ae	a7ae	38		sec				sec
.c7af	a7af	ad d2 07	lda $07d2			lda		gxX1
.c7b2	a7b2	ed ce 07	sbc $07ce			sbc 	gxX0
.c7b5	a7b5	85 36		sta $36				sta 	gxzTemp0
.c7b7	a7b7	ad d3 07	lda $07d3			lda 	gxX1+1
.c7ba	a7ba	ed cf 07	sbc $07cf			sbc 	gxX0+1
.c7bd	a7bd	85 37		sta $37				sta 	gxzTemp0+1
.c7bf	a7bf	28		plp				plp
.c7c0	a7c0					GXDrawLineTemp0:
.c7c0	a7c0	a5 3c		lda $3c				lda 	gxzScreen 						; push gxzScreen, gxOffset and GXEditSlot on stack
.c7c2	a7c2	48		pha				pha
.c7c3	a7c3	a5 3d		lda $3d				lda 	gxzScreen+1
.c7c5	a7c5	48		pha				pha
.c7c6	a7c6	ad e0 07	lda $07e0			lda 	gxOffset
.c7c9	a7c9	48		pha				pha
.c7ca	a7ca	a5 0b		lda $0b				lda 	GXEditSlot
.c7cc	a7cc	48		pha				pha
.c7cd	a7cd	ac e0 07	ldy $07e0			ldy 	gxOffset 					; Y offset
.c7d0	a7d0	90 1e		bcc $a7f0			bcc 	_GXDLTEndPoints 			; if CC draw end points only.
.c7d2	a7d2					_GXDLTLine:
.c7d2	a7d2	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.c7d4	a7d4	2d de 07	and $07de			and 	gxANDValue
.c7d7	a7d7	4d dd 07	eor $07dd			eor 	gxEORValue
.c7da	a7da	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.c7dc	a7dc	a5 36		lda $36				lda 	gxzTemp0 					; decrement counter
.c7de	a7de	d0 04		bne $a7e4			bne 	_GXDLTNoBorrow
.c7e0	a7e0	c6 37		dec $37				dec 	gxzTemp0+1 					; borrow, if goes -ve then exit
.c7e2	a7e2	30 2e		bmi $a812			bmi 	_GXDLTExit
.c7e4	a7e4					_GXDLTNoBorrow:
.c7e4	a7e4	c6 36		dec $36				dec 	gxzTemp0
.c7e6	a7e6	c8		iny				iny 								; next slot.
.c7e7	a7e7	d0 e9		bne $a7d2			bne 	_GXDLTLine
.c7e9	a7e9	e6 3d		inc $3d				inc 	gxzScreen+1 					; carry to next
.c7eb	a7eb	20 20 a8	jsr $a820			jsr 	GXDLTCheckWrap				; check for new page.
.c7ee	a7ee	80 e2		bra $a7d2			bra 	_GXDLTLine
.c7f0	a7f0					_GXDLTEndPoints:
.c7f0	a7f0	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.c7f2	a7f2	2d de 07	and $07de			and 	gxANDValue
.c7f5	a7f5	4d dd 07	eor $07dd			eor 	gxEORValue
.c7f8	a7f8	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.c7fa	a7fa	98		tya				tya 								; advance to right side
.c7fb	a7fb	18		clc				clc
.c7fc	a7fc	65 36		adc $36				adc 	gxzTemp0
.c7fe	a7fe	a8		tay				tay
.c7ff	a7ff	a5 3d		lda $3d				lda 	gxzScreen+1
.c801	a801	65 37		adc $37				adc 	gxzTemp0+1
.c803	a803	85 3d		sta $3d				sta 	gxzScreen+1
.c805	a805	20 20 a8	jsr $a820			jsr 	GXDLTCheckWrap 			; fix up.
.c808	a808	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.c80a	a80a	2d de 07	and $07de			and 	gxANDValue
.c80d	a80d	4d dd 07	eor $07dd			eor 	gxEORValue
.c810	a810	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.c812	a812					_GXDLTExit:
.c812	a812	68		pla				pla
.c813	a813	85 0b		sta $0b				sta 	GXEditSlot
.c815	a815	68		pla				pla
.c816	a816	8d e0 07	sta $07e0			sta 	gxOffset
.c819	a819	68		pla				pla
.c81a	a81a	85 3d		sta $3d				sta 	gxzScreen+1
.c81c	a81c	68		pla				pla
.c81d	a81d	85 3c		sta $3c				sta 	gxzScreen
.c81f	a81f	60		rts				rts
.c820	a820					GXDLTCheckWrap:
.c820	a820	a5 3d		lda $3d				lda 	gxzScreen+1 					; check end of page
.c822	a822	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8)
.c824	a824	90 06		bcc $a82c			bcc 	_GXDLTCWExit
.c826	a826	e9 20		sbc #$20			sbc 	#$20 						; fix up
.c828	a828	85 3d		sta $3d				sta 	gxzScreen+1
.c82a	a82a	e6 0b		inc $0b				inc 	GXEditSlot
.c82c	a82c					_GXDLTCWExit:
.c82c	a82c	60		rts				rts
.c82d	a82d					GXDrawGraphicElement:
.c82d	a82d	8d 73 08	sta $0873			sta 	gxSize 						; save size
.c830	a830	3a		dec a				dec 	a
.c831	a831	8d 74 08	sta $0874			sta 	gxMask 						; and mask
.c834	a834	ad d7 07	lda $07d7			lda 	gxBitmapsOn 				; check BMP on
.c837	a837	f0 67		beq $a8a0			beq 	_GXSLFail
.c839	a839	ad d0 07	lda $07d0			lda 	gxY0 						; push Y on stack
.c83c	a83c	48		pha				pha
.c83d	a83d	8c 76 08	sty $0876			sty 	gxAcquireVector+1 			; and acquisition vector
.c840	a840	8e 75 08	stx $0875			stx 	gxAcquireVector
.c843	a843	20 d7 aa	jsr $aad7			jsr 	GXOpenBitmap 				; open the bitmap.
.c846	a846	ad 78 08	lda $0878			lda 	gxUseMode 					; scale bits
.c849	a849	4a		lsr a				lsr 	a
.c84a	a84a	4a		lsr a				lsr 	a
.c84b	a84b	4a		lsr a				lsr 	a
.c84c	a84c	29 07		and #$07			and		#7
.c84e	a84e	1a		inc a				inc 	a
.c84f	a84f	8d 77 08	sta $0877			sta 	gxScale
.c852	a852	64 38		stz $38				stz 	gxzTemp1					; start first line
.c854	a854					_GXGELoop:
.c854	a854	a5 38		lda $38				lda 	gxzTemp1 					; current line number to read.
.c856	a856	2c 78 08	bit $0878			bit 	gxUseMode 					; check for flip.
.c859	a859	10 06		bpl $a861			bpl		_GXNoVFlip
.c85b	a85b	ad 74 08	lda $0874			lda 	gxMask
.c85e	a85e	38		sec				sec
.c85f	a85f	e5 38		sbc $38				sbc 	gxzTemp1
.c861	a861					_GXNoVFlip:
.c861	a861	aa		tax				tax 								; get the Xth line.
.c862	a862	20 a2 a8	jsr $a8a2			jsr 	_GXCallAcquire 				; get that data.
.c865	a865	ad 77 08	lda $0877			lda 	gxScale 					; do scale identical copies of that line.
.c868	a868	85 39		sta $39				sta 	gxzTemp1+1
.c86a	a86a					_GXGELoop2:
.c86a	a86a	ad d0 07	lda $07d0			lda 	gxY0 						; off screen
.c86d	a86d	cd da 07	cmp $07da			cmp 	gxHeight
.c870	a870	b0 10		bcs $a882			bcs 	_GXDGEExit
.c872	a872	20 a5 a8	jsr $a8a5			jsr 	GXRenderOneLine 			; render line
.c875	a875	c6 39		dec $39				dec 	gxzTemp1+1 					; scale times.
.c877	a877	d0 f1		bne $a86a			bne 	_GXGELoop2
.c879	a879	e6 38		inc $38				inc 	gxzTemp1 					; done all lines.
.c87b	a87b	a5 38		lda $38				lda 	gxzTemp1
.c87d	a87d	cd 73 08	cmp $0873			cmp 	gxSize
.c880	a880	d0 d2		bne $a854			bne 	_GXGELoop
.c882	a882					_GXDGEExit:
.c882	a882	68		pla				pla 								; restore Y for next time
.c883	a883	8d d0 07	sta $07d0			sta 	gxY0
.c886	a886	ae 77 08	ldx $0877			ldx 	gxScale 					; get scale (1-8)
.c889	a889					_GXShiftLeft:
.c889	a889	18		clc				clc
.c88a	a88a	ad 73 08	lda $0873			lda 	gxSize
.c88d	a88d	6d ce 07	adc $07ce			adc 	gxX0
.c890	a890	8d ce 07	sta $07ce			sta 	gxX0
.c893	a893	90 03		bcc $a898			bcc 	_GXSLNoCarry
.c895	a895	ee cf 07	inc $07cf			inc 	gxX0+1
.c898	a898					_GXSLNoCarry:
.c898	a898	ca		dex				dex
.c899	a899	d0 ee		bne $a889			bne 	_GXShiftLeft
.c89b	a89b	20 df aa	jsr $aadf			jsr 	GXCloseBitmap
.c89e	a89e	18		clc				clc
.c89f	a89f	60		rts				rts
.c8a0	a8a0					_GXSLFail:
.c8a0	a8a0	38		sec				sec
.c8a1	a8a1	60		rts				rts
.c8a2	a8a2					_GXCallAcquire:
.c8a2	a8a2	6c 75 08	jmp ($0875)			jmp 	(gxAcquireVector)
.c8a5	a8a5					GXRenderOneLine:
.c8a5	a8a5	20 e7 aa	jsr $aae7			jsr 	gxPositionCalc 				; calculate position/offset.
.c8a8	a8a8	ac e0 07	ldy $07e0			ldy 	gxOffset 					; Y contains position.
.c8ab	a8ab	64 3a		stz $3a				stz 	gxzTemp2 					; do size pixels
.c8ad	a8ad					_GXROLLoop1:
.c8ad	a8ad	ad 77 08	lda $0877			lda 	gxScale 					; set to do 'scale' times
.c8b0	a8b0	85 3b		sta $3b				sta 	gxzTemp2+1
.c8b2	a8b2					_GXROLLoop2:
.c8b2	a8b2	a5 3a		lda $3a				lda 	gxzTemp2 					; get current pixel
.c8b4	a8b4	2c db 07	bit $07db			bit 	gxMode 						; check H Flip
.c8b7	a8b7	50 06		bvc $a8bf			bvc 	_GXNoHFlip
.c8b9	a8b9	ad 74 08	lda $0874			lda 	gxMask
.c8bc	a8bc	38		sec				sec
.c8bd	a8bd	e5 3a		sbc $3a				sbc 	gxzTemp2
.c8bf	a8bf					_GXNoHFlip:
.c8bf	a8bf	aa		tax				tax 								; read from the pixel buffer
.c8c0	a8c0	bd 23 06	lda $0623,x			lda 	gxPixelBuffer,x
.c8c3	a8c3	d0 07		bne $a8cc			bne 	_GXDraw 					; draw if non zero
.c8c5	a8c5	ad 78 08	lda $0878			lda 	gxUseMode 					; check to see if solid background
.c8c8	a8c8	29 04		and #$04			and 	#4
.c8ca	a8ca	f0 0a		beq $a8d6			beq 	_GXZeroPixel
.c8cc	a8cc					_GXDraw:
.c8cc	a8cc	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.c8ce	a8ce	2d de 07	and $07de			and 	gxANDValue
.c8d1	a8d1	5d 23 06	eor $0623,x			eor 	gxPixelBuffer,x
.c8d4	a8d4	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.c8d6	a8d6					_GXZeroPixel:
.c8d6	a8d6	c8		iny				iny 								; advance pointer
.c8d7	a8d7	d0 05		bne $a8de			bne 	_GXNoShift
.c8d9	a8d9	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.c8db	a8db	20 20 a8	jsr $a820			jsr 	GXDLTCheckWrap				; check for new page.
.c8de	a8de					_GXNoShift:
.c8de	a8de	c6 3b		dec $3b				dec 	gxzTemp2+1 					; do the inner loop gxScale times.
.c8e0	a8e0	d0 d0		bne $a8b2			bne 	_GXROLLoop2
.c8e2	a8e2	e6 3a		inc $3a				inc 	gxzTemp2 					; next pixel.
.c8e4	a8e4	a5 3a		lda $3a				lda 	gxzTemp2
.c8e6	a8e6	cd 73 08	cmp $0873			cmp 	gxSize
.c8e9	a8e9	d0 c2		bne $a8ad			bne 	_GXROLLoop1
.c8eb	a8eb	ee d0 07	inc $07d0			inc 	gxY0
.c8ee	a8ee	60		rts				rts
.0873						gxSize:
>0873								.fill 	1
.0874						gxMask:
>0874								.fill 	1
.0875						gxAcquireVector:
>0875								.fill 	2
.0877						gxScale:
>0877								.fill 	1
.0878						gxUseMode:
>0878								.fill 	1
.c8ef	a8ef					GXFontHandler:
.c8ef	a8ef	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.c8f1	a8f1	4d db 07	eor $07db			eor 	gxMode
.c8f4	a8f4	8d 78 08	sta $0878			sta 	gxUseMode
.c8f7	a8f7	64 37		stz $37				stz 	gxzTemp0+1 					; gxzTemp0 is font #
.c8f9	a8f9	06 36		asl $36				asl	 	gxzTemp0 					; x 2
.c8fb	a8fb	26 37		rol $37				rol	 	gxzTemp0+1
.c8fd	a8fd	06 36		asl $36				asl	 	gxzTemp0 					; x 4
.c8ff	a8ff	26 37		rol $37				rol	 	gxzTemp0+1
.c901	a901	06 36		asl $36				asl	 	gxzTemp0 					; x 8
.c903	a903	26 37		rol $37				rol	 	gxzTemp0+1
.c905	a905	a5 37		lda $37				lda 	gxzTemp0+1 					; put in page C0
.c907	a907	09 c0		ora #$c0			ora 	#$C0
.c909	a909	85 37		sta $37				sta 	gxzTemp0+1
.c90b	a90b	a9 08		lda #$08			lda 	#8 							; size 8x8
.c90d	a90d	a2 15		ldx #$15			ldx 	#GXGetGraphicDataFont & $FF ; XY = Graphic Data retrieval routine
.c90f	a90f	a0 a9		ldy #$a9			ldy 	#GXGetGraphicDataFont >> 8
.c911	a911	20 2d a8	jsr $a82d			jsr 	GXDrawGraphicElement
.c914	a914	60		rts				rts
.c915	a915					GXGetGraphicDataFont:
.c915	a915	8a		txa				txa 								; X->Y
.c916	a916	a8		tay				tay
.c917	a917	a6 01		ldx $01				ldx 	1 							; preserve old value
.c919	a919	a9 01		lda #$01			lda 	#1 							; access page 1 (font memory)
.c91b	a91b	85 01		sta $01				sta 	1
.c91d	a91d	b1 36		lda ($36),y			lda 	(gxzTemp0),y 				; read the font element.
.c91f	a91f	86 01		stx $01				stx 	1 							; put old value back.
.c921	a921	a2 00		ldx #$00			ldx 	#0 							; do 8 times
.c923	a923					_GXExpand:
.c923	a923	9e 23 06	stz $0623,x			stz 	gxPixelBuffer,x 			; zero in pixel buffer
.c926	a926	0a		asl a				asl 	a 							; shift bit 7 into C
.c927	a927	90 08		bcc $a931			bcc 	_GXNoPixel
.c929	a929	48		pha				pha 								; if set, set pixel buffer to current colour.
.c92a	a92a	ad dc 07	lda $07dc			lda 	gxColour
.c92d	a92d	9d 23 06	sta $0623,x			sta 	gxPixelBuffer,x
.c930	a930	68		pla				pla
.c931	a931					_GXNoPixel:
.c931	a931	e8		inx				inx 								; do the whole byte.
.c932	a932	e0 08		cpx #$08			cpx 	#8
.c934	a934	d0 ed		bne $a923			bne 	_GXExpand
.c936	a936	60		rts				rts
.c937	a937					GXSpriteHandler:
.c937	a937	ad d6 07	lda $07d6			lda 	gxSpritesOn 				; sprites on ?
.c93a	a93a	f0 23		beq $a95f			beq 	_GXSHExit
.c93c	a93c	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.c93e	a93e	4d db 07	eor $07db			eor 	gxMode
.c941	a941	8d 78 08	sta $0878			sta 	gxUseMode
.c944	a944	a6 36		ldx $36				ldx 	gxzTemp0 					; sprite #
.c946	a946	da		phx				phx
.c947	a947	20 d7 aa	jsr $aad7			jsr 	GXOpenBitmap 				; can access sprite information
.c94a	a94a	68		pla				pla
.c94b	a94b	20 b8 ab	jsr $abb8			jsr 	GXFindSprite 				; get the sprite address
.c94e	a94e	08		php				php
.c94f	a94f	20 df aa	jsr $aadf			jsr 	GXCloseBitmap
.c952	a952	28		plp				plp
.c953	a953	b0 0a		bcs $a95f			bcs		_GXSHExit 					; exit if find failed.
.c955	a955	ad 79 08	lda $0879			lda 	gxSizePixels 				; return size
.c958	a958	a2 60		ldx #$60			ldx 	#GXSpriteAcquire & $FF
.c95a	a95a	a0 a9		ldy #$a9			ldy 	#GXSpriteAcquire >> 8
.c95c	a95c	20 2d a8	jsr $a82d			jsr 	GXDrawGraphicElement
.c95f	a95f					_GXSHExit:
.c95f	a95f	60		rts				rts
.c960	a960					GXSpriteAcquire:
.c960	a960	ad d9 07	lda $07d9			lda 	gxSpritePage				; point to base page
.c963	a963	85 0b		sta $0b				sta 	GXEditSlot
.c965	a965	86 36		stx $36				stx 	gxzTemp0 					; row number x 1,2,3,4
.c967	a967	a9 00		lda #$00			lda 	#0
.c969	a969	ae 7a 08	ldx $087a			ldx 	gxSizeBits
.c96c	a96c					_GXTimesRowNumber:
.c96c	a96c	18		clc				clc
.c96d	a96d	65 36		adc $36				adc 	gxzTemp0
.c96f	a96f	ca		dex				dex
.c970	a970	10 fa		bpl $a96c			bpl 	_GXTimesRowNumber
.c972	a972	64 37		stz $37				stz 	gxzTemp0+1
.c974	a974	0a		asl a				asl 	a 							; row x 2,4,6,8
.c975	a975	26 37		rol $37				rol 	gxzTemp0+1
.c977	a977	0a		asl a				asl 	a 							; row x 4,8,12,16
.c978	a978	26 37		rol $37				rol 	gxzTemp0+1
.c97a	a97a	0a		asl a				asl 	a 							; row x 8,16,24,32
.c97b	a97b	26 37		rol $37				rol 	gxzTemp0+1
.c97d	a97d	85 36		sta $36				sta 	gxzTemp0
.c97f	a97f	18		clc				clc 								; add base address.
.c980	a980	a5 36		lda $36				lda 	gxzTemp0
.c982	a982	6d 7c 08	adc $087c			adc 	gxSpriteOffset
.c985	a985	85 36		sta $36				sta 	gxzTemp0
.c987	a987	a5 37		lda $37				lda 	gxzTemp0+1
.c989	a989	6d 7d 08	adc $087d			adc 	gxSpriteOffset+1
.c98c	a98c					_GXSAFindPage:
.c98c	a98c	c9 20		cmp #$20			cmp 	#$20 						; on this page
.c98e	a98e	90 06		bcc $a996			bcc 	_GXSAFoundPage
.c990	a990	e9 20		sbc #$20			sbc 	#$20 						; forward one page
.c992	a992	e6 0b		inc $0b				inc 	GXEditSlot
.c994	a994	80 f6		bra $a98c			bra 	_GXSAFindPage
.c996	a996					_GXSAFoundPage:
.c996	a996	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; physical address of page.
.c998	a998	85 37		sta $37				sta 	gxzTemp0+1 					; gxzTemp0 now points to the page
.c99a	a99a	a0 00		ldy #$00			ldy 	#0
.c99c	a99c					_GXSACopyLoop:
.c99c	a99c	b1 36		lda ($36),y			lda 	(gxzTemp0),y
.c99e	a99e	99 23 06	sta $0623,y			sta 	gxPixelBuffer,y
.c9a1	a9a1	c8		iny				iny
.c9a2	a9a2	cc 79 08	cpy $0879			cpy 	gxSizePixels
.c9a5	a9a5	d0 f5		bne $a99c			bne 	_GXSACopyLoop
.c9a7	a9a7	60		rts				rts
.c9a8	a9a8					GXSelect:
.c9a8	a9a8	ad d6 07	lda $07d6			lda 	gxSpritesOn
.c9ab	a9ab	f0 22		beq $a9cf			beq 	_GXSFail
.c9ad	a9ad	a5 36		lda $36				lda 	gxzTemp0 					; illegal sprite #
.c9af	a9af	c9 40		cmp #$40			cmp 	#64
.c9b1	a9b1	b0 1c		bcs $a9cf			bcs 	_GXSFail
.c9b3	a9b3	8d e1 07	sta $07e1			sta 	GSCurrentSpriteID
.c9b6	a9b6	a4 37		ldy $37				ldy 	gxzTemp0+1 					; control value.
.c9b8	a9b8	a9 00		lda #$00			lda  	#0 							; multiply sprite # x 8 => A
.c9ba	a9ba	06 36		asl $36				asl 	gxzTemp0
.c9bc	a9bc	06 36		asl $36				asl 	gxzTemp0
.c9be	a9be	06 36		asl $36				asl 	gxzTemp0
.c9c0	a9c0	2a		rol a				rol 	a
.c9c1	a9c1	69 d9		adc #$d9			adc 	#$D9 						; sprite area
.c9c3	a9c3	8d e3 07	sta $07e3			sta 	GSCurrentSpriteAddr+1 		; address to GSCurrentSprite and gxzTemp
.c9c6	a9c6	85 37		sta $37				sta 	gxzTemp0+1
.c9c8	a9c8	a5 36		lda $36				lda 	gxzTemp0
.c9ca	a9ca	8d e2 07	sta $07e2			sta 	GSCurrentSpriteAddr
.c9cd	a9cd	18		clc				clc
.c9ce	a9ce	60		rts				rts
.c9cf	a9cf					_GXSFail:
.c9cf	a9cf	38		sec				sec
.c9d0	a9d0	60		rts				rts
.c9d1	a9d1					GXSelectImage:
.c9d1	a9d1	ad d6 07	lda $07d6			lda 	gxSpritesOn
.c9d4	a9d4	f0 74		beq $aa4a			beq 	_GXSIFail
.c9d6	a9d6	ad e3 07	lda $07e3			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.c9d9	a9d9	f0 6f		beq $aa4a			beq 	_GXSIFail 					; (checking the MSB)
.c9db	a9db	64 01		stz $01				stz 	1
.c9dd	a9dd	a5 37		lda $37				lda 	gxzTemp0+1 					; push show/hide on the stack.
.c9df	a9df	d0 6b		bne $aa4c			bne 	_GXSIHide
.c9e1	a9e1	a5 36		lda $36				lda 	gxzTemp0 					; sprite image
.c9e3	a9e3	48		pha				pha
.c9e4	a9e4	20 d7 aa	jsr $aad7			jsr 	GXOpenBitmap
.c9e7	a9e7	68		pla				pla
.c9e8	a9e8	20 b8 ab	jsr $abb8			jsr 	GXFindSprite
.c9eb	a9eb	b0 5a		bcs $aa47			bcs 	_GXSICloseFail 				; no image
.c9ed	a9ed	a0 01		ldy #$01			ldy 	#1
.c9ef	a9ef	ad e2 07	lda $07e2			lda 	GSCurrentSpriteAddr
.c9f2	a9f2	85 36		sta $36				sta 	gxzTemp0
.c9f4	a9f4	ad e3 07	lda $07e3			lda 	GSCurrentSpriteAddr+1
.c9f7	a9f7	85 37		sta $37				sta 	gxzTemp0+1
.c9f9	a9f9	ad 7c 08	lda $087c			lda 	gxSpriteOffset
.c9fc	a9fc	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.c9fe	a9fe	18		clc				clc
.c9ff	a9ff	ad 7d 08	lda $087d			lda 	gxSpriteOffset+1
.ca02	aa02	6d e4 07	adc $07e4			adc 	gxSpriteOffsetBase
.ca05	aa05	c8		iny				iny
.ca06	aa06	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.ca08	aa08	ad e5 07	lda $07e5			lda 	gxSpriteOffsetBase+1
.ca0b	aa0b	69 00		adc #$00			adc 	#0
.ca0d	aa0d	c8		iny				iny
.ca0e	aa0e	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.ca10	aa10	ad 7a 08	lda $087a			lda 	gxSizeBits 					; get raw size
.ca13	aa13	49 03		eor #$03			eor 	#3 							; make it right (00=32 etc.)
.ca15	aa15	2a		rol a				rol 	a 							; x 2
.ca16	aa16	0a		asl a				asl 	a 							; x 4
.ca17	aa17	0a		asl a				asl 	a 							; x 8
.ca18	aa18	0a		asl a				asl 	a 							; x 16
.ca19	aa19	0d 7b 08	ora $087b			ora 	gxSpriteLUT 				; Or with LUT
.ca1c	aa1c	0a		asl a				asl 	a 							; 1 shift
.ca1d	aa1d	09 01		ora #$01			ora 	#1 							; enable sprite.
.ca1f	aa1f	92 36		sta ($36)			sta 	(gxzTemp0) 					; and write back
.ca21	aa21	20 df aa	jsr $aadf			jsr 	GXCloseBitmap
.ca24	aa24	ae e1 07	ldx $07e1			ldx 	GSCurrentSpriteID 			; point to sprite entries.
.ca27	aa27	bd 26 08	lda $0826,x			lda 	gxSpriteHigh,x 				; clear upper two bits of size
.ca2a	aa2a	29 3f		and #$3f			and 	#$3F
.ca2c	aa2c	9d 26 08	sta $0826,x			sta 	gxSpriteHigh,x
.ca2f	aa2f	ad 7a 08	lda $087a			lda 	gxSizeBits 					; get bit size
.ca32	aa32	6a		ror a				ror 	a 							; shift into bits 6/7
.ca33	aa33	6a		ror a				ror 	a
.ca34	aa34	6a		ror a				ror 	a
.ca35	aa35	29 c0		and #$c0			and 	#$C0
.ca37	aa37	1d 26 08	ora $0826,x			ora 	gxSpriteHigh,x 				; put in  upper 2 bits of sprite data
.ca3a	aa3a	9d 26 08	sta $0826,x			sta 	gxSpriteHigh,x
.ca3d	aa3d	bd e6 07	lda $07e6,x			lda 	gxSpriteLow,x 				; clear hidden flag.
.ca40	aa40	29 7f		and #$7f			and 	#$7F
.ca42	aa42	9d e6 07	sta $07e6,x			sta 	gxSpriteLow,x
.ca45	aa45	18		clc				clc
.ca46	aa46	60		rts				rts
.ca47	aa47					_GXSICloseFail:
.ca47	aa47	20 df aa	jsr $aadf			jsr 	GXCloseBitmap
.ca4a	aa4a					_GXSIFail:
.ca4a	aa4a	38		sec				sec
.ca4b	aa4b	60		rts				rts
.ca4c	aa4c					_GXSIHide:
.ca4c	aa4c	ad e2 07	lda $07e2			lda 	GSCurrentSpriteAddr  		; get Sprite h/w address and write there
.ca4f	aa4f	85 36		sta $36				sta 	gxzTemp0
.ca51	aa51	ad e3 07	lda $07e3			lda 	GSCurrentSpriteAddr+1
.ca54	aa54	85 37		sta $37				sta 	gxzTemp0+1
.ca56	aa56	a9 00		lda #$00			lda 	#0
.ca58	aa58	92 36		sta ($36)			sta 	(gxzTemp0)
.ca5a	aa5a	ae e1 07	ldx $07e1			ldx 	GSCurrentSpriteID 			; get sprite ID
.ca5d	aa5d	bd e6 07	lda $07e6,x			lda 	gxSpriteLow,x 				; set the hidden bit.
.ca60	aa60	09 80		ora #$80			ora 	#$80
.ca62	aa62	9d e6 07	sta $07e6,x			sta 	gxSpriteLow,x
.ca65	aa65	18		clc				clc
.ca66	aa66	60		rts				rts
.ca67	aa67					GXMoveSprite:
.ca67	aa67	ad d6 07	lda $07d6			lda 	gxSpritesOn
.ca6a	aa6a	f0 65		beq $aad1			beq 	_GXSIFail
.ca6c	aa6c	ad e3 07	lda $07e3			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.ca6f	aa6f	f0 60		beq $aad1			beq 	_GXSIFail
.ca71	aa71	85 37		sta $37				sta 	gxzTemp0+1
.ca73	aa73	a0 04		ldy #$04			ldy 	#4
.ca75	aa75	ad e2 07	lda $07e2			lda 	GSCurrentSpriteAddr
.ca78	aa78	85 36		sta $36				sta 	gxzTemp0
.ca7a	aa7a	ae e1 07	ldx $07e1			ldx 	GSCurrentSpriteID 			; get the size from the upper two bits
.ca7d	aa7d	bd 26 08	lda $0826,x			lda 	gxSpriteHigh,x
.ca80	aa80	2a		rol a				rol 	a	 						; into bits 0,1.
.ca81	aa81	2a		rol a				rol 	a
.ca82	aa82	2a		rol a				rol 	a
.ca83	aa83	29 03		and #$03			and 	#3
.ca85	aa85	aa		tax				tax
.ca86	aa86	bd d3 aa	lda $aad3,x			lda 	_GXMSOffset,x 				; get 32-SpriteSize/2
.ca89	aa89	48		pha				pha
.ca8a	aa8a	18		clc				clc
.ca8b	aa8b	6d ce 07	adc $07ce			adc 	gxX0						; copy position.
.ca8e	aa8e	91 36		sta ($36),y			sta 	(gxzTemp0),y
.ca90	aa90	c8		iny				iny
.ca91	aa91	ad cf 07	lda $07cf			lda 	gxX0+1
.ca94	aa94	69 00		adc #$00			adc 	#0
.ca96	aa96	91 36		sta ($36),y			sta 	(gxzTemp0),y
.ca98	aa98	c8		iny				iny
.ca99	aa99	68		pla				pla
.ca9a	aa9a	18		clc				clc
.ca9b	aa9b	6d d0 07	adc $07d0			adc 	gxY0
.ca9e	aa9e	91 36		sta ($36),y			sta 	(gxzTemp0),y
.caa0	aaa0	a9 00		lda #$00			lda 	#0
.caa2	aaa2	69 00		adc #$00			adc 	#0
.caa4	aaa4	c8		iny				iny
.caa5	aaa5	91 36		sta ($36),y			sta 	(gxzTemp0),y
.caa7	aaa7	4e cf 07	lsr $07cf			lsr 	gxX0+1 						; divide X by 4
.caaa	aaaa	6e ce 07	ror $07ce			ror 	gxX0
.caad	aaad	4e ce 07	lsr $07ce			lsr 	gxX0
.cab0	aab0	4e d0 07	lsr $07d0			lsr 	gxY0 						; divide Y by 4
.cab3	aab3	4e d0 07	lsr $07d0			lsr 	gxY0
.cab6	aab6	ae e1 07	ldx $07e1			ldx 	GSCurrentSpriteID 			; copy X/4 and Y/4 into the status bytes
.cab9	aab9	bd e6 07	lda $07e6,x			lda 	gxSpriteLow,x
.cabc	aabc	29 80		and #$80			and 	#$80
.cabe	aabe	0d ce 07	ora $07ce			ora 	gxX0
.cac1	aac1	9d e6 07	sta $07e6,x			sta 	gxSpriteLow,x
.cac4	aac4	bd 26 08	lda $0826,x			lda 	gxSpriteHigh,x
.cac7	aac7	29 c0		and #$c0			and 	#$C0
.cac9	aac9	0d d0 07	ora $07d0			ora 	gxY0
.cacc	aacc	9d 26 08	sta $0826,x			sta 	gxSpriteHigh,x
.cacf	aacf	18		clc				clc
.cad0	aad0	60		rts				rts
.cad1	aad1					_GXSIFail:
.cad1	aad1	38		sec				sec
.cad2	aad2	60		rts				rts
.cad3	aad3					_GXMSOffset:
>cad3	aad3	1c						.byte 	32-8/2
>cad4	aad4	18						.byte 	32-16/2
>cad5	aad5	14						.byte 	32-24/2
>cad6	aad6	10						.byte 	32-32/2
.cad7	aad7					GXOpenBitmap:
.cad7	aad7	78		sei				sei 								; no interrupts here
.cad8	aad8	a5 0b		lda $0b				lda 	GXEditSlot 					; Save the original LUT slot value
.cada	aada	8d df 07	sta $07df			sta 	gxOriginalLUTValue
.cadd	aadd	58		cli				cli
.cade	aade	60		rts				rts
.cadf	aadf					GXCloseBitmap:
.cadf	aadf	78		sei				sei
.cae0	aae0	ad df 07	lda $07df			lda 	gxOriginalLUTValue 			; restore LUT slot value
.cae3	aae3	85 0b		sta $0b				sta 	GXEditSlot
.cae5	aae5	58		cli				cli
.cae6	aae6	60		rts				rts
.cae7	aae7					gxPositionCalc:
.cae7	aae7	a5 36		lda $36				lda 	gxzTemp0 					; save temp memory slot
.cae9	aae9	48		pha				pha
.caea	aaea	ad d0 07	lda $07d0			lda 	gxY0 						; gxzScreen = Y0
.caed	aaed	85 3c		sta $3c				sta 	gxzScreen
.caef	aaef	64 3d		stz $3d				stz 	gxzScreen+1
.caf1	aaf1	06 3c		asl $3c				asl 	gxzScreen 						; gxzScreen = Y0 * 4
.caf3	aaf3	26 3d		rol $3d				rol 	gxzScreen+1
.caf5	aaf5	06 3c		asl $3c				asl 	gxzScreen
.caf7	aaf7	26 3d		rol $3d				rol 	gxzScreen+1
.caf9	aaf9	18		clc				clc 								; gxzScreen = Y0 * 5, as it's still in A
.cafa	aafa	65 3c		adc $3c				adc 	gxzScreen
.cafc	aafc	85 3c		sta $3c				sta 	gxzScreen
.cafe	aafe	90 02		bcc $ab02			bcc 	_GXPCNoCarry
.cb00	ab00	e6 3d		inc $3d				inc 	gxzScreen+1
.cb02	ab02					_GXPCNoCarry:
.cb02	ab02	06 3c		asl $3c				asl 	gxzScreen 						; now Y0 * 10. Needs to be multiplied by another
.cb04	ab04	26 3d		rol $3d				rol 	gxzScreen+1 					; 32. At this point the MSB contains the offset
.cb06	ab06	a5 3d		lda $3d				lda	 	gxzScreen+1 					; so save this in zTemp0 and zero it.
.cb08	ab08	85 36		sta $36				sta 	gxzTemp0
.cb0a	ab0a	64 3d		stz $3d				stz 	gxzScreen+1
.cb0c	ab0c	a9 05		lda #$05			lda 	#5 							; now multiply by 32, this puts this in the range 0..8191
.cb0e	ab0e					_GXPCMultiply32:
.cb0e	ab0e	06 3c		asl $3c				asl 	gxzScreen
.cb10	ab10	26 3d		rol $3d				rol 	gxzScreen+1
.cb12	ab12	3a		dec a				dec 	a
.cb13	ab13	d0 f9		bne $ab0e			bne 	_GXPCMultiply32
.cb15	ab15	18		clc				clc
.cb16	ab16	ad ce 07	lda $07ce			lda 	gxX0 						; add X to this value, put the result in gxOffset, gxzScreen has to be on a page boundary
.cb19	ab19	65 3c		adc $3c				adc 	gxzScreen
.cb1b	ab1b	8d e0 07	sta $07e0			sta 	gxOffset
.cb1e	ab1e	ad cf 07	lda $07cf			lda 	gxX0+1
.cb21	ab21	65 3d		adc $3d				adc 	gxzScreen+1
.cb23	ab23	c9 20		cmp #$20			cmp 	#$20 						; has it overflowed into the next one ?
.cb25	ab25	90 04		bcc $ab2b			bcc 	_GXPCNoOverflow
.cb27	ab27	29 1f		and #$1f			and 	#$1F 						; fix it up
.cb29	ab29	e6 36		inc $36				inc 	gxzTemp0 					; add 1 to the page number
.cb2b	ab2b					_GXPCNoOverflow:
.cb2b	ab2b	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; make it the address mapped in.
.cb2d	ab2d	85 3d		sta $3d				sta 	gxzScreen+1
.cb2f	ab2f	64 3c		stz $3c				stz 	gxzScreen
.cb31	ab31	18		clc				clc
.cb32	ab32	a5 36		lda $36				lda 	gxzTemp0 					; get the page number
.cb34	ab34	6d d8 07	adc $07d8			adc 	gxBasePage 					; by adding the base page
.cb37	ab37	85 0b		sta $0b				sta 	GXEditSlot 				; and map it into memory.
.cb39	ab39	68		pla				pla
.cb3a	ab3a	85 36		sta $36				sta 	gxzTemp0
.cb3c	ab3c	60		rts				rts
.cb3d	ab3d					GXMovePositionDown:
.cb3d	ab3d	18		clc				clc 								; add 320 to offset/temp+1
.cb3e	ab3e	ad e0 07	lda $07e0			lda 	gxOffset
.cb41	ab41	69 40		adc #$40			adc 	#64
.cb43	ab43	8d e0 07	sta $07e0			sta 	gxOffset
.cb46	ab46	a5 3d		lda $3d				lda 	gxzScreen+1
.cb48	ab48	69 01		adc #$01			adc 	#1
.cb4a	ab4a	85 3d		sta $3d				sta 	gxzScreen+1
.cb4c	ab4c	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page
.cb4e	ab4e	90 07		bcc $ab57			bcc 	_GXMPDExit
.cb50	ab50	38		sec				sec  								; next page
.cb51	ab51	e9 20		sbc #$20			sbc 	#$20
.cb53	ab53	85 3d		sta $3d				sta 	gxzScreen+1
.cb55	ab55	e6 0b		inc $0b				inc 	GXEditSlot
.cb57	ab57					_GXMPDExit:
.cb57	ab57	60		rts				rts
.cb58	ab58					GXCollide:
.cb58	ab58	a5 36		lda $36				lda 	gxzTemp0 					; check if sprite numbers are legal.
.cb5a	ab5a	aa		tax				tax
.cb5b	ab5b	05 37		ora $37				ora 	gxzTemp0+1
.cb5d	ab5d	29 c0		and #$c0			and 	#$C0
.cb5f	ab5f	38		sec				sec
.cb60	ab60	d0 53		bne $abb5			bne 	_GXCollideFail 				; if either >= 64, fail.
.cb62	ab62	a4 37		ldy $37				ldy 	gxzTemp0+1 					; at this point X is 1st sprite and Y is 2nd sprite.
.cb64	ab64	b9 e6 07	lda $07e6,y			lda 	gxSpriteLow,y 				; check if either hidden bit is set
.cb67	ab67	1d e6 07	ora $07e6,x			ora 	gxSpriteLow,x
.cb6a	ab6a	30 48		bmi $abb4			bmi 	_GXOkayFail 				; if either hidden, then they cannot collide.
.cb6c	ab6c	18		clc				clc 								; need to calculate sum of sizes.
.cb6d	ab6d	b9 26 08	lda $0826,y			lda 	gxSpriteHigh,y
.cb70	ab70	7d 26 08	adc $0826,x			adc 	gxSpriteHigh,x 				; at this point, CS, Bit 6 and 7 contain that sum.
.cb73	ab73	29 c0		and #$c0			and 	#$C0 					 	; mask off
.cb75	ab75	6a		ror a				ror 	a 							; 5/6/7
.cb76	ab76	4a		lsr a				lsr 	a 							; 4/5/6
.cb77	ab77	4a		lsr a				lsr 	a 							; 3/4/5
.cb78	ab78	4a		lsr a				lsr 	a 							; 2/3/4
.cb79	ab79	18		clc				clc
.cb7a	ab7a	69 08		adc #$08			adc 	#$08
.cb7c	ab7c	4a		lsr a				lsr 	a 							; adjust because all coordinates are divided by 4 to store.
.cb7d	ab7d	4a		lsr a				lsr 	a
.cb7e	ab7e	85 38		sta $38				sta 	gxzTemp1 					; so the difference between the centres has to be less than this.
.cb80	ab80	b9 26 08	lda $0826,y			lda 	gxSpriteHigh,y 				; calculate y1-y0
.cb83	ab83	29 3f		and #$3f			and 	#$3F
.cb85	ab85	85 39		sta $39				sta 	gxzTemp1+1
.cb87	ab87	38		sec				sec
.cb88	ab88	bd 26 08	lda $0826,x			lda 	gxSpriteHigh,x
.cb8b	ab8b	29 3f		and #$3f			and 	#$3F
.cb8d	ab8d	e5 39		sbc $39				sbc 	gxzTemp1+1
.cb8f	ab8f	b0 03		bcs $ab94			bcs 	_GXCAbs1 					; calculate |y1-y0|
.cb91	ab91	49 ff		eor #$ff			eor 	#$FF
.cb93	ab93	1a		inc a				inc 	a
.cb94	ab94					_GXCAbs1:
.cb94	ab94	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.cb96	ab96	b0 1c		bcs $abb4			bcs 	_GXOkayFail
.cb98	ab98	85 39		sta $39				sta 	gxzTemp1+1 					; save |y1-y0|
.cb9a	ab9a	38		sec				sec 								; calculate |x1-x0|
.cb9b	ab9b	b9 e6 07	lda $07e6,y			lda 	gxSpriteLow,y
.cb9e	ab9e	fd e6 07	sbc $07e6,x			sbc 	gxSpriteLow,x
.cba1	aba1	b0 03		bcs $aba6			bcs 	_GXCAbs2
.cba3	aba3	49 ff		eor #$ff			eor 	#$FF
.cba5	aba5	1a		inc a				inc 	a
.cba6	aba6					_GXCAbs2:
.cba6	aba6	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.cba8	aba8	b0 0a		bcs $abb4			bcs 	_GXOkayFail
.cbaa	abaa	c5 39		cmp $39				cmp 	gxzTemp1+1 					; is it less than the previous one.
.cbac	abac	90 02		bcc $abb0			bcc 	_GXCHaveLowest
.cbae	abae	a5 39		lda $39				lda 	gxzTemp1+1 					; if not, that's the smallest difference.
.cbb0	abb0					_GXCHaveLowest:
.cbb0	abb0	0a		asl a				asl 	a 							; scale to allow for >> 2
.cbb1	abb1	0a		asl a				asl 	a
.cbb2	abb2	18		clc				clc
.cbb3	abb3	60		rts				rts
.cbb4	abb4					_GXOkayFail:
.cbb4	abb4	18		clc				clc
.cbb5	abb5					_GXCollideFail:
.cbb5	abb5	a9 ff		lda #$ff			lda 	#$FF
.cbb7	abb7	60		rts				rts
.cbb8	abb8					GXFindSprite:
.cbb8	abb8	aa		tax				tax
.cbb9	abb9	ad d9 07	lda $07d9			lda 	gxSpritePage 				; access the base page of the sprite
.cbbc	abbc	85 0b		sta $0b				sta 	GXEditSlot
.cbbe	abbe	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; check a valid sprite
.cbc1	abc1	1d 00 60	ora $6000,x			ora 	GXMappingAddress,x
.cbc4	abc4	f0 33		beq $abf9			beq 	_GXFSFail
.cbc6	abc6	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; MSB
.cbc9	abc9	8d 7d 08	sta $087d			sta 	gxSpriteOffset+1
.cbcc	abcc	bd 00 60	lda $6000,x			lda 	GXMappingAddress,x 			; LSB
.cbcf	abcf	48		pha				pha 								; save twice
.cbd0	abd0	48		pha				pha
.cbd1	abd1	29 03		and #$03			and 	#3 							; get sprite size
.cbd3	abd3	8d 7a 08	sta $087a			sta 	gxSizeBits 					; save raw (0-3)
.cbd6	abd6	aa		tax				tax
.cbd7	abd7	bd fb ab	lda $abfb,x			lda 	_GXFXSSTTable,x 			; read sprite size
.cbda	abda	8d 79 08	sta $0879			sta 	gxSizePixels 					; save (8/16/24/32)
.cbdd	abdd	68		pla				pla 								; get LUT
.cbde	abde	4a		lsr a				lsr		a
.cbdf	abdf	4a		lsr a				lsr		a
.cbe0	abe0	29 03		and #$03			and 	#3
.cbe2	abe2	8d 7b 08	sta $087b			sta 	gxSpriteLUT
.cbe5	abe5	68		pla				pla 								; address, neeeds to be x 4
.cbe6	abe6	29 f0		and #$f0			and 	#$F0
.cbe8	abe8	8d 7c 08	sta $087c			sta 	gxSpriteOffset
.cbeb	abeb	0e 7c 08	asl $087c			asl 	gxSpriteOffset
.cbee	abee	2e 7d 08	rol $087d			rol 	gxSpriteOffset+1
.cbf1	abf1	0e 7c 08	asl $087c			asl 	gxSpriteOffset
.cbf4	abf4	2e 7d 08	rol $087d			rol 	gxSpriteOffset+1
.cbf7	abf7	18		clc				clc
.cbf8	abf8	60		rts				rts
.cbf9	abf9					_GXFSFail:
.cbf9	abf9	38		sec				sec
.cbfa	abfa	60		rts				rts
.cbfb	abfb					_GXFXSSTTable:
>cbfb	abfb	08 10 18 20					.byte 	8,16,24,32
.0879						gxSizePixels:
>0879								.fill 	1
.087a						gxSizeBits:
>087a								.fill 	1
.087b						gxSpriteLUT:
>087b								.fill 	1
.087c						gxSpriteOffset:
>087c								.fill 	2
.cbff	abff					GXSortXY:
.cbff	abff	20 1d ac	jsr $ac1d			jsr 	GXSortY 					; will be sorted on Y now
.cc02	ac02	ad ce 07	lda $07ce			lda 	gxX0 						; compare X0 v X1
.cc05	ac05	cd d2 07	cmp $07d2			cmp 	gxX1
.cc08	ac08	ad cf 07	lda $07cf			lda 	gxX0+1
.cc0b	ac0b	ed d3 07	sbc $07d3			sbc 	gxX1+1
.cc0e	ac0e	90 0c		bcc $ac1c			bcc 	_GXSXYExit 					; X0 < X1 exit
.cc10	ac10	a2 00		ldx #$00			ldx 	#0 							; swap them over
.cc12	ac12	a0 04		ldy #$04			ldy 	#4
.cc14	ac14	20 31 ac	jsr $ac31			jsr 	GXSwapXY
.cc17	ac17	e8		inx				inx
.cc18	ac18	c8		iny				iny
.cc19	ac19	20 31 ac	jsr $ac31			jsr 	GXSwapXY
.cc1c	ac1c					_GXSXYExit:
.cc1c	ac1c	60		rts				rts
.cc1d	ac1d					GXSortY:
.cc1d	ac1d	ad d0 07	lda $07d0			lda 	gxY0 						; if Y0 >= Y1
.cc20	ac20	cd d4 07	cmp $07d4			cmp 	gxY1
.cc23	ac23	90 0b		bcc $ac30			bcc 	_GXSYSorted
.cc25	ac25	a2 03		ldx #$03			ldx 	#3 							; swap 3-0
.cc27	ac27	a0 07		ldy #$07			ldy 	#7 							; with 4-7
.cc29	ac29					_GXSwap1:
.cc29	ac29	20 31 ac	jsr $ac31			jsr 	GXSwapXY
.cc2c	ac2c	88		dey				dey
.cc2d	ac2d	ca		dex				dex
.cc2e	ac2e	10 f9		bpl $ac29			bpl 	_GXSwap1
.cc30	ac30					_GXSYSorted:
.cc30	ac30	60		rts				rts
.cc31	ac31					GXSwapXY:
.cc31	ac31	bd ce 07	lda $07ce,x			lda 	gxX0,x
.cc34	ac34	48		pha				pha
.cc35	ac35	b9 ce 07	lda $07ce,y			lda 	gxX0,y
.cc38	ac38	9d ce 07	sta $07ce,x			sta 	gxX0,x
.cc3b	ac3b	68		pla				pla
.cc3c	ac3c	99 ce 07	sta $07ce,y			sta 	gxX0,y
.cc3f	ac3f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_tokeniser.module

=1						tokeniserIntegrated=1
.cc40	ac40					KeywordSet0:
>cc40	ac40	00 65					.text	0,$65,""               ; $80 !0:EOF
>cc42	ac42	00 58					.text	0,$58,""               ; $81 !1:SH1
>cc44	ac44	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>cc46	ac46	04 fe 41 42 53 28			.text	4,$fe,"ABS("           ; $83 ABS(
>cc4c	ac4c	06 93 41 4c 4c 4f 43 28			.text	6,$93,"ALLOC("         ; $84 ALLOC(
>cc54	ac54	04 ff 41 53 43 28			.text	4,$ff,"ASC("           ; $85 ASC(
>cc5a	ac5a	05 29 43 48 52 24 28			.text	5,$29,"CHR$("          ; $86 CHR$(
>cc61	ac61	06 aa 45 56 45 4e 54 28			.text	6,$aa,"EVENT("         ; $87 EVENT(
>cc69	ac69	05 6b 46 41 4c 53 45			.text	5,$6b,"FALSE"          ; $88 FALSE
>cc70	ac70	05 44 46 52 41 43 28			.text	5,$44,"FRAC("          ; $89 FRAC(
>cc77	ac77	05 2c 47 45 54 24 28			.text	5,$2c,"GET$("          ; $8a GET$(
>cc7e	ac7e	04 08 47 45 54 28			.text	4,$08,"GET("           ; $8b GET(
>cc84	ac84	09 4a 47 45 54 44 41 54			.text	9,$4a,"GETDATE$("      ; $8c GETDATE$(
>cc8c	ac8c	45 24 28
>cc8f	ac8f	09 5b 47 45 54 54 49 4d			.text	9,$5b,"GETTIME$("      ; $8d GETTIME$(
>cc97	ac97	45 24 28
>cc9a	ac9a	04 0d 48 49 54 28			.text	4,$0d,"HIT("           ; $8e HIT(
>cca0	aca0	07 cc 49 4e 4b 45 59 24			.text	7,$cc,"INKEY$("        ; $8f INKEY$(
>cca8	aca8	28
>cca9	aca9	06 a8 49 4e 4b 45 59 28			.text	6,$a8,"INKEY("         ; $90 INKEY(
>ccb1	acb1	04 13 49 4e 54 28			.text	4,$13,"INT("           ; $91 INT(
>ccb7	acb7	06 a7 49 53 56 41 4c 28			.text	6,$a7,"ISVAL("         ; $92 ISVAL(
>ccbf	acbf	0a e0 49 54 45 4d 43 4f			.text	10,$e0,"ITEMCOUNT("     ; $93 ITEMCOUNT(
>ccc7	acc7	55 4e 54 28
>cccb	accb	09 5b 49 54 45 4d 47 45			.text	9,$5b,"ITEMGET$("      ; $94 ITEMGET$(
>ccd3	acd3	54 24 28
>ccd6	acd6	05 5c 4a 4f 59 42 28			.text	5,$5c,"JOYB("          ; $95 JOYB(
>ccdd	acdd	05 72 4a 4f 59 58 28			.text	5,$72,"JOYX("          ; $96 JOYX(
>cce4	ace4	05 73 4a 4f 59 59 28			.text	5,$73,"JOYY("          ; $97 JOYY(
>cceb	aceb	08 49 4b 45 59 44 4f 57			.text	8,$49,"KEYDOWN("       ; $98 KEYDOWN(
>ccf3	acf3	4e 28
>ccf5	acf5	06 77 4c 45 46 54 24 28			.text	6,$77,"LEFT$("         ; $99 LEFT$(
>ccfd	acfd	04 07 4c 45 4e 28			.text	4,$07,"LEN("           ; $9a LEN(
>cd03	ad03	04 0e 4d 41 58 28			.text	4,$0e,"MAX("           ; $9b MAX(
>cd09	ad09	05 26 4d 49 44 24 28			.text	5,$26,"MID$("          ; $9c MID$(
>cd10	ad10	04 0c 4d 49 4e 28			.text	4,$0c,"MIN("           ; $9d MIN(
>cd16	ad16	04 19 4e 4f 54 28			.text	4,$19,"NOT("           ; $9e NOT(
>cd1c	ad1c	05 4d 50 45 45 4b 28			.text	5,$4d,"PEEK("          ; $9f PEEK(
>cd23	ad23	06 91 50 45 45 4b 44 28			.text	6,$91,"PEEKD("         ; $a0 PEEKD(
>cd2b	ad2b	06 99 50 45 45 4b 4c 28			.text	6,$99,"PEEKL("         ; $a1 PEEKL(
>cd33	ad33	06 a4 50 45 45 4b 57 28			.text	6,$a4,"PEEKW("         ; $a2 PEEKW(
>cd3b	ad3b	08 3c 50 4c 41 59 49 4e			.text	8,$3c,"PLAYING("       ; $a3 PLAYING(
>cd43	ad43	47 28
>cd45	ad45	07 e9 52 41 4e 44 4f 4d			.text	7,$e9,"RANDOM("        ; $a4 RANDOM(
>cd4d	ad4d	28
>cd4e	ad4e	07 ca 52 49 47 48 54 24			.text	7,$ca,"RIGHT$("        ; $a5 RIGHT$(
>cd56	ad56	28
>cd57	ad57	04 0c 52 4e 44 28			.text	4,$0c,"RND("           ; $a6 RND(
>cd5d	ad5d	04 10 53 47 4e 28			.text	4,$10,"SGN("           ; $a7 SGN(
>cd63	ad63	04 0e 53 50 43 28			.text	4,$0e,"SPC("           ; $a8 SPC(
>cd69	ad69	05 45 53 54 52 24 28			.text	5,$45,"STR$("          ; $a9 STR$(
>cd70	ad70	06 a9 54 49 4d 45 52 28			.text	6,$a9,"TIMER("         ; $aa TIMER(
>cd78	ad78	04 40 54 52 55 45			.text	4,$40,"TRUE"           ; $ab TRUE
>cd7e	ad7e	04 0b 56 41 4c 28			.text	4,$0b,"VAL("           ; $ac VAL(
>cd84	ad84	03 e7 46 4f 52				.text	3,$e7,"FOR"            ; $ad FOR
>cd89	ad89	02 8f 49 46				.text	2,$8f,"IF"             ; $ae IF
>cd8d	ad8d	04 34 50 52 4f 43			.text	4,$34,"PROC"           ; $af PROC
>cd93	ad93	06 c1 52 45 50 45 41 54			.text	6,$c1,"REPEAT"         ; $b0 REPEAT
>cd9b	ad9b	05 79 57 48 49 4c 45			.text	5,$79,"WHILE"          ; $b1 WHILE
>cda2	ada2	05 66 45 4e 44 49 46			.text	5,$66,"ENDIF"          ; $b2 ENDIF
>cda9	ada9	07 0b 45 4e 44 50 52 4f			.text	7,$0b,"ENDPROC"        ; $b3 ENDPROC
>cdb1	adb1	43
>cdb2	adb2	04 3f 4e 45 58 54			.text	4,$3f,"NEXT"           ; $b4 NEXT
>cdb8	adb8	04 2f 54 48 45 4e			.text	4,$2f,"THEN"           ; $b5 THEN
>cdbe	adbe	05 8c 55 4e 54 49 4c			.text	5,$8c,"UNTIL"          ; $b6 UNTIL
>cdc5	adc5	04 2e 57 45 4e 44			.text	4,$2e,"WEND"           ; $b7 WEND
>cdcb	adcb	02 95 41 54				.text	2,$95,"AT"             ; $b8 AT
>cdcf	adcf	02 9b 42 59				.text	2,$9b,"BY"             ; $b9 BY
>cdd3	add3	04 1c 43 41 4c 4c			.text	4,$1c,"CALL"           ; $ba CALL
>cdd9	add9	06 b2 43 49 52 43 4c 45			.text	6,$b2,"CIRCLE"         ; $bb CIRCLE
>cde1	ade1	05 67 43 4c 45 41 52			.text	5,$67,"CLEAR"          ; $bc CLEAR
>cde8	ade8	05 7f 43 4f 4c 4f 52			.text	5,$7f,"COLOR"          ; $bd COLOR
>cdef	adef	06 d4 43 4f 4c 4f 55 52			.text	6,$d4,"COLOUR"         ; $be COLOUR
>cdf7	adf7	04 1a 44 41 54 41			.text	4,$1a,"DATA"           ; $bf DATA
>cdfd	adfd	03 da 44 49 4d				.text	3,$da,"DIM"            ; $c0 DIM
>ce02	ae02	06 db 44 4f 57 4e 54 4f			.text	6,$db,"DOWNTO"         ; $c1 DOWNTO
>ce0a	ae0a	04 29 45 4c 53 45			.text	4,$29,"ELSE"           ; $c2 ELSE
>ce10	ae10	04 34 46 52 4f 4d			.text	4,$34,"FROM"           ; $c3 FROM
>ce16	ae16	03 e5 47 46 58				.text	3,$e5,"GFX"            ; $c4 GFX
>ce1b	ae1b	04 24 48 45 52 45			.text	4,$24,"HERE"           ; $c5 HERE
>ce21	ae21	05 63 49 4d 41 47 45			.text	5,$63,"IMAGE"          ; $c6 IMAGE
>ce28	ae28	03 e5 4c 45 54				.text	3,$e5,"LET"            ; $c7 LET
>ce2d	ae2d	04 28 4c 49 4e 45			.text	4,$28,"LINE"           ; $c8 LINE
>ce33	ae33	05 6b 4c 4f 43 41 4c			.text	5,$6b,"LOCAL"          ; $c9 LOCAL
>ce3a	ae3a	07 1a 4d 45 4d 43 4f 50			.text	7,$1a,"MEMCOPY"        ; $ca MEMCOPY
>ce42	ae42	59
>ce43	ae43	03 db 4f 46 46				.text	3,$db,"OFF"            ; $cb OFF
>ce48	ae48	02 9d 4f 4e				.text	2,$9d,"ON"             ; $cc ON
>ce4c	ae4c	07 20 4f 55 54 4c 49 4e			.text	7,$20,"OUTLINE"        ; $cd OUTLINE
>ce54	ae54	45
>ce55	ae55	07 0f 50 41 4c 45 54 54			.text	7,$0f,"PALETTE"        ; $ce PALETTE
>ce5d	ae5d	45
>ce5e	ae5e	04 3f 50 4c 4f 54			.text	4,$3f,"PLOT"           ; $cf PLOT
>ce64	ae64	04 2f 50 4f 4b 45			.text	4,$2f,"POKE"           ; $d0 POKE
>ce6a	ae6a	05 73 50 4f 4b 45 44			.text	5,$73,"POKED"          ; $d1 POKED
>ce71	ae71	05 7b 50 4f 4b 45 4c			.text	5,$7b,"POKEL"          ; $d2 POKEL
>ce78	ae78	05 86 50 4f 4b 45 57			.text	5,$86,"POKEW"          ; $d3 POKEW
>ce7f	ae7f	04 1c 52 45 41 44			.text	4,$1c,"READ"           ; $d4 READ
>ce85	ae85	04 2e 52 45 43 54			.text	4,$2e,"RECT"           ; $d5 RECT
>ce8b	ae8b	03 e4 52 45 4d				.text	3,$e4,"REM"            ; $d6 REM
>ce90	ae90	05 7b 53 4f 4c 49 44			.text	5,$7b,"SOLID"          ; $d7 SOLID
>ce97	ae97	05 89 53 4f 55 4e 44			.text	5,$89,"SOUND"          ; $d8 SOUND
>ce9e	ae9e	06 d7 53 50 52 49 54 45			.text	6,$d7,"SPRITE"         ; $d9 SPRITE
>cea6	aea6	04 45 54 45 58 54			.text	4,$45,"TEXT"           ; $da TEXT
>ceac	aeac	02 a3 54 4f				.text	2,$a3,"TO"             ; $db TO
>ceb0	aeb0	ff					.text	$FF
.ceb1	aeb1					KeywordSet1:
>ceb1	aeb1	00 65					.text	0,$65,""               ; $80 !0:EOF
>ceb3	aeb3	00 58					.text	0,$58,""               ; $81 !1:SH1
>ceb5	aeb5	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>ceb7	aeb7	08 4c 41 53 53 45 4d 42			.text	8,$4c,"ASSEMBLE"       ; $83 ASSEMBLE
>cebf	aebf	4c 45
>cec1	aec1	06 d2 41 53 53 45 52 54			.text	6,$d2,"ASSERT"         ; $84 ASSERT
>cec9	aec9	06 bd 42 49 54 4d 41 50			.text	6,$bd,"BITMAP"         ; $85 BITMAP
>ced1	aed1	05 62 42 4c 4f 41 44			.text	5,$62,"BLOAD"          ; $86 BLOAD
>ced8	aed8	05 71 42 53 41 56 45			.text	5,$71,"BSAVE"          ; $87 BSAVE
>cedf	aedf	03 e2 43 4c 53				.text	3,$e2,"CLS"            ; $88 CLS
>cee4	aee4	06 d0 43 50 52 49 4e 54			.text	6,$d0,"CPRINT"         ; $89 CPRINT
>ceec	aeec	03 df 44 49 52				.text	3,$df,"DIR"            ; $8a DIR
>cef1	aef1	03 e6 44 4f 53				.text	3,$e6,"DOS"            ; $8b DOS
>cef6	aef6	05 7a 44 52 49 56 45			.text	5,$7a,"DRIVE"          ; $8c DRIVE
>cefd	aefd	03 d7 45 4e 44				.text	3,$d7,"END"            ; $8d END
>cf02	af02	07 11 45 58 50 4c 4f 44			.text	7,$11,"EXPLODE"        ; $8e EXPLODE
>cf0a	af0a	45
>cf0b	af0b	02 96 47 4f				.text	2,$96,"GO"             ; $8f GO
>cf0f	af0f	05 80 47 4f 53 55 42			.text	5,$80,"GOSUB"          ; $90 GOSUB
>cf16	af16	04 39 47 4f 54 4f			.text	4,$39,"GOTO"           ; $91 GOTO
>cf1c	af1c	05 70 48 49 4d 45 4d			.text	5,$70,"HIMEM"          ; $92 HIMEM
>cf23	af23	05 90 49 4e 50 55 54			.text	5,$90,"INPUT"          ; $93 INPUT
>cf2a	af2a	04 3c 4c 49 53 54			.text	4,$3c,"LIST"           ; $94 LIST
>cf30	af30	04 20 4c 4f 41 44			.text	4,$20,"LOAD"           ; $95 LOAD
>cf36	af36	06 b7 4d 44 45 4c 54 41			.text	6,$b7,"MDELTA"         ; $96 MDELTA
>cf3e	af3e	05 89 4d 4f 55 53 45			.text	5,$89,"MOUSE"          ; $97 MOUSE
>cf45	af45	03 ea 4e 45 57				.text	3,$ea,"NEW"            ; $98 NEW
>cf4a	af4a	04 2e 50 49 4e 47			.text	4,$2e,"PING"           ; $99 PING
>cf50	af50	05 8d 50 52 49 4e 54			.text	5,$8d,"PRINT"          ; $9a PRINT
>cf57	af57	07 24 52 45 53 54 4f 52			.text	7,$24,"RESTORE"        ; $9b RESTORE
>cf5f	af5f	45
>cf60	af60	06 e0 52 45 54 55 52 4e			.text	6,$e0,"RETURN"         ; $9c RETURN
>cf68	af68	03 f5 52 55 4e				.text	3,$f5,"RUN"            ; $9d RUN
>cf6d	af6d	04 2f 53 41 56 45			.text	4,$2f,"SAVE"           ; $9e SAVE
>cf73	af73	07 0a 53 45 54 44 41 54			.text	7,$0a,"SETDATE"        ; $9f SETDATE
>cf7b	af7b	45
>cf7c	af7c	07 1b 53 45 54 54 49 4d			.text	7,$1b,"SETTIME"        ; $a0 SETTIME
>cf84	af84	45
>cf85	af85	05 8d 53 48 4f 4f 54			.text	5,$8d,"SHOOT"          ; $a1 SHOOT
>cf8c	af8c	07 2a 53 50 52 49 54 45			.text	7,$2a,"SPRITES"        ; $a2 SPRITES
>cf94	af94	53
>cf95	af95	04 46 53 54 4f 50			.text	4,$46,"STOP"           ; $a3 STOP
>cf9b	af9b	06 d5 56 45 52 49 46 59			.text	6,$d5,"VERIFY"         ; $a4 VERIFY
>cfa3	afa3	03 ee 58 47 4f				.text	3,$ee,"XGO"            ; $a5 XGO
>cfa8	afa8	05 78 58 4c 4f 41 44			.text	5,$78,"XLOAD"          ; $a6 XLOAD
>cfaf	afaf	03 eb 5a 41 50				.text	3,$eb,"ZAP"            ; $a7 ZAP
>cfb4	afb4	ff					.text	$FF
.cfb5	afb5					KeywordSet2:
>cfb5	afb5	00 65					.text	0,$65,""               ; $80 !0:EOF
>cfb7	afb7	00 58					.text	0,$58,""               ; $81 !1:SH1
>cfb9	afb9	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>cfbb	afbb	03 c8 41 44 43				.text	3,$c8,"ADC"            ; $83 ADC
>cfc0	afc0	03 d3 41 4e 44				.text	3,$d3,"AND"            ; $84 AND
>cfc5	afc5	03 e0 41 53 4c				.text	3,$e0,"ASL"            ; $85 ASL
>cfca	afca	03 c8 42 43 43				.text	3,$c8,"BCC"            ; $86 BCC
>cfcf	afcf	03 d8 42 43 53				.text	3,$d8,"BCS"            ; $87 BCS
>cfd4	afd4	03 d8 42 45 51				.text	3,$d8,"BEQ"            ; $88 BEQ
>cfd9	afd9	03 df 42 49 54				.text	3,$df,"BIT"            ; $89 BIT
>cfde	afde	03 d8 42 4d 49				.text	3,$d8,"BMI"            ; $8a BMI
>cfe3	afe3	03 d5 42 4e 45				.text	3,$d5,"BNE"            ; $8b BNE
>cfe8	afe8	03 de 42 50 4c				.text	3,$de,"BPL"            ; $8c BPL
>cfed	afed	03 d5 42 52 41				.text	3,$d5,"BRA"            ; $8d BRA
>cff2	aff2	03 df 42 52 4b				.text	3,$df,"BRK"            ; $8e BRK
>cff7	aff7	03 db 42 56 43				.text	3,$db,"BVC"            ; $8f BVC
>cffc	affc	03 eb 42 56 53				.text	3,$eb,"BVS"            ; $90 BVS
>d001	b001	03 d2 43 4c 43				.text	3,$d2,"CLC"            ; $91 CLC
>d006	b006	03 d3 43 4c 44				.text	3,$d3,"CLD"            ; $92 CLD
>d00b	b00b	03 d8 43 4c 49				.text	3,$d8,"CLI"            ; $93 CLI
>d010	b010	03 e5 43 4c 56				.text	3,$e5,"CLV"            ; $94 CLV
>d015	b015	03 e0 43 4d 50				.text	3,$e0,"CMP"            ; $95 CMP
>d01a	b01a	03 eb 43 50 58				.text	3,$eb,"CPX"            ; $96 CPX
>d01f	b01f	03 ec 43 50 59				.text	3,$ec,"CPY"            ; $97 CPY
>d024	b024	03 cc 44 45 43				.text	3,$cc,"DEC"            ; $98 DEC
>d029	b029	03 e1 44 45 58				.text	3,$e1,"DEX"            ; $99 DEX
>d02e	b02e	03 e2 44 45 59				.text	3,$e2,"DEY"            ; $9a DEY
>d033	b033	03 e6 45 4f 52				.text	3,$e6,"EOR"            ; $9b EOR
>d038	b038	03 da 49 4e 43				.text	3,$da,"INC"            ; $9c INC
>d03d	b03d	03 ef 49 4e 58				.text	3,$ef,"INX"            ; $9d INX
>d042	b042	03 f0 49 4e 59				.text	3,$f0,"INY"            ; $9e INY
>d047	b047	03 e7 4a 4d 50				.text	3,$e7,"JMP"            ; $9f JMP
>d04c	b04c	03 ef 4a 53 52				.text	3,$ef,"JSR"            ; $a0 JSR
>d051	b051	03 d1 4c 44 41				.text	3,$d1,"LDA"            ; $a1 LDA
>d056	b056	03 e8 4c 44 58				.text	3,$e8,"LDX"            ; $a2 LDX
>d05b	b05b	03 e9 4c 44 59				.text	3,$e9,"LDY"            ; $a3 LDY
>d060	b060	03 f1 4c 53 52				.text	3,$f1,"LSR"            ; $a4 LSR
>d065	b065	03 ed 4e 4f 50				.text	3,$ed,"NOP"            ; $a5 NOP
>d06a	b06a	03 e2 4f 52 41				.text	3,$e2,"ORA"            ; $a6 ORA
>d06f	b06f	03 d9 50 48 41				.text	3,$d9,"PHA"            ; $a7 PHA
>d074	b074	03 e8 50 48 50				.text	3,$e8,"PHP"            ; $a8 PHP
>d079	b079	03 f0 50 48 58				.text	3,$f0,"PHX"            ; $a9 PHX
>d07e	b07e	03 f1 50 48 59				.text	3,$f1,"PHY"            ; $aa PHY
>d083	b083	03 dd 50 4c 41				.text	3,$dd,"PLA"            ; $ab PLA
>d088	b088	03 ec 50 4c 50				.text	3,$ec,"PLP"            ; $ac PLP
>d08d	b08d	03 f4 50 4c 58				.text	3,$f4,"PLX"            ; $ad PLX
>d092	b092	03 f5 50 4c 59				.text	3,$f5,"PLY"            ; $ae PLY
>d097	b097	03 ed 52 4f 4c				.text	3,$ed,"ROL"            ; $af ROL
>d09c	b09c	03 f3 52 4f 52				.text	3,$f3,"ROR"            ; $b0 ROR
>d0a1	b0a1	03 ef 52 54 49				.text	3,$ef,"RTI"            ; $b1 RTI
>d0a6	b0a6	03 f9 52 54 53				.text	3,$f9,"RTS"            ; $b2 RTS
>d0ab	b0ab	03 d8 53 42 43				.text	3,$d8,"SBC"            ; $b3 SBC
>d0b0	b0b0	03 db 53 45 43				.text	3,$db,"SEC"            ; $b4 SEC
>d0b5	b0b5	03 dc 53 45 44				.text	3,$dc,"SED"            ; $b5 SED
>d0ba	b0ba	03 e1 53 45 49				.text	3,$e1,"SEI"            ; $b6 SEI
>d0bf	b0bf	03 e8 53 54 41				.text	3,$e8,"STA"            ; $b7 STA
>d0c4	b0c4	03 f7 53 54 50				.text	3,$f7,"STP"            ; $b8 STP
>d0c9	b0c9	03 ff 53 54 58				.text	3,$ff,"STX"            ; $b9 STX
>d0ce	b0ce	03 00 53 54 59				.text	3,$00,"STY"            ; $ba STY
>d0d3	b0d3	03 01 53 54 5a				.text	3,$01,"STZ"            ; $bb STZ
>d0d8	b0d8	03 ed 54 41 58				.text	3,$ed,"TAX"            ; $bc TAX
>d0dd	b0dd	03 ee 54 41 59				.text	3,$ee,"TAY"            ; $bd TAY
>d0e2	b0e2	03 e8 54 52 42				.text	3,$e8,"TRB"            ; $be TRB
>d0e7	b0e7	03 e9 54 53 42				.text	3,$e9,"TSB"            ; $bf TSB
>d0ec	b0ec	03 ff 54 53 58				.text	3,$ff,"TSX"            ; $c0 TSX
>d0f1	b0f1	03 ed 54 58 41				.text	3,$ed,"TXA"            ; $c1 TXA
>d0f6	b0f6	03 ff 54 58 53				.text	3,$ff,"TXS"            ; $c2 TXS
>d0fb	b0fb	03 ee 54 59 41				.text	3,$ee,"TYA"            ; $c3 TYA
>d100	b100	ff					.text	$FF
.d101	b101					Export_TKListConvertLine:
.d101	b101	48		pha				pha 								; save indent on the stack
.d102	b102	9c 19 04	stz $0419			stz 	tbOffset
.d105	b105	9c 29 04	stz $0429			stz 	tokenBuffer
.d108	b108	9c 25 04	stz $0425			stz 	currentListColour
.d10b	b10b	a9 8d		lda #$8d			lda 	#CLILineNumber+$80
.d10d	b10d	20 8a b2	jsr $b28a			jsr 	LCLWriteColour
.d110	b110	a0 02		ldy #$02			ldy 	#2 							; convert line number to string
.d112	b112	b1 30		lda ($30),y			lda 	(codePtr),y
.d114	b114	aa		tax				tax
.d115	b115	88		dey				dey
.d116	b116	b1 30		lda ($30),y			lda 	(codePtr),y
.d118	b118	20 fb b2	jsr $b2fb			jsr 	LCLWriteNumberXA
.d11b	b11b	68		pla				pla 								; adjustment to indent
.d11c	b11c	48		pha				pha 								; save on stack
.d11d	b11d	10 0c		bpl $b12b			bpl 	_LCNoAdjust 				; don't adjust indent if +ve, do after.
.d11f	b11f	18		clc				clc 								; add to list indent and make 0 if goes -ve.
.d120	b120	6d 22 04	adc $0422			adc 	listIndent
.d123	b123	8d 22 04	sta $0422			sta 	listIndent
.d126	b126	10 03		bpl $b12b			bpl 	_LCNoAdjust
.d128	b128	9c 22 04	stz $0422			stz 	listIndent
.d12b	b12b					_LCNoAdjust:
.d12b	b12b	18		clc				clc		 							; work out actual indent.
.d12c	b12c	ad 22 04	lda $0422			lda 	listIndent
.d12f	b12f	0a		asl a				asl 	a
.d130	b130	69 07		adc #$07			adc 	#7
.d132	b132	85 36		sta $36				sta 	zTemp0
.d134	b134					_LCPadOut:
.d134	b134	a9 20		lda #$20			lda 	#' '						; pad out to 6+indent characters
.d136	b136	20 93 b2	jsr $b293			jsr 	LCLWrite
.d139	b139	ad 19 04	lda $0419			lda 	tbOffset
.d13c	b13c	c5 36		cmp $36				cmp 	zTemp0
.d13e	b13e	d0 f4		bne $b134			bne 	_LCPadOut
.d140	b140	a0 03		ldy #$03			ldy 	#3 							; start position.
.d142	b142					_LCMainLoop:
.d142	b142	a9 8c		lda #$8c			lda 	#CLIPunctuation+$80
.d144	b144	20 8a b2	jsr $b28a			jsr 	LCLWriteColour
.d147	b147	b1 30		lda ($30),y			lda 	(codePtr),y
.d149	b149	c9 80		cmp #$80			cmp 	#KWC_EOL 					; end of line ?
.d14b	b14b	f0 17		beq $b164			beq 	_LCExit
.d14d	b14d	c9 10		cmp #$10			cmp 	#16 						; 0-5 are the double punctuations
.d14f	b14f	90 1e		bcc $b16f			bcc 	_LCDoubles
.d151	b151	c9 20		cmp #$20			cmp 	#32 						; 16-31 are shifted punctuation from 64-91
.d153	b153	90 2a		bcc $b17f			bcc 	_LCShiftPunc
.d155	b155	c9 40		cmp #$40			cmp 	#64 						; 32-64 are as stored, punc and digits
.d157	b157	90 35		bcc $b18e			bcc 	_LCPunctuation
.d159	b159	c9 80		cmp #$80			cmp 	#128 						; 64-127 are variable identifiers.
.d15b	b15b	90 51		bcc $b1ae			bcc 	_LCIdentifiers
.d15d	b15d	c9 fe		cmp #$fe			cmp 	#254 						; 128-253 are tokenised words
.d15f	b15f	90 73		bcc $b1d4			bcc 	_LCTokens
.d161	b161	4c 34 b2	jmp $b234			jmp 	_LCData 					; 254-5 are data objects
.d164	b164					_LCExit:
.d164	b164	68		pla				pla 								; get old indent adjust
.d165	b165	30 07		bmi $b16e			bmi 	_LCExit2
.d167	b167	18		clc				clc 								; add to indent if +ve
.d168	b168	6d 22 04	adc $0422			adc 	listIndent
.d16b	b16b	8d 22 04	sta $0422			sta 	listIndent
.d16e	b16e					_LCExit2:
.d16e	b16e	60		rts				rts
.d16f	b16f					_LCDoubles:
.d16f	b16f	48		pha				pha
.d170	b170	4a		lsr a				lsr 	a 							; put bit 2 into bit 1
.d171	b171	29 02		and #$02			and 	#2
.d173	b173	09 3c		ora #$3c			ora 	#60 						; make < >
.d175	b175	20 93 b2	jsr $b293			jsr 	LCLWrite
.d178	b178	68		pla				pla 								; restore, do lower bit
.d179	b179	29 03		and #$03			and 	#3
.d17b	b17b	09 3c		ora #$3c			ora 	#60
.d17d	b17d	80 0f		bra $b18e			bra		_LCPunctuation 				; print, increment, loop
.d17f	b17f					_LCShiftPunc:
.d17f	b17f	aa		tax				tax 								; save in X
.d180	b180	29 07		and #$07			and 	#7 							; lower 3 bits
.d182	b182	f0 02		beq $b186			beq 	_LCNoAdd
.d184	b184	09 18		ora #$18			ora 	#24 						; adds $18 to it.
.d186	b186					_LCNoAdd:
.d186	b186	e0 18		cpx #$18			cpx 	#24 						; if >= 24 add $20
.d188	b188	90 02		bcc $b18c			bcc 	_LCNoAdd2
.d18a	b18a	09 20		ora #$20			ora 	#32 						; adds $20
.d18c	b18c					_LCNoAdd2:
.d18c	b18c	09 40		ora #$40			ora 	#$40 						; shift into 64-127 range and fall through.
.d18e	b18e					_LCPunctuation:
.d18e	b18e	c9 3a		cmp #$3a			cmp 	#':' 						; check if :
.d190	b190	d0 03		bne $b195			bne 	_LCPContinue
.d192	b192	20 a9 b2	jsr $b2a9			jsr 	LCLDeleteLastSpace 			; if so delete any preceding spaces
.d195	b195					_LCPContinue:
.d195	b195	c9 2e		cmp #$2e			cmp 	#'.'
.d197	b197	f0 08		beq $b1a1			beq 	_LCPIsConstant
.d199	b199	c9 30		cmp #$30			cmp 	#'0'
.d19b	b19b	90 0b		bcc $b1a8			bcc 	_LCPNotConstant
.d19d	b19d	c9 3a		cmp #$3a			cmp 	#'9'+1
.d19f	b19f	b0 07		bcs $b1a8			bcs 	_LCPNotConstant
.d1a1	b1a1					_LCPIsConstant:
.d1a1	b1a1	48		pha				pha
.d1a2	b1a2	a9 87		lda #$87			lda 	#CLIConstant+$80
.d1a4	b1a4	20 8a b2	jsr $b28a			jsr 	LCLWriteColour
.d1a7	b1a7	68		pla				pla
.d1a8	b1a8					_LCPNotConstant:
.d1a8	b1a8	c8		iny				iny 								; consume character
.d1a9	b1a9	20 93 b2	jsr $b293			jsr 	LCLWrite 					; write it out.
.d1ac	b1ac	80 94		bra $b142			bra 	_LCMainLoop 				; go round again.
.d1ae	b1ae					_LCIdentifiers:
.d1ae	b1ae	18		clc				clc 								; convert to physical address
.d1af	b1af	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.d1b1	b1b1	85 37		sta $37				sta 	zTemp0+1
.d1b3	b1b3	c8		iny				iny
.d1b4	b1b4	b1 30		lda ($30),y			lda 	(codePtr),y
.d1b6	b1b6	85 36		sta $36				sta 	zTemp0
.d1b8	b1b8	c8		iny				iny
.d1b9	b1b9	5a		phy				phy 								; save position
.d1ba	b1ba	a9 8e		lda #$8e			lda 	#CLIIdentifier+$80
.d1bc	b1bc	20 8a b2	jsr $b28a			jsr 	LCLWriteColour
.d1bf	b1bf	a0 07		ldy #$07			ldy 	#7 							; output the identifier at +8
.d1c1	b1c1					_LCOutIdentifier:
.d1c1	b1c1	c8		iny				iny
.d1c2	b1c2	b1 36		lda ($36),y			lda 	(zTemp0),y					; bit 7 set = end.
.d1c4	b1c4	29 7f		and #$7f			and 	#$7F
.d1c6	b1c6	20 e5 b2	jsr $b2e5			jsr 	LCLLowerCase
.d1c9	b1c9	20 93 b2	jsr $b293			jsr 	LCLWrite
.d1cc	b1cc	b1 36		lda ($36),y			lda 	(zTemp0),y				 	; ends when bit 7 set.
.d1ce	b1ce	10 f1		bpl $b1c1			bpl 	_LCOutIdentifier
.d1d0	b1d0	7a		ply				ply 								; restore position
.d1d1	b1d1	4c 42 b1	jmp $b142			jmp 	_LCMainLoop
.d1d4	b1d4					_LCTokens:
.d1d4	b1d4	aa		tax				tax 								; token in X
.d1d5	b1d5	a9 b5		lda #$b5			lda 	#((KeywordSet2) & $FF)
.d1d7	b1d7	85 36		sta $36				sta 	0+zTemp0
.d1d9	b1d9	a9 af		lda #$af			lda 	#((KeywordSet2) >> 8)
.d1db	b1db	85 37		sta $37				sta 	1+zTemp0
.d1dd	b1dd	e0 82		cpx #$82			cpx 	#$82
.d1df	b1df	f0 16		beq $b1f7			beq 	_LCUseShift
.d1e1	b1e1	a9 b1		lda #$b1			lda 	#((KeywordSet1) & $FF)
.d1e3	b1e3	85 36		sta $36				sta 	0+zTemp0
.d1e5	b1e5	a9 ae		lda #$ae			lda 	#((KeywordSet1) >> 8)
.d1e7	b1e7	85 37		sta $37				sta 	1+zTemp0
.d1e9	b1e9	e0 81		cpx #$81			cpx 	#$81
.d1eb	b1eb	f0 0a		beq $b1f7			beq 	_LCUseShift
.d1ed	b1ed	a9 40		lda #$40			lda 	#((KeywordSet0) & $FF)
.d1ef	b1ef	85 36		sta $36				sta 	0+zTemp0
.d1f1	b1f1	a9 ac		lda #$ac			lda 	#((KeywordSet0) >> 8)
.d1f3	b1f3	85 37		sta $37				sta 	1+zTemp0
.d1f5	b1f5	80 01		bra $b1f8			bra 	_LCNoShift
.d1f7	b1f7					_LCUseShift:
.d1f7	b1f7	c8		iny				iny
.d1f8	b1f8					_LCNoShift:
.d1f8	b1f8	20 bd b2	jsr $b2bd			jsr 	LCLCheckSpaceRequired 		; do we need a space ?
.d1fb	b1fb	b1 30		lda ($30),y			lda 	(codePtr),y
.d1fd	b1fd	aa		tax				tax 								; into X
.d1fe	b1fe					_LCFindText:
.d1fe	b1fe	ca		dex				dex
.d1ff	b1ff	10 0e		bpl $b20f			bpl 	_LCFoundText 				; found text.
.d201	b201	b2 36		lda ($36)			lda 	(zTemp0) 					; length of text
.d203	b203	1a		inc a				inc 	a 							; one extra for size
.d204	b204	38		sec				sec 								; one extra for checksum
.d205	b205	65 36		adc $36				adc 	zTemp0 						; go to next token
.d207	b207	85 36		sta $36				sta 	zTemp0
.d209	b209	90 f3		bcc $b1fe			bcc 	_LCFindText
.d20b	b20b	e6 37		inc $37				inc 	zTemp0+1
.d20d	b20d	80 ef		bra $b1fe			bra 	_LCFindText
.d20f	b20f					_LCFoundText:
.d20f	b20f	5a		phy				phy 								; save List position
.d210	b210	b2 36		lda ($36)			lda 	(zTemp0)					; count to print
.d212	b212	aa		tax				tax
.d213	b213	a9 86		lda #$86			lda 	#CLIToken+$80
.d215	b215	20 8a b2	jsr $b28a			jsr 	LCLWriteColour
.d218	b218	a0 02		ldy #$02			ldy 	#2
.d21a	b21a					_LCCopyToken:
.d21a	b21a	b1 36		lda ($36),y			lda 	(zTemp0),y
.d21c	b21c	20 e5 b2	jsr $b2e5			jsr 	LCLLowerCase
.d21f	b21f	20 93 b2	jsr $b293			jsr 	LCLWrite
.d222	b222	c8		iny				iny
.d223	b223	ca		dex				dex
.d224	b224	d0 f4		bne $b21a			bne 	_LCCopyToken
.d226	b226	c9 28		cmp #$28			cmp 	#"(" 						; if last char not ( print a space
.d228	b228	f0 05		beq $b22f			beq 	_LCNoSpace
.d22a	b22a	a9 20		lda #$20			lda 	#' '
.d22c	b22c	20 93 b2	jsr $b293			jsr 	LCLWrite
.d22f	b22f					_LCNoSpace:
.d22f	b22f	7a		ply				ply 								; restore position.
.d230	b230	c8		iny				iny 								; consume token
.d231	b231	4c 42 b1	jmp $b142			jmp 	_LCMainLoop 				; and go around again.
.d234	b234					_LCData:
.d234	b234	48		pha				pha 								; save type $FE/$FF
.d235	b235	a2 24		ldx #$24			ldx 	#'$' 						; figure out $ or "
.d237	b237	c9 fe		cmp #$fe			cmp 	#$FE
.d239	b239	f0 22		beq $b25d			beq 	_LCHaveOpener
.d23b	b23b	a2 22		ldx #$22			ldx 	#'"'
.d23d	b23d	a9 8f		lda #$8f			lda 	#CLIData+$80
.d23f	b23f	20 8a b2	jsr $b28a			jsr 	LCLWriteColour
.d242	b242	c0 04		cpy #$04			cpy 	#4 							; must be 2nd thing on line
.d244	b244	d0 17		bne $b25d			bne 	_LCHaveOpener
.d246	b246	88		dey				dey 								; what precedes it ?
.d247	b247	b1 30		lda ($30),y			lda 	(codePtr),y
.d249	b249	c8		iny				iny
.d24a	b24a	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; if quote
.d24c	b24c	d0 0f		bne $b25d			bne 	_LCHaveOpener
.d24e	b24e	a9 09		lda #$09			lda 	#9 							; tab
.d250	b250	20 93 b2	jsr $b293			jsr 	LCLWrite
.d253	b253	a9 9e		lda #$9e			lda 	#$90+CLIBComment
.d255	b255	20 93 b2	jsr $b293			jsr 	LCLWrite
.d258	b258	a9 85		lda #$85			lda 	#CLIFComment+$80
.d25a	b25a	20 8a b2	jsr $b28a			jsr 	LCLWriteColour
.d25d	b25d					_LCHaveOpener:
.d25d	b25d	8a		txa				txa 								; output prefix (# or ")
.d25e	b25e	20 93 b2	jsr $b293			jsr 	LCLWrite
.d261	b261	c8		iny				iny 								; get count
.d262	b262	b1 30		lda ($30),y			lda 	(codePtr),y
.d264	b264	aa		tax				tax
.d265	b265	c8		iny				iny 								; point at first character
.d266	b266					_LCOutData:
.d266	b266	b1 30		lda ($30),y			lda 	(codePtr),y
.d268	b268	c9 00		cmp #$00			cmp 	#0
.d26a	b26a	f0 03		beq $b26f			beq 	_LCNoPrint
.d26c	b26c	20 93 b2	jsr $b293			jsr 	LCLWrite
.d26f	b26f					_LCNoPrint:
.d26f	b26f	c8		iny				iny
.d270	b270	ca		dex				dex
.d271	b271	d0 f3		bne $b266			bne 	_LCOutData
.d273	b273	68		pla				pla 								; closing " required ?
.d274	b274	c9 ff		cmp #$ff			cmp 	#$FF 						; not required for hex constant.
.d276	b276	d0 0f		bne $b287			bne 	_LCNoQuote
.d278	b278	a9 22		lda #$22			lda 	#'"'
.d27a	b27a	20 93 b2	jsr $b293			jsr 	LCLWrite
.d27d	b27d	ad c3 07	lda $07c3			lda 	EXTTextColour
.d280	b280	29 0f		and #$0f			and 	#$0F
.d282	b282	09 90		ora #$90			ora 	#$90
.d284	b284	20 93 b2	jsr $b293			jsr 	LCLWrite
.d287	b287					_LCNoQuote:
.d287	b287	4c 42 b1	jmp $b142			jmp 	_LCMainLoop
.d28a	b28a					LCLWriteColour:
.d28a	b28a	cd 25 04	cmp $0425			cmp 	currentListColour 			; has the colour changed
.d28d	b28d	8d 25 04	sta $0425			sta 	currentListColour 			; (update it anyway)
.d290	b290	d0 01		bne $b293			bne 	LCLWrite 					; if different, output it
.d292	b292	60		rts				rts
.d293	b293					LCLWrite:
.d293	b293	da		phx				phx
.d294	b294	ae 19 04	ldx $0419			ldx 	tbOffset 					; write out make ASCIIZ
.d297	b297	9d 29 04	sta $0429,x			sta 	tokenBuffer,x
.d29a	b29a	9e 2a 04	stz $042a,x			stz 	tokenBuffer+1,x
.d29d	b29d	ee 19 04	inc $0419			inc 	tbOffset 					; bump the position
.d2a0	b2a0	09 00		ora #$00			ora 	#0 							; don't update last character if colour data
.d2a2	b2a2	30 03		bmi $b2a7			bmi 	_LCLNoColour
.d2a4	b2a4	8d 23 04	sta $0423			sta 	lcLastCharacter
.d2a7	b2a7					_LCLNoColour:
.d2a7	b2a7	fa		plx				plx
.d2a8	b2a8	60		rts				rts
.d2a9	b2a9					LCLDeleteLastSpace:
.d2a9	b2a9	48		pha				pha
.d2aa	b2aa	da		phx				phx
.d2ab	b2ab	ae 19 04	ldx $0419			ldx 	tbOffset
.d2ae	b2ae	f0 0a		beq $b2ba			beq 	_LCDLSExit
.d2b0	b2b0	bd 28 04	lda $0428,x			lda 	tokenBuffer-1,x
.d2b3	b2b3	c9 20		cmp #$20			cmp 	#' '
.d2b5	b2b5	d0 03		bne $b2ba			bne 	_LCDLSExit
.d2b7	b2b7	ce 19 04	dec $0419			dec 	tbOffset
.d2ba	b2ba					_LCDLSExit:
.d2ba	b2ba	fa		plx				plx
.d2bb	b2bb	68		pla				pla
.d2bc	b2bc	60		rts				rts
.d2bd	b2bd					LCLCheckSpaceRequired:
.d2bd	b2bd	ad 23 04	lda $0423			lda 	lcLastCharacter 			; check last character
.d2c0	b2c0	c9 24		cmp #$24			cmp 	#'$' 						; $ # and ) require that token space.
.d2c2	b2c2	f0 1b		beq $b2df			beq 	_LCCSRSpace
.d2c4	b2c4	c9 29		cmp #$29			cmp 	#')'
.d2c6	b2c6	f0 17		beq $b2df			beq 	_LCCSRSpace
.d2c8	b2c8	c9 23		cmp #$23			cmp 	#'#'
.d2ca	b2ca	f0 13		beq $b2df			beq 	_LCCSRSpace
.d2cc	b2cc	20 e5 b2	jsr $b2e5			jsr 	LCLLowerCase 				; saves a little effort
.d2cf	b2cf	c9 30		cmp #$30			cmp 	#"0" 						; check if it was 0-9 A-Z a-z if so need space.
.d2d1	b2d1	90 11		bcc $b2e4			bcc 	_LCCSRExit
.d2d3	b2d3	c9 3a		cmp #$3a			cmp 	#"9"+1
.d2d5	b2d5	90 08		bcc $b2df			bcc 	_LCCSRSpace
.d2d7	b2d7	c9 61		cmp #$61			cmp 	#"a"
.d2d9	b2d9	90 09		bcc $b2e4			bcc 	_LCCSRExit
.d2db	b2db	c9 7b		cmp #$7b			cmp 	#"z"+1
.d2dd	b2dd	b0 05		bcs $b2e4			bcs 	_LCCSRExit
.d2df	b2df					_LCCSRSpace:
.d2df	b2df	a9 20		lda #$20			lda 	#' '
.d2e1	b2e1	20 93 b2	jsr $b293			jsr 	LCLWrite
.d2e4	b2e4					_LCCSRExit:
.d2e4	b2e4	60		rts				rts
.d2e5	b2e5					LCLLowerCase:
.d2e5	b2e5	c9 41		cmp #$41			cmp 	#"A"
.d2e7	b2e7	90 06		bcc $b2ef			bcc 	_LCLLCOut
.d2e9	b2e9	c9 5b		cmp #$5b			cmp 	#"Z"+1
.d2eb	b2eb	b0 02		bcs $b2ef			bcs 	_LCLLCOut
.d2ed	b2ed	69 20		adc #$20			adc 	#$20
.d2ef	b2ef					_LCLLCOut:
.d2ef	b2ef	60		rts				rts
.d2f0	b2f0					LCLUpperCase:
.d2f0	b2f0	c9 61		cmp #$61			cmp 	#"a"
.d2f2	b2f2	90 06		bcc $b2fa			bcc 	_LCLUCOut
.d2f4	b2f4	c9 7b		cmp #$7b			cmp 	#"z"+1
.d2f6	b2f6	b0 02		bcs $b2fa			bcs 	_LCLUCOut
.d2f8	b2f8	e9 1f		sbc #$1f			sbc 	#$1F
.d2fa	b2fa					_LCLUCOut:
.d2fa	b2fa	60		rts				rts
.d2fb	b2fb					LCLWriteNumberXA:
.d2fb	b2fb	64 37		stz $37				stz 	zTemp0+1 					; index into digit table.
.d2fd	b2fd					_LCLWNLoop1:
.d2fd	b2fd	64 36		stz $36				stz 	zTemp0 						; subtraction count.
.d2ff	b2ff					_LCLWNLoop2:
.d2ff	b2ff	48		pha				pha 								; save initial LSB
.d300	b300	38		sec				sec
.d301	b301	a4 37		ldy $37				ldy 	zTemp0+1 					; position in table.
.d303	b303	f9 34 b3	sbc $b334,y			sbc 	_LCLWNTable,y
.d306	b306	48		pha				pha
.d307	b307	8a		txa				txa
.d308	b308	f9 35 b3	sbc $b335,y			sbc 	_LCLWNTable+1,y
.d30b	b30b	90 07		bcc $b314			bcc 	_LCLWNUnderflow
.d30d	b30d	e6 36		inc $36				inc 	zTemp0  					; subtracted one without borrow.
.d30f	b30f	aa		tax				tax 								; update X
.d310	b310	68		pla				pla 								; restore A
.d311	b311	7a		ply				ply 								; throw original
.d312	b312	80 eb		bra $b2ff			bra 	_LCLWNLoop2 				; try again.
.d314	b314					_LCLWNUnderflow:
.d314	b314	a4 36		ldy $36				ldy 	zTemp0 						; count of subtractions.
.d316	b316	d0 06		bne $b31e			bne 	_LCLWNOut
.d318	b318	ad 19 04	lda $0419			lda 	tbOffset 					; suppress leading zeroes
.d31b	b31b	3a		dec a				dec 	a
.d31c	b31c	f0 04		beq $b322			beq 	_LCLWNNext
.d31e	b31e					_LCLWNOut:
.d31e	b31e	98		tya				tya
.d31f	b31f	20 2e b3	jsr $b32e			jsr 	_LCLWNOutDigit
.d322	b322					_LCLWNNext:
.d322	b322	7a		ply				ply 							 	; restore original value.
.d323	b323	68		pla				pla
.d324	b324	a4 37		ldy $37				ldy 	zTemp0+1  					; bump the index
.d326	b326	c8		iny				iny
.d327	b327	c8		iny				iny
.d328	b328	84 37		sty $37				sty 	zTemp0+1
.d32a	b32a	c0 08		cpy #$08			cpy 	#8 							; done all 4
.d32c	b32c	d0 cf		bne $b2fd			bne 	_LCLWNLoop1
.d32e	b32e					_LCLWNOutDigit:
.d32e	b32e	09 30		ora #$30			ora 	#'0'
.d330	b330	20 93 b2	jsr $b293			jsr 	LCLWrite
.d333	b333	60		rts				rts
.d334	b334					_LCLWNTable:
>d334	b334	10 27						.word 	10000
>d336	b336	e8 03						.word 	1000
>d338	b338	64 00						.word 	100
>d33a	b33a	0a 00						.word 	10
.d33c	b33c					TOKSearchTable:
.d33c	b33c	84 37		sty $37				sty 	zTemp0+1 					; (zTemp0),y points to current token being tested.
.d33e	b33e	85 36		sta $36				sta 	zTemp0
.d340	b340	a0 00		ldy #$00			ldy 	#0
.d342	b342	a9 80		lda #$80			lda 	#$80 						; token # so we know which one we are looking at
.d344	b344	85 38		sta $38				sta 	zTemp1
.d346	b346					_TSTLoop:
.d346	b346	b1 36		lda ($36),y			lda 	(zTemp0),y 					; length, 0 (skip) -ve (end)
.d348	b348	30 49		bmi $b393			bmi 	_TSTFail 					; -ve = end of table, so fail.
.d34a	b34a	f0 2e		beq $b37a			beq 	_TSTNext 					; zero, check next as it's a dummy (e.g. EOL, SHIFT)
.d34c	b34c	c8		iny				iny 								; get the hash
.d34d	b34d	b1 36		lda ($36),y			lda 	(zTemp0),y
.d34f	b34f	88		dey				dey
.d350	b350	cd 03 04	cmp $0403			cmp 	identHash 					; check they match with the identifier hash, if not go to next
.d353	b353	d0 25		bne $b37a			bne 	_TSTNext
.d355	b355	ad 02 04	lda $0402			lda 	identTypeEnd 				; get length of identifier from end-start
.d358	b358	38		sec				sec
.d359	b359	ed 00 04	sbc $0400			sbc 	identStart
.d35c	b35c	d1 36		cmp ($36),y			cmp 	(zTemp0),y 					; compare against the length in the table, no match, then return.
.d35e	b35e	d0 1a		bne $b37a			bne 	_TSTNext
.d360	b360	5a		phy				phy 								; save Y , we might fail to match.
.d361	b361	c8		iny				iny 								; point to text
.d362	b362	c8		iny				iny
.d363	b363	ae 00 04	ldx $0400			ldx 	identStart 					; offset in line buffer in X
.d366	b366					_TSTCompareName:
.d366	b366	bd 26 05	lda $0526,x			lda 	lineBuffer,x 				; compare text.
.d369	b369	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.d36b	b36b	d0 0c		bne $b379			bne 	_TSTNextPullY 				; fail, pullY and do next
.d36d	b36d	e8		inx				inx
.d36e	b36e	c8		iny				iny
.d36f	b36f	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; complete match.
.d372	b372	d0 f2		bne $b366			bne 	_TSTCompareName
.d374	b374	7a		ply				ply 								; throw Y
.d375	b375	a5 38		lda $38				lda 	zTemp1 						; get token #
.d377	b377	38		sec				sec 								; return with CS = passed.
.d378	b378	60		rts				rts
.d379	b379					_TSTNextPullY:
.d379	b379	7a		ply				ply 								; restore current, fall through.
.d37a	b37a					_TSTNext:
.d37a	b37a	e6 38		inc $38				inc 	zTemp1 						; token counter
.d37c	b37c	98		tya				tya
.d37d	b37d	18		clc				clc
.d37e	b37e	71 36		adc ($36),y			adc 	(zTemp0),y 					; add [Length] + 2 to Y
.d380	b380	1a		inc a				inc 	a 							; +1
.d381	b381	1a		inc a				inc 	a 							; +2
.d382	b382	a8		tay				tay
.d383	b383	10 c1		bpl $b346			bpl 	_TSTLoop 					; if Y < $80 loop back
.d385	b385	98		tya				tya 								; add Y to zTemp0 and reset Y
.d386	b386	a0 00		ldy #$00			ldy 	#0   						; so we can use Y to search fast
.d388	b388	18		clc				clc  								; but have tables > 255 bytes
.d389	b389	65 36		adc $36				adc 	zTemp0 						; when Y gets >= 128 we reset Y
.d38b	b38b	85 36		sta $36				sta 	zTemp0 						; and adjust the table pointer/
.d38d	b38d	90 b7		bcc $b346			bcc 	_TSTLoop
.d38f	b38f	e6 37		inc $37				inc 	zTemp0+1
.d391	b391	80 b3		bra $b346			bra 	_TSTLoop
.d393	b393					_TSTFail:
.d393	b393	18		clc				clc
.d394	b394	60		rts				rts
.d395	b395					Export_TKTokeniseLine:
.d395	b395	20 62 b5	jsr $b562			jsr 	LCLFixLineBufferCase 		; fix line case
.d398	b398	a9 03		lda #$03			lda 	#3 							; reset the token buffer to empty
.d39a	b39a	8d 26 04	sta $0426			sta 	tokenOffset 				; (3 bytes for line number & offset)
.d39d	b39d	9c 27 04	stz $0427			stz 	tokenLineNumber
.d3a0	b3a0	9c 28 04	stz $0428			stz 	tokenLineNumber+1
.d3a3	b3a3	a2 ff		ldx #$ff			ldx 	#$FF
.d3a5	b3a5					_TKFindFirst:
.d3a5	b3a5	e8		inx				inx
.d3a6	b3a6	bd 26 05	lda $0526,x			lda 	lineBuffer,x
.d3a9	b3a9	f0 62		beq $b40d			beq 	_TKExit
.d3ab	b3ab	c9 20		cmp #$20			cmp 	#' '
.d3ad	b3ad	90 f6		bcc $b3a5			bcc 	_TKFindFirst
.d3af	b3af	c9 30		cmp #$30			cmp 	#'0'
.d3b1	b3b1	90 07		bcc $b3ba			bcc 	_TKNoLineNumber
.d3b3	b3b3	c9 3a		cmp #$3a			cmp 	#'9'+1
.d3b5	b3b5	b0 03		bcs $b3ba			bcs 	_TKNoLineNumber
.d3b7	b3b7	20 8c b5	jsr $b58c			jsr 	TOKExtractLineNumber
.d3ba	b3ba					_TKNoLineNumber:
.d3ba	b3ba					_TKTokeniseLoop:
.d3ba	b3ba	bd 26 05	lda $0526,x			lda 	lineBuffer,x 				; next character, exit if zero EOL.
.d3bd	b3bd	f0 4e		beq $b40d			beq 	_TKExit
.d3bf	b3bf	e8		inx				inx
.d3c0	b3c0	c9 20		cmp #$20			cmp 	#' '
.d3c2	b3c2	f0 f6		beq $b3ba			beq 	_TKTokeniseLoop 			; keep looping if space found.
.d3c4	b3c4	ca		dex				dex 								; undo last get, A contains character, X is position.
.d3c5	b3c5	c9 5f		cmp #$5f			cmp 	#'_'						; _ A-Z is identifier *or* token
.d3c7	b3c7	f0 68		beq $b431			beq 	_TKTokeniseIdentifier 		; (already case converted outside string constants)
.d3c9	b3c9	c9 41		cmp #$41			cmp 	#'A'
.d3cb	b3cb	90 04		bcc $b3d1			bcc 	_TKTokenisePunctuation
.d3cd	b3cd	c9 5b		cmp #$5b			cmp 	#'Z'+1
.d3cf	b3cf	90 60		bcc $b431			bcc 	_TKTokeniseIdentifier
.d3d1	b3d1					_TKTokenisePunctuation:
.d3d1	b3d1	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.d3d3	b3d3	f0 2e		beq $b403			beq 	_TKString
.d3d5	b3d5	c9 24		cmp #$24			cmp 	#'$'						; hexadecimal constant ($ only appears at end of identifiers)
.d3d7	b3d7	f0 2f		beq $b408			beq 	_TKHexConstant
.d3d9	b3d9	c9 3c		cmp #$3c			cmp 	#'<' 						; check for < > handlers - these are for <> <= >= >> <<
.d3db	b3db	f0 36		beq $b413			beq 	_TKCheckDouble
.d3dd	b3dd	c9 3e		cmp #$3e			cmp 	#'>'
.d3df	b3df	f0 32		beq $b413			beq 	_TKCheckDouble
.d3e1	b3e1					_TKStandardPunctuation:
.d3e1	b3e1	bd 26 05	lda $0526,x			lda 	lineBuffer,x 				; get the punctuation token back.
.d3e4	b3e4	c9 40		cmp #$40			cmp 	#64 						; are we >= 64
.d3e6	b3e6	90 0e		bcc $b3f6			bcc 	_TKNoShift
.d3e8	b3e8	48		pha				pha 								; save. we are about to convert this punctuation token from
.d3e9	b3e9	29 07		and #$07			and 	#7 							; lower 3 bits in zTemp0
.d3eb	b3eb	85 36		sta $36				sta 	zTemp0
.d3ed	b3ed	68		pla				pla
.d3ee	b3ee	29 20		and #$20			and 	#32 						; bit 5
.d3f0	b3f0	4a		lsr a				lsr 	a 							; shift into bit 3
.d3f1	b3f1	4a		lsr a				lsr 	a
.d3f2	b3f2	05 36		ora $36				ora 	zTemp0
.d3f4	b3f4	09 10		ora #$10			ora 	#$10						; now in the range 16-31
.d3f6	b3f6					_TKNoShift:
.d3f6	b3f6	20 d1 b5	jsr $b5d1			jsr 	TOKWriteByte 				; write the punctuation character
.d3f9	b3f9	e8		inx				inx 								; consume the character
.d3fa	b3fa	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; quote found ?
.d3fc	b3fc	d0 bc		bne $b3ba			bne 	_TKTokeniseLoop 			; and loop round again.
.d3fe	b3fe	20 c4 b4	jsr $b4c4			jsr 	TOKCheckComment 			; comment checl
.d401	b401	80 b7		bra $b3ba			bra 	_TKTokeniseLoop
.d403	b403					_TKString:
.d403	b403	20 f1 b4	jsr $b4f1			jsr 	TOKTokenString
.d406	b406	80 b2		bra $b3ba			bra 	_TKTokeniseLoop
.d408	b408					_TKHexConstant:
.d408	b408	20 2c b5	jsr $b52c			jsr 	TOKHexConstant
.d40b	b40b	80 ad		bra $b3ba			bra 	_TKTokeniseLoop
.d40d	b40d	a9 80		lda #$80	_TKExit:lda 	#KWC_EOL 					; write end of line byte
.d40f	b40f	20 d1 b5	jsr $b5d1			jsr 	TOKWriteByte
.d412	b412	60		rts				rts
.d413	b413					_TKCheckDouble:
.d413	b413	bd 27 05	lda $0527,x			lda 	lineBuffer+1,x 				; get next character
.d416	b416	c9 3c		cmp #$3c			cmp 	#'<'						; if not < = > which are ASCII consecutive go back
.d418	b418	90 c7		bcc $b3e1			bcc 	_TKStandardPunctuation 		; and do the normal punctuation handler.
.d41a	b41a	c9 3f		cmp #$3f			cmp 	#'>'+1
.d41c	b41c	b0 c3		bcs $b3e1			bcs 	_TKStandardPunctuation
.d41e	b41e	bd 26 05	lda $0526,x			lda 	lineBuffer,x 				; this is < (60) or > (62)
.d421	b421	29 02		and #$02			and 	#2 							; now < (0) or > (2)
.d423	b423	0a		asl a				asl 	a 							; now < (0) or > (4), CC also
.d424	b424	7d 27 05	adc $0527,x			adc 	lineBuffer+1,x 				; add < = > codes - < code
.d427	b427	38		sec				sec
.d428	b428	e9 3c		sbc #$3c			sbc 	#'<'
.d42a	b42a	20 d1 b5	jsr $b5d1			jsr 	TOKWriteByte 				; this is in the range 0-7
.d42d	b42d	e8		inx				inx 								; consume both
.d42e	b42e	e8		inx				inx
.d42f	b42f	80 89		bra $b3ba			bra 	_TKTokeniseLoop
.d431	b431					_TKTokeniseIdentifier:
.d431	b431	8e 00 04	stx $0400			stx 	identStart 					; save start
.d434	b434	9c 04 04	stz $0404			stz 	identTypeByte 				; zero the type byte
.d437	b437					_TKCheckLoop:
.d437	b437	e8		inx				inx 								; look at next, we know first is identifier already.
.d438	b438	bd 26 05	lda $0526,x			lda  	lineBuffer,x
.d43b	b43b	c9 5f		cmp #$5f			cmp 	#"_" 						; legal char _ 0-9 A-Z
.d43d	b43d	f0 f8		beq $b437			beq 	_TKCheckLoop
.d43f	b43f	c9 30		cmp #$30			cmp	 	#"0"
.d441	b441	90 0c		bcc $b44f			bcc 	_TKEndIdentifier
.d443	b443	c9 3a		cmp #$3a			cmp 	#"9"+1
.d445	b445	90 f0		bcc $b437			bcc 	_TKCheckLoop
.d447	b447	c9 41		cmp #$41			cmp	 	#"A"
.d449	b449	90 04		bcc $b44f			bcc 	_TKEndIdentifier
.d44b	b44b	c9 5b		cmp #$5b			cmp 	#"Z"+1
.d44d	b44d	90 e8		bcc $b437			bcc 	_TKCheckLoop
.d44f	b44f					_TKEndIdentifier:
.d44f	b44f	8e 01 04	stx $0401			stx 	identTypeStart 				; save start of type text (if any !)
.d452	b452	a0 08		ldy #$08			ldy 	#$08 						; this is the identifier type byte for #
.d454	b454	c9 23		cmp #$23			cmp 	#"#"						; followed by #
.d456	b456	f0 06		beq $b45e			beq 	_TKHasTypeCharacter
.d458	b458	a0 10		ldy #$10			ldy 	#$10 						; this is the identifier type byte for $
.d45a	b45a	c9 24		cmp #$24			cmp 	#"$"						; followed by $ or #
.d45c	b45c	d0 07		bne $b465			bne 	_TKNoTypeCharacter
.d45e	b45e					_TKHasTypeCharacter:
.d45e	b45e	8c 04 04	sty $0404			sty 	identTypeByte 				; has # or $, save the type
.d461	b461	e8		inx				inx 								; consume the type character
.d462	b462	bd 26 05	lda $0526,x			lda 	lineBuffer,x
.d465	b465					_TKNoTypeCharacter:
.d465	b465	c9 28		cmp #$28			cmp 	#"("						; is it open parenthesis (e.g. array)
.d467	b467	d0 09		bne $b472			bne 	_TKNoArray
.d469	b469	e8		inx				inx 								; skip the (
.d46a	b46a	ad 04 04	lda $0404			lda 	identTypeByte 				; set bit 2 (e.g. array) in type byte
.d46d	b46d	09 04		ora #$04			ora 	#$04
.d46f	b46f	8d 04 04	sta $0404			sta 	identTypeByte
.d472	b472					_TKNoArray:
.d472	b472	8e 02 04	stx $0402			stx 	identTypeEnd 				; save end marker, e.g. continue from here.
.d475	b475	20 4d b5	jsr $b54d			jsr 	TOKCalculateHash 			; calculate the has for those tokens
.d478	b478	a0 ac		ldy #$ac			ldy 	#(KeywordSet0) >> 8
.d47a	b47a	a9 40		lda #$40			lda 	#(KeywordSet0) & $FF
.d47c	b47c	20 3c b3	jsr $b33c			jsr 	TOKSearchTable
.d47f	b47f	a2 00		ldx #$00			ldx 	#0
.d481	b481	b0 1f		bcs $b4a2			bcs 	_TKFoundToken
.d483	b483	a0 ae		ldy #$ae			ldy 	#(KeywordSet1) >> 8
.d485	b485	a9 b1		lda #$b1			lda 	#(KeywordSet1) & $FF
.d487	b487	20 3c b3	jsr $b33c			jsr 	TOKSearchTable
.d48a	b48a	a2 81		ldx #$81			ldx 	#$81
.d48c	b48c	b0 14		bcs $b4a2			bcs 	_TKFoundToken
.d48e	b48e	a0 af		ldy #$af			ldy 	#(KeywordSet2) >> 8
.d490	b490	a9 b5		lda #$b5			lda 	#(KeywordSet2) & $FF
.d492	b492	20 3c b3	jsr $b33c			jsr 	TOKSearchTable
.d495	b495	a2 82		ldx #$82			ldx 	#$82
.d497	b497	b0 09		bcs $b4a2			bcs 	_TKFoundToken
.d499	b499	20 dd b5	jsr $b5dd			jsr 	TOKCheckCreateVariableRecord ; failed all, it's a variable, create record if does not exist.
.d49c	b49c	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.d49f	b49f	4c ba b3	jmp $b3ba			jmp 	_TKTokeniseLoop 			; and go round again.
.d4a2	b4a2					_TKFoundToken:
.d4a2	b4a2	48		pha				pha 								; save token
.d4a3	b4a3	8a		txa				txa 								; shift in X, is there one ?
.d4a4	b4a4	f0 03		beq $b4a9			beq 	_TKNoTShift
.d4a6	b4a6	20 d1 b5	jsr $b5d1			jsr 	TOKWriteByte 				; if so, write it out
.d4a9	b4a9					_TKNoTShift:
.d4a9	b4a9	68		pla				pla 								; restore and write token
.d4aa	b4aa	20 d1 b5	jsr $b5d1			jsr 	TOKWriteByte
.d4ad	b4ad	e0 00		cpx #$00			cpx 	#0 							; check for REM and '
.d4af	b4af	d0 0d		bne $b4be			bne 	_TKNotRem 			 		; not shifted ?
.d4b1	b4b1	c9 d6		cmp #$d6			cmp 	#KWD_REM
.d4b3	b4b3	d0 09		bne $b4be			bne 	_TKNotRem
.d4b5	b4b5	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; check if comment follows.
.d4b8	b4b8	20 c4 b4	jsr $b4c4			jsr 	TOKCheckComment
.d4bb	b4bb	4c ba b3	jmp $b3ba			jmp 	_TKTokeniseLoop
.d4be	b4be					_TKNotRem:
.d4be	b4be	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.d4c1	b4c1	4c ba b3	jmp $b3ba			jmp 	_TKTokeniseLoop 			; and go round again.
.d4c4	b4c4					TOKCheckComment:
.d4c4	b4c4	bd 26 05	lda $0526,x			lda 	lineBuffer,x 				; skip over space
.d4c7	b4c7	e8		inx				inx
.d4c8	b4c8	c9 20		cmp #$20			cmp 	#' '
.d4ca	b4ca	f0 f8		beq $b4c4			beq 	TOKCheckComment
.d4cc	b4cc	ca		dex				dex 								; first non space character
.d4cd	b4cd	c9 22		cmp #$22			cmp 	#'"'						; quote mark
.d4cf	b4cf	f0 1f		beq $b4f0			beq 	_TOKCCExit 					; then we are okay
.d4d1	b4d1	c9 00		cmp #$00			cmp 	#0 							; EOL
.d4d3	b4d3	f0 1b		beq $b4f0			beq 	_TOKCCExit 					; then we are okay
.d4d5	b4d5	da		phx				phx
.d4d6	b4d6					_TOKCCLowerCase:
.d4d6	b4d6	bd 26 05	lda $0526,x			lda 	lineBuffer,x 				; about making it lower case it all, but I thought
.d4d9	b4d9	c9 41		cmp #$41			cmp 	#"A"		 				; that was a bit risky. So it's converted to L/C here.
.d4db	b4db	90 09		bcc $b4e6			bcc 	_TOKKCNotUC
.d4dd	b4dd	c9 5b		cmp #$5b			cmp 	#"Z"+1
.d4df	b4df	b0 05		bcs $b4e6			bcs 	_TOKKCNotUC
.d4e1	b4e1	49 20		eor #$20			eor 	#$20
.d4e3	b4e3	9d 26 05	sta $0526,x			sta 	lineBuffer,x
.d4e6	b4e6					_TOKKCNotUC:
.d4e6	b4e6	e8		inx				inx
.d4e7	b4e7	c9 00		cmp #$00			cmp 	#0
.d4e9	b4e9	d0 eb		bne $b4d6			bne 	_TOKCCLowerCase
.d4eb	b4eb	fa		plx				plx
.d4ec	b4ec	ca		dex				dex 								; tokenise string expects initial skip.
.d4ed	b4ed	20 f1 b4	jsr $b4f1			jsr 	TOKTokenString 				; tokenise rest of line as a string.
.d4f0	b4f0					_TOKCCExit:
.d4f0	b4f0	60		rts				rts
.d4f1	b4f1					TOKTokenString:
.d4f1	b4f1	a9 ff		lda #$ff			lda 	#KWC_STRING 				; string token.
.d4f3	b4f3	20 d1 b5	jsr $b5d1			jsr 	TOKWriteByte
.d4f6	b4f6	e8		inx				inx									; start of quoted string.
.d4f7	b4f7	da		phx				phx 								; push start of string on top
.d4f8	b4f8	ca		dex				dex 								; because we pre-increment
.d4f9	b4f9					_TSFindEnd:
.d4f9	b4f9	e8		inx				inx
.d4fa	b4fa	bd 26 05	lda $0526,x			lda 	lineBuffer,x 				; next character
.d4fd	b4fd	f0 04		beq $b503			beq 	_TSEndOfString 				; no matching quote, we don't mind.
.d4ff	b4ff	c9 22		cmp #$22			cmp 	#'"' 						; go back if quote not found
.d501	b501	d0 f6		bne $b4f9			bne 	_TSFindEnd
.d503	b503					_TSEndOfString:
.d503	b503	7a		ply				ply  								; so now Y is first character, X is character after end.
.d504	b504	48		pha				pha 								; save terminating character
.d505	b505	20 0d b5	jsr $b50d			jsr 	TOKWriteBlockXY 			; write X to Y as a data block
.d508	b508	68		pla				pla 								; terminating character
.d509	b509	f0 01		beq $b50c			beq 	_TSNotQuote					; if it wasn't EOS skip it
.d50b	b50b	e8		inx				inx
.d50c	b50c					_TSNotQuote:
.d50c	b50c	60		rts				rts
.d50d	b50d					TOKWriteBlockXY:
.d50d	b50d	86 36		stx $36				stx 	zTemp0 						; save end character
.d50f	b50f	98		tya				tya 								; use 2's complement to work out the byte size
.d510	b510	49 ff		eor #$ff			eor 	#$FF
.d512	b512	38		sec				sec
.d513	b513	65 36		adc $36				adc 	zTemp0
.d515	b515	1a		inc a				inc 	a 							; one extra for NULL
.d516	b516	20 d1 b5	jsr $b5d1			jsr 	TOKWriteByte
.d519	b519					_TOBlockLoop:
.d519	b519	c4 36		cpy $36				cpy 	zTemp0 						; exit if reached the end
.d51b	b51b	f0 09		beq $b526			beq 	_TOBlockExit
.d51d	b51d	b9 26 05	lda $0526,y			lda 	lineBuffer,y 				; write byte out.
.d520	b520	20 d1 b5	jsr $b5d1			jsr 	TOKWriteByte
.d523	b523	c8		iny				iny
.d524	b524	80 f3		bra $b519			bra 	_TOBlockLoop
.d526	b526					_TOBlockExit:
.d526	b526	a9 00		lda #$00			lda 	#0 							; add NULL.
.d528	b528	20 d1 b5	jsr $b5d1			jsr 	TOKWriteByte
.d52b	b52b	60		rts				rts
.d52c	b52c					TOKHexConstant:
.d52c	b52c	a9 fe		lda #$fe			lda 	#KWC_HEXCONST 				; hex constant token.
.d52e	b52e	20 d1 b5	jsr $b5d1			jsr 	TOKWriteByte
.d531	b531	e8		inx				inx									; start of quoted string.
.d532	b532	da		phx				phx 								; push start of constant on top
.d533	b533	ca		dex				dex
.d534	b534					_THFindLoop:
.d534	b534	e8		inx				inx 	 							; this is stored in a block, so find out how long
.d535	b535	bd 26 05	lda $0526,x			lda 	lineBuffer,x 				; the hex constant is.
.d538	b538	c9 30		cmp #$30			cmp 	#"0"
.d53a	b53a	90 0c		bcc $b548			bcc 	_THFoundEnd
.d53c	b53c	c9 3a		cmp #$3a			cmp 	#"9"+1
.d53e	b53e	90 f4		bcc $b534			bcc 	_THFindLoop
.d540	b540	c9 41		cmp #$41			cmp 	#"A"
.d542	b542	90 04		bcc $b548			bcc 	_THFoundEnd
.d544	b544	c9 47		cmp #$47			cmp 	#"F"+1
.d546	b546	90 ec		bcc $b534			bcc 	_THFindLoop
.d548	b548					_THFoundEnd:
.d548	b548	7a		ply				ply 								; restore start
.d549	b549	20 0d b5	jsr $b50d			jsr 	TOKWriteBlockXY 			; output the block
.d54c	b54c	60		rts				rts
.d54d	b54d					TOKCalculateHash:
.d54d	b54d	da		phx				phx
.d54e	b54e	ae 00 04	ldx $0400			ldx 	identStart 					; needs to be same as in tokens.py - simple sum at present.
.d551	b551	a9 00		lda #$00			lda 	#0
.d553	b553					_TCHLoop:
.d553	b553	18		clc				clc
.d554	b554	7d 26 05	adc $0526,x			adc 	lineBuffer,x
.d557	b557	e8		inx				inx
.d558	b558	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; do the whole thing including type and array markers.
.d55b	b55b	d0 f6		bne $b553			bne 	_TCHLoop
.d55d	b55d	8d 03 04	sta $0403			sta 	identHash 					; save the hash
.d560	b560	fa		plx				plx
.d561	b561	60		rts				rts
.d562	b562					LCLFixLineBufferCase:
.d562	b562	a2 00		ldx #$00			ldx 	#0
.d564	b564					_FLBCLoop:
.d564	b564	bd 26 05	lda $0526,x			lda 	lineBuffer,x 				; get next character
.d567	b567	f0 22		beq $b58b			beq 	_FLBCExit 					; end of string.
.d569	b569	c9 22		cmp #$22			cmp 	#'"'						; quote, go to in quotes
.d56b	b56b	f0 11		beq $b57e			beq 	_FLBCInQuotes
.d56d	b56d	e8		inx				inx
.d56e	b56e	c9 61		cmp #$61			cmp 	#'a'						; needs capitalising ?
.d570	b570	90 f2		bcc $b564			bcc 	_FLBCLoop
.d572	b572	c9 7b		cmp #$7b			cmp 	#'z'+1
.d574	b574	b0 ee		bcs $b564			bcs 	_FLBCLoop
.d576	b576	38		sec				sec 								; make U/C
.d577	b577	e9 20		sbc #$20			sbc 	#32
.d579	b579	9d 25 05	sta $0525,x			sta	 	lineBuffer-1,x 				; write back
.d57c	b57c	80 e6		bra $b564			bra 	_FLBCLoop
.d57e	b57e					_FLBCInQuotes:
.d57e	b57e	e8		inx				inx 								; advance
.d57f	b57f	bd 26 05	lda $0526,x			lda 	lineBuffer,x 				; get next
.d582	b582	f0 07		beq $b58b			beq 	_FLBCExit 					; exit on EOS
.d584	b584	c9 22		cmp #$22			cmp 	#'"' 				 		; until " found
.d586	b586	d0 f6		bne $b57e			bne 	_FLBCInQuotes
.d588	b588	e8		inx				inx 								; skip over it
.d589	b589	80 d9		bra $b564			bra 	_FLBCLoop
.d58b	b58b					_FLBCExit:
.d58b	b58b	60		rts				rts
.d58c	b58c					TOKExtractLineNumber:
.d58c	b58c	ad 28 04	lda $0428			lda 	tokenLineNumber+1 			; push current value on stack
.d58f	b58f	48		pha				pha
.d590	b590	ad 27 04	lda $0427			lda 	tokenLineNumber
.d593	b593	48		pha				pha
.d594	b594	20 ca b5	jsr $b5ca			jsr 	_LCLNTimes2 				; line # x 2
.d597	b597	20 ca b5	jsr $b5ca			jsr 	_LCLNTimes2 				; line # x 4
.d59a	b59a	18		clc				clc 								; add stacked value
.d59b	b59b	68		pla				pla
.d59c	b59c	6d 27 04	adc $0427			adc 	tokenLineNumber
.d59f	b59f	8d 27 04	sta $0427			sta 	tokenLineNumber
.d5a2	b5a2	68		pla				pla
.d5a3	b5a3	6d 28 04	adc $0428			adc 	tokenLineNumber+1
.d5a6	b5a6	8d 28 04	sta $0428			sta 	tokenLineNumber+1 			; line # x 5
.d5a9	b5a9	20 ca b5	jsr $b5ca			jsr 	_LCLNTimes2 				; line # x 10
.d5ac	b5ac	bd 26 05	lda $0526,x			lda 	lineBuffer,x 				; get and consume character
.d5af	b5af	e8		inx				inx
.d5b0	b5b0	29 0f		and #$0f			and 	#15 						; add to line #
.d5b2	b5b2	18		clc				clc
.d5b3	b5b3	6d 27 04	adc $0427			adc 	tokenLineNumber
.d5b6	b5b6	8d 27 04	sta $0427			sta 	tokenLineNumber
.d5b9	b5b9	90 03		bcc $b5be			bcc 	_TLENNoCarry
.d5bb	b5bb	ee 28 04	inc $0428			inc 	tokenLineNumber+1
.d5be	b5be					_TLENNoCarry:
.d5be	b5be	bd 26 05	lda $0526,x			lda 	lineBuffer,x 				; more digits ?
.d5c1	b5c1	c9 30		cmp #$30			cmp 	#'0'
.d5c3	b5c3	90 04		bcc $b5c9			bcc 	_TLENExit
.d5c5	b5c5	c9 3a		cmp #$3a			cmp 	#'9'+1
.d5c7	b5c7	90 c3		bcc $b58c			bcc 	TOKExtractLineNumber
.d5c9	b5c9					_TLENExit:
.d5c9	b5c9	60		rts				rts
.d5ca	b5ca					_LCLNTimes2:
.d5ca	b5ca	0e 27 04	asl $0427			asl 	tokenLineNumber 			; doubles tokenLineNumber.
.d5cd	b5cd	2e 28 04	rol $0428			rol 	tokenLineNumber+1
.d5d0	b5d0	60		rts				rts
.d5d1	b5d1					TOKWriteByte:
.d5d1	b5d1	da		phx				phx
.d5d2	b5d2	ae 26 04	ldx $0426			ldx 	tokenOffset 				; next slot to write to
.d5d5	b5d5	9d 26 04	sta $0426,x			sta 	tokenOffset,x 				; write byte out
.d5d8	b5d8	ee 26 04	inc $0426			inc 	tokenOffset 				; advance slot.
.d5db	b5db	fa		plx				plx
.d5dc	b5dc	60		rts				rts
.d5dd	b5dd					TOKCheckCreateVariableRecord:
.d5dd	b5dd	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.d5df	b5df	85 36		sta $36				sta 	0+zTemp0
.d5e1	b5e1	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.d5e3	b5e3	85 37		sta $37				sta 	1+zTemp0
.d5e5	b5e5					_CCVSearch:
.d5e5	b5e5	b2 36		lda ($36)			lda 	(zTemp0) 					; end of list
.d5e7	b5e7	f0 2c		beq $b615			beq 	_CCVFail
.d5e9	b5e9	a0 01		ldy #$01			ldy 	#1 							; read the hash
.d5eb	b5eb	b1 36		lda ($36),y			lda 	(zTemp0),y 					; does it match ?
.d5ed	b5ed	cd 03 04	cmp $0403			cmp 	identHash 	  				; if not, try the next.
.d5f0	b5f0	d0 16		bne $b608			bne 	_CCVNext
.d5f2	b5f2	a0 08		ldy #$08			ldy 	#8 							; name in variable record
.d5f4	b5f4	ae 00 04	ldx $0400			ldx 	identStart
.d5f7	b5f7					_CCVCompare:
.d5f7	b5f7	bd 26 05	lda $0526,x			lda 	lineBuffer,x 				; xor them. zero if the same, except
.d5fa	b5fa	51 36		eor ($36),y			eor 	(zTemp0),y 					; bit 7 is used for EOS.
.d5fc	b5fc	e8		inx				inx 								; advance pointers
.d5fd	b5fd	c8		iny				iny
.d5fe	b5fe	0a		asl a				asl 	a 							; A = 0 if they match, CS if end.
.d5ff	b5ff	d0 07		bne $b608			bne 	_CCVNext  					; didn't match go to next.
.d601	b601	90 f4		bcc $b5f7			bcc 	_CCVCompare 				; not finished yet.
.d603	b603	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; matched whole thing ?
.d606	b606	f0 41		beq $b649			beq 	_CCVFound 					; yes, we were successful
.d608	b608					_CCVNext:
.d608	b608	18		clc				clc 								; go to next record.
.d609	b609	b2 36		lda ($36)			lda 	(zTemp0) 					; add offset to pointer
.d60b	b60b	65 36		adc $36				adc 	zTemp0
.d60d	b60d	85 36		sta $36				sta 	zTemp0
.d60f	b60f	90 d4		bcc $b5e5			bcc 	_CCVSearch
.d611	b611	e6 37		inc $37				inc 	zTemp0+1
.d613	b613	80 d0		bra $b5e5			bra 	_CCVSearch
.d615	b615					_CCVFail:
.d615	b615	a0 01		ldy #$01			ldy 	#1 							; create the new record. Offset 1 is hash
.d617	b617	ad 03 04	lda $0403			lda 	identHash
.d61a	b61a	91 36		sta ($36),y			sta 	(zTemp0),y
.d61c	b61c	c8		iny				iny 								; offset 2 is the type byte
.d61d	b61d	ad 04 04	lda $0404			lda 	identTypeByte
.d620	b620	91 36		sta ($36),y			sta 	(zTemp0),y
.d622	b622	c8		iny				iny
.d623	b623					_CCVData:
.d623	b623	a9 00		lda #$00			lda 	#0 							; erase data 3-7 (the 5 value bytes)
.d625	b625	91 36		sta ($36),y			sta 	(zTemp0),y
.d627	b627	c8		iny				iny
.d628	b628	c0 08		cpy #$08			cpy 	#8
.d62a	b62a	90 f7		bcc $b623			bcc 	_CCVData
.d62c	b62c	ae 00 04	ldx $0400			ldx 	identStart 					; copy name into 8 on.
.d62f	b62f					_CCVCopyName:
.d62f	b62f	bd 26 05	lda $0526,x			lda 	lineBuffer,x
.d632	b632	91 36		sta ($36),y			sta 	(zTemp0),y
.d634	b634	e8		inx				inx
.d635	b635	c8		iny				iny
.d636	b636	ec 02 04	cpx $0402			cpx 	identTypeEnd
.d639	b639	d0 f4		bne $b62f			bne 	_CCVCopyName
.d63b	b63b	98		tya				tya 								; patch offset
.d63c	b63c	92 36		sta ($36)			sta 	(zTemp0)
.d63e	b63e	a9 00		lda #$00			lda 	#0 							; offset for next is zero.
.d640	b640	91 36		sta ($36),y			sta 	(zTemp0),y
.d642	b642	88		dey				dey
.d643	b643	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set bit 7 of last bit
.d645	b645	09 80		ora #$80			ora 	#$80
.d647	b647	91 36		sta ($36),y			sta 	(zTemp0),y
.d649	b649					_CCVFound:
.d649	b649	a5 37		lda $37				lda 	zTemp0+1 					; write out MSB
.d64b	b64b	38		sec				sec
.d64c	b64c	e9 10		sbc #$10			sbc 	#(VariableSpace >> 8) 		; offset from the start of the variable token
.d64e	b64e	09 40		ora #$40			ora 	#$40 						; make it a writeable token $4000-$7FFF
.d650	b650	20 d1 b5	jsr $b5d1			jsr 	TOKWriteByte
.d653	b653	a5 36		lda $36				lda 	zTemp0 						; write out LSB
.d655	b655	20 d1 b5	jsr $b5d1			jsr 	TOKWriteByte
.d658	b658	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_sound.module

=1						soundIntegrated=1
.d659	b659					SNDCheckChannel:
.d659	b659	aa		tax				tax
.d65a	b65a	bd 8c 09	lda $098c,x			lda 	SNDTimeLeft,x 				; currently playing a note
.d65d	b65d	d0 38		bne $b697			bne 	_SNDCCExit
.d65f	b65f	da		phx				phx 								; save current channel
.d660	b660	8a		txa				txa 								; put in A
.d661	b661	20 dd b6	jsr $b6dd			jsr 	SNDFindNextNoteForA 		; is there a note for A in the queue ?
.d664	b664	68		pla				pla 								; channel # in A
.d665	b665	90 30		bcc $b697			bcc 	_SNDCCExit  				; nothing in the queue for this channel, exit.
.d667	b667	a8		tay				tay 								; Y is the channel #
.d668	b668	bd 81 08	lda $0881,x			lda 	SNDQueue+1,x 				; copy data into the slot.
.d66b	b66b	99 80 09	sta $0980,y			sta 	SNDPitchLow,y
.d66e	b66e	bd 82 08	lda $0882,x			lda 	SNDQueue+2,x
.d671	b671	99 84 09	sta $0984,y			sta 	SNDPitchHigh,y
.d674	b674	bd 83 08	lda $0883,x			lda 	SNDQueue+3,x
.d677	b677	99 88 09	sta $0988,y			sta 	SNDVolume,y
.d67a	b67a	bd 84 08	lda $0884,x			lda 	SNDQueue+4,x
.d67d	b67d	99 8c 09	sta $098c,y			sta 	SNDTimeLeft,y
.d680	b680	bd 85 08	lda $0885,x			lda 	SNDQueue+5,x
.d683	b683	99 90 09	sta $0990,y			sta 	SNDAdjustLow,y
.d686	b686	bd 86 08	lda $0886,x			lda 	SNDQueue+6,x
.d689	b689	99 94 09	sta $0994,y			sta 	SNDAdjustHigh,y
.d68c	b68c	5a		phy				phy 								; save channel #
.d68d	b68d	20 f7 b6	jsr $b6f7			jsr 	SNDDeleteXFromQueue 		; delete record at X from queue
.d690	b690	ce 7f 08	dec $087f			dec 	SNDLength 					; reduce the queue length.
.d693	b693	68		pla				pla
.d694	b694	20 98 b6	jsr $b698			jsr 	SNDUpdateNote 				; update channel A
.d697	b697					_SNDCCExit:
.d697	b697	60		rts				rts
.d698	b698					SNDUpdateNote:
.d698	b698	aa		tax				tax 								; so we can access records
.d699	b699	0a		asl a				asl 	a 							; convert it to a channel bit pair in 5,6
.d69a	b69a	0a		asl a				asl 	a
.d69b	b69b	0a		asl a				asl 	a
.d69c	b69c	0a		asl a				asl 	a
.d69d	b69d	0a		asl a				asl 	a
.d69e	b69e	8d 7e 08	sta $087e			sta 	SNDChannelBits
.d6a1	b6a1	bd 8c 09	lda $098c,x			lda 	SNDTimeLeft,x 				; are we silent
.d6a4	b6a4	f0 2e		beq $b6d4			beq 	_SNDUNIsSilent
.d6a6	b6a6	ad 7e 08	lda $087e			lda 	SNDChannelBits 				; push channel bits on stack
.d6a9	b6a9	48		pha				pha
.d6aa	b6aa	bd 80 09	lda $0980,x			lda 	SNDPitchLow,x 				; get 4 lowest bits of pitch.
.d6ad	b6ad	29 0f		and #$0f			and 	#$0F
.d6af	b6af	0d 7e 08	ora $087e			ora 	SNDChannelBits 				; set channel bits
.d6b2	b6b2	09 80		ora #$80			ora 	#$80 						; write to pitch register
.d6b4	b6b4	20 41 b7	jsr $b741			jsr 	SNDWritePorts
.d6b7	b6b7	bd 84 09	lda $0984,x			lda 	SNDPitchHigh,x 				; pitch high => channel temp.
.d6ba	b6ba	8d 7e 08	sta $087e			sta 	SNDChannelBits
.d6bd	b6bd	bd 80 09	lda $0980,x			lda 	SNDPitchLow,x
.d6c0	b6c0	4e 7e 08	lsr $087e			lsr 	SNDChannelBits 				; shift 2 LSBs into MSB of A
.d6c3	b6c3	6a		ror a				ror 	a
.d6c4	b6c4	4e 7e 08	lsr $087e			lsr 	SNDChannelBits
.d6c7	b6c7	6a		ror a				ror 	a
.d6c8	b6c8	4a		lsr a				lsr 	a 							; put in bits 0-5
.d6c9	b6c9	4a		lsr a				lsr 	a
.d6ca	b6ca	20 41 b7	jsr $b741			jsr 	SNDWritePorts 				; write as rest of pitch register
.d6cd	b6cd	68		pla				pla
.d6ce	b6ce	09 90		ora #$90			ora 	#$90 						; set to write minimum attentuation.
.d6d0	b6d0	20 41 b7	jsr $b741			jsr 	SNDWritePorts
.d6d3	b6d3	60		rts				rts
.d6d4	b6d4					_SNDUNIsSilent:
.d6d4	b6d4	ad 7e 08	lda $087e			lda 	SNDChannelBits 				; channel bits
.d6d7	b6d7	09 9f		ora #$9f			ora 	#$9F 						; maximum attenuation
.d6d9	b6d9	20 41 b7	jsr $b741			jsr 	SNDWritePorts 				; write to the ports
.d6dc	b6dc	60		rts				rts
.d6dd	b6dd					SNDFindNextNoteForA:
.d6dd	b6dd	ac 7f 08	ldy $087f			ldy 	SNDLength 					; queue size into Y
.d6e0	b6e0	f0 13		beq $b6f5			beq 	_SNDFNNFail 				; queue empty.
.d6e2	b6e2	a2 00		ldx #$00			ldx 	#0
.d6e4	b6e4					_SNDFNNSearch:
.d6e4	b6e4	dd 80 08	cmp $0880,x			cmp 	SNDQueue,x 					; does it match the channel
.d6e7	b6e7	38		sec				sec
.d6e8	b6e8	f0 0c		beq $b6f6			beq 	_SNDFNNExit 				; if so exit with CS.
.d6ea	b6ea	e8		inx				inx 								; next queue slot.
.d6eb	b6eb	e8		inx				inx
.d6ec	b6ec	e8		inx				inx
.d6ed	b6ed	e8		inx				inx
.d6ee	b6ee	e8		inx				inx
.d6ef	b6ef	e8		inx				inx
.d6f0	b6f0	e8		inx				inx
.d6f1	b6f1	e8		inx				inx
.d6f2	b6f2	88		dey				dey 								; done the whole queue
.d6f3	b6f3	d0 ef		bne $b6e4			bne 	_SNDFNNSearch 				; no, go back.
.d6f5	b6f5					_SNDFNNFail:
.d6f5	b6f5	18		clc				clc
.d6f6	b6f6					_SNDFNNExit:
.d6f6	b6f6	60		rts				rts
.d6f7	b6f7					SNDDeleteXFromQueue:
.d6f7	b6f7	e0 f8		cpx #$f8			cpx 	#SNDQueueSize*8-8 			; reached the end.
.d6f9	b6f9	f0 09		beq $b704			beq 	_SNDDXExit
.d6fb	b6fb	bd 88 08	lda $0888,x			lda 	SNDQueue+8,x
.d6fe	b6fe	9d 80 08	sta $0880,x			sta 	SNDQueue,x
.d701	b701	e8		inx				inx
.d702	b702	80 f3		bra $b6f7			bra 	SNDDeleteXFromQueue
.d704	b704					_SNDDXExit:
.d704	b704	60		rts				rts
.087e						SNDChannelBits:
>087e								.fill 	1
.d705	b705					SNDQueueRequest:
.d705	b705	86 36		stx $36				stx 	zTemp0						; save queue address
.d707	b707	84 37		sty $37				sty 	zTemp0+1
.d709	b709	ae 7f 08	ldx $087f			ldx 	SNDLength 					; queue is full, can't take any more.
.d70c	b70c	e0 20		cpx #$20			cpx 	#SNDQueueSize
.d70e	b70e	f0 21		beq $b731			beq 	_SNDQRExit
.d710	b710	29 03		and #$03			and 	#3	 						; channel # and push on stack
.d712	b712	48		pha				pha
.d713	b713	8a		txa				txa  								; get offset in queue buffer/
.d714	b714	0a		asl a				asl 	a
.d715	b715	0a		asl a				asl 	a
.d716	b716	0a		asl a				asl 	a
.d717	b717	aa		tax				tax
.d718	b718	68		pla				pla 								; get back and push again
.d719	b719	48		pha				pha
.d71a	b71a	9d 80 08	sta $0880,x			sta 	SNDQueue+0,x 				; save the channel #
.d71d	b71d	a0 00		ldy #$00			ldy 	#0 							; copy the rest in.
.d71f	b71f					_SNDQCopy:
.d71f	b71f	b1 36		lda ($36),y			lda 	(zTemp0),y
.d721	b721	e8		inx				inx
.d722	b722	c8		iny				iny
.d723	b723	9d 80 08	sta $0880,x			sta 	SNDQueue,x
.d726	b726	c0 06		cpy #$06			cpy 	#6
.d728	b728	d0 f5		bne $b71f			bne 	_SNDQCopy
.d72a	b72a	ee 7f 08	inc $087f			inc 	SNDLength 					; bump queue length.
.d72d	b72d	68		pla				pla 								; get channel # back
.d72e	b72e	20 59 b6	jsr $b659			jsr 	SNDCheckChannel 			; check if channel needs refreshing.
.d731	b731					_SNDQRExit:
.d731	b731	60		rts				rts
.d732	b732					SNDSilenceChannel:
.d732	b732	aa		tax				tax 								; zero time left.
.d733	b733	9e 8c 09	stz $098c,x			stz 	SNDTimeLeft,x
.d736	b736	0a		asl a				asl 	a 							; shift into position
.d737	b737	0a		asl a				asl 	a
.d738	b738	0a		asl a				asl 	a
.d739	b739	0a		asl a				asl 	a
.d73a	b73a	0a		asl a				asl 	a
.d73b	b73b	09 9f		ora #$9f			ora 	#$9F 						; write register attenuation $F
.d73d	b73d	20 41 b7	jsr $b741			jsr 	SNDWritePorts
.d740	b740	60		rts				rts
.d741	b741					SNDWritePorts:
.d741	b741	da		phx				phx 								; save X
.d742	b742	a6 01		ldx $01				ldx 	1 							; save I/O status
.d744	b744	64 01		stz $01				stz 	1 							; access I/O page 0
.d746	b746	8d 00 d6	sta $d600			sta 	$D600 						; write to both
.d749	b749	8d 10 d6	sta $d610			sta 	$D610
.d74c	b74c	86 01		stx $01				stx 	1 							; restore I/O
.d74e	b74e	fa		plx				plx 								; restore X
.d74f	b74f	60		rts				rts
.d750	b750					Export_SNDCommand:
.d750	b750	da		phx				phx 								; save XY
.d751	b751	5a		phy				phy
.d752	b752	c9 0f		cmp #$0f			cmp 	#$0F 						; $0F is initialise
.d754	b754	f0 1d		beq $b773			beq 	_SNDInitialise
.d756	b756	90 28		bcc $b780			bcc 	_SNDExit
.d758	b758	c9 3f		cmp #$3f			cmp 	#$3F 						; $3F is silence all
.d75a	b75a	f0 17		beq $b773			beq 	_SNDSilence
.d75c	b75c	b0 22		bcs $b780			bcs 	_SNDExit
.d75e	b75e	c9 20		cmp #$20			cmp 	#$20 						; $2x is check playing => A
.d760	b760	b0 09		bcs $b76b			bcs 	_SNDQueryPlay
.d762	b762	c9 14		cmp #$14			cmp 	#$14 						; $10-$13 is queue sound
.d764	b764	b0 1a		bcs $b780			bcs 	_SNDExit
.d766	b766	20 05 b7	jsr $b705			jsr 	SNDQueueRequest
.d769	b769	80 15		bra $b780			bra 	_SNDExit
.d76b	b76b					_SNDQueryPlay:
.d76b	b76b	29 03		and #$03			and 	#3 							; get channel #
.d76d	b76d	aa		tax				tax
.d76e	b76e	bd 8c 09	lda $098c,x			lda 	SNDTimeLeft,x 				; read time left, if zero then silent
.d771	b771	80 0d		bra $b780			bra 	_SNDExit
.d773	b773					_SNDInitialise:
.d773	b773					_SNDSilence:
.d773	b773	9c 7f 08	stz $087f			stz 	SNDLength 					; empty the queue.
.d776	b776	a9 03		lda #$03			lda 	#$3 						; silence channel 0-3.
.d778	b778					_SNDSilenceLoop:
.d778	b778	48		pha				pha
.d779	b779	20 32 b7	jsr $b732			jsr 	SNDSilenceChannel
.d77c	b77c	68		pla				pla
.d77d	b77d	3a		dec a				dec 	a
.d77e	b77e	10 f8		bpl $b778			bpl 	_SNDSilenceLoop
.d780	b780					_SNDExit:
.d780	b780	7a		ply				ply
.d781	b781	fa		plx				plx
.d782	b782	60		rts				rts
=32						SNDQueueSize = 32 							; number of queue entries
.087f						SNDLength:
>087f								.fill 	1
.0880						SNDQueue:
>0880								.fill 	SNDQueueSize * 8
.0980						SNDPitchLow:
>0980								.fill 	4
.0984						SNDPitchHigh:
>0984								.fill 	4
.0988						SNDVolume:
>0988								.fill 	4
.098c						SNDTimeLeft:
>098c								.fill 	4
.0990						SNDAdjustLow:
>0990								.fill 	4
.0994						SNDAdjustHigh:
>0994								.fill 	4
.d783	b783					Export_SNDUpdate:
.d783	b783					PagedSNDUpdate:
.d783	b783	ad 8c 09	lda $098c			lda 	SNDTimeLeft+0 				; look at time remaining
.d786	b786	f0 05		beq $b78d			beq 	_SNDUNot0 					; not playing
.d788	b788	a2 00		ldx #$00			ldx 	#0 							; so we know which channel to update
.d78a	b78a	20 ac b7	jsr $b7ac			jsr 	SNDUpdateChannel 			; update it.
.d78d	b78d					_SNDUNot0:
.d78d	b78d	ad 8d 09	lda $098d			lda 	SNDTimeLeft+1
.d790	b790	f0 05		beq $b797			beq 	_SNDUNot1
.d792	b792	a2 01		ldx #$01			ldx 	#1
.d794	b794	20 ac b7	jsr $b7ac			jsr 	SNDUpdateChannel
.d797	b797					_SNDUNot1:
.d797	b797	ad 8e 09	lda $098e			lda 	SNDTimeLeft+2
.d79a	b79a	f0 05		beq $b7a1			beq 	_SNDUNot2
.d79c	b79c	a2 02		ldx #$02			ldx 	#2
.d79e	b79e	20 ac b7	jsr $b7ac			jsr 	SNDUpdateChannel
.d7a1	b7a1					_SNDUNot2:
.d7a1	b7a1	ad 8f 09	lda $098f			lda 	SNDTimeLeft+3
.d7a4	b7a4	f0 05		beq $b7ab			beq 	_SNDUNot3
.d7a6	b7a6	a2 03		ldx #$03			ldx 	#3
.d7a8	b7a8	20 ac b7	jsr $b7ac			jsr 	SNDUpdateChannel
.d7ab	b7ab					_SNDUNot3:
.d7ab	b7ab	60		rts				rts
.d7ac	b7ac					SNDUpdateChannel:
.d7ac	b7ac	c9 ff		cmp #$ff			cmp 	#$FF 						; sound $FF play forever until turned off manually
.d7ae	b7ae	f0 2c		beq $b7dc			beq 	_SNDUCExit
.d7b0	b7b0	3a		dec a				dec 	a 							; decrement and update timer
.d7b1	b7b1	9d 8c 09	sta $098c,x			sta 	SNDTimeLeft,x
.d7b4	b7b4	f0 1d		beq $b7d3			beq 	_SNDUCUpdate 				; if zero, silence channel
.d7b6	b7b6	bd 90 09	lda $0990,x			lda 	SNDAdjustLow,x 				; adjust ?
.d7b9	b7b9	1d 94 09	ora $0994,x			ora 	SNDAdjustHigh,x
.d7bc	b7bc	f0 1e		beq $b7dc			beq 	_SNDUCExit 					; if zero carry on at current tone.
.d7be	b7be	18		clc				clc 								; add adjust, forcing into a 10 bit range
.d7bf	b7bf	bd 80 09	lda $0980,x			lda 	SNDPitchLow,x
.d7c2	b7c2	7d 90 09	adc $0990,x			adc 	SNDAdjustLow,x
.d7c5	b7c5	9d 80 09	sta $0980,x			sta 	SNDPitchLow,x
.d7c8	b7c8	bd 84 09	lda $0984,x			lda 	SNDPitchHigh,x
.d7cb	b7cb	7d 94 09	adc $0994,x			adc 	SNDAdjustHigh,x
.d7ce	b7ce	29 03		and #$03			and 	#3
.d7d0	b7d0	9d 84 09	sta $0984,x			sta 	SNDPitchHigh,x
.d7d3	b7d3					_SNDUCUpdate:
.d7d3	b7d3	8a		txa				txa 								; which channel.
.d7d4	b7d4	48		pha				pha
.d7d5	b7d5	20 98 b6	jsr $b698			jsr 	SNDUpdateNote 				; update the current note
.d7d8	b7d8	68		pla				pla
.d7d9	b7d9	20 59 b6	jsr $b659			jsr 	SNDCheckChannel 			; more to do ?
.d7dc	b7dc					_SNDUCExit:
.d7dc	b7dc	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/hardware/header/headerdata.dat

=14						Header_Height = 14
=255						Header_RLE = 255
.e000	a000					Header_jattrs:
>e000	a000	ff 05 21 05 0d ff 05 16			.byte	255,5,33,5,13,255,5,22,5,14,255,5,29,5,255,13,7,13,255,5,2,5,255,13,6,13,255,5,2,5,255,13,8,13,255,5,2,5,255,13,6,13,255,5,8,5,14,13,13,5,5,255,13,7,13,255,5,17,5,6,6,255,5,7,5,6,6,255,5,4,5,6,6,5,5,6,6,255,5,8,5,6,6,255,5,4,5,6,6,255,5,7,5,14,13,13,5,5,13,13,255,5,4,5,13,13,255,5,16,5,14,14,255,5,14,5,14,14,5,5,14,14,255,5,8,5,14,14,255,5,14,5,14,13,13,5,5,13,13,255,5,4,5,13,13,255,5,16,5,255,3,5,3,255,5,4,5,255,3,6,3,255,5,2,5,255,3,7,3,255,5,2,5,255,3,7,3,255,5,8,5,14,13,13,5,5,255,13,7,13,255,5,17,5,7,7,255,5,7,5,7,7,255,5,15,5,7,7,5,5,7,7,255,5,4,5,7,7,5,5,13,13,255,5,3,5,14,13,13,5,5,13,13,255,5,2,5,13,13,255,5,18,5,10,10,255,5,7,5,10,10,255,5,8,5,10,10,255,5,4,5,10,10,5,5,10,10,255,5,4,5,10,10,5,5,13,13,255,5,3,5,14,13,13,5,5,13,13,255,5,3,5,13,13,255,5,17,5,4,4,255,5,7,5,255,4,8,4,5,4,5,255,4,6,4,255,5,3,5,255,4,6,4,255,5,3,5,255,13,6,13,255,5,2,5,13,13,255,5,4,5,13,13,255,5,41,5,13,255,5,22,5,14,255,5,20,5,255,7,80,7,255,14,7,14,255,9,19,9,7,255,9,4,9,255,7,18,7,255,12,24,12,7,7,255,14,10,14,255,9,16,9,7,255,9,4,9,255,7,18,7,255,12,24,12,7,7,255,14,9,14,255,9,17,9,7,255,9,4,9,255,7,18,7,255,12,24,12,255,7,80,7,255,0
>e008	a008	05 0e ff 05 1d 05 ff 0d 07 0d ff 05 02 05 ff 0d
>e018	a018	06 0d ff 05 02 05 ff 0d 08 0d ff 05 02 05 ff 0d
>e028	a028	06 0d ff 05 08 05 0e 0d 0d 05 05 ff 0d 07 0d ff
>e038	a038	05 11 05 06 06 ff 05 07 05 06 06 ff 05 04 05 06
>e048	a048	06 05 05 06 06 ff 05 08 05 06 06 ff 05 04 05 06
>e058	a058	06 ff 05 07 05 0e 0d 0d 05 05 0d 0d ff 05 04 05
>e068	a068	0d 0d ff 05 10 05 0e 0e ff 05 0e 05 0e 0e 05 05
>e078	a078	0e 0e ff 05 08 05 0e 0e ff 05 0e 05 0e 0d 0d 05
>e088	a088	05 0d 0d ff 05 04 05 0d 0d ff 05 10 05 ff 03 05
>e098	a098	03 ff 05 04 05 ff 03 06 03 ff 05 02 05 ff 03 07
>e0a8	a0a8	03 ff 05 02 05 ff 03 07 03 ff 05 08 05 0e 0d 0d
>e0b8	a0b8	05 05 ff 0d 07 0d ff 05 11 05 07 07 ff 05 07 05
>e0c8	a0c8	07 07 ff 05 0f 05 07 07 05 05 07 07 ff 05 04 05
>e0d8	a0d8	07 07 05 05 0d 0d ff 05 03 05 0e 0d 0d 05 05 0d
>e0e8	a0e8	0d ff 05 02 05 0d 0d ff 05 12 05 0a 0a ff 05 07
>e0f8	a0f8	05 0a 0a ff 05 08 05 0a 0a ff 05 04 05 0a 0a 05
>e108	a108	05 0a 0a ff 05 04 05 0a 0a 05 05 0d 0d ff 05 03
>e118	a118	05 0e 0d 0d 05 05 0d 0d ff 05 03 05 0d 0d ff 05
>e128	a128	11 05 04 04 ff 05 07 05 ff 04 08 04 05 04 05 ff
>e138	a138	04 06 04 ff 05 03 05 ff 04 06 04 ff 05 03 05 ff
>e148	a148	0d 06 0d ff 05 02 05 0d 0d ff 05 04 05 0d 0d ff
>e158	a158	05 29 05 0d ff 05 16 05 0e ff 05 14 05 ff 07 50
>e168	a168	07 ff 0e 07 0e ff 09 13 09 07 ff 09 04 09 ff 07
>e178	a178	12 07 ff 0c 18 0c 07 07 ff 0e 0a 0e ff 09 10 09
>e188	a188	07 ff 09 04 09 ff 07 12 07 ff 0c 18 0c 07 07 ff
>e198	a198	0e 09 0e ff 09 11 09 07 ff 09 04 09 ff 07 12 07
>e1a8	a1a8	ff 0c 18 0c ff 07 50 07 ff 00
.e1b2	a1b2					Header_jchars:
>e1b2	a1b2	ff 20 58 20 ff 08 07 08			.byte	255,32,88,32,255,8,7,8,255,32,2,32,255,8,6,8,255,32,2,32,255,8,8,8,255,32,2,32,255,8,6,8,255,32,9,32,252,252,32,32,255,252,7,252,255,32,17,32,8,8,255,32,7,32,8,8,255,32,4,32,8,8,32,32,8,8,255,32,8,32,8,8,255,32,4,32,8,8,255,32,8,32,252,252,32,32,252,252,255,32,4,32,252,252,255,32,16,32,8,8,255,32,14,32,8,8,32,32,8,8,255,32,8,32,8,8,255,32,15,32,252,252,32,32,252,252,255,32,4,32,252,252,255,32,16,32,255,8,5,8,255,32,4,32,255,8,6,8,255,32,2,32,255,8,7,8,255,32,2,32,255,8,7,8,255,32,9,32,252,252,32,32,255,252,7,252,255,32,17,32,8,8,255,32,7,32,8,8,255,32,15,32,8,8,32,32,8,8,255,32,4,32,8,8,32,32,252,252,255,32,4,32,252,252,32,32,252,252,255,32,2,32,252,252,255,32,18,32,8,8,255,32,7,32,8,8,255,32,8,32,8,8,255,32,4,32,8,8,32,32,8,8,255,32,4,32,8,8,32,32,252,252,255,32,4,32,252,252,32,32,252,252,255,32,3,32,252,252,255,32,17,32,8,8,255,32,7,32,255,8,8,8,255,32,2,32,255,8,6,8,255,32,3,32,255,8,6,8,255,32,3,32,255,252,6,252,255,32,2,32,252,252,255,32,4,32,252,252,255,32,87,32,160,255,150,27,150,155,255,150,22,150,155,255,150,24,150,161,130,72,97,114,100,119,97,114,101,255,32,19,32,130,215,50,48,50,51,32,83,116,101,102,97,110,121,32,65,108,108,97,105,114,101,32,32,130,99,50,53,54,102,111,101,110,105,120,46,99,111,109,47,102,50,53,54,45,106,114,255,32,2,32,130,130,77,105,99,114,111,75,101,114,110,101,108,255,32,16,32,130,215,50,48,50,51,32,74,101,115,115,105,101,32,79,98,101,114,114,101,117,116,101,114,130,71,97,100,103,101,116,64,72,97,99,107,119,114,101,110,99,104,76,97,98,115,46,99,111,109,130,130,83,117,112,101,114,66,65,83,73,67,255,32,17,32,130,215,50,48,50,51,32,80,97,117,108,32,82,111,98,115,111,110,255,32,5,32,130,80,97,117,108,64,82,111,98,115,111,110,115,46,111,114,103,46,117,107,255,32,5,32,130,162,255,150,27,150,157,255,150,22,150,157,255,150,24,150,163,255,0
>e1ba	a1ba	ff 20 02 20 ff 08 06 08 ff 20 02 20 ff 08 08 08
>e1ca	a1ca	ff 20 02 20 ff 08 06 08 ff 20 09 20 fc fc 20 20
>e1da	a1da	ff fc 07 fc ff 20 11 20 08 08 ff 20 07 20 08 08
>e1ea	a1ea	ff 20 04 20 08 08 20 20 08 08 ff 20 08 20 08 08
>e1fa	a1fa	ff 20 04 20 08 08 ff 20 08 20 fc fc 20 20 fc fc
>e20a	a20a	ff 20 04 20 fc fc ff 20 10 20 08 08 ff 20 0e 20
>e21a	a21a	08 08 20 20 08 08 ff 20 08 20 08 08 ff 20 0f 20
>e22a	a22a	fc fc 20 20 fc fc ff 20 04 20 fc fc ff 20 10 20
>e23a	a23a	ff 08 05 08 ff 20 04 20 ff 08 06 08 ff 20 02 20
>e24a	a24a	ff 08 07 08 ff 20 02 20 ff 08 07 08 ff 20 09 20
>e25a	a25a	fc fc 20 20 ff fc 07 fc ff 20 11 20 08 08 ff 20
>e26a	a26a	07 20 08 08 ff 20 0f 20 08 08 20 20 08 08 ff 20
>e27a	a27a	04 20 08 08 20 20 fc fc ff 20 04 20 fc fc 20 20
>e28a	a28a	fc fc ff 20 02 20 fc fc ff 20 12 20 08 08 ff 20
>e29a	a29a	07 20 08 08 ff 20 08 20 08 08 ff 20 04 20 08 08
>e2aa	a2aa	20 20 08 08 ff 20 04 20 08 08 20 20 fc fc ff 20
>e2ba	a2ba	04 20 fc fc 20 20 fc fc ff 20 03 20 fc fc ff 20
>e2ca	a2ca	11 20 08 08 ff 20 07 20 ff 08 08 08 ff 20 02 20
>e2da	a2da	ff 08 06 08 ff 20 03 20 ff 08 06 08 ff 20 03 20
>e2ea	a2ea	ff fc 06 fc ff 20 02 20 fc fc ff 20 04 20 fc fc
>e2fa	a2fa	ff 20 57 20 a0 ff 96 1b 96 9b ff 96 16 96 9b ff
>e30a	a30a	96 18 96 a1 82 48 61 72 64 77 61 72 65 ff 20 13
>e31a	a31a	20 82 d7 32 30 32 33 20 53 74 65 66 61 6e 79 20
>e32a	a32a	41 6c 6c 61 69 72 65 20 20 82 63 32 35 36 66 6f
>e33a	a33a	65 6e 69 78 2e 63 6f 6d 2f 66 32 35 36 2d 6a 72
>e34a	a34a	ff 20 02 20 82 82 4d 69 63 72 6f 4b 65 72 6e 65
>e35a	a35a	6c ff 20 10 20 82 d7 32 30 32 33 20 4a 65 73 73
>e36a	a36a	69 65 20 4f 62 65 72 72 65 75 74 65 72 82 47 61
>e37a	a37a	64 67 65 74 40 48 61 63 6b 77 72 65 6e 63 68 4c
>e38a	a38a	61 62 73 2e 63 6f 6d 82 82 53 75 70 65 72 42 41
>e39a	a39a	53 49 43 ff 20 11 20 82 d7 32 30 32 33 20 50 61
>e3aa	a3aa	75 6c 20 52 6f 62 73 6f 6e ff 20 05 20 82 50 61
>e3ba	a3ba	75 6c 40 52 6f 62 73 6f 6e 73 2e 6f 72 67 2e 75
>e3ca	a3ca	6b ff 20 05 20 82 a2 ff 96 1b 96 9d ff 96 16 96
>e3da	a3da	9d ff 96 18 96 a3 ff 00
.e3e2	a3e2					Header_kattrs:
>e3e2	a3e2	07 ff 06 09 06 ff 07 38			.byte	7,255,6,9,6,255,7,56,7,255,6,8,6,255,7,3,7,255,6,9,6,255,7,3,7,255,13,7,13,255,7,2,7,255,13,6,13,255,7,2,7,255,13,8,13,255,7,2,7,255,13,6,13,255,7,2,7,13,13,255,7,3,7,13,13,7,7,255,6,8,6,255,7,3,7,255,6,9,6,255,7,3,7,6,6,255,7,7,7,6,6,255,7,4,7,6,6,7,7,6,6,255,7,8,7,6,6,255,7,4,7,6,6,7,7,13,13,255,7,2,7,13,13,255,7,2,7,255,6,8,6,255,7,3,7,255,6,9,6,255,7,3,7,14,14,255,7,14,7,14,14,7,7,14,14,255,7,8,7,14,14,255,7,8,7,13,13,7,7,13,13,255,7,3,7,255,6,8,6,255,7,3,7,255,6,9,6,255,7,3,7,255,3,5,3,255,7,4,7,255,3,6,3,255,7,2,7,255,3,7,3,255,7,2,7,255,3,7,3,255,7,2,7,255,13,4,13,255,7,4,7,255,6,8,6,255,7,3,7,255,6,9,6,255,7,46,7,13,13,7,7,13,13,255,7,3,7,255,6,8,6,255,7,3,7,255,6,9,6,255,7,3,7,10,10,255,7,7,7,10,10,255,7,8,7,10,10,255,7,4,7,10,10,7,7,10,10,255,7,4,7,10,10,7,7,13,13,255,7,2,7,13,13,255,7,2,7,255,6,8,6,255,7,3,7,255,6,9,6,255,7,3,7,4,4,255,7,7,7,255,4,8,4,255,7,2,7,255,4,6,4,255,7,3,7,255,4,6,4,255,7,2,7,13,13,255,7,3,7,13,13,7,7,255,6,8,6,255,7,2,7,255,0,79,0,255,7,80,7,255,14,7,14,255,9,19,9,7,255,9,4,9,255,7,18,7,255,12,24,12,7,7,255,14,10,14,255,9,16,9,7,255,9,4,9,255,7,18,7,255,12,24,12,7,7,255,14,9,14,255,9,17,9,7,255,9,4,9,255,7,18,7,255,12,24,12,255,7,80,7,255,0
>e3ea	a3ea	07 ff 06 08 06 ff 07 03 07 ff 06 09 06 ff 07 03
>e3fa	a3fa	07 ff 0d 07 0d ff 07 02 07 ff 0d 06 0d ff 07 02
>e40a	a40a	07 ff 0d 08 0d ff 07 02 07 ff 0d 06 0d ff 07 02
>e41a	a41a	07 0d 0d ff 07 03 07 0d 0d 07 07 ff 06 08 06 ff
>e42a	a42a	07 03 07 ff 06 09 06 ff 07 03 07 06 06 ff 07 07
>e43a	a43a	07 06 06 ff 07 04 07 06 06 07 07 06 06 ff 07 08
>e44a	a44a	07 06 06 ff 07 04 07 06 06 07 07 0d 0d ff 07 02
>e45a	a45a	07 0d 0d ff 07 02 07 ff 06 08 06 ff 07 03 07 ff
>e46a	a46a	06 09 06 ff 07 03 07 0e 0e ff 07 0e 07 0e 0e 07
>e47a	a47a	07 0e 0e ff 07 08 07 0e 0e ff 07 08 07 0d 0d 07
>e48a	a48a	07 0d 0d ff 07 03 07 ff 06 08 06 ff 07 03 07 ff
>e49a	a49a	06 09 06 ff 07 03 07 ff 03 05 03 ff 07 04 07 ff
>e4aa	a4aa	03 06 03 ff 07 02 07 ff 03 07 03 ff 07 02 07 ff
>e4ba	a4ba	03 07 03 ff 07 02 07 ff 0d 04 0d ff 07 04 07 ff
>e4ca	a4ca	06 08 06 ff 07 03 07 ff 06 09 06 ff 07 2e 07 0d
>e4da	a4da	0d 07 07 0d 0d ff 07 03 07 ff 06 08 06 ff 07 03
>e4ea	a4ea	07 ff 06 09 06 ff 07 03 07 0a 0a ff 07 07 07 0a
>e4fa	a4fa	0a ff 07 08 07 0a 0a ff 07 04 07 0a 0a 07 07 0a
>e50a	a50a	0a ff 07 04 07 0a 0a 07 07 0d 0d ff 07 02 07 0d
>e51a	a51a	0d ff 07 02 07 ff 06 08 06 ff 07 03 07 ff 06 09
>e52a	a52a	06 ff 07 03 07 04 04 ff 07 07 07 ff 04 08 04 ff
>e53a	a53a	07 02 07 ff 04 06 04 ff 07 03 07 ff 04 06 04 ff
>e54a	a54a	07 02 07 0d 0d ff 07 03 07 0d 0d 07 07 ff 06 08
>e55a	a55a	06 ff 07 02 07 ff 00 4f 00 ff 07 50 07 ff 0e 07
>e56a	a56a	0e ff 09 13 09 07 ff 09 04 09 ff 07 12 07 ff 0c
>e57a	a57a	18 0c 07 07 ff 0e 0a 0e ff 09 10 09 07 ff 09 04
>e58a	a58a	09 ff 07 12 07 ff 0c 18 0c 07 07 ff 0e 09 0e ff
>e59a	a59a	09 11 09 07 ff 09 04 09 ff 07 12 07 ff 0c 18 0c
>e5aa	a5aa	ff 07 50 07 ff 00
.e5b0	a5b0					Header_kchars:
>e5b0	a5b0	ff 20 5e 20 ff 08 07 08			.byte	255,32,94,32,255,8,7,8,255,32,2,32,255,8,6,8,255,32,2,32,255,8,8,8,255,32,2,32,255,8,6,8,255,32,2,32,180,180,255,32,3,32,180,180,255,32,28,32,8,8,255,32,7,32,8,8,255,32,4,32,8,8,32,32,8,8,255,32,8,32,8,8,255,32,4,32,8,8,32,32,180,180,255,32,2,32,180,180,255,32,29,32,8,8,255,32,14,32,8,8,32,32,8,8,255,32,8,32,8,8,255,32,8,32,180,180,32,32,180,180,255,32,30,32,255,8,5,8,255,32,4,32,255,8,6,8,255,32,2,32,255,8,7,8,255,32,2,32,255,8,7,8,255,32,2,32,255,180,4,180,255,32,31,32,8,8,255,32,7,32,8,8,255,32,15,32,8,8,32,32,8,8,255,32,4,32,8,8,32,32,180,180,32,32,180,180,255,32,30,32,8,8,255,32,7,32,8,8,255,32,8,32,8,8,255,32,4,32,8,8,32,32,8,8,255,32,4,32,8,8,32,32,180,180,255,32,2,32,180,180,255,32,29,32,8,8,255,32,7,32,255,8,8,8,255,32,2,32,255,8,6,8,255,32,3,32,255,8,6,8,255,32,2,32,180,180,255,32,3,32,180,180,255,32,93,32,188,255,150,27,150,155,255,150,22,150,155,255,150,24,150,189,130,72,97,114,100,119,97,114,101,255,32,19,32,130,215,50,48,50,51,32,83,116,101,102,97,110,121,32,65,108,108,97,105,114,101,32,32,130,99,50,53,54,102,111,101,110,105,120,46,99,111,109,47,102,50,53,54,45,106,114,255,32,2,32,130,130,77,105,99,114,111,75,101,114,110,101,108,255,32,16,32,130,215,50,48,50,51,32,74,101,115,115,105,101,32,79,98,101,114,114,101,117,116,101,114,130,71,97,100,103,101,116,64,72,97,99,107,119,114,101,110,99,104,76,97,98,115,46,99,111,109,130,130,83,117,112,101,114,66,65,83,73,67,255,32,17,32,130,215,50,48,50,51,32,80,97,117,108,32,82,111,98,115,111,110,255,32,5,32,130,80,97,117,108,64,82,111,98,115,111,110,115,46,111,114,103,46,117,107,255,32,5,32,130,190,255,150,27,150,157,255,150,22,150,157,255,150,24,150,191,255,0
>e5b8	a5b8	ff 20 02 20 ff 08 06 08 ff 20 02 20 ff 08 08 08
>e5c8	a5c8	ff 20 02 20 ff 08 06 08 ff 20 02 20 b4 b4 ff 20
>e5d8	a5d8	03 20 b4 b4 ff 20 1c 20 08 08 ff 20 07 20 08 08
>e5e8	a5e8	ff 20 04 20 08 08 20 20 08 08 ff 20 08 20 08 08
>e5f8	a5f8	ff 20 04 20 08 08 20 20 b4 b4 ff 20 02 20 b4 b4
>e608	a608	ff 20 1d 20 08 08 ff 20 0e 20 08 08 20 20 08 08
>e618	a618	ff 20 08 20 08 08 ff 20 08 20 b4 b4 20 20 b4 b4
>e628	a628	ff 20 1e 20 ff 08 05 08 ff 20 04 20 ff 08 06 08
>e638	a638	ff 20 02 20 ff 08 07 08 ff 20 02 20 ff 08 07 08
>e648	a648	ff 20 02 20 ff b4 04 b4 ff 20 1f 20 08 08 ff 20
>e658	a658	07 20 08 08 ff 20 0f 20 08 08 20 20 08 08 ff 20
>e668	a668	04 20 08 08 20 20 b4 b4 20 20 b4 b4 ff 20 1e 20
>e678	a678	08 08 ff 20 07 20 08 08 ff 20 08 20 08 08 ff 20
>e688	a688	04 20 08 08 20 20 08 08 ff 20 04 20 08 08 20 20
>e698	a698	b4 b4 ff 20 02 20 b4 b4 ff 20 1d 20 08 08 ff 20
>e6a8	a6a8	07 20 ff 08 08 08 ff 20 02 20 ff 08 06 08 ff 20
>e6b8	a6b8	03 20 ff 08 06 08 ff 20 02 20 b4 b4 ff 20 03 20
>e6c8	a6c8	b4 b4 ff 20 5d 20 bc ff 96 1b 96 9b ff 96 16 96
>e6d8	a6d8	9b ff 96 18 96 bd 82 48 61 72 64 77 61 72 65 ff
>e6e8	a6e8	20 13 20 82 d7 32 30 32 33 20 53 74 65 66 61 6e
>e6f8	a6f8	79 20 41 6c 6c 61 69 72 65 20 20 82 63 32 35 36
>e708	a708	66 6f 65 6e 69 78 2e 63 6f 6d 2f 66 32 35 36 2d
>e718	a718	6a 72 ff 20 02 20 82 82 4d 69 63 72 6f 4b 65 72
>e728	a728	6e 65 6c ff 20 10 20 82 d7 32 30 32 33 20 4a 65
>e738	a738	73 73 69 65 20 4f 62 65 72 72 65 75 74 65 72 82
>e748	a748	47 61 64 67 65 74 40 48 61 63 6b 77 72 65 6e 63
>e758	a758	68 4c 61 62 73 2e 63 6f 6d 82 82 53 75 70 65 72
>e768	a768	42 41 53 49 43 ff 20 11 20 82 d7 32 30 32 33 20
>e778	a778	50 61 75 6c 20 52 6f 62 73 6f 6e ff 20 05 20 82
>e788	a788	50 61 75 6c 40 52 6f 62 73 6f 6e 73 2e 6f 72 67
>e798	a798	2e 75 6b ff 20 05 20 82 be ff 96 1b 96 9d ff 96
>e7a8	a7a8	16 96 9d ff 96 18 96 bf ff 00
.e7b2	a7b2					Header_Palette:
>e7b2	a7b2	00 00 00 00				.dword $000000
>e7b6	a7b6	66 66 66 00				.dword $666666
>e7ba	a7ba	aa 00 00 00				.dword $0000aa
>e7be	a7be	00 aa 00 00				.dword $00aa00
>e7c2	a7c2	ea 41 c0 00				.dword $c041ea
>e7c6	a7c6	00 48 87 00				.dword $874800
>e7ca	a7ca	00 9c ff 00				.dword $ff9c00
>e7ce	a7ce	ff db 57 00				.dword $57dbff
>e7d2	a7d2	28 3f 3f 00				.dword $3f3f28
>e7d6	a7d6	8a aa aa 00				.dword $aaaa8a
>e7da	a7da	ff 55 55 00				.dword $5555ff
>e7de	a7de	55 ff 55 00				.dword $55ff55
>e7e2	a7e2	ed 8d ff 00				.dword $ff8ded
>e7e6	a7e6	00 00 ff 00				.dword $ff0000
>e7ea	a7ea	55 ff ff 00				.dword $ffff55
>e7ee	a7ee	ff ff ff 00				.dword $ffffff
>e7f2	a7f2	ff ff ff 00				.dword $ffffff
>e7f6	a7f6	ff ff ff 00				.dword $ffffff

;******  Return to file: _basic.asm


;******  End of listing
