
; 64tass Turbo Assembler Macro V1.57.2900 listing file
; 64tass -D AUTORUN=0 "-D MONITOR_ADDRESS=\$E000" "-D LOCKOUT_ADDRESS=\$F000" "-D BASIC_ADDRESS=\$38000" "-D SOURCE_ADDRESS=\$3000" "-D SPRITE_ADDRESS=\$30000" -q -b -Wall -c -D "HARDWARE=0 $'\x9'$'\x9'$'\x9'$'\x9'$'\x9'$'\x9'" -L output/basic.lst -l output/basic.lbl -Wall -o basic.rom _basic.asm
; Tue Nov 22 18:38:29 2022

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=0					AUTORUN=0
=$e000					 MONITOR_ADDRESS=$E000
=$f000					 LOCKOUT_ADDRESS=$F000
=$38000					 BASIC_ADDRESS=$38000
=$3000					 SOURCE_ADDRESS=$3000
=$30000					 SPRITE_ADDRESS=$30000
=0					HARDWARE=0

;******  Processing input file: _basic.asm


;******  Processing file: ./common/aa.system/01common.inc

=$30					ZeroPageMandatory = $30
=$400					ZeroPagePreference = $400
=$480					MemoryStorage = $480
=$2000					BasicStart = $2000
=$8000					BasicEnd = $8000
=$8000					CodeStart = $8000
=$1000					VariableSpace = $1000
=$2000					EndVariableSpace = $2000
=8					MathStackSize = 8
=512					BasicStackSize = 512
=3584					BasicStackBase = $1000-BasicStackSize
=80					MaxLineSize = 80

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/02macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/04data.inc

.0030					codePtr:
>0030							.fill 	4
.0034					basicStack:
>0034							.fill 	2
.0036					zTemp0:
>0036							.fill 	2
.0038					zTemp1:
>0038							.fill 	2
.003a					zTemp2:
>003a							.fill 	2
.003c					zsTemp:
>003c							.fill 	2
.003e					zaTemp:
>003e							.fill 	2
=$30					safePtr = codePtr 							; minimise direct tinkering
=$80					NSBIsNegative = $80 						; bit 7 : sign of mantissa (where numeric)
=$20					NSBIsReference = $20 						; bit 5 : is a reference
=$10					NSBIsString = $10 							; bit 4 : set if string (procedures don't go on the stack)
=$18					NSBTypeMask = $18 							; bits 4,3 : 00 int 01 float 10 string 11 procedure
=$03					NSBRefMask = $03 							; bits 0,1 : Bytes of reference, -1 (e.g. 00 = 1 byte, 11 = 4 bytes)
=$04					NSBIsArray = $04
=$00					NSTInteger = $00 							; base types for bits 3..4
=$08					NSTFloat = $08
=$10					NSTString = $10
=$18					NSTProcedure = $18
.0400					NSStatus:
>0400							.fill 	MathStackSize
.0408					NSMantissa0:
>0408							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0410					NSMantissa1:
>0410							.fill 	MathStackSize
.0418					NSMantissa2:
>0418							.fill 	MathStackSize
.0420					NSMantissa3:
>0420							.fill 	MathStackSize
.0428					NSExponent:
>0428							.fill 	MathStackSize
.0480					identStart:
>0480							.fill 	1
.0481					identTypeStart:
>0481							.fill 	1
.0482					identTypeEnd:
>0482							.fill 	1
.0483					identHash:
>0483							.fill 	1
.0484					identTypeByte:
>0484							.fill 	1	 						; (see tokenising.pdf)
.0485					encodeState:
>0485							.fill 	1
.0486					digitTemp:
>0486							.fill 	1
.0487					decimalCount:
>0487							.fill 	1
.0488					randomSeed:
>0488							.fill 	4
.048c					lowMemPtr:
>048c							.fill 	2
.048e					stringMemory:
>048e							.fill 	2
.0490					stringInitialised:
>0490							.fill 	1
.0491					stringTempPointer:
>0491							.fill 	2
.0493					breakCheck:
>0493							.fill 	1
.0494					decimalPlaces:
>0494							.fill 	1
.0495					dbOffset:
>0495							.fill 	1
.0496					lastParameter:
>0496							.fill 	1
.0497					dataPointer:
>0497							.fill 	5
.049c					inDataStatement:
>049c							.fill 	1
.049d					tbOffset:
>049d							.fill 	1
.049e					AssemblerAddress:
>049e							.fill 	2
.04a0					AssemblerControl:
>04a0							.fill 	1
.04a1					ParamStart:
>04a1							.fill 	2
.04a3					IsGroup1:
>04a3							.fill 	1
.04a4					BaseOpcode:
>04a4							.fill 	1
.04a5					ModeMask:
>04a5							.fill 	1
.04a6					listIndent:
>04a6							.fill 	1
.04a7					lcLastCharacter:
>04a7							.fill 	1
.04a8					isInputFlag:
>04a8							.fill 	1
.04a9					tokenOffset:
>04a9							.fill 	1
.04aa					tokenLineNumber:
>04aa							.fill 	2
.04ac					tokenBuffer:
>04ac							.fill 	253
.05a9					lineBuffer:
>05a9							.fill 	MaxLineSize+1
.05fa					numberBuffer:
>05fa							.fill 	34
.061c					decimalBuffer:
>061c							.fill 	16

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/constants.inc

=$80					AM_ISZP = $80
=$40					AM_ISG1 = $40
=$20					AM_ISG2 = $20
=224					AM_IMMEDIATE = AM_ISZP+AM_ISG1+AM_ISG2+$00
=228					AM_ZEROPAGE = AM_ISZP+AM_ISG1+AM_ISG2+$04
=40					AM_ACC = AM_ISG2+$08
=108					AM_ABS = AM_ISG1+AM_ISG2+$0C
=208					AM_INDY = AM_ISZP+AM_ISG1+$10
=244					AM_ZEROX = AM_ISZP+AM_ISG1+AM_ISG2+$14
=120					AM_ABSY = AM_ISG1+AM_ISG2+$18
=124					AM_ABSX = AM_ISG1+AM_ISG2+$1C
=209					AM_IND = AM_ISZP+AM_ISG1+$11
=$80					AM_ZEROY = AM_ISZP
=$01					AM_INDABS = $01
=$02					AM_INDABSX = $02
=192					AM_INDX = AM_ISZP+AM_ISG1+$00

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/handlers.inc


;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.inc

=1					ERRID_BREAK = 1
=2					ERRID_SYNTAX = 2
=3					ERRID_DIVZERO = 3
=4					ERRID_RANGE = 4
=5					ERRID_TYPE = 5
=6					ERRID_MEMORY = 6
=7					ERRID_ARGUMENT = 7
=8					ERRID_STOP = 8
=9					ERRID_STRING = 9
=10					ERRID_ASSERT = 10
=11					ERRID_DATA = 11
=12					ERRID_NOTDONE = 12
=13					ERRID_LINE = 13
=14					ERRID_GOSUB = 14
=15					ERRID_REPEAT = 15
=16					ERRID_WHILE = 16
=17					ERRID_FOR = 17
=18					ERRID_STACK = 18
=19					ERRID_STRUCT = 19
=20					ERRID_PROC = 20
=21					ERRID_REDEFINE = 21
=22					ERRID_ARRAYSIZE = 22
=23					ERRID_ARRAYIDX = 23

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst.inc

=$00					KWD_LESSLESS                         = $00; $00 <<
=$01					KWD_LESSEQUAL                        = $01; $01 <=
=$02					KWD_LESSGREATER                      = $02; $02 <>
=$03					KWD_PLINGPLING3                      = $03; $03 !!3
=$04					KWD_GREATERLESS                      = $04; $04 ><
=$05					KWD_GREATEREQUAL                     = $05; $05 >=
=$06					KWD_GREATERGREATER                   = $06; $06 >>
=$07					KWD_PLINGPLING7                      = $07; $07 !!7
=$08					KWD_PLINGPLING8                      = $08; $08 !!8
=$09					KWD_PLINGPLING9                      = $09; $09 !!9
=$0a					KWD_PLINGPLING10                     = $0a; $0a !!10
=$0b					KWD_PLINGPLING11                     = $0b; $0b !!11
=$0c					KWD_PLINGPLING12                     = $0c; $0c !!12
=$0d					KWD_PLINGPLING13                     = $0d; $0d !!13
=$0e					KWD_PLINGPLING14                     = $0e; $0e !!14
=$0f					KWD_PLINGPLING15                     = $0f; $0f !!15
=$10					KWD_AT                               = $10; $10 @
=$11					KWD_PLINGPLING17                     = $11; $11 !!17
=$12					KWD_PLINGPLING18                     = $12; $12 !!18
=$13					KWD_LSQPAREN                         = $13; $13 [
=$14					KWD_BACKSLASH                        = $14; $14 \
=$15					KWD_RSQPAREN                         = $15; $15 ]
=$16					KWD_HAT                              = $16; $16 ^
=$17					KWD_UNDERSCORE                       = $17; $17 _
=$18					KWD_BQUOTE                           = $18; $18 `
=$19					KWD_PLINGPLING25                     = $19; $19 !!25
=$1a					KWD_PLINGPLING26                     = $1a; $1a !!26
=$1b					KWD_LCURLY                           = $1b; $1b {
=$1c					KWD_BAR                              = $1c; $1c |
=$1d					KWD_RCURLY                           = $1d; $1d }
=$1e					KWD_TILDE                            = $1e; $1e ~
=$21					KWD_PLING                            = $21; $21 !
=$22					KWD_DQUOTE                           = $22; $22 "
=$23					KWD_HASH                             = $23; $23 #
=$24					KWD_DOLLAR                           = $24; $24 $
=$25					KWD_PERCENT                          = $25; $25 %
=$26					KWD_AMPERSAND                        = $26; $26 &
=$27					KWD_QUOTE                            = $27; $27 '
=$28					KWD_LPAREN                           = $28; $28 (
=$29					KWD_RPAREN                           = $29; $29 )
=$2a					KWD_STAR                             = $2a; $2a *
=$2b					KWD_PLUS                             = $2b; $2b +
=$2c					KWD_COMMA                            = $2c; $2c ,
=$2d					KWD_MINUS                            = $2d; $2d -
=$2e					KWD_PERIOD                           = $2e; $2e .
=$2f					KWD_SLASH                            = $2f; $2f /
=$30					KWD_0                                = $30; $30 0
=$31					KWD_1                                = $31; $31 1
=$32					KWD_2                                = $32; $32 2
=$33					KWD_3                                = $33; $33 3
=$34					KWD_4                                = $34; $34 4
=$35					KWD_5                                = $35; $35 5
=$36					KWD_6                                = $36; $36 6
=$37					KWD_7                                = $37; $37 7
=$38					KWD_8                                = $38; $38 8
=$39					KWD_9                                = $39; $39 9
=$3a					KWD_COLON                            = $3a; $3a :
=$3b					KWD_SEMICOLON                        = $3b; $3b ;
=$3c					KWD_LESS                             = $3c; $3c <
=$3d					KWD_EQUAL                            = $3d; $3d =
=$3e					KWD_GREATER                          = $3e; $3e >
=$3f					KWD_QMARK                            = $3f; $3f ?
=$83					KWD_ABSLPAREN                        = $83; $83 ABS(
=$84					KWD_ALLOCLPAREN                      = $84; $84 ALLOC(
=$85					KWD_ASCLPAREN                        = $85; $85 ASC(
=$86					KWD_CHRDOLLARLPAREN                  = $86; $86 CHR$(
=$87					KWD_EVENTLPAREN                      = $87; $87 EVENT(
=$88					KWD_FALSE                            = $88; $88 FALSE
=$89					KWD_FRACLPAREN                       = $89; $89 FRAC(
=$8a					KWD_HITLPAREN                        = $8a; $8a HIT(
=$8b					KWD_INTLPAREN                        = $8b; $8b INT(
=$8c					KWD_ISVALLPAREN                      = $8c; $8c ISVAL(
=$8d					KWD_JOYBLPAREN                       = $8d; $8d JOYB(
=$8e					KWD_JOYXLPAREN                       = $8e; $8e JOYX(
=$8f					KWD_JOYYLPAREN                       = $8f; $8f JOYY(
=$90					KWD_LEFTDOLLARLPAREN                 = $90; $90 LEFT$(
=$91					KWD_LENLPAREN                        = $91; $91 LEN(
=$92					KWD_MAXLPAREN                        = $92; $92 MAX(
=$93					KWD_MIDDOLLARLPAREN                  = $93; $93 MID$(
=$94					KWD_MINLPAREN                        = $94; $94 MIN(
=$95					KWD_NOTLPAREN                        = $95; $95 NOT(
=$96					KWD_PLAYINGLPAREN                    = $96; $96 PLAYING(
=$97					KWD_RANDOMLPAREN                     = $97; $97 RANDOM(
=$98					KWD_RIGHTDOLLARLPAREN                = $98; $98 RIGHT$(
=$99					KWD_RNDLPAREN                        = $99; $99 RND(
=$9a					KWD_SGNLPAREN                        = $9a; $9a SGN(
=$9b					KWD_SPCLPAREN                        = $9b; $9b SPC(
=$9c					KWD_STRDOLLARLPAREN                  = $9c; $9c STR$(
=$9d					KWD_TIMERLPAREN                      = $9d; $9d TIMER(
=$9e					KWD_TRUE                             = $9e; $9e TRUE
=$9f					KWD_VALLPAREN                        = $9f; $9f VAL(
=$a0					KWD_FOR                              = $a0; $a0 FOR
=$a1					KWD_IF                               = $a1; $a1 IF
=$a2					KWD_PROC                             = $a2; $a2 PROC
=$a3					KWD_REPEAT                           = $a3; $a3 REPEAT
=$a4					KWD_WHILE                            = $a4; $a4 WHILE
=$a5					KWD_ENDIF                            = $a5; $a5 ENDIF
=$a6					KWD_ENDPROC                          = $a6; $a6 ENDPROC
=$a7					KWD_NEXT                             = $a7; $a7 NEXT
=$a8					KWD_THEN                             = $a8; $a8 THEN
=$a9					KWD_UNTIL                            = $a9; $a9 UNTIL
=$aa					KWD_WEND                             = $aa; $aa WEND
=$ab					KWD_BY                               = $ab; $ab BY
=$ac					KWD_CALL                             = $ac; $ac CALL
=$ad					KWD_CIRCLE                           = $ad; $ad CIRCLE
=$ae					KWD_CLEAR                            = $ae; $ae CLEAR
=$af					KWD_CLS                              = $af; $af CLS
=$b0					KWD_COLOR                            = $b0; $b0 COLOR
=$b1					KWD_COLOUR                           = $b1; $b1 COLOUR
=$b2					KWD_DATA                             = $b2; $b2 DATA
=$b3					KWD_DIM                              = $b3; $b3 DIM
=$b4					KWD_DOWNTO                           = $b4; $b4 DOWNTO
=$b5					KWD_ELSE                             = $b5; $b5 ELSE
=$b6					KWD_FROM                             = $b6; $b6 FROM
=$b7					KWD_GFX                              = $b7; $b7 GFX
=$b8					KWD_GOSUB                            = $b8; $b8 GOSUB
=$b9					KWD_GOTO                             = $b9; $b9 GOTO
=$ba					KWD_HERE                             = $ba; $ba HERE
=$bb					KWD_IMAGE                            = $bb; $bb IMAGE
=$bc					KWD_INPUT                            = $bc; $bc INPUT
=$bd					KWD_LET                              = $bd; $bd LET
=$be					KWD_LINE                             = $be; $be LINE
=$bf					KWD_LOCAL                            = $bf; $bf LOCAL
=$c0					KWD_OFF                              = $c0; $c0 OFF
=$c1					KWD_ON                               = $c1; $c1 ON
=$c2					KWD_OUTLINE                          = $c2; $c2 OUTLINE
=$c3					KWD_PALETTE                          = $c3; $c3 PALETTE
=$c4					KWD_PLOT                             = $c4; $c4 PLOT
=$c5					KWD_PRINT                            = $c5; $c5 PRINT
=$c6					KWD_READ                             = $c6; $c6 READ
=$c7					KWD_RECT                             = $c7; $c7 RECT
=$c8					KWD_REM                              = $c8; $c8 REM
=$c9					KWD_RETURN                           = $c9; $c9 RETURN
=$ca					KWD_SOLID                            = $ca; $ca SOLID
=$cb					KWD_SOUND                            = $cb; $cb SOUND
=$cc					KWD_SPRITE                           = $cc; $cc SPRITE
=$cd					KWD_TEXT                             = $cd; $cd TEXT
=$ce					KWD_TO                               = $ce; $ce TO

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst0.inc

=$80					KWC_EOL = $80
=$ff					KWC_STRING = $FF
=$fe					KWC_HEXCONST = $FE
=$a0					KWC_FIRST_STRUCTURE = $a0
=$a5					KWC_FIRST_STRUCTURE_DEC = $a5
=$aa					KWC_LAST_STRUCTURE = $aa
=$83					KWC_FIRST_UNARY = $83
=$9f					KWC_LAST_UNARY = $9f

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/access.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/stack.inc

=$e0					STK_GOSUB = $E0
=$d0					STK_FOR = $D0
=$c0					STK_REPEAT = $C0
=$b0					STK_PROC = $B0
=$a0					STK_WHILE = $A0
=$01					STK_LOCALN = $01
=$02					STK_LOCALS = $02

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/00start.asm

.8000	a2 ff		ldx #$ff	Start:	ldx 	#$FF 						; stack reset
.8002	9a		txs				txs
.8003	20 de aa	jsr $aade			jsr 	EXTInitialise 				; hardware initialise
.8006	a2 80		ldx #$80			ldx 	#(Prompt >> 8) 				; prompt
.8008	a9 22		lda #$22			lda 	#(Prompt & $FF)
.800a	20 4a 8e	jsr $8e4a			jsr 	PrintStringXA
.800d	a9 00		lda #$00			lda 	#0 							; graphics system initialise.
.800f	aa		tax				tax
.8010	a8		tay				tay
.8011	20 6a ab	jsr $ab6a			jsr 	GXGraphicDraw
.8014	a9 0f		lda #$0f			lda 	#$0F 						; initialise sound system
.8016	20 f8 b9	jsr $b9f8			jsr 	SNDCommand
.8019	20 44 89	jsr $8944			jsr 	NewProgram 					; erase current program
.801c	20 e4 82	jsr $82e4			jsr 	BackloadProgram
.801f	4c 54 83	jmp $8354			jmp 	WarmStart
>8022	0c 2a 2a 2a 20 46 32 35		Prompt:	.text 	12,"*** F256 Junior SuperBASIC ***",13,13
>802a	36 20 4a 75 6e 69 6f 72 20 53 75 70 65 72 42 41
>803a	53 49 43 20 2a 2a 2a 0d 0d

;******  Processing file: ./common/aa.system/../generated/timestamp.asm

>8043	42 75 69 6c 74 20 54 75			.text "Built Tuesday 22-Nov-2022. Build 3570."
>804b	65 73 64 61 79 20 32 32 2d 4e 6f 76 2d 32 30 32
>805b	32 2e 20 42 75 69 6c 64 20 33 35 37 30 2e

;******  Return to file: ./common/aa.system/00start.asm

>8069	0d 0d 00					.byte 	13,13,0

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/assembler.asm

.806c					AssembleGroup1:
.806c	a9 ff		lda #$ff			lda 	#$FF
.806e	8d a5 04	sta $04a5			sta 	ModeMask 					; initialise the mode mask - all for all
.8071	80 02		bra $8075			bra 	AsmGroup12
.8073					AssembleGroup2:
.8073	a9 00		lda #$00			lda 	#$00
.8075					AsmGroup12:
.8075	8d a3 04	sta $04a3			sta 	IsGroup1 					; save the 'group 1' flag
.8078	68		pla				pla 								; pop the return address to access the information following.
.8079	fa		plx				plx
.807a	20 03 81	jsr $8103			jsr 	AccessParameters 			; get opcode and save as base
.807d	8d a4 04	sta $04a4			sta 	BaseOpcode
.8080	ad a3 04	lda $04a3			lda 	IsGroup1 					; skip if group 1 as we don't have a complex mask.
.8083	d0 08		bne $808d			bne 	_AG12HaveMask
.8085	a9 02		lda #$02			lda 	#2 							; if group 2 the second parameter is the mask
.8087	20 0b 81	jsr $810b			jsr 	GetParameter		 		; e.g. which modes are supported for this operand
.808a	8d a5 04	sta $04a5			sta 	ModeMask
.808d					_AG12HaveMask:
.808d	20 46 82	jsr $8246			jsr 	TypeAndCalculateOperand 	; get zero page type
.8090	da		phx				phx 								; save found address mode
.8091	20 6f 81	jsr $816f			jsr 	AssembleModeX
.8094	fa		plx				plx  								; restore address mode
.8095	b0 0b		bcs $80a2			bcs 	_AG12Exit
.8097	20 a3 80	jsr $80a3			jsr 	PromoteToAbsolute  			; promote ZP to ABS and try that
.809a	20 6f 81	jsr $816f			jsr 	AssembleModeX
.809d	b0 03		bcs $80a2			bcs 	_AG12Exit
.809f	4c 3e a0	jmp $a03e			jmp 	SyntaxError 				; can't do either, so must be wrong mode/operand.
.80a2					_AG12Exit:
.80a2	60		rts				rts
.80a3					PromoteToAbsolute:
.80a3	a9 6c		lda #$6c			lda 	#AM_ABS 					; lda xx
.80a5	e0 e4		cpx #$e4			cpx 	#AM_ZEROPAGE
.80a7	f0 19		beq $80c2			beq 	_PTADo
.80a9	a9 7c		lda #$7c			lda 	#AM_ABSX 					; lda xx,X
.80ab	e0 f4		cpx #$f4			cpx 	#AM_ZEROX
.80ad	f0 13		beq $80c2			beq 	_PTADo
.80af	a9 78		lda #$78			lda 	#AM_ABSY 					; lda xx,Y
.80b1	e0 80		cpx #$80			cpx 	#AM_ZEROY
.80b3	f0 0d		beq $80c2			beq 	_PTADo
.80b5	a9 01		lda #$01			lda 	#AM_INDABS 					; lda (xx) (jump)
.80b7	e0 d1		cpx #$d1			cpx 	#AM_IND
.80b9	f0 07		beq $80c2			beq 	_PTADo
.80bb	a9 02		lda #$02			lda 	#AM_INDABSX 				; lda (xx,x) (jump)
.80bd	e0 c0		cpx #$c0			cpx 	#AM_INDX
.80bf	f0 01		beq $80c2			beq 	_PTADo
.80c1	60		rts				rts
.80c2					_PTADo:
.80c2	aa		tax				tax
.80c3	60		rts				rts
.80c4					AssembleGroup3:
.80c4	68		pla				pla 								; get parameters, which is just the opcode.
.80c5	fa		plx				plx
.80c6	20 03 81	jsr $8103			jsr 	AccessParameters 			; get and output opcode
.80c9	20 1b 81	jsr $811b			jsr 	AssemblerWriteByte
.80cc	20 aa 82	jsr $82aa			jsr 	CalculateOperand 			; get a 16 bit operand
.80cf	ad 08 04	lda $0408			lda 	NSMantissa0 				; calculate the offset
.80d2	38		sec				sec
.80d3	ed 9e 04	sbc $049e			sbc 	AssemblerAddress
.80d6	48		pha				pha 								; LSB in A
.80d7	ad 10 04	lda $0410			lda 	NSMantissa1
.80da	ed 9f 04	sbc $049f			sbc 	AssemblerAddress+1
.80dd	aa		tax				tax 								; MSB in X
.80de	68		pla				pla
.80df	18		clc				clc 								; $80 to easy check $80-$7F, plus 1 for offset error
.80e0	69 7f		adc #$7f			adc 	#$7F
.80e2	90 01		bcc $80e5			bcc 	_AG3NoCarry
.80e4	e8		inx				inx
.80e5					_AG3NoCarry:
.80e5	38		sec				sec 								; fix back and write out anyways.
.80e6	e9 80		sbc #$80			sbc 	#$80
.80e8	20 1b 81	jsr $811b			jsr 	AssemblerWriteByte
.80eb	e0 00		cpx #$00			cpx 	#0 							; was it in range
.80ed	f0 0a		beq $80f9			beq 	_AG3Exit
.80ef	ad a0 04	lda $04a0			lda 	AssemblerControl 			; are we allowing bad values ?
.80f2	29 01		and #$01			and 	#1
.80f4	f0 03		beq $80f9			beq 	_AG3Exit
.80f6	4c 43 a0	jmp $a043			jmp 	RangeError 					; no, branch is out of range
.80f9					_AG3Exit:
.80f9	60		rts				rts
.80fa					AssembleGroup4:
.80fa	68		pla				pla 								; pop address
.80fb	fa		plx				plx
.80fc	20 03 81	jsr $8103			jsr 	AccessParameters 			; access and get first
.80ff	20 1b 81	jsr $811b			jsr 	AssemblerWriteByte 			; output it.
.8102	60		rts				rts
.8103					AccessParameters:
.8103	8d a1 04	sta $04a1			sta 	ParamStart
.8106	8e a2 04	stx $04a2			stx 	ParamStart+1
.8109	a9 01		lda #$01			lda 	#1
.810b					GetParameter:
.810b	5a		phy				phy
.810c	a8		tay				tay
.810d	ad a1 04	lda $04a1			lda 	ParamStart
.8110	85 36		sta $36				sta 	zTemp0
.8112	ad a2 04	lda $04a2			lda 	ParamStart+1
.8115	85 37		sta $37				sta 	zTemp0+1
.8117	b1 36		lda ($36),y			lda 	(zTemp0),y
.8119	7a		ply				ply
.811a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/aswrite.asm

.811b					AssemblerWriteByte:
.811b	48		pha			pha
.811c	ad a0 04	lda $04a0		lda 	AssemblerControl 				; check printing bytes ?
.811f	29 02		and #$02		and 	#2
.8121	f0 1b		beq $813e		beq 	_AWBNoPrint
.8123	ad 9f 04	lda $049f		lda		AssemblerAddress+1 				; print address
.8126	20 59 81	jsr $8159		jsr 	PrintHex
.8129	ad 9e 04	lda $049e		lda		AssemblerAddress
.812c	20 59 81	jsr $8159		jsr 	PrintHex
.812f	a9 20		lda #$20		lda 	#' '
.8131	20 6a a8	jsr $a86a		jsr 	EXTPrintCharacter
.8134	68		pla			pla 									; print byte
.8135	48		pha			pha
.8136	20 59 81	jsr $8159		jsr 	PrintHex
.8139	a9 0d		lda #$0d		lda 	#13
.813b	20 6a a8	jsr $a86a		jsr 	EXTPrintCharacter
.813e					_AWBNoPrint:
.813e	ad 9e 04	lda $049e		lda		AssemblerAddress				; copy address to zTemp0
.8141	85 36		sta $36			sta 	zTemp0
.8143	ad 9f 04	lda $049f		lda		AssemblerAddress+1
.8146	f0 0e		beq $8156		beq 	_AWBRange
.8148	85 37		sta $37			sta 	zTemp0+1
.814a	68		pla			pla 									; write byte out
.814b	92 36		sta ($36)		sta 	(zTemp0)
.814d	ee 9e 04	inc $049e		inc 	AssemblerAddress 				; bump address
.8150	d0 03		bne $8155		bne 	_AWBNoCarry
.8152	ee 9f 04	inc $049f		inc 	AssemblerAddress+1
.8155					_AWBNoCarry:
.8155	60		rts			rts
.8156					_AWBRange:
.8156	4c 43 a0	jmp $a043		jmp 	RangeError
.8159					PrintHex:
.8159	48		pha				pha
.815a	4a		lsr a				lsr 	a
.815b	4a		lsr a				lsr 	a
.815c	4a		lsr a				lsr 	a
.815d	4a		lsr a				lsr 	a
.815e	20 62 81	jsr $8162			jsr 	_PrintNibble
.8161	68		pla				pla
.8162					_PrintNibble:
.8162	29 0f		and #$0f			and 	#15
.8164	c9 0a		cmp #$0a			cmp 	#10
.8166	90 02		bcc $816a			bcc 	_NoShift
.8168	69 06		adc #$06			adc 	#6
.816a					_NoShift:
.816a	69 30		adc #$30			adc 	#48
.816c	4c 6a a8	jmp $a86a			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/instruction.asm

.816f					AssembleModeX:
.816f	5a		phy				phy
.8170	ad a3 04	lda $04a3			lda 	IsGroup1
.8173	f0 17		beq $818c			beq 	_AMXGroup2
.8175	8a		txa				txa 							; is it in group # 1
.8176	29 40		and #$40			and 	#AM_ISG1
.8178	f0 50		beq $81ca			beq 	_AMXFail 				; no, give up.
.817a	8a		txa				txa 							; get back.
.817b	29 1f		and #$1f			and 	#$1F 					; this is now the offset.
.817d	e0 e0		cpx #$e0			cpx 	#AM_IMMEDIATE 			; if not immediate, we can continue.
.817f	d0 22		bne $81a3			bne 	_AMXHaveInfo
.8181	ad a4 04	lda $04a4			lda 	BaseOpcode 				; cannot store immediate.
.8184	c9 81		cmp #$81			cmp 	#$81
.8186	f0 42		beq $81ca			beq 	_AMXFail
.8188	a9 08		lda #$08			lda 	#8 						; if immediate we use offset 8.
.818a	80 17		bra $81a3			bra 	_AMXHaveInfo 			; odd design decision there.
.818c					_AMXGroup2:
.818c	8a		txa				txa 							; is it in group 2 ?
.818d	29 20		and #$20			and 	#AM_ISG2
.818f	f0 39		beq $81ca			beq 	_AMXFail 				; no, give up.
.8191	8a		txa				txa 							; get the offset into Y
.8192	29 1f		and #$1f			and 	#$1F
.8194	4a		lsr a				lsr 	a 						; make it 0-7.
.8195	4a		lsr a				lsr  	a
.8196	a8		tay				tay
.8197	ad a5 04	lda $04a5			lda 	ModeMask 				; shift the modemask left so you can check it against the requested offset
.819a					_AMXCheckOkay:
.819a	0a		asl a				asl 	a 						; shift modemask left enough times to check legitimate.
.819b	88		dey				dey
.819c	10 fc		bpl $819a			bpl 	_AMXCheckOkay
.819e	90 2a		bcc $81ca			bcc 	_AMXFail 				; not allowed.
.81a0	8a		txa				txa  							; get mask back
.81a1	29 1f		and #$1f			and 	#$1F
.81a3					_AMXHaveInfo:
.81a3	e0 00		cpx #$00			cpx 	#$00 					; does it *require* an 8 bit operand
.81a5	10 05		bpl $81ac			bpl 	_AMXAnySize 			; checking bit 7, the zero page opcode flag.
.81a7	ac 10 04	ldy $0410			ldy 	NSMantissa1 			; fail if it is outside range, e.g. the MSB is set.
.81aa	d0 1e		bne $81ca			bne 	_AMXFail
.81ac					_AMXAnySize:
.81ac	18		clc				clc 							; add offset to the base opcode
.81ad	6d a4 04	adc $04a4			adc 	BaseOpcode
.81b0					_AMXOutputCode:
.81b0	20 1b 81	jsr $811b			jsr 	AssemblerWriteByte 		; write the opcode out.
.81b3	e0 28		cpx #$28			cpx 	#AM_ACC 				; A mode (e.g. ASL A)
.81b5	f0 10		beq $81c7			beq 	_AMXExit
.81b7	ad 08 04	lda $0408			lda 	NSMantissa0 				; write LSB operand
.81ba	20 1b 81	jsr $811b			jsr 	AssemblerWriteByte
.81bd	e0 00		cpx #$00			cpx 	#$00 					; zeropage ?
.81bf	30 06		bmi $81c7			bmi 	_AMXExit
.81c1	ad 10 04	lda $0410			lda 	NSMantissa1 			; write MSB operand
.81c4	20 1b 81	jsr $811b			jsr 	AssemblerWriteByte
.81c7					_AMXExit:
.81c7	7a		ply				ply
.81c8	38		sec				sec
.81c9	60		rts				rts
.81ca					_AMXFail:
.81ca	a0 00		ldy #$00			ldy 	#0
.81cc					_AMXCheckOddities:
.81cc	8a		txa				txa
.81cd	d9 f5 81	cmp $81f5,y			cmp 	ExtraOpcode+2,y 		; match address mode
.81d0	d0 16		bne $81e8			bne 	_AMXCONext
.81d2	b9 f3 81	lda $81f3,y			lda 	ExtraOpcode+0,y 		; do the base opcodes match
.81d5	cd a4 04	cmp $04a4			cmp 	BaseOpcode
.81d8	d0 0e		bne $81e8			bne 	_AMXCONext
.81da	e0 00		cpx #$00			cpx 	#$00 					; requires zero page ?
.81dc	10 05		bpl $81e3			bpl 	_AMXCONotZero
.81de	ad 10 04	lda $0410			lda 	NSMantissa1
.81e1	d0 05		bne $81e8			bne 	_AMXCONext
.81e3					_AMXCONotZero:
.81e3	b9 f4 81	lda $81f4,y			lda 	ExtraOpcode+1,y 		; get new opcode
.81e6	80 c8		bra $81b0			bra 	_AMXOutputCode 			; and assemble it
.81e8					_AMXCONext:
.81e8	c8		iny				iny
.81e9	c8		iny				iny
.81ea	c8		iny				iny
.81eb	b9 f3 81	lda $81f3,y			lda 	ExtraOpcode+0,y 		; end of table
.81ee	d0 dc		bne $81cc			bne 	_AMXCheckOddities
.81f0					_AMXCOFail:
.81f0	7a		ply				ply
.81f1	18		clc				clc
.81f2	60		rts				rts
.81f3					ExtraOpcode:
>81f3	40 6c 01					.byte $40,$6c,AM_INDABS 	; jmp
>81f6	40 7c 02					.byte $40,$7C,AM_INDABSX 	; jmp
>81f9	a2 be 78					.byte $a2,$BE,AM_ABSY 		; ldx
>81fc	a2 b6 80					.byte $a2,$B6,AM_ZEROY 		; ldx
>81ff	82 96 80					.byte $82,$96,AM_ZEROY 		; stx
>8202	e2 1a 28					.byte $e2,$1a,AM_ACC 		; inc
>8205	c2 3a 28					.byte $c2,$3a,AM_ACC 		; dec
>8208	20 89 e0					.byte $20,$89,AM_IMMEDIATE 	; bit
>820b	60 9c 6c					.byte $60,$9c,AM_ABS 		; stz
>820e	60 9e 7c					.byte $60,$9e,AM_ABSX 		; stz
>8211	00						.byte $00

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/label.asm

.8212					LabelHere:
.8212	c8		iny				iny 								; skip .
.8213	a2 00		ldx #$00			ldx 	#0 							; get a term
.8215	20 7a 98	jsr $987a			jsr 	EvaluateTerm 				; get a term
.8218	ad 00 04	lda $0400			lda 	NSStatus 					; needs to be an integer reference.
.821b	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.821d	d0 24		bne $8243			bne 	_ALType
.821f	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy reference address to zTemp0
.8222	85 36		sta $36				sta 	zTemp0
.8224	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.8227	85 37		sta $37				sta 	zTemp0+1
.8229	5a		phy				phy 								; copy address in.
.822a	a0 01		ldy #$01			ldy 	#1
.822c	ad 9e 04	lda $049e			lda	 	AssemblerAddress
.822f	92 36		sta ($36)			sta 	(zTemp0)
.8231	ad 9f 04	lda $049f			lda	 	AssemblerAddress+1
.8234	91 36		sta ($36),y			sta 	(zTemp0),y
.8236	c8		iny				iny
.8237	a9 00		lda #$00			lda 	#0
.8239	91 36		sta ($36),y			sta 	(zTemp0),y
.823b	c8		iny				iny
.823c	91 36		sta ($36),y			sta 	(zTemp0),y
.823e	c8		iny				iny
.823f	91 36		sta ($36),y			sta 	(zTemp0),y
.8241	7a		ply				ply
.8242	60		rts				rts
.8243					_ALType:
.8243	4c 48 a0	jmp $a048			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/operands.asm

.8246					TypeAndCalculateOperand:
.8246	b1 30		lda ($30),y			lda 	(codePtr),y
.8248	a2 28		ldx #$28			ldx 	#AM_ACC 					; ACC if : or EOL
.824a	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.824c	f0 5b		beq $82a9			beq 	_TACOExit
.824e	c9 80		cmp #$80			cmp 	#KWC_EOL
.8250	f0 57		beq $82a9			beq 	_TACOExit
.8252	c8		iny				iny
.8253	a2 e0		ldx #$e0			ldx 	#AM_IMMEDIATE
.8255	c9 23		cmp #$23			cmp 	#KWD_HASH 					; if hash, then immediate - constant.
.8257	f0 51		beq $82aa			beq 	CalculateOperand
.8259	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; if ( then check for indirection
.825b	f0 1f		beq $827c			beq 	_TACOIndirect
.825d	88		dey				dey 								; undo get of first character
.825e	20 aa 82	jsr $82aa			jsr 	CalculateOperand 			; get operand
.8261	b1 30		lda ($30),y			lda 	(codePtr),y
.8263	a2 e4		ldx #$e4			ldx 	#AM_ZEROPAGE 				; if not, try zero page (then absolute)
.8265	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8267	d0 40		bne $82a9			bne 	_TACOExit
.8269	c8		iny				iny
.826a	20 b4 82	jsr $82b4			jsr 	TACOCheckXY 				; extract X,Y or 0 (neither) from the variable.
.826d	a2 f4		ldx #$f4			ldx 	#AM_ZEROX 					; check for X
.826f	c9 58		cmp #$58			cmp 	#'X'
.8271	f0 36		beq $82a9			beq 	_TACOExit
.8273	a2 80		ldx #$80			ldx 	#AM_ZEROY 					; check for Y
.8275	c9 59		cmp #$59			cmp 	#'Y'
.8277	f0 30		beq $82a9			beq 	_TACOExit
.8279					_TACOSyntax:
.8279	4c 3e a0	jmp $a03e			jmp 	SyntaxError
.827c					_TACOIndirect:
.827c	20 aa 82	jsr $82aa			jsr 	CalculateOperand 			; get the operand
.827f	b1 30		lda ($30),y			lda 	(codePtr),y
.8281	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if , then it must be ,X)
.8283	f0 17		beq $829c			beq 	_TACOIndX
.8285	20 d8 8d	jsr $8dd8			jsr 	CheckRightBracket  			; otherwise must be ) or ),Y
.8288	b1 30		lda ($30),y			lda 	(codePtr),y
.828a	a2 d1		ldx #$d1			ldx 	#AM_IND
.828c	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not comma then exit with (xx)
.828e	d0 19		bne $82a9			bne 	_TACOExit
.8290	c8		iny				iny
.8291	20 b4 82	jsr $82b4			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.8294	c9 59		cmp #$59			cmp 	#'Y' 						; check Y
.8296	d0 e1		bne $8279			bne 	_TACOSyntax
.8298	a2 d0		ldx #$d0			ldx 	#AM_INDY
.829a	80 0d		bra $82a9			bra 	_TACOExit
.829c					_TACOIndX:
.829c	c8		iny				iny
.829d	20 b4 82	jsr $82b4			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.82a0	c9 58		cmp #$58			cmp 	#'X' 						; check X
.82a2	d0 d5		bne $8279			bne 	_TACOSyntax
.82a4	20 d8 8d	jsr $8dd8			jsr 	CheckRightBracket			; check )
.82a7	a2 c0		ldx #$c0			ldx 	#AM_INDX
.82a9					_TACOExit:
.82a9	60		rts				rts
.82aa					CalculateOperand:
.82aa	48		pha				pha
.82ab	da		phx				phx
.82ac	a2 00		ldx #$00			ldx 	#0 							; get 16 bit integer in Slot 0
.82ae	20 15 9e	jsr $9e15			jsr 	Evaluate16BitInteger
.82b1	fa		plx				plx
.82b2	68		pla				pla
.82b3	60		rts				rts
.82b4					TACOCheckXY:
.82b4	b1 30		lda ($30),y			lda 	(codePtr),y
.82b6	29 c0		and #$c0			and 	#$C0 						; check it is an identifier reference.
.82b8	c9 40		cmp #$40			cmp 	#$40
.82ba	d0 21		bne $82dd			bne 	_TCXYFail
.82bc	b1 30		lda ($30),y			lda 	(codePtr),y
.82be	18		clc				clc
.82bf	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.82c1	85 37		sta $37				sta 	zTemp0+1
.82c3	c8		iny				iny
.82c4	b1 30		lda ($30),y			lda 	(codePtr),y
.82c6	c8		iny				iny
.82c7	85 36		sta $36				sta 	zTemp0
.82c9	5a		phy				phy 								; save position
.82ca	a0 02		ldy #$02			ldy 	#2 							; type is integer ?
.82cc	b1 36		lda ($36),y			lda 	(zTemp0),y
.82ce	d0 0c		bne $82dc			bne 	_TCXYPopFail
.82d0	a0 08		ldy #$08			ldy 	#8 							; get first character, should have bit 7 set as also last.
.82d2	b1 36		lda ($36),y			lda 	(zTemp0),y
.82d4	c9 d8		cmp #$d8			cmp 	#'X'+$80 					; should be X or Y
.82d6	f0 08		beq $82e0			beq 	_TCXYFound
.82d8	c9 d9		cmp #$d9			cmp 	#'Y'+$80
.82da	f0 04		beq $82e0			beq 	_TCXYFound
.82dc					_TCXYPopFail:
.82dc	7a		ply				ply
.82dd					_TCXYFail:
.82dd	a9 00		lda #$00			lda 	#0
.82df	60		rts				rts
.82e0					_TCXYFound:
.82e0	7a		ply				ply 								; restore position
.82e1	29 7f		and #$7f			and 	#$7F 						; throw bit 7
.82e3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/backload.asm

.82e4					BackloadProgram:
.82e4	a9 00		lda #$00			lda 	#((SOURCE_ADDRESS) & $FF)
.82e6	8d 2c 06	sta $062c			sta 	0+BackLoadPointer
.82e9	a9 30		lda #$30			lda 	#((SOURCE_ADDRESS) >> 8)
.82eb	8d 2d 06	sta $062d			sta 	1+BackLoadPointer
.82ee					_BPLoop:
.82ee	a2 ff		ldx #$ff			ldx 	#$FF
.82f0	20 18 83	jsr $8318			jsr 	BLReadByte
.82f3	30 1f		bmi $8314			bmi 	_BPExit
.82f5					_BPCopy:
.82f5	e8		inx				inx  								; copy byte in
.82f6	9d a9 05	sta $05a9,x			sta 	lineBuffer,x
.82f9	9e aa 05	stz $05aa,x			stz 	lineBuffer+1,x
.82fc	20 18 83	jsr $8318			jsr 	BLReadByte 					; read next byte
.82ff	30 0a		bmi $830b			bmi 	_BPEndLine 					; -ve = EOL
.8301	c9 09		cmp #$09			cmp 	#9 							; handle TAB
.8303	d0 02		bne $8307			bne 	_BPNotTab
.8305	a9 20		lda #$20			lda 	#' '
.8307					_BPNotTab:
.8307	c9 20		cmp #$20			cmp 	#' ' 						; < ' ' = EOL
.8309	b0 ea		bcs $82f5			bcs 	_BPCopy
.830b					_BPEndLine:
.830b	20 88 b6	jsr $b688			jsr 	TokeniseLine 				; tokenise the line.
.830e	38		sec				sec 								; append not insert
.830f	20 a6 a5	jsr $a5a6			jsr 	MemoryInsertLine 			; append to current program
.8312	80 da		bra $82ee			bra 	_BPLoop
.8314					_BPExit:
.8314	20 ed 83	jsr $83ed			jsr 	ClearCommand 				; clear variables etc.
.8317	60		rts				rts
.8318					BLReadByte:
.8318	ad 2c 06	lda $062c			lda 	BackLoadPointer
.831b	85 36		sta $36				sta 	zTemp0
.831d	ad 2d 06	lda $062d			lda 	BackLoadPointer+1
.8320	85 37		sta $37				sta 	zTemp0+1
.8322	b2 36		lda ($36)			lda 	(zTemp0)
.8324	ee 2c 06	inc $062c			inc 	BackLoadPointer
.8327	d0 03		bne $832c			bne 	_BLNoCarry
.8329	ee 2d 06	inc $062d			inc 	BackLoadPointer+1
.832c					_BLNoCarry:
.832c	c9 00		cmp #$00			cmp 	#0
.832e	60		rts				rts
.062c					BackLoadPointer:
>062c							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/editor.asm

.832f					EditProgramCode:
.832f	ad aa 04	lda $04aa			lda 	TokenLineNumber 			; find the line.
.8332	ae ab 04	ldx $04ab			ldx 	TokenLineNumber+1
.8335	20 4e a6	jsr $a64e			jsr 	MemorySearch
.8338	90 05		bcc $833f			bcc 	_EPCNoDelete 				; reached the end don't delete
.833a	d0 03		bne $833f			bne 	_EPCNoDelete 				; found slot but didn't match, no delete
.833c	20 6f a5	jsr $a56f			jsr 	MemoryDeleteLine 			; delete the line
.833f					_EPCNoDelete:
.833f	ad ac 04	lda $04ac			lda 	TokenBuffer 				; buffer empty
.8342	c9 80		cmp #$80			cmp 	#KWC_EOL
.8344	f0 0d		beq $8353			beq 	_EPCNoInsert
.8346	ad aa 04	lda $04aa			lda 	TokenLineNumber 			; find the line - it cannot exist.
.8349	ae ab 04	ldx $04ab			ldx 	TokenLineNumber+1 			; so this can't fail, it returns some point in the code.
.834c	20 4e a6	jsr $a64e			jsr 	MemorySearch
.834f	18		clc				clc 								; insert at this point.
.8350	20 a6 a5	jsr $a5a6			jsr 	MemoryInsertLine 			; insert the line
.8353					_EPCNoInsert:
.8353	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/warmstart.asm

.8354					WarmStart:
.8354	a2 ff		ldx #$ff			ldx 	#$FF
.8356	9a		txs				txs
.8357	20 f8 a9	jsr $a9f8			jsr 	EXTInputLine 				; get line to lineBuffer
.835a	20 88 b6	jsr $b688			jsr 	TokeniseLine 				; tokenise the line
.835d	ad aa 04	lda $04aa			lda 	TokenLineNumber 			; line number ?
.8360	0d ab 04	ora $04ab			ora 	TokenLineNumber+1
.8363	d0 17		bne $837c			bne 	_WSEditCode 				; if so,edit code.
.8365	9c a9 04	stz $04a9			stz 	TokenOffset 				; zero offset, meaning it only runs one line.
.8368	a9 a9		lda #$a9			lda 	#((TokenOffset) & $FF)
.836a	85 30		sta $30				sta 	codePtr
.836c	a9 04		lda #$04			lda 	#((TokenOffset) >> 8)
.836e	85 31		sta $31				sta 	codePtr+1
.8370	ad ac 04	lda $04ac			lda 	TokenBuffer 				; nothing to run
.8373	c9 80		cmp #$80			cmp 	#KWC_EOL
.8375	f0 dd		beq $8354			beq 	WarmStart
.8377	20 95 8a	jsr $8a95			jsr 	RUNCodePointerLine 			; execute that line.
.837a	80 d8		bra $8354			bra 	WarmStart
.837c					_WSEditCode:
.837c	20 2f 83	jsr $832f			jsr 	EditProgramCode
.837f	20 ed 83	jsr $83ed			jsr 	ClearCommand
.8382	80 d0		bra $8354			bra 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assemble.asm

.8384					AssembleCommand:
.8384	a2 00		ldx #$00			ldx 	#0
.8386	20 15 9e	jsr $9e15			jsr 	Evaluate16BitInteger 		; start address
.8389	ad 08 04	lda $0408			lda 	NSMantissa0
.838c	8d 9e 04	sta $049e			sta 	AssemblerAddress
.838f	ad 10 04	lda $0410			lda 	NSMantissa1
.8392	8d 9f 04	sta $049f			sta 	AssemblerAddress+1
.8395	20 e0 8d	jsr $8de0			jsr 	CheckComma
.8398	20 35 9e	jsr $9e35			jsr 	Evaluate8BitInteger 		; options
.839b	ad 08 04	lda $0408			lda 	NSMantissa0
.839e	8d a0 04	sta $04a0			sta 	AssemblerControl
.83a1	60		rts				rts
.83a2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assert.asm

.83a3					AssertCommand:
.83a3	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.83a5	20 00 9e	jsr $9e00			jsr 	EvaluateInteger 			; the assert test
.83a8	20 e4 9e	jsr $9ee4			jsr 	NSMIsZero 					; exit if result is non zero.
.83ab	d0 05		bne $83b2			bne 	_ACExit
.83ad	a9 0a		lda #$0a		lda	#10
.83af	4c f1 8d	jmp $8df1		jmp	ErrorHandler
.83b2					_ACExit:
.83b2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/call.asm

.83b3					CallCommand:
.83b3	a2 00		ldx #$00			ldx 	#0
.83b5	20 15 9e	jsr $9e15			jsr 	Evaluate16BitInteger
.83b8					_CCClear
.83b8	e8		inx				inx  								; clear 1,2 and 3 (for A X Y)
.83b9	20 b4 9e	jsr $9eb4			jsr 	NSMSetZero
.83bc	e0 04		cpx #$04			cpx 	#4
.83be	d0 f8		bne $83b8			bne 	_CCClear
.83c0	a2 00		ldx #$00			ldx 	#0 							; and keep trying
.83c2					_CCCParam:
.83c2	b1 30		lda ($30),y			lda 	(codePtr),y
.83c4	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.83c6	d0 09		bne $83d1			bne 	_CCCRun6502
.83c8	c8		iny				iny 								; skip comma
.83c9	e8		inx				inx	 								; next level
.83ca	20 35 9e	jsr $9e35			jsr 	Evaluate8BitInteger 		; get A/X/Y
.83cd	e0 03		cpx #$03			cpx 	#3
.83cf	90 f1		bcc $83c2			bcc 	_CCCParam 					; done all 3 ?
.83d1					_CCCRun6502:
.83d1	5a		phy				phy 								; save position
.83d2	ad 10 04	lda $0410			lda 	NSMantissa1 				; put address in zTemp0
.83d5	85 37		sta $37				sta 	zTemp0+1
.83d7	ad 08 04	lda $0408			lda 	NSMantissa0
.83da	85 36		sta $36				sta 	zTemp0
.83dc	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; get registers
.83df	ae 0a 04	ldx $040a			ldx 	NSMantissa0+2
.83e2	ac 0b 04	ldy $040b			ldy 	NSMantissa0+3
.83e5	20 ea 83	jsr $83ea			jsr 	_CCCZTemp0 					; call zTemp0
.83e8	7a		ply				ply 								; restore position and exit
.83e9	60		rts				rts
.83ea					_CCCZTemp0:
.83ea	6c 36 00	jmp ($0036)			jmp 	(zTemp0)

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/clear.asm

.83ed					ClearCommand:
.83ed	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.83ef	85 36		sta $36				sta 	0+zTemp0
.83f1	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.83f3	85 37		sta $37				sta 	1+zTemp0
.83f5					_ClearZeroLoop:
.83f5	b2 36		lda ($36)			lda 	(zTemp0) 					; end of variables
.83f7	f0 24		beq $841d			beq 	_ClearZeroEnd
.83f9	a0 03		ldy #$03			ldy 	#3 							; erase the variables
.83fb	a9 00		lda #$00			lda 	#0
.83fd					_ClearOneVariable:
.83fd	91 36		sta ($36),y			sta 	(zTemp0),y
.83ff	c8		iny				iny
.8400	c0 08		cpy #$08			cpy 	#8
.8402	d0 f9		bne $83fd			bne 	_ClearOneVariable
.8404	a0 02		ldy #$02			ldy 	#2 							; has it been marked procedure
.8406	b1 36		lda ($36),y			lda 	(zTemp0),y
.8408	c9 18		cmp #$18			cmp 	#NSTProcedure
.840a	d0 04		bne $8410			bne 	_ClearNotProcedure
.840c	a9 04		lda #$04			lda 	#NSTInteger+NSBIsArray 		; set it back to an integer array
.840e	91 36		sta ($36),y			sta 	(zTemp0),y
.8410					_ClearNotProcedure:
.8410	18		clc				clc 								; go to the next variable
.8411	b2 36		lda ($36)			lda 	(zTemp0)
.8413	65 36		adc $36				adc 	zTemp0
.8415	85 36		sta $36				sta 	zTemp0
.8417	90 dc		bcc $83f5			bcc 	_ClearZeroLoop
.8419	e6 37		inc $37				inc 	zTemp0+1
.841b	80 d8		bra $83f5			bra 	_ClearZeroLoop
.841d					_ClearZeroEnd:
.841d	18		clc				clc
.841e	a5 36		lda $36				lda 	zTemp0
.8420	69 01		adc #$01			adc 	#1
.8422	8d 8c 04	sta $048c			sta 	lowMemPtr
.8425	a5 37		lda $37				lda 	zTemp0+1
.8427	69 00		adc #$00			adc 	#0
.8429	8d 8d 04	sta $048d			sta 	lowMemPtr+1
.842c	20 8f a7	jsr $a78f			jsr 	StackReset
.842f	20 f9 a7	jsr $a7f9			jsr 	StringSystemInitialise
.8432	20 e1 8c	jsr $8ce1			jsr 	ProcedureScan
.8435	20 44 8a	jsr $8a44			jsr 	Command_Restore
.8438	9c 9e 04	stz $049e			stz 	AssemblerAddress
.843b	9c 9f 04	stz $049f			stz 	AssemblerAddress+1
.843e	9c a0 04	stz $04a0			stz 	AssemblerControl
.8441	20 7d 9a	jsr $9a7d			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.8444	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/cls.asm

.8445					ClearScreen:
.8445	5a		phy				phy
.8446	a9 0c		lda #$0c			lda 	#12 						; char code 12 clears the screen.
.8448	20 6a a8	jsr $a86a			jsr 	EXTPrintCharacter
.844b	7a		ply				ply
.844c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/data.asm

.844d					Command_Data:
.844d	a9 3a		lda #$3a			lda 	#KWD_COLON 					; advance to colon/EOL
.844f	a2 80		ldx #$80			ldx 	#KWC_EOL
.8451	20 33 8d	jsr $8d33			jsr 	ScanForward
.8454	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dim.asm

.8455					DimCommand:
.8455	b1 30		lda ($30),y			lda 	(codePtr),y
.8457	29 c0		and #$c0			and 	#$C0
.8459	c9 40		cmp #$40			cmp 	#$40
.845b	d0 7a		bne $84d7			bne 	_DCSyntax
.845d	b1 30		lda ($30),y			lda 	(codePtr),y
.845f	18		clc				clc
.8460	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8462	85 3f		sta $3f				sta 	zaTemp+1
.8464	c8		iny				iny
.8465	b1 30		lda ($30),y			lda 	(codePtr),y
.8467	c8		iny				iny
.8468	85 3e		sta $3e				sta 	zaTemp
.846a	5a		phy				phy
.846b	a0 02		ldy #$02			ldy 	#2 						; read type byte
.846d	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.846f	29 18		and #$18			and 	#NSBTypeMask 			; check it's not a procedure
.8471	c9 18		cmp #$18			cmp 	#NSTProcedure
.8473	f0 62		beq $84d7			beq 	_DCSyntax
.8475	b1 3e		lda ($3e),y			lda 	(zaTemp),y 				; check it's an array
.8477	29 04		and #$04			and 	#NSBIsArray
.8479	f0 64		beq $84df			beq 	_DCType
.847b	a0 04		ldy #$04			ldy 	#4 						; check not already defined
.847d	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.847f	d0 59		bne $84da			bne 	_DCRedefine
.8481	7a		ply				ply
.8482	20 e2 84	jsr $84e2			jsr 	_DCGetSize 				; get array size, check it.
.8485	5a		phy				phy
.8486	a0 05		ldy #$05			ldy 	#5 						; store in first array size slot
.8488	91 3e		sta ($3e),y			sta 	(zaTemp),y 				; second will be zero.
.848a	7a		ply				ply 							; is there a second (e.g. ,x)
.848b	b1 30		lda ($30),y			lda 	(codePtr),y
.848d	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.848f	d0 0a		bne $849b			bne 	_DCOneDimension
.8491	c8		iny				iny 							; skip comma
.8492	20 e2 84	jsr $84e2			jsr 	_DCGetSize 				; get 2nd array size
.8495	5a		phy				phy
.8496	a0 06		ldy #$06			ldy 	#6 						; store in 2nd array size
.8498	91 3e		sta ($3e),y			sta 	(zaTemp),y
.849a	7a		ply				ply
.849b					_DCOneDimension:
.849b	5a		phy				phy 							; save position
.849c	a0 05		ldy #$05			ldy 	#5 						; dimensions + 1 in AX (as zero based)
.849e	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84a0	aa		tax				tax
.84a1	c8		iny				iny
.84a2	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84a4	e8		inx				inx 							; bump them.
.84a5	1a		inc a				inc 	a
.84a6	20 49 9e	jsr $9e49			jsr 	Multiply8x8 			; work out the total number of elements -> zTemp0
.84a9	a5 37		lda $37				lda 	zTemp0+1 				; don't allow more than 8192 elements whatever
.84ab	29 e0		and #$e0			and 	#$E0
.84ad	d0 23		bne $84d2			bne 	_DCSize
.84af	a0 02		ldy #$02			ldy 	#2 						; get base type
.84b1	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84b3	20 f0 84	jsr $84f0			jsr 	ScaleByBaseType 		; scale by base type
.84b6	a5 36		lda $36				lda 	zTemp0
.84b8	a6 37		ldx $37				ldx 	zTemp0+1
.84ba	20 3f 9a	jsr $9a3f			jsr 	AllocateXABytes 		; allocate memory
.84bd	a0 03		ldy #$03			ldy 	#3 						; copy into the address.
.84bf	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84c1	c8		iny				iny
.84c2	8a		txa				txa
.84c3	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84c5	7a		ply				ply 							; get position back
.84c6	20 d8 8d	jsr $8dd8			jsr 	CheckRightBracket 		; check )
.84c9	b1 30		lda ($30),y			lda 	(codePtr),y
.84cb	c8		iny				iny 							; consume in case
.84cc	c9 2c		cmp #$2c			cmp 	#KWD_COMMA		 		; if so do another DIM.
.84ce	f0 85		beq $8455			beq 	DimCommand
.84d0	88		dey				dey 							; undo consume
.84d1	60		rts				rts
.84d2					_DCSize:
.84d2	a9 16		lda #$16		lda	#22
.84d4	4c f1 8d	jmp $8df1		jmp	ErrorHandler
.84d7					_DCSyntax:
.84d7	4c 3e a0	jmp $a03e			jmp 	SyntaxError
.84da					_DCRedefine:
.84da	a9 15		lda #$15		lda	#21
.84dc	4c f1 8d	jmp $8df1		jmp	ErrorHandler
.84df					_DCType:
.84df	4c 48 a0	jmp $a048			jmp 	TypeError
.84e2					_DCGetSize:
.84e2	a2 00		ldx #$00			ldx 	#0 						; get first index.
.84e4	20 35 9e	jsr $9e35			jsr 	Evaluate8BitInteger 	; get array dimension
.84e7	c9 00		cmp #$00			cmp 	#0 						; must be 1-254
.84e9	f0 e7		beq $84d2			beq 	_DCSize
.84eb	c9 fe		cmp #$fe			cmp 	#254
.84ed	f0 e3		beq $84d2			beq 	_DCSize
.84ef	60		rts				rts
.84f0					ScaleByBaseType:
.84f0	29 10		and #$10			and 	#NSBIsString 			; is it string
.84f2	d0 19		bne $850d			bne 	_SBBTString
.84f4	a5 37		lda $37				lda 	zTemp0+1 				; push value on stack
.84f6	48		pha				pha
.84f7	a5 36		lda $36				lda 	zTemp0
.84f9	48		pha				pha
.84fa	06 36		asl $36				asl 	zTemp0 					; x 2
.84fc	26 37		rol $37				rol 	zTemp0+1
.84fe	06 36		asl $36				asl 	zTemp0 					; x 4
.8500	26 37		rol $37				rol 	zTemp0+1
.8502	68		pla				pla 							; add stacked value = x 5
.8503	65 36		adc $36				adc 	zTemp0
.8505	85 36		sta $36				sta 	zTemp0
.8507	68		pla				pla
.8508	65 37		adc $37				adc 	zTemp0+1
.850a	85 37		sta $37				sta 	zTemp0+1
.850c	60		rts				rts
.850d					_SBBTString:
.850d	06 36		asl $36				asl 	zTemp0
.850f	26 37		rol $37				rol 	zTemp0+1
.8511	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/end.asm

.8512					EndCommand:
.8512	4c 54 83	jmp $8354			jmp 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/for.asm

.8515					ForCommand:
.8515	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; allocate 18 bytes on the return stack.
.8517	20 2a a7	jsr $a72a			jsr 	StackOpen
.851a	a2 00		ldx #$00			ldx 	#0
.851c	20 7a 98	jsr $987a			jsr 	EvaluateTerm
.851f	bd 00 04	lda $0400,x			lda 	NSStatus,x
.8522	c9 20		cmp #$20			cmp 	#NSBIsReference+NSTInteger 	; do we have an integer 4 byte reference.
.8524	d0 49		bne $856f			bne		_FCError
.8526	a9 3d		lda #$3d			lda 	#KWD_EQUAL 					; =
.8528	20 e8 8d	jsr $8de8			jsr 	CheckNextA
.852b	e8		inx				inx
.852c	20 00 9e	jsr $9e00			jsr 	EvaluateInteger 			; <from> in +1
.852f	b1 30		lda ($30),y			lda 	(codePtr),y
.8531	c8		iny				iny 								; consume it
.8532	48		pha				pha 								; save on stack for later
.8533	c9 b4		cmp #$b4			cmp 	#KWD_DOWNTO
.8535	f0 04		beq $853b			beq 	_FCNoSyntax
.8537	c9 ce		cmp #$ce			cmp 	#KWD_TO
.8539	d0 37		bne $8572			bne 	_FCSyntaxError
.853b					_FCNoSyntax:
.853b	e8		inx				inx
.853c	20 00 9e	jsr $9e00			jsr 	EvaluateInteger
.853f	20 6e a7	jsr $a76e			jsr 	STKSaveCodePosition 		; save loop back position
.8542	68		pla				pla 								; restore DOWNTO or TO
.8543	5a		phy				phy 								; save Y on the stack
.8544	49 b4		eor #$b4			eor 	#KWD_DOWNTO 				; 0 if DOWNTO, #0 if TO
.8546	f0 02		beq $854a			beq 	_FCNotDownTo
.8548	a9 02		lda #$02			lda 	#2
.854a					_FCNotDownTo:
.854a	3a		dec a				dec 	a 							; 255 if DOWNTO, 1 if TO
.854b	a0 10		ldy #$10			ldy 	#16
.854d	91 34		sta ($34),y			sta 	(basicStack),y 				; copy that out to the Basic Stack.
.854f	a0 06		ldy #$06			ldy 	#6
.8551	ad 08 04	lda $0408			lda 	NSMantissa0
.8554	91 34		sta ($34),y			sta 	(basicStack),y
.8556	ad 10 04	lda $0410			lda 	NSMantissa1
.8559	c8		iny				iny
.855a	91 34		sta ($34),y			sta 	(basicStack),y
.855c	a0 08		ldy #$08			ldy 	#8 							; set initial index value
.855e	a2 01		ldx #$01			ldx 	#1
.8560	20 75 85	jsr $8575			jsr 	FCIntegerToStack
.8563	a0 0c		ldy #$0c			ldy 	#12 						; set the terminal value
.8565	a2 02		ldx #$02			ldx 	#2
.8567	20 75 85	jsr $8575			jsr 	FCIntegerToStack
.856a	20 95 85	jsr $8595			jsr 	CopyIndexToReference
.856d	7a		ply				ply 								; restore position
.856e	60		rts				rts
.856f					_FCError:
.856f	4c 48 a0	jmp $a048			jmp 	TypeError
.8572					_FCSyntaxError:
.8572	4c 3e a0	jmp $a03e			jmp 	SyntaxError
.8575					FCIntegerToStack:
.8575	3c 00 04	bit $0400,x			bit 	NSStatus,x 					; is the value negative
.8578	10 03		bpl $857d			bpl	 	_FCNotNegative
.857a	20 69 9e	jsr $9e69			jsr 	NSMNegateMantissa 			; if so 2's complement the mantissa
.857d					_FCNotNegative:
.857d	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy out to the basic stack
.8580	91 34		sta ($34),y			sta 	(basicStack),y
.8582	c8		iny				iny
.8583	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.8586	91 34		sta ($34),y			sta 	(basicStack),y
.8588	c8		iny				iny
.8589	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.858c	91 34		sta ($34),y			sta 	(basicStack),y
.858e	c8		iny				iny
.858f	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.8592	91 34		sta ($34),y			sta 	(basicStack),y
.8594	60		rts				rts
.8595					CopyIndexToReference:
.8595	5a		phy				phy
.8596	a0 06		ldy #$06			ldy 	#6 							; copy address-8 to write to zTemp0
.8598	38		sec				sec 								; (because we copy from offset 8)
.8599	b1 34		lda ($34),y			lda 	(basicStack),y
.859b	e9 08		sbc #$08			sbc 	#8
.859d	85 36		sta $36				sta 	zTemp0
.859f	c8		iny				iny
.85a0	b1 34		lda ($34),y			lda 	(basicStack),y
.85a2	e9 00		sbc #$00			sbc 	#0
.85a4	85 37		sta $37				sta 	zTemp0+1
.85a6	a2 04		ldx #$04			ldx 	#4 							; this is the copy counter/
.85a8	a0 0b		ldy #$0b			ldy 	#8+3 		 				; the MSB of the mantissa
.85aa	b1 34		lda ($34),y			lda 	(basicStack),y
.85ac	0a		asl a				asl 	a 							; into carry
.85ad	a0 08		ldy #$08			ldy 	#8 							; where to copy from.
.85af	90 14		bcc $85c5			bcc 	_CITRNormal
.85b1	38		sec				sec
.85b2					_CITRNegative:
.85b2	a9 00		lda #$00			lda 	#0
.85b4	f1 34		sbc ($34),y			sbc 	(basicStack),y
.85b6	91 36		sta ($36),y			sta 	(zTemp0),y
.85b8	c8		iny				iny
.85b9	ca		dex				dex
.85ba	d0 f6		bne $85b2			bne 	_CITRNegative
.85bc	88		dey				dey 								; look at MSB of mantissa
.85bd	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set the MSB as negative packed.
.85bf	09 80		ora #$80			ora 	#$80
.85c1	91 36		sta ($36),y			sta 	(zTemp0),y
.85c3	7a		ply				ply
.85c4	60		rts				rts
.85c5					_CITRNormal:
.85c5	b1 34		lda ($34),y			lda 	(basicStack),y 				; copy without negation.
.85c7	91 36		sta ($36),y			sta 	(zTemp0),y
.85c9	c8		iny				iny
.85ca	ca		dex				dex
.85cb	d0 f8		bne $85c5			bne 	_CITRNormal
.85cd	7a		ply				ply 								; and exit.
.85ce	60		rts				rts
.85cf					NextCommand:
.85cf	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; check FOR is TOS
.85d1	a2 11		ldx #$11			ldx 	#ERRID_FOR 					; this error
.85d3	20 56 a7	jsr $a756			jsr 	StackCheckFrame
.85d6	5a		phy				phy
.85d7	a0 10		ldy #$10			ldy 	#16 						; get the step count
.85d9	b1 34		lda ($34),y			lda 	(basicStack),y
.85db	85 36		sta $36				sta 	zTemp0 						; this is the sign extend
.85dd	30 02		bmi $85e1			bmi 	_NCStepNeg
.85df	64 36		stz $36				stz 	zTemp0 						; which is 0 or 255
.85e1					_NCStepNeg:
.85e1	a0 08		ldy #$08			ldy 	#8 							; offset to bump
.85e3	a2 04		ldx #$04			ldx 	#4 							; count to bump
.85e5	18		clc				clc
.85e6					_NCBump:
.85e6	71 34		adc ($34),y			adc 	(basicStack),y 				; add it
.85e8	91 34		sta ($34),y			sta 	(basicStack),y
.85ea	a5 36		lda $36				lda 	zTemp0 						; get sign extend for next time.
.85ec	c8		iny				iny 								; next byte
.85ed	ca		dex				dex 								; do four times
.85ee	d0 f6		bne $85e6			bne 	_NCBump
.85f0	20 95 85	jsr $8595			jsr		CopyIndexToReference		; copy it to the reference variable.
.85f3	a0 10		ldy #$10			ldy 	#16 						; get step count again
.85f5	b1 34		lda ($34),y			lda 	(basicStack),y
.85f7	0a		asl a				asl 	a 							; sign bit to carry
.85f8	a9 0c		lda #$0c			lda 	#12 						; offset of LHS = terminal offset
.85fa	85 38		sta $38				sta 	zTemp1
.85fc	90 02		bcc $8600			bcc 	_NCCompRev 					; use if step is +ve
.85fe	a9 08		lda #$08			lda 	#8 							; now the LHS = index value
.8600					_NCCompRev:
.8600	85 38		sta $38				sta 	zTemp1 						; so zTemp0 is the index for LHS
.8602	49 04		eor #$04			eor 	#(8^12) 					; and zTemp0+1 is the index for RHS
.8604	85 39		sta $39				sta 	zTemp1+1
.8606	a2 04		ldx #$04			ldx 	#4 							; bytes to compare
.8608	38		sec				sec
.8609					_NCCompare:
.8609	a4 38		ldy $38				ldy 	zTemp1 						; do compare using the two indices
.860b	b1 34		lda ($34),y			lda 	(basicStack),y
.860d	a4 39		ldy $39				ldy 	zTemp1+1
.860f	f1 34		sbc ($34),y			sbc 	(basicStack),y
.8611	e6 38		inc $38				inc 	zTemp1 						; bump the indices (inc,dex do not change C or V)
.8613	e6 39		inc $39				inc 	zTemp1+1
.8615	ca		dex				dex 								; do it 4 times.
.8616	d0 f1		bne $8609			bne 	_NCCompare
.8618	50 02		bvc $861c			bvc 	_NCNoOverflow 				; convert to signed comparison
.861a	49 80		eor #$80			eor 	#$80
.861c					_NCNoOverflow:
.861c	7a		ply				ply 								; restore Y position
.861d	0a		asl a				asl 	a 							; is bit 7 set.
.861e	90 04		bcc $8624			bcc 	_NCLoopback 				; if no , >= so loop back
.8620	20 48 a7	jsr $a748			jsr 	StackClose 					; exit the loop
.8623	60		rts				rts
.8624					_NCLoopBack:
.8624	20 7f a7	jsr $a77f			jsr 	STKLoadCodePosition 		; loop back
.8627	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/gosub.asm

.8628					Command_GOSUB:
.8628	a2 00		ldx #$00			ldx 	#0
.862a	20 15 9e	jsr $9e15			jsr 	Evaluate16BitInteger 		; line number in Stack.0
.862d	a9 e3		lda #$e3			lda 	#STK_GOSUB+3
.862f	20 2a a7	jsr $a72a			jsr 	StackOpen 					; create frame
.8632	20 6e a7	jsr $a76e			jsr 	STKSaveCodePosition 		; save current position
.8635	4c 4b 86	jmp $864b			jmp 	GotoStackX
.8638					Command_RETURN:
.8638	a9 e0		lda #$e0			lda 	#STK_GOSUB 					; check TOS is this
.863a	a2 0e		ldx #$0e			ldx 	#ERRID_GOSUB 				; this error
.863c	20 56 a7	jsr $a756			jsr 	StackCheckFrame
.863f	20 7f a7	jsr $a77f			jsr 	STKLoadCodePosition 		; restore code position
.8642	20 48 a7	jsr $a748			jsr 	StackClose
.8645	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/goto.asm

.8646					GotoCommand:
.8646	a2 00		ldx #$00			ldx 	#0 							; GOTO where
.8648	20 15 9e	jsr $9e15			jsr 	Evaluate16BitInteger
.864b					GotoStackX:
.864b	bd 10 04	lda $0410,x			lda  	NSMantissa1,x 				; put line # in XA. I'll keep this even though
.864e	48		pha				pha 								; it is slightly inefficient, just in cases.
.864f	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.8652	fa		plx				plx
.8653	20 4e a6	jsr $a64e			jsr 	MemorySearch 				; transfer to line number AX.
.8656	90 05		bcc $865d			bcc 	_GotoError 					; not found, off end.
.8658	d0 03		bne $865d			bne 	_GotoError 					; not found exactly
.865a	4c 8e 8a	jmp $8a8e			jmp 	RunNewLine 					; and go straight to new line code.
.865d					_GotoError:
.865d	a9 0d		lda #$0d		lda	#13
.865f	4c f1 8d	jmp $8df1		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/if.asm

.8662					IfCommand:
.8662	a2 00		ldx #$00			ldx 	#0 							; If what.
.8664	20 dd 9d	jsr $9ddd			jsr 	EvaluateNumber
.8667	b1 30		lda ($30),y			lda 	(codePtr),y
.8669	c9 a8		cmp #$a8			cmp 	#KWD_THEN  					; could be THEN <stuff> or GOTO
.866b	d0 0a		bne $8677			bne 	_IFStructured
.866d	c8		iny				iny 								; consume THEN
.866e	20 e4 9e	jsr $9ee4			jsr 	NSMIsZero 					; is it zero
.8671	f0 01		beq $8674			beq 	_IfFail 					; if fail, go to next line
.8673	60		rts				rts 								; if THEN just continue
.8674					_IfFail:
.8674	4c 76 8a	jmp $8a76			jmp 	EOLCommand
.8677					_IfStructured:
.8677	20 e4 9e	jsr $9ee4			jsr 	NSMIsZero 					; is it zero
.867a	d0 07		bne $8683			bne 	_IfExit 					; if not, then continue normally.
.867c	a9 b5		lda #$b5			lda 	#KWD_ELSE 					; look for else/endif
.867e	a2 a5		ldx #$a5			ldx 	#KWD_ENDIF
.8680	20 33 8d	jsr $8d33			jsr 	ScanForward 				; and run from there/
.8683					_IfExit:
.8683	60		rts				rts
.8684					ElseCode:
.8684	a9 a5		lda #$a5			lda 	#KWD_ENDIF 					; else is only run after the if clause succeeds
.8686	aa		tax				tax 								; so just go to the structure exit
.8687	20 33 8d	jsr $8d33			jsr 	ScanForward
.868a	60		rts				rts
.868b					EndIf:
.868b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/inputprint.asm

.868c					Command_Input:
.868c	a9 ff		lda #$ff			lda 	#$FF
.868e	8d a8 04	sta $04a8			sta 	IsInputFlag
.8691	80 03		bra $8696			bra 	Command_IP_Main
.8693					Command_Print:
.8693	9c a8 04	stz $04a8			stz 	IsInputFlag
.8696					Command_IP_Main:
.8696	18		clc				clc 								; carry being clear means last print wasn't comma/semicolon
.8697					_CPLoop:
.8697	08		php				php 								; save last action flag
.8698	b1 30		lda ($30),y			lda 	(codePtr),y
.869a	c9 80		cmp #$80			cmp  	#KWC_EOL 					; end of line or colon, exit now.
.869c	f0 58		beq $86f6			beq 	_CPExit
.869e	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.86a0	f0 54		beq $86f6			beq 	_CPExit
.86a2	68		pla				pla 								; throw last action flag
.86a3	b1 30		lda ($30),y			lda 	(codePtr),y
.86a5	c8		iny				iny
.86a6	c9 3b		cmp #$3b			cmp 	#KWD_SEMICOLON				; is it a semicolon
.86a8	f0 49		beq $86f3			beq 	_CPContinueWithSameLine
.86aa	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; comma
.86ac	f0 40		beq $86ee			beq 	_CPTab
.86ae	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; apostrophe (new line)
.86b0	f0 38		beq $86ea			beq 	_CPNewLine
.86b2	88		dey				dey 								; undo the get.
.86b3	20 9e 93	jsr $939e			jsr 	EvaluateExpressionAt0 		; evaluate expression at 0.
.86b6	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; read the status
.86b9	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.86bb	f0 0d		beq $86ca			beq 	_CPIsValue
.86bd	ad a8 04	lda $04a8			lda 	IsInputFlag 				; if print, dereference and print.
.86c0	f0 05		beq $86c7			beq 	_CPIsPrint
.86c2	20 ff 86	jsr $86ff			jsr 	CIInputValue 				; input a value to the reference
.86c5	80 23		bra $86ea			bra 	_CPNewLine
.86c7					_CPIsPrint:
.86c7	20 be 96	jsr $96be			jsr 	Dereference
.86ca					_CPIsValue:
.86ca	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; is it a number
.86cd	29 10		and #$10			and 	#NSBIsString
.86cf	f0 0b		beq $86dc			beq 	_CPNumber
.86d1	ae 10 04	ldx $0410			ldx 	NSMantissa1 				; string, print the text.
.86d4	ad 08 04	lda $0408			lda 	NSMantissa0
.86d7	20 68 87	jsr $8768			jsr 	CPPrintStringXA
.86da	80 ba		bra $8696			bra 	Command_IP_Main 			; loop round clearing carry so NL if end
.86dc					_CPNumber:
.86dc	a9 05		lda #$05			lda 	#5 							; maximum decimals
.86de	20 aa 9c	jsr $9caa			jsr 	ConvertNumberToString 		; convert to string
.86e1	a2 06		ldx #$06			ldx 	#DecimalBuffer >> 8
.86e3	a9 1c		lda #$1c			lda 	#DecimalBuffer & $FF
.86e5	20 68 87	jsr $8768			jsr 	CPPrintStringXA
.86e8	80 ac		bra $8696			bra 	Command_IP_Main				; loop round clearing carry so NL if end
.86ea					_CPNewLine:
.86ea	a9 0d		lda #$0d			lda 	#13
.86ec	80 02		bra $86f0			bra 	_CPPrintChar
.86ee					_CPTab:
.86ee	a9 09		lda #$09			lda 	#9 							; print TAB
.86f0					_CPPrintChar:
.86f0	20 7b 87	jsr $877b			jsr 	CPPrintVector
.86f3					_CPContinueWithSameLine:
.86f3	38		sec				sec 								; loop round with carry set, which
.86f4	80 a1		bra $8697			bra 	_CPLoop 					; will inhibit final CR
.86f6					_CPExit:
.86f6	28		plp				plp 								; get last action flag
.86f7	b0 05		bcs $86fe			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.86f9	a9 0d		lda #$0d			lda 	#13 						; print new line
.86fb	20 7b 87	jsr $877b			jsr 	CPPrintVector
.86fe					_CPExit2:
.86fe	60		rts				rts
.86ff					CIInputValue:
.86ff	a2 00		ldx #$00			ldx 	#0 							; input a line.
.8701					_CIInputLine:
.8701	20 7e 87	jsr $877e			jsr 	CPInputVector 				; get key
.8704	c9 0d		cmp #$0d			cmp 	#13 						; 13 = End
.8706	f0 1f		beq $8727			beq 	_CIHaveValue
.8708	c9 08		cmp #$08			cmp 	#8 							; 8 = BS
.870a	f0 11		beq $871d			beq 	_CIBackspace
.870c	c9 20		cmp #$20			cmp 	#32 						; ignore other control characters
.870e	90 f1		bcc $8701			bcc 	_CIInputLine
.8710	e0 50		cpx #$50			cpx 	#80 						; max length
.8712	b0 ed		bcs $8701			bcs 	_CIInputLine
.8714	9d a9 05	sta $05a9,x			sta 	lineBuffer,x
.8717	e8		inx				inx
.8718	20 7b 87	jsr $877b			jsr 	CPPrintVector 				; echo it.
.871b	80 e4		bra $8701			bra 	_CIInputLine
.871d					_CIBackSpace:
.871d	e0 00		cpx #$00			cpx 	#0 							; nothing to delete
.871f	f0 e0		beq $8701			beq 	_CIInputLine
.8721	20 7b 87	jsr $877b			jsr 	CPPrintVector 				; echo it.
.8724	ca		dex				dex
.8725	80 da		bra $8701			bra 	_CIInputLine
.8727					_CIHaveValue:
.8727	9e a9 05	stz $05a9,x			stz 	LineBuffer,x 				; ASCIIZ string now in line buffer.
.872a	ad 00 04	lda $0400			lda 	NSStatus 					; was it a string assignment
.872d	29 10		and #$10			and 	#NSBIsString
.872f	f0 1c		beq $874d			beq 	_CIAssignNumber 			; assign a number
.8731	a2 01		ldx #$01			ldx 	#1
.8733	a9 a9		lda #$a9			lda 	#lineBuffer & $FF 			; set up to point to new string
.8735	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.8738	a9 05		lda #$05			lda 	#lineBuffer >> 8
.873a	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.873d	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.8740	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.8743	a9 10		lda #$10			lda 	#NSBIsString 				; so it becomes a string value
.8745	9d 00 04	sta $0400,x			sta  	NSStatus,x
.8748	ca		dex				dex 								; X = 0
.8749	20 bd 87	jsr $87bd			jsr 	AssignVariable
.874c	60		rts				rts
.874d					_CIAssignNumber:
.874d	a9 a9		lda #$a9			lda 	#lineBuffer & $FF 			; set up to point to new string
.874f	85 36		sta $36				sta 	zTemp0
.8751	a9 05		lda #$05			lda 	#lineBuffer >> 8
.8753	85 37		sta $37				sta 	zTemp0+1
.8755	a2 01		ldx #$01			ldx 	#1 							; put in slot 1
.8757	20 2c 9c	jsr $9c2c			jsr 	ValEvaluateZTemp0 			; use the VAL() code
.875a	90 07		bcc $8763			bcc 	_CIIsOkay
.875c	a9 3f		lda #$3f			lda 	#"?" 						; error ?
.875e	20 7b 87	jsr $877b			jsr 	CPPrintVector
.8761	80 9c		bra $86ff			bra 	CIInputValue
.8763					_CIIsOkay:
.8763	ca		dex				dex 								; X = 0
.8764	20 bd 87	jsr $87bd			jsr 	AssignVariable
.8767	60		rts				rts
.8768					CPPrintStringXA:
.8768	5a		phy				phy
.8769	86 37		stx $37				stx 	zTemp0+1
.876b	85 36		sta $36				sta 	zTemp0
.876d	a0 00		ldy #$00			ldy 	#0
.876f					_PSXALoop:
.876f	b1 36		lda ($36),y			lda 	(zTemp0),y
.8771	f0 06		beq $8779			beq 	_PSXAExit
.8773	20 7b 87	jsr $877b			jsr 	CPPrintVector
.8776	c8		iny				iny
.8777	80 f6		bra $876f			bra 	_PSXALoop
.8779					_PSXAExit:
.8779	7a		ply				ply
.877a	60		rts				rts
.877b					CPPrintVector:
.877b	4c 6a a8	jmp $a86a			jmp 	EXTPrintCharacter
.877e					CPInputVector:
.877e	4c 00 ab	jmp $ab00			jmp 	EXTInputSingleCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/let.asm

.8781					LetCommand:
.8781	a2 00		ldx #$00			ldx 	#0
.8783	b1 30		lda ($30),y			lda 	(codePtr),y
.8785	c9 10		cmp #$10			cmp 	#KWD_AT
.8787	d0 16		bne $879f			bne 	_LCStandard
.8789	c8		iny				iny 								; skip equal
.878a	20 7a 98	jsr $987a			jsr 	EvaluateTerm 				; get a number
.878d	20 be 96	jsr $96be			jsr 	Dereference 				; dereference it
.8790	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check integer
.8793	49 20		eor #$20			eor 	#NSBIsReference	 			; toggle reference
.8795	9d 00 04	sta $0400,x			sta 	NSStatus,x
.8798	29 20		and #$20			and 	#NSBIsReference 			; if it is now a reference, continue
.879a	d0 10		bne $87ac			bne 	_LCMain
.879c	4c 48 a0	jmp $a048			jmp 	TypeError 					; was a reference before.
.879f					_LCStandard:
.879f	ad 88 93	lda $9388			lda 	PrecedenceLevel+"*"			; precedence > this
.87a2	20 a2 93	jsr $93a2			jsr 	EvaluateExpressionAtPrecedence
.87a5	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; is it a reference to an array
.87a8	c9 38		cmp #$38			cmp		#NSTProcedure+NSBIsReference
.87aa	f0 0e		beq $87ba			beq 	_LetGoProc 					; it's a procedure call.
.87ac					_LCMain:
.87ac	a9 3d		lda #$3d			lda 	#"=" 						; check =
.87ae	20 e8 8d	jsr $8de8			jsr 	CheckNextA
.87b1	e8		inx				inx 								; RHS
.87b2	20 d4 9d	jsr $9dd4			jsr 	EvaluateValue
.87b5	ca		dex				dex
.87b6	20 bd 87	jsr $87bd			jsr 	AssignVariable
.87b9	60		rts				rts
.87ba					_LetGoProc:
.87ba	4c 4e 89	jmp $894e			jmp 	CallProcedure
.87bd					AssignVariable:
.87bd	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check the string/number type bits match
.87c0	48		pha				pha 								; save a copy
.87c1	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.87c4	29 10		and #$10			and 	#NSBIsString
.87c6	d0 0b		bne $87d3			bne 	_ASError
.87c8	68		pla				pla 								; get back
.87c9	29 10		and #$10			and 	#NSBIsString 				; check type
.87cb	d0 03		bne $87d0			bne 	_ASString
.87cd	4c e6 95	jmp $95e6			jmp 	AssignNumber
.87d0					_ASString:
.87d0	4c 54 96	jmp $9654			jmp 	AssignString
.87d3					_ASError:
.87d3	4c 48 a0	jmp $a048			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/list.asm

.87d6					Command_List:
.87d6	9c a6 04	stz $04a6			stz 	listIndent 					; reset indent.
.87d9	9c 0c 04	stz $040c			stz		NSMantissa0+4				; set the lower (slot 4) to 0 and upper (slot 7) to $FFFF
.87dc	9c 14 04	stz $0414			stz 	NSMantissa1+4
.87df	a9 ff		lda #$ff			lda 	#$FF
.87e1	8d 0f 04	sta $040f			sta 	NSMantissa0+7
.87e4	8d 17 04	sta $0417			sta 	NSMantissa1+7
.87e7	b1 30		lda ($30),y			lda 	(codePtr),y
.87e9	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.87eb	f0 1e		beq $880b			beq 	_CLSecond
.87ed	20 6c 88	jsr $886c			jsr 	CLIsDigit 					; if not digit, list all
.87f0	b0 24		bcs $8816			bcs 	_CLStart
.87f2	a2 04		ldx #$04			ldx 	#4 							; get 1st range into slot 4
.87f4	20 15 9e	jsr $9e15			jsr 	Evaluate16BitInteger
.87f7	b1 30		lda ($30),y			lda 	(codePtr),y
.87f9	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.87fb	f0 0e		beq $880b			beq 	_CLSecond 					; if so go get it
.87fd	ad 0c 04	lda $040c			lda 	NSMantissa0+4 				; copy 4->7
.8800	8d 0f 04	sta $040f			sta 	NSMantissa0+7
.8803	ad 14 04	lda $0414			lda 	NSMantissa1+4
.8806	8d 17 04	sta $0417			sta 	NSMantissa1+7
.8809	80 0b		bra $8816			bra 	_CLStart
.880b					_CLSecond:
.880b	c8		iny				iny 								; consume comma
.880c	20 6c 88	jsr $886c			jsr 	CLIsDigit 					; digit found
.880f	b0 05		bcs $8816			bcs 	_CLStart 					; if not, continue listing
.8811	a2 07		ldx #$07			ldx 	#7 							; load 2nd range into slot 7
.8813	20 15 9e	jsr $9e15			jsr 	Evaluate16BitInteger
.8816					_CLStart
.8816	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8818	85 30		sta $30				sta 	codePtr
.881a	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.881c	85 31		sta $31				sta 	codePtr+1
.881e					_CLLoop:
.881e	20 20 ab	jsr $ab20			jsr 	EXTBreakCheck 				; break check
.8821	f0 33		beq $8856			beq 	_CLExit
.8823	b2 30		lda ($30)			lda 	(codePtr)
.8825	f0 2f		beq $8856			beq 	_CLExit
.8827	a2 04		ldx #$04			ldx 	#4 							; check range every time, line numbers aren't in order.
.8829	20 59 88	jsr $8859			jsr 	CLCompareLineNo
.882c	90 1b		bcc $8849			bcc 	_CLNext
.882e	a2 07		ldx #$07			ldx 	#7
.8830	20 59 88	jsr $8859			jsr 	CLCompareLineNo
.8833	f0 02		beq $8837			beq 	_CLDoThisOne
.8835	b0 12		bcs $8849			bcs 	_CLNext
.8837					_CLDoThisOne:
.8837	20 96 8d	jsr $8d96			jsr 	ScanGetCurrentLineStep 		; get indent adjust.
.883a	20 6a b4	jsr $b46a			jsr 	ListConvertLine 			; convert line into token Buffer
.883d	a2 04		ldx #$04			ldx 	#(tokenBuffer >> 8) 		; print that line
.883f	a9 ac		lda #$ac			lda 	#(tokenBuffer & $FF)
.8841	20 4a 8e	jsr $8e4a			jsr 	PrintStringXA
.8844	a9 0d		lda #$0d			lda 	#13 						; new line
.8846	20 6a a8	jsr $a86a			jsr 	EXTPrintCharacter
.8849					_CLNext:
.8849	18		clc				clc
.884a	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.884c	65 30		adc $30				adc 	codePtr
.884e	85 30		sta $30				sta 	codePtr
.8850	90 02		bcc $8854			bcc 	_CREExit
.8852	e6 31		inc $31				inc 	codePtr+1
.8854					_CREExit:
.8854	80 c8		bra $881e			bra 	_CLLoop
.8856					_CLExit:
.8856	4c 54 83	jmp $8354			jmp 	WarmStart
.8859					CLCompareLineNo:
.8859	38		sec				sec
.885a	a0 01		ldy #$01			ldy 	#1
.885c	b1 30		lda ($30),y			lda 	(codePtr),y
.885e	fd 08 04	sbc $0408,x			sbc 	NSMantissa0,x
.8861	85 36		sta $36				sta 	zTemp0
.8863	c8		iny				iny
.8864	b1 30		lda ($30),y			lda 	(codePtr),y
.8866	fd 10 04	sbc $0410,x			sbc 	NSMantissa1,x
.8869	05 36		ora $36				ora 	zTemp0
.886b	60		rts				rts
.886c					CLIsDigit:
.886c	b1 30		lda ($30),y			lda 	(codePtr),y
.886e	c9 30		cmp #$30			cmp 	#"0"
.8870	90 03		bcc $8875			bcc	 	_CLIDExitFalse
.8872	c9 3a		cmp #$3a			cmp 	#"9"+1
.8874	60		rts				rts
.8875					_CLIDExitFalse:
.8875	38		sec				sec
.8876	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/local.asm

.8877					Command_LOCAL:
.8877	a2 00		ldx #$00			ldx 	#0 							; at level 0
.8879	20 85 88	jsr $8885			jsr 	LocaliseNextTerm 			; convert term to a local.
.887c	b1 30		lda ($30),y			lda 	(codePtr),y
.887e	c8		iny				iny
.887f	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8881	f0 f4		beq $8877			beq 	Command_LOCAL
.8883	88		dey				dey 								; unpick pre-get
.8884	60		rts				rts
.8885					LocaliseNextTerm:
.8885	20 7a 98	jsr $987a			jsr 	EvaluateTerm 				; evaluate the term
.8888	bd 00 04	lda $0400,x			lda 	NSStatus,x
.888b	29 20		and #$20			and 	#NSBIsReference 			; check it is a reference
.888d	f0 61		beq $88f0			beq		_LNTError
.888f	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address of variable to zTemp0
.8892	85 36		sta $36				sta 	zTemp0
.8894	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.8897	85 37		sta $37				sta  	zTemp0+1
.8899	bd 00 04	lda $0400,x			lda 	NSStatus,x
.889c	29 10		and #$10			and 	#NSBIsString
.889e	d0 1e		bne $88be			bne 	_LNTPushString
.88a0	5a		phy				phy
.88a1	a0 00		ldy #$00			ldy 	#0 							; push 0 to 4 inclusive, the number values, on the stack, and zero them as you go.
.88a3					_LNTPushNumLoop:
.88a3	b1 36		lda ($36),y			lda		(zTemp0),y
.88a5	20 08 a7	jsr $a708			jsr 	StackPushByte
.88a8	c8		iny				iny
.88a9	c0 05		cpy #$05			cpy 	#5
.88ab	d0 f6		bne $88a3			bne 	_LNTPushNumLoop
.88ad	a5 36		lda $36				lda 	zTemp0 						; push the actual target address to write on the stack
.88af	20 08 a7	jsr $a708			jsr 	StackPushByte
.88b2	a5 37		lda $37				lda 	zTemp0+1
.88b4	20 08 a7	jsr $a708			jsr 	StackPushByte
.88b7	a9 01		lda #$01			lda 	#STK_LOCALN 				; push local-number marker.
.88b9	20 08 a7	jsr $a708			jsr 	StackPushByte
.88bc	7a		ply				ply
.88bd	60		rts				rts
.88be					_LNTPushString:
.88be	5a		phy				phy
.88bf	b2 36		lda ($36)			lda 	(zTemp0) 					; put address of string in zTemp1
.88c1	85 38		sta $38				sta 	zTemp1
.88c3	a0 01		ldy #$01			ldy 	#1
.88c5	b1 36		lda ($36),y			lda 	(zTemp0),y
.88c7	85 39		sta $39				sta 	zTemp1+1
.88c9	a0 00		ldy #$00			ldy 	#0 							; output string
.88cb	c9 00		cmp #$00			cmp 	#0 							; if not assigned strin
.88cd	f0 0a		beq $88d9			beq 	_LNTStringOut
.88cf					_LNTPushStrLoop:
.88cf	b1 38		lda ($38),y			lda 	(zTemp1),y
.88d1	f0 06		beq $88d9			beq 	_LNTStringOut
.88d3	20 08 a7	jsr $a708			jsr 	StackPushByte
.88d6	c8		iny				iny
.88d7	80 f6		bra $88cf			bra 	_LNTPushStrLoop
.88d9					_LNTStringOut:
.88d9	98		tya				tya									; output length
.88da	20 08 a7	jsr $a708			jsr 	StackPushByte
.88dd	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; output address of the string record *not* the string itself
.88e0	20 08 a7	jsr $a708			jsr 	StackPushByte
.88e3	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.88e6	20 08 a7	jsr $a708			jsr 	StackPushByte
.88e9	a9 02		lda #$02			lda 	#STK_LOCALS 				; push local-string marker.
.88eb	20 08 a7	jsr $a708			jsr 	StackPushByte
.88ee	7a		ply				ply
.88ef	60		rts				rts
.88f0					_LNTError:
.88f0	4c 3e a0	jmp $a03e			jmp 	SyntaxError
.88f3					LocalPopValue:
.88f3	20 21 a7	jsr $a721			jsr 	StackPopByte
.88f6	c9 01		cmp #$01			cmp 	#STK_LOCALN 				; if not local-N
.88f8	d0 17		bne $8911			bne 	_LPVString
.88fa	20 21 a7	jsr $a721			jsr 	StackPopByte 				; address
.88fd	85 37		sta $37				sta 	zTemp0+1
.88ff	20 21 a7	jsr $a721			jsr 	StackPopByte
.8902	85 36		sta $36				sta 	zTemp0
.8904	5a		phy				phy
.8905	a0 04		ldy #$04			ldy 	#4 							; copy back
.8907					_LPVNumberCopy:
.8907	20 21 a7	jsr $a721			jsr 	StackPopByte
.890a	91 36		sta ($36),y			sta 	(zTemp0),y
.890c	88		dey				dey
.890d	10 f8		bpl $8907			bpl 	_LPVNumberCopy
.890f	7a		ply				ply 								; and complete
.8910	60		rts				rts
.8911					_LPVString:
.8911	20 21 a7	jsr $a721			jsr 	StackPopByte 				; address of record => zTemp0
.8914	85 37		sta $37				sta 	zTemp0+1
.8916	20 21 a7	jsr $a721			jsr 	StackPopByte
.8919	85 36		sta $36				sta 	zTemp0
.891b	5a		phy				phy
.891c	b2 36		lda ($36)			lda 	(zTemp0) 					; address to write string to => zTemp1
.891e	85 38		sta $38				sta 	zTemp1
.8920	a0 01		ldy #$01			ldy 	#1
.8922	b1 36		lda ($36),y			lda 	(zTemp0),y
.8924	85 39		sta $39				sta 	zTemp1+1
.8926	20 21 a7	jsr $a721			jsr 	StackPopByte 				; # to get => y
.8929	a8		tay				tay
.892a	a5 39		lda $39				lda 	zTemp1+1 					; if no target (e.g. was "" originally) exit
.892c	f0 0e		beq $893c			beq 	_LPVStringCopied
.892e	a9 00		lda #$00			lda 	#0 							; NULL on end
.8930	91 38		sta ($38),y			sta 	(zTemp1),y
.8932					_LPVStringCopy:
.8932	88		dey				dey
.8933	30 07		bmi $893c			bmi 	_LPVStringCopied
.8935	20 21 a7	jsr $a721			jsr 	StackPopByte
.8938	91 38		sta ($38),y			sta 	(zTemp1),y
.893a	80 f6		bra $8932			bra 	_LPVStringCopy
.893c					_LPVStringCopied:
.893c	fa		plx				plx
.893d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/new.asm

.893e					NewCommand:
.893e	20 44 89	jsr $8944			jsr 	NewProgram
.8941	4c 54 83	jmp $8354			jmp 	WarmStart
.8944					NewProgram:
.8944	20 2c a6	jsr $a62c			jsr 	MemoryNew
.8947	9c 00 10	stz $1000			stz 	VariableSpace 				; erase all variables.
.894a	20 ed 83	jsr $83ed			jsr 	ClearCommand 				; clear everything.
.894d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/procedure.asm

=2					ParameterStackPos = 2
.894e					CallProcedure:
.894e	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start storing parameters at 2.
.8950	b1 30		lda ($30),y			lda 	(codePtr),y
.8952	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.8954	f0 0c		beq $8962			beq 	_CPEndParam
.8956					_CPParamLoop:
.8956	20 d4 9d	jsr $9dd4			jsr 	EvaluateValue 				; get parameter onto stack
.8959	e8		inx				inx 								; bump next stack
.895a	b1 30		lda ($30),y			lda 	(codePtr),y
.895c	c8		iny				iny
.895d	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if comma, go back and try again.
.895f	f0 f5		beq $8956			beq 	_CPParamLoop
.8961	88		dey				dey 								; unpick.
.8962					_CPEndParam:
.8962	8e 96 04	stx $0496			stx 	LastParameter 				; save the last parameters index.
.8965	c8		iny				iny									; skip right bracket
.8966	a9 b3		lda #$b3			lda 	#STK_PROC+3 				; allocate 6 bytes on the return stack.
.8968	20 2a a7	jsr $a72a			jsr 	StackOpen
.896b	20 6e a7	jsr $a76e			jsr 	STKSaveCodePosition 		; save loop position
.896e	ad 08 04	lda $0408			lda 	NSMantissa0 				; copy variable (e.g. procedure) address to zTemp0
.8971	85 36		sta $36				sta 	zTemp0 						; this is the DATA not the RECORD
.8973	ad 10 04	lda $0410			lda 	NSMantissa1
.8976	85 37		sta $37				sta 	zTemp0+1
.8978	a0 01		ldy #$01			ldy 	#1 							; copy code address back.
.897a	b2 36		lda ($36)			lda 	(zTemp0)
.897c	85 30		sta $30				sta 	safePtr
.897e	b1 36		lda ($36),y			lda 	(zTemp0),y
.8980	85 31		sta $31				sta 	safePtr+1
.8982	c8		iny				iny
.8983	b1 36		lda ($36),y			lda 	(zTemp0),y
.8985	85 32		sta $32				sta 	safePtr+2
.8987	c8		iny				iny
.8988	b1 36		lda ($36),y			lda 	(zTemp0),y
.898a	85 33		sta $33				sta 	safePtr+3
.898c	c8		iny				iny 								; get Y offset -> Y
.898d	b1 36		lda ($36),y			lda 	(zTemp0),y
.898f	a8		tay				tay
.8990	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start position of parameters
.8992	ec 96 04	cpx $0496			cpx	 	LastParameter 				; check no parameters at the start
.8995	f0 13		beq $89aa			beq 	_ParamExit 					; if so, exit.
.8997					_ParamExtract:
.8997	ca		dex				dex 								; put a local term on the level before
.8998	20 85 88	jsr $8885			jsr 	LocaliseNextTerm			; also pushes original param value to basic stack
.899b	20 bd 87	jsr $87bd			jsr 	AssignVariable 				; assign stacked value to the variable.
.899e	e8		inx				inx 								; advance to next parameter to do.
.899f	e8		inx				inx
.89a0	ec 96 04	cpx $0496			cpx 	LastParameter 				; are we done ?
.89a3	f0 05		beq $89aa			beq 	_ParamExit
.89a5	20 e0 8d	jsr $8de0			jsr 	CheckComma 					; comma seperating parameters
.89a8	80 ed		bra $8997			bra 	_ParamExtract
.89aa					_ParamExit:
.89aa	20 d8 8d	jsr $8dd8			jsr 	CheckRightBracket 			; check )
.89ad	60		rts				rts 								; and continue from here
.89ae					Command_ENDPROC:
.89ae	a9 b0		lda #$b0			lda 	#STK_PROC 					; check TOS is this
.89b0	a2 14		ldx #$14			ldx 	#ERRID_PROC
.89b2	20 56 a7	jsr $a756			jsr 	StackCheckFrame
.89b5	20 7f a7	jsr $a77f			jsr 	STKLoadCodePosition 		; restore code position
.89b8	20 48 a7	jsr $a748			jsr 	StackClose
.89bb	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/read.asm

.89bc					Command_Read:
.89bc	a2 00		ldx #$00			ldx 	#0 							; evaluate the term which is the var/array element to assign
.89be	20 7a 98	jsr $987a			jsr 	EvaluateTerm
.89c1	bd 00 04	lda $0400,x			lda 	NSStatus,x
.89c4	29 20		and #$20			and 	#NSBIsReference				; get status byte on stack, identifies int, float, string.
.89c6	f0 4a		beq $8a12			beq 	_CRSyntax 					; check reference (bit 0)
.89c8	20 5b 8a	jsr $8a5b			jsr 	SwapDataCodePtrs 			; swap code and data
.89cb	ad 9c 04	lda $049c			lda 	inDataStatement 			; if in a data statement, we don't need to search
.89ce	d0 20		bne $89f0			bne 	_CRContinueData
.89d0					_CRKeepSearching:
.89d0	a9 b2		lda #$b2			lda 	#KWD_DATA 					; scan for instruction
.89d2	aa		tax				tax
.89d3	20 33 8d	jsr $8d33			jsr 	ScanForward
.89d6	c9 b2		cmp #$b2			cmp 	#KWD_DATA 					; found data ?
.89d8	f0 16		beq $89f0			beq 	_CRHaveData 				; found it
.89da	18		clc				clc
.89db	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.89dd	65 30		adc $30				adc 	codePtr
.89df	85 30		sta $30				sta 	codePtr
.89e1	90 02		bcc $89e5			bcc 	_CREExit
.89e3	e6 31		inc $31				inc 	codePtr+1
.89e5					_CREExit:
.89e5	a0 03		ldy #$03			ldy 	#3 							; start of line.
.89e7	b2 30		lda ($30)			lda 	(codePtr)
.89e9	d0 e5		bne $89d0			bne 	_CRKeepSearching
.89eb	a9 0b		lda #$0b		lda	#11
.89ed	4c f1 8d	jmp $8df1		jmp	ErrorHandler
.89f0					_CRHaveData:
.89f0					_CRContinueData:
.89f0	a2 01		ldx #$01			ldx 	#1
.89f2	20 d4 9d	jsr $9dd4			jsr 	EvaluateValue 				; evaluate value into slot # 1
.89f5	ca		dex				dex
.89f6	20 bd 87	jsr $87bd			jsr		AssignVariable 				; do the assignment
.89f9	9c 9c 04	stz $049c			stz 	inDataStatement 			; clear in data
.89fc	b1 30		lda ($30),y			lda 	(codePtr),y
.89fe	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not, end of data statement
.8a00	d0 04		bne $8a06			bne 	_CRSwapBack
.8a02	c8		iny				iny 								; consume comma
.8a03	ee 9c 04	inc $049c			inc 	inDataStatement 			; set in data statement currently.
.8a06					_CRSwapBack:
.8a06	20 5b 8a	jsr $8a5b			jsr 	SwapDataCodePtrs			; swap them back.
.8a09	b1 30		lda ($30),y			lda 	(codePtr),y
.8a0b	c8		iny				iny
.8a0c	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8a0e	f0 ac		beq $89bc			beq 	Command_Read 				; if so go round again.
.8a10	88		dey				dey 								; unpick get.
.8a11	60		rts				rts
.8a12					_CRSyntax:
.8a12	4c 3e a0	jmp $a03e			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/rem.asm

.8a15					RemCommand:
.8a15	b1 30		lda ($30),y			lda 	(codePtr),y
.8a17	c9 ff		cmp #$ff			cmp 	#KWC_STRING
.8a19	d0 06		bne $8a21			bne 	_RMExit
.8a1b	c8		iny				iny
.8a1c	98		tya				tya
.8a1d	38		sec				sec
.8a1e	71 30		adc ($30),y			adc 	(codePtr),y
.8a20	a8		tay				tay
.8a21					_RMExit:
.8a21	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/repeat.asm

.8a22					Command_REPEAT:
.8a22	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; allocate 6 bytes on the return stack.
.8a24	20 2a a7	jsr $a72a			jsr 	StackOpen
.8a27	20 6e a7	jsr $a76e			jsr 	STKSaveCodePosition 		; save loop position
.8a2a	60		rts				rts
.8a2b					Command_UNTIL:
.8a2b	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; check REPEAT is TOS
.8a2d	a2 0f		ldx #$0f			ldx 	#ERRID_REPEAT 				; this error
.8a2f	20 56 a7	jsr $a756			jsr 	StackCheckFrame
.8a32	a2 00		ldx #$00			ldx 	#0
.8a34	20 dd 9d	jsr $9ddd			jsr 	EvaluateNumber 				; work out the number
.8a37	20 e4 9e	jsr $9ee4			jsr 	NSMIsZero 					; check if zero
.8a3a	f0 04		beq $8a40			beq 	_CULoopBack 				; if so keep looping
.8a3c	20 48 a7	jsr $a748			jsr 	StackClose		 			; return
.8a3f	60		rts				rts
.8a40					_CULoopBack:
.8a40	20 7f a7	jsr $a77f			jsr 	STKLoadCodePosition 		; loop back
.8a43	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/restore.asm

.8a44					Command_Restore:
.8a44	20 5b 8a	jsr $8a5b			jsr 	SwapDataCodePtrs 			; swap code and data
.8a47	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8a49	85 30		sta $30				sta 	codePtr
.8a4b	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8a4d	85 31		sta $31				sta 	codePtr+1
.8a4f	20 5b 8a	jsr $8a5b			jsr 	SwapDataCodePtrs 			; put them back
.8a52	a9 03		lda #$03			lda 	#3 							; start at offset 3, e.g. first instruction of first line.
.8a54	8d 9b 04	sta $049b			sta 	dataPointer+4
.8a57	9c 9c 04	stz $049c			stz 	inDataStatement 			; not in data statement
.8a5a	60		rts				rts
.8a5b					SwapDataCodePtrs:
.8a5b	da		phx				phx
.8a5c	a2 03		ldx #$03			ldx 	#3 							; swap 32 bit code pointer over
.8a5e					_SDCPLoop:
.8a5e	b5 30		lda $30,x			lda 	safePtr,x
.8a60	48		pha				pha
.8a61	bd 97 04	lda $0497,x			lda 	dataPointer,x
.8a64	95 30		sta $30,x			sta 	safePtr,x
.8a66	68		pla				pla
.8a67	9d 97 04	sta $0497,x			sta 	dataPointer,x
.8a6a	ca		dex				dex
.8a6b	10 f1		bpl $8a5e			bpl 	_SDCPLoop
.8a6d	ad 9b 04	lda $049b			lda 	dataPointer+4 				; swap Y position over.
.8a70	8c 9b 04	sty $049b			sty 	dataPointer+4
.8a73	a8		tay				tay
.8a74	fa		plx				plx
.8a75	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/run.asm

.8a76					EOLCommand:
.8a76	18		clc				clc
.8a77	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.8a79	65 30		adc $30				adc 	codePtr
.8a7b	85 30		sta $30				sta 	codePtr
.8a7d	90 02		bcc $8a81			bcc 	_CREExit
.8a7f	e6 31		inc $31				inc 	codePtr+1
.8a81					_CREExit:
.8a81	80 0b		bra $8a8e			bra 	RunNewLine
.8a83					CommandRUN:
.8a83	20 ed 83	jsr $83ed			jsr 	ClearCommand 				; clear variable/stacks/etc.
.8a86	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8a88	85 30		sta $30				sta 	codePtr
.8a8a	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8a8c	85 31		sta $31				sta 	codePtr+1
.8a8e					RUNNewLine:
.8a8e	b2 30		lda ($30)			lda 	(codePtr)
.8a90	f0 72		beq $8b04			beq 	CRNoProgram         		; no then END.
.8a92	a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack
.8a94	9a		txs				txs
.8a95					RUNCodePointerLine:
.8a95	a0 02		ldy #$02			ldy 	#2 							; start of program
.8a97					_CRIncMainLoop:
.8a97	0e 93 04	asl $0493			asl 	breakCheck 					; clears 1 time in 8
.8a9a	d0 19		bne $8ab5			bne 	_CRNoBreakCheck
.8a9c	20 20 ab	jsr $ab20			jsr 	EXTBreakCheck 				; break check
.8a9f	f0 5e		beq $8aff			beq 	_CRBreak
.8aa1	64 01		stz $01				stz 	1 							; access I/O Page 0
.8aa3	38		sec				sec 								; calculate timer - LastTick
.8aa4	ad 59 d6	lda $d659			lda 	$D659
.8aa7	aa		tax				tax 								; saving timer in X
.8aa8	ed 2e 06	sbc $062e			sbc 	LastTick
.8aab	c9 03		cmp #$03			cmp 	#3
.8aad	90 06		bcc $8ab5			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.8aaf	8e 2e 06	stx $062e			stx 	LastTick 					; update last timer
.8ab2	20 85 ba	jsr $ba85			jsr 	TickHandler 				; go do the code.
.8ab5					_NoFireTick:
.8ab5					_CRNoBreakCheck:
.8ab5	c8		iny				iny
.8ab6					_CRMainLoop:
.8ab6	9c 90 04	stz $0490			stz 	stringInitialised 			; clear the temporary string initialised flag.
.8ab9	b1 30		lda ($30),y			lda 	(codePtr),y
.8abb	10 10		bpl $8acd			bpl 	_CRNotKeyword
.8abd	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1 			; if after unary, legitimate command
.8abf	b0 04		bcs $8ac5			bcs 	_CRIsKeyword
.8ac1	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if unary, syntax error.
.8ac3	b0 34		bcs $8af9			bcs		_CRSyntaxError
.8ac5					_CRIsKeyword:
.8ac5	c8		iny				iny 								; consume command
.8ac6	0a		asl a				asl 	a 							; double losing the MSB which is '1' as tokens are $80-$FF
.8ac7	aa		tax				tax 								; put in X for vector jump
.8ac8	20 fc 8a	jsr $8afc			jsr 	_CRCallVector0 				; call the vector - effectively jsr (vectortable,X)
.8acb	80 e9		bra $8ab6			bra 	_CRMainLoop 				; and loop round
.8acd					_CRNotKeyword:
.8acd	c9 3a		cmp #$3a			cmp 	#KWD_COLON 					; if a :, consume it and go round.
.8acf	f0 c6		beq $8a97			beq 	_CRIncMainLoop
.8ad1	c9 40		cmp #$40			cmp 	#$40 						; variable/call reference
.8ad3	90 05		bcc $8ada			bcc 	_CRNotVariable
.8ad5					_CRGoLet:
.8ad5	20 81 87	jsr $8781			jsr 	LetCommand
.8ad8	80 dc		bra $8ab6			bra 	_CRMainLoop
.8ada					_CRNotVariable:
.8ada	c9 10		cmp #$10			cmp 	#KWD_AT 					; handle @
.8adc	f0 f7		beq $8ad5			beq 	_CRGoLet
.8ade	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; handle ? !
.8ae0	f0 f3		beq $8ad5			beq 	_CRGoLet
.8ae2	c9 21		cmp #$21			cmp 	#KWD_PLING
.8ae4	f0 ef		beq $8ad5			beq 	_CRGoLet
.8ae6	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; handle ' (comment)
.8ae8	f0 09		beq $8af3			beq 	_CRGoRem
.8aea	c9 2e		cmp #$2e			cmp 	#KWD_PERIOD 				; handle . (assembler label)
.8aec	d0 0b		bne $8af9			bne 	_CRSyntaxError
.8aee	20 12 82	jsr $8212			jsr 	LabelHere
.8af1	80 c3		bra $8ab6			bra 	_CRMainLoop
.8af3					_CRGoRem:
.8af3	c8		iny				iny
.8af4	20 15 8a	jsr $8a15			jsr 	RemCommand
.8af7	80 bd		bra $8ab6			bra 	_CRMainLoop
.8af9					_CRSyntaxError:
.8af9	4c 3e a0	jmp $a03e			jmp 	SyntaxError
.8afc					_CRCallVector0:
.8afc	7c 9a 8b	jmp ($8b9a,x)			jmp 	(VectorSet0,x)
.8aff					_CRBreak:
.8aff	a9 01		lda #$01		lda	#1
.8b01	4c f1 8d	jmp $8df1		jmp	ErrorHandler
.8b04					CRNoProgram:
.8b04	4c 12 85	jmp $8512			jmp 	EndCommand
.8b07					Shift1Command:
.8b07	b1 30		lda ($30),y			lda 	(codePtr),y
.8b09	c8		iny				iny
.8b0a	0a		asl a				asl 	a
.8b0b	aa		tax				tax
.8b0c	7c 38 8c	jmp ($8c38,x)			jmp 	(VectorSet1,x)
.8b0f					Shift2Command:
.8b0f	b1 30		lda ($30),y			lda 	(codePtr),y
.8b11	c8		iny				iny
.8b12	0a		asl a				asl 	a
.8b13	aa		tax				tax
.8b14	7c 54 8c	jmp ($8c54,x)			jmp 	(VectorSet2,x)
.8b17					Unused1:
.8b17					Unused2:
.8b17					Unused3:
.8b17					Unused4:
.8b17	4c 3e a0	jmp $a03e			jmp 	SyntaxError
>8b1a							.align 2

;******  Processing file: ./common/commands/../generated/vectors.dat

.8b1a					VectorSetPunc:
>8b1a	de 90					.word	ShiftLeft                        ; $00 <<
>8b1c	95 8e					.word	BinaryCompareLessEqual           ; $01 <=
>8b1e	8b 8e					.word	BinaryCompareNotEqual            ; $02 <>
>8b20	3e a0					.word	SyntaxError                      ; $03 !!3
>8b22	3e a0					.word	SyntaxError                      ; $04 ><
>8b24	9f 8e					.word	BinaryCompareGreaterEqual        ; $05 >=
>8b26	e1 90					.word	ShiftRight                       ; $06 >>
>8b28	3e a0					.word	SyntaxError                      ; $07 !!7
>8b2a	3e a0					.word	SyntaxError                      ; $08 !!8
>8b2c	3e a0					.word	SyntaxError                      ; $09 !!9
>8b2e	3e a0					.word	SyntaxError                      ; $0a !!10
>8b30	3e a0					.word	SyntaxError                      ; $0b !!11
>8b32	3e a0					.word	SyntaxError                      ; $0c !!12
>8b34	3e a0					.word	SyntaxError                      ; $0d !!13
>8b36	3e a0					.word	SyntaxError                      ; $0e !!14
>8b38	3e a0					.word	SyntaxError                      ; $0f !!15
>8b3a	3e a0					.word	SyntaxError                      ; $10 @
>8b3c	3e a0					.word	SyntaxError                      ; $11 !!17
>8b3e	3e a0					.word	SyntaxError                      ; $12 !!18
>8b40	3e a0					.word	SyntaxError                      ; $13 [
>8b42	62 8f					.word	IntegerDivide                    ; $14 \
>8b44	3e a0					.word	SyntaxError                      ; $15 ]
>8b46	6f 92					.word	EorInteger                       ; $16 ^
>8b48	3e a0					.word	SyntaxError                      ; $17 _
>8b4a	3e a0					.word	SyntaxError                      ; $18 `
>8b4c	3e a0					.word	SyntaxError                      ; $19 !!25
>8b4e	3e a0					.word	SyntaxError                      ; $1a !!26
>8b50	3e a0					.word	SyntaxError                      ; $1b {
>8b52	29 92					.word	OraInteger                       ; $1c |
>8b54	3e a0					.word	SyntaxError                      ; $1d }
>8b56	3e a0					.word	SyntaxError                      ; $1e ~
>8b58	3e a0					.word	SyntaxError                      ; $1f [7m<7F>[m
>8b5a	3e a0					.word	SyntaxError                      ; $20
>8b5c	b5 92					.word	WordIndirect                     ; $21 !
>8b5e	3e a0					.word	SyntaxError                      ; $22 "
>8b60	3e a0					.word	SyntaxError                      ; $23 #
>8b62	3e a0					.word	SyntaxError                      ; $24 $
>8b64	af 8f					.word	IntegerModulus                   ; $25 %
>8b66	e3 91					.word	AndInteger                       ; $26 &
>8b68	3e a0					.word	SyntaxError                      ; $27 '
>8b6a	3e a0					.word	SyntaxError                      ; $28 (
>8b6c	3e a0					.word	SyntaxError                      ; $29 )
>8b6e	24 90					.word	MulInteger                       ; $2a *
>8b70	75 91					.word	AddInteger                       ; $2b +
>8b72	3e a0					.word	SyntaxError                      ; $2c ,
>8b74	b8 91					.word	SubInteger                       ; $2d -
>8b76	3e a0					.word	SyntaxError                      ; $2e .
>8b78	a0 94					.word	FDivideCommand                   ; $2f /
>8b7a	3e a0					.word	SyntaxError                      ; $30 0
>8b7c	3e a0					.word	SyntaxError                      ; $31 1
>8b7e	3e a0					.word	SyntaxError                      ; $32 2
>8b80	3e a0					.word	SyntaxError                      ; $33 3
>8b82	3e a0					.word	SyntaxError                      ; $34 4
>8b84	3e a0					.word	SyntaxError                      ; $35 5
>8b86	3e a0					.word	SyntaxError                      ; $36 6
>8b88	3e a0					.word	SyntaxError                      ; $37 7
>8b8a	3e a0					.word	SyntaxError                      ; $38 8
>8b8c	3e a0					.word	SyntaxError                      ; $39 9
>8b8e	3e a0					.word	SyntaxError                      ; $3a :
>8b90	3e a0					.word	SyntaxError                      ; $3b ;
>8b92	77 8e					.word	BinaryCompareLess                ; $3c <
>8b94	6d 8e					.word	BinaryCompareEqual               ; $3d =
>8b96	81 8e					.word	BinaryCompareGreater             ; $3e >
>8b98	dc 92					.word	ByteIndirect                     ; $3f ?
.8b9a					VectorSet0:
>8b9a	76 8a					.word	EOLCommand                       ; $80 !0:EOF
>8b9c	07 8b					.word	Shift1Command                    ; $81 !1:SH1
>8b9e	0f 8b					.word	Shift2Command                    ; $82 !2:SH2
>8ba0	10 9a					.word	AbsUnary                         ; $83 ABS(
>8ba2	20 9a					.word	AllocUnary                       ; $84 ALLOC(
>8ba4	90 9a					.word	AscUnary                         ; $85 ASC(
>8ba6	5b 9c					.word	ChrUnary                         ; $86 CHR$(
>8ba8	af a4					.word	UnaryEvent                       ; $87 EVENT(
>8baa	69 8e					.word	UnaryFalse                       ; $88 FALSE
>8bac	9d 9a					.word	FracUnary                        ; $89 FRAC(
>8bae	45 a4					.word	UnaryHit                         ; $8a HIT(
>8bb0	b3 9a					.word	IntUnary                         ; $8b INT(
>8bb2	1a 9c					.word	IsValUnary                       ; $8c ISVAL(
>8bb4	3f a5					.word	UnaryJoyB                        ; $8d JOYB(
>8bb6	18 a5					.word	UnaryJoyX                        ; $8e JOYX(
>8bb8	1b a5					.word	UnaryJoyY                        ; $8f JOYY(
>8bba	35 9d					.word	Unary_Left                       ; $90 LEFT$(
>8bbc	c5 9a					.word	LenUnary                         ; $91 LEN(
>8bbe	e3 9a					.word	Unary_Max                        ; $92 MAX(
>8bc0	5f 9d					.word	Unary_Mid                        ; $93 MID$(
>8bc2	df 9a					.word	Unary_Min                        ; $94 MIN(
>8bc4	3a 9b					.word	Unary_Not                        ; $95 NOT(
>8bc6	81 a6					.word	UnaryPlaying                     ; $96 PLAYING(
>8bc8	50 9b					.word	Unary_Random                     ; $97 RANDOM(
>8bca	45 9d					.word	Unary_Right                      ; $98 RIGHT$(
>8bcc	6f 9b					.word	Unary_Rnd                        ; $99 RND(
>8bce	f0 9b					.word	SgnUnary                         ; $9a SGN(
>8bd0	6d 9c					.word	SpcUnary                         ; $9b SPC(
>8bd2	88 9c					.word	Unary_Str                        ; $9c STR$(
>8bd4	53 a5					.word	UnaryTimer                       ; $9d TIMER(
>8bd6	5d 8e					.word	UnaryTrue                        ; $9e TRUE
>8bd8	10 9c					.word	ValUnary                         ; $9f VAL(
>8bda	15 85					.word	ForCommand                       ; $a0 FOR
>8bdc	62 86					.word	IfCommand                        ; $a1 IF
>8bde	17 8b					.word	Unused1                          ; $a2 PROC
>8be0	22 8a					.word	Command_REPEAT                   ; $a3 REPEAT
>8be2	a9 8d					.word	Command_WHILE                    ; $a4 WHILE
>8be4	8b 86					.word	EndIf                            ; $a5 ENDIF
>8be6	ae 89					.word	Command_ENDPROC                  ; $a6 ENDPROC
>8be8	cf 85					.word	NextCommand                      ; $a7 NEXT
>8bea	17 8b					.word	Unused4                          ; $a8 THEN
>8bec	2b 8a					.word	Command_UNTIL                    ; $a9 UNTIL
>8bee	ca 8d					.word	Command_WEND                     ; $aa WEND
>8bf0	3e a0					.word	SyntaxError                      ; $ab BY
>8bf2	b3 83					.word	CallCommand                      ; $ac CALL
>8bf4	e7 a1					.word	CircleCommand                    ; $ad CIRCLE
>8bf6	ed 83					.word	ClearCommand                     ; $ae CLEAR
>8bf8	45 84					.word	ClearScreen                      ; $af CLS
>8bfa	3e a0					.word	SyntaxError                      ; $b0 COLOR
>8bfc	3e a0					.word	SyntaxError                      ; $b1 COLOUR
>8bfe	4d 84					.word	Command_Data                     ; $b2 DATA
>8c00	55 84					.word	DimCommand                       ; $b3 DIM
>8c02	17 8b					.word	Unused3                          ; $b4 DOWNTO
>8c04	84 86					.word	ElseCode                         ; $b5 ELSE
>8c06	3e a0					.word	SyntaxError                      ; $b6 FROM
>8c08	13 a4					.word	GfxCommand                       ; $b7 GFX
>8c0a	28 86					.word	Command_GOSUB                    ; $b8 GOSUB
>8c0c	46 86					.word	GotoCommand                      ; $b9 GOTO
>8c0e	3e a0					.word	SyntaxError                      ; $ba HERE
>8c10	11 a2					.word	ImageCommand                     ; $bb IMAGE
>8c12	8c 86					.word	Command_Input                    ; $bc INPUT
>8c14	81 87					.word	LetCommand                       ; $bd LET
>8c16	66 a2					.word	LineCommand                      ; $be LINE
>8c18	77 88					.word	Command_LOCAL                    ; $bf LOCAL
>8c1a	3e a0					.word	SyntaxError                      ; $c0 OFF
>8c1c	3e a0					.word	SyntaxError                      ; $c1 ON
>8c1e	3e a0					.word	SyntaxError                      ; $c2 OUTLINE
>8c20	6b a4					.word	PaletteCommand                   ; $c3 PALETTE
>8c22	5f a2					.word	PlotCommand                      ; $c4 PLOT
>8c24	93 86					.word	Command_Print                    ; $c5 PRINT
>8c26	bc 89					.word	Command_Read                     ; $c6 READ
>8c28	e3 a1					.word	RectangleCommand                 ; $c7 RECT
>8c2a	15 8a					.word	RemCommand                       ; $c8 REM
>8c2c	38 86					.word	Command_RETURN                   ; $c9 RETURN
>8c2e	3e a0					.word	SyntaxError                      ; $ca SOLID
>8c30	9d a6					.word	SoundCommand                     ; $cb SOUND
>8c32	f2 a1					.word	SpriteCommand                    ; $cc SPRITE
>8c34	2e a2					.word	TextCommand                      ; $cd TEXT
>8c36	17 8b					.word	Unused2                          ; $ce TO
.8c38					VectorSet1:
>8c38	3e a0					.word	SyntaxError                      ; $80 !0:EOF
>8c3a	3e a0					.word	SyntaxError                      ; $81 !1:SH1
>8c3c	3e a0					.word	SyntaxError                      ; $82 !2:SH2
>8c3e	84 83					.word	AssembleCommand                  ; $83 ASSEMBLE
>8c40	a3 83					.word	AssertCommand                    ; $84 ASSERT
>8c42	b3 a3					.word	BitmapCtrl                       ; $85 BITMAP
>8c44	12 85					.word	EndCommand                       ; $86 END
>8c46	d6 87					.word	Command_List                     ; $87 LIST
>8c48	3e 89					.word	NewCommand                       ; $88 NEW
>8c4a	44 8a					.word	Command_Restore                  ; $89 RESTORE
>8c4c	83 8a					.word	CommandRUN                       ; $8a RUN
>8c4e	f8 a3					.word	SpritesCtrl                      ; $8b SPRITES
>8c50	dc 8c					.word	StopCommand                      ; $8c STOP
>8c52	3e a0					.word	SyntaxError                      ; $8d WHO
.8c54					VectorSet2:
>8c54	3e a0					.word	SyntaxError                      ; $80 !0:EOF
>8c56	3e a0					.word	SyntaxError                      ; $81 !1:SH1
>8c58	3e a0					.word	SyntaxError                      ; $82 !2:SH2
>8c5a	fd 9e					.word	Assemble_adc                     ; $83 ADC
>8c5c	f5 9e					.word	Assemble_and                     ; $84 AND
>8c5e	11 9f					.word	Assemble_asl                     ; $85 ASL
>8c60	7b 9f					.word	Assemble_bcc                     ; $86 BCC
>8c62	7f 9f					.word	Assemble_bcs                     ; $87 BCS
>8c64	87 9f					.word	Assemble_beq                     ; $88 BEQ
>8c66	3e 9f					.word	Assemble_bit                     ; $89 BIT
>8c68	6f 9f					.word	Assemble_bmi                     ; $8a BMI
>8c6a	83 9f					.word	Assemble_bne                     ; $8b BNE
>8c6c	6b 9f					.word	Assemble_bpl                     ; $8c BPL
>8c6e	8b 9f					.word	Assemble_bra                     ; $8d BRA
>8c70	8f 9f					.word	Assemble_brk                     ; $8e BRK
>8c72	73 9f					.word	Assemble_bvc                     ; $8f BVC
>8c74	77 9f					.word	Assemble_bvs                     ; $90 BVS
>8c76	97 9f					.word	Assemble_clc                     ; $91 CLC
>8c78	eb 9f					.word	Assemble_cld                     ; $92 CLD
>8c7a	ab 9f					.word	Assemble_cli                     ; $93 CLI
>8c7c	db 9f					.word	Assemble_clv                     ; $94 CLV
>8c7e	09 9f					.word	Assemble_cmp                     ; $95 CMP
>8c80	52 9f					.word	Assemble_cpx                     ; $96 CPX
>8c82	4d 9f					.word	Assemble_cpy                     ; $97 CPY
>8c84	2f 9f					.word	Assemble_dec                     ; $98 DEC
>8c86	e7 9f					.word	Assemble_dex                     ; $99 DEX
>8c88	c3 9f					.word	Assemble_dey                     ; $9a DEY
>8c8a	f9 9e					.word	Assemble_eor                     ; $9b EOR
>8c8c	34 9f					.word	Assemble_inc                     ; $9c INC
>8c8e	f7 9f					.word	Assemble_inx                     ; $9d INX
>8c90	e3 9f					.word	Assemble_iny                     ; $9e INY
>8c92	66 9f					.word	Assemble_jmp                     ; $9f JMP
>8c94	61 9f					.word	Assemble_jsr                     ; $a0 JSR
>8c96	05 9f					.word	Assemble_lda                     ; $a1 LDA
>8c98	2a 9f					.word	Assemble_ldx                     ; $a2 LDX
>8c9a	48 9f					.word	Assemble_ldy                     ; $a3 LDY
>8c9c	1b 9f					.word	Assemble_lsr                     ; $a4 LSR
>8c9e	fb 9f					.word	Assemble_nop                     ; $a5 NOP
>8ca0	f1 9e					.word	Assemble_ora                     ; $a6 ORA
>8ca2	a7 9f					.word	Assemble_pha                     ; $a7 PHA
>8ca4	93 9f					.word	Assemble_php                     ; $a8 PHP
>8ca6	ef 9f					.word	Assemble_phx                     ; $a9 PHX
>8ca8	af 9f					.word	Assemble_phy                     ; $aa PHY
>8caa	b7 9f					.word	Assemble_pla                     ; $ab PLA
>8cac	9b 9f					.word	Assemble_plp                     ; $ac PLP
>8cae	03 a0					.word	Assemble_plx                     ; $ad PLX
>8cb0	bf 9f					.word	Assemble_ply                     ; $ae PLY
>8cb2	16 9f					.word	Assemble_rol                     ; $af ROL
>8cb4	20 9f					.word	Assemble_ror                     ; $b0 ROR
>8cb6	a3 9f					.word	Assemble_rti                     ; $b1 RTI
>8cb8	b3 9f					.word	Assemble_rts                     ; $b2 RTS
>8cba	0d 9f					.word	Assemble_sbc                     ; $b3 SBC
>8cbc	9f 9f					.word	Assemble_sec                     ; $b4 SEC
>8cbe	ff 9f					.word	Assemble_sed                     ; $b5 SED
>8cc0	bb 9f					.word	Assemble_sei                     ; $b6 SEI
>8cc2	01 9f					.word	Assemble_sta                     ; $b7 STA
>8cc4	f3 9f					.word	Assemble_stp                     ; $b8 STP
>8cc6	25 9f					.word	Assemble_stx                     ; $b9 STX
>8cc8	43 9f					.word	Assemble_sty                     ; $ba STY
>8cca	39 9f					.word	Assemble_stz                     ; $bb STZ
>8ccc	d7 9f					.word	Assemble_tax                     ; $bc TAX
>8cce	d3 9f					.word	Assemble_tay                     ; $bd TAY
>8cd0	5c 9f					.word	Assemble_trb                     ; $be TRB
>8cd2	57 9f					.word	Assemble_tsb                     ; $bf TSB
>8cd4	df 9f					.word	Assemble_tsx                     ; $c0 TSX
>8cd6	c7 9f					.word	Assemble_txa                     ; $c1 TXA
>8cd8	cf 9f					.word	Assemble_txs                     ; $c2 TXS
>8cda	cb 9f					.word	Assemble_tya                     ; $c3 TYA

;******  Return to file: ./common/commands/run.asm


;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/stop.asm

.8cdc					StopCommand:
.8cdc	a9 08		lda #$08		lda	#8
.8cde	4c f1 8d	jmp $8df1		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/procscan.asm

.8ce1					ProcedureScan:
.8ce1	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8ce3	85 30		sta $30				sta 	codePtr
.8ce5	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8ce7	85 31		sta $31				sta 	codePtr+1
.8ce9					_PSLoop:
.8ce9	b2 30		lda ($30)			lda 	(codePtr)
.8ceb	f0 42		beq $8d2f			beq 	_PSExit
.8ced	a0 03		ldy #$03			ldy 	#3 							; is it PROC ?
.8cef	b1 30		lda ($30),y			lda 	(codePtr),y
.8cf1	c9 a2		cmp #$a2			cmp 	#KWD_PROC
.8cf3	d0 2d		bne $8d22			bne 	_PSNext
.8cf5	c8		iny				iny 								; get the address of the record to zTemp0 and
.8cf6	b1 30		lda ($30),y			lda 	(codePtr),y
.8cf8	29 c0		and #$c0			and 	#$C0
.8cfa	c9 40		cmp #$40			cmp 	#$40
.8cfc	d0 32		bne $8d30			bne 	_PSSyntax
.8cfe	b1 30		lda ($30),y			lda 	(codePtr),y
.8d00	18		clc				clc
.8d01	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8d03	85 37		sta $37				sta 	zTemp0+1
.8d05	c8		iny				iny 								; LSB
.8d06	b1 30		lda ($30),y			lda 	(codePtr),y
.8d08	85 36		sta $36				sta 	zTemp0
.8d0a	c8		iny				iny 								; character after variable call.
.8d0b	98		tya				tya 								; save Y offset at +7
.8d0c	a0 07		ldy #$07			ldy 	#7
.8d0e	91 36		sta ($36),y			sta 	(zTemp0),y
.8d10	a9 18		lda #$18			lda 	#NSTProcedure 				; mark it as procedure
.8d12	a0 02		ldy #$02			ldy 	#2
.8d14	91 36		sta ($36),y			sta 	(zTemp0),y
.8d16	a2 00		ldx #$00			ldx 	#0 							; copy code-Ptr in
.8d18					_PSCopy:
.8d18	b5 30		lda $30,x			lda 	safePtr,x
.8d1a	c8		iny				iny
.8d1b	91 36		sta ($36),y			sta 	(zTemp0),y
.8d1d	e8		inx				inx
.8d1e	e0 04		cpx #$04			cpx 	#4
.8d20	d0 f6		bne $8d18			bne 	_PSCopy
.8d22					_PSNext:
.8d22	18		clc				clc
.8d23	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.8d25	65 30		adc $30				adc 	codePtr
.8d27	85 30		sta $30				sta 	codePtr
.8d29	90 02		bcc $8d2d			bcc 	_CREExit
.8d2b	e6 31		inc $31				inc 	codePtr+1
.8d2d					_CREExit:
.8d2d	80 ba		bra $8ce9			bra 	_PSLoop
.8d2f					_PSExit:
.8d2f	60		rts				rts
.8d30					_PSSyntax:
.8d30	4c 3e a0	jmp $a03e			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/scanforward.asm

.8d33					ScanForward:
.8d33	64 38		stz $38				stz 	zTemp1 						; this is the structure count - goes up with WHILE/FOR
.8d35	86 37		stx $37				stx 	zTemp0+1
.8d37	85 36		sta $36				sta 	zTemp0 						; save XA as the two possible matches.
.8d39					_ScanLoop:
.8d39	b1 30		lda ($30),y			lda 	(codePtr),y
.8d3b	c8		iny				iny
.8d3c	a6 38		ldx $38				ldx 	zTemp1 						; if the count is > 0 cannot match as in substructure
.8d3e	d0 0e		bne $8d4e			bne 	_ScanGoNext
.8d40	c5 36		cmp $36				cmp 	zTemp0 						; see if either matches
.8d42	f0 04		beq $8d48			beq 	_ScanMatch
.8d44	c5 37		cmp $37				cmp 	zTemp0+1
.8d46	d0 06		bne $8d4e			bne 	_ScanGoNext
.8d48					_ScanMatch:
.8d48	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if asked for EOL, backtrack.
.8d4a	d0 01		bne $8d4d			bne 	_ScanNotEndEOL
.8d4c	88		dey				dey
.8d4d					_ScanNotEndEOL:
.8d4d	60		rts				rts
.8d4e					_ScanGoNext:
.8d4e	20 53 8d	jsr $8d53			jsr  	ScanForwardOne
.8d51	80 e6		bra $8d39			bra 	_ScanLoop
.8d53					ScanForwardOne:
.8d53	c9 40		cmp #$40			cmp 	#$40 						; if 00-3F, punctuation characters, loop back
.8d55	90 3e		bcc $8d95			bcc 	_SFWExit
.8d57	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if 40-82, skip one extra.
.8d59	90 18		bcc $8d73			bcc 	_ScanSkipOne
.8d5b	c9 fc		cmp #$fc			cmp 	#$FC 						; FC-FF are data skips
.8d5d	b0 2f		bcs $8d8e			bcs 	_ScanSkipData
.8d5f	c9 a0		cmp #$a0			cmp 	#KWC_FIRST_STRUCTURE 		; structure keyword ?
.8d61	90 32		bcc $8d95			bcc 	_SFWExit 					; if not, ordinary keywords.
.8d63	c9 ab		cmp #$ab			cmp 	#KWC_LAST_STRUCTURE+1
.8d65	b0 2e		bcs $8d95			bcs 	_SFWExit
.8d67	c6 38		dec $38				dec 	zTemp1 						; decrement the sructure count
.8d69	c9 a5		cmp #$a5			cmp 	#KWC_FIRST_STRUCTURE_DEC 	; back if it is a dec structure (e.g. WEND/NEXT)
.8d6b	b0 28		bcs $8d95			bcs 	_SFWExit
.8d6d	e6 38		inc $38				inc 	zTemp1 						; so it's an increment structure
.8d6f	e6 38		inc $38				inc 	zTemp1 						; twice to undo the dec
.8d71	80 22		bra $8d95			bra 	_SFWExit
.8d73					_ScanSkipOne:
.8d73	c8		iny				iny 								; consume the extra one.
.8d74	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if not EOL loop back
.8d76	d0 1d		bne $8d95			bne 	_SFWExit
.8d78	18		clc				clc
.8d79	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.8d7b	65 30		adc $30				adc 	codePtr
.8d7d	85 30		sta $30				sta 	codePtr
.8d7f	90 02		bcc $8d83			bcc 	_CREExit
.8d81	e6 31		inc $31				inc 	codePtr+1
.8d83					_CREExit:
.8d83	a0 03		ldy #$03			ldy 	#3 							; scan start position.
.8d85	b2 30		lda ($30)			lda 	(codePtr)
.8d87	d0 0c		bne $8d95			bne 	_SFWExit 					; if not zero, more to scan
.8d89	a9 13		lda #$13		lda	#19
.8d8b	4c f1 8d	jmp $8df1		jmp	ErrorHandler
.8d8e					_ScanSkipData:
.8d8e	88		dey				dey 								; point at data token
.8d8f	c8		iny				iny
.8d90	98		tya				tya
.8d91	38		sec				sec
.8d92	71 30		adc ($30),y			adc 	(codePtr),y
.8d94	a8		tay				tay
.8d95					_SFWExit:
.8d95	60		rts				rts
.8d96					ScanGetCurrentLineStep:
.8d96	64 38		stz $38				stz 	zTemp1
.8d98	a0 03		ldy #$03			ldy 	#3
.8d9a					_SGCLSLoop:
.8d9a	b1 30		lda ($30),y			lda 	(codePtr),y
.8d9c	c8		iny				iny
.8d9d	c9 80		cmp #$80			cmp 	#KWC_EOL	 				; if EOL exit
.8d9f	f0 05		beq $8da6			beq 	_SGCLSExit
.8da1	20 53 8d	jsr $8d53			jsr 	ScanForwardOne
.8da4	80 f4		bra $8d9a			bra 	_SGCLSLoop
.8da6					_SGCLSExit:
.8da6	a5 38		lda $38				lda 	zTemp1
.8da8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/while.asm

.8da9					Command_WHILE:
.8da9	5a		phy				phy 								; save position of the test
.8daa	a2 00		ldx #$00			ldx 	#0
.8dac	20 dd 9d	jsr $9ddd			jsr 	EvaluateNumber 				; work out the number
.8daf	20 e4 9e	jsr $9ee4			jsr 	NSMIsZero 					; check if zero
.8db2	f0 0e		beq $8dc2			beq 	_WHExitLoop 				; if so exit the loop
.8db4	98		tya				tya 								; position *after* test.
.8db5	7a		ply				ply 								; restore position before test, at WHILE
.8db6	88		dey				dey
.8db7	48		pha				pha 								; push after test on the stack
.8db8	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; allocate 6 bytes on the return stack.
.8dba	20 2a a7	jsr $a72a			jsr 	StackOpen
.8dbd	20 6e a7	jsr $a76e			jsr 	STKSaveCodePosition 		; save loop position - where the test value is.
.8dc0	7a		ply				ply 								; restore the position *after* the test
.8dc1	60		rts				rts
.8dc2					_WHExitLoop:
.8dc2	68		pla				pla 								; throw post loop position
.8dc3	a9 aa		lda #$aa			lda 	#KWD_WEND 					; scan forward past WEND
.8dc5	aa		tax				tax
.8dc6	20 33 8d	jsr $8d33			jsr 	ScanForward
.8dc9	60		rts				rts
.8dca					Command_WEND:
.8dca	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; check WHILE is TOS
.8dcc	a2 10		ldx #$10			ldx 	#ERRID_WHILE 				; this error
.8dce	20 56 a7	jsr $a756			jsr 	StackCheckFrame
.8dd1	20 7f a7	jsr $a77f			jsr 	STKLoadCodePosition 		; loop back
.8dd4	20 48 a7	jsr $a748			jsr 	StackClose		 			; erase the frame
.8dd7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/charcheck.asm

.8dd8					CheckRightBracket:
.8dd8	b1 30		lda ($30),y			lda 	(codePtr),y
.8dda	c8		iny				iny
.8ddb	c9 29		cmp #$29			cmp 	#KWD_RPAREN 						; exit if matches
.8ddd	d0 0f		bne $8dee			bne 	CNAFail
.8ddf	60		rts				rts
.8de0					CheckComma:
.8de0	b1 30		lda ($30),y			lda 	(codePtr),y
.8de2	c8		iny				iny
.8de3	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 						; exit if matches
.8de5	d0 07		bne $8dee			bne 	CNAFail
.8de7	60		rts				rts
.8de8					CheckNextA:
.8de8	d1 30		cmp ($30),y			cmp 	(codePtr),y
.8dea	d0 02		bne $8dee			bne 	CNAFail
.8dec	c8		iny				iny 								; skip character
.8ded	60		rts				rts 								; and exit
.8dee					CNAFail:
.8dee	4c 3e a0	jmp $a03e			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/errors.asm

.8df1					ErrorHandler:
.8df1	a8		tay				tay 								; find the error text
.8df2	f0 49		beq $8e3d			beq 	_EHEnd
.8df4	a2 00		ldx #$00			ldx 	#0
.8df6	a9 57		lda #$57			lda 	#((ErrorText) & $FF)
.8df8	85 36		sta $36				sta 	0+zTemp0
.8dfa	a9 a0		lda #$a0			lda 	#((ErrorText) >> 8)
.8dfc	85 37		sta $37				sta 	1+zTemp0
.8dfe					_EHFind:
.8dfe	88		dey				dey 								; found the error text ?
.8dff	f0 0e		beq $8e0f			beq 	_EHFound
.8e01					_EHFindZero:
.8e01	b2 36		lda ($36)			lda 	(zTemp0) 					; find the next error
.8e03	e6 36		inc $36				inc 	zTemp0
.8e05	d0 02		bne $8e09			bne 	_EHFNoCarry
.8e07	e6 37		inc $37				inc 	zTemp0+1
.8e09					_EHFNoCarry:
.8e09	c9 00		cmp #$00			cmp 	#0
.8e0b	d0 f4		bne $8e01			bne 	_EHFindZero
.8e0d	80 ef		bra $8dfe			bra 	_EHFind
.8e0f					_EHFound:
.8e0f	a5 36		lda $36				lda 	zTemp0 						; print message
.8e11	a6 37		ldx $37				ldx 	zTemp0+1
.8e13	20 4a 8e	jsr $8e4a			jsr 	PrintStringXA
.8e16	a0 01		ldy #$01			ldy 	#1 							; if line number zero don't print i
.8e18	b1 30		lda ($30),y			lda 	(codePtr),y
.8e1a	d0 05		bne $8e21			bne 	_EHAtMsg
.8e1c	c8		iny				iny
.8e1d	b1 30		lda ($30),y			lda 	(codePtr),y
.8e1f	f0 17		beq $8e38			beq 	_EHCREnd
.8e21					_EHAtMsg:
.8e21	a2 8e		ldx #$8e			ldx 	#_AtMsg >> 8 				; print " at "
.8e23	a9 40		lda #$40			lda 	#_AtMsg & $FF
.8e25	20 4a 8e	jsr $8e4a			jsr 	PrintStringXA
.8e28	a0 01		ldy #$01			ldy 	#1 							; line number into XA
.8e2a	b1 30		lda ($30),y			lda 	(codePtr),y
.8e2c	48		pha				pha
.8e2d	c8		iny				iny
.8e2e	b1 30		lda ($30),y			lda 	(codePtr),y
.8e30	aa		tax				tax
.8e31	68		pla				pla
.8e32	20 03 93	jsr $9303			jsr 	LCLConvertInt16 				; convert XA to string
.8e35	20 4a 8e	jsr $8e4a			jsr 	PrintStringXA 				; and print it.
.8e38					_EHCREnd:
.8e38	a9 0d		lda #$0d			lda 	#13 						; new line
.8e3a	20 6a a8	jsr $a86a			jsr 	EXTPrintCharacter
.8e3d					_EHEnd:
.8e3d	4c 54 83	jmp $8354			jmp 	WarmStart
>8e40	20 61 74 20 6c 69 6e 65		_AtMsg:	.text 	" at line ",0
>8e48	20 00
.8e4a					PrintStringXA:
.8e4a	5a		phy				phy
.8e4b	86 37		stx $37				stx 	zTemp0+1
.8e4d	85 36		sta $36				sta 	zTemp0
.8e4f	a0 00		ldy #$00			ldy 	#0
.8e51					_PSXALoop:
.8e51	b1 36		lda ($36),y			lda 	(zTemp0),y
.8e53	f0 06		beq $8e5b			beq 	_PSXAExit
.8e55	20 6a a8	jsr $a86a			jsr 	EXTPrintCharacter
.8e58	c8		iny				iny
.8e59	80 f6		bra $8e51			bra 	_PSXALoop
.8e5b					_PSXAExit:
.8e5b	7a		ply				ply
.8e5c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/compare.asm

.8e5d					UnaryTrue:
.8e5d	fa		plx				plx
.8e5e					ReturnTrue:
.8e5e	a9 01		lda #$01			lda 	#1  						; set to 1
.8e60	20 b6 9e	jsr $9eb6			jsr 	NSMSetByte
.8e63	a9 80		lda #$80			lda 	#$80 						; set sign flag, so it is -1
.8e65	9d 00 04	sta $0400,x			sta 	NSStatus,x
.8e68	60		rts				rts
.8e69					UnaryFalse:
.8e69	fa		plx				plx
.8e6a					ReturnFalse:
.8e6a	4c b4 9e	jmp $9eb4			jmp 	NSMSetZero 					; set it all to zero
.8e6d					BinaryCompareEqual:
.8e6d	fa		plx				plx
.8e6e	20 a9 8e	jsr $8ea9			jsr 	CompareBaseCode
.8e71	c9 00		cmp #$00			cmp 	#0
.8e73	f0 e9		beq $8e5e			beq 	ReturnTrue
.8e75	80 f3		bra $8e6a			bra 	ReturnFalse
.8e77					BinaryCompareLess:
.8e77	fa		plx				plx
.8e78	20 a9 8e	jsr $8ea9			jsr 	CompareBaseCode
.8e7b	c9 ff		cmp #$ff			cmp 	#$FF
.8e7d	f0 df		beq $8e5e			beq 	ReturnTrue
.8e7f	80 e9		bra $8e6a			bra 	ReturnFalse
.8e81					BinaryCompareGreater:
.8e81	fa		plx				plx
.8e82	20 a9 8e	jsr $8ea9			jsr 	CompareBaseCode
.8e85	c9 01		cmp #$01			cmp 	#1
.8e87	f0 d5		beq $8e5e			beq 	ReturnTrue
.8e89	80 df		bra $8e6a			bra 	ReturnFalse
.8e8b					BinaryCompareNotEqual:
.8e8b	fa		plx				plx
.8e8c	20 a9 8e	jsr $8ea9			jsr 	CompareBaseCode
.8e8f	c9 00		cmp #$00			cmp 	#0
.8e91	d0 cb		bne $8e5e			bne 	ReturnTrue
.8e93	80 d5		bra $8e6a			bra 	ReturnFalse
.8e95					BinaryCompareLessEqual:
.8e95	fa		plx				plx
.8e96	20 a9 8e	jsr $8ea9			jsr 	CompareBaseCode
.8e99	c9 01		cmp #$01			cmp 	#1
.8e9b	d0 c1		bne $8e5e			bne 	ReturnTrue
.8e9d	80 cb		bra $8e6a			bra 	ReturnFalse
.8e9f					BinaryCompareGreaterEqual:
.8e9f	fa		plx				plx
.8ea0	20 a9 8e	jsr $8ea9			jsr 	CompareBaseCode
.8ea3	c9 ff		cmp #$ff			cmp 	#$FF
.8ea5	d0 b7		bne $8e5e			bne 	ReturnTrue
.8ea7	80 c1		bra $8e6a			bra 	ReturnFalse
.8ea9					CompareBaseCode:
.8ea9	20 b9 96	jsr $96b9			jsr 	DereferenceTopTwo 			; make both values if references.
.8eac	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if either is a string.
.8eaf	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8eb2	29 10		and #$10			and 	#NSTString
.8eb4	d0 40		bne $8ef6			bne 	_CBCString
.8eb6	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check both are integers
.8eb9	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8ebc	d0 3b		bne $8ef9			bne 	_CBCFloat
.8ebe	bd 00 04	lda $0400,x			lda 	NSStatus,x
.8ec1	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8ec4	29 08		and #$08			and 	#NSTFloat
.8ec6	d0 31		bne $8ef9			bne 	_CBCFloat
.8ec8	20 fc 8e	jsr $8efc			jsr 	CompareFixMinusZero
.8ecb	e8		inx				inx
.8ecc	20 fc 8e	jsr $8efc			jsr 	CompareFixMinusZero
.8ecf	ca		dex				dex
.8ed0	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; are the signs different ?
.8ed3	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.8ed6	10 0b		bpl $8ee3			bpl 	_CDCSameSign
.8ed8	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; if first one is -ve
.8edb	30 16		bmi $8ef3			bmi 	_CBCLess 					; return $FF
.8edd					_CBCGreater:
.8edd	a9 01		lda #$01			lda 	#1
.8edf	60		rts				rts
.8ee0					_CBCEqual:
.8ee0	a9 00		lda #$00			lda 	#0
.8ee2	60		rts				rts
.8ee3					_CDCSameSign:
.8ee3	20 4f 91	jsr $914f			jsr 	SubTopTwoStack 				; unsigned subtract
.8ee6	20 e4 9e	jsr $9ee4			jsr 	NSMIsZero 					; or the mantissa together
.8ee9	f0 f5		beq $8ee0			beq 	_CBCEqual 					; -0 == 0
.8eeb	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; sign of the result. if +ve return $01 else return $FF
.8eee	5d 01 04	eor $0401,x			eor 	NSStatus+1,x 				; however if both were -ve this is inverted
.8ef1	10 ea		bpl $8edd			bpl 	_CBCGreater
.8ef3					_CBCLess:
.8ef3	a9 ff		lda #$ff			lda 	#$FF
.8ef5	60		rts				rts
.8ef6					_CBCString:
.8ef6	4c a5 90	jmp $90a5			jmp 	CompareStrings
.8ef9					_CBCFloat:
.8ef9	4c 86 94	jmp $9486			jmp 	CompareFloat
.8efc					CompareFixMinusZero:
.8efc	20 e4 9e	jsr $9ee4			jsr 	NSMIsZero
.8eff	d0 03		bne $8f04			bne 	_CFXMZNotZero
.8f01	9e 00 04	stz $0400,x			stz 	NSStatus,x
.8f04					_CFXMZNotZero:
.8f04	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/concat.asm

.8f05					StringConcat:
.8f05	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check both strings
.8f08	3d 01 04	and $0401,x			and 	NSStatus+1,x
.8f0b	29 18		and #$18			and 	#NSBTypeMask
.8f0d	c9 10		cmp #$10			cmp 	#NSTString
.8f0f	d0 4e		bne $8f5f			bne		_SCType
.8f11	64 38		stz $38				stz 	zTemp1 						; counting total length
.8f13	e8		inx				inx
.8f14	20 32 8f	jsr $8f32			jsr 	_SCSetupZ0 					; setup for second
.8f17	20 3d 8f	jsr $8f3d			jsr 	_SCLengthZ0 				; length for second
.8f1a	ca		dex				dex
.8f1b	20 32 8f	jsr $8f32			jsr 	_SCSetupZ0 					; setup for first
.8f1e	20 3d 8f	jsr $8f3d			jsr 	_SCLengthZ0 				; length for first
.8f21	a5 38		lda $38				lda 	zTemp1 						; allocate memory
.8f23	20 1d a8	jsr $a81d			jsr 	StringTempAllocate
.8f26	20 50 8f	jsr $8f50			jsr 	_SCCopy 					; copy first out, using zTemp0 from above
.8f29	e8		inx				inx
.8f2a	20 32 8f	jsr $8f32			jsr 	_SCSetupZ0 					; copy second out
.8f2d	20 50 8f	jsr $8f50			jsr 	_SCCopy
.8f30	ca		dex				dex
.8f31	60		rts				rts
.8f32					_SCSetupZ0:
.8f32	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.8f35	85 36		sta $36				sta 	zTemp0
.8f37	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.8f3a	85 37		sta $37				sta 	zTemp0+1
.8f3c	60		rts				rts
.8f3d					_SCLengthZ0:
.8f3d	5a		phy				phy
.8f3e	a0 00		ldy #$00			ldy 	#0
.8f40					_SCLenLoop:
.8f40	b1 36		lda ($36),y			lda 	(zTemp0),y
.8f42	f0 0a		beq $8f4e			beq 	_SCLExit
.8f44	c8		iny				iny
.8f45	e6 38		inc $38				inc 	zTemp1
.8f47	10 f7		bpl $8f40			bpl		_SCLenLoop
.8f49	a9 09		lda #$09		lda	#9
.8f4b	4c f1 8d	jmp $8df1		jmp	ErrorHandler
.8f4e					_SCLExit:
.8f4e	7a		ply				ply
.8f4f	60		rts				rts
.8f50					_SCCopy:
.8f50	5a		phy				phy
.8f51	a0 00		ldy #$00			ldy 	#0
.8f53					_SCCopyLoop:
.8f53	b1 36		lda ($36),y			lda 	(zTemp0),y
.8f55	f0 06		beq $8f5d			beq 	_SCCExit
.8f57	20 5b a8	jsr $a85b			jsr 	StringTempWrite
.8f5a	c8		iny				iny
.8f5b	80 f6		bra $8f53			bra 	_SCCopyLoop
.8f5d					_SCCExit:
.8f5d	7a		ply				ply
.8f5e	60		rts				rts
.8f5f					_SCType:
.8f5f	4c 48 a0	jmp $a048			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/divide.asm

.8f62					IntegerDivide:
.8f62	fa		plx				plx
.8f63	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.8f66	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8f69	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8f6a	0a		asl a				asl 	a
.8f6b	10 05		bpl $8f72			bpl 	_NotRef
.8f6d	48		pha				pha
.8f6e	20 b9 96	jsr $96b9			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8f71	68		pla				pla
.8f72					_NotRef:
.8f72	0a		asl a				asl 	a
.8f73	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.8f75	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8f78	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8f7b	f0 03		beq $8f80			beq 	_IntegerCode 				; if clear, then we have two integers
.8f7d	4c 48 a0	jmp $a048			jmp 	TypeError 					; anything else, type mismatch.
.8f80					_IntegerCode:
.8f80	20 a2 8f	jsr $8fa2			jsr 	CheckDivideZero 			; do div zero check
.8f83	20 da 8f	jsr $8fda			jsr 	Int32Divide 				; do the division
.8f86	20 97 90	jsr $9097			jsr 	CalculateSign 				; calculate result sign
.8f89					NSMCopyPlusTwoToZero:
.8f89	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.8f8c	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.8f8f	bd 12 04	lda $0412,x			lda 	NSMantissa1+2,x
.8f92	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.8f95	bd 1a 04	lda $041a,x			lda 	NSMantissa2+2,x
.8f98	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.8f9b	bd 22 04	lda $0422,x			lda 	NSMantissa3+2,x
.8f9e	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.8fa1	60		rts				rts
.8fa2					CheckDivideZero:
.8fa2	e8		inx				inx
.8fa3	20 e4 9e	jsr $9ee4			jsr 	NSMIsZero
.8fa6	f0 02		beq $8faa			beq 	_CDVError
.8fa8	ca		dex				dex
.8fa9	60		rts				rts
.8faa					_CDVError:
.8faa	a9 03		lda #$03		lda	#3
.8fac	4c f1 8d	jmp $8df1		jmp	ErrorHandler
.8faf					IntegerModulus:
.8faf	fa		plx				plx
.8fb0	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.8fb3	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8fb6	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8fb7	0a		asl a				asl 	a
.8fb8	10 05		bpl $8fbf			bpl 	_NotRef
.8fba	48		pha				pha
.8fbb	20 b9 96	jsr $96b9			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8fbe	68		pla				pla
.8fbf					_NotRef:
.8fbf	0a		asl a				asl 	a
.8fc0	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.8fc2	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8fc5	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8fc8	f0 03		beq $8fcd			beq 	_IntegerCode 				; if clear, then we have two integers
.8fca	4c 48 a0	jmp $a048			jmp 	TypeError 					; anything else, type mismatch.
.8fcd					_IntegerCode:
.8fcd					IntegerModulusNoCheck:
.8fcd	20 a2 8f	jsr $8fa2			jsr 	CheckDivideZero 			; do div zero check
.8fd0	20 da 8f	jsr $8fda			jsr 	Int32Divide 				; do the division
.8fd3	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; clear the sign bit.
.8fd6	5e 00 04	lsr $0400,x			lsr 	NSStatus,x
.8fd9	60		rts				rts
.8fda					Int32Divide:
.8fda	48		pha				pha 								; save AXY
.8fdb	5a		phy				phy
.8fdc	20 8b 9e	jsr $9e8b			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.8fdf	20 b0 9e	jsr $9eb0			jsr 	NSMSetZeroMantissaOnly 		; set S[X] to zero
.8fe2	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.8fe4					_I32DivideLoop:
.8fe4	e8		inx				inx
.8fe5	e8		inx				inx
.8fe6	20 c9 9e	jsr $9ec9			jsr 	NSMShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.8fe9	ca		dex				dex
.8fea	ca		dex				dex
.8feb	20 ca 9e	jsr $9eca			jsr 	NSMRotateLeft
.8fee	20 1a 90	jsr $901a			jsr 	DivideCheckSubtract 		; check if subtract possible
.8ff1	90 03		bcc $8ff6			bcc 	_I32DivideNoCarryIn
.8ff3	fe 0a 04	inc $040a,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.8ff6					_I32DivideNoCarryIn:
.8ff6	88		dey				dey 								; loop round till division completed.
.8ff7	d0 eb		bne $8fe4			bne 	_I32DivideLoop
.8ff9	7a		ply				ply 								; restore AXY and exit
.8ffa	68		pla				pla
.8ffb	60		rts				rts
.8ffc					Int32ShiftDivide:
.8ffc	48		pha				pha 								; save AY
.8ffd	5a		phy				phy
.8ffe	e8		inx				inx 								; clear S[X+2]
.8fff	e8		inx				inx
.9000	20 b4 9e	jsr $9eb4			jsr 	NSMSetZero
.9003	ca		dex				dex
.9004	ca		dex				dex
.9005	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.9007					_I32SDLoop:
.9007	20 1a 90	jsr $901a			jsr 	DivideCheckSubtract 		; check if subtract possible
.900a	e8		inx				inx
.900b	e8		inx				inx
.900c	20 ca 9e	jsr $9eca			jsr 	NSMRotateLeft				; shift 64 bit FPA left, rotating carry in
.900f	ca		dex				dex
.9010	ca		dex				dex
.9011	20 ca 9e	jsr $9eca			jsr 	NSMRotateLeft
.9014	88		dey				dey 	 							; do 31 times
.9015	d0 f0		bne $9007			bne 	_I32SDLoop
.9017	7a		ply				ply 								; restore AY and exit
.9018	68		pla				pla
.9019	60		rts				rts
.901a					DivideCheckSubtract:
.901a	20 4f 91	jsr $914f			jsr 	SubTopTwoStack 				; subtract Stack[X+1] from Stack[X+0]
.901d	b0 04		bcs $9023			bcs 	_DCSExit 					; if carry set, then could do, exit
.901f	20 29 91	jsr $9129			jsr 	AddTopTwoStack 				; add it back in
.9022	18		clc				clc 								; and return False
.9023					_DCSExit:
.9023	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/multiply.asm

.9024					MulInteger:
.9024	fa		plx				plx
.9025	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9028	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.902b	0a		asl a				asl 	a 							; shift reference bit into sign bit
.902c	0a		asl a				asl 	a
.902d	10 05		bpl $9034			bpl 	_NotRef
.902f	48		pha				pha
.9030	20 b9 96	jsr $96b9			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9033	68		pla				pla
.9034					_NotRef:
.9034	0a		asl a				asl 	a 							; put MSB of type into A:7
.9035	30 0b		bmi $9042			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9037	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.903a	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.903d	f0 06		beq $9045			beq 	_IntegerCode 				; if clear, then we have two integers
.903f	4c 5d 95	jmp $955d			jmp 	FloatingPointMultiply 							; otherwise at least one float.
.9042					_StringData:
.9042	4c 52 a0	jmp $a052			jmp 	NotDoneError							; at least one string - don't know both are strings.
.9045					_IntegerCode:
.9045	20 52 90	jsr $9052			jsr 	MultiplyShort
.9048	c9 00		cmp #$00			cmp 	#0
.904a	f0 05		beq $9051			beq 	_MIExit
.904c	a9 04		lda #$04		lda	#4
.904e	4c f1 8d	jmp $8df1		jmp	ErrorHandler
.9051					_MIExit:
.9051	60		rts				rts
.9052					MultiplyShort:
.9052	5a		phy				phy 								; save Y
.9053	20 8b 9e	jsr $9e8b			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.9056	20 b0 9e	jsr $9eb0			jsr 	NSMSetZeroMantissaOnly 		; set mantissa S[X] to zero
.9059	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.905b					_I32MLoop:
.905b	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.905e	1d 12 04	ora $0412,x			ora 	NSMantissa1+2,x
.9061	1d 1a 04	ora $041a,x			ora 	NSMantissa2+2,x
.9064	1d 22 04	ora $0422,x			ora 	NSMantissa3+2,x
.9067	f0 28		beq $9091			beq 	_I32MExit 					; exit if zero
.9069	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.906c	29 01		and #$01			and 	#1
.906e	f0 0e		beq $907e			beq 	_I32MNoAdd
.9070	20 29 91	jsr $9129			jsr 	AddTopTwoStack 				; if so add S[X+1] to S[X+0]
.9073	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.9076	10 06		bpl $907e			bpl 	_I32MNoAdd
.9078					_I32ShiftRight:
.9078	20 d7 9e	jsr $9ed7			jsr 	NSMShiftRight 				; shift S[X] right
.907b	c8		iny				iny 								; increment shift count
.907c	80 0a		bra $9088			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.907e					_I32MNoAdd:
.907e	3c 21 04	bit $0421,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.9081	70 f5		bvs $9078			bvs 	_I32ShiftRight 				; instead.
.9083	e8		inx				inx
.9084	20 c9 9e	jsr $9ec9			jsr 	NSMShiftLeft 				; shift additive S[X+1] left
.9087	ca		dex				dex
.9088					_I32MShiftUpper:
.9088	e8		inx				inx 								; shift S[X+2] right
.9089	e8		inx				inx
.908a	20 d7 9e	jsr $9ed7			jsr 	NSMShiftRight
.908d	ca		dex				dex
.908e	ca		dex				dex
.908f	80 ca		bra $905b			bra 	_I32MLoop 					; try again.
.9091					_I32MExit:
.9091	20 97 90	jsr $9097			jsr 	CalculateSign
.9094	98		tya				tya 								; shift in A
.9095	7a		ply				ply 								; restore Y and exit
.9096	60		rts				rts
.9097					CalculateSign:
.9097	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.909a	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; shift result left
.909d	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.90a0	0a		asl a				asl 	a 							; shift bit 7 into carry
.90a1	7e 00 04	ror $0400,x			ror 	NSStatus,x 					; shift right into status byte.
.90a4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/scompare.asm

.90a5					CompareStrings:
.90a5	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check both are strings
.90a8	3d 01 04	and $0401,x			and 	NSStatus+1,x
.90ab	29 10		and #$10			and 	#NSBIsString
.90ad	f0 2c		beq $90db			beq 	_CSTypeError
.90af	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy string addresses to zTemp0/1
.90b2	85 36		sta $36				sta 	zTemp0
.90b4	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.90b7	85 37		sta $37				sta 	zTemp0+1
.90b9	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.90bc	85 38		sta $38				sta 	zTemp1
.90be	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.90c1	85 39		sta $39				sta 	zTemp1+1
.90c3	5a		phy				phy 								; save Y so we can access strings
.90c4	a0 ff		ldy #$ff			ldy 	#$FF 						; -1 for pre increment.
.90c6					_CSLoop:
.90c6	c8		iny				iny
.90c7	b1 36		lda ($36),y			lda 	(zTemp0),y 					; check if they are the same
.90c9	d1 38		cmp ($38),y			cmp 	(zTemp1),y
.90cb	d0 06		bne $90d3			bne 	_CSDifferent
.90cd	c9 00		cmp #$00			cmp 	#0 							; reached end ?
.90cf	d0 f5		bne $90c6			bne 	_CSLoop 					; still comparing
.90d1					_CSExit:
.90d1	7a		ply				ply 								; reached end, return zero in A from EOS
.90d2	60		rts				rts
.90d3					_CSDifferent:
.90d3	a9 ff		lda #$ff			lda 	#255 						; if < return $FF
.90d5	90 fa		bcc $90d1			bcc		_CSExit
.90d7	a9 01		lda #$01			lda 	#1 							; otherwise return 1.
.90d9	80 f6		bra $90d1			bra 	_CSExit
.90db					_CSTypeError:
.90db	4c 48 a0	jmp $a048			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/shifts.asm

.90de					ShiftLeft:
.90de	38		sec				sec
.90df	80 01		bra $90e2			bra 	ShiftMain
.90e1					ShiftRight:
.90e1	18		clc				clc
.90e2					ShiftMain:
.90e2	fa		plx				plx 								; restore X
.90e3	08		php				php 								; save direction
.90e4	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.90e7	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.90ea	0a		asl a				asl 	a 							; shift reference bit into sign bit
.90eb	0a		asl a				asl 	a
.90ec	10 05		bpl $90f3			bpl 	_NotRef
.90ee	48		pha				pha
.90ef	20 b9 96	jsr $96b9			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.90f2	68		pla				pla
.90f3					_NotRef:
.90f3	0a		asl a				asl 	a
.90f4	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.90f6	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.90f9	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.90fc	f0 03		beq $9101			beq 	_IntegerCode 				; if clear, then we have two integers
.90fe	4c 48 a0	jmp $a048			jmp 	TypeError 					; anything else, type mismatch.
.9101					_IntegerCode:
.9101	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; check number < 32
.9104	29 e0		and #$e0			and 	#$E0
.9106	1d 11 04	ora $0411,x			ora 	NSMantissa1+1,x
.9109	1d 19 04	ora $0419,x			ora 	NSMantissa2+1,x
.910c	1d 21 04	ora $0421,x			ora 	NSMantissa3+1,x
.910f	d0 13		bne $9124			bne 	_SMExit0 					; if >= 32 it will always return zero.
.9111					_SMLoop:
.9111	de 09 04	dec $0409,x			dec 	NSMantissa0+1,x 			; predecrement, could do << 0
.9114	30 11		bmi $9127			bmi 	_SMExit 					; exit if done.
.9116	28		plp				plp 								; restore direcition setting
.9117	08		php				php
.9118	90 05		bcc $911f			bcc 	_SMRight
.911a	20 c9 9e	jsr $9ec9			jsr 	NSMShiftLeft 				; shift left if CS
.911d	80 f2		bra $9111			bra 	_SMLoop
.911f					_SMRight:
.911f	20 d7 9e	jsr $9ed7			jsr 	NSMShiftRight 				; shift right if CC
.9122	80 ed		bra $9111			bra 	_SMLoop
.9124					_SMExit0:
.9124	20 b4 9e	jsr $9eb4			jsr 	NSMSetZero 					; return zero.
.9127					_SMExit:
.9127	28		plp				plp 								; throw direction
.9128	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/simple.asm

.9129					AddTopTwoStack:
.9129	18		clc				clc
.912a	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.912d	7d 09 04	adc $0409,x			adc 		NSMantissa0+1,x
.9130	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9133	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.9136	7d 11 04	adc $0411,x			adc 		NSMantissa1+1,x
.9139	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.913c	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.913f	7d 19 04	adc $0419,x			adc 		NSMantissa2+1,x
.9142	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9145	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.9148	7d 21 04	adc $0421,x			adc 		NSMantissa3+1,x
.914b	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.914e	60		rts				rts
.914f					SubTopTwoStack:
.914f	38		sec				sec
.9150	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.9153	fd 09 04	sbc $0409,x			sbc 		NSMantissa0+1,x
.9156	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9159	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.915c	fd 11 04	sbc $0411,x			sbc 		NSMantissa1+1,x
.915f	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9162	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.9165	fd 19 04	sbc $0419,x			sbc 		NSMantissa2+1,x
.9168	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.916b	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.916e	fd 21 04	sbc $0421,x			sbc 		NSMantissa3+1,x
.9171	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9174	60		rts				rts
.9175					AddInteger:
.9175	fa		plx				plx
.9176	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9179	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.917c	0a		asl a				asl 	a 							; shift reference bit into sign bit
.917d	0a		asl a				asl 	a
.917e	10 05		bpl $9185			bpl 	_NotRef
.9180	48		pha				pha
.9181	20 b9 96	jsr $96b9			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9184	68		pla				pla
.9185					_NotRef:
.9185	0a		asl a				asl 	a 							; put MSB of type into A:7
.9186	30 0b		bmi $9193			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9188	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.918b	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.918e	f0 06		beq $9196			beq 	_IntegerCode 				; if clear, then we have two integers
.9190	4c dd 93	jmp $93dd			jmp 	FloatingPointAdd 							; otherwise at least one float.
.9193					_StringData:
.9193	4c 05 8f	jmp $8f05			jmp 	StringConcat							; at least one string - don't know both are strings.
.9196					_IntegerCode:
.9196					AddCode:
.9196	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.9199	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.919c	10 8b		bpl $9129			bpl 	AddTopTwoStack
.919e	20 4f 91	jsr $914f			jsr 	SubTopTwoStack 				; do a physical subtraction
.91a1	3c 20 04	bit $0420,x			bit 	NSMantissa3,x 				; result is +ve, okay
.91a4	10 09		bpl $91af			bpl 	_AddExit
.91a6	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; sign is that of 2nd value
.91a9	9d 00 04	sta $0400,x			sta 	NSStatus,x
.91ac	20 69 9e	jsr $9e69			jsr 	NSMNegateMantissa 			; negate the mantissa and exit
.91af					_AddExit:
.91af	20 e4 9e	jsr $9ee4			jsr 	NSMIsZero 					; check for -0
.91b2	d0 03		bne $91b7			bne 	_AddNonZero
.91b4	9e 00 04	stz $0400,x			stz 	NSStatus,x
.91b7					_AddNonZero:
.91b7	60		rts				rts
.91b8					SubInteger:
.91b8	fa		plx				plx
.91b9	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.91bc	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.91bf	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91c0	0a		asl a				asl 	a
.91c1	10 05		bpl $91c8			bpl 	_NotRef
.91c3	48		pha				pha
.91c4	20 b9 96	jsr $96b9			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91c7	68		pla				pla
.91c8					_NotRef:
.91c8	0a		asl a				asl 	a 							; put MSB of type into A:7
.91c9	30 0b		bmi $91d6			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.91cb	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91ce	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.91d1	f0 06		beq $91d9			beq 	_IntegerCode 				; if clear, then we have two integers
.91d3	4c e2 93	jmp $93e2			jmp 	FloatingPointSub 							; otherwise at least one float.
.91d6					_StringData:
.91d6	4c 52 a0	jmp $a052			jmp 	NotDoneError							; at least one string - don't know both are strings.
.91d9					_IntegerCode:
.91d9	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; negate the second value.
.91dc	49 80		eor #$80			eor 	#$80
.91de	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.91e1	80 b3		bra $9196			bra 	AddCode 					; and do the same code as add.
.91e3					AndInteger:
.91e3	fa		plx				plx
.91e4	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.91e7	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.91ea	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91eb	0a		asl a				asl 	a
.91ec	10 05		bpl $91f3			bpl 	_NotRef
.91ee	48		pha				pha
.91ef	20 b9 96	jsr $96b9			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91f2	68		pla				pla
.91f3					_NotRef:
.91f3	0a		asl a				asl 	a
.91f4	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.91f6	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91f9	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.91fc	f0 03		beq $9201			beq 	_IntegerCode 				; if clear, then we have two integers
.91fe	4c 48 a0	jmp $a048			jmp 	TypeError 					; anything else, type mismatch.
.9201					_IntegerCode:
.9201	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.9204	3d 09 04	and $0409,x			and 		NSMantissa0+1,x
.9207	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.920a	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.920d	3d 11 04	and $0411,x			and 		NSMantissa1+1,x
.9210	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9213	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.9216	3d 19 04	and $0419,x			and 		NSMantissa2+1,x
.9219	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.921c	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.921f	3d 21 04	and $0421,x			and 		NSMantissa3+1,x
.9222	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9225	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.9228	60		rts				rts
.9229					OraInteger:
.9229	fa		plx				plx
.922a	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.922d	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9230	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9231	0a		asl a				asl 	a
.9232	10 05		bpl $9239			bpl 	_NotRef
.9234	48		pha				pha
.9235	20 b9 96	jsr $96b9			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9238	68		pla				pla
.9239					_NotRef:
.9239	0a		asl a				asl 	a
.923a	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.923c	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.923f	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9242	f0 03		beq $9247			beq 	_IntegerCode 				; if clear, then we have two integers
.9244	4c 48 a0	jmp $a048			jmp 	TypeError 					; anything else, type mismatch.
.9247					_IntegerCode:
.9247	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.924a	1d 09 04	ora $0409,x			ora 		NSMantissa0+1,x
.924d	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9250	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.9253	1d 11 04	ora $0411,x			ora 		NSMantissa1+1,x
.9256	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9259	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.925c	1d 19 04	ora $0419,x			ora 		NSMantissa2+1,x
.925f	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9262	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.9265	1d 21 04	ora $0421,x			ora 		NSMantissa3+1,x
.9268	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.926b	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.926e	60		rts				rts
.926f					EorInteger:
.926f	fa		plx				plx
.9270	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9273	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9276	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9277	0a		asl a				asl 	a
.9278	10 05		bpl $927f			bpl 	_NotRef
.927a	48		pha				pha
.927b	20 b9 96	jsr $96b9			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.927e	68		pla				pla
.927f					_NotRef:
.927f	0a		asl a				asl 	a
.9280	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9282	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9285	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9288	f0 03		beq $928d			beq 	_IntegerCode 				; if clear, then we have two integers
.928a	4c 48 a0	jmp $a048			jmp 	TypeError 					; anything else, type mismatch.
.928d					_IntegerCode:
.928d	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.9290	5d 09 04	eor $0409,x			eor 		NSMantissa0+1,x
.9293	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9296	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.9299	5d 11 04	eor $0411,x			eor 		NSMantissa1+1,x
.929c	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.929f	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.92a2	5d 19 04	eor $0419,x			eor 		NSMantissa2+1,x
.92a5	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.92a8	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.92ab	5d 21 04	eor $0421,x			eor 		NSMantissa3+1,x
.92ae	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.92b1	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.92b4	60		rts				rts
.92b5					WordIndirect:
.92b5	fa		plx				plx
.92b6	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.92b9	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.92bc	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92bd	0a		asl a				asl 	a
.92be	10 05		bpl $92c5			bpl 	_NotRef
.92c0	48		pha				pha
.92c1	20 b9 96	jsr $96b9			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92c4	68		pla				pla
.92c5					_NotRef:
.92c5	0a		asl a				asl 	a
.92c6	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.92c8	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92cb	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.92ce	f0 03		beq $92d3			beq 	_IntegerCode 				; if clear, then we have two integers
.92d0	4c 48 a0	jmp $a048			jmp 	TypeError 					; anything else, type mismatch.
.92d3					_IntegerCode:
.92d3	20 96 91	jsr $9196			jsr 	AddCode 					; add the two values
.92d6	a9 22		lda #$22			lda 	#NSBIsReference+2 			; make a 2 byte reference
.92d8	9d 00 04	sta $0400,x			sta 	NSStatus,x
.92db	60		rts				rts
.92dc					ByteIndirect:
.92dc	fa		plx				plx
.92dd	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.92e0	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.92e3	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92e4	0a		asl a				asl 	a
.92e5	10 05		bpl $92ec			bpl 	_NotRef
.92e7	48		pha				pha
.92e8	20 b9 96	jsr $96b9			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92eb	68		pla				pla
.92ec					_NotRef:
.92ec	0a		asl a				asl 	a
.92ed	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.92ef	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92f2	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.92f5	f0 03		beq $92fa			beq 	_IntegerCode 				; if clear, then we have two integers
.92f7	4c 48 a0	jmp $a048			jmp 	TypeError 					; anything else, type mismatch.
.92fa					_IntegerCode:
.92fa	20 96 91	jsr $9196			jsr 	AddCode 					; add the two values
.92fd	a9 21		lda #$21			lda 	#NSBIsReference+1 			; make a 1 byte reference
.92ff	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9302	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/tostring.asm

.9303					LCLConvertInt16:
.9303	8d 08 04	sta $0408			sta 	NSMantissa0 				; set up as 32 bit conversion
.9306	8e 10 04	stx $0410			stx 	NSMantissa1
.9309	9c 18 04	stz $0418			stz 	NSMantissa2
.930c	9c 20 04	stz $0420			stz 	NSMantissa3
.930f	9c 00 04	stz $0400			stz 	NSStatus 					; positive integer
.9312	a2 00		ldx #$00			ldx 	#0 							; stack level
.9314	a9 0a		lda #$0a			lda 	#10 						; base
.9316	80 00		bra $9318			bra 	ConvertInt32
.9318					ConvertInt32:
.9318	5a		phy				phy
.9319	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.931b	2c 00 04	bit $0400			bit 	NSStatus 					; output a - if not negative.
.931e	10 08		bpl $9328			bpl 	_CI32NotNeg
.9320	48		pha				pha
.9321	a9 2d		lda #$2d			lda 	#'-'
.9323	99 fa 05	sta $05fa,y			sta 	NumberBuffer,y
.9326	c8		iny				iny
.9327	68		pla				pla
.9328					_CI32NotNeg:
.9328	20 36 93	jsr $9336			jsr 	_CI32DivideConvert 			; recursive conversion
.932b	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.932d	99 fa 05	sta $05fa,y			sta 	NumberBuffer,y
.9330	7a		ply				ply
.9331	a2 05		ldx #$05			ldx 	#NumberBuffer >> 8
.9333	a9 fa		lda #$fa			lda 	#NumberBuffer & $FF
.9335	60		rts				rts
.9336					_CI32DivideConvert:
.9336	e8		inx				inx 								; write to next slot up
.9337	20 b6 9e	jsr $9eb6			jsr 	NSMSetByte
.933a	ca		dex				dex
.933b	20 da 8f	jsr $8fda			jsr 	Int32Divide 				; divide
.933e	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; save remainder
.9341	48		pha				pha
.9342	20 89 8f	jsr $8f89			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.9345	20 e4 9e	jsr $9ee4			jsr 	NSMIsZero 					; is it zero ?
.9348	f0 06		beq $9350			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.934a	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.934d	20 36 93	jsr $9336			jsr 	_CI32DivideConvert 			; and recusrively call.
.9350					_CI32NoRecurse:
.9350	68		pla				pla 								; remainder
.9351	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.9353	90 02		bcc $9357			bcc 	_CI32NotHex
.9355	69 26		adc #$26			adc 	#6+32
.9357					_CI32NotHex:
.9357	69 30		adc #$30			adc 	#48
.9359	99 fa 05	sta $05fa,y			sta 	NumberBuffer,y 				; write out and exit
.935c	c8		iny				iny
.935d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/expression.asm


;******  Processing file: ./common/expressions/../generated/precedence.dat

.935e					PrecedenceLevel:
>935e	04					.byte	 4	; $00 <<
>935f	02					.byte	 2	; $01 <=
>9360	02					.byte	 2	; $02 <>
>9361	00					.byte	 0	; $03 !!3
>9362	00					.byte	 0	; $04 ><
>9363	02					.byte	 2	; $05 >=
>9364	04					.byte	 4	; $06 >>
>9365	00					.byte	 0	; $07 !!7
>9366	00					.byte	 0	; $08 !!8
>9367	00					.byte	 0	; $09 !!9
>9368	00					.byte	 0	; $0a !!10
>9369	00					.byte	 0	; $0b !!11
>936a	00					.byte	 0	; $0c !!12
>936b	00					.byte	 0	; $0d !!13
>936c	00					.byte	 0	; $0e !!14
>936d	00					.byte	 0	; $0f !!15
>936e	00					.byte	 0	; $10 @
>936f	00					.byte	 0	; $11 !!17
>9370	00					.byte	 0	; $12 !!18
>9371	00					.byte	 0	; $13 [
>9372	04					.byte	 4	; $14 \
>9373	00					.byte	 0	; $15 ]
>9374	01					.byte	 1	; $16 ^
>9375	00					.byte	 0	; $17 _
>9376	00					.byte	 0	; $18 `
>9377	00					.byte	 0	; $19 !!25
>9378	00					.byte	 0	; $1a !!26
>9379	00					.byte	 0	; $1b {
>937a	01					.byte	 1	; $1c |
>937b	00					.byte	 0	; $1d }
>937c	00					.byte	 0	; $1e ~
>937d	00					.byte	 0	; $1f [7m<7F>[m
>937e	00					.byte	 0	; $20
>937f	05					.byte	 5	; $21 !
>9380	00					.byte	 0	; $22 "
>9381	00					.byte	 0	; $23 #
>9382	05					.byte	 5	; $24 $
>9383	04					.byte	 4	; $25 %
>9384	01					.byte	 1	; $26 &
>9385	00					.byte	 0	; $27 '
>9386	00					.byte	 0	; $28 (
>9387	00					.byte	 0	; $29 )
>9388	04					.byte	 4	; $2a *
>9389	03					.byte	 3	; $2b +
>938a	00					.byte	 0	; $2c ,
>938b	03					.byte	 3	; $2d -
>938c	00					.byte	 0	; $2e .
>938d	04					.byte	 4	; $2f /
>938e	00					.byte	 0	; $30 0
>938f	00					.byte	 0	; $31 1
>9390	00					.byte	 0	; $32 2
>9391	00					.byte	 0	; $33 3
>9392	00					.byte	 0	; $34 4
>9393	00					.byte	 0	; $35 5
>9394	00					.byte	 0	; $36 6
>9395	00					.byte	 0	; $37 7
>9396	00					.byte	 0	; $38 8
>9397	00					.byte	 0	; $39 9
>9398	00					.byte	 0	; $3a :
>9399	00					.byte	 0	; $3b ;
>939a	02					.byte	 2	; $3c <
>939b	02					.byte	 2	; $3d =
>939c	02					.byte	 2	; $3e >
>939d	05					.byte	 5	; $3f ?

;******  Return to file: ./common/expressions/expression.asm

.939e					EvaluateExpressionAt0:
.939e	a2 00		ldx #$00			ldx 	#0 							; bottom stack level
.93a0					EvaluateExpression:
.93a0	a9 00		lda #$00			lda 	#0 							; lowest precedence level
.93a2					EvaluateExpressionAtPrecedence:
.93a2	48		pha				pha 								; save precedence level
.93a3	20 7a 98	jsr $987a			jsr 	EvaluateTerm 				; evaluate term into level X.
.93a6	68		pla				pla 								; restore precedence level.
.93a7					_EXPRLoop:
.93a7	85 36		sta $36				sta 	zTemp0 						; save current precedence level.
.93a9	b1 30		lda ($30),y			lda 	(codePtr),y
.93ab	c9 40		cmp #$40			cmp		#$40 						; if >= $40 cannot be an operator
.93ad	b0 25		bcs $93d4			bcs 	_EXPRExit
.93af	da		phx				phx 								; read the operator precedence
.93b0	aa		tax				tax
.93b1	bd 5e 93	lda $935e,x			lda 	PrecedenceLevel,x
.93b4	fa		plx				plx
.93b5	c9 00		cmp #$00			cmp 	#0							; if zero exit (not an operator)
.93b7	f0 1b		beq $93d4			beq 	_EXPRExit
.93b9	85 37		sta $37				sta 	zTemp0+1 					; save operator precedence level.
.93bb	a5 36		lda $36				lda 	zTemp0 						; compare current precedence vs. operator precedence
.93bd	c5 37		cmp $37				cmp 	zTemp0+1
.93bf	b0 13		bcs $93d4			bcs		_EXPRExit 					; if current >= operator exit
.93c1	48		pha				pha 								; save current precedence.
.93c2	b1 30		lda ($30),y			lda 	(codePtr),y
.93c4	c8		iny				iny
.93c5	48		pha				pha
.93c6	a5 37		lda $37				lda 	zTemp0+1 					; get operator precedence level
.93c8	e8		inx				inx 								; work out the right hand side.
.93c9	20 a2 93	jsr $93a2			jsr 	EvaluateExpressionAtPrecedence
.93cc	ca		dex				dex
.93cd	68		pla				pla 								; get operator, call the code.
.93ce	20 d7 93	jsr $93d7			jsr 	_EXPRCaller
.93d1	68		pla				pla 								; restore precedence level
.93d2	80 d3		bra $93a7			bra 	_EXPRLoop 					; and go round.
.93d4					_EXPRExit:
.93d4	a5 36		lda $36				lda 	zTemp0 						; A = current precedence level.
.93d6	60		rts				rts
.93d7					_EXPRCaller:
.93d7	da		phx				phx 								; save on stack, first thing is to restore it
.93d8	0a		asl a				asl 	a 							; double so can use vectors into X
.93d9	aa		tax				tax
.93da	7c 1a 8b	jmp ($8b1a,x)			jmp 	(VectorSetPunc,x) 			; and go to the code.

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/addsub.asm

.93dd					FloatingPointAdd:
.93dd	20 86 95	jsr $9586			jsr 	FloatPrepare 				; prepare for floats
.93e0	80 0b		bra $93ed			bra 	FloatAdd
.93e2					FloatingPointSub:
.93e2	20 86 95	jsr $9586			jsr 	FloatPrepare 				; prepare for floats
.93e5					FloatSubtract:
.93e5	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; negate FPB
.93e8	49 80		eor #$80			eor 	#$80
.93ea	9d 01 04	sta $0401,x			sta 	NSStatus+1,x				; and fall through.
.93ed					FloatAdd:
.93ed	48		pha				pha
.93ee	5a		phy				phy
.93ef	20 97 95	jsr $9597			jsr 	NSNormalise 				; normalise S[X]
.93f2	f0 5c		beq $9450			beq 	_FAReturn1
.93f4	e8		inx				inx 								; normalise S[X+1]
.93f5	20 97 95	jsr $9597			jsr 	NSNormalise
.93f8	ca		dex				dex
.93f9	c9 00		cmp #$00			cmp 	#0
.93fb	f0 77		beq $9474			beq 	_FAExit 					; if so, just return A
.93fd	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; are the exponents the same ?
.9400	dd 29 04	cmp $0429,x			cmp 	NSExponent+1,x
.9403	f0 1b		beq $9420			beq 	_FAExponentsEqual
.9405	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; work out the larger exponent
.9408	a8		tay				tay
.9409	38		sec				sec 								; do a signed comparison of the exponents.
.940a	fd 29 04	sbc $0429,x			sbc 	NSExponent+1,x
.940d	50 02		bvc $9411			bvc 	_FANoSignedChange
.940f	49 80		eor #$80			eor 	#$80
.9411					_FANoSignedChange:
.9411	29 80		and #$80			and 	#$80
.9413	10 03		bpl $9418			bpl 	_FAHaveMax
.9415	bc 29 04	ldy $0429,x			ldy 	NSExponent+1,x
.9418					_FAHaveMax:
.9418	20 77 94	jsr $9477			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.941b	e8		inx				inx
.941c	20 77 94	jsr $9477			jsr 	_FAShiftToExponent
.941f	ca		dex				dex
.9420					_FAExponentsEqual:
.9420	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; are the signs the same
.9423	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.9426	30 10		bmi $9438			bmi 	_FADifferentSigns
.9428	20 29 91	jsr $9129			jsr 	AddTopTwoStack 				; do the add of the mantissae
.942b	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.942e	10 44		bpl $9474			bpl 	_FAExit 					; if no, we are done.
.9430	20 d7 9e	jsr $9ed7			jsr 	NSMShiftRight 				; shift A right, renormalising it.
.9433	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; bump the exponent and exit
.9436	80 3c		bra $9474			bra 	_FAExit
.9438					_FADifferentSigns:
.9438	20 4f 91	jsr $914f			jsr 	SubTopTwoStack 				; subtract mantissa B from A
.943b	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; is the result negative ?
.943e	10 06		bpl $9446			bpl 	_FACheckZero 				; if no, check for -0
.9440	20 60 9e	jsr $9e60			jsr 	NSMNegate 					; netate result
.9443	20 69 9e	jsr $9e69			jsr 	NSMNegateMantissa 			; negate (2'c) the mantissa
.9446					_FACheckZero:
.9446	20 e4 9e	jsr $9ee4			jsr 	NSMIsZero	 				; check for -0
.9449	d0 29		bne $9474			bne 	_FAExit
.944b	9e 00 04	stz $0400,x			stz 	NSStatus,x
.944e	80 24		bra $9474			bra 	_FAExit
.9450					_FAReturn1:
.9450	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.9453	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9456	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.9459	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.945c	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.945f	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9462	bd 21 04	lda $0421,x			lda 	NSMantissa3+1,x
.9465	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9468	bd 29 04	lda $0429,x			lda 	NSExponent+1,x
.946b	9d 28 04	sta $0428,x			sta 	NSExponent,x
.946e	bd 01 04	lda $0401,x			lda 	NSStatus+1,x
.9471	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9474					_FAExit:
.9474	7a		ply				ply
.9475	68		pla				pla
.9476	60		rts				rts
.9477					_FAShiftToExponent:
.9477					_FAShiftToExponent2:
.9477	98		tya				tya 								; compare Y to exponent
.9478	dd 28 04	cmp $0428,x			cmp 	NSExponent,x 				; reached the exponent required ?
.947b	f0 08		beq $9485			beq 	_FASEExit 					; exit if so.
.947d	20 d7 9e	jsr $9ed7			jsr 	NSMShiftRight	 			; shift the mantissa right
.9480	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; increment exponent
.9483	80 f2		bra $9477			bra 	_FAShiftToExponent2
.9485					_FASEExit:
.9485	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/compare.asm

.9486					CompareFloat:
.9486	20 e5 93	jsr $93e5			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.9489	bd 10 04	lda $0410,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.948c	29 f8		and #$f8			and 	#$F8
.948e	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9491	1d 20 04	ora $0420,x			ora 	NSMantissa3,x
.9494	f0 09		beq $949f			beq 	_FCExit 					; zero, so approximately identical
.9496	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.9498	3c 00 04	bit $0400,x			bit 	NSStatus,x
.949b	10 02		bpl $949f			bpl 	_FCExit
.949d					_FCNegative:
.949d	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.949f					_FCExit:
.949f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/divide.asm

.94a0					FDivideCommand:
.94a0	fa		plx				plx	 								; restore stack position
.94a1	20 86 95	jsr $9586			jsr 	FloatPrepare 				; prepare for floats
.94a4					FloatDivide:
.94a4	48		pha				pha
.94a5	e8		inx				inx
.94a6	20 97 95	jsr $9597			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.94a9	ca		dex				dex
.94aa	c9 00		cmp #$00			cmp 	#0
.94ac	f0 20		beq $94ce			beq 	_FDZero
.94ae	20 97 95	jsr $9597			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.94b1	f0 19		beq $94cc			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.94b3	20 fc 8f	jsr $8ffc			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.94b6	20 89 8f	jsr $8f89			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.94b9	20 97 95	jsr $9597			jsr		NSNormalise 				; renormalise
.94bc	20 97 90	jsr $9097			jsr 	CalculateSign 				; calculate result sign
.94bf	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; calculate exponent
.94c2	38		sec				sec
.94c3	fd 29 04	sbc $0429,x			sbc 	NSExponent+1,x
.94c6	38		sec				sec
.94c7	e9 1e		sbc #$1e			sbc 	#30
.94c9	9d 28 04	sta $0428,x			sta 	NSExponent,x
.94cc					_FDExit:
.94cc	68		pla				pla
.94cd	60		rts				rts
.94ce					_FDZero:
.94ce	a9 03		lda #$03		lda	#3
.94d0	4c f1 8d	jmp $8df1		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/fractional.asm

.94d3					FloatFractionalPart:
.94d3	5a		phy				phy
.94d4	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; take absolute value
.94d7	29 7f		and #$7f			and 	#$7F
.94d9	9d 00 04	sta $0400,x			sta 	NSStatus,x
.94dc	20 97 95	jsr $9597			jsr 	NSNormalise
.94df	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.94e2	38		sec				sec
.94e3	e9 e0		sbc #$e0			sbc 	#$E0
.94e5	90 31		bcc $9518			bcc 	_FFPExit 					; already fractional
.94e7	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.94e9	b0 2a		bcs $9515			bcs 	_FFPZero
.94eb	a8		tay				tay 								; put count to do in Y
.94ec	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; do each in turn.
.94ef	20 1a 95	jsr $951a			jsr 	_FFPPartial
.94f2	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.94f5	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.94f8	20 1a 95	jsr $951a			jsr 	_FFPPartial
.94fb	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.94fe	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9501	20 1a 95	jsr $951a			jsr 	_FFPPartial
.9504	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9507	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.950a	20 1a 95	jsr $951a			jsr 	_FFPPartial
.950d	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9510	20 e4 9e	jsr $9ee4			jsr 	NSMIsZero 					; zeroed check.
.9513	d0 03		bne $9518			bne 	_FFPExit
.9515					_FFPZero:
.9515	20 b4 9e	jsr $9eb4			jsr 	NSMSetZero
.9518					_FFPExit:
.9518	7a		ply				ply
.9519	60		rts				rts
.951a					_FFPPartial:
.951a	c0 00		cpy #$00			cpy 	#0 							; no more to do
.951c	f0 17		beq $9535			beq 	_FFFPPExit
.951e	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.9520	b0 0c		bcs $952e			bcs 	_FFFPPWholeByte
.9522	5a		phy				phy
.9523					_FFFPPLeft:
.9523	0a		asl a				asl 	a
.9524	88		dey				dey
.9525	d0 fc		bne $9523			bne 	_FFFPPLeft
.9527	7a		ply				ply
.9528					_FFFPPRight:
.9528	4a		lsr a				lsr 	a
.9529	88		dey				dey
.952a	d0 fc		bne $9528			bne 	_FFFPPRight
.952c	80 07		bra $9535			bra 	_FFFPPExit
.952e					_FFFPPWholeByte:
.952e	98		tya				tya 								; subtract 8 from count
.952f	38		sec				sec
.9530	e9 08		sbc #$08			sbc 	#8
.9532	a8		tay				tay
.9533	a9 00		lda #$00			lda 	#0 							; and clear all
.9535					_FFFPPExit:
.9535	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/integer.asm

.9536					FloatIntegerPart:
.9536	48		pha				pha
.9537	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; is it integer already ?
.953a	f0 1f		beq $955b			beq 	_FIPExit 					; if so do nothing
.953c	20 e4 9e	jsr $9ee4			jsr 	NSMIsZero 					; is it zero ?
.953f	f0 17		beq $9558			beq 	_FIPZero 					; if so return zero.
.9541	20 97 95	jsr $9597			jsr 	NSNormalise 				; normalise
.9544	f0 12		beq $9558			beq 	_FIPZero 					; normalised to zero, exit zero
.9546					_FIPShift:
.9546	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.9549	10 08		bpl $9553			bpl 	_FIPCheckZero
.954b	20 d7 9e	jsr $9ed7			jsr 	NSMShiftRight 				; shift mantissa right
.954e	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; bump exponent
.9551	80 f3		bra $9546			bra 	_FIPShift
.9553					_FIPCheckZero:
.9553	20 e4 9e	jsr $9ee4			jsr 	NSMIsZero 					; avoid -0 problem
.9556	d0 03		bne $955b			bne 	_FIPExit 					; set to zero if mantissa zero.
.9558					_FIPZero:
.9558	20 b4 9e	jsr $9eb4			jsr 	NSMSetZero
.955b					_FIPExit:
.955b	68		pla				pla
.955c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/multiply.asm

.955d					FloatingPointMultiply:
.955d	20 86 95	jsr $9586			jsr 	FloatPrepare 				; prepare for floats
.9560					FloatMultiply:
.9560	48		pha				pha
.9561	20 97 95	jsr $9597			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.9564	f0 1b		beq $9581			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.9566	e8		inx				inx
.9567	20 97 95	jsr $9597			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.956a	ca		dex				dex
.956b	c9 00		cmp #$00			cmp 	#0
.956d	f0 0f		beq $957e			beq 	_FDSetZero
.956f	20 52 90	jsr $9052			jsr 	MultiplyShort 				; calculate the result.
.9572	7d 28 04	adc $0428,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.9575	18		clc				clc
.9576	7d 29 04	adc $0429,x			adc 	NSExponent+1,x
.9579	9d 28 04	sta $0428,x			sta 	NSExponent,x
.957c	80 03		bra $9581			bra 	_FDExit
.957e					_FDSetZero:
.957e	20 b4 9e	jsr $9eb4			jsr 	NSMSetZero 					; return 0
.9581					_FDExit:
.9581	20 97 95	jsr $9597			jsr 	NSNormalise 				; normalise the result
.9584	68		pla				pla
.9585	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/utility.asm

.9586					FloatPrepare:
.9586	20 b9 96	jsr $96b9			jsr 	DereferenceTopTwo 			; dereference the top two values
.9589	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check ints/floats
.958c	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.958f	29 10		and #$10			and 	#NSBIsString
.9591	d0 01		bne $9594			bne 	_FDType
.9593	60		rts				rts
.9594					_FDType:
.9594	4c 48 a0	jmp $a048			jmp 	TypeError
.9597					NSNormalise:
.9597	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; make float, keep sign
.959a	29 80		and #$80			and 	#$80
.959c	09 08		ora #$08			ora 	#NSTFloat
.959e	9d 00 04	sta $0400,x			sta 	NSStatus,x
.95a1	20 e4 9e	jsr $9ee4			jsr 	NSMIsZero 					; if zero exit
.95a4	d0 09		bne $95af			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.95a6	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; clear the sign bit.
.95a9	7e 00 04	ror $0400,x			ror 	NSStatus,x 					; (no -0)
.95ac	a9 00		lda #$00			lda 	#0 							; set Z flag
.95ae	60		rts				rts
.95af					_NSNormaliseOptimise:
.95af	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; upper byte zero ?
.95b2	d0 22		bne $95d6			bne 	_NSNormaliseLoop
.95b4	bd 18 04	lda $0418,x			lda 	NSMantissa2,x 				; byte normalise
.95b7	30 1d		bmi $95d6			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.95b9	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.95bc	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.95bf	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.95c2	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.95c5	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.95c8	9e 08 04	stz $0408,x			stz 	NSMantissa0,x
.95cb	bd 28 04	lda $0428,x			lda 	NSExponent,x
.95ce	38		sec				sec
.95cf	e9 08		sbc #$08			sbc 	#8
.95d1	9d 28 04	sta $0428,x			sta 	NSExponent,x
.95d4	80 d9		bra $95af			bra 	_NSNormaliseOptimise
.95d6					_NSNormaliseLoop:
.95d6	3c 20 04	bit $0420,x			bit 	NSMantissa3,x 				; bit 30 set ?
.95d9	70 08		bvs $95e3			bvs 	_NSNExit 					; exit if so with Z flag clear
.95db	20 c9 9e	jsr $9ec9			jsr 	NSMShiftLeft 				; shift mantissa left
.95de	de 28 04	dec $0428,x			dec 	NSExponent,x 				; adjust exponent
.95e1	80 f3		bra $95d6			bra 	_NSNormaliseLoop
.95e3					_NSNExit:
.95e3	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.95e5	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignnumber.asm

.95e6					AssignNumber:
.95e6	5a		phy				phy
.95e7	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy mantissa0/1 to zTemp0
.95ea	85 36		sta $36				sta 	zTemp0
.95ec	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.95ef	85 37		sta $37				sta 	zTemp0+1
.95f1	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; clear reference bits
.95f4	29 df		and #$df			and 	#(NSBIsReference ^ $FF)
.95f6	9d 00 04	sta $0400,x			sta 	NSStatus,x
.95f9	29 18		and #$18			and 	#NSBTypeMask				; assigning to a float ?
.95fb	c9 08		cmp #$08			cmp 	#NSTFloat
.95fd	f0 2a		beq $9629			beq 	_ANFloat
.95ff	bd 29 04	lda $0429,x			lda		NSExponent+1,x 				; is it a float
.9602	f0 05		beq $9609			beq		_ANNotFloat
.9604	e8		inx				inx
.9605	20 36 95	jsr $9536			jsr 	FloatIntegerPart 			; make it an integer
.9608	ca		dex				dex
.9609					_ANNotFloat:
.9609	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if byte/word reference.
.960c	29 03		and #$03			and 	#3
.960e	d0 05		bne $9615			bne 	_ANByteWord
.9610	20 35 96	jsr $9635			jsr 	_ANCopy4PackSign 			; copy all 4 bytes and sign
.9613	80 1e		bra $9633			bra 	_ANExit
.9615					_ANByteWord:
.9615	48		pha				pha 								; save count
.9616	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; do byte
.9619	92 36		sta ($36)			sta 	(zTemp0)
.961b	68		pla				pla
.961c	c9 01		cmp #$01			cmp	 	#1
.961e	f0 13		beq $9633			beq 	_ANExit
.9620	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x 			; do word
.9623	a0 01		ldy #$01			ldy 	#1
.9625	91 36		sta ($36),y			sta 	(zTemp0),y
.9627	80 0a		bra $9633			bra 	_ANExit
.9629					_ANFloat:
.9629	20 35 96	jsr $9635			jsr 	_ANCopy4PackSign 			; write all 4 bytes and packed sign
.962c	bd 29 04	lda $0429,x			lda 	NSExponent+1,x 				; copy exponent to slot 4
.962f	a0 04		ldy #$04			ldy 	#4
.9631	91 36		sta ($36),y			sta 	(zTemp0),y
.9633					_ANExit:
.9633	7a		ply				ply
.9634	60		rts				rts
.9635					_ANCopy4PackSign:
.9635	a0 03		ldy #$03			ldy 	#3
.9637	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; sign bit into status
.963a	29 80		and #$80			and 	#$80 						; put into high bit of mantissa 3
.963c	1d 21 04	ora $0421,x			ora 	NSMantissa3+1,x
.963f	91 36		sta ($36),y			sta 	(zTemp0),y
.9641	88		dey				dey
.9642	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.9645	91 36		sta ($36),y			sta 	(zTemp0),y
.9647	88		dey				dey
.9648	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.964b	91 36		sta ($36),y			sta 	(zTemp0),y
.964d	88		dey				dey
.964e	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.9651	91 36		sta ($36),y			sta 	(zTemp0),y
.9653	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignstring.asm

.9654					AssignString:
.9654	5a		phy				phy
.9655	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.9658	85 38		sta $38				sta 	zTemp1
.965a	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.965d	85 39		sta $39				sta 	zTemp1+1
.965f	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9662	85 36		sta $36				sta 	zTemp0
.9664	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9667	85 37		sta $37				sta 	zTemp0+1
.9669	a0 01		ldy #$01			ldy 	#1 							; the high byte of the target address
.966b	b1 36		lda ($36),y			lda 	(zTemp0),y
.966d	f0 23		beq $9692			beq 	_ASNewStringRequired 		; if zero, a new string is required.
.966f	38		sec				sec 								; put Address-2 in zsTemp - this is the size/status/string record
.9670	b2 36		lda ($36)			lda 	(zTemp0) 					; of concreted strings
.9672	e9 02		sbc #$02			sbc 	#2
.9674	85 3c		sta $3c				sta 	zsTemp
.9676	a0 01		ldy #$01			ldy 	#1
.9678	b1 36		lda ($36),y			lda 	(zTemp0),y
.967a	e9 00		sbc #$00			sbc 	#0
.967c	85 3d		sta $3d				sta 	zsTemp+1
.967e	a0 ff		ldy #$ff			ldy 	#$FF 						; get length of new string
.9680					_ASGetLength:
.9680	c8		iny				iny
.9681	b1 38		lda ($38),y			lda 	(zTemp1),y
.9683	d0 fb		bne $9680			bne 	_ASGetLength
.9685	98		tya				tya 								; is this length <= current length
.9686	d2 3c		cmp ($3c)			cmp 	(zsTemp)
.9688	90 20		bcc $96aa			bcc 	_ASCopyString
.968a	f0 1e		beq $96aa			beq 	_ASCopyString
.968c	a9 80		lda #$80			lda 	#$80 						; mark as unused.
.968e	a0 01		ldy #$01			ldy 	#1
.9690	91 3c		sta ($3c),y			sta 	(zsTemp),y
.9692					_ASNewStringRequired:
.9692	e8		inx				inx 								; concrete the new string.
.9693	20 9c a7	jsr $a79c			jsr 	StringConcrete				; (breaks zTemp1/2, not zTemp0 and zsTemp)
.9696	ca		dex				dex
.9697	18		clc				clc
.9698	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; copy that new address to the reference.
.969b	69 02		adc #$02			adc 	#2 							; add two to point at the data.
.969d	92 36		sta ($36)			sta 	(zTemp0)
.969f	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.96a2	69 00		adc #$00			adc 	#0
.96a4	a0 01		ldy #$01			ldy 	#1
.96a6	91 36		sta ($36),y			sta 	(zTemp0),y
.96a8	80 0d		bra $96b7			bra 	_ASExit
.96aa					_ASCopyString:
.96aa	a0 00		ldy #$00			ldy 	#0
.96ac					_ASCopyLoop:
.96ac	b1 38		lda ($38),y			lda 	(zTemp1),y
.96ae	c8		iny				iny
.96af	c8		iny				iny
.96b0	91 3c		sta ($3c),y			sta 	(zsTemp),y
.96b2	88		dey				dey
.96b3	c9 00		cmp #$00			cmp 	#0
.96b5	d0 f5		bne $96ac			bne 	_ASCopyLoop
.96b7					_ASExit:
.96b7	7a		ply				ply
.96b8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/dereference.asm

.96b9					DereferenceTopTwo:
.96b9	e8		inx				inx
.96ba	20 be 96	jsr $96be			jsr 	Dereference 				; deref x+1
.96bd	ca		dex				dex  								; falls through to deref x
.96be					Dereference:
.96be	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get the status byte
.96c1	29 20		and #$20			and 	#NSBIsReference 			; shift sign bit to carry, reference to bit 7
.96c3	f0 57		beq $971c			beq 	_DRFExit 					; not a reference
.96c5	5a		phy				phy
.96c6	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address to dereference into zTemp0
.96c9	85 36		sta $36				sta 	zTemp0
.96cb	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.96ce	85 37		sta $37				sta 	zTemp0+1
.96d0	9e 10 04	stz $0410,x			stz 	NSMantissa1,x 				; clear second byte.
.96d3	b2 36		lda ($36)			lda 	(zTemp0) 					; do the first byte
.96d5	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.96d8	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get status byte.
.96db	29 18		and #$18			and 	#NSBTypeMask 				; what type is it ?
.96dd	c9 10		cmp #$10			cmp 	#NSTString 					; if string, dereference two
.96df	f0 0f		beq $96f0			beq 	_DRFDereferenceTwo
.96e1	c9 08		cmp #$08			cmp 	#NSTFloat 					; if float, do full dereference.
.96e3	f0 39		beq $971e			beq 	_DRFFull
.96e5	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be integer - how many bytes ?
.96e8	29 03		and #$03			and 	#3
.96ea	f0 32		beq $971e			beq 	_DRFFull 					; the whole word
.96ec	c9 01		cmp #$01			cmp 	#1 							; is it 10 (e.g. 2 bytes)
.96ee	f0 07		beq $96f7			beq		_DRFClear23 				; no, one byte, clear 2 & 3 and exit
.96f0					_DRFDereferenceTwo:
.96f0	a0 01		ldy #$01			ldy 	#1
.96f2	b1 36		lda ($36),y			lda 	(zTemp0),y
.96f4	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.96f7					_DRFClear23:
.96f7	9e 18 04	stz $0418,x			stz 	NSMantissa2,x 				; clear upper bytes, only read 1 or 2 bytes
.96fa	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.96fd	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; make it a value of that type.
.9700	29 18		and #$18			and 	#NSBTypeMask
.9702	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9705	c9 10		cmp #$10			cmp 	#NSTString  				; is it a string
.9707	d0 12		bne $971b			bne 	_DRFNotString
.9709	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; check address is zero
.970c	1d 10 04	ora $0410,x			ora 	NSMantissa1,x
.970f	d0 0a		bne $971b			bne 	_DRFNotString
.9711	a9 1d		lda #$1d			lda 	#_DRFNullString & $FF 		; if so, return reference to ""
.9713	9d 08 04	sta $0408,x			sta 	NSMantissa0,X
.9716	a9 97		lda #$97			lda 	#_DRFNullString >> 8
.9718	9d 10 04	sta $0410,x			sta 	NSMantissa1,X
.971b					_DRFNotString
.971b	7a		ply				ply 								; restore Y and exit
.971c					_DRFExit:
.971c	60		rts				rts
.971d					_DRFNullString:
>971d	00						.byte 	0
.971e					_DRFFull:
.971e	a0 01		ldy #$01			ldy 	#1 							; get remaining 3 bytes.
.9720	b1 36		lda ($36),y			lda 	(zTemp0),y
.9722	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9725	c8		iny				iny
.9726	b1 36		lda ($36),y			lda 	(zTemp0),y
.9728	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.972b	c8		iny				iny
.972c	b1 36		lda ($36),y			lda 	(zTemp0),y
.972e	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9731	9e 28 04	stz $0428,x			stz 	NSExponent,x 				; clear exponent.
.9734	bd 00 04	lda $0400,x			lda		NSStatus,x 					; see if type is integer
.9737	29 18		and #$18			and 	#NSBTypeMask  				; type information only
.9739	9d 00 04	sta $0400,x			sta 	NSStatus,x 					; update it back.
.973c	f0 06		beq $9744			beq 	_DRFNoExponent
.973e	c8		iny				iny 								; if not, read the exponent as well.
.973f	b1 36		lda ($36),y			lda 	(zTemp0),y
.9741	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9744					_DRFNoExponent:
.9744	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; is the most significant bit set ?
.9747	10 0d		bpl $9756			bpl 	_DRFExit2 					; if not, then exit.
.9749	29 7f		and #$7f			and 	#$7F 						; clear that bit.
.974b	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.974e	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; set the sign flag
.9751	09 80		ora #$80			ora 	#NSBIsNegative
.9753	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9756					_DRFExit2:
.9756	7a		ply				ply
.9757	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/number.asm

=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.9758					EncodeNumberStart:
.9758	38		sec				sec
.9759	80 01		bra $975c			bra 	EncodeNumberContinue+1
.975b					EncodeNumberContinue:
.975b	18		clc				clc
.975c					EncodeNumber:
.975c	08		php				php 								; save reset.
.975d	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.975f	f0 12		beq $9773			beq 	_ENIsOkay
.9761	c9 30		cmp #$30			cmp 	#"0"
.9763	90 04		bcc $9769			bcc 	_ENBadNumber
.9765	c9 3a		cmp #$3a			cmp 	#"9"+1
.9767	90 0a		bcc $9773			bcc 	_ENIsOkay
.9769					_ENBadNumber:
.9769	28		plp				plp 								; throw saved reset
.976a	ad 85 04	lda $0485			lda 	EncodeState 				; decimal mode, construct final number
.976d	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.976f	f0 7e		beq $97ef			beq 	_ENConstructFinal
.9771					_ENFail:
.9771	18		clc				clc 								; not allowed
.9772	60		rts				rts
.9773					_ENIsOkay:
.9773	28		plp				plp 								; are we restarting
.9774	90 15		bcc $978b			bcc 	_ENNoRestart
.9776					_ENStartEncode:
.9776	c9 2e		cmp #$2e			cmp 	#'.'						; first is DP
.9778	f0 0c		beq $9786			beq 	_ENFirstDP
.977a	29 0f		and #$0f			and 	#15 						; put digit in mantissa
.977c	20 b6 9e	jsr $9eb6			jsr 	NSMSetByte
.977f	a9 01		lda #$01			lda 	#ESTA_Low
.9781					_ENExitChange:
.9781	8d 85 04	sta $0485			sta 	EncodeState 				; save new state
.9784	38		sec				sec
.9785	60		rts				rts
.9786					_ENFirstDP:
.9786	20 b4 9e	jsr $9eb4			jsr 	NSMSetZero 					; clear integer part
.9789	80 3f		bra $97ca			bra 	_ESTASwitchFloat			; go straight to float and exi
.978b					_ENNoRestart:
.978b	48		pha				pha 								; save on stack.
.978c	ad 85 04	lda $0485			lda 	EncodeState 				; get current state
.978f	c9 01		cmp #$01			cmp 	#ESTA_Low
.9791	f0 09		beq $979c			beq  	_ESTALowState
.9793	c9 02		cmp #$02			cmp 	#ESTA_High
.9795	f0 29		beq $97c0			beq 	_ESTAHighState
.9797	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.9799	f0 3b		beq $97d6			beq 	_ESTADecimalState
>979b	db						.byte 	$DB 						; causes a break in the emulator
.979c					_ESTALowState:
.979c	68		pla				pla 								; get value back
.979d	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.979f	f0 29		beq $97ca			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.97a1	29 0f		and #$0f			and 	#15 						; make digit
.97a3	8d 86 04	sta $0486			sta 	DigitTemp 					; save it.
.97a6	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.97a9	0a		asl a				asl 	a
.97aa	0a		asl a				asl 	a
.97ab	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.97ae	0a		asl a				asl 	a
.97af	6d 86 04	adc $0486			adc 	DigitTemp
.97b2	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.97b5	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.97b7	90 05		bcc $97be			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.97b9	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.97bb	8d 85 04	sta $0485			sta 	EncodeState
.97be					_ESTANoSwitch:
.97be	38		sec				sec
.97bf	60		rts				rts
.97c0					_ESTAHighState:
.97c0	68		pla				pla 								; get value back
.97c1	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.97c3	f0 05		beq $97ca			beq 	_ESTASwitchFloat
.97c5	20 29 98	jsr $9829			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.97c8	38		sec				sec
.97c9	60		rts				rts
.97ca					_ESTASwitchFloat:
.97ca	9c 87 04	stz $0487			stz 	DecimalCount
.97cd	e8		inx				inx 								; zero the decimal additive.
.97ce	20 b4 9e	jsr $9eb4			jsr 	NSMSetZero
.97d1	ca		dex				dex
.97d2	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.97d4	80 ab		bra $9781			bra 	_ENExitChange
.97d6					_ESTADecimalState:
.97d6	68		pla				pla 								; digit.
.97d7	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 2nd decimal point.
.97d9	f0 96		beq $9771			beq 	_ENFail
.97db	e8		inx				inx 								; put digit into fractional part of X+1
.97dc	20 29 98	jsr $9829			jsr 	ESTAShiftDigitIntoMantissa
.97df	ca		dex				dex
.97e0	ee 87 04	inc $0487			inc 	DecimalCount 				; bump the count of decimals
.97e3	ad 87 04	lda $0487			lda 	DecimalCount
.97e6	c9 0b		cmp #$0b			cmp 	#11
.97e8	f0 02		beq $97ec			beq 	_ESTADSFail
.97ea	38		sec				sec
.97eb	60		rts				rts
.97ec					_ESTADSFail:
.97ec	4c 43 a0	jmp $a043			jmp 	RangeError
.97ef					_ENConstructFinal:
.97ef	ad 87 04	lda $0487			lda 	DecimalCount 				; get decimal count
.97f2	f0 33		beq $9827			beq 	_ENCFExit 					; no decimals
.97f4	5a		phy				phy
.97f5	0a		asl a				asl 	a 							; x 4 and CLC
.97f6	0a		asl a				asl 	a
.97f7	6d 87 04	adc $0487			adc 	DecimalCount
.97fa	a8		tay				tay
.97fb	b9 02 a0	lda $a002,y			lda 	DecimalScalarTable-5,y 		; copy decimal scalar to X+2
.97fe	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9801	b9 03 a0	lda $a003,y			lda 	DecimalScalarTable-5+1,y
.9804	9d 12 04	sta $0412,x			sta 	NSMantissa1+2,x
.9807	b9 04 a0	lda $a004,y			lda 	DecimalScalarTable-5+2,y
.980a	9d 1a 04	sta $041a,x			sta 	NSMantissa2+2,x
.980d	b9 05 a0	lda $a005,y			lda 	DecimalScalarTable-5+3,y
.9810	9d 22 04	sta $0422,x			sta 	NSMantissa3+2,x
.9813	b9 06 a0	lda $a006,y			lda 	DecimalScalarTable-5+4,y
.9816	9d 2a 04	sta $042a,x			sta 	NSExponent+2,x
.9819	a9 08		lda #$08			lda 	#NSTFloat
.981b	9d 02 04	sta $0402,x			sta 	NSStatus+2,x
.981e	7a		ply				ply
.981f	e8		inx				inx 								; multiply decimal const by decimal scalar
.9820	20 60 95	jsr $9560			jsr 	FloatMultiply
.9823	ca		dex				dex
.9824	20 ed 93	jsr $93ed			jsr 	FloatAdd 					; add to integer part.
.9827					_ENCFExit:
.9827	18		clc				clc 								; reject the digit.
.9828	60		rts				rts
.9829					ESTAShiftDigitIntoMantissa:
.9829	29 0f		and #$0f			and 	#15 						; save digit
.982b	48		pha				pha
.982c	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; push mantissa on stack
.982f	48		pha				pha
.9830	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9833	48		pha				pha
.9834	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9837	48		pha				pha
.9838	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.983b	48		pha				pha
.983c	20 c9 9e	jsr $9ec9			jsr 	NSMShiftLeft 				; x 2
.983f	20 c9 9e	jsr $9ec9			jsr 	NSMShiftLeft 				; x 4
.9842	18		clc				clc 								; pop mantissa and add
.9843	68		pla				pla
.9844	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.9847	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.984a	68		pla				pla
.984b	7d 10 04	adc $0410,x			adc 	NSMantissa1,x
.984e	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9851	68		pla				pla
.9852	7d 18 04	adc $0418,x			adc 	NSMantissa2,x
.9855	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9858	68		pla				pla
.9859	7d 20 04	adc $0420,x			adc 	NSMantissa3,x
.985c	9d 20 04	sta $0420,x			sta 	NSMantissa3,x 				; x 5
.985f	20 c9 9e	jsr $9ec9			jsr 	NSMShiftLeft 				; x 10
.9862	68		pla				pla 								; add digit
.9863	18		clc				clc
.9864	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.9867	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.986a	90 0d		bcc $9879			bcc 	_ESTASDExit
.986c	fe 10 04	inc $0410,x			inc 	NSMantissa1,x
.986f	d0 08		bne $9879			bne 	_ESTASDExit
.9871	fe 18 04	inc $0418,x			inc 	NSMantissa2,x
.9874	d0 03		bne $9879			bne 	_ESTASDExit
.9876	fe 20 04	inc $0420,x			inc 	NSMantissa3,x
.9879					_ESTASDExit:
.9879	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/term.asm

.987a					EvaluateTerm:
.987a	b1 30		lda ($30),y			lda 	(codePtr),y
.987c	30 18		bmi $9896			bmi 	_ETCheckUnary 				; unary function ? (text ones)
.987e	c9 40		cmp #$40			cmp 	#$40 						; 40-7F => identifier reference
.9880	b0 6f		bcs $98f1			bcs 	_ETVariable
.9882	c9 30		cmp #$30			cmp 	#'0' 						; is it a number
.9884	90 6e		bcc $98f4			bcc 	_ETPuncUnary 				; if not it might be a punctuation unary.
.9886	c9 3a		cmp #$3a			cmp 	#'9'+1
.9888	b0 6a		bcs $98f4			bcs 	_ETPuncUnary
.988a	20 58 97	jsr $9758			jsr 	EncodeNumberStart 			; can't fail as it's 0-9 !
.988d					_ETNumber:
.988d	c8		iny				iny 								; keep encoding until we have the numbers
.988e	b1 30		lda ($30),y			lda 	(codePtr),y
.9890	20 5b 97	jsr $975b			jsr 	EncodeNumberContinue
.9893	b0 f8		bcs $988d			bcs 	_ETNumber 					; go back if accepted.
.9895	60		rts				rts
.9896					_ETCheckUnary:
.9896	c9 ff		cmp #$ff			cmp 	#KWC_STRING 				; string token
.9898	f0 41		beq $98db			beq 	_ETString
.989a	c9 fe		cmp #$fe			cmp 	#KWC_HEXCONST 				; hex constant.
.989c	f0 12		beq $98b0			beq 	_ETHexConstant
.989e	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; check it actually is a unary function
.98a0	90 0b		bcc $98ad			bcc 	_ETSyntaxError
.98a2	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1
.98a4	b0 07		bcs $98ad			bcs 	_ETSyntaxError
.98a6	da		phx				phx 								; push X on the stack
.98a7	0a		asl a				asl 	a 							; put vector x 2 into X
.98a8	aa		tax				tax
.98a9	c8		iny				iny 								; consume unary function token
.98aa	7c 9a 8b	jmp ($8b9a,x)			jmp 	(VectorSet0,x) 				; and do it.
.98ad					_ETSyntaxError:
.98ad	4c 3e a0	jmp $a03e			jmp 	SyntaxError
.98b0					_ETHexConstant:
.98b0	c8		iny				iny 								; skip #
.98b1	c8		iny				iny 								; skip count
.98b2	20 b4 9e	jsr $9eb4			jsr 	NSMSetZero 					; clear result
.98b5					_ETHLoop:
.98b5	b1 30		lda ($30),y			lda 	(codePtr),y
.98b7	c8		iny				iny 								; and consume
.98b8	c9 00		cmp #$00			cmp 	#0 							; exit if zero
.98ba	f0 1e		beq $98da			beq 	_ETHExit
.98bc	48		pha				pha 								; save on stack.
.98bd	20 c9 9e	jsr $9ec9			jsr 	NSMShiftLeft 				; x 2
.98c0	20 c9 9e	jsr $9ec9			jsr 	NSMShiftLeft 				; x 4
.98c3	20 c9 9e	jsr $9ec9			jsr 	NSMShiftLeft 				; x 8
.98c6	20 c9 9e	jsr $9ec9			jsr 	NSMShiftLeft 				; x 16
.98c9	68		pla				pla 								; ASCII
.98ca	c9 41		cmp #$41			cmp 	#'A'
.98cc	90 02		bcc $98d0			bcc 	_ETHNotChar
.98ce	e9 07		sbc #$07			sbc 	#7
.98d0					_ETHNotChar:
.98d0	29 0f		and #$0f			and 	#15 						; digit now
.98d2	1d 08 04	ora $0408,x			ora 	NSMantissa0,x 				; put in LS Nibble
.98d5	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.98d8	80 db		bra $98b5			bra 	_ETHLoop 					; go round.
.98da					_ETHExit:
.98da	60		rts				rts
.98db					_ETString:
.98db	c8		iny				iny 								; look at length
.98dc	b1 30		lda ($30),y			lda 	(codePtr),y
.98de	48		pha				pha
.98df	c8		iny				iny 								; first character
.98e0	20 39 a6	jsr $a639			jsr 	MemoryInline 				; put address of string at (code-Ptr),y on stack
.98e3	68		pla				pla 								; restore count and save
.98e4	85 36		sta $36				sta 	zTemp0
.98e6	98		tya				tya 								; add length to Y to skip it.
.98e7	18		clc				clc
.98e8	65 36		adc $36				adc 	zTemp0
.98ea	a8		tay				tay
.98eb	a9 10		lda #$10			lda 	#NSTString 					; mark as string
.98ed	9d 00 04	sta $0400,x			sta 	NSStatus,x
.98f0	60		rts				rts
.98f1					_ETVariable:
.98f1	4c 4b 99	jmp $994b			jmp 	VariableHandler
.98f4					_ETPuncUnary:
.98f4	c8		iny				iny 								; consume the unary character
.98f5	c9 2d		cmp #$2d			cmp 	#KWD_MINUS 					; unary minus
.98f7	f0 2d		beq $9926			beq 	_ETUnaryNegate
.98f9	c9 10		cmp #$10			cmp 	#KWD_AT 					; @ reference -> constant
.98fb	f0 39		beq $9936			beq 	_ETDereference
.98fd	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; parenthesis
.98ff	f0 43		beq $9944			beq 	_ETParenthesis
.9901	64 36		stz $36				stz 	zTemp0 						; zTemp0 is the indirection level.
.9903	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; byte indirection (0) ?
.9905	f0 06		beq $990d			beq 	_ETIndirection
.9907	e6 36		inc $36				inc 	zTemp0
.9909	c9 21		cmp #$21			cmp 	#KWD_PLING					; word indirection (1) \
.990b	d0 a0		bne $98ad			bne 	_ETSyntaxError
.990d					_ETIndirection:
.990d	a5 36		lda $36				lda 	zTemp0 						; push indirection amount (0-1) => (1-2) on the stack
.990f	1a		inc a				inc 	a
.9910	48		pha				pha
.9911	20 7a 98	jsr $987a			jsr 	EvaluateTerm				; evaluate the term
.9914	20 be 96	jsr $96be			jsr 	Dereference 				; dereference it.
.9917	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a +ve integer.
.991a	d0 07		bne $9923			bne 	_ETTypeMismatch
.991c	68		pla				pla 								; indirection 1-2
.991d	09 20		ora #$20			ora 	#NSBIsReference 			; make it a reference.
.991f	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9922	60		rts				rts
.9923					_ETTypeMismatch:
.9923	4c 48 a0	jmp $a048			jmp 	TypeError
.9926					_ETUnaryNegate:
.9926	20 7a 98	jsr $987a			jsr 	EvaluateTerm				; evaluate the term
.9929	20 be 96	jsr $96be			jsr 	Dereference 				; dereference it.
.992c	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a number
.992f	29 10		and #$10			and 	#NSTString
.9931	d0 f0		bne $9923			bne 	_ETTypeMismatch
.9933	4c 60 9e	jmp $9e60			jmp 	NSMNegate  					; just toggles the sign bit.
.9936					_ETDereference:
.9936	20 7a 98	jsr $987a			jsr 	EvaluateTerm				; evaluate the term
.9939	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a reference
.993c	29 20		and #$20			and 	#NSBIsReference
.993e	f0 e3		beq $9923			beq 	_ETTypeMismatch
.9940	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; make it an integer address
.9943	60		rts				rts
.9944					_ETParenthesis:
.9944	20 a0 93	jsr $93a0			jsr 	EvaluateExpression 			; evaluate here, from lowest precedence
.9947	20 d8 8d	jsr $8dd8			jsr 	CheckRightBracket 			; check for )
.994a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/variable.asm

.994b					VariableHandler:
.994b	b1 30		lda ($30),y			lda 	(codePtr),y
.994d	18		clc				clc
.994e	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.9950	85 37		sta $37				sta 	zTemp0+1
.9952	c8		iny				iny
.9953	b1 30		lda ($30),y			lda 	(codePtr),y
.9955	85 36		sta $36				sta 	zTemp0
.9957	c8		iny				iny
.9958	18		clc				clc									; copy variable address+3 to mantissa
.9959	69 03		adc #$03			adc 	#3
.995b	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.995e	a5 37		lda $37				lda 	zTemp0+1
.9960	69 00		adc #$00			adc 	#0
.9962	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9965	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.9968	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.996b	9e 28 04	stz $0428,x			stz 	NSExponent,x
.996e	5a		phy				phy
.996f	a0 02		ldy #$02			ldy 	#2 							; read type
.9971	b1 36		lda ($36),y			lda 	(zTemp0),y
.9973	7a		ply				ply
.9974	29 1c		and #$1c			and 	#NSBTypeMask+NSBIsArray 	; get type information
.9976	09 20		ora #$20			ora 	#NSBIsReference 			; make a reference.
.9978	9d 00 04	sta $0400,x			sta 	NSStatus,x
.997b	29 04		and #$04			and 	#NSBIsArray
.997d	d0 01		bne $9980			bne 	_VHArray
.997f	60		rts				rts
.9980					_VHArray:
.9980	e8		inx				inx
.9981	20 35 9e	jsr $9e35			jsr 	Evaluate8BitInteger 		; get the 1st index.
.9984	a9 ff		lda #$ff			lda 	#$FF 						; set Status of X+2 to a duff value so we know if we picked it up.
.9986	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.9989	b1 30		lda ($30),y			lda 	(codePtr),y
.998b	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.998d	d0 06		bne $9995			bne 	_VHNoSecondIndex
.998f	c8		iny				iny 								; skip the comma
.9990	e8		inx				inx
.9991	20 35 9e	jsr $9e35			jsr 	Evaluate8BitInteger 		; get the 2nd index.
.9994	ca		dex				dex
.9995					_VHNoSecondIndex:
.9995	ca		dex				dex 								; set X back.
.9996	20 d8 8d	jsr $8dd8			jsr 	CheckRightBracket 			; and check the right bracket.
.9999	5a		phy				phy 								; save position
.999a	a0 02		ldy #$02			ldy 	#2 							; check first index is not-zero, e.g. array defined
.999c	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.999e	f0 6b		beq $9a0b			beq 	_VHBadIndex
.99a0	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy record address to zaTemp
.99a3	85 3e		sta $3e				sta 	zaTemp
.99a5	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.99a8	85 3f		sta $3f				sta 	zaTemp+1
.99aa	a0 03		ldy #$03			ldy 	#3 							; get the second index - which is 0 if there is one index.
.99ac	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99ae	f0 02		beq $99b2			beq 	_VHHas2Mask
.99b0	a9 ff		lda #$ff			lda 	#$FF
.99b2					_VHHas2Mask:
.99b2	dd 02 04	cmp $0402,x			cmp 	NSStatus+2,x 				; so if they are the same there are the wrong number of indices
.99b5	f0 54		beq $9a0b			beq 	_VHBadIndex
.99b7	0a		asl a				asl 	a 							; carry will be set if a second index
.99b8	90 09		bcc $99c3			bcc 	_VHCheckFirstIndex
.99ba	a0 03		ldy #$03			ldy 	#3 			 				; check the 2nd size >= 2nd index
.99bc	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99be	dd 0a 04	cmp $040a,x			cmp 	NSMantissa0+2,x
.99c1	90 48		bcc $9a0b			bcc 	_VHBadIndex
.99c3					_VHCheckFirstIndex:
.99c3	a0 02		ldy #$02			ldy 	#2 			 				; check the 2nd size >= 2nd index
.99c5	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99c7	dd 09 04	cmp $0409,x			cmp 	NSMantissa0+1,x
.99ca	90 3f		bcc $9a0b			bcc 	_VHBadIndex
.99cc	64 36		stz $36				stz 	zTemp0 						; clear zTemp0 (if 1 index)
.99ce	64 37		stz $37				stz 	zTemp0+1
.99d0	bd 02 04	lda $0402,x			lda 	NSStatus+2,x 				; if only one index provided, don't need to multiply
.99d3	30 0f		bmi $99e4			bmi 	_VHNoMultiply
.99d5	da		phx				phx
.99d6	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; get 2nd index on stack
.99d9	48		pha				pha
.99da	a0 02		ldy #$02			ldy 	#2 							; get 1st size in A
.99dc	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99de	1a		inc a				inc 	a 							; add 1 for zero base
.99df	fa		plx				plx
.99e0	20 49 9e	jsr $9e49			jsr 	Multiply8x8 				; calculate -> Z0
.99e3	fa		plx				plx
.99e4					_VHNoMultiply:
.99e4	18		clc				clc
.99e5	a5 36		lda $36				lda 	zTemp0
.99e7	7d 09 04	adc $0409,x			adc 	NSMantissa0+1,x
.99ea	85 36		sta $36				sta 	zTemp0
.99ec	a5 37		lda $37				lda 	zTemp0+1
.99ee	69 00		adc #$00			adc 	#0
.99f0	85 37		sta $37				sta 	zTemp0+1
.99f2	bd 00 04	lda $0400,x			lda 	NSStatus,x
.99f5	20 f0 84	jsr $84f0			jsr 	ScaleByBaseType
.99f8	18		clc				clc
.99f9	b2 3e		lda ($3e)			lda 	(zaTemp)
.99fb	65 36		adc $36				adc 	zTemp0
.99fd	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9a00	a0 01		ldy #$01			ldy 	#1
.9a02	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9a04	65 37		adc $37				adc 	zTemp0+1
.9a06	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9a09	7a		ply				ply 								; restore position
.9a0a	60		rts				rts
.9a0b					_VHBadIndex:
.9a0b	a9 17		lda #$17		lda	#23
.9a0d	4c f1 8d	jmp $8df1		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/abs.asm

.9a10					AbsUnary:
.9a10	fa		plx				plx 								; restore stack pos
.9a11	20 dd 9d	jsr $9ddd			jsr 	EvaluateNumber 				; get a float or int
.9a14	20 d8 8d	jsr $8dd8			jsr 	CheckRightBracket
.9a17	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; clear the sign bit
.9a1a	29 7f		and #$7f			and 	#$7F
.9a1c	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9a1f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/alloc.asm

.9a20					AllocUnary:
.9a20	fa		plx				plx 								; restore stack pos
.9a21	20 15 9e	jsr $9e15			jsr 	Evaluate16BitInteger		; get bytes required.
.9a24	20 d8 8d	jsr $8dd8			jsr 	CheckRightBracket
.9a27	da		phx				phx 								; save X/Y
.9a28	5a		phy				phy
.9a29	8a		txa				txa 								; copy X into Y
.9a2a	a8		tay				tay
.9a2b	b9 10 04	lda $0410,y			lda		NSMantissa1,y 				; get size
.9a2e	aa		tax				tax
.9a2f	b9 08 04	lda $0408,y			lda 	NSMantissa0,y
.9a32	20 3f 9a	jsr $9a3f			jsr 	AllocateXABytes 			; allocate memory
.9a35	99 08 04	sta $0408,y			sta 	NSMantissa0,y 				; write address out.
.9a38	8a		txa				txa
.9a39	99 10 04	sta $0410,y			sta 	NSMantissa1,y
.9a3c	7a		ply				ply
.9a3d	fa		plx				plx
.9a3e	60		rts				rts
.9a3f					AllocateXABytes:
.9a3f	5a		phy				phy
.9a40	ac 8c 04	ldy $048c			ldy 	lowMemPtr 					; push current address on stack and to zTemp0
.9a43	84 36		sty $36				sty 	zTemp0
.9a45	5a		phy				phy
.9a46	ac 8d 04	ldy $048d			ldy 	lowMemPtr+1
.9a49	84 37		sty $37				sty 	zTemp0+1
.9a4b	5a		phy				phy
.9a4c	18		clc				clc 								; add to low memory pointer
.9a4d	6d 8c 04	adc $048c			adc 	lowMemPtr
.9a50	8d 8c 04	sta $048c			sta 	lowMemPtr
.9a53	8a		txa				txa
.9a54	6d 8d 04	adc $048d			adc 	lowMemPtr+1
.9a57	8d 8d 04	sta $048d			sta 	lowMemPtr+1
.9a5a	b0 2f		bcs $9a8b			bcs 	CISSMemory
.9a5c	20 7d 9a	jsr $9a7d			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.9a5f					_ClearMemory:
.9a5f	ad 8c 04	lda $048c			lda 	lowMemPtr 					; cleared all memory allocated
.9a62	c5 36		cmp $36				cmp 	zTemp0
.9a64	d0 07		bne $9a6d			bne 	_CMClearNext
.9a66	ad 8d 04	lda $048d			lda 	lowMemPtr+1
.9a69	c5 37		cmp $37				cmp 	zTemp0+1
.9a6b	f0 0c		beq $9a79			beq 	_CMExit
.9a6d					_CMClearNext:
.9a6d	a9 00		lda #$00			lda 	#0 							; clear byte, advance to next.
.9a6f	92 36		sta ($36)			sta 	(zTemp0)
.9a71	e6 36		inc $36				inc 	zTemp0
.9a73	d0 ea		bne $9a5f			bne 	_ClearMemory
.9a75	e6 37		inc $37				inc		zTemp0+1
.9a77	80 e6		bra $9a5f			bra 	_ClearMemory
.9a79					_CMExit:
.9a79	fa		plx				plx
.9a7a	68		pla				pla
.9a7b	7a		ply				ply
.9a7c	60		rts				rts
.9a7d					CheckIdentifierStringSpace:
.9a7d	48		pha				pha
.9a7e	ad 8d 04	lda $048d			lda 	lowMemPtr+1 				; get low memory pointer
.9a81	18		clc				clc
.9a82	69 02		adc #$02			adc 	#2 							; need at least 2 256 byte pages
.9a84	cd 8f 04	cmp $048f			cmp 	StringMemory+1 				; is it >= StringMemory
.9a87	b0 02		bcs $9a8b			bcs 	CISSMemory
.9a89	68		pla				pla
.9a8a	60		rts				rts
.9a8b					CISSMemory:
.9a8b	a9 06		lda #$06		lda	#6
.9a8d	4c f1 8d	jmp $8df1		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/asc.asm

.9a90					AscUnary:
.9a90	fa		plx				plx 								; restore stack pos
.9a91	20 e8 9d	jsr $9de8			jsr 	EvaluateString 				; get a string
.9a94	b2 36		lda ($36)			lda 	(zTemp0)					; get/return firs character
.9a96	20 b6 9e	jsr $9eb6			jsr 	NSMSetByte
.9a99	20 d8 8d	jsr $8dd8			jsr 	CheckRightBracket
.9a9c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/frac.asm

.9a9d					FracUnary:
.9a9d	fa		plx				plx 								; restore stack pos
.9a9e	20 dd 9d	jsr $9ddd			jsr 	EvaluateNumber 				; get a float or int
.9aa1	20 d8 8d	jsr $8dd8			jsr 	CheckRightBracket
.9aa4	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9aa7	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9aa9	f0 04		beq $9aaf			beq 	_IUZero
.9aab	20 d3 94	jsr $94d3			jsr 	FloatFractionalPart
.9aae	60		rts				rts
.9aaf					_IUZero:
.9aaf	20 b4 9e	jsr $9eb4			jsr 	NSMSetZero
.9ab2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/int.asm

.9ab3					IntUnary:
.9ab3	fa		plx				plx 								; restore stack pos
.9ab4	20 dd 9d	jsr $9ddd			jsr 	EvaluateNumber 				; get a float or int
.9ab7	20 d8 8d	jsr $8dd8			jsr 	CheckRightBracket
.9aba	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9abd	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9abf	f0 03		beq $9ac4			beq 	_IUExit
.9ac1	20 36 95	jsr $9536			jsr 	FloatIntegerPart
.9ac4					_IUExit:
.9ac4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/len.asm

.9ac5					LenUnary:
.9ac5	fa		plx				plx 								; restore stack pos
.9ac6	20 e8 9d	jsr $9de8			jsr 	EvaluateString 				; get a string
.9ac9	5a		phy				phy
.9aca	a0 00		ldy #$00			ldy 	#0 							; find length
.9acc					_LenFind:
.9acc	b1 36		lda ($36),y			lda 	(zTemp0),y
.9ace	f0 06		beq $9ad6			beq 	_LenExit
.9ad0	c8		iny				iny
.9ad1	d0 f9		bne $9acc			bne 	_LenFind
.9ad3	4c 43 a0	jmp $a043			jmp 	RangeError 					; string > 255
.9ad6					_LenExit:
.9ad6	98		tya				tya
.9ad7	20 b6 9e	jsr $9eb6			jsr 	NSMSetByte
.9ada	7a		ply				ply
.9adb	20 d8 8d	jsr $8dd8			jsr 	CheckRightBracket
.9ade	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/minmax.asm

.9adf					Unary_Min:
.9adf	a9 01		lda #$01			lda 	#1
.9ae1	80 02		bra $9ae5			bra 	UnaryMinMaxMain
.9ae3					Unary_Max:
.9ae3	a9 ff		lda #$ff			lda 	#$FF 						; value from comparator to cause a write
.9ae5					UnaryMinMaxMain:
.9ae5	fa		plx				plx 								; get index on number stack
.9ae6	48		pha				pha 								; save comparator
.9ae7	20 d4 9d	jsr $9dd4			jsr 	EvaluateValue 				; get the first value.
.9aea					_UMMMLoop:
.9aea	b1 30		lda ($30),y			lda 	(codePtr),y
.9aec	c9 29		cmp #$29			cmp 	#KWD_RPAREN 				; if right bracket then done.
.9aee	f0 22		beq $9b12			beq 	_UMMMDone
.9af0	20 e0 8d	jsr $8de0			jsr 	CheckComma 					; must be a comma
.9af3	e8		inx				inx
.9af4	20 d4 9d	jsr $9dd4			jsr 	EvaluateValue
.9af7	ca		dex				dex
.9af8	20 8b 9e	jsr $9e8b			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] (Compare is destructive)
.9afb	e8		inx				inx
.9afc	20 8b 9e	jsr $9e8b			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2], original
.9aff	e8		inx				inx
.9b00	20 a9 8e	jsr $8ea9			jsr 	CompareBaseCode 			; part of > = < etc. code, returns 255,0 or 1
.9b03	ca		dex				dex
.9b04	ca		dex				dex
.9b05	85 36		sta $36				sta 	zTemp0 						; save required result
.9b07	68		pla				pla 								; get and save comparator
.9b08	48		pha				pha
.9b09	c5 36		cmp $36				cmp 	zTemp0 						; if the comparator
.9b0b	d0 dd		bne $9aea			bne 	_UMMMLoop
.9b0d	20 15 9b	jsr $9b15			jsr 	ExpCopyAboveDown 			; copy next up slot down
.9b10	80 d8		bra $9aea			bra 	_UMMMLoop
.9b12					_UMMMDone:
.9b12	68		pla				pla 								; throw the comparator
.9b13	c8		iny				iny 								; skip )
.9b14	60		rts				rts
.9b15					ExpCopyAboveDown:
.9b15	bd 01 04	lda $0401,x			lda 	NSStatus+1,x
.9b18	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9b1b	bd 29 04	lda $0429,x			lda 	NSExponent+1,x
.9b1e	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9b21	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.9b24	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9b27	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.9b2a	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9b2d	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.9b30	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9b33	bd 21 04	lda $0421,x			lda 	NSMantissa3+1,x
.9b36	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9b39	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/not.asm

.9b3a					Unary_Not:
.9b3a	fa		plx				plx
.9b3b	20 00 9e	jsr $9e00			jsr 	EvaluateInteger 			; get integer
.9b3e	20 d8 8d	jsr $8dd8			jsr 	CheckRightBracket
.9b41	20 e4 9e	jsr $9ee4			jsr 	NSMIsZero 					; zero mantissa ?
.9b44	f0 04		beq $9b4a			beq 	_NotZero
.9b46	20 b4 9e	jsr $9eb4			jsr 	NSMSetZero
.9b49	60		rts				rts
.9b4a					_NotZero:
.9b4a	4c 5e 8e	jmp $8e5e			jmp 	ReturnTrue
.9b4d					_UNBad:
.9b4d	4c 4d a0	jmp $a04d			jmp 	ArgumentError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/rnd.asm

.9b50					Unary_Random:
.9b50	fa		plx				plx
.9b51	20 cf 9b	jsr $9bcf			jsr 	Random32Bit 				; get a random number
.9b54	20 b4 9b	jsr $9bb4			jsr 	URCopyToMantissa  			; put in mantissa
.9b57	b1 30		lda ($30),y			lda 	(codePtr),y
.9b59	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.9b5b	f0 08		beq $9b65			beq 	_URNoModulus
.9b5d	e8		inx				inx
.9b5e	20 15 9e	jsr $9e15			jsr 	Evaluate16BitInteger 		; put modulus value in +1
.9b61	ca		dex				dex
.9b62	20 cd 8f	jsr $8fcd			jsr 	IntegerModulusNoCheck 		; calculate modulus
.9b65					_URNoModulus:
.9b65	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; make it an integer positive
.9b68	9e 28 04	stz $0428,x			stz 	NSExponent,x
.9b6b	20 d8 8d	jsr $8dd8			jsr 	CheckRightBracket
.9b6e	60		rts				rts
.9b6f					Unary_Rnd:
.9b6f	fa		plx				plx
.9b70	20 dd 9d	jsr $9ddd			jsr 	EvaluateNumber 				; number to use.
.9b73	20 d8 8d	jsr $8dd8			jsr 	CheckRightBracket 			; closing bracket
.9b76	20 e4 9e	jsr $9ee4			jsr 	NSMIsZero 					; if zero, then don't generate a new number
.9b79	f0 2b		beq $9ba6			beq 	_URCopySeed
.9b7b	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; if -ve, then seed using parameter
.9b7e	10 23		bpl $9ba3			bpl 	_URDontSeed
.9b80	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy - value to seed butchering it.
.9b83	49 17		eor #$17			eor 	#$17
.9b85	8d 88 04	sta $0488			sta 	RandomSeed+0
.9b88	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9b8b	49 a5		eor #$a5			eor 	#$A5
.9b8d	8d 89 04	sta $0489			sta 	RandomSeed+1
.9b90	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9b93	49 c2		eor #$c2			eor 	#$C2
.9b95	8d 8a 04	sta $048a			sta 	RandomSeed+2
.9b98	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9b9b	49 9d		eor #$9d			eor 	#$9D
.9b9d	8d 8b 04	sta $048b			sta 	RandomSeed+3
.9ba0	20 cf 9b	jsr $9bcf			jsr 	Random32Bit
.9ba3					_URDontSeed:
.9ba3	20 cf 9b	jsr $9bcf			jsr 	Random32Bit 				; generate a number.
.9ba6					_URCopySeed:
.9ba6	20 b4 9b	jsr $9bb4			jsr 	URCopyToMantissa 			; copy into mantissa
.9ba9	a9 e2		lda #$e2			lda 	#-30 						; force into 0-1 range
.9bab	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9bae	a9 08		lda #$08			lda 	#NSTFloat
.9bb0	9d 00 04	sta $0400,x			sta 	NSStatus,x 					; positive.
.9bb3	60		rts				rts
.9bb4					URCopyToMantissa:
.9bb4	ad 88 04	lda $0488			lda 	RandomSeed+0
.9bb7	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9bba	ad 89 04	lda $0489			lda 	RandomSeed+1
.9bbd	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9bc0	ad 8a 04	lda $048a			lda 	RandomSeed+2
.9bc3	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9bc6	ad 8b 04	lda $048b			lda 	RandomSeed+3
.9bc9	29 3f		and #$3f			and 	#$3F 						; make legal mantissa
.9bcb	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9bce	60		rts				rts
.9bcf					Random32Bit:
.9bcf	5a		phy				phy
.9bd0	a0 07		ldy #$07			ldy 	#7 							; do it 7 times
.9bd2	ad 88 04	lda $0488			lda 	RandomSeed+0 				; check the seed isn't zero
.9bd5	d0 03		bne $9bda			bne 	_Random1
.9bd7	a8		tay				tay 								; if so do it 256 times
.9bd8	a9 aa		lda #$aa			lda		#$AA 						; and use this to seed the seed....
.9bda					_Random1:
.9bda	0a		asl a				asl 	a 							; LSFR RNG
.9bdb	2e 89 04	rol $0489			rol 	RandomSeed+1
.9bde	2e 8a 04	rol $048a			rol 	RandomSeed+2
.9be1	2e 8b 04	rol $048b			rol 	RandomSeed+3
.9be4	90 02		bcc $9be8			bcc 	_Random2
.9be6	49 c5		eor #$c5			eor 	#$C5
.9be8					_Random2:
.9be8	88		dey				dey
.9be9	d0 ef		bne $9bda			bne 	_Random1
.9beb	8d 88 04	sta $0488			sta 	RandomSeed+0
.9bee	7a		ply				ply
.9bef	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/sgn.asm

.9bf0					SgnUnary:
.9bf0	fa		plx				plx 								; restore stack pos
.9bf1	20 dd 9d	jsr $9ddd			jsr 	EvaluateNumber 				; get a float or int
.9bf4	20 d8 8d	jsr $8dd8			jsr 	CheckRightBracket
.9bf7	20 e4 9e	jsr $9ee4			jsr 	NSMIsZero 					; if zero
.9bfa	f0 10		beq $9c0c			beq 	_SGZero  					; return Int Zero
.9bfc	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get status w/sign
.9bff	48		pha				pha
.9c00	a9 01		lda #$01			lda 	#1 							; set to 1
.9c02	20 b6 9e	jsr $9eb6			jsr 	NSMSetByte
.9c05	68		pla				pla
.9c06	29 80		and #$80			and		#$80 						; copy the sign byte out
.9c08	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9c0b	60		rts				rts
.9c0c	20 b4 9e	jsr $9eb4	_SGZero:jsr 	NSMSetZero
.9c0f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/val.asm

.9c10					ValUnary:
.9c10	fa		plx				plx 								; restore stack pos
.9c11	20 26 9c	jsr $9c26			jsr 	ValMainCode 				; do the main val() code
.9c14	b0 01		bcs $9c17			bcs 	_VUError 					; couldn't convert
.9c16	60		rts				rts
.9c17					_VUError:
.9c17	4c 48 a0	jmp $a048			jmp 	TypeError
.9c1a					IsValUnary:
.9c1a	fa		plx				plx 								; restore stack pos
.9c1b	20 26 9c	jsr $9c26			jsr 	ValMainCode 				; do the main val() code
.9c1e	b0 03		bcs $9c23			bcs 	_VUBad
.9c20	4c 5e 8e	jmp $8e5e			jmp 	ReturnTrue
.9c23					_VUBad:
.9c23	4c 6a 8e	jmp $8e6a			jmp 	ReturnFalse
.9c26					ValMainCode:
.9c26	20 e8 9d	jsr $9de8			jsr 	EvaluateString 				; get a string
.9c29	20 d8 8d	jsr $8dd8			jsr 	CheckRightBracket 			; check right bracket present
.9c2c					ValEvaluateZTemp0:
.9c2c	5a		phy				phy
.9c2d	b2 36		lda ($36)			lda 	(zTemp0) 					; check not empty string
.9c2f	f0 17		beq $9c48			beq 	_VMCFail2
.9c31	a0 ff		ldy #$ff			ldy 	#$FF 						; start position
.9c33	48		pha				pha 								; save first character
.9c34	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it -
.9c36	d0 01		bne $9c39			bne 	_VMCStart
.9c38	c8		iny				iny 								; skip over -
.9c39					_VMCStart:
.9c39	38		sec				sec 								; initialise first time round.
.9c3a					_VMCNext:
.9c3a	c8		iny				iny 								; pre-increment
.9c3b	b1 36		lda ($36),y			lda 	(zTemp0),y 					; next character
.9c3d	f0 0c		beq $9c4b			beq 	_VMCSuccess 				; successful.
.9c3f	20 5c 97	jsr $975c			jsr 	EncodeNumber 				; send it to the number-builder
.9c42	90 03		bcc $9c47			bcc 	_VMCFail 					; if failed, give up.
.9c44	18		clc				clc 								; next time round, countinue
.9c45	80 f3		bra $9c3a			bra 	_VMCNext
.9c47					_VMCFail:
.9c47	68		pla				pla
.9c48					_VMCFail2:
.9c48	7a		ply				ply
.9c49	38		sec				sec
.9c4a	60		rts				rts
.9c4b					_VMCSuccess:
.9c4b	a9 00		lda #$00			lda 	#0 							; construct final
.9c4d	20 5c 97	jsr $975c			jsr 	EncodeNumber
.9c50	68		pla				pla
.9c51	c9 2d		cmp #$2d			cmp 	#"-"
.9c53	d0 03		bne $9c58			bne 	_VMCNotNegative
.9c55	20 60 9e	jsr $9e60			jsr		NSMNegate
.9c58					_VMCNotNegative:
.9c58	7a		ply				ply
.9c59	18		clc				clc
.9c5a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/chr.asm

.9c5b					ChrUnary:
.9c5b	fa		plx				plx 								; restore stack pos
.9c5c	20 35 9e	jsr $9e35			jsr 	Evaluate8BitInteger			; get value
.9c5f	48		pha				pha
.9c60	20 d8 8d	jsr $8dd8			jsr 	CheckRightBracket
.9c63	a9 01		lda #$01			lda 	#1 							; allocate space for one char
.9c65	20 1d a8	jsr $a81d			jsr 	StringTempAllocate
.9c68	68		pla				pla 								; write number to it
.9c69	20 5b a8	jsr $a85b			jsr 	StringTempWrite
.9c6c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/spc.asm

.9c6d					SpcUnary:
.9c6d	fa		plx				plx 								; restore stack pos
.9c6e	20 35 9e	jsr $9e35			jsr 	Evaluate8BitInteger			; get value
.9c71	5a		phy				phy
.9c72	48		pha				pha 								; save count
.9c73	20 1d a8	jsr $a81d			jsr 	StringTempAllocate
.9c76	7a		ply				ply 								; to do count in Y
.9c77					_SpcLoop:
.9c77	c0 00		cpy #$00			cpy 	#0
.9c79	f0 08		beq $9c83			beq 	_SpcExit
.9c7b	a9 20		lda #$20			lda 	#32
.9c7d	20 5b a8	jsr $a85b			jsr 	StringTempWrite
.9c80	88		dey				dey
.9c81	80 f4		bra $9c77			bra 	_SPCLoop
.9c83					_SpcExit:
.9c83	7a		ply				ply
.9c84	20 d8 8d	jsr $8dd8			jsr 	CheckRightBracket
.9c87	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/str.asm

.9c88					Unary_Str:
.9c88	fa		plx				plx
.9c89	20 dd 9d	jsr $9ddd			jsr 	EvaluateNumber  			; get number
.9c8c	20 d8 8d	jsr $8dd8			jsr 	CheckRightBracket 			; closing bracket
.9c8f	a9 05		lda #$05			lda 	#5 							; maximum decimals, from Basic816
.9c91	20 aa 9c	jsr $9caa			jsr 	ConvertNumberToString 		; do the conversion.
.9c94	a9 21		lda #$21			lda		#33 						; create buffer
.9c96	20 1d a8	jsr $a81d			jsr 	StringTempAllocate 			; allocate memory
.9c99	da		phx				phx
.9c9a	a2 00		ldx #$00			ldx 	#0
.9c9c					_USCopy:
.9c9c	bd 1c 06	lda $061c,x			lda 	DecimalBuffer,x
.9c9f	20 5b a8	jsr $a85b			jsr 	StringTempWrite
.9ca2	e8		inx				inx
.9ca3	bd 1c 06	lda $061c,x			lda 	DecimalBuffer,x
.9ca6	d0 f4		bne $9c9c			bne 	_USCopy
.9ca8	fa		plx				plx
.9ca9	60		rts				rts
.9caa					ConvertNumberToString:
.9caa	5a		phy				phy 								; save code position
.9cab	8d 94 04	sta $0494			sta 	DecimalPlaces	 			; save number of DPs.
.9cae	9c 95 04	stz $0495			stz 	dbOffset 					; offset into decimal buffer = start.
.9cb1	bd 00 04	lda $0400,x			lda 	NSStatus,x  				; is it -ve.
.9cb4	10 0a		bpl $9cc0			bpl 	_CNTSNotNegative
.9cb6	29 7f		and #$7f			and 	#$7F 						; make +ve
.9cb8	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9cbb	a9 2d		lda #$2d			lda 	#"-"
.9cbd	20 26 9d	jsr $9d26			jsr 	WriteDecimalBuffer
.9cc0					_CNTSNotNegative:
.9cc0	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if decimal
.9cc3	f0 15		beq $9cda			beq 	_CNTSNotFloat
.9cc5	e8		inx				inx 								; round up
.9cc6	a9 01		lda #$01			lda 	#1
.9cc8	20 b6 9e	jsr $9eb6			jsr 	NSMSetByte
.9ccb	ca		dex				dex
.9ccc	bd 28 04	lda $0428,x			lda		NSExponent,x
.9ccf	9d 29 04	sta $0429,x			sta 	NSExponent+1,x
.9cd2	a9 08		lda #$08			lda 	#NSTFloat
.9cd4	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.9cd7	20 ed 93	jsr $93ed			jsr 	FloatAdd
.9cda					_CNTSNotFloat:
.9cda	20 08 9d	jsr $9d08			jsr 	MakePlusTwoString
.9cdd	20 d3 94	jsr $94d3			jsr 	FloatFractionalPart 		; get the fractional part
.9ce0	20 97 95	jsr $9597			jsr 	NSNormalise					; normalise , exit if zero
.9ce3	f0 21		beq $9d06			beq 	_CNTSExit
.9ce5	a9 2e		lda #$2e			lda 	#"."
.9ce7	20 26 9d	jsr $9d26			jsr 	WriteDecimalBuffer 			; write decimal place
.9cea					_CNTSDecimal:
.9cea	ce 94 04	dec $0494			dec 	DecimalPlaces 				; done all the decimals
.9ced	30 17		bmi $9d06			bmi 	_CNTSExit
.9cef	e8		inx				inx 								; x 10.0
.9cf0	a9 0a		lda #$0a			lda 	#10
.9cf2	20 b6 9e	jsr $9eb6			jsr 	NSMSetByte
.9cf5	a9 08		lda #$08			lda 	#NSTFloat
.9cf7	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9cfa	ca		dex				dex
.9cfb	20 60 95	jsr $9560			jsr 	FloatMultiply
.9cfe	20 08 9d	jsr $9d08			jsr 	MakePlusTwoString
.9d01	20 d3 94	jsr $94d3			jsr 	FloatFractionalPart 		; get the fractional part
.9d04	80 e4		bra $9cea			bra 	_CNTSDecimal 				; keep going.
.9d06					_CNTSExit:
.9d06	7a		ply				ply
.9d07	60		rts				rts
.9d08					MakePlusTwoString:
.9d08	da		phx				phx
.9d09	20 8b 9e	jsr $9e8b			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.9d0c	e8		inx				inx 								; access it
.9d0d	e8		inx				inx
.9d0e	20 36 95	jsr $9536			jsr 	FloatIntegerPart 			; make it an integer
.9d11	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.9d13	20 18 93	jsr $9318			jsr 	ConvertInt32
.9d16	a2 00		ldx #$00			ldx	 	#0
.9d18					_MPTSCopy:
.9d18	bd fa 05	lda $05fa,x			lda 	NumberBuffer,x
.9d1b	20 26 9d	jsr $9d26			jsr 	WriteDecimalBuffer
.9d1e	e8		inx				inx
.9d1f	bd fa 05	lda $05fa,x			lda 	NumberBuffer,x
.9d22	d0 f4		bne $9d18			bne 	_MPTSCopy
.9d24	fa		plx				plx
.9d25	60		rts				rts
.9d26					WriteDecimalBuffer:
.9d26	da		phx				phx
.9d27	ae 95 04	ldx $0495			ldx 	dbOffset
.9d2a	9d 1c 06	sta $061c,x			sta 	DecimalBuffer,x
.9d2d	9e 1d 06	stz $061d,x			stz 	DecimalBuffer+1,x
.9d30	ee 95 04	inc $0495			inc 	dbOffset
.9d33	fa		plx				plx
.9d34	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/substring.asm

.9d35					Unary_Left:
.9d35	fa		plx				plx
.9d36	18		clc				clc 								; only one parameter
.9d37	20 ac 9d	jsr $9dac			jsr 	SubstringInitial 			; set up.
.9d3a	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; Param #1 is the length
.9d3d	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9d40	9e 09 04	stz $0409,x			stz 	NSMantissa0+1,x 			; Start is zero.
.9d43	80 2c		bra $9d71			bra 	SubstringMain
.9d45					Unary_Right:
.9d45	fa		plx				plx
.9d46	18		clc				clc 								; only one parameter
.9d47	20 ac 9d	jsr $9dac			jsr 	SubstringInitial 			; set up.
.9d4a	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; length => param 2
.9d4d	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9d50	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; total length
.9d53	fd 09 04	sbc $0409,x			sbc 	NSMantissa0+1,x 			; length - required.
.9d56	b0 02		bcs $9d5a			bcs 	_URNotUnderflow
.9d58	a9 00		lda #$00			lda 	#0 							; start from the beginning, as something like right$("AB",3)
.9d5a					_URNotUnderFlow:
.9d5a	9d 09 04	sta $0409,x			sta 	NSMantissa0+1,x 			; this is the start position
.9d5d	80 12		bra $9d71			bra 	SubStringMain
.9d5f					Unary_Mid:
.9d5f	fa		plx				plx
.9d60	38		sec				sec 								; two parameters
.9d61	20 ac 9d	jsr $9dac			jsr 	SubstringInitial 			; set up.
.9d64	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; first parameter is zero ?
.9d67	f0 05		beq $9d6e			beq 	_UMError
.9d69	de 09 04	dec $0409,x			dec 	NSMantissa0+1,x				; reduce initial offset by 1 as MID$(a$,1..) is actually the first character
.9d6c	80 03		bra $9d71			bra 	SubStringMain
.9d6e					_UMError:
.9d6e	4c 4d a0	jmp $a04d			jmp 	ArgumentError
.9d71					SubStringMain:
.9d71	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; is the initial offset >= the length
.9d74	dd 28 04	cmp $0428,x			cmp 	NSExponent,x
.9d77	b0 2d		bcs $9da6			bcs 	_SSMNull 					; if so, return an empty string.
.9d79	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; if copy count is zero
.9d7c	f0 28		beq $9da6			beq 	_SSMNull 					; return empty string.
.9d7e	18		clc				clc 								; add the offset +1 to the address and
.9d7f	bd 08 04	lda $0408,x			lda	 	NSMantissa0,x 				; put in zTemp
.9d82	7d 09 04	adc $0409,x			adc 	NSMantissa0+1,x
.9d85	85 36		sta $36				sta 	zTemp0
.9d87	bd 10 04	lda $0410,x			lda	 	NSMantissa1,x
.9d8a	69 00		adc #$00			adc 	#0
.9d8c	85 37		sta $37				sta 	zTemp0+1
.9d8e					_SSMNoCarry:
.9d8e	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; characters required.
.9d91	20 1d a8	jsr $a81d			jsr 	StringTempAllocate 			; allocate that many characters
.9d94	5a		phy				phy 								; save Y
.9d95	a0 00		ldy #$00			ldy 	#0 							; start copying in.
.9d97					_SSMCopy:
.9d97	b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next character
.9d99	f0 09		beq $9da4			beq 	_SSMEString 				; no more to copy
.9d9b	20 5b a8	jsr $a85b			jsr 	StringTempWrite 			; and write it out.
.9d9e	c8		iny				iny
.9d9f	de 0a 04	dec $040a,x			dec 	NSMantissa0+2,x
.9da2	d0 f3		bne $9d97			bne 	_SSMCopy
.9da4					_SSMEString:
.9da4	7a		ply				ply
.9da5					_SSMExit:
.9da5	60		rts				rts
.9da6					_SSMNull:
.9da6	a9 00		lda #$00			lda 	#0
.9da8	20 1d a8	jsr $a81d			jsr 	StringTempAllocate
.9dab	60		rts				rts
.9dac					SubstringInitial:
.9dac	da		phx				phx 								; save initial stack position
.9dad	08		php				php 								; save carry on stack indicating 2 parameters
.9dae	20 e8 9d	jsr $9de8			jsr 	EvaluateString 				; get a string
.9db1	5a		phy				phy 								; calculate length to exponent.
.9db2	a0 ff		ldy #$ff			ldy 	#$FF
.9db4					_SIFindLength:
.9db4	c8		iny				iny
.9db5	b1 36		lda ($36),y			lda 	(zTemp0),y
.9db7	d0 fb		bne $9db4			bne 	_SIFindLength
.9db9	98		tya				tya
.9dba	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9dbd	7a		ply				ply
.9dbe	e8		inx				inx
.9dbf	20 e0 8d	jsr $8de0			jsr 	CheckComma 					; comma next
.9dc2	20 35 9e	jsr $9e35			jsr 	Evaluate8BitInteger 		; get next parameter
.9dc5	28		plp				plp 								; is it the last parameter ?
.9dc6	90 07		bcc $9dcf			bcc 	_SSIExit 					; if so, exit.
.9dc8	e8		inx				inx
.9dc9	20 e0 8d	jsr $8de0			jsr 	CheckComma 					; comma next
.9dcc	20 35 9e	jsr $9e35			jsr 	Evaluate8BitInteger 		; get last parameter
.9dcf					_SSIExit:
.9dcf	fa		plx				plx
.9dd0	20 d8 8d	jsr $8dd8			jsr 	CheckRightBracket 			; check closing bracket
.9dd3	60		rts				rts 								; exit

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/exprhelper.asm

.9dd4					EvaluateValue:
.9dd4	48		pha				pha
.9dd5	20 a0 93	jsr $93a0			jsr		EvaluateExpression 			; expression
.9dd8	20 be 96	jsr $96be			jsr 	Dereference					; derefernce it
.9ddb	68		pla				pla
.9ddc	60		rts				rts
.9ddd					EvaluateNumber:
.9ddd	20 d4 9d	jsr $9dd4			jsr 	EvaluateValue 				; get a value
.9de0	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if string.
.9de3	29 10		and #$10			and 	#NSBIsString
.9de5	d0 16		bne $9dfd			bne 	HelperTypeError
.9de7	60		rts				rts
.9de8					EvaluateString:
.9de8	20 d4 9d	jsr $9dd4			jsr 	EvaluateValue 				; get a value
.9deb	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if string.
.9dee	29 10		and #$10			and 	#NSBIsString
.9df0	f0 0b		beq $9dfd			beq 	HelperTypeError
.9df2					CopyAddressToTemp0:
.9df2	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address -> zTemp0
.9df5	85 36		sta $36				sta 	zTemp0
.9df7	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9dfa	85 37		sta $37				sta 	zTemp0+1
.9dfc	60		rts				rts
.9dfd					HelperTypeError:
.9dfd	4c 48 a0	jmp $a048			jmp 	TypeError
.9e00					EvaluateInteger:
.9e00	20 dd 9d	jsr $9ddd			jsr 	EvaluateNumber
.9e03	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check exponent is zero
.9e06	d0 0a		bne $9e12			bne 	HelperValueError 			; if not, it's a float.
.9e08	60		rts				rts
.9e09					EvaluateUnsignedInteger:
.9e09	20 00 9e	jsr $9e00			jsr 	EvaluateInteger 			; check integer is +ve
.9e0c	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9e0f	30 01		bmi $9e12			bmi 	HelperValueError
.9e11	60		rts				rts
.9e12					HelperValueError:
.9e12	4c 4d a0	jmp $a04d			jmp 	ArgumentError
.9e15					Evaluate16BitInteger:
.9e15	20 09 9e	jsr $9e09			jsr	 	EvaluateUnsignedInteger		; get integer
.9e18	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9e1b	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9e1e	d0 f2		bne $9e12			bne 	HelperValueError
.9e20	60		rts				rts
.9e21					Evaluate16BitIntegerSigned:
.9e21	20 00 9e	jsr $9e00			jsr	 	EvaluateInteger				; get integer
.9e24	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9e27	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9e2a	d0 e6		bne $9e12			bne 	HelperValueError
.9e2c	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; signed ?
.9e2f	10 03		bpl $9e34			bpl 	_EISNotSigned
.9e31	20 69 9e	jsr $9e69			jsr 	NSMNegateMantissa
.9e34					_EISNotSigned:
.9e34	60		rts				rts
.9e35					Evaluate8BitInteger:
.9e35	20 09 9e	jsr $9e09			jsr	 	EvaluateUnsignedInteger 	; get an integer
.9e38	d0 d8		bne $9e12			bne 	HelperValueError
.9e3a	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 1, 2 & 3 must be zero
.9e3d	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9e40	1d 10 04	ora $0410,x			ora 	NSMantissa1,x
.9e43	d0 cd		bne $9e12			bne 	HelperValueError
.9e45	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9e48	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/mult8x8.asm

.9e49					Multiply8x8:
.9e49	4a		lsr a		  		lsr 	a  							; prime the carry bit for the loop
.9e4a	85 36		sta $36			  	sta 	zTemp0
.9e4c	86 37		stx $37				stx 	zTemp0+1
.9e4e	a9 00		lda #$00			lda 	#0
.9e50	a2 08		ldx #$08			ldx 	#8
.9e52					_M88Loop:
.9e52	90 03		bcc $9e57			bcc 	_M88NoAdd
.9e54	18		clc				clc
.9e55	65 37		adc $37				adc 	zTemp0+1
.9e57					_M88NoAdd:
.9e57	6a		ror a				ror 	a
.9e58	66 36		ror $36				ror 	zTemp0  					; pull another bit out for the next iteration
.9e5a	ca		dex				dex         						; inc/dec don't modify carry; only shifts and adds do
.9e5b	d0 f5		bne $9e52			bne 	_M88Loop
.9e5d	85 37		sta $37				sta 	zTemp0+1 					; store high 8 bits.
.9e5f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/utility.asm

.9e60					NSMNegate:
.9e60	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9e63	49 80		eor #$80			eor 	#NSBIsNegative
.9e65	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9e68	60		rts				rts
.9e69					NSMNegateMantissa:
.9e69	38		sec				sec
.9e6a	a9 00		lda #$00			lda 	#0
.9e6c	fd 08 04	sbc $0408,x			sbc 	NSMantissa0,x
.9e6f	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9e72	a9 00		lda #$00			lda 	#0
.9e74	fd 10 04	sbc $0410,x			sbc 	NSMantissa1,x
.9e77	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9e7a	a9 00		lda #$00			lda 	#0
.9e7c	fd 18 04	sbc $0418,x			sbc 	NSMantissa2,x
.9e7f	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9e82	a9 00		lda #$00			lda 	#0
.9e84	fd 20 04	sbc $0420,x			sbc 	NSMantissa3,x
.9e87	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9e8a	60		rts				rts
.9e8b					NSMShiftUpTwo:
.9e8b	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9e8e	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9e91	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9e94	9d 12 04	sta $0412,x			sta 	NSMantissa1+2,x
.9e97	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9e9a	9d 1a 04	sta $041a,x			sta 	NSMantissa2+2,x
.9e9d	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9ea0	9d 22 04	sta $0422,x			sta 	NSMantissa3+2,x
.9ea3	bd 28 04	lda $0428,x			lda 	NSExponent,x
.9ea6	9d 2a 04	sta $042a,x			sta 	NSExponent+2,x
.9ea9	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9eac	9d 02 04	sta $0402,x			sta 	NSStatus+2,x
.9eaf	60		rts				rts
.9eb0					NSMSetZeroMantissaOnly:
.9eb0	a9 00		lda #$00			lda 	#0
.9eb2	80 08		bra $9ebc			bra 	NSMSetMantissa
.9eb4					NSMSetZero:
.9eb4	a9 00		lda #$00			lda 	#0
.9eb6					NSMSetByte:
.9eb6	9e 28 04	stz $0428,x			stz 	NSExponent,x 				; zero exponent, as integer.
.9eb9	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; status zero (integer)
.9ebc					NSMSetMantissa:
.9ebc	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; mantissa
.9ebf	9e 10 04	stz $0410,x			stz 	NSMantissa1,x
.9ec2	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.9ec5	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.9ec8	60		rts				rts
.9ec9					NSMShiftLeft:
.9ec9	18		clc				clc
.9eca					NSMRotateLeft:
.9eca	3e 08 04	rol $0408,x			rol 	NSMantissa0,x
.9ecd	3e 10 04	rol $0410,x			rol		NSMantissa1,x
.9ed0	3e 18 04	rol $0418,x			rol		NSMantissa2,x
.9ed3	3e 20 04	rol $0420,x			rol		NSMantissa3,x
.9ed6	60		rts				rts
.9ed7					NSMShiftRight:
.9ed7	5e 20 04	lsr $0420,x			lsr 	NSMantissa3,x
.9eda	7e 18 04	ror $0418,x			ror		NSMantissa2,x
.9edd	7e 10 04	ror $0410,x			ror		NSMantissa1,x
.9ee0	7e 08 04	ror $0408,x			ror		NSMantissa0,x
.9ee3	60		rts				rts
.9ee4					NSMIsZero:
.9ee4	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9ee7	1d 18 04	ora $0418,x			ora		NSMantissa2,x
.9eea	1d 10 04	ora $0410,x			ora		NSMantissa1,x
.9eed	1d 08 04	ora $0408,x			ora		NSMantissa0,x
.9ef0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.asm

.ba85					TickHandler:
.ba85	5a		phy				phy 								; need to preserve Y
.ba86	20 2b ba	jsr $ba2b			jsr 	SNDUpdate 					; update sound
.ba89	7a		ply				ply
.ba8a	60		rts				rts
.062e					LastTick:
>062e							.fill 		1

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/asmcore.asm

.9ef1					Assemble_ora:
.9ef1	20 6c 80	jsr $806c		jsr	AssembleGroup1
>9ef4	01					.byte $01
.9ef5					Assemble_and:
.9ef5	20 6c 80	jsr $806c		jsr	AssembleGroup1
>9ef8	21					.byte $21
.9ef9					Assemble_eor:
.9ef9	20 6c 80	jsr $806c		jsr	AssembleGroup1
>9efc	41					.byte $41
.9efd					Assemble_adc:
.9efd	20 6c 80	jsr $806c		jsr	AssembleGroup1
>9f00	61					.byte $61
.9f01					Assemble_sta:
.9f01	20 6c 80	jsr $806c		jsr	AssembleGroup1
>9f04	81					.byte $81
.9f05					Assemble_lda:
.9f05	20 6c 80	jsr $806c		jsr	AssembleGroup1
>9f08	a1					.byte $a1
.9f09					Assemble_cmp:
.9f09	20 6c 80	jsr $806c		jsr	AssembleGroup1
>9f0c	c1					.byte $c1
.9f0d					Assemble_sbc:
.9f0d	20 6c 80	jsr $806c		jsr	AssembleGroup1
>9f10	e1					.byte $e1
.9f11					Assemble_asl:
.9f11	20 73 80	jsr $8073		jsr	AssembleGroup2
>9f14	02					.byte $02
>9f15	75					.byte $75
.9f16					Assemble_rol:
.9f16	20 73 80	jsr $8073		jsr	AssembleGroup2
>9f19	22					.byte $22
>9f1a	75					.byte $75
.9f1b					Assemble_lsr:
.9f1b	20 73 80	jsr $8073		jsr	AssembleGroup2
>9f1e	42					.byte $42
>9f1f	75					.byte $75
.9f20					Assemble_ror:
.9f20	20 73 80	jsr $8073		jsr	AssembleGroup2
>9f23	62					.byte $62
>9f24	75					.byte $75
.9f25					Assemble_stx:
.9f25	20 73 80	jsr $8073		jsr	AssembleGroup2
>9f28	82					.byte $82
>9f29	50					.byte $50
.9f2a					Assemble_ldx:
.9f2a	20 73 80	jsr $8073		jsr	AssembleGroup2
>9f2d	a2					.byte $a2
>9f2e	d0					.byte $d0
.9f2f					Assemble_dec:
.9f2f	20 73 80	jsr $8073		jsr	AssembleGroup2
>9f32	c2					.byte $c2
>9f33	55					.byte $55
.9f34					Assemble_inc:
.9f34	20 73 80	jsr $8073		jsr	AssembleGroup2
>9f37	e2					.byte $e2
>9f38	55					.byte $55
.9f39					Assemble_stz:
.9f39	20 73 80	jsr $8073		jsr	AssembleGroup2
>9f3c	60					.byte $60
>9f3d	44					.byte $44
.9f3e					Assemble_bit:
.9f3e	20 73 80	jsr $8073		jsr	AssembleGroup2
>9f41	20					.byte $20
>9f42	55					.byte $55
.9f43					Assemble_sty:
.9f43	20 73 80	jsr $8073		jsr	AssembleGroup2
>9f46	80					.byte $80
>9f47	54					.byte $54
.9f48					Assemble_ldy:
.9f48	20 73 80	jsr $8073		jsr	AssembleGroup2
>9f4b	a0					.byte $a0
>9f4c	d5					.byte $d5
.9f4d					Assemble_cpy:
.9f4d	20 73 80	jsr $8073		jsr	AssembleGroup2
>9f50	c0					.byte $c0
>9f51	d4					.byte $d4
.9f52					Assemble_cpx:
.9f52	20 73 80	jsr $8073		jsr	AssembleGroup2
>9f55	e0					.byte $e0
>9f56	d0					.byte $d0
.9f57					Assemble_tsb:
.9f57	20 73 80	jsr $8073		jsr	AssembleGroup2
>9f5a	00					.byte $00
>9f5b	50					.byte $50
.9f5c					Assemble_trb:
.9f5c	20 73 80	jsr $8073		jsr	AssembleGroup2
>9f5f	10					.byte $10
>9f60	50					.byte $50
.9f61					Assemble_jsr:
.9f61	20 73 80	jsr $8073		jsr	AssembleGroup2
>9f64	14					.byte $14
>9f65	10					.byte $10
.9f66					Assemble_jmp:
.9f66	20 73 80	jsr $8073		jsr	AssembleGroup2
>9f69	40					.byte $40
>9f6a	10					.byte $10
.9f6b					Assemble_bpl:
.9f6b	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9f6e	10					.byte $10
.9f6f					Assemble_bmi:
.9f6f	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9f72	30					.byte $30
.9f73					Assemble_bvc:
.9f73	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9f76	50					.byte $50
.9f77					Assemble_bvs:
.9f77	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9f7a	70					.byte $70
.9f7b					Assemble_bcc:
.9f7b	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9f7e	90					.byte $90
.9f7f					Assemble_bcs:
.9f7f	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9f82	b0					.byte $b0
.9f83					Assemble_bne:
.9f83	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9f86	d0					.byte $d0
.9f87					Assemble_beq:
.9f87	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9f8a	f0					.byte $f0
.9f8b					Assemble_bra:
.9f8b	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9f8e	80					.byte $80
.9f8f					Assemble_brk:
.9f8f	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f92	00					.byte $00
.9f93					Assemble_php:
.9f93	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f96	08					.byte $08
.9f97					Assemble_clc:
.9f97	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f9a	18					.byte $18
.9f9b					Assemble_plp:
.9f9b	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f9e	28					.byte $28
.9f9f					Assemble_sec:
.9f9f	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9fa2	38					.byte $38
.9fa3					Assemble_rti:
.9fa3	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9fa6	40					.byte $40
.9fa7					Assemble_pha:
.9fa7	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9faa	48					.byte $48
.9fab					Assemble_cli:
.9fab	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9fae	58					.byte $58
.9faf					Assemble_phy:
.9faf	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9fb2	5a					.byte $5a
.9fb3					Assemble_rts:
.9fb3	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9fb6	60					.byte $60
.9fb7					Assemble_pla:
.9fb7	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9fba	68					.byte $68
.9fbb					Assemble_sei:
.9fbb	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9fbe	78					.byte $78
.9fbf					Assemble_ply:
.9fbf	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9fc2	7a					.byte $7a
.9fc3					Assemble_dey:
.9fc3	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9fc6	88					.byte $88
.9fc7					Assemble_txa:
.9fc7	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9fca	8a					.byte $8a
.9fcb					Assemble_tya:
.9fcb	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9fce	98					.byte $98
.9fcf					Assemble_txs:
.9fcf	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9fd2	9a					.byte $9a
.9fd3					Assemble_tay:
.9fd3	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9fd6	a8					.byte $a8
.9fd7					Assemble_tax:
.9fd7	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9fda	aa					.byte $aa
.9fdb					Assemble_clv:
.9fdb	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9fde	b8					.byte $b8
.9fdf					Assemble_tsx:
.9fdf	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9fe2	ba					.byte $ba
.9fe3					Assemble_iny:
.9fe3	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9fe6	c8					.byte $c8
.9fe7					Assemble_dex:
.9fe7	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9fea	ca					.byte $ca
.9feb					Assemble_cld:
.9feb	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9fee	d8					.byte $d8
.9fef					Assemble_phx:
.9fef	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9ff2	da					.byte $da
.9ff3					Assemble_stp:
.9ff3	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9ff6	db					.byte $db
.9ff7					Assemble_inx:
.9ff7	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9ffa	e8					.byte $e8
.9ffb					Assemble_nop:
.9ffb	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9ffe	ea					.byte $ea
.9fff					Assemble_sed:
.9fff	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>a002	f8					.byte $f8
.a003					Assemble_plx:
.a003	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>a006	fa					.byte $fa

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/constants.asm

.a007					DecimalScalarTable:
>a007	66 66 66 66				.dword $66666666 ; 0.1
>a00b	de					.byte $de
>a00c	1f 85 eb 51				.dword $51eb851f ; 0.01
>a010	db					.byte $db
>a011	4c 37 89 41				.dword $4189374c ; 0.001
>a015	d8					.byte $d8
>a016	ac 8b db 68				.dword $68db8bac ; 0.0001
>a01a	d4					.byte $d4
>a01b	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>a01f	d1					.byte $d1
>a020	83 de 1b 43				.dword $431bde83 ; 1e-06
>a024	ce					.byte $ce
>a025	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>a029	ca					.byte $ca
>a02a	89 3b e6 55				.dword $55e63b89 ; 1e-08
>a02e	c7					.byte $c7
>a02f	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>a033	c4					.byte $c4
>a034	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>a038	c0					.byte $c0
>a039	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>a03d	bd					.byte $bd

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.asm

.a03e					SyntaxError:
.a03e	a9 02		lda #$02		lda	#2
.a040	4c f1 8d	jmp $8df1		jmp	ErrorHandler
.a043					RangeError:
.a043	a9 04		lda #$04		lda	#4
.a045	4c f1 8d	jmp $8df1		jmp	ErrorHandler
.a048					TypeError:
.a048	a9 05		lda #$05		lda	#5
.a04a	4c f1 8d	jmp $8df1		jmp	ErrorHandler
.a04d					ArgumentError:
.a04d	a9 07		lda #$07		lda	#7
.a04f	4c f1 8d	jmp $8df1		jmp	ErrorHandler
.a052					NotDoneError:
.a052	a9 0c		lda #$0c		lda	#12
.a054	4c f1 8d	jmp $8df1		jmp	ErrorHandler
.a057					ErrorText:
>a057	42 72 65 61 6b 00			.text	"Break",0
>a05d	53 79 6e 74 61 78 20 65			.text	"Syntax error",0
>a065	72 72 6f 72 00
>a06a	44 69 76 69 73 69 6f 6e			.text	"Division by zero",0
>a072	20 62 79 20 7a 65 72 6f 00
>a07b	4f 75 74 20 6f 66 20 52			.text	"Out of Range",0
>a083	61 6e 67 65 00
>a088	54 79 70 65 20 6d 69 73			.text	"Type mismatch",0
>a090	6d 61 74 63 68 00
>a096	4f 75 74 20 6f 66 20 6d			.text	"Out of memory",0
>a09e	65 6d 6f 72 79 00
>a0a4	49 6c 6c 65 67 61 6c 20			.text	"Illegal argument",0
>a0ac	61 72 67 75 6d 65 6e 74 00
>a0b5	53 74 6f 70 00				.text	"Stop",0
>a0ba	53 74 72 69 6e 67 20 74			.text	"String too long",0
>a0c2	6f 6f 20 6c 6f 6e 67 00
>a0ca	41 73 73 65 72 74 69 6f			.text	"Assertion failed",0
>a0d2	6e 20 66 61 69 6c 65 64 00
>a0db	4f 75 74 20 6f 66 20 64			.text	"Out of data",0
>a0e3	61 74 61 00
>a0e7	55 6e 69 6d 70 6c 65 6d			.text	"Unimplemented",0
>a0ef	65 6e 74 65 64 00
>a0f5	4e 6f 20 73 75 63 68 20			.text	"No such line number",0
>a0fd	6c 69 6e 65 20 6e 75 6d 62 65 72 00
>a109	52 65 74 75 72 6e 20 77			.text	"Return without Gosub",0
>a111	69 74 68 6f 75 74 20 47 6f 73 75 62 00
>a11e	55 6e 74 69 6c 20 77 69			.text	"Until without Repeat",0
>a126	74 68 6f 75 74 20 52 65 70 65 61 74 00
>a133	57 65 6e 64 20 77 69 74			.text	"Wend without While",0
>a13b	68 6f 75 74 20 57 68 69 6c 65 00
>a146	4e 65 78 74 20 77 69 74			.text	"Next without For",0
>a14e	68 6f 75 74 20 46 6f 72 00
>a157	42 41 53 49 43 20 53 74			.text	"BASIC Stack full",0
>a15f	61 63 6b 20 66 75 6c 6c 00
>a168	4f 70 65 6e 20 53 74 72			.text	"Open Structure",0
>a170	75 63 74 75 72 65 00
>a177	45 6e 64 50 72 6f 63 20			.text	"EndProc without call",0
>a17f	77 69 74 68 6f 75 74 20 63 61 6c 6c 00
>a18c	41 72 72 61 79 20 61 6c			.text	"Array already defined",0
>a194	72 65 61 64 79 20 64 65 66 69 6e 65 64 00
>a1a2	41 72 72 61 79 20 73 69			.text	"Array size",0
>a1aa	7a 65 00
>a1ad	42 61 64 20 61 72 72 61			.text	"Bad array index",0
>a1b5	79 20 69 6e 64 65 78 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/timestamp.asm

>a1bd	42 75 69 6c 74 20 54 75			.text "Built Tuesday 22-Nov-2022. Build 3570."
>a1c5	65 73 64 61 79 20 32 32 2d 4e 6f 76 2d 32 30 32
>a1d5	32 2e 20 42 75 69 6c 64 20 33 35 37 30 2e

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcommand.asm

.a1e3					RectangleCommand:
.a1e3	a9 44		lda #$44			lda 	#GCMD_FrameRect				; frame rectangle
.a1e5	80 02		bra $a1e9			bra 	ShapeDrawCmd
.a1e7					CircleCommand:
.a1e7	a9 48		lda #$48			lda 	#GCMD_FrameCircle 				; framed circle
.a1e9					ShapeDrawCmd:
.a1e9	20 77 a2	jsr $a277			jsr 	RunGraphicsCommand
.a1ec					ShapeDraw:
.a1ec	0d 30 06	ora $0630			ora 	gxFillSolid  				; adjust AXY for solid fill.
.a1ef	4c 6b a2	jmp $a26b			jmp 	ExecuteGraphicCommand	 	; and complete
.a1f2					SpriteCommand:
.a1f2	a2 00		ldx #$00			ldx 	#0
.a1f4	20 35 9e	jsr $9e35			jsr 	Evaluate8BitInteger 		; get image number.
.a1f7	5a		phy				phy
.a1f8	a9 0e		lda #$0e			lda 	#GCMD_SpriteUse 			; use that image.
.a1fa	ae 08 04	ldx $0408			ldx 	NSMantissa0
.a1fd	e0 40		cpx #$40			cpx 	#64 						; 0-63 only
.a1ff	b0 0d		bcs $a20e			bcs 	_SCRange
.a201	a0 ff		ldy #$ff			ldy 	#255
.a203	20 6a ab	jsr $ab6a			jsr 	GXGraphicDraw
.a206	a9 52		lda #$52			lda 	#GCMD_SpriteMove
.a208	7a		ply				ply
.a209	20 77 a2	jsr $a277			jsr 	RunGraphicsCommand
.a20c	80 5d		bra $a26b			bra 	ExecuteGraphicCommand
.a20e					_SCRange:
.a20e	4c 43 a0	jmp $a043			jmp 	RangeError
.a211					ImageCommand:
.a211	a2 00		ldx #$00			ldx 	#0
.a213	20 35 9e	jsr $9e35			jsr 	Evaluate8BitInteger 		; get image number.
.a216	20 77 a2	jsr $a277			jsr 	RunGraphicsCommand
.a219					ImageRunDraw:
.a219	09 40		ora #$40			ora 	#GCMD_Move					; move cursor
.a21b	20 6a ab	jsr $ab6a			jsr 	GXGraphicDraw
.a21e	ad 36 06	lda $0636			lda 	gxDrawScale
.a221	0a		asl a				asl 	a
.a222	0a		asl a				asl 	a
.a223	0a		asl a				asl 	a
.a224	a8		tay				tay
.a225	a9 0c		lda #$0c			lda 	#GCMD_DrawSprite 			; image drawing
.a227	ae 08 04	ldx $0408			ldx 	NSMantissa0
.a22a	20 6a ab	jsr $ab6a			jsr 	GXGraphicDraw
.a22d	60		rts				rts
.a22e					TextCommand:
.a22e	a2 00		ldx #$00			ldx 	#0
.a230	20 e8 9d	jsr $9de8			jsr 	EvaluateString 				; get text
.a233	20 77 a2	jsr $a277			jsr 	RunGraphicsCommand
.a236					TextRunDraw:
.a236	09 40		ora #$40			ora 	#GCMD_Move 					; move cursor
.a238	20 6a ab	jsr $ab6a			jsr 	GXGraphicDraw
.a23b	a0 00		ldy #$00			ldy 	#0
.a23d					_IRDLoop:
.a23d	ad 10 04	lda $0410			lda 	NSMantissa1 				; access character
.a240	85 37		sta $37				sta 	zTemp0+1
.a242	ad 08 04	lda $0408			lda 	NSMantissa0
.a245	85 36		sta $36				sta 	zTemp0
.a247	b1 36		lda ($36),y			lda 	(zTemp0),y
.a249	f0 13		beq $a25e			beq 	_IRDExit
.a24b	5a		phy				phy									; save string pos
.a24c	48		pha				pha 								; save char
.a24d	ad 36 06	lda $0636			lda 	gxDrawScale 				; get scale
.a250	0a		asl a				asl 	a
.a251	0a		asl a				asl 	a
.a252	0a		asl a				asl 	a
.a253	a8		tay				tay
.a254	a9 0a		lda #$0a			lda 	#GCMD_DrawFont 				; char drawing
.a256	fa		plx				plx 								; char to draw
.a257	20 6a ab	jsr $ab6a			jsr 	GXGraphicDraw
.a25a	7a		ply				ply 								; restore string pos
.a25b	c8		iny				iny
.a25c	90 df		bcc $a23d			bcc 	_IRDLoop 					; go back if no error.
.a25e					_IRDExit:
.a25e	60		rts				rts
.a25f					PlotCommand:
.a25f	a9 50		lda #$50			lda 	#GCMD_Plot 					; command ID to use
.a261	20 77 a2	jsr $a277			jsr 	RunGraphicsCommand
.a264	80 05		bra $a26b			bra 	ExecuteGraphicCommand
.a266					LineCommand:
.a266	a9 42		lda #$42			lda 	#GCMD_Line 						; command ID to use
.a268	20 77 a2	jsr $a277			jsr 	RunGraphicsCommand
.a26b					ExecuteGraphicCommand:
.a26b	0d 2f 06	ora $062f			ora 	gxCommandID 				; make a full command
.a26e	20 6a ab	jsr $ab6a			jsr 	GXGraphicDraw 				; draw it and exit
.a271	b0 01		bcs $a274			bcs 	_EGCError
.a273	60		rts				rts
.a274					_EGCError:
.a274	4c 3e a0	jmp $a03e			jmp 	SyntaxError
.a277					RunGraphicsCommand:
.a277	8d 2f 06	sta $062f			sta 	gxCommandID					; save TODO graphics command.
.a27a	68		pla				pla 								; pop handler address
.a27b	fa		plx				plx
.a27c	1a		inc a				inc 	a
.a27d	d0 01		bne $a280			bne 	_RGINoCarry
.a27f	e8		inx				inx
.a280					_RGINoCarry:
.a280	8d 34 06	sta $0634			sta 	GXHandler
.a283	8e 35 06	stx $0635			stx 	GXHandler+1
.a286					_RGICommandLoop:
.a286	b1 30		lda ($30),y			lda 	(codePtr),y
.a288	c8		iny				iny
.a289	c9 ce		cmp #$ce			cmp 	#KWD_TO						; is it TO x,y
.a28b	f0 53		beq $a2e0			beq 	_RGI_To
.a28d	c9 ba		cmp #$ba			cmp 	#KWD_HERE 					; do it here.
.a28f	f0 55		beq $a2e6			beq 	_RGI_Here
.a291	c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL or : , exit
.a293	f0 3d		beq $a2d2			beq 	_RGI_Exit
.a295	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.a297	f0 39		beq $a2d2			beq 	_RGI_Exit
.a299	c9 c2		cmp #$c2			cmp 	#KWD_OUTLINE 				; solid or outline
.a29b	f0 3e		beq $a2db			beq 	_RGI_Frame
.a29d	c9 ca		cmp #$ca			cmp 	#KWD_SOLID
.a29f	f0 33		beq $a2d4			beq 	_RGI_Solid
.a2a1	c9 ab		cmp #$ab			cmp 	#KWD_BY 					; by offset
.a2a3	f0 4b		beq $a2f0			beq 	_RGI_By
.a2a5	c9 b6		cmp #$b6			cmp 	#KWD_FROM 					; from
.a2a7	f0 17		beq $a2c0			beq 	_RGI_Move2
.a2a9	c9 b3		cmp #$b3			cmp 	#KWD_DIM 					; dim (set scale)
.a2ab	f0 65		beq $a312			beq 	_RGI_Dim
.a2ad	c9 b1		cmp #$b1			cmp 	#KWD_COLOUR 				; colour or Color
.a2af	f0 78		beq $a329			beq 	_RGI_Colour
.a2b1	c9 b0		cmp #$b0			cmp 	#KWD_COLOR
.a2b3	f0 74		beq $a329			beq 	_RGI_Colour
.a2b5	ae 2f 06	ldx $062f			ldx 	gxCommandID
.a2b8	e0 52		cpx #$52			cpx 	#GCMD_SpriteMove 			; if not sprite
.a2ba	d0 03		bne $a2bf			bne 	_RGI_Move 					; move
.a2bc	4c 53 a3	jmp $a353			jmp		_RGI_SpriteInstructions
.a2bf					_RGI_Move:
.a2bf	88		dey				dey 								; unpick get.
.a2c0					_RGI_Move2:
.a2c0	20 79 a3	jsr $a379			jsr 	GCGetCoordinatePair 		; move to here
.a2c3	20 a0 a3	jsr $a3a0			jsr 	GCCopyPairToStore 			; save
.a2c6	5a		phy				phy
.a2c7	20 96 a3	jsr $a396			jsr 	GCLoadAXY 					; load in
.a2ca	09 40		ora #$40			ora 	#GCMD_Move 					; move there
.a2cc	20 6a ab	jsr $ab6a			jsr 	GXGraphicDraw
.a2cf	7a		ply				ply
.a2d0	80 b4		bra $a286			bra 	_RGICommandLoop 			; and go round
.a2d2					_RGI_Exit:
.a2d2	88		dey				dey 								; unpick : / EOL
.a2d3	60		rts				rts
.a2d4					_RGI_Solid:
.a2d4	a9 02		lda #$02			lda 	#2
.a2d6	8d 30 06	sta $0630			sta 	gxFillSolid
.a2d9	80 ab		bra $a286			bra 	_RGICommandLoop
.a2db					_RGI_Frame:
.a2db	9c 30 06	stz $0630			stz 	gxFillSolid
.a2de	80 a6		bra $a286			bra 	_RGICommandLoop
.a2e0					_RGI_To:
.a2e0	20 79 a3	jsr $a379			jsr 	GCGetCoordinatePair 		; get coordinate pair into slot #1,#2
.a2e3	20 a0 a3	jsr $a3a0			jsr 	GCCopyPairToStore
.a2e6					_RGI_Here:
.a2e6	5a		phy				phy
.a2e7	20 96 a3	jsr $a396			jsr 	GCLoadAXY 					; load it into AXY
.a2ea	20 50 a3	jsr $a350			jsr 	_RGICallHandler 			; go do whatever it is.
.a2ed	7a		ply				ply
.a2ee	80 96		bra $a286			bra 	_RGICommandLoop 			; and go round
.a2f0					_RGI_By:
.a2f0	20 86 a3	jsr $a386			jsr 	GCSignedCoordinatePair 		; get coordinate pair into slot #1,#2
.a2f3	18		clc				clc
.a2f4	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; copy it into space.
.a2f7	6d 31 06	adc $0631			adc 	gxxPos
.a2fa	8d 31 06	sta $0631			sta 	gxXPos
.a2fd	ad 11 04	lda $0411			lda 	NSMantissa1+1
.a300	6d 32 06	adc $0632			adc 	gxxPos+1
.a303	8d 32 06	sta $0632			sta 	gxXPos+1
.a306	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a309	18		clc				clc
.a30a	6d 33 06	adc $0633			adc 	gxYPos
.a30d	8d 33 06	sta $0633			sta 	gxYPos
.a310	80 d4		bra $a2e6			bra 	_RGI_Here
.a312					_RGI_Dim:
.a312	a2 01		ldx #$01			ldx	 	#1
.a314	20 35 9e	jsr $9e35			jsr 	Evaluate8BitInteger
.a317	ad 09 04	lda $0409			lda 	NSMantissa0+1
.a31a	c9 00		cmp #$00			cmp 	#0
.a31c	f0 2f		beq $a34d			beq 	_RGIRange
.a31e	c9 09		cmp #$09			cmp 	#8+1
.a320	b0 2b		bcs $a34d			bcs		_RGIRange
.a322	3a		dec a				dec 	a
.a323	8d 36 06	sta $0636			sta 	gxDrawScale
.a326	4c 86 a2	jmp $a286			jmp 	_RGICommandLoop
.a329					_RGI_Colour:
.a329	a2 01		ldx #$01			ldx 	#1 							; colour
.a32b	20 35 9e	jsr $9e35			jsr 	Evaluate8BitInteger
.a32e	a2 02		ldx #$02			ldx 	#2 							; default zero for 2nd parameter
.a330	20 b4 9e	jsr $9eb4			jsr 	NSMSetZero
.a333	b1 30		lda ($30),y			lda 	(codePtr),y
.a335	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; check , => mode.
.a337	d0 04		bne $a33d			bne 	_RGICDefaultMode
.a339	c8		iny				iny
.a33a	20 35 9e	jsr $9e35			jsr 	Evaluate8BitInteger
.a33d					_RGICDefaultMode:
.a33d	5a		phy				phy
.a33e	a9 08		lda #$08			lda 	#GCMD_Colour 				; set colour.
.a340	ae 09 04	ldx $0409			ldx 	NSMantissa0+1
.a343	ac 0a 04	ldy $040a			ldy 	NSMantissa0+2
.a346	20 6a ab	jsr $ab6a			jsr 	GXGraphicDraw
.a349	7a		ply				ply
.a34a	4c 86 a2	jmp $a286			jmp 	_RGICommandLoop 			; and go round
.a34d					_RGIRange:
.a34d	4c 43 a0	jmp $a043			jmp 	RangeError
.a350					_RGICallHandler:
.a350	6c 34 06	jmp ($0634)			jmp 	(GXHandler)
.a353					_RGI_SpriteInstructions:
.a353	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a355	f0 07		beq $a35e			beq 	_RGISpriteOff
.a357	c9 bb		cmp #$bb			cmp 	#KWD_IMAGE
.a359	f0 13		beq $a36e			beq 	_RGISetImage
.a35b	4c bf a2	jmp $a2bf			jmp 	_RGI_Move
.a35e					_RGISpriteOff:
.a35e	5a		phy				phy
.a35f	a0 01		ldy #$01			ldy 	#1
.a361	a2 00		ldx #$00			ldx 	#0
.a363					_RGIDoCommandLoop:
.a363	a9 10		lda #$10			lda 	#GCMD_SpriteImage
.a365	20 6a ab	jsr $ab6a			jsr 	GXGraphicDraw
.a368	7a		ply				ply
.a369	b0 e2		bcs $a34d			bcs 	_RGIRange
.a36b	4c 86 a2	jmp $a286			jmp 	_RGICommandLoop
.a36e					_RGISetImage:
.a36e	a2 01		ldx #$01			ldx 	#1
.a370	20 35 9e	jsr $9e35			jsr 	Evaluate8BitInteger
.a373	5a		phy				phy
.a374	aa		tax				tax
.a375	a0 00		ldy #$00			ldy 	#0
.a377	80 ea		bra $a363			bra 	_RGIDoCommandLoop
.a379					GCGetCoordinatePair:
.a379	a2 01		ldx #$01			ldx 	#1
.a37b	20 15 9e	jsr $9e15			jsr 	Evaluate16BitInteger
.a37e	20 e0 8d	jsr $8de0			jsr 	CheckComma
.a381	e8		inx				inx
.a382	20 15 9e	jsr $9e15			jsr 	Evaluate16BitInteger
.a385	60		rts				rts
.a386					GCSignedCoordinatePair:
.a386	a2 01		ldx #$01			ldx 	#1
.a388	20 21 9e	jsr $9e21			jsr 	Evaluate16BitIntegerSigned
.a38b	20 e0 8d	jsr $8de0			jsr 	CheckComma
.a38e	e8		inx				inx
.a38f	20 21 9e	jsr $9e21			jsr 	Evaluate16BitIntegerSigned
.a392	60		rts				rts
.a393					_GCCPRange:
.a393	4c 43 a0	jmp $a043			jmp 	RangeError
.a396					GCLoadAXY:
.a396	ad 32 06	lda $0632			lda 	gxXPos+1
.a399	ae 31 06	ldx $0631			ldx 	gxXPos
.a39c	ac 33 06	ldy $0633			ldy 	gxYPos
.a39f	60		rts				rts
.a3a0					GCCopyPairToStore:
.a3a0	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; copy it into space.
.a3a3	8d 31 06	sta $0631			sta 	gxXPos
.a3a6	ad 11 04	lda $0411			lda 	NSMantissa1+1
.a3a9	8d 32 06	sta $0632			sta 	gxXPos+1
.a3ac	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a3af	8d 33 06	sta $0633			sta 	gxYPos
.a3b2	60		rts				rts
.062f					gxCommandID:
>062f							.fill 	1
.0630					gxFillSolid:
>0630							.fill 	1
.0631					gxXPos:
>0631							.fill 	2
.0633					gxYPos:
>0633							.fill 	1
.0634					gxHandler:
>0634							.fill 	2
.0636					gxDrawScale:
>0636							.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcontrol.asm

.a3b3					BitmapCtrl:
.a3b3	b1 30		lda ($30),y			lda 	(codePtr),y
.a3b5	c8		iny				iny
.a3b6	a2 01		ldx #$01			ldx 	#1
.a3b8	c9 c1		cmp #$c1			cmp 	#KWD_ON
.a3ba	f0 11		beq $a3cd			beq 	BitmapSwitch
.a3bc	ca		dex				dex
.a3bd	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a3bf	f0 0c		beq $a3cd			beq 	BitmapSwitch
.a3c1	20 35 9e	jsr $9e35			jsr 	Evaluate8BitInteger 		; get the colour
.a3c4	5a		phy				phy
.a3c5	aa		tax				tax
.a3c6	a9 06		lda #$06			lda 	#GCMD_Clear					; clear to that colour
.a3c8	20 6a ab	jsr $ab6a			jsr 	GXGraphicDraw
.a3cb	7a		ply				ply
.a3cc	60		rts				rts
.a3cd					BitmapSwitch:
.a3cd	5a		phy				phy
.a3ce	a0 00		ldy #$00			ldy 	#0 							; gfx 1,on/off,0
.a3d0	a9 02		lda #$02			lda 	#GCMD_BitmapCtl
.a3d2	20 6a ab	jsr $ab6a			jsr 	GXGraphicDraw
.a3d5	a9 08		lda #$08			lda 	#GCMD_Colour				; set colour to $FF
.a3d7	a0 00		ldy #$00			ldy 	#0
.a3d9	a2 ff		ldx #$ff			ldx 	#$FF
.a3db	20 6a ab	jsr $ab6a			jsr 	GXGraphicDraw
.a3de	9c 30 06	stz $0630			stz 	gxFillSolid
.a3e1	9c 31 06	stz $0631			stz 	gxXPos
.a3e4	9c 32 06	stz $0632			stz 	gxXPos+1
.a3e7	9c 33 06	stz $0633			stz 	gxYPos
.a3ea	9c 36 06	stz $0636			stz 	gxDrawScale
.a3ed	a9 40		lda #$40			lda 	#GCMD_Move 						; home cursor
.a3ef	a2 00		ldx #$00			ldx 	#0
.a3f1	a0 00		ldy #$00			ldy 	#0
.a3f3	20 6a ab	jsr $ab6a			jsr 	GXGraphicDraw
.a3f6	7a		ply				ply
.a3f7	60		rts				rts
.a3f8					SpritesCtrl:
.a3f8	b1 30		lda ($30),y			lda 	(codePtr),y
.a3fa	c8		iny				iny
.a3fb	a2 01		ldx #$01			ldx 	#1
.a3fd	c9 c1		cmp #$c1			cmp 	#KWD_ON
.a3ff	f0 08		beq $a409			beq 	SpriteSwitch
.a401	ca		dex				dex
.a402	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a404	f0 03		beq $a409			beq 	SpriteSwitch
.a406	4c 3e a0	jmp $a03e			jmp 	SyntaxError
.a409					SpriteSwitch:
.a409	5a		phy				phy
.a40a	a0 00		ldy #$00			ldy 	#0 							; gfx 2,on/off,0
.a40c	a9 04		lda #$04			lda 	#GCMD_SpriteCtl
.a40e	20 6a ab	jsr $ab6a			jsr 	GXGraphicDraw
.a411	7a		ply				ply
.a412	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gfx.asm

.a413					GfxCommand:
.a413	a2 00		ldx #$00			ldx 	#0
.a415	20 35 9e	jsr $9e35			jsr 	Evaluate8BitInteger 		; command
.a418	20 e0 8d	jsr $8de0			jsr 	CheckComma
.a41b	e8		inx				inx
.a41c	20 15 9e	jsr $9e15			jsr 	Evaluate16BitInteger 		; X
.a41f	20 e0 8d	jsr $8de0			jsr 	CheckComma
.a422	e8		inx				inx
.a423	20 35 9e	jsr $9e35			jsr 	Evaluate8BitInteger 		; Y
.a426	ad 11 04	lda $0411			lda 	NSMantissa1+1  				; shift bit 0 of X into CS, should now be zero
.a429	4a		lsr a				lsr 	a
.a42a	d0 16		bne $a442			bne 	_GfxError
.a42c	2e 08 04	rol $0408			rol 	NSMantissa0 				; rotate into command
.a42f	b0 11		bcs $a442			bcs 	_GfxError 					; bit 7 should have been zero
.a431	5a		phy				phy 								; save pos
.a432	ad 08 04	lda $0408			lda 	NSMantissa0 				; do the command
.a435	ae 09 04	ldx $0409			ldx 	NSMantissa0+1
.a438	ac 0a 04	ldy $040a			ldy 	NSMantissa0+2
.a43b	20 6a ab	jsr $ab6a			jsr 	GXGraphicDraw
.a43e	b0 02		bcs $a442			bcs 	_GfxError
.a440	7a		ply				ply 								; restore pos and exit.
.a441	60		rts				rts
.a442					_GfxError:
.a442	4c 43 a0	jmp $a043			jmp 	RangeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/hit.asm

.a445					UnaryHit:
.a445	fa		plx				plx
.a446	a9 36		lda #$36			lda 	#zTemp0
.a448	20 35 9e	jsr $9e35			jsr 	Evaluate8BitInteger 		; get sprite number 0
.a44b	20 e0 8d	jsr $8de0			jsr 	CheckComma
.a44e	e8		inx				inx
.a44f	20 35 9e	jsr $9e35			jsr 	Evaluate8BitInteger 		; get sprite number 1
.a452	20 d8 8d	jsr $8dd8			jsr		CheckRightBracket
.a455	ca		dex				dex 								; fix back up again.
.a456	da		phx				phx 								; save X/Y
.a457	5a		phy				phy
.a458	bc 09 04	ldy $0409,x			ldy 	NSMantissa0+1,x 			; get the sprite numbers into X/Y
.a45b	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a45e	aa		tax				tax
.a45f	a9 12		lda #$12			lda 	#GCMD_SpriteCollide 		; command check collision.
.a461	20 6a ab	jsr $ab6a			jsr 	GXGraphicDraw 				; calculate result
.a464	1a		inc a				inc 	a 							; so 255 (fail) -> 0, otherwise 1,2,3,4 pixels etc.
.a465	7a		ply				ply 								; restore XY
.a466	fa		plx				plx
.a467	20 b6 9e	jsr $9eb6			jsr 	NSMSetByte 					; return the hit result
.a46a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/palette.asm

.a46b					PaletteCommand:
.a46b	a2 00		ldx #$00			ldx 	#0
.a46d	20 35 9e	jsr $9e35			jsr 	Evaluate8BitInteger 		; colour
.a470	20 e0 8d	jsr $8de0			jsr 	CheckComma
.a473	e8		inx				inx
.a474	20 15 9e	jsr $9e15			jsr 	Evaluate16BitInteger 		; r
.a477	20 e0 8d	jsr $8de0			jsr 	CheckComma
.a47a	e8		inx				inx
.a47b	20 35 9e	jsr $9e35			jsr 	Evaluate8BitInteger 		; g
.a47e	20 e0 8d	jsr $8de0			jsr 	CheckComma
.a481	e8		inx				inx
.a482	20 35 9e	jsr $9e35			jsr 	Evaluate8BitInteger 		; b
.a485	ad 08 04	lda $0408			lda 	NSMantissa0 				; get colour #
.a488	85 36		sta $36				sta 	zTemp0
.a48a	a9 34		lda #$34			lda 	#$D0 >> 2 					; MSB = D0/4
.a48c	85 37		sta $37				sta 	zTemp0+1
.a48e	06 36		asl $36				asl 	zTemp0 						; zTemp = $D000+Colour x 4
.a490	26 37		rol $37				rol	 	zTemp0+1
.a492	06 36		asl $36				asl 	zTemp0
.a494	26 37		rol $37				rol	 	zTemp0+1
.a496	a9 01		lda #$01			lda 	#1 							; I/O Page 2
.a498	85 01		sta $01				sta 	1
.a49a	5a		phy				phy
.a49b	ad 0b 04	lda $040b			lda 	NSMantissa0+3 				; fix to r,g,b
.a49e	92 36		sta ($36)			sta 	(zTemp0)
.a4a0	a0 01		ldy #$01			ldy 	#1
.a4a2	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a4a5	91 36		sta ($36),y			sta 	(zTemp0),y
.a4a7	ad 09 04	lda $0409			lda 	NSMantissa0+1
.a4aa	c8		iny				iny
.a4ab	91 36		sta ($36),y			sta 	(zTemp0),y
.a4ad	7a		ply				ply
.a4ae	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/event.asm

.a4af					UnaryEvent:
.a4af	fa		plx				plx
.a4b0	20 57 a5	jsr $a557			jsr 	TimerToStackX 				; timer in +0
.a4b3	e8		inx				inx  								; put reference into +1
.a4b4	20 7a 98	jsr $987a			jsr 	EvaluateTerm
.a4b7	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if is integer reference
.a4ba	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.a4bc	d0 57		bne $a515			bne 	_UEType
.a4be	e8		inx				inx 								; put the step in +2
.a4bf	20 e0 8d	jsr $8de0			jsr 	CheckComma
.a4c2	20 15 9e	jsr $9e15			jsr 	Evaluate16BitInteger
.a4c5	20 d8 8d	jsr $8dd8			jsr 	CheckRightBracket
.a4c8	ca		dex				dex
.a4c9	ca		dex				dex
.a4ca	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; copy reference to zTemp0
.a4cd	85 36		sta $36				sta 	zTemp0
.a4cf	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.a4d2	85 37		sta $37				sta 	zTemp0+1
.a4d4	5a		phy				phy
.a4d5	a0 03		ldy #$03			ldy 	#3 							; check bit 7 of last bit, the packed sign bit
.a4d7	b1 36		lda ($36),y			lda 	(zTemp0),y
.a4d9	30 36		bmi $a511			bmi 	_UEFalse 					; exit if signed.
.a4db	a0 00		ldy #$00			ldy 	#0 							; has it timed out (24 bit)
.a4dd	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a4e0	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.a4e2	c8		iny				iny
.a4e3	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a4e6	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a4e8	c8		iny				iny
.a4e9	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.a4ec	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a4ee	90 21		bcc $a511			bcc 	_UEFalse 					; no, return FALSE.
.a4f0	18		clc				clc
.a4f1	a0 00		ldy #$00			ldy 	#0 							; work out new value as timer() + step
.a4f3	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a4f6	7d 0a 04	adc $040a,x			adc 	NSMantissa0+2,x
.a4f9	91 36		sta ($36),y			sta 	(zTemp0),y
.a4fb	c8		iny				iny
.a4fc	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a4ff	7d 12 04	adc $0412,x			adc 	NSMantissa1+2,x
.a502	91 36		sta ($36),y			sta 	(zTemp0),y
.a504	c8		iny				iny
.a505	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.a508	7d 1a 04	adc $041a,x			adc 	NSMantissa2+2,x
.a50b	91 36		sta ($36),y			sta 	(zTemp0),y
.a50d	7a		ply				ply
.a50e	4c 5e 8e	jmp $8e5e			jmp 	ReturnTrue
.a511					_UEFalse:
.a511	7a		ply				ply 								; restore Y
.a512	4c 6a 8e	jmp $8e6a			jmp 	ReturnFalse 				; and return False
.a515					_UEType:
.a515	4c 48 a0	jmp $a048			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/joy.asm

.a518					UnaryJoyX:
.a518	18		clc				clc
.a519	80 01		bra $a51c			bra 	JoyMain
.a51b					UnaryJoyY:
.a51b	38		sec				sec
.a51c					JoyMain:
.a51c	fa		plx				plx 								; get pos
.a51d	08		php				php 								; save carry (set for Y)
.a51e	20 35 9e	jsr $9e35			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a521	20 d8 8d	jsr $8dd8			jsr 	CheckRightBracket
.a524	20 23 ab	jsr $ab23			jsr 	EXTReadController 			; read the controller.
.a527	28		plp				plp
.a528	90 02		bcc $a52c			bcc 	_JMNoShift 					; if Y then shift bits 3,2 -> 1,0
.a52a	4a		lsr a				lsr 	a
.a52b	4a		lsr a				lsr 	a
.a52c					_JMNoShift:
.a52c	4a		lsr a				lsr 	a 							; if bit 0 set then right/down e.g. +1
.a52d	b0 0a		bcs $a539			bcs 	_JMIsRight
.a52f	4a		lsr a				lsr 	a 							; if bit 1 set then left/up e.g. -1
.a530	b0 04		bcs $a536			bcs 	_JMIsLeft
.a532	20 b4 9e	jsr $9eb4			jsr 	NSMSetZero 					; zero result
.a535	60		rts				rts
.a536					_JMIsLeft:
.a536	4c 5e 8e	jmp $8e5e			jmp 	ReturnTrue
.a539					_JMIsRight:
.a539	a9 01		lda #$01			lda 	#1
.a53b	20 b6 9e	jsr $9eb6			jsr 	NSMSetByte
.a53e	60		rts				rts
.a53f					UnaryJoyB:
.a53f	fa		plx				plx 								; get pos
.a540	20 35 9e	jsr $9e35			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a543	20 d8 8d	jsr $8dd8			jsr 	CheckRightBracket
.a546	20 23 ab	jsr $ab23			jsr 	EXTReadController 			; read the controller.
.a549	4a		lsr a				lsr 	a
.a54a	4a		lsr a				lsr 	a
.a54b	4a		lsr a				lsr 	a
.a54c	4a		lsr a				lsr 	a
.a54d	29 01		and #$01			and 	#1
.a54f	20 b6 9e	jsr $9eb6			jsr 	NSMSetByte
.a552	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/timer.asm

.a553					UnaryTimer:
.a553	fa		plx				plx
.a554	20 d8 8d	jsr $8dd8			jsr 	CheckRightBracket
.a557					TimerToStackX:
.a557	20 b4 9e	jsr $9eb4			jsr 	NSMSetZero 					; zero result
.a55a	64 01		stz $01				stz 	1 							; access I/O
.a55c	ad 59 d6	lda $d659			lda 	$D659 						; copy timer in
.a55f	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.a562	ad 5a d6	lda $d65a			lda 	$D65A
.a565	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a568	ad 5b d6	lda $d65b			lda 	$D65B
.a56b	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.a56e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/delete.asm

.a56f					MemoryDeleteLine:
.a56f	20 8e a5	jsr $a58e			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a572	b2 30		lda ($30)			lda 	(codePtr) 					; size to delete => y
.a574	a8		tay				tay
.a575					_MDDLLoop:
.a575	b1 30		lda ($30),y			lda 	(codePtr),y 				; copy down
.a577	92 30		sta ($30)			sta 	(codePtr)
.a579	a5 30		lda $30				lda 	codePtr 					; check done the lot.
.a57b	c5 3a		cmp $3a				cmp 	zTemp2
.a57d	d0 07		bne $a586			bne 	_MDLDLNext
.a57f	a5 31		lda $31				lda 	codePtr+1
.a581	c5 3b		cmp $3b				cmp 	zTemp2+1
.a583	d0 01		bne $a586			bne 	_MDLDLNext
.a585					_MDDLExit:
.a585	60		rts				rts
.a586					_MDLDLNext:
.a586	e6 30		inc $30				inc 	codePtr						; next byte
.a588	d0 eb		bne $a575			bne 	_MDDLLoop
.a58a	e6 31		inc $31				inc 	codePtr+1
.a58c	80 e7		bra $a575			bra 	_MDDLLoop
.a58e					IMemoryFindEnd:
.a58e	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a590	85 3a		sta $3a				sta 	0+zTemp2
.a592	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a594	85 3b		sta $3b				sta 	1+zTemp2
.a596					_MDLFELoop:
.a596	b2 3a		lda ($3a)			lda 	(zTemp2)
.a598	f0 0b		beq $a5a5			beq 	_MDLFEExit
.a59a	18		clc				clc
.a59b	65 3a		adc $3a				adc 	zTemp2
.a59d	85 3a		sta $3a				sta 	zTemp2
.a59f	90 f5		bcc $a596			bcc 	_MDLFELoop
.a5a1	e6 3b		inc $3b				inc 	zTemp2+1
.a5a3	80 f1		bra $a596			bra 	_MDLFELoop
.a5a5					_MDLFEExit:
.a5a5	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/insert.asm

.a5a6					MemoryInsertLine:
.a5a6	08		php				php
.a5a7	20 8e a5	jsr $a58e			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a5aa	a5 3b		lda $3b				lda 	zTemp2+1 					; space ?
.a5ac	1a		inc a				inc 	a
.a5ad	c9 7f		cmp #$7f			cmp 	#(BasicEnd >> 8)-1
.a5af	b0 36		bcs $a5e7			bcs 	_MDLIError
.a5b1	28		plp				plp
.a5b2	90 08		bcc $a5bc			bcc 	_MDLIFound
.a5b4	a5 3a		lda $3a				lda 	zTemp2 						; if CS on entry append.
.a5b6	85 30		sta $30				sta 	codePtr
.a5b8	a5 3b		lda $3b				lda 	zTemp2+1
.a5ba	85 31		sta $31				sta 	codePtr+1
.a5bc					_MDLIFound:
.a5bc	ad a9 04	lda $04a9			lda 	tokenOffset 				; insert gap in Y, the offset, e.g. length of the new line
.a5bf	a8		tay				tay
.a5c0					_MDLIInsert:
.a5c0	b2 3a		lda ($3a)			lda 	(zTemp2) 					; shift one byte up , at least one covers end case.
.a5c2	91 3a		sta ($3a),y			sta 	(zTemp2),y 					; work from top down.
.a5c4	a5 30		lda $30				lda 	codePtr 					; done insert point ?
.a5c6	c5 3a		cmp $3a				cmp 	zTemp2
.a5c8	d0 06		bne $a5d0			bne 	_MDLINext
.a5ca	a5 31		lda $31				lda 	codePtr+1
.a5cc	c5 3b		cmp $3b				cmp 	zTemp2+1
.a5ce	f0 0a		beq $a5da			beq 	_MDLIHaveSpace
.a5d0					_MDLINext:
.a5d0	a5 3a		lda $3a				lda 	zTemp2 						; if no, keep zTemp2 going backwards
.a5d2	d0 02		bne $a5d6			bne 	_MDLINoBorrow
.a5d4	c6 3b		dec $3b				dec 	zTemp2+1
.a5d6					_MDLINoBorrow:
.a5d6	c6 3a		dec $3a				dec 	zTemp2
.a5d8	80 e6		bra $a5c0			bra 	_MDLIInsert
.a5da					_MDLIHaveSpace:
.a5da	ac a9 04	ldy $04a9			ldy 	tokenOffset 				; bytes to copy
.a5dd	88		dey				dey 								; from offset-1 to 0
.a5de					_MDLICopy:
.a5de	b9 a9 04	lda $04a9,y			lda 	tokenOffset,y
.a5e1	91 30		sta ($30),y			sta 	(codePtr),y
.a5e3	88		dey				dey
.a5e4	10 f8		bpl $a5de			bpl 	_MDLICopy
.a5e6	60		rts				rts
.a5e7					_MDLIError:
.a5e7	a9 06		lda #$06		lda	#6
.a5e9	4c f1 8d	jmp $8df1		jmp	ErrorHandler
.a5ec					MDLAppendLine:
.a5ec	86 37		stx $37				stx 	zTemp0+1 					; save new line at zTemp0
.a5ee	85 36		sta $36				sta 	zTemp0
.a5f0	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a5f2	85 38		sta $38				sta 	0+zTemp1
.a5f4	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a5f6	85 39		sta $39				sta 	1+zTemp1
.a5f8	b2 38		lda ($38)			lda 	(zTemp1)
.a5fa	d0 0a		bne $a606			bne 	_MDLANoInitialise
.a5fc	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a5fe	8d 37 06	sta $0637			sta 	0+AppendPointer
.a601	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a603	8d 38 06	sta $0638			sta 	1+AppendPointer
.a606					_MDLANoInitialise:
.a606	18		clc				clc
.a607	ad 37 06	lda $0637			lda 	AppendPointer 				; copy append pointer to zTemp1 adding the offset as you go
.a60a	85 38		sta $38				sta 	zTemp1
.a60c	72 36		adc ($36)			adc 	(zTemp0)
.a60e	8d 37 06	sta $0637			sta 	AppendPointer
.a611	ad 38 06	lda $0638			lda 	AppendPointer+1
.a614	85 39		sta $39				sta 	zTemp1+1
.a616	69 00		adc #$00			adc 	#0
.a618	8d 38 06	sta $0638			sta 	AppendPointer+1
.a61b	a0 00		ldy #$00			ldy 	#0
.a61d					_MDLACopy:
.a61d	b1 36		lda ($36),y			lda 	(zTemp0),y 					; copy new line in
.a61f	91 38		sta ($38),y			sta 	(zTemp1),y
.a621	c8		iny				iny
.a622	98		tya				tya
.a623	d2 36		cmp ($36)			cmp 	(zTemp0) 					; done whole line
.a625	d0 f6		bne $a61d			bne 	_MDLACopy
.a627	a9 00		lda #$00			lda 	#0 							; end of program.
.a629	91 38		sta ($38),y			sta 	(zTemp1),y
.a62b	60		rts				rts
.0637					AppendPointer:
>0637							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/memory.asm

.a62c					MemoryNew:
.a62c	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a62e	85 30		sta $30				sta 	codePtr
.a630	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a632	85 31		sta $31				sta 	codePtr+1
.a634	a9 00		lda #$00			lda 	#0 							; write zero there erasing the program.
.a636	92 30		sta ($30)			sta 	(codePtr)
.a638	60		rts				rts
.a639					MemoryInline:
.a639	98		tya				tya 								; put address into stack,x
.a63a	18		clc				clc
.a63b	65 30		adc $30				adc 	codePtr
.a63d	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.a640	a5 31		lda $31				lda 	codePtr+1
.a642	69 00		adc #$00			adc 	#0
.a644	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a647	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.a64a	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.a64d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/search.asm

.a64e					MemorySearch:
.a64e	85 36		sta $36				sta 	zTemp0 						; save line number zTemp0
.a650	86 37		stx $37				stx 	zTemp0+1
.a652	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a654	85 30		sta $30				sta 	codePtr
.a656	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a658	85 31		sta $31				sta 	codePtr+1
.a65a					_MTAXLoop:
.a65a	b2 30		lda ($30)			lda 	(codePtr)
.a65c	18		clc				clc
.a65d	f0 21		beq $a680			beq 	_MTAXExit 					; reached end, exit with CC.
.a65f	a0 01		ldy #$01			ldy 	#1 							; calculate current line# - requested line#
.a661	b1 30		lda ($30),y			lda 	(codePtr),y
.a663	38		sec				sec
.a664	e5 36		sbc $36				sbc 	zTemp0
.a666	85 38		sta $38				sta 	zTemp1 						; save interim to set Z
.a668	c8		iny				iny 								; do the MSB
.a669	b1 30		lda ($30),y			lda 	(codePtr),y
.a66b	e5 37		sbc $37				sbc 	zTemp0+1
.a66d	05 38		ora $38				ora 	zTemp1
.a66f	f0 0f		beq $a680			beq 	_MTAXExit	 				; found
.a671	b0 0d		bcs $a680			bcs 	_MTAXExit 					; current < required exit
.a673	18		clc				clc
.a674	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.a676	65 30		adc $30				adc 	codePtr
.a678	85 30		sta $30				sta 	codePtr
.a67a	90 02		bcc $a67e			bcc 	_CREExit
.a67c	e6 31		inc $31				inc 	codePtr+1
.a67e					_CREExit:
.a67e	80 da		bra $a65a			bra 	_MTAXLoop
.a680					_MTAXExit:
.a680	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/playing.asm

.a681					UnaryPlaying:
.a681	fa		plx				plx
.a682	20 35 9e	jsr $9e35			jsr 	Evaluate8BitInteger 		; get channel #
.a685	48		pha				pha
.a686	20 d8 8d	jsr $8dd8			jsr		CheckRightBracket
.a689	68		pla				pla
.a68a	c9 04		cmp #$04			cmp 	#4
.a68c	b0 0c		bcs $a69a			bcs 	_UPNotPlaying
.a68e	09 20		ora #$20			ora 	#$20 						; query playing ?
.a690	20 f8 b9	jsr $b9f8			jsr 	SNDCommand
.a693	c9 00		cmp #$00			cmp 	#0
.a695	f0 03		beq $a69a			beq 	_UPNotPlaying
.a697	4c 5e 8e	jmp $8e5e			jmp 	ReturnTrue
.a69a					_UPNotPlaying:
.a69a	4c 6a 8e	jmp $8e6a			jmp 	ReturnFalse

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/sound.asm

.a69d					SoundCommand:
.a69d	b1 30		lda ($30),y			lda 	(codePtr),y
.a69f	c9 c0		cmp #$c0			cmp 	#KWD_OFF 					; SOUND OFF ?
.a6a1	d0 09		bne $a6ac			bne 	_SNDMain
.a6a3	c8		iny				iny 								; skip OFF
.a6a4	a9 3f		lda #$3f			lda 	#$3F 						; call command $3F (silence)
.a6a6	5a		phy				phy
.a6a7	20 f8 b9	jsr $b9f8			jsr 	SNDCommand
.a6aa	7a		ply				ply
.a6ab	60		rts				rts
.a6ac					_SNDMain:
.a6ac	a2 00		ldx #$00			ldx 	#0
.a6ae	20 35 9e	jsr $9e35			jsr 	Evaluate8BitInteger 		; channel
.a6b1	c9 04		cmp #$04			cmp 	#4 							; must be 0-3
.a6b3	b0 50		bcs $a705			bcs 	_SndError
.a6b5	e8		inx				inx 								; do the rest in slot 1.
.a6b6	20 e0 8d	jsr $8de0			jsr 	CheckComma
.a6b9	20 15 9e	jsr $9e15			jsr 	Evaluate16BitInteger 		; Pitch
.a6bc	bd 10 04	lda $0410,x			lda 	NSMantissa1,x 				; must be 10 bit
.a6bf	c9 10		cmp #$10			cmp 	#16
.a6c1	b0 42		bcs $a705			bcs 	_SndError
.a6c3	8d 3a 06	sta $063a			sta 	SoundCommandBlock+1 		; Pitch (2 bytes + 0)
.a6c6	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a6c9	8d 39 06	sta $0639			sta 	SoundCommandBlock
.a6cc	20 e0 8d	jsr $8de0			jsr 	CheckComma
.a6cf	20 35 9e	jsr $9e35			jsr 	Evaluate8BitInteger 		; Length (1 byte + 3)
.a6d2	8d 3c 06	sta $063c			sta 	SoundCommandBlock+3
.a6d5	a9 0f		lda #$0f			lda 	#15
.a6d7	8d 3b 06	sta $063b			sta 	SoundCommandBlock+2 		; Volume (1 byte + 2)
.a6da	9c 3d 06	stz $063d			stz 	SoundCommandBlock+4 		; default slide (2 bytes +4)
.a6dd	9c 3e 06	stz $063e			stz 	SoundCommandBlock+5
.a6e0	b1 30		lda ($30),y			lda 	(codePtr),y
.a6e2	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.a6e4	d0 10		bne $a6f6			bne 	_SNDPlay
.a6e6	c8		iny				iny
.a6e7	20 21 9e	jsr $9e21			jsr 	Evaluate16BitIntegerSigned 	; Slide
.a6ea	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; Slide (2 bytes + 4)
.a6ed	8d 3d 06	sta $063d			sta 	SoundCommandBlock+4
.a6f0	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a6f3	8d 3e 06	sta $063e			sta 	SoundCommandBlock+5
.a6f6					_SNDPlay:
.a6f6	5a		phy				phy
.a6f7	ad 08 04	lda $0408			lda 	NSMantissa0 				; channel.
.a6fa	09 10		ora #$10			ora 	#$10 						; 1x = Queue sound
.a6fc	a2 39		ldx #$39			ldx 	#(SoundCommandBlock & $FF)
.a6fe	a0 06		ldy #$06			ldy 	#(SoundCommandBlock >> 8)
.a700	20 f8 b9	jsr $b9f8			jsr 	SNDCommand
.a703	7a		ply				ply
.a704	60		rts				rts
.a705					_SndError:
.a705	4c 43 a0	jmp $a043			jmp 	RangeError
.0639					SoundCommandBlock:
>0639							.fill 	6

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/bytes.asm

.a708					StackPushByte:
.a708	48		pha				pha 								; save byte
.a709	a5 34		lda $34				lda 	BasicStack
.a70b	d0 09		bne $a716			bne 	_SPBNoBorrow
.a70d	c6 35		dec $35				dec 	BasicStack+1
.a70f	48		pha				pha
.a710	a5 35		lda $35				lda 	BasicStack+1
.a712	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a714	90 06		bcc $a71c			bcc 	_SPBMemory
.a716					_SPBNoBorrow:
.a716	c6 34		dec $34				dec 	BasicStack
.a718	68		pla				pla 								; get back and write
.a719	92 34		sta ($34)			sta 	(BasicStack)
.a71b	60		rts				rts
.a71c					_SPBMemory:
.a71c	a9 12		lda #$12		lda	#18
.a71e	4c f1 8d	jmp $8df1		jmp	ErrorHandler
.a721					StackPopByte:
.a721	b2 34		lda ($34)			lda 	(BasicStack)
.a723	e6 34		inc $34				inc 	BasicStack
.a725	d0 02		bne $a729			bne 	_SPBNoCarry
.a727	e6 35		inc $35				inc 	BasicStack+1
.a729					_SPBNoCarry:
.a729	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/frames.asm

.a72a					StackOpen:
.a72a	48		pha				pha 								; save frame byte
.a72b	29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.a72d	0a		asl a				asl 	a 							; claim twice this for storage
.a72e	49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.a730	38		sec				sec 								; so basically subtracting from
.a731	65 34		adc $34				adc 	basicStack 	 				; basicStack
.a733	85 34		sta $34				sta 	basicStack
.a735	b0 08		bcs $a73f			bcs 	_SONoBorrow
.a737	c6 35		dec $35				dec 	basicStack+1
.a739	a5 35		lda $35				lda 	basicStack+1 				; have we reached stack overflow
.a73b	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a73d	90 04		bcc $a743			bcc 	_SOMemory
.a73f					_SONoBorrow:
.a73f	68		pla				pla 								; get marker back and write at TOS
.a740	92 34		sta ($34)			sta 	(basicStack)
.a742	60		rts				rts
.a743					_SOMemory:
.a743	a9 12		lda #$12		lda	#18
.a745	4c f1 8d	jmp $8df1		jmp	ErrorHandler
.a748					StackClose:
.a748	b2 34		lda ($34)			lda 	(basicStack) 				; get TOS marker
.a74a	29 0f		and #$0f			and 	#$0F 						; bytes to add back
.a74c	0a		asl a				asl 	a 							; claim twice this.
.a74d	65 34		adc $34				adc 	basicStack 					; add to the stack pointer.
.a74f	85 34		sta $34				sta 	basicStack
.a751	90 02		bcc $a755			bcc 	_SCExit
.a753	e6 35		inc $35				inc 	basicStack+1
.a755					_SCExit:
.a755	60		rts				rts
.a756					StackCheckFrame:
.a756	48		pha				pha
.a757					_StackRemoveLocals:
.a757	b2 34		lda ($34)			lda 	(basicStack) 				; check for local, keep popping them
.a759	c9 03		cmp #$03			cmp 	#STK_LOCALS+1
.a75b	b0 05		bcs $a762			bcs 	_SCNoLocal
.a75d	20 f3 88	jsr $88f3			jsr 	LocalPopValue
.a760	80 f5		bra $a757			bra 	_StackRemoveLocals
.a762					_SCNoLocal:
.a762	68		pla				pla
.a763	52 34		eor ($34)			eor 	(basicStack) 				; xor with toS marker
.a765	29 f0		and #$f0			and 	#$F0 						; check type bits
.a767	d0 01		bne $a76a			bne 	_SCFError 					; different, we have structures mixed up
.a769	60		rts				rts
.a76a					_SCFError:
.a76a	8a		txa				txa 								; report error X
.a76b	4c f1 8d	jmp $8df1			jmp 	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/location.asm

.a76e					STKSaveCodePosition:
.a76e	5a		phy				phy
.a76f	98		tya				tya 								; save Y
.a770	a0 05		ldy #$05			ldy 	#5
.a772	91 34		sta ($34),y			sta 	(basicStack),y
.a774	88		dey				dey 								; save Code Pointer
.a775					_STKSaveLoop:
.a775	b9 2f 00	lda $002f,y			lda 	safePtr-1,y 				; allows us to access the pointer w/out issues.
.a778	91 34		sta ($34),y			sta 	(basicStack),y
.a77a	88		dey				dey
.a77b	d0 f8		bne $a775			bne 	_STKSaveLoop
.a77d	7a		ply				ply
.a77e	60		rts				rts
.a77f					STKLoadCodePosition:
.a77f	a0 01		ldy #$01			ldy 	#1 							; load code pointer back
.a781					_STKLoadLoop:
.a781	b1 34		lda ($34),y			lda 	(basicStack),y
.a783	99 2f 00	sta $002f,y			sta 	safePtr-1,y
.a786	c8		iny				iny
.a787	c0 05		cpy #$05			cpy 	#5
.a789	d0 f6		bne $a781			bne 	_STKLoadLoop
.a78b	b1 34		lda ($34),y			lda 	(basicStack),y 				; get Y offset
.a78d	a8		tay				tay
.a78e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/setup.asm

.a78f					StackReset:
.a78f	a9 ff		lda #$ff			lda 	#((BasicStackBase+BasicStackSize-1) & $FF)
.a791	85 34		sta $34				sta 	0+basicStack
.a793	a9 0f		lda #$0f			lda 	#((BasicStackBase+BasicStackSize-1) >> 8)
.a795	85 35		sta $35				sta 	1+basicStack
.a797	a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.a799	92 34		sta ($34)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.a79b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/concrete.asm

.a79c					StringConcrete:
.a79c	5a		phy				phy 								; save position on stack
.a79d	20 7d 9a	jsr $9a7d			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a7a0	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy target string to zTemp1
.a7a3	85 38		sta $38				sta 	zTemp1
.a7a5	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a7a8	85 39		sta $39				sta 	zTemp1+1
.a7aa	a0 ff		ldy #$ff			ldy 	#$FF	 					; calculate string length
.a7ac					_SALength:
.a7ac	c8		iny				iny
.a7ad	b1 38		lda ($38),y			lda 	(zTemp1),y
.a7af	d0 fb		bne $a7ac			bne 	_SALength
.a7b1	c0 fd		cpy #$fd			cpy 	#253 						; string too long
.a7b3	b0 3f		bcs $a7f4			bcs 	_SALengthError
.a7b5	98		tya				tya 				 				; length of the new string
.a7b6	18		clc				clc
.a7b7	69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.a7b9	90 02		bcc $a7bd			bcc 	_SAHaveLength
.a7bb	a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.a7bd					_SAHaveLength:
.a7bd	48		pha				pha 								; save length.
.a7be	38		sec				sec
.a7bf	49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.a7c1	6d 8e 04	adc $048e			adc 	StringMemory
.a7c4	8d 8e 04	sta $048e			sta 	StringMemory
.a7c7	85 3a		sta $3a				sta 	zTemp2 						; update storage address
.a7c9	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; update mantissa address
.a7cc	a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.a7ce	6d 8f 04	adc $048f			adc 	StringMemory+1
.a7d1	8d 8f 04	sta $048f			sta 	StringMemory+1
.a7d4	85 3b		sta $3b				sta 	zTemp2+1
.a7d6	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a7d9	68		pla				pla 								; save length-3 (chars allowed) in first byte
.a7da	38		sec				sec
.a7db	e9 03		sbc #$03			sbc 	#3
.a7dd	92 3a		sta ($3a)			sta 	(zTemp2)
.a7df	a9 00		lda #$00			lda 	#0 							; clear the status byte.
.a7e1	a0 01		ldy #$01			ldy 	#1
.a7e3	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a7e5					_SACopyNewString:
.a7e5	a0 00		ldy #$00			ldy 	#0
.a7e7					_SACopyNSLoop:
.a7e7	b1 38		lda ($38),y			lda 	(zTemp1),y 					; get character
.a7e9	c8		iny				iny 								; write two on in string storage
.a7ea	c8		iny				iny
.a7eb	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a7ed	88		dey				dey 								; this makes it one one.
.a7ee	c9 00		cmp #$00			cmp 	#0 							; until EOS copied
.a7f0	d0 f5		bne $a7e7			bne 	_SACopyNSLoop
.a7f2	7a		ply				ply
.a7f3	60		rts				rts
.a7f4					_SALengthError:
.a7f4	a9 09		lda #$09		lda	#9
.a7f6	4c f1 8d	jmp $8df1		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/stringalloc.asm

.a7f9					StringSystemInitialise:
.a7f9	a9 ff		lda #$ff			lda 	#((EndVariableSpace-1) & $FF)
.a7fb	8d 8e 04	sta $048e			sta 	0+StringMemory
.a7fe	a9 1f		lda #$1f			lda 	#((EndVariableSpace-1) >> 8)
.a800	8d 8f 04	sta $048f			sta 	1+StringMemory
.a803	9c ff 1f	stz $1fff			stz 	EndVariableSpace-1 			; put a zero at the end, so know end of string memory.
.a806	60		rts				rts
.a807					StringSpaceInitialise:
.a807	20 7d 9a	jsr $9a7d			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a80a	a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.a80c	8d 90 04	sta $0490			sta 	StringInitialised
.a80f	ad 8e 04	lda $048e			lda 	StringMemory 				; allocate 256 bytes for one concreted string
.a812	8d 91 04	sta $0491			sta 	StringTempPointer
.a815	ad 8f 04	lda $048f			lda 	StringMemory+1
.a818	3a		dec a				dec 	a
.a819	8d 92 04	sta $0492			sta 	StringTempPointer+1
.a81c	60		rts				rts
.a81d					StringTempAllocate:
.a81d	c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.a81f	b0 35		bcs $a856			bcs 	_STALength
.a821	2c 90 04	bit $0490			bit 	StringInitialised 			; already initialised
.a824	30 05		bmi $a82b			bmi 	_STAAllocate
.a826	48		pha				pha 								; save value to subtract.
.a827	20 07 a8	jsr $a807			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.a82a	68		pla				pla 								; restore it
.a82b					_STAAllocate:
.a82b	49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.a82d	18		clc				clc  								; deliberate allows one more
.a82e	6d 91 04	adc $0491			adc 	StringTempPointer 			; subtract from temp pointer
.a831	8d 91 04	sta $0491			sta 	StringTempPointer
.a834	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; address in mantissa
.a837	85 3c		sta $3c				sta 	zsTemp 						; and zsTemp
.a839	ad 92 04	lda $0492			lda 	StringTempPointer+1
.a83c	69 ff		adc #$ff			adc 	#$FF
.a83e	8d 92 04	sta $0492			sta 	StringTempPointer+1
.a841	85 3d		sta $3d				sta 	zsTemp+1
.a843	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a846	9e 18 04	stz $0418,x			stz 	NSMantissa2,x 				; set the typing data
.a849	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.a84c	a9 10		lda #$10			lda 	#NSTString
.a84e	9d 00 04	sta $0400,x			sta 	NSStatus,x
.a851	a9 00		lda #$00			lda 	#0 							; clear the target string
.a853	92 3c		sta ($3c)			sta 	(zsTemp)
.a855	60		rts				rts
.a856					_STALength:
.a856	a9 09		lda #$09		lda	#9
.a858	4c f1 8d	jmp $8df1		jmp	ErrorHandler
.a85b					StringTempWrite:
.a85b	48		pha				pha
.a85c	92 3c		sta ($3c)			sta 	(zsTemp)
.a85e	e6 3c		inc $3c				inc 	zsTemp
.a860	d0 02		bne $a864			bne 	_STWNoCarry
.a862	e6 3d		inc $3d				inc 	zsTemp+1
.a864					_STWNoCarry:
.a864	a9 00		lda #$00			lda 	#0
.a866	92 3c		sta ($3c)			sta 	(zsTemp)
.a868	68		pla				pla
.a869	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_hardware.module

=1					hardwareIntegrated=1
=0					CONBlack = 0
=1					CONWhite = 1
=2					CONRed = 2
=3					CONCyan = 3
=4					CONPurple = 4
=5					CONGreen = 5
=6					CONBlue = 6
=7					CONYellow = 7
=8					CONOrange = 8
=9					CONBrown = 9
=10					CONYellowGreen = 10
=11					CONRosa = 11
=12					CONBlueGreen = 12
=13					CONLightBlue = 13
=14					CONPink = 14
=15					CONLightGreen = 15
=7					CONForeground = CONYellow
=6					CONBackground = CONBlue
=12					CLINumber = CONBlueGreen
=3					CLIToken = CONCyan
=13					CLIConstant = CONLightBlue
=7					CLIIdentifier = CONYellow
=10					CLIPunctuation = CONYellowGreen
=1					CLIData = CONWhite
.a86a					EXTPrintCharacter:
.a86a	48		pha				pha
.a86b	da		phx				phx
.a86c	5a		phy				phy
.a86d	a6 01		ldx $01				ldx 	1
.a86f	da		phx				phx
.a870	ac 40 06	ldy $0640			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.a873	09 00		ora #$00			ora 	#$00 						; check $80-$FF
.a875	30 48		bmi $a8bf			bmi 	_EXPCColour
.a877	c9 20		cmp #$20			cmp 	#$20 						; check $00-$1F
.a879	90 4d		bcc $a8c8			bcc 	_EXPCControl
.a87b	a2 02		ldx #$02			ldx 	#2 							; select char memory
.a87d	86 01		stx $01				stx 	1
.a87f	91 40		sta ($40),y			sta 	(EXTAddress),y
.a881	e6 01		inc $01				inc 	1 							; select colour memory
.a883	ad 41 06	lda $0641			lda 	EXTTextColour
.a886	91 40		sta ($40),y			sta 	(EXTAddress),y
.a888	c8		iny				iny 								; advance horizontal position
.a889	8c 40 06	sty $0640			sty 	EXTColumn
.a88c	cc 42 06	cpy $0642			cpy 	EXTScreenWidth 				; reached RHS ?
.a88f	90 66		bcc $a8f7			bcc 	_EXPCExit 					; no, then exit.
.a891					_EXPCCRLF:
.a891	ee 3f 06	inc $063f			inc 	EXTRow  					; bump row
.a894	9c 40 06	stz $0640			stz 	EXTColumn 					; back to column 0
.a897	ad 3f 06	lda $063f			lda 	EXTRow 						; check if reached the bottom ?
.a89a	cd 43 06	cmp $0643			cmp 	EXTScreenHeight 			; if so, then scroll.
.a89d	f0 18		beq $a8b7			beq 	_EXPCScroll
.a89f	18		clc				clc 								; add width to address.
.a8a0	a5 40		lda $40				lda 	EXTAddress
.a8a2	6d 42 06	adc $0642			adc 	EXTScreenWidth
.a8a5	85 40		sta $40				sta 	EXTAddress
.a8a7	90 4e		bcc $a8f7			bcc 	_EXPCExit
.a8a9	e6 41		inc $41				inc 	EXTAddress+1
.a8ab	80 4a		bra $a8f7			bra 	_EXPCExit
.a8ad					_EXPCLeft:
.a8ad	ce 40 06	dec $0640			dec 	EXTColumn
.a8b0	10 45		bpl $a8f7			bpl 	_EXPCExit
.a8b2					_EXPCBegin:
.a8b2	9c 40 06	stz $0640			stz 	EXTColumn
.a8b5	80 40		bra $a8f7			bra 	_EXPCExit
.a8b7					_EXPCScroll:
.a8b7	ce 3f 06	dec $063f			dec 	EXTRow 						; the height-1 th line.
.a8ba	20 84 a9	jsr $a984			jsr 	EXTScreenScroll 			; scroll the screen
.a8bd	80 38		bra $a8f7			bra 	_EXPCExit
.a8bf					_EXPCColour:
.a8bf	c9 a0		cmp #$a0			cmp 	#$A0						; 80-9F set foreground/background
.a8c1	b0 34		bcs $a8f7			bcs 	_EXPCExit
.a8c3	20 64 a9	jsr $a964			jsr 	_EXPCHandleColour
.a8c6	80 2f		bra $a8f7			bra 	_EXPCExit
.a8c8					_EXPCControl:
.a8c8	c9 11		cmp #$11			cmp 	#$11 						; only handle 00-10.
.a8ca	b0 2b		bcs $a8f7			bcs 	_EXPCExit
.a8cc	0a		asl a				asl 	a 							; double into X
.a8cd	aa		tax				tax
.a8ce	7c 42 a9	jmp ($a942,x)			jmp 	(_EXPCActionTable,x) 		; and execute code.
.a8d1					_EXPCUp:
.a8d1	ad 3f 06	lda $063f			lda 	EXTRow 						; already at top ?
.a8d4	f0 21		beq $a8f7			beq 	_EXPCExit
.a8d6	ce 3f 06	dec $063f			dec 	EXTRow 						; up one in position/address
.a8d9	38		sec				sec
.a8da	a5 40		lda $40				lda 	EXTAddress
.a8dc	ed 42 06	sbc $0642			sbc 	EXTScreenWidth
.a8df	85 40		sta $40				sta 	EXTAddress
.a8e1	b0 14		bcs $a8f7			bcs 	_EXPCExit
.a8e3	c6 41		dec $41				dec 	EXTAddress+1
.a8e5	80 10		bra $a8f7			bra 	_EXPCExit
.a8e7					_EXPCRight:
.a8e7	c8		iny				iny
.a8e8	8c 40 06	sty $0640			sty 	EXTColumn
.a8eb	cc 42 06	cpy $0642			cpy 	EXTScreenWidth
.a8ee	d0 07		bne $a8f7			bne 	_EXPCExit
.a8f0					_EXPCEnd:
.a8f0	ad 42 06	lda $0642			lda 	EXTScreenWidth
.a8f3	3a		dec a				dec 	a
.a8f4	8d 40 06	sta $0640			sta 	EXTColumn
.a8f7					_EXPCExit:
.a8f7	20 d9 a9	jsr $a9d9			jsr 	EXTSetHardwareCursor 		; place the physical cursor.
.a8fa	68		pla				pla
.a8fb	85 01		sta $01				sta 	1
.a8fd	7a		ply				ply
.a8fe	fa		plx				plx
.a8ff	68		pla				pla
.a900	60		rts				rts
.a901					_EXPCClearScreen:
.a901	20 96 a9	jsr $a996			jsr		EXTClearScreenCode
.a904	80 f1		bra $a8f7			bra 	_EXPCExit
.a906					_EXPCDown:
.a906	ad 43 06	lda $0643			lda 	EXTScreenHeight 			; at the bottom
.a909	3a		dec a				dec 	a
.a90a	cd 3f 06	cmp $063f			cmp 	EXTRow
.a90d	f0 e8		beq $a8f7			beq 	_EXPCExit
.a90f	ee 3f 06	inc $063f			inc 	EXTRow 						; down one in position/address
.a912	18		clc				clc
.a913	a5 40		lda $40				lda 	EXTAddress
.a915	6d 42 06	adc $0642			adc 	EXTScreenWidth
.a918	85 40		sta $40				sta 	EXTAddress
.a91a	90 db		bcc $a8f7			bcc 	_EXPCExit
.a91c	e6 41		inc $41				inc 	EXTAddress+1
.a91e	80 d7		bra $a8f7			bra 	_EXPCExit
.a920					_EXPCTab:
.a920	ad 40 06	lda $0640			lda 	EXTColumn 					; next tab stop
.a923	29 f8		and #$f8			and 	#$F8
.a925	18		clc				clc
.a926	69 08		adc #$08			adc 	#8
.a928	8d 40 06	sta $0640			sta 	EXTColumn
.a92b	cd 42 06	cmp $0642			cmp 	EXTScreenWidth 				; too far, stick end of line.
.a92e	90 c7		bcc $a8f7			bcc 	_EXPCExit
.a930	80 be		bra $a8f0			bra 	_EXPCEnd
.a932					_EXPCBackSpace:
.a932	88		dey				dey
.a933	30 c2		bmi $a8f7			bmi 	_EXPCExit
.a935	ce 40 06	dec $0640			dec 	EXTColumn
.a938	a9 02		lda #$02			lda 	#2
.a93a	85 01		sta $01				sta 	1
.a93c	a9 20		lda #$20			lda 	#32
.a93e	91 40		sta ($40),y			sta 	(EXTAddress),y
.a940	80 b5		bra $a8f7			bra 	_EXPCExit
.a942					_EXPCActionTable:
>a942	f7 a8						.word 	_EXPCExit 					; 00
>a944	b2 a8						.word 	_EXPCBegin 					; 01 A Start of Line
>a946	ad a8						.word 	_EXPCLeft 					; 02 B Left
>a948	f7 a8						.word 	_EXPCExit 					; 03 <Break>
>a94a	f7 a8						.word 	_EXPCExit 					; 04
>a94c	f0 a8						.word 	_EXPCEnd 					; 05 E End of Line
>a94e	e7 a8						.word 	_EXPCRight 					; 06 F Right
>a950	f7 a8						.word 	_EXPCExit 					; 07
>a952	32 a9						.word 	_EXPCBackspace 				; 08 H Backspace
>a954	20 a9						.word 	_EXPCTab 					; 09 I Tab
>a956	f7 a8						.word 	_EXPCExit 					; 0A
>a958	f7 a8						.word 	_EXPCExit 					; 0B
>a95a	01 a9						.word 	_EXPCClearScreen			; 0C L CLS
>a95c	91 a8						.word 	_EXPCCRLF 					; 0D M CR/LF
>a95e	06 a9						.word 	_EXPCDown 					; 0E N Down
>a960	f7 a8						.word 	_EXPCExit 					; 0F
>a962	d1 a8						.word 	_EXPCUp 					; 10 P Up
.a964					_EXPCHandleColour
.a964	c9 90		cmp #$90			cmp 	#$90 						; 8x foreground 9x background
.a966	b0 16		bcs $a97e			bcs 	_EXPCBackground
.a968	0a		asl a				asl 	a 							; shift it 4 bits to the right.
.a969	0a		asl a				asl 	a
.a96a	0a		asl a				asl 	a
.a96b	0a		asl a				asl 	a
.a96c	a2 0f		ldx #$0f			ldx 	#$0F 						; Mask in X
.a96e					_EXPCUpdate:
.a96e	48		pha				pha 								; save new colour
.a96f	8a		txa				txa 								; get mask
.a970	2d 41 06	and $0641			and 	EXTTextColour 				; mask out old.
.a973	8d 41 06	sta $0641			sta 	EXTTextColour
.a976	68		pla				pla 								; or in new colour
.a977	0d 41 06	ora $0641			ora 	EXTTextColour
.a97a	8d 41 06	sta $0641			sta 	EXTTextColour
.a97d	60		rts				rts
.a97e					_EXPCBackground:
.a97e	29 0f		and #$0f			and 	#$0F 						; get the colour
.a980	a2 f0		ldx #$f0			ldx 	#$F0 						; mask
.a982	80 ea		bra $a96e			bra 	_EXPCUpdate
.a984					EXTScreenScroll:
.a984	a9 02		lda #$02			lda 	#2 							; select text page
.a986	85 01		sta $01				sta 	1
.a988	a9 20		lda #$20			lda		#32 						; fill with space
.a98a	20 99 aa	jsr $aa99			jsr 	EXTScrollFill
.a98d	e6 01		inc $01				inc 	1 							; select colour page
.a98f	ad 41 06	lda $0641			lda 	EXTTextColour
.a992	20 99 aa	jsr $aa99			jsr 	EXTScrollFill
.a995	60		rts				rts
.a996					EXTClearScreenCode:
.a996	a9 02		lda #$02			lda 	#2 							; select text page
.a998	85 01		sta $01				sta 	1
.a99a	a9 20		lda #$20			lda		#32 						; fill with space
.a99c	20 a9 a9	jsr $a9a9			jsr 	_EXTCSFill
.a99f	e6 01		inc $01				inc 	1 							; select colour page
.a9a1	ad 41 06	lda $0641			lda 	EXTTextColour
.a9a4	20 a9 a9	jsr $a9a9			jsr 	_EXTCSFill
.a9a7	80 22		bra $a9cb			bra 	EXTHomeCursor
.a9a9					_EXTCSFill:
.a9a9	aa		tax				tax
.a9aa	a9 00		lda #$00			lda 	#EXTMemory & $FF
.a9ac	85 40		sta $40				sta 	EXTAddress
.a9ae	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a9b0	85 41		sta $41				sta 	EXTAddress+1
.a9b2					_EXTCSFill1:
.a9b2	a0 00		ldy #$00			ldy 	#0
.a9b4	8a		txa				txa
.a9b5					_EXTCSFill2:
.a9b5	91 40		sta ($40),y			sta 	(EXTAddress),y
.a9b7	c8		iny				iny
.a9b8	d0 fb		bne $a9b5			bne 	_EXTCSFill2
.a9ba	e6 41		inc $41				inc 	EXTAddress+1
.a9bc	a5 41		lda $41				lda 	EXTAddress+1
.a9be	c9 d2		cmp #$d2			cmp 	#$D2
.a9c0	d0 f0		bne $a9b2			bne 	_EXTCSFill1
.a9c2	8a		txa				txa
.a9c3					_EXTCSFill3:
.a9c3	91 40		sta ($40),y			sta 	(EXTAddress),y
.a9c5	c8		iny				iny
.a9c6	c0 c0		cpy #$c0			cpy 	#$C0
.a9c8	d0 f9		bne $a9c3			bne 	_EXTCSFill3
.a9ca	60		rts				rts
.a9cb					EXTHomeCursor:
.a9cb	9c 3f 06	stz $063f			stz 	EXTRow 						; reset row & column
.a9ce	9c 40 06	stz $0640			stz 	EXTColumn
.a9d1	a9 00		lda #$00			lda 	#EXTMemory & $FF 			; set address
.a9d3	85 40		sta $40				sta 	EXTAddress
.a9d5	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a9d7	85 41		sta $41				sta 	EXTAddress+1
.a9d9					EXTSetHardwareCursor:
.a9d9	64 01		stz $01				stz 	1 							; I/O Page zero
.a9db	a9 05		lda #$05			lda 	#1+4 						; enable cursor
.a9dd	8d 10 d0	sta $d010			sta 	$D010
.a9e0	a9 b1		lda #$b1			lda 	#$B1
.a9e2	8d 12 d0	sta $d012			sta 	$D012
.a9e5	ad 40 06	lda $0640			lda 	EXTColumn
.a9e8	8d 14 d0	sta $d014			sta 	$D014 						; set cursor position
.a9eb	9c 15 d0	stz $d015			stz 	$D015
.a9ee	ad 3f 06	lda $063f			lda 	EXTRow
.a9f1	8d 16 d0	sta $d016			sta 	$D016
.a9f4	9c 17 d0	stz $d017			stz 	$D017
.a9f7	60		rts				rts
.a9f8					EXTInputLine:
.a9f8	48		pha				pha
.a9f9	da		phx				phx
.a9fa	5a		phy				phy
.a9fb	a5 01		lda $01				lda 	1 							; save I/O page
.a9fd	48		pha				pha
.a9fe					_EILLoop:
.a9fe	20 00 ab	jsr $ab00			jsr 	ExtInputSingleCharacter
.aa01	c9 0d		cmp #$0d			cmp 	#13 						; scrape line if exit.
.aa03	f0 40		beq $aa45			beq 	_EILExit
.aa05	c9 08		cmp #$08			cmp 	#8 							; handle backspace
.aa07	f0 1c		beq $aa25			beq 	_EILBackspace
.aa09	c9 20		cmp #$20			cmp 	#' '						; < space, print it
.aa0b	90 12		bcc $aa1f			bcc 	_EILPrintLoop
.aa0d	c9 7f		cmp #$7f			cmp 	#$7F 						; if -ve print it
.aa0f	b0 0e		bcs $aa1f			bcs 	_EILPrintLoop
.aa11	48		pha				pha 								; save character
.aa12	a9 02		lda #$02			lda 	#2  						; insert a space
.aa14	85 01		sta $01				sta 	1
.aa16	20 87 aa	jsr $aa87			jsr 	EXTILInsert 				; insert in text screen
.aa19	e6 01		inc $01				inc 	1
.aa1b	20 87 aa	jsr $aa87			jsr 	EXTILInsert 				; insert in colour screen
.aa1e	68		pla				pla 								; get character back.
.aa1f					_EILPrintLoop:
.aa1f	20 6a a8	jsr $a86a			jsr 	ExtPrintCharacter
.aa22	80 da		bra $a9fe			bra 	_EILLoop
.aa24	60		rts				rts
.aa25					_EILBackspace:
.aa25	ad 40 06	lda $0640			lda 	EXTColumn					; can we backspace ?
.aa28	f0 d4		beq $a9fe			beq 	_EILLoop
.aa2a	a9 02		lda #$02			lda 	#2 							; move cursor left
.aa2c	20 6a a8	jsr $a86a			jsr 	EXTPrintCharacter
.aa2f	a9 02		lda #$02			lda 	#2 							; text block
.aa31	85 01		sta $01				sta 	1
.aa33	a9 20		lda #$20			lda 	#' ' 						; backspace text.
.aa35	20 72 aa	jsr $aa72			jsr 	EXTILDelete
.aa38	e6 01		inc $01				inc 	1 							; colour block
.aa3a	ac 40 06	ldy $0640			ldy 	EXTColumn 					; get attribute of last character
.aa3d	88		dey				dey
.aa3e	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa40	20 72 aa	jsr $aa72			jsr 	EXTILDelete 				; backspace attribute
.aa43	80 b9		bra $a9fe			bra 	_EILLoop 					; and go round.
.aa45					_EILExit:
.aa45	a9 02		lda #$02			lda 	#2 							; switch to page 2
.aa47	85 01		sta $01				sta 	1
.aa49	a0 00		ldy #$00			ldy 	#0 							; copy current line into buffer.
.aa4b					_EILScrapeLine:
.aa4b	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa4d	99 a9 05	sta $05a9,y			sta 	lineBuffer,y
.aa50	c8		iny				iny
.aa51	cc 42 06	cpy $0642			cpy 	EXTScreenWidth
.aa54	d0 f5		bne $aa4b			bne 	_EILScrapeLine
.aa56					_EILTrimSpaces:
.aa56	88		dey				dey
.aa57	f0 08		beq $aa61			beq 	_EILEndTrim
.aa59	b9 a9 05	lda $05a9,y			lda 	lineBuffer,y
.aa5c	c9 20		cmp #$20			cmp 	#' '
.aa5e	f0 f6		beq $aa56			beq 	_EILTrimSpaces
.aa60	c8		iny				iny 								; trim after non space character.
.aa61					_EILEndTrim:
.aa61	a9 00		lda #$00			lda 	#0 							; trim here.
.aa63	99 a9 05	sta $05a9,y			sta 	lineBuffer,y
.aa66	a9 0d		lda #$0d			lda 	#13 						; echo the RETURN
.aa68	20 6a a8	jsr $a86a			jsr 	ExtPrintCharacter
.aa6b	68		pla				pla 								; reset I/O page
.aa6c	85 01		sta $01				sta 	1
.aa6e	7a		ply				ply
.aa6f	fa		plx				plx
.aa70	68		pla				pla
.aa71	60		rts				rts
.aa72					EXTILDelete:
.aa72	48		pha				pha 								; save the new character
.aa73	ac 40 06	ldy $0640			ldy 	EXTColumn 					; start copying from here.
.aa76					_EXTDLoop:
.aa76	c8		iny				iny 								; copy one byte down.
.aa77	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa79	88		dey				dey
.aa7a	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa7c	c8		iny				iny 								; do till end of line.
.aa7d	cc 42 06	cpy $0642			cpy 	EXTScreenWidth
.aa80	90 f4		bcc $aa76			bcc 	_EXTDLoop
.aa82	88		dey				dey 	 							; write in last slot.
.aa83	68		pla				pla
.aa84	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa86	60		rts				rts
.aa87					EXTILInsert:
.aa87	ac 42 06	ldy $0642			ldy 	EXTScreenWidth 				; end position
.aa8a					_EXTILoop:
.aa8a	88		dey				dey 								; back one
.aa8b	cc 40 06	cpy $0640			cpy 	EXTColumn 					; exit if reached insert point.
.aa8e	f0 08		beq $aa98			beq 	_EXTIExit
.aa90	88		dey				dey 								; copy one byte up.
.aa91	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa93	c8		iny				iny
.aa94	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa96	80 f2		bra $aa8a			bra 	_EXTILoop
.aa98					_EXTIExit:
.aa98	60		rts				rts
.aa99					EXTScrollFill:
.aa99	aa		tax				tax									; save value to fill with
.aa9a	a5 36		lda $36				lda 	zTemp0 						; save zTemp0 (dest) zTemp1 (src)
.aa9c	48		pha				pha
.aa9d	a5 37		lda $37				lda 	zTemp0+1
.aa9f	48		pha				pha
.aaa0	a5 38		lda $38				lda 	zTemp1
.aaa2	48		pha				pha
.aaa3	a5 39		lda $39				lda 	zTemp1+1
.aaa5	48		pha				pha
.aaa6	a9 c0		lda #$c0			lda 	#$C0 						; copy from C000+length to C000
.aaa8	85 37		sta $37				sta 	zTemp0+1
.aaaa	85 39		sta $39				sta 	zTemp1+1
.aaac	64 36		stz $36				stz 	zTemp0
.aaae	ad 42 06	lda $0642			lda 	EXTScreenWidth
.aab1	85 38		sta $38				sta 	zTemp1
.aab3	a0 00		ldy #$00			ldy 	#0
.aab5					_EXSFCopy1:
.aab5	b1 38		lda ($38),y			lda 	(zTemp1),y
.aab7	91 36		sta ($36),y			sta 	(zTemp0),y
.aab9	c8		iny				iny
.aaba	d0 f9		bne $aab5			bne 	_EXSFCopy1
.aabc	e6 37		inc $37				inc 	zTemp0+1 					; next page
.aabe	e6 39		inc $39				inc 	zTemp1+1
.aac0	a5 39		lda $39				lda 	zTemp1+1
.aac2	c9 d3		cmp #$d3			cmp 	#$D3
.aac4	d0 ef		bne $aab5			bne 	_EXSFCopy1
.aac6	ac 42 06	ldy $0642			ldy 	EXTScreenWidth 				; blank the bottom line.
.aac9	8a		txa				txa
.aaca					_EXSFFill1:
.aaca	88		dey				dey
.aacb	91 40		sta ($40),y			sta 	(EXTAddress),y
.aacd	c0 00		cpy #$00			cpy 	#0
.aacf	10 f9		bpl $aaca			bpl 	_EXSFFill1
.aad1	68		pla				pla
.aad2	85 39		sta $39				sta 	zTemp1+1
.aad4	68		pla				pla
.aad5	85 38		sta $38				sta 	zTemp1
.aad7	68		pla				pla
.aad8	85 37		sta $37				sta 	zTemp0+1
.aada	68		pla				pla
.aadb	85 36		sta $36				sta 	zTemp0
.aadd	60		rts				rts
=$c000					EXTMemory = $C000
=$02					EXTTextPage = $02
=$03					EXTColourPage = $03
=1					EXTDummySpace = 1 							; fake-space for CR character.
=0					EXTCBlack = 0
.063f					EXTRow:
>063f							.fill 	1
.0640					EXTColumn:
>0640							.fill 	1
.0641					EXTTextColour:
>0641							.fill 	1
.0642					EXTScreenWidth:
>0642							.fill 	1
.0643					EXTScreenHeight:
>0643							.fill 	1
.0040					EXTAddress:
>0040							.fill 	2
.aade					EXTInitialise:
.aade	64 01		stz $01				stz 	1 							; Access I/O
.aae0	9c 04 d0	stz $d004			stz 	$D004 						; Disable border
.aae3	9c 08 d0	stz $d008			stz 	$D008
.aae6	9c 09 d0	stz $d009			stz 	$D009
.aae9	a9 09		lda #$09			lda 	#1+8						; Timer On at 70Hz counting up.
.aaeb	8d 58 d6	sta $d658			sta 	$D658
.aaee	a9 76		lda #$76			lda 	#CONForeground * 16 + CONBackground
.aaf0	8d 41 06	sta $0641			sta 	EXTTextColour
.aaf3	a9 50		lda #$50			lda 	#80 						; set screen dimensions.
.aaf5	8d 42 06	sta $0642			sta 	EXTScreenWidth
.aaf8	a9 3c		lda #$3c			lda 	#60
.aafa	8d 43 06	sta $0643			sta 	EXTScreenHeight
.aafd	64 01		stz $01				stz 	1
.aaff	60		rts				rts
.ab00					EXTInputSingleCharacter:
.ab00	da		phx				phx
.ab01	5a		phy				phy
.ab02					_EISCWait:
.ab02	64 01		stz $01				stz 	1 							; access I/O Page 0
.ab04	38		sec				sec 								; calculate timer - LastTick
.ab05	ad 59 d6	lda $d659			lda 	$D659
.ab08	aa		tax				tax 								; saving timer in X
.ab09	ed 2e 06	sbc $062e			sbc 	LastTick
.ab0c	c9 03		cmp #$03			cmp 	#3
.ab0e	90 06		bcc $ab16			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.ab10	8e 2e 06	stx $062e			stx 	LastTick 					; update last timer
.ab13	20 85 ba	jsr $ba85			jsr 	TickHandler 				; go do the code.
.ab16					_NoFireTick:
.ab16	20 e4 ff	jsr $ffe4			jsr 	$FFE4
.ab19	c9 00		cmp #$00			cmp 	#0
.ab1b	f0 e5		beq $ab02			beq 	_EISCWait
.ab1d	7a		ply				ply
.ab1e	fa		plx				plx
.ab1f	60		rts				rts
.ab20					EXTBreakCheck:
.ab20	4c e1 ff	jmp $ffe1			jmp		$FFE1
.ab23					EXTReadController:
.ab23	da		phx				phx
.ab24	a2 00		ldx #$00			ldx 	#0
.ab26	a9 05		lda #$05			lda 	#(($2D) >> 3)
.ab28	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab2b	29 20		and #$20			and 	#($01 << (($2D) & 7))
.ab2d	f0 04		beq $ab33			beq 	_NoSet1
.ab2f	8a		txa				txa
.ab30	09 01		ora #$01			ora 	#1
.ab32	aa		tax				tax
.ab33					_NoSet1:
.ab33	a9 05		lda #$05			lda 	#(($2C) >> 3)
.ab35	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab38	29 10		and #$10			and 	#($01 << (($2C) & 7))
.ab3a	f0 04		beq $ab40			beq 	_NoSet1
.ab3c	8a		txa				txa
.ab3d	09 02		ora #$02			ora 	#2
.ab3f	aa		tax				tax
.ab40					_NoSet1:
.ab40	a9 06		lda #$06			lda 	#(($32) >> 3)
.ab42	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab45	29 04		and #$04			and 	#($01 << (($32) & 7))
.ab47	f0 04		beq $ab4d			beq 	_NoSet1
.ab49	8a		txa				txa
.ab4a	09 04		ora #$04			ora 	#4
.ab4c	aa		tax				tax
.ab4d					_NoSet1:
.ab4d	a9 04		lda #$04			lda 	#(($25) >> 3)
.ab4f	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab52	29 20		and #$20			and 	#($01 << (($25) & 7))
.ab54	f0 04		beq $ab5a			beq 	_NoSet1
.ab56	8a		txa				txa
.ab57	09 08		ora #$08			ora 	#8
.ab59	aa		tax				tax
.ab5a					_NoSet1:
.ab5a	a9 04		lda #$04			lda 	#(($26) >> 3)
.ab5c	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab5f	29 40		and #$40			and 	#($01 << (($26) & 7))
.ab61	f0 04		beq $ab67			beq 	_NoSet1
.ab63	8a		txa				txa
.ab64	09 10		ora #$10			ora 	#16
.ab66	aa		tax				tax
.ab67					_NoSet1:
.ab67	8a		txa				txa
.ab68	fa		plx				plx
.ab69	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_graphics.module

=1					graphicsIntegrated=1
=0					GCMD_Initialise = 0*2
=2					GCMD_BitmapCtl = 1*2
=4					GCMD_SpriteCtl = 2*2
=6					GCMD_Clear = 3*2
=8					GCMD_Colour = 4*2
=10					GCMD_DrawFont = 5*2
=12					GCMD_DrawSprite = 6*2
=14					GCMD_SpriteUse = 7*2
=16					GCMD_SpriteImage = 8*2
=18					GCMD_SpriteCollide = 9*2
=64					GCMD_Move = 32*2
=66					GCMD_Line = 33*2
=68					GCMD_FrameRect = 34*2
=70					GCMD_FillRect = 35*2
=72					GCMD_FrameCircle = 36*2
=74					GCMD_FillCircle = 37*2
=80					GCMD_Plot = 40*2
=82					GCMD_SpriteMove = 41*2
=42					GRFirstFreeCode = 42
.ba8b					GRVectorTable:
>ba8b	65 ad					.word	GXInitialise             ; $00 Initialise
>ba8d	7f ad					.word	GXControlBitmap          ; $01 BitmapCtl
>ba8f	c7 ad					.word	GXControlSprite          ; $02 SpriteCtl
>ba91	17 ad					.word	GXClearBitmap            ; $03 Clear
>ba93	56 af					.word	GXSetColourMode          ; $04 Colour
>ba95	1e b1					.word	GXFontHandler            ; $05 DrawFont
>ba97	66 b1					.word	GXSpriteHandler          ; $06 DrawSprite
>ba99	d2 b1					.word	GXSelect                 ; $07 SpriteUse
>ba9b	fb b1					.word	GXSelectImage            ; $08 SpriteImage
>ba9d	82 b3					.word	GXCollide                ; $09 SpriteCollide
>ba9f	c9 ab					.word	GRUndefined              ; $0a
>baa1	c9 ab					.word	GRUndefined              ; $0b
>baa3	c9 ab					.word	GRUndefined              ; $0c
>baa5	c9 ab					.word	GRUndefined              ; $0d
>baa7	c9 ab					.word	GRUndefined              ; $0e
>baa9	c9 ab					.word	GRUndefined              ; $0f
>baab	c9 ab					.word	GRUndefined              ; $10
>baad	c9 ab					.word	GRUndefined              ; $11
>baaf	c9 ab					.word	GRUndefined              ; $12
>bab1	c9 ab					.word	GRUndefined              ; $13
>bab3	c9 ab					.word	GRUndefined              ; $14
>bab5	c9 ab					.word	GRUndefined              ; $15
>bab7	c9 ab					.word	GRUndefined              ; $16
>bab9	c9 ab					.word	GRUndefined              ; $17
>babb	c9 ab					.word	GRUndefined              ; $18
>babd	c9 ab					.word	GRUndefined              ; $19
>babf	c9 ab					.word	GRUndefined              ; $1a
>bac1	c9 ab					.word	GRUndefined              ; $1b
>bac3	c9 ab					.word	GRUndefined              ; $1c
>bac5	c9 ab					.word	GRUndefined              ; $1d
>bac7	c9 ab					.word	GRUndefined              ; $1e
>bac9	c9 ab					.word	GRUndefined              ; $1f
>bacb	c7 ab					.word	GXMove                   ; $20 Move
>bacd	24 ae					.word	GXLine                   ; $21 Line
>bacf	9f af					.word	GXFrameRectangle         ; $22 FrameRect
>bad1	9c af					.word	GXFillRectangle          ; $23 FillRect
>bad3	ce ab					.word	GXFrameCircle            ; $24 FrameCircle
>bad5	ca ab					.word	GXFillCircle             ; $25 FillCircle
>bad7	c9 ab					.word	GRUndefined              ; $26
>bad9	c9 ab					.word	GRUndefined              ; $27
>badb	84 af					.word	GXPlotPoint              ; $28 Plot
>badd	91 b2					.word	GXMoveSprite             ; $29 SpriteMove
=3					GXMappingPage = 3
=24576					GXMappingAddress = ($2000 * GXMappingPage)
=11					GXEditSlot = 8 + GXMappingPage
=$36					gxzTemp0 = zTemp0
=$38					gxzTemp1 = zTemp1
=$3a					gxzTemp2 = zTemp2
=$3c					gxzScreen = zsTemp
=$5fa					gxPixelBuffer = numberBuffer
.0644					gxCurrentX:
>0644							.fill 	2
.0646					gxCurrentY:
>0646							.fill 	2
.0648					gxLastX:
>0648							.fill 	2
.064a					gxLastY:
>064a							.fill 	2
.064c					gxX0:
>064c							.fill 	2
.064e					gxY0:
>064e							.fill 	2
.0650					gxX1:
>0650							.fill 	2
.0652					gxY1:
>0652							.fill 	2
.0654					gxSpritesOn:
>0654							.fill 	1
.0655					gxBitmapsOn:
>0655							.fill 	1
.0656					gxBasePage:
>0656							.fill 	1
.0657					gxSpritePage:
>0657							.fill 	1
.0658					gxHeight:
>0658							.fill 	1
.0659					gxMode:
>0659							.fill 	1
.065a					gxColour:
>065a							.fill 	1
.065b					gxEORValue:
>065b							.fill 	1
.065c					gxANDValue:
>065c							.fill 	1
.065d					gxOriginalLUTValue:
>065d							.fill 	1
.065e					gsOffset:
>065e							.fill 	1
.065f					GSCurrentSpriteID:
>065f							.fill 	1
.0660					GSCurrentSpriteAddr:
>0660							.fill 	2
.0662					GXSpriteOffsetBase:
>0662							.fill 	2
.0664					GXSpriteLow:
>0664							.fill 	64
.06a4					GXSpriteHigh:
>06a4							.fill 	64
.ab6a					GXGraphicDraw:
.ab6a	c9 40		cmp #$40			cmp 	#GCMD_Move					; low instructions don't use coordinates
.ab6c	b0 06		bcs $ab74			bcs 	_GDCoordinate
.ab6e	86 36		stx $36				stx 	gxzTemp0 					; save X/Y
.ab70	84 37		sty $37				sty 	gxzTemp0+1
.ab72	80 4b		bra $abbf			bra 	_GDExecuteA 				; and execute
.ab74					_GDCoordinate:
.ab74	48		pha				pha 								; save AXY
.ab75	da		phx				phx
.ab76	5a		phy				phy
.ab77	a2 03		ldx #$03			ldx 	#3 							; copy currentX to lastX
.ab79					_GDCopy1:
.ab79	bd 44 06	lda $0644,x			lda 	gxCurrentX,x
.ab7c	9d 48 06	sta $0648,x			sta 	gxLastX,x
.ab7f	ca		dex				dex
.ab80	10 f7		bpl $ab79			bpl 	_GDCopy1
.ab82	68		pla				pla 								; update Y
.ab83	8d 46 06	sta $0646			sta 	gxCurrentY
.ab86	9c 47 06	stz $0647			stz 	gxCurrentY+1
.ab89	68		pla				pla
.ab8a	8d 44 06	sta $0644			sta 	gxCurrentX
.ab8d	68		pla				pla 								; get A (command+X.1) back
.ab8e	48		pha				pha
.ab8f	29 01		and #$01			and 	#1 							; put LSB as MSB of Current.X
.ab91	8d 45 06	sta $0645			sta 	gxCurrentX+1
.ab94	68		pla				pla 								; get command back
.ab95	29 fe		and #$fe			and 	#$FE 						; lose LSB, chuck the stray X bit
.ab97	48		pha				pha 								; push back.
.ab98	c9 52		cmp #$52			cmp 	#GCMD_SpriteMove 			; move sprite does not clip.
.ab9a	f0 17		beq $abb3			beq 	_GDCopyToWorkArea
.ab9c	ad 45 06	lda $0645			lda 	gxCurrentX+1 				; X < 256 X okay
.ab9f	f0 07		beq $aba8			beq 	_GDCheckY
.aba1	ad 44 06	lda $0644			lda 	gxCurrentX 					; otherwise X < 320 = 256 + 64
.aba4	c9 40		cmp #$40			cmp 	#64
.aba6	b0 08		bcs $abb0			bcs 	_GDError1
.aba8					_GDCheckY:
.aba8	ad 46 06	lda $0646			lda 	gxCurrentY 					; check Y < Height.
.abab	cd 58 06	cmp $0658			cmp 	gxHeight
.abae	90 03		bcc $abb3			bcc 	_GDCopyToWorkArea
.abb0					_GDError1:
.abb0	68		pla				pla
.abb1					_GDError2:
.abb1	38		sec				sec
.abb2	60		rts				rts
.abb3					_GDCopyToWorkArea:
.abb3	a2 07		ldx #$07			ldx 	#7 							; copy current and last to gxXY/12 work area
.abb5					_GDCopy2:
.abb5	bd 44 06	lda $0644,x			lda 	gxCurrentX,x
.abb8	9d 4c 06	sta $064c,x			sta 	gxX0,x
.abbb	ca		dex				dex
.abbc	10 f7		bpl $abb5			bpl 	_GDCopy2
.abbe	68		pla				pla 								; get command
.abbf					_GDExecuteA:
.abbf	c9 54		cmp #$54			cmp 	#GRFirstFreeCode*2 			; bad ?
.abc1	b0 ee		bcs $abb1			bcs 	_GDError2
.abc3	aa		tax				tax
.abc4	7c 8b ba	jmp ($ba8b,x)			jmp 	(GRVectorTable,x)
.abc7					GXMove:
.abc7	18		clc				clc
.abc8	60		rts				rts
.abc9					GRUndefined:
>abc9	db						.byte 	$DB 						; causes a break in the emulator
.abca					GXFillCircle:
.abca	a9 ff		lda #$ff			lda 	#255
.abcc	80 02		bra $abd0			bra 	GXCircle
.abce					GXFrameCircle:
.abce	a9 00		lda #$00			lda 	#0
.abd0					GXCircle:
.abd0	8d e7 06	sta $06e7			sta 	gxIsFillMode					; save Fill flag
.abd3	ad 55 06	lda $0655			lda 	gxBitmapsOn
.abd6	f0 26		beq $abfe			beq 	_GXCFail
.abd8	20 29 b4	jsr $b429			jsr 	GXSortXY 					; topleft/bottomright
.abdb	20 01 b3	jsr $b301			jsr 	GXOpenBitmap 				; start drawing
.abde	20 d0 ac	jsr $acd0			jsr 	GXCircleSetup 				; set up for drawing
.abe1	9c e8 06	stz $06e8			stz 	gxYChanged
.abe4					_GXCircleDraw:
.abe4	ad e5 06	lda $06e5			lda 	gXCentre					; while x <= y
.abe7	cd e6 06	cmp $06e6			cmp 	gYCentre
.abea	90 0a		bcc $abf6			bcc 	_GXCircleContinue
.abec	d0 03		bne $abf1			bne 	_GXNoLast
.abee	20 03 ac	jsr $ac03			jsr 	GXPlot1
.abf1					_GXNoLast:
.abf1	20 09 b3	jsr $b309			jsr 	GXCloseBitmap 				; close the bitmap
.abf4	18		clc				clc
.abf5	60		rts				rts
.abf6					_GXCircleContinue:
.abf6	20 00 ac	jsr $ac00			jsr 	GXPlot2 					; draw it
.abf9	20 7d ac	jsr $ac7d			jsr 	GXCircleMove 				; adjust the coordinates
.abfc	80 e6		bra $abe4			bra 	_GXCircleDraw
.abfe					_GXCFail:
.abfe	38		sec				sec
.abff	60		rts				rts
.ac00					GXPlot2:
.ac00	20 03 ac	jsr $ac03			jsr 	GXPlot1 						; plot and swap, fall through does twice
.ac03					GXPlot1:
.ac03	ad e6 06	lda $06e6			lda 	gYCentre 						; if y = 0, don't do it twice (xor)
.ac06	f0 03		beq $ac0b			beq 	_GXPlot1Only
.ac08	20 27 ac	jsr $ac27			jsr 	GXPlot0 						; plot and negate
.ac0b					_GXPlot1Only:
.ac0b	20 27 ac	jsr $ac27			jsr 	GXPlot0 						; twice, undoing negation
.ac0e	ad e5 06	lda $06e5			lda 	gXCentre 						; swap X and Y
.ac11	ae e6 06	ldx $06e6			ldx	 	gYCentre
.ac14	8d e6 06	sta $06e6			sta 	gYCentre
.ac17	8e e5 06	stx $06e5			stx 	gXCentre
.ac1a	ad e8 06	lda $06e8			lda 	gxYChanged 						; toggle Y Changed flag
.ac1d	a9 ff		lda #$ff			lda 	#$FF
.ac1f	8d e8 06	sta $06e8			sta 	gxYChanged
.ac22	60		rts				rts
.ac23	20 27 ac	jsr $ac27			jsr 	GXPlot0 						; do once
.ac26	60		rts				rts
.ac27	ad e7 06	lda $06e7	GXPlot0:lda 	gxIsFillMode 					; outline mode, always draw as X or Y will change
.ac2a	f0 05		beq $ac31			beq 	_GXPlot0Always
.ac2c	ad e8 06	lda $06e8			lda 	gxYChanged						; fill mode, only draw if changed.
.ac2f	f0 2d		beq $ac5e			beq 	GXPlot0Exit
.ac31					_GXPlot0Always:
.ac31	a2 02		ldx #$02			ldx 	#2 								; copy Y1-A => Y0
.ac33	ad e6 06	lda $06e6			lda 	gYCentre
.ac36	20 5f ac	jsr $ac5f			jsr 	GXSubCopy
.ac39	a2 00		ldx #$00			ldx 	#0 								; copy X1-A => X0,
.ac3b	ad e5 06	lda $06e5			lda 	gXCentre
.ac3e	20 5f ac	jsr $ac5f			jsr 	GXSubCopy
.ac41	48		pha				pha 									; save last offset X
.ac42	20 11 b3	jsr $b311			jsr 	GXPositionCalc 					; calculate position/offset.
.ac45	68		pla				pla
.ac46	0a		asl a				asl 	a 								; store 2 x last offset in gxzTemp0
.ac47	85 36		sta $36				sta 	gxzTemp0
.ac49	64 37		stz $37				stz 	gxzTemp0+1
.ac4b	26 37		rol $37				rol 	gxzTemp0+1
.ac4d	ad e7 06	lda $06e7			lda 	gxIsFillMode
.ac50	69 80		adc #$80			adc 	#128
.ac52	20 ef af	jsr $afef			jsr 	GXDrawLineTemp0 				; routine from Rectangle.
.ac55	38		sec				sec 									; GY = -GY
.ac56	a9 00		lda #$00			lda 	#0
.ac58	ed e6 06	sbc $06e6			sbc 	gYCentre
.ac5b	8d e6 06	sta $06e6			sta 	gYCentre
.ac5e					GXPlot0Exit:
.ac5e	60		rts				rts
.ac5f					GXSubCopy:
.ac5f	85 36		sta $36				sta 	gxzTemp0
.ac61	64 37		stz $37				stz 	gxzTemp0+1
.ac63	29 80		and #$80			and 	#$80
.ac65	f0 02		beq $ac69			beq 	_GXNoSx
.ac67	c6 37		dec $37				dec 	gxzTemp0+1
.ac69					_GXNoSx:
.ac69	38		sec				sec
.ac6a	bd 50 06	lda $0650,x			lda 	gXX1,x
.ac6d	e5 36		sbc $36				sbc 	gxzTemp0
.ac6f	9d 4c 06	sta $064c,x			sta 	gXX0,x
.ac72	bd 51 06	lda $0651,x			lda 	gXX1+1,x
.ac75	e5 37		sbc $37				sbc 	gxzTemp0+1
.ac77	9d 4d 06	sta $064d,x			sta 	gXX0+1,x
.ac7a	a5 36		lda $36				lda 	gxzTemp0 						; return A
.ac7c	60		rts				rts
.ac7d					GXCircleMove:
.ac7d	9c e8 06	stz $06e8			stz 	gxYChanged 					; clear Y changed flag
.ac80	a5 39		lda $39				lda 	gxzTemp1+1 					; check sign of D
.ac82	10 0d		bpl $ac91			bpl 	_GXEMPositive
.ac84	ee e5 06	inc $06e5			inc 	gXCentre 					; X++
.ac87	ad e5 06	lda $06e5			lda 	gXCentre
.ac8a	20 b0 ac	jsr $acb0			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.ac8d	a9 06		lda #$06			lda 	#6  						; and add 6
.ac8f	80 15		bra $aca6			bra 	_GXEMAddD
.ac91					_GXEMPositive:
.ac91	ee e5 06	inc $06e5			inc 	gXCentre					; X++
.ac94	ce e6 06	dec $06e6			dec 	gyCentre 					; Y--
.ac97	38		sec				sec 								; calculate X-Y
.ac98	ad e5 06	lda $06e5			lda 	gXCentre
.ac9b	ed e6 06	sbc $06e6			sbc 	gYCentre
.ac9e	20 b0 ac	jsr $acb0			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.aca1	a9 0a		lda #$0a			lda 	#10  						; and add 10
.aca3	ce e8 06	dec $06e8			dec 	gxYChanged
.aca6					_GXEMAddD:
.aca6	18		clc				clc
.aca7	65 38		adc $38				adc 	gxzTemp1
.aca9	85 38		sta $38				sta 	gxzTemp1
.acab	90 02		bcc $acaf			bcc 	_GXEMNoCarry
.acad	e6 39		inc $39				inc 	gxzTemp1+1
.acaf					_GXEMNoCarry:
.acaf	60		rts				rts
.acb0					_GXAdd4TimesToD:
.acb0	85 36		sta $36				sta 	gxzTemp0 					; make 16 bit signed.
.acb2	29 80		and #$80			and 	#$80
.acb4	f0 02		beq $acb8			beq 	_GXA4Unsigned
.acb6	a9 ff		lda #$ff			lda 	#$FF
.acb8					_GXA4Unsigned:
.acb8	85 37		sta $37				sta 	gxzTemp0+1
.acba	06 36		asl $36				asl 	gxzTemp0  					; x 4
.acbc	26 37		rol $37				rol 	gxzTemp0+1
.acbe	06 36		asl $36				asl 	gxzTemp0
.acc0	26 37		rol $37				rol 	gxzTemp0+1
.acc2	18		clc				clc 								; add
.acc3	a5 36		lda $36				lda		gxzTemp0
.acc5	65 38		adc $38				adc 	gxzTemp1
.acc7	85 38		sta $38				sta 	gxzTemp1
.acc9	a5 37		lda $37				lda		gxzTemp0+1
.accb	65 39		adc $39				adc 	gxzTemp1+1
.accd	85 39		sta $39				sta 	gxzTemp1+1
.accf	60		rts				rts
.acd0					GXCircleSetup:
.acd0	38		sec				sec
.acd1	ad 52 06	lda $0652			lda 	gxY1
.acd4	ed 4e 06	sbc $064e			sbc 	gxY0
.acd7	4a		lsr a				lsr 	a
.acd8	8d e4 06	sta $06e4			sta 	gxRadius
.acdb	a2 00		ldx #$00			ldx 	#0
.acdd	20 ff ac	jsr $acff			jsr 	_GXCalculateCentre
.ace0	a2 02		ldx #$02			ldx 	#2
.ace2	20 ff ac	jsr $acff			jsr 	_GXCalculateCentre
.ace5	9c e5 06	stz $06e5			stz 	gXCentre
.ace8	ad e4 06	lda $06e4			lda 	gxRadius
.aceb	8d e6 06	sta $06e6			sta 	gYCentre
.acee	0a		asl a				asl 	a 							; R x 2
.acef	85 36		sta $36				sta 	gxzTemp0
.acf1	38		sec				sec
.acf2	a9 03		lda #$03			lda 	#3
.acf4	e5 36		sbc $36				sbc 	gxzTemp0
.acf6	85 38		sta $38				sta 	gxzTemp1
.acf8	a9 00		lda #$00			lda 	#0
.acfa	e9 00		sbc #$00			sbc 	#0
.acfc	85 39		sta $39				sta 	gxzTemp1+1
.acfe	60		rts				rts
.acff					_GXCalculateCentre:
.acff	38		sec				sec
.ad00	bd 50 06	lda $0650,x			lda 	gxX1,x
.ad03	7d 4c 06	adc $064c,x			adc 	gXX0,x
.ad06	9d 50 06	sta $0650,x			sta 	gXX1,x
.ad09	bd 51 06	lda $0651,x			lda 	gXX1+1,x
.ad0c	7d 4d 06	adc $064d,x			adc 	gXX0+1,x
.ad0f	4a		lsr a				lsr 	a
.ad10	9d 51 06	sta $0651,x			sta 	gXX1+1,x
.ad13	7e 50 06	ror $0650,x			ror 	gXX1,x
.ad16	60		rts				rts
.06e4					gxRadius:
>06e4							.fill 	1
.06e5					gXCentre:
>06e5							.fill 	1
.06e6					gYCentre:
>06e6							.fill 	1
.06e7					gxIsFillMode:
>06e7							.fill 	1
.06e8					gxYChanged:
>06e8							.fill  	1
=64000					ScreenSize200 = 320 * 200
=76800					ScreenSize240 = 320 * 240
.ad17					GXClearBitmap:
.ad17	ad 55 06	lda $0655			lda 	gxBitmapsOn 				; check BMP running.
.ad1a	f0 24		beq $ad40			beq 	_GXCBFail
.ad1c	20 01 b3	jsr $b301			jsr 	GXOpenBitmap 				; start access
.ad1f	a0 07		ldy #$07			ldy 	#ScreenSize200 / 8192 		; X is pages to clear
.ad21	ad 58 06	lda $0658			lda 	gxHeight
.ad24	c9 c8		cmp #$c8			cmp 	#200 						; 200 ?
.ad26	a0 09		ldy #$09			ldy 	#ScreenSize240 / 8192
.ad28					_GXCalcLastPage:
.ad28	98		tya				tya 								; add to base page
.ad29	18		clc				clc
.ad2a	6d 56 06	adc $0656			adc 	gxBasePage
.ad2d	85 0b		sta $0b				sta 	GXEditSlot  				; clear from this page back
.ad2f					_GXClearAll:
.ad2f	20 42 ad	jsr $ad42			jsr 	_GXClearBlock 				; clear 8k block
.ad32	c6 0b		dec $0b				dec 	GXEditSlot  				; back to previous
.ad34	a5 0b		lda $0b				lda 	GXEditSlot
.ad36	cd 56 06	cmp $0656			cmp 	gxBasePage 					; until before base page
.ad39	b0 f4		bcs $ad2f			bcs 	_GXClearAll
.ad3b	20 09 b3	jsr $b309			jsr 	GXCloseBitmap	 			; stop access
.ad3e	18		clc				clc
.ad3f	60		rts				rts
.ad40					_GXCBFail:
.ad40	38		sec				sec
.ad41	60		rts				rts
.ad42					_GXClearBlock:
.ad42	a9 00		lda #$00			lda 	#((GXMappingAddress) & $FF)
.ad44	85 38		sta $38				sta 	0+gxzTemp1
.ad46	a9 60		lda #$60			lda 	#((GXMappingAddress) >> 8)
.ad48	85 39		sta $39				sta 	1+gxzTemp1
.ad4a					_GXCB0:
.ad4a	a5 36		lda $36				lda 	gxzTemp0
.ad4c	a0 00		ldy #$00			ldy 	#0
.ad4e					_GXCB1:
.ad4e	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad50	c8		iny				iny
.ad51	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad53	c8		iny				iny
.ad54	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad56	c8		iny				iny
.ad57	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad59	c8		iny				iny
.ad5a	d0 f2		bne $ad4e			bne 	_GXCB1
.ad5c	e6 39		inc $39				inc 	gxzTemp1+1
.ad5e	a5 39		lda $39				lda 	gxzTemp1+1
.ad60	c9 80		cmp #$80			cmp	 	#(GXMappingAddress >> 8)+$20
.ad62	d0 e6		bne $ad4a			bne 	_GXCB0
.ad64	60		rts				rts
.ad65					GXInitialise:
.ad65	64 01		stz $01				stz 	1
.ad67	a9 01		lda #$01			lda 	#1
.ad69	8d 00 d0	sta $d000			sta 	$D000
.ad6c	18		clc				clc
.ad6d	9c 54 06	stz $0654			stz 	GXSpritesOn
.ad70	9c 55 06	stz $0655			stz 	GXBitmapsOn
.ad73	a2 0f		ldx #$0f			ldx 	#15
.ad75					_GXIClear:
.ad75	9e 44 06	stz $0644,x			stz 	gxCurrentX,x
.ad78	ca		dex				dex
.ad79	10 fa		bpl $ad75			bpl 	_GXIClear
.ad7b	20 16 ae	jsr $ae16			jsr 	GXClearSpriteStore
.ad7e	60		rts				rts
.ad7f					GXControlBitmap:
.ad7f	64 01		stz $01				stz 	1
.ad81	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.ad83	29 01		and #$01			and 	#1 							; set bitmap flag
.ad85	8d 55 06	sta $0655			sta 	gxBitmapsOn
.ad88	4a		lsr a				lsr 	a 							; bit 0 into carry.
.ad89	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.ad8c	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.ad8e	29 f7		and #$f7			and 	#$F7 						; clear bitmap bit
.ad90	90 02		bcc $ad94			bcc 	_CBNotOn
.ad92	09 08		ora #$08			ora 	#$08 						; bitmap on if 1 on 0 off
.ad94					_CBNotOn:
.ad94	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.ad97	a5 36		lda $36				lda 	gxzTemp0 					; get control settings (bits 0-2)
.ad99	29 07		and #$07			and 	#7
.ad9b	8d 00 d1	sta $d100			sta 	$D100 						; write in Vicky Bitmap Control Register #0
.ad9e	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.ada0	d0 02		bne $ada4			bne 	_CBNotDefault
.ada2	a9 08		lda #$08			lda 	#8  						; if zero, use 8 e.g. bitmap at $10000
.ada4					_CBNotDefault:
.ada4	8d 56 06	sta $0656			sta 	gxBasePage
.ada7	20 08 ae	jsr $ae08			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.adaa	a5 37		lda $37				lda 	gxzTemp0+1 					; copy address into Bitmap address registers
.adac	8d 03 d1	sta $d103			sta 	$D103
.adaf	a5 36		lda $36				lda 	gxzTemp0
.adb1	8d 02 d1	sta $d102			sta 	$D102
.adb4	9c 01 d1	stz $d101			stz 	$D101
.adb7	a2 f0		ldx #$f0			ldx 	#240 						; height is 240
.adb9	ad 01 d0	lda $d001			lda 	$D001 						; read MCR bit 0
.adbc	29 01		and #$01			and 	#1
.adbe	f0 02		beq $adc2			beq 	_CBHaveHeight
.adc0	a2 c8		ldx #$c8			ldx 	#200 						; if bit 0 set 320x200
.adc2					_CBHaveHeight
.adc2	8e 58 06	stx $0658			stx 	gxHeight
.adc5	18		clc				clc
.adc6	60		rts				rts
.adc7					GXControlSprite:
.adc7	64 01		stz $01				stz 	1
.adc9	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.adcb	29 01		and #$01			and 	#1 							; set sprites flag
.adcd	8d 54 06	sta $0654			sta 	gxSpritesOn
.add0	4a		lsr a				lsr 	a 							; bit 0 into carry.
.add1	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.add4	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.add6	29 df		and #$df			and 	#$DF 						; clear sprite bit
.add8	90 02		bcc $addc			bcc 	_CSNotOn
.adda	09 20		ora #$20			ora 	#$20 						; sprite on if 1 on 0 off
.addc					_CSNotOn:
.addc	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.addf	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.ade1	d0 02		bne $ade5			bne 	_CSNotDefault
.ade3	a9 18		lda #$18			lda 	#24  						; if zero, use 24 e.g. sprites at $30000
.ade5					_CSNotDefault:
.ade5	8d 57 06	sta $0657			sta 	gxSpritePage
.ade8	20 08 ae	jsr $ae08			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.adeb	a5 36		lda $36				lda 	zTemp0
.aded	8d 62 06	sta $0662			sta 	GXSpriteOffsetBase
.adf0	a5 37		lda $37				lda 	zTemp0+1
.adf2	8d 63 06	sta $0663			sta 	GXSpriteOffsetBase+1
.adf5	a2 00		ldx #$00			ldx 	#0 							; disable all sprites, clears all sprite memory.
.adf7					_CSClear:
.adf7	9e 00 d9	stz $d900,x			stz 	$D900,x
.adfa	9e 00 da	stz $da00,x			stz 	$DA00,x
.adfd	ca		dex				dex
.adfe	d0 f7		bne $adf7			bne 	_CSClear
.ae00	9c 61 06	stz $0661			stz 	GSCurrentSpriteAddr+1 		; no sprite selected.
.ae03	20 16 ae	jsr $ae16			jsr 	GXClearSpriteStore
.ae06	18		clc				clc
.ae07	60		rts				rts
.ae08					GXCalculateBaseAddress:
.ae08	85 36		sta $36				sta 	gxzTemp0
.ae0a	64 37		stz $37				stz 	gxzTemp0+1
.ae0c	a9 05		lda #$05			lda 	#5
.ae0e					_GXShift:
.ae0e	06 36		asl $36				asl 	gxzTemp0
.ae10	26 37		rol $37				rol 	gxzTemp0+1
.ae12	3a		dec a				dec		a
.ae13	d0 f9		bne $ae0e			bne 	_GXShift
.ae15	60		rts				rts
.ae16					GXClearSpriteStore:
.ae16	a2 3f		ldx #$3f			ldx 	#63 						; erase 64 sprite store elements
.ae18					_GXCSSLoop:
.ae18	9e a4 06	stz $06a4,x			stz 	GXSpriteHigh,x
.ae1b	a9 80		lda #$80			lda 	#$80 						; set the 'hidden' bit.
.ae1d	9d 64 06	sta $0664,x			sta 	GXSpriteLow,x
.ae20	ca		dex				dex
.ae21	10 f5		bpl $ae18			bpl 	_GXCSSLoop
.ae23	60		rts				rts
.ae24					GXLine:
.ae24	ad 55 06	lda $0655			lda 	GXBitmapsOn
.ae27	f0 28		beq $ae51			beq 	_GXLFail
.ae29	20 01 b3	jsr $b301			jsr 	GXOpenBitmap
.ae2c	20 47 b4	jsr $b447			jsr 	GXSortY						; sort pairs so Y1 >= Y0 e.g. top to bottom.
.ae2f	20 f7 ae	jsr $aef7			jsr 	GXLineSetup 				; the calculations in the linescanner constructor
.ae32	20 11 b3	jsr $b311			jsr 	GXPositionCalc 				; calculate position/offset.
.ae35					_GXDrawLoop:
.ae35	ac 5e 06	ldy $065e			ldy 	gsOffset 					; draw the pixel
.ae38	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.ae3a	2d 5c 06	and $065c			and 	gxANDValue
.ae3d	4d 5b 06	eor $065b			eor 	gxEORValue
.ae40	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.ae42	20 53 ae	jsr $ae53			jsr 	GXLineIsComplete 			; is the line complete ?
.ae45	f0 05		beq $ae4c			beq 	_GXLExit
.ae47	20 6e ae	jsr $ae6e			jsr 	GXLineAdvance 				; code as per advance method
.ae4a	80 e9		bra $ae35			bra 	_GXDrawLoop
.ae4c					_GXLExit:
.ae4c	20 09 b3	jsr $b309			jsr 	GXCloseBitmap
.ae4f	18		clc				clc
.ae50	60		rts				rts
.ae51					_GXLFail:
.ae51	38		sec				sec
.ae52	60		rts				rts
.ae53					GXLineIsComplete:
.ae53	ad eb 06	lda $06eb			lda 	GXIsDiffYLarger 			; is dy larger
.ae56	d0 0f		bne $ae67			bne 	_GXLICCompareY 				; if so compare Y1/Y0
.ae58	ad 4c 06	lda $064c			lda 	GXX0 						; compare X, LSB and MSB
.ae5b	4d 50 06	eor $0650			eor 	GXX1
.ae5e	d0 06		bne $ae66			bne 	_GXLICExit
.ae60	ad 4d 06	lda $064d			lda 	GXX0+1
.ae63	4d 51 06	eor $0651			eor 	GXX1+1
.ae66					_GXLICExit:
.ae66	60		rts				rts
.ae67					_GXLICCompareY:
.ae67	ad 52 06	lda $0652			lda 	GXY1
.ae6a	4d 4e 06	eor $064e			eor 	GXY0
.ae6d	60		rts				rts
.ae6e					GXLineAdvance:
.ae6e	18		clc				clc 								; add adjust to position
.ae6f	ad ed 06	lda $06ed			lda 	GXPosition
.ae72	6d ee 06	adc $06ee			adc 	GXAdjust
.ae75	8d ed 06	sta $06ed			sta 	GXPosition
.ae78	9c f0 06	stz $06f0			stz 	GXAddSelect 				; clear add select flag
.ae7b	b0 05		bcs $ae82			bcs 	_GXLAOverflow 				; if carry out, overflowed.
.ae7d	cd ef 06	cmp $06ef			cmp 	GXTotal 					; if exceeded total
.ae80	90 0a		bcc $ae8c			bcc 	_GXLANoExtra
.ae82					_GXLAOverflow:
.ae82	ce f0 06	dec $06f0			dec 	GXAddSelect 				; set addselect to $FF
.ae85	38		sec				sec 								; subtract total and write back
.ae86	ed ef 06	sbc $06ef			sbc 	GXTotal
.ae89	8d ed 06	sta $06ed			sta 	GXPosition
.ae8c					_GXLANoExtra:
.ae8c	ad eb 06	lda $06eb			lda 	GXIsDiffYLarger
.ae8f	f0 0d		beq $ae9e			beq 	_GXDXLarger
.ae91	20 f0 ae	jsr $aef0			jsr 	GXIncrementY
.ae94	ad f0 06	lda $06f0			lda 	GXAddSelect
.ae97	f0 10		beq $aea9			beq 	_GXLAExit
.ae99	20 aa ae	jsr $aeaa			jsr 	GXAdjustX
.ae9c	80 0b		bra $aea9			bra 	_GXLAExit
.ae9e					_GXDXLarger:
.ae9e	20 aa ae	jsr $aeaa			jsr 	GXAdjustX
.aea1	ad f0 06	lda $06f0			lda 	GXAddSelect
.aea4	f0 03		beq $aea9			beq 	_GXLAExit
.aea6	20 f0 ae	jsr $aef0			jsr 	GXIncrementY
.aea9					_GXLAExit:
.aea9	60		rts				rts
.aeaa					GXAdjustX:
.aeaa	ad ec 06	lda $06ec			lda 	GXDXNegative
.aead	10 25		bpl $aed4			bpl 	_GXAXRight
.aeaf	ad 4c 06	lda $064c			lda 	GXX0
.aeb2	d0 03		bne $aeb7			bne 	_GXAXNoBorrow
.aeb4	ce 4d 06	dec $064d			dec 	GXX0+1
.aeb7					_GXAXNoBorrow:
.aeb7	ce 4c 06	dec $064c			dec 	GXX0
.aeba	ce 5e 06	dec $065e			dec 	gsOffset 					; pixel left
.aebd	ad 5e 06	lda $065e			lda 	gsOffset
.aec0	c9 ff		cmp #$ff			cmp 	#$FF
.aec2	d0 0f		bne $aed3			bne 	_GXAYExit 					; underflow
.aec4	c6 3d		dec $3d				dec 	gxzScreen+1 					; borrow
.aec6	a5 3d		lda $3d				lda 	gxzScreen+1 					; gone off page
.aec8	c9 60		cmp #$60			cmp 	#GXMappingAddress >> 8
.aeca	b0 07		bcs $aed3			bcs 	_GXAYExit
.aecc	18		clc				clc
.aecd	69 20		adc #$20			adc 	#$20 						; fix up
.aecf	85 3d		sta $3d				sta 	gxzScreen+1
.aed1	c6 0b		dec $0b				dec 	GXEditSlot 				; back one page
.aed3					_GXAYExit:
.aed3	60		rts				rts
.aed4					_GXAXRight:
.aed4	ee 4c 06	inc $064c			inc 	GXX0
.aed7	d0 03		bne $aedc			bne 	_GXAXNoCarry
.aed9	ee 4d 06	inc $064d			inc 	GXX0+1
.aedc					_GXAXNoCarry:
.aedc	ee 5e 06	inc $065e			inc 	gsOffset 					; pixel right
.aedf	d0 0e		bne $aeef			bne 	_GXAXExit 					; if not overflowed, exit.
.aee1	e6 3d		inc $3d				inc 	gxzScreen+1 					; next line
.aee3	a5 3d		lda $3d				lda 	gxzScreen+1
.aee5	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.aee7	90 06		bcc $aeef			bcc 	_GXAXExit
.aee9	e9 20		sbc #$20			sbc 	#$20 						; fix up
.aeeb	85 3d		sta $3d				sta 	gxzScreen+1
.aeed	e6 0b		inc $0b				inc 	GXEditSlot 				; next page
.aeef					_GXAXExit:
.aeef	60		rts				rts
.aef0					GXIncrementY:
.aef0	ee 4e 06	inc $064e			inc 	GXY0
.aef3	20 67 b3	jsr $b367			jsr 	GXMovePositionDown
.aef6	60		rts				rts
.aef7					GXLineSetup:
.aef7	ad 52 06	lda $0652			lda 	GXY1
.aefa	38		sec				sec
.aefb	ed 4e 06	sbc $064e			sbc 	GXY0
.aefe	4a		lsr a				lsr 	a
.aeff	8d ea 06	sta $06ea			sta 	GXDiffY
.af02	9c ec 06	stz $06ec			stz 	GXDXNegative 				; clear -ve flag
.af05	38		sec				sec
.af06	ad 50 06	lda $0650			lda 	GXX1
.af09	ed 4c 06	sbc $064c			sbc 	GXX0
.af0c	8d e9 06	sta $06e9			sta 	GXDiffX
.af0f	ad 51 06	lda $0651			lda 	GXX1+1 						; calculate MSB
.af12	ed 4d 06	sbc $064d			sbc 	GXX0+1
.af15	6a		ror a				ror 	a 							; rotate bit into DiffX halving it
.af16	6e e9 06	ror $06e9			ror 	GXDiffX
.af19	0a		asl a				asl 	a
.af1a	10 0c		bpl $af28			bpl 	_GDXNotNegative
.af1c	a9 00		lda #$00			lda 	#0 							; make absolute value of |dx|
.af1e	38		sec				sec
.af1f	ed e9 06	sbc $06e9			sbc 	GXDiffX
.af22	8d e9 06	sta $06e9			sta 	GXDiffX
.af25	ce ec 06	dec $06ec			dec 	GXDXNegative 				; -ve flag = $FF.
.af28					_GDXNotNegative:
.af28	9c eb 06	stz $06eb			stz 	GXIsDiffYLarger 			; clear larger flag
.af2b	ad ea 06	lda $06ea			lda 	GXDiffY 					; set adjust and total.
.af2e	8d ee 06	sta $06ee			sta 	GXAdjust
.af31	ad e9 06	lda $06e9			lda 	GXDiffX
.af34	8d ef 06	sta $06ef			sta 	GXTotal
.af37	ad ea 06	lda $06ea			lda 	GXDiffY 					; if dy > dx
.af3a	cd e9 06	cmp $06e9			cmp 	GXDiffX
.af3d	90 0f		bcc $af4e			bcc 	_GDXNotLarger
.af3f	ce eb 06	dec $06eb			dec 	GXIsDiffYLarger 			; set the dy larger flag
.af42	ad e9 06	lda $06e9			lda 	GXDiffX 					; set adjust and total other way round
.af45	8d ee 06	sta $06ee			sta 	GXAdjust
.af48	ad ea 06	lda $06ea			lda 	GXDiffY
.af4b	8d ef 06	sta $06ef			sta 	GXTotal
.af4e					_GDXNotLarger:
.af4e	ad ef 06	lda $06ef			lda 	GXTotal
.af51	4a		lsr a				lsr 	a
.af52	8d ed 06	sta $06ed			sta 	GXPosition
.af55	60		rts				rts
.06e9					GXDiffX:
>06e9							.fill 	1
.06ea					GXDiffY:
>06ea							.fill 	1
.06eb					GXIsDiffYLarger:
>06eb							.fill 	1
.06ec					GXDXNegative:
>06ec							.fill 	1
.06ed					GXPosition:
>06ed							.fill 	1
.06ee					GXAdjust:
>06ee							.fill 	1
.06ef					GXTotal:
>06ef							.fill 	1
.06f0					GXAddSelect:
>06f0							.fill 	1
.af56					GXSetColourMode:
.af56	a6 36		ldx $36				ldx 	gxzTemp0
.af58	8e 5a 06	stx $065a			stx 	gxColour 								; set colour
.af5b	a5 37		lda $37				lda 	gxzTemp0+1 								;
.af5d	8d 59 06	sta $0659			sta 	gxMode 									; set mode
.af60	29 03		and #$03			and 	#3 										; only interested in bits 0-3
.af62	9c 5c 06	stz $065c			stz 	gxANDValue 								; initially AND with 0, and EOR with Colour
.af65	ae 5a 06	ldx $065a			ldx 	gxColour
.af68	8e 5b 06	stx $065b			stx 	gxEORValue
.af6b	c9 02		cmp #$02			cmp 	#2 										; if mode 2/3 And with colour
.af6d	90 03		bcc $af72			bcc 	_GXSDCNotAndColour
.af6f	8e 5c 06	stx $065c			stx 	gxANDValue
.af72					_GXSDCNotAndColour:
.af72	d0 03		bne $af77			bne 	_GXSDCNotAnd 							; mode 2, Don't EOR with colour
.af74	9c 5b 06	stz $065b			stz 	gxEORValue
.af77					_GXSDCNotAnd:
.af77	4a		lsr a				lsr 	a 										; if bit 0 set, 1's complement AND value
.af78	90 08		bcc $af82			bcc 	_GXSDCNoFlip
.af7a	ad 5c 06	lda $065c			lda	 	gxANDValue
.af7d	49 ff		eor #$ff			eor 	#$FF
.af7f	8d 5c 06	sta $065c			sta 	gxANDValue
.af82					_GXSDCNoFlip:
.af82	18		clc				clc
.af83	60		rts				rts
.af84					GXPlotPoint:
.af84	20 01 b3	jsr $b301			jsr 	GXOpenBitmap 				; start drawing
.af87	20 11 b3	jsr $b311			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.af8a	ac 5e 06	ldy $065e			ldy 	gsOffset
.af8d	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.af8f	2d 5c 06	and $065c			and 	gxANDValue
.af92	4d 5b 06	eor $065b			eor 	gxEORValue
.af95	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.af97	20 09 b3	jsr $b309			jsr 	GXCloseBitmap 				; stop drawing and exit
.af9a	18		clc				clc
.af9b	60		rts				rts
.af9c					GXFillRectangle:
.af9c	38		sec				sec
.af9d	80 01		bra $afa0			bra 	GXRectangle
.af9f					GXFrameRectangle:
.af9f	18		clc				clc
.afa0					GXRectangle:
.afa0	ad 55 06	lda $0655			lda 	gxBitmapsOn
.afa3	f0 35		beq $afda			beq 	_GXRFail
.afa5	08		php				php 								; save Fill flag (CS)
.afa6	20 01 b3	jsr $b301			jsr 	GXOpenBitmap 				; start drawing
.afa9	20 29 b4	jsr $b429			jsr 	GXSortXY 					; sort both X and Y so top left/bottom right
.afac	20 11 b3	jsr $b311			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.afaf	38		sec				sec 								; sec = Draw line
.afb0	20 dc af	jsr $afdc			jsr 	GXDrawLineX1X0 				; draw a line length X1-X0
.afb3	ad 4e 06	lda $064e			lda 	gxY0 						; reached end of rectangle ?
.afb6	cd 52 06	cmp $0652			cmp 	gxY1
.afb9	f0 19		beq $afd4			beq 	_GXRectangleExit
.afbb					_GXRectLoop:
.afbb	20 67 b3	jsr $b367			jsr 	GXMovePositionDown 			; down one.
.afbe	ee 4e 06	inc $064e			inc 	gxY0 						; change Y pos
.afc1	ad 4e 06	lda $064e			lda 	gxY0 						; reached last line
.afc4	cd 52 06	cmp $0652			cmp 	gXY1
.afc7	f0 07		beq $afd0			beq 	_GXLastLine
.afc9	28		plp				plp 								; get flag back
.afca	08		php				php
.afcb	20 dc af	jsr $afdc			jsr 	GXDrawLineX1X0 				; draw horizontal line
.afce	80 eb		bra $afbb			bra 	_GXRectLoop
.afd0					_GXLastLine:
.afd0	38		sec				sec
.afd1	20 dc af	jsr $afdc			jsr 	GXDrawLineX1X0
.afd4					_GXRectangleExit:
.afd4	68		pla				pla 								; throw fill flag.
.afd5	20 09 b3	jsr $b309			jsr 	GXCloseBitmap 				; stop drawing and exit
.afd8	18		clc				clc
.afd9	60		rts				rts
.afda					_GXRFail:
.afda	38		sec				sec
.afdb	60		rts				rts
.afdc					GXDrawLineX1X0:
.afdc	08		php				php 								; save solid/either-end
.afdd	38		sec				sec
.afde	ad 50 06	lda $0650			lda		gXX1
.afe1	ed 4c 06	sbc $064c			sbc 	gXX0
.afe4	85 36		sta $36				sta 	gxzTemp0
.afe6	ad 51 06	lda $0651			lda 	gXX1+1
.afe9	ed 4d 06	sbc $064d			sbc 	gXX0+1
.afec	85 37		sta $37				sta 	gxzTemp0+1
.afee	28		plp				plp
.afef					GXDrawLineTemp0:
.afef	a5 3c		lda $3c				lda 	gxzScreen 						; push gxzScreen, gsOffset and GXEditSlot on stack
.aff1	48		pha				pha
.aff2	a5 3d		lda $3d				lda 	gxzScreen+1
.aff4	48		pha				pha
.aff5	ad 5e 06	lda $065e			lda 	gsOffset
.aff8	48		pha				pha
.aff9	a5 0b		lda $0b				lda 	GXEditSlot
.affb	48		pha				pha
.affc	ac 5e 06	ldy $065e			ldy 	gsOffset 					; Y offset
.afff	90 1e		bcc $b01f			bcc 	_GXDLTEndPoints 			; if CC draw end points only.
.b001					_GXDLTLine:
.b001	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.b003	2d 5c 06	and $065c			and 	gxANDValue
.b006	4d 5b 06	eor $065b			eor 	gxEORValue
.b009	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b00b	a5 36		lda $36				lda 	gxzTemp0 					; decrement counter
.b00d	d0 04		bne $b013			bne 	_GXDLTNoBorrow
.b00f	c6 37		dec $37				dec 	gxzTemp0+1 					; borrow, if goes -ve then exit
.b011	30 2e		bmi $b041			bmi 	_GXDLTExit
.b013					_GXDLTNoBorrow:
.b013	c6 36		dec $36				dec 	gxzTemp0
.b015	c8		iny				iny 								; next slot.
.b016	d0 e9		bne $b001			bne 	_GXDLTLine
.b018	e6 3d		inc $3d				inc 	gxzScreen+1 					; carry to next
.b01a	20 4f b0	jsr $b04f			jsr 	GXDLTCheckWrap				; check for new page.
.b01d	80 e2		bra $b001			bra 	_GXDLTLine
.b01f					_GXDLTEndPoints:
.b01f	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.b021	2d 5c 06	and $065c			and 	gxANDValue
.b024	4d 5b 06	eor $065b			eor 	gxEORValue
.b027	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b029	98		tya				tya 								; advance to right side
.b02a	18		clc				clc
.b02b	65 36		adc $36				adc 	gxzTemp0
.b02d	a8		tay				tay
.b02e	a5 3d		lda $3d				lda 	gxzScreen+1
.b030	65 37		adc $37				adc 	gxzTemp0+1
.b032	85 3d		sta $3d				sta 	gxzScreen+1
.b034	20 4f b0	jsr $b04f			jsr 	GXDLTCheckWrap 			; fix up.
.b037	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.b039	2d 5c 06	and $065c			and 	gxANDValue
.b03c	4d 5b 06	eor $065b			eor 	gxEORValue
.b03f	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b041					_GXDLTExit:
.b041	68		pla				pla
.b042	85 0b		sta $0b				sta 	GXEditSlot
.b044	68		pla				pla
.b045	8d 5e 06	sta $065e			sta 	gsOffset
.b048	68		pla				pla
.b049	85 3d		sta $3d				sta 	gxzScreen+1
.b04b	68		pla				pla
.b04c	85 3c		sta $3c				sta 	gxzScreen
.b04e	60		rts				rts
.b04f					GXDLTCheckWrap:
.b04f	a5 3d		lda $3d				lda 	gxzScreen+1 					; check end of page
.b051	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8)
.b053	90 06		bcc $b05b			bcc 	_GXDLTCWExit
.b055	e9 20		sbc #$20			sbc 	#$20 						; fix up
.b057	85 3d		sta $3d				sta 	gxzScreen+1
.b059	e6 0b		inc $0b				inc 	GXEditSlot
.b05b					_GXDLTCWExit:
.b05b	60		rts				rts
.b05c					GXDrawGraphicElement:
.b05c	8d f1 06	sta $06f1			sta 	gxSize 						; save size
.b05f	3a		dec a				dec 	a
.b060	8d f2 06	sta $06f2			sta 	gxMask 						; and mask
.b063	ad 55 06	lda $0655			lda 	gxBitmapsOn 				; check BMP on
.b066	f0 67		beq $b0cf			beq 	_GXSLFail
.b068	ad 4e 06	lda $064e			lda 	gxY0 						; push Y on stack
.b06b	48		pha				pha
.b06c	8c f4 06	sty $06f4			sty 	gxAcquireVector+1 			; and acquisition vector
.b06f	8e f3 06	stx $06f3			stx 	gxAcquireVector
.b072	20 01 b3	jsr $b301			jsr 	gxOpenBitmap 				; open the bitmap.
.b075	ad f6 06	lda $06f6			lda 	gxUseMode 					; scale bits
.b078	4a		lsr a				lsr 	a
.b079	4a		lsr a				lsr 	a
.b07a	4a		lsr a				lsr 	a
.b07b	29 07		and #$07			and		#7
.b07d	1a		inc a				inc 	a
.b07e	8d f5 06	sta $06f5			sta 	gxScale
.b081	64 38		stz $38				stz 	gxzTemp1					; start first line
.b083					_GXGELoop:
.b083	a5 38		lda $38				lda 	gxzTemp1 					; current line number to read.
.b085	2c f6 06	bit $06f6			bit 	gxUseMode 					; check for flip.
.b088	10 06		bpl $b090			bpl		_GXNoVFlip
.b08a	ad f2 06	lda $06f2			lda 	gxMask
.b08d	38		sec				sec
.b08e	e5 38		sbc $38				sbc 	gxzTemp1
.b090					_GXNoVFlip:
.b090	aa		tax				tax 								; get the Xth line.
.b091	20 d1 b0	jsr $b0d1			jsr 	_GXCallAcquire 				; get that data.
.b094	ad f5 06	lda $06f5			lda 	gxScale 					; do scale identical copies of that line.
.b097	85 39		sta $39				sta 	gxzTemp1+1
.b099					_GXGELoop2:
.b099	ad 4e 06	lda $064e			lda 	gxY0 						; off screen
.b09c	cd 58 06	cmp $0658			cmp 	gxHeight
.b09f	b0 10		bcs $b0b1			bcs 	_GXDGEExit
.b0a1	20 d4 b0	jsr $b0d4			jsr 	GXRenderOneLine 			; render line
.b0a4	c6 39		dec $39				dec 	gxzTemp1+1 					; scale times.
.b0a6	d0 f1		bne $b099			bne 	_GXGELoop2
.b0a8	e6 38		inc $38				inc 	gxzTemp1 					; done all lines.
.b0aa	a5 38		lda $38				lda 	gxzTemp1
.b0ac	cd f1 06	cmp $06f1			cmp 	gxSize
.b0af	d0 d2		bne $b083			bne 	_GXGELoop
.b0b1					_GXDGEExit:
.b0b1	68		pla				pla 								; restore Y for next time
.b0b2	8d 4e 06	sta $064e			sta 	gxY0
.b0b5	ae f5 06	ldx $06f5			ldx 	gxScale 					; get scale (1-8)
.b0b8					_GXShiftLeft:
.b0b8	18		clc				clc
.b0b9	ad f1 06	lda $06f1			lda 	gxSize
.b0bc	6d 4c 06	adc $064c			adc 	gxX0
.b0bf	8d 4c 06	sta $064c			sta 	gxX0
.b0c2	90 03		bcc $b0c7			bcc 	_GXSLNoCarry
.b0c4	ee 4d 06	inc $064d			inc 	gxX0+1
.b0c7					_GXSLNoCarry:
.b0c7	ca		dex				dex
.b0c8	d0 ee		bne $b0b8			bne 	_GXShiftLeft
.b0ca	20 09 b3	jsr $b309			jsr 	GXCloseBitmap
.b0cd	18		clc				clc
.b0ce	60		rts				rts
.b0cf					_GXSLFail:
.b0cf	38		sec				sec
.b0d0	60		rts				rts
.b0d1					_GXCallAcquire:
.b0d1	6c f3 06	jmp ($06f3)			jmp 	(gxAcquireVector)
.b0d4					GXRenderOneLine:
.b0d4	20 11 b3	jsr $b311			jsr 	GXPositionCalc 				; calculate position/offset.
.b0d7	ac 5e 06	ldy $065e			ldy 	gsOffset 					; Y contains position.
.b0da	64 3a		stz $3a				stz 	gxzTemp2 					; do size pixels
.b0dc					_GXROLLoop1:
.b0dc	ad f5 06	lda $06f5			lda 	gxScale 					; set to do 'scale' times
.b0df	85 3b		sta $3b				sta 	gxzTemp2+1
.b0e1					_GXROLLoop2:
.b0e1	a5 3a		lda $3a				lda 	gxzTemp2 					; get current pixel
.b0e3	2c 59 06	bit $0659			bit 	gxMode 						; check H Flip
.b0e6	50 06		bvc $b0ee			bvc 	_GXNoHFlip
.b0e8	ad f2 06	lda $06f2			lda 	gxMask
.b0eb	38		sec				sec
.b0ec	e5 3a		sbc $3a				sbc 	gxzTemp2
.b0ee					_GXNoHFlip:
.b0ee	aa		tax				tax 								; read from the pixel buffer
.b0ef	bd fa 05	lda $05fa,x			lda 	gxPixelBuffer,x
.b0f2	d0 07		bne $b0fb			bne 	_GXDraw 					; draw if non zero
.b0f4	ad f6 06	lda $06f6			lda 	gxUseMode 					; check to see if solid background
.b0f7	29 04		and #$04			and 	#4
.b0f9	f0 0a		beq $b105			beq 	_GXZeroPixel
.b0fb					_GXDraw:
.b0fb	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.b0fd	2d 5c 06	and $065c			and 	gxANDValue
.b100	5d fa 05	eor $05fa,x			eor 	gxPixelBuffer,x
.b103	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b105					_GXZeroPixel:
.b105	c8		iny				iny 								; advance pointer
.b106	d0 05		bne $b10d			bne 	_GXNoShift
.b108	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.b10a	20 4f b0	jsr $b04f			jsr 	GXDLTCheckWrap				; check for new page.
.b10d					_GXNoShift:
.b10d	c6 3b		dec $3b				dec 	gxzTemp2+1 					; do the inner loop gxScale times.
.b10f	d0 d0		bne $b0e1			bne 	_GXROLLoop2
.b111	e6 3a		inc $3a				inc 	gxzTemp2 					; next pixel.
.b113	a5 3a		lda $3a				lda 	gxzTemp2
.b115	cd f1 06	cmp $06f1			cmp 	gxSize
.b118	d0 c2		bne $b0dc			bne 	_GXROLLoop1
.b11a	ee 4e 06	inc $064e			inc 	gxY0
.b11d	60		rts				rts
.06f1					gxSize:
>06f1							.fill 	1
.06f2					gxMask:
>06f2							.fill 	1
.06f3					gxAcquireVector:
>06f3							.fill 	2
.06f5					gxScale:
>06f5							.fill 	1
.06f6					gxUseMode:
>06f6							.fill 	1
.b11e					GXFontHandler:
.b11e	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b120	4d 59 06	eor $0659			eor 	gxMode
.b123	8d f6 06	sta $06f6			sta 	gxUseMode
.b126	64 37		stz $37				stz 	gxzTemp0+1 					; gxzTemp0 is font #
.b128	06 36		asl $36				asl	 	gxzTemp0 					; x 2
.b12a	26 37		rol $37				rol	 	gxzTemp0+1
.b12c	06 36		asl $36				asl	 	gxzTemp0 					; x 4
.b12e	26 37		rol $37				rol	 	gxzTemp0+1
.b130	06 36		asl $36				asl	 	gxzTemp0 					; x 8
.b132	26 37		rol $37				rol	 	gxzTemp0+1
.b134	a5 37		lda $37				lda 	gxzTemp0+1 					; put in page C0
.b136	09 c0		ora #$c0			ora 	#$C0
.b138	85 37		sta $37				sta 	gxzTemp0+1
.b13a	a9 08		lda #$08			lda 	#8 							; size 8x8
.b13c	a2 44		ldx #$44			ldx 	#GXGetGraphicDataFont & $FF ; XY = Graphic Data retrieval routine
.b13e	a0 b1		ldy #$b1			ldy 	#GXGetGraphicDataFont >> 8
.b140	20 5c b0	jsr $b05c			jsr 	GXDrawGraphicElement
.b143	60		rts				rts
.b144					GXGetGraphicDataFont:
.b144	8a		txa				txa 								; X->Y
.b145	a8		tay				tay
.b146	a6 01		ldx $01				ldx 	1 							; preserve old value
.b148	a9 01		lda #$01			lda 	#1 							; access page 1 (font memory)
.b14a	85 01		sta $01				sta 	1
.b14c	b1 36		lda ($36),y			lda 	(gxzTemp0),y 				; read the font element.
.b14e	86 01		stx $01				stx 	1 							; put old value back.
.b150	a2 00		ldx #$00			ldx 	#0 							; do 8 times
.b152					_GXExpand:
.b152	9e fa 05	stz $05fa,x			stz 	gxPixelBuffer,x 			; zero in pixel buffer
.b155	0a		asl a				asl 	a 							; shift bit 7 into C
.b156	90 08		bcc $b160			bcc 	_GXNoPixel
.b158	48		pha				pha 								; if set, set pixel buffer to current colour.
.b159	ad 5a 06	lda $065a			lda 	gxColour
.b15c	9d fa 05	sta $05fa,x			sta 	gxPixelBuffer,x
.b15f	68		pla				pla
.b160					_GXNoPixel:
.b160	e8		inx				inx 								; do the whole byte.
.b161	e0 08		cpx #$08			cpx 	#8
.b163	d0 ed		bne $b152			bne 	_GXExpand
.b165	60		rts				rts
.b166					GXSpriteHandler:
.b166	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b168	4d 59 06	eor $0659			eor 	gxMode
.b16b	8d f6 06	sta $06f6			sta 	gxUseMode
.b16e	a6 36		ldx $36				ldx 	gxzTemp0 					; sprite #
.b170	da		phx				phx
.b171	20 01 b3	jsr $b301			jsr 	GXOpenBitmap 				; can access sprite information
.b174	68		pla				pla
.b175	20 e2 b3	jsr $b3e2			jsr 	GXFindSprite 				; get the sprite address
.b178	08		php				php
.b179	20 09 b3	jsr $b309			jsr 	GXCloseBitmap
.b17c	28		plp				plp
.b17d	b0 0a		bcs $b189			bcs		_GXSHExit 					; exit if find failed.
.b17f	ad f7 06	lda $06f7			lda 	GXSizePixels 				; return size
.b182	a2 8a		ldx #$8a			ldx 	#GXSpriteAcquire & $FF
.b184	a0 b1		ldy #$b1			ldy 	#GXSpriteAcquire >> 8
.b186	20 5c b0	jsr $b05c			jsr 	GXDrawGraphicElement
.b189					_GXSHExit:
.b189	60		rts				rts
.b18a					GXSpriteAcquire:
.b18a	ad 57 06	lda $0657			lda 	GXSpritePage				; point to base page
.b18d	85 0b		sta $0b				sta 	GXEditSlot
.b18f	86 36		stx $36				stx 	zTemp0 						; row number x 1,2,3,4
.b191	a9 00		lda #$00			lda 	#0
.b193	ae f8 06	ldx $06f8			ldx 	GXSizeBits
.b196					_GXTimesRowNumber:
.b196	18		clc				clc
.b197	65 36		adc $36				adc 	zTemp0
.b199	ca		dex				dex
.b19a	10 fa		bpl $b196			bpl 	_GXTimesRowNumber
.b19c	64 37		stz $37				stz 	gxzTemp0+1
.b19e	0a		asl a				asl 	a 							; row x 2,4,6,8
.b19f	26 37		rol $37				rol 	gxzTemp0+1
.b1a1	0a		asl a				asl 	a 							; row x 4,8,12,16
.b1a2	26 37		rol $37				rol 	gxzTemp0+1
.b1a4	0a		asl a				asl 	a 							; row x 8,16,24,32
.b1a5	26 37		rol $37				rol 	gxzTemp0+1
.b1a7	85 36		sta $36				sta 	gxzTemp0
.b1a9	18		clc				clc 								; add base address.
.b1aa	a5 36		lda $36				lda 	gxzTemp0
.b1ac	6d fa 06	adc $06fa			adc 	GXSpriteOffset
.b1af	85 36		sta $36				sta 	gxzTemp0
.b1b1	a5 37		lda $37				lda 	gxzTemp0+1
.b1b3	6d fb 06	adc $06fb			adc 	GXSpriteOffset+1
.b1b6					_GXSAFindPage:
.b1b6	c9 20		cmp #$20			cmp 	#$20 						; on this page
.b1b8	90 06		bcc $b1c0			bcc 	_GXSAFoundPage
.b1ba	e9 20		sbc #$20			sbc 	#$20 						; forward one page
.b1bc	e6 0b		inc $0b				inc 	GXEditSlot
.b1be	80 f6		bra $b1b6			bra 	_GXSAFindPage
.b1c0					_GXSAFoundPage:
.b1c0	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; physical address of page.
.b1c2	85 37		sta $37				sta 	gxzTemp0+1 					; gxzTemp0 now points to the page
.b1c4	a0 00		ldy #$00			ldy 	#0
.b1c6					_GXSACopyLoop:
.b1c6	b1 36		lda ($36),y			lda 	(gxzTemp0),y
.b1c8	99 fa 05	sta $05fa,y			sta 	gxPixelBuffer,y
.b1cb	c8		iny				iny
.b1cc	cc f7 06	cpy $06f7			cpy 	GXSizePixels
.b1cf	d0 f5		bne $b1c6			bne 	_GXSACopyLoop
.b1d1	60		rts				rts
.b1d2					GXSelect:
.b1d2	ad 54 06	lda $0654			lda 	gxSpritesOn
.b1d5	f0 22		beq $b1f9			beq 	_GXSFail
.b1d7	a5 36		lda $36				lda 	gxzTemp0 					; illegal sprite #
.b1d9	c9 40		cmp #$40			cmp 	#64
.b1db	b0 1c		bcs $b1f9			bcs 	_GXSFail
.b1dd	8d 5f 06	sta $065f			sta 	GSCurrentSpriteID
.b1e0	a4 37		ldy $37				ldy 	gxzTemp0+1 					; control value.
.b1e2	a9 00		lda #$00			lda  	#0 							; multiply sprite # x 8 => A
.b1e4	06 36		asl $36				asl 	gxzTemp0
.b1e6	06 36		asl $36				asl 	gxzTemp0
.b1e8	06 36		asl $36				asl 	gxzTemp0
.b1ea	2a		rol a				rol 	a
.b1eb	69 d9		adc #$d9			adc 	#$D9 						; sprite area
.b1ed	8d 61 06	sta $0661			sta 	GSCurrentSpriteAddr+1 		; address to GSCurrentSprite and gxzTemp
.b1f0	85 37		sta $37				sta 	gxzTemp0+1
.b1f2	a5 36		lda $36				lda 	gxzTemp0
.b1f4	8d 60 06	sta $0660			sta 	GSCurrentSpriteAddr
.b1f7	18		clc				clc
.b1f8	60		rts				rts
.b1f9					_GXSFail:
.b1f9	38		sec				sec
.b1fa	60		rts				rts
.b1fb					GXSelectImage:
.b1fb	ad 54 06	lda $0654			lda 	gxSpritesOn
.b1fe	f0 74		beq $b274			beq 	_GXSIFail
.b200	ad 61 06	lda $0661			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b203	f0 6f		beq $b274			beq 	_GXSIFail 					; (checking the MSB)
.b205	64 01		stz $01				stz 	1
.b207	a5 37		lda $37				lda 	gxzTemp0+1 					; push show/hide on the stack.
.b209	d0 6b		bne $b276			bne 	_GXSIHide
.b20b	a5 36		lda $36				lda 	gxzTemp0 					; sprite image
.b20d	48		pha				pha
.b20e	20 01 b3	jsr $b301			jsr 	GXOpenBitmap
.b211	68		pla				pla
.b212	20 e2 b3	jsr $b3e2			jsr 	GXFindSprite
.b215	b0 5a		bcs $b271			bcs 	_GXSICloseFail 				; no image
.b217	a0 01		ldy #$01			ldy 	#1
.b219	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr
.b21c	85 36		sta $36				sta 	gxzTemp0
.b21e	ad 61 06	lda $0661			lda 	GSCurrentSpriteAddr+1
.b221	85 37		sta $37				sta 	gxzTemp0+1
.b223	ad fa 06	lda $06fa			lda 	GXSpriteOffset
.b226	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b228	18		clc				clc
.b229	ad fb 06	lda $06fb			lda 	GXSpriteOffset+1
.b22c	6d 62 06	adc $0662			adc 	GXSpriteOffsetBase
.b22f	c8		iny				iny
.b230	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b232	ad 63 06	lda $0663			lda 	GXSpriteOffsetBase+1
.b235	69 00		adc #$00			adc 	#0
.b237	c8		iny				iny
.b238	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b23a	ad f8 06	lda $06f8			lda 	GXSizeBits 					; get raw size
.b23d	49 03		eor #$03			eor 	#3 							; make it right (00=32 etc.)
.b23f	2a		rol a				rol 	a 							; x 2
.b240	0a		asl a				asl 	a 							; x 4
.b241	0a		asl a				asl 	a 							; x 8
.b242	0a		asl a				asl 	a 							; x 16
.b243	0d f9 06	ora $06f9			ora 	GXSpriteLUT 				; Or with LUT
.b246	0a		asl a				asl 	a 							; 1 shift
.b247	09 01		ora #$01			ora 	#1 							; enable sprite.
.b249	92 36		sta ($36)			sta 	(gxzTemp0) 					; and write back
.b24b	20 09 b3	jsr $b309			jsr 	GXCloseBitmap
.b24e	ae 5f 06	ldx $065f			ldx 	GSCurrentSpriteID 			; point to sprite entries.
.b251	bd a4 06	lda $06a4,x			lda 	GXSpriteHigh,x 				; clear upper two bits of size
.b254	29 3f		and #$3f			and 	#$3F
.b256	9d a4 06	sta $06a4,x			sta 	GXSpriteHigh,x
.b259	ad f8 06	lda $06f8			lda 	GXSizeBits 					; get bit size
.b25c	6a		ror a				ror 	a 							; shift into bits 6/7
.b25d	6a		ror a				ror 	a
.b25e	6a		ror a				ror 	a
.b25f	29 c0		and #$c0			and 	#$C0
.b261	1d a4 06	ora $06a4,x			ora 	GXSpriteHigh,x 				; put in  upper 2 bits of sprite data
.b264	9d a4 06	sta $06a4,x			sta 	GXSpriteHigh,x
.b267	bd 64 06	lda $0664,x			lda 	GXSpriteLow,x 				; clear hidden flag.
.b26a	29 7f		and #$7f			and 	#$7F
.b26c	9d 64 06	sta $0664,x			sta 	GXSpriteLow,x
.b26f	18		clc				clc
.b270	60		rts				rts
.b271					_GXSICloseFail:
.b271	20 09 b3	jsr $b309			jsr 	GXCloseBitmap
.b274					_GXSIFail:
.b274	38		sec				sec
.b275	60		rts				rts
.b276					_GXSIHide:
.b276	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr  		; get Sprite h/w address and write there
.b279	85 36		sta $36				sta 	gxzTemp0
.b27b	ad 61 06	lda $0661			lda 	GSCurrentSpriteAddr+1
.b27e	85 37		sta $37				sta 	gxzTemp0+1
.b280	a9 00		lda #$00			lda 	#0
.b282	92 36		sta ($36)			sta 	(gxzTemp0)
.b284	ae 5f 06	ldx $065f			ldx 	GSCurrentSpriteID 			; get sprite ID
.b287	bd 64 06	lda $0664,x			lda 	GXSpriteLow,x 				; set the hidden bit.
.b28a	09 80		ora #$80			ora 	#$80
.b28c	9d 64 06	sta $0664,x			sta 	GXSpriteLow,x
.b28f	18		clc				clc
.b290	60		rts				rts
.b291					GXMoveSprite:
.b291	ad 54 06	lda $0654			lda 	gxSpritesOn
.b294	f0 65		beq $b2fb			beq 	_GXSIFail
.b296	ad 61 06	lda $0661			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b299	f0 60		beq $b2fb			beq 	_GXSIFail
.b29b	85 37		sta $37				sta 	gxzTemp0+1
.b29d	a0 04		ldy #$04			ldy 	#4
.b29f	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr
.b2a2	85 36		sta $36				sta 	gxzTemp0
.b2a4	ae 5f 06	ldx $065f			ldx 	GSCurrentSpriteID 			; get the size from the upper two bits
.b2a7	bd a4 06	lda $06a4,x			lda 	GXSpriteHigh,x
.b2aa	2a		rol a				rol 	a	 						; into bits 0,1.
.b2ab	2a		rol a				rol 	a
.b2ac	2a		rol a				rol 	a
.b2ad	29 03		and #$03			and 	#3
.b2af	aa		tax				tax
.b2b0	bd fd b2	lda $b2fd,x			lda 	_GXMSOffset,x 				; get 32-SpriteSize/2
.b2b3	48		pha				pha
.b2b4	18		clc				clc
.b2b5	6d 4c 06	adc $064c			adc 	gxX0						; copy position.
.b2b8	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2ba	c8		iny				iny
.b2bb	ad 4d 06	lda $064d			lda 	gxX0+1
.b2be	69 00		adc #$00			adc 	#0
.b2c0	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2c2	c8		iny				iny
.b2c3	68		pla				pla
.b2c4	18		clc				clc
.b2c5	6d 4e 06	adc $064e			adc 	gxY0
.b2c8	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2ca	a9 00		lda #$00			lda 	#0
.b2cc	69 00		adc #$00			adc 	#0
.b2ce	c8		iny				iny
.b2cf	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2d1	4e 4d 06	lsr $064d			lsr 	gxX0+1 						; divide X by 4
.b2d4	6e 4c 06	ror $064c			ror 	gxX0
.b2d7	4e 4c 06	lsr $064c			lsr 	gxX0
.b2da	4e 4e 06	lsr $064e			lsr 	gxY0 						; divide Y by 4
.b2dd	4e 4e 06	lsr $064e			lsr 	gxY0
.b2e0	ae 5f 06	ldx $065f			ldx 	GSCurrentSpriteID 			; copy X/4 and Y/4 into the status bytes
.b2e3	bd 64 06	lda $0664,x			lda 	GXSpriteLow,x
.b2e6	29 80		and #$80			and 	#$80
.b2e8	0d 4c 06	ora $064c			ora 	gxX0
.b2eb	9d 64 06	sta $0664,x			sta 	GXSpriteLow,x
.b2ee	bd a4 06	lda $06a4,x			lda 	GXSpriteHigh,x
.b2f1	29 c0		and #$c0			and 	#$C0
.b2f3	0d 4e 06	ora $064e			ora 	gxY0
.b2f6	9d a4 06	sta $06a4,x			sta 	GXSpriteHigh,x
.b2f9	18		clc				clc
.b2fa	60		rts				rts
.b2fb					_GXSIFail:
.b2fb	38		sec				sec
.b2fc	60		rts				rts
.b2fd					_GXMSOffset:
>b2fd	1c						.byte 	32-8/2
>b2fe	18						.byte 	32-16/2
>b2ff	14						.byte 	32-24/2
>b300	10						.byte 	32-32/2
.b301					GXOpenBitmap:
.b301	78		sei				sei 								; no interrupts here
.b302	a5 0b		lda $0b				lda 	GXEditSlot 					; Save the original LUT slot value
.b304	8d 5d 06	sta $065d			sta 	gxOriginalLUTValue
.b307	58		cli				cli
.b308	60		rts				rts
.b309					GXCloseBitmap:
.b309	78		sei				sei
.b30a	ad 5d 06	lda $065d			lda 	gxOriginalLUTValue 			; restore LUT slot value
.b30d	85 0b		sta $0b				sta 	GXEditSlot
.b30f	58		cli				cli
.b310	60		rts				rts
.b311					GXPositionCalc:
.b311	a5 36		lda $36				lda 	gxzTemp0 					; save temp memory slot
.b313	48		pha				pha
.b314	ad 4e 06	lda $064e			lda 	GXY0 						; gxzScreen = Y0
.b317	85 3c		sta $3c				sta 	gxzScreen
.b319	64 3d		stz $3d				stz 	gxzScreen+1
.b31b	06 3c		asl $3c				asl 	gxzScreen 						; gxzScreen = Y0 * 4
.b31d	26 3d		rol $3d				rol 	gxzScreen+1
.b31f	06 3c		asl $3c				asl 	gxzScreen
.b321	26 3d		rol $3d				rol 	gxzScreen+1
.b323	18		clc				clc 								; gxzScreen = Y0 * 5, as it's still in A
.b324	65 3c		adc $3c				adc 	gxzScreen
.b326	85 3c		sta $3c				sta 	gxzScreen
.b328	90 02		bcc $b32c			bcc 	_GXPCNoCarry
.b32a	e6 3d		inc $3d				inc 	gxzScreen+1
.b32c					_GXPCNoCarry:
.b32c	06 3c		asl $3c				asl 	gxzScreen 						; now Y0 * 10. Needs to be multiplied by another
.b32e	26 3d		rol $3d				rol 	gxzScreen+1 					; 32. At this point the MSB contains the offset
.b330	a5 3d		lda $3d				lda	 	gxzScreen+1 					; so save this in zTemp0 and zero it.
.b332	85 36		sta $36				sta 	gxzTemp0
.b334	64 3d		stz $3d				stz 	gxzScreen+1
.b336	a9 05		lda #$05			lda 	#5 							; now multiply by 32, this puts this in the range 0..8191
.b338					_GXPCMultiply32:
.b338	06 3c		asl $3c				asl 	gxzScreen
.b33a	26 3d		rol $3d				rol 	gxzScreen+1
.b33c	3a		dec a				dec 	a
.b33d	d0 f9		bne $b338			bne 	_GXPCMultiply32
.b33f	18		clc				clc
.b340	ad 4c 06	lda $064c			lda 	GXX0 						; add X to this value, put the result in gsOffset, gxzScreen has to be on a page boundary
.b343	65 3c		adc $3c				adc 	gxzScreen
.b345	8d 5e 06	sta $065e			sta 	gsOffset
.b348	ad 4d 06	lda $064d			lda 	GXX0+1
.b34b	65 3d		adc $3d				adc 	gxzScreen+1
.b34d	c9 20		cmp #$20			cmp 	#$20 						; has it overflowed into the next one ?
.b34f	90 04		bcc $b355			bcc 	_GXPCNoOverflow
.b351	29 1f		and #$1f			and 	#$1F 						; fix it up
.b353	e6 36		inc $36				inc 	gxzTemp0 					; add 1 to the page number
.b355					_GXPCNoOverflow:
.b355	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; make it the address mapped in.
.b357	85 3d		sta $3d				sta 	gxzScreen+1
.b359	64 3c		stz $3c				stz 	gxzScreen
.b35b	18		clc				clc
.b35c	a5 36		lda $36				lda 	gxzTemp0 					; get the page number
.b35e	6d 56 06	adc $0656			adc 	gxBasePage 					; by adding the base page
.b361	85 0b		sta $0b				sta 	GXEditSlot 				; and map it into memory.
.b363	68		pla				pla
.b364	85 36		sta $36				sta 	gxzTemp0
.b366	60		rts				rts
.b367					GXMovePositionDown:
.b367	18		clc				clc 								; add 320 to offset/temp+1
.b368	ad 5e 06	lda $065e			lda 	gsOffset
.b36b	69 40		adc #$40			adc 	#64
.b36d	8d 5e 06	sta $065e			sta 	gsOffset
.b370	a5 3d		lda $3d				lda 	gxzScreen+1
.b372	69 01		adc #$01			adc 	#1
.b374	85 3d		sta $3d				sta 	gxzScreen+1
.b376	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page
.b378	90 07		bcc $b381			bcc 	_GXMPDExit
.b37a	38		sec				sec  								; next page
.b37b	e9 20		sbc #$20			sbc 	#$20
.b37d	85 3d		sta $3d				sta 	gxzScreen+1
.b37f	e6 0b		inc $0b				inc 	GXEditSlot
.b381					_GXMPDExit:
.b381	60		rts				rts
.b382					GXCollide:
.b382	a5 36		lda $36				lda 	gxzTemp0 					; check if sprite numbers are legal.
.b384	aa		tax				tax
.b385	05 37		ora $37				ora 	gxzTemp0+1
.b387	29 c0		and #$c0			and 	#$C0
.b389	38		sec				sec
.b38a	d0 53		bne $b3df			bne 	_GXCollideFail 				; if either >= 64, fail.
.b38c	a4 37		ldy $37				ldy 	gxzTemp0+1 					; at this point X is 1st sprite and Y is 2nd sprite.
.b38e	b9 64 06	lda $0664,y			lda 	GXSpriteLow,y 				; check if either hidden bit is set
.b391	1d 64 06	ora $0664,x			ora 	GXSpriteLow,x
.b394	30 48		bmi $b3de			bmi 	_GXOkayFail 				; if either hidden, then they cannot collide.
.b396	18		clc				clc 								; need to calculate sum of sizes.
.b397	b9 a4 06	lda $06a4,y			lda 	GXSpriteHigh,y
.b39a	7d a4 06	adc $06a4,x			adc 	GXSpriteHigh,x 				; at this point, CS, Bit 6 and 7 contain that sum.
.b39d	29 c0		and #$c0			and 	#$C0 					 	; mask off
.b39f	6a		ror a				ror 	a 							; 5/6/7
.b3a0	4a		lsr a				lsr 	a 							; 4/5/6
.b3a1	4a		lsr a				lsr 	a 							; 3/4/5
.b3a2	4a		lsr a				lsr 	a 							; 2/3/4
.b3a3	18		clc				clc
.b3a4	69 08		adc #$08			adc 	#$08
.b3a6	4a		lsr a				lsr 	a 							; adjust because all coordinates are divided by 4 to store.
.b3a7	4a		lsr a				lsr 	a
.b3a8	85 38		sta $38				sta 	gxzTemp1 					; so the difference between the centres has to be less than this.
.b3aa	b9 a4 06	lda $06a4,y			lda 	GXSpriteHigh,y 				; calculate y1-y0
.b3ad	29 3f		and #$3f			and 	#$3F
.b3af	85 39		sta $39				sta 	gxzTemp1+1
.b3b1	38		sec				sec
.b3b2	bd a4 06	lda $06a4,x			lda 	GXSpriteHigh,x
.b3b5	29 3f		and #$3f			and 	#$3F
.b3b7	e5 39		sbc $39				sbc 	gxzTemp1+1
.b3b9	b0 03		bcs $b3be			bcs 	_GXCAbs1 					; calculate |y1-y0|
.b3bb	49 ff		eor #$ff			eor 	#$FF
.b3bd	1a		inc a				inc 	a
.b3be					_GXCAbs1:
.b3be	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b3c0	b0 1c		bcs $b3de			bcs 	_GXOkayFail
.b3c2	85 39		sta $39				sta 	gxzTemp1+1 					; save |y1-y0|
.b3c4	38		sec				sec 								; calculate |x1-x0|
.b3c5	b9 64 06	lda $0664,y			lda 	GXSpriteLow,y
.b3c8	fd 64 06	sbc $0664,x			sbc 	GXSpriteLow,x
.b3cb	b0 03		bcs $b3d0			bcs 	_GXCAbs2
.b3cd	49 ff		eor #$ff			eor 	#$FF
.b3cf	1a		inc a				inc 	a
.b3d0					_GXCAbs2:
.b3d0	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b3d2	b0 0a		bcs $b3de			bcs 	_GXOkayFail
.b3d4	c5 39		cmp $39				cmp 	gxzTemp1+1 					; is it less than the previous one.
.b3d6	90 02		bcc $b3da			bcc 	_GXCHaveLowest
.b3d8	a5 39		lda $39				lda 	gxzTemp1+1 					; if not, that's the smallest difference.
.b3da					_GXCHaveLowest:
.b3da	0a		asl a				asl 	a 							; scale to allow for >> 2
.b3db	0a		asl a				asl 	a
.b3dc	18		clc				clc
.b3dd	60		rts				rts
.b3de					_GXOkayFail:
.b3de	18		clc				clc
.b3df					_GXCollideFail:
.b3df	a9 ff		lda #$ff			lda 	#$FF
.b3e1	60		rts				rts
.b3e2					GXFindSprite:
.b3e2	aa		tax				tax
.b3e3	ad 57 06	lda $0657			lda 	GXSpritePage 				; access the base page of the sprite
.b3e6	85 0b		sta $0b				sta 	GXEditSlot
.b3e8	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; check a valid sprite
.b3eb	1d 00 60	ora $6000,x			ora 	GXMappingAddress,x
.b3ee	f0 33		beq $b423			beq 	_GXFSFail
.b3f0	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; MSB
.b3f3	8d fb 06	sta $06fb			sta 	GXSpriteOffset+1
.b3f6	bd 00 60	lda $6000,x			lda 	GXMappingAddress,x 			; LSB
.b3f9	48		pha				pha 								; save twice
.b3fa	48		pha				pha
.b3fb	29 03		and #$03			and 	#3 							; get sprite size
.b3fd	8d f8 06	sta $06f8			sta 	GXSizeBits 					; save raw (0-3)
.b400	aa		tax				tax
.b401	bd 25 b4	lda $b425,x			lda 	_GXFXSSTTable,x 			; read sprite size
.b404	8d f7 06	sta $06f7			sta 	GXSizePixels 					; save (8/16/24/32)
.b407	68		pla				pla 								; get LUT
.b408	4a		lsr a				lsr		a
.b409	4a		lsr a				lsr		a
.b40a	29 03		and #$03			and 	#3
.b40c	8d f9 06	sta $06f9			sta 	GXSpriteLUT
.b40f	68		pla				pla 								; address, neeeds to be x 4
.b410	29 f0		and #$f0			and 	#$F0
.b412	8d fa 06	sta $06fa			sta 	GXSpriteOffset
.b415	0e fa 06	asl $06fa			asl 	GXSpriteOffset
.b418	2e fb 06	rol $06fb			rol 	GXSpriteOffset+1
.b41b	0e fa 06	asl $06fa			asl 	GXSpriteOffset
.b41e	2e fb 06	rol $06fb			rol 	GXSpriteOffset+1
.b421	18		clc				clc
.b422	60		rts				rts
.b423					_GXFSFail:
.b423	38		sec				sec
.b424	60		rts				rts
.b425					_GXFXSSTTable:
>b425	08 10 18 20					.byte 	8,16,24,32
.06f7					GXSizePixels:
>06f7							.fill 	1
.06f8					GXSizeBits:
>06f8							.fill 	1
.06f9					GXSpriteLUT:
>06f9							.fill 	1
.06fa					GXSpriteOffset:
>06fa							.fill 	2
.b429					GXSortXY:
.b429	20 47 b4	jsr $b447			jsr 	GXSortY 					; will be sorted on Y now
.b42c	ad 4c 06	lda $064c			lda 	gxX0 						; compare X0 v X1
.b42f	cd 50 06	cmp $0650			cmp 	gxX1
.b432	ad 4d 06	lda $064d			lda 	gXX0+1
.b435	ed 51 06	sbc $0651			sbc 	gXX1+1
.b438	90 0c		bcc $b446			bcc 	_GXSXYExit 					; X0 < X1 exit
.b43a	a2 00		ldx #$00			ldx 	#0 							; swap them over
.b43c	a0 04		ldy #$04			ldy 	#4
.b43e	20 5b b4	jsr $b45b			jsr 	GXSwapXY
.b441	e8		inx				inx
.b442	c8		iny				iny
.b443	20 5b b4	jsr $b45b			jsr 	GXSwapXY
.b446					_GXSXYExit:
.b446	60		rts				rts
.b447					GXSortY:
.b447	ad 4e 06	lda $064e			lda 	gxY0 						; if Y0 >= Y1
.b44a	cd 52 06	cmp $0652			cmp 	gxY1
.b44d	90 0b		bcc $b45a			bcc 	_GXSYSorted
.b44f	a2 03		ldx #$03			ldx 	#3 							; swap 3-0
.b451	a0 07		ldy #$07			ldy 	#7 							; with 4-7
.b453					_GXSwap1:
.b453	20 5b b4	jsr $b45b			jsr 	GXSwapXY
.b456	88		dey				dey
.b457	ca		dex				dex
.b458	10 f9		bpl $b453			bpl 	_GXSwap1
.b45a					_GXSYSorted:
.b45a	60		rts				rts
.b45b					GXSwapXY:
.b45b	bd 4c 06	lda $064c,x			lda 	gxX0,x
.b45e	48		pha				pha
.b45f	b9 4c 06	lda $064c,y			lda 	gxX0,y
.b462	9d 4c 06	sta $064c,x			sta 	gxX0,x
.b465	68		pla				pla
.b466	99 4c 06	sta $064c,y			sta 	gxX0,y
.b469	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_tokeniser.module

=1					tokeniserIntegrated=1
.badf					KeywordSet0:
>badf	00 65					.text	0,$65,""               ; $80 !0:EOF
>bae1	00 58					.text	0,$58,""               ; $81 !1:SH1
>bae3	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bae5	04 fe 41 42 53 28			.text	4,$fe,"ABS("           ; $83 ABS(
>baeb	06 93 41 4c 4c 4f 43 28			.text	6,$93,"ALLOC("         ; $84 ALLOC(
>baf3	04 ff 41 53 43 28			.text	4,$ff,"ASC("           ; $85 ASC(
>baf9	05 29 43 48 52 24 28			.text	5,$29,"CHR$("          ; $86 CHR$(
>bb00	06 aa 45 56 45 4e 54 28			.text	6,$aa,"EVENT("         ; $87 EVENT(
>bb08	05 6b 46 41 4c 53 45			.text	5,$6b,"FALSE"          ; $88 FALSE
>bb0f	05 44 46 52 41 43 28			.text	5,$44,"FRAC("          ; $89 FRAC(
>bb16	04 0d 48 49 54 28			.text	4,$0d,"HIT("           ; $8a HIT(
>bb1c	04 13 49 4e 54 28			.text	4,$13,"INT("           ; $8b INT(
>bb22	06 a7 49 53 56 41 4c 28			.text	6,$a7,"ISVAL("         ; $8c ISVAL(
>bb2a	05 5c 4a 4f 59 42 28			.text	5,$5c,"JOYB("          ; $8d JOYB(
>bb31	05 72 4a 4f 59 58 28			.text	5,$72,"JOYX("          ; $8e JOYX(
>bb38	05 73 4a 4f 59 59 28			.text	5,$73,"JOYY("          ; $8f JOYY(
>bb3f	06 77 4c 45 46 54 24 28			.text	6,$77,"LEFT$("         ; $90 LEFT$(
>bb47	04 07 4c 45 4e 28			.text	4,$07,"LEN("           ; $91 LEN(
>bb4d	04 0e 4d 41 58 28			.text	4,$0e,"MAX("           ; $92 MAX(
>bb53	05 26 4d 49 44 24 28			.text	5,$26,"MID$("          ; $93 MID$(
>bb5a	04 0c 4d 49 4e 28			.text	4,$0c,"MIN("           ; $94 MIN(
>bb60	04 19 4e 4f 54 28			.text	4,$19,"NOT("           ; $95 NOT(
>bb66	08 3c 50 4c 41 59 49 4e			.text	8,$3c,"PLAYING("       ; $96 PLAYING(
>bb6e	47 28
>bb70	07 e9 52 41 4e 44 4f 4d			.text	7,$e9,"RANDOM("        ; $97 RANDOM(
>bb78	28
>bb79	07 ca 52 49 47 48 54 24			.text	7,$ca,"RIGHT$("        ; $98 RIGHT$(
>bb81	28
>bb82	04 0c 52 4e 44 28			.text	4,$0c,"RND("           ; $99 RND(
>bb88	04 10 53 47 4e 28			.text	4,$10,"SGN("           ; $9a SGN(
>bb8e	04 0e 53 50 43 28			.text	4,$0e,"SPC("           ; $9b SPC(
>bb94	05 45 53 54 52 24 28			.text	5,$45,"STR$("          ; $9c STR$(
>bb9b	06 a9 54 49 4d 45 52 28			.text	6,$a9,"TIMER("         ; $9d TIMER(
>bba3	04 40 54 52 55 45			.text	4,$40,"TRUE"           ; $9e TRUE
>bba9	04 0b 56 41 4c 28			.text	4,$0b,"VAL("           ; $9f VAL(
>bbaf	03 e7 46 4f 52				.text	3,$e7,"FOR"            ; $a0 FOR
>bbb4	02 8f 49 46				.text	2,$8f,"IF"             ; $a1 IF
>bbb8	04 34 50 52 4f 43			.text	4,$34,"PROC"           ; $a2 PROC
>bbbe	06 c1 52 45 50 45 41 54			.text	6,$c1,"REPEAT"         ; $a3 REPEAT
>bbc6	05 79 57 48 49 4c 45			.text	5,$79,"WHILE"          ; $a4 WHILE
>bbcd	05 66 45 4e 44 49 46			.text	5,$66,"ENDIF"          ; $a5 ENDIF
>bbd4	07 0b 45 4e 44 50 52 4f			.text	7,$0b,"ENDPROC"        ; $a6 ENDPROC
>bbdc	43
>bbdd	04 3f 4e 45 58 54			.text	4,$3f,"NEXT"           ; $a7 NEXT
>bbe3	04 2f 54 48 45 4e			.text	4,$2f,"THEN"           ; $a8 THEN
>bbe9	05 8c 55 4e 54 49 4c			.text	5,$8c,"UNTIL"          ; $a9 UNTIL
>bbf0	04 2e 57 45 4e 44			.text	4,$2e,"WEND"           ; $aa WEND
>bbf6	02 9b 42 59				.text	2,$9b,"BY"             ; $ab BY
>bbfa	04 1c 43 41 4c 4c			.text	4,$1c,"CALL"           ; $ac CALL
>bc00	06 b2 43 49 52 43 4c 45			.text	6,$b2,"CIRCLE"         ; $ad CIRCLE
>bc08	05 67 43 4c 45 41 52			.text	5,$67,"CLEAR"          ; $ae CLEAR
>bc0f	03 e2 43 4c 53				.text	3,$e2,"CLS"            ; $af CLS
>bc14	05 7f 43 4f 4c 4f 52			.text	5,$7f,"COLOR"          ; $b0 COLOR
>bc1b	06 d4 43 4f 4c 4f 55 52			.text	6,$d4,"COLOUR"         ; $b1 COLOUR
>bc23	04 1a 44 41 54 41			.text	4,$1a,"DATA"           ; $b2 DATA
>bc29	03 da 44 49 4d				.text	3,$da,"DIM"            ; $b3 DIM
>bc2e	06 db 44 4f 57 4e 54 4f			.text	6,$db,"DOWNTO"         ; $b4 DOWNTO
>bc36	04 29 45 4c 53 45			.text	4,$29,"ELSE"           ; $b5 ELSE
>bc3c	04 34 46 52 4f 4d			.text	4,$34,"FROM"           ; $b6 FROM
>bc42	03 e5 47 46 58				.text	3,$e5,"GFX"            ; $b7 GFX
>bc47	05 80 47 4f 53 55 42			.text	5,$80,"GOSUB"          ; $b8 GOSUB
>bc4e	04 39 47 4f 54 4f			.text	4,$39,"GOTO"           ; $b9 GOTO
>bc54	04 24 48 45 52 45			.text	4,$24,"HERE"           ; $ba HERE
>bc5a	05 63 49 4d 41 47 45			.text	5,$63,"IMAGE"          ; $bb IMAGE
>bc61	05 90 49 4e 50 55 54			.text	5,$90,"INPUT"          ; $bc INPUT
>bc68	03 e5 4c 45 54				.text	3,$e5,"LET"            ; $bd LET
>bc6d	04 28 4c 49 4e 45			.text	4,$28,"LINE"           ; $be LINE
>bc73	05 6b 4c 4f 43 41 4c			.text	5,$6b,"LOCAL"          ; $bf LOCAL
>bc7a	03 db 4f 46 46				.text	3,$db,"OFF"            ; $c0 OFF
>bc7f	02 9d 4f 4e				.text	2,$9d,"ON"             ; $c1 ON
>bc83	07 20 4f 55 54 4c 49 4e			.text	7,$20,"OUTLINE"        ; $c2 OUTLINE
>bc8b	45
>bc8c	07 0f 50 41 4c 45 54 54			.text	7,$0f,"PALETTE"        ; $c3 PALETTE
>bc94	45
>bc95	04 3f 50 4c 4f 54			.text	4,$3f,"PLOT"           ; $c4 PLOT
>bc9b	05 8d 50 52 49 4e 54			.text	5,$8d,"PRINT"          ; $c5 PRINT
>bca2	04 1c 52 45 41 44			.text	4,$1c,"READ"           ; $c6 READ
>bca8	04 2e 52 45 43 54			.text	4,$2e,"RECT"           ; $c7 RECT
>bcae	03 e4 52 45 4d				.text	3,$e4,"REM"            ; $c8 REM
>bcb3	06 e0 52 45 54 55 52 4e			.text	6,$e0,"RETURN"         ; $c9 RETURN
>bcbb	05 7b 53 4f 4c 49 44			.text	5,$7b,"SOLID"          ; $ca SOLID
>bcc2	05 89 53 4f 55 4e 44			.text	5,$89,"SOUND"          ; $cb SOUND
>bcc9	06 d7 53 50 52 49 54 45			.text	6,$d7,"SPRITE"         ; $cc SPRITE
>bcd1	04 45 54 45 58 54			.text	4,$45,"TEXT"           ; $cd TEXT
>bcd7	02 a3 54 4f				.text	2,$a3,"TO"             ; $ce TO
>bcdb	ff					.text	$FF
.bcdc					KeywordSet1:
>bcdc	00 65					.text	0,$65,""               ; $80 !0:EOF
>bcde	00 58					.text	0,$58,""               ; $81 !1:SH1
>bce0	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bce2	08 4c 41 53 53 45 4d 42			.text	8,$4c,"ASSEMBLE"       ; $83 ASSEMBLE
>bcea	4c 45
>bcec	06 d2 41 53 53 45 52 54			.text	6,$d2,"ASSERT"         ; $84 ASSERT
>bcf4	06 bd 42 49 54 4d 41 50			.text	6,$bd,"BITMAP"         ; $85 BITMAP
>bcfc	03 d7 45 4e 44				.text	3,$d7,"END"            ; $86 END
>bd01	04 3c 4c 49 53 54			.text	4,$3c,"LIST"           ; $87 LIST
>bd07	03 ea 4e 45 57				.text	3,$ea,"NEW"            ; $88 NEW
>bd0c	07 24 52 45 53 54 4f 52			.text	7,$24,"RESTORE"        ; $89 RESTORE
>bd14	45
>bd15	03 f5 52 55 4e				.text	3,$f5,"RUN"            ; $8a RUN
>bd1a	07 2a 53 50 52 49 54 45			.text	7,$2a,"SPRITES"        ; $8b SPRITES
>bd22	53
>bd23	04 46 53 54 4f 50			.text	4,$46,"STOP"           ; $8c STOP
>bd29	03 ee 57 48 4f				.text	3,$ee,"WHO"            ; $8d WHO
>bd2e	ff					.text	$FF
.bd2f					KeywordSet2:
>bd2f	00 65					.text	0,$65,""               ; $80 !0:EOF
>bd31	00 58					.text	0,$58,""               ; $81 !1:SH1
>bd33	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bd35	03 c8 41 44 43				.text	3,$c8,"ADC"            ; $83 ADC
>bd3a	03 d3 41 4e 44				.text	3,$d3,"AND"            ; $84 AND
>bd3f	03 e0 41 53 4c				.text	3,$e0,"ASL"            ; $85 ASL
>bd44	03 c8 42 43 43				.text	3,$c8,"BCC"            ; $86 BCC
>bd49	03 d8 42 43 53				.text	3,$d8,"BCS"            ; $87 BCS
>bd4e	03 d8 42 45 51				.text	3,$d8,"BEQ"            ; $88 BEQ
>bd53	03 df 42 49 54				.text	3,$df,"BIT"            ; $89 BIT
>bd58	03 d8 42 4d 49				.text	3,$d8,"BMI"            ; $8a BMI
>bd5d	03 d5 42 4e 45				.text	3,$d5,"BNE"            ; $8b BNE
>bd62	03 de 42 50 4c				.text	3,$de,"BPL"            ; $8c BPL
>bd67	03 d5 42 52 41				.text	3,$d5,"BRA"            ; $8d BRA
>bd6c	03 df 42 52 4b				.text	3,$df,"BRK"            ; $8e BRK
>bd71	03 db 42 56 43				.text	3,$db,"BVC"            ; $8f BVC
>bd76	03 eb 42 56 53				.text	3,$eb,"BVS"            ; $90 BVS
>bd7b	03 d2 43 4c 43				.text	3,$d2,"CLC"            ; $91 CLC
>bd80	03 d3 43 4c 44				.text	3,$d3,"CLD"            ; $92 CLD
>bd85	03 d8 43 4c 49				.text	3,$d8,"CLI"            ; $93 CLI
>bd8a	03 e5 43 4c 56				.text	3,$e5,"CLV"            ; $94 CLV
>bd8f	03 e0 43 4d 50				.text	3,$e0,"CMP"            ; $95 CMP
>bd94	03 eb 43 50 58				.text	3,$eb,"CPX"            ; $96 CPX
>bd99	03 ec 43 50 59				.text	3,$ec,"CPY"            ; $97 CPY
>bd9e	03 cc 44 45 43				.text	3,$cc,"DEC"            ; $98 DEC
>bda3	03 e1 44 45 58				.text	3,$e1,"DEX"            ; $99 DEX
>bda8	03 e2 44 45 59				.text	3,$e2,"DEY"            ; $9a DEY
>bdad	03 e6 45 4f 52				.text	3,$e6,"EOR"            ; $9b EOR
>bdb2	03 da 49 4e 43				.text	3,$da,"INC"            ; $9c INC
>bdb7	03 ef 49 4e 58				.text	3,$ef,"INX"            ; $9d INX
>bdbc	03 f0 49 4e 59				.text	3,$f0,"INY"            ; $9e INY
>bdc1	03 e7 4a 4d 50				.text	3,$e7,"JMP"            ; $9f JMP
>bdc6	03 ef 4a 53 52				.text	3,$ef,"JSR"            ; $a0 JSR
>bdcb	03 d1 4c 44 41				.text	3,$d1,"LDA"            ; $a1 LDA
>bdd0	03 e8 4c 44 58				.text	3,$e8,"LDX"            ; $a2 LDX
>bdd5	03 e9 4c 44 59				.text	3,$e9,"LDY"            ; $a3 LDY
>bdda	03 f1 4c 53 52				.text	3,$f1,"LSR"            ; $a4 LSR
>bddf	03 ed 4e 4f 50				.text	3,$ed,"NOP"            ; $a5 NOP
>bde4	03 e2 4f 52 41				.text	3,$e2,"ORA"            ; $a6 ORA
>bde9	03 d9 50 48 41				.text	3,$d9,"PHA"            ; $a7 PHA
>bdee	03 e8 50 48 50				.text	3,$e8,"PHP"            ; $a8 PHP
>bdf3	03 f0 50 48 58				.text	3,$f0,"PHX"            ; $a9 PHX
>bdf8	03 f1 50 48 59				.text	3,$f1,"PHY"            ; $aa PHY
>bdfd	03 dd 50 4c 41				.text	3,$dd,"PLA"            ; $ab PLA
>be02	03 ec 50 4c 50				.text	3,$ec,"PLP"            ; $ac PLP
>be07	03 f4 50 4c 58				.text	3,$f4,"PLX"            ; $ad PLX
>be0c	03 f5 50 4c 59				.text	3,$f5,"PLY"            ; $ae PLY
>be11	03 ed 52 4f 4c				.text	3,$ed,"ROL"            ; $af ROL
>be16	03 f3 52 4f 52				.text	3,$f3,"ROR"            ; $b0 ROR
>be1b	03 ef 52 54 49				.text	3,$ef,"RTI"            ; $b1 RTI
>be20	03 f9 52 54 53				.text	3,$f9,"RTS"            ; $b2 RTS
>be25	03 d8 53 42 43				.text	3,$d8,"SBC"            ; $b3 SBC
>be2a	03 db 53 45 43				.text	3,$db,"SEC"            ; $b4 SEC
>be2f	03 dc 53 45 44				.text	3,$dc,"SED"            ; $b5 SED
>be34	03 e1 53 45 49				.text	3,$e1,"SEI"            ; $b6 SEI
>be39	03 e8 53 54 41				.text	3,$e8,"STA"            ; $b7 STA
>be3e	03 f7 53 54 50				.text	3,$f7,"STP"            ; $b8 STP
>be43	03 ff 53 54 58				.text	3,$ff,"STX"            ; $b9 STX
>be48	03 00 53 54 59				.text	3,$00,"STY"            ; $ba STY
>be4d	03 01 53 54 5a				.text	3,$01,"STZ"            ; $bb STZ
>be52	03 ed 54 41 58				.text	3,$ed,"TAX"            ; $bc TAX
>be57	03 ee 54 41 59				.text	3,$ee,"TAY"            ; $bd TAY
>be5c	03 e8 54 52 42				.text	3,$e8,"TRB"            ; $be TRB
>be61	03 e9 54 53 42				.text	3,$e9,"TSB"            ; $bf TSB
>be66	03 ff 54 53 58				.text	3,$ff,"TSX"            ; $c0 TSX
>be6b	03 ed 54 58 41				.text	3,$ed,"TXA"            ; $c1 TXA
>be70	03 ff 54 58 53				.text	3,$ff,"TXS"            ; $c2 TXS
>be75	03 ee 54 59 41				.text	3,$ee,"TYA"            ; $c3 TYA
>be7a	ff					.text	$FF
.b46a					ListConvertLine:
.b46a	48		pha				pha 								; save indent on the stack
.b46b	9c 9d 04	stz $049d			stz 	tbOffset
.b46e	9c ac 04	stz $04ac			stz 	tokenBuffer
.b471	a0 02		ldy #$02			ldy 	#2 							; convert line number to string
.b473	b1 30		lda ($30),y			lda 	(codePtr),y
.b475	aa		tax				tax
.b476	88		dey				dey
.b477	b1 30		lda ($30),y			lda 	(codePtr),y
.b479	20 03 93	jsr $9303			jsr 	LCLConvertInt16
.b47c	85 36		sta $36				sta 	zTemp0 						; copy number into buffer
.b47e	86 37		stx $37				stx 	zTemp0+1
.b480	a9 8c		lda #$8c			lda 	#CLINumber+$80
.b482	20 c7 b5	jsr $b5c7			jsr 	LCLWrite
.b485	a0 00		ldy #$00			ldy 	#0
.b487					_LCCopyNumber:
.b487	b1 36		lda ($36),y			lda 	(zTemp0),y
.b489	20 c7 b5	jsr $b5c7			jsr 	LCLWrite
.b48c	c8		iny				iny
.b48d	b1 36		lda ($36),y			lda 	(zTemp0),y
.b48f	d0 f6		bne $b487			bne 	_LCCopyNumber
.b491	68		pla				pla 								; adjustment to indent
.b492	48		pha				pha 								; save on stack
.b493	10 0c		bpl $b4a1			bpl 	_LCNoAdjust 				; don't adjust indent if +ve, do after.
.b495	18		clc				clc 								; add to list indent and make 0 if goes -ve.
.b496	6d a6 04	adc $04a6			adc 	listIndent
.b499	8d a6 04	sta $04a6			sta 	listIndent
.b49c	10 03		bpl $b4a1			bpl 	_LCNoAdjust
.b49e	9c a6 04	stz $04a6			stz 	listIndent
.b4a1					_LCNoAdjust:
.b4a1	18		clc				clc		 							; work out actual indent.
.b4a2	ad a6 04	lda $04a6			lda 	listIndent
.b4a5	0a		asl a				asl 	a
.b4a6	69 06		adc #$06			adc 	#6
.b4a8	85 36		sta $36				sta 	zTemp0
.b4aa					_LCPadOut:
.b4aa	a9 20		lda #$20			lda 	#' '						; pad out to 6 characters
.b4ac	20 c7 b5	jsr $b5c7			jsr 	LCLWrite
.b4af	ad 9d 04	lda $049d			lda 	tbOffset
.b4b2	c5 36		cmp $36				cmp 	zTemp0
.b4b4	d0 f4		bne $b4aa			bne 	_LCPadOut
.b4b6	a0 03		ldy #$03			ldy 	#3 							; start position.
.b4b8					_LCMainLoop:
.b4b8	a9 8a		lda #$8a			lda 	#CLIPunctuation+$80
.b4ba	20 c7 b5	jsr $b5c7			jsr 	LCLWrite
.b4bd	b1 30		lda ($30),y			lda 	(codePtr),y
.b4bf	c9 80		cmp #$80			cmp 	#KWC_EOL 					; end of line ?
.b4c1	f0 17		beq $b4da			beq 	_LCExit
.b4c3	c9 10		cmp #$10			cmp 	#16 						; 0-5 are the double punctuations
.b4c5	90 1e		bcc $b4e5			bcc 	_LCDoubles
.b4c7	c9 20		cmp #$20			cmp 	#32 						; 16-31 are shifted punctuation from 64-91
.b4c9	90 2a		bcc $b4f5			bcc 	_LCShiftPunc
.b4cb	c9 40		cmp #$40			cmp 	#64 						; 32-64 are as stored, punc and digits
.b4cd	90 35		bcc $b504			bcc 	_LCPunctuation
.b4cf	c9 80		cmp #$80			cmp 	#128 						; 64-127 are variable identifiers.
.b4d1	90 3e		bcc $b511			bcc 	_LCIdentifiers
.b4d3	c9 fe		cmp #$fe			cmp 	#254 						; 128-253 are tokenised words
.b4d5	90 5f		bcc $b536			bcc 	_LCTokens
.b4d7	4c 96 b5	jmp $b596			jmp 	_LCData 					; 254-5 are data objects
.b4da					_LCExit:
.b4da	68		pla				pla 								; get old indent adjust
.b4db	30 07		bmi $b4e4			bmi 	_LCExit2
.b4dd	18		clc				clc 								; add to indent if +ve
.b4de	6d a6 04	adc $04a6			adc 	listIndent
.b4e1	8d a6 04	sta $04a6			sta 	listIndent
.b4e4					_LCExit2:
.b4e4	60		rts				rts
.b4e5					_LCDoubles:
.b4e5	48		pha				pha
.b4e6	4a		lsr a				lsr 	a 							; put bit 2 into bit 1
.b4e7	29 02		and #$02			and 	#2
.b4e9	09 3c		ora #$3c			ora 	#60 						; make < >
.b4eb	20 c7 b5	jsr $b5c7			jsr 	LCLWrite
.b4ee	68		pla				pla 								; restore, do lower bit
.b4ef	29 03		and #$03			and 	#3
.b4f1	09 3c		ora #$3c			ora 	#60
.b4f3	80 0f		bra $b504			bra		_LCPunctuation 				; print, increment, loop
.b4f5					_LCShiftPunc:
.b4f5	aa		tax				tax 								; save in X
.b4f6	29 07		and #$07			and 	#7 							; lower 3 bits
.b4f8	f0 02		beq $b4fc			beq 	_LCNoAdd
.b4fa	09 18		ora #$18			ora 	#24 						; adds $18 to it.
.b4fc					_LCNoAdd:
.b4fc	e0 18		cpx #$18			cpx 	#24 						; if >= 24 add $20
.b4fe	90 02		bcc $b502			bcc 	_LCNoAdd2
.b500	09 20		ora #$20			ora 	#32 						; adds $20
.b502					_LCNoAdd2:
.b502	09 40		ora #$40			ora 	#$40 						; shift into 64-127 range and fall through.
.b504					_LCPunctuation:
.b504	c9 3a		cmp #$3a			cmp 	#':' 						; check if :
.b506	d0 03		bne $b50b			bne 	_LCPContinue
.b508	20 dd b5	jsr $b5dd			jsr 	LCLDeleteLastSpace
.b50b					_LCPContinue:
.b50b	c8		iny				iny 								; consume character
.b50c	20 c7 b5	jsr $b5c7			jsr 	LCLWrite 					; write it out.
.b50f	80 a7		bra $b4b8			bra 	_LCMainLoop 				; go round again.
.b511					_LCIdentifiers:
.b511	18		clc				clc 								; convert to physical address
.b512	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.b514	85 37		sta $37				sta 	zTemp0+1
.b516	c8		iny				iny
.b517	b1 30		lda ($30),y			lda 	(codePtr),y
.b519	85 36		sta $36				sta 	zTemp0
.b51b	c8		iny				iny
.b51c	5a		phy				phy 								; save position
.b51d	a9 87		lda #$87			lda 	#CLIIdentifier+$80
.b51f	20 c7 b5	jsr $b5c7			jsr 	LCLWrite
.b522	a0 07		ldy #$07			ldy 	#7 							; output the identifier.
.b524					_LCOutIdentifier:
.b524	c8		iny				iny
.b525	b1 36		lda ($36),y			lda 	(zTemp0),y
.b527	29 7f		and #$7f			and 	#$7F
.b529	20 19 b6	jsr $b619			jsr 	LCLLowerCase
.b52c	20 c7 b5	jsr $b5c7			jsr 	LCLWrite
.b52f	b1 36		lda ($36),y			lda 	(zTemp0),y				 	; ends when bit 7 set.
.b531	10 f1		bpl $b524			bpl 	_LCOutIdentifier
.b533	7a		ply				ply 								; restore position
.b534	80 82		bra $b4b8			bra 	_LCMainLoop
.b536					_LCTokens:
.b536	aa		tax				tax 								; token in X
.b537	a9 2f		lda #$2f			lda 	#((KeywordSet2) & $FF)
.b539	85 36		sta $36				sta 	0+zTemp0
.b53b	a9 bd		lda #$bd			lda 	#((KeywordSet2) >> 8)
.b53d	85 37		sta $37				sta 	1+zTemp0
.b53f	e0 82		cpx #$82			cpx 	#$82
.b541	f0 16		beq $b559			beq 	_LCUseShift
.b543	a9 dc		lda #$dc			lda 	#((KeywordSet1) & $FF)
.b545	85 36		sta $36				sta 	0+zTemp0
.b547	a9 bc		lda #$bc			lda 	#((KeywordSet1) >> 8)
.b549	85 37		sta $37				sta 	1+zTemp0
.b54b	e0 81		cpx #$81			cpx 	#$81
.b54d	f0 0a		beq $b559			beq 	_LCUseShift
.b54f	a9 df		lda #$df			lda 	#((KeywordSet0) & $FF)
.b551	85 36		sta $36				sta 	0+zTemp0
.b553	a9 ba		lda #$ba			lda 	#((KeywordSet0) >> 8)
.b555	85 37		sta $37				sta 	1+zTemp0
.b557	80 01		bra $b55a			bra 	_LCNoShift
.b559					_LCUseShift:
.b559	c8		iny				iny
.b55a					_LCNoShift:
.b55a	20 f1 b5	jsr $b5f1			jsr 	LCLCheckSpaceRequired 		; do we need a space ?
.b55d	b1 30		lda ($30),y			lda 	(codePtr),y
.b55f	aa		tax				tax 								; into X
.b560					_LCFindText:
.b560	ca		dex				dex
.b561	10 0e		bpl $b571			bpl 	_LCFoundText 				; found text.
.b563	b2 36		lda ($36)			lda 	(zTemp0) 					; length of text
.b565	1a		inc a				inc 	a 							; one extra for size
.b566	38		sec				sec 								; one extra for checksum
.b567	65 36		adc $36				adc 	zTemp0 						; go to next token
.b569	85 36		sta $36				sta 	zTemp0
.b56b	90 f3		bcc $b560			bcc 	_LCFindText
.b56d	e6 37		inc $37				inc 	zTemp0+1
.b56f	80 ef		bra $b560			bra 	_LCFindText
.b571					_LCFoundText:
.b571	5a		phy				phy 								; save List position
.b572	b2 36		lda ($36)			lda 	(zTemp0)					; count to print
.b574	aa		tax				tax
.b575	a9 83		lda #$83			lda 	#CLIToken+$80
.b577	20 c7 b5	jsr $b5c7			jsr 	LCLWrite
.b57a	a0 02		ldy #$02			ldy 	#2
.b57c					_LCCopyToken:
.b57c	b1 36		lda ($36),y			lda 	(zTemp0),y
.b57e	20 19 b6	jsr $b619			jsr 	LCLLowerCase
.b581	20 c7 b5	jsr $b5c7			jsr 	LCLWrite
.b584	c8		iny				iny
.b585	ca		dex				dex
.b586	d0 f4		bne $b57c			bne 	_LCCopyToken
.b588	c9 28		cmp #$28			cmp 	#"(" 						; if last char not ( print a space
.b58a	f0 05		beq $b591			beq 	_LCNoSpace
.b58c	a9 20		lda #$20			lda 	#' '
.b58e	20 c7 b5	jsr $b5c7			jsr 	LCLWrite
.b591					_LCNoSpace:
.b591	7a		ply				ply 								; restore position.
.b592	c8		iny				iny 								; consume token
.b593	4c b8 b4	jmp $b4b8			jmp 	_LCMainLoop 				; and go around again.
.b596					_LCData:
.b596	48		pha				pha 								; save type $FE/$FF
.b597	a2 24		ldx #$24			ldx 	#'$' 						; figure out $ or "
.b599	c9 fe		cmp #$fe			cmp 	#$FE
.b59b	f0 07		beq $b5a4			beq 	_LCHaveOpener
.b59d	a2 22		ldx #$22			ldx 	#'"'
.b59f	a9 81		lda #$81			lda 	#CLIData+$80
.b5a1	20 c7 b5	jsr $b5c7			jsr 	LCLWrite
.b5a4					_LCHaveOpener:
.b5a4	8a		txa				txa 								; output prefix (# or ")
.b5a5	20 c7 b5	jsr $b5c7			jsr 	LCLWrite
.b5a8	c8		iny				iny 								; get count
.b5a9	b1 30		lda ($30),y			lda 	(codePtr),y
.b5ab	aa		tax				tax
.b5ac	c8		iny				iny 								; point at first character
.b5ad					_LCOutData:
.b5ad	b1 30		lda ($30),y			lda 	(codePtr),y
.b5af	c9 00		cmp #$00			cmp 	#0
.b5b1	f0 03		beq $b5b6			beq 	_LCNoPrint
.b5b3	20 c7 b5	jsr $b5c7			jsr 	LCLWrite
.b5b6					_LCNoPrint:
.b5b6	c8		iny				iny
.b5b7	ca		dex				dex
.b5b8	d0 f3		bne $b5ad			bne 	_LCOutData
.b5ba	68		pla				pla 								; closing " required ?
.b5bb	c9 ff		cmp #$ff			cmp 	#$FF
.b5bd	d0 05		bne $b5c4			bne 	_LCNoQuote
.b5bf	a9 22		lda #$22			lda 	#'"'
.b5c1	20 c7 b5	jsr $b5c7			jsr 	LCLWrite
.b5c4					_LCNoQuote:
.b5c4	4c b8 b4	jmp $b4b8			jmp 	_LCMainLoop
.b5c7					LCLWrite:
.b5c7	da		phx				phx
.b5c8	ae 9d 04	ldx $049d			ldx 	tbOffset
.b5cb	9d ac 04	sta $04ac,x			sta 	tokenBuffer,x
.b5ce	9e ad 04	stz $04ad,x			stz 	tokenBuffer+1,x
.b5d1	ee 9d 04	inc $049d			inc 	tbOffset
.b5d4	09 00		ora #$00			ora 	#0 							; don't update if colour data
.b5d6	30 03		bmi $b5db			bmi 	_LCLNoColour
.b5d8	8d a7 04	sta $04a7			sta 	LCLastCharacter
.b5db					_LCLNoColour:
.b5db	fa		plx				plx
.b5dc	60		rts				rts
.b5dd					LCLDeleteLastSpace:
.b5dd	48		pha				pha
.b5de	da		phx				phx
.b5df	ae 9d 04	ldx $049d			ldx 	tbOffset
.b5e2	f0 0a		beq $b5ee			beq 	_LCDLSExit
.b5e4	bd ab 04	lda $04ab,x			lda 	tokenBuffer-1,x
.b5e7	c9 20		cmp #$20			cmp 	#' '
.b5e9	d0 03		bne $b5ee			bne 	_LCDLSExit
.b5eb	ce 9d 04	dec $049d			dec 	tbOffset
.b5ee					_LCDLSExit:
.b5ee	fa		plx				plx
.b5ef	68		pla				pla
.b5f0	60		rts				rts
.b5f1					LCLCheckSpaceRequired:
.b5f1	ad a7 04	lda $04a7			lda 	LCLastCharacter 			; check last character
.b5f4	c9 24		cmp #$24			cmp 	#'$' 						; $ # and ) require that token space.
.b5f6	f0 1b		beq $b613			beq 	_LCCSRSpace
.b5f8	c9 29		cmp #$29			cmp 	#')'
.b5fa	f0 17		beq $b613			beq 	_LCCSRSpace
.b5fc	c9 23		cmp #$23			cmp 	#'#'
.b5fe	f0 13		beq $b613			beq 	_LCCSRSpace
.b600	20 19 b6	jsr $b619			jsr 	LCLLowerCase 				; saves a little effort
.b603	c9 30		cmp #$30			cmp 	#"0" 						; check if it was 0-9 A-Z a-z if so need space.
.b605	90 11		bcc $b618			bcc 	_LCCSRExit
.b607	c9 3a		cmp #$3a			cmp 	#"9"+1
.b609	90 08		bcc $b613			bcc 	_LCCSRSpace
.b60b	c9 61		cmp #$61			cmp 	#"a"
.b60d	90 09		bcc $b618			bcc 	_LCCSRExit
.b60f	c9 7b		cmp #$7b			cmp 	#"z"+1
.b611	b0 05		bcs $b618			bcs 	_LCCSRExit
.b613					_LCCSRSpace:
.b613	a9 20		lda #$20			lda 	#' '
.b615	20 c7 b5	jsr $b5c7			jsr 	LCLWrite
.b618					_LCCSRExit:
.b618	60		rts				rts
.b619					LCLLowerCase:
.b619	c9 41		cmp #$41			cmp 	#"A"
.b61b	90 06		bcc $b623			bcc 	_LCLLCOut
.b61d	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b61f	b0 02		bcs $b623			bcs 	_LCLLCOut
.b621	69 20		adc #$20			adc 	#$20
.b623					_LCLLCOut:
.b623	60		rts				rts
.b624					LCLUpperCase:
.b624	c9 61		cmp #$61			cmp 	#"a"
.b626	90 06		bcc $b62e			bcc 	_LCLUCOut
.b628	c9 7b		cmp #$7b			cmp 	#"z"+1
.b62a	b0 02		bcs $b62e			bcs 	_LCLUCOut
.b62c	e9 1f		sbc #$1f			sbc 	#$1F
.b62e					_LCLUCOut:
.b62e	60		rts				rts
.b62f					TOKSearchTable:
.b62f	84 37		sty $37				sty 	zTemp0+1 					; (zTemp0),y points to current token.
.b631	85 36		sta $36				sta 	zTemp0
.b633	a0 00		ldy #$00			ldy 	#0
.b635	a9 80		lda #$80			lda 	#$80 						; token #
.b637	85 38		sta $38				sta 	zTemp1
.b639					_TSTLoop:
.b639	b1 36		lda ($36),y			lda 	(zTemp0),y 					; length, 0 (skip) -ve (end)
.b63b	30 49		bmi $b686			bmi 	_TSTFail 					; -ve = end of table
.b63d	f0 2e		beq $b66d			beq 	_TSTNext 					; zero, check next it's a dummy
.b63f	c8		iny				iny 								; get the hash
.b640	b1 36		lda ($36),y			lda 	(zTemp0),y
.b642	88		dey				dey
.b643	cd 83 04	cmp $0483			cmp 	identHash 					; check they match, if not go to next
.b646	d0 25		bne $b66d			bne 	_TSTNext
.b648	ad 82 04	lda $0482			lda 	identTypeEnd 				; length of identifier
.b64b	38		sec				sec
.b64c	ed 80 04	sbc $0480			sbc 	identStart
.b64f	d1 36		cmp ($36),y			cmp 	(zTemp0),y 					; no match, then return.
.b651	d0 1a		bne $b66d			bne 	_TSTNext
.b653	5a		phy				phy 								; save Y , we might fail
.b654	c8		iny				iny 								; point to text
.b655	c8		iny				iny
.b656	ae 80 04	ldx $0480			ldx 	identStart 					; offset in line buffer in X
.b659					_TSTCompareName:
.b659	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; compare text.
.b65c	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.b65e	d0 0c		bne $b66c			bne 	_TSTNextPullY 				; fail, pullY and do next
.b660	e8		inx				inx
.b661	c8		iny				iny
.b662	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; complete match.
.b665	d0 f2		bne $b659			bne 	_TSTCompareName
.b667	7a		ply				ply 								; throw Y
.b668	a5 38		lda $38				lda 	zTemp1 						; get token #
.b66a	38		sec				sec 								; return with CS = passed.
.b66b	60		rts				rts
.b66c					_TSTNextPullY:
.b66c	7a		ply				ply 								; restore current, fall through.
.b66d					_TSTNext:
.b66d	e6 38		inc $38				inc 	zTemp1 						; token counter
.b66f	98		tya				tya
.b670	18		clc				clc
.b671	71 36		adc ($36),y			adc 	(zTemp0),y 					; add [Length] + 2 to Y
.b673	1a		inc a				inc 	a 							; +1
.b674	1a		inc a				inc 	a 							; +2
.b675	a8		tay				tay
.b676	10 c1		bpl $b639			bpl 	_TSTLoop 					; if Y < $80 loop back
.b678	98		tya				tya 								; add Y to zTemp0 and reset Y
.b679	a0 00		ldy #$00			ldy 	#0   						; so we can use Y to search fast
.b67b	18		clc				clc  								; but have tables > 255 bytes
.b67c	65 36		adc $36				adc 	zTemp0 						; when Y gets >= 128 we reset Y
.b67e	85 36		sta $36				sta 	zTemp0 						; and adjust the table pointer/
.b680	90 b7		bcc $b639			bcc 	_TSTLoop
.b682	e6 37		inc $37				inc 	zTemp0+1
.b684	80 b3		bra $b639			bra 	_TSTLoop
.b686					_TSTFail:
.b686	18		clc				clc
.b687	60		rts				rts
.b688					TokeniseLine:
.b688	20 10 b8	jsr $b810			jsr 	LCLFixLineBufferCase 		; fix line case
.b68b	a9 03		lda #$03			lda 	#3 							; reset the token buffer to empty
.b68d	8d a9 04	sta $04a9			sta 	tokenOffset
.b690	9c aa 04	stz $04aa			stz 	tokenLineNumber
.b693	9c ab 04	stz $04ab			stz 	tokenLineNumber+1
.b696	a2 ff		ldx #$ff			ldx 	#$FF
.b698					_TKFindFirst:
.b698	e8		inx				inx
.b699	bd a9 05	lda $05a9,x			lda 	lineBuffer,x
.b69c	f0 79		beq $b717			beq 	_TKExit
.b69e	c9 20		cmp #$20			cmp 	#' '
.b6a0	90 f6		bcc $b698			bcc 	_TKFindFirst
.b6a2	c9 30		cmp #$30			cmp 	#'0'
.b6a4	90 07		bcc $b6ad			bcc 	_TKNoLineNumber
.b6a6	c9 3a		cmp #$3a			cmp 	#'9'+1
.b6a8	b0 03		bcs $b6ad			bcs 	_TKNoLineNumber
.b6aa	20 3a b8	jsr $b83a			jsr 	TOKExtractLineNumber
.b6ad					_TKNoLineNumber:
.b6ad					_TKTokeniseLoop:
.b6ad	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; next character, exit if zero EOL.
.b6b0	f0 65		beq $b717			beq 	_TKExit
.b6b2	e8		inx				inx
.b6b3	c9 20		cmp #$20			cmp 	#' '
.b6b5	f0 f6		beq $b6ad			beq 	_TKTokeniseLoop 			; keep looping if space found.
.b6b7	ca		dex				dex 								; undo last get, A contains character, X is position.
.b6b8	c9 5f		cmp #$5f			cmp 	#'_'						; _ A-Z is identifier *or* token
.b6ba	f0 61		beq $b71d			beq 	_TKTokeniseIdentifier
.b6bc	c9 41		cmp #$41			cmp 	#'A'
.b6be	90 04		bcc $b6c4			bcc 	_TKTokenisePunctuation
.b6c0	c9 5b		cmp #$5b			cmp 	#'Z'+1
.b6c2	90 59		bcc $b71d			bcc 	_TKTokeniseIdentifier
.b6c4					_TKTokenisePunctuation:
.b6c4	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.b6c6	f0 27		beq $b6ef			beq 	_TKString
.b6c8	c9 24		cmp #$24			cmp 	#'$'						; hexadecimal constant (# only appears at end of identifiers)
.b6ca	f0 28		beq $b6f4			beq 	_TKHexConstant
.b6cc	c9 3c		cmp #$3c			cmp 	#'<' 						; check for < > handlers.
.b6ce	f0 29		beq $b6f9			beq 	_TKCheckDouble
.b6d0	c9 3e		cmp #$3e			cmp 	#'>'
.b6d2	f0 25		beq $b6f9			beq 	_TKCheckDouble
.b6d4					_TKStandardPunctuation:
.b6d4	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; get it back.
.b6d7	c9 40		cmp #$40			cmp 	#64 						; are we >= 64
.b6d9	90 0e		bcc $b6e9			bcc 	_TKNoShift
.b6db	48		pha				pha 								; save
.b6dc	29 07		and #$07			and 	#7 							; lower 3 bits in zTemp0
.b6de	85 36		sta $36				sta 	zTemp0
.b6e0	68		pla				pla
.b6e1	29 20		and #$20			and 	#32 						; bit 5
.b6e3	4a		lsr a				lsr 	a 							; shift into bit 3
.b6e4	4a		lsr a				lsr 	a
.b6e5	05 36		ora $36				ora 	zTemp0
.b6e7	09 10		ora #$10			ora 	#$10						; now in the range 16-31
.b6e9					_TKNoShift:
.b6e9	20 7f b8	jsr $b87f			jsr 	TOKWriteByte 				; write the punctuation character
.b6ec	e8		inx				inx 								; consume the character
.b6ed	80 be		bra $b6ad			bra 	_TKTokeniseLoop 			; and loop round again.
.b6ef					_TKString:
.b6ef	20 9f b7	jsr $b79f			jsr 	TOKTokenString
.b6f2	80 b9		bra $b6ad			bra 	_TKTokeniseLoop
.b6f4					_TKHexConstant:
.b6f4	20 da b7	jsr $b7da			jsr 	TOKHexConstant
.b6f7	80 b4		bra $b6ad			bra 	_TKTokeniseLoop
.b6f9					_TKCheckDouble:
.b6f9	bd aa 05	lda $05aa,x			lda 	lineBuffer+1,x 				; get next character
.b6fc	c9 3c		cmp #$3c			cmp 	#'<'						; if not < = > which are ASCII consecutive go back
.b6fe	90 d4		bcc $b6d4			bcc 	_TKStandardPunctuation
.b700	c9 3f		cmp #$3f			cmp 	#'>'+1
.b702	b0 d0		bcs $b6d4			bcs 	_TKStandardPunctuation
.b704	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; this is < (60) or > (62)
.b707	29 02		and #$02			and 	#2 							; now < (0) or > (2)
.b709	0a		asl a				asl 	a 							; now < (0) or > (4), CC also
.b70a	7d aa 05	adc $05aa,x			adc 	lineBuffer+1,x 				; add < = > codes - < code
.b70d	38		sec				sec
.b70e	e9 3c		sbc #$3c			sbc 	#'<'
.b710	20 7f b8	jsr $b87f			jsr 	TOKWriteByte 				; this is in the range 0-7
.b713	e8		inx				inx 								; consume both
.b714	e8		inx				inx
.b715	80 96		bra $b6ad			bra 	_TKTokeniseLoop
.b717	a9 80		lda #$80	_TKExit:lda 	#KWC_EOL 					; write end of line byte
.b719	20 7f b8	jsr $b87f			jsr 	TOKWriteByte
.b71c	60		rts				rts
.b71d					_TKTokeniseIdentifier:
.b71d	8e 80 04	stx $0480			stx 	identStart 					; save start
.b720	9c 84 04	stz $0484			stz 	identTypeByte 				; zero the type byte
.b723					_TKCheckLoop:
.b723	e8		inx				inx 								; look at next, we know first is identifier.
.b724	bd a9 05	lda $05a9,x			lda  	lineBuffer,x
.b727	c9 5f		cmp #$5f			cmp 	#"_" 						; legal char _ 0-9 A-Z
.b729	f0 f8		beq $b723			beq 	_TKCheckLoop
.b72b	c9 30		cmp #$30			cmp	 	#"0"
.b72d	90 0c		bcc $b73b			bcc 	_TKEndIdentifier
.b72f	c9 3a		cmp #$3a			cmp 	#"9"+1
.b731	90 f0		bcc $b723			bcc 	_TKCheckLoop
.b733	c9 41		cmp #$41			cmp	 	#"A"
.b735	90 04		bcc $b73b			bcc 	_TKEndIdentifier
.b737	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b739	90 e8		bcc $b723			bcc 	_TKCheckLoop
.b73b					_TKEndIdentifier:
.b73b	8e 81 04	stx $0481			stx 	identTypeStart 				; save start of type text (if any !)
.b73e	a0 08		ldy #$08			ldy 	#$08 						; this is the identifier type byte for #
.b740	c9 23		cmp #$23			cmp 	#"#"						; followed by #
.b742	f0 06		beq $b74a			beq 	_TKHasTypeCharacter
.b744	a0 10		ldy #$10			ldy 	#$10 						; this is the identifier type byte for $
.b746	c9 24		cmp #$24			cmp 	#"$"						; followed by $ or #
.b748	d0 07		bne $b751			bne 	_TKNoTypeCharacter
.b74a					_TKHasTypeCharacter:
.b74a	8c 84 04	sty $0484			sty 	identTypeByte 				; has # or $, save the type
.b74d	e8		inx				inx 								; read next
.b74e	bd a9 05	lda $05a9,x			lda 	lineBuffer,x
.b751					_TKNoTypeCharacter:
.b751	c9 28		cmp #$28			cmp 	#"("						; is it open parenthesis (e.g. array)
.b753	d0 09		bne $b75e			bne 	_TKNoArray
.b755	e8		inx				inx 								; skip the (
.b756	ad 84 04	lda $0484			lda 	identTypeByte 				; set bit 2 (e.g. array)
.b759	09 04		ora #$04			ora 	#$04
.b75b	8d 84 04	sta $0484			sta 	identTypeByte
.b75e					_TKNoArray:
.b75e	8e 82 04	stx $0482			stx 	identTypeEnd 				; save end marker, e.g. continue from here.
.b761	20 fb b7	jsr $b7fb			jsr 	TOKCalculateHash 			; calculate the has for those tokens
.b764	a0 ba		ldy #$ba			ldy 	#(KeywordSet0) >> 8
.b766	a9 df		lda #$df			lda 	#(KeywordSet0) & $FF
.b768	20 2f b6	jsr $b62f			jsr 	TOKSearchTable
.b76b	a2 00		ldx #$00			ldx 	#0
.b76d	b0 1f		bcs $b78e			bcs 	_TKFoundToken
.b76f	a0 bc		ldy #$bc			ldy 	#(KeywordSet1) >> 8
.b771	a9 dc		lda #$dc			lda 	#(KeywordSet1) & $FF
.b773	20 2f b6	jsr $b62f			jsr 	TOKSearchTable
.b776	a2 81		ldx #$81			ldx 	#$81
.b778	b0 14		bcs $b78e			bcs 	_TKFoundToken
.b77a	a0 bd		ldy #$bd			ldy 	#(KeywordSet2) >> 8
.b77c	a9 2f		lda #$2f			lda 	#(KeywordSet2) & $FF
.b77e	20 2f b6	jsr $b62f			jsr 	TOKSearchTable
.b781	a2 82		ldx #$82			ldx 	#$82
.b783	b0 09		bcs $b78e			bcs 	_TKFoundToken
.b785	20 8b b8	jsr $b88b			jsr 	TOKCheckCreateVariableRecord ; failed all, it's a variable, create record if does not exist.
.b788	ae 82 04	ldx $0482			ldx 	identTypeEnd 				; X points to following byte
.b78b	4c ad b6	jmp $b6ad			jmp 	_TKTokeniseLoop 			; and go round again.
.b78e					_TKFoundToken:
.b78e	48		pha				pha 								; save token
.b78f	8a		txa				txa 								; shift in X, is there one ?
.b790	f0 03		beq $b795			beq 	_TKNoTShift
.b792	20 7f b8	jsr $b87f			jsr 	TOKWriteByte 				; if so, write it out
.b795					_TKNoTShift:
.b795	68		pla				pla 								; restore and write token
.b796	20 7f b8	jsr $b87f			jsr 	TOKWriteByte
.b799	ae 82 04	ldx $0482			ldx 	identTypeEnd 				; X points to following byte
.b79c	4c ad b6	jmp $b6ad			jmp 	_TKTokeniseLoop 			; and go round again.
.b79f					TOKTokenString:
.b79f	a9 ff		lda #$ff			lda 	#KWC_STRING 				; string token.
.b7a1	20 7f b8	jsr $b87f			jsr 	TOKWriteByte
.b7a4	e8		inx				inx									; start of quoted string.
.b7a5	da		phx				phx 								; push start of string on top
.b7a6	ca		dex				dex
.b7a7					_TSFindEnd:
.b7a7	e8		inx				inx
.b7a8	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; next character
.b7ab	f0 04		beq $b7b1			beq 	_TSEndOfString
.b7ad	c9 22		cmp #$22			cmp 	#'"'
.b7af	d0 f6		bne $b7a7			bne 	_TSFindEnd
.b7b1					_TSEndOfString:
.b7b1	7a		ply				ply  								; so now Y is first character, X is character after end.
.b7b2	48		pha				pha 								; save terminating character
.b7b3	20 bb b7	jsr $b7bb			jsr 	TOKWriteBlockXY 			; write X to Y as a data block
.b7b6	68		pla				pla 								; terminating character
.b7b7	f0 01		beq $b7ba			beq 	_TSNotQuote					; if it wasn't EOS skip it
.b7b9	e8		inx				inx
.b7ba					_TSNotQuote:
.b7ba	60		rts				rts
.b7bb					TOKWriteBlockXY:
.b7bb	86 36		stx $36				stx 	zTemp0 						; write end character
.b7bd	98		tya				tya
.b7be	49 ff		eor #$ff			eor 	#$FF
.b7c0	38		sec				sec
.b7c1	65 36		adc $36				adc 	zTemp0
.b7c3	1a		inc a				inc 	a 							; one extra for NULL
.b7c4	20 7f b8	jsr $b87f			jsr 	TOKWriteByte
.b7c7					_TOBlockLoop:
.b7c7	c4 36		cpy $36				cpy 	zTemp0
.b7c9	f0 09		beq $b7d4			beq 	_TOBlockExit
.b7cb	b9 a9 05	lda $05a9,y			lda 	lineBuffer,y
.b7ce	20 7f b8	jsr $b87f			jsr 	TOKWriteByte
.b7d1	c8		iny				iny
.b7d2	80 f3		bra $b7c7			bra 	_TOBlockLoop
.b7d4					_TOBlockExit:
.b7d4	a9 00		lda #$00			lda 	#0
.b7d6	20 7f b8	jsr $b87f			jsr 	TOKWriteByte
.b7d9	60		rts				rts
.b7da					TOKHexConstant:
.b7da	a9 fe		lda #$fe			lda 	#KWC_HEXCONST 				; hex constant token.
.b7dc	20 7f b8	jsr $b87f			jsr 	TOKWriteByte
.b7df	e8		inx				inx									; start of quoted string.
.b7e0	da		phx				phx 								; push start of constant on top
.b7e1	ca		dex				dex
.b7e2					_THFindLoop:
.b7e2	e8		inx				inx
.b7e3	bd a9 05	lda $05a9,x			lda 	lineBuffer,x
.b7e6	c9 30		cmp #$30			cmp 	#"0"
.b7e8	90 0c		bcc $b7f6			bcc 	_THFoundEnd
.b7ea	c9 3a		cmp #$3a			cmp 	#"9"+1
.b7ec	90 f4		bcc $b7e2			bcc 	_THFindLoop
.b7ee	c9 41		cmp #$41			cmp 	#"A"
.b7f0	90 04		bcc $b7f6			bcc 	_THFoundEnd
.b7f2	c9 47		cmp #$47			cmp 	#"F"+1
.b7f4	90 ec		bcc $b7e2			bcc 	_THFindLoop
.b7f6					_THFoundEnd:
.b7f6	7a		ply				ply 								; restore start
.b7f7	20 bb b7	jsr $b7bb			jsr 	TOKWriteBlockXY 			; output the block
.b7fa	60		rts				rts
.b7fb					TOKCalculateHash:
.b7fb	da		phx				phx
.b7fc	ae 80 04	ldx $0480			ldx 	identStart 					; needs to be same as in tokens.py - simple sum
.b7ff	a9 00		lda #$00			lda 	#0
.b801					_TCHLoop:
.b801	18		clc				clc
.b802	7d a9 05	adc $05a9,x			adc 	lineBuffer,x
.b805	e8		inx				inx
.b806	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; do the whole thing including type and array markers.
.b809	d0 f6		bne $b801			bne 	_TCHLoop
.b80b	8d 83 04	sta $0483			sta 	identHash 					; save the hash
.b80e	fa		plx				plx
.b80f	60		rts				rts
.b810					LCLFixLineBufferCase:
.b810	a2 00		ldx #$00			ldx 	#0
.b812					_FLBCLoop:
.b812	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; get next character
.b815	f0 22		beq $b839			beq 	_FLBCExit 					; end of string.
.b817	c9 22		cmp #$22			cmp 	#'"'						; quote, go to in quotes
.b819	f0 11		beq $b82c			beq 	_FLBCInQuotes
.b81b	e8		inx				inx
.b81c	c9 61		cmp #$61			cmp 	#'a'						; needs capitalising ?
.b81e	90 f2		bcc $b812			bcc 	_FLBCLoop
.b820	c9 7b		cmp #$7b			cmp 	#'z'+1
.b822	b0 ee		bcs $b812			bcs 	_FLBCLoop
.b824	38		sec				sec 								; make U/C
.b825	e9 20		sbc #$20			sbc 	#32
.b827	9d a8 05	sta $05a8,x			sta	 	lineBuffer-1,x 				; write back
.b82a	80 e6		bra $b812			bra 	_FLBCLoop
.b82c					_FLBCInQuotes:
.b82c	e8		inx				inx 								; advance
.b82d	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; get next
.b830	f0 07		beq $b839			beq 	_FLBCExit 					; exit on EOS
.b832	c9 22		cmp #$22			cmp 	#'"' 				 		; until " found
.b834	d0 f6		bne $b82c			bne 	_FLBCInQuotes
.b836	e8		inx				inx 								; skip over it
.b837	80 d9		bra $b812			bra 	_FLBCLoop
.b839					_FLBCExit:
.b839	60		rts				rts
.b83a					TOKExtractLineNumber:
.b83a	ad ab 04	lda $04ab			lda 	tokenLineNumber+1 			; push current value on stack
.b83d	48		pha				pha
.b83e	ad aa 04	lda $04aa			lda 	tokenLineNumber
.b841	48		pha				pha
.b842	20 78 b8	jsr $b878			jsr 	_LCLNTimes2 				; line # x 4
.b845	20 78 b8	jsr $b878			jsr 	_LCLNTimes2 				; line # x 2
.b848	18		clc				clc 								; add stacked value
.b849	68		pla				pla
.b84a	6d aa 04	adc $04aa			adc 	tokenLineNumber
.b84d	8d aa 04	sta $04aa			sta 	tokenLineNumber
.b850	68		pla				pla
.b851	6d ab 04	adc $04ab			adc 	tokenLineNumber+1
.b854	8d ab 04	sta $04ab			sta 	tokenLineNumber+1 			; line # x 5
.b857	20 78 b8	jsr $b878			jsr 	_LCLNTimes2 				; line # x 10
.b85a	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; get and consume character
.b85d	e8		inx				inx
.b85e	29 0f		and #$0f			and 	#15 						; add to line #
.b860	18		clc				clc
.b861	6d aa 04	adc $04aa			adc 	tokenLineNumber
.b864	8d aa 04	sta $04aa			sta 	tokenLineNumber
.b867	90 03		bcc $b86c			bcc 	_TLENNoCarry
.b869	ee ab 04	inc $04ab			inc 	tokenLineNumber+1
.b86c					_TLENNoCarry:
.b86c	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; more digits ?
.b86f	c9 30		cmp #$30			cmp 	#'0'
.b871	90 04		bcc $b877			bcc 	_TLENExit
.b873	c9 3a		cmp #$3a			cmp 	#'9'+1
.b875	90 c3		bcc $b83a			bcc 	TOKExtractLineNumber
.b877					_TLENExit:
.b877	60		rts				rts
.b878					_LCLNTimes2:
.b878	0e aa 04	asl $04aa			asl 	tokenLineNumber
.b87b	2e ab 04	rol $04ab			rol 	tokenLineNumber+1
.b87e	60		rts				rts
.b87f					TOKWriteByte:
.b87f	da		phx				phx
.b880	ae a9 04	ldx $04a9			ldx 	tokenOffset 				; next slot to write to
.b883	9d a9 04	sta $04a9,x			sta 	tokenOffset,x 				; write byte out
.b886	ee a9 04	inc $04a9			inc 	tokenOffset 				; advance slot.
.b889	fa		plx				plx
.b88a	60		rts				rts
.b88b					TOKCheckCreateVariableRecord:
.b88b	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.b88d	85 36		sta $36				sta 	0+zTemp0
.b88f	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.b891	85 37		sta $37				sta 	1+zTemp0
.b893					_CCVSearch:
.b893	b2 36		lda ($36)			lda 	(zTemp0) 					; end of list
.b895	f0 2c		beq $b8c3			beq 	_CCVFail
.b897	a0 01		ldy #$01			ldy 	#1 							; read the hash
.b899	b1 36		lda ($36),y			lda 	(zTemp0),y 					; does it match ?
.b89b	cd 83 04	cmp $0483			cmp 	identHash
.b89e	d0 16		bne $b8b6			bne 	_CCVNext
.b8a0	a0 08		ldy #$08			ldy 	#8 							; name in variable record
.b8a2	ae 80 04	ldx $0480			ldx 	identStart
.b8a5					_CCVCompare:
.b8a5	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; xor them. zero if the same, except
.b8a8	51 36		eor ($36),y			eor 	(zTemp0),y 					; bit 7 is used for EOS.
.b8aa	e8		inx				inx 								; advance pointers
.b8ab	c8		iny				iny
.b8ac	0a		asl a				asl 	a 							; A = 0 if they match, CS if end.
.b8ad	d0 07		bne $b8b6			bne 	_CCVNext  					; didn't match go to next.
.b8af	90 f4		bcc $b8a5			bcc 	_CCVCompare 				; not finished yet.
.b8b1	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; matched whole thing ?
.b8b4	f0 41		beq $b8f7			beq 	_CCVFound 					; yes, we were successful
.b8b6					_CCVNext:
.b8b6	18		clc				clc
.b8b7	b2 36		lda ($36)			lda 	(zTemp0) 					; add offset to pointer
.b8b9	65 36		adc $36				adc 	zTemp0
.b8bb	85 36		sta $36				sta 	zTemp0
.b8bd	90 d4		bcc $b893			bcc 	_CCVSearch
.b8bf	e6 37		inc $37				inc 	zTemp0+1
.b8c1	80 d0		bra $b893			bra 	_CCVSearch
.b8c3					_CCVFail:
.b8c3	a0 01		ldy #$01			ldy 	#1 							; create the new record. Offset 1 is hash
.b8c5	ad 83 04	lda $0483			lda 	identHash
.b8c8	91 36		sta ($36),y			sta 	(zTemp0),y
.b8ca	c8		iny				iny 								; offset 2 is the type byte
.b8cb	ad 84 04	lda $0484			lda 	identTypeByte
.b8ce	91 36		sta ($36),y			sta 	(zTemp0),y
.b8d0	c8		iny				iny
.b8d1					_CCVData:
.b8d1	a9 00		lda #$00			lda 	#0 							; erase data 3-7
.b8d3	91 36		sta ($36),y			sta 	(zTemp0),y
.b8d5	c8		iny				iny
.b8d6	c0 08		cpy #$08			cpy 	#8
.b8d8	90 f7		bcc $b8d1			bcc 	_CCVData
.b8da	ae 80 04	ldx $0480			ldx 	identStart 					; copy name into 8 on.
.b8dd					_CCVCopyName:
.b8dd	bd a9 05	lda $05a9,x			lda 	lineBuffer,x
.b8e0	91 36		sta ($36),y			sta 	(zTemp0),y
.b8e2	e8		inx				inx
.b8e3	c8		iny				iny
.b8e4	ec 82 04	cpx $0482			cpx 	identTypeEnd
.b8e7	d0 f4		bne $b8dd			bne 	_CCVCopyName
.b8e9	98		tya				tya 								; patch offset
.b8ea	92 36		sta ($36)			sta 	(zTemp0)
.b8ec	a9 00		lda #$00			lda 	#0 							; offset for next is zero.
.b8ee	91 36		sta ($36),y			sta 	(zTemp0),y
.b8f0	88		dey				dey
.b8f1	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set bit 7 of last bit
.b8f3	09 80		ora #$80			ora 	#$80
.b8f5	91 36		sta ($36),y			sta 	(zTemp0),y
.b8f7					_CCVFound:
.b8f7	a5 37		lda $37				lda 	zTemp0+1 					; write out MSB
.b8f9	38		sec				sec
.b8fa	e9 10		sbc #$10			sbc 	#(VariableSpace >> 8) 		; offset from the start
.b8fc	09 40		ora #$40			ora 	#$40 						; make it a writeable token
.b8fe	20 7f b8	jsr $b87f			jsr 	TOKWriteByte
.b901	a5 36		lda $36				lda 	zTemp0 						; write out LSB
.b903	20 7f b8	jsr $b87f			jsr 	TOKWriteByte
.b906	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_sound.module

=1					soundIntegrated=1
.b907					SNDCheckChannel:
.b907	aa		tax				tax
.b908	bd 0a 08	lda $080a,x			lda 	SNDTimeLeft,x 				; currently playing a note
.b90b	d0 38		bne $b945			bne 	_SNDCCExit
.b90d	da		phx				phx 								; save current channel
.b90e	8a		txa				txa 								; put in A
.b90f	20 8b b9	jsr $b98b			jsr 	SNDFindNextNoteForA 		; is there a note for A in the queue ?
.b912	68		pla				pla 								; channel # in A
.b913	90 30		bcc $b945			bcc 	_SNDCCExit  				; nothing in the queue for this channel, exit.
.b915	a8		tay				tay 								; Y is the channel #
.b916	bd ff 06	lda $06ff,x			lda 	SNDQueue+1,x 				; copy data into the slot.
.b919	99 fe 07	sta $07fe,y			sta 	SNDPitchLow,y
.b91c	bd 00 07	lda $0700,x			lda 	SNDQueue+2,x
.b91f	99 02 08	sta $0802,y			sta 	SNDPitchHigh,y
.b922	bd 01 07	lda $0701,x			lda 	SNDQueue+3,x
.b925	99 06 08	sta $0806,y			sta 	SNDVolume,y
.b928	bd 02 07	lda $0702,x			lda 	SNDQueue+4,x
.b92b	99 0a 08	sta $080a,y			sta 	SNDTimeLeft,y
.b92e	bd 03 07	lda $0703,x			lda 	SNDQueue+5,x
.b931	99 0e 08	sta $080e,y			sta 	SNDAdjustLow,y
.b934	bd 04 07	lda $0704,x			lda 	SNDQueue+6,x
.b937	99 12 08	sta $0812,y			sta 	SNDAdjustHigh,y
.b93a	5a		phy				phy 								; save channel #
.b93b	20 a5 b9	jsr $b9a5			jsr 	SNDDeleteXFromQueue 		; delete record at X from queue
.b93e	ce fd 06	dec $06fd			dec 	SNDLength 					; reduce the queue length.
.b941	68		pla				pla
.b942	20 46 b9	jsr $b946			jsr 	SNDUpdateNote 				; update channel A
.b945					_SNDCCExit:
.b945	60		rts				rts
.b946					SNDUpdateNote:
.b946	aa		tax				tax 								; so we can access records
.b947	0a		asl a				asl 	a 							; convert it to a channel bit pair in 5,6
.b948	0a		asl a				asl 	a
.b949	0a		asl a				asl 	a
.b94a	0a		asl a				asl 	a
.b94b	0a		asl a				asl 	a
.b94c	8d fc 06	sta $06fc			sta 	SNDChannelBits
.b94f	bd 0a 08	lda $080a,x			lda 	SNDTimeLeft,x 				; are we silent
.b952	f0 2e		beq $b982			beq 	_SNDUNIsSilent
.b954	ad fc 06	lda $06fc			lda 	SNDChannelBits 				; push channel bits on stack
.b957	48		pha				pha
.b958	bd fe 07	lda $07fe,x			lda 	SNDPitchLow,x 				; get 4 lowest bits of pitch.
.b95b	29 0f		and #$0f			and 	#$0F
.b95d	0d fc 06	ora $06fc			ora 	SNDChannelBits 				; set channel bits
.b960	09 80		ora #$80			ora 	#$80 						; write to pitch register
.b962	20 ef b9	jsr $b9ef			jsr 	SNDWritePorts
.b965	bd 02 08	lda $0802,x			lda 	SNDPitchHigh,x 				; pitch high => channel temp.
.b968	8d fc 06	sta $06fc			sta 	SNDChannelBits
.b96b	bd fe 07	lda $07fe,x			lda 	SNDPitchLow,x
.b96e	4e fc 06	lsr $06fc			lsr 	SNDChannelBits 				; shift 2 LSBs into MSB of A
.b971	6a		ror a				ror 	a
.b972	4e fc 06	lsr $06fc			lsr 	SNDChannelBits
.b975	6a		ror a				ror 	a
.b976	4a		lsr a				lsr 	a 							; put in bits 0-5
.b977	4a		lsr a				lsr 	a
.b978	20 ef b9	jsr $b9ef			jsr 	SNDWritePorts 				; write as rest of pitch register
.b97b	68		pla				pla
.b97c	09 90		ora #$90			ora 	#$90 						; set to write minimum attentuation.
.b97e	20 ef b9	jsr $b9ef			jsr 	SNDWritePorts
.b981	60		rts				rts
.b982					_SNDUNIsSilent:
.b982	ad fc 06	lda $06fc			lda 	SNDChannelBits 				; channel bits
.b985	09 9f		ora #$9f			ora 	#$9F 						; maximum attenuation
.b987	20 ef b9	jsr $b9ef			jsr 	SNDWritePorts 				; write to the ports
.b98a	60		rts				rts
.b98b					SNDFindNextNoteForA:
.b98b	ac fd 06	ldy $06fd			ldy 	SNDLength 					; queue size into Y
.b98e	f0 13		beq $b9a3			beq 	_SNDFNNFail 				; queue empty.
.b990	a2 00		ldx #$00			ldx 	#0
.b992					_SNDFNNSearch:
.b992	dd fe 06	cmp $06fe,x			cmp 	SNDQueue,x 					; does it match the channel
.b995	38		sec				sec
.b996	f0 0c		beq $b9a4			beq 	_SNDFNNExit 				; if so exit with CS.
.b998	e8		inx				inx 								; next queue slot.
.b999	e8		inx				inx
.b99a	e8		inx				inx
.b99b	e8		inx				inx
.b99c	e8		inx				inx
.b99d	e8		inx				inx
.b99e	e8		inx				inx
.b99f	e8		inx				inx
.b9a0	88		dey				dey 								; done the whole queue
.b9a1	d0 ef		bne $b992			bne 	_SNDFNNSearch 				; no, go back.
.b9a3					_SNDFNNFail:
.b9a3	18		clc				clc
.b9a4					_SNDFNNexit:
.b9a4	60		rts				rts
.b9a5					SNDDeleteXFromQueue:
.b9a5	e0 f8		cpx #$f8			cpx 	#SNDQueueSize*8-8 			; reached the end.
.b9a7	f0 09		beq $b9b2			beq 	_SNDDXExit
.b9a9	bd 06 07	lda $0706,x			lda 	SNDQueue+8,x
.b9ac	9d fe 06	sta $06fe,x			sta 	SNDQueue,x
.b9af	e8		inx				inx
.b9b0	80 f3		bra $b9a5			bra 	SNDDeleteXFromQueue
.b9b2					_SNDDXExit:
.b9b2	60		rts				rts
.06fc					SNDChannelBits:
>06fc							.fill 	1
.b9b3					SNDQueueRequest:
.b9b3	86 36		stx $36				stx 	zTemp0						; save queue address
.b9b5	84 37		sty $37				sty 	zTemp0+1
.b9b7	ae fd 06	ldx $06fd			ldx 	SNDLength 					; queue is full, can't take any more.
.b9ba	e0 20		cpx #$20			cpx 	#SNDQueueSize
.b9bc	f0 21		beq $b9df			beq 	_SNDQRExit
.b9be	29 03		and #$03			and 	#3	 						; channel # and push on stack
.b9c0	48		pha				pha
.b9c1	8a		txa				txa  								; get offset in queue buffer/
.b9c2	0a		asl a				asl 	a
.b9c3	0a		asl a				asl 	a
.b9c4	0a		asl a				asl 	a
.b9c5	aa		tax				tax
.b9c6	68		pla				pla 								; get back and push again
.b9c7	48		pha				pha
.b9c8	9d fe 06	sta $06fe,x			sta 	SNDQueue+0,x 				; save the channel #
.b9cb	a0 00		ldy #$00			ldy 	#0 							; copy the rest in.
.b9cd					_SNDQCopy:
.b9cd	b1 36		lda ($36),y			lda 	(zTemp0),y
.b9cf	e8		inx				inx
.b9d0	c8		iny				iny
.b9d1	9d fe 06	sta $06fe,x			sta 	SNDQueue,x
.b9d4	c0 06		cpy #$06			cpy 	#6
.b9d6	d0 f5		bne $b9cd			bne 	_SNDQCopy
.b9d8	ee fd 06	inc $06fd			inc 	SNDLength 					; bump queue length.
.b9db	68		pla				pla 								; get channel # back
.b9dc	20 07 b9	jsr $b907			jsr 	SNDCheckChannel 			; check if channel needs refreshing.
.b9df					_SNDQRExit:
.b9df	60		rts				rts
.b9e0					SNDSilenceChannel:
.b9e0	aa		tax				tax 								; zero time left.
.b9e1	9e 0a 08	stz $080a,x			stz 	SNDTimeLeft,x
.b9e4	0a		asl a				asl 	a 							; shift into position
.b9e5	0a		asl a				asl 	a
.b9e6	0a		asl a				asl 	a
.b9e7	0a		asl a				asl 	a
.b9e8	0a		asl a				asl 	a
.b9e9	09 9f		ora #$9f			ora 	#$9F 						; write register attenuation $F
.b9eb	20 ef b9	jsr $b9ef			jsr 	SNDWritePorts
.b9ee	60		rts				rts
.b9ef					SNDWritePorts:
.b9ef	64 01		stz $01				stz 	1
.b9f1	8d 00 d6	sta $d600			sta 	$D600
.b9f4	8d 10 d6	sta $d610			sta 	$D610
.b9f7	60		rts				rts
.b9f8					SNDCommand:
.b9f8	da		phx				phx
.b9f9	5a		phy				phy
.b9fa	c9 0f		cmp #$0f			cmp 	#$0F 						; $0F is initialise
.b9fc	f0 1d		beq $ba1b			beq 	_SNDInitialise
.b9fe	90 28		bcc $ba28			bcc 	_SNDExit
.ba00	c9 3f		cmp #$3f			cmp 	#$3F 						; $3F is silence all
.ba02	f0 17		beq $ba1b			beq 	_SNDSilence
.ba04	b0 22		bcs $ba28			bcs 	_SNDExit
.ba06	c9 20		cmp #$20			cmp 	#$20 						; $2x is check playing => A
.ba08	b0 09		bcs $ba13			bcs 	_SNDQueryPlay
.ba0a	c9 14		cmp #$14			cmp 	#$14 						; $10-$13 is queue sound
.ba0c	b0 1a		bcs $ba28			bcs 	_SNDExit
.ba0e	20 b3 b9	jsr $b9b3			jsr 	SNDQueueRequest
.ba11	80 15		bra $ba28			bra 	_SNDExit
.ba13					_SNDQueryPlay:
.ba13	29 03		and #$03			and 	#3 							; get channel #
.ba15	aa		tax				tax
.ba16	bd 0a 08	lda $080a,x			lda 	SNDTimeLeft,x 				; read time left, if zero then silent
.ba19	80 0d		bra $ba28			bra 	_SNDExit
.ba1b					_SNDInitialise:
.ba1b					_SNDSilence:
.ba1b	9c fd 06	stz $06fd			stz 	SNDLength 					; empty the queue.
.ba1e	a9 03		lda #$03			lda 	#$3 						; silence channel 0-3.
.ba20					_SNDSilenceLoop:
.ba20	48		pha				pha
.ba21	20 e0 b9	jsr $b9e0			jsr 	SNDSilenceChannel
.ba24	68		pla				pla
.ba25	3a		dec a				dec 	a
.ba26	10 f8		bpl $ba20			bpl 	_SNDSilenceLoop
.ba28					_SNDExit:
.ba28	7a		ply				ply
.ba29	fa		plx				plx
.ba2a	60		rts				rts
=32					SNDQueueSize = 32 							; number of queue entries
.06fd					SNDLength:
>06fd							.fill 	1
.06fe					SNDQueue:
>06fe							.fill 	SNDQueueSize * 8
.07fe					SNDPitchLow:
>07fe							.fill 	4
.0802					SNDPitchHigh:
>0802							.fill 	4
.0806					SNDVolume:
>0806							.fill 	4
.080a					SNDTimeLeft:
>080a							.fill 	4
.080e					SNDAdjustLow:
>080e							.fill 	4
.0812					SNDAdjustHigh:
>0812							.fill 	4
.ba2b					SNDUpdate:
.ba2b	ad 0a 08	lda $080a			lda 	SNDTimeLeft+0 				; look at time remaining
.ba2e	f0 05		beq $ba35			beq 	_SNDUNot0 					; not playing
.ba30	a2 00		ldx #$00			ldx 	#0 							; so we know which channel to update
.ba32	20 54 ba	jsr $ba54			jsr 	SNDUpdateChannel 			; update it.
.ba35					_SNDUNot0:
.ba35	ad 0b 08	lda $080b			lda 	SNDTimeLeft+1
.ba38	f0 05		beq $ba3f			beq 	_SNDUNot1
.ba3a	a2 01		ldx #$01			ldx 	#1
.ba3c	20 54 ba	jsr $ba54			jsr 	SNDUpdateChannel
.ba3f					_SNDUNot1:
.ba3f	ad 0c 08	lda $080c			lda 	SNDTimeLeft+2
.ba42	f0 05		beq $ba49			beq 	_SNDUNot2
.ba44	a2 02		ldx #$02			ldx 	#2
.ba46	20 54 ba	jsr $ba54			jsr 	SNDUpdateChannel
.ba49					_SNDUNot2:
.ba49	ad 0d 08	lda $080d			lda 	SNDTimeLeft+3
.ba4c	f0 05		beq $ba53			beq 	_SNDUNot3
.ba4e	a2 03		ldx #$03			ldx 	#3
.ba50	20 54 ba	jsr $ba54			jsr 	SNDUpdateChannel
.ba53					_SNDUNot3:
.ba53	60		rts				rts
.ba54					SNDUpdateChannel:
.ba54	c9 ff		cmp #$ff			cmp 	#$FF 						; sound $FF play forever until turned off manually
.ba56	f0 2c		beq $ba84			beq 	_SNDUCExit
.ba58	3a		dec a				dec 	a 							; decrement and update timer
.ba59	9d 0a 08	sta $080a,x			sta 	SNDTimeLeft,x
.ba5c	f0 1d		beq $ba7b			beq 	_SNDUCUpdate 				; if zero, silence channel
.ba5e	bd 0e 08	lda $080e,x			lda 	SNDAdjustLow,x 				; adjust ?
.ba61	1d 12 08	ora $0812,x			ora 	SNDAdjustHigh,x
.ba64	f0 1e		beq $ba84			beq 	_SNDUCExit 					; if zero carry on at current tone.
.ba66	18		clc				clc 								; add adjust, forcing into a 10 bit range
.ba67	bd fe 07	lda $07fe,x			lda 	SNDPitchLow,x
.ba6a	7d 0e 08	adc $080e,x			adc 	SNDAdjustLow,x
.ba6d	9d fe 07	sta $07fe,x			sta 	SNDPitchLow,x
.ba70	bd 02 08	lda $0802,x			lda 	SNDPitchHigh,x
.ba73	7d 12 08	adc $0812,x			adc 	SNDAdjustHigh,x
.ba76	29 03		and #$03			and 	#3
.ba78	9d 02 08	sta $0802,x			sta 	SNDPitchHigh,x
.ba7b					_SNDUCUpdate:
.ba7b	8a		txa				txa 								; which channel.
.ba7c	48		pha				pha
.ba7d	20 46 b9	jsr $b946			jsr 	SNDUpdateNote 				; update the current note
.ba80	68		pla				pla
.ba81	20 07 b9	jsr $b907			jsr 	SNDCheckChannel 			; more to do ?
.ba84					_SNDUCExit:
.ba84	60		rts				rts

;******  Return to file: _basic.asm


;******  End of listing
