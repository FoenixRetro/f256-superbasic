
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -D AUTORUN=0 "-D MONITOR_ADDRESS=\$E000" "-D LOCKOUT_ADDRESS=\$F000" "-D BASIC_ADDRESS=\$34000" "-D SOURCE_ADDRESS=\$28000" "-D SPRITE_ADDRESS=\$30000" "-D TILEMAP_ADDRESS=\$24000" "-D TILEIMAGES_ADDRESS=\$26000" -q -b -Wall -c -C -D HARDWARE=0 -L output/basic.lst -l output/basic.lbl -Wall -o build/basic.rom _basic.asm
; Sun Jun  1 21:02:27 2025

;Offset	;PC	;Hex		;Monitor	;Source

;******  Command line definitions

=0						AUTORUN=0
=$e000						 MONITOR_ADDRESS=$E000
=$f000						 LOCKOUT_ADDRESS=$F000
=$34000						 BASIC_ADDRESS=$34000
=$28000						 SOURCE_ADDRESS=$28000
=$30000						 SPRITE_ADDRESS=$30000
=$24000						 TILEMAP_ADDRESS=$24000
=$26000						 TILEIMAGES_ADDRESS=$26000
=0						HARDWARE=0

;******  Processing input file: _basic.asm


;******  Processing file: ./common/aa.system/01common.inc

=$30						ZeroPageMandatory = $30
=$50						ZeroPagePreference = $50
=$200						ArgumentStorage = $200
=$400						ControlStorage = $400
=$420						MemoryStorage = $420
=$2000						BasicStart = $2000
=$8000						BasicEnd = $8000
=$8000						CodeStart = $8000
=$1000						VariableSpace = $1000
=$2000						EndVariableSpace = $2000
=16						MathStackSize = 16
=512						BasicStackSize = 512
=3584						BasicStackBase = $1000-BasicStackSize
=80						MaxLineSize = 80

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/02macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/04data.inc

.0030						codePtr:
>0030								.fill 	4
.0034						basicStack:
>0034								.fill 	2
.0036						zTemp0:
>0036								.fill 	2
.0038						zTemp1:
>0038								.fill 	2
.003a						zTemp2:
>003a								.fill 	2
.003c						zsTemp:
>003c								.fill 	2
.003e						zaTemp:
>003e								.fill 	2
=$30						safePtr = codePtr 							; minimise direct tinkering
=$80						NSBIsNegative = $80 						; bit 7 : sign of mantissa (where numeric)
=$20						NSBIsReference = $20 						; bit 5 : is a reference
=$10						NSBIsString = $10 							; bit 4 : set if string (procedures don't go on the stack)
=$18						NSBTypeMask = $18 							; bits 4,3 : 00 int 01 float 10 string 11 procedure
=$03						NSBRefMask = $03 							; bits 0,1 : Bytes of reference, 00 = 4,01 = 1,10=2
=$04						NSBIsArray = $04
=$00						NSTInteger = $00 							; base types for bits 3..4
=$08						NSTFloat = $08
=$10						NSTString = $10
=$18						NSTProcedure = $18
.0050						NSStatus:
>0050								.fill 	MathStackSize
.0060						NSMantissa0:
>0060								.fill 	MathStackSize 				; (this is my integer mantissa system)
.0070						NSMantissa1:
>0070								.fill 	MathStackSize
.0080						NSMantissa2:
>0080								.fill 	MathStackSize
.0090						NSMantissa3:
>0090								.fill 	MathStackSize
.00a0						NSExponent:
>00a0								.fill 	MathStackSize
.0420						identStart:
>0420								.fill 	1
.0421						identTypeStart:
>0421								.fill 	1
.0422						identTypeEnd:
>0422								.fill 	1
.0423						identHash:
>0423								.fill 	1
.0424						identTypeByte:
>0424								.fill 	1	 						; (see tokenising.pdf)
.0425						encodeState:
>0425								.fill 	1
.0426						digitTemp:
>0426								.fill 	1
.0427						decimalCount:
>0427								.fill 	1
.0428						lowMemPtr:
>0428								.fill 	2
.042a						stringMemory:
>042a								.fill 	2
.042c						stringInitialised:
>042c								.fill 	1
.042d						stringTempPointer:
>042d								.fill 	2
.042f						breakCheck:
>042f								.fill 	1
.0430						decimalPlaces:
>0430								.fill 	1
.0431						dbOffset:
>0431								.fill 	1
.0432						lastParameter:
>0432								.fill 	1
.0433						dataPointer:
>0433								.fill 	5
.0438						inDataStatement:
>0438								.fill 	1
.0439						tbOffset:
>0439								.fill 	1
.043a						AssemblerAddress:
>043a								.fill 	2
.043c						AssemblerControl:
>043c								.fill 	1
.043d						ParamStart:
>043d								.fill 	2
.043f						IsGroup1:
>043f								.fill 	1
.0440						BaseOpcode:
>0440								.fill 	1
.0441						ModeMask:
>0441								.fill 	1
.0442						listIndent:
>0442								.fill 	1
.0443						lcLastCharacter:
>0443								.fill 	1
.0444						isPrintFlag:
>0444								.fill 	1
.0445						currentListColour:
>0445								.fill 	1
.0446						tokenOffset:
>0446								.fill 	1
.0447						tokenLineNumber:
>0447								.fill 	2
.0449						tokenBuffer:
>0449								.fill 	253
.0546						lineBuffer:
>0546								.fill 	253
.0643						numberBuffer:
>0643								.fill 	34
.0665						decimalBuffer:
>0665								.fill 	16
.0675						programChanged:
>0675								.fill	1							; tracks whether program has been changed since last save

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/ab.system/macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/ab.system/ticktask.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/constants.inc

=$80						AM_ISZP = $80
=$40						AM_ISG1 = $40
=$20						AM_ISG2 = $20
=224						AM_IMMEDIATE = AM_ISZP+AM_ISG1+AM_ISG2+$00
=228						AM_ZEROPAGE = AM_ISZP+AM_ISG1+AM_ISG2+$04
=40						AM_ACC = AM_ISG2+$08
=108						AM_ABS = AM_ISG1+AM_ISG2+$0C
=208						AM_INDY = AM_ISZP+AM_ISG1+$10
=244						AM_ZEROX = AM_ISZP+AM_ISG1+AM_ISG2+$14
=120						AM_ABSY = AM_ISG1+AM_ISG2+$18
=124						AM_ABSX = AM_ISG1+AM_ISG2+$1C
=209						AM_IND = AM_ISZP+AM_ISG1+$11
=$80						AM_ZEROY = AM_ISZP
=$01						AM_INDABS = $01
=$02						AM_INDABSX = $02
=192						AM_INDX = AM_ISZP+AM_ISG1+$00

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/handlers.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.inc

=1						ERRID_BREAK = 1
=2						ERRID_SYNTAX = 2
=3						ERRID_DIVZERO = 3
=4						ERRID_RANGE = 4
=5						ERRID_TYPE = 5
=6						ERRID_MEMORY = 6
=7						ERRID_ARGUMENT = 7
=8						ERRID_STOP = 8
=9						ERRID_STRING = 9
=10						ERRID_ASSERT = 10
=11						ERRID_DATA = 11
=12						ERRID_NOTDONE = 12
=13						ERRID_LINE = 13
=14						ERRID_GOSUB = 14
=15						ERRID_REPEAT = 15
=16						ERRID_WHILE = 16
=17						ERRID_FOR = 17
=18						ERRID_STACK = 18
=19						ERRID_STRUCT = 19
=20						ERRID_PROC = 20
=21						ERRID_REDEFINE = 21
=22						ERRID_ARRAYSIZE = 22
=23						ERRID_ARRAYIDX = 23
=24						ERRID_ARRAYDEC = 24
=25						ERRID_NOTFOUND = 25
=26						ERRID_DRIVEIO = 26
=27						ERRID_VERIFY = 27
=28						ERRID_NOPROGRAM = 28
=29						ERRID_PARAMETERS = 29
=30						ERRID_TOOCOMPLEX = 30
=31						ERRID_INITERROR = 31

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst.inc

=$00						KWD_LESSLESS                         = $00; $00 <<
=$01						KWD_LESSEQUAL                        = $01; $01 <=
=$02						KWD_LESSGREATER                      = $02; $02 <>
=$03						KWD_PLINGPLING3                      = $03; $03 !!3
=$04						KWD_GREATERLESS                      = $04; $04 ><
=$05						KWD_GREATEREQUAL                     = $05; $05 >=
=$06						KWD_GREATERGREATER                   = $06; $06 >>
=$07						KWD_PLINGPLING7                      = $07; $07 !!7
=$08						KWD_PLINGPLING8                      = $08; $08 !!8
=$09						KWD_PLINGPLING9                      = $09; $09 !!9
=$0a						KWD_PLINGPLING10                     = $0a; $0a !!10
=$0b						KWD_PLINGPLING11                     = $0b; $0b !!11
=$0c						KWD_PLINGPLING12                     = $0c; $0c !!12
=$0d						KWD_PLINGPLING13                     = $0d; $0d !!13
=$0e						KWD_PLINGPLING14                     = $0e; $0e !!14
=$0f						KWD_PLINGPLING15                     = $0f; $0f !!15
=$10						KWD_ATCH                             = $10; $10 @
=$11						KWD_PLINGPLING17                     = $11; $11 !!17
=$12						KWD_PLINGPLING18                     = $12; $12 !!18
=$13						KWD_LSQPAREN                         = $13; $13 [
=$14						KWD_BACKSLASH                        = $14; $14 \
=$15						KWD_RSQPAREN                         = $15; $15 ]
=$16						KWD_HAT                              = $16; $16 ^
=$17						KWD_UNDERSCORE                       = $17; $17 _
=$18						KWD_BQUOTE                           = $18; $18 `
=$19						KWD_PLINGPLING25                     = $19; $19 !!25
=$1a						KWD_PLINGPLING26                     = $1a; $1a !!26
=$1b						KWD_LCURLY                           = $1b; $1b {
=$1c						KWD_BAR                              = $1c; $1c |
=$1d						KWD_RCURLY                           = $1d; $1d }
=$1e						KWD_TILDE                            = $1e; $1e ~
=$21						KWD_PLING                            = $21; $21 !
=$22						KWD_DQUOTE                           = $22; $22 "
=$23						KWD_HASH                             = $23; $23 #
=$24						KWD_DOLLAR                           = $24; $24 $
=$25						KWD_PERCENT                          = $25; $25 %
=$26						KWD_AMPERSAND                        = $26; $26 &
=$27						KWD_QUOTE                            = $27; $27 '
=$28						KWD_LPAREN                           = $28; $28 (
=$29						KWD_RPAREN                           = $29; $29 )
=$2a						KWD_STAR                             = $2a; $2a *
=$2b						KWD_PLUS                             = $2b; $2b +
=$2c						KWD_COMMA                            = $2c; $2c ,
=$2d						KWD_MINUS                            = $2d; $2d -
=$2e						KWD_PERIOD                           = $2e; $2e .
=$2f						KWD_SLASH                            = $2f; $2f /
=$30						KWD_0                                = $30; $30 0
=$31						KWD_1                                = $31; $31 1
=$32						KWD_2                                = $32; $32 2
=$33						KWD_3                                = $33; $33 3
=$34						KWD_4                                = $34; $34 4
=$35						KWD_5                                = $35; $35 5
=$36						KWD_6                                = $36; $36 6
=$37						KWD_7                                = $37; $37 7
=$38						KWD_8                                = $38; $38 8
=$39						KWD_9                                = $39; $39 9
=$3a						KWD_COLON                            = $3a; $3a :
=$3b						KWD_SEMICOLON                        = $3b; $3b ;
=$3c						KWD_LESS                             = $3c; $3c <
=$3d						KWD_EQUAL                            = $3d; $3d =
=$3e						KWD_GREATER                          = $3e; $3e >
=$3f						KWD_QMARK                            = $3f; $3f ?
=$83						KWD_ABSLPAREN                        = $83; $83 ABS(
=$84						KWD_ALLOCLPAREN                      = $84; $84 ALLOC(
=$85						KWD_ASCLPAREN                        = $85; $85 ASC(
=$86						KWD_CHRDOLLARLPAREN                  = $86; $86 CHR$(
=$87						KWD_EVENTLPAREN                      = $87; $87 EVENT(
=$88						KWD_FALSE                            = $88; $88 FALSE
=$89						KWD_FRACLPAREN                       = $89; $89 FRAC(
=$8a						KWD_GETDOLLARLPAREN                  = $8a; $8a GET$(
=$8b						KWD_GETLPAREN                        = $8b; $8b GET(
=$8c						KWD_GETDATEDOLLARLPAREN              = $8c; $8c GETDATE$(
=$8d						KWD_GETTIMEDOLLARLPAREN              = $8d; $8d GETTIME$(
=$8e						KWD_HITLPAREN                        = $8e; $8e HIT(
=$8f						KWD_INKEYDOLLARLPAREN                = $8f; $8f INKEY$(
=$90						KWD_INKEYLPAREN                      = $90; $90 INKEY(
=$91						KWD_INTLPAREN                        = $91; $91 INT(
=$92						KWD_ISVALLPAREN                      = $92; $92 ISVAL(
=$93						KWD_ITEMCOUNTLPAREN                  = $93; $93 ITEMCOUNT(
=$94						KWD_ITEMGETDOLLARLPAREN              = $94; $94 ITEMGET$(
=$95						KWD_JOYBLPAREN                       = $95; $95 JOYB(
=$96						KWD_JOYXLPAREN                       = $96; $96 JOYX(
=$97						KWD_JOYYLPAREN                       = $97; $97 JOYY(
=$98						KWD_KEYDOWNLPAREN                    = $98; $98 KEYDOWN(
=$99						KWD_LEFTDOLLARLPAREN                 = $99; $99 LEFT$(
=$9a						KWD_LENLPAREN                        = $9a; $9a LEN(
=$9b						KWD_MAXLPAREN                        = $9b; $9b MAX(
=$9c						KWD_MIDDOLLARLPAREN                  = $9c; $9c MID$(
=$9d						KWD_MINLPAREN                        = $9d; $9d MIN(
=$9e						KWD_NOTLPAREN                        = $9e; $9e NOT(
=$9f						KWD_PEEKLPAREN                       = $9f; $9f PEEK(
=$a0						KWD_PEEKDLPAREN                      = $a0; $a0 PEEKD(
=$a1						KWD_PEEKLLPAREN                      = $a1; $a1 PEEKL(
=$a2						KWD_PEEKWLPAREN                      = $a2; $a2 PEEKW(
=$a3						KWD_PLAYINGLPAREN                    = $a3; $a3 PLAYING(
=$a4						KWD_RANDOMLPAREN                     = $a4; $a4 RANDOM(
=$a5						KWD_RIGHTDOLLARLPAREN                = $a5; $a5 RIGHT$(
=$a6						KWD_RNDLPAREN                        = $a6; $a6 RND(
=$a7						KWD_SGNLPAREN                        = $a7; $a7 SGN(
=$a8						KWD_SPCLPAREN                        = $a8; $a8 SPC(
=$a9						KWD_STRDOLLARLPAREN                  = $a9; $a9 STR$(
=$aa						KWD_TILELPAREN                       = $aa; $aa TILE(
=$ab						KWD_TIMERLPAREN                      = $ab; $ab TIMER(
=$ac						KWD_TRUE                             = $ac; $ac TRUE
=$ad						KWD_VALLPAREN                        = $ad; $ad VAL(
=$ae						KWD_FOR                              = $ae; $ae FOR
=$af						KWD_IF                               = $af; $af IF
=$b0						KWD_PROC                             = $b0; $b0 PROC
=$b1						KWD_REPEAT                           = $b1; $b1 REPEAT
=$b2						KWD_WHILE                            = $b2; $b2 WHILE
=$b3						KWD_ENDIF                            = $b3; $b3 ENDIF
=$b4						KWD_ENDPROC                          = $b4; $b4 ENDPROC
=$b5						KWD_NEXT                             = $b5; $b5 NEXT
=$b6						KWD_THEN                             = $b6; $b6 THEN
=$b7						KWD_UNTIL                            = $b7; $b7 UNTIL
=$b8						KWD_WEND                             = $b8; $b8 WEND
=$b9						KWD_AT                               = $b9; $b9 AT
=$ba						KWD_BY                               = $ba; $ba BY
=$bb						KWD_CALL                             = $bb; $bb CALL
=$bc						KWD_CIRCLE                           = $bc; $bc CIRCLE
=$bd						KWD_CLEAR                            = $bd; $bd CLEAR
=$be						KWD_COLOR                            = $be; $be COLOR
=$bf						KWD_COLOUR                           = $bf; $bf COLOUR
=$c0						KWD_DATA                             = $c0; $c0 DATA
=$c1						KWD_DIM                              = $c1; $c1 DIM
=$c2						KWD_DOWNTO                           = $c2; $c2 DOWNTO
=$c3						KWD_ELSE                             = $c3; $c3 ELSE
=$c4						KWD_FROM                             = $c4; $c4 FROM
=$c5						KWD_GFX                              = $c5; $c5 GFX
=$c6						KWD_HERE                             = $c6; $c6 HERE
=$c7						KWD_IMAGE                            = $c7; $c7 IMAGE
=$c8						KWD_LET                              = $c8; $c8 LET
=$c9						KWD_LINE                             = $c9; $c9 LINE
=$ca						KWD_LOCAL                            = $ca; $ca LOCAL
=$cb						KWD_MEMCOPY                          = $cb; $cb MEMCOPY
=$cc						KWD_OFF                              = $cc; $cc OFF
=$cd						KWD_ON                               = $cd; $cd ON
=$ce						KWD_OUTLINE                          = $ce; $ce OUTLINE
=$cf						KWD_PALETTE                          = $cf; $cf PALETTE
=$d0						KWD_PLOT                             = $d0; $d0 PLOT
=$d1						KWD_POKE                             = $d1; $d1 POKE
=$d2						KWD_POKED                            = $d2; $d2 POKED
=$d3						KWD_POKEL                            = $d3; $d3 POKEL
=$d4						KWD_POKEW                            = $d4; $d4 POKEW
=$d5						KWD_READ                             = $d5; $d5 READ
=$d6						KWD_RECT                             = $d6; $d6 RECT
=$d7						KWD_REM                              = $d7; $d7 REM
=$d8						KWD_SOLID                            = $d8; $d8 SOLID
=$d9						KWD_SOUND                            = $d9; $d9 SOUND
=$da						KWD_SPRITE                           = $da; $da SPRITE
=$db						KWD_TEXT                             = $db; $db TEXT
=$dc						KWD_TO                               = $dc; $dc TO
=$83						KWD1_ASSEMBLE                         = $83; $83 ASSEMBLE
=$84						KWD1_ASSERT                           = $84; $84 ASSERT
=$85						KWD1_BITMAP                           = $85; $85 BITMAP
=$86						KWD1_BLOAD                            = $86; $86 BLOAD
=$87						KWD1_BSAVE                            = $87; $87 BSAVE
=$88						KWD1_CLS                              = $88; $88 CLS
=$89						KWD1_CPRINT                           = $89; $89 CPRINT
=$8a						KWD1_CURSOR                           = $8a; $8a CURSOR
=$8b						KWD1_DIR                              = $8b; $8b DIR
=$8c						KWD1_DRIVE                            = $8c; $8c DRIVE
=$8d						KWD1_END                              = $8d; $8d END
=$8e						KWD1_EXPLODE                          = $8e; $8e EXPLODE
=$8f						KWD1_GO                               = $8f; $8f GO
=$90						KWD1_GOSUB                            = $90; $90 GOSUB
=$91						KWD1_GOTO                             = $91; $91 GOTO
=$92						KWD1_HIMEM                            = $92; $92 HIMEM
=$93						KWD1_INPUT                            = $93; $93 INPUT
=$94						KWD1_LIST                             = $94; $94 LIST
=$95						KWD1_LOAD                             = $95; $95 LOAD
=$96						KWD1_MDELTA                           = $96; $96 MDELTA
=$97						KWD1_MOUSE                            = $97; $97 MOUSE
=$98						KWD1_NEW                              = $98; $98 NEW
=$99						KWD1_OPTION                           = $99; $99 OPTION
=$9a						KWD1_PING                             = $9a; $9a PING
=$9b						KWD1_PRINT                            = $9b; $9b PRINT
=$9c						KWD1_RESTORE                          = $9c; $9c RESTORE
=$9d						KWD1_RETURN                           = $9d; $9d RETURN
=$9e						KWD1_RUN                              = $9e; $9e RUN
=$9f						KWD1_SAVE                             = $9f; $9f SAVE
=$a0						KWD1_SETDATE                          = $a0; $a0 SETDATE
=$a1						KWD1_SETTIME                          = $a1; $a1 SETTIME
=$a2						KWD1_SHOOT                            = $a2; $a2 SHOOT
=$a3						KWD1_SPRITES                          = $a3; $a3 SPRITES
=$a4						KWD1_STOP                             = $a4; $a4 STOP
=$a5						KWD1_TILE                             = $a5; $a5 TILE
=$a6						KWD1_TILES                            = $a6; $a6 TILES
=$a7						KWD1_TRY                              = $a7; $a7 TRY
=$a8						KWD1_VERIFY                           = $a8; $a8 VERIFY
=$a9						KWD1_XGO                              = $a9; $a9 XGO
=$aa						KWD1_XLOAD                            = $aa; $aa XLOAD
=$ab						KWD1_ZAP                              = $ab; $ab ZAP

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst0.inc

=$80						KWC_EOL = $80
=$81						KWC_SHIFT1 = $81
=$82						KWC_SHIFT2 = $82
=$ff						KWC_STRING = $FF
=$fe						KWC_HEXCONST = $FE
=$ae						KWC_FIRST_STRUCTURE = $ae
=$b3						KWC_FIRST_STRUCTURE_DEC = $b3
=$b8						KWC_LAST_STRUCTURE = $b8
=$83						KWC_FIRST_UNARY = $83
=$ad						KWC_LAST_UNARY = $ad

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/memory/memory.flat/access.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/stack.inc

=$e0						STK_GOSUB = $E0
=$d0						STK_FOR = $D0
=$c0						STK_REPEAT = $C0
=$b0						STK_PROC = $B0
=$a0						STK_WHILE = $A0
=$01						STK_LOCALN = $01
=$02						STK_LOCALS = $02

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/00start.asm

.8000						F256Header:
>8000		f2 56						.text	$f2,$56         			; Signature
>8002		04						.byte   4               			; 4 blocks
>8003		04						.byte   4               			; mount at $8000
>8004		40 80						.word   Boot 	      				; Start here
>8006		01						.byte   1 			               	; version
>8007		00						.byte   0               			; reserved
>8008		00						.byte   0               			; reserved
>8009		00						.byte   0               			; reserved
>800a		62 61 73 69 63 00				.text   "basic",0 					; name of program.
>8010		00						.text   0							; arguments
>8011		54 68 65 20 53 75 70 65				.text	"The SuperBASIC environment.",0	; description
>8019		72 42 41 53 49 43 20 65 6e 76 69 72 6f 6e 6d 65
>8029		6e 74 2e 00
.8040		4c a7 80	jmp $80a7	Boot:	jmp 	Start

;******  Processing file: ./common/aa.system/../../../modules/.build/_exports.module.asm

=1						PagingEnabled = 1
.8043						EXTInitialise:
.8043		e6 0d		inc $0d			inc 8+5
.8045		20 e6 a1	jsr $a1e6		jsr	Export_EXTInitialise
.8048		08		php			php
.8049		c6 0d		dec $0d			dec 8+5
.804b		28		plp			plp
.804c		60		rts			rts
.804d						EXTPrintCharacter:
.804d		e6 0d		inc $0d			inc 8+5
.804f		20 0b a0	jsr $a00b		jsr	Export_EXTPrintCharacter
.8052		08		php			php
.8053		c6 0d		dec $0d			dec 8+5
.8055		28		plp			plp
.8056		60		rts			rts
.8057						EXTPrintNoControl:
.8057		e6 0d		inc $0d			inc 8+5
.8059		20 00 a0	jsr $a000		jsr	Export_EXTPrintNoControl
.805c		08		php			php
.805d		c6 0d		dec $0d			dec 8+5
.805f		28		plp			plp
.8060		60		rts			rts
.8061						EXTSetCurrentLine:
.8061		e6 0d		inc $0d			inc 8+5
.8063		20 d1 a1	jsr $a1d1		jsr	Export_EXTSetCurrentLine
.8066		08		php			php
.8067		c6 0d		dec $0d			dec 8+5
.8069		28		plp			plp
.806a		60		rts			rts
.806b						SNDCommand:
.806b		e6 0d		inc $0d			inc 8+5
.806d		20 ca b9	jsr $b9ca		jsr	Export_SNDCommand
.8070		08		php			php
.8071		c6 0d		dec $0d			dec 8+5
.8073		28		plp			plp
.8074		60		rts			rts
.8075						SNDUpdate:
.8075		e6 0d		inc $0d			inc 8+5
.8077		20 fd b9	jsr $b9fd		jsr	Export_SNDUpdate
.807a		08		php			php
.807b		c6 0d		dec $0d			dec 8+5
.807d		28		plp			plp
.807e		60		rts			rts
.807f						TKInitialise:
.807f		e6 0d		inc $0d			inc 8+5
.8081		20 57 b3	jsr $b357		jsr	Export_TKInitialise
.8084		08		php			php
.8085		c6 0d		dec $0d			dec 8+5
.8087		28		plp			plp
.8088		60		rts			rts
.8089						TKListConvertLine:
.8089		e6 0d		inc $0d			inc 8+5
.808b		20 63 b3	jsr $b363		jsr	Export_TKListConvertLine
.808e		08		php			php
.808f		c6 0d		dec $0d			dec 8+5
.8091		28		plp			plp
.8092		60		rts			rts
.8093						TKTokeniseLine:
.8093		e6 0d		inc $0d			inc 8+5
.8095		20 0f b6	jsr $b60f		jsr	Export_TKTokeniseLine
.8098		08		php			php
.8099		c6 0d		dec $0d			dec 8+5
.809b		28		plp			plp
.809c		60		rts			rts
.809d						GXGraphicDraw:
.809d		e6 0d		inc $0d			inc 8+5
.809f		20 7f a3	jsr $a37f		jsr	Export_GXGraphicDraw
.80a2		08		php			php
.80a3		c6 0d		dec $0d			dec 8+5
.80a5		28		plp			plp
.80a6		60		rts			rts

;******  Return to file: ./common/aa.system/00start.asm

.80a7		a2 ff		ldx #$ff	Start:	ldx 	#$FF 						; stack reset
.80a9		9a		txs				txs
.80aa		20 43 80	jsr $8043			jsr 	EXTInitialise 				; hardware initialise
.80ad		a5 00		lda $00				lda 	0  							; turn on editing of MMU LUT
.80af		09 80		ora #$80			ora 	#$80
.80b1		85 00		sta $00				sta 	0
.80b3		ad 02 20	lda $2002			lda 	$2002 						; if $2002..5 is BT65 then jump to $2000
.80b6		c9 42		cmp #$42			cmp 	#"B"
.80b8		d0 18		bne $80d2			bne 	_NoMachineCode
.80ba		ad 03 20	lda $2003			lda 	$2003
.80bd		c9 54		cmp #$54			cmp 	#"T"
.80bf		d0 11		bne $80d2			bne 	_NoMachineCode
.80c1		ad 04 20	lda $2004			lda 	$2004
.80c4		c9 36		cmp #$36			cmp 	#"6"
.80c6		d0 0a		bne $80d2			bne 	_NoMachineCode
.80c8		ad 05 20	lda $2005			lda 	$2005
.80cb		c9 35		cmp #$35			cmp 	#"5"
.80cd		d0 03		bne $80d2			bne 	_NoMachineCode
.80cf		4c 00 20	jmp $2000			jmp 	$2000
.80d2						_NoMachineCode:
.80d2		a9 00		lda #$00			lda 	#0 							; zero the default drive.
.80d4		20 41 84	jsr $8441			jsr 	KNLSetDrive
.80d7		20 7f 80	jsr $807f			jsr 	TKInitialise 				; initialise tokeniser.
.80da		a9 00		lda #$00			lda 	#0 							; graphics system initialise.
.80dc		aa		tax				tax
.80dd		a8		tay				tay
.80de		20 9d 80	jsr $809d			jsr 	GXGraphicDraw
.80e1		a9 0f		lda #$0f			lda 	#$0F 						; initialise sound system
.80e3		20 6b 80	jsr $806b			jsr 	SNDCommand
.80e6		a9 8d		lda #$8d			lda 	#128+13 					; Display FPGA information.
.80e8		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.80eb		a9 09		lda #$09			lda 	#9
.80ed		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.80f0		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.80f3		64 01		stz $01				stz 	1
.80f5		ad ad d6	lda $d6ad			lda 	$D6AD
.80f8		20 1b 86	jsr $861b			jsr 	PrintHex
.80fb		ad ac d6	lda $d6ac			lda 	$D6AC
.80fe		20 1b 86	jsr $861b			jsr 	PrintHex
.8101		ad ab d6	lda $d6ab			lda 	$D6AB
.8104		20 1b 86	jsr $861b			jsr 	PrintHex
.8107		ad aa d6	lda $d6aa			lda 	$D6AA
.810a		20 1b 86	jsr $861b			jsr 	PrintHex
.810d		a9 20		lda #$20			lda 	#32
.810f		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.8112		ad a8 d6	lda $d6a8			lda 	$D6A8
.8115		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.8118		ad a9 d6	lda $d6a9			lda 	$D6A9
.811b		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.811e		a9 0d		lda #$0d			lda 	#13 						; display Kernel information
.8120		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.8123		a9 09		lda #$09			lda 	#9
.8125		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.8128		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.812b		a9 08		lda #$08			lda 	#$08
.812d		a2 e0		ldx #$e0			ldx 	#$E0
.812f		20 78 95	jsr $9578			jsr 	PrintStringXA
.8132		a2 81		ldx #$81			ldx 	#Prompt >> 8 				; display prompt
.8134		a9 45		lda #$45			lda 	#Prompt & $FF
.8136		20 78 95	jsr $9578			jsr 	PrintStringXA
.8139		20 f6 82	jsr $82f6			jsr 	ResetIOTracking 			; reset the I/O tracking.
.813c		20 43 8f	jsr $8f43			jsr 	NewProgram 					; erase current program
.813f		4c 12 89	jmp $8912			jmp 	WarmStart					; make same size.
.8142		4c 12 89	jmp $8912			jmp 	WarmStart
>8145		0d				Prompt:	.text 	13

;******  Processing file: ./common/aa.system/../generated/timestamp.asm

>8146		09 09 30 31 2f 30 36 2f			.text 9,9,"01/06/25 01e"
>814e		32 35 20 30 31 65

;******  Return to file: ./common/aa.system/00start.asm

>8154		0d 0d 0d 00					.text 	13,13,13,0

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/ab.system/events.asm

.8158						ProcessEvents:
.8158		20 85 84	jsr $8485			jsr 	KNLSetEventPointer
.815b		20 ff 82	jsr $82ff			jsr     GetNextEvent 				; get next event
.815e		b0 53		bcs $81b3			bcs 	_PEExitZ 					; nothing left to process.
.8160		ad be 07	lda $07be			lda 	KNLEvent.type 				; go back if event not key.pressed.
.8163		c9 52		cmp #$52	                cmp     #kernel.event.timer.EXPIRED
.8165		f0 24		beq $818b	                beq     _PEIsTimer
.8167		c9 0a		cmp #$0a			cmp     #kernel.event.key.RELEASED
.8169		f0 27		beq $8192			beq     _PEIsRelease
.816b		c9 08		cmp #$08			cmp 	#kernel.event.key.PRESSED
.816d		d0 e9		bne $8158			bne 	ProcessEvents
.816f		ad c4 07	lda $07c4			lda	KNLEvent.key.flags 			; is KNLEvent.key.flags = 0 ?
.8172		30 20		bmi $8194			bmi 	_PEIsRaw
.8174		d0 e2		bne $8158			bne 	ProcessEvents
.8176		ad c3 07	lda $07c3			lda 	KNLEvent.key.ascii 			; is it Ctrl+C
.8179		c9 03		cmp #$03			cmp 	#3
.817b		f0 33		beq $81b0			beq 	_PEReturnBreak  			; no, keep going.
.817d		da		phx				phx
.817e		ae c1 07	ldx $07c1	                ldx     KNLEvent.key.keyboard
.8181		d0 05		bne $8188	                bne     +
.8183		aa		tax		                tax
.8184		20 fd 81	jsr $81fd	                jsr     StartRepeatTimerForKey
.8187		8a		txa		                txa
.8188		fa		plx		+               plx
.8189		80 14		bra $819f			bra 	_PEQueueA
.818b						_PEIsTimer:
.818b		20 20 82	jsr $8220	                jsr     HandleRepeatTimerEvent
.818e		b0 c8		bcs $8158	                bcs     ProcessEvents
.8190		80 0d		bra $819f	                bra     _PEQueueA
.8192						_PEIsRelease:
.8192		80 c4		bra $8158	                bra     ProcessEvents
.8194						_PEIsRaw:
.8194		ad c3 07	lda $07c3			lda 	KNLEvent.key.ascii 			; return pseudo ascii value if F1-F12
.8197		c9 81		cmp #$81			cmp 	#129
.8199		90 bd		bcc $8158			bcc		ProcessEvents
.819b		c9 8d		cmp #$8d			cmp 	#140+1
.819d		b0 b9		bcs $8158			bcs 	ProcessEvents
.819f						_PEQueueA:
.819f		da		phx				phx
.81a0		ae 80 06	ldx $0680			ldx 	KeyboardQueueEntries 		; get keyboard queue size into X
.81a3		e0 08		cpx #$08			cpx 	#KBDQueueSize 				; if full, then ignore
.81a5		f0 06		beq $81ad			beq 	_PENoQueue
.81a7		9d 78 06	sta $0678,x			sta 	KeyboardQueue,x 			; write into queue
.81aa		ee 80 06	inc $0680			inc 	KeyboardQueueEntries 		; bump count
.81ad						_PENoQueue:
.81ad		fa		plx				plx
.81ae		80 a8		bra $8158			bra 	ProcessEvents
.81b0						_PEReturnBreak:
.81b0		a9 ff		lda #$ff			lda 	#255 						; return with NZ state
.81b2		60		rts				rts
.81b3						_PEExitZ:
.81b3		a9 00		lda #$00			lda 	#0
.81b5		60		rts				rts
.81b6						PopKeyboardQueue:
.81b6		ad 80 06	lda $0680			lda 	KeyboardQueueEntries 		; get keyboard queue entries.
.81b9		f0 17		beq $81d2			beq 	_PKQExit 					; zero, then exit.
.81bb		ad 78 06	lda $0678			lda 	KeyboardQueue 				; save head of keyboard queue
.81be		48		pha				pha
.81bf		da		phx				phx 								; drop head of queue
.81c0		a2 00		ldx #$00			ldx 	#0
.81c2						_PKQLoop:
.81c2		bd 79 06	lda $0679,x			lda 	KeyboardQueue+1,x 			; shift everything back one.
.81c5		9d 78 06	sta $0678,x			sta 	KeyboardQueue,x  			; not efficient but doesn't matter.
.81c8		e8		inx				inx
.81c9		e0 07		cpx #$07			cpx 	#7
.81cb		d0 f5		bne $81c2			bne 	_PKQLoop
.81cd		fa		plx				plx
.81ce		ce 80 06	dec $0680			dec 	KeyboardQueueEntries 		; one fewer in queue.
.81d1		68		pla				pla 								; restore head of queue.
.81d2						_PKQExit:
.81d2		60		rts				rts
.81d3						KNLGetKeyPressed:
.81d3		a5 01		lda $01				lda 	1 							; save I/O 0
.81d5		48		pha				pha
.81d6		64 01		stz $01				stz 	1 							; access I/O Page 0
.81d8		38		sec				sec 								; calculate timer - LastTick
.81d9		ad 59 d6	lda $d659			lda 	$D659
.81dc		cd 81 06	cmp $0681			cmp 	LastTick
.81df		f0 06		beq $81e7			beq 	_NoFireTick 				; if < 3 clocks don't fire.
.81e1		8d 81 06	sta $0681			sta 	LastTick 					; update last timer
.81e4		20 ee 82	jsr $82ee			jsr 	TickHandler 							; go do the code.
.81e7						_NoFireTick:
.81e7		68		pla				pla 								; restore I/O 0
.81e8		85 01		sta $01				sta 	1
.81ea		ad 80 06	lda $0680			lda 	KeyboardQueueEntries 		; something in the queue
.81ed		d0 c7		bne $81b6			bne 	PopKeyboardQueue 			; if so, pop and return it
.81ef		20 58 81	jsr $8158			jsr 	ProcessEvents 				; process any outstanding events
.81f2		a9 00		lda #$00			lda 	#0
.81f4		60		rts				rts
.81f5						KNLGetSingleCharacter:
.81f5		20 d3 81	jsr $81d3			jsr 	KNLGetKeyPressed
.81f8		c9 00		cmp #$00			cmp 	#0
.81fa		f0 f9		beq $81f5			beq 	KNLGetSingleCharacter
.81fc		60		rts				rts
>0000						key             .byte   ?   ; Key-code to repeat.
>0001						cookie          .byte   ?   ; Timer ID.
.81fd						StartRepeatTimerForKey
.81fd		8d 76 06	sta $0676	                sta     repeat.key
.8200		ee 77 06	inc $0677	                inc     repeat.cookie
.8203		a9 80		lda #$80	                lda     #kernel.args.timer.FRAMES | kernel.args.timer.QUERY
.8205		85 f3		sta $f3		                sta     kernel.args.timer.units
.8207		20 f0 ff	jsr $fff0	                jsr     kernel.Clock.SetTimer
.820a		69 1e		adc #$1e	                adc     #30
.820c		80 04		bra $8212	                bra     ScheduleRepeatEvent
.820e						StopRepeat
.820e		ee 77 06	inc $0677	                inc     repeat.cookie
.8211		60		rts		                rts
.8212						ScheduleRepeatEvent
.8212		85 f4		sta $f4		                sta     kernel.args.timer.absolute
.8214		a9 00		lda #$00	                lda     #kernel.args.timer.FRAMES
.8216		85 f3		sta $f3		                sta     kernel.args.timer.units
.8218		ad 77 06	lda $0677	                lda     repeat.cookie
.821b		85 f5		sta $f5		                sta     kernel.args.timer.cookie
.821d		4c f0 ff	jmp $fff0	                jmp     kernel.Clock.SetTimer
.8220						HandleRepeatTimerEvent
.8220		ad c2 07	lda $07c2	                lda     KNLEvent.timer.cookie
.8223		cd 77 06	cmp $0677	                cmp     repeat.cookie
.8226		f0 02		beq $822a	                beq     _repeat
.8228		38		sec		                sec
.8229		60		rts		                rts
.822a						_repeat
.822a		ad c1 07	lda $07c1	                lda     KNLEvent.timer.value
.822d		18		clc		                clc
.822e		69 03		adc #$03	                adc     #3
.8230		20 12 82	jsr $8212	                jsr     ScheduleRepeatEvent
.8233		ad 76 06	lda $0676	                lda     repeat.key
.8236		18		clc		                clc
.8237		60		rts		                rts
.0676						repeat:
>0676						key             .byte   ?   ; Key-code to repeat.
>0677						cookie          .byte   ?   ; Timer ID.
=8						KBDQueueSize = 8
.0678						KeyboardQueue:
>0678								.fill 	KBDQueueSize
.0680						KeyboardQueueEntries:
>0680								.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/ab.system/input.asm

.8238						InputLine:
.8238		48		pha				pha
.8239		da		phx				phx
.823a		5a		phy				phy
.823b		a5 01		lda $01				lda 	1 							; save I/O page
.823d		48		pha				pha
.823e						_EILLoop:
.823e		20 f5 81	jsr $81f5			jsr 	KNLGetSingleCharacter 		; get one single character
.8241		c9 0d		cmp #$0d			cmp 	#13 						; scrape line if exit.
.8243		f0 53		beq $8298			beq 	_EILExit
.8245		c9 04		cmp #$04			cmp 	#4 							; Ctrl+D delete at cursor
.8247		f0 39		beq $8282			beq 	_EILDelete
.8249		c9 08		cmp #$08			cmp 	#8 							; Ctrl+H backspace
.824b		f0 2b		beq $8278			beq 	_EILBackspace
.824d		c9 20		cmp #$20			cmp 	#' '						; < space, print it
.824f		90 21		bcc $8272			bcc 	_EILPrintLoop
.8251		c9 7f		cmp #$7f			cmp 	#$7F 						; if -ve print it
.8253		b0 1d		bcs $8272			bcs 	_EILPrintLoop
.8255		aa		tax				tax 								; save character in X
.8256		a9 02		lda #$02			lda	 	#2 							; screen character memory
.8258		85 01		sta $01				sta 	1
.825a		ac ed 07	ldy $07ed			ldy 	EXTScreenWidth 				; read the last character.
.825d		88		dey				dey
.825e		b1 40		lda ($40),y			lda 	(EXTAddress),y
.8260		c9 20		cmp #$20			cmp 	#' ' 						; if not space then reject.
.8262		d0 da		bne $823e			bne 	_EILLoop
.8264		da		phx				phx 								; save character on stack
.8265		a9 02		lda #$02			lda 	#2  						; insert a space
.8267		85 01		sta $01				sta 	1
.8269		20 dc 82	jsr $82dc			jsr 	EXTILInsert 				; insert in text screen
.826c		e6 01		inc $01				inc 	1
.826e		20 dc 82	jsr $82dc			jsr 	EXTILInsert 				; insert in colour screen
.8271		68		pla				pla 								; get character back.
.8272						_EILPrintLoop:
.8272		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.8275		80 c7		bra $823e			bra 	_EILLoop
.8277		60		rts				rts
.8278						_EILBackspace:
.8278		ad eb 07	lda $07eb			lda 	EXTColumn					; can we backspace ?
.827b		f0 c1		beq $823e			beq 	_EILLoop
.827d		a9 02		lda #$02			lda 	#2 							; move cursor left
.827f		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.8282						_EILDelete
.8282		a9 02		lda #$02			lda 	#2 							; text block
.8284		85 01		sta $01				sta 	1
.8286		a9 20		lda #$20			lda 	#' ' 						; backspace text.
.8288		20 c7 82	jsr $82c7			jsr 	EXTILDelete
.828b		e6 01		inc $01				inc 	1 							; colour block
.828d		ac eb 07	ldy $07eb			ldy 	EXTColumn 					; get attribute of last character
.8290		88		dey				dey
.8291		b1 40		lda ($40),y			lda 	(EXTAddress),y
.8293		20 c7 82	jsr $82c7			jsr 	EXTILDelete 				; backspace attribute
.8296		80 a6		bra $823e			bra 	_EILLoop 					; and go round.
.8298						_EILExit:
.8298		a9 02		lda #$02			lda 	#2 							; switch to page 2
.829a		85 01		sta $01				sta 	1
.829c		a0 00		ldy #$00			ldy 	#0 							; copy current line into buffer.
.829e						_EILScrapeLine:
.829e		b1 40		lda ($40),y			lda 	(EXTAddress),y
.82a0		99 46 05	sta $0546,y			sta 	lineBuffer,y
.82a3		c8		iny				iny
.82a4		cc ed 07	cpy $07ed			cpy 	EXTScreenWidth
.82a7		d0 f5		bne $829e			bne 	_EILScrapeLine
.82a9						_EILTrimSpaces:
.82a9		88		dey				dey
.82aa		c0 ff		cpy #$ff			cpy 	#$FF 						; back past the start
.82ac		f0 07		beq $82b5			beq 	_EILEndTrim		 			; zero the input line.
.82ae		b9 46 05	lda $0546,y			lda 	lineBuffer,y
.82b1		c9 20		cmp #$20			cmp 	#' '
.82b3		f0 f4		beq $82a9			beq 	_EILTrimSpaces 				; if fail this found non space character
.82b5						_EILEndTrim:
.82b5		c8		iny				iny 								; trim after non space character.
.82b6		a9 00		lda #$00			lda 	#0 							; trim here.
.82b8		99 46 05	sta $0546,y			sta 	lineBuffer,y
.82bb		a9 0d		lda #$0d			lda 	#13 						; echo the RETURN
.82bd		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.82c0		68		pla				pla 								; reset I/O page
.82c1		85 01		sta $01				sta 	1
.82c3		7a		ply				ply
.82c4		fa		plx				plx
.82c5		68		pla				pla
.82c6		60		rts				rts
.82c7						EXTILDelete:
.82c7		48		pha				pha 								; save the new character
.82c8		ac eb 07	ldy $07eb			ldy 	EXTColumn 					; start copying from here.
.82cb						_EXTDLoop:
.82cb		c8		iny				iny 								; copy one byte down.
.82cc		b1 40		lda ($40),y			lda 	(EXTAddress),y
.82ce		88		dey				dey
.82cf		91 40		sta ($40),y			sta 	(EXTAddress),y
.82d1		c8		iny				iny 								; do till end of line.
.82d2		cc ed 07	cpy $07ed			cpy 	EXTScreenWidth
.82d5		90 f4		bcc $82cb			bcc 	_EXTDLoop
.82d7		88		dey				dey 	 							; write in last slot.
.82d8		68		pla				pla
.82d9		91 40		sta ($40),y			sta 	(EXTAddress),y
.82db		60		rts				rts
.82dc						EXTILInsert:
.82dc		ac ed 07	ldy $07ed			ldy 	EXTScreenWidth 				; end position
.82df						_EXTILoop:
.82df		88		dey				dey 								; back one
.82e0		cc eb 07	cpy $07eb			cpy 	EXTColumn 					; exit if reached insert point.
.82e3		f0 08		beq $82ed			beq 	_EXTIExit
.82e5		88		dey				dey 								; copy one byte up.
.82e6		b1 40		lda ($40),y			lda 	(EXTAddress),y
.82e8		c8		iny				iny
.82e9		91 40		sta ($40),y			sta 	(EXTAddress),y
.82eb		80 f2		bra $82df			bra 	_EXTILoop
.82ed						_EXTIExit:
.82ed		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/ab.system/ticktask.asm

.82ee						TickHandler:
.82ee		da		phx				phx
.82ef		5a		phy				phy 								; need to preserve Y
.82f0		20 75 80	jsr $8075			jsr 	SNDUpdate 					; update sound
.82f3		7a		ply				ply
.82f4		fa		plx				plx
.82f5		60		rts				rts
.0681						LastTick:
>0681								.fill 		1

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/ab.system/trackio.asm

.82f6						ResetIOTracking:
.82f6		a2 3a		ldx #$3a			ldx 	#GNEEnd-GNEBegin-1
.82f8						_RIOLoop:
.82f8		9e 82 06	stz $0682,x			stz 	GNEBegin,x
.82fb		ca		dex				dex
.82fc		10 fa		bpl $82f8			bpl 	_RIOLoop
.82fe		60		rts				rts
.82ff						GetNextEvent:
.82ff		20 00 ff	jsr $ff00			jsr 	kernel.NextEvent 			; get event
.8302		08		php				php									; save yes/no flag.
.8303		b0 29		bcs $832e			bcs 	_GNEExit
.8305		48		pha				pha 								; save registers
.8306		da		phx				phx
.8307		5a		phy				phy
.8308		ad be 07	lda $07be			lda 	KNLEvent.type	 			; check for PRESSED or RELEASED
.830b		c9 08		cmp #$08			cmp 	#kernel.event.key.PRESSED
.830d		f0 04		beq $8313			beq 	_GNEKeyEvent
.830f		c9 0a		cmp #$0a			cmp 	#kernel.event.key.RELEASED
.8311		d0 08		bne $831b			bne 	_GNECheckMouseEvent
.8313						_GNEKeyEvent:
.8313		20 ed 83	jsr $83ed			jsr 	ProcessKeyboardEvent 		; process keyboard up/down.
.8316		20 0c 84	jsr $840c			jsr 	UpdateKeyboardJoystick 		; update the keyboard-joystick.
.8319		80 10		bra $832b			bra 	_GNEEventExit
.831b						_GNECheckMouseEvent:
.831b		c9 0c		cmp #$0c			cmp 	#kernel.event.mouse.DELTA 	; check for move events
.831d		d0 05		bne $8324			bne 	_GNENotDelta
.831f		20 30 83	jsr $8330			jsr 	ProcessMouseDeltaEvent 		; process them.
.8322		80 07		bra $832b			bra 	_GNEEventExit
.8324						_GNENotDelta:
.8324		c9 0e		cmp #$0e			cmp 	#kernel.event.mouse.CLICKS 	; check for click events
.8326		d0 03		bne $832b			bne 	_GNEEventExit
.8328		20 5f 83	jsr $835f			jsr 	ProcessMouseClickEvent 		; process them.
.832b						_GNEEventExit:
.832b		7a		ply				ply 								; restore registers
.832c		fa		plx				plx
.832d		68		pla				pla
.832e						_GNEExit:
.832e		28		plp				plp
.832f		60		rts				rts
.8330						ProcessMouseDeltaEvent:
.8330		a2 23		ldx #$23			ldx 	#MouseDeltaX-GNEBegin
.8332		ad c1 07	lda $07c1			lda 	KNLEvent.mouse.delta.x
.8335		20 86 83	jsr $8386			jsr 	PMKAdjustTotal
.8338		20 c9 83	jsr $83c9			jsr 	PMKAddSubtract
.833b		ad c2 07	lda $07c2			lda 	KNLEvent.mouse.delta.y
.833e		20 86 83	jsr $8386			jsr 	PMKAdjustTotal
.8341		20 c9 83	jsr $83c9			jsr 	PMKAddSubtract
.8344		ad c3 07	lda $07c3			lda 	KNLEvent.mouse.delta.z
.8347		20 86 83	jsr $8386			jsr 	PMKAdjustTotal
.834a		20 c9 83	jsr $83c9			jsr 	PMKAddSubtract
.834d		ad c4 07	lda $07c4			lda 	KNLEvent.mouse.delta.buttons
.8350		a2 35		ldx #$35			ldx 	#MouseStatusX-GNEBegin
.8352		20 74 83	jsr $8374			jsr 	PMKOutputButton
.8355		20 74 83	jsr $8374			jsr 	PMKOutputButton
.8358		20 74 83	jsr $8374			jsr 	PMKOutputButton
.835b		20 95 83	jsr $8395			jsr 	PMKClipMouseCoord
.835e		60		rts				rts
.835f						ProcessMouseClickEvent:
.835f		a2 29		ldx #$29			ldx 	#MouseCountInner-GNEBegin
.8361		ad c1 07	lda $07c1			lda 	KNLEvent.mouse.clicks.inner
.8364		20 cd 83	jsr $83cd			jsr 	PMKAdd
.8367		ad c2 07	lda $07c2			lda 	KNLEvent.mouse.clicks.middle
.836a		20 cd 83	jsr $83cd			jsr 	PMKAdd
.836d		ad c3 07	lda $07c3			lda 	KNLEvent.mouse.clicks.outer
.8370		20 cd 83	jsr $83cd			jsr 	PMKAdd
.8373		60		rts				rts
.8374						PMKOutputButton:
.8374		9e 82 06	stz $0682,x			stz 	GNEBegin,x 					; button to zero
.8377		9e 83 06	stz $0683,x			stz 	GNEBegin+1,x
.837a		6a		ror a				ror 	a 							; shift LSB into carry
.837b		90 06		bcc $8383			bcc 	_PMKOBExit
.837d		de 82 06	dec $0682,x			dec 	GNEBegin,x 					; if set then set to -1
.8380		de 83 06	dec $0683,x			dec 	GNEBegin+1,x
.8383						_PMKOBExit:
.8383		e8		inx				inx  								; next button
.8384		e8		inx				inx
.8385		60		rts				rts
.8386						PMKAdjustTotal:
.8386		48		pha				pha 								; save offset A index X
.8387		da		phx				phx
.8388		48		pha				pha 								; point X to the position
.8389		8a		txa				txa
.838a		18		clc				clc
.838b		69 0c		adc #$0c			adc 	#MousePosX-MouseDeltaX
.838d		aa		tax				tax
.838e		68		pla				pla
.838f		20 c9 83	jsr $83c9			jsr 	PMKAddSubtract 				; reuse the addition code.
.8392		fa		plx				plx 								; restore XA
.8393		68		pla				pla
.8394		60		rts				rts
.8395						PMKClipMouseCoord:
.8395		a2 00		ldx #$00			ldx 	#0
.8397						_PCMCLoop:
.8397		bd b2 06	lda $06b2,x			lda 	MousePosX+1,x 				; check if -ve
.839a		10 06		bpl $83a2			bpl 	_PCMCNotNeg
.839c		9e b1 06	stz $06b1,x			stz 	MousePosX,x 				; if so zero position.
.839f		9e b2 06	stz $06b2,x			stz 	MousePosX+1,x
.83a2						_PCMCNotNeg:
.83a2		bd b1 06	lda $06b1,x			lda 	MousePosX,x 				; compare pos vs extent
.83a5		dd c3 83	cmp $83c3,x			cmp 	_PCMCExtent,x
.83a8		bd b2 06	lda $06b2,x			lda 	MousePosX+1,x
.83ab		fd c4 83	sbc $83c4,x			sbc 	_PCMCExtent+1,x
.83ae		90 0c		bcc $83bc			bcc 	_PCMCNotOver 				; in range ?
.83b0		bd c3 83	lda $83c3,x			lda 	_PCMCExtent,x 				; no, set to X limit.
.83b3		9d b1 06	sta $06b1,x			sta 	MousePosX,x
.83b6		bd c4 83	lda $83c4,x			lda 	_PCMCExtent+1,x
.83b9		9d b2 06	sta $06b2,x			sta 	MousePosX+1,x
.83bc						_PCMCNotOver:
.83bc		e8		inx				inx
.83bd		e8		inx				inx
.83be		e0 06		cpx #$06			cpx 	#3*2
.83c0		d0 d5		bne $8397			bne 	_PCMCLoop
.83c2		60		rts				rts
.83c3						_PCMCExtent:
>83c3		3f 01 ef 00 ff 00				.word 	319,239,255
.83c9						PMKAddSubtract:
.83c9		c9 00		cmp #$00			cmp 	#0 							; subtracting ?
.83cb		30 0e		bmi $83db			bmi 	PMKSubtract
.83cd						PMKAdd:
.83cd		18		clc				clc
.83ce		7d 82 06	adc $0682,x			adc 	GNEBegin,x
.83d1		9d 82 06	sta $0682,x			sta 	GNEBegin,x
.83d4		90 14		bcc $83ea			bcc 	PMKExit
.83d6		fe 83 06	inc $0683,x			inc 	GNEBegin+1,x
.83d9		80 0f		bra $83ea			bra 	PMKExit
.83db						PMKSubtract:
.83db		18		clc				clc
.83dc		7d 82 06	adc $0682,x			adc 	GNEBegin,x
.83df		9d 82 06	sta $0682,x			sta 	GNEBegin,x
.83e2		bd 83 06	lda $0683,x			lda 	GNEBegin+1,x
.83e5		69 ff		adc #$ff			adc 	#$FF
.83e7		9d 83 06	sta $0683,x			sta 	GNEBegin+1,x
.83ea						PMKExit:
.83ea		e8		inx				inx 								; next slot ?
.83eb		e8		inx				inx
.83ec		60		rts				rts
.83ed						ProcessKeyboardEvent:
.83ed		ad c2 07	lda $07c2			lda 	KNLEvent.key.raw 			; raw key code.
.83f0		20 2d 84	jsr $842d			jsr 	KeyboardConvertXA  			; convert to index in X, mask in A
.83f3		ac be 07	ldy $07be			ldy 	KNLEvent.type
.83f6		c0 0a		cpy #$0a			cpy 	#kernel.event.key.RELEASED 	; check if pressed/released
.83f8		f0 07		beq $8401			beq 	_PKERelease
.83fa		1d 83 06	ora $0683,x			ora 	KeyStatus,x 				; set bit
.83fd		9d 83 06	sta $0683,x			sta 	KeyStatus,x
.8400		60		rts				rts
.8401						_PKERelease:
.8401		49 ff		eor #$ff			eor 	#$FF						; clear bit
.8403		3d 83 06	and $0683,x			and 	KeyStatus,x
.8406		9d 83 06	sta $0683,x			sta 	KeyStatus,x
.8409		4c 0e 82	jmp $820e			jmp     StopRepeat      ; See events.asm.
.840c						UpdateKeyboardJoystick:
.840c		9c a4 06	stz $06a4			stz 	KeyJoystick
.840f		a2 00		ldx #$00			ldx 	#0
.8411						_UKJLoop:
.8411		bd 28 84	lda $8428,x			lda 	_UKJKeys,x 					; which key
.8414		29 1f		and #$1f			and 	#$1F
.8416		a8		tay				tay
.8417		b9 83 06	lda $0683,y			lda 	KeyStatus,y 				; get status
.841a		29 10		and #$10			and 	#$10 						; letters always bit 4 (actually ASCII of L/C)
.841c		18		clc				clc  								; set C if bit set
.841d		69 ff		adc #$ff			adc 	#$FF
.841f		2e a4 06	rol $06a4			rol 	KeyJoystick 				; shift into place
.8422		e8		inx				inx
.8423		e0 05		cpx #$05			cpx 	#5 							; do all 5
.8425		d0 ea		bne $8411			bne 	_UKJLoop
.8427		60		rts				rts
.8428						_UKJKeys:
>8428		4c 58 5a 4d 4b					.byte	'L','X','Z','M','K'
.842d						KeyboardConvertXA:
.842d		a2 01		ldx #$01			ldx 	#1 							; set the mask temp to %00000001
.842f		8e a3 06	stx $06a3			stx 	KeyMaskTemp
.8432						_KCCALoop:
.8432		18		clc				clc
.8433		69 20		adc #$20			adc 	#$20 						; upper 3 bits are the mask, if causes CS A will be in the range 00-1F
.8435		b0 05		bcs $843c			bcs 	_KCCADone
.8437		0e a3 06	asl $06a3			asl 	KeyMaskTemp 				; shift the mask temp
.843a		80 f6		bra $8432			bra 	_KCCALoop
.843c						_KCCADone:
.843c		aa		tax				tax 								; table entry in X
.843d		ad a3 06	lda $06a3			lda 	KeyMaskTemp 				; mask temp in A.
.8440		60		rts				rts
.0682						GNEBegin:
.0682						CMDMouseFlag:
>0682								.fill 	1
.0683						KeyStatus:
>0683								.fill 	32
.06a3						KeyMaskTemp:
>06a3								.fill 	1
.06a4						KeyJoystick:
>06a4								.fill 	1
.06a5						MouseDeltaX:
>06a5								.fill 	2
.06a7						MouseDeltaY:
>06a7								.fill 	2
.06a9						MouseDeltaZ:
>06a9								.fill 	2
.06ab						MouseCountInner:
>06ab								.fill 	2
.06ad						MouseCountMiddle:
>06ad								.fill 	2
.06af						MouseCountOuter:
>06af								.fill 	2
.06b1						MousePosX:
>06b1								.fill 	2
.06b3						MousePosY:
>06b3								.fill 	2
.06b5						MousePosZ:
>06b5								.fill 	2
.06b7						MouseStatusX:
>06b7								.fill 	2
.06b9						MouseStatusY:
>06b9								.fill 	2
.06bb						MouseStatusZ:
>06bb								.fill 	2
.06bd						GNEEnd:

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/ab.system/wrapper.asm

=56						KERR_GENERAL = kernel.event.file.ERROR 		; Event $38
=50						KERR_CLOSED = kernel.event.file.CLOSED 		; Event $32
=40						KERR_NOTFOUND = kernel.event.file.NOT_FOUND ; Event $28
=48						KERR_EOF = kernel.event.file.EOF 			; Event $30
=64						KNLReadBufferLen = 64 								; read buffer size.
.8441						KNLSetDrive:
.8441		8d bd 07	sta $07bd			sta 	KNLDefaultDrive
.8444		60		rts				rts
.8445						KNLOpenFileWrite:
.8445		48		pha				pha
.8446		a9 01		lda #$01			lda 	#kernel.args.file.open.WRITE
.8448		80 03		bra $844d			bra 	KNLOpenStart
.844a						KNLOpenFileRead:
.844a		48		pha				pha
.844b		a9 00		lda #$00			lda     #kernel.args.file.open.READ ; set READ mode.
.844d						KNLOpenStart:
.844d		85 f5		sta $f5				sta     kernel.args.file.open.mode
.844f		68		pla				pla
.8450		5a		phy				phy
.8451		20 90 84	jsr $8490			jsr 	KNLSetupFileName
.8454		20 85 84	jsr $8485			jsr 	KNLSetEventPointer
.8457		ad bd 07	lda $07bd			lda 	KNLDefaultDrive 			; currently drive zero only.
.845a		85 f3		sta $f3				sta 	kernel.args.file.open.drive
.845c		20 5c ff	jsr $ff5c			jsr     kernel.File.Open 			; open the file and exit.
.845f		b0 1c		bcs $847d			bcs     _kernel_error
.8461		a8		tay				tay
.8462						_loop
.8462		20 0c ff	jsr $ff0c			jsr     kernel.Yield    			; event wait
.8465		20 ff 82	jsr $82ff			jsr     GetNextEvent
.8468		b0 f8		bcs $8462			bcs     _loop
.846a		ad be 07	lda $07be			lda 	KNLEvent.type
.846d		c9 2a		cmp #$2a			cmp     #kernel.event.file.OPENED
.846f		f0 10		beq $8481			beq 	_success
.8471		c9 28		cmp #$28			cmp     #kernel.event.file.NOT_FOUND
.8473		f0 0e		beq $8483			beq 	_exit
.8475		c9 38		cmp #$38			cmp     #kernel.event.file.ERROR
.8477		d0 e9		bne $8462			bne 	_loop
.8479		a9 28		lda #$28			lda		#kernel.event.file.NOT_FOUND
.847b		80 06		bra $8483			bra		_exit
.847d						_kernel_error
.847d		a9 38		lda #$38			lda     #kernel.event.file.ERROR
.847f		80 02		bra $8483			bra		_exit
.8481						_success
.8481		98		tya				tya
.8482		18		clc				clc
.8483						_exit
.8483		7a		ply				ply
.8484		60		rts				rts
.8485						KNLSetEventPointer:
.8485		48		pha				pha
.8486		a9 be		lda #$be			lda     #KNLEvent & $FF 			; tell kernel where to store event data
.8488		85 f0		sta $f0				sta     kernel.args.events+0
.848a		a9 07		lda #$07			lda     #KNLEvent >> 8
.848c		85 f1		sta $f1				sta     kernel.args.events+1
.848e		68		pla				pla
.848f		60		rts				rts
.8490						KNLSetupFileName:
.8490		5a		phy				phy 								; save Y on stack
.8491		85 36		sta $36				sta 	zTemp0 						; save filename position in temp, and in kenrel slot
.8493		86 37		stx $37				stx 	zTemp0+1
.8495		85 fb		sta $fb				sta     kernel.args.file.open.fname+0
.8497		86 fc		stx $fc				stx     kernel.args.file.open.fname+1
.8499		a0 ff		ldy #$ff			ldy 	#$FF 						; get the filename length => Kernel slot
.849b						_KNLGetLength:
.849b		c8		iny				iny
.849c		b1 36		lda ($36),y			lda 	(zTemp0),y
.849e		d0 fb		bne $849b			bne 	_KNLGetLength
.84a0		84 fd		sty $fd				sty 	kernel.args.file.open.fname_len
.84a2		7a		ply				ply
.84a3		60		rts				rts
.84a4						KNLReadBlock:
.84a4		85 f3		sta $f3				sta     kernel.args.file.read.stream
.84a6		86 f4		stx $f4				stx     kernel.args.file.read.buflen
.84a8		20 60 ff	jsr $ff60			jsr     kernel.File.Read 			; read request
.84ab		a9 38		lda #$38			lda     #kernel.event.file.ERROR    ; Kernel out of events/buffers; shouldn't happen
.84ad		b0 2e		bcs $84dd			bcs     _KGNBExitFail               ; report as general error
.84af						_KGRBEventLoop:
.84af		20 0c ff	jsr $ff0c			jsr     kernel.Yield    			; event wait
.84b2		20 ff 82	jsr $82ff			jsr     GetNextEvent
.84b5		b0 f8		bcs $84af			bcs     _KGRBEventLoop
.84b7		ad be 07	lda $07be			lda 	KNLEvent.type 				; get event
.84ba		c9 2c		cmp #$2c			cmp     #kernel.event.file.DATA 	; data, return data
.84bc		f0 0a		beq $84c8			beq     _KNLRBGetNextByte
.84be		c9 38		cmp #$38			cmp     #kernel.event.file.ERROR  	; errors on file i/o, return as appropriate.
.84c0		f0 1b		beq $84dd			beq 	_KGNBExitFail
.84c2		c9 30		cmp #$30			cmp     #kernel.event.file.EOF
.84c4		f0 17		beq $84dd			beq 	_KGNBExitFail
.84c6		80 e7		bra $84af			bra 	_KGRBEventLoop
.84c8						_KNLRBGetNextByte:
.84c8		a9 bd		lda #$bd			lda     #<KNLReadBuffer 			; Set the target buffer
.84ca		85 fb		sta $fb				sta     kernel.args.recv.buf+0
.84cc		a9 06		lda #$06			lda     #>KNLReadBuffer
.84ce		85 fc		sta $fc				sta     kernel.args.recv.buf+1
.84d0		ad c4 07	lda $07c4			lda     KNLEvent.file.data.read 	; Set the target length
.84d3		85 fd		sta $fd				sta     kernel.args.recv.buflen
.84d5		20 04 ff	jsr $ff04			jsr     kernel.ReadData		       	; Get the data from the kernel  (Synchronous call, no error)
.84d8		ad c4 07	lda $07c4			lda     KNLEvent.file.data.read 	; Return # of bytes read (in A)
.84db		18		clc				clc
.84dc		60		rts				rts
.84dd						_KGNBExitFail:
.84dd		38		sec				sec
.84de		60		rts				rts
.84df						KNLWriteBlock:
.84df		da		phx				phx
.84e0		5a		phy				phy
.84e1		85 f3		sta $f3				sta     kernel.args.file.write.stream ; save the stream.
.84e3		a5 36		lda $36				lda     zTemp0 						; save the data location.
.84e5		85 fb		sta $fb				sta     kernel.args.file.write.buf+0
.84e7		a5 37		lda $37				lda     zTemp0+1
.84e9		85 fc		sta $fc				sta     kernel.args.file.write.buf+1
.84eb		86 fd		stx $fd				stx     kernel.args.file.write.buflen ; Set the buffer length
.84ed		20 64 ff	jsr $ff64			jsr     kernel.File.Write 			; write it out.
.84f0		a9 38		lda #$38			lda 	#kernel.event.file.ERROR 	; in case it fails.
.84f2		b0 21		bcs $8515			bcs 	_KWBFailed
.84f4						_KNLWLoop:
.84f4		20 0c ff	jsr $ff0c			jsr     kernel.Yield
.84f7		20 ff 82	jsr $82ff			jsr     GetNextEvent
.84fa		b0 f8		bcs $84f4			bcs     _KNLWLoop
.84fc		ad be 07	lda $07be			lda     KNLEvent.type 				; various errors.
.84ff		c9 32		cmp #$32			cmp     #kernel.event.file.CLOSED
.8501		f0 12		beq $8515			beq 	_KWBFailed
.8503		c9 38		cmp #$38			cmp     #kernel.event.file.ERROR
.8505		f0 0e		beq $8515			beq 	_KWBFailed
.8507		c9 30		cmp #$30			cmp     #kernel.event.file.EOF
.8509		f0 0a		beq $8515			beq 	_KWBFailed
.850b		c9 2e		cmp #$2e			cmp     #kernel.event.file.WROTE 	; wait until block write succeeds
.850d		d0 e5		bne $84f4			bne 	_KNLWLoop
.850f		18		clc				clc
.8510		ad c4 07	lda $07c4			lda    KNLEvent.file.wrote.wrote 	; get bytes written.
.8513		80 01		bra $8516			bra 	_KWBExit
.8515						_KWBFailed:
.8515		38		sec				sec
.8516						_KWBExit:
.8516		7a		ply				ply
.8517		fa		plx				plx
.8518		60		rts				rts
.8519						KNLCloseFile:
.8519		85 f3		sta $f3				sta     kernel.args.file.close.stream
.851b		20 68 ff	jsr $ff68			jsr     kernel.File.Close
.851e		60		rts				rts
.851f						KNLReadController:
.851f		da		phx				phx
.8520		a6 01		ldx $01				ldx 	1 							; save current I/O in X
.8522		64 01		stz $01				stz 	1 							; switch to I/O 0
.8524		ad 00 dc	lda $dc00			lda 	$DC00  						; read VIA register
.8527		49 ff		eor #$ff			eor 	#$FF 						; make active '1'
.8529		0d a4 06	ora $06a4			ora 	KeyJoystick 				; use key joystick.
.852c		86 01		stx $01				stx 	1 							; repair old I/O and exit
.852e		fa		plx				plx
.852f		60		rts				rts
.06bd						KNLReadBuffer:
>06bd								.fill   256
.07bd						KNLDefaultDrive:
>07bd								.byte 	?
.07be						KNLEvent
>07be						type        .byte   ?   ; Enum above
>07bf						buf         .byte   ?   ; page id or zero
>07c0						ext         .byte   ?   ; page id or zero
.07c1						key
>07c1						keyboard    .byte   ?   ; Keyboard ID
>07c2						raw         .byte   ?   ; Raw key ID
>07c3						ascii       .byte   ?   ; ASCII value
>07c4						flags       .byte   ?   ; Flags (META)
=$80						META        = $80       ; Meta key; no associated ASCII value.
.07c1						mouse
.07c1						delta
>07c1						x           .byte   ?
>07c2						y           .byte   ?
>07c3						z           .byte   ?
>07c4						buttons     .byte   ?
.07c1						clicks
>07c1						inner       .byte   ?
>07c2						middle      .byte   ?
>07c3						outer       .byte   ?
.07c1						joystick
>07c1						joy0        .byte   ?
>07c2						joy1        .byte   ?
.07c1						udp
>07c1						token       .byte   ?   ; TODO: break out into fields
.07c1						tcp
>07c1						len         .byte   ?   ; Raw packet length.
.07c1						file
>07c1						stream      .byte   ?
>07c2						cookie      .byte   ?
.07c3						data
>07c3						requested   .byte   ?   ; Requested number of bytes to read
>07c4						read        .byte   ?   ; Number of bytes actually read
.07c3						wrote
>07c3						requested   .byte   ?   ; Requested number of bytes to read
>07c4						wrote       .byte   ?   ; Number of bytes actually read
.07c1						directory
>07c1						stream      .byte   ?
>07c2						cookie      .byte   ?
.07c3						volume
>07c3						len         .byte   ?   ; Length of volname (in buf)
>07c4						flags       .byte   ?   ; block size, text encoding
.07c3						file
>07c3						len         .byte   ?
>07c4						flags       .byte   ?   ; block scale, text encoding, approx size
.07c3						free
>07c3						flags       .byte   ?   ; block scale, text encoding, approx size
.07c1						timer
>07c1						value       .byte   ?
>07c2						cookie      .byte   ?

;******  Return to file: _basic.asm


;******  Processing file: ./common/api/api.asm

>ff00						NextEvent   .fill   4   ; Copy the next event into user-space.
>ff04						ReadData    .fill   4   ; Copy primary bulk event data into user-space
>ff08						ReadExt     .fill   4   ; Copy secondary bolk event data into user-space
>ff0c						Yield       .fill   4   ; Give unused time to the kernel.
>ff10						Putch       .fill   4   ; deprecated
>ff14						RunBlock    .fill   4   ; Chain to resident program by block ID.
>ff18						RunNamed    .fill   4   ; Chain to resident program by name.
>ff1c						            .fill   4   ; reserved
>ff20						List        .fill   4   ; Returns a bit-set of available block-accessible devices.
>ff24						GetName     .fill   4   ; Gets the hardware level name of the given block device or media.
>ff28						GetSize     .fill   4   ; Get the number of raw sectors (48 bits) for the given device
>ff2c						Read        .fill   4   ; Read a raw sector (48 bit LBA)
>ff30						Write       .fill   4   ; Write a raw sector (48 bit LBA)
>ff34						Format      .fill   4   ; Perform a low-level format if the media support it.
>ff38						Export      .fill   4   ; Update the FileSystem table with the partition table (if present).
>ff3c						List        .fill   4   ; Returns a bit-set of available logical devices.
>ff40						GetSize     .fill   4   ; Get the size of the partition or logical device in sectors.
>ff44						MkFS        .fill   4   ; Creates a new file-system on the logical device.
>ff48						CheckFS     .fill   4   ; Checks the file-system for errors and corrects them.
>ff4c						Mount       .fill   4   ; Mark the file-system as available for File and Directory operations.
>ff50						Unmount     .fill   4   ; Mark the file-system as unavailable for File and Directory operations.
>ff54						ReadBlock   .fill   4   ; Read a partition-local raw sector on an unmounted device.
>ff58						WriteBlock  .fill   4   ; Write a partition-local raw sector on an unmounted device.
>ff5c						Open        .fill   4   ; Open the given file for read, create, or append.
>ff60						Read        .fill   4   ; Request bytes from a file opened for reading.
>ff64						Write       .fill   4   ; Write bytes to a file opened for create or append.
>ff68						Close       .fill   4   ; Close an open file.
>ff6c						Rename      .fill   4   ; Rename a closed file.
>ff70						Delete      .fill   4   ; Delete a closed file.
>ff74						Seek        .fill   4   ; Seek to a specific position in a file.
>ff78						Open        .fill   4   ; Open a directory for reading.
>ff7c						Read        .fill   4   ; Read a directory entry; may also return VOLUME and FREE events.
>ff80						Close       .fill   4   ; Close a directory once finished reading.
>ff84						MkDir       .fill   4   ; Create a directory
>ff88						RmDir       .fill   4   ; Delete a directory
>ff8c						            .fill   4   ; call gate
>ff90						GetIP       .fill   4   ; Get the local IP address.
>ff94						SetIP       .fill   4   ; Set the local IP address.
>ff98						GetDNS      .fill   4   ; Get the configured DNS IP address.
>ff9c						SetDNS      .fill   4   ; Set the configured DNS IP address.
>ffa0						SendICMP    .fill   4
>ffa4						Match       .fill   4
>ffa8						Init        .fill   4
>ffac						Send        .fill   4
>ffb0						Recv        .fill   4
>ffb4						Open        .fill   4
>ffb8						Accept      .fill   4
>ffbc						Reject      .fill   4
>ffc0						Send        .fill   4
>ffc4						Recv        .fill   4
>ffc8						Close       .fill   4
>ffcc						Reset       .fill   4   ; Re-init the display
>ffd0						GetSize     .fill   4   ; Returns rows/cols in kernel args.
>ffd4						DrawRow     .fill   4   ; Draw text/color buffers left-to-right
>ffd8						DrawColumn  .fill   4   ; Draw text/color buffers top-to-bottom
>ffdc						GetTime     .fill   4
>ffe0						SetTime     .fill   4
>ffe4						            .fill   12  ; 65816 vectors
>fff0						SetTimer    .fill   4
.00f0						args
.00f0						events
>00f0						dest        .word       ?   ; GetNextEvent copies event data here
>00f2						pending     .byte       ?   ; Negative count of pending events
.00f3						end
.00f3						run
>00f3						block_id    .byte   ?
.00f3						recv
=$fb						buf         = args.buf
=$fd						buflen      = args.buflen
.00f3						fs
.00f3						format
>00f3						drive       .byte       ?
>00f4						cookie      .byte       ?
=$fb						label       = args.buf
=$fd						label_len   = args.buflen
.00f3						mkfs
>00f3						drive       .byte       ?
>00f4						cookie      .byte       ?
=$fb						label       = args.buf
=$fd						label_len   = args.buflen
.00f3						file
.00f3						open
>00f3						drive       .byte       ?
>00f4						cookie      .byte       ?
=$fb						fname       = args.buf
=$fd						fname_len   = args.buflen
>00f5						mode        .byte       ?
=0						READ        = 0
=1						WRITE       = 1
=2						END         = 2
.00f3						read
>00f3						stream      .byte       ?
>00f4						buflen      .byte       ?
.00f3						write
>00f3						stream      .byte       ?
=$fb						buf         = args.buf
=$fd						buflen      = args.buflen
.00f3						seek
>00f3						stream      .byte       ?
>00f4						position    .dword      ?
.00f3						close
>00f3						stream      .byte       ?
.00f3						rename
>00f3						drive       .byte       ?
>00f4						cookie      .byte       ?
=$fb						old         = args.buf
=$fd						old_len     = args.buflen
=$f8						new         = args.ext
=$fa						new_len     = args.extlen
.00f3						delete
>00f3						drive       .byte       ?
>00f4						cookie      .byte       ?
=$fb						fname       = args.buf
=$fd						fname_len   = args.buflen
>00f5						mode        .byte       ?
=0						READ        = 0
=1						WRITE       = 1
=2						END         = 2
.00f3						directory
.00f3						open
>00f3						drive       .byte       ?
>00f4						cookie      .byte       ?
=$fb						path        = args.buf
=$fd						path_len    = args.buflen
.00f3						read
>00f3						stream      .byte       ?
>00f4						buflen      .byte       ?
.00f3						close
>00f3						stream      .byte       ?
.00f3						mkdir
>00f3						drive       .byte       ?
>00f4						cookie      .byte       ?
=$fb						path        = args.buf
=$fd						path_len    = args.buflen
.00f3						rmdir
>00f3						drive       .byte       ?
>00f4						cookie      .byte       ?
=$fb						path        = args.buf
=$fd						path_len    = args.buflen
.00f3						display
>00f3						x           .byte       ?   ; coordinate or size
>00f4						y           .byte       ?   ; coordinate or size
=$fb						text        = args.buf      ; text
=$f8						color       = args.ext      ; color
=$fb						buf         = args.buf      ; deprecated
=$f8						buf2        = args.ext      ; deprecated
=$fd						buflen      = args.buflen
.00f3						net
=$fb						socket      = args.buf
>00f3						src_port    .word       ?
>00f5						dest_port   .word       ?
>00f7						dest_ip     .fill       4
>00f3						accepted    .byte       ?
=$f8						buf         = args.ext
=$fa						buflen      = args.extlen
.00f3						config
.00f3						timer
>00f3						units       .byte       ?
=0						FRAMES      = 0
=1						SECONDS     = 1
=128						QUERY       = 128
>00f4						absolute    .byte       ?
>00f5						cookie      .byte       ?
=$f8						ext         = $f8
=$fa						extlen      = $fa
=$fb						buf         = $fb
=$fd						buflen      = $fd
=$fe						ptr         = $fe
.0000						events
>0000						dest        .word       ?   ; GetNextEvent copies event data here
>0002						pending     .byte       ?   ; Negative count of pending events
.0003						end
.0003						run
>0003						block_id    .byte   ?
.0003						recv
=$fb						buf         = args.buf
=$fd						buflen      = args.buflen
.0003						fs
.0003						format
>0003						drive       .byte       ?
>0004						cookie      .byte       ?
=$fb						label       = args.buf
=$fd						label_len   = args.buflen
.0003						mkfs
>0003						drive       .byte       ?
>0004						cookie      .byte       ?
=$fb						label       = args.buf
=$fd						label_len   = args.buflen
.0003						file
.0003						open
>0003						drive       .byte       ?
>0004						cookie      .byte       ?
=$fb						fname       = args.buf
=$fd						fname_len   = args.buflen
>0005						mode        .byte       ?
=0						READ        = 0
=1						WRITE       = 1
=2						END         = 2
.0003						read
>0003						stream      .byte       ?
>0004						buflen      .byte       ?
.0003						write
>0003						stream      .byte       ?
=$fb						buf         = args.buf
=$fd						buflen      = args.buflen
.0003						seek
>0003						stream      .byte       ?
>0004						position    .dword      ?
.0003						close
>0003						stream      .byte       ?
.0003						rename
>0003						drive       .byte       ?
>0004						cookie      .byte       ?
=$fb						old         = args.buf
=$fd						old_len     = args.buflen
=$f8						new         = args.ext
=$fa						new_len     = args.extlen
.0003						delete
>0003						drive       .byte       ?
>0004						cookie      .byte       ?
=$fb						fname       = args.buf
=$fd						fname_len   = args.buflen
>0005						mode        .byte       ?
=0						READ        = 0
=1						WRITE       = 1
=2						END         = 2
.0003						directory
.0003						open
>0003						drive       .byte       ?
>0004						cookie      .byte       ?
=$fb						path        = args.buf
=$fd						path_len    = args.buflen
.0003						read
>0003						stream      .byte       ?
>0004						buflen      .byte       ?
.0003						close
>0003						stream      .byte       ?
.0003						mkdir
>0003						drive       .byte       ?
>0004						cookie      .byte       ?
=$fb						path        = args.buf
=$fd						path_len    = args.buflen
.0003						rmdir
>0003						drive       .byte       ?
>0004						cookie      .byte       ?
=$fb						path        = args.buf
=$fd						path_len    = args.buflen
.0003						display
>0003						x           .byte       ?   ; coordinate or size
>0004						y           .byte       ?   ; coordinate or size
=$fb						text        = args.buf      ; text
=$f8						color       = args.ext      ; color
=$fb						buf         = args.buf      ; deprecated
=$f8						buf2        = args.ext      ; deprecated
=$fd						buflen      = args.buflen
.0003						net
=$fb						socket      = args.buf
>0003						src_port    .word       ?
>0005						dest_port   .word       ?
>0007						dest_ip     .fill       4
>0003						accepted    .byte       ?
=$f8						buf         = args.ext
=$fa						buflen      = args.extlen
.0003						config
.0003						timer
>0003						units       .byte       ?
=0						FRAMES      = 0
=1						SECONDS     = 1
=128						QUERY       = 128
>0004						absolute    .byte       ?
>0005						cookie      .byte       ?
=$f8						ext         = $f8
=$fa						extlen      = $fa
=$fb						buf         = $fb
=$fd						buflen      = $fd
=$fe						ptr         = $fe
>0000						dest        .word       ?   ; GetNextEvent copies event data here
>0002						pending     .byte       ?   ; Negative count of pending events
.0003						end
=$fb						buf         = args.buf
=$fd						buflen      = args.buflen
>0000						block_id    .byte   ?
.0000						format
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						label       = args.buf
=$fd						label_len   = args.buflen
.0000						mkfs
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						label       = args.buf
=$fd						label_len   = args.buflen
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						label       = args.buf
=$fd						label_len   = args.buflen
.0000						open
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						fname       = args.buf
=$fd						fname_len   = args.buflen
>0002						mode        .byte       ?
=0						READ        = 0
=1						WRITE       = 1
=2						END         = 2
.0000						read
>0000						stream      .byte       ?
>0001						buflen      .byte       ?
.0000						write
>0000						stream      .byte       ?
=$fb						buf         = args.buf
=$fd						buflen      = args.buflen
.0000						seek
>0000						stream      .byte       ?
>0001						position    .dword      ?
.0000						close
>0000						stream      .byte       ?
.0000						rename
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						old         = args.buf
=$fd						old_len     = args.buflen
=$f8						new         = args.ext
=$fa						new_len     = args.extlen
.0000						delete
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						fname       = args.buf
=$fd						fname_len   = args.buflen
>0002						mode        .byte       ?
=0						READ        = 0
=1						WRITE       = 1
=2						END         = 2
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						fname       = args.buf
=$fd						fname_len   = args.buflen
>0002						mode        .byte       ?
=0						READ        = 0
=1						WRITE       = 1
=2						END         = 2
>0000						stream      .byte       ?
>0001						buflen      .byte       ?
>0000						stream      .byte       ?
=$fb						buf         = args.buf
=$fd						buflen      = args.buflen
>0000						stream      .byte       ?
>0001						position    .dword      ?
>0000						stream      .byte       ?
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						old         = args.buf
=$fd						old_len     = args.buflen
=$f8						new         = args.ext
=$fa						new_len     = args.extlen
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						fnane       = args.buf
=$fd						fname_len   = args.buflen
.0000						open
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						path        = args.buf
=$fd						path_len    = args.buflen
.0000						read
>0000						stream      .byte       ?
>0001						buflen      .byte       ?
.0000						close
>0000						stream      .byte       ?
.0000						mkdir
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						path        = args.buf
=$fd						path_len    = args.buflen
.0000						rmdir
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						path        = args.buf
=$fd						path_len    = args.buflen
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						path        = args.buf
=$fd						path_len    = args.buflen
>0000						stream      .byte       ?
>0001						buflen      .byte       ?
>0000						stream      .byte       ?
>0000						x           .byte       ?   ; coordinate or size
>0001						y           .byte       ?   ; coordinate or size
=$fb						text        = args.buf      ; text
=$f8						color       = args.ext      ; color
=$fb						buf         = args.buf      ; deprecated
=$f8						buf2        = args.ext      ; deprecated
=$fd						buflen      = args.buflen
=$fb						socket      = args.buf
>0000						src_port    .word       ?
>0002						dest_port   .word       ?
>0004						dest_ip     .fill       4
>0000						accepted    .byte       ?
=$f8						buf         = args.ext
=$fa						buflen      = args.extlen
>0000						units       .byte       ?
=0						FRAMES      = 0
=1						SECONDS     = 1
=128						QUERY       = 128
>0001						absolute    .byte       ?
>0002						cookie      .byte       ?
>0000						century     .byte       ?
>0001						year        .byte       ?
>0002						month       .byte       ?
>0003						day         .byte       ?
>0004						hours       .byte       ?
>0005						minutes     .byte       ?
>0006						seconds     .byte       ?
>0007						centis      .byte       ?
.0008						size
>0000						            .word   ?   ; Reserved
>0002						            .word   ?   ; Deprecated
>0004						JOYSTICK    .word   ?   ; Game Controller changes.
>0006						DEVICE      .word   ?   ; Device added/removed.
>0008						PRESSED     .word   ?   ; Key pressed
>000a						RELEASED    .word   ?   ; Key released.
>000c						DELTA       .word   ?   ; Regular mouse move and button state
>000e						CLICKS      .word   ?   ; Click counts
>0010						NAME        .word   ?
>0012						SIZE        .word   ?
>0014						DATA        .word   ?   ; The read request has succeeded.
>0016						WROTE       .word   ?   ; The write request has completed.
>0018						FORMATTED   .word   ?   ; The low-level format has completed.
>001a						ERROR       .word   ?
>001c						SIZE        .word   ?
>001e						CREATED     .word   ?
>0020						CHECKED     .word   ?
>0022						DATA        .word   ?   ; The read request has succeeded.
>0024						WROTE       .word   ?   ; The write request has completed.
>0026						ERROR       .word   ?
>0028						NOT_FOUND   .word   ?   ; The file file was not found.
>002a						OPENED      .word   ?   ; The file was successfully opened.
>002c						DATA        .word   ?   ; The read request has succeeded.
>002e						WROTE       .word   ?   ; The write request has completed.
>0030						EOF         .word   ?   ; All file data has been read.
>0032						CLOSED      .word   ?   ; The close request has completed.
>0034						RENAMED     .word   ?   ; The rename request has completed.
>0036						DELETED     .word   ?   ; The delete request has completed.
>0038						ERROR       .word   ?   ; An error occured; close the file if opened.
>003a						SEEK        .word   ?   ; The seek request has completed.
>003c						OPENED      .word   ?   ; The directory open request succeeded.
>003e						VOLUME      .word   ?   ; A volume record was found.
>0040						FILE        .word   ?   ; A file record was found.
>0042						FREE        .word   ?   ; A file-system free-space record was found.
>0044						EOF         .word   ?   ; All data has been read.
>0046						CLOSED      .word   ?   ; The directory file has been closed.
>0048						ERROR       .word   ?   ; An error occured; user should close.
>004a						CREATED     .word   ?   ; The directory has been created.
>004c						DELETED     .word   ?   ; The directory has been deleted.
>004e						TCP         .word   ?
>0050						UDP         .word   ?
>0052						EXPIRED     .word   ?
>0054						TICK        .word   ?
>0000						type        .byte   ?   ; Enum above
>0001						buf         .byte   ?   ; page id or zero
>0002						ext         .byte   ?   ; page id or zero
.0003						key
>0003						keyboard    .byte   ?   ; Keyboard ID
>0004						raw         .byte   ?   ; Raw key ID
>0005						ascii       .byte   ?   ; ASCII value
>0006						flags       .byte   ?   ; Flags (META)
=$80						META        = $80       ; Meta key; no associated ASCII value.
.0003						mouse
.0003						delta
>0003						x           .byte   ?
>0004						y           .byte   ?
>0005						z           .byte   ?
>0006						buttons     .byte   ?
.0003						clicks
>0003						inner       .byte   ?
>0004						middle      .byte   ?
>0005						outer       .byte   ?
.0003						joystick
>0003						joy0        .byte   ?
>0004						joy1        .byte   ?
.0003						udp
>0003						token       .byte   ?   ; TODO: break out into fields
.0003						tcp
>0003						len         .byte   ?   ; Raw packet length.
.0003						file
>0003						stream      .byte   ?
>0004						cookie      .byte   ?
.0005						data
>0005						requested   .byte   ?   ; Requested number of bytes to read
>0006						read        .byte   ?   ; Number of bytes actually read
.0005						wrote
>0005						requested   .byte   ?   ; Requested number of bytes to read
>0006						wrote       .byte   ?   ; Number of bytes actually read
.0003						directory
>0003						stream      .byte   ?
>0004						cookie      .byte   ?
.0005						volume
>0005						len         .byte   ?   ; Length of volname (in buf)
>0006						flags       .byte   ?   ; block size, text encoding
.0005						file
>0005						len         .byte   ?
>0006						flags       .byte   ?   ; block scale, text encoding, approx size
.0005						free
>0005						flags       .byte   ?   ; block scale, text encoding, approx size
.0003						timer
>0003						value       .byte   ?
>0004						cookie      .byte   ?
>0000						keyboard    .byte   ?   ; Keyboard ID
>0001						raw         .byte   ?   ; Raw key ID
>0002						ascii       .byte   ?   ; ASCII value
>0003						flags       .byte   ?   ; Flags (META)
=$80						META        = $80       ; Meta key; no associated ASCII value.
.0000						delta
>0000						x           .byte   ?
>0001						y           .byte   ?
>0002						z           .byte   ?
>0003						buttons     .byte   ?
.0000						clicks
>0000						inner       .byte   ?
>0001						middle      .byte   ?
>0002						outer       .byte   ?
>0000						x           .byte   ?
>0001						y           .byte   ?
>0002						z           .byte   ?
>0003						buttons     .byte   ?
>0000						inner       .byte   ?
>0001						middle      .byte   ?
>0002						outer       .byte   ?
>0000						joy0        .byte   ?
>0001						joy1        .byte   ?
>0000						stream      .byte   ?
>0001						cookie      .byte   ?
.0002						data
>0002						requested   .byte   ?   ; Requested number of bytes to read
>0003						read        .byte   ?   ; Number of bytes actually read
.0002						wrote
>0002						requested   .byte   ?   ; Requested number of bytes to read
>0003						wrote       .byte   ?   ; Number of bytes actually read
>0000						requested   .byte   ?   ; Requested number of bytes to read
>0001						read        .byte   ?   ; Number of bytes actually read
>0000						requested   .byte   ?   ; Requested number of bytes to read
>0001						wrote       .byte   ?   ; Number of bytes actually read
>0000						stream      .byte   ?
>0001						cookie      .byte   ?
.0002						volume
>0002						len         .byte   ?   ; Length of volname (in buf)
>0003						flags       .byte   ?   ; block size, text encoding
.0002						file
>0002						len         .byte   ?
>0003						flags       .byte   ?   ; block scale, text encoding, approx size
.0002						free
>0002						flags       .byte   ?   ; block scale, text encoding, approx size
>0000						len         .byte   ?   ; Length of volname (in buf)
>0001						flags       .byte   ?   ; block size, text encoding
>0000						len         .byte   ?
>0001						flags       .byte   ?   ; block scale, text encoding, approx size
>0000						flags       .byte   ?   ; block scale, text encoding, approx size
>0000						free        .fill   6   ; blocks used/free
>0000						token       .byte   ?   ; TODO: break out into fields
>0000						len         .byte   ?   ; Raw packet length.
>0000						value       .byte   ?
>0001						cookie      .byte   ?

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/assembler.asm

.8530						AssembleGroup1:
.8530		a9 ff		lda #$ff			lda 	#$FF 						; flag for group 1 / mask.
.8532		8d 41 04	sta $0441			sta 	ModeMask 					; initialise the mode mask - all for all
.8535		80 02		bra $8539			bra 	AsmGroup12
.8537						AssembleGroup2:
.8537		a9 00		lda #$00			lda 	#$00 						; flag for group 2
.8539						AsmGroup12:
.8539		8d 3f 04	sta $043f			sta 	IsGroup1 					; save the 'group 1' flag
.853c		68		pla				pla 								; pop the return address to access the information following.
.853d		fa		plx				plx
.853e		20 c5 85	jsr $85c5			jsr 	AccessParameters 			; get opcode and save as base
.8541		8d 40 04	sta $0440			sta 	BaseOpcode
.8544		ad 3f 04	lda $043f			lda 	IsGroup1 					; skip if group 1 as we don't have a complex mask.
.8547		d0 08		bne $8551			bne 	_AG12HaveMask
.8549		a9 02		lda #$02			lda 	#2 							; if group 2 the second parameter is the mask
.854b		20 cd 85	jsr $85cd			jsr 	GetParameter		 		; e.g. which modes are supported for this operand
.854e		8d 41 04	sta $0441			sta 	ModeMask
.8551						_AG12HaveMask:
.8551		20 01 87	jsr $8701			jsr 	TypeAndCalculateOperand 	; get zero page type
.8554		da		phx				phx 								; save found address mode
.8555		20 31 86	jsr $8631			jsr 	AssembleModeX
.8558		fa		plx				plx  								; restore address mode
.8559		b0 0b		bcs $8566			bcs 	_AG12Exit
.855b		20 67 85	jsr $8567			jsr 	PromoteToAbsolute  			; promote ZP to ABS and try that
.855e		20 31 86	jsr $8631			jsr 	AssembleModeX
.8561		b0 03		bcs $8566			bcs 	_AG12Exit
.8563		4c fa a5	jmp $a5fa			jmp 	SyntaxError 				; can't do either, so must be wrong mode/operand.
.8566						_AG12Exit:
.8566		60		rts				rts
.8567						PromoteToAbsolute:
.8567		a9 6c		lda #$6c			lda 	#AM_ABS 					; lda xx
.8569		e0 e4		cpx #$e4			cpx 	#AM_ZEROPAGE
.856b		f0 19		beq $8586			beq 	_PTADo
.856d		a9 7c		lda #$7c			lda 	#AM_ABSX 					; lda xx,X
.856f		e0 f4		cpx #$f4			cpx 	#AM_ZEROX
.8571		f0 13		beq $8586			beq 	_PTADo
.8573		a9 78		lda #$78			lda 	#AM_ABSY 					; lda xx,Y
.8575		e0 80		cpx #$80			cpx 	#AM_ZEROY
.8577		f0 0d		beq $8586			beq 	_PTADo
.8579		a9 01		lda #$01			lda 	#AM_INDABS 					; lda (xx) (jump)
.857b		e0 d1		cpx #$d1			cpx 	#AM_IND
.857d		f0 07		beq $8586			beq 	_PTADo
.857f		a9 02		lda #$02			lda 	#AM_INDABSX 				; lda (xx,x) (jump)
.8581		e0 c0		cpx #$c0			cpx 	#AM_INDX
.8583		f0 01		beq $8586			beq 	_PTADo
.8585		60		rts				rts
.8586						_PTADo:
.8586		aa		tax				tax
.8587		60		rts				rts
.8588						AssembleGroup3:
.8588		68		pla				pla 								; get parameters, which is just the opcode.
.8589		fa		plx				plx
.858a		20 c5 85	jsr $85c5			jsr 	AccessParameters 			; get and output opcode
.858d		20 dd 85	jsr $85dd			jsr 	AssemblerWriteByte
.8590		20 65 87	jsr $8765			jsr 	CalculateOperand 			; get a 16 bit operand
.8593		a5 60		lda $60				lda 	NSMantissa0 				; calculate the offset
.8595		38		sec				sec
.8596		ed 3a 04	sbc $043a			sbc 	AssemblerAddress
.8599		48		pha				pha 								; LSB in A
.859a		a5 70		lda $70				lda 	NSMantissa1
.859c		ed 3b 04	sbc $043b			sbc 	AssemblerAddress+1
.859f		aa		tax				tax 								; MSB in X
.85a0		68		pla				pla
.85a1		18		clc				clc 								; $80 to easy check $80-$7F, plus 1 for offset error
.85a2		69 7f		adc #$7f			adc 	#$7F
.85a4		90 01		bcc $85a7			bcc 	_AG3NoCarry
.85a6		e8		inx				inx
.85a7						_AG3NoCarry:
.85a7		38		sec				sec 								; fix back and write out anyways.
.85a8		e9 80		sbc #$80			sbc 	#$80
.85aa		20 dd 85	jsr $85dd			jsr 	AssemblerWriteByte
.85ad		e0 00		cpx #$00			cpx 	#0 							; was it in range
.85af		f0 0a		beq $85bb			beq 	_AG3Exit
.85b1		ad 3c 04	lda $043c			lda 	AssemblerControl 			; are we allowing bad values ?
.85b4		29 01		and #$01			and 	#1
.85b6		f0 03		beq $85bb			beq 	_AG3Exit
.85b8		4c ff a5	jmp $a5ff			jmp 	RangeError 					; no, branch is out of range
.85bb						_AG3Exit:
.85bb		60		rts				rts
.85bc						AssembleGroup4:
.85bc		68		pla				pla 								; pop address
.85bd		fa		plx				plx
.85be		20 c5 85	jsr $85c5			jsr 	AccessParameters 			; access and get first
.85c1		20 dd 85	jsr $85dd			jsr 	AssemblerWriteByte 			; output it.
.85c4		60		rts				rts
.85c5						AccessParameters:
.85c5		8d 3d 04	sta $043d			sta 	ParamStart
.85c8		8e 3e 04	stx $043e			stx 	ParamStart+1
.85cb		a9 01		lda #$01			lda 	#1
.85cd						GetParameter:
.85cd		5a		phy				phy
.85ce		a8		tay				tay
.85cf		ad 3d 04	lda $043d			lda 	ParamStart
.85d2		85 36		sta $36				sta 	zTemp0
.85d4		ad 3e 04	lda $043e			lda 	ParamStart+1
.85d7		85 37		sta $37				sta 	zTemp0+1
.85d9		b1 36		lda ($36),y			lda 	(zTemp0),y
.85db		7a		ply				ply
.85dc		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/aswrite.asm

.85dd						AssemblerWriteByte:
.85dd		48		pha			pha
.85de		ad 3c 04	lda $043c		lda 	AssemblerControl 				; check printing bytes ?
.85e1		29 02		and #$02		and 	#2
.85e3		f0 1b		beq $8600		beq 	_AWBNoPrint
.85e5		ad 3b 04	lda $043b		lda		AssemblerAddress+1 				; print address
.85e8		20 1b 86	jsr $861b		jsr 	PrintHex
.85eb		ad 3a 04	lda $043a		lda		AssemblerAddress
.85ee		20 1b 86	jsr $861b		jsr 	PrintHex
.85f1		a9 20		lda #$20		lda 	#' '
.85f3		20 4d 80	jsr $804d		jsr 	EXTPrintCharacter
.85f6		68		pla			pla 									; print byte
.85f7		48		pha			pha
.85f8		20 1b 86	jsr $861b		jsr 	PrintHex
.85fb		a9 0d		lda #$0d		lda 	#13
.85fd		20 4d 80	jsr $804d		jsr 	EXTPrintCharacter
.8600						_AWBNoPrint:
.8600		ad 3a 04	lda $043a		lda		AssemblerAddress				; copy address to zTemp0
.8603		85 36		sta $36			sta 	zTemp0
.8605		ad 3b 04	lda $043b		lda		AssemblerAddress+1
.8608		f0 0e		beq $8618		beq 	_AWBRange
.860a		85 37		sta $37			sta 	zTemp0+1
.860c		68		pla			pla 									; write byte out
.860d		92 36		sta ($36)		sta 	(zTemp0)
.860f		ee 3a 04	inc $043a		inc 	AssemblerAddress 				; bump address
.8612		d0 03		bne $8617		bne 	_AWBNoCarry
.8614		ee 3b 04	inc $043b		inc 	AssemblerAddress+1
.8617						_AWBNoCarry:
.8617		60		rts			rts
.8618						_AWBRange:
.8618		4c ff a5	jmp $a5ff		jmp 	RangeError
.861b						PrintHex:
.861b		48		pha				pha
.861c		4a		lsr a				lsr 	a
.861d		4a		lsr a				lsr 	a
.861e		4a		lsr a				lsr 	a
.861f		4a		lsr a				lsr 	a
.8620		20 24 86	jsr $8624			jsr 	_PrintNibble
.8623		68		pla				pla
.8624						_PrintNibble:
.8624		29 0f		and #$0f			and 	#15
.8626		c9 0a		cmp #$0a			cmp 	#10
.8628		90 02		bcc $862c			bcc 	_NoShift
.862a		69 06		adc #$06			adc 	#6
.862c						_NoShift:
.862c		69 30		adc #$30			adc 	#48
.862e		4c 4d 80	jmp $804d			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/instruction.asm

.8631						AssembleModeX:
.8631		5a		phy				phy
.8632		ad 3f 04	lda $043f			lda 	IsGroup1
.8635		f0 17		beq $864e			beq 	_AMXGroup2
.8637		8a		txa				txa 							; is it in group # 1
.8638		29 40		and #$40			and 	#AM_ISG1
.863a		f0 4d		beq $8689			beq 	_AMXFail 				; no, give up.
.863c		8a		txa				txa 							; get back.
.863d		29 1f		and #$1f			and 	#$1F 					; this is now the offset.
.863f		e0 e0		cpx #$e0			cpx 	#AM_IMMEDIATE 			; if not immediate, we can continue.
.8641		d0 22		bne $8665			bne 	_AMXHaveInfo
.8643		ad 40 04	lda $0440			lda 	BaseOpcode 				; cannot store immediate.
.8646		c9 81		cmp #$81			cmp 	#$81
.8648		f0 3f		beq $8689			beq 	_AMXFail
.864a		a9 08		lda #$08			lda 	#8 						; if immediate we use offset 8.
.864c		80 17		bra $8665			bra 	_AMXHaveInfo 			; odd design decision there.
.864e						_AMXGroup2:
.864e		8a		txa				txa 							; is it in group 2 ?
.864f		29 20		and #$20			and 	#AM_ISG2
.8651		f0 36		beq $8689			beq 	_AMXFail 				; no, give up.
.8653		8a		txa				txa 							; get the offset into Y
.8654		29 1f		and #$1f			and 	#$1F
.8656		4a		lsr a				lsr 	a 						; make it 0-7.
.8657		4a		lsr a				lsr  	a
.8658		a8		tay				tay
.8659		ad 41 04	lda $0441			lda 	ModeMask 				; shift the modemask left so you can check it against the requested offset
.865c						_AMXCheckOkay:
.865c		0a		asl a				asl 	a 						; shift modemask left enough times to check legitimate.
.865d		88		dey				dey
.865e		10 fc		bpl $865c			bpl 	_AMXCheckOkay
.8660		90 27		bcc $8689			bcc 	_AMXFail 				; not allowed.
.8662		8a		txa				txa  							; get mask back
.8663		29 1f		and #$1f			and 	#$1F
.8665						_AMXHaveInfo:
.8665		e0 00		cpx #$00			cpx 	#$00 					; does it *require* an 8 bit operand
.8667		10 04		bpl $866d			bpl 	_AMXAnySize 			; checking bit 7, the zero page opcode flag.
.8669		a4 70		ldy $70				ldy 	NSMantissa1 			; fail if it is outside range, e.g. the MSB is set.
.866b		d0 1c		bne $8689			bne 	_AMXFail
.866d						_AMXAnySize:
.866d		18		clc				clc 							; add offset to the base opcode
.866e		6d 40 04	adc $0440			adc 	BaseOpcode
.8671						_AMXOutputCode:
.8671		20 dd 85	jsr $85dd			jsr 	AssemblerWriteByte 		; write the opcode out.
.8674		e0 28		cpx #$28			cpx 	#AM_ACC 				; A mode (e.g. ASL)
.8676		f0 0e		beq $8686			beq 	_AMXExit
.8678		a5 60		lda $60				lda 	NSMantissa0 			; write LSB operand
.867a		20 dd 85	jsr $85dd			jsr 	AssemblerWriteByte
.867d		e0 00		cpx #$00			cpx 	#$00 					; zeropage ?
.867f		30 05		bmi $8686			bmi 	_AMXExit
.8681		a5 70		lda $70				lda 	NSMantissa1 			; write MSB operand
.8683		20 dd 85	jsr $85dd			jsr 	AssemblerWriteByte
.8686						_AMXExit:
.8686		7a		ply				ply
.8687		38		sec				sec
.8688		60		rts				rts
.8689						_AMXFail:
.8689		a0 00		ldy #$00			ldy 	#0
.868b						_AMXCheckOddities:
.868b		8a		txa				txa
.868c		d9 b3 86	cmp $86b3,y			cmp 	ExtraOpcode+2,y 		; match address mode
.868f		d0 15		bne $86a6			bne 	_AMXCONext
.8691		b9 b1 86	lda $86b1,y			lda 	ExtraOpcode+0,y 		; do the base opcodes match
.8694		cd 40 04	cmp $0440			cmp 	BaseOpcode
.8697		d0 0d		bne $86a6			bne 	_AMXCONext
.8699		e0 00		cpx #$00			cpx 	#$00 					; requires zero page ?
.869b		10 04		bpl $86a1			bpl 	_AMXCONotZero
.869d		a5 70		lda $70				lda 	NSMantissa1
.869f		d0 05		bne $86a6			bne 	_AMXCONext
.86a1						_AMXCONotZero:
.86a1		b9 b2 86	lda $86b2,y			lda 	ExtraOpcode+1,y 		; get new opcode
.86a4		80 cb		bra $8671			bra 	_AMXOutputCode 			; and assemble it
.86a6						_AMXCONext:
.86a6		c8		iny				iny
.86a7		c8		iny				iny
.86a8		c8		iny				iny
.86a9		b9 b1 86	lda $86b1,y			lda 	ExtraOpcode+0,y 		; end of table
.86ac		d0 dd		bne $868b			bne 	_AMXCheckOddities
.86ae						_AMXCOFail:
.86ae		7a		ply				ply
.86af		18		clc				clc
.86b0		60		rts				rts
.86b1						ExtraOpcode:
>86b1		40 6c 01					.byte $40,$6c,AM_INDABS 	; jump
>86b4		40 7c 02					.byte $40,$7C,AM_INDABSX 	; jump
>86b7		a2 be 78					.byte $a2,$BE,AM_ABSY 		; ldx
>86ba		a2 b6 80					.byte $a2,$B6,AM_ZEROY 		; ldx
>86bd		82 96 80					.byte $82,$96,AM_ZEROY 		; stx
>86c0		e2 1a 28					.byte $e2,$1a,AM_ACC 		; inc
>86c3		c2 3a 28					.byte $c2,$3a,AM_ACC 		; dec
>86c6		20 89 e0					.byte $20,$89,AM_IMMEDIATE 	; bit
>86c9		60 9c 6c					.byte $60,$9c,AM_ABS 		; stz
>86cc		60 9e 7c					.byte $60,$9e,AM_ABSX 		; stz
>86cf		00						.byte $00

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/label.asm

.86d0						LabelHere:
.86d0		c8		iny				iny 								; skip .
.86d1		a2 00		ldx #$00			ldx 	#0 							; get a term
.86d3		20 76 9e	jsr $9e76			jsr 	EvaluateTerm
.86d6		a5 50		lda $50				lda 	NSStatus 					; needs to be an integer reference.
.86d8		c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.86da		d0 22		bne $86fe			bne 	_ALType 					; otherwise typing error
.86dc		b5 60		lda $60,x			lda 	NSMantissa0,x 				; copy reference address to zTemp0
.86de		85 36		sta $36				sta 	zTemp0 						; (e.g. where we store the address)
.86e0		b5 70		lda $70,x			lda 	NSMantissa1,x
.86e2		85 37		sta $37				sta 	zTemp0+1
.86e4		5a		phy				phy 								; copy address in (64k)
.86e5		a0 01		ldy #$01			ldy 	#1
.86e7		ad 3a 04	lda $043a			lda	 	AssemblerAddress
.86ea		92 36		sta ($36)			sta 	(zTemp0)
.86ec		ad 3b 04	lda $043b			lda	 	AssemblerAddress+1
.86ef		91 36		sta ($36),y			sta 	(zTemp0),y
.86f1		c8		iny				iny
.86f2		a9 00		lda #$00			lda 	#0 							; zero the rest.
.86f4		91 36		sta ($36),y			sta 	(zTemp0),y
.86f6		c8		iny				iny
.86f7		91 36		sta ($36),y			sta 	(zTemp0),y
.86f9		c8		iny				iny
.86fa		91 36		sta ($36),y			sta 	(zTemp0),y
.86fc		7a		ply				ply
.86fd		60		rts				rts
.86fe						_ALType:
.86fe		4c 04 a6	jmp $a604			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/operands.asm

.8701						TypeAndCalculateOperand:
.8701		b1 30		lda ($30),y			lda 	(codePtr),y
.8703		a2 28		ldx #$28			ldx 	#AM_ACC 					; ACC if : or EOL
.8705		c9 3a		cmp #$3a			cmp 	#KWD_COLON
.8707		f0 5b		beq $8764			beq 	_TACOExit
.8709		c9 80		cmp #$80			cmp 	#KWC_EOL
.870b		f0 57		beq $8764			beq 	_TACOExit
.870d		c8		iny				iny
.870e		a2 e0		ldx #$e0			ldx 	#AM_IMMEDIATE
.8710		c9 23		cmp #$23			cmp 	#KWD_HASH 					; if hash, then immediate - constant.
.8712		f0 51		beq $8765			beq 	CalculateOperand
.8714		c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; if ( then check for indirection
.8716		f0 1f		beq $8737			beq 	_TACOIndirect
.8718		88		dey				dey 								; undo get of first character
.8719		20 65 87	jsr $8765			jsr 	CalculateOperand 			; get operand
.871c		b1 30		lda ($30),y			lda 	(codePtr),y
.871e		a2 e4		ldx #$e4			ldx 	#AM_ZEROPAGE 				; if not, try zero page (then absolute)
.8720		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8722		d0 40		bne $8764			bne 	_TACOExit
.8724		c8		iny				iny
.8725		20 6f 87	jsr $876f			jsr 	TACOCheckXY 				; extract X,Y or 0 (neither) from the variable.
.8728		a2 f4		ldx #$f4			ldx 	#AM_ZEROX 					; check for X
.872a		c9 58		cmp #$58			cmp 	#'X'
.872c		f0 36		beq $8764			beq 	_TACOExit
.872e		a2 80		ldx #$80			ldx 	#AM_ZEROY 					; check for Y
.8730		c9 59		cmp #$59			cmp 	#'Y'
.8732		f0 30		beq $8764			beq 	_TACOExit
.8734						_TACOSyntax:
.8734		4c fa a5	jmp $a5fa			jmp 	SyntaxError
.8737						_TACOIndirect:
.8737		20 65 87	jsr $8765			jsr 	CalculateOperand 			; get the operand
.873a		b1 30		lda ($30),y			lda 	(codePtr),y
.873c		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if , then it must be ,X)
.873e		f0 17		beq $8757			beq 	_TACOIndX
.8740		20 00 95	jsr $9500			jsr 	CheckRightBracket  			; otherwise must be ) or ),Y
.8743		b1 30		lda ($30),y			lda 	(codePtr),y
.8745		a2 d1		ldx #$d1			ldx 	#AM_IND
.8747		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not comma then exit with (xx)
.8749		d0 19		bne $8764			bne 	_TACOExit
.874b		c8		iny				iny
.874c		20 6f 87	jsr $876f			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.874f		c9 59		cmp #$59			cmp 	#'Y' 						; check Y
.8751		d0 e1		bne $8734			bne 	_TACOSyntax
.8753		a2 d0		ldx #$d0			ldx 	#AM_INDY
.8755		80 0d		bra $8764			bra 	_TACOExit
.8757						_TACOIndX:
.8757		c8		iny				iny
.8758		20 6f 87	jsr $876f			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.875b		c9 58		cmp #$58			cmp 	#'X' 						; check X
.875d		d0 d5		bne $8734			bne 	_TACOSyntax
.875f		20 00 95	jsr $9500			jsr 	CheckRightBracket			; check )
.8762		a2 c0		ldx #$c0			ldx 	#AM_INDX
.8764						_TACOExit:
.8764		60		rts				rts
.8765						CalculateOperand:
.8765		48		pha				pha
.8766		da		phx				phx
.8767		a2 00		ldx #$00			ldx 	#0 							; get 16 bit integer in Slot 0
.8769		20 02 a4	jsr $a402			jsr 	Evaluate16BitInteger
.876c		fa		plx				plx
.876d		68		pla				pla
.876e		60		rts				rts
.876f						TACOCheckXY:
.876f		b1 30		lda ($30),y			lda 	(codePtr),y
.8771		29 c0		and #$c0			and 	#$C0 						; check it is an identifier reference.
.8773		c9 40		cmp #$40			cmp 	#$40
.8775		d0 21		bne $8798			bne 	_TCXYFail
.8777		b1 30		lda ($30),y			lda 	(codePtr),y
.8779		18		clc				clc
.877a		69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.877c		85 37		sta $37				sta 	zTemp0+1
.877e		c8		iny				iny
.877f		b1 30		lda ($30),y			lda 	(codePtr),y
.8781		c8		iny				iny
.8782		85 36		sta $36				sta 	zTemp0
.8784		5a		phy				phy 								; save position
.8785		a0 02		ldy #$02			ldy 	#2 							; type is integer ?
.8787		b1 36		lda ($36),y			lda 	(zTemp0),y
.8789		d0 0c		bne $8797			bne 	_TCXYPopFail
.878b		a0 08		ldy #$08			ldy 	#8 							; get first character, should have bit 7 set as also last.
.878d		b1 36		lda ($36),y			lda 	(zTemp0),y
.878f		c9 d8		cmp #$d8			cmp 	#'X'+$80 					; should be X or Y
.8791		f0 08		beq $879b			beq 	_TCXYFound
.8793		c9 d9		cmp #$d9			cmp 	#'Y'+$80
.8795		f0 04		beq $879b			beq 	_TCXYFound
.8797						_TCXYPopFail:
.8797		7a		ply				ply
.8798						_TCXYFail:
.8798		a9 00		lda #$00			lda 	#0
.879a		60		rts				rts
.879b						_TCXYFound:
.879b		7a		ply				ply 								; restore position
.879c		29 7f		and #$7f			and 	#$7F 						; throw bit 7
.879e		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/backload.asm

.879f						BackloadProgram:
.879f		20 43 8f	jsr $8f43			jsr 	NewProgram 					; does the actual NEW.
.87a2		a2 87		ldx #$87			ldx 	#_BLLoad >> 8
.87a4		a9 ff		lda #$ff			lda 	#_BLLoad & $FF
.87a6		20 78 95	jsr $9578			jsr 	PrintStringXA
.87a9		a9 14		lda #$14			lda 	#SOURCE_ADDRESS >> 13 		; start page
.87ab		8d c5 07	sta $07c5			sta 	BackLoadPage
.87ae		a9 00		lda #$00			lda 	#(($6000) & $FF)
.87b0		8d c6 07	sta $07c6			sta 	0+BackLoadPointer
.87b3		a9 60		lda #$60			lda 	#(($6000) >> 8)
.87b5		8d c7 07	sta $07c7			sta 	1+BackLoadPointer
.87b8		9c c8 07	stz $07c8			stz 	BackLoadLast 				; reset backload last.
.87bb		9c c9 07	stz $07c9			stz 	BackLoadLast+1
.87be		a9 ff		lda #$ff			lda 	#$FF
.87c0		8d fa ff	sta $fffa			sta 	$FFFA
.87c3						_BPLoop:
.87c3		a2 ff		ldx #$ff			ldx 	#$FF
.87c5		20 34 88	jsr $8834			jsr 	BLReadByte 					; read a byte
.87c8		c9 00		cmp #$00			cmp 	#0
.87ca		f0 2c		beq $87f8			beq 	_BPExit 					; if 0 exit
.87cc		30 2a		bmi $87f8			bmi 	_BPExit 					; if -ve exit
.87ce						_BPCopy:
.87ce		e8		inx				inx  								; copy byte into the lineBuffer
.87cf		9d 46 05	sta $0546,x			sta 	lineBuffer,x
.87d2		9e 47 05	stz $0547,x			stz 	lineBuffer+1,x
.87d5		20 34 88	jsr $8834			jsr 	BLReadByte 					; read next byte
.87d8		30 0a		bmi $87e4			bmi 	_BPEndLine 					; -ve = EOL
.87da		c9 09		cmp #$09			cmp 	#9 							; handle TAB, make it space.
.87dc		d0 02		bne $87e0			bne 	_BPNotTab
.87de		a9 20		lda #$20			lda 	#' '
.87e0						_BPNotTab:
.87e0		c9 20		cmp #$20			cmp 	#' ' 						; < ' ' = EOL
.87e2		b0 ea		bcs $87ce			bcs 	_BPCopy 					; until a control character, should be 13 received.
.87e4						_BPEndLine:
.87e4		20 93 80	jsr $8093			jsr 	TKTokeniseLine 				; tokenise the line.
.87e7		ad 47 04	lda $0447			lda 	tokenLineNumber 			; line number = 0
.87ea		0d 48 04	ora $0448			ora 	tokenLineNumber+1
.87ed		f0 d4		beq $87c3			beq 	_BPLoop 					; not legal code, blank line or maybe a comment.
.87ef		20 14 88	jsr $8814			jsr 	BLCheckLast 				; check last backload okay.
.87f2		38		sec				sec 								; append not insert
.87f3		20 3d a8	jsr $a83d			jsr 	MemoryInsertLine 			; append to current program
.87f6		80 cb		bra $87c3			bra 	_BPLoop
.87f8						_BPExit:
.87f8		9c fa ff	stz $fffa			stz 	$FFFA
.87fb		20 a5 93	jsr $93a5			jsr 	ClearSystem 				; clear variables etc.
.87fe		60		rts				rts
.87ff						_BLLoad:
>87ff		4c 6f 61 64 69 6e 67 20				.text 	"Loading from Memory",13,0
>8807		66 72 6f 6d 20 4d 65 6d 6f 72 79 0d 00
.8814						BLCheckLast:
.8814		ad c8 07	lda $07c8			lda 	BackLoadLast 				; check last < current
.8817		cd 47 04	cmp $0447			cmp 	tokenLineNumber
.881a		ad c9 07	lda $07c9			lda 	BackLoadLast+1
.881d		ed 48 04	sbc $0448			sbc 	tokenLineNumber+1
.8820		b0 0d		bcs $882f			bcs 	_BLCheckFail
.8822		ad 47 04	lda $0447			lda 	tokenLineNumber 			; update
.8825		8d c8 07	sta $07c8			sta 	BackLoadLast
.8828		ad 48 04	lda $0448			lda 	tokenLineNumber+1
.882b		8d c9 07	sta $07c9			sta 	BackLoadLast+1
.882e		60		rts				rts
.882f						_BLCheckFail:
.882f		a9 02		lda #$02		lda	#2
.8831		4c 19 95	jmp $9519		jmp	ErrorHandler
.8834						BLReadByte:
.8834		da		phx				phx
.8835		a6 0b		ldx $0b				ldx 	8+3 						; save current mapping for $6000 in X
.8837		ad c5 07	lda $07c5			lda 	BackLoadPage	 			; set current page
.883a		85 0b		sta $0b				sta 	8+3
.883c		ad c6 07	lda $07c6			lda 	BackLoadPointer 			; copy pointer to zTemp0
.883f		85 36		sta $36				sta 	zTemp0
.8841		ad c7 07	lda $07c7			lda 	BackLoadPointer+1
.8844		85 37		sta $37				sta 	zTemp0+1
.8846		b2 36		lda ($36)			lda 	(zTemp0) 					; read next byte
.8848		ee c6 07	inc $07c6			inc 	BackLoadPointer 			; bump pointer
.884b		d0 0f		bne $885c			bne 	_BLNoCarry
.884d		ee c7 07	inc $07c7			inc 	BackLoadPointer+1
.8850		10 0a		bpl $885c			bpl 	_BLNoCarry 					; need a new page
.8852		48		pha				pha
.8853		a9 60		lda #$60			lda 	#$60 						; reset pointer
.8855		8d c7 07	sta $07c7			sta 	BackLoadPointer+1
.8858		ee c5 07	inc $07c5			inc 	BackLoadPage 				; next page from source.
.885b		68		pla				pla
.885c						_BLNoCarry:
.885c		86 0b		stx $0b				stx 	8+3 						; restore mapping, then X.
.885e		fa		plx				plx
.885f		c9 00		cmp #$00			cmp 	#0
.8861		60		rts				rts
.07c5						BackLoadPage:
>07c5								.fill  	1
.07c6						BackLoadPointer:
>07c6								.fill 	2
.07c8						BackLoadLast:
>07c8								.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/editor.asm

.8862						EditProgramCode:
.8862		ad 47 04	lda $0447			lda 	tokenLineNumber 			; try to find the line.
.8865		ae 48 04	ldx $0448			ldx 	tokenLineNumber+1
.8868		20 e1 a8	jsr $a8e1			jsr 	MemorySearch
.886b		90 05		bcc $8872			bcc 	_EPCNoDelete 				; reached the end : don't delete
.886d		d0 03		bne $8872			bne 	_EPCNoDelete 				; found slot but didn't match : no delete
.886f		20 06 a8	jsr $a806			jsr 	MemoryDeleteLine 			; delete the line
.8872						_EPCNoDelete:
.8872		ad 49 04	lda $0449			lda 	tokenBuffer 				; buffer empty - we just want to delete a line.
.8875		c9 80		cmp #$80			cmp 	#KWC_EOL
.8877		f0 0d		beq $8886			beq 	_EPCNoInsert
.8879		ad 47 04	lda $0447			lda 	tokenLineNumber 			; find the line - it cannot exist as we've just deleted it.
.887c		ae 48 04	ldx $0448			ldx 	tokenLineNumber+1 			; so this can't fail, it returns some point in the code.
.887f		20 e1 a8	jsr $a8e1			jsr 	MemorySearch
.8882		18		clc				clc 								; insert at this point.
.8883		20 3d a8	jsr $a83d			jsr 	MemoryInsertLine 			; insert the line
.8886						_EPCNoInsert:
.8886		a9 01		lda #$01			lda		#1
.8888		8d 75 06	sta $0675			sta		programChanged				; mark program changed
.888b		60		rts				rts
.888c						ResetTokenBuffer:
.888c		a9 03		lda #$03			lda		#3					; reset the token buffer to empty
.888e		8d 46 04	sta $0446			sta		tokenOffset			; (3 bytes for line number & offset)
.8891		9c 47 04	stz $0447			stz		tokenLineNumber
.8894		9c 48 04	stz $0448			stz		tokenLineNumber+1
.8897		a9 46		lda #$46			lda 	#((tokenOffset) & $FF)
.8899		85 30		sta $30				sta 	codePtr
.889b		a9 04		lda #$04			lda 	#((tokenOffset) >> 8)
.889d		85 31		sta $31				sta 	codePtr+1
.889f		60		rts				rts
.88a0						IsDestructiveActionOK:
.88a0		ad 75 06	lda $0675			lda		programChanged
.88a3		f0 31		beq $88d6			beq		_ok_exit
.88a5		a2 88		ldx #$88			ldx 	#_continue >> 8 	; print confirmation prompt
.88a7		a9 e4		lda #$e4			lda 	#_continue & $FF
.88a9		20 78 95	jsr $9578			jsr 	PrintStringXA
.88ac						_next_char
.88ac		20 f5 81	jsr $81f5			jsr		KNLGetSingleCharacter
.88af		c9 79		cmp #$79			cmp		#'y'
.88b1		f0 16		beq $88c9			beq		_ok
.88b3		c9 59		cmp #$59			cmp		#'Y'
.88b5		f0 12		beq $88c9			beq		_ok
.88b7		c9 1b		cmp #$1b			cmp		#27
.88b9		f0 1d		beq $88d8			beq		_not_ok
.88bb		c9 6e		cmp #$6e			cmp		#'n'
.88bd		f0 19		beq $88d8			beq		_not_ok
.88bf		c9 4e		cmp #$4e			cmp		#'N'
.88c1		f0 15		beq $88d8			beq		_not_ok
.88c3		c9 0d		cmp #$0d			cmp		#13
.88c5		f0 11		beq $88d8			beq		_not_ok
.88c7		80 e3		bra $88ac			bra		_next_char
.88c9						_ok:
.88c9		a9 59		lda #$59			lda		#'Y'
.88cb		20 4d 80	jsr $804d			jsr		EXTPrintCharacter
.88ce		a9 0d		lda #$0d			lda		#13
.88d0		20 4d 80	jsr $804d			jsr		EXTPrintCharacter
.88d3		9c 75 06	stz $0675			stz		programChanged
.88d6						_ok_exit:
.88d6		18		clc				clc
.88d7		60		rts				rts
.88d8						_not_ok:
.88d8		a9 4e		lda #$4e			lda		#'N'
.88da		20 4d 80	jsr $804d			jsr		EXTPrintCharacter
.88dd		a9 0d		lda #$0d			lda		#13
.88df		20 4d 80	jsr $804d			jsr		EXTPrintCharacter
.88e2		38		sec				sec
.88e3		60		rts				rts
.88e4						_continue:
>88e4		50 72 6f 67 72 61 6d 20				.text	"Program has unsaved changes, continue (y/N)? ",0
>88ec		68 61 73 20 75 6e 73 61 76 65 64 20 63 68 61 6e
>88fc		67 65 73 2c 20 63 6f 6e 74 69 6e 75 65 20 28 79
>890c		2f 4e 29 3f 20 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/warmstart.asm

.8912						WarmStart:
.8912		a2 ff		ldx #$ff			ldx 	#$FF
.8914		9a		txs				txs
.8915		a9 89		lda #$89			lda 	#CLICommandLine+$80 		; set console colour whatever the current colour is.
.8917		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.891a		20 38 82	jsr $8238			jsr 	InputLine 					; get line to lineBuffer
.891d		ad 46 05	lda $0546			lda 	lineBuffer 					; first character is slash
.8920		c9 2f		cmp #$2f			cmp 	#"/"
.8922		d0 07		bne $892b			bne 	_WSNotSlash
.8924		a2 05		ldx #$05			ldx 	#(lineBuffer+1) >> 8 		; boot rest of line.
.8926		a9 47		lda #$47			lda 	#(lineBuffer+1) & $FF
.8928		4c 64 ad	jmp $ad64			jmp 	BootXA
.892b						_WSNotSlash:
.892b		20 93 80	jsr $8093			jsr 	TKTokeniseLine 				; tokenise the line
.892e		ad 47 04	lda $0447			lda 	tokenLineNumber 			; line number <> 0
.8931		0d 48 04	ora $0448			ora 	tokenLineNumber+1
.8934		d0 17		bne $894d			bne 	_WSEditCode 				; if so,edit code.
.8936		9c 46 04	stz $0446			stz 	tokenOffset 				; zero the "offset", meaning it only runs one line.
.8939		a9 46		lda #$46			lda 	#((tokenOffset) & $FF)
.893b		85 30		sta $30				sta 	codePtr
.893d		a9 04		lda #$04			lda 	#((tokenOffset) >> 8)
.893f		85 31		sta $31				sta 	codePtr+1
.8941		ad 49 04	lda $0449			lda 	tokenBuffer 				; nothing to run
.8944		c9 80		cmp #$80			cmp 	#KWC_EOL
.8946		f0 ca		beq $8912			beq 	WarmStart
.8948		20 fe 90	jsr $90fe			jsr 	RUNCodePointerLine 			; execute that line.
.894b		80 c5		bra $8912			bra 	WarmStart
.894d						_WSEditCode:
.894d		20 62 88	jsr $8862			jsr 	EditProgramCode 			; edit the program code
.8950		20 a5 93	jsr $93a5			jsr 	ClearSystem 				; clear all variables etc.
.8953		80 bd		bra $8912			bra 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assemble.asm

.8955						AssembleCommand:
.8955		a2 00		ldx #$00			ldx 	#0
.8957		20 02 a4	jsr $a402			jsr 	Evaluate16BitInteger 		; start address
.895a		a5 60		lda $60				lda 	NSMantissa0
.895c		8d 3a 04	sta $043a			sta 	AssemblerAddress
.895f		a5 70		lda $70				lda 	NSMantissa1
.8961		8d 3b 04	sta $043b			sta 	AssemblerAddress+1
.8964		20 08 95	jsr $9508			jsr 	CheckComma
.8967		20 1d a4	jsr $a41d			jsr 	Evaluate8BitInteger 		; options 0-3
.896a		a5 60		lda $60				lda 	NSMantissa0
.896c		8d 3c 04	sta $043c			sta 	AssemblerControl
.896f		60		rts				rts
.8970		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assert.asm

.8971						AssertCommand:
.8971		a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.8973		20 ef a3	jsr $a3ef			jsr 	EvaluateInteger 			; the assert test
.8976		20 a4 a4	jsr $a4a4			jsr 	NSMIsZero 					; exit if result is non zero.
.8979		d0 05		bne $8980			bne 	_ACExit
.897b		a9 0a		lda #$0a		lda	#10
.897d		4c 19 95	jmp $9519		jmp	ErrorHandler
.8980						_ACExit:
.8980		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/call.asm

.8981						CallCommand:
.8981		a2 00		ldx #$00			ldx 	#0 							; get the routine address to level 0
.8983		20 02 a4	jsr $a402			jsr 	Evaluate16BitInteger
.8986						_CCClear
.8986		e8		inx				inx  								; clear 1,2 and 3 (for A X Y)
.8987		20 82 a4	jsr $a482			jsr 	NSMSetZero 					; these are optional sequentially.
.898a		e0 04		cpx #$04			cpx 	#4
.898c		d0 f8		bne $8986			bne 	_CCClear
.898e		a2 00		ldx #$00			ldx 	#0 							; and keep trying while there are more values.
.8990						_CCCParam:
.8990		b1 30		lda ($30),y			lda 	(codePtr),y
.8992		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8994		d0 09		bne $899f			bne 	_CCCRun6502
.8996		c8		iny				iny 								; skip comma
.8997		e8		inx				inx	 								; next level
.8998		20 1d a4	jsr $a41d			jsr 	Evaluate8BitInteger 		; get A/X/Y
.899b		e0 03		cpx #$03			cpx 	#3
.899d		90 f1		bcc $8990			bcc 	_CCCParam 					; done all 3 ?
.899f						_CCCRun6502:
.899f		5a		phy				phy 								; save position
.89a0		a5 70		lda $70				lda 	NSMantissa1 				; put address in zTemp0
.89a2		85 37		sta $37				sta 	zTemp0+1
.89a4		a5 60		lda $60				lda 	NSMantissa0
.89a6		85 36		sta $36				sta 	zTemp0
.89a8		a5 61		lda $61				lda 	NSMantissa0+1 				; get registers into A X Y
.89aa		a6 62		ldx $62				ldx 	NSMantissa0+2
.89ac		a4 63		ldy $63				ldy 	NSMantissa0+3
.89ae		20 b3 89	jsr $89b3			jsr 	_CCCZTemp0 					; call zTemp0
.89b1		7a		ply				ply 								; restore position and exit
.89b2		60		rts				rts
.89b3						_CCCZTemp0:
.89b3		6c 36 00	jmp ($0036)			jmp 	(zTemp0)

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/data.asm

.89b6						Command_Data:
.89b6		a9 3a		lda #$3a			lda 	#KWD_COLON 					; advance to colon/EOL, e.g. ignore anything till then.
.89b8		a2 80		ldx #$80			ldx 	#KWC_EOL
.89ba		20 5b 94	jsr $945b			jsr 	ScanForward
.89bd		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dim.asm

.89be						DimCommand:
.89be		b1 30		lda ($30),y			lda 	(codePtr),y
.89c0		29 c0		and #$c0			and 	#$C0
.89c2		c9 40		cmp #$40			cmp 	#$40
.89c4		d0 7a		bne $8a40			bne 	_DCSyntax 				; n o, error.
.89c6		b1 30		lda ($30),y			lda 	(codePtr),y
.89c8		18		clc				clc
.89c9		69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.89cb		85 3f		sta $3f				sta 	zaTemp+1
.89cd		c8		iny				iny
.89ce		b1 30		lda ($30),y			lda 	(codePtr),y
.89d0		c8		iny				iny
.89d1		85 3e		sta $3e				sta 	zaTemp
.89d3		5a		phy				phy
.89d4		a0 02		ldy #$02			ldy 	#2 						; read type byte
.89d6		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.89d8		29 18		and #$18			and 	#NSBTypeMask 			; check it's not a procedure
.89da		c9 18		cmp #$18			cmp 	#NSTProcedure
.89dc		f0 62		beq $8a40			beq 	_DCSyntax
.89de		b1 3e		lda ($3e),y			lda 	(zaTemp),y 				; check it's an array
.89e0		29 04		and #$04			and 	#NSBIsArray
.89e2		f0 64		beq $8a48			beq 	_DCType
.89e4		a0 04		ldy #$04			ldy 	#4 						; check not already defined
.89e6		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.89e8		d0 59		bne $8a43			bne 	_DCRedefine
.89ea		7a		ply				ply
.89eb		20 4b 8a	jsr $8a4b			jsr 	_DCGetSize 				; get array size, check it.
.89ee		5a		phy				phy
.89ef		a0 05		ldy #$05			ldy 	#5 						; store in first array size slot
.89f1		91 3e		sta ($3e),y			sta 	(zaTemp),y 				; second will be zero.
.89f3		7a		ply				ply 							; is there a second (e.g. ,x)
.89f4		b1 30		lda ($30),y			lda 	(codePtr),y
.89f6		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.89f8		d0 0a		bne $8a04			bne 	_DCOneDimension
.89fa		c8		iny				iny 							; skip comma
.89fb		20 4b 8a	jsr $8a4b			jsr 	_DCGetSize 				; get 2nd array size
.89fe		5a		phy				phy
.89ff		a0 06		ldy #$06			ldy 	#6 						; store in 2nd array size
.8a01		91 3e		sta ($3e),y			sta 	(zaTemp),y
.8a03		7a		ply				ply
.8a04						_DCOneDimension:
.8a04		5a		phy				phy 							; save position
.8a05		a0 05		ldy #$05			ldy 	#5 						; dimensions + 1 in AX (as zero based)
.8a07		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8a09		aa		tax				tax
.8a0a		c8		iny				iny
.8a0b		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8a0d		e8		inx				inx 							; bump them.
.8a0e		1a		inc a				inc 	a
.8a0f		20 2d a4	jsr $a42d			jsr 	Multiply8x8 			; work out the total number of elements -> zTemp0
.8a12		a5 37		lda $37				lda 	zTemp0+1 				; don't allow more than 8192 elements whatever
.8a14		29 e0		and #$e0			and 	#$E0
.8a16		d0 23		bne $8a3b			bne 	_DCSize
.8a18		a0 02		ldy #$02			ldy 	#2 						; get base type
.8a1a		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8a1c		20 59 8a	jsr $8a59			jsr 	ScaleByBaseType 		; scale by base type
.8a1f		a5 36		lda $36				lda 	zTemp0
.8a21		a6 37		ldx $37				ldx 	zTemp0+1
.8a23		20 24 a0	jsr $a024			jsr 	AllocateXABytes 		; allocate memory
.8a26		a0 03		ldy #$03			ldy 	#3 						; copy into the address.
.8a28		91 3e		sta ($3e),y			sta 	(zaTemp),y
.8a2a		c8		iny				iny
.8a2b		8a		txa				txa
.8a2c		91 3e		sta ($3e),y			sta 	(zaTemp),y
.8a2e		7a		ply				ply 							; get position back
.8a2f		20 00 95	jsr $9500			jsr 	CheckRightBracket 		; check )
.8a32		b1 30		lda ($30),y			lda 	(codePtr),y
.8a34		c8		iny				iny 							; consume in case
.8a35		c9 2c		cmp #$2c			cmp 	#KWD_COMMA		 		; if so do another DIM.
.8a37		f0 85		beq $89be			beq 	DimCommand
.8a39		88		dey				dey 							; undo consume
.8a3a		60		rts				rts
.8a3b						_DCSize:
.8a3b		a9 16		lda #$16		lda	#22
.8a3d		4c 19 95	jmp $9519		jmp	ErrorHandler
.8a40						_DCSyntax:
.8a40		4c fa a5	jmp $a5fa			jmp 	SyntaxError
.8a43						_DCRedefine:
.8a43		a9 15		lda #$15		lda	#21
.8a45		4c 19 95	jmp $9519		jmp	ErrorHandler
.8a48						_DCType:
.8a48		4c 04 a6	jmp $a604			jmp 	TypeError
.8a4b						_DCGetSize:
.8a4b		a2 00		ldx #$00			ldx 	#0 						; get first index.
.8a4d		20 1d a4	jsr $a41d			jsr 	Evaluate8BitInteger 	; get array dimension
.8a50		c9 00		cmp #$00			cmp 	#0 						; must be 1-254
.8a52		f0 e7		beq $8a3b			beq 	_DCSize
.8a54		c9 fe		cmp #$fe			cmp 	#254
.8a56		f0 e3		beq $8a3b			beq 	_DCSize
.8a58		60		rts				rts
.8a59						ScaleByBaseType:
.8a59		29 10		and #$10			and 	#NSBIsString 			; is it string
.8a5b		d0 19		bne $8a76			bne 	_SBBTString
.8a5d		a5 37		lda $37				lda 	zTemp0+1 				; push value on stack
.8a5f		48		pha				pha
.8a60		a5 36		lda $36				lda 	zTemp0
.8a62		48		pha				pha
.8a63		06 36		asl $36				asl 	zTemp0 					; x 2
.8a65		26 37		rol $37				rol 	zTemp0+1
.8a67		06 36		asl $36				asl 	zTemp0 					; x 4
.8a69		26 37		rol $37				rol 	zTemp0+1
.8a6b		68		pla				pla 							; add stacked value = x 5
.8a6c		65 36		adc $36				adc 	zTemp0
.8a6e		85 36		sta $36				sta 	zTemp0
.8a70		68		pla				pla
.8a71		65 37		adc $37				adc 	zTemp0+1
.8a73		85 37		sta $37				sta 	zTemp0+1
.8a75		60		rts				rts
.8a76						_SBBTString:
.8a76		06 36		asl $36				asl 	zTemp0
.8a78		26 37		rol $37				rol 	zTemp0+1
.8a7a		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/end.asm

.8a7b						EndCommand:
.8a7b		4c 12 89	jmp $8912			jmp 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/for.asm

.8a7e						ForCommand:
.8a7e		a9 d9		lda #$d9			lda 	#STK_FOR+9 					; allocate 18 bytes on the return stack (see above).
.8a80		20 99 b6	jsr $b699			jsr 	StackOpen
.8a83		a2 00		ldx #$00			ldx 	#0
.8a85		20 76 9e	jsr $9e76			jsr 	EvaluateTerm
.8a88		b5 50		lda $50,x			lda 	NSStatus,x
.8a8a		c9 20		cmp #$20			cmp 	#NSBIsReference+NSTInteger 	; do we have an integer 4 byte reference.
.8a8c		d0 47		bne $8ad5			bne		_FCError
.8a8e		a9 3d		lda #$3d			lda 	#KWD_EQUAL 					; =
.8a90		20 10 95	jsr $9510			jsr 	CheckNextA
.8a93		e8		inx				inx
.8a94		20 ef a3	jsr $a3ef			jsr 	EvaluateInteger 			; <from> in +1
.8a97		b1 30		lda ($30),y			lda 	(codePtr),y
.8a99		c8		iny				iny 								; consume it
.8a9a		48		pha				pha 								; save on stack for later
.8a9b		c9 c2		cmp #$c2			cmp 	#KWD_DOWNTO
.8a9d		f0 04		beq $8aa3			beq 	_FCNoSyntax
.8a9f		c9 dc		cmp #$dc			cmp 	#KWD_TO
.8aa1		d0 35		bne $8ad8			bne 	_FCSyntaxError
.8aa3						_FCNoSyntax:
.8aa3		e8		inx				inx
.8aa4		20 ef a3	jsr $a3ef			jsr 	EvaluateInteger
.8aa7		20 de b6	jsr $b6de			jsr 	STKSaveCodePosition 		; save loop back position
.8aaa		68		pla				pla 								; restore DOWNTO or TO
.8aab		5a		phy				phy 								; save Y on the stack
.8aac		49 c2		eor #$c2			eor 	#KWD_DOWNTO 				; 0 if DOWNTO, #0 if TO
.8aae		f0 02		beq $8ab2			beq 	_FCNotDownTo
.8ab0		a9 02		lda #$02			lda 	#2
.8ab2						_FCNotDownTo:
.8ab2		3a		dec a				dec 	a 							; 255 if DOWNTO, 1 if TO
.8ab3		a0 10		ldy #$10			ldy 	#16
.8ab5		91 34		sta ($34),y			sta 	(basicStack),y 				; copy that out to the Basic Stack.
.8ab7		a0 06		ldy #$06			ldy 	#6 							; this is the address of the loop variable.
.8ab9		a5 60		lda $60				lda 	NSMantissa0
.8abb		91 34		sta ($34),y			sta 	(basicStack),y
.8abd		a5 70		lda $70				lda 	NSMantissa1
.8abf		c8		iny				iny
.8ac0		91 34		sta ($34),y			sta 	(basicStack),y
.8ac2		a0 08		ldy #$08			ldy 	#8 							; set initial index value
.8ac4		a2 01		ldx #$01			ldx 	#1
.8ac6		20 db 8a	jsr $8adb			jsr 	FCIntegerToStack
.8ac9		a0 0c		ldy #$0c			ldy 	#12 						; set the terminal value
.8acb		a2 02		ldx #$02			ldx 	#2
.8acd		20 db 8a	jsr $8adb			jsr 	FCIntegerToStack
.8ad0		20 f6 8a	jsr $8af6			jsr 	CopyIndexToReference
.8ad3		7a		ply				ply 								; restore position
.8ad4		60		rts				rts
.8ad5						_FCError:
.8ad5		4c 04 a6	jmp $a604			jmp 	TypeError
.8ad8						_FCSyntaxError:
.8ad8		4c fa a5	jmp $a5fa			jmp 	SyntaxError
.8adb						FCIntegerToStack:
.8adb		34 50		bit $50,x			bit 	NSStatus,x 					; is the value negative
.8add		10 03		bpl $8ae2			bpl	 	_FCNotNegative
.8adf		20 4b a4	jsr $a44b			jsr 	NSMNegateMantissa 			; if so 2's complement the mantissa
.8ae2						_FCNotNegative:
.8ae2		b5 60		lda $60,x			lda 	NSMantissa0,x 				; copy out to the basic stack
.8ae4		91 34		sta ($34),y			sta 	(basicStack),y
.8ae6		c8		iny				iny
.8ae7		b5 70		lda $70,x			lda 	NSMantissa1,x
.8ae9		91 34		sta ($34),y			sta 	(basicStack),y
.8aeb		c8		iny				iny
.8aec		b5 80		lda $80,x			lda 	NSMantissa2,x
.8aee		91 34		sta ($34),y			sta 	(basicStack),y
.8af0		c8		iny				iny
.8af1		b5 90		lda $90,x			lda 	NSMantissa3,x
.8af3		91 34		sta ($34),y			sta 	(basicStack),y
.8af5		60		rts				rts
.8af6						CopyIndexToReference:
.8af6		5a		phy				phy
.8af7		a0 06		ldy #$06			ldy 	#6 							; copy address-8 to write to zTemp0
.8af9		38		sec				sec 								; (because we copy from offset 8)
.8afa		b1 34		lda ($34),y			lda 	(basicStack),y
.8afc		e9 08		sbc #$08			sbc 	#8
.8afe		85 36		sta $36				sta 	zTemp0
.8b00		c8		iny				iny
.8b01		b1 34		lda ($34),y			lda 	(basicStack),y
.8b03		e9 00		sbc #$00			sbc 	#0
.8b05		85 37		sta $37				sta 	zTemp0+1
.8b07		a2 04		ldx #$04			ldx 	#4 							; this is the copy counter/
.8b09		a0 0b		ldy #$0b			ldy 	#8+3 		 				; the MSB of the mantissa
.8b0b		b1 34		lda ($34),y			lda 	(basicStack),y
.8b0d		0a		asl a				asl 	a 							; into carry
.8b0e		a0 08		ldy #$08			ldy 	#8 							; where to copy from.
.8b10		90 14		bcc $8b26			bcc 	_CITRNormal
.8b12		38		sec				sec
.8b13						_CITRNegative:
.8b13		a9 00		lda #$00			lda 	#0
.8b15		f1 34		sbc ($34),y			sbc 	(basicStack),y
.8b17		91 36		sta ($36),y			sta 	(zTemp0),y
.8b19		c8		iny				iny
.8b1a		ca		dex				dex
.8b1b		d0 f6		bne $8b13			bne 	_CITRNegative
.8b1d		88		dey				dey 								; look at MSB of mantissa
.8b1e		b1 36		lda ($36),y			lda 	(zTemp0),y 					; set the MSB as negative packed.
.8b20		09 80		ora #$80			ora 	#$80
.8b22		91 36		sta ($36),y			sta 	(zTemp0),y
.8b24		7a		ply				ply
.8b25		60		rts				rts
.8b26						_CITRNormal:
.8b26		b1 34		lda ($34),y			lda 	(basicStack),y 				; copy without negation.
.8b28		91 36		sta ($36),y			sta 	(zTemp0),y
.8b2a		c8		iny				iny
.8b2b		ca		dex				dex
.8b2c		d0 f8		bne $8b26			bne 	_CITRNormal
.8b2e		7a		ply				ply 								; and exit.
.8b2f		60		rts				rts
.8b30						NextCommand:
.8b30		a9 d9		lda #$d9			lda 	#STK_FOR+9 					; check FOR is TOS
.8b32		a2 11		ldx #$11			ldx 	#ERRID_FOR 					; this error
.8b34		20 c6 b6	jsr $b6c6			jsr 	StackCheckFrame
.8b37		5a		phy				phy
.8b38		a0 10		ldy #$10			ldy 	#16 						; get the step count
.8b3a		b1 34		lda ($34),y			lda 	(basicStack),y
.8b3c		85 36		sta $36				sta 	zTemp0 						; this is the sign extend
.8b3e		30 02		bmi $8b42			bmi 	_NCStepNeg
.8b40		64 36		stz $36				stz 	zTemp0 						; which is 0 or 255
.8b42						_NCStepNeg:
.8b42		a0 08		ldy #$08			ldy 	#8 							; offset to bump
.8b44		a2 04		ldx #$04			ldx 	#4 							; count to bump
.8b46		18		clc				clc
.8b47						_NCBump:
.8b47		71 34		adc ($34),y			adc 	(basicStack),y 				; add it
.8b49		91 34		sta ($34),y			sta 	(basicStack),y
.8b4b		a5 36		lda $36				lda 	zTemp0 						; get sign extend for next time.
.8b4d		c8		iny				iny 								; next byte
.8b4e		ca		dex				dex 								; do four times
.8b4f		d0 f6		bne $8b47			bne 	_NCBump
.8b51		20 f6 8a	jsr $8af6			jsr		CopyIndexToReference		; copy it to the reference variable.
.8b54		a0 10		ldy #$10			ldy 	#16 						; get step count again
.8b56		b1 34		lda ($34),y			lda 	(basicStack),y
.8b58		0a		asl a				asl 	a 							; sign bit to carry
.8b59		a9 0c		lda #$0c			lda 	#12 						; offset of LHS = terminal offset
.8b5b		85 38		sta $38				sta 	zTemp1
.8b5d		90 02		bcc $8b61			bcc 	_NCCompRev 					; use if step is +ve
.8b5f		a9 08		lda #$08			lda 	#8 							; now the LHS = index value
.8b61						_NCCompRev:
.8b61		85 38		sta $38				sta 	zTemp1 						; so zTemp0 is the index for LHS
.8b63		49 04		eor #$04			eor 	#(8^12) 					; and zTemp0+1 is the index for RHS
.8b65		85 39		sta $39				sta 	zTemp1+1
.8b67		a2 04		ldx #$04			ldx 	#4 							; bytes to compare
.8b69		38		sec				sec
.8b6a						_NCCompare:
.8b6a		a4 38		ldy $38				ldy 	zTemp1 						; do compare using the two indices
.8b6c		b1 34		lda ($34),y			lda 	(basicStack),y
.8b6e		a4 39		ldy $39				ldy 	zTemp1+1
.8b70		f1 34		sbc ($34),y			sbc 	(basicStack),y
.8b72		e6 38		inc $38				inc 	zTemp1 						; bump the indices (inc,dex do not change C or V)
.8b74		e6 39		inc $39				inc 	zTemp1+1
.8b76		ca		dex				dex 								; do it 4 times.
.8b77		d0 f1		bne $8b6a			bne 	_NCCompare
.8b79		50 02		bvc $8b7d			bvc 	_NCNoOverflow 				; convert to signed comparison
.8b7b		49 80		eor #$80			eor 	#$80
.8b7d						_NCNoOverflow:
.8b7d		7a		ply				ply 								; restore Y position
.8b7e		0a		asl a				asl 	a 							; is bit 7 set.
.8b7f		90 04		bcc $8b85			bcc 	_NCLoopBack 				; if no , >= so loop back
.8b81		20 b8 b6	jsr $b6b8			jsr 	StackClose 					; exit the loop
.8b84		60		rts				rts
.8b85						_NCLoopBack:
.8b85		20 ef b6	jsr $b6ef			jsr 	STKLoadCodePosition 		; loop back
.8b88		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/gosub.asm

.8b89						Command_GOSUB:
.8b89		a2 00		ldx #$00			ldx 	#0
.8b8b		20 02 a4	jsr $a402			jsr 	Evaluate16BitInteger 		; line number in Stack.0
.8b8e		a9 e3		lda #$e3			lda 	#STK_GOSUB+3
.8b90		20 99 b6	jsr $b699			jsr 	StackOpen 					; create frame
.8b93		20 de b6	jsr $b6de			jsr 	STKSaveCodePosition 		; save current position
.8b96		4c ac 8b	jmp $8bac			jmp 	GotoStackX
.8b99						Command_RETURN:
.8b99		a9 e0		lda #$e0			lda 	#STK_GOSUB 					; check TOS is this
.8b9b		a2 0e		ldx #$0e			ldx 	#ERRID_GOSUB 				; this error
.8b9d		20 c6 b6	jsr $b6c6			jsr 	StackCheckFrame
.8ba0		20 ef b6	jsr $b6ef			jsr 	STKLoadCodePosition 		; restore code position
.8ba3		20 b8 b6	jsr $b6b8			jsr 	StackClose
.8ba6		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/goto.asm

.8ba7						GotoCommand:
.8ba7		a2 00		ldx #$00			ldx 	#0 							; GOTO where
.8ba9		20 02 a4	jsr $a402			jsr 	Evaluate16BitInteger
.8bac						GotoStackX:
.8bac		b5 70		lda $70,x			lda  	NSMantissa1,x 				; put line # in XA. I'll keep this even though
.8bae		48		pha				pha 								; it is slightly inefficient, just in cases.
.8baf		b5 60		lda $60,x			lda 	NSMantissa0,x
.8bb1		fa		plx				plx
.8bb2		20 e1 a8	jsr $a8e1			jsr 	MemorySearch 				; transfer to line number AX.
.8bb5		90 05		bcc $8bbc			bcc 	_GotoError 					; not found, off end.
.8bb7		d0 03		bne $8bbc			bne 	_GotoError 					; not found exactly
.8bb9		4c f7 90	jmp $90f7			jmp 	RunNewLine 					; and go straight to new line code.
.8bbc						_GotoError:
.8bbc		a9 0d		lda #$0d		lda	#13
.8bbe		4c 19 95	jmp $9519		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/if.asm

.8bc1						IfCommand:
.8bc1		a2 00		ldx #$00			ldx 	#0 							; Get the if test.
.8bc3		20 d0 a3	jsr $a3d0			jsr 	EvaluateNumber
.8bc6		b1 30		lda ($30),y			lda 	(codePtr),y
.8bc8		c9 b6		cmp #$b6			cmp 	#KWD_THEN  					; could be THEN <stuff>
.8bca		d0 0a		bne $8bd6			bne 	_IfStructured 				; we still support it.
.8bcc		c8		iny				iny 								; consume THEN
.8bcd		20 a4 a4	jsr $a4a4			jsr 	NSMIsZero 					; is it zero
.8bd0		f0 01		beq $8bd3			beq 	_IfFail 					; if fail, go to next line
.8bd2		60		rts				rts 								; if THEN just continue
.8bd3						_IfFail:
.8bd3		4c d2 90	jmp $90d2			jmp 	EOLCommand
.8bd6						_IfStructured:
.8bd6		20 a4 a4	jsr $a4a4			jsr 	NSMIsZero 					; is it zero
.8bd9		d0 07		bne $8be2			bne 	_IfExit 					; if not, then continue normally.
.8bdb		a9 c3		lda #$c3			lda 	#KWD_ELSE 					; look for else/endif
.8bdd		a2 b3		ldx #$b3			ldx 	#KWD_ENDIF
.8bdf		20 5b 94	jsr $945b			jsr 	ScanForward 				; and run from there
.8be2						_IfExit:
.8be2		60		rts				rts
.8be3						ElseCode:
.8be3		a9 b3		lda #$b3			lda 	#KWD_ENDIF 					; else is only run after the if clause succeeds
.8be5		aa		tax				tax 								; so just go to the structure exit
.8be6		20 5b 94	jsr $945b			jsr 	ScanForward
.8be9		60		rts				rts
.8bea						EndIf:
.8bea		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/inputprint.asm

.8beb						Command_Input:
.8beb		9c 44 04	stz $0444			stz 	isPrintFlag
.8bee		80 0c		bra $8bfc			bra 	Command_IP_Main
.8bf0						Command_CPrint:
.8bf0		a9 7f		lda #$7f			lda 	#$7F
.8bf2		8d 44 04	sta $0444			sta 	isPrintFlag 				; set input flag to character mode
.8bf5		80 05		bra $8bfc			bra 	Command_IP_Main
.8bf7						Command_Print:
.8bf7		a9 ff		lda #$ff			lda 	#$FF
.8bf9		8d 44 04	sta $0444			sta 	isPrintFlag 				; set input flag
.8bfc						Command_IP_Main:
.8bfc		18		clc				clc
.8bfd						_CPLoop:
.8bfd		08		php				php 								; save last action flag
.8bfe		b1 30		lda ($30),y			lda 	(codePtr),y
.8c00		c9 80		cmp #$80			cmp  	#KWC_EOL 					; end of line or colon, exit now.
.8c02		f0 5d		beq $8c61			beq 	_CPExit
.8c04		c9 3a		cmp #$3a			cmp 	#KWD_COLON
.8c06		f0 59		beq $8c61			beq 	_CPExit
.8c08		68		pla				pla 								; throw last action flag
.8c09		b1 30		lda ($30),y			lda 	(codePtr),y
.8c0b		c8		iny				iny
.8c0c		c9 3b		cmp #$3b			cmp 	#KWD_SEMICOLON				; is it a semicolon
.8c0e		f0 4e		beq $8c5e			beq 	_CPContinueWithSameLine
.8c10		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; comma
.8c12		f0 45		beq $8c59			beq 	_CPTab
.8c14		c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; apostrophe (new line)
.8c16		f0 3d		beq $8c55			beq 	_CPNewLine
.8c18		c9 b9		cmp #$b9			cmp 	#KWD_AT 					; `at` modifier
.8c1a		f0 34		beq $8c50			beq 	_CPAtModifier
.8c1c		88		dey				dey 								; undo the get
.8c1d		20 21 9a	jsr $9a21			jsr 	EvaluateExpressionAt0 		; evaluate expression at 0.
.8c20		b5 50		lda $50,x			lda 	NSStatus,x 					; read the status
.8c22		29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.8c24		f0 0d		beq $8c33			beq 	_CPIsValue 					; no, display it
.8c26		ad 44 04	lda $0444			lda 	isPrintFlag 				; if print, dereference and print
.8c29		d0 05		bne $8c30			bne 	_CPIsPrint 					; otherwise display.
.8c2b		20 6a 8c	jsr $8c6a			jsr 	CIInputValue 				; input a value to the reference
.8c2e		80 25		bra $8c55			bra 	_CPNewLine
.8c30						_CPIsPrint:
.8c30		20 ef 9c	jsr $9cef			jsr 	Dereference 				; dereference if required.
.8c33						_CPIsValue:
.8c33		b5 50		lda $50,x			lda 	NSStatus,x 					; is it a number
.8c35		29 10		and #$10			and 	#NSBIsString
.8c37		f0 09		beq $8c42			beq 	_CPNumber
.8c39		a6 70		ldx $70				ldx 	NSMantissa1 				; string, print the text.
.8c3b		a5 60		lda $60				lda 	NSMantissa0
.8c3d		20 cd 8c	jsr $8ccd			jsr 	CPPrintStringXA
.8c40		80 ba		bra $8bfc			bra 	Command_IP_Main 			; loop round clearing carry so NL if end
.8c42						_CPNumber:
.8c42		a9 05		lda #$05			lda 	#5 							; maximum decimals
.8c44		20 b7 a2	jsr $a2b7			jsr 	ConvertNumberToString 		; convert to string (in unary str$() function)
.8c47		a2 06		ldx #$06			ldx 	#decimalBuffer >> 8
.8c49		a9 65		lda #$65			lda 	#decimalBuffer & $FF
.8c4b		20 cd 8c	jsr $8ccd			jsr 	CPPrintStringXA 			; print it.
.8c4e		80 ac		bra $8bfc			bra 	Command_IP_Main				; loop round clearing carry so NL if end
.8c50						_CPAtModifier:
.8c50		20 ee 8c	jsr $8cee			jsr 	CPPrintAt			        ; subroutine to keep `_CPLoop` within branch range
.8c53		80 a7		bra $8bfc			bra 	Command_IP_Main
.8c55						_CPNewLine:
.8c55		a9 0d		lda #$0d			lda 	#13
.8c57		80 02		bra $8c5b			bra 	_CPPrintCharDirect
.8c59						_CPTab:
.8c59		a9 09		lda #$09			lda 	#9 							; print TAB
.8c5b						_CPPrintCharDirect:
.8c5b		20 e8 8c	jsr $8ce8			jsr 	CPPVControl 				; print TAB/CR using the non PETSCII
.8c5e						_CPContinueWithSameLine:
.8c5e		38		sec				sec 								; loop round with carry set, which
.8c5f		80 9c		bra $8bfd			bra 	_CPLoop 					; will inhibit final CR
.8c61						_CPExit:
.8c61		28		plp				plp 								; get last action flag
.8c62		b0 05		bcs $8c69			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.8c64		a9 0d		lda #$0d			lda 	#13 						; print new line
.8c66		20 e8 8c	jsr $8ce8			jsr 	CPPVControl
.8c69						_CPExit2:
.8c69		60		rts				rts
.8c6a						CIInputValue:
.8c6a		a2 00		ldx #$00			ldx 	#0 							; input a line.
.8c6c						_CIInputLine:
.8c6c		20 eb 8c	jsr $8ceb			jsr 	CPInputVector 				; get key
.8c6f		c9 0d		cmp #$0d			cmp 	#13 						; 13 = End
.8c71		f0 1f		beq $8c92			beq 	_CIHaveValue
.8c73		c9 08		cmp #$08			cmp 	#8 							; 8 = BS
.8c75		f0 11		beq $8c88			beq 	_CIBackspace
.8c77		c9 20		cmp #$20			cmp 	#32 						; ignore other control characters
.8c79		90 f1		bcc $8c6c			bcc 	_CIInputLine
.8c7b		e0 50		cpx #$50			cpx 	#80 						; max length
.8c7d		b0 ed		bcs $8c6c			bcs 	_CIInputLine
.8c7f		9d 46 05	sta $0546,x			sta 	lineBuffer,x
.8c82		e8		inx				inx
.8c83		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter 			; echo it.
.8c86		80 e4		bra $8c6c			bra 	_CIInputLine
.8c88						_CIBackspace:
.8c88		e0 00		cpx #$00			cpx 	#0 							; nothing to delete
.8c8a		f0 e0		beq $8c6c			beq 	_CIInputLine
.8c8c		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter 			; echo it.
.8c8f		ca		dex				dex
.8c90		80 da		bra $8c6c			bra 	_CIInputLine
.8c92						_CIHaveValue:
.8c92		9e 46 05	stz $0546,x			stz 	lineBuffer,x 				; ASCIIZ string now in line buffer.
.8c95		a5 50		lda $50				lda 	NSStatus 					; was it a string assignment
.8c97		29 10		and #$10			and 	#NSBIsString
.8c99		f0 17		beq $8cb2			beq 	_CIAssignNumber 			; assign a number
.8c9b		a2 01		ldx #$01			ldx 	#1
.8c9d		a9 46		lda #$46			lda 	#lineBuffer & $FF 			; set up to point to new string
.8c9f		95 60		sta $60,x			sta 	NSMantissa0,x
.8ca1		a9 05		lda #$05			lda 	#lineBuffer >> 8
.8ca3		95 70		sta $70,x			sta 	NSMantissa1,x
.8ca5		74 80		stz $80,x			stz 	NSMantissa2,x
.8ca7		74 90		stz $90,x			stz 	NSMantissa3,x
.8ca9		a9 10		lda #$10			lda 	#NSBIsString 				; so it becomes a string value
.8cab		95 50		sta $50,x			sta  	NSStatus,x
.8cad		ca		dex				dex 								; X = 0
.8cae		20 4d 8d	jsr $8d4d			jsr 	AssignVariable
.8cb1		60		rts				rts
.8cb2						_CIAssignNumber:
.8cb2		a9 46		lda #$46			lda 	#lineBuffer & $FF 			; set up to point to new string
.8cb4		85 36		sta $36				sta 	zTemp0
.8cb6		a9 05		lda #$05			lda 	#lineBuffer >> 8
.8cb8		85 37		sta $37				sta 	zTemp0+1
.8cba		a2 01		ldx #$01			ldx 	#1 							; put in slot 1
.8cbc		20 97 a1	jsr $a197			jsr 	ValEvaluateZTemp0 			; use the VAL() code
.8cbf		90 07		bcc $8cc8			bcc 	_CIIsOkay
.8cc1		a9 3f		lda #$3f			lda 	#"?" 						; error ?
.8cc3		20 e0 8c	jsr $8ce0			jsr 	CPPrintVector
.8cc6		80 a2		bra $8c6a			bra 	CIInputValue
.8cc8						_CIIsOkay:
.8cc8		ca		dex				dex 								; X = 0
.8cc9		20 4d 8d	jsr $8d4d			jsr 	AssignVariable
.8ccc		60		rts				rts
.8ccd						CPPrintStringXA:
.8ccd		5a		phy				phy
.8cce		86 37		stx $37				stx 	zTemp0+1
.8cd0		85 36		sta $36				sta 	zTemp0
.8cd2		a0 00		ldy #$00			ldy 	#0
.8cd4						_PSXALoop:
.8cd4		b1 36		lda ($36),y			lda 	(zTemp0),y
.8cd6		f0 06		beq $8cde			beq 	_PSXAExit
.8cd8		20 e0 8c	jsr $8ce0			jsr 	CPPrintVector
.8cdb		c8		iny				iny
.8cdc		80 f6		bra $8cd4			bra 	_PSXALoop
.8cde						_PSXAExit:
.8cde		7a		ply				ply
.8cdf		60		rts				rts
.8ce0						CPPrintVector:
.8ce0		2c 44 04	bit $0444			bit 	isPrintFlag 				; check if char only mode and call appropriate handler
.8ce3		30 03		bmi $8ce8			bmi 	CPPVControl
.8ce5		4c 57 80	jmp $8057			jmp 	EXTPrintNoControl
.8ce8						CPPVControl:
.8ce8		4c 4d 80	jmp $804d			jmp 	EXTPrintCharacter
.8ceb						CPInputVector:
.8ceb		4c f5 81	jmp $81f5			jmp 	KNLGetSingleCharacter
.8cee						CPPrintAt:
.8cee		a2 00		ldx #$00			ldx		#0 							; bottom stack level
.8cf0		20 1d a4	jsr $a41d			jsr		Evaluate8BitInteger         ; parse row into `A`
.8cf3		cd ee 07	cmp $07ee			cmp		EXTScreenHeight				; check if row is within valid range
.8cf6		b0 19		bcs $8d11			bcs		_range_error
.8cf8		48		pha				pha									; save it on the stack
.8cf9		20 08 95	jsr $9508			jsr		CheckComma					; ensure the next character is a comma
.8cfc		20 1d a4	jsr $a41d			jsr		Evaluate8BitInteger			; parse column into `A`
.8cff		cd ed 07	cmp $07ed			cmp		EXTScreenWidth				; check if column is within valid range
.8d02		b0 0d		bcs $8d11			bcs		_range_error
.8d04		8d eb 07	sta $07eb			sta     EXTColumn					; save column into `EXTColumn`
.8d07		68		pla				pla                                 ; restore row into `A`
.8d08		8d ea 07	sta $07ea			sta     EXTRow						; save row into `EXTRow`
.8d0b		5a		phy				phy
.8d0c		20 61 80	jsr $8061			jsr 	EXTSetCurrentLine         	; set current line address to `EXTRow`
.8d0f		7a		ply		        ply
.8d10		60		rts				rts
.8d11						_range_error:
.8d11		4c ff a5	jmp $a5ff			jmp 	RangeError 					; branch to range error handler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/let.asm

.8d14						LetCommand:
.8d14		a2 00		ldx #$00			ldx 	#0
.8d16		b1 30		lda ($30),y			lda 	(codePtr),y
.8d18		c9 10		cmp #$10			cmp 	#KWD_ATCH
.8d1a		d0 14		bne $8d30			bne 	_LCStandard
.8d1c		c8		iny				iny 								; skip equal
.8d1d		20 76 9e	jsr $9e76			jsr 	EvaluateTerm 				; get a number (the address of the reference)
.8d20		20 ef 9c	jsr $9cef			jsr 	Dereference 				; dereference it to a value
.8d23		b5 50		lda $50,x			lda 	NSStatus,x 					; check integer
.8d25		49 20		eor #$20			eor 	#NSBIsReference	 			; toggle reference
.8d27		95 50		sta $50,x			sta 	NSStatus,x
.8d29		29 20		and #$20			and 	#NSBIsReference 			; if it is now a reference, continue
.8d2b		d0 0f		bne $8d3c			bne 	_LCMain
.8d2d		4c 04 a6	jmp $a604			jmp 	TypeError 					; was a reference before.
.8d30						_LCStandard:
.8d30		ad 0b 9a	lda $9a0b			lda 	PrecedenceLevel+"*"			; precedence > this
.8d33		20 25 9a	jsr $9a25			jsr 	EvaluateExpressionAtPrecedence
.8d36		b5 50		lda $50,x			lda 	NSStatus,x 					; is it a reference to an array marked as procedure ?
.8d38		c9 38		cmp #$38			cmp		#NSTProcedure+NSBIsReference
.8d3a		f0 0e		beq $8d4a			beq 	_LetGoProc 					; it's a procedure call.
.8d3c						_LCMain:
.8d3c		a9 3d		lda #$3d			lda 	#"=" 						; check =
.8d3e		20 10 95	jsr $9510			jsr 	CheckNextA
.8d41		e8		inx				inx 								; RHS
.8d42		20 c7 a3	jsr $a3c7			jsr 	EvaluateValue
.8d45		ca		dex				dex
.8d46		20 4d 8d	jsr $8d4d			jsr 	AssignVariable
.8d49		60		rts				rts
.8d4a						_LetGoProc:
.8d4a		4c 9f 8f	jmp $8f9f			jmp 	CallProcedure
.8d4d						AssignVariable:
.8d4d		b5 50		lda $50,x			lda 	NSStatus,x 					; check the string/number type bits match
.8d4f		48		pha				pha 								; save a copy
.8d50		55 51		eor $51,x			eor 	NSStatus+1,x
.8d52		29 10		and #$10			and 	#NSBIsString
.8d54		d0 0b		bne $8d61			bne 	_ASError
.8d56		68		pla				pla 								; get back
.8d57		29 10		and #$10			and 	#NSBIsString 				; check type
.8d59		d0 03		bne $8d5e			bne 	_ASString
.8d5b		4c 2d 9c	jmp $9c2d			jmp 	AssignNumber
.8d5e						_ASString:
.8d5e		4c 8b 9c	jmp $9c8b			jmp 	AssignString
.8d61						_ASError:
.8d61		4c 04 a6	jmp $a604			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/list.asm

.8d64						Command_List:
.8d64		9c 42 04	stz $0442			stz 	listIndent 					; reset indent.
.8d67		a9 3f		lda #$3f			lda 	#$3F 						; silence at list.
.8d69		20 6b 80	jsr $806b			jsr 	SNDCommand
.8d6c		b1 30		lda ($30),y			lda 	(codePtr),y
.8d6e		29 c0		and #$c0			and 	#$C0 				 		; if so, we are list procedure() which is a seperate block
.8d70		c9 40		cmp #$40			cmp 	#$40  						; of code.
.8d72		f0 72		beq $8de6			beq 	_CLListProcedure
.8d74		64 64		stz $64				stz		NSMantissa0+4				; set the lower (slot 4) to 0 and upper (slot 7) to $FFFF
.8d76		64 74		stz $74				stz 	NSMantissa1+4 				; these are the default top and bottom.
.8d78		a9 ff		lda #$ff			lda 	#$FF
.8d7a		85 67		sta $67				sta 	NSMantissa0+7
.8d7c		85 77		sta $77				sta 	NSMantissa1+7
.8d7e		b1 30		lda ($30),y			lda 	(codePtr),y
.8d80		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8d82		f0 1a		beq $8d9e			beq 	_CLSecond
.8d84		20 6c 8e	jsr $8e6c			jsr 	CLIsDigit 					; if not digit, list all
.8d87		b0 20		bcs $8da9			bcs 	_CLStart
.8d89		a2 04		ldx #$04			ldx 	#4 							; get 1st range into slot 4
.8d8b		20 02 a4	jsr $a402			jsr 	Evaluate16BitInteger
.8d8e		b1 30		lda ($30),y			lda 	(codePtr),y
.8d90		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8d92		f0 0a		beq $8d9e			beq 	_CLSecond 					; if so go get it
.8d94		a5 64		lda $64				lda 	NSMantissa0+4 				; copy 4->7
.8d96		85 67		sta $67				sta 	NSMantissa0+7
.8d98		a5 74		lda $74				lda 	NSMantissa1+4
.8d9a		85 77		sta $77				sta 	NSMantissa1+7
.8d9c		80 0b		bra $8da9			bra 	_CLStart
.8d9e						_CLSecond:
.8d9e		c8		iny				iny 								; consume comma
.8d9f		20 6c 8e	jsr $8e6c			jsr 	CLIsDigit 					; digit found
.8da2		b0 05		bcs $8da9			bcs 	_CLStart 					; if not, continue listing
.8da4		a2 07		ldx #$07			ldx 	#7 							; load 2nd range into slot 7
.8da6		20 02 a4	jsr $a402			jsr 	Evaluate16BitInteger
.8da9						_CLStart
.8da9		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8dab		85 30		sta $30				sta 	codePtr
.8dad		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8daf		85 31		sta $31				sta 	codePtr+1
.8db1						_CLLoop:
.8db1		a5 f2		lda $f2				lda 	kernel.args.events.pending 	; load pending event count into accumulator
.8db3		f0 03		beq $8db8			beq 	_NoEvents					; if zero, skip with Z flag set.
.8db5		20 58 81	jsr $8158			jsr 	ProcessEvents
.8db8						_NoEvents:
.8db8		d0 27		bne $8de1			bne 	_CLBreak
.8dba		b2 30		lda ($30)			lda 	(codePtr)
.8dbc		f0 20		beq $8dde			beq 	_CLExit
.8dbe		a2 04		ldx #$04			ldx 	#4 							; check range every time, line numbers aren't in order.
.8dc0		20 5b 8e	jsr $8e5b			jsr 	CLCompareLineNo
.8dc3		90 0c		bcc $8dd1			bcc 	_CLNext
.8dc5		a2 07		ldx #$07			ldx 	#7
.8dc7		20 5b 8e	jsr $8e5b			jsr 	CLCompareLineNo
.8dca		f0 02		beq $8dce			beq 	_CLDoThisOne
.8dcc		b0 03		bcs $8dd1			bcs 	_CLNext
.8dce						_CLDoThisOne:
.8dce		20 48 8e	jsr $8e48			jsr 	CLListOneLine 				; routine to list the current line.
.8dd1						_CLNext:
.8dd1		18		clc				clc
.8dd2		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8dd4		65 30		adc $30				adc 	codePtr
.8dd6		85 30		sta $30				sta 	codePtr
.8dd8		90 02		bcc $8ddc			bcc 	_CREExit
.8dda		e6 31		inc $31				inc 	codePtr+1 					; carry
.8ddc						_CREExit:
.8ddc		80 d3		bra $8db1			bra 	_CLLoop
.8dde						_CLExit:
.8dde		4c 12 89	jmp $8912			jmp 	WarmStart
.8de1						_CLBreak:
.8de1		a9 01		lda #$01		lda	#1
.8de3		4c 19 95	jmp $9519		jmp	ErrorHandler
.8de6						_CLListProcedure:
.8de6		b1 30		lda ($30),y			lda 	(codePtr),y
.8de8		85 38		sta $38				sta 	zTemp1
.8dea		c8		iny				iny
.8deb		b1 30		lda ($30),y			lda 	(codePtr),y
.8ded		85 39		sta $39				sta 	zTemp1+1
.8def		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8df1		85 30		sta $30				sta 	codePtr
.8df3		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8df5		85 31		sta $31				sta 	codePtr+1
.8df7						_CLLPSearch:
.8df7		b2 30		lda ($30)			lda 	(codePtr)
.8df9		c9 00		cmp #$00			cmp 	#0 							; if zero, end
.8dfb		f0 e1		beq $8dde			beq 	_CLExit
.8dfd		a0 03		ldy #$03			ldy 	#3 							; check if PROC something
.8dff		b1 30		lda ($30),y			lda 	(codePtr),y
.8e01		c9 b0		cmp #$b0			cmp 	#KWD_PROC
.8e03		d0 0e		bne $8e13			bne 	_CLLPNext
.8e05		c8		iny				iny 								; check if PROC this.
.8e06		b1 30		lda ($30),y			lda 	(codePtr),y
.8e08		c5 38		cmp $38				cmp 	zTemp1 						; does it match ?
.8e0a		d0 07		bne $8e13			bne 	_CLLPNext
.8e0c		c8		iny				iny
.8e0d		b1 30		lda ($30),y			lda 	(codePtr),y
.8e0f		c5 39		cmp $39				cmp 	zTemp1+1
.8e11		f0 0d		beq $8e20			beq 	_CLLPFound
.8e13						_CLLPNext:
.8e13		18		clc				clc
.8e14		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8e16		65 30		adc $30				adc 	codePtr
.8e18		85 30		sta $30				sta 	codePtr
.8e1a		90 02		bcc $8e1e			bcc 	_CREExit
.8e1c		e6 31		inc $31				inc 	codePtr+1 					; carry
.8e1e						_CREExit:
.8e1e		80 d7		bra $8df7			bra 	_CLLPSearch
.8e20						_CLLPFound:
.8e20		b2 30		lda ($30)			lda 	(codePtr)
.8e22		f0 ba		beq $8dde			beq 	_CLExit
.8e24		a5 f2		lda $f2				lda 	kernel.args.events.pending 	; load pending event count into accumulator
.8e26		f0 03		beq $8e2b			beq 	_NoEvents					; if zero, skip with Z flag set.
.8e28		20 58 81	jsr $8158			jsr 	ProcessEvents
.8e2b						_NoEvents:
.8e2b		d0 b4		bne $8de1			bne 	_CLBreak
.8e2d		a0 03		ldy #$03			ldy 	#3 							; get first keyword
.8e2f		b1 30		lda ($30),y			lda 	(codePtr),y
.8e31		48		pha				pha
.8e32		20 48 8e	jsr $8e48			jsr 	CLListOneLine 				; list line and go forward
.8e35		18		clc				clc
.8e36		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8e38		65 30		adc $30				adc 	codePtr
.8e3a		85 30		sta $30				sta 	codePtr
.8e3c		90 02		bcc $8e40			bcc 	_CREExit
.8e3e		e6 31		inc $31				inc 	codePtr+1 					; carry
.8e40						_CREExit:
.8e40		68		pla				pla 								; reached ENDPROC ?
.8e41		c9 b4		cmp #$b4			cmp 	#KWD_ENDPROC
.8e43		d0 db		bne $8e20			bne 	_CLLPFound
.8e45		4c 12 89	jmp $8912			jmp 	WarmStart
.8e48						CLListOneLine:
.8e48		20 be 94	jsr $94be			jsr 	ScanGetCurrentLineStep 		; get indent adjust.
.8e4b		20 89 80	jsr $8089			jsr 	TKListConvertLine 			; convert line into token Buffer
.8e4e		a2 04		ldx #$04			ldx 	#(tokenBuffer >> 8) 		; print that line
.8e50		a9 49		lda #$49			lda 	#(tokenBuffer & $FF)
.8e52		20 78 95	jsr $9578			jsr 	PrintStringXA
.8e55		a9 0d		lda #$0d			lda 	#13 						; new line
.8e57		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.8e5a		60		rts				rts
.8e5b						CLCompareLineNo:
.8e5b		38		sec				sec
.8e5c		a0 01		ldy #$01			ldy 	#1
.8e5e		b1 30		lda ($30),y			lda 	(codePtr),y
.8e60		f5 60		sbc $60,x			sbc 	NSMantissa0,x
.8e62		85 36		sta $36				sta 	zTemp0
.8e64		c8		iny				iny
.8e65		b1 30		lda ($30),y			lda 	(codePtr),y
.8e67		f5 70		sbc $70,x			sbc 	NSMantissa1,x
.8e69		05 36		ora $36				ora 	zTemp0
.8e6b		60		rts				rts
.8e6c						CLIsDigit:
.8e6c		b1 30		lda ($30),y			lda 	(codePtr),y
.8e6e		c9 30		cmp #$30			cmp 	#"0"
.8e70		90 03		bcc $8e75			bcc	 	_CLIDExitFalse
.8e72		c9 3a		cmp #$3a			cmp 	#"9"+1
.8e74		60		rts				rts
.8e75						_CLIDExitFalse:
.8e75		38		sec				sec
.8e76		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/local.asm

.8e77						Command_LOCAL:
.8e77		a2 00		ldx #$00			ldx 	#0 							; at level 0
.8e79		20 85 8e	jsr $8e85			jsr 	LocaliseNextTerm 			; convert term to a local.
.8e7c		b1 30		lda ($30),y			lda 	(codePtr),y
.8e7e		c8		iny				iny
.8e7f		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8e81		f0 f4		beq $8e77			beq 	Command_LOCAL 				; if so, localise another variable.
.8e83		88		dey				dey 								; unpick pre-get
.8e84		60		rts				rts
.8e85						LocaliseNextTerm:
.8e85		20 76 9e	jsr $9e76			jsr 	EvaluateTerm 				; evaluate the term
.8e88		b5 50		lda $50,x			lda 	NSStatus,x
.8e8a		29 20		and #$20			and 	#NSBIsReference 			; check it is a reference, must be a variable.
.8e8c		f0 5c		beq $8eea			beq		_LNTError
.8e8e		b5 60		lda $60,x			lda 	NSMantissa0,x 				; copy address of variable to zTemp0
.8e90		85 36		sta $36				sta 	zTemp0
.8e92		b5 70		lda $70,x			lda 	NSMantissa1,x
.8e94		85 37		sta $37				sta  	zTemp0+1
.8e96		b5 50		lda $50,x			lda 	NSStatus,x 					; figure out what it is.
.8e98		29 10		and #$10			and 	#NSBIsString
.8e9a		d0 1e		bne $8eba			bne 	_LNTPushString
.8e9c		5a		phy				phy
.8e9d		a0 00		ldy #$00			ldy 	#0 							; push 0 to 4 inclusive, the number values, on the stack, and zero them as you go.
.8e9f						_LNTPushNumLoop:
.8e9f		b1 36		lda ($36),y			lda		(zTemp0),y
.8ea1		20 78 b6	jsr $b678			jsr 	StackPushByte
.8ea4		c8		iny				iny
.8ea5		c0 05		cpy #$05			cpy 	#5
.8ea7		d0 f6		bne $8e9f			bne 	_LNTPushNumLoop
.8ea9		a5 36		lda $36				lda 	zTemp0 						; push the actual target address to write on the stack
.8eab		20 78 b6	jsr $b678			jsr 	StackPushByte
.8eae		a5 37		lda $37				lda 	zTemp0+1
.8eb0		20 78 b6	jsr $b678			jsr 	StackPushByte
.8eb3		a9 01		lda #$01			lda 	#STK_LOCALN 				; push local-number marker.
.8eb5		20 78 b6	jsr $b678			jsr 	StackPushByte
.8eb8		7a		ply				ply
.8eb9		60		rts				rts
.8eba						_LNTPushString:
.8eba		5a		phy				phy
.8ebb		b2 36		lda ($36)			lda 	(zTemp0) 					; put address of string in zTemp1
.8ebd		85 38		sta $38				sta 	zTemp1
.8ebf		a0 01		ldy #$01			ldy 	#1
.8ec1		b1 36		lda ($36),y			lda 	(zTemp0),y
.8ec3		85 39		sta $39				sta 	zTemp1+1
.8ec5		a0 00		ldy #$00			ldy 	#0 							; output string
.8ec7		c9 00		cmp #$00			cmp 	#0 							; if not assigned string
.8ec9		f0 0a		beq $8ed5			beq 	_LNTStringOut
.8ecb						_LNTPushStrLoop:
.8ecb		b1 38		lda ($38),y			lda 	(zTemp1),y
.8ecd		f0 06		beq $8ed5			beq 	_LNTStringOut
.8ecf		20 78 b6	jsr $b678			jsr 	StackPushByte
.8ed2		c8		iny				iny
.8ed3		80 f6		bra $8ecb			bra 	_LNTPushStrLoop
.8ed5						_LNTStringOut:
.8ed5		98		tya				tya									; output length (chars written).
.8ed6		20 78 b6	jsr $b678			jsr 	StackPushByte
.8ed9		b5 60		lda $60,x			lda 	NSMantissa0,x 				; output address of the string record *not* the string itself
.8edb		20 78 b6	jsr $b678			jsr 	StackPushByte
.8ede		b5 70		lda $70,x			lda 	NSMantissa1,x
.8ee0		20 78 b6	jsr $b678			jsr 	StackPushByte
.8ee3		a9 02		lda #$02			lda 	#STK_LOCALS 				; push local-string marker.
.8ee5		20 78 b6	jsr $b678			jsr 	StackPushByte
.8ee8		7a		ply				ply
.8ee9		60		rts				rts
.8eea						_LNTError:
.8eea		4c fa a5	jmp $a5fa			jmp 	SyntaxError
.8eed						LocalPopValue:
.8eed		20 90 b6	jsr $b690			jsr 	StackPopByte
.8ef0		c9 01		cmp #$01			cmp 	#STK_LOCALN 				; if not local-N
.8ef2		d0 17		bne $8f0b			bne 	_LPVString
.8ef4		20 90 b6	jsr $b690			jsr 	StackPopByte 				; address
.8ef7		85 37		sta $37				sta 	zTemp0+1
.8ef9		20 90 b6	jsr $b690			jsr 	StackPopByte
.8efc		85 36		sta $36				sta 	zTemp0
.8efe		5a		phy				phy
.8eff		a0 04		ldy #$04			ldy 	#4 							; copy back
.8f01						_LPVNumberCopy:
.8f01		20 90 b6	jsr $b690			jsr 	StackPopByte
.8f04		91 36		sta ($36),y			sta 	(zTemp0),y
.8f06		88		dey				dey
.8f07		10 f8		bpl $8f01			bpl 	_LPVNumberCopy
.8f09		7a		ply				ply 								; and complete
.8f0a		60		rts				rts
.8f0b						_LPVString:
.8f0b		20 90 b6	jsr $b690			jsr 	StackPopByte 				; address of record copied to zTemp0
.8f0e		85 37		sta $37				sta 	zTemp0+1
.8f10		20 90 b6	jsr $b690			jsr 	StackPopByte
.8f13		85 36		sta $36				sta 	zTemp0
.8f15		5a		phy				phy
.8f16		b2 36		lda ($36)			lda 	(zTemp0) 					; address to write string to copied to zTemp1
.8f18		85 38		sta $38				sta 	zTemp1
.8f1a		a0 01		ldy #$01			ldy 	#1
.8f1c		b1 36		lda ($36),y			lda 	(zTemp0),y
.8f1e		85 39		sta $39				sta 	zTemp1+1
.8f20		20 90 b6	jsr $b690			jsr 	StackPopByte 				; # chars to get => y
.8f23		a8		tay				tay
.8f24		a5 39		lda $39				lda 	zTemp1+1 					; if no target (e.g. was "" originally) exit
.8f26		f0 0e		beq $8f36			beq 	_LPVStringCopied
.8f28		a9 00		lda #$00			lda 	#0 							; NULL on end
.8f2a		91 38		sta ($38),y			sta 	(zTemp1),y
.8f2c						_LPVStringCopy:
.8f2c		88		dey				dey
.8f2d		30 07		bmi $8f36			bmi 	_LPVStringCopied
.8f2f		20 90 b6	jsr $b690			jsr 	StackPopByte
.8f32		91 38		sta ($38),y			sta 	(zTemp1),y
.8f34		80 f6		bra $8f2c			bra 	_LPVStringCopy
.8f36						_LPVStringCopied:
.8f36		fa		plx				plx
.8f37		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/new.asm

.8f38						NewCommand:
.8f38		20 a0 88	jsr $88a0			jsr		IsDestructiveActionOK
.8f3b		b0 03		bcs $8f40			bcs		_not_ok
.8f3d		20 43 8f	jsr $8f43			jsr 	NewProgram 					; does the actual NEW.
.8f40						_not_ok:
.8f40		4c 12 89	jmp $8912			jmp 	WarmStart 					; and warm starts straight away.
.8f43						NewProgram:
.8f43		20 c3 a8	jsr $a8c3			jsr 	MemoryNew
.8f46		9c 00 10	stz $1000			stz 	VariableSpace 				; erase all variables.
.8f49		20 a5 93	jsr $93a5			jsr 	ClearSystem					; clear everything.
.8f4c		9c 75 06	stz $0675			stz		programChanged
.8f4f		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/option.asm

.8f50						OptionCommand:
.8f50		a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.8f52		20 1d a4	jsr $a41d			jsr		Evaluate8BitInteger 		; address
.8f55		48		pha				pha
.8f56		20 08 95	jsr $9508			jsr 	CheckComma
.8f59		e8		inx				inx
.8f5a		20 1d a4	jsr $a41d			jsr		Evaluate8BitInteger 		; data
.8f5d		fa		plx				plx
.8f5e		9d 00 04	sta $0400,x			sta 	ControlStorage,x
.8f61		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/poke.asm

.8f62						PokeBCommand:
.8f62		a9 01		lda #$01			lda 	#1
.8f64		80 0c		bra $8f72			bra 	PokeCommand
.8f66						PokeWCommand:
.8f66		a9 02		lda #$02			lda 	#2
.8f68		80 08		bra $8f72			bra 	PokeCommand
.8f6a						PokeLCommand:
.8f6a		a9 03		lda #$03			lda 	#3
.8f6c		80 04		bra $8f72			bra 	PokeCommand
.8f6e						PokeDCommand:
.8f6e		a9 04		lda #$04			lda 	#4
.8f70		80 00		bra $8f72			bra 	PokeCommand
.8f72						PokeCommand:
.8f72		48		pha				pha 								; save count on stack
.8f73		a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.8f75		20 02 a4	jsr $a402			jsr		Evaluate16BitInteger 		; address
.8f78		20 08 95	jsr $9508			jsr 	CheckComma
.8f7b		e8		inx				inx
.8f7c		20 ef a3	jsr $a3ef			jsr		EvaluateInteger 			; data
.8f7f		a5 60		lda $60				lda 	NSMantissa0 				; copy address
.8f81		85 36		sta $36				sta 	zTemp0
.8f83		a5 70		lda $70				lda 	NSMantissa1
.8f85		85 37		sta $37				sta 	zTemp0+1
.8f87		68		pla				pla 								; count -> zTemp1
.8f88		85 38		sta $38				sta 	zTemp1
.8f8a		5a		phy				phy 								; save Y position.
.8f8b		a0 00		ldy #$00			ldy 	#0 							; index to write
.8f8d		a2 00		ldx #$00			ldx 	#0 							; index to read
.8f8f						_PCLoop:
.8f8f		b5 61		lda $61,x			lda 	NSMantissa0+1,x 			; read byte from mantissa and copy out
.8f91		91 36		sta ($36),y			sta 	(zTemp0),y
.8f93		c8		iny				iny 								; next byte to write
.8f94		8a		txa				txa 								; next byte to read - stack layout in 04data.inc
.8f95		18		clc				clc
.8f96		69 10		adc #$10			adc 	#MathStackSize
.8f98		aa		tax				tax
.8f99		c6 38		dec $38				dec 	zTemp1 						; done them all
.8f9b		d0 f2		bne $8f8f			bne 	_PCLoop
.8f9d		7a		ply				ply 								; restore position.
.8f9e		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/procedure.asm

=2						ParameterStackPos = 2
.8f9f						CallProcedure:
.8f9f		a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start storing parameters at 2.
.8fa1		b1 30		lda ($30),y			lda 	(codePtr),y
.8fa3		c9 29		cmp #$29			cmp 	#KWD_RPAREN
.8fa5		f0 10		beq $8fb7			beq 	_CPEndParam
.8fa7						_CPParamLoop:
.8fa7		20 c7 a3	jsr $a3c7			jsr 	EvaluateValue 				; get parameter onto stack
.8faa		e8		inx				inx 								; bump next stack
.8fab		e0 10		cpx #$10			cpx		#MathStackSize				; check if parameters overflow stack
.8fad		b0 52		bcs $9001			bge		_TooManyParam
.8faf		b1 30		lda ($30),y			lda 	(codePtr),y
.8fb1		c8		iny				iny
.8fb2		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if comma, go back and try again.
.8fb4		f0 f1		beq $8fa7			beq 	_CPParamLoop
.8fb6		88		dey				dey 								; unpick.
.8fb7						_CPEndParam:
.8fb7		8e 32 04	stx $0432			stx 	lastParameter 				; save the last parameters index.
.8fba		c8		iny				iny									; skip right bracket
.8fbb		a9 b3		lda #$b3			lda 	#STK_PROC+3 				; allocate 6 bytes on the return stack.
.8fbd		20 99 b6	jsr $b699			jsr 	StackOpen
.8fc0		20 de b6	jsr $b6de			jsr 	STKSaveCodePosition 		; save loop position
.8fc3		a5 60		lda $60				lda 	NSMantissa0 				; copy variable (e.g. procedure) address to zTemp0
.8fc5		85 36		sta $36				sta 	zTemp0 						; this is the DATA not the RECORD
.8fc7		a5 70		lda $70				lda 	NSMantissa1
.8fc9		85 37		sta $37				sta 	zTemp0+1
.8fcb		a0 01		ldy #$01			ldy 	#1 							; copy code address back.
.8fcd		b2 36		lda ($36)			lda 	(zTemp0)
.8fcf		85 30		sta $30				sta 	safePtr
.8fd1		b1 36		lda ($36),y			lda 	(zTemp0),y
.8fd3		85 31		sta $31				sta 	safePtr+1
.8fd5		c8		iny				iny
.8fd6		b1 36		lda ($36),y			lda 	(zTemp0),y
.8fd8		85 32		sta $32				sta 	safePtr+2
.8fda		c8		iny				iny
.8fdb		b1 36		lda ($36),y			lda 	(zTemp0),y
.8fdd		85 33		sta $33				sta 	safePtr+3
.8fdf		c8		iny				iny 								; get Y offset -> Y
.8fe0		b1 36		lda ($36),y			lda 	(zTemp0),y
.8fe2		a8		tay				tay
.8fe3		a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start position of parameters
.8fe5		ec 32 04	cpx $0432			cpx	 	lastParameter 				; check zero parameters at the start
.8fe8		f0 13		beq $8ffd			beq 	_ParamExit 					; if so, exit.
.8fea						_ParamExtract:
.8fea		ca		dex				dex 								; put a local term on the level before
.8feb		20 85 8e	jsr $8e85			jsr 	LocaliseNextTerm			; also pushes original param value to basic stack
.8fee		20 4d 8d	jsr $8d4d			jsr 	AssignVariable 				; assign stacked value to the variable.
.8ff1		e8		inx				inx 								; advance to next parameter to do.
.8ff2		e8		inx				inx
.8ff3		ec 32 04	cpx $0432			cpx 	lastParameter 				; are we done ?
.8ff6		f0 05		beq $8ffd			beq 	_ParamExit
.8ff8		20 08 95	jsr $9508			jsr 	CheckComma 					; comma seperating parameters
.8ffb		80 ed		bra $8fea			bra 	_ParamExtract
.8ffd						_ParamExit:
.8ffd		20 00 95	jsr $9500			jsr 	CheckRightBracket 			; check )
.9000		60		rts				rts 								; and continue from here
.9001						_TooManyParam:
.9001								error
.9001		a9 1d		lda #$1d		lda	#29
.9003		4c 19 95	jmp $9519		jmp	ErrorHandler
.9006						Command_ENDPROC:
.9006		a9 b0		lda #$b0			lda 	#STK_PROC 					; check TOS is this
.9008		a2 14		ldx #$14			ldx 	#ERRID_PROC
.900a		20 c6 b6	jsr $b6c6			jsr 	StackCheckFrame
.900d		20 ef b6	jsr $b6ef			jsr 	STKLoadCodePosition 		; restore code position
.9010		20 b8 b6	jsr $b6b8			jsr 	StackClose
.9013		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/read.asm

.9014						Command_Read:
.9014		a2 00		ldx #$00			ldx 	#0 							; evaluate the term which is the var/array element to assign
.9016		20 76 9e	jsr $9e76			jsr 	EvaluateTerm
.9019		b5 50		lda $50,x			lda 	NSStatus,x
.901b		29 20		and #$20			and 	#NSBIsReference				; get status byte on stack, identifies int, float, string.
.901d		f0 4f		beq $906e			beq 	_CRSyntax 					; check reference (bit 0) fail if not a reference.
.901f		20 b7 90	jsr $90b7			jsr 	SwapDataCodePtrs 			; swap code and data
.9022		ad 38 04	lda $0438			lda 	inDataStatement 			; if in a data statement, we don't need to search
.9025		d0 25		bne $904c			bne 	_CRContinueData  			; forward for the next one.
.9027		b2 30		lda ($30)			lda 	(codePtr)
.9029		f0 1c		beq $9047			beq 	_CRNoData
.902b						_CRKeepSearching:
.902b		a9 c0		lda #$c0			lda 	#KWD_DATA 					; scan for instruction
.902d		a2 80		ldx #$80			ldx 	#KWC_EOL
.902f		20 5b 94	jsr $945b			jsr 	ScanForward
.9032		c9 c0		cmp #$c0			cmp 	#KWD_DATA 					; found data ?
.9034		f0 16		beq $904c			beq 	_CRHaveData 				; found it
.9036		18		clc				clc
.9037		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.9039		65 30		adc $30				adc 	codePtr
.903b		85 30		sta $30				sta 	codePtr
.903d		90 02		bcc $9041			bcc 	_CREExit
.903f		e6 31		inc $31				inc 	codePtr+1 					; carry
.9041						_CREExit:
.9041		a0 03		ldy #$03			ldy 	#3 							; start of line.
.9043		b2 30		lda ($30)			lda 	(codePtr)
.9045		d0 e4		bne $902b			bne 	_CRKeepSearching
.9047						_CRNoData:
.9047		a9 0b		lda #$0b		lda	#11
.9049		4c 19 95	jmp $9519		jmp	ErrorHandler
.904c						_CRHaveData:
.904c						_CRContinueData:
.904c		a2 01		ldx #$01			ldx 	#1
.904e		20 c7 a3	jsr $a3c7			jsr 	EvaluateValue 				; evaluate value into slot # 1
.9051		ca		dex				dex
.9052		20 4d 8d	jsr $8d4d			jsr		AssignVariable 				; do the assignment
.9055		9c 38 04	stz $0438			stz 	inDataStatement 			; clear in data flag
.9058		b1 30		lda ($30),y			lda 	(codePtr),y
.905a		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not, end of data statement and exit
.905c		d0 04		bne $9062			bne 	_CRSwapBack
.905e		c8		iny				iny 								; consume comma
.905f		ee 38 04	inc $0438			inc 	inDataStatement 			; set in data statement currently.
.9062						_CRSwapBack:
.9062		20 b7 90	jsr $90b7			jsr 	SwapDataCodePtrs			; swap them back.
.9065		b1 30		lda ($30),y			lda 	(codePtr),y
.9067		c8		iny				iny
.9068		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.906a		f0 a8		beq $9014			beq 	Command_Read 				; if so go round again.
.906c		88		dey				dey 								; unpick get.
.906d		60		rts				rts
.906e						_CRSyntax:
.906e		4c fa a5	jmp $a5fa			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/rem.asm

.9071						RemCommand:
.9071		b1 30		lda ($30),y			lda 	(codePtr),y
.9073		c9 ff		cmp #$ff			cmp 	#KWC_STRING
.9075		d0 06		bne $907d			bne 	_RMExit
.9077		c8		iny				iny 								; point to offset
.9078		98		tya				tya 								; A = offset position
.9079		38		sec				sec 								; add size +1 hence SEC
.907a		71 30		adc ($30),y			adc 	(codePtr),y
.907c		a8		tay				tay 								; make current position.
.907d						_RMExit:
.907d		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/repeat.asm

.907e						Command_REPEAT:
.907e		a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; allocate 6 bytes on the return stack.
.9080		20 99 b6	jsr $b699			jsr 	StackOpen
.9083		20 de b6	jsr $b6de			jsr 	STKSaveCodePosition 		; save loop position
.9086		60		rts				rts
.9087						Command_UNTIL:
.9087		a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; check REPEAT is TOS
.9089		a2 0f		ldx #$0f			ldx 	#ERRID_REPEAT 				; this error
.908b		20 c6 b6	jsr $b6c6			jsr 	StackCheckFrame
.908e		a2 00		ldx #$00			ldx 	#0
.9090		20 d0 a3	jsr $a3d0			jsr 	EvaluateNumber 				; work out the number
.9093		20 a4 a4	jsr $a4a4			jsr 	NSMIsZero 					; check if zero
.9096		f0 04		beq $909c			beq 	_CULoopBack 				; if so keep looping
.9098		20 b8 b6	jsr $b6b8			jsr 	StackClose		 			; return
.909b		60		rts				rts
.909c						_CULoopBack:
.909c		20 ef b6	jsr $b6ef			jsr 	STKLoadCodePosition 		; loop back
.909f		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/restore.asm

.90a0						Command_Restore:
.90a0		20 b7 90	jsr $90b7			jsr 	SwapDataCodePtrs 			; swap code and data
.90a3		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.90a5		85 30		sta $30				sta 	codePtr
.90a7		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.90a9		85 31		sta $31				sta 	codePtr+1
.90ab		20 b7 90	jsr $90b7			jsr 	SwapDataCodePtrs 			; put them back
.90ae		a9 03		lda #$03			lda 	#3 							; start at offset 3, e.g. first instruction of first line.
.90b0		8d 37 04	sta $0437			sta 	dataPointer+4   			; (read checks not EOF)
.90b3		9c 38 04	stz $0438			stz 	inDataStatement 			; not in data statement
.90b6		60		rts				rts
.90b7						SwapDataCodePtrs:
.90b7		da		phx				phx
.90b8		a2 03		ldx #$03			ldx 	#3 							; swap 32 bit code pointer over
.90ba						_SDCPLoop:
.90ba		b5 30		lda $30,x			lda 	safePtr,x
.90bc		48		pha				pha
.90bd		bd 33 04	lda $0433,x			lda 	dataPointer,x
.90c0		95 30		sta $30,x			sta 	safePtr,x
.90c2		68		pla				pla
.90c3		9d 33 04	sta $0433,x			sta 	dataPointer,x
.90c6		ca		dex				dex
.90c7		10 f1		bpl $90ba			bpl 	_SDCPLoop
.90c9		ad 37 04	lda $0437			lda 	dataPointer+4 				; swap Y position over.
.90cc		8c 37 04	sty $0437			sty 	dataPointer+4
.90cf		a8		tay				tay
.90d0		fa		plx				plx
.90d1		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/run.asm

.90d2						EOLCommand:
.90d2		18		clc				clc
.90d3		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.90d5		65 30		adc $30				adc 	codePtr
.90d7		85 30		sta $30				sta 	codePtr
.90d9		90 02		bcc $90dd			bcc 	_CREExit
.90db		e6 31		inc $31				inc 	codePtr+1 					; carry
.90dd						_CREExit:
.90dd		80 18		bra $90f7			bra 	RunNewLine
.90df						CommandRUNOptLoad:
.90df		b1 30		lda ($30),y			lda 	(codePtr),y
.90e1		c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL / : just RUN
.90e3		f0 07		beq $90ec			beq 	RunCurrentProgram
.90e5		c9 3a		cmp #$3a			cmp 	#KWD_COLON
.90e7		f0 03		beq $90ec			beq 	RunCurrentProgram
.90e9		20 3f b0	jsr $b03f			jsr 	LoadFile 					; load expected name file.
.90ec						RunCurrentProgram:
.90ec		20 a5 93	jsr $93a5			jsr 	ClearSystem 				; clear variable/stacks/etc.
.90ef		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.90f1		85 30		sta $30				sta 	codePtr
.90f3		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.90f5		85 31		sta $31				sta 	codePtr+1
.90f7						RunNewLine:
.90f7		b2 30		lda ($30)			lda 	(codePtr)
.90f9		f0 74		beq $916f			beq 	CRNoProgram         		; no then END.
.90fb		a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack
.90fd		9a		txs				txs
.90fe						RUNCodePointerLine:
.90fe		a0 02		ldy #$02			ldy 	#2 							; start of program
.9100						_CRIncMainLoop:
.9100		a5 f2		lda $f2				lda 	kernel.args.events.pending 	; load pending event count into accumulator
.9102		f0 03		beq $9107			beq 	_NoEvents					; if zero, skip with Z flag set.
.9104		20 58 81	jsr $8158			jsr 	ProcessEvents
.9107						_NoEvents:
.9107		d0 61		bne $916a			bne 	_CRBreak
.9109		a5 01		lda $01				lda 	1 							; save I/O 0
.910b		48		pha				pha
.910c		64 01		stz $01				stz 	1 							; access I/O Page 0
.910e		38		sec				sec 								; calculate timer - LastTick
.910f		ad 59 d6	lda $d659			lda 	$D659
.9112		cd 81 06	cmp $0681			cmp 	LastTick
.9115		f0 06		beq $911d			beq 	_NoFireTick 				; if < 3 clocks don't fire.
.9117		8d 81 06	sta $0681			sta 	LastTick 					; update last timer
.911a		20 ee 82	jsr $82ee			jsr 	TickHandler 							; go do the code.
.911d						_NoFireTick:
.911d		68		pla				pla 								; restore I/O 0
.911e		85 01		sta $01				sta 	1
.9120						_CRNoBreakCheck:
.9120		c8		iny				iny									; next token
.9121						_CRMainLoop:
.9121		9c 2c 04	stz $042c			stz 	stringInitialised 			; clear the temporary string initialised flag.
.9124		b1 30		lda ($30),y			lda 	(codePtr),y
.9126		10 10		bpl $9138			bpl 	_CRNotKeyword				; not a token.
.9128		c9 ae		cmp #$ae			cmp 	#KWC_LAST_UNARY+1 			; if after unary, legitimate command
.912a		b0 04		bcs $9130			bcs 	_CRIsKeyword
.912c		c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if unary, syntax error.
.912e		b0 34		bcs $9164			bcs		_CRSyntaxError
.9130						_CRIsKeyword:
.9130		c8		iny				iny 								; consume command
.9131		0a		asl a				asl 	a 							; double losing the MSB which is '1' as tokens are $80-$FF
.9132		aa		tax				tax 								; put in X for vector jump
.9133		20 67 91	jsr $9167			jsr 	_CRCallVector0 				; call the vector - effectively jsr (vectortable,X)
.9136		80 e9		bra $9121			bra 	_CRMainLoop 				; and loop round
.9138						_CRNotKeyword:
.9138		c9 3a		cmp #$3a			cmp 	#KWD_COLON 					; if a :, consume it and go round.
.913a		f0 c4		beq $9100			beq 	_CRIncMainLoop
.913c		c9 40		cmp #$40			cmp 	#$40 						; variable/call reference
.913e		90 05		bcc $9145			bcc 	_CRNotVariable
.9140						_CRGoLet:
.9140		20 14 8d	jsr $8d14			jsr 	LetCommand
.9143		80 dc		bra $9121			bra 	_CRMainLoop
.9145						_CRNotVariable:
.9145		c9 10		cmp #$10			cmp 	#KWD_ATCH 					; handle @
.9147		f0 f7		beq $9140			beq 	_CRGoLet
.9149		c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; handle ? !
.914b		f0 f3		beq $9140			beq 	_CRGoLet
.914d		c9 21		cmp #$21			cmp 	#KWD_PLING
.914f		f0 ef		beq $9140			beq 	_CRGoLet
.9151		c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; handle ' (comment)
.9153		f0 09		beq $915e			beq 	_CRGoRem
.9155		c9 2e		cmp #$2e			cmp 	#KWD_PERIOD 				; handle . (assembler label)
.9157		d0 0b		bne $9164			bne 	_CRSyntaxError
.9159		20 d0 86	jsr $86d0			jsr 	LabelHere
.915c		80 c3		bra $9121			bra 	_CRMainLoop
.915e						_CRGoRem:
.915e		c8		iny				iny
.915f		20 71 90	jsr $9071			jsr 	RemCommand
.9162		80 bd		bra $9121			bra 	_CRMainLoop
.9164						_CRSyntaxError:
.9164		4c fa a5	jmp $a5fa			jmp 	SyntaxError
.9167						_CRCallVector0:
.9167		7c 06 92	jmp ($9206,x)			jmp 	(VectorSet0,x)
.916a						_CRBreak:
.916a		a9 01		lda #$01		lda	#1
.916c		4c 19 95	jmp $9519		jmp	ErrorHandler
.916f						CRNoProgram:
.916f		4c 7b 8a	jmp $8a7b			jmp 	EndCommand
.9172						Shift1Command:
.9172		b1 30		lda ($30),y			lda 	(codePtr),y
.9174		c8		iny				iny
.9175		0a		asl a				asl 	a
.9176		aa		tax				tax
.9177		7c c0 92	jmp ($92c0,x)			jmp 	(VectorSet1,x)
.917a						Shift2Command:
.917a		b1 30		lda ($30),y			lda 	(codePtr),y
.917c		c8		iny				iny
.917d		0a		asl a				asl 	a
.917e		aa		tax				tax
.917f		7c 18 93	jmp ($9318,x)			jmp 	(VectorSet2,x)
.9182						Unused1:
.9182						Unused2:
.9182						Unused3:
.9182						Unused4:
.9182		4c fa a5	jmp $a5fa			jmp 	SyntaxError
>9185								.align 2

;******  Processing file: ./common/commands/../generated/vectors.dat

.9186						VectorSetPunc:
>9186		d7 97					.word	ShiftLeft                        ; $00 <<
>9188		c2 95					.word	BinaryCompareLessEqual           ; $01 <=
>918a		b8 95					.word	BinaryCompareNotEqual            ; $02 <>
>918c		fa a5					.word	SyntaxError                      ; $03 !!3
>918e		fa a5					.word	SyntaxError                      ; $04 ><
>9190		cc 95					.word	BinaryCompareGreaterEqual        ; $05 >=
>9192		da 97					.word	ShiftRight                       ; $06 >>
>9194		fa a5					.word	SyntaxError                      ; $07 !!7
>9196		fa a5					.word	SyntaxError                      ; $08 !!8
>9198		fa a5					.word	SyntaxError                      ; $09 !!9
>919a		fa a5					.word	SyntaxError                      ; $0a !!10
>919c		fa a5					.word	SyntaxError                      ; $0b !!11
>919e		fa a5					.word	SyntaxError                      ; $0c !!12
>91a0		fa a5					.word	SyntaxError                      ; $0d !!13
>91a2		fa a5					.word	SyntaxError                      ; $0e !!14
>91a4		fa a5					.word	SyntaxError                      ; $0f !!15
>91a6		fa a5					.word	SyntaxError                      ; $10 @
>91a8		fa a5					.word	SyntaxError                      ; $11 !!17
>91aa		fa a5					.word	SyntaxError                      ; $12 !!18
>91ac		fa a5					.word	SyntaxError                      ; $13 [
>91ae		83 96					.word	IntegerDivide                    ; $14 \
>91b0		fa a5					.word	SyntaxError                      ; $15 ]
>91b2		15 99					.word	EorInteger                       ; $16 ^
>91b4		fa a5					.word	SyntaxError                      ; $17 _
>91b6		fa a5					.word	SyntaxError                      ; $18 `
>91b8		fa a5					.word	SyntaxError                      ; $19 !!25
>91ba		fa a5					.word	SyntaxError                      ; $1a !!26
>91bc		fa a5					.word	SyntaxError                      ; $1b {
>91be		e0 98					.word	OraInteger                       ; $1c |
>91c0		fa a5					.word	SyntaxError                      ; $1d }
>91c2		fa a5					.word	SyntaxError                      ; $1e ~
>91c4		fa a5					.word	SyntaxError                      ; $1f <7F>
>91c6		fa a5					.word	SyntaxError                      ; $20
>91c8		4a 99					.word	WordIndirect                     ; $21 !
>91ca		fa a5					.word	SyntaxError                      ; $22 "
>91cc		fa a5					.word	SyntaxError                      ; $23 #
>91ce		fa a5					.word	SyntaxError                      ; $24 $
>91d0		c4 96					.word	IntegerModulus                   ; $25 %
>91d2		ab 98					.word	AndInteger                       ; $26 &
>91d4		fa a5					.word	SyntaxError                      ; $27 '
>91d6		fa a5					.word	SyntaxError                      ; $28 (
>91d8		fa a5					.word	SyntaxError                      ; $29 )
>91da		32 97					.word	MulInteger                       ; $2a *
>91dc		4d 98					.word	AddInteger                       ; $2b +
>91de		fa a5					.word	SyntaxError                      ; $2c ,
>91e0		86 98					.word	SubInteger                       ; $2d -
>91e2		fa a5					.word	SyntaxError                      ; $2e .
>91e4		0d 9b					.word	FDivideCommand                   ; $2f /
>91e6		fa a5					.word	SyntaxError                      ; $30 0
>91e8		fa a5					.word	SyntaxError                      ; $31 1
>91ea		fa a5					.word	SyntaxError                      ; $32 2
>91ec		fa a5					.word	SyntaxError                      ; $33 3
>91ee		fa a5					.word	SyntaxError                      ; $34 4
>91f0		fa a5					.word	SyntaxError                      ; $35 5
>91f2		fa a5					.word	SyntaxError                      ; $36 6
>91f4		fa a5					.word	SyntaxError                      ; $37 7
>91f6		fa a5					.word	SyntaxError                      ; $38 8
>91f8		fa a5					.word	SyntaxError                      ; $39 9
>91fa		fa a5					.word	SyntaxError                      ; $3a :
>91fc		fa a5					.word	SyntaxError                      ; $3b ;
>91fe		a4 95					.word	BinaryCompareLess                ; $3c <
>9200		9a 95					.word	BinaryCompareEqual               ; $3d =
>9202		ae 95					.word	BinaryCompareGreater             ; $3e >
>9204		6c 99					.word	ByteIndirect                     ; $3f ?
.9206						VectorSet0:
>9206		d2 90					.word	EOLCommand                       ; $80 !0:EOF
>9208		72 91					.word	Shift1Command                    ; $81 !1:SH1
>920a		7a 91					.word	Shift2Command                    ; $82 !2:SH2
>920c		f7 9f					.word	AbsUnary                         ; $83 ABS(
>920e		05 a0					.word	AllocUnary                       ; $84 ALLOC(
>9210		75 a0					.word	AscUnary                         ; $85 ASC(
>9212		c6 a1					.word	ChrUnary                         ; $86 CHR$(
>9214		d1 ad					.word	UnaryEvent                       ; $87 EVENT(
>9216		96 95					.word	UnaryFalse                       ; $88 FALSE
>9218		82 a0					.word	FracUnary                        ; $89 FRAC(
>921a		f7 b4					.word	ChrGet                           ; $8a GET$(
>921c		dc b4					.word	AscGet                           ; $8b GET(
>921e		86 b4					.word	UnaryGetDate                     ; $8c GETDATE$(
>9220		82 b4					.word	UnaryGetTime                     ; $8d GETTIME$(
>9222		2a ac					.word	UnaryHit                         ; $8e HIT(
>9224		fe b4					.word	ChrInkey                         ; $8f INKEY$(
>9226		ec b4					.word	AscInkey                         ; $90 INKEY(
>9228		97 a0					.word	IntUnary                         ; $91 INT(
>922a		85 a1					.word	IsValUnary                       ; $92 ISVAL(
>922c		d8 a1					.word	ItemCountUnary                   ; $93 ITEMCOUNT(
>922e		fc a1					.word	ItemGetUnary                     ; $94 ITEMGET$(
>9230		59 b2					.word	UnaryJoyB                        ; $95 JOYB(
>9232		32 b2					.word	UnaryJoyX                        ; $96 JOYX(
>9234		35 b2					.word	UnaryJoyY                        ; $97 JOYY(
>9236		17 b5					.word	KeyDown                          ; $98 KEYDOWN(
>9238		3b a3					.word	Unary_Left                       ; $99 LEFT$(
>923a		a8 a0					.word	LenUnary                         ; $9a LEN(
>923c		c6 a0					.word	Unary_Max                        ; $9b MAX(
>923e		5d a3					.word	Unary_Mid                        ; $9c MID$(
>9240		c2 a0					.word	Unary_Min                        ; $9d MIN(
>9242		11 a1					.word	Unary_Not                        ; $9e NOT(
>9244		24 a1					.word	PeekByteUnary                    ; $9f PEEK(
>9246		30 a1					.word	PeekDUnary                       ; $a0 PEEKD(
>9248		2c a1					.word	PeekLUnary                       ; $a1 PEEKL(
>924a		28 a1					.word	PeekWUnary                       ; $a2 PEEKW(
>924c		f6 b5					.word	UnaryPlaying                     ; $a3 PLAYING(
>924e		31 b5					.word	Unary_Random                     ; $a4 RANDOM(
>9250		48 a3					.word	Unary_Right                      ; $a5 RIGHT$(
>9252		4b b5					.word	Unary_Rnd                        ; $a6 RND(
>9254		5d a1					.word	SgnUnary                         ; $a7 SGN(
>9256		7a a2					.word	SpcUnary                         ; $a8 SPC(
>9258		95 a2					.word	Unary_Str                        ; $a9 STR$(
>925a		09 ad					.word	TileRead                         ; $aa TILE(
>925c		69 b4					.word	UnaryTimer                       ; $ab TIMER(
>925e		8b 95					.word	UnaryTrue                        ; $ac TRUE
>9260		7b a1					.word	ValUnary                         ; $ad VAL(
>9262		7e 8a					.word	ForCommand                       ; $ae FOR
>9264		c1 8b					.word	IfCommand                        ; $af IF
>9266		82 91					.word	Unused1                          ; $b0 PROC
>9268		7e 90					.word	Command_REPEAT                   ; $b1 REPEAT
>926a		d1 94					.word	Command_WHILE                    ; $b2 WHILE
>926c		ea 8b					.word	EndIf                            ; $b3 ENDIF
>926e		06 90					.word	Command_ENDPROC                  ; $b4 ENDPROC
>9270		30 8b					.word	NextCommand                      ; $b5 NEXT
>9272		82 91					.word	Unused4                          ; $b6 THEN
>9274		87 90					.word	Command_UNTIL                    ; $b7 UNTIL
>9276		f2 94					.word	Command_WEND                     ; $b8 WEND
>9278		fa a5					.word	SyntaxError                      ; $b9 AT
>927a		fa a5					.word	SyntaxError                      ; $ba BY
>927c		81 89					.word	CallCommand                      ; $bb CALL
>927e		18 a9					.word	CircleCommand                    ; $bc CIRCLE
>9280		fa a5					.word	SyntaxError                      ; $bd CLEAR
>9282		fa a5					.word	SyntaxError                      ; $be COLOR
>9284		fa a5					.word	SyntaxError                      ; $bf COLOUR
>9286		b6 89					.word	Command_Data                     ; $c0 DATA
>9288		be 89					.word	DimCommand                       ; $c1 DIM
>928a		82 91					.word	Unused3                          ; $c2 DOWNTO
>928c		e3 8b					.word	ElseCode                         ; $c3 ELSE
>928e		fa a5					.word	SyntaxError                      ; $c4 FROM
>9290		fd ab					.word	GfxCommand                       ; $c5 GFX
>9292		fa a5					.word	SyntaxError                      ; $c6 HERE
>9294		41 a9					.word	ImageCommand                     ; $c7 IMAGE
>9296		14 8d					.word	LetCommand                       ; $c8 LET
>9298		93 a9					.word	LineCommand                      ; $c9 LINE
>929a		77 8e					.word	Command_LOCAL                    ; $ca LOCAL
>929c		6b b2					.word	MCCommand                        ; $cb MEMCOPY
>929e		fa a5					.word	SyntaxError                      ; $cc OFF
>92a0		fa a5					.word	SyntaxError                      ; $cd ON
>92a2		fa a5					.word	SyntaxError                      ; $ce OUTLINE
>92a4		4e ac					.word	PaletteCommand                   ; $cf PALETTE
>92a6		8c a9					.word	PlotCommand                      ; $d0 PLOT
>92a8		62 8f					.word	PokeBCommand                     ; $d1 POKE
>92aa		6e 8f					.word	PokeDCommand                     ; $d2 POKED
>92ac		6a 8f					.word	PokeLCommand                     ; $d3 POKEL
>92ae		66 8f					.word	PokeWCommand                     ; $d4 POKEW
>92b0		14 90					.word	Command_Read                     ; $d5 READ
>92b2		14 a9					.word	RectangleCommand                 ; $d6 RECT
>92b4		71 90					.word	RemCommand                       ; $d7 REM
>92b6		fa a5					.word	SyntaxError                      ; $d8 SOLID
>92b8		12 b6					.word	SoundCommand                     ; $d9 SOUND
>92ba		23 a9					.word	SpriteCommand                    ; $da SPRITE
>92bc		5d a9					.word	TextCommand                      ; $db TEXT
>92be		82 91					.word	Unused2                          ; $dc TO
.92c0						VectorSet1:
>92c0		fa a5					.word	SyntaxError                      ; $80 !0:EOF
>92c2		fa a5					.word	SyntaxError                      ; $81 !1:SH1
>92c4		fa a5					.word	SyntaxError                      ; $82 !2:SH2
>92c6		55 89					.word	AssembleCommand                  ; $83 ASSEMBLE
>92c8		71 89					.word	AssertCommand                    ; $84 ASSERT
>92ca		ee aa					.word	BitmapCtrl                       ; $85 BITMAP
>92cc		2e ae					.word	Command_BLoad                    ; $86 BLOAD
>92ce		da ae					.word	Command_BSave                    ; $87 BSAVE
>92d0		24 ad					.word	ClearScreen                      ; $88 CLS
>92d2		f0 8b					.word	Command_CPrint                   ; $89 CPRINT
>92d4		2c ad					.word	CursorControl                    ; $8a CURSOR
>92d6		5d af					.word	Command_Dir                      ; $8b DIR
>92d8		2d b0					.word	Command_Drive                    ; $8c DRIVE
>92da		7b 8a					.word	EndCommand                       ; $8d END
>92dc		ca b5					.word	Explode                          ; $8e EXPLODE
>92de		fa a5					.word	SyntaxError                      ; $8f GO
>92e0		89 8b					.word	Command_GOSUB                    ; $90 GOSUB
>92e2		a7 8b					.word	GotoCommand                      ; $91 GOTO
>92e4		fa a5					.word	SyntaxError                      ; $92 HIMEM
>92e6		eb 8b					.word	Command_Input                    ; $93 INPUT
>92e8		64 8d					.word	Command_List                     ; $94 LIST
>92ea		34 b0					.word	Command_Load                     ; $95 LOAD
>92ec		7f b3					.word	MouseDeltaStatus                 ; $96 MDELTA
>92ee		7b b3					.word	MouseStatus                      ; $97 MOUSE
>92f0		38 8f					.word	NewCommand                       ; $98 NEW
>92f2		50 8f					.word	OptionCommand                    ; $99 OPTION
>92f4		a6 b5					.word	PingCommand                      ; $9a PING
>92f6		f7 8b					.word	Command_Print                    ; $9b PRINT
>92f8		a0 90					.word	Command_Restore                  ; $9c RESTORE
>92fa		99 8b					.word	Command_RETURN                   ; $9d RETURN
>92fc		df 90					.word	CommandRUNOptLoad                ; $9e RUN
>92fe		0b b1					.word	Command_Save                     ; $9f SAVE
>9300		f5 b3					.word	CommandSetDate                   ; $a0 SETDATE
>9302		f9 b3					.word	CommandSetTime                   ; $a1 SETTIME
>9304		be b5					.word	ShootCommand                     ; $a2 SHOOT
>9306		48 ab					.word	SpritesCtrl                      ; $a3 SPRITES
>9308		a0 93					.word	StopCommand                      ; $a4 STOP
>930a		8e ac					.word	TileCommand                      ; $a5 TILE
>930c		70 ab					.word	TilesCtrl                        ; $a6 TILES
>930e		95 b1					.word	Command_Try                      ; $a7 TRY
>9310		d2 b1					.word	Command_VERIFY                   ; $a8 VERIFY
>9312		5b ad					.word	XGoCommand                       ; $a9 XGO
>9314		52 ad					.word	XLoadCommand                     ; $aa XLOAD
>9316		b2 b5					.word	ZapCommand                       ; $ab ZAP
.9318						VectorSet2:
>9318		fa a5					.word	SyntaxError                      ; $80 !0:EOF
>931a		fa a5					.word	SyntaxError                      ; $81 !1:SH1
>931c		fa a5					.word	SyntaxError                      ; $82 !2:SH2
>931e		b9 a4					.word	Assemble_adc                     ; $83 ADC
>9320		b1 a4					.word	Assemble_and                     ; $84 AND
>9322		cd a4					.word	Assemble_asl                     ; $85 ASL
>9324		37 a5					.word	Assemble_bcc                     ; $86 BCC
>9326		3b a5					.word	Assemble_bcs                     ; $87 BCS
>9328		43 a5					.word	Assemble_beq                     ; $88 BEQ
>932a		fa a4					.word	Assemble_bit                     ; $89 BIT
>932c		2b a5					.word	Assemble_bmi                     ; $8a BMI
>932e		3f a5					.word	Assemble_bne                     ; $8b BNE
>9330		27 a5					.word	Assemble_bpl                     ; $8c BPL
>9332		47 a5					.word	Assemble_bra                     ; $8d BRA
>9334		4b a5					.word	Assemble_brk                     ; $8e BRK
>9336		2f a5					.word	Assemble_bvc                     ; $8f BVC
>9338		33 a5					.word	Assemble_bvs                     ; $90 BVS
>933a		53 a5					.word	Assemble_clc                     ; $91 CLC
>933c		a7 a5					.word	Assemble_cld                     ; $92 CLD
>933e		67 a5					.word	Assemble_cli                     ; $93 CLI
>9340		97 a5					.word	Assemble_clv                     ; $94 CLV
>9342		c5 a4					.word	Assemble_cmp                     ; $95 CMP
>9344		0e a5					.word	Assemble_cpx                     ; $96 CPX
>9346		09 a5					.word	Assemble_cpy                     ; $97 CPY
>9348		eb a4					.word	Assemble_dec                     ; $98 DEC
>934a		a3 a5					.word	Assemble_dex                     ; $99 DEX
>934c		7f a5					.word	Assemble_dey                     ; $9a DEY
>934e		b5 a4					.word	Assemble_eor                     ; $9b EOR
>9350		f0 a4					.word	Assemble_inc                     ; $9c INC
>9352		b3 a5					.word	Assemble_inx                     ; $9d INX
>9354		9f a5					.word	Assemble_iny                     ; $9e INY
>9356		22 a5					.word	Assemble_jmp                     ; $9f JMP
>9358		1d a5					.word	Assemble_jsr                     ; $a0 JSR
>935a		c1 a4					.word	Assemble_lda                     ; $a1 LDA
>935c		e6 a4					.word	Assemble_ldx                     ; $a2 LDX
>935e		04 a5					.word	Assemble_ldy                     ; $a3 LDY
>9360		d7 a4					.word	Assemble_lsr                     ; $a4 LSR
>9362		b7 a5					.word	Assemble_nop                     ; $a5 NOP
>9364		ad a4					.word	Assemble_ora                     ; $a6 ORA
>9366		63 a5					.word	Assemble_pha                     ; $a7 PHA
>9368		4f a5					.word	Assemble_php                     ; $a8 PHP
>936a		ab a5					.word	Assemble_phx                     ; $a9 PHX
>936c		6b a5					.word	Assemble_phy                     ; $aa PHY
>936e		73 a5					.word	Assemble_pla                     ; $ab PLA
>9370		57 a5					.word	Assemble_plp                     ; $ac PLP
>9372		bf a5					.word	Assemble_plx                     ; $ad PLX
>9374		7b a5					.word	Assemble_ply                     ; $ae PLY
>9376		d2 a4					.word	Assemble_rol                     ; $af ROL
>9378		dc a4					.word	Assemble_ror                     ; $b0 ROR
>937a		5f a5					.word	Assemble_rti                     ; $b1 RTI
>937c		6f a5					.word	Assemble_rts                     ; $b2 RTS
>937e		c9 a4					.word	Assemble_sbc                     ; $b3 SBC
>9380		5b a5					.word	Assemble_sec                     ; $b4 SEC
>9382		bb a5					.word	Assemble_sed                     ; $b5 SED
>9384		77 a5					.word	Assemble_sei                     ; $b6 SEI
>9386		bd a4					.word	Assemble_sta                     ; $b7 STA
>9388		af a5					.word	Assemble_stp                     ; $b8 STP
>938a		e1 a4					.word	Assemble_stx                     ; $b9 STX
>938c		ff a4					.word	Assemble_sty                     ; $ba STY
>938e		f5 a4					.word	Assemble_stz                     ; $bb STZ
>9390		93 a5					.word	Assemble_tax                     ; $bc TAX
>9392		8f a5					.word	Assemble_tay                     ; $bd TAY
>9394		18 a5					.word	Assemble_trb                     ; $be TRB
>9396		13 a5					.word	Assemble_tsb                     ; $bf TSB
>9398		9b a5					.word	Assemble_tsx                     ; $c0 TSX
>939a		83 a5					.word	Assemble_txa                     ; $c1 TXA
>939c		8b a5					.word	Assemble_txs                     ; $c2 TXS
>939e		87 a5					.word	Assemble_tya                     ; $c3 TYA

;******  Return to file: ./common/commands/run.asm


;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/stop.asm

.93a0						StopCommand:
.93a0		a9 08		lda #$08		lda	#8
.93a2		4c 19 95	jmp $9519		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/clear.asm

.93a5						ClearSystem:
.93a5		a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.93a7		85 36		sta $36				sta 	0+zTemp0
.93a9		a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.93ab		85 37		sta $37				sta 	1+zTemp0
.93ad						_ClearZeroLoop:
.93ad		b2 36		lda ($36)			lda 	(zTemp0) 					; end of variables if offset is zero.
.93af		f0 24		beq $93d5			beq 	_ClearZeroEnd
.93b1		a0 03		ldy #$03			ldy 	#3 							; erase the variables
.93b3		a9 00		lda #$00			lda 	#0 							; set all the data to zero.
.93b5						_ClearOneVariable:
.93b5		91 36		sta ($36),y			sta 	(zTemp0),y
.93b7		c8		iny				iny
.93b8		c0 08		cpy #$08			cpy 	#8
.93ba		d0 f9		bne $93b5			bne 	_ClearOneVariable
.93bc		a0 02		ldy #$02			ldy 	#2 							; has it been marked procedure
.93be		b1 36		lda ($36),y			lda 	(zTemp0),y
.93c0		c9 18		cmp #$18			cmp 	#NSTProcedure
.93c2		d0 04		bne $93c8			bne 	_ClearNotProcedure
.93c4		a9 04		lda #$04			lda 	#NSTInteger+NSBIsArray 		; if so set it back to an integer array
.93c6		91 36		sta ($36),y			sta 	(zTemp0),y 					; will be fixed on the pre-run scan.
.93c8						_ClearNotProcedure:
.93c8		18		clc				clc 								; go to the next variable
.93c9		b2 36		lda ($36)			lda 	(zTemp0) 					; offset to next, add to zTemp0
.93cb		65 36		adc $36				adc 	zTemp0
.93cd		85 36		sta $36				sta 	zTemp0
.93cf		90 dc		bcc $93ad			bcc 	_ClearZeroLoop
.93d1		e6 37		inc $37				inc 	zTemp0+1
.93d3		80 d8		bra $93ad			bra 	_ClearZeroLoop
.93d5						_ClearZeroEnd:
.93d5		18		clc				clc
.93d6		a5 36		lda $36				lda 	zTemp0
.93d8		69 01		adc #$01			adc 	#1
.93da		8d 28 04	sta $0428			sta 	lowMemPtr
.93dd		a5 37		lda $37				lda 	zTemp0+1
.93df		69 00		adc #$00			adc 	#0
.93e1		8d 29 04	sta $0429			sta 	lowMemPtr+1
.93e4		20 ff b6	jsr $b6ff			jsr 	StackReset
.93e7		20 65 b7	jsr $b765			jsr 	StringSystemInitialise
.93ea		20 03 94	jsr $9403			jsr 	ProcedureScan
.93ed		20 a0 90	jsr $90a0			jsr 	Command_Restore
.93f0		9c 3a 04	stz $043a			stz 	AssemblerAddress
.93f3		9c 3b 04	stz $043b			stz 	AssemblerAddress+1
.93f6		9c 3c 04	stz $043c			stz 	AssemblerControl
.93f9		9c 80 06	stz $0680			stz 	KeyboardQueueEntries
.93fc		20 62 a0	jsr $a062			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.93ff		20 d7 aa	jsr $aad7			jsr 	ResetBitmapSpritesTiles
.9402		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/procscan.asm

.9403						ProcedureScan:
.9403		20 b7 90	jsr $90b7			jsr 	SwapDataCodePtrs 			; swap code and data
.9406		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.9408		85 30		sta $30				sta 	codePtr
.940a		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.940c		85 31		sta $31				sta 	codePtr+1
.940e						_PSLoop:
.940e		b2 30		lda ($30)			lda 	(codePtr)
.9410		f0 42		beq $9454			beq 	_PSExit
.9412		a0 03		ldy #$03			ldy 	#3 							; is it PROC at start of line ?
.9414		b1 30		lda ($30),y			lda 	(codePtr),y
.9416		c9 b0		cmp #$b0			cmp 	#KWD_PROC
.9418		d0 2d		bne $9447			bne 	_PSNext
.941a		c8		iny				iny 								; get the address of the record to zTemp0 and
.941b		b1 30		lda ($30),y			lda 	(codePtr),y
.941d		29 c0		and #$c0			and 	#$C0
.941f		c9 40		cmp #$40			cmp 	#$40
.9421		d0 35		bne $9458			bne 	_PSSyntax
.9423		b1 30		lda ($30),y			lda 	(codePtr),y
.9425		18		clc				clc
.9426		69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.9428		85 37		sta $37				sta 	zTemp0+1
.942a		c8		iny				iny 								; LSB
.942b		b1 30		lda ($30),y			lda 	(codePtr),y
.942d		85 36		sta $36				sta 	zTemp0
.942f		c8		iny				iny 								; character after variable call.
.9430		98		tya				tya 								; save Y offset at +7 (exponent slot)
.9431		a0 07		ldy #$07			ldy 	#7
.9433		91 36		sta ($36),y			sta 	(zTemp0),y
.9435		a9 18		lda #$18			lda 	#NSTProcedure 				; mark it as procedure
.9437		a0 02		ldy #$02			ldy 	#2
.9439		91 36		sta ($36),y			sta 	(zTemp0),y
.943b		a2 00		ldx #$00			ldx 	#0 							; copy code-Ptr into offset 3-6 (mantissa)
.943d						_PSCopy:
.943d		b5 30		lda $30,x			lda 	safePtr,x
.943f		c8		iny				iny
.9440		91 36		sta ($36),y			sta 	(zTemp0),y
.9442		e8		inx				inx
.9443		e0 04		cpx #$04			cpx 	#4
.9445		d0 f6		bne $943d			bne 	_PSCopy
.9447						_PSNext:
.9447		18		clc				clc
.9448		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.944a		65 30		adc $30				adc 	codePtr
.944c		85 30		sta $30				sta 	codePtr
.944e		90 02		bcc $9452			bcc 	_CREExit
.9450		e6 31		inc $31				inc 	codePtr+1 					; carry
.9452						_CREExit:
.9452		80 ba		bra $940e			bra 	_PSLoop
.9454						_PSExit:
.9454		20 b7 90	jsr $90b7			jsr 	SwapDataCodePtrs 			; swap code and data
.9457		60		rts				rts
.9458						_PSSyntax:
.9458		4c fa a5	jmp $a5fa			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/scanforward.asm

.945b						ScanForward:
.945b		64 38		stz $38				stz 	zTemp1 						; zero the structure count - goes up with WHILE/FOR down with WEND/NEXT etc.
.945d		86 37		stx $37				stx 	zTemp0+1
.945f		85 36		sta $36				sta 	zTemp0 						; save X & A as the two possible matches.
.9461						_ScanLoop:
.9461		b1 30		lda ($30),y			lda 	(codePtr),y
.9463		c8		iny				iny
.9464		a6 38		ldx $38				ldx 	zTemp1 						; if the count is > 0 cannot match as in substructure
.9466		d0 0e		bne $9476			bne 	_ScanGoNext
.9468		c5 36		cmp $36				cmp 	zTemp0 						; see if either matches
.946a		f0 04		beq $9470			beq 	_ScanMatch
.946c		c5 37		cmp $37				cmp 	zTemp0+1
.946e		d0 06		bne $9476			bne 	_ScanGoNext
.9470						_ScanMatch:
.9470		c9 80		cmp #$80			cmp 	#KWC_EOL 					; if asked for EOL, backtrack.
.9472		d0 01		bne $9475			bne 	_ScanNotEndEOL
.9474		88		dey				dey
.9475						_ScanNotEndEOL:
.9475		60		rts				rts
.9476						_ScanGoNext:
.9476		20 7b 94	jsr $947b			jsr  	ScanForwardOne 				; allows for shifts and so on.
.9479		80 e6		bra $9461			bra 	_ScanLoop
.947b						ScanForwardOne:
.947b		c9 40		cmp #$40			cmp 	#$40 						; if 00-3F, punctuation characters, already done.
.947d		90 3e		bcc $94bd			bcc 	_SFWExit
.947f		c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if 40-82, skip one extra as these are 2 byte
.9481		90 18		bcc $949b			bcc 	_ScanSkipOne	 			; offsets into the identifier table or shifts.
.9483		c9 fc		cmp #$fc			cmp 	#$FC 						; FC-FF are data skips (hex consts, strings etc.)
.9485		b0 2f		bcs $94b6			bcs 	_ScanSkipData
.9487		c9 ae		cmp #$ae			cmp 	#KWC_FIRST_STRUCTURE 		; structure keyword ?
.9489		90 32		bcc $94bd			bcc 	_SFWExit 					; if not, ordinary keywords.
.948b		c9 b9		cmp #$b9			cmp 	#KWC_LAST_STRUCTURE+1
.948d		b0 2e		bcs $94bd			bcs 	_SFWExit
.948f		c6 38		dec $38				dec 	zTemp1 						; decrement the sructure count
.9491		c9 b3		cmp #$b3			cmp 	#KWC_FIRST_STRUCTURE_DEC 	; back if it is a dec structure (e.g. WEND/NEXT)
.9493		b0 28		bcs $94bd			bcs 	_SFWExit
.9495		e6 38		inc $38				inc 	zTemp1 						; so it's an increment structure
.9497		e6 38		inc $38				inc 	zTemp1 						; twice to undo the dec
.9499		80 22		bra $94bd			bra 	_SFWExit
.949b						_ScanSkipOne:
.949b		c8		iny				iny 								; consume the extra one.
.949c		c9 80		cmp #$80			cmp 	#KWC_EOL 					; if not EOL loop back
.949e		d0 1d		bne $94bd			bne 	_SFWExit
.94a0		18		clc				clc
.94a1		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.94a3		65 30		adc $30				adc 	codePtr
.94a5		85 30		sta $30				sta 	codePtr
.94a7		90 02		bcc $94ab			bcc 	_CREExit
.94a9		e6 31		inc $31				inc 	codePtr+1 					; carry
.94ab						_CREExit:
.94ab		a0 03		ldy #$03			ldy 	#3 							; scan start position.
.94ad		b2 30		lda ($30)			lda 	(codePtr)
.94af		d0 0c		bne $94bd			bne 	_SFWExit 					; if not zero, more to scan
.94b1		a9 13		lda #$13		lda	#19
.94b3		4c 19 95	jmp $9519		jmp	ErrorHandler
.94b6						_ScanSkipData:
.94b6		88		dey				dey 								; point at data token
.94b7		c8		iny				iny 								; point to offset
.94b8		98		tya				tya 								; A = offset position
.94b9		38		sec				sec 								; add size +1 hence SEC
.94ba		71 30		adc ($30),y			adc 	(codePtr),y
.94bc		a8		tay				tay 								; make current position.
.94bd						_SFWExit:
.94bd		60		rts				rts
.94be						ScanGetCurrentLineStep:
.94be		64 38		stz $38				stz 	zTemp1
.94c0		a0 03		ldy #$03			ldy 	#3
.94c2						_SGCLSLoop:
.94c2		b1 30		lda ($30),y			lda 	(codePtr),y
.94c4		c8		iny				iny
.94c5		c9 80		cmp #$80			cmp 	#KWC_EOL	 				; if EOL exit
.94c7		f0 05		beq $94ce			beq 	_SGCLSExit
.94c9		20 7b 94	jsr $947b			jsr 	ScanForwardOne
.94cc		80 f4		bra $94c2			bra 	_SGCLSLoop
.94ce						_SGCLSExit:
.94ce		a5 38		lda $38				lda 	zTemp1 						; return the adjustment
.94d0		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/while.asm

.94d1						Command_WHILE:
.94d1		5a		phy				phy 								; save position of the test
.94d2		a2 00		ldx #$00			ldx 	#0 							; work out the while test.
.94d4		20 d0 a3	jsr $a3d0			jsr 	EvaluateNumber
.94d7		20 a4 a4	jsr $a4a4			jsr 	NSMIsZero 					; check if zero
.94da		f0 0e		beq $94ea			beq 	_WHExitLoop 				; if so exit the loop, while has failed.
.94dc		98		tya				tya 								; position *after* test.
.94dd		7a		ply				ply 								; restore position before test, at WHILE
.94de		88		dey				dey 								; so we execute the WHILE command again.
.94df		48		pha				pha 								; push after test on the stack
.94e0		a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; allocate 6 bytes on the return stack.
.94e2		20 99 b6	jsr $b699			jsr 	StackOpen
.94e5		20 de b6	jsr $b6de			jsr 	STKSaveCodePosition 		; save loop position - where the test value expr is.
.94e8		7a		ply				ply 								; restore the position *after* the test
.94e9		60		rts				rts
.94ea						_WHExitLoop:
.94ea		68		pla				pla 								; throw post loop position
.94eb		a9 b8		lda #$b8			lda 	#KWD_WEND 					; scan forward past WEND
.94ed		aa		tax				tax
.94ee		20 5b 94	jsr $945b			jsr 	ScanForward
.94f1		60		rts				rts
.94f2						Command_WEND:
.94f2		a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; check WHILE is TOS e.g. in a while loop :)
.94f4		a2 10		ldx #$10			ldx 	#ERRID_WHILE 				; this error if not.
.94f6		20 c6 b6	jsr $b6c6			jsr 	StackCheckFrame
.94f9		20 ef b6	jsr $b6ef			jsr 	STKLoadCodePosition 		; loop back to the WHILE keyword.
.94fc		20 b8 b6	jsr $b6b8			jsr 	StackClose		 			; erase the frame
.94ff		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/charcheck.asm

.9500						CheckRightBracket:
.9500		b1 30		lda ($30),y			lda 	(codePtr),y
.9502		c8		iny				iny
.9503		c9 29		cmp #$29			cmp 	#KWD_RPAREN 						; exit if matches
.9505		d0 0f		bne $9516			bne 	CNAFail
.9507		60		rts				rts
.9508						CheckComma:
.9508		b1 30		lda ($30),y			lda 	(codePtr),y
.950a		c8		iny				iny
.950b		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 						; exit if matches
.950d		d0 07		bne $9516			bne 	CNAFail
.950f		60		rts				rts
.9510						CheckNextA:
.9510		d1 30		cmp ($30),y			cmp 	(codePtr),y
.9512		d0 02		bne $9516			bne 	CNAFail
.9514		c8		iny				iny 								; skip character
.9515		60		rts				rts 								; and exit
.9516						CNAFail:
.9516		4c fa a5	jmp $a5fa			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/errors.asm

.9519						ErrorHandler:
.9519		48		pha				pha 								; save error #
.951a		a8		tay				tay 								; find the error text
.951b		f0 4e		beq $956b			beq 	_EHEnd
.951d		a2 00		ldx #$00			ldx 	#0
.951f		a9 13		lda #$13			lda 	#((ErrorText) & $FF)
.9521		85 36		sta $36				sta 	0+zTemp0
.9523		a9 a6		lda #$a6			lda 	#((ErrorText) >> 8)
.9525		85 37		sta $37				sta 	1+zTemp0
.9527						_EHFind:
.9527		88		dey				dey 								; keep looking through text
.9528		f0 0e		beq $9538			beq 	_EHFound
.952a						_EHFindZero:
.952a		b2 36		lda ($36)			lda 	(zTemp0) 					; find the next error
.952c		e6 36		inc $36				inc 	zTemp0
.952e		d0 02		bne $9532			bne 	_EHFNoCarry
.9530		e6 37		inc $37				inc 	zTemp0+1
.9532						_EHFNoCarry:
.9532		c9 00		cmp #$00			cmp 	#0
.9534		d0 f4		bne $952a			bne 	_EHFindZero
.9536		80 ef		bra $9527			bra 	_EHFind
.9538						_EHFound:
.9538		a5 36		lda $36				lda 	zTemp0 						; print message
.953a		a6 37		ldx $37				ldx 	zTemp0+1
.953c		20 78 95	jsr $9578			jsr 	PrintStringXA
.953f		68		pla				pla  								; check if error is 'open structure'
.9540		c9 13		cmp #$13			cmp 	#ERRID_STRUCT
.9542		f0 22		beq $9566			beq 	_EHCREnd
.9544		a0 01		ldy #$01			ldy 	#1 							; if line number zero don't print it
.9546		b1 30		lda ($30),y			lda 	(codePtr),y
.9548		d0 05		bne $954f			bne 	_EHAtMsg
.954a		c8		iny				iny
.954b		b1 30		lda ($30),y			lda 	(codePtr),y
.954d		f0 17		beq $9566			beq 	_EHCREnd
.954f						_EHAtMsg:
.954f		a2 95		ldx #$95			ldx 	#_AtMsg >> 8 				; print " at "
.9551		a9 6e		lda #$6e			lda 	#_AtMsg & $FF
.9553		20 78 95	jsr $9578			jsr 	PrintStringXA
.9556		a0 01		ldy #$01			ldy 	#1 							; line number into XA
.9558		b1 30		lda ($30),y			lda 	(codePtr),y
.955a		48		pha				pha
.955b		c8		iny				iny
.955c		b1 30		lda ($30),y			lda 	(codePtr),y
.955e		aa		tax				tax
.955f		68		pla				pla
.9560		20 8e 99	jsr $998e			jsr 	ConvertInt16 				; convert XA to string
.9563		20 78 95	jsr $9578			jsr 	PrintStringXA 				; and print it.
.9566						_EHCREnd:
.9566		a9 0d		lda #$0d			lda 	#13 						; new line
.9568		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.956b						_EHEnd:
.956b		4c 12 89	jmp $8912			jmp 	WarmStart
>956e		20 61 74 20 6c 69 6e 65		_AtMsg:	.text 	" at line ",0
>9576		20 00
.9578						PrintStringXA:
.9578		5a		phy				phy
.9579		86 37		stx $37				stx 	zTemp0+1
.957b		85 36		sta $36				sta 	zTemp0
.957d		a0 00		ldy #$00			ldy 	#0
.957f						_PSXALoop:
.957f		b1 36		lda ($36),y			lda 	(zTemp0),y
.9581		f0 06		beq $9589			beq 	_PSXAExit
.9583		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.9586		c8		iny				iny
.9587		80 f6		bra $957f			bra 	_PSXALoop
.9589						_PSXAExit:
.9589		7a		ply				ply
.958a		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/compare.asm

.958b						UnaryTrue:
.958b		fa		plx				plx
.958c						ReturnTrue:
.958c		a9 01		lda #$01			lda 	#1  						; set to 1
.958e		20 84 a4	jsr $a484			jsr 	NSMSetByte
.9591		a9 80		lda #$80			lda 	#$80 						; set sign flag, so it is -1
.9593		95 50		sta $50,x			sta 	NSStatus,x
.9595		60		rts				rts
.9596						UnaryFalse:
.9596		fa		plx				plx
.9597						ReturnFalse:
.9597		4c 82 a4	jmp $a482			jmp 	NSMSetZero 					; set it all to zero
.959a						BinaryCompareEqual:
.959a		fa		plx				plx
.959b		20 d6 95	jsr $95d6			jsr 	CompareBaseCode
.959e		c9 00		cmp #$00			cmp 	#0
.95a0		f0 ea		beq $958c			beq 	ReturnTrue
.95a2		80 f3		bra $9597			bra 	ReturnFalse
.95a4						BinaryCompareLess:
.95a4		fa		plx				plx
.95a5		20 d6 95	jsr $95d6			jsr 	CompareBaseCode
.95a8		c9 ff		cmp #$ff			cmp 	#$FF
.95aa		f0 e0		beq $958c			beq 	ReturnTrue
.95ac		80 e9		bra $9597			bra 	ReturnFalse
.95ae						BinaryCompareGreater:
.95ae		fa		plx				plx
.95af		20 d6 95	jsr $95d6			jsr 	CompareBaseCode
.95b2		c9 01		cmp #$01			cmp 	#1
.95b4		f0 d6		beq $958c			beq 	ReturnTrue
.95b6		80 df		bra $9597			bra 	ReturnFalse
.95b8						BinaryCompareNotEqual:
.95b8		fa		plx				plx
.95b9		20 d6 95	jsr $95d6			jsr 	CompareBaseCode
.95bc		c9 00		cmp #$00			cmp 	#0
.95be		d0 cc		bne $958c			bne 	ReturnTrue
.95c0		80 d5		bra $9597			bra 	ReturnFalse
.95c2						BinaryCompareLessEqual:
.95c2		fa		plx				plx
.95c3		20 d6 95	jsr $95d6			jsr 	CompareBaseCode
.95c6		c9 01		cmp #$01			cmp 	#1
.95c8		d0 c2		bne $958c			bne 	ReturnTrue
.95ca		80 cb		bra $9597			bra 	ReturnFalse
.95cc						BinaryCompareGreaterEqual:
.95cc		fa		plx				plx
.95cd		20 d6 95	jsr $95d6			jsr 	CompareBaseCode
.95d0		c9 ff		cmp #$ff			cmp 	#$FF
.95d2		d0 b8		bne $958c			bne 	ReturnTrue
.95d4		80 c1		bra $9597			bra 	ReturnFalse
.95d6						CompareBaseCode:
.95d6		20 ea 9c	jsr $9cea			jsr 	DereferenceTopTwo 			; make both values if references.
.95d9		b5 50		lda $50,x			lda 	NSStatus,x 					; check if either is a string.
.95db		15 51		ora $51,x			ora 	NSStatus+1,x
.95dd		29 10		and #$10			and 	#NSTString
.95df		d0 37		bne $9618			bne 	_CBCString 					; if so do string code, which will check if both.
.95e1		b5 a0		lda $a0,x			lda 	NSExponent,x 				; check both are integers
.95e3		15 a1		ora $a1,x			ora 	NSExponent+1,x
.95e5		d0 34		bne $961b			bne 	_CBCFloat
.95e7		b5 50		lda $50,x			lda 	NSStatus,x
.95e9		15 51		ora $51,x			ora 	NSStatus+1,x
.95eb		29 08		and #$08			and 	#NSTFloat
.95ed		d0 2c		bne $961b			bne 	_CBCFloat
.95ef		20 1e 96	jsr $961e			jsr 	CompareFixMinusZero 		; fix up -0 just in cases.
.95f2		e8		inx				inx
.95f3		20 1e 96	jsr $961e			jsr 	CompareFixMinusZero
.95f6		ca		dex				dex
.95f7		b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs different ?
.95f9		55 51		eor $51,x			eor 	NSStatus+1,x
.95fb		10 0a		bpl $9607			bpl 	_CDCSameSign
.95fd		b5 50		lda $50,x			lda 	NSStatus,x 					; if first one is -ve
.95ff		30 14		bmi $9615			bmi 	_CBCLess 					; return $FF
.9601						_CBCGreater:
.9601		a9 01		lda #$01			lda 	#1
.9603		60		rts				rts
.9604						_CBCEqual:
.9604		a9 00		lda #$00			lda 	#0
.9606		60		rts				rts
.9607						_CDCSameSign:
.9607		20 33 98	jsr $9833			jsr 	SubTopTwoStack 				; unsigned subtract
.960a		20 a4 a4	jsr $a4a4			jsr 	NSMIsZero 					; or the mantissa together
.960d		f0 f5		beq $9604			beq 	_CBCEqual 					; -0 == 0
.960f		b5 90		lda $90,x			lda 	NSMantissa3,x 				; sign of the result. if +ve return $01 else return $FF
.9611		55 51		eor $51,x			eor 	NSStatus+1,x 				; however if both were -ve this is inverted
.9613		10 ec		bpl $9601			bpl 	_CBCGreater
.9615						_CBCLess:
.9615		a9 ff		lda #$ff			lda 	#$FF
.9617		60		rts				rts
.9618						_CBCString:
.9618		4c a4 97	jmp $97a4			jmp 	CompareStrings
.961b						_CBCFloat:
.961b		4c f7 9a	jmp $9af7			jmp 	CompareFloat
.961e						CompareFixMinusZero:
.961e		20 a4 a4	jsr $a4a4			jsr 	NSMIsZero
.9621		d0 02		bne $9625			bne 	_CFXMZNotZero
.9623		74 50		stz $50,x			stz 	NSStatus,x
.9625						_CFXMZNotZero:
.9625		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/concat.asm

.9626						StringConcat:
.9626		b5 50		lda $50,x			lda 	NSStatus,x 					; check both strings
.9628		35 51		and $51,x			and 	NSStatus+1,x
.962a		29 18		and #$18			and 	#NSBTypeMask
.962c		c9 10		cmp #$10			cmp 	#NSTString
.962e		d0 50		bne $9680			bne		_SCType
.9630		64 38		stz $38				stz 	zTemp1 						; counting total length
.9632		e8		inx				inx
.9633		20 51 96	jsr $9651			jsr 	_SCSetupZ0 					; setup for second
.9636		20 5a 96	jsr $965a			jsr 	_SCLengthZ0 				; length for second
.9639		ca		dex				dex
.963a		20 51 96	jsr $9651			jsr 	_SCSetupZ0 					; setup for first
.963d		20 5a 96	jsr $965a			jsr 	_SCLengthZ0 				; length for first
.9640		a5 38		lda $38				lda 	zTemp1 						; allocate memory using total.
.9642		20 89 b7	jsr $b789			jsr 	StringTempAllocate
.9645		20 71 96	jsr $9671			jsr 	_SCCopy 					; copy first out, using zTemp0 from above
.9648		e8		inx				inx
.9649		20 51 96	jsr $9651			jsr 	_SCSetupZ0 					; copy second out
.964c		20 71 96	jsr $9671			jsr 	_SCCopy
.964f		ca		dex				dex
.9650		60		rts				rts
.9651						_SCSetupZ0:
.9651		b5 60		lda $60,x			lda 	NSMantissa0,x
.9653		85 36		sta $36				sta 	zTemp0
.9655		b5 70		lda $70,x			lda 	NSMantissa1,x
.9657		85 37		sta $37				sta 	zTemp0+1
.9659		60		rts				rts
.965a						_SCLengthZ0:
.965a		5a		phy				phy
.965b		a0 00		ldy #$00			ldy 	#0
.965d						_SCLenLoop:
.965d		b1 36		lda ($36),y			lda 	(zTemp0),y
.965f		f0 0e		beq $966f			beq 	_SCLExit
.9661		c8		iny				iny
.9662		e6 38		inc $38				inc 	zTemp1
.9664		a5 38		lda $38				lda	 	zTemp1 						; check string too long.
.9666		c9 fd		cmp #$fd			cmp 	#253
.9668		d0 f3		bne $965d			bne		_SCLenLoop
.966a		a9 09		lda #$09		lda	#9
.966c		4c 19 95	jmp $9519		jmp	ErrorHandler
.966f						_SCLExit:
.966f		7a		ply				ply
.9670		60		rts				rts
.9671						_SCCopy:
.9671		5a		phy				phy
.9672		a0 00		ldy #$00			ldy 	#0
.9674						_SCCopyLoop:
.9674		b1 36		lda ($36),y			lda 	(zTemp0),y
.9676		f0 06		beq $967e			beq 	_SCCExit
.9678		20 c2 b7	jsr $b7c2			jsr 	StringTempWrite
.967b		c8		iny				iny
.967c		80 f6		bra $9674			bra 	_SCCopyLoop
.967e						_SCCExit:
.967e		7a		ply				ply
.967f		60		rts				rts
.9680						_SCType:
.9680		4c 04 a6	jmp $a604			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/divide.asm

.9683						IntegerDivide:
.9683		fa		plx				plx
.9684		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9686		15 51		ora $51,x			ora 	NSStatus+1,x
.9688		0a		asl a				asl 	a 							; shift reference bit into sign bit
.9689		0a		asl a				asl 	a
.968a		10 05		bpl $9691			bpl 	_NotRef
.968c		48		pha				pha
.968d		20 ea 9c	jsr $9cea			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9690		68		pla				pla
.9691						_NotRef:
.9691		0a		asl a				asl 	a
.9692		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9694		15 a0		ora $a0,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9696		15 a1		ora $a1,x			ora 	NSExponent+1,x
.9698		f0 03		beq $969d			beq 	_IntegerCode 				; if clear, then we have two integers
.969a		4c 04 a6	jmp $a604			jmp 	TypeError 					; anything else, type mismatch.
.969d						_IntegerCode:
.969d		20 b7 96	jsr $96b7			jsr 	CheckDivideZero 			; do div zero check
.96a0		20 e9 96	jsr $96e9			jsr 	Int32Divide 				; do the division
.96a3		20 9a 97	jsr $979a			jsr 	CalculateSign 				; calculate result sign
.96a6						NSMCopyPlusTwoToZero:
.96a6		b5 62		lda $62,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.96a8		95 60		sta $60,x			sta 	NSMantissa0,x
.96aa		b5 72		lda $72,x			lda 	NSMantissa1+2,x
.96ac		95 70		sta $70,x			sta 	NSMantissa1,x
.96ae		b5 82		lda $82,x			lda 	NSMantissa2+2,x
.96b0		95 80		sta $80,x			sta 	NSMantissa2,x
.96b2		b5 92		lda $92,x			lda 	NSMantissa3+2,x
.96b4		95 90		sta $90,x			sta 	NSMantissa3,x
.96b6		60		rts				rts
.96b7						CheckDivideZero:
.96b7		e8		inx				inx
.96b8		20 a4 a4	jsr $a4a4			jsr 	NSMIsZero
.96bb		f0 02		beq $96bf			beq 	_CDVError
.96bd		ca		dex				dex
.96be		60		rts				rts
.96bf						_CDVError:
.96bf		a9 03		lda #$03		lda	#3
.96c1		4c 19 95	jmp $9519		jmp	ErrorHandler
.96c4						IntegerModulus:
.96c4		fa		plx				plx
.96c5		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.96c7		15 51		ora $51,x			ora 	NSStatus+1,x
.96c9		0a		asl a				asl 	a 							; shift reference bit into sign bit
.96ca		0a		asl a				asl 	a
.96cb		10 05		bpl $96d2			bpl 	_NotRef
.96cd		48		pha				pha
.96ce		20 ea 9c	jsr $9cea			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.96d1		68		pla				pla
.96d2						_NotRef:
.96d2		0a		asl a				asl 	a
.96d3		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.96d5		15 a0		ora $a0,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.96d7		15 a1		ora $a1,x			ora 	NSExponent+1,x
.96d9		f0 03		beq $96de			beq 	_IntegerCode 				; if clear, then we have two integers
.96db		4c 04 a6	jmp $a604			jmp 	TypeError 					; anything else, type mismatch.
.96de						_IntegerCode:
.96de						IntegerModulusNoCheck:
.96de		20 b7 96	jsr $96b7			jsr 	CheckDivideZero 			; do div zero check
.96e1		20 e9 96	jsr $96e9			jsr 	Int32Divide 				; do the division
.96e4		16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.96e6		56 50		lsr $50,x			lsr 	NSStatus,x
.96e8		60		rts				rts
.96e9						Int32Divide:
.96e9		48		pha				pha 								; save AXY
.96ea		5a		phy				phy
.96eb		20 65 a4	jsr $a465			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.96ee		20 7e a4	jsr $a47e			jsr 	NSMSetZeroMantissaOnly 		; set S[X] to zero
.96f1		a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.96f3						_I32DivideLoop:
.96f3		e8		inx				inx
.96f4		e8		inx				inx
.96f5		20 91 a4	jsr $a491			jsr 	NSMShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.96f8		ca		dex				dex
.96f9		ca		dex				dex
.96fa		20 92 a4	jsr $a492			jsr 	NSMRotateLeft
.96fd		20 28 97	jsr $9728			jsr 	DivideCheckSubtract 		; check if subtract possible
.9700		90 02		bcc $9704			bcc 	_I32DivideNoCarryIn
.9702		f6 62		inc $62,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.9704						_I32DivideNoCarryIn:
.9704		88		dey				dey 								; loop round till division completed.
.9705		d0 ec		bne $96f3			bne 	_I32DivideLoop
.9707		7a		ply				ply 								; restore AXY and exit
.9708		68		pla				pla
.9709		60		rts				rts
.970a						Int32ShiftDivide:
.970a		48		pha				pha 								; save AY
.970b		5a		phy				phy
.970c		e8		inx				inx 								; clear S[X+2]
.970d		e8		inx				inx
.970e		20 82 a4	jsr $a482			jsr 	NSMSetZero
.9711		ca		dex				dex
.9712		ca		dex				dex
.9713		a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.9715						_I32SDLoop:
.9715		20 28 97	jsr $9728			jsr 	DivideCheckSubtract 		; check if subtract possible
.9718		e8		inx				inx
.9719		e8		inx				inx
.971a		20 92 a4	jsr $a492			jsr 	NSMRotateLeft				; shift 64 bit FPA left, rotating carry in
.971d		ca		dex				dex
.971e		ca		dex				dex
.971f		20 92 a4	jsr $a492			jsr 	NSMRotateLeft
.9722		88		dey				dey 	 							; do 31 times
.9723		d0 f0		bne $9715			bne 	_I32SDLoop
.9725		7a		ply				ply 								; restore AY and exit
.9726		68		pla				pla
.9727		60		rts				rts
.9728						DivideCheckSubtract:
.9728		20 33 98	jsr $9833			jsr 	SubTopTwoStack 				; subtract Stack[X+1] from Stack[X+0]
.972b		b0 04		bcs $9731			bcs 	_DCSExit 					; if carry set, then could do, exit
.972d		20 19 98	jsr $9819			jsr 	AddTopTwoStack 				; add it back in
.9730		18		clc				clc 								; and return False
.9731						_DCSExit:
.9731		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/multiply.asm

.9732						MulInteger:
.9732		fa		plx				plx
.9733		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9735		15 51		ora $51,x			ora 	NSStatus+1,x
.9737		0a		asl a				asl 	a 							; shift reference bit into sign bit
.9738		0a		asl a				asl 	a
.9739		10 05		bpl $9740			bpl 	_NotRef
.973b		48		pha				pha
.973c		20 ea 9c	jsr $9cea			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.973f		68		pla				pla
.9740						_NotRef:
.9740		0a		asl a				asl 	a 							; put MSB of type into A:7
.9741		30 09		bmi $974c			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9743		b5 a0		lda $a0,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9745		15 a1		ora $a1,x			ora 	NSExponent+1,x
.9747		f0 06		beq $974f			beq 	_IntegerCode 				; if clear, then we have two integers
.9749		4c b9 9b	jmp $9bb9			jmp 	FloatingPointMultiply 							; otherwise at least one float.
.974c						_StringData:
.974c		4c 0e a6	jmp $a60e			jmp 	NotDoneError							; at least one string - don't know both are strings.
.974f						_IntegerCode:
.974f		20 5c 97	jsr $975c			jsr 	MultiplyShort
.9752		c9 00		cmp #$00			cmp 	#0
.9754		f0 05		beq $975b			beq 	_MIExit
.9756		a9 04		lda #$04		lda	#4
.9758		4c 19 95	jmp $9519		jmp	ErrorHandler
.975b						_MIExit:
.975b		60		rts				rts
.975c						MultiplyShort:
.975c		5a		phy				phy 								; save Y
.975d		20 65 a4	jsr $a465			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.9760		20 7e a4	jsr $a47e			jsr 	NSMSetZeroMantissaOnly 		; set mantissa S[X] to zero
.9763		a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.9765						_I32MLoop:
.9765		b5 62		lda $62,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.9767		15 72		ora $72,x			ora 	NSMantissa1+2,x
.9769		15 82		ora $82,x			ora 	NSMantissa2+2,x
.976b		15 92		ora $92,x			ora 	NSMantissa3+2,x
.976d		f0 25		beq $9794			beq 	_I32MExit 					; exit if zero
.976f		b5 62		lda $62,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.9771		29 01		and #$01			and 	#1
.9773		f0 0d		beq $9782			beq 	_I32MNoAdd
.9775		20 19 98	jsr $9819			jsr 	AddTopTwoStack 				; if so add S[X+1] to S[X+0]
.9778		b5 90		lda $90,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.977a		10 06		bpl $9782			bpl 	_I32MNoAdd
.977c						_I32ShiftRight:
.977c		20 9b a4	jsr $a49b			jsr 	NSMShiftRight 				; shift S[X] right
.977f		c8		iny				iny 								; increment shift count
.9780		80 09		bra $978b			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.9782						_I32MNoAdd:
.9782		34 91		bit $91,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.9784		70 f6		bvs $977c			bvs 	_I32ShiftRight 				; instead.
.9786		e8		inx				inx
.9787		20 91 a4	jsr $a491			jsr 	NSMShiftLeft 				; shift additive S[X+1] left
.978a		ca		dex				dex
.978b						_I32MShiftUpper:
.978b		e8		inx				inx 								; shift S[X+2] right
.978c		e8		inx				inx
.978d		20 9b a4	jsr $a49b			jsr 	NSMShiftRight
.9790		ca		dex				dex
.9791		ca		dex				dex
.9792		80 d1		bra $9765			bra 	_I32MLoop 					; try again.
.9794						_I32MExit:
.9794		20 9a 97	jsr $979a			jsr 	CalculateSign
.9797		98		tya				tya 								; shift in A
.9798		7a		ply				ply 								; restore Y and exit
.9799		60		rts				rts
.979a						CalculateSign:
.979a		b5 50		lda $50,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.979c		16 50		asl $50,x			asl 	NSStatus,x 					; shift result left
.979e		55 51		eor $51,x			eor 	NSStatus+1,x
.97a0		0a		asl a				asl 	a 							; shift bit 7 into carry
.97a1		76 50		ror $50,x			ror 	NSStatus,x 					; shift right into status byte.
.97a3		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/scompare.asm

.97a4						CompareStrings:
.97a4		b5 50		lda $50,x			lda 	NSStatus,x 					; check both are strings
.97a6		35 51		and $51,x			and 	NSStatus+1,x
.97a8		29 10		and #$10			and 	#NSBIsString
.97aa		f0 28		beq $97d4			beq 	_CSTypeError
.97ac		b5 60		lda $60,x			lda 	NSMantissa0,x 				; copy string addresses to zTemp0/1
.97ae		85 36		sta $36				sta 	zTemp0
.97b0		b5 70		lda $70,x			lda 	NSMantissa1,x
.97b2		85 37		sta $37				sta 	zTemp0+1
.97b4		b5 61		lda $61,x			lda 	NSMantissa0+1,x
.97b6		85 38		sta $38				sta 	zTemp1
.97b8		b5 71		lda $71,x			lda 	NSMantissa1+1,x
.97ba		85 39		sta $39				sta 	zTemp1+1
.97bc		5a		phy				phy 								; save Y so we can access strings
.97bd		a0 ff		ldy #$ff			ldy 	#$FF 						; -1 for pre increment.
.97bf						_CSLoop:
.97bf		c8		iny				iny
.97c0		b1 36		lda ($36),y			lda 	(zTemp0),y 					; check if they are the same
.97c2		d1 38		cmp ($38),y			cmp 	(zTemp1),y
.97c4		d0 06		bne $97cc			bne 	_CSDifferent
.97c6		c9 00		cmp #$00			cmp 	#0 							; reached end ?
.97c8		d0 f5		bne $97bf			bne 	_CSLoop 					; still comparing
.97ca						_CSExit:
.97ca		7a		ply				ply 								; reached end, return zero in A from EOS
.97cb		60		rts				rts
.97cc						_CSDifferent:
.97cc		a9 ff		lda #$ff			lda 	#255 						; if < return $FF
.97ce		90 fa		bcc $97ca			bcc		_CSExit
.97d0		a9 01		lda #$01			lda 	#1 							; otherwise return 1.
.97d2		80 f6		bra $97ca			bra 	_CSExit
.97d4						_CSTypeError:
.97d4		4c 04 a6	jmp $a604			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/shifts.asm

.97d7						ShiftLeft:
.97d7		38		sec				sec 								; common code, carry determines which way.
.97d8		80 01		bra $97db			bra 	ShiftMain
.97da						ShiftRight:
.97da		18		clc				clc
.97db						ShiftMain:
.97db		fa		plx				plx 								; restore X
.97dc		08		php				php 								; save direction
.97dd		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.97df		15 51		ora $51,x			ora 	NSStatus+1,x
.97e1		0a		asl a				asl 	a 							; shift reference bit into sign bit
.97e2		0a		asl a				asl 	a
.97e3		10 05		bpl $97ea			bpl 	_NotRef
.97e5		48		pha				pha
.97e6		20 ea 9c	jsr $9cea			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.97e9		68		pla				pla
.97ea						_NotRef:
.97ea		0a		asl a				asl 	a
.97eb		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.97ed		15 a0		ora $a0,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.97ef		15 a1		ora $a1,x			ora 	NSExponent+1,x
.97f1		f0 03		beq $97f6			beq 	_IntegerCode 				; if clear, then we have two integers
.97f3		4c 04 a6	jmp $a604			jmp 	TypeError 					; anything else, type mismatch.
.97f6						_IntegerCode:
.97f6		b5 61		lda $61,x			lda 	NSMantissa0+1,x 			; check number < 32
.97f8		29 e0		and #$e0			and 	#$E0
.97fa		15 71		ora $71,x			ora 	NSMantissa1+1,x
.97fc		15 81		ora $81,x			ora 	NSMantissa2+1,x
.97fe		15 91		ora $91,x			ora 	NSMantissa3+1,x
.9800		d0 12		bne $9814			bne 	_SMExit0 					; if >= 32 it will always return zero.
.9802						_SMLoop:
.9802		d6 61		dec $61,x			dec 	NSMantissa0+1,x 			; predecrement, could do << 0
.9804		30 11		bmi $9817			bmi 	_SMExit 					; exit if done.
.9806		28		plp				plp 								; restore direction setting
.9807		08		php				php
.9808		90 05		bcc $980f			bcc 	_SMRight
.980a		20 91 a4	jsr $a491			jsr 	NSMShiftLeft 				; shift left if CS
.980d		80 f3		bra $9802			bra 	_SMLoop
.980f						_SMRight:
.980f		20 9b a4	jsr $a49b			jsr 	NSMShiftRight 				; shift right if CC
.9812		80 ee		bra $9802			bra 	_SMLoop
.9814						_SMExit0:
.9814		20 82 a4	jsr $a482			jsr 	NSMSetZero 					; return zero.
.9817						_SMExit:
.9817		28		plp				plp 								; throw direction
.9818		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/simple.asm

.9819						AddTopTwoStack:
.9819		18		clc				clc
.981a		b5 60		lda $60,x			lda		NSMantissa0,x
.981c		75 61		adc $61,x			adc 		NSMantissa0+1,x
.981e		95 60		sta $60,x			sta 	NSMantissa0,x
.9820		b5 70		lda $70,x			lda		NSMantissa1,x
.9822		75 71		adc $71,x			adc 		NSMantissa1+1,x
.9824		95 70		sta $70,x			sta 	NSMantissa1,x
.9826		b5 80		lda $80,x			lda		NSMantissa2,x
.9828		75 81		adc $81,x			adc 		NSMantissa2+1,x
.982a		95 80		sta $80,x			sta 	NSMantissa2,x
.982c		b5 90		lda $90,x			lda		NSMantissa3,x
.982e		75 91		adc $91,x			adc 		NSMantissa3+1,x
.9830		95 90		sta $90,x			sta 	NSMantissa3,x
.9832		60		rts				rts
.9833						SubTopTwoStack:
.9833		38		sec				sec
.9834		b5 60		lda $60,x			lda		NSMantissa0,x
.9836		f5 61		sbc $61,x			sbc 		NSMantissa0+1,x
.9838		95 60		sta $60,x			sta 	NSMantissa0,x
.983a		b5 70		lda $70,x			lda		NSMantissa1,x
.983c		f5 71		sbc $71,x			sbc 		NSMantissa1+1,x
.983e		95 70		sta $70,x			sta 	NSMantissa1,x
.9840		b5 80		lda $80,x			lda		NSMantissa2,x
.9842		f5 81		sbc $81,x			sbc 		NSMantissa2+1,x
.9844		95 80		sta $80,x			sta 	NSMantissa2,x
.9846		b5 90		lda $90,x			lda		NSMantissa3,x
.9848		f5 91		sbc $91,x			sbc 		NSMantissa3+1,x
.984a		95 90		sta $90,x			sta 	NSMantissa3,x
.984c		60		rts				rts
.984d						AddInteger:
.984d		fa		plx				plx
.984e		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9850		15 51		ora $51,x			ora 	NSStatus+1,x
.9852		0a		asl a				asl 	a 							; shift reference bit into sign bit
.9853		0a		asl a				asl 	a
.9854		10 05		bpl $985b			bpl 	_NotRef
.9856		48		pha				pha
.9857		20 ea 9c	jsr $9cea			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.985a		68		pla				pla
.985b						_NotRef:
.985b		0a		asl a				asl 	a 							; put MSB of type into A:7
.985c		30 09		bmi $9867			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.985e		b5 a0		lda $a0,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9860		15 a1		ora $a1,x			ora 	NSExponent+1,x
.9862		f0 06		beq $986a			beq 	_IntegerCode 				; if clear, then we have two integers
.9864		4c 69 9a	jmp $9a69			jmp 	FloatingPointAdd 							; otherwise at least one float.
.9867						_StringData:
.9867		4c 26 96	jmp $9626			jmp 	StringConcat							; at least one string - don't know both are strings.
.986a						_IntegerCode:
.986a						AddCode:
.986a		b5 50		lda $50,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.986c		55 51		eor $51,x			eor 	NSStatus+1,x
.986e		10 a9		bpl $9819			bpl 	AddTopTwoStack
.9870		20 33 98	jsr $9833			jsr 	SubTopTwoStack 				; do a physical subtraction
.9873		34 90		bit $90,x			bit 	NSMantissa3,x 				; result is +ve, okay
.9875		10 07		bpl $987e			bpl 	_AddExit
.9877		b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign is that of 2nd value
.9879		95 50		sta $50,x			sta 	NSStatus,x
.987b		20 4b a4	jsr $a44b			jsr 	NSMNegateMantissa 			; negate the mantissa and exit
.987e						_AddExit:
.987e		20 a4 a4	jsr $a4a4			jsr 	NSMIsZero 					; check for -0
.9881		d0 02		bne $9885			bne 	_AddNonZero
.9883		74 50		stz $50,x			stz 	NSStatus,x
.9885						_AddNonZero:
.9885		60		rts				rts
.9886						SubInteger:
.9886		fa		plx				plx
.9887		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9889		15 51		ora $51,x			ora 	NSStatus+1,x
.988b		0a		asl a				asl 	a 							; shift reference bit into sign bit
.988c		0a		asl a				asl 	a
.988d		10 05		bpl $9894			bpl 	_NotRef
.988f		48		pha				pha
.9890		20 ea 9c	jsr $9cea			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9893		68		pla				pla
.9894						_NotRef:
.9894		0a		asl a				asl 	a 							; put MSB of type into A:7
.9895		30 09		bmi $98a0			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9897		b5 a0		lda $a0,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9899		15 a1		ora $a1,x			ora 	NSExponent+1,x
.989b		f0 06		beq $98a3			beq 	_IntegerCode 				; if clear, then we have two integers
.989d		4c 6e 9a	jmp $9a6e			jmp 	FloatingPointSub 							; otherwise at least one float.
.98a0						_StringData:
.98a0		4c 0e a6	jmp $a60e			jmp 	NotDoneError							; at least one string - don't know both are strings.
.98a3						_IntegerCode:
.98a3		b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate the second value.
.98a5		49 80		eor #$80			eor 	#$80
.98a7		95 51		sta $51,x			sta 	NSStatus+1,x
.98a9		80 bf		bra $986a			bra 	AddCode 					; and do the same code as add.
.98ab						AndInteger:
.98ab		fa		plx				plx
.98ac		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.98ae		15 51		ora $51,x			ora 	NSStatus+1,x
.98b0		0a		asl a				asl 	a 							; shift reference bit into sign bit
.98b1		0a		asl a				asl 	a
.98b2		10 05		bpl $98b9			bpl 	_NotRef
.98b4		48		pha				pha
.98b5		20 ea 9c	jsr $9cea			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.98b8		68		pla				pla
.98b9						_NotRef:
.98b9		0a		asl a				asl 	a
.98ba		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.98bc		15 a0		ora $a0,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.98be		15 a1		ora $a1,x			ora 	NSExponent+1,x
.98c0		f0 03		beq $98c5			beq 	_IntegerCode 				; if clear, then we have two integers
.98c2		4c 04 a6	jmp $a604			jmp 	TypeError 					; anything else, type mismatch.
.98c5						_IntegerCode:
.98c5		b5 60		lda $60,x			lda		NSMantissa0,x
.98c7		35 61		and $61,x			and 		NSMantissa0+1,x
.98c9		95 60		sta $60,x			sta 	NSMantissa0,x
.98cb		b5 70		lda $70,x			lda		NSMantissa1,x
.98cd		35 71		and $71,x			and 		NSMantissa1+1,x
.98cf		95 70		sta $70,x			sta 	NSMantissa1,x
.98d1		b5 80		lda $80,x			lda		NSMantissa2,x
.98d3		35 81		and $81,x			and 		NSMantissa2+1,x
.98d5		95 80		sta $80,x			sta 	NSMantissa2,x
.98d7		b5 90		lda $90,x			lda		NSMantissa3,x
.98d9		35 91		and $91,x			and 		NSMantissa3+1,x
.98db		95 90		sta $90,x			sta 	NSMantissa3,x
.98dd		74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.98df		60		rts				rts
.98e0						OraInteger:
.98e0		fa		plx				plx
.98e1		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.98e3		15 51		ora $51,x			ora 	NSStatus+1,x
.98e5		0a		asl a				asl 	a 							; shift reference bit into sign bit
.98e6		0a		asl a				asl 	a
.98e7		10 05		bpl $98ee			bpl 	_NotRef
.98e9		48		pha				pha
.98ea		20 ea 9c	jsr $9cea			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.98ed		68		pla				pla
.98ee						_NotRef:
.98ee		0a		asl a				asl 	a
.98ef		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.98f1		15 a0		ora $a0,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.98f3		15 a1		ora $a1,x			ora 	NSExponent+1,x
.98f5		f0 03		beq $98fa			beq 	_IntegerCode 				; if clear, then we have two integers
.98f7		4c 04 a6	jmp $a604			jmp 	TypeError 					; anything else, type mismatch.
.98fa						_IntegerCode:
.98fa		b5 60		lda $60,x			lda		NSMantissa0,x
.98fc		15 61		ora $61,x			ora 		NSMantissa0+1,x
.98fe		95 60		sta $60,x			sta 	NSMantissa0,x
.9900		b5 70		lda $70,x			lda		NSMantissa1,x
.9902		15 71		ora $71,x			ora 		NSMantissa1+1,x
.9904		95 70		sta $70,x			sta 	NSMantissa1,x
.9906		b5 80		lda $80,x			lda		NSMantissa2,x
.9908		15 81		ora $81,x			ora 		NSMantissa2+1,x
.990a		95 80		sta $80,x			sta 	NSMantissa2,x
.990c		b5 90		lda $90,x			lda		NSMantissa3,x
.990e		15 91		ora $91,x			ora 		NSMantissa3+1,x
.9910		95 90		sta $90,x			sta 	NSMantissa3,x
.9912		74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.9914		60		rts				rts
.9915						EorInteger:
.9915		fa		plx				plx
.9916		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9918		15 51		ora $51,x			ora 	NSStatus+1,x
.991a		0a		asl a				asl 	a 							; shift reference bit into sign bit
.991b		0a		asl a				asl 	a
.991c		10 05		bpl $9923			bpl 	_NotRef
.991e		48		pha				pha
.991f		20 ea 9c	jsr $9cea			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9922		68		pla				pla
.9923						_NotRef:
.9923		0a		asl a				asl 	a
.9924		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9926		15 a0		ora $a0,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9928		15 a1		ora $a1,x			ora 	NSExponent+1,x
.992a		f0 03		beq $992f			beq 	_IntegerCode 				; if clear, then we have two integers
.992c		4c 04 a6	jmp $a604			jmp 	TypeError 					; anything else, type mismatch.
.992f						_IntegerCode:
.992f		b5 60		lda $60,x			lda		NSMantissa0,x
.9931		55 61		eor $61,x			eor 		NSMantissa0+1,x
.9933		95 60		sta $60,x			sta 	NSMantissa0,x
.9935		b5 70		lda $70,x			lda		NSMantissa1,x
.9937		55 71		eor $71,x			eor 		NSMantissa1+1,x
.9939		95 70		sta $70,x			sta 	NSMantissa1,x
.993b		b5 80		lda $80,x			lda		NSMantissa2,x
.993d		55 81		eor $81,x			eor 		NSMantissa2+1,x
.993f		95 80		sta $80,x			sta 	NSMantissa2,x
.9941		b5 90		lda $90,x			lda		NSMantissa3,x
.9943		55 91		eor $91,x			eor 		NSMantissa3+1,x
.9945		95 90		sta $90,x			sta 	NSMantissa3,x
.9947		74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.9949		60		rts				rts
.994a						WordIndirect:
.994a		fa		plx				plx
.994b		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.994d		15 51		ora $51,x			ora 	NSStatus+1,x
.994f		0a		asl a				asl 	a 							; shift reference bit into sign bit
.9950		0a		asl a				asl 	a
.9951		10 05		bpl $9958			bpl 	_NotRef
.9953		48		pha				pha
.9954		20 ea 9c	jsr $9cea			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9957		68		pla				pla
.9958						_NotRef:
.9958		0a		asl a				asl 	a
.9959		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.995b		15 a0		ora $a0,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.995d		15 a1		ora $a1,x			ora 	NSExponent+1,x
.995f		f0 03		beq $9964			beq 	_IntegerCode 				; if clear, then we have two integers
.9961		4c 04 a6	jmp $a604			jmp 	TypeError 					; anything else, type mismatch.
.9964						_IntegerCode:
.9964		20 6a 98	jsr $986a			jsr 	AddCode 					; add the two values
.9967		a9 22		lda #$22			lda 	#NSBIsReference+2 			; make a 2 byte reference
.9969		95 50		sta $50,x			sta 	NSStatus,x
.996b		60		rts				rts
.996c						ByteIndirect:
.996c		fa		plx				plx
.996d		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.996f		15 51		ora $51,x			ora 	NSStatus+1,x
.9971		0a		asl a				asl 	a 							; shift reference bit into sign bit
.9972		0a		asl a				asl 	a
.9973		10 05		bpl $997a			bpl 	_NotRef
.9975		48		pha				pha
.9976		20 ea 9c	jsr $9cea			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9979		68		pla				pla
.997a						_NotRef:
.997a		0a		asl a				asl 	a
.997b		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.997d		15 a0		ora $a0,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.997f		15 a1		ora $a1,x			ora 	NSExponent+1,x
.9981		f0 03		beq $9986			beq 	_IntegerCode 				; if clear, then we have two integers
.9983		4c 04 a6	jmp $a604			jmp 	TypeError 					; anything else, type mismatch.
.9986						_IntegerCode:
.9986		20 6a 98	jsr $986a			jsr 	AddCode 					; add the two values
.9989		a9 21		lda #$21			lda 	#NSBIsReference+1 			; make a 1 byte reference
.998b		95 50		sta $50,x			sta 	NSStatus,x
.998d		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/tostring.asm

.998e						ConvertInt16:
.998e		85 60		sta $60				sta 	NSMantissa0 				; set up as 32 bit conversion
.9990		86 70		stx $70				stx 	NSMantissa1
.9992		64 80		stz $80				stz 	NSMantissa2
.9994		64 90		stz $90				stz 	NSMantissa3
.9996		64 50		stz $50				stz 	NSStatus 					; positive integer
.9998		a2 00		ldx #$00			ldx 	#0 							; stack level
.999a		a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.999c		80 00		bra $999e			bra 	ConvertInt32
.999e						ConvertInt32:
.999e		5a		phy				phy
.999f		a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.99a1		24 50		bit $50				bit 	NSStatus 					; output a - if not negative.
.99a3		10 08		bpl $99ad			bpl 	_CI32NotNeg
.99a5		48		pha				pha
.99a6		a9 2d		lda #$2d			lda 	#'-'
.99a8		99 43 06	sta $0643,y			sta 	numberBuffer,y
.99ab		c8		iny				iny
.99ac		68		pla				pla
.99ad						_CI32NotNeg:
.99ad		20 bb 99	jsr $99bb			jsr 	_CI32DivideConvert 			; recursive conversion
.99b0		a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.99b2		99 43 06	sta $0643,y			sta 	numberBuffer,y
.99b5		7a		ply				ply
.99b6		a2 06		ldx #$06			ldx 	#numberBuffer >> 8 			; return address in XA
.99b8		a9 43		lda #$43			lda 	#numberBuffer & $FF
.99ba		60		rts				rts
.99bb						_CI32DivideConvert:
.99bb		e8		inx				inx 								; write to next slot up
.99bc		20 84 a4	jsr $a484			jsr 	NSMSetByte 		 			; write the base out.
.99bf		ca		dex				dex
.99c0		20 e9 96	jsr $96e9			jsr 	Int32Divide 				; divide
.99c3		b5 60		lda $60,x			lda 	NSMantissa0,x 				; save remainder
.99c5		48		pha				pha
.99c6		20 a6 96	jsr $96a6			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.99c9		20 a4 a4	jsr $a4a4			jsr 	NSMIsZero 					; is it zero ?
.99cc		f0 05		beq $99d3			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.99ce		b5 61		lda $61,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.99d0		20 bb 99	jsr $99bb			jsr 	_CI32DivideConvert 			; and recusrively call.
.99d3						_CI32NoRecurse:
.99d3		68		pla				pla 								; remainder
.99d4		c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.99d6		90 02		bcc $99da			bcc 	_CI32NotHex
.99d8		69 26		adc #$26			adc 	#6+32
.99da						_CI32NotHex:
.99da		69 30		adc #$30			adc 	#48
.99dc		99 43 06	sta $0643,y			sta 	numberBuffer,y 				; write out and exit
.99df		c8		iny				iny
.99e0		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/expression.asm


;******  Processing file: ./common/expressions/../generated/precedence.dat

.99e1						PrecedenceLevel:
>99e1		04					.byte	 4	; $00 <<
>99e2		02					.byte	 2	; $01 <=
>99e3		02					.byte	 2	; $02 <>
>99e4		00					.byte	 0	; $03 !!3
>99e5		00					.byte	 0	; $04 ><
>99e6		02					.byte	 2	; $05 >=
>99e7		04					.byte	 4	; $06 >>
>99e8		00					.byte	 0	; $07 !!7
>99e9		00					.byte	 0	; $08 !!8
>99ea		00					.byte	 0	; $09 !!9
>99eb		00					.byte	 0	; $0a !!10
>99ec		00					.byte	 0	; $0b !!11
>99ed		00					.byte	 0	; $0c !!12
>99ee		00					.byte	 0	; $0d !!13
>99ef		00					.byte	 0	; $0e !!14
>99f0		00					.byte	 0	; $0f !!15
>99f1		00					.byte	 0	; $10 @
>99f2		00					.byte	 0	; $11 !!17
>99f3		00					.byte	 0	; $12 !!18
>99f4		00					.byte	 0	; $13 [
>99f5		04					.byte	 4	; $14 \
>99f6		00					.byte	 0	; $15 ]
>99f7		01					.byte	 1	; $16 ^
>99f8		00					.byte	 0	; $17 _
>99f9		00					.byte	 0	; $18 `
>99fa		00					.byte	 0	; $19 !!25
>99fb		00					.byte	 0	; $1a !!26
>99fc		00					.byte	 0	; $1b {
>99fd		01					.byte	 1	; $1c |
>99fe		00					.byte	 0	; $1d }
>99ff		00					.byte	 0	; $1e ~
>9a00		00					.byte	 0	; $1f <7F>
>9a01		00					.byte	 0	; $20
>9a02		05					.byte	 5	; $21 !
>9a03		00					.byte	 0	; $22 "
>9a04		00					.byte	 0	; $23 #
>9a05		05					.byte	 5	; $24 $
>9a06		04					.byte	 4	; $25 %
>9a07		01					.byte	 1	; $26 &
>9a08		00					.byte	 0	; $27 '
>9a09		00					.byte	 0	; $28 (
>9a0a		00					.byte	 0	; $29 )
>9a0b		04					.byte	 4	; $2a *
>9a0c		03					.byte	 3	; $2b +
>9a0d		00					.byte	 0	; $2c ,
>9a0e		03					.byte	 3	; $2d -
>9a0f		00					.byte	 0	; $2e .
>9a10		04					.byte	 4	; $2f /
>9a11		00					.byte	 0	; $30 0
>9a12		00					.byte	 0	; $31 1
>9a13		00					.byte	 0	; $32 2
>9a14		00					.byte	 0	; $33 3
>9a15		00					.byte	 0	; $34 4
>9a16		00					.byte	 0	; $35 5
>9a17		00					.byte	 0	; $36 6
>9a18		00					.byte	 0	; $37 7
>9a19		00					.byte	 0	; $38 8
>9a1a		00					.byte	 0	; $39 9
>9a1b		00					.byte	 0	; $3a :
>9a1c		00					.byte	 0	; $3b ;
>9a1d		02					.byte	 2	; $3c <
>9a1e		02					.byte	 2	; $3d =
>9a1f		02					.byte	 2	; $3e >
>9a20		05					.byte	 5	; $3f ?

;******  Return to file: ./common/expressions/expression.asm

.9a21						EvaluateExpressionAt0:
.9a21		a2 00		ldx #$00			ldx 	#0 							; bottom stack level
.9a23						EvaluateExpression:
.9a23		a9 00		lda #$00			lda 	#0 							; lowest precedence level
.9a25						EvaluateExpressionAtPrecedence:
.9a25		48		pha				pha 								; save precedence level
.9a26		20 76 9e	jsr $9e76			jsr 	EvaluateTerm 				; evaluate term into level X.
.9a29		68		pla				pla 								; restore precedence level.
.9a2a						_EXPRLoop:
.9a2a		85 36		sta $36				sta 	zTemp0 						; save current precedence level.
.9a2c		b1 30		lda ($30),y			lda 	(codePtr),y
.9a2e		c9 40		cmp #$40			cmp		#$40 						; if >= $40 cannot be an operator
.9a30		b0 25		bcs $9a57			bcs 	_EXPRExit
.9a32		da		phx				phx 								; read the operator precedence
.9a33		aa		tax				tax
.9a34		bd e1 99	lda $99e1,x			lda 	PrecedenceLevel,x
.9a37		fa		plx				plx
.9a38		c9 00		cmp #$00			cmp 	#0							; if zero exit (not an operator)
.9a3a		f0 1b		beq $9a57			beq 	_EXPRExit
.9a3c		85 37		sta $37				sta 	zTemp0+1 					; save operator precedence level.
.9a3e		a5 36		lda $36				lda 	zTemp0 						; compare current precedence vs. operator precedence
.9a40		c5 37		cmp $37				cmp 	zTemp0+1
.9a42		b0 13		bcs $9a57			bcs		_EXPRExit 					; if current >= operator exit
.9a44		48		pha				pha 								; save current precedence.
.9a45		b1 30		lda ($30),y			lda 	(codePtr),y
.9a47		c8		iny				iny
.9a48		48		pha				pha
.9a49		a5 37		lda $37				lda 	zTemp0+1 					; get operator precedence level
.9a4b		e8		inx				inx 								; work out the right hand side.
.9a4c		20 25 9a	jsr $9a25			jsr 	EvaluateExpressionAtPrecedence
.9a4f		ca		dex				dex
.9a50		68		pla				pla 								; get operator, call the code.
.9a51		20 5a 9a	jsr $9a5a			jsr 	_EXPRCaller
.9a54		68		pla				pla 								; restore precedence level
.9a55		80 d3		bra $9a2a			bra 	_EXPRLoop 					; and go round.
.9a57						_EXPRExit:
.9a57		a5 36		lda $36				lda 	zTemp0 						; A = current precedence level.
.9a59		60		rts				rts
.9a5a						_EXPRCaller:
.9a5a		e0 10		cpx #$10			cpx		#MathStackSize
.9a5c		b0 06		bcs $9a64			bge		_EXPRTooComplex
.9a5e		da		phx				phx 								; save on stack, first thing is to restore it
.9a5f		0a		asl a				asl 	a 							; double so can use vectors into X
.9a60		aa		tax				tax
.9a61		7c 86 91	jmp ($9186,x)			jmp 	(VectorSetPunc,x) 			; and go to the code.
.9a64						_EXPRTooComplex:
.9a64		a9 1e		lda #$1e		lda	#30
.9a66		4c 19 95	jmp $9519		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/addsub.asm

.9a69						FloatingPointAdd:
.9a69		20 df 9b	jsr $9bdf			jsr 	FloatPrepare 				; prepare for floats
.9a6c		80 09		bra $9a77			bra 	FloatAdd
.9a6e						FloatingPointSub:
.9a6e		20 df 9b	jsr $9bdf			jsr 	FloatPrepare 				; prepare for floats
.9a71						FloatSubtract:
.9a71		b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate FPB
.9a73		49 80		eor #$80			eor 	#$80
.9a75		95 51		sta $51,x			sta 	NSStatus+1,x				; and fall through.
.9a77						FloatAdd:
.9a77		48		pha				pha
.9a78		5a		phy				phy
.9a79		20 ee 9b	jsr $9bee			jsr 	NSNormalise 				; normalise S[X]
.9a7c		f0 51		beq $9acf			beq 	_FAReturn1
.9a7e		e8		inx				inx 								; normalise S[X+1]
.9a7f		20 ee 9b	jsr $9bee			jsr 	NSNormalise
.9a82		ca		dex				dex
.9a83		c9 00		cmp #$00			cmp 	#0
.9a85		f0 60		beq $9ae7			beq 	_FAExit 					; if so, just return A
.9a87		b5 a0		lda $a0,x			lda 	NSExponent,x 				; are the exponents the same ?
.9a89		d5 a1		cmp $a1,x			cmp 	NSExponent+1,x
.9a8b		f0 18		beq $9aa5			beq 	_FAExponentsEqual
.9a8d		b5 a0		lda $a0,x			lda 	NSExponent,x 				; work out the larger exponent
.9a8f		a8		tay				tay
.9a90		38		sec				sec 								; do a signed comparison of the exponents.
.9a91		f5 a1		sbc $a1,x			sbc 	NSExponent+1,x
.9a93		50 02		bvc $9a97			bvc 	_FANoSignedChange
.9a95		49 80		eor #$80			eor 	#$80
.9a97						_FANoSignedChange:
.9a97		29 80		and #$80			and 	#$80
.9a99		10 02		bpl $9a9d			bpl 	_FAHaveMax
.9a9b		b4 a1		ldy $a1,x			ldy 	NSExponent+1,x
.9a9d						_FAHaveMax:
.9a9d		20 ea 9a	jsr $9aea			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.9aa0		e8		inx				inx
.9aa1		20 ea 9a	jsr $9aea			jsr 	_FAShiftToExponent
.9aa4		ca		dex				dex
.9aa5						_FAExponentsEqual:
.9aa5		b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs the same
.9aa7		55 51		eor $51,x			eor 	NSStatus+1,x
.9aa9		30 0e		bmi $9ab9			bmi 	_FADifferentSigns
.9aab		20 19 98	jsr $9819			jsr 	AddTopTwoStack 				; do the add of the mantissae
.9aae		b5 90		lda $90,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.9ab0		10 35		bpl $9ae7			bpl 	_FAExit 					; if no, we are done.
.9ab2		20 9b a4	jsr $a49b			jsr 	NSMShiftRight 				; shift A right, renormalising it.
.9ab5		f6 a0		inc $a0,x			inc 	NSExponent,x 				; bump the exponent and exit
.9ab7		80 2e		bra $9ae7			bra 	_FAExit
.9ab9						_FADifferentSigns:
.9ab9		20 33 98	jsr $9833			jsr 	SubTopTwoStack 				; subtract mantissa B from A
.9abc		b5 90		lda $90,x			lda 	NSMantissa3,x 				; is the result negative ?
.9abe		10 06		bpl $9ac6			bpl 	_FACheckZero 				; if no, check for -0
.9ac0		20 44 a4	jsr $a444			jsr 	NSMNegate 					; netate result
.9ac3		20 4b a4	jsr $a44b			jsr 	NSMNegateMantissa 			; negate (2'c) the mantissa
.9ac6						_FACheckZero:
.9ac6		20 a4 a4	jsr $a4a4			jsr 	NSMIsZero	 				; check for -0
.9ac9		d0 1c		bne $9ae7			bne 	_FAExit
.9acb		74 50		stz $50,x			stz 	NSStatus,x
.9acd		80 18		bra $9ae7			bra 	_FAExit
.9acf						_FAReturn1:
.9acf		b5 61		lda $61,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.9ad1		95 60		sta $60,x			sta 	NSMantissa0,x
.9ad3		b5 71		lda $71,x			lda 	NSMantissa1+1,x
.9ad5		95 70		sta $70,x			sta 	NSMantissa1,x
.9ad7		b5 81		lda $81,x			lda 	NSMantissa2+1,x
.9ad9		95 80		sta $80,x			sta 	NSMantissa2,x
.9adb		b5 91		lda $91,x			lda 	NSMantissa3+1,x
.9add		95 90		sta $90,x			sta 	NSMantissa3,x
.9adf		b5 a1		lda $a1,x			lda 	NSExponent+1,x
.9ae1		95 a0		sta $a0,x			sta 	NSExponent,x
.9ae3		b5 51		lda $51,x			lda 	NSStatus+1,x
.9ae5		95 50		sta $50,x			sta 	NSStatus,x
.9ae7						_FAExit:
.9ae7		7a		ply				ply
.9ae8		68		pla				pla
.9ae9		60		rts				rts
.9aea						_FAShiftToExponent:
.9aea						_FAShiftToExponent2:
.9aea		98		tya				tya 								; compare Y to exponent
.9aeb		d5 a0		cmp $a0,x			cmp 	NSExponent,x 				; reached the exponent required ?
.9aed		f0 07		beq $9af6			beq 	_FASEExit 					; exit if so.
.9aef		20 9b a4	jsr $a49b			jsr 	NSMShiftRight	 			; shift the mantissa right
.9af2		f6 a0		inc $a0,x			inc 	NSExponent,x 				; increment exponent
.9af4		80 f4		bra $9aea			bra 	_FAShiftToExponent2
.9af6						_FASEExit:
.9af6		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/compare.asm

.9af7						CompareFloat:
.9af7		20 71 9a	jsr $9a71			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.9afa		b5 70		lda $70,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.9afc		29 f8		and #$f8			and 	#$F8
.9afe		15 80		ora $80,x			ora 	NSMantissa2,x
.9b00		15 90		ora $90,x			ora 	NSMantissa3,x
.9b02		f0 08		beq $9b0c			beq 	_FCExit 					; zero, so approximately identical
.9b04		a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.9b06		34 50		bit $50,x			bit 	NSStatus,x
.9b08		10 02		bpl $9b0c			bpl 	_FCExit
.9b0a						_FCNegative:
.9b0a		a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.9b0c						_FCExit:
.9b0c		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/divide.asm

.9b0d						FDivideCommand:
.9b0d		fa		plx				plx	 								; restore stack position
.9b0e		20 df 9b	jsr $9bdf			jsr 	FloatPrepare 				; prepare for floats
.9b11						FloatDivide:
.9b11		48		pha				pha
.9b12		e8		inx				inx
.9b13		20 ee 9b	jsr $9bee			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.9b16		ca		dex				dex
.9b17		c9 00		cmp #$00			cmp 	#0
.9b19		f0 1d		beq $9b38			beq 	_FDZero
.9b1b		20 ee 9b	jsr $9bee			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.9b1e		f0 16		beq $9b36			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.9b20		20 0a 97	jsr $970a			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.9b23		20 a6 96	jsr $96a6			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.9b26		20 ee 9b	jsr $9bee			jsr		NSNormalise 				; renormalise
.9b29		20 9a 97	jsr $979a			jsr 	CalculateSign 				; calculate result sign
.9b2c		b5 a0		lda $a0,x			lda 	NSExponent,x 				; calculate exponent
.9b2e		38		sec				sec
.9b2f		f5 a1		sbc $a1,x			sbc 	NSExponent+1,x
.9b31		38		sec				sec
.9b32		e9 1e		sbc #$1e			sbc 	#30
.9b34		95 a0		sta $a0,x			sta 	NSExponent,x
.9b36						_FDExit:
.9b36		68		pla				pla
.9b37		60		rts				rts
.9b38						_FDZero:
.9b38		a9 03		lda #$03		lda	#3
.9b3a		4c 19 95	jmp $9519		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/fractional.asm

.9b3d						FloatFractionalPart:
.9b3d		5a		phy				phy
.9b3e		b5 50		lda $50,x			lda 	NSStatus,x 					; take absolute value
.9b40		29 7f		and #$7f			and 	#$7F
.9b42		95 50		sta $50,x			sta 	NSStatus,x
.9b44		20 ee 9b	jsr $9bee			jsr 	NSNormalise
.9b47		b5 a0		lda $a0,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.9b49		38		sec				sec
.9b4a		e9 e0		sbc #$e0			sbc 	#$E0
.9b4c		90 29		bcc $9b77			bcc 	_FFPExit 					; already fractional
.9b4e		c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.9b50		b0 22		bcs $9b74			bcs 	_FFPZero
.9b52		a8		tay				tay 								; put count to do in Y
.9b53		b5 90		lda $90,x			lda 	NSMantissa3,x 				; do each in turn.
.9b55		20 79 9b	jsr $9b79			jsr 	_FFPPartial
.9b58		95 90		sta $90,x			sta 	NSMantissa3,x
.9b5a		b5 80		lda $80,x			lda 	NSMantissa2,x
.9b5c		20 79 9b	jsr $9b79			jsr 	_FFPPartial
.9b5f		95 80		sta $80,x			sta 	NSMantissa2,x
.9b61		b5 70		lda $70,x			lda 	NSMantissa1,x
.9b63		20 79 9b	jsr $9b79			jsr 	_FFPPartial
.9b66		95 70		sta $70,x			sta 	NSMantissa1,x
.9b68		b5 60		lda $60,x			lda 	NSMantissa0,x
.9b6a		20 79 9b	jsr $9b79			jsr 	_FFPPartial
.9b6d		95 60		sta $60,x			sta 	NSMantissa0,x
.9b6f		20 a4 a4	jsr $a4a4			jsr 	NSMIsZero 					; zeroed check.
.9b72		d0 03		bne $9b77			bne 	_FFPExit
.9b74						_FFPZero:
.9b74		20 82 a4	jsr $a482			jsr 	NSMSetZero
.9b77						_FFPExit:
.9b77		7a		ply				ply
.9b78		60		rts				rts
.9b79						_FFPPartial:
.9b79		c0 00		cpy #$00			cpy 	#0 							; no more to do
.9b7b		f0 17		beq $9b94			beq 	_FFFPPExit
.9b7d		c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.9b7f		b0 0c		bcs $9b8d			bcs 	_FFFPPWholeByte
.9b81		5a		phy				phy
.9b82						_FFFPPLeft:
.9b82		0a		asl a				asl 	a
.9b83		88		dey				dey
.9b84		d0 fc		bne $9b82			bne 	_FFFPPLeft
.9b86		7a		ply				ply
.9b87						_FFFPPRight:
.9b87		4a		lsr a				lsr 	a
.9b88		88		dey				dey
.9b89		d0 fc		bne $9b87			bne 	_FFFPPRight
.9b8b		80 07		bra $9b94			bra 	_FFFPPExit
.9b8d						_FFFPPWholeByte:
.9b8d		98		tya				tya 								; subtract 8 from count
.9b8e		38		sec				sec
.9b8f		e9 08		sbc #$08			sbc 	#8
.9b91		a8		tay				tay
.9b92		a9 00		lda #$00			lda 	#0 							; and clear all
.9b94						_FFFPPExit:
.9b94		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/integer.asm

.9b95						FloatIntegerPart:
.9b95		48		pha				pha
.9b96		b5 a0		lda $a0,x			lda 	NSExponent,x 				; is it integer already ?
.9b98		f0 1d		beq $9bb7			beq 	_FIPExit 					; if so do nothing
.9b9a		20 a4 a4	jsr $a4a4			jsr 	NSMIsZero 					; is it zero ?
.9b9d		f0 15		beq $9bb4			beq 	_FIPZero 					; if so return zero.
.9b9f		20 ee 9b	jsr $9bee			jsr 	NSNormalise 				; normalise
.9ba2		f0 10		beq $9bb4			beq 	_FIPZero 					; normalised to zero, exit zero
.9ba4						_FIPShift:
.9ba4		b5 a0		lda $a0,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.9ba6		10 07		bpl $9baf			bpl 	_FIPCheckZero
.9ba8		20 9b a4	jsr $a49b			jsr 	NSMShiftRight 				; shift mantissa right
.9bab		f6 a0		inc $a0,x			inc 	NSExponent,x 				; bump exponent
.9bad		80 f5		bra $9ba4			bra 	_FIPShift
.9baf						_FIPCheckZero:
.9baf		20 a4 a4	jsr $a4a4			jsr 	NSMIsZero 					; avoid -0 problem
.9bb2		d0 03		bne $9bb7			bne 	_FIPExit 					; set to zero if mantissa zero.
.9bb4						_FIPZero:
.9bb4		20 82 a4	jsr $a482			jsr 	NSMSetZero
.9bb7						_FIPExit:
.9bb7		68		pla				pla
.9bb8		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/multiply.asm

.9bb9						FloatingPointMultiply:
.9bb9		20 df 9b	jsr $9bdf			jsr 	FloatPrepare 				; prepare for floats
.9bbc						FloatMultiply:
.9bbc		48		pha				pha
.9bbd		20 ee 9b	jsr $9bee			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.9bc0		f0 18		beq $9bda			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.9bc2		e8		inx				inx
.9bc3		20 ee 9b	jsr $9bee			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.9bc6		ca		dex				dex
.9bc7		c9 00		cmp #$00			cmp 	#0
.9bc9		f0 0c		beq $9bd7			beq 	_FDSetZero
.9bcb		20 5c 97	jsr $975c			jsr 	MultiplyShort 				; calculate the result.
.9bce		75 a0		adc $a0,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.9bd0		18		clc				clc
.9bd1		75 a1		adc $a1,x			adc 	NSExponent+1,x
.9bd3		95 a0		sta $a0,x			sta 	NSExponent,x
.9bd5		80 03		bra $9bda			bra 	_FDExit
.9bd7						_FDSetZero:
.9bd7		20 82 a4	jsr $a482			jsr 	NSMSetZero 					; return 0
.9bda						_FDExit:
.9bda		20 ee 9b	jsr $9bee			jsr 	NSNormalise 				; normalise the result
.9bdd		68		pla				pla
.9bde		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/utility.asm

.9bdf						FloatPrepare:
.9bdf		20 ea 9c	jsr $9cea			jsr 	DereferenceTopTwo 			; dereference the top two values
.9be2		b5 50		lda $50,x			lda 	NSStatus,x 					; check ints/floats, either will do.
.9be4		15 51		ora $51,x			ora 	NSStatus+1,x
.9be6		29 10		and #$10			and 	#NSBIsString
.9be8		d0 01		bne $9beb			bne 	_FDType
.9bea		60		rts				rts
.9beb						_FDType:
.9beb		4c 04 a6	jmp $a604			jmp 	TypeError
.9bee						NSNormalise:
.9bee		b5 50		lda $50,x			lda 	NSStatus,x 					; make float, keep sign
.9bf0		29 80		and #$80			and 	#$80
.9bf2		09 08		ora #$08			ora 	#NSTFloat
.9bf4		95 50		sta $50,x			sta 	NSStatus,x
.9bf6		20 a4 a4	jsr $a4a4			jsr 	NSMIsZero 					; if zero exit
.9bf9		d0 07		bne $9c02			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.9bfb		16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.9bfd		76 50		ror $50,x			ror 	NSStatus,x 					; (no -0)
.9bff		a9 00		lda #$00			lda 	#0 							; set Z flag
.9c01		60		rts				rts
.9c02						_NSNormaliseOptimise:
.9c02		b5 90		lda $90,x			lda 	NSMantissa3,x 				; upper byte zero ?
.9c04		d0 19		bne $9c1f			bne 	_NSNormaliseLoop
.9c06		b5 80		lda $80,x			lda 	NSMantissa2,x 				; byte normalise
.9c08		30 15		bmi $9c1f			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.9c0a		95 90		sta $90,x			sta 	NSMantissa3,x
.9c0c		b5 70		lda $70,x			lda 	NSMantissa1,x
.9c0e		95 80		sta $80,x			sta 	NSMantissa2,x
.9c10		b5 60		lda $60,x			lda 	NSMantissa0,x
.9c12		95 70		sta $70,x			sta 	NSMantissa1,x
.9c14		74 60		stz $60,x			stz 	NSMantissa0,x
.9c16		b5 a0		lda $a0,x			lda 	NSExponent,x
.9c18		38		sec				sec
.9c19		e9 08		sbc #$08			sbc 	#8
.9c1b		95 a0		sta $a0,x			sta 	NSExponent,x
.9c1d		80 e3		bra $9c02			bra 	_NSNormaliseOptimise
.9c1f						_NSNormaliseLoop:
.9c1f		34 90		bit $90,x			bit 	NSMantissa3,x 				; bit 30 set ?
.9c21		70 07		bvs $9c2a			bvs 	_NSNExit 					; exit if so with Z flag clear
.9c23		20 91 a4	jsr $a491			jsr 	NSMShiftLeft 				; shift mantissa left
.9c26		d6 a0		dec $a0,x			dec 	NSExponent,x 				; adjust exponent
.9c28		80 f5		bra $9c1f			bra 	_NSNormaliseLoop
.9c2a						_NSNExit:
.9c2a		a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.9c2c		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignnumber.asm

.9c2d						AssignNumber:
.9c2d		5a		phy				phy
.9c2e		b5 60		lda $60,x			lda 	NSMantissa0,x 				; copy mantissa0/1 to zTemp0
.9c30		85 36		sta $36				sta 	zTemp0
.9c32		b5 70		lda $70,x			lda 	NSMantissa1,x
.9c34		85 37		sta $37				sta 	zTemp0+1
.9c36		b5 50		lda $50,x			lda 	NSStatus,x 					; clear reference bits
.9c38		29 df		and #$df			and 	#(NSBIsReference ^ $FF)
.9c3a		95 50		sta $50,x			sta 	NSStatus,x
.9c3c		29 18		and #$18			and 	#NSBTypeMask				; assigning to a float ?
.9c3e		c9 08		cmp #$08			cmp 	#NSTFloat
.9c40		f0 24		beq $9c66			beq 	_ANFloat
.9c42		b5 a1		lda $a1,x			lda		NSExponent+1,x 				; is it a float
.9c44		f0 03		beq $9c49			beq		_ANNotFloat
.9c46		4c ff a5	jmp $a5ff			jmp 	RangeError					; if it is, report an error.
.9c49						_ANNotFloat:
.9c49		b5 50		lda $50,x			lda 	NSStatus,x 					; check if byte/word reference.
.9c4b		29 03		and #$03			and 	#3
.9c4d		d0 05		bne $9c54			bne 	_ANByteWord
.9c4f		20 71 9c	jsr $9c71			jsr 	_ANCopy4PackSign 			; copy all 4 bytes and sign
.9c52		80 1b		bra $9c6f			bra 	_ANExit
.9c54						_ANByteWord:
.9c54		48		pha				pha 								; save count
.9c55		b5 61		lda $61,x			lda 	NSMantissa0+1,x 			; do byte
.9c57		92 36		sta ($36)			sta 	(zTemp0)
.9c59		68		pla				pla
.9c5a		c9 01		cmp #$01			cmp	 	#1
.9c5c		f0 11		beq $9c6f			beq 	_ANExit
.9c5e		b5 71		lda $71,x			lda 	NSMantissa1+1,x 			; do word
.9c60		a0 01		ldy #$01			ldy 	#1
.9c62		91 36		sta ($36),y			sta 	(zTemp0),y
.9c64		80 09		bra $9c6f			bra 	_ANExit
.9c66						_ANFloat:
.9c66		20 71 9c	jsr $9c71			jsr 	_ANCopy4PackSign 			; write all 4 bytes and packed sign
.9c69		b5 a1		lda $a1,x			lda 	NSExponent+1,x 				; copy exponent to slot 4
.9c6b		a0 04		ldy #$04			ldy 	#4
.9c6d		91 36		sta ($36),y			sta 	(zTemp0),y
.9c6f						_ANExit:
.9c6f		7a		ply				ply
.9c70		60		rts				rts
.9c71						_ANCopy4PackSign:
.9c71		a0 03		ldy #$03			ldy 	#3
.9c73		b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign bit into status
.9c75		29 80		and #$80			and 	#$80 						; put into high bit of mantissa 3
.9c77		15 91		ora $91,x			ora 	NSMantissa3+1,x
.9c79		91 36		sta ($36),y			sta 	(zTemp0),y
.9c7b		88		dey				dey
.9c7c		b5 81		lda $81,x			lda 	NSMantissa2+1,x
.9c7e		91 36		sta ($36),y			sta 	(zTemp0),y
.9c80		88		dey				dey
.9c81		b5 71		lda $71,x			lda 	NSMantissa1+1,x
.9c83		91 36		sta ($36),y			sta 	(zTemp0),y
.9c85		88		dey				dey
.9c86		b5 61		lda $61,x			lda 	NSMantissa0+1,x
.9c88		91 36		sta ($36),y			sta 	(zTemp0),y
.9c8a		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignstring.asm

.9c8b						AssignString:
.9c8b		5a		phy				phy
.9c8c		b5 61		lda $61,x			lda 	NSMantissa0+1,x
.9c8e		85 38		sta $38				sta 	zTemp1
.9c90		b5 71		lda $71,x			lda 	NSMantissa1+1,x
.9c92		85 39		sta $39				sta 	zTemp1+1
.9c94		b5 60		lda $60,x			lda 	NSMantissa0,x
.9c96		85 36		sta $36				sta 	zTemp0
.9c98		b5 70		lda $70,x			lda 	NSMantissa1,x
.9c9a		85 37		sta $37				sta 	zTemp0+1
.9c9c		a0 01		ldy #$01			ldy 	#1 							; the high byte of the target address
.9c9e		b1 36		lda ($36),y			lda 	(zTemp0),y
.9ca0		f0 23		beq $9cc5			beq 	_ASNewStringRequired 		; if zero, a new string is required.
.9ca2		38		sec				sec 								; put Address-2 in zsTemp - this is the size/status/string record
.9ca3		b2 36		lda ($36)			lda 	(zTemp0) 					; of concreted strings
.9ca5		e9 02		sbc #$02			sbc 	#2
.9ca7		85 3c		sta $3c				sta 	zsTemp
.9ca9		a0 01		ldy #$01			ldy 	#1
.9cab		b1 36		lda ($36),y			lda 	(zTemp0),y
.9cad		e9 00		sbc #$00			sbc 	#0
.9caf		85 3d		sta $3d				sta 	zsTemp+1
.9cb1		a0 ff		ldy #$ff			ldy 	#$FF 						; get length of new string
.9cb3						_ASGetLength:
.9cb3		c8		iny				iny
.9cb4		b1 38		lda ($38),y			lda 	(zTemp1),y
.9cb6		d0 fb		bne $9cb3			bne 	_ASGetLength
.9cb8		98		tya				tya 								; is this length <= current length
.9cb9		d2 3c		cmp ($3c)			cmp 	(zsTemp)
.9cbb		90 1e		bcc $9cdb			bcc 	_ASCopyString
.9cbd		f0 1c		beq $9cdb			beq 	_ASCopyString
.9cbf		a9 80		lda #$80			lda 	#$80 						; mark as unused.
.9cc1		a0 01		ldy #$01			ldy 	#1
.9cc3		91 3c		sta ($3c),y			sta 	(zsTemp),y
.9cc5						_ASNewStringRequired:
.9cc5		e8		inx				inx 								; concrete the new string.
.9cc6		20 0c b7	jsr $b70c			jsr 	StringConcrete				; (breaks zTemp1/2, not zTemp0 and zsTemp)
.9cc9		ca		dex				dex
.9cca		18		clc				clc
.9ccb		b5 61		lda $61,x			lda 	NSMantissa0+1,x 			; copy that new address to the reference.
.9ccd		69 02		adc #$02			adc 	#2 							; add two to point at the data.
.9ccf		92 36		sta ($36)			sta 	(zTemp0)
.9cd1		b5 71		lda $71,x			lda 	NSMantissa1+1,x
.9cd3		69 00		adc #$00			adc 	#0
.9cd5		a0 01		ldy #$01			ldy 	#1
.9cd7		91 36		sta ($36),y			sta 	(zTemp0),y
.9cd9		80 0d		bra $9ce8			bra 	_ASExit
.9cdb						_ASCopyString:
.9cdb		a0 00		ldy #$00			ldy 	#0
.9cdd						_ASCopyLoop:
.9cdd		b1 38		lda ($38),y			lda 	(zTemp1),y
.9cdf		c8		iny				iny
.9ce0		c8		iny				iny
.9ce1		91 3c		sta ($3c),y			sta 	(zsTemp),y
.9ce3		88		dey				dey
.9ce4		c9 00		cmp #$00			cmp 	#0
.9ce6		d0 f5		bne $9cdd			bne 	_ASCopyLoop
.9ce8						_ASExit:
.9ce8		7a		ply				ply
.9ce9		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/dereference.asm

.9cea						DereferenceTopTwo:
.9cea		e8		inx				inx
.9ceb		20 ef 9c	jsr $9cef			jsr 	Dereference 				; deref x+1
.9cee		ca		dex				dex  								; falls through to deref x
.9cef						Dereference:
.9cef		b5 50		lda $50,x			lda 	NSStatus,x 					; get the status byte
.9cf1		29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.9cf3		f0 48		beq $9d3d			beq 	_DRFExit 					; not a reference, so exit.
.9cf5		5a		phy				phy
.9cf6		b5 60		lda $60,x			lda 	NSMantissa0,x 				; copy address to dereference into zTemp0
.9cf8		85 36		sta $36				sta 	zTemp0
.9cfa		b5 70		lda $70,x			lda 	NSMantissa1,x
.9cfc		85 37		sta $37				sta 	zTemp0+1
.9cfe		74 70		stz $70,x			stz 	NSMantissa1,x 				; clear second byte.
.9d00		b2 36		lda ($36)			lda 	(zTemp0) 					; do the first byte
.9d02		95 60		sta $60,x			sta 	NSMantissa0,x
.9d04		b5 50		lda $50,x			lda 	NSStatus,x 					; get status byte.
.9d06		29 18		and #$18			and 	#NSBTypeMask 				; what type is it ?
.9d08		c9 10		cmp #$10			cmp 	#NSTString 					; if string, dereference two
.9d0a		f0 0e		beq $9d1a			beq 	_DRFDereferenceTwo
.9d0c		c9 08		cmp #$08			cmp 	#NSTFloat 					; if float, do full dereference.
.9d0e		f0 2f		beq $9d3f			beq 	_DRFFull
.9d10		b5 50		lda $50,x			lda 	NSStatus,x 					; must be integer - how many bytes ?
.9d12		29 03		and #$03			and 	#3
.9d14		f0 29		beq $9d3f			beq 	_DRFFull 					; the whole word
.9d16		c9 01		cmp #$01			cmp 	#1 							; is it 10 (e.g. 2 bytes)
.9d18		f0 06		beq $9d20			beq		_DRFClear23 				; no, one byte, clear 2 & 3 and exit
.9d1a						_DRFDereferenceTwo:
.9d1a		a0 01		ldy #$01			ldy 	#1
.9d1c		b1 36		lda ($36),y			lda 	(zTemp0),y
.9d1e		95 70		sta $70,x			sta 	NSMantissa1,x
.9d20						_DRFClear23:
.9d20		74 80		stz $80,x			stz 	NSMantissa2,x 				; clear upper bytes, only read 1 or 2 bytes
.9d22		74 90		stz $90,x			stz 	NSMantissa3,x
.9d24		b5 50		lda $50,x			lda 	NSStatus,x 					; make it a value of that type.
.9d26		29 18		and #$18			and 	#NSBTypeMask
.9d28		95 50		sta $50,x			sta 	NSStatus,x 					; and fall through.
.9d2a		c9 10		cmp #$10			cmp 	#NSTString  				; is it a string
.9d2c		d0 0e		bne $9d3c			bne 	_DRFNotString
.9d2e		b5 60		lda $60,x			lda 	NSMantissa0,x 				; check address is zero
.9d30		15 70		ora $70,x			ora 	NSMantissa1,x
.9d32		d0 08		bne $9d3c			bne 	_DRFNotString
.9d34		a9 3e		lda #$3e			lda 	#_DRFNullString & $FF 		; if so, return reference to ""
.9d36		95 60		sta $60,x			sta 	NSMantissa0,x
.9d38		a9 9d		lda #$9d			lda 	#_DRFNullString >> 8
.9d3a		95 70		sta $70,x			sta 	NSMantissa1,x
.9d3c						_DRFNotString
.9d3c		7a		ply				ply 								; restore Y and exit
.9d3d						_DRFExit:
.9d3d		60		rts				rts
.9d3e						_DRFNullString:
>9d3e		00						.byte 	0
.9d3f						_DRFFull:
.9d3f		a0 01		ldy #$01			ldy 	#1 							; get remaining 3 bytes.
.9d41		b1 36		lda ($36),y			lda 	(zTemp0),y
.9d43		95 70		sta $70,x			sta 	NSMantissa1,x
.9d45		c8		iny				iny
.9d46		b1 36		lda ($36),y			lda 	(zTemp0),y
.9d48		95 80		sta $80,x			sta 	NSMantissa2,x
.9d4a		c8		iny				iny
.9d4b		b1 36		lda ($36),y			lda 	(zTemp0),y
.9d4d		95 90		sta $90,x			sta 	NSMantissa3,x
.9d4f		74 a0		stz $a0,x			stz 	NSExponent,x 				; clear exponent.
.9d51		b5 50		lda $50,x			lda		NSStatus,x 					; see if type is integer
.9d53		29 18		and #$18			and 	#NSBTypeMask  				; type information only
.9d55		95 50		sta $50,x			sta 	NSStatus,x 					; update it back.
.9d57		f0 05		beq $9d5e			beq 	_DRFNoExponent
.9d59		c8		iny				iny 								; if not, read the exponent as well.
.9d5a		b1 36		lda ($36),y			lda 	(zTemp0),y
.9d5c		95 a0		sta $a0,x			sta 	NSExponent,x
.9d5e						_DRFNoExponent:
.9d5e		b5 90		lda $90,x			lda 	NSMantissa3,x 				; is the most significant bit set ?
.9d60		10 0a		bpl $9d6c			bpl 	_DRFExit2 					; if not, then exit.
.9d62		29 7f		and #$7f			and 	#$7F 						; clear that bit.
.9d64		95 90		sta $90,x			sta 	NSMantissa3,x
.9d66		b5 50		lda $50,x			lda 	NSStatus,x 					; set the sign flag
.9d68		09 80		ora #$80			ora 	#NSBIsNegative
.9d6a		95 50		sta $50,x			sta 	NSStatus,x
.9d6c						_DRFExit2:
.9d6c		7a		ply				ply
.9d6d		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/number.asm

=1						ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2						ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3						ESTA_Decimal = 3 							; fractional part.
.9d6e						EncodeNumberStart:
.9d6e		38		sec				sec
.9d6f		80 01		bra $9d72			bra 	EncodeNumberContinue+1
.9d71						EncodeNumberContinue:
.9d71		18		clc				clc
.9d72						EncodeNumber:
.9d72		08		php				php 								; save reset flag.
.9d73		c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.9d75		f0 12		beq $9d89			beq 	_ENIsOkay
.9d77		c9 30		cmp #$30			cmp 	#"0"
.9d79		90 04		bcc $9d7f			bcc 	_ENBadNumber
.9d7b		c9 3a		cmp #$3a			cmp 	#"9"+1
.9d7d		90 0a		bcc $9d89			bcc 	_ENIsOkay
.9d7f						_ENBadNumber:
.9d7f		28		plp				plp 								; throw saved reset
.9d80		ad 25 04	lda $0425			lda 	encodeState 				; if in decimal mode, construct final number
.9d83		c9 03		cmp #$03			cmp 	#ESTA_Decimal
.9d85		f0 7b		beq $9e02			beq 	_ENConstructFinal
.9d87						_ENFail:
.9d87		18		clc				clc 								; not allowed
.9d88		60		rts				rts
.9d89						_ENIsOkay:
.9d89		28		plp				plp 								; are we restarting
.9d8a		90 15		bcc $9da1			bcc 	_ENNoRestart
.9d8c						_ENStartEncode:
.9d8c		c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.9d8e		f0 0c		beq $9d9c			beq 	_ENFirstDP
.9d90		29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.9d92		20 84 a4	jsr $a484			jsr 	NSMSetByte 					; in single byte mode.
.9d95		a9 01		lda #$01			lda 	#ESTA_Low
.9d97						_ENExitChange:
.9d97		8d 25 04	sta $0425			sta 	encodeState 				; save new state
.9d9a		38		sec				sec
.9d9b		60		rts				rts
.9d9c						_ENFirstDP:
.9d9c		20 82 a4	jsr $a482			jsr 	NSMSetZero 					; clear integer part
.9d9f		80 3c		bra $9ddd			bra 	_ESTASwitchFloat			; go straight to float and exi
.9da1						_ENNoRestart:
.9da1		48		pha				pha 								; save digit or DP on stack.
.9da2		ad 25 04	lda $0425			lda 	encodeState 				; get current state
.9da5		c9 01		cmp #$01			cmp 	#ESTA_Low
.9da7		f0 09		beq $9db2			beq  	_ESTALowState
.9da9		c9 02		cmp #$02			cmp 	#ESTA_High
.9dab		f0 26		beq $9dd3			beq 	_ESTAHighState
.9dad		c9 03		cmp #$03			cmp 	#ESTA_Decimal
.9daf		f0 38		beq $9de9			beq 	_ESTADecimalState
>9db1		db						.byte 	$DB 						; causes a break in the emulator
.9db2						_ESTALowState:
.9db2		68		pla				pla 								; get value back
.9db3		c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.9db5		f0 26		beq $9ddd			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.9db7		29 0f		and #$0f			and 	#15 						; make digit
.9db9		8d 26 04	sta $0426			sta 	digitTemp 					; save it.
.9dbc		b5 60		lda $60,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.9dbe		0a		asl a				asl 	a
.9dbf		0a		asl a				asl 	a
.9dc0		75 60		adc $60,x			adc 	NSMantissa0,x
.9dc2		0a		asl a				asl 	a
.9dc3		6d 26 04	adc $0426			adc 	digitTemp
.9dc6		95 60		sta $60,x			sta 	NSMantissa0,x
.9dc8		c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.9dca		90 05		bcc $9dd1			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.9dcc		a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.9dce		8d 25 04	sta $0425			sta 	encodeState
.9dd1						_ESTANoSwitch:
.9dd1		38		sec				sec
.9dd2		60		rts				rts
.9dd3						_ESTAHighState:
.9dd3		68		pla				pla 								; get value back
.9dd4		c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.9dd6		f0 05		beq $9ddd			beq 	_ESTASwitchFloat
.9dd8		20 36 9e	jsr $9e36			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.9ddb		38		sec				sec
.9ddc		60		rts				rts
.9ddd						_ESTASwitchFloat:
.9ddd		9c 27 04	stz $0427			stz 	decimalCount 				; reset the count of digits - we divide by 10^n at the end.
.9de0		e8		inx				inx 								; zero the decimal additive.
.9de1		20 82 a4	jsr $a482			jsr 	NSMSetZero
.9de4		ca		dex				dex
.9de5		a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.9de7		80 ae		bra $9d97			bra 	_ENExitChange
.9de9						_ESTADecimalState:
.9de9		68		pla				pla 								; digit.
.9dea		c9 2e		cmp #$2e			cmp 	#"." 						; fail on 2nd decimal point.
.9dec		f0 99		beq $9d87			beq 	_ENFail
.9dee		e8		inx				inx 								; put digit into fractional part of X+1
.9def		20 36 9e	jsr $9e36			jsr 	ESTAShiftDigitIntoMantissa
.9df2		ca		dex				dex
.9df3		ee 27 04	inc $0427			inc 	decimalCount 				; bump the count of decimals
.9df6		ad 27 04	lda $0427			lda 	decimalCount 				; too many decimal digits.
.9df9		c9 0b		cmp #$0b			cmp 	#11
.9dfb		f0 02		beq $9dff			beq 	_ESTADSFail
.9dfd		38		sec				sec
.9dfe		60		rts				rts
.9dff						_ESTADSFail:
.9dff		4c ff a5	jmp $a5ff			jmp 	RangeError
.9e02						_ENConstructFinal:
.9e02		ad 27 04	lda $0427			lda 	decimalCount 				; get decimal count
.9e05		f0 2d		beq $9e34			beq 	_ENCFExit 					; no decimals
.9e07		5a		phy				phy
.9e08		0a		asl a				asl 	a 							; x 4 and CLC
.9e09		0a		asl a				asl 	a
.9e0a		6d 27 04	adc $0427			adc 	decimalCount
.9e0d		a8		tay				tay
.9e0e		b9 be a5	lda $a5be,y			lda 	DecimalScalarTable-5,y 		; copy decimal scalar to X+2
.9e11		95 62		sta $62,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.9e13		b9 bf a5	lda $a5bf,y			lda 	DecimalScalarTable-5+1,y
.9e16		95 72		sta $72,x			sta 	NSMantissa1+2,x
.9e18		b9 c0 a5	lda $a5c0,y			lda 	DecimalScalarTable-5+2,y
.9e1b		95 82		sta $82,x			sta 	NSMantissa2+2,x
.9e1d		b9 c1 a5	lda $a5c1,y			lda 	DecimalScalarTable-5+3,y
.9e20		95 92		sta $92,x			sta 	NSMantissa3+2,x
.9e22		b9 c2 a5	lda $a5c2,y			lda 	DecimalScalarTable-5+4,y
.9e25		95 a2		sta $a2,x			sta 	NSExponent+2,x
.9e27		a9 08		lda #$08			lda 	#NSTFloat
.9e29		95 52		sta $52,x			sta 	NSStatus+2,x
.9e2b		7a		ply				ply
.9e2c		e8		inx				inx 								; multiply decimal const by decimal scalar
.9e2d		20 bc 9b	jsr $9bbc			jsr 	FloatMultiply
.9e30		ca		dex				dex
.9e31		20 77 9a	jsr $9a77			jsr 	FloatAdd 					; add to integer part.
.9e34						_ENCFExit:
.9e34		18		clc				clc 								; reject the digit.
.9e35		60		rts				rts
.9e36						ESTAShiftDigitIntoMantissa:
.9e36		29 0f		and #$0f			and 	#15 						; save digit
.9e38		48		pha				pha
.9e39		b5 90		lda $90,x			lda 	NSMantissa3,x 				; push mantissa on stack
.9e3b		48		pha				pha
.9e3c		b5 80		lda $80,x			lda 	NSMantissa2,x
.9e3e		48		pha				pha
.9e3f		b5 70		lda $70,x			lda 	NSMantissa1,x
.9e41		48		pha				pha
.9e42		b5 60		lda $60,x			lda 	NSMantissa0,x
.9e44		48		pha				pha
.9e45		20 91 a4	jsr $a491			jsr 	NSMShiftLeft 				; x 2
.9e48		20 91 a4	jsr $a491			jsr 	NSMShiftLeft 				; x 4
.9e4b		18		clc				clc 								; pop mantissa and add
.9e4c		68		pla				pla
.9e4d		75 60		adc $60,x			adc 	NSMantissa0,x
.9e4f		95 60		sta $60,x			sta 	NSMantissa0,x
.9e51		68		pla				pla
.9e52		75 70		adc $70,x			adc 	NSMantissa1,x
.9e54		95 70		sta $70,x			sta 	NSMantissa1,x
.9e56		68		pla				pla
.9e57		75 80		adc $80,x			adc 	NSMantissa2,x
.9e59		95 80		sta $80,x			sta 	NSMantissa2,x
.9e5b		68		pla				pla
.9e5c		75 90		adc $90,x			adc 	NSMantissa3,x
.9e5e		95 90		sta $90,x			sta 	NSMantissa3,x 				; x 5
.9e60		20 91 a4	jsr $a491			jsr 	NSMShiftLeft 				; x 10
.9e63		68		pla				pla 								; add digit
.9e64		18		clc				clc
.9e65		75 60		adc $60,x			adc 	NSMantissa0,x
.9e67		95 60		sta $60,x			sta 	NSMantissa0,x
.9e69		90 0a		bcc $9e75			bcc 	_ESTASDExit
.9e6b		f6 70		inc $70,x			inc 	NSMantissa1,x
.9e6d		d0 06		bne $9e75			bne 	_ESTASDExit
.9e6f		f6 80		inc $80,x			inc 	NSMantissa2,x
.9e71		d0 02		bne $9e75			bne 	_ESTASDExit
.9e73		f6 90		inc $90,x			inc 	NSMantissa3,x
.9e75						_ESTASDExit:
.9e75		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/term.asm

.9e76						EvaluateTerm:
.9e76		b1 30		lda ($30),y			lda 	(codePtr),y
.9e78		30 18		bmi $9e92			bmi 	_ETCheckUnary 				; unary function ? (text ones)
.9e7a		c9 40		cmp #$40			cmp 	#$40 						; 40-7F => identifier reference
.9e7c		b0 6c		bcs $9eea			bcs 	_ETVariable
.9e7e		c9 30		cmp #$30			cmp 	#'0' 						; is it a number
.9e80		90 6b		bcc $9eed			bcc 	_ETPuncUnary 				; if not it might be a punctuation unary.
.9e82		c9 3a		cmp #$3a			cmp 	#'9'+1
.9e84		b0 67		bcs $9eed			bcs 	_ETPuncUnary
.9e86		20 6e 9d	jsr $9d6e			jsr 	EncodeNumberStart 			; can't fail as it's 0-9 !
.9e89						_ETNumber:
.9e89		c8		iny				iny 								; keep encoding until we have the numbers
.9e8a		b1 30		lda ($30),y			lda 	(codePtr),y
.9e8c		20 71 9d	jsr $9d71			jsr 	EncodeNumberContinue
.9e8f		b0 f8		bcs $9e89			bcs 	_ETNumber 					; go back if accepted.
.9e91		60		rts				rts
.9e92						_ETCheckUnary:
.9e92		c9 ff		cmp #$ff			cmp 	#KWC_STRING 				; string token
.9e94		f0 3f		beq $9ed5			beq 	_ETString
.9e96		c9 fe		cmp #$fe			cmp 	#KWC_HEXCONST 				; hex constant.
.9e98		f0 12		beq $9eac			beq 	_ETHexConstant
.9e9a		c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; check it actually is a unary function
.9e9c		90 0b		bcc $9ea9			bcc 	_ETSyntaxError
.9e9e		c9 ae		cmp #$ae			cmp 	#KWC_LAST_UNARY+1
.9ea0		b0 07		bcs $9ea9			bcs 	_ETSyntaxError
.9ea2		da		phx				phx 								; push X on the stack
.9ea3		0a		asl a				asl 	a 							; put vector x 2 into X
.9ea4		aa		tax				tax
.9ea5		c8		iny				iny 								; consume unary function token
.9ea6		7c 06 92	jmp ($9206,x)			jmp 	(VectorSet0,x) 				; and do it.
.9ea9						_ETSyntaxError:
.9ea9		4c fa a5	jmp $a5fa			jmp 	SyntaxError
.9eac						_ETHexConstant:
.9eac		c8		iny				iny 								; skip #
.9ead		c8		iny				iny 								; skip count
.9eae		20 82 a4	jsr $a482			jsr 	NSMSetZero 					; clear result
.9eb1						_ETHLoop:
.9eb1		b1 30		lda ($30),y			lda 	(codePtr),y
.9eb3		c8		iny				iny 								; and consume
.9eb4		c9 00		cmp #$00			cmp 	#0 							; exit if zero
.9eb6		f0 1c		beq $9ed4			beq 	_ETHExit
.9eb8		48		pha				pha 								; save on stack.
.9eb9		20 91 a4	jsr $a491			jsr 	NSMShiftLeft 				; x 2
.9ebc		20 91 a4	jsr $a491			jsr 	NSMShiftLeft 				; x 4
.9ebf		20 91 a4	jsr $a491			jsr 	NSMShiftLeft 				; x 8
.9ec2		20 91 a4	jsr $a491			jsr 	NSMShiftLeft 				; x 16
.9ec5		68		pla				pla 								; ASCII
.9ec6		c9 41		cmp #$41			cmp 	#'A'
.9ec8		90 02		bcc $9ecc			bcc 	_ETHNotChar
.9eca		e9 07		sbc #$07			sbc 	#7
.9ecc						_ETHNotChar:
.9ecc		29 0f		and #$0f			and 	#15 						; digit now
.9ece		15 60		ora $60,x			ora 	NSMantissa0,x 				; put in LS Nibble
.9ed0		95 60		sta $60,x			sta 	NSMantissa0,x
.9ed2		80 dd		bra $9eb1			bra 	_ETHLoop 					; go round.
.9ed4						_ETHExit:
.9ed4		60		rts				rts
.9ed5						_ETString:
.9ed5		c8		iny				iny 								; look at length
.9ed6		b1 30		lda ($30),y			lda 	(codePtr),y
.9ed8		48		pha				pha
.9ed9		c8		iny				iny 								; first character
.9eda		20 d0 a8	jsr $a8d0			jsr 	MemoryInline 				; put address of string at (code-Ptr),y on stack
.9edd		68		pla				pla 								; restore count and save
.9ede		85 36		sta $36				sta 	zTemp0
.9ee0		98		tya				tya 								; add length to Y to skip it.
.9ee1		18		clc				clc
.9ee2		65 36		adc $36				adc 	zTemp0
.9ee4		a8		tay				tay
.9ee5		a9 10		lda #$10			lda 	#NSTString 					; mark as string
.9ee7		95 50		sta $50,x			sta 	NSStatus,x
.9ee9		60		rts				rts
.9eea						_ETVariable:
.9eea		4c 3f 9f	jmp $9f3f			jmp 	VariableHandler
.9eed						_ETPuncUnary:
.9eed		c8		iny				iny 								; consume the unary character
.9eee		c9 2d		cmp #$2d			cmp 	#KWD_MINUS 					; unary minus
.9ef0		f0 2b		beq $9f1d			beq 	_ETUnaryNegate
.9ef2		c9 10		cmp #$10			cmp 	#KWD_ATCH 					; @ reference -> constant
.9ef4		f0 36		beq $9f2c			beq 	_ETDereference
.9ef6		c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; parenthesis
.9ef8		f0 3e		beq $9f38			beq 	_ETParenthesis
.9efa		64 36		stz $36				stz 	zTemp0 						; zTemp0 is the indirection level.
.9efc		c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; byte indirection (0) ?
.9efe		f0 06		beq $9f06			beq 	_ETIndirection
.9f00		e6 36		inc $36				inc 	zTemp0
.9f02		c9 21		cmp #$21			cmp 	#KWD_PLING					; word indirection (1) \
.9f04		d0 a3		bne $9ea9			bne 	_ETSyntaxError
.9f06						_ETIndirection:
.9f06		a5 36		lda $36				lda 	zTemp0 						; push indirection amount (0-1) => (1-2) on the stack
.9f08		1a		inc a				inc 	a
.9f09		48		pha				pha
.9f0a		20 76 9e	jsr $9e76			jsr 	EvaluateTerm				; evaluate the term
.9f0d		20 ef 9c	jsr $9cef			jsr 	Dereference 				; dereference it.
.9f10		b5 50		lda $50,x			lda 	NSStatus,x 					; must be a +ve integer.
.9f12		d0 06		bne $9f1a			bne 	_ETTypeMismatch
.9f14		68		pla				pla 								; indirection 1-2
.9f15		09 20		ora #$20			ora 	#NSBIsReference 			; make it a reference.
.9f17		95 50		sta $50,x			sta 	NSStatus,x
.9f19		60		rts				rts
.9f1a						_ETTypeMismatch:
.9f1a		4c 04 a6	jmp $a604			jmp 	TypeError
.9f1d						_ETUnaryNegate:
.9f1d		20 76 9e	jsr $9e76			jsr 	EvaluateTerm				; evaluate the term
.9f20		20 ef 9c	jsr $9cef			jsr 	Dereference 				; dereference it.
.9f23		b5 50		lda $50,x			lda 	NSStatus,x 					; must be a number
.9f25		29 10		and #$10			and 	#NSTString
.9f27		d0 f1		bne $9f1a			bne 	_ETTypeMismatch
.9f29		4c 44 a4	jmp $a444			jmp 	NSMNegate  					; just toggles the sign bit.
.9f2c						_ETDereference:
.9f2c		20 76 9e	jsr $9e76			jsr 	EvaluateTerm				; evaluate the term
.9f2f		b5 50		lda $50,x			lda 	NSStatus,x 					; must be a reference
.9f31		29 20		and #$20			and 	#NSBIsReference
.9f33		f0 e5		beq $9f1a			beq 	_ETTypeMismatch
.9f35		74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer address
.9f37		60		rts				rts
.9f38						_ETParenthesis:
.9f38		20 23 9a	jsr $9a23			jsr 	EvaluateExpression 			; evaluate here, from lowest precedence
.9f3b		20 00 95	jsr $9500			jsr 	CheckRightBracket 			; check for )
.9f3e		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/variable.asm

.9f3f						VariableHandler:
.9f3f		b1 30		lda ($30),y			lda 	(codePtr),y
.9f41		18		clc				clc
.9f42		69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.9f44		85 37		sta $37				sta 	zTemp0+1
.9f46		c8		iny				iny
.9f47		b1 30		lda ($30),y			lda 	(codePtr),y
.9f49		85 36		sta $36				sta 	zTemp0
.9f4b		c8		iny				iny
.9f4c		18		clc				clc									; copy variable address+3 to mantissa
.9f4d		69 03		adc #$03			adc 	#3 							; this is the address of the data.
.9f4f		95 60		sta $60,x			sta 	NSMantissa0,x
.9f51		a5 37		lda $37				lda 	zTemp0+1
.9f53		69 00		adc #$00			adc 	#0
.9f55		95 70		sta $70,x			sta 	NSMantissa1,x
.9f57		74 80		stz $80,x			stz 	NSMantissa2,x
.9f59		74 90		stz $90,x			stz 	NSMantissa3,x
.9f5b		74 a0		stz $a0,x			stz 	NSExponent,x
.9f5d		5a		phy				phy
.9f5e		a0 02		ldy #$02			ldy 	#2 							; read type
.9f60		b1 36		lda ($36),y			lda 	(zTemp0),y
.9f62		7a		ply				ply
.9f63		29 1c		and #$1c			and 	#NSBTypeMask+NSBIsArray 	; get type information
.9f65		09 20		ora #$20			ora 	#NSBIsReference 			; make a reference.
.9f67		95 50		sta $50,x			sta 	NSStatus,x
.9f69		29 04		and #$04			and 	#NSBIsArray
.9f6b		d0 01		bne $9f6e			bne 	_VHArray
.9f6d		60		rts				rts
.9f6e						_VHArray:
.9f6e		e8		inx				inx
.9f6f		20 1d a4	jsr $a41d			jsr 	Evaluate8BitInteger 		; get the 1st index.
.9f72		a9 ff		lda #$ff			lda 	#$FF 						; set Status of X+2 to a duff value so we know if we picked it up.
.9f74		95 51		sta $51,x			sta 	NSStatus+1,x
.9f76		b1 30		lda ($30),y			lda 	(codePtr),y
.9f78		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.9f7a		d0 06		bne $9f82			bne 	_VHNoSecondIndex
.9f7c		c8		iny				iny 								; skip the comma
.9f7d		e8		inx				inx
.9f7e		20 1d a4	jsr $a41d			jsr 	Evaluate8BitInteger 		; get the 2nd index.
.9f81		ca		dex				dex
.9f82						_VHNoSecondIndex:
.9f82		ca		dex				dex 								; set X back.
.9f83		20 00 95	jsr $9500			jsr 	CheckRightBracket 			; and check the right bracket.
.9f86		5a		phy				phy 								; save position
.9f87		b5 60		lda $60,x			lda 	NSMantissa0,x 				; copy record address to zaTemp (moved 6/12/22)
.9f89		85 3e		sta $3e				sta 	zaTemp
.9f8b		b5 70		lda $70,x			lda 	NSMantissa1,x
.9f8d		85 3f		sta $3f				sta 	zaTemp+1
.9f8f		a0 02		ldy #$02			ldy 	#2 							; check first index is not-zero, e.g. array defined
.9f91		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9f93		f0 5d		beq $9ff2			beq 	_VHBadArray
.9f95		a0 03		ldy #$03			ldy 	#3 							; get the second index - which is 0 if there is one index.
.9f97		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9f99		f0 02		beq $9f9d			beq 	_VHHas2Mask
.9f9b		a9 ff		lda #$ff			lda 	#$FF
.9f9d						_VHHas2Mask:
.9f9d		d5 52		cmp $52,x			cmp 	NSStatus+2,x 				; so if they are the same there are the wrong number of indices
.9f9f		f0 4c		beq $9fed			beq 	_VHBadIndex
.9fa1		0a		asl a				asl 	a 							; carry will be set if a second index
.9fa2		90 08		bcc $9fac			bcc 	_VHCheckFirstIndex
.9fa4		a0 03		ldy #$03			ldy 	#3 			 				; check the 2nd size >= 2nd index
.9fa6		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9fa8		d5 62		cmp $62,x			cmp 	NSMantissa0+2,x
.9faa		90 41		bcc $9fed			bcc 	_VHBadIndex
.9fac						_VHCheckFirstIndex:
.9fac		a0 02		ldy #$02			ldy 	#2 			 				; check the 2nd size >= 2nd index
.9fae		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9fb0		d5 61		cmp $61,x			cmp 	NSMantissa0+1,x
.9fb2		90 39		bcc $9fed			bcc 	_VHBadIndex
.9fb4		64 36		stz $36				stz 	zTemp0 						; clear zTemp0 (if 1 index)
.9fb6		64 37		stz $37				stz 	zTemp0+1
.9fb8		b5 52		lda $52,x			lda 	NSStatus+2,x 				; if only one index provided, don't need to multiply
.9fba		30 0e		bmi $9fca			bmi 	_VHNoMultiply
.9fbc		da		phx				phx
.9fbd		b5 62		lda $62,x			lda 	NSMantissa0+2,x 			; get 2nd index on stack
.9fbf		48		pha				pha
.9fc0		a0 02		ldy #$02			ldy 	#2 							; get 1st size in A
.9fc2		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9fc4		1a		inc a				inc 	a 							; add 1 for zero base
.9fc5		fa		plx				plx
.9fc6		20 2d a4	jsr $a42d			jsr 	Multiply8x8 				; calculate -> Z0
.9fc9		fa		plx				plx
.9fca						_VHNoMultiply:
.9fca		18		clc				clc
.9fcb		a5 36		lda $36				lda 	zTemp0
.9fcd		75 61		adc $61,x			adc 	NSMantissa0+1,x
.9fcf		85 36		sta $36				sta 	zTemp0
.9fd1		a5 37		lda $37				lda 	zTemp0+1
.9fd3		69 00		adc #$00			adc 	#0
.9fd5		85 37		sta $37				sta 	zTemp0+1
.9fd7		b5 50		lda $50,x			lda 	NSStatus,x
.9fd9		20 59 8a	jsr $8a59			jsr 	ScaleByBaseType
.9fdc		18		clc				clc
.9fdd		b2 3e		lda ($3e)			lda 	(zaTemp)
.9fdf		65 36		adc $36				adc 	zTemp0
.9fe1		95 60		sta $60,x			sta 	NSMantissa0,x
.9fe3		a0 01		ldy #$01			ldy 	#1
.9fe5		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9fe7		65 37		adc $37				adc 	zTemp0+1
.9fe9		95 70		sta $70,x			sta 	NSMantissa1,x
.9feb		7a		ply				ply 								; restore position
.9fec		60		rts				rts
.9fed						_VHBadIndex:
.9fed		a9 17		lda #$17		lda	#23
.9fef		4c 19 95	jmp $9519		jmp	ErrorHandler
.9ff2						_VHBadArray:
.9ff2		a9 18		lda #$18		lda	#24
.9ff4		4c 19 95	jmp $9519		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/abs.asm

.9ff7						AbsUnary:
.9ff7		fa		plx				plx 								; restore stack pos
.9ff8		20 d0 a3	jsr $a3d0			jsr 	EvaluateNumber 				; get a float or int
.9ffb		20 00 95	jsr $9500			jsr 	CheckRightBracket
.9ffe		b5 50		lda $50,x			lda 	NSStatus,x 					; clear the sign bit
.a000		29 7f		and #$7f			and 	#$7F
.a002		95 50		sta $50,x			sta 	NSStatus,x
.a004		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/alloc.asm

.a005						AllocUnary:
.a005		fa		plx				plx 								; restore stack pos
.a006		20 02 a4	jsr $a402			jsr 	Evaluate16BitInteger		; get bytes required.
.a009		20 00 95	jsr $9500			jsr 	CheckRightBracket
.a00c		da		phx				phx 								; save X/Y
.a00d		5a		phy				phy
.a00e		8a		txa				txa 								; copy X into Y
.a00f		a8		tay				tay
.a010		b9 70 00	lda $0070,y			lda		NSMantissa1,y 				; get size into XA
.a013		aa		tax				tax
.a014		b9 60 00	lda $0060,y			lda 	NSMantissa0,y
.a017		20 24 a0	jsr $a024			jsr 	AllocateXABytes 			; allocate memory
.a01a		99 60 00	sta $0060,y			sta 	NSMantissa0,y 				; write address out.
.a01d		8a		txa				txa 	 							; typing is 16 bit integer.
.a01e		99 70 00	sta $0070,y			sta 	NSMantissa1,y
.a021		7a		ply				ply
.a022		fa		plx				plx
.a023		60		rts				rts
.a024						AllocateXABytes:
.a024		5a		phy				phy
.a025		ac 28 04	ldy $0428			ldy 	lowMemPtr 					; push current address on stack and to zTemp0
.a028		84 36		sty $36				sty 	zTemp0
.a02a		5a		phy				phy
.a02b		ac 29 04	ldy $0429			ldy 	lowMemPtr+1
.a02e		84 37		sty $37				sty 	zTemp0+1
.a030		5a		phy				phy
.a031		18		clc				clc 								; add to low memory pointer
.a032		6d 28 04	adc $0428			adc 	lowMemPtr
.a035		8d 28 04	sta $0428			sta 	lowMemPtr
.a038		8a		txa				txa
.a039		6d 29 04	adc $0429			adc 	lowMemPtr+1
.a03c		8d 29 04	sta $0429			sta 	lowMemPtr+1
.a03f		b0 2f		bcs $a070			bcs 	CISSMemory
.a041		20 62 a0	jsr $a062			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.a044						_ClearMemory:
.a044		ad 28 04	lda $0428			lda 	lowMemPtr 					; cleared all memory allocated
.a047		c5 36		cmp $36				cmp 	zTemp0
.a049		d0 07		bne $a052			bne 	_CMClearNext
.a04b		ad 29 04	lda $0429			lda 	lowMemPtr+1
.a04e		c5 37		cmp $37				cmp 	zTemp0+1
.a050		f0 0c		beq $a05e			beq 	_CMExit
.a052						_CMClearNext:
.a052		a9 00		lda #$00			lda 	#0 							; clear byte, advance to next.
.a054		92 36		sta ($36)			sta 	(zTemp0)
.a056		e6 36		inc $36				inc 	zTemp0
.a058		d0 ea		bne $a044			bne 	_ClearMemory
.a05a		e6 37		inc $37				inc		zTemp0+1
.a05c		80 e6		bra $a044			bra 	_ClearMemory
.a05e						_CMExit:
.a05e		fa		plx				plx
.a05f		68		pla				pla
.a060		7a		ply				ply
.a061		60		rts				rts
.a062						CheckIdentifierStringSpace:
.a062		48		pha				pha
.a063		ad 29 04	lda $0429			lda 	lowMemPtr+1 				; get low memory pointer
.a066		18		clc				clc
.a067		69 02		adc #$02			adc 	#2 							; need at least 2 256 byte pages
.a069		cd 2b 04	cmp $042b			cmp 	stringMemory+1 				; is it >= StringMemory
.a06c		b0 02		bcs $a070			bcs 	CISSMemory
.a06e		68		pla				pla
.a06f		60		rts				rts
.a070						CISSMemory:
.a070		a9 06		lda #$06		lda	#6
.a072		4c 19 95	jmp $9519		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/asc.asm

.a075						AscUnary:
.a075		fa		plx				plx 								; restore stack pos
.a076		20 da a3	jsr $a3da			jsr 	EvaluateString 				; get a string
.a079		b2 36		lda ($36)			lda 	(zTemp0)					; get/return first character
.a07b		20 84 a4	jsr $a484			jsr 	NSMSetByte 					; ASC("") will return zero.
.a07e		20 00 95	jsr $9500			jsr 	CheckRightBracket
.a081		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/frac.asm

.a082						FracUnary:
.a082		fa		plx				plx 								; restore stack pos
.a083		20 d0 a3	jsr $a3d0			jsr 	EvaluateNumber 				; get a float or int
.a086		20 00 95	jsr $9500			jsr 	CheckRightBracket
.a089		b5 50		lda $50,x			lda 	NSStatus,x
.a08b		29 08		and #$08			and 	#NSTFloat 					; check it is a float
.a08d		f0 04		beq $a093			beq 	_IUZero
.a08f		20 3d 9b	jsr $9b3d			jsr 	FloatFractionalPart 		; if so, get the fractional part.
.a092		60		rts				rts
.a093						_IUZero:
.a093		20 82 a4	jsr $a482			jsr 	NSMSetZero
.a096		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/int.asm

.a097						IntUnary:
.a097		fa		plx				plx 								; restore stack pos
.a098		20 d0 a3	jsr $a3d0			jsr 	EvaluateNumber 				; get a float or int
.a09b		20 00 95	jsr $9500			jsr 	CheckRightBracket
.a09e		b5 50		lda $50,x			lda 	NSStatus,x
.a0a0		29 08		and #$08			and 	#NSTFloat 					; check it is a float
.a0a2		f0 03		beq $a0a7			beq 	_IUExit
.a0a4		20 95 9b	jsr $9b95			jsr 	FloatIntegerPart 			; if it is get the integer part.
.a0a7						_IUExit:
.a0a7		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/len.asm

.a0a8						LenUnary:
.a0a8		fa		plx				plx 								; restore stack pos
.a0a9		20 da a3	jsr $a3da			jsr 	EvaluateString 				; get a string
.a0ac		5a		phy				phy
.a0ad		a0 00		ldy #$00			ldy 	#0 							; find length
.a0af						_LenFind:
.a0af		b1 36		lda ($36),y			lda 	(zTemp0),y 					; look for trailing NULL.
.a0b1		f0 06		beq $a0b9			beq 	_LenExit
.a0b3		c8		iny				iny
.a0b4		d0 f9		bne $a0af			bne 	_LenFind
.a0b6		4c ff a5	jmp $a5ff			jmp 	RangeError 					; string > 255 - no trailing NULL.
.a0b9						_LenExit:
.a0b9		98		tya				tya		 							; return length
.a0ba		20 84 a4	jsr $a484			jsr 	NSMSetByte
.a0bd		7a		ply				ply
.a0be		20 00 95	jsr $9500			jsr 	CheckRightBracket
.a0c1		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/minmax.asm

.a0c2						Unary_Min:
.a0c2		a9 01		lda #$01			lda 	#1
.a0c4		80 02		bra $a0c8			bra 	UnaryMinMaxMain
.a0c6						Unary_Max:
.a0c6		a9 ff		lda #$ff			lda 	#$FF 						; value from comparator to cause a write
.a0c8						UnaryMinMaxMain:
.a0c8		fa		plx				plx 								; get index on number stack
.a0c9		48		pha				pha 								; save comparator
.a0ca		20 c7 a3	jsr $a3c7			jsr 	EvaluateValue 				; get the first value.
.a0cd						_UMMMLoop:
.a0cd		b1 30		lda ($30),y			lda 	(codePtr),y
.a0cf		c9 29		cmp #$29			cmp 	#KWD_RPAREN 				; if right bracket then done.
.a0d1		f0 22		beq $a0f5			beq 	_UMMMDone
.a0d3		20 08 95	jsr $9508			jsr 	CheckComma 					; must be a comma
.a0d6		e8		inx				inx
.a0d7		20 c7 a3	jsr $a3c7			jsr 	EvaluateValue
.a0da		ca		dex				dex
.a0db		20 65 a4	jsr $a465			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] (Compare is destructive)
.a0de		e8		inx				inx
.a0df		20 65 a4	jsr $a465			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2], original
.a0e2		e8		inx				inx
.a0e3		20 d6 95	jsr $95d6			jsr 	CompareBaseCode 			; part of > = < etc. code, returns 255,0 or 1
.a0e6		ca		dex				dex
.a0e7		ca		dex				dex
.a0e8		85 36		sta $36				sta 	zTemp0 						; save required result
.a0ea		68		pla				pla 								; get and save comparator
.a0eb		48		pha				pha
.a0ec		c5 36		cmp $36				cmp 	zTemp0 						; if the comparator
.a0ee		d0 dd		bne $a0cd			bne 	_UMMMLoop
.a0f0		20 f8 a0	jsr $a0f8			jsr 	ExpCopyAboveDown 			; copy next up slot down
.a0f3		80 d8		bra $a0cd			bra 	_UMMMLoop
.a0f5						_UMMMDone:
.a0f5		68		pla				pla 								; throw the comparator
.a0f6		c8		iny				iny 								; skip )
.a0f7		60		rts				rts
.a0f8						ExpCopyAboveDown:
.a0f8		b5 51		lda $51,x			lda 	NSStatus+1,x
.a0fa		95 50		sta $50,x			sta 	NSStatus,x
.a0fc		b5 a1		lda $a1,x			lda 	NSExponent+1,x
.a0fe		95 a0		sta $a0,x			sta 	NSExponent,x
.a100		b5 61		lda $61,x			lda 	NSMantissa0+1,x
.a102		95 60		sta $60,x			sta 	NSMantissa0,x
.a104		b5 71		lda $71,x			lda 	NSMantissa1+1,x
.a106		95 70		sta $70,x			sta 	NSMantissa1,x
.a108		b5 81		lda $81,x			lda 	NSMantissa2+1,x
.a10a		95 80		sta $80,x			sta 	NSMantissa2,x
.a10c		b5 91		lda $91,x			lda 	NSMantissa3+1,x
.a10e		95 90		sta $90,x			sta 	NSMantissa3,x
.a110		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/not.asm

.a111						Unary_Not:
.a111		fa		plx				plx
.a112		20 ef a3	jsr $a3ef			jsr 	EvaluateInteger 			; get integer
.a115		20 00 95	jsr $9500			jsr 	CheckRightBracket
.a118		20 a4 a4	jsr $a4a4			jsr 	NSMIsZero 					; zero mantissa ?
.a11b		f0 04		beq $a121			beq 	_NotZero
.a11d		20 82 a4	jsr $a482			jsr 	NSMSetZero
.a120		60		rts				rts
.a121						_NotZero:
.a121		4c 8c 95	jmp $958c			jmp 	ReturnTrue

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/peek.asm

.a124						PeekByteUnary:
.a124		a9 01		lda #$01			lda 	#1
.a126		80 0a		bra $a132			bra 	PeekUnary
.a128						PeekWUnary:
.a128		a9 02		lda #$02			lda 	#2
.a12a		80 06		bra $a132			bra 	PeekUnary
.a12c						PeekLUnary:
.a12c		a9 03		lda #$03			lda 	#3
.a12e		80 02		bra $a132			bra 	PeekUnary
.a130						PeekDUnary:
.a130		a9 04		lda #$04			lda 	#4
.a132						PeekUnary:
.a132		fa		plx				plx 								; restore position.
.a133		48		pha				pha 								; save count to copy on stack
.a134		20 02 a4	jsr $a402			jsr		Evaluate16BitInteger 		; address as constant.
.a137		20 00 95	jsr $9500			jsr 	CheckRightBracket
.a13a		b5 60		lda $60,x			lda 	NSMantissa0,x 				; save mantissa in zTemp0 as address
.a13c		85 36		sta $36				sta 	zTemp0
.a13e		b5 70		lda $70,x			lda 	NSMantissa1,x
.a140		85 37		sta $37				sta 	zTemp0+1
.a142		20 82 a4	jsr $a482			jsr 	NSMSetZero 					; clear the result to zero.
.a145		68		pla				pla 								; count in zTemp2
.a146		85 3a		sta $3a				sta 	zTemp2
.a148		da		phx				phx 								; save stack position and offset of read
.a149		5a		phy				phy
.a14a		a0 00		ldy #$00			ldy 	#0 							; byte read offset.
.a14c						_PULoop:
.a14c		b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next byte, write to mantissa0,x
.a14e		95 60		sta $60,x			sta 	NSMantissa0,x 				; we change X not the index before it.
.a150		c8		iny				iny 								; next byte to write
.a151		8a		txa				txa 								; next byte to read - stack layout in 04data.inc
.a152		18		clc				clc
.a153		69 10		adc #$10			adc 	#MathStackSize
.a155		aa		tax				tax
.a156		c6 3a		dec $3a				dec 	zTemp2 						; done them all
.a158		d0 f2		bne $a14c			bne 	_PULoop
.a15a		7a		ply				ply 								; restore stack/code pos and exit.
.a15b		fa		plx				plx
.a15c		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/sgn.asm

.a15d						SgnUnary:
.a15d		fa		plx				plx 								; restore stack pos
.a15e		20 d0 a3	jsr $a3d0			jsr 	EvaluateNumber 				; get a float or int
.a161		20 00 95	jsr $9500			jsr 	CheckRightBracket
.a164		20 a4 a4	jsr $a4a4			jsr 	NSMIsZero 					; if zero
.a167		f0 0e		beq $a177			beq 	_SGZero  					; return Int Zero
.a169		b5 50		lda $50,x			lda 	NSStatus,x 					; get status w/sign
.a16b		48		pha				pha
.a16c		a9 01		lda #$01			lda 	#1 							; set to 1
.a16e		20 84 a4	jsr $a484			jsr 	NSMSetByte
.a171		68		pla				pla
.a172		29 80		and #$80			and		#$80 						; copy the sign byte out
.a174		95 50		sta $50,x			sta 	NSStatus,x  				; so it will be -1 or 1
.a176		60		rts				rts
.a177		20 82 a4	jsr $a482	_SGZero:jsr 	NSMSetZero
.a17a		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/val.asm

.a17b						ValUnary:
.a17b		fa		plx				plx 								; restore stack pos
.a17c		20 91 a1	jsr $a191			jsr 	ValMainCode 				; do the main val() code
.a17f		b0 01		bcs $a182			bcs 	_VUError 					; couldn't convert
.a181		60		rts				rts
.a182						_VUError:
.a182		4c 04 a6	jmp $a604			jmp 	TypeError
.a185						IsValUnary:
.a185		fa		plx				plx 								; restore stack pos
.a186		20 91 a1	jsr $a191			jsr 	ValMainCode 				; do the main val() code
.a189		b0 03		bcs $a18e			bcs 	_VUBad
.a18b		4c 8c 95	jmp $958c			jmp 	ReturnTrue
.a18e						_VUBad:
.a18e		4c 97 95	jmp $9597			jmp 	ReturnFalse
.a191						ValMainCode:
.a191		20 da a3	jsr $a3da			jsr 	EvaluateString 				; get a string
.a194		20 00 95	jsr $9500			jsr 	CheckRightBracket 			; check right bracket present
.a197						ValEvaluateZTemp0:
.a197		5a		phy				phy
.a198		b2 36		lda ($36)			lda 	(zTemp0) 					; check not empty string
.a19a		f0 17		beq $a1b3			beq 	_VMCFail2
.a19c		a0 ff		ldy #$ff			ldy 	#$FF 						; start position
.a19e		48		pha				pha 								; save first character
.a19f		c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.a1a1		d0 01		bne $a1a4			bne 	_VMCStart
.a1a3		c8		iny				iny 								; skip over -
.a1a4						_VMCStart:
.a1a4		38		sec				sec 								; initialise first time round.
.a1a5						_VMCNext:
.a1a5		c8		iny				iny 								; pre-increment
.a1a6		b1 36		lda ($36),y			lda 	(zTemp0),y 					; next character = EOS ?
.a1a8		f0 0c		beq $a1b6			beq 	_VMCSuccess 				; successful.
.a1aa		20 72 9d	jsr $9d72			jsr 	EncodeNumber 				; send it to the number-builder
.a1ad		90 03		bcc $a1b2			bcc 	_VMCFail 					; if failed, give up.
.a1af		18		clc				clc 								; next time round, countinue
.a1b0		80 f3		bra $a1a5			bra 	_VMCNext
.a1b2						_VMCFail:
.a1b2		68		pla				pla
.a1b3						_VMCFail2:
.a1b3		7a		ply				ply
.a1b4		38		sec				sec
.a1b5		60		rts				rts
.a1b6						_VMCSuccess:
.a1b6		a9 00		lda #$00			lda 	#0 							; construct final
.a1b8		20 72 9d	jsr $9d72			jsr 	EncodeNumber 				; by sending a duff value.
.a1bb		68		pla				pla 								; if it was -ve
.a1bc		c9 2d		cmp #$2d			cmp 	#"-"
.a1be		d0 03		bne $a1c3			bne 	_VMCNotNegative
.a1c0		20 44 a4	jsr $a444			jsr		NSMNegate 					; negate it.
.a1c3						_VMCNotNegative:
.a1c3		7a		ply				ply
.a1c4		18		clc				clc
.a1c5		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/chr.asm

.a1c6						ChrUnary:
.a1c6		fa		plx				plx 								; restore stack pos
.a1c7		20 1d a4	jsr $a41d			jsr 	Evaluate8BitInteger			; get value (chr$(0) returns an empty string)
.a1ca		48		pha				pha
.a1cb		20 00 95	jsr $9500			jsr 	CheckRightBracket
.a1ce		a9 01		lda #$01			lda 	#1 							; allocate space for one char
.a1d0		20 89 b7	jsr $b789			jsr 	StringTempAllocate
.a1d3		68		pla				pla 								; write number to it
.a1d4		20 c2 b7	jsr $b7c2			jsr 	StringTempWrite
.a1d7		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/items.asm

.a1d8						ItemCountUnary:
.a1d8		fa		plx				plx
.a1d9		20 da a3	jsr $a3da			jsr 	EvaluateString
.a1dc		e8		inx				inx
.a1dd		20 50 a2	jsr $a250			jsr 	ICGetSeperator
.a1e0		ca		dex				dex
.a1e1		20 71 a2	jsr $a271			jsr 	ICSetPointer 				; zTemp0 = (string)
.a1e4		20 82 a4	jsr $a482			jsr 	NSMSetZero 					; zero the result.
.a1e7		5a		phy				phy
.a1e8		a0 ff		ldy #$ff			ldy 	#$FF 						; loop counting seperators in mantissa
.a1ea						_ICULoop:
.a1ea		c8		iny				iny
.a1eb		b1 36		lda ($36),y			lda 	(zTemp0),y
.a1ed		cd ca 07	cmp $07ca			cmp 	ICSeperator
.a1f0		d0 02		bne $a1f4			bne 	_ICUNoMatch
.a1f2		f6 60		inc $60,x			inc 	NSMantissa0,x
.a1f4						_ICUNoMatch:
.a1f4		c9 00		cmp #$00			cmp 	#0
.a1f6		d0 f2		bne $a1ea			bne 	_ICULoop
.a1f8		f6 60		inc $60,x			inc 	NSMantissa0,x 				; +1
.a1fa		7a		ply				ply
.a1fb		60		rts				rts
.a1fc						ItemGetUnary:
.a1fc		fa		plx				plx
.a1fd		20 da a3	jsr $a3da			jsr 	EvaluateString 				; search string
.a200		20 08 95	jsr $9508			jsr 	CheckComma
.a203		e8		inx				inx 								; get count
.a204		20 1d a4	jsr $a41d			jsr 	Evaluate8BitInteger
.a207		c9 00		cmp #$00			cmp 	#0 							; must be > 0, index starts at 1.
.a209		f0 61		beq $a26c			beq 	ICGSRange
.a20b		e8		inx				inx 								; get seperator.
.a20c		20 50 a2	jsr $a250			jsr 	ICGetSeperator
.a20f		ca		dex				dex
.a210		ca		dex				dex
.a211		5a		phy				phy
.a212		20 71 a2	jsr $a271			jsr 	ICSetPointer 				; zTemp0 points to string.
.a215		a0 00		ldy #$00			ldy 	#0
.a217		d6 61		dec $61,x			dec 	NSMantissa0+1,x 			; first element.
.a219		f0 0e		beq $a229			beq 	_IGUFoundStart
.a21b						_IGUFindNext:
.a21b		b1 36		lda ($36),y			lda 	(zTemp0),y		 			; next
.a21d		f0 4d		beq $a26c			beq 	ICGSRange 					; eol, not found.
.a21f		c8		iny				iny
.a220		cd ca 07	cmp $07ca			cmp 	ICSeperator 				; until found a seperator (or EOS)
.a223		d0 f6		bne $a21b			bne 	_IGUFindNext
.a225		d6 61		dec $61,x			dec 	NSMantissa0+1,x
.a227		d0 f2		bne $a21b			bne 	_IGUFindNext
.a229						_IGUFoundStart:
.a229		84 38		sty $38				sty 	zTemp1 						; save start
.a22b		88		dey				dey
.a22c						_IGUFindLength:
.a22c		c8		iny				iny 								; forward till seperator/EOS
.a22d		b1 36		lda ($36),y			lda 	(zTemp0),y
.a22f		f0 05		beq $a236			beq 	_IGUFoundLength
.a231		cd ca 07	cmp $07ca			cmp 	ICSeperator
.a234		d0 f6		bne $a22c			bne 	_IGUFindLength
.a236						_IGUFoundLength:
.a236		84 39		sty $39				sty 	zTemp1+1 					; save end of copy string
.a238		98		tya				tya 								; calculate length of new string.
.a239		38		sec				sec
.a23a		e5 38		sbc $38				sbc 	zTemp1
.a23c		20 89 b7	jsr $b789			jsr 	StringTempAllocate 			; allocate bytes for it.
.a23f		a4 38		ldy $38				ldy 	zTemp1
.a241						_IGUCopySub:
.a241		c4 39		cpy $39				cpy 	zTemp1+1
.a243		f0 08		beq $a24d			beq 	_IGUCopyOver
.a245		b1 36		lda ($36),y			lda 	(zTemp0),y
.a247		20 c2 b7	jsr $b7c2			jsr 	StringTempWrite
.a24a		c8		iny				iny
.a24b		80 f4		bra $a241			bra 	_IGUCopySub
.a24d						_IGUCopyOver:
.a24d		7a		ply				ply
.a24e		60		rts				rts
>a24f		db						.byte 	$DB 						; causes a break in the emulator
.a250						ICGetSeperator:
.a250		20 08 95	jsr $9508			jsr 	CheckComma 					; preceding comma
.a253		20 da a3	jsr $a3da			jsr 	EvaluateString 				; seperator string
.a256		20 71 a2	jsr $a271			jsr 	ICSetPointer 				; access it
.a259		b2 36		lda ($36)			lda 	(zTemp0) 					; get sep char
.a25b		8d ca 07	sta $07ca			sta 	ICSeperator
.a25e		f0 0c		beq $a26c			beq 	ICGSRange 					; check LEN(seperator) = 1
.a260		5a		phy				phy
.a261		a0 01		ldy #$01			ldy 	#1
.a263		b1 36		lda ($36),y			lda 	(zTemp0),y
.a265		d0 05		bne $a26c			bne 	ICGSRange
.a267		7a		ply				ply
.a268		20 00 95	jsr $9500			jsr 	CheckRightBracket 			; check following )
.a26b		60		rts				rts
.a26c						ICGSRange:
.a26c		a9 04		lda #$04		lda	#4
.a26e		4c 19 95	jmp $9519		jmp	ErrorHandler
.a271						ICSetPointer:
.a271		b5 60		lda $60,x			lda 	NSMantissa0,x 				; set zTemp0 to point to it.
.a273		85 36		sta $36				sta 	zTemp0
.a275		b5 70		lda $70,x			lda 	NSMantissa1,x
.a277		85 37		sta $37				sta 	zTemp0+1
.a279		60		rts				rts
.07ca						ICSeperator:
>07ca								.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/spc.asm

.a27a						SpcUnary:
.a27a		fa		plx				plx 								; restore stack pos
.a27b		20 1d a4	jsr $a41d			jsr 	Evaluate8BitInteger			; get value
.a27e		5a		phy				phy
.a27f		48		pha				pha 								; save count
.a280		20 89 b7	jsr $b789			jsr 	StringTempAllocate
.a283		7a		ply				ply 								; to do count in Y
.a284						_SpcLoop:
.a284		c0 00		cpy #$00			cpy 	#0 							; copy Y spaces in.
.a286		f0 08		beq $a290			beq 	_SpcExit
.a288		a9 20		lda #$20			lda 	#32
.a28a		20 c2 b7	jsr $b7c2			jsr 	StringTempWrite
.a28d		88		dey				dey
.a28e		80 f4		bra $a284			bra 	_SpcLoop
.a290						_SpcExit:
.a290		7a		ply				ply
.a291		20 00 95	jsr $9500			jsr 	CheckRightBracket
.a294		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/str.asm

.a295						Unary_Str:
.a295		fa		plx				plx
.a296		20 d0 a3	jsr $a3d0			jsr 	EvaluateNumber  			; get number
.a299		20 00 95	jsr $9500			jsr 	CheckRightBracket 			; closing bracket
.a29c		a9 05		lda #$05			lda 	#5 							; maximum decimals, from Basic816
.a29e		20 b7 a2	jsr $a2b7			jsr 	ConvertNumberToString 		; do the conversion.
.a2a1		a9 21		lda #$21			lda		#33 						; create buffer
.a2a3		20 89 b7	jsr $b789			jsr 	StringTempAllocate 			; allocate memory
.a2a6		da		phx				phx  								; copy the converted string into the buffer.
.a2a7		a2 00		ldx #$00			ldx 	#0
.a2a9						_USCopy:
.a2a9		bd 65 06	lda $0665,x			lda 	decimalBuffer,x
.a2ac		20 c2 b7	jsr $b7c2			jsr 	StringTempWrite
.a2af		e8		inx				inx
.a2b0		bd 65 06	lda $0665,x			lda 	decimalBuffer,x
.a2b3		d0 f4		bne $a2a9			bne 	_USCopy
.a2b5		fa		plx				plx
.a2b6		60		rts				rts
.a2b7						ConvertNumberToString:
.a2b7		5a		phy				phy 								; save code position
.a2b8		8d 30 04	sta $0430			sta 	decimalPlaces	 			; save number of DPs.
.a2bb		9c 31 04	stz $0431			stz 	dbOffset 					; offset into decimal buffer = start.
.a2be		b5 50		lda $50,x			lda 	NSStatus,x  				; is it -ve.
.a2c0		10 09		bpl $a2cb			bpl 	_CNTSNotNegative
.a2c2		29 7f		and #$7f			and 	#$7F 						; make +ve
.a2c4		95 50		sta $50,x			sta 	NSStatus,x
.a2c6		a9 2d		lda #$2d			lda 	#"-"
.a2c8		20 2c a3	jsr $a32c			jsr 	WriteDecimalBuffer
.a2cb						_CNTSNotNegative:
.a2cb		b5 a0		lda $a0,x			lda 	NSExponent,x 				; check if decimal
.a2cd		f0 12		beq $a2e1			beq 	_CNTSNotFloat
.a2cf		e8		inx				inx 								; round up so we don't get too many 6.999999
.a2d0		a9 01		lda #$01			lda 	#1
.a2d2		20 84 a4	jsr $a484			jsr 	NSMSetByte
.a2d5		ca		dex				dex
.a2d6		b5 a0		lda $a0,x			lda		NSExponent,x
.a2d8		95 a1		sta $a1,x			sta 	NSExponent+1,x
.a2da		a9 08		lda #$08			lda 	#NSTFloat
.a2dc		95 51		sta $51,x			sta 	NSStatus+1,x
.a2de		20 77 9a	jsr $9a77			jsr 	FloatAdd
.a2e1						_CNTSNotFloat:
.a2e1		20 0e a3	jsr $a30e			jsr 	MakePlusTwoString 			; do the integer part.
.a2e4		20 3d 9b	jsr $9b3d			jsr 	FloatFractionalPart 		; get the fractional part
.a2e7		20 ee 9b	jsr $9bee			jsr 	NSNormalise					; normalise , exit if zero
.a2ea		f0 20		beq $a30c			beq 	_CNTSExit
.a2ec		a9 2e		lda #$2e			lda 	#"."
.a2ee		20 2c a3	jsr $a32c			jsr 	WriteDecimalBuffer 			; write decimal place
.a2f1						_CNTSDecimal:
.a2f1		ce 30 04	dec $0430			dec 	decimalPlaces 				; done all the decimals
.a2f4		30 16		bmi $a30c			bmi 	_CNTSExit
.a2f6		e8		inx				inx 								; x 10.0
.a2f7		a9 0a		lda #$0a			lda 	#10
.a2f9		20 84 a4	jsr $a484			jsr 	NSMSetByte
.a2fc		a9 08		lda #$08			lda 	#NSTFloat
.a2fe		95 50		sta $50,x			sta 	NSStatus,x
.a300		ca		dex				dex
.a301		20 bc 9b	jsr $9bbc			jsr 	FloatMultiply
.a304		20 0e a3	jsr $a30e			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.a307		20 3d 9b	jsr $9b3d			jsr 	FloatFractionalPart 		; get the fractional part
.a30a		80 e5		bra $a2f1			bra 	_CNTSDecimal 				; keep going.
.a30c						_CNTSExit:
.a30c		7a		ply				ply
.a30d		60		rts				rts
.a30e						MakePlusTwoString:
.a30e		da		phx				phx
.a30f		20 65 a4	jsr $a465			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.a312		e8		inx				inx 								; access it
.a313		e8		inx				inx
.a314		20 95 9b	jsr $9b95			jsr 	FloatIntegerPart 			; make it an integer
.a317		a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.a319		20 9e 99	jsr $999e			jsr 	ConvertInt32
.a31c		a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.a31e						_MPTSCopy:
.a31e		bd 43 06	lda $0643,x			lda 	numberBuffer,x
.a321		20 2c a3	jsr $a32c			jsr 	WriteDecimalBuffer
.a324		e8		inx				inx
.a325		bd 43 06	lda $0643,x			lda 	numberBuffer,x
.a328		d0 f4		bne $a31e			bne 	_MPTSCopy
.a32a		fa		plx				plx
.a32b		60		rts				rts
.a32c						WriteDecimalBuffer:
.a32c		da		phx				phx
.a32d		ae 31 04	ldx $0431			ldx 	dbOffset
.a330		9d 65 06	sta $0665,x			sta 	decimalBuffer,x
.a333		9e 66 06	stz $0666,x			stz 	decimalBuffer+1,x
.a336		ee 31 04	inc $0431			inc 	dbOffset
.a339		fa		plx				plx
.a33a		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/substring.asm

.a33b						Unary_Left:
.a33b		fa		plx				plx
.a33c		18		clc				clc 								; only one parameter
.a33d		20 a0 a3	jsr $a3a0			jsr 	SubstringInitial 			; set up.
.a340		b5 61		lda $61,x			lda 	NSMantissa0+1,x 			; Param #1 is the length
.a342		95 62		sta $62,x			sta 	NSMantissa0+2,x
.a344		74 61		stz $61,x			stz 	NSMantissa0+1,x 			; Start is zero.
.a346		80 25		bra $a36d			bra 	SubstringMain
.a348						Unary_Right:
.a348		fa		plx				plx
.a349		18		clc				clc 								; only one parameter
.a34a		20 a0 a3	jsr $a3a0			jsr 	SubstringInitial 			; set up.
.a34d		b5 61		lda $61,x			lda 	NSMantissa0+1,x 			; length => param 2
.a34f		95 62		sta $62,x			sta 	NSMantissa0+2,x
.a351		b5 a0		lda $a0,x			lda 	NSExponent,x 				; total length
.a353		f5 61		sbc $61,x			sbc 	NSMantissa0+1,x 			; length - required.
.a355		b0 02		bcs $a359			bcs 	_URNotUnderflow
.a357		a9 00		lda #$00			lda 	#0 							; start from the beginning, as something like right$("AB",3)
.a359						_URNotUnderflow:
.a359		95 61		sta $61,x			sta 	NSMantissa0+1,x 			; this is the start position
.a35b		80 10		bra $a36d			bra 	SubstringMain
.a35d						Unary_Mid:
.a35d		fa		plx				plx
.a35e		38		sec				sec 								; two parameters
.a35f		20 a0 a3	jsr $a3a0			jsr 	SubstringInitial 			; set up.
.a362		b5 61		lda $61,x			lda 	NSMantissa0+1,x 			; first parameter is zero ?
.a364		f0 04		beq $a36a			beq 	_UMError
.a366		d6 61		dec $61,x			dec 	NSMantissa0+1,x				; reduce initial offset by 1 as MID$(a$,1..) is actually the first character
.a368		80 03		bra $a36d			bra 	SubstringMain
.a36a						_UMError:
.a36a		4c 09 a6	jmp $a609			jmp 	ArgumentError
.a36d						SubstringMain:
.a36d		b5 61		lda $61,x			lda 	NSMantissa0+1,x 			; is the initial offset >= the length
.a36f		d5 a0		cmp $a0,x			cmp 	NSExponent,x
.a371		b0 27		bcs $a39a			bcs 	_SSMNull 					; if so, return an empty string.
.a373		b5 62		lda $62,x			lda 	NSMantissa0+2,x 			; if copy count is zero
.a375		f0 23		beq $a39a			beq 	_SSMNull 					; return empty string.
.a377		18		clc				clc 								; add the offset +1 to the address and
.a378		b5 60		lda $60,x			lda	 	NSMantissa0,x 				; put in zTemp, this is the start of the substring to copy.
.a37a		75 61		adc $61,x			adc 	NSMantissa0+1,x
.a37c		85 36		sta $36				sta 	zTemp0
.a37e		b5 70		lda $70,x			lda	 	NSMantissa1,x
.a380		69 00		adc #$00			adc 	#0
.a382		85 37		sta $37				sta 	zTemp0+1
.a384						_SSMNoCarry:
.a384		b5 62		lda $62,x			lda 	NSMantissa0+2,x 			; characters required.
.a386		20 89 b7	jsr $b789			jsr 	StringTempAllocate 			; allocate that many characters
.a389		5a		phy				phy 								; save Y
.a38a		a0 00		ldy #$00			ldy 	#0 							; start copying in.
.a38c						_SSMCopy:
.a38c		b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next character
.a38e		f0 08		beq $a398			beq 	_SSMEString 				; no more to copy
.a390		20 c2 b7	jsr $b7c2			jsr 	StringTempWrite 			; and write it out.
.a393		c8		iny				iny
.a394		d6 62		dec $62,x			dec 	NSMantissa0+2,x
.a396		d0 f4		bne $a38c			bne 	_SSMCopy
.a398						_SSMEString:
.a398		7a		ply				ply
.a399						_SSMExit:
.a399		60		rts				rts
.a39a						_SSMNull:
.a39a		a9 00		lda #$00			lda 	#0
.a39c		20 89 b7	jsr $b789			jsr 	StringTempAllocate
.a39f		60		rts				rts
.a3a0						SubstringInitial:
.a3a0		da		phx				phx 								; save initial stack position
.a3a1		08		php				php 								; save carry on stack indicating 2 parameters
.a3a2		20 da a3	jsr $a3da			jsr 	EvaluateString 				; get a string
.a3a5		5a		phy				phy 								; calculate length to exponent.
.a3a6		a0 ff		ldy #$ff			ldy 	#$FF
.a3a8						_SIFindLength:
.a3a8		c8		iny				iny
.a3a9		b1 36		lda ($36),y			lda 	(zTemp0),y
.a3ab		d0 fb		bne $a3a8			bne 	_SIFindLength
.a3ad		98		tya				tya
.a3ae		95 a0		sta $a0,x			sta 	NSExponent,x
.a3b0		7a		ply				ply
.a3b1		e8		inx				inx
.a3b2		20 08 95	jsr $9508			jsr 	CheckComma 					; comma next
.a3b5		20 1d a4	jsr $a41d			jsr 	Evaluate8BitInteger 		; get next parameter
.a3b8		28		plp				plp 								; is it the last parameter ?
.a3b9		90 07		bcc $a3c2			bcc 	_SSIExit 					; if so, exit.
.a3bb		e8		inx				inx
.a3bc		20 08 95	jsr $9508			jsr 	CheckComma 					; comma next
.a3bf		20 1d a4	jsr $a41d			jsr 	Evaluate8BitInteger 		; get last parameter
.a3c2						_SSIExit:
.a3c2		fa		plx				plx
.a3c3		20 00 95	jsr $9500			jsr 	CheckRightBracket 			; check closing bracket
.a3c6		60		rts				rts 								; exit

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/exprhelper.asm

.a3c7						EvaluateValue:
.a3c7		48		pha				pha
.a3c8		20 23 9a	jsr $9a23			jsr		EvaluateExpression 			; expression
.a3cb		20 ef 9c	jsr $9cef			jsr 	Dereference					; derefernce it
.a3ce		68		pla				pla
.a3cf		60		rts				rts
.a3d0						EvaluateNumber:
.a3d0		20 c7 a3	jsr $a3c7			jsr 	EvaluateValue 				; get a value
.a3d3		b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.a3d5		29 10		and #$10			and 	#NSBIsString
.a3d7		d0 13		bne $a3ec			bne 	HelperTypeError
.a3d9		60		rts				rts
.a3da						EvaluateString:
.a3da		20 c7 a3	jsr $a3c7			jsr 	EvaluateValue 				; get a value
.a3dd		b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.a3df		29 10		and #$10			and 	#NSBIsString
.a3e1		f0 09		beq $a3ec			beq 	HelperTypeError
.a3e3						CopyAddressToTemp0:
.a3e3		b5 60		lda $60,x			lda 	NSMantissa0,x 				; copy address -> zTemp0
.a3e5		85 36		sta $36				sta 	zTemp0 						; (so we can do something with it)
.a3e7		b5 70		lda $70,x			lda 	NSMantissa1,x
.a3e9		85 37		sta $37				sta 	zTemp0+1
.a3eb		60		rts				rts
.a3ec						HelperTypeError:
.a3ec		4c 04 a6	jmp $a604			jmp 	TypeError
.a3ef						EvaluateInteger:
.a3ef		20 d0 a3	jsr $a3d0			jsr 	EvaluateNumber
.a3f2		b5 a0		lda $a0,x			lda 	NSExponent,x 				; check exponent is zero
.a3f4		d0 09		bne $a3ff			bne 	HelperValueError 			; if not, it's a float.
.a3f6		60		rts				rts
.a3f7						EvaluateUnsignedInteger:
.a3f7		20 ef a3	jsr $a3ef			jsr 	EvaluateInteger 			; check integer is +ve
.a3fa		b5 50		lda $50,x			lda 	NSStatus,x
.a3fc		30 01		bmi $a3ff			bmi 	HelperValueError
.a3fe		60		rts				rts
.a3ff						HelperValueError:
.a3ff		4c 09 a6	jmp $a609			jmp 	ArgumentError
.a402						Evaluate16BitInteger:
.a402		20 f7 a3	jsr $a3f7			jsr	 	EvaluateUnsignedInteger		; get integer
.a405		b5 90		lda $90,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.a407		15 80		ora $80,x			ora 	NSMantissa2,x
.a409		d0 f4		bne $a3ff			bne 	HelperValueError
.a40b		60		rts				rts
.a40c						Evaluate16BitIntegerSigned:
.a40c		20 ef a3	jsr $a3ef			jsr	 	EvaluateInteger				; get integer
.a40f		b5 90		lda $90,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.a411		15 80		ora $80,x			ora 	NSMantissa2,x
.a413		d0 ea		bne $a3ff			bne 	HelperValueError
.a415		b5 50		lda $50,x			lda 	NSStatus,x 					; signed ?
.a417		10 03		bpl $a41c			bpl 	_EISNotSigned
.a419		20 4b a4	jsr $a44b			jsr 	NSMNegateMantissa 			; makes it an actual 2's complement value.
.a41c						_EISNotSigned:
.a41c		60		rts				rts
.a41d						Evaluate8BitInteger:
.a41d		20 f7 a3	jsr $a3f7			jsr	 	EvaluateUnsignedInteger 	; get an integer
.a420		d0 dd		bne $a3ff			bne 	HelperValueError
.a422		b5 90		lda $90,x			lda 	NSMantissa3,x	 			; bytes 1, 2 & 3 must be zero
.a424		15 80		ora $80,x			ora 	NSMantissa2,x
.a426		15 70		ora $70,x			ora 	NSMantissa1,x
.a428		d0 d5		bne $a3ff			bne 	HelperValueError
.a42a		b5 60		lda $60,x			lda 	NSMantissa0,x
.a42c		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/mult8x8.asm

.a42d						Multiply8x8:
.a42d		4a		lsr a		  		lsr 	a  							; prime the carry bit for the loop
.a42e		85 36		sta $36			  	sta 	zTemp0
.a430		86 37		stx $37				stx 	zTemp0+1
.a432		a9 00		lda #$00			lda 	#0
.a434		a2 08		ldx #$08			ldx 	#8
.a436						_M88Loop:
.a436		90 03		bcc $a43b			bcc 	_M88NoAdd
.a438		18		clc				clc
.a439		65 37		adc $37				adc 	zTemp0+1
.a43b						_M88NoAdd:
.a43b		6a		ror a				ror 	a
.a43c		66 36		ror $36				ror 	zTemp0  					; pull another bit out for the next iteration
.a43e		ca		dex				dex         						; inc/dec don't modify carry; only shifts and adds do
.a43f		d0 f5		bne $a436			bne 	_M88Loop
.a441		85 37		sta $37				sta 	zTemp0+1 					; store high 8 bits.
.a443		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/utility.asm

.a444						NSMNegate:
.a444		b5 50		lda $50,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.a446		49 80		eor #$80			eor 	#NSBIsNegative  			; toggle the negative flag
.a448		95 50		sta $50,x			sta 	NSStatus,x
.a44a		60		rts				rts
.a44b						NSMNegateMantissa:
.a44b		38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.a44c		a9 00		lda #$00			lda 	#0
.a44e		f5 60		sbc $60,x			sbc 	NSMantissa0,x
.a450		95 60		sta $60,x			sta 	NSMantissa0,x
.a452		a9 00		lda #$00			lda 	#0
.a454		f5 70		sbc $70,x			sbc 	NSMantissa1,x
.a456		95 70		sta $70,x			sta 	NSMantissa1,x
.a458		a9 00		lda #$00			lda 	#0
.a45a		f5 80		sbc $80,x			sbc 	NSMantissa2,x
.a45c		95 80		sta $80,x			sta 	NSMantissa2,x
.a45e		a9 00		lda #$00			lda 	#0
.a460		f5 90		sbc $90,x			sbc 	NSMantissa3,x
.a462		95 90		sta $90,x			sta 	NSMantissa3,x
.a464		60		rts				rts
.a465						NSMShiftUpTwo:
.a465		b5 60		lda $60,x			lda 	NSMantissa0,x
.a467		95 62		sta $62,x			sta 	NSMantissa0+2,x
.a469		b5 70		lda $70,x			lda 	NSMantissa1,x
.a46b		95 72		sta $72,x			sta 	NSMantissa1+2,x
.a46d		b5 80		lda $80,x			lda 	NSMantissa2,x
.a46f		95 82		sta $82,x			sta 	NSMantissa2+2,x
.a471		b5 90		lda $90,x			lda 	NSMantissa3,x
.a473		95 92		sta $92,x			sta 	NSMantissa3+2,x
.a475		b5 a0		lda $a0,x			lda 	NSExponent,x
.a477		95 a2		sta $a2,x			sta 	NSExponent+2,x
.a479		b5 50		lda $50,x			lda 	NSStatus,x
.a47b		95 52		sta $52,x			sta 	NSStatus+2,x
.a47d		60		rts				rts
.a47e						NSMSetZeroMantissaOnly:
.a47e		a9 00		lda #$00			lda 	#0
.a480		80 06		bra $a488			bra 	NSMSetMantissa
.a482						NSMSetZero:
.a482		a9 00		lda #$00			lda 	#0
.a484						NSMSetByte:
.a484		74 a0		stz $a0,x			stz 	NSExponent,x 				; zero exponent, as integer.
.a486		74 50		stz $50,x			stz 	NSStatus,x 					; status zero (integer)
.a488						NSMSetMantissa:
.a488		95 60		sta $60,x			sta 	NSMantissa0,x 				; mantissa
.a48a		74 70		stz $70,x			stz 	NSMantissa1,x
.a48c		74 80		stz $80,x			stz 	NSMantissa2,x
.a48e		74 90		stz $90,x			stz 	NSMantissa3,x
.a490		60		rts				rts
.a491						NSMShiftLeft:
.a491		18		clc				clc
.a492						NSMRotateLeft:
.a492		36 60		rol $60,x			rol 	NSMantissa0,x
.a494		36 70		rol $70,x			rol		NSMantissa1,x
.a496		36 80		rol $80,x			rol		NSMantissa2,x
.a498		36 90		rol $90,x			rol		NSMantissa3,x
.a49a		60		rts				rts
.a49b						NSMShiftRight:
.a49b		56 90		lsr $90,x			lsr 	NSMantissa3,x
.a49d		76 80		ror $80,x			ror		NSMantissa2,x
.a49f		76 70		ror $70,x			ror		NSMantissa1,x
.a4a1		76 60		ror $60,x			ror		NSMantissa0,x
.a4a3		60		rts				rts
.a4a4						NSMIsZero:
.a4a4		b5 90		lda $90,x			lda 	NSMantissa3,x
.a4a6		15 80		ora $80,x			ora		NSMantissa2,x
.a4a8		15 70		ora $70,x			ora		NSMantissa1,x
.a4aa		15 60		ora $60,x			ora		NSMantissa0,x
.a4ac		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/asmcore.asm

.a4ad						Assemble_ora:
.a4ad		20 30 85	jsr $8530		jsr	AssembleGroup1
>a4b0		01					.byte $01
.a4b1						Assemble_and:
.a4b1		20 30 85	jsr $8530		jsr	AssembleGroup1
>a4b4		21					.byte $21
.a4b5						Assemble_eor:
.a4b5		20 30 85	jsr $8530		jsr	AssembleGroup1
>a4b8		41					.byte $41
.a4b9						Assemble_adc:
.a4b9		20 30 85	jsr $8530		jsr	AssembleGroup1
>a4bc		61					.byte $61
.a4bd						Assemble_sta:
.a4bd		20 30 85	jsr $8530		jsr	AssembleGroup1
>a4c0		81					.byte $81
.a4c1						Assemble_lda:
.a4c1		20 30 85	jsr $8530		jsr	AssembleGroup1
>a4c4		a1					.byte $a1
.a4c5						Assemble_cmp:
.a4c5		20 30 85	jsr $8530		jsr	AssembleGroup1
>a4c8		c1					.byte $c1
.a4c9						Assemble_sbc:
.a4c9		20 30 85	jsr $8530		jsr	AssembleGroup1
>a4cc		e1					.byte $e1
.a4cd						Assemble_asl:
.a4cd		20 37 85	jsr $8537		jsr	AssembleGroup2
>a4d0		02					.byte $02
>a4d1		75					.byte $75
.a4d2						Assemble_rol:
.a4d2		20 37 85	jsr $8537		jsr	AssembleGroup2
>a4d5		22					.byte $22
>a4d6		75					.byte $75
.a4d7						Assemble_lsr:
.a4d7		20 37 85	jsr $8537		jsr	AssembleGroup2
>a4da		42					.byte $42
>a4db		75					.byte $75
.a4dc						Assemble_ror:
.a4dc		20 37 85	jsr $8537		jsr	AssembleGroup2
>a4df		62					.byte $62
>a4e0		75					.byte $75
.a4e1						Assemble_stx:
.a4e1		20 37 85	jsr $8537		jsr	AssembleGroup2
>a4e4		82					.byte $82
>a4e5		50					.byte $50
.a4e6						Assemble_ldx:
.a4e6		20 37 85	jsr $8537		jsr	AssembleGroup2
>a4e9		a2					.byte $a2
>a4ea		d0					.byte $d0
.a4eb						Assemble_dec:
.a4eb		20 37 85	jsr $8537		jsr	AssembleGroup2
>a4ee		c2					.byte $c2
>a4ef		55					.byte $55
.a4f0						Assemble_inc:
.a4f0		20 37 85	jsr $8537		jsr	AssembleGroup2
>a4f3		e2					.byte $e2
>a4f4		55					.byte $55
.a4f5						Assemble_stz:
.a4f5		20 37 85	jsr $8537		jsr	AssembleGroup2
>a4f8		60					.byte $60
>a4f9		44					.byte $44
.a4fa						Assemble_bit:
.a4fa		20 37 85	jsr $8537		jsr	AssembleGroup2
>a4fd		20					.byte $20
>a4fe		55					.byte $55
.a4ff						Assemble_sty:
.a4ff		20 37 85	jsr $8537		jsr	AssembleGroup2
>a502		80					.byte $80
>a503		54					.byte $54
.a504						Assemble_ldy:
.a504		20 37 85	jsr $8537		jsr	AssembleGroup2
>a507		a0					.byte $a0
>a508		d5					.byte $d5
.a509						Assemble_cpy:
.a509		20 37 85	jsr $8537		jsr	AssembleGroup2
>a50c		c0					.byte $c0
>a50d		d4					.byte $d4
.a50e						Assemble_cpx:
.a50e		20 37 85	jsr $8537		jsr	AssembleGroup2
>a511		e0					.byte $e0
>a512		d0					.byte $d0
.a513						Assemble_tsb:
.a513		20 37 85	jsr $8537		jsr	AssembleGroup2
>a516		00					.byte $00
>a517		50					.byte $50
.a518						Assemble_trb:
.a518		20 37 85	jsr $8537		jsr	AssembleGroup2
>a51b		10					.byte $10
>a51c		50					.byte $50
.a51d						Assemble_jsr:
.a51d		20 37 85	jsr $8537		jsr	AssembleGroup2
>a520		14					.byte $14
>a521		10					.byte $10
.a522						Assemble_jmp:
.a522		20 37 85	jsr $8537		jsr	AssembleGroup2
>a525		40					.byte $40
>a526		10					.byte $10
.a527						Assemble_bpl:
.a527		20 88 85	jsr $8588		jsr	AssembleGroup3
>a52a		10					.byte $10
.a52b						Assemble_bmi:
.a52b		20 88 85	jsr $8588		jsr	AssembleGroup3
>a52e		30					.byte $30
.a52f						Assemble_bvc:
.a52f		20 88 85	jsr $8588		jsr	AssembleGroup3
>a532		50					.byte $50
.a533						Assemble_bvs:
.a533		20 88 85	jsr $8588		jsr	AssembleGroup3
>a536		70					.byte $70
.a537						Assemble_bcc:
.a537		20 88 85	jsr $8588		jsr	AssembleGroup3
>a53a		90					.byte $90
.a53b						Assemble_bcs:
.a53b		20 88 85	jsr $8588		jsr	AssembleGroup3
>a53e		b0					.byte $b0
.a53f						Assemble_bne:
.a53f		20 88 85	jsr $8588		jsr	AssembleGroup3
>a542		d0					.byte $d0
.a543						Assemble_beq:
.a543		20 88 85	jsr $8588		jsr	AssembleGroup3
>a546		f0					.byte $f0
.a547						Assemble_bra:
.a547		20 88 85	jsr $8588		jsr	AssembleGroup3
>a54a		80					.byte $80
.a54b						Assemble_brk:
.a54b		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a54e		00					.byte $00
.a54f						Assemble_php:
.a54f		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a552		08					.byte $08
.a553						Assemble_clc:
.a553		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a556		18					.byte $18
.a557						Assemble_plp:
.a557		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a55a		28					.byte $28
.a55b						Assemble_sec:
.a55b		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a55e		38					.byte $38
.a55f						Assemble_rti:
.a55f		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a562		40					.byte $40
.a563						Assemble_pha:
.a563		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a566		48					.byte $48
.a567						Assemble_cli:
.a567		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a56a		58					.byte $58
.a56b						Assemble_phy:
.a56b		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a56e		5a					.byte $5a
.a56f						Assemble_rts:
.a56f		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a572		60					.byte $60
.a573						Assemble_pla:
.a573		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a576		68					.byte $68
.a577						Assemble_sei:
.a577		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a57a		78					.byte $78
.a57b						Assemble_ply:
.a57b		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a57e		7a					.byte $7a
.a57f						Assemble_dey:
.a57f		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a582		88					.byte $88
.a583						Assemble_txa:
.a583		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a586		8a					.byte $8a
.a587						Assemble_tya:
.a587		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a58a		98					.byte $98
.a58b						Assemble_txs:
.a58b		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a58e		9a					.byte $9a
.a58f						Assemble_tay:
.a58f		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a592		a8					.byte $a8
.a593						Assemble_tax:
.a593		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a596		aa					.byte $aa
.a597						Assemble_clv:
.a597		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a59a		b8					.byte $b8
.a59b						Assemble_tsx:
.a59b		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a59e		ba					.byte $ba
.a59f						Assemble_iny:
.a59f		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a5a2		c8					.byte $c8
.a5a3						Assemble_dex:
.a5a3		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a5a6		ca					.byte $ca
.a5a7						Assemble_cld:
.a5a7		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a5aa		d8					.byte $d8
.a5ab						Assemble_phx:
.a5ab		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a5ae		da					.byte $da
.a5af						Assemble_stp:
.a5af		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a5b2		db					.byte $db
.a5b3						Assemble_inx:
.a5b3		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a5b6		e8					.byte $e8
.a5b7						Assemble_nop:
.a5b7		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a5ba		ea					.byte $ea
.a5bb						Assemble_sed:
.a5bb		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a5be		f8					.byte $f8
.a5bf						Assemble_plx:
.a5bf		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a5c2		fa					.byte $fa

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/constants.asm

.a5c3						DecimalScalarTable:
>a5c3		66 66 66 66				.dword $66666666 ; 0.1
>a5c7		de					.byte $de
>a5c8		1f 85 eb 51				.dword $51eb851f ; 0.01
>a5cc		db					.byte $db
>a5cd		4c 37 89 41				.dword $4189374c ; 0.001
>a5d1		d8					.byte $d8
>a5d2		ac 8b db 68				.dword $68db8bac ; 0.0001
>a5d6		d4					.byte $d4
>a5d7		24 d6 e2 53				.dword $53e2d624 ; 1e-05
>a5db		d1					.byte $d1
>a5dc		83 de 1b 43				.dword $431bde83 ; 1e-06
>a5e0		ce					.byte $ce
>a5e1		6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>a5e5		ca					.byte $ca
>a5e6		89 3b e6 55				.dword $55e63b89 ; 1e-08
>a5ea		c7					.byte $c7
>a5eb		a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>a5ef		c4					.byte $c4
>a5f0		67 7f f3 6d				.dword $6df37f67 ; 1e-10
>a5f4		c0					.byte $c0
>a5f5		86 ff f5 57				.dword $57f5ff86 ; 1e-11
>a5f9		bd					.byte $bd

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.asm

.a5fa						SyntaxError:
.a5fa		a9 02		lda #$02		lda	#2
.a5fc		4c 19 95	jmp $9519		jmp	ErrorHandler
.a5ff						RangeError:
.a5ff		a9 04		lda #$04		lda	#4
.a601		4c 19 95	jmp $9519		jmp	ErrorHandler
.a604						TypeError:
.a604		a9 05		lda #$05		lda	#5
.a606		4c 19 95	jmp $9519		jmp	ErrorHandler
.a609						ArgumentError:
.a609		a9 07		lda #$07		lda	#7
.a60b		4c 19 95	jmp $9519		jmp	ErrorHandler
.a60e						NotDoneError:
.a60e		a9 0c		lda #$0c		lda	#12
.a610		4c 19 95	jmp $9519		jmp	ErrorHandler
.a613						ErrorText:
>a613		42 72 65 61 6b 00			.text	"Break",0
>a619		53 79 6e 74 61 78 20 65			.text	"Syntax error",0
>a621		72 72 6f 72 00
>a626		44 69 76 69 73 69 6f 6e			.text	"Division by zero",0
>a62e		20 62 79 20 7a 65 72 6f 00
>a637		4f 75 74 20 6f 66 20 52			.text	"Out of Range",0
>a63f		61 6e 67 65 00
>a644		54 79 70 65 20 6d 69 73			.text	"Type mismatch",0
>a64c		6d 61 74 63 68 00
>a652		4f 75 74 20 6f 66 20 6d			.text	"Out of memory",0
>a65a		65 6d 6f 72 79 00
>a660		49 6c 6c 65 67 61 6c 20			.text	"Illegal argument",0
>a668		61 72 67 75 6d 65 6e 74 00
>a671		53 74 6f 70 00				.text	"Stop",0
>a676		53 74 72 69 6e 67 20 74			.text	"String too long",0
>a67e		6f 6f 20 6c 6f 6e 67 00
>a686		41 73 73 65 72 74 69 6f			.text	"Assertion failed",0
>a68e		6e 20 66 61 69 6c 65 64 00
>a697		4f 75 74 20 6f 66 20 64			.text	"Out of data",0
>a69f		61 74 61 00
>a6a3		55 6e 69 6d 70 6c 65 6d			.text	"Unimplemented",0
>a6ab		65 6e 74 65 64 00
>a6b1		4e 6f 20 73 75 63 68 20			.text	"No such line number",0
>a6b9		6c 69 6e 65 20 6e 75 6d 62 65 72 00
>a6c5		52 65 74 75 72 6e 20 77			.text	"Return without Gosub",0
>a6cd		69 74 68 6f 75 74 20 47 6f 73 75 62 00
>a6da		55 6e 74 69 6c 20 77 69			.text	"Until without Repeat",0
>a6e2		74 68 6f 75 74 20 52 65 70 65 61 74 00
>a6ef		57 65 6e 64 20 77 69 74			.text	"Wend without While",0
>a6f7		68 6f 75 74 20 57 68 69 6c 65 00
>a702		4e 65 78 74 20 77 69 74			.text	"Next without For",0
>a70a		68 6f 75 74 20 46 6f 72 00
>a713		42 41 53 49 43 20 53 74			.text	"BASIC Stack full",0
>a71b		61 63 6b 20 66 75 6c 6c 00
>a724		4f 70 65 6e 20 53 74 72			.text	"Open Structure",0
>a72c		75 63 74 75 72 65 00
>a733		45 6e 64 50 72 6f 63 20			.text	"EndProc without call",0
>a73b		77 69 74 68 6f 75 74 20 63 61 6c 6c 00
>a748		41 72 72 61 79 20 61 6c			.text	"Array already defined",0
>a750		72 65 61 64 79 20 64 65 66 69 6e 65 64 00
>a75e		41 72 72 61 79 20 73 69			.text	"Array size",0
>a766		7a 65 00
>a769		42 61 64 20 61 72 72 61			.text	"Bad array index",0
>a771		79 20 69 6e 64 65 78 00
>a779		41 72 72 61 79 20 6e 6f			.text	"Array not declared",0
>a781		74 20 64 65 63 6c 61 72 65 64 00
>a78c		46 69 6c 65 20 6e 6f 74			.text	"File not found",0
>a794		20 66 6f 75 6e 64 00
>a79b		53 74 6f 72 61 67 65 20			.text	"Storage error",0
>a7a3		65 72 72 6f 72 00
>a7a9		56 65 72 69 66 79 20 66			.text	"Verify failed",0
>a7b1		61 69 6c 65 64 00
>a7b7		50 72 6f 67 72 61 6d 20			.text	"Program not found",0
>a7bf		6e 6f 74 20 66 6f 75 6e 64 00
>a7c9		54 6f 6f 20 6d 61 6e 79			.text	"Too many parameters",0
>a7d1		20 70 61 72 61 6d 65 74 65 72 73 00
>a7dd		46 6f 72 6d 75 6c 61 20			.text	"Formula too complex",0
>a7e5		74 6f 6f 20 63 6f 6d 70 6c 65 78 00
>a7f1		49 6e 69 74 69 61 6c 69			.text	"Initialization error",0
>a7f9		7a 61 74 69 6f 6e 20 65 72 72 6f 72 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/timestamp.asm

>e76b		09 09 30 31 2f 30 36 2f			.text 9,9,"01/06/25 01e"
>e773		32 35 20 30 31 65

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/memory/memory.flat/delete.asm

.a806						MemoryDeleteLine:
.a806		20 25 a8	jsr $a825			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a809		b2 30		lda ($30)			lda 	(codePtr) 					; size to delete => y
.a80b		a8		tay				tay
.a80c						_MDDLLoop:
.a80c		b1 30		lda ($30),y			lda 	(codePtr),y 				; copy down
.a80e		92 30		sta ($30)			sta 	(codePtr)
.a810		a5 30		lda $30				lda 	codePtr 					; check done the lot.
.a812		c5 3a		cmp $3a				cmp 	zTemp2 						; has codePtr (copyFrom) reached the last byte to copy.
.a814		d0 07		bne $a81d			bne 	_MDLDLNext
.a816		a5 31		lda $31				lda 	codePtr+1
.a818		c5 3b		cmp $3b				cmp 	zTemp2+1
.a81a		d0 01		bne $a81d			bne 	_MDLDLNext
.a81c						_MDDLExit:
.a81c		60		rts				rts
.a81d						_MDLDLNext:
.a81d		e6 30		inc $30				inc 	codePtr						; next byte
.a81f		d0 eb		bne $a80c			bne 	_MDDLLoop
.a821		e6 31		inc $31				inc 	codePtr+1
.a823		80 e7		bra $a80c			bra 	_MDDLLoop
.a825						IMemoryFindEnd:
.a825		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a827		85 3a		sta $3a				sta 	0+zTemp2
.a829		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a82b		85 3b		sta $3b				sta 	1+zTemp2
.a82d						_MDLFELoop:
.a82d		b2 3a		lda ($3a)			lda 	(zTemp2) 					; scan forward using offsets.
.a82f		f0 0b		beq $a83c			beq 	_MDLFEExit
.a831		18		clc				clc
.a832		65 3a		adc $3a				adc 	zTemp2
.a834		85 3a		sta $3a				sta 	zTemp2
.a836		90 f5		bcc $a82d			bcc 	_MDLFELoop
.a838		e6 3b		inc $3b				inc 	zTemp2+1
.a83a		80 f1		bra $a82d			bra 	_MDLFELoop
.a83c						_MDLFEExit:
.a83c		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/memory/memory.flat/insert.asm

.a83d						MemoryInsertLine:
.a83d		08		php				php
.a83e		20 25 a8	jsr $a825			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a841		a5 3b		lda $3b				lda 	zTemp2+1 					; is there space for the new line ?
.a843		1a		inc a				inc 	a
.a844		c9 7f		cmp #$7f			cmp 	#(BasicEnd >> 8)-1
.a846		b0 36		bcs $a87e			bcs 	_MDLIError 					; no, fail.
.a848		28		plp				plp 								; do at a specific point or the end ?
.a849		90 08		bcc $a853			bcc 	_MDLIFound 					; if specific point already set.
.a84b		a5 3a		lda $3a				lda 	zTemp2 						; if CS on entry append, so put on the
.a84d		85 30		sta $30				sta 	codePtr 					; end.
.a84f		a5 3b		lda $3b				lda 	zTemp2+1
.a851		85 31		sta $31				sta 	codePtr+1
.a853						_MDLIFound:
.a853		ad 46 04	lda $0446			lda 	tokenOffset 				; insert gap in Y, the offset, e.g. length of the new line
.a856		a8		tay				tay
.a857						_MDLIInsert:
.a857		b2 3a		lda ($3a)			lda 	(zTemp2) 					; shift one byte up , at least one covers end case (copying link 0)
.a859		91 3a		sta ($3a),y			sta 	(zTemp2),y 					; work from top down.
.a85b		a5 30		lda $30				lda 	codePtr 					; reached insert point ?
.a85d		c5 3a		cmp $3a				cmp 	zTemp2
.a85f		d0 06		bne $a867			bne 	_MDLINext
.a861		a5 31		lda $31				lda 	codePtr+1
.a863		c5 3b		cmp $3b				cmp 	zTemp2+1
.a865		f0 0a		beq $a871			beq 	_MDLIHaveSpace
.a867						_MDLINext:
.a867		a5 3a		lda $3a				lda 	zTemp2 						; if no, keep zTemp2 going backwards opening up space.
.a869		d0 02		bne $a86d			bne 	_MDLINoBorrow
.a86b		c6 3b		dec $3b				dec 	zTemp2+1
.a86d						_MDLINoBorrow:
.a86d		c6 3a		dec $3a				dec 	zTemp2
.a86f		80 e6		bra $a857			bra 	_MDLIInsert
.a871						_MDLIHaveSpace:
.a871		ac 46 04	ldy $0446			ldy 	tokenOffset 				; bytes to copy
.a874		88		dey				dey 								; from offset-1 (last written) to the end of the buffer.
.a875						_MDLICopy:
.a875		b9 46 04	lda $0446,y			lda 	tokenOffset,y
.a878		91 30		sta ($30),y			sta 	(codePtr),y
.a87a		88		dey				dey
.a87b		10 f8		bpl $a875			bpl 	_MDLICopy
.a87d		60		rts				rts
.a87e						_MDLIError:
.a87e		a9 06		lda #$06		lda	#6
.a880		4c 19 95	jmp $9519		jmp	ErrorHandler
.a883						MDLAppendLine:
.a883		86 37		stx $37				stx 	zTemp0+1 					; save new line at zTemp0
.a885		85 36		sta $36				sta 	zTemp0
.a887		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a889		85 38		sta $38				sta 	0+zTemp1
.a88b		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a88d		85 39		sta $39				sta 	1+zTemp1
.a88f		b2 38		lda ($38)			lda 	(zTemp1)
.a891		d0 0a		bne $a89d			bne 	_MDLANoInitialise
.a893		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a895		8d cb 07	sta $07cb			sta 	0+AppendPointer
.a898		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a89a		8d cc 07	sta $07cc			sta 	1+AppendPointer
.a89d						_MDLANoInitialise:
.a89d		18		clc				clc
.a89e		ad cb 07	lda $07cb			lda 	AppendPointer 				; copy append pointer to zTemp1 adding the offset as you go
.a8a1		85 38		sta $38				sta 	zTemp1
.a8a3		72 36		adc ($36)			adc 	(zTemp0)
.a8a5		8d cb 07	sta $07cb			sta 	AppendPointer
.a8a8		ad cc 07	lda $07cc			lda 	AppendPointer+1
.a8ab		85 39		sta $39				sta 	zTemp1+1
.a8ad		69 00		adc #$00			adc 	#0
.a8af		8d cc 07	sta $07cc			sta 	AppendPointer+1
.a8b2		a0 00		ldy #$00			ldy 	#0
.a8b4						_MDLACopy:
.a8b4		b1 36		lda ($36),y			lda 	(zTemp0),y 					; copy new line in
.a8b6		91 38		sta ($38),y			sta 	(zTemp1),y
.a8b8		c8		iny				iny
.a8b9		98		tya				tya
.a8ba		d2 36		cmp ($36)			cmp 	(zTemp0) 					; done whole line
.a8bc		d0 f6		bne $a8b4			bne 	_MDLACopy
.a8be		a9 00		lda #$00			lda 	#0 							; end of program.
.a8c0		91 38		sta ($38),y			sta 	(zTemp1),y
.a8c2		60		rts				rts
.07cb						AppendPointer:
>07cb								.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/memory/memory.flat/memory.asm

.a8c3						MemoryNew:
.a8c3		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a8c5		85 30		sta $30				sta 	codePtr
.a8c7		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a8c9		85 31		sta $31				sta 	codePtr+1
.a8cb		a9 00		lda #$00			lda 	#0 							; write zero there erasing the program.
.a8cd		92 30		sta ($30)			sta 	(codePtr)
.a8cf		60		rts				rts
.a8d0						MemoryInline:
.a8d0		98		tya				tya 								; put address into stack,x
.a8d1		18		clc				clc  								; get the offset, add codePtr
.a8d2		65 30		adc $30				adc 	codePtr
.a8d4		95 60		sta $60,x			sta 	NSMantissa0,x 				; store the result in the mantissa.
.a8d6		a5 31		lda $31				lda 	codePtr+1
.a8d8		69 00		adc #$00			adc 	#0
.a8da		95 70		sta $70,x			sta 	NSMantissa1,x
.a8dc		74 80		stz $80,x			stz 	NSMantissa2,x
.a8de		74 90		stz $90,x			stz 	NSMantissa3,x
.a8e0		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/memory/memory.flat/search.asm

.a8e1						MemorySearch:
.a8e1		85 36		sta $36				sta 	zTemp0 						; save line number in zTemp0
.a8e3		86 37		stx $37				stx 	zTemp0+1
.a8e5		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a8e7		85 30		sta $30				sta 	codePtr
.a8e9		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a8eb		85 31		sta $31				sta 	codePtr+1
.a8ed						_MTAXLoop:
.a8ed		b2 30		lda ($30)			lda 	(codePtr)
.a8ef		18		clc				clc
.a8f0		f0 21		beq $a913			beq 	_MTAXExit 					; reached end, exit with CC.
.a8f2		a0 01		ldy #$01			ldy 	#1 							; calculate current line# - requested line#
.a8f4		b1 30		lda ($30),y			lda 	(codePtr),y
.a8f6		38		sec				sec
.a8f7		e5 36		sbc $36				sbc 	zTemp0
.a8f9		85 38		sta $38				sta 	zTemp1 						; save interim to set Z
.a8fb		c8		iny				iny 								; do the MSB
.a8fc		b1 30		lda ($30),y			lda 	(codePtr),y
.a8fe		e5 37		sbc $37				sbc 	zTemp0+1
.a900		05 38		ora $38				ora 	zTemp1 						; will set Z if result is zero, doesn't affect carry flag
.a902		f0 0f		beq $a913			beq 	_MTAXExit	 				; found so exit (CS will be set)
.a904		b0 0d		bcs $a913			bcs 	_MTAXExit 					; current < required exit
.a906		18		clc				clc
.a907		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.a909		65 30		adc $30				adc 	codePtr
.a90b		85 30		sta $30				sta 	codePtr
.a90d		90 02		bcc $a911			bcc 	_CREExit
.a90f		e6 31		inc $31				inc 	codePtr+1 					; carry
.a911						_CREExit:
.a911		80 da		bra $a8ed			bra 	_MTAXLoop
.a913						_MTAXExit:
.a913		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/graphics/gcommand.asm

.a914						RectangleCommand:
.a914		a9 44		lda #$44			lda 	#GCMD_FrameRect				; frame rectangle
.a916		80 02		bra $a91a			bra 	ShapeDrawCmd
.a918						CircleCommand:
.a918		a9 48		lda #$48			lda 	#GCMD_FrameCircle 				; framed circle
.a91a						ShapeDrawCmd:
.a91a		20 a4 a9	jsr $a9a4			jsr 	RunGraphicsCommand
.a91d						ShapeDraw:
.a91d		0d ce 07	ora $07ce			ora 	gxFillSolid  				; adjust AXY for solid fill.
.a920		4c 98 a9	jmp $a998			jmp 	ExecuteGraphicCommand	 	; and complete
.a923						SpriteCommand:
.a923		a2 00		ldx #$00			ldx 	#0
.a925		20 1d a4	jsr $a41d			jsr 	Evaluate8BitInteger 		; get image number.
.a928		5a		phy				phy
.a929		a9 0e		lda #$0e			lda 	#GCMD_SpriteUse 			; use that image.
.a92b		a6 60		ldx $60				ldx 	NSMantissa0
.a92d		e0 40		cpx #$40			cpx 	#64 						; 0-63 only
.a92f		b0 0d		bcs $a93e			bcs 	_SCRange
.a931		a0 ff		ldy #$ff			ldy 	#255
.a933		20 9d 80	jsr $809d			jsr 	GXGraphicDraw
.a936		a9 52		lda #$52			lda 	#GCMD_SpriteMove
.a938		7a		ply				ply
.a939		20 a4 a9	jsr $a9a4			jsr 	RunGraphicsCommand
.a93c		80 5a		bra $a998			bra 	ExecuteGraphicCommand
.a93e						_SCRange:
.a93e		4c ff a5	jmp $a5ff			jmp 	RangeError
.a941						ImageCommand:
.a941		a2 00		ldx #$00			ldx 	#0
.a943		20 1d a4	jsr $a41d			jsr 	Evaluate8BitInteger 		; get image number.
.a946		20 a4 a9	jsr $a9a4			jsr 	RunGraphicsCommand
.a949						ImageRunDraw:
.a949		09 40		ora #$40			ora 	#GCMD_Move					; move cursor
.a94b		20 9d 80	jsr $809d			jsr 	GXGraphicDraw
.a94e		ad d4 07	lda $07d4			lda 	gxDrawScale
.a951		0a		asl a				asl 	a
.a952		0a		asl a				asl 	a
.a953		0a		asl a				asl 	a
.a954		a8		tay				tay
.a955		a9 0c		lda #$0c			lda 	#GCMD_DrawSprite 			; image drawing
.a957		a6 60		ldx $60				ldx 	NSMantissa0
.a959		20 9d 80	jsr $809d			jsr 	GXGraphicDraw
.a95c		60		rts				rts
.a95d						TextCommand:
.a95d		a2 00		ldx #$00			ldx 	#0
.a95f		20 da a3	jsr $a3da			jsr 	EvaluateString 				; get text
.a962		20 a4 a9	jsr $a9a4			jsr 	RunGraphicsCommand
.a965						TextRunDraw:
.a965		09 40		ora #$40			ora 	#GCMD_Move 					; move cursor
.a967		20 9d 80	jsr $809d			jsr 	GXGraphicDraw
.a96a		a0 00		ldy #$00			ldy 	#0
.a96c						_IRDLoop:
.a96c		a5 70		lda $70				lda 	NSMantissa1 				; access character
.a96e		85 37		sta $37				sta 	zTemp0+1
.a970		a5 60		lda $60				lda 	NSMantissa0
.a972		85 36		sta $36				sta 	zTemp0
.a974		b1 36		lda ($36),y			lda 	(zTemp0),y
.a976		f0 13		beq $a98b			beq 	_IRDExit
.a978		5a		phy				phy									; save string pos
.a979		48		pha				pha 								; save char
.a97a		ad d4 07	lda $07d4			lda 	gxDrawScale 				; get scale
.a97d		0a		asl a				asl 	a
.a97e		0a		asl a				asl 	a
.a97f		0a		asl a				asl 	a
.a980		a8		tay				tay
.a981		a9 0a		lda #$0a			lda 	#GCMD_DrawFont 				; char drawing
.a983		fa		plx				plx 								; char to draw
.a984		20 9d 80	jsr $809d			jsr 	GXGraphicDraw
.a987		7a		ply				ply 								; restore string pos
.a988		c8		iny				iny
.a989		90 e1		bcc $a96c			bcc 	_IRDLoop 					; go back if no error.
.a98b						_IRDExit:
.a98b		60		rts				rts
.a98c						PlotCommand:
.a98c		a9 50		lda #$50			lda 	#GCMD_Plot 					; command ID to use
.a98e		20 a4 a9	jsr $a9a4			jsr 	RunGraphicsCommand
.a991		80 05		bra $a998			bra 	ExecuteGraphicCommand
.a993						LineCommand:
.a993		a9 42		lda #$42			lda 	#GCMD_Line 						; command ID to use
.a995		20 a4 a9	jsr $a9a4			jsr 	RunGraphicsCommand
.a998						ExecuteGraphicCommand:
.a998		0d cd 07	ora $07cd			ora 	gxCommandID 				; make a full command
.a99b		20 9d 80	jsr $809d			jsr 	GXGraphicDraw 				; draw it and exit
.a99e		b0 01		bcs $a9a1			bcs 	_EGCError
.a9a0		60		rts				rts
.a9a1						_EGCError:
.a9a1		4c fa a5	jmp $a5fa			jmp 	SyntaxError
.a9a4						RunGraphicsCommand:
.a9a4		8d cd 07	sta $07cd			sta 	gxCommandID					; save TODO graphics command.
.a9a7		68		pla				pla 								; pop handler address
.a9a8		fa		plx				plx
.a9a9		1a		inc a				inc 	a
.a9aa		d0 01		bne $a9ad			bne 	_RGINoCarry
.a9ac		e8		inx				inx
.a9ad						_RGINoCarry:
.a9ad		8d d2 07	sta $07d2			sta 	gxHandler
.a9b0		8e d3 07	stx $07d3			stx 	gxHandler+1
.a9b3						_RGICommandLoop:
.a9b3		b1 30		lda ($30),y			lda 	(codePtr),y
.a9b5		c8		iny				iny
.a9b6		c9 dc		cmp #$dc			cmp 	#KWD_TO						; is it TO x,y
.a9b8		f0 53		beq $aa0d			beq 	_RGI_To
.a9ba		c9 c6		cmp #$c6			cmp 	#KWD_HERE 					; do it here.
.a9bc		f0 55		beq $aa13			beq 	_RGI_Here
.a9be		c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL or : , exit
.a9c0		f0 3d		beq $a9ff			beq 	_RGI_Exit
.a9c2		c9 3a		cmp #$3a			cmp 	#KWD_COLON
.a9c4		f0 39		beq $a9ff			beq 	_RGI_Exit
.a9c6		c9 ce		cmp #$ce			cmp 	#KWD_OUTLINE 				; solid or outline
.a9c8		f0 3e		beq $aa08			beq 	_RGI_Frame
.a9ca		c9 d8		cmp #$d8			cmp 	#KWD_SOLID
.a9cc		f0 33		beq $aa01			beq 	_RGI_Solid
.a9ce		c9 ba		cmp #$ba			cmp 	#KWD_BY 					; by offset
.a9d0		f0 4b		beq $aa1d			beq 	_RGI_By
.a9d2		c9 c4		cmp #$c4			cmp 	#KWD_FROM 					; from
.a9d4		f0 17		beq $a9ed			beq 	_RGI_Move2
.a9d6		c9 c1		cmp #$c1			cmp 	#KWD_DIM 					; dim (set scale)
.a9d8		f0 62		beq $aa3c			beq 	_RGI_Dim
.a9da		c9 bf		cmp #$bf			cmp 	#KWD_COLOUR 				; colour or Color
.a9dc		f0 74		beq $aa52			beq 	_RGI_Colour
.a9de		c9 be		cmp #$be			cmp 	#KWD_COLOR
.a9e0		f0 70		beq $aa52			beq 	_RGI_Colour
.a9e2		ae cd 07	ldx $07cd			ldx 	gxCommandID
.a9e5		e0 52		cpx #$52			cpx 	#GCMD_SpriteMove 			; if not sprite
.a9e7		d0 03		bne $a9ec			bne 	_RGI_Move 					; move
.a9e9		4c 7a aa	jmp $aa7a			jmp		_RGI_SpriteInstructions
.a9ec						_RGI_Move:
.a9ec		88		dey				dey 								; unpick get.
.a9ed						_RGI_Move2:
.a9ed		20 a0 aa	jsr $aaa0			jsr 	GCGetCoordinatePair 		; move to here
.a9f0		20 c7 aa	jsr $aac7			jsr 	GCCopyPairToStore 			; save
.a9f3		5a		phy				phy
.a9f4		20 bd aa	jsr $aabd			jsr 	GCLoadAXY 					; load in
.a9f7		09 40		ora #$40			ora 	#GCMD_Move 					; move there
.a9f9		20 9d 80	jsr $809d			jsr 	GXGraphicDraw
.a9fc		7a		ply				ply
.a9fd		80 b4		bra $a9b3			bra 	_RGICommandLoop 			; and go round
.a9ff						_RGI_Exit:
.a9ff		88		dey				dey 								; unpick : / EOL
.aa00		60		rts				rts
.aa01						_RGI_Solid:
.aa01		a9 02		lda #$02			lda 	#2
.aa03		8d ce 07	sta $07ce			sta 	gxFillSolid
.aa06		80 ab		bra $a9b3			bra 	_RGICommandLoop
.aa08						_RGI_Frame:
.aa08		9c ce 07	stz $07ce			stz 	gxFillSolid
.aa0b		80 a6		bra $a9b3			bra 	_RGICommandLoop
.aa0d						_RGI_To:
.aa0d		20 a0 aa	jsr $aaa0			jsr 	GCGetCoordinatePair 		; get coordinate pair into slot #1,#2
.aa10		20 c7 aa	jsr $aac7			jsr 	GCCopyPairToStore
.aa13						_RGI_Here:
.aa13		5a		phy				phy
.aa14		20 bd aa	jsr $aabd			jsr 	GCLoadAXY 					; load it into AXY
.aa17		20 77 aa	jsr $aa77			jsr 	_RGICallHandler 			; go do whatever it is.
.aa1a		7a		ply				ply
.aa1b		80 96		bra $a9b3			bra 	_RGICommandLoop 			; and go round
.aa1d						_RGI_By:
.aa1d		20 ad aa	jsr $aaad			jsr 	GCSignedCoordinatePair 		; get coordinate pair into slot #1,#2
.aa20		18		clc				clc
.aa21		a5 61		lda $61				lda 	NSMantissa0+1 				; copy it into space.
.aa23		6d cf 07	adc $07cf			adc 	gxXPos
.aa26		8d cf 07	sta $07cf			sta 	gxXPos
.aa29		a5 71		lda $71				lda 	NSMantissa1+1
.aa2b		6d d0 07	adc $07d0			adc 	gxXPos+1
.aa2e		8d d0 07	sta $07d0			sta 	gxXPos+1
.aa31		a5 62		lda $62				lda 	NSMantissa0+2
.aa33		18		clc				clc
.aa34		6d d1 07	adc $07d1			adc 	gxYPos
.aa37		8d d1 07	sta $07d1			sta 	gxYPos
.aa3a		80 d7		bra $aa13			bra 	_RGI_Here
.aa3c						_RGI_Dim:
.aa3c		a2 01		ldx #$01			ldx	 	#1
.aa3e		20 1d a4	jsr $a41d			jsr 	Evaluate8BitInteger
.aa41		a5 61		lda $61				lda 	NSMantissa0+1
.aa43		c9 00		cmp #$00			cmp 	#0
.aa45		f0 2d		beq $aa74			beq 	_RGIRange
.aa47		c9 09		cmp #$09			cmp 	#8+1
.aa49		b0 29		bcs $aa74			bcs		_RGIRange
.aa4b		3a		dec a				dec 	a
.aa4c		8d d4 07	sta $07d4			sta 	gxDrawScale
.aa4f		4c b3 a9	jmp $a9b3			jmp 	_RGICommandLoop
.aa52						_RGI_Colour:
.aa52		a2 01		ldx #$01			ldx 	#1 							; colour
.aa54		20 1d a4	jsr $a41d			jsr 	Evaluate8BitInteger
.aa57		a2 02		ldx #$02			ldx 	#2 							; default zero for 2nd parameter
.aa59		20 82 a4	jsr $a482			jsr 	NSMSetZero
.aa5c		b1 30		lda ($30),y			lda 	(codePtr),y
.aa5e		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; check , => mode.
.aa60		d0 04		bne $aa66			bne 	_RGICDefaultMode
.aa62		c8		iny				iny
.aa63		20 1d a4	jsr $a41d			jsr 	Evaluate8BitInteger
.aa66						_RGICDefaultMode:
.aa66		5a		phy				phy
.aa67		a9 08		lda #$08			lda 	#GCMD_Colour 				; set colour.
.aa69		a6 61		ldx $61				ldx 	NSMantissa0+1
.aa6b		a4 62		ldy $62				ldy 	NSMantissa0+2
.aa6d		20 9d 80	jsr $809d			jsr 	GXGraphicDraw
.aa70		7a		ply				ply
.aa71		4c b3 a9	jmp $a9b3			jmp 	_RGICommandLoop 			; and go round
.aa74						_RGIRange:
.aa74		4c ff a5	jmp $a5ff			jmp 	RangeError
.aa77						_RGICallHandler:
.aa77		6c d2 07	jmp ($07d2)			jmp 	(gxHandler)
.aa7a						_RGI_SpriteInstructions:
.aa7a		c9 cc		cmp #$cc			cmp 	#KWD_OFF
.aa7c		f0 07		beq $aa85			beq 	_RGISpriteOff
.aa7e		c9 c7		cmp #$c7			cmp 	#KWD_IMAGE
.aa80		f0 13		beq $aa95			beq 	_RGISetImage
.aa82		4c ec a9	jmp $a9ec			jmp 	_RGI_Move
.aa85						_RGISpriteOff:
.aa85		5a		phy				phy
.aa86		a0 01		ldy #$01			ldy 	#1
.aa88		a2 00		ldx #$00			ldx 	#0
.aa8a						_RGIDoCommandLoop:
.aa8a		a9 10		lda #$10			lda 	#GCMD_SpriteImage
.aa8c		20 9d 80	jsr $809d			jsr 	GXGraphicDraw
.aa8f		7a		ply				ply
.aa90		b0 e2		bcs $aa74			bcs 	_RGIRange
.aa92		4c b3 a9	jmp $a9b3			jmp 	_RGICommandLoop
.aa95						_RGISetImage:
.aa95		a2 01		ldx #$01			ldx 	#1
.aa97		20 1d a4	jsr $a41d			jsr 	Evaluate8BitInteger
.aa9a		5a		phy				phy
.aa9b		aa		tax				tax
.aa9c		a0 00		ldy #$00			ldy 	#0
.aa9e		80 ea		bra $aa8a			bra 	_RGIDoCommandLoop
.aaa0						GCGetCoordinatePair:
.aaa0		a2 01		ldx #$01			ldx 	#1
.aaa2		20 02 a4	jsr $a402			jsr 	Evaluate16BitInteger
.aaa5		20 08 95	jsr $9508			jsr 	CheckComma
.aaa8		e8		inx				inx
.aaa9		20 02 a4	jsr $a402			jsr 	Evaluate16BitInteger
.aaac		60		rts				rts
.aaad						GCSignedCoordinatePair:
.aaad		a2 01		ldx #$01			ldx 	#1
.aaaf		20 0c a4	jsr $a40c			jsr 	Evaluate16BitIntegerSigned
.aab2		20 08 95	jsr $9508			jsr 	CheckComma
.aab5		e8		inx				inx
.aab6		20 0c a4	jsr $a40c			jsr 	Evaluate16BitIntegerSigned
.aab9		60		rts				rts
.aaba						_GCCPRange:
.aaba		4c ff a5	jmp $a5ff			jmp 	RangeError
.aabd						GCLoadAXY:
.aabd		ad d0 07	lda $07d0			lda 	gxXPos+1
.aac0		ae cf 07	ldx $07cf			ldx 	gxXPos
.aac3		ac d1 07	ldy $07d1			ldy 	gxYPos
.aac6		60		rts				rts
.aac7						GCCopyPairToStore:
.aac7		a5 61		lda $61				lda 	NSMantissa0+1 				; copy it into space.
.aac9		8d cf 07	sta $07cf			sta 	gxXPos
.aacc		a5 71		lda $71				lda 	NSMantissa1+1
.aace		8d d0 07	sta $07d0			sta 	gxXPos+1
.aad1		a5 62		lda $62				lda 	NSMantissa0+2
.aad3		8d d1 07	sta $07d1			sta 	gxYPos
.aad6		60		rts				rts
.07cd						gxCommandID:
>07cd								.fill 	1
.07ce						gxFillSolid:
>07ce								.fill 	1
.07cf						gxXPos:
>07cf								.fill 	2
.07d1						gxYPos:
>07d1								.fill 	1
.07d2						gxHandler:
>07d2								.fill 	2
.07d4						gxDrawScale:
>07d4								.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/graphics/gcontrol.asm

.aad7						ResetBitmapSpritesTiles:
.aad7		9c d5 07	stz $07d5			stz 	BitmapPageNumber
.aada		9c d6 07	stz $07d6			stz 	SpritePageNumber
.aadd		9c d7 07	stz $07d7			stz 	TileMapPageNumber
.aae0		9c d8 07	stz $07d8			stz 	TileImagePageNumber
.aae3		a9 40		lda #$40			lda 	#64
.aae5		8d d9 07	sta $07d9			sta 	TileMapWidth
.aae8		a9 20		lda #$20			lda 	#32
.aaea		8d da 07	sta $07da			sta 	TileMapHeight
.aaed		60		rts				rts
.aaee						BitmapCtrl:
.aaee						BitmapCtrlLoop:
.aaee		b1 30		lda ($30),y			lda 	(codePtr),y
.aaf0		c8		iny				iny
.aaf1		a2 01		ldx #$01			ldx 	#1
.aaf3		c9 cd		cmp #$cd			cmp 	#KWD_ON
.aaf5		f0 24		beq $ab1b			beq 	BitmapSwitch
.aaf7		ca		dex				dex
.aaf8		c9 cc		cmp #$cc			cmp 	#KWD_OFF
.aafa		f0 1f		beq $ab1b			beq 	BitmapSwitch
.aafc		c9 b9		cmp #$b9			cmp 	#KWD_AT  					; set address
.aafe		f0 13		beq $ab13			beq 	BitmapAddress
.ab00		c9 bd		cmp #$bd			cmp 	#KWD_CLEAR
.ab02		f0 02		beq $ab06			beq 	BitmapClear
.ab04		88		dey				dey
.ab05		60		rts				rts
.ab06						BitmapClear:
.ab06		20 1d a4	jsr $a41d			jsr 	Evaluate8BitInteger 		; get the colour
.ab09		5a		phy				phy
.ab0a		aa		tax				tax
.ab0b		a9 06		lda #$06			lda 	#GCMD_Clear					; clear to that colour
.ab0d		20 9d 80	jsr $809d			jsr 	GXGraphicDraw
.ab10		7a		ply				ply
.ab11		80 db		bra $aaee			bra 	BitmapCtrlLoop
.ab13						BitmapAddress:
.ab13		20 df ab	jsr $abdf			jsr 	GetPageNumber
.ab16		8d d5 07	sta $07d5			sta 	BitmapPageNumber
.ab19		80 d3		bra $aaee			bra 	BitmapCtrlLoop
.ab1b						BitmapSwitch:
.ab1b		5a		phy				phy
.ab1c		ac d5 07	ldy $07d5			ldy 	BitmapPageNumber 			; gfx 1,on/off,0
.ab1f		a9 02		lda #$02			lda 	#GCMD_BitmapCtl
.ab21		20 9d 80	jsr $809d			jsr 	GXGraphicDraw
.ab24		a9 08		lda #$08			lda 	#GCMD_Colour				; set colour to $FF
.ab26		a0 00		ldy #$00			ldy 	#0
.ab28		a2 ff		ldx #$ff			ldx 	#$FF
.ab2a		20 9d 80	jsr $809d			jsr 	GXGraphicDraw
.ab2d		9c ce 07	stz $07ce			stz 	gxFillSolid
.ab30		9c cf 07	stz $07cf			stz 	gxXPos
.ab33		9c d0 07	stz $07d0			stz 	gxXPos+1
.ab36		9c d1 07	stz $07d1			stz 	gxYPos
.ab39		9c d4 07	stz $07d4			stz 	gxDrawScale
.ab3c		a9 40		lda #$40			lda 	#GCMD_Move 						; home cursor
.ab3e		a2 00		ldx #$00			ldx 	#0
.ab40		a0 00		ldy #$00			ldy 	#0
.ab42		20 9d 80	jsr $809d			jsr 	GXGraphicDraw
.ab45		7a		ply				ply
.ab46		80 a6		bra $aaee			bra 	BitmapCtrlLoop
.ab48						SpritesCtrl:
.ab48						SpritesCtrlLoop:
.ab48		b1 30		lda ($30),y			lda 	(codePtr),y
.ab4a		c8		iny				iny
.ab4b		a2 01		ldx #$01			ldx 	#1
.ab4d		c9 cd		cmp #$cd			cmp 	#KWD_ON
.ab4f		f0 13		beq $ab64			beq 	SpriteSwitch
.ab51		ca		dex				dex
.ab52		c9 cc		cmp #$cc			cmp 	#KWD_OFF
.ab54		f0 0e		beq $ab64			beq 	SpriteSwitch
.ab56		c9 b9		cmp #$b9			cmp 	#KWD_AT
.ab58		f0 02		beq $ab5c			beq 	SpriteSetAddress
.ab5a		88		dey				dey
.ab5b		60		rts				rts
.ab5c						SpriteSetAddress:
.ab5c		20 df ab	jsr $abdf			jsr 	GetPageNumber
.ab5f		8d d6 07	sta $07d6			sta 	SpritePageNumber
.ab62		80 e4		bra $ab48			bra 	SpritesCtrlLoop
.ab64						SpriteSwitch:
.ab64		5a		phy				phy
.ab65		ac d6 07	ldy $07d6			ldy 	SpritePageNumber 			; gfx 2,on/off,0
.ab68		a9 04		lda #$04			lda 	#GCMD_SpriteCtl
.ab6a		20 9d 80	jsr $809d			jsr 	GXGraphicDraw
.ab6d		7a		ply				ply
.ab6e		80 d8		bra $ab48			bra 	SpritesCtrlLoop
.ab70						TilesCtrl:
.ab70						TilesCtrlLoop:
.ab70		b1 30		lda ($30),y			lda 	(codePtr),y
.ab72		c8		iny				iny
.ab73		a2 80		ldx #$80			ldx 	#$80
.ab75		c9 cd		cmp #$cd			cmp 	#KWD_ON
.ab77		f0 34		beq $abad			beq 	TileSwitch
.ab79		a2 00		ldx #$00			ldx 	#$00
.ab7b		c9 cc		cmp #$cc			cmp 	#KWD_OFF
.ab7d		f0 2e		beq $abad			beq 	TileSwitch
.ab7f		c9 b9		cmp #$b9			cmp 	#KWD_AT
.ab81		f0 19		beq $ab9c			beq 	TileSetAddress
.ab83		c9 c1		cmp #$c1			cmp 	#KWD_DIM
.ab85		f0 02		beq $ab89			beq 	TileSetSize
.ab87		88		dey				dey
.ab88		60		rts				rts
.ab89						TileSetSize:
.ab89		a2 00		ldx #$00			ldx 	#0
.ab8b		20 1d a4	jsr $a41d			jsr 	Evaluate8BitInteger
.ab8e		8d d9 07	sta $07d9			sta 	TileMapWidth
.ab91		20 08 95	jsr $9508			jsr 	CheckComma
.ab94		20 1d a4	jsr $a41d			jsr 	Evaluate8BitInteger
.ab97		8d da 07	sta $07da			sta 	TileMapHeight
.ab9a		80 d4		bra $ab70			bra 	TilesCtrlLoop
.ab9c						TileSetAddress:
.ab9c		20 df ab	jsr $abdf			jsr 	GetPageNumber 				; map page
.ab9f		8d d7 07	sta $07d7			sta 	TileMapPageNumber
.aba2		20 08 95	jsr $9508			jsr 	CheckComma
.aba5		20 df ab	jsr $abdf			jsr 	GetPageNumber 				; image page
.aba8		8d d8 07	sta $07d8			sta 	TileImagePageNumber
.abab		80 c3		bra $ab70			bra 	TilesCtrlLoop
.abad						TileSwitch:
.abad		5a		phy				phy
.abae		da		phx				phx 								; set the on/off state and the pages.
.abaf		8a		txa				txa
.abb0		0d d7 07	ora $07d7			ora 	TileMapPageNumber
.abb3		aa		tax				tax
.abb4		ac d8 07	ldy $07d8			ldy 	TileImagePageNumber
.abb7		a9 14		lda #$14			lda 	#GCMD_TileCtl
.abb9		20 9d 80	jsr $809d			jsr 	GXGraphicDraw
.abbc		fa		plx				plx
.abbd		10 b1		bpl $ab70			bpl 	TilesCtrlLoop 				; nothing else.
.abbf		a9 16		lda #$16			lda 	#GCMD_TileSize 				; set size of tile map.
.abc1		ae d9 07	ldx $07d9			ldx 	TileMapWidth
.abc4		ac da 07	ldy $07da			ldy 	TileMapHeight
.abc7		20 9d 80	jsr $809d			jsr 	GXGraphicDraw
.abca		a9 18		lda #$18			lda 	#GCMD_TileScrollX 			; reset scroll
.abcc		20 d8 ab	jsr $abd8			jsr 	_TileResetScroll
.abcf		a9 1a		lda #$1a			lda 	#GCMD_TileScrollY
.abd1		20 d8 ab	jsr $abd8			jsr 	_TileResetScroll
.abd4		7a		ply				ply
.abd5		4c 70 ab	jmp $ab70			jmp 	TilesCtrlLoop
.abd8						_TileResetScroll:
.abd8		a2 00		ldx #$00			ldx 	#0
.abda		a0 00		ldy #$00			ldy 	#0
.abdc		4c 9d 80	jmp $809d			jmp 	GXGraphicDraw
.abdf						GetPageNumber:
.abdf		a2 00		ldx #$00			ldx 	#0
.abe1		20 f7 a3	jsr $a3f7			jsr 	EvaluateUnsignedInteger 	; evaluate where to go.
.abe4		a5 70		lda $70				lda 	NSMantissa1 				; check on page
.abe6		29 1f		and #$1f			and 	#$1F
.abe8		05 60		ora $60				ora 	NSMantissa0
.abea		d0 0c		bne $abf8			bne 	_GPNError
.abec		a5 80		lda $80				lda 	NSMantissa2
.abee		06 70		asl $70				asl 	NSMantissa1					; get page number
.abf0		2a		rol a				rol 	a
.abf1		06 70		asl $70				asl 	NSMantissa1
.abf3		2a		rol a				rol 	a
.abf4		06 70		asl $70				asl 	NSMantissa1
.abf6		2a		rol a				rol 	a
.abf7		60		rts				rts
.abf8						_GPNError:
.abf8		a9 07		lda #$07		lda	#7
.abfa		4c 19 95	jmp $9519		jmp	ErrorHandler
.07d5						BitmapPageNumber:
>07d5								.fill 	1
.07d6						SpritePageNumber:
>07d6								.fill 	1
.07d7						TileMapPageNumber:
>07d7								.fill 	1
.07d8						TileImagePageNumber:
>07d8								.fill 	1
.07d9						TileMapWidth:
>07d9								.fill 	1
.07da						TileMapHeight:
>07da								.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/graphics/gfx.asm

.abfd						GfxCommand:
.abfd		a2 00		ldx #$00			ldx 	#0
.abff		20 1d a4	jsr $a41d			jsr 	Evaluate8BitInteger 		; command
.ac02		20 08 95	jsr $9508			jsr 	CheckComma
.ac05		e8		inx				inx
.ac06		20 02 a4	jsr $a402			jsr 	Evaluate16BitInteger 		; X
.ac09		20 08 95	jsr $9508			jsr 	CheckComma
.ac0c		e8		inx				inx
.ac0d		20 1d a4	jsr $a41d			jsr 	Evaluate8BitInteger 		; Y
.ac10		a5 71		lda $71				lda 	NSMantissa1+1  				; shift bit 0 of X into CS, should now be zero
.ac12		4a		lsr a				lsr 	a
.ac13		d0 12		bne $ac27			bne 	_GfxError
.ac15		26 60		rol $60				rol 	NSMantissa0 				; rotate into command
.ac17		b0 0e		bcs $ac27			bcs 	_GfxError 					; bit 7 should have been zero
.ac19		5a		phy				phy 								; save pos
.ac1a		a5 60		lda $60				lda 	NSMantissa0 				; do the command
.ac1c		a6 61		ldx $61				ldx 	NSMantissa0+1
.ac1e		a4 62		ldy $62				ldy 	NSMantissa0+2
.ac20		20 9d 80	jsr $809d			jsr 	GXGraphicDraw
.ac23		b0 02		bcs $ac27			bcs 	_GfxError
.ac25		7a		ply				ply 								; restore pos and exit.
.ac26		60		rts				rts
.ac27						_GfxError:
.ac27		4c ff a5	jmp $a5ff			jmp 	RangeError

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/graphics/hit.asm

.ac2a						UnaryHit:
.ac2a		fa		plx				plx
.ac2b		a9 36		lda #$36			lda 	#zTemp0
.ac2d		20 1d a4	jsr $a41d			jsr 	Evaluate8BitInteger 		; get sprite number 0
.ac30		20 08 95	jsr $9508			jsr 	CheckComma
.ac33		e8		inx				inx
.ac34		20 1d a4	jsr $a41d			jsr 	Evaluate8BitInteger 		; get sprite number 1
.ac37		20 00 95	jsr $9500			jsr		CheckRightBracket
.ac3a		ca		dex				dex 								; fix back up again.
.ac3b		da		phx				phx 								; save X/Y
.ac3c		5a		phy				phy
.ac3d		b4 61		ldy $61,x			ldy 	NSMantissa0+1,x 			; get the sprite numbers into X/Y
.ac3f		b5 60		lda $60,x			lda 	NSMantissa0,x
.ac41		aa		tax				tax
.ac42		a9 12		lda #$12			lda 	#GCMD_SpriteCollide 		; command check collision.
.ac44		20 9d 80	jsr $809d			jsr 	GXGraphicDraw 				; calculate result
.ac47		1a		inc a				inc 	a 							; so 255 (fail) -> 0, otherwise 1,2,3,4 pixels etc.
.ac48		7a		ply				ply 								; restore XY
.ac49		fa		plx				plx
.ac4a		20 84 a4	jsr $a484			jsr 	NSMSetByte 					; return the hit result
.ac4d		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/graphics/palette.asm

.ac4e						PaletteCommand:
.ac4e		a2 00		ldx #$00			ldx 	#0
.ac50		20 1d a4	jsr $a41d			jsr 	Evaluate8BitInteger 		; colour
.ac53		20 08 95	jsr $9508			jsr 	CheckComma
.ac56		e8		inx				inx
.ac57		20 02 a4	jsr $a402			jsr 	Evaluate16BitInteger 		; r
.ac5a		20 08 95	jsr $9508			jsr 	CheckComma
.ac5d		e8		inx				inx
.ac5e		20 1d a4	jsr $a41d			jsr 	Evaluate8BitInteger 		; g
.ac61		20 08 95	jsr $9508			jsr 	CheckComma
.ac64		e8		inx				inx
.ac65		20 1d a4	jsr $a41d			jsr 	Evaluate8BitInteger 		; b
.ac68		a5 60		lda $60				lda 	NSMantissa0 				; get colour #
.ac6a		85 36		sta $36				sta 	zTemp0
.ac6c		a9 34		lda #$34			lda 	#$D0 >> 2 					; MSB = D0/4
.ac6e		85 37		sta $37				sta 	zTemp0+1
.ac70		06 36		asl $36				asl 	zTemp0 						; zTemp = $D000+Colour x 4
.ac72		26 37		rol $37				rol	 	zTemp0+1
.ac74		06 36		asl $36				asl 	zTemp0
.ac76		26 37		rol $37				rol	 	zTemp0+1
.ac78		a9 01		lda #$01			lda 	#1 							; I/O Page 2
.ac7a		85 01		sta $01				sta 	1
.ac7c		5a		phy				phy
.ac7d		a5 63		lda $63				lda 	NSMantissa0+3 				; fix to r,g,b
.ac7f		92 36		sta ($36)			sta 	(zTemp0)
.ac81		a0 01		ldy #$01			ldy 	#1
.ac83		a5 62		lda $62				lda 	NSMantissa0+2
.ac85		91 36		sta ($36),y			sta 	(zTemp0),y
.ac87		a5 61		lda $61				lda 	NSMantissa0+1
.ac89		c8		iny				iny
.ac8a		91 36		sta ($36),y			sta 	(zTemp0),y
.ac8c		7a		ply				ply
.ac8d		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/graphics/tile.asm

.ac8e						TileCommand:
.ac8e		b1 30		lda ($30),y			lda 	(codePtr),y
.ac90		c8		iny				iny
.ac91		c9 b9		cmp #$b9			cmp 	#KWD_AT
.ac93		f0 0a		beq $ac9f			beq 	_TileSetPos
.ac95		c9 d0		cmp #$d0			cmp 	#KWD_PLOT
.ac97		f0 15		beq $acae			beq 	_TilePlot
.ac99		c9 dc		cmp #$dc			cmp 	#KWD_TO
.ac9b		f0 40		beq $acdd			beq 	_TileScroll
.ac9d		88		dey				dey
.ac9e		60		rts				rts
.ac9f						_TileSetPos:
.ac9f		a2 00		ldx #$00			ldx 	#0 							; location to XA
.aca1		20 fd ac	jsr $acfd			jsr 	TileGetPair
.aca4		5a		phy				phy 								; call routine
.aca5		a8		tay				tay
.aca6		a9 1c		lda #$1c			lda 	#GCMD_TilePos
.aca8		20 9d 80	jsr $809d			jsr 	GXGraphicDraw
.acab		7a		ply				ply
.acac		80 e0		bra $ac8e			bra 	TileCommand 				; loop round
.acae						_TilePlot:
.acae		a2 00		ldx #$00			ldx 	#0
.acb0		20 1d a4	jsr $a41d			jsr 	Evaluate8BitInteger 		; tile to print
.acb3		a9 01		lda #$01			lda 	#1
.acb5		85 61		sta $61				sta 	NSMantissa0+1 				; default repeat count.
.acb7		a2 01		ldx #$01			ldx 	#1
.acb9		b1 30		lda ($30),y			lda 	(codePtr),y
.acbb		c9 c9		cmp #$c9			cmp 	#KWD_LINE
.acbd		d0 04		bne $acc3			bne 	_TileNoRepeat
.acbf		c8		iny				iny 								; skip LINE
.acc0		20 1d a4	jsr $a41d			jsr 	Evaluate8BitInteger 		; evaluate count
.acc3						_TileNoRepeat:
.acc3						_TileOutLoop:
.acc3		a5 61		lda $61				lda 	NSMantissa0+1 				; complete ?
.acc5		f0 0d		beq $acd4			beq 	_TileCheckAgain 			; check , <repeats>
.acc7		c6 61		dec $61				dec 	NSMantissa0+1 				; dec count
.acc9		a9 1e		lda #$1e			lda 	#GCMD_TileWrite				; set up to write tile.
.accb		a6 60		ldx $60				ldx 	NSMantissa0
.accd		5a		phy				phy 								; call preserving Y
.acce		20 9d 80	jsr $809d			jsr 	GXGraphicDraw
.acd1		7a		ply				ply
.acd2		80 ef		bra $acc3			bra 	_TileOutLoop
.acd4						_TileCheckAgain:
.acd4		b1 30		lda ($30),y			lda 	(codePtr),y
.acd6		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.acd8		d0 b4		bne $ac8e			bne 	TileCommand 				; no, do again
.acda		c8		iny				iny 								; consume comma
.acdb		80 d1		bra $acae			bra 	_TilePlot 					; and loop round.
.acdd						_TileScroll:
.acdd		a9 18		lda #$18			lda 	#GCMD_TileScrollX 			; do X
.acdf		20 ec ac	jsr $acec			jsr 	_TileSetScroll
.ace2		20 08 95	jsr $9508			jsr 	CheckComma
.ace5		a9 1a		lda #$1a			lda 	#GCMD_TileScrollY 			; do Y
.ace7		20 ec ac	jsr $acec			jsr 	_TileSetScroll
.acea		80 a2		bra $ac8e			bra 	TileCommand
.acec						_TileSetScroll:
.acec		48		pha				pha 								; save command on stack
.aced		a2 00		ldx #$00			ldx 	#0 							; get value to scroll to
.acef		20 02 a4	jsr $a402			jsr 	Evaluate16BitInteger
.acf2		68		pla				pla 								; restore command
.acf3		5a		phy				phy 								; save Y code pos
.acf4		a6 60		ldx $60				ldx 	NSMantissa0 				; YX = scroll value
.acf6		a4 70		ldy $70				ldy 	NSMantissa1
.acf8		20 9d 80	jsr $809d			jsr 	GXGraphicDraw 				; do command
.acfb		7a		ply				ply 								; restore code pos
.acfc		60		rts				rts
.acfd						TileGetPair:
.acfd		20 1d a4	jsr $a41d			jsr 	Evaluate8BitInteger
.ad00		48		pha				pha
.ad01		20 08 95	jsr $9508			jsr 	CheckComma
.ad04		20 1d a4	jsr $a41d			jsr 	Evaluate8BitInteger
.ad07		fa		plx				plx
.ad08		60		rts				rts
.ad09						TileRead:
.ad09		fa		plx				plx 								; current stack pos (where the result goes)
.ad0a		da		phx				phx 								; save it back again
.ad0b		e8		inx				inx   								; space to evaluate coordinates
.ad0c		20 fd ac	jsr $acfd			jsr 	TileGetPair 				; X A are the coordinates
.ad0f		5a		phy				phy 								; save code position
.ad10		a8		tay				tay 								; X Y are the coordinates.
.ad11		a9 1c		lda #$1c			lda 	#GCMD_TilePos 				; set the read position.
.ad13		20 9d 80	jsr $809d			jsr 	GXGraphicDraw
.ad16		a9 20		lda #$20			lda 	#GCMD_TileRead 				; read the tile there
.ad18		20 9d 80	jsr $809d			jsr 	GXGraphicDraw
.ad1b		7a		ply				ply 								; restore code and stack positions
.ad1c		fa		plx				plx
.ad1d		20 84 a4	jsr $a484			jsr 	NSMSetByte 					; set the result.
.ad20		20 00 95	jsr $9500			jsr 	CheckRightBracket 			; check for )
.ad23		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/hardware/cls.asm

.ad24						ClearScreen:
.ad24		5a		phy				phy
.ad25		a9 0c		lda #$0c			lda 	#12 						; char code 12 clears the screen.
.ad27		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.ad2a		7a		ply				ply
.ad2b		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/hardware/cursor.asm

.ad2c						CursorControl:
.ad2c		a2 00		ldx #$00			ldx 	#0
.ad2e		b1 30		lda ($30),y			lda 	(codePtr),y
.ad30		c8		iny				iny
.ad31		c9 cc		cmp #$cc			cmp 	#KWD_OFF
.ad33		f0 08		beq $ad3d			beq 	_CCOnOff
.ad35		e8		inx				inx
.ad36		c9 cd		cmp #$cd			cmp 	#KWD_ON
.ad38		f0 03		beq $ad3d			beq 	_CCOnOff
.ad3a		4c fa a5	jmp $a5fa			jmp 	SyntaxError
.ad3d						_CCOnOff:
.ad3d		a5 01		lda $01				lda 	1 							; save current I/O
.ad3f		48		pha				pha
.ad40		64 01		stz $01				stz 	1 		 					; page 0.
.ad42		ad 10 d0	lda $d010			lda 	$D010 						; read Cursor control register
.ad45		29 fe		and #$fe			and 	#$FE 						; clear enable bit
.ad47		86 36		stx $36				stx 	zTemp0 						; put bit back in
.ad49		05 36		ora $36				ora 	zTemp0
.ad4b		8d 10 d0	sta $d010			sta 	$D010
.ad4e		68		pla				pla 	 							; switch I/O back
.ad4f		85 01		sta $01				sta 	1
.ad51		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/crossdev.asm

.ad52						XLoadCommand:
.ad52		20 43 8f	jsr $8f43			jsr 	NewProgram
.ad55		20 9f 87	jsr $879f			jsr 	BackloadProgram
.ad58		4c 12 89	jmp $8912			jmp 	WarmStart
.ad5b						XGoCommand:
.ad5b		20 43 8f	jsr $8f43			jsr 	NewProgram
.ad5e		20 9f 87	jsr $879f			jsr 	BackloadProgram
.ad61		4c ec 90	jmp $90ec			jmp 	RunCurrentProgram

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/dos.asm

>0200						ArgumentStrings .fill 128
>0280						ArgumentArray   .fill (8+1)*2		; DOS provides a maximum of 8 tokens
.ad64						BootXA:
.ad64		48		pha				pha
.ad65		da		phx				phx
.ad66		20 a0 88	jsr $88a0			jsr		IsDestructiveActionOK
.ad69		fa		plx				plx
.ad6a		68		pla				pla
.ad6b		90 03		bcc $ad70			bcc		_action_ok
.ad6d		4c 12 89	jmp $8912			jmp		WarmStart
.ad70						_action_ok:
.ad70		85 36		sta $36				sta		zTemp0+0
.ad72		86 37		stx $37				stx		zTemp0+1
.ad74		a2 00		ldx #$00			ldx		#0
.ad76		a0 00		ldy #$00			ldy		#0
.ad78						_copy_next_string:
.ad78		98		tya				tya
.ad79		18		clc				clc
.ad7a		69 00		adc #$00			adc		#<ArgumentStrings
.ad7c		9d 80 02	sta $0280,x			sta		ArgumentArray,x
.ad7f		e8		inx				inx
.ad80		a9 02		lda #$02			lda		#>ArgumentStrings
.ad82		69 00		adc #$00			adc		#0
.ad84		9d 80 02	sta $0280,x			sta		ArgumentArray,x
.ad87		e8		inx				inx
.ad88						_copy_string:
.ad88		b1 36		lda ($36),y			lda		(zTemp0),y
.ad8a		f0 1a		beq $ada6			beq		_copy_done
.ad8c		c9 20		cmp #$20			cmp		#' '
.ad8e		f0 06		beq $ad96			beq		_skip_spaces
.ad90		99 00 02	sta $0200,y			sta		ArgumentStrings,y
.ad93		c8		iny				iny
.ad94		80 f2		bra $ad88			bra		_copy_string
.ad96						_skip_spaces:
.ad96		a9 00		lda #$00			lda		#0
.ad98		99 00 02	sta $0200,y			sta		ArgumentStrings,y
.ad9b		c8		iny				iny
.ad9c		b1 36		lda ($36),y			lda		(zTemp0),y
.ad9e		f0 06		beq $ada6			beq		_copy_done
.ada0		c9 20		cmp #$20			cmp		#' '
.ada2		f0 f2		beq $ad96			beq		_skip_spaces
.ada4		80 d2		bra $ad78			bra		_copy_next_string
.ada6						_copy_done:
.ada6		a9 00		lda #$00			lda		#0
.ada8		99 00 02	sta $0200,y			sta		ArgumentStrings,y
.adab		86 fa		stx $fa				stx		kernel.args.extlen
.adad		9e 80 02	stz $0280,x			stz		ArgumentArray,x
.adb0		9e 81 02	stz $0281,x			stz		ArgumentArray+1,x
.adb3		a9 80		lda #$80			lda		#<ArgumentArray
.adb5		85 f8		sta $f8				sta		kernel.args.ext
.adb7		a9 02		lda #$02			lda		#>ArgumentArray
.adb9		85 f9		sta $f9				sta		kernel.args.ext+1
.adbb		a9 00		lda #$00			lda		#<ArgumentStrings
.adbd		85 fb		sta $fb				sta		kernel.args.buf
.adbf		a9 02		lda #$02			lda		#>ArgumentStrings
.adc1		85 fc		sta $fc				sta		kernel.args.buf+1
.adc3		20 18 ff	jsr $ff18			jsr		kernel.RunNamed
.adc6		20 8c 88	jsr $888c			jsr		ResetTokenBuffer
.adc9		a9 1c		lda #$1c		lda	#28
.adcb		4c 19 95	jmp $9519		jmp	ErrorHandler
.adce		4c 12 89	jmp $8912			jmp		WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/event.asm

.add1						UnaryEvent:
.add1		fa		plx				plx
.add2		20 6d b4	jsr $b46d			jsr 	TimerToStackX 				; timer in +0
.add5		e8		inx				inx  								; put reference into +1
.add6		20 76 9e	jsr $9e76			jsr 	EvaluateTerm
.add9		b5 50		lda $50,x			lda 	NSStatus,x 					; check if is integer reference
.addb		c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.addd		d0 4c		bne $ae2b			bne 	_UEType
.addf		e8		inx				inx 								; put the step in +2
.ade0		20 08 95	jsr $9508			jsr 	CheckComma
.ade3		20 02 a4	jsr $a402			jsr 	Evaluate16BitInteger
.ade6		20 00 95	jsr $9500			jsr 	CheckRightBracket
.ade9		ca		dex				dex
.adea		ca		dex				dex
.adeb		b5 61		lda $61,x			lda 	NSMantissa0+1,x 			; copy reference to zTemp0
.aded		85 36		sta $36				sta 	zTemp0
.adef		b5 71		lda $71,x			lda 	NSMantissa1+1,x
.adf1		85 37		sta $37				sta 	zTemp0+1
.adf3		5a		phy				phy
.adf4		a0 03		ldy #$03			ldy 	#3 							; check bit 7 of last bit, the packed sign bit
.adf6		b1 36		lda ($36),y			lda 	(zTemp0),y
.adf8		30 2d		bmi $ae27			bmi 	_UEFalse 					; exit if signed.
.adfa		a0 00		ldy #$00			ldy 	#0 							; has it timed out (24 bit)
.adfc		b5 60		lda $60,x			lda 	NSMantissa0,x
.adfe		d1 36		cmp ($36),y			cmp 	(zTemp0),y
.ae00		c8		iny				iny
.ae01		b5 70		lda $70,x			lda 	NSMantissa1,x
.ae03		f1 36		sbc ($36),y			sbc		(zTemp0),y
.ae05		c8		iny				iny
.ae06		b5 80		lda $80,x			lda 	NSMantissa2,x
.ae08		f1 36		sbc ($36),y			sbc		(zTemp0),y
.ae0a		90 1b		bcc $ae27			bcc 	_UEFalse 					; no, return FALSE.
.ae0c		18		clc				clc
.ae0d		a0 00		ldy #$00			ldy 	#0 							; work out new value as timer() + step
.ae0f		b5 60		lda $60,x			lda 	NSMantissa0,x
.ae11		75 62		adc $62,x			adc 	NSMantissa0+2,x
.ae13		91 36		sta ($36),y			sta 	(zTemp0),y
.ae15		c8		iny				iny
.ae16		b5 70		lda $70,x			lda 	NSMantissa1,x
.ae18		75 72		adc $72,x			adc 	NSMantissa1+2,x
.ae1a		91 36		sta ($36),y			sta 	(zTemp0),y
.ae1c		c8		iny				iny
.ae1d		b5 80		lda $80,x			lda 	NSMantissa2,x
.ae1f		75 82		adc $82,x			adc 	NSMantissa2+2,x
.ae21		91 36		sta ($36),y			sta 	(zTemp0),y
.ae23		7a		ply				ply
.ae24		4c 8c 95	jmp $958c			jmp 	ReturnTrue
.ae27						_UEFalse:
.ae27		7a		ply				ply 								; restore Y
.ae28		4c 97 95	jmp $9597			jmp 	ReturnFalse 				; and return False
.ae2b						_UEType:
.ae2b		4c 04 a6	jmp $a604			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/files/bload.asm

.ae2e						Command_BLoad:
.ae2e		20 39 ae	jsr $ae39			jsr 	BLOADHandler
.ae31		c9 00		cmp #$00			cmp 	#0
.ae33		d0 01		bne $ae36			bne 	_BLError
.ae35		60		rts				rts
.ae36						_BLError:
.ae36		4c 8d b0	jmp $b08d			jmp 	CLErrorHandler
.ae39						BLOADHandler:
.ae39		a2 00		ldx #$00			ldx 	#0
.ae3b		20 da a3	jsr $a3da			jsr 	EvaluateString 				; file name to load
.ae3e		20 08 95	jsr $9508			jsr 	CheckComma 					; consume comma
.ae41		e8		inx				inx
.ae42		20 ef a3	jsr $a3ef			jsr 	EvaluateInteger 			; load address (full physical address)
.ae45		5a		phy				phy
.ae46		a5 60		lda $60				lda 	NSMantissa0					; file name -> XA
.ae48		a6 70		ldx $70				ldx 	NSMantissa1
.ae4a		20 4a 84	jsr $844a			jsr 	KNLOpenFileRead 			; open file for reading
.ae4d		b0 50		bcs $ae9f			bcs 	_BLErrorExit 				; error, so fail.
.ae4f		8d df 07	sta $07df			sta 	BasicFileStream 			; save the reading stream.
.ae52		a2 01		ldx #$01			ldx 	#1 							; address is in slot # 1
.ae54		20 a1 ae	jsr $aea1			jsr 	BLOpenPhysicalMemory 		; open for access.
.ae57						_BLReadFile:
.ae57		ad df 07	lda $07df			lda 	BasicFileStream
.ae5a		a2 40		ldx #$40			ldx     #KNLReadBufferLen 			; set bytes to read.
.ae5c		20 a4 84	jsr $84a4			jsr 	KNLReadBlock 				; read next block
.ae5f		b0 22		bcs $ae83			bcs 	_BLFileError 				; file error, which might be EOF.
.ae61		c9 00		cmp #$00			cmp 	#0 							; read nothing.
.ae63		f0 f2		beq $ae57			beq 	_BLReadFile
.ae65		8d dd 07	sta $07dd			sta 	BLCopyCounter 				; counter.
.ae68		ac dc 07	ldy $07dc			ldy 	BLYOffset 					; copy the buffer out here
.ae6b		a2 00		ldx #$00			ldx 	#0 							; offset in buffer.
.ae6d						_BLCopyLoop:
.ae6d		bd bd 06	lda $06bd,x			lda 	KNLReadBuffer,x 			; copy byte and advance
.ae70		91 3a		sta ($3a),y			sta 	(zTemp2),y
.ae72		c8		iny				iny
.ae73		d0 03		bne $ae78			bne 	_BLNoAdjust 				; check changed 256 byte or 8k page.
.ae75		20 c9 ae	jsr $aec9			jsr 	BLAdvancePhysicalMemory
.ae78						_BLNoAdjust:
.ae78		e8		inx				inx
.ae79		ce dd 07	dec $07dd			dec 	BLCopyCounter
.ae7c		d0 ef		bne $ae6d			bne 	_BLCopyLoop
.ae7e		8c dc 07	sty $07dc			sty 	BLYOffset 					; update Y offset
.ae81		80 d4		bra $ae57			bra 	_BLReadFile 				; go ask for more.
.ae83						_BLFileError:
.ae83		c9 30		cmp #$30			cmp 	#KERR_EOF 					; End of file
.ae85		d0 0d		bne $ae94			bne 	_BLErrorHandler				; no, it's an actual error
.ae87		20 c3 ae	jsr $aec3			jsr 	BLClosePhysicalMemory 		; close the access.
.ae8a		ad df 07	lda $07df			lda 	BasicFileStream 			; close the file
.ae8d		20 19 85	jsr $8519			jsr 	KNLCloseFile
.ae90		a9 00		lda #$00			lda 	#0 							; and return zero.
.ae92		7a		ply				ply
.ae93		60		rts				rts
.ae94						_BLErrorHandler:
.ae94		48		pha				pha 								; save code
.ae95		20 c3 ae	jsr $aec3			jsr 	BLClosePhysicalMemory 		; close access
.ae98		ad df 07	lda $07df			lda 	BasicFileStream 			; close the open file
.ae9b		20 19 85	jsr $8519			jsr 	KNLCloseFile
.ae9e		68		pla				pla 								; get error code
.ae9f						_BLErrorExit:
.ae9f		7a		ply				ply 								; restore position and exit.
.aea0		60		rts				rts
=3						BLAccessPage = 3 							; page to use for actual memory.
.aea1						BLOpenPhysicalMemory:
.aea1		a5 0b		lda $0b				lda 	BLAccessPage+8 				; save current mapping
.aea3		8d db 07	sta $07db			sta 	BLNormalMapping
.aea6		b5 60		lda $60,x			lda 	NSMantissa0,x 				; copy address, 13 bit adjusted for page -> (zTemp2),BLYOffset
.aea8		8d dc 07	sta $07dc			sta 	BLYOffset 					; zTemp2 0 is *always* zero.
.aeab		64 3a		stz $3a				stz 	zTemp2
.aead		b5 70		lda $70,x			lda 	NSMantissa1,x
.aeaf		29 1f		and #$1f			and 	#$1F
.aeb1		09 60		ora #$60			ora 	#BLAccessPage << 5
.aeb3		85 3b		sta $3b				sta 	zTemp2+1
.aeb5		b5 80		lda $80,x			lda 	NSMantissa2,x 				; shift M2:M1 right 3 times to give page # required
.aeb7		16 70		asl $70,x			asl 	NSMantissa1,x
.aeb9		2a		rol a				rol 	a
.aeba		16 70		asl $70,x			asl 	NSMantissa1,x
.aebc		2a		rol a				rol 	a
.aebd		16 70		asl $70,x			asl 	NSMantissa1,x
.aebf		2a		rol a				rol 	a
.aec0		85 0b		sta $0b				sta 	BLAccessPage+8 				; access that page
.aec2		60		rts				rts
.aec3						BLClosePhysicalMemory:
.aec3		ad db 07	lda $07db			lda 	BLNormalMapping
.aec6		85 0b		sta $0b				sta 	BLAccessPage+8
.aec8		60		rts				rts
.aec9						BLAdvancePhysicalMemory:
.aec9		48		pha				pha
.aeca		e6 3b		inc $3b				inc		zTemp2+1 					; bump MSB
.aecc		a5 3b		lda $3b				lda 	zTemp2+1
.aece		c9 80		cmp #$80			cmp 	#(BLAccessPage+1) << 5 		; reached next page ?
.aed0		d0 06		bne $aed8			bne 	_BLAPMExit 					; (e.g. end of the mapped page.)
.aed2		e6 0b		inc $0b				inc 	BLAccessPage+8 				; next physical page
.aed4		a9 60		lda #$60			lda 	#BLAccessPage << 5 			; page back to start of transfer page
.aed6		85 3b		sta $3b				sta 	zTemp2+1
.aed8						_BLAPMExit:
.aed8		68		pla				pla
.aed9		60		rts				rts
.07db						BLNormalMapping:
>07db								.fill 	1
.07dc						BLYOffset:
>07dc								.fill 	1
.07dd						BLCopyCounter:
>07dd								.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/files/bsave.asm

.aeda						Command_BSave:
.aeda		20 e5 ae	jsr $aee5			jsr 	BSaveHandler
.aedd		c9 00		cmp #$00			cmp 	#0
.aedf		d0 01		bne $aee2			bne 	_BSError
.aee1		60		rts				rts
.aee2						_BSError:
.aee2		4c 8d b0	jmp $b08d			jmp 	CLErrorHandler
.aee5						BSaveHandler:
.aee5		a2 00		ldx #$00			ldx 	#0
.aee7		20 da a3	jsr $a3da			jsr 	EvaluateString 				; file name to load
.aeea		20 08 95	jsr $9508			jsr 	CheckComma 					; consume comma
.aeed		e8		inx				inx
.aeee		20 ef a3	jsr $a3ef			jsr 	EvaluateInteger 			; load address (full physical address)
.aef1		20 08 95	jsr $9508			jsr 	CheckComma 					; consume comma
.aef4		e8		inx				inx
.aef5		20 ef a3	jsr $a3ef			jsr 	EvaluateInteger 			; data length (3 bytes only)
.aef8		5a		phy				phy
.aef9		a5 60		lda $60				lda 	NSMantissa0					; file name -> XA
.aefb		a6 70		ldx $70				ldx 	NSMantissa1
.aefd		20 45 84	jsr $8445			jsr 	KNLOpenFileWrite 			; open file for reading
.af00		b0 47		bcs $af49			bcs 	_BSErrorExit 				; error, so fail.
.af02		8d df 07	sta $07df			sta 	BasicFileStream 			; save the reading stream.
.af05		a2 01		ldx #$01			ldx 	#1 							; address is in slot # 1
.af07		20 a1 ae	jsr $aea1			jsr 	BLOpenPhysicalMemory 		; open for access.
.af0a		a2 00		ldx #$00			ldx 	#0 							; number of bytes in kernel buffer
.af0c		ac dc 07	ldy $07dc			ldy 	BLYOffset 					; used for data offset.
.af0f						_BSWriteToFileLoop:
.af0f		38		sec				sec 								; pre decrement count.
.af10		a5 62		lda $62				lda 	NSMantissa0+2
.af12		e9 01		sbc #$01			sbc 	#1
.af14		85 62		sta $62				sta 	NSMantissa0+2
.af16		a5 72		lda $72				lda 	NSMantissa1+2
.af18		e9 00		sbc #$00			sbc 	#0
.af1a		85 72		sta $72				sta 	NSMantissa1+2
.af1c		a5 82		lda $82				lda 	NSMantissa2+2
.af1e		e9 00		sbc #$00			sbc 	#0
.af20		85 82		sta $82				sta 	NSMantissa2+2
.af22		30 15		bmi $af39			bmi 	_BSFileComplete 			; undercounted, so exit.
.af24		b1 3a		lda ($3a),y			lda 	(zTemp2),y 					; get byte to save
.af26		9d bd 06	sta $06bd,x			sta 	KNLReadBuffer,x 			; save in the buffer and bump buffer index
.af29		e8		inx				inx
.af2a		c8		iny				iny 								; next byte
.af2b		d0 03		bne $af30			bne 	_BSNoCheck
.af2d		20 c9 ae	jsr $aec9			jsr 	BLAdvancePhysicalMemory 	; check not gone to next page.
.af30						_BSNoCheck:
.af30		e0 40		cpx #$40			cpx 	#KNLReadBufferLen 			; done the whole buffer
.af32		d0 db		bne $af0f			bne 	_BSWriteToFileLoop 			; no , do the next byte.
.af34		20 4b af	jsr $af4b			jsr 	BSFlushBuffer 				; yes, flush the buffer
.af37		80 d6		bra $af0f			bra 	_BSWriteToFileLoop 			; and keep on going
.af39						_BSFileComplete:
.af39		20 4b af	jsr $af4b			jsr 	BSFlushBuffer 				; write the buffer remainder.
.af3c		20 c3 ae	jsr $aec3			jsr 	BLClosePhysicalMemory 		; close the access.
.af3f		ad df 07	lda $07df			lda 	BasicFileStream 			; close the file
.af42		20 19 85	jsr $8519			jsr 	KNLCloseFile
.af45		a9 00		lda #$00			lda 	#0
.af47		7a		ply				ply
.af48		60		rts				rts
.af49						_BSErrorExit:
.af49		7a		ply				ply
.af4a		60		rts				rts
.af4b						BSFlushBuffer:
.af4b		e0 00		cpx #$00			cpx 	#0 							; buffer empty ?
.af4d		f0 0d		beq $af5c			beq 	_BSFBExit 					; if so, exit.
.af4f		a9 bd		lda #$bd			lda 	#KNLReadBuffer & $FF 		; where to write from.
.af51		85 36		sta $36				sta 	zTemp0
.af53		a9 06		lda #$06			lda 	#KNLReadBuffer >> 8
.af55		85 37		sta $37				sta 	zTemp0+1 					; # of bytes in X
.af57		20 4f b1	jsr $b14f			jsr 	CLWriteByteBlock 			; write it.
.af5a		a2 00		ldx #$00			ldx 	#0 							; buffer is empty.
.af5c						_BSFBExit:
.af5c		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/files/dir.asm

.af5d						Command_Dir:
.af5d		ad bd 07	lda $07bd			lda     KNLDefaultDrive				; set drive to list.
.af60		85 f3		sta $f3				sta     kernel.args.directory.open.drive
.af62		64 fd		stz $fd				stz     kernel.args.directory.open.path_len
.af64		20 78 ff	jsr $ff78			jsr     kernel.Directory.Open
.af67		b0 4f		bcs $afb8			bcs     _CDExit
.af69						_CDEventLoop:
.af69		20 0c ff	jsr $ff0c			jsr     kernel.Yield        		; Polite, not actually needed.
.af6c		20 ff 82	jsr $82ff			jsr     GetNextEvent
.af6f		b0 f8		bcs $af69			bcs     _CDEventLoop
.af71		ad be 07	lda $07be			lda     KNLEvent.type
.af74		c9 46		cmp #$46			cmp     #kernel.event.directory.CLOSED
.af76		f0 40		beq $afb8			beq    	_CDExit
.af78		20 7d af	jsr $af7d			jsr     _CDMessages 				; handle various messages
.af7b		80 ec		bra $af69			bra     _CDEventLoop
.af7d						_CDMessages:
.af7d		c9 3c		cmp #$3c			cmp     #kernel.event.directory.OPENED
.af7f		f0 15		beq $af96			beq     _CDEVRead
.af81		c9 3e		cmp #$3e			cmp     #kernel.event.directory.VOLUME
.af83		f0 19		beq $af9e			beq     _CDEVVolume
.af85		c9 40		cmp #$40			cmp     #kernel.event.directory.FILE
.af87		f0 32		beq $afbb			beq     _CDEVFile
.af89		c9 42		cmp #$42			cmp     #kernel.event.directory.FREE
.af8b		f0 70		beq $affd			beq     _CDEVFree
.af8d		c9 44		cmp #$44			cmp     #kernel.event.directory.EOF
.af8f		f0 6e		beq $afff			beq     _CDEVEOF
.af91		c9 48		cmp #$48			cmp     #kernel.event.directory.ERROR
.af93		f0 6a		beq $afff			beq     _CDEVEOF
.af95		60		rts				rts
.af96						_CDEVRead:
.af96		ad c1 07	lda $07c1			lda     KNLEvent.directory.stream
.af99		85 f3		sta $f3				sta     kernel.args.directory.read.stream
.af9b		4c 7c ff	jmp $ff7c			jmp     kernel.Directory.Read
.af9e						_CDEVVolume:
.af9e		a9 5b		lda #$5b			lda 	#"["
.afa0		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.afa3		ad c3 07	lda $07c3			lda     KNLEvent.directory.volume.len
.afa6		20 07 b0	jsr $b007			jsr     _CDReadData
.afa9		20 78 95	jsr $9578			jsr 	PrintStringXA
.afac		a9 5d		lda #$5d			lda 	#"]"
.afae		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.afb1		a9 0d		lda #$0d			lda 	#13
.afb3		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.afb6		80 de		bra $af96			bra     _CDEVRead
.afb8						_CDExit:
.afb8		4c 12 89	jmp $8912			jmp 	WarmStart
.afbb						_CDEVFile:
.afbb		a9 20		lda #$20			lda 	#32
.afbd		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.afc0		ad c3 07	lda $07c3			lda     KNLEvent.directory.file.len
.afc3		48		pha				pha
.afc4		20 07 b0	jsr $b007			jsr     _CDReadData
.afc7		20 78 95	jsr $9578			jsr 	PrintStringXA
.afca		68		pla				pla
.afcb		49 ff		eor #$ff			eor 	#$FF
.afcd		38		sec				sec
.afce		69 10		adc #$10			adc 	#16
.afd0		aa		tax				tax
.afd1						_CDEVTab:
.afd1		a9 20		lda #$20			lda 	#32
.afd3		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.afd6		ca		dex				dex
.afd7		10 f8		bpl $afd1			bpl 	_CDEVTab
.afd9		20 1e b0	jsr $b01e			jsr 	_CDReadExtended
.afdc		ad 46 05	lda $0546			lda 	lineBuffer
.afdf		ae 47 05	ldx $0547			ldx 	lineBuffer+1
.afe2		20 8e 99	jsr $998e			jsr 	ConvertInt16
.afe5		20 78 95	jsr $9578			jsr 	PrintStringXA
.afe8		a2 af		ldx #$af			ldx 	#_CDEVFMessage >> 8
.afea		a9 f1		lda #$f1			lda 	#_CDEVFMessage & $FF
.afec		20 78 95	jsr $9578			jsr 	PrintStringXA
.afef		80 a5		bra $af96			bra     _CDEVRead
.aff1						_CDEVFMessage:
>aff1		20 62 6c 6f 63 6b 28 73				.text 	" block(s).",13,0
>aff9		29 2e 0d 00
.affd						_CDEVFree:
.affd		80 00		bra $afff			bra     _CDEVEOF
.afff						_CDEVEOF:
.afff		ad c1 07	lda $07c1			lda     KNLEvent.directory.stream
.b002		85 f3		sta $f3				sta     kernel.args.directory.close.stream
.b004		4c 80 ff	jmp $ff80			jmp     kernel.Directory.Close
.b007						_CDReadData:
.b007		85 fd		sta $fd				sta     kernel.args.recv.buflen
.b009		a9 46		lda #$46			lda     #lineBuffer & $FF
.b00b		85 fb		sta $fb				sta     kernel.args.recv.buf+0
.b00d		a9 05		lda #$05			lda     #lineBuffer >> 8
.b00f		85 fc		sta $fc				sta     kernel.args.recv.buf+1
.b011		20 04 ff	jsr $ff04			jsr     kernel.ReadData
.b014		a6 fd		ldx $fd				ldx     kernel.args.recv.buflen
.b016		9e 46 05	stz $0546,x			stz     lineBuffer,x
.b019		a9 46		lda #$46			lda 	#lineBuffer & $FF
.b01b		a2 05		ldx #$05			ldx 	#lineBuffer >> 8
.b01d		60		rts				rts
.b01e						_CDReadExtended:
.b01e		a9 02		lda #$02			lda     #2
.b020		85 fd		sta $fd				sta     kernel.args.recv.buflen
.b022		a9 46		lda #$46			lda     #lineBuffer & $FF
.b024		85 fb		sta $fb				sta     kernel.args.recv.buf+0
.b026		a9 05		lda #$05			lda     #lineBuffer >> 8
.b028		85 fc		sta $fc				sta     kernel.args.recv.buf+1
.b02a		4c 08 ff	jmp $ff08			jmp     kernel.ReadExt

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/files/drive.asm

.b02d						Command_Drive:
.b02d		20 1d a4	jsr $a41d			jsr 	Evaluate8BitInteger
.b030		20 41 84	jsr $8441			jsr 	KNLSetDrive
.b033		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/files/load.asm

.b034						Command_Load:
.b034		20 a0 88	jsr $88a0			jsr		IsDestructiveActionOK
.b037		b0 03		bcs $b03c			bcs		_not_ok
.b039		20 3f b0	jsr $b03f			jsr 	LoadFile
.b03c						_not_ok
.b03c		4c 12 89	jmp $8912			jmp		WarmStart
.b03f						LoadFile:
.b03f		20 da a3	jsr $a3da			jsr 	EvaluateString 				; file name to load
.b042		a6 37		ldx $37				ldx 	zTemp0+1					; zTemp0 -> XA
.b044		a5 36		lda $36				lda 	zTemp0
.b046		20 4a 84	jsr $844a			jsr 	KNLOpenFileRead 			; open file for reading
.b049		b0 42		bcs $b08d			bcs 	CLErrorHandler 				; error, so fail.
.b04b		8d df 07	sta $07df			sta 	BasicFileStream 			; save the reading stream.
.b04e		20 dd b0	jsr $b0dd			jsr     LoadReadByteInit            ; Init reader with the stream
.b051		20 43 8f	jsr $8f43			jsr 	NewProgram 					; does the actual NEW.
.b054		9c de 07	stz $07de			stz 	LoadEOFFlag 				; clear EOF Flag.
.b057						_CLLoop:
.b057		20 9b b0	jsr $b09b			jsr 	LoadReadLine 				; get next line.
.b05a		f0 10		beq $b06c			beq 	_CLExit 					; end, exit.
.b05c		20 93 80	jsr $8093			jsr 	TKTokeniseLine 				; tokenise the line.
.b05f		ad 47 04	lda $0447			lda 	tokenLineNumber 			; line number = 0
.b062		0d 48 04	ora $0448			ora 	tokenLineNumber+1
.b065		f0 f0		beq $b057			beq 	_CLLoop 					; not legal code, blank line or maybe a comment.
.b067		20 62 88	jsr $8862			jsr 	EditProgramCode 			; do the editing etc.
.b06a		80 eb		bra $b057			bra 	_CLLoop
.b06c						_CLExit:
.b06c		ad df 07	lda $07df			lda 	BasicFileStream
.b06f		20 19 85	jsr $8519			jsr 	KNLCloseFile
.b072						CLComplete:
.b072		a9 7a		lda #$7a			lda 	#_CLCMsg & $FF
.b074		a2 b0		ldx #$b0			ldx 	#_CLCMsg >> 8
.b076		20 78 95	jsr $9578			jsr 	PrintStringXA
.b079		60		rts				rts
.b07a						_CLCMsg:
>b07a		43 6f 6d 70 6c 65 74 65				.text 	"Complete.",13,0
>b082		2e 0d 00
.b085						CLCloseError:
.b085		48		pha				pha
.b086		ad df 07	lda $07df			lda 	BasicFileStream
.b089		20 19 85	jsr $8519			jsr 	KNLCloseFile
.b08c		68		pla				pla
.b08d						CLErrorHandler:
.b08d		c9 28		cmp #$28			cmp 	#KERR_NOTFOUND
.b08f		f0 05		beq $b096			beq 	_CLEHNotFound
.b091		a9 1a		lda #$1a		lda	#26
.b093		4c 19 95	jmp $9519		jmp	ErrorHandler
.b096						_CLEHNotFound:
.b096		a9 19		lda #$19		lda	#25
.b098		4c 19 95	jmp $9519		jmp	ErrorHandler
.b09b						LoadReadLine:
.b09b		a2 00		ldx #$00			ldx 	#0 							; look for first character non space/ctl
.b09d		20 b7 b0	jsr $b0b7			jsr 	LoadReadCharacter
.b0a0		f0 14		beq $b0b6			beq 	_LRLExit 					; eof ?
.b0a2		c9 21		cmp #$21			cmp 	#' '+1 						; space control tab skip
.b0a4		90 f5		bcc $b09b			bcc 	LoadReadLine
.b0a6						_LRLLoop:
.b0a6		9d 46 05	sta $0546,x			sta 	lineBuffer,x 				; write into line buffer
.b0a9		9e 47 05	stz $0547,x			stz 	lineBuffer+1,x 				; make ASCIIZ
.b0ac		e8		inx				inx
.b0ad		20 b7 b0	jsr $b0b7			jsr 	LoadReadCharacter 			; next line
.b0b0		c9 20		cmp #$20			cmp 	#32 						; until < space ctrl/eof.
.b0b2		b0 f2		bcs $b0a6			bcs 	_LRLLoop
.b0b4		a9 01		lda #$01			lda 	#1 							; return code 1, okay.
.b0b6						_LRLExit:
.b0b6		60		rts				rts
.b0b7						LoadReadCharacter:
.b0b7		da		phx				phx
.b0b8		5a		phy				phy
.b0b9		ad de 07	lda $07de			lda 	LoadEOFFlag 				; already done EOF.
.b0bc		d0 0c		bne $b0ca			bne 	_LRCIsEOF
.b0be		20 e7 b0	jsr $b0e7			jsr 	LoadReadByte 				; read a byte
.b0c1		90 09		bcc $b0cc			bcc		_LRCExit 					; read okay.
.b0c3		c9 30		cmp #$30			cmp 	#KERR_EOF 					; if error not EOF it's an actual error.
.b0c5		d0 be		bne $b085			bne 	CLCloseError
.b0c7		ce de 07	dec $07de			dec 	LoadEOFFlag
.b0ca						_LRCIsEOF:
.b0ca		a9 00		lda #$00			lda 	#0
.b0cc						_LRCExit:
.b0cc		c9 09		cmp #$09			cmp 	#9 							; convert tab to space
.b0ce		d0 02		bne $b0d2			bne 	_LRCNotTab
.b0d0		a9 20		lda #$20			lda 	#' '
.b0d2						_LRCNotTab:
.b0d2		c9 0a		cmp #$0a			cmp 	#$0A
.b0d4		d0 02		bne $b0d8			bne 	_LRCNotLF
.b0d6		a9 0d		lda #$0d			lda 	#$0D
.b0d8						_LRCNotLF:
.b0d8		7a		ply				ply
.b0d9		fa		plx				plx
.b0da		c9 00		cmp #$00			cmp 	#0 							; set Z flag if EOF.
.b0dc		60		rts				rts
.b0dd						LoadReadByteInit:
.b0dd		8d e0 07	sta $07e0			sta     LoadFileStream 				; save stream
.b0e0		9c e1 07	stz $07e1			stz     LoadNextCharacter 			; reset buffer
.b0e3		9c e2 07	stz $07e2			stz     LoadEndCharacter
.b0e6		60		rts				rts
.b0e7						LoadReadByte:
.b0e7		da		phx				phx
.b0e8		ae e1 07	ldx $07e1			ldx     LoadNextCharacter 					; all data consumed ?
.b0eb		ec e2 07	cpx $07e2			cpx     LoadEndCharacter
.b0ee		d0 12		bne $b102			bne     _KNLRBGetNextByte
.b0f0		ad e0 07	lda $07e0			lda     LoadFileStream
.b0f3		a2 40		ldx #$40			ldx     #KNLReadBufferLen 			; set bytes to read.
.b0f5		20 a4 84	jsr $84a4			jsr     KNLReadBlock 				; read next chunk from the stream
.b0f8		b0 0f		bcs $b109			bcs     _KNLRBError 				; error has occurred on read.
.b0fa		8d e2 07	sta $07e2			sta     LoadEndCharacter 						; # read is the number available
.b0fd		a2 00		ldx #$00			ldx     #0 							; reset the read pointer.
.b0ff		8e e1 07	stx $07e1			stx     LoadNextCharacter
.b102						_KNLRBGetNextByte:
.b102		bd bd 06	lda $06bd,x			lda     KNLReadBuffer,x 			; get the next data item
.b105		ee e1 07	inc $07e1			inc     LoadNextCharacter 					; and advance the index
.b108		18		clc				clc 								; succeeded
.b109						_KNLRBError:
.b109		fa		plx				plx
.b10a		60		rts				rts
.07de						LoadEOFFlag:
>07de								.fill 	1
.07df						BasicFileStream:
>07df								.fill 	1
.07e0						LoadFileStream:
>07e0								.byte   ?
.07e1						LoadNextCharacter:
>07e1								.byte   ?
.07e2						LoadEndCharacter:
>07e2								.byte   ?

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/files/save.asm

.b10b						Command_Save:
.b10b		20 da a3	jsr $a3da			jsr 	EvaluateString 				; file name to load
.b10e		a6 37		ldx $37				ldx 	zTemp0+1					; zTemp0 -> XA
.b110		a5 36		lda $36				lda 	zTemp0
.b112		20 45 84	jsr $8445			jsr 	KNLOpenFileWrite 			; open file for writing
.b115		b0 35		bcs $b14c			bcs 	CSErrorHandler 				; error, so fail.
.b117		8d df 07	sta $07df			sta 	BasicFileStream 			; save the reading stream.
.b11a		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.b11c		85 30		sta $30				sta 	codePtr
.b11e		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.b120		85 31		sta $31				sta 	codePtr+1
.b122						_CSLoop:
.b122		b2 30		lda ($30)			lda 	(codePtr)
.b124		f0 17		beq $b13d			beq 	_CSExit
.b126		20 70 b1	jsr $b170			jsr 	CSGetCleanLine
.b129		84 37		sty $37				sty 	zTemp0+1 					; save write address of data
.b12b		85 36		sta $36				sta 	zTemp0
.b12d		20 4f b1	jsr $b14f			jsr 	CLWriteByteBlock 			; write the block out.
.b130		18		clc				clc
.b131		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.b133		65 30		adc $30				adc 	codePtr
.b135		85 30		sta $30				sta 	codePtr
.b137		90 02		bcc $b13b			bcc 	_CREExit
.b139		e6 31		inc $31				inc 	codePtr+1 					; carry
.b13b						_CREExit:
.b13b		80 e5		bra $b122			bra 	_CSLoop
.b13d						_CSExit:
.b13d		ad df 07	lda $07df			lda 	BasicFileStream 			; close file
.b140		20 19 85	jsr $8519			jsr 	KNLCloseFile
.b143		20 72 b0	jsr $b072			jsr 	CLComplete 					; display complete message.
.b146		9c 75 06	stz $0675			stz		programChanged				; mark program not changed since save
.b149		4c 12 89	jmp $8912			jmp 	WarmStart 					; and warm start
.b14c						CSErrorHandler:
.b14c		4c 8d b0	jmp $b08d			jmp 	CLErrorHandler
.b14f						CLWriteByteBlock:
.b14f		e0 00		cpx #$00			cpx 	#0 							; written the lot ?
.b151		f0 1c		beq $b16f			beq 	_CLWBBExit					; if so, exit
.b153		ad df 07	lda $07df			lda 	BasicFileStream 			; stream to write, count in X
.b156		20 df 84	jsr $84df			jsr 	KNLWriteBlock 				; call one write attempt
.b159		b0 f1		bcs $b14c			bcs 	CSErrorHandler 				; error occurred
.b15b		85 38		sta $38				sta 	zTemp1 						; save bytes written.
.b15d		8a		txa				txa 								; subtract bytes written from X, total count.
.b15e		38		sec				sec
.b15f		e5 38		sbc $38				sbc 	zTemp1
.b161		aa		tax				tax
.b162		18		clc				clc 								; advance zTemp0 pointer by bytes written.
.b163		a5 36		lda $36				lda 	zTemp0
.b165		65 38		adc $38				adc 	zTemp1
.b167		85 36		sta $36				sta 	zTemp0
.b169		90 e4		bcc $b14f			bcc 	CLWriteByteBlock
.b16b		e6 37		inc $37				inc 	zTemp0+1
.b16d		80 e0		bra $b14f			bra 	CLWriteByteBlock 			; and retry write out.
.b16f						_CLWBBExit:
.b16f		60		rts				rts
.b170						CSGetCleanLine:
.b170		a9 00		lda #$00			lda 	#0 							; no indent.
.b172		20 89 80	jsr $8089			jsr 	TKListConvertLine 			; convert line into token Buffer
.b175		a2 00		ldx #$00			ldx 	#0 							; copy stripping controls.
.b177		a0 00		ldy #$00			ldy 	#0
.b179						_CSClean:
.b179		b9 49 04	lda $0449,y			lda 	tokenBuffer,y
.b17c		f0 09		beq $b187			beq 	_CSDoneClean
.b17e		30 04		bmi $b184			bmi 	_CSIgnoreCharacter
.b180		9d 46 05	sta $0546,x			sta 	lineBuffer,x
.b183		e8		inx				inx
.b184						_CSIgnoreCharacter:
.b184		c8		iny				iny
.b185		80 f2		bra $b179			bra 	_CSClean
.b187						_CSDoneClean:
.b187		a9 0d		lda #$0d			lda 	#13 						; add CR, length now in X and ASCIIZ.
.b189		9d 46 05	sta $0546,x			sta 	lineBuffer,x
.b18c		e8		inx				inx
.b18d		9e 46 05	stz $0546,x			stz 	lineBuffer,x
.b190		a0 05		ldy #$05			ldy 	#(lineBuffer >> 8) 			; line address in YA
.b192		a9 46		lda #$46			lda 	#(lineBuffer & $FF)
.b194		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/files/try.asm

.b195						Command_Try:
.b195		b1 30		lda ($30),y			lda 	(codePtr),y
.b197		c9 81		cmp #$81			cmp 	#KWC_SHIFT1					; can only try in SHIFT_1
.b199		d0 0c		bne $b1a7			bne 	_TrySyntax
.b19b		c8		iny				iny 								; get second
.b19c		b1 30		lda ($30),y			lda 	(codePtr),y
.b19e		c8		iny				iny 								; and consume it.
.b19f		c9 86		cmp #$86			cmp 	#KWD1_BLOAD
.b1a1		f0 09		beq $b1ac			beq 	_TryBLoad
.b1a3		c9 87		cmp #$87			cmp	 	#KWD1_BSAVE
.b1a5		f0 0a		beq $b1b1			beq 	_TryBSave
.b1a7						_TrySyntax:
.b1a7		a9 02		lda #$02		lda	#2
.b1a9		4c 19 95	jmp $9519		jmp	ErrorHandler
.b1ac						_TryBLoad:
.b1ac		20 39 ae	jsr $ae39			jsr 	BLOADHandler
.b1af		80 03		bra $b1b4			bra 	_TryExit
.b1b1						_TryBSave:
.b1b1		20 e5 ae	jsr $aee5			jsr 	BSaveHandler
.b1b4						_TryExit:
.b1b4		48		pha				pha 								; save result
.b1b5		b1 30		lda ($30),y			lda 	(codePtr),y
.b1b7		c8		iny				iny
.b1b8		c9 dc		cmp #$dc			cmp 	#KWD_TO
.b1ba		d0 eb		bne $b1a7			bne 	_TrySyntax
.b1bc		a2 00		ldx #$00			ldx 	#0 							; get an integer reference.
.b1be		20 76 9e	jsr $9e76			jsr 	EvaluateTerm
.b1c1		b5 50		lda $50,x			lda 	NSStatus,x
.b1c3		c9 20		cmp #$20			cmp 	#NSBIsReference+NSTInteger 	; do we have an integer 4 byte reference.
.b1c5		d0 e0		bne $b1a7			bne		_TrySyntax
.b1c7		68		pla				pla 								; error code.
.b1c8		a2 01		ldx #$01			ldx	 	#1 							; address in 0, data in 1
.b1ca		20 84 a4	jsr $a484			jsr 	NSMSetByte
.b1cd		ca		dex				dex
.b1ce		20 4d 8d	jsr $8d4d			jsr 	AssignVariable 				; do the assign and exit
.b1d1		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/files/verify.asm

.e779						m
.b1d2						Command_VERIFY:
.b1d2		20 da a3	jsr $a3da			jsr 	EvaluateString 				; file name to verify
.b1d5		a6 37		ldx $37				ldx 	zTemp0+1					; zTemp0 -> XA
.b1d7		a5 36		lda $36				lda 	zTemp0
.b1d9		20 4a 84	jsr $844a			jsr 	KNLOpenFileRead 			; open file for reading
.b1dc		b0 51		bcs $b22f			bcs 	_CVErrorHandler 			; error, so fail.
.b1de		8d df 07	sta $07df			sta 	BasicFileStream 			; save the reading stream.
.b1e1		20 dd b0	jsr $b0dd			jsr     LoadReadByteInit            ; Init reader with the stream
.b1e4		9c de 07	stz $07de			stz 	LoadEOFFlag 				; clear EOF Flag.
.b1e7		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.b1e9		85 30		sta $30				sta 	codePtr
.b1eb		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.b1ed		85 31		sta $31				sta 	codePtr+1
.b1ef						_CVLoop:
.b1ef		20 9b b0	jsr $b09b			jsr 	LoadReadLine 				; get next line.
.b1f2		f0 27		beq $b21b			beq 	_CVExit 					; end, exit.
.b1f4		20 93 80	jsr $8093			jsr 	TKTokeniseLine 				; tokenise the line.
.b1f7		ad 47 04	lda $0447			lda 	tokenLineNumber 			; line number = 0
.b1fa		0d 48 04	ora $0448			ora 	tokenLineNumber+1
.b1fd		f0 f0		beq $b1ef			beq 	_CVLoop 					; not legal code, blank line or maybe a comment.
.b1ff		a0 00		ldy #$00			ldy 	#0 							; start compare
.b201						_CVCompareLoop:
.b201		b1 30		lda ($30),y			lda 	(codePtr),y
.b203		d9 46 04	cmp $0446,y			cmp 	tokenOffset,y 				; compare against actual code.
.b206		d0 1f		bne $b227			bne 	_CVCompareError
.b208		c8		iny				iny
.b209		cc 46 04	cpy $0446			cpy 	tokenOffset 				; until done whole line of code
.b20c		d0 f3		bne $b201			bne 	_CVCompareLoop
.b20e		18		clc				clc
.b20f		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.b211		65 30		adc $30				adc 	codePtr
.b213		85 30		sta $30				sta 	codePtr
.b215		90 02		bcc $b219			bcc 	_CREExit
.b217		e6 31		inc $31				inc 	codePtr+1 					; carry
.b219						_CREExit:
.b219		80 d4		bra $b1ef			bra 	_CVLoop
.b21b						_CVExit:
.b21b		ad df 07	lda $07df			lda 	BasicFileStream
.b21e		20 19 85	jsr $8519			jsr 	KNLCloseFile
.b221		20 72 b0	jsr $b072			jsr 	CLComplete
.b224		4c 12 89	jmp $8912			jmp		WarmStart
.b227						_CVCompareError:
.b227		20 8c 88	jsr $888c			jsr		ResetTokenBuffer
.b22a		a9 1b		lda #$1b		lda	#27
.b22c		4c 19 95	jmp $9519		jmp	ErrorHandler
.b22f						_CVErrorHandler:
.b22f		4c 8d b0	jmp $b08d			jmp 	CLErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/joy.asm

.b232						UnaryJoyX:
.b232		18		clc				clc
.b233		80 01		bra $b236			bra 	JoyMain
.b235						UnaryJoyY:
.b235		38		sec				sec
.b236						JoyMain:
.b236		fa		plx				plx 								; get pos
.b237		08		php				php 								; save carry (set for Y)
.b238		20 1d a4	jsr $a41d			jsr 	Evaluate8BitInteger 		; ignore the parameter
.b23b		20 00 95	jsr $9500			jsr 	CheckRightBracket
.b23e		20 1f 85	jsr $851f			jsr 	KNLReadController 			; read the controller.
.b241		28		plp				plp
.b242		b0 02		bcs $b246			bcs 	_JMNoShift 					; if X then shift bits 3,2 -> 1,0
.b244		4a		lsr a				lsr 	a
.b245		4a		lsr a				lsr 	a
.b246						_JMNoShift:
.b246		4a		lsr a				lsr 	a 							; if bit 0 set then left/up e.g. -1
.b247		b0 07		bcs $b250			bcs 	JMIsLeft
.b249		4a		lsr a				lsr 	a 							; if bit 1 set then right/down e.g. +1
.b24a		b0 07		bcs $b253			bcs 	JMIsRight
.b24c		20 82 a4	jsr $a482			jsr 	NSMSetZero 					; zero result
.b24f		60		rts				rts
.b250						JMIsLeft:
.b250		4c 8c 95	jmp $958c			jmp 	ReturnTrue
.b253						JMIsRight:
.b253		a9 01		lda #$01			lda 	#1
.b255		20 84 a4	jsr $a484			jsr 	NSMSetByte
.b258		60		rts				rts
.b259						UnaryJoyB:
.b259		fa		plx				plx 								; get pos
.b25a		20 1d a4	jsr $a41d			jsr 	Evaluate8BitInteger 		; ignore the parameter
.b25d		20 00 95	jsr $9500			jsr 	CheckRightBracket
.b260		20 1f 85	jsr $851f			jsr 	KNLReadController 			; read the controller.
.b263		29 10		and #$10			and 	#$10
.b265		d0 e9		bne $b250			bne 	JMIsLeft
.b267		20 82 a4	jsr $a482			jsr 	NSMSetZero
.b26a		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/memcopy.asm

.b26b						MCCommand:
.b26b		a5 01		lda $01				lda 	1 							; save current I/O ; switch to I/O 0
.b26d		48		pha				pha
.b26e		64 01		stz $01				stz 	1
.b270		9c 00 df	stz $df00			stz 	$DF00 						; zero control byte.
.b273		a9 81		lda #$81			lda 	#$81 						; standard start byte (DMA Enabled, Start set)
.b275		8d e3 07	sta $07e3			sta 	DMAControlByte
.b278		20 26 b3	jsr $b326			jsr 	MCPosition 					; start position
.b27b		a2 04		ldx #$04			ldx 	#4 							; write to source AND $DF04 destination address $DF08
.b27d		20 f7 b2	jsr $b2f7			jsr 	MCCopyAddress
.b280		a2 08		ldx #$08			ldx 	#8
.b282		20 f7 b2	jsr $b2f7			jsr 	MCCopyAddress
.b285		b1 30		lda ($30),y			lda 	(codePtr),y
.b287		c8		iny				iny
.b288		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; , <size>
.b28a		f0 09		beq $b295			beq 	_MCSize1D
.b28c		c9 d6		cmp #$d6			cmp 	#KWD_RECT 					; RECT <x>,<y>
.b28e		f0 11		beq $b2a1			beq 	_MCRect2D
.b290						_MCSyntax:
.b290		a9 02		lda #$02		lda	#2
.b292		4c 19 95	jmp $9519		jmp	ErrorHandler
.b295						_MCSize1D:
.b295		a2 00		ldx #$00			ldx 	#0 							; get size
.b297		20 ef a3	jsr $a3ef			jsr 	EvaluateInteger
.b29a		a2 0c		ldx #$0c			ldx 	#$C 						; copy to size $DF0C-E
.b29c		20 f7 b2	jsr $b2f7			jsr 	MCCopyAddress
.b29f		80 24		bra $b2c5			bra 	_MCDestination
.b2a1						_MCRect2D:
.b2a1		a2 0c		ldx #$0c			ldx 	#$C 						; width to $DF0C,D
.b2a3		20 14 b3	jsr $b314			jsr 	MCEvalCopyData16
.b2a6		20 08 95	jsr $9508			jsr 	CheckComma
.b2a9		a2 0e		ldx #$0e			ldx 	#$E 						; height to $DF0E,F
.b2ab		20 14 b3	jsr $b314			jsr 	MCEvalCopyData16
.b2ae		a9 ba		lda #$ba			lda 	#KWD_BY 					; BY keyword.
.b2b0		20 10 95	jsr $9510			jsr 	CheckNextA
.b2b3		a2 10		ldx #$10			ldx 	#$10 						; store source and destination stride
.b2b5		20 14 b3	jsr $b314			jsr 	MCEvalCopyData16
.b2b8		a2 12		ldx #$12			ldx 	#$12
.b2ba		20 1b b3	jsr $b31b			jsr 	MCCopyData16
.b2bd		ad e3 07	lda $07e3			lda 	DMAControlByte 				; set bit 4 of DMA control indicating 2D.
.b2c0		09 02		ora #$02			ora 	#$02
.b2c2		8d e3 07	sta $07e3			sta 	DMAControlByte
.b2c5						_MCDestination:
.b2c5		b1 30		lda ($30),y			lda 	(codePtr),y
.b2c7		c8		iny				iny
.b2c8		c9 d1		cmp #$d1			cmp 	#KWD_POKE 					; is it POKE n
.b2ca		f0 0e		beq $b2da			beq 	_MCDestPoke
.b2cc		c9 dc		cmp #$dc			cmp 	#KWD_TO 					; is it TO n
.b2ce		d0 c0		bne $b290			bne 	_MCSyntax
.b2d0		20 26 b3	jsr $b326			jsr 	MCPosition 					; get target address
.b2d3		a2 08		ldx #$08			ldx 	#8							; copy to target address at $DF08-A
.b2d5		20 f7 b2	jsr $b2f7			jsr 	MCCopyAddress
.b2d8		80 0e		bra $b2e8			bra 	_MCDoDMA 					; and we can go.
.b2da						_MCDestPoke:
.b2da		20 1d a4	jsr $a41d			jsr 	Evaluate8BitInteger 		; POKE what
.b2dd		8d 01 df	sta $df01			sta 	$DF01 						; set the FILL register
.b2e0		ad e3 07	lda $07e3			lda 	DMAControlByte 				; set bit 2 of control byte indicating FILL.
.b2e3		09 04		ora #$04			ora 	#$04
.b2e5		8d e3 07	sta $07e3			sta 	DMAControlByte
.b2e8						_MCDoDMA:
.b2e8		ad e3 07	lda $07e3			lda 	DMAControlByte 				; set the DMA Control byte to go !
.b2eb		8d 00 df	sta $df00			sta 	$DF00
.b2ee						_MCWaitBUSD:
.b2ee		ad 01 df	lda $df01			lda 	$DF01
.b2f1		30 fb		bmi $b2ee			bmi 	_MCWaitBUSD
.b2f3		68		pla				pla 								; restore I/O.
.b2f4		85 01		sta $01				sta 	1
.b2f6		60		rts				rts
.b2f7						MCCopyAddress:
.b2f7		a5 80		lda $80				lda 	NSMantissa2 				; check valid vlaue
.b2f9		29 f8		and #$f8			and 	#$F8
.b2fb		05 90		ora $90				ora 	NSMantissa3
.b2fd		d0 10		bne $b30f			bne 	_MCRange
.b2ff		a5 60		lda $60				lda 	NSMantissa0
.b301		9d 00 df	sta $df00,x			sta 	$DF00,x
.b304		a5 70		lda $70				lda 	NSMantissa1
.b306		9d 01 df	sta $df01,x			sta 	$DF01,x
.b309		a5 80		lda $80				lda 	NSMantissa2
.b30b		9d 02 df	sta $df02,x			sta 	$DF02,x
.b30e		60		rts				rts
.b30f						_MCRange:
.b30f		a9 04		lda #$04		lda	#4
.b311		4c 19 95	jmp $9519		jmp	ErrorHandler
.b314						MCEvalCopyData16:
.b314		da		phx				phx
.b315		a2 00		ldx #$00			ldx 	#0
.b317		20 02 a4	jsr $a402			jsr 	Evaluate16BitInteger
.b31a		fa		plx				plx
.b31b						MCCopyData16:
.b31b		a5 60		lda $60				lda 	NSMantissa0
.b31d		9d 00 df	sta $df00,x			sta 	$DF00,x
.b320		a5 70		lda $70				lda 	NSMantissa1
.b322		9d 01 df	sta $df01,x			sta 	$DF01,x
.b325		60		rts				rts
.b326						MCPosition:
.b326		a2 00		ldx #$00			ldx 	#0 							; get start address.
.b328		b1 30		lda ($30),y			lda 	(codePtr),y
.b32a		c9 b9		cmp #$b9			cmp 	#KWD_AT
.b32c		f0 04		beq $b332			beq 	_MCPAt
.b32e		20 ef a3	jsr $a3ef			jsr 	EvaluateInteger
.b331		60		rts				rts
.b332						_MCPAt:
.b332		c8		iny				iny
.b333		20 1d a4	jsr $a41d			jsr 	Evaluate8BitInteger 		; X position
.b336		48		pha				pha
.b337		20 08 95	jsr $9508			jsr 	CheckComma
.b33a		e8		inx				inx
.b33b		20 1d a4	jsr $a41d			jsr 	Evaluate8BitInteger 		; Y position
.b33e		ca		dex				dex
.b33f		85 70		sta $70				sta 	NSMantissa1 				; put Y x 64 in Mantissa.0
.b341		64 60		stz $60				stz 	NSMantissa0
.b343		64 80		stz $80				stz 	NSMantissa2
.b345		64 90		stz $90				stz 	NSMantissa3
.b347		46 70		lsr $70				lsr 	NSMantissa1
.b349		66 60		ror $60				ror 	NSMantissa0
.b34b		46 70		lsr $70				lsr 	NSMantissa1
.b34d		66 60		ror $60				ror 	NSMantissa0
.b34f		68		pla				pla
.b350		18		clc				clc
.b351		65 60		adc $60				adc 	NSMantissa0 				; add X, Y * 256 and the
.b353		85 60		sta $60				sta 	NSMantissa0
.b355		a5 70		lda $70				lda 	NSMantissa1
.b357		65 61		adc $61				adc 	NSMantissa0+1
.b359		85 70		sta $70				sta 	NSMantissa1
.b35b		90 02		bcc $b35f			bcc 	_MCPNoCarry
.b35d		e6 80		inc $80				inc 	NSMantissa2
.b35f						_MCPNoCarry:
.b35f		ad 03 09	lda $0903			lda 	gxBasePage
.b362		85 81		sta $81				sta 	NSMantissa2+1
.b364		64 61		stz $61				stz 	NSMantissa0+1
.b366		64 71		stz $71				stz 	NSMantissa1+1
.b368		64 91		stz $91				stz 	NSMantissa3+1
.b36a		a2 01		ldx #$01			ldx 	#1
.b36c		20 9b a4	jsr $a49b			jsr 	NSMShiftRight
.b36f		20 9b a4	jsr $a49b			jsr 	NSMShiftRight
.b372		20 9b a4	jsr $a49b			jsr 	NSMShiftRight
.b375		a2 00		ldx #$00			ldx 	#0
.b377		20 19 98	jsr $9819			jsr 	AddTopTwoStack
.b37a		60		rts				rts
.07e3						DMAControlByte:
>07e3								.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/mouse.asm

.b37b						MouseStatus:
.b37b		a9 ff		lda #$ff	        lda     #255
.b37d		80 02		bra $b381	        bra     MouseCommand
.b37f						MouseDeltaStatus:
.b37f		a9 00		lda #$00	        lda     #0
.b381						MouseCommand:
.b381		8d 82 06	sta $0682	        sta     CMDMouseFlag
.b384		a2 00		ldx #$00	        ldx     #0
.b386						_MouseCommandLoop:
.b386		da		phx		        phx                                 ; save slot.
.b387		20 21 9a	jsr $9a21	        jsr     EvaluateExpressionAt0       ; evaluate a reference.
.b38a		a5 50		lda $50		        lda     NSStatus                    ; check it's a reference.
.b38c		c9 20		cmp #$20	        cmp     #NSBIsReference
.b38e		d0 60		bne $b3f0	        bne     _MouseNotRef
.b390		b1 30		lda ($30),y			lda 	(codePtr),y
.b392		c9 2c		cmp #$2c	        cmp     #KWD_COMMA
.b394		d0 01		bne $b397	        bne     _MouseNoSkipComma
.b396		c8		iny		        iny
.b397						_MouseNoSkipComma:
.b397		fa		plx		        plx                                 ; restore X
.b398		5a		phy		        phy                                 ; save Y
.b399		a5 60		lda $60		        lda     NSMantissa0                 ; copy address to zTemp0
.b39b		85 36		sta $36		        sta     zTemp0
.b39d		a5 70		lda $70		        lda     NSMantissa1
.b39f		85 37		sta $37		        sta     zTemp0+1
.b3a1		a0 04		ldy #$04	        ldy     #4                          ; set exponent, m3, m2 , m1 , m0
.b3a3		a9 00		lda #$00	        lda     #0
.b3a5		91 36		sta ($36),y	        sta     (zTemp0),y                  ; exponent
.b3a7		88		dey		        dey
.b3a8		91 36		sta ($36),y	        sta     (zTemp0),y                  ; m3
.b3aa		88		dey		        dey
.b3ab		91 36		sta ($36),y	        sta     (zTemp0),y                  ; m2
.b3ad		88		dey		        dey
.b3ae		2c 82 06	bit $0682	        bit     CMDMouseFlag                ; mouse or mdelta command
.b3b1		30 12		bmi $b3c5	        bmi     _MouseMouseCommand
.b3b3						_MouseMDeltaCommand:
.b3b3		bd a5 06	lda $06a5,x	        lda     MouseDeltaX,x
.b3b6		92 36		sta ($36)	        sta     (zTemp0)                    ; m0
.b3b8		bd a6 06	lda $06a6,x	        lda     MouseDeltaX+1,x
.b3bb		91 36		sta ($36),y	        sta     (zTemp0),y                  ; m1
.b3bd		9e a5 06	stz $06a5,x	        stz     MouseDeltaX,x               ; clear entry in current table
.b3c0		9e a6 06	stz $06a6,x	        stz     MouseDeltaX+1,x
.b3c3		80 0a		bra $b3cf	        bra     _MouseProcessData
.b3c5						_MouseMouseCommand:
.b3c5		bd b1 06	lda $06b1,x	        lda     MousePosX,x
.b3c8		92 36		sta ($36)	        sta     (zTemp0)                    ; m0
.b3ca		bd b2 06	lda $06b2,x	        lda     MousePosX+1,x
.b3cd		91 36		sta ($36),y	        sta     (zTemp0),y                  ; m1
.b3cf						_MouseProcessData:
.b3cf		b1 36		lda ($36),y	        lda     (zTemp0),y
.b3d1		10 15		bpl $b3e8	        bpl     _MouseDataPos               ; signed 16 bit value, so fix up if -ve.
.b3d3		38		sec		        sec                                 ; negate the mantissa 2 bytes
.b3d4		a9 00		lda #$00	        lda     #0
.b3d6		f2 36		sbc ($36)	        sbc     (zTemp0)
.b3d8		92 36		sta ($36)	        sta     (zTemp0)
.b3da		a9 00		lda #$00	        lda     #0
.b3dc		f1 36		sbc ($36),y	        sbc     (zTemp0),y
.b3de		91 36		sta ($36),y	        sta     (zTemp0),y
.b3e0		a0 03		ldy #$03	        ldy     #3
.b3e2		b1 36		lda ($36),y	        lda     (zTemp0),y                  ; set upper bit of mantissa
.b3e4		09 80		ora #$80	        ora     #$80
.b3e6		91 36		sta ($36),y	        sta     (zTemp0),y
.b3e8						_MouseDataPos:
.b3e8		7a		ply		        ply                                 ; restore Y.
.b3e9		e8		inx		        inx                                 ; next entry
.b3ea		e8		inx		        inx
.b3eb		e0 0c		cpx #$0c	        cpx     #6*2                        ; done 6 reads to variables.
.b3ed		d0 97		bne $b386	        bne     _MouseCommandLoop
.b3ef		60		rts		        rts
.b3f0						_MouseNotRef:
.b3f0		a9 07		lda #$07		lda	#7
.b3f2		4c 19 95	jmp $9519		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/setdatetime.asm

.b3f5						CommandSetDate:
.b3f5		a9 03		lda #$03			lda 	#3
.b3f7		80 02		bra $b3fb			bra 	CSDTMain
.b3f9						CommandSetTime:
.b3f9		a9 00		lda #$00			lda 	#0
.b3fb						CSDTMain:
.b3fb		48		pha				pha 								; save table offsets 0 or 3
.b3fc		a2 00		ldx #$00			ldx 	#0 							; input 3 values.
.b3fe		20 1d a4	jsr $a41d			jsr 	Evaluate8BitInteger
.b401		20 08 95	jsr $9508			jsr 	CheckComma
.b404		e8		inx				inx
.b405		20 1d a4	jsr $a41d			jsr 	Evaluate8BitInteger
.b408		20 08 95	jsr $9508			jsr 	CheckComma
.b40b		e8		inx				inx
.b40c		20 1d a4	jsr $a41d			jsr 	Evaluate8BitInteger
.b40f		68		pla				pla 								; table offset in Y, saving Y
.b410		5a		phy				phy
.b411		a8		tay				tay
.b412		a2 00		ldx #$00			ldx 	#0 							; first number
.b414		a5 01		lda $01				lda 	1 							; save I/O page, switch to zero
.b416		48		pha				pha
.b417		64 01		stz $01				stz 	1
.b419						_CSDTCopy:
.b419		b5 60		lda $60,x			lda 	NSMantissa0,x 				; get first number
.b41b		d9 5d b4	cmp $b45d,y			cmp 	RTCWMinValues,y 			; check range
.b41e		90 1b		bcc $b43b			bcc 	_CSDTRange
.b420		d9 63 b4	cmp $b463,y			cmp 	RTCWMaxValues,y
.b423		b0 16		bcs $b43b			bcs 	_CSDTRange
.b425		20 40 b4	jsr $b440			jsr 	CSDTDecimalToBCD
.b428		da		phx				phx 								; save X
.b429		be 57 b4	ldx $b457,y			ldx 	RTCWOffset,y 				; offset in RTC in X
.b42c		9d 90 d6	sta $d690,x			sta 	$D690,x 					; write to RTC
.b42f		fa		plx				plx 								; restore X
.b430		e8		inx				inx 								; next number
.b431		c8		iny				iny 								; next table entries
.b432		e0 03		cpx #$03			cpx 	#3 							; until done all 3.
.b434		d0 e3		bne $b419			bne 	_CSDTCopy
.b436		68		pla				pla 								; restore I/O space
.b437		85 01		sta $01				sta 	1
.b439		7a		ply				ply 								; restore code pos and exit.
.b43a		60		rts				rts
.b43b						_CSDTRange:
.b43b		a9 04		lda #$04		lda	#4
.b43d		4c 19 95	jmp $9519		jmp	ErrorHandler
.b440						CSDTDecimalToBCD:
.b440		da		phx				phx 								; 10 count in X
.b441		a2 00		ldx #$00			ldx 	#0
.b443						_CSDTDBLoop:
.b443		c9 0a		cmp #$0a			cmp 	#10 						; < 10 evaluate result.
.b445		90 05		bcc $b44c			bcc 	_CSDTDBExit
.b447		e9 0a		sbc #$0a			sbc 	#10 						; 10 from value
.b449		e8		inx				inx 								; one more 10s.
.b44a		80 f7		bra $b443			bra 	_CSDTDBLoop
.b44c						_CSDTDBExit:
.b44c		85 36		sta $36				sta 	zTemp0 						; units
.b44e		8a		txa				txa 								; 10s x 16
.b44f		0a		asl a				asl 	a
.b450		0a		asl a				asl 	a
.b451		0a		asl a				asl 	a
.b452		0a		asl a				asl 	a
.b453		05 36		ora $36				ora 	zTemp0 						; BCD result and exit
.b455		fa		plx				plx
.b456		60		rts				rts
.b457						RTCWOffset:
>b457		04 02 00 06 09 0a				.byte 	4,2,0,6,9,10
.b45d						RTCWMinValues:
>b45d		00 00 00 01 01 00				.byte 	0,0,0,1,1,0
.b463						RTCWMaxValues:
>b463		18 3c 3c 20 0d 64				.byte 	24,60,60,32,13,100

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/timer.asm

.b469						UnaryTimer:
.b469		fa		plx				plx
.b46a		20 00 95	jsr $9500			jsr 	CheckRightBracket
.b46d						TimerToStackX:
.b46d		20 82 a4	jsr $a482			jsr 	NSMSetZero 					; zero result
.b470		64 01		stz $01				stz 	1 							; access I/O
.b472		ad 59 d6	lda $d659			lda 	$D659 						; copy timer in
.b475		95 60		sta $60,x			sta 	NSMantissa0,x
.b477		ad 5a d6	lda $d65a			lda 	$D65A
.b47a		95 70		sta $70,x			sta 	NSMantissa1,x
.b47c		ad 5b d6	lda $d65b			lda 	$D65B
.b47f		95 80		sta $80,x			sta 	NSMantissa2,x
.b481		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/functions/getdatetime.asm

.b482						UnaryGetTime:
.b482		a9 00		lda #$00			lda 	#0
.b484		80 02		bra $b488			bra 	UGDTMain
.b486						UnaryGetDate:
.b486		a9 03		lda #$03			lda 	#3
.b488						UGDTMain:
.b488		fa		plx				plx 								; get stack position back
.b489		48		pha				pha 								; save table offset
.b48a		20 1d a4	jsr $a41d			jsr 	Evaluate8BitInteger			; ignored parameter
.b48d		20 00 95	jsr $9500			jsr 	CheckRightBracket 			; closing )
.b490		68		pla				pla 								; table offset in A
.b491		5a		phy				phy 								; saving Y
.b492		a8		tay				tay 								; table offset in Y
.b493		a9 08		lda #$08			lda 	#8							; allocate space for 8 chars DD:MM:YY
.b495		20 89 b7	jsr $b789			jsr 	StringTempAllocate
.b498		a5 01		lda $01				lda 	1 							; save I/O table and switch to I/O page 0
.b49a		48		pha				pha
.b49b		64 01		stz $01				stz 	1
.b49d		20 b0 b4	jsr $b4b0			jsr 	UGDTDigit 					; do XX:YY:ZZ
.b4a0		20 ab b4	jsr $b4ab			jsr 	UGDTColonDigit
.b4a3		20 ab b4	jsr $b4ab			jsr 	UGDTColonDigit
.b4a6		68		pla				pla 								; restore I/O select
.b4a7		85 01		sta $01				sta 	1
.b4a9		7a		ply				ply  								; restore code position
.b4aa		60		rts				rts
.b4ab						UGDTColonDigit:
.b4ab		a9 3a		lda #$3a			lda 	#':'
.b4ad		20 c2 b7	jsr $b7c2			jsr 	StringTempWrite
.b4b0						UGDTDigit:
.b4b0		da		phx				phx 								; save X
.b4b1		b9 d0 b4	lda $b4d0,y			lda 	RTCROffset,y 				; get offset in RTC register
.b4b4		aa		tax				tax
.b4b5		bd 90 d6	lda $d690,x			lda 	$D690,x 					; read RTC register
.b4b8		39 d6 b4	and $b4d6,y			and 	RTCRMask,y 					; and with Mask.
.b4bb		fa		plx				plx
.b4bc		48		pha				pha 								; output in BCD
.b4bd		4a		lsr a				lsr 	a
.b4be		4a		lsr a				lsr 	a
.b4bf		4a		lsr a				lsr 	a
.b4c0		4a		lsr a				lsr 	a
.b4c1		09 30		ora #$30			ora 	#48
.b4c3		20 c2 b7	jsr $b7c2			jsr 	StringTempWrite
.b4c6		68		pla				pla
.b4c7		29 0f		and #$0f			and 	#15
.b4c9		09 30		ora #$30			ora 	#48
.b4cb		20 c2 b7	jsr $b7c2			jsr 	StringTempWrite
.b4ce		c8		iny				iny
.b4cf		60		rts				rts
.b4d0						RTCROffset:
>b4d0		04 02 00 06 09 0a				.byte 	4,2,0,6,9,10
.b4d6						RTCRMask:
>b4d6		3f 7f 7f 3f 1f 7f				.byte 	$3F,$7F,$7F,$3F,$1F,$7F

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/functions/getinkey.asm

.b4dc						AscGet:
.b4dc		fa		plx				plx 								; restore stack pos
.b4dd						AscGet2:
.b4dd		20 00 95	jsr $9500			jsr 	CheckRightBracket
.b4e0		20 f5 81	jsr $81f5			jsr 	KNLGetSingleCharacter
.b4e3		20 84 a4	jsr $a484			jsr 	NSMSetByte
.b4e6		60		rts				rts
.b4e7						_AGBreak:
.b4e7		a9 01		lda #$01		lda	#1
.b4e9		4c 19 95	jmp $9519		jmp	ErrorHandler
.b4ec						AscInkey:
.b4ec		fa		plx				plx 								; restore stack pos
.b4ed						AscInkey2:
.b4ed		20 00 95	jsr $9500			jsr 	CheckRightBracket
.b4f0		20 d3 81	jsr $81d3			jsr 	KNLGetKeyPressed
.b4f3		20 84 a4	jsr $a484			jsr 	NSMSetByte
.b4f6		60		rts				rts
.b4f7						ChrGet:
.b4f7		fa		plx				plx
.b4f8		20 dd b4	jsr $b4dd			jsr 	AscGet2
.b4fb		4c 02 b5	jmp $b502			jmp 	GetInkeyToString
.b4fe						ChrInkey:
.b4fe		fa		plx				plx
.b4ff		20 ed b4	jsr $b4ed			jsr 	AscInkey2
.b502						GetInkeyToString:
.b502		c9 00		cmp #$00			cmp 	#0 							; if zero, return ""
.b504		f0 0b		beq $b511			beq 	_GKISNull
.b506		48		pha				pha
.b507		a9 01		lda #$01			lda 	#1 							; allocate space for one char
.b509		20 89 b7	jsr $b789			jsr 	StringTempAllocate
.b50c		68		pla				pla 								; write number to it
.b50d		20 c2 b7	jsr $b7c2			jsr 	StringTempWrite
.b510		60		rts				rts
.b511						_GKISNull:
.b511		a9 00		lda #$00			lda 	#0
.b513		20 89 b7	jsr $b789			jsr 	StringTempAllocate
.b516		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/functions/keydown.asm

.b517						KeyDown:
.b517		20 58 81	jsr $8158			jsr 	ProcessEvents 				; process outstanding events.
.b51a		fa		plx				plx 								; restore stack pos
.b51b		20 1d a4	jsr $a41d			jsr 	Evaluate8BitInteger 		; key to check.
.b51e		48		pha				pha 								; check right bracket.
.b51f		20 00 95	jsr $9500			jsr 	CheckRightBracket
.b522		68		pla				pla
.b523		20 2d 84	jsr $842d			jsr 	KeyboardConvertXA 			; get offset and mask.
.b526		3d 83 06	and $0683,x			and 	KeyStatus,x 				; is it zero ?
.b529		f0 03		beq $b52e			beq 	_KeyUp
.b52b		4c 8c 95	jmp $958c			jmp 	ReturnTrue
.b52e		4c 97 95	jmp $9597	_KeyUp:	jmp 	ReturnFalse

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/functions/rnd.asm

.b531						Unary_Random:
.b531		fa		plx				plx
.b532		20 82 b5	jsr $b582			jsr 	URCopyToMantissa  			; put random # in mantissa
.b535		b1 30		lda ($30),y			lda 	(codePtr),y
.b537		c9 29		cmp #$29			cmp 	#KWD_RPAREN
.b539		f0 08		beq $b543			beq 	_URNoModulus 				; then we return a random 30 bit number.
.b53b		e8		inx				inx
.b53c		20 02 a4	jsr $a402			jsr 	Evaluate16BitInteger 		; put modulus value in +1
.b53f		ca		dex				dex
.b540		20 de 96	jsr $96de			jsr 	IntegerModulusNoCheck 		; calculate modulus, so now 0 .. n-1
.b543						_URNoModulus:
.b543		74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer positive
.b545		74 a0		stz $a0,x			stz 	NSExponent,x
.b547		20 00 95	jsr $9500			jsr 	CheckRightBracket
.b54a		60		rts				rts
.b54b						Unary_Rnd:
.b54b		fa		plx				plx
.b54c		20 d0 a3	jsr $a3d0			jsr 	EvaluateNumber 				; number to use.
.b54f		20 00 95	jsr $9500			jsr 	CheckRightBracket 			; closing bracket
.b552		b5 50		lda $50,x			lda 	NSStatus,x 					; if -ve, then seed using parameter
.b554		10 20		bpl $b576			bpl 	_URDontSeed
.b556		a5 01		lda $01				lda 	1 							; switch to page 0
.b558		48		pha				pha
.b559		64 01		stz $01				stz 	1
.b55b		b5 60		lda $60,x			lda 	NSMantissa0,x 				; copy - value to seed butchering it.
.b55d		49 17		eor #$17			eor 	#$17
.b55f		8d a4 d6	sta $d6a4			sta 	$D6A4
.b562		b5 70		lda $70,x			lda 	NSMantissa1,x
.b564		49 a5		eor #$a5			eor 	#$A5
.b566		8d a5 d6	sta $d6a5			sta 	$D6A5
.b569		a9 03		lda #$03			lda 	#3 							; set bit 1 high/low to set seed.
.b56b		8d a6 d6	sta $d6a6			sta 	$D6A6
.b56e		a9 01		lda #$01			lda 	#1
.b570		8d a6 d6	sta $d6a6			sta 	$D6A6
.b573		68		pla				pla
.b574		85 01		sta $01				sta 	1
.b576						_URDontSeed:
.b576		20 82 b5	jsr $b582			jsr 	URCopyToMantissa 			; copy into mantissa
.b579		a9 e2		lda #$e2			lda 	#-30 						; force into 0-1 range
.b57b		95 a0		sta $a0,x			sta 	NSExponent,x
.b57d		a9 08		lda #$08			lda 	#NSTFloat
.b57f		95 50		sta $50,x			sta 	NSStatus,x 					; positive float
.b581		60		rts				rts
.b582						URCopyToMantissa:
.b582		a5 01		lda $01				lda 	1 							; switch to I/O page 1
.b584		48		pha				pha
.b585		64 01		stz $01				stz 	1
.b587		a9 01		lda #$01			lda 	#1
.b589		8d a6 d6	sta $d6a6			sta 	$D6A6 						; enable LFSR
.b58c		ad a4 d6	lda $d6a4			lda 	$D6A4
.b58f		95 60		sta $60,x			sta 	NSMantissa0,x
.b591		ad a5 d6	lda $d6a5			lda 	$D6A5
.b594		95 70		sta $70,x			sta 	NSMantissa1,x
.b596		ad a4 d6	lda $d6a4			lda 	$D6A4
.b599		95 80		sta $80,x			sta 	NSMantissa2,x
.b59b		ad a5 d6	lda $d6a5			lda 	$D6A5
.b59e		29 3f		and #$3f			and 	#$3F 						; make legal mantissa
.b5a0		95 90		sta $90,x			sta 	NSMantissa3,x
.b5a2		68		pla				pla
.b5a3		85 01		sta $01				sta 	1
.b5a5		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/sound/effects.asm

.b5a6						PingCommand:
.b5a6		5a		phy				phy 								; save pos
.b5a7		a9 01		lda #$01			lda 	#1 						; push channel.
.b5a9		48		pha				pha
.b5aa		a9 c8		lda #$c8			lda 	#200 						; pitch LSB
.b5ac		a2 06		ldx #$06			ldx 	#6 						; length
.b5ae		a0 00		ldy #$00			ldy 	#0 						; slide LSB
.b5b0		80 24		bra $b5d6			bra 	SoundEffectCommand
.b5b2						ZapCommand:
.b5b2		5a		phy				phy 								; save pos
.b5b3		a9 01		lda #$01			lda 	#1 						; push channel.
.b5b5		48		pha				pha
.b5b6		a9 ff		lda #$ff			lda 	#255 						; pitch LSB
.b5b8		a2 0a		ldx #$0a			ldx 	#10 						; length
.b5ba		a0 0a		ldy #$0a			ldy 	#10 						; slide LSB
.b5bc		80 18		bra $b5d6			bra 	SoundEffectCommand
.b5be						ShootCommand:
.b5be		5a		phy				phy 								; save pos
.b5bf		a9 03		lda #$03			lda 	#3 						; push channel.
.b5c1		48		pha				pha
.b5c2		a9 20		lda #$20			lda 	#32 						; pitch LSB
.b5c4		a2 04		ldx #$04			ldx 	#4 						; length
.b5c6		a0 00		ldy #$00			ldy 	#0 						; slide LSB
.b5c8		80 0c		bra $b5d6			bra 	SoundEffectCommand
.b5ca						Explode:
.b5ca		5a		phy				phy 								; save pos
.b5cb		a9 03		lda #$03			lda 	#3 						; push channel.
.b5cd		48		pha				pha
.b5ce		a9 50		lda #$50			lda 	#80 						; pitch LSB
.b5d0		a2 0a		ldx #$0a			ldx 	#10 						; length
.b5d2		a0 00		ldy #$00			ldy 	#0 						; slide LSB
.b5d4		80 00		bra $b5d6			bra 	SoundEffectCommand
.b5d6						SoundEffectCommand:
.b5d6		8d e4 07	sta $07e4			sta 	SoundCommandBlock 			; set up the command block in sound.asm
.b5d9		9c e5 07	stz $07e5			stz 	SoundCommandBlock+1
.b5dc		a9 0f		lda #$0f			lda 	#15
.b5de		8d e6 07	sta $07e6			sta 	SoundCommandBlock+2
.b5e1		8e e7 07	stx $07e7			stx 	SoundCommandBlock+3
.b5e4		8c e8 07	sty $07e8			sty 	SoundCommandBlock+4
.b5e7		9c e9 07	stz $07e9			stz 	SoundCommandBlock+5
.b5ea		68		pla				pla
.b5eb		09 10		ora #$10			ora 	#$10  						; execute command $11
.b5ed		a2 e4		ldx #$e4			ldx 	#(SoundCommandBlock & $FF)
.b5ef		a0 07		ldy #$07			ldy 	#(SoundCommandBlock >> 8)
.b5f1		20 6b 80	jsr $806b			jsr 	SNDCommand
.b5f4		7a		ply				ply
.b5f5		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/sound/playing.asm

.b5f6						UnaryPlaying:
.b5f6		fa		plx				plx
.b5f7		20 1d a4	jsr $a41d			jsr 	Evaluate8BitInteger 		; get channel #
.b5fa		48		pha				pha
.b5fb		20 00 95	jsr $9500			jsr		CheckRightBracket
.b5fe		68		pla				pla
.b5ff		c9 04		cmp #$04			cmp 	#4
.b601		b0 0c		bcs $b60f			bcs 	_UPNotPlaying
.b603		09 20		ora #$20			ora 	#$20 						; query playing ?
.b605		20 6b 80	jsr $806b			jsr 	SNDCommand
.b608		c9 00		cmp #$00			cmp 	#0
.b60a		f0 03		beq $b60f			beq 	_UPNotPlaying
.b60c		4c 8c 95	jmp $958c			jmp 	ReturnTrue
.b60f						_UPNotPlaying:
.b60f		4c 97 95	jmp $9597			jmp 	ReturnFalse

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/sound/sound.asm

.b612						SoundCommand:
.b612		b1 30		lda ($30),y			lda 	(codePtr),y
.b614		c9 cc		cmp #$cc			cmp 	#KWD_OFF 					; SOUND OFF ?
.b616		d0 09		bne $b621			bne 	_SNDMain
.b618		c8		iny				iny 								; skip OFF
.b619		a9 3f		lda #$3f			lda 	#$3F 						; call command $3F (silence)
.b61b		5a		phy				phy
.b61c		20 6b 80	jsr $806b			jsr 	SNDCommand
.b61f		7a		ply				ply
.b620		60		rts				rts
.b621						_SNDMain:
.b621		a2 00		ldx #$00			ldx 	#0
.b623		20 1d a4	jsr $a41d			jsr 	Evaluate8BitInteger 		; channel
.b626		c9 04		cmp #$04			cmp 	#4 							; must be 0-3
.b628		b0 4b		bcs $b675			bcs 	_SndError
.b62a		e8		inx				inx 								; do the rest in slot 1.
.b62b		20 08 95	jsr $9508			jsr 	CheckComma
.b62e		20 02 a4	jsr $a402			jsr 	Evaluate16BitInteger 		; Pitch
.b631		b5 70		lda $70,x			lda 	NSMantissa1,x 				; must be 10 bit
.b633		c9 10		cmp #$10			cmp 	#16
.b635		b0 3e		bcs $b675			bcs 	_SndError
.b637		8d e5 07	sta $07e5			sta 	SoundCommandBlock+1 		; Pitch (2 bytes + 0)
.b63a		b5 60		lda $60,x			lda 	NSMantissa0,x
.b63c		8d e4 07	sta $07e4			sta 	SoundCommandBlock
.b63f		20 08 95	jsr $9508			jsr 	CheckComma
.b642		20 1d a4	jsr $a41d			jsr 	Evaluate8BitInteger 		; Length (1 byte + 3)
.b645		8d e7 07	sta $07e7			sta 	SoundCommandBlock+3
.b648		a9 0f		lda #$0f			lda 	#15
.b64a		8d e6 07	sta $07e6			sta 	SoundCommandBlock+2 		; Volume (1 byte + 2)
.b64d		9c e8 07	stz $07e8			stz 	SoundCommandBlock+4 		; default slide (2 bytes +4)
.b650		9c e9 07	stz $07e9			stz 	SoundCommandBlock+5
.b653		b1 30		lda ($30),y			lda 	(codePtr),y
.b655		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.b657		d0 0e		bne $b667			bne 	_SNDPlay
.b659		c8		iny				iny
.b65a		20 0c a4	jsr $a40c			jsr 	Evaluate16BitIntegerSigned 	; Slide
.b65d		b5 60		lda $60,x			lda 	NSMantissa0,x 				; Slide (2 bytes + 4)
.b65f		8d e8 07	sta $07e8			sta 	SoundCommandBlock+4
.b662		b5 70		lda $70,x			lda 	NSMantissa1,x
.b664		8d e9 07	sta $07e9			sta 	SoundCommandBlock+5
.b667						_SNDPlay:
.b667		5a		phy				phy
.b668		a5 60		lda $60				lda 	NSMantissa0 				; channel.
.b66a		09 10		ora #$10			ora 	#$10 						; 1x = Queue sound
.b66c		a2 e4		ldx #$e4			ldx 	#(SoundCommandBlock & $FF)
.b66e		a0 07		ldy #$07			ldy 	#(SoundCommandBlock >> 8)
.b670		20 6b 80	jsr $806b			jsr 	SNDCommand
.b673		7a		ply				ply
.b674		60		rts				rts
.b675						_SndError:
.b675		4c ff a5	jmp $a5ff			jmp 	RangeError
.07e4						SoundCommandBlock:
>07e4								.fill 	6

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/bytes.asm

.b678						StackPushByte:
.b678		48		pha				pha 								; save byte on stack
.b679		a5 34		lda $34				lda 	basicStack 					; decrement basic stack pointer
.b67b		d0 08		bne $b685			bne 	_SPBNoBorrow
.b67d		c6 35		dec $35				dec 	basicStack+1 				; borrow
.b67f		a5 35		lda $35				lda 	basicStack+1 				; check range.
.b681		c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.b683		90 06		bcc $b68b			bcc 	_SPBMemory
.b685						_SPBNoBorrow:
.b685		c6 34		dec $34				dec 	basicStack
.b687		68		pla				pla 								; get back and write
.b688		92 34		sta ($34)			sta 	(basicStack)
.b68a		60		rts				rts
.b68b						_SPBMemory:
.b68b		a9 12		lda #$12		lda	#18
.b68d		4c 19 95	jmp $9519		jmp	ErrorHandler
.b690						StackPopByte:
.b690		b2 34		lda ($34)			lda 	(basicStack) 				; bump the stack pointer.
.b692		e6 34		inc $34				inc 	basicStack
.b694		d0 02		bne $b698			bne 	_SPBNoCarry
.b696		e6 35		inc $35				inc 	basicStack+1
.b698						_SPBNoCarry:
.b698		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/frames.asm

.b699						StackOpen:
.b699		48		pha				pha 								; save frame byte
.b69a		29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.b69c		0a		asl a				asl 	a 							; claim twice this for storage
.b69d		49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.b69f		38		sec				sec 								; so basically subtracting from
.b6a0		65 34		adc $34				adc 	basicStack 	 				; basicStack
.b6a2		85 34		sta $34				sta 	basicStack
.b6a4		b0 09		bcs $b6af			bcs 	_SONoBorrow
>b6a6		db						.byte 	$DB 						; causes a break in the emulator
.b6a7		c6 35		dec $35				dec 	basicStack+1
.b6a9		a5 35		lda $35				lda 	basicStack+1 				; have we reached stack overflow
.b6ab		c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.b6ad		90 04		bcc $b6b3			bcc 	_SOMemory
.b6af						_SONoBorrow:
.b6af		68		pla				pla 								; get marker back and write at TOS
.b6b0		92 34		sta ($34)			sta 	(basicStack)
.b6b2		60		rts				rts
.b6b3						_SOMemory:
.b6b3		a9 12		lda #$12		lda	#18
.b6b5		4c 19 95	jmp $9519		jmp	ErrorHandler
.b6b8						StackClose:
.b6b8		b2 34		lda ($34)			lda 	(basicStack) 				; get TOS marker
.b6ba		29 0f		and #$0f			and 	#$0F 						; bytes to add back
.b6bc		0a		asl a				asl 	a 							; claim twice this.
.b6bd		65 34		adc $34				adc 	basicStack 					; add to the stack pointer.
.b6bf		85 34		sta $34				sta 	basicStack
.b6c1		90 02		bcc $b6c5			bcc 	_SCExit
.b6c3		e6 35		inc $35				inc 	basicStack+1
.b6c5						_SCExit:
.b6c5		60		rts				rts
.b6c6						StackCheckFrame:
.b6c6		48		pha				pha
.b6c7						_StackRemoveLocals:
.b6c7		b2 34		lda ($34)			lda 	(basicStack) 				; check for local, keep popping them
.b6c9		c9 03		cmp #$03			cmp 	#STK_LOCALS+1 				; is the frame a local ? S or N are 1/0
.b6cb		b0 05		bcs $b6d2			bcs 	_SCNoLocal
.b6cd		20 ed 8e	jsr $8eed			jsr 	LocalPopValue 				; restore the local value
.b6d0		80 f5		bra $b6c7			bra 	_StackRemoveLocals 			; gr round again
.b6d2						_SCNoLocal:
.b6d2		68		pla				pla 								; get the frame check.
.b6d3		52 34		eor ($34)			eor 	(basicStack) 				; xor with toS marker
.b6d5		29 f0		and #$f0			and 	#$F0 						; check type bits
.b6d7		d0 01		bne $b6da			bne 	_SCFError 					; different, we have structures mixed up
.b6d9		60		rts				rts
.b6da						_SCFError:
.b6da		8a		txa				txa 								; report error X
.b6db		4c 19 95	jmp $9519			jmp 	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/location.asm

.b6de						STKSaveCodePosition:
.b6de		5a		phy				phy
.b6df		98		tya				tya 								; save Y
.b6e0		a0 05		ldy #$05			ldy 	#5
.b6e2		91 34		sta ($34),y			sta 	(basicStack),y
.b6e4		88		dey				dey 								; save Code Pointer
.b6e5						_STKSaveLoop:
.b6e5		b9 2f 00	lda $002f,y			lda 	safePtr-1,y 				; allows us to access the pointer w/out issues.
.b6e8		91 34		sta ($34),y			sta 	(basicStack),y
.b6ea		88		dey				dey
.b6eb		d0 f8		bne $b6e5			bne 	_STKSaveLoop
.b6ed		7a		ply				ply
.b6ee		60		rts				rts
.b6ef						STKLoadCodePosition:
.b6ef		a0 01		ldy #$01			ldy 	#1 							; load code pointer back
.b6f1						_STKLoadLoop:
.b6f1		b1 34		lda ($34),y			lda 	(basicStack),y
.b6f3		99 2f 00	sta $002f,y			sta 	safePtr-1,y
.b6f6		c8		iny				iny
.b6f7		c0 05		cpy #$05			cpy 	#5
.b6f9		d0 f6		bne $b6f1			bne 	_STKLoadLoop
.b6fb		b1 34		lda ($34),y			lda 	(basicStack),y 				; get Y offset
.b6fd		a8		tay				tay
.b6fe		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/setup.asm

.b6ff						StackReset:
.b6ff		a9 ff		lda #$ff			lda 	#((BasicStackBase+BasicStackSize-1) & $FF)
.b701		85 34		sta $34				sta 	0+basicStack
.b703		a9 0f		lda #$0f			lda 	#((BasicStackBase+BasicStackSize-1) >> 8)
.b705		85 35		sta $35				sta 	1+basicStack
.b707		a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.b709		92 34		sta ($34)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.b70b		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/concrete.asm

.b70c						StringConcrete:
.b70c		5a		phy				phy 								; save position on stack
.b70d		20 62 a0	jsr $a062			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.b710		b5 60		lda $60,x			lda 	NSMantissa0,x 				; copy target string to zTemp1
.b712		85 38		sta $38				sta 	zTemp1
.b714		b5 70		lda $70,x			lda 	NSMantissa1,x
.b716		85 39		sta $39				sta 	zTemp1+1
.b718		a0 ff		ldy #$ff			ldy 	#$FF	 					; calculate string length
.b71a						_SALength:
.b71a		c8		iny				iny
.b71b		b1 38		lda ($38),y			lda 	(zTemp1),y
.b71d		d0 fb		bne $b71a			bne 	_SALength
.b71f		c0 fd		cpy #$fd			cpy 	#253 						; string too long - cannot concrete.
.b721		b0 3d		bcs $b760			bcs 	_SALengthError
.b723		98		tya				tya 				 				; length of the new string
.b724		18		clc				clc
.b725		69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.b727		90 02		bcc $b72b			bcc 	_SAHaveLength
.b729		a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.b72b						_SAHaveLength:
.b72b		48		pha				pha 								; save length.
.b72c		38		sec				sec
.b72d		49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.b72f		6d 2a 04	adc $042a			adc 	stringMemory
.b732		8d 2a 04	sta $042a			sta 	stringMemory
.b735		85 3a		sta $3a				sta 	zTemp2 						; update storage address
.b737		95 60		sta $60,x			sta 	NSMantissa0,x 				; update mantissa address
.b739		a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.b73b		6d 2b 04	adc $042b			adc 	stringMemory+1
.b73e		8d 2b 04	sta $042b			sta 	stringMemory+1
.b741		85 3b		sta $3b				sta 	zTemp2+1
.b743		95 70		sta $70,x			sta 	NSMantissa1,x
.b745		68		pla				pla 								; save length-3 (chars allowed) in first byte
.b746		38		sec				sec
.b747		e9 03		sbc #$03			sbc 	#3
.b749		92 3a		sta ($3a)			sta 	(zTemp2)
.b74b		a9 00		lda #$00			lda 	#0 							; clear the status byte.
.b74d		a0 01		ldy #$01			ldy 	#1
.b74f		91 3a		sta ($3a),y			sta 	(zTemp2),y
.b751						_SACopyNewString:
.b751		a0 00		ldy #$00			ldy 	#0
.b753						_SACopyNSLoop:
.b753		b1 38		lda ($38),y			lda 	(zTemp1),y 					; get character
.b755		c8		iny				iny 								; write two on in string storage
.b756		c8		iny				iny
.b757		91 3a		sta ($3a),y			sta 	(zTemp2),y
.b759		88		dey				dey 								; this makes it one one.
.b75a		c9 00		cmp #$00			cmp 	#0 							; until EOS copied
.b75c		d0 f5		bne $b753			bne 	_SACopyNSLoop
.b75e		7a		ply				ply
.b75f		60		rts				rts
.b760						_SALengthError:
.b760		a9 09		lda #$09		lda	#9
.b762		4c 19 95	jmp $9519		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/stringalloc.asm

.b765						StringSystemInitialise:
.b765		a9 ff		lda #$ff			lda 	#((EndVariableSpace-1) & $FF)
.b767		8d 2a 04	sta $042a			sta 	0+stringMemory
.b76a		a9 1f		lda #$1f			lda 	#((EndVariableSpace-1) >> 8)
.b76c		8d 2b 04	sta $042b			sta 	1+stringMemory
.b76f		9c ff 1f	stz $1fff			stz 	EndVariableSpace-1 			; put a zero at the end, so know end of string memory.
.b772		60		rts				rts
.b773						StringSpaceInitialise:
.b773		20 62 a0	jsr $a062			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.b776		a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.b778		8d 2c 04	sta $042c			sta 	stringInitialised
.b77b		ad 2a 04	lda $042a			lda 	stringMemory 				; allocate 256 bytes for one concreted string
.b77e		8d 2d 04	sta $042d			sta 	stringTempPointer 			; so temporary string space is allocated below that.
.b781		ad 2b 04	lda $042b			lda 	stringMemory+1
.b784		3a		dec a				dec 	a
.b785		8d 2e 04	sta $042e			sta 	stringTempPointer+1
.b788		60		rts				rts
.b789						StringTempAllocate:
.b789		c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.b78b		b0 30		bcs $b7bd			bcs 	_STALength
.b78d		2c 2c 04	bit $042c			bit 	stringInitialised 			; already initialised
.b790		30 05		bmi $b797			bmi 	_STAAllocate
.b792		48		pha				pha 								; save value to subtract.
.b793		20 73 b7	jsr $b773			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.b796		68		pla				pla 								; restore it
.b797						_STAAllocate:
.b797		49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.b799		18		clc				clc  								; deliberate allows one more
.b79a		6d 2d 04	adc $042d			adc 	stringTempPointer 			; subtract from temp pointer
.b79d		8d 2d 04	sta $042d			sta 	stringTempPointer
.b7a0		95 60		sta $60,x			sta 	NSMantissa0,x 				; address in mantissa
.b7a2		85 3c		sta $3c				sta 	zsTemp 						; and zsTemp
.b7a4		ad 2e 04	lda $042e			lda 	stringTempPointer+1
.b7a7		69 ff		adc #$ff			adc 	#$FF
.b7a9		8d 2e 04	sta $042e			sta 	stringTempPointer+1
.b7ac		85 3d		sta $3d				sta 	zsTemp+1
.b7ae		95 70		sta $70,x			sta 	NSMantissa1,x
.b7b0		74 80		stz $80,x			stz 	NSMantissa2,x 				; set the typing data and the upper address bytes.
.b7b2		74 90		stz $90,x			stz 	NSMantissa3,x
.b7b4		a9 10		lda #$10			lda 	#NSTString
.b7b6		95 50		sta $50,x			sta 	NSStatus,x
.b7b8		a9 00		lda #$00			lda 	#0 							; clear the target string
.b7ba		92 3c		sta ($3c)			sta 	(zsTemp)
.b7bc		60		rts				rts
.b7bd						_STALength:
.b7bd		a9 09		lda #$09		lda	#9
.b7bf		4c 19 95	jmp $9519		jmp	ErrorHandler
.b7c2						StringTempWrite:
.b7c2		48		pha				pha
.b7c3		92 3c		sta ($3c)			sta 	(zsTemp) 					; write byte
.b7c5		e6 3c		inc $3c				inc 	zsTemp 						; bump pointer
.b7c7		d0 02		bne $b7cb			bne 	_STWNoCarry
.b7c9		e6 3d		inc $3d				inc 	zsTemp+1
.b7cb						_STWNoCarry:
.b7cb		a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.b7cd		92 3c		sta ($3c)			sta 	(zsTemp)
.b7cf		68		pla				pla
.b7d0		60		rts				rts

;******  Return to file: _basic.asm

.b7d1						StartModuleCode:

;******  Processing file: ../modules/.build/hardware.module.asm

=1						hardwareIntegrated=1
=0						CONBlack = 0
=1						CONGrey = 1
=2						CONDarkBlue = 2
=3						CONGreen = 3
=4						CONPurple = 4
=5						CONBrown = 5
=6						CONOrange = 6
=7						CONCyan = 7
=8						CONDarkGrey = 8
=9						CONLightGrey = 9
=10						CONLightBlue = 10
=11						CONLightGreen = 11
=12						CONPink = 12
=13						CONRed = 13
=14						CONYellow = 14
=15						CONWhite = 15
=9						CONForeground = CONLightGrey
=2						CONBackground = CONDarkBlue
=9						CLICommandLine = CONLightGrey
.c000	a000					Export_EXTPrintNoControl:
.c000	a000	48		pha				pha
.c001	a001	da		phx				phx
.c002	a002	5a		phy				phy
.c003	a003	a6 01		ldx $01				ldx 	1
.c005	a005	da		phx				phx
.c006	a006	ac eb 07	ldy $07eb			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.c009	a009	80 11		bra $a01c			bra 	PrintCharacterOnly
.c00b	a00b					Export_EXTPrintCharacter:
.c00b	a00b					PAGEDPrintCharacter:
.c00b	a00b	48		pha				pha
.c00c	a00c	da		phx				phx
.c00d	a00d	5a		phy				phy
.c00e	a00e	a6 01		ldx $01				ldx 	1
.c010	a010	da		phx				phx
.c011	a011	ac eb 07	ldy $07eb			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.c014	a014	09 00		ora #$00			ora 	#$00 						; check $80-$FF
.c016	a016	30 48		bmi $a060			bmi 	EXPCColour
.c018	a018	c9 20		cmp #$20			cmp 	#$20 						; check $00-$1F
.c01a	a01a	90 4d		bcc $a069			bcc 	EXPCControl
.c01c	a01c					PrintCharacterOnly:
.c01c	a01c	a2 02		ldx #$02			ldx 	#2 							; select char memory
.c01e	a01e	86 01		stx $01				stx 	1
.c020	a020	91 40		sta ($40),y			sta 	(EXTAddress),y
.c022	a022	e6 01		inc $01				inc 	1 							; select colour memory
.c024	a024	ad ec 07	lda $07ec			lda 	EXTTextColour
.c027	a027	91 40		sta ($40),y			sta 	(EXTAddress),y
.c029	a029	c8		iny				iny 								; advance horizontal position
.c02a	a02a	8c eb 07	sty $07eb			sty 	EXTColumn
.c02d	a02d	cc ed 07	cpy $07ed			cpy 	EXTScreenWidth 				; reached RHS ?
.c030	a030	90 63		bcc $a095			bcc 	EXPCExit 					; no, then exit.
.c032	a032					EXPCCRLF:
.c032	a032	ee ea 07	inc $07ea			inc 	EXTRow  					; bump row
.c035	a035	9c eb 07	stz $07eb			stz 	EXTColumn 					; back to column 0
.c038	a038	ad ea 07	lda $07ea			lda 	EXTRow 						; check if reached the bottom ?
.c03b	a03b	cd ee 07	cmp $07ee			cmp 	EXTScreenHeight 			; if so, then scroll.
.c03e	a03e	f0 18		beq $a058			beq 	EXPCScroll
.c040	a040	18		clc				clc 								; add width to address.
.c041	a041	a5 40		lda $40				lda 	EXTAddress
.c043	a043	6d ed 07	adc $07ed			adc 	EXTScreenWidth
.c046	a046	85 40		sta $40				sta 	EXTAddress
.c048	a048	90 4b		bcc $a095			bcc 	EXPCExit
.c04a	a04a	e6 41		inc $41				inc 	EXTAddress+1
.c04c	a04c	80 47		bra $a095			bra 	EXPCExit
.c04e	a04e					EXPCLeft:
.c04e	a04e	ce eb 07	dec $07eb			dec 	EXTColumn
.c051	a051	10 42		bpl $a095			bpl 	EXPCExit
.c053	a053					EXPCBegin:
.c053	a053	9c eb 07	stz $07eb			stz 	EXTColumn
.c056	a056	80 3d		bra $a095			bra 	EXPCExit
.c058	a058					EXPCScroll:
.c058	a058	ce ea 07	dec $07ea			dec 	EXTRow 						; the height-1 th line.
.c05b	a05b	20 47 a1	jsr $a147			jsr 	EXTScreenScroll 			; scroll the screen
.c05e	a05e	80 35		bra $a095			bra 	EXPCExit
.c060	a060					EXPCColour:
.c060	a060	c9 a0		cmp #$a0			cmp 	#$A0						; 80-9F set foreground/background
.c062	a062	b0 31		bcs $a095			bcs 	EXPCExit
.c064	a064	20 27 a1	jsr $a127			jsr 	EXPCHandleColour
.c067	a067	80 2c		bra $a095			bra 	EXPCExit
.c069	a069					EXPCControl:
.c069	a069	c9 11		cmp #$11			cmp 	#$11 						; only handle 00-10.
.c06b	a06b	b0 28		bcs $a095			bcs 	EXPCExit
.c06d	a06d	0a		asl a				asl 	a 							; double into X
.c06e	a06e	aa		tax				tax
.c06f	a06f	7c 05 a1	jmp ($a105,x)			jmp 	(EXPCActionTable,x) 		; and execute code.
.c072	a072					EXPCUp:
.c072	a072	ad ea 07	lda $07ea			lda 	EXTRow 						; already at top ?
.c075	a075	f0 1e		beq $a095			beq 	EXPCExit
.c077	a077	ce ea 07	dec $07ea			dec 	EXTRow 						; up one in position/address
.c07a	a07a	38		sec				sec
.c07b	a07b	a5 40		lda $40				lda 	EXTAddress
.c07d	a07d	ed ed 07	sbc $07ed			sbc 	EXTScreenWidth
.c080	a080	85 40		sta $40				sta 	EXTAddress
.c082	a082	b0 11		bcs $a095			bcs 	EXPCExit
.c084	a084	c6 41		dec $41				dec 	EXTAddress+1
.c086	a086	80 0d		bra $a095			bra 	EXPCExit
.c088	a088					EXPCRight:
.c088	a088	c8		iny				iny
.c089	a089	8c eb 07	sty $07eb			sty 	EXTColumn
.c08c	a08c	cc ed 07	cpy $07ed			cpy 	EXTScreenWidth
.c08f	a08f	d0 04		bne $a095			bne 	EXPCExit
.c091	a091	88		dey				dey
.c092	a092					EXPCSetColumnY:
.c092	a092	8c eb 07	sty $07eb			sty 	EXTColumn
.c095	a095					EXPCExit:
.c095	a095	20 bc a1	jsr $a1bc			jsr 	EXTSetHardwareCursor 		; place the physical cursor.
.c098	a098	68		pla				pla
.c099	a099	85 01		sta $01				sta 	1
.c09b	a09b	7a		ply				ply
.c09c	a09c	fa		plx				plx
.c09d	a09d	68		pla				pla
.c09e	a09e	60		rts				rts
.c09f	a09f					EXPCClearScreen:
.c09f	a09f	20 79 a1	jsr $a179			jsr		EXTClearScreenCode
.c0a2	a0a2	80 f1		bra $a095			bra 	EXPCExit
.c0a4	a0a4					EXPCDown:
.c0a4	a0a4	ad ee 07	lda $07ee			lda 	EXTScreenHeight 			; at the bottom
.c0a7	a0a7	3a		dec a				dec 	a
.c0a8	a0a8	cd ea 07	cmp $07ea			cmp 	EXTRow
.c0ab	a0ab	f0 e8		beq $a095			beq 	EXPCExit
.c0ad	a0ad	ee ea 07	inc $07ea			inc 	EXTRow 						; down one in position/address
.c0b0	a0b0	18		clc				clc
.c0b1	a0b1	a5 40		lda $40				lda 	EXTAddress
.c0b3	a0b3	6d ed 07	adc $07ed			adc 	EXTScreenWidth
.c0b6	a0b6	85 40		sta $40				sta 	EXTAddress
.c0b8	a0b8	90 db		bcc $a095			bcc 	EXPCExit
.c0ba	a0ba	e6 41		inc $41				inc 	EXTAddress+1
.c0bc	a0bc	80 d7		bra $a095			bra 	EXPCExit
.c0be	a0be					EXPCTab:
.c0be	a0be	ad eb 07	lda $07eb			lda 	EXTColumn 					; next tab stop
.c0c1	a0c1	29 f8		and #$f8			and 	#$F8
.c0c3	a0c3	18		clc				clc
.c0c4	a0c4	69 08		adc #$08			adc 	#8
.c0c6	a0c6	8d eb 07	sta $07eb			sta 	EXTColumn
.c0c9	a0c9	cd ed 07	cmp $07ed			cmp 	EXTScreenWidth 				; too far, new line.
.c0cc	a0cc	90 c7		bcc $a095			bcc 	EXPCExit
.c0ce	a0ce	4c 32 a0	jmp $a032			jmp 	EXPCCRLF
.c0d1	a0d1					EXPCBackSpace:
.c0d1	a0d1	88		dey				dey
.c0d2	a0d2	30 c1		bmi $a095			bmi 	EXPCExit
.c0d4	a0d4	ce eb 07	dec $07eb			dec 	EXTColumn
.c0d7	a0d7	a9 02		lda #$02			lda 	#2
.c0d9	a0d9	85 01		sta $01				sta 	1
.c0db	a0db	a9 20		lda #$20			lda 	#32
.c0dd	a0dd	91 40		sta ($40),y			sta 	(EXTAddress),y
.c0df	a0df	80 b4		bra $a095			bra 	EXPCExit
.c0e1	a0e1					EXPCEnd:
.c0e1	a0e1	a9 02		lda #$02			lda 	#2 							; access text screen
.c0e3	a0e3	85 01		sta $01				sta 	1
.c0e5	a0e5	ac ed 07	ldy $07ed			ldy 	EXTScreenWidth 				; point to last character
.c0e8	a0e8	88		dey				dey
.c0e9	a0e9					EXPCEndSearch:
.c0e9	a0e9	88		dey				dey 								; if past start, move to col 0.
.c0ea	a0ea	30 06		bmi $a0f2			bmi 	EXPCFound
.c0ec	a0ec	b1 40		lda ($40),y			lda 	(EXTAddress),y 				; keep going back till non space found
.c0ee	a0ee	c9 20		cmp #$20			cmp 	#' '
.c0f0	a0f0	f0 f7		beq $a0e9			beq 	EXPCEndSearch
.c0f2	a0f2					EXPCFound:
.c0f2	a0f2	c8		iny				iny 								; move to following cell.
.c0f3	a0f3	80 9d		bra $a092			bra 	EXPCSetColumnY
.c0f5	a0f5					EXPCClearEOL:
.c0f5	a0f5	a9 02		lda #$02			lda 	#2 							; access character RAM
.c0f7	a0f7	85 01		sta $01				sta 	1
.c0f9	a0f9	a9 20		lda #$20			lda 	#' ' 						; write space
.c0fb	a0fb	91 40		sta ($40),y			sta 	(EXTAddress),y
.c0fd	a0fd	c8		iny				iny
.c0fe	a0fe	cc ed 07	cpy $07ed			cpy 	EXTScreenWidth 				; until RHS of screen.
.c101	a101	90 f2		bcc $a0f5			bcc 	EXPCClearEOL
.c103	a103	80 90		bra $a095			bra 	EXPCExit
.c105	a105					EXPCActionTable:
>c105	a105	95 a0						.word 	EXPCExit 					; 00
>c107	a107	53 a0						.word 	EXPCBegin 					; 01 A Start of Line
>c109	a109	4e a0						.word 	EXPCLeft 					; 02 B Left
>c10b	a10b	95 a0						.word 	EXPCExit 					; 03 <Break>
>c10d	a10d	95 a0						.word 	EXPCExit 					; 04
>c10f	a10f	e1 a0						.word 	EXPCEnd 					; 05 E End of Line
>c111	a111	88 a0						.word 	EXPCRight 					; 06 F Right
>c113	a113	95 a0						.word 	EXPCExit 					; 07
>c115	a115	d1 a0						.word 	EXPCBackSpace 				; 08 H Backspace
>c117	a117	be a0						.word 	EXPCTab 					; 09 I Tab
>c119	a119	95 a0						.word 	EXPCExit 					; 0A
>c11b	a11b	f5 a0						.word 	EXPCClearEOL 				; 0B K Clear to EOL
>c11d	a11d	9f a0						.word 	EXPCClearScreen			; 0C L CLS
>c11f	a11f	32 a0						.word 	EXPCCRLF 					; 0D M CR/LF
>c121	a121	a4 a0						.word 	EXPCDown 					; 0E N Down
>c123	a123	95 a0						.word 	EXPCExit 					; 0F
>c125	a125	72 a0						.word 	EXPCUp 					; 10 P Up
.c127	a127					EXPCHandleColour:
.c127	a127	c9 90		cmp #$90			cmp 	#$90 						; 8x foreground 9x background
.c129	a129	b0 16		bcs $a141			bcs 	EXPCBackground
.c12b	a12b	0a		asl a				asl 	a 							; shift it 4 bits to the right.
.c12c	a12c	0a		asl a				asl 	a
.c12d	a12d	0a		asl a				asl 	a
.c12e	a12e	0a		asl a				asl 	a
.c12f	a12f	a2 0f		ldx #$0f			ldx 	#$0F 						; Mask in X
.c131	a131					EXPCUpdate:
.c131	a131	48		pha				pha 								; save new colour
.c132	a132	8a		txa				txa 								; get mask
.c133	a133	2d ec 07	and $07ec			and 	EXTTextColour 				; mask out old.
.c136	a136	8d ec 07	sta $07ec			sta 	EXTTextColour
.c139	a139	68		pla				pla 								; or in new colour
.c13a	a13a	0d ec 07	ora $07ec			ora 	EXTTextColour
.c13d	a13d	8d ec 07	sta $07ec			sta 	EXTTextColour
.c140	a140	60		rts				rts
.c141	a141					EXPCBackground:
.c141	a141	29 0f		and #$0f			and 	#$0F 						; get the colour
.c143	a143	a2 f0		ldx #$f0			ldx 	#$F0 						; mask
.c145	a145	80 ea		bra $a131			bra 	EXPCUpdate
.c147	a147					EXTScreenScroll:
.c147	a147	a9 02		lda #$02			lda 	#2 							; select text page
.c149	a149	85 01		sta $01				sta 	1
.c14b	a14b	a9 20		lda #$20			lda		#32 						; fill with space
.c14d	a14d	20 e6 a2	jsr $a2e6			jsr 	EXTScrollFill
.c150	a150	e6 01		inc $01				inc 	1 							; select colour page
.c152	a152	ad ec 07	lda $07ec			lda 	EXTTextColour
.c155	a155	20 e6 a2	jsr $a2e6			jsr 	EXTScrollFill
.c158	a158	60		rts				rts
.c159	a159					PAGEDPrintHex:
.c159	a159	48		pha				pha
.c15a	a15a	a9 20		lda #$20			lda 	#' '
.c15c	a15c	20 0b a0	jsr $a00b			jsr 	PAGEDPrintCharacter
.c15f	a15f	68		pla				pla
.c160	a160	48		pha				pha
.c161	a161	4a		lsr a				lsr 	a
.c162	a162	4a		lsr a				lsr 	a
.c163	a163	4a		lsr a				lsr 	a
.c164	a164	4a		lsr a				lsr 	a
.c165	a165	20 69 a1	jsr $a169			jsr 	_PPHNibble
.c168	a168	68		pla				pla
.c169	a169					_PPHNibble:
.c169	a169	48		pha				pha
.c16a	a16a	29 0f		and #$0f			and 	#15
.c16c	a16c	c9 0a		cmp #$0a			cmp 	#10
.c16e	a16e	90 02		bcc $a172			bcc 	_PPHOut
.c170	a170	69 06		adc #$06			adc 	#6
.c172	a172	69 30		adc #$30	_PPHOut:adc 	#48
.c174	a174	20 0b a0	jsr $a00b			jsr		PAGEDPrintCharacter
.c177	a177	68		pla				pla
.c178	a178	60		rts				rts
.c179	a179					EXTClearScreenCode:
.c179	a179	a9 02		lda #$02			lda 	#2 							; select text page
.c17b	a17b	85 01		sta $01				sta 	1
.c17d	a17d	a9 20		lda #$20			lda		#32 						; fill with space
.c17f	a17f	20 8c a1	jsr $a18c			jsr 	_EXTCSFill
.c182	a182	e6 01		inc $01				inc 	1 							; select color page
.c184	a184	ad ec 07	lda $07ec			lda 	EXTTextColour
.c187	a187	20 8c a1	jsr $a18c			jsr 	_EXTCSFill
.c18a	a18a	80 22		bra $a1ae			bra 	EXTHomeCursor				; home cursor
.c18c	a18c					_EXTCSFill:
.c18c	a18c	aa		tax				tax
.c18d	a18d	a9 00		lda #$00			lda 	#EXTMemory & $FF
.c18f	a18f	85 40		sta $40				sta 	EXTAddress
.c191	a191	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.c193	a193	85 41		sta $41				sta 	EXTAddress+1
.c195	a195					_EXTCSFill1:
.c195	a195	a0 00		ldy #$00			ldy 	#0
.c197	a197	8a		txa				txa
.c198	a198					_EXTCSFill2:
.c198	a198	91 40		sta ($40),y			sta 	(EXTAddress),y
.c19a	a19a	c8		iny				iny
.c19b	a19b	d0 fb		bne $a198			bne 	_EXTCSFill2
.c19d	a19d	e6 41		inc $41				inc 	EXTAddress+1
.c19f	a19f	a5 41		lda $41				lda 	EXTAddress+1
.c1a1	a1a1	c9 d2		cmp #$d2			cmp 	#$D2
.c1a3	a1a3	d0 f0		bne $a195			bne 	_EXTCSFill1
.c1a5	a1a5	8a		txa				txa
.c1a6	a1a6					_EXTCSFill3:
.c1a6	a1a6	91 40		sta ($40),y			sta 	(EXTAddress),y
.c1a8	a1a8	c8		iny				iny
.c1a9	a1a9	c0 c0		cpy #$c0			cpy 	#$C0
.c1ab	a1ab	d0 f9		bne $a1a6			bne 	_EXTCSFill3
.c1ad	a1ad	60		rts				rts
.c1ae	a1ae					EXTHomeCursor:
.c1ae	a1ae	9c ea 07	stz $07ea			stz 	EXTRow 						; reset row & column
.c1b1	a1b1	9c eb 07	stz $07eb			stz 	EXTColumn
.c1b4	a1b4	a9 00		lda #$00			lda 	#<EXTMemory					; set address in I/O memory
.c1b6	a1b6	85 40		sta $40				sta 	EXTAddress
.c1b8	a1b8	a9 c0		lda #$c0			lda 	#>EXTMemory
.c1ba	a1ba	85 41		sta $41				sta 	EXTAddress+1
.c1bc	a1bc					EXTSetHardwareCursor:
.c1bc	a1bc	64 01		stz $01		        stz 	1 							; I/O Page zero
.c1be	a1be	ad eb 07	lda $07eb	        lda 	EXTColumn
.c1c1	a1c1	8d 14 d0	sta $d014	        sta 	$D014 						; set cursor position
.c1c4	a1c4	9c 15 d0	stz $d015	        stz 	$D015
.c1c7	a1c7	ad ea 07	lda $07ea	        lda 	EXTRow
.c1ca	a1ca	8d 16 d0	sta $d016	        sta 	$D016
.c1cd	a1cd	9c 17 d0	stz $d017	        stz 	$D017
.c1d0	a1d0	60		rts		        rts
.c1d1	a1d1					Export_EXTSetCurrentLine:
.c1d1	a1d1	ad ea 07	lda $07ea			lda     EXTRow						; `A` holds the current row
.c1d4	a1d4	0a		asl a				asl 	a							; multiply row index by 2 to get byte index
.c1d5	a1d5	a8		tay				tay									; `Y` holds the byte index of the row offset
.c1d6	a1d6	18		clc				clc
.c1d7	a1d7	a9 00		lda #$00			lda 	#<EXTMemory					; `A` = low byte of screen memory
.c1d9	a1d9	79 f0 07	adc $07f0,y			adc 	EXTScreenRowOffsets,y		; add the row offset
.c1dc	a1dc	85 40		sta $40				sta 	EXTAddress					; store low byte of the line address
.c1de	a1de	a9 c0		lda #$c0			lda 	#>EXTMemory					; `A` = high byte of screen memory
.c1e0	a1e0	79 f1 07	adc $07f1,y			adc 	EXTScreenRowOffsets+1,y		; add the row offset
.c1e3	a1e3	85 41		sta $41				sta 	EXTAddress+1				; store high byte of the line address
.c1e5	a1e5	60		rts		        rts
=$c000						EXTMemory 		= $C000
=$02						EXTTextPage 	= $02
=$03						EXTColourPage 	= $03
>07ea						EXTRow				.fill 	1
>07eb						EXTColumn			.fill 	1
>07ec						EXTTextColour		.fill 	1
>07ed						EXTScreenWidth		.fill 	1
>07ee						EXTScreenHeight		.fill 	1
>07ef								.align 2
>07f0						EXTScreenRowOffsets	.fill 	128 * 2
>0040						EXTAddress			.fill 	2
.c1e6	a1e6					Export_EXTInitialise:
.c1e6	a1e6	64 01		stz $01				stz 	1 							; Access I/O page 0
.c1e8	a1e8	9c 04 d0	stz $d004			stz 	$D004 						; Disable border
.c1eb	a1eb	9c 08 d0	stz $d008			stz 	$D008
.c1ee	a1ee	9c 09 d0	stz $d009			stz 	$D009
.c1f1	a1f1	a9 09		lda #$09			lda 	#1+8						; Timer On at 70Hz counting up.
.c1f3	a1f3	8d 58 d6	sta $d658			sta 	$D658
.c1f6	a1f6	a9 52		lda #$52			lda 	#$52
.c1f8	a1f8	8d ec 07	sta $07ec			sta 	EXTTextColour
.c1fb	a1fb	a9 50		lda #$50			lda 	#80 						; number of columns
.c1fd	a1fd	8d ed 07	sta $07ed			sta 	EXTScreenWidth
.c200	a200	a9 3c		lda #$3c			lda 	#60							; number of rows
.c202	a202	8d ee 07	sta $07ee			sta 	EXTScreenHeight
.c205	a205	ad ee 07	lda $07ee			lda		EXTScreenHeight				; get screen height
.c208	a208	85 36		sta $36				sta		zTemp0 						; `zTemp0` = row counter
.c20a	a20a	10 05		bpl $a211			bpl		loop_start					; screen height is less then 128, continue
.c20c	a20c	a9 1f		lda #$1f		lda	#31
.c20e	a20e	4c 19 95	jmp $9519		jmp	ErrorHandler
.c211	a211						loop_start:
.c211	a211	64 38		stz $38				stz		zTemp1						; zTemp1 holds the current offset
.c213	a213	64 39		stz $39				stz		zTemp1+1					;
.c215	a215	a0 00		ldy #$00			ldy		#0			  				; `Y` = offset byte index
.c217	a217						next_row:
.c217	a217	a5 38		lda $38				lda		zTemp1						; get low byte of offset
.c219	a219	99 f0 07	sta $07f0,y			sta		EXTScreenRowOffsets,y		; store low byte
.c21c	a21c	c8		iny				iny
.c21d	a21d	a5 39		lda $39				lda		zTemp1+1					; get high byte of offset
.c21f	a21f	99 f0 07	sta $07f0,y			sta		EXTScreenRowOffsets,y		; store high byte
.c222	a222	c8		iny				iny
.c223	a223	18		clc				clc
.c224	a224	a5 38		lda $38				lda		zTemp1						; `A` holds the low byte of offset
.c226	a226	6d ed 07	adc $07ed			adc		EXTScreenWidth				; add screen width
.c229	a229	85 38		sta $38				sta		zTemp1						; store low byte of new offset
.c22b	a22b	90 02		bcc $a22f			bcc		no_carry					; if no carry, we are done
.c22d	a22d	e6 39		inc $39				inc		zTemp1+1					; increment high byte of offset if carry occurred
.c22f	a22f						no_carry:
.c22f	a22f	c6 36		dec $36				dec		zTemp0						; decrement row counter
.c231	a231	d0 e4		bne $a217			bne		next_row					; if not zero, precompute the next row's offset
.c233	a233	a9 05		lda #$05			lda 	#1+4 						; enable cursor
.c235	a235	8d 10 d0	sta $d010			sta 	$D010
.c238	a238	a9 d6		lda #$d6			lda 	#214 						; cursor character
.c23a	a23a	8d 12 d0	sta $d012			sta 	$D012
.c23d	a23d	20 79 a1	jsr $a179			jsr 	EXTClearScreenCode 			; clear the screen and home cursor
.c240	a240					_EXMoveDown:
.c240	a240	a9 0d		lda #$0d			lda 	#13
.c242	a242	20 0b a0	jsr $a00b			jsr 	PAGEDPrintCharacter
.c245	a245	ad ea 07	lda $07ea			lda 	EXTRow
.c248	a248	c9 0a		cmp #$0a			cmp 	#Header_Height-4
.c24a	a24a	d0 f4		bne $a240			bne 	_EXMoveDown
.c24c	a24c	20 52 a2	jsr $a252			jsr 	EXTShowHeader
.c24f	a24f	64 01		stz $01				stz 	1
.c251	a251	60		rts				rts
.c252	a252					EXTShowHeader:
.c252	a252	a5 01		lda $01				lda 	1
.c254	a254	48		pha				pha
.c255	a255	a5 0b		lda $0b				lda 	8+3
.c257	a257	48		pha				pha
.c258	a258	a5 0c		lda $0c				lda 	8+4
.c25a	a25a	18		clc				clc
.c25b	a25b	69 03		adc #$03			adc 	#3
.c25d	a25d	85 0b		sta $0b				sta 	8+3
.c25f	a25f	a2 92		ldx #$92			ldx 	#(Header_jchars & $FF)
.c261	a261	a0 61		ldy #$61			ldy 	#(Header_jchars >> 8)-$40
.c263	a263	64 01		stz $01				stz 	1
.c265	a265	ad a7 d6	lda $d6a7			lda 	$D6A7
.c268	a268	29 10		and #$10			and 	#$10
.c26a	a26a	f0 04		beq $a270			beq 	_EXTSHNotK1
.c26c	a26c	a2 21		ldx #$21			ldx 	#(Header_kchars & $FF)
.c26e	a26e	a0 65		ldy #$65			ldy 	#(Header_kchars >> 8)-$40
.c270	a270					_EXTSHNotK1:
.c270	a270	a9 02		lda #$02			lda 	#2
.c272	a272	20 a0 a2	jsr $a2a0			jsr 	_ESHCopyBlock
.c275	a275	a2 00		ldx #$00			ldx 	#(Header_jattrs & $FF)
.c277	a277	a0 60		ldy #$60			ldy 	#(Header_jattrs >> 8)-$40
.c279	a279	64 01		stz $01				stz 	1
.c27b	a27b	ad a7 d6	lda $d6a7			lda 	$D6A7
.c27e	a27e	29 10		and #$10			and 	#$10
.c280	a280	f0 04		beq $a286			beq 	_EXTSHNotK2
.c282	a282	a2 c2		ldx #$c2			ldx 	#(Header_kattrs & $FF)
.c284	a284	a0 63		ldy #$63			ldy 	#(Header_kattrs >> 8)-$40
.c286	a286					_EXTSHNotK2:
.c286	a286	a9 03		lda #$03			lda 	#3
.c288	a288	20 a0 a2	jsr $a2a0			jsr 	_ESHCopyBlock
.c28b	a28b	64 01		stz $01				stz 	1
.c28d	a28d	a2 3f		ldx #$3f			ldx 	#16*4-1
.c28f	a28f					_EXTCopyLUT:
.c28f	a28f	bd 23 67	lda $6723,x			lda 	Header_Palette-$4000,x
.c292	a292	9d 00 d8	sta $d800,x			sta 	$D800,x
.c295	a295	9d 40 d8	sta $d840,x			sta 	$D840,x
.c298	a298	ca		dex				dex
.c299	a299	10 f4		bpl $a28f			bpl 	_EXTCopyLUT
.c29b	a29b	68		pla				pla
.c29c	a29c	85 0b		sta $0b				sta 	8+3
.c29e	a29e	68		pla				pla
.c29f	a29f	60		rts				rts
.c2a0	a2a0					_ESHCopyBlock:
.c2a0	a2a0	85 01		sta $01				sta 	1
.c2a2	a2a2	86 36		stx $36				stx 	zTemp0 						; zTemp0 is RLE packed data
.c2a4	a2a4	84 37		sty $37				sty 	zTemp0+1
.c2a6	a2a6	a9 00		lda #$00			lda 	#(($C000) & $FF)
.c2a8	a2a8	85 38		sta $38				sta 	0+zTemp1
.c2aa	a2aa	a9 c0		lda #$c0			lda 	#(($C000) >> 8)
.c2ac	a2ac	85 39		sta $39				sta 	1+zTemp1
.c2ae	a2ae					_ESHCopyLoop:
.c2ae	a2ae	b2 36		lda ($36)			lda 	(zTemp0) 					; get next character
.c2b0	a2b0	c9 ff		cmp #$ff			cmp 	#Header_RLE 				; packed ?
.c2b2	a2b2	f0 1b		beq $a2cf			beq 	_ESHUnpack
.c2b4	a2b4	92 38		sta ($38)			sta 	(zTemp1) 					; copy it out.
.c2b6	a2b6	a9 01		lda #$01			lda 	#1 							; source add 1
.c2b8	a2b8	a0 01		ldy #$01			ldy 	#1 							; dest add 1
.c2ba	a2ba					_ESHNext:
.c2ba	a2ba	18		clc				clc 								; zTemp0 + A
.c2bb	a2bb	65 36		adc $36				adc 	zTemp0
.c2bd	a2bd	85 36		sta $36				sta 	zTemp0
.c2bf	a2bf	90 02		bcc $a2c3			bcc 	_ESHNoCarry
.c2c1	a2c1	e6 37		inc $37				inc 	zTemp0+1
.c2c3	a2c3					_ESHNoCarry:
.c2c3	a2c3	98		tya				tya 								; zTemp1 + Y
.c2c4	a2c4	18		clc				clc
.c2c5	a2c5	65 38		adc $38				adc 	zTemp1
.c2c7	a2c7	85 38		sta $38				sta 	zTemp1
.c2c9	a2c9	90 e3		bcc $a2ae			bcc 	_ESHCopyLoop
.c2cb	a2cb	e6 39		inc $39				inc 	zTemp1+1
.c2cd	a2cd	80 df		bra $a2ae			bra 	_ESHCopyLoop
.c2cf	a2cf					_ESHUnpack:
.c2cf	a2cf	a0 02		ldy #$02			ldy 	#2 							; get count into X
.c2d1	a2d1	b1 36		lda ($36),y			lda 	(zTemp0),y
.c2d3	a2d3	aa		tax				tax
.c2d4	a2d4	88		dey				dey 								; byte into A
.c2d5	a2d5	b1 36		lda ($36),y			lda 	(zTemp0),y
.c2d7	a2d7	f0 0c		beq $a2e5			beq 	_ESHExit 					; exit if zero.
.c2d9	a2d9	a0 00		ldy #$00			ldy 	#0 							; copy start position
.c2db	a2db					_ESHCopyOut:
.c2db	a2db	91 38		sta ($38),y			sta 	(zTemp1),y
.c2dd	a2dd	c8		iny				iny
.c2de	a2de	ca		dex				dex
.c2df	a2df	d0 fa		bne $a2db			bne 	_ESHCopyOut
.c2e1	a2e1	a9 03		lda #$03			lda 	#3 							; Y is bytes on screen, 3 bytes from source
.c2e3	a2e3	80 d5		bra $a2ba			bra 	_ESHNext
.c2e5	a2e5					_ESHExit:
.c2e5	a2e5	60		rts				rts
.c2e6	a2e6					EXTScrollFill:
.c2e6	a2e6	aa		tax				tax									; save value to fill with
.c2e7	a2e7	a5 36		lda $36				lda 	zTemp0 						; save zTemp0 (dest) zTemp1 (src)
.c2e9	a2e9	48		pha				pha
.c2ea	a2ea	a5 37		lda $37				lda 	zTemp0+1
.c2ec	a2ec	48		pha				pha
.c2ed	a2ed	a5 38		lda $38				lda 	zTemp1
.c2ef	a2ef	48		pha				pha
.c2f0	a2f0	a5 39		lda $39				lda 	zTemp1+1
.c2f2	a2f2	48		pha				pha
.c2f3	a2f3	a9 c0		lda #$c0			lda 	#$C0 						; copy from C000+length to C000
.c2f5	a2f5	85 37		sta $37				sta 	zTemp0+1
.c2f7	a2f7	85 39		sta $39				sta 	zTemp1+1
.c2f9	a2f9	64 36		stz $36				stz 	zTemp0
.c2fb	a2fb	ad ed 07	lda $07ed			lda 	EXTScreenWidth
.c2fe	a2fe	85 38		sta $38				sta 	zTemp1
.c300	a300	a0 00		ldy #$00			ldy 	#0
.c302	a302					_EXSFCopy1:
.c302	a302	b1 38		lda ($38),y			lda 	(zTemp1),y
.c304	a304	91 36		sta ($36),y			sta 	(zTemp0),y
.c306	a306	c8		iny				iny
.c307	a307	d0 f9		bne $a302			bne 	_EXSFCopy1
.c309	a309	e6 37		inc $37				inc 	zTemp0+1 					; next page
.c30b	a30b	e6 39		inc $39				inc 	zTemp1+1
.c30d	a30d	a5 39		lda $39				lda 	zTemp1+1
.c30f	a30f	c9 d3		cmp #$d3			cmp 	#$D3
.c311	a311	d0 ef		bne $a302			bne 	_EXSFCopy1
.c313	a313	ac ed 07	ldy $07ed			ldy 	EXTScreenWidth 				; blank the bottom line.
.c316	a316	8a		txa				txa
.c317	a317					_EXSFFill1:
.c317	a317	88		dey				dey
.c318	a318	91 40		sta ($40),y			sta 	(EXTAddress),y
.c31a	a31a	c0 00		cpy #$00			cpy 	#0
.c31c	a31c	10 f9		bpl $a317			bpl 	_EXSFFill1
.c31e	a31e	68		pla				pla
.c31f	a31f	85 39		sta $39				sta 	zTemp1+1
.c321	a321	68		pla				pla
.c322	a322	85 38		sta $38				sta 	zTemp1
.c324	a324	68		pla				pla
.c325	a325	85 37		sta $37				sta 	zTemp0+1
.c327	a327	68		pla				pla
.c328	a328	85 36		sta $36				sta 	zTemp0
.c32a	a32a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/.build/graphics.module.asm

=1						graphicsIntegrated=1
=0						GCMD_Initialise = 0*2
=2						GCMD_BitmapCtl = 1*2
=4						GCMD_SpriteCtl = 2*2
=6						GCMD_Clear = 3*2
=8						GCMD_Colour = 4*2
=10						GCMD_DrawFont = 5*2
=12						GCMD_DrawSprite = 6*2
=14						GCMD_SpriteUse = 7*2
=16						GCMD_SpriteImage = 8*2
=18						GCMD_SpriteCollide = 9*2
=20						GCMD_TileCtl = 10*2
=22						GCMD_TileSize = 11*2
=24						GCMD_TileScrollX = 12*2
=26						GCMD_TileScrollY = 13*2
=28						GCMD_TilePos = 14*2
=30						GCMD_TileWrite = 15*2
=32						GCMD_TileRead = 16*2
=64						GCMD_Move = 32*2
=66						GCMD_Line = 33*2
=68						GCMD_FrameRect = 34*2
=70						GCMD_FillRect = 35*2
=72						GCMD_FrameCircle = 36*2
=74						GCMD_FillCircle = 37*2
=80						GCMD_Plot = 40*2
=82						GCMD_SpriteMove = 41*2
=42						GRFirstFreeCode = 42
.c32b	a32b					GRVectorTable:
>c32b	a32b	7d a5					.word	GXInitialise             ; $00 Initialise
>c32d	a32d	a4 a5					.word	GXControlBitmap          ; $01 BitmapCtl
>c32f	a32f	ec a5					.word	GXControlSprite          ; $02 SpriteCtl
>c331	a331	2d a5					.word	GXClearBitmap            ; $03 Clear
>c333	a333	1d a8					.word	GXSetColourMode          ; $04 Colour
>c335	a335	3c aa					.word	GXFontHandler            ; $05 DrawFont
>c337	a337	84 aa					.word	GXSpriteHandler          ; $06 DrawSprite
>c339	a339	f5 aa					.word	GXSelect                 ; $07 SpriteUse
>c33b	a33b	1e ab					.word	GXSelectImage            ; $08 SpriteImage
>c33d	a33d	43 ad					.word	GXCollide                ; $09 SpriteCollide
>c33f	a33f	2d a6					.word	GXControlTilemap         ; $0a TileCtl
>c341	a341	b5 a6					.word	GXControlTileSize        ; $0b TileSize
>c343	a343	e5 a9					.word	GXControlTileScrollX     ; $0c TileScrollX
>c345	a345	f6 a9					.word	GXControlTileScrollY     ; $0d TileScrollY
>c347	a347	24 ac					.word	GXSelectTile             ; $0e TilePos
>c349	a349	86 ac					.word	GXSTWriteTile            ; $0f TileWrite
>c34b	a34b	89 ac					.word	GXSTReadTile             ; $10 TileRead
>c34d	a34d	de a3					.word	GRUndefined              ; $11
>c34f	a34f	de a3					.word	GRUndefined              ; $12
>c351	a351	de a3					.word	GRUndefined              ; $13
>c353	a353	de a3					.word	GRUndefined              ; $14
>c355	a355	de a3					.word	GRUndefined              ; $15
>c357	a357	de a3					.word	GRUndefined              ; $16
>c359	a359	de a3					.word	GRUndefined              ; $17
>c35b	a35b	de a3					.word	GRUndefined              ; $18
>c35d	a35d	de a3					.word	GRUndefined              ; $19
>c35f	a35f	de a3					.word	GRUndefined              ; $1a
>c361	a361	de a3					.word	GRUndefined              ; $1b
>c363	a363	de a3					.word	GRUndefined              ; $1c
>c365	a365	de a3					.word	GRUndefined              ; $1d
>c367	a367	de a3					.word	GRUndefined              ; $1e
>c369	a369	de a3					.word	GRUndefined              ; $1f
>c36b	a36b	dc a3					.word	GXMove                   ; $20 Move
>c36d	a36d	eb a6					.word	GXLine                   ; $21 Line
>c36f	a36f	66 a8					.word	GXFrameRectangle         ; $22 FrameRect
>c371	a371	63 a8					.word	GXFillRectangle          ; $23 FillRect
>c373	a373	e4 a3					.word	GXFrameCircle            ; $24 FrameCircle
>c375	a375	e0 a3					.word	GXFillCircle             ; $25 FillCircle
>c377	a377	de a3					.word	GRUndefined              ; $26
>c379	a379	de a3					.word	GRUndefined              ; $27
>c37b	a37b	4b a8					.word	GXPlotPoint              ; $28 Plot
>c37d	a37d	b4 ab					.word	GXMoveSprite             ; $29 SpriteMove
=3						GXMappingPage = 3
=24576						GXMappingAddress = ($2000 * GXMappingPage)
=11						GXEditSlot = 8 + GXMappingPage
=$36						gxzTemp0 = zTemp0
=$38						gxzTemp1 = zTemp1
=$3a						gxzTemp2 = zTemp2
=$3c						gxzScreen = zsTemp
=$643						gxPixelBuffer = numberBuffer
.08f0						gxCurrentX:
>08f0								.fill 	2
.08f2						gxCurrentY:
>08f2								.fill 	2
.08f4						gxLastX:
>08f4								.fill 	2
.08f6						gxLastY:
>08f6								.fill 	2
.08f8						gxX0:
>08f8								.fill 	2
.08fa						gxY0:
>08fa								.fill 	2
.08fc						gxX1:
>08fc								.fill 	2
.08fe						gxY1:
>08fe								.fill 	2
.0900						gxSpritesOn:
>0900								.fill 	1
.0901						gxBitmapsOn:
>0901								.fill 	1
.0902						gxTilesOn:
>0902								.fill 	1
.0903						gxBasePage:
>0903								.fill 	1
.0904						gxSpritePage:
>0904								.fill 	1
.0905						gxTileImagePage:
>0905								.fill 	1
.0906						gxTileMapPage:
>0906								.fill 	1
.0907						gxTileMapWidth:
>0907								.fill 	1
.0908						gxTileMapHeight:
>0908								.fill 	1
.0909						gxHeight:
>0909								.fill 	1
.090a						gxMode:
>090a								.fill 	1
.090b						gxColour:
>090b								.fill 	1
.090c						gxEORValue:
>090c								.fill 	1
.090d						gxANDValue:
>090d								.fill 	1
.090e						gxOriginalLUTValue:
>090e								.fill 	1
.090f						gxOffset:
>090f								.fill 	1
.0910						GSCurrentSpriteID:
>0910								.fill 	1
.0911						GSCurrentSpriteAddr:
>0911								.fill 	2
.0913						gxSpriteOffsetBase:
>0913								.fill 	2
.0915						gxSpriteLow:
>0915								.fill 	64
.0955						gxSpriteHigh:
>0955								.fill 	64
.0995						gxTileAccessPage:
>0995								.fill 	1
.0996						gxTileAccessAddress:
>0996								.fill 	2
.c37f	a37f					Export_GXGraphicDraw:
.c37f	a37f	c9 40		cmp #$40			cmp 	#GCMD_Move					; low value instructions don't use coordinates
.c381	a381	b0 06		bcs $a389			bcs 	_GDCoordinate 				; (see graphics.txt)
.c383	a383	86 36		stx $36				stx 	gxzTemp0 					; save X/Y
.c385	a385	84 37		sty $37				sty 	gxzTemp0+1
.c387	a387	80 4b		bra $a3d4			bra 	_GDExecuteA 				; and execute
.c389	a389					_GDCoordinate:
.c389	a389	48		pha				pha 								; save AXY
.c38a	a38a	da		phx				phx
.c38b	a38b	5a		phy				phy
.c38c	a38c	a2 03		ldx #$03			ldx 	#3 							; copy currentX to lastX
.c38e	a38e					_GDCopy1:
.c38e	a38e	bd f0 08	lda $08f0,x			lda 	gxCurrentX,x
.c391	a391	9d f4 08	sta $08f4,x			sta 	gxLastX,x
.c394	a394	ca		dex				dex
.c395	a395	10 f7		bpl $a38e			bpl 	_GDCopy1
.c397	a397	68		pla				pla
.c398	a398	8d f2 08	sta $08f2			sta 	gxCurrentY
.c39b	a39b	9c f3 08	stz $08f3			stz 	gxCurrentY+1
.c39e	a39e	68		pla				pla
.c39f	a39f	8d f0 08	sta $08f0			sta 	gxCurrentX
.c3a2	a3a2	68		pla				pla 								; get A (command+X.1) back
.c3a3	a3a3	48		pha				pha
.c3a4	a3a4	29 01		and #$01			and 	#1 							; put LSB as MSB of Current.X
.c3a6	a3a6	8d f1 08	sta $08f1			sta 	gxCurrentX+1
.c3a9	a3a9	68		pla				pla 								; get command back
.c3aa	a3aa	29 fe		and #$fe			and 	#$FE 						; lose LSB, chuck the stray X bit
.c3ac	a3ac	48		pha				pha 								; push back.
.c3ad	a3ad	c9 52		cmp #$52			cmp 	#GCMD_SpriteMove 			; move sprite does not clip.
.c3af	a3af	f0 17		beq $a3c8			beq 	_GDCopyToWorkArea
.c3b1	a3b1	ad f1 08	lda $08f1			lda 	gxCurrentX+1 				; X < 256 X okay
.c3b4	a3b4	f0 07		beq $a3bd			beq 	_GDCheckY
.c3b6	a3b6	ad f0 08	lda $08f0			lda 	gxCurrentX 					; otherwise X < 320 = 256 + 64
.c3b9	a3b9	c9 40		cmp #$40			cmp 	#64
.c3bb	a3bb	b0 08		bcs $a3c5			bcs 	_GDError1
.c3bd	a3bd					_GDCheckY:
.c3bd	a3bd	ad f2 08	lda $08f2			lda 	gxCurrentY 					; check Y < Height.
.c3c0	a3c0	cd 09 09	cmp $0909			cmp 	gxHeight
.c3c3	a3c3	90 03		bcc $a3c8			bcc 	_GDCopyToWorkArea
.c3c5	a3c5					_GDError1:
.c3c5	a3c5	68		pla				pla
.c3c6	a3c6					_GDError2:
.c3c6	a3c6	38		sec				sec
.c3c7	a3c7	60		rts				rts
.c3c8	a3c8					_GDCopyToWorkArea:
.c3c8	a3c8	a2 07		ldx #$07			ldx 	#7 							; copy current and last to gxXY/12 work area
.c3ca	a3ca					_GDCopy2:
.c3ca	a3ca	bd f0 08	lda $08f0,x			lda 	gxCurrentX,x
.c3cd	a3cd	9d f8 08	sta $08f8,x			sta 	gxX0,x
.c3d0	a3d0	ca		dex				dex
.c3d1	a3d1	10 f7		bpl $a3ca			bpl 	_GDCopy2
.c3d3	a3d3	68		pla				pla 								; get command
.c3d4	a3d4					_GDExecuteA:
.c3d4	a3d4	c9 54		cmp #$54			cmp 	#GRFirstFreeCode*2 			; bad command ?
.c3d6	a3d6	b0 ee		bcs $a3c6			bcs 	_GDError2
.c3d8	a3d8	aa		tax				tax 								; go execute the command.
.c3d9	a3d9	7c 2b a3	jmp ($a32b,x)			jmp 	(GRVectorTable,x)
.c3dc	a3dc					GXMove:
.c3dc	a3dc	18		clc				clc
.c3dd	a3dd	60		rts				rts
.c3de	a3de					GRUndefined:
.c3de	a3de	38		sec				sec
.c3df	a3df	60		rts				rts
.c3e0	a3e0					GXFillCircle:
.c3e0	a3e0	a9 ff		lda #$ff			lda 	#255 						; A determines fill or not
.c3e2	a3e2	80 02		bra $a3e6			bra 	GXCircle
.c3e4	a3e4					GXFrameCircle:
.c3e4	a3e4	a9 00		lda #$00			lda 	#0
.c3e6	a3e6					GXCircle:
.c3e6	a3e6	8d 9b 09	sta $099b			sta 	gxIsFillMode				; save Fill flag
.c3e9	a3e9	ad 01 09	lda $0901			lda 	gxBitmapsOn
.c3ec	a3ec	f0 26		beq $a414			beq 	_GXCFail
.c3ee	a3ee	20 31 ae	jsr $ae31			jsr 	GXSortXY 					; topleft/bottomright
.c3f1	a3f1	20 c2 ac	jsr $acc2			jsr 	GXOpenBitmap 				; start drawing
.c3f4	a3f4	20 e6 a4	jsr $a4e6			jsr 	GXCircleSetup 				; set up for drawing
.c3f7	a3f7	9c 9c 09	stz $099c			stz 	gxYChanged
.c3fa	a3fa					_GXCircleDraw:
.c3fa	a3fa	ad 99 09	lda $0999			lda 	gxxCentre					; while x <= y
.c3fd	a3fd	cd 9a 09	cmp $099a			cmp 	gxYCentre
.c400	a400	90 0a		bcc $a40c			bcc 	_GXCircleContinue
.c402	a402	d0 03		bne $a407			bne 	_GXNoLast  					; fix up if x < y
.c404	a404	20 19 a4	jsr $a419			jsr 	GXPlot1
.c407	a407					_GXNoLast:
.c407	a407	20 ca ac	jsr $acca			jsr 	GXCloseBitmap 				; close the bitmap
.c40a	a40a	18		clc				clc
.c40b	a40b	60		rts				rts
.c40c	a40c					_GXCircleContinue:
.c40c	a40c	20 16 a4	jsr $a416			jsr 	GXPlot2 					; draw it
.c40f	a40f	20 93 a4	jsr $a493			jsr 	GXCircleMove 				; adjust the coordinates
.c412	a412	80 e6		bra $a3fa			bra 	_GXCircleDraw
.c414	a414					_GXCFail:
.c414	a414	38		sec				sec
.c415	a415	60		rts				rts
.c416	a416					GXPlot2:
.c416	a416	20 19 a4	jsr $a419			jsr 	GXPlot1 						; plot and swap, fall through does twice
.c419	a419					GXPlot1:
.c419	a419	ad 9a 09	lda $099a			lda 	gxYCentre 						; if y = 0, don't do it twice (xor)
.c41c	a41c	f0 03		beq $a421			beq 	_GXPlot1Only
.c41e	a41e	20 3d a4	jsr $a43d			jsr 	GXPlot0 						; plot and negate
.c421	a421					_GXPlot1Only:
.c421	a421	20 3d a4	jsr $a43d			jsr 	GXPlot0 						; twice, undoing negation
.c424	a424	ad 99 09	lda $0999			lda 	gxxCentre 						; swap X and Y
.c427	a427	ae 9a 09	ldx $099a			ldx	 	gxYCentre
.c42a	a42a	8d 9a 09	sta $099a			sta 	gxYCentre
.c42d	a42d	8e 99 09	stx $0999			stx 	gxxCentre
.c430	a430	ad 9c 09	lda $099c			lda 	gxYChanged 						; toggle Y Changed flag
.c433	a433	a9 ff		lda #$ff			lda 	#$FF
.c435	a435	8d 9c 09	sta $099c			sta 	gxYChanged
.c438	a438	60		rts				rts
.c439	a439	20 3d a4	jsr $a43d			jsr 	GXPlot0 						; do once
.c43c	a43c	60		rts				rts
.c43d	a43d	ad 9b 09	lda $099b	GXPlot0:lda 	gxIsFillMode 					; outline mode, always draw as X or Y will change
.c440	a440	f0 05		beq $a447			beq 	_GXPlot0Always
.c442	a442	ad 9c 09	lda $099c			lda 	gxYChanged						; fill mode, only draw if changed.
.c445	a445	f0 2d		beq $a474			beq 	GXPlot0Exit
.c447	a447					_GXPlot0Always:
.c447	a447	a2 02		ldx #$02			ldx 	#2 								; copy Y1-A => Y0
.c449	a449	ad 9a 09	lda $099a			lda 	gxYCentre
.c44c	a44c	20 75 a4	jsr $a475			jsr 	GXSubCopy
.c44f	a44f	a2 00		ldx #$00			ldx 	#0 								; copy X1-A => X0,
.c451	a451	ad 99 09	lda $0999			lda 	gxxCentre
.c454	a454	20 75 a4	jsr $a475			jsr 	GXSubCopy
.c457	a457	48		pha				pha 									; save last offset X
.c458	a458	20 d2 ac	jsr $acd2			jsr 	gxPositionCalc 					; calculate position/offset.
.c45b	a45b	68		pla				pla
.c45c	a45c	0a		asl a				asl 	a 								; store 2 x last offset in gxzTemp0
.c45d	a45d	85 36		sta $36				sta 	gxzTemp0
.c45f	a45f	64 37		stz $37				stz 	gxzTemp0+1
.c461	a461	26 37		rol $37				rol 	gxzTemp0+1
.c463	a463	ad 9b 09	lda $099b			lda 	gxIsFillMode
.c466	a466	69 80		adc #$80			adc 	#128
.c468	a468	20 b6 a8	jsr $a8b6			jsr 	GXDrawLineTemp0 				; routine from Rectangle.
.c46b	a46b	38		sec				sec 									; GY = -GY
.c46c	a46c	a9 00		lda #$00			lda 	#0
.c46e	a46e	ed 9a 09	sbc $099a			sbc 	gxYCentre
.c471	a471	8d 9a 09	sta $099a			sta 	gxYCentre
.c474	a474					GXPlot0Exit:
.c474	a474	60		rts				rts
.c475	a475					GXSubCopy:
.c475	a475	85 36		sta $36				sta 	gxzTemp0
.c477	a477	64 37		stz $37				stz 	gxzTemp0+1
.c479	a479	29 80		and #$80			and 	#$80
.c47b	a47b	f0 02		beq $a47f			beq 	_GXNoSx
.c47d	a47d	c6 37		dec $37				dec 	gxzTemp0+1
.c47f	a47f					_GXNoSx:
.c47f	a47f	38		sec				sec
.c480	a480	bd fc 08	lda $08fc,x			lda 	gxX1,x
.c483	a483	e5 36		sbc $36				sbc 	gxzTemp0
.c485	a485	9d f8 08	sta $08f8,x			sta 	gxX0,x
.c488	a488	bd fd 08	lda $08fd,x			lda 	gxX1+1,x
.c48b	a48b	e5 37		sbc $37				sbc 	gxzTemp0+1
.c48d	a48d	9d f9 08	sta $08f9,x			sta 	gxX0+1,x
.c490	a490	a5 36		lda $36				lda 	gxzTemp0 						; return A
.c492	a492	60		rts				rts
.c493	a493					GXCircleMove:
.c493	a493	9c 9c 09	stz $099c			stz 	gxYChanged 					; clear Y changed flag
.c496	a496	a5 39		lda $39				lda 	gxzTemp1+1 					; check sign of D
.c498	a498	10 0d		bpl $a4a7			bpl 	_GXEMPositive
.c49a	a49a	ee 99 09	inc $0999			inc 	gxxCentre 					; X++
.c49d	a49d	ad 99 09	lda $0999			lda 	gxxCentre
.c4a0	a4a0	20 c6 a4	jsr $a4c6			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.c4a3	a4a3	a9 06		lda #$06			lda 	#6  						; and add 6
.c4a5	a4a5	80 15		bra $a4bc			bra 	_GXEMAddD
.c4a7	a4a7					_GXEMPositive:
.c4a7	a4a7	ee 99 09	inc $0999			inc 	gxxCentre					; X++
.c4aa	a4aa	ce 9a 09	dec $099a			dec 	gxYCentre 					; Y--
.c4ad	a4ad	38		sec				sec 								; calculate X-Y
.c4ae	a4ae	ad 99 09	lda $0999			lda 	gxxCentre
.c4b1	a4b1	ed 9a 09	sbc $099a			sbc 	gxYCentre
.c4b4	a4b4	20 c6 a4	jsr $a4c6			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.c4b7	a4b7	a9 0a		lda #$0a			lda 	#10  						; and add 10
.c4b9	a4b9	ce 9c 09	dec $099c			dec 	gxYChanged
.c4bc	a4bc					_GXEMAddD:
.c4bc	a4bc	18		clc				clc
.c4bd	a4bd	65 38		adc $38				adc 	gxzTemp1
.c4bf	a4bf	85 38		sta $38				sta 	gxzTemp1
.c4c1	a4c1	90 02		bcc $a4c5			bcc 	_GXEMNoCarry
.c4c3	a4c3	e6 39		inc $39				inc 	gxzTemp1+1
.c4c5	a4c5					_GXEMNoCarry:
.c4c5	a4c5	60		rts				rts
.c4c6	a4c6					_GXAdd4TimesToD:
.c4c6	a4c6	85 36		sta $36				sta 	gxzTemp0 					; make 16 bit signed.
.c4c8	a4c8	29 80		and #$80			and 	#$80
.c4ca	a4ca	f0 02		beq $a4ce			beq 	_GXA4Unsigned
.c4cc	a4cc	a9 ff		lda #$ff			lda 	#$FF
.c4ce	a4ce					_GXA4Unsigned:
.c4ce	a4ce	85 37		sta $37				sta 	gxzTemp0+1
.c4d0	a4d0	06 36		asl $36				asl 	gxzTemp0  					; x 4
.c4d2	a4d2	26 37		rol $37				rol 	gxzTemp0+1
.c4d4	a4d4	06 36		asl $36				asl 	gxzTemp0
.c4d6	a4d6	26 37		rol $37				rol 	gxzTemp0+1
.c4d8	a4d8	18		clc				clc 								; add
.c4d9	a4d9	a5 36		lda $36				lda		gxzTemp0
.c4db	a4db	65 38		adc $38				adc 	gxzTemp1
.c4dd	a4dd	85 38		sta $38				sta 	gxzTemp1
.c4df	a4df	a5 37		lda $37				lda		gxzTemp0+1
.c4e1	a4e1	65 39		adc $39				adc 	gxzTemp1+1
.c4e3	a4e3	85 39		sta $39				sta 	gxzTemp1+1
.c4e5	a4e5	60		rts				rts
.c4e6	a4e6					GXCircleSetup:
.c4e6	a4e6	38		sec				sec
.c4e7	a4e7	ad fe 08	lda $08fe			lda 	gxY1
.c4ea	a4ea	ed fa 08	sbc $08fa			sbc 	gxY0
.c4ed	a4ed	4a		lsr a				lsr 	a
.c4ee	a4ee	8d 98 09	sta $0998			sta 	gxRadius
.c4f1	a4f1	a2 00		ldx #$00			ldx 	#0
.c4f3	a4f3	20 15 a5	jsr $a515			jsr 	_GXCalculateCentre
.c4f6	a4f6	a2 02		ldx #$02			ldx 	#2
.c4f8	a4f8	20 15 a5	jsr $a515			jsr 	_GXCalculateCentre
.c4fb	a4fb	9c 99 09	stz $0999			stz 	gxxCentre
.c4fe	a4fe	ad 98 09	lda $0998			lda 	gxRadius
.c501	a501	8d 9a 09	sta $099a			sta 	gxYCentre
.c504	a504	0a		asl a				asl 	a 							; R x 2
.c505	a505	85 36		sta $36				sta 	gxzTemp0
.c507	a507	38		sec				sec
.c508	a508	a9 03		lda #$03			lda 	#3
.c50a	a50a	e5 36		sbc $36				sbc 	gxzTemp0
.c50c	a50c	85 38		sta $38				sta 	gxzTemp1
.c50e	a50e	a9 00		lda #$00			lda 	#0
.c510	a510	e9 00		sbc #$00			sbc 	#0
.c512	a512	85 39		sta $39				sta 	gxzTemp1+1
.c514	a514	60		rts				rts
.c515	a515					_GXCalculateCentre:
.c515	a515	38		sec				sec
.c516	a516	bd fc 08	lda $08fc,x			lda 	gxX1,x
.c519	a519	7d f8 08	adc $08f8,x			adc 	gxX0,x
.c51c	a51c	9d fc 08	sta $08fc,x			sta 	gxX1,x
.c51f	a51f	bd fd 08	lda $08fd,x			lda 	gxX1+1,x
.c522	a522	7d f9 08	adc $08f9,x			adc 	gxX0+1,x
.c525	a525	4a		lsr a				lsr 	a
.c526	a526	9d fd 08	sta $08fd,x			sta 	gxX1+1,x
.c529	a529	7e fc 08	ror $08fc,x			ror 	gxX1,x
.c52c	a52c	60		rts				rts
.0998						gxRadius:
>0998								.fill 	1
.0999						gxxCentre:
>0999								.fill 	1
.099a						gxYCentre:
>099a								.fill 	1
.099b						gxIsFillMode:
>099b								.fill 	1
.099c						gxYChanged:
>099c								.fill  	1
=64000						ScreenSize200 = 320 * 200
=76800						ScreenSize240 = 320 * 240
.c52d	a52d					GXClearBitmap:
.c52d	a52d	ad 01 09	lda $0901			lda 	gxBitmapsOn 				; check BMP turned on.
.c530	a530	f0 26		beq $a558			beq 	_GXCBFail
.c532	a532	20 c2 ac	jsr $acc2			jsr 	GXOpenBitmap 				; start access
.c535	a535	a0 07		ldy #$07			ldy 	#ScreenSize200 / 8192 		; X is pages to clear as 2 graphic heights.
.c537	a537	ad 09 09	lda $0909			lda 	gxHeight
.c53a	a53a	c9 c8		cmp #$c8			cmp 	#200 						; 200 ?
.c53c	a53c	f0 02		beq $a540			beq 	_GXCalcLastPage
.c53e	a53e	a0 09		ldy #$09			ldy 	#ScreenSize240 / 8192
.c540	a540					_GXCalcLastPage:
.c540	a540	98		tya				tya 								; add to base page
.c541	a541	18		clc				clc
.c542	a542	6d 03 09	adc $0903			adc 	gxBasePage
.c545	a545	85 0b		sta $0b				sta 	GXEditSlot  				; clear from this page back
.c547	a547					_GXClearAll:
.c547	a547	20 5a a5	jsr $a55a			jsr 	_GXClearBlock 				; clear 8k block
.c54a	a54a	c6 0b		dec $0b				dec 	GXEditSlot  				; back to previous
.c54c	a54c	a5 0b		lda $0b				lda 	GXEditSlot
.c54e	a54e	cd 03 09	cmp $0903			cmp 	gxBasePage 					; until before base page
.c551	a551	b0 f4		bcs $a547			bcs 	_GXClearAll
.c553	a553	20 ca ac	jsr $acca			jsr 	GXCloseBitmap	 			; stop access
.c556	a556	18		clc				clc
.c557	a557	60		rts				rts
.c558	a558					_GXCBFail:
.c558	a558	38		sec				sec
.c559	a559	60		rts				rts
.c55a	a55a					_GXClearBlock:
.c55a	a55a	a9 00		lda #$00			lda 	#((GXMappingAddress) & $FF)
.c55c	a55c	85 38		sta $38				sta 	0+gxzTemp1
.c55e	a55e	a9 60		lda #$60			lda 	#((GXMappingAddress) >> 8)
.c560	a560	85 39		sta $39				sta 	1+gxzTemp1
.c562	a562					_GXCB0:
.c562	a562	a5 36		lda $36				lda 	gxzTemp0 					; clear colour
.c564	a564	a0 00		ldy #$00			ldy 	#0
.c566	a566					_GXCB1:
.c566	a566	91 38		sta ($38),y			sta 	(gxzTemp1),y
.c568	a568	c8		iny				iny
.c569	a569	91 38		sta ($38),y			sta 	(gxzTemp1),y
.c56b	a56b	c8		iny				iny
.c56c	a56c	91 38		sta ($38),y			sta 	(gxzTemp1),y
.c56e	a56e	c8		iny				iny
.c56f	a56f	91 38		sta ($38),y			sta 	(gxzTemp1),y
.c571	a571	c8		iny				iny
.c572	a572	d0 f2		bne $a566			bne 	_GXCB1
.c574	a574	e6 39		inc $39				inc 	gxzTemp1+1
.c576	a576	a5 39		lda $39				lda 	gxzTemp1+1
.c578	a578	c9 80		cmp #$80			cmp	 	#(GXMappingAddress >> 8)+$20
.c57a	a57a	d0 e6		bne $a562			bne 	_GXCB0
.c57c	a57c	60		rts				rts
.c57d	a57d					GXInitialise:
.c57d	a57d	64 01		stz $01				stz 	1 							; access I/O
.c57f	a57f	a9 01		lda #$01			lda 	#1 							; reset bitmap address
.c581	a581	8d 00 d0	sta $d000			sta 	$D000
.c584	a584	18		clc				clc
.c585	a585	9c 00 09	stz $0900			stz 	gxSpritesOn					; sprites/bitmaps/tiles off.
.c588	a588	9c 01 09	stz $0901			stz 	gxBitmapsOn
.c58b	a58b	9c 02 09	stz $0902			stz 	gxTilesOn
.c58e	a58e	a2 0f		ldx #$0f			ldx 	#15 						; erase work area
.c590	a590					_GXIClear:
.c590	a590	9e f0 08	stz $08f0,x			stz 	gxCurrentX,x
.c593	a593	ca		dex				dex
.c594	a594	10 fa		bpl $a590			bpl 	_GXIClear
.c596	a596	20 dd a6	jsr $a6dd			jsr 	GXClearSpriteStore 			; clear sprite backup space.
.c599	a599	a9 40		lda #$40			lda 	#$40                   		; Layer 0 = Bitmap 0, Layer 1 = Tile map 0
.c59b	a59b	8d 02 d0	sta $d002			sta 	$D002
.c59e	a59e	a9 15		lda #$15			lda 	#$15                   		; Layer 2 = Tile Map 1
.c5a0	a5a0	8d 03 d0	sta $d003			sta 	$D003
.c5a3	a5a3	60		rts				rts
.c5a4	a5a4					GXControlBitmap:
.c5a4	a5a4	64 01		stz $01				stz 	1
.c5a6	a5a6	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.c5a8	a5a8	29 01		and #$01			and 	#1 							; get bitmap flag (is enabled)
.c5aa	a5aa	8d 01 09	sta $0901			sta 	gxBitmapsOn
.c5ad	a5ad	4a		lsr a				lsr 	a 							; bit 0 into carry.
.c5ae	a5ae	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.c5b1	a5b1	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.c5b3	a5b3	29 f7		and #$f7			and 	#$F7 						; clear bitmap bit
.c5b5	a5b5	90 02		bcc $a5b9			bcc 	_CBNotOn
.c5b7	a5b7	09 08		ora #$08			ora 	#$08 						; bitmap on if 1 on 0 off
.c5b9	a5b9					_CBNotOn:
.c5b9	a5b9	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.c5bc	a5bc	a5 36		lda $36				lda 	gxzTemp0 					; get control settings (bits 0-2)
.c5be	a5be	29 07		and #$07			and 	#7
.c5c0	a5c0	8d 00 d1	sta $d100			sta 	$D100 						; write in Vicky Bitmap Control Register #0
.c5c3	a5c3	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page requested
.c5c5	a5c5	d0 02		bne $a5c9			bne 	_CBNotDefault
.c5c7	a5c7	a9 08		lda #$08			lda 	#8  						; if zero, use default 8 e.g. bitmap at $10000
.c5c9	a5c9					_CBNotDefault:
.c5c9	a5c9	8d 03 09	sta $0903			sta 	gxBasePage 					; save as bitmap base page.
.c5cc	a5cc	20 cf a6	jsr $a6cf			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.c5cf	a5cf	a5 37		lda $37				lda 	gxzTemp0+1 					; copy address into Bitmap address registers
.c5d1	a5d1	8d 03 d1	sta $d103			sta 	$D103
.c5d4	a5d4	a5 36		lda $36				lda 	gxzTemp0
.c5d6	a5d6	8d 02 d1	sta $d102			sta 	$D102
.c5d9	a5d9	9c 01 d1	stz $d101			stz 	$D101
.c5dc	a5dc	a2 f0		ldx #$f0			ldx 	#240 						; height is 240 or 200 ?
.c5de	a5de	ad 01 d0	lda $d001			lda 	$D001 						; read MCR bit 0
.c5e1	a5e1	29 01		and #$01			and 	#1
.c5e3	a5e3	f0 02		beq $a5e7			beq 	_CBHaveHeight
.c5e5	a5e5	a2 c8		ldx #$c8			ldx 	#200 						; if bit 0 set 320x200
.c5e7	a5e7					_CBHaveHeight
.c5e7	a5e7	8e 09 09	stx $0909			stx 	gxHeight
.c5ea	a5ea	18		clc				clc
.c5eb	a5eb	60		rts				rts
.c5ec	a5ec					GXControlSprite:
.c5ec	a5ec	64 01		stz $01				stz 	1
.c5ee	a5ee	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.c5f0	a5f0	29 01		and #$01			and 	#1 							; set sprites flag
.c5f2	a5f2	8d 00 09	sta $0900			sta 	gxSpritesOn
.c5f5	a5f5	4a		lsr a				lsr 	a 							; bit 0 into carry
.c5f6	a5f6	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.c5f9	a5f9	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.c5fb	a5fb	29 df		and #$df			and 	#$DF 						; clear sprite bit
.c5fd	a5fd	90 02		bcc $a601			bcc 	_CSNotOn
.c5ff	a5ff	09 20		ora #$20			ora 	#$20 						; sprite on if 1 on 0 off
.c601	a601					_CSNotOn:
.c601	a601	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.c604	a604	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.c606	a606	d0 02		bne $a60a			bne 	_CSNotDefault
.c608	a608	a9 18		lda #$18			lda 	#24  						; if zero, use 24 e.g. sprites at $30000
.c60a	a60a					_CSNotDefault:
.c60a	a60a	8d 04 09	sta $0904			sta 	gxSpritePage
.c60d	a60d	20 cf a6	jsr $a6cf			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.c610	a610	a5 36		lda $36				lda 	gxzTemp0 					; save this so we know where the sprites are.
.c612	a612	8d 13 09	sta $0913			sta 	gxSpriteOffsetBase
.c615	a615	a5 37		lda $37				lda 	gxzTemp0+1
.c617	a617	8d 14 09	sta $0914			sta 	gxSpriteOffsetBase+1
.c61a	a61a	a2 00		ldx #$00			ldx 	#0 							; disable all sprites, clears all sprite memory.
.c61c	a61c					_CSClear:
.c61c	a61c	9e 00 d9	stz $d900,x			stz 	$D900,x
.c61f	a61f	9e 00 da	stz $da00,x			stz 	$DA00,x
.c622	a622	ca		dex				dex
.c623	a623	d0 f7		bne $a61c			bne 	_CSClear
.c625	a625	9c 12 09	stz $0912			stz 	GSCurrentSpriteAddr+1 		; no sprite selected.
.c628	a628	20 dd a6	jsr $a6dd			jsr 	GXClearSpriteStore
.c62b	a62b	18		clc				clc
.c62c	a62c	60		rts				rts
.c62d	a62d					GXControlTilemap:
.c62d	a62d	64 01		stz $01				stz 	1 							; access I/O
.c62f	a62f	a5 36		lda $36				lda 	gxzTemp0 					; get the Map Page/Enable
.c631	a631	30 0d		bmi $a640			bmi 	_GXCTOn
.c633	a633	ad 00 d0	lda $d000			lda 	$D000 						; turn off bitmap enable bit in MCR
.c636	a636	29 ef		and #$ef			and 	#$EF 						; clear bit 4
.c638	a638	8d 00 d0	sta $d000			sta 	$D000
.c63b	a63b	9c 02 09	stz $0902			stz 	gxTilesOn 					; clear tiles on flag.
.c63e	a63e	18		clc				clc
.c63f	a63f	60		rts				rts
.c640	a640					_GXCTOn:
.c640	a640	8d 02 09	sta $0902			sta 	gxTilesOn 					; set tiles on flag.
.c643	a643	ad 00 d0	lda $d000			lda 	$D000	 					; turn tilemap on
.c646	a646	09 17		ora #$17			ora 	#$17
.c648	a648	8d 00 d0	sta $d000			sta 	$D000
.c64b	a64b	9c 0c d2	stz $d20c			stz 	$D20C 						; turn off tilemap#1 and tilemap#2
.c64e	a64e	9c 18 d2	stz $d218			stz 	$D218
.c651	a651	a9 40		lda #$40			lda 	#64 						; default size of 64x32
.c653	a653	8d 07 09	sta $0907			sta 	gxTileMapWidth
.c656	a656	a9 20		lda #$20			lda		#32
.c658	a658	8d 08 09	sta $0908			sta 	gxTileMapHeight
.c65b	a65b	ad 02 09	lda $0902			lda 	gxTilesOn 					; set the tile map page
.c65e	a65e	29 7f		and #$7f			and 	#$7F
.c660	a660	d0 02		bne $a664			bne	 	_GXCTNotMapDefault 			; check for default
.c662	a662	a9 12		lda #$12			lda 	#TILEMAP_ADDRESS >> 13
.c664	a664					_GXCTNotMapDefault:
.c664	a664	8d 06 09	sta $0906			sta 	gxTileMapPage
.c667	a667	a5 37		lda $37				lda 	gxzTemp0+1 					; set the tile image page
.c669	a669	d0 02		bne $a66d			bne 	_GXCTNotImgDefault 			; check for default
.c66b	a66b	a9 13		lda #$13			lda 	#TILEIMAGES_ADDRESS >> 13
.c66d	a66d					_GXCTNotImgDefault:
.c66d	a66d	8d 05 09	sta $0905			sta 	gxTileImagePage
.c670	a670	a9 11		lda #$11			lda 	#$11 						; set tilemap#0 on and 8x8
.c672	a672	8d 00 d2	sta $d200			sta 	$D200
.c675	a675	ad 06 09	lda $0906			lda 	gxTileMapPage 				; put tile map address in.
.c678	a678	20 cf a6	jsr $a6cf			jsr		GXCalculateBaseAddress
.c67b	a67b	9c 01 d2	stz $d201			stz 	$D201
.c67e	a67e	a5 36		lda $36				lda 	gxzTemp0
.c680	a680	8d 02 d2	sta $d202			sta 	$D202
.c683	a683	a5 37		lda $37				lda 	gxzTemp0+1
.c685	a685	8d 03 d2	sta $d203			sta 	$D203
.c688	a688	ad 07 09	lda $0907			lda 	gxTileMapWidth	 			; set tilemap size.
.c68b	a68b	8d 04 d2	sta $d204			sta 	$D204
.c68e	a68e	ad 08 09	lda $0908			lda 	gxTileMapHeight
.c691	a691	8d 06 d2	sta $d206			sta 	$D206
.c694	a694	9c 08 d2	stz $d208			stz 	$D208 						; clear scrolling register
.c697	a697	9c 09 d2	stz $d209			stz 	$D209
.c69a	a69a	9c 0a d2	stz $d20a			stz 	$D20A
.c69d	a69d	9c 0b d2	stz $d20b			stz 	$D20B
.c6a0	a6a0	ad 05 09	lda $0905			lda 	gxTileImagePage 			; set the tile image address
.c6a3	a6a3	20 cf a6	jsr $a6cf			jsr 	GXCalculateBaseAddress
.c6a6	a6a6	9c 80 d2	stz $d280			stz 	$D280
.c6a9	a6a9	a5 36		lda $36				lda 	gxzTemp0
.c6ab	a6ab	8d 81 d2	sta $d281			sta 	$D281
.c6ae	a6ae	a5 37		lda $37				lda 	gxzTemp0+1
.c6b0	a6b0	8d 82 d2	sta $d282			sta 	$D282
.c6b3	a6b3	18		clc				clc
.c6b4	a6b4	60		rts				rts
.c6b5	a6b5					GXControlTileSize:
.c6b5	a6b5	ad 02 09	lda $0902			lda 	gxTilesOn 					; check on
.c6b8	a6b8	38		sec				sec
.c6b9	a6b9	f0 13		beq $a6ce			beq 	_GXCTSExit
.c6bb	a6bb	64 01		stz $01				stz 	1 							; access I/O 0
.c6bd	a6bd	a5 36		lda $36				lda 	gxzTemp0 					; save parameter to registes
.c6bf	a6bf	8d 07 09	sta $0907			sta 	gxTileMapWidth
.c6c2	a6c2	8d 04 d2	sta $d204			sta 	$D204
.c6c5	a6c5	a5 37		lda $37				lda 	gxzTemp0+1
.c6c7	a6c7	8d 08 09	sta $0908			sta 	gxTileMapHeight
.c6ca	a6ca	8d 06 d2	sta $d206			sta 	$D206
.c6cd	a6cd	18		clc				clc
.c6ce	a6ce					_GXCTSExit:
.c6ce	a6ce	60		rts				rts
.c6cf	a6cf					GXCalculateBaseAddress:
.c6cf	a6cf	85 36		sta $36				sta 	gxzTemp0
.c6d1	a6d1	64 37		stz $37				stz 	gxzTemp0+1
.c6d3	a6d3	a9 05		lda #$05			lda 	#5
.c6d5	a6d5					_GXShift:
.c6d5	a6d5	06 36		asl $36				asl 	gxzTemp0
.c6d7	a6d7	26 37		rol $37				rol 	gxzTemp0+1
.c6d9	a6d9	3a		dec a				dec		a
.c6da	a6da	d0 f9		bne $a6d5			bne 	_GXShift
.c6dc	a6dc	60		rts				rts
.c6dd	a6dd					GXClearSpriteStore:
.c6dd	a6dd	a2 3f		ldx #$3f			ldx 	#63 						; erase 64 sprite store elements
.c6df	a6df					_GXCSSLoop:
.c6df	a6df	9e 55 09	stz $0955,x			stz 	gxSpriteHigh,x
.c6e2	a6e2	a9 80		lda #$80			lda 	#$80 						; set the 'hidden' bit.
.c6e4	a6e4	9d 15 09	sta $0915,x			sta 	gxSpriteLow,x
.c6e7	a6e7	ca		dex				dex
.c6e8	a6e8	10 f5		bpl $a6df			bpl 	_GXCSSLoop
.c6ea	a6ea	60		rts				rts
.c6eb	a6eb					GXLine:
.c6eb	a6eb	ad 01 09	lda $0901			lda 	gxBitmapsOn					; check bitmap on.
.c6ee	a6ee	f0 28		beq $a718			beq 	_GXLFail
.c6f0	a6f0	20 c2 ac	jsr $acc2			jsr 	GXOpenBitmap 				; access it.
.c6f3	a6f3	20 4f ae	jsr $ae4f			jsr 	GXSortY						; sort pairs so Y1 >= Y0 e.g. top to bottom.
.c6f6	a6f6	20 be a7	jsr $a7be			jsr 	GXLineSetup 				; the calculations in the linescanner constructor
.c6f9	a6f9	20 d2 ac	jsr $acd2			jsr 	gxPositionCalc 				; calculate position/offset.
.c6fc	a6fc					_GXDrawLoop:
.c6fc	a6fc	ac 0f 09	ldy $090f			ldy 	gxOffset 					; draw the pixel
.c6ff	a6ff	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.c701	a701	2d 0d 09	and $090d			and 	gxANDValue
.c704	a704	4d 0c 09	eor $090c			eor 	gxEORValue
.c707	a707	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.c709	a709	20 1a a7	jsr $a71a			jsr 	GXLineIsComplete 			; is the line complete ?
.c70c	a70c	f0 05		beq $a713			beq 	_GXLExit
.c70e	a70e	20 35 a7	jsr $a735			jsr 	GXLineAdvance 				; code as per advance method
.c711	a711	80 e9		bra $a6fc			bra 	_GXDrawLoop
.c713	a713					_GXLExit:
.c713	a713	20 ca ac	jsr $acca			jsr 	GXCloseBitmap 				; restore and return success.
.c716	a716	18		clc				clc
.c717	a717	60		rts				rts
.c718	a718					_GXLFail:
.c718	a718	38		sec				sec
.c719	a719	60		rts				rts
.c71a	a71a					GXLineIsComplete:
.c71a	a71a	ad 9f 09	lda $099f			lda 	gxIsDiffYLarger 			; is dy larger
.c71d	a71d	d0 0f		bne $a72e			bne 	_GXLICCompareY 				; if so compare Y1 versus Y0
.c71f	a71f	ad f8 08	lda $08f8			lda 	gxX0 						; compare X, LSB and MSB
.c722	a722	4d fc 08	eor $08fc			eor 	gxX1
.c725	a725	d0 06		bne $a72d			bne 	_GXLICExit
.c727	a727	ad f9 08	lda $08f9			lda 	gxX0+1
.c72a	a72a	4d fd 08	eor $08fd			eor 	gxX1+1
.c72d	a72d					_GXLICExit:
.c72d	a72d	60		rts				rts
.c72e	a72e					_GXLICCompareY:
.c72e	a72e	ad fe 08	lda $08fe			lda 	gxY1
.c731	a731	4d fa 08	eor $08fa			eor 	gxY0
.c734	a734	60		rts				rts
.c735	a735					GXLineAdvance:
.c735	a735	18		clc				clc 								; add adjust to position
.c736	a736	ad a1 09	lda $09a1			lda 	gxPosition
.c739	a739	6d a2 09	adc $09a2			adc 	gxAdjust
.c73c	a73c	8d a1 09	sta $09a1			sta 	gxPosition
.c73f	a73f	9c a4 09	stz $09a4			stz 	gxAddSelect 				; clear add select flag
.c742	a742	b0 05		bcs $a749			bcs 	_GXLAOverflow 				; if carry out, overflowed.
.c744	a744	cd a3 09	cmp $09a3			cmp 	gxTotal 					; if exceeded total
.c747	a747	90 0a		bcc $a753			bcc 	_GXLANoExtra
.c749	a749					_GXLAOverflow:
.c749	a749	ce a4 09	dec $09a4			dec 	gxAddSelect 				; set addselect to $FF
.c74c	a74c	38		sec				sec 								; subtract total and write back
.c74d	a74d	ed a3 09	sbc $09a3			sbc 	gxTotal
.c750	a750	8d a1 09	sta $09a1			sta 	gxPosition
.c753	a753					_GXLANoExtra:
.c753	a753	ad 9f 09	lda $099f			lda 	gxIsDiffYLarger
.c756	a756	f0 0d		beq $a765			beq 	_GXDXLarger
.c758	a758	20 b7 a7	jsr $a7b7			jsr 	GXIncrementY
.c75b	a75b	ad a4 09	lda $09a4			lda 	gxAddSelect
.c75e	a75e	f0 10		beq $a770			beq 	_GXLAExit
.c760	a760	20 71 a7	jsr $a771			jsr 	gxAdjustX
.c763	a763	80 0b		bra $a770			bra 	_GXLAExit
.c765	a765					_GXDXLarger:
.c765	a765	20 71 a7	jsr $a771			jsr 	gxAdjustX
.c768	a768	ad a4 09	lda $09a4			lda 	gxAddSelect
.c76b	a76b	f0 03		beq $a770			beq 	_GXLAExit
.c76d	a76d	20 b7 a7	jsr $a7b7			jsr 	GXIncrementY
.c770	a770					_GXLAExit:
.c770	a770	60		rts				rts
.c771	a771					gxAdjustX:
.c771	a771	ad a0 09	lda $09a0			lda 	gxDXNegative
.c774	a774	10 25		bpl $a79b			bpl 	_GXAXRight
.c776	a776	ad f8 08	lda $08f8			lda 	gxX0
.c779	a779	d0 03		bne $a77e			bne 	_GXAXNoBorrow
.c77b	a77b	ce f9 08	dec $08f9			dec 	gxX0+1
.c77e	a77e					_GXAXNoBorrow:
.c77e	a77e	ce f8 08	dec $08f8			dec 	gxX0
.c781	a781	ce 0f 09	dec $090f			dec 	gxOffset 					; pixel left
.c784	a784	ad 0f 09	lda $090f			lda 	gxOffset
.c787	a787	c9 ff		cmp #$ff			cmp 	#$FF
.c789	a789	d0 0f		bne $a79a			bne 	_GXAYExit 					; underflow
.c78b	a78b	c6 3d		dec $3d				dec 	gxzScreen+1 					; borrow
.c78d	a78d	a5 3d		lda $3d				lda 	gxzScreen+1 					; gone off page
.c78f	a78f	c9 60		cmp #$60			cmp 	#GXMappingAddress >> 8
.c791	a791	b0 07		bcs $a79a			bcs 	_GXAYExit
.c793	a793	18		clc				clc
.c794	a794	69 20		adc #$20			adc 	#$20 						; fix up
.c796	a796	85 3d		sta $3d				sta 	gxzScreen+1
.c798	a798	c6 0b		dec $0b				dec 	GXEditSlot 				; back one page
.c79a	a79a					_GXAYExit:
.c79a	a79a	60		rts				rts
.c79b	a79b					_GXAXRight:
.c79b	a79b	ee f8 08	inc $08f8			inc 	gxX0
.c79e	a79e	d0 03		bne $a7a3			bne 	_GXAXNoCarry
.c7a0	a7a0	ee f9 08	inc $08f9			inc 	gxX0+1
.c7a3	a7a3					_GXAXNoCarry:
.c7a3	a7a3	ee 0f 09	inc $090f			inc 	gxOffset 					; pixel right
.c7a6	a7a6	d0 0e		bne $a7b6			bne 	_GXAXExit 					; if not overflowed, exit.
.c7a8	a7a8	e6 3d		inc $3d				inc 	gxzScreen+1 					; next line
.c7aa	a7aa	a5 3d		lda $3d				lda 	gxzScreen+1
.c7ac	a7ac	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.c7ae	a7ae	90 06		bcc $a7b6			bcc 	_GXAXExit
.c7b0	a7b0	e9 20		sbc #$20			sbc 	#$20 						; fix up
.c7b2	a7b2	85 3d		sta $3d				sta 	gxzScreen+1
.c7b4	a7b4	e6 0b		inc $0b				inc 	GXEditSlot 				; next page
.c7b6	a7b6					_GXAXExit:
.c7b6	a7b6	60		rts				rts
.c7b7	a7b7					GXIncrementY:
.c7b7	a7b7	ee fa 08	inc $08fa			inc 	gxY0
.c7ba	a7ba	20 28 ad	jsr $ad28			jsr 	GXMovePositionDown
.c7bd	a7bd	60		rts				rts
.c7be	a7be					GXLineSetup:
.c7be	a7be	ad fe 08	lda $08fe			lda 	gxY1
.c7c1	a7c1	38		sec				sec
.c7c2	a7c2	ed fa 08	sbc $08fa			sbc 	gxY0
.c7c5	a7c5	4a		lsr a				lsr 	a
.c7c6	a7c6	8d 9e 09	sta $099e			sta 	gxDiffY
.c7c9	a7c9	9c a0 09	stz $09a0			stz 	gxDXNegative 				; clear -ve flag
.c7cc	a7cc	38		sec				sec
.c7cd	a7cd	ad fc 08	lda $08fc			lda 	gxX1
.c7d0	a7d0	ed f8 08	sbc $08f8			sbc 	gxX0
.c7d3	a7d3	8d 9d 09	sta $099d			sta 	gxDiffX
.c7d6	a7d6	ad fd 08	lda $08fd			lda 	gxX1+1 						; calculate MSB
.c7d9	a7d9	ed f9 08	sbc $08f9			sbc 	gxX0+1
.c7dc	a7dc	6a		ror a				ror 	a 							; rotate bit into DiffX halving it
.c7dd	a7dd	6e 9d 09	ror $099d			ror 	gxDiffX
.c7e0	a7e0	0a		asl a				asl 	a
.c7e1	a7e1	10 0c		bpl $a7ef			bpl 	_GDXNotNegative
.c7e3	a7e3	a9 00		lda #$00			lda 	#0 							; make absolute value of |dx|
.c7e5	a7e5	38		sec				sec
.c7e6	a7e6	ed 9d 09	sbc $099d			sbc 	gxDiffX
.c7e9	a7e9	8d 9d 09	sta $099d			sta 	gxDiffX
.c7ec	a7ec	ce a0 09	dec $09a0			dec 	gxDXNegative 				; -ve flag = $FF.
.c7ef	a7ef					_GDXNotNegative:
.c7ef	a7ef	9c 9f 09	stz $099f			stz 	gxIsDiffYLarger 			; clear larger flag
.c7f2	a7f2	ad 9e 09	lda $099e			lda 	gxDiffY 					; set adjust and total.
.c7f5	a7f5	8d a2 09	sta $09a2			sta 	gxAdjust
.c7f8	a7f8	ad 9d 09	lda $099d			lda 	gxDiffX
.c7fb	a7fb	8d a3 09	sta $09a3			sta 	gxTotal
.c7fe	a7fe	ad 9e 09	lda $099e			lda 	gxDiffY 					; if dy > dx
.c801	a801	cd 9d 09	cmp $099d			cmp 	gxDiffX
.c804	a804	90 0f		bcc $a815			bcc 	_GDXNotLarger
.c806	a806	ce 9f 09	dec $099f			dec 	gxIsDiffYLarger 			; set the dy larger flag
.c809	a809	ad 9d 09	lda $099d			lda 	gxDiffX 					; set adjust and total other way round
.c80c	a80c	8d a2 09	sta $09a2			sta 	gxAdjust
.c80f	a80f	ad 9e 09	lda $099e			lda 	gxDiffY
.c812	a812	8d a3 09	sta $09a3			sta 	gxTotal
.c815	a815					_GDXNotLarger:
.c815	a815	ad a3 09	lda $09a3			lda 	gxTotal
.c818	a818	4a		lsr a				lsr 	a
.c819	a819	8d a1 09	sta $09a1			sta 	gxPosition
.c81c	a81c	60		rts				rts
.099d						gxDiffX:
>099d								.fill 	1
.099e						gxDiffY:
>099e								.fill 	1
.099f						gxIsDiffYLarger:
>099f								.fill 	1
.09a0						gxDXNegative:
>09a0								.fill 	1
.09a1						gxPosition:
>09a1								.fill 	1
.09a2						gxAdjust:
>09a2								.fill 	1
.09a3						gxTotal:
>09a3								.fill 	1
.09a4						gxAddSelect:
>09a4								.fill 	1
.c81d	a81d					GXSetColourMode:
.c81d	a81d	a6 36		ldx $36				ldx 	gxzTemp0
.c81f	a81f	8e 0b 09	stx $090b			stx 	gxColour 								; set colour
.c822	a822	a5 37		lda $37				lda 	gxzTemp0+1 								;
.c824	a824	8d 0a 09	sta $090a			sta 	gxMode 									; set mode
.c827	a827	29 03		and #$03			and 	#3 										; only interested in bits 0-3
.c829	a829	9c 0d 09	stz $090d			stz 	gxANDValue 								; initially AND with 0, and EOR with Colour
.c82c	a82c	ae 0b 09	ldx $090b			ldx 	gxColour
.c82f	a82f	8e 0c 09	stx $090c			stx 	gxEORValue
.c832	a832	c9 02		cmp #$02			cmp 	#2 										; if mode 2/3 And with colour
.c834	a834	90 03		bcc $a839			bcc 	_GXSDCNotAndColour
.c836	a836	8e 0d 09	stx $090d			stx 	gxANDValue
.c839	a839					_GXSDCNotAndColour:
.c839	a839	d0 03		bne $a83e			bne 	_GXSDCNotAnd 							; mode 2, Don't EOR with colour
.c83b	a83b	9c 0c 09	stz $090c			stz 	gxEORValue
.c83e	a83e					_GXSDCNotAnd:
.c83e	a83e	4a		lsr a				lsr 	a 										; if bit 0 set, 1's complement AND value
.c83f	a83f	90 08		bcc $a849			bcc 	_GXSDCNoFlip
.c841	a841	ad 0d 09	lda $090d			lda	 	gxANDValue
.c844	a844	49 ff		eor #$ff			eor 	#$FF
.c846	a846	8d 0d 09	sta $090d			sta 	gxANDValue
.c849	a849					_GXSDCNoFlip:
.c849	a849	18		clc				clc
.c84a	a84a	60		rts				rts
.c84b	a84b					GXPlotPoint:
.c84b	a84b	20 c2 ac	jsr $acc2			jsr 	GXOpenBitmap 				; start drawing
.c84e	a84e	20 d2 ac	jsr $acd2			jsr 	gxPositionCalc 				; setup gxzScreen, gxOffset and the position.
.c851	a851	ac 0f 09	ldy $090f			ldy 	gxOffset
.c854	a854	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 				; set pixel on the right
.c856	a856	2d 0d 09	and $090d			and 	gxANDValue
.c859	a859	4d 0c 09	eor $090c			eor 	gxEORValue
.c85c	a85c	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.c85e	a85e	20 ca ac	jsr $acca			jsr 	GXCloseBitmap 				; stop drawing and exit
.c861	a861	18		clc				clc
.c862	a862	60		rts				rts
.c863	a863					GXFillRectangle:
.c863	a863	38		sec				sec 								; pass carry in for fill/frame
.c864	a864	80 01		bra $a867			bra 	GXRectangle
.c866	a866					GXFrameRectangle:
.c866	a866	18		clc				clc
.c867	a867					GXRectangle:
.c867	a867	ad 01 09	lda $0901			lda 	gxBitmapsOn 				; exit if off.
.c86a	a86a	f0 35		beq $a8a1			beq 	_GXRFail
.c86c	a86c	08		php				php 								; save Fill flag (CS)
.c86d	a86d	20 c2 ac	jsr $acc2			jsr 	GXOpenBitmap 				; start drawing
.c870	a870	20 31 ae	jsr $ae31			jsr 	GXSortXY 					; sort both X and Y so top left/bottom right
.c873	a873	20 d2 ac	jsr $acd2			jsr 	gxPositionCalc 				; setup gxzScreen, gxOffset and the position.
.c876	a876	38		sec				sec 								; sec = Draw line
.c877	a877	20 a3 a8	jsr $a8a3			jsr 	GXDrawLineX1X0 				; draw a line length X1-X0
.c87a	a87a	ad fa 08	lda $08fa			lda 	gxY0 						; reached end of rectangle ?
.c87d	a87d	cd fe 08	cmp $08fe			cmp 	gxY1 						; e.g. 1 pixel high.
.c880	a880	f0 19		beq $a89b			beq 	_GXRectangleExit
.c882	a882					_GXRectLoop:
.c882	a882	20 28 ad	jsr $ad28			jsr 	GXMovePositionDown 			; down one.
.c885	a885	ee fa 08	inc $08fa			inc 	gxY0 						; change Y pos
.c888	a888	ad fa 08	lda $08fa			lda 	gxY0 						; reached last line
.c88b	a88b	cd fe 08	cmp $08fe			cmp 	gxY1
.c88e	a88e	f0 07		beq $a897			beq 	_GXLastLine
.c890	a890	28		plp				plp 								; get flag back for solid/edged
.c891	a891	08		php				php
.c892	a892	20 a3 a8	jsr $a8a3			jsr 	GXDrawLineX1X0 				; draw horizontal line
.c895	a895	80 eb		bra $a882			bra 	_GXRectLoop
.c897	a897					_GXLastLine:
.c897	a897	38		sec				sec
.c898	a898	20 a3 a8	jsr $a8a3			jsr 	GXDrawLineX1X0
.c89b	a89b					_GXRectangleExit:
.c89b	a89b	68		pla				pla 								; throw fill flag.
.c89c	a89c	20 ca ac	jsr $acca			jsr 	GXCloseBitmap 				; stop drawing and exit
.c89f	a89f	18		clc				clc
.c8a0	a8a0	60		rts				rts
.c8a1	a8a1					_GXRFail:
.c8a1	a8a1	38		sec				sec
.c8a2	a8a2	60		rts				rts
.c8a3	a8a3					GXDrawLineX1X0:
.c8a3	a8a3	08		php				php 								; save solid/either-end
.c8a4	a8a4	38		sec				sec 								; calculate x1-x0
.c8a5	a8a5	ad fc 08	lda $08fc			lda		gxX1
.c8a8	a8a8	ed f8 08	sbc $08f8			sbc 	gxX0
.c8ab	a8ab	85 36		sta $36				sta 	gxzTemp0
.c8ad	a8ad	ad fd 08	lda $08fd			lda 	gxX1+1
.c8b0	a8b0	ed f9 08	sbc $08f9			sbc 	gxX0+1
.c8b3	a8b3	85 37		sta $37				sta 	gxzTemp0+1
.c8b5	a8b5	28		plp				plp
.c8b6	a8b6					GXDrawLineTemp0:
.c8b6	a8b6	a5 3c		lda $3c				lda 	gxzScreen 					; push gxzScreen, gxOffset and GXEditSlot on stack
.c8b8	a8b8	48		pha				pha
.c8b9	a8b9	a5 3d		lda $3d				lda 	gxzScreen+1
.c8bb	a8bb	48		pha				pha
.c8bc	a8bc	ad 0f 09	lda $090f			lda 	gxOffset
.c8bf	a8bf	48		pha				pha
.c8c0	a8c0	a5 0b		lda $0b				lda 	GXEditSlot
.c8c2	a8c2	48		pha				pha
.c8c3	a8c3	ac 0f 09	ldy $090f			ldy 	gxOffset 					; Y offset
.c8c6	a8c6	90 1e		bcc $a8e6			bcc 	_GXDLTEndPoints 			; if CC draw end points only.
.c8c8	a8c8					_GXDLTLine:
.c8c8	a8c8	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 				; set pixel
.c8ca	a8ca	2d 0d 09	and $090d			and 	gxANDValue
.c8cd	a8cd	4d 0c 09	eor $090c			eor 	gxEORValue
.c8d0	a8d0	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.c8d2	a8d2	a5 36		lda $36				lda 	gxzTemp0 					; decrement counter
.c8d4	a8d4	d0 04		bne $a8da			bne 	_GXDLTNoBorrow
.c8d6	a8d6	c6 37		dec $37				dec 	gxzTemp0+1 					; borrow, if goes -ve then exit
.c8d8	a8d8	30 2e		bmi $a908			bmi 	_GXDLTExit
.c8da	a8da					_GXDLTNoBorrow:
.c8da	a8da	c6 36		dec $36				dec 	gxzTemp0
.c8dc	a8dc	c8		iny				iny 								; next slot.
.c8dd	a8dd	d0 e9		bne $a8c8			bne 	_GXDLTLine
.c8df	a8df	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.c8e1	a8e1	20 16 a9	jsr $a916			jsr 	GXDLTCheckWrap				; check for new page.
.c8e4	a8e4	80 e2		bra $a8c8			bra 	_GXDLTLine
.c8e6	a8e6					_GXDLTEndPoints:
.c8e6	a8e6	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 				; set pixel
.c8e8	a8e8	2d 0d 09	and $090d			and 	gxANDValue
.c8eb	a8eb	4d 0c 09	eor $090c			eor 	gxEORValue
.c8ee	a8ee	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.c8f0	a8f0	98		tya				tya 								; advance to right side
.c8f1	a8f1	18		clc				clc
.c8f2	a8f2	65 36		adc $36				adc 	gxzTemp0
.c8f4	a8f4	a8		tay				tay
.c8f5	a8f5	a5 3d		lda $3d				lda 	gxzScreen+1
.c8f7	a8f7	65 37		adc $37				adc 	gxzTemp0+1
.c8f9	a8f9	85 3d		sta $3d				sta 	gxzScreen+1
.c8fb	a8fb	20 16 a9	jsr $a916			jsr 	GXDLTCheckWrap 				; fix up.
.c8fe	a8fe	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 				; set pixel on the right
.c900	a900	2d 0d 09	and $090d			and 	gxANDValue
.c903	a903	4d 0c 09	eor $090c			eor 	gxEORValue
.c906	a906	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.c908	a908					_GXDLTExit:
.c908	a908	68		pla				pla
.c909	a909	85 0b		sta $0b				sta 	GXEditSlot
.c90b	a90b	68		pla				pla
.c90c	a90c	8d 0f 09	sta $090f			sta 	gxOffset
.c90f	a90f	68		pla				pla
.c910	a910	85 3d		sta $3d				sta 	gxzScreen+1
.c912	a912	68		pla				pla
.c913	a913	85 3c		sta $3c				sta 	gxzScreen
.c915	a915	60		rts				rts
.c916	a916					GXDLTCheckWrap:
.c916	a916	a5 3d		lda $3d				lda 	gxzScreen+1 				; check end of page
.c918	a918	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8)
.c91a	a91a	90 06		bcc $a922			bcc 	_GXDLTCWExit
.c91c	a91c	e9 20		sbc #$20			sbc 	#$20 						; fix up
.c91e	a91e	85 3d		sta $3d				sta 	gxzScreen+1
.c920	a920	e6 0b		inc $0b				inc 	GXEditSlot 					; next bitmap vram page.
.c922	a922					_GXDLTCWExit:
.c922	a922	60		rts				rts
.c923	a923					GXDrawGraphicElement:
.c923	a923	8d a5 09	sta $09a5			sta 	gxSize 						; save size
.c926	a926	3a		dec a				dec 	a
.c927	a927	8d a6 09	sta $09a6			sta 	gxMask 						; and mask
.c92a	a92a	ad 01 09	lda $0901			lda 	gxBitmapsOn 				; check BMP on
.c92d	a92d	f0 67		beq $a996			beq 	_GXSLFail
.c92f	a92f	ad fa 08	lda $08fa			lda 	gxY0 						; push Y on stack
.c932	a932	48		pha				pha
.c933	a933	8c a8 09	sty $09a8			sty 	gxAcquireVector+1 			; and acquisition vector
.c936	a936	8e a7 09	stx $09a7			stx 	gxAcquireVector
.c939	a939	20 c2 ac	jsr $acc2			jsr 	GXOpenBitmap 				; open the bitmap.
.c93c	a93c	ad aa 09	lda $09aa			lda 	gxUseMode 					; scale bits
.c93f	a93f	4a		lsr a				lsr 	a
.c940	a940	4a		lsr a				lsr 	a
.c941	a941	4a		lsr a				lsr 	a
.c942	a942	29 07		and #$07			and		#7
.c944	a944	1a		inc a				inc 	a
.c945	a945	8d a9 09	sta $09a9			sta 	gxScale
.c948	a948	64 38		stz $38				stz 	gxzTemp1					; start first line
.c94a	a94a					_GXGELoop:
.c94a	a94a	a5 38		lda $38				lda 	gxzTemp1 					; current line number to read.
.c94c	a94c	2c aa 09	bit $09aa			bit 	gxUseMode 					; check for flip.
.c94f	a94f	10 06		bpl $a957			bpl		_GXNoVFlip
.c951	a951	ad a6 09	lda $09a6			lda 	gxMask
.c954	a954	38		sec				sec
.c955	a955	e5 38		sbc $38				sbc 	gxzTemp1
.c957	a957					_GXNoVFlip:
.c957	a957	aa		tax				tax 								; get the Xth line.
.c958	a958	20 98 a9	jsr $a998			jsr 	_GXCallAcquire 				; get that data.
.c95b	a95b	ad a9 09	lda $09a9			lda 	gxScale 					; do scale identical copies of that line.
.c95e	a95e	85 39		sta $39				sta 	gxzTemp1+1
.c960	a960					_GXGELoop2:
.c960	a960	ad fa 08	lda $08fa			lda 	gxY0 						; off screen
.c963	a963	cd 09 09	cmp $0909			cmp 	gxHeight
.c966	a966	b0 10		bcs $a978			bcs 	_GXDGEExit
.c968	a968	20 9b a9	jsr $a99b			jsr 	GXRenderOneLine 			; render line
.c96b	a96b	c6 39		dec $39				dec 	gxzTemp1+1 					; scale times.
.c96d	a96d	d0 f1		bne $a960			bne 	_GXGELoop2
.c96f	a96f	e6 38		inc $38				inc 	gxzTemp1 					; done all lines.
.c971	a971	a5 38		lda $38				lda 	gxzTemp1
.c973	a973	cd a5 09	cmp $09a5			cmp 	gxSize
.c976	a976	d0 d2		bne $a94a			bne 	_GXGELoop
.c978	a978					_GXDGEExit:
.c978	a978	68		pla				pla 								; restore Y for next time
.c979	a979	8d fa 08	sta $08fa			sta 	gxY0
.c97c	a97c	ae a9 09	ldx $09a9			ldx 	gxScale 					; get scale (1-8)
.c97f	a97f					_GXShiftLeft:
.c97f	a97f	18		clc				clc
.c980	a980	ad a5 09	lda $09a5			lda 	gxSize
.c983	a983	6d f8 08	adc $08f8			adc 	gxX0
.c986	a986	8d f8 08	sta $08f8			sta 	gxX0
.c989	a989	90 03		bcc $a98e			bcc 	_GXSLNoCarry
.c98b	a98b	ee f9 08	inc $08f9			inc 	gxX0+1
.c98e	a98e					_GXSLNoCarry:
.c98e	a98e	ca		dex				dex
.c98f	a98f	d0 ee		bne $a97f			bne 	_GXShiftLeft
.c991	a991	20 ca ac	jsr $acca			jsr 	GXCloseBitmap
.c994	a994	18		clc				clc
.c995	a995	60		rts				rts
.c996	a996					_GXSLFail:
.c996	a996	38		sec				sec
.c997	a997	60		rts				rts
.c998	a998					_GXCallAcquire:
.c998	a998	6c a7 09	jmp ($09a7)			jmp 	(gxAcquireVector)
.c99b	a99b					GXRenderOneLine:
.c99b	a99b	20 d2 ac	jsr $acd2			jsr 	gxPositionCalc 				; calculate position/offset.
.c99e	a99e	ac 0f 09	ldy $090f			ldy 	gxOffset 					; Y contains position.
.c9a1	a9a1	64 3a		stz $3a				stz 	gxzTemp2 					; do size pixels
.c9a3	a9a3					_GXROLLoop1:
.c9a3	a9a3	ad a9 09	lda $09a9			lda 	gxScale 					; set to do 'scale' times
.c9a6	a9a6	85 3b		sta $3b				sta 	gxzTemp2+1
.c9a8	a9a8					_GXROLLoop2:
.c9a8	a9a8	a5 3a		lda $3a				lda 	gxzTemp2 					; get current pixel
.c9aa	a9aa	2c 0a 09	bit $090a			bit 	gxMode 						; check H Flip
.c9ad	a9ad	50 06		bvc $a9b5			bvc 	_GXNoHFlip
.c9af	a9af	ad a6 09	lda $09a6			lda 	gxMask
.c9b2	a9b2	38		sec				sec
.c9b3	a9b3	e5 3a		sbc $3a				sbc 	gxzTemp2
.c9b5	a9b5					_GXNoHFlip:
.c9b5	a9b5	aa		tax				tax 								; read from the pixel buffer
.c9b6	a9b6	bd 43 06	lda $0643,x			lda 	gxPixelBuffer,x
.c9b9	a9b9	d0 07		bne $a9c2			bne 	_GXDraw 					; draw if non zero
.c9bb	a9bb	ad aa 09	lda $09aa			lda 	gxUseMode 					; check to see if solid background
.c9be	a9be	29 04		and #$04			and 	#4
.c9c0	a9c0	f0 0a		beq $a9cc			beq 	_GXZeroPixel
.c9c2	a9c2					_GXDraw:
.c9c2	a9c2	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.c9c4	a9c4	2d 0d 09	and $090d			and 	gxANDValue
.c9c7	a9c7	5d 43 06	eor $0643,x			eor 	gxPixelBuffer,x
.c9ca	a9ca	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.c9cc	a9cc					_GXZeroPixel:
.c9cc	a9cc	c8		iny				iny 								; advance pointer
.c9cd	a9cd	d0 05		bne $a9d4			bne 	_GXNoShift
.c9cf	a9cf	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.c9d1	a9d1	20 16 a9	jsr $a916			jsr 	GXDLTCheckWrap				; check for new page.
.c9d4	a9d4					_GXNoShift:
.c9d4	a9d4	c6 3b		dec $3b				dec 	gxzTemp2+1 					; do the inner loop gxScale times.
.c9d6	a9d6	d0 d0		bne $a9a8			bne 	_GXROLLoop2
.c9d8	a9d8	e6 3a		inc $3a				inc 	gxzTemp2 					; next pixel.
.c9da	a9da	a5 3a		lda $3a				lda 	gxzTemp2
.c9dc	a9dc	cd a5 09	cmp $09a5			cmp 	gxSize
.c9df	a9df	d0 c2		bne $a9a3			bne 	_GXROLLoop1
.c9e1	a9e1	ee fa 08	inc $08fa			inc 	gxY0
.c9e4	a9e4	60		rts				rts
.09a5						gxSize:
>09a5								.fill 	1
.09a6						gxMask:
>09a6								.fill 	1
.09a7						gxAcquireVector:
>09a7								.fill 	2
.09a9						gxScale:
>09a9								.fill 	1
.09aa						gxUseMode:
>09aa								.fill 	1
.c9e5	a9e5					GXControlTileScrollX:
.c9e5	a9e5	ad 07 09	lda $0907			lda 	gxTileMapWidth 				; comparator value (max X tile)
.c9e8	a9e8	20 07 aa	jsr $aa07			jsr 	GXScrollProcessor 			; scroll processing.
.c9eb	a9eb	b0 08		bcs $a9f5			bcs 	_GXCTSExit
.c9ed	a9ed	64 01		stz $01				stz 	1 							; write it out.
.c9ef	a9ef	8e 08 d2	stx $d208			stx 	$D208
.c9f2	a9f2	8c 09 d2	sty $d209			sty 	$D209
.c9f5	a9f5					_GXCTSExit:
.c9f5	a9f5	60		rts				rts
.c9f6	a9f6					GXControlTileScrollY:
.c9f6	a9f6	ad 08 09	lda $0908			lda 	gxTileMapHeight 			; comparator value (max X tile)
.c9f9	a9f9	20 07 aa	jsr $aa07			jsr 	GXScrollProcessor 			; scroll processing.
.c9fc	a9fc	b0 08		bcs $aa06			bcs 	_GXCTSExit
.c9fe	a9fe	64 01		stz $01				stz 	1 							; write it out.
.ca00	aa00	8e 0a d2	stx $d20a			stx 	$D20A
.ca03	aa03	8c 0b d2	sty $d20b			sty 	$D20B
.ca06	aa06					_GXCTSExit:
.ca06	aa06	60		rts				rts
.ca07	aa07					GXScrollProcessor:
.ca07	aa07	85 38		sta $38				sta 	gxzTemp1 					; save max tile value.
.ca09	aa09	ad 02 09	lda $0902			lda 	gxTilesOn 					; check tile map is on.
.ca0c	aa0c	38		sec				sec
.ca0d	aa0d	f0 2c		beq $aa3b			beq 	_GXSPExit
.ca0f	aa0f	64 39		stz $39				stz 	gxzTemp1+1 					; convert tile size to a pixel scroll.
.ca11	aa11	a2 03		ldx #$03			ldx 	#3
.ca13	aa13					_GXCalcMaxPixelScroll:
.ca13	aa13	06 38		asl $38				asl 	gxzTemp1
.ca15	aa15	26 39		rol $39				rol 	gxzTemp1+1
.ca17	aa17	ca		dex				dex
.ca18	aa18	d0 f9		bne $aa13			bne 	_GXCalcMaxPixelScroll
.ca1a	aa1a	a5 36		lda $36				lda 	gxzTemp0 					; check scroll in range.
.ca1c	aa1c	c5 38		cmp $38				cmp 	gxzTemp1
.ca1e	aa1e	a5 37		lda $37				lda 	gxzTemp0+1
.ca20	aa20	e5 39		sbc $39				sbc 	gxzTemp1+1
.ca22	aa22	b0 17		bcs $aa3b			bcs		_GXSPExit
.ca24	aa24	a5 36		lda $36				lda 	gxzTemp0 	 				; save fine scroll.
.ca26	aa26	29 07		and #$07			and		#7
.ca28	aa28	85 38		sta $38				sta 	gxzTemp1
.ca2a	aa2a	06 36		asl $36				asl 	gxzTemp0 					; shift left one, as whole tiles are 8 pixels.
.ca2c	aa2c	26 37		rol $37				rol 	gxzTemp0+1
.ca2e	aa2e	a5 37		lda $37				lda 	gxzTemp0+1 					; MSB is the upper byte.
.ca30	aa30	29 0f		and #$0f			and 	#$0F
.ca32	aa32	a8		tay				tay
.ca33	aa33	a5 36		lda $36				lda 	gxzTemp0 					; get coarse scroll
.ca35	aa35	29 f0		and #$f0			and 	#$F0
.ca37	aa37	05 38		ora $38				ora 	gxzTemp1 					; OR in fine scroll.
.ca39	aa39	aa		tax				tax 								; return in X
.ca3a	aa3a	18		clc				clc
.ca3b	aa3b					_GXSPExit:
.ca3b	aa3b	60		rts				rts
.ca3c	aa3c					GXFontHandler:
.ca3c	aa3c	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.ca3e	aa3e	4d 0a 09	eor $090a			eor 	gxMode
.ca41	aa41	8d aa 09	sta $09aa			sta 	gxUseMode
.ca44	aa44	64 37		stz $37				stz 	gxzTemp0+1 					; gxzTemp0 is font #
.ca46	aa46	06 36		asl $36				asl	 	gxzTemp0 					; x 2
.ca48	aa48	26 37		rol $37				rol	 	gxzTemp0+1
.ca4a	aa4a	06 36		asl $36				asl	 	gxzTemp0 					; x 4
.ca4c	aa4c	26 37		rol $37				rol	 	gxzTemp0+1
.ca4e	aa4e	06 36		asl $36				asl	 	gxzTemp0 					; x 8
.ca50	aa50	26 37		rol $37				rol	 	gxzTemp0+1
.ca52	aa52	a5 37		lda $37				lda 	gxzTemp0+1 					; put in page C0
.ca54	aa54	09 c0		ora #$c0			ora 	#$C0
.ca56	aa56	85 37		sta $37				sta 	gxzTemp0+1
.ca58	aa58	a9 08		lda #$08			lda 	#8 							; size 8x8
.ca5a	aa5a	a2 62		ldx #$62			ldx 	#GXGetGraphicDataFont & $FF ; XY = Graphic Data retrieval routine
.ca5c	aa5c	a0 aa		ldy #$aa			ldy 	#GXGetGraphicDataFont >> 8
.ca5e	aa5e	20 23 a9	jsr $a923			jsr 	GXDrawGraphicElement
.ca61	aa61	60		rts				rts
.ca62	aa62					GXGetGraphicDataFont:
.ca62	aa62	8a		txa				txa 								; X->Y
.ca63	aa63	a8		tay				tay
.ca64	aa64	a6 01		ldx $01				ldx 	1 							; preserve old value
.ca66	aa66	a9 01		lda #$01			lda 	#1 							; access page 1 (font memory)
.ca68	aa68	85 01		sta $01				sta 	1
.ca6a	aa6a	b1 36		lda ($36),y			lda 	(gxzTemp0),y 				; read the font element.
.ca6c	aa6c	86 01		stx $01				stx 	1 							; put old value back.
.ca6e	aa6e	a2 00		ldx #$00			ldx 	#0 							; do 8 times
.ca70	aa70					_GXExpand:
.ca70	aa70	9e 43 06	stz $0643,x			stz 	gxPixelBuffer,x 			; zero in pixel buffer
.ca73	aa73	0a		asl a				asl 	a 							; shift bit 7 into C
.ca74	aa74	90 08		bcc $aa7e			bcc 	_GXNoPixel
.ca76	aa76	48		pha				pha 								; if set, set pixel buffer to current colour.
.ca77	aa77	ad 0b 09	lda $090b			lda 	gxColour
.ca7a	aa7a	9d 43 06	sta $0643,x			sta 	gxPixelBuffer,x
.ca7d	aa7d	68		pla				pla
.ca7e	aa7e					_GXNoPixel:
.ca7e	aa7e	e8		inx				inx 								; do the whole byte.
.ca7f	aa7f	e0 08		cpx #$08			cpx 	#8
.ca81	aa81	d0 ed		bne $aa70			bne 	_GXExpand
.ca83	aa83	60		rts				rts
.ca84	aa84					GXSpriteHandler:
.ca84	aa84	ad 00 09	lda $0900			lda 	gxSpritesOn 				; sprites on ?
.ca87	aa87	f0 23		beq $aaac			beq 	_GXSHExit
.ca89	aa89	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.ca8b	aa8b	4d 0a 09	eor $090a			eor 	gxMode
.ca8e	aa8e	8d aa 09	sta $09aa			sta 	gxUseMode
.ca91	aa91	a6 36		ldx $36				ldx 	gxzTemp0 					; sprite #
.ca93	aa93	da		phx				phx
.ca94	aa94	20 c2 ac	jsr $acc2			jsr 	GXOpenBitmap 				; can access sprite information
.ca97	aa97	68		pla				pla
.ca98	aa98	20 a3 ad	jsr $ada3			jsr 	GXFindSprite 				; get the sprite address
.ca9b	aa9b	08		php				php
.ca9c	aa9c	20 ca ac	jsr $acca			jsr 	GXCloseBitmap
.ca9f	aa9f	28		plp				plp
.caa0	aaa0	b0 0a		bcs $aaac			bcs		_GXSHExit 					; exit if find failed.
.caa2	aaa2	ad ab 09	lda $09ab			lda 	gxSizePixels 				; return size
.caa5	aaa5	a2 ad		ldx #$ad			ldx 	#GXSpriteAcquire & $FF
.caa7	aaa7	a0 aa		ldy #$aa			ldy 	#GXSpriteAcquire >> 8
.caa9	aaa9	20 23 a9	jsr $a923			jsr 	GXDrawGraphicElement
.caac	aaac					_GXSHExit:
.caac	aaac	60		rts				rts
.caad	aaad					GXSpriteAcquire:
.caad	aaad	ad 04 09	lda $0904			lda 	gxSpritePage				; point to base page
.cab0	aab0	85 0b		sta $0b				sta 	GXEditSlot
.cab2	aab2	86 36		stx $36				stx 	gxzTemp0 					; row number x 1,2,3,4
.cab4	aab4	a9 00		lda #$00			lda 	#0
.cab6	aab6	ae ac 09	ldx $09ac			ldx 	gxSizeBits
.cab9	aab9					_GXTimesRowNumber:
.cab9	aab9	18		clc				clc
.caba	aaba	65 36		adc $36				adc 	gxzTemp0
.cabc	aabc	ca		dex				dex
.cabd	aabd	10 fa		bpl $aab9			bpl 	_GXTimesRowNumber
.cabf	aabf	64 37		stz $37				stz 	gxzTemp0+1
.cac1	aac1	0a		asl a				asl 	a 							; row x 2,4,6,8
.cac2	aac2	26 37		rol $37				rol 	gxzTemp0+1
.cac4	aac4	0a		asl a				asl 	a 							; row x 4,8,12,16
.cac5	aac5	26 37		rol $37				rol 	gxzTemp0+1
.cac7	aac7	0a		asl a				asl 	a 							; row x 8,16,24,32
.cac8	aac8	26 37		rol $37				rol 	gxzTemp0+1
.caca	aaca	85 36		sta $36				sta 	gxzTemp0
.cacc	aacc	18		clc				clc 								; add base address.
.cacd	aacd	a5 36		lda $36				lda 	gxzTemp0
.cacf	aacf	6d ae 09	adc $09ae			adc 	gxSpriteOffset
.cad2	aad2	85 36		sta $36				sta 	gxzTemp0
.cad4	aad4	a5 37		lda $37				lda 	gxzTemp0+1
.cad6	aad6	6d af 09	adc $09af			adc 	gxSpriteOffset+1
.cad9	aad9					_GXSAFindPage:
.cad9	aad9	c9 20		cmp #$20			cmp 	#$20 						; on this page
.cadb	aadb	90 06		bcc $aae3			bcc 	_GXSAFoundPage
.cadd	aadd	e9 20		sbc #$20			sbc 	#$20 						; forward one page
.cadf	aadf	e6 0b		inc $0b				inc 	GXEditSlot
.cae1	aae1	80 f6		bra $aad9			bra 	_GXSAFindPage
.cae3	aae3					_GXSAFoundPage:
.cae3	aae3	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; physical address of page.
.cae5	aae5	85 37		sta $37				sta 	gxzTemp0+1 					; gxzTemp0 now points to the page
.cae7	aae7	a0 00		ldy #$00			ldy 	#0
.cae9	aae9					_GXSACopyLoop:
.cae9	aae9	b1 36		lda ($36),y			lda 	(gxzTemp0),y
.caeb	aaeb	99 43 06	sta $0643,y			sta 	gxPixelBuffer,y
.caee	aaee	c8		iny				iny
.caef	aaef	cc ab 09	cpy $09ab			cpy 	gxSizePixels
.caf2	aaf2	d0 f5		bne $aae9			bne 	_GXSACopyLoop
.caf4	aaf4	60		rts				rts
.caf5	aaf5					GXSelect:
.caf5	aaf5	ad 00 09	lda $0900			lda 	gxSpritesOn
.caf8	aaf8	f0 22		beq $ab1c			beq 	_GXSFail
.cafa	aafa	a5 36		lda $36				lda 	gxzTemp0 					; illegal sprite #
.cafc	aafc	c9 40		cmp #$40			cmp 	#64
.cafe	aafe	b0 1c		bcs $ab1c			bcs 	_GXSFail
.cb00	ab00	8d 10 09	sta $0910			sta 	GSCurrentSpriteID
.cb03	ab03	a4 37		ldy $37				ldy 	gxzTemp0+1 					; control value.
.cb05	ab05	a9 00		lda #$00			lda  	#0 							; multiply sprite # x 8 => A
.cb07	ab07	06 36		asl $36				asl 	gxzTemp0
.cb09	ab09	06 36		asl $36				asl 	gxzTemp0
.cb0b	ab0b	06 36		asl $36				asl 	gxzTemp0
.cb0d	ab0d	2a		rol a				rol 	a
.cb0e	ab0e	69 d9		adc #$d9			adc 	#$D9 						; sprite area
.cb10	ab10	8d 12 09	sta $0912			sta 	GSCurrentSpriteAddr+1 		; address to GSCurrentSprite and gxzTemp
.cb13	ab13	85 37		sta $37				sta 	gxzTemp0+1
.cb15	ab15	a5 36		lda $36				lda 	gxzTemp0
.cb17	ab17	8d 11 09	sta $0911			sta 	GSCurrentSpriteAddr
.cb1a	ab1a	18		clc				clc
.cb1b	ab1b	60		rts				rts
.cb1c	ab1c					_GXSFail:
.cb1c	ab1c	38		sec				sec
.cb1d	ab1d	60		rts				rts
.cb1e	ab1e					GXSelectImage:
.cb1e	ab1e	ad 00 09	lda $0900			lda 	gxSpritesOn
.cb21	ab21	f0 74		beq $ab97			beq 	_GXSIFail
.cb23	ab23	ad 12 09	lda $0912			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.cb26	ab26	f0 6f		beq $ab97			beq 	_GXSIFail 					; (checking the MSB)
.cb28	ab28	64 01		stz $01				stz 	1
.cb2a	ab2a	a5 37		lda $37				lda 	gxzTemp0+1 					; push show/hide on the stack.
.cb2c	ab2c	d0 6b		bne $ab99			bne 	_GXSIHide
.cb2e	ab2e	a5 36		lda $36				lda 	gxzTemp0 					; sprite image
.cb30	ab30	48		pha				pha
.cb31	ab31	20 c2 ac	jsr $acc2			jsr 	GXOpenBitmap
.cb34	ab34	68		pla				pla
.cb35	ab35	20 a3 ad	jsr $ada3			jsr 	GXFindSprite
.cb38	ab38	b0 5a		bcs $ab94			bcs 	_GXSICloseFail 				; no image
.cb3a	ab3a	a0 01		ldy #$01			ldy 	#1
.cb3c	ab3c	ad 11 09	lda $0911			lda 	GSCurrentSpriteAddr
.cb3f	ab3f	85 36		sta $36				sta 	gxzTemp0
.cb41	ab41	ad 12 09	lda $0912			lda 	GSCurrentSpriteAddr+1
.cb44	ab44	85 37		sta $37				sta 	gxzTemp0+1
.cb46	ab46	ad ae 09	lda $09ae			lda 	gxSpriteOffset
.cb49	ab49	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.cb4b	ab4b	18		clc				clc
.cb4c	ab4c	ad af 09	lda $09af			lda 	gxSpriteOffset+1
.cb4f	ab4f	6d 13 09	adc $0913			adc 	gxSpriteOffsetBase
.cb52	ab52	c8		iny				iny
.cb53	ab53	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.cb55	ab55	ad 14 09	lda $0914			lda 	gxSpriteOffsetBase+1
.cb58	ab58	69 00		adc #$00			adc 	#0
.cb5a	ab5a	c8		iny				iny
.cb5b	ab5b	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.cb5d	ab5d	ad ac 09	lda $09ac			lda 	gxSizeBits 					; get raw size
.cb60	ab60	49 03		eor #$03			eor 	#3 							; make it right (00=32 etc.)
.cb62	ab62	2a		rol a				rol 	a 							; x 2
.cb63	ab63	0a		asl a				asl 	a 							; x 4
.cb64	ab64	0a		asl a				asl 	a 							; x 8
.cb65	ab65	0a		asl a				asl 	a 							; x 16
.cb66	ab66	0d ad 09	ora $09ad			ora 	gxSpriteLUT 				; Or with LUT
.cb69	ab69	0a		asl a				asl 	a 							; 1 shift
.cb6a	ab6a	09 01		ora #$01			ora 	#1 							; enable sprite.
.cb6c	ab6c	92 36		sta ($36)			sta 	(gxzTemp0) 					; and write back
.cb6e	ab6e	20 ca ac	jsr $acca			jsr 	GXCloseBitmap
.cb71	ab71	ae 10 09	ldx $0910			ldx 	GSCurrentSpriteID 			; point to sprite entries.
.cb74	ab74	bd 55 09	lda $0955,x			lda 	gxSpriteHigh,x 				; clear upper two bits of size
.cb77	ab77	29 3f		and #$3f			and 	#$3F
.cb79	ab79	9d 55 09	sta $0955,x			sta 	gxSpriteHigh,x
.cb7c	ab7c	ad ac 09	lda $09ac			lda 	gxSizeBits 					; get bit size
.cb7f	ab7f	6a		ror a				ror 	a 							; shift into bits 6/7
.cb80	ab80	6a		ror a				ror 	a
.cb81	ab81	6a		ror a				ror 	a
.cb82	ab82	29 c0		and #$c0			and 	#$C0
.cb84	ab84	1d 55 09	ora $0955,x			ora 	gxSpriteHigh,x 				; put in  upper 2 bits of sprite data
.cb87	ab87	9d 55 09	sta $0955,x			sta 	gxSpriteHigh,x
.cb8a	ab8a	bd 15 09	lda $0915,x			lda 	gxSpriteLow,x 				; clear hidden flag.
.cb8d	ab8d	29 7f		and #$7f			and 	#$7F
.cb8f	ab8f	9d 15 09	sta $0915,x			sta 	gxSpriteLow,x
.cb92	ab92	18		clc				clc
.cb93	ab93	60		rts				rts
.cb94	ab94					_GXSICloseFail:
.cb94	ab94	20 ca ac	jsr $acca			jsr 	GXCloseBitmap
.cb97	ab97					_GXSIFail:
.cb97	ab97	38		sec				sec
.cb98	ab98	60		rts				rts
.cb99	ab99					_GXSIHide:
.cb99	ab99	ad 11 09	lda $0911			lda 	GSCurrentSpriteAddr  		; get Sprite h/w address and write there
.cb9c	ab9c	85 36		sta $36				sta 	gxzTemp0
.cb9e	ab9e	ad 12 09	lda $0912			lda 	GSCurrentSpriteAddr+1
.cba1	aba1	85 37		sta $37				sta 	gxzTemp0+1
.cba3	aba3	a9 00		lda #$00			lda 	#0
.cba5	aba5	92 36		sta ($36)			sta 	(gxzTemp0)
.cba7	aba7	ae 10 09	ldx $0910			ldx 	GSCurrentSpriteID 			; get sprite ID
.cbaa	abaa	bd 15 09	lda $0915,x			lda 	gxSpriteLow,x 				; set the hidden bit.
.cbad	abad	09 80		ora #$80			ora 	#$80
.cbaf	abaf	9d 15 09	sta $0915,x			sta 	gxSpriteLow,x
.cbb2	abb2	18		clc				clc
.cbb3	abb3	60		rts				rts
.cbb4	abb4					GXMoveSprite:
.cbb4	abb4	ad 00 09	lda $0900			lda 	gxSpritesOn
.cbb7	abb7	f0 65		beq $ac1e			beq 	_GXSIFail
.cbb9	abb9	ad 12 09	lda $0912			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.cbbc	abbc	f0 60		beq $ac1e			beq 	_GXSIFail
.cbbe	abbe	85 37		sta $37				sta 	gxzTemp0+1
.cbc0	abc0	a0 04		ldy #$04			ldy 	#4
.cbc2	abc2	ad 11 09	lda $0911			lda 	GSCurrentSpriteAddr
.cbc5	abc5	85 36		sta $36				sta 	gxzTemp0
.cbc7	abc7	ae 10 09	ldx $0910			ldx 	GSCurrentSpriteID 			; get the size from the upper two bits
.cbca	abca	bd 55 09	lda $0955,x			lda 	gxSpriteHigh,x
.cbcd	abcd	2a		rol a				rol 	a	 						; into bits 0,1.
.cbce	abce	2a		rol a				rol 	a
.cbcf	abcf	2a		rol a				rol 	a
.cbd0	abd0	29 03		and #$03			and 	#3
.cbd2	abd2	aa		tax				tax
.cbd3	abd3	bd 20 ac	lda $ac20,x			lda 	_GXMSOffset,x 				; get 32-SpriteSize/2
.cbd6	abd6	48		pha				pha
.cbd7	abd7	18		clc				clc
.cbd8	abd8	6d f8 08	adc $08f8			adc 	gxX0						; copy position.
.cbdb	abdb	91 36		sta ($36),y			sta 	(gxzTemp0),y
.cbdd	abdd	c8		iny				iny
.cbde	abde	ad f9 08	lda $08f9			lda 	gxX0+1
.cbe1	abe1	69 00		adc #$00			adc 	#0
.cbe3	abe3	91 36		sta ($36),y			sta 	(gxzTemp0),y
.cbe5	abe5	c8		iny				iny
.cbe6	abe6	68		pla				pla
.cbe7	abe7	18		clc				clc
.cbe8	abe8	6d fa 08	adc $08fa			adc 	gxY0
.cbeb	abeb	91 36		sta ($36),y			sta 	(gxzTemp0),y
.cbed	abed	a9 00		lda #$00			lda 	#0
.cbef	abef	69 00		adc #$00			adc 	#0
.cbf1	abf1	c8		iny				iny
.cbf2	abf2	91 36		sta ($36),y			sta 	(gxzTemp0),y
.cbf4	abf4	4e f9 08	lsr $08f9			lsr 	gxX0+1 						; divide X by 4
.cbf7	abf7	6e f8 08	ror $08f8			ror 	gxX0
.cbfa	abfa	4e f8 08	lsr $08f8			lsr 	gxX0
.cbfd	abfd	4e fa 08	lsr $08fa			lsr 	gxY0 						; divide Y by 4
.cc00	ac00	4e fa 08	lsr $08fa			lsr 	gxY0
.cc03	ac03	ae 10 09	ldx $0910			ldx 	GSCurrentSpriteID 			; copy X/4 and Y/4 into the status bytes
.cc06	ac06	bd 15 09	lda $0915,x			lda 	gxSpriteLow,x
.cc09	ac09	29 80		and #$80			and 	#$80
.cc0b	ac0b	0d f8 08	ora $08f8			ora 	gxX0
.cc0e	ac0e	9d 15 09	sta $0915,x			sta 	gxSpriteLow,x
.cc11	ac11	bd 55 09	lda $0955,x			lda 	gxSpriteHigh,x
.cc14	ac14	29 c0		and #$c0			and 	#$C0
.cc16	ac16	0d fa 08	ora $08fa			ora 	gxY0
.cc19	ac19	9d 55 09	sta $0955,x			sta 	gxSpriteHigh,x
.cc1c	ac1c	18		clc				clc
.cc1d	ac1d	60		rts				rts
.cc1e	ac1e					_GXSIFail:
.cc1e	ac1e	38		sec				sec
.cc1f	ac1f	60		rts				rts
.cc20	ac20					_GXMSOffset:
>cc20	ac20	1c						.byte 	32-8/2
>cc21	ac21	18						.byte 	32-16/2
>cc22	ac22	14						.byte 	32-24/2
>cc23	ac23	10						.byte 	32-32/2
.cc24	ac24					GXSelectTile:
.cc24	ac24	ad 02 09	lda $0902			lda 	gxTilesOn 					; check tilemap in use
.cc27	ac27	f0 4b		beq $ac74			beq 	_GXSFail
.cc29	ac29	a5 36		lda $36				lda 	gxzTemp0 					; check X and Y in range
.cc2b	ac2b	cd 07 09	cmp $0907			cmp 	gxTileMapWidth
.cc2e	ac2e	b0 44		bcs $ac74			bcs 	_GXSFail
.cc30	ac30	a5 37		lda $37				lda 	gxzTemp0+1
.cc32	ac32	cd 08 09	cmp $0908			cmp 	gxTileMapHeight
.cc35	ac35	b0 3d		bcs $ac74			bcs 	_GXSFail
.cc37	ac37	ad 06 09	lda $0906			lda 	gxTileMapPage 				; page to access = tile access page.
.cc3a	ac3a	8d 95 09	sta $0995			sta 	gxTileAccessPage
.cc3d	ac3d	ae 07 09	ldx $0907			ldx 	gxTileMapWidth 				; YX is the additive, e.g. shifted left. gxzTemp0+1 is shifted right.
.cc40	ac40	a0 00		ldy #$00			ldy 	#0
.cc42	ac42	a5 36		lda $36				lda 	gxzTemp0 					; initial result is X
.cc44	ac44	8d 96 09	sta $0996			sta 	gxTileAccessAddress
.cc47	ac47	9c 97 09	stz $0997			stz  	gxTileAccessAddress+1
.cc4a	ac4a					_GXSTMultiply:
.cc4a	ac4a	46 37		lsr $37				lsr 	gxzTemp0+1 					; shift Y right
.cc4c	ac4c	90 0f		bcc $ac5d			bcc 	_GXSTNoAdd 					; add if CS
.cc4e	ac4e	18		clc				clc 								; add YX to result
.cc4f	ac4f	8a		txa				txa
.cc50	ac50	6d 96 09	adc $0996			adc 	gxTileAccessAddress
.cc53	ac53	8d 96 09	sta $0996			sta 	gxTileAccessAddress
.cc56	ac56	98		tya				tya
.cc57	ac57	6d 97 09	adc $0997			adc 	gxTileAccessAddress+1
.cc5a	ac5a	8d 97 09	sta $0997			sta 	gxTileAccessAddress+1
.cc5d	ac5d					_GXSTNoAdd:
.cc5d	ac5d	8a		txa				txa 								; shift YX left
.cc5e	ac5e	0a		asl a				asl 	a
.cc5f	ac5f	aa		tax				tax
.cc60	ac60	98		tya				tya
.cc61	ac61	2a		rol a				rol 	a
.cc62	ac62	a8		tay				tay
.cc63	ac63	a5 37		lda $37				lda 	gxzTemp0+1 					; multiply complete
.cc65	ac65	d0 e3		bne $ac4a			bne 	_GXSTMultiply
.cc67	ac67	0e 96 09	asl $0996			asl 	gxTileAccessAddress 		; double it, as it is a word array.
.cc6a	ac6a	2e 97 09	rol $0997			rol 	gxTileAccessAddress+1
.cc6d	ac6d					_GXSTFixAddressLoop:
.cc6d	ac6d	20 76 ac	jsr $ac76			jsr 	GXSTFixAddress
.cc70	ac70	b0 fb		bcs $ac6d			bcs 	_GXSTFixAddressLoop
.cc72	ac72	18		clc				clc
.cc73	ac73	60		rts				rts
.cc74	ac74					_GXSFail:
.cc74	ac74	38		sec				sec
.cc75	ac75	60		rts				rts
.cc76	ac76					GXSTFixAddress:
.cc76	ac76	48		pha				pha
.cc77	ac77	ad 97 09	lda $0997			lda 	gxTileAccessAddress+1 		; in legal page range e.g. $0000-$1FFF
.cc7a	ac7a	c9 20		cmp #$20			cmp 	#$20
.cc7c	ac7c	90 06		bcc $ac84			bcc 	_GXSTFAExit
.cc7e	ac7e	e9 20		sbc #$20			sbc 	#$20 						; adjust address
.cc80	ac80	ee 95 09	inc $0995			inc 	gxTileAccessPage 			; adjust page up.
.cc83	ac83	38		sec				sec
.cc84	ac84					_GXSTFAExit:
.cc84	ac84	68		pla				pla
.cc85	ac85	60		rts				rts
.cc86	ac86					GXSTWriteTile:
.cc86	ac86	38		sec				sec 								; CS = update flag
.cc87	ac87	80 01		bra $ac8a			bra 	GXSTTileAccess
.cc89	ac89					GXSTReadTile:
.cc89	ac89	18		clc				clc
.cc8a	ac8a					GXSTTileAccess:
.cc8a	ac8a	a5 0b		lda $0b				lda 	GXEditSlot 					; save oroginal page
.cc8c	ac8c	48		pha				pha
.cc8d	ac8d	08		php				php 								; save update flag
.cc8e	ac8e	ad 95 09	lda $0995			lda 	gxTileAccessPage 			; access the tile page.
.cc91	ac91	85 0b		sta $0b				sta 	GXEditSlot
.cc93	ac93	a6 36		ldx $36				ldx 	gxzTemp0 					; X = New value
.cc95	ac95	ad 96 09	lda $0996			lda 	gxTileAccessAddress 		; set gxzTemp0 to point there
.cc98	ac98	85 36		sta $36				sta 	gxzTemp0
.cc9a	ac9a	ad 97 09	lda $0997			lda 	gxTileAccessAddress+1
.cc9d	ac9d	09 60		ora #$60			ora 	#(GXMappingAddress >> 8)
.cc9f	ac9f	85 37		sta $37				sta 	gxzTemp0+1
.cca1	aca1	28		plp				plp 								; get flag
.cca2	aca2	90 09		bcc $acad			bcc 	_GXSNoUpdate 				; updating the tile map ?
.cca4	aca4	8a		txa				txa 								; new value
.cca5	aca5	92 36		sta ($36)			sta 	(gxzTemp0) 					; write it out, as a word.
.cca7	aca7	a0 01		ldy #$01			ldy 	#1
.cca9	aca9	a9 00		lda #$00			lda 	#0
.ccab	acab	91 36		sta ($36),y			sta 	(gxzTemp0),y
.ccad	acad					_GXSNoUpdate:
.ccad	acad	b2 36		lda ($36)			lda 	(gxzTemp0) 					; read the value
.ccaf	acaf	fa		plx				plx 								; restore old page
.ccb0	acb0	86 0b		stx $0b				stx 	GXEditSlot
.ccb2	acb2	ee 96 09	inc $0996			inc 	gxTileAccessAddress 		; advance tile ptr by 2 - will always be even.
.ccb5	acb5	ee 96 09	inc $0996			inc 	gxTileAccessAddress
.ccb8	acb8	d0 03		bne $acbd			bne 	_GXSNoCarry
.ccba	acba	ee 97 09	inc $0997			inc 	gxTileAccessAddress+1
.ccbd	acbd					_GXSNoCarry:
.ccbd	acbd	20 76 ac	jsr $ac76			jsr 	GXSTFixAddress 				; fix address if required.
.ccc0	acc0	18		clc				clc 								; return with ok flag.
.ccc1	acc1	60		rts				rts
.ccc2	acc2					GXOpenBitmap:
.ccc2	acc2	78		sei				sei 								; no interrupts here
.ccc3	acc3	a5 0b		lda $0b				lda 	GXEditSlot 					; Save the original LUT slot value
.ccc5	acc5	8d 0e 09	sta $090e			sta 	gxOriginalLUTValue
.ccc8	acc8	58		cli				cli
.ccc9	acc9	60		rts				rts
.ccca	acca					GXCloseBitmap:
.ccca	acca	78		sei				sei
.cccb	accb	ad 0e 09	lda $090e			lda 	gxOriginalLUTValue 			; restore LUT slot value
.ccce	acce	85 0b		sta $0b				sta 	GXEditSlot
.ccd0	acd0	58		cli				cli
.ccd1	acd1	60		rts				rts
.ccd2	acd2					gxPositionCalc:
.ccd2	acd2	a5 36		lda $36				lda 	gxzTemp0 						; save temp memory slot
.ccd4	acd4	48		pha				pha
.ccd5	acd5	ad fa 08	lda $08fa			lda 	gxY0 							; gxzScreen = Y0
.ccd8	acd8	85 3c		sta $3c				sta 	gxzScreen
.ccda	acda	64 3d		stz $3d				stz 	gxzScreen+1
.ccdc	acdc	06 3c		asl $3c				asl 	gxzScreen 						; gxzScreen = Y0 * 4
.ccde	acde	26 3d		rol $3d				rol 	gxzScreen+1
.cce0	ace0	06 3c		asl $3c				asl 	gxzScreen
.cce2	ace2	26 3d		rol $3d				rol 	gxzScreen+1
.cce4	ace4	18		clc				clc 									; gxzScreen = Y0 * 5, as it's still in A
.cce5	ace5	65 3c		adc $3c				adc 	gxzScreen
.cce7	ace7	85 3c		sta $3c				sta 	gxzScreen
.cce9	ace9	90 02		bcc $aced			bcc 	_GXPCNoCarry
.cceb	aceb	e6 3d		inc $3d				inc 	gxzScreen+1
.cced	aced					_GXPCNoCarry:
.cced	aced	06 3c		asl $3c				asl 	gxzScreen 						; now Y0 * 10
.ccef	acef	26 3d		rol $3d				rol 	gxzScreen+1
.ccf1	acf1	a5 3d		lda $3d				lda	 	gxzScreen+1
.ccf3	acf3	85 36		sta $36				sta 	gxzTemp0 						; the page offset.
.ccf5	acf5	64 3d		stz $3d				stz 	gxzScreen+1
.ccf7	acf7	a9 05		lda #$05			lda 	#5 								; now multiply by 32, this puts this in the range 0..8191
.ccf9	acf9					_GXPCMultiply32:
.ccf9	acf9	06 3c		asl $3c				asl 	gxzScreen
.ccfb	acfb	26 3d		rol $3d				rol 	gxzScreen+1
.ccfd	acfd	3a		dec a				dec 	a
.ccfe	acfe	d0 f9		bne $acf9			bne 	_GXPCMultiply32
.cd00	ad00	18		clc				clc
.cd01	ad01	ad f8 08	lda $08f8			lda 	gxX0 						; add X to this value, put the result in gxOffset, gxzScreen has to be on a page boundary
.cd04	ad04	65 3c		adc $3c				adc 	gxzScreen
.cd06	ad06	8d 0f 09	sta $090f			sta 	gxOffset
.cd09	ad09	ad f9 08	lda $08f9			lda 	gxX0+1
.cd0c	ad0c	65 3d		adc $3d				adc 	gxzScreen+1
.cd0e	ad0e	c9 20		cmp #$20			cmp 	#$20 						; has it overflowed into the next one ?
.cd10	ad10	90 04		bcc $ad16			bcc 	_GXPCNoOverflow
.cd12	ad12	29 1f		and #$1f			and 	#$1F 						; fix it up
.cd14	ad14	e6 36		inc $36				inc 	gxzTemp0 					; add 1 to the page number
.cd16	ad16					_GXPCNoOverflow:
.cd16	ad16	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; make it the address mapped in.
.cd18	ad18	85 3d		sta $3d				sta 	gxzScreen+1
.cd1a	ad1a	64 3c		stz $3c				stz 	gxzScreen
.cd1c	ad1c	18		clc				clc
.cd1d	ad1d	a5 36		lda $36				lda 	gxzTemp0 					; get the page number
.cd1f	ad1f	6d 03 09	adc $0903			adc 	gxBasePage 					; by adding the base page
.cd22	ad22	85 0b		sta $0b				sta 	GXEditSlot 					; and map it into memory.
.cd24	ad24	68		pla				pla
.cd25	ad25	85 36		sta $36				sta 	gxzTemp0
.cd27	ad27	60		rts				rts
.cd28	ad28					GXMovePositionDown:
.cd28	ad28	18		clc				clc 								; add 320 to offset/temp+1
.cd29	ad29	ad 0f 09	lda $090f			lda 	gxOffset
.cd2c	ad2c	69 40		adc #$40			adc 	#64
.cd2e	ad2e	8d 0f 09	sta $090f			sta 	gxOffset
.cd31	ad31	a5 3d		lda $3d				lda 	gxzScreen+1
.cd33	ad33	69 01		adc #$01			adc 	#1
.cd35	ad35	85 3d		sta $3d				sta 	gxzScreen+1
.cd37	ad37	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.cd39	ad39	90 07		bcc $ad42			bcc 	_GXMPDExit
.cd3b	ad3b	38		sec				sec  								; next page, adjust address
.cd3c	ad3c	e9 20		sbc #$20			sbc 	#$20
.cd3e	ad3e	85 3d		sta $3d				sta 	gxzScreen+1
.cd40	ad40	e6 0b		inc $0b				inc 	GXEditSlot 					; bump page
.cd42	ad42					_GXMPDExit:
.cd42	ad42	60		rts				rts
.cd43	ad43					GXCollide:
.cd43	ad43	a5 36		lda $36				lda 	gxzTemp0 					; check if sprite numbers are legal.
.cd45	ad45	aa		tax				tax
.cd46	ad46	05 37		ora $37				ora 	gxzTemp0+1
.cd48	ad48	29 c0		and #$c0			and 	#$C0
.cd4a	ad4a	38		sec				sec
.cd4b	ad4b	d0 53		bne $ada0			bne 	_GXCollideFail 				; if either >= 64, fail.
.cd4d	ad4d	a4 37		ldy $37				ldy 	gxzTemp0+1 					; at this point X is 1st sprite and Y is 2nd sprite.
.cd4f	ad4f	b9 15 09	lda $0915,y			lda 	gxSpriteLow,y 				; check if either hidden bit is set
.cd52	ad52	1d 15 09	ora $0915,x			ora 	gxSpriteLow,x
.cd55	ad55	30 48		bmi $ad9f			bmi 	_GXOkayFail 				; if either hidden, then they cannot collide.
.cd57	ad57	18		clc				clc 								; need to calculate sum of sizes.
.cd58	ad58	b9 55 09	lda $0955,y			lda 	gxSpriteHigh,y
.cd5b	ad5b	7d 55 09	adc $0955,x			adc 	gxSpriteHigh,x 				; at this point, CS, Bit 6 and 7 contain that sum.
.cd5e	ad5e	29 c0		and #$c0			and 	#$C0 					 	; mask off
.cd60	ad60	6a		ror a				ror 	a 							; 5/6/7
.cd61	ad61	4a		lsr a				lsr 	a 							; 4/5/6
.cd62	ad62	4a		lsr a				lsr 	a 							; 3/4/5
.cd63	ad63	4a		lsr a				lsr 	a 							; 2/3/4
.cd64	ad64	18		clc				clc
.cd65	ad65	69 08		adc #$08			adc 	#$08
.cd67	ad67	4a		lsr a				lsr 	a 							; adjust because all coordinates are divided by 4 to store.
.cd68	ad68	4a		lsr a				lsr 	a
.cd69	ad69	85 38		sta $38				sta 	gxzTemp1 					; so the difference between the centres has to be less than this.
.cd6b	ad6b	b9 55 09	lda $0955,y			lda 	gxSpriteHigh,y 				; calculate y1-y0
.cd6e	ad6e	29 3f		and #$3f			and 	#$3F
.cd70	ad70	85 39		sta $39				sta 	gxzTemp1+1
.cd72	ad72	38		sec				sec
.cd73	ad73	bd 55 09	lda $0955,x			lda 	gxSpriteHigh,x
.cd76	ad76	29 3f		and #$3f			and 	#$3F
.cd78	ad78	e5 39		sbc $39				sbc 	gxzTemp1+1
.cd7a	ad7a	b0 03		bcs $ad7f			bcs 	_GXCAbs1 					; calculate |y1-y0|
.cd7c	ad7c	49 ff		eor #$ff			eor 	#$FF
.cd7e	ad7e	1a		inc a				inc 	a
.cd7f	ad7f					_GXCAbs1:
.cd7f	ad7f	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.cd81	ad81	b0 1c		bcs $ad9f			bcs 	_GXOkayFail
.cd83	ad83	85 39		sta $39				sta 	gxzTemp1+1 					; save |y1-y0|
.cd85	ad85	38		sec				sec 								; calculate |x1-x0|
.cd86	ad86	b9 15 09	lda $0915,y			lda 	gxSpriteLow,y
.cd89	ad89	fd 15 09	sbc $0915,x			sbc 	gxSpriteLow,x
.cd8c	ad8c	b0 03		bcs $ad91			bcs 	_GXCAbs2
.cd8e	ad8e	49 ff		eor #$ff			eor 	#$FF
.cd90	ad90	1a		inc a				inc 	a
.cd91	ad91					_GXCAbs2:
.cd91	ad91	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.cd93	ad93	b0 0a		bcs $ad9f			bcs 	_GXOkayFail
.cd95	ad95	c5 39		cmp $39				cmp 	gxzTemp1+1 					; is it less than the previous one.
.cd97	ad97	90 02		bcc $ad9b			bcc 	_GXCHaveLowest
.cd99	ad99	a5 39		lda $39				lda 	gxzTemp1+1 					; if not, that's the smallest difference.
.cd9b	ad9b					_GXCHaveLowest:
.cd9b	ad9b	0a		asl a				asl 	a 							; scale to allow for >> 2
.cd9c	ad9c	0a		asl a				asl 	a
.cd9d	ad9d	18		clc				clc
.cd9e	ad9e	60		rts				rts
.cd9f	ad9f					_GXOkayFail:
.cd9f	ad9f	18		clc				clc
.cda0	ada0					_GXCollideFail:
.cda0	ada0	a9 ff		lda #$ff			lda 	#$FF
.cda2	ada2	60		rts				rts
.cda3	ada3					GXFindSprite:
.cda3	ada3	aa		tax				tax  								; sprite index in X
.cda4	ada4	9c ae 09	stz $09ae			stz 	gxSpriteOffset 				; sprite offset is the offset in the sprite list.
.cda7	ada7	9c af 09	stz $09af			stz 	gxSpriteOffset+1
.cdaa	adaa	64 38		stz $38				stz 	gxzTemp1 					; zTemp1 is the address in memory, given the current selected page.
.cdac	adac	a9 60		lda #$60			lda 	#GXMappingAddress >> 8
.cdae	adae	85 39		sta $39				sta 	gxzTemp1+1
.cdb0	adb0	ad 04 09	lda $0904			lda 	gxSpritePage 				; and point to the sprite page.
.cdb3	adb3	85 0b		sta $0b				sta 	GXEditSlot
.cdb5	adb5	b2 38		lda ($38)			lda 	(gxzTemp1) 					; get the first sprite record header, identifying the format.
.cdb7	adb7	c9 11		cmp #$11			cmp 	#$11						; should be $11
.cdb9	adb9	d0 6c		bne $ae27			bne 	_GXFSFail 					; if not, fail
.cdbb	adbb	20 0d ae	jsr $ae0d			jsr 	_GXFSIncrement 				; increment pointers.
.cdbe	adbe					_GXFindLoop:
.cdbe	adbe	b2 38		lda ($38)			lda 	(gxzTemp1) 					; reached the end, if so then failed.
.cdc0	adc0	c9 80		cmp #$80			cmp 	#$80
.cdc2	adc2	f0 63		beq $ae27			beq 	_GXFSFail
.cdc4	adc4	e0 00		cpx #$00			cpx 	#0 							; if zero, then found.
.cdc6	adc6	f0 2c		beq $adf4			beq 	_GXFSFound
.cdc8	adc8	ca		dex				dex 								; decrement count.
.cdc9	adc9	0a		asl a				asl 	a 							; index into table
.cdca	adca	a8		tay				tay 								; so we can look it up.
.cdcb	adcb	18		clc				clc 								; add LSB
.cdcc	adcc	ad ae 09	lda $09ae			lda 	gxSpriteOffset
.cdcf	adcf	79 29 ae	adc $ae29,y			adc 	_GXFSSizeTable,y
.cdd2	add2	8d ae 09	sta $09ae			sta 	gxSpriteOffset 				; these two should move in lock step.
.cdd5	add5	85 38		sta $38				sta 	gxzTemp1
.cdd7	add7	90 05		bcc $adde			bcc 	_GXNextNoCarry 				; adjust for carry as we add the MSB seperately.
.cdd9	add9	ee af 09	inc $09af			inc 	gxSpriteOffset+1
.cddc	addc	e6 39		inc $39				inc 	gxzTemp1+1
.cdde	adde					_GXNextNoCarry:
.cdde	adde	18		clc				clc
.cddf	addf	a5 39		lda $39				lda 	gxzTemp1+1 					; add MSB
.cde1	ade1	79 2a ae	adc $ae2a,y			adc 	_GXFSSizeTable+1,y
.cde4	ade4	85 39		sta $39				sta 	gxzTemp1+1
.cde6	ade6	ad af 09	lda $09af			lda 	gxSpriteOffset+1
.cde9	ade9	79 2a ae	adc $ae2a,y			adc 	_GXFSSizeTable+1,y
.cdec	adec	8d af 09	sta $09af			sta 	gxSpriteOffset+1
.cdef	adef	20 19 ae	jsr $ae19			jsr 	_GXFSNormalise 				; and normalise the page address.
.cdf2	adf2	80 ca		bra $adbe			bra 	_GXFindLoop 				; and go round again.
.cdf4	adf4					_GXFSFound:
.cdf4	adf4	b2 38		lda ($38)			lda 	(gxzTemp1)					; get the bit size (e.g. 0-3)
.cdf6	adf6	8d ac 09	sta $09ac			sta 	gxSizeBits
.cdf9	adf9	1a		inc a				inc 	a 							; 1,2,3,4 - calculating pixel size
.cdfa	adfa	0a		asl a				asl 	a 							; 2,4,6,8
.cdfb	adfb	0a		asl a				asl 	a 							; 4,8,12,16
.cdfc	adfc	0a		asl a				asl 	a 							; 8,16,24,32
.cdfd	adfd	8d ab 09	sta $09ab			sta 	gxSizePixels
.ce00	ae00	20 0d ae	jsr $ae0d			jsr 	_GXFSIncrement 				; and to the LUT
.ce03	ae03	b2 38		lda ($38)			lda 	(gxzTemp1) 					; copy that out.
.ce05	ae05	8d ad 09	sta $09ad			sta 	gxSpriteLUT
.ce08	ae08	20 0d ae	jsr $ae0d			jsr 	_GXFSIncrement 				; and it now points to the first graphic data byte
.ce0b	ae0b	18		clc				clc
.ce0c	ae0c	60		rts				rts
.ce0d	ae0d					_GXFSIncrement:
.ce0d	ae0d	ee ae 09	inc $09ae			inc 	gxSpriteOffset 				; these two should move in sync
.ce10	ae10	e6 38		inc $38				inc 	gxzTemp1
.ce12	ae12	d0 05		bne $ae19			bne 	_GXFSNormalise
.ce14	ae14	ee af 09	inc $09af			inc 	gxSpriteOffset+1
.ce17	ae17	e6 39		inc $39				inc 	gxzTemp1+1
.ce19	ae19					_GXFSNormalise:
.ce19	ae19	a5 39		lda $39				lda 	gxzTemp1+1 					; are we out of range.
.ce1b	ae1b	c9 80		cmp #$80			cmp 	#(GXMappingAddress >> 8)+$20
.ce1d	ae1d	90 07		bcc $ae26			bcc 	_GXFSOkay
.ce1f	ae1f	e6 0b		inc $0b				inc 	GXEditSlot 					; next 8k page
.ce21	ae21	38		sec				sec 								; adjust page address back
.ce22	ae22	e9 20		sbc #$20			sbc 	#$20
.ce24	ae24	85 39		sta $39				sta 	gxzTemp1+1
.ce26	ae26					_GXFSOkay:
.ce26	ae26	60		rts				rts
.ce27	ae27					_GXFSFail:
.ce27	ae27	38		sec				sec
.ce28	ae28	60		rts				rts
.ce29	ae29					_GXFSSizeTable:
>ce29	ae29	42 00 02 01 42 02 02 04				.word 	8*8+2,16*16+2,24*24+2,32*32+2
.09ab						gxSizePixels:
>09ab								.fill 	1
.09ac						gxSizeBits:
>09ac								.fill 	1
.09ad						gxSpriteLUT:
>09ad								.fill 	1
.09ae						gxSpriteOffset:
>09ae								.fill 	2
.ce31	ae31					GXSortXY:
.ce31	ae31	20 4f ae	jsr $ae4f			jsr 	GXSortY 					; will be sorted on Y now
.ce34	ae34	ad f8 08	lda $08f8			lda 	gxX0 						; compare X0 v X1
.ce37	ae37	cd fc 08	cmp $08fc			cmp 	gxX1
.ce3a	ae3a	ad f9 08	lda $08f9			lda 	gxX0+1
.ce3d	ae3d	ed fd 08	sbc $08fd			sbc 	gxX1+1
.ce40	ae40	90 0c		bcc $ae4e			bcc 	_GXSXYExit 					; X0 < X1 exit
.ce42	ae42	a2 00		ldx #$00			ldx 	#0 							; swap them over
.ce44	ae44	a0 04		ldy #$04			ldy 	#4
.ce46	ae46	20 63 ae	jsr $ae63			jsr 	GXSwapXY
.ce49	ae49	e8		inx				inx
.ce4a	ae4a	c8		iny				iny
.ce4b	ae4b	20 63 ae	jsr $ae63			jsr 	GXSwapXY
.ce4e	ae4e					_GXSXYExit:
.ce4e	ae4e	60		rts				rts
.ce4f	ae4f					GXSortY:
.ce4f	ae4f	ad fa 08	lda $08fa			lda 	gxY0 						; if Y0 >= Y1
.ce52	ae52	cd fe 08	cmp $08fe			cmp 	gxY1
.ce55	ae55	90 0b		bcc $ae62			bcc 	_GXSYSorted
.ce57	ae57	a2 03		ldx #$03			ldx 	#3 							; swap 3-0 - for lines we want to sort but keep lines together
.ce59	ae59	a0 07		ldy #$07			ldy 	#7 							; with 4-7
.ce5b	ae5b					_GXSwap1:
.ce5b	ae5b	20 63 ae	jsr $ae63			jsr 	GXSwapXY
.ce5e	ae5e	88		dey				dey
.ce5f	ae5f	ca		dex				dex
.ce60	ae60	10 f9		bpl $ae5b			bpl 	_GXSwap1
.ce62	ae62					_GXSYSorted:
.ce62	ae62	60		rts				rts
.ce63	ae63					GXSwapXY:
.ce63	ae63	bd f8 08	lda $08f8,x			lda 	gxX0,x
.ce66	ae66	48		pha				pha
.ce67	ae67	b9 f8 08	lda $08f8,y			lda 	gxX0,y
.ce6a	ae6a	9d f8 08	sta $08f8,x			sta 	gxX0,x
.ce6d	ae6d	68		pla				pla
.ce6e	ae6e	99 f8 08	sta $08f8,y			sta 	gxX0,y
.ce71	ae71	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/.build/tokeniser.module.asm

=1						tokeniserIntegrated=1
.ce72	ae72					KeywordSet0:
>ce72	ae72	00 65					.text	0,$65,""               ; $80 !0:EOF
>ce74	ae74	00 58					.text	0,$58,""               ; $81 !1:SH1
>ce76	ae76	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>ce78	ae78	04 fe 41 42 53 28			.text	4,$fe,"ABS("           ; $83 ABS(
>ce7e	ae7e	06 93 41 4c 4c 4f 43 28			.text	6,$93,"ALLOC("         ; $84 ALLOC(
>ce86	ae86	04 ff 41 53 43 28			.text	4,$ff,"ASC("           ; $85 ASC(
>ce8c	ae8c	05 29 43 48 52 24 28			.text	5,$29,"CHR$("          ; $86 CHR$(
>ce93	ae93	06 aa 45 56 45 4e 54 28			.text	6,$aa,"EVENT("         ; $87 EVENT(
>ce9b	ae9b	05 6b 46 41 4c 53 45			.text	5,$6b,"FALSE"          ; $88 FALSE
>cea2	aea2	05 44 46 52 41 43 28			.text	5,$44,"FRAC("          ; $89 FRAC(
>cea9	aea9	05 2c 47 45 54 24 28			.text	5,$2c,"GET$("          ; $8a GET$(
>ceb0	aeb0	04 08 47 45 54 28			.text	4,$08,"GET("           ; $8b GET(
>ceb6	aeb6	09 4a 47 45 54 44 41 54			.text	9,$4a,"GETDATE$("      ; $8c GETDATE$(
>cebe	aebe	45 24 28
>cec1	aec1	09 5b 47 45 54 54 49 4d			.text	9,$5b,"GETTIME$("      ; $8d GETTIME$(
>cec9	aec9	45 24 28
>cecc	aecc	04 0d 48 49 54 28			.text	4,$0d,"HIT("           ; $8e HIT(
>ced2	aed2	07 cc 49 4e 4b 45 59 24			.text	7,$cc,"INKEY$("        ; $8f INKEY$(
>ceda	aeda	28
>cedb	aedb	06 a8 49 4e 4b 45 59 28			.text	6,$a8,"INKEY("         ; $90 INKEY(
>cee3	aee3	04 13 49 4e 54 28			.text	4,$13,"INT("           ; $91 INT(
>cee9	aee9	06 a7 49 53 56 41 4c 28			.text	6,$a7,"ISVAL("         ; $92 ISVAL(
>cef1	aef1	0a e0 49 54 45 4d 43 4f			.text	10,$e0,"ITEMCOUNT("     ; $93 ITEMCOUNT(
>cef9	aef9	55 4e 54 28
>cefd	aefd	09 5b 49 54 45 4d 47 45			.text	9,$5b,"ITEMGET$("      ; $94 ITEMGET$(
>cf05	af05	54 24 28
>cf08	af08	05 5c 4a 4f 59 42 28			.text	5,$5c,"JOYB("          ; $95 JOYB(
>cf0f	af0f	05 72 4a 4f 59 58 28			.text	5,$72,"JOYX("          ; $96 JOYX(
>cf16	af16	05 73 4a 4f 59 59 28			.text	5,$73,"JOYY("          ; $97 JOYY(
>cf1d	af1d	08 49 4b 45 59 44 4f 57			.text	8,$49,"KEYDOWN("       ; $98 KEYDOWN(
>cf25	af25	4e 28
>cf27	af27	06 77 4c 45 46 54 24 28			.text	6,$77,"LEFT$("         ; $99 LEFT$(
>cf2f	af2f	04 07 4c 45 4e 28			.text	4,$07,"LEN("           ; $9a LEN(
>cf35	af35	04 0e 4d 41 58 28			.text	4,$0e,"MAX("           ; $9b MAX(
>cf3b	af3b	05 26 4d 49 44 24 28			.text	5,$26,"MID$("          ; $9c MID$(
>cf42	af42	04 0c 4d 49 4e 28			.text	4,$0c,"MIN("           ; $9d MIN(
>cf48	af48	04 19 4e 4f 54 28			.text	4,$19,"NOT("           ; $9e NOT(
>cf4e	af4e	05 4d 50 45 45 4b 28			.text	5,$4d,"PEEK("          ; $9f PEEK(
>cf55	af55	06 91 50 45 45 4b 44 28			.text	6,$91,"PEEKD("         ; $a0 PEEKD(
>cf5d	af5d	06 99 50 45 45 4b 4c 28			.text	6,$99,"PEEKL("         ; $a1 PEEKL(
>cf65	af65	06 a4 50 45 45 4b 57 28			.text	6,$a4,"PEEKW("         ; $a2 PEEKW(
>cf6d	af6d	08 3c 50 4c 41 59 49 4e			.text	8,$3c,"PLAYING("       ; $a3 PLAYING(
>cf75	af75	47 28
>cf77	af77	07 e9 52 41 4e 44 4f 4d			.text	7,$e9,"RANDOM("        ; $a4 RANDOM(
>cf7f	af7f	28
>cf80	af80	07 ca 52 49 47 48 54 24			.text	7,$ca,"RIGHT$("        ; $a5 RIGHT$(
>cf88	af88	28
>cf89	af89	04 0c 52 4e 44 28			.text	4,$0c,"RND("           ; $a6 RND(
>cf8f	af8f	04 10 53 47 4e 28			.text	4,$10,"SGN("           ; $a7 SGN(
>cf95	af95	04 0e 53 50 43 28			.text	4,$0e,"SPC("           ; $a8 SPC(
>cf9b	af9b	05 45 53 54 52 24 28			.text	5,$45,"STR$("          ; $a9 STR$(
>cfa2	afa2	05 56 54 49 4c 45 28			.text	5,$56,"TILE("          ; $aa TILE(
>cfa9	afa9	06 a9 54 49 4d 45 52 28			.text	6,$a9,"TIMER("         ; $ab TIMER(
>cfb1	afb1	04 40 54 52 55 45			.text	4,$40,"TRUE"           ; $ac TRUE
>cfb7	afb7	04 0b 56 41 4c 28			.text	4,$0b,"VAL("           ; $ad VAL(
>cfbd	afbd	03 e7 46 4f 52				.text	3,$e7,"FOR"            ; $ae FOR
>cfc2	afc2	02 8f 49 46				.text	2,$8f,"IF"             ; $af IF
>cfc6	afc6	04 34 50 52 4f 43			.text	4,$34,"PROC"           ; $b0 PROC
>cfcc	afcc	06 c1 52 45 50 45 41 54			.text	6,$c1,"REPEAT"         ; $b1 REPEAT
>cfd4	afd4	05 79 57 48 49 4c 45			.text	5,$79,"WHILE"          ; $b2 WHILE
>cfdb	afdb	05 66 45 4e 44 49 46			.text	5,$66,"ENDIF"          ; $b3 ENDIF
>cfe2	afe2	07 0b 45 4e 44 50 52 4f			.text	7,$0b,"ENDPROC"        ; $b4 ENDPROC
>cfea	afea	43
>cfeb	afeb	04 3f 4e 45 58 54			.text	4,$3f,"NEXT"           ; $b5 NEXT
>cff1	aff1	04 2f 54 48 45 4e			.text	4,$2f,"THEN"           ; $b6 THEN
>cff7	aff7	05 8c 55 4e 54 49 4c			.text	5,$8c,"UNTIL"          ; $b7 UNTIL
>cffe	affe	04 2e 57 45 4e 44			.text	4,$2e,"WEND"           ; $b8 WEND
>d004	b004	02 95 41 54				.text	2,$95,"AT"             ; $b9 AT
>d008	b008	02 9b 42 59				.text	2,$9b,"BY"             ; $ba BY
>d00c	b00c	04 1c 43 41 4c 4c			.text	4,$1c,"CALL"           ; $bb CALL
>d012	b012	06 b2 43 49 52 43 4c 45			.text	6,$b2,"CIRCLE"         ; $bc CIRCLE
>d01a	b01a	05 67 43 4c 45 41 52			.text	5,$67,"CLEAR"          ; $bd CLEAR
>d021	b021	05 7f 43 4f 4c 4f 52			.text	5,$7f,"COLOR"          ; $be COLOR
>d028	b028	06 d4 43 4f 4c 4f 55 52			.text	6,$d4,"COLOUR"         ; $bf COLOUR
>d030	b030	04 1a 44 41 54 41			.text	4,$1a,"DATA"           ; $c0 DATA
>d036	b036	03 da 44 49 4d				.text	3,$da,"DIM"            ; $c1 DIM
>d03b	b03b	06 db 44 4f 57 4e 54 4f			.text	6,$db,"DOWNTO"         ; $c2 DOWNTO
>d043	b043	04 29 45 4c 53 45			.text	4,$29,"ELSE"           ; $c3 ELSE
>d049	b049	04 34 46 52 4f 4d			.text	4,$34,"FROM"           ; $c4 FROM
>d04f	b04f	03 e5 47 46 58				.text	3,$e5,"GFX"            ; $c5 GFX
>d054	b054	04 24 48 45 52 45			.text	4,$24,"HERE"           ; $c6 HERE
>d05a	b05a	05 63 49 4d 41 47 45			.text	5,$63,"IMAGE"          ; $c7 IMAGE
>d061	b061	03 e5 4c 45 54				.text	3,$e5,"LET"            ; $c8 LET
>d066	b066	04 28 4c 49 4e 45			.text	4,$28,"LINE"           ; $c9 LINE
>d06c	b06c	05 6b 4c 4f 43 41 4c			.text	5,$6b,"LOCAL"          ; $ca LOCAL
>d073	b073	07 1a 4d 45 4d 43 4f 50			.text	7,$1a,"MEMCOPY"        ; $cb MEMCOPY
>d07b	b07b	59
>d07c	b07c	03 db 4f 46 46				.text	3,$db,"OFF"            ; $cc OFF
>d081	b081	02 9d 4f 4e				.text	2,$9d,"ON"             ; $cd ON
>d085	b085	07 20 4f 55 54 4c 49 4e			.text	7,$20,"OUTLINE"        ; $ce OUTLINE
>d08d	b08d	45
>d08e	b08e	07 0f 50 41 4c 45 54 54			.text	7,$0f,"PALETTE"        ; $cf PALETTE
>d096	b096	45
>d097	b097	04 3f 50 4c 4f 54			.text	4,$3f,"PLOT"           ; $d0 PLOT
>d09d	b09d	04 2f 50 4f 4b 45			.text	4,$2f,"POKE"           ; $d1 POKE
>d0a3	b0a3	05 73 50 4f 4b 45 44			.text	5,$73,"POKED"          ; $d2 POKED
>d0aa	b0aa	05 7b 50 4f 4b 45 4c			.text	5,$7b,"POKEL"          ; $d3 POKEL
>d0b1	b0b1	05 86 50 4f 4b 45 57			.text	5,$86,"POKEW"          ; $d4 POKEW
>d0b8	b0b8	04 1c 52 45 41 44			.text	4,$1c,"READ"           ; $d5 READ
>d0be	b0be	04 2e 52 45 43 54			.text	4,$2e,"RECT"           ; $d6 RECT
>d0c4	b0c4	03 e4 52 45 4d				.text	3,$e4,"REM"            ; $d7 REM
>d0c9	b0c9	05 7b 53 4f 4c 49 44			.text	5,$7b,"SOLID"          ; $d8 SOLID
>d0d0	b0d0	05 89 53 4f 55 4e 44			.text	5,$89,"SOUND"          ; $d9 SOUND
>d0d7	b0d7	06 d7 53 50 52 49 54 45			.text	6,$d7,"SPRITE"         ; $da SPRITE
>d0df	b0df	04 45 54 45 58 54			.text	4,$45,"TEXT"           ; $db TEXT
>d0e5	b0e5	02 a3 54 4f				.text	2,$a3,"TO"             ; $dc TO
>d0e9	b0e9	ff					.text	$FF
.d0ea	b0ea					KeywordSet1:
>d0ea	b0ea	00 65					.text	0,$65,""               ; $80 !0:EOF
>d0ec	b0ec	00 58					.text	0,$58,""               ; $81 !1:SH1
>d0ee	b0ee	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>d0f0	b0f0	08 4c 41 53 53 45 4d 42			.text	8,$4c,"ASSEMBLE"       ; $83 ASSEMBLE
>d0f8	b0f8	4c 45
>d0fa	b0fa	06 d2 41 53 53 45 52 54			.text	6,$d2,"ASSERT"         ; $84 ASSERT
>d102	b102	06 bd 42 49 54 4d 41 50			.text	6,$bd,"BITMAP"         ; $85 BITMAP
>d10a	b10a	05 62 42 4c 4f 41 44			.text	5,$62,"BLOAD"          ; $86 BLOAD
>d111	b111	05 71 42 53 41 56 45			.text	5,$71,"BSAVE"          ; $87 BSAVE
>d118	b118	03 e2 43 4c 53				.text	3,$e2,"CLS"            ; $88 CLS
>d11d	b11d	06 d0 43 50 52 49 4e 54			.text	6,$d0,"CPRINT"         ; $89 CPRINT
>d125	b125	06 de 43 55 52 53 4f 52			.text	6,$de,"CURSOR"         ; $8a CURSOR
>d12d	b12d	03 df 44 49 52				.text	3,$df,"DIR"            ; $8b DIR
>d132	b132	05 7a 44 52 49 56 45			.text	5,$7a,"DRIVE"          ; $8c DRIVE
>d139	b139	03 d7 45 4e 44				.text	3,$d7,"END"            ; $8d END
>d13e	b13e	07 11 45 58 50 4c 4f 44			.text	7,$11,"EXPLODE"        ; $8e EXPLODE
>d146	b146	45
>d147	b147	02 96 47 4f				.text	2,$96,"GO"             ; $8f GO
>d14b	b14b	05 80 47 4f 53 55 42			.text	5,$80,"GOSUB"          ; $90 GOSUB
>d152	b152	04 39 47 4f 54 4f			.text	4,$39,"GOTO"           ; $91 GOTO
>d158	b158	05 70 48 49 4d 45 4d			.text	5,$70,"HIMEM"          ; $92 HIMEM
>d15f	b15f	05 90 49 4e 50 55 54			.text	5,$90,"INPUT"          ; $93 INPUT
>d166	b166	04 3c 4c 49 53 54			.text	4,$3c,"LIST"           ; $94 LIST
>d16c	b16c	04 20 4c 4f 41 44			.text	4,$20,"LOAD"           ; $95 LOAD
>d172	b172	06 b7 4d 44 45 4c 54 41			.text	6,$b7,"MDELTA"         ; $96 MDELTA
>d17a	b17a	05 89 4d 4f 55 53 45			.text	5,$89,"MOUSE"          ; $97 MOUSE
>d181	b181	03 ea 4e 45 57				.text	3,$ea,"NEW"            ; $98 NEW
>d186	b186	06 d9 4f 50 54 49 4f 4e			.text	6,$d9,"OPTION"         ; $99 OPTION
>d18e	b18e	04 2e 50 49 4e 47			.text	4,$2e,"PING"           ; $9a PING
>d194	b194	05 8d 50 52 49 4e 54			.text	5,$8d,"PRINT"          ; $9b PRINT
>d19b	b19b	07 24 52 45 53 54 4f 52			.text	7,$24,"RESTORE"        ; $9c RESTORE
>d1a3	b1a3	45
>d1a4	b1a4	06 e0 52 45 54 55 52 4e			.text	6,$e0,"RETURN"         ; $9d RETURN
>d1ac	b1ac	03 f5 52 55 4e				.text	3,$f5,"RUN"            ; $9e RUN
>d1b1	b1b1	04 2f 53 41 56 45			.text	4,$2f,"SAVE"           ; $9f SAVE
>d1b7	b1b7	07 0a 53 45 54 44 41 54			.text	7,$0a,"SETDATE"        ; $a0 SETDATE
>d1bf	b1bf	45
>d1c0	b1c0	07 1b 53 45 54 54 49 4d			.text	7,$1b,"SETTIME"        ; $a1 SETTIME
>d1c8	b1c8	45
>d1c9	b1c9	05 8d 53 48 4f 4f 54			.text	5,$8d,"SHOOT"          ; $a2 SHOOT
>d1d0	b1d0	07 2a 53 50 52 49 54 45			.text	7,$2a,"SPRITES"        ; $a3 SPRITES
>d1d8	b1d8	53
>d1d9	b1d9	04 46 53 54 4f 50			.text	4,$46,"STOP"           ; $a4 STOP
>d1df	b1df	04 2e 54 49 4c 45			.text	4,$2e,"TILE"           ; $a5 TILE
>d1e5	b1e5	05 81 54 49 4c 45 53			.text	5,$81,"TILES"          ; $a6 TILES
>d1ec	b1ec	03 ff 54 52 59				.text	3,$ff,"TRY"            ; $a7 TRY
>d1f1	b1f1	06 d5 56 45 52 49 46 59			.text	6,$d5,"VERIFY"         ; $a8 VERIFY
>d1f9	b1f9	03 ee 58 47 4f				.text	3,$ee,"XGO"            ; $a9 XGO
>d1fe	b1fe	05 78 58 4c 4f 41 44			.text	5,$78,"XLOAD"          ; $aa XLOAD
>d205	b205	03 eb 5a 41 50				.text	3,$eb,"ZAP"            ; $ab ZAP
>d20a	b20a	ff					.text	$FF
.d20b	b20b					KeywordSet2:
>d20b	b20b	00 65					.text	0,$65,""               ; $80 !0:EOF
>d20d	b20d	00 58					.text	0,$58,""               ; $81 !1:SH1
>d20f	b20f	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>d211	b211	03 c8 41 44 43				.text	3,$c8,"ADC"            ; $83 ADC
>d216	b216	03 d3 41 4e 44				.text	3,$d3,"AND"            ; $84 AND
>d21b	b21b	03 e0 41 53 4c				.text	3,$e0,"ASL"            ; $85 ASL
>d220	b220	03 c8 42 43 43				.text	3,$c8,"BCC"            ; $86 BCC
>d225	b225	03 d8 42 43 53				.text	3,$d8,"BCS"            ; $87 BCS
>d22a	b22a	03 d8 42 45 51				.text	3,$d8,"BEQ"            ; $88 BEQ
>d22f	b22f	03 df 42 49 54				.text	3,$df,"BIT"            ; $89 BIT
>d234	b234	03 d8 42 4d 49				.text	3,$d8,"BMI"            ; $8a BMI
>d239	b239	03 d5 42 4e 45				.text	3,$d5,"BNE"            ; $8b BNE
>d23e	b23e	03 de 42 50 4c				.text	3,$de,"BPL"            ; $8c BPL
>d243	b243	03 d5 42 52 41				.text	3,$d5,"BRA"            ; $8d BRA
>d248	b248	03 df 42 52 4b				.text	3,$df,"BRK"            ; $8e BRK
>d24d	b24d	03 db 42 56 43				.text	3,$db,"BVC"            ; $8f BVC
>d252	b252	03 eb 42 56 53				.text	3,$eb,"BVS"            ; $90 BVS
>d257	b257	03 d2 43 4c 43				.text	3,$d2,"CLC"            ; $91 CLC
>d25c	b25c	03 d3 43 4c 44				.text	3,$d3,"CLD"            ; $92 CLD
>d261	b261	03 d8 43 4c 49				.text	3,$d8,"CLI"            ; $93 CLI
>d266	b266	03 e5 43 4c 56				.text	3,$e5,"CLV"            ; $94 CLV
>d26b	b26b	03 e0 43 4d 50				.text	3,$e0,"CMP"            ; $95 CMP
>d270	b270	03 eb 43 50 58				.text	3,$eb,"CPX"            ; $96 CPX
>d275	b275	03 ec 43 50 59				.text	3,$ec,"CPY"            ; $97 CPY
>d27a	b27a	03 cc 44 45 43				.text	3,$cc,"DEC"            ; $98 DEC
>d27f	b27f	03 e1 44 45 58				.text	3,$e1,"DEX"            ; $99 DEX
>d284	b284	03 e2 44 45 59				.text	3,$e2,"DEY"            ; $9a DEY
>d289	b289	03 e6 45 4f 52				.text	3,$e6,"EOR"            ; $9b EOR
>d28e	b28e	03 da 49 4e 43				.text	3,$da,"INC"            ; $9c INC
>d293	b293	03 ef 49 4e 58				.text	3,$ef,"INX"            ; $9d INX
>d298	b298	03 f0 49 4e 59				.text	3,$f0,"INY"            ; $9e INY
>d29d	b29d	03 e7 4a 4d 50				.text	3,$e7,"JMP"            ; $9f JMP
>d2a2	b2a2	03 ef 4a 53 52				.text	3,$ef,"JSR"            ; $a0 JSR
>d2a7	b2a7	03 d1 4c 44 41				.text	3,$d1,"LDA"            ; $a1 LDA
>d2ac	b2ac	03 e8 4c 44 58				.text	3,$e8,"LDX"            ; $a2 LDX
>d2b1	b2b1	03 e9 4c 44 59				.text	3,$e9,"LDY"            ; $a3 LDY
>d2b6	b2b6	03 f1 4c 53 52				.text	3,$f1,"LSR"            ; $a4 LSR
>d2bb	b2bb	03 ed 4e 4f 50				.text	3,$ed,"NOP"            ; $a5 NOP
>d2c0	b2c0	03 e2 4f 52 41				.text	3,$e2,"ORA"            ; $a6 ORA
>d2c5	b2c5	03 d9 50 48 41				.text	3,$d9,"PHA"            ; $a7 PHA
>d2ca	b2ca	03 e8 50 48 50				.text	3,$e8,"PHP"            ; $a8 PHP
>d2cf	b2cf	03 f0 50 48 58				.text	3,$f0,"PHX"            ; $a9 PHX
>d2d4	b2d4	03 f1 50 48 59				.text	3,$f1,"PHY"            ; $aa PHY
>d2d9	b2d9	03 dd 50 4c 41				.text	3,$dd,"PLA"            ; $ab PLA
>d2de	b2de	03 ec 50 4c 50				.text	3,$ec,"PLP"            ; $ac PLP
>d2e3	b2e3	03 f4 50 4c 58				.text	3,$f4,"PLX"            ; $ad PLX
>d2e8	b2e8	03 f5 50 4c 59				.text	3,$f5,"PLY"            ; $ae PLY
>d2ed	b2ed	03 ed 52 4f 4c				.text	3,$ed,"ROL"            ; $af ROL
>d2f2	b2f2	03 f3 52 4f 52				.text	3,$f3,"ROR"            ; $b0 ROR
>d2f7	b2f7	03 ef 52 54 49				.text	3,$ef,"RTI"            ; $b1 RTI
>d2fc	b2fc	03 f9 52 54 53				.text	3,$f9,"RTS"            ; $b2 RTS
>d301	b301	03 d8 53 42 43				.text	3,$d8,"SBC"            ; $b3 SBC
>d306	b306	03 db 53 45 43				.text	3,$db,"SEC"            ; $b4 SEC
>d30b	b30b	03 dc 53 45 44				.text	3,$dc,"SED"            ; $b5 SED
>d310	b310	03 e1 53 45 49				.text	3,$e1,"SEI"            ; $b6 SEI
>d315	b315	03 e8 53 54 41				.text	3,$e8,"STA"            ; $b7 STA
>d31a	b31a	03 f7 53 54 50				.text	3,$f7,"STP"            ; $b8 STP
>d31f	b31f	03 ff 53 54 58				.text	3,$ff,"STX"            ; $b9 STX
>d324	b324	03 00 53 54 59				.text	3,$00,"STY"            ; $ba STY
>d329	b329	03 01 53 54 5a				.text	3,$01,"STZ"            ; $bb STZ
>d32e	b32e	03 ed 54 41 58				.text	3,$ed,"TAX"            ; $bc TAX
>d333	b333	03 ee 54 41 59				.text	3,$ee,"TAY"            ; $bd TAY
>d338	b338	03 e8 54 52 42				.text	3,$e8,"TRB"            ; $be TRB
>d33d	b33d	03 e9 54 53 42				.text	3,$e9,"TSB"            ; $bf TSB
>d342	b342	03 ff 54 53 58				.text	3,$ff,"TSX"            ; $c0 TSX
>d347	b347	03 ed 54 58 41				.text	3,$ed,"TXA"            ; $c1 TXA
>d34c	b34c	03 ff 54 58 53				.text	3,$ff,"TXS"            ; $c2 TXS
>d351	b351	03 ee 54 59 41				.text	3,$ee,"TYA"            ; $c3 TYA
>d356	b356	ff					.text	$FF
.d357	b357					Export_TKInitialise:
.d357	b357	a2 07		ldx #$07			ldx 	#7
.d359	b359					_ETKISetDefault:
.d359	b359	bd ae b5	lda $b5ae,x			lda 	CLIDefault,x
.d35c	b35c	9d 00 04	sta $0400,x			sta 	CLIFComment,x
.d35f	b35f	ca		dex				dex
.d360	b360	10 f7		bpl $b359			bpl 	_ETKISetDefault
.d362	b362	60		rts				rts
.d363	b363					Export_TKListConvertLine:
.d363	b363	48		pha				pha 								; save indent on the stack
.d364	b364	9c 39 04	stz $0439			stz 	tbOffset
.d367	b367	9c 49 04	stz $0449			stz 	tokenBuffer
.d36a	b36a	9c 45 04	stz $0445			stz 	currentListColour
.d36d	b36d	ad 02 04	lda $0402			lda 	CLILineNumber
.d370	b370	20 f8 b4	jsr $b4f8			jsr 	LCLWriteColour
.d373	b373	a0 02		ldy #$02			ldy 	#2 							; convert line number to string
.d375	b375	b1 30		lda ($30),y			lda 	(codePtr),y
.d377	b377	aa		tax				tax
.d378	b378	88		dey				dey
.d379	b379	b1 30		lda ($30),y			lda 	(codePtr),y
.d37b	b37b	20 6d b5	jsr $b56d			jsr 	LCLWriteNumberXA
.d37e	b37e	68		pla				pla 								; adjustment to indent
.d37f	b37f	48		pha				pha 								; save on stack
.d380	b380	10 0c		bpl $b38e			bpl 	_LCNoAdjust 				; don't adjust indent if +ve, do after.
.d382	b382	18		clc				clc 								; add to list indent and make 0 if goes -ve.
.d383	b383	6d 42 04	adc $0442			adc 	listIndent
.d386	b386	8d 42 04	sta $0442			sta 	listIndent
.d389	b389	10 03		bpl $b38e			bpl 	_LCNoAdjust
.d38b	b38b	9c 42 04	stz $0442			stz 	listIndent
.d38e	b38e					_LCNoAdjust:
.d38e	b38e	18		clc				clc		 							; work out actual indent.
.d38f	b38f	ad 42 04	lda $0442			lda 	listIndent
.d392	b392	0a		asl a				asl 	a
.d393	b393	69 07		adc #$07			adc 	#7
.d395	b395	85 36		sta $36				sta 	zTemp0
.d397	b397					_LCPadOut:
.d397	b397	a9 20		lda #$20			lda 	#' '						; pad out to 6+indent characters
.d399	b399	20 05 b5	jsr $b505			jsr 	LCLWrite
.d39c	b39c	ad 39 04	lda $0439			lda 	tbOffset
.d39f	b39f	c5 36		cmp $36				cmp 	zTemp0
.d3a1	b3a1	d0 f4		bne $b397			bne 	_LCPadOut
.d3a3	b3a3	a0 03		ldy #$03			ldy 	#3 							; start position.
.d3a5	b3a5					_LCMainLoop:
.d3a5	b3a5	ad 06 04	lda $0406			lda 	CLIPunctuation
.d3a8	b3a8	20 f8 b4	jsr $b4f8			jsr 	LCLWriteColour
.d3ab	b3ab	b1 30		lda ($30),y			lda 	(codePtr),y
.d3ad	b3ad	c9 80		cmp #$80			cmp 	#KWC_EOL 					; end of line ?
.d3af	b3af	f0 17		beq $b3c8			beq 	_LCExit
.d3b1	b3b1	c9 10		cmp #$10			cmp 	#16 						; 0-5 are the double punctuations
.d3b3	b3b3	90 1e		bcc $b3d3			bcc 	_LCDoubles
.d3b5	b3b5	c9 20		cmp #$20			cmp 	#32 						; 16-31 are shifted punctuation from 64-91
.d3b7	b3b7	90 2a		bcc $b3e3			bcc 	_LCShiftPunc
.d3b9	b3b9	c9 40		cmp #$40			cmp 	#64 						; 32-64 are as stored, punc and digits
.d3bb	b3bb	90 35		bcc $b3f2			bcc 	_LCPunctuation
.d3bd	b3bd	c9 80		cmp #$80			cmp 	#128 						; 64-127 are variable identifiers.
.d3bf	b3bf	90 52		bcc $b413			bcc 	_LCIdentifiers
.d3c1	b3c1	c9 fe		cmp #$fe			cmp 	#254 						; 128-253 are tokenised words
.d3c3	b3c3	90 75		bcc $b43a			bcc 	_LCTokens
.d3c5	b3c5	4c 9b b4	jmp $b49b			jmp 	_LCData 					; 254-5 are data objects
.d3c8	b3c8					_LCExit:
.d3c8	b3c8	68		pla				pla 								; get old indent adjust
.d3c9	b3c9	30 07		bmi $b3d2			bmi 	_LCExit2
.d3cb	b3cb	18		clc				clc 								; add to indent if +ve
.d3cc	b3cc	6d 42 04	adc $0442			adc 	listIndent
.d3cf	b3cf	8d 42 04	sta $0442			sta 	listIndent
.d3d2	b3d2					_LCExit2:
.d3d2	b3d2	60		rts				rts
.d3d3	b3d3					_LCDoubles:
.d3d3	b3d3	48		pha				pha
.d3d4	b3d4	4a		lsr a				lsr 	a 							; put bit 2 into bit 1
.d3d5	b3d5	29 02		and #$02			and 	#2
.d3d7	b3d7	09 3c		ora #$3c			ora 	#60 						; make < >
.d3d9	b3d9	20 05 b5	jsr $b505			jsr 	LCLWrite
.d3dc	b3dc	68		pla				pla 								; restore, do lower bit
.d3dd	b3dd	29 03		and #$03			and 	#3
.d3df	b3df	09 3c		ora #$3c			ora 	#60
.d3e1	b3e1	80 0f		bra $b3f2			bra		_LCPunctuation 				; print, increment, loop
.d3e3	b3e3					_LCShiftPunc:
.d3e3	b3e3	aa		tax				tax 								; save in X
.d3e4	b3e4	29 07		and #$07			and 	#7 							; lower 3 bits
.d3e6	b3e6	f0 02		beq $b3ea			beq 	_LCNoAdd
.d3e8	b3e8	09 18		ora #$18			ora 	#24 						; adds $18 to it.
.d3ea	b3ea					_LCNoAdd:
.d3ea	b3ea	e0 18		cpx #$18			cpx 	#24 						; if >= 24 add $20
.d3ec	b3ec	90 02		bcc $b3f0			bcc 	_LCNoAdd2
.d3ee	b3ee	09 20		ora #$20			ora 	#32 						; adds $20
.d3f0	b3f0					_LCNoAdd2:
.d3f0	b3f0	09 40		ora #$40			ora 	#$40 						; shift into 64-127 range and fall through.
.d3f2	b3f2					_LCPunctuation:
.d3f2	b3f2	c9 3a		cmp #$3a			cmp 	#':' 						; check if :
.d3f4	b3f4	d0 03		bne $b3f9			bne 	_LCPContinue
.d3f6	b3f6	20 1b b5	jsr $b51b			jsr 	LCLDeleteLastSpace 			; if so delete any preceding spaces
.d3f9	b3f9					_LCPContinue:
.d3f9	b3f9	c9 2e		cmp #$2e			cmp 	#'.'
.d3fb	b3fb	f0 08		beq $b405			beq 	_LCPIsConstant
.d3fd	b3fd	c9 30		cmp #$30			cmp 	#'0'
.d3ff	b3ff	90 0c		bcc $b40d			bcc 	_LCPNotConstant
.d401	b401	c9 3a		cmp #$3a			cmp 	#'9'+1
.d403	b403	b0 08		bcs $b40d			bcs 	_LCPNotConstant
.d405	b405					_LCPIsConstant:
.d405	b405	48		pha				pha
.d406	b406	ad 04 04	lda $0404			lda 	CLIConstant
.d409	b409	20 f8 b4	jsr $b4f8			jsr 	LCLWriteColour
.d40c	b40c	68		pla				pla
.d40d	b40d					_LCPNotConstant:
.d40d	b40d	c8		iny				iny 								; consume character
.d40e	b40e	20 05 b5	jsr $b505			jsr 	LCLWrite 					; write it out.
.d411	b411	80 92		bra $b3a5			bra 	_LCMainLoop 				; go round again.
.d413	b413					_LCIdentifiers:
.d413	b413	18		clc				clc 								; convert to physical address
.d414	b414	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.d416	b416	85 37		sta $37				sta 	zTemp0+1
.d418	b418	c8		iny				iny
.d419	b419	b1 30		lda ($30),y			lda 	(codePtr),y
.d41b	b41b	85 36		sta $36				sta 	zTemp0
.d41d	b41d	c8		iny				iny
.d41e	b41e	5a		phy				phy 								; save position
.d41f	b41f	ad 05 04	lda $0405			lda 	CLIIdentifier
.d422	b422	20 f8 b4	jsr $b4f8			jsr 	LCLWriteColour
.d425	b425	a0 07		ldy #$07			ldy 	#7 							; output the identifier at +8
.d427	b427					_LCOutIdentifier:
.d427	b427	c8		iny				iny
.d428	b428	b1 36		lda ($36),y			lda 	(zTemp0),y					; bit 7 set = end.
.d42a	b42a	29 7f		and #$7f			and 	#$7F
.d42c	b42c	20 57 b5	jsr $b557			jsr 	LCLLowerCase
.d42f	b42f	20 05 b5	jsr $b505			jsr 	LCLWrite
.d432	b432	b1 36		lda ($36),y			lda 	(zTemp0),y				 	; ends when bit 7 set.
.d434	b434	10 f1		bpl $b427			bpl 	_LCOutIdentifier
.d436	b436	7a		ply				ply 								; restore position
.d437	b437	4c a5 b3	jmp $b3a5			jmp 	_LCMainLoop
.d43a	b43a					_LCTokens:
.d43a	b43a	aa		tax				tax 								; token in X
.d43b	b43b	a9 0b		lda #$0b			lda 	#((KeywordSet2) & $FF)
.d43d	b43d	85 36		sta $36				sta 	0+zTemp0
.d43f	b43f	a9 b2		lda #$b2			lda 	#((KeywordSet2) >> 8)
.d441	b441	85 37		sta $37				sta 	1+zTemp0
.d443	b443	e0 82		cpx #$82			cpx 	#$82
.d445	b445	f0 16		beq $b45d			beq 	_LCUseShift
.d447	b447	a9 ea		lda #$ea			lda 	#((KeywordSet1) & $FF)
.d449	b449	85 36		sta $36				sta 	0+zTemp0
.d44b	b44b	a9 b0		lda #$b0			lda 	#((KeywordSet1) >> 8)
.d44d	b44d	85 37		sta $37				sta 	1+zTemp0
.d44f	b44f	e0 81		cpx #$81			cpx 	#$81
.d451	b451	f0 0a		beq $b45d			beq 	_LCUseShift
.d453	b453	a9 72		lda #$72			lda 	#((KeywordSet0) & $FF)
.d455	b455	85 36		sta $36				sta 	0+zTemp0
.d457	b457	a9 ae		lda #$ae			lda 	#((KeywordSet0) >> 8)
.d459	b459	85 37		sta $37				sta 	1+zTemp0
.d45b	b45b	80 01		bra $b45e			bra 	_LCNoShift
.d45d	b45d					_LCUseShift:
.d45d	b45d	c8		iny				iny
.d45e	b45e					_LCNoShift:
.d45e	b45e	20 2f b5	jsr $b52f			jsr 	LCLCheckSpaceRequired 		; do we need a space ?
.d461	b461	b1 30		lda ($30),y			lda 	(codePtr),y
.d463	b463	aa		tax				tax 								; into X
.d464	b464					_LCFindText:
.d464	b464	ca		dex				dex
.d465	b465	10 0e		bpl $b475			bpl 	_LCFoundText 				; found text.
.d467	b467	b2 36		lda ($36)			lda 	(zTemp0) 					; length of text
.d469	b469	1a		inc a				inc 	a 							; one extra for size
.d46a	b46a	38		sec				sec 								; one extra for checksum
.d46b	b46b	65 36		adc $36				adc 	zTemp0 						; go to next token
.d46d	b46d	85 36		sta $36				sta 	zTemp0
.d46f	b46f	90 f3		bcc $b464			bcc 	_LCFindText
.d471	b471	e6 37		inc $37				inc 	zTemp0+1
.d473	b473	80 ef		bra $b464			bra 	_LCFindText
.d475	b475					_LCFoundText:
.d475	b475	5a		phy				phy 								; save List position
.d476	b476	b2 36		lda ($36)			lda 	(zTemp0)					; count to print
.d478	b478	aa		tax				tax
.d479	b479	ad 03 04	lda $0403			lda 	CLIToken
.d47c	b47c	20 f8 b4	jsr $b4f8			jsr 	LCLWriteColour
.d47f	b47f	a0 02		ldy #$02			ldy 	#2
.d481	b481					_LCCopyToken:
.d481	b481	b1 36		lda ($36),y			lda 	(zTemp0),y
.d483	b483	20 57 b5	jsr $b557			jsr 	LCLLowerCase
.d486	b486	20 05 b5	jsr $b505			jsr 	LCLWrite
.d489	b489	c8		iny				iny
.d48a	b48a	ca		dex				dex
.d48b	b48b	d0 f4		bne $b481			bne 	_LCCopyToken
.d48d	b48d	c9 28		cmp #$28			cmp 	#"(" 						; if last char not ( print a space
.d48f	b48f	f0 05		beq $b496			beq 	_LCNoSpace
.d491	b491	a9 20		lda #$20			lda 	#' '
.d493	b493	20 05 b5	jsr $b505			jsr 	LCLWrite
.d496	b496					_LCNoSpace:
.d496	b496	7a		ply				ply 								; restore position.
.d497	b497	c8		iny				iny 								; consume token
.d498	b498	4c a5 b3	jmp $b3a5			jmp 	_LCMainLoop 				; and go around again.
.d49b	b49b					_LCData:
.d49b	b49b	48		pha				pha 								; save type $FE/$FF
.d49c	b49c	a2 24		ldx #$24			ldx 	#'$' 						; figure out $ or "
.d49e	b49e	c9 fe		cmp #$fe			cmp 	#$FE
.d4a0	b4a0	f0 29		beq $b4cb			beq 	_LCHaveOpener
.d4a2	b4a2	a2 22		ldx #$22			ldx 	#'"'
.d4a4	b4a4	ad 07 04	lda $0407			lda 	CLIData
.d4a7	b4a7	20 f8 b4	jsr $b4f8			jsr 	LCLWriteColour
.d4aa	b4aa	c0 04		cpy #$04			cpy 	#4 							; must be 2nd thing on line
.d4ac	b4ac	d0 1d		bne $b4cb			bne 	_LCHaveOpener
.d4ae	b4ae	88		dey				dey 								; what precedes it ?
.d4af	b4af	b1 30		lda ($30),y			lda 	(codePtr),y
.d4b1	b4b1	c8		iny				iny
.d4b2	b4b2	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; if quote
.d4b4	b4b4	d0 15		bne $b4cb			bne 	_LCHaveOpener
.d4b6	b4b6	a9 09		lda #$09			lda 	#9 							; tab
.d4b8	b4b8	20 05 b5	jsr $b505			jsr 	LCLWrite
.d4bb	b4bb	ad 01 04	lda $0401			lda 	CLIBComment
.d4be	b4be	30 0b		bmi $b4cb			bmi 	_LCHaveOpener
.d4c0	b4c0	09 90		ora #$90			ora 	#$90
.d4c2	b4c2	20 05 b5	jsr $b505			jsr 	LCLWrite
.d4c5	b4c5	ad 00 04	lda $0400			lda 	CLIFComment
.d4c8	b4c8	20 f8 b4	jsr $b4f8			jsr 	LCLWriteColour
.d4cb	b4cb					_LCHaveOpener:
.d4cb	b4cb	8a		txa				txa 								; output prefix (# or ")
.d4cc	b4cc	20 05 b5	jsr $b505			jsr 	LCLWrite
.d4cf	b4cf	c8		iny				iny 								; get count
.d4d0	b4d0	b1 30		lda ($30),y			lda 	(codePtr),y
.d4d2	b4d2	aa		tax				tax
.d4d3	b4d3	c8		iny				iny 								; point at first character
.d4d4	b4d4					_LCOutData:
.d4d4	b4d4	b1 30		lda ($30),y			lda 	(codePtr),y
.d4d6	b4d6	c9 00		cmp #$00			cmp 	#0
.d4d8	b4d8	f0 03		beq $b4dd			beq 	_LCNoPrint
.d4da	b4da	20 05 b5	jsr $b505			jsr 	LCLWrite
.d4dd	b4dd					_LCNoPrint:
.d4dd	b4dd	c8		iny				iny
.d4de	b4de	ca		dex				dex
.d4df	b4df	d0 f3		bne $b4d4			bne 	_LCOutData
.d4e1	b4e1	68		pla				pla 								; closing " required ?
.d4e2	b4e2	c9 ff		cmp #$ff			cmp 	#$FF 						; not required for hex constant.
.d4e4	b4e4	d0 0f		bne $b4f5			bne 	_LCNoQuote
.d4e6	b4e6	a9 22		lda #$22			lda 	#'"'
.d4e8	b4e8	20 05 b5	jsr $b505			jsr 	LCLWrite
.d4eb	b4eb	ad ec 07	lda $07ec			lda 	EXTTextColour
.d4ee	b4ee	29 0f		and #$0f			and 	#$0F
.d4f0	b4f0	09 90		ora #$90			ora 	#$90
.d4f2	b4f2	20 05 b5	jsr $b505			jsr 	LCLWrite
.d4f5	b4f5					_LCNoQuote:
.d4f5	b4f5	4c a5 b3	jmp $b3a5			jmp 	_LCMainLoop
.d4f8	b4f8					LCLWriteColour:
.d4f8	b4f8	29 0f		and #$0f			and 	#$0F
.d4fa	b4fa	09 80		ora #$80			ora 	#$80
.d4fc	b4fc	cd 45 04	cmp $0445			cmp 	currentListColour 			; has the colour changed
.d4ff	b4ff	8d 45 04	sta $0445			sta 	currentListColour 			; (update it anyway)
.d502	b502	d0 01		bne $b505			bne 	LCLWrite 					; if different, output it
.d504	b504	60		rts				rts
.d505	b505					LCLWrite:
.d505	b505	da		phx				phx
.d506	b506	ae 39 04	ldx $0439			ldx 	tbOffset 					; write out make ASCIIZ
.d509	b509	9d 49 04	sta $0449,x			sta 	tokenBuffer,x
.d50c	b50c	9e 4a 04	stz $044a,x			stz 	tokenBuffer+1,x
.d50f	b50f	ee 39 04	inc $0439			inc 	tbOffset 					; bump the position
.d512	b512	09 00		ora #$00			ora 	#0 							; don't update last character if colour data
.d514	b514	30 03		bmi $b519			bmi 	_LCLNoColour
.d516	b516	8d 43 04	sta $0443			sta 	lcLastCharacter
.d519	b519					_LCLNoColour:
.d519	b519	fa		plx				plx
.d51a	b51a	60		rts				rts
.d51b	b51b					LCLDeleteLastSpace:
.d51b	b51b	48		pha				pha
.d51c	b51c	da		phx				phx
.d51d	b51d	ae 39 04	ldx $0439			ldx 	tbOffset
.d520	b520	f0 0a		beq $b52c			beq 	_LCDLSExit
.d522	b522	bd 48 04	lda $0448,x			lda 	tokenBuffer-1,x
.d525	b525	c9 20		cmp #$20			cmp 	#' '
.d527	b527	d0 03		bne $b52c			bne 	_LCDLSExit
.d529	b529	ce 39 04	dec $0439			dec 	tbOffset
.d52c	b52c					_LCDLSExit:
.d52c	b52c	fa		plx				plx
.d52d	b52d	68		pla				pla
.d52e	b52e	60		rts				rts
.d52f	b52f					LCLCheckSpaceRequired:
.d52f	b52f	ad 43 04	lda $0443			lda 	lcLastCharacter 			; check last character
.d532	b532	c9 24		cmp #$24			cmp 	#'$' 						; $ # and ) require that token space.
.d534	b534	f0 1b		beq $b551			beq 	_LCCSRSpace
.d536	b536	c9 29		cmp #$29			cmp 	#')'
.d538	b538	f0 17		beq $b551			beq 	_LCCSRSpace
.d53a	b53a	c9 23		cmp #$23			cmp 	#'#'
.d53c	b53c	f0 13		beq $b551			beq 	_LCCSRSpace
.d53e	b53e	20 57 b5	jsr $b557			jsr 	LCLLowerCase 				; saves a little effort
.d541	b541	c9 30		cmp #$30			cmp 	#"0" 						; check if it was 0-9 A-Z a-z if so need space.
.d543	b543	90 11		bcc $b556			bcc 	_LCCSRExit
.d545	b545	c9 3a		cmp #$3a			cmp 	#"9"+1
.d547	b547	90 08		bcc $b551			bcc 	_LCCSRSpace
.d549	b549	c9 61		cmp #$61			cmp 	#"a"
.d54b	b54b	90 09		bcc $b556			bcc 	_LCCSRExit
.d54d	b54d	c9 7b		cmp #$7b			cmp 	#"z"+1
.d54f	b54f	b0 05		bcs $b556			bcs 	_LCCSRExit
.d551	b551					_LCCSRSpace:
.d551	b551	a9 20		lda #$20			lda 	#' '
.d553	b553	20 05 b5	jsr $b505			jsr 	LCLWrite
.d556	b556					_LCCSRExit:
.d556	b556	60		rts				rts
.d557	b557					LCLLowerCase:
.d557	b557	c9 41		cmp #$41			cmp 	#"A"
.d559	b559	90 06		bcc $b561			bcc 	_LCLLCOut
.d55b	b55b	c9 5b		cmp #$5b			cmp 	#"Z"+1
.d55d	b55d	b0 02		bcs $b561			bcs 	_LCLLCOut
.d55f	b55f	69 20		adc #$20			adc 	#$20
.d561	b561					_LCLLCOut:
.d561	b561	60		rts				rts
.d562	b562					LCLUpperCase:
.d562	b562	c9 61		cmp #$61			cmp 	#"a"
.d564	b564	90 06		bcc $b56c			bcc 	_LCLUCOut
.d566	b566	c9 7b		cmp #$7b			cmp 	#"z"+1
.d568	b568	b0 02		bcs $b56c			bcs 	_LCLUCOut
.d56a	b56a	e9 1f		sbc #$1f			sbc 	#$1F
.d56c	b56c					_LCLUCOut:
.d56c	b56c	60		rts				rts
.d56d	b56d					LCLWriteNumberXA:
.d56d	b56d	64 37		stz $37				stz 	zTemp0+1 					; index into digit table.
.d56f	b56f					_LCLWNLoop1:
.d56f	b56f	64 36		stz $36				stz 	zTemp0 						; subtraction count.
.d571	b571					_LCLWNLoop2:
.d571	b571	48		pha				pha 								; save initial LSB
.d572	b572	38		sec				sec
.d573	b573	a4 37		ldy $37				ldy 	zTemp0+1 					; position in table.
.d575	b575	f9 a6 b5	sbc $b5a6,y			sbc 	_LCLWNTable,y
.d578	b578	48		pha				pha
.d579	b579	8a		txa				txa
.d57a	b57a	f9 a7 b5	sbc $b5a7,y			sbc 	_LCLWNTable+1,y
.d57d	b57d	90 07		bcc $b586			bcc 	_LCLWNUnderflow
.d57f	b57f	e6 36		inc $36				inc 	zTemp0  					; subtracted one without borrow.
.d581	b581	aa		tax				tax 								; update X
.d582	b582	68		pla				pla 								; restore A
.d583	b583	7a		ply				ply 								; throw original
.d584	b584	80 eb		bra $b571			bra 	_LCLWNLoop2 				; try again.
.d586	b586					_LCLWNUnderflow:
.d586	b586	a4 36		ldy $36				ldy 	zTemp0 						; count of subtractions.
.d588	b588	d0 06		bne $b590			bne 	_LCLWNOut
.d58a	b58a	ad 39 04	lda $0439			lda 	tbOffset 					; suppress leading zeroes
.d58d	b58d	3a		dec a				dec 	a
.d58e	b58e	f0 04		beq $b594			beq 	_LCLWNNext
.d590	b590					_LCLWNOut:
.d590	b590	98		tya				tya
.d591	b591	20 a0 b5	jsr $b5a0			jsr 	_LCLWNOutDigit
.d594	b594					_LCLWNNext:
.d594	b594	7a		ply				ply 							 	; restore original value.
.d595	b595	68		pla				pla
.d596	b596	a4 37		ldy $37				ldy 	zTemp0+1  					; bump the index
.d598	b598	c8		iny				iny
.d599	b599	c8		iny				iny
.d59a	b59a	84 37		sty $37				sty 	zTemp0+1
.d59c	b59c	c0 08		cpy #$08			cpy 	#8 							; done all 4
.d59e	b59e	d0 cf		bne $b56f			bne 	_LCLWNLoop1
.d5a0	b5a0					_LCLWNOutDigit:
.d5a0	b5a0	09 30		ora #$30			ora 	#'0'
.d5a2	b5a2	20 05 b5	jsr $b505			jsr 	LCLWrite
.d5a5	b5a5	60		rts				rts
.d5a6	b5a6					_LCLWNTable:
>d5a6	b5a6	10 27						.word 	10000
>d5a8	b5a8	e8 03						.word 	1000
>d5aa	b5aa	64 00						.word 	100
>d5ac	b5ac	0a 00						.word 	10
.d5ae	b5ae					CLIDefault:
>d5ae	b5ae	05 0e 0d 06 07 0e 0c 0f				.byte	CONBrown, CONYellow, CONRed, CONOrange, CONCyan, CONYellow, CONPink, CONWhite
=1024						CLIFComment = ControlStorage + 0
=1025						CLIBComment = ControlStorage + 1
=1026						CLILineNumber = ControlStorage + 2
=1027						CLIToken = ControlStorage + 3
=1028						CLIConstant = ControlStorage + 4
=1029						CLIIdentifier = ControlStorage + 5
=1030						CLIPunctuation = ControlStorage + 6
=1031						CLIData = ControlStorage + 7
.d5b6	b5b6					TOKSearchTable:
.d5b6	b5b6	84 37		sty $37				sty 	zTemp0+1 					; (zTemp0),y points to current token being tested.
.d5b8	b5b8	85 36		sta $36				sta 	zTemp0
.d5ba	b5ba	a0 00		ldy #$00			ldy 	#0
.d5bc	b5bc	a9 80		lda #$80			lda 	#$80 						; token # so we know which one we are looking at
.d5be	b5be	85 38		sta $38				sta 	zTemp1
.d5c0	b5c0					_TSTLoop:
.d5c0	b5c0	b1 36		lda ($36),y			lda 	(zTemp0),y 					; length, 0 (skip) -ve (end)
.d5c2	b5c2	30 49		bmi $b60d			bmi 	_TSTFail 					; -ve = end of table, so fail.
.d5c4	b5c4	f0 2e		beq $b5f4			beq 	_TSTNext 					; zero, check next as it's a dummy (e.g. EOL, SHIFT)
.d5c6	b5c6	c8		iny				iny 								; get the hash
.d5c7	b5c7	b1 36		lda ($36),y			lda 	(zTemp0),y
.d5c9	b5c9	88		dey				dey
.d5ca	b5ca	cd 23 04	cmp $0423			cmp 	identHash 					; check they match with the identifier hash, if not go to next
.d5cd	b5cd	d0 25		bne $b5f4			bne 	_TSTNext
.d5cf	b5cf	ad 22 04	lda $0422			lda 	identTypeEnd 				; get length of identifier from end-start
.d5d2	b5d2	38		sec				sec
.d5d3	b5d3	ed 20 04	sbc $0420			sbc 	identStart
.d5d6	b5d6	d1 36		cmp ($36),y			cmp 	(zTemp0),y 					; compare against the length in the table, no match, then return.
.d5d8	b5d8	d0 1a		bne $b5f4			bne 	_TSTNext
.d5da	b5da	5a		phy				phy 								; save Y , we might fail to match.
.d5db	b5db	c8		iny				iny 								; point to text
.d5dc	b5dc	c8		iny				iny
.d5dd	b5dd	ae 20 04	ldx $0420			ldx 	identStart 					; offset in line buffer in X
.d5e0	b5e0					_TSTCompareName:
.d5e0	b5e0	bd 46 05	lda $0546,x			lda 	lineBuffer,x 				; compare text.
.d5e3	b5e3	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.d5e5	b5e5	d0 0c		bne $b5f3			bne 	_TSTNextPullY 				; fail, pullY and do next
.d5e7	b5e7	e8		inx				inx
.d5e8	b5e8	c8		iny				iny
.d5e9	b5e9	ec 22 04	cpx $0422			cpx 	identTypeEnd 				; complete match.
.d5ec	b5ec	d0 f2		bne $b5e0			bne 	_TSTCompareName
.d5ee	b5ee	7a		ply				ply 								; throw Y
.d5ef	b5ef	a5 38		lda $38				lda 	zTemp1 						; get token #
.d5f1	b5f1	38		sec				sec 								; return with CS = passed.
.d5f2	b5f2	60		rts				rts
.d5f3	b5f3					_TSTNextPullY:
.d5f3	b5f3	7a		ply				ply 								; restore current, fall through.
.d5f4	b5f4					_TSTNext:
.d5f4	b5f4	e6 38		inc $38				inc 	zTemp1 						; token counter
.d5f6	b5f6	98		tya				tya
.d5f7	b5f7	18		clc				clc
.d5f8	b5f8	71 36		adc ($36),y			adc 	(zTemp0),y 					; add [Length] + 2 to Y
.d5fa	b5fa	1a		inc a				inc 	a 							; +1
.d5fb	b5fb	1a		inc a				inc 	a 							; +2
.d5fc	b5fc	a8		tay				tay
.d5fd	b5fd	10 c1		bpl $b5c0			bpl 	_TSTLoop 					; if Y < $80 loop back
.d5ff	b5ff	98		tya				tya 								; add Y to zTemp0 and reset Y
.d600	b600	a0 00		ldy #$00			ldy 	#0   						; so we can use Y to search fast
.d602	b602	18		clc				clc  								; but have tables > 255 bytes
.d603	b603	65 36		adc $36				adc 	zTemp0 						; when Y gets >= 128 we reset Y
.d605	b605	85 36		sta $36				sta 	zTemp0 						; and adjust the table pointer/
.d607	b607	90 b7		bcc $b5c0			bcc 	_TSTLoop
.d609	b609	e6 37		inc $37				inc 	zTemp0+1
.d60b	b60b	80 b3		bra $b5c0			bra 	_TSTLoop
.d60d	b60d					_TSTFail:
.d60d	b60d	18		clc				clc
.d60e	b60e	60		rts				rts
.d60f	b60f					Export_TKTokeniseLine:
.d60f	b60f	20 dc b7	jsr $b7dc			jsr 	LCLFixLineBufferCase 		; fix line case
.d612	b612	a9 03		lda #$03			lda 	#3 							; reset the token buffer to empty
.d614	b614	8d 46 04	sta $0446			sta 	tokenOffset 				; (3 bytes for line number & offset)
.d617	b617	9c 47 04	stz $0447			stz 	tokenLineNumber
.d61a	b61a	9c 48 04	stz $0448			stz 	tokenLineNumber+1
.d61d	b61d	a2 ff		ldx #$ff			ldx 	#$FF
.d61f	b61f					_TKFindFirst:
.d61f	b61f	e8		inx				inx
.d620	b620	bd 46 05	lda $0546,x			lda 	lineBuffer,x
.d623	b623	f0 62		beq $b687			beq 	_TKExit
.d625	b625	c9 20		cmp #$20			cmp 	#' '
.d627	b627	90 f6		bcc $b61f			bcc 	_TKFindFirst
.d629	b629	c9 30		cmp #$30			cmp 	#'0'
.d62b	b62b	90 07		bcc $b634			bcc 	_TKNoLineNumber
.d62d	b62d	c9 3a		cmp #$3a			cmp 	#'9'+1
.d62f	b62f	b0 03		bcs $b634			bcs 	_TKNoLineNumber
.d631	b631	20 06 b8	jsr $b806			jsr 	TOKExtractLineNumber
.d634	b634					_TKNoLineNumber:
.d634	b634					_TKTokeniseLoop:
.d634	b634	bd 46 05	lda $0546,x			lda 	lineBuffer,x 				; next character, exit if zero EOL.
.d637	b637	f0 4e		beq $b687			beq 	_TKExit
.d639	b639	e8		inx				inx
.d63a	b63a	c9 20		cmp #$20			cmp 	#' '
.d63c	b63c	f0 f6		beq $b634			beq 	_TKTokeniseLoop 			; keep looping if space found.
.d63e	b63e	ca		dex				dex 								; undo last get, A contains character, X is position.
.d63f	b63f	c9 5f		cmp #$5f			cmp 	#'_'						; _ A-Z is identifier *or* token
.d641	b641	f0 68		beq $b6ab			beq 	_TKTokeniseIdentifier 		; (already case converted outside string constants)
.d643	b643	c9 41		cmp #$41			cmp 	#'A'
.d645	b645	90 04		bcc $b64b			bcc 	_TKTokenisePunctuation
.d647	b647	c9 5b		cmp #$5b			cmp 	#'Z'+1
.d649	b649	90 60		bcc $b6ab			bcc 	_TKTokeniseIdentifier
.d64b	b64b					_TKTokenisePunctuation:
.d64b	b64b	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.d64d	b64d	f0 2e		beq $b67d			beq 	_TKString
.d64f	b64f	c9 24		cmp #$24			cmp 	#'$'						; hexadecimal constant ($ only appears at end of identifiers)
.d651	b651	f0 2f		beq $b682			beq 	_TKHexConstant
.d653	b653	c9 3c		cmp #$3c			cmp 	#'<' 						; check for < > handlers - these are for <> <= >= >> <<
.d655	b655	f0 36		beq $b68d			beq 	_TKCheckDouble
.d657	b657	c9 3e		cmp #$3e			cmp 	#'>'
.d659	b659	f0 32		beq $b68d			beq 	_TKCheckDouble
.d65b	b65b					_TKStandardPunctuation:
.d65b	b65b	bd 46 05	lda $0546,x			lda 	lineBuffer,x 				; get the punctuation token back.
.d65e	b65e	c9 40		cmp #$40			cmp 	#64 						; are we >= 64
.d660	b660	90 0e		bcc $b670			bcc 	_TKNoShift
.d662	b662	48		pha				pha 								; save. we are about to convert this punctuation token from
.d663	b663	29 07		and #$07			and 	#7 							; lower 3 bits in zTemp0
.d665	b665	85 36		sta $36				sta 	zTemp0
.d667	b667	68		pla				pla
.d668	b668	29 20		and #$20			and 	#32 						; bit 5
.d66a	b66a	4a		lsr a				lsr 	a 							; shift into bit 3
.d66b	b66b	4a		lsr a				lsr 	a
.d66c	b66c	05 36		ora $36				ora 	zTemp0
.d66e	b66e	09 10		ora #$10			ora 	#$10						; now in the range 16-31
.d670	b670					_TKNoShift:
.d670	b670	20 4b b8	jsr $b84b			jsr 	TOKWriteByte 				; write the punctuation character
.d673	b673	e8		inx				inx 								; consume the character
.d674	b674	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; quote found ?
.d676	b676	d0 bc		bne $b634			bne 	_TKTokeniseLoop 			; and loop round again.
.d678	b678	20 3e b7	jsr $b73e			jsr 	TOKCheckComment 			; comment checl
.d67b	b67b	80 b7		bra $b634			bra 	_TKTokeniseLoop
.d67d	b67d					_TKString:
.d67d	b67d	20 6b b7	jsr $b76b			jsr 	TOKTokenString
.d680	b680	80 b2		bra $b634			bra 	_TKTokeniseLoop
.d682	b682					_TKHexConstant:
.d682	b682	20 a6 b7	jsr $b7a6			jsr 	TOKHexConstant
.d685	b685	80 ad		bra $b634			bra 	_TKTokeniseLoop
.d687	b687	a9 80		lda #$80	_TKExit:lda 	#KWC_EOL 					; write end of line byte
.d689	b689	20 4b b8	jsr $b84b			jsr 	TOKWriteByte
.d68c	b68c	60		rts				rts
.d68d	b68d					_TKCheckDouble:
.d68d	b68d	bd 47 05	lda $0547,x			lda 	lineBuffer+1,x 				; get next character
.d690	b690	c9 3c		cmp #$3c			cmp 	#'<'						; if not < = > which are ASCII consecutive go back
.d692	b692	90 c7		bcc $b65b			bcc 	_TKStandardPunctuation 		; and do the normal punctuation handler.
.d694	b694	c9 3f		cmp #$3f			cmp 	#'>'+1
.d696	b696	b0 c3		bcs $b65b			bcs 	_TKStandardPunctuation
.d698	b698	bd 46 05	lda $0546,x			lda 	lineBuffer,x 				; this is < (60) or > (62)
.d69b	b69b	29 02		and #$02			and 	#2 							; now < (0) or > (2)
.d69d	b69d	0a		asl a				asl 	a 							; now < (0) or > (4), CC also
.d69e	b69e	7d 47 05	adc $0547,x			adc 	lineBuffer+1,x 				; add < = > codes - < code
.d6a1	b6a1	38		sec				sec
.d6a2	b6a2	e9 3c		sbc #$3c			sbc 	#'<'
.d6a4	b6a4	20 4b b8	jsr $b84b			jsr 	TOKWriteByte 				; this is in the range 0-7
.d6a7	b6a7	e8		inx				inx 								; consume both
.d6a8	b6a8	e8		inx				inx
.d6a9	b6a9	80 89		bra $b634			bra 	_TKTokeniseLoop
.d6ab	b6ab					_TKTokeniseIdentifier:
.d6ab	b6ab	8e 20 04	stx $0420			stx 	identStart 					; save start
.d6ae	b6ae	9c 24 04	stz $0424			stz 	identTypeByte 				; zero the type byte
.d6b1	b6b1					_TKCheckLoop:
.d6b1	b6b1	e8		inx				inx 								; look at next, we know first is identifier already.
.d6b2	b6b2	bd 46 05	lda $0546,x			lda  	lineBuffer,x
.d6b5	b6b5	c9 5f		cmp #$5f			cmp 	#"_" 						; legal char _ 0-9 A-Z
.d6b7	b6b7	f0 f8		beq $b6b1			beq 	_TKCheckLoop
.d6b9	b6b9	c9 30		cmp #$30			cmp	 	#"0"
.d6bb	b6bb	90 0c		bcc $b6c9			bcc 	_TKEndIdentifier
.d6bd	b6bd	c9 3a		cmp #$3a			cmp 	#"9"+1
.d6bf	b6bf	90 f0		bcc $b6b1			bcc 	_TKCheckLoop
.d6c1	b6c1	c9 41		cmp #$41			cmp	 	#"A"
.d6c3	b6c3	90 04		bcc $b6c9			bcc 	_TKEndIdentifier
.d6c5	b6c5	c9 5b		cmp #$5b			cmp 	#"Z"+1
.d6c7	b6c7	90 e8		bcc $b6b1			bcc 	_TKCheckLoop
.d6c9	b6c9					_TKEndIdentifier:
.d6c9	b6c9	8e 21 04	stx $0421			stx 	identTypeStart 				; save start of type text (if any !)
.d6cc	b6cc	a0 08		ldy #$08			ldy 	#$08 						; this is the identifier type byte for #
.d6ce	b6ce	c9 23		cmp #$23			cmp 	#"#"						; followed by #
.d6d0	b6d0	f0 06		beq $b6d8			beq 	_TKHasTypeCharacter
.d6d2	b6d2	a0 10		ldy #$10			ldy 	#$10 						; this is the identifier type byte for $
.d6d4	b6d4	c9 24		cmp #$24			cmp 	#"$"						; followed by $ or #
.d6d6	b6d6	d0 07		bne $b6df			bne 	_TKNoTypeCharacter
.d6d8	b6d8					_TKHasTypeCharacter:
.d6d8	b6d8	8c 24 04	sty $0424			sty 	identTypeByte 				; has # or $, save the type
.d6db	b6db	e8		inx				inx 								; consume the type character
.d6dc	b6dc	bd 46 05	lda $0546,x			lda 	lineBuffer,x
.d6df	b6df					_TKNoTypeCharacter:
.d6df	b6df	c9 28		cmp #$28			cmp 	#"("						; is it open parenthesis (e.g. array)
.d6e1	b6e1	d0 09		bne $b6ec			bne 	_TKNoArray
.d6e3	b6e3	e8		inx				inx 								; skip the (
.d6e4	b6e4	ad 24 04	lda $0424			lda 	identTypeByte 				; set bit 2 (e.g. array) in type byte
.d6e7	b6e7	09 04		ora #$04			ora 	#$04
.d6e9	b6e9	8d 24 04	sta $0424			sta 	identTypeByte
.d6ec	b6ec					_TKNoArray:
.d6ec	b6ec	8e 22 04	stx $0422			stx 	identTypeEnd 				; save end marker, e.g. continue from here.
.d6ef	b6ef	20 c7 b7	jsr $b7c7			jsr 	TOKCalculateHash 			; calculate the has for those tokens
.d6f2	b6f2	a0 ae		ldy #$ae			ldy 	#(KeywordSet0) >> 8
.d6f4	b6f4	a9 72		lda #$72			lda 	#(KeywordSet0) & $FF
.d6f6	b6f6	20 b6 b5	jsr $b5b6			jsr 	TOKSearchTable
.d6f9	b6f9	a2 00		ldx #$00			ldx 	#0
.d6fb	b6fb	b0 1f		bcs $b71c			bcs 	_TKFoundToken
.d6fd	b6fd	a0 b0		ldy #$b0			ldy 	#(KeywordSet1) >> 8
.d6ff	b6ff	a9 ea		lda #$ea			lda 	#(KeywordSet1) & $FF
.d701	b701	20 b6 b5	jsr $b5b6			jsr 	TOKSearchTable
.d704	b704	a2 81		ldx #$81			ldx 	#$81
.d706	b706	b0 14		bcs $b71c			bcs 	_TKFoundToken
.d708	b708	a0 b2		ldy #$b2			ldy 	#(KeywordSet2) >> 8
.d70a	b70a	a9 0b		lda #$0b			lda 	#(KeywordSet2) & $FF
.d70c	b70c	20 b6 b5	jsr $b5b6			jsr 	TOKSearchTable
.d70f	b70f	a2 82		ldx #$82			ldx 	#$82
.d711	b711	b0 09		bcs $b71c			bcs 	_TKFoundToken
.d713	b713	20 57 b8	jsr $b857			jsr 	TOKCheckCreateVariableRecord ; failed all, it's a variable, create record if does not exist.
.d716	b716	ae 22 04	ldx $0422			ldx 	identTypeEnd 				; X points to following byte
.d719	b719	4c 34 b6	jmp $b634			jmp 	_TKTokeniseLoop 			; and go round again.
.d71c	b71c					_TKFoundToken:
.d71c	b71c	48		pha				pha 								; save token
.d71d	b71d	8a		txa				txa 								; shift in X, is there one ?
.d71e	b71e	f0 03		beq $b723			beq 	_TKNoTShift
.d720	b720	20 4b b8	jsr $b84b			jsr 	TOKWriteByte 				; if so, write it out
.d723	b723					_TKNoTShift:
.d723	b723	68		pla				pla 								; restore and write token
.d724	b724	20 4b b8	jsr $b84b			jsr 	TOKWriteByte
.d727	b727	e0 00		cpx #$00			cpx 	#0 							; check for REM and '
.d729	b729	d0 0d		bne $b738			bne 	_TKNotRem 			 		; not shifted ?
.d72b	b72b	c9 d7		cmp #$d7			cmp 	#KWD_REM
.d72d	b72d	d0 09		bne $b738			bne 	_TKNotRem
.d72f	b72f	ae 22 04	ldx $0422			ldx 	identTypeEnd 				; check if comment follows.
.d732	b732	20 3e b7	jsr $b73e			jsr 	TOKCheckComment
.d735	b735	4c 34 b6	jmp $b634			jmp 	_TKTokeniseLoop
.d738	b738					_TKNotRem:
.d738	b738	ae 22 04	ldx $0422			ldx 	identTypeEnd 				; X points to following byte
.d73b	b73b	4c 34 b6	jmp $b634			jmp 	_TKTokeniseLoop 			; and go round again.
.d73e	b73e					TOKCheckComment:
.d73e	b73e	bd 46 05	lda $0546,x			lda 	lineBuffer,x 				; skip over space
.d741	b741	e8		inx				inx
.d742	b742	c9 20		cmp #$20			cmp 	#' '
.d744	b744	f0 f8		beq $b73e			beq 	TOKCheckComment
.d746	b746	ca		dex				dex 								; first non space character
.d747	b747	c9 22		cmp #$22			cmp 	#'"'						; quote mark
.d749	b749	f0 1f		beq $b76a			beq 	_TOKCCExit 					; then we are okay
.d74b	b74b	c9 00		cmp #$00			cmp 	#0 							; EOL
.d74d	b74d	f0 1b		beq $b76a			beq 	_TOKCCExit 					; then we are okay
.d74f	b74f	da		phx				phx
.d750	b750					_TOKCCLowerCase:
.d750	b750	bd 46 05	lda $0546,x			lda 	lineBuffer,x 				; about making it lower case it all, but I thought
.d753	b753	c9 41		cmp #$41			cmp 	#"A"		 				; that was a bit risky. So it's converted to L/C here.
.d755	b755	90 09		bcc $b760			bcc 	_TOKKCNotUC
.d757	b757	c9 5b		cmp #$5b			cmp 	#"Z"+1
.d759	b759	b0 05		bcs $b760			bcs 	_TOKKCNotUC
.d75b	b75b	49 20		eor #$20			eor 	#$20
.d75d	b75d	9d 46 05	sta $0546,x			sta 	lineBuffer,x
.d760	b760					_TOKKCNotUC:
.d760	b760	e8		inx				inx
.d761	b761	c9 00		cmp #$00			cmp 	#0
.d763	b763	d0 eb		bne $b750			bne 	_TOKCCLowerCase
.d765	b765	fa		plx				plx
.d766	b766	ca		dex				dex 								; tokenise string expects initial skip.
.d767	b767	20 6b b7	jsr $b76b			jsr 	TOKTokenString 				; tokenise rest of line as a string.
.d76a	b76a					_TOKCCExit:
.d76a	b76a	60		rts				rts
.d76b	b76b					TOKTokenString:
.d76b	b76b	a9 ff		lda #$ff			lda 	#KWC_STRING 				; string token.
.d76d	b76d	20 4b b8	jsr $b84b			jsr 	TOKWriteByte
.d770	b770	e8		inx				inx									; start of quoted string.
.d771	b771	da		phx				phx 								; push start of string on top
.d772	b772	ca		dex				dex 								; because we pre-increment
.d773	b773					_TSFindEnd:
.d773	b773	e8		inx				inx
.d774	b774	bd 46 05	lda $0546,x			lda 	lineBuffer,x 				; next character
.d777	b777	f0 04		beq $b77d			beq 	_TSEndOfString 				; no matching quote, we don't mind.
.d779	b779	c9 22		cmp #$22			cmp 	#'"' 						; go back if quote not found
.d77b	b77b	d0 f6		bne $b773			bne 	_TSFindEnd
.d77d	b77d					_TSEndOfString:
.d77d	b77d	7a		ply				ply  								; so now Y is first character, X is character after end.
.d77e	b77e	48		pha				pha 								; save terminating character
.d77f	b77f	20 87 b7	jsr $b787			jsr 	TOKWriteBlockXY 			; write X to Y as a data block
.d782	b782	68		pla				pla 								; terminating character
.d783	b783	f0 01		beq $b786			beq 	_TSNotQuote					; if it wasn't EOS skip it
.d785	b785	e8		inx				inx
.d786	b786					_TSNotQuote:
.d786	b786	60		rts				rts
.d787	b787					TOKWriteBlockXY:
.d787	b787	86 36		stx $36				stx 	zTemp0 						; save end character
.d789	b789	98		tya				tya 								; use 2's complement to work out the byte size
.d78a	b78a	49 ff		eor #$ff			eor 	#$FF
.d78c	b78c	38		sec				sec
.d78d	b78d	65 36		adc $36				adc 	zTemp0
.d78f	b78f	1a		inc a				inc 	a 							; one extra for NULL
.d790	b790	20 4b b8	jsr $b84b			jsr 	TOKWriteByte
.d793	b793					_TOBlockLoop:
.d793	b793	c4 36		cpy $36				cpy 	zTemp0 						; exit if reached the end
.d795	b795	f0 09		beq $b7a0			beq 	_TOBlockExit
.d797	b797	b9 46 05	lda $0546,y			lda 	lineBuffer,y 				; write byte out.
.d79a	b79a	20 4b b8	jsr $b84b			jsr 	TOKWriteByte
.d79d	b79d	c8		iny				iny
.d79e	b79e	80 f3		bra $b793			bra 	_TOBlockLoop
.d7a0	b7a0					_TOBlockExit:
.d7a0	b7a0	a9 00		lda #$00			lda 	#0 							; add NULL.
.d7a2	b7a2	20 4b b8	jsr $b84b			jsr 	TOKWriteByte
.d7a5	b7a5	60		rts				rts
.d7a6	b7a6					TOKHexConstant:
.d7a6	b7a6	a9 fe		lda #$fe			lda 	#KWC_HEXCONST 				; hex constant token.
.d7a8	b7a8	20 4b b8	jsr $b84b			jsr 	TOKWriteByte
.d7ab	b7ab	e8		inx				inx									; start of quoted string.
.d7ac	b7ac	da		phx				phx 								; push start of constant on top
.d7ad	b7ad	ca		dex				dex
.d7ae	b7ae					_THFindLoop:
.d7ae	b7ae	e8		inx				inx 	 							; this is stored in a block, so find out how long
.d7af	b7af	bd 46 05	lda $0546,x			lda 	lineBuffer,x 				; the hex constant is.
.d7b2	b7b2	c9 30		cmp #$30			cmp 	#"0"
.d7b4	b7b4	90 0c		bcc $b7c2			bcc 	_THFoundEnd
.d7b6	b7b6	c9 3a		cmp #$3a			cmp 	#"9"+1
.d7b8	b7b8	90 f4		bcc $b7ae			bcc 	_THFindLoop
.d7ba	b7ba	c9 41		cmp #$41			cmp 	#"A"
.d7bc	b7bc	90 04		bcc $b7c2			bcc 	_THFoundEnd
.d7be	b7be	c9 47		cmp #$47			cmp 	#"F"+1
.d7c0	b7c0	90 ec		bcc $b7ae			bcc 	_THFindLoop
.d7c2	b7c2					_THFoundEnd:
.d7c2	b7c2	7a		ply				ply 								; restore start
.d7c3	b7c3	20 87 b7	jsr $b787			jsr 	TOKWriteBlockXY 			; output the block
.d7c6	b7c6	60		rts				rts
.d7c7	b7c7					TOKCalculateHash:
.d7c7	b7c7	da		phx				phx
.d7c8	b7c8	ae 20 04	ldx $0420			ldx 	identStart 					; needs to be same as in tokens.py - simple sum at present.
.d7cb	b7cb	a9 00		lda #$00			lda 	#0
.d7cd	b7cd					_TCHLoop:
.d7cd	b7cd	18		clc				clc
.d7ce	b7ce	7d 46 05	adc $0546,x			adc 	lineBuffer,x
.d7d1	b7d1	e8		inx				inx
.d7d2	b7d2	ec 22 04	cpx $0422			cpx 	identTypeEnd 				; do the whole thing including type and array markers.
.d7d5	b7d5	d0 f6		bne $b7cd			bne 	_TCHLoop
.d7d7	b7d7	8d 23 04	sta $0423			sta 	identHash 					; save the hash
.d7da	b7da	fa		plx				plx
.d7db	b7db	60		rts				rts
.d7dc	b7dc					LCLFixLineBufferCase:
.d7dc	b7dc	a2 00		ldx #$00			ldx 	#0
.d7de	b7de					_FLBCLoop:
.d7de	b7de	bd 46 05	lda $0546,x			lda 	lineBuffer,x 				; get next character
.d7e1	b7e1	f0 22		beq $b805			beq 	_FLBCExit 					; end of string.
.d7e3	b7e3	c9 22		cmp #$22			cmp 	#'"'						; quote, go to in quotes
.d7e5	b7e5	f0 11		beq $b7f8			beq 	_FLBCInQuotes
.d7e7	b7e7	e8		inx				inx
.d7e8	b7e8	c9 61		cmp #$61			cmp 	#'a'						; needs capitalising ?
.d7ea	b7ea	90 f2		bcc $b7de			bcc 	_FLBCLoop
.d7ec	b7ec	c9 7b		cmp #$7b			cmp 	#'z'+1
.d7ee	b7ee	b0 ee		bcs $b7de			bcs 	_FLBCLoop
.d7f0	b7f0	38		sec				sec 								; make U/C
.d7f1	b7f1	e9 20		sbc #$20			sbc 	#32
.d7f3	b7f3	9d 45 05	sta $0545,x			sta	 	lineBuffer-1,x 				; write back
.d7f6	b7f6	80 e6		bra $b7de			bra 	_FLBCLoop
.d7f8	b7f8					_FLBCInQuotes:
.d7f8	b7f8	e8		inx				inx 								; advance
.d7f9	b7f9	bd 46 05	lda $0546,x			lda 	lineBuffer,x 				; get next
.d7fc	b7fc	f0 07		beq $b805			beq 	_FLBCExit 					; exit on EOS
.d7fe	b7fe	c9 22		cmp #$22			cmp 	#'"' 				 		; until " found
.d800	b800	d0 f6		bne $b7f8			bne 	_FLBCInQuotes
.d802	b802	e8		inx				inx 								; skip over it
.d803	b803	80 d9		bra $b7de			bra 	_FLBCLoop
.d805	b805					_FLBCExit:
.d805	b805	60		rts				rts
.d806	b806					TOKExtractLineNumber:
.d806	b806	ad 48 04	lda $0448			lda 	tokenLineNumber+1 			; push current value on stack
.d809	b809	48		pha				pha
.d80a	b80a	ad 47 04	lda $0447			lda 	tokenLineNumber
.d80d	b80d	48		pha				pha
.d80e	b80e	20 44 b8	jsr $b844			jsr 	_LCLNTimes2 				; line # x 2
.d811	b811	20 44 b8	jsr $b844			jsr 	_LCLNTimes2 				; line # x 4
.d814	b814	18		clc				clc 								; add stacked value
.d815	b815	68		pla				pla
.d816	b816	6d 47 04	adc $0447			adc 	tokenLineNumber
.d819	b819	8d 47 04	sta $0447			sta 	tokenLineNumber
.d81c	b81c	68		pla				pla
.d81d	b81d	6d 48 04	adc $0448			adc 	tokenLineNumber+1
.d820	b820	8d 48 04	sta $0448			sta 	tokenLineNumber+1 			; line # x 5
.d823	b823	20 44 b8	jsr $b844			jsr 	_LCLNTimes2 				; line # x 10
.d826	b826	bd 46 05	lda $0546,x			lda 	lineBuffer,x 				; get and consume character
.d829	b829	e8		inx				inx
.d82a	b82a	29 0f		and #$0f			and 	#15 						; add to line #
.d82c	b82c	18		clc				clc
.d82d	b82d	6d 47 04	adc $0447			adc 	tokenLineNumber
.d830	b830	8d 47 04	sta $0447			sta 	tokenLineNumber
.d833	b833	90 03		bcc $b838			bcc 	_TLENNoCarry
.d835	b835	ee 48 04	inc $0448			inc 	tokenLineNumber+1
.d838	b838					_TLENNoCarry:
.d838	b838	bd 46 05	lda $0546,x			lda 	lineBuffer,x 				; more digits ?
.d83b	b83b	c9 30		cmp #$30			cmp 	#'0'
.d83d	b83d	90 04		bcc $b843			bcc 	_TLENExit
.d83f	b83f	c9 3a		cmp #$3a			cmp 	#'9'+1
.d841	b841	90 c3		bcc $b806			bcc 	TOKExtractLineNumber
.d843	b843					_TLENExit:
.d843	b843	60		rts				rts
.d844	b844					_LCLNTimes2:
.d844	b844	0e 47 04	asl $0447			asl 	tokenLineNumber 			; doubles tokenLineNumber.
.d847	b847	2e 48 04	rol $0448			rol 	tokenLineNumber+1
.d84a	b84a	60		rts				rts
.d84b	b84b					TOKWriteByte:
.d84b	b84b	da		phx				phx
.d84c	b84c	ae 46 04	ldx $0446			ldx 	tokenOffset 				; next slot to write to
.d84f	b84f	9d 46 04	sta $0446,x			sta 	tokenOffset,x 				; write byte out
.d852	b852	ee 46 04	inc $0446			inc 	tokenOffset 				; advance slot.
.d855	b855	fa		plx				plx
.d856	b856	60		rts				rts
.d857	b857					TOKCheckCreateVariableRecord:
.d857	b857	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.d859	b859	85 36		sta $36				sta 	0+zTemp0
.d85b	b85b	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.d85d	b85d	85 37		sta $37				sta 	1+zTemp0
.d85f	b85f					_CCVSearch:
.d85f	b85f	b2 36		lda ($36)			lda 	(zTemp0) 					; end of list
.d861	b861	f0 2c		beq $b88f			beq 	_CCVFail
.d863	b863	a0 01		ldy #$01			ldy 	#1 							; read the hash
.d865	b865	b1 36		lda ($36),y			lda 	(zTemp0),y 					; does it match ?
.d867	b867	cd 23 04	cmp $0423			cmp 	identHash 	  				; if not, try the next.
.d86a	b86a	d0 16		bne $b882			bne 	_CCVNext
.d86c	b86c	a0 08		ldy #$08			ldy 	#8 							; name in variable record
.d86e	b86e	ae 20 04	ldx $0420			ldx 	identStart
.d871	b871					_CCVCompare:
.d871	b871	bd 46 05	lda $0546,x			lda 	lineBuffer,x 				; xor them. zero if the same, except
.d874	b874	51 36		eor ($36),y			eor 	(zTemp0),y 					; bit 7 is used for EOS.
.d876	b876	e8		inx				inx 								; advance pointers
.d877	b877	c8		iny				iny
.d878	b878	0a		asl a				asl 	a 							; A = 0 if they match, CS if end.
.d879	b879	d0 07		bne $b882			bne 	_CCVNext  					; didn't match go to next.
.d87b	b87b	90 f4		bcc $b871			bcc 	_CCVCompare 				; not finished yet.
.d87d	b87d	ec 22 04	cpx $0422			cpx 	identTypeEnd 				; matched whole thing ?
.d880	b880	f0 41		beq $b8c3			beq 	_CCVFound 					; yes, we were successful
.d882	b882					_CCVNext:
.d882	b882	18		clc				clc 								; go to next record.
.d883	b883	b2 36		lda ($36)			lda 	(zTemp0) 					; add offset to pointer
.d885	b885	65 36		adc $36				adc 	zTemp0
.d887	b887	85 36		sta $36				sta 	zTemp0
.d889	b889	90 d4		bcc $b85f			bcc 	_CCVSearch
.d88b	b88b	e6 37		inc $37				inc 	zTemp0+1
.d88d	b88d	80 d0		bra $b85f			bra 	_CCVSearch
.d88f	b88f					_CCVFail:
.d88f	b88f	a0 01		ldy #$01			ldy 	#1 							; create the new record. Offset 1 is hash
.d891	b891	ad 23 04	lda $0423			lda 	identHash
.d894	b894	91 36		sta ($36),y			sta 	(zTemp0),y
.d896	b896	c8		iny				iny 								; offset 2 is the type byte
.d897	b897	ad 24 04	lda $0424			lda 	identTypeByte
.d89a	b89a	91 36		sta ($36),y			sta 	(zTemp0),y
.d89c	b89c	c8		iny				iny
.d89d	b89d					_CCVData:
.d89d	b89d	a9 00		lda #$00			lda 	#0 							; erase data 3-7 (the 5 value bytes)
.d89f	b89f	91 36		sta ($36),y			sta 	(zTemp0),y
.d8a1	b8a1	c8		iny				iny
.d8a2	b8a2	c0 08		cpy #$08			cpy 	#8
.d8a4	b8a4	90 f7		bcc $b89d			bcc 	_CCVData
.d8a6	b8a6	ae 20 04	ldx $0420			ldx 	identStart 					; copy name into 8 on.
.d8a9	b8a9					_CCVCopyName:
.d8a9	b8a9	bd 46 05	lda $0546,x			lda 	lineBuffer,x
.d8ac	b8ac	91 36		sta ($36),y			sta 	(zTemp0),y
.d8ae	b8ae	e8		inx				inx
.d8af	b8af	c8		iny				iny
.d8b0	b8b0	ec 22 04	cpx $0422			cpx 	identTypeEnd
.d8b3	b8b3	d0 f4		bne $b8a9			bne 	_CCVCopyName
.d8b5	b8b5	98		tya				tya 								; patch offset
.d8b6	b8b6	92 36		sta ($36)			sta 	(zTemp0)
.d8b8	b8b8	a9 00		lda #$00			lda 	#0 							; offset for next is zero.
.d8ba	b8ba	91 36		sta ($36),y			sta 	(zTemp0),y
.d8bc	b8bc	88		dey				dey
.d8bd	b8bd	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set bit 7 of last bit
.d8bf	b8bf	09 80		ora #$80			ora 	#$80
.d8c1	b8c1	91 36		sta ($36),y			sta 	(zTemp0),y
.d8c3	b8c3					_CCVFound:
.d8c3	b8c3	a5 37		lda $37				lda 	zTemp0+1 					; write out MSB
.d8c5	b8c5	38		sec				sec
.d8c6	b8c6	e9 10		sbc #$10			sbc 	#(VariableSpace >> 8) 		; offset from the start of the variable token
.d8c8	b8c8	09 40		ora #$40			ora 	#$40 						; make it a writeable token $4000-$7FFF
.d8ca	b8ca	20 4b b8	jsr $b84b			jsr 	TOKWriteByte
.d8cd	b8cd	a5 36		lda $36				lda 	zTemp0 						; write out LSB
.d8cf	b8cf	20 4b b8	jsr $b84b			jsr 	TOKWriteByte
.d8d2	b8d2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/.build/sound.module.asm

=1						soundIntegrated=1
.d8d3	b8d3					SNDCheckChannel:
.d8d3	b8d3	aa		tax				tax
.d8d4	b8d4	bd be 0a	lda $0abe,x			lda 	SNDTimeLeft,x 				; currently playing a note
.d8d7	b8d7	d0 38		bne $b911			bne 	_SNDCCExit
.d8d9	b8d9	da		phx				phx 								; save current channel
.d8da	b8da	8a		txa				txa 								; put in A
.d8db	b8db	20 57 b9	jsr $b957			jsr 	SNDFindNextNoteForA 		; is there a note for A in the queue ?
.d8de	b8de	68		pla				pla 								; channel # in A
.d8df	b8df	90 30		bcc $b911			bcc 	_SNDCCExit  				; nothing in the queue for this channel, exit.
.d8e1	b8e1	a8		tay				tay 								; Y is the channel #
.d8e2	b8e2	bd b3 09	lda $09b3,x			lda 	SNDQueue+1,x 				; copy data into the slot.
.d8e5	b8e5	99 b2 0a	sta $0ab2,y			sta 	SNDPitchLow,y
.d8e8	b8e8	bd b4 09	lda $09b4,x			lda 	SNDQueue+2,x
.d8eb	b8eb	99 b6 0a	sta $0ab6,y			sta 	SNDPitchHigh,y
.d8ee	b8ee	bd b5 09	lda $09b5,x			lda 	SNDQueue+3,x
.d8f1	b8f1	99 ba 0a	sta $0aba,y			sta 	SNDVolume,y
.d8f4	b8f4	bd b6 09	lda $09b6,x			lda 	SNDQueue+4,x
.d8f7	b8f7	99 be 0a	sta $0abe,y			sta 	SNDTimeLeft,y
.d8fa	b8fa	bd b7 09	lda $09b7,x			lda 	SNDQueue+5,x
.d8fd	b8fd	99 c2 0a	sta $0ac2,y			sta 	SNDAdjustLow,y
.d900	b900	bd b8 09	lda $09b8,x			lda 	SNDQueue+6,x
.d903	b903	99 c6 0a	sta $0ac6,y			sta 	SNDAdjustHigh,y
.d906	b906	5a		phy				phy 								; save channel #
.d907	b907	20 71 b9	jsr $b971			jsr 	SNDDeleteXFromQueue 		; delete record at X from queue
.d90a	b90a	ce b1 09	dec $09b1			dec 	SNDLength 					; reduce the queue length.
.d90d	b90d	68		pla				pla
.d90e	b90e	20 12 b9	jsr $b912			jsr 	SNDUpdateNote 				; update channel A
.d911	b911					_SNDCCExit:
.d911	b911	60		rts				rts
.d912	b912					SNDUpdateNote:
.d912	b912	aa		tax				tax 								; so we can access records
.d913	b913	0a		asl a				asl 	a 							; convert it to a channel bit pair in 5,6
.d914	b914	0a		asl a				asl 	a
.d915	b915	0a		asl a				asl 	a
.d916	b916	0a		asl a				asl 	a
.d917	b917	0a		asl a				asl 	a
.d918	b918	8d b0 09	sta $09b0			sta 	SNDChannelBits
.d91b	b91b	bd be 0a	lda $0abe,x			lda 	SNDTimeLeft,x 				; are we silent
.d91e	b91e	f0 2e		beq $b94e			beq 	_SNDUNIsSilent
.d920	b920	ad b0 09	lda $09b0			lda 	SNDChannelBits 				; push channel bits on stack
.d923	b923	48		pha				pha
.d924	b924	bd b2 0a	lda $0ab2,x			lda 	SNDPitchLow,x 				; get 4 lowest bits of pitch.
.d927	b927	29 0f		and #$0f			and 	#$0F
.d929	b929	0d b0 09	ora $09b0			ora 	SNDChannelBits 				; set channel bits
.d92c	b92c	09 80		ora #$80			ora 	#$80 						; write to pitch register
.d92e	b92e	20 bb b9	jsr $b9bb			jsr 	SNDWritePorts
.d931	b931	bd b6 0a	lda $0ab6,x			lda 	SNDPitchHigh,x 				; pitch high => channel temp.
.d934	b934	8d b0 09	sta $09b0			sta 	SNDChannelBits
.d937	b937	bd b2 0a	lda $0ab2,x			lda 	SNDPitchLow,x
.d93a	b93a	4e b0 09	lsr $09b0			lsr 	SNDChannelBits 				; shift 2 LSBs into MSB of A
.d93d	b93d	6a		ror a				ror 	a
.d93e	b93e	4e b0 09	lsr $09b0			lsr 	SNDChannelBits
.d941	b941	6a		ror a				ror 	a
.d942	b942	4a		lsr a				lsr 	a 							; put in bits 0-5
.d943	b943	4a		lsr a				lsr 	a
.d944	b944	20 bb b9	jsr $b9bb			jsr 	SNDWritePorts 				; write as rest of pitch register
.d947	b947	68		pla				pla
.d948	b948	09 90		ora #$90			ora 	#$90 						; set to write minimum attentuation.
.d94a	b94a	20 bb b9	jsr $b9bb			jsr 	SNDWritePorts
.d94d	b94d	60		rts				rts
.d94e	b94e					_SNDUNIsSilent:
.d94e	b94e	ad b0 09	lda $09b0			lda 	SNDChannelBits 				; channel bits
.d951	b951	09 9f		ora #$9f			ora 	#$9F 						; maximum attenuation
.d953	b953	20 bb b9	jsr $b9bb			jsr 	SNDWritePorts 				; write to the ports
.d956	b956	60		rts				rts
.d957	b957					SNDFindNextNoteForA:
.d957	b957	ac b1 09	ldy $09b1			ldy 	SNDLength 					; queue size into Y
.d95a	b95a	f0 13		beq $b96f			beq 	_SNDFNNFail 				; queue empty.
.d95c	b95c	a2 00		ldx #$00			ldx 	#0
.d95e	b95e					_SNDFNNSearch:
.d95e	b95e	dd b2 09	cmp $09b2,x			cmp 	SNDQueue,x 					; does it match the channel
.d961	b961	38		sec				sec
.d962	b962	f0 0c		beq $b970			beq 	_SNDFNNExit 				; if so exit with CS.
.d964	b964	e8		inx				inx 								; next queue slot.
.d965	b965	e8		inx				inx
.d966	b966	e8		inx				inx
.d967	b967	e8		inx				inx
.d968	b968	e8		inx				inx
.d969	b969	e8		inx				inx
.d96a	b96a	e8		inx				inx
.d96b	b96b	e8		inx				inx
.d96c	b96c	88		dey				dey 								; done the whole queue
.d96d	b96d	d0 ef		bne $b95e			bne 	_SNDFNNSearch 				; no, go back.
.d96f	b96f					_SNDFNNFail:
.d96f	b96f	18		clc				clc
.d970	b970					_SNDFNNExit:
.d970	b970	60		rts				rts
.d971	b971					SNDDeleteXFromQueue:
.d971	b971	e0 f8		cpx #$f8			cpx 	#SNDQueueSize*8-8 			; reached the end.
.d973	b973	f0 09		beq $b97e			beq 	_SNDDXExit
.d975	b975	bd ba 09	lda $09ba,x			lda 	SNDQueue+8,x
.d978	b978	9d b2 09	sta $09b2,x			sta 	SNDQueue,x
.d97b	b97b	e8		inx				inx
.d97c	b97c	80 f3		bra $b971			bra 	SNDDeleteXFromQueue
.d97e	b97e					_SNDDXExit:
.d97e	b97e	60		rts				rts
.09b0						SNDChannelBits:
>09b0								.fill 	1
.d97f	b97f					SNDQueueRequest:
.d97f	b97f	86 36		stx $36				stx 	zTemp0						; save queue address
.d981	b981	84 37		sty $37				sty 	zTemp0+1
.d983	b983	ae b1 09	ldx $09b1			ldx 	SNDLength 					; queue is full, can't take any more.
.d986	b986	e0 20		cpx #$20			cpx 	#SNDQueueSize
.d988	b988	f0 21		beq $b9ab			beq 	_SNDQRExit
.d98a	b98a	29 03		and #$03			and 	#3	 						; channel # and push on stack
.d98c	b98c	48		pha				pha
.d98d	b98d	8a		txa				txa  								; get offset in queue buffer/
.d98e	b98e	0a		asl a				asl 	a
.d98f	b98f	0a		asl a				asl 	a
.d990	b990	0a		asl a				asl 	a
.d991	b991	aa		tax				tax
.d992	b992	68		pla				pla 								; get back and push again
.d993	b993	48		pha				pha
.d994	b994	9d b2 09	sta $09b2,x			sta 	SNDQueue+0,x 				; save the channel #
.d997	b997	a0 00		ldy #$00			ldy 	#0 							; copy the rest in.
.d999	b999					_SNDQCopy:
.d999	b999	b1 36		lda ($36),y			lda 	(zTemp0),y
.d99b	b99b	e8		inx				inx
.d99c	b99c	c8		iny				iny
.d99d	b99d	9d b2 09	sta $09b2,x			sta 	SNDQueue,x
.d9a0	b9a0	c0 06		cpy #$06			cpy 	#6
.d9a2	b9a2	d0 f5		bne $b999			bne 	_SNDQCopy
.d9a4	b9a4	ee b1 09	inc $09b1			inc 	SNDLength 					; bump queue length.
.d9a7	b9a7	68		pla				pla 								; get channel # back
.d9a8	b9a8	20 d3 b8	jsr $b8d3			jsr 	SNDCheckChannel 			; check if channel needs refreshing.
.d9ab	b9ab					_SNDQRExit:
.d9ab	b9ab	60		rts				rts
.d9ac	b9ac					SNDSilenceChannel:
.d9ac	b9ac	aa		tax				tax 								; zero time left.
.d9ad	b9ad	9e be 0a	stz $0abe,x			stz 	SNDTimeLeft,x
.d9b0	b9b0	0a		asl a				asl 	a 							; shift into position
.d9b1	b9b1	0a		asl a				asl 	a
.d9b2	b9b2	0a		asl a				asl 	a
.d9b3	b9b3	0a		asl a				asl 	a
.d9b4	b9b4	0a		asl a				asl 	a
.d9b5	b9b5	09 9f		ora #$9f			ora 	#$9F 						; write register attenuation $F
.d9b7	b9b7	20 bb b9	jsr $b9bb			jsr 	SNDWritePorts
.d9ba	b9ba	60		rts				rts
.d9bb	b9bb					SNDWritePorts:
.d9bb	b9bb	da		phx				phx 								; save X
.d9bc	b9bc	a6 01		ldx $01				ldx 	1 							; save I/O status
.d9be	b9be	64 01		stz $01				stz 	1 							; access I/O page 0
.d9c0	b9c0	8d 00 d6	sta $d600			sta 	$D600 						; write to both
.d9c3	b9c3	8d 10 d6	sta $d610			sta 	$D610
.d9c6	b9c6	86 01		stx $01				stx 	1 							; restore I/O
.d9c8	b9c8	fa		plx				plx 								; restore X
.d9c9	b9c9	60		rts				rts
.d9ca	b9ca					Export_SNDCommand:
.d9ca	b9ca	da		phx				phx 								; save XY
.d9cb	b9cb	5a		phy				phy
.d9cc	b9cc	c9 0f		cmp #$0f			cmp 	#$0F 						; $0F is initialise
.d9ce	b9ce	f0 1d		beq $b9ed			beq 	_SNDInitialise
.d9d0	b9d0	90 28		bcc $b9fa			bcc 	_SNDExit
.d9d2	b9d2	c9 3f		cmp #$3f			cmp 	#$3F 						; $3F is silence all
.d9d4	b9d4	f0 17		beq $b9ed			beq 	_SNDSilence
.d9d6	b9d6	b0 22		bcs $b9fa			bcs 	_SNDExit
.d9d8	b9d8	c9 20		cmp #$20			cmp 	#$20 						; $2x is check playing => A
.d9da	b9da	b0 09		bcs $b9e5			bcs 	_SNDQueryPlay
.d9dc	b9dc	c9 14		cmp #$14			cmp 	#$14 						; $10-$13 is queue sound
.d9de	b9de	b0 1a		bcs $b9fa			bcs 	_SNDExit
.d9e0	b9e0	20 7f b9	jsr $b97f			jsr 	SNDQueueRequest
.d9e3	b9e3	80 15		bra $b9fa			bra 	_SNDExit
.d9e5	b9e5					_SNDQueryPlay:
.d9e5	b9e5	29 03		and #$03			and 	#3 							; get channel #
.d9e7	b9e7	aa		tax				tax
.d9e8	b9e8	bd be 0a	lda $0abe,x			lda 	SNDTimeLeft,x 				; read time left, if zero then silent
.d9eb	b9eb	80 0d		bra $b9fa			bra 	_SNDExit
.d9ed	b9ed					_SNDInitialise:
.d9ed	b9ed					_SNDSilence:
.d9ed	b9ed	9c b1 09	stz $09b1			stz 	SNDLength 					; empty the queue.
.d9f0	b9f0	a9 03		lda #$03			lda 	#$3 						; silence channel 0-3.
.d9f2	b9f2					_SNDSilenceLoop:
.d9f2	b9f2	48		pha				pha
.d9f3	b9f3	20 ac b9	jsr $b9ac			jsr 	SNDSilenceChannel
.d9f6	b9f6	68		pla				pla
.d9f7	b9f7	3a		dec a				dec 	a
.d9f8	b9f8	10 f8		bpl $b9f2			bpl 	_SNDSilenceLoop
.d9fa	b9fa					_SNDExit:
.d9fa	b9fa	7a		ply				ply
.d9fb	b9fb	fa		plx				plx
.d9fc	b9fc	60		rts				rts
=32						SNDQueueSize = 32 							; number of queue entries
.09b1						SNDLength:
>09b1								.fill 	1
.09b2						SNDQueue:
>09b2								.fill 	SNDQueueSize * 8
.0ab2						SNDPitchLow:
>0ab2								.fill 	4
.0ab6						SNDPitchHigh:
>0ab6								.fill 	4
.0aba						SNDVolume:
>0aba								.fill 	4
.0abe						SNDTimeLeft:
>0abe								.fill 	4
.0ac2						SNDAdjustLow:
>0ac2								.fill 	4
.0ac6						SNDAdjustHigh:
>0ac6								.fill 	4
.d9fd	b9fd					Export_SNDUpdate:
.d9fd	b9fd					PagedSNDUpdate:
.d9fd	b9fd	ad be 0a	lda $0abe			lda 	SNDTimeLeft+0 				; look at time remaining
.da00	ba00	f0 05		beq $ba07			beq 	_SNDUNot0 					; not playing
.da02	ba02	a2 00		ldx #$00			ldx 	#0 							; so we know which channel to update
.da04	ba04	20 26 ba	jsr $ba26			jsr 	SNDUpdateChannel 			; update it.
.da07	ba07					_SNDUNot0:
.da07	ba07	ad bf 0a	lda $0abf			lda 	SNDTimeLeft+1
.da0a	ba0a	f0 05		beq $ba11			beq 	_SNDUNot1
.da0c	ba0c	a2 01		ldx #$01			ldx 	#1
.da0e	ba0e	20 26 ba	jsr $ba26			jsr 	SNDUpdateChannel
.da11	ba11					_SNDUNot1:
.da11	ba11	ad c0 0a	lda $0ac0			lda 	SNDTimeLeft+2
.da14	ba14	f0 05		beq $ba1b			beq 	_SNDUNot2
.da16	ba16	a2 02		ldx #$02			ldx 	#2
.da18	ba18	20 26 ba	jsr $ba26			jsr 	SNDUpdateChannel
.da1b	ba1b					_SNDUNot2:
.da1b	ba1b	ad c1 0a	lda $0ac1			lda 	SNDTimeLeft+3
.da1e	ba1e	f0 05		beq $ba25			beq 	_SNDUNot3
.da20	ba20	a2 03		ldx #$03			ldx 	#3
.da22	ba22	20 26 ba	jsr $ba26			jsr 	SNDUpdateChannel
.da25	ba25					_SNDUNot3:
.da25	ba25	60		rts				rts
.da26	ba26					SNDUpdateChannel:
.da26	ba26	c9 ff		cmp #$ff			cmp 	#$FF 						; sound $FF play forever until turned off manually
.da28	ba28	f0 2c		beq $ba56			beq 	_SNDUCExit
.da2a	ba2a	3a		dec a				dec 	a 							; decrement and update timer
.da2b	ba2b	9d be 0a	sta $0abe,x			sta 	SNDTimeLeft,x
.da2e	ba2e	f0 1d		beq $ba4d			beq 	_SNDUCUpdate 				; if zero, silence channel
.da30	ba30	bd c2 0a	lda $0ac2,x			lda 	SNDAdjustLow,x 				; adjust ?
.da33	ba33	1d c6 0a	ora $0ac6,x			ora 	SNDAdjustHigh,x
.da36	ba36	f0 1e		beq $ba56			beq 	_SNDUCExit 					; if zero carry on at current tone.
.da38	ba38	18		clc				clc 								; add adjust, forcing into a 10 bit range
.da39	ba39	bd b2 0a	lda $0ab2,x			lda 	SNDPitchLow,x
.da3c	ba3c	7d c2 0a	adc $0ac2,x			adc 	SNDAdjustLow,x
.da3f	ba3f	9d b2 0a	sta $0ab2,x			sta 	SNDPitchLow,x
.da42	ba42	bd b6 0a	lda $0ab6,x			lda 	SNDPitchHigh,x
.da45	ba45	7d c6 0a	adc $0ac6,x			adc 	SNDAdjustHigh,x
.da48	ba48	29 03		and #$03			and 	#3
.da4a	ba4a	9d b6 0a	sta $0ab6,x			sta 	SNDPitchHigh,x
.da4d	ba4d					_SNDUCUpdate:
.da4d	ba4d	8a		txa				txa 								; which channel.
.da4e	ba4e	48		pha				pha
.da4f	ba4f	20 12 b9	jsr $b912			jsr 	SNDUpdateNote 				; update the current note
.da52	ba52	68		pla				pla
.da53	ba53	20 d3 b8	jsr $b8d3			jsr 	SNDCheckChannel 			; more to do ?
.da56	ba56					_SNDUCExit:
.da56	ba56	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/.build/kernel.module.asm

=1						kernelIntegrated=1

;******  Return to file: _basic.asm


;******  Processing file: ../modules/hardware/header/.build/headerdata.dat

=14						Header_Height = 14
=255						Header_RLE = 255
.e000	a000					Header_jattrs:
>e000	a000	ff f2 58 f2 ff d8 07 d8			.byte	255,242,88,242,255,216,7,216,255,242,2,242,255,216,6,216,255,242,2,242,255,216,8,216,255,242,2,242,255,216,6,216,255,242,9,242,210,210,242,242,255,210,7,210,255,242,17,242,104,104,255,242,7,242,104,104,255,242,4,242,104,104,242,242,104,104,255,242,8,242,104,104,255,242,4,242,104,104,255,242,8,242,210,210,242,242,210,210,255,242,4,242,210,210,255,242,16,242,232,232,255,242,14,242,232,232,242,242,232,232,255,242,8,242,232,232,255,242,15,242,210,210,242,242,210,210,255,242,4,242,210,210,255,242,16,242,255,56,5,56,255,242,4,242,255,56,6,56,255,242,2,242,255,56,7,56,255,242,2,242,255,56,7,56,255,242,9,242,210,210,242,242,255,210,7,210,255,242,17,242,120,120,255,242,7,242,120,120,255,242,15,242,120,120,242,242,120,120,255,242,4,242,120,120,242,242,210,210,255,242,4,242,210,210,242,242,210,210,255,242,2,242,210,210,255,242,18,242,168,168,255,242,7,242,168,168,255,242,8,242,168,168,255,242,4,242,168,168,242,242,168,168,255,242,4,242,168,168,242,242,210,210,255,242,4,242,210,210,242,242,210,210,255,242,3,242,210,210,255,242,17,242,72,72,255,242,7,242,255,72,8,72,255,242,2,242,255,72,6,72,255,242,3,242,255,72,6,72,255,242,3,242,255,210,4,210,209,210,255,242,2,242,210,210,255,242,4,242,210,210,255,242,87,242,255,114,80,114,255,226,27,226,114,255,146,3,146,145,255,114,18,114,255,194,24,194,114,114,255,226,27,226,114,255,146,3,146,145,255,114,18,114,255,194,24,194,114,114,255,226,27,226,114,255,146,3,146,145,255,114,18,114,255,194,24,194,255,114,80,114,255,0
>e008	a008	ff f2 02 f2 ff d8 06 d8 ff f2 02 f2 ff d8 08 d8
>e018	a018	ff f2 02 f2 ff d8 06 d8 ff f2 09 f2 d2 d2 f2 f2
>e028	a028	ff d2 07 d2 ff f2 11 f2 68 68 ff f2 07 f2 68 68
>e038	a038	ff f2 04 f2 68 68 f2 f2 68 68 ff f2 08 f2 68 68
>e048	a048	ff f2 04 f2 68 68 ff f2 08 f2 d2 d2 f2 f2 d2 d2
>e058	a058	ff f2 04 f2 d2 d2 ff f2 10 f2 e8 e8 ff f2 0e f2
>e068	a068	e8 e8 f2 f2 e8 e8 ff f2 08 f2 e8 e8 ff f2 0f f2
>e078	a078	d2 d2 f2 f2 d2 d2 ff f2 04 f2 d2 d2 ff f2 10 f2
>e088	a088	ff 38 05 38 ff f2 04 f2 ff 38 06 38 ff f2 02 f2
>e098	a098	ff 38 07 38 ff f2 02 f2 ff 38 07 38 ff f2 09 f2
>e0a8	a0a8	d2 d2 f2 f2 ff d2 07 d2 ff f2 11 f2 78 78 ff f2
>e0b8	a0b8	07 f2 78 78 ff f2 0f f2 78 78 f2 f2 78 78 ff f2
>e0c8	a0c8	04 f2 78 78 f2 f2 d2 d2 ff f2 04 f2 d2 d2 f2 f2
>e0d8	a0d8	d2 d2 ff f2 02 f2 d2 d2 ff f2 12 f2 a8 a8 ff f2
>e0e8	a0e8	07 f2 a8 a8 ff f2 08 f2 a8 a8 ff f2 04 f2 a8 a8
>e0f8	a0f8	f2 f2 a8 a8 ff f2 04 f2 a8 a8 f2 f2 d2 d2 ff f2
>e108	a108	04 f2 d2 d2 f2 f2 d2 d2 ff f2 03 f2 d2 d2 ff f2
>e118	a118	11 f2 48 48 ff f2 07 f2 ff 48 08 48 ff f2 02 f2
>e128	a128	ff 48 06 48 ff f2 03 f2 ff 48 06 48 ff f2 03 f2
>e138	a138	ff d2 04 d2 d1 d2 ff f2 02 f2 d2 d2 ff f2 04 f2
>e148	a148	d2 d2 ff f2 57 f2 ff 72 50 72 ff e2 1b e2 72 ff
>e158	a158	92 03 92 91 ff 72 12 72 ff c2 18 c2 72 72 ff e2
>e168	a168	1b e2 72 ff 92 03 92 91 ff 72 12 72 ff c2 18 c2
>e178	a178	72 72 ff e2 1b e2 72 ff 92 03 92 91 ff 72 12 72
>e188	a188	ff c2 18 c2 ff 72 50 72 ff 00
.e192	a192					Header_jchars:
>e192	a192	ff 20 58 20 ff 08 07 08			.byte	255,32,88,32,255,8,7,8,255,32,2,32,255,8,6,8,255,32,2,32,255,8,8,8,255,32,2,32,255,8,6,8,255,32,9,32,252,252,32,32,255,252,7,252,255,32,17,32,8,8,255,32,7,32,8,8,255,32,4,32,8,8,32,32,8,8,255,32,8,32,8,8,255,32,4,32,8,8,255,32,8,32,252,252,32,32,252,252,255,32,4,32,252,252,255,32,16,32,8,8,255,32,14,32,8,8,32,32,8,8,255,32,8,32,8,8,255,32,15,32,252,252,32,32,252,252,255,32,4,32,252,252,255,32,16,32,255,8,5,8,255,32,4,32,255,8,6,8,255,32,2,32,255,8,7,8,255,32,2,32,255,8,7,8,255,32,9,32,252,252,32,32,255,252,7,252,255,32,17,32,8,8,255,32,7,32,8,8,255,32,15,32,8,8,32,32,8,8,255,32,4,32,8,8,32,32,252,252,255,32,4,32,252,252,32,32,252,252,255,32,2,32,252,252,255,32,18,32,8,8,255,32,7,32,8,8,255,32,8,32,8,8,255,32,4,32,8,8,32,32,8,8,255,32,4,32,8,8,32,32,252,252,255,32,4,32,252,252,32,32,252,252,255,32,3,32,252,252,255,32,17,32,8,8,255,32,7,32,255,8,8,8,255,32,2,32,255,8,6,8,255,32,3,32,255,8,6,8,255,32,3,32,255,252,6,252,255,32,2,32,252,252,255,32,4,32,252,252,255,32,87,32,160,255,150,27,150,155,255,150,22,150,155,255,150,24,150,161,130,72,97,114,100,119,97,114,101,255,32,19,32,130,215,50,48,50,51,32,83,116,101,102,97,110,121,32,65,108,108,97,105,114,101,32,32,130,99,50,53,54,102,111,101,110,105,120,46,99,111,109,47,102,50,53,54,45,106,114,255,32,2,32,130,130,77,105,99,114,111,75,101,114,110,101,108,255,32,16,32,130,215,50,48,50,51,32,74,101,115,115,105,101,32,79,98,101,114,114,101,117,116,101,114,130,71,97,100,103,101,116,64,72,97,99,107,119,114,101,110,99,104,76,97,98,115,46,99,111,109,130,130,83,117,112,101,114,66,65,83,73,67,255,32,17,32,130,215,50,48,50,51,32,80,97,117,108,32,82,111,98,115,111,110,255,32,5,32,130,80,97,117,108,64,82,111,98,115,111,110,115,46,111,114,103,46,117,107,255,32,5,32,130,162,255,150,27,150,157,255,150,22,150,157,255,150,24,150,163,255,0
>e19a	a19a	ff 20 02 20 ff 08 06 08 ff 20 02 20 ff 08 08 08
>e1aa	a1aa	ff 20 02 20 ff 08 06 08 ff 20 09 20 fc fc 20 20
>e1ba	a1ba	ff fc 07 fc ff 20 11 20 08 08 ff 20 07 20 08 08
>e1ca	a1ca	ff 20 04 20 08 08 20 20 08 08 ff 20 08 20 08 08
>e1da	a1da	ff 20 04 20 08 08 ff 20 08 20 fc fc 20 20 fc fc
>e1ea	a1ea	ff 20 04 20 fc fc ff 20 10 20 08 08 ff 20 0e 20
>e1fa	a1fa	08 08 20 20 08 08 ff 20 08 20 08 08 ff 20 0f 20
>e20a	a20a	fc fc 20 20 fc fc ff 20 04 20 fc fc ff 20 10 20
>e21a	a21a	ff 08 05 08 ff 20 04 20 ff 08 06 08 ff 20 02 20
>e22a	a22a	ff 08 07 08 ff 20 02 20 ff 08 07 08 ff 20 09 20
>e23a	a23a	fc fc 20 20 ff fc 07 fc ff 20 11 20 08 08 ff 20
>e24a	a24a	07 20 08 08 ff 20 0f 20 08 08 20 20 08 08 ff 20
>e25a	a25a	04 20 08 08 20 20 fc fc ff 20 04 20 fc fc 20 20
>e26a	a26a	fc fc ff 20 02 20 fc fc ff 20 12 20 08 08 ff 20
>e27a	a27a	07 20 08 08 ff 20 08 20 08 08 ff 20 04 20 08 08
>e28a	a28a	20 20 08 08 ff 20 04 20 08 08 20 20 fc fc ff 20
>e29a	a29a	04 20 fc fc 20 20 fc fc ff 20 03 20 fc fc ff 20
>e2aa	a2aa	11 20 08 08 ff 20 07 20 ff 08 08 08 ff 20 02 20
>e2ba	a2ba	ff 08 06 08 ff 20 03 20 ff 08 06 08 ff 20 03 20
>e2ca	a2ca	ff fc 06 fc ff 20 02 20 fc fc ff 20 04 20 fc fc
>e2da	a2da	ff 20 57 20 a0 ff 96 1b 96 9b ff 96 16 96 9b ff
>e2ea	a2ea	96 18 96 a1 82 48 61 72 64 77 61 72 65 ff 20 13
>e2fa	a2fa	20 82 d7 32 30 32 33 20 53 74 65 66 61 6e 79 20
>e30a	a30a	41 6c 6c 61 69 72 65 20 20 82 63 32 35 36 66 6f
>e31a	a31a	65 6e 69 78 2e 63 6f 6d 2f 66 32 35 36 2d 6a 72
>e32a	a32a	ff 20 02 20 82 82 4d 69 63 72 6f 4b 65 72 6e 65
>e33a	a33a	6c ff 20 10 20 82 d7 32 30 32 33 20 4a 65 73 73
>e34a	a34a	69 65 20 4f 62 65 72 72 65 75 74 65 72 82 47 61
>e35a	a35a	64 67 65 74 40 48 61 63 6b 77 72 65 6e 63 68 4c
>e36a	a36a	61 62 73 2e 63 6f 6d 82 82 53 75 70 65 72 42 41
>e37a	a37a	53 49 43 ff 20 11 20 82 d7 32 30 32 33 20 50 61
>e38a	a38a	75 6c 20 52 6f 62 73 6f 6e ff 20 05 20 82 50 61
>e39a	a39a	75 6c 40 52 6f 62 73 6f 6e 73 2e 6f 72 67 2e 75
>e3aa	a3aa	6b ff 20 05 20 82 a2 ff 96 1b 96 9d ff 96 16 96
>e3ba	a3ba	9d ff 96 18 96 a3 ff 00
.e3c2	a3c2					Header_kattrs:
>e3c2	a3c2	ff f2 5e f2 ff d8 07 d8			.byte	255,242,94,242,255,216,7,216,255,242,2,242,255,216,6,216,255,242,2,242,255,216,8,216,255,242,2,242,255,216,6,216,255,242,2,242,210,210,255,242,3,242,210,210,255,242,28,242,104,104,255,242,7,242,104,104,255,242,4,242,104,104,242,242,104,104,255,242,8,242,104,104,255,242,4,242,104,104,242,242,210,210,255,242,2,242,210,210,255,242,29,242,232,232,255,242,14,242,232,232,242,242,232,232,255,242,8,242,232,232,255,242,8,242,210,210,242,242,210,210,255,242,30,242,255,56,5,56,255,242,4,242,255,56,6,56,255,242,2,242,255,56,7,56,255,242,2,242,255,56,7,56,255,242,2,242,255,210,4,210,255,242,31,242,120,120,255,242,7,242,120,120,255,242,15,242,113,113,242,242,113,113,255,242,4,242,113,113,242,242,210,210,242,242,210,210,255,242,30,242,168,168,255,242,7,242,168,168,255,242,8,242,168,168,255,242,4,242,168,168,242,242,168,168,255,242,4,242,168,168,242,242,210,210,255,242,2,242,210,210,255,242,29,242,72,72,255,242,7,242,255,72,8,72,255,242,2,242,255,72,6,72,255,242,3,242,255,72,6,72,255,242,2,242,210,210,255,242,3,242,210,210,255,242,93,242,255,114,80,114,255,226,27,226,114,255,146,4,146,255,114,18,114,255,194,24,194,114,114,255,226,27,226,114,255,146,4,146,255,114,18,114,255,194,24,194,114,114,255,226,27,226,114,255,146,4,146,255,114,18,114,255,194,24,194,255,114,80,114,255,0
>e3ca	a3ca	ff f2 02 f2 ff d8 06 d8 ff f2 02 f2 ff d8 08 d8
>e3da	a3da	ff f2 02 f2 ff d8 06 d8 ff f2 02 f2 d2 d2 ff f2
>e3ea	a3ea	03 f2 d2 d2 ff f2 1c f2 68 68 ff f2 07 f2 68 68
>e3fa	a3fa	ff f2 04 f2 68 68 f2 f2 68 68 ff f2 08 f2 68 68
>e40a	a40a	ff f2 04 f2 68 68 f2 f2 d2 d2 ff f2 02 f2 d2 d2
>e41a	a41a	ff f2 1d f2 e8 e8 ff f2 0e f2 e8 e8 f2 f2 e8 e8
>e42a	a42a	ff f2 08 f2 e8 e8 ff f2 08 f2 d2 d2 f2 f2 d2 d2
>e43a	a43a	ff f2 1e f2 ff 38 05 38 ff f2 04 f2 ff 38 06 38
>e44a	a44a	ff f2 02 f2 ff 38 07 38 ff f2 02 f2 ff 38 07 38
>e45a	a45a	ff f2 02 f2 ff d2 04 d2 ff f2 1f f2 78 78 ff f2
>e46a	a46a	07 f2 78 78 ff f2 0f f2 71 71 f2 f2 71 71 ff f2
>e47a	a47a	04 f2 71 71 f2 f2 d2 d2 f2 f2 d2 d2 ff f2 1e f2
>e48a	a48a	a8 a8 ff f2 07 f2 a8 a8 ff f2 08 f2 a8 a8 ff f2
>e49a	a49a	04 f2 a8 a8 f2 f2 a8 a8 ff f2 04 f2 a8 a8 f2 f2
>e4aa	a4aa	d2 d2 ff f2 02 f2 d2 d2 ff f2 1d f2 48 48 ff f2
>e4ba	a4ba	07 f2 ff 48 08 48 ff f2 02 f2 ff 48 06 48 ff f2
>e4ca	a4ca	03 f2 ff 48 06 48 ff f2 02 f2 d2 d2 ff f2 03 f2
>e4da	a4da	d2 d2 ff f2 5d f2 ff 72 50 72 ff e2 1b e2 72 ff
>e4ea	a4ea	92 04 92 ff 72 12 72 ff c2 18 c2 72 72 ff e2 1b
>e4fa	a4fa	e2 72 ff 92 04 92 ff 72 12 72 ff c2 18 c2 72 72
>e50a	a50a	ff e2 1b e2 72 ff 92 04 92 ff 72 12 72 ff c2 18
>e51a	a51a	c2 ff 72 50 72 ff 00
.e521	a521					Header_kchars:
>e521	a521	ff 20 5e 20 ff 08 07 08			.byte	255,32,94,32,255,8,7,8,255,32,2,32,255,8,6,8,255,32,2,32,255,8,8,8,255,32,2,32,255,8,6,8,255,32,2,32,180,180,255,32,3,32,180,180,255,32,28,32,8,8,255,32,7,32,8,8,255,32,4,32,8,8,32,32,8,8,255,32,8,32,8,8,255,32,4,32,8,8,32,32,180,180,255,32,2,32,180,180,255,32,29,32,8,8,255,32,14,32,8,8,32,32,8,8,255,32,8,32,8,8,255,32,8,32,180,180,32,32,180,180,255,32,30,32,255,8,5,8,255,32,4,32,255,8,6,8,255,32,2,32,255,8,7,8,255,32,2,32,255,8,7,8,255,32,2,32,255,180,4,180,255,32,31,32,8,8,255,32,7,32,8,8,255,32,15,32,8,8,32,32,8,8,255,32,4,32,8,8,32,32,180,180,32,32,180,180,255,32,30,32,8,8,255,32,7,32,8,8,255,32,8,32,8,8,255,32,4,32,8,8,32,32,8,8,255,32,4,32,8,8,32,32,180,180,255,32,2,32,180,180,255,32,29,32,8,8,255,32,7,32,255,8,8,8,255,32,2,32,255,8,6,8,255,32,3,32,255,8,6,8,255,32,2,32,180,180,255,32,3,32,180,180,255,32,93,32,188,255,150,27,150,155,255,150,22,150,155,255,150,24,150,189,130,72,97,114,100,119,97,114,101,255,32,19,32,130,215,50,48,50,51,32,83,116,101,102,97,110,121,32,65,108,108,97,105,114,101,32,32,130,99,50,53,54,102,111,101,110,105,120,46,99,111,109,47,102,50,53,54,45,106,114,255,32,2,32,130,130,77,105,99,114,111,75,101,114,110,101,108,255,32,16,32,130,215,50,48,50,51,32,74,101,115,115,105,101,32,79,98,101,114,114,101,117,116,101,114,130,71,97,100,103,101,116,64,72,97,99,107,119,114,101,110,99,104,76,97,98,115,46,99,111,109,130,130,83,117,112,101,114,66,65,83,73,67,255,32,17,32,130,215,50,48,50,51,32,80,97,117,108,32,82,111,98,115,111,110,255,32,5,32,130,80,97,117,108,64,82,111,98,115,111,110,115,46,111,114,103,46,117,107,255,32,5,32,130,190,255,150,27,150,157,255,150,22,150,157,255,150,24,150,191,255,0
>e529	a529	ff 20 02 20 ff 08 06 08 ff 20 02 20 ff 08 08 08
>e539	a539	ff 20 02 20 ff 08 06 08 ff 20 02 20 b4 b4 ff 20
>e549	a549	03 20 b4 b4 ff 20 1c 20 08 08 ff 20 07 20 08 08
>e559	a559	ff 20 04 20 08 08 20 20 08 08 ff 20 08 20 08 08
>e569	a569	ff 20 04 20 08 08 20 20 b4 b4 ff 20 02 20 b4 b4
>e579	a579	ff 20 1d 20 08 08 ff 20 0e 20 08 08 20 20 08 08
>e589	a589	ff 20 08 20 08 08 ff 20 08 20 b4 b4 20 20 b4 b4
>e599	a599	ff 20 1e 20 ff 08 05 08 ff 20 04 20 ff 08 06 08
>e5a9	a5a9	ff 20 02 20 ff 08 07 08 ff 20 02 20 ff 08 07 08
>e5b9	a5b9	ff 20 02 20 ff b4 04 b4 ff 20 1f 20 08 08 ff 20
>e5c9	a5c9	07 20 08 08 ff 20 0f 20 08 08 20 20 08 08 ff 20
>e5d9	a5d9	04 20 08 08 20 20 b4 b4 20 20 b4 b4 ff 20 1e 20
>e5e9	a5e9	08 08 ff 20 07 20 08 08 ff 20 08 20 08 08 ff 20
>e5f9	a5f9	04 20 08 08 20 20 08 08 ff 20 04 20 08 08 20 20
>e609	a609	b4 b4 ff 20 02 20 b4 b4 ff 20 1d 20 08 08 ff 20
>e619	a619	07 20 ff 08 08 08 ff 20 02 20 ff 08 06 08 ff 20
>e629	a629	03 20 ff 08 06 08 ff 20 02 20 b4 b4 ff 20 03 20
>e639	a639	b4 b4 ff 20 5d 20 bc ff 96 1b 96 9b ff 96 16 96
>e649	a649	9b ff 96 18 96 bd 82 48 61 72 64 77 61 72 65 ff
>e659	a659	20 13 20 82 d7 32 30 32 33 20 53 74 65 66 61 6e
>e669	a669	79 20 41 6c 6c 61 69 72 65 20 20 82 63 32 35 36
>e679	a679	66 6f 65 6e 69 78 2e 63 6f 6d 2f 66 32 35 36 2d
>e689	a689	6a 72 ff 20 02 20 82 82 4d 69 63 72 6f 4b 65 72
>e699	a699	6e 65 6c ff 20 10 20 82 d7 32 30 32 33 20 4a 65
>e6a9	a6a9	73 73 69 65 20 4f 62 65 72 72 65 75 74 65 72 82
>e6b9	a6b9	47 61 64 67 65 74 40 48 61 63 6b 77 72 65 6e 63
>e6c9	a6c9	68 4c 61 62 73 2e 63 6f 6d 82 82 53 75 70 65 72
>e6d9	a6d9	42 41 53 49 43 ff 20 11 20 82 d7 32 30 32 33 20
>e6e9	a6e9	50 61 75 6c 20 52 6f 62 73 6f 6e ff 20 05 20 82
>e6f9	a6f9	50 61 75 6c 40 52 6f 62 73 6f 6e 73 2e 6f 72 67
>e709	a709	2e 75 6b ff 20 05 20 82 be ff 96 1b 96 9d ff 96
>e719	a719	16 96 9d ff 96 18 96 bf ff 00
.e723	a723					Header_Palette:
>e723	a723	00 00 00 00				.dword $000000
>e727	a727	66 66 66 00				.dword $666666
>e72b	a72b	aa 00 00 00				.dword $0000aa
>e72f	a72f	00 aa 00 00				.dword $00aa00
>e733	a733	ea 41 c0 00				.dword $c041ea
>e737	a737	00 48 87 00				.dword $874800
>e73b	a73b	00 9c ff 00				.dword $ff9c00
>e73f	a73f	ff db 57 00				.dword $57dbff
>e743	a743	28 3f 3f 00				.dword $3f3f28
>e747	a747	8a aa aa 00				.dword $aaaa8a
>e74b	a74b	ff 55 55 00				.dword $5555ff
>e74f	a74f	55 ff 55 00				.dword $55ff55
>e753	a753	ed 8d ff 00				.dword $ff8ded
>e757	a757	00 00 ff 00				.dword $ff0000
>e75b	a75b	55 ff ff 00				.dword $ffff55
>e75f	a75f	ff ff ff 00				.dword $ffffff
>e763	a763	ff ff ff 00				.dword $ffffff
>e767	a767	ff ff ff 00				.dword $ffffff

;******  Return to file: _basic.asm


;******  End of listing
