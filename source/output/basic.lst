
; 64tass Turbo Assembler Macro V1.57.2900 listing file
; 64tass -D AUTORUN=0 "-D MONITOR_ADDRESS=\$E000" "-D LOCKOUT_ADDRESS=\$F000" "-D BASIC_ADDRESS=\$38000" "-D SOURCE_ADDRESS=\$28000" "-D SPRITE_ADDRESS=\$30000" -q -b -Wall -c -D "HARDWARE=0 $'\x9'$'\x9'$'\x9'$'\x9'$'\x9'$'\x9'" -L output/basic.lst -l output/basic.lbl -Wall -o build/basic.rom _basic.asm
; Tue Dec  6 08:05:16 2022

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=0					AUTORUN=0
=$e000					 MONITOR_ADDRESS=$E000
=$f000					 LOCKOUT_ADDRESS=$F000
=$38000					 BASIC_ADDRESS=$38000
=$28000					 SOURCE_ADDRESS=$28000
=$30000					 SPRITE_ADDRESS=$30000
=0					HARDWARE=0

;******  Processing input file: _basic.asm


;******  Processing file: ./common/aa.system/01common.inc

=$30					ZeroPageMandatory = $30
=$50					ZeroPagePreference = $50
=$400					MemoryStorage = $400
=$2000					BasicStart = $2000
=$8000					BasicEnd = $8000
=$8000					CodeStart = $8000
=$1000					VariableSpace = $1000
=$2000					EndVariableSpace = $2000
=8					MathStackSize = 8
=512					BasicStackSize = 512
=3584					BasicStackBase = $1000-BasicStackSize
=80					MaxLineSize = 80

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/02macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/04data.inc

.0030					codePtr:
>0030							.fill 	4
.0034					basicStack:
>0034							.fill 	2
.0036					zTemp0:
>0036							.fill 	2
.0038					zTemp1:
>0038							.fill 	2
.003a					zTemp2:
>003a							.fill 	2
.003c					zsTemp:
>003c							.fill 	2
.003e					zaTemp:
>003e							.fill 	2
=$30					safePtr = codePtr 							; minimise direct tinkering
=$80					NSBIsNegative = $80 						; bit 7 : sign of mantissa (where numeric)
=$20					NSBIsReference = $20 						; bit 5 : is a reference
=$10					NSBIsString = $10 							; bit 4 : set if string (procedures don't go on the stack)
=$18					NSBTypeMask = $18 							; bits 4,3 : 00 int 01 float 10 string 11 procedure
=$03					NSBRefMask = $03 							; bits 0,1 : Bytes of reference, 00 = 4,01 = 1,10=2
=$04					NSBIsArray = $04
=$00					NSTInteger = $00 							; base types for bits 3..4
=$08					NSTFloat = $08
=$10					NSTString = $10
=$18					NSTProcedure = $18
.0050					NSStatus:
>0050							.fill 	MathStackSize
.0058					NSMantissa0:
>0058							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0060					NSMantissa1:
>0060							.fill 	MathStackSize
.0068					NSMantissa2:
>0068							.fill 	MathStackSize
.0070					NSMantissa3:
>0070							.fill 	MathStackSize
.0078					NSExponent:
>0078							.fill 	MathStackSize
.0400					identStart:
>0400							.fill 	1
.0401					identTypeStart:
>0401							.fill 	1
.0402					identTypeEnd:
>0402							.fill 	1
.0403					identHash:
>0403							.fill 	1
.0404					identTypeByte:
>0404							.fill 	1	 						; (see tokenising.pdf)
.0405					encodeState:
>0405							.fill 	1
.0406					digitTemp:
>0406							.fill 	1
.0407					decimalCount:
>0407							.fill 	1
.0408					randomSeed:
>0408							.fill 	4
.040c					lowMemPtr:
>040c							.fill 	2
.040e					stringMemory:
>040e							.fill 	2
.0410					stringInitialised:
>0410							.fill 	1
.0411					stringTempPointer:
>0411							.fill 	2
.0413					breakCheck:
>0413							.fill 	1
.0414					decimalPlaces:
>0414							.fill 	1
.0415					dbOffset:
>0415							.fill 	1
.0416					lastParameter:
>0416							.fill 	1
.0417					dataPointer:
>0417							.fill 	5
.041c					inDataStatement:
>041c							.fill 	1
.041d					tbOffset:
>041d							.fill 	1
.041e					AssemblerAddress:
>041e							.fill 	2
.0420					AssemblerControl:
>0420							.fill 	1
.0421					ParamStart:
>0421							.fill 	2
.0423					IsGroup1:
>0423							.fill 	1
.0424					BaseOpcode:
>0424							.fill 	1
.0425					ModeMask:
>0425							.fill 	1
.0426					listIndent:
>0426							.fill 	1
.0427					lcLastCharacter:
>0427							.fill 	1
.0428					isInputFlag:
>0428							.fill 	1
.0429					currentListColour:
>0429							.fill 	1
.042a					tokenOffset:
>042a							.fill 	1
.042b					tokenLineNumber:
>042b							.fill 	2
.042d					tokenBuffer:
>042d							.fill 	253
.052a					lineBuffer:
>052a							.fill 	253
.0627					numberBuffer:
>0627							.fill 	34
.0649					decimalBuffer:
>0649							.fill 	16

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/constants.inc

=$80					AM_ISZP = $80
=$40					AM_ISG1 = $40
=$20					AM_ISG2 = $20
=224					AM_IMMEDIATE = AM_ISZP+AM_ISG1+AM_ISG2+$00
=228					AM_ZEROPAGE = AM_ISZP+AM_ISG1+AM_ISG2+$04
=40					AM_ACC = AM_ISG2+$08
=108					AM_ABS = AM_ISG1+AM_ISG2+$0C
=208					AM_INDY = AM_ISZP+AM_ISG1+$10
=244					AM_ZEROX = AM_ISZP+AM_ISG1+AM_ISG2+$14
=120					AM_ABSY = AM_ISG1+AM_ISG2+$18
=124					AM_ABSX = AM_ISG1+AM_ISG2+$1C
=209					AM_IND = AM_ISZP+AM_ISG1+$11
=$80					AM_ZEROY = AM_ISZP
=$01					AM_INDABS = $01
=$02					AM_INDABSX = $02
=192					AM_INDX = AM_ISZP+AM_ISG1+$00

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/handlers.inc


;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.inc

=1					ERRID_BREAK = 1
=2					ERRID_SYNTAX = 2
=3					ERRID_DIVZERO = 3
=4					ERRID_RANGE = 4
=5					ERRID_TYPE = 5
=6					ERRID_MEMORY = 6
=7					ERRID_ARGUMENT = 7
=8					ERRID_STOP = 8
=9					ERRID_STRING = 9
=10					ERRID_ASSERT = 10
=11					ERRID_DATA = 11
=12					ERRID_NOTDONE = 12
=13					ERRID_LINE = 13
=14					ERRID_GOSUB = 14
=15					ERRID_REPEAT = 15
=16					ERRID_WHILE = 16
=17					ERRID_FOR = 17
=18					ERRID_STACK = 18
=19					ERRID_STRUCT = 19
=20					ERRID_PROC = 20
=21					ERRID_REDEFINE = 21
=22					ERRID_ARRAYSIZE = 22
=23					ERRID_ARRAYIDX = 23

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst.inc

=$00					KWD_LESSLESS                         = $00; $00 <<
=$01					KWD_LESSEQUAL                        = $01; $01 <=
=$02					KWD_LESSGREATER                      = $02; $02 <>
=$03					KWD_PLINGPLING3                      = $03; $03 !!3
=$04					KWD_GREATERLESS                      = $04; $04 ><
=$05					KWD_GREATEREQUAL                     = $05; $05 >=
=$06					KWD_GREATERGREATER                   = $06; $06 >>
=$07					KWD_PLINGPLING7                      = $07; $07 !!7
=$08					KWD_PLINGPLING8                      = $08; $08 !!8
=$09					KWD_PLINGPLING9                      = $09; $09 !!9
=$0a					KWD_PLINGPLING10                     = $0a; $0a !!10
=$0b					KWD_PLINGPLING11                     = $0b; $0b !!11
=$0c					KWD_PLINGPLING12                     = $0c; $0c !!12
=$0d					KWD_PLINGPLING13                     = $0d; $0d !!13
=$0e					KWD_PLINGPLING14                     = $0e; $0e !!14
=$0f					KWD_PLINGPLING15                     = $0f; $0f !!15
=$10					KWD_AT                               = $10; $10 @
=$11					KWD_PLINGPLING17                     = $11; $11 !!17
=$12					KWD_PLINGPLING18                     = $12; $12 !!18
=$13					KWD_LSQPAREN                         = $13; $13 [
=$14					KWD_BACKSLASH                        = $14; $14 \
=$15					KWD_RSQPAREN                         = $15; $15 ]
=$16					KWD_HAT                              = $16; $16 ^
=$17					KWD_UNDERSCORE                       = $17; $17 _
=$18					KWD_BQUOTE                           = $18; $18 `
=$19					KWD_PLINGPLING25                     = $19; $19 !!25
=$1a					KWD_PLINGPLING26                     = $1a; $1a !!26
=$1b					KWD_LCURLY                           = $1b; $1b {
=$1c					KWD_BAR                              = $1c; $1c |
=$1d					KWD_RCURLY                           = $1d; $1d }
=$1e					KWD_TILDE                            = $1e; $1e ~
=$21					KWD_PLING                            = $21; $21 !
=$22					KWD_DQUOTE                           = $22; $22 "
=$23					KWD_HASH                             = $23; $23 #
=$24					KWD_DOLLAR                           = $24; $24 $
=$25					KWD_PERCENT                          = $25; $25 %
=$26					KWD_AMPERSAND                        = $26; $26 &
=$27					KWD_QUOTE                            = $27; $27 '
=$28					KWD_LPAREN                           = $28; $28 (
=$29					KWD_RPAREN                           = $29; $29 )
=$2a					KWD_STAR                             = $2a; $2a *
=$2b					KWD_PLUS                             = $2b; $2b +
=$2c					KWD_COMMA                            = $2c; $2c ,
=$2d					KWD_MINUS                            = $2d; $2d -
=$2e					KWD_PERIOD                           = $2e; $2e .
=$2f					KWD_SLASH                            = $2f; $2f /
=$30					KWD_0                                = $30; $30 0
=$31					KWD_1                                = $31; $31 1
=$32					KWD_2                                = $32; $32 2
=$33					KWD_3                                = $33; $33 3
=$34					KWD_4                                = $34; $34 4
=$35					KWD_5                                = $35; $35 5
=$36					KWD_6                                = $36; $36 6
=$37					KWD_7                                = $37; $37 7
=$38					KWD_8                                = $38; $38 8
=$39					KWD_9                                = $39; $39 9
=$3a					KWD_COLON                            = $3a; $3a :
=$3b					KWD_SEMICOLON                        = $3b; $3b ;
=$3c					KWD_LESS                             = $3c; $3c <
=$3d					KWD_EQUAL                            = $3d; $3d =
=$3e					KWD_GREATER                          = $3e; $3e >
=$3f					KWD_QMARK                            = $3f; $3f ?
=$83					KWD_ABSLPAREN                        = $83; $83 ABS(
=$84					KWD_ALLOCLPAREN                      = $84; $84 ALLOC(
=$85					KWD_ASCLPAREN                        = $85; $85 ASC(
=$86					KWD_CHRDOLLARLPAREN                  = $86; $86 CHR$(
=$87					KWD_DEEKLPAREN                       = $87; $87 DEEK(
=$88					KWD_EVENTLPAREN                      = $88; $88 EVENT(
=$89					KWD_FALSE                            = $89; $89 FALSE
=$8a					KWD_FRACLPAREN                       = $8a; $8a FRAC(
=$8b					KWD_HITLPAREN                        = $8b; $8b HIT(
=$8c					KWD_INTLPAREN                        = $8c; $8c INT(
=$8d					KWD_ISVALLPAREN                      = $8d; $8d ISVAL(
=$8e					KWD_JOYBLPAREN                       = $8e; $8e JOYB(
=$8f					KWD_JOYXLPAREN                       = $8f; $8f JOYX(
=$90					KWD_JOYYLPAREN                       = $90; $90 JOYY(
=$91					KWD_LEFTDOLLARLPAREN                 = $91; $91 LEFT$(
=$92					KWD_LENLPAREN                        = $92; $92 LEN(
=$93					KWD_MAXLPAREN                        = $93; $93 MAX(
=$94					KWD_MIDDOLLARLPAREN                  = $94; $94 MID$(
=$95					KWD_MINLPAREN                        = $95; $95 MIN(
=$96					KWD_NOTLPAREN                        = $96; $96 NOT(
=$97					KWD_PEEKLPAREN                       = $97; $97 PEEK(
=$98					KWD_PLAYINGLPAREN                    = $98; $98 PLAYING(
=$99					KWD_RANDOMLPAREN                     = $99; $99 RANDOM(
=$9a					KWD_RIGHTDOLLARLPAREN                = $9a; $9a RIGHT$(
=$9b					KWD_RNDLPAREN                        = $9b; $9b RND(
=$9c					KWD_SGNLPAREN                        = $9c; $9c SGN(
=$9d					KWD_SPCLPAREN                        = $9d; $9d SPC(
=$9e					KWD_STRDOLLARLPAREN                  = $9e; $9e STR$(
=$9f					KWD_TIMERLPAREN                      = $9f; $9f TIMER(
=$a0					KWD_TRUE                             = $a0; $a0 TRUE
=$a1					KWD_VALLPAREN                        = $a1; $a1 VAL(
=$a2					KWD_FOR                              = $a2; $a2 FOR
=$a3					KWD_IF                               = $a3; $a3 IF
=$a4					KWD_PROC                             = $a4; $a4 PROC
=$a5					KWD_REPEAT                           = $a5; $a5 REPEAT
=$a6					KWD_WHILE                            = $a6; $a6 WHILE
=$a7					KWD_ENDIF                            = $a7; $a7 ENDIF
=$a8					KWD_ENDPROC                          = $a8; $a8 ENDPROC
=$a9					KWD_NEXT                             = $a9; $a9 NEXT
=$aa					KWD_THEN                             = $aa; $aa THEN
=$ab					KWD_UNTIL                            = $ab; $ab UNTIL
=$ac					KWD_WEND                             = $ac; $ac WEND
=$ad					KWD_BY                               = $ad; $ad BY
=$ae					KWD_CALL                             = $ae; $ae CALL
=$af					KWD_CIRCLE                           = $af; $af CIRCLE
=$b0					KWD_CLEAR                            = $b0; $b0 CLEAR
=$b1					KWD_CLS                              = $b1; $b1 CLS
=$b2					KWD_COLOR                            = $b2; $b2 COLOR
=$b3					KWD_COLOUR                           = $b3; $b3 COLOUR
=$b4					KWD_DATA                             = $b4; $b4 DATA
=$b5					KWD_DIM                              = $b5; $b5 DIM
=$b6					KWD_DOKE                             = $b6; $b6 DOKE
=$b7					KWD_DOWNTO                           = $b7; $b7 DOWNTO
=$b8					KWD_ELSE                             = $b8; $b8 ELSE
=$b9					KWD_FROM                             = $b9; $b9 FROM
=$ba					KWD_GFX                              = $ba; $ba GFX
=$bb					KWD_GOSUB                            = $bb; $bb GOSUB
=$bc					KWD_GOTO                             = $bc; $bc GOTO
=$bd					KWD_HERE                             = $bd; $bd HERE
=$be					KWD_IMAGE                            = $be; $be IMAGE
=$bf					KWD_INPUT                            = $bf; $bf INPUT
=$c0					KWD_LET                              = $c0; $c0 LET
=$c1					KWD_LINE                             = $c1; $c1 LINE
=$c2					KWD_LOCAL                            = $c2; $c2 LOCAL
=$c3					KWD_OFF                              = $c3; $c3 OFF
=$c4					KWD_ON                               = $c4; $c4 ON
=$c5					KWD_OUTLINE                          = $c5; $c5 OUTLINE
=$c6					KWD_PALETTE                          = $c6; $c6 PALETTE
=$c7					KWD_PLOT                             = $c7; $c7 PLOT
=$c8					KWD_POKE                             = $c8; $c8 POKE
=$c9					KWD_PRINT                            = $c9; $c9 PRINT
=$ca					KWD_READ                             = $ca; $ca READ
=$cb					KWD_RECT                             = $cb; $cb RECT
=$cc					KWD_REM                              = $cc; $cc REM
=$cd					KWD_RETURN                           = $cd; $cd RETURN
=$ce					KWD_SOLID                            = $ce; $ce SOLID
=$cf					KWD_SOUND                            = $cf; $cf SOUND
=$d0					KWD_SPRITE                           = $d0; $d0 SPRITE
=$d1					KWD_TEXT                             = $d1; $d1 TEXT
=$d2					KWD_TO                               = $d2; $d2 TO

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst0.inc

=$80					KWC_EOL = $80
=$ff					KWC_STRING = $FF
=$fe					KWC_HEXCONST = $FE
=$a2					KWC_FIRST_STRUCTURE = $a2
=$a7					KWC_FIRST_STRUCTURE_DEC = $a7
=$ac					KWC_LAST_STRUCTURE = $ac
=$83					KWC_FIRST_UNARY = $83
=$a1					KWC_LAST_UNARY = $a1

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/access.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/stack.inc

=$e0					STK_GOSUB = $E0
=$d0					STK_FOR = $D0
=$c0					STK_REPEAT = $C0
=$b0					STK_PROC = $B0
=$a0					STK_WHILE = $A0
=$01					STK_LOCALN = $01
=$02					STK_LOCALS = $02

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/00start.asm

.8000	4c 24 80	jmp $8024	Boot:	jmp 	Start

;******  Processing file: ./common/aa.system/../../../modules/_build/_linker.module

=0					PagingEnabled = 0
.8003					EXTPrintCharacter:
.8003	4c e2 a7	jmp $a7e2		jmp	Export_EXTPrintCharacter
.8006					EXTInitialise:
.8006	4c 7b aa	jmp $aa7b		jmp	Export_EXTInitialise
.8009					EXTInputSingleCharacter:
.8009	4c b1 aa	jmp $aab1		jmp	Export_EXTInputSingleCharacter
.800c					EXTBreakCheck:
.800c	4c d7 aa	jmp $aad7		jmp	Export_EXTBreakCheck
.800f					EXTReadController:
.800f	4c da aa	jmp $aada		jmp	Export_EXTReadController
.8012					EXTInputLine:
.8012	4c 91 a9	jmp $a991		jmp	Export_EXTInputLine
.8015					GXGraphicDraw:
.8015	4c 75 ab	jmp $ab75		jmp	Export_GXGraphicDraw
.8018					SNDCommand:
.8018	4c 5a be	jmp $be5a		jmp	Export_SNDCommand
.801b					SNDUpdate:
.801b	4c 8d be	jmp $be8d		jmp	Export_SNDUpdate
.801e					TKListConvertLine:
.801e	4c 50 b8	jmp $b850		jmp	Export_TKListConvertLine
.8021					TKTokeniseLine:
.8021	4c e4 ba	jmp $bae4		jmp	Export_TKTokeniseLine

;******  Return to file: ./common/aa.system/00start.asm

.8024	a2 ff		ldx #$ff	Start:	ldx 	#$FF 						; stack reset
.8026	9a		txs				txs
.8027	20 0c 80	jsr $800c			jsr 	EXTBreakCheck 				; added to stop initial break bug.
.802a	a5 00		lda $00				lda 	0  							; turn on editing of MMU LUT
.802c	09 80		ora #$80			ora 	#$80
.802e	85 00		sta $00				sta 	0
.8030	20 06 80	jsr $8006			jsr 	EXTInitialise 				; hardware initialise
.8033	a9 00		lda #$00			lda 	#0 							; graphics system initialise.
.8035	aa		tax				tax
.8036	a8		tay				tay
.8037	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.803a	a9 0f		lda #$0f			lda 	#$0F 						; initialise sound system
.803c	20 18 80	jsr $8018			jsr 	SNDCommand
.803f	a2 80		ldx #$80			ldx 	#Prompt >> 8 				; display prompt
.8041	a9 4f		lda #$4f			lda 	#Prompt & $FF
.8043	20 52 8f	jsr $8f52			jsr 	PrintStringXA
.8046	20 2e 8a	jsr $8a2e			jsr 	NewProgram 					; erase current program
.8049	4c d7 83	jmp $83d7			jmp 	WarmStart					; make same size.
.804c	4c d7 83	jmp $83d7			jmp 	WarmStart
>804f	36 35 30 32 20 53 75 70		Prompt:	.text 	"6502 SuperBASIC",13
>8057	65 72 42 41 53 49 43 0d
>805f	43 6f 70 79 72 69 67 68				.text 	"Copyright 2022 Paul Robson",13
>8067	74 20 32 30 32 32 20 50 61 75 6c 20 52 6f 62 73
>8077	6f 6e 0d
>807a	50 61 75 6c 40 52 6f 62				.text  	"Paul@Robsons.org.uk",13
>8082	73 6f 6e 73 2e 6f 72 67 2e 75 6b 0d
>808e	46 32 35 36 20					.text "F256 "

;******  Processing file: ./common/aa.system/../generated/timestamp.asm

>8093	41 6c 70 68 61 20 31 32			.text "Alpha 12 built 06-Dec-22. "
>809b	20 62 75 69 6c 74 20 30 36 2d 44 65 63 2d 32 32
>80ab	2e 20

;******  Return to file: ./common/aa.system/00start.asm

>80ad	0d						.byte  	13
>80ae	0d 0d 00					.text 	13,13,0

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/assembler.asm

.80b1					AssembleGroup1:
.80b1	a9 ff		lda #$ff			lda 	#$FF 						; flag for group 1 / mask.
.80b3	8d 25 04	sta $0425			sta 	ModeMask 					; initialise the mode mask - all for all
.80b6	80 02		bra $80ba			bra 	AsmGroup12
.80b8					AssembleGroup2:
.80b8	a9 00		lda #$00			lda 	#$00 						; flag for group 2
.80ba					AsmGroup12:
.80ba	8d 23 04	sta $0423			sta 	IsGroup1 					; save the 'group 1' flag
.80bd	68		pla				pla 								; pop the return address to access the information following.
.80be	fa		plx				plx
.80bf	20 46 81	jsr $8146			jsr 	AccessParameters 			; get opcode and save as base
.80c2	8d 24 04	sta $0424			sta 	BaseOpcode
.80c5	ad 23 04	lda $0423			lda 	IsGroup1 					; skip if group 1 as we don't have a complex mask.
.80c8	d0 08		bne $80d2			bne 	_AG12HaveMask
.80ca	a9 02		lda #$02			lda 	#2 							; if group 2 the second parameter is the mask
.80cc	20 4e 81	jsr $814e			jsr 	GetParameter		 		; e.g. which modes are supported for this operand
.80cf	8d 25 04	sta $0425			sta 	ModeMask
.80d2					_AG12HaveMask:
.80d2	20 82 82	jsr $8282			jsr 	TypeAndCalculateOperand 	; get zero page type
.80d5	da		phx				phx 								; save found address mode
.80d6	20 b2 81	jsr $81b2			jsr 	AssembleModeX
.80d9	fa		plx				plx  								; restore address mode
.80da	b0 0b		bcs $80e7			bcs 	_AG12Exit
.80dc	20 e8 80	jsr $80e8			jsr 	PromoteToAbsolute  			; promote ZP to ABS and try that
.80df	20 b2 81	jsr $81b2			jsr 	AssembleModeX
.80e2	b0 03		bcs $80e7			bcs 	_AG12Exit
.80e4	4c 99 9f	jmp $9f99			jmp 	SyntaxError 				; can't do either, so must be wrong mode/operand.
.80e7					_AG12Exit:
.80e7	60		rts				rts
.80e8					PromoteToAbsolute:
.80e8	a9 6c		lda #$6c			lda 	#AM_ABS 					; lda xx
.80ea	e0 e4		cpx #$e4			cpx 	#AM_ZEROPAGE
.80ec	f0 19		beq $8107			beq 	_PTADo
.80ee	a9 7c		lda #$7c			lda 	#AM_ABSX 					; lda xx,X
.80f0	e0 f4		cpx #$f4			cpx 	#AM_ZEROX
.80f2	f0 13		beq $8107			beq 	_PTADo
.80f4	a9 78		lda #$78			lda 	#AM_ABSY 					; lda xx,Y
.80f6	e0 80		cpx #$80			cpx 	#AM_ZEROY
.80f8	f0 0d		beq $8107			beq 	_PTADo
.80fa	a9 01		lda #$01			lda 	#AM_INDABS 					; lda (xx) (jump)
.80fc	e0 d1		cpx #$d1			cpx 	#AM_IND
.80fe	f0 07		beq $8107			beq 	_PTADo
.8100	a9 02		lda #$02			lda 	#AM_INDABSX 				; lda (xx,x) (jump)
.8102	e0 c0		cpx #$c0			cpx 	#AM_INDX
.8104	f0 01		beq $8107			beq 	_PTADo
.8106	60		rts				rts
.8107					_PTADo:
.8107	aa		tax				tax
.8108	60		rts				rts
.8109					AssembleGroup3:
.8109	68		pla				pla 								; get parameters, which is just the opcode.
.810a	fa		plx				plx
.810b	20 46 81	jsr $8146			jsr 	AccessParameters 			; get and output opcode
.810e	20 5e 81	jsr $815e			jsr 	AssemblerWriteByte
.8111	20 e6 82	jsr $82e6			jsr 	CalculateOperand 			; get a 16 bit operand
.8114	a5 58		lda $58				lda 	NSMantissa0 				; calculate the offset
.8116	38		sec				sec
.8117	ed 1e 04	sbc $041e			sbc 	AssemblerAddress
.811a	48		pha				pha 								; LSB in A
.811b	a5 60		lda $60				lda 	NSMantissa1
.811d	ed 1f 04	sbc $041f			sbc 	AssemblerAddress+1
.8120	aa		tax				tax 								; MSB in X
.8121	68		pla				pla
.8122	18		clc				clc 								; $80 to easy check $80-$7F, plus 1 for offset error
.8123	69 7f		adc #$7f			adc 	#$7F
.8125	90 01		bcc $8128			bcc 	_AG3NoCarry
.8127	e8		inx				inx
.8128					_AG3NoCarry:
.8128	38		sec				sec 								; fix back and write out anyways.
.8129	e9 80		sbc #$80			sbc 	#$80
.812b	20 5e 81	jsr $815e			jsr 	AssemblerWriteByte
.812e	e0 00		cpx #$00			cpx 	#0 							; was it in range
.8130	f0 0a		beq $813c			beq 	_AG3Exit
.8132	ad 20 04	lda $0420			lda 	AssemblerControl 			; are we allowing bad values ?
.8135	29 01		and #$01			and 	#1
.8137	f0 03		beq $813c			beq 	_AG3Exit
.8139	4c 9e 9f	jmp $9f9e			jmp 	RangeError 					; no, branch is out of range
.813c					_AG3Exit:
.813c	60		rts				rts
.813d					AssembleGroup4:
.813d	68		pla				pla 								; pop address
.813e	fa		plx				plx
.813f	20 46 81	jsr $8146			jsr 	AccessParameters 			; access and get first
.8142	20 5e 81	jsr $815e			jsr 	AssemblerWriteByte 			; output it.
.8145	60		rts				rts
.8146					AccessParameters:
.8146	8d 21 04	sta $0421			sta 	ParamStart
.8149	8e 22 04	stx $0422			stx 	ParamStart+1
.814c	a9 01		lda #$01			lda 	#1
.814e					GetParameter:
.814e	5a		phy				phy
.814f	a8		tay				tay
.8150	ad 21 04	lda $0421			lda 	ParamStart
.8153	85 36		sta $36				sta 	zTemp0
.8155	ad 22 04	lda $0422			lda 	ParamStart+1
.8158	85 37		sta $37				sta 	zTemp0+1
.815a	b1 36		lda ($36),y			lda 	(zTemp0),y
.815c	7a		ply				ply
.815d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/aswrite.asm

.815e					AssemblerWriteByte:
.815e	48		pha			pha
.815f	ad 20 04	lda $0420		lda 	AssemblerControl 				; check printing bytes ?
.8162	29 02		and #$02		and 	#2
.8164	f0 1b		beq $8181		beq 	_AWBNoPrint
.8166	ad 1f 04	lda $041f		lda		AssemblerAddress+1 				; print address
.8169	20 9c 81	jsr $819c		jsr 	PrintHex
.816c	ad 1e 04	lda $041e		lda		AssemblerAddress
.816f	20 9c 81	jsr $819c		jsr 	PrintHex
.8172	a9 20		lda #$20		lda 	#' '
.8174	20 03 80	jsr $8003		jsr 	EXTPrintCharacter
.8177	68		pla			pla 									; print byte
.8178	48		pha			pha
.8179	20 9c 81	jsr $819c		jsr 	PrintHex
.817c	a9 0d		lda #$0d		lda 	#13
.817e	20 03 80	jsr $8003		jsr 	EXTPrintCharacter
.8181					_AWBNoPrint:
.8181	ad 1e 04	lda $041e		lda		AssemblerAddress				; copy address to zTemp0
.8184	85 36		sta $36			sta 	zTemp0
.8186	ad 1f 04	lda $041f		lda		AssemblerAddress+1
.8189	f0 0e		beq $8199		beq 	_AWBRange
.818b	85 37		sta $37			sta 	zTemp0+1
.818d	68		pla			pla 									; write byte out
.818e	92 36		sta ($36)		sta 	(zTemp0)
.8190	ee 1e 04	inc $041e		inc 	AssemblerAddress 				; bump address
.8193	d0 03		bne $8198		bne 	_AWBNoCarry
.8195	ee 1f 04	inc $041f		inc 	AssemblerAddress+1
.8198					_AWBNoCarry:
.8198	60		rts			rts
.8199					_AWBRange:
.8199	4c 9e 9f	jmp $9f9e		jmp 	RangeError
.819c					PrintHex:
.819c	48		pha				pha
.819d	4a		lsr a				lsr 	a
.819e	4a		lsr a				lsr 	a
.819f	4a		lsr a				lsr 	a
.81a0	4a		lsr a				lsr 	a
.81a1	20 a5 81	jsr $81a5			jsr 	_PrintNibble
.81a4	68		pla				pla
.81a5					_PrintNibble:
.81a5	29 0f		and #$0f			and 	#15
.81a7	c9 0a		cmp #$0a			cmp 	#10
.81a9	90 02		bcc $81ad			bcc 	_NoShift
.81ab	69 06		adc #$06			adc 	#6
.81ad					_NoShift:
.81ad	69 30		adc #$30			adc 	#48
.81af	4c 03 80	jmp $8003			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/instruction.asm

.81b2					AssembleModeX:
.81b2	5a		phy				phy
.81b3	ad 23 04	lda $0423			lda 	IsGroup1
.81b6	f0 17		beq $81cf			beq 	_AMXGroup2
.81b8	8a		txa				txa 							; is it in group # 1
.81b9	29 40		and #$40			and 	#AM_ISG1
.81bb	f0 4d		beq $820a			beq 	_AMXFail 				; no, give up.
.81bd	8a		txa				txa 							; get back.
.81be	29 1f		and #$1f			and 	#$1F 					; this is now the offset.
.81c0	e0 e0		cpx #$e0			cpx 	#AM_IMMEDIATE 			; if not immediate, we can continue.
.81c2	d0 22		bne $81e6			bne 	_AMXHaveInfo
.81c4	ad 24 04	lda $0424			lda 	BaseOpcode 				; cannot store immediate.
.81c7	c9 81		cmp #$81			cmp 	#$81
.81c9	f0 3f		beq $820a			beq 	_AMXFail
.81cb	a9 08		lda #$08			lda 	#8 						; if immediate we use offset 8.
.81cd	80 17		bra $81e6			bra 	_AMXHaveInfo 			; odd design decision there.
.81cf					_AMXGroup2:
.81cf	8a		txa				txa 							; is it in group 2 ?
.81d0	29 20		and #$20			and 	#AM_ISG2
.81d2	f0 36		beq $820a			beq 	_AMXFail 				; no, give up.
.81d4	8a		txa				txa 							; get the offset into Y
.81d5	29 1f		and #$1f			and 	#$1F
.81d7	4a		lsr a				lsr 	a 						; make it 0-7.
.81d8	4a		lsr a				lsr  	a
.81d9	a8		tay				tay
.81da	ad 25 04	lda $0425			lda 	ModeMask 				; shift the modemask left so you can check it against the requested offset
.81dd					_AMXCheckOkay:
.81dd	0a		asl a				asl 	a 						; shift modemask left enough times to check legitimate.
.81de	88		dey				dey
.81df	10 fc		bpl $81dd			bpl 	_AMXCheckOkay
.81e1	90 27		bcc $820a			bcc 	_AMXFail 				; not allowed.
.81e3	8a		txa				txa  							; get mask back
.81e4	29 1f		and #$1f			and 	#$1F
.81e6					_AMXHaveInfo:
.81e6	e0 00		cpx #$00			cpx 	#$00 					; does it *require* an 8 bit operand
.81e8	10 04		bpl $81ee			bpl 	_AMXAnySize 			; checking bit 7, the zero page opcode flag.
.81ea	a4 60		ldy $60				ldy 	NSMantissa1 			; fail if it is outside range, e.g. the MSB is set.
.81ec	d0 1c		bne $820a			bne 	_AMXFail
.81ee					_AMXAnySize:
.81ee	18		clc				clc 							; add offset to the base opcode
.81ef	6d 24 04	adc $0424			adc 	BaseOpcode
.81f2					_AMXOutputCode:
.81f2	20 5e 81	jsr $815e			jsr 	AssemblerWriteByte 		; write the opcode out.
.81f5	e0 28		cpx #$28			cpx 	#AM_ACC 				; A mode (e.g. ASL)
.81f7	f0 0e		beq $8207			beq 	_AMXExit
.81f9	a5 58		lda $58				lda 	NSMantissa0 			; write LSB operand
.81fb	20 5e 81	jsr $815e			jsr 	AssemblerWriteByte
.81fe	e0 00		cpx #$00			cpx 	#$00 					; zeropage ?
.8200	30 05		bmi $8207			bmi 	_AMXExit
.8202	a5 60		lda $60				lda 	NSMantissa1 			; write MSB operand
.8204	20 5e 81	jsr $815e			jsr 	AssemblerWriteByte
.8207					_AMXExit:
.8207	7a		ply				ply
.8208	38		sec				sec
.8209	60		rts				rts
.820a					_AMXFail:
.820a	a0 00		ldy #$00			ldy 	#0
.820c					_AMXCheckOddities:
.820c	8a		txa				txa
.820d	d9 34 82	cmp $8234,y			cmp 	ExtraOpcode+2,y 		; match address mode
.8210	d0 15		bne $8227			bne 	_AMXCONext
.8212	b9 32 82	lda $8232,y			lda 	ExtraOpcode+0,y 		; do the base opcodes match
.8215	cd 24 04	cmp $0424			cmp 	BaseOpcode
.8218	d0 0d		bne $8227			bne 	_AMXCONext
.821a	e0 00		cpx #$00			cpx 	#$00 					; requires zero page ?
.821c	10 04		bpl $8222			bpl 	_AMXCONotZero
.821e	a5 60		lda $60				lda 	NSMantissa1
.8220	d0 05		bne $8227			bne 	_AMXCONext
.8222					_AMXCONotZero:
.8222	b9 33 82	lda $8233,y			lda 	ExtraOpcode+1,y 		; get new opcode
.8225	80 cb		bra $81f2			bra 	_AMXOutputCode 			; and assemble it
.8227					_AMXCONext:
.8227	c8		iny				iny
.8228	c8		iny				iny
.8229	c8		iny				iny
.822a	b9 32 82	lda $8232,y			lda 	ExtraOpcode+0,y 		; end of table
.822d	d0 dd		bne $820c			bne 	_AMXCheckOddities
.822f					_AMXCOFail:
.822f	7a		ply				ply
.8230	18		clc				clc
.8231	60		rts				rts
.8232					ExtraOpcode:
>8232	40 6c 01					.byte $40,$6c,AM_INDABS 	; jump
>8235	40 7c 02					.byte $40,$7C,AM_INDABSX 	; jump
>8238	a2 be 78					.byte $a2,$BE,AM_ABSY 		; ldx
>823b	a2 b6 80					.byte $a2,$B6,AM_ZEROY 		; ldx
>823e	82 96 80					.byte $82,$96,AM_ZEROY 		; stx
>8241	e2 1a 28					.byte $e2,$1a,AM_ACC 		; inc
>8244	c2 3a 28					.byte $c2,$3a,AM_ACC 		; dec
>8247	20 89 e0					.byte $20,$89,AM_IMMEDIATE 	; bit
>824a	60 9c 6c					.byte $60,$9c,AM_ABS 		; stz
>824d	60 9e 7c					.byte $60,$9e,AM_ABSX 		; stz
>8250	00						.byte $00

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/label.asm

.8251					LabelHere:
.8251	c8		iny				iny 								; skip .
.8252	a2 00		ldx #$00			ldx 	#0 							; get a term
.8254	20 47 98	jsr $9847			jsr 	EvaluateTerm
.8257	a5 50		lda $50				lda 	NSStatus 					; needs to be an integer reference.
.8259	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.825b	d0 22		bne $827f			bne 	_ALType 					; otherwise typing error
.825d	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy reference address to zTemp0
.825f	85 36		sta $36				sta 	zTemp0 						; (e.g. where we store the address)
.8261	b5 60		lda $60,x			lda 	NSMantissa1,x
.8263	85 37		sta $37				sta 	zTemp0+1
.8265	5a		phy				phy 								; copy address in (64k)
.8266	a0 01		ldy #$01			ldy 	#1
.8268	ad 1e 04	lda $041e			lda	 	AssemblerAddress
.826b	92 36		sta ($36)			sta 	(zTemp0)
.826d	ad 1f 04	lda $041f			lda	 	AssemblerAddress+1
.8270	91 36		sta ($36),y			sta 	(zTemp0),y
.8272	c8		iny				iny
.8273	a9 00		lda #$00			lda 	#0 							; zero the rest.
.8275	91 36		sta ($36),y			sta 	(zTemp0),y
.8277	c8		iny				iny
.8278	91 36		sta ($36),y			sta 	(zTemp0),y
.827a	c8		iny				iny
.827b	91 36		sta ($36),y			sta 	(zTemp0),y
.827d	7a		ply				ply
.827e	60		rts				rts
.827f					_ALType:
.827f	4c a3 9f	jmp $9fa3			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/operands.asm

.8282					TypeAndCalculateOperand:
.8282	b1 30		lda ($30),y			lda 	(codePtr),y
.8284	a2 28		ldx #$28			ldx 	#AM_ACC 					; ACC if : or EOL
.8286	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.8288	f0 5b		beq $82e5			beq 	_TACOExit
.828a	c9 80		cmp #$80			cmp 	#KWC_EOL
.828c	f0 57		beq $82e5			beq 	_TACOExit
.828e	c8		iny				iny
.828f	a2 e0		ldx #$e0			ldx 	#AM_IMMEDIATE
.8291	c9 23		cmp #$23			cmp 	#KWD_HASH 					; if hash, then immediate - constant.
.8293	f0 51		beq $82e6			beq 	CalculateOperand
.8295	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; if ( then check for indirection
.8297	f0 1f		beq $82b8			beq 	_TACOIndirect
.8299	88		dey				dey 								; undo get of first character
.829a	20 e6 82	jsr $82e6			jsr 	CalculateOperand 			; get operand
.829d	b1 30		lda ($30),y			lda 	(codePtr),y
.829f	a2 e4		ldx #$e4			ldx 	#AM_ZEROPAGE 				; if not, try zero page (then absolute)
.82a1	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.82a3	d0 40		bne $82e5			bne 	_TACOExit
.82a5	c8		iny				iny
.82a6	20 f0 82	jsr $82f0			jsr 	TACOCheckXY 				; extract X,Y or 0 (neither) from the variable.
.82a9	a2 f4		ldx #$f4			ldx 	#AM_ZEROX 					; check for X
.82ab	c9 58		cmp #$58			cmp 	#'X'
.82ad	f0 36		beq $82e5			beq 	_TACOExit
.82af	a2 80		ldx #$80			ldx 	#AM_ZEROY 					; check for Y
.82b1	c9 59		cmp #$59			cmp 	#'Y'
.82b3	f0 30		beq $82e5			beq 	_TACOExit
.82b5					_TACOSyntax:
.82b5	4c 99 9f	jmp $9f99			jmp 	SyntaxError
.82b8					_TACOIndirect:
.82b8	20 e6 82	jsr $82e6			jsr 	CalculateOperand 			; get the operand
.82bb	b1 30		lda ($30),y			lda 	(codePtr),y
.82bd	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if , then it must be ,X)
.82bf	f0 17		beq $82d8			beq 	_TACOIndX
.82c1	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket  			; otherwise must be ) or ),Y
.82c4	b1 30		lda ($30),y			lda 	(codePtr),y
.82c6	a2 d1		ldx #$d1			ldx 	#AM_IND
.82c8	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not comma then exit with (xx)
.82ca	d0 19		bne $82e5			bne 	_TACOExit
.82cc	c8		iny				iny
.82cd	20 f0 82	jsr $82f0			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.82d0	c9 59		cmp #$59			cmp 	#'Y' 						; check Y
.82d2	d0 e1		bne $82b5			bne 	_TACOSyntax
.82d4	a2 d0		ldx #$d0			ldx 	#AM_INDY
.82d6	80 0d		bra $82e5			bra 	_TACOExit
.82d8					_TACOIndX:
.82d8	c8		iny				iny
.82d9	20 f0 82	jsr $82f0			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.82dc	c9 58		cmp #$58			cmp 	#'X' 						; check X
.82de	d0 d5		bne $82b5			bne 	_TACOSyntax
.82e0	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket			; check )
.82e3	a2 c0		ldx #$c0			ldx 	#AM_INDX
.82e5					_TACOExit:
.82e5	60		rts				rts
.82e6					CalculateOperand:
.82e6	48		pha				pha
.82e7	da		phx				phx
.82e8	a2 00		ldx #$00			ldx 	#0 							; get 16 bit integer in Slot 0
.82ea	20 9b 9d	jsr $9d9b			jsr 	Evaluate16BitInteger
.82ed	fa		plx				plx
.82ee	68		pla				pla
.82ef	60		rts				rts
.82f0					TACOCheckXY:
.82f0	b1 30		lda ($30),y			lda 	(codePtr),y
.82f2	29 c0		and #$c0			and 	#$C0 						; check it is an identifier reference.
.82f4	c9 40		cmp #$40			cmp 	#$40
.82f6	d0 21		bne $8319			bne 	_TCXYFail
.82f8	b1 30		lda ($30),y			lda 	(codePtr),y
.82fa	18		clc				clc
.82fb	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.82fd	85 37		sta $37				sta 	zTemp0+1
.82ff	c8		iny				iny
.8300	b1 30		lda ($30),y			lda 	(codePtr),y
.8302	c8		iny				iny
.8303	85 36		sta $36				sta 	zTemp0
.8305	5a		phy				phy 								; save position
.8306	a0 02		ldy #$02			ldy 	#2 							; type is integer ?
.8308	b1 36		lda ($36),y			lda 	(zTemp0),y
.830a	d0 0c		bne $8318			bne 	_TCXYPopFail
.830c	a0 08		ldy #$08			ldy 	#8 							; get first character, should have bit 7 set as also last.
.830e	b1 36		lda ($36),y			lda 	(zTemp0),y
.8310	c9 d8		cmp #$d8			cmp 	#'X'+$80 					; should be X or Y
.8312	f0 08		beq $831c			beq 	_TCXYFound
.8314	c9 d9		cmp #$d9			cmp 	#'Y'+$80
.8316	f0 04		beq $831c			beq 	_TCXYFound
.8318					_TCXYPopFail:
.8318	7a		ply				ply
.8319					_TCXYFail:
.8319	a9 00		lda #$00			lda 	#0
.831b	60		rts				rts
.831c					_TCXYFound:
.831c	7a		ply				ply 								; restore position
.831d	29 7f		and #$7f			and 	#$7F 						; throw bit 7
.831f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/backload.asm

.8320					BackloadProgram:
.8320	20 2e 8a	jsr $8a2e			jsr 	NewProgram 					; does the actual NEW.
.8323	a2 83		ldx #$83			ldx 	#_BLLoad >> 8
.8325	a9 6f		lda #$6f			lda 	#_BLLoad & $FF
.8327	20 52 8f	jsr $8f52			jsr 	PrintStringXA
.832a	a9 14		lda #$14			lda 	#SOURCE_ADDRESS >> 13 		; start page
.832c	8d 59 06	sta $0659			sta 	BackLoadPage
.832f	a9 00		lda #$00			lda 	#(($6000) & $FF)
.8331	8d 5a 06	sta $065a			sta 	0+BackLoadPointer
.8334	a9 60		lda #$60			lda 	#(($6000) >> 8)
.8336	8d 5b 06	sta $065b			sta 	1+BackLoadPointer
.8339	a9 ff		lda #$ff			lda 	#$FF
.833b	8d fa ff	sta $fffa			sta 	$FFFA
.833e					_BPLoop:
.833e	a2 ff		ldx #$ff			ldx 	#$FF
.8340	20 84 83	jsr $8384			jsr 	BLReadByte 					; read a byte
.8343	c9 00		cmp #$00			cmp 	#0
.8345	f0 21		beq $8368			beq 	_BPExit 					; if 0 exit
.8347	30 1f		bmi $8368			bmi 	_BPExit 					; if -ve exit
.8349					_BPCopy:
.8349	e8		inx				inx  								; copy byte into the lineBuffer
.834a	9d 2a 05	sta $052a,x			sta 	lineBuffer,x
.834d	9e 2b 05	stz $052b,x			stz 	lineBuffer+1,x
.8350	20 84 83	jsr $8384			jsr 	BLReadByte 					; read next byte
.8353	30 0a		bmi $835f			bmi 	_BPEndLine 					; -ve = EOL
.8355	c9 09		cmp #$09			cmp 	#9 							; handle TAB, make it space.
.8357	d0 02		bne $835b			bne 	_BPNotTab
.8359	a9 20		lda #$20			lda 	#' '
.835b					_BPNotTab:
.835b	c9 20		cmp #$20			cmp 	#' ' 						; < ' ' = EOL
.835d	b0 ea		bcs $8349			bcs 	_BPCopy 					; until a control character, should be 13 received.
.835f					_BPEndLine:
.835f	20 21 80	jsr $8021			jsr 	TKTokeniseLine 				; tokenise the line.
.8362	38		sec				sec 								; append not insert
.8363	20 e0 a4	jsr $a4e0			jsr 	MemoryInsertLine 			; append to current program
.8366	80 d6		bra $833e			bra 	_BPLoop
.8368					_BPExit:
.8368	9c fa ff	stz $fffa			stz 	$FFFA
.836b	20 6d 84	jsr $846d			jsr 	ClearCommand 				; clear variables etc.
.836e	60		rts				rts
.836f					_BLLoad:
>836f	4c 6f 61 64 69 6e 67 20				.text 	"Loading from Memory",13,0
>8377	66 72 6f 6d 20 4d 65 6d 6f 72 79 0d 00
.8384					BLReadByte:
.8384	da		phx				phx
.8385	a6 0b		ldx $0b				ldx 	8+3 						; save current mapping for $6000 in X
.8387	ad 59 06	lda $0659			lda 	BackLoadPage	 			; set current page
.838a	85 0b		sta $0b				sta 	8+3
.838c	ad 5a 06	lda $065a			lda 	BackLoadPointer 			; copy pointer to zTemp0
.838f	85 36		sta $36				sta 	zTemp0
.8391	ad 5b 06	lda $065b			lda 	BackLoadPointer+1
.8394	85 37		sta $37				sta 	zTemp0+1
.8396	b2 36		lda ($36)			lda 	(zTemp0) 					; read next byte
.8398	ee 5a 06	inc $065a			inc 	BackLoadPointer 			; bump pointer
.839b	d0 0f		bne $83ac			bne 	_BLNoCarry
.839d	ee 5b 06	inc $065b			inc 	BackLoadPointer+1
.83a0	10 0a		bpl $83ac			bpl 	_BLNoCarry 					; need a new page
.83a2	48		pha				pha
.83a3	a9 60		lda #$60			lda 	#$60 						; reset pointer
.83a5	8d 5b 06	sta $065b			sta 	BackLoadPointer+1
.83a8	ee 59 06	inc $0659			inc 	BackLoadPage 				; next page from source.
.83ab	68		pla				pla
.83ac					_BLNoCarry:
.83ac	86 0b		stx $0b				stx 	8+3 						; restore mapping, then X.
.83ae	fa		plx				plx
.83af	c9 00		cmp #$00			cmp 	#0
.83b1	60		rts				rts
.0659					BackLoadPage:
>0659							.fill  	1
.065a					BackLoadPointer:
>065a							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/editor.asm

.83b2					EditProgramCode:
.83b2	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; try to find the line.
.83b5	ae 2c 04	ldx $042c			ldx 	TokenLineNumber+1
.83b8	20 84 a5	jsr $a584			jsr 	MemorySearch
.83bb	90 05		bcc $83c2			bcc 	_EPCNoDelete 				; reached the end : don't delete
.83bd	d0 03		bne $83c2			bne 	_EPCNoDelete 				; found slot but didn't match : no delete
.83bf	20 a9 a4	jsr $a4a9			jsr 	MemoryDeleteLine 			; delete the line
.83c2					_EPCNoDelete:
.83c2	ad 2d 04	lda $042d			lda 	TokenBuffer 				; buffer empty - we just want to delete a line.
.83c5	c9 80		cmp #$80			cmp 	#KWC_EOL
.83c7	f0 0d		beq $83d6			beq 	_EPCNoInsert
.83c9	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; find the line - it cannot exist as we've just deleted it.
.83cc	ae 2c 04	ldx $042c			ldx 	TokenLineNumber+1 			; so this can't fail, it returns some point in the code.
.83cf	20 84 a5	jsr $a584			jsr 	MemorySearch
.83d2	18		clc				clc 								; insert at this point.
.83d3	20 e0 a4	jsr $a4e0			jsr 	MemoryInsertLine 			; insert the line
.83d6					_EPCNoInsert:
.83d6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/warmstart.asm

.83d7					WarmStart:
.83d7	a2 ff		ldx #$ff			ldx 	#$FF
.83d9	9a		txs				txs
.83da	a9 85		lda #$85			lda 	#CLICommandLine+$80 		; set console colour whatever the current colour is.
.83dc	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.83df	20 12 80	jsr $8012			jsr 	EXTInputLine 				; get line to lineBuffer
.83e2	20 21 80	jsr $8021			jsr 	TKTokeniseLine 				; tokenise the line
.83e5	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; line number <> 0
.83e8	0d 2c 04	ora $042c			ora 	TokenLineNumber+1
.83eb	d0 17		bne $8404			bne 	_WSEditCode 				; if so,edit code.
.83ed	9c 2a 04	stz $042a			stz 	TokenOffset 				; zero the "offset", meaning it only runs one line.
.83f0	a9 2a		lda #$2a			lda 	#((TokenOffset) & $FF)
.83f2	85 30		sta $30				sta 	codePtr
.83f4	a9 04		lda #$04			lda 	#((TokenOffset) >> 8)
.83f6	85 31		sta $31				sta 	codePtr+1
.83f8	ad 2d 04	lda $042d			lda 	TokenBuffer 				; nothing to run
.83fb	c9 80		cmp #$80			cmp 	#KWC_EOL
.83fd	f0 d8		beq $83d7			beq 	WarmStart
.83ff	20 81 8b	jsr $8b81			jsr 	RUNCodePointerLine 			; execute that line.
.8402	80 d3		bra $83d7			bra 	WarmStart
.8404					_WSEditCode:
.8404	20 b2 83	jsr $83b2			jsr 	EditProgramCode 			; edit the program code
.8407	20 6d 84	jsr $846d			jsr 	ClearCommand 				; clear all variables etc.
.840a	80 cb		bra $83d7			bra 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assemble.asm

.840c					AssembleCommand:
.840c	a2 00		ldx #$00			ldx 	#0
.840e	20 9b 9d	jsr $9d9b			jsr 	Evaluate16BitInteger 		; start address
.8411	a5 58		lda $58				lda 	NSMantissa0
.8413	8d 1e 04	sta $041e			sta 	AssemblerAddress
.8416	a5 60		lda $60				lda 	NSMantissa1
.8418	8d 1f 04	sta $041f			sta 	AssemblerAddress+1
.841b	20 e8 8e	jsr $8ee8			jsr 	CheckComma
.841e	20 b6 9d	jsr $9db6			jsr 	Evaluate8BitInteger 		; options 0-3
.8421	a5 58		lda $58				lda 	NSMantissa0
.8423	8d 20 04	sta $0420			sta 	AssemblerControl
.8426	60		rts				rts
.8427	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assert.asm

.8428					AssertCommand:
.8428	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.842a	20 88 9d	jsr $9d88			jsr 	EvaluateInteger 			; the assert test
.842d	20 3d 9e	jsr $9e3d			jsr 	NSMIsZero 					; exit if result is non zero.
.8430	d0 05		bne $8437			bne 	_ACExit
.8432	a9 0a		lda #$0a		lda	#10
.8434	4c f9 8e	jmp $8ef9		jmp	ErrorHandler
.8437					_ACExit:
.8437	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/call.asm

.8438					CallCommand:
.8438	a2 00		ldx #$00			ldx 	#0 							; get the routine address to level 0
.843a	20 9b 9d	jsr $9d9b			jsr 	Evaluate16BitInteger
.843d					_CCClear
.843d	e8		inx				inx  								; clear 1,2 and 3 (for A X Y)
.843e	20 1b 9e	jsr $9e1b			jsr 	NSMSetZero 					; these are optional sequentially.
.8441	e0 04		cpx #$04			cpx 	#4
.8443	d0 f8		bne $843d			bne 	_CCClear
.8445	a2 00		ldx #$00			ldx 	#0 							; and keep trying while there are more values.
.8447					_CCCParam:
.8447	b1 30		lda ($30),y			lda 	(codePtr),y
.8449	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.844b	d0 09		bne $8456			bne 	_CCCRun6502
.844d	c8		iny				iny 								; skip comma
.844e	e8		inx				inx	 								; next level
.844f	20 b6 9d	jsr $9db6			jsr 	Evaluate8BitInteger 		; get A/X/Y
.8452	e0 03		cpx #$03			cpx 	#3
.8454	90 f1		bcc $8447			bcc 	_CCCParam 					; done all 3 ?
.8456					_CCCRun6502:
.8456	5a		phy				phy 								; save position
.8457	a5 60		lda $60				lda 	NSMantissa1 				; put address in zTemp0
.8459	85 37		sta $37				sta 	zTemp0+1
.845b	a5 58		lda $58				lda 	NSMantissa0
.845d	85 36		sta $36				sta 	zTemp0
.845f	a5 59		lda $59				lda 	NSMantissa0+1 				; get registers into A X Y
.8461	a6 5a		ldx $5a				ldx 	NSMantissa0+2
.8463	a4 5b		ldy $5b				ldy 	NSMantissa0+3
.8465	20 6a 84	jsr $846a			jsr 	_CCCZTemp0 					; call zTemp0
.8468	7a		ply				ply 								; restore position and exit
.8469	60		rts				rts
.846a					_CCCZTemp0:
.846a	6c 36 00	jmp ($0036)			jmp 	(zTemp0)

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/clear.asm

.846d					ClearCommand:
.846d	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.846f	85 36		sta $36				sta 	0+zTemp0
.8471	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.8473	85 37		sta $37				sta 	1+zTemp0
.8475					_ClearZeroLoop:
.8475	b2 36		lda ($36)			lda 	(zTemp0) 					; end of variables if offset is zero.
.8477	f0 24		beq $849d			beq 	_ClearZeroEnd
.8479	a0 03		ldy #$03			ldy 	#3 							; erase the variables
.847b	a9 00		lda #$00			lda 	#0 							; set all the data to zero.
.847d					_ClearOneVariable:
.847d	91 36		sta ($36),y			sta 	(zTemp0),y
.847f	c8		iny				iny
.8480	c0 08		cpy #$08			cpy 	#8
.8482	d0 f9		bne $847d			bne 	_ClearOneVariable
.8484	a0 02		ldy #$02			ldy 	#2 							; has it been marked procedure
.8486	b1 36		lda ($36),y			lda 	(zTemp0),y
.8488	c9 18		cmp #$18			cmp 	#NSTProcedure
.848a	d0 04		bne $8490			bne 	_ClearNotProcedure
.848c	a9 04		lda #$04			lda 	#NSTInteger+NSBIsArray 		; if so set it back to an integer array
.848e	91 36		sta ($36),y			sta 	(zTemp0),y 					; will be fixed on the pre-run scan.
.8490					_ClearNotProcedure:
.8490	18		clc				clc 								; go to the next variable
.8491	b2 36		lda ($36)			lda 	(zTemp0) 					; offset to next, add to zTemp0
.8493	65 36		adc $36				adc 	zTemp0
.8495	85 36		sta $36				sta 	zTemp0
.8497	90 dc		bcc $8475			bcc 	_ClearZeroLoop
.8499	e6 37		inc $37				inc 	zTemp0+1
.849b	80 d8		bra $8475			bra 	_ClearZeroLoop
.849d					_ClearZeroEnd:
.849d	18		clc				clc
.849e	a5 36		lda $36				lda 	zTemp0
.84a0	69 01		adc #$01			adc 	#1
.84a2	8d 0c 04	sta $040c			sta 	lowMemPtr
.84a5	a5 37		lda $37				lda 	zTemp0+1
.84a7	69 00		adc #$00			adc 	#0
.84a9	8d 0d 04	sta $040d			sta 	lowMemPtr+1
.84ac	20 10 a7	jsr $a710			jsr 	StackReset
.84af	20 76 a7	jsr $a776			jsr 	StringSystemInitialise
.84b2	20 e9 8d	jsr $8de9			jsr 	ProcedureScan
.84b5	20 30 8b	jsr $8b30			jsr 	Command_Restore
.84b8	9c 1e 04	stz $041e			stz 	AssemblerAddress
.84bb	9c 1f 04	stz $041f			stz 	AssemblerAddress+1
.84be	9c 20 04	stz $0420			stz 	AssemblerControl
.84c1	20 2e 9a	jsr $9a2e			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.84c4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/cls.asm

.84c5					ClearScreen:
.84c5	5a		phy				phy
.84c6	a9 0c		lda #$0c			lda 	#12 						; char code 12 clears the screen.
.84c8	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.84cb	7a		ply				ply
.84cc	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/data.asm

.84cd					Command_Data:
.84cd	a9 3a		lda #$3a			lda 	#KWD_COLON 					; advance to colon/EOL, e.g. ignore anything till then.
.84cf	a2 80		ldx #$80			ldx 	#KWC_EOL
.84d1	20 3b 8e	jsr $8e3b			jsr 	ScanForward
.84d4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dim.asm

.84d5					DimCommand:
.84d5	b1 30		lda ($30),y			lda 	(codePtr),y
.84d7	29 c0		and #$c0			and 	#$C0
.84d9	c9 40		cmp #$40			cmp 	#$40
.84db	d0 7a		bne $8557			bne 	_DCSyntax 				; n o, error.
.84dd	b1 30		lda ($30),y			lda 	(codePtr),y
.84df	18		clc				clc
.84e0	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.84e2	85 3f		sta $3f				sta 	zaTemp+1
.84e4	c8		iny				iny
.84e5	b1 30		lda ($30),y			lda 	(codePtr),y
.84e7	c8		iny				iny
.84e8	85 3e		sta $3e				sta 	zaTemp
.84ea	5a		phy				phy
.84eb	a0 02		ldy #$02			ldy 	#2 						; read type byte
.84ed	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84ef	29 18		and #$18			and 	#NSBTypeMask 			; check it's not a procedure
.84f1	c9 18		cmp #$18			cmp 	#NSTProcedure
.84f3	f0 62		beq $8557			beq 	_DCSyntax
.84f5	b1 3e		lda ($3e),y			lda 	(zaTemp),y 				; check it's an array
.84f7	29 04		and #$04			and 	#NSBIsArray
.84f9	f0 64		beq $855f			beq 	_DCType
.84fb	a0 04		ldy #$04			ldy 	#4 						; check not already defined
.84fd	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84ff	d0 59		bne $855a			bne 	_DCRedefine
.8501	7a		ply				ply
.8502	20 62 85	jsr $8562			jsr 	_DCGetSize 				; get array size, check it.
.8505	5a		phy				phy
.8506	a0 05		ldy #$05			ldy 	#5 						; store in first array size slot
.8508	91 3e		sta ($3e),y			sta 	(zaTemp),y 				; second will be zero.
.850a	7a		ply				ply 							; is there a second (e.g. ,x)
.850b	b1 30		lda ($30),y			lda 	(codePtr),y
.850d	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.850f	d0 0a		bne $851b			bne 	_DCOneDimension
.8511	c8		iny				iny 							; skip comma
.8512	20 62 85	jsr $8562			jsr 	_DCGetSize 				; get 2nd array size
.8515	5a		phy				phy
.8516	a0 06		ldy #$06			ldy 	#6 						; store in 2nd array size
.8518	91 3e		sta ($3e),y			sta 	(zaTemp),y
.851a	7a		ply				ply
.851b					_DCOneDimension:
.851b	5a		phy				phy 							; save position
.851c	a0 05		ldy #$05			ldy 	#5 						; dimensions + 1 in AX (as zero based)
.851e	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8520	aa		tax				tax
.8521	c8		iny				iny
.8522	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8524	e8		inx				inx 							; bump them.
.8525	1a		inc a				inc 	a
.8526	20 c6 9d	jsr $9dc6			jsr 	Multiply8x8 			; work out the total number of elements -> zTemp0
.8529	a5 37		lda $37				lda 	zTemp0+1 				; don't allow more than 8192 elements whatever
.852b	29 e0		and #$e0			and 	#$E0
.852d	d0 23		bne $8552			bne 	_DCSize
.852f	a0 02		ldy #$02			ldy 	#2 						; get base type
.8531	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8533	20 70 85	jsr $8570			jsr 	ScaleByBaseType 		; scale by base type
.8536	a5 36		lda $36				lda 	zTemp0
.8538	a6 37		ldx $37				ldx 	zTemp0+1
.853a	20 f0 99	jsr $99f0			jsr 	AllocateXABytes 		; allocate memory
.853d	a0 03		ldy #$03			ldy 	#3 						; copy into the address.
.853f	91 3e		sta ($3e),y			sta 	(zaTemp),y
.8541	c8		iny				iny
.8542	8a		txa				txa
.8543	91 3e		sta ($3e),y			sta 	(zaTemp),y
.8545	7a		ply				ply 							; get position back
.8546	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket 		; check )
.8549	b1 30		lda ($30),y			lda 	(codePtr),y
.854b	c8		iny				iny 							; consume in case
.854c	c9 2c		cmp #$2c			cmp 	#KWD_COMMA		 		; if so do another DIM.
.854e	f0 85		beq $84d5			beq 	DimCommand
.8550	88		dey				dey 							; undo consume
.8551	60		rts				rts
.8552					_DCSize:
.8552	a9 16		lda #$16		lda	#22
.8554	4c f9 8e	jmp $8ef9		jmp	ErrorHandler
.8557					_DCSyntax:
.8557	4c 99 9f	jmp $9f99			jmp 	SyntaxError
.855a					_DCRedefine:
.855a	a9 15		lda #$15		lda	#21
.855c	4c f9 8e	jmp $8ef9		jmp	ErrorHandler
.855f					_DCType:
.855f	4c a3 9f	jmp $9fa3			jmp 	TypeError
.8562					_DCGetSize:
.8562	a2 00		ldx #$00			ldx 	#0 						; get first index.
.8564	20 b6 9d	jsr $9db6			jsr 	Evaluate8BitInteger 	; get array dimension
.8567	c9 00		cmp #$00			cmp 	#0 						; must be 1-254
.8569	f0 e7		beq $8552			beq 	_DCSize
.856b	c9 fe		cmp #$fe			cmp 	#254
.856d	f0 e3		beq $8552			beq 	_DCSize
.856f	60		rts				rts
.8570					ScaleByBaseType:
.8570	29 10		and #$10			and 	#NSBIsString 			; is it string
.8572	d0 19		bne $858d			bne 	_SBBTString
.8574	a5 37		lda $37				lda 	zTemp0+1 				; push value on stack
.8576	48		pha				pha
.8577	a5 36		lda $36				lda 	zTemp0
.8579	48		pha				pha
.857a	06 36		asl $36				asl 	zTemp0 					; x 2
.857c	26 37		rol $37				rol 	zTemp0+1
.857e	06 36		asl $36				asl 	zTemp0 					; x 4
.8580	26 37		rol $37				rol 	zTemp0+1
.8582	68		pla				pla 							; add stacked value = x 5
.8583	65 36		adc $36				adc 	zTemp0
.8585	85 36		sta $36				sta 	zTemp0
.8587	68		pla				pla
.8588	65 37		adc $37				adc 	zTemp0+1
.858a	85 37		sta $37				sta 	zTemp0+1
.858c	60		rts				rts
.858d					_SBBTString:
.858d	06 36		asl $36				asl 	zTemp0
.858f	26 37		rol $37				rol 	zTemp0+1
.8591	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dokepoke.asm

.8592					PokeCommand:
.8592	18		clc				clc
.8593	80 01		bra $8596			bra 	DPCommand
.8595					DokeCommand:
.8595	38		sec				sec
.8596					DPCommand:
.8596	08		php				php									; save on stack, CS = Doke, CC = Poke
.8597	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.8599	20 9b 9d	jsr $9d9b			jsr		Evaluate16BitInteger 		; address
.859c	20 e8 8e	jsr $8ee8			jsr 	CheckComma
.859f	e8		inx				inx
.85a0	20 9b 9d	jsr $9d9b			jsr		Evaluate16BitInteger 		; data
.85a3	a5 58		lda $58				lda 	NSMantissa0 				; copy address
.85a5	85 36		sta $36				sta 	zTemp0
.85a7	a5 60		lda $60				lda 	NSMantissa1
.85a9	85 37		sta $37				sta 	zTemp0+1
.85ab	a5 59		lda $59				lda 	NSMantissa0+1 				; low byte
.85ad	92 36		sta ($36)			sta 	(zTemp0)
.85af	28		plp				plp 								; done if POKE
.85b0	90 08		bcc $85ba			bcc 	_DPExit
.85b2	5a		phy				phy 								; write high byte out.
.85b3	a0 01		ldy #$01			ldy 	#1
.85b5	a5 61		lda $61				lda 	NSMantissa1+1
.85b7	91 36		sta ($36),y			sta 	(zTemp0),y
.85b9	7a		ply				ply
.85ba					_DPExit:
.85ba	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/end.asm

.85bb					EndCommand:
.85bb	4c d7 83	jmp $83d7			jmp 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/for.asm

.85be					ForCommand:
.85be	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; allocate 18 bytes on the return stack (see above).
.85c0	20 aa a6	jsr $a6aa			jsr 	StackOpen
.85c3	a2 00		ldx #$00			ldx 	#0
.85c5	20 47 98	jsr $9847			jsr 	EvaluateTerm
.85c8	b5 50		lda $50,x			lda 	NSStatus,x
.85ca	c9 20		cmp #$20			cmp 	#NSBIsReference+NSTInteger 	; do we have an integer 4 byte reference.
.85cc	d0 47		bne $8615			bne		_FCError
.85ce	a9 3d		lda #$3d			lda 	#KWD_EQUAL 					; =
.85d0	20 f0 8e	jsr $8ef0			jsr 	CheckNextA
.85d3	e8		inx				inx
.85d4	20 88 9d	jsr $9d88			jsr 	EvaluateInteger 			; <from> in +1
.85d7	b1 30		lda ($30),y			lda 	(codePtr),y
.85d9	c8		iny				iny 								; consume it
.85da	48		pha				pha 								; save on stack for later
.85db	c9 b7		cmp #$b7			cmp 	#KWD_DOWNTO
.85dd	f0 04		beq $85e3			beq 	_FCNoSyntax
.85df	c9 d2		cmp #$d2			cmp 	#KWD_TO
.85e1	d0 35		bne $8618			bne 	_FCSyntaxError
.85e3					_FCNoSyntax:
.85e3	e8		inx				inx
.85e4	20 88 9d	jsr $9d88			jsr 	EvaluateInteger
.85e7	20 ef a6	jsr $a6ef			jsr 	STKSaveCodePosition 		; save loop back position
.85ea	68		pla				pla 								; restore DOWNTO or TO
.85eb	5a		phy				phy 								; save Y on the stack
.85ec	49 b7		eor #$b7			eor 	#KWD_DOWNTO 				; 0 if DOWNTO, #0 if TO
.85ee	f0 02		beq $85f2			beq 	_FCNotDownTo
.85f0	a9 02		lda #$02			lda 	#2
.85f2					_FCNotDownTo:
.85f2	3a		dec a				dec 	a 							; 255 if DOWNTO, 1 if TO
.85f3	a0 10		ldy #$10			ldy 	#16
.85f5	91 34		sta ($34),y			sta 	(basicStack),y 				; copy that out to the Basic Stack.
.85f7	a0 06		ldy #$06			ldy 	#6 							; this is the address of the loop variable.
.85f9	a5 58		lda $58				lda 	NSMantissa0
.85fb	91 34		sta ($34),y			sta 	(basicStack),y
.85fd	a5 60		lda $60				lda 	NSMantissa1
.85ff	c8		iny				iny
.8600	91 34		sta ($34),y			sta 	(basicStack),y
.8602	a0 08		ldy #$08			ldy 	#8 							; set initial index value
.8604	a2 01		ldx #$01			ldx 	#1
.8606	20 1b 86	jsr $861b			jsr 	FCIntegerToStack
.8609	a0 0c		ldy #$0c			ldy 	#12 						; set the terminal value
.860b	a2 02		ldx #$02			ldx 	#2
.860d	20 1b 86	jsr $861b			jsr 	FCIntegerToStack
.8610	20 36 86	jsr $8636			jsr 	CopyIndexToReference
.8613	7a		ply				ply 								; restore position
.8614	60		rts				rts
.8615					_FCError:
.8615	4c a3 9f	jmp $9fa3			jmp 	TypeError
.8618					_FCSyntaxError:
.8618	4c 99 9f	jmp $9f99			jmp 	SyntaxError
.861b					FCIntegerToStack:
.861b	34 50		bit $50,x			bit 	NSStatus,x 					; is the value negative
.861d	10 03		bpl $8622			bpl	 	_FCNotNegative
.861f	20 e4 9d	jsr $9de4			jsr 	NSMNegateMantissa 			; if so 2's complement the mantissa
.8622					_FCNotNegative:
.8622	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy out to the basic stack
.8624	91 34		sta ($34),y			sta 	(basicStack),y
.8626	c8		iny				iny
.8627	b5 60		lda $60,x			lda 	NSMantissa1,x
.8629	91 34		sta ($34),y			sta 	(basicStack),y
.862b	c8		iny				iny
.862c	b5 68		lda $68,x			lda 	NSMantissa2,x
.862e	91 34		sta ($34),y			sta 	(basicStack),y
.8630	c8		iny				iny
.8631	b5 70		lda $70,x			lda 	NSMantissa3,x
.8633	91 34		sta ($34),y			sta 	(basicStack),y
.8635	60		rts				rts
.8636					CopyIndexToReference:
.8636	5a		phy				phy
.8637	a0 06		ldy #$06			ldy 	#6 							; copy address-8 to write to zTemp0
.8639	38		sec				sec 								; (because we copy from offset 8)
.863a	b1 34		lda ($34),y			lda 	(basicStack),y
.863c	e9 08		sbc #$08			sbc 	#8
.863e	85 36		sta $36				sta 	zTemp0
.8640	c8		iny				iny
.8641	b1 34		lda ($34),y			lda 	(basicStack),y
.8643	e9 00		sbc #$00			sbc 	#0
.8645	85 37		sta $37				sta 	zTemp0+1
.8647	a2 04		ldx #$04			ldx 	#4 							; this is the copy counter/
.8649	a0 0b		ldy #$0b			ldy 	#8+3 		 				; the MSB of the mantissa
.864b	b1 34		lda ($34),y			lda 	(basicStack),y
.864d	0a		asl a				asl 	a 							; into carry
.864e	a0 08		ldy #$08			ldy 	#8 							; where to copy from.
.8650	90 14		bcc $8666			bcc 	_CITRNormal
.8652	38		sec				sec
.8653					_CITRNegative:
.8653	a9 00		lda #$00			lda 	#0
.8655	f1 34		sbc ($34),y			sbc 	(basicStack),y
.8657	91 36		sta ($36),y			sta 	(zTemp0),y
.8659	c8		iny				iny
.865a	ca		dex				dex
.865b	d0 f6		bne $8653			bne 	_CITRNegative
.865d	88		dey				dey 								; look at MSB of mantissa
.865e	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set the MSB as negative packed.
.8660	09 80		ora #$80			ora 	#$80
.8662	91 36		sta ($36),y			sta 	(zTemp0),y
.8664	7a		ply				ply
.8665	60		rts				rts
.8666					_CITRNormal:
.8666	b1 34		lda ($34),y			lda 	(basicStack),y 				; copy without negation.
.8668	91 36		sta ($36),y			sta 	(zTemp0),y
.866a	c8		iny				iny
.866b	ca		dex				dex
.866c	d0 f8		bne $8666			bne 	_CITRNormal
.866e	7a		ply				ply 								; and exit.
.866f	60		rts				rts
.8670					NextCommand:
.8670	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; check FOR is TOS
.8672	a2 11		ldx #$11			ldx 	#ERRID_FOR 					; this error
.8674	20 d7 a6	jsr $a6d7			jsr 	StackCheckFrame
.8677	5a		phy				phy
.8678	a0 10		ldy #$10			ldy 	#16 						; get the step count
.867a	b1 34		lda ($34),y			lda 	(basicStack),y
.867c	85 36		sta $36				sta 	zTemp0 						; this is the sign extend
.867e	30 02		bmi $8682			bmi 	_NCStepNeg
.8680	64 36		stz $36				stz 	zTemp0 						; which is 0 or 255
.8682					_NCStepNeg:
.8682	a0 08		ldy #$08			ldy 	#8 							; offset to bump
.8684	a2 04		ldx #$04			ldx 	#4 							; count to bump
.8686	18		clc				clc
.8687					_NCBump:
.8687	71 34		adc ($34),y			adc 	(basicStack),y 				; add it
.8689	91 34		sta ($34),y			sta 	(basicStack),y
.868b	a5 36		lda $36				lda 	zTemp0 						; get sign extend for next time.
.868d	c8		iny				iny 								; next byte
.868e	ca		dex				dex 								; do four times
.868f	d0 f6		bne $8687			bne 	_NCBump
.8691	20 36 86	jsr $8636			jsr		CopyIndexToReference		; copy it to the reference variable.
.8694	a0 10		ldy #$10			ldy 	#16 						; get step count again
.8696	b1 34		lda ($34),y			lda 	(basicStack),y
.8698	0a		asl a				asl 	a 							; sign bit to carry
.8699	a9 0c		lda #$0c			lda 	#12 						; offset of LHS = terminal offset
.869b	85 38		sta $38				sta 	zTemp1
.869d	90 02		bcc $86a1			bcc 	_NCCompRev 					; use if step is +ve
.869f	a9 08		lda #$08			lda 	#8 							; now the LHS = index value
.86a1					_NCCompRev:
.86a1	85 38		sta $38				sta 	zTemp1 						; so zTemp0 is the index for LHS
.86a3	49 04		eor #$04			eor 	#(8^12) 					; and zTemp0+1 is the index for RHS
.86a5	85 39		sta $39				sta 	zTemp1+1
.86a7	a2 04		ldx #$04			ldx 	#4 							; bytes to compare
.86a9	38		sec				sec
.86aa					_NCCompare:
.86aa	a4 38		ldy $38				ldy 	zTemp1 						; do compare using the two indices
.86ac	b1 34		lda ($34),y			lda 	(basicStack),y
.86ae	a4 39		ldy $39				ldy 	zTemp1+1
.86b0	f1 34		sbc ($34),y			sbc 	(basicStack),y
.86b2	e6 38		inc $38				inc 	zTemp1 						; bump the indices (inc,dex do not change C or V)
.86b4	e6 39		inc $39				inc 	zTemp1+1
.86b6	ca		dex				dex 								; do it 4 times.
.86b7	d0 f1		bne $86aa			bne 	_NCCompare
.86b9	50 02		bvc $86bd			bvc 	_NCNoOverflow 				; convert to signed comparison
.86bb	49 80		eor #$80			eor 	#$80
.86bd					_NCNoOverflow:
.86bd	7a		ply				ply 								; restore Y position
.86be	0a		asl a				asl 	a 							; is bit 7 set.
.86bf	90 04		bcc $86c5			bcc 	_NCLoopback 				; if no , >= so loop back
.86c1	20 c9 a6	jsr $a6c9			jsr 	StackClose 					; exit the loop
.86c4	60		rts				rts
.86c5					_NCLoopBack:
.86c5	20 00 a7	jsr $a700			jsr 	STKLoadCodePosition 		; loop back
.86c8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/gosub.asm

.86c9					Command_GOSUB:
.86c9	a2 00		ldx #$00			ldx 	#0
.86cb	20 9b 9d	jsr $9d9b			jsr 	Evaluate16BitInteger 		; line number in Stack.0
.86ce	a9 e3		lda #$e3			lda 	#STK_GOSUB+3
.86d0	20 aa a6	jsr $a6aa			jsr 	StackOpen 					; create frame
.86d3	20 ef a6	jsr $a6ef			jsr 	STKSaveCodePosition 		; save current position
.86d6	4c ec 86	jmp $86ec			jmp 	GotoStackX
.86d9					Command_RETURN:
.86d9	a9 e0		lda #$e0			lda 	#STK_GOSUB 					; check TOS is this
.86db	a2 0e		ldx #$0e			ldx 	#ERRID_GOSUB 				; this error
.86dd	20 d7 a6	jsr $a6d7			jsr 	StackCheckFrame
.86e0	20 00 a7	jsr $a700			jsr 	STKLoadCodePosition 		; restore code position
.86e3	20 c9 a6	jsr $a6c9			jsr 	StackClose
.86e6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/goto.asm

.86e7					GotoCommand:
.86e7	a2 00		ldx #$00			ldx 	#0 							; GOTO where
.86e9	20 9b 9d	jsr $9d9b			jsr 	Evaluate16BitInteger
.86ec					GotoStackX:
.86ec	b5 60		lda $60,x			lda  	NSMantissa1,x 				; put line # in XA. I'll keep this even though
.86ee	48		pha				pha 								; it is slightly inefficient, just in cases.
.86ef	b5 58		lda $58,x			lda 	NSMantissa0,x
.86f1	fa		plx				plx
.86f2	20 84 a5	jsr $a584			jsr 	MemorySearch 				; transfer to line number AX.
.86f5	90 05		bcc $86fc			bcc 	_GotoError 					; not found, off end.
.86f7	d0 03		bne $86fc			bne 	_GotoError 					; not found exactly
.86f9	4c 7a 8b	jmp $8b7a			jmp 	RunNewLine 					; and go straight to new line code.
.86fc					_GotoError:
.86fc	a9 0d		lda #$0d		lda	#13
.86fe	4c f9 8e	jmp $8ef9		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/if.asm

.8701					IfCommand:
.8701	a2 00		ldx #$00			ldx 	#0 							; Get the if test.
.8703	20 69 9d	jsr $9d69			jsr 	EvaluateNumber
.8706	b1 30		lda ($30),y			lda 	(codePtr),y
.8708	c9 aa		cmp #$aa			cmp 	#KWD_THEN  					; could be THEN <stuff>
.870a	d0 0a		bne $8716			bne 	_IFStructured 				; we still support it.
.870c	c8		iny				iny 								; consume THEN
.870d	20 3d 9e	jsr $9e3d			jsr 	NSMIsZero 					; is it zero
.8710	f0 01		beq $8713			beq 	_IfFail 					; if fail, go to next line
.8712	60		rts				rts 								; if THEN just continue
.8713					_IfFail:
.8713	4c 62 8b	jmp $8b62			jmp 	EOLCommand
.8716					_IfStructured:
.8716	20 3d 9e	jsr $9e3d			jsr 	NSMIsZero 					; is it zero
.8719	d0 07		bne $8722			bne 	_IfExit 					; if not, then continue normally.
.871b	a9 b8		lda #$b8			lda 	#KWD_ELSE 					; look for else/endif
.871d	a2 a7		ldx #$a7			ldx 	#KWD_ENDIF
.871f	20 3b 8e	jsr $8e3b			jsr 	ScanForward 				; and run from there
.8722					_IfExit:
.8722	60		rts				rts
.8723					ElseCode:
.8723	a9 a7		lda #$a7			lda 	#KWD_ENDIF 					; else is only run after the if clause succeeds
.8725	aa		tax				tax 								; so just go to the structure exit
.8726	20 3b 8e	jsr $8e3b			jsr 	ScanForward
.8729	60		rts				rts
.872a					EndIf:
.872a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/inputprint.asm

.872b					Command_Input:
.872b	a9 ff		lda #$ff			lda 	#$FF 						; set input flag
.872d	8d 28 04	sta $0428			sta 	IsInputFlag
.8730	80 03		bra $8735			bra 	Command_IP_Main
.8732					Command_Print:
.8732	9c 28 04	stz $0428			stz 	IsInputFlag 				; clear input flag
.8735					Command_IP_Main:
.8735	18		clc				clc 								; carry being clear means last print wasn't comma/semicolon
.8736					_CPLoop:
.8736	08		php				php 								; save last action flag
.8737	b1 30		lda ($30),y			lda 	(codePtr),y
.8739	c9 80		cmp #$80			cmp  	#KWC_EOL 					; end of line or colon, exit now.
.873b	f0 54		beq $8791			beq 	_CPExit
.873d	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.873f	f0 50		beq $8791			beq 	_CPExit
.8741	68		pla				pla 								; throw last action flag
.8742	b1 30		lda ($30),y			lda 	(codePtr),y
.8744	c8		iny				iny
.8745	c9 3b		cmp #$3b			cmp 	#KWD_SEMICOLON				; is it a semicolon
.8747	f0 45		beq $878e			beq 	_CPContinueWithSameLine
.8749	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; comma
.874b	f0 3c		beq $8789			beq 	_CPTab
.874d	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; apostrophe (new line)
.874f	f0 34		beq $8785			beq 	_CPNewLine
.8751	88		dey				dey 								; undo the get.
.8752	20 fb 93	jsr $93fb			jsr 	EvaluateExpressionAt0 		; evaluate expression at 0.
.8755	b5 50		lda $50,x			lda 	NSStatus,x 					; read the status
.8757	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.8759	f0 0d		beq $8768			beq 	_CPIsValue 					; no, display it.
.875b	ad 28 04	lda $0428			lda 	IsInputFlag 				; if print, dereference and print.
.875e	f0 05		beq $8765			beq 	_CPIsPrint 					; otherwise display.
.8760	20 9a 87	jsr $879a			jsr 	CIInputValue 				; input a value to the reference
.8763	80 20		bra $8785			bra 	_CPNewLine
.8765					_CPIsPrint:
.8765	20 c0 96	jsr $96c0			jsr 	Dereference 				; dereference if required.
.8768					_CPIsValue:
.8768	b5 50		lda $50,x			lda 	NSStatus,x 					; is it a number
.876a	29 10		and #$10			and 	#NSBIsString
.876c	f0 09		beq $8777			beq 	_CPNumber
.876e	a6 60		ldx $60				ldx 	NSMantissa1 				; string, print the text.
.8770	a5 58		lda $58				lda 	NSMantissa0
.8772	20 fd 87	jsr $87fd			jsr 	CPPrintStringXA
.8775	80 be		bra $8735			bra 	Command_IP_Main 			; loop round clearing carry so NL if end
.8777					_CPNumber:
.8777	a9 05		lda #$05			lda 	#5 							; maximum decimals
.8779	20 50 9c	jsr $9c50			jsr 	ConvertNumberToString 		; convert to string (in unary str$() function)
.877c	a2 06		ldx #$06			ldx 	#DecimalBuffer >> 8
.877e	a9 49		lda #$49			lda 	#DecimalBuffer & $FF
.8780	20 fd 87	jsr $87fd			jsr 	CPPrintStringXA 			; print it.
.8783	80 b0		bra $8735			bra 	Command_IP_Main				; loop round clearing carry so NL if end
.8785					_CPNewLine:
.8785	a9 0d		lda #$0d			lda 	#13
.8787	80 02		bra $878b			bra 	_CPPrintChar
.8789					_CPTab:
.8789	a9 09		lda #$09			lda 	#9 							; print TAB
.878b					_CPPrintChar:
.878b	20 10 88	jsr $8810			jsr 	CPPrintVector
.878e					_CPContinueWithSameLine:
.878e	38		sec				sec 								; loop round with carry set, which
.878f	80 a5		bra $8736			bra 	_CPLoop 					; will inhibit final CR
.8791					_CPExit:
.8791	28		plp				plp 								; get last action flag
.8792	b0 05		bcs $8799			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.8794	a9 0d		lda #$0d			lda 	#13 						; print new line
.8796	20 10 88	jsr $8810			jsr 	CPPrintVector
.8799					_CPExit2:
.8799	60		rts				rts
.879a					CIInputValue:
.879a	a2 00		ldx #$00			ldx 	#0 							; input a line.
.879c					_CIInputLine:
.879c	20 13 88	jsr $8813			jsr 	CPInputVector 				; get key
.879f	c9 0d		cmp #$0d			cmp 	#13 						; 13 = End
.87a1	f0 1f		beq $87c2			beq 	_CIHaveValue
.87a3	c9 08		cmp #$08			cmp 	#8 							; 8 = BS
.87a5	f0 11		beq $87b8			beq 	_CIBackspace
.87a7	c9 20		cmp #$20			cmp 	#32 						; ignore other control characters
.87a9	90 f1		bcc $879c			bcc 	_CIInputLine
.87ab	e0 50		cpx #$50			cpx 	#80 						; max length
.87ad	b0 ed		bcs $879c			bcs 	_CIInputLine
.87af	9d 2a 05	sta $052a,x			sta 	lineBuffer,x
.87b2	e8		inx				inx
.87b3	20 10 88	jsr $8810			jsr 	CPPrintVector 				; echo it.
.87b6	80 e4		bra $879c			bra 	_CIInputLine
.87b8					_CIBackSpace:
.87b8	e0 00		cpx #$00			cpx 	#0 							; nothing to delete
.87ba	f0 e0		beq $879c			beq 	_CIInputLine
.87bc	20 10 88	jsr $8810			jsr 	CPPrintVector 				; echo it.
.87bf	ca		dex				dex
.87c0	80 da		bra $879c			bra 	_CIInputLine
.87c2					_CIHaveValue:
.87c2	9e 2a 05	stz $052a,x			stz 	LineBuffer,x 				; ASCIIZ string now in line buffer.
.87c5	a5 50		lda $50				lda 	NSStatus 					; was it a string assignment
.87c7	29 10		and #$10			and 	#NSBIsString
.87c9	f0 17		beq $87e2			beq 	_CIAssignNumber 			; assign a number
.87cb	a2 01		ldx #$01			ldx 	#1
.87cd	a9 2a		lda #$2a			lda 	#lineBuffer & $FF 			; set up to point to new string
.87cf	95 58		sta $58,x			sta 	NSMantissa0,x
.87d1	a9 05		lda #$05			lda 	#lineBuffer >> 8
.87d3	95 60		sta $60,x			sta 	NSMantissa1,x
.87d5	74 68		stz $68,x			stz 	NSMantissa2,x
.87d7	74 70		stz $70,x			stz 	NSMantissa3,x
.87d9	a9 10		lda #$10			lda 	#NSBIsString 				; so it becomes a string value
.87db	95 50		sta $50,x			sta  	NSStatus,x
.87dd	ca		dex				dex 								; X = 0
.87de	20 4f 88	jsr $884f			jsr 	AssignVariable
.87e1	60		rts				rts
.87e2					_CIAssignNumber:
.87e2	a9 2a		lda #$2a			lda 	#lineBuffer & $FF 			; set up to point to new string
.87e4	85 36		sta $36				sta 	zTemp0
.87e6	a9 05		lda #$05			lda 	#lineBuffer >> 8
.87e8	85 37		sta $37				sta 	zTemp0+1
.87ea	a2 01		ldx #$01			ldx 	#1 							; put in slot 1
.87ec	20 d2 9b	jsr $9bd2			jsr 	ValEvaluateZTemp0 			; use the VAL() code
.87ef	90 07		bcc $87f8			bcc 	_CIIsOkay
.87f1	a9 3f		lda #$3f			lda 	#"?" 						; error ?
.87f3	20 10 88	jsr $8810			jsr 	CPPrintVector
.87f6	80 a2		bra $879a			bra 	CIInputValue
.87f8					_CIIsOkay:
.87f8	ca		dex				dex 								; X = 0
.87f9	20 4f 88	jsr $884f			jsr 	AssignVariable
.87fc	60		rts				rts
.87fd					CPPrintStringXA:
.87fd	5a		phy				phy
.87fe	86 37		stx $37				stx 	zTemp0+1
.8800	85 36		sta $36				sta 	zTemp0
.8802	a0 00		ldy #$00			ldy 	#0
.8804					_PSXALoop:
.8804	b1 36		lda ($36),y			lda 	(zTemp0),y
.8806	f0 06		beq $880e			beq 	_PSXAExit
.8808	20 10 88	jsr $8810			jsr 	CPPrintVector
.880b	c8		iny				iny
.880c	80 f6		bra $8804			bra 	_PSXALoop
.880e					_PSXAExit:
.880e	7a		ply				ply
.880f	60		rts				rts
.8810					CPPrintVector:
.8810	4c 03 80	jmp $8003			jmp 	EXTPrintCharacter
.8813					CPInputVector:
.8813	4c 09 80	jmp $8009			jmp 	EXTInputSingleCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/let.asm

.8816					LetCommand:
.8816	a2 00		ldx #$00			ldx 	#0
.8818	b1 30		lda ($30),y			lda 	(codePtr),y
.881a	c9 10		cmp #$10			cmp 	#KWD_AT
.881c	d0 14		bne $8832			bne 	_LCStandard
.881e	c8		iny				iny 								; skip equal
.881f	20 47 98	jsr $9847			jsr 	EvaluateTerm 				; get a number (the address of the reference)
.8822	20 c0 96	jsr $96c0			jsr 	Dereference 				; dereference it to a value
.8825	b5 50		lda $50,x			lda 	NSStatus,x 					; check integer
.8827	49 20		eor #$20			eor 	#NSBIsReference	 			; toggle reference
.8829	95 50		sta $50,x			sta 	NSStatus,x
.882b	29 20		and #$20			and 	#NSBIsReference 			; if it is now a reference, continue
.882d	d0 0f		bne $883e			bne 	_LCMain
.882f	4c a3 9f	jmp $9fa3			jmp 	TypeError 					; was a reference before.
.8832					_LCStandard:
.8832	ad e5 93	lda $93e5			lda 	PrecedenceLevel+"*"			; precedence > this
.8835	20 ff 93	jsr $93ff			jsr 	EvaluateExpressionAtPrecedence
.8838	b5 50		lda $50,x			lda 	NSStatus,x 					; is it a reference to an array marked as procedure ?
.883a	c9 38		cmp #$38			cmp		#NSTProcedure+NSBIsReference
.883c	f0 0e		beq $884c			beq 	_LetGoProc 					; it's a procedure call.
.883e					_LCMain:
.883e	a9 3d		lda #$3d			lda 	#"=" 						; check =
.8840	20 f0 8e	jsr $8ef0			jsr 	CheckNextA
.8843	e8		inx				inx 								; RHS
.8844	20 60 9d	jsr $9d60			jsr 	EvaluateValue
.8847	ca		dex				dex
.8848	20 4f 88	jsr $884f			jsr 	AssignVariable
.884b	60		rts				rts
.884c					_LetGoProc:
.884c	4c 38 8a	jmp $8a38			jmp 	CallProcedure
.884f					AssignVariable:
.884f	b5 50		lda $50,x			lda 	NSStatus,x 					; check the string/number type bits match
.8851	48		pha				pha 								; save a copy
.8852	55 51		eor $51,x			eor 	NSStatus+1,x
.8854	29 10		and #$10			and 	#NSBIsString
.8856	d0 0b		bne $8863			bne 	_ASError
.8858	68		pla				pla 								; get back
.8859	29 10		and #$10			and 	#NSBIsString 				; check type
.885b	d0 03		bne $8860			bne 	_ASString
.885d	4c fe 95	jmp $95fe			jmp 	AssignNumber
.8860					_ASString:
.8860	4c 5c 96	jmp $965c			jmp 	AssignString
.8863					_ASError:
.8863	4c a3 9f	jmp $9fa3			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/list.asm

.8866					Command_List:
.8866	9c 26 04	stz $0426			stz 	listIndent 					; reset indent.
.8869	b1 30		lda ($30),y			lda 	(codePtr),y
.886b	29 c0		and #$c0			and 	#$C0 				 		; if so, we are list procedure() which is a seperate block
.886d	c9 40		cmp #$40			cmp 	#$40  						; of code.
.886f	f0 6e		beq $88df			beq 	_CLListProcedure
.8871	64 5c		stz $5c				stz		NSMantissa0+4				; set the lower (slot 4) to 0 and upper (slot 7) to $FFFF
.8873	64 64		stz $64				stz 	NSMantissa1+4 				; these are the default top and bottom.
.8875	a9 ff		lda #$ff			lda 	#$FF
.8877	85 5f		sta $5f				sta 	NSMantissa0+7
.8879	85 67		sta $67				sta 	NSMantissa1+7
.887b	b1 30		lda ($30),y			lda 	(codePtr),y
.887d	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.887f	f0 1a		beq $889b			beq 	_CLSecond
.8881	20 5c 89	jsr $895c			jsr 	CLIsDigit 					; if not digit, list all
.8884	b0 20		bcs $88a6			bcs 	_CLStart
.8886	a2 04		ldx #$04			ldx 	#4 							; get 1st range into slot 4
.8888	20 9b 9d	jsr $9d9b			jsr 	Evaluate16BitInteger
.888b	b1 30		lda ($30),y			lda 	(codePtr),y
.888d	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.888f	f0 0a		beq $889b			beq 	_CLSecond 					; if so go get it
.8891	a5 5c		lda $5c				lda 	NSMantissa0+4 				; copy 4->7
.8893	85 5f		sta $5f				sta 	NSMantissa0+7
.8895	a5 64		lda $64				lda 	NSMantissa1+4
.8897	85 67		sta $67				sta 	NSMantissa1+7
.8899	80 0b		bra $88a6			bra 	_CLStart
.889b					_CLSecond:
.889b	c8		iny				iny 								; consume comma
.889c	20 5c 89	jsr $895c			jsr 	CLIsDigit 					; digit found
.889f	b0 05		bcs $88a6			bcs 	_CLStart 					; if not, continue listing
.88a1	a2 07		ldx #$07			ldx 	#7 							; load 2nd range into slot 7
.88a3	20 9b 9d	jsr $9d9b			jsr 	Evaluate16BitInteger
.88a6					_CLStart
.88a6	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.88a8	85 30		sta $30				sta 	codePtr
.88aa	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.88ac	85 31		sta $31				sta 	codePtr+1
.88ae					_CLLoop:
.88ae	20 0c 80	jsr $800c			jsr 	EXTBreakCheck 				; break check here, as we want the option of breaking out of long lists.
.88b1	f0 27		beq $88da			beq 	_CLBreak
.88b3	b2 30		lda ($30)			lda 	(codePtr)
.88b5	f0 20		beq $88d7			beq 	_CLExit
.88b7	a2 04		ldx #$04			ldx 	#4 							; check range every time, line numbers aren't in order.
.88b9	20 4b 89	jsr $894b			jsr 	CLCompareLineNo
.88bc	90 0c		bcc $88ca			bcc 	_CLNext
.88be	a2 07		ldx #$07			ldx 	#7
.88c0	20 4b 89	jsr $894b			jsr 	CLCompareLineNo
.88c3	f0 02		beq $88c7			beq 	_CLDoThisOne
.88c5	b0 03		bcs $88ca			bcs 	_CLNext
.88c7					_CLDoThisOne:
.88c7	20 38 89	jsr $8938			jsr 	CLListOneLine 				; routine to list the current line.
.88ca					_CLNext:
.88ca	18		clc				clc
.88cb	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.88cd	65 30		adc $30				adc 	codePtr
.88cf	85 30		sta $30				sta 	codePtr
.88d1	90 02		bcc $88d5			bcc 	_CREExit
.88d3	e6 31		inc $31				inc 	codePtr+1 					; carry
.88d5					_CREExit:
.88d5	80 d7		bra $88ae			bra 	_CLLoop
.88d7					_CLExit:
.88d7	4c d7 83	jmp $83d7			jmp 	WarmStart
.88da					_CLBreak:
.88da	a9 01		lda #$01		lda	#1
.88dc	4c f9 8e	jmp $8ef9		jmp	ErrorHandler
.88df					_CLListProcedure:
.88df	b1 30		lda ($30),y			lda 	(codePtr),y
.88e1	85 38		sta $38				sta 	zTemp1
.88e3	c8		iny				iny
.88e4	b1 30		lda ($30),y			lda 	(codePtr),y
.88e6	85 39		sta $39				sta 	zTemp1+1
.88e8	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.88ea	85 30		sta $30				sta 	codePtr
.88ec	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.88ee	85 31		sta $31				sta 	codePtr+1
.88f0					_CLLPSearch:
.88f0	b2 30		lda ($30)			lda 	(codePtr)
.88f2	c9 00		cmp #$00			cmp 	#0 							; if zero, end
.88f4	f0 e1		beq $88d7			beq 	_CLExit
.88f6	a0 03		ldy #$03			ldy 	#3 							; check if PROC something
.88f8	b1 30		lda ($30),y			lda 	(codePtr),y
.88fa	c9 a4		cmp #$a4			cmp 	#KWD_PROC
.88fc	d0 0e		bne $890c			bne 	_CLLPNext
.88fe	c8		iny				iny 								; check if PROC this.
.88ff	b1 30		lda ($30),y			lda 	(codePtr),y
.8901	c5 38		cmp $38				cmp 	zTemp1 						; does it match ?
.8903	d0 07		bne $890c			bne 	_CLLPNext
.8905	c8		iny				iny
.8906	b1 30		lda ($30),y			lda 	(codePtr),y
.8908	c5 39		cmp $39				cmp 	zTemp1+1
.890a	f0 0d		beq $8919			beq 	_CLLPFound
.890c					_CLLPNext:
.890c	18		clc				clc
.890d	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.890f	65 30		adc $30				adc 	codePtr
.8911	85 30		sta $30				sta 	codePtr
.8913	90 02		bcc $8917			bcc 	_CREExit
.8915	e6 31		inc $31				inc 	codePtr+1 					; carry
.8917					_CREExit:
.8917	80 d7		bra $88f0			bra 	_CLLPSearch
.8919					_CLLPFound:
.8919	b2 30		lda ($30)			lda 	(codePtr)
.891b	f0 ba		beq $88d7			beq 	_CLExit
.891d	a0 03		ldy #$03			ldy 	#3 							; get first keyword
.891f	b1 30		lda ($30),y			lda 	(codePtr),y
.8921	48		pha				pha
.8922	20 38 89	jsr $8938			jsr 	CLListOneLine 				; list line and go forward
.8925	18		clc				clc
.8926	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8928	65 30		adc $30				adc 	codePtr
.892a	85 30		sta $30				sta 	codePtr
.892c	90 02		bcc $8930			bcc 	_CREExit
.892e	e6 31		inc $31				inc 	codePtr+1 					; carry
.8930					_CREExit:
.8930	68		pla				pla 								; reached ENDPROC ?
.8931	c9 a8		cmp #$a8			cmp 	#KWD_ENDPROC
.8933	d0 e4		bne $8919			bne 	_CLLPFound
.8935	4c d7 83	jmp $83d7			jmp 	WarmStart
.8938					CLListOneLine:
.8938	20 9e 8e	jsr $8e9e			jsr 	ScanGetCurrentLineStep 		; get indent adjust.
.893b	20 1e 80	jsr $801e			jsr 	TKListConvertLine 			; convert line into token Buffer
.893e	a2 04		ldx #$04			ldx 	#(tokenBuffer >> 8) 		; print that line
.8940	a9 2d		lda #$2d			lda 	#(tokenBuffer & $FF)
.8942	20 52 8f	jsr $8f52			jsr 	PrintStringXA
.8945	a9 0d		lda #$0d			lda 	#13 						; new line
.8947	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.894a	60		rts				rts
.894b					CLCompareLineNo:
.894b	38		sec				sec
.894c	a0 01		ldy #$01			ldy 	#1
.894e	b1 30		lda ($30),y			lda 	(codePtr),y
.8950	f5 58		sbc $58,x			sbc 	NSMantissa0,x
.8952	85 36		sta $36				sta 	zTemp0
.8954	c8		iny				iny
.8955	b1 30		lda ($30),y			lda 	(codePtr),y
.8957	f5 60		sbc $60,x			sbc 	NSMantissa1,x
.8959	05 36		ora $36				ora 	zTemp0
.895b	60		rts				rts
.895c					CLIsDigit:
.895c	b1 30		lda ($30),y			lda 	(codePtr),y
.895e	c9 30		cmp #$30			cmp 	#"0"
.8960	90 03		bcc $8965			bcc	 	_CLIDExitFalse
.8962	c9 3a		cmp #$3a			cmp 	#"9"+1
.8964	60		rts				rts
.8965					_CLIDExitFalse:
.8965	38		sec				sec
.8966	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/local.asm

.8967					Command_LOCAL:
.8967	a2 00		ldx #$00			ldx 	#0 							; at level 0
.8969	20 75 89	jsr $8975			jsr 	LocaliseNextTerm 			; convert term to a local.
.896c	b1 30		lda ($30),y			lda 	(codePtr),y
.896e	c8		iny				iny
.896f	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8971	f0 f4		beq $8967			beq 	Command_LOCAL 				; if so, localise another variable.
.8973	88		dey				dey 								; unpick pre-get
.8974	60		rts				rts
.8975					LocaliseNextTerm:
.8975	20 47 98	jsr $9847			jsr 	EvaluateTerm 				; evaluate the term
.8978	b5 50		lda $50,x			lda 	NSStatus,x
.897a	29 20		and #$20			and 	#NSBIsReference 			; check it is a reference, must be a variable.
.897c	f0 5c		beq $89da			beq		_LNTError
.897e	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address of variable to zTemp0
.8980	85 36		sta $36				sta 	zTemp0
.8982	b5 60		lda $60,x			lda 	NSMantissa1,x
.8984	85 37		sta $37				sta  	zTemp0+1
.8986	b5 50		lda $50,x			lda 	NSStatus,x 					; figure out what it is.
.8988	29 10		and #$10			and 	#NSBIsString
.898a	d0 1e		bne $89aa			bne 	_LNTPushString
.898c	5a		phy				phy
.898d	a0 00		ldy #$00			ldy 	#0 							; push 0 to 4 inclusive, the number values, on the stack, and zero them as you go.
.898f					_LNTPushNumLoop:
.898f	b1 36		lda ($36),y			lda		(zTemp0),y
.8991	20 89 a6	jsr $a689			jsr 	StackPushByte
.8994	c8		iny				iny
.8995	c0 05		cpy #$05			cpy 	#5
.8997	d0 f6		bne $898f			bne 	_LNTPushNumLoop
.8999	a5 36		lda $36				lda 	zTemp0 						; push the actual target address to write on the stack
.899b	20 89 a6	jsr $a689			jsr 	StackPushByte
.899e	a5 37		lda $37				lda 	zTemp0+1
.89a0	20 89 a6	jsr $a689			jsr 	StackPushByte
.89a3	a9 01		lda #$01			lda 	#STK_LOCALN 				; push local-number marker.
.89a5	20 89 a6	jsr $a689			jsr 	StackPushByte
.89a8	7a		ply				ply
.89a9	60		rts				rts
.89aa					_LNTPushString:
.89aa	5a		phy				phy
.89ab	b2 36		lda ($36)			lda 	(zTemp0) 					; put address of string in zTemp1
.89ad	85 38		sta $38				sta 	zTemp1
.89af	a0 01		ldy #$01			ldy 	#1
.89b1	b1 36		lda ($36),y			lda 	(zTemp0),y
.89b3	85 39		sta $39				sta 	zTemp1+1
.89b5	a0 00		ldy #$00			ldy 	#0 							; output string
.89b7	c9 00		cmp #$00			cmp 	#0 							; if not assigned string
.89b9	f0 0a		beq $89c5			beq 	_LNTStringOut
.89bb					_LNTPushStrLoop:
.89bb	b1 38		lda ($38),y			lda 	(zTemp1),y
.89bd	f0 06		beq $89c5			beq 	_LNTStringOut
.89bf	20 89 a6	jsr $a689			jsr 	StackPushByte
.89c2	c8		iny				iny
.89c3	80 f6		bra $89bb			bra 	_LNTPushStrLoop
.89c5					_LNTStringOut:
.89c5	98		tya				tya									; output length (chars written).
.89c6	20 89 a6	jsr $a689			jsr 	StackPushByte
.89c9	b5 58		lda $58,x			lda 	NSMantissa0,x 				; output address of the string record *not* the string itself
.89cb	20 89 a6	jsr $a689			jsr 	StackPushByte
.89ce	b5 60		lda $60,x			lda 	NSMantissa1,x
.89d0	20 89 a6	jsr $a689			jsr 	StackPushByte
.89d3	a9 02		lda #$02			lda 	#STK_LOCALS 				; push local-string marker.
.89d5	20 89 a6	jsr $a689			jsr 	StackPushByte
.89d8	7a		ply				ply
.89d9	60		rts				rts
.89da					_LNTError:
.89da	4c 99 9f	jmp $9f99			jmp 	SyntaxError
.89dd					LocalPopValue:
.89dd	20 a1 a6	jsr $a6a1			jsr 	StackPopByte
.89e0	c9 01		cmp #$01			cmp 	#STK_LOCALN 				; if not local-N
.89e2	d0 17		bne $89fb			bne 	_LPVString
.89e4	20 a1 a6	jsr $a6a1			jsr 	StackPopByte 				; address
.89e7	85 37		sta $37				sta 	zTemp0+1
.89e9	20 a1 a6	jsr $a6a1			jsr 	StackPopByte
.89ec	85 36		sta $36				sta 	zTemp0
.89ee	5a		phy				phy
.89ef	a0 04		ldy #$04			ldy 	#4 							; copy back
.89f1					_LPVNumberCopy:
.89f1	20 a1 a6	jsr $a6a1			jsr 	StackPopByte
.89f4	91 36		sta ($36),y			sta 	(zTemp0),y
.89f6	88		dey				dey
.89f7	10 f8		bpl $89f1			bpl 	_LPVNumberCopy
.89f9	7a		ply				ply 								; and complete
.89fa	60		rts				rts
.89fb					_LPVString:
.89fb	20 a1 a6	jsr $a6a1			jsr 	StackPopByte 				; address of record copied to zTemp0
.89fe	85 37		sta $37				sta 	zTemp0+1
.8a00	20 a1 a6	jsr $a6a1			jsr 	StackPopByte
.8a03	85 36		sta $36				sta 	zTemp0
.8a05	5a		phy				phy
.8a06	b2 36		lda ($36)			lda 	(zTemp0) 					; address to write string to copied to zTemp1
.8a08	85 38		sta $38				sta 	zTemp1
.8a0a	a0 01		ldy #$01			ldy 	#1
.8a0c	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a0e	85 39		sta $39				sta 	zTemp1+1
.8a10	20 a1 a6	jsr $a6a1			jsr 	StackPopByte 				; # chars to get => y
.8a13	a8		tay				tay
.8a14	a5 39		lda $39				lda 	zTemp1+1 					; if no target (e.g. was "" originally) exit
.8a16	f0 0e		beq $8a26			beq 	_LPVStringCopied
.8a18	a9 00		lda #$00			lda 	#0 							; NULL on end
.8a1a	91 38		sta ($38),y			sta 	(zTemp1),y
.8a1c					_LPVStringCopy:
.8a1c	88		dey				dey
.8a1d	30 07		bmi $8a26			bmi 	_LPVStringCopied
.8a1f	20 a1 a6	jsr $a6a1			jsr 	StackPopByte
.8a22	91 38		sta ($38),y			sta 	(zTemp1),y
.8a24	80 f6		bra $8a1c			bra 	_LPVStringCopy
.8a26					_LPVStringCopied:
.8a26	fa		plx				plx
.8a27	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/new.asm

.8a28					NewCommand:
.8a28	20 2e 8a	jsr $8a2e			jsr 	NewProgram 					; does the actual NEW.
.8a2b	4c d7 83	jmp $83d7			jmp 	WarmStart 					; and warm starts straight away.
.8a2e					NewProgram:
.8a2e	20 66 a5	jsr $a566			jsr 	MemoryNew
.8a31	9c 00 10	stz $1000			stz 	VariableSpace 				; erase all variables.
.8a34	20 6d 84	jsr $846d			jsr 	ClearCommand 				; clear everything.
.8a37	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/procedure.asm

=2					ParameterStackPos = 2
.8a38					CallProcedure:
.8a38	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start storing parameters at 2.
.8a3a	b1 30		lda ($30),y			lda 	(codePtr),y
.8a3c	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.8a3e	f0 0c		beq $8a4c			beq 	_CPEndParam
.8a40					_CPParamLoop:
.8a40	20 60 9d	jsr $9d60			jsr 	EvaluateValue 				; get parameter onto stack
.8a43	e8		inx				inx 								; bump next stack
.8a44	b1 30		lda ($30),y			lda 	(codePtr),y
.8a46	c8		iny				iny
.8a47	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if comma, go back and try again.
.8a49	f0 f5		beq $8a40			beq 	_CPParamLoop
.8a4b	88		dey				dey 								; unpick.
.8a4c					_CPEndParam:
.8a4c	8e 16 04	stx $0416			stx 	LastParameter 				; save the last parameters index.
.8a4f	c8		iny				iny									; skip right bracket
.8a50	a9 b3		lda #$b3			lda 	#STK_PROC+3 				; allocate 6 bytes on the return stack.
.8a52	20 aa a6	jsr $a6aa			jsr 	StackOpen
.8a55	20 ef a6	jsr $a6ef			jsr 	STKSaveCodePosition 		; save loop position
.8a58	a5 58		lda $58				lda 	NSMantissa0 				; copy variable (e.g. procedure) address to zTemp0
.8a5a	85 36		sta $36				sta 	zTemp0 						; this is the DATA not the RECORD
.8a5c	a5 60		lda $60				lda 	NSMantissa1
.8a5e	85 37		sta $37				sta 	zTemp0+1
.8a60	a0 01		ldy #$01			ldy 	#1 							; copy code address back.
.8a62	b2 36		lda ($36)			lda 	(zTemp0)
.8a64	85 30		sta $30				sta 	safePtr
.8a66	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a68	85 31		sta $31				sta 	safePtr+1
.8a6a	c8		iny				iny
.8a6b	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a6d	85 32		sta $32				sta 	safePtr+2
.8a6f	c8		iny				iny
.8a70	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a72	85 33		sta $33				sta 	safePtr+3
.8a74	c8		iny				iny 								; get Y offset -> Y
.8a75	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a77	a8		tay				tay
.8a78	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start position of parameters
.8a7a	ec 16 04	cpx $0416			cpx	 	LastParameter 				; check zero parameters at the start
.8a7d	f0 13		beq $8a92			beq 	_ParamExit 					; if so, exit.
.8a7f					_ParamExtract:
.8a7f	ca		dex				dex 								; put a local term on the level before
.8a80	20 75 89	jsr $8975			jsr 	LocaliseNextTerm			; also pushes original param value to basic stack
.8a83	20 4f 88	jsr $884f			jsr 	AssignVariable 				; assign stacked value to the variable.
.8a86	e8		inx				inx 								; advance to next parameter to do.
.8a87	e8		inx				inx
.8a88	ec 16 04	cpx $0416			cpx 	LastParameter 				; are we done ?
.8a8b	f0 05		beq $8a92			beq 	_ParamExit
.8a8d	20 e8 8e	jsr $8ee8			jsr 	CheckComma 					; comma seperating parameters
.8a90	80 ed		bra $8a7f			bra 	_ParamExtract
.8a92					_ParamExit:
.8a92	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket 			; check )
.8a95	60		rts				rts 								; and continue from here
.8a96					Command_ENDPROC:
.8a96	a9 b0		lda #$b0			lda 	#STK_PROC 					; check TOS is this
.8a98	a2 14		ldx #$14			ldx 	#ERRID_PROC
.8a9a	20 d7 a6	jsr $a6d7			jsr 	StackCheckFrame
.8a9d	20 00 a7	jsr $a700			jsr 	STKLoadCodePosition 		; restore code position
.8aa0	20 c9 a6	jsr $a6c9			jsr 	StackClose
.8aa3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/read.asm

.8aa4					Command_Read:
.8aa4	a2 00		ldx #$00			ldx 	#0 							; evaluate the term which is the var/array element to assign
.8aa6	20 47 98	jsr $9847			jsr 	EvaluateTerm
.8aa9	b5 50		lda $50,x			lda 	NSStatus,x
.8aab	29 20		and #$20			and 	#NSBIsReference				; get status byte on stack, identifies int, float, string.
.8aad	f0 4f		beq $8afe			beq 	_CRSyntax 					; check reference (bit 0) fail if not a reference.
.8aaf	20 47 8b	jsr $8b47			jsr 	SwapDataCodePtrs 			; swap code and data
.8ab2	ad 1c 04	lda $041c			lda 	inDataStatement 			; if in a data statement, we don't need to search
.8ab5	d0 25		bne $8adc			bne 	_CRContinueData  			; forward for the next one.
.8ab7	b2 30		lda ($30)			lda 	(codePtr)
.8ab9	f0 1c		beq $8ad7			beq 	_CRNoData
.8abb					_CRKeepSearching:
.8abb	a9 b4		lda #$b4			lda 	#KWD_DATA 					; scan for instruction
.8abd	a2 80		ldx #$80			ldx 	#KWC_EOL
.8abf	20 3b 8e	jsr $8e3b			jsr 	ScanForward
.8ac2	c9 b4		cmp #$b4			cmp 	#KWD_DATA 					; found data ?
.8ac4	f0 16		beq $8adc			beq 	_CRHaveData 				; found it
.8ac6	18		clc				clc
.8ac7	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8ac9	65 30		adc $30				adc 	codePtr
.8acb	85 30		sta $30				sta 	codePtr
.8acd	90 02		bcc $8ad1			bcc 	_CREExit
.8acf	e6 31		inc $31				inc 	codePtr+1 					; carry
.8ad1					_CREExit:
.8ad1	a0 03		ldy #$03			ldy 	#3 							; start of line.
.8ad3	b2 30		lda ($30)			lda 	(codePtr)
.8ad5	d0 e4		bne $8abb			bne 	_CRKeepSearching
.8ad7					_CRNoData:
.8ad7	a9 0b		lda #$0b		lda	#11
.8ad9	4c f9 8e	jmp $8ef9		jmp	ErrorHandler
.8adc					_CRHaveData:
.8adc					_CRContinueData:
.8adc	a2 01		ldx #$01			ldx 	#1
.8ade	20 60 9d	jsr $9d60			jsr 	EvaluateValue 				; evaluate value into slot # 1
.8ae1	ca		dex				dex
.8ae2	20 4f 88	jsr $884f			jsr		AssignVariable 				; do the assignment
.8ae5	9c 1c 04	stz $041c			stz 	inDataStatement 			; clear in data flag
.8ae8	b1 30		lda ($30),y			lda 	(codePtr),y
.8aea	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not, end of data statement and exit
.8aec	d0 04		bne $8af2			bne 	_CRSwapBack
.8aee	c8		iny				iny 								; consume comma
.8aef	ee 1c 04	inc $041c			inc 	inDataStatement 			; set in data statement currently.
.8af2					_CRSwapBack:
.8af2	20 47 8b	jsr $8b47			jsr 	SwapDataCodePtrs			; swap them back.
.8af5	b1 30		lda ($30),y			lda 	(codePtr),y
.8af7	c8		iny				iny
.8af8	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8afa	f0 a8		beq $8aa4			beq 	Command_Read 				; if so go round again.
.8afc	88		dey				dey 								; unpick get.
.8afd	60		rts				rts
.8afe					_CRSyntax:
.8afe	4c 99 9f	jmp $9f99			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/rem.asm

.8b01					RemCommand:
.8b01	b1 30		lda ($30),y			lda 	(codePtr),y
.8b03	c9 ff		cmp #$ff			cmp 	#KWC_STRING
.8b05	d0 06		bne $8b0d			bne 	_RMExit
.8b07	c8		iny				iny 								; point to offset
.8b08	98		tya				tya 								; A = offset position
.8b09	38		sec				sec 								; add size +1 hence SEC
.8b0a	71 30		adc ($30),y			adc 	(codePtr),y
.8b0c	a8		tay				tay 								; make current position.
.8b0d					_RMExit:
.8b0d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/repeat.asm

.8b0e					Command_REPEAT:
.8b0e	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; allocate 6 bytes on the return stack.
.8b10	20 aa a6	jsr $a6aa			jsr 	StackOpen
.8b13	20 ef a6	jsr $a6ef			jsr 	STKSaveCodePosition 		; save loop position
.8b16	60		rts				rts
.8b17					Command_UNTIL:
.8b17	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; check REPEAT is TOS
.8b19	a2 0f		ldx #$0f			ldx 	#ERRID_REPEAT 				; this error
.8b1b	20 d7 a6	jsr $a6d7			jsr 	StackCheckFrame
.8b1e	a2 00		ldx #$00			ldx 	#0
.8b20	20 69 9d	jsr $9d69			jsr 	EvaluateNumber 				; work out the number
.8b23	20 3d 9e	jsr $9e3d			jsr 	NSMIsZero 					; check if zero
.8b26	f0 04		beq $8b2c			beq 	_CULoopBack 				; if so keep looping
.8b28	20 c9 a6	jsr $a6c9			jsr 	StackClose		 			; return
.8b2b	60		rts				rts
.8b2c					_CULoopBack:
.8b2c	20 00 a7	jsr $a700			jsr 	STKLoadCodePosition 		; loop back
.8b2f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/restore.asm

.8b30					Command_Restore:
.8b30	20 47 8b	jsr $8b47			jsr 	SwapDataCodePtrs 			; swap code and data
.8b33	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8b35	85 30		sta $30				sta 	codePtr
.8b37	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8b39	85 31		sta $31				sta 	codePtr+1
.8b3b	20 47 8b	jsr $8b47			jsr 	SwapDataCodePtrs 			; put them back
.8b3e	a9 03		lda #$03			lda 	#3 							; start at offset 3, e.g. first instruction of first line.
.8b40	8d 1b 04	sta $041b			sta 	dataPointer+4   			; (read checks not EOF)
.8b43	9c 1c 04	stz $041c			stz 	inDataStatement 			; not in data statement
.8b46	60		rts				rts
.8b47					SwapDataCodePtrs:
.8b47	da		phx				phx
.8b48	a2 03		ldx #$03			ldx 	#3 							; swap 32 bit code pointer over
.8b4a					_SDCPLoop:
.8b4a	b5 30		lda $30,x			lda 	safePtr,x
.8b4c	48		pha				pha
.8b4d	bd 17 04	lda $0417,x			lda 	dataPointer,x
.8b50	95 30		sta $30,x			sta 	safePtr,x
.8b52	68		pla				pla
.8b53	9d 17 04	sta $0417,x			sta 	dataPointer,x
.8b56	ca		dex				dex
.8b57	10 f1		bpl $8b4a			bpl 	_SDCPLoop
.8b59	ad 1b 04	lda $041b			lda 	dataPointer+4 				; swap Y position over.
.8b5c	8c 1b 04	sty $041b			sty 	dataPointer+4
.8b5f	a8		tay				tay
.8b60	fa		plx				plx
.8b61	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/run.asm

.8b62					EOLCommand:
.8b62	18		clc				clc
.8b63	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8b65	65 30		adc $30				adc 	codePtr
.8b67	85 30		sta $30				sta 	codePtr
.8b69	90 02		bcc $8b6d			bcc 	_CREExit
.8b6b	e6 31		inc $31				inc 	codePtr+1 					; carry
.8b6d					_CREExit:
.8b6d	80 0b		bra $8b7a			bra 	RunNewLine
.8b6f					CommandRUN:
.8b6f	20 6d 84	jsr $846d			jsr 	ClearCommand 				; clear variable/stacks/etc.
.8b72	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8b74	85 30		sta $30				sta 	codePtr
.8b76	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8b78	85 31		sta $31				sta 	codePtr+1
.8b7a					RUNNewLine:
.8b7a	b2 30		lda ($30)			lda 	(codePtr)
.8b7c	f0 7b		beq $8bf9			beq 	CRNoProgram         		; no then END.
.8b7e	a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack
.8b80	9a		txs				txs
.8b81					RUNCodePointerLine:
.8b81	a0 02		ldy #$02			ldy 	#2 							; start of program
.8b83					_CRIncMainLoop:
.8b83	0e 13 04	asl $0413			asl 	breakCheck 					; clears 1 time in 8
.8b86	d0 22		bne $8baa			bne 	_CRNoBreakCheck
.8b88	ce 13 04	dec $0413			dec	 	breakCheck 					; set it back to $FF
.8b8b	20 0c 80	jsr $800c			jsr 	EXTBreakCheck 				; break check
.8b8e	f0 64		beq $8bf4			beq 	_CRBreak
.8b90	a5 01		lda $01				lda 	1 							; save I/O 0
.8b92	48		pha				pha
.8b93	64 01		stz $01				stz 	1 							; access I/O Page 0
.8b95	38		sec				sec 								; calculate timer - LastTick
.8b96	ad 59 d6	lda $d659			lda 	$D659
.8b99	aa		tax				tax 								; saving timer in X
.8b9a	ed 5c 06	sbc $065c			sbc 	LastTick
.8b9d	c9 03		cmp #$03			cmp 	#3
.8b9f	90 06		bcc $8ba7			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.8ba1	8e 5c 06	stx $065c			stx 	LastTick 					; update last timer
.8ba4	20 46 9e	jsr $9e46			jsr 	TickHandler 							; go do the code.
.8ba7					_NoFireTick:
.8ba7	68		pla				pla 								; restore I/O 0
.8ba8	85 01		sta $01				sta 	1
.8baa					_CRNoBreakCheck:
.8baa	c8		iny				iny									; next token
.8bab					_CRMainLoop:
.8bab	9c 10 04	stz $0410			stz 	stringInitialised 			; clear the temporary string initialised flag.
.8bae	b1 30		lda ($30),y			lda 	(codePtr),y
.8bb0	10 10		bpl $8bc2			bpl 	_CRNotKeyword				; not a token.
.8bb2	c9 a2		cmp #$a2			cmp 	#KWC_LAST_UNARY+1 			; if after unary, legitimate command
.8bb4	b0 04		bcs $8bba			bcs 	_CRIsKeyword
.8bb6	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if unary, syntax error.
.8bb8	b0 34		bcs $8bee			bcs		_CRSyntaxError
.8bba					_CRIsKeyword:
.8bba	c8		iny				iny 								; consume command
.8bbb	0a		asl a				asl 	a 							; double losing the MSB which is '1' as tokens are $80-$FF
.8bbc	aa		tax				tax 								; put in X for vector jump
.8bbd	20 f1 8b	jsr $8bf1			jsr 	_CRCallVector0 				; call the vector - effectively jsr (vectortable,X)
.8bc0	80 e9		bra $8bab			bra 	_CRMainLoop 				; and loop round
.8bc2					_CRNotKeyword:
.8bc2	c9 3a		cmp #$3a			cmp 	#KWD_COLON 					; if a :, consume it and go round.
.8bc4	f0 bd		beq $8b83			beq 	_CRIncMainLoop
.8bc6	c9 40		cmp #$40			cmp 	#$40 						; variable/call reference
.8bc8	90 05		bcc $8bcf			bcc 	_CRNotVariable
.8bca					_CRGoLet:
.8bca	20 16 88	jsr $8816			jsr 	LetCommand
.8bcd	80 dc		bra $8bab			bra 	_CRMainLoop
.8bcf					_CRNotVariable:
.8bcf	c9 10		cmp #$10			cmp 	#KWD_AT 					; handle @
.8bd1	f0 f7		beq $8bca			beq 	_CRGoLet
.8bd3	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; handle ? !
.8bd5	f0 f3		beq $8bca			beq 	_CRGoLet
.8bd7	c9 21		cmp #$21			cmp 	#KWD_PLING
.8bd9	f0 ef		beq $8bca			beq 	_CRGoLet
.8bdb	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; handle ' (comment)
.8bdd	f0 09		beq $8be8			beq 	_CRGoRem
.8bdf	c9 2e		cmp #$2e			cmp 	#KWD_PERIOD 				; handle . (assembler label)
.8be1	d0 0b		bne $8bee			bne 	_CRSyntaxError
.8be3	20 51 82	jsr $8251			jsr 	LabelHere
.8be6	80 c3		bra $8bab			bra 	_CRMainLoop
.8be8					_CRGoRem:
.8be8	c8		iny				iny
.8be9	20 01 8b	jsr $8b01			jsr 	RemCommand
.8bec	80 bd		bra $8bab			bra 	_CRMainLoop
.8bee					_CRSyntaxError:
.8bee	4c 99 9f	jmp $9f99			jmp 	SyntaxError
.8bf1					_CRCallVector0:
.8bf1	7c 90 8c	jmp ($8c90,x)			jmp 	(VectorSet0,x)
.8bf4					_CRBreak:
.8bf4	a9 01		lda #$01		lda	#1
.8bf6	4c f9 8e	jmp $8ef9		jmp	ErrorHandler
.8bf9					CRNoProgram:
.8bf9	4c bb 85	jmp $85bb			jmp 	EndCommand
.8bfc					Shift1Command:
.8bfc	b1 30		lda ($30),y			lda 	(codePtr),y
.8bfe	c8		iny				iny
.8bff	0a		asl a				asl 	a
.8c00	aa		tax				tax
.8c01	7c 36 8d	jmp ($8d36,x)			jmp 	(VectorSet1,x)
.8c04					Shift2Command:
.8c04	b1 30		lda ($30),y			lda 	(codePtr),y
.8c06	c8		iny				iny
.8c07	0a		asl a				asl 	a
.8c08	aa		tax				tax
.8c09	7c 5c 8d	jmp ($8d5c,x)			jmp 	(VectorSet2,x)
.8c0c					Unused1:
.8c0c					Unused2:
.8c0c					Unused3:
.8c0c					Unused4:
.8c0c	4c 99 9f	jmp $9f99			jmp 	SyntaxError
>8c0f							.align 2

;******  Processing file: ./common/commands/../generated/vectors.dat

.8c10					VectorSetPunc:
>8c10	b1 91					.word	ShiftLeft                        ; $00 <<
>8c12	9c 8f					.word	BinaryCompareLessEqual           ; $01 <=
>8c14	92 8f					.word	BinaryCompareNotEqual            ; $02 <>
>8c16	99 9f					.word	SyntaxError                      ; $03 !!3
>8c18	99 9f					.word	SyntaxError                      ; $04 ><
>8c1a	a6 8f					.word	BinaryCompareGreaterEqual        ; $05 >=
>8c1c	b4 91					.word	ShiftRight                       ; $06 >>
>8c1e	99 9f					.word	SyntaxError                      ; $07 !!7
>8c20	99 9f					.word	SyntaxError                      ; $08 !!8
>8c22	99 9f					.word	SyntaxError                      ; $09 !!9
>8c24	99 9f					.word	SyntaxError                      ; $0a !!10
>8c26	99 9f					.word	SyntaxError                      ; $0b !!11
>8c28	99 9f					.word	SyntaxError                      ; $0c !!12
>8c2a	99 9f					.word	SyntaxError                      ; $0d !!13
>8c2c	99 9f					.word	SyntaxError                      ; $0e !!14
>8c2e	99 9f					.word	SyntaxError                      ; $0f !!15
>8c30	99 9f					.word	SyntaxError                      ; $10 @
>8c32	99 9f					.word	SyntaxError                      ; $11 !!17
>8c34	99 9f					.word	SyntaxError                      ; $12 !!18
>8c36	99 9f					.word	SyntaxError                      ; $13 [
>8c38	5d 90					.word	IntegerDivide                    ; $14 \
>8c3a	99 9f					.word	SyntaxError                      ; $15 ]
>8c3c	ef 92					.word	EorInteger                       ; $16 ^
>8c3e	99 9f					.word	SyntaxError                      ; $17 _
>8c40	99 9f					.word	SyntaxError                      ; $18 `
>8c42	99 9f					.word	SyntaxError                      ; $19 !!25
>8c44	99 9f					.word	SyntaxError                      ; $1a !!26
>8c46	99 9f					.word	SyntaxError                      ; $1b {
>8c48	ba 92					.word	OraInteger                       ; $1c |
>8c4a	99 9f					.word	SyntaxError                      ; $1d }
>8c4c	99 9f					.word	SyntaxError                      ; $1e ~
>8c4e	99 9f					.word	SyntaxError                      ; $1f [7m<7F>[m
>8c50	99 9f					.word	SyntaxError                      ; $20
>8c52	24 93					.word	WordIndirect                     ; $21 !
>8c54	99 9f					.word	SyntaxError                      ; $22 "
>8c56	99 9f					.word	SyntaxError                      ; $23 #
>8c58	99 9f					.word	SyntaxError                      ; $24 $
>8c5a	9e 90					.word	IntegerModulus                   ; $25 %
>8c5c	85 92					.word	AndInteger                       ; $26 &
>8c5e	99 9f					.word	SyntaxError                      ; $27 '
>8c60	99 9f					.word	SyntaxError                      ; $28 (
>8c62	99 9f					.word	SyntaxError                      ; $29 )
>8c64	0c 91					.word	MulInteger                       ; $2a *
>8c66	27 92					.word	AddInteger                       ; $2b +
>8c68	99 9f					.word	SyntaxError                      ; $2c ,
>8c6a	60 92					.word	SubInteger                       ; $2d -
>8c6c	99 9f					.word	SyntaxError                      ; $2e .
>8c6e	de 94					.word	FDivideCommand                   ; $2f /
>8c70	99 9f					.word	SyntaxError                      ; $30 0
>8c72	99 9f					.word	SyntaxError                      ; $31 1
>8c74	99 9f					.word	SyntaxError                      ; $32 2
>8c76	99 9f					.word	SyntaxError                      ; $33 3
>8c78	99 9f					.word	SyntaxError                      ; $34 4
>8c7a	99 9f					.word	SyntaxError                      ; $35 5
>8c7c	99 9f					.word	SyntaxError                      ; $36 6
>8c7e	99 9f					.word	SyntaxError                      ; $37 7
>8c80	99 9f					.word	SyntaxError                      ; $38 8
>8c82	99 9f					.word	SyntaxError                      ; $39 9
>8c84	99 9f					.word	SyntaxError                      ; $3a :
>8c86	99 9f					.word	SyntaxError                      ; $3b ;
>8c88	7e 8f					.word	BinaryCompareLess                ; $3c <
>8c8a	74 8f					.word	BinaryCompareEqual               ; $3d =
>8c8c	88 8f					.word	BinaryCompareGreater             ; $3e >
>8c8e	46 93					.word	ByteIndirect                     ; $3f ?
.8c90					VectorSet0:
>8c90	62 8b					.word	EOLCommand                       ; $80 !0:EOF
>8c92	fc 8b					.word	Shift1Command                    ; $81 !1:SH1
>8c94	04 8c					.word	Shift2Command                    ; $82 !2:SH2
>8c96	c3 99					.word	AbsUnary                         ; $83 ABS(
>8c98	d1 99					.word	AllocUnary                       ; $84 ALLOC(
>8c9a	41 9a					.word	AscUnary                         ; $85 ASC(
>8c9c	01 9c					.word	ChrUnary                         ; $86 CHR$(
>8c9e	51 9a					.word	DeekUnary                        ; $87 DEEK(
>8ca0	e6 a3					.word	UnaryEvent                       ; $88 EVENT(
>8ca2	70 8f					.word	UnaryFalse                       ; $89 FALSE
>8ca4	63 9a					.word	FracUnary                        ; $8a FRAC(
>8ca6	82 a3					.word	UnaryHit                         ; $8b HIT(
>8ca8	78 9a					.word	IntUnary                         ; $8c INT(
>8caa	c0 9b					.word	IsValUnary                       ; $8d ISVAL(
>8cac	6a a4					.word	UnaryJoyB                        ; $8e JOYB(
>8cae	43 a4					.word	UnaryJoyX                        ; $8f JOYX(
>8cb0	46 a4					.word	UnaryJoyY                        ; $90 JOYY(
>8cb2	d4 9c					.word	Unary_Left                       ; $91 LEFT$(
>8cb4	89 9a					.word	LenUnary                         ; $92 LEN(
>8cb6	a7 9a					.word	Unary_Max                        ; $93 MAX(
>8cb8	f6 9c					.word	Unary_Mid                        ; $94 MID$(
>8cba	a3 9a					.word	Unary_Min                        ; $95 MIN(
>8cbc	f2 9a					.word	Unary_Not                        ; $96 NOT(
>8cbe	4e 9a					.word	PeekUnary                        ; $97 PEEK(
>8cc0	07 a6					.word	UnaryPlaying                     ; $98 PLAYING(
>8cc2	05 9b					.word	Unary_Random                     ; $99 RANDOM(
>8cc4	e1 9c					.word	Unary_Right                      ; $9a RIGHT$(
>8cc6	22 9b					.word	Unary_Rnd                        ; $9b RND(
>8cc8	98 9b					.word	SgnUnary                         ; $9c SGN(
>8cca	13 9c					.word	SpcUnary                         ; $9d SPC(
>8ccc	2e 9c					.word	Unary_Str                        ; $9e STR$(
>8cce	90 a4					.word	UnaryTimer                       ; $9f TIMER(
>8cd0	65 8f					.word	UnaryTrue                        ; $a0 TRUE
>8cd2	b6 9b					.word	ValUnary                         ; $a1 VAL(
>8cd4	be 85					.word	ForCommand                       ; $a2 FOR
>8cd6	01 87					.word	IfCommand                        ; $a3 IF
>8cd8	0c 8c					.word	Unused1                          ; $a4 PROC
>8cda	0e 8b					.word	Command_REPEAT                   ; $a5 REPEAT
>8cdc	b1 8e					.word	Command_WHILE                    ; $a6 WHILE
>8cde	2a 87					.word	EndIf                            ; $a7 ENDIF
>8ce0	96 8a					.word	Command_ENDPROC                  ; $a8 ENDPROC
>8ce2	70 86					.word	NextCommand                      ; $a9 NEXT
>8ce4	0c 8c					.word	Unused4                          ; $aa THEN
>8ce6	17 8b					.word	Command_UNTIL                    ; $ab UNTIL
>8ce8	d2 8e					.word	Command_WEND                     ; $ac WEND
>8cea	99 9f					.word	SyntaxError                      ; $ad BY
>8cec	38 84					.word	CallCommand                      ; $ae CALL
>8cee	36 a1					.word	CircleCommand                    ; $af CIRCLE
>8cf0	6d 84					.word	ClearCommand                     ; $b0 CLEAR
>8cf2	c5 84					.word	ClearScreen                      ; $b1 CLS
>8cf4	99 9f					.word	SyntaxError                      ; $b2 COLOR
>8cf6	99 9f					.word	SyntaxError                      ; $b3 COLOUR
>8cf8	cd 84					.word	Command_Data                     ; $b4 DATA
>8cfa	d5 84					.word	DimCommand                       ; $b5 DIM
>8cfc	95 85					.word	DokeCommand                      ; $b6 DOKE
>8cfe	0c 8c					.word	Unused3                          ; $b7 DOWNTO
>8d00	23 87					.word	ElseCode                         ; $b8 ELSE
>8d02	99 9f					.word	SyntaxError                      ; $b9 FROM
>8d04	55 a3					.word	GfxCommand                       ; $ba GFX
>8d06	c9 86					.word	Command_GOSUB                    ; $bb GOSUB
>8d08	e7 86					.word	GotoCommand                      ; $bc GOTO
>8d0a	99 9f					.word	SyntaxError                      ; $bd HERE
>8d0c	5f a1					.word	ImageCommand                     ; $be IMAGE
>8d0e	2b 87					.word	Command_Input                    ; $bf INPUT
>8d10	16 88					.word	LetCommand                       ; $c0 LET
>8d12	b1 a1					.word	LineCommand                      ; $c1 LINE
>8d14	67 89					.word	Command_LOCAL                    ; $c2 LOCAL
>8d16	99 9f					.word	SyntaxError                      ; $c3 OFF
>8d18	99 9f					.word	SyntaxError                      ; $c4 ON
>8d1a	99 9f					.word	SyntaxError                      ; $c5 OUTLINE
>8d1c	a6 a3					.word	PaletteCommand                   ; $c6 PALETTE
>8d1e	aa a1					.word	PlotCommand                      ; $c7 PLOT
>8d20	92 85					.word	PokeCommand                      ; $c8 POKE
>8d22	32 87					.word	Command_Print                    ; $c9 PRINT
>8d24	a4 8a					.word	Command_Read                     ; $ca READ
>8d26	32 a1					.word	RectangleCommand                 ; $cb RECT
>8d28	01 8b					.word	RemCommand                       ; $cc REM
>8d2a	d9 86					.word	Command_RETURN                   ; $cd RETURN
>8d2c	99 9f					.word	SyntaxError                      ; $ce SOLID
>8d2e	23 a6					.word	SoundCommand                     ; $cf SOUND
>8d30	41 a1					.word	SpriteCommand                    ; $d0 SPRITE
>8d32	7b a1					.word	TextCommand                      ; $d1 TEXT
>8d34	0c 8c					.word	Unused2                          ; $d2 TO
.8d36					VectorSet1:
>8d36	99 9f					.word	SyntaxError                      ; $80 !0:EOF
>8d38	99 9f					.word	SyntaxError                      ; $81 !1:SH1
>8d3a	99 9f					.word	SyntaxError                      ; $82 !2:SH2
>8d3c	0c 84					.word	AssembleCommand                  ; $83 ASSEMBLE
>8d3e	28 84					.word	AssertCommand                    ; $84 ASSERT
>8d40	f5 a2					.word	BitmapCtrl                       ; $85 BITMAP
>8d42	bb 85					.word	EndCommand                       ; $86 END
>8d44	db a5					.word	Explode                          ; $87 EXPLODE
>8d46	87 a4					.word	GoCommand                        ; $88 GO
>8d48	66 88					.word	Command_List                     ; $89 LIST
>8d4a	7e a4					.word	LoadCommand                      ; $8a LOAD
>8d4c	28 8a					.word	NewCommand                       ; $8b NEW
>8d4e	b7 a5					.word	PingCommand                      ; $8c PING
>8d50	30 8b					.word	Command_Restore                  ; $8d RESTORE
>8d52	6f 8b					.word	CommandRUN                       ; $8e RUN
>8d54	cf a5					.word	ShootCommand                     ; $8f SHOOT
>8d56	3a a3					.word	SpritesCtrl                      ; $90 SPRITES
>8d58	e4 8d					.word	StopCommand                      ; $91 STOP
>8d5a	c3 a5					.word	ZapCommand                       ; $92 ZAP
.8d5c					VectorSet2:
>8d5c	99 9f					.word	SyntaxError                      ; $80 !0:EOF
>8d5e	99 9f					.word	SyntaxError                      ; $81 !1:SH1
>8d60	99 9f					.word	SyntaxError                      ; $82 !2:SH2
>8d62	58 9e					.word	Assemble_adc                     ; $83 ADC
>8d64	50 9e					.word	Assemble_and                     ; $84 AND
>8d66	6c 9e					.word	Assemble_asl                     ; $85 ASL
>8d68	d6 9e					.word	Assemble_bcc                     ; $86 BCC
>8d6a	da 9e					.word	Assemble_bcs                     ; $87 BCS
>8d6c	e2 9e					.word	Assemble_beq                     ; $88 BEQ
>8d6e	99 9e					.word	Assemble_bit                     ; $89 BIT
>8d70	ca 9e					.word	Assemble_bmi                     ; $8a BMI
>8d72	de 9e					.word	Assemble_bne                     ; $8b BNE
>8d74	c6 9e					.word	Assemble_bpl                     ; $8c BPL
>8d76	e6 9e					.word	Assemble_bra                     ; $8d BRA
>8d78	ea 9e					.word	Assemble_brk                     ; $8e BRK
>8d7a	ce 9e					.word	Assemble_bvc                     ; $8f BVC
>8d7c	d2 9e					.word	Assemble_bvs                     ; $90 BVS
>8d7e	f2 9e					.word	Assemble_clc                     ; $91 CLC
>8d80	46 9f					.word	Assemble_cld                     ; $92 CLD
>8d82	06 9f					.word	Assemble_cli                     ; $93 CLI
>8d84	36 9f					.word	Assemble_clv                     ; $94 CLV
>8d86	64 9e					.word	Assemble_cmp                     ; $95 CMP
>8d88	ad 9e					.word	Assemble_cpx                     ; $96 CPX
>8d8a	a8 9e					.word	Assemble_cpy                     ; $97 CPY
>8d8c	8a 9e					.word	Assemble_dec                     ; $98 DEC
>8d8e	42 9f					.word	Assemble_dex                     ; $99 DEX
>8d90	1e 9f					.word	Assemble_dey                     ; $9a DEY
>8d92	54 9e					.word	Assemble_eor                     ; $9b EOR
>8d94	8f 9e					.word	Assemble_inc                     ; $9c INC
>8d96	52 9f					.word	Assemble_inx                     ; $9d INX
>8d98	3e 9f					.word	Assemble_iny                     ; $9e INY
>8d9a	c1 9e					.word	Assemble_jmp                     ; $9f JMP
>8d9c	bc 9e					.word	Assemble_jsr                     ; $a0 JSR
>8d9e	60 9e					.word	Assemble_lda                     ; $a1 LDA
>8da0	85 9e					.word	Assemble_ldx                     ; $a2 LDX
>8da2	a3 9e					.word	Assemble_ldy                     ; $a3 LDY
>8da4	76 9e					.word	Assemble_lsr                     ; $a4 LSR
>8da6	56 9f					.word	Assemble_nop                     ; $a5 NOP
>8da8	4c 9e					.word	Assemble_ora                     ; $a6 ORA
>8daa	02 9f					.word	Assemble_pha                     ; $a7 PHA
>8dac	ee 9e					.word	Assemble_php                     ; $a8 PHP
>8dae	4a 9f					.word	Assemble_phx                     ; $a9 PHX
>8db0	0a 9f					.word	Assemble_phy                     ; $aa PHY
>8db2	12 9f					.word	Assemble_pla                     ; $ab PLA
>8db4	f6 9e					.word	Assemble_plp                     ; $ac PLP
>8db6	5e 9f					.word	Assemble_plx                     ; $ad PLX
>8db8	1a 9f					.word	Assemble_ply                     ; $ae PLY
>8dba	71 9e					.word	Assemble_rol                     ; $af ROL
>8dbc	7b 9e					.word	Assemble_ror                     ; $b0 ROR
>8dbe	fe 9e					.word	Assemble_rti                     ; $b1 RTI
>8dc0	0e 9f					.word	Assemble_rts                     ; $b2 RTS
>8dc2	68 9e					.word	Assemble_sbc                     ; $b3 SBC
>8dc4	fa 9e					.word	Assemble_sec                     ; $b4 SEC
>8dc6	5a 9f					.word	Assemble_sed                     ; $b5 SED
>8dc8	16 9f					.word	Assemble_sei                     ; $b6 SEI
>8dca	5c 9e					.word	Assemble_sta                     ; $b7 STA
>8dcc	4e 9f					.word	Assemble_stp                     ; $b8 STP
>8dce	80 9e					.word	Assemble_stx                     ; $b9 STX
>8dd0	9e 9e					.word	Assemble_sty                     ; $ba STY
>8dd2	94 9e					.word	Assemble_stz                     ; $bb STZ
>8dd4	32 9f					.word	Assemble_tax                     ; $bc TAX
>8dd6	2e 9f					.word	Assemble_tay                     ; $bd TAY
>8dd8	b7 9e					.word	Assemble_trb                     ; $be TRB
>8dda	b2 9e					.word	Assemble_tsb                     ; $bf TSB
>8ddc	3a 9f					.word	Assemble_tsx                     ; $c0 TSX
>8dde	22 9f					.word	Assemble_txa                     ; $c1 TXA
>8de0	2a 9f					.word	Assemble_txs                     ; $c2 TXS
>8de2	26 9f					.word	Assemble_tya                     ; $c3 TYA

;******  Return to file: ./common/commands/run.asm


;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/stop.asm

.8de4					StopCommand:
.8de4	a9 08		lda #$08		lda	#8
.8de6	4c f9 8e	jmp $8ef9		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/procscan.asm

.8de9					ProcedureScan:
.8de9	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8deb	85 30		sta $30				sta 	codePtr
.8ded	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8def	85 31		sta $31				sta 	codePtr+1
.8df1					_PSLoop:
.8df1	b2 30		lda ($30)			lda 	(codePtr)
.8df3	f0 42		beq $8e37			beq 	_PSExit
.8df5	a0 03		ldy #$03			ldy 	#3 							; is it PROC at start of line ?
.8df7	b1 30		lda ($30),y			lda 	(codePtr),y
.8df9	c9 a4		cmp #$a4			cmp 	#KWD_PROC
.8dfb	d0 2d		bne $8e2a			bne 	_PSNext
.8dfd	c8		iny				iny 								; get the address of the record to zTemp0 and
.8dfe	b1 30		lda ($30),y			lda 	(codePtr),y
.8e00	29 c0		and #$c0			and 	#$C0
.8e02	c9 40		cmp #$40			cmp 	#$40
.8e04	d0 32		bne $8e38			bne 	_PSSyntax
.8e06	b1 30		lda ($30),y			lda 	(codePtr),y
.8e08	18		clc				clc
.8e09	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8e0b	85 37		sta $37				sta 	zTemp0+1
.8e0d	c8		iny				iny 								; LSB
.8e0e	b1 30		lda ($30),y			lda 	(codePtr),y
.8e10	85 36		sta $36				sta 	zTemp0
.8e12	c8		iny				iny 								; character after variable call.
.8e13	98		tya				tya 								; save Y offset at +7 (exponent slot)
.8e14	a0 07		ldy #$07			ldy 	#7
.8e16	91 36		sta ($36),y			sta 	(zTemp0),y
.8e18	a9 18		lda #$18			lda 	#NSTProcedure 				; mark it as procedure
.8e1a	a0 02		ldy #$02			ldy 	#2
.8e1c	91 36		sta ($36),y			sta 	(zTemp0),y
.8e1e	a2 00		ldx #$00			ldx 	#0 							; copy code-Ptr into offset 3-6 (mantissa)
.8e20					_PSCopy:
.8e20	b5 30		lda $30,x			lda 	safePtr,x
.8e22	c8		iny				iny
.8e23	91 36		sta ($36),y			sta 	(zTemp0),y
.8e25	e8		inx				inx
.8e26	e0 04		cpx #$04			cpx 	#4
.8e28	d0 f6		bne $8e20			bne 	_PSCopy
.8e2a					_PSNext:
.8e2a	18		clc				clc
.8e2b	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8e2d	65 30		adc $30				adc 	codePtr
.8e2f	85 30		sta $30				sta 	codePtr
.8e31	90 02		bcc $8e35			bcc 	_CREExit
.8e33	e6 31		inc $31				inc 	codePtr+1 					; carry
.8e35					_CREExit:
.8e35	80 ba		bra $8df1			bra 	_PSLoop
.8e37					_PSExit:
.8e37	60		rts				rts
.8e38					_PSSyntax:
.8e38	4c 99 9f	jmp $9f99			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/scanforward.asm

.8e3b					ScanForward:
.8e3b	64 38		stz $38				stz 	zTemp1 						; zero the structure count - goes up with WHILE/FOR down with WEND/NEXT etc.
.8e3d	86 37		stx $37				stx 	zTemp0+1
.8e3f	85 36		sta $36				sta 	zTemp0 						; save X & A as the two possible matches.
.8e41					_ScanLoop:
.8e41	b1 30		lda ($30),y			lda 	(codePtr),y
.8e43	c8		iny				iny
.8e44	a6 38		ldx $38				ldx 	zTemp1 						; if the count is > 0 cannot match as in substructure
.8e46	d0 0e		bne $8e56			bne 	_ScanGoNext
.8e48	c5 36		cmp $36				cmp 	zTemp0 						; see if either matches
.8e4a	f0 04		beq $8e50			beq 	_ScanMatch
.8e4c	c5 37		cmp $37				cmp 	zTemp0+1
.8e4e	d0 06		bne $8e56			bne 	_ScanGoNext
.8e50					_ScanMatch:
.8e50	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if asked for EOL, backtrack.
.8e52	d0 01		bne $8e55			bne 	_ScanNotEndEOL
.8e54	88		dey				dey
.8e55					_ScanNotEndEOL:
.8e55	60		rts				rts
.8e56					_ScanGoNext:
.8e56	20 5b 8e	jsr $8e5b			jsr  	ScanForwardOne 				; allows for shifts and so on.
.8e59	80 e6		bra $8e41			bra 	_ScanLoop
.8e5b					ScanForwardOne:
.8e5b	c9 40		cmp #$40			cmp 	#$40 						; if 00-3F, punctuation characters, already done.
.8e5d	90 3e		bcc $8e9d			bcc 	_SFWExit
.8e5f	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if 40-82, skip one extra as these are 2 byte
.8e61	90 18		bcc $8e7b			bcc 	_ScanSkipOne	 			; offsets into the identifier table or shifts.
.8e63	c9 fc		cmp #$fc			cmp 	#$FC 						; FC-FF are data skips (hex consts, strings etc.)
.8e65	b0 2f		bcs $8e96			bcs 	_ScanSkipData
.8e67	c9 a2		cmp #$a2			cmp 	#KWC_FIRST_STRUCTURE 		; structure keyword ?
.8e69	90 32		bcc $8e9d			bcc 	_SFWExit 					; if not, ordinary keywords.
.8e6b	c9 ad		cmp #$ad			cmp 	#KWC_LAST_STRUCTURE+1
.8e6d	b0 2e		bcs $8e9d			bcs 	_SFWExit
.8e6f	c6 38		dec $38				dec 	zTemp1 						; decrement the sructure count
.8e71	c9 a7		cmp #$a7			cmp 	#KWC_FIRST_STRUCTURE_DEC 	; back if it is a dec structure (e.g. WEND/NEXT)
.8e73	b0 28		bcs $8e9d			bcs 	_SFWExit
.8e75	e6 38		inc $38				inc 	zTemp1 						; so it's an increment structure
.8e77	e6 38		inc $38				inc 	zTemp1 						; twice to undo the dec
.8e79	80 22		bra $8e9d			bra 	_SFWExit
.8e7b					_ScanSkipOne:
.8e7b	c8		iny				iny 								; consume the extra one.
.8e7c	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if not EOL loop back
.8e7e	d0 1d		bne $8e9d			bne 	_SFWExit
.8e80	18		clc				clc
.8e81	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8e83	65 30		adc $30				adc 	codePtr
.8e85	85 30		sta $30				sta 	codePtr
.8e87	90 02		bcc $8e8b			bcc 	_CREExit
.8e89	e6 31		inc $31				inc 	codePtr+1 					; carry
.8e8b					_CREExit:
.8e8b	a0 03		ldy #$03			ldy 	#3 							; scan start position.
.8e8d	b2 30		lda ($30)			lda 	(codePtr)
.8e8f	d0 0c		bne $8e9d			bne 	_SFWExit 					; if not zero, more to scan
.8e91	a9 13		lda #$13		lda	#19
.8e93	4c f9 8e	jmp $8ef9		jmp	ErrorHandler
.8e96					_ScanSkipData:
.8e96	88		dey				dey 								; point at data token
.8e97	c8		iny				iny 								; point to offset
.8e98	98		tya				tya 								; A = offset position
.8e99	38		sec				sec 								; add size +1 hence SEC
.8e9a	71 30		adc ($30),y			adc 	(codePtr),y
.8e9c	a8		tay				tay 								; make current position.
.8e9d					_SFWExit:
.8e9d	60		rts				rts
.8e9e					ScanGetCurrentLineStep:
.8e9e	64 38		stz $38				stz 	zTemp1
.8ea0	a0 03		ldy #$03			ldy 	#3
.8ea2					_SGCLSLoop:
.8ea2	b1 30		lda ($30),y			lda 	(codePtr),y
.8ea4	c8		iny				iny
.8ea5	c9 80		cmp #$80			cmp 	#KWC_EOL	 				; if EOL exit
.8ea7	f0 05		beq $8eae			beq 	_SGCLSExit
.8ea9	20 5b 8e	jsr $8e5b			jsr 	ScanForwardOne
.8eac	80 f4		bra $8ea2			bra 	_SGCLSLoop
.8eae					_SGCLSExit:
.8eae	a5 38		lda $38				lda 	zTemp1 						; return the adjustment
.8eb0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/while.asm

.8eb1					Command_WHILE:
.8eb1	5a		phy				phy 								; save position of the test
.8eb2	a2 00		ldx #$00			ldx 	#0 							; work out the while test.
.8eb4	20 69 9d	jsr $9d69			jsr 	EvaluateNumber
.8eb7	20 3d 9e	jsr $9e3d			jsr 	NSMIsZero 					; check if zero
.8eba	f0 0e		beq $8eca			beq 	_WHExitLoop 				; if so exit the loop, while has failed.
.8ebc	98		tya				tya 								; position *after* test.
.8ebd	7a		ply				ply 								; restore position before test, at WHILE
.8ebe	88		dey				dey 								; so we execute the WHILE command again.
.8ebf	48		pha				pha 								; push after test on the stack
.8ec0	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; allocate 6 bytes on the return stack.
.8ec2	20 aa a6	jsr $a6aa			jsr 	StackOpen
.8ec5	20 ef a6	jsr $a6ef			jsr 	STKSaveCodePosition 		; save loop position - where the test value expr is.
.8ec8	7a		ply				ply 								; restore the position *after* the test
.8ec9	60		rts				rts
.8eca					_WHExitLoop:
.8eca	68		pla				pla 								; throw post loop position
.8ecb	a9 ac		lda #$ac			lda 	#KWD_WEND 					; scan forward past WEND
.8ecd	aa		tax				tax
.8ece	20 3b 8e	jsr $8e3b			jsr 	ScanForward
.8ed1	60		rts				rts
.8ed2					Command_WEND:
.8ed2	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; check WHILE is TOS e.g. in a while loop :)
.8ed4	a2 10		ldx #$10			ldx 	#ERRID_WHILE 				; this error if not.
.8ed6	20 d7 a6	jsr $a6d7			jsr 	StackCheckFrame
.8ed9	20 00 a7	jsr $a700			jsr 	STKLoadCodePosition 		; loop back to the WHILE keyword.
.8edc	20 c9 a6	jsr $a6c9			jsr 	StackClose		 			; erase the frame
.8edf	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/charcheck.asm

.8ee0					CheckRightBracket:
.8ee0	b1 30		lda ($30),y			lda 	(codePtr),y
.8ee2	c8		iny				iny
.8ee3	c9 29		cmp #$29			cmp 	#KWD_RPAREN 						; exit if matches
.8ee5	d0 0f		bne $8ef6			bne 	CNAFail
.8ee7	60		rts				rts
.8ee8					CheckComma:
.8ee8	b1 30		lda ($30),y			lda 	(codePtr),y
.8eea	c8		iny				iny
.8eeb	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 						; exit if matches
.8eed	d0 07		bne $8ef6			bne 	CNAFail
.8eef	60		rts				rts
.8ef0					CheckNextA:
.8ef0	d1 30		cmp ($30),y			cmp 	(codePtr),y
.8ef2	d0 02		bne $8ef6			bne 	CNAFail
.8ef4	c8		iny				iny 								; skip character
.8ef5	60		rts				rts 								; and exit
.8ef6					CNAFail:
.8ef6	4c 99 9f	jmp $9f99			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/errors.asm

.8ef9					ErrorHandler:
.8ef9	a8		tay				tay 								; find the error text
.8efa	f0 49		beq $8f45			beq 	_EHEnd
.8efc	a2 00		ldx #$00			ldx 	#0
.8efe	a9 b2		lda #$b2			lda 	#((ErrorText) & $FF)
.8f00	85 36		sta $36				sta 	0+zTemp0
.8f02	a9 9f		lda #$9f			lda 	#((ErrorText) >> 8)
.8f04	85 37		sta $37				sta 	1+zTemp0
.8f06					_EHFind:
.8f06	88		dey				dey 								; keep looking through text
.8f07	f0 0e		beq $8f17			beq 	_EHFound
.8f09					_EHFindZero:
.8f09	b2 36		lda ($36)			lda 	(zTemp0) 					; find the next error
.8f0b	e6 36		inc $36				inc 	zTemp0
.8f0d	d0 02		bne $8f11			bne 	_EHFNoCarry
.8f0f	e6 37		inc $37				inc 	zTemp0+1
.8f11					_EHFNoCarry:
.8f11	c9 00		cmp #$00			cmp 	#0
.8f13	d0 f4		bne $8f09			bne 	_EHFindZero
.8f15	80 ef		bra $8f06			bra 	_EHFind
.8f17					_EHFound:
.8f17	a5 36		lda $36				lda 	zTemp0 						; print message
.8f19	a6 37		ldx $37				ldx 	zTemp0+1
.8f1b	20 52 8f	jsr $8f52			jsr 	PrintStringXA
.8f1e	a0 01		ldy #$01			ldy 	#1 							; if line number zero don't print it
.8f20	b1 30		lda ($30),y			lda 	(codePtr),y
.8f22	d0 05		bne $8f29			bne 	_EHAtMsg
.8f24	c8		iny				iny
.8f25	b1 30		lda ($30),y			lda 	(codePtr),y
.8f27	f0 17		beq $8f40			beq 	_EHCREnd
.8f29					_EHAtMsg:
.8f29	a2 8f		ldx #$8f			ldx 	#_AtMsg >> 8 				; print " at "
.8f2b	a9 48		lda #$48			lda 	#_AtMsg & $FF
.8f2d	20 52 8f	jsr $8f52			jsr 	PrintStringXA
.8f30	a0 01		ldy #$01			ldy 	#1 							; line number into XA
.8f32	b1 30		lda ($30),y			lda 	(codePtr),y
.8f34	48		pha				pha
.8f35	c8		iny				iny
.8f36	b1 30		lda ($30),y			lda 	(codePtr),y
.8f38	aa		tax				tax
.8f39	68		pla				pla
.8f3a	20 68 93	jsr $9368			jsr 	ConvertInt16 				; convert XA to string
.8f3d	20 52 8f	jsr $8f52			jsr 	PrintStringXA 				; and print it.
.8f40					_EHCREnd:
.8f40	a9 0d		lda #$0d			lda 	#13 						; new line
.8f42	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8f45					_EHEnd:
.8f45	4c d7 83	jmp $83d7			jmp 	WarmStart
>8f48	20 61 74 20 6c 69 6e 65		_AtMsg:	.text 	" at line ",0
>8f50	20 00
.8f52					PrintStringXA:
.8f52	5a		phy				phy
.8f53	86 37		stx $37				stx 	zTemp0+1
.8f55	85 36		sta $36				sta 	zTemp0
.8f57	a0 00		ldy #$00			ldy 	#0
.8f59					_PSXALoop:
.8f59	b1 36		lda ($36),y			lda 	(zTemp0),y
.8f5b	f0 06		beq $8f63			beq 	_PSXAExit
.8f5d	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8f60	c8		iny				iny
.8f61	80 f6		bra $8f59			bra 	_PSXALoop
.8f63					_PSXAExit:
.8f63	7a		ply				ply
.8f64	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/compare.asm

.8f65					UnaryTrue:
.8f65	fa		plx				plx
.8f66					ReturnTrue:
.8f66	a9 01		lda #$01			lda 	#1  						; set to 1
.8f68	20 1d 9e	jsr $9e1d			jsr 	NSMSetByte
.8f6b	a9 80		lda #$80			lda 	#$80 						; set sign flag, so it is -1
.8f6d	95 50		sta $50,x			sta 	NSStatus,x
.8f6f	60		rts				rts
.8f70					UnaryFalse:
.8f70	fa		plx				plx
.8f71					ReturnFalse:
.8f71	4c 1b 9e	jmp $9e1b			jmp 	NSMSetZero 					; set it all to zero
.8f74					BinaryCompareEqual:
.8f74	fa		plx				plx
.8f75	20 b0 8f	jsr $8fb0			jsr 	CompareBaseCode
.8f78	c9 00		cmp #$00			cmp 	#0
.8f7a	f0 ea		beq $8f66			beq 	ReturnTrue
.8f7c	80 f3		bra $8f71			bra 	ReturnFalse
.8f7e					BinaryCompareLess:
.8f7e	fa		plx				plx
.8f7f	20 b0 8f	jsr $8fb0			jsr 	CompareBaseCode
.8f82	c9 ff		cmp #$ff			cmp 	#$FF
.8f84	f0 e0		beq $8f66			beq 	ReturnTrue
.8f86	80 e9		bra $8f71			bra 	ReturnFalse
.8f88					BinaryCompareGreater:
.8f88	fa		plx				plx
.8f89	20 b0 8f	jsr $8fb0			jsr 	CompareBaseCode
.8f8c	c9 01		cmp #$01			cmp 	#1
.8f8e	f0 d6		beq $8f66			beq 	ReturnTrue
.8f90	80 df		bra $8f71			bra 	ReturnFalse
.8f92					BinaryCompareNotEqual:
.8f92	fa		plx				plx
.8f93	20 b0 8f	jsr $8fb0			jsr 	CompareBaseCode
.8f96	c9 00		cmp #$00			cmp 	#0
.8f98	d0 cc		bne $8f66			bne 	ReturnTrue
.8f9a	80 d5		bra $8f71			bra 	ReturnFalse
.8f9c					BinaryCompareLessEqual:
.8f9c	fa		plx				plx
.8f9d	20 b0 8f	jsr $8fb0			jsr 	CompareBaseCode
.8fa0	c9 01		cmp #$01			cmp 	#1
.8fa2	d0 c2		bne $8f66			bne 	ReturnTrue
.8fa4	80 cb		bra $8f71			bra 	ReturnFalse
.8fa6					BinaryCompareGreaterEqual:
.8fa6	fa		plx				plx
.8fa7	20 b0 8f	jsr $8fb0			jsr 	CompareBaseCode
.8faa	c9 ff		cmp #$ff			cmp 	#$FF
.8fac	d0 b8		bne $8f66			bne 	ReturnTrue
.8fae	80 c1		bra $8f71			bra 	ReturnFalse
.8fb0					CompareBaseCode:
.8fb0	20 bb 96	jsr $96bb			jsr 	DereferenceTopTwo 			; make both values if references.
.8fb3	b5 50		lda $50,x			lda 	NSStatus,x 					; check if either is a string.
.8fb5	15 51		ora $51,x			ora 	NSStatus+1,x
.8fb7	29 10		and #$10			and 	#NSTString
.8fb9	d0 37		bne $8ff2			bne 	_CBCString 					; if so do string code, which will check if both.
.8fbb	b5 78		lda $78,x			lda 	NSExponent,x 				; check both are integers
.8fbd	15 79		ora $79,x			ora 	NSExponent+1,x
.8fbf	d0 34		bne $8ff5			bne 	_CBCFloat
.8fc1	b5 50		lda $50,x			lda 	NSStatus,x
.8fc3	15 51		ora $51,x			ora 	NSStatus+1,x
.8fc5	29 08		and #$08			and 	#NSTFloat
.8fc7	d0 2c		bne $8ff5			bne 	_CBCFloat
.8fc9	20 f8 8f	jsr $8ff8			jsr 	CompareFixMinusZero 		; fix up -0 just in cases.
.8fcc	e8		inx				inx
.8fcd	20 f8 8f	jsr $8ff8			jsr 	CompareFixMinusZero
.8fd0	ca		dex				dex
.8fd1	b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs different ?
.8fd3	55 51		eor $51,x			eor 	NSStatus+1,x
.8fd5	10 0a		bpl $8fe1			bpl 	_CDCSameSign
.8fd7	b5 50		lda $50,x			lda 	NSStatus,x 					; if first one is -ve
.8fd9	30 14		bmi $8fef			bmi 	_CBCLess 					; return $FF
.8fdb					_CBCGreater:
.8fdb	a9 01		lda #$01			lda 	#1
.8fdd	60		rts				rts
.8fde					_CBCEqual:
.8fde	a9 00		lda #$00			lda 	#0
.8fe0	60		rts				rts
.8fe1					_CDCSameSign:
.8fe1	20 0d 92	jsr $920d			jsr 	SubTopTwoStack 				; unsigned subtract
.8fe4	20 3d 9e	jsr $9e3d			jsr 	NSMIsZero 					; or the mantissa together
.8fe7	f0 f5		beq $8fde			beq 	_CBCEqual 					; -0 == 0
.8fe9	b5 70		lda $70,x			lda 	NSMantissa3,x 				; sign of the result. if +ve return $01 else return $FF
.8feb	55 51		eor $51,x			eor 	NSStatus+1,x 				; however if both were -ve this is inverted
.8fed	10 ec		bpl $8fdb			bpl 	_CBCGreater
.8fef					_CBCLess:
.8fef	a9 ff		lda #$ff			lda 	#$FF
.8ff1	60		rts				rts
.8ff2					_CBCString:
.8ff2	4c 7e 91	jmp $917e			jmp 	CompareStrings
.8ff5					_CBCFloat:
.8ff5	4c c8 94	jmp $94c8			jmp 	CompareFloat
.8ff8					CompareFixMinusZero:
.8ff8	20 3d 9e	jsr $9e3d			jsr 	NSMIsZero
.8ffb	d0 02		bne $8fff			bne 	_CFXMZNotZero
.8ffd	74 50		stz $50,x			stz 	NSStatus,x
.8fff					_CFXMZNotZero:
.8fff	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/concat.asm

.9000					StringConcat:
.9000	b5 50		lda $50,x			lda 	NSStatus,x 					; check both strings
.9002	35 51		and $51,x			and 	NSStatus+1,x
.9004	29 18		and #$18			and 	#NSBTypeMask
.9006	c9 10		cmp #$10			cmp 	#NSTString
.9008	d0 50		bne $905a			bne		_SCType
.900a	64 38		stz $38				stz 	zTemp1 						; counting total length
.900c	e8		inx				inx
.900d	20 2b 90	jsr $902b			jsr 	_SCSetupZ0 					; setup for second
.9010	20 34 90	jsr $9034			jsr 	_SCLengthZ0 				; length for second
.9013	ca		dex				dex
.9014	20 2b 90	jsr $902b			jsr 	_SCSetupZ0 					; setup for first
.9017	20 34 90	jsr $9034			jsr 	_SCLengthZ0 				; length for first
.901a	a5 38		lda $38				lda 	zTemp1 						; allocate memory using total.
.901c	20 9a a7	jsr $a79a			jsr 	StringTempAllocate
.901f	20 4b 90	jsr $904b			jsr 	_SCCopy 					; copy first out, using zTemp0 from above
.9022	e8		inx				inx
.9023	20 2b 90	jsr $902b			jsr 	_SCSetupZ0 					; copy second out
.9026	20 4b 90	jsr $904b			jsr 	_SCCopy
.9029	ca		dex				dex
.902a	60		rts				rts
.902b					_SCSetupZ0:
.902b	b5 58		lda $58,x			lda 	NSMantissa0,x
.902d	85 36		sta $36				sta 	zTemp0
.902f	b5 60		lda $60,x			lda 	NSMantissa1,x
.9031	85 37		sta $37				sta 	zTemp0+1
.9033	60		rts				rts
.9034					_SCLengthZ0:
.9034	5a		phy				phy
.9035	a0 00		ldy #$00			ldy 	#0
.9037					_SCLenLoop:
.9037	b1 36		lda ($36),y			lda 	(zTemp0),y
.9039	f0 0e		beq $9049			beq 	_SCLExit
.903b	c8		iny				iny
.903c	e6 38		inc $38				inc 	zTemp1
.903e	a5 38		lda $38				lda	 	zTemp1 						; check string too long.
.9040	c9 fd		cmp #$fd			cmp 	#253
.9042	d0 f3		bne $9037			bne		_SCLenLoop
.9044	a9 09		lda #$09		lda	#9
.9046	4c f9 8e	jmp $8ef9		jmp	ErrorHandler
.9049					_SCLExit:
.9049	7a		ply				ply
.904a	60		rts				rts
.904b					_SCCopy:
.904b	5a		phy				phy
.904c	a0 00		ldy #$00			ldy 	#0
.904e					_SCCopyLoop:
.904e	b1 36		lda ($36),y			lda 	(zTemp0),y
.9050	f0 06		beq $9058			beq 	_SCCExit
.9052	20 d3 a7	jsr $a7d3			jsr 	StringTempWrite
.9055	c8		iny				iny
.9056	80 f6		bra $904e			bra 	_SCCopyLoop
.9058					_SCCExit:
.9058	7a		ply				ply
.9059	60		rts				rts
.905a					_SCType:
.905a	4c a3 9f	jmp $9fa3			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/divide.asm

.905d					IntegerDivide:
.905d	fa		plx				plx
.905e	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9060	15 51		ora $51,x			ora 	NSStatus+1,x
.9062	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9063	0a		asl a				asl 	a
.9064	10 05		bpl $906b			bpl 	_NotRef
.9066	48		pha				pha
.9067	20 bb 96	jsr $96bb			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.906a	68		pla				pla
.906b					_NotRef:
.906b	0a		asl a				asl 	a
.906c	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.906e	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9070	15 79		ora $79,x			ora 	NSExponent+1,x
.9072	f0 03		beq $9077			beq 	_IntegerCode 				; if clear, then we have two integers
.9074	4c a3 9f	jmp $9fa3			jmp 	TypeError 					; anything else, type mismatch.
.9077					_IntegerCode:
.9077	20 91 90	jsr $9091			jsr 	CheckDivideZero 			; do div zero check
.907a	20 c3 90	jsr $90c3			jsr 	Int32Divide 				; do the division
.907d	20 74 91	jsr $9174			jsr 	CalculateSign 				; calculate result sign
.9080					NSMCopyPlusTwoToZero:
.9080	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.9082	95 58		sta $58,x			sta 	NSMantissa0,x
.9084	b5 62		lda $62,x			lda 	NSMantissa1+2,x
.9086	95 60		sta $60,x			sta 	NSMantissa1,x
.9088	b5 6a		lda $6a,x			lda 	NSMantissa2+2,x
.908a	95 68		sta $68,x			sta 	NSMantissa2,x
.908c	b5 72		lda $72,x			lda 	NSMantissa3+2,x
.908e	95 70		sta $70,x			sta 	NSMantissa3,x
.9090	60		rts				rts
.9091					CheckDivideZero:
.9091	e8		inx				inx
.9092	20 3d 9e	jsr $9e3d			jsr 	NSMIsZero
.9095	f0 02		beq $9099			beq 	_CDVError
.9097	ca		dex				dex
.9098	60		rts				rts
.9099					_CDVError:
.9099	a9 03		lda #$03		lda	#3
.909b	4c f9 8e	jmp $8ef9		jmp	ErrorHandler
.909e					IntegerModulus:
.909e	fa		plx				plx
.909f	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.90a1	15 51		ora $51,x			ora 	NSStatus+1,x
.90a3	0a		asl a				asl 	a 							; shift reference bit into sign bit
.90a4	0a		asl a				asl 	a
.90a5	10 05		bpl $90ac			bpl 	_NotRef
.90a7	48		pha				pha
.90a8	20 bb 96	jsr $96bb			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.90ab	68		pla				pla
.90ac					_NotRef:
.90ac	0a		asl a				asl 	a
.90ad	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.90af	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.90b1	15 79		ora $79,x			ora 	NSExponent+1,x
.90b3	f0 03		beq $90b8			beq 	_IntegerCode 				; if clear, then we have two integers
.90b5	4c a3 9f	jmp $9fa3			jmp 	TypeError 					; anything else, type mismatch.
.90b8					_IntegerCode:
.90b8					IntegerModulusNoCheck:
.90b8	20 91 90	jsr $9091			jsr 	CheckDivideZero 			; do div zero check
.90bb	20 c3 90	jsr $90c3			jsr 	Int32Divide 				; do the division
.90be	16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.90c0	56 50		lsr $50,x			lsr 	NSStatus,x
.90c2	60		rts				rts
.90c3					Int32Divide:
.90c3	48		pha				pha 								; save AXY
.90c4	5a		phy				phy
.90c5	20 fe 9d	jsr $9dfe			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.90c8	20 17 9e	jsr $9e17			jsr 	NSMSetZeroMantissaOnly 		; set S[X] to zero
.90cb	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.90cd					_I32DivideLoop:
.90cd	e8		inx				inx
.90ce	e8		inx				inx
.90cf	20 2a 9e	jsr $9e2a			jsr 	NSMShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.90d2	ca		dex				dex
.90d3	ca		dex				dex
.90d4	20 2b 9e	jsr $9e2b			jsr 	NSMRotateLeft
.90d7	20 02 91	jsr $9102			jsr 	DivideCheckSubtract 		; check if subtract possible
.90da	90 02		bcc $90de			bcc 	_I32DivideNoCarryIn
.90dc	f6 5a		inc $5a,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.90de					_I32DivideNoCarryIn:
.90de	88		dey				dey 								; loop round till division completed.
.90df	d0 ec		bne $90cd			bne 	_I32DivideLoop
.90e1	7a		ply				ply 								; restore AXY and exit
.90e2	68		pla				pla
.90e3	60		rts				rts
.90e4					Int32ShiftDivide:
.90e4	48		pha				pha 								; save AY
.90e5	5a		phy				phy
.90e6	e8		inx				inx 								; clear S[X+2]
.90e7	e8		inx				inx
.90e8	20 1b 9e	jsr $9e1b			jsr 	NSMSetZero
.90eb	ca		dex				dex
.90ec	ca		dex				dex
.90ed	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.90ef					_I32SDLoop:
.90ef	20 02 91	jsr $9102			jsr 	DivideCheckSubtract 		; check if subtract possible
.90f2	e8		inx				inx
.90f3	e8		inx				inx
.90f4	20 2b 9e	jsr $9e2b			jsr 	NSMRotateLeft				; shift 64 bit FPA left, rotating carry in
.90f7	ca		dex				dex
.90f8	ca		dex				dex
.90f9	20 2b 9e	jsr $9e2b			jsr 	NSMRotateLeft
.90fc	88		dey				dey 	 							; do 31 times
.90fd	d0 f0		bne $90ef			bne 	_I32SDLoop
.90ff	7a		ply				ply 								; restore AY and exit
.9100	68		pla				pla
.9101	60		rts				rts
.9102					DivideCheckSubtract:
.9102	20 0d 92	jsr $920d			jsr 	SubTopTwoStack 				; subtract Stack[X+1] from Stack[X+0]
.9105	b0 04		bcs $910b			bcs 	_DCSExit 					; if carry set, then could do, exit
.9107	20 f3 91	jsr $91f3			jsr 	AddTopTwoStack 				; add it back in
.910a	18		clc				clc 								; and return False
.910b					_DCSExit:
.910b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/multiply.asm

.910c					MulInteger:
.910c	fa		plx				plx
.910d	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.910f	15 51		ora $51,x			ora 	NSStatus+1,x
.9111	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9112	0a		asl a				asl 	a
.9113	10 05		bpl $911a			bpl 	_NotRef
.9115	48		pha				pha
.9116	20 bb 96	jsr $96bb			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9119	68		pla				pla
.911a					_NotRef:
.911a	0a		asl a				asl 	a 							; put MSB of type into A:7
.911b	30 09		bmi $9126			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.911d	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.911f	15 79		ora $79,x			ora 	NSExponent+1,x
.9121	f0 06		beq $9129			beq 	_IntegerCode 				; if clear, then we have two integers
.9123	4c 8a 95	jmp $958a			jmp 	FloatingPointMultiply 							; otherwise at least one float.
.9126					_StringData:
.9126	4c ad 9f	jmp $9fad			jmp 	NotDoneError							; at least one string - don't know both are strings.
.9129					_IntegerCode:
.9129	20 36 91	jsr $9136			jsr 	MultiplyShort
.912c	c9 00		cmp #$00			cmp 	#0
.912e	f0 05		beq $9135			beq 	_MIExit
.9130	a9 04		lda #$04		lda	#4
.9132	4c f9 8e	jmp $8ef9		jmp	ErrorHandler
.9135					_MIExit:
.9135	60		rts				rts
.9136					MultiplyShort:
.9136	5a		phy				phy 								; save Y
.9137	20 fe 9d	jsr $9dfe			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.913a	20 17 9e	jsr $9e17			jsr 	NSMSetZeroMantissaOnly 		; set mantissa S[X] to zero
.913d	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.913f					_I32MLoop:
.913f	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.9141	15 62		ora $62,x			ora 	NSMantissa1+2,x
.9143	15 6a		ora $6a,x			ora 	NSMantissa2+2,x
.9145	15 72		ora $72,x			ora 	NSMantissa3+2,x
.9147	f0 25		beq $916e			beq 	_I32MExit 					; exit if zero
.9149	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.914b	29 01		and #$01			and 	#1
.914d	f0 0d		beq $915c			beq 	_I32MNoAdd
.914f	20 f3 91	jsr $91f3			jsr 	AddTopTwoStack 				; if so add S[X+1] to S[X+0]
.9152	b5 70		lda $70,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.9154	10 06		bpl $915c			bpl 	_I32MNoAdd
.9156					_I32ShiftRight:
.9156	20 34 9e	jsr $9e34			jsr 	NSMShiftRight 				; shift S[X] right
.9159	c8		iny				iny 								; increment shift count
.915a	80 09		bra $9165			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.915c					_I32MNoAdd:
.915c	34 71		bit $71,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.915e	70 f6		bvs $9156			bvs 	_I32ShiftRight 				; instead.
.9160	e8		inx				inx
.9161	20 2a 9e	jsr $9e2a			jsr 	NSMShiftLeft 				; shift additive S[X+1] left
.9164	ca		dex				dex
.9165					_I32MShiftUpper:
.9165	e8		inx				inx 								; shift S[X+2] right
.9166	e8		inx				inx
.9167	20 34 9e	jsr $9e34			jsr 	NSMShiftRight
.916a	ca		dex				dex
.916b	ca		dex				dex
.916c	80 d1		bra $913f			bra 	_I32MLoop 					; try again.
.916e					_I32MExit:
.916e	20 74 91	jsr $9174			jsr 	CalculateSign
.9171	98		tya				tya 								; shift in A
.9172	7a		ply				ply 								; restore Y and exit
.9173	60		rts				rts
.9174					CalculateSign:
.9174	b5 50		lda $50,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.9176	16 50		asl $50,x			asl 	NSStatus,x 					; shift result left
.9178	55 51		eor $51,x			eor 	NSStatus+1,x
.917a	0a		asl a				asl 	a 							; shift bit 7 into carry
.917b	76 50		ror $50,x			ror 	NSStatus,x 					; shift right into status byte.
.917d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/scompare.asm

.917e					CompareStrings:
.917e	b5 50		lda $50,x			lda 	NSStatus,x 					; check both are strings
.9180	35 51		and $51,x			and 	NSStatus+1,x
.9182	29 10		and #$10			and 	#NSBIsString
.9184	f0 28		beq $91ae			beq 	_CSTypeError
.9186	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy string addresses to zTemp0/1
.9188	85 36		sta $36				sta 	zTemp0
.918a	b5 60		lda $60,x			lda 	NSMantissa1,x
.918c	85 37		sta $37				sta 	zTemp0+1
.918e	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9190	85 38		sta $38				sta 	zTemp1
.9192	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9194	85 39		sta $39				sta 	zTemp1+1
.9196	5a		phy				phy 								; save Y so we can access strings
.9197	a0 ff		ldy #$ff			ldy 	#$FF 						; -1 for pre increment.
.9199					_CSLoop:
.9199	c8		iny				iny
.919a	b1 36		lda ($36),y			lda 	(zTemp0),y 					; check if they are the same
.919c	d1 38		cmp ($38),y			cmp 	(zTemp1),y
.919e	d0 06		bne $91a6			bne 	_CSDifferent
.91a0	c9 00		cmp #$00			cmp 	#0 							; reached end ?
.91a2	d0 f5		bne $9199			bne 	_CSLoop 					; still comparing
.91a4					_CSExit:
.91a4	7a		ply				ply 								; reached end, return zero in A from EOS
.91a5	60		rts				rts
.91a6					_CSDifferent:
.91a6	a9 ff		lda #$ff			lda 	#255 						; if < return $FF
.91a8	90 fa		bcc $91a4			bcc		_CSExit
.91aa	a9 01		lda #$01			lda 	#1 							; otherwise return 1.
.91ac	80 f6		bra $91a4			bra 	_CSExit
.91ae					_CSTypeError:
.91ae	4c a3 9f	jmp $9fa3			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/shifts.asm

.91b1					ShiftLeft:
.91b1	38		sec				sec 								; common code, carry determines which way.
.91b2	80 01		bra $91b5			bra 	ShiftMain
.91b4					ShiftRight:
.91b4	18		clc				clc
.91b5					ShiftMain:
.91b5	fa		plx				plx 								; restore X
.91b6	08		php				php 								; save direction
.91b7	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.91b9	15 51		ora $51,x			ora 	NSStatus+1,x
.91bb	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91bc	0a		asl a				asl 	a
.91bd	10 05		bpl $91c4			bpl 	_NotRef
.91bf	48		pha				pha
.91c0	20 bb 96	jsr $96bb			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91c3	68		pla				pla
.91c4					_NotRef:
.91c4	0a		asl a				asl 	a
.91c5	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.91c7	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91c9	15 79		ora $79,x			ora 	NSExponent+1,x
.91cb	f0 03		beq $91d0			beq 	_IntegerCode 				; if clear, then we have two integers
.91cd	4c a3 9f	jmp $9fa3			jmp 	TypeError 					; anything else, type mismatch.
.91d0					_IntegerCode:
.91d0	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; check number < 32
.91d2	29 e0		and #$e0			and 	#$E0
.91d4	15 61		ora $61,x			ora 	NSMantissa1+1,x
.91d6	15 69		ora $69,x			ora 	NSMantissa2+1,x
.91d8	15 71		ora $71,x			ora 	NSMantissa3+1,x
.91da	d0 12		bne $91ee			bne 	_SMExit0 					; if >= 32 it will always return zero.
.91dc					_SMLoop:
.91dc	d6 59		dec $59,x			dec 	NSMantissa0+1,x 			; predecrement, could do << 0
.91de	30 11		bmi $91f1			bmi 	_SMExit 					; exit if done.
.91e0	28		plp				plp 								; restore direction setting
.91e1	08		php				php
.91e2	90 05		bcc $91e9			bcc 	_SMRight
.91e4	20 2a 9e	jsr $9e2a			jsr 	NSMShiftLeft 				; shift left if CS
.91e7	80 f3		bra $91dc			bra 	_SMLoop
.91e9					_SMRight:
.91e9	20 34 9e	jsr $9e34			jsr 	NSMShiftRight 				; shift right if CC
.91ec	80 ee		bra $91dc			bra 	_SMLoop
.91ee					_SMExit0:
.91ee	20 1b 9e	jsr $9e1b			jsr 	NSMSetZero 					; return zero.
.91f1					_SMExit:
.91f1	28		plp				plp 								; throw direction
.91f2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/simple.asm

.91f3					AddTopTwoStack:
.91f3	18		clc				clc
.91f4	b5 58		lda $58,x			lda		NSMantissa0,x
.91f6	75 59		adc $59,x			adc 		NSMantissa0+1,x
.91f8	95 58		sta $58,x			sta 	NSMantissa0,x
.91fa	b5 60		lda $60,x			lda		NSMantissa1,x
.91fc	75 61		adc $61,x			adc 		NSMantissa1+1,x
.91fe	95 60		sta $60,x			sta 	NSMantissa1,x
.9200	b5 68		lda $68,x			lda		NSMantissa2,x
.9202	75 69		adc $69,x			adc 		NSMantissa2+1,x
.9204	95 68		sta $68,x			sta 	NSMantissa2,x
.9206	b5 70		lda $70,x			lda		NSMantissa3,x
.9208	75 71		adc $71,x			adc 		NSMantissa3+1,x
.920a	95 70		sta $70,x			sta 	NSMantissa3,x
.920c	60		rts				rts
.920d					SubTopTwoStack:
.920d	38		sec				sec
.920e	b5 58		lda $58,x			lda		NSMantissa0,x
.9210	f5 59		sbc $59,x			sbc 		NSMantissa0+1,x
.9212	95 58		sta $58,x			sta 	NSMantissa0,x
.9214	b5 60		lda $60,x			lda		NSMantissa1,x
.9216	f5 61		sbc $61,x			sbc 		NSMantissa1+1,x
.9218	95 60		sta $60,x			sta 	NSMantissa1,x
.921a	b5 68		lda $68,x			lda		NSMantissa2,x
.921c	f5 69		sbc $69,x			sbc 		NSMantissa2+1,x
.921e	95 68		sta $68,x			sta 	NSMantissa2,x
.9220	b5 70		lda $70,x			lda		NSMantissa3,x
.9222	f5 71		sbc $71,x			sbc 		NSMantissa3+1,x
.9224	95 70		sta $70,x			sta 	NSMantissa3,x
.9226	60		rts				rts
.9227					AddInteger:
.9227	fa		plx				plx
.9228	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.922a	15 51		ora $51,x			ora 	NSStatus+1,x
.922c	0a		asl a				asl 	a 							; shift reference bit into sign bit
.922d	0a		asl a				asl 	a
.922e	10 05		bpl $9235			bpl 	_NotRef
.9230	48		pha				pha
.9231	20 bb 96	jsr $96bb			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9234	68		pla				pla
.9235					_NotRef:
.9235	0a		asl a				asl 	a 							; put MSB of type into A:7
.9236	30 09		bmi $9241			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9238	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.923a	15 79		ora $79,x			ora 	NSExponent+1,x
.923c	f0 06		beq $9244			beq 	_IntegerCode 				; if clear, then we have two integers
.923e	4c 3a 94	jmp $943a			jmp 	FloatingPointAdd 							; otherwise at least one float.
.9241					_StringData:
.9241	4c 00 90	jmp $9000			jmp 	StringConcat							; at least one string - don't know both are strings.
.9244					_IntegerCode:
.9244					AddCode:
.9244	b5 50		lda $50,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.9246	55 51		eor $51,x			eor 	NSStatus+1,x
.9248	10 a9		bpl $91f3			bpl 	AddTopTwoStack
.924a	20 0d 92	jsr $920d			jsr 	SubTopTwoStack 				; do a physical subtraction
.924d	34 70		bit $70,x			bit 	NSMantissa3,x 				; result is +ve, okay
.924f	10 07		bpl $9258			bpl 	_AddExit
.9251	b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign is that of 2nd value
.9253	95 50		sta $50,x			sta 	NSStatus,x
.9255	20 e4 9d	jsr $9de4			jsr 	NSMNegateMantissa 			; negate the mantissa and exit
.9258					_AddExit:
.9258	20 3d 9e	jsr $9e3d			jsr 	NSMIsZero 					; check for -0
.925b	d0 02		bne $925f			bne 	_AddNonZero
.925d	74 50		stz $50,x			stz 	NSStatus,x
.925f					_AddNonZero:
.925f	60		rts				rts
.9260					SubInteger:
.9260	fa		plx				plx
.9261	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9263	15 51		ora $51,x			ora 	NSStatus+1,x
.9265	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9266	0a		asl a				asl 	a
.9267	10 05		bpl $926e			bpl 	_NotRef
.9269	48		pha				pha
.926a	20 bb 96	jsr $96bb			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.926d	68		pla				pla
.926e					_NotRef:
.926e	0a		asl a				asl 	a 							; put MSB of type into A:7
.926f	30 09		bmi $927a			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9271	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9273	15 79		ora $79,x			ora 	NSExponent+1,x
.9275	f0 06		beq $927d			beq 	_IntegerCode 				; if clear, then we have two integers
.9277	4c 3f 94	jmp $943f			jmp 	FloatingPointSub 							; otherwise at least one float.
.927a					_StringData:
.927a	4c ad 9f	jmp $9fad			jmp 	NotDoneError							; at least one string - don't know both are strings.
.927d					_IntegerCode:
.927d	b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate the second value.
.927f	49 80		eor #$80			eor 	#$80
.9281	95 51		sta $51,x			sta 	NSStatus+1,x
.9283	80 bf		bra $9244			bra 	AddCode 					; and do the same code as add.
.9285					AndInteger:
.9285	fa		plx				plx
.9286	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9288	15 51		ora $51,x			ora 	NSStatus+1,x
.928a	0a		asl a				asl 	a 							; shift reference bit into sign bit
.928b	0a		asl a				asl 	a
.928c	10 05		bpl $9293			bpl 	_NotRef
.928e	48		pha				pha
.928f	20 bb 96	jsr $96bb			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9292	68		pla				pla
.9293					_NotRef:
.9293	0a		asl a				asl 	a
.9294	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9296	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9298	15 79		ora $79,x			ora 	NSExponent+1,x
.929a	f0 03		beq $929f			beq 	_IntegerCode 				; if clear, then we have two integers
.929c	4c a3 9f	jmp $9fa3			jmp 	TypeError 					; anything else, type mismatch.
.929f					_IntegerCode:
.929f	b5 58		lda $58,x			lda		NSMantissa0,x
.92a1	35 59		and $59,x			and 		NSMantissa0+1,x
.92a3	95 58		sta $58,x			sta 	NSMantissa0,x
.92a5	b5 60		lda $60,x			lda		NSMantissa1,x
.92a7	35 61		and $61,x			and 		NSMantissa1+1,x
.92a9	95 60		sta $60,x			sta 	NSMantissa1,x
.92ab	b5 68		lda $68,x			lda		NSMantissa2,x
.92ad	35 69		and $69,x			and 		NSMantissa2+1,x
.92af	95 68		sta $68,x			sta 	NSMantissa2,x
.92b1	b5 70		lda $70,x			lda		NSMantissa3,x
.92b3	35 71		and $71,x			and 		NSMantissa3+1,x
.92b5	95 70		sta $70,x			sta 	NSMantissa3,x
.92b7	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.92b9	60		rts				rts
.92ba					OraInteger:
.92ba	fa		plx				plx
.92bb	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.92bd	15 51		ora $51,x			ora 	NSStatus+1,x
.92bf	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92c0	0a		asl a				asl 	a
.92c1	10 05		bpl $92c8			bpl 	_NotRef
.92c3	48		pha				pha
.92c4	20 bb 96	jsr $96bb			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92c7	68		pla				pla
.92c8					_NotRef:
.92c8	0a		asl a				asl 	a
.92c9	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.92cb	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92cd	15 79		ora $79,x			ora 	NSExponent+1,x
.92cf	f0 03		beq $92d4			beq 	_IntegerCode 				; if clear, then we have two integers
.92d1	4c a3 9f	jmp $9fa3			jmp 	TypeError 					; anything else, type mismatch.
.92d4					_IntegerCode:
.92d4	b5 58		lda $58,x			lda		NSMantissa0,x
.92d6	15 59		ora $59,x			ora 		NSMantissa0+1,x
.92d8	95 58		sta $58,x			sta 	NSMantissa0,x
.92da	b5 60		lda $60,x			lda		NSMantissa1,x
.92dc	15 61		ora $61,x			ora 		NSMantissa1+1,x
.92de	95 60		sta $60,x			sta 	NSMantissa1,x
.92e0	b5 68		lda $68,x			lda		NSMantissa2,x
.92e2	15 69		ora $69,x			ora 		NSMantissa2+1,x
.92e4	95 68		sta $68,x			sta 	NSMantissa2,x
.92e6	b5 70		lda $70,x			lda		NSMantissa3,x
.92e8	15 71		ora $71,x			ora 		NSMantissa3+1,x
.92ea	95 70		sta $70,x			sta 	NSMantissa3,x
.92ec	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.92ee	60		rts				rts
.92ef					EorInteger:
.92ef	fa		plx				plx
.92f0	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.92f2	15 51		ora $51,x			ora 	NSStatus+1,x
.92f4	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92f5	0a		asl a				asl 	a
.92f6	10 05		bpl $92fd			bpl 	_NotRef
.92f8	48		pha				pha
.92f9	20 bb 96	jsr $96bb			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92fc	68		pla				pla
.92fd					_NotRef:
.92fd	0a		asl a				asl 	a
.92fe	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9300	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9302	15 79		ora $79,x			ora 	NSExponent+1,x
.9304	f0 03		beq $9309			beq 	_IntegerCode 				; if clear, then we have two integers
.9306	4c a3 9f	jmp $9fa3			jmp 	TypeError 					; anything else, type mismatch.
.9309					_IntegerCode:
.9309	b5 58		lda $58,x			lda		NSMantissa0,x
.930b	55 59		eor $59,x			eor 		NSMantissa0+1,x
.930d	95 58		sta $58,x			sta 	NSMantissa0,x
.930f	b5 60		lda $60,x			lda		NSMantissa1,x
.9311	55 61		eor $61,x			eor 		NSMantissa1+1,x
.9313	95 60		sta $60,x			sta 	NSMantissa1,x
.9315	b5 68		lda $68,x			lda		NSMantissa2,x
.9317	55 69		eor $69,x			eor 		NSMantissa2+1,x
.9319	95 68		sta $68,x			sta 	NSMantissa2,x
.931b	b5 70		lda $70,x			lda		NSMantissa3,x
.931d	55 71		eor $71,x			eor 		NSMantissa3+1,x
.931f	95 70		sta $70,x			sta 	NSMantissa3,x
.9321	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.9323	60		rts				rts
.9324					WordIndirect:
.9324	fa		plx				plx
.9325	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9327	15 51		ora $51,x			ora 	NSStatus+1,x
.9329	0a		asl a				asl 	a 							; shift reference bit into sign bit
.932a	0a		asl a				asl 	a
.932b	10 05		bpl $9332			bpl 	_NotRef
.932d	48		pha				pha
.932e	20 bb 96	jsr $96bb			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9331	68		pla				pla
.9332					_NotRef:
.9332	0a		asl a				asl 	a
.9333	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9335	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9337	15 79		ora $79,x			ora 	NSExponent+1,x
.9339	f0 03		beq $933e			beq 	_IntegerCode 				; if clear, then we have two integers
.933b	4c a3 9f	jmp $9fa3			jmp 	TypeError 					; anything else, type mismatch.
.933e					_IntegerCode:
.933e	20 44 92	jsr $9244			jsr 	AddCode 					; add the two values
.9341	a9 22		lda #$22			lda 	#NSBIsReference+2 			; make a 2 byte reference
.9343	95 50		sta $50,x			sta 	NSStatus,x
.9345	60		rts				rts
.9346					ByteIndirect:
.9346	fa		plx				plx
.9347	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9349	15 51		ora $51,x			ora 	NSStatus+1,x
.934b	0a		asl a				asl 	a 							; shift reference bit into sign bit
.934c	0a		asl a				asl 	a
.934d	10 05		bpl $9354			bpl 	_NotRef
.934f	48		pha				pha
.9350	20 bb 96	jsr $96bb			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9353	68		pla				pla
.9354					_NotRef:
.9354	0a		asl a				asl 	a
.9355	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9357	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9359	15 79		ora $79,x			ora 	NSExponent+1,x
.935b	f0 03		beq $9360			beq 	_IntegerCode 				; if clear, then we have two integers
.935d	4c a3 9f	jmp $9fa3			jmp 	TypeError 					; anything else, type mismatch.
.9360					_IntegerCode:
.9360	20 44 92	jsr $9244			jsr 	AddCode 					; add the two values
.9363	a9 21		lda #$21			lda 	#NSBIsReference+1 			; make a 1 byte reference
.9365	95 50		sta $50,x			sta 	NSStatus,x
.9367	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/tostring.asm

.9368					ConvertInt16:
.9368	85 58		sta $58				sta 	NSMantissa0 				; set up as 32 bit conversion
.936a	86 60		stx $60				stx 	NSMantissa1
.936c	64 68		stz $68				stz 	NSMantissa2
.936e	64 70		stz $70				stz 	NSMantissa3
.9370	64 50		stz $50				stz 	NSStatus 					; positive integer
.9372	a2 00		ldx #$00			ldx 	#0 							; stack level
.9374	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.9376	80 00		bra $9378			bra 	ConvertInt32
.9378					ConvertInt32:
.9378	5a		phy				phy
.9379	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.937b	24 50		bit $50				bit 	NSStatus 					; output a - if not negative.
.937d	10 08		bpl $9387			bpl 	_CI32NotNeg
.937f	48		pha				pha
.9380	a9 2d		lda #$2d			lda 	#'-'
.9382	99 27 06	sta $0627,y			sta 	NumberBuffer,y
.9385	c8		iny				iny
.9386	68		pla				pla
.9387					_CI32NotNeg:
.9387	20 95 93	jsr $9395			jsr 	_CI32DivideConvert 			; recursive conversion
.938a	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.938c	99 27 06	sta $0627,y			sta 	NumberBuffer,y
.938f	7a		ply				ply
.9390	a2 06		ldx #$06			ldx 	#NumberBuffer >> 8 			; return address in XA
.9392	a9 27		lda #$27			lda 	#NumberBuffer & $FF
.9394	60		rts				rts
.9395					_CI32DivideConvert:
.9395	e8		inx				inx 								; write to next slot up
.9396	20 1d 9e	jsr $9e1d			jsr 	NSMSetByte 		 			; write the base out.
.9399	ca		dex				dex
.939a	20 c3 90	jsr $90c3			jsr 	Int32Divide 				; divide
.939d	b5 58		lda $58,x			lda 	NSMantissa0,x 				; save remainder
.939f	48		pha				pha
.93a0	20 80 90	jsr $9080			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.93a3	20 3d 9e	jsr $9e3d			jsr 	NSMIsZero 					; is it zero ?
.93a6	f0 05		beq $93ad			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.93a8	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.93aa	20 95 93	jsr $9395			jsr 	_CI32DivideConvert 			; and recusrively call.
.93ad					_CI32NoRecurse:
.93ad	68		pla				pla 								; remainder
.93ae	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.93b0	90 02		bcc $93b4			bcc 	_CI32NotHex
.93b2	69 26		adc #$26			adc 	#6+32
.93b4					_CI32NotHex:
.93b4	69 30		adc #$30			adc 	#48
.93b6	99 27 06	sta $0627,y			sta 	NumberBuffer,y 				; write out and exit
.93b9	c8		iny				iny
.93ba	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/expression.asm


;******  Processing file: ./common/expressions/../generated/precedence.dat

.93bb					PrecedenceLevel:
>93bb	04					.byte	 4	; $00 <<
>93bc	02					.byte	 2	; $01 <=
>93bd	02					.byte	 2	; $02 <>
>93be	00					.byte	 0	; $03 !!3
>93bf	00					.byte	 0	; $04 ><
>93c0	02					.byte	 2	; $05 >=
>93c1	04					.byte	 4	; $06 >>
>93c2	00					.byte	 0	; $07 !!7
>93c3	00					.byte	 0	; $08 !!8
>93c4	00					.byte	 0	; $09 !!9
>93c5	00					.byte	 0	; $0a !!10
>93c6	00					.byte	 0	; $0b !!11
>93c7	00					.byte	 0	; $0c !!12
>93c8	00					.byte	 0	; $0d !!13
>93c9	00					.byte	 0	; $0e !!14
>93ca	00					.byte	 0	; $0f !!15
>93cb	00					.byte	 0	; $10 @
>93cc	00					.byte	 0	; $11 !!17
>93cd	00					.byte	 0	; $12 !!18
>93ce	00					.byte	 0	; $13 [
>93cf	04					.byte	 4	; $14 \
>93d0	00					.byte	 0	; $15 ]
>93d1	01					.byte	 1	; $16 ^
>93d2	00					.byte	 0	; $17 _
>93d3	00					.byte	 0	; $18 `
>93d4	00					.byte	 0	; $19 !!25
>93d5	00					.byte	 0	; $1a !!26
>93d6	00					.byte	 0	; $1b {
>93d7	01					.byte	 1	; $1c |
>93d8	00					.byte	 0	; $1d }
>93d9	00					.byte	 0	; $1e ~
>93da	00					.byte	 0	; $1f [7m<7F>[m
>93db	00					.byte	 0	; $20
>93dc	05					.byte	 5	; $21 !
>93dd	00					.byte	 0	; $22 "
>93de	00					.byte	 0	; $23 #
>93df	05					.byte	 5	; $24 $
>93e0	04					.byte	 4	; $25 %
>93e1	01					.byte	 1	; $26 &
>93e2	00					.byte	 0	; $27 '
>93e3	00					.byte	 0	; $28 (
>93e4	00					.byte	 0	; $29 )
>93e5	04					.byte	 4	; $2a *
>93e6	03					.byte	 3	; $2b +
>93e7	00					.byte	 0	; $2c ,
>93e8	03					.byte	 3	; $2d -
>93e9	00					.byte	 0	; $2e .
>93ea	04					.byte	 4	; $2f /
>93eb	00					.byte	 0	; $30 0
>93ec	00					.byte	 0	; $31 1
>93ed	00					.byte	 0	; $32 2
>93ee	00					.byte	 0	; $33 3
>93ef	00					.byte	 0	; $34 4
>93f0	00					.byte	 0	; $35 5
>93f1	00					.byte	 0	; $36 6
>93f2	00					.byte	 0	; $37 7
>93f3	00					.byte	 0	; $38 8
>93f4	00					.byte	 0	; $39 9
>93f5	00					.byte	 0	; $3a :
>93f6	00					.byte	 0	; $3b ;
>93f7	02					.byte	 2	; $3c <
>93f8	02					.byte	 2	; $3d =
>93f9	02					.byte	 2	; $3e >
>93fa	05					.byte	 5	; $3f ?

;******  Return to file: ./common/expressions/expression.asm

.93fb					EvaluateExpressionAt0:
.93fb	a2 00		ldx #$00			ldx 	#0 							; bottom stack level
.93fd					EvaluateExpression:
.93fd	a9 00		lda #$00			lda 	#0 							; lowest precedence level
.93ff					EvaluateExpressionAtPrecedence:
.93ff	48		pha				pha 								; save precedence level
.9400	20 47 98	jsr $9847			jsr 	EvaluateTerm 				; evaluate term into level X.
.9403	68		pla				pla 								; restore precedence level.
.9404					_EXPRLoop:
.9404	85 36		sta $36				sta 	zTemp0 						; save current precedence level.
.9406	b1 30		lda ($30),y			lda 	(codePtr),y
.9408	c9 40		cmp #$40			cmp		#$40 						; if >= $40 cannot be an operator
.940a	b0 25		bcs $9431			bcs 	_EXPRExit
.940c	da		phx				phx 								; read the operator precedence
.940d	aa		tax				tax
.940e	bd bb 93	lda $93bb,x			lda 	PrecedenceLevel,x
.9411	fa		plx				plx
.9412	c9 00		cmp #$00			cmp 	#0							; if zero exit (not an operator)
.9414	f0 1b		beq $9431			beq 	_EXPRExit
.9416	85 37		sta $37				sta 	zTemp0+1 					; save operator precedence level.
.9418	a5 36		lda $36				lda 	zTemp0 						; compare current precedence vs. operator precedence
.941a	c5 37		cmp $37				cmp 	zTemp0+1
.941c	b0 13		bcs $9431			bcs		_EXPRExit 					; if current >= operator exit
.941e	48		pha				pha 								; save current precedence.
.941f	b1 30		lda ($30),y			lda 	(codePtr),y
.9421	c8		iny				iny
.9422	48		pha				pha
.9423	a5 37		lda $37				lda 	zTemp0+1 					; get operator precedence level
.9425	e8		inx				inx 								; work out the right hand side.
.9426	20 ff 93	jsr $93ff			jsr 	EvaluateExpressionAtPrecedence
.9429	ca		dex				dex
.942a	68		pla				pla 								; get operator, call the code.
.942b	20 34 94	jsr $9434			jsr 	_EXPRCaller
.942e	68		pla				pla 								; restore precedence level
.942f	80 d3		bra $9404			bra 	_EXPRLoop 					; and go round.
.9431					_EXPRExit:
.9431	a5 36		lda $36				lda 	zTemp0 						; A = current precedence level.
.9433	60		rts				rts
.9434					_EXPRCaller:
.9434	da		phx				phx 								; save on stack, first thing is to restore it
.9435	0a		asl a				asl 	a 							; double so can use vectors into X
.9436	aa		tax				tax
.9437	7c 10 8c	jmp ($8c10,x)			jmp 	(VectorSetPunc,x) 			; and go to the code.

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/addsub.asm

.943a					FloatingPointAdd:
.943a	20 b0 95	jsr $95b0			jsr 	FloatPrepare 				; prepare for floats
.943d	80 09		bra $9448			bra 	FloatAdd
.943f					FloatingPointSub:
.943f	20 b0 95	jsr $95b0			jsr 	FloatPrepare 				; prepare for floats
.9442					FloatSubtract:
.9442	b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate FPB
.9444	49 80		eor #$80			eor 	#$80
.9446	95 51		sta $51,x			sta 	NSStatus+1,x				; and fall through.
.9448					FloatAdd:
.9448	48		pha				pha
.9449	5a		phy				phy
.944a	20 bf 95	jsr $95bf			jsr 	NSNormalise 				; normalise S[X]
.944d	f0 51		beq $94a0			beq 	_FAReturn1
.944f	e8		inx				inx 								; normalise S[X+1]
.9450	20 bf 95	jsr $95bf			jsr 	NSNormalise
.9453	ca		dex				dex
.9454	c9 00		cmp #$00			cmp 	#0
.9456	f0 60		beq $94b8			beq 	_FAExit 					; if so, just return A
.9458	b5 78		lda $78,x			lda 	NSExponent,x 				; are the exponents the same ?
.945a	d5 79		cmp $79,x			cmp 	NSExponent+1,x
.945c	f0 18		beq $9476			beq 	_FAExponentsEqual
.945e	b5 78		lda $78,x			lda 	NSExponent,x 				; work out the larger exponent
.9460	a8		tay				tay
.9461	38		sec				sec 								; do a signed comparison of the exponents.
.9462	f5 79		sbc $79,x			sbc 	NSExponent+1,x
.9464	50 02		bvc $9468			bvc 	_FANoSignedChange
.9466	49 80		eor #$80			eor 	#$80
.9468					_FANoSignedChange:
.9468	29 80		and #$80			and 	#$80
.946a	10 02		bpl $946e			bpl 	_FAHaveMax
.946c	b4 79		ldy $79,x			ldy 	NSExponent+1,x
.946e					_FAHaveMax:
.946e	20 bb 94	jsr $94bb			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.9471	e8		inx				inx
.9472	20 bb 94	jsr $94bb			jsr 	_FAShiftToExponent
.9475	ca		dex				dex
.9476					_FAExponentsEqual:
.9476	b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs the same
.9478	55 51		eor $51,x			eor 	NSStatus+1,x
.947a	30 0e		bmi $948a			bmi 	_FADifferentSigns
.947c	20 f3 91	jsr $91f3			jsr 	AddTopTwoStack 				; do the add of the mantissae
.947f	b5 70		lda $70,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.9481	10 35		bpl $94b8			bpl 	_FAExit 					; if no, we are done.
.9483	20 34 9e	jsr $9e34			jsr 	NSMShiftRight 				; shift A right, renormalising it.
.9486	f6 78		inc $78,x			inc 	NSExponent,x 				; bump the exponent and exit
.9488	80 2e		bra $94b8			bra 	_FAExit
.948a					_FADifferentSigns:
.948a	20 0d 92	jsr $920d			jsr 	SubTopTwoStack 				; subtract mantissa B from A
.948d	b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the result negative ?
.948f	10 06		bpl $9497			bpl 	_FACheckZero 				; if no, check for -0
.9491	20 dd 9d	jsr $9ddd			jsr 	NSMNegate 					; netate result
.9494	20 e4 9d	jsr $9de4			jsr 	NSMNegateMantissa 			; negate (2'c) the mantissa
.9497					_FACheckZero:
.9497	20 3d 9e	jsr $9e3d			jsr 	NSMIsZero	 				; check for -0
.949a	d0 1c		bne $94b8			bne 	_FAExit
.949c	74 50		stz $50,x			stz 	NSStatus,x
.949e	80 18		bra $94b8			bra 	_FAExit
.94a0					_FAReturn1:
.94a0	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.94a2	95 58		sta $58,x			sta 	NSMantissa0,x
.94a4	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.94a6	95 60		sta $60,x			sta 	NSMantissa1,x
.94a8	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.94aa	95 68		sta $68,x			sta 	NSMantissa2,x
.94ac	b5 71		lda $71,x			lda 	NSMantissa3+1,x
.94ae	95 70		sta $70,x			sta 	NSMantissa3,x
.94b0	b5 79		lda $79,x			lda 	NSExponent+1,x
.94b2	95 78		sta $78,x			sta 	NSExponent,x
.94b4	b5 51		lda $51,x			lda 	NSStatus+1,x
.94b6	95 50		sta $50,x			sta 	NSStatus,x
.94b8					_FAExit:
.94b8	7a		ply				ply
.94b9	68		pla				pla
.94ba	60		rts				rts
.94bb					_FAShiftToExponent:
.94bb					_FAShiftToExponent2:
.94bb	98		tya				tya 								; compare Y to exponent
.94bc	d5 78		cmp $78,x			cmp 	NSExponent,x 				; reached the exponent required ?
.94be	f0 07		beq $94c7			beq 	_FASEExit 					; exit if so.
.94c0	20 34 9e	jsr $9e34			jsr 	NSMShiftRight	 			; shift the mantissa right
.94c3	f6 78		inc $78,x			inc 	NSExponent,x 				; increment exponent
.94c5	80 f4		bra $94bb			bra 	_FAShiftToExponent2
.94c7					_FASEExit:
.94c7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/compare.asm

.94c8					CompareFloat:
.94c8	20 42 94	jsr $9442			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.94cb	b5 60		lda $60,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.94cd	29 f8		and #$f8			and 	#$F8
.94cf	15 68		ora $68,x			ora 	NSMantissa2,x
.94d1	15 70		ora $70,x			ora 	NSMantissa3,x
.94d3	f0 08		beq $94dd			beq 	_FCExit 					; zero, so approximately identical
.94d5	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.94d7	34 50		bit $50,x			bit 	NSStatus,x
.94d9	10 02		bpl $94dd			bpl 	_FCExit
.94db					_FCNegative:
.94db	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.94dd					_FCExit:
.94dd	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/divide.asm

.94de					FDivideCommand:
.94de	fa		plx				plx	 								; restore stack position
.94df	20 b0 95	jsr $95b0			jsr 	FloatPrepare 				; prepare for floats
.94e2					FloatDivide:
.94e2	48		pha				pha
.94e3	e8		inx				inx
.94e4	20 bf 95	jsr $95bf			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.94e7	ca		dex				dex
.94e8	c9 00		cmp #$00			cmp 	#0
.94ea	f0 1d		beq $9509			beq 	_FDZero
.94ec	20 bf 95	jsr $95bf			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.94ef	f0 16		beq $9507			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.94f1	20 e4 90	jsr $90e4			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.94f4	20 80 90	jsr $9080			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.94f7	20 bf 95	jsr $95bf			jsr		NSNormalise 				; renormalise
.94fa	20 74 91	jsr $9174			jsr 	CalculateSign 				; calculate result sign
.94fd	b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent
.94ff	38		sec				sec
.9500	f5 79		sbc $79,x			sbc 	NSExponent+1,x
.9502	38		sec				sec
.9503	e9 1e		sbc #$1e			sbc 	#30
.9505	95 78		sta $78,x			sta 	NSExponent,x
.9507					_FDExit:
.9507	68		pla				pla
.9508	60		rts				rts
.9509					_FDZero:
.9509	a9 03		lda #$03		lda	#3
.950b	4c f9 8e	jmp $8ef9		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/fractional.asm

.950e					FloatFractionalPart:
.950e	5a		phy				phy
.950f	b5 50		lda $50,x			lda 	NSStatus,x 					; take absolute value
.9511	29 7f		and #$7f			and 	#$7F
.9513	95 50		sta $50,x			sta 	NSStatus,x
.9515	20 bf 95	jsr $95bf			jsr 	NSNormalise
.9518	b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.951a	38		sec				sec
.951b	e9 e0		sbc #$e0			sbc 	#$E0
.951d	90 29		bcc $9548			bcc 	_FFPExit 					; already fractional
.951f	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.9521	b0 22		bcs $9545			bcs 	_FFPZero
.9523	a8		tay				tay 								; put count to do in Y
.9524	b5 70		lda $70,x			lda 	NSMantissa3,x 				; do each in turn.
.9526	20 4a 95	jsr $954a			jsr 	_FFPPartial
.9529	95 70		sta $70,x			sta 	NSMantissa3,x
.952b	b5 68		lda $68,x			lda 	NSMantissa2,x
.952d	20 4a 95	jsr $954a			jsr 	_FFPPartial
.9530	95 68		sta $68,x			sta 	NSMantissa2,x
.9532	b5 60		lda $60,x			lda 	NSMantissa1,x
.9534	20 4a 95	jsr $954a			jsr 	_FFPPartial
.9537	95 60		sta $60,x			sta 	NSMantissa1,x
.9539	b5 58		lda $58,x			lda 	NSMantissa0,x
.953b	20 4a 95	jsr $954a			jsr 	_FFPPartial
.953e	95 58		sta $58,x			sta 	NSMantissa0,x
.9540	20 3d 9e	jsr $9e3d			jsr 	NSMIsZero 					; zeroed check.
.9543	d0 03		bne $9548			bne 	_FFPExit
.9545					_FFPZero:
.9545	20 1b 9e	jsr $9e1b			jsr 	NSMSetZero
.9548					_FFPExit:
.9548	7a		ply				ply
.9549	60		rts				rts
.954a					_FFPPartial:
.954a	c0 00		cpy #$00			cpy 	#0 							; no more to do
.954c	f0 17		beq $9565			beq 	_FFFPPExit
.954e	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.9550	b0 0c		bcs $955e			bcs 	_FFFPPWholeByte
.9552	5a		phy				phy
.9553					_FFFPPLeft:
.9553	0a		asl a				asl 	a
.9554	88		dey				dey
.9555	d0 fc		bne $9553			bne 	_FFFPPLeft
.9557	7a		ply				ply
.9558					_FFFPPRight:
.9558	4a		lsr a				lsr 	a
.9559	88		dey				dey
.955a	d0 fc		bne $9558			bne 	_FFFPPRight
.955c	80 07		bra $9565			bra 	_FFFPPExit
.955e					_FFFPPWholeByte:
.955e	98		tya				tya 								; subtract 8 from count
.955f	38		sec				sec
.9560	e9 08		sbc #$08			sbc 	#8
.9562	a8		tay				tay
.9563	a9 00		lda #$00			lda 	#0 							; and clear all
.9565					_FFFPPExit:
.9565	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/integer.asm

.9566					FloatIntegerPart:
.9566	48		pha				pha
.9567	b5 78		lda $78,x			lda 	NSExponent,x 				; is it integer already ?
.9569	f0 1d		beq $9588			beq 	_FIPExit 					; if so do nothing
.956b	20 3d 9e	jsr $9e3d			jsr 	NSMIsZero 					; is it zero ?
.956e	f0 15		beq $9585			beq 	_FIPZero 					; if so return zero.
.9570	20 bf 95	jsr $95bf			jsr 	NSNormalise 				; normalise
.9573	f0 10		beq $9585			beq 	_FIPZero 					; normalised to zero, exit zero
.9575					_FIPShift:
.9575	b5 78		lda $78,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.9577	10 07		bpl $9580			bpl 	_FIPCheckZero
.9579	20 34 9e	jsr $9e34			jsr 	NSMShiftRight 				; shift mantissa right
.957c	f6 78		inc $78,x			inc 	NSExponent,x 				; bump exponent
.957e	80 f5		bra $9575			bra 	_FIPShift
.9580					_FIPCheckZero:
.9580	20 3d 9e	jsr $9e3d			jsr 	NSMIsZero 					; avoid -0 problem
.9583	d0 03		bne $9588			bne 	_FIPExit 					; set to zero if mantissa zero.
.9585					_FIPZero:
.9585	20 1b 9e	jsr $9e1b			jsr 	NSMSetZero
.9588					_FIPExit:
.9588	68		pla				pla
.9589	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/multiply.asm

.958a					FloatingPointMultiply:
.958a	20 b0 95	jsr $95b0			jsr 	FloatPrepare 				; prepare for floats
.958d					FloatMultiply:
.958d	48		pha				pha
.958e	20 bf 95	jsr $95bf			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.9591	f0 18		beq $95ab			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.9593	e8		inx				inx
.9594	20 bf 95	jsr $95bf			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.9597	ca		dex				dex
.9598	c9 00		cmp #$00			cmp 	#0
.959a	f0 0c		beq $95a8			beq 	_FDSetZero
.959c	20 36 91	jsr $9136			jsr 	MultiplyShort 				; calculate the result.
.959f	75 78		adc $78,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.95a1	18		clc				clc
.95a2	75 79		adc $79,x			adc 	NSExponent+1,x
.95a4	95 78		sta $78,x			sta 	NSExponent,x
.95a6	80 03		bra $95ab			bra 	_FDExit
.95a8					_FDSetZero:
.95a8	20 1b 9e	jsr $9e1b			jsr 	NSMSetZero 					; return 0
.95ab					_FDExit:
.95ab	20 bf 95	jsr $95bf			jsr 	NSNormalise 				; normalise the result
.95ae	68		pla				pla
.95af	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/utility.asm

.95b0					FloatPrepare:
.95b0	20 bb 96	jsr $96bb			jsr 	DereferenceTopTwo 			; dereference the top two values
.95b3	b5 50		lda $50,x			lda 	NSStatus,x 					; check ints/floats, either will do.
.95b5	15 51		ora $51,x			ora 	NSStatus+1,x
.95b7	29 10		and #$10			and 	#NSBIsString
.95b9	d0 01		bne $95bc			bne 	_FDType
.95bb	60		rts				rts
.95bc					_FDType:
.95bc	4c a3 9f	jmp $9fa3			jmp 	TypeError
.95bf					NSNormalise:
.95bf	b5 50		lda $50,x			lda 	NSStatus,x 					; make float, keep sign
.95c1	29 80		and #$80			and 	#$80
.95c3	09 08		ora #$08			ora 	#NSTFloat
.95c5	95 50		sta $50,x			sta 	NSStatus,x
.95c7	20 3d 9e	jsr $9e3d			jsr 	NSMIsZero 					; if zero exit
.95ca	d0 07		bne $95d3			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.95cc	16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.95ce	76 50		ror $50,x			ror 	NSStatus,x 					; (no -0)
.95d0	a9 00		lda #$00			lda 	#0 							; set Z flag
.95d2	60		rts				rts
.95d3					_NSNormaliseOptimise:
.95d3	b5 70		lda $70,x			lda 	NSMantissa3,x 				; upper byte zero ?
.95d5	d0 19		bne $95f0			bne 	_NSNormaliseLoop
.95d7	b5 68		lda $68,x			lda 	NSMantissa2,x 				; byte normalise
.95d9	30 15		bmi $95f0			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.95db	95 70		sta $70,x			sta 	NSMantissa3,x
.95dd	b5 60		lda $60,x			lda 	NSMantissa1,x
.95df	95 68		sta $68,x			sta 	NSMantissa2,x
.95e1	b5 58		lda $58,x			lda 	NSMantissa0,x
.95e3	95 60		sta $60,x			sta 	NSMantissa1,x
.95e5	74 58		stz $58,x			stz 	NSMantissa0,x
.95e7	b5 78		lda $78,x			lda 	NSExponent,x
.95e9	38		sec				sec
.95ea	e9 08		sbc #$08			sbc 	#8
.95ec	95 78		sta $78,x			sta 	NSExponent,x
.95ee	80 e3		bra $95d3			bra 	_NSNormaliseOptimise
.95f0					_NSNormaliseLoop:
.95f0	34 70		bit $70,x			bit 	NSMantissa3,x 				; bit 30 set ?
.95f2	70 07		bvs $95fb			bvs 	_NSNExit 					; exit if so with Z flag clear
.95f4	20 2a 9e	jsr $9e2a			jsr 	NSMShiftLeft 				; shift mantissa left
.95f7	d6 78		dec $78,x			dec 	NSExponent,x 				; adjust exponent
.95f9	80 f5		bra $95f0			bra 	_NSNormaliseLoop
.95fb					_NSNExit:
.95fb	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.95fd	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignnumber.asm

.95fe					AssignNumber:
.95fe	5a		phy				phy
.95ff	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy mantissa0/1 to zTemp0
.9601	85 36		sta $36				sta 	zTemp0
.9603	b5 60		lda $60,x			lda 	NSMantissa1,x
.9605	85 37		sta $37				sta 	zTemp0+1
.9607	b5 50		lda $50,x			lda 	NSStatus,x 					; clear reference bits
.9609	29 df		and #$df			and 	#(NSBIsReference ^ $FF)
.960b	95 50		sta $50,x			sta 	NSStatus,x
.960d	29 18		and #$18			and 	#NSBTypeMask				; assigning to a float ?
.960f	c9 08		cmp #$08			cmp 	#NSTFloat
.9611	f0 24		beq $9637			beq 	_ANFloat
.9613	b5 79		lda $79,x			lda		NSExponent+1,x 				; is it a float
.9615	f0 03		beq $961a			beq		_ANNotFloat
.9617	4c 9e 9f	jmp $9f9e			jmp 	RangeError					; if it is, report an error.
.961a					_ANNotFloat:
.961a	b5 50		lda $50,x			lda 	NSStatus,x 					; check if byte/word reference.
.961c	29 03		and #$03			and 	#3
.961e	d0 05		bne $9625			bne 	_ANByteWord
.9620	20 42 96	jsr $9642			jsr 	_ANCopy4PackSign 			; copy all 4 bytes and sign
.9623	80 1b		bra $9640			bra 	_ANExit
.9625					_ANByteWord:
.9625	48		pha				pha 								; save count
.9626	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; do byte
.9628	92 36		sta ($36)			sta 	(zTemp0)
.962a	68		pla				pla
.962b	c9 01		cmp #$01			cmp	 	#1
.962d	f0 11		beq $9640			beq 	_ANExit
.962f	b5 61		lda $61,x			lda 	NSMantissa1+1,x 			; do word
.9631	a0 01		ldy #$01			ldy 	#1
.9633	91 36		sta ($36),y			sta 	(zTemp0),y
.9635	80 09		bra $9640			bra 	_ANExit
.9637					_ANFloat:
.9637	20 42 96	jsr $9642			jsr 	_ANCopy4PackSign 			; write all 4 bytes and packed sign
.963a	b5 79		lda $79,x			lda 	NSExponent+1,x 				; copy exponent to slot 4
.963c	a0 04		ldy #$04			ldy 	#4
.963e	91 36		sta ($36),y			sta 	(zTemp0),y
.9640					_ANExit:
.9640	7a		ply				ply
.9641	60		rts				rts
.9642					_ANCopy4PackSign:
.9642	a0 03		ldy #$03			ldy 	#3
.9644	b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign bit into status
.9646	29 80		and #$80			and 	#$80 						; put into high bit of mantissa 3
.9648	15 71		ora $71,x			ora 	NSMantissa3+1,x
.964a	91 36		sta ($36),y			sta 	(zTemp0),y
.964c	88		dey				dey
.964d	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.964f	91 36		sta ($36),y			sta 	(zTemp0),y
.9651	88		dey				dey
.9652	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9654	91 36		sta ($36),y			sta 	(zTemp0),y
.9656	88		dey				dey
.9657	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9659	91 36		sta ($36),y			sta 	(zTemp0),y
.965b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignstring.asm

.965c					AssignString:
.965c	5a		phy				phy
.965d	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.965f	85 38		sta $38				sta 	zTemp1
.9661	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9663	85 39		sta $39				sta 	zTemp1+1
.9665	b5 58		lda $58,x			lda 	NSMantissa0,x
.9667	85 36		sta $36				sta 	zTemp0
.9669	b5 60		lda $60,x			lda 	NSMantissa1,x
.966b	85 37		sta $37				sta 	zTemp0+1
.966d	a0 01		ldy #$01			ldy 	#1 							; the high byte of the target address
.966f	b1 36		lda ($36),y			lda 	(zTemp0),y
.9671	f0 23		beq $9696			beq 	_ASNewStringRequired 		; if zero, a new string is required.
.9673	38		sec				sec 								; put Address-2 in zsTemp - this is the size/status/string record
.9674	b2 36		lda ($36)			lda 	(zTemp0) 					; of concreted strings
.9676	e9 02		sbc #$02			sbc 	#2
.9678	85 3c		sta $3c				sta 	zsTemp
.967a	a0 01		ldy #$01			ldy 	#1
.967c	b1 36		lda ($36),y			lda 	(zTemp0),y
.967e	e9 00		sbc #$00			sbc 	#0
.9680	85 3d		sta $3d				sta 	zsTemp+1
.9682	a0 ff		ldy #$ff			ldy 	#$FF 						; get length of new string
.9684					_ASGetLength:
.9684	c8		iny				iny
.9685	b1 38		lda ($38),y			lda 	(zTemp1),y
.9687	d0 fb		bne $9684			bne 	_ASGetLength
.9689	98		tya				tya 								; is this length <= current length
.968a	d2 3c		cmp ($3c)			cmp 	(zsTemp)
.968c	90 1e		bcc $96ac			bcc 	_ASCopyString
.968e	f0 1c		beq $96ac			beq 	_ASCopyString
.9690	a9 80		lda #$80			lda 	#$80 						; mark as unused.
.9692	a0 01		ldy #$01			ldy 	#1
.9694	91 3c		sta ($3c),y			sta 	(zsTemp),y
.9696					_ASNewStringRequired:
.9696	e8		inx				inx 								; concrete the new string.
.9697	20 1d a7	jsr $a71d			jsr 	StringConcrete				; (breaks zTemp1/2, not zTemp0 and zsTemp)
.969a	ca		dex				dex
.969b	18		clc				clc
.969c	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy that new address to the reference.
.969e	69 02		adc #$02			adc 	#2 							; add two to point at the data.
.96a0	92 36		sta ($36)			sta 	(zTemp0)
.96a2	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.96a4	69 00		adc #$00			adc 	#0
.96a6	a0 01		ldy #$01			ldy 	#1
.96a8	91 36		sta ($36),y			sta 	(zTemp0),y
.96aa	80 0d		bra $96b9			bra 	_ASExit
.96ac					_ASCopyString:
.96ac	a0 00		ldy #$00			ldy 	#0
.96ae					_ASCopyLoop:
.96ae	b1 38		lda ($38),y			lda 	(zTemp1),y
.96b0	c8		iny				iny
.96b1	c8		iny				iny
.96b2	91 3c		sta ($3c),y			sta 	(zsTemp),y
.96b4	88		dey				dey
.96b5	c9 00		cmp #$00			cmp 	#0
.96b7	d0 f5		bne $96ae			bne 	_ASCopyLoop
.96b9					_ASExit:
.96b9	7a		ply				ply
.96ba	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/dereference.asm

.96bb					DereferenceTopTwo:
.96bb	e8		inx				inx
.96bc	20 c0 96	jsr $96c0			jsr 	Dereference 				; deref x+1
.96bf	ca		dex				dex  								; falls through to deref x
.96c0					Dereference:
.96c0	b5 50		lda $50,x			lda 	NSStatus,x 					; get the status byte
.96c2	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.96c4	f0 48		beq $970e			beq 	_DRFExit 					; not a reference, so exit.
.96c6	5a		phy				phy
.96c7	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address to dereference into zTemp0
.96c9	85 36		sta $36				sta 	zTemp0
.96cb	b5 60		lda $60,x			lda 	NSMantissa1,x
.96cd	85 37		sta $37				sta 	zTemp0+1
.96cf	74 60		stz $60,x			stz 	NSMantissa1,x 				; clear second byte.
.96d1	b2 36		lda ($36)			lda 	(zTemp0) 					; do the first byte
.96d3	95 58		sta $58,x			sta 	NSMantissa0,x
.96d5	b5 50		lda $50,x			lda 	NSStatus,x 					; get status byte.
.96d7	29 18		and #$18			and 	#NSBTypeMask 				; what type is it ?
.96d9	c9 10		cmp #$10			cmp 	#NSTString 					; if string, dereference two
.96db	f0 0e		beq $96eb			beq 	_DRFDereferenceTwo
.96dd	c9 08		cmp #$08			cmp 	#NSTFloat 					; if float, do full dereference.
.96df	f0 2f		beq $9710			beq 	_DRFFull
.96e1	b5 50		lda $50,x			lda 	NSStatus,x 					; must be integer - how many bytes ?
.96e3	29 03		and #$03			and 	#3
.96e5	f0 29		beq $9710			beq 	_DRFFull 					; the whole word
.96e7	c9 01		cmp #$01			cmp 	#1 							; is it 10 (e.g. 2 bytes)
.96e9	f0 06		beq $96f1			beq		_DRFClear23 				; no, one byte, clear 2 & 3 and exit
.96eb					_DRFDereferenceTwo:
.96eb	a0 01		ldy #$01			ldy 	#1
.96ed	b1 36		lda ($36),y			lda 	(zTemp0),y
.96ef	95 60		sta $60,x			sta 	NSMantissa1,x
.96f1					_DRFClear23:
.96f1	74 68		stz $68,x			stz 	NSMantissa2,x 				; clear upper bytes, only read 1 or 2 bytes
.96f3	74 70		stz $70,x			stz 	NSMantissa3,x
.96f5	b5 50		lda $50,x			lda 	NSStatus,x 					; make it a value of that type.
.96f7	29 18		and #$18			and 	#NSBTypeMask
.96f9	95 50		sta $50,x			sta 	NSStatus,x 					; and fall through.
.96fb	c9 10		cmp #$10			cmp 	#NSTString  				; is it a string
.96fd	d0 0e		bne $970d			bne 	_DRFNotString
.96ff	b5 58		lda $58,x			lda 	NSMantissa0,x 				; check address is zero
.9701	15 60		ora $60,x			ora 	NSMantissa1,x
.9703	d0 08		bne $970d			bne 	_DRFNotString
.9705	a9 0f		lda #$0f			lda 	#_DRFNullString & $FF 		; if so, return reference to ""
.9707	95 58		sta $58,x			sta 	NSMantissa0,X
.9709	a9 97		lda #$97			lda 	#_DRFNullString >> 8
.970b	95 60		sta $60,x			sta 	NSMantissa1,X
.970d					_DRFNotString
.970d	7a		ply				ply 								; restore Y and exit
.970e					_DRFExit:
.970e	60		rts				rts
.970f					_DRFNullString:
>970f	00						.byte 	0
.9710					_DRFFull:
.9710	a0 01		ldy #$01			ldy 	#1 							; get remaining 3 bytes.
.9712	b1 36		lda ($36),y			lda 	(zTemp0),y
.9714	95 60		sta $60,x			sta 	NSMantissa1,x
.9716	c8		iny				iny
.9717	b1 36		lda ($36),y			lda 	(zTemp0),y
.9719	95 68		sta $68,x			sta 	NSMantissa2,x
.971b	c8		iny				iny
.971c	b1 36		lda ($36),y			lda 	(zTemp0),y
.971e	95 70		sta $70,x			sta 	NSMantissa3,x
.9720	74 78		stz $78,x			stz 	NSExponent,x 				; clear exponent.
.9722	b5 50		lda $50,x			lda		NSStatus,x 					; see if type is integer
.9724	29 18		and #$18			and 	#NSBTypeMask  				; type information only
.9726	95 50		sta $50,x			sta 	NSStatus,x 					; update it back.
.9728	f0 05		beq $972f			beq 	_DRFNoExponent
.972a	c8		iny				iny 								; if not, read the exponent as well.
.972b	b1 36		lda ($36),y			lda 	(zTemp0),y
.972d	95 78		sta $78,x			sta 	NSExponent,x
.972f					_DRFNoExponent:
.972f	b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the most significant bit set ?
.9731	10 0a		bpl $973d			bpl 	_DRFExit2 					; if not, then exit.
.9733	29 7f		and #$7f			and 	#$7F 						; clear that bit.
.9735	95 70		sta $70,x			sta 	NSMantissa3,x
.9737	b5 50		lda $50,x			lda 	NSStatus,x 					; set the sign flag
.9739	09 80		ora #$80			ora 	#NSBIsNegative
.973b	95 50		sta $50,x			sta 	NSStatus,x
.973d					_DRFExit2:
.973d	7a		ply				ply
.973e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/number.asm

=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.973f					EncodeNumberStart:
.973f	38		sec				sec
.9740	80 01		bra $9743			bra 	EncodeNumberContinue+1
.9742					EncodeNumberContinue:
.9742	18		clc				clc
.9743					EncodeNumber:
.9743	08		php				php 								; save reset flag.
.9744	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.9746	f0 12		beq $975a			beq 	_ENIsOkay
.9748	c9 30		cmp #$30			cmp 	#"0"
.974a	90 04		bcc $9750			bcc 	_ENBadNumber
.974c	c9 3a		cmp #$3a			cmp 	#"9"+1
.974e	90 0a		bcc $975a			bcc 	_ENIsOkay
.9750					_ENBadNumber:
.9750	28		plp				plp 								; throw saved reset
.9751	ad 05 04	lda $0405			lda 	EncodeState 				; if in decimal mode, construct final number
.9754	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.9756	f0 7b		beq $97d3			beq 	_ENConstructFinal
.9758					_ENFail:
.9758	18		clc				clc 								; not allowed
.9759	60		rts				rts
.975a					_ENIsOkay:
.975a	28		plp				plp 								; are we restarting
.975b	90 15		bcc $9772			bcc 	_ENNoRestart
.975d					_ENStartEncode:
.975d	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.975f	f0 0c		beq $976d			beq 	_ENFirstDP
.9761	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.9763	20 1d 9e	jsr $9e1d			jsr 	NSMSetByte 					; in single byte mode.
.9766	a9 01		lda #$01			lda 	#ESTA_Low
.9768					_ENExitChange:
.9768	8d 05 04	sta $0405			sta 	EncodeState 				; save new state
.976b	38		sec				sec
.976c	60		rts				rts
.976d					_ENFirstDP:
.976d	20 1b 9e	jsr $9e1b			jsr 	NSMSetZero 					; clear integer part
.9770	80 3c		bra $97ae			bra 	_ESTASwitchFloat			; go straight to float and exi
.9772					_ENNoRestart:
.9772	48		pha				pha 								; save digit or DP on stack.
.9773	ad 05 04	lda $0405			lda 	EncodeState 				; get current state
.9776	c9 01		cmp #$01			cmp 	#ESTA_Low
.9778	f0 09		beq $9783			beq  	_ESTALowState
.977a	c9 02		cmp #$02			cmp 	#ESTA_High
.977c	f0 26		beq $97a4			beq 	_ESTAHighState
.977e	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.9780	f0 38		beq $97ba			beq 	_ESTADecimalState
>9782	db						.byte 	$DB 						; causes a break in the emulator
.9783					_ESTALowState:
.9783	68		pla				pla 								; get value back
.9784	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.9786	f0 26		beq $97ae			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.9788	29 0f		and #$0f			and 	#15 						; make digit
.978a	8d 06 04	sta $0406			sta 	DigitTemp 					; save it.
.978d	b5 58		lda $58,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.978f	0a		asl a				asl 	a
.9790	0a		asl a				asl 	a
.9791	75 58		adc $58,x			adc 	NSMantissa0,x
.9793	0a		asl a				asl 	a
.9794	6d 06 04	adc $0406			adc 	DigitTemp
.9797	95 58		sta $58,x			sta 	NSMantissa0,x
.9799	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.979b	90 05		bcc $97a2			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.979d	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.979f	8d 05 04	sta $0405			sta 	EncodeState
.97a2					_ESTANoSwitch:
.97a2	38		sec				sec
.97a3	60		rts				rts
.97a4					_ESTAHighState:
.97a4	68		pla				pla 								; get value back
.97a5	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.97a7	f0 05		beq $97ae			beq 	_ESTASwitchFloat
.97a9	20 07 98	jsr $9807			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.97ac	38		sec				sec
.97ad	60		rts				rts
.97ae					_ESTASwitchFloat:
.97ae	9c 07 04	stz $0407			stz 	DecimalCount 				; reset the count of digits - we divide by 10^n at the end.
.97b1	e8		inx				inx 								; zero the decimal additive.
.97b2	20 1b 9e	jsr $9e1b			jsr 	NSMSetZero
.97b5	ca		dex				dex
.97b6	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.97b8	80 ae		bra $9768			bra 	_ENExitChange
.97ba					_ESTADecimalState:
.97ba	68		pla				pla 								; digit.
.97bb	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 2nd decimal point.
.97bd	f0 99		beq $9758			beq 	_ENFail
.97bf	e8		inx				inx 								; put digit into fractional part of X+1
.97c0	20 07 98	jsr $9807			jsr 	ESTAShiftDigitIntoMantissa
.97c3	ca		dex				dex
.97c4	ee 07 04	inc $0407			inc 	DecimalCount 				; bump the count of decimals
.97c7	ad 07 04	lda $0407			lda 	DecimalCount 				; too many decimal digits.
.97ca	c9 0b		cmp #$0b			cmp 	#11
.97cc	f0 02		beq $97d0			beq 	_ESTADSFail
.97ce	38		sec				sec
.97cf	60		rts				rts
.97d0					_ESTADSFail:
.97d0	4c 9e 9f	jmp $9f9e			jmp 	RangeError
.97d3					_ENConstructFinal:
.97d3	ad 07 04	lda $0407			lda 	DecimalCount 				; get decimal count
.97d6	f0 2d		beq $9805			beq 	_ENCFExit 					; no decimals
.97d8	5a		phy				phy
.97d9	0a		asl a				asl 	a 							; x 4 and CLC
.97da	0a		asl a				asl 	a
.97db	6d 07 04	adc $0407			adc 	DecimalCount
.97de	a8		tay				tay
.97df	b9 5d 9f	lda $9f5d,y			lda 	DecimalScalarTable-5,y 		; copy decimal scalar to X+2
.97e2	95 5a		sta $5a,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.97e4	b9 5e 9f	lda $9f5e,y			lda 	DecimalScalarTable-5+1,y
.97e7	95 62		sta $62,x			sta 	NSMantissa1+2,x
.97e9	b9 5f 9f	lda $9f5f,y			lda 	DecimalScalarTable-5+2,y
.97ec	95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.97ee	b9 60 9f	lda $9f60,y			lda 	DecimalScalarTable-5+3,y
.97f1	95 72		sta $72,x			sta 	NSMantissa3+2,x
.97f3	b9 61 9f	lda $9f61,y			lda 	DecimalScalarTable-5+4,y
.97f6	95 7a		sta $7a,x			sta 	NSExponent+2,x
.97f8	a9 08		lda #$08			lda 	#NSTFloat
.97fa	95 52		sta $52,x			sta 	NSStatus+2,x
.97fc	7a		ply				ply
.97fd	e8		inx				inx 								; multiply decimal const by decimal scalar
.97fe	20 8d 95	jsr $958d			jsr 	FloatMultiply
.9801	ca		dex				dex
.9802	20 48 94	jsr $9448			jsr 	FloatAdd 					; add to integer part.
.9805					_ENCFExit:
.9805	18		clc				clc 								; reject the digit.
.9806	60		rts				rts
.9807					ESTAShiftDigitIntoMantissa:
.9807	29 0f		and #$0f			and 	#15 						; save digit
.9809	48		pha				pha
.980a	b5 70		lda $70,x			lda 	NSMantissa3,x 				; push mantissa on stack
.980c	48		pha				pha
.980d	b5 68		lda $68,x			lda 	NSMantissa2,x
.980f	48		pha				pha
.9810	b5 60		lda $60,x			lda 	NSMantissa1,x
.9812	48		pha				pha
.9813	b5 58		lda $58,x			lda 	NSMantissa0,x
.9815	48		pha				pha
.9816	20 2a 9e	jsr $9e2a			jsr 	NSMShiftLeft 				; x 2
.9819	20 2a 9e	jsr $9e2a			jsr 	NSMShiftLeft 				; x 4
.981c	18		clc				clc 								; pop mantissa and add
.981d	68		pla				pla
.981e	75 58		adc $58,x			adc 	NSMantissa0,x
.9820	95 58		sta $58,x			sta 	NSMantissa0,x
.9822	68		pla				pla
.9823	75 60		adc $60,x			adc 	NSMantissa1,x
.9825	95 60		sta $60,x			sta 	NSMantissa1,x
.9827	68		pla				pla
.9828	75 68		adc $68,x			adc 	NSMantissa2,x
.982a	95 68		sta $68,x			sta 	NSMantissa2,x
.982c	68		pla				pla
.982d	75 70		adc $70,x			adc 	NSMantissa3,x
.982f	95 70		sta $70,x			sta 	NSMantissa3,x 				; x 5
.9831	20 2a 9e	jsr $9e2a			jsr 	NSMShiftLeft 				; x 10
.9834	68		pla				pla 								; add digit
.9835	18		clc				clc
.9836	75 58		adc $58,x			adc 	NSMantissa0,x
.9838	95 58		sta $58,x			sta 	NSMantissa0,x
.983a	90 0a		bcc $9846			bcc 	_ESTASDExit
.983c	f6 60		inc $60,x			inc 	NSMantissa1,x
.983e	d0 06		bne $9846			bne 	_ESTASDExit
.9840	f6 68		inc $68,x			inc 	NSMantissa2,x
.9842	d0 02		bne $9846			bne 	_ESTASDExit
.9844	f6 70		inc $70,x			inc 	NSMantissa3,x
.9846					_ESTASDExit:
.9846	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/term.asm

.9847					EvaluateTerm:
.9847	b1 30		lda ($30),y			lda 	(codePtr),y
.9849	30 18		bmi $9863			bmi 	_ETCheckUnary 				; unary function ? (text ones)
.984b	c9 40		cmp #$40			cmp 	#$40 						; 40-7F => identifier reference
.984d	b0 6c		bcs $98bb			bcs 	_ETVariable
.984f	c9 30		cmp #$30			cmp 	#'0' 						; is it a number
.9851	90 6b		bcc $98be			bcc 	_ETPuncUnary 				; if not it might be a punctuation unary.
.9853	c9 3a		cmp #$3a			cmp 	#'9'+1
.9855	b0 67		bcs $98be			bcs 	_ETPuncUnary
.9857	20 3f 97	jsr $973f			jsr 	EncodeNumberStart 			; can't fail as it's 0-9 !
.985a					_ETNumber:
.985a	c8		iny				iny 								; keep encoding until we have the numbers
.985b	b1 30		lda ($30),y			lda 	(codePtr),y
.985d	20 42 97	jsr $9742			jsr 	EncodeNumberContinue
.9860	b0 f8		bcs $985a			bcs 	_ETNumber 					; go back if accepted.
.9862	60		rts				rts
.9863					_ETCheckUnary:
.9863	c9 ff		cmp #$ff			cmp 	#KWC_STRING 				; string token
.9865	f0 3f		beq $98a6			beq 	_ETString
.9867	c9 fe		cmp #$fe			cmp 	#KWC_HEXCONST 				; hex constant.
.9869	f0 12		beq $987d			beq 	_ETHexConstant
.986b	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; check it actually is a unary function
.986d	90 0b		bcc $987a			bcc 	_ETSyntaxError
.986f	c9 a2		cmp #$a2			cmp 	#KWC_LAST_UNARY+1
.9871	b0 07		bcs $987a			bcs 	_ETSyntaxError
.9873	da		phx				phx 								; push X on the stack
.9874	0a		asl a				asl 	a 							; put vector x 2 into X
.9875	aa		tax				tax
.9876	c8		iny				iny 								; consume unary function token
.9877	7c 90 8c	jmp ($8c90,x)			jmp 	(VectorSet0,x) 				; and do it.
.987a					_ETSyntaxError:
.987a	4c 99 9f	jmp $9f99			jmp 	SyntaxError
.987d					_ETHexConstant:
.987d	c8		iny				iny 								; skip #
.987e	c8		iny				iny 								; skip count
.987f	20 1b 9e	jsr $9e1b			jsr 	NSMSetZero 					; clear result
.9882					_ETHLoop:
.9882	b1 30		lda ($30),y			lda 	(codePtr),y
.9884	c8		iny				iny 								; and consume
.9885	c9 00		cmp #$00			cmp 	#0 							; exit if zero
.9887	f0 1c		beq $98a5			beq 	_ETHExit
.9889	48		pha				pha 								; save on stack.
.988a	20 2a 9e	jsr $9e2a			jsr 	NSMShiftLeft 				; x 2
.988d	20 2a 9e	jsr $9e2a			jsr 	NSMShiftLeft 				; x 4
.9890	20 2a 9e	jsr $9e2a			jsr 	NSMShiftLeft 				; x 8
.9893	20 2a 9e	jsr $9e2a			jsr 	NSMShiftLeft 				; x 16
.9896	68		pla				pla 								; ASCII
.9897	c9 41		cmp #$41			cmp 	#'A'
.9899	90 02		bcc $989d			bcc 	_ETHNotChar
.989b	e9 07		sbc #$07			sbc 	#7
.989d					_ETHNotChar:
.989d	29 0f		and #$0f			and 	#15 						; digit now
.989f	15 58		ora $58,x			ora 	NSMantissa0,x 				; put in LS Nibble
.98a1	95 58		sta $58,x			sta 	NSMantissa0,x
.98a3	80 dd		bra $9882			bra 	_ETHLoop 					; go round.
.98a5					_ETHExit:
.98a5	60		rts				rts
.98a6					_ETString:
.98a6	c8		iny				iny 								; look at length
.98a7	b1 30		lda ($30),y			lda 	(codePtr),y
.98a9	48		pha				pha
.98aa	c8		iny				iny 								; first character
.98ab	20 73 a5	jsr $a573			jsr 	MemoryInline 				; put address of string at (code-Ptr),y on stack
.98ae	68		pla				pla 								; restore count and save
.98af	85 36		sta $36				sta 	zTemp0
.98b1	98		tya				tya 								; add length to Y to skip it.
.98b2	18		clc				clc
.98b3	65 36		adc $36				adc 	zTemp0
.98b5	a8		tay				tay
.98b6	a9 10		lda #$10			lda 	#NSTString 					; mark as string
.98b8	95 50		sta $50,x			sta 	NSStatus,x
.98ba	60		rts				rts
.98bb					_ETVariable:
.98bb	4c 10 99	jmp $9910			jmp 	VariableHandler
.98be					_ETPuncUnary:
.98be	c8		iny				iny 								; consume the unary character
.98bf	c9 2d		cmp #$2d			cmp 	#KWD_MINUS 					; unary minus
.98c1	f0 2b		beq $98ee			beq 	_ETUnaryNegate
.98c3	c9 10		cmp #$10			cmp 	#KWD_AT 					; @ reference -> constant
.98c5	f0 36		beq $98fd			beq 	_ETDereference
.98c7	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; parenthesis
.98c9	f0 3e		beq $9909			beq 	_ETParenthesis
.98cb	64 36		stz $36				stz 	zTemp0 						; zTemp0 is the indirection level.
.98cd	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; byte indirection (0) ?
.98cf	f0 06		beq $98d7			beq 	_ETIndirection
.98d1	e6 36		inc $36				inc 	zTemp0
.98d3	c9 21		cmp #$21			cmp 	#KWD_PLING					; word indirection (1) \
.98d5	d0 a3		bne $987a			bne 	_ETSyntaxError
.98d7					_ETIndirection:
.98d7	a5 36		lda $36				lda 	zTemp0 						; push indirection amount (0-1) => (1-2) on the stack
.98d9	1a		inc a				inc 	a
.98da	48		pha				pha
.98db	20 47 98	jsr $9847			jsr 	EvaluateTerm				; evaluate the term
.98de	20 c0 96	jsr $96c0			jsr 	Dereference 				; dereference it.
.98e1	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a +ve integer.
.98e3	d0 06		bne $98eb			bne 	_ETTypeMismatch
.98e5	68		pla				pla 								; indirection 1-2
.98e6	09 20		ora #$20			ora 	#NSBIsReference 			; make it a reference.
.98e8	95 50		sta $50,x			sta 	NSStatus,x
.98ea	60		rts				rts
.98eb					_ETTypeMismatch:
.98eb	4c a3 9f	jmp $9fa3			jmp 	TypeError
.98ee					_ETUnaryNegate:
.98ee	20 47 98	jsr $9847			jsr 	EvaluateTerm				; evaluate the term
.98f1	20 c0 96	jsr $96c0			jsr 	Dereference 				; dereference it.
.98f4	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a number
.98f6	29 10		and #$10			and 	#NSTString
.98f8	d0 f1		bne $98eb			bne 	_ETTypeMismatch
.98fa	4c dd 9d	jmp $9ddd			jmp 	NSMNegate  					; just toggles the sign bit.
.98fd					_ETDereference:
.98fd	20 47 98	jsr $9847			jsr 	EvaluateTerm				; evaluate the term
.9900	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a reference
.9902	29 20		and #$20			and 	#NSBIsReference
.9904	f0 e5		beq $98eb			beq 	_ETTypeMismatch
.9906	74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer address
.9908	60		rts				rts
.9909					_ETParenthesis:
.9909	20 fd 93	jsr $93fd			jsr 	EvaluateExpression 			; evaluate here, from lowest precedence
.990c	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket 			; check for )
.990f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/variable.asm

.9910					VariableHandler:
.9910	b1 30		lda ($30),y			lda 	(codePtr),y
.9912	18		clc				clc
.9913	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.9915	85 37		sta $37				sta 	zTemp0+1
.9917	c8		iny				iny
.9918	b1 30		lda ($30),y			lda 	(codePtr),y
.991a	85 36		sta $36				sta 	zTemp0
.991c	c8		iny				iny
.991d	18		clc				clc									; copy variable address+3 to mantissa
.991e	69 03		adc #$03			adc 	#3 							; this is the address of the data.
.9920	95 58		sta $58,x			sta 	NSMantissa0,x
.9922	a5 37		lda $37				lda 	zTemp0+1
.9924	69 00		adc #$00			adc 	#0
.9926	95 60		sta $60,x			sta 	NSMantissa1,x
.9928	74 68		stz $68,x			stz 	NSMantissa2,x
.992a	74 70		stz $70,x			stz 	NSMantissa3,x
.992c	74 78		stz $78,x			stz 	NSExponent,x
.992e	5a		phy				phy
.992f	a0 02		ldy #$02			ldy 	#2 							; read type
.9931	b1 36		lda ($36),y			lda 	(zTemp0),y
.9933	7a		ply				ply
.9934	29 1c		and #$1c			and 	#NSBTypeMask+NSBIsArray 	; get type information
.9936	09 20		ora #$20			ora 	#NSBIsReference 			; make a reference.
.9938	95 50		sta $50,x			sta 	NSStatus,x
.993a	29 04		and #$04			and 	#NSBIsArray
.993c	d0 01		bne $993f			bne 	_VHArray
.993e	60		rts				rts
.993f					_VHArray:
.993f	e8		inx				inx
.9940	20 b6 9d	jsr $9db6			jsr 	Evaluate8BitInteger 		; get the 1st index.
.9943	a9 ff		lda #$ff			lda 	#$FF 						; set Status of X+2 to a duff value so we know if we picked it up.
.9945	95 51		sta $51,x			sta 	NSStatus+1,x
.9947	b1 30		lda ($30),y			lda 	(codePtr),y
.9949	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.994b	d0 06		bne $9953			bne 	_VHNoSecondIndex
.994d	c8		iny				iny 								; skip the comma
.994e	e8		inx				inx
.994f	20 b6 9d	jsr $9db6			jsr 	Evaluate8BitInteger 		; get the 2nd index.
.9952	ca		dex				dex
.9953					_VHNoSecondIndex:
.9953	ca		dex				dex 								; set X back.
.9954	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket 			; and check the right bracket.
.9957	5a		phy				phy 								; save position
.9958	a0 02		ldy #$02			ldy 	#2 							; check first index is not-zero, e.g. array defined
.995a	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.995c	f0 60		beq $99be			beq 	_VHBadIndex
.995e	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy record address to zaTemp
.9960	85 3e		sta $3e				sta 	zaTemp
.9962	b5 60		lda $60,x			lda 	NSMantissa1,x
.9964	85 3f		sta $3f				sta 	zaTemp+1
.9966	a0 03		ldy #$03			ldy 	#3 							; get the second index - which is 0 if there is one index.
.9968	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.996a	f0 02		beq $996e			beq 	_VHHas2Mask
.996c	a9 ff		lda #$ff			lda 	#$FF
.996e					_VHHas2Mask:
.996e	d5 52		cmp $52,x			cmp 	NSStatus+2,x 				; so if they are the same there are the wrong number of indices
.9970	f0 4c		beq $99be			beq 	_VHBadIndex
.9972	0a		asl a				asl 	a 							; carry will be set if a second index
.9973	90 08		bcc $997d			bcc 	_VHCheckFirstIndex
.9975	a0 03		ldy #$03			ldy 	#3 			 				; check the 2nd size >= 2nd index
.9977	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9979	d5 5a		cmp $5a,x			cmp 	NSMantissa0+2,x
.997b	90 41		bcc $99be			bcc 	_VHBadIndex
.997d					_VHCheckFirstIndex:
.997d	a0 02		ldy #$02			ldy 	#2 			 				; check the 2nd size >= 2nd index
.997f	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9981	d5 59		cmp $59,x			cmp 	NSMantissa0+1,x
.9983	90 39		bcc $99be			bcc 	_VHBadIndex
.9985	64 36		stz $36				stz 	zTemp0 						; clear zTemp0 (if 1 index)
.9987	64 37		stz $37				stz 	zTemp0+1
.9989	b5 52		lda $52,x			lda 	NSStatus+2,x 				; if only one index provided, don't need to multiply
.998b	30 0e		bmi $999b			bmi 	_VHNoMultiply
.998d	da		phx				phx
.998e	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; get 2nd index on stack
.9990	48		pha				pha
.9991	a0 02		ldy #$02			ldy 	#2 							; get 1st size in A
.9993	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9995	1a		inc a				inc 	a 							; add 1 for zero base
.9996	fa		plx				plx
.9997	20 c6 9d	jsr $9dc6			jsr 	Multiply8x8 				; calculate -> Z0
.999a	fa		plx				plx
.999b					_VHNoMultiply:
.999b	18		clc				clc
.999c	a5 36		lda $36				lda 	zTemp0
.999e	75 59		adc $59,x			adc 	NSMantissa0+1,x
.99a0	85 36		sta $36				sta 	zTemp0
.99a2	a5 37		lda $37				lda 	zTemp0+1
.99a4	69 00		adc #$00			adc 	#0
.99a6	85 37		sta $37				sta 	zTemp0+1
.99a8	b5 50		lda $50,x			lda 	NSStatus,x
.99aa	20 70 85	jsr $8570			jsr 	ScaleByBaseType
.99ad	18		clc				clc
.99ae	b2 3e		lda ($3e)			lda 	(zaTemp)
.99b0	65 36		adc $36				adc 	zTemp0
.99b2	95 58		sta $58,x			sta 	NSMantissa0,x
.99b4	a0 01		ldy #$01			ldy 	#1
.99b6	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99b8	65 37		adc $37				adc 	zTemp0+1
.99ba	95 60		sta $60,x			sta 	NSMantissa1,x
.99bc	7a		ply				ply 								; restore position
.99bd	60		rts				rts
.99be					_VHBadIndex:
.99be	a9 17		lda #$17		lda	#23
.99c0	4c f9 8e	jmp $8ef9		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/abs.asm

.99c3					AbsUnary:
.99c3	fa		plx				plx 								; restore stack pos
.99c4	20 69 9d	jsr $9d69			jsr 	EvaluateNumber 				; get a float or int
.99c7	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket
.99ca	b5 50		lda $50,x			lda 	NSStatus,x 					; clear the sign bit
.99cc	29 7f		and #$7f			and 	#$7F
.99ce	95 50		sta $50,x			sta 	NSStatus,x
.99d0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/alloc.asm

.99d1					AllocUnary:
.99d1	fa		plx				plx 								; restore stack pos
.99d2	20 9b 9d	jsr $9d9b			jsr 	Evaluate16BitInteger		; get bytes required.
.99d5	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket
.99d8	da		phx				phx 								; save X/Y
.99d9	5a		phy				phy
.99da	8a		txa				txa 								; copy X into Y
.99db	a8		tay				tay
.99dc	b9 60 00	lda $0060,y			lda		NSMantissa1,y 				; get size into XA
.99df	aa		tax				tax
.99e0	b9 58 00	lda $0058,y			lda 	NSMantissa0,y
.99e3	20 f0 99	jsr $99f0			jsr 	AllocateXABytes 			; allocate memory
.99e6	99 58 00	sta $0058,y			sta 	NSMantissa0,y 				; write address out.
.99e9	8a		txa				txa 	 							; typing is 16 bit integer.
.99ea	99 60 00	sta $0060,y			sta 	NSMantissa1,y
.99ed	7a		ply				ply
.99ee	fa		plx				plx
.99ef	60		rts				rts
.99f0					AllocateXABytes:
.99f0	5a		phy				phy
.99f1	ac 0c 04	ldy $040c			ldy 	lowMemPtr 					; push current address on stack and to zTemp0
.99f4	84 36		sty $36				sty 	zTemp0
.99f6	5a		phy				phy
.99f7	ac 0d 04	ldy $040d			ldy 	lowMemPtr+1
.99fa	84 37		sty $37				sty 	zTemp0+1
.99fc	5a		phy				phy
.99fd	18		clc				clc 								; add to low memory pointer
.99fe	6d 0c 04	adc $040c			adc 	lowMemPtr
.9a01	8d 0c 04	sta $040c			sta 	lowMemPtr
.9a04	8a		txa				txa
.9a05	6d 0d 04	adc $040d			adc 	lowMemPtr+1
.9a08	8d 0d 04	sta $040d			sta 	lowMemPtr+1
.9a0b	b0 2f		bcs $9a3c			bcs 	CISSMemory
.9a0d	20 2e 9a	jsr $9a2e			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.9a10					_ClearMemory:
.9a10	ad 0c 04	lda $040c			lda 	lowMemPtr 					; cleared all memory allocated
.9a13	c5 36		cmp $36				cmp 	zTemp0
.9a15	d0 07		bne $9a1e			bne 	_CMClearNext
.9a17	ad 0d 04	lda $040d			lda 	lowMemPtr+1
.9a1a	c5 37		cmp $37				cmp 	zTemp0+1
.9a1c	f0 0c		beq $9a2a			beq 	_CMExit
.9a1e					_CMClearNext:
.9a1e	a9 00		lda #$00			lda 	#0 							; clear byte, advance to next.
.9a20	92 36		sta ($36)			sta 	(zTemp0)
.9a22	e6 36		inc $36				inc 	zTemp0
.9a24	d0 ea		bne $9a10			bne 	_ClearMemory
.9a26	e6 37		inc $37				inc		zTemp0+1
.9a28	80 e6		bra $9a10			bra 	_ClearMemory
.9a2a					_CMExit:
.9a2a	fa		plx				plx
.9a2b	68		pla				pla
.9a2c	7a		ply				ply
.9a2d	60		rts				rts
.9a2e					CheckIdentifierStringSpace:
.9a2e	48		pha				pha
.9a2f	ad 0d 04	lda $040d			lda 	lowMemPtr+1 				; get low memory pointer
.9a32	18		clc				clc
.9a33	69 02		adc #$02			adc 	#2 							; need at least 2 256 byte pages
.9a35	cd 0f 04	cmp $040f			cmp 	StringMemory+1 				; is it >= StringMemory
.9a38	b0 02		bcs $9a3c			bcs 	CISSMemory
.9a3a	68		pla				pla
.9a3b	60		rts				rts
.9a3c					CISSMemory:
.9a3c	a9 06		lda #$06		lda	#6
.9a3e	4c f9 8e	jmp $8ef9		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/asc.asm

.9a41					AscUnary:
.9a41	fa		plx				plx 								; restore stack pos
.9a42	20 73 9d	jsr $9d73			jsr 	EvaluateString 				; get a string
.9a45	b2 36		lda ($36)			lda 	(zTemp0)					; get/return first character
.9a47	20 1d 9e	jsr $9e1d			jsr 	NSMSetByte 					; ASC("") will return zero.
.9a4a	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket
.9a4d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/deekpeek.asm

.9a4e					PeekUnary:
.9a4e	18		clc				clc
.9a4f	80 01		bra $9a52			bra 	DPUnary
.9a51					DeekUnary:
.9a51	38		sec				sec
.9a52					DPUnary:
.9a52	fa		plx				plx 								; restore position.
.9a53	08		php				php									; save on stack, CS = Deek, CC = Peek
.9a54	20 9b 9d	jsr $9d9b			jsr		Evaluate16BitInteger 		; address as constant.
.9a57	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket
.9a5a	28		plp				plp 								; function back.
.9a5b	a9 21		lda #$21			lda 	#NSBIsReference+NSTInteger+1 ; 1 byte read
.9a5d	90 01		bcc $9a60			bcc 	_DPUpdate
.9a5f	1a		inc a				inc 	a 							; 2 byte read
.9a60					_DPUpdate:
.9a60	95 50		sta $50,x			sta 	NSStatus,x 					; set to 1/2 byte reference.
.9a62	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/frac.asm

.9a63					FracUnary:
.9a63	fa		plx				plx 								; restore stack pos
.9a64	20 69 9d	jsr $9d69			jsr 	EvaluateNumber 				; get a float or int
.9a67	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket
.9a6a	b5 50		lda $50,x			lda 	NSStatus,x
.9a6c	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9a6e	f0 04		beq $9a74			beq 	_IUZero
.9a70	20 0e 95	jsr $950e			jsr 	FloatFractionalPart 		; if so, get the fractional part.
.9a73	60		rts				rts
.9a74					_IUZero:
.9a74	20 1b 9e	jsr $9e1b			jsr 	NSMSetZero
.9a77	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/int.asm

.9a78					IntUnary:
.9a78	fa		plx				plx 								; restore stack pos
.9a79	20 69 9d	jsr $9d69			jsr 	EvaluateNumber 				; get a float or int
.9a7c	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket
.9a7f	b5 50		lda $50,x			lda 	NSStatus,x
.9a81	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9a83	f0 03		beq $9a88			beq 	_IUExit
.9a85	20 66 95	jsr $9566			jsr 	FloatIntegerPart 			; if it is get the integer part.
.9a88					_IUExit:
.9a88	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/len.asm

.9a89					LenUnary:
.9a89	fa		plx				plx 								; restore stack pos
.9a8a	20 73 9d	jsr $9d73			jsr 	EvaluateString 				; get a string
.9a8d	5a		phy				phy
.9a8e	a0 00		ldy #$00			ldy 	#0 							; find length
.9a90					_LenFind:
.9a90	b1 36		lda ($36),y			lda 	(zTemp0),y 					; look for trailing NULL.
.9a92	f0 06		beq $9a9a			beq 	_LenExit
.9a94	c8		iny				iny
.9a95	d0 f9		bne $9a90			bne 	_LenFind
.9a97	4c 9e 9f	jmp $9f9e			jmp 	RangeError 					; string > 255 - no trailing NULL.
.9a9a					_LenExit:
.9a9a	98		tya				tya		 							; return length
.9a9b	20 1d 9e	jsr $9e1d			jsr 	NSMSetByte
.9a9e	7a		ply				ply
.9a9f	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket
.9aa2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/minmax.asm

.9aa3					Unary_Min:
.9aa3	a9 01		lda #$01			lda 	#1
.9aa5	80 02		bra $9aa9			bra 	UnaryMinMaxMain
.9aa7					Unary_Max:
.9aa7	a9 ff		lda #$ff			lda 	#$FF 						; value from comparator to cause a write
.9aa9					UnaryMinMaxMain:
.9aa9	fa		plx				plx 								; get index on number stack
.9aaa	48		pha				pha 								; save comparator
.9aab	20 60 9d	jsr $9d60			jsr 	EvaluateValue 				; get the first value.
.9aae					_UMMMLoop:
.9aae	b1 30		lda ($30),y			lda 	(codePtr),y
.9ab0	c9 29		cmp #$29			cmp 	#KWD_RPAREN 				; if right bracket then done.
.9ab2	f0 22		beq $9ad6			beq 	_UMMMDone
.9ab4	20 e8 8e	jsr $8ee8			jsr 	CheckComma 					; must be a comma
.9ab7	e8		inx				inx
.9ab8	20 60 9d	jsr $9d60			jsr 	EvaluateValue
.9abb	ca		dex				dex
.9abc	20 fe 9d	jsr $9dfe			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] (Compare is destructive)
.9abf	e8		inx				inx
.9ac0	20 fe 9d	jsr $9dfe			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2], original
.9ac3	e8		inx				inx
.9ac4	20 b0 8f	jsr $8fb0			jsr 	CompareBaseCode 			; part of > = < etc. code, returns 255,0 or 1
.9ac7	ca		dex				dex
.9ac8	ca		dex				dex
.9ac9	85 36		sta $36				sta 	zTemp0 						; save required result
.9acb	68		pla				pla 								; get and save comparator
.9acc	48		pha				pha
.9acd	c5 36		cmp $36				cmp 	zTemp0 						; if the comparator
.9acf	d0 dd		bne $9aae			bne 	_UMMMLoop
.9ad1	20 d9 9a	jsr $9ad9			jsr 	ExpCopyAboveDown 			; copy next up slot down
.9ad4	80 d8		bra $9aae			bra 	_UMMMLoop
.9ad6					_UMMMDone:
.9ad6	68		pla				pla 								; throw the comparator
.9ad7	c8		iny				iny 								; skip )
.9ad8	60		rts				rts
.9ad9					ExpCopyAboveDown:
.9ad9	b5 51		lda $51,x			lda 	NSStatus+1,x
.9adb	95 50		sta $50,x			sta 	NSStatus,x
.9add	b5 79		lda $79,x			lda 	NSExponent+1,x
.9adf	95 78		sta $78,x			sta 	NSExponent,x
.9ae1	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9ae3	95 58		sta $58,x			sta 	NSMantissa0,x
.9ae5	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9ae7	95 60		sta $60,x			sta 	NSMantissa1,x
.9ae9	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.9aeb	95 68		sta $68,x			sta 	NSMantissa2,x
.9aed	b5 71		lda $71,x			lda 	NSMantissa3+1,x
.9aef	95 70		sta $70,x			sta 	NSMantissa3,x
.9af1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/not.asm

.9af2					Unary_Not:
.9af2	fa		plx				plx
.9af3	20 88 9d	jsr $9d88			jsr 	EvaluateInteger 			; get integer
.9af6	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket
.9af9	20 3d 9e	jsr $9e3d			jsr 	NSMIsZero 					; zero mantissa ?
.9afc	f0 04		beq $9b02			beq 	_NotZero
.9afe	20 1b 9e	jsr $9e1b			jsr 	NSMSetZero
.9b01	60		rts				rts
.9b02					_NotZero:
.9b02	4c 66 8f	jmp $8f66			jmp 	ReturnTrue

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/rnd.asm

.9b05					Unary_Random:
.9b05	fa		plx				plx
.9b06	20 77 9b	jsr $9b77			jsr 	Random32Bit 				; get a random number
.9b09	20 60 9b	jsr $9b60			jsr 	URCopyToMantissa  			; put in mantissa
.9b0c	b1 30		lda ($30),y			lda 	(codePtr),y
.9b0e	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.9b10	f0 08		beq $9b1a			beq 	_URNoModulus 				; then we return a random 30 bit number.
.9b12	e8		inx				inx
.9b13	20 9b 9d	jsr $9d9b			jsr 	Evaluate16BitInteger 		; put modulus value in +1
.9b16	ca		dex				dex
.9b17	20 b8 90	jsr $90b8			jsr 	IntegerModulusNoCheck 		; calculate modulus, so now 0 .. n-1
.9b1a					_URNoModulus:
.9b1a	74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer positive
.9b1c	74 78		stz $78,x			stz 	NSExponent,x
.9b1e	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket
.9b21	60		rts				rts
.9b22					Unary_Rnd:
.9b22	fa		plx				plx
.9b23	20 69 9d	jsr $9d69			jsr 	EvaluateNumber 				; number to use.
.9b26	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket 			; closing bracket
.9b29	20 3d 9e	jsr $9e3d			jsr 	NSMIsZero 					; if zero, then don't generate a new number
.9b2c	f0 26		beq $9b54			beq 	_URCopySeed
.9b2e	b5 50		lda $50,x			lda 	NSStatus,x 					; if -ve, then seed using parameter
.9b30	10 1f		bpl $9b51			bpl 	_URDontSeed
.9b32	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy - value to seed butchering it.
.9b34	49 17		eor #$17			eor 	#$17
.9b36	8d 08 04	sta $0408			sta 	RandomSeed+0
.9b39	b5 60		lda $60,x			lda 	NSMantissa1,x
.9b3b	49 a5		eor #$a5			eor 	#$A5
.9b3d	8d 09 04	sta $0409			sta 	RandomSeed+1
.9b40	b5 68		lda $68,x			lda 	NSMantissa2,x
.9b42	49 c2		eor #$c2			eor 	#$C2
.9b44	8d 0a 04	sta $040a			sta 	RandomSeed+2
.9b47	b5 70		lda $70,x			lda 	NSMantissa3,x
.9b49	49 9d		eor #$9d			eor 	#$9D
.9b4b	8d 0b 04	sta $040b			sta 	RandomSeed+3
.9b4e	20 77 9b	jsr $9b77			jsr 	Random32Bit
.9b51					_URDontSeed:
.9b51	20 77 9b	jsr $9b77			jsr 	Random32Bit 				; generate a number
.9b54					_URCopySeed:
.9b54	20 60 9b	jsr $9b60			jsr 	URCopyToMantissa 			; copy into mantissa
.9b57	a9 e2		lda #$e2			lda 	#-30 						; force into 0-1 range
.9b59	95 78		sta $78,x			sta 	NSExponent,x
.9b5b	a9 08		lda #$08			lda 	#NSTFloat
.9b5d	95 50		sta $50,x			sta 	NSStatus,x 					; positive float
.9b5f	60		rts				rts
.9b60					URCopyToMantissa:
.9b60	ad 08 04	lda $0408			lda 	RandomSeed+0
.9b63	95 58		sta $58,x			sta 	NSMantissa0,x
.9b65	ad 09 04	lda $0409			lda 	RandomSeed+1
.9b68	95 60		sta $60,x			sta 	NSMantissa1,x
.9b6a	ad 0a 04	lda $040a			lda 	RandomSeed+2
.9b6d	95 68		sta $68,x			sta 	NSMantissa2,x
.9b6f	ad 0b 04	lda $040b			lda 	RandomSeed+3
.9b72	29 3f		and #$3f			and 	#$3F 						; make legal mantissa
.9b74	95 70		sta $70,x			sta 	NSMantissa3,x
.9b76	60		rts				rts
.9b77					Random32Bit:
.9b77	5a		phy				phy
.9b78	a0 07		ldy #$07			ldy 	#7 							; do it 7 times
.9b7a	ad 08 04	lda $0408			lda 	RandomSeed+0 				; check the seed isn't zero
.9b7d	d0 03		bne $9b82			bne 	_Random1
.9b7f	a8		tay				tay 								; if so do it 256 times
.9b80	a9 aa		lda #$aa			lda		#$AA 						; and use this to seed the seed....
.9b82					_Random1:
.9b82	0a		asl a				asl 	a 							; LSFR RNG
.9b83	2e 09 04	rol $0409			rol 	RandomSeed+1
.9b86	2e 0a 04	rol $040a			rol 	RandomSeed+2
.9b89	2e 0b 04	rol $040b			rol 	RandomSeed+3
.9b8c	90 02		bcc $9b90			bcc 	_Random2
.9b8e	49 c5		eor #$c5			eor 	#$C5
.9b90					_Random2:
.9b90	88		dey				dey
.9b91	d0 ef		bne $9b82			bne 	_Random1
.9b93	8d 08 04	sta $0408			sta 	RandomSeed+0
.9b96	7a		ply				ply
.9b97	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/sgn.asm

.9b98					SgnUnary:
.9b98	fa		plx				plx 								; restore stack pos
.9b99	20 69 9d	jsr $9d69			jsr 	EvaluateNumber 				; get a float or int
.9b9c	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket
.9b9f	20 3d 9e	jsr $9e3d			jsr 	NSMIsZero 					; if zero
.9ba2	f0 0e		beq $9bb2			beq 	_SGZero  					; return Int Zero
.9ba4	b5 50		lda $50,x			lda 	NSStatus,x 					; get status w/sign
.9ba6	48		pha				pha
.9ba7	a9 01		lda #$01			lda 	#1 							; set to 1
.9ba9	20 1d 9e	jsr $9e1d			jsr 	NSMSetByte
.9bac	68		pla				pla
.9bad	29 80		and #$80			and		#$80 						; copy the sign byte out
.9baf	95 50		sta $50,x			sta 	NSStatus,x  				; so it will be -1 or 1
.9bb1	60		rts				rts
.9bb2	20 1b 9e	jsr $9e1b	_SGZero:jsr 	NSMSetZero
.9bb5	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/val.asm

.9bb6					ValUnary:
.9bb6	fa		plx				plx 								; restore stack pos
.9bb7	20 cc 9b	jsr $9bcc			jsr 	ValMainCode 				; do the main val() code
.9bba	b0 01		bcs $9bbd			bcs 	_VUError 					; couldn't convert
.9bbc	60		rts				rts
.9bbd					_VUError:
.9bbd	4c a3 9f	jmp $9fa3			jmp 	TypeError
.9bc0					IsValUnary:
.9bc0	fa		plx				plx 								; restore stack pos
.9bc1	20 cc 9b	jsr $9bcc			jsr 	ValMainCode 				; do the main val() code
.9bc4	b0 03		bcs $9bc9			bcs 	_VUBad
.9bc6	4c 66 8f	jmp $8f66			jmp 	ReturnTrue
.9bc9					_VUBad:
.9bc9	4c 71 8f	jmp $8f71			jmp 	ReturnFalse
.9bcc					ValMainCode:
.9bcc	20 73 9d	jsr $9d73			jsr 	EvaluateString 				; get a string
.9bcf	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket 			; check right bracket present
.9bd2					ValEvaluateZTemp0:
.9bd2	5a		phy				phy
.9bd3	b2 36		lda ($36)			lda 	(zTemp0) 					; check not empty string
.9bd5	f0 17		beq $9bee			beq 	_VMCFail2
.9bd7	a0 ff		ldy #$ff			ldy 	#$FF 						; start position
.9bd9	48		pha				pha 								; save first character
.9bda	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.9bdc	d0 01		bne $9bdf			bne 	_VMCStart
.9bde	c8		iny				iny 								; skip over -
.9bdf					_VMCStart:
.9bdf	38		sec				sec 								; initialise first time round.
.9be0					_VMCNext:
.9be0	c8		iny				iny 								; pre-increment
.9be1	b1 36		lda ($36),y			lda 	(zTemp0),y 					; next character = EOS ?
.9be3	f0 0c		beq $9bf1			beq 	_VMCSuccess 				; successful.
.9be5	20 43 97	jsr $9743			jsr 	EncodeNumber 				; send it to the number-builder
.9be8	90 03		bcc $9bed			bcc 	_VMCFail 					; if failed, give up.
.9bea	18		clc				clc 								; next time round, countinue
.9beb	80 f3		bra $9be0			bra 	_VMCNext
.9bed					_VMCFail:
.9bed	68		pla				pla
.9bee					_VMCFail2:
.9bee	7a		ply				ply
.9bef	38		sec				sec
.9bf0	60		rts				rts
.9bf1					_VMCSuccess:
.9bf1	a9 00		lda #$00			lda 	#0 							; construct final
.9bf3	20 43 97	jsr $9743			jsr 	EncodeNumber 				; by sending a duff value.
.9bf6	68		pla				pla 								; if it was -ve
.9bf7	c9 2d		cmp #$2d			cmp 	#"-"
.9bf9	d0 03		bne $9bfe			bne 	_VMCNotNegative
.9bfb	20 dd 9d	jsr $9ddd			jsr		NSMNegate 					; negate it.
.9bfe					_VMCNotNegative:
.9bfe	7a		ply				ply
.9bff	18		clc				clc
.9c00	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/chr.asm

.9c01					ChrUnary:
.9c01	fa		plx				plx 								; restore stack pos
.9c02	20 b6 9d	jsr $9db6			jsr 	Evaluate8BitInteger			; get value (chr$(0) returns an empty string)
.9c05	48		pha				pha
.9c06	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket
.9c09	a9 01		lda #$01			lda 	#1 							; allocate space for one char
.9c0b	20 9a a7	jsr $a79a			jsr 	StringTempAllocate
.9c0e	68		pla				pla 								; write number to it
.9c0f	20 d3 a7	jsr $a7d3			jsr 	StringTempWrite
.9c12	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/spc.asm

.9c13					SpcUnary:
.9c13	fa		plx				plx 								; restore stack pos
.9c14	20 b6 9d	jsr $9db6			jsr 	Evaluate8BitInteger			; get value
.9c17	5a		phy				phy
.9c18	48		pha				pha 								; save count
.9c19	20 9a a7	jsr $a79a			jsr 	StringTempAllocate
.9c1c	7a		ply				ply 								; to do count in Y
.9c1d					_SpcLoop:
.9c1d	c0 00		cpy #$00			cpy 	#0 							; copy Y spaces in.
.9c1f	f0 08		beq $9c29			beq 	_SpcExit
.9c21	a9 20		lda #$20			lda 	#32
.9c23	20 d3 a7	jsr $a7d3			jsr 	StringTempWrite
.9c26	88		dey				dey
.9c27	80 f4		bra $9c1d			bra 	_SPCLoop
.9c29					_SpcExit:
.9c29	7a		ply				ply
.9c2a	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket
.9c2d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/str.asm

.9c2e					Unary_Str:
.9c2e	fa		plx				plx
.9c2f	20 69 9d	jsr $9d69			jsr 	EvaluateNumber  			; get number
.9c32	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket 			; closing bracket
.9c35	a9 05		lda #$05			lda 	#5 							; maximum decimals, from Basic816
.9c37	20 50 9c	jsr $9c50			jsr 	ConvertNumberToString 		; do the conversion.
.9c3a	a9 21		lda #$21			lda		#33 						; create buffer
.9c3c	20 9a a7	jsr $a79a			jsr 	StringTempAllocate 			; allocate memory
.9c3f	da		phx				phx  								; copy the converted string into the buffer.
.9c40	a2 00		ldx #$00			ldx 	#0
.9c42					_USCopy:
.9c42	bd 49 06	lda $0649,x			lda 	DecimalBuffer,x
.9c45	20 d3 a7	jsr $a7d3			jsr 	StringTempWrite
.9c48	e8		inx				inx
.9c49	bd 49 06	lda $0649,x			lda 	DecimalBuffer,x
.9c4c	d0 f4		bne $9c42			bne 	_USCopy
.9c4e	fa		plx				plx
.9c4f	60		rts				rts
.9c50					ConvertNumberToString:
.9c50	5a		phy				phy 								; save code position
.9c51	8d 14 04	sta $0414			sta 	DecimalPlaces	 			; save number of DPs.
.9c54	9c 15 04	stz $0415			stz 	dbOffset 					; offset into decimal buffer = start.
.9c57	b5 50		lda $50,x			lda 	NSStatus,x  				; is it -ve.
.9c59	10 09		bpl $9c64			bpl 	_CNTSNotNegative
.9c5b	29 7f		and #$7f			and 	#$7F 						; make +ve
.9c5d	95 50		sta $50,x			sta 	NSStatus,x
.9c5f	a9 2d		lda #$2d			lda 	#"-"
.9c61	20 c5 9c	jsr $9cc5			jsr 	WriteDecimalBuffer
.9c64					_CNTSNotNegative:
.9c64	b5 78		lda $78,x			lda 	NSExponent,x 				; check if decimal
.9c66	f0 12		beq $9c7a			beq 	_CNTSNotFloat
.9c68	e8		inx				inx 								; round up so we don't get too many 6.999999
.9c69	a9 01		lda #$01			lda 	#1
.9c6b	20 1d 9e	jsr $9e1d			jsr 	NSMSetByte
.9c6e	ca		dex				dex
.9c6f	b5 78		lda $78,x			lda		NSExponent,x
.9c71	95 79		sta $79,x			sta 	NSExponent+1,x
.9c73	a9 08		lda #$08			lda 	#NSTFloat
.9c75	95 51		sta $51,x			sta 	NSStatus+1,x
.9c77	20 48 94	jsr $9448			jsr 	FloatAdd
.9c7a					_CNTSNotFloat:
.9c7a	20 a7 9c	jsr $9ca7			jsr 	MakePlusTwoString 			; do the integer part.
.9c7d	20 0e 95	jsr $950e			jsr 	FloatFractionalPart 		; get the fractional part
.9c80	20 bf 95	jsr $95bf			jsr 	NSNormalise					; normalise , exit if zero
.9c83	f0 20		beq $9ca5			beq 	_CNTSExit
.9c85	a9 2e		lda #$2e			lda 	#"."
.9c87	20 c5 9c	jsr $9cc5			jsr 	WriteDecimalBuffer 			; write decimal place
.9c8a					_CNTSDecimal:
.9c8a	ce 14 04	dec $0414			dec 	DecimalPlaces 				; done all the decimals
.9c8d	30 16		bmi $9ca5			bmi 	_CNTSExit
.9c8f	e8		inx				inx 								; x 10.0
.9c90	a9 0a		lda #$0a			lda 	#10
.9c92	20 1d 9e	jsr $9e1d			jsr 	NSMSetByte
.9c95	a9 08		lda #$08			lda 	#NSTFloat
.9c97	95 50		sta $50,x			sta 	NSStatus,x
.9c99	ca		dex				dex
.9c9a	20 8d 95	jsr $958d			jsr 	FloatMultiply
.9c9d	20 a7 9c	jsr $9ca7			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.9ca0	20 0e 95	jsr $950e			jsr 	FloatFractionalPart 		; get the fractional part
.9ca3	80 e5		bra $9c8a			bra 	_CNTSDecimal 				; keep going.
.9ca5					_CNTSExit:
.9ca5	7a		ply				ply
.9ca6	60		rts				rts
.9ca7					MakePlusTwoString:
.9ca7	da		phx				phx
.9ca8	20 fe 9d	jsr $9dfe			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.9cab	e8		inx				inx 								; access it
.9cac	e8		inx				inx
.9cad	20 66 95	jsr $9566			jsr 	FloatIntegerPart 			; make it an integer
.9cb0	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.9cb2	20 78 93	jsr $9378			jsr 	ConvertInt32
.9cb5	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.9cb7					_MPTSCopy:
.9cb7	bd 27 06	lda $0627,x			lda 	NumberBuffer,x
.9cba	20 c5 9c	jsr $9cc5			jsr 	WriteDecimalBuffer
.9cbd	e8		inx				inx
.9cbe	bd 27 06	lda $0627,x			lda 	NumberBuffer,x
.9cc1	d0 f4		bne $9cb7			bne 	_MPTSCopy
.9cc3	fa		plx				plx
.9cc4	60		rts				rts
.9cc5					WriteDecimalBuffer:
.9cc5	da		phx				phx
.9cc6	ae 15 04	ldx $0415			ldx 	dbOffset
.9cc9	9d 49 06	sta $0649,x			sta 	DecimalBuffer,x
.9ccc	9e 4a 06	stz $064a,x			stz 	DecimalBuffer+1,x
.9ccf	ee 15 04	inc $0415			inc 	dbOffset
.9cd2	fa		plx				plx
.9cd3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/substring.asm

.9cd4					Unary_Left:
.9cd4	fa		plx				plx
.9cd5	18		clc				clc 								; only one parameter
.9cd6	20 39 9d	jsr $9d39			jsr 	SubstringInitial 			; set up.
.9cd9	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; Param #1 is the length
.9cdb	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9cdd	74 59		stz $59,x			stz 	NSMantissa0+1,x 			; Start is zero.
.9cdf	80 25		bra $9d06			bra 	SubstringMain
.9ce1					Unary_Right:
.9ce1	fa		plx				plx
.9ce2	18		clc				clc 								; only one parameter
.9ce3	20 39 9d	jsr $9d39			jsr 	SubstringInitial 			; set up.
.9ce6	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; length => param 2
.9ce8	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9cea	b5 78		lda $78,x			lda 	NSExponent,x 				; total length
.9cec	f5 59		sbc $59,x			sbc 	NSMantissa0+1,x 			; length - required.
.9cee	b0 02		bcs $9cf2			bcs 	_URNotUnderflow
.9cf0	a9 00		lda #$00			lda 	#0 							; start from the beginning, as something like right$("AB",3)
.9cf2					_URNotUnderFlow:
.9cf2	95 59		sta $59,x			sta 	NSMantissa0+1,x 			; this is the start position
.9cf4	80 10		bra $9d06			bra 	SubStringMain
.9cf6					Unary_Mid:
.9cf6	fa		plx				plx
.9cf7	38		sec				sec 								; two parameters
.9cf8	20 39 9d	jsr $9d39			jsr 	SubstringInitial 			; set up.
.9cfb	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; first parameter is zero ?
.9cfd	f0 04		beq $9d03			beq 	_UMError
.9cff	d6 59		dec $59,x			dec 	NSMantissa0+1,x				; reduce initial offset by 1 as MID$(a$,1..) is actually the first character
.9d01	80 03		bra $9d06			bra 	SubStringMain
.9d03					_UMError:
.9d03	4c a8 9f	jmp $9fa8			jmp 	ArgumentError
.9d06					SubStringMain:
.9d06	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; is the initial offset >= the length
.9d08	d5 78		cmp $78,x			cmp 	NSExponent,x
.9d0a	b0 27		bcs $9d33			bcs 	_SSMNull 					; if so, return an empty string.
.9d0c	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; if copy count is zero
.9d0e	f0 23		beq $9d33			beq 	_SSMNull 					; return empty string.
.9d10	18		clc				clc 								; add the offset +1 to the address and
.9d11	b5 58		lda $58,x			lda	 	NSMantissa0,x 				; put in zTemp, this is the start of the substring to copy.
.9d13	75 59		adc $59,x			adc 	NSMantissa0+1,x
.9d15	85 36		sta $36				sta 	zTemp0
.9d17	b5 60		lda $60,x			lda	 	NSMantissa1,x
.9d19	69 00		adc #$00			adc 	#0
.9d1b	85 37		sta $37				sta 	zTemp0+1
.9d1d					_SSMNoCarry:
.9d1d	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; characters required.
.9d1f	20 9a a7	jsr $a79a			jsr 	StringTempAllocate 			; allocate that many characters
.9d22	5a		phy				phy 								; save Y
.9d23	a0 00		ldy #$00			ldy 	#0 							; start copying in.
.9d25					_SSMCopy:
.9d25	b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next character
.9d27	f0 08		beq $9d31			beq 	_SSMEString 				; no more to copy
.9d29	20 d3 a7	jsr $a7d3			jsr 	StringTempWrite 			; and write it out.
.9d2c	c8		iny				iny
.9d2d	d6 5a		dec $5a,x			dec 	NSMantissa0+2,x
.9d2f	d0 f4		bne $9d25			bne 	_SSMCopy
.9d31					_SSMEString:
.9d31	7a		ply				ply
.9d32					_SSMExit:
.9d32	60		rts				rts
.9d33					_SSMNull:
.9d33	a9 00		lda #$00			lda 	#0
.9d35	20 9a a7	jsr $a79a			jsr 	StringTempAllocate
.9d38	60		rts				rts
.9d39					SubstringInitial:
.9d39	da		phx				phx 								; save initial stack position
.9d3a	08		php				php 								; save carry on stack indicating 2 parameters
.9d3b	20 73 9d	jsr $9d73			jsr 	EvaluateString 				; get a string
.9d3e	5a		phy				phy 								; calculate length to exponent.
.9d3f	a0 ff		ldy #$ff			ldy 	#$FF
.9d41					_SIFindLength:
.9d41	c8		iny				iny
.9d42	b1 36		lda ($36),y			lda 	(zTemp0),y
.9d44	d0 fb		bne $9d41			bne 	_SIFindLength
.9d46	98		tya				tya
.9d47	95 78		sta $78,x			sta 	NSExponent,x
.9d49	7a		ply				ply
.9d4a	e8		inx				inx
.9d4b	20 e8 8e	jsr $8ee8			jsr 	CheckComma 					; comma next
.9d4e	20 b6 9d	jsr $9db6			jsr 	Evaluate8BitInteger 		; get next parameter
.9d51	28		plp				plp 								; is it the last parameter ?
.9d52	90 07		bcc $9d5b			bcc 	_SSIExit 					; if so, exit.
.9d54	e8		inx				inx
.9d55	20 e8 8e	jsr $8ee8			jsr 	CheckComma 					; comma next
.9d58	20 b6 9d	jsr $9db6			jsr 	Evaluate8BitInteger 		; get last parameter
.9d5b					_SSIExit:
.9d5b	fa		plx				plx
.9d5c	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket 			; check closing bracket
.9d5f	60		rts				rts 								; exit

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/exprhelper.asm

.9d60					EvaluateValue:
.9d60	48		pha				pha
.9d61	20 fd 93	jsr $93fd			jsr		EvaluateExpression 			; expression
.9d64	20 c0 96	jsr $96c0			jsr 	Dereference					; derefernce it
.9d67	68		pla				pla
.9d68	60		rts				rts
.9d69					EvaluateNumber:
.9d69	20 60 9d	jsr $9d60			jsr 	EvaluateValue 				; get a value
.9d6c	b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.9d6e	29 10		and #$10			and 	#NSBIsString
.9d70	d0 13		bne $9d85			bne 	HelperTypeError
.9d72	60		rts				rts
.9d73					EvaluateString:
.9d73	20 60 9d	jsr $9d60			jsr 	EvaluateValue 				; get a value
.9d76	b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.9d78	29 10		and #$10			and 	#NSBIsString
.9d7a	f0 09		beq $9d85			beq 	HelperTypeError
.9d7c					CopyAddressToTemp0:
.9d7c	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address -> zTemp0
.9d7e	85 36		sta $36				sta 	zTemp0 						; (so we can do something with it)
.9d80	b5 60		lda $60,x			lda 	NSMantissa1,x
.9d82	85 37		sta $37				sta 	zTemp0+1
.9d84	60		rts				rts
.9d85					HelperTypeError:
.9d85	4c a3 9f	jmp $9fa3			jmp 	TypeError
.9d88					EvaluateInteger:
.9d88	20 69 9d	jsr $9d69			jsr 	EvaluateNumber
.9d8b	b5 78		lda $78,x			lda 	NSExponent,x 				; check exponent is zero
.9d8d	d0 09		bne $9d98			bne 	HelperValueError 			; if not, it's a float.
.9d8f	60		rts				rts
.9d90					EvaluateUnsignedInteger:
.9d90	20 88 9d	jsr $9d88			jsr 	EvaluateInteger 			; check integer is +ve
.9d93	b5 50		lda $50,x			lda 	NSStatus,x
.9d95	30 01		bmi $9d98			bmi 	HelperValueError
.9d97	60		rts				rts
.9d98					HelperValueError:
.9d98	4c a8 9f	jmp $9fa8			jmp 	ArgumentError
.9d9b					Evaluate16BitInteger:
.9d9b	20 90 9d	jsr $9d90			jsr	 	EvaluateUnsignedInteger		; get integer
.9d9e	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9da0	15 68		ora $68,x			ora 	NSMantissa2,x
.9da2	d0 f4		bne $9d98			bne 	HelperValueError
.9da4	60		rts				rts
.9da5					Evaluate16BitIntegerSigned:
.9da5	20 88 9d	jsr $9d88			jsr	 	EvaluateInteger				; get integer
.9da8	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9daa	15 68		ora $68,x			ora 	NSMantissa2,x
.9dac	d0 ea		bne $9d98			bne 	HelperValueError
.9dae	b5 50		lda $50,x			lda 	NSStatus,x 					; signed ?
.9db0	10 03		bpl $9db5			bpl 	_EISNotSigned
.9db2	20 e4 9d	jsr $9de4			jsr 	NSMNegateMantissa 			; makes it an actual 2's complement value.
.9db5					_EISNotSigned:
.9db5	60		rts				rts
.9db6					Evaluate8BitInteger:
.9db6	20 90 9d	jsr $9d90			jsr	 	EvaluateUnsignedInteger 	; get an integer
.9db9	d0 dd		bne $9d98			bne 	HelperValueError
.9dbb	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 1, 2 & 3 must be zero
.9dbd	15 68		ora $68,x			ora 	NSMantissa2,x
.9dbf	15 60		ora $60,x			ora 	NSMantissa1,x
.9dc1	d0 d5		bne $9d98			bne 	HelperValueError
.9dc3	b5 58		lda $58,x			lda 	NSMantissa0,x
.9dc5	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/mult8x8.asm

.9dc6					Multiply8x8:
.9dc6	4a		lsr a		  		lsr 	a  							; prime the carry bit for the loop
.9dc7	85 36		sta $36			  	sta 	zTemp0
.9dc9	86 37		stx $37				stx 	zTemp0+1
.9dcb	a9 00		lda #$00			lda 	#0
.9dcd	a2 08		ldx #$08			ldx 	#8
.9dcf					_M88Loop:
.9dcf	90 03		bcc $9dd4			bcc 	_M88NoAdd
.9dd1	18		clc				clc
.9dd2	65 37		adc $37				adc 	zTemp0+1
.9dd4					_M88NoAdd:
.9dd4	6a		ror a				ror 	a
.9dd5	66 36		ror $36				ror 	zTemp0  					; pull another bit out for the next iteration
.9dd7	ca		dex				dex         						; inc/dec don't modify carry; only shifts and adds do
.9dd8	d0 f5		bne $9dcf			bne 	_M88Loop
.9dda	85 37		sta $37				sta 	zTemp0+1 					; store high 8 bits.
.9ddc	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/utility.asm

.9ddd					NSMNegate:
.9ddd	b5 50		lda $50,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.9ddf	49 80		eor #$80			eor 	#NSBIsNegative  			; toggle the negative flag
.9de1	95 50		sta $50,x			sta 	NSStatus,x
.9de3	60		rts				rts
.9de4					NSMNegateMantissa:
.9de4	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.9de5	a9 00		lda #$00			lda 	#0
.9de7	f5 58		sbc $58,x			sbc 	NSMantissa0,x
.9de9	95 58		sta $58,x			sta 	NSMantissa0,x
.9deb	a9 00		lda #$00			lda 	#0
.9ded	f5 60		sbc $60,x			sbc 	NSMantissa1,x
.9def	95 60		sta $60,x			sta 	NSMantissa1,x
.9df1	a9 00		lda #$00			lda 	#0
.9df3	f5 68		sbc $68,x			sbc 	NSMantissa2,x
.9df5	95 68		sta $68,x			sta 	NSMantissa2,x
.9df7	a9 00		lda #$00			lda 	#0
.9df9	f5 70		sbc $70,x			sbc 	NSMantissa3,x
.9dfb	95 70		sta $70,x			sta 	NSMantissa3,x
.9dfd	60		rts				rts
.9dfe					NSMShiftUpTwo:
.9dfe	b5 58		lda $58,x			lda 	NSMantissa0,x
.9e00	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9e02	b5 60		lda $60,x			lda 	NSMantissa1,x
.9e04	95 62		sta $62,x			sta 	NSMantissa1+2,x
.9e06	b5 68		lda $68,x			lda 	NSMantissa2,x
.9e08	95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.9e0a	b5 70		lda $70,x			lda 	NSMantissa3,x
.9e0c	95 72		sta $72,x			sta 	NSMantissa3+2,x
.9e0e	b5 78		lda $78,x			lda 	NSExponent,x
.9e10	95 7a		sta $7a,x			sta 	NSExponent+2,x
.9e12	b5 50		lda $50,x			lda 	NSStatus,x
.9e14	95 52		sta $52,x			sta 	NSStatus+2,x
.9e16	60		rts				rts
.9e17					NSMSetZeroMantissaOnly:
.9e17	a9 00		lda #$00			lda 	#0
.9e19	80 06		bra $9e21			bra 	NSMSetMantissa
.9e1b					NSMSetZero:
.9e1b	a9 00		lda #$00			lda 	#0
.9e1d					NSMSetByte:
.9e1d	74 78		stz $78,x			stz 	NSExponent,x 				; zero exponent, as integer.
.9e1f	74 50		stz $50,x			stz 	NSStatus,x 					; status zero (integer)
.9e21					NSMSetMantissa:
.9e21	95 58		sta $58,x			sta 	NSMantissa0,x 				; mantissa
.9e23	74 60		stz $60,x			stz 	NSMantissa1,x
.9e25	74 68		stz $68,x			stz 	NSMantissa2,x
.9e27	74 70		stz $70,x			stz 	NSMantissa3,x
.9e29	60		rts				rts
.9e2a					NSMShiftLeft:
.9e2a	18		clc				clc
.9e2b					NSMRotateLeft:
.9e2b	36 58		rol $58,x			rol 	NSMantissa0,x
.9e2d	36 60		rol $60,x			rol		NSMantissa1,x
.9e2f	36 68		rol $68,x			rol		NSMantissa2,x
.9e31	36 70		rol $70,x			rol		NSMantissa3,x
.9e33	60		rts				rts
.9e34					NSMShiftRight:
.9e34	56 70		lsr $70,x			lsr 	NSMantissa3,x
.9e36	76 68		ror $68,x			ror		NSMantissa2,x
.9e38	76 60		ror $60,x			ror		NSMantissa1,x
.9e3a	76 58		ror $58,x			ror		NSMantissa0,x
.9e3c	60		rts				rts
.9e3d					NSMIsZero:
.9e3d	b5 70		lda $70,x			lda 	NSMantissa3,x
.9e3f	15 68		ora $68,x			ora		NSMantissa2,x
.9e41	15 60		ora $60,x			ora		NSMantissa1,x
.9e43	15 58		ora $58,x			ora		NSMantissa0,x
.9e45	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.asm

.9e46					TickHandler:
.9e46	5a		phy				phy 								; need to preserve Y
.9e47	20 1b 80	jsr $801b			jsr 	SNDUpdate 					; update sound
.9e4a	7a		ply				ply
.9e4b	60		rts				rts
.065c					LastTick:
>065c							.fill 		1

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/asmcore.asm

.9e4c					Assemble_ora:
.9e4c	20 b1 80	jsr $80b1		jsr	AssembleGroup1
>9e4f	01					.byte $01
.9e50					Assemble_and:
.9e50	20 b1 80	jsr $80b1		jsr	AssembleGroup1
>9e53	21					.byte $21
.9e54					Assemble_eor:
.9e54	20 b1 80	jsr $80b1		jsr	AssembleGroup1
>9e57	41					.byte $41
.9e58					Assemble_adc:
.9e58	20 b1 80	jsr $80b1		jsr	AssembleGroup1
>9e5b	61					.byte $61
.9e5c					Assemble_sta:
.9e5c	20 b1 80	jsr $80b1		jsr	AssembleGroup1
>9e5f	81					.byte $81
.9e60					Assemble_lda:
.9e60	20 b1 80	jsr $80b1		jsr	AssembleGroup1
>9e63	a1					.byte $a1
.9e64					Assemble_cmp:
.9e64	20 b1 80	jsr $80b1		jsr	AssembleGroup1
>9e67	c1					.byte $c1
.9e68					Assemble_sbc:
.9e68	20 b1 80	jsr $80b1		jsr	AssembleGroup1
>9e6b	e1					.byte $e1
.9e6c					Assemble_asl:
.9e6c	20 b8 80	jsr $80b8		jsr	AssembleGroup2
>9e6f	02					.byte $02
>9e70	75					.byte $75
.9e71					Assemble_rol:
.9e71	20 b8 80	jsr $80b8		jsr	AssembleGroup2
>9e74	22					.byte $22
>9e75	75					.byte $75
.9e76					Assemble_lsr:
.9e76	20 b8 80	jsr $80b8		jsr	AssembleGroup2
>9e79	42					.byte $42
>9e7a	75					.byte $75
.9e7b					Assemble_ror:
.9e7b	20 b8 80	jsr $80b8		jsr	AssembleGroup2
>9e7e	62					.byte $62
>9e7f	75					.byte $75
.9e80					Assemble_stx:
.9e80	20 b8 80	jsr $80b8		jsr	AssembleGroup2
>9e83	82					.byte $82
>9e84	50					.byte $50
.9e85					Assemble_ldx:
.9e85	20 b8 80	jsr $80b8		jsr	AssembleGroup2
>9e88	a2					.byte $a2
>9e89	d0					.byte $d0
.9e8a					Assemble_dec:
.9e8a	20 b8 80	jsr $80b8		jsr	AssembleGroup2
>9e8d	c2					.byte $c2
>9e8e	55					.byte $55
.9e8f					Assemble_inc:
.9e8f	20 b8 80	jsr $80b8		jsr	AssembleGroup2
>9e92	e2					.byte $e2
>9e93	55					.byte $55
.9e94					Assemble_stz:
.9e94	20 b8 80	jsr $80b8		jsr	AssembleGroup2
>9e97	60					.byte $60
>9e98	44					.byte $44
.9e99					Assemble_bit:
.9e99	20 b8 80	jsr $80b8		jsr	AssembleGroup2
>9e9c	20					.byte $20
>9e9d	55					.byte $55
.9e9e					Assemble_sty:
.9e9e	20 b8 80	jsr $80b8		jsr	AssembleGroup2
>9ea1	80					.byte $80
>9ea2	54					.byte $54
.9ea3					Assemble_ldy:
.9ea3	20 b8 80	jsr $80b8		jsr	AssembleGroup2
>9ea6	a0					.byte $a0
>9ea7	d5					.byte $d5
.9ea8					Assemble_cpy:
.9ea8	20 b8 80	jsr $80b8		jsr	AssembleGroup2
>9eab	c0					.byte $c0
>9eac	d4					.byte $d4
.9ead					Assemble_cpx:
.9ead	20 b8 80	jsr $80b8		jsr	AssembleGroup2
>9eb0	e0					.byte $e0
>9eb1	d0					.byte $d0
.9eb2					Assemble_tsb:
.9eb2	20 b8 80	jsr $80b8		jsr	AssembleGroup2
>9eb5	00					.byte $00
>9eb6	50					.byte $50
.9eb7					Assemble_trb:
.9eb7	20 b8 80	jsr $80b8		jsr	AssembleGroup2
>9eba	10					.byte $10
>9ebb	50					.byte $50
.9ebc					Assemble_jsr:
.9ebc	20 b8 80	jsr $80b8		jsr	AssembleGroup2
>9ebf	14					.byte $14
>9ec0	10					.byte $10
.9ec1					Assemble_jmp:
.9ec1	20 b8 80	jsr $80b8		jsr	AssembleGroup2
>9ec4	40					.byte $40
>9ec5	10					.byte $10
.9ec6					Assemble_bpl:
.9ec6	20 09 81	jsr $8109		jsr	AssembleGroup3
>9ec9	10					.byte $10
.9eca					Assemble_bmi:
.9eca	20 09 81	jsr $8109		jsr	AssembleGroup3
>9ecd	30					.byte $30
.9ece					Assemble_bvc:
.9ece	20 09 81	jsr $8109		jsr	AssembleGroup3
>9ed1	50					.byte $50
.9ed2					Assemble_bvs:
.9ed2	20 09 81	jsr $8109		jsr	AssembleGroup3
>9ed5	70					.byte $70
.9ed6					Assemble_bcc:
.9ed6	20 09 81	jsr $8109		jsr	AssembleGroup3
>9ed9	90					.byte $90
.9eda					Assemble_bcs:
.9eda	20 09 81	jsr $8109		jsr	AssembleGroup3
>9edd	b0					.byte $b0
.9ede					Assemble_bne:
.9ede	20 09 81	jsr $8109		jsr	AssembleGroup3
>9ee1	d0					.byte $d0
.9ee2					Assemble_beq:
.9ee2	20 09 81	jsr $8109		jsr	AssembleGroup3
>9ee5	f0					.byte $f0
.9ee6					Assemble_bra:
.9ee6	20 09 81	jsr $8109		jsr	AssembleGroup3
>9ee9	80					.byte $80
.9eea					Assemble_brk:
.9eea	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9eed	00					.byte $00
.9eee					Assemble_php:
.9eee	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9ef1	08					.byte $08
.9ef2					Assemble_clc:
.9ef2	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9ef5	18					.byte $18
.9ef6					Assemble_plp:
.9ef6	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9ef9	28					.byte $28
.9efa					Assemble_sec:
.9efa	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9efd	38					.byte $38
.9efe					Assemble_rti:
.9efe	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f01	40					.byte $40
.9f02					Assemble_pha:
.9f02	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f05	48					.byte $48
.9f06					Assemble_cli:
.9f06	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f09	58					.byte $58
.9f0a					Assemble_phy:
.9f0a	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f0d	5a					.byte $5a
.9f0e					Assemble_rts:
.9f0e	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f11	60					.byte $60
.9f12					Assemble_pla:
.9f12	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f15	68					.byte $68
.9f16					Assemble_sei:
.9f16	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f19	78					.byte $78
.9f1a					Assemble_ply:
.9f1a	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f1d	7a					.byte $7a
.9f1e					Assemble_dey:
.9f1e	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f21	88					.byte $88
.9f22					Assemble_txa:
.9f22	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f25	8a					.byte $8a
.9f26					Assemble_tya:
.9f26	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f29	98					.byte $98
.9f2a					Assemble_txs:
.9f2a	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f2d	9a					.byte $9a
.9f2e					Assemble_tay:
.9f2e	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f31	a8					.byte $a8
.9f32					Assemble_tax:
.9f32	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f35	aa					.byte $aa
.9f36					Assemble_clv:
.9f36	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f39	b8					.byte $b8
.9f3a					Assemble_tsx:
.9f3a	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f3d	ba					.byte $ba
.9f3e					Assemble_iny:
.9f3e	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f41	c8					.byte $c8
.9f42					Assemble_dex:
.9f42	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f45	ca					.byte $ca
.9f46					Assemble_cld:
.9f46	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f49	d8					.byte $d8
.9f4a					Assemble_phx:
.9f4a	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f4d	da					.byte $da
.9f4e					Assemble_stp:
.9f4e	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f51	db					.byte $db
.9f52					Assemble_inx:
.9f52	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f55	e8					.byte $e8
.9f56					Assemble_nop:
.9f56	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f59	ea					.byte $ea
.9f5a					Assemble_sed:
.9f5a	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f5d	f8					.byte $f8
.9f5e					Assemble_plx:
.9f5e	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f61	fa					.byte $fa

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/constants.asm

.9f62					DecimalScalarTable:
>9f62	66 66 66 66				.dword $66666666 ; 0.1
>9f66	de					.byte $de
>9f67	1f 85 eb 51				.dword $51eb851f ; 0.01
>9f6b	db					.byte $db
>9f6c	4c 37 89 41				.dword $4189374c ; 0.001
>9f70	d8					.byte $d8
>9f71	ac 8b db 68				.dword $68db8bac ; 0.0001
>9f75	d4					.byte $d4
>9f76	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>9f7a	d1					.byte $d1
>9f7b	83 de 1b 43				.dword $431bde83 ; 1e-06
>9f7f	ce					.byte $ce
>9f80	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>9f84	ca					.byte $ca
>9f85	89 3b e6 55				.dword $55e63b89 ; 1e-08
>9f89	c7					.byte $c7
>9f8a	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>9f8e	c4					.byte $c4
>9f8f	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>9f93	c0					.byte $c0
>9f94	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>9f98	bd					.byte $bd

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.asm

.9f99					SyntaxError:
.9f99	a9 02		lda #$02		lda	#2
.9f9b	4c f9 8e	jmp $8ef9		jmp	ErrorHandler
.9f9e					RangeError:
.9f9e	a9 04		lda #$04		lda	#4
.9fa0	4c f9 8e	jmp $8ef9		jmp	ErrorHandler
.9fa3					TypeError:
.9fa3	a9 05		lda #$05		lda	#5
.9fa5	4c f9 8e	jmp $8ef9		jmp	ErrorHandler
.9fa8					ArgumentError:
.9fa8	a9 07		lda #$07		lda	#7
.9faa	4c f9 8e	jmp $8ef9		jmp	ErrorHandler
.9fad					NotDoneError:
.9fad	a9 0c		lda #$0c		lda	#12
.9faf	4c f9 8e	jmp $8ef9		jmp	ErrorHandler
.9fb2					ErrorText:
>9fb2	42 72 65 61 6b 00			.text	"Break",0
>9fb8	53 79 6e 74 61 78 20 65			.text	"Syntax error",0
>9fc0	72 72 6f 72 00
>9fc5	44 69 76 69 73 69 6f 6e			.text	"Division by zero",0
>9fcd	20 62 79 20 7a 65 72 6f 00
>9fd6	4f 75 74 20 6f 66 20 52			.text	"Out of Range",0
>9fde	61 6e 67 65 00
>9fe3	54 79 70 65 20 6d 69 73			.text	"Type mismatch",0
>9feb	6d 61 74 63 68 00
>9ff1	4f 75 74 20 6f 66 20 6d			.text	"Out of memory",0
>9ff9	65 6d 6f 72 79 00
>9fff	49 6c 6c 65 67 61 6c 20			.text	"Illegal argument",0
>a007	61 72 67 75 6d 65 6e 74 00
>a010	53 74 6f 70 00				.text	"Stop",0
>a015	53 74 72 69 6e 67 20 74			.text	"String too long",0
>a01d	6f 6f 20 6c 6f 6e 67 00
>a025	41 73 73 65 72 74 69 6f			.text	"Assertion failed",0
>a02d	6e 20 66 61 69 6c 65 64 00
>a036	4f 75 74 20 6f 66 20 64			.text	"Out of data",0
>a03e	61 74 61 00
>a042	55 6e 69 6d 70 6c 65 6d			.text	"Unimplemented",0
>a04a	65 6e 74 65 64 00
>a050	4e 6f 20 73 75 63 68 20			.text	"No such line number",0
>a058	6c 69 6e 65 20 6e 75 6d 62 65 72 00
>a064	52 65 74 75 72 6e 20 77			.text	"Return without Gosub",0
>a06c	69 74 68 6f 75 74 20 47 6f 73 75 62 00
>a079	55 6e 74 69 6c 20 77 69			.text	"Until without Repeat",0
>a081	74 68 6f 75 74 20 52 65 70 65 61 74 00
>a08e	57 65 6e 64 20 77 69 74			.text	"Wend without While",0
>a096	68 6f 75 74 20 57 68 69 6c 65 00
>a0a1	4e 65 78 74 20 77 69 74			.text	"Next without For",0
>a0a9	68 6f 75 74 20 46 6f 72 00
>a0b2	42 41 53 49 43 20 53 74			.text	"BASIC Stack full",0
>a0ba	61 63 6b 20 66 75 6c 6c 00
>a0c3	4f 70 65 6e 20 53 74 72			.text	"Open Structure",0
>a0cb	75 63 74 75 72 65 00
>a0d2	45 6e 64 50 72 6f 63 20			.text	"EndProc without call",0
>a0da	77 69 74 68 6f 75 74 20 63 61 6c 6c 00
>a0e7	41 72 72 61 79 20 61 6c			.text	"Array already defined",0
>a0ef	72 65 61 64 79 20 64 65 66 69 6e 65 64 00
>a0fd	41 72 72 61 79 20 73 69			.text	"Array size",0
>a105	7a 65 00
>a108	42 61 64 20 61 72 72 61			.text	"Bad array index",0
>a110	79 20 69 6e 64 65 78 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/timestamp.asm

>a118	41 6c 70 68 61 20 31 32			.text "Alpha 12 built 06-Dec-22. "
>a120	20 62 75 69 6c 74 20 30 36 2d 44 65 63 2d 32 32
>a130	2e 20

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcommand.asm

.a132					RectangleCommand:
.a132	a9 44		lda #$44			lda 	#GCMD_FrameRect				; frame rectangle
.a134	80 02		bra $a138			bra 	ShapeDrawCmd
.a136					CircleCommand:
.a136	a9 48		lda #$48			lda 	#GCMD_FrameCircle 				; framed circle
.a138					ShapeDrawCmd:
.a138	20 c2 a1	jsr $a1c2			jsr 	RunGraphicsCommand
.a13b					ShapeDraw:
.a13b	0d 5e 06	ora $065e			ora 	gxFillSolid  				; adjust AXY for solid fill.
.a13e	4c b6 a1	jmp $a1b6			jmp 	ExecuteGraphicCommand	 	; and complete
.a141					SpriteCommand:
.a141	a2 00		ldx #$00			ldx 	#0
.a143	20 b6 9d	jsr $9db6			jsr 	Evaluate8BitInteger 		; get image number.
.a146	5a		phy				phy
.a147	a9 0e		lda #$0e			lda 	#GCMD_SpriteUse 			; use that image.
.a149	a6 58		ldx $58				ldx 	NSMantissa0
.a14b	e0 40		cpx #$40			cpx 	#64 						; 0-63 only
.a14d	b0 0d		bcs $a15c			bcs 	_SCRange
.a14f	a0 ff		ldy #$ff			ldy 	#255
.a151	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a154	a9 52		lda #$52			lda 	#GCMD_SpriteMove
.a156	7a		ply				ply
.a157	20 c2 a1	jsr $a1c2			jsr 	RunGraphicsCommand
.a15a	80 5a		bra $a1b6			bra 	ExecuteGraphicCommand
.a15c					_SCRange:
.a15c	4c 9e 9f	jmp $9f9e			jmp 	RangeError
.a15f					ImageCommand:
.a15f	a2 00		ldx #$00			ldx 	#0
.a161	20 b6 9d	jsr $9db6			jsr 	Evaluate8BitInteger 		; get image number.
.a164	20 c2 a1	jsr $a1c2			jsr 	RunGraphicsCommand
.a167					ImageRunDraw:
.a167	09 40		ora #$40			ora 	#GCMD_Move					; move cursor
.a169	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a16c	ad 64 06	lda $0664			lda 	gxDrawScale
.a16f	0a		asl a				asl 	a
.a170	0a		asl a				asl 	a
.a171	0a		asl a				asl 	a
.a172	a8		tay				tay
.a173	a9 0c		lda #$0c			lda 	#GCMD_DrawSprite 			; image drawing
.a175	a6 58		ldx $58				ldx 	NSMantissa0
.a177	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a17a	60		rts				rts
.a17b					TextCommand:
.a17b	a2 00		ldx #$00			ldx 	#0
.a17d	20 73 9d	jsr $9d73			jsr 	EvaluateString 				; get text
.a180	20 c2 a1	jsr $a1c2			jsr 	RunGraphicsCommand
.a183					TextRunDraw:
.a183	09 40		ora #$40			ora 	#GCMD_Move 					; move cursor
.a185	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a188	a0 00		ldy #$00			ldy 	#0
.a18a					_IRDLoop:
.a18a	a5 60		lda $60				lda 	NSMantissa1 				; access character
.a18c	85 37		sta $37				sta 	zTemp0+1
.a18e	a5 58		lda $58				lda 	NSMantissa0
.a190	85 36		sta $36				sta 	zTemp0
.a192	b1 36		lda ($36),y			lda 	(zTemp0),y
.a194	f0 13		beq $a1a9			beq 	_IRDExit
.a196	5a		phy				phy									; save string pos
.a197	48		pha				pha 								; save char
.a198	ad 64 06	lda $0664			lda 	gxDrawScale 				; get scale
.a19b	0a		asl a				asl 	a
.a19c	0a		asl a				asl 	a
.a19d	0a		asl a				asl 	a
.a19e	a8		tay				tay
.a19f	a9 0a		lda #$0a			lda 	#GCMD_DrawFont 				; char drawing
.a1a1	fa		plx				plx 								; char to draw
.a1a2	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a1a5	7a		ply				ply 								; restore string pos
.a1a6	c8		iny				iny
.a1a7	90 e1		bcc $a18a			bcc 	_IRDLoop 					; go back if no error.
.a1a9					_IRDExit:
.a1a9	60		rts				rts
.a1aa					PlotCommand:
.a1aa	a9 50		lda #$50			lda 	#GCMD_Plot 					; command ID to use
.a1ac	20 c2 a1	jsr $a1c2			jsr 	RunGraphicsCommand
.a1af	80 05		bra $a1b6			bra 	ExecuteGraphicCommand
.a1b1					LineCommand:
.a1b1	a9 42		lda #$42			lda 	#GCMD_Line 						; command ID to use
.a1b3	20 c2 a1	jsr $a1c2			jsr 	RunGraphicsCommand
.a1b6					ExecuteGraphicCommand:
.a1b6	0d 5d 06	ora $065d			ora 	gxCommandID 				; make a full command
.a1b9	20 15 80	jsr $8015			jsr 	GXGraphicDraw 				; draw it and exit
.a1bc	b0 01		bcs $a1bf			bcs 	_EGCError
.a1be	60		rts				rts
.a1bf					_EGCError:
.a1bf	4c 99 9f	jmp $9f99			jmp 	SyntaxError
.a1c2					RunGraphicsCommand:
.a1c2	8d 5d 06	sta $065d			sta 	gxCommandID					; save TODO graphics command.
.a1c5	68		pla				pla 								; pop handler address
.a1c6	fa		plx				plx
.a1c7	1a		inc a				inc 	a
.a1c8	d0 01		bne $a1cb			bne 	_RGINoCarry
.a1ca	e8		inx				inx
.a1cb					_RGINoCarry:
.a1cb	8d 62 06	sta $0662			sta 	GXHandler
.a1ce	8e 63 06	stx $0663			stx 	GXHandler+1
.a1d1					_RGICommandLoop:
.a1d1	b1 30		lda ($30),y			lda 	(codePtr),y
.a1d3	c8		iny				iny
.a1d4	c9 d2		cmp #$d2			cmp 	#KWD_TO						; is it TO x,y
.a1d6	f0 53		beq $a22b			beq 	_RGI_To
.a1d8	c9 bd		cmp #$bd			cmp 	#KWD_HERE 					; do it here.
.a1da	f0 55		beq $a231			beq 	_RGI_Here
.a1dc	c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL or : , exit
.a1de	f0 3d		beq $a21d			beq 	_RGI_Exit
.a1e0	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.a1e2	f0 39		beq $a21d			beq 	_RGI_Exit
.a1e4	c9 c5		cmp #$c5			cmp 	#KWD_OUTLINE 				; solid or outline
.a1e6	f0 3e		beq $a226			beq 	_RGI_Frame
.a1e8	c9 ce		cmp #$ce			cmp 	#KWD_SOLID
.a1ea	f0 33		beq $a21f			beq 	_RGI_Solid
.a1ec	c9 ad		cmp #$ad			cmp 	#KWD_BY 					; by offset
.a1ee	f0 4b		beq $a23b			beq 	_RGI_By
.a1f0	c9 b9		cmp #$b9			cmp 	#KWD_FROM 					; from
.a1f2	f0 17		beq $a20b			beq 	_RGI_Move2
.a1f4	c9 b5		cmp #$b5			cmp 	#KWD_DIM 					; dim (set scale)
.a1f6	f0 62		beq $a25a			beq 	_RGI_Dim
.a1f8	c9 b3		cmp #$b3			cmp 	#KWD_COLOUR 				; colour or Color
.a1fa	f0 74		beq $a270			beq 	_RGI_Colour
.a1fc	c9 b2		cmp #$b2			cmp 	#KWD_COLOR
.a1fe	f0 70		beq $a270			beq 	_RGI_Colour
.a200	ae 5d 06	ldx $065d			ldx 	gxCommandID
.a203	e0 52		cpx #$52			cpx 	#GCMD_SpriteMove 			; if not sprite
.a205	d0 03		bne $a20a			bne 	_RGI_Move 					; move
.a207	4c 98 a2	jmp $a298			jmp		_RGI_SpriteInstructions
.a20a					_RGI_Move:
.a20a	88		dey				dey 								; unpick get.
.a20b					_RGI_Move2:
.a20b	20 be a2	jsr $a2be			jsr 	GCGetCoordinatePair 		; move to here
.a20e	20 e5 a2	jsr $a2e5			jsr 	GCCopyPairToStore 			; save
.a211	5a		phy				phy
.a212	20 db a2	jsr $a2db			jsr 	GCLoadAXY 					; load in
.a215	09 40		ora #$40			ora 	#GCMD_Move 					; move there
.a217	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a21a	7a		ply				ply
.a21b	80 b4		bra $a1d1			bra 	_RGICommandLoop 			; and go round
.a21d					_RGI_Exit:
.a21d	88		dey				dey 								; unpick : / EOL
.a21e	60		rts				rts
.a21f					_RGI_Solid:
.a21f	a9 02		lda #$02			lda 	#2
.a221	8d 5e 06	sta $065e			sta 	gxFillSolid
.a224	80 ab		bra $a1d1			bra 	_RGICommandLoop
.a226					_RGI_Frame:
.a226	9c 5e 06	stz $065e			stz 	gxFillSolid
.a229	80 a6		bra $a1d1			bra 	_RGICommandLoop
.a22b					_RGI_To:
.a22b	20 be a2	jsr $a2be			jsr 	GCGetCoordinatePair 		; get coordinate pair into slot #1,#2
.a22e	20 e5 a2	jsr $a2e5			jsr 	GCCopyPairToStore
.a231					_RGI_Here:
.a231	5a		phy				phy
.a232	20 db a2	jsr $a2db			jsr 	GCLoadAXY 					; load it into AXY
.a235	20 95 a2	jsr $a295			jsr 	_RGICallHandler 			; go do whatever it is.
.a238	7a		ply				ply
.a239	80 96		bra $a1d1			bra 	_RGICommandLoop 			; and go round
.a23b					_RGI_By:
.a23b	20 cb a2	jsr $a2cb			jsr 	GCSignedCoordinatePair 		; get coordinate pair into slot #1,#2
.a23e	18		clc				clc
.a23f	a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.a241	6d 5f 06	adc $065f			adc 	gxxPos
.a244	8d 5f 06	sta $065f			sta 	gxXPos
.a247	a5 61		lda $61				lda 	NSMantissa1+1
.a249	6d 60 06	adc $0660			adc 	gxxPos+1
.a24c	8d 60 06	sta $0660			sta 	gxXPos+1
.a24f	a5 5a		lda $5a				lda 	NSMantissa0+2
.a251	18		clc				clc
.a252	6d 61 06	adc $0661			adc 	gxYPos
.a255	8d 61 06	sta $0661			sta 	gxYPos
.a258	80 d7		bra $a231			bra 	_RGI_Here
.a25a					_RGI_Dim:
.a25a	a2 01		ldx #$01			ldx	 	#1
.a25c	20 b6 9d	jsr $9db6			jsr 	Evaluate8BitInteger
.a25f	a5 59		lda $59				lda 	NSMantissa0+1
.a261	c9 00		cmp #$00			cmp 	#0
.a263	f0 2d		beq $a292			beq 	_RGIRange
.a265	c9 09		cmp #$09			cmp 	#8+1
.a267	b0 29		bcs $a292			bcs		_RGIRange
.a269	3a		dec a				dec 	a
.a26a	8d 64 06	sta $0664			sta 	gxDrawScale
.a26d	4c d1 a1	jmp $a1d1			jmp 	_RGICommandLoop
.a270					_RGI_Colour:
.a270	a2 01		ldx #$01			ldx 	#1 							; colour
.a272	20 b6 9d	jsr $9db6			jsr 	Evaluate8BitInteger
.a275	a2 02		ldx #$02			ldx 	#2 							; default zero for 2nd parameter
.a277	20 1b 9e	jsr $9e1b			jsr 	NSMSetZero
.a27a	b1 30		lda ($30),y			lda 	(codePtr),y
.a27c	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; check , => mode.
.a27e	d0 04		bne $a284			bne 	_RGICDefaultMode
.a280	c8		iny				iny
.a281	20 b6 9d	jsr $9db6			jsr 	Evaluate8BitInteger
.a284					_RGICDefaultMode:
.a284	5a		phy				phy
.a285	a9 08		lda #$08			lda 	#GCMD_Colour 				; set colour.
.a287	a6 59		ldx $59				ldx 	NSMantissa0+1
.a289	a4 5a		ldy $5a				ldy 	NSMantissa0+2
.a28b	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a28e	7a		ply				ply
.a28f	4c d1 a1	jmp $a1d1			jmp 	_RGICommandLoop 			; and go round
.a292					_RGIRange:
.a292	4c 9e 9f	jmp $9f9e			jmp 	RangeError
.a295					_RGICallHandler:
.a295	6c 62 06	jmp ($0662)			jmp 	(GXHandler)
.a298					_RGI_SpriteInstructions:
.a298	c9 c3		cmp #$c3			cmp 	#KWD_OFF
.a29a	f0 07		beq $a2a3			beq 	_RGISpriteOff
.a29c	c9 be		cmp #$be			cmp 	#KWD_IMAGE
.a29e	f0 13		beq $a2b3			beq 	_RGISetImage
.a2a0	4c 0a a2	jmp $a20a			jmp 	_RGI_Move
.a2a3					_RGISpriteOff:
.a2a3	5a		phy				phy
.a2a4	a0 01		ldy #$01			ldy 	#1
.a2a6	a2 00		ldx #$00			ldx 	#0
.a2a8					_RGIDoCommandLoop:
.a2a8	a9 10		lda #$10			lda 	#GCMD_SpriteImage
.a2aa	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a2ad	7a		ply				ply
.a2ae	b0 e2		bcs $a292			bcs 	_RGIRange
.a2b0	4c d1 a1	jmp $a1d1			jmp 	_RGICommandLoop
.a2b3					_RGISetImage:
.a2b3	a2 01		ldx #$01			ldx 	#1
.a2b5	20 b6 9d	jsr $9db6			jsr 	Evaluate8BitInteger
.a2b8	5a		phy				phy
.a2b9	aa		tax				tax
.a2ba	a0 00		ldy #$00			ldy 	#0
.a2bc	80 ea		bra $a2a8			bra 	_RGIDoCommandLoop
.a2be					GCGetCoordinatePair:
.a2be	a2 01		ldx #$01			ldx 	#1
.a2c0	20 9b 9d	jsr $9d9b			jsr 	Evaluate16BitInteger
.a2c3	20 e8 8e	jsr $8ee8			jsr 	CheckComma
.a2c6	e8		inx				inx
.a2c7	20 9b 9d	jsr $9d9b			jsr 	Evaluate16BitInteger
.a2ca	60		rts				rts
.a2cb					GCSignedCoordinatePair:
.a2cb	a2 01		ldx #$01			ldx 	#1
.a2cd	20 a5 9d	jsr $9da5			jsr 	Evaluate16BitIntegerSigned
.a2d0	20 e8 8e	jsr $8ee8			jsr 	CheckComma
.a2d3	e8		inx				inx
.a2d4	20 a5 9d	jsr $9da5			jsr 	Evaluate16BitIntegerSigned
.a2d7	60		rts				rts
.a2d8					_GCCPRange:
.a2d8	4c 9e 9f	jmp $9f9e			jmp 	RangeError
.a2db					GCLoadAXY:
.a2db	ad 60 06	lda $0660			lda 	gxXPos+1
.a2de	ae 5f 06	ldx $065f			ldx 	gxXPos
.a2e1	ac 61 06	ldy $0661			ldy 	gxYPos
.a2e4	60		rts				rts
.a2e5					GCCopyPairToStore:
.a2e5	a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.a2e7	8d 5f 06	sta $065f			sta 	gxXPos
.a2ea	a5 61		lda $61				lda 	NSMantissa1+1
.a2ec	8d 60 06	sta $0660			sta 	gxXPos+1
.a2ef	a5 5a		lda $5a				lda 	NSMantissa0+2
.a2f1	8d 61 06	sta $0661			sta 	gxYPos
.a2f4	60		rts				rts
.065d					gxCommandID:
>065d							.fill 	1
.065e					gxFillSolid:
>065e							.fill 	1
.065f					gxXPos:
>065f							.fill 	2
.0661					gxYPos:
>0661							.fill 	1
.0662					gxHandler:
>0662							.fill 	2
.0664					gxDrawScale:
>0664							.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcontrol.asm

.a2f5					BitmapCtrl:
.a2f5	b1 30		lda ($30),y			lda 	(codePtr),y
.a2f7	c8		iny				iny
.a2f8	a2 01		ldx #$01			ldx 	#1
.a2fa	c9 c4		cmp #$c4			cmp 	#KWD_ON
.a2fc	f0 11		beq $a30f			beq 	BitmapSwitch
.a2fe	ca		dex				dex
.a2ff	c9 c3		cmp #$c3			cmp 	#KWD_OFF
.a301	f0 0c		beq $a30f			beq 	BitmapSwitch
.a303	20 b6 9d	jsr $9db6			jsr 	Evaluate8BitInteger 		; get the colour
.a306	5a		phy				phy
.a307	aa		tax				tax
.a308	a9 06		lda #$06			lda 	#GCMD_Clear					; clear to that colour
.a30a	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a30d	7a		ply				ply
.a30e	60		rts				rts
.a30f					BitmapSwitch:
.a30f	5a		phy				phy
.a310	a0 00		ldy #$00			ldy 	#0 							; gfx 1,on/off,0
.a312	a9 02		lda #$02			lda 	#GCMD_BitmapCtl
.a314	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a317	a9 08		lda #$08			lda 	#GCMD_Colour				; set colour to $FF
.a319	a0 00		ldy #$00			ldy 	#0
.a31b	a2 ff		ldx #$ff			ldx 	#$FF
.a31d	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a320	9c 5e 06	stz $065e			stz 	gxFillSolid
.a323	9c 5f 06	stz $065f			stz 	gxXPos
.a326	9c 60 06	stz $0660			stz 	gxXPos+1
.a329	9c 61 06	stz $0661			stz 	gxYPos
.a32c	9c 64 06	stz $0664			stz 	gxDrawScale
.a32f	a9 40		lda #$40			lda 	#GCMD_Move 						; home cursor
.a331	a2 00		ldx #$00			ldx 	#0
.a333	a0 00		ldy #$00			ldy 	#0
.a335	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a338	7a		ply				ply
.a339	60		rts				rts
.a33a					SpritesCtrl:
.a33a	b1 30		lda ($30),y			lda 	(codePtr),y
.a33c	c8		iny				iny
.a33d	a2 01		ldx #$01			ldx 	#1
.a33f	c9 c4		cmp #$c4			cmp 	#KWD_ON
.a341	f0 08		beq $a34b			beq 	SpriteSwitch
.a343	ca		dex				dex
.a344	c9 c3		cmp #$c3			cmp 	#KWD_OFF
.a346	f0 03		beq $a34b			beq 	SpriteSwitch
.a348	4c 99 9f	jmp $9f99			jmp 	SyntaxError
.a34b					SpriteSwitch:
.a34b	5a		phy				phy
.a34c	a0 00		ldy #$00			ldy 	#0 							; gfx 2,on/off,0
.a34e	a9 04		lda #$04			lda 	#GCMD_SpriteCtl
.a350	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a353	7a		ply				ply
.a354	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gfx.asm

.a355					GfxCommand:
.a355	a2 00		ldx #$00			ldx 	#0
.a357	20 b6 9d	jsr $9db6			jsr 	Evaluate8BitInteger 		; command
.a35a	20 e8 8e	jsr $8ee8			jsr 	CheckComma
.a35d	e8		inx				inx
.a35e	20 9b 9d	jsr $9d9b			jsr 	Evaluate16BitInteger 		; X
.a361	20 e8 8e	jsr $8ee8			jsr 	CheckComma
.a364	e8		inx				inx
.a365	20 b6 9d	jsr $9db6			jsr 	Evaluate8BitInteger 		; Y
.a368	a5 61		lda $61				lda 	NSMantissa1+1  				; shift bit 0 of X into CS, should now be zero
.a36a	4a		lsr a				lsr 	a
.a36b	d0 12		bne $a37f			bne 	_GfxError
.a36d	26 58		rol $58				rol 	NSMantissa0 				; rotate into command
.a36f	b0 0e		bcs $a37f			bcs 	_GfxError 					; bit 7 should have been zero
.a371	5a		phy				phy 								; save pos
.a372	a5 58		lda $58				lda 	NSMantissa0 				; do the command
.a374	a6 59		ldx $59				ldx 	NSMantissa0+1
.a376	a4 5a		ldy $5a				ldy 	NSMantissa0+2
.a378	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a37b	b0 02		bcs $a37f			bcs 	_GfxError
.a37d	7a		ply				ply 								; restore pos and exit.
.a37e	60		rts				rts
.a37f					_GfxError:
.a37f	4c 9e 9f	jmp $9f9e			jmp 	RangeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/hit.asm

.a382					UnaryHit:
.a382	fa		plx				plx
.a383	a9 36		lda #$36			lda 	#zTemp0
.a385	20 b6 9d	jsr $9db6			jsr 	Evaluate8BitInteger 		; get sprite number 0
.a388	20 e8 8e	jsr $8ee8			jsr 	CheckComma
.a38b	e8		inx				inx
.a38c	20 b6 9d	jsr $9db6			jsr 	Evaluate8BitInteger 		; get sprite number 1
.a38f	20 e0 8e	jsr $8ee0			jsr		CheckRightBracket
.a392	ca		dex				dex 								; fix back up again.
.a393	da		phx				phx 								; save X/Y
.a394	5a		phy				phy
.a395	b4 59		ldy $59,x			ldy 	NSMantissa0+1,x 			; get the sprite numbers into X/Y
.a397	b5 58		lda $58,x			lda 	NSMantissa0,x
.a399	aa		tax				tax
.a39a	a9 12		lda #$12			lda 	#GCMD_SpriteCollide 		; command check collision.
.a39c	20 15 80	jsr $8015			jsr 	GXGraphicDraw 				; calculate result
.a39f	1a		inc a				inc 	a 							; so 255 (fail) -> 0, otherwise 1,2,3,4 pixels etc.
.a3a0	7a		ply				ply 								; restore XY
.a3a1	fa		plx				plx
.a3a2	20 1d 9e	jsr $9e1d			jsr 	NSMSetByte 					; return the hit result
.a3a5	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/palette.asm

.a3a6					PaletteCommand:
.a3a6	a2 00		ldx #$00			ldx 	#0
.a3a8	20 b6 9d	jsr $9db6			jsr 	Evaluate8BitInteger 		; colour
.a3ab	20 e8 8e	jsr $8ee8			jsr 	CheckComma
.a3ae	e8		inx				inx
.a3af	20 9b 9d	jsr $9d9b			jsr 	Evaluate16BitInteger 		; r
.a3b2	20 e8 8e	jsr $8ee8			jsr 	CheckComma
.a3b5	e8		inx				inx
.a3b6	20 b6 9d	jsr $9db6			jsr 	Evaluate8BitInteger 		; g
.a3b9	20 e8 8e	jsr $8ee8			jsr 	CheckComma
.a3bc	e8		inx				inx
.a3bd	20 b6 9d	jsr $9db6			jsr 	Evaluate8BitInteger 		; b
.a3c0	a5 58		lda $58				lda 	NSMantissa0 				; get colour #
.a3c2	85 36		sta $36				sta 	zTemp0
.a3c4	a9 34		lda #$34			lda 	#$D0 >> 2 					; MSB = D0/4
.a3c6	85 37		sta $37				sta 	zTemp0+1
.a3c8	06 36		asl $36				asl 	zTemp0 						; zTemp = $D000+Colour x 4
.a3ca	26 37		rol $37				rol	 	zTemp0+1
.a3cc	06 36		asl $36				asl 	zTemp0
.a3ce	26 37		rol $37				rol	 	zTemp0+1
.a3d0	a9 01		lda #$01			lda 	#1 							; I/O Page 2
.a3d2	85 01		sta $01				sta 	1
.a3d4	5a		phy				phy
.a3d5	a5 5b		lda $5b				lda 	NSMantissa0+3 				; fix to r,g,b
.a3d7	92 36		sta ($36)			sta 	(zTemp0)
.a3d9	a0 01		ldy #$01			ldy 	#1
.a3db	a5 5a		lda $5a				lda 	NSMantissa0+2
.a3dd	91 36		sta ($36),y			sta 	(zTemp0),y
.a3df	a5 59		lda $59				lda 	NSMantissa0+1
.a3e1	c8		iny				iny
.a3e2	91 36		sta ($36),y			sta 	(zTemp0),y
.a3e4	7a		ply				ply
.a3e5	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/event.asm

.a3e6					UnaryEvent:
.a3e6	fa		plx				plx
.a3e7	20 94 a4	jsr $a494			jsr 	TimerToStackX 				; timer in +0
.a3ea	e8		inx				inx  								; put reference into +1
.a3eb	20 47 98	jsr $9847			jsr 	EvaluateTerm
.a3ee	b5 50		lda $50,x			lda 	NSStatus,x 					; check if is integer reference
.a3f0	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.a3f2	d0 4c		bne $a440			bne 	_UEType
.a3f4	e8		inx				inx 								; put the step in +2
.a3f5	20 e8 8e	jsr $8ee8			jsr 	CheckComma
.a3f8	20 9b 9d	jsr $9d9b			jsr 	Evaluate16BitInteger
.a3fb	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket
.a3fe	ca		dex				dex
.a3ff	ca		dex				dex
.a400	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy reference to zTemp0
.a402	85 36		sta $36				sta 	zTemp0
.a404	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.a406	85 37		sta $37				sta 	zTemp0+1
.a408	5a		phy				phy
.a409	a0 03		ldy #$03			ldy 	#3 							; check bit 7 of last bit, the packed sign bit
.a40b	b1 36		lda ($36),y			lda 	(zTemp0),y
.a40d	30 2d		bmi $a43c			bmi 	_UEFalse 					; exit if signed.
.a40f	a0 00		ldy #$00			ldy 	#0 							; has it timed out (24 bit)
.a411	b5 58		lda $58,x			lda 	NSMantissa0,x
.a413	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.a415	c8		iny				iny
.a416	b5 60		lda $60,x			lda 	NSMantissa1,x
.a418	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a41a	c8		iny				iny
.a41b	b5 68		lda $68,x			lda 	NSMantissa2,x
.a41d	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a41f	90 1b		bcc $a43c			bcc 	_UEFalse 					; no, return FALSE.
.a421	18		clc				clc
.a422	a0 00		ldy #$00			ldy 	#0 							; work out new value as timer() + step
.a424	b5 58		lda $58,x			lda 	NSMantissa0,x
.a426	75 5a		adc $5a,x			adc 	NSMantissa0+2,x
.a428	91 36		sta ($36),y			sta 	(zTemp0),y
.a42a	c8		iny				iny
.a42b	b5 60		lda $60,x			lda 	NSMantissa1,x
.a42d	75 62		adc $62,x			adc 	NSMantissa1+2,x
.a42f	91 36		sta ($36),y			sta 	(zTemp0),y
.a431	c8		iny				iny
.a432	b5 68		lda $68,x			lda 	NSMantissa2,x
.a434	75 6a		adc $6a,x			adc 	NSMantissa2+2,x
.a436	91 36		sta ($36),y			sta 	(zTemp0),y
.a438	7a		ply				ply
.a439	4c 66 8f	jmp $8f66			jmp 	ReturnTrue
.a43c					_UEFalse:
.a43c	7a		ply				ply 								; restore Y
.a43d	4c 71 8f	jmp $8f71			jmp 	ReturnFalse 				; and return False
.a440					_UEType:
.a440	4c a3 9f	jmp $9fa3			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/joy.asm

.a443					UnaryJoyX:
.a443	18		clc				clc
.a444	80 01		bra $a447			bra 	JoyMain
.a446					UnaryJoyY:
.a446	38		sec				sec
.a447					JoyMain:
.a447	fa		plx				plx 								; get pos
.a448	08		php				php 								; save carry (set for Y)
.a449	20 b6 9d	jsr $9db6			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a44c	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket
.a44f	20 0f 80	jsr $800f			jsr 	EXTReadController 			; read the controller.
.a452	28		plp				plp
.a453	90 02		bcc $a457			bcc 	_JMNoShift 					; if Y then shift bits 3,2 -> 1,0
.a455	4a		lsr a				lsr 	a
.a456	4a		lsr a				lsr 	a
.a457					_JMNoShift:
.a457	4a		lsr a				lsr 	a 							; if bit 0 set then right/down e.g. +1
.a458	b0 0a		bcs $a464			bcs 	_JMIsRight
.a45a	4a		lsr a				lsr 	a 							; if bit 1 set then left/up e.g. -1
.a45b	b0 04		bcs $a461			bcs 	_JMIsLeft
.a45d	20 1b 9e	jsr $9e1b			jsr 	NSMSetZero 					; zero result
.a460	60		rts				rts
.a461					_JMIsLeft:
.a461	4c 66 8f	jmp $8f66			jmp 	ReturnTrue
.a464					_JMIsRight:
.a464	a9 01		lda #$01			lda 	#1
.a466	20 1d 9e	jsr $9e1d			jsr 	NSMSetByte
.a469	60		rts				rts
.a46a					UnaryJoyB:
.a46a	fa		plx				plx 								; get pos
.a46b	20 b6 9d	jsr $9db6			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a46e	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket
.a471	20 0f 80	jsr $800f			jsr 	EXTReadController 			; read the controller.
.a474	4a		lsr a				lsr 	a
.a475	4a		lsr a				lsr 	a
.a476	4a		lsr a				lsr 	a
.a477	4a		lsr a				lsr 	a
.a478	29 01		and #$01			and 	#1
.a47a	20 1d 9e	jsr $9e1d			jsr 	NSMSetByte
.a47d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/load.asm

.a47e					LoadCommand:
.a47e	20 2e 8a	jsr $8a2e			jsr 	NewProgram
.a481	20 20 83	jsr $8320			jsr 	BackLoadProgram
.a484	4c d7 83	jmp $83d7			jmp 	WarmStart
.a487					GoCommand:
.a487	20 2e 8a	jsr $8a2e			jsr 	NewProgram
.a48a	20 20 83	jsr $8320			jsr 	BackLoadProgram
.a48d	4c 6f 8b	jmp $8b6f			jmp 	CommandRun

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/timer.asm

.a490					UnaryTimer:
.a490	fa		plx				plx
.a491	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket
.a494					TimerToStackX:
.a494	20 1b 9e	jsr $9e1b			jsr 	NSMSetZero 					; zero result
.a497	64 01		stz $01				stz 	1 							; access I/O
.a499	ad 59 d6	lda $d659			lda 	$D659 						; copy timer in
.a49c	95 58		sta $58,x			sta 	NSMantissa0,x
.a49e	ad 5a d6	lda $d65a			lda 	$D65A
.a4a1	95 60		sta $60,x			sta 	NSMantissa1,x
.a4a3	ad 5b d6	lda $d65b			lda 	$D65B
.a4a6	95 68		sta $68,x			sta 	NSMantissa2,x
.a4a8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/delete.asm

.a4a9					MemoryDeleteLine:
.a4a9	20 c8 a4	jsr $a4c8			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a4ac	b2 30		lda ($30)			lda 	(codePtr) 					; size to delete => y
.a4ae	a8		tay				tay
.a4af					_MDDLLoop:
.a4af	b1 30		lda ($30),y			lda 	(codePtr),y 				; copy down
.a4b1	92 30		sta ($30)			sta 	(codePtr)
.a4b3	a5 30		lda $30				lda 	codePtr 					; check done the lot.
.a4b5	c5 3a		cmp $3a				cmp 	zTemp2
.a4b7	d0 07		bne $a4c0			bne 	_MDLDLNext
.a4b9	a5 31		lda $31				lda 	codePtr+1
.a4bb	c5 3b		cmp $3b				cmp 	zTemp2+1
.a4bd	d0 01		bne $a4c0			bne 	_MDLDLNext
.a4bf					_MDDLExit:
.a4bf	60		rts				rts
.a4c0					_MDLDLNext:
.a4c0	e6 30		inc $30				inc 	codePtr						; next byte
.a4c2	d0 eb		bne $a4af			bne 	_MDDLLoop
.a4c4	e6 31		inc $31				inc 	codePtr+1
.a4c6	80 e7		bra $a4af			bra 	_MDDLLoop
.a4c8					IMemoryFindEnd:
.a4c8	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a4ca	85 3a		sta $3a				sta 	0+zTemp2
.a4cc	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a4ce	85 3b		sta $3b				sta 	1+zTemp2
.a4d0					_MDLFELoop:
.a4d0	b2 3a		lda ($3a)			lda 	(zTemp2)
.a4d2	f0 0b		beq $a4df			beq 	_MDLFEExit
.a4d4	18		clc				clc
.a4d5	65 3a		adc $3a				adc 	zTemp2
.a4d7	85 3a		sta $3a				sta 	zTemp2
.a4d9	90 f5		bcc $a4d0			bcc 	_MDLFELoop
.a4db	e6 3b		inc $3b				inc 	zTemp2+1
.a4dd	80 f1		bra $a4d0			bra 	_MDLFELoop
.a4df					_MDLFEExit:
.a4df	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/insert.asm

.a4e0					MemoryInsertLine:
.a4e0	08		php				php
.a4e1	20 c8 a4	jsr $a4c8			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a4e4	a5 3b		lda $3b				lda 	zTemp2+1 					; space ?
.a4e6	1a		inc a				inc 	a
.a4e7	c9 7f		cmp #$7f			cmp 	#(BasicEnd >> 8)-1
.a4e9	b0 36		bcs $a521			bcs 	_MDLIError
.a4eb	28		plp				plp
.a4ec	90 08		bcc $a4f6			bcc 	_MDLIFound
.a4ee	a5 3a		lda $3a				lda 	zTemp2 						; if CS on entry append.
.a4f0	85 30		sta $30				sta 	codePtr
.a4f2	a5 3b		lda $3b				lda 	zTemp2+1
.a4f4	85 31		sta $31				sta 	codePtr+1
.a4f6					_MDLIFound:
.a4f6	ad 2a 04	lda $042a			lda 	tokenOffset 				; insert gap in Y, the offset, e.g. length of the new line
.a4f9	a8		tay				tay
.a4fa					_MDLIInsert:
.a4fa	b2 3a		lda ($3a)			lda 	(zTemp2) 					; shift one byte up , at least one covers end case.
.a4fc	91 3a		sta ($3a),y			sta 	(zTemp2),y 					; work from top down.
.a4fe	a5 30		lda $30				lda 	codePtr 					; done insert point ?
.a500	c5 3a		cmp $3a				cmp 	zTemp2
.a502	d0 06		bne $a50a			bne 	_MDLINext
.a504	a5 31		lda $31				lda 	codePtr+1
.a506	c5 3b		cmp $3b				cmp 	zTemp2+1
.a508	f0 0a		beq $a514			beq 	_MDLIHaveSpace
.a50a					_MDLINext:
.a50a	a5 3a		lda $3a				lda 	zTemp2 						; if no, keep zTemp2 going backwards
.a50c	d0 02		bne $a510			bne 	_MDLINoBorrow
.a50e	c6 3b		dec $3b				dec 	zTemp2+1
.a510					_MDLINoBorrow:
.a510	c6 3a		dec $3a				dec 	zTemp2
.a512	80 e6		bra $a4fa			bra 	_MDLIInsert
.a514					_MDLIHaveSpace:
.a514	ac 2a 04	ldy $042a			ldy 	tokenOffset 				; bytes to copy
.a517	88		dey				dey 								; from offset-1 to 0
.a518					_MDLICopy:
.a518	b9 2a 04	lda $042a,y			lda 	tokenOffset,y
.a51b	91 30		sta ($30),y			sta 	(codePtr),y
.a51d	88		dey				dey
.a51e	10 f8		bpl $a518			bpl 	_MDLICopy
.a520	60		rts				rts
.a521					_MDLIError:
.a521	a9 06		lda #$06		lda	#6
.a523	4c f9 8e	jmp $8ef9		jmp	ErrorHandler
.a526					MDLAppendLine:
.a526	86 37		stx $37				stx 	zTemp0+1 					; save new line at zTemp0
.a528	85 36		sta $36				sta 	zTemp0
.a52a	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a52c	85 38		sta $38				sta 	0+zTemp1
.a52e	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a530	85 39		sta $39				sta 	1+zTemp1
.a532	b2 38		lda ($38)			lda 	(zTemp1)
.a534	d0 0a		bne $a540			bne 	_MDLANoInitialise
.a536	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a538	8d 65 06	sta $0665			sta 	0+AppendPointer
.a53b	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a53d	8d 66 06	sta $0666			sta 	1+AppendPointer
.a540					_MDLANoInitialise:
.a540	18		clc				clc
.a541	ad 65 06	lda $0665			lda 	AppendPointer 				; copy append pointer to zTemp1 adding the offset as you go
.a544	85 38		sta $38				sta 	zTemp1
.a546	72 36		adc ($36)			adc 	(zTemp0)
.a548	8d 65 06	sta $0665			sta 	AppendPointer
.a54b	ad 66 06	lda $0666			lda 	AppendPointer+1
.a54e	85 39		sta $39				sta 	zTemp1+1
.a550	69 00		adc #$00			adc 	#0
.a552	8d 66 06	sta $0666			sta 	AppendPointer+1
.a555	a0 00		ldy #$00			ldy 	#0
.a557					_MDLACopy:
.a557	b1 36		lda ($36),y			lda 	(zTemp0),y 					; copy new line in
.a559	91 38		sta ($38),y			sta 	(zTemp1),y
.a55b	c8		iny				iny
.a55c	98		tya				tya
.a55d	d2 36		cmp ($36)			cmp 	(zTemp0) 					; done whole line
.a55f	d0 f6		bne $a557			bne 	_MDLACopy
.a561	a9 00		lda #$00			lda 	#0 							; end of program.
.a563	91 38		sta ($38),y			sta 	(zTemp1),y
.a565	60		rts				rts
.0665					AppendPointer:
>0665							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/memory.asm

.a566					MemoryNew:
.a566	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a568	85 30		sta $30				sta 	codePtr
.a56a	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a56c	85 31		sta $31				sta 	codePtr+1
.a56e	a9 00		lda #$00			lda 	#0 							; write zero there erasing the program.
.a570	92 30		sta ($30)			sta 	(codePtr)
.a572	60		rts				rts
.a573					MemoryInline:
.a573	98		tya				tya 								; put address into stack,x
.a574	18		clc				clc  								; get the offset, add codePtr
.a575	65 30		adc $30				adc 	codePtr
.a577	95 58		sta $58,x			sta 	NSMantissa0,x 				; store the result in the mantissa.
.a579	a5 31		lda $31				lda 	codePtr+1
.a57b	69 00		adc #$00			adc 	#0
.a57d	95 60		sta $60,x			sta 	NSMantissa1,x
.a57f	74 68		stz $68,x			stz 	NSMantissa2,x
.a581	74 70		stz $70,x			stz 	NSMantissa3,x
.a583	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/search.asm

.a584					MemorySearch:
.a584	85 36		sta $36				sta 	zTemp0 						; save line number in zTemp0
.a586	86 37		stx $37				stx 	zTemp0+1
.a588	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a58a	85 30		sta $30				sta 	codePtr
.a58c	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a58e	85 31		sta $31				sta 	codePtr+1
.a590					_MTAXLoop:
.a590	b2 30		lda ($30)			lda 	(codePtr)
.a592	18		clc				clc
.a593	f0 21		beq $a5b6			beq 	_MTAXExit 					; reached end, exit with CC.
.a595	a0 01		ldy #$01			ldy 	#1 							; calculate current line# - requested line#
.a597	b1 30		lda ($30),y			lda 	(codePtr),y
.a599	38		sec				sec
.a59a	e5 36		sbc $36				sbc 	zTemp0
.a59c	85 38		sta $38				sta 	zTemp1 						; save interim to set Z
.a59e	c8		iny				iny 								; do the MSB
.a59f	b1 30		lda ($30),y			lda 	(codePtr),y
.a5a1	e5 37		sbc $37				sbc 	zTemp0+1
.a5a3	05 38		ora $38				ora 	zTemp1 						; will set Z if result is zero, doesn't affect carry flag
.a5a5	f0 0f		beq $a5b6			beq 	_MTAXExit	 				; found so exit (CS will be set)
.a5a7	b0 0d		bcs $a5b6			bcs 	_MTAXExit 					; current < required exit
.a5a9	18		clc				clc
.a5aa	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.a5ac	65 30		adc $30				adc 	codePtr
.a5ae	85 30		sta $30				sta 	codePtr
.a5b0	90 02		bcc $a5b4			bcc 	_CREExit
.a5b2	e6 31		inc $31				inc 	codePtr+1 					; carry
.a5b4					_CREExit:
.a5b4	80 da		bra $a590			bra 	_MTAXLoop
.a5b6					_MTAXExit:
.a5b6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/effects.asm

.a5b7					PingCommand:
.a5b7	5a		phy				phy 								; save pos
.a5b8	a9 01		lda #$01			lda 	#1 						; push channel.
.a5ba	48		pha				pha
.a5bb	a9 c8		lda #$c8			lda 	#200 						; pitch LSB
.a5bd	a2 03		ldx #$03			ldx 	#3 						; length
.a5bf	a0 00		ldy #$00			ldy 	#0 						; slide LSB
.a5c1	80 24		bra $a5e7			bra 	SoundEffectCommand
.a5c3					ZapCommand:
.a5c3	5a		phy				phy 								; save pos
.a5c4	a9 01		lda #$01			lda 	#1 						; push channel.
.a5c6	48		pha				pha
.a5c7	a9 ff		lda #$ff			lda 	#255 						; pitch LSB
.a5c9	a2 05		ldx #$05			ldx 	#5 						; length
.a5cb	a0 14		ldy #$14			ldy 	#20 						; slide LSB
.a5cd	80 18		bra $a5e7			bra 	SoundEffectCommand
.a5cf					ShootCommand:
.a5cf	5a		phy				phy 								; save pos
.a5d0	a9 03		lda #$03			lda 	#3 						; push channel.
.a5d2	48		pha				pha
.a5d3	a9 20		lda #$20			lda 	#32 						; pitch LSB
.a5d5	a2 02		ldx #$02			ldx 	#2 						; length
.a5d7	a0 00		ldy #$00			ldy 	#0 						; slide LSB
.a5d9	80 0c		bra $a5e7			bra 	SoundEffectCommand
.a5db					Explode:
.a5db	5a		phy				phy 								; save pos
.a5dc	a9 03		lda #$03			lda 	#3 						; push channel.
.a5de	48		pha				pha
.a5df	a9 50		lda #$50			lda 	#80 						; pitch LSB
.a5e1	a2 05		ldx #$05			ldx 	#5 						; length
.a5e3	a0 00		ldy #$00			ldy 	#0 						; slide LSB
.a5e5	80 00		bra $a5e7			bra 	SoundEffectCommand
.a5e7					SoundEffectCommand:
.a5e7	8d 67 06	sta $0667			sta 	SoundCommandBlock 			; set up the command block in sound.asm
.a5ea	9c 68 06	stz $0668			stz 	SoundCommandBlock+1
.a5ed	a9 0f		lda #$0f			lda 	#15
.a5ef	8d 69 06	sta $0669			sta 	SoundCommandBlock+2
.a5f2	8e 6a 06	stx $066a			stx 	SoundCommandBlock+3
.a5f5	8c 6b 06	sty $066b			sty 	SoundCommandBlock+4
.a5f8	9c 6c 06	stz $066c			stz 	SoundCommandBlock+5
.a5fb	68		pla				pla
.a5fc	09 10		ora #$10			ora 	#$10  						; execute command $11
.a5fe	a2 67		ldx #$67			ldx 	#(SoundCommandBlock & $FF)
.a600	a0 06		ldy #$06			ldy 	#(SoundCommandBlock >> 8)
.a602	20 18 80	jsr $8018			jsr 	SNDCommand
.a605	7a		ply				ply
.a606	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/playing.asm

.a607					UnaryPlaying:
.a607	fa		plx				plx
.a608	20 b6 9d	jsr $9db6			jsr 	Evaluate8BitInteger 		; get channel #
.a60b	48		pha				pha
.a60c	20 e0 8e	jsr $8ee0			jsr		CheckRightBracket
.a60f	68		pla				pla
.a610	c9 04		cmp #$04			cmp 	#4
.a612	b0 0c		bcs $a620			bcs 	_UPNotPlaying
.a614	09 20		ora #$20			ora 	#$20 						; query playing ?
.a616	20 18 80	jsr $8018			jsr 	SNDCommand
.a619	c9 00		cmp #$00			cmp 	#0
.a61b	f0 03		beq $a620			beq 	_UPNotPlaying
.a61d	4c 66 8f	jmp $8f66			jmp 	ReturnTrue
.a620					_UPNotPlaying:
.a620	4c 71 8f	jmp $8f71			jmp 	ReturnFalse

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/sound.asm

.a623					SoundCommand:
.a623	b1 30		lda ($30),y			lda 	(codePtr),y
.a625	c9 c3		cmp #$c3			cmp 	#KWD_OFF 					; SOUND OFF ?
.a627	d0 09		bne $a632			bne 	_SNDMain
.a629	c8		iny				iny 								; skip OFF
.a62a	a9 3f		lda #$3f			lda 	#$3F 						; call command $3F (silence)
.a62c	5a		phy				phy
.a62d	20 18 80	jsr $8018			jsr 	SNDCommand
.a630	7a		ply				ply
.a631	60		rts				rts
.a632					_SNDMain:
.a632	a2 00		ldx #$00			ldx 	#0
.a634	20 b6 9d	jsr $9db6			jsr 	Evaluate8BitInteger 		; channel
.a637	c9 04		cmp #$04			cmp 	#4 							; must be 0-3
.a639	b0 4b		bcs $a686			bcs 	_SndError
.a63b	e8		inx				inx 								; do the rest in slot 1.
.a63c	20 e8 8e	jsr $8ee8			jsr 	CheckComma
.a63f	20 9b 9d	jsr $9d9b			jsr 	Evaluate16BitInteger 		; Pitch
.a642	b5 60		lda $60,x			lda 	NSMantissa1,x 				; must be 10 bit
.a644	c9 10		cmp #$10			cmp 	#16
.a646	b0 3e		bcs $a686			bcs 	_SndError
.a648	8d 68 06	sta $0668			sta 	SoundCommandBlock+1 		; Pitch (2 bytes + 0)
.a64b	b5 58		lda $58,x			lda 	NSMantissa0,x
.a64d	8d 67 06	sta $0667			sta 	SoundCommandBlock
.a650	20 e8 8e	jsr $8ee8			jsr 	CheckComma
.a653	20 b6 9d	jsr $9db6			jsr 	Evaluate8BitInteger 		; Length (1 byte + 3)
.a656	8d 6a 06	sta $066a			sta 	SoundCommandBlock+3
.a659	a9 0f		lda #$0f			lda 	#15
.a65b	8d 69 06	sta $0669			sta 	SoundCommandBlock+2 		; Volume (1 byte + 2)
.a65e	9c 6b 06	stz $066b			stz 	SoundCommandBlock+4 		; default slide (2 bytes +4)
.a661	9c 6c 06	stz $066c			stz 	SoundCommandBlock+5
.a664	b1 30		lda ($30),y			lda 	(codePtr),y
.a666	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.a668	d0 0e		bne $a678			bne 	_SNDPlay
.a66a	c8		iny				iny
.a66b	20 a5 9d	jsr $9da5			jsr 	Evaluate16BitIntegerSigned 	; Slide
.a66e	b5 58		lda $58,x			lda 	NSMantissa0,x 				; Slide (2 bytes + 4)
.a670	8d 6b 06	sta $066b			sta 	SoundCommandBlock+4
.a673	b5 60		lda $60,x			lda 	NSMantissa1,x
.a675	8d 6c 06	sta $066c			sta 	SoundCommandBlock+5
.a678					_SNDPlay:
.a678	5a		phy				phy
.a679	a5 58		lda $58				lda 	NSMantissa0 				; channel.
.a67b	09 10		ora #$10			ora 	#$10 						; 1x = Queue sound
.a67d	a2 67		ldx #$67			ldx 	#(SoundCommandBlock & $FF)
.a67f	a0 06		ldy #$06			ldy 	#(SoundCommandBlock >> 8)
.a681	20 18 80	jsr $8018			jsr 	SNDCommand
.a684	7a		ply				ply
.a685	60		rts				rts
.a686					_SndError:
.a686	4c 9e 9f	jmp $9f9e			jmp 	RangeError
.0667					SoundCommandBlock:
>0667							.fill 	6

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/bytes.asm

.a689					StackPushByte:
.a689	48		pha				pha 								; save byte on stack
.a68a	a5 34		lda $34				lda 	BasicStack 					; decrement basic stack pointer
.a68c	d0 08		bne $a696			bne 	_SPBNoBorrow
.a68e	c6 35		dec $35				dec 	BasicStack+1 				; borrow
.a690	a5 35		lda $35				lda 	BasicStack+1 				; check range.
.a692	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a694	90 06		bcc $a69c			bcc 	_SPBMemory
.a696					_SPBNoBorrow:
.a696	c6 34		dec $34				dec 	BasicStack
.a698	68		pla				pla 								; get back and write
.a699	92 34		sta ($34)			sta 	(BasicStack)
.a69b	60		rts				rts
.a69c					_SPBMemory:
.a69c	a9 12		lda #$12		lda	#18
.a69e	4c f9 8e	jmp $8ef9		jmp	ErrorHandler
.a6a1					StackPopByte:
.a6a1	b2 34		lda ($34)			lda 	(BasicStack) 				; bump the stack pointer.
.a6a3	e6 34		inc $34				inc 	BasicStack
.a6a5	d0 02		bne $a6a9			bne 	_SPBNoCarry
.a6a7	e6 35		inc $35				inc 	BasicStack+1
.a6a9					_SPBNoCarry:
.a6a9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/frames.asm

.a6aa					StackOpen:
.a6aa	48		pha				pha 								; save frame byte
.a6ab	29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.a6ad	0a		asl a				asl 	a 							; claim twice this for storage
.a6ae	49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.a6b0	38		sec				sec 								; so basically subtracting from
.a6b1	65 34		adc $34				adc 	basicStack 	 				; basicStack
.a6b3	85 34		sta $34				sta 	basicStack
.a6b5	b0 09		bcs $a6c0			bcs 	_SONoBorrow
>a6b7	db						.byte 	$DB 						; causes a break in the emulator
.a6b8	c6 35		dec $35				dec 	basicStack+1
.a6ba	a5 35		lda $35				lda 	basicStack+1 				; have we reached stack overflow
.a6bc	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a6be	90 04		bcc $a6c4			bcc 	_SOMemory
.a6c0					_SONoBorrow:
.a6c0	68		pla				pla 								; get marker back and write at TOS
.a6c1	92 34		sta ($34)			sta 	(basicStack)
.a6c3	60		rts				rts
.a6c4					_SOMemory:
.a6c4	a9 12		lda #$12		lda	#18
.a6c6	4c f9 8e	jmp $8ef9		jmp	ErrorHandler
.a6c9					StackClose:
.a6c9	b2 34		lda ($34)			lda 	(basicStack) 				; get TOS marker
.a6cb	29 0f		and #$0f			and 	#$0F 						; bytes to add back
.a6cd	0a		asl a				asl 	a 							; claim twice this.
.a6ce	65 34		adc $34				adc 	basicStack 					; add to the stack pointer.
.a6d0	85 34		sta $34				sta 	basicStack
.a6d2	90 02		bcc $a6d6			bcc 	_SCExit
.a6d4	e6 35		inc $35				inc 	basicStack+1
.a6d6					_SCExit:
.a6d6	60		rts				rts
.a6d7					StackCheckFrame:
.a6d7	48		pha				pha
.a6d8					_StackRemoveLocals:
.a6d8	b2 34		lda ($34)			lda 	(basicStack) 				; check for local, keep popping them
.a6da	c9 03		cmp #$03			cmp 	#STK_LOCALS+1 				; is the frame a local ? S or N are 1/0
.a6dc	b0 05		bcs $a6e3			bcs 	_SCNoLocal
.a6de	20 dd 89	jsr $89dd			jsr 	LocalPopValue 				; restore the local value
.a6e1	80 f5		bra $a6d8			bra 	_StackRemoveLocals 			; gr round again
.a6e3					_SCNoLocal:
.a6e3	68		pla				pla 								; get the frame check.
.a6e4	52 34		eor ($34)			eor 	(basicStack) 				; xor with toS marker
.a6e6	29 f0		and #$f0			and 	#$F0 						; check type bits
.a6e8	d0 01		bne $a6eb			bne 	_SCFError 					; different, we have structures mixed up
.a6ea	60		rts				rts
.a6eb					_SCFError:
.a6eb	8a		txa				txa 								; report error X
.a6ec	4c f9 8e	jmp $8ef9			jmp 	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/location.asm

.a6ef					STKSaveCodePosition:
.a6ef	5a		phy				phy
.a6f0	98		tya				tya 								; save Y
.a6f1	a0 05		ldy #$05			ldy 	#5
.a6f3	91 34		sta ($34),y			sta 	(basicStack),y
.a6f5	88		dey				dey 								; save Code Pointer
.a6f6					_STKSaveLoop:
.a6f6	b9 2f 00	lda $002f,y			lda 	safePtr-1,y 				; allows us to access the pointer w/out issues.
.a6f9	91 34		sta ($34),y			sta 	(basicStack),y
.a6fb	88		dey				dey
.a6fc	d0 f8		bne $a6f6			bne 	_STKSaveLoop
.a6fe	7a		ply				ply
.a6ff	60		rts				rts
.a700					STKLoadCodePosition:
.a700	a0 01		ldy #$01			ldy 	#1 							; load code pointer back
.a702					_STKLoadLoop:
.a702	b1 34		lda ($34),y			lda 	(basicStack),y
.a704	99 2f 00	sta $002f,y			sta 	safePtr-1,y
.a707	c8		iny				iny
.a708	c0 05		cpy #$05			cpy 	#5
.a70a	d0 f6		bne $a702			bne 	_STKLoadLoop
.a70c	b1 34		lda ($34),y			lda 	(basicStack),y 				; get Y offset
.a70e	a8		tay				tay
.a70f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/setup.asm

.a710					StackReset:
.a710	a9 ff		lda #$ff			lda 	#((BasicStackBase+BasicStackSize-1) & $FF)
.a712	85 34		sta $34				sta 	0+basicStack
.a714	a9 0f		lda #$0f			lda 	#((BasicStackBase+BasicStackSize-1) >> 8)
.a716	85 35		sta $35				sta 	1+basicStack
.a718	a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.a71a	92 34		sta ($34)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.a71c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/concrete.asm

.a71d					StringConcrete:
.a71d	5a		phy				phy 								; save position on stack
.a71e	20 2e 9a	jsr $9a2e			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a721	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy target string to zTemp1
.a723	85 38		sta $38				sta 	zTemp1
.a725	b5 60		lda $60,x			lda 	NSMantissa1,x
.a727	85 39		sta $39				sta 	zTemp1+1
.a729	a0 ff		ldy #$ff			ldy 	#$FF	 					; calculate string length
.a72b					_SALength:
.a72b	c8		iny				iny
.a72c	b1 38		lda ($38),y			lda 	(zTemp1),y
.a72e	d0 fb		bne $a72b			bne 	_SALength
.a730	c0 fd		cpy #$fd			cpy 	#253 						; string too long - cannot concrete.
.a732	b0 3d		bcs $a771			bcs 	_SALengthError
.a734	98		tya				tya 				 				; length of the new string
.a735	18		clc				clc
.a736	69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.a738	90 02		bcc $a73c			bcc 	_SAHaveLength
.a73a	a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.a73c					_SAHaveLength:
.a73c	48		pha				pha 								; save length.
.a73d	38		sec				sec
.a73e	49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.a740	6d 0e 04	adc $040e			adc 	StringMemory
.a743	8d 0e 04	sta $040e			sta 	StringMemory
.a746	85 3a		sta $3a				sta 	zTemp2 						; update storage address
.a748	95 58		sta $58,x			sta 	NSMantissa0,x 				; update mantissa address
.a74a	a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.a74c	6d 0f 04	adc $040f			adc 	StringMemory+1
.a74f	8d 0f 04	sta $040f			sta 	StringMemory+1
.a752	85 3b		sta $3b				sta 	zTemp2+1
.a754	95 60		sta $60,x			sta 	NSMantissa1,x
.a756	68		pla				pla 								; save length-3 (chars allowed) in first byte
.a757	38		sec				sec
.a758	e9 03		sbc #$03			sbc 	#3
.a75a	92 3a		sta ($3a)			sta 	(zTemp2)
.a75c	a9 00		lda #$00			lda 	#0 							; clear the status byte.
.a75e	a0 01		ldy #$01			ldy 	#1
.a760	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a762					_SACopyNewString:
.a762	a0 00		ldy #$00			ldy 	#0
.a764					_SACopyNSLoop:
.a764	b1 38		lda ($38),y			lda 	(zTemp1),y 					; get character
.a766	c8		iny				iny 								; write two on in string storage
.a767	c8		iny				iny
.a768	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a76a	88		dey				dey 								; this makes it one one.
.a76b	c9 00		cmp #$00			cmp 	#0 							; until EOS copied
.a76d	d0 f5		bne $a764			bne 	_SACopyNSLoop
.a76f	7a		ply				ply
.a770	60		rts				rts
.a771					_SALengthError:
.a771	a9 09		lda #$09		lda	#9
.a773	4c f9 8e	jmp $8ef9		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/stringalloc.asm

.a776					StringSystemInitialise:
.a776	a9 ff		lda #$ff			lda 	#((EndVariableSpace-1) & $FF)
.a778	8d 0e 04	sta $040e			sta 	0+StringMemory
.a77b	a9 1f		lda #$1f			lda 	#((EndVariableSpace-1) >> 8)
.a77d	8d 0f 04	sta $040f			sta 	1+StringMemory
.a780	9c ff 1f	stz $1fff			stz 	EndVariableSpace-1 			; put a zero at the end, so know end of string memory.
.a783	60		rts				rts
.a784					StringSpaceInitialise:
.a784	20 2e 9a	jsr $9a2e			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a787	a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.a789	8d 10 04	sta $0410			sta 	StringInitialised
.a78c	ad 0e 04	lda $040e			lda 	StringMemory 				; allocate 256 bytes for one concreted string
.a78f	8d 11 04	sta $0411			sta 	StringTempPointer 			; so temporary string space is allocated below that.
.a792	ad 0f 04	lda $040f			lda 	StringMemory+1
.a795	3a		dec a				dec 	a
.a796	8d 12 04	sta $0412			sta 	StringTempPointer+1
.a799	60		rts				rts
.a79a					StringTempAllocate:
.a79a	c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.a79c	b0 30		bcs $a7ce			bcs 	_STALength
.a79e	2c 10 04	bit $0410			bit 	StringInitialised 			; already initialised
.a7a1	30 05		bmi $a7a8			bmi 	_STAAllocate
.a7a3	48		pha				pha 								; save value to subtract.
.a7a4	20 84 a7	jsr $a784			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.a7a7	68		pla				pla 								; restore it
.a7a8					_STAAllocate:
.a7a8	49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.a7aa	18		clc				clc  								; deliberate allows one more
.a7ab	6d 11 04	adc $0411			adc 	StringTempPointer 			; subtract from temp pointer
.a7ae	8d 11 04	sta $0411			sta 	StringTempPointer
.a7b1	95 58		sta $58,x			sta 	NSMantissa0,x 				; address in mantissa
.a7b3	85 3c		sta $3c				sta 	zsTemp 						; and zsTemp
.a7b5	ad 12 04	lda $0412			lda 	StringTempPointer+1
.a7b8	69 ff		adc #$ff			adc 	#$FF
.a7ba	8d 12 04	sta $0412			sta 	StringTempPointer+1
.a7bd	85 3d		sta $3d				sta 	zsTemp+1
.a7bf	95 60		sta $60,x			sta 	NSMantissa1,x
.a7c1	74 68		stz $68,x			stz 	NSMantissa2,x 				; set the typing data and the upper address bytes.
.a7c3	74 70		stz $70,x			stz 	NSMantissa3,x
.a7c5	a9 10		lda #$10			lda 	#NSTString
.a7c7	95 50		sta $50,x			sta 	NSStatus,x
.a7c9	a9 00		lda #$00			lda 	#0 							; clear the target string
.a7cb	92 3c		sta ($3c)			sta 	(zsTemp)
.a7cd	60		rts				rts
.a7ce					_STALength:
.a7ce	a9 09		lda #$09		lda	#9
.a7d0	4c f9 8e	jmp $8ef9		jmp	ErrorHandler
.a7d3					StringTempWrite:
.a7d3	48		pha				pha
.a7d4	92 3c		sta ($3c)			sta 	(zsTemp) 					; write byte
.a7d6	e6 3c		inc $3c				inc 	zsTemp 						; bump pointer
.a7d8	d0 02		bne $a7dc			bne 	_STWNoCarry
.a7da	e6 3d		inc $3d				inc 	zsTemp+1
.a7dc					_STWNoCarry:
.a7dc	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.a7de	92 3c		sta ($3c)			sta 	(zsTemp)
.a7e0	68		pla				pla
.a7e1	60		rts				rts

;******  Return to file: _basic.asm

.a7e2					StartModuleCode:

;******  Processing file: ../modules/_build/_hardware.module

=1					hardwareIntegrated=1
=0					CONBlack = 0
=1					CONWhite = 1
=2					CONRed = 2
=3					CONCyan = 3
=4					CONPurple = 4
=5					CONGreen = 5
=6					CONBlue = 6
=7					CONYellow = 7
=8					CONOrange = 8
=9					CONBrown = 9
=10					CONYellowGreen = 10
=11					CONRosa = 11
=12					CONBlueGreen = 12
=13					CONLightBlue = 13
=14					CONPink = 14
=15					CONLightGreen = 15
=7					CONForeground = CONYellow
=6					CONBackground = CONBlue
=5					CLICommandLine = CONGreen
=0					CLIFComment = CONBlack
=7					CLIBComment = CONYellow
=9					CLILineNumber = CONBrown
=3					CLIToken = CONCyan
=13					CLIConstant = CONLightBlue
=7					CLIIdentifier = CONYellow
=10					CLIPunctuation = CONYellowGreen
=1					CLIData = CONWhite
.a7e2					Export_EXTPrintCharacter:
.a7e2					PAGEDPrintCharacter:
.a7e2	48		pha				pha
.a7e3	da		phx				phx
.a7e4	5a		phy				phy
.a7e5	a6 01		ldx $01				ldx 	1
.a7e7	da		phx				phx
.a7e8	ac 6e 06	ldy $066e			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.a7eb	09 00		ora #$00			ora 	#$00 						; check $80-$FF
.a7ed	30 48		bmi $a837			bmi 	_EXPCColour
.a7ef	c9 20		cmp #$20			cmp 	#$20 						; check $00-$1F
.a7f1	90 4d		bcc $a840			bcc 	_EXPCControl
.a7f3	a2 02		ldx #$02			ldx 	#2 							; select char memory
.a7f5	86 01		stx $01				stx 	1
.a7f7	91 40		sta ($40),y			sta 	(EXTAddress),y
.a7f9	e6 01		inc $01				inc 	1 							; select colour memory
.a7fb	ad 6f 06	lda $066f			lda 	EXTTextColour
.a7fe	91 40		sta ($40),y			sta 	(EXTAddress),y
.a800	c8		iny				iny 								; advance horizontal position
.a801	8c 6e 06	sty $066e			sty 	EXTColumn
.a804	cc 70 06	cpy $0670			cpy 	EXTScreenWidth 				; reached RHS ?
.a807	90 63		bcc $a86c			bcc 	_EXPCExit 					; no, then exit.
.a809					_EXPCCRLF:
.a809	ee 6d 06	inc $066d			inc 	EXTRow  					; bump row
.a80c	9c 6e 06	stz $066e			stz 	EXTColumn 					; back to column 0
.a80f	ad 6d 06	lda $066d			lda 	EXTRow 						; check if reached the bottom ?
.a812	cd 71 06	cmp $0671			cmp 	EXTScreenHeight 			; if so, then scroll.
.a815	f0 18		beq $a82f			beq 	_EXPCScroll
.a817	18		clc				clc 								; add width to address.
.a818	a5 40		lda $40				lda 	EXTAddress
.a81a	6d 70 06	adc $0670			adc 	EXTScreenWidth
.a81d	85 40		sta $40				sta 	EXTAddress
.a81f	90 4b		bcc $a86c			bcc 	_EXPCExit
.a821	e6 41		inc $41				inc 	EXTAddress+1
.a823	80 47		bra $a86c			bra 	_EXPCExit
.a825					_EXPCLeft:
.a825	ce 6e 06	dec $066e			dec 	EXTColumn
.a828	10 42		bpl $a86c			bpl 	_EXPCExit
.a82a					_EXPCBegin:
.a82a	9c 6e 06	stz $066e			stz 	EXTColumn
.a82d	80 3d		bra $a86c			bra 	_EXPCExit
.a82f					_EXPCScroll:
.a82f	ce 6d 06	dec $066d			dec 	EXTRow 						; the height-1 th line.
.a832	20 1d a9	jsr $a91d			jsr 	EXTScreenScroll 			; scroll the screen
.a835	80 35		bra $a86c			bra 	_EXPCExit
.a837					_EXPCColour:
.a837	c9 a0		cmp #$a0			cmp 	#$A0						; 80-9F set foreground/background
.a839	b0 31		bcs $a86c			bcs 	_EXPCExit
.a83b	20 fd a8	jsr $a8fd			jsr 	_EXPCHandleColour
.a83e	80 2c		bra $a86c			bra 	_EXPCExit
.a840					_EXPCControl:
.a840	c9 11		cmp #$11			cmp 	#$11 						; only handle 00-10.
.a842	b0 28		bcs $a86c			bcs 	_EXPCExit
.a844	0a		asl a				asl 	a 							; double into X
.a845	aa		tax				tax
.a846	7c db a8	jmp ($a8db,x)			jmp 	(_EXPCActionTable,x) 		; and execute code.
.a849					_EXPCUp:
.a849	ad 6d 06	lda $066d			lda 	EXTRow 						; already at top ?
.a84c	f0 1e		beq $a86c			beq 	_EXPCExit
.a84e	ce 6d 06	dec $066d			dec 	EXTRow 						; up one in position/address
.a851	38		sec				sec
.a852	a5 40		lda $40				lda 	EXTAddress
.a854	ed 70 06	sbc $0670			sbc 	EXTScreenWidth
.a857	85 40		sta $40				sta 	EXTAddress
.a859	b0 11		bcs $a86c			bcs 	_EXPCExit
.a85b	c6 41		dec $41				dec 	EXTAddress+1
.a85d	80 0d		bra $a86c			bra 	_EXPCExit
.a85f					_EXPCRight:
.a85f	c8		iny				iny
.a860	8c 6e 06	sty $066e			sty 	EXTColumn
.a863	cc 70 06	cpy $0670			cpy 	EXTScreenWidth
.a866	d0 04		bne $a86c			bne 	_EXPCExit
.a868	88		dey				dey
.a869					_EXPCSetColumnY:
.a869	8c 6e 06	sty $066e			sty 	EXTColumn
.a86c					_EXPCExit:
.a86c	20 72 a9	jsr $a972			jsr 	EXTSetHardwareCursor 		; place the physical cursor.
.a86f	68		pla				pla
.a870	85 01		sta $01				sta 	1
.a872	7a		ply				ply
.a873	fa		plx				plx
.a874	68		pla				pla
.a875	60		rts				rts
.a876					_EXPCClearScreen:
.a876	20 2f a9	jsr $a92f			jsr		EXTClearScreenCode
.a879	80 f1		bra $a86c			bra 	_EXPCExit
.a87b					_EXPCDown:
.a87b	ad 71 06	lda $0671			lda 	EXTScreenHeight 			; at the bottom
.a87e	3a		dec a				dec 	a
.a87f	cd 6d 06	cmp $066d			cmp 	EXTRow
.a882	f0 e8		beq $a86c			beq 	_EXPCExit
.a884	ee 6d 06	inc $066d			inc 	EXTRow 						; down one in position/address
.a887	18		clc				clc
.a888	a5 40		lda $40				lda 	EXTAddress
.a88a	6d 70 06	adc $0670			adc 	EXTScreenWidth
.a88d	85 40		sta $40				sta 	EXTAddress
.a88f	90 db		bcc $a86c			bcc 	_EXPCExit
.a891	e6 41		inc $41				inc 	EXTAddress+1
.a893	80 d7		bra $a86c			bra 	_EXPCExit
.a895					_EXPCTab:
.a895	ad 6e 06	lda $066e			lda 	EXTColumn 					; next tab stop
.a898	29 f8		and #$f8			and 	#$F8
.a89a	18		clc				clc
.a89b	69 08		adc #$08			adc 	#8
.a89d	8d 6e 06	sta $066e			sta 	EXTColumn
.a8a0	cd 70 06	cmp $0670			cmp 	EXTScreenWidth 				; too far, stick end of line.
.a8a3	90 c7		bcc $a86c			bcc 	_EXPCExit
.a8a5	80 10		bra $a8b7			bra 	_EXPCEnd
.a8a7					_EXPCBackSpace:
.a8a7	88		dey				dey
.a8a8	30 c2		bmi $a86c			bmi 	_EXPCExit
.a8aa	ce 6e 06	dec $066e			dec 	EXTColumn
.a8ad	a9 02		lda #$02			lda 	#2
.a8af	85 01		sta $01				sta 	1
.a8b1	a9 20		lda #$20			lda 	#32
.a8b3	91 40		sta ($40),y			sta 	(EXTAddress),y
.a8b5	80 b5		bra $a86c			bra 	_EXPCExit
.a8b7					_EXPCEnd:
.a8b7	a9 02		lda #$02			lda 	#2 							; access text screen
.a8b9	85 01		sta $01				sta 	1
.a8bb	ac 70 06	ldy $0670			ldy 	EXTScreenWidth 				; point to last character
.a8be	88		dey				dey
.a8bf					_EXPCEndSearch:
.a8bf	88		dey				dey 								; if past start, move to col 0.
.a8c0	30 06		bmi $a8c8			bmi 	_EXPCFound
.a8c2	b1 40		lda ($40),y			lda 	(EXTAddress),y 				; keep going back till non space found
.a8c4	c9 20		cmp #$20			cmp 	#' '
.a8c6	f0 f7		beq $a8bf			beq 	_EXPCEndSearch
.a8c8					_EXPCFound:
.a8c8	c8		iny				iny 								; move to following cell.
.a8c9	80 9e		bra $a869			bra 	_EXPCSetColumnY
.a8cb					_EXPCClearEOL:
.a8cb	a9 02		lda #$02			lda 	#2 							; access character RAM
.a8cd	85 01		sta $01				sta 	1
.a8cf	a9 20		lda #$20			lda 	#' ' 						; write space
.a8d1	91 40		sta ($40),y			sta 	(EXTAddress),y
.a8d3	c8		iny				iny
.a8d4	cc 70 06	cpy $0670			cpy 	EXTScreenWidth 				; until RHS of screen.
.a8d7	90 f2		bcc $a8cb			bcc 	_EXPCClearEOL
.a8d9	80 91		bra $a86c			bra 	_EXPCExit
.a8db					_EXPCActionTable:
>a8db	6c a8						.word 	_EXPCExit 					; 00
>a8dd	2a a8						.word 	_EXPCBegin 					; 01 A Start of Line
>a8df	25 a8						.word 	_EXPCLeft 					; 02 B Left
>a8e1	6c a8						.word 	_EXPCExit 					; 03 <Break>
>a8e3	6c a8						.word 	_EXPCExit 					; 04
>a8e5	b7 a8						.word 	_EXPCEnd 					; 05 E End of Line
>a8e7	5f a8						.word 	_EXPCRight 					; 06 F Right
>a8e9	6c a8						.word 	_EXPCExit 					; 07
>a8eb	a7 a8						.word 	_EXPCBackspace 				; 08 H Backspace
>a8ed	95 a8						.word 	_EXPCTab 					; 09 I Tab
>a8ef	6c a8						.word 	_EXPCExit 					; 0A
>a8f1	cb a8						.word 	_EXPCClearEOL 				; 0B K Clear to EOL
>a8f3	76 a8						.word 	_EXPCClearScreen			; 0C L CLS
>a8f5	09 a8						.word 	_EXPCCRLF 					; 0D M CR/LF
>a8f7	7b a8						.word 	_EXPCDown 					; 0E N Down
>a8f9	6c a8						.word 	_EXPCExit 					; 0F
>a8fb	49 a8						.word 	_EXPCUp 					; 10 P Up
.a8fd					_EXPCHandleColour
.a8fd	c9 90		cmp #$90			cmp 	#$90 						; 8x foreground 9x background
.a8ff	b0 16		bcs $a917			bcs 	_EXPCBackground
.a901	0a		asl a				asl 	a 							; shift it 4 bits to the right.
.a902	0a		asl a				asl 	a
.a903	0a		asl a				asl 	a
.a904	0a		asl a				asl 	a
.a905	a2 0f		ldx #$0f			ldx 	#$0F 						; Mask in X
.a907					_EXPCUpdate:
.a907	48		pha				pha 								; save new colour
.a908	8a		txa				txa 								; get mask
.a909	2d 6f 06	and $066f			and 	EXTTextColour 				; mask out old.
.a90c	8d 6f 06	sta $066f			sta 	EXTTextColour
.a90f	68		pla				pla 								; or in new colour
.a910	0d 6f 06	ora $066f			ora 	EXTTextColour
.a913	8d 6f 06	sta $066f			sta 	EXTTextColour
.a916	60		rts				rts
.a917					_EXPCBackground:
.a917	29 0f		and #$0f			and 	#$0F 						; get the colour
.a919	a2 f0		ldx #$f0			ldx 	#$F0 						; mask
.a91b	80 ea		bra $a907			bra 	_EXPCUpdate
.a91d					EXTScreenScroll:
.a91d	a9 02		lda #$02			lda 	#2 							; select text page
.a91f	85 01		sta $01				sta 	1
.a921	a9 20		lda #$20			lda		#32 						; fill with space
.a923	20 36 aa	jsr $aa36			jsr 	EXTScrollFill
.a926	e6 01		inc $01				inc 	1 							; select colour page
.a928	ad 6f 06	lda $066f			lda 	EXTTextColour
.a92b	20 36 aa	jsr $aa36			jsr 	EXTScrollFill
.a92e	60		rts				rts
.a92f					EXTClearScreenCode:
.a92f	a9 02		lda #$02			lda 	#2 							; select text page
.a931	85 01		sta $01				sta 	1
.a933	a9 20		lda #$20			lda		#32 						; fill with space
.a935	20 42 a9	jsr $a942			jsr 	_EXTCSFill
.a938	e6 01		inc $01				inc 	1 							; select colour page
.a93a	ad 6f 06	lda $066f			lda 	EXTTextColour
.a93d	20 42 a9	jsr $a942			jsr 	_EXTCSFill
.a940	80 22		bra $a964			bra 	EXTHomeCursor
.a942					_EXTCSFill:
.a942	aa		tax				tax
.a943	a9 00		lda #$00			lda 	#EXTMemory & $FF
.a945	85 40		sta $40				sta 	EXTAddress
.a947	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a949	85 41		sta $41				sta 	EXTAddress+1
.a94b					_EXTCSFill1:
.a94b	a0 00		ldy #$00			ldy 	#0
.a94d	8a		txa				txa
.a94e					_EXTCSFill2:
.a94e	91 40		sta ($40),y			sta 	(EXTAddress),y
.a950	c8		iny				iny
.a951	d0 fb		bne $a94e			bne 	_EXTCSFill2
.a953	e6 41		inc $41				inc 	EXTAddress+1
.a955	a5 41		lda $41				lda 	EXTAddress+1
.a957	c9 d2		cmp #$d2			cmp 	#$D2
.a959	d0 f0		bne $a94b			bne 	_EXTCSFill1
.a95b	8a		txa				txa
.a95c					_EXTCSFill3:
.a95c	91 40		sta ($40),y			sta 	(EXTAddress),y
.a95e	c8		iny				iny
.a95f	c0 c0		cpy #$c0			cpy 	#$C0
.a961	d0 f9		bne $a95c			bne 	_EXTCSFill3
.a963	60		rts				rts
.a964					EXTHomeCursor:
.a964	9c 6d 06	stz $066d			stz 	EXTRow 						; reset row & column
.a967	9c 6e 06	stz $066e			stz 	EXTColumn
.a96a	a9 00		lda #$00			lda 	#EXTMemory & $FF 			; set address
.a96c	85 40		sta $40				sta 	EXTAddress
.a96e	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a970	85 41		sta $41				sta 	EXTAddress+1
.a972					EXTSetHardwareCursor:
.a972	64 01		stz $01				stz 	1 							; I/O Page zero
.a974	a9 05		lda #$05			lda 	#1+4 						; enable cursor
.a976	8d 10 d0	sta $d010			sta 	$D010
.a979	a9 b1		lda #$b1			lda 	#$B1
.a97b	8d 12 d0	sta $d012			sta 	$D012
.a97e	ad 6e 06	lda $066e			lda 	EXTColumn
.a981	8d 14 d0	sta $d014			sta 	$D014 						; set cursor position
.a984	9c 15 d0	stz $d015			stz 	$D015
.a987	ad 6d 06	lda $066d			lda 	EXTRow
.a98a	8d 16 d0	sta $d016			sta 	$D016
.a98d	9c 17 d0	stz $d017			stz 	$D017
.a990	60		rts				rts
.a991					Export_EXTInputLine:
.a991	48		pha				pha
.a992	da		phx				phx
.a993	5a		phy				phy
.a994	a5 01		lda $01				lda 	1 							; save I/O page
.a996	48		pha				pha
.a997					_EILLoop:
.a997	20 b1 aa	jsr $aab1			jsr 	PagedInputSingleCharacter
.a99a	c9 0d		cmp #$0d			cmp 	#13 						; scrape line if exit.
.a99c	f0 44		beq $a9e2			beq 	_EILExit
.a99e	c9 04		cmp #$04			cmp 	#4 							; Ctrl+D delete at cursor
.a9a0	f0 2a		beq $a9cc			beq 	_EILDelete
.a9a2	c9 08		cmp #$08			cmp 	#8 							; Ctrl+H backspace
.a9a4	f0 1c		beq $a9c2			beq 	_EILBackspace
.a9a6	c9 20		cmp #$20			cmp 	#' '						; < space, print it
.a9a8	90 12		bcc $a9bc			bcc 	_EILPrintLoop
.a9aa	c9 7f		cmp #$7f			cmp 	#$7F 						; if -ve print it
.a9ac	b0 0e		bcs $a9bc			bcs 	_EILPrintLoop
.a9ae	48		pha				pha 								; save character
.a9af	a9 02		lda #$02			lda 	#2  						; insert a space
.a9b1	85 01		sta $01				sta 	1
.a9b3	20 24 aa	jsr $aa24			jsr 	EXTILInsert 				; insert in text screen
.a9b6	e6 01		inc $01				inc 	1
.a9b8	20 24 aa	jsr $aa24			jsr 	EXTILInsert 				; insert in colour screen
.a9bb	68		pla				pla 								; get character back.
.a9bc					_EILPrintLoop:
.a9bc	20 e2 a7	jsr $a7e2			jsr 	PagedPrintCharacter
.a9bf	80 d6		bra $a997			bra 	_EILLoop
.a9c1	60		rts				rts
.a9c2					_EILBackspace:
.a9c2	ad 6e 06	lda $066e			lda 	EXTColumn					; can we backspace ?
.a9c5	f0 d0		beq $a997			beq 	_EILLoop
.a9c7	a9 02		lda #$02			lda 	#2 							; move cursor left
.a9c9	20 e2 a7	jsr $a7e2			jsr 	PagedPrintCharacter
.a9cc					_EILDelete
.a9cc	a9 02		lda #$02			lda 	#2 							; text block
.a9ce	85 01		sta $01				sta 	1
.a9d0	a9 20		lda #$20			lda 	#' ' 						; backspace text.
.a9d2	20 0f aa	jsr $aa0f			jsr 	EXTILDelete
.a9d5	e6 01		inc $01				inc 	1 							; colour block
.a9d7	ac 6e 06	ldy $066e			ldy 	EXTColumn 					; get attribute of last character
.a9da	88		dey				dey
.a9db	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a9dd	20 0f aa	jsr $aa0f			jsr 	EXTILDelete 				; backspace attribute
.a9e0	80 b5		bra $a997			bra 	_EILLoop 					; and go round.
.a9e2					_EILExit:
.a9e2	a9 02		lda #$02			lda 	#2 							; switch to page 2
.a9e4	85 01		sta $01				sta 	1
.a9e6	a0 00		ldy #$00			ldy 	#0 							; copy current line into buffer.
.a9e8					_EILScrapeLine:
.a9e8	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a9ea	99 2a 05	sta $052a,y			sta 	lineBuffer,y
.a9ed	c8		iny				iny
.a9ee	cc 70 06	cpy $0670			cpy 	EXTScreenWidth
.a9f1	d0 f5		bne $a9e8			bne 	_EILScrapeLine
.a9f3					_EILTrimSpaces:
.a9f3	88		dey				dey
.a9f4	f0 08		beq $a9fe			beq 	_EILEndTrim
.a9f6	b9 2a 05	lda $052a,y			lda 	lineBuffer,y
.a9f9	c9 20		cmp #$20			cmp 	#' '
.a9fb	f0 f6		beq $a9f3			beq 	_EILTrimSpaces
.a9fd	c8		iny				iny 								; trim after non space character.
.a9fe					_EILEndTrim:
.a9fe	a9 00		lda #$00			lda 	#0 							; trim here.
.aa00	99 2a 05	sta $052a,y			sta 	lineBuffer,y
.aa03	a9 0d		lda #$0d			lda 	#13 						; echo the RETURN
.aa05	20 e2 a7	jsr $a7e2			jsr 	PagedPrintCharacter
.aa08	68		pla				pla 								; reset I/O page
.aa09	85 01		sta $01				sta 	1
.aa0b	7a		ply				ply
.aa0c	fa		plx				plx
.aa0d	68		pla				pla
.aa0e	60		rts				rts
.aa0f					EXTILDelete:
.aa0f	48		pha				pha 								; save the new character
.aa10	ac 6e 06	ldy $066e			ldy 	EXTColumn 					; start copying from here.
.aa13					_EXTDLoop:
.aa13	c8		iny				iny 								; copy one byte down.
.aa14	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa16	88		dey				dey
.aa17	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa19	c8		iny				iny 								; do till end of line.
.aa1a	cc 70 06	cpy $0670			cpy 	EXTScreenWidth
.aa1d	90 f4		bcc $aa13			bcc 	_EXTDLoop
.aa1f	88		dey				dey 	 							; write in last slot.
.aa20	68		pla				pla
.aa21	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa23	60		rts				rts
.aa24					EXTILInsert:
.aa24	ac 70 06	ldy $0670			ldy 	EXTScreenWidth 				; end position
.aa27					_EXTILoop:
.aa27	88		dey				dey 								; back one
.aa28	cc 6e 06	cpy $066e			cpy 	EXTColumn 					; exit if reached insert point.
.aa2b	f0 08		beq $aa35			beq 	_EXTIExit
.aa2d	88		dey				dey 								; copy one byte up.
.aa2e	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa30	c8		iny				iny
.aa31	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa33	80 f2		bra $aa27			bra 	_EXTILoop
.aa35					_EXTIExit:
.aa35	60		rts				rts
.aa36					EXTScrollFill:
.aa36	aa		tax				tax									; save value to fill with
.aa37	a5 36		lda $36				lda 	zTemp0 						; save zTemp0 (dest) zTemp1 (src)
.aa39	48		pha				pha
.aa3a	a5 37		lda $37				lda 	zTemp0+1
.aa3c	48		pha				pha
.aa3d	a5 38		lda $38				lda 	zTemp1
.aa3f	48		pha				pha
.aa40	a5 39		lda $39				lda 	zTemp1+1
.aa42	48		pha				pha
.aa43	a9 c0		lda #$c0			lda 	#$C0 						; copy from C000+length to C000
.aa45	85 37		sta $37				sta 	zTemp0+1
.aa47	85 39		sta $39				sta 	zTemp1+1
.aa49	64 36		stz $36				stz 	zTemp0
.aa4b	ad 70 06	lda $0670			lda 	EXTScreenWidth
.aa4e	85 38		sta $38				sta 	zTemp1
.aa50	a0 00		ldy #$00			ldy 	#0
.aa52					_EXSFCopy1:
.aa52	b1 38		lda ($38),y			lda 	(zTemp1),y
.aa54	91 36		sta ($36),y			sta 	(zTemp0),y
.aa56	c8		iny				iny
.aa57	d0 f9		bne $aa52			bne 	_EXSFCopy1
.aa59	e6 37		inc $37				inc 	zTemp0+1 					; next page
.aa5b	e6 39		inc $39				inc 	zTemp1+1
.aa5d	a5 39		lda $39				lda 	zTemp1+1
.aa5f	c9 d3		cmp #$d3			cmp 	#$D3
.aa61	d0 ef		bne $aa52			bne 	_EXSFCopy1
.aa63	ac 70 06	ldy $0670			ldy 	EXTScreenWidth 				; blank the bottom line.
.aa66	8a		txa				txa
.aa67					_EXSFFill1:
.aa67	88		dey				dey
.aa68	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa6a	c0 00		cpy #$00			cpy 	#0
.aa6c	10 f9		bpl $aa67			bpl 	_EXSFFill1
.aa6e	68		pla				pla
.aa6f	85 39		sta $39				sta 	zTemp1+1
.aa71	68		pla				pla
.aa72	85 38		sta $38				sta 	zTemp1
.aa74	68		pla				pla
.aa75	85 37		sta $37				sta 	zTemp0+1
.aa77	68		pla				pla
.aa78	85 36		sta $36				sta 	zTemp0
.aa7a	60		rts				rts
=$c000					EXTMemory = $C000
=$02					EXTTextPage = $02
=$03					EXTColourPage = $03
=1					EXTDummySpace = 1 							; fake-space for CR character.
=0					EXTCBlack = 0
.066d					EXTRow:
>066d							.fill 	1
.066e					EXTColumn:
>066e							.fill 	1
.066f					EXTTextColour:
>066f							.fill 	1
.0670					EXTScreenWidth:
>0670							.fill 	1
.0671					EXTScreenHeight:
>0671							.fill 	1
.0040					EXTAddress:
>0040							.fill 	2
.aa7b					Export_EXTInitialise:
.aa7b	64 01		stz $01				stz 	1 							; Access I/O page 0
.aa7d	9c 04 d0	stz $d004			stz 	$D004 						; Disable border
.aa80	9c 08 d0	stz $d008			stz 	$D008
.aa83	9c 09 d0	stz $d009			stz 	$D009
.aa86	a9 09		lda #$09			lda 	#1+8						; Timer On at 70Hz counting up.
.aa88	8d 58 d6	sta $d658			sta 	$D658
.aa8b	a9 03		lda #$03			lda 	#3 							; get current text colour from whatever the kernel
.aa8d	85 01		sta $01				sta 	1 							; has set it to, looking at top left character
.aa8f	ad 00 c0	lda $c000			lda 	$C000
.aa92	8d 6f 06	sta $066f			sta 	EXTTextColour
.aa95	a9 50		lda #$50			lda 	#80 						; set screen dimensions.
.aa97	8d 70 06	sta $0670			sta 	EXTScreenWidth
.aa9a	a9 3c		lda #$3c			lda 	#60
.aa9c	8d 71 06	sta $0671			sta 	EXTScreenHeight
.aa9f	20 64 a9	jsr $a964			jsr 	EXTHomeCursor 				; home cursor
.aaa2					_EXMoveDown:
.aaa2	a9 0d		lda #$0d			lda 	#13
.aaa4	20 e2 a7	jsr $a7e2			jsr 	PAGEDPrintCharacter
.aaa7	ad 6d 06	lda $066d			lda 	EXTRow
.aaaa	c9 08		cmp #$08			cmp 	#8
.aaac	d0 f4		bne $aaa2			bne 	_EXMoveDown
.aaae	64 01		stz $01				stz 	1
.aab0	60		rts				rts
.aab1					Export_EXTInputSingleCharacter:
.aab1					PagedInputSingleCharacter:
.aab1	da		phx				phx
.aab2	5a		phy				phy
.aab3					_EISCWait:
.aab3	a5 01		lda $01				lda 	1 							; save I/O 0
.aab5	48		pha				pha
.aab6	64 01		stz $01				stz 	1 							; access I/O Page 0
.aab8	38		sec				sec 								; calculate timer - LastTick
.aab9	ad 59 d6	lda $d659			lda 	$D659
.aabc	aa		tax				tax 								; saving timer in X
.aabd	ed 5c 06	sbc $065c			sbc 	LastTick
.aac0	c9 03		cmp #$03			cmp 	#3
.aac2	90 06		bcc $aaca			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.aac4	8e 5c 06	stx $065c			stx 	LastTick 					; update last timer
.aac7	20 8d be	jsr $be8d			jsr 	PagedSNDUpdate 							; go do the code.
.aaca					_NoFireTick:
.aaca	68		pla				pla 								; restore I/O 0
.aacb	85 01		sta $01				sta 	1
.aacd	20 e4 ff	jsr $ffe4			jsr 	$FFE4 						; get a key
.aad0	c9 00		cmp #$00			cmp 	#0 							; loop back if none pressed.
.aad2	f0 df		beq $aab3			beq 	_EISCWait
.aad4	7a		ply				ply
.aad5	fa		plx				plx
.aad6	60		rts				rts
.aad7					Export_EXTBreakCheck:
.aad7	4c e1 ff	jmp $ffe1			jmp		$FFE1
.aada					Export_EXTReadController:
.aada	da		phx				phx
.aadb	a2 00		ldx #$00			ldx 	#0
.aadd	a9 05		lda #$05			lda 	#(($2D) >> 3)
.aadf	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aae2	29 20		and #$20			and 	#($01 << (($2D) & 7))
.aae4	f0 04		beq $aaea			beq 	_NoSet1
.aae6	8a		txa				txa
.aae7	09 01		ora #$01			ora 	#1
.aae9	aa		tax				tax
.aaea					_NoSet1:
.aaea	a9 05		lda #$05			lda 	#(($2C) >> 3)
.aaec	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aaef	29 10		and #$10			and 	#($01 << (($2C) & 7))
.aaf1	f0 04		beq $aaf7			beq 	_NoSet1
.aaf3	8a		txa				txa
.aaf4	09 02		ora #$02			ora 	#2
.aaf6	aa		tax				tax
.aaf7					_NoSet1:
.aaf7	a9 06		lda #$06			lda 	#(($32) >> 3)
.aaf9	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aafc	29 04		and #$04			and 	#($01 << (($32) & 7))
.aafe	f0 04		beq $ab04			beq 	_NoSet1
.ab00	8a		txa				txa
.ab01	09 04		ora #$04			ora 	#4
.ab03	aa		tax				tax
.ab04					_NoSet1:
.ab04	a9 04		lda #$04			lda 	#(($25) >> 3)
.ab06	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab09	29 20		and #$20			and 	#($01 << (($25) & 7))
.ab0b	f0 04		beq $ab11			beq 	_NoSet1
.ab0d	8a		txa				txa
.ab0e	09 08		ora #$08			ora 	#8
.ab10	aa		tax				tax
.ab11					_NoSet1:
.ab11	a9 04		lda #$04			lda 	#(($26) >> 3)
.ab13	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab16	29 40		and #$40			and 	#($01 << (($26) & 7))
.ab18	f0 04		beq $ab1e			beq 	_NoSet1
.ab1a	8a		txa				txa
.ab1b	09 10		ora #$10			ora 	#16
.ab1d	aa		tax				tax
.ab1e					_NoSet1:
.ab1e	8a		txa				txa
.ab1f	fa		plx				plx
.ab20	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_graphics.module

=1					graphicsIntegrated=1
=0					GCMD_Initialise = 0*2
=2					GCMD_BitmapCtl = 1*2
=4					GCMD_SpriteCtl = 2*2
=6					GCMD_Clear = 3*2
=8					GCMD_Colour = 4*2
=10					GCMD_DrawFont = 5*2
=12					GCMD_DrawSprite = 6*2
=14					GCMD_SpriteUse = 7*2
=16					GCMD_SpriteImage = 8*2
=18					GCMD_SpriteCollide = 9*2
=64					GCMD_Move = 32*2
=66					GCMD_Line = 33*2
=68					GCMD_FrameRect = 34*2
=70					GCMD_FillRect = 35*2
=72					GCMD_FrameCircle = 36*2
=74					GCMD_FillCircle = 37*2
=80					GCMD_Plot = 40*2
=82					GCMD_SpriteMove = 41*2
=42					GRFirstFreeCode = 42
.ab21					GRVectorTable:
>ab21	70 ad					.word	GXInitialise             ; $00 Initialise
>ab23	8a ad					.word	GXControlBitmap          ; $01 BitmapCtl
>ab25	d2 ad					.word	GXControlSprite          ; $02 SpriteCtl
>ab27	22 ad					.word	GXClearBitmap            ; $03 Clear
>ab29	61 af					.word	GXSetColourMode          ; $04 Colour
>ab2b	29 b1					.word	GXFontHandler            ; $05 DrawFont
>ab2d	71 b1					.word	GXSpriteHandler          ; $06 DrawSprite
>ab2f	e2 b1					.word	GXSelect                 ; $07 SpriteUse
>ab31	0b b2					.word	GXSelectImage            ; $08 SpriteImage
>ab33	92 b3					.word	GXCollide                ; $09 SpriteCollide
>ab35	d4 ab					.word	GRUndefined              ; $0a
>ab37	d4 ab					.word	GRUndefined              ; $0b
>ab39	d4 ab					.word	GRUndefined              ; $0c
>ab3b	d4 ab					.word	GRUndefined              ; $0d
>ab3d	d4 ab					.word	GRUndefined              ; $0e
>ab3f	d4 ab					.word	GRUndefined              ; $0f
>ab41	d4 ab					.word	GRUndefined              ; $10
>ab43	d4 ab					.word	GRUndefined              ; $11
>ab45	d4 ab					.word	GRUndefined              ; $12
>ab47	d4 ab					.word	GRUndefined              ; $13
>ab49	d4 ab					.word	GRUndefined              ; $14
>ab4b	d4 ab					.word	GRUndefined              ; $15
>ab4d	d4 ab					.word	GRUndefined              ; $16
>ab4f	d4 ab					.word	GRUndefined              ; $17
>ab51	d4 ab					.word	GRUndefined              ; $18
>ab53	d4 ab					.word	GRUndefined              ; $19
>ab55	d4 ab					.word	GRUndefined              ; $1a
>ab57	d4 ab					.word	GRUndefined              ; $1b
>ab59	d4 ab					.word	GRUndefined              ; $1c
>ab5b	d4 ab					.word	GRUndefined              ; $1d
>ab5d	d4 ab					.word	GRUndefined              ; $1e
>ab5f	d4 ab					.word	GRUndefined              ; $1f
>ab61	d2 ab					.word	GXMove                   ; $20 Move
>ab63	2f ae					.word	GXLine                   ; $21 Line
>ab65	aa af					.word	GXFrameRectangle         ; $22 FrameRect
>ab67	a7 af					.word	GXFillRectangle          ; $23 FillRect
>ab69	d9 ab					.word	GXFrameCircle            ; $24 FrameCircle
>ab6b	d5 ab					.word	GXFillCircle             ; $25 FillCircle
>ab6d	d4 ab					.word	GRUndefined              ; $26
>ab6f	d4 ab					.word	GRUndefined              ; $27
>ab71	8f af					.word	GXPlotPoint              ; $28 Plot
>ab73	a1 b2					.word	GXMoveSprite             ; $29 SpriteMove
=3					GXMappingPage = 3
=24576					GXMappingAddress = ($2000 * GXMappingPage)
=11					GXEditSlot = 8 + GXMappingPage
=$36					gxzTemp0 = zTemp0
=$38					gxzTemp1 = zTemp1
=$3a					gxzTemp2 = zTemp2
=$3c					gxzScreen = zsTemp
=$627					gxPixelBuffer = numberBuffer
.0672					gxCurrentX:
>0672							.fill 	2
.0674					gxCurrentY:
>0674							.fill 	2
.0676					gxLastX:
>0676							.fill 	2
.0678					gxLastY:
>0678							.fill 	2
.067a					gxX0:
>067a							.fill 	2
.067c					gxY0:
>067c							.fill 	2
.067e					gxX1:
>067e							.fill 	2
.0680					gxY1:
>0680							.fill 	2
.0682					gxSpritesOn:
>0682							.fill 	1
.0683					gxBitmapsOn:
>0683							.fill 	1
.0684					gxBasePage:
>0684							.fill 	1
.0685					gxSpritePage:
>0685							.fill 	1
.0686					gxHeight:
>0686							.fill 	1
.0687					gxMode:
>0687							.fill 	1
.0688					gxColour:
>0688							.fill 	1
.0689					gxEORValue:
>0689							.fill 	1
.068a					gxANDValue:
>068a							.fill 	1
.068b					gxOriginalLUTValue:
>068b							.fill 	1
.068c					gsOffset:
>068c							.fill 	1
.068d					GSCurrentSpriteID:
>068d							.fill 	1
.068e					GSCurrentSpriteAddr:
>068e							.fill 	2
.0690					GXSpriteOffsetBase:
>0690							.fill 	2
.0692					GXSpriteLow:
>0692							.fill 	64
.06d2					GXSpriteHigh:
>06d2							.fill 	64
.ab75					Export_GXGraphicDraw:
.ab75	c9 40		cmp #$40			cmp 	#GCMD_Move					; low instructions don't use coordinates
.ab77	b0 06		bcs $ab7f			bcs 	_GDCoordinate
.ab79	86 36		stx $36				stx 	gxzTemp0 					; save X/Y
.ab7b	84 37		sty $37				sty 	gxzTemp0+1
.ab7d	80 4b		bra $abca			bra 	_GDExecuteA 				; and execute
.ab7f					_GDCoordinate:
.ab7f	48		pha				pha 								; save AXY
.ab80	da		phx				phx
.ab81	5a		phy				phy
.ab82	a2 03		ldx #$03			ldx 	#3 							; copy currentX to lastX
.ab84					_GDCopy1:
.ab84	bd 72 06	lda $0672,x			lda 	gxCurrentX,x
.ab87	9d 76 06	sta $0676,x			sta 	gxLastX,x
.ab8a	ca		dex				dex
.ab8b	10 f7		bpl $ab84			bpl 	_GDCopy1
.ab8d	68		pla				pla 								; update Y
.ab8e	8d 74 06	sta $0674			sta 	gxCurrentY
.ab91	9c 75 06	stz $0675			stz 	gxCurrentY+1
.ab94	68		pla				pla
.ab95	8d 72 06	sta $0672			sta 	gxCurrentX
.ab98	68		pla				pla 								; get A (command+X.1) back
.ab99	48		pha				pha
.ab9a	29 01		and #$01			and 	#1 							; put LSB as MSB of Current.X
.ab9c	8d 73 06	sta $0673			sta 	gxCurrentX+1
.ab9f	68		pla				pla 								; get command back
.aba0	29 fe		and #$fe			and 	#$FE 						; lose LSB, chuck the stray X bit
.aba2	48		pha				pha 								; push back.
.aba3	c9 52		cmp #$52			cmp 	#GCMD_SpriteMove 			; move sprite does not clip.
.aba5	f0 17		beq $abbe			beq 	_GDCopyToWorkArea
.aba7	ad 73 06	lda $0673			lda 	gxCurrentX+1 				; X < 256 X okay
.abaa	f0 07		beq $abb3			beq 	_GDCheckY
.abac	ad 72 06	lda $0672			lda 	gxCurrentX 					; otherwise X < 320 = 256 + 64
.abaf	c9 40		cmp #$40			cmp 	#64
.abb1	b0 08		bcs $abbb			bcs 	_GDError1
.abb3					_GDCheckY:
.abb3	ad 74 06	lda $0674			lda 	gxCurrentY 					; check Y < Height.
.abb6	cd 86 06	cmp $0686			cmp 	gxHeight
.abb9	90 03		bcc $abbe			bcc 	_GDCopyToWorkArea
.abbb					_GDError1:
.abbb	68		pla				pla
.abbc					_GDError2:
.abbc	38		sec				sec
.abbd	60		rts				rts
.abbe					_GDCopyToWorkArea:
.abbe	a2 07		ldx #$07			ldx 	#7 							; copy current and last to gxXY/12 work area
.abc0					_GDCopy2:
.abc0	bd 72 06	lda $0672,x			lda 	gxCurrentX,x
.abc3	9d 7a 06	sta $067a,x			sta 	gxX0,x
.abc6	ca		dex				dex
.abc7	10 f7		bpl $abc0			bpl 	_GDCopy2
.abc9	68		pla				pla 								; get command
.abca					_GDExecuteA:
.abca	c9 54		cmp #$54			cmp 	#GRFirstFreeCode*2 			; bad ?
.abcc	b0 ee		bcs $abbc			bcs 	_GDError2
.abce	aa		tax				tax
.abcf	7c 21 ab	jmp ($ab21,x)			jmp 	(GRVectorTable,x)
.abd2					GXMove:
.abd2	18		clc				clc
.abd3	60		rts				rts
.abd4					GRUndefined:
>abd4	db						.byte 	$DB 						; causes a break in the emulator
.abd5					GXFillCircle:
.abd5	a9 ff		lda #$ff			lda 	#255
.abd7	80 02		bra $abdb			bra 	GXCircle
.abd9					GXFrameCircle:
.abd9	a9 00		lda #$00			lda 	#0
.abdb					GXCircle:
.abdb	8d 15 07	sta $0715			sta 	gxIsFillMode					; save Fill flag
.abde	ad 83 06	lda $0683			lda 	gxBitmapsOn
.abe1	f0 26		beq $ac09			beq 	_GXCFail
.abe3	20 39 b4	jsr $b439			jsr 	GXSortXY 					; topleft/bottomright
.abe6	20 11 b3	jsr $b311			jsr 	GXOpenBitmap 				; start drawing
.abe9	20 db ac	jsr $acdb			jsr 	GXCircleSetup 				; set up for drawing
.abec	9c 16 07	stz $0716			stz 	gxYChanged
.abef					_GXCircleDraw:
.abef	ad 13 07	lda $0713			lda 	gXCentre					; while x <= y
.abf2	cd 14 07	cmp $0714			cmp 	gYCentre
.abf5	90 0a		bcc $ac01			bcc 	_GXCircleContinue
.abf7	d0 03		bne $abfc			bne 	_GXNoLast
.abf9	20 0e ac	jsr $ac0e			jsr 	GXPlot1
.abfc					_GXNoLast:
.abfc	20 19 b3	jsr $b319			jsr 	GXCloseBitmap 				; close the bitmap
.abff	18		clc				clc
.ac00	60		rts				rts
.ac01					_GXCircleContinue:
.ac01	20 0b ac	jsr $ac0b			jsr 	GXPlot2 					; draw it
.ac04	20 88 ac	jsr $ac88			jsr 	GXCircleMove 				; adjust the coordinates
.ac07	80 e6		bra $abef			bra 	_GXCircleDraw
.ac09					_GXCFail:
.ac09	38		sec				sec
.ac0a	60		rts				rts
.ac0b					GXPlot2:
.ac0b	20 0e ac	jsr $ac0e			jsr 	GXPlot1 						; plot and swap, fall through does twice
.ac0e					GXPlot1:
.ac0e	ad 14 07	lda $0714			lda 	gYCentre 						; if y = 0, don't do it twice (xor)
.ac11	f0 03		beq $ac16			beq 	_GXPlot1Only
.ac13	20 32 ac	jsr $ac32			jsr 	GXPlot0 						; plot and negate
.ac16					_GXPlot1Only:
.ac16	20 32 ac	jsr $ac32			jsr 	GXPlot0 						; twice, undoing negation
.ac19	ad 13 07	lda $0713			lda 	gXCentre 						; swap X and Y
.ac1c	ae 14 07	ldx $0714			ldx	 	gYCentre
.ac1f	8d 14 07	sta $0714			sta 	gYCentre
.ac22	8e 13 07	stx $0713			stx 	gXCentre
.ac25	ad 16 07	lda $0716			lda 	gxYChanged 						; toggle Y Changed flag
.ac28	a9 ff		lda #$ff			lda 	#$FF
.ac2a	8d 16 07	sta $0716			sta 	gxYChanged
.ac2d	60		rts				rts
.ac2e	20 32 ac	jsr $ac32			jsr 	GXPlot0 						; do once
.ac31	60		rts				rts
.ac32	ad 15 07	lda $0715	GXPlot0:lda 	gxIsFillMode 					; outline mode, always draw as X or Y will change
.ac35	f0 05		beq $ac3c			beq 	_GXPlot0Always
.ac37	ad 16 07	lda $0716			lda 	gxYChanged						; fill mode, only draw if changed.
.ac3a	f0 2d		beq $ac69			beq 	GXPlot0Exit
.ac3c					_GXPlot0Always:
.ac3c	a2 02		ldx #$02			ldx 	#2 								; copy Y1-A => Y0
.ac3e	ad 14 07	lda $0714			lda 	gYCentre
.ac41	20 6a ac	jsr $ac6a			jsr 	GXSubCopy
.ac44	a2 00		ldx #$00			ldx 	#0 								; copy X1-A => X0,
.ac46	ad 13 07	lda $0713			lda 	gXCentre
.ac49	20 6a ac	jsr $ac6a			jsr 	GXSubCopy
.ac4c	48		pha				pha 									; save last offset X
.ac4d	20 21 b3	jsr $b321			jsr 	GXPositionCalc 					; calculate position/offset.
.ac50	68		pla				pla
.ac51	0a		asl a				asl 	a 								; store 2 x last offset in gxzTemp0
.ac52	85 36		sta $36				sta 	gxzTemp0
.ac54	64 37		stz $37				stz 	gxzTemp0+1
.ac56	26 37		rol $37				rol 	gxzTemp0+1
.ac58	ad 15 07	lda $0715			lda 	gxIsFillMode
.ac5b	69 80		adc #$80			adc 	#128
.ac5d	20 fa af	jsr $affa			jsr 	GXDrawLineTemp0 				; routine from Rectangle.
.ac60	38		sec				sec 									; GY = -GY
.ac61	a9 00		lda #$00			lda 	#0
.ac63	ed 14 07	sbc $0714			sbc 	gYCentre
.ac66	8d 14 07	sta $0714			sta 	gYCentre
.ac69					GXPlot0Exit:
.ac69	60		rts				rts
.ac6a					GXSubCopy:
.ac6a	85 36		sta $36				sta 	gxzTemp0
.ac6c	64 37		stz $37				stz 	gxzTemp0+1
.ac6e	29 80		and #$80			and 	#$80
.ac70	f0 02		beq $ac74			beq 	_GXNoSx
.ac72	c6 37		dec $37				dec 	gxzTemp0+1
.ac74					_GXNoSx:
.ac74	38		sec				sec
.ac75	bd 7e 06	lda $067e,x			lda 	gXX1,x
.ac78	e5 36		sbc $36				sbc 	gxzTemp0
.ac7a	9d 7a 06	sta $067a,x			sta 	gXX0,x
.ac7d	bd 7f 06	lda $067f,x			lda 	gXX1+1,x
.ac80	e5 37		sbc $37				sbc 	gxzTemp0+1
.ac82	9d 7b 06	sta $067b,x			sta 	gXX0+1,x
.ac85	a5 36		lda $36				lda 	gxzTemp0 						; return A
.ac87	60		rts				rts
.ac88					GXCircleMove:
.ac88	9c 16 07	stz $0716			stz 	gxYChanged 					; clear Y changed flag
.ac8b	a5 39		lda $39				lda 	gxzTemp1+1 					; check sign of D
.ac8d	10 0d		bpl $ac9c			bpl 	_GXEMPositive
.ac8f	ee 13 07	inc $0713			inc 	gXCentre 					; X++
.ac92	ad 13 07	lda $0713			lda 	gXCentre
.ac95	20 bb ac	jsr $acbb			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.ac98	a9 06		lda #$06			lda 	#6  						; and add 6
.ac9a	80 15		bra $acb1			bra 	_GXEMAddD
.ac9c					_GXEMPositive:
.ac9c	ee 13 07	inc $0713			inc 	gXCentre					; X++
.ac9f	ce 14 07	dec $0714			dec 	gyCentre 					; Y--
.aca2	38		sec				sec 								; calculate X-Y
.aca3	ad 13 07	lda $0713			lda 	gXCentre
.aca6	ed 14 07	sbc $0714			sbc 	gYCentre
.aca9	20 bb ac	jsr $acbb			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.acac	a9 0a		lda #$0a			lda 	#10  						; and add 10
.acae	ce 16 07	dec $0716			dec 	gxYChanged
.acb1					_GXEMAddD:
.acb1	18		clc				clc
.acb2	65 38		adc $38				adc 	gxzTemp1
.acb4	85 38		sta $38				sta 	gxzTemp1
.acb6	90 02		bcc $acba			bcc 	_GXEMNoCarry
.acb8	e6 39		inc $39				inc 	gxzTemp1+1
.acba					_GXEMNoCarry:
.acba	60		rts				rts
.acbb					_GXAdd4TimesToD:
.acbb	85 36		sta $36				sta 	gxzTemp0 					; make 16 bit signed.
.acbd	29 80		and #$80			and 	#$80
.acbf	f0 02		beq $acc3			beq 	_GXA4Unsigned
.acc1	a9 ff		lda #$ff			lda 	#$FF
.acc3					_GXA4Unsigned:
.acc3	85 37		sta $37				sta 	gxzTemp0+1
.acc5	06 36		asl $36				asl 	gxzTemp0  					; x 4
.acc7	26 37		rol $37				rol 	gxzTemp0+1
.acc9	06 36		asl $36				asl 	gxzTemp0
.accb	26 37		rol $37				rol 	gxzTemp0+1
.accd	18		clc				clc 								; add
.acce	a5 36		lda $36				lda		gxzTemp0
.acd0	65 38		adc $38				adc 	gxzTemp1
.acd2	85 38		sta $38				sta 	gxzTemp1
.acd4	a5 37		lda $37				lda		gxzTemp0+1
.acd6	65 39		adc $39				adc 	gxzTemp1+1
.acd8	85 39		sta $39				sta 	gxzTemp1+1
.acda	60		rts				rts
.acdb					GXCircleSetup:
.acdb	38		sec				sec
.acdc	ad 80 06	lda $0680			lda 	gxY1
.acdf	ed 7c 06	sbc $067c			sbc 	gxY0
.ace2	4a		lsr a				lsr 	a
.ace3	8d 12 07	sta $0712			sta 	gxRadius
.ace6	a2 00		ldx #$00			ldx 	#0
.ace8	20 0a ad	jsr $ad0a			jsr 	_GXCalculateCentre
.aceb	a2 02		ldx #$02			ldx 	#2
.aced	20 0a ad	jsr $ad0a			jsr 	_GXCalculateCentre
.acf0	9c 13 07	stz $0713			stz 	gXCentre
.acf3	ad 12 07	lda $0712			lda 	gxRadius
.acf6	8d 14 07	sta $0714			sta 	gYCentre
.acf9	0a		asl a				asl 	a 							; R x 2
.acfa	85 36		sta $36				sta 	gxzTemp0
.acfc	38		sec				sec
.acfd	a9 03		lda #$03			lda 	#3
.acff	e5 36		sbc $36				sbc 	gxzTemp0
.ad01	85 38		sta $38				sta 	gxzTemp1
.ad03	a9 00		lda #$00			lda 	#0
.ad05	e9 00		sbc #$00			sbc 	#0
.ad07	85 39		sta $39				sta 	gxzTemp1+1
.ad09	60		rts				rts
.ad0a					_GXCalculateCentre:
.ad0a	38		sec				sec
.ad0b	bd 7e 06	lda $067e,x			lda 	gxX1,x
.ad0e	7d 7a 06	adc $067a,x			adc 	gXX0,x
.ad11	9d 7e 06	sta $067e,x			sta 	gXX1,x
.ad14	bd 7f 06	lda $067f,x			lda 	gXX1+1,x
.ad17	7d 7b 06	adc $067b,x			adc 	gXX0+1,x
.ad1a	4a		lsr a				lsr 	a
.ad1b	9d 7f 06	sta $067f,x			sta 	gXX1+1,x
.ad1e	7e 7e 06	ror $067e,x			ror 	gXX1,x
.ad21	60		rts				rts
.0712					gxRadius:
>0712							.fill 	1
.0713					gXCentre:
>0713							.fill 	1
.0714					gYCentre:
>0714							.fill 	1
.0715					gxIsFillMode:
>0715							.fill 	1
.0716					gxYChanged:
>0716							.fill  	1
=64000					ScreenSize200 = 320 * 200
=76800					ScreenSize240 = 320 * 240
.ad22					GXClearBitmap:
.ad22	ad 83 06	lda $0683			lda 	gxBitmapsOn 				; check BMP running.
.ad25	f0 24		beq $ad4b			beq 	_GXCBFail
.ad27	20 11 b3	jsr $b311			jsr 	GXOpenBitmap 				; start access
.ad2a	a0 07		ldy #$07			ldy 	#ScreenSize200 / 8192 		; X is pages to clear
.ad2c	ad 86 06	lda $0686			lda 	gxHeight
.ad2f	c9 c8		cmp #$c8			cmp 	#200 						; 200 ?
.ad31	a0 09		ldy #$09			ldy 	#ScreenSize240 / 8192
.ad33					_GXCalcLastPage:
.ad33	98		tya				tya 								; add to base page
.ad34	18		clc				clc
.ad35	6d 84 06	adc $0684			adc 	gxBasePage
.ad38	85 0b		sta $0b				sta 	GXEditSlot  				; clear from this page back
.ad3a					_GXClearAll:
.ad3a	20 4d ad	jsr $ad4d			jsr 	_GXClearBlock 				; clear 8k block
.ad3d	c6 0b		dec $0b				dec 	GXEditSlot  				; back to previous
.ad3f	a5 0b		lda $0b				lda 	GXEditSlot
.ad41	cd 84 06	cmp $0684			cmp 	gxBasePage 					; until before base page
.ad44	b0 f4		bcs $ad3a			bcs 	_GXClearAll
.ad46	20 19 b3	jsr $b319			jsr 	GXCloseBitmap	 			; stop access
.ad49	18		clc				clc
.ad4a	60		rts				rts
.ad4b					_GXCBFail:
.ad4b	38		sec				sec
.ad4c	60		rts				rts
.ad4d					_GXClearBlock:
.ad4d	a9 00		lda #$00			lda 	#((GXMappingAddress) & $FF)
.ad4f	85 38		sta $38				sta 	0+gxzTemp1
.ad51	a9 60		lda #$60			lda 	#((GXMappingAddress) >> 8)
.ad53	85 39		sta $39				sta 	1+gxzTemp1
.ad55					_GXCB0:
.ad55	a5 36		lda $36				lda 	gxzTemp0
.ad57	a0 00		ldy #$00			ldy 	#0
.ad59					_GXCB1:
.ad59	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad5b	c8		iny				iny
.ad5c	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad5e	c8		iny				iny
.ad5f	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad61	c8		iny				iny
.ad62	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad64	c8		iny				iny
.ad65	d0 f2		bne $ad59			bne 	_GXCB1
.ad67	e6 39		inc $39				inc 	gxzTemp1+1
.ad69	a5 39		lda $39				lda 	gxzTemp1+1
.ad6b	c9 80		cmp #$80			cmp	 	#(GXMappingAddress >> 8)+$20
.ad6d	d0 e6		bne $ad55			bne 	_GXCB0
.ad6f	60		rts				rts
.ad70					GXInitialise:
.ad70	64 01		stz $01				stz 	1
.ad72	a9 01		lda #$01			lda 	#1
.ad74	8d 00 d0	sta $d000			sta 	$D000
.ad77	18		clc				clc
.ad78	9c 82 06	stz $0682			stz 	GXSpritesOn
.ad7b	9c 83 06	stz $0683			stz 	GXBitmapsOn
.ad7e	a2 0f		ldx #$0f			ldx 	#15
.ad80					_GXIClear:
.ad80	9e 72 06	stz $0672,x			stz 	gxCurrentX,x
.ad83	ca		dex				dex
.ad84	10 fa		bpl $ad80			bpl 	_GXIClear
.ad86	20 21 ae	jsr $ae21			jsr 	GXClearSpriteStore
.ad89	60		rts				rts
.ad8a					GXControlBitmap:
.ad8a	64 01		stz $01				stz 	1
.ad8c	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.ad8e	29 01		and #$01			and 	#1 							; set bitmap flag
.ad90	8d 83 06	sta $0683			sta 	gxBitmapsOn
.ad93	4a		lsr a				lsr 	a 							; bit 0 into carry.
.ad94	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.ad97	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.ad99	29 f7		and #$f7			and 	#$F7 						; clear bitmap bit
.ad9b	90 02		bcc $ad9f			bcc 	_CBNotOn
.ad9d	09 08		ora #$08			ora 	#$08 						; bitmap on if 1 on 0 off
.ad9f					_CBNotOn:
.ad9f	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.ada2	a5 36		lda $36				lda 	gxzTemp0 					; get control settings (bits 0-2)
.ada4	29 07		and #$07			and 	#7
.ada6	8d 00 d1	sta $d100			sta 	$D100 						; write in Vicky Bitmap Control Register #0
.ada9	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.adab	d0 02		bne $adaf			bne 	_CBNotDefault
.adad	a9 08		lda #$08			lda 	#8  						; if zero, use 8 e.g. bitmap at $10000
.adaf					_CBNotDefault:
.adaf	8d 84 06	sta $0684			sta 	gxBasePage
.adb2	20 13 ae	jsr $ae13			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.adb5	a5 37		lda $37				lda 	gxzTemp0+1 					; copy address into Bitmap address registers
.adb7	8d 03 d1	sta $d103			sta 	$D103
.adba	a5 36		lda $36				lda 	gxzTemp0
.adbc	8d 02 d1	sta $d102			sta 	$D102
.adbf	9c 01 d1	stz $d101			stz 	$D101
.adc2	a2 f0		ldx #$f0			ldx 	#240 						; height is 240
.adc4	ad 01 d0	lda $d001			lda 	$D001 						; read MCR bit 0
.adc7	29 01		and #$01			and 	#1
.adc9	f0 02		beq $adcd			beq 	_CBHaveHeight
.adcb	a2 c8		ldx #$c8			ldx 	#200 						; if bit 0 set 320x200
.adcd					_CBHaveHeight
.adcd	8e 86 06	stx $0686			stx 	gxHeight
.add0	18		clc				clc
.add1	60		rts				rts
.add2					GXControlSprite:
.add2	64 01		stz $01				stz 	1
.add4	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.add6	29 01		and #$01			and 	#1 							; set sprites flag
.add8	8d 82 06	sta $0682			sta 	gxSpritesOn
.addb	4a		lsr a				lsr 	a 							; bit 0 into carry.
.addc	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.addf	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.ade1	29 df		and #$df			and 	#$DF 						; clear sprite bit
.ade3	90 02		bcc $ade7			bcc 	_CSNotOn
.ade5	09 20		ora #$20			ora 	#$20 						; sprite on if 1 on 0 off
.ade7					_CSNotOn:
.ade7	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.adea	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.adec	d0 02		bne $adf0			bne 	_CSNotDefault
.adee	a9 18		lda #$18			lda 	#24  						; if zero, use 24 e.g. sprites at $30000
.adf0					_CSNotDefault:
.adf0	8d 85 06	sta $0685			sta 	gxSpritePage
.adf3	20 13 ae	jsr $ae13			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.adf6	a5 36		lda $36				lda 	zTemp0
.adf8	8d 90 06	sta $0690			sta 	GXSpriteOffsetBase
.adfb	a5 37		lda $37				lda 	zTemp0+1
.adfd	8d 91 06	sta $0691			sta 	GXSpriteOffsetBase+1
.ae00	a2 00		ldx #$00			ldx 	#0 							; disable all sprites, clears all sprite memory.
.ae02					_CSClear:
.ae02	9e 00 d9	stz $d900,x			stz 	$D900,x
.ae05	9e 00 da	stz $da00,x			stz 	$DA00,x
.ae08	ca		dex				dex
.ae09	d0 f7		bne $ae02			bne 	_CSClear
.ae0b	9c 8f 06	stz $068f			stz 	GSCurrentSpriteAddr+1 		; no sprite selected.
.ae0e	20 21 ae	jsr $ae21			jsr 	GXClearSpriteStore
.ae11	18		clc				clc
.ae12	60		rts				rts
.ae13					GXCalculateBaseAddress:
.ae13	85 36		sta $36				sta 	gxzTemp0
.ae15	64 37		stz $37				stz 	gxzTemp0+1
.ae17	a9 05		lda #$05			lda 	#5
.ae19					_GXShift:
.ae19	06 36		asl $36				asl 	gxzTemp0
.ae1b	26 37		rol $37				rol 	gxzTemp0+1
.ae1d	3a		dec a				dec		a
.ae1e	d0 f9		bne $ae19			bne 	_GXShift
.ae20	60		rts				rts
.ae21					GXClearSpriteStore:
.ae21	a2 3f		ldx #$3f			ldx 	#63 						; erase 64 sprite store elements
.ae23					_GXCSSLoop:
.ae23	9e d2 06	stz $06d2,x			stz 	GXSpriteHigh,x
.ae26	a9 80		lda #$80			lda 	#$80 						; set the 'hidden' bit.
.ae28	9d 92 06	sta $0692,x			sta 	GXSpriteLow,x
.ae2b	ca		dex				dex
.ae2c	10 f5		bpl $ae23			bpl 	_GXCSSLoop
.ae2e	60		rts				rts
.ae2f					GXLine:
.ae2f	ad 83 06	lda $0683			lda 	GXBitmapsOn
.ae32	f0 28		beq $ae5c			beq 	_GXLFail
.ae34	20 11 b3	jsr $b311			jsr 	GXOpenBitmap
.ae37	20 57 b4	jsr $b457			jsr 	GXSortY						; sort pairs so Y1 >= Y0 e.g. top to bottom.
.ae3a	20 02 af	jsr $af02			jsr 	GXLineSetup 				; the calculations in the linescanner constructor
.ae3d	20 21 b3	jsr $b321			jsr 	GXPositionCalc 				; calculate position/offset.
.ae40					_GXDrawLoop:
.ae40	ac 8c 06	ldy $068c			ldy 	gsOffset 					; draw the pixel
.ae43	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.ae45	2d 8a 06	and $068a			and 	gxANDValue
.ae48	4d 89 06	eor $0689			eor 	gxEORValue
.ae4b	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.ae4d	20 5e ae	jsr $ae5e			jsr 	GXLineIsComplete 			; is the line complete ?
.ae50	f0 05		beq $ae57			beq 	_GXLExit
.ae52	20 79 ae	jsr $ae79			jsr 	GXLineAdvance 				; code as per advance method
.ae55	80 e9		bra $ae40			bra 	_GXDrawLoop
.ae57					_GXLExit:
.ae57	20 19 b3	jsr $b319			jsr 	GXCloseBitmap
.ae5a	18		clc				clc
.ae5b	60		rts				rts
.ae5c					_GXLFail:
.ae5c	38		sec				sec
.ae5d	60		rts				rts
.ae5e					GXLineIsComplete:
.ae5e	ad 19 07	lda $0719			lda 	GXIsDiffYLarger 			; is dy larger
.ae61	d0 0f		bne $ae72			bne 	_GXLICCompareY 				; if so compare Y1/Y0
.ae63	ad 7a 06	lda $067a			lda 	GXX0 						; compare X, LSB and MSB
.ae66	4d 7e 06	eor $067e			eor 	GXX1
.ae69	d0 06		bne $ae71			bne 	_GXLICExit
.ae6b	ad 7b 06	lda $067b			lda 	GXX0+1
.ae6e	4d 7f 06	eor $067f			eor 	GXX1+1
.ae71					_GXLICExit:
.ae71	60		rts				rts
.ae72					_GXLICCompareY:
.ae72	ad 80 06	lda $0680			lda 	GXY1
.ae75	4d 7c 06	eor $067c			eor 	GXY0
.ae78	60		rts				rts
.ae79					GXLineAdvance:
.ae79	18		clc				clc 								; add adjust to position
.ae7a	ad 1b 07	lda $071b			lda 	GXPosition
.ae7d	6d 1c 07	adc $071c			adc 	GXAdjust
.ae80	8d 1b 07	sta $071b			sta 	GXPosition
.ae83	9c 1e 07	stz $071e			stz 	GXAddSelect 				; clear add select flag
.ae86	b0 05		bcs $ae8d			bcs 	_GXLAOverflow 				; if carry out, overflowed.
.ae88	cd 1d 07	cmp $071d			cmp 	GXTotal 					; if exceeded total
.ae8b	90 0a		bcc $ae97			bcc 	_GXLANoExtra
.ae8d					_GXLAOverflow:
.ae8d	ce 1e 07	dec $071e			dec 	GXAddSelect 				; set addselect to $FF
.ae90	38		sec				sec 								; subtract total and write back
.ae91	ed 1d 07	sbc $071d			sbc 	GXTotal
.ae94	8d 1b 07	sta $071b			sta 	GXPosition
.ae97					_GXLANoExtra:
.ae97	ad 19 07	lda $0719			lda 	GXIsDiffYLarger
.ae9a	f0 0d		beq $aea9			beq 	_GXDXLarger
.ae9c	20 fb ae	jsr $aefb			jsr 	GXIncrementY
.ae9f	ad 1e 07	lda $071e			lda 	GXAddSelect
.aea2	f0 10		beq $aeb4			beq 	_GXLAExit
.aea4	20 b5 ae	jsr $aeb5			jsr 	GXAdjustX
.aea7	80 0b		bra $aeb4			bra 	_GXLAExit
.aea9					_GXDXLarger:
.aea9	20 b5 ae	jsr $aeb5			jsr 	GXAdjustX
.aeac	ad 1e 07	lda $071e			lda 	GXAddSelect
.aeaf	f0 03		beq $aeb4			beq 	_GXLAExit
.aeb1	20 fb ae	jsr $aefb			jsr 	GXIncrementY
.aeb4					_GXLAExit:
.aeb4	60		rts				rts
.aeb5					GXAdjustX:
.aeb5	ad 1a 07	lda $071a			lda 	GXDXNegative
.aeb8	10 25		bpl $aedf			bpl 	_GXAXRight
.aeba	ad 7a 06	lda $067a			lda 	GXX0
.aebd	d0 03		bne $aec2			bne 	_GXAXNoBorrow
.aebf	ce 7b 06	dec $067b			dec 	GXX0+1
.aec2					_GXAXNoBorrow:
.aec2	ce 7a 06	dec $067a			dec 	GXX0
.aec5	ce 8c 06	dec $068c			dec 	gsOffset 					; pixel left
.aec8	ad 8c 06	lda $068c			lda 	gsOffset
.aecb	c9 ff		cmp #$ff			cmp 	#$FF
.aecd	d0 0f		bne $aede			bne 	_GXAYExit 					; underflow
.aecf	c6 3d		dec $3d				dec 	gxzScreen+1 					; borrow
.aed1	a5 3d		lda $3d				lda 	gxzScreen+1 					; gone off page
.aed3	c9 60		cmp #$60			cmp 	#GXMappingAddress >> 8
.aed5	b0 07		bcs $aede			bcs 	_GXAYExit
.aed7	18		clc				clc
.aed8	69 20		adc #$20			adc 	#$20 						; fix up
.aeda	85 3d		sta $3d				sta 	gxzScreen+1
.aedc	c6 0b		dec $0b				dec 	GXEditSlot 				; back one page
.aede					_GXAYExit:
.aede	60		rts				rts
.aedf					_GXAXRight:
.aedf	ee 7a 06	inc $067a			inc 	GXX0
.aee2	d0 03		bne $aee7			bne 	_GXAXNoCarry
.aee4	ee 7b 06	inc $067b			inc 	GXX0+1
.aee7					_GXAXNoCarry:
.aee7	ee 8c 06	inc $068c			inc 	gsOffset 					; pixel right
.aeea	d0 0e		bne $aefa			bne 	_GXAXExit 					; if not overflowed, exit.
.aeec	e6 3d		inc $3d				inc 	gxzScreen+1 					; next line
.aeee	a5 3d		lda $3d				lda 	gxzScreen+1
.aef0	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.aef2	90 06		bcc $aefa			bcc 	_GXAXExit
.aef4	e9 20		sbc #$20			sbc 	#$20 						; fix up
.aef6	85 3d		sta $3d				sta 	gxzScreen+1
.aef8	e6 0b		inc $0b				inc 	GXEditSlot 				; next page
.aefa					_GXAXExit:
.aefa	60		rts				rts
.aefb					GXIncrementY:
.aefb	ee 7c 06	inc $067c			inc 	GXY0
.aefe	20 77 b3	jsr $b377			jsr 	GXMovePositionDown
.af01	60		rts				rts
.af02					GXLineSetup:
.af02	ad 80 06	lda $0680			lda 	GXY1
.af05	38		sec				sec
.af06	ed 7c 06	sbc $067c			sbc 	GXY0
.af09	4a		lsr a				lsr 	a
.af0a	8d 18 07	sta $0718			sta 	GXDiffY
.af0d	9c 1a 07	stz $071a			stz 	GXDXNegative 				; clear -ve flag
.af10	38		sec				sec
.af11	ad 7e 06	lda $067e			lda 	GXX1
.af14	ed 7a 06	sbc $067a			sbc 	GXX0
.af17	8d 17 07	sta $0717			sta 	GXDiffX
.af1a	ad 7f 06	lda $067f			lda 	GXX1+1 						; calculate MSB
.af1d	ed 7b 06	sbc $067b			sbc 	GXX0+1
.af20	6a		ror a				ror 	a 							; rotate bit into DiffX halving it
.af21	6e 17 07	ror $0717			ror 	GXDiffX
.af24	0a		asl a				asl 	a
.af25	10 0c		bpl $af33			bpl 	_GDXNotNegative
.af27	a9 00		lda #$00			lda 	#0 							; make absolute value of |dx|
.af29	38		sec				sec
.af2a	ed 17 07	sbc $0717			sbc 	GXDiffX
.af2d	8d 17 07	sta $0717			sta 	GXDiffX
.af30	ce 1a 07	dec $071a			dec 	GXDXNegative 				; -ve flag = $FF.
.af33					_GDXNotNegative:
.af33	9c 19 07	stz $0719			stz 	GXIsDiffYLarger 			; clear larger flag
.af36	ad 18 07	lda $0718			lda 	GXDiffY 					; set adjust and total.
.af39	8d 1c 07	sta $071c			sta 	GXAdjust
.af3c	ad 17 07	lda $0717			lda 	GXDiffX
.af3f	8d 1d 07	sta $071d			sta 	GXTotal
.af42	ad 18 07	lda $0718			lda 	GXDiffY 					; if dy > dx
.af45	cd 17 07	cmp $0717			cmp 	GXDiffX
.af48	90 0f		bcc $af59			bcc 	_GDXNotLarger
.af4a	ce 19 07	dec $0719			dec 	GXIsDiffYLarger 			; set the dy larger flag
.af4d	ad 17 07	lda $0717			lda 	GXDiffX 					; set adjust and total other way round
.af50	8d 1c 07	sta $071c			sta 	GXAdjust
.af53	ad 18 07	lda $0718			lda 	GXDiffY
.af56	8d 1d 07	sta $071d			sta 	GXTotal
.af59					_GDXNotLarger:
.af59	ad 1d 07	lda $071d			lda 	GXTotal
.af5c	4a		lsr a				lsr 	a
.af5d	8d 1b 07	sta $071b			sta 	GXPosition
.af60	60		rts				rts
.0717					GXDiffX:
>0717							.fill 	1
.0718					GXDiffY:
>0718							.fill 	1
.0719					GXIsDiffYLarger:
>0719							.fill 	1
.071a					GXDXNegative:
>071a							.fill 	1
.071b					GXPosition:
>071b							.fill 	1
.071c					GXAdjust:
>071c							.fill 	1
.071d					GXTotal:
>071d							.fill 	1
.071e					GXAddSelect:
>071e							.fill 	1
.af61					GXSetColourMode:
.af61	a6 36		ldx $36				ldx 	gxzTemp0
.af63	8e 88 06	stx $0688			stx 	gxColour 								; set colour
.af66	a5 37		lda $37				lda 	gxzTemp0+1 								;
.af68	8d 87 06	sta $0687			sta 	gxMode 									; set mode
.af6b	29 03		and #$03			and 	#3 										; only interested in bits 0-3
.af6d	9c 8a 06	stz $068a			stz 	gxANDValue 								; initially AND with 0, and EOR with Colour
.af70	ae 88 06	ldx $0688			ldx 	gxColour
.af73	8e 89 06	stx $0689			stx 	gxEORValue
.af76	c9 02		cmp #$02			cmp 	#2 										; if mode 2/3 And with colour
.af78	90 03		bcc $af7d			bcc 	_GXSDCNotAndColour
.af7a	8e 8a 06	stx $068a			stx 	gxANDValue
.af7d					_GXSDCNotAndColour:
.af7d	d0 03		bne $af82			bne 	_GXSDCNotAnd 							; mode 2, Don't EOR with colour
.af7f	9c 89 06	stz $0689			stz 	gxEORValue
.af82					_GXSDCNotAnd:
.af82	4a		lsr a				lsr 	a 										; if bit 0 set, 1's complement AND value
.af83	90 08		bcc $af8d			bcc 	_GXSDCNoFlip
.af85	ad 8a 06	lda $068a			lda	 	gxANDValue
.af88	49 ff		eor #$ff			eor 	#$FF
.af8a	8d 8a 06	sta $068a			sta 	gxANDValue
.af8d					_GXSDCNoFlip:
.af8d	18		clc				clc
.af8e	60		rts				rts
.af8f					GXPlotPoint:
.af8f	20 11 b3	jsr $b311			jsr 	GXOpenBitmap 				; start drawing
.af92	20 21 b3	jsr $b321			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.af95	ac 8c 06	ldy $068c			ldy 	gsOffset
.af98	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.af9a	2d 8a 06	and $068a			and 	gxANDValue
.af9d	4d 89 06	eor $0689			eor 	gxEORValue
.afa0	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.afa2	20 19 b3	jsr $b319			jsr 	GXCloseBitmap 				; stop drawing and exit
.afa5	18		clc				clc
.afa6	60		rts				rts
.afa7					GXFillRectangle:
.afa7	38		sec				sec
.afa8	80 01		bra $afab			bra 	GXRectangle
.afaa					GXFrameRectangle:
.afaa	18		clc				clc
.afab					GXRectangle:
.afab	ad 83 06	lda $0683			lda 	gxBitmapsOn
.afae	f0 35		beq $afe5			beq 	_GXRFail
.afb0	08		php				php 								; save Fill flag (CS)
.afb1	20 11 b3	jsr $b311			jsr 	GXOpenBitmap 				; start drawing
.afb4	20 39 b4	jsr $b439			jsr 	GXSortXY 					; sort both X and Y so top left/bottom right
.afb7	20 21 b3	jsr $b321			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.afba	38		sec				sec 								; sec = Draw line
.afbb	20 e7 af	jsr $afe7			jsr 	GXDrawLineX1X0 				; draw a line length X1-X0
.afbe	ad 7c 06	lda $067c			lda 	gxY0 						; reached end of rectangle ?
.afc1	cd 80 06	cmp $0680			cmp 	gxY1
.afc4	f0 19		beq $afdf			beq 	_GXRectangleExit
.afc6					_GXRectLoop:
.afc6	20 77 b3	jsr $b377			jsr 	GXMovePositionDown 			; down one.
.afc9	ee 7c 06	inc $067c			inc 	gxY0 						; change Y pos
.afcc	ad 7c 06	lda $067c			lda 	gxY0 						; reached last line
.afcf	cd 80 06	cmp $0680			cmp 	gXY1
.afd2	f0 07		beq $afdb			beq 	_GXLastLine
.afd4	28		plp				plp 								; get flag back
.afd5	08		php				php
.afd6	20 e7 af	jsr $afe7			jsr 	GXDrawLineX1X0 				; draw horizontal line
.afd9	80 eb		bra $afc6			bra 	_GXRectLoop
.afdb					_GXLastLine:
.afdb	38		sec				sec
.afdc	20 e7 af	jsr $afe7			jsr 	GXDrawLineX1X0
.afdf					_GXRectangleExit:
.afdf	68		pla				pla 								; throw fill flag.
.afe0	20 19 b3	jsr $b319			jsr 	GXCloseBitmap 				; stop drawing and exit
.afe3	18		clc				clc
.afe4	60		rts				rts
.afe5					_GXRFail:
.afe5	38		sec				sec
.afe6	60		rts				rts
.afe7					GXDrawLineX1X0:
.afe7	08		php				php 								; save solid/either-end
.afe8	38		sec				sec
.afe9	ad 7e 06	lda $067e			lda		gXX1
.afec	ed 7a 06	sbc $067a			sbc 	gXX0
.afef	85 36		sta $36				sta 	gxzTemp0
.aff1	ad 7f 06	lda $067f			lda 	gXX1+1
.aff4	ed 7b 06	sbc $067b			sbc 	gXX0+1
.aff7	85 37		sta $37				sta 	gxzTemp0+1
.aff9	28		plp				plp
.affa					GXDrawLineTemp0:
.affa	a5 3c		lda $3c				lda 	gxzScreen 						; push gxzScreen, gsOffset and GXEditSlot on stack
.affc	48		pha				pha
.affd	a5 3d		lda $3d				lda 	gxzScreen+1
.afff	48		pha				pha
.b000	ad 8c 06	lda $068c			lda 	gsOffset
.b003	48		pha				pha
.b004	a5 0b		lda $0b				lda 	GXEditSlot
.b006	48		pha				pha
.b007	ac 8c 06	ldy $068c			ldy 	gsOffset 					; Y offset
.b00a	90 1e		bcc $b02a			bcc 	_GXDLTEndPoints 			; if CC draw end points only.
.b00c					_GXDLTLine:
.b00c	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.b00e	2d 8a 06	and $068a			and 	gxANDValue
.b011	4d 89 06	eor $0689			eor 	gxEORValue
.b014	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b016	a5 36		lda $36				lda 	gxzTemp0 					; decrement counter
.b018	d0 04		bne $b01e			bne 	_GXDLTNoBorrow
.b01a	c6 37		dec $37				dec 	gxzTemp0+1 					; borrow, if goes -ve then exit
.b01c	30 2e		bmi $b04c			bmi 	_GXDLTExit
.b01e					_GXDLTNoBorrow:
.b01e	c6 36		dec $36				dec 	gxzTemp0
.b020	c8		iny				iny 								; next slot.
.b021	d0 e9		bne $b00c			bne 	_GXDLTLine
.b023	e6 3d		inc $3d				inc 	gxzScreen+1 					; carry to next
.b025	20 5a b0	jsr $b05a			jsr 	GXDLTCheckWrap				; check for new page.
.b028	80 e2		bra $b00c			bra 	_GXDLTLine
.b02a					_GXDLTEndPoints:
.b02a	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.b02c	2d 8a 06	and $068a			and 	gxANDValue
.b02f	4d 89 06	eor $0689			eor 	gxEORValue
.b032	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b034	98		tya				tya 								; advance to right side
.b035	18		clc				clc
.b036	65 36		adc $36				adc 	gxzTemp0
.b038	a8		tay				tay
.b039	a5 3d		lda $3d				lda 	gxzScreen+1
.b03b	65 37		adc $37				adc 	gxzTemp0+1
.b03d	85 3d		sta $3d				sta 	gxzScreen+1
.b03f	20 5a b0	jsr $b05a			jsr 	GXDLTCheckWrap 			; fix up.
.b042	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.b044	2d 8a 06	and $068a			and 	gxANDValue
.b047	4d 89 06	eor $0689			eor 	gxEORValue
.b04a	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b04c					_GXDLTExit:
.b04c	68		pla				pla
.b04d	85 0b		sta $0b				sta 	GXEditSlot
.b04f	68		pla				pla
.b050	8d 8c 06	sta $068c			sta 	gsOffset
.b053	68		pla				pla
.b054	85 3d		sta $3d				sta 	gxzScreen+1
.b056	68		pla				pla
.b057	85 3c		sta $3c				sta 	gxzScreen
.b059	60		rts				rts
.b05a					GXDLTCheckWrap:
.b05a	a5 3d		lda $3d				lda 	gxzScreen+1 					; check end of page
.b05c	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8)
.b05e	90 06		bcc $b066			bcc 	_GXDLTCWExit
.b060	e9 20		sbc #$20			sbc 	#$20 						; fix up
.b062	85 3d		sta $3d				sta 	gxzScreen+1
.b064	e6 0b		inc $0b				inc 	GXEditSlot
.b066					_GXDLTCWExit:
.b066	60		rts				rts
.b067					GXDrawGraphicElement:
.b067	8d 1f 07	sta $071f			sta 	gxSize 						; save size
.b06a	3a		dec a				dec 	a
.b06b	8d 20 07	sta $0720			sta 	gxMask 						; and mask
.b06e	ad 83 06	lda $0683			lda 	gxBitmapsOn 				; check BMP on
.b071	f0 67		beq $b0da			beq 	_GXSLFail
.b073	ad 7c 06	lda $067c			lda 	gxY0 						; push Y on stack
.b076	48		pha				pha
.b077	8c 22 07	sty $0722			sty 	gxAcquireVector+1 			; and acquisition vector
.b07a	8e 21 07	stx $0721			stx 	gxAcquireVector
.b07d	20 11 b3	jsr $b311			jsr 	gxOpenBitmap 				; open the bitmap.
.b080	ad 24 07	lda $0724			lda 	gxUseMode 					; scale bits
.b083	4a		lsr a				lsr 	a
.b084	4a		lsr a				lsr 	a
.b085	4a		lsr a				lsr 	a
.b086	29 07		and #$07			and		#7
.b088	1a		inc a				inc 	a
.b089	8d 23 07	sta $0723			sta 	gxScale
.b08c	64 38		stz $38				stz 	gxzTemp1					; start first line
.b08e					_GXGELoop:
.b08e	a5 38		lda $38				lda 	gxzTemp1 					; current line number to read.
.b090	2c 24 07	bit $0724			bit 	gxUseMode 					; check for flip.
.b093	10 06		bpl $b09b			bpl		_GXNoVFlip
.b095	ad 20 07	lda $0720			lda 	gxMask
.b098	38		sec				sec
.b099	e5 38		sbc $38				sbc 	gxzTemp1
.b09b					_GXNoVFlip:
.b09b	aa		tax				tax 								; get the Xth line.
.b09c	20 dc b0	jsr $b0dc			jsr 	_GXCallAcquire 				; get that data.
.b09f	ad 23 07	lda $0723			lda 	gxScale 					; do scale identical copies of that line.
.b0a2	85 39		sta $39				sta 	gxzTemp1+1
.b0a4					_GXGELoop2:
.b0a4	ad 7c 06	lda $067c			lda 	gxY0 						; off screen
.b0a7	cd 86 06	cmp $0686			cmp 	gxHeight
.b0aa	b0 10		bcs $b0bc			bcs 	_GXDGEExit
.b0ac	20 df b0	jsr $b0df			jsr 	GXRenderOneLine 			; render line
.b0af	c6 39		dec $39				dec 	gxzTemp1+1 					; scale times.
.b0b1	d0 f1		bne $b0a4			bne 	_GXGELoop2
.b0b3	e6 38		inc $38				inc 	gxzTemp1 					; done all lines.
.b0b5	a5 38		lda $38				lda 	gxzTemp1
.b0b7	cd 1f 07	cmp $071f			cmp 	gxSize
.b0ba	d0 d2		bne $b08e			bne 	_GXGELoop
.b0bc					_GXDGEExit:
.b0bc	68		pla				pla 								; restore Y for next time
.b0bd	8d 7c 06	sta $067c			sta 	gxY0
.b0c0	ae 23 07	ldx $0723			ldx 	gxScale 					; get scale (1-8)
.b0c3					_GXShiftLeft:
.b0c3	18		clc				clc
.b0c4	ad 1f 07	lda $071f			lda 	gxSize
.b0c7	6d 7a 06	adc $067a			adc 	gxX0
.b0ca	8d 7a 06	sta $067a			sta 	gxX0
.b0cd	90 03		bcc $b0d2			bcc 	_GXSLNoCarry
.b0cf	ee 7b 06	inc $067b			inc 	gxX0+1
.b0d2					_GXSLNoCarry:
.b0d2	ca		dex				dex
.b0d3	d0 ee		bne $b0c3			bne 	_GXShiftLeft
.b0d5	20 19 b3	jsr $b319			jsr 	GXCloseBitmap
.b0d8	18		clc				clc
.b0d9	60		rts				rts
.b0da					_GXSLFail:
.b0da	38		sec				sec
.b0db	60		rts				rts
.b0dc					_GXCallAcquire:
.b0dc	6c 21 07	jmp ($0721)			jmp 	(gxAcquireVector)
.b0df					GXRenderOneLine:
.b0df	20 21 b3	jsr $b321			jsr 	GXPositionCalc 				; calculate position/offset.
.b0e2	ac 8c 06	ldy $068c			ldy 	gsOffset 					; Y contains position.
.b0e5	64 3a		stz $3a				stz 	gxzTemp2 					; do size pixels
.b0e7					_GXROLLoop1:
.b0e7	ad 23 07	lda $0723			lda 	gxScale 					; set to do 'scale' times
.b0ea	85 3b		sta $3b				sta 	gxzTemp2+1
.b0ec					_GXROLLoop2:
.b0ec	a5 3a		lda $3a				lda 	gxzTemp2 					; get current pixel
.b0ee	2c 87 06	bit $0687			bit 	gxMode 						; check H Flip
.b0f1	50 06		bvc $b0f9			bvc 	_GXNoHFlip
.b0f3	ad 20 07	lda $0720			lda 	gxMask
.b0f6	38		sec				sec
.b0f7	e5 3a		sbc $3a				sbc 	gxzTemp2
.b0f9					_GXNoHFlip:
.b0f9	aa		tax				tax 								; read from the pixel buffer
.b0fa	bd 27 06	lda $0627,x			lda 	gxPixelBuffer,x
.b0fd	d0 07		bne $b106			bne 	_GXDraw 					; draw if non zero
.b0ff	ad 24 07	lda $0724			lda 	gxUseMode 					; check to see if solid background
.b102	29 04		and #$04			and 	#4
.b104	f0 0a		beq $b110			beq 	_GXZeroPixel
.b106					_GXDraw:
.b106	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.b108	2d 8a 06	and $068a			and 	gxANDValue
.b10b	5d 27 06	eor $0627,x			eor 	gxPixelBuffer,x
.b10e	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b110					_GXZeroPixel:
.b110	c8		iny				iny 								; advance pointer
.b111	d0 05		bne $b118			bne 	_GXNoShift
.b113	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.b115	20 5a b0	jsr $b05a			jsr 	GXDLTCheckWrap				; check for new page.
.b118					_GXNoShift:
.b118	c6 3b		dec $3b				dec 	gxzTemp2+1 					; do the inner loop gxScale times.
.b11a	d0 d0		bne $b0ec			bne 	_GXROLLoop2
.b11c	e6 3a		inc $3a				inc 	gxzTemp2 					; next pixel.
.b11e	a5 3a		lda $3a				lda 	gxzTemp2
.b120	cd 1f 07	cmp $071f			cmp 	gxSize
.b123	d0 c2		bne $b0e7			bne 	_GXROLLoop1
.b125	ee 7c 06	inc $067c			inc 	gxY0
.b128	60		rts				rts
.071f					gxSize:
>071f							.fill 	1
.0720					gxMask:
>0720							.fill 	1
.0721					gxAcquireVector:
>0721							.fill 	2
.0723					gxScale:
>0723							.fill 	1
.0724					gxUseMode:
>0724							.fill 	1
.b129					GXFontHandler:
.b129	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b12b	4d 87 06	eor $0687			eor 	gxMode
.b12e	8d 24 07	sta $0724			sta 	gxUseMode
.b131	64 37		stz $37				stz 	gxzTemp0+1 					; gxzTemp0 is font #
.b133	06 36		asl $36				asl	 	gxzTemp0 					; x 2
.b135	26 37		rol $37				rol	 	gxzTemp0+1
.b137	06 36		asl $36				asl	 	gxzTemp0 					; x 4
.b139	26 37		rol $37				rol	 	gxzTemp0+1
.b13b	06 36		asl $36				asl	 	gxzTemp0 					; x 8
.b13d	26 37		rol $37				rol	 	gxzTemp0+1
.b13f	a5 37		lda $37				lda 	gxzTemp0+1 					; put in page C0
.b141	09 c0		ora #$c0			ora 	#$C0
.b143	85 37		sta $37				sta 	gxzTemp0+1
.b145	a9 08		lda #$08			lda 	#8 							; size 8x8
.b147	a2 4f		ldx #$4f			ldx 	#GXGetGraphicDataFont & $FF ; XY = Graphic Data retrieval routine
.b149	a0 b1		ldy #$b1			ldy 	#GXGetGraphicDataFont >> 8
.b14b	20 67 b0	jsr $b067			jsr 	GXDrawGraphicElement
.b14e	60		rts				rts
.b14f					GXGetGraphicDataFont:
.b14f	8a		txa				txa 								; X->Y
.b150	a8		tay				tay
.b151	a6 01		ldx $01				ldx 	1 							; preserve old value
.b153	a9 01		lda #$01			lda 	#1 							; access page 1 (font memory)
.b155	85 01		sta $01				sta 	1
.b157	b1 36		lda ($36),y			lda 	(gxzTemp0),y 				; read the font element.
.b159	86 01		stx $01				stx 	1 							; put old value back.
.b15b	a2 00		ldx #$00			ldx 	#0 							; do 8 times
.b15d					_GXExpand:
.b15d	9e 27 06	stz $0627,x			stz 	gxPixelBuffer,x 			; zero in pixel buffer
.b160	0a		asl a				asl 	a 							; shift bit 7 into C
.b161	90 08		bcc $b16b			bcc 	_GXNoPixel
.b163	48		pha				pha 								; if set, set pixel buffer to current colour.
.b164	ad 88 06	lda $0688			lda 	gxColour
.b167	9d 27 06	sta $0627,x			sta 	gxPixelBuffer,x
.b16a	68		pla				pla
.b16b					_GXNoPixel:
.b16b	e8		inx				inx 								; do the whole byte.
.b16c	e0 08		cpx #$08			cpx 	#8
.b16e	d0 ed		bne $b15d			bne 	_GXExpand
.b170	60		rts				rts
.b171					GXSpriteHandler:
.b171	ad 82 06	lda $0682			lda 	gxSpritesOn 				; sprites on ?
.b174	f0 23		beq $b199			beq 	_GXSHExit
.b176	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b178	4d 87 06	eor $0687			eor 	gxMode
.b17b	8d 24 07	sta $0724			sta 	gxUseMode
.b17e	a6 36		ldx $36				ldx 	gxzTemp0 					; sprite #
.b180	da		phx				phx
.b181	20 11 b3	jsr $b311			jsr 	GXOpenBitmap 				; can access sprite information
.b184	68		pla				pla
.b185	20 f2 b3	jsr $b3f2			jsr 	GXFindSprite 				; get the sprite address
.b188	08		php				php
.b189	20 19 b3	jsr $b319			jsr 	GXCloseBitmap
.b18c	28		plp				plp
.b18d	b0 0a		bcs $b199			bcs		_GXSHExit 					; exit if find failed.
.b18f	ad 25 07	lda $0725			lda 	GXSizePixels 				; return size
.b192	a2 9a		ldx #$9a			ldx 	#GXSpriteAcquire & $FF
.b194	a0 b1		ldy #$b1			ldy 	#GXSpriteAcquire >> 8
.b196	20 67 b0	jsr $b067			jsr 	GXDrawGraphicElement
.b199					_GXSHExit:
.b199	60		rts				rts
.b19a					GXSpriteAcquire:
.b19a	ad 85 06	lda $0685			lda 	GXSpritePage				; point to base page
.b19d	85 0b		sta $0b				sta 	GXEditSlot
.b19f	86 36		stx $36				stx 	zTemp0 						; row number x 1,2,3,4
.b1a1	a9 00		lda #$00			lda 	#0
.b1a3	ae 26 07	ldx $0726			ldx 	GXSizeBits
.b1a6					_GXTimesRowNumber:
.b1a6	18		clc				clc
.b1a7	65 36		adc $36				adc 	zTemp0
.b1a9	ca		dex				dex
.b1aa	10 fa		bpl $b1a6			bpl 	_GXTimesRowNumber
.b1ac	64 37		stz $37				stz 	gxzTemp0+1
.b1ae	0a		asl a				asl 	a 							; row x 2,4,6,8
.b1af	26 37		rol $37				rol 	gxzTemp0+1
.b1b1	0a		asl a				asl 	a 							; row x 4,8,12,16
.b1b2	26 37		rol $37				rol 	gxzTemp0+1
.b1b4	0a		asl a				asl 	a 							; row x 8,16,24,32
.b1b5	26 37		rol $37				rol 	gxzTemp0+1
.b1b7	85 36		sta $36				sta 	gxzTemp0
.b1b9	18		clc				clc 								; add base address.
.b1ba	a5 36		lda $36				lda 	gxzTemp0
.b1bc	6d 28 07	adc $0728			adc 	GXSpriteOffset
.b1bf	85 36		sta $36				sta 	gxzTemp0
.b1c1	a5 37		lda $37				lda 	gxzTemp0+1
.b1c3	6d 29 07	adc $0729			adc 	GXSpriteOffset+1
.b1c6					_GXSAFindPage:
.b1c6	c9 20		cmp #$20			cmp 	#$20 						; on this page
.b1c8	90 06		bcc $b1d0			bcc 	_GXSAFoundPage
.b1ca	e9 20		sbc #$20			sbc 	#$20 						; forward one page
.b1cc	e6 0b		inc $0b				inc 	GXEditSlot
.b1ce	80 f6		bra $b1c6			bra 	_GXSAFindPage
.b1d0					_GXSAFoundPage:
.b1d0	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; physical address of page.
.b1d2	85 37		sta $37				sta 	gxzTemp0+1 					; gxzTemp0 now points to the page
.b1d4	a0 00		ldy #$00			ldy 	#0
.b1d6					_GXSACopyLoop:
.b1d6	b1 36		lda ($36),y			lda 	(gxzTemp0),y
.b1d8	99 27 06	sta $0627,y			sta 	gxPixelBuffer,y
.b1db	c8		iny				iny
.b1dc	cc 25 07	cpy $0725			cpy 	GXSizePixels
.b1df	d0 f5		bne $b1d6			bne 	_GXSACopyLoop
.b1e1	60		rts				rts
.b1e2					GXSelect:
.b1e2	ad 82 06	lda $0682			lda 	gxSpritesOn
.b1e5	f0 22		beq $b209			beq 	_GXSFail
.b1e7	a5 36		lda $36				lda 	gxzTemp0 					; illegal sprite #
.b1e9	c9 40		cmp #$40			cmp 	#64
.b1eb	b0 1c		bcs $b209			bcs 	_GXSFail
.b1ed	8d 8d 06	sta $068d			sta 	GSCurrentSpriteID
.b1f0	a4 37		ldy $37				ldy 	gxzTemp0+1 					; control value.
.b1f2	a9 00		lda #$00			lda  	#0 							; multiply sprite # x 8 => A
.b1f4	06 36		asl $36				asl 	gxzTemp0
.b1f6	06 36		asl $36				asl 	gxzTemp0
.b1f8	06 36		asl $36				asl 	gxzTemp0
.b1fa	2a		rol a				rol 	a
.b1fb	69 d9		adc #$d9			adc 	#$D9 						; sprite area
.b1fd	8d 8f 06	sta $068f			sta 	GSCurrentSpriteAddr+1 		; address to GSCurrentSprite and gxzTemp
.b200	85 37		sta $37				sta 	gxzTemp0+1
.b202	a5 36		lda $36				lda 	gxzTemp0
.b204	8d 8e 06	sta $068e			sta 	GSCurrentSpriteAddr
.b207	18		clc				clc
.b208	60		rts				rts
.b209					_GXSFail:
.b209	38		sec				sec
.b20a	60		rts				rts
.b20b					GXSelectImage:
.b20b	ad 82 06	lda $0682			lda 	gxSpritesOn
.b20e	f0 74		beq $b284			beq 	_GXSIFail
.b210	ad 8f 06	lda $068f			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b213	f0 6f		beq $b284			beq 	_GXSIFail 					; (checking the MSB)
.b215	64 01		stz $01				stz 	1
.b217	a5 37		lda $37				lda 	gxzTemp0+1 					; push show/hide on the stack.
.b219	d0 6b		bne $b286			bne 	_GXSIHide
.b21b	a5 36		lda $36				lda 	gxzTemp0 					; sprite image
.b21d	48		pha				pha
.b21e	20 11 b3	jsr $b311			jsr 	GXOpenBitmap
.b221	68		pla				pla
.b222	20 f2 b3	jsr $b3f2			jsr 	GXFindSprite
.b225	b0 5a		bcs $b281			bcs 	_GXSICloseFail 				; no image
.b227	a0 01		ldy #$01			ldy 	#1
.b229	ad 8e 06	lda $068e			lda 	GSCurrentSpriteAddr
.b22c	85 36		sta $36				sta 	gxzTemp0
.b22e	ad 8f 06	lda $068f			lda 	GSCurrentSpriteAddr+1
.b231	85 37		sta $37				sta 	gxzTemp0+1
.b233	ad 28 07	lda $0728			lda 	GXSpriteOffset
.b236	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b238	18		clc				clc
.b239	ad 29 07	lda $0729			lda 	GXSpriteOffset+1
.b23c	6d 90 06	adc $0690			adc 	GXSpriteOffsetBase
.b23f	c8		iny				iny
.b240	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b242	ad 91 06	lda $0691			lda 	GXSpriteOffsetBase+1
.b245	69 00		adc #$00			adc 	#0
.b247	c8		iny				iny
.b248	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b24a	ad 26 07	lda $0726			lda 	GXSizeBits 					; get raw size
.b24d	49 03		eor #$03			eor 	#3 							; make it right (00=32 etc.)
.b24f	2a		rol a				rol 	a 							; x 2
.b250	0a		asl a				asl 	a 							; x 4
.b251	0a		asl a				asl 	a 							; x 8
.b252	0a		asl a				asl 	a 							; x 16
.b253	0d 27 07	ora $0727			ora 	GXSpriteLUT 				; Or with LUT
.b256	0a		asl a				asl 	a 							; 1 shift
.b257	09 01		ora #$01			ora 	#1 							; enable sprite.
.b259	92 36		sta ($36)			sta 	(gxzTemp0) 					; and write back
.b25b	20 19 b3	jsr $b319			jsr 	GXCloseBitmap
.b25e	ae 8d 06	ldx $068d			ldx 	GSCurrentSpriteID 			; point to sprite entries.
.b261	bd d2 06	lda $06d2,x			lda 	GXSpriteHigh,x 				; clear upper two bits of size
.b264	29 3f		and #$3f			and 	#$3F
.b266	9d d2 06	sta $06d2,x			sta 	GXSpriteHigh,x
.b269	ad 26 07	lda $0726			lda 	GXSizeBits 					; get bit size
.b26c	6a		ror a				ror 	a 							; shift into bits 6/7
.b26d	6a		ror a				ror 	a
.b26e	6a		ror a				ror 	a
.b26f	29 c0		and #$c0			and 	#$C0
.b271	1d d2 06	ora $06d2,x			ora 	GXSpriteHigh,x 				; put in  upper 2 bits of sprite data
.b274	9d d2 06	sta $06d2,x			sta 	GXSpriteHigh,x
.b277	bd 92 06	lda $0692,x			lda 	GXSpriteLow,x 				; clear hidden flag.
.b27a	29 7f		and #$7f			and 	#$7F
.b27c	9d 92 06	sta $0692,x			sta 	GXSpriteLow,x
.b27f	18		clc				clc
.b280	60		rts				rts
.b281					_GXSICloseFail:
.b281	20 19 b3	jsr $b319			jsr 	GXCloseBitmap
.b284					_GXSIFail:
.b284	38		sec				sec
.b285	60		rts				rts
.b286					_GXSIHide:
.b286	ad 8e 06	lda $068e			lda 	GSCurrentSpriteAddr  		; get Sprite h/w address and write there
.b289	85 36		sta $36				sta 	gxzTemp0
.b28b	ad 8f 06	lda $068f			lda 	GSCurrentSpriteAddr+1
.b28e	85 37		sta $37				sta 	gxzTemp0+1
.b290	a9 00		lda #$00			lda 	#0
.b292	92 36		sta ($36)			sta 	(gxzTemp0)
.b294	ae 8d 06	ldx $068d			ldx 	GSCurrentSpriteID 			; get sprite ID
.b297	bd 92 06	lda $0692,x			lda 	GXSpriteLow,x 				; set the hidden bit.
.b29a	09 80		ora #$80			ora 	#$80
.b29c	9d 92 06	sta $0692,x			sta 	GXSpriteLow,x
.b29f	18		clc				clc
.b2a0	60		rts				rts
.b2a1					GXMoveSprite:
.b2a1	ad 82 06	lda $0682			lda 	gxSpritesOn
.b2a4	f0 65		beq $b30b			beq 	_GXSIFail
.b2a6	ad 8f 06	lda $068f			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b2a9	f0 60		beq $b30b			beq 	_GXSIFail
.b2ab	85 37		sta $37				sta 	gxzTemp0+1
.b2ad	a0 04		ldy #$04			ldy 	#4
.b2af	ad 8e 06	lda $068e			lda 	GSCurrentSpriteAddr
.b2b2	85 36		sta $36				sta 	gxzTemp0
.b2b4	ae 8d 06	ldx $068d			ldx 	GSCurrentSpriteID 			; get the size from the upper two bits
.b2b7	bd d2 06	lda $06d2,x			lda 	GXSpriteHigh,x
.b2ba	2a		rol a				rol 	a	 						; into bits 0,1.
.b2bb	2a		rol a				rol 	a
.b2bc	2a		rol a				rol 	a
.b2bd	29 03		and #$03			and 	#3
.b2bf	aa		tax				tax
.b2c0	bd 0d b3	lda $b30d,x			lda 	_GXMSOffset,x 				; get 32-SpriteSize/2
.b2c3	48		pha				pha
.b2c4	18		clc				clc
.b2c5	6d 7a 06	adc $067a			adc 	gxX0						; copy position.
.b2c8	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2ca	c8		iny				iny
.b2cb	ad 7b 06	lda $067b			lda 	gxX0+1
.b2ce	69 00		adc #$00			adc 	#0
.b2d0	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2d2	c8		iny				iny
.b2d3	68		pla				pla
.b2d4	18		clc				clc
.b2d5	6d 7c 06	adc $067c			adc 	gxY0
.b2d8	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2da	a9 00		lda #$00			lda 	#0
.b2dc	69 00		adc #$00			adc 	#0
.b2de	c8		iny				iny
.b2df	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2e1	4e 7b 06	lsr $067b			lsr 	gxX0+1 						; divide X by 4
.b2e4	6e 7a 06	ror $067a			ror 	gxX0
.b2e7	4e 7a 06	lsr $067a			lsr 	gxX0
.b2ea	4e 7c 06	lsr $067c			lsr 	gxY0 						; divide Y by 4
.b2ed	4e 7c 06	lsr $067c			lsr 	gxY0
.b2f0	ae 8d 06	ldx $068d			ldx 	GSCurrentSpriteID 			; copy X/4 and Y/4 into the status bytes
.b2f3	bd 92 06	lda $0692,x			lda 	GXSpriteLow,x
.b2f6	29 80		and #$80			and 	#$80
.b2f8	0d 7a 06	ora $067a			ora 	gxX0
.b2fb	9d 92 06	sta $0692,x			sta 	GXSpriteLow,x
.b2fe	bd d2 06	lda $06d2,x			lda 	GXSpriteHigh,x
.b301	29 c0		and #$c0			and 	#$C0
.b303	0d 7c 06	ora $067c			ora 	gxY0
.b306	9d d2 06	sta $06d2,x			sta 	GXSpriteHigh,x
.b309	18		clc				clc
.b30a	60		rts				rts
.b30b					_GXSIFail:
.b30b	38		sec				sec
.b30c	60		rts				rts
.b30d					_GXMSOffset:
>b30d	1c						.byte 	32-8/2
>b30e	18						.byte 	32-16/2
>b30f	14						.byte 	32-24/2
>b310	10						.byte 	32-32/2
.b311					GXOpenBitmap:
.b311	78		sei				sei 								; no interrupts here
.b312	a5 0b		lda $0b				lda 	GXEditSlot 					; Save the original LUT slot value
.b314	8d 8b 06	sta $068b			sta 	gxOriginalLUTValue
.b317	58		cli				cli
.b318	60		rts				rts
.b319					GXCloseBitmap:
.b319	78		sei				sei
.b31a	ad 8b 06	lda $068b			lda 	gxOriginalLUTValue 			; restore LUT slot value
.b31d	85 0b		sta $0b				sta 	GXEditSlot
.b31f	58		cli				cli
.b320	60		rts				rts
.b321					GXPositionCalc:
.b321	a5 36		lda $36				lda 	gxzTemp0 					; save temp memory slot
.b323	48		pha				pha
.b324	ad 7c 06	lda $067c			lda 	GXY0 						; gxzScreen = Y0
.b327	85 3c		sta $3c				sta 	gxzScreen
.b329	64 3d		stz $3d				stz 	gxzScreen+1
.b32b	06 3c		asl $3c				asl 	gxzScreen 						; gxzScreen = Y0 * 4
.b32d	26 3d		rol $3d				rol 	gxzScreen+1
.b32f	06 3c		asl $3c				asl 	gxzScreen
.b331	26 3d		rol $3d				rol 	gxzScreen+1
.b333	18		clc				clc 								; gxzScreen = Y0 * 5, as it's still in A
.b334	65 3c		adc $3c				adc 	gxzScreen
.b336	85 3c		sta $3c				sta 	gxzScreen
.b338	90 02		bcc $b33c			bcc 	_GXPCNoCarry
.b33a	e6 3d		inc $3d				inc 	gxzScreen+1
.b33c					_GXPCNoCarry:
.b33c	06 3c		asl $3c				asl 	gxzScreen 						; now Y0 * 10. Needs to be multiplied by another
.b33e	26 3d		rol $3d				rol 	gxzScreen+1 					; 32. At this point the MSB contains the offset
.b340	a5 3d		lda $3d				lda	 	gxzScreen+1 					; so save this in zTemp0 and zero it.
.b342	85 36		sta $36				sta 	gxzTemp0
.b344	64 3d		stz $3d				stz 	gxzScreen+1
.b346	a9 05		lda #$05			lda 	#5 							; now multiply by 32, this puts this in the range 0..8191
.b348					_GXPCMultiply32:
.b348	06 3c		asl $3c				asl 	gxzScreen
.b34a	26 3d		rol $3d				rol 	gxzScreen+1
.b34c	3a		dec a				dec 	a
.b34d	d0 f9		bne $b348			bne 	_GXPCMultiply32
.b34f	18		clc				clc
.b350	ad 7a 06	lda $067a			lda 	GXX0 						; add X to this value, put the result in gsOffset, gxzScreen has to be on a page boundary
.b353	65 3c		adc $3c				adc 	gxzScreen
.b355	8d 8c 06	sta $068c			sta 	gsOffset
.b358	ad 7b 06	lda $067b			lda 	GXX0+1
.b35b	65 3d		adc $3d				adc 	gxzScreen+1
.b35d	c9 20		cmp #$20			cmp 	#$20 						; has it overflowed into the next one ?
.b35f	90 04		bcc $b365			bcc 	_GXPCNoOverflow
.b361	29 1f		and #$1f			and 	#$1F 						; fix it up
.b363	e6 36		inc $36				inc 	gxzTemp0 					; add 1 to the page number
.b365					_GXPCNoOverflow:
.b365	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; make it the address mapped in.
.b367	85 3d		sta $3d				sta 	gxzScreen+1
.b369	64 3c		stz $3c				stz 	gxzScreen
.b36b	18		clc				clc
.b36c	a5 36		lda $36				lda 	gxzTemp0 					; get the page number
.b36e	6d 84 06	adc $0684			adc 	gxBasePage 					; by adding the base page
.b371	85 0b		sta $0b				sta 	GXEditSlot 				; and map it into memory.
.b373	68		pla				pla
.b374	85 36		sta $36				sta 	gxzTemp0
.b376	60		rts				rts
.b377					GXMovePositionDown:
.b377	18		clc				clc 								; add 320 to offset/temp+1
.b378	ad 8c 06	lda $068c			lda 	gsOffset
.b37b	69 40		adc #$40			adc 	#64
.b37d	8d 8c 06	sta $068c			sta 	gsOffset
.b380	a5 3d		lda $3d				lda 	gxzScreen+1
.b382	69 01		adc #$01			adc 	#1
.b384	85 3d		sta $3d				sta 	gxzScreen+1
.b386	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page
.b388	90 07		bcc $b391			bcc 	_GXMPDExit
.b38a	38		sec				sec  								; next page
.b38b	e9 20		sbc #$20			sbc 	#$20
.b38d	85 3d		sta $3d				sta 	gxzScreen+1
.b38f	e6 0b		inc $0b				inc 	GXEditSlot
.b391					_GXMPDExit:
.b391	60		rts				rts
.b392					GXCollide:
.b392	a5 36		lda $36				lda 	gxzTemp0 					; check if sprite numbers are legal.
.b394	aa		tax				tax
.b395	05 37		ora $37				ora 	gxzTemp0+1
.b397	29 c0		and #$c0			and 	#$C0
.b399	38		sec				sec
.b39a	d0 53		bne $b3ef			bne 	_GXCollideFail 				; if either >= 64, fail.
.b39c	a4 37		ldy $37				ldy 	gxzTemp0+1 					; at this point X is 1st sprite and Y is 2nd sprite.
.b39e	b9 92 06	lda $0692,y			lda 	GXSpriteLow,y 				; check if either hidden bit is set
.b3a1	1d 92 06	ora $0692,x			ora 	GXSpriteLow,x
.b3a4	30 48		bmi $b3ee			bmi 	_GXOkayFail 				; if either hidden, then they cannot collide.
.b3a6	18		clc				clc 								; need to calculate sum of sizes.
.b3a7	b9 d2 06	lda $06d2,y			lda 	GXSpriteHigh,y
.b3aa	7d d2 06	adc $06d2,x			adc 	GXSpriteHigh,x 				; at this point, CS, Bit 6 and 7 contain that sum.
.b3ad	29 c0		and #$c0			and 	#$C0 					 	; mask off
.b3af	6a		ror a				ror 	a 							; 5/6/7
.b3b0	4a		lsr a				lsr 	a 							; 4/5/6
.b3b1	4a		lsr a				lsr 	a 							; 3/4/5
.b3b2	4a		lsr a				lsr 	a 							; 2/3/4
.b3b3	18		clc				clc
.b3b4	69 08		adc #$08			adc 	#$08
.b3b6	4a		lsr a				lsr 	a 							; adjust because all coordinates are divided by 4 to store.
.b3b7	4a		lsr a				lsr 	a
.b3b8	85 38		sta $38				sta 	gxzTemp1 					; so the difference between the centres has to be less than this.
.b3ba	b9 d2 06	lda $06d2,y			lda 	GXSpriteHigh,y 				; calculate y1-y0
.b3bd	29 3f		and #$3f			and 	#$3F
.b3bf	85 39		sta $39				sta 	gxzTemp1+1
.b3c1	38		sec				sec
.b3c2	bd d2 06	lda $06d2,x			lda 	GXSpriteHigh,x
.b3c5	29 3f		and #$3f			and 	#$3F
.b3c7	e5 39		sbc $39				sbc 	gxzTemp1+1
.b3c9	b0 03		bcs $b3ce			bcs 	_GXCAbs1 					; calculate |y1-y0|
.b3cb	49 ff		eor #$ff			eor 	#$FF
.b3cd	1a		inc a				inc 	a
.b3ce					_GXCAbs1:
.b3ce	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b3d0	b0 1c		bcs $b3ee			bcs 	_GXOkayFail
.b3d2	85 39		sta $39				sta 	gxzTemp1+1 					; save |y1-y0|
.b3d4	38		sec				sec 								; calculate |x1-x0|
.b3d5	b9 92 06	lda $0692,y			lda 	GXSpriteLow,y
.b3d8	fd 92 06	sbc $0692,x			sbc 	GXSpriteLow,x
.b3db	b0 03		bcs $b3e0			bcs 	_GXCAbs2
.b3dd	49 ff		eor #$ff			eor 	#$FF
.b3df	1a		inc a				inc 	a
.b3e0					_GXCAbs2:
.b3e0	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b3e2	b0 0a		bcs $b3ee			bcs 	_GXOkayFail
.b3e4	c5 39		cmp $39				cmp 	gxzTemp1+1 					; is it less than the previous one.
.b3e6	90 02		bcc $b3ea			bcc 	_GXCHaveLowest
.b3e8	a5 39		lda $39				lda 	gxzTemp1+1 					; if not, that's the smallest difference.
.b3ea					_GXCHaveLowest:
.b3ea	0a		asl a				asl 	a 							; scale to allow for >> 2
.b3eb	0a		asl a				asl 	a
.b3ec	18		clc				clc
.b3ed	60		rts				rts
.b3ee					_GXOkayFail:
.b3ee	18		clc				clc
.b3ef					_GXCollideFail:
.b3ef	a9 ff		lda #$ff			lda 	#$FF
.b3f1	60		rts				rts
.b3f2					GXFindSprite:
.b3f2	aa		tax				tax
.b3f3	ad 85 06	lda $0685			lda 	GXSpritePage 				; access the base page of the sprite
.b3f6	85 0b		sta $0b				sta 	GXEditSlot
.b3f8	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; check a valid sprite
.b3fb	1d 00 60	ora $6000,x			ora 	GXMappingAddress,x
.b3fe	f0 33		beq $b433			beq 	_GXFSFail
.b400	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; MSB
.b403	8d 29 07	sta $0729			sta 	GXSpriteOffset+1
.b406	bd 00 60	lda $6000,x			lda 	GXMappingAddress,x 			; LSB
.b409	48		pha				pha 								; save twice
.b40a	48		pha				pha
.b40b	29 03		and #$03			and 	#3 							; get sprite size
.b40d	8d 26 07	sta $0726			sta 	GXSizeBits 					; save raw (0-3)
.b410	aa		tax				tax
.b411	bd 35 b4	lda $b435,x			lda 	_GXFXSSTTable,x 			; read sprite size
.b414	8d 25 07	sta $0725			sta 	GXSizePixels 					; save (8/16/24/32)
.b417	68		pla				pla 								; get LUT
.b418	4a		lsr a				lsr		a
.b419	4a		lsr a				lsr		a
.b41a	29 03		and #$03			and 	#3
.b41c	8d 27 07	sta $0727			sta 	GXSpriteLUT
.b41f	68		pla				pla 								; address, neeeds to be x 4
.b420	29 f0		and #$f0			and 	#$F0
.b422	8d 28 07	sta $0728			sta 	GXSpriteOffset
.b425	0e 28 07	asl $0728			asl 	GXSpriteOffset
.b428	2e 29 07	rol $0729			rol 	GXSpriteOffset+1
.b42b	0e 28 07	asl $0728			asl 	GXSpriteOffset
.b42e	2e 29 07	rol $0729			rol 	GXSpriteOffset+1
.b431	18		clc				clc
.b432	60		rts				rts
.b433					_GXFSFail:
.b433	38		sec				sec
.b434	60		rts				rts
.b435					_GXFXSSTTable:
>b435	08 10 18 20					.byte 	8,16,24,32
.0725					GXSizePixels:
>0725							.fill 	1
.0726					GXSizeBits:
>0726							.fill 	1
.0727					GXSpriteLUT:
>0727							.fill 	1
.0728					GXSpriteOffset:
>0728							.fill 	2
.b439					GXSortXY:
.b439	20 57 b4	jsr $b457			jsr 	GXSortY 					; will be sorted on Y now
.b43c	ad 7a 06	lda $067a			lda 	gxX0 						; compare X0 v X1
.b43f	cd 7e 06	cmp $067e			cmp 	gxX1
.b442	ad 7b 06	lda $067b			lda 	gXX0+1
.b445	ed 7f 06	sbc $067f			sbc 	gXX1+1
.b448	90 0c		bcc $b456			bcc 	_GXSXYExit 					; X0 < X1 exit
.b44a	a2 00		ldx #$00			ldx 	#0 							; swap them over
.b44c	a0 04		ldy #$04			ldy 	#4
.b44e	20 6b b4	jsr $b46b			jsr 	GXSwapXY
.b451	e8		inx				inx
.b452	c8		iny				iny
.b453	20 6b b4	jsr $b46b			jsr 	GXSwapXY
.b456					_GXSXYExit:
.b456	60		rts				rts
.b457					GXSortY:
.b457	ad 7c 06	lda $067c			lda 	gxY0 						; if Y0 >= Y1
.b45a	cd 80 06	cmp $0680			cmp 	gxY1
.b45d	90 0b		bcc $b46a			bcc 	_GXSYSorted
.b45f	a2 03		ldx #$03			ldx 	#3 							; swap 3-0
.b461	a0 07		ldy #$07			ldy 	#7 							; with 4-7
.b463					_GXSwap1:
.b463	20 6b b4	jsr $b46b			jsr 	GXSwapXY
.b466	88		dey				dey
.b467	ca		dex				dex
.b468	10 f9		bpl $b463			bpl 	_GXSwap1
.b46a					_GXSYSorted:
.b46a	60		rts				rts
.b46b					GXSwapXY:
.b46b	bd 7a 06	lda $067a,x			lda 	gxX0,x
.b46e	48		pha				pha
.b46f	b9 7a 06	lda $067a,y			lda 	gxX0,y
.b472	9d 7a 06	sta $067a,x			sta 	gxX0,x
.b475	68		pla				pla
.b476	99 7a 06	sta $067a,y			sta 	gxX0,y
.b479	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_tokeniser.module

=1					tokeniserIntegrated=1
.b47a					KeywordSet0:
>b47a	00 65					.text	0,$65,""               ; $80 !0:EOF
>b47c	00 58					.text	0,$58,""               ; $81 !1:SH1
>b47e	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b480	04 fe 41 42 53 28			.text	4,$fe,"ABS("           ; $83 ABS(
>b486	06 93 41 4c 4c 4f 43 28			.text	6,$93,"ALLOC("         ; $84 ALLOC(
>b48e	04 ff 41 53 43 28			.text	4,$ff,"ASC("           ; $85 ASC(
>b494	05 29 43 48 52 24 28			.text	5,$29,"CHR$("          ; $86 CHR$(
>b49b	05 41 44 45 45 4b 28			.text	5,$41,"DEEK("          ; $87 DEEK(
>b4a2	06 aa 45 56 45 4e 54 28			.text	6,$aa,"EVENT("         ; $88 EVENT(
>b4aa	05 6b 46 41 4c 53 45			.text	5,$6b,"FALSE"          ; $89 FALSE
>b4b1	05 44 46 52 41 43 28			.text	5,$44,"FRAC("          ; $8a FRAC(
>b4b8	04 0d 48 49 54 28			.text	4,$0d,"HIT("           ; $8b HIT(
>b4be	04 13 49 4e 54 28			.text	4,$13,"INT("           ; $8c INT(
>b4c4	06 a7 49 53 56 41 4c 28			.text	6,$a7,"ISVAL("         ; $8d ISVAL(
>b4cc	05 5c 4a 4f 59 42 28			.text	5,$5c,"JOYB("          ; $8e JOYB(
>b4d3	05 72 4a 4f 59 58 28			.text	5,$72,"JOYX("          ; $8f JOYX(
>b4da	05 73 4a 4f 59 59 28			.text	5,$73,"JOYY("          ; $90 JOYY(
>b4e1	06 77 4c 45 46 54 24 28			.text	6,$77,"LEFT$("         ; $91 LEFT$(
>b4e9	04 07 4c 45 4e 28			.text	4,$07,"LEN("           ; $92 LEN(
>b4ef	04 0e 4d 41 58 28			.text	4,$0e,"MAX("           ; $93 MAX(
>b4f5	05 26 4d 49 44 24 28			.text	5,$26,"MID$("          ; $94 MID$(
>b4fc	04 0c 4d 49 4e 28			.text	4,$0c,"MIN("           ; $95 MIN(
>b502	04 19 4e 4f 54 28			.text	4,$19,"NOT("           ; $96 NOT(
>b508	05 4d 50 45 45 4b 28			.text	5,$4d,"PEEK("          ; $97 PEEK(
>b50f	08 3c 50 4c 41 59 49 4e			.text	8,$3c,"PLAYING("       ; $98 PLAYING(
>b517	47 28
>b519	07 e9 52 41 4e 44 4f 4d			.text	7,$e9,"RANDOM("        ; $99 RANDOM(
>b521	28
>b522	07 ca 52 49 47 48 54 24			.text	7,$ca,"RIGHT$("        ; $9a RIGHT$(
>b52a	28
>b52b	04 0c 52 4e 44 28			.text	4,$0c,"RND("           ; $9b RND(
>b531	04 10 53 47 4e 28			.text	4,$10,"SGN("           ; $9c SGN(
>b537	04 0e 53 50 43 28			.text	4,$0e,"SPC("           ; $9d SPC(
>b53d	05 45 53 54 52 24 28			.text	5,$45,"STR$("          ; $9e STR$(
>b544	06 a9 54 49 4d 45 52 28			.text	6,$a9,"TIMER("         ; $9f TIMER(
>b54c	04 40 54 52 55 45			.text	4,$40,"TRUE"           ; $a0 TRUE
>b552	04 0b 56 41 4c 28			.text	4,$0b,"VAL("           ; $a1 VAL(
>b558	03 e7 46 4f 52				.text	3,$e7,"FOR"            ; $a2 FOR
>b55d	02 8f 49 46				.text	2,$8f,"IF"             ; $a3 IF
>b561	04 34 50 52 4f 43			.text	4,$34,"PROC"           ; $a4 PROC
>b567	06 c1 52 45 50 45 41 54			.text	6,$c1,"REPEAT"         ; $a5 REPEAT
>b56f	05 79 57 48 49 4c 45			.text	5,$79,"WHILE"          ; $a6 WHILE
>b576	05 66 45 4e 44 49 46			.text	5,$66,"ENDIF"          ; $a7 ENDIF
>b57d	07 0b 45 4e 44 50 52 4f			.text	7,$0b,"ENDPROC"        ; $a8 ENDPROC
>b585	43
>b586	04 3f 4e 45 58 54			.text	4,$3f,"NEXT"           ; $a9 NEXT
>b58c	04 2f 54 48 45 4e			.text	4,$2f,"THEN"           ; $aa THEN
>b592	05 8c 55 4e 54 49 4c			.text	5,$8c,"UNTIL"          ; $ab UNTIL
>b599	04 2e 57 45 4e 44			.text	4,$2e,"WEND"           ; $ac WEND
>b59f	02 9b 42 59				.text	2,$9b,"BY"             ; $ad BY
>b5a3	04 1c 43 41 4c 4c			.text	4,$1c,"CALL"           ; $ae CALL
>b5a9	06 b2 43 49 52 43 4c 45			.text	6,$b2,"CIRCLE"         ; $af CIRCLE
>b5b1	05 67 43 4c 45 41 52			.text	5,$67,"CLEAR"          ; $b0 CLEAR
>b5b8	03 e2 43 4c 53				.text	3,$e2,"CLS"            ; $b1 CLS
>b5bd	05 7f 43 4f 4c 4f 52			.text	5,$7f,"COLOR"          ; $b2 COLOR
>b5c4	06 d4 43 4f 4c 4f 55 52			.text	6,$d4,"COLOUR"         ; $b3 COLOUR
>b5cc	04 1a 44 41 54 41			.text	4,$1a,"DATA"           ; $b4 DATA
>b5d2	03 da 44 49 4d				.text	3,$da,"DIM"            ; $b5 DIM
>b5d7	04 23 44 4f 4b 45			.text	4,$23,"DOKE"           ; $b6 DOKE
>b5dd	06 db 44 4f 57 4e 54 4f			.text	6,$db,"DOWNTO"         ; $b7 DOWNTO
>b5e5	04 29 45 4c 53 45			.text	4,$29,"ELSE"           ; $b8 ELSE
>b5eb	04 34 46 52 4f 4d			.text	4,$34,"FROM"           ; $b9 FROM
>b5f1	03 e5 47 46 58				.text	3,$e5,"GFX"            ; $ba GFX
>b5f6	05 80 47 4f 53 55 42			.text	5,$80,"GOSUB"          ; $bb GOSUB
>b5fd	04 39 47 4f 54 4f			.text	4,$39,"GOTO"           ; $bc GOTO
>b603	04 24 48 45 52 45			.text	4,$24,"HERE"           ; $bd HERE
>b609	05 63 49 4d 41 47 45			.text	5,$63,"IMAGE"          ; $be IMAGE
>b610	05 90 49 4e 50 55 54			.text	5,$90,"INPUT"          ; $bf INPUT
>b617	03 e5 4c 45 54				.text	3,$e5,"LET"            ; $c0 LET
>b61c	04 28 4c 49 4e 45			.text	4,$28,"LINE"           ; $c1 LINE
>b622	05 6b 4c 4f 43 41 4c			.text	5,$6b,"LOCAL"          ; $c2 LOCAL
>b629	03 db 4f 46 46				.text	3,$db,"OFF"            ; $c3 OFF
>b62e	02 9d 4f 4e				.text	2,$9d,"ON"             ; $c4 ON
>b632	07 20 4f 55 54 4c 49 4e			.text	7,$20,"OUTLINE"        ; $c5 OUTLINE
>b63a	45
>b63b	07 0f 50 41 4c 45 54 54			.text	7,$0f,"PALETTE"        ; $c6 PALETTE
>b643	45
>b644	04 3f 50 4c 4f 54			.text	4,$3f,"PLOT"           ; $c7 PLOT
>b64a	04 2f 50 4f 4b 45			.text	4,$2f,"POKE"           ; $c8 POKE
>b650	05 8d 50 52 49 4e 54			.text	5,$8d,"PRINT"          ; $c9 PRINT
>b657	04 1c 52 45 41 44			.text	4,$1c,"READ"           ; $ca READ
>b65d	04 2e 52 45 43 54			.text	4,$2e,"RECT"           ; $cb RECT
>b663	03 e4 52 45 4d				.text	3,$e4,"REM"            ; $cc REM
>b668	06 e0 52 45 54 55 52 4e			.text	6,$e0,"RETURN"         ; $cd RETURN
>b670	05 7b 53 4f 4c 49 44			.text	5,$7b,"SOLID"          ; $ce SOLID
>b677	05 89 53 4f 55 4e 44			.text	5,$89,"SOUND"          ; $cf SOUND
>b67e	06 d7 53 50 52 49 54 45			.text	6,$d7,"SPRITE"         ; $d0 SPRITE
>b686	04 45 54 45 58 54			.text	4,$45,"TEXT"           ; $d1 TEXT
>b68c	02 a3 54 4f				.text	2,$a3,"TO"             ; $d2 TO
>b690	ff					.text	$FF
.b691					KeywordSet1:
>b691	00 65					.text	0,$65,""               ; $80 !0:EOF
>b693	00 58					.text	0,$58,""               ; $81 !1:SH1
>b695	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b697	08 4c 41 53 53 45 4d 42			.text	8,$4c,"ASSEMBLE"       ; $83 ASSEMBLE
>b69f	4c 45
>b6a1	06 d2 41 53 53 45 52 54			.text	6,$d2,"ASSERT"         ; $84 ASSERT
>b6a9	06 bd 42 49 54 4d 41 50			.text	6,$bd,"BITMAP"         ; $85 BITMAP
>b6b1	03 d7 45 4e 44				.text	3,$d7,"END"            ; $86 END
>b6b6	07 11 45 58 50 4c 4f 44			.text	7,$11,"EXPLODE"        ; $87 EXPLODE
>b6be	45
>b6bf	02 96 47 4f				.text	2,$96,"GO"             ; $88 GO
>b6c3	04 3c 4c 49 53 54			.text	4,$3c,"LIST"           ; $89 LIST
>b6c9	04 20 4c 4f 41 44			.text	4,$20,"LOAD"           ; $8a LOAD
>b6cf	03 ea 4e 45 57				.text	3,$ea,"NEW"            ; $8b NEW
>b6d4	04 2e 50 49 4e 47			.text	4,$2e,"PING"           ; $8c PING
>b6da	07 24 52 45 53 54 4f 52			.text	7,$24,"RESTORE"        ; $8d RESTORE
>b6e2	45
>b6e3	03 f5 52 55 4e				.text	3,$f5,"RUN"            ; $8e RUN
>b6e8	05 8d 53 48 4f 4f 54			.text	5,$8d,"SHOOT"          ; $8f SHOOT
>b6ef	07 2a 53 50 52 49 54 45			.text	7,$2a,"SPRITES"        ; $90 SPRITES
>b6f7	53
>b6f8	04 46 53 54 4f 50			.text	4,$46,"STOP"           ; $91 STOP
>b6fe	03 eb 5a 41 50				.text	3,$eb,"ZAP"            ; $92 ZAP
>b703	ff					.text	$FF
.b704					KeywordSet2:
>b704	00 65					.text	0,$65,""               ; $80 !0:EOF
>b706	00 58					.text	0,$58,""               ; $81 !1:SH1
>b708	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b70a	03 c8 41 44 43				.text	3,$c8,"ADC"            ; $83 ADC
>b70f	03 d3 41 4e 44				.text	3,$d3,"AND"            ; $84 AND
>b714	03 e0 41 53 4c				.text	3,$e0,"ASL"            ; $85 ASL
>b719	03 c8 42 43 43				.text	3,$c8,"BCC"            ; $86 BCC
>b71e	03 d8 42 43 53				.text	3,$d8,"BCS"            ; $87 BCS
>b723	03 d8 42 45 51				.text	3,$d8,"BEQ"            ; $88 BEQ
>b728	03 df 42 49 54				.text	3,$df,"BIT"            ; $89 BIT
>b72d	03 d8 42 4d 49				.text	3,$d8,"BMI"            ; $8a BMI
>b732	03 d5 42 4e 45				.text	3,$d5,"BNE"            ; $8b BNE
>b737	03 de 42 50 4c				.text	3,$de,"BPL"            ; $8c BPL
>b73c	03 d5 42 52 41				.text	3,$d5,"BRA"            ; $8d BRA
>b741	03 df 42 52 4b				.text	3,$df,"BRK"            ; $8e BRK
>b746	03 db 42 56 43				.text	3,$db,"BVC"            ; $8f BVC
>b74b	03 eb 42 56 53				.text	3,$eb,"BVS"            ; $90 BVS
>b750	03 d2 43 4c 43				.text	3,$d2,"CLC"            ; $91 CLC
>b755	03 d3 43 4c 44				.text	3,$d3,"CLD"            ; $92 CLD
>b75a	03 d8 43 4c 49				.text	3,$d8,"CLI"            ; $93 CLI
>b75f	03 e5 43 4c 56				.text	3,$e5,"CLV"            ; $94 CLV
>b764	03 e0 43 4d 50				.text	3,$e0,"CMP"            ; $95 CMP
>b769	03 eb 43 50 58				.text	3,$eb,"CPX"            ; $96 CPX
>b76e	03 ec 43 50 59				.text	3,$ec,"CPY"            ; $97 CPY
>b773	03 cc 44 45 43				.text	3,$cc,"DEC"            ; $98 DEC
>b778	03 e1 44 45 58				.text	3,$e1,"DEX"            ; $99 DEX
>b77d	03 e2 44 45 59				.text	3,$e2,"DEY"            ; $9a DEY
>b782	03 e6 45 4f 52				.text	3,$e6,"EOR"            ; $9b EOR
>b787	03 da 49 4e 43				.text	3,$da,"INC"            ; $9c INC
>b78c	03 ef 49 4e 58				.text	3,$ef,"INX"            ; $9d INX
>b791	03 f0 49 4e 59				.text	3,$f0,"INY"            ; $9e INY
>b796	03 e7 4a 4d 50				.text	3,$e7,"JMP"            ; $9f JMP
>b79b	03 ef 4a 53 52				.text	3,$ef,"JSR"            ; $a0 JSR
>b7a0	03 d1 4c 44 41				.text	3,$d1,"LDA"            ; $a1 LDA
>b7a5	03 e8 4c 44 58				.text	3,$e8,"LDX"            ; $a2 LDX
>b7aa	03 e9 4c 44 59				.text	3,$e9,"LDY"            ; $a3 LDY
>b7af	03 f1 4c 53 52				.text	3,$f1,"LSR"            ; $a4 LSR
>b7b4	03 ed 4e 4f 50				.text	3,$ed,"NOP"            ; $a5 NOP
>b7b9	03 e2 4f 52 41				.text	3,$e2,"ORA"            ; $a6 ORA
>b7be	03 d9 50 48 41				.text	3,$d9,"PHA"            ; $a7 PHA
>b7c3	03 e8 50 48 50				.text	3,$e8,"PHP"            ; $a8 PHP
>b7c8	03 f0 50 48 58				.text	3,$f0,"PHX"            ; $a9 PHX
>b7cd	03 f1 50 48 59				.text	3,$f1,"PHY"            ; $aa PHY
>b7d2	03 dd 50 4c 41				.text	3,$dd,"PLA"            ; $ab PLA
>b7d7	03 ec 50 4c 50				.text	3,$ec,"PLP"            ; $ac PLP
>b7dc	03 f4 50 4c 58				.text	3,$f4,"PLX"            ; $ad PLX
>b7e1	03 f5 50 4c 59				.text	3,$f5,"PLY"            ; $ae PLY
>b7e6	03 ed 52 4f 4c				.text	3,$ed,"ROL"            ; $af ROL
>b7eb	03 f3 52 4f 52				.text	3,$f3,"ROR"            ; $b0 ROR
>b7f0	03 ef 52 54 49				.text	3,$ef,"RTI"            ; $b1 RTI
>b7f5	03 f9 52 54 53				.text	3,$f9,"RTS"            ; $b2 RTS
>b7fa	03 d8 53 42 43				.text	3,$d8,"SBC"            ; $b3 SBC
>b7ff	03 db 53 45 43				.text	3,$db,"SEC"            ; $b4 SEC
>b804	03 dc 53 45 44				.text	3,$dc,"SED"            ; $b5 SED
>b809	03 e1 53 45 49				.text	3,$e1,"SEI"            ; $b6 SEI
>b80e	03 e8 53 54 41				.text	3,$e8,"STA"            ; $b7 STA
>b813	03 f7 53 54 50				.text	3,$f7,"STP"            ; $b8 STP
>b818	03 ff 53 54 58				.text	3,$ff,"STX"            ; $b9 STX
>b81d	03 00 53 54 59				.text	3,$00,"STY"            ; $ba STY
>b822	03 01 53 54 5a				.text	3,$01,"STZ"            ; $bb STZ
>b827	03 ed 54 41 58				.text	3,$ed,"TAX"            ; $bc TAX
>b82c	03 ee 54 41 59				.text	3,$ee,"TAY"            ; $bd TAY
>b831	03 e8 54 52 42				.text	3,$e8,"TRB"            ; $be TRB
>b836	03 e9 54 53 42				.text	3,$e9,"TSB"            ; $bf TSB
>b83b	03 ff 54 53 58				.text	3,$ff,"TSX"            ; $c0 TSX
>b840	03 ed 54 58 41				.text	3,$ed,"TXA"            ; $c1 TXA
>b845	03 ff 54 58 53				.text	3,$ff,"TXS"            ; $c2 TXS
>b84a	03 ee 54 59 41				.text	3,$ee,"TYA"            ; $c3 TYA
>b84f	ff					.text	$FF
.b850					Export_TKListConvertLine:
.b850	48		pha				pha 								; save indent on the stack
.b851	9c 1d 04	stz $041d			stz 	tbOffset
.b854	9c 2d 04	stz $042d			stz 	tokenBuffer
.b857	9c 29 04	stz $0429			stz 	currentListColour
.b85a	a9 89		lda #$89			lda 	#CLILineNumber+$80
.b85c	20 d9 b9	jsr $b9d9			jsr 	LCLWriteColour
.b85f	a0 02		ldy #$02			ldy 	#2 							; convert line number to string
.b861	b1 30		lda ($30),y			lda 	(codePtr),y
.b863	aa		tax				tax
.b864	88		dey				dey
.b865	b1 30		lda ($30),y			lda 	(codePtr),y
.b867	20 4a ba	jsr $ba4a			jsr 	LCLWriteNumberXA
.b86a	68		pla				pla 								; adjustment to indent
.b86b	48		pha				pha 								; save on stack
.b86c	10 0c		bpl $b87a			bpl 	_LCNoAdjust 				; don't adjust indent if +ve, do after.
.b86e	18		clc				clc 								; add to list indent and make 0 if goes -ve.
.b86f	6d 26 04	adc $0426			adc 	listIndent
.b872	8d 26 04	sta $0426			sta 	listIndent
.b875	10 03		bpl $b87a			bpl 	_LCNoAdjust
.b877	9c 26 04	stz $0426			stz 	listIndent
.b87a					_LCNoAdjust:
.b87a	18		clc				clc		 							; work out actual indent.
.b87b	ad 26 04	lda $0426			lda 	listIndent
.b87e	0a		asl a				asl 	a
.b87f	69 07		adc #$07			adc 	#7
.b881	85 36		sta $36				sta 	zTemp0
.b883					_LCPadOut:
.b883	a9 20		lda #$20			lda 	#' '						; pad out to 6+indent characters
.b885	20 e2 b9	jsr $b9e2			jsr 	LCLWrite
.b888	ad 1d 04	lda $041d			lda 	tbOffset
.b88b	c5 36		cmp $36				cmp 	zTemp0
.b88d	d0 f4		bne $b883			bne 	_LCPadOut
.b88f	a0 03		ldy #$03			ldy 	#3 							; start position.
.b891					_LCMainLoop:
.b891	a9 8a		lda #$8a			lda 	#CLIPunctuation+$80
.b893	20 d9 b9	jsr $b9d9			jsr 	LCLWriteColour
.b896	b1 30		lda ($30),y			lda 	(codePtr),y
.b898	c9 80		cmp #$80			cmp 	#KWC_EOL 					; end of line ?
.b89a	f0 17		beq $b8b3			beq 	_LCExit
.b89c	c9 10		cmp #$10			cmp 	#16 						; 0-5 are the double punctuations
.b89e	90 1e		bcc $b8be			bcc 	_LCDoubles
.b8a0	c9 20		cmp #$20			cmp 	#32 						; 16-31 are shifted punctuation from 64-91
.b8a2	90 2a		bcc $b8ce			bcc 	_LCShiftPunc
.b8a4	c9 40		cmp #$40			cmp 	#64 						; 32-64 are as stored, punc and digits
.b8a6	90 35		bcc $b8dd			bcc 	_LCPunctuation
.b8a8	c9 80		cmp #$80			cmp 	#128 						; 64-127 are variable identifiers.
.b8aa	90 51		bcc $b8fd			bcc 	_LCIdentifiers
.b8ac	c9 fe		cmp #$fe			cmp 	#254 						; 128-253 are tokenised words
.b8ae	90 73		bcc $b923			bcc 	_LCTokens
.b8b0	4c 83 b9	jmp $b983			jmp 	_LCData 					; 254-5 are data objects
.b8b3					_LCExit:
.b8b3	68		pla				pla 								; get old indent adjust
.b8b4	30 07		bmi $b8bd			bmi 	_LCExit2
.b8b6	18		clc				clc 								; add to indent if +ve
.b8b7	6d 26 04	adc $0426			adc 	listIndent
.b8ba	8d 26 04	sta $0426			sta 	listIndent
.b8bd					_LCExit2:
.b8bd	60		rts				rts
.b8be					_LCDoubles:
.b8be	48		pha				pha
.b8bf	4a		lsr a				lsr 	a 							; put bit 2 into bit 1
.b8c0	29 02		and #$02			and 	#2
.b8c2	09 3c		ora #$3c			ora 	#60 						; make < >
.b8c4	20 e2 b9	jsr $b9e2			jsr 	LCLWrite
.b8c7	68		pla				pla 								; restore, do lower bit
.b8c8	29 03		and #$03			and 	#3
.b8ca	09 3c		ora #$3c			ora 	#60
.b8cc	80 0f		bra $b8dd			bra		_LCPunctuation 				; print, increment, loop
.b8ce					_LCShiftPunc:
.b8ce	aa		tax				tax 								; save in X
.b8cf	29 07		and #$07			and 	#7 							; lower 3 bits
.b8d1	f0 02		beq $b8d5			beq 	_LCNoAdd
.b8d3	09 18		ora #$18			ora 	#24 						; adds $18 to it.
.b8d5					_LCNoAdd:
.b8d5	e0 18		cpx #$18			cpx 	#24 						; if >= 24 add $20
.b8d7	90 02		bcc $b8db			bcc 	_LCNoAdd2
.b8d9	09 20		ora #$20			ora 	#32 						; adds $20
.b8db					_LCNoAdd2:
.b8db	09 40		ora #$40			ora 	#$40 						; shift into 64-127 range and fall through.
.b8dd					_LCPunctuation:
.b8dd	c9 3a		cmp #$3a			cmp 	#':' 						; check if :
.b8df	d0 03		bne $b8e4			bne 	_LCPContinue
.b8e1	20 f8 b9	jsr $b9f8			jsr 	LCLDeleteLastSpace 			; if so delete any preceding spaces
.b8e4					_LCPContinue:
.b8e4	c9 2e		cmp #$2e			cmp 	#'.'
.b8e6	f0 08		beq $b8f0			beq 	_LCPIsConstant
.b8e8	c9 30		cmp #$30			cmp 	#'0'
.b8ea	90 0b		bcc $b8f7			bcc 	_LCPNotConstant
.b8ec	c9 3a		cmp #$3a			cmp 	#'9'+1
.b8ee	b0 07		bcs $b8f7			bcs 	_LCPNotConstant
.b8f0					_LCPIsConstant:
.b8f0	48		pha				pha
.b8f1	a9 8d		lda #$8d			lda 	#CLIConstant+$80
.b8f3	20 d9 b9	jsr $b9d9			jsr 	LCLWriteColour
.b8f6	68		pla				pla
.b8f7					_LCPNotConstant:
.b8f7	c8		iny				iny 								; consume character
.b8f8	20 e2 b9	jsr $b9e2			jsr 	LCLWrite 					; write it out.
.b8fb	80 94		bra $b891			bra 	_LCMainLoop 				; go round again.
.b8fd					_LCIdentifiers:
.b8fd	18		clc				clc 								; convert to physical address
.b8fe	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.b900	85 37		sta $37				sta 	zTemp0+1
.b902	c8		iny				iny
.b903	b1 30		lda ($30),y			lda 	(codePtr),y
.b905	85 36		sta $36				sta 	zTemp0
.b907	c8		iny				iny
.b908	5a		phy				phy 								; save position
.b909	a9 87		lda #$87			lda 	#CLIIdentifier+$80
.b90b	20 d9 b9	jsr $b9d9			jsr 	LCLWriteColour
.b90e	a0 07		ldy #$07			ldy 	#7 							; output the identifier at +8
.b910					_LCOutIdentifier:
.b910	c8		iny				iny
.b911	b1 36		lda ($36),y			lda 	(zTemp0),y					; bit 7 set = end.
.b913	29 7f		and #$7f			and 	#$7F
.b915	20 34 ba	jsr $ba34			jsr 	LCLLowerCase
.b918	20 e2 b9	jsr $b9e2			jsr 	LCLWrite
.b91b	b1 36		lda ($36),y			lda 	(zTemp0),y				 	; ends when bit 7 set.
.b91d	10 f1		bpl $b910			bpl 	_LCOutIdentifier
.b91f	7a		ply				ply 								; restore position
.b920	4c 91 b8	jmp $b891			jmp 	_LCMainLoop
.b923					_LCTokens:
.b923	aa		tax				tax 								; token in X
.b924	a9 04		lda #$04			lda 	#((KeywordSet2) & $FF)
.b926	85 36		sta $36				sta 	0+zTemp0
.b928	a9 b7		lda #$b7			lda 	#((KeywordSet2) >> 8)
.b92a	85 37		sta $37				sta 	1+zTemp0
.b92c	e0 82		cpx #$82			cpx 	#$82
.b92e	f0 16		beq $b946			beq 	_LCUseShift
.b930	a9 91		lda #$91			lda 	#((KeywordSet1) & $FF)
.b932	85 36		sta $36				sta 	0+zTemp0
.b934	a9 b6		lda #$b6			lda 	#((KeywordSet1) >> 8)
.b936	85 37		sta $37				sta 	1+zTemp0
.b938	e0 81		cpx #$81			cpx 	#$81
.b93a	f0 0a		beq $b946			beq 	_LCUseShift
.b93c	a9 7a		lda #$7a			lda 	#((KeywordSet0) & $FF)
.b93e	85 36		sta $36				sta 	0+zTemp0
.b940	a9 b4		lda #$b4			lda 	#((KeywordSet0) >> 8)
.b942	85 37		sta $37				sta 	1+zTemp0
.b944	80 01		bra $b947			bra 	_LCNoShift
.b946					_LCUseShift:
.b946	c8		iny				iny
.b947					_LCNoShift:
.b947	20 0c ba	jsr $ba0c			jsr 	LCLCheckSpaceRequired 		; do we need a space ?
.b94a	b1 30		lda ($30),y			lda 	(codePtr),y
.b94c	aa		tax				tax 								; into X
.b94d					_LCFindText:
.b94d	ca		dex				dex
.b94e	10 0e		bpl $b95e			bpl 	_LCFoundText 				; found text.
.b950	b2 36		lda ($36)			lda 	(zTemp0) 					; length of text
.b952	1a		inc a				inc 	a 							; one extra for size
.b953	38		sec				sec 								; one extra for checksum
.b954	65 36		adc $36				adc 	zTemp0 						; go to next token
.b956	85 36		sta $36				sta 	zTemp0
.b958	90 f3		bcc $b94d			bcc 	_LCFindText
.b95a	e6 37		inc $37				inc 	zTemp0+1
.b95c	80 ef		bra $b94d			bra 	_LCFindText
.b95e					_LCFoundText:
.b95e	5a		phy				phy 								; save List position
.b95f	b2 36		lda ($36)			lda 	(zTemp0)					; count to print
.b961	aa		tax				tax
.b962	a9 83		lda #$83			lda 	#CLIToken+$80
.b964	20 d9 b9	jsr $b9d9			jsr 	LCLWriteColour
.b967	a0 02		ldy #$02			ldy 	#2
.b969					_LCCopyToken:
.b969	b1 36		lda ($36),y			lda 	(zTemp0),y
.b96b	20 34 ba	jsr $ba34			jsr 	LCLLowerCase
.b96e	20 e2 b9	jsr $b9e2			jsr 	LCLWrite
.b971	c8		iny				iny
.b972	ca		dex				dex
.b973	d0 f4		bne $b969			bne 	_LCCopyToken
.b975	c9 28		cmp #$28			cmp 	#"(" 						; if last char not ( print a space
.b977	f0 05		beq $b97e			beq 	_LCNoSpace
.b979	a9 20		lda #$20			lda 	#' '
.b97b	20 e2 b9	jsr $b9e2			jsr 	LCLWrite
.b97e					_LCNoSpace:
.b97e	7a		ply				ply 								; restore position.
.b97f	c8		iny				iny 								; consume token
.b980	4c 91 b8	jmp $b891			jmp 	_LCMainLoop 				; and go around again.
.b983					_LCData:
.b983	48		pha				pha 								; save type $FE/$FF
.b984	a2 24		ldx #$24			ldx 	#'$' 						; figure out $ or "
.b986	c9 fe		cmp #$fe			cmp 	#$FE
.b988	f0 22		beq $b9ac			beq 	_LCHaveOpener
.b98a	a2 22		ldx #$22			ldx 	#'"'
.b98c	a9 81		lda #$81			lda 	#CLIData+$80
.b98e	20 d9 b9	jsr $b9d9			jsr 	LCLWriteColour
.b991	c0 04		cpy #$04			cpy 	#4 							; must be 2nd thing on line
.b993	d0 17		bne $b9ac			bne 	_LCHaveOpener
.b995	88		dey				dey 								; what precedes it ?
.b996	b1 30		lda ($30),y			lda 	(codePtr),y
.b998	c8		iny				iny
.b999	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; if quote
.b99b	d0 0f		bne $b9ac			bne 	_LCHaveOpener
.b99d	a9 09		lda #$09			lda 	#9 							; tab
.b99f	20 e2 b9	jsr $b9e2			jsr 	LCLWrite
.b9a2	a9 97		lda #$97			lda 	#$90+CLIBComment
.b9a4	20 e2 b9	jsr $b9e2			jsr 	LCLWrite
.b9a7	a9 80		lda #$80			lda 	#CLIFComment+$80
.b9a9	20 d9 b9	jsr $b9d9			jsr 	LCLWriteColour
.b9ac					_LCHaveOpener:
.b9ac	8a		txa				txa 								; output prefix (# or ")
.b9ad	20 e2 b9	jsr $b9e2			jsr 	LCLWrite
.b9b0	c8		iny				iny 								; get count
.b9b1	b1 30		lda ($30),y			lda 	(codePtr),y
.b9b3	aa		tax				tax
.b9b4	c8		iny				iny 								; point at first character
.b9b5					_LCOutData:
.b9b5	b1 30		lda ($30),y			lda 	(codePtr),y
.b9b7	c9 00		cmp #$00			cmp 	#0
.b9b9	f0 03		beq $b9be			beq 	_LCNoPrint
.b9bb	20 e2 b9	jsr $b9e2			jsr 	LCLWrite
.b9be					_LCNoPrint:
.b9be	c8		iny				iny
.b9bf	ca		dex				dex
.b9c0	d0 f3		bne $b9b5			bne 	_LCOutData
.b9c2	68		pla				pla 								; closing " required ?
.b9c3	c9 ff		cmp #$ff			cmp 	#$FF 						; not required for hex constant.
.b9c5	d0 0f		bne $b9d6			bne 	_LCNoQuote
.b9c7	a9 22		lda #$22			lda 	#'"'
.b9c9	20 e2 b9	jsr $b9e2			jsr 	LCLWrite
.b9cc	ad 6f 06	lda $066f			lda 	EXTTextColour
.b9cf	29 0f		and #$0f			and 	#$0F
.b9d1	09 90		ora #$90			ora 	#$90
.b9d3	20 e2 b9	jsr $b9e2			jsr 	LCLWrite
.b9d6					_LCNoQuote:
.b9d6	4c 91 b8	jmp $b891			jmp 	_LCMainLoop
.b9d9					LCLWriteColour:
.b9d9	cd 29 04	cmp $0429			cmp 	currentListColour 			; has the colour changed
.b9dc	8d 29 04	sta $0429			sta 	currentListColour 			; (update it anyway)
.b9df	d0 01		bne $b9e2			bne 	LCLWrite 					; if different, output it
.b9e1	60		rts				rts
.b9e2					LCLWrite:
.b9e2	da		phx				phx
.b9e3	ae 1d 04	ldx $041d			ldx 	tbOffset 					; write out make ASCIIZ
.b9e6	9d 2d 04	sta $042d,x			sta 	tokenBuffer,x
.b9e9	9e 2e 04	stz $042e,x			stz 	tokenBuffer+1,x
.b9ec	ee 1d 04	inc $041d			inc 	tbOffset 					; bump the position
.b9ef	09 00		ora #$00			ora 	#0 							; don't update last character if colour data
.b9f1	30 03		bmi $b9f6			bmi 	_LCLNoColour
.b9f3	8d 27 04	sta $0427			sta 	LCLastCharacter
.b9f6					_LCLNoColour:
.b9f6	fa		plx				plx
.b9f7	60		rts				rts
.b9f8					LCLDeleteLastSpace:
.b9f8	48		pha				pha
.b9f9	da		phx				phx
.b9fa	ae 1d 04	ldx $041d			ldx 	tbOffset
.b9fd	f0 0a		beq $ba09			beq 	_LCDLSExit
.b9ff	bd 2c 04	lda $042c,x			lda 	tokenBuffer-1,x
.ba02	c9 20		cmp #$20			cmp 	#' '
.ba04	d0 03		bne $ba09			bne 	_LCDLSExit
.ba06	ce 1d 04	dec $041d			dec 	tbOffset
.ba09					_LCDLSExit:
.ba09	fa		plx				plx
.ba0a	68		pla				pla
.ba0b	60		rts				rts
.ba0c					LCLCheckSpaceRequired:
.ba0c	ad 27 04	lda $0427			lda 	LCLastCharacter 			; check last character
.ba0f	c9 24		cmp #$24			cmp 	#'$' 						; $ # and ) require that token space.
.ba11	f0 1b		beq $ba2e			beq 	_LCCSRSpace
.ba13	c9 29		cmp #$29			cmp 	#')'
.ba15	f0 17		beq $ba2e			beq 	_LCCSRSpace
.ba17	c9 23		cmp #$23			cmp 	#'#'
.ba19	f0 13		beq $ba2e			beq 	_LCCSRSpace
.ba1b	20 34 ba	jsr $ba34			jsr 	LCLLowerCase 				; saves a little effort
.ba1e	c9 30		cmp #$30			cmp 	#"0" 						; check if it was 0-9 A-Z a-z if so need space.
.ba20	90 11		bcc $ba33			bcc 	_LCCSRExit
.ba22	c9 3a		cmp #$3a			cmp 	#"9"+1
.ba24	90 08		bcc $ba2e			bcc 	_LCCSRSpace
.ba26	c9 61		cmp #$61			cmp 	#"a"
.ba28	90 09		bcc $ba33			bcc 	_LCCSRExit
.ba2a	c9 7b		cmp #$7b			cmp 	#"z"+1
.ba2c	b0 05		bcs $ba33			bcs 	_LCCSRExit
.ba2e					_LCCSRSpace:
.ba2e	a9 20		lda #$20			lda 	#' '
.ba30	20 e2 b9	jsr $b9e2			jsr 	LCLWrite
.ba33					_LCCSRExit:
.ba33	60		rts				rts
.ba34					LCLLowerCase:
.ba34	c9 41		cmp #$41			cmp 	#"A"
.ba36	90 06		bcc $ba3e			bcc 	_LCLLCOut
.ba38	c9 5b		cmp #$5b			cmp 	#"Z"+1
.ba3a	b0 02		bcs $ba3e			bcs 	_LCLLCOut
.ba3c	69 20		adc #$20			adc 	#$20
.ba3e					_LCLLCOut:
.ba3e	60		rts				rts
.ba3f					LCLUpperCase:
.ba3f	c9 61		cmp #$61			cmp 	#"a"
.ba41	90 06		bcc $ba49			bcc 	_LCLUCOut
.ba43	c9 7b		cmp #$7b			cmp 	#"z"+1
.ba45	b0 02		bcs $ba49			bcs 	_LCLUCOut
.ba47	e9 1f		sbc #$1f			sbc 	#$1F
.ba49					_LCLUCOut:
.ba49	60		rts				rts
.ba4a					LCLWriteNumberXA:
.ba4a	64 37		stz $37				stz 	zTemp0+1 					; index into digit table.
.ba4c					_LCLWNLoop1:
.ba4c	64 36		stz $36				stz 	zTemp0 						; subtraction count.
.ba4e					_LCLWNLoop2:
.ba4e	48		pha				pha 								; save initial LSB
.ba4f	38		sec				sec
.ba50	a4 37		ldy $37				ldy 	zTemp0+1 					; position in table.
.ba52	f9 83 ba	sbc $ba83,y			sbc 	_LCLWNTable,y
.ba55	48		pha				pha
.ba56	8a		txa				txa
.ba57	f9 84 ba	sbc $ba84,y			sbc 	_LCLWNTable+1,y
.ba5a	90 07		bcc $ba63			bcc 	_LCLWNUnderflow
.ba5c	e6 36		inc $36				inc 	zTemp0  					; subtracted one without borrow.
.ba5e	aa		tax				tax 								; update X
.ba5f	68		pla				pla 								; restore A
.ba60	7a		ply				ply 								; throw original
.ba61	80 eb		bra $ba4e			bra 	_LCLWNLoop2 				; try again.
.ba63					_LCLWNUnderflow:
.ba63	a4 36		ldy $36				ldy 	zTemp0 						; count of subtractions.
.ba65	d0 06		bne $ba6d			bne 	_LCLWNOut
.ba67	ad 1d 04	lda $041d			lda 	tbOffset 					; suppress leading zeroes
.ba6a	3a		dec a				dec 	a
.ba6b	f0 04		beq $ba71			beq 	_LCLWNNext
.ba6d					_LCLWNOut:
.ba6d	98		tya				tya
.ba6e	20 7d ba	jsr $ba7d			jsr 	_LCLWNOutDigit
.ba71					_LCLWNNext:
.ba71	7a		ply				ply 							 	; restore original value.
.ba72	68		pla				pla
.ba73	a4 37		ldy $37				ldy 	zTemp0+1  					; bump the index
.ba75	c8		iny				iny
.ba76	c8		iny				iny
.ba77	84 37		sty $37				sty 	zTemp0+1
.ba79	c0 08		cpy #$08			cpy 	#8 							; done all 4
.ba7b	d0 cf		bne $ba4c			bne 	_LCLWNLoop1
.ba7d					_LCLWNOutDigit:
.ba7d	09 30		ora #$30			ora 	#'0'
.ba7f	20 e2 b9	jsr $b9e2			jsr 	LCLWrite
.ba82	60		rts				rts
.ba83					_LCLWNTable:
>ba83	10 27						.word 	10000
>ba85	e8 03						.word 	1000
>ba87	64 00						.word 	100
>ba89	0a 00						.word 	10
.ba8b					TOKSearchTable:
.ba8b	84 37		sty $37				sty 	zTemp0+1 					; (zTemp0),y points to current token being tested.
.ba8d	85 36		sta $36				sta 	zTemp0
.ba8f	a0 00		ldy #$00			ldy 	#0
.ba91	a9 80		lda #$80			lda 	#$80 						; token # so we know which one we are looking at
.ba93	85 38		sta $38				sta 	zTemp1
.ba95					_TSTLoop:
.ba95	b1 36		lda ($36),y			lda 	(zTemp0),y 					; length, 0 (skip) -ve (end)
.ba97	30 49		bmi $bae2			bmi 	_TSTFail 					; -ve = end of table, so fail.
.ba99	f0 2e		beq $bac9			beq 	_TSTNext 					; zero, check next as it's a dummy (e.g. EOL, SHIFT)
.ba9b	c8		iny				iny 								; get the hash
.ba9c	b1 36		lda ($36),y			lda 	(zTemp0),y
.ba9e	88		dey				dey
.ba9f	cd 03 04	cmp $0403			cmp 	identHash 					; check they match with the identifier hash, if not go to next
.baa2	d0 25		bne $bac9			bne 	_TSTNext
.baa4	ad 02 04	lda $0402			lda 	identTypeEnd 				; get length of identifier from end-start
.baa7	38		sec				sec
.baa8	ed 00 04	sbc $0400			sbc 	identStart
.baab	d1 36		cmp ($36),y			cmp 	(zTemp0),y 					; compare against the length in the table, no match, then return.
.baad	d0 1a		bne $bac9			bne 	_TSTNext
.baaf	5a		phy				phy 								; save Y , we might fail to match.
.bab0	c8		iny				iny 								; point to text
.bab1	c8		iny				iny
.bab2	ae 00 04	ldx $0400			ldx 	identStart 					; offset in line buffer in X
.bab5					_TSTCompareName:
.bab5	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; compare text.
.bab8	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.baba	d0 0c		bne $bac8			bne 	_TSTNextPullY 				; fail, pullY and do next
.babc	e8		inx				inx
.babd	c8		iny				iny
.babe	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; complete match.
.bac1	d0 f2		bne $bab5			bne 	_TSTCompareName
.bac3	7a		ply				ply 								; throw Y
.bac4	a5 38		lda $38				lda 	zTemp1 						; get token #
.bac6	38		sec				sec 								; return with CS = passed.
.bac7	60		rts				rts
.bac8					_TSTNextPullY:
.bac8	7a		ply				ply 								; restore current, fall through.
.bac9					_TSTNext:
.bac9	e6 38		inc $38				inc 	zTemp1 						; token counter
.bacb	98		tya				tya
.bacc	18		clc				clc
.bacd	71 36		adc ($36),y			adc 	(zTemp0),y 					; add [Length] + 2 to Y
.bacf	1a		inc a				inc 	a 							; +1
.bad0	1a		inc a				inc 	a 							; +2
.bad1	a8		tay				tay
.bad2	10 c1		bpl $ba95			bpl 	_TSTLoop 					; if Y < $80 loop back
.bad4	98		tya				tya 								; add Y to zTemp0 and reset Y
.bad5	a0 00		ldy #$00			ldy 	#0   						; so we can use Y to search fast
.bad7	18		clc				clc  								; but have tables > 255 bytes
.bad8	65 36		adc $36				adc 	zTemp0 						; when Y gets >= 128 we reset Y
.bada	85 36		sta $36				sta 	zTemp0 						; and adjust the table pointer/
.badc	90 b7		bcc $ba95			bcc 	_TSTLoop
.bade	e6 37		inc $37				inc 	zTemp0+1
.bae0	80 b3		bra $ba95			bra 	_TSTLoop
.bae2					_TSTFail:
.bae2	18		clc				clc
.bae3	60		rts				rts
.bae4					Export_TKTokeniseLine:
.bae4	20 6c bc	jsr $bc6c			jsr 	LCLFixLineBufferCase 		; fix line case
.bae7	a9 03		lda #$03			lda 	#3 							; reset the token buffer to empty
.bae9	8d 2a 04	sta $042a			sta 	tokenOffset 				; (3 bytes for line number & offset)
.baec	9c 2b 04	stz $042b			stz 	tokenLineNumber
.baef	9c 2c 04	stz $042c			stz 	tokenLineNumber+1
.baf2	a2 ff		ldx #$ff			ldx 	#$FF
.baf4					_TKFindFirst:
.baf4	e8		inx				inx
.baf5	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.baf8	f0 79		beq $bb73			beq 	_TKExit
.bafa	c9 20		cmp #$20			cmp 	#' '
.bafc	90 f6		bcc $baf4			bcc 	_TKFindFirst
.bafe	c9 30		cmp #$30			cmp 	#'0'
.bb00	90 07		bcc $bb09			bcc 	_TKNoLineNumber
.bb02	c9 3a		cmp #$3a			cmp 	#'9'+1
.bb04	b0 03		bcs $bb09			bcs 	_TKNoLineNumber
.bb06	20 96 bc	jsr $bc96			jsr 	TOKExtractLineNumber
.bb09					_TKNoLineNumber:
.bb09					_TKTokeniseLoop:
.bb09	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; next character, exit if zero EOL.
.bb0c	f0 65		beq $bb73			beq 	_TKExit
.bb0e	e8		inx				inx
.bb0f	c9 20		cmp #$20			cmp 	#' '
.bb11	f0 f6		beq $bb09			beq 	_TKTokeniseLoop 			; keep looping if space found.
.bb13	ca		dex				dex 								; undo last get, A contains character, X is position.
.bb14	c9 5f		cmp #$5f			cmp 	#'_'						; _ A-Z is identifier *or* token
.bb16	f0 61		beq $bb79			beq 	_TKTokeniseIdentifier 		; (already case converted outside string constants)
.bb18	c9 41		cmp #$41			cmp 	#'A'
.bb1a	90 04		bcc $bb20			bcc 	_TKTokenisePunctuation
.bb1c	c9 5b		cmp #$5b			cmp 	#'Z'+1
.bb1e	90 59		bcc $bb79			bcc 	_TKTokeniseIdentifier
.bb20					_TKTokenisePunctuation:
.bb20	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.bb22	f0 27		beq $bb4b			beq 	_TKString
.bb24	c9 24		cmp #$24			cmp 	#'$'						; hexadecimal constant ($ only appears at end of identifiers)
.bb26	f0 28		beq $bb50			beq 	_TKHexConstant
.bb28	c9 3c		cmp #$3c			cmp 	#'<' 						; check for < > handlers - these are for <> <= >= >> <<
.bb2a	f0 29		beq $bb55			beq 	_TKCheckDouble
.bb2c	c9 3e		cmp #$3e			cmp 	#'>'
.bb2e	f0 25		beq $bb55			beq 	_TKCheckDouble
.bb30					_TKStandardPunctuation:
.bb30	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get the punctuation token back.
.bb33	c9 40		cmp #$40			cmp 	#64 						; are we >= 64
.bb35	90 0e		bcc $bb45			bcc 	_TKNoShift
.bb37	48		pha				pha 								; save. we are about to convert this punctuation token from
.bb38	29 07		and #$07			and 	#7 							; lower 3 bits in zTemp0
.bb3a	85 36		sta $36				sta 	zTemp0
.bb3c	68		pla				pla
.bb3d	29 20		and #$20			and 	#32 						; bit 5
.bb3f	4a		lsr a				lsr 	a 							; shift into bit 3
.bb40	4a		lsr a				lsr 	a
.bb41	05 36		ora $36				ora 	zTemp0
.bb43	09 10		ora #$10			ora 	#$10						; now in the range 16-31
.bb45					_TKNoShift:
.bb45	20 db bc	jsr $bcdb			jsr 	TOKWriteByte 				; write the punctuation character
.bb48	e8		inx				inx 								; consume the character
.bb49	80 be		bra $bb09			bra 	_TKTokeniseLoop 			; and loop round again.
.bb4b					_TKString:
.bb4b	20 fb bb	jsr $bbfb			jsr 	TOKTokenString
.bb4e	80 b9		bra $bb09			bra 	_TKTokeniseLoop
.bb50					_TKHexConstant:
.bb50	20 36 bc	jsr $bc36			jsr 	TOKHexConstant
.bb53	80 b4		bra $bb09			bra 	_TKTokeniseLoop
.bb55					_TKCheckDouble:
.bb55	bd 2b 05	lda $052b,x			lda 	lineBuffer+1,x 				; get next character
.bb58	c9 3c		cmp #$3c			cmp 	#'<'						; if not < = > which are ASCII consecutive go back
.bb5a	90 d4		bcc $bb30			bcc 	_TKStandardPunctuation 		; and do the normal punctuation handler.
.bb5c	c9 3f		cmp #$3f			cmp 	#'>'+1
.bb5e	b0 d0		bcs $bb30			bcs 	_TKStandardPunctuation
.bb60	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; this is < (60) or > (62)
.bb63	29 02		and #$02			and 	#2 							; now < (0) or > (2)
.bb65	0a		asl a				asl 	a 							; now < (0) or > (4), CC also
.bb66	7d 2b 05	adc $052b,x			adc 	lineBuffer+1,x 				; add < = > codes - < code
.bb69	38		sec				sec
.bb6a	e9 3c		sbc #$3c			sbc 	#'<'
.bb6c	20 db bc	jsr $bcdb			jsr 	TOKWriteByte 				; this is in the range 0-7
.bb6f	e8		inx				inx 								; consume both
.bb70	e8		inx				inx
.bb71	80 96		bra $bb09			bra 	_TKTokeniseLoop
.bb73	a9 80		lda #$80	_TKExit:lda 	#KWC_EOL 					; write end of line byte
.bb75	20 db bc	jsr $bcdb			jsr 	TOKWriteByte
.bb78	60		rts				rts
.bb79					_TKTokeniseIdentifier:
.bb79	8e 00 04	stx $0400			stx 	identStart 					; save start
.bb7c	9c 04 04	stz $0404			stz 	identTypeByte 				; zero the type byte
.bb7f					_TKCheckLoop:
.bb7f	e8		inx				inx 								; look at next, we know first is identifier already.
.bb80	bd 2a 05	lda $052a,x			lda  	lineBuffer,x
.bb83	c9 5f		cmp #$5f			cmp 	#"_" 						; legal char _ 0-9 A-Z
.bb85	f0 f8		beq $bb7f			beq 	_TKCheckLoop
.bb87	c9 30		cmp #$30			cmp	 	#"0"
.bb89	90 0c		bcc $bb97			bcc 	_TKEndIdentifier
.bb8b	c9 3a		cmp #$3a			cmp 	#"9"+1
.bb8d	90 f0		bcc $bb7f			bcc 	_TKCheckLoop
.bb8f	c9 41		cmp #$41			cmp	 	#"A"
.bb91	90 04		bcc $bb97			bcc 	_TKEndIdentifier
.bb93	c9 5b		cmp #$5b			cmp 	#"Z"+1
.bb95	90 e8		bcc $bb7f			bcc 	_TKCheckLoop
.bb97					_TKEndIdentifier:
.bb97	8e 01 04	stx $0401			stx 	identTypeStart 				; save start of type text (if any !)
.bb9a	a0 08		ldy #$08			ldy 	#$08 						; this is the identifier type byte for #
.bb9c	c9 23		cmp #$23			cmp 	#"#"						; followed by #
.bb9e	f0 06		beq $bba6			beq 	_TKHasTypeCharacter
.bba0	a0 10		ldy #$10			ldy 	#$10 						; this is the identifier type byte for $
.bba2	c9 24		cmp #$24			cmp 	#"$"						; followed by $ or #
.bba4	d0 07		bne $bbad			bne 	_TKNoTypeCharacter
.bba6					_TKHasTypeCharacter:
.bba6	8c 04 04	sty $0404			sty 	identTypeByte 				; has # or $, save the type
.bba9	e8		inx				inx 								; consume the type character
.bbaa	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.bbad					_TKNoTypeCharacter:
.bbad	c9 28		cmp #$28			cmp 	#"("						; is it open parenthesis (e.g. array)
.bbaf	d0 09		bne $bbba			bne 	_TKNoArray
.bbb1	e8		inx				inx 								; skip the (
.bbb2	ad 04 04	lda $0404			lda 	identTypeByte 				; set bit 2 (e.g. array) in type byte
.bbb5	09 04		ora #$04			ora 	#$04
.bbb7	8d 04 04	sta $0404			sta 	identTypeByte
.bbba					_TKNoArray:
.bbba	8e 02 04	stx $0402			stx 	identTypeEnd 				; save end marker, e.g. continue from here.
.bbbd	20 57 bc	jsr $bc57			jsr 	TOKCalculateHash 			; calculate the has for those tokens
.bbc0	a0 b4		ldy #$b4			ldy 	#(KeywordSet0) >> 8
.bbc2	a9 7a		lda #$7a			lda 	#(KeywordSet0) & $FF
.bbc4	20 8b ba	jsr $ba8b			jsr 	TOKSearchTable
.bbc7	a2 00		ldx #$00			ldx 	#0
.bbc9	b0 1f		bcs $bbea			bcs 	_TKFoundToken
.bbcb	a0 b6		ldy #$b6			ldy 	#(KeywordSet1) >> 8
.bbcd	a9 91		lda #$91			lda 	#(KeywordSet1) & $FF
.bbcf	20 8b ba	jsr $ba8b			jsr 	TOKSearchTable
.bbd2	a2 81		ldx #$81			ldx 	#$81
.bbd4	b0 14		bcs $bbea			bcs 	_TKFoundToken
.bbd6	a0 b7		ldy #$b7			ldy 	#(KeywordSet2) >> 8
.bbd8	a9 04		lda #$04			lda 	#(KeywordSet2) & $FF
.bbda	20 8b ba	jsr $ba8b			jsr 	TOKSearchTable
.bbdd	a2 82		ldx #$82			ldx 	#$82
.bbdf	b0 09		bcs $bbea			bcs 	_TKFoundToken
.bbe1	20 e7 bc	jsr $bce7			jsr 	TOKCheckCreateVariableRecord ; failed all, it's a variable, create record if does not exist.
.bbe4	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.bbe7	4c 09 bb	jmp $bb09			jmp 	_TKTokeniseLoop 			; and go round again.
.bbea					_TKFoundToken:
.bbea	48		pha				pha 								; save token
.bbeb	8a		txa				txa 								; shift in X, is there one ?
.bbec	f0 03		beq $bbf1			beq 	_TKNoTShift
.bbee	20 db bc	jsr $bcdb			jsr 	TOKWriteByte 				; if so, write it out
.bbf1					_TKNoTShift:
.bbf1	68		pla				pla 								; restore and write token
.bbf2	20 db bc	jsr $bcdb			jsr 	TOKWriteByte
.bbf5	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.bbf8	4c 09 bb	jmp $bb09			jmp 	_TKTokeniseLoop 			; and go round again.
.bbfb					TOKTokenString:
.bbfb	a9 ff		lda #$ff			lda 	#KWC_STRING 				; string token.
.bbfd	20 db bc	jsr $bcdb			jsr 	TOKWriteByte
.bc00	e8		inx				inx									; start of quoted string.
.bc01	da		phx				phx 								; push start of string on top
.bc02	ca		dex				dex 								; because we pre-increment
.bc03					_TSFindEnd:
.bc03	e8		inx				inx
.bc04	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; next character
.bc07	f0 04		beq $bc0d			beq 	_TSEndOfString 				; no matching quote, we don't mind.
.bc09	c9 22		cmp #$22			cmp 	#'"' 						; go back if quote not found
.bc0b	d0 f6		bne $bc03			bne 	_TSFindEnd
.bc0d					_TSEndOfString:
.bc0d	7a		ply				ply  								; so now Y is first character, X is character after end.
.bc0e	48		pha				pha 								; save terminating character
.bc0f	20 17 bc	jsr $bc17			jsr 	TOKWriteBlockXY 			; write X to Y as a data block
.bc12	68		pla				pla 								; terminating character
.bc13	f0 01		beq $bc16			beq 	_TSNotQuote					; if it wasn't EOS skip it
.bc15	e8		inx				inx
.bc16					_TSNotQuote:
.bc16	60		rts				rts
.bc17					TOKWriteBlockXY:
.bc17	86 36		stx $36				stx 	zTemp0 						; save end character
.bc19	98		tya				tya 								; use 2's complement to work out the byte size
.bc1a	49 ff		eor #$ff			eor 	#$FF
.bc1c	38		sec				sec
.bc1d	65 36		adc $36				adc 	zTemp0
.bc1f	1a		inc a				inc 	a 							; one extra for NULL
.bc20	20 db bc	jsr $bcdb			jsr 	TOKWriteByte
.bc23					_TOBlockLoop:
.bc23	c4 36		cpy $36				cpy 	zTemp0 						; exit if reached the end
.bc25	f0 09		beq $bc30			beq 	_TOBlockExit
.bc27	b9 2a 05	lda $052a,y			lda 	lineBuffer,y 				; write byte out.
.bc2a	20 db bc	jsr $bcdb			jsr 	TOKWriteByte
.bc2d	c8		iny				iny
.bc2e	80 f3		bra $bc23			bra 	_TOBlockLoop
.bc30					_TOBlockExit:
.bc30	a9 00		lda #$00			lda 	#0 							; add NULL.
.bc32	20 db bc	jsr $bcdb			jsr 	TOKWriteByte
.bc35	60		rts				rts
.bc36					TOKHexConstant:
.bc36	a9 fe		lda #$fe			lda 	#KWC_HEXCONST 				; hex constant token.
.bc38	20 db bc	jsr $bcdb			jsr 	TOKWriteByte
.bc3b	e8		inx				inx									; start of quoted string.
.bc3c	da		phx				phx 								; push start of constant on top
.bc3d	ca		dex				dex
.bc3e					_THFindLoop:
.bc3e	e8		inx				inx 	 							; this is stored in a block, so find out how long
.bc3f	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; the hex constant is.
.bc42	c9 30		cmp #$30			cmp 	#"0"
.bc44	90 0c		bcc $bc52			bcc 	_THFoundEnd
.bc46	c9 3a		cmp #$3a			cmp 	#"9"+1
.bc48	90 f4		bcc $bc3e			bcc 	_THFindLoop
.bc4a	c9 41		cmp #$41			cmp 	#"A"
.bc4c	90 04		bcc $bc52			bcc 	_THFoundEnd
.bc4e	c9 47		cmp #$47			cmp 	#"F"+1
.bc50	90 ec		bcc $bc3e			bcc 	_THFindLoop
.bc52					_THFoundEnd:
.bc52	7a		ply				ply 								; restore start
.bc53	20 17 bc	jsr $bc17			jsr 	TOKWriteBlockXY 			; output the block
.bc56	60		rts				rts
.bc57					TOKCalculateHash:
.bc57	da		phx				phx
.bc58	ae 00 04	ldx $0400			ldx 	identStart 					; needs to be same as in tokens.py - simple sum at present.
.bc5b	a9 00		lda #$00			lda 	#0
.bc5d					_TCHLoop:
.bc5d	18		clc				clc
.bc5e	7d 2a 05	adc $052a,x			adc 	lineBuffer,x
.bc61	e8		inx				inx
.bc62	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; do the whole thing including type and array markers.
.bc65	d0 f6		bne $bc5d			bne 	_TCHLoop
.bc67	8d 03 04	sta $0403			sta 	identHash 					; save the hash
.bc6a	fa		plx				plx
.bc6b	60		rts				rts
.bc6c					LCLFixLineBufferCase:
.bc6c	a2 00		ldx #$00			ldx 	#0
.bc6e					_FLBCLoop:
.bc6e	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get next character
.bc71	f0 22		beq $bc95			beq 	_FLBCExit 					; end of string.
.bc73	c9 22		cmp #$22			cmp 	#'"'						; quote, go to in quotes
.bc75	f0 11		beq $bc88			beq 	_FLBCInQuotes
.bc77	e8		inx				inx
.bc78	c9 61		cmp #$61			cmp 	#'a'						; needs capitalising ?
.bc7a	90 f2		bcc $bc6e			bcc 	_FLBCLoop
.bc7c	c9 7b		cmp #$7b			cmp 	#'z'+1
.bc7e	b0 ee		bcs $bc6e			bcs 	_FLBCLoop
.bc80	38		sec				sec 								; make U/C
.bc81	e9 20		sbc #$20			sbc 	#32
.bc83	9d 29 05	sta $0529,x			sta	 	lineBuffer-1,x 				; write back
.bc86	80 e6		bra $bc6e			bra 	_FLBCLoop
.bc88					_FLBCInQuotes:
.bc88	e8		inx				inx 								; advance
.bc89	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get next
.bc8c	f0 07		beq $bc95			beq 	_FLBCExit 					; exit on EOS
.bc8e	c9 22		cmp #$22			cmp 	#'"' 				 		; until " found
.bc90	d0 f6		bne $bc88			bne 	_FLBCInQuotes
.bc92	e8		inx				inx 								; skip over it
.bc93	80 d9		bra $bc6e			bra 	_FLBCLoop
.bc95					_FLBCExit:
.bc95	60		rts				rts
.bc96					TOKExtractLineNumber:
.bc96	ad 2c 04	lda $042c			lda 	tokenLineNumber+1 			; push current value on stack
.bc99	48		pha				pha
.bc9a	ad 2b 04	lda $042b			lda 	tokenLineNumber
.bc9d	48		pha				pha
.bc9e	20 d4 bc	jsr $bcd4			jsr 	_LCLNTimes2 				; line # x 2
.bca1	20 d4 bc	jsr $bcd4			jsr 	_LCLNTimes2 				; line # x 4
.bca4	18		clc				clc 								; add stacked value
.bca5	68		pla				pla
.bca6	6d 2b 04	adc $042b			adc 	tokenLineNumber
.bca9	8d 2b 04	sta $042b			sta 	tokenLineNumber
.bcac	68		pla				pla
.bcad	6d 2c 04	adc $042c			adc 	tokenLineNumber+1
.bcb0	8d 2c 04	sta $042c			sta 	tokenLineNumber+1 			; line # x 5
.bcb3	20 d4 bc	jsr $bcd4			jsr 	_LCLNTimes2 				; line # x 10
.bcb6	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get and consume character
.bcb9	e8		inx				inx
.bcba	29 0f		and #$0f			and 	#15 						; add to line #
.bcbc	18		clc				clc
.bcbd	6d 2b 04	adc $042b			adc 	tokenLineNumber
.bcc0	8d 2b 04	sta $042b			sta 	tokenLineNumber
.bcc3	90 03		bcc $bcc8			bcc 	_TLENNoCarry
.bcc5	ee 2c 04	inc $042c			inc 	tokenLineNumber+1
.bcc8					_TLENNoCarry:
.bcc8	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; more digits ?
.bccb	c9 30		cmp #$30			cmp 	#'0'
.bccd	90 04		bcc $bcd3			bcc 	_TLENExit
.bccf	c9 3a		cmp #$3a			cmp 	#'9'+1
.bcd1	90 c3		bcc $bc96			bcc 	TOKExtractLineNumber
.bcd3					_TLENExit:
.bcd3	60		rts				rts
.bcd4					_LCLNTimes2:
.bcd4	0e 2b 04	asl $042b			asl 	tokenLineNumber 			; doubles tokenLineNumber.
.bcd7	2e 2c 04	rol $042c			rol 	tokenLineNumber+1
.bcda	60		rts				rts
.bcdb					TOKWriteByte:
.bcdb	da		phx				phx
.bcdc	ae 2a 04	ldx $042a			ldx 	tokenOffset 				; next slot to write to
.bcdf	9d 2a 04	sta $042a,x			sta 	tokenOffset,x 				; write byte out
.bce2	ee 2a 04	inc $042a			inc 	tokenOffset 				; advance slot.
.bce5	fa		plx				plx
.bce6	60		rts				rts
.bce7					TOKCheckCreateVariableRecord:
.bce7	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.bce9	85 36		sta $36				sta 	0+zTemp0
.bceb	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.bced	85 37		sta $37				sta 	1+zTemp0
.bcef					_CCVSearch:
.bcef	b2 36		lda ($36)			lda 	(zTemp0) 					; end of list
.bcf1	f0 2c		beq $bd1f			beq 	_CCVFail
.bcf3	a0 01		ldy #$01			ldy 	#1 							; read the hash
.bcf5	b1 36		lda ($36),y			lda 	(zTemp0),y 					; does it match ?
.bcf7	cd 03 04	cmp $0403			cmp 	identHash 	  				; if not, try the next.
.bcfa	d0 16		bne $bd12			bne 	_CCVNext
.bcfc	a0 08		ldy #$08			ldy 	#8 							; name in variable record
.bcfe	ae 00 04	ldx $0400			ldx 	identStart
.bd01					_CCVCompare:
.bd01	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; xor them. zero if the same, except
.bd04	51 36		eor ($36),y			eor 	(zTemp0),y 					; bit 7 is used for EOS.
.bd06	e8		inx				inx 								; advance pointers
.bd07	c8		iny				iny
.bd08	0a		asl a				asl 	a 							; A = 0 if they match, CS if end.
.bd09	d0 07		bne $bd12			bne 	_CCVNext  					; didn't match go to next.
.bd0b	90 f4		bcc $bd01			bcc 	_CCVCompare 				; not finished yet.
.bd0d	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; matched whole thing ?
.bd10	f0 41		beq $bd53			beq 	_CCVFound 					; yes, we were successful
.bd12					_CCVNext:
.bd12	18		clc				clc 								; go to next record.
.bd13	b2 36		lda ($36)			lda 	(zTemp0) 					; add offset to pointer
.bd15	65 36		adc $36				adc 	zTemp0
.bd17	85 36		sta $36				sta 	zTemp0
.bd19	90 d4		bcc $bcef			bcc 	_CCVSearch
.bd1b	e6 37		inc $37				inc 	zTemp0+1
.bd1d	80 d0		bra $bcef			bra 	_CCVSearch
.bd1f					_CCVFail:
.bd1f	a0 01		ldy #$01			ldy 	#1 							; create the new record. Offset 1 is hash
.bd21	ad 03 04	lda $0403			lda 	identHash
.bd24	91 36		sta ($36),y			sta 	(zTemp0),y
.bd26	c8		iny				iny 								; offset 2 is the type byte
.bd27	ad 04 04	lda $0404			lda 	identTypeByte
.bd2a	91 36		sta ($36),y			sta 	(zTemp0),y
.bd2c	c8		iny				iny
.bd2d					_CCVData:
.bd2d	a9 00		lda #$00			lda 	#0 							; erase data 3-7 (the 5 value bytes)
.bd2f	91 36		sta ($36),y			sta 	(zTemp0),y
.bd31	c8		iny				iny
.bd32	c0 08		cpy #$08			cpy 	#8
.bd34	90 f7		bcc $bd2d			bcc 	_CCVData
.bd36	ae 00 04	ldx $0400			ldx 	identStart 					; copy name into 8 on.
.bd39					_CCVCopyName:
.bd39	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.bd3c	91 36		sta ($36),y			sta 	(zTemp0),y
.bd3e	e8		inx				inx
.bd3f	c8		iny				iny
.bd40	ec 02 04	cpx $0402			cpx 	identTypeEnd
.bd43	d0 f4		bne $bd39			bne 	_CCVCopyName
.bd45	98		tya				tya 								; patch offset
.bd46	92 36		sta ($36)			sta 	(zTemp0)
.bd48	a9 00		lda #$00			lda 	#0 							; offset for next is zero.
.bd4a	91 36		sta ($36),y			sta 	(zTemp0),y
.bd4c	88		dey				dey
.bd4d	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set bit 7 of last bit
.bd4f	09 80		ora #$80			ora 	#$80
.bd51	91 36		sta ($36),y			sta 	(zTemp0),y
.bd53					_CCVFound:
.bd53	a5 37		lda $37				lda 	zTemp0+1 					; write out MSB
.bd55	38		sec				sec
.bd56	e9 10		sbc #$10			sbc 	#(VariableSpace >> 8) 		; offset from the start of the variable token
.bd58	09 40		ora #$40			ora 	#$40 						; make it a writeable token $4000-$7FFF
.bd5a	20 db bc	jsr $bcdb			jsr 	TOKWriteByte
.bd5d	a5 36		lda $36				lda 	zTemp0 						; write out LSB
.bd5f	20 db bc	jsr $bcdb			jsr 	TOKWriteByte
.bd62	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_sound.module

=1					soundIntegrated=1
.bd63					SNDCheckChannel:
.bd63	aa		tax				tax
.bd64	bd 38 08	lda $0838,x			lda 	SNDTimeLeft,x 				; currently playing a note
.bd67	d0 38		bne $bda1			bne 	_SNDCCExit
.bd69	da		phx				phx 								; save current channel
.bd6a	8a		txa				txa 								; put in A
.bd6b	20 e7 bd	jsr $bde7			jsr 	SNDFindNextNoteForA 		; is there a note for A in the queue ?
.bd6e	68		pla				pla 								; channel # in A
.bd6f	90 30		bcc $bda1			bcc 	_SNDCCExit  				; nothing in the queue for this channel, exit.
.bd71	a8		tay				tay 								; Y is the channel #
.bd72	bd 2d 07	lda $072d,x			lda 	SNDQueue+1,x 				; copy data into the slot.
.bd75	99 2c 08	sta $082c,y			sta 	SNDPitchLow,y
.bd78	bd 2e 07	lda $072e,x			lda 	SNDQueue+2,x
.bd7b	99 30 08	sta $0830,y			sta 	SNDPitchHigh,y
.bd7e	bd 2f 07	lda $072f,x			lda 	SNDQueue+3,x
.bd81	99 34 08	sta $0834,y			sta 	SNDVolume,y
.bd84	bd 30 07	lda $0730,x			lda 	SNDQueue+4,x
.bd87	99 38 08	sta $0838,y			sta 	SNDTimeLeft,y
.bd8a	bd 31 07	lda $0731,x			lda 	SNDQueue+5,x
.bd8d	99 3c 08	sta $083c,y			sta 	SNDAdjustLow,y
.bd90	bd 32 07	lda $0732,x			lda 	SNDQueue+6,x
.bd93	99 40 08	sta $0840,y			sta 	SNDAdjustHigh,y
.bd96	5a		phy				phy 								; save channel #
.bd97	20 01 be	jsr $be01			jsr 	SNDDeleteXFromQueue 		; delete record at X from queue
.bd9a	ce 2b 07	dec $072b			dec 	SNDLength 					; reduce the queue length.
.bd9d	68		pla				pla
.bd9e	20 a2 bd	jsr $bda2			jsr 	SNDUpdateNote 				; update channel A
.bda1					_SNDCCExit:
.bda1	60		rts				rts
.bda2					SNDUpdateNote:
.bda2	aa		tax				tax 								; so we can access records
.bda3	0a		asl a				asl 	a 							; convert it to a channel bit pair in 5,6
.bda4	0a		asl a				asl 	a
.bda5	0a		asl a				asl 	a
.bda6	0a		asl a				asl 	a
.bda7	0a		asl a				asl 	a
.bda8	8d 2a 07	sta $072a			sta 	SNDChannelBits
.bdab	bd 38 08	lda $0838,x			lda 	SNDTimeLeft,x 				; are we silent
.bdae	f0 2e		beq $bdde			beq 	_SNDUNIsSilent
.bdb0	ad 2a 07	lda $072a			lda 	SNDChannelBits 				; push channel bits on stack
.bdb3	48		pha				pha
.bdb4	bd 2c 08	lda $082c,x			lda 	SNDPitchLow,x 				; get 4 lowest bits of pitch.
.bdb7	29 0f		and #$0f			and 	#$0F
.bdb9	0d 2a 07	ora $072a			ora 	SNDChannelBits 				; set channel bits
.bdbc	09 80		ora #$80			ora 	#$80 						; write to pitch register
.bdbe	20 4b be	jsr $be4b			jsr 	SNDWritePorts
.bdc1	bd 30 08	lda $0830,x			lda 	SNDPitchHigh,x 				; pitch high => channel temp.
.bdc4	8d 2a 07	sta $072a			sta 	SNDChannelBits
.bdc7	bd 2c 08	lda $082c,x			lda 	SNDPitchLow,x
.bdca	4e 2a 07	lsr $072a			lsr 	SNDChannelBits 				; shift 2 LSBs into MSB of A
.bdcd	6a		ror a				ror 	a
.bdce	4e 2a 07	lsr $072a			lsr 	SNDChannelBits
.bdd1	6a		ror a				ror 	a
.bdd2	4a		lsr a				lsr 	a 							; put in bits 0-5
.bdd3	4a		lsr a				lsr 	a
.bdd4	20 4b be	jsr $be4b			jsr 	SNDWritePorts 				; write as rest of pitch register
.bdd7	68		pla				pla
.bdd8	09 90		ora #$90			ora 	#$90 						; set to write minimum attentuation.
.bdda	20 4b be	jsr $be4b			jsr 	SNDWritePorts
.bddd	60		rts				rts
.bdde					_SNDUNIsSilent:
.bdde	ad 2a 07	lda $072a			lda 	SNDChannelBits 				; channel bits
.bde1	09 9f		ora #$9f			ora 	#$9F 						; maximum attenuation
.bde3	20 4b be	jsr $be4b			jsr 	SNDWritePorts 				; write to the ports
.bde6	60		rts				rts
.bde7					SNDFindNextNoteForA:
.bde7	ac 2b 07	ldy $072b			ldy 	SNDLength 					; queue size into Y
.bdea	f0 13		beq $bdff			beq 	_SNDFNNFail 				; queue empty.
.bdec	a2 00		ldx #$00			ldx 	#0
.bdee					_SNDFNNSearch:
.bdee	dd 2c 07	cmp $072c,x			cmp 	SNDQueue,x 					; does it match the channel
.bdf1	38		sec				sec
.bdf2	f0 0c		beq $be00			beq 	_SNDFNNExit 				; if so exit with CS.
.bdf4	e8		inx				inx 								; next queue slot.
.bdf5	e8		inx				inx
.bdf6	e8		inx				inx
.bdf7	e8		inx				inx
.bdf8	e8		inx				inx
.bdf9	e8		inx				inx
.bdfa	e8		inx				inx
.bdfb	e8		inx				inx
.bdfc	88		dey				dey 								; done the whole queue
.bdfd	d0 ef		bne $bdee			bne 	_SNDFNNSearch 				; no, go back.
.bdff					_SNDFNNFail:
.bdff	18		clc				clc
.be00					_SNDFNNexit:
.be00	60		rts				rts
.be01					SNDDeleteXFromQueue:
.be01	e0 f8		cpx #$f8			cpx 	#SNDQueueSize*8-8 			; reached the end.
.be03	f0 09		beq $be0e			beq 	_SNDDXExit
.be05	bd 34 07	lda $0734,x			lda 	SNDQueue+8,x
.be08	9d 2c 07	sta $072c,x			sta 	SNDQueue,x
.be0b	e8		inx				inx
.be0c	80 f3		bra $be01			bra 	SNDDeleteXFromQueue
.be0e					_SNDDXExit:
.be0e	60		rts				rts
.072a					SNDChannelBits:
>072a							.fill 	1
.be0f					SNDQueueRequest:
.be0f	86 36		stx $36				stx 	zTemp0						; save queue address
.be11	84 37		sty $37				sty 	zTemp0+1
.be13	ae 2b 07	ldx $072b			ldx 	SNDLength 					; queue is full, can't take any more.
.be16	e0 20		cpx #$20			cpx 	#SNDQueueSize
.be18	f0 21		beq $be3b			beq 	_SNDQRExit
.be1a	29 03		and #$03			and 	#3	 						; channel # and push on stack
.be1c	48		pha				pha
.be1d	8a		txa				txa  								; get offset in queue buffer/
.be1e	0a		asl a				asl 	a
.be1f	0a		asl a				asl 	a
.be20	0a		asl a				asl 	a
.be21	aa		tax				tax
.be22	68		pla				pla 								; get back and push again
.be23	48		pha				pha
.be24	9d 2c 07	sta $072c,x			sta 	SNDQueue+0,x 				; save the channel #
.be27	a0 00		ldy #$00			ldy 	#0 							; copy the rest in.
.be29					_SNDQCopy:
.be29	b1 36		lda ($36),y			lda 	(zTemp0),y
.be2b	e8		inx				inx
.be2c	c8		iny				iny
.be2d	9d 2c 07	sta $072c,x			sta 	SNDQueue,x
.be30	c0 06		cpy #$06			cpy 	#6
.be32	d0 f5		bne $be29			bne 	_SNDQCopy
.be34	ee 2b 07	inc $072b			inc 	SNDLength 					; bump queue length.
.be37	68		pla				pla 								; get channel # back
.be38	20 63 bd	jsr $bd63			jsr 	SNDCheckChannel 			; check if channel needs refreshing.
.be3b					_SNDQRExit:
.be3b	60		rts				rts
.be3c					SNDSilenceChannel:
.be3c	aa		tax				tax 								; zero time left.
.be3d	9e 38 08	stz $0838,x			stz 	SNDTimeLeft,x
.be40	0a		asl a				asl 	a 							; shift into position
.be41	0a		asl a				asl 	a
.be42	0a		asl a				asl 	a
.be43	0a		asl a				asl 	a
.be44	0a		asl a				asl 	a
.be45	09 9f		ora #$9f			ora 	#$9F 						; write register attenuation $F
.be47	20 4b be	jsr $be4b			jsr 	SNDWritePorts
.be4a	60		rts				rts
.be4b					SNDWritePorts:
.be4b	da		phx				phx 								; save X
.be4c	a6 01		ldx $01				ldx 	1 							; save I/O status
.be4e	64 01		stz $01				stz 	1 							; access I/O page 0
.be50	8d 00 d6	sta $d600			sta 	$D600 						; write to both
.be53	8d 10 d6	sta $d610			sta 	$D610
.be56	86 01		stx $01				stx 	1 							; restore I/O
.be58	fa		plx				plx 								; restore X
.be59	60		rts				rts
.be5a					Export_SNDCommand:
.be5a	da		phx				phx 								; save XY
.be5b	5a		phy				phy
.be5c	c9 0f		cmp #$0f			cmp 	#$0F 						; $0F is initialise
.be5e	f0 1d		beq $be7d			beq 	_SNDInitialise
.be60	90 28		bcc $be8a			bcc 	_SNDExit
.be62	c9 3f		cmp #$3f			cmp 	#$3F 						; $3F is silence all
.be64	f0 17		beq $be7d			beq 	_SNDSilence
.be66	b0 22		bcs $be8a			bcs 	_SNDExit
.be68	c9 20		cmp #$20			cmp 	#$20 						; $2x is check playing => A
.be6a	b0 09		bcs $be75			bcs 	_SNDQueryPlay
.be6c	c9 14		cmp #$14			cmp 	#$14 						; $10-$13 is queue sound
.be6e	b0 1a		bcs $be8a			bcs 	_SNDExit
.be70	20 0f be	jsr $be0f			jsr 	SNDQueueRequest
.be73	80 15		bra $be8a			bra 	_SNDExit
.be75					_SNDQueryPlay:
.be75	29 03		and #$03			and 	#3 							; get channel #
.be77	aa		tax				tax
.be78	bd 38 08	lda $0838,x			lda 	SNDTimeLeft,x 				; read time left, if zero then silent
.be7b	80 0d		bra $be8a			bra 	_SNDExit
.be7d					_SNDInitialise:
.be7d					_SNDSilence:
.be7d	9c 2b 07	stz $072b			stz 	SNDLength 					; empty the queue.
.be80	a9 03		lda #$03			lda 	#$3 						; silence channel 0-3.
.be82					_SNDSilenceLoop:
.be82	48		pha				pha
.be83	20 3c be	jsr $be3c			jsr 	SNDSilenceChannel
.be86	68		pla				pla
.be87	3a		dec a				dec 	a
.be88	10 f8		bpl $be82			bpl 	_SNDSilenceLoop
.be8a					_SNDExit:
.be8a	7a		ply				ply
.be8b	fa		plx				plx
.be8c	60		rts				rts
=32					SNDQueueSize = 32 							; number of queue entries
.072b					SNDLength:
>072b							.fill 	1
.072c					SNDQueue:
>072c							.fill 	SNDQueueSize * 8
.082c					SNDPitchLow:
>082c							.fill 	4
.0830					SNDPitchHigh:
>0830							.fill 	4
.0834					SNDVolume:
>0834							.fill 	4
.0838					SNDTimeLeft:
>0838							.fill 	4
.083c					SNDAdjustLow:
>083c							.fill 	4
.0840					SNDAdjustHigh:
>0840							.fill 	4
.be8d					Export_SNDUpdate:
.be8d					PagedSNDUpdate:
.be8d	ad 38 08	lda $0838			lda 	SNDTimeLeft+0 				; look at time remaining
.be90	f0 05		beq $be97			beq 	_SNDUNot0 					; not playing
.be92	a2 00		ldx #$00			ldx 	#0 							; so we know which channel to update
.be94	20 b6 be	jsr $beb6			jsr 	SNDUpdateChannel 			; update it.
.be97					_SNDUNot0:
.be97	ad 39 08	lda $0839			lda 	SNDTimeLeft+1
.be9a	f0 05		beq $bea1			beq 	_SNDUNot1
.be9c	a2 01		ldx #$01			ldx 	#1
.be9e	20 b6 be	jsr $beb6			jsr 	SNDUpdateChannel
.bea1					_SNDUNot1:
.bea1	ad 3a 08	lda $083a			lda 	SNDTimeLeft+2
.bea4	f0 05		beq $beab			beq 	_SNDUNot2
.bea6	a2 02		ldx #$02			ldx 	#2
.bea8	20 b6 be	jsr $beb6			jsr 	SNDUpdateChannel
.beab					_SNDUNot2:
.beab	ad 3b 08	lda $083b			lda 	SNDTimeLeft+3
.beae	f0 05		beq $beb5			beq 	_SNDUNot3
.beb0	a2 03		ldx #$03			ldx 	#3
.beb2	20 b6 be	jsr $beb6			jsr 	SNDUpdateChannel
.beb5					_SNDUNot3:
.beb5	60		rts				rts
.beb6					SNDUpdateChannel:
.beb6	c9 ff		cmp #$ff			cmp 	#$FF 						; sound $FF play forever until turned off manually
.beb8	f0 2c		beq $bee6			beq 	_SNDUCExit
.beba	3a		dec a				dec 	a 							; decrement and update timer
.bebb	9d 38 08	sta $0838,x			sta 	SNDTimeLeft,x
.bebe	f0 1d		beq $bedd			beq 	_SNDUCUpdate 				; if zero, silence channel
.bec0	bd 3c 08	lda $083c,x			lda 	SNDAdjustLow,x 				; adjust ?
.bec3	1d 40 08	ora $0840,x			ora 	SNDAdjustHigh,x
.bec6	f0 1e		beq $bee6			beq 	_SNDUCExit 					; if zero carry on at current tone.
.bec8	18		clc				clc 								; add adjust, forcing into a 10 bit range
.bec9	bd 2c 08	lda $082c,x			lda 	SNDPitchLow,x
.becc	7d 3c 08	adc $083c,x			adc 	SNDAdjustLow,x
.becf	9d 2c 08	sta $082c,x			sta 	SNDPitchLow,x
.bed2	bd 30 08	lda $0830,x			lda 	SNDPitchHigh,x
.bed5	7d 40 08	adc $0840,x			adc 	SNDAdjustHigh,x
.bed8	29 03		and #$03			and 	#3
.beda	9d 30 08	sta $0830,x			sta 	SNDPitchHigh,x
.bedd					_SNDUCUpdate:
.bedd	8a		txa				txa 								; which channel.
.bede	48		pha				pha
.bedf	20 a2 bd	jsr $bda2			jsr 	SNDUpdateNote 				; update the current note
.bee2	68		pla				pla
.bee3	20 63 bd	jsr $bd63			jsr 	SNDCheckChannel 			; more to do ?
.bee6					_SNDUCExit:
.bee6	60		rts				rts

;******  Return to file: _basic.asm


;******  End of listing
