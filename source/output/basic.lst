
; 64tass Turbo Assembler Macro V1.57.2900 listing file
; 64tass -D AUTORUN=0 "-D MONITOR_ADDRESS=\$E000" "-D LOCKOUT_ADDRESS=\$F000" "-D BASIC_ADDRESS=\$38000" "-D SOURCE_ADDRESS=\$3000" "-D SPRITE_ADDRESS=\$30000" -q -b -Wall -c -D "HARDWARE=0 $'\x9'$'\x9'$'\x9'$'\x9'$'\x9'$'\x9'" -L output/basic.lst -l output/basic.lbl -Wall -o basic.rom _basic.asm
; Sat Nov 26 15:34:45 2022

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=0					AUTORUN=0
=$e000					 MONITOR_ADDRESS=$E000
=$f000					 LOCKOUT_ADDRESS=$F000
=$38000					 BASIC_ADDRESS=$38000
=$3000					 SOURCE_ADDRESS=$3000
=$30000					 SPRITE_ADDRESS=$30000
=0					HARDWARE=0

;******  Processing input file: _basic.asm


;******  Processing file: ./common/aa.system/01common.inc

=$30					ZeroPageMandatory = $30
=$50					ZeroPagePreference = $50
=$400					MemoryStorage = $400
=$2000					BasicStart = $2000
=$8000					BasicEnd = $8000
=$8000					CodeStart = $8000
=$1000					VariableSpace = $1000
=$2000					EndVariableSpace = $2000
=8					MathStackSize = 8
=512					BasicStackSize = 512
=3584					BasicStackBase = $1000-BasicStackSize
=80					MaxLineSize = 80

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/02macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/04data.inc

.0030					codePtr:
>0030							.fill 	4
.0034					basicStack:
>0034							.fill 	2
.0036					zTemp0:
>0036							.fill 	2
.0038					zTemp1:
>0038							.fill 	2
.003a					zTemp2:
>003a							.fill 	2
.003c					zsTemp:
>003c							.fill 	2
.003e					zaTemp:
>003e							.fill 	2
=$30					safePtr = codePtr 							; minimise direct tinkering
=$80					NSBIsNegative = $80 						; bit 7 : sign of mantissa (where numeric)
=$20					NSBIsReference = $20 						; bit 5 : is a reference
=$10					NSBIsString = $10 							; bit 4 : set if string (procedures don't go on the stack)
=$18					NSBTypeMask = $18 							; bits 4,3 : 00 int 01 float 10 string 11 procedure
=$03					NSBRefMask = $03 							; bits 0,1 : Bytes of reference, -1 (e.g. 00 = 1 byte, 11 = 4 bytes)
=$04					NSBIsArray = $04
=$00					NSTInteger = $00 							; base types for bits 3..4
=$08					NSTFloat = $08
=$10					NSTString = $10
=$18					NSTProcedure = $18
.0050					NSStatus:
>0050							.fill 	MathStackSize
.0058					NSMantissa0:
>0058							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0060					NSMantissa1:
>0060							.fill 	MathStackSize
.0068					NSMantissa2:
>0068							.fill 	MathStackSize
.0070					NSMantissa3:
>0070							.fill 	MathStackSize
.0078					NSExponent:
>0078							.fill 	MathStackSize
.0400					identStart:
>0400							.fill 	1
.0401					identTypeStart:
>0401							.fill 	1
.0402					identTypeEnd:
>0402							.fill 	1
.0403					identHash:
>0403							.fill 	1
.0404					identTypeByte:
>0404							.fill 	1	 						; (see tokenising.pdf)
.0405					encodeState:
>0405							.fill 	1
.0406					digitTemp:
>0406							.fill 	1
.0407					decimalCount:
>0407							.fill 	1
.0408					randomSeed:
>0408							.fill 	4
.040c					lowMemPtr:
>040c							.fill 	2
.040e					stringMemory:
>040e							.fill 	2
.0410					stringInitialised:
>0410							.fill 	1
.0411					stringTempPointer:
>0411							.fill 	2
.0413					breakCheck:
>0413							.fill 	1
.0414					decimalPlaces:
>0414							.fill 	1
.0415					dbOffset:
>0415							.fill 	1
.0416					lastParameter:
>0416							.fill 	1
.0417					dataPointer:
>0417							.fill 	5
.041c					inDataStatement:
>041c							.fill 	1
.041d					tbOffset:
>041d							.fill 	1
.041e					AssemblerAddress:
>041e							.fill 	2
.0420					AssemblerControl:
>0420							.fill 	1
.0421					ParamStart:
>0421							.fill 	2
.0423					IsGroup1:
>0423							.fill 	1
.0424					BaseOpcode:
>0424							.fill 	1
.0425					ModeMask:
>0425							.fill 	1
.0426					listIndent:
>0426							.fill 	1
.0427					lcLastCharacter:
>0427							.fill 	1
.0428					isInputFlag:
>0428							.fill 	1
.0429					currentListColour:
>0429							.fill 	1
.042a					tokenOffset:
>042a							.fill 	1
.042b					tokenLineNumber:
>042b							.fill 	2
.042d					tokenBuffer:
>042d							.fill 	253
.052a					lineBuffer:
>052a							.fill 	MaxLineSize+1
.057b					numberBuffer:
>057b							.fill 	34
.059d					decimalBuffer:
>059d							.fill 	16

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/constants.inc

=$80					AM_ISZP = $80
=$40					AM_ISG1 = $40
=$20					AM_ISG2 = $20
=224					AM_IMMEDIATE = AM_ISZP+AM_ISG1+AM_ISG2+$00
=228					AM_ZEROPAGE = AM_ISZP+AM_ISG1+AM_ISG2+$04
=40					AM_ACC = AM_ISG2+$08
=108					AM_ABS = AM_ISG1+AM_ISG2+$0C
=208					AM_INDY = AM_ISZP+AM_ISG1+$10
=244					AM_ZEROX = AM_ISZP+AM_ISG1+AM_ISG2+$14
=120					AM_ABSY = AM_ISG1+AM_ISG2+$18
=124					AM_ABSX = AM_ISG1+AM_ISG2+$1C
=209					AM_IND = AM_ISZP+AM_ISG1+$11
=$80					AM_ZEROY = AM_ISZP
=$01					AM_INDABS = $01
=$02					AM_INDABSX = $02
=192					AM_INDX = AM_ISZP+AM_ISG1+$00

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/handlers.inc


;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.inc

=1					ERRID_BREAK = 1
=2					ERRID_SYNTAX = 2
=3					ERRID_DIVZERO = 3
=4					ERRID_RANGE = 4
=5					ERRID_TYPE = 5
=6					ERRID_MEMORY = 6
=7					ERRID_ARGUMENT = 7
=8					ERRID_STOP = 8
=9					ERRID_STRING = 9
=10					ERRID_ASSERT = 10
=11					ERRID_DATA = 11
=12					ERRID_NOTDONE = 12
=13					ERRID_LINE = 13
=14					ERRID_GOSUB = 14
=15					ERRID_REPEAT = 15
=16					ERRID_WHILE = 16
=17					ERRID_FOR = 17
=18					ERRID_STACK = 18
=19					ERRID_STRUCT = 19
=20					ERRID_PROC = 20
=21					ERRID_REDEFINE = 21
=22					ERRID_ARRAYSIZE = 22
=23					ERRID_ARRAYIDX = 23

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst.inc

=$00					KWD_LESSLESS                         = $00; $00 <<
=$01					KWD_LESSEQUAL                        = $01; $01 <=
=$02					KWD_LESSGREATER                      = $02; $02 <>
=$03					KWD_PLINGPLING3                      = $03; $03 !!3
=$04					KWD_GREATERLESS                      = $04; $04 ><
=$05					KWD_GREATEREQUAL                     = $05; $05 >=
=$06					KWD_GREATERGREATER                   = $06; $06 >>
=$07					KWD_PLINGPLING7                      = $07; $07 !!7
=$08					KWD_PLINGPLING8                      = $08; $08 !!8
=$09					KWD_PLINGPLING9                      = $09; $09 !!9
=$0a					KWD_PLINGPLING10                     = $0a; $0a !!10
=$0b					KWD_PLINGPLING11                     = $0b; $0b !!11
=$0c					KWD_PLINGPLING12                     = $0c; $0c !!12
=$0d					KWD_PLINGPLING13                     = $0d; $0d !!13
=$0e					KWD_PLINGPLING14                     = $0e; $0e !!14
=$0f					KWD_PLINGPLING15                     = $0f; $0f !!15
=$10					KWD_AT                               = $10; $10 @
=$11					KWD_PLINGPLING17                     = $11; $11 !!17
=$12					KWD_PLINGPLING18                     = $12; $12 !!18
=$13					KWD_LSQPAREN                         = $13; $13 [
=$14					KWD_BACKSLASH                        = $14; $14 \
=$15					KWD_RSQPAREN                         = $15; $15 ]
=$16					KWD_HAT                              = $16; $16 ^
=$17					KWD_UNDERSCORE                       = $17; $17 _
=$18					KWD_BQUOTE                           = $18; $18 `
=$19					KWD_PLINGPLING25                     = $19; $19 !!25
=$1a					KWD_PLINGPLING26                     = $1a; $1a !!26
=$1b					KWD_LCURLY                           = $1b; $1b {
=$1c					KWD_BAR                              = $1c; $1c |
=$1d					KWD_RCURLY                           = $1d; $1d }
=$1e					KWD_TILDE                            = $1e; $1e ~
=$21					KWD_PLING                            = $21; $21 !
=$22					KWD_DQUOTE                           = $22; $22 "
=$23					KWD_HASH                             = $23; $23 #
=$24					KWD_DOLLAR                           = $24; $24 $
=$25					KWD_PERCENT                          = $25; $25 %
=$26					KWD_AMPERSAND                        = $26; $26 &
=$27					KWD_QUOTE                            = $27; $27 '
=$28					KWD_LPAREN                           = $28; $28 (
=$29					KWD_RPAREN                           = $29; $29 )
=$2a					KWD_STAR                             = $2a; $2a *
=$2b					KWD_PLUS                             = $2b; $2b +
=$2c					KWD_COMMA                            = $2c; $2c ,
=$2d					KWD_MINUS                            = $2d; $2d -
=$2e					KWD_PERIOD                           = $2e; $2e .
=$2f					KWD_SLASH                            = $2f; $2f /
=$30					KWD_0                                = $30; $30 0
=$31					KWD_1                                = $31; $31 1
=$32					KWD_2                                = $32; $32 2
=$33					KWD_3                                = $33; $33 3
=$34					KWD_4                                = $34; $34 4
=$35					KWD_5                                = $35; $35 5
=$36					KWD_6                                = $36; $36 6
=$37					KWD_7                                = $37; $37 7
=$38					KWD_8                                = $38; $38 8
=$39					KWD_9                                = $39; $39 9
=$3a					KWD_COLON                            = $3a; $3a :
=$3b					KWD_SEMICOLON                        = $3b; $3b ;
=$3c					KWD_LESS                             = $3c; $3c <
=$3d					KWD_EQUAL                            = $3d; $3d =
=$3e					KWD_GREATER                          = $3e; $3e >
=$3f					KWD_QMARK                            = $3f; $3f ?
=$83					KWD_ABSLPAREN                        = $83; $83 ABS(
=$84					KWD_ALLOCLPAREN                      = $84; $84 ALLOC(
=$85					KWD_ASCLPAREN                        = $85; $85 ASC(
=$86					KWD_CHRDOLLARLPAREN                  = $86; $86 CHR$(
=$87					KWD_EVENTLPAREN                      = $87; $87 EVENT(
=$88					KWD_FALSE                            = $88; $88 FALSE
=$89					KWD_FRACLPAREN                       = $89; $89 FRAC(
=$8a					KWD_HITLPAREN                        = $8a; $8a HIT(
=$8b					KWD_INTLPAREN                        = $8b; $8b INT(
=$8c					KWD_ISVALLPAREN                      = $8c; $8c ISVAL(
=$8d					KWD_JOYBLPAREN                       = $8d; $8d JOYB(
=$8e					KWD_JOYXLPAREN                       = $8e; $8e JOYX(
=$8f					KWD_JOYYLPAREN                       = $8f; $8f JOYY(
=$90					KWD_LEFTDOLLARLPAREN                 = $90; $90 LEFT$(
=$91					KWD_LENLPAREN                        = $91; $91 LEN(
=$92					KWD_MAXLPAREN                        = $92; $92 MAX(
=$93					KWD_MIDDOLLARLPAREN                  = $93; $93 MID$(
=$94					KWD_MINLPAREN                        = $94; $94 MIN(
=$95					KWD_NOTLPAREN                        = $95; $95 NOT(
=$96					KWD_PLAYINGLPAREN                    = $96; $96 PLAYING(
=$97					KWD_RANDOMLPAREN                     = $97; $97 RANDOM(
=$98					KWD_RIGHTDOLLARLPAREN                = $98; $98 RIGHT$(
=$99					KWD_RNDLPAREN                        = $99; $99 RND(
=$9a					KWD_SGNLPAREN                        = $9a; $9a SGN(
=$9b					KWD_SPCLPAREN                        = $9b; $9b SPC(
=$9c					KWD_STRDOLLARLPAREN                  = $9c; $9c STR$(
=$9d					KWD_TIMERLPAREN                      = $9d; $9d TIMER(
=$9e					KWD_TRUE                             = $9e; $9e TRUE
=$9f					KWD_VALLPAREN                        = $9f; $9f VAL(
=$a0					KWD_FOR                              = $a0; $a0 FOR
=$a1					KWD_IF                               = $a1; $a1 IF
=$a2					KWD_PROC                             = $a2; $a2 PROC
=$a3					KWD_REPEAT                           = $a3; $a3 REPEAT
=$a4					KWD_WHILE                            = $a4; $a4 WHILE
=$a5					KWD_ENDIF                            = $a5; $a5 ENDIF
=$a6					KWD_ENDPROC                          = $a6; $a6 ENDPROC
=$a7					KWD_NEXT                             = $a7; $a7 NEXT
=$a8					KWD_THEN                             = $a8; $a8 THEN
=$a9					KWD_UNTIL                            = $a9; $a9 UNTIL
=$aa					KWD_WEND                             = $aa; $aa WEND
=$ab					KWD_BY                               = $ab; $ab BY
=$ac					KWD_CALL                             = $ac; $ac CALL
=$ad					KWD_CIRCLE                           = $ad; $ad CIRCLE
=$ae					KWD_CLEAR                            = $ae; $ae CLEAR
=$af					KWD_CLS                              = $af; $af CLS
=$b0					KWD_COLOR                            = $b0; $b0 COLOR
=$b1					KWD_COLOUR                           = $b1; $b1 COLOUR
=$b2					KWD_DATA                             = $b2; $b2 DATA
=$b3					KWD_DIM                              = $b3; $b3 DIM
=$b4					KWD_DOWNTO                           = $b4; $b4 DOWNTO
=$b5					KWD_ELSE                             = $b5; $b5 ELSE
=$b6					KWD_FROM                             = $b6; $b6 FROM
=$b7					KWD_GFX                              = $b7; $b7 GFX
=$b8					KWD_GOSUB                            = $b8; $b8 GOSUB
=$b9					KWD_GOTO                             = $b9; $b9 GOTO
=$ba					KWD_HERE                             = $ba; $ba HERE
=$bb					KWD_IMAGE                            = $bb; $bb IMAGE
=$bc					KWD_INPUT                            = $bc; $bc INPUT
=$bd					KWD_LET                              = $bd; $bd LET
=$be					KWD_LINE                             = $be; $be LINE
=$bf					KWD_LOCAL                            = $bf; $bf LOCAL
=$c0					KWD_OFF                              = $c0; $c0 OFF
=$c1					KWD_ON                               = $c1; $c1 ON
=$c2					KWD_OUTLINE                          = $c2; $c2 OUTLINE
=$c3					KWD_PALETTE                          = $c3; $c3 PALETTE
=$c4					KWD_PLOT                             = $c4; $c4 PLOT
=$c5					KWD_PRINT                            = $c5; $c5 PRINT
=$c6					KWD_READ                             = $c6; $c6 READ
=$c7					KWD_RECT                             = $c7; $c7 RECT
=$c8					KWD_REM                              = $c8; $c8 REM
=$c9					KWD_RETURN                           = $c9; $c9 RETURN
=$ca					KWD_SOLID                            = $ca; $ca SOLID
=$cb					KWD_SOUND                            = $cb; $cb SOUND
=$cc					KWD_SPRITE                           = $cc; $cc SPRITE
=$cd					KWD_TEXT                             = $cd; $cd TEXT
=$ce					KWD_TO                               = $ce; $ce TO

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst0.inc

=$80					KWC_EOL = $80
=$ff					KWC_STRING = $FF
=$fe					KWC_HEXCONST = $FE
=$a0					KWC_FIRST_STRUCTURE = $a0
=$a5					KWC_FIRST_STRUCTURE_DEC = $a5
=$aa					KWC_LAST_STRUCTURE = $aa
=$83					KWC_FIRST_UNARY = $83
=$9f					KWC_LAST_UNARY = $9f

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/access.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/stack.inc

=$e0					STK_GOSUB = $E0
=$d0					STK_FOR = $D0
=$c0					STK_REPEAT = $C0
=$b0					STK_PROC = $B0
=$a0					STK_WHILE = $A0
=$01					STK_LOCALN = $01
=$02					STK_LOCALS = $02

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/00start.asm

.8000	a2 ff		ldx #$ff	Start:	ldx 	#$FF 						; stack reset
.8002	9a		txs				txs
.8003	20 38 a9	jsr $a938			jsr 	EXTInitialise 				; hardware initialise
.8006	a2 80		ldx #$80			ldx 	#(Prompt >> 8) 				; prompt display
.8008	a9 22		lda #$22			lda 	#(Prompt & $FF)
.800a	20 99 8e	jsr $8e99			jsr 	PrintStringXA
.800d	a9 00		lda #$00			lda 	#0 							; graphics system initialise.
.800f	aa		tax				tax
.8010	a8		tay				tay
.8011	20 c4 a9	jsr $a9c4			jsr 	GXGraphicDraw
.8014	a9 0f		lda #$0f			lda 	#$0F 						; initialise sound system
.8016	20 83 b8	jsr $b883			jsr 	SNDCommand
.8019	20 2e 89	jsr $892e			jsr 	NewProgram 					; erase current program
.801c	4c 6a 83	jmp $836a			jmp 	WarmStart					; make same size.
.801f	4c 6a 83	jmp $836a			jmp 	WarmStart
>8022	0c 2a 2a 2a 20 46 32 35		Prompt:	.text 	12,"*** F256 Junior SuperBASIC ***",13,13
>802a	36 20 4a 75 6e 69 6f 72 20 53 75 70 65 72 42 41
>803a	53 49 43 20 2a 2a 2a 0d 0d

;******  Processing file: ./common/aa.system/../generated/timestamp.asm

>8043	52 65 6c 65 61 73 65 20			.text "Release Alpha 5 (26-Nov-22). "
>804b	41 6c 70 68 61 20 35 20 28 32 36 2d 4e 6f 76 2d
>805b	32 32 29 2e 20

;******  Return to file: ./common/aa.system/00start.asm

>8060	0d 0d 00					.byte 	13,13,0

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/assembler.asm

.8063					AssembleGroup1:
.8063	a9 ff		lda #$ff			lda 	#$FF
.8065	8d 25 04	sta $0425			sta 	ModeMask 					; initialise the mode mask - all for all
.8068	80 02		bra $806c			bra 	AsmGroup12
.806a					AssembleGroup2:
.806a	a9 00		lda #$00			lda 	#$00
.806c					AsmGroup12:
.806c	8d 23 04	sta $0423			sta 	IsGroup1 					; save the 'group 1' flag
.806f	68		pla				pla 								; pop the return address to access the information following.
.8070	fa		plx				plx
.8071	20 f8 80	jsr $80f8			jsr 	AccessParameters 			; get opcode and save as base
.8074	8d 24 04	sta $0424			sta 	BaseOpcode
.8077	ad 23 04	lda $0423			lda 	IsGroup1 					; skip if group 1 as we don't have a complex mask.
.807a	d0 08		bne $8084			bne 	_AG12HaveMask
.807c	a9 02		lda #$02			lda 	#2 							; if group 2 the second parameter is the mask
.807e	20 00 81	jsr $8100			jsr 	GetParameter		 		; e.g. which modes are supported for this operand
.8081	8d 25 04	sta $0425			sta 	ModeMask
.8084					_AG12HaveMask:
.8084	20 34 82	jsr $8234			jsr 	TypeAndCalculateOperand 	; get zero page type
.8087	da		phx				phx 								; save found address mode
.8088	20 64 81	jsr $8164			jsr 	AssembleModeX
.808b	fa		plx				plx  								; restore address mode
.808c	b0 0b		bcs $8099			bcs 	_AG12Exit
.808e	20 9a 80	jsr $809a			jsr 	PromoteToAbsolute  			; promote ZP to ABS and try that
.8091	20 64 81	jsr $8164			jsr 	AssembleModeX
.8094	b0 03		bcs $8099			bcs 	_AG12Exit
.8096	4c c8 9e	jmp $9ec8			jmp 	SyntaxError 				; can't do either, so must be wrong mode/operand.
.8099					_AG12Exit:
.8099	60		rts				rts
.809a					PromoteToAbsolute:
.809a	a9 6c		lda #$6c			lda 	#AM_ABS 					; lda xx
.809c	e0 e4		cpx #$e4			cpx 	#AM_ZEROPAGE
.809e	f0 19		beq $80b9			beq 	_PTADo
.80a0	a9 7c		lda #$7c			lda 	#AM_ABSX 					; lda xx,X
.80a2	e0 f4		cpx #$f4			cpx 	#AM_ZEROX
.80a4	f0 13		beq $80b9			beq 	_PTADo
.80a6	a9 78		lda #$78			lda 	#AM_ABSY 					; lda xx,Y
.80a8	e0 80		cpx #$80			cpx 	#AM_ZEROY
.80aa	f0 0d		beq $80b9			beq 	_PTADo
.80ac	a9 01		lda #$01			lda 	#AM_INDABS 					; lda (xx) (jump)
.80ae	e0 d1		cpx #$d1			cpx 	#AM_IND
.80b0	f0 07		beq $80b9			beq 	_PTADo
.80b2	a9 02		lda #$02			lda 	#AM_INDABSX 				; lda (xx,x) (jump)
.80b4	e0 c0		cpx #$c0			cpx 	#AM_INDX
.80b6	f0 01		beq $80b9			beq 	_PTADo
.80b8	60		rts				rts
.80b9					_PTADo:
.80b9	aa		tax				tax
.80ba	60		rts				rts
.80bb					AssembleGroup3:
.80bb	68		pla				pla 								; get parameters, which is just the opcode.
.80bc	fa		plx				plx
.80bd	20 f8 80	jsr $80f8			jsr 	AccessParameters 			; get and output opcode
.80c0	20 10 81	jsr $8110			jsr 	AssemblerWriteByte
.80c3	20 98 82	jsr $8298			jsr 	CalculateOperand 			; get a 16 bit operand
.80c6	a5 58		lda $58				lda 	NSMantissa0 				; calculate the offset
.80c8	38		sec				sec
.80c9	ed 1e 04	sbc $041e			sbc 	AssemblerAddress
.80cc	48		pha				pha 								; LSB in A
.80cd	a5 60		lda $60				lda 	NSMantissa1
.80cf	ed 1f 04	sbc $041f			sbc 	AssemblerAddress+1
.80d2	aa		tax				tax 								; MSB in X
.80d3	68		pla				pla
.80d4	18		clc				clc 								; $80 to easy check $80-$7F, plus 1 for offset error
.80d5	69 7f		adc #$7f			adc 	#$7F
.80d7	90 01		bcc $80da			bcc 	_AG3NoCarry
.80d9	e8		inx				inx
.80da					_AG3NoCarry:
.80da	38		sec				sec 								; fix back and write out anyways.
.80db	e9 80		sbc #$80			sbc 	#$80
.80dd	20 10 81	jsr $8110			jsr 	AssemblerWriteByte
.80e0	e0 00		cpx #$00			cpx 	#0 							; was it in range
.80e2	f0 0a		beq $80ee			beq 	_AG3Exit
.80e4	ad 20 04	lda $0420			lda 	AssemblerControl 			; are we allowing bad values ?
.80e7	29 01		and #$01			and 	#1
.80e9	f0 03		beq $80ee			beq 	_AG3Exit
.80eb	4c cd 9e	jmp $9ecd			jmp 	RangeError 					; no, branch is out of range
.80ee					_AG3Exit:
.80ee	60		rts				rts
.80ef					AssembleGroup4:
.80ef	68		pla				pla 								; pop address
.80f0	fa		plx				plx
.80f1	20 f8 80	jsr $80f8			jsr 	AccessParameters 			; access and get first
.80f4	20 10 81	jsr $8110			jsr 	AssemblerWriteByte 			; output it.
.80f7	60		rts				rts
.80f8					AccessParameters:
.80f8	8d 21 04	sta $0421			sta 	ParamStart
.80fb	8e 22 04	stx $0422			stx 	ParamStart+1
.80fe	a9 01		lda #$01			lda 	#1
.8100					GetParameter:
.8100	5a		phy				phy
.8101	a8		tay				tay
.8102	ad 21 04	lda $0421			lda 	ParamStart
.8105	85 36		sta $36				sta 	zTemp0
.8107	ad 22 04	lda $0422			lda 	ParamStart+1
.810a	85 37		sta $37				sta 	zTemp0+1
.810c	b1 36		lda ($36),y			lda 	(zTemp0),y
.810e	7a		ply				ply
.810f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/aswrite.asm

.8110					AssemblerWriteByte:
.8110	48		pha			pha
.8111	ad 20 04	lda $0420		lda 	AssemblerControl 				; check printing bytes ?
.8114	29 02		and #$02		and 	#2
.8116	f0 1b		beq $8133		beq 	_AWBNoPrint
.8118	ad 1f 04	lda $041f		lda		AssemblerAddress+1 				; print address
.811b	20 4e 81	jsr $814e		jsr 	PrintHex
.811e	ad 1e 04	lda $041e		lda		AssemblerAddress
.8121	20 4e 81	jsr $814e		jsr 	PrintHex
.8124	a9 20		lda #$20		lda 	#' '
.8126	20 c4 a6	jsr $a6c4		jsr 	EXTPrintCharacter
.8129	68		pla			pla 									; print byte
.812a	48		pha			pha
.812b	20 4e 81	jsr $814e		jsr 	PrintHex
.812e	a9 0d		lda #$0d		lda 	#13
.8130	20 c4 a6	jsr $a6c4		jsr 	EXTPrintCharacter
.8133					_AWBNoPrint:
.8133	ad 1e 04	lda $041e		lda		AssemblerAddress				; copy address to zTemp0
.8136	85 36		sta $36			sta 	zTemp0
.8138	ad 1f 04	lda $041f		lda		AssemblerAddress+1
.813b	f0 0e		beq $814b		beq 	_AWBRange
.813d	85 37		sta $37			sta 	zTemp0+1
.813f	68		pla			pla 									; write byte out
.8140	92 36		sta ($36)		sta 	(zTemp0)
.8142	ee 1e 04	inc $041e		inc 	AssemblerAddress 				; bump address
.8145	d0 03		bne $814a		bne 	_AWBNoCarry
.8147	ee 1f 04	inc $041f		inc 	AssemblerAddress+1
.814a					_AWBNoCarry:
.814a	60		rts			rts
.814b					_AWBRange:
.814b	4c cd 9e	jmp $9ecd		jmp 	RangeError
.814e					PrintHex:
.814e	48		pha				pha
.814f	4a		lsr a				lsr 	a
.8150	4a		lsr a				lsr 	a
.8151	4a		lsr a				lsr 	a
.8152	4a		lsr a				lsr 	a
.8153	20 57 81	jsr $8157			jsr 	_PrintNibble
.8156	68		pla				pla
.8157					_PrintNibble:
.8157	29 0f		and #$0f			and 	#15
.8159	c9 0a		cmp #$0a			cmp 	#10
.815b	90 02		bcc $815f			bcc 	_NoShift
.815d	69 06		adc #$06			adc 	#6
.815f					_NoShift:
.815f	69 30		adc #$30			adc 	#48
.8161	4c c4 a6	jmp $a6c4			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/instruction.asm

.8164					AssembleModeX:
.8164	5a		phy				phy
.8165	ad 23 04	lda $0423			lda 	IsGroup1
.8168	f0 17		beq $8181			beq 	_AMXGroup2
.816a	8a		txa				txa 							; is it in group # 1
.816b	29 40		and #$40			and 	#AM_ISG1
.816d	f0 4d		beq $81bc			beq 	_AMXFail 				; no, give up.
.816f	8a		txa				txa 							; get back.
.8170	29 1f		and #$1f			and 	#$1F 					; this is now the offset.
.8172	e0 e0		cpx #$e0			cpx 	#AM_IMMEDIATE 			; if not immediate, we can continue.
.8174	d0 22		bne $8198			bne 	_AMXHaveInfo
.8176	ad 24 04	lda $0424			lda 	BaseOpcode 				; cannot store immediate.
.8179	c9 81		cmp #$81			cmp 	#$81
.817b	f0 3f		beq $81bc			beq 	_AMXFail
.817d	a9 08		lda #$08			lda 	#8 						; if immediate we use offset 8.
.817f	80 17		bra $8198			bra 	_AMXHaveInfo 			; odd design decision there.
.8181					_AMXGroup2:
.8181	8a		txa				txa 							; is it in group 2 ?
.8182	29 20		and #$20			and 	#AM_ISG2
.8184	f0 36		beq $81bc			beq 	_AMXFail 				; no, give up.
.8186	8a		txa				txa 							; get the offset into Y
.8187	29 1f		and #$1f			and 	#$1F
.8189	4a		lsr a				lsr 	a 						; make it 0-7.
.818a	4a		lsr a				lsr  	a
.818b	a8		tay				tay
.818c	ad 25 04	lda $0425			lda 	ModeMask 				; shift the modemask left so you can check it against the requested offset
.818f					_AMXCheckOkay:
.818f	0a		asl a				asl 	a 						; shift modemask left enough times to check legitimate.
.8190	88		dey				dey
.8191	10 fc		bpl $818f			bpl 	_AMXCheckOkay
.8193	90 27		bcc $81bc			bcc 	_AMXFail 				; not allowed.
.8195	8a		txa				txa  							; get mask back
.8196	29 1f		and #$1f			and 	#$1F
.8198					_AMXHaveInfo:
.8198	e0 00		cpx #$00			cpx 	#$00 					; does it *require* an 8 bit operand
.819a	10 04		bpl $81a0			bpl 	_AMXAnySize 			; checking bit 7, the zero page opcode flag.
.819c	a4 60		ldy $60				ldy 	NSMantissa1 			; fail if it is outside range, e.g. the MSB is set.
.819e	d0 1c		bne $81bc			bne 	_AMXFail
.81a0					_AMXAnySize:
.81a0	18		clc				clc 							; add offset to the base opcode
.81a1	6d 24 04	adc $0424			adc 	BaseOpcode
.81a4					_AMXOutputCode:
.81a4	20 10 81	jsr $8110			jsr 	AssemblerWriteByte 		; write the opcode out.
.81a7	e0 28		cpx #$28			cpx 	#AM_ACC 				; A mode (e.g. ASL A)
.81a9	f0 0e		beq $81b9			beq 	_AMXExit
.81ab	a5 58		lda $58				lda 	NSMantissa0 				; write LSB operand
.81ad	20 10 81	jsr $8110			jsr 	AssemblerWriteByte
.81b0	e0 00		cpx #$00			cpx 	#$00 					; zeropage ?
.81b2	30 05		bmi $81b9			bmi 	_AMXExit
.81b4	a5 60		lda $60				lda 	NSMantissa1 			; write MSB operand
.81b6	20 10 81	jsr $8110			jsr 	AssemblerWriteByte
.81b9					_AMXExit:
.81b9	7a		ply				ply
.81ba	38		sec				sec
.81bb	60		rts				rts
.81bc					_AMXFail:
.81bc	a0 00		ldy #$00			ldy 	#0
.81be					_AMXCheckOddities:
.81be	8a		txa				txa
.81bf	d9 e6 81	cmp $81e6,y			cmp 	ExtraOpcode+2,y 		; match address mode
.81c2	d0 15		bne $81d9			bne 	_AMXCONext
.81c4	b9 e4 81	lda $81e4,y			lda 	ExtraOpcode+0,y 		; do the base opcodes match
.81c7	cd 24 04	cmp $0424			cmp 	BaseOpcode
.81ca	d0 0d		bne $81d9			bne 	_AMXCONext
.81cc	e0 00		cpx #$00			cpx 	#$00 					; requires zero page ?
.81ce	10 04		bpl $81d4			bpl 	_AMXCONotZero
.81d0	a5 60		lda $60				lda 	NSMantissa1
.81d2	d0 05		bne $81d9			bne 	_AMXCONext
.81d4					_AMXCONotZero:
.81d4	b9 e5 81	lda $81e5,y			lda 	ExtraOpcode+1,y 		; get new opcode
.81d7	80 cb		bra $81a4			bra 	_AMXOutputCode 			; and assemble it
.81d9					_AMXCONext:
.81d9	c8		iny				iny
.81da	c8		iny				iny
.81db	c8		iny				iny
.81dc	b9 e4 81	lda $81e4,y			lda 	ExtraOpcode+0,y 		; end of table
.81df	d0 dd		bne $81be			bne 	_AMXCheckOddities
.81e1					_AMXCOFail:
.81e1	7a		ply				ply
.81e2	18		clc				clc
.81e3	60		rts				rts
.81e4					ExtraOpcode:
>81e4	40 6c 01					.byte $40,$6c,AM_INDABS 	; jmp
>81e7	40 7c 02					.byte $40,$7C,AM_INDABSX 	; jmp
>81ea	a2 be 78					.byte $a2,$BE,AM_ABSY 		; ldx
>81ed	a2 b6 80					.byte $a2,$B6,AM_ZEROY 		; ldx
>81f0	82 96 80					.byte $82,$96,AM_ZEROY 		; stx
>81f3	e2 1a 28					.byte $e2,$1a,AM_ACC 		; inc
>81f6	c2 3a 28					.byte $c2,$3a,AM_ACC 		; dec
>81f9	20 89 e0					.byte $20,$89,AM_IMMEDIATE 	; bit
>81fc	60 9c 6c					.byte $60,$9c,AM_ABS 		; stz
>81ff	60 9e 7c					.byte $60,$9e,AM_ABSX 		; stz
>8202	00						.byte $00

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/label.asm

.8203					LabelHere:
.8203	c8		iny				iny 								; skip .
.8204	a2 00		ldx #$00			ldx 	#0 							; get a term
.8206	20 8e 97	jsr $978e			jsr 	EvaluateTerm 				; get a term
.8209	a5 50		lda $50				lda 	NSStatus 					; needs to be an integer reference.
.820b	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.820d	d0 22		bne $8231			bne 	_ALType
.820f	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy reference address to zTemp0
.8211	85 36		sta $36				sta 	zTemp0
.8213	b5 60		lda $60,x			lda 	NSMantissa1,x
.8215	85 37		sta $37				sta 	zTemp0+1
.8217	5a		phy				phy 								; copy address in.
.8218	a0 01		ldy #$01			ldy 	#1
.821a	ad 1e 04	lda $041e			lda	 	AssemblerAddress
.821d	92 36		sta ($36)			sta 	(zTemp0)
.821f	ad 1f 04	lda $041f			lda	 	AssemblerAddress+1
.8222	91 36		sta ($36),y			sta 	(zTemp0),y
.8224	c8		iny				iny
.8225	a9 00		lda #$00			lda 	#0
.8227	91 36		sta ($36),y			sta 	(zTemp0),y
.8229	c8		iny				iny
.822a	91 36		sta ($36),y			sta 	(zTemp0),y
.822c	c8		iny				iny
.822d	91 36		sta ($36),y			sta 	(zTemp0),y
.822f	7a		ply				ply
.8230	60		rts				rts
.8231					_ALType:
.8231	4c d2 9e	jmp $9ed2			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/operands.asm

.8234					TypeAndCalculateOperand:
.8234	b1 30		lda ($30),y			lda 	(codePtr),y
.8236	a2 28		ldx #$28			ldx 	#AM_ACC 					; ACC if : or EOL
.8238	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.823a	f0 5b		beq $8297			beq 	_TACOExit
.823c	c9 80		cmp #$80			cmp 	#KWC_EOL
.823e	f0 57		beq $8297			beq 	_TACOExit
.8240	c8		iny				iny
.8241	a2 e0		ldx #$e0			ldx 	#AM_IMMEDIATE
.8243	c9 23		cmp #$23			cmp 	#KWD_HASH 					; if hash, then immediate - constant.
.8245	f0 51		beq $8298			beq 	CalculateOperand
.8247	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; if ( then check for indirection
.8249	f0 1f		beq $826a			beq 	_TACOIndirect
.824b	88		dey				dey 								; undo get of first character
.824c	20 98 82	jsr $8298			jsr 	CalculateOperand 			; get operand
.824f	b1 30		lda ($30),y			lda 	(codePtr),y
.8251	a2 e4		ldx #$e4			ldx 	#AM_ZEROPAGE 				; if not, try zero page (then absolute)
.8253	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8255	d0 40		bne $8297			bne 	_TACOExit
.8257	c8		iny				iny
.8258	20 a2 82	jsr $82a2			jsr 	TACOCheckXY 				; extract X,Y or 0 (neither) from the variable.
.825b	a2 f4		ldx #$f4			ldx 	#AM_ZEROX 					; check for X
.825d	c9 58		cmp #$58			cmp 	#'X'
.825f	f0 36		beq $8297			beq 	_TACOExit
.8261	a2 80		ldx #$80			ldx 	#AM_ZEROY 					; check for Y
.8263	c9 59		cmp #$59			cmp 	#'Y'
.8265	f0 30		beq $8297			beq 	_TACOExit
.8267					_TACOSyntax:
.8267	4c c8 9e	jmp $9ec8			jmp 	SyntaxError
.826a					_TACOIndirect:
.826a	20 98 82	jsr $8298			jsr 	CalculateOperand 			; get the operand
.826d	b1 30		lda ($30),y			lda 	(codePtr),y
.826f	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if , then it must be ,X)
.8271	f0 17		beq $828a			beq 	_TACOIndX
.8273	20 27 8e	jsr $8e27			jsr 	CheckRightBracket  			; otherwise must be ) or ),Y
.8276	b1 30		lda ($30),y			lda 	(codePtr),y
.8278	a2 d1		ldx #$d1			ldx 	#AM_IND
.827a	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not comma then exit with (xx)
.827c	d0 19		bne $8297			bne 	_TACOExit
.827e	c8		iny				iny
.827f	20 a2 82	jsr $82a2			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.8282	c9 59		cmp #$59			cmp 	#'Y' 						; check Y
.8284	d0 e1		bne $8267			bne 	_TACOSyntax
.8286	a2 d0		ldx #$d0			ldx 	#AM_INDY
.8288	80 0d		bra $8297			bra 	_TACOExit
.828a					_TACOIndX:
.828a	c8		iny				iny
.828b	20 a2 82	jsr $82a2			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.828e	c9 58		cmp #$58			cmp 	#'X' 						; check X
.8290	d0 d5		bne $8267			bne 	_TACOSyntax
.8292	20 27 8e	jsr $8e27			jsr 	CheckRightBracket			; check )
.8295	a2 c0		ldx #$c0			ldx 	#AM_INDX
.8297					_TACOExit:
.8297	60		rts				rts
.8298					CalculateOperand:
.8298	48		pha				pha
.8299	da		phx				phx
.829a	a2 00		ldx #$00			ldx 	#0 							; get 16 bit integer in Slot 0
.829c	20 d0 9c	jsr $9cd0			jsr 	Evaluate16BitInteger
.829f	fa		plx				plx
.82a0	68		pla				pla
.82a1	60		rts				rts
.82a2					TACOCheckXY:
.82a2	b1 30		lda ($30),y			lda 	(codePtr),y
.82a4	29 c0		and #$c0			and 	#$C0 						; check it is an identifier reference.
.82a6	c9 40		cmp #$40			cmp 	#$40
.82a8	d0 21		bne $82cb			bne 	_TCXYFail
.82aa	b1 30		lda ($30),y			lda 	(codePtr),y
.82ac	18		clc				clc
.82ad	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.82af	85 37		sta $37				sta 	zTemp0+1
.82b1	c8		iny				iny
.82b2	b1 30		lda ($30),y			lda 	(codePtr),y
.82b4	c8		iny				iny
.82b5	85 36		sta $36				sta 	zTemp0
.82b7	5a		phy				phy 								; save position
.82b8	a0 02		ldy #$02			ldy 	#2 							; type is integer ?
.82ba	b1 36		lda ($36),y			lda 	(zTemp0),y
.82bc	d0 0c		bne $82ca			bne 	_TCXYPopFail
.82be	a0 08		ldy #$08			ldy 	#8 							; get first character, should have bit 7 set as also last.
.82c0	b1 36		lda ($36),y			lda 	(zTemp0),y
.82c2	c9 d8		cmp #$d8			cmp 	#'X'+$80 					; should be X or Y
.82c4	f0 08		beq $82ce			beq 	_TCXYFound
.82c6	c9 d9		cmp #$d9			cmp 	#'Y'+$80
.82c8	f0 04		beq $82ce			beq 	_TCXYFound
.82ca					_TCXYPopFail:
.82ca	7a		ply				ply
.82cb					_TCXYFail:
.82cb	a9 00		lda #$00			lda 	#0
.82cd	60		rts				rts
.82ce					_TCXYFound:
.82ce	7a		ply				ply 								; restore position
.82cf	29 7f		and #$7f			and 	#$7F 						; throw bit 7
.82d1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/backload.asm

.82d2					BackloadProgram:
.82d2	a2 83		ldx #$83			ldx 	#_BLLoad >> 8
.82d4	a9 19		lda #$19			lda 	#_BLLoad & $FF
.82d6	20 99 8e	jsr $8e99			jsr 	PrintStringXA
.82d9	a9 00		lda #$00			lda 	#((SOURCE_ADDRESS) & $FF)
.82db	8d ad 05	sta $05ad			sta 	0+BackLoadPointer
.82de	a9 30		lda #$30			lda 	#((SOURCE_ADDRESS) >> 8)
.82e0	8d ae 05	sta $05ae			sta 	1+BackLoadPointer
.82e3	a9 ff		lda #$ff			lda 	#$FF
.82e5	8d fa ff	sta $fffa			sta 	$FFFA
.82e8					_BPLoop:
.82e8	a2 ff		ldx #$ff			ldx 	#$FF
.82ea	20 2e 83	jsr $832e			jsr 	BLReadByte 					; read a byte
.82ed	c9 00		cmp #$00			cmp 	#0
.82ef	f0 21		beq $8312			beq 	_BPExit 					; if 0 exit
.82f1	30 1f		bmi $8312			bmi 	_BPExit 					; if -ve exit
.82f3					_BPCopy:
.82f3	e8		inx				inx  								; copy byte into the lineBuffer
.82f4	9d 2a 05	sta $052a,x			sta 	lineBuffer,x
.82f7	9e 2b 05	stz $052b,x			stz 	lineBuffer+1,x
.82fa	20 2e 83	jsr $832e			jsr 	BLReadByte 					; read next byte
.82fd	30 0a		bmi $8309			bmi 	_BPEndLine 					; -ve = EOL
.82ff	c9 09		cmp #$09			cmp 	#9 							; handle TAB, make it space.
.8301	d0 02		bne $8305			bne 	_BPNotTab
.8303	a9 20		lda #$20			lda 	#' '
.8305					_BPNotTab:
.8305	c9 20		cmp #$20			cmp 	#' ' 						; < ' ' = EOL
.8307	b0 ea		bcs $82f3			bcs 	_BPCopy 					; until a control character, should be 13 received.
.8309					_BPEndLine:
.8309	20 02 b5	jsr $b502			jsr 	TokeniseLine 				; tokenise the line.
.830c	38		sec				sec 								; append not insert
.830d	20 12 a4	jsr $a412			jsr 	MemoryInsertLine 			; append to current program
.8310	80 d6		bra $82e8			bra 	_BPLoop
.8312					_BPExit:
.8312	9c fa ff	stz $fffa			stz 	$FFFA
.8315	20 00 84	jsr $8400			jsr 	ClearCommand 				; clear variables etc.
.8318	60		rts				rts
.8319					_BLLoad:
>8319	4c 6f 61 64 69 6e 67 20				.text 	"Loading from Memory",13,0
>8321	66 72 6f 6d 20 4d 65 6d 6f 72 79 0d 00
.832e					BLReadByte:
.832e	ad ad 05	lda $05ad			lda 	BackLoadPointer 			; copy pointer to zTemp0
.8331	85 36		sta $36				sta 	zTemp0
.8333	ad ae 05	lda $05ae			lda 	BackLoadPointer+1
.8336	85 37		sta $37				sta 	zTemp0+1
.8338	b2 36		lda ($36)			lda 	(zTemp0) 					; read next byte
.833a	ee ad 05	inc $05ad			inc 	BackLoadPointer 			; bump pointer
.833d	d0 03		bne $8342			bne 	_BLNoCarry
.833f	ee ae 05	inc $05ae			inc 	BackLoadPointer+1
.8342					_BLNoCarry:
.8342	c9 00		cmp #$00			cmp 	#0
.8344	60		rts				rts
.05ad					BackLoadPointer:
>05ad							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/editor.asm

.8345					EditProgramCode:
.8345	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; find the line.
.8348	ae 2c 04	ldx $042c			ldx 	TokenLineNumber+1
.834b	20 b6 a4	jsr $a4b6			jsr 	MemorySearch
.834e	90 05		bcc $8355			bcc 	_EPCNoDelete 				; reached the end don't delete
.8350	d0 03		bne $8355			bne 	_EPCNoDelete 				; found slot but didn't match, no delete
.8352	20 db a3	jsr $a3db			jsr 	MemoryDeleteLine 			; delete the line
.8355					_EPCNoDelete:
.8355	ad 2d 04	lda $042d			lda 	TokenBuffer 				; buffer empty
.8358	c9 80		cmp #$80			cmp 	#KWC_EOL
.835a	f0 0d		beq $8369			beq 	_EPCNoInsert
.835c	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; find the line - it cannot exist.
.835f	ae 2c 04	ldx $042c			ldx 	TokenLineNumber+1 			; so this can't fail, it returns some point in the code.
.8362	20 b6 a4	jsr $a4b6			jsr 	MemorySearch
.8365	18		clc				clc 								; insert at this point.
.8366	20 12 a4	jsr $a412			jsr 	MemoryInsertLine 			; insert the line
.8369					_EPCNoInsert:
.8369	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/warmstart.asm

.836a					WarmStart:
.836a	a2 ff		ldx #$ff			ldx 	#$FF
.836c	9a		txs				txs
.836d	a9 85		lda #$85			lda 	#CLICommandLine+$80 		; set console colour
.836f	20 c4 a6	jsr $a6c4			jsr 	EXTPrintCharacter
.8372	20 52 a8	jsr $a852			jsr 	EXTInputLine 				; get line to lineBuffer
.8375	20 02 b5	jsr $b502			jsr 	TokeniseLine 				; tokenise the line
.8378	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; line number ?
.837b	0d 2c 04	ora $042c			ora 	TokenLineNumber+1
.837e	d0 17		bne $8397			bne 	_WSEditCode 				; if so,edit code.
.8380	9c 2a 04	stz $042a			stz 	TokenOffset 				; zero offset, meaning it only runs one line.
.8383	a9 2a		lda #$2a			lda 	#((TokenOffset) & $FF)
.8385	85 30		sta $30				sta 	codePtr
.8387	a9 04		lda #$04			lda 	#((TokenOffset) >> 8)
.8389	85 31		sta $31				sta 	codePtr+1
.838b	ad 2d 04	lda $042d			lda 	TokenBuffer 				; nothing to run
.838e	c9 80		cmp #$80			cmp 	#KWC_EOL
.8390	f0 d8		beq $836a			beq 	WarmStart
.8392	20 7c 8a	jsr $8a7c			jsr 	RUNCodePointerLine 			; execute that line.
.8395	80 d3		bra $836a			bra 	WarmStart
.8397					_WSEditCode:
.8397	20 45 83	jsr $8345			jsr 	EditProgramCode
.839a	20 00 84	jsr $8400			jsr 	ClearCommand
.839d	80 cb		bra $836a			bra 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assemble.asm

.839f					AssembleCommand:
.839f	a2 00		ldx #$00			ldx 	#0
.83a1	20 d0 9c	jsr $9cd0			jsr 	Evaluate16BitInteger 		; start address
.83a4	a5 58		lda $58				lda 	NSMantissa0
.83a6	8d 1e 04	sta $041e			sta 	AssemblerAddress
.83a9	a5 60		lda $60				lda 	NSMantissa1
.83ab	8d 1f 04	sta $041f			sta 	AssemblerAddress+1
.83ae	20 2f 8e	jsr $8e2f			jsr 	CheckComma
.83b1	20 eb 9c	jsr $9ceb			jsr 	Evaluate8BitInteger 		; options
.83b4	a5 58		lda $58				lda 	NSMantissa0
.83b6	8d 20 04	sta $0420			sta 	AssemblerControl
.83b9	60		rts				rts
.83ba	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assert.asm

.83bb					AssertCommand:
.83bb	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.83bd	20 bd 9c	jsr $9cbd			jsr 	EvaluateInteger 			; the assert test
.83c0	20 72 9d	jsr $9d72			jsr 	NSMIsZero 					; exit if result is non zero.
.83c3	d0 05		bne $83ca			bne 	_ACExit
.83c5	a9 0a		lda #$0a		lda	#10
.83c7	4c 40 8e	jmp $8e40		jmp	ErrorHandler
.83ca					_ACExit:
.83ca	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/call.asm

.83cb					CallCommand:
.83cb	a2 00		ldx #$00			ldx 	#0 							; get the routine address to level 0
.83cd	20 d0 9c	jsr $9cd0			jsr 	Evaluate16BitInteger
.83d0					_CCClear
.83d0	e8		inx				inx  								; clear 1,2 and 3 (for A X Y)
.83d1	20 50 9d	jsr $9d50			jsr 	NSMSetZero 					; these are optional sequentially.
.83d4	e0 04		cpx #$04			cpx 	#4
.83d6	d0 f8		bne $83d0			bne 	_CCClear
.83d8	a2 00		ldx #$00			ldx 	#0 							; and keep trying while there are more values.
.83da					_CCCParam:
.83da	b1 30		lda ($30),y			lda 	(codePtr),y
.83dc	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.83de	d0 09		bne $83e9			bne 	_CCCRun6502
.83e0	c8		iny				iny 								; skip comma
.83e1	e8		inx				inx	 								; next level
.83e2	20 eb 9c	jsr $9ceb			jsr 	Evaluate8BitInteger 		; get A/X/Y
.83e5	e0 03		cpx #$03			cpx 	#3
.83e7	90 f1		bcc $83da			bcc 	_CCCParam 					; done all 3 ?
.83e9					_CCCRun6502:
.83e9	5a		phy				phy 								; save position
.83ea	a5 60		lda $60				lda 	NSMantissa1 				; put address in zTemp0
.83ec	85 37		sta $37				sta 	zTemp0+1
.83ee	a5 58		lda $58				lda 	NSMantissa0
.83f0	85 36		sta $36				sta 	zTemp0
.83f2	a5 59		lda $59				lda 	NSMantissa0+1 				; get registers into A X Y
.83f4	a6 5a		ldx $5a				ldx 	NSMantissa0+2
.83f6	a4 5b		ldy $5b				ldy 	NSMantissa0+3
.83f8	20 fd 83	jsr $83fd			jsr 	_CCCZTemp0 					; call zTemp0
.83fb	7a		ply				ply 								; restore position and exit
.83fc	60		rts				rts
.83fd					_CCCZTemp0:
.83fd	6c 36 00	jmp ($0036)			jmp 	(zTemp0)

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/clear.asm

.8400					ClearCommand:
.8400	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.8402	85 36		sta $36				sta 	0+zTemp0
.8404	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.8406	85 37		sta $37				sta 	1+zTemp0
.8408					_ClearZeroLoop:
.8408	b2 36		lda ($36)			lda 	(zTemp0) 					; end of variables if offset is zero.
.840a	f0 24		beq $8430			beq 	_ClearZeroEnd
.840c	a0 03		ldy #$03			ldy 	#3 							; erase the variables
.840e	a9 00		lda #$00			lda 	#0 							; set all the data to zero.
.8410					_ClearOneVariable:
.8410	91 36		sta ($36),y			sta 	(zTemp0),y
.8412	c8		iny				iny
.8413	c0 08		cpy #$08			cpy 	#8
.8415	d0 f9		bne $8410			bne 	_ClearOneVariable
.8417	a0 02		ldy #$02			ldy 	#2 							; has it been marked procedure
.8419	b1 36		lda ($36),y			lda 	(zTemp0),y
.841b	c9 18		cmp #$18			cmp 	#NSTProcedure
.841d	d0 04		bne $8423			bne 	_ClearNotProcedure
.841f	a9 04		lda #$04			lda 	#NSTInteger+NSBIsArray 		; if so set it back to an integer array
.8421	91 36		sta ($36),y			sta 	(zTemp0),y 					; will be fixed on the pre-run scan.
.8423					_ClearNotProcedure:
.8423	18		clc				clc 								; go to the next variable
.8424	b2 36		lda ($36)			lda 	(zTemp0) 					; offset to next, add to zTemp0
.8426	65 36		adc $36				adc 	zTemp0
.8428	85 36		sta $36				sta 	zTemp0
.842a	90 dc		bcc $8408			bcc 	_ClearZeroLoop
.842c	e6 37		inc $37				inc 	zTemp0+1
.842e	80 d8		bra $8408			bra 	_ClearZeroLoop
.8430					_ClearZeroEnd:
.8430	18		clc				clc
.8431	a5 36		lda $36				lda 	zTemp0
.8433	69 01		adc #$01			adc 	#1
.8435	8d 0c 04	sta $040c			sta 	lowMemPtr
.8438	a5 37		lda $37				lda 	zTemp0+1
.843a	69 00		adc #$00			adc 	#0
.843c	8d 0d 04	sta $040d			sta 	lowMemPtr+1
.843f	20 f2 a5	jsr $a5f2			jsr 	StackReset
.8442	20 58 a6	jsr $a658			jsr 	StringSystemInitialise
.8445	20 cd 8c	jsr $8ccd			jsr 	ProcedureScan
.8448	20 2b 8a	jsr $8a2b			jsr 	Command_Restore
.844b	9c 1e 04	stz $041e			stz 	AssemblerAddress
.844e	9c 1f 04	stz $041f			stz 	AssemblerAddress+1
.8451	9c 20 04	stz $0420			stz 	AssemblerControl
.8454	20 75 99	jsr $9975			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.8457	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/cls.asm

.8458					ClearScreen:
.8458	5a		phy				phy
.8459	a9 0c		lda #$0c			lda 	#12 						; char code 12 clears the screen.
.845b	20 c4 a6	jsr $a6c4			jsr 	EXTPrintCharacter
.845e	7a		ply				ply
.845f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/data.asm

.8460					Command_Data:
.8460	a9 3a		lda #$3a			lda 	#KWD_COLON 					; advance to colon/EOL
.8462	a2 80		ldx #$80			ldx 	#KWC_EOL
.8464	20 1f 8d	jsr $8d1f			jsr 	ScanForward
.8467	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dim.asm

.8468					DimCommand:
.8468	b1 30		lda ($30),y			lda 	(codePtr),y
.846a	29 c0		and #$c0			and 	#$C0
.846c	c9 40		cmp #$40			cmp 	#$40
.846e	d0 7a		bne $84ea			bne 	_DCSyntax
.8470	b1 30		lda ($30),y			lda 	(codePtr),y
.8472	18		clc				clc
.8473	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8475	85 3f		sta $3f				sta 	zaTemp+1
.8477	c8		iny				iny
.8478	b1 30		lda ($30),y			lda 	(codePtr),y
.847a	c8		iny				iny
.847b	85 3e		sta $3e				sta 	zaTemp
.847d	5a		phy				phy
.847e	a0 02		ldy #$02			ldy 	#2 						; read type byte
.8480	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8482	29 18		and #$18			and 	#NSBTypeMask 			; check it's not a procedure
.8484	c9 18		cmp #$18			cmp 	#NSTProcedure
.8486	f0 62		beq $84ea			beq 	_DCSyntax
.8488	b1 3e		lda ($3e),y			lda 	(zaTemp),y 				; check it's an array
.848a	29 04		and #$04			and 	#NSBIsArray
.848c	f0 64		beq $84f2			beq 	_DCType
.848e	a0 04		ldy #$04			ldy 	#4 						; check not already defined
.8490	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8492	d0 59		bne $84ed			bne 	_DCRedefine
.8494	7a		ply				ply
.8495	20 f5 84	jsr $84f5			jsr 	_DCGetSize 				; get array size, check it.
.8498	5a		phy				phy
.8499	a0 05		ldy #$05			ldy 	#5 						; store in first array size slot
.849b	91 3e		sta ($3e),y			sta 	(zaTemp),y 				; second will be zero.
.849d	7a		ply				ply 							; is there a second (e.g. ,x)
.849e	b1 30		lda ($30),y			lda 	(codePtr),y
.84a0	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.84a2	d0 0a		bne $84ae			bne 	_DCOneDimension
.84a4	c8		iny				iny 							; skip comma
.84a5	20 f5 84	jsr $84f5			jsr 	_DCGetSize 				; get 2nd array size
.84a8	5a		phy				phy
.84a9	a0 06		ldy #$06			ldy 	#6 						; store in 2nd array size
.84ab	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84ad	7a		ply				ply
.84ae					_DCOneDimension:
.84ae	5a		phy				phy 							; save position
.84af	a0 05		ldy #$05			ldy 	#5 						; dimensions + 1 in AX (as zero based)
.84b1	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84b3	aa		tax				tax
.84b4	c8		iny				iny
.84b5	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84b7	e8		inx				inx 							; bump them.
.84b8	1a		inc a				inc 	a
.84b9	20 fb 9c	jsr $9cfb			jsr 	Multiply8x8 			; work out the total number of elements -> zTemp0
.84bc	a5 37		lda $37				lda 	zTemp0+1 				; don't allow more than 8192 elements whatever
.84be	29 e0		and #$e0			and 	#$E0
.84c0	d0 23		bne $84e5			bne 	_DCSize
.84c2	a0 02		ldy #$02			ldy 	#2 						; get base type
.84c4	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84c6	20 03 85	jsr $8503			jsr 	ScaleByBaseType 		; scale by base type
.84c9	a5 36		lda $36				lda 	zTemp0
.84cb	a6 37		ldx $37				ldx 	zTemp0+1
.84cd	20 37 99	jsr $9937			jsr 	AllocateXABytes 		; allocate memory
.84d0	a0 03		ldy #$03			ldy 	#3 						; copy into the address.
.84d2	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84d4	c8		iny				iny
.84d5	8a		txa				txa
.84d6	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84d8	7a		ply				ply 							; get position back
.84d9	20 27 8e	jsr $8e27			jsr 	CheckRightBracket 		; check )
.84dc	b1 30		lda ($30),y			lda 	(codePtr),y
.84de	c8		iny				iny 							; consume in case
.84df	c9 2c		cmp #$2c			cmp 	#KWD_COMMA		 		; if so do another DIM.
.84e1	f0 85		beq $8468			beq 	DimCommand
.84e3	88		dey				dey 							; undo consume
.84e4	60		rts				rts
.84e5					_DCSize:
.84e5	a9 16		lda #$16		lda	#22
.84e7	4c 40 8e	jmp $8e40		jmp	ErrorHandler
.84ea					_DCSyntax:
.84ea	4c c8 9e	jmp $9ec8			jmp 	SyntaxError
.84ed					_DCRedefine:
.84ed	a9 15		lda #$15		lda	#21
.84ef	4c 40 8e	jmp $8e40		jmp	ErrorHandler
.84f2					_DCType:
.84f2	4c d2 9e	jmp $9ed2			jmp 	TypeError
.84f5					_DCGetSize:
.84f5	a2 00		ldx #$00			ldx 	#0 						; get first index.
.84f7	20 eb 9c	jsr $9ceb			jsr 	Evaluate8BitInteger 	; get array dimension
.84fa	c9 00		cmp #$00			cmp 	#0 						; must be 1-254
.84fc	f0 e7		beq $84e5			beq 	_DCSize
.84fe	c9 fe		cmp #$fe			cmp 	#254
.8500	f0 e3		beq $84e5			beq 	_DCSize
.8502	60		rts				rts
.8503					ScaleByBaseType:
.8503	29 10		and #$10			and 	#NSBIsString 			; is it string
.8505	d0 19		bne $8520			bne 	_SBBTString
.8507	a5 37		lda $37				lda 	zTemp0+1 				; push value on stack
.8509	48		pha				pha
.850a	a5 36		lda $36				lda 	zTemp0
.850c	48		pha				pha
.850d	06 36		asl $36				asl 	zTemp0 					; x 2
.850f	26 37		rol $37				rol 	zTemp0+1
.8511	06 36		asl $36				asl 	zTemp0 					; x 4
.8513	26 37		rol $37				rol 	zTemp0+1
.8515	68		pla				pla 							; add stacked value = x 5
.8516	65 36		adc $36				adc 	zTemp0
.8518	85 36		sta $36				sta 	zTemp0
.851a	68		pla				pla
.851b	65 37		adc $37				adc 	zTemp0+1
.851d	85 37		sta $37				sta 	zTemp0+1
.851f	60		rts				rts
.8520					_SBBTString:
.8520	06 36		asl $36				asl 	zTemp0
.8522	26 37		rol $37				rol 	zTemp0+1
.8524	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/end.asm

.8525					EndCommand:
.8525	4c 6a 83	jmp $836a			jmp 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/for.asm

.8528					ForCommand:
.8528	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; allocate 18 bytes on the return stack.
.852a	20 8d a5	jsr $a58d			jsr 	StackOpen
.852d	a2 00		ldx #$00			ldx 	#0
.852f	20 8e 97	jsr $978e			jsr 	EvaluateTerm
.8532	b5 50		lda $50,x			lda 	NSStatus,x
.8534	c9 20		cmp #$20			cmp 	#NSBIsReference+NSTInteger 	; do we have an integer 4 byte reference.
.8536	d0 47		bne $857f			bne		_FCError
.8538	a9 3d		lda #$3d			lda 	#KWD_EQUAL 					; =
.853a	20 37 8e	jsr $8e37			jsr 	CheckNextA
.853d	e8		inx				inx
.853e	20 bd 9c	jsr $9cbd			jsr 	EvaluateInteger 			; <from> in +1
.8541	b1 30		lda ($30),y			lda 	(codePtr),y
.8543	c8		iny				iny 								; consume it
.8544	48		pha				pha 								; save on stack for later
.8545	c9 b4		cmp #$b4			cmp 	#KWD_DOWNTO
.8547	f0 04		beq $854d			beq 	_FCNoSyntax
.8549	c9 ce		cmp #$ce			cmp 	#KWD_TO
.854b	d0 35		bne $8582			bne 	_FCSyntaxError
.854d					_FCNoSyntax:
.854d	e8		inx				inx
.854e	20 bd 9c	jsr $9cbd			jsr 	EvaluateInteger
.8551	20 d1 a5	jsr $a5d1			jsr 	STKSaveCodePosition 		; save loop back position
.8554	68		pla				pla 								; restore DOWNTO or TO
.8555	5a		phy				phy 								; save Y on the stack
.8556	49 b4		eor #$b4			eor 	#KWD_DOWNTO 				; 0 if DOWNTO, #0 if TO
.8558	f0 02		beq $855c			beq 	_FCNotDownTo
.855a	a9 02		lda #$02			lda 	#2
.855c					_FCNotDownTo:
.855c	3a		dec a				dec 	a 							; 255 if DOWNTO, 1 if TO
.855d	a0 10		ldy #$10			ldy 	#16
.855f	91 34		sta ($34),y			sta 	(basicStack),y 				; copy that out to the Basic Stack.
.8561	a0 06		ldy #$06			ldy 	#6
.8563	a5 58		lda $58				lda 	NSMantissa0
.8565	91 34		sta ($34),y			sta 	(basicStack),y
.8567	a5 60		lda $60				lda 	NSMantissa1
.8569	c8		iny				iny
.856a	91 34		sta ($34),y			sta 	(basicStack),y
.856c	a0 08		ldy #$08			ldy 	#8 							; set initial index value
.856e	a2 01		ldx #$01			ldx 	#1
.8570	20 85 85	jsr $8585			jsr 	FCIntegerToStack
.8573	a0 0c		ldy #$0c			ldy 	#12 						; set the terminal value
.8575	a2 02		ldx #$02			ldx 	#2
.8577	20 85 85	jsr $8585			jsr 	FCIntegerToStack
.857a	20 a0 85	jsr $85a0			jsr 	CopyIndexToReference
.857d	7a		ply				ply 								; restore position
.857e	60		rts				rts
.857f					_FCError:
.857f	4c d2 9e	jmp $9ed2			jmp 	TypeError
.8582					_FCSyntaxError:
.8582	4c c8 9e	jmp $9ec8			jmp 	SyntaxError
.8585					FCIntegerToStack:
.8585	34 50		bit $50,x			bit 	NSStatus,x 					; is the value negative
.8587	10 03		bpl $858c			bpl	 	_FCNotNegative
.8589	20 19 9d	jsr $9d19			jsr 	NSMNegateMantissa 			; if so 2's complement the mantissa
.858c					_FCNotNegative:
.858c	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy out to the basic stack
.858e	91 34		sta ($34),y			sta 	(basicStack),y
.8590	c8		iny				iny
.8591	b5 60		lda $60,x			lda 	NSMantissa1,x
.8593	91 34		sta ($34),y			sta 	(basicStack),y
.8595	c8		iny				iny
.8596	b5 68		lda $68,x			lda 	NSMantissa2,x
.8598	91 34		sta ($34),y			sta 	(basicStack),y
.859a	c8		iny				iny
.859b	b5 70		lda $70,x			lda 	NSMantissa3,x
.859d	91 34		sta ($34),y			sta 	(basicStack),y
.859f	60		rts				rts
.85a0					CopyIndexToReference:
.85a0	5a		phy				phy
.85a1	a0 06		ldy #$06			ldy 	#6 							; copy address-8 to write to zTemp0
.85a3	38		sec				sec 								; (because we copy from offset 8)
.85a4	b1 34		lda ($34),y			lda 	(basicStack),y
.85a6	e9 08		sbc #$08			sbc 	#8
.85a8	85 36		sta $36				sta 	zTemp0
.85aa	c8		iny				iny
.85ab	b1 34		lda ($34),y			lda 	(basicStack),y
.85ad	e9 00		sbc #$00			sbc 	#0
.85af	85 37		sta $37				sta 	zTemp0+1
.85b1	a2 04		ldx #$04			ldx 	#4 							; this is the copy counter/
.85b3	a0 0b		ldy #$0b			ldy 	#8+3 		 				; the MSB of the mantissa
.85b5	b1 34		lda ($34),y			lda 	(basicStack),y
.85b7	0a		asl a				asl 	a 							; into carry
.85b8	a0 08		ldy #$08			ldy 	#8 							; where to copy from.
.85ba	90 14		bcc $85d0			bcc 	_CITRNormal
.85bc	38		sec				sec
.85bd					_CITRNegative:
.85bd	a9 00		lda #$00			lda 	#0
.85bf	f1 34		sbc ($34),y			sbc 	(basicStack),y
.85c1	91 36		sta ($36),y			sta 	(zTemp0),y
.85c3	c8		iny				iny
.85c4	ca		dex				dex
.85c5	d0 f6		bne $85bd			bne 	_CITRNegative
.85c7	88		dey				dey 								; look at MSB of mantissa
.85c8	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set the MSB as negative packed.
.85ca	09 80		ora #$80			ora 	#$80
.85cc	91 36		sta ($36),y			sta 	(zTemp0),y
.85ce	7a		ply				ply
.85cf	60		rts				rts
.85d0					_CITRNormal:
.85d0	b1 34		lda ($34),y			lda 	(basicStack),y 				; copy without negation.
.85d2	91 36		sta ($36),y			sta 	(zTemp0),y
.85d4	c8		iny				iny
.85d5	ca		dex				dex
.85d6	d0 f8		bne $85d0			bne 	_CITRNormal
.85d8	7a		ply				ply 								; and exit.
.85d9	60		rts				rts
.85da					NextCommand:
.85da	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; check FOR is TOS
.85dc	a2 11		ldx #$11			ldx 	#ERRID_FOR 					; this error
.85de	20 b9 a5	jsr $a5b9			jsr 	StackCheckFrame
.85e1	5a		phy				phy
.85e2	a0 10		ldy #$10			ldy 	#16 						; get the step count
.85e4	b1 34		lda ($34),y			lda 	(basicStack),y
.85e6	85 36		sta $36				sta 	zTemp0 						; this is the sign extend
.85e8	30 02		bmi $85ec			bmi 	_NCStepNeg
.85ea	64 36		stz $36				stz 	zTemp0 						; which is 0 or 255
.85ec					_NCStepNeg:
.85ec	a0 08		ldy #$08			ldy 	#8 							; offset to bump
.85ee	a2 04		ldx #$04			ldx 	#4 							; count to bump
.85f0	18		clc				clc
.85f1					_NCBump:
.85f1	71 34		adc ($34),y			adc 	(basicStack),y 				; add it
.85f3	91 34		sta ($34),y			sta 	(basicStack),y
.85f5	a5 36		lda $36				lda 	zTemp0 						; get sign extend for next time.
.85f7	c8		iny				iny 								; next byte
.85f8	ca		dex				dex 								; do four times
.85f9	d0 f6		bne $85f1			bne 	_NCBump
.85fb	20 a0 85	jsr $85a0			jsr		CopyIndexToReference		; copy it to the reference variable.
.85fe	a0 10		ldy #$10			ldy 	#16 						; get step count again
.8600	b1 34		lda ($34),y			lda 	(basicStack),y
.8602	0a		asl a				asl 	a 							; sign bit to carry
.8603	a9 0c		lda #$0c			lda 	#12 						; offset of LHS = terminal offset
.8605	85 38		sta $38				sta 	zTemp1
.8607	90 02		bcc $860b			bcc 	_NCCompRev 					; use if step is +ve
.8609	a9 08		lda #$08			lda 	#8 							; now the LHS = index value
.860b					_NCCompRev:
.860b	85 38		sta $38				sta 	zTemp1 						; so zTemp0 is the index for LHS
.860d	49 04		eor #$04			eor 	#(8^12) 					; and zTemp0+1 is the index for RHS
.860f	85 39		sta $39				sta 	zTemp1+1
.8611	a2 04		ldx #$04			ldx 	#4 							; bytes to compare
.8613	38		sec				sec
.8614					_NCCompare:
.8614	a4 38		ldy $38				ldy 	zTemp1 						; do compare using the two indices
.8616	b1 34		lda ($34),y			lda 	(basicStack),y
.8618	a4 39		ldy $39				ldy 	zTemp1+1
.861a	f1 34		sbc ($34),y			sbc 	(basicStack),y
.861c	e6 38		inc $38				inc 	zTemp1 						; bump the indices (inc,dex do not change C or V)
.861e	e6 39		inc $39				inc 	zTemp1+1
.8620	ca		dex				dex 								; do it 4 times.
.8621	d0 f1		bne $8614			bne 	_NCCompare
.8623	50 02		bvc $8627			bvc 	_NCNoOverflow 				; convert to signed comparison
.8625	49 80		eor #$80			eor 	#$80
.8627					_NCNoOverflow:
.8627	7a		ply				ply 								; restore Y position
.8628	0a		asl a				asl 	a 							; is bit 7 set.
.8629	90 04		bcc $862f			bcc 	_NCLoopback 				; if no , >= so loop back
.862b	20 ab a5	jsr $a5ab			jsr 	StackClose 					; exit the loop
.862e	60		rts				rts
.862f					_NCLoopBack:
.862f	20 e2 a5	jsr $a5e2			jsr 	STKLoadCodePosition 		; loop back
.8632	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/gosub.asm

.8633					Command_GOSUB:
.8633	a2 00		ldx #$00			ldx 	#0
.8635	20 d0 9c	jsr $9cd0			jsr 	Evaluate16BitInteger 		; line number in Stack.0
.8638	a9 e3		lda #$e3			lda 	#STK_GOSUB+3
.863a	20 8d a5	jsr $a58d			jsr 	StackOpen 					; create frame
.863d	20 d1 a5	jsr $a5d1			jsr 	STKSaveCodePosition 		; save current position
.8640	4c 56 86	jmp $8656			jmp 	GotoStackX
.8643					Command_RETURN:
.8643	a9 e0		lda #$e0			lda 	#STK_GOSUB 					; check TOS is this
.8645	a2 0e		ldx #$0e			ldx 	#ERRID_GOSUB 				; this error
.8647	20 b9 a5	jsr $a5b9			jsr 	StackCheckFrame
.864a	20 e2 a5	jsr $a5e2			jsr 	STKLoadCodePosition 		; restore code position
.864d	20 ab a5	jsr $a5ab			jsr 	StackClose
.8650	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/goto.asm

.8651					GotoCommand:
.8651	a2 00		ldx #$00			ldx 	#0 							; GOTO where
.8653	20 d0 9c	jsr $9cd0			jsr 	Evaluate16BitInteger
.8656					GotoStackX:
.8656	b5 60		lda $60,x			lda  	NSMantissa1,x 				; put line # in XA. I'll keep this even though
.8658	48		pha				pha 								; it is slightly inefficient, just in cases.
.8659	b5 58		lda $58,x			lda 	NSMantissa0,x
.865b	fa		plx				plx
.865c	20 b6 a4	jsr $a4b6			jsr 	MemorySearch 				; transfer to line number AX.
.865f	90 05		bcc $8666			bcc 	_GotoError 					; not found, off end.
.8661	d0 03		bne $8666			bne 	_GotoError 					; not found exactly
.8663	4c 75 8a	jmp $8a75			jmp 	RunNewLine 					; and go straight to new line code.
.8666					_GotoError:
.8666	a9 0d		lda #$0d		lda	#13
.8668	4c 40 8e	jmp $8e40		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/if.asm

.866b					IfCommand:
.866b	a2 00		ldx #$00			ldx 	#0 							; If what.
.866d	20 9e 9c	jsr $9c9e			jsr 	EvaluateNumber
.8670	b1 30		lda ($30),y			lda 	(codePtr),y
.8672	c9 a8		cmp #$a8			cmp 	#KWD_THEN  					; could be THEN <stuff> or GOTO
.8674	d0 0a		bne $8680			bne 	_IFStructured
.8676	c8		iny				iny 								; consume THEN
.8677	20 72 9d	jsr $9d72			jsr 	NSMIsZero 					; is it zero
.867a	f0 01		beq $867d			beq 	_IfFail 					; if fail, go to next line
.867c	60		rts				rts 								; if THEN just continue
.867d					_IfFail:
.867d	4c 5d 8a	jmp $8a5d			jmp 	EOLCommand
.8680					_IfStructured:
.8680	20 72 9d	jsr $9d72			jsr 	NSMIsZero 					; is it zero
.8683	d0 07		bne $868c			bne 	_IfExit 					; if not, then continue normally.
.8685	a9 b5		lda #$b5			lda 	#KWD_ELSE 					; look for else/endif
.8687	a2 a5		ldx #$a5			ldx 	#KWD_ENDIF
.8689	20 1f 8d	jsr $8d1f			jsr 	ScanForward 				; and run from there/
.868c					_IfExit:
.868c	60		rts				rts
.868d					ElseCode:
.868d	a9 a5		lda #$a5			lda 	#KWD_ENDIF 					; else is only run after the if clause succeeds
.868f	aa		tax				tax 								; so just go to the structure exit
.8690	20 1f 8d	jsr $8d1f			jsr 	ScanForward
.8693	60		rts				rts
.8694					EndIf:
.8694	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/inputprint.asm

.8695					Command_Input:
.8695	a9 ff		lda #$ff			lda 	#$FF
.8697	8d 28 04	sta $0428			sta 	IsInputFlag
.869a	80 03		bra $869f			bra 	Command_IP_Main
.869c					Command_Print:
.869c	9c 28 04	stz $0428			stz 	IsInputFlag
.869f					Command_IP_Main:
.869f	18		clc				clc 								; carry being clear means last print wasn't comma/semicolon
.86a0					_CPLoop:
.86a0	08		php				php 								; save last action flag
.86a1	b1 30		lda ($30),y			lda 	(codePtr),y
.86a3	c9 80		cmp #$80			cmp  	#KWC_EOL 					; end of line or colon, exit now.
.86a5	f0 54		beq $86fb			beq 	_CPExit
.86a7	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.86a9	f0 50		beq $86fb			beq 	_CPExit
.86ab	68		pla				pla 								; throw last action flag
.86ac	b1 30		lda ($30),y			lda 	(codePtr),y
.86ae	c8		iny				iny
.86af	c9 3b		cmp #$3b			cmp 	#KWD_SEMICOLON				; is it a semicolon
.86b1	f0 45		beq $86f8			beq 	_CPContinueWithSameLine
.86b3	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; comma
.86b5	f0 3c		beq $86f3			beq 	_CPTab
.86b7	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; apostrophe (new line)
.86b9	f0 34		beq $86ef			beq 	_CPNewLine
.86bb	88		dey				dey 								; undo the get.
.86bc	20 42 93	jsr $9342			jsr 	EvaluateExpressionAt0 		; evaluate expression at 0.
.86bf	b5 50		lda $50,x			lda 	NSStatus,x 					; read the status
.86c1	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.86c3	f0 0d		beq $86d2			beq 	_CPIsValue
.86c5	ad 28 04	lda $0428			lda 	IsInputFlag 				; if print, dereference and print.
.86c8	f0 05		beq $86cf			beq 	_CPIsPrint
.86ca	20 04 87	jsr $8704			jsr 	CIInputValue 				; input a value to the reference
.86cd	80 20		bra $86ef			bra 	_CPNewLine
.86cf					_CPIsPrint:
.86cf	20 07 96	jsr $9607			jsr 	Dereference
.86d2					_CPIsValue:
.86d2	b5 50		lda $50,x			lda 	NSStatus,x 					; is it a number
.86d4	29 10		and #$10			and 	#NSBIsString
.86d6	f0 09		beq $86e1			beq 	_CPNumber
.86d8	a6 60		ldx $60				ldx 	NSMantissa1 				; string, print the text.
.86da	a5 58		lda $58				lda 	NSMantissa0
.86dc	20 67 87	jsr $8767			jsr 	CPPrintStringXA
.86df	80 be		bra $869f			bra 	Command_IP_Main 			; loop round clearing carry so NL if end
.86e1					_CPNumber:
.86e1	a9 05		lda #$05			lda 	#5 							; maximum decimals
.86e3	20 85 9b	jsr $9b85			jsr 	ConvertNumberToString 		; convert to string
.86e6	a2 05		ldx #$05			ldx 	#DecimalBuffer >> 8
.86e8	a9 9d		lda #$9d			lda 	#DecimalBuffer & $FF
.86ea	20 67 87	jsr $8767			jsr 	CPPrintStringXA
.86ed	80 b0		bra $869f			bra 	Command_IP_Main				; loop round clearing carry so NL if end
.86ef					_CPNewLine:
.86ef	a9 0d		lda #$0d			lda 	#13
.86f1	80 02		bra $86f5			bra 	_CPPrintChar
.86f3					_CPTab:
.86f3	a9 09		lda #$09			lda 	#9 							; print TAB
.86f5					_CPPrintChar:
.86f5	20 7a 87	jsr $877a			jsr 	CPPrintVector
.86f8					_CPContinueWithSameLine:
.86f8	38		sec				sec 								; loop round with carry set, which
.86f9	80 a5		bra $86a0			bra 	_CPLoop 					; will inhibit final CR
.86fb					_CPExit:
.86fb	28		plp				plp 								; get last action flag
.86fc	b0 05		bcs $8703			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.86fe	a9 0d		lda #$0d			lda 	#13 						; print new line
.8700	20 7a 87	jsr $877a			jsr 	CPPrintVector
.8703					_CPExit2:
.8703	60		rts				rts
.8704					CIInputValue:
.8704	a2 00		ldx #$00			ldx 	#0 							; input a line.
.8706					_CIInputLine:
.8706	20 7d 87	jsr $877d			jsr 	CPInputVector 				; get key
.8709	c9 0d		cmp #$0d			cmp 	#13 						; 13 = End
.870b	f0 1f		beq $872c			beq 	_CIHaveValue
.870d	c9 08		cmp #$08			cmp 	#8 							; 8 = BS
.870f	f0 11		beq $8722			beq 	_CIBackspace
.8711	c9 20		cmp #$20			cmp 	#32 						; ignore other control characters
.8713	90 f1		bcc $8706			bcc 	_CIInputLine
.8715	e0 50		cpx #$50			cpx 	#80 						; max length
.8717	b0 ed		bcs $8706			bcs 	_CIInputLine
.8719	9d 2a 05	sta $052a,x			sta 	lineBuffer,x
.871c	e8		inx				inx
.871d	20 7a 87	jsr $877a			jsr 	CPPrintVector 				; echo it.
.8720	80 e4		bra $8706			bra 	_CIInputLine
.8722					_CIBackSpace:
.8722	e0 00		cpx #$00			cpx 	#0 							; nothing to delete
.8724	f0 e0		beq $8706			beq 	_CIInputLine
.8726	20 7a 87	jsr $877a			jsr 	CPPrintVector 				; echo it.
.8729	ca		dex				dex
.872a	80 da		bra $8706			bra 	_CIInputLine
.872c					_CIHaveValue:
.872c	9e 2a 05	stz $052a,x			stz 	LineBuffer,x 				; ASCIIZ string now in line buffer.
.872f	a5 50		lda $50				lda 	NSStatus 					; was it a string assignment
.8731	29 10		and #$10			and 	#NSBIsString
.8733	f0 17		beq $874c			beq 	_CIAssignNumber 			; assign a number
.8735	a2 01		ldx #$01			ldx 	#1
.8737	a9 2a		lda #$2a			lda 	#lineBuffer & $FF 			; set up to point to new string
.8739	95 58		sta $58,x			sta 	NSMantissa0,x
.873b	a9 05		lda #$05			lda 	#lineBuffer >> 8
.873d	95 60		sta $60,x			sta 	NSMantissa1,x
.873f	74 68		stz $68,x			stz 	NSMantissa2,x
.8741	74 70		stz $70,x			stz 	NSMantissa3,x
.8743	a9 10		lda #$10			lda 	#NSBIsString 				; so it becomes a string value
.8745	95 50		sta $50,x			sta  	NSStatus,x
.8747	ca		dex				dex 								; X = 0
.8748	20 b9 87	jsr $87b9			jsr 	AssignVariable
.874b	60		rts				rts
.874c					_CIAssignNumber:
.874c	a9 2a		lda #$2a			lda 	#lineBuffer & $FF 			; set up to point to new string
.874e	85 36		sta $36				sta 	zTemp0
.8750	a9 05		lda #$05			lda 	#lineBuffer >> 8
.8752	85 37		sta $37				sta 	zTemp0+1
.8754	a2 01		ldx #$01			ldx 	#1 							; put in slot 1
.8756	20 07 9b	jsr $9b07			jsr 	ValEvaluateZTemp0 			; use the VAL() code
.8759	90 07		bcc $8762			bcc 	_CIIsOkay
.875b	a9 3f		lda #$3f			lda 	#"?" 						; error ?
.875d	20 7a 87	jsr $877a			jsr 	CPPrintVector
.8760	80 a2		bra $8704			bra 	CIInputValue
.8762					_CIIsOkay:
.8762	ca		dex				dex 								; X = 0
.8763	20 b9 87	jsr $87b9			jsr 	AssignVariable
.8766	60		rts				rts
.8767					CPPrintStringXA:
.8767	5a		phy				phy
.8768	86 37		stx $37				stx 	zTemp0+1
.876a	85 36		sta $36				sta 	zTemp0
.876c	a0 00		ldy #$00			ldy 	#0
.876e					_PSXALoop:
.876e	b1 36		lda ($36),y			lda 	(zTemp0),y
.8770	f0 06		beq $8778			beq 	_PSXAExit
.8772	20 7a 87	jsr $877a			jsr 	CPPrintVector
.8775	c8		iny				iny
.8776	80 f6		bra $876e			bra 	_PSXALoop
.8778					_PSXAExit:
.8778	7a		ply				ply
.8779	60		rts				rts
.877a					CPPrintVector:
.877a	4c c4 a6	jmp $a6c4			jmp 	EXTPrintCharacter
.877d					CPInputVector:
.877d	4c 5a a9	jmp $a95a			jmp 	EXTInputSingleCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/let.asm

.8780					LetCommand:
.8780	a2 00		ldx #$00			ldx 	#0
.8782	b1 30		lda ($30),y			lda 	(codePtr),y
.8784	c9 10		cmp #$10			cmp 	#KWD_AT
.8786	d0 14		bne $879c			bne 	_LCStandard
.8788	c8		iny				iny 								; skip equal
.8789	20 8e 97	jsr $978e			jsr 	EvaluateTerm 				; get a number
.878c	20 07 96	jsr $9607			jsr 	Dereference 				; dereference it
.878f	b5 50		lda $50,x			lda 	NSStatus,x 					; check integer
.8791	49 20		eor #$20			eor 	#NSBIsReference	 			; toggle reference
.8793	95 50		sta $50,x			sta 	NSStatus,x
.8795	29 20		and #$20			and 	#NSBIsReference 			; if it is now a reference, continue
.8797	d0 0f		bne $87a8			bne 	_LCMain
.8799	4c d2 9e	jmp $9ed2			jmp 	TypeError 					; was a reference before.
.879c					_LCStandard:
.879c	ad 2c 93	lda $932c			lda 	PrecedenceLevel+"*"			; precedence > this
.879f	20 46 93	jsr $9346			jsr 	EvaluateExpressionAtPrecedence
.87a2	b5 50		lda $50,x			lda 	NSStatus,x 					; is it a reference to an array
.87a4	c9 38		cmp #$38			cmp		#NSTProcedure+NSBIsReference
.87a6	f0 0e		beq $87b6			beq 	_LetGoProc 					; it's a procedure call.
.87a8					_LCMain:
.87a8	a9 3d		lda #$3d			lda 	#"=" 						; check =
.87aa	20 37 8e	jsr $8e37			jsr 	CheckNextA
.87ad	e8		inx				inx 								; RHS
.87ae	20 95 9c	jsr $9c95			jsr 	EvaluateValue
.87b1	ca		dex				dex
.87b2	20 b9 87	jsr $87b9			jsr 	AssignVariable
.87b5	60		rts				rts
.87b6					_LetGoProc:
.87b6	4c 38 89	jmp $8938			jmp 	CallProcedure
.87b9					AssignVariable:
.87b9	b5 50		lda $50,x			lda 	NSStatus,x 					; check the string/number type bits match
.87bb	48		pha				pha 								; save a copy
.87bc	55 51		eor $51,x			eor 	NSStatus+1,x
.87be	29 10		and #$10			and 	#NSBIsString
.87c0	d0 0b		bne $87cd			bne 	_ASError
.87c2	68		pla				pla 								; get back
.87c3	29 10		and #$10			and 	#NSBIsString 				; check type
.87c5	d0 03		bne $87ca			bne 	_ASString
.87c7	4c 45 95	jmp $9545			jmp 	AssignNumber
.87ca					_ASString:
.87ca	4c a3 95	jmp $95a3			jmp 	AssignString
.87cd					_ASError:
.87cd	4c d2 9e	jmp $9ed2			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/list.asm

.87d0					Command_List:
.87d0	9c 26 04	stz $0426			stz 	listIndent 					; reset indent.
.87d3	64 5c		stz $5c				stz		NSMantissa0+4				; set the lower (slot 4) to 0 and upper (slot 7) to $FFFF
.87d5	64 64		stz $64				stz 	NSMantissa1+4
.87d7	a9 ff		lda #$ff			lda 	#$FF
.87d9	85 5f		sta $5f				sta 	NSMantissa0+7
.87db	85 67		sta $67				sta 	NSMantissa1+7
.87dd	b1 30		lda ($30),y			lda 	(codePtr),y
.87df	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.87e1	f0 1a		beq $87fd			beq 	_CLSecond
.87e3	20 5c 88	jsr $885c			jsr 	CLIsDigit 					; if not digit, list all
.87e6	b0 20		bcs $8808			bcs 	_CLStart
.87e8	a2 04		ldx #$04			ldx 	#4 							; get 1st range into slot 4
.87ea	20 d0 9c	jsr $9cd0			jsr 	Evaluate16BitInteger
.87ed	b1 30		lda ($30),y			lda 	(codePtr),y
.87ef	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.87f1	f0 0a		beq $87fd			beq 	_CLSecond 					; if so go get it
.87f3	a5 5c		lda $5c				lda 	NSMantissa0+4 				; copy 4->7
.87f5	85 5f		sta $5f				sta 	NSMantissa0+7
.87f7	a5 64		lda $64				lda 	NSMantissa1+4
.87f9	85 67		sta $67				sta 	NSMantissa1+7
.87fb	80 0b		bra $8808			bra 	_CLStart
.87fd					_CLSecond:
.87fd	c8		iny				iny 								; consume comma
.87fe	20 5c 88	jsr $885c			jsr 	CLIsDigit 					; digit found
.8801	b0 05		bcs $8808			bcs 	_CLStart 					; if not, continue listing
.8803	a2 07		ldx #$07			ldx 	#7 							; load 2nd range into slot 7
.8805	20 d0 9c	jsr $9cd0			jsr 	Evaluate16BitInteger
.8808					_CLStart
.8808	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.880a	85 30		sta $30				sta 	codePtr
.880c	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.880e	85 31		sta $31				sta 	codePtr+1
.8810					_CLLoop:
.8810	20 7a a9	jsr $a97a			jsr 	EXTBreakCheck 				; break check
.8813	f0 33		beq $8848			beq 	_CLExit
.8815	b2 30		lda ($30)			lda 	(codePtr)
.8817	f0 2f		beq $8848			beq 	_CLExit
.8819	a2 04		ldx #$04			ldx 	#4 							; check range every time, line numbers aren't in order.
.881b	20 4b 88	jsr $884b			jsr 	CLCompareLineNo
.881e	90 1b		bcc $883b			bcc 	_CLNext
.8820	a2 07		ldx #$07			ldx 	#7
.8822	20 4b 88	jsr $884b			jsr 	CLCompareLineNo
.8825	f0 02		beq $8829			beq 	_CLDoThisOne
.8827	b0 12		bcs $883b			bcs 	_CLNext
.8829					_CLDoThisOne:
.8829	20 82 8d	jsr $8d82			jsr 	ScanGetCurrentLineStep 		; get indent adjust.
.882c	20 c4 b2	jsr $b2c4			jsr 	ListConvertLine 			; convert line into token Buffer
.882f	a2 04		ldx #$04			ldx 	#(tokenBuffer >> 8) 		; print that line
.8831	a9 2d		lda #$2d			lda 	#(tokenBuffer & $FF)
.8833	20 99 8e	jsr $8e99			jsr 	PrintStringXA
.8836	a9 0d		lda #$0d			lda 	#13 						; new line
.8838	20 c4 a6	jsr $a6c4			jsr 	EXTPrintCharacter
.883b					_CLNext:
.883b	18		clc				clc
.883c	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.883e	65 30		adc $30				adc 	codePtr
.8840	85 30		sta $30				sta 	codePtr
.8842	90 02		bcc $8846			bcc 	_CREExit
.8844	e6 31		inc $31				inc 	codePtr+1 					; carry
.8846					_CREExit:
.8846	80 c8		bra $8810			bra 	_CLLoop
.8848					_CLExit:
.8848	4c 6a 83	jmp $836a			jmp 	WarmStart
.884b					CLCompareLineNo:
.884b	38		sec				sec
.884c	a0 01		ldy #$01			ldy 	#1
.884e	b1 30		lda ($30),y			lda 	(codePtr),y
.8850	f5 58		sbc $58,x			sbc 	NSMantissa0,x
.8852	85 36		sta $36				sta 	zTemp0
.8854	c8		iny				iny
.8855	b1 30		lda ($30),y			lda 	(codePtr),y
.8857	f5 60		sbc $60,x			sbc 	NSMantissa1,x
.8859	05 36		ora $36				ora 	zTemp0
.885b	60		rts				rts
.885c					CLIsDigit:
.885c	b1 30		lda ($30),y			lda 	(codePtr),y
.885e	c9 30		cmp #$30			cmp 	#"0"
.8860	90 03		bcc $8865			bcc	 	_CLIDExitFalse
.8862	c9 3a		cmp #$3a			cmp 	#"9"+1
.8864	60		rts				rts
.8865					_CLIDExitFalse:
.8865	38		sec				sec
.8866	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/local.asm

.8867					Command_LOCAL:
.8867	a2 00		ldx #$00			ldx 	#0 							; at level 0
.8869	20 75 88	jsr $8875			jsr 	LocaliseNextTerm 			; convert term to a local.
.886c	b1 30		lda ($30),y			lda 	(codePtr),y
.886e	c8		iny				iny
.886f	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8871	f0 f4		beq $8867			beq 	Command_LOCAL
.8873	88		dey				dey 								; unpick pre-get
.8874	60		rts				rts
.8875					LocaliseNextTerm:
.8875	20 8e 97	jsr $978e			jsr 	EvaluateTerm 				; evaluate the term
.8878	b5 50		lda $50,x			lda 	NSStatus,x
.887a	29 20		and #$20			and 	#NSBIsReference 			; check it is a reference
.887c	f0 5c		beq $88da			beq		_LNTError
.887e	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address of variable to zTemp0
.8880	85 36		sta $36				sta 	zTemp0
.8882	b5 60		lda $60,x			lda 	NSMantissa1,x
.8884	85 37		sta $37				sta  	zTemp0+1
.8886	b5 50		lda $50,x			lda 	NSStatus,x
.8888	29 10		and #$10			and 	#NSBIsString
.888a	d0 1e		bne $88aa			bne 	_LNTPushString
.888c	5a		phy				phy
.888d	a0 00		ldy #$00			ldy 	#0 							; push 0 to 4 inclusive, the number values, on the stack, and zero them as you go.
.888f					_LNTPushNumLoop:
.888f	b1 36		lda ($36),y			lda		(zTemp0),y
.8891	20 6b a5	jsr $a56b			jsr 	StackPushByte
.8894	c8		iny				iny
.8895	c0 05		cpy #$05			cpy 	#5
.8897	d0 f6		bne $888f			bne 	_LNTPushNumLoop
.8899	a5 36		lda $36				lda 	zTemp0 						; push the actual target address to write on the stack
.889b	20 6b a5	jsr $a56b			jsr 	StackPushByte
.889e	a5 37		lda $37				lda 	zTemp0+1
.88a0	20 6b a5	jsr $a56b			jsr 	StackPushByte
.88a3	a9 01		lda #$01			lda 	#STK_LOCALN 				; push local-number marker.
.88a5	20 6b a5	jsr $a56b			jsr 	StackPushByte
.88a8	7a		ply				ply
.88a9	60		rts				rts
.88aa					_LNTPushString:
.88aa	5a		phy				phy
.88ab	b2 36		lda ($36)			lda 	(zTemp0) 					; put address of string in zTemp1
.88ad	85 38		sta $38				sta 	zTemp1
.88af	a0 01		ldy #$01			ldy 	#1
.88b1	b1 36		lda ($36),y			lda 	(zTemp0),y
.88b3	85 39		sta $39				sta 	zTemp1+1
.88b5	a0 00		ldy #$00			ldy 	#0 							; output string
.88b7	c9 00		cmp #$00			cmp 	#0 							; if not assigned strin
.88b9	f0 0a		beq $88c5			beq 	_LNTStringOut
.88bb					_LNTPushStrLoop:
.88bb	b1 38		lda ($38),y			lda 	(zTemp1),y
.88bd	f0 06		beq $88c5			beq 	_LNTStringOut
.88bf	20 6b a5	jsr $a56b			jsr 	StackPushByte
.88c2	c8		iny				iny
.88c3	80 f6		bra $88bb			bra 	_LNTPushStrLoop
.88c5					_LNTStringOut:
.88c5	98		tya				tya									; output length
.88c6	20 6b a5	jsr $a56b			jsr 	StackPushByte
.88c9	b5 58		lda $58,x			lda 	NSMantissa0,x 				; output address of the string record *not* the string itself
.88cb	20 6b a5	jsr $a56b			jsr 	StackPushByte
.88ce	b5 60		lda $60,x			lda 	NSMantissa1,x
.88d0	20 6b a5	jsr $a56b			jsr 	StackPushByte
.88d3	a9 02		lda #$02			lda 	#STK_LOCALS 				; push local-string marker.
.88d5	20 6b a5	jsr $a56b			jsr 	StackPushByte
.88d8	7a		ply				ply
.88d9	60		rts				rts
.88da					_LNTError:
.88da	4c c8 9e	jmp $9ec8			jmp 	SyntaxError
.88dd					LocalPopValue:
.88dd	20 84 a5	jsr $a584			jsr 	StackPopByte
.88e0	c9 01		cmp #$01			cmp 	#STK_LOCALN 				; if not local-N
.88e2	d0 17		bne $88fb			bne 	_LPVString
.88e4	20 84 a5	jsr $a584			jsr 	StackPopByte 				; address
.88e7	85 37		sta $37				sta 	zTemp0+1
.88e9	20 84 a5	jsr $a584			jsr 	StackPopByte
.88ec	85 36		sta $36				sta 	zTemp0
.88ee	5a		phy				phy
.88ef	a0 04		ldy #$04			ldy 	#4 							; copy back
.88f1					_LPVNumberCopy:
.88f1	20 84 a5	jsr $a584			jsr 	StackPopByte
.88f4	91 36		sta ($36),y			sta 	(zTemp0),y
.88f6	88		dey				dey
.88f7	10 f8		bpl $88f1			bpl 	_LPVNumberCopy
.88f9	7a		ply				ply 								; and complete
.88fa	60		rts				rts
.88fb					_LPVString:
.88fb	20 84 a5	jsr $a584			jsr 	StackPopByte 				; address of record => zTemp0
.88fe	85 37		sta $37				sta 	zTemp0+1
.8900	20 84 a5	jsr $a584			jsr 	StackPopByte
.8903	85 36		sta $36				sta 	zTemp0
.8905	5a		phy				phy
.8906	b2 36		lda ($36)			lda 	(zTemp0) 					; address to write string to => zTemp1
.8908	85 38		sta $38				sta 	zTemp1
.890a	a0 01		ldy #$01			ldy 	#1
.890c	b1 36		lda ($36),y			lda 	(zTemp0),y
.890e	85 39		sta $39				sta 	zTemp1+1
.8910	20 84 a5	jsr $a584			jsr 	StackPopByte 				; # to get => y
.8913	a8		tay				tay
.8914	a5 39		lda $39				lda 	zTemp1+1 					; if no target (e.g. was "" originally) exit
.8916	f0 0e		beq $8926			beq 	_LPVStringCopied
.8918	a9 00		lda #$00			lda 	#0 							; NULL on end
.891a	91 38		sta ($38),y			sta 	(zTemp1),y
.891c					_LPVStringCopy:
.891c	88		dey				dey
.891d	30 07		bmi $8926			bmi 	_LPVStringCopied
.891f	20 84 a5	jsr $a584			jsr 	StackPopByte
.8922	91 38		sta ($38),y			sta 	(zTemp1),y
.8924	80 f6		bra $891c			bra 	_LPVStringCopy
.8926					_LPVStringCopied:
.8926	fa		plx				plx
.8927	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/new.asm

.8928					NewCommand:
.8928	20 2e 89	jsr $892e			jsr 	NewProgram 					; does the actual NEW.
.892b	4c 6a 83	jmp $836a			jmp 	WarmStart 					; and warm starts straight away.
.892e					NewProgram:
.892e	20 98 a4	jsr $a498			jsr 	MemoryNew
.8931	9c 00 10	stz $1000			stz 	VariableSpace 				; erase all variables.
.8934	20 00 84	jsr $8400			jsr 	ClearCommand 				; clear everything.
.8937	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/procedure.asm

=2					ParameterStackPos = 2
.8938					CallProcedure:
.8938	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start storing parameters at 2.
.893a	b1 30		lda ($30),y			lda 	(codePtr),y
.893c	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.893e	f0 0c		beq $894c			beq 	_CPEndParam
.8940					_CPParamLoop:
.8940	20 95 9c	jsr $9c95			jsr 	EvaluateValue 				; get parameter onto stack
.8943	e8		inx				inx 								; bump next stack
.8944	b1 30		lda ($30),y			lda 	(codePtr),y
.8946	c8		iny				iny
.8947	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if comma, go back and try again.
.8949	f0 f5		beq $8940			beq 	_CPParamLoop
.894b	88		dey				dey 								; unpick.
.894c					_CPEndParam:
.894c	8e 16 04	stx $0416			stx 	LastParameter 				; save the last parameters index.
.894f	c8		iny				iny									; skip right bracket
.8950	a9 b3		lda #$b3			lda 	#STK_PROC+3 				; allocate 6 bytes on the return stack.
.8952	20 8d a5	jsr $a58d			jsr 	StackOpen
.8955	20 d1 a5	jsr $a5d1			jsr 	STKSaveCodePosition 		; save loop position
.8958	a5 58		lda $58				lda 	NSMantissa0 				; copy variable (e.g. procedure) address to zTemp0
.895a	85 36		sta $36				sta 	zTemp0 						; this is the DATA not the RECORD
.895c	a5 60		lda $60				lda 	NSMantissa1
.895e	85 37		sta $37				sta 	zTemp0+1
.8960	a0 01		ldy #$01			ldy 	#1 							; copy code address back.
.8962	b2 36		lda ($36)			lda 	(zTemp0)
.8964	85 30		sta $30				sta 	safePtr
.8966	b1 36		lda ($36),y			lda 	(zTemp0),y
.8968	85 31		sta $31				sta 	safePtr+1
.896a	c8		iny				iny
.896b	b1 36		lda ($36),y			lda 	(zTemp0),y
.896d	85 32		sta $32				sta 	safePtr+2
.896f	c8		iny				iny
.8970	b1 36		lda ($36),y			lda 	(zTemp0),y
.8972	85 33		sta $33				sta 	safePtr+3
.8974	c8		iny				iny 								; get Y offset -> Y
.8975	b1 36		lda ($36),y			lda 	(zTemp0),y
.8977	a8		tay				tay
.8978	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start position of parameters
.897a	ec 16 04	cpx $0416			cpx	 	LastParameter 				; check no parameters at the start
.897d	f0 13		beq $8992			beq 	_ParamExit 					; if so, exit.
.897f					_ParamExtract:
.897f	ca		dex				dex 								; put a local term on the level before
.8980	20 75 88	jsr $8875			jsr 	LocaliseNextTerm			; also pushes original param value to basic stack
.8983	20 b9 87	jsr $87b9			jsr 	AssignVariable 				; assign stacked value to the variable.
.8986	e8		inx				inx 								; advance to next parameter to do.
.8987	e8		inx				inx
.8988	ec 16 04	cpx $0416			cpx 	LastParameter 				; are we done ?
.898b	f0 05		beq $8992			beq 	_ParamExit
.898d	20 2f 8e	jsr $8e2f			jsr 	CheckComma 					; comma seperating parameters
.8990	80 ed		bra $897f			bra 	_ParamExtract
.8992					_ParamExit:
.8992	20 27 8e	jsr $8e27			jsr 	CheckRightBracket 			; check )
.8995	60		rts				rts 								; and continue from here
.8996					Command_ENDPROC:
.8996	a9 b0		lda #$b0			lda 	#STK_PROC 					; check TOS is this
.8998	a2 14		ldx #$14			ldx 	#ERRID_PROC
.899a	20 b9 a5	jsr $a5b9			jsr 	StackCheckFrame
.899d	20 e2 a5	jsr $a5e2			jsr 	STKLoadCodePosition 		; restore code position
.89a0	20 ab a5	jsr $a5ab			jsr 	StackClose
.89a3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/read.asm

.89a4					Command_Read:
.89a4	a2 00		ldx #$00			ldx 	#0 							; evaluate the term which is the var/array element to assign
.89a6	20 8e 97	jsr $978e			jsr 	EvaluateTerm
.89a9	b5 50		lda $50,x			lda 	NSStatus,x
.89ab	29 20		and #$20			and 	#NSBIsReference				; get status byte on stack, identifies int, float, string.
.89ad	f0 4a		beq $89f9			beq 	_CRSyntax 					; check reference (bit 0)
.89af	20 42 8a	jsr $8a42			jsr 	SwapDataCodePtrs 			; swap code and data
.89b2	ad 1c 04	lda $041c			lda 	inDataStatement 			; if in a data statement, we don't need to search
.89b5	d0 20		bne $89d7			bne 	_CRContinueData
.89b7					_CRKeepSearching:
.89b7	a9 b2		lda #$b2			lda 	#KWD_DATA 					; scan for instruction
.89b9	aa		tax				tax
.89ba	20 1f 8d	jsr $8d1f			jsr 	ScanForward
.89bd	c9 b2		cmp #$b2			cmp 	#KWD_DATA 					; found data ?
.89bf	f0 16		beq $89d7			beq 	_CRHaveData 				; found it
.89c1	18		clc				clc
.89c2	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.89c4	65 30		adc $30				adc 	codePtr
.89c6	85 30		sta $30				sta 	codePtr
.89c8	90 02		bcc $89cc			bcc 	_CREExit
.89ca	e6 31		inc $31				inc 	codePtr+1 					; carry
.89cc					_CREExit:
.89cc	a0 03		ldy #$03			ldy 	#3 							; start of line.
.89ce	b2 30		lda ($30)			lda 	(codePtr)
.89d0	d0 e5		bne $89b7			bne 	_CRKeepSearching
.89d2	a9 0b		lda #$0b		lda	#11
.89d4	4c 40 8e	jmp $8e40		jmp	ErrorHandler
.89d7					_CRHaveData:
.89d7					_CRContinueData:
.89d7	a2 01		ldx #$01			ldx 	#1
.89d9	20 95 9c	jsr $9c95			jsr 	EvaluateValue 				; evaluate value into slot # 1
.89dc	ca		dex				dex
.89dd	20 b9 87	jsr $87b9			jsr		AssignVariable 				; do the assignment
.89e0	9c 1c 04	stz $041c			stz 	inDataStatement 			; clear in data
.89e3	b1 30		lda ($30),y			lda 	(codePtr),y
.89e5	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not, end of data statement
.89e7	d0 04		bne $89ed			bne 	_CRSwapBack
.89e9	c8		iny				iny 								; consume comma
.89ea	ee 1c 04	inc $041c			inc 	inDataStatement 			; set in data statement currently.
.89ed					_CRSwapBack:
.89ed	20 42 8a	jsr $8a42			jsr 	SwapDataCodePtrs			; swap them back.
.89f0	b1 30		lda ($30),y			lda 	(codePtr),y
.89f2	c8		iny				iny
.89f3	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.89f5	f0 ad		beq $89a4			beq 	Command_Read 				; if so go round again.
.89f7	88		dey				dey 								; unpick get.
.89f8	60		rts				rts
.89f9					_CRSyntax:
.89f9	4c c8 9e	jmp $9ec8			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/rem.asm

.89fc					RemCommand:
.89fc	b1 30		lda ($30),y			lda 	(codePtr),y
.89fe	c9 ff		cmp #$ff			cmp 	#KWC_STRING
.8a00	d0 06		bne $8a08			bne 	_RMExit
.8a02	c8		iny				iny 								; point to offset
.8a03	98		tya				tya 								; A = offset position
.8a04	38		sec				sec 								; add size +1 hence SEC
.8a05	71 30		adc ($30),y			adc 	(codePtr),y
.8a07	a8		tay				tay 								; make current position.
.8a08					_RMExit:
.8a08	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/repeat.asm

.8a09					Command_REPEAT:
.8a09	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; allocate 6 bytes on the return stack.
.8a0b	20 8d a5	jsr $a58d			jsr 	StackOpen
.8a0e	20 d1 a5	jsr $a5d1			jsr 	STKSaveCodePosition 		; save loop position
.8a11	60		rts				rts
.8a12					Command_UNTIL:
.8a12	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; check REPEAT is TOS
.8a14	a2 0f		ldx #$0f			ldx 	#ERRID_REPEAT 				; this error
.8a16	20 b9 a5	jsr $a5b9			jsr 	StackCheckFrame
.8a19	a2 00		ldx #$00			ldx 	#0
.8a1b	20 9e 9c	jsr $9c9e			jsr 	EvaluateNumber 				; work out the number
.8a1e	20 72 9d	jsr $9d72			jsr 	NSMIsZero 					; check if zero
.8a21	f0 04		beq $8a27			beq 	_CULoopBack 				; if so keep looping
.8a23	20 ab a5	jsr $a5ab			jsr 	StackClose		 			; return
.8a26	60		rts				rts
.8a27					_CULoopBack:
.8a27	20 e2 a5	jsr $a5e2			jsr 	STKLoadCodePosition 		; loop back
.8a2a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/restore.asm

.8a2b					Command_Restore:
.8a2b	20 42 8a	jsr $8a42			jsr 	SwapDataCodePtrs 			; swap code and data
.8a2e	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8a30	85 30		sta $30				sta 	codePtr
.8a32	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8a34	85 31		sta $31				sta 	codePtr+1
.8a36	20 42 8a	jsr $8a42			jsr 	SwapDataCodePtrs 			; put them back
.8a39	a9 03		lda #$03			lda 	#3 							; start at offset 3, e.g. first instruction of first line.
.8a3b	8d 1b 04	sta $041b			sta 	dataPointer+4
.8a3e	9c 1c 04	stz $041c			stz 	inDataStatement 			; not in data statement
.8a41	60		rts				rts
.8a42					SwapDataCodePtrs:
.8a42	da		phx				phx
.8a43	a2 03		ldx #$03			ldx 	#3 							; swap 32 bit code pointer over
.8a45					_SDCPLoop:
.8a45	b5 30		lda $30,x			lda 	safePtr,x
.8a47	48		pha				pha
.8a48	bd 17 04	lda $0417,x			lda 	dataPointer,x
.8a4b	95 30		sta $30,x			sta 	safePtr,x
.8a4d	68		pla				pla
.8a4e	9d 17 04	sta $0417,x			sta 	dataPointer,x
.8a51	ca		dex				dex
.8a52	10 f1		bpl $8a45			bpl 	_SDCPLoop
.8a54	ad 1b 04	lda $041b			lda 	dataPointer+4 				; swap Y position over.
.8a57	8c 1b 04	sty $041b			sty 	dataPointer+4
.8a5a	a8		tay				tay
.8a5b	fa		plx				plx
.8a5c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/run.asm

.8a5d					EOLCommand:
.8a5d	18		clc				clc
.8a5e	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8a60	65 30		adc $30				adc 	codePtr
.8a62	85 30		sta $30				sta 	codePtr
.8a64	90 02		bcc $8a68			bcc 	_CREExit
.8a66	e6 31		inc $31				inc 	codePtr+1 					; carry
.8a68					_CREExit:
.8a68	80 0b		bra $8a75			bra 	RunNewLine
.8a6a					CommandRUN:
.8a6a	20 00 84	jsr $8400			jsr 	ClearCommand 				; clear variable/stacks/etc.
.8a6d	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8a6f	85 30		sta $30				sta 	codePtr
.8a71	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8a73	85 31		sta $31				sta 	codePtr+1
.8a75					RUNNewLine:
.8a75	b2 30		lda ($30)			lda 	(codePtr)
.8a77	f0 72		beq $8aeb			beq 	CRNoProgram         		; no then END.
.8a79	a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack
.8a7b	9a		txs				txs
.8a7c					RUNCodePointerLine:
.8a7c	a0 02		ldy #$02			ldy 	#2 							; start of program
.8a7e					_CRIncMainLoop:
.8a7e	0e 13 04	asl $0413			asl 	breakCheck 					; clears 1 time in 8
.8a81	d0 19		bne $8a9c			bne 	_CRNoBreakCheck
.8a83	20 7a a9	jsr $a97a			jsr 	EXTBreakCheck 				; break check
.8a86	f0 5e		beq $8ae6			beq 	_CRBreak
.8a88	64 01		stz $01				stz 	1 							; access I/O Page 0
.8a8a	38		sec				sec 								; calculate timer - LastTick
.8a8b	ad 59 d6	lda $d659			lda 	$D659
.8a8e	aa		tax				tax 								; saving timer in X
.8a8f	ed af 05	sbc $05af			sbc 	LastTick
.8a92	c9 03		cmp #$03			cmp 	#3
.8a94	90 06		bcc $8a9c			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.8a96	8e af 05	stx $05af			stx 	LastTick 					; update last timer
.8a99	20 10 b9	jsr $b910			jsr 	TickHandler 				; go do the code.
.8a9c					_NoFireTick:
.8a9c					_CRNoBreakCheck:
.8a9c	c8		iny				iny
.8a9d					_CRMainLoop:
.8a9d	9c 10 04	stz $0410			stz 	stringInitialised 			; clear the temporary string initialised flag.
.8aa0	b1 30		lda ($30),y			lda 	(codePtr),y
.8aa2	10 10		bpl $8ab4			bpl 	_CRNotKeyword
.8aa4	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1 			; if after unary, legitimate command
.8aa6	b0 04		bcs $8aac			bcs 	_CRIsKeyword
.8aa8	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if unary, syntax error.
.8aaa	b0 34		bcs $8ae0			bcs		_CRSyntaxError
.8aac					_CRIsKeyword:
.8aac	c8		iny				iny 								; consume command
.8aad	0a		asl a				asl 	a 							; double losing the MSB which is '1' as tokens are $80-$FF
.8aae	aa		tax				tax 								; put in X for vector jump
.8aaf	20 e3 8a	jsr $8ae3			jsr 	_CRCallVector0 				; call the vector - effectively jsr (vectortable,X)
.8ab2	80 e9		bra $8a9d			bra 	_CRMainLoop 				; and loop round
.8ab4					_CRNotKeyword:
.8ab4	c9 3a		cmp #$3a			cmp 	#KWD_COLON 					; if a :, consume it and go round.
.8ab6	f0 c6		beq $8a7e			beq 	_CRIncMainLoop
.8ab8	c9 40		cmp #$40			cmp 	#$40 						; variable/call reference
.8aba	90 05		bcc $8ac1			bcc 	_CRNotVariable
.8abc					_CRGoLet:
.8abc	20 80 87	jsr $8780			jsr 	LetCommand
.8abf	80 dc		bra $8a9d			bra 	_CRMainLoop
.8ac1					_CRNotVariable:
.8ac1	c9 10		cmp #$10			cmp 	#KWD_AT 					; handle @
.8ac3	f0 f7		beq $8abc			beq 	_CRGoLet
.8ac5	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; handle ? !
.8ac7	f0 f3		beq $8abc			beq 	_CRGoLet
.8ac9	c9 21		cmp #$21			cmp 	#KWD_PLING
.8acb	f0 ef		beq $8abc			beq 	_CRGoLet
.8acd	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; handle ' (comment)
.8acf	f0 09		beq $8ada			beq 	_CRGoRem
.8ad1	c9 2e		cmp #$2e			cmp 	#KWD_PERIOD 				; handle . (assembler label)
.8ad3	d0 0b		bne $8ae0			bne 	_CRSyntaxError
.8ad5	20 03 82	jsr $8203			jsr 	LabelHere
.8ad8	80 c3		bra $8a9d			bra 	_CRMainLoop
.8ada					_CRGoRem:
.8ada	c8		iny				iny
.8adb	20 fc 89	jsr $89fc			jsr 	RemCommand
.8ade	80 bd		bra $8a9d			bra 	_CRMainLoop
.8ae0					_CRSyntaxError:
.8ae0	4c c8 9e	jmp $9ec8			jmp 	SyntaxError
.8ae3					_CRCallVector0:
.8ae3	7c 82 8b	jmp ($8b82,x)			jmp 	(VectorSet0,x)
.8ae6					_CRBreak:
.8ae6	a9 01		lda #$01		lda	#1
.8ae8	4c 40 8e	jmp $8e40		jmp	ErrorHandler
.8aeb					CRNoProgram:
.8aeb	4c 25 85	jmp $8525			jmp 	EndCommand
.8aee					Shift1Command:
.8aee	b1 30		lda ($30),y			lda 	(codePtr),y
.8af0	c8		iny				iny
.8af1	0a		asl a				asl 	a
.8af2	aa		tax				tax
.8af3	7c 20 8c	jmp ($8c20,x)			jmp 	(VectorSet1,x)
.8af6					Shift2Command:
.8af6	b1 30		lda ($30),y			lda 	(codePtr),y
.8af8	c8		iny				iny
.8af9	0a		asl a				asl 	a
.8afa	aa		tax				tax
.8afb	7c 40 8c	jmp ($8c40,x)			jmp 	(VectorSet2,x)
.8afe					Unused1:
.8afe					Unused2:
.8afe					Unused3:
.8afe					Unused4:
.8afe	4c c8 9e	jmp $9ec8			jmp 	SyntaxError
>8b01							.align 2

;******  Processing file: ./common/commands/../generated/vectors.dat

.8b02					VectorSetPunc:
>8b02	f8 90					.word	ShiftLeft                        ; $00 <<
>8b04	e3 8e					.word	BinaryCompareLessEqual           ; $01 <=
>8b06	d9 8e					.word	BinaryCompareNotEqual            ; $02 <>
>8b08	c8 9e					.word	SyntaxError                      ; $03 !!3
>8b0a	c8 9e					.word	SyntaxError                      ; $04 ><
>8b0c	ed 8e					.word	BinaryCompareGreaterEqual        ; $05 >=
>8b0e	fb 90					.word	ShiftRight                       ; $06 >>
>8b10	c8 9e					.word	SyntaxError                      ; $07 !!7
>8b12	c8 9e					.word	SyntaxError                      ; $08 !!8
>8b14	c8 9e					.word	SyntaxError                      ; $09 !!9
>8b16	c8 9e					.word	SyntaxError                      ; $0a !!10
>8b18	c8 9e					.word	SyntaxError                      ; $0b !!11
>8b1a	c8 9e					.word	SyntaxError                      ; $0c !!12
>8b1c	c8 9e					.word	SyntaxError                      ; $0d !!13
>8b1e	c8 9e					.word	SyntaxError                      ; $0e !!14
>8b20	c8 9e					.word	SyntaxError                      ; $0f !!15
>8b22	c8 9e					.word	SyntaxError                      ; $10 @
>8b24	c8 9e					.word	SyntaxError                      ; $11 !!17
>8b26	c8 9e					.word	SyntaxError                      ; $12 !!18
>8b28	c8 9e					.word	SyntaxError                      ; $13 [
>8b2a	a4 8f					.word	IntegerDivide                    ; $14 \
>8b2c	c8 9e					.word	SyntaxError                      ; $15 ]
>8b2e	36 92					.word	EorInteger                       ; $16 ^
>8b30	c8 9e					.word	SyntaxError                      ; $17 _
>8b32	c8 9e					.word	SyntaxError                      ; $18 `
>8b34	c8 9e					.word	SyntaxError                      ; $19 !!25
>8b36	c8 9e					.word	SyntaxError                      ; $1a !!26
>8b38	c8 9e					.word	SyntaxError                      ; $1b {
>8b3a	01 92					.word	OraInteger                       ; $1c |
>8b3c	c8 9e					.word	SyntaxError                      ; $1d }
>8b3e	c8 9e					.word	SyntaxError                      ; $1e ~
>8b40	c8 9e					.word	SyntaxError                      ; $1f [7m<7F>[m
>8b42	c8 9e					.word	SyntaxError                      ; $20
>8b44	6b 92					.word	WordIndirect                     ; $21 !
>8b46	c8 9e					.word	SyntaxError                      ; $22 "
>8b48	c8 9e					.word	SyntaxError                      ; $23 #
>8b4a	c8 9e					.word	SyntaxError                      ; $24 $
>8b4c	e5 8f					.word	IntegerModulus                   ; $25 %
>8b4e	cc 91					.word	AndInteger                       ; $26 &
>8b50	c8 9e					.word	SyntaxError                      ; $27 '
>8b52	c8 9e					.word	SyntaxError                      ; $28 (
>8b54	c8 9e					.word	SyntaxError                      ; $29 )
>8b56	53 90					.word	MulInteger                       ; $2a *
>8b58	6e 91					.word	AddInteger                       ; $2b +
>8b5a	c8 9e					.word	SyntaxError                      ; $2c ,
>8b5c	a7 91					.word	SubInteger                       ; $2d -
>8b5e	c8 9e					.word	SyntaxError                      ; $2e .
>8b60	25 94					.word	FDivideCommand                   ; $2f /
>8b62	c8 9e					.word	SyntaxError                      ; $30 0
>8b64	c8 9e					.word	SyntaxError                      ; $31 1
>8b66	c8 9e					.word	SyntaxError                      ; $32 2
>8b68	c8 9e					.word	SyntaxError                      ; $33 3
>8b6a	c8 9e					.word	SyntaxError                      ; $34 4
>8b6c	c8 9e					.word	SyntaxError                      ; $35 5
>8b6e	c8 9e					.word	SyntaxError                      ; $36 6
>8b70	c8 9e					.word	SyntaxError                      ; $37 7
>8b72	c8 9e					.word	SyntaxError                      ; $38 8
>8b74	c8 9e					.word	SyntaxError                      ; $39 9
>8b76	c8 9e					.word	SyntaxError                      ; $3a :
>8b78	c8 9e					.word	SyntaxError                      ; $3b ;
>8b7a	c5 8e					.word	BinaryCompareLess                ; $3c <
>8b7c	bb 8e					.word	BinaryCompareEqual               ; $3d =
>8b7e	cf 8e					.word	BinaryCompareGreater             ; $3e >
>8b80	8d 92					.word	ByteIndirect                     ; $3f ?
.8b82					VectorSet0:
>8b82	5d 8a					.word	EOLCommand                       ; $80 !0:EOF
>8b84	ee 8a					.word	Shift1Command                    ; $81 !1:SH1
>8b86	f6 8a					.word	Shift2Command                    ; $82 !2:SH2
>8b88	0a 99					.word	AbsUnary                         ; $83 ABS(
>8b8a	18 99					.word	AllocUnary                       ; $84 ALLOC(
>8b8c	88 99					.word	AscUnary                         ; $85 ASC(
>8b8e	36 9b					.word	ChrUnary                         ; $86 CHR$(
>8b90	18 a3					.word	UnaryEvent                       ; $87 EVENT(
>8b92	b7 8e					.word	UnaryFalse                       ; $88 FALSE
>8b94	95 99					.word	FracUnary                        ; $89 FRAC(
>8b96	b4 a2					.word	UnaryHit                         ; $8a HIT(
>8b98	aa 99					.word	IntUnary                         ; $8b INT(
>8b9a	f5 9a					.word	IsValUnary                       ; $8c ISVAL(
>8b9c	9c a3					.word	UnaryJoyB                        ; $8d JOYB(
>8b9e	75 a3					.word	UnaryJoyX                        ; $8e JOYX(
>8ba0	78 a3					.word	UnaryJoyY                        ; $8f JOYY(
>8ba2	09 9c					.word	Unary_Left                       ; $90 LEFT$(
>8ba4	bb 99					.word	LenUnary                         ; $91 LEN(
>8ba6	d9 99					.word	Unary_Max                        ; $92 MAX(
>8ba8	2b 9c					.word	Unary_Mid                        ; $93 MID$(
>8baa	d5 99					.word	Unary_Min                        ; $94 MIN(
>8bac	24 9a					.word	Unary_Not                        ; $95 NOT(
>8bae	e9 a4					.word	UnaryPlaying                     ; $96 PLAYING(
>8bb0	3a 9a					.word	Unary_Random                     ; $97 RANDOM(
>8bb2	16 9c					.word	Unary_Right                      ; $98 RIGHT$(
>8bb4	57 9a					.word	Unary_Rnd                        ; $99 RND(
>8bb6	cd 9a					.word	SgnUnary                         ; $9a SGN(
>8bb8	48 9b					.word	SpcUnary                         ; $9b SPC(
>8bba	63 9b					.word	Unary_Str                        ; $9c STR$(
>8bbc	c2 a3					.word	UnaryTimer                       ; $9d TIMER(
>8bbe	ac 8e					.word	UnaryTrue                        ; $9e TRUE
>8bc0	eb 9a					.word	ValUnary                         ; $9f VAL(
>8bc2	28 85					.word	ForCommand                       ; $a0 FOR
>8bc4	6b 86					.word	IfCommand                        ; $a1 IF
>8bc6	fe 8a					.word	Unused1                          ; $a2 PROC
>8bc8	09 8a					.word	Command_REPEAT                   ; $a3 REPEAT
>8bca	95 8d					.word	Command_WHILE                    ; $a4 WHILE
>8bcc	94 86					.word	EndIf                            ; $a5 ENDIF
>8bce	96 89					.word	Command_ENDPROC                  ; $a6 ENDPROC
>8bd0	da 85					.word	NextCommand                      ; $a7 NEXT
>8bd2	fe 8a					.word	Unused4                          ; $a8 THEN
>8bd4	12 8a					.word	Command_UNTIL                    ; $a9 UNTIL
>8bd6	b6 8d					.word	Command_WEND                     ; $aa WEND
>8bd8	c8 9e					.word	SyntaxError                      ; $ab BY
>8bda	cb 83					.word	CallCommand                      ; $ac CALL
>8bdc	68 a0					.word	CircleCommand                    ; $ad CIRCLE
>8bde	00 84					.word	ClearCommand                     ; $ae CLEAR
>8be0	58 84					.word	ClearScreen                      ; $af CLS
>8be2	c8 9e					.word	SyntaxError                      ; $b0 COLOR
>8be4	c8 9e					.word	SyntaxError                      ; $b1 COLOUR
>8be6	60 84					.word	Command_Data                     ; $b2 DATA
>8be8	68 84					.word	DimCommand                       ; $b3 DIM
>8bea	fe 8a					.word	Unused3                          ; $b4 DOWNTO
>8bec	8d 86					.word	ElseCode                         ; $b5 ELSE
>8bee	c8 9e					.word	SyntaxError                      ; $b6 FROM
>8bf0	87 a2					.word	GfxCommand                       ; $b7 GFX
>8bf2	33 86					.word	Command_GOSUB                    ; $b8 GOSUB
>8bf4	51 86					.word	GotoCommand                      ; $b9 GOTO
>8bf6	c8 9e					.word	SyntaxError                      ; $ba HERE
>8bf8	91 a0					.word	ImageCommand                     ; $bb IMAGE
>8bfa	95 86					.word	Command_Input                    ; $bc INPUT
>8bfc	80 87					.word	LetCommand                       ; $bd LET
>8bfe	e3 a0					.word	LineCommand                      ; $be LINE
>8c00	67 88					.word	Command_LOCAL                    ; $bf LOCAL
>8c02	c8 9e					.word	SyntaxError                      ; $c0 OFF
>8c04	c8 9e					.word	SyntaxError                      ; $c1 ON
>8c06	c8 9e					.word	SyntaxError                      ; $c2 OUTLINE
>8c08	d8 a2					.word	PaletteCommand                   ; $c3 PALETTE
>8c0a	dc a0					.word	PlotCommand                      ; $c4 PLOT
>8c0c	9c 86					.word	Command_Print                    ; $c5 PRINT
>8c0e	a4 89					.word	Command_Read                     ; $c6 READ
>8c10	64 a0					.word	RectangleCommand                 ; $c7 RECT
>8c12	fc 89					.word	RemCommand                       ; $c8 REM
>8c14	43 86					.word	Command_RETURN                   ; $c9 RETURN
>8c16	c8 9e					.word	SyntaxError                      ; $ca SOLID
>8c18	05 a5					.word	SoundCommand                     ; $cb SOUND
>8c1a	73 a0					.word	SpriteCommand                    ; $cc SPRITE
>8c1c	ad a0					.word	TextCommand                      ; $cd TEXT
>8c1e	fe 8a					.word	Unused2                          ; $ce TO
.8c20					VectorSet1:
>8c20	c8 9e					.word	SyntaxError                      ; $80 !0:EOF
>8c22	c8 9e					.word	SyntaxError                      ; $81 !1:SH1
>8c24	c8 9e					.word	SyntaxError                      ; $82 !2:SH2
>8c26	9f 83					.word	AssembleCommand                  ; $83 ASSEMBLE
>8c28	bb 83					.word	AssertCommand                    ; $84 ASSERT
>8c2a	27 a2					.word	BitmapCtrl                       ; $85 BITMAP
>8c2c	25 85					.word	EndCommand                       ; $86 END
>8c2e	b9 a3					.word	GoCommand                        ; $87 GO
>8c30	d0 87					.word	Command_List                     ; $88 LIST
>8c32	b0 a3					.word	LoadCommand                      ; $89 LOAD
>8c34	28 89					.word	NewCommand                       ; $8a NEW
>8c36	2b 8a					.word	Command_Restore                  ; $8b RESTORE
>8c38	6a 8a					.word	CommandRUN                       ; $8c RUN
>8c3a	6c a2					.word	SpritesCtrl                      ; $8d SPRITES
>8c3c	c8 8c					.word	StopCommand                      ; $8e STOP
>8c3e	c4 8d					.word	WhoCommand                       ; $8f WHO
.8c40					VectorSet2:
>8c40	c8 9e					.word	SyntaxError                      ; $80 !0:EOF
>8c42	c8 9e					.word	SyntaxError                      ; $81 !1:SH1
>8c44	c8 9e					.word	SyntaxError                      ; $82 !2:SH2
>8c46	87 9d					.word	Assemble_adc                     ; $83 ADC
>8c48	7f 9d					.word	Assemble_and                     ; $84 AND
>8c4a	9b 9d					.word	Assemble_asl                     ; $85 ASL
>8c4c	05 9e					.word	Assemble_bcc                     ; $86 BCC
>8c4e	09 9e					.word	Assemble_bcs                     ; $87 BCS
>8c50	11 9e					.word	Assemble_beq                     ; $88 BEQ
>8c52	c8 9d					.word	Assemble_bit                     ; $89 BIT
>8c54	f9 9d					.word	Assemble_bmi                     ; $8a BMI
>8c56	0d 9e					.word	Assemble_bne                     ; $8b BNE
>8c58	f5 9d					.word	Assemble_bpl                     ; $8c BPL
>8c5a	15 9e					.word	Assemble_bra                     ; $8d BRA
>8c5c	19 9e					.word	Assemble_brk                     ; $8e BRK
>8c5e	fd 9d					.word	Assemble_bvc                     ; $8f BVC
>8c60	01 9e					.word	Assemble_bvs                     ; $90 BVS
>8c62	21 9e					.word	Assemble_clc                     ; $91 CLC
>8c64	75 9e					.word	Assemble_cld                     ; $92 CLD
>8c66	35 9e					.word	Assemble_cli                     ; $93 CLI
>8c68	65 9e					.word	Assemble_clv                     ; $94 CLV
>8c6a	93 9d					.word	Assemble_cmp                     ; $95 CMP
>8c6c	dc 9d					.word	Assemble_cpx                     ; $96 CPX
>8c6e	d7 9d					.word	Assemble_cpy                     ; $97 CPY
>8c70	b9 9d					.word	Assemble_dec                     ; $98 DEC
>8c72	71 9e					.word	Assemble_dex                     ; $99 DEX
>8c74	4d 9e					.word	Assemble_dey                     ; $9a DEY
>8c76	83 9d					.word	Assemble_eor                     ; $9b EOR
>8c78	be 9d					.word	Assemble_inc                     ; $9c INC
>8c7a	81 9e					.word	Assemble_inx                     ; $9d INX
>8c7c	6d 9e					.word	Assemble_iny                     ; $9e INY
>8c7e	f0 9d					.word	Assemble_jmp                     ; $9f JMP
>8c80	eb 9d					.word	Assemble_jsr                     ; $a0 JSR
>8c82	8f 9d					.word	Assemble_lda                     ; $a1 LDA
>8c84	b4 9d					.word	Assemble_ldx                     ; $a2 LDX
>8c86	d2 9d					.word	Assemble_ldy                     ; $a3 LDY
>8c88	a5 9d					.word	Assemble_lsr                     ; $a4 LSR
>8c8a	85 9e					.word	Assemble_nop                     ; $a5 NOP
>8c8c	7b 9d					.word	Assemble_ora                     ; $a6 ORA
>8c8e	31 9e					.word	Assemble_pha                     ; $a7 PHA
>8c90	1d 9e					.word	Assemble_php                     ; $a8 PHP
>8c92	79 9e					.word	Assemble_phx                     ; $a9 PHX
>8c94	39 9e					.word	Assemble_phy                     ; $aa PHY
>8c96	41 9e					.word	Assemble_pla                     ; $ab PLA
>8c98	25 9e					.word	Assemble_plp                     ; $ac PLP
>8c9a	8d 9e					.word	Assemble_plx                     ; $ad PLX
>8c9c	49 9e					.word	Assemble_ply                     ; $ae PLY
>8c9e	a0 9d					.word	Assemble_rol                     ; $af ROL
>8ca0	aa 9d					.word	Assemble_ror                     ; $b0 ROR
>8ca2	2d 9e					.word	Assemble_rti                     ; $b1 RTI
>8ca4	3d 9e					.word	Assemble_rts                     ; $b2 RTS
>8ca6	97 9d					.word	Assemble_sbc                     ; $b3 SBC
>8ca8	29 9e					.word	Assemble_sec                     ; $b4 SEC
>8caa	89 9e					.word	Assemble_sed                     ; $b5 SED
>8cac	45 9e					.word	Assemble_sei                     ; $b6 SEI
>8cae	8b 9d					.word	Assemble_sta                     ; $b7 STA
>8cb0	7d 9e					.word	Assemble_stp                     ; $b8 STP
>8cb2	af 9d					.word	Assemble_stx                     ; $b9 STX
>8cb4	cd 9d					.word	Assemble_sty                     ; $ba STY
>8cb6	c3 9d					.word	Assemble_stz                     ; $bb STZ
>8cb8	61 9e					.word	Assemble_tax                     ; $bc TAX
>8cba	5d 9e					.word	Assemble_tay                     ; $bd TAY
>8cbc	e6 9d					.word	Assemble_trb                     ; $be TRB
>8cbe	e1 9d					.word	Assemble_tsb                     ; $bf TSB
>8cc0	69 9e					.word	Assemble_tsx                     ; $c0 TSX
>8cc2	51 9e					.word	Assemble_txa                     ; $c1 TXA
>8cc4	59 9e					.word	Assemble_txs                     ; $c2 TXS
>8cc6	55 9e					.word	Assemble_tya                     ; $c3 TYA

;******  Return to file: ./common/commands/run.asm


;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/stop.asm

.8cc8					StopCommand:
.8cc8	a9 08		lda #$08		lda	#8
.8cca	4c 40 8e	jmp $8e40		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/procscan.asm

.8ccd					ProcedureScan:
.8ccd	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8ccf	85 30		sta $30				sta 	codePtr
.8cd1	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8cd3	85 31		sta $31				sta 	codePtr+1
.8cd5					_PSLoop:
.8cd5	b2 30		lda ($30)			lda 	(codePtr)
.8cd7	f0 42		beq $8d1b			beq 	_PSExit
.8cd9	a0 03		ldy #$03			ldy 	#3 							; is it PROC ?
.8cdb	b1 30		lda ($30),y			lda 	(codePtr),y
.8cdd	c9 a2		cmp #$a2			cmp 	#KWD_PROC
.8cdf	d0 2d		bne $8d0e			bne 	_PSNext
.8ce1	c8		iny				iny 								; get the address of the record to zTemp0 and
.8ce2	b1 30		lda ($30),y			lda 	(codePtr),y
.8ce4	29 c0		and #$c0			and 	#$C0
.8ce6	c9 40		cmp #$40			cmp 	#$40
.8ce8	d0 32		bne $8d1c			bne 	_PSSyntax
.8cea	b1 30		lda ($30),y			lda 	(codePtr),y
.8cec	18		clc				clc
.8ced	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8cef	85 37		sta $37				sta 	zTemp0+1
.8cf1	c8		iny				iny 								; LSB
.8cf2	b1 30		lda ($30),y			lda 	(codePtr),y
.8cf4	85 36		sta $36				sta 	zTemp0
.8cf6	c8		iny				iny 								; character after variable call.
.8cf7	98		tya				tya 								; save Y offset at +7
.8cf8	a0 07		ldy #$07			ldy 	#7
.8cfa	91 36		sta ($36),y			sta 	(zTemp0),y
.8cfc	a9 18		lda #$18			lda 	#NSTProcedure 				; mark it as procedure
.8cfe	a0 02		ldy #$02			ldy 	#2
.8d00	91 36		sta ($36),y			sta 	(zTemp0),y
.8d02	a2 00		ldx #$00			ldx 	#0 							; copy code-Ptr in
.8d04					_PSCopy:
.8d04	b5 30		lda $30,x			lda 	safePtr,x
.8d06	c8		iny				iny
.8d07	91 36		sta ($36),y			sta 	(zTemp0),y
.8d09	e8		inx				inx
.8d0a	e0 04		cpx #$04			cpx 	#4
.8d0c	d0 f6		bne $8d04			bne 	_PSCopy
.8d0e					_PSNext:
.8d0e	18		clc				clc
.8d0f	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8d11	65 30		adc $30				adc 	codePtr
.8d13	85 30		sta $30				sta 	codePtr
.8d15	90 02		bcc $8d19			bcc 	_CREExit
.8d17	e6 31		inc $31				inc 	codePtr+1 					; carry
.8d19					_CREExit:
.8d19	80 ba		bra $8cd5			bra 	_PSLoop
.8d1b					_PSExit:
.8d1b	60		rts				rts
.8d1c					_PSSyntax:
.8d1c	4c c8 9e	jmp $9ec8			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/scanforward.asm

.8d1f					ScanForward:
.8d1f	64 38		stz $38				stz 	zTemp1 						; this is the structure count - goes up with WHILE/FOR
.8d21	86 37		stx $37				stx 	zTemp0+1
.8d23	85 36		sta $36				sta 	zTemp0 						; save XA as the two possible matches.
.8d25					_ScanLoop:
.8d25	b1 30		lda ($30),y			lda 	(codePtr),y
.8d27	c8		iny				iny
.8d28	a6 38		ldx $38				ldx 	zTemp1 						; if the count is > 0 cannot match as in substructure
.8d2a	d0 0e		bne $8d3a			bne 	_ScanGoNext
.8d2c	c5 36		cmp $36				cmp 	zTemp0 						; see if either matches
.8d2e	f0 04		beq $8d34			beq 	_ScanMatch
.8d30	c5 37		cmp $37				cmp 	zTemp0+1
.8d32	d0 06		bne $8d3a			bne 	_ScanGoNext
.8d34					_ScanMatch:
.8d34	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if asked for EOL, backtrack.
.8d36	d0 01		bne $8d39			bne 	_ScanNotEndEOL
.8d38	88		dey				dey
.8d39					_ScanNotEndEOL:
.8d39	60		rts				rts
.8d3a					_ScanGoNext:
.8d3a	20 3f 8d	jsr $8d3f			jsr  	ScanForwardOne
.8d3d	80 e6		bra $8d25			bra 	_ScanLoop
.8d3f					ScanForwardOne:
.8d3f	c9 40		cmp #$40			cmp 	#$40 						; if 00-3F, punctuation characters, loop back
.8d41	90 3e		bcc $8d81			bcc 	_SFWExit
.8d43	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if 40-82, skip one extra.
.8d45	90 18		bcc $8d5f			bcc 	_ScanSkipOne
.8d47	c9 fc		cmp #$fc			cmp 	#$FC 						; FC-FF are data skips
.8d49	b0 2f		bcs $8d7a			bcs 	_ScanSkipData
.8d4b	c9 a0		cmp #$a0			cmp 	#KWC_FIRST_STRUCTURE 		; structure keyword ?
.8d4d	90 32		bcc $8d81			bcc 	_SFWExit 					; if not, ordinary keywords.
.8d4f	c9 ab		cmp #$ab			cmp 	#KWC_LAST_STRUCTURE+1
.8d51	b0 2e		bcs $8d81			bcs 	_SFWExit
.8d53	c6 38		dec $38				dec 	zTemp1 						; decrement the sructure count
.8d55	c9 a5		cmp #$a5			cmp 	#KWC_FIRST_STRUCTURE_DEC 	; back if it is a dec structure (e.g. WEND/NEXT)
.8d57	b0 28		bcs $8d81			bcs 	_SFWExit
.8d59	e6 38		inc $38				inc 	zTemp1 						; so it's an increment structure
.8d5b	e6 38		inc $38				inc 	zTemp1 						; twice to undo the dec
.8d5d	80 22		bra $8d81			bra 	_SFWExit
.8d5f					_ScanSkipOne:
.8d5f	c8		iny				iny 								; consume the extra one.
.8d60	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if not EOL loop back
.8d62	d0 1d		bne $8d81			bne 	_SFWExit
.8d64	18		clc				clc
.8d65	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8d67	65 30		adc $30				adc 	codePtr
.8d69	85 30		sta $30				sta 	codePtr
.8d6b	90 02		bcc $8d6f			bcc 	_CREExit
.8d6d	e6 31		inc $31				inc 	codePtr+1 					; carry
.8d6f					_CREExit:
.8d6f	a0 03		ldy #$03			ldy 	#3 							; scan start position.
.8d71	b2 30		lda ($30)			lda 	(codePtr)
.8d73	d0 0c		bne $8d81			bne 	_SFWExit 					; if not zero, more to scan
.8d75	a9 13		lda #$13		lda	#19
.8d77	4c 40 8e	jmp $8e40		jmp	ErrorHandler
.8d7a					_ScanSkipData:
.8d7a	88		dey				dey 								; point at data token
.8d7b	c8		iny				iny 								; point to offset
.8d7c	98		tya				tya 								; A = offset position
.8d7d	38		sec				sec 								; add size +1 hence SEC
.8d7e	71 30		adc ($30),y			adc 	(codePtr),y
.8d80	a8		tay				tay 								; make current position.
.8d81					_SFWExit:
.8d81	60		rts				rts
.8d82					ScanGetCurrentLineStep:
.8d82	64 38		stz $38				stz 	zTemp1
.8d84	a0 03		ldy #$03			ldy 	#3
.8d86					_SGCLSLoop:
.8d86	b1 30		lda ($30),y			lda 	(codePtr),y
.8d88	c8		iny				iny
.8d89	c9 80		cmp #$80			cmp 	#KWC_EOL	 				; if EOL exit
.8d8b	f0 05		beq $8d92			beq 	_SGCLSExit
.8d8d	20 3f 8d	jsr $8d3f			jsr 	ScanForwardOne
.8d90	80 f4		bra $8d86			bra 	_SGCLSLoop
.8d92					_SGCLSExit:
.8d92	a5 38		lda $38				lda 	zTemp1
.8d94	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/while.asm

.8d95					Command_WHILE:
.8d95	5a		phy				phy 								; save position of the test
.8d96	a2 00		ldx #$00			ldx 	#0
.8d98	20 9e 9c	jsr $9c9e			jsr 	EvaluateNumber 				; work out the number
.8d9b	20 72 9d	jsr $9d72			jsr 	NSMIsZero 					; check if zero
.8d9e	f0 0e		beq $8dae			beq 	_WHExitLoop 				; if so exit the loop
.8da0	98		tya				tya 								; position *after* test.
.8da1	7a		ply				ply 								; restore position before test, at WHILE
.8da2	88		dey				dey
.8da3	48		pha				pha 								; push after test on the stack
.8da4	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; allocate 6 bytes on the return stack.
.8da6	20 8d a5	jsr $a58d			jsr 	StackOpen
.8da9	20 d1 a5	jsr $a5d1			jsr 	STKSaveCodePosition 		; save loop position - where the test value is.
.8dac	7a		ply				ply 								; restore the position *after* the test
.8dad	60		rts				rts
.8dae					_WHExitLoop:
.8dae	68		pla				pla 								; throw post loop position
.8daf	a9 aa		lda #$aa			lda 	#KWD_WEND 					; scan forward past WEND
.8db1	aa		tax				tax
.8db2	20 1f 8d	jsr $8d1f			jsr 	ScanForward
.8db5	60		rts				rts
.8db6					Command_WEND:
.8db6	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; check WHILE is TOS
.8db8	a2 10		ldx #$10			ldx 	#ERRID_WHILE 				; this error
.8dba	20 b9 a5	jsr $a5b9			jsr 	StackCheckFrame
.8dbd	20 e2 a5	jsr $a5e2			jsr 	STKLoadCodePosition 		; loop back
.8dc0	20 ab a5	jsr $a5ab			jsr 	StackClose		 			; erase the frame
.8dc3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/who.asm

.8dc4					WhoCommand:
.8dc4	a2 8d		ldx #$8d			ldx 	#(_WHOMessage >> 8)
.8dc6	a9 cc		lda #$cc			lda 	#(_WHOMessage & $FF)
.8dc8	20 99 8e	jsr $8e99			jsr 	PrintStringXA
.8dcb	60		rts				rts
.8dcc					_WHOMessage:
>8dcc	81						.byte 	$81
>8dcd	42 72 6f 75 67 68 74 20				.text 	"Brought to you by :",13,13
>8dd5	74 6f 20 79 6f 75 20 62 79 20 3a 0d 0d
>8de2	09 53 74 65 66 61 6e 79				.text 	9,"Stefany Allaire",13
>8dea	20 41 6c 6c 61 69 72 65 0d
>8df3	09 4a 65 73 73 69 65 20				.text 	9,"Jessie Oberreuter",13
>8dfb	4f 62 65 72 72 65 75 74 65 72 0d
>8e06	09 50 61 75 6c 20 52 6f				.text 	9,"Paul Robson",13
>8e0e	62 73 6f 6e 0d
>8e13	09 50 65 74 65 72 20 57				.text 	9,"Peter Weingartner",13
>8e1b	65 69 6e 67 61 72 74 6e 65 72 0d
>8e26	00						.byte 	0

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/charcheck.asm

.8e27					CheckRightBracket:
.8e27	b1 30		lda ($30),y			lda 	(codePtr),y
.8e29	c8		iny				iny
.8e2a	c9 29		cmp #$29			cmp 	#KWD_RPAREN 						; exit if matches
.8e2c	d0 0f		bne $8e3d			bne 	CNAFail
.8e2e	60		rts				rts
.8e2f					CheckComma:
.8e2f	b1 30		lda ($30),y			lda 	(codePtr),y
.8e31	c8		iny				iny
.8e32	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 						; exit if matches
.8e34	d0 07		bne $8e3d			bne 	CNAFail
.8e36	60		rts				rts
.8e37					CheckNextA:
.8e37	d1 30		cmp ($30),y			cmp 	(codePtr),y
.8e39	d0 02		bne $8e3d			bne 	CNAFail
.8e3b	c8		iny				iny 								; skip character
.8e3c	60		rts				rts 								; and exit
.8e3d					CNAFail:
.8e3d	4c c8 9e	jmp $9ec8			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/errors.asm

.8e40					ErrorHandler:
.8e40	a8		tay				tay 								; find the error text
.8e41	f0 49		beq $8e8c			beq 	_EHEnd
.8e43	a2 00		ldx #$00			ldx 	#0
.8e45	a9 e1		lda #$e1			lda 	#((ErrorText) & $FF)
.8e47	85 36		sta $36				sta 	0+zTemp0
.8e49	a9 9e		lda #$9e			lda 	#((ErrorText) >> 8)
.8e4b	85 37		sta $37				sta 	1+zTemp0
.8e4d					_EHFind:
.8e4d	88		dey				dey 								; found the error text ?
.8e4e	f0 0e		beq $8e5e			beq 	_EHFound
.8e50					_EHFindZero:
.8e50	b2 36		lda ($36)			lda 	(zTemp0) 					; find the next error
.8e52	e6 36		inc $36				inc 	zTemp0
.8e54	d0 02		bne $8e58			bne 	_EHFNoCarry
.8e56	e6 37		inc $37				inc 	zTemp0+1
.8e58					_EHFNoCarry:
.8e58	c9 00		cmp #$00			cmp 	#0
.8e5a	d0 f4		bne $8e50			bne 	_EHFindZero
.8e5c	80 ef		bra $8e4d			bra 	_EHFind
.8e5e					_EHFound:
.8e5e	a5 36		lda $36				lda 	zTemp0 						; print message
.8e60	a6 37		ldx $37				ldx 	zTemp0+1
.8e62	20 99 8e	jsr $8e99			jsr 	PrintStringXA
.8e65	a0 01		ldy #$01			ldy 	#1 							; if line number zero don't print i
.8e67	b1 30		lda ($30),y			lda 	(codePtr),y
.8e69	d0 05		bne $8e70			bne 	_EHAtMsg
.8e6b	c8		iny				iny
.8e6c	b1 30		lda ($30),y			lda 	(codePtr),y
.8e6e	f0 17		beq $8e87			beq 	_EHCREnd
.8e70					_EHAtMsg:
.8e70	a2 8e		ldx #$8e			ldx 	#_AtMsg >> 8 				; print " at "
.8e72	a9 8f		lda #$8f			lda 	#_AtMsg & $FF
.8e74	20 99 8e	jsr $8e99			jsr 	PrintStringXA
.8e77	a0 01		ldy #$01			ldy 	#1 							; line number into XA
.8e79	b1 30		lda ($30),y			lda 	(codePtr),y
.8e7b	48		pha				pha
.8e7c	c8		iny				iny
.8e7d	b1 30		lda ($30),y			lda 	(codePtr),y
.8e7f	aa		tax				tax
.8e80	68		pla				pla
.8e81	20 af 92	jsr $92af			jsr 	LCLConvertInt16 				; convert XA to string
.8e84	20 99 8e	jsr $8e99			jsr 	PrintStringXA 				; and print it.
.8e87					_EHCREnd:
.8e87	a9 0d		lda #$0d			lda 	#13 						; new line
.8e89	20 c4 a6	jsr $a6c4			jsr 	EXTPrintCharacter
.8e8c					_EHEnd:
.8e8c	4c 6a 83	jmp $836a			jmp 	WarmStart
>8e8f	20 61 74 20 6c 69 6e 65		_AtMsg:	.text 	" at line ",0
>8e97	20 00
.8e99					PrintStringXA:
.8e99	5a		phy				phy
.8e9a	86 37		stx $37				stx 	zTemp0+1
.8e9c	85 36		sta $36				sta 	zTemp0
.8e9e	a0 00		ldy #$00			ldy 	#0
.8ea0					_PSXALoop:
.8ea0	b1 36		lda ($36),y			lda 	(zTemp0),y
.8ea2	f0 06		beq $8eaa			beq 	_PSXAExit
.8ea4	20 c4 a6	jsr $a6c4			jsr 	EXTPrintCharacter
.8ea7	c8		iny				iny
.8ea8	80 f6		bra $8ea0			bra 	_PSXALoop
.8eaa					_PSXAExit:
.8eaa	7a		ply				ply
.8eab	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/compare.asm

.8eac					UnaryTrue:
.8eac	fa		plx				plx
.8ead					ReturnTrue:
.8ead	a9 01		lda #$01			lda 	#1  						; set to 1
.8eaf	20 52 9d	jsr $9d52			jsr 	NSMSetByte
.8eb2	a9 80		lda #$80			lda 	#$80 						; set sign flag, so it is -1
.8eb4	95 50		sta $50,x			sta 	NSStatus,x
.8eb6	60		rts				rts
.8eb7					UnaryFalse:
.8eb7	fa		plx				plx
.8eb8					ReturnFalse:
.8eb8	4c 50 9d	jmp $9d50			jmp 	NSMSetZero 					; set it all to zero
.8ebb					BinaryCompareEqual:
.8ebb	fa		plx				plx
.8ebc	20 f7 8e	jsr $8ef7			jsr 	CompareBaseCode
.8ebf	c9 00		cmp #$00			cmp 	#0
.8ec1	f0 ea		beq $8ead			beq 	ReturnTrue
.8ec3	80 f3		bra $8eb8			bra 	ReturnFalse
.8ec5					BinaryCompareLess:
.8ec5	fa		plx				plx
.8ec6	20 f7 8e	jsr $8ef7			jsr 	CompareBaseCode
.8ec9	c9 ff		cmp #$ff			cmp 	#$FF
.8ecb	f0 e0		beq $8ead			beq 	ReturnTrue
.8ecd	80 e9		bra $8eb8			bra 	ReturnFalse
.8ecf					BinaryCompareGreater:
.8ecf	fa		plx				plx
.8ed0	20 f7 8e	jsr $8ef7			jsr 	CompareBaseCode
.8ed3	c9 01		cmp #$01			cmp 	#1
.8ed5	f0 d6		beq $8ead			beq 	ReturnTrue
.8ed7	80 df		bra $8eb8			bra 	ReturnFalse
.8ed9					BinaryCompareNotEqual:
.8ed9	fa		plx				plx
.8eda	20 f7 8e	jsr $8ef7			jsr 	CompareBaseCode
.8edd	c9 00		cmp #$00			cmp 	#0
.8edf	d0 cc		bne $8ead			bne 	ReturnTrue
.8ee1	80 d5		bra $8eb8			bra 	ReturnFalse
.8ee3					BinaryCompareLessEqual:
.8ee3	fa		plx				plx
.8ee4	20 f7 8e	jsr $8ef7			jsr 	CompareBaseCode
.8ee7	c9 01		cmp #$01			cmp 	#1
.8ee9	d0 c2		bne $8ead			bne 	ReturnTrue
.8eeb	80 cb		bra $8eb8			bra 	ReturnFalse
.8eed					BinaryCompareGreaterEqual:
.8eed	fa		plx				plx
.8eee	20 f7 8e	jsr $8ef7			jsr 	CompareBaseCode
.8ef1	c9 ff		cmp #$ff			cmp 	#$FF
.8ef3	d0 b8		bne $8ead			bne 	ReturnTrue
.8ef5	80 c1		bra $8eb8			bra 	ReturnFalse
.8ef7					CompareBaseCode:
.8ef7	20 02 96	jsr $9602			jsr 	DereferenceTopTwo 			; make both values if references.
.8efa	b5 50		lda $50,x			lda 	NSStatus,x 					; check if either is a string.
.8efc	15 51		ora $51,x			ora 	NSStatus+1,x
.8efe	29 10		and #$10			and 	#NSTString
.8f00	d0 37		bne $8f39			bne 	_CBCString 					; if so do string code, which will check if both.
.8f02	b5 78		lda $78,x			lda 	NSExponent,x 				; check both are integers
.8f04	15 79		ora $79,x			ora 	NSExponent+1,x
.8f06	d0 34		bne $8f3c			bne 	_CBCFloat
.8f08	b5 50		lda $50,x			lda 	NSStatus,x
.8f0a	15 51		ora $51,x			ora 	NSStatus+1,x
.8f0c	29 08		and #$08			and 	#NSTFloat
.8f0e	d0 2c		bne $8f3c			bne 	_CBCFloat
.8f10	20 3f 8f	jsr $8f3f			jsr 	CompareFixMinusZero 		; fix up -0 just in cases.
.8f13	e8		inx				inx
.8f14	20 3f 8f	jsr $8f3f			jsr 	CompareFixMinusZero
.8f17	ca		dex				dex
.8f18	b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs different ?
.8f1a	55 51		eor $51,x			eor 	NSStatus+1,x
.8f1c	10 0a		bpl $8f28			bpl 	_CDCSameSign
.8f1e	b5 50		lda $50,x			lda 	NSStatus,x 					; if first one is -ve
.8f20	30 14		bmi $8f36			bmi 	_CBCLess 					; return $FF
.8f22					_CBCGreater:
.8f22	a9 01		lda #$01			lda 	#1
.8f24	60		rts				rts
.8f25					_CBCEqual:
.8f25	a9 00		lda #$00			lda 	#0
.8f27	60		rts				rts
.8f28					_CDCSameSign:
.8f28	20 54 91	jsr $9154			jsr 	SubTopTwoStack 				; unsigned subtract
.8f2b	20 72 9d	jsr $9d72			jsr 	NSMIsZero 					; or the mantissa together
.8f2e	f0 f5		beq $8f25			beq 	_CBCEqual 					; -0 == 0
.8f30	b5 70		lda $70,x			lda 	NSMantissa3,x 				; sign of the result. if +ve return $01 else return $FF
.8f32	55 51		eor $51,x			eor 	NSStatus+1,x 				; however if both were -ve this is inverted
.8f34	10 ec		bpl $8f22			bpl 	_CBCGreater
.8f36					_CBCLess:
.8f36	a9 ff		lda #$ff			lda 	#$FF
.8f38	60		rts				rts
.8f39					_CBCString:
.8f39	4c c5 90	jmp $90c5			jmp 	CompareStrings
.8f3c					_CBCFloat:
.8f3c	4c 0f 94	jmp $940f			jmp 	CompareFloat
.8f3f					CompareFixMinusZero:
.8f3f	20 72 9d	jsr $9d72			jsr 	NSMIsZero
.8f42	d0 02		bne $8f46			bne 	_CFXMZNotZero
.8f44	74 50		stz $50,x			stz 	NSStatus,x
.8f46					_CFXMZNotZero:
.8f46	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/concat.asm

.8f47					StringConcat:
.8f47	b5 50		lda $50,x			lda 	NSStatus,x 					; check both strings
.8f49	35 51		and $51,x			and 	NSStatus+1,x
.8f4b	29 18		and #$18			and 	#NSBTypeMask
.8f4d	c9 10		cmp #$10			cmp 	#NSTString
.8f4f	d0 50		bne $8fa1			bne		_SCType
.8f51	64 38		stz $38				stz 	zTemp1 						; counting total length
.8f53	e8		inx				inx
.8f54	20 72 8f	jsr $8f72			jsr 	_SCSetupZ0 					; setup for second
.8f57	20 7b 8f	jsr $8f7b			jsr 	_SCLengthZ0 				; length for second
.8f5a	ca		dex				dex
.8f5b	20 72 8f	jsr $8f72			jsr 	_SCSetupZ0 					; setup for first
.8f5e	20 7b 8f	jsr $8f7b			jsr 	_SCLengthZ0 				; length for first
.8f61	a5 38		lda $38				lda 	zTemp1 						; allocate memory using total.
.8f63	20 7c a6	jsr $a67c			jsr 	StringTempAllocate
.8f66	20 92 8f	jsr $8f92			jsr 	_SCCopy 					; copy first out, using zTemp0 from above
.8f69	e8		inx				inx
.8f6a	20 72 8f	jsr $8f72			jsr 	_SCSetupZ0 					; copy second out
.8f6d	20 92 8f	jsr $8f92			jsr 	_SCCopy
.8f70	ca		dex				dex
.8f71	60		rts				rts
.8f72					_SCSetupZ0:
.8f72	b5 58		lda $58,x			lda 	NSMantissa0,x
.8f74	85 36		sta $36				sta 	zTemp0
.8f76	b5 60		lda $60,x			lda 	NSMantissa1,x
.8f78	85 37		sta $37				sta 	zTemp0+1
.8f7a	60		rts				rts
.8f7b					_SCLengthZ0:
.8f7b	5a		phy				phy
.8f7c	a0 00		ldy #$00			ldy 	#0
.8f7e					_SCLenLoop:
.8f7e	b1 36		lda ($36),y			lda 	(zTemp0),y
.8f80	f0 0e		beq $8f90			beq 	_SCLExit
.8f82	c8		iny				iny
.8f83	e6 38		inc $38				inc 	zTemp1
.8f85	a5 38		lda $38				lda	 	zTemp1 						; check string too long.
.8f87	c9 fd		cmp #$fd			cmp 	#253
.8f89	d0 f3		bne $8f7e			bne		_SCLenLoop
.8f8b	a9 09		lda #$09		lda	#9
.8f8d	4c 40 8e	jmp $8e40		jmp	ErrorHandler
.8f90					_SCLExit:
.8f90	7a		ply				ply
.8f91	60		rts				rts
.8f92					_SCCopy:
.8f92	5a		phy				phy
.8f93	a0 00		ldy #$00			ldy 	#0
.8f95					_SCCopyLoop:
.8f95	b1 36		lda ($36),y			lda 	(zTemp0),y
.8f97	f0 06		beq $8f9f			beq 	_SCCExit
.8f99	20 b5 a6	jsr $a6b5			jsr 	StringTempWrite
.8f9c	c8		iny				iny
.8f9d	80 f6		bra $8f95			bra 	_SCCopyLoop
.8f9f					_SCCExit:
.8f9f	7a		ply				ply
.8fa0	60		rts				rts
.8fa1					_SCType:
.8fa1	4c d2 9e	jmp $9ed2			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/divide.asm

.8fa4					IntegerDivide:
.8fa4	fa		plx				plx
.8fa5	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.8fa7	15 51		ora $51,x			ora 	NSStatus+1,x
.8fa9	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8faa	0a		asl a				asl 	a
.8fab	10 05		bpl $8fb2			bpl 	_NotRef
.8fad	48		pha				pha
.8fae	20 02 96	jsr $9602			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8fb1	68		pla				pla
.8fb2					_NotRef:
.8fb2	0a		asl a				asl 	a
.8fb3	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.8fb5	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8fb7	15 79		ora $79,x			ora 	NSExponent+1,x
.8fb9	f0 03		beq $8fbe			beq 	_IntegerCode 				; if clear, then we have two integers
.8fbb	4c d2 9e	jmp $9ed2			jmp 	TypeError 					; anything else, type mismatch.
.8fbe					_IntegerCode:
.8fbe	20 d8 8f	jsr $8fd8			jsr 	CheckDivideZero 			; do div zero check
.8fc1	20 0a 90	jsr $900a			jsr 	Int32Divide 				; do the division
.8fc4	20 bb 90	jsr $90bb			jsr 	CalculateSign 				; calculate result sign
.8fc7					NSMCopyPlusTwoToZero:
.8fc7	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.8fc9	95 58		sta $58,x			sta 	NSMantissa0,x
.8fcb	b5 62		lda $62,x			lda 	NSMantissa1+2,x
.8fcd	95 60		sta $60,x			sta 	NSMantissa1,x
.8fcf	b5 6a		lda $6a,x			lda 	NSMantissa2+2,x
.8fd1	95 68		sta $68,x			sta 	NSMantissa2,x
.8fd3	b5 72		lda $72,x			lda 	NSMantissa3+2,x
.8fd5	95 70		sta $70,x			sta 	NSMantissa3,x
.8fd7	60		rts				rts
.8fd8					CheckDivideZero:
.8fd8	e8		inx				inx
.8fd9	20 72 9d	jsr $9d72			jsr 	NSMIsZero
.8fdc	f0 02		beq $8fe0			beq 	_CDVError
.8fde	ca		dex				dex
.8fdf	60		rts				rts
.8fe0					_CDVError:
.8fe0	a9 03		lda #$03		lda	#3
.8fe2	4c 40 8e	jmp $8e40		jmp	ErrorHandler
.8fe5					IntegerModulus:
.8fe5	fa		plx				plx
.8fe6	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.8fe8	15 51		ora $51,x			ora 	NSStatus+1,x
.8fea	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8feb	0a		asl a				asl 	a
.8fec	10 05		bpl $8ff3			bpl 	_NotRef
.8fee	48		pha				pha
.8fef	20 02 96	jsr $9602			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8ff2	68		pla				pla
.8ff3					_NotRef:
.8ff3	0a		asl a				asl 	a
.8ff4	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.8ff6	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8ff8	15 79		ora $79,x			ora 	NSExponent+1,x
.8ffa	f0 03		beq $8fff			beq 	_IntegerCode 				; if clear, then we have two integers
.8ffc	4c d2 9e	jmp $9ed2			jmp 	TypeError 					; anything else, type mismatch.
.8fff					_IntegerCode:
.8fff					IntegerModulusNoCheck:
.8fff	20 d8 8f	jsr $8fd8			jsr 	CheckDivideZero 			; do div zero check
.9002	20 0a 90	jsr $900a			jsr 	Int32Divide 				; do the division
.9005	16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.9007	56 50		lsr $50,x			lsr 	NSStatus,x
.9009	60		rts				rts
.900a					Int32Divide:
.900a	48		pha				pha 								; save AXY
.900b	5a		phy				phy
.900c	20 33 9d	jsr $9d33			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.900f	20 4c 9d	jsr $9d4c			jsr 	NSMSetZeroMantissaOnly 		; set S[X] to zero
.9012	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.9014					_I32DivideLoop:
.9014	e8		inx				inx
.9015	e8		inx				inx
.9016	20 5f 9d	jsr $9d5f			jsr 	NSMShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.9019	ca		dex				dex
.901a	ca		dex				dex
.901b	20 60 9d	jsr $9d60			jsr 	NSMRotateLeft
.901e	20 49 90	jsr $9049			jsr 	DivideCheckSubtract 		; check if subtract possible
.9021	90 02		bcc $9025			bcc 	_I32DivideNoCarryIn
.9023	f6 5a		inc $5a,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.9025					_I32DivideNoCarryIn:
.9025	88		dey				dey 								; loop round till division completed.
.9026	d0 ec		bne $9014			bne 	_I32DivideLoop
.9028	7a		ply				ply 								; restore AXY and exit
.9029	68		pla				pla
.902a	60		rts				rts
.902b					Int32ShiftDivide:
.902b	48		pha				pha 								; save AY
.902c	5a		phy				phy
.902d	e8		inx				inx 								; clear S[X+2]
.902e	e8		inx				inx
.902f	20 50 9d	jsr $9d50			jsr 	NSMSetZero
.9032	ca		dex				dex
.9033	ca		dex				dex
.9034	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.9036					_I32SDLoop:
.9036	20 49 90	jsr $9049			jsr 	DivideCheckSubtract 		; check if subtract possible
.9039	e8		inx				inx
.903a	e8		inx				inx
.903b	20 60 9d	jsr $9d60			jsr 	NSMRotateLeft				; shift 64 bit FPA left, rotating carry in
.903e	ca		dex				dex
.903f	ca		dex				dex
.9040	20 60 9d	jsr $9d60			jsr 	NSMRotateLeft
.9043	88		dey				dey 	 							; do 31 times
.9044	d0 f0		bne $9036			bne 	_I32SDLoop
.9046	7a		ply				ply 								; restore AY and exit
.9047	68		pla				pla
.9048	60		rts				rts
.9049					DivideCheckSubtract:
.9049	20 54 91	jsr $9154			jsr 	SubTopTwoStack 				; subtract Stack[X+1] from Stack[X+0]
.904c	b0 04		bcs $9052			bcs 	_DCSExit 					; if carry set, then could do, exit
.904e	20 3a 91	jsr $913a			jsr 	AddTopTwoStack 				; add it back in
.9051	18		clc				clc 								; and return False
.9052					_DCSExit:
.9052	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/multiply.asm

.9053					MulInteger:
.9053	fa		plx				plx
.9054	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9056	15 51		ora $51,x			ora 	NSStatus+1,x
.9058	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9059	0a		asl a				asl 	a
.905a	10 05		bpl $9061			bpl 	_NotRef
.905c	48		pha				pha
.905d	20 02 96	jsr $9602			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9060	68		pla				pla
.9061					_NotRef:
.9061	0a		asl a				asl 	a 							; put MSB of type into A:7
.9062	30 09		bmi $906d			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9064	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9066	15 79		ora $79,x			ora 	NSExponent+1,x
.9068	f0 06		beq $9070			beq 	_IntegerCode 				; if clear, then we have two integers
.906a	4c d1 94	jmp $94d1			jmp 	FloatingPointMultiply 							; otherwise at least one float.
.906d					_StringData:
.906d	4c dc 9e	jmp $9edc			jmp 	NotDoneError							; at least one string - don't know both are strings.
.9070					_IntegerCode:
.9070	20 7d 90	jsr $907d			jsr 	MultiplyShort
.9073	c9 00		cmp #$00			cmp 	#0
.9075	f0 05		beq $907c			beq 	_MIExit
.9077	a9 04		lda #$04		lda	#4
.9079	4c 40 8e	jmp $8e40		jmp	ErrorHandler
.907c					_MIExit:
.907c	60		rts				rts
.907d					MultiplyShort:
.907d	5a		phy				phy 								; save Y
.907e	20 33 9d	jsr $9d33			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.9081	20 4c 9d	jsr $9d4c			jsr 	NSMSetZeroMantissaOnly 		; set mantissa S[X] to zero
.9084	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.9086					_I32MLoop:
.9086	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.9088	15 62		ora $62,x			ora 	NSMantissa1+2,x
.908a	15 6a		ora $6a,x			ora 	NSMantissa2+2,x
.908c	15 72		ora $72,x			ora 	NSMantissa3+2,x
.908e	f0 25		beq $90b5			beq 	_I32MExit 					; exit if zero
.9090	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.9092	29 01		and #$01			and 	#1
.9094	f0 0d		beq $90a3			beq 	_I32MNoAdd
.9096	20 3a 91	jsr $913a			jsr 	AddTopTwoStack 				; if so add S[X+1] to S[X+0]
.9099	b5 70		lda $70,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.909b	10 06		bpl $90a3			bpl 	_I32MNoAdd
.909d					_I32ShiftRight:
.909d	20 69 9d	jsr $9d69			jsr 	NSMShiftRight 				; shift S[X] right
.90a0	c8		iny				iny 								; increment shift count
.90a1	80 09		bra $90ac			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.90a3					_I32MNoAdd:
.90a3	34 71		bit $71,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.90a5	70 f6		bvs $909d			bvs 	_I32ShiftRight 				; instead.
.90a7	e8		inx				inx
.90a8	20 5f 9d	jsr $9d5f			jsr 	NSMShiftLeft 				; shift additive S[X+1] left
.90ab	ca		dex				dex
.90ac					_I32MShiftUpper:
.90ac	e8		inx				inx 								; shift S[X+2] right
.90ad	e8		inx				inx
.90ae	20 69 9d	jsr $9d69			jsr 	NSMShiftRight
.90b1	ca		dex				dex
.90b2	ca		dex				dex
.90b3	80 d1		bra $9086			bra 	_I32MLoop 					; try again.
.90b5					_I32MExit:
.90b5	20 bb 90	jsr $90bb			jsr 	CalculateSign
.90b8	98		tya				tya 								; shift in A
.90b9	7a		ply				ply 								; restore Y and exit
.90ba	60		rts				rts
.90bb					CalculateSign:
.90bb	b5 50		lda $50,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.90bd	16 50		asl $50,x			asl 	NSStatus,x 					; shift result left
.90bf	55 51		eor $51,x			eor 	NSStatus+1,x
.90c1	0a		asl a				asl 	a 							; shift bit 7 into carry
.90c2	76 50		ror $50,x			ror 	NSStatus,x 					; shift right into status byte.
.90c4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/scompare.asm

.90c5					CompareStrings:
.90c5	b5 50		lda $50,x			lda 	NSStatus,x 					; check both are strings
.90c7	35 51		and $51,x			and 	NSStatus+1,x
.90c9	29 10		and #$10			and 	#NSBIsString
.90cb	f0 28		beq $90f5			beq 	_CSTypeError
.90cd	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy string addresses to zTemp0/1
.90cf	85 36		sta $36				sta 	zTemp0
.90d1	b5 60		lda $60,x			lda 	NSMantissa1,x
.90d3	85 37		sta $37				sta 	zTemp0+1
.90d5	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.90d7	85 38		sta $38				sta 	zTemp1
.90d9	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.90db	85 39		sta $39				sta 	zTemp1+1
.90dd	5a		phy				phy 								; save Y so we can access strings
.90de	a0 ff		ldy #$ff			ldy 	#$FF 						; -1 for pre increment.
.90e0					_CSLoop:
.90e0	c8		iny				iny
.90e1	b1 36		lda ($36),y			lda 	(zTemp0),y 					; check if they are the same
.90e3	d1 38		cmp ($38),y			cmp 	(zTemp1),y
.90e5	d0 06		bne $90ed			bne 	_CSDifferent
.90e7	c9 00		cmp #$00			cmp 	#0 							; reached end ?
.90e9	d0 f5		bne $90e0			bne 	_CSLoop 					; still comparing
.90eb					_CSExit:
.90eb	7a		ply				ply 								; reached end, return zero in A from EOS
.90ec	60		rts				rts
.90ed					_CSDifferent:
.90ed	a9 ff		lda #$ff			lda 	#255 						; if < return $FF
.90ef	90 fa		bcc $90eb			bcc		_CSExit
.90f1	a9 01		lda #$01			lda 	#1 							; otherwise return 1.
.90f3	80 f6		bra $90eb			bra 	_CSExit
.90f5					_CSTypeError:
.90f5	4c d2 9e	jmp $9ed2			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/shifts.asm

.90f8					ShiftLeft:
.90f8	38		sec				sec 								; common code, carry determines which way.
.90f9	80 01		bra $90fc			bra 	ShiftMain
.90fb					ShiftRight:
.90fb	18		clc				clc
.90fc					ShiftMain:
.90fc	fa		plx				plx 								; restore X
.90fd	08		php				php 								; save direction
.90fe	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9100	15 51		ora $51,x			ora 	NSStatus+1,x
.9102	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9103	0a		asl a				asl 	a
.9104	10 05		bpl $910b			bpl 	_NotRef
.9106	48		pha				pha
.9107	20 02 96	jsr $9602			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.910a	68		pla				pla
.910b					_NotRef:
.910b	0a		asl a				asl 	a
.910c	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.910e	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9110	15 79		ora $79,x			ora 	NSExponent+1,x
.9112	f0 03		beq $9117			beq 	_IntegerCode 				; if clear, then we have two integers
.9114	4c d2 9e	jmp $9ed2			jmp 	TypeError 					; anything else, type mismatch.
.9117					_IntegerCode:
.9117	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; check number < 32
.9119	29 e0		and #$e0			and 	#$E0
.911b	15 61		ora $61,x			ora 	NSMantissa1+1,x
.911d	15 69		ora $69,x			ora 	NSMantissa2+1,x
.911f	15 71		ora $71,x			ora 	NSMantissa3+1,x
.9121	d0 12		bne $9135			bne 	_SMExit0 					; if >= 32 it will always return zero.
.9123					_SMLoop:
.9123	d6 59		dec $59,x			dec 	NSMantissa0+1,x 			; predecrement, could do << 0
.9125	30 11		bmi $9138			bmi 	_SMExit 					; exit if done.
.9127	28		plp				plp 								; restore direction setting
.9128	08		php				php
.9129	90 05		bcc $9130			bcc 	_SMRight
.912b	20 5f 9d	jsr $9d5f			jsr 	NSMShiftLeft 				; shift left if CS
.912e	80 f3		bra $9123			bra 	_SMLoop
.9130					_SMRight:
.9130	20 69 9d	jsr $9d69			jsr 	NSMShiftRight 				; shift right if CC
.9133	80 ee		bra $9123			bra 	_SMLoop
.9135					_SMExit0:
.9135	20 50 9d	jsr $9d50			jsr 	NSMSetZero 					; return zero.
.9138					_SMExit:
.9138	28		plp				plp 								; throw direction
.9139	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/simple.asm

.913a					AddTopTwoStack:
.913a	18		clc				clc
.913b	b5 58		lda $58,x			lda		NSMantissa0,x
.913d	75 59		adc $59,x			adc 		NSMantissa0+1,x
.913f	95 58		sta $58,x			sta 	NSMantissa0,x
.9141	b5 60		lda $60,x			lda		NSMantissa1,x
.9143	75 61		adc $61,x			adc 		NSMantissa1+1,x
.9145	95 60		sta $60,x			sta 	NSMantissa1,x
.9147	b5 68		lda $68,x			lda		NSMantissa2,x
.9149	75 69		adc $69,x			adc 		NSMantissa2+1,x
.914b	95 68		sta $68,x			sta 	NSMantissa2,x
.914d	b5 70		lda $70,x			lda		NSMantissa3,x
.914f	75 71		adc $71,x			adc 		NSMantissa3+1,x
.9151	95 70		sta $70,x			sta 	NSMantissa3,x
.9153	60		rts				rts
.9154					SubTopTwoStack:
.9154	38		sec				sec
.9155	b5 58		lda $58,x			lda		NSMantissa0,x
.9157	f5 59		sbc $59,x			sbc 		NSMantissa0+1,x
.9159	95 58		sta $58,x			sta 	NSMantissa0,x
.915b	b5 60		lda $60,x			lda		NSMantissa1,x
.915d	f5 61		sbc $61,x			sbc 		NSMantissa1+1,x
.915f	95 60		sta $60,x			sta 	NSMantissa1,x
.9161	b5 68		lda $68,x			lda		NSMantissa2,x
.9163	f5 69		sbc $69,x			sbc 		NSMantissa2+1,x
.9165	95 68		sta $68,x			sta 	NSMantissa2,x
.9167	b5 70		lda $70,x			lda		NSMantissa3,x
.9169	f5 71		sbc $71,x			sbc 		NSMantissa3+1,x
.916b	95 70		sta $70,x			sta 	NSMantissa3,x
.916d	60		rts				rts
.916e					AddInteger:
.916e	fa		plx				plx
.916f	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9171	15 51		ora $51,x			ora 	NSStatus+1,x
.9173	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9174	0a		asl a				asl 	a
.9175	10 05		bpl $917c			bpl 	_NotRef
.9177	48		pha				pha
.9178	20 02 96	jsr $9602			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.917b	68		pla				pla
.917c					_NotRef:
.917c	0a		asl a				asl 	a 							; put MSB of type into A:7
.917d	30 09		bmi $9188			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.917f	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9181	15 79		ora $79,x			ora 	NSExponent+1,x
.9183	f0 06		beq $918b			beq 	_IntegerCode 				; if clear, then we have two integers
.9185	4c 81 93	jmp $9381			jmp 	FloatingPointAdd 							; otherwise at least one float.
.9188					_StringData:
.9188	4c 47 8f	jmp $8f47			jmp 	StringConcat							; at least one string - don't know both are strings.
.918b					_IntegerCode:
.918b					AddCode:
.918b	b5 50		lda $50,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.918d	55 51		eor $51,x			eor 	NSStatus+1,x
.918f	10 a9		bpl $913a			bpl 	AddTopTwoStack
.9191	20 54 91	jsr $9154			jsr 	SubTopTwoStack 				; do a physical subtraction
.9194	34 70		bit $70,x			bit 	NSMantissa3,x 				; result is +ve, okay
.9196	10 07		bpl $919f			bpl 	_AddExit
.9198	b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign is that of 2nd value
.919a	95 50		sta $50,x			sta 	NSStatus,x
.919c	20 19 9d	jsr $9d19			jsr 	NSMNegateMantissa 			; negate the mantissa and exit
.919f					_AddExit:
.919f	20 72 9d	jsr $9d72			jsr 	NSMIsZero 					; check for -0
.91a2	d0 02		bne $91a6			bne 	_AddNonZero
.91a4	74 50		stz $50,x			stz 	NSStatus,x
.91a6					_AddNonZero:
.91a6	60		rts				rts
.91a7					SubInteger:
.91a7	fa		plx				plx
.91a8	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.91aa	15 51		ora $51,x			ora 	NSStatus+1,x
.91ac	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91ad	0a		asl a				asl 	a
.91ae	10 05		bpl $91b5			bpl 	_NotRef
.91b0	48		pha				pha
.91b1	20 02 96	jsr $9602			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91b4	68		pla				pla
.91b5					_NotRef:
.91b5	0a		asl a				asl 	a 							; put MSB of type into A:7
.91b6	30 09		bmi $91c1			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.91b8	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91ba	15 79		ora $79,x			ora 	NSExponent+1,x
.91bc	f0 06		beq $91c4			beq 	_IntegerCode 				; if clear, then we have two integers
.91be	4c 86 93	jmp $9386			jmp 	FloatingPointSub 							; otherwise at least one float.
.91c1					_StringData:
.91c1	4c dc 9e	jmp $9edc			jmp 	NotDoneError							; at least one string - don't know both are strings.
.91c4					_IntegerCode:
.91c4	b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate the second value.
.91c6	49 80		eor #$80			eor 	#$80
.91c8	95 51		sta $51,x			sta 	NSStatus+1,x
.91ca	80 bf		bra $918b			bra 	AddCode 					; and do the same code as add.
.91cc					AndInteger:
.91cc	fa		plx				plx
.91cd	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.91cf	15 51		ora $51,x			ora 	NSStatus+1,x
.91d1	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91d2	0a		asl a				asl 	a
.91d3	10 05		bpl $91da			bpl 	_NotRef
.91d5	48		pha				pha
.91d6	20 02 96	jsr $9602			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91d9	68		pla				pla
.91da					_NotRef:
.91da	0a		asl a				asl 	a
.91db	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.91dd	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91df	15 79		ora $79,x			ora 	NSExponent+1,x
.91e1	f0 03		beq $91e6			beq 	_IntegerCode 				; if clear, then we have two integers
.91e3	4c d2 9e	jmp $9ed2			jmp 	TypeError 					; anything else, type mismatch.
.91e6					_IntegerCode:
.91e6	b5 58		lda $58,x			lda		NSMantissa0,x
.91e8	35 59		and $59,x			and 		NSMantissa0+1,x
.91ea	95 58		sta $58,x			sta 	NSMantissa0,x
.91ec	b5 60		lda $60,x			lda		NSMantissa1,x
.91ee	35 61		and $61,x			and 		NSMantissa1+1,x
.91f0	95 60		sta $60,x			sta 	NSMantissa1,x
.91f2	b5 68		lda $68,x			lda		NSMantissa2,x
.91f4	35 69		and $69,x			and 		NSMantissa2+1,x
.91f6	95 68		sta $68,x			sta 	NSMantissa2,x
.91f8	b5 70		lda $70,x			lda		NSMantissa3,x
.91fa	35 71		and $71,x			and 		NSMantissa3+1,x
.91fc	95 70		sta $70,x			sta 	NSMantissa3,x
.91fe	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.9200	60		rts				rts
.9201					OraInteger:
.9201	fa		plx				plx
.9202	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9204	15 51		ora $51,x			ora 	NSStatus+1,x
.9206	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9207	0a		asl a				asl 	a
.9208	10 05		bpl $920f			bpl 	_NotRef
.920a	48		pha				pha
.920b	20 02 96	jsr $9602			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.920e	68		pla				pla
.920f					_NotRef:
.920f	0a		asl a				asl 	a
.9210	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9212	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9214	15 79		ora $79,x			ora 	NSExponent+1,x
.9216	f0 03		beq $921b			beq 	_IntegerCode 				; if clear, then we have two integers
.9218	4c d2 9e	jmp $9ed2			jmp 	TypeError 					; anything else, type mismatch.
.921b					_IntegerCode:
.921b	b5 58		lda $58,x			lda		NSMantissa0,x
.921d	15 59		ora $59,x			ora 		NSMantissa0+1,x
.921f	95 58		sta $58,x			sta 	NSMantissa0,x
.9221	b5 60		lda $60,x			lda		NSMantissa1,x
.9223	15 61		ora $61,x			ora 		NSMantissa1+1,x
.9225	95 60		sta $60,x			sta 	NSMantissa1,x
.9227	b5 68		lda $68,x			lda		NSMantissa2,x
.9229	15 69		ora $69,x			ora 		NSMantissa2+1,x
.922b	95 68		sta $68,x			sta 	NSMantissa2,x
.922d	b5 70		lda $70,x			lda		NSMantissa3,x
.922f	15 71		ora $71,x			ora 		NSMantissa3+1,x
.9231	95 70		sta $70,x			sta 	NSMantissa3,x
.9233	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.9235	60		rts				rts
.9236					EorInteger:
.9236	fa		plx				plx
.9237	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9239	15 51		ora $51,x			ora 	NSStatus+1,x
.923b	0a		asl a				asl 	a 							; shift reference bit into sign bit
.923c	0a		asl a				asl 	a
.923d	10 05		bpl $9244			bpl 	_NotRef
.923f	48		pha				pha
.9240	20 02 96	jsr $9602			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9243	68		pla				pla
.9244					_NotRef:
.9244	0a		asl a				asl 	a
.9245	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9247	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9249	15 79		ora $79,x			ora 	NSExponent+1,x
.924b	f0 03		beq $9250			beq 	_IntegerCode 				; if clear, then we have two integers
.924d	4c d2 9e	jmp $9ed2			jmp 	TypeError 					; anything else, type mismatch.
.9250					_IntegerCode:
.9250	b5 58		lda $58,x			lda		NSMantissa0,x
.9252	55 59		eor $59,x			eor 		NSMantissa0+1,x
.9254	95 58		sta $58,x			sta 	NSMantissa0,x
.9256	b5 60		lda $60,x			lda		NSMantissa1,x
.9258	55 61		eor $61,x			eor 		NSMantissa1+1,x
.925a	95 60		sta $60,x			sta 	NSMantissa1,x
.925c	b5 68		lda $68,x			lda		NSMantissa2,x
.925e	55 69		eor $69,x			eor 		NSMantissa2+1,x
.9260	95 68		sta $68,x			sta 	NSMantissa2,x
.9262	b5 70		lda $70,x			lda		NSMantissa3,x
.9264	55 71		eor $71,x			eor 		NSMantissa3+1,x
.9266	95 70		sta $70,x			sta 	NSMantissa3,x
.9268	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.926a	60		rts				rts
.926b					WordIndirect:
.926b	fa		plx				plx
.926c	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.926e	15 51		ora $51,x			ora 	NSStatus+1,x
.9270	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9271	0a		asl a				asl 	a
.9272	10 05		bpl $9279			bpl 	_NotRef
.9274	48		pha				pha
.9275	20 02 96	jsr $9602			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9278	68		pla				pla
.9279					_NotRef:
.9279	0a		asl a				asl 	a
.927a	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.927c	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.927e	15 79		ora $79,x			ora 	NSExponent+1,x
.9280	f0 03		beq $9285			beq 	_IntegerCode 				; if clear, then we have two integers
.9282	4c d2 9e	jmp $9ed2			jmp 	TypeError 					; anything else, type mismatch.
.9285					_IntegerCode:
.9285	20 8b 91	jsr $918b			jsr 	AddCode 					; add the two values
.9288	a9 22		lda #$22			lda 	#NSBIsReference+2 			; make a 2 byte reference
.928a	95 50		sta $50,x			sta 	NSStatus,x
.928c	60		rts				rts
.928d					ByteIndirect:
.928d	fa		plx				plx
.928e	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9290	15 51		ora $51,x			ora 	NSStatus+1,x
.9292	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9293	0a		asl a				asl 	a
.9294	10 05		bpl $929b			bpl 	_NotRef
.9296	48		pha				pha
.9297	20 02 96	jsr $9602			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.929a	68		pla				pla
.929b					_NotRef:
.929b	0a		asl a				asl 	a
.929c	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.929e	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92a0	15 79		ora $79,x			ora 	NSExponent+1,x
.92a2	f0 03		beq $92a7			beq 	_IntegerCode 				; if clear, then we have two integers
.92a4	4c d2 9e	jmp $9ed2			jmp 	TypeError 					; anything else, type mismatch.
.92a7					_IntegerCode:
.92a7	20 8b 91	jsr $918b			jsr 	AddCode 					; add the two values
.92aa	a9 21		lda #$21			lda 	#NSBIsReference+1 			; make a 1 byte reference
.92ac	95 50		sta $50,x			sta 	NSStatus,x
.92ae	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/tostring.asm

.92af					LCLConvertInt16:
.92af	85 58		sta $58				sta 	NSMantissa0 				; set up as 32 bit conversion
.92b1	86 60		stx $60				stx 	NSMantissa1
.92b3	64 68		stz $68				stz 	NSMantissa2
.92b5	64 70		stz $70				stz 	NSMantissa3
.92b7	64 50		stz $50				stz 	NSStatus 					; positive integer
.92b9	a2 00		ldx #$00			ldx 	#0 							; stack level
.92bb	a9 0a		lda #$0a			lda 	#10 						; base
.92bd	80 00		bra $92bf			bra 	ConvertInt32
.92bf					ConvertInt32:
.92bf	5a		phy				phy
.92c0	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.92c2	24 50		bit $50				bit 	NSStatus 					; output a - if not negative.
.92c4	10 08		bpl $92ce			bpl 	_CI32NotNeg
.92c6	48		pha				pha
.92c7	a9 2d		lda #$2d			lda 	#'-'
.92c9	99 7b 05	sta $057b,y			sta 	NumberBuffer,y
.92cc	c8		iny				iny
.92cd	68		pla				pla
.92ce					_CI32NotNeg:
.92ce	20 dc 92	jsr $92dc			jsr 	_CI32DivideConvert 			; recursive conversion
.92d1	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.92d3	99 7b 05	sta $057b,y			sta 	NumberBuffer,y
.92d6	7a		ply				ply
.92d7	a2 05		ldx #$05			ldx 	#NumberBuffer >> 8
.92d9	a9 7b		lda #$7b			lda 	#NumberBuffer & $FF
.92db	60		rts				rts
.92dc					_CI32DivideConvert:
.92dc	e8		inx				inx 								; write to next slot up
.92dd	20 52 9d	jsr $9d52			jsr 	NSMSetByte
.92e0	ca		dex				dex
.92e1	20 0a 90	jsr $900a			jsr 	Int32Divide 				; divide
.92e4	b5 58		lda $58,x			lda 	NSMantissa0,x 				; save remainder
.92e6	48		pha				pha
.92e7	20 c7 8f	jsr $8fc7			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.92ea	20 72 9d	jsr $9d72			jsr 	NSMIsZero 					; is it zero ?
.92ed	f0 05		beq $92f4			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.92ef	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.92f1	20 dc 92	jsr $92dc			jsr 	_CI32DivideConvert 			; and recusrively call.
.92f4					_CI32NoRecurse:
.92f4	68		pla				pla 								; remainder
.92f5	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.92f7	90 02		bcc $92fb			bcc 	_CI32NotHex
.92f9	69 26		adc #$26			adc 	#6+32
.92fb					_CI32NotHex:
.92fb	69 30		adc #$30			adc 	#48
.92fd	99 7b 05	sta $057b,y			sta 	NumberBuffer,y 				; write out and exit
.9300	c8		iny				iny
.9301	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/expression.asm


;******  Processing file: ./common/expressions/../generated/precedence.dat

.9302					PrecedenceLevel:
>9302	04					.byte	 4	; $00 <<
>9303	02					.byte	 2	; $01 <=
>9304	02					.byte	 2	; $02 <>
>9305	00					.byte	 0	; $03 !!3
>9306	00					.byte	 0	; $04 ><
>9307	02					.byte	 2	; $05 >=
>9308	04					.byte	 4	; $06 >>
>9309	00					.byte	 0	; $07 !!7
>930a	00					.byte	 0	; $08 !!8
>930b	00					.byte	 0	; $09 !!9
>930c	00					.byte	 0	; $0a !!10
>930d	00					.byte	 0	; $0b !!11
>930e	00					.byte	 0	; $0c !!12
>930f	00					.byte	 0	; $0d !!13
>9310	00					.byte	 0	; $0e !!14
>9311	00					.byte	 0	; $0f !!15
>9312	00					.byte	 0	; $10 @
>9313	00					.byte	 0	; $11 !!17
>9314	00					.byte	 0	; $12 !!18
>9315	00					.byte	 0	; $13 [
>9316	04					.byte	 4	; $14 \
>9317	00					.byte	 0	; $15 ]
>9318	01					.byte	 1	; $16 ^
>9319	00					.byte	 0	; $17 _
>931a	00					.byte	 0	; $18 `
>931b	00					.byte	 0	; $19 !!25
>931c	00					.byte	 0	; $1a !!26
>931d	00					.byte	 0	; $1b {
>931e	01					.byte	 1	; $1c |
>931f	00					.byte	 0	; $1d }
>9320	00					.byte	 0	; $1e ~
>9321	00					.byte	 0	; $1f [7m<7F>[m
>9322	00					.byte	 0	; $20
>9323	05					.byte	 5	; $21 !
>9324	00					.byte	 0	; $22 "
>9325	00					.byte	 0	; $23 #
>9326	05					.byte	 5	; $24 $
>9327	04					.byte	 4	; $25 %
>9328	01					.byte	 1	; $26 &
>9329	00					.byte	 0	; $27 '
>932a	00					.byte	 0	; $28 (
>932b	00					.byte	 0	; $29 )
>932c	04					.byte	 4	; $2a *
>932d	03					.byte	 3	; $2b +
>932e	00					.byte	 0	; $2c ,
>932f	03					.byte	 3	; $2d -
>9330	00					.byte	 0	; $2e .
>9331	04					.byte	 4	; $2f /
>9332	00					.byte	 0	; $30 0
>9333	00					.byte	 0	; $31 1
>9334	00					.byte	 0	; $32 2
>9335	00					.byte	 0	; $33 3
>9336	00					.byte	 0	; $34 4
>9337	00					.byte	 0	; $35 5
>9338	00					.byte	 0	; $36 6
>9339	00					.byte	 0	; $37 7
>933a	00					.byte	 0	; $38 8
>933b	00					.byte	 0	; $39 9
>933c	00					.byte	 0	; $3a :
>933d	00					.byte	 0	; $3b ;
>933e	02					.byte	 2	; $3c <
>933f	02					.byte	 2	; $3d =
>9340	02					.byte	 2	; $3e >
>9341	05					.byte	 5	; $3f ?

;******  Return to file: ./common/expressions/expression.asm

.9342					EvaluateExpressionAt0:
.9342	a2 00		ldx #$00			ldx 	#0 							; bottom stack level
.9344					EvaluateExpression:
.9344	a9 00		lda #$00			lda 	#0 							; lowest precedence level
.9346					EvaluateExpressionAtPrecedence:
.9346	48		pha				pha 								; save precedence level
.9347	20 8e 97	jsr $978e			jsr 	EvaluateTerm 				; evaluate term into level X.
.934a	68		pla				pla 								; restore precedence level.
.934b					_EXPRLoop:
.934b	85 36		sta $36				sta 	zTemp0 						; save current precedence level.
.934d	b1 30		lda ($30),y			lda 	(codePtr),y
.934f	c9 40		cmp #$40			cmp		#$40 						; if >= $40 cannot be an operator
.9351	b0 25		bcs $9378			bcs 	_EXPRExit
.9353	da		phx				phx 								; read the operator precedence
.9354	aa		tax				tax
.9355	bd 02 93	lda $9302,x			lda 	PrecedenceLevel,x
.9358	fa		plx				plx
.9359	c9 00		cmp #$00			cmp 	#0							; if zero exit (not an operator)
.935b	f0 1b		beq $9378			beq 	_EXPRExit
.935d	85 37		sta $37				sta 	zTemp0+1 					; save operator precedence level.
.935f	a5 36		lda $36				lda 	zTemp0 						; compare current precedence vs. operator precedence
.9361	c5 37		cmp $37				cmp 	zTemp0+1
.9363	b0 13		bcs $9378			bcs		_EXPRExit 					; if current >= operator exit
.9365	48		pha				pha 								; save current precedence.
.9366	b1 30		lda ($30),y			lda 	(codePtr),y
.9368	c8		iny				iny
.9369	48		pha				pha
.936a	a5 37		lda $37				lda 	zTemp0+1 					; get operator precedence level
.936c	e8		inx				inx 								; work out the right hand side.
.936d	20 46 93	jsr $9346			jsr 	EvaluateExpressionAtPrecedence
.9370	ca		dex				dex
.9371	68		pla				pla 								; get operator, call the code.
.9372	20 7b 93	jsr $937b			jsr 	_EXPRCaller
.9375	68		pla				pla 								; restore precedence level
.9376	80 d3		bra $934b			bra 	_EXPRLoop 					; and go round.
.9378					_EXPRExit:
.9378	a5 36		lda $36				lda 	zTemp0 						; A = current precedence level.
.937a	60		rts				rts
.937b					_EXPRCaller:
.937b	da		phx				phx 								; save on stack, first thing is to restore it
.937c	0a		asl a				asl 	a 							; double so can use vectors into X
.937d	aa		tax				tax
.937e	7c 02 8b	jmp ($8b02,x)			jmp 	(VectorSetPunc,x) 			; and go to the code.

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/addsub.asm

.9381					FloatingPointAdd:
.9381	20 f7 94	jsr $94f7			jsr 	FloatPrepare 				; prepare for floats
.9384	80 09		bra $938f			bra 	FloatAdd
.9386					FloatingPointSub:
.9386	20 f7 94	jsr $94f7			jsr 	FloatPrepare 				; prepare for floats
.9389					FloatSubtract:
.9389	b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate FPB
.938b	49 80		eor #$80			eor 	#$80
.938d	95 51		sta $51,x			sta 	NSStatus+1,x				; and fall through.
.938f					FloatAdd:
.938f	48		pha				pha
.9390	5a		phy				phy
.9391	20 06 95	jsr $9506			jsr 	NSNormalise 				; normalise S[X]
.9394	f0 51		beq $93e7			beq 	_FAReturn1
.9396	e8		inx				inx 								; normalise S[X+1]
.9397	20 06 95	jsr $9506			jsr 	NSNormalise
.939a	ca		dex				dex
.939b	c9 00		cmp #$00			cmp 	#0
.939d	f0 60		beq $93ff			beq 	_FAExit 					; if so, just return A
.939f	b5 78		lda $78,x			lda 	NSExponent,x 				; are the exponents the same ?
.93a1	d5 79		cmp $79,x			cmp 	NSExponent+1,x
.93a3	f0 18		beq $93bd			beq 	_FAExponentsEqual
.93a5	b5 78		lda $78,x			lda 	NSExponent,x 				; work out the larger exponent
.93a7	a8		tay				tay
.93a8	38		sec				sec 								; do a signed comparison of the exponents.
.93a9	f5 79		sbc $79,x			sbc 	NSExponent+1,x
.93ab	50 02		bvc $93af			bvc 	_FANoSignedChange
.93ad	49 80		eor #$80			eor 	#$80
.93af					_FANoSignedChange:
.93af	29 80		and #$80			and 	#$80
.93b1	10 02		bpl $93b5			bpl 	_FAHaveMax
.93b3	b4 79		ldy $79,x			ldy 	NSExponent+1,x
.93b5					_FAHaveMax:
.93b5	20 02 94	jsr $9402			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.93b8	e8		inx				inx
.93b9	20 02 94	jsr $9402			jsr 	_FAShiftToExponent
.93bc	ca		dex				dex
.93bd					_FAExponentsEqual:
.93bd	b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs the same
.93bf	55 51		eor $51,x			eor 	NSStatus+1,x
.93c1	30 0e		bmi $93d1			bmi 	_FADifferentSigns
.93c3	20 3a 91	jsr $913a			jsr 	AddTopTwoStack 				; do the add of the mantissae
.93c6	b5 70		lda $70,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.93c8	10 35		bpl $93ff			bpl 	_FAExit 					; if no, we are done.
.93ca	20 69 9d	jsr $9d69			jsr 	NSMShiftRight 				; shift A right, renormalising it.
.93cd	f6 78		inc $78,x			inc 	NSExponent,x 				; bump the exponent and exit
.93cf	80 2e		bra $93ff			bra 	_FAExit
.93d1					_FADifferentSigns:
.93d1	20 54 91	jsr $9154			jsr 	SubTopTwoStack 				; subtract mantissa B from A
.93d4	b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the result negative ?
.93d6	10 06		bpl $93de			bpl 	_FACheckZero 				; if no, check for -0
.93d8	20 12 9d	jsr $9d12			jsr 	NSMNegate 					; netate result
.93db	20 19 9d	jsr $9d19			jsr 	NSMNegateMantissa 			; negate (2'c) the mantissa
.93de					_FACheckZero:
.93de	20 72 9d	jsr $9d72			jsr 	NSMIsZero	 				; check for -0
.93e1	d0 1c		bne $93ff			bne 	_FAExit
.93e3	74 50		stz $50,x			stz 	NSStatus,x
.93e5	80 18		bra $93ff			bra 	_FAExit
.93e7					_FAReturn1:
.93e7	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.93e9	95 58		sta $58,x			sta 	NSMantissa0,x
.93eb	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.93ed	95 60		sta $60,x			sta 	NSMantissa1,x
.93ef	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.93f1	95 68		sta $68,x			sta 	NSMantissa2,x
.93f3	b5 71		lda $71,x			lda 	NSMantissa3+1,x
.93f5	95 70		sta $70,x			sta 	NSMantissa3,x
.93f7	b5 79		lda $79,x			lda 	NSExponent+1,x
.93f9	95 78		sta $78,x			sta 	NSExponent,x
.93fb	b5 51		lda $51,x			lda 	NSStatus+1,x
.93fd	95 50		sta $50,x			sta 	NSStatus,x
.93ff					_FAExit:
.93ff	7a		ply				ply
.9400	68		pla				pla
.9401	60		rts				rts
.9402					_FAShiftToExponent:
.9402					_FAShiftToExponent2:
.9402	98		tya				tya 								; compare Y to exponent
.9403	d5 78		cmp $78,x			cmp 	NSExponent,x 				; reached the exponent required ?
.9405	f0 07		beq $940e			beq 	_FASEExit 					; exit if so.
.9407	20 69 9d	jsr $9d69			jsr 	NSMShiftRight	 			; shift the mantissa right
.940a	f6 78		inc $78,x			inc 	NSExponent,x 				; increment exponent
.940c	80 f4		bra $9402			bra 	_FAShiftToExponent2
.940e					_FASEExit:
.940e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/compare.asm

.940f					CompareFloat:
.940f	20 89 93	jsr $9389			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.9412	b5 60		lda $60,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.9414	29 f8		and #$f8			and 	#$F8
.9416	15 68		ora $68,x			ora 	NSMantissa2,x
.9418	15 70		ora $70,x			ora 	NSMantissa3,x
.941a	f0 08		beq $9424			beq 	_FCExit 					; zero, so approximately identical
.941c	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.941e	34 50		bit $50,x			bit 	NSStatus,x
.9420	10 02		bpl $9424			bpl 	_FCExit
.9422					_FCNegative:
.9422	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.9424					_FCExit:
.9424	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/divide.asm

.9425					FDivideCommand:
.9425	fa		plx				plx	 								; restore stack position
.9426	20 f7 94	jsr $94f7			jsr 	FloatPrepare 				; prepare for floats
.9429					FloatDivide:
.9429	48		pha				pha
.942a	e8		inx				inx
.942b	20 06 95	jsr $9506			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.942e	ca		dex				dex
.942f	c9 00		cmp #$00			cmp 	#0
.9431	f0 1d		beq $9450			beq 	_FDZero
.9433	20 06 95	jsr $9506			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.9436	f0 16		beq $944e			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.9438	20 2b 90	jsr $902b			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.943b	20 c7 8f	jsr $8fc7			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.943e	20 06 95	jsr $9506			jsr		NSNormalise 				; renormalise
.9441	20 bb 90	jsr $90bb			jsr 	CalculateSign 				; calculate result sign
.9444	b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent
.9446	38		sec				sec
.9447	f5 79		sbc $79,x			sbc 	NSExponent+1,x
.9449	38		sec				sec
.944a	e9 1e		sbc #$1e			sbc 	#30
.944c	95 78		sta $78,x			sta 	NSExponent,x
.944e					_FDExit:
.944e	68		pla				pla
.944f	60		rts				rts
.9450					_FDZero:
.9450	a9 03		lda #$03		lda	#3
.9452	4c 40 8e	jmp $8e40		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/fractional.asm

.9455					FloatFractionalPart:
.9455	5a		phy				phy
.9456	b5 50		lda $50,x			lda 	NSStatus,x 					; take absolute value
.9458	29 7f		and #$7f			and 	#$7F
.945a	95 50		sta $50,x			sta 	NSStatus,x
.945c	20 06 95	jsr $9506			jsr 	NSNormalise
.945f	b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.9461	38		sec				sec
.9462	e9 e0		sbc #$e0			sbc 	#$E0
.9464	90 29		bcc $948f			bcc 	_FFPExit 					; already fractional
.9466	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.9468	b0 22		bcs $948c			bcs 	_FFPZero
.946a	a8		tay				tay 								; put count to do in Y
.946b	b5 70		lda $70,x			lda 	NSMantissa3,x 				; do each in turn.
.946d	20 91 94	jsr $9491			jsr 	_FFPPartial
.9470	95 70		sta $70,x			sta 	NSMantissa3,x
.9472	b5 68		lda $68,x			lda 	NSMantissa2,x
.9474	20 91 94	jsr $9491			jsr 	_FFPPartial
.9477	95 68		sta $68,x			sta 	NSMantissa2,x
.9479	b5 60		lda $60,x			lda 	NSMantissa1,x
.947b	20 91 94	jsr $9491			jsr 	_FFPPartial
.947e	95 60		sta $60,x			sta 	NSMantissa1,x
.9480	b5 58		lda $58,x			lda 	NSMantissa0,x
.9482	20 91 94	jsr $9491			jsr 	_FFPPartial
.9485	95 58		sta $58,x			sta 	NSMantissa0,x
.9487	20 72 9d	jsr $9d72			jsr 	NSMIsZero 					; zeroed check.
.948a	d0 03		bne $948f			bne 	_FFPExit
.948c					_FFPZero:
.948c	20 50 9d	jsr $9d50			jsr 	NSMSetZero
.948f					_FFPExit:
.948f	7a		ply				ply
.9490	60		rts				rts
.9491					_FFPPartial:
.9491	c0 00		cpy #$00			cpy 	#0 							; no more to do
.9493	f0 17		beq $94ac			beq 	_FFFPPExit
.9495	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.9497	b0 0c		bcs $94a5			bcs 	_FFFPPWholeByte
.9499	5a		phy				phy
.949a					_FFFPPLeft:
.949a	0a		asl a				asl 	a
.949b	88		dey				dey
.949c	d0 fc		bne $949a			bne 	_FFFPPLeft
.949e	7a		ply				ply
.949f					_FFFPPRight:
.949f	4a		lsr a				lsr 	a
.94a0	88		dey				dey
.94a1	d0 fc		bne $949f			bne 	_FFFPPRight
.94a3	80 07		bra $94ac			bra 	_FFFPPExit
.94a5					_FFFPPWholeByte:
.94a5	98		tya				tya 								; subtract 8 from count
.94a6	38		sec				sec
.94a7	e9 08		sbc #$08			sbc 	#8
.94a9	a8		tay				tay
.94aa	a9 00		lda #$00			lda 	#0 							; and clear all
.94ac					_FFFPPExit:
.94ac	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/integer.asm

.94ad					FloatIntegerPart:
.94ad	48		pha				pha
.94ae	b5 78		lda $78,x			lda 	NSExponent,x 				; is it integer already ?
.94b0	f0 1d		beq $94cf			beq 	_FIPExit 					; if so do nothing
.94b2	20 72 9d	jsr $9d72			jsr 	NSMIsZero 					; is it zero ?
.94b5	f0 15		beq $94cc			beq 	_FIPZero 					; if so return zero.
.94b7	20 06 95	jsr $9506			jsr 	NSNormalise 				; normalise
.94ba	f0 10		beq $94cc			beq 	_FIPZero 					; normalised to zero, exit zero
.94bc					_FIPShift:
.94bc	b5 78		lda $78,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.94be	10 07		bpl $94c7			bpl 	_FIPCheckZero
.94c0	20 69 9d	jsr $9d69			jsr 	NSMShiftRight 				; shift mantissa right
.94c3	f6 78		inc $78,x			inc 	NSExponent,x 				; bump exponent
.94c5	80 f5		bra $94bc			bra 	_FIPShift
.94c7					_FIPCheckZero:
.94c7	20 72 9d	jsr $9d72			jsr 	NSMIsZero 					; avoid -0 problem
.94ca	d0 03		bne $94cf			bne 	_FIPExit 					; set to zero if mantissa zero.
.94cc					_FIPZero:
.94cc	20 50 9d	jsr $9d50			jsr 	NSMSetZero
.94cf					_FIPExit:
.94cf	68		pla				pla
.94d0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/multiply.asm

.94d1					FloatingPointMultiply:
.94d1	20 f7 94	jsr $94f7			jsr 	FloatPrepare 				; prepare for floats
.94d4					FloatMultiply:
.94d4	48		pha				pha
.94d5	20 06 95	jsr $9506			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.94d8	f0 18		beq $94f2			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.94da	e8		inx				inx
.94db	20 06 95	jsr $9506			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.94de	ca		dex				dex
.94df	c9 00		cmp #$00			cmp 	#0
.94e1	f0 0c		beq $94ef			beq 	_FDSetZero
.94e3	20 7d 90	jsr $907d			jsr 	MultiplyShort 				; calculate the result.
.94e6	75 78		adc $78,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.94e8	18		clc				clc
.94e9	75 79		adc $79,x			adc 	NSExponent+1,x
.94eb	95 78		sta $78,x			sta 	NSExponent,x
.94ed	80 03		bra $94f2			bra 	_FDExit
.94ef					_FDSetZero:
.94ef	20 50 9d	jsr $9d50			jsr 	NSMSetZero 					; return 0
.94f2					_FDExit:
.94f2	20 06 95	jsr $9506			jsr 	NSNormalise 				; normalise the result
.94f5	68		pla				pla
.94f6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/utility.asm

.94f7					FloatPrepare:
.94f7	20 02 96	jsr $9602			jsr 	DereferenceTopTwo 			; dereference the top two values
.94fa	b5 50		lda $50,x			lda 	NSStatus,x 					; check ints/floats
.94fc	15 51		ora $51,x			ora 	NSStatus+1,x
.94fe	29 10		and #$10			and 	#NSBIsString
.9500	d0 01		bne $9503			bne 	_FDType
.9502	60		rts				rts
.9503					_FDType:
.9503	4c d2 9e	jmp $9ed2			jmp 	TypeError
.9506					NSNormalise:
.9506	b5 50		lda $50,x			lda 	NSStatus,x 					; make float, keep sign
.9508	29 80		and #$80			and 	#$80
.950a	09 08		ora #$08			ora 	#NSTFloat
.950c	95 50		sta $50,x			sta 	NSStatus,x
.950e	20 72 9d	jsr $9d72			jsr 	NSMIsZero 					; if zero exit
.9511	d0 07		bne $951a			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.9513	16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.9515	76 50		ror $50,x			ror 	NSStatus,x 					; (no -0)
.9517	a9 00		lda #$00			lda 	#0 							; set Z flag
.9519	60		rts				rts
.951a					_NSNormaliseOptimise:
.951a	b5 70		lda $70,x			lda 	NSMantissa3,x 				; upper byte zero ?
.951c	d0 19		bne $9537			bne 	_NSNormaliseLoop
.951e	b5 68		lda $68,x			lda 	NSMantissa2,x 				; byte normalise
.9520	30 15		bmi $9537			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.9522	95 70		sta $70,x			sta 	NSMantissa3,x
.9524	b5 60		lda $60,x			lda 	NSMantissa1,x
.9526	95 68		sta $68,x			sta 	NSMantissa2,x
.9528	b5 58		lda $58,x			lda 	NSMantissa0,x
.952a	95 60		sta $60,x			sta 	NSMantissa1,x
.952c	74 58		stz $58,x			stz 	NSMantissa0,x
.952e	b5 78		lda $78,x			lda 	NSExponent,x
.9530	38		sec				sec
.9531	e9 08		sbc #$08			sbc 	#8
.9533	95 78		sta $78,x			sta 	NSExponent,x
.9535	80 e3		bra $951a			bra 	_NSNormaliseOptimise
.9537					_NSNormaliseLoop:
.9537	34 70		bit $70,x			bit 	NSMantissa3,x 				; bit 30 set ?
.9539	70 07		bvs $9542			bvs 	_NSNExit 					; exit if so with Z flag clear
.953b	20 5f 9d	jsr $9d5f			jsr 	NSMShiftLeft 				; shift mantissa left
.953e	d6 78		dec $78,x			dec 	NSExponent,x 				; adjust exponent
.9540	80 f5		bra $9537			bra 	_NSNormaliseLoop
.9542					_NSNExit:
.9542	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.9544	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignnumber.asm

.9545					AssignNumber:
.9545	5a		phy				phy
.9546	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy mantissa0/1 to zTemp0
.9548	85 36		sta $36				sta 	zTemp0
.954a	b5 60		lda $60,x			lda 	NSMantissa1,x
.954c	85 37		sta $37				sta 	zTemp0+1
.954e	b5 50		lda $50,x			lda 	NSStatus,x 					; clear reference bits
.9550	29 df		and #$df			and 	#(NSBIsReference ^ $FF)
.9552	95 50		sta $50,x			sta 	NSStatus,x
.9554	29 18		and #$18			and 	#NSBTypeMask				; assigning to a float ?
.9556	c9 08		cmp #$08			cmp 	#NSTFloat
.9558	f0 24		beq $957e			beq 	_ANFloat
.955a	b5 79		lda $79,x			lda		NSExponent+1,x 				; is it a float
.955c	f0 03		beq $9561			beq		_ANNotFloat
.955e	4c cd 9e	jmp $9ecd			jmp 	RangeError
.9561					_ANNotFloat:
.9561	b5 50		lda $50,x			lda 	NSStatus,x 					; check if byte/word reference.
.9563	29 03		and #$03			and 	#3
.9565	d0 05		bne $956c			bne 	_ANByteWord
.9567	20 89 95	jsr $9589			jsr 	_ANCopy4PackSign 			; copy all 4 bytes and sign
.956a	80 1b		bra $9587			bra 	_ANExit
.956c					_ANByteWord:
.956c	48		pha				pha 								; save count
.956d	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; do byte
.956f	92 36		sta ($36)			sta 	(zTemp0)
.9571	68		pla				pla
.9572	c9 01		cmp #$01			cmp	 	#1
.9574	f0 11		beq $9587			beq 	_ANExit
.9576	b5 61		lda $61,x			lda 	NSMantissa1+1,x 			; do word
.9578	a0 01		ldy #$01			ldy 	#1
.957a	91 36		sta ($36),y			sta 	(zTemp0),y
.957c	80 09		bra $9587			bra 	_ANExit
.957e					_ANFloat:
.957e	20 89 95	jsr $9589			jsr 	_ANCopy4PackSign 			; write all 4 bytes and packed sign
.9581	b5 79		lda $79,x			lda 	NSExponent+1,x 				; copy exponent to slot 4
.9583	a0 04		ldy #$04			ldy 	#4
.9585	91 36		sta ($36),y			sta 	(zTemp0),y
.9587					_ANExit:
.9587	7a		ply				ply
.9588	60		rts				rts
.9589					_ANCopy4PackSign:
.9589	a0 03		ldy #$03			ldy 	#3
.958b	b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign bit into status
.958d	29 80		and #$80			and 	#$80 						; put into high bit of mantissa 3
.958f	15 71		ora $71,x			ora 	NSMantissa3+1,x
.9591	91 36		sta ($36),y			sta 	(zTemp0),y
.9593	88		dey				dey
.9594	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.9596	91 36		sta ($36),y			sta 	(zTemp0),y
.9598	88		dey				dey
.9599	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.959b	91 36		sta ($36),y			sta 	(zTemp0),y
.959d	88		dey				dey
.959e	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.95a0	91 36		sta ($36),y			sta 	(zTemp0),y
.95a2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignstring.asm

.95a3					AssignString:
.95a3	5a		phy				phy
.95a4	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.95a6	85 38		sta $38				sta 	zTemp1
.95a8	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.95aa	85 39		sta $39				sta 	zTemp1+1
.95ac	b5 58		lda $58,x			lda 	NSMantissa0,x
.95ae	85 36		sta $36				sta 	zTemp0
.95b0	b5 60		lda $60,x			lda 	NSMantissa1,x
.95b2	85 37		sta $37				sta 	zTemp0+1
.95b4	a0 01		ldy #$01			ldy 	#1 							; the high byte of the target address
.95b6	b1 36		lda ($36),y			lda 	(zTemp0),y
.95b8	f0 23		beq $95dd			beq 	_ASNewStringRequired 		; if zero, a new string is required.
.95ba	38		sec				sec 								; put Address-2 in zsTemp - this is the size/status/string record
.95bb	b2 36		lda ($36)			lda 	(zTemp0) 					; of concreted strings
.95bd	e9 02		sbc #$02			sbc 	#2
.95bf	85 3c		sta $3c				sta 	zsTemp
.95c1	a0 01		ldy #$01			ldy 	#1
.95c3	b1 36		lda ($36),y			lda 	(zTemp0),y
.95c5	e9 00		sbc #$00			sbc 	#0
.95c7	85 3d		sta $3d				sta 	zsTemp+1
.95c9	a0 ff		ldy #$ff			ldy 	#$FF 						; get length of new string
.95cb					_ASGetLength:
.95cb	c8		iny				iny
.95cc	b1 38		lda ($38),y			lda 	(zTemp1),y
.95ce	d0 fb		bne $95cb			bne 	_ASGetLength
.95d0	98		tya				tya 								; is this length <= current length
.95d1	d2 3c		cmp ($3c)			cmp 	(zsTemp)
.95d3	90 1e		bcc $95f3			bcc 	_ASCopyString
.95d5	f0 1c		beq $95f3			beq 	_ASCopyString
.95d7	a9 80		lda #$80			lda 	#$80 						; mark as unused.
.95d9	a0 01		ldy #$01			ldy 	#1
.95db	91 3c		sta ($3c),y			sta 	(zsTemp),y
.95dd					_ASNewStringRequired:
.95dd	e8		inx				inx 								; concrete the new string.
.95de	20 ff a5	jsr $a5ff			jsr 	StringConcrete				; (breaks zTemp1/2, not zTemp0 and zsTemp)
.95e1	ca		dex				dex
.95e2	18		clc				clc
.95e3	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy that new address to the reference.
.95e5	69 02		adc #$02			adc 	#2 							; add two to point at the data.
.95e7	92 36		sta ($36)			sta 	(zTemp0)
.95e9	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.95eb	69 00		adc #$00			adc 	#0
.95ed	a0 01		ldy #$01			ldy 	#1
.95ef	91 36		sta ($36),y			sta 	(zTemp0),y
.95f1	80 0d		bra $9600			bra 	_ASExit
.95f3					_ASCopyString:
.95f3	a0 00		ldy #$00			ldy 	#0
.95f5					_ASCopyLoop:
.95f5	b1 38		lda ($38),y			lda 	(zTemp1),y
.95f7	c8		iny				iny
.95f8	c8		iny				iny
.95f9	91 3c		sta ($3c),y			sta 	(zsTemp),y
.95fb	88		dey				dey
.95fc	c9 00		cmp #$00			cmp 	#0
.95fe	d0 f5		bne $95f5			bne 	_ASCopyLoop
.9600					_ASExit:
.9600	7a		ply				ply
.9601	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/dereference.asm

.9602					DereferenceTopTwo:
.9602	e8		inx				inx
.9603	20 07 96	jsr $9607			jsr 	Dereference 				; deref x+1
.9606	ca		dex				dex  								; falls through to deref x
.9607					Dereference:
.9607	b5 50		lda $50,x			lda 	NSStatus,x 					; get the status byte
.9609	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.960b	f0 48		beq $9655			beq 	_DRFExit 					; not a reference, so exit.
.960d	5a		phy				phy
.960e	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address to dereference into zTemp0
.9610	85 36		sta $36				sta 	zTemp0
.9612	b5 60		lda $60,x			lda 	NSMantissa1,x
.9614	85 37		sta $37				sta 	zTemp0+1
.9616	74 60		stz $60,x			stz 	NSMantissa1,x 				; clear second byte.
.9618	b2 36		lda ($36)			lda 	(zTemp0) 					; do the first byte
.961a	95 58		sta $58,x			sta 	NSMantissa0,x
.961c	b5 50		lda $50,x			lda 	NSStatus,x 					; get status byte.
.961e	29 18		and #$18			and 	#NSBTypeMask 				; what type is it ?
.9620	c9 10		cmp #$10			cmp 	#NSTString 					; if string, dereference two
.9622	f0 0e		beq $9632			beq 	_DRFDereferenceTwo
.9624	c9 08		cmp #$08			cmp 	#NSTFloat 					; if float, do full dereference.
.9626	f0 2f		beq $9657			beq 	_DRFFull
.9628	b5 50		lda $50,x			lda 	NSStatus,x 					; must be integer - how many bytes ?
.962a	29 03		and #$03			and 	#3
.962c	f0 29		beq $9657			beq 	_DRFFull 					; the whole word
.962e	c9 01		cmp #$01			cmp 	#1 							; is it 10 (e.g. 2 bytes)
.9630	f0 06		beq $9638			beq		_DRFClear23 				; no, one byte, clear 2 & 3 and exit
.9632					_DRFDereferenceTwo:
.9632	a0 01		ldy #$01			ldy 	#1
.9634	b1 36		lda ($36),y			lda 	(zTemp0),y
.9636	95 60		sta $60,x			sta 	NSMantissa1,x
.9638					_DRFClear23:
.9638	74 68		stz $68,x			stz 	NSMantissa2,x 				; clear upper bytes, only read 1 or 2 bytes
.963a	74 70		stz $70,x			stz 	NSMantissa3,x
.963c	b5 50		lda $50,x			lda 	NSStatus,x 					; make it a value of that type.
.963e	29 18		and #$18			and 	#NSBTypeMask
.9640	95 50		sta $50,x			sta 	NSStatus,x 					; and fall through.
.9642	c9 10		cmp #$10			cmp 	#NSTString  				; is it a string
.9644	d0 0e		bne $9654			bne 	_DRFNotString
.9646	b5 58		lda $58,x			lda 	NSMantissa0,x 				; check address is zero
.9648	15 60		ora $60,x			ora 	NSMantissa1,x
.964a	d0 08		bne $9654			bne 	_DRFNotString
.964c	a9 56		lda #$56			lda 	#_DRFNullString & $FF 		; if so, return reference to ""
.964e	95 58		sta $58,x			sta 	NSMantissa0,X
.9650	a9 96		lda #$96			lda 	#_DRFNullString >> 8
.9652	95 60		sta $60,x			sta 	NSMantissa1,X
.9654					_DRFNotString
.9654	7a		ply				ply 								; restore Y and exit
.9655					_DRFExit:
.9655	60		rts				rts
.9656					_DRFNullString:
>9656	00						.byte 	0
.9657					_DRFFull:
.9657	a0 01		ldy #$01			ldy 	#1 							; get remaining 3 bytes.
.9659	b1 36		lda ($36),y			lda 	(zTemp0),y
.965b	95 60		sta $60,x			sta 	NSMantissa1,x
.965d	c8		iny				iny
.965e	b1 36		lda ($36),y			lda 	(zTemp0),y
.9660	95 68		sta $68,x			sta 	NSMantissa2,x
.9662	c8		iny				iny
.9663	b1 36		lda ($36),y			lda 	(zTemp0),y
.9665	95 70		sta $70,x			sta 	NSMantissa3,x
.9667	74 78		stz $78,x			stz 	NSExponent,x 				; clear exponent.
.9669	b5 50		lda $50,x			lda		NSStatus,x 					; see if type is integer
.966b	29 18		and #$18			and 	#NSBTypeMask  				; type information only
.966d	95 50		sta $50,x			sta 	NSStatus,x 					; update it back.
.966f	f0 05		beq $9676			beq 	_DRFNoExponent
.9671	c8		iny				iny 								; if not, read the exponent as well.
.9672	b1 36		lda ($36),y			lda 	(zTemp0),y
.9674	95 78		sta $78,x			sta 	NSExponent,x
.9676					_DRFNoExponent:
.9676	b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the most significant bit set ?
.9678	10 0a		bpl $9684			bpl 	_DRFExit2 					; if not, then exit.
.967a	29 7f		and #$7f			and 	#$7F 						; clear that bit.
.967c	95 70		sta $70,x			sta 	NSMantissa3,x
.967e	b5 50		lda $50,x			lda 	NSStatus,x 					; set the sign flag
.9680	09 80		ora #$80			ora 	#NSBIsNegative
.9682	95 50		sta $50,x			sta 	NSStatus,x
.9684					_DRFExit2:
.9684	7a		ply				ply
.9685	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/number.asm

=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.9686					EncodeNumberStart:
.9686	38		sec				sec
.9687	80 01		bra $968a			bra 	EncodeNumberContinue+1
.9689					EncodeNumberContinue:
.9689	18		clc				clc
.968a					EncodeNumber:
.968a	08		php				php 								; save reset flag.
.968b	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.968d	f0 12		beq $96a1			beq 	_ENIsOkay
.968f	c9 30		cmp #$30			cmp 	#"0"
.9691	90 04		bcc $9697			bcc 	_ENBadNumber
.9693	c9 3a		cmp #$3a			cmp 	#"9"+1
.9695	90 0a		bcc $96a1			bcc 	_ENIsOkay
.9697					_ENBadNumber:
.9697	28		plp				plp 								; throw saved reset
.9698	ad 05 04	lda $0405			lda 	EncodeState 				; if in decimal mode, construct final number
.969b	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.969d	f0 7b		beq $971a			beq 	_ENConstructFinal
.969f					_ENFail:
.969f	18		clc				clc 								; not allowed
.96a0	60		rts				rts
.96a1					_ENIsOkay:
.96a1	28		plp				plp 								; are we restarting
.96a2	90 15		bcc $96b9			bcc 	_ENNoRestart
.96a4					_ENStartEncode:
.96a4	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.96a6	f0 0c		beq $96b4			beq 	_ENFirstDP
.96a8	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.96aa	20 52 9d	jsr $9d52			jsr 	NSMSetByte 					; in single byte mode.
.96ad	a9 01		lda #$01			lda 	#ESTA_Low
.96af					_ENExitChange:
.96af	8d 05 04	sta $0405			sta 	EncodeState 				; save new state
.96b2	38		sec				sec
.96b3	60		rts				rts
.96b4					_ENFirstDP:
.96b4	20 50 9d	jsr $9d50			jsr 	NSMSetZero 					; clear integer part
.96b7	80 3c		bra $96f5			bra 	_ESTASwitchFloat			; go straight to float and exi
.96b9					_ENNoRestart:
.96b9	48		pha				pha 								; save digit or DP on stack.
.96ba	ad 05 04	lda $0405			lda 	EncodeState 				; get current state
.96bd	c9 01		cmp #$01			cmp 	#ESTA_Low
.96bf	f0 09		beq $96ca			beq  	_ESTALowState
.96c1	c9 02		cmp #$02			cmp 	#ESTA_High
.96c3	f0 26		beq $96eb			beq 	_ESTAHighState
.96c5	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.96c7	f0 38		beq $9701			beq 	_ESTADecimalState
>96c9	db						.byte 	$DB 						; causes a break in the emulator
.96ca					_ESTALowState:
.96ca	68		pla				pla 								; get value back
.96cb	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.96cd	f0 26		beq $96f5			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.96cf	29 0f		and #$0f			and 	#15 						; make digit
.96d1	8d 06 04	sta $0406			sta 	DigitTemp 					; save it.
.96d4	b5 58		lda $58,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.96d6	0a		asl a				asl 	a
.96d7	0a		asl a				asl 	a
.96d8	75 58		adc $58,x			adc 	NSMantissa0,x
.96da	0a		asl a				asl 	a
.96db	6d 06 04	adc $0406			adc 	DigitTemp
.96de	95 58		sta $58,x			sta 	NSMantissa0,x
.96e0	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.96e2	90 05		bcc $96e9			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.96e4	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.96e6	8d 05 04	sta $0405			sta 	EncodeState
.96e9					_ESTANoSwitch:
.96e9	38		sec				sec
.96ea	60		rts				rts
.96eb					_ESTAHighState:
.96eb	68		pla				pla 								; get value back
.96ec	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.96ee	f0 05		beq $96f5			beq 	_ESTASwitchFloat
.96f0	20 4e 97	jsr $974e			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.96f3	38		sec				sec
.96f4	60		rts				rts
.96f5					_ESTASwitchFloat:
.96f5	9c 07 04	stz $0407			stz 	DecimalCount 				; reset the count of digits - we divide by 10^n at the end.
.96f8	e8		inx				inx 								; zero the decimal additive.
.96f9	20 50 9d	jsr $9d50			jsr 	NSMSetZero
.96fc	ca		dex				dex
.96fd	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.96ff	80 ae		bra $96af			bra 	_ENExitChange
.9701					_ESTADecimalState:
.9701	68		pla				pla 								; digit.
.9702	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 2nd decimal point.
.9704	f0 99		beq $969f			beq 	_ENFail
.9706	e8		inx				inx 								; put digit into fractional part of X+1
.9707	20 4e 97	jsr $974e			jsr 	ESTAShiftDigitIntoMantissa
.970a	ca		dex				dex
.970b	ee 07 04	inc $0407			inc 	DecimalCount 				; bump the count of decimals
.970e	ad 07 04	lda $0407			lda 	DecimalCount 				; too many decimal digits.
.9711	c9 0b		cmp #$0b			cmp 	#11
.9713	f0 02		beq $9717			beq 	_ESTADSFail
.9715	38		sec				sec
.9716	60		rts				rts
.9717					_ESTADSFail:
.9717	4c cd 9e	jmp $9ecd			jmp 	RangeError
.971a					_ENConstructFinal:
.971a	ad 07 04	lda $0407			lda 	DecimalCount 				; get decimal count
.971d	f0 2d		beq $974c			beq 	_ENCFExit 					; no decimals
.971f	5a		phy				phy
.9720	0a		asl a				asl 	a 							; x 4 and CLC
.9721	0a		asl a				asl 	a
.9722	6d 07 04	adc $0407			adc 	DecimalCount
.9725	a8		tay				tay
.9726	b9 8c 9e	lda $9e8c,y			lda 	DecimalScalarTable-5,y 		; copy decimal scalar to X+2
.9729	95 5a		sta $5a,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.972b	b9 8d 9e	lda $9e8d,y			lda 	DecimalScalarTable-5+1,y
.972e	95 62		sta $62,x			sta 	NSMantissa1+2,x
.9730	b9 8e 9e	lda $9e8e,y			lda 	DecimalScalarTable-5+2,y
.9733	95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.9735	b9 8f 9e	lda $9e8f,y			lda 	DecimalScalarTable-5+3,y
.9738	95 72		sta $72,x			sta 	NSMantissa3+2,x
.973a	b9 90 9e	lda $9e90,y			lda 	DecimalScalarTable-5+4,y
.973d	95 7a		sta $7a,x			sta 	NSExponent+2,x
.973f	a9 08		lda #$08			lda 	#NSTFloat
.9741	95 52		sta $52,x			sta 	NSStatus+2,x
.9743	7a		ply				ply
.9744	e8		inx				inx 								; multiply decimal const by decimal scalar
.9745	20 d4 94	jsr $94d4			jsr 	FloatMultiply
.9748	ca		dex				dex
.9749	20 8f 93	jsr $938f			jsr 	FloatAdd 					; add to integer part.
.974c					_ENCFExit:
.974c	18		clc				clc 								; reject the digit.
.974d	60		rts				rts
.974e					ESTAShiftDigitIntoMantissa:
.974e	29 0f		and #$0f			and 	#15 						; save digit
.9750	48		pha				pha
.9751	b5 70		lda $70,x			lda 	NSMantissa3,x 				; push mantissa on stack
.9753	48		pha				pha
.9754	b5 68		lda $68,x			lda 	NSMantissa2,x
.9756	48		pha				pha
.9757	b5 60		lda $60,x			lda 	NSMantissa1,x
.9759	48		pha				pha
.975a	b5 58		lda $58,x			lda 	NSMantissa0,x
.975c	48		pha				pha
.975d	20 5f 9d	jsr $9d5f			jsr 	NSMShiftLeft 				; x 2
.9760	20 5f 9d	jsr $9d5f			jsr 	NSMShiftLeft 				; x 4
.9763	18		clc				clc 								; pop mantissa and add
.9764	68		pla				pla
.9765	75 58		adc $58,x			adc 	NSMantissa0,x
.9767	95 58		sta $58,x			sta 	NSMantissa0,x
.9769	68		pla				pla
.976a	75 60		adc $60,x			adc 	NSMantissa1,x
.976c	95 60		sta $60,x			sta 	NSMantissa1,x
.976e	68		pla				pla
.976f	75 68		adc $68,x			adc 	NSMantissa2,x
.9771	95 68		sta $68,x			sta 	NSMantissa2,x
.9773	68		pla				pla
.9774	75 70		adc $70,x			adc 	NSMantissa3,x
.9776	95 70		sta $70,x			sta 	NSMantissa3,x 				; x 5
.9778	20 5f 9d	jsr $9d5f			jsr 	NSMShiftLeft 				; x 10
.977b	68		pla				pla 								; add digit
.977c	18		clc				clc
.977d	75 58		adc $58,x			adc 	NSMantissa0,x
.977f	95 58		sta $58,x			sta 	NSMantissa0,x
.9781	90 0a		bcc $978d			bcc 	_ESTASDExit
.9783	f6 60		inc $60,x			inc 	NSMantissa1,x
.9785	d0 06		bne $978d			bne 	_ESTASDExit
.9787	f6 68		inc $68,x			inc 	NSMantissa2,x
.9789	d0 02		bne $978d			bne 	_ESTASDExit
.978b	f6 70		inc $70,x			inc 	NSMantissa3,x
.978d					_ESTASDExit:
.978d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/term.asm

.978e					EvaluateTerm:
.978e	b1 30		lda ($30),y			lda 	(codePtr),y
.9790	30 18		bmi $97aa			bmi 	_ETCheckUnary 				; unary function ? (text ones)
.9792	c9 40		cmp #$40			cmp 	#$40 						; 40-7F => identifier reference
.9794	b0 6c		bcs $9802			bcs 	_ETVariable
.9796	c9 30		cmp #$30			cmp 	#'0' 						; is it a number
.9798	90 6b		bcc $9805			bcc 	_ETPuncUnary 				; if not it might be a punctuation unary.
.979a	c9 3a		cmp #$3a			cmp 	#'9'+1
.979c	b0 67		bcs $9805			bcs 	_ETPuncUnary
.979e	20 86 96	jsr $9686			jsr 	EncodeNumberStart 			; can't fail as it's 0-9 !
.97a1					_ETNumber:
.97a1	c8		iny				iny 								; keep encoding until we have the numbers
.97a2	b1 30		lda ($30),y			lda 	(codePtr),y
.97a4	20 89 96	jsr $9689			jsr 	EncodeNumberContinue
.97a7	b0 f8		bcs $97a1			bcs 	_ETNumber 					; go back if accepted.
.97a9	60		rts				rts
.97aa					_ETCheckUnary:
.97aa	c9 ff		cmp #$ff			cmp 	#KWC_STRING 				; string token
.97ac	f0 3f		beq $97ed			beq 	_ETString
.97ae	c9 fe		cmp #$fe			cmp 	#KWC_HEXCONST 				; hex constant.
.97b0	f0 12		beq $97c4			beq 	_ETHexConstant
.97b2	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; check it actually is a unary function
.97b4	90 0b		bcc $97c1			bcc 	_ETSyntaxError
.97b6	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1
.97b8	b0 07		bcs $97c1			bcs 	_ETSyntaxError
.97ba	da		phx				phx 								; push X on the stack
.97bb	0a		asl a				asl 	a 							; put vector x 2 into X
.97bc	aa		tax				tax
.97bd	c8		iny				iny 								; consume unary function token
.97be	7c 82 8b	jmp ($8b82,x)			jmp 	(VectorSet0,x) 				; and do it.
.97c1					_ETSyntaxError:
.97c1	4c c8 9e	jmp $9ec8			jmp 	SyntaxError
.97c4					_ETHexConstant:
.97c4	c8		iny				iny 								; skip #
.97c5	c8		iny				iny 								; skip count
.97c6	20 50 9d	jsr $9d50			jsr 	NSMSetZero 					; clear result
.97c9					_ETHLoop:
.97c9	b1 30		lda ($30),y			lda 	(codePtr),y
.97cb	c8		iny				iny 								; and consume
.97cc	c9 00		cmp #$00			cmp 	#0 							; exit if zero
.97ce	f0 1c		beq $97ec			beq 	_ETHExit
.97d0	48		pha				pha 								; save on stack.
.97d1	20 5f 9d	jsr $9d5f			jsr 	NSMShiftLeft 				; x 2
.97d4	20 5f 9d	jsr $9d5f			jsr 	NSMShiftLeft 				; x 4
.97d7	20 5f 9d	jsr $9d5f			jsr 	NSMShiftLeft 				; x 8
.97da	20 5f 9d	jsr $9d5f			jsr 	NSMShiftLeft 				; x 16
.97dd	68		pla				pla 								; ASCII
.97de	c9 41		cmp #$41			cmp 	#'A'
.97e0	90 02		bcc $97e4			bcc 	_ETHNotChar
.97e2	e9 07		sbc #$07			sbc 	#7
.97e4					_ETHNotChar:
.97e4	29 0f		and #$0f			and 	#15 						; digit now
.97e6	15 58		ora $58,x			ora 	NSMantissa0,x 				; put in LS Nibble
.97e8	95 58		sta $58,x			sta 	NSMantissa0,x
.97ea	80 dd		bra $97c9			bra 	_ETHLoop 					; go round.
.97ec					_ETHExit:
.97ec	60		rts				rts
.97ed					_ETString:
.97ed	c8		iny				iny 								; look at length
.97ee	b1 30		lda ($30),y			lda 	(codePtr),y
.97f0	48		pha				pha
.97f1	c8		iny				iny 								; first character
.97f2	20 a5 a4	jsr $a4a5			jsr 	MemoryInline 				; put address of string at (code-Ptr),y on stack
.97f5	68		pla				pla 								; restore count and save
.97f6	85 36		sta $36				sta 	zTemp0
.97f8	98		tya				tya 								; add length to Y to skip it.
.97f9	18		clc				clc
.97fa	65 36		adc $36				adc 	zTemp0
.97fc	a8		tay				tay
.97fd	a9 10		lda #$10			lda 	#NSTString 					; mark as string
.97ff	95 50		sta $50,x			sta 	NSStatus,x
.9801	60		rts				rts
.9802					_ETVariable:
.9802	4c 57 98	jmp $9857			jmp 	VariableHandler
.9805					_ETPuncUnary:
.9805	c8		iny				iny 								; consume the unary character
.9806	c9 2d		cmp #$2d			cmp 	#KWD_MINUS 					; unary minus
.9808	f0 2b		beq $9835			beq 	_ETUnaryNegate
.980a	c9 10		cmp #$10			cmp 	#KWD_AT 					; @ reference -> constant
.980c	f0 36		beq $9844			beq 	_ETDereference
.980e	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; parenthesis
.9810	f0 3e		beq $9850			beq 	_ETParenthesis
.9812	64 36		stz $36				stz 	zTemp0 						; zTemp0 is the indirection level.
.9814	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; byte indirection (0) ?
.9816	f0 06		beq $981e			beq 	_ETIndirection
.9818	e6 36		inc $36				inc 	zTemp0
.981a	c9 21		cmp #$21			cmp 	#KWD_PLING					; word indirection (1) \
.981c	d0 a3		bne $97c1			bne 	_ETSyntaxError
.981e					_ETIndirection:
.981e	a5 36		lda $36				lda 	zTemp0 						; push indirection amount (0-1) => (1-2) on the stack
.9820	1a		inc a				inc 	a
.9821	48		pha				pha
.9822	20 8e 97	jsr $978e			jsr 	EvaluateTerm				; evaluate the term
.9825	20 07 96	jsr $9607			jsr 	Dereference 				; dereference it.
.9828	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a +ve integer.
.982a	d0 06		bne $9832			bne 	_ETTypeMismatch
.982c	68		pla				pla 								; indirection 1-2
.982d	09 20		ora #$20			ora 	#NSBIsReference 			; make it a reference.
.982f	95 50		sta $50,x			sta 	NSStatus,x
.9831	60		rts				rts
.9832					_ETTypeMismatch:
.9832	4c d2 9e	jmp $9ed2			jmp 	TypeError
.9835					_ETUnaryNegate:
.9835	20 8e 97	jsr $978e			jsr 	EvaluateTerm				; evaluate the term
.9838	20 07 96	jsr $9607			jsr 	Dereference 				; dereference it.
.983b	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a number
.983d	29 10		and #$10			and 	#NSTString
.983f	d0 f1		bne $9832			bne 	_ETTypeMismatch
.9841	4c 12 9d	jmp $9d12			jmp 	NSMNegate  					; just toggles the sign bit.
.9844					_ETDereference:
.9844	20 8e 97	jsr $978e			jsr 	EvaluateTerm				; evaluate the term
.9847	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a reference
.9849	29 20		and #$20			and 	#NSBIsReference
.984b	f0 e5		beq $9832			beq 	_ETTypeMismatch
.984d	74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer address
.984f	60		rts				rts
.9850					_ETParenthesis:
.9850	20 44 93	jsr $9344			jsr 	EvaluateExpression 			; evaluate here, from lowest precedence
.9853	20 27 8e	jsr $8e27			jsr 	CheckRightBracket 			; check for )
.9856	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/variable.asm

.9857					VariableHandler:
.9857	b1 30		lda ($30),y			lda 	(codePtr),y
.9859	18		clc				clc
.985a	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.985c	85 37		sta $37				sta 	zTemp0+1
.985e	c8		iny				iny
.985f	b1 30		lda ($30),y			lda 	(codePtr),y
.9861	85 36		sta $36				sta 	zTemp0
.9863	c8		iny				iny
.9864	18		clc				clc									; copy variable address+3 to mantissa
.9865	69 03		adc #$03			adc 	#3
.9867	95 58		sta $58,x			sta 	NSMantissa0,x
.9869	a5 37		lda $37				lda 	zTemp0+1
.986b	69 00		adc #$00			adc 	#0
.986d	95 60		sta $60,x			sta 	NSMantissa1,x
.986f	74 68		stz $68,x			stz 	NSMantissa2,x
.9871	74 70		stz $70,x			stz 	NSMantissa3,x
.9873	74 78		stz $78,x			stz 	NSExponent,x
.9875	5a		phy				phy
.9876	a0 02		ldy #$02			ldy 	#2 							; read type
.9878	b1 36		lda ($36),y			lda 	(zTemp0),y
.987a	7a		ply				ply
.987b	29 1c		and #$1c			and 	#NSBTypeMask+NSBIsArray 	; get type information
.987d	09 20		ora #$20			ora 	#NSBIsReference 			; make a reference.
.987f	95 50		sta $50,x			sta 	NSStatus,x
.9881	29 04		and #$04			and 	#NSBIsArray
.9883	d0 01		bne $9886			bne 	_VHArray
.9885	60		rts				rts
.9886					_VHArray:
.9886	e8		inx				inx
.9887	20 eb 9c	jsr $9ceb			jsr 	Evaluate8BitInteger 		; get the 1st index.
.988a	a9 ff		lda #$ff			lda 	#$FF 						; set Status of X+2 to a duff value so we know if we picked it up.
.988c	95 51		sta $51,x			sta 	NSStatus+1,x
.988e	b1 30		lda ($30),y			lda 	(codePtr),y
.9890	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.9892	d0 06		bne $989a			bne 	_VHNoSecondIndex
.9894	c8		iny				iny 								; skip the comma
.9895	e8		inx				inx
.9896	20 eb 9c	jsr $9ceb			jsr 	Evaluate8BitInteger 		; get the 2nd index.
.9899	ca		dex				dex
.989a					_VHNoSecondIndex:
.989a	ca		dex				dex 								; set X back.
.989b	20 27 8e	jsr $8e27			jsr 	CheckRightBracket 			; and check the right bracket.
.989e	5a		phy				phy 								; save position
.989f	a0 02		ldy #$02			ldy 	#2 							; check first index is not-zero, e.g. array defined
.98a1	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.98a3	f0 60		beq $9905			beq 	_VHBadIndex
.98a5	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy record address to zaTemp
.98a7	85 3e		sta $3e				sta 	zaTemp
.98a9	b5 60		lda $60,x			lda 	NSMantissa1,x
.98ab	85 3f		sta $3f				sta 	zaTemp+1
.98ad	a0 03		ldy #$03			ldy 	#3 							; get the second index - which is 0 if there is one index.
.98af	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.98b1	f0 02		beq $98b5			beq 	_VHHas2Mask
.98b3	a9 ff		lda #$ff			lda 	#$FF
.98b5					_VHHas2Mask:
.98b5	d5 52		cmp $52,x			cmp 	NSStatus+2,x 				; so if they are the same there are the wrong number of indices
.98b7	f0 4c		beq $9905			beq 	_VHBadIndex
.98b9	0a		asl a				asl 	a 							; carry will be set if a second index
.98ba	90 08		bcc $98c4			bcc 	_VHCheckFirstIndex
.98bc	a0 03		ldy #$03			ldy 	#3 			 				; check the 2nd size >= 2nd index
.98be	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.98c0	d5 5a		cmp $5a,x			cmp 	NSMantissa0+2,x
.98c2	90 41		bcc $9905			bcc 	_VHBadIndex
.98c4					_VHCheckFirstIndex:
.98c4	a0 02		ldy #$02			ldy 	#2 			 				; check the 2nd size >= 2nd index
.98c6	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.98c8	d5 59		cmp $59,x			cmp 	NSMantissa0+1,x
.98ca	90 39		bcc $9905			bcc 	_VHBadIndex
.98cc	64 36		stz $36				stz 	zTemp0 						; clear zTemp0 (if 1 index)
.98ce	64 37		stz $37				stz 	zTemp0+1
.98d0	b5 52		lda $52,x			lda 	NSStatus+2,x 				; if only one index provided, don't need to multiply
.98d2	30 0e		bmi $98e2			bmi 	_VHNoMultiply
.98d4	da		phx				phx
.98d5	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; get 2nd index on stack
.98d7	48		pha				pha
.98d8	a0 02		ldy #$02			ldy 	#2 							; get 1st size in A
.98da	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.98dc	1a		inc a				inc 	a 							; add 1 for zero base
.98dd	fa		plx				plx
.98de	20 fb 9c	jsr $9cfb			jsr 	Multiply8x8 				; calculate -> Z0
.98e1	fa		plx				plx
.98e2					_VHNoMultiply:
.98e2	18		clc				clc
.98e3	a5 36		lda $36				lda 	zTemp0
.98e5	75 59		adc $59,x			adc 	NSMantissa0+1,x
.98e7	85 36		sta $36				sta 	zTemp0
.98e9	a5 37		lda $37				lda 	zTemp0+1
.98eb	69 00		adc #$00			adc 	#0
.98ed	85 37		sta $37				sta 	zTemp0+1
.98ef	b5 50		lda $50,x			lda 	NSStatus,x
.98f1	20 03 85	jsr $8503			jsr 	ScaleByBaseType
.98f4	18		clc				clc
.98f5	b2 3e		lda ($3e)			lda 	(zaTemp)
.98f7	65 36		adc $36				adc 	zTemp0
.98f9	95 58		sta $58,x			sta 	NSMantissa0,x
.98fb	a0 01		ldy #$01			ldy 	#1
.98fd	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.98ff	65 37		adc $37				adc 	zTemp0+1
.9901	95 60		sta $60,x			sta 	NSMantissa1,x
.9903	7a		ply				ply 								; restore position
.9904	60		rts				rts
.9905					_VHBadIndex:
.9905	a9 17		lda #$17		lda	#23
.9907	4c 40 8e	jmp $8e40		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/abs.asm

.990a					AbsUnary:
.990a	fa		plx				plx 								; restore stack pos
.990b	20 9e 9c	jsr $9c9e			jsr 	EvaluateNumber 				; get a float or int
.990e	20 27 8e	jsr $8e27			jsr 	CheckRightBracket
.9911	b5 50		lda $50,x			lda 	NSStatus,x 					; clear the sign bit
.9913	29 7f		and #$7f			and 	#$7F
.9915	95 50		sta $50,x			sta 	NSStatus,x
.9917	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/alloc.asm

.9918					AllocUnary:
.9918	fa		plx				plx 								; restore stack pos
.9919	20 d0 9c	jsr $9cd0			jsr 	Evaluate16BitInteger		; get bytes required.
.991c	20 27 8e	jsr $8e27			jsr 	CheckRightBracket
.991f	da		phx				phx 								; save X/Y
.9920	5a		phy				phy
.9921	8a		txa				txa 								; copy X into Y
.9922	a8		tay				tay
.9923	b9 60 00	lda $0060,y			lda		NSMantissa1,y 				; get size
.9926	aa		tax				tax
.9927	b9 58 00	lda $0058,y			lda 	NSMantissa0,y
.992a	20 37 99	jsr $9937			jsr 	AllocateXABytes 			; allocate memory
.992d	99 58 00	sta $0058,y			sta 	NSMantissa0,y 				; write address out.
.9930	8a		txa				txa
.9931	99 60 00	sta $0060,y			sta 	NSMantissa1,y
.9934	7a		ply				ply
.9935	fa		plx				plx
.9936	60		rts				rts
.9937					AllocateXABytes:
.9937	5a		phy				phy
.9938	ac 0c 04	ldy $040c			ldy 	lowMemPtr 					; push current address on stack and to zTemp0
.993b	84 36		sty $36				sty 	zTemp0
.993d	5a		phy				phy
.993e	ac 0d 04	ldy $040d			ldy 	lowMemPtr+1
.9941	84 37		sty $37				sty 	zTemp0+1
.9943	5a		phy				phy
.9944	18		clc				clc 								; add to low memory pointer
.9945	6d 0c 04	adc $040c			adc 	lowMemPtr
.9948	8d 0c 04	sta $040c			sta 	lowMemPtr
.994b	8a		txa				txa
.994c	6d 0d 04	adc $040d			adc 	lowMemPtr+1
.994f	8d 0d 04	sta $040d			sta 	lowMemPtr+1
.9952	b0 2f		bcs $9983			bcs 	CISSMemory
.9954	20 75 99	jsr $9975			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.9957					_ClearMemory:
.9957	ad 0c 04	lda $040c			lda 	lowMemPtr 					; cleared all memory allocated
.995a	c5 36		cmp $36				cmp 	zTemp0
.995c	d0 07		bne $9965			bne 	_CMClearNext
.995e	ad 0d 04	lda $040d			lda 	lowMemPtr+1
.9961	c5 37		cmp $37				cmp 	zTemp0+1
.9963	f0 0c		beq $9971			beq 	_CMExit
.9965					_CMClearNext:
.9965	a9 00		lda #$00			lda 	#0 							; clear byte, advance to next.
.9967	92 36		sta ($36)			sta 	(zTemp0)
.9969	e6 36		inc $36				inc 	zTemp0
.996b	d0 ea		bne $9957			bne 	_ClearMemory
.996d	e6 37		inc $37				inc		zTemp0+1
.996f	80 e6		bra $9957			bra 	_ClearMemory
.9971					_CMExit:
.9971	fa		plx				plx
.9972	68		pla				pla
.9973	7a		ply				ply
.9974	60		rts				rts
.9975					CheckIdentifierStringSpace:
.9975	48		pha				pha
.9976	ad 0d 04	lda $040d			lda 	lowMemPtr+1 				; get low memory pointer
.9979	18		clc				clc
.997a	69 02		adc #$02			adc 	#2 							; need at least 2 256 byte pages
.997c	cd 0f 04	cmp $040f			cmp 	StringMemory+1 				; is it >= StringMemory
.997f	b0 02		bcs $9983			bcs 	CISSMemory
.9981	68		pla				pla
.9982	60		rts				rts
.9983					CISSMemory:
.9983	a9 06		lda #$06		lda	#6
.9985	4c 40 8e	jmp $8e40		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/asc.asm

.9988					AscUnary:
.9988	fa		plx				plx 								; restore stack pos
.9989	20 a8 9c	jsr $9ca8			jsr 	EvaluateString 				; get a string
.998c	b2 36		lda ($36)			lda 	(zTemp0)					; get/return first character
.998e	20 52 9d	jsr $9d52			jsr 	NSMSetByte 					; ASC("") will return zero.
.9991	20 27 8e	jsr $8e27			jsr 	CheckRightBracket
.9994	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/frac.asm

.9995					FracUnary:
.9995	fa		plx				plx 								; restore stack pos
.9996	20 9e 9c	jsr $9c9e			jsr 	EvaluateNumber 				; get a float or int
.9999	20 27 8e	jsr $8e27			jsr 	CheckRightBracket
.999c	b5 50		lda $50,x			lda 	NSStatus,x
.999e	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.99a0	f0 04		beq $99a6			beq 	_IUZero
.99a2	20 55 94	jsr $9455			jsr 	FloatFractionalPart
.99a5	60		rts				rts
.99a6					_IUZero:
.99a6	20 50 9d	jsr $9d50			jsr 	NSMSetZero
.99a9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/int.asm

.99aa					IntUnary:
.99aa	fa		plx				plx 								; restore stack pos
.99ab	20 9e 9c	jsr $9c9e			jsr 	EvaluateNumber 				; get a float or int
.99ae	20 27 8e	jsr $8e27			jsr 	CheckRightBracket
.99b1	b5 50		lda $50,x			lda 	NSStatus,x
.99b3	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.99b5	f0 03		beq $99ba			beq 	_IUExit
.99b7	20 ad 94	jsr $94ad			jsr 	FloatIntegerPart
.99ba					_IUExit:
.99ba	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/len.asm

.99bb					LenUnary:
.99bb	fa		plx				plx 								; restore stack pos
.99bc	20 a8 9c	jsr $9ca8			jsr 	EvaluateString 				; get a string
.99bf	5a		phy				phy
.99c0	a0 00		ldy #$00			ldy 	#0 							; find length
.99c2					_LenFind:
.99c2	b1 36		lda ($36),y			lda 	(zTemp0),y 					; look for trailing NULL.
.99c4	f0 06		beq $99cc			beq 	_LenExit
.99c6	c8		iny				iny
.99c7	d0 f9		bne $99c2			bne 	_LenFind
.99c9	4c cd 9e	jmp $9ecd			jmp 	RangeError 					; string > 255 - no trailing NULL.
.99cc					_LenExit:
.99cc	98		tya				tya		 							; return length
.99cd	20 52 9d	jsr $9d52			jsr 	NSMSetByte
.99d0	7a		ply				ply
.99d1	20 27 8e	jsr $8e27			jsr 	CheckRightBracket
.99d4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/minmax.asm

.99d5					Unary_Min:
.99d5	a9 01		lda #$01			lda 	#1
.99d7	80 02		bra $99db			bra 	UnaryMinMaxMain
.99d9					Unary_Max:
.99d9	a9 ff		lda #$ff			lda 	#$FF 						; value from comparator to cause a write
.99db					UnaryMinMaxMain:
.99db	fa		plx				plx 								; get index on number stack
.99dc	48		pha				pha 								; save comparator
.99dd	20 95 9c	jsr $9c95			jsr 	EvaluateValue 				; get the first value.
.99e0					_UMMMLoop:
.99e0	b1 30		lda ($30),y			lda 	(codePtr),y
.99e2	c9 29		cmp #$29			cmp 	#KWD_RPAREN 				; if right bracket then done.
.99e4	f0 22		beq $9a08			beq 	_UMMMDone
.99e6	20 2f 8e	jsr $8e2f			jsr 	CheckComma 					; must be a comma
.99e9	e8		inx				inx
.99ea	20 95 9c	jsr $9c95			jsr 	EvaluateValue
.99ed	ca		dex				dex
.99ee	20 33 9d	jsr $9d33			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] (Compare is destructive)
.99f1	e8		inx				inx
.99f2	20 33 9d	jsr $9d33			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2], original
.99f5	e8		inx				inx
.99f6	20 f7 8e	jsr $8ef7			jsr 	CompareBaseCode 			; part of > = < etc. code, returns 255,0 or 1
.99f9	ca		dex				dex
.99fa	ca		dex				dex
.99fb	85 36		sta $36				sta 	zTemp0 						; save required result
.99fd	68		pla				pla 								; get and save comparator
.99fe	48		pha				pha
.99ff	c5 36		cmp $36				cmp 	zTemp0 						; if the comparator
.9a01	d0 dd		bne $99e0			bne 	_UMMMLoop
.9a03	20 0b 9a	jsr $9a0b			jsr 	ExpCopyAboveDown 			; copy next up slot down
.9a06	80 d8		bra $99e0			bra 	_UMMMLoop
.9a08					_UMMMDone:
.9a08	68		pla				pla 								; throw the comparator
.9a09	c8		iny				iny 								; skip )
.9a0a	60		rts				rts
.9a0b					ExpCopyAboveDown:
.9a0b	b5 51		lda $51,x			lda 	NSStatus+1,x
.9a0d	95 50		sta $50,x			sta 	NSStatus,x
.9a0f	b5 79		lda $79,x			lda 	NSExponent+1,x
.9a11	95 78		sta $78,x			sta 	NSExponent,x
.9a13	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9a15	95 58		sta $58,x			sta 	NSMantissa0,x
.9a17	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9a19	95 60		sta $60,x			sta 	NSMantissa1,x
.9a1b	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.9a1d	95 68		sta $68,x			sta 	NSMantissa2,x
.9a1f	b5 71		lda $71,x			lda 	NSMantissa3+1,x
.9a21	95 70		sta $70,x			sta 	NSMantissa3,x
.9a23	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/not.asm

.9a24					Unary_Not:
.9a24	fa		plx				plx
.9a25	20 bd 9c	jsr $9cbd			jsr 	EvaluateInteger 			; get integer
.9a28	20 27 8e	jsr $8e27			jsr 	CheckRightBracket
.9a2b	20 72 9d	jsr $9d72			jsr 	NSMIsZero 					; zero mantissa ?
.9a2e	f0 04		beq $9a34			beq 	_NotZero
.9a30	20 50 9d	jsr $9d50			jsr 	NSMSetZero
.9a33	60		rts				rts
.9a34					_NotZero:
.9a34	4c ad 8e	jmp $8ead			jmp 	ReturnTrue
.9a37					_UNBad:
.9a37	4c d7 9e	jmp $9ed7			jmp 	ArgumentError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/rnd.asm

.9a3a					Unary_Random:
.9a3a	fa		plx				plx
.9a3b	20 ac 9a	jsr $9aac			jsr 	Random32Bit 				; get a random number
.9a3e	20 95 9a	jsr $9a95			jsr 	URCopyToMantissa  			; put in mantissa
.9a41	b1 30		lda ($30),y			lda 	(codePtr),y
.9a43	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.9a45	f0 08		beq $9a4f			beq 	_URNoModulus
.9a47	e8		inx				inx
.9a48	20 d0 9c	jsr $9cd0			jsr 	Evaluate16BitInteger 		; put modulus value in +1
.9a4b	ca		dex				dex
.9a4c	20 ff 8f	jsr $8fff			jsr 	IntegerModulusNoCheck 		; calculate modulus
.9a4f					_URNoModulus:
.9a4f	74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer positive
.9a51	74 78		stz $78,x			stz 	NSExponent,x
.9a53	20 27 8e	jsr $8e27			jsr 	CheckRightBracket
.9a56	60		rts				rts
.9a57					Unary_Rnd:
.9a57	fa		plx				plx
.9a58	20 9e 9c	jsr $9c9e			jsr 	EvaluateNumber 				; number to use.
.9a5b	20 27 8e	jsr $8e27			jsr 	CheckRightBracket 			; closing bracket
.9a5e	20 72 9d	jsr $9d72			jsr 	NSMIsZero 					; if zero, then don't generate a new number
.9a61	f0 26		beq $9a89			beq 	_URCopySeed
.9a63	b5 50		lda $50,x			lda 	NSStatus,x 					; if -ve, then seed using parameter
.9a65	10 1f		bpl $9a86			bpl 	_URDontSeed
.9a67	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy - value to seed butchering it.
.9a69	49 17		eor #$17			eor 	#$17
.9a6b	8d 08 04	sta $0408			sta 	RandomSeed+0
.9a6e	b5 60		lda $60,x			lda 	NSMantissa1,x
.9a70	49 a5		eor #$a5			eor 	#$A5
.9a72	8d 09 04	sta $0409			sta 	RandomSeed+1
.9a75	b5 68		lda $68,x			lda 	NSMantissa2,x
.9a77	49 c2		eor #$c2			eor 	#$C2
.9a79	8d 0a 04	sta $040a			sta 	RandomSeed+2
.9a7c	b5 70		lda $70,x			lda 	NSMantissa3,x
.9a7e	49 9d		eor #$9d			eor 	#$9D
.9a80	8d 0b 04	sta $040b			sta 	RandomSeed+3
.9a83	20 ac 9a	jsr $9aac			jsr 	Random32Bit
.9a86					_URDontSeed:
.9a86	20 ac 9a	jsr $9aac			jsr 	Random32Bit 				; generate a number.
.9a89					_URCopySeed:
.9a89	20 95 9a	jsr $9a95			jsr 	URCopyToMantissa 			; copy into mantissa
.9a8c	a9 e2		lda #$e2			lda 	#-30 						; force into 0-1 range
.9a8e	95 78		sta $78,x			sta 	NSExponent,x
.9a90	a9 08		lda #$08			lda 	#NSTFloat
.9a92	95 50		sta $50,x			sta 	NSStatus,x 					; positive.
.9a94	60		rts				rts
.9a95					URCopyToMantissa:
.9a95	ad 08 04	lda $0408			lda 	RandomSeed+0
.9a98	95 58		sta $58,x			sta 	NSMantissa0,x
.9a9a	ad 09 04	lda $0409			lda 	RandomSeed+1
.9a9d	95 60		sta $60,x			sta 	NSMantissa1,x
.9a9f	ad 0a 04	lda $040a			lda 	RandomSeed+2
.9aa2	95 68		sta $68,x			sta 	NSMantissa2,x
.9aa4	ad 0b 04	lda $040b			lda 	RandomSeed+3
.9aa7	29 3f		and #$3f			and 	#$3F 						; make legal mantissa
.9aa9	95 70		sta $70,x			sta 	NSMantissa3,x
.9aab	60		rts				rts
.9aac					Random32Bit:
.9aac	5a		phy				phy
.9aad	a0 07		ldy #$07			ldy 	#7 							; do it 7 times
.9aaf	ad 08 04	lda $0408			lda 	RandomSeed+0 				; check the seed isn't zero
.9ab2	d0 03		bne $9ab7			bne 	_Random1
.9ab4	a8		tay				tay 								; if so do it 256 times
.9ab5	a9 aa		lda #$aa			lda		#$AA 						; and use this to seed the seed....
.9ab7					_Random1:
.9ab7	0a		asl a				asl 	a 							; LSFR RNG
.9ab8	2e 09 04	rol $0409			rol 	RandomSeed+1
.9abb	2e 0a 04	rol $040a			rol 	RandomSeed+2
.9abe	2e 0b 04	rol $040b			rol 	RandomSeed+3
.9ac1	90 02		bcc $9ac5			bcc 	_Random2
.9ac3	49 c5		eor #$c5			eor 	#$C5
.9ac5					_Random2:
.9ac5	88		dey				dey
.9ac6	d0 ef		bne $9ab7			bne 	_Random1
.9ac8	8d 08 04	sta $0408			sta 	RandomSeed+0
.9acb	7a		ply				ply
.9acc	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/sgn.asm

.9acd					SgnUnary:
.9acd	fa		plx				plx 								; restore stack pos
.9ace	20 9e 9c	jsr $9c9e			jsr 	EvaluateNumber 				; get a float or int
.9ad1	20 27 8e	jsr $8e27			jsr 	CheckRightBracket
.9ad4	20 72 9d	jsr $9d72			jsr 	NSMIsZero 					; if zero
.9ad7	f0 0e		beq $9ae7			beq 	_SGZero  					; return Int Zero
.9ad9	b5 50		lda $50,x			lda 	NSStatus,x 					; get status w/sign
.9adb	48		pha				pha
.9adc	a9 01		lda #$01			lda 	#1 							; set to 1
.9ade	20 52 9d	jsr $9d52			jsr 	NSMSetByte
.9ae1	68		pla				pla
.9ae2	29 80		and #$80			and		#$80 						; copy the sign byte out
.9ae4	95 50		sta $50,x			sta 	NSStatus,x
.9ae6	60		rts				rts
.9ae7	20 50 9d	jsr $9d50	_SGZero:jsr 	NSMSetZero
.9aea	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/val.asm

.9aeb					ValUnary:
.9aeb	fa		plx				plx 								; restore stack pos
.9aec	20 01 9b	jsr $9b01			jsr 	ValMainCode 				; do the main val() code
.9aef	b0 01		bcs $9af2			bcs 	_VUError 					; couldn't convert
.9af1	60		rts				rts
.9af2					_VUError:
.9af2	4c d2 9e	jmp $9ed2			jmp 	TypeError
.9af5					IsValUnary:
.9af5	fa		plx				plx 								; restore stack pos
.9af6	20 01 9b	jsr $9b01			jsr 	ValMainCode 				; do the main val() code
.9af9	b0 03		bcs $9afe			bcs 	_VUBad
.9afb	4c ad 8e	jmp $8ead			jmp 	ReturnTrue
.9afe					_VUBad:
.9afe	4c b8 8e	jmp $8eb8			jmp 	ReturnFalse
.9b01					ValMainCode:
.9b01	20 a8 9c	jsr $9ca8			jsr 	EvaluateString 				; get a string
.9b04	20 27 8e	jsr $8e27			jsr 	CheckRightBracket 			; check right bracket present
.9b07					ValEvaluateZTemp0:
.9b07	5a		phy				phy
.9b08	b2 36		lda ($36)			lda 	(zTemp0) 					; check not empty string
.9b0a	f0 17		beq $9b23			beq 	_VMCFail2
.9b0c	a0 ff		ldy #$ff			ldy 	#$FF 						; start position
.9b0e	48		pha				pha 								; save first character
.9b0f	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it -
.9b11	d0 01		bne $9b14			bne 	_VMCStart
.9b13	c8		iny				iny 								; skip over -
.9b14					_VMCStart:
.9b14	38		sec				sec 								; initialise first time round.
.9b15					_VMCNext:
.9b15	c8		iny				iny 								; pre-increment
.9b16	b1 36		lda ($36),y			lda 	(zTemp0),y 					; next character
.9b18	f0 0c		beq $9b26			beq 	_VMCSuccess 				; successful.
.9b1a	20 8a 96	jsr $968a			jsr 	EncodeNumber 				; send it to the number-builder
.9b1d	90 03		bcc $9b22			bcc 	_VMCFail 					; if failed, give up.
.9b1f	18		clc				clc 								; next time round, countinue
.9b20	80 f3		bra $9b15			bra 	_VMCNext
.9b22					_VMCFail:
.9b22	68		pla				pla
.9b23					_VMCFail2:
.9b23	7a		ply				ply
.9b24	38		sec				sec
.9b25	60		rts				rts
.9b26					_VMCSuccess:
.9b26	a9 00		lda #$00			lda 	#0 							; construct final
.9b28	20 8a 96	jsr $968a			jsr 	EncodeNumber
.9b2b	68		pla				pla
.9b2c	c9 2d		cmp #$2d			cmp 	#"-"
.9b2e	d0 03		bne $9b33			bne 	_VMCNotNegative
.9b30	20 12 9d	jsr $9d12			jsr		NSMNegate
.9b33					_VMCNotNegative:
.9b33	7a		ply				ply
.9b34	18		clc				clc
.9b35	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/chr.asm

.9b36					ChrUnary:
.9b36	fa		plx				plx 								; restore stack pos
.9b37	20 eb 9c	jsr $9ceb			jsr 	Evaluate8BitInteger			; get value
.9b3a	48		pha				pha
.9b3b	20 27 8e	jsr $8e27			jsr 	CheckRightBracket
.9b3e	a9 01		lda #$01			lda 	#1 							; allocate space for one char
.9b40	20 7c a6	jsr $a67c			jsr 	StringTempAllocate
.9b43	68		pla				pla 								; write number to it
.9b44	20 b5 a6	jsr $a6b5			jsr 	StringTempWrite
.9b47	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/spc.asm

.9b48					SpcUnary:
.9b48	fa		plx				plx 								; restore stack pos
.9b49	20 eb 9c	jsr $9ceb			jsr 	Evaluate8BitInteger			; get value
.9b4c	5a		phy				phy
.9b4d	48		pha				pha 								; save count
.9b4e	20 7c a6	jsr $a67c			jsr 	StringTempAllocate
.9b51	7a		ply				ply 								; to do count in Y
.9b52					_SpcLoop:
.9b52	c0 00		cpy #$00			cpy 	#0
.9b54	f0 08		beq $9b5e			beq 	_SpcExit
.9b56	a9 20		lda #$20			lda 	#32
.9b58	20 b5 a6	jsr $a6b5			jsr 	StringTempWrite
.9b5b	88		dey				dey
.9b5c	80 f4		bra $9b52			bra 	_SPCLoop
.9b5e					_SpcExit:
.9b5e	7a		ply				ply
.9b5f	20 27 8e	jsr $8e27			jsr 	CheckRightBracket
.9b62	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/str.asm

.9b63					Unary_Str:
.9b63	fa		plx				plx
.9b64	20 9e 9c	jsr $9c9e			jsr 	EvaluateNumber  			; get number
.9b67	20 27 8e	jsr $8e27			jsr 	CheckRightBracket 			; closing bracket
.9b6a	a9 05		lda #$05			lda 	#5 							; maximum decimals, from Basic816
.9b6c	20 85 9b	jsr $9b85			jsr 	ConvertNumberToString 		; do the conversion.
.9b6f	a9 21		lda #$21			lda		#33 						; create buffer
.9b71	20 7c a6	jsr $a67c			jsr 	StringTempAllocate 			; allocate memory
.9b74	da		phx				phx
.9b75	a2 00		ldx #$00			ldx 	#0
.9b77					_USCopy:
.9b77	bd 9d 05	lda $059d,x			lda 	DecimalBuffer,x
.9b7a	20 b5 a6	jsr $a6b5			jsr 	StringTempWrite
.9b7d	e8		inx				inx
.9b7e	bd 9d 05	lda $059d,x			lda 	DecimalBuffer,x
.9b81	d0 f4		bne $9b77			bne 	_USCopy
.9b83	fa		plx				plx
.9b84	60		rts				rts
.9b85					ConvertNumberToString:
.9b85	5a		phy				phy 								; save code position
.9b86	8d 14 04	sta $0414			sta 	DecimalPlaces	 			; save number of DPs.
.9b89	9c 15 04	stz $0415			stz 	dbOffset 					; offset into decimal buffer = start.
.9b8c	b5 50		lda $50,x			lda 	NSStatus,x  				; is it -ve.
.9b8e	10 09		bpl $9b99			bpl 	_CNTSNotNegative
.9b90	29 7f		and #$7f			and 	#$7F 						; make +ve
.9b92	95 50		sta $50,x			sta 	NSStatus,x
.9b94	a9 2d		lda #$2d			lda 	#"-"
.9b96	20 fa 9b	jsr $9bfa			jsr 	WriteDecimalBuffer
.9b99					_CNTSNotNegative:
.9b99	b5 78		lda $78,x			lda 	NSExponent,x 				; check if decimal
.9b9b	f0 12		beq $9baf			beq 	_CNTSNotFloat
.9b9d	e8		inx				inx 								; round up
.9b9e	a9 01		lda #$01			lda 	#1
.9ba0	20 52 9d	jsr $9d52			jsr 	NSMSetByte
.9ba3	ca		dex				dex
.9ba4	b5 78		lda $78,x			lda		NSExponent,x
.9ba6	95 79		sta $79,x			sta 	NSExponent+1,x
.9ba8	a9 08		lda #$08			lda 	#NSTFloat
.9baa	95 51		sta $51,x			sta 	NSStatus+1,x
.9bac	20 8f 93	jsr $938f			jsr 	FloatAdd
.9baf					_CNTSNotFloat:
.9baf	20 dc 9b	jsr $9bdc			jsr 	MakePlusTwoString
.9bb2	20 55 94	jsr $9455			jsr 	FloatFractionalPart 		; get the fractional part
.9bb5	20 06 95	jsr $9506			jsr 	NSNormalise					; normalise , exit if zero
.9bb8	f0 20		beq $9bda			beq 	_CNTSExit
.9bba	a9 2e		lda #$2e			lda 	#"."
.9bbc	20 fa 9b	jsr $9bfa			jsr 	WriteDecimalBuffer 			; write decimal place
.9bbf					_CNTSDecimal:
.9bbf	ce 14 04	dec $0414			dec 	DecimalPlaces 				; done all the decimals
.9bc2	30 16		bmi $9bda			bmi 	_CNTSExit
.9bc4	e8		inx				inx 								; x 10.0
.9bc5	a9 0a		lda #$0a			lda 	#10
.9bc7	20 52 9d	jsr $9d52			jsr 	NSMSetByte
.9bca	a9 08		lda #$08			lda 	#NSTFloat
.9bcc	95 50		sta $50,x			sta 	NSStatus,x
.9bce	ca		dex				dex
.9bcf	20 d4 94	jsr $94d4			jsr 	FloatMultiply
.9bd2	20 dc 9b	jsr $9bdc			jsr 	MakePlusTwoString
.9bd5	20 55 94	jsr $9455			jsr 	FloatFractionalPart 		; get the fractional part
.9bd8	80 e5		bra $9bbf			bra 	_CNTSDecimal 				; keep going.
.9bda					_CNTSExit:
.9bda	7a		ply				ply
.9bdb	60		rts				rts
.9bdc					MakePlusTwoString:
.9bdc	da		phx				phx
.9bdd	20 33 9d	jsr $9d33			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.9be0	e8		inx				inx 								; access it
.9be1	e8		inx				inx
.9be2	20 ad 94	jsr $94ad			jsr 	FloatIntegerPart 			; make it an integer
.9be5	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.9be7	20 bf 92	jsr $92bf			jsr 	ConvertInt32
.9bea	a2 00		ldx #$00			ldx	 	#0
.9bec					_MPTSCopy:
.9bec	bd 7b 05	lda $057b,x			lda 	NumberBuffer,x
.9bef	20 fa 9b	jsr $9bfa			jsr 	WriteDecimalBuffer
.9bf2	e8		inx				inx
.9bf3	bd 7b 05	lda $057b,x			lda 	NumberBuffer,x
.9bf6	d0 f4		bne $9bec			bne 	_MPTSCopy
.9bf8	fa		plx				plx
.9bf9	60		rts				rts
.9bfa					WriteDecimalBuffer:
.9bfa	da		phx				phx
.9bfb	ae 15 04	ldx $0415			ldx 	dbOffset
.9bfe	9d 9d 05	sta $059d,x			sta 	DecimalBuffer,x
.9c01	9e 9e 05	stz $059e,x			stz 	DecimalBuffer+1,x
.9c04	ee 15 04	inc $0415			inc 	dbOffset
.9c07	fa		plx				plx
.9c08	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/substring.asm

.9c09					Unary_Left:
.9c09	fa		plx				plx
.9c0a	18		clc				clc 								; only one parameter
.9c0b	20 6e 9c	jsr $9c6e			jsr 	SubstringInitial 			; set up.
.9c0e	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; Param #1 is the length
.9c10	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9c12	74 59		stz $59,x			stz 	NSMantissa0+1,x 			; Start is zero.
.9c14	80 25		bra $9c3b			bra 	SubstringMain
.9c16					Unary_Right:
.9c16	fa		plx				plx
.9c17	18		clc				clc 								; only one parameter
.9c18	20 6e 9c	jsr $9c6e			jsr 	SubstringInitial 			; set up.
.9c1b	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; length => param 2
.9c1d	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9c1f	b5 78		lda $78,x			lda 	NSExponent,x 				; total length
.9c21	f5 59		sbc $59,x			sbc 	NSMantissa0+1,x 			; length - required.
.9c23	b0 02		bcs $9c27			bcs 	_URNotUnderflow
.9c25	a9 00		lda #$00			lda 	#0 							; start from the beginning, as something like right$("AB",3)
.9c27					_URNotUnderFlow:
.9c27	95 59		sta $59,x			sta 	NSMantissa0+1,x 			; this is the start position
.9c29	80 10		bra $9c3b			bra 	SubStringMain
.9c2b					Unary_Mid:
.9c2b	fa		plx				plx
.9c2c	38		sec				sec 								; two parameters
.9c2d	20 6e 9c	jsr $9c6e			jsr 	SubstringInitial 			; set up.
.9c30	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; first parameter is zero ?
.9c32	f0 04		beq $9c38			beq 	_UMError
.9c34	d6 59		dec $59,x			dec 	NSMantissa0+1,x				; reduce initial offset by 1 as MID$(a$,1..) is actually the first character
.9c36	80 03		bra $9c3b			bra 	SubStringMain
.9c38					_UMError:
.9c38	4c d7 9e	jmp $9ed7			jmp 	ArgumentError
.9c3b					SubStringMain:
.9c3b	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; is the initial offset >= the length
.9c3d	d5 78		cmp $78,x			cmp 	NSExponent,x
.9c3f	b0 27		bcs $9c68			bcs 	_SSMNull 					; if so, return an empty string.
.9c41	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; if copy count is zero
.9c43	f0 23		beq $9c68			beq 	_SSMNull 					; return empty string.
.9c45	18		clc				clc 								; add the offset +1 to the address and
.9c46	b5 58		lda $58,x			lda	 	NSMantissa0,x 				; put in zTemp
.9c48	75 59		adc $59,x			adc 	NSMantissa0+1,x
.9c4a	85 36		sta $36				sta 	zTemp0
.9c4c	b5 60		lda $60,x			lda	 	NSMantissa1,x
.9c4e	69 00		adc #$00			adc 	#0
.9c50	85 37		sta $37				sta 	zTemp0+1
.9c52					_SSMNoCarry:
.9c52	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; characters required.
.9c54	20 7c a6	jsr $a67c			jsr 	StringTempAllocate 			; allocate that many characters
.9c57	5a		phy				phy 								; save Y
.9c58	a0 00		ldy #$00			ldy 	#0 							; start copying in.
.9c5a					_SSMCopy:
.9c5a	b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next character
.9c5c	f0 08		beq $9c66			beq 	_SSMEString 				; no more to copy
.9c5e	20 b5 a6	jsr $a6b5			jsr 	StringTempWrite 			; and write it out.
.9c61	c8		iny				iny
.9c62	d6 5a		dec $5a,x			dec 	NSMantissa0+2,x
.9c64	d0 f4		bne $9c5a			bne 	_SSMCopy
.9c66					_SSMEString:
.9c66	7a		ply				ply
.9c67					_SSMExit:
.9c67	60		rts				rts
.9c68					_SSMNull:
.9c68	a9 00		lda #$00			lda 	#0
.9c6a	20 7c a6	jsr $a67c			jsr 	StringTempAllocate
.9c6d	60		rts				rts
.9c6e					SubstringInitial:
.9c6e	da		phx				phx 								; save initial stack position
.9c6f	08		php				php 								; save carry on stack indicating 2 parameters
.9c70	20 a8 9c	jsr $9ca8			jsr 	EvaluateString 				; get a string
.9c73	5a		phy				phy 								; calculate length to exponent.
.9c74	a0 ff		ldy #$ff			ldy 	#$FF
.9c76					_SIFindLength:
.9c76	c8		iny				iny
.9c77	b1 36		lda ($36),y			lda 	(zTemp0),y
.9c79	d0 fb		bne $9c76			bne 	_SIFindLength
.9c7b	98		tya				tya
.9c7c	95 78		sta $78,x			sta 	NSExponent,x
.9c7e	7a		ply				ply
.9c7f	e8		inx				inx
.9c80	20 2f 8e	jsr $8e2f			jsr 	CheckComma 					; comma next
.9c83	20 eb 9c	jsr $9ceb			jsr 	Evaluate8BitInteger 		; get next parameter
.9c86	28		plp				plp 								; is it the last parameter ?
.9c87	90 07		bcc $9c90			bcc 	_SSIExit 					; if so, exit.
.9c89	e8		inx				inx
.9c8a	20 2f 8e	jsr $8e2f			jsr 	CheckComma 					; comma next
.9c8d	20 eb 9c	jsr $9ceb			jsr 	Evaluate8BitInteger 		; get last parameter
.9c90					_SSIExit:
.9c90	fa		plx				plx
.9c91	20 27 8e	jsr $8e27			jsr 	CheckRightBracket 			; check closing bracket
.9c94	60		rts				rts 								; exit

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/exprhelper.asm

.9c95					EvaluateValue:
.9c95	48		pha				pha
.9c96	20 44 93	jsr $9344			jsr		EvaluateExpression 			; expression
.9c99	20 07 96	jsr $9607			jsr 	Dereference					; derefernce it
.9c9c	68		pla				pla
.9c9d	60		rts				rts
.9c9e					EvaluateNumber:
.9c9e	20 95 9c	jsr $9c95			jsr 	EvaluateValue 				; get a value
.9ca1	b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.9ca3	29 10		and #$10			and 	#NSBIsString
.9ca5	d0 13		bne $9cba			bne 	HelperTypeError
.9ca7	60		rts				rts
.9ca8					EvaluateString:
.9ca8	20 95 9c	jsr $9c95			jsr 	EvaluateValue 				; get a value
.9cab	b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.9cad	29 10		and #$10			and 	#NSBIsString
.9caf	f0 09		beq $9cba			beq 	HelperTypeError
.9cb1					CopyAddressToTemp0:
.9cb1	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address -> zTemp0
.9cb3	85 36		sta $36				sta 	zTemp0 						; (so we can do something with it)
.9cb5	b5 60		lda $60,x			lda 	NSMantissa1,x
.9cb7	85 37		sta $37				sta 	zTemp0+1
.9cb9	60		rts				rts
.9cba					HelperTypeError:
.9cba	4c d2 9e	jmp $9ed2			jmp 	TypeError
.9cbd					EvaluateInteger:
.9cbd	20 9e 9c	jsr $9c9e			jsr 	EvaluateNumber
.9cc0	b5 78		lda $78,x			lda 	NSExponent,x 				; check exponent is zero
.9cc2	d0 09		bne $9ccd			bne 	HelperValueError 			; if not, it's a float.
.9cc4	60		rts				rts
.9cc5					EvaluateUnsignedInteger:
.9cc5	20 bd 9c	jsr $9cbd			jsr 	EvaluateInteger 			; check integer is +ve
.9cc8	b5 50		lda $50,x			lda 	NSStatus,x
.9cca	30 01		bmi $9ccd			bmi 	HelperValueError
.9ccc	60		rts				rts
.9ccd					HelperValueError:
.9ccd	4c d7 9e	jmp $9ed7			jmp 	ArgumentError
.9cd0						Evaluate16BitInteger:
.9cd0	20 c5 9c	jsr $9cc5			jsr	 	EvaluateUnsignedInteger		; get integer
.9cd3	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9cd5	15 68		ora $68,x			ora 	NSMantissa2,x
.9cd7	d0 f4		bne $9ccd			bne 	HelperValueError
.9cd9	60		rts				rts
.9cda					Evaluate16BitIntegerSigned:
.9cda	20 bd 9c	jsr $9cbd			jsr	 	EvaluateInteger				; get integer
.9cdd	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9cdf	15 68		ora $68,x			ora 	NSMantissa2,x
.9ce1	d0 ea		bne $9ccd			bne 	HelperValueError
.9ce3	b5 50		lda $50,x			lda 	NSStatus,x 					; signed ?
.9ce5	10 03		bpl $9cea			bpl 	_EISNotSigned
.9ce7	20 19 9d	jsr $9d19			jsr 	NSMNegateMantissa 			; makes it an actual 2's complement value.
.9cea					_EISNotSigned:
.9cea	60		rts				rts
.9ceb					Evaluate8BitInteger:
.9ceb	20 c5 9c	jsr $9cc5			jsr	 	EvaluateUnsignedInteger 	; get an integer
.9cee	d0 dd		bne $9ccd			bne 	HelperValueError
.9cf0	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 1, 2 & 3 must be zero
.9cf2	15 68		ora $68,x			ora 	NSMantissa2,x
.9cf4	15 60		ora $60,x			ora 	NSMantissa1,x
.9cf6	d0 d5		bne $9ccd			bne 	HelperValueError
.9cf8	b5 58		lda $58,x			lda 	NSMantissa0,x
.9cfa	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/mult8x8.asm

.9cfb					Multiply8x8:
.9cfb	4a		lsr a		  		lsr 	a  							; prime the carry bit for the loop
.9cfc	85 36		sta $36			  	sta 	zTemp0
.9cfe	86 37		stx $37				stx 	zTemp0+1
.9d00	a9 00		lda #$00			lda 	#0
.9d02	a2 08		ldx #$08			ldx 	#8
.9d04					_M88Loop:
.9d04	90 03		bcc $9d09			bcc 	_M88NoAdd
.9d06	18		clc				clc
.9d07	65 37		adc $37				adc 	zTemp0+1
.9d09					_M88NoAdd:
.9d09	6a		ror a				ror 	a
.9d0a	66 36		ror $36				ror 	zTemp0  					; pull another bit out for the next iteration
.9d0c	ca		dex				dex         						; inc/dec don't modify carry; only shifts and adds do
.9d0d	d0 f5		bne $9d04			bne 	_M88Loop
.9d0f	85 37		sta $37				sta 	zTemp0+1 					; store high 8 bits.
.9d11	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/utility.asm

.9d12					NSMNegate:
.9d12	b5 50		lda $50,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.9d14	49 80		eor #$80			eor 	#NSBIsNegative  			; toggle the negative flag
.9d16	95 50		sta $50,x			sta 	NSStatus,x
.9d18	60		rts				rts
.9d19					NSMNegateMantissa:
.9d19	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.9d1a	a9 00		lda #$00			lda 	#0
.9d1c	f5 58		sbc $58,x			sbc 	NSMantissa0,x
.9d1e	95 58		sta $58,x			sta 	NSMantissa0,x
.9d20	a9 00		lda #$00			lda 	#0
.9d22	f5 60		sbc $60,x			sbc 	NSMantissa1,x
.9d24	95 60		sta $60,x			sta 	NSMantissa1,x
.9d26	a9 00		lda #$00			lda 	#0
.9d28	f5 68		sbc $68,x			sbc 	NSMantissa2,x
.9d2a	95 68		sta $68,x			sta 	NSMantissa2,x
.9d2c	a9 00		lda #$00			lda 	#0
.9d2e	f5 70		sbc $70,x			sbc 	NSMantissa3,x
.9d30	95 70		sta $70,x			sta 	NSMantissa3,x
.9d32	60		rts				rts
.9d33					NSMShiftUpTwo:
.9d33	b5 58		lda $58,x			lda 	NSMantissa0,x
.9d35	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9d37	b5 60		lda $60,x			lda 	NSMantissa1,x
.9d39	95 62		sta $62,x			sta 	NSMantissa1+2,x
.9d3b	b5 68		lda $68,x			lda 	NSMantissa2,x
.9d3d	95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.9d3f	b5 70		lda $70,x			lda 	NSMantissa3,x
.9d41	95 72		sta $72,x			sta 	NSMantissa3+2,x
.9d43	b5 78		lda $78,x			lda 	NSExponent,x
.9d45	95 7a		sta $7a,x			sta 	NSExponent+2,x
.9d47	b5 50		lda $50,x			lda 	NSStatus,x
.9d49	95 52		sta $52,x			sta 	NSStatus+2,x
.9d4b	60		rts				rts
.9d4c					NSMSetZeroMantissaOnly:
.9d4c	a9 00		lda #$00			lda 	#0
.9d4e	80 06		bra $9d56			bra 	NSMSetMantissa
.9d50					NSMSetZero:
.9d50	a9 00		lda #$00			lda 	#0
.9d52					NSMSetByte:
.9d52	74 78		stz $78,x			stz 	NSExponent,x 				; zero exponent, as integer.
.9d54	74 50		stz $50,x			stz 	NSStatus,x 					; status zero (integer)
.9d56					NSMSetMantissa:
.9d56	95 58		sta $58,x			sta 	NSMantissa0,x 				; mantissa
.9d58	74 60		stz $60,x			stz 	NSMantissa1,x
.9d5a	74 68		stz $68,x			stz 	NSMantissa2,x
.9d5c	74 70		stz $70,x			stz 	NSMantissa3,x
.9d5e	60		rts				rts
.9d5f					NSMShiftLeft:
.9d5f	18		clc				clc
.9d60					NSMRotateLeft:
.9d60	36 58		rol $58,x			rol 	NSMantissa0,x
.9d62	36 60		rol $60,x			rol		NSMantissa1,x
.9d64	36 68		rol $68,x			rol		NSMantissa2,x
.9d66	36 70		rol $70,x			rol		NSMantissa3,x
.9d68	60		rts				rts
.9d69					NSMShiftRight:
.9d69	56 70		lsr $70,x			lsr 	NSMantissa3,x
.9d6b	76 68		ror $68,x			ror		NSMantissa2,x
.9d6d	76 60		ror $60,x			ror		NSMantissa1,x
.9d6f	76 58		ror $58,x			ror		NSMantissa0,x
.9d71	60		rts				rts
.9d72					NSMIsZero:
.9d72	b5 70		lda $70,x			lda 	NSMantissa3,x
.9d74	15 68		ora $68,x			ora		NSMantissa2,x
.9d76	15 60		ora $60,x			ora		NSMantissa1,x
.9d78	15 58		ora $58,x			ora		NSMantissa0,x
.9d7a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.asm

.b910					TickHandler:
.b910	5a		phy				phy 								; need to preserve Y
.b911	20 b6 b8	jsr $b8b6			jsr 	SNDUpdate 					; update sound
.b914	7a		ply				ply
.b915	60		rts				rts
.05af					LastTick:
>05af							.fill 		1

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/asmcore.asm

.9d7b					Assemble_ora:
.9d7b	20 63 80	jsr $8063		jsr	AssembleGroup1
>9d7e	01					.byte $01
.9d7f					Assemble_and:
.9d7f	20 63 80	jsr $8063		jsr	AssembleGroup1
>9d82	21					.byte $21
.9d83					Assemble_eor:
.9d83	20 63 80	jsr $8063		jsr	AssembleGroup1
>9d86	41					.byte $41
.9d87					Assemble_adc:
.9d87	20 63 80	jsr $8063		jsr	AssembleGroup1
>9d8a	61					.byte $61
.9d8b					Assemble_sta:
.9d8b	20 63 80	jsr $8063		jsr	AssembleGroup1
>9d8e	81					.byte $81
.9d8f					Assemble_lda:
.9d8f	20 63 80	jsr $8063		jsr	AssembleGroup1
>9d92	a1					.byte $a1
.9d93					Assemble_cmp:
.9d93	20 63 80	jsr $8063		jsr	AssembleGroup1
>9d96	c1					.byte $c1
.9d97					Assemble_sbc:
.9d97	20 63 80	jsr $8063		jsr	AssembleGroup1
>9d9a	e1					.byte $e1
.9d9b					Assemble_asl:
.9d9b	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9d9e	02					.byte $02
>9d9f	75					.byte $75
.9da0					Assemble_rol:
.9da0	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9da3	22					.byte $22
>9da4	75					.byte $75
.9da5					Assemble_lsr:
.9da5	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9da8	42					.byte $42
>9da9	75					.byte $75
.9daa					Assemble_ror:
.9daa	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9dad	62					.byte $62
>9dae	75					.byte $75
.9daf					Assemble_stx:
.9daf	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9db2	82					.byte $82
>9db3	50					.byte $50
.9db4					Assemble_ldx:
.9db4	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9db7	a2					.byte $a2
>9db8	d0					.byte $d0
.9db9					Assemble_dec:
.9db9	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9dbc	c2					.byte $c2
>9dbd	55					.byte $55
.9dbe					Assemble_inc:
.9dbe	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9dc1	e2					.byte $e2
>9dc2	55					.byte $55
.9dc3					Assemble_stz:
.9dc3	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9dc6	60					.byte $60
>9dc7	44					.byte $44
.9dc8					Assemble_bit:
.9dc8	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9dcb	20					.byte $20
>9dcc	55					.byte $55
.9dcd					Assemble_sty:
.9dcd	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9dd0	80					.byte $80
>9dd1	54					.byte $54
.9dd2					Assemble_ldy:
.9dd2	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9dd5	a0					.byte $a0
>9dd6	d5					.byte $d5
.9dd7					Assemble_cpy:
.9dd7	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9dda	c0					.byte $c0
>9ddb	d4					.byte $d4
.9ddc					Assemble_cpx:
.9ddc	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9ddf	e0					.byte $e0
>9de0	d0					.byte $d0
.9de1					Assemble_tsb:
.9de1	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9de4	00					.byte $00
>9de5	50					.byte $50
.9de6					Assemble_trb:
.9de6	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9de9	10					.byte $10
>9dea	50					.byte $50
.9deb					Assemble_jsr:
.9deb	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9dee	14					.byte $14
>9def	10					.byte $10
.9df0					Assemble_jmp:
.9df0	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9df3	40					.byte $40
>9df4	10					.byte $10
.9df5					Assemble_bpl:
.9df5	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9df8	10					.byte $10
.9df9					Assemble_bmi:
.9df9	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9dfc	30					.byte $30
.9dfd					Assemble_bvc:
.9dfd	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9e00	50					.byte $50
.9e01					Assemble_bvs:
.9e01	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9e04	70					.byte $70
.9e05					Assemble_bcc:
.9e05	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9e08	90					.byte $90
.9e09					Assemble_bcs:
.9e09	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9e0c	b0					.byte $b0
.9e0d					Assemble_bne:
.9e0d	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9e10	d0					.byte $d0
.9e11					Assemble_beq:
.9e11	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9e14	f0					.byte $f0
.9e15					Assemble_bra:
.9e15	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9e18	80					.byte $80
.9e19					Assemble_brk:
.9e19	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e1c	00					.byte $00
.9e1d					Assemble_php:
.9e1d	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e20	08					.byte $08
.9e21					Assemble_clc:
.9e21	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e24	18					.byte $18
.9e25					Assemble_plp:
.9e25	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e28	28					.byte $28
.9e29					Assemble_sec:
.9e29	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e2c	38					.byte $38
.9e2d					Assemble_rti:
.9e2d	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e30	40					.byte $40
.9e31					Assemble_pha:
.9e31	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e34	48					.byte $48
.9e35					Assemble_cli:
.9e35	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e38	58					.byte $58
.9e39					Assemble_phy:
.9e39	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e3c	5a					.byte $5a
.9e3d					Assemble_rts:
.9e3d	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e40	60					.byte $60
.9e41					Assemble_pla:
.9e41	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e44	68					.byte $68
.9e45					Assemble_sei:
.9e45	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e48	78					.byte $78
.9e49					Assemble_ply:
.9e49	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e4c	7a					.byte $7a
.9e4d					Assemble_dey:
.9e4d	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e50	88					.byte $88
.9e51					Assemble_txa:
.9e51	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e54	8a					.byte $8a
.9e55					Assemble_tya:
.9e55	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e58	98					.byte $98
.9e59					Assemble_txs:
.9e59	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e5c	9a					.byte $9a
.9e5d					Assemble_tay:
.9e5d	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e60	a8					.byte $a8
.9e61					Assemble_tax:
.9e61	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e64	aa					.byte $aa
.9e65					Assemble_clv:
.9e65	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e68	b8					.byte $b8
.9e69					Assemble_tsx:
.9e69	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e6c	ba					.byte $ba
.9e6d					Assemble_iny:
.9e6d	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e70	c8					.byte $c8
.9e71					Assemble_dex:
.9e71	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e74	ca					.byte $ca
.9e75					Assemble_cld:
.9e75	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e78	d8					.byte $d8
.9e79					Assemble_phx:
.9e79	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e7c	da					.byte $da
.9e7d					Assemble_stp:
.9e7d	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e80	db					.byte $db
.9e81					Assemble_inx:
.9e81	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e84	e8					.byte $e8
.9e85					Assemble_nop:
.9e85	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e88	ea					.byte $ea
.9e89					Assemble_sed:
.9e89	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e8c	f8					.byte $f8
.9e8d					Assemble_plx:
.9e8d	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e90	fa					.byte $fa

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/constants.asm

.9e91					DecimalScalarTable:
>9e91	66 66 66 66				.dword $66666666 ; 0.1
>9e95	de					.byte $de
>9e96	1f 85 eb 51				.dword $51eb851f ; 0.01
>9e9a	db					.byte $db
>9e9b	4c 37 89 41				.dword $4189374c ; 0.001
>9e9f	d8					.byte $d8
>9ea0	ac 8b db 68				.dword $68db8bac ; 0.0001
>9ea4	d4					.byte $d4
>9ea5	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>9ea9	d1					.byte $d1
>9eaa	83 de 1b 43				.dword $431bde83 ; 1e-06
>9eae	ce					.byte $ce
>9eaf	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>9eb3	ca					.byte $ca
>9eb4	89 3b e6 55				.dword $55e63b89 ; 1e-08
>9eb8	c7					.byte $c7
>9eb9	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>9ebd	c4					.byte $c4
>9ebe	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>9ec2	c0					.byte $c0
>9ec3	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>9ec7	bd					.byte $bd

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.asm

.9ec8					SyntaxError:
.9ec8	a9 02		lda #$02		lda	#2
.9eca	4c 40 8e	jmp $8e40		jmp	ErrorHandler
.9ecd					RangeError:
.9ecd	a9 04		lda #$04		lda	#4
.9ecf	4c 40 8e	jmp $8e40		jmp	ErrorHandler
.9ed2					TypeError:
.9ed2	a9 05		lda #$05		lda	#5
.9ed4	4c 40 8e	jmp $8e40		jmp	ErrorHandler
.9ed7					ArgumentError:
.9ed7	a9 07		lda #$07		lda	#7
.9ed9	4c 40 8e	jmp $8e40		jmp	ErrorHandler
.9edc					NotDoneError:
.9edc	a9 0c		lda #$0c		lda	#12
.9ede	4c 40 8e	jmp $8e40		jmp	ErrorHandler
.9ee1					ErrorText:
>9ee1	42 72 65 61 6b 00			.text	"Break",0
>9ee7	53 79 6e 74 61 78 20 65			.text	"Syntax error",0
>9eef	72 72 6f 72 00
>9ef4	44 69 76 69 73 69 6f 6e			.text	"Division by zero",0
>9efc	20 62 79 20 7a 65 72 6f 00
>9f05	4f 75 74 20 6f 66 20 52			.text	"Out of Range",0
>9f0d	61 6e 67 65 00
>9f12	54 79 70 65 20 6d 69 73			.text	"Type mismatch",0
>9f1a	6d 61 74 63 68 00
>9f20	4f 75 74 20 6f 66 20 6d			.text	"Out of memory",0
>9f28	65 6d 6f 72 79 00
>9f2e	49 6c 6c 65 67 61 6c 20			.text	"Illegal argument",0
>9f36	61 72 67 75 6d 65 6e 74 00
>9f3f	53 74 6f 70 00				.text	"Stop",0
>9f44	53 74 72 69 6e 67 20 74			.text	"String too long",0
>9f4c	6f 6f 20 6c 6f 6e 67 00
>9f54	41 73 73 65 72 74 69 6f			.text	"Assertion failed",0
>9f5c	6e 20 66 61 69 6c 65 64 00
>9f65	4f 75 74 20 6f 66 20 64			.text	"Out of data",0
>9f6d	61 74 61 00
>9f71	55 6e 69 6d 70 6c 65 6d			.text	"Unimplemented",0
>9f79	65 6e 74 65 64 00
>9f7f	4e 6f 20 73 75 63 68 20			.text	"No such line number",0
>9f87	6c 69 6e 65 20 6e 75 6d 62 65 72 00
>9f93	52 65 74 75 72 6e 20 77			.text	"Return without Gosub",0
>9f9b	69 74 68 6f 75 74 20 47 6f 73 75 62 00
>9fa8	55 6e 74 69 6c 20 77 69			.text	"Until without Repeat",0
>9fb0	74 68 6f 75 74 20 52 65 70 65 61 74 00
>9fbd	57 65 6e 64 20 77 69 74			.text	"Wend without While",0
>9fc5	68 6f 75 74 20 57 68 69 6c 65 00
>9fd0	4e 65 78 74 20 77 69 74			.text	"Next without For",0
>9fd8	68 6f 75 74 20 46 6f 72 00
>9fe1	42 41 53 49 43 20 53 74			.text	"BASIC Stack full",0
>9fe9	61 63 6b 20 66 75 6c 6c 00
>9ff2	4f 70 65 6e 20 53 74 72			.text	"Open Structure",0
>9ffa	75 63 74 75 72 65 00
>a001	45 6e 64 50 72 6f 63 20			.text	"EndProc without call",0
>a009	77 69 74 68 6f 75 74 20 63 61 6c 6c 00
>a016	41 72 72 61 79 20 61 6c			.text	"Array already defined",0
>a01e	72 65 61 64 79 20 64 65 66 69 6e 65 64 00
>a02c	41 72 72 61 79 20 73 69			.text	"Array size",0
>a034	7a 65 00
>a037	42 61 64 20 61 72 72 61			.text	"Bad array index",0
>a03f	79 20 69 6e 64 65 78 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/timestamp.asm

>a047	52 65 6c 65 61 73 65 20			.text "Release Alpha 5 (26-Nov-22). "
>a04f	41 6c 70 68 61 20 35 20 28 32 36 2d 4e 6f 76 2d
>a05f	32 32 29 2e 20

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcommand.asm

.a064					RectangleCommand:
.a064	a9 44		lda #$44			lda 	#GCMD_FrameRect				; frame rectangle
.a066	80 02		bra $a06a			bra 	ShapeDrawCmd
.a068					CircleCommand:
.a068	a9 48		lda #$48			lda 	#GCMD_FrameCircle 				; framed circle
.a06a					ShapeDrawCmd:
.a06a	20 f4 a0	jsr $a0f4			jsr 	RunGraphicsCommand
.a06d					ShapeDraw:
.a06d	0d b1 05	ora $05b1			ora 	gxFillSolid  				; adjust AXY for solid fill.
.a070	4c e8 a0	jmp $a0e8			jmp 	ExecuteGraphicCommand	 	; and complete
.a073					SpriteCommand:
.a073	a2 00		ldx #$00			ldx 	#0
.a075	20 eb 9c	jsr $9ceb			jsr 	Evaluate8BitInteger 		; get image number.
.a078	5a		phy				phy
.a079	a9 0e		lda #$0e			lda 	#GCMD_SpriteUse 			; use that image.
.a07b	a6 58		ldx $58				ldx 	NSMantissa0
.a07d	e0 40		cpx #$40			cpx 	#64 						; 0-63 only
.a07f	b0 0d		bcs $a08e			bcs 	_SCRange
.a081	a0 ff		ldy #$ff			ldy 	#255
.a083	20 c4 a9	jsr $a9c4			jsr 	GXGraphicDraw
.a086	a9 52		lda #$52			lda 	#GCMD_SpriteMove
.a088	7a		ply				ply
.a089	20 f4 a0	jsr $a0f4			jsr 	RunGraphicsCommand
.a08c	80 5a		bra $a0e8			bra 	ExecuteGraphicCommand
.a08e					_SCRange:
.a08e	4c cd 9e	jmp $9ecd			jmp 	RangeError
.a091					ImageCommand:
.a091	a2 00		ldx #$00			ldx 	#0
.a093	20 eb 9c	jsr $9ceb			jsr 	Evaluate8BitInteger 		; get image number.
.a096	20 f4 a0	jsr $a0f4			jsr 	RunGraphicsCommand
.a099					ImageRunDraw:
.a099	09 40		ora #$40			ora 	#GCMD_Move					; move cursor
.a09b	20 c4 a9	jsr $a9c4			jsr 	GXGraphicDraw
.a09e	ad b7 05	lda $05b7			lda 	gxDrawScale
.a0a1	0a		asl a				asl 	a
.a0a2	0a		asl a				asl 	a
.a0a3	0a		asl a				asl 	a
.a0a4	a8		tay				tay
.a0a5	a9 0c		lda #$0c			lda 	#GCMD_DrawSprite 			; image drawing
.a0a7	a6 58		ldx $58				ldx 	NSMantissa0
.a0a9	20 c4 a9	jsr $a9c4			jsr 	GXGraphicDraw
.a0ac	60		rts				rts
.a0ad					TextCommand:
.a0ad	a2 00		ldx #$00			ldx 	#0
.a0af	20 a8 9c	jsr $9ca8			jsr 	EvaluateString 				; get text
.a0b2	20 f4 a0	jsr $a0f4			jsr 	RunGraphicsCommand
.a0b5					TextRunDraw:
.a0b5	09 40		ora #$40			ora 	#GCMD_Move 					; move cursor
.a0b7	20 c4 a9	jsr $a9c4			jsr 	GXGraphicDraw
.a0ba	a0 00		ldy #$00			ldy 	#0
.a0bc					_IRDLoop:
.a0bc	a5 60		lda $60				lda 	NSMantissa1 				; access character
.a0be	85 37		sta $37				sta 	zTemp0+1
.a0c0	a5 58		lda $58				lda 	NSMantissa0
.a0c2	85 36		sta $36				sta 	zTemp0
.a0c4	b1 36		lda ($36),y			lda 	(zTemp0),y
.a0c6	f0 13		beq $a0db			beq 	_IRDExit
.a0c8	5a		phy				phy									; save string pos
.a0c9	48		pha				pha 								; save char
.a0ca	ad b7 05	lda $05b7			lda 	gxDrawScale 				; get scale
.a0cd	0a		asl a				asl 	a
.a0ce	0a		asl a				asl 	a
.a0cf	0a		asl a				asl 	a
.a0d0	a8		tay				tay
.a0d1	a9 0a		lda #$0a			lda 	#GCMD_DrawFont 				; char drawing
.a0d3	fa		plx				plx 								; char to draw
.a0d4	20 c4 a9	jsr $a9c4			jsr 	GXGraphicDraw
.a0d7	7a		ply				ply 								; restore string pos
.a0d8	c8		iny				iny
.a0d9	90 e1		bcc $a0bc			bcc 	_IRDLoop 					; go back if no error.
.a0db					_IRDExit:
.a0db	60		rts				rts
.a0dc					PlotCommand:
.a0dc	a9 50		lda #$50			lda 	#GCMD_Plot 					; command ID to use
.a0de	20 f4 a0	jsr $a0f4			jsr 	RunGraphicsCommand
.a0e1	80 05		bra $a0e8			bra 	ExecuteGraphicCommand
.a0e3					LineCommand:
.a0e3	a9 42		lda #$42			lda 	#GCMD_Line 						; command ID to use
.a0e5	20 f4 a0	jsr $a0f4			jsr 	RunGraphicsCommand
.a0e8					ExecuteGraphicCommand:
.a0e8	0d b0 05	ora $05b0			ora 	gxCommandID 				; make a full command
.a0eb	20 c4 a9	jsr $a9c4			jsr 	GXGraphicDraw 				; draw it and exit
.a0ee	b0 01		bcs $a0f1			bcs 	_EGCError
.a0f0	60		rts				rts
.a0f1					_EGCError:
.a0f1	4c c8 9e	jmp $9ec8			jmp 	SyntaxError
.a0f4					RunGraphicsCommand:
.a0f4	8d b0 05	sta $05b0			sta 	gxCommandID					; save TODO graphics command.
.a0f7	68		pla				pla 								; pop handler address
.a0f8	fa		plx				plx
.a0f9	1a		inc a				inc 	a
.a0fa	d0 01		bne $a0fd			bne 	_RGINoCarry
.a0fc	e8		inx				inx
.a0fd					_RGINoCarry:
.a0fd	8d b5 05	sta $05b5			sta 	GXHandler
.a100	8e b6 05	stx $05b6			stx 	GXHandler+1
.a103					_RGICommandLoop:
.a103	b1 30		lda ($30),y			lda 	(codePtr),y
.a105	c8		iny				iny
.a106	c9 ce		cmp #$ce			cmp 	#KWD_TO						; is it TO x,y
.a108	f0 53		beq $a15d			beq 	_RGI_To
.a10a	c9 ba		cmp #$ba			cmp 	#KWD_HERE 					; do it here.
.a10c	f0 55		beq $a163			beq 	_RGI_Here
.a10e	c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL or : , exit
.a110	f0 3d		beq $a14f			beq 	_RGI_Exit
.a112	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.a114	f0 39		beq $a14f			beq 	_RGI_Exit
.a116	c9 c2		cmp #$c2			cmp 	#KWD_OUTLINE 				; solid or outline
.a118	f0 3e		beq $a158			beq 	_RGI_Frame
.a11a	c9 ca		cmp #$ca			cmp 	#KWD_SOLID
.a11c	f0 33		beq $a151			beq 	_RGI_Solid
.a11e	c9 ab		cmp #$ab			cmp 	#KWD_BY 					; by offset
.a120	f0 4b		beq $a16d			beq 	_RGI_By
.a122	c9 b6		cmp #$b6			cmp 	#KWD_FROM 					; from
.a124	f0 17		beq $a13d			beq 	_RGI_Move2
.a126	c9 b3		cmp #$b3			cmp 	#KWD_DIM 					; dim (set scale)
.a128	f0 62		beq $a18c			beq 	_RGI_Dim
.a12a	c9 b1		cmp #$b1			cmp 	#KWD_COLOUR 				; colour or Color
.a12c	f0 74		beq $a1a2			beq 	_RGI_Colour
.a12e	c9 b0		cmp #$b0			cmp 	#KWD_COLOR
.a130	f0 70		beq $a1a2			beq 	_RGI_Colour
.a132	ae b0 05	ldx $05b0			ldx 	gxCommandID
.a135	e0 52		cpx #$52			cpx 	#GCMD_SpriteMove 			; if not sprite
.a137	d0 03		bne $a13c			bne 	_RGI_Move 					; move
.a139	4c ca a1	jmp $a1ca			jmp		_RGI_SpriteInstructions
.a13c					_RGI_Move:
.a13c	88		dey				dey 								; unpick get.
.a13d					_RGI_Move2:
.a13d	20 f0 a1	jsr $a1f0			jsr 	GCGetCoordinatePair 		; move to here
.a140	20 17 a2	jsr $a217			jsr 	GCCopyPairToStore 			; save
.a143	5a		phy				phy
.a144	20 0d a2	jsr $a20d			jsr 	GCLoadAXY 					; load in
.a147	09 40		ora #$40			ora 	#GCMD_Move 					; move there
.a149	20 c4 a9	jsr $a9c4			jsr 	GXGraphicDraw
.a14c	7a		ply				ply
.a14d	80 b4		bra $a103			bra 	_RGICommandLoop 			; and go round
.a14f					_RGI_Exit:
.a14f	88		dey				dey 								; unpick : / EOL
.a150	60		rts				rts
.a151					_RGI_Solid:
.a151	a9 02		lda #$02			lda 	#2
.a153	8d b1 05	sta $05b1			sta 	gxFillSolid
.a156	80 ab		bra $a103			bra 	_RGICommandLoop
.a158					_RGI_Frame:
.a158	9c b1 05	stz $05b1			stz 	gxFillSolid
.a15b	80 a6		bra $a103			bra 	_RGICommandLoop
.a15d					_RGI_To:
.a15d	20 f0 a1	jsr $a1f0			jsr 	GCGetCoordinatePair 		; get coordinate pair into slot #1,#2
.a160	20 17 a2	jsr $a217			jsr 	GCCopyPairToStore
.a163					_RGI_Here:
.a163	5a		phy				phy
.a164	20 0d a2	jsr $a20d			jsr 	GCLoadAXY 					; load it into AXY
.a167	20 c7 a1	jsr $a1c7			jsr 	_RGICallHandler 			; go do whatever it is.
.a16a	7a		ply				ply
.a16b	80 96		bra $a103			bra 	_RGICommandLoop 			; and go round
.a16d					_RGI_By:
.a16d	20 fd a1	jsr $a1fd			jsr 	GCSignedCoordinatePair 		; get coordinate pair into slot #1,#2
.a170	18		clc				clc
.a171	a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.a173	6d b2 05	adc $05b2			adc 	gxxPos
.a176	8d b2 05	sta $05b2			sta 	gxXPos
.a179	a5 61		lda $61				lda 	NSMantissa1+1
.a17b	6d b3 05	adc $05b3			adc 	gxxPos+1
.a17e	8d b3 05	sta $05b3			sta 	gxXPos+1
.a181	a5 5a		lda $5a				lda 	NSMantissa0+2
.a183	18		clc				clc
.a184	6d b4 05	adc $05b4			adc 	gxYPos
.a187	8d b4 05	sta $05b4			sta 	gxYPos
.a18a	80 d7		bra $a163			bra 	_RGI_Here
.a18c					_RGI_Dim:
.a18c	a2 01		ldx #$01			ldx	 	#1
.a18e	20 eb 9c	jsr $9ceb			jsr 	Evaluate8BitInteger
.a191	a5 59		lda $59				lda 	NSMantissa0+1
.a193	c9 00		cmp #$00			cmp 	#0
.a195	f0 2d		beq $a1c4			beq 	_RGIRange
.a197	c9 09		cmp #$09			cmp 	#8+1
.a199	b0 29		bcs $a1c4			bcs		_RGIRange
.a19b	3a		dec a				dec 	a
.a19c	8d b7 05	sta $05b7			sta 	gxDrawScale
.a19f	4c 03 a1	jmp $a103			jmp 	_RGICommandLoop
.a1a2					_RGI_Colour:
.a1a2	a2 01		ldx #$01			ldx 	#1 							; colour
.a1a4	20 eb 9c	jsr $9ceb			jsr 	Evaluate8BitInteger
.a1a7	a2 02		ldx #$02			ldx 	#2 							; default zero for 2nd parameter
.a1a9	20 50 9d	jsr $9d50			jsr 	NSMSetZero
.a1ac	b1 30		lda ($30),y			lda 	(codePtr),y
.a1ae	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; check , => mode.
.a1b0	d0 04		bne $a1b6			bne 	_RGICDefaultMode
.a1b2	c8		iny				iny
.a1b3	20 eb 9c	jsr $9ceb			jsr 	Evaluate8BitInteger
.a1b6					_RGICDefaultMode:
.a1b6	5a		phy				phy
.a1b7	a9 08		lda #$08			lda 	#GCMD_Colour 				; set colour.
.a1b9	a6 59		ldx $59				ldx 	NSMantissa0+1
.a1bb	a4 5a		ldy $5a				ldy 	NSMantissa0+2
.a1bd	20 c4 a9	jsr $a9c4			jsr 	GXGraphicDraw
.a1c0	7a		ply				ply
.a1c1	4c 03 a1	jmp $a103			jmp 	_RGICommandLoop 			; and go round
.a1c4					_RGIRange:
.a1c4	4c cd 9e	jmp $9ecd			jmp 	RangeError
.a1c7					_RGICallHandler:
.a1c7	6c b5 05	jmp ($05b5)			jmp 	(GXHandler)
.a1ca					_RGI_SpriteInstructions:
.a1ca	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a1cc	f0 07		beq $a1d5			beq 	_RGISpriteOff
.a1ce	c9 bb		cmp #$bb			cmp 	#KWD_IMAGE
.a1d0	f0 13		beq $a1e5			beq 	_RGISetImage
.a1d2	4c 3c a1	jmp $a13c			jmp 	_RGI_Move
.a1d5					_RGISpriteOff:
.a1d5	5a		phy				phy
.a1d6	a0 01		ldy #$01			ldy 	#1
.a1d8	a2 00		ldx #$00			ldx 	#0
.a1da					_RGIDoCommandLoop:
.a1da	a9 10		lda #$10			lda 	#GCMD_SpriteImage
.a1dc	20 c4 a9	jsr $a9c4			jsr 	GXGraphicDraw
.a1df	7a		ply				ply
.a1e0	b0 e2		bcs $a1c4			bcs 	_RGIRange
.a1e2	4c 03 a1	jmp $a103			jmp 	_RGICommandLoop
.a1e5					_RGISetImage:
.a1e5	a2 01		ldx #$01			ldx 	#1
.a1e7	20 eb 9c	jsr $9ceb			jsr 	Evaluate8BitInteger
.a1ea	5a		phy				phy
.a1eb	aa		tax				tax
.a1ec	a0 00		ldy #$00			ldy 	#0
.a1ee	80 ea		bra $a1da			bra 	_RGIDoCommandLoop
.a1f0					GCGetCoordinatePair:
.a1f0	a2 01		ldx #$01			ldx 	#1
.a1f2	20 d0 9c	jsr $9cd0			jsr 	Evaluate16BitInteger
.a1f5	20 2f 8e	jsr $8e2f			jsr 	CheckComma
.a1f8	e8		inx				inx
.a1f9	20 d0 9c	jsr $9cd0			jsr 	Evaluate16BitInteger
.a1fc	60		rts				rts
.a1fd					GCSignedCoordinatePair:
.a1fd	a2 01		ldx #$01			ldx 	#1
.a1ff	20 da 9c	jsr $9cda			jsr 	Evaluate16BitIntegerSigned
.a202	20 2f 8e	jsr $8e2f			jsr 	CheckComma
.a205	e8		inx				inx
.a206	20 da 9c	jsr $9cda			jsr 	Evaluate16BitIntegerSigned
.a209	60		rts				rts
.a20a					_GCCPRange:
.a20a	4c cd 9e	jmp $9ecd			jmp 	RangeError
.a20d					GCLoadAXY:
.a20d	ad b3 05	lda $05b3			lda 	gxXPos+1
.a210	ae b2 05	ldx $05b2			ldx 	gxXPos
.a213	ac b4 05	ldy $05b4			ldy 	gxYPos
.a216	60		rts				rts
.a217					GCCopyPairToStore:
.a217	a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.a219	8d b2 05	sta $05b2			sta 	gxXPos
.a21c	a5 61		lda $61				lda 	NSMantissa1+1
.a21e	8d b3 05	sta $05b3			sta 	gxXPos+1
.a221	a5 5a		lda $5a				lda 	NSMantissa0+2
.a223	8d b4 05	sta $05b4			sta 	gxYPos
.a226	60		rts				rts
.05b0					gxCommandID:
>05b0							.fill 	1
.05b1					gxFillSolid:
>05b1							.fill 	1
.05b2					gxXPos:
>05b2							.fill 	2
.05b4					gxYPos:
>05b4							.fill 	1
.05b5					gxHandler:
>05b5							.fill 	2
.05b7					gxDrawScale:
>05b7							.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcontrol.asm

.a227					BitmapCtrl:
.a227	b1 30		lda ($30),y			lda 	(codePtr),y
.a229	c8		iny				iny
.a22a	a2 01		ldx #$01			ldx 	#1
.a22c	c9 c1		cmp #$c1			cmp 	#KWD_ON
.a22e	f0 11		beq $a241			beq 	BitmapSwitch
.a230	ca		dex				dex
.a231	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a233	f0 0c		beq $a241			beq 	BitmapSwitch
.a235	20 eb 9c	jsr $9ceb			jsr 	Evaluate8BitInteger 		; get the colour
.a238	5a		phy				phy
.a239	aa		tax				tax
.a23a	a9 06		lda #$06			lda 	#GCMD_Clear					; clear to that colour
.a23c	20 c4 a9	jsr $a9c4			jsr 	GXGraphicDraw
.a23f	7a		ply				ply
.a240	60		rts				rts
.a241					BitmapSwitch:
.a241	5a		phy				phy
.a242	a0 00		ldy #$00			ldy 	#0 							; gfx 1,on/off,0
.a244	a9 02		lda #$02			lda 	#GCMD_BitmapCtl
.a246	20 c4 a9	jsr $a9c4			jsr 	GXGraphicDraw
.a249	a9 08		lda #$08			lda 	#GCMD_Colour				; set colour to $FF
.a24b	a0 00		ldy #$00			ldy 	#0
.a24d	a2 ff		ldx #$ff			ldx 	#$FF
.a24f	20 c4 a9	jsr $a9c4			jsr 	GXGraphicDraw
.a252	9c b1 05	stz $05b1			stz 	gxFillSolid
.a255	9c b2 05	stz $05b2			stz 	gxXPos
.a258	9c b3 05	stz $05b3			stz 	gxXPos+1
.a25b	9c b4 05	stz $05b4			stz 	gxYPos
.a25e	9c b7 05	stz $05b7			stz 	gxDrawScale
.a261	a9 40		lda #$40			lda 	#GCMD_Move 						; home cursor
.a263	a2 00		ldx #$00			ldx 	#0
.a265	a0 00		ldy #$00			ldy 	#0
.a267	20 c4 a9	jsr $a9c4			jsr 	GXGraphicDraw
.a26a	7a		ply				ply
.a26b	60		rts				rts
.a26c					SpritesCtrl:
.a26c	b1 30		lda ($30),y			lda 	(codePtr),y
.a26e	c8		iny				iny
.a26f	a2 01		ldx #$01			ldx 	#1
.a271	c9 c1		cmp #$c1			cmp 	#KWD_ON
.a273	f0 08		beq $a27d			beq 	SpriteSwitch
.a275	ca		dex				dex
.a276	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a278	f0 03		beq $a27d			beq 	SpriteSwitch
.a27a	4c c8 9e	jmp $9ec8			jmp 	SyntaxError
.a27d					SpriteSwitch:
.a27d	5a		phy				phy
.a27e	a0 00		ldy #$00			ldy 	#0 							; gfx 2,on/off,0
.a280	a9 04		lda #$04			lda 	#GCMD_SpriteCtl
.a282	20 c4 a9	jsr $a9c4			jsr 	GXGraphicDraw
.a285	7a		ply				ply
.a286	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gfx.asm

.a287					GfxCommand:
.a287	a2 00		ldx #$00			ldx 	#0
.a289	20 eb 9c	jsr $9ceb			jsr 	Evaluate8BitInteger 		; command
.a28c	20 2f 8e	jsr $8e2f			jsr 	CheckComma
.a28f	e8		inx				inx
.a290	20 d0 9c	jsr $9cd0			jsr 	Evaluate16BitInteger 		; X
.a293	20 2f 8e	jsr $8e2f			jsr 	CheckComma
.a296	e8		inx				inx
.a297	20 eb 9c	jsr $9ceb			jsr 	Evaluate8BitInteger 		; Y
.a29a	a5 61		lda $61				lda 	NSMantissa1+1  				; shift bit 0 of X into CS, should now be zero
.a29c	4a		lsr a				lsr 	a
.a29d	d0 12		bne $a2b1			bne 	_GfxError
.a29f	26 58		rol $58				rol 	NSMantissa0 				; rotate into command
.a2a1	b0 0e		bcs $a2b1			bcs 	_GfxError 					; bit 7 should have been zero
.a2a3	5a		phy				phy 								; save pos
.a2a4	a5 58		lda $58				lda 	NSMantissa0 				; do the command
.a2a6	a6 59		ldx $59				ldx 	NSMantissa0+1
.a2a8	a4 5a		ldy $5a				ldy 	NSMantissa0+2
.a2aa	20 c4 a9	jsr $a9c4			jsr 	GXGraphicDraw
.a2ad	b0 02		bcs $a2b1			bcs 	_GfxError
.a2af	7a		ply				ply 								; restore pos and exit.
.a2b0	60		rts				rts
.a2b1					_GfxError:
.a2b1	4c cd 9e	jmp $9ecd			jmp 	RangeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/hit.asm

.a2b4					UnaryHit:
.a2b4	fa		plx				plx
.a2b5	a9 36		lda #$36			lda 	#zTemp0
.a2b7	20 eb 9c	jsr $9ceb			jsr 	Evaluate8BitInteger 		; get sprite number 0
.a2ba	20 2f 8e	jsr $8e2f			jsr 	CheckComma
.a2bd	e8		inx				inx
.a2be	20 eb 9c	jsr $9ceb			jsr 	Evaluate8BitInteger 		; get sprite number 1
.a2c1	20 27 8e	jsr $8e27			jsr		CheckRightBracket
.a2c4	ca		dex				dex 								; fix back up again.
.a2c5	da		phx				phx 								; save X/Y
.a2c6	5a		phy				phy
.a2c7	b4 59		ldy $59,x			ldy 	NSMantissa0+1,x 			; get the sprite numbers into X/Y
.a2c9	b5 58		lda $58,x			lda 	NSMantissa0,x
.a2cb	aa		tax				tax
.a2cc	a9 12		lda #$12			lda 	#GCMD_SpriteCollide 		; command check collision.
.a2ce	20 c4 a9	jsr $a9c4			jsr 	GXGraphicDraw 				; calculate result
.a2d1	1a		inc a				inc 	a 							; so 255 (fail) -> 0, otherwise 1,2,3,4 pixels etc.
.a2d2	7a		ply				ply 								; restore XY
.a2d3	fa		plx				plx
.a2d4	20 52 9d	jsr $9d52			jsr 	NSMSetByte 					; return the hit result
.a2d7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/palette.asm

.a2d8					PaletteCommand:
.a2d8	a2 00		ldx #$00			ldx 	#0
.a2da	20 eb 9c	jsr $9ceb			jsr 	Evaluate8BitInteger 		; colour
.a2dd	20 2f 8e	jsr $8e2f			jsr 	CheckComma
.a2e0	e8		inx				inx
.a2e1	20 d0 9c	jsr $9cd0			jsr 	Evaluate16BitInteger 		; r
.a2e4	20 2f 8e	jsr $8e2f			jsr 	CheckComma
.a2e7	e8		inx				inx
.a2e8	20 eb 9c	jsr $9ceb			jsr 	Evaluate8BitInteger 		; g
.a2eb	20 2f 8e	jsr $8e2f			jsr 	CheckComma
.a2ee	e8		inx				inx
.a2ef	20 eb 9c	jsr $9ceb			jsr 	Evaluate8BitInteger 		; b
.a2f2	a5 58		lda $58				lda 	NSMantissa0 				; get colour #
.a2f4	85 36		sta $36				sta 	zTemp0
.a2f6	a9 34		lda #$34			lda 	#$D0 >> 2 					; MSB = D0/4
.a2f8	85 37		sta $37				sta 	zTemp0+1
.a2fa	06 36		asl $36				asl 	zTemp0 						; zTemp = $D000+Colour x 4
.a2fc	26 37		rol $37				rol	 	zTemp0+1
.a2fe	06 36		asl $36				asl 	zTemp0
.a300	26 37		rol $37				rol	 	zTemp0+1
.a302	a9 01		lda #$01			lda 	#1 							; I/O Page 2
.a304	85 01		sta $01				sta 	1
.a306	5a		phy				phy
.a307	a5 5b		lda $5b				lda 	NSMantissa0+3 				; fix to r,g,b
.a309	92 36		sta ($36)			sta 	(zTemp0)
.a30b	a0 01		ldy #$01			ldy 	#1
.a30d	a5 5a		lda $5a				lda 	NSMantissa0+2
.a30f	91 36		sta ($36),y			sta 	(zTemp0),y
.a311	a5 59		lda $59				lda 	NSMantissa0+1
.a313	c8		iny				iny
.a314	91 36		sta ($36),y			sta 	(zTemp0),y
.a316	7a		ply				ply
.a317	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/event.asm

.a318					UnaryEvent:
.a318	fa		plx				plx
.a319	20 c6 a3	jsr $a3c6			jsr 	TimerToStackX 				; timer in +0
.a31c	e8		inx				inx  								; put reference into +1
.a31d	20 8e 97	jsr $978e			jsr 	EvaluateTerm
.a320	b5 50		lda $50,x			lda 	NSStatus,x 					; check if is integer reference
.a322	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.a324	d0 4c		bne $a372			bne 	_UEType
.a326	e8		inx				inx 								; put the step in +2
.a327	20 2f 8e	jsr $8e2f			jsr 	CheckComma
.a32a	20 d0 9c	jsr $9cd0			jsr 	Evaluate16BitInteger
.a32d	20 27 8e	jsr $8e27			jsr 	CheckRightBracket
.a330	ca		dex				dex
.a331	ca		dex				dex
.a332	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy reference to zTemp0
.a334	85 36		sta $36				sta 	zTemp0
.a336	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.a338	85 37		sta $37				sta 	zTemp0+1
.a33a	5a		phy				phy
.a33b	a0 03		ldy #$03			ldy 	#3 							; check bit 7 of last bit, the packed sign bit
.a33d	b1 36		lda ($36),y			lda 	(zTemp0),y
.a33f	30 2d		bmi $a36e			bmi 	_UEFalse 					; exit if signed.
.a341	a0 00		ldy #$00			ldy 	#0 							; has it timed out (24 bit)
.a343	b5 58		lda $58,x			lda 	NSMantissa0,x
.a345	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.a347	c8		iny				iny
.a348	b5 60		lda $60,x			lda 	NSMantissa1,x
.a34a	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a34c	c8		iny				iny
.a34d	b5 68		lda $68,x			lda 	NSMantissa2,x
.a34f	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a351	90 1b		bcc $a36e			bcc 	_UEFalse 					; no, return FALSE.
.a353	18		clc				clc
.a354	a0 00		ldy #$00			ldy 	#0 							; work out new value as timer() + step
.a356	b5 58		lda $58,x			lda 	NSMantissa0,x
.a358	75 5a		adc $5a,x			adc 	NSMantissa0+2,x
.a35a	91 36		sta ($36),y			sta 	(zTemp0),y
.a35c	c8		iny				iny
.a35d	b5 60		lda $60,x			lda 	NSMantissa1,x
.a35f	75 62		adc $62,x			adc 	NSMantissa1+2,x
.a361	91 36		sta ($36),y			sta 	(zTemp0),y
.a363	c8		iny				iny
.a364	b5 68		lda $68,x			lda 	NSMantissa2,x
.a366	75 6a		adc $6a,x			adc 	NSMantissa2+2,x
.a368	91 36		sta ($36),y			sta 	(zTemp0),y
.a36a	7a		ply				ply
.a36b	4c ad 8e	jmp $8ead			jmp 	ReturnTrue
.a36e					_UEFalse:
.a36e	7a		ply				ply 								; restore Y
.a36f	4c b8 8e	jmp $8eb8			jmp 	ReturnFalse 				; and return False
.a372					_UEType:
.a372	4c d2 9e	jmp $9ed2			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/joy.asm

.a375					UnaryJoyX:
.a375	18		clc				clc
.a376	80 01		bra $a379			bra 	JoyMain
.a378					UnaryJoyY:
.a378	38		sec				sec
.a379					JoyMain:
.a379	fa		plx				plx 								; get pos
.a37a	08		php				php 								; save carry (set for Y)
.a37b	20 eb 9c	jsr $9ceb			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a37e	20 27 8e	jsr $8e27			jsr 	CheckRightBracket
.a381	20 7d a9	jsr $a97d			jsr 	EXTReadController 			; read the controller.
.a384	28		plp				plp
.a385	90 02		bcc $a389			bcc 	_JMNoShift 					; if Y then shift bits 3,2 -> 1,0
.a387	4a		lsr a				lsr 	a
.a388	4a		lsr a				lsr 	a
.a389					_JMNoShift:
.a389	4a		lsr a				lsr 	a 							; if bit 0 set then right/down e.g. +1
.a38a	b0 0a		bcs $a396			bcs 	_JMIsRight
.a38c	4a		lsr a				lsr 	a 							; if bit 1 set then left/up e.g. -1
.a38d	b0 04		bcs $a393			bcs 	_JMIsLeft
.a38f	20 50 9d	jsr $9d50			jsr 	NSMSetZero 					; zero result
.a392	60		rts				rts
.a393					_JMIsLeft:
.a393	4c ad 8e	jmp $8ead			jmp 	ReturnTrue
.a396					_JMIsRight:
.a396	a9 01		lda #$01			lda 	#1
.a398	20 52 9d	jsr $9d52			jsr 	NSMSetByte
.a39b	60		rts				rts
.a39c					UnaryJoyB:
.a39c	fa		plx				plx 								; get pos
.a39d	20 eb 9c	jsr $9ceb			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a3a0	20 27 8e	jsr $8e27			jsr 	CheckRightBracket
.a3a3	20 7d a9	jsr $a97d			jsr 	EXTReadController 			; read the controller.
.a3a6	4a		lsr a				lsr 	a
.a3a7	4a		lsr a				lsr 	a
.a3a8	4a		lsr a				lsr 	a
.a3a9	4a		lsr a				lsr 	a
.a3aa	29 01		and #$01			and 	#1
.a3ac	20 52 9d	jsr $9d52			jsr 	NSMSetByte
.a3af	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/load.asm

.a3b0					LoadCommand:
.a3b0	20 2e 89	jsr $892e			jsr 	NewProgram
.a3b3	20 d2 82	jsr $82d2			jsr 	BackLoadProgram
.a3b6	4c 6a 83	jmp $836a			jmp 	WarmStart
.a3b9					GoCommand:
.a3b9	20 2e 89	jsr $892e			jsr 	NewProgram
.a3bc	20 d2 82	jsr $82d2			jsr 	BackLoadProgram
.a3bf	4c 6a 8a	jmp $8a6a			jmp 	CommandRun

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/timer.asm

.a3c2					UnaryTimer:
.a3c2	fa		plx				plx
.a3c3	20 27 8e	jsr $8e27			jsr 	CheckRightBracket
.a3c6					TimerToStackX:
.a3c6	20 50 9d	jsr $9d50			jsr 	NSMSetZero 					; zero result
.a3c9	64 01		stz $01				stz 	1 							; access I/O
.a3cb	ad 59 d6	lda $d659			lda 	$D659 						; copy timer in
.a3ce	95 58		sta $58,x			sta 	NSMantissa0,x
.a3d0	ad 5a d6	lda $d65a			lda 	$D65A
.a3d3	95 60		sta $60,x			sta 	NSMantissa1,x
.a3d5	ad 5b d6	lda $d65b			lda 	$D65B
.a3d8	95 68		sta $68,x			sta 	NSMantissa2,x
.a3da	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/delete.asm

.a3db					MemoryDeleteLine:
.a3db	20 fa a3	jsr $a3fa			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a3de	b2 30		lda ($30)			lda 	(codePtr) 					; size to delete => y
.a3e0	a8		tay				tay
.a3e1					_MDDLLoop:
.a3e1	b1 30		lda ($30),y			lda 	(codePtr),y 				; copy down
.a3e3	92 30		sta ($30)			sta 	(codePtr)
.a3e5	a5 30		lda $30				lda 	codePtr 					; check done the lot.
.a3e7	c5 3a		cmp $3a				cmp 	zTemp2
.a3e9	d0 07		bne $a3f2			bne 	_MDLDLNext
.a3eb	a5 31		lda $31				lda 	codePtr+1
.a3ed	c5 3b		cmp $3b				cmp 	zTemp2+1
.a3ef	d0 01		bne $a3f2			bne 	_MDLDLNext
.a3f1					_MDDLExit:
.a3f1	60		rts				rts
.a3f2					_MDLDLNext:
.a3f2	e6 30		inc $30				inc 	codePtr						; next byte
.a3f4	d0 eb		bne $a3e1			bne 	_MDDLLoop
.a3f6	e6 31		inc $31				inc 	codePtr+1
.a3f8	80 e7		bra $a3e1			bra 	_MDDLLoop
.a3fa					IMemoryFindEnd:
.a3fa	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a3fc	85 3a		sta $3a				sta 	0+zTemp2
.a3fe	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a400	85 3b		sta $3b				sta 	1+zTemp2
.a402					_MDLFELoop:
.a402	b2 3a		lda ($3a)			lda 	(zTemp2)
.a404	f0 0b		beq $a411			beq 	_MDLFEExit
.a406	18		clc				clc
.a407	65 3a		adc $3a				adc 	zTemp2
.a409	85 3a		sta $3a				sta 	zTemp2
.a40b	90 f5		bcc $a402			bcc 	_MDLFELoop
.a40d	e6 3b		inc $3b				inc 	zTemp2+1
.a40f	80 f1		bra $a402			bra 	_MDLFELoop
.a411					_MDLFEExit:
.a411	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/insert.asm

.a412					MemoryInsertLine:
.a412	08		php				php
.a413	20 fa a3	jsr $a3fa			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a416	a5 3b		lda $3b				lda 	zTemp2+1 					; space ?
.a418	1a		inc a				inc 	a
.a419	c9 7f		cmp #$7f			cmp 	#(BasicEnd >> 8)-1
.a41b	b0 36		bcs $a453			bcs 	_MDLIError
.a41d	28		plp				plp
.a41e	90 08		bcc $a428			bcc 	_MDLIFound
.a420	a5 3a		lda $3a				lda 	zTemp2 						; if CS on entry append.
.a422	85 30		sta $30				sta 	codePtr
.a424	a5 3b		lda $3b				lda 	zTemp2+1
.a426	85 31		sta $31				sta 	codePtr+1
.a428					_MDLIFound:
.a428	ad 2a 04	lda $042a			lda 	tokenOffset 				; insert gap in Y, the offset, e.g. length of the new line
.a42b	a8		tay				tay
.a42c					_MDLIInsert:
.a42c	b2 3a		lda ($3a)			lda 	(zTemp2) 					; shift one byte up , at least one covers end case.
.a42e	91 3a		sta ($3a),y			sta 	(zTemp2),y 					; work from top down.
.a430	a5 30		lda $30				lda 	codePtr 					; done insert point ?
.a432	c5 3a		cmp $3a				cmp 	zTemp2
.a434	d0 06		bne $a43c			bne 	_MDLINext
.a436	a5 31		lda $31				lda 	codePtr+1
.a438	c5 3b		cmp $3b				cmp 	zTemp2+1
.a43a	f0 0a		beq $a446			beq 	_MDLIHaveSpace
.a43c					_MDLINext:
.a43c	a5 3a		lda $3a				lda 	zTemp2 						; if no, keep zTemp2 going backwards
.a43e	d0 02		bne $a442			bne 	_MDLINoBorrow
.a440	c6 3b		dec $3b				dec 	zTemp2+1
.a442					_MDLINoBorrow:
.a442	c6 3a		dec $3a				dec 	zTemp2
.a444	80 e6		bra $a42c			bra 	_MDLIInsert
.a446					_MDLIHaveSpace:
.a446	ac 2a 04	ldy $042a			ldy 	tokenOffset 				; bytes to copy
.a449	88		dey				dey 								; from offset-1 to 0
.a44a					_MDLICopy:
.a44a	b9 2a 04	lda $042a,y			lda 	tokenOffset,y
.a44d	91 30		sta ($30),y			sta 	(codePtr),y
.a44f	88		dey				dey
.a450	10 f8		bpl $a44a			bpl 	_MDLICopy
.a452	60		rts				rts
.a453					_MDLIError:
.a453	a9 06		lda #$06		lda	#6
.a455	4c 40 8e	jmp $8e40		jmp	ErrorHandler
.a458					MDLAppendLine:
.a458	86 37		stx $37				stx 	zTemp0+1 					; save new line at zTemp0
.a45a	85 36		sta $36				sta 	zTemp0
.a45c	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a45e	85 38		sta $38				sta 	0+zTemp1
.a460	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a462	85 39		sta $39				sta 	1+zTemp1
.a464	b2 38		lda ($38)			lda 	(zTemp1)
.a466	d0 0a		bne $a472			bne 	_MDLANoInitialise
.a468	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a46a	8d b8 05	sta $05b8			sta 	0+AppendPointer
.a46d	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a46f	8d b9 05	sta $05b9			sta 	1+AppendPointer
.a472					_MDLANoInitialise:
.a472	18		clc				clc
.a473	ad b8 05	lda $05b8			lda 	AppendPointer 				; copy append pointer to zTemp1 adding the offset as you go
.a476	85 38		sta $38				sta 	zTemp1
.a478	72 36		adc ($36)			adc 	(zTemp0)
.a47a	8d b8 05	sta $05b8			sta 	AppendPointer
.a47d	ad b9 05	lda $05b9			lda 	AppendPointer+1
.a480	85 39		sta $39				sta 	zTemp1+1
.a482	69 00		adc #$00			adc 	#0
.a484	8d b9 05	sta $05b9			sta 	AppendPointer+1
.a487	a0 00		ldy #$00			ldy 	#0
.a489					_MDLACopy:
.a489	b1 36		lda ($36),y			lda 	(zTemp0),y 					; copy new line in
.a48b	91 38		sta ($38),y			sta 	(zTemp1),y
.a48d	c8		iny				iny
.a48e	98		tya				tya
.a48f	d2 36		cmp ($36)			cmp 	(zTemp0) 					; done whole line
.a491	d0 f6		bne $a489			bne 	_MDLACopy
.a493	a9 00		lda #$00			lda 	#0 							; end of program.
.a495	91 38		sta ($38),y			sta 	(zTemp1),y
.a497	60		rts				rts
.05b8					AppendPointer:
>05b8							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/memory.asm

.a498					MemoryNew:
.a498	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a49a	85 30		sta $30				sta 	codePtr
.a49c	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a49e	85 31		sta $31				sta 	codePtr+1
.a4a0	a9 00		lda #$00			lda 	#0 							; write zero there erasing the program.
.a4a2	92 30		sta ($30)			sta 	(codePtr)
.a4a4	60		rts				rts
.a4a5					MemoryInline:
.a4a5	98		tya				tya 								; put address into stack,x
.a4a6	18		clc				clc  								; get the offset, add codePtr
.a4a7	65 30		adc $30				adc 	codePtr
.a4a9	95 58		sta $58,x			sta 	NSMantissa0,x 				; store the result in the mantissa.
.a4ab	a5 31		lda $31				lda 	codePtr+1
.a4ad	69 00		adc #$00			adc 	#0
.a4af	95 60		sta $60,x			sta 	NSMantissa1,x
.a4b1	74 68		stz $68,x			stz 	NSMantissa2,x
.a4b3	74 70		stz $70,x			stz 	NSMantissa3,x
.a4b5	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/search.asm

.a4b6					MemorySearch:
.a4b6	85 36		sta $36				sta 	zTemp0 						; save line number in zTemp0
.a4b8	86 37		stx $37				stx 	zTemp0+1
.a4ba	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a4bc	85 30		sta $30				sta 	codePtr
.a4be	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a4c0	85 31		sta $31				sta 	codePtr+1
.a4c2					_MTAXLoop:
.a4c2	b2 30		lda ($30)			lda 	(codePtr)
.a4c4	18		clc				clc
.a4c5	f0 21		beq $a4e8			beq 	_MTAXExit 					; reached end, exit with CC.
.a4c7	a0 01		ldy #$01			ldy 	#1 							; calculate current line# - requested line#
.a4c9	b1 30		lda ($30),y			lda 	(codePtr),y
.a4cb	38		sec				sec
.a4cc	e5 36		sbc $36				sbc 	zTemp0
.a4ce	85 38		sta $38				sta 	zTemp1 						; save interim to set Z
.a4d0	c8		iny				iny 								; do the MSB
.a4d1	b1 30		lda ($30),y			lda 	(codePtr),y
.a4d3	e5 37		sbc $37				sbc 	zTemp0+1
.a4d5	05 38		ora $38				ora 	zTemp1 						; will set Z if result is zero, doesn't affect carry flag
.a4d7	f0 0f		beq $a4e8			beq 	_MTAXExit	 				; found so exit (CS will be set)
.a4d9	b0 0d		bcs $a4e8			bcs 	_MTAXExit 					; current < required exit
.a4db	18		clc				clc
.a4dc	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.a4de	65 30		adc $30				adc 	codePtr
.a4e0	85 30		sta $30				sta 	codePtr
.a4e2	90 02		bcc $a4e6			bcc 	_CREExit
.a4e4	e6 31		inc $31				inc 	codePtr+1 					; carry
.a4e6					_CREExit:
.a4e6	80 da		bra $a4c2			bra 	_MTAXLoop
.a4e8					_MTAXExit:
.a4e8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/playing.asm

.a4e9					UnaryPlaying:
.a4e9	fa		plx				plx
.a4ea	20 eb 9c	jsr $9ceb			jsr 	Evaluate8BitInteger 		; get channel #
.a4ed	48		pha				pha
.a4ee	20 27 8e	jsr $8e27			jsr		CheckRightBracket
.a4f1	68		pla				pla
.a4f2	c9 04		cmp #$04			cmp 	#4
.a4f4	b0 0c		bcs $a502			bcs 	_UPNotPlaying
.a4f6	09 20		ora #$20			ora 	#$20 						; query playing ?
.a4f8	20 83 b8	jsr $b883			jsr 	SNDCommand
.a4fb	c9 00		cmp #$00			cmp 	#0
.a4fd	f0 03		beq $a502			beq 	_UPNotPlaying
.a4ff	4c ad 8e	jmp $8ead			jmp 	ReturnTrue
.a502					_UPNotPlaying:
.a502	4c b8 8e	jmp $8eb8			jmp 	ReturnFalse

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/sound.asm

.a505					SoundCommand:
.a505	b1 30		lda ($30),y			lda 	(codePtr),y
.a507	c9 c0		cmp #$c0			cmp 	#KWD_OFF 					; SOUND OFF ?
.a509	d0 09		bne $a514			bne 	_SNDMain
.a50b	c8		iny				iny 								; skip OFF
.a50c	a9 3f		lda #$3f			lda 	#$3F 						; call command $3F (silence)
.a50e	5a		phy				phy
.a50f	20 83 b8	jsr $b883			jsr 	SNDCommand
.a512	7a		ply				ply
.a513	60		rts				rts
.a514					_SNDMain:
.a514	a2 00		ldx #$00			ldx 	#0
.a516	20 eb 9c	jsr $9ceb			jsr 	Evaluate8BitInteger 		; channel
.a519	c9 04		cmp #$04			cmp 	#4 							; must be 0-3
.a51b	b0 4b		bcs $a568			bcs 	_SndError
.a51d	e8		inx				inx 								; do the rest in slot 1.
.a51e	20 2f 8e	jsr $8e2f			jsr 	CheckComma
.a521	20 d0 9c	jsr $9cd0			jsr 	Evaluate16BitInteger 		; Pitch
.a524	b5 60		lda $60,x			lda 	NSMantissa1,x 				; must be 10 bit
.a526	c9 10		cmp #$10			cmp 	#16
.a528	b0 3e		bcs $a568			bcs 	_SndError
.a52a	8d bb 05	sta $05bb			sta 	SoundCommandBlock+1 		; Pitch (2 bytes + 0)
.a52d	b5 58		lda $58,x			lda 	NSMantissa0,x
.a52f	8d ba 05	sta $05ba			sta 	SoundCommandBlock
.a532	20 2f 8e	jsr $8e2f			jsr 	CheckComma
.a535	20 eb 9c	jsr $9ceb			jsr 	Evaluate8BitInteger 		; Length (1 byte + 3)
.a538	8d bd 05	sta $05bd			sta 	SoundCommandBlock+3
.a53b	a9 0f		lda #$0f			lda 	#15
.a53d	8d bc 05	sta $05bc			sta 	SoundCommandBlock+2 		; Volume (1 byte + 2)
.a540	9c be 05	stz $05be			stz 	SoundCommandBlock+4 		; default slide (2 bytes +4)
.a543	9c bf 05	stz $05bf			stz 	SoundCommandBlock+5
.a546	b1 30		lda ($30),y			lda 	(codePtr),y
.a548	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.a54a	d0 0e		bne $a55a			bne 	_SNDPlay
.a54c	c8		iny				iny
.a54d	20 da 9c	jsr $9cda			jsr 	Evaluate16BitIntegerSigned 	; Slide
.a550	b5 58		lda $58,x			lda 	NSMantissa0,x 				; Slide (2 bytes + 4)
.a552	8d be 05	sta $05be			sta 	SoundCommandBlock+4
.a555	b5 60		lda $60,x			lda 	NSMantissa1,x
.a557	8d bf 05	sta $05bf			sta 	SoundCommandBlock+5
.a55a					_SNDPlay:
.a55a	5a		phy				phy
.a55b	a5 58		lda $58				lda 	NSMantissa0 				; channel.
.a55d	09 10		ora #$10			ora 	#$10 						; 1x = Queue sound
.a55f	a2 ba		ldx #$ba			ldx 	#(SoundCommandBlock & $FF)
.a561	a0 05		ldy #$05			ldy 	#(SoundCommandBlock >> 8)
.a563	20 83 b8	jsr $b883			jsr 	SNDCommand
.a566	7a		ply				ply
.a567	60		rts				rts
.a568					_SndError:
.a568	4c cd 9e	jmp $9ecd			jmp 	RangeError
.05ba					SoundCommandBlock:
>05ba							.fill 	6

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/bytes.asm

.a56b					StackPushByte:
.a56b	48		pha				pha 								; save byte
.a56c	a5 34		lda $34				lda 	BasicStack
.a56e	d0 09		bne $a579			bne 	_SPBNoBorrow
.a570	c6 35		dec $35				dec 	BasicStack+1
.a572	48		pha				pha
.a573	a5 35		lda $35				lda 	BasicStack+1
.a575	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a577	90 06		bcc $a57f			bcc 	_SPBMemory
.a579					_SPBNoBorrow:
.a579	c6 34		dec $34				dec 	BasicStack
.a57b	68		pla				pla 								; get back and write
.a57c	92 34		sta ($34)			sta 	(BasicStack)
.a57e	60		rts				rts
.a57f					_SPBMemory:
.a57f	a9 12		lda #$12		lda	#18
.a581	4c 40 8e	jmp $8e40		jmp	ErrorHandler
.a584					StackPopByte:
.a584	b2 34		lda ($34)			lda 	(BasicStack)
.a586	e6 34		inc $34				inc 	BasicStack
.a588	d0 02		bne $a58c			bne 	_SPBNoCarry
.a58a	e6 35		inc $35				inc 	BasicStack+1
.a58c					_SPBNoCarry:
.a58c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/frames.asm

.a58d					StackOpen:
.a58d	48		pha				pha 								; save frame byte
.a58e	29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.a590	0a		asl a				asl 	a 							; claim twice this for storage
.a591	49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.a593	38		sec				sec 								; so basically subtracting from
.a594	65 34		adc $34				adc 	basicStack 	 				; basicStack
.a596	85 34		sta $34				sta 	basicStack
.a598	b0 08		bcs $a5a2			bcs 	_SONoBorrow
.a59a	c6 35		dec $35				dec 	basicStack+1
.a59c	a5 35		lda $35				lda 	basicStack+1 				; have we reached stack overflow
.a59e	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a5a0	90 04		bcc $a5a6			bcc 	_SOMemory
.a5a2					_SONoBorrow:
.a5a2	68		pla				pla 								; get marker back and write at TOS
.a5a3	92 34		sta ($34)			sta 	(basicStack)
.a5a5	60		rts				rts
.a5a6					_SOMemory:
.a5a6	a9 12		lda #$12		lda	#18
.a5a8	4c 40 8e	jmp $8e40		jmp	ErrorHandler
.a5ab					StackClose:
.a5ab	b2 34		lda ($34)			lda 	(basicStack) 				; get TOS marker
.a5ad	29 0f		and #$0f			and 	#$0F 						; bytes to add back
.a5af	0a		asl a				asl 	a 							; claim twice this.
.a5b0	65 34		adc $34				adc 	basicStack 					; add to the stack pointer.
.a5b2	85 34		sta $34				sta 	basicStack
.a5b4	90 02		bcc $a5b8			bcc 	_SCExit
.a5b6	e6 35		inc $35				inc 	basicStack+1
.a5b8					_SCExit:
.a5b8	60		rts				rts
.a5b9					StackCheckFrame:
.a5b9	48		pha				pha
.a5ba					_StackRemoveLocals:
.a5ba	b2 34		lda ($34)			lda 	(basicStack) 				; check for local, keep popping them
.a5bc	c9 03		cmp #$03			cmp 	#STK_LOCALS+1
.a5be	b0 05		bcs $a5c5			bcs 	_SCNoLocal
.a5c0	20 dd 88	jsr $88dd			jsr 	LocalPopValue
.a5c3	80 f5		bra $a5ba			bra 	_StackRemoveLocals
.a5c5					_SCNoLocal:
.a5c5	68		pla				pla
.a5c6	52 34		eor ($34)			eor 	(basicStack) 				; xor with toS marker
.a5c8	29 f0		and #$f0			and 	#$F0 						; check type bits
.a5ca	d0 01		bne $a5cd			bne 	_SCFError 					; different, we have structures mixed up
.a5cc	60		rts				rts
.a5cd					_SCFError:
.a5cd	8a		txa				txa 								; report error X
.a5ce	4c 40 8e	jmp $8e40			jmp 	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/location.asm

.a5d1					STKSaveCodePosition:
.a5d1	5a		phy				phy
.a5d2	98		tya				tya 								; save Y
.a5d3	a0 05		ldy #$05			ldy 	#5
.a5d5	91 34		sta ($34),y			sta 	(basicStack),y
.a5d7	88		dey				dey 								; save Code Pointer
.a5d8					_STKSaveLoop:
.a5d8	b9 2f 00	lda $002f,y			lda 	safePtr-1,y 				; allows us to access the pointer w/out issues.
.a5db	91 34		sta ($34),y			sta 	(basicStack),y
.a5dd	88		dey				dey
.a5de	d0 f8		bne $a5d8			bne 	_STKSaveLoop
.a5e0	7a		ply				ply
.a5e1	60		rts				rts
.a5e2					STKLoadCodePosition:
.a5e2	a0 01		ldy #$01			ldy 	#1 							; load code pointer back
.a5e4					_STKLoadLoop:
.a5e4	b1 34		lda ($34),y			lda 	(basicStack),y
.a5e6	99 2f 00	sta $002f,y			sta 	safePtr-1,y
.a5e9	c8		iny				iny
.a5ea	c0 05		cpy #$05			cpy 	#5
.a5ec	d0 f6		bne $a5e4			bne 	_STKLoadLoop
.a5ee	b1 34		lda ($34),y			lda 	(basicStack),y 				; get Y offset
.a5f0	a8		tay				tay
.a5f1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/setup.asm

.a5f2					StackReset:
.a5f2	a9 ff		lda #$ff			lda 	#((BasicStackBase+BasicStackSize-1) & $FF)
.a5f4	85 34		sta $34				sta 	0+basicStack
.a5f6	a9 0f		lda #$0f			lda 	#((BasicStackBase+BasicStackSize-1) >> 8)
.a5f8	85 35		sta $35				sta 	1+basicStack
.a5fa	a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.a5fc	92 34		sta ($34)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.a5fe	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/concrete.asm

.a5ff					StringConcrete:
.a5ff	5a		phy				phy 								; save position on stack
.a600	20 75 99	jsr $9975			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a603	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy target string to zTemp1
.a605	85 38		sta $38				sta 	zTemp1
.a607	b5 60		lda $60,x			lda 	NSMantissa1,x
.a609	85 39		sta $39				sta 	zTemp1+1
.a60b	a0 ff		ldy #$ff			ldy 	#$FF	 					; calculate string length
.a60d					_SALength:
.a60d	c8		iny				iny
.a60e	b1 38		lda ($38),y			lda 	(zTemp1),y
.a610	d0 fb		bne $a60d			bne 	_SALength
.a612	c0 fd		cpy #$fd			cpy 	#253 						; string too long
.a614	b0 3d		bcs $a653			bcs 	_SALengthError
.a616	98		tya				tya 				 				; length of the new string
.a617	18		clc				clc
.a618	69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.a61a	90 02		bcc $a61e			bcc 	_SAHaveLength
.a61c	a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.a61e					_SAHaveLength:
.a61e	48		pha				pha 								; save length.
.a61f	38		sec				sec
.a620	49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.a622	6d 0e 04	adc $040e			adc 	StringMemory
.a625	8d 0e 04	sta $040e			sta 	StringMemory
.a628	85 3a		sta $3a				sta 	zTemp2 						; update storage address
.a62a	95 58		sta $58,x			sta 	NSMantissa0,x 				; update mantissa address
.a62c	a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.a62e	6d 0f 04	adc $040f			adc 	StringMemory+1
.a631	8d 0f 04	sta $040f			sta 	StringMemory+1
.a634	85 3b		sta $3b				sta 	zTemp2+1
.a636	95 60		sta $60,x			sta 	NSMantissa1,x
.a638	68		pla				pla 								; save length-3 (chars allowed) in first byte
.a639	38		sec				sec
.a63a	e9 03		sbc #$03			sbc 	#3
.a63c	92 3a		sta ($3a)			sta 	(zTemp2)
.a63e	a9 00		lda #$00			lda 	#0 							; clear the status byte.
.a640	a0 01		ldy #$01			ldy 	#1
.a642	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a644					_SACopyNewString:
.a644	a0 00		ldy #$00			ldy 	#0
.a646					_SACopyNSLoop:
.a646	b1 38		lda ($38),y			lda 	(zTemp1),y 					; get character
.a648	c8		iny				iny 								; write two on in string storage
.a649	c8		iny				iny
.a64a	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a64c	88		dey				dey 								; this makes it one one.
.a64d	c9 00		cmp #$00			cmp 	#0 							; until EOS copied
.a64f	d0 f5		bne $a646			bne 	_SACopyNSLoop
.a651	7a		ply				ply
.a652	60		rts				rts
.a653					_SALengthError:
.a653	a9 09		lda #$09		lda	#9
.a655	4c 40 8e	jmp $8e40		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/stringalloc.asm

.a658					StringSystemInitialise:
.a658	a9 ff		lda #$ff			lda 	#((EndVariableSpace-1) & $FF)
.a65a	8d 0e 04	sta $040e			sta 	0+StringMemory
.a65d	a9 1f		lda #$1f			lda 	#((EndVariableSpace-1) >> 8)
.a65f	8d 0f 04	sta $040f			sta 	1+StringMemory
.a662	9c ff 1f	stz $1fff			stz 	EndVariableSpace-1 			; put a zero at the end, so know end of string memory.
.a665	60		rts				rts
.a666					StringSpaceInitialise:
.a666	20 75 99	jsr $9975			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a669	a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.a66b	8d 10 04	sta $0410			sta 	StringInitialised
.a66e	ad 0e 04	lda $040e			lda 	StringMemory 				; allocate 256 bytes for one concreted string
.a671	8d 11 04	sta $0411			sta 	StringTempPointer
.a674	ad 0f 04	lda $040f			lda 	StringMemory+1
.a677	3a		dec a				dec 	a
.a678	8d 12 04	sta $0412			sta 	StringTempPointer+1
.a67b	60		rts				rts
.a67c					StringTempAllocate:
.a67c	c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.a67e	b0 30		bcs $a6b0			bcs 	_STALength
.a680	2c 10 04	bit $0410			bit 	StringInitialised 			; already initialised
.a683	30 05		bmi $a68a			bmi 	_STAAllocate
.a685	48		pha				pha 								; save value to subtract.
.a686	20 66 a6	jsr $a666			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.a689	68		pla				pla 								; restore it
.a68a					_STAAllocate:
.a68a	49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.a68c	18		clc				clc  								; deliberate allows one more
.a68d	6d 11 04	adc $0411			adc 	StringTempPointer 			; subtract from temp pointer
.a690	8d 11 04	sta $0411			sta 	StringTempPointer
.a693	95 58		sta $58,x			sta 	NSMantissa0,x 				; address in mantissa
.a695	85 3c		sta $3c				sta 	zsTemp 						; and zsTemp
.a697	ad 12 04	lda $0412			lda 	StringTempPointer+1
.a69a	69 ff		adc #$ff			adc 	#$FF
.a69c	8d 12 04	sta $0412			sta 	StringTempPointer+1
.a69f	85 3d		sta $3d				sta 	zsTemp+1
.a6a1	95 60		sta $60,x			sta 	NSMantissa1,x
.a6a3	74 68		stz $68,x			stz 	NSMantissa2,x 				; set the typing data
.a6a5	74 70		stz $70,x			stz 	NSMantissa3,x
.a6a7	a9 10		lda #$10			lda 	#NSTString
.a6a9	95 50		sta $50,x			sta 	NSStatus,x
.a6ab	a9 00		lda #$00			lda 	#0 							; clear the target string
.a6ad	92 3c		sta ($3c)			sta 	(zsTemp)
.a6af	60		rts				rts
.a6b0					_STALength:
.a6b0	a9 09		lda #$09		lda	#9
.a6b2	4c 40 8e	jmp $8e40		jmp	ErrorHandler
.a6b5					StringTempWrite:
.a6b5	48		pha				pha
.a6b6	92 3c		sta ($3c)			sta 	(zsTemp)
.a6b8	e6 3c		inc $3c				inc 	zsTemp
.a6ba	d0 02		bne $a6be			bne 	_STWNoCarry
.a6bc	e6 3d		inc $3d				inc 	zsTemp+1
.a6be					_STWNoCarry:
.a6be	a9 00		lda #$00			lda 	#0
.a6c0	92 3c		sta ($3c)			sta 	(zsTemp)
.a6c2	68		pla				pla
.a6c3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_hardware.module

=1					hardwareIntegrated=1
=0					CONBlack = 0
=1					CONWhite = 1
=2					CONRed = 2
=3					CONCyan = 3
=4					CONPurple = 4
=5					CONGreen = 5
=6					CONBlue = 6
=7					CONYellow = 7
=8					CONOrange = 8
=9					CONBrown = 9
=10					CONYellowGreen = 10
=11					CONRosa = 11
=12					CONBlueGreen = 12
=13					CONLightBlue = 13
=14					CONPink = 14
=15					CONLightGreen = 15
=7					CONForeground = CONYellow
=6					CONBackground = CONBlue
=5					CLICommandLine = CONGreen
=9					CLINumber = CONBrown
=3					CLIToken = CONCyan
=13					CLIConstant = CONLightBlue
=7					CLIIdentifier = CONYellow
=10					CLIPunctuation = CONYellowGreen
=1					CLIData = CONWhite
.a6c4					EXTPrintCharacter:
.a6c4	48		pha				pha
.a6c5	da		phx				phx
.a6c6	5a		phy				phy
.a6c7	a6 01		ldx $01				ldx 	1
.a6c9	da		phx				phx
.a6ca	ac c1 05	ldy $05c1			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.a6cd	09 00		ora #$00			ora 	#$00 						; check $80-$FF
.a6cf	30 48		bmi $a719			bmi 	_EXPCColour
.a6d1	c9 20		cmp #$20			cmp 	#$20 						; check $00-$1F
.a6d3	90 4d		bcc $a722			bcc 	_EXPCControl
.a6d5	a2 02		ldx #$02			ldx 	#2 							; select char memory
.a6d7	86 01		stx $01				stx 	1
.a6d9	91 40		sta ($40),y			sta 	(EXTAddress),y
.a6db	e6 01		inc $01				inc 	1 							; select colour memory
.a6dd	ad c2 05	lda $05c2			lda 	EXTTextColour
.a6e0	91 40		sta ($40),y			sta 	(EXTAddress),y
.a6e2	c8		iny				iny 								; advance horizontal position
.a6e3	8c c1 05	sty $05c1			sty 	EXTColumn
.a6e6	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth 				; reached RHS ?
.a6e9	90 66		bcc $a751			bcc 	_EXPCExit 					; no, then exit.
.a6eb					_EXPCCRLF:
.a6eb	ee c0 05	inc $05c0			inc 	EXTRow  					; bump row
.a6ee	9c c1 05	stz $05c1			stz 	EXTColumn 					; back to column 0
.a6f1	ad c0 05	lda $05c0			lda 	EXTRow 						; check if reached the bottom ?
.a6f4	cd c4 05	cmp $05c4			cmp 	EXTScreenHeight 			; if so, then scroll.
.a6f7	f0 18		beq $a711			beq 	_EXPCScroll
.a6f9	18		clc				clc 								; add width to address.
.a6fa	a5 40		lda $40				lda 	EXTAddress
.a6fc	6d c3 05	adc $05c3			adc 	EXTScreenWidth
.a6ff	85 40		sta $40				sta 	EXTAddress
.a701	90 4e		bcc $a751			bcc 	_EXPCExit
.a703	e6 41		inc $41				inc 	EXTAddress+1
.a705	80 4a		bra $a751			bra 	_EXPCExit
.a707					_EXPCLeft:
.a707	ce c1 05	dec $05c1			dec 	EXTColumn
.a70a	10 45		bpl $a751			bpl 	_EXPCExit
.a70c					_EXPCBegin:
.a70c	9c c1 05	stz $05c1			stz 	EXTColumn
.a70f	80 40		bra $a751			bra 	_EXPCExit
.a711					_EXPCScroll:
.a711	ce c0 05	dec $05c0			dec 	EXTRow 						; the height-1 th line.
.a714	20 de a7	jsr $a7de			jsr 	EXTScreenScroll 			; scroll the screen
.a717	80 38		bra $a751			bra 	_EXPCExit
.a719					_EXPCColour:
.a719	c9 a0		cmp #$a0			cmp 	#$A0						; 80-9F set foreground/background
.a71b	b0 34		bcs $a751			bcs 	_EXPCExit
.a71d	20 be a7	jsr $a7be			jsr 	_EXPCHandleColour
.a720	80 2f		bra $a751			bra 	_EXPCExit
.a722					_EXPCControl:
.a722	c9 11		cmp #$11			cmp 	#$11 						; only handle 00-10.
.a724	b0 2b		bcs $a751			bcs 	_EXPCExit
.a726	0a		asl a				asl 	a 							; double into X
.a727	aa		tax				tax
.a728	7c 9c a7	jmp ($a79c,x)			jmp 	(_EXPCActionTable,x) 		; and execute code.
.a72b					_EXPCUp:
.a72b	ad c0 05	lda $05c0			lda 	EXTRow 						; already at top ?
.a72e	f0 21		beq $a751			beq 	_EXPCExit
.a730	ce c0 05	dec $05c0			dec 	EXTRow 						; up one in position/address
.a733	38		sec				sec
.a734	a5 40		lda $40				lda 	EXTAddress
.a736	ed c3 05	sbc $05c3			sbc 	EXTScreenWidth
.a739	85 40		sta $40				sta 	EXTAddress
.a73b	b0 14		bcs $a751			bcs 	_EXPCExit
.a73d	c6 41		dec $41				dec 	EXTAddress+1
.a73f	80 10		bra $a751			bra 	_EXPCExit
.a741					_EXPCRight:
.a741	c8		iny				iny
.a742	8c c1 05	sty $05c1			sty 	EXTColumn
.a745	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth
.a748	d0 07		bne $a751			bne 	_EXPCExit
.a74a					_EXPCEnd:
.a74a	ad c3 05	lda $05c3			lda 	EXTScreenWidth
.a74d	3a		dec a				dec 	a
.a74e	8d c1 05	sta $05c1			sta 	EXTColumn
.a751					_EXPCExit:
.a751	20 33 a8	jsr $a833			jsr 	EXTSetHardwareCursor 		; place the physical cursor.
.a754	68		pla				pla
.a755	85 01		sta $01				sta 	1
.a757	7a		ply				ply
.a758	fa		plx				plx
.a759	68		pla				pla
.a75a	60		rts				rts
.a75b					_EXPCClearScreen:
.a75b	20 f0 a7	jsr $a7f0			jsr		EXTClearScreenCode
.a75e	80 f1		bra $a751			bra 	_EXPCExit
.a760					_EXPCDown:
.a760	ad c4 05	lda $05c4			lda 	EXTScreenHeight 			; at the bottom
.a763	3a		dec a				dec 	a
.a764	cd c0 05	cmp $05c0			cmp 	EXTRow
.a767	f0 e8		beq $a751			beq 	_EXPCExit
.a769	ee c0 05	inc $05c0			inc 	EXTRow 						; down one in position/address
.a76c	18		clc				clc
.a76d	a5 40		lda $40				lda 	EXTAddress
.a76f	6d c3 05	adc $05c3			adc 	EXTScreenWidth
.a772	85 40		sta $40				sta 	EXTAddress
.a774	90 db		bcc $a751			bcc 	_EXPCExit
.a776	e6 41		inc $41				inc 	EXTAddress+1
.a778	80 d7		bra $a751			bra 	_EXPCExit
.a77a					_EXPCTab:
.a77a	ad c1 05	lda $05c1			lda 	EXTColumn 					; next tab stop
.a77d	29 f8		and #$f8			and 	#$F8
.a77f	18		clc				clc
.a780	69 08		adc #$08			adc 	#8
.a782	8d c1 05	sta $05c1			sta 	EXTColumn
.a785	cd c3 05	cmp $05c3			cmp 	EXTScreenWidth 				; too far, stick end of line.
.a788	90 c7		bcc $a751			bcc 	_EXPCExit
.a78a	80 be		bra $a74a			bra 	_EXPCEnd
.a78c					_EXPCBackSpace:
.a78c	88		dey				dey
.a78d	30 c2		bmi $a751			bmi 	_EXPCExit
.a78f	ce c1 05	dec $05c1			dec 	EXTColumn
.a792	a9 02		lda #$02			lda 	#2
.a794	85 01		sta $01				sta 	1
.a796	a9 20		lda #$20			lda 	#32
.a798	91 40		sta ($40),y			sta 	(EXTAddress),y
.a79a	80 b5		bra $a751			bra 	_EXPCExit
.a79c					_EXPCActionTable:
>a79c	51 a7						.word 	_EXPCExit 					; 00
>a79e	0c a7						.word 	_EXPCBegin 					; 01 A Start of Line
>a7a0	07 a7						.word 	_EXPCLeft 					; 02 B Left
>a7a2	51 a7						.word 	_EXPCExit 					; 03 <Break>
>a7a4	51 a7						.word 	_EXPCExit 					; 04
>a7a6	4a a7						.word 	_EXPCEnd 					; 05 E End of Line
>a7a8	41 a7						.word 	_EXPCRight 					; 06 F Right
>a7aa	51 a7						.word 	_EXPCExit 					; 07
>a7ac	8c a7						.word 	_EXPCBackspace 				; 08 H Backspace
>a7ae	7a a7						.word 	_EXPCTab 					; 09 I Tab
>a7b0	51 a7						.word 	_EXPCExit 					; 0A
>a7b2	51 a7						.word 	_EXPCExit 					; 0B
>a7b4	5b a7						.word 	_EXPCClearScreen			; 0C L CLS
>a7b6	eb a6						.word 	_EXPCCRLF 					; 0D M CR/LF
>a7b8	60 a7						.word 	_EXPCDown 					; 0E N Down
>a7ba	51 a7						.word 	_EXPCExit 					; 0F
>a7bc	2b a7						.word 	_EXPCUp 					; 10 P Up
.a7be					_EXPCHandleColour
.a7be	c9 90		cmp #$90			cmp 	#$90 						; 8x foreground 9x background
.a7c0	b0 16		bcs $a7d8			bcs 	_EXPCBackground
.a7c2	0a		asl a				asl 	a 							; shift it 4 bits to the right.
.a7c3	0a		asl a				asl 	a
.a7c4	0a		asl a				asl 	a
.a7c5	0a		asl a				asl 	a
.a7c6	a2 0f		ldx #$0f			ldx 	#$0F 						; Mask in X
.a7c8					_EXPCUpdate:
.a7c8	48		pha				pha 								; save new colour
.a7c9	8a		txa				txa 								; get mask
.a7ca	2d c2 05	and $05c2			and 	EXTTextColour 				; mask out old.
.a7cd	8d c2 05	sta $05c2			sta 	EXTTextColour
.a7d0	68		pla				pla 								; or in new colour
.a7d1	0d c2 05	ora $05c2			ora 	EXTTextColour
.a7d4	8d c2 05	sta $05c2			sta 	EXTTextColour
.a7d7	60		rts				rts
.a7d8					_EXPCBackground:
.a7d8	29 0f		and #$0f			and 	#$0F 						; get the colour
.a7da	a2 f0		ldx #$f0			ldx 	#$F0 						; mask
.a7dc	80 ea		bra $a7c8			bra 	_EXPCUpdate
.a7de					EXTScreenScroll:
.a7de	a9 02		lda #$02			lda 	#2 							; select text page
.a7e0	85 01		sta $01				sta 	1
.a7e2	a9 20		lda #$20			lda		#32 						; fill with space
.a7e4	20 f3 a8	jsr $a8f3			jsr 	EXTScrollFill
.a7e7	e6 01		inc $01				inc 	1 							; select colour page
.a7e9	ad c2 05	lda $05c2			lda 	EXTTextColour
.a7ec	20 f3 a8	jsr $a8f3			jsr 	EXTScrollFill
.a7ef	60		rts				rts
.a7f0					EXTClearScreenCode:
.a7f0	a9 02		lda #$02			lda 	#2 							; select text page
.a7f2	85 01		sta $01				sta 	1
.a7f4	a9 20		lda #$20			lda		#32 						; fill with space
.a7f6	20 03 a8	jsr $a803			jsr 	_EXTCSFill
.a7f9	e6 01		inc $01				inc 	1 							; select colour page
.a7fb	ad c2 05	lda $05c2			lda 	EXTTextColour
.a7fe	20 03 a8	jsr $a803			jsr 	_EXTCSFill
.a801	80 22		bra $a825			bra 	EXTHomeCursor
.a803					_EXTCSFill:
.a803	aa		tax				tax
.a804	a9 00		lda #$00			lda 	#EXTMemory & $FF
.a806	85 40		sta $40				sta 	EXTAddress
.a808	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a80a	85 41		sta $41				sta 	EXTAddress+1
.a80c					_EXTCSFill1:
.a80c	a0 00		ldy #$00			ldy 	#0
.a80e	8a		txa				txa
.a80f					_EXTCSFill2:
.a80f	91 40		sta ($40),y			sta 	(EXTAddress),y
.a811	c8		iny				iny
.a812	d0 fb		bne $a80f			bne 	_EXTCSFill2
.a814	e6 41		inc $41				inc 	EXTAddress+1
.a816	a5 41		lda $41				lda 	EXTAddress+1
.a818	c9 d2		cmp #$d2			cmp 	#$D2
.a81a	d0 f0		bne $a80c			bne 	_EXTCSFill1
.a81c	8a		txa				txa
.a81d					_EXTCSFill3:
.a81d	91 40		sta ($40),y			sta 	(EXTAddress),y
.a81f	c8		iny				iny
.a820	c0 c0		cpy #$c0			cpy 	#$C0
.a822	d0 f9		bne $a81d			bne 	_EXTCSFill3
.a824	60		rts				rts
.a825					EXTHomeCursor:
.a825	9c c0 05	stz $05c0			stz 	EXTRow 						; reset row & column
.a828	9c c1 05	stz $05c1			stz 	EXTColumn
.a82b	a9 00		lda #$00			lda 	#EXTMemory & $FF 			; set address
.a82d	85 40		sta $40				sta 	EXTAddress
.a82f	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a831	85 41		sta $41				sta 	EXTAddress+1
.a833					EXTSetHardwareCursor:
.a833	64 01		stz $01				stz 	1 							; I/O Page zero
.a835	a9 05		lda #$05			lda 	#1+4 						; enable cursor
.a837	8d 10 d0	sta $d010			sta 	$D010
.a83a	a9 b1		lda #$b1			lda 	#$B1
.a83c	8d 12 d0	sta $d012			sta 	$D012
.a83f	ad c1 05	lda $05c1			lda 	EXTColumn
.a842	8d 14 d0	sta $d014			sta 	$D014 						; set cursor position
.a845	9c 15 d0	stz $d015			stz 	$D015
.a848	ad c0 05	lda $05c0			lda 	EXTRow
.a84b	8d 16 d0	sta $d016			sta 	$D016
.a84e	9c 17 d0	stz $d017			stz 	$D017
.a851	60		rts				rts
.a852					EXTInputLine:
.a852	48		pha				pha
.a853	da		phx				phx
.a854	5a		phy				phy
.a855	a5 01		lda $01				lda 	1 							; save I/O page
.a857	48		pha				pha
.a858					_EILLoop:
.a858	20 5a a9	jsr $a95a			jsr 	ExtInputSingleCharacter
.a85b	c9 0d		cmp #$0d			cmp 	#13 						; scrape line if exit.
.a85d	f0 40		beq $a89f			beq 	_EILExit
.a85f	c9 08		cmp #$08			cmp 	#8 							; handle backspace
.a861	f0 1c		beq $a87f			beq 	_EILBackspace
.a863	c9 20		cmp #$20			cmp 	#' '						; < space, print it
.a865	90 12		bcc $a879			bcc 	_EILPrintLoop
.a867	c9 7f		cmp #$7f			cmp 	#$7F 						; if -ve print it
.a869	b0 0e		bcs $a879			bcs 	_EILPrintLoop
.a86b	48		pha				pha 								; save character
.a86c	a9 02		lda #$02			lda 	#2  						; insert a space
.a86e	85 01		sta $01				sta 	1
.a870	20 e1 a8	jsr $a8e1			jsr 	EXTILInsert 				; insert in text screen
.a873	e6 01		inc $01				inc 	1
.a875	20 e1 a8	jsr $a8e1			jsr 	EXTILInsert 				; insert in colour screen
.a878	68		pla				pla 								; get character back.
.a879					_EILPrintLoop:
.a879	20 c4 a6	jsr $a6c4			jsr 	ExtPrintCharacter
.a87c	80 da		bra $a858			bra 	_EILLoop
.a87e	60		rts				rts
.a87f					_EILBackspace:
.a87f	ad c1 05	lda $05c1			lda 	EXTColumn					; can we backspace ?
.a882	f0 d4		beq $a858			beq 	_EILLoop
.a884	a9 02		lda #$02			lda 	#2 							; move cursor left
.a886	20 c4 a6	jsr $a6c4			jsr 	EXTPrintCharacter
.a889	a9 02		lda #$02			lda 	#2 							; text block
.a88b	85 01		sta $01				sta 	1
.a88d	a9 20		lda #$20			lda 	#' ' 						; backspace text.
.a88f	20 cc a8	jsr $a8cc			jsr 	EXTILDelete
.a892	e6 01		inc $01				inc 	1 							; colour block
.a894	ac c1 05	ldy $05c1			ldy 	EXTColumn 					; get attribute of last character
.a897	88		dey				dey
.a898	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a89a	20 cc a8	jsr $a8cc			jsr 	EXTILDelete 				; backspace attribute
.a89d	80 b9		bra $a858			bra 	_EILLoop 					; and go round.
.a89f					_EILExit:
.a89f	a9 02		lda #$02			lda 	#2 							; switch to page 2
.a8a1	85 01		sta $01				sta 	1
.a8a3	a0 00		ldy #$00			ldy 	#0 							; copy current line into buffer.
.a8a5					_EILScrapeLine:
.a8a5	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a8a7	99 2a 05	sta $052a,y			sta 	lineBuffer,y
.a8aa	c8		iny				iny
.a8ab	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth
.a8ae	d0 f5		bne $a8a5			bne 	_EILScrapeLine
.a8b0					_EILTrimSpaces:
.a8b0	88		dey				dey
.a8b1	f0 08		beq $a8bb			beq 	_EILEndTrim
.a8b3	b9 2a 05	lda $052a,y			lda 	lineBuffer,y
.a8b6	c9 20		cmp #$20			cmp 	#' '
.a8b8	f0 f6		beq $a8b0			beq 	_EILTrimSpaces
.a8ba	c8		iny				iny 								; trim after non space character.
.a8bb					_EILEndTrim:
.a8bb	a9 00		lda #$00			lda 	#0 							; trim here.
.a8bd	99 2a 05	sta $052a,y			sta 	lineBuffer,y
.a8c0	a9 0d		lda #$0d			lda 	#13 						; echo the RETURN
.a8c2	20 c4 a6	jsr $a6c4			jsr 	ExtPrintCharacter
.a8c5	68		pla				pla 								; reset I/O page
.a8c6	85 01		sta $01				sta 	1
.a8c8	7a		ply				ply
.a8c9	fa		plx				plx
.a8ca	68		pla				pla
.a8cb	60		rts				rts
.a8cc					EXTILDelete:
.a8cc	48		pha				pha 								; save the new character
.a8cd	ac c1 05	ldy $05c1			ldy 	EXTColumn 					; start copying from here.
.a8d0					_EXTDLoop:
.a8d0	c8		iny				iny 								; copy one byte down.
.a8d1	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a8d3	88		dey				dey
.a8d4	91 40		sta ($40),y			sta 	(EXTAddress),y
.a8d6	c8		iny				iny 								; do till end of line.
.a8d7	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth
.a8da	90 f4		bcc $a8d0			bcc 	_EXTDLoop
.a8dc	88		dey				dey 	 							; write in last slot.
.a8dd	68		pla				pla
.a8de	91 40		sta ($40),y			sta 	(EXTAddress),y
.a8e0	60		rts				rts
.a8e1					EXTILInsert:
.a8e1	ac c3 05	ldy $05c3			ldy 	EXTScreenWidth 				; end position
.a8e4					_EXTILoop:
.a8e4	88		dey				dey 								; back one
.a8e5	cc c1 05	cpy $05c1			cpy 	EXTColumn 					; exit if reached insert point.
.a8e8	f0 08		beq $a8f2			beq 	_EXTIExit
.a8ea	88		dey				dey 								; copy one byte up.
.a8eb	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a8ed	c8		iny				iny
.a8ee	91 40		sta ($40),y			sta 	(EXTAddress),y
.a8f0	80 f2		bra $a8e4			bra 	_EXTILoop
.a8f2					_EXTIExit:
.a8f2	60		rts				rts
.a8f3					EXTScrollFill:
.a8f3	aa		tax				tax									; save value to fill with
.a8f4	a5 36		lda $36				lda 	zTemp0 						; save zTemp0 (dest) zTemp1 (src)
.a8f6	48		pha				pha
.a8f7	a5 37		lda $37				lda 	zTemp0+1
.a8f9	48		pha				pha
.a8fa	a5 38		lda $38				lda 	zTemp1
.a8fc	48		pha				pha
.a8fd	a5 39		lda $39				lda 	zTemp1+1
.a8ff	48		pha				pha
.a900	a9 c0		lda #$c0			lda 	#$C0 						; copy from C000+length to C000
.a902	85 37		sta $37				sta 	zTemp0+1
.a904	85 39		sta $39				sta 	zTemp1+1
.a906	64 36		stz $36				stz 	zTemp0
.a908	ad c3 05	lda $05c3			lda 	EXTScreenWidth
.a90b	85 38		sta $38				sta 	zTemp1
.a90d	a0 00		ldy #$00			ldy 	#0
.a90f					_EXSFCopy1:
.a90f	b1 38		lda ($38),y			lda 	(zTemp1),y
.a911	91 36		sta ($36),y			sta 	(zTemp0),y
.a913	c8		iny				iny
.a914	d0 f9		bne $a90f			bne 	_EXSFCopy1
.a916	e6 37		inc $37				inc 	zTemp0+1 					; next page
.a918	e6 39		inc $39				inc 	zTemp1+1
.a91a	a5 39		lda $39				lda 	zTemp1+1
.a91c	c9 d3		cmp #$d3			cmp 	#$D3
.a91e	d0 ef		bne $a90f			bne 	_EXSFCopy1
.a920	ac c3 05	ldy $05c3			ldy 	EXTScreenWidth 				; blank the bottom line.
.a923	8a		txa				txa
.a924					_EXSFFill1:
.a924	88		dey				dey
.a925	91 40		sta ($40),y			sta 	(EXTAddress),y
.a927	c0 00		cpy #$00			cpy 	#0
.a929	10 f9		bpl $a924			bpl 	_EXSFFill1
.a92b	68		pla				pla
.a92c	85 39		sta $39				sta 	zTemp1+1
.a92e	68		pla				pla
.a92f	85 38		sta $38				sta 	zTemp1
.a931	68		pla				pla
.a932	85 37		sta $37				sta 	zTemp0+1
.a934	68		pla				pla
.a935	85 36		sta $36				sta 	zTemp0
.a937	60		rts				rts
=$c000					EXTMemory = $C000
=$02					EXTTextPage = $02
=$03					EXTColourPage = $03
=1					EXTDummySpace = 1 							; fake-space for CR character.
=0					EXTCBlack = 0
.05c0					EXTRow:
>05c0							.fill 	1
.05c1					EXTColumn:
>05c1							.fill 	1
.05c2					EXTTextColour:
>05c2							.fill 	1
.05c3					EXTScreenWidth:
>05c3							.fill 	1
.05c4					EXTScreenHeight:
>05c4							.fill 	1
.0040					EXTAddress:
>0040							.fill 	2
.a938					EXTInitialise:
.a938	64 01		stz $01				stz 	1 							; Access I/O
.a93a	9c 04 d0	stz $d004			stz 	$D004 						; Disable border
.a93d	9c 08 d0	stz $d008			stz 	$D008
.a940	9c 09 d0	stz $d009			stz 	$D009
.a943	a9 09		lda #$09			lda 	#1+8						; Timer On at 70Hz counting up.
.a945	8d 58 d6	sta $d658			sta 	$D658
.a948	a9 76		lda #$76			lda 	#CONForeground * 16 + CONBackground
.a94a	8d c2 05	sta $05c2			sta 	EXTTextColour
.a94d	a9 50		lda #$50			lda 	#80 						; set screen dimensions.
.a94f	8d c3 05	sta $05c3			sta 	EXTScreenWidth
.a952	a9 3c		lda #$3c			lda 	#60
.a954	8d c4 05	sta $05c4			sta 	EXTScreenHeight
.a957	64 01		stz $01				stz 	1
.a959	60		rts				rts
.a95a					EXTInputSingleCharacter:
.a95a	da		phx				phx
.a95b	5a		phy				phy
.a95c					_EISCWait:
.a95c	64 01		stz $01				stz 	1 							; access I/O Page 0
.a95e	38		sec				sec 								; calculate timer - LastTick
.a95f	ad 59 d6	lda $d659			lda 	$D659
.a962	aa		tax				tax 								; saving timer in X
.a963	ed af 05	sbc $05af			sbc 	LastTick
.a966	c9 03		cmp #$03			cmp 	#3
.a968	90 06		bcc $a970			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.a96a	8e af 05	stx $05af			stx 	LastTick 					; update last timer
.a96d	20 10 b9	jsr $b910			jsr 	TickHandler 				; go do the code.
.a970					_NoFireTick:
.a970	20 e4 ff	jsr $ffe4			jsr 	$FFE4
.a973	c9 00		cmp #$00			cmp 	#0
.a975	f0 e5		beq $a95c			beq 	_EISCWait
.a977	7a		ply				ply
.a978	fa		plx				plx
.a979	60		rts				rts
.a97a					EXTBreakCheck:
.a97a	4c e1 ff	jmp $ffe1			jmp		$FFE1
.a97d					EXTReadController:
.a97d	da		phx				phx
.a97e	a2 00		ldx #$00			ldx 	#0
.a980	a9 05		lda #$05			lda 	#(($2D) >> 3)
.a982	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.a985	29 20		and #$20			and 	#($01 << (($2D) & 7))
.a987	f0 04		beq $a98d			beq 	_NoSet1
.a989	8a		txa				txa
.a98a	09 01		ora #$01			ora 	#1
.a98c	aa		tax				tax
.a98d					_NoSet1:
.a98d	a9 05		lda #$05			lda 	#(($2C) >> 3)
.a98f	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.a992	29 10		and #$10			and 	#($01 << (($2C) & 7))
.a994	f0 04		beq $a99a			beq 	_NoSet1
.a996	8a		txa				txa
.a997	09 02		ora #$02			ora 	#2
.a999	aa		tax				tax
.a99a					_NoSet1:
.a99a	a9 06		lda #$06			lda 	#(($32) >> 3)
.a99c	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.a99f	29 04		and #$04			and 	#($01 << (($32) & 7))
.a9a1	f0 04		beq $a9a7			beq 	_NoSet1
.a9a3	8a		txa				txa
.a9a4	09 04		ora #$04			ora 	#4
.a9a6	aa		tax				tax
.a9a7					_NoSet1:
.a9a7	a9 04		lda #$04			lda 	#(($25) >> 3)
.a9a9	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.a9ac	29 20		and #$20			and 	#($01 << (($25) & 7))
.a9ae	f0 04		beq $a9b4			beq 	_NoSet1
.a9b0	8a		txa				txa
.a9b1	09 08		ora #$08			ora 	#8
.a9b3	aa		tax				tax
.a9b4					_NoSet1:
.a9b4	a9 04		lda #$04			lda 	#(($26) >> 3)
.a9b6	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.a9b9	29 40		and #$40			and 	#($01 << (($26) & 7))
.a9bb	f0 04		beq $a9c1			beq 	_NoSet1
.a9bd	8a		txa				txa
.a9be	09 10		ora #$10			ora 	#16
.a9c0	aa		tax				tax
.a9c1					_NoSet1:
.a9c1	8a		txa				txa
.a9c2	fa		plx				plx
.a9c3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_graphics.module

=1					graphicsIntegrated=1
=0					GCMD_Initialise = 0*2
=2					GCMD_BitmapCtl = 1*2
=4					GCMD_SpriteCtl = 2*2
=6					GCMD_Clear = 3*2
=8					GCMD_Colour = 4*2
=10					GCMD_DrawFont = 5*2
=12					GCMD_DrawSprite = 6*2
=14					GCMD_SpriteUse = 7*2
=16					GCMD_SpriteImage = 8*2
=18					GCMD_SpriteCollide = 9*2
=64					GCMD_Move = 32*2
=66					GCMD_Line = 33*2
=68					GCMD_FrameRect = 34*2
=70					GCMD_FillRect = 35*2
=72					GCMD_FrameCircle = 36*2
=74					GCMD_FillCircle = 37*2
=80					GCMD_Plot = 40*2
=82					GCMD_SpriteMove = 41*2
=42					GRFirstFreeCode = 42
.b916					GRVectorTable:
>b916	bf ab					.word	GXInitialise             ; $00 Initialise
>b918	d9 ab					.word	GXControlBitmap          ; $01 BitmapCtl
>b91a	21 ac					.word	GXControlSprite          ; $02 SpriteCtl
>b91c	71 ab					.word	GXClearBitmap            ; $03 Clear
>b91e	b0 ad					.word	GXSetColourMode          ; $04 Colour
>b920	78 af					.word	GXFontHandler            ; $05 DrawFont
>b922	c0 af					.word	GXSpriteHandler          ; $06 DrawSprite
>b924	2c b0					.word	GXSelect                 ; $07 SpriteUse
>b926	55 b0					.word	GXSelectImage            ; $08 SpriteImage
>b928	dc b1					.word	GXCollide                ; $09 SpriteCollide
>b92a	23 aa					.word	GRUndefined              ; $0a
>b92c	23 aa					.word	GRUndefined              ; $0b
>b92e	23 aa					.word	GRUndefined              ; $0c
>b930	23 aa					.word	GRUndefined              ; $0d
>b932	23 aa					.word	GRUndefined              ; $0e
>b934	23 aa					.word	GRUndefined              ; $0f
>b936	23 aa					.word	GRUndefined              ; $10
>b938	23 aa					.word	GRUndefined              ; $11
>b93a	23 aa					.word	GRUndefined              ; $12
>b93c	23 aa					.word	GRUndefined              ; $13
>b93e	23 aa					.word	GRUndefined              ; $14
>b940	23 aa					.word	GRUndefined              ; $15
>b942	23 aa					.word	GRUndefined              ; $16
>b944	23 aa					.word	GRUndefined              ; $17
>b946	23 aa					.word	GRUndefined              ; $18
>b948	23 aa					.word	GRUndefined              ; $19
>b94a	23 aa					.word	GRUndefined              ; $1a
>b94c	23 aa					.word	GRUndefined              ; $1b
>b94e	23 aa					.word	GRUndefined              ; $1c
>b950	23 aa					.word	GRUndefined              ; $1d
>b952	23 aa					.word	GRUndefined              ; $1e
>b954	23 aa					.word	GRUndefined              ; $1f
>b956	21 aa					.word	GXMove                   ; $20 Move
>b958	7e ac					.word	GXLine                   ; $21 Line
>b95a	f9 ad					.word	GXFrameRectangle         ; $22 FrameRect
>b95c	f6 ad					.word	GXFillRectangle          ; $23 FillRect
>b95e	28 aa					.word	GXFrameCircle            ; $24 FrameCircle
>b960	24 aa					.word	GXFillCircle             ; $25 FillCircle
>b962	23 aa					.word	GRUndefined              ; $26
>b964	23 aa					.word	GRUndefined              ; $27
>b966	de ad					.word	GXPlotPoint              ; $28 Plot
>b968	eb b0					.word	GXMoveSprite             ; $29 SpriteMove
=3					GXMappingPage = 3
=24576					GXMappingAddress = ($2000 * GXMappingPage)
=11					GXEditSlot = 8 + GXMappingPage
=$36					gxzTemp0 = zTemp0
=$38					gxzTemp1 = zTemp1
=$3a					gxzTemp2 = zTemp2
=$3c					gxzScreen = zsTemp
=$57b					gxPixelBuffer = numberBuffer
.05c5					gxCurrentX:
>05c5							.fill 	2
.05c7					gxCurrentY:
>05c7							.fill 	2
.05c9					gxLastX:
>05c9							.fill 	2
.05cb					gxLastY:
>05cb							.fill 	2
.05cd					gxX0:
>05cd							.fill 	2
.05cf					gxY0:
>05cf							.fill 	2
.05d1					gxX1:
>05d1							.fill 	2
.05d3					gxY1:
>05d3							.fill 	2
.05d5					gxSpritesOn:
>05d5							.fill 	1
.05d6					gxBitmapsOn:
>05d6							.fill 	1
.05d7					gxBasePage:
>05d7							.fill 	1
.05d8					gxSpritePage:
>05d8							.fill 	1
.05d9					gxHeight:
>05d9							.fill 	1
.05da					gxMode:
>05da							.fill 	1
.05db					gxColour:
>05db							.fill 	1
.05dc					gxEORValue:
>05dc							.fill 	1
.05dd					gxANDValue:
>05dd							.fill 	1
.05de					gxOriginalLUTValue:
>05de							.fill 	1
.05df					gsOffset:
>05df							.fill 	1
.05e0					GSCurrentSpriteID:
>05e0							.fill 	1
.05e1					GSCurrentSpriteAddr:
>05e1							.fill 	2
.05e3					GXSpriteOffsetBase:
>05e3							.fill 	2
.05e5					GXSpriteLow:
>05e5							.fill 	64
.0625					GXSpriteHigh:
>0625							.fill 	64
.a9c4					GXGraphicDraw:
.a9c4	c9 40		cmp #$40			cmp 	#GCMD_Move					; low instructions don't use coordinates
.a9c6	b0 06		bcs $a9ce			bcs 	_GDCoordinate
.a9c8	86 36		stx $36				stx 	gxzTemp0 					; save X/Y
.a9ca	84 37		sty $37				sty 	gxzTemp0+1
.a9cc	80 4b		bra $aa19			bra 	_GDExecuteA 				; and execute
.a9ce					_GDCoordinate:
.a9ce	48		pha				pha 								; save AXY
.a9cf	da		phx				phx
.a9d0	5a		phy				phy
.a9d1	a2 03		ldx #$03			ldx 	#3 							; copy currentX to lastX
.a9d3					_GDCopy1:
.a9d3	bd c5 05	lda $05c5,x			lda 	gxCurrentX,x
.a9d6	9d c9 05	sta $05c9,x			sta 	gxLastX,x
.a9d9	ca		dex				dex
.a9da	10 f7		bpl $a9d3			bpl 	_GDCopy1
.a9dc	68		pla				pla 								; update Y
.a9dd	8d c7 05	sta $05c7			sta 	gxCurrentY
.a9e0	9c c8 05	stz $05c8			stz 	gxCurrentY+1
.a9e3	68		pla				pla
.a9e4	8d c5 05	sta $05c5			sta 	gxCurrentX
.a9e7	68		pla				pla 								; get A (command+X.1) back
.a9e8	48		pha				pha
.a9e9	29 01		and #$01			and 	#1 							; put LSB as MSB of Current.X
.a9eb	8d c6 05	sta $05c6			sta 	gxCurrentX+1
.a9ee	68		pla				pla 								; get command back
.a9ef	29 fe		and #$fe			and 	#$FE 						; lose LSB, chuck the stray X bit
.a9f1	48		pha				pha 								; push back.
.a9f2	c9 52		cmp #$52			cmp 	#GCMD_SpriteMove 			; move sprite does not clip.
.a9f4	f0 17		beq $aa0d			beq 	_GDCopyToWorkArea
.a9f6	ad c6 05	lda $05c6			lda 	gxCurrentX+1 				; X < 256 X okay
.a9f9	f0 07		beq $aa02			beq 	_GDCheckY
.a9fb	ad c5 05	lda $05c5			lda 	gxCurrentX 					; otherwise X < 320 = 256 + 64
.a9fe	c9 40		cmp #$40			cmp 	#64
.aa00	b0 08		bcs $aa0a			bcs 	_GDError1
.aa02					_GDCheckY:
.aa02	ad c7 05	lda $05c7			lda 	gxCurrentY 					; check Y < Height.
.aa05	cd d9 05	cmp $05d9			cmp 	gxHeight
.aa08	90 03		bcc $aa0d			bcc 	_GDCopyToWorkArea
.aa0a					_GDError1:
.aa0a	68		pla				pla
.aa0b					_GDError2:
.aa0b	38		sec				sec
.aa0c	60		rts				rts
.aa0d					_GDCopyToWorkArea:
.aa0d	a2 07		ldx #$07			ldx 	#7 							; copy current and last to gxXY/12 work area
.aa0f					_GDCopy2:
.aa0f	bd c5 05	lda $05c5,x			lda 	gxCurrentX,x
.aa12	9d cd 05	sta $05cd,x			sta 	gxX0,x
.aa15	ca		dex				dex
.aa16	10 f7		bpl $aa0f			bpl 	_GDCopy2
.aa18	68		pla				pla 								; get command
.aa19					_GDExecuteA:
.aa19	c9 54		cmp #$54			cmp 	#GRFirstFreeCode*2 			; bad ?
.aa1b	b0 ee		bcs $aa0b			bcs 	_GDError2
.aa1d	aa		tax				tax
.aa1e	7c 16 b9	jmp ($b916,x)			jmp 	(GRVectorTable,x)
.aa21					GXMove:
.aa21	18		clc				clc
.aa22	60		rts				rts
.aa23					GRUndefined:
>aa23	db						.byte 	$DB 						; causes a break in the emulator
.aa24					GXFillCircle:
.aa24	a9 ff		lda #$ff			lda 	#255
.aa26	80 02		bra $aa2a			bra 	GXCircle
.aa28					GXFrameCircle:
.aa28	a9 00		lda #$00			lda 	#0
.aa2a					GXCircle:
.aa2a	8d 68 06	sta $0668			sta 	gxIsFillMode					; save Fill flag
.aa2d	ad d6 05	lda $05d6			lda 	gxBitmapsOn
.aa30	f0 26		beq $aa58			beq 	_GXCFail
.aa32	20 83 b2	jsr $b283			jsr 	GXSortXY 					; topleft/bottomright
.aa35	20 5b b1	jsr $b15b			jsr 	GXOpenBitmap 				; start drawing
.aa38	20 2a ab	jsr $ab2a			jsr 	GXCircleSetup 				; set up for drawing
.aa3b	9c 69 06	stz $0669			stz 	gxYChanged
.aa3e					_GXCircleDraw:
.aa3e	ad 66 06	lda $0666			lda 	gXCentre					; while x <= y
.aa41	cd 67 06	cmp $0667			cmp 	gYCentre
.aa44	90 0a		bcc $aa50			bcc 	_GXCircleContinue
.aa46	d0 03		bne $aa4b			bne 	_GXNoLast
.aa48	20 5d aa	jsr $aa5d			jsr 	GXPlot1
.aa4b					_GXNoLast:
.aa4b	20 63 b1	jsr $b163			jsr 	GXCloseBitmap 				; close the bitmap
.aa4e	18		clc				clc
.aa4f	60		rts				rts
.aa50					_GXCircleContinue:
.aa50	20 5a aa	jsr $aa5a			jsr 	GXPlot2 					; draw it
.aa53	20 d7 aa	jsr $aad7			jsr 	GXCircleMove 				; adjust the coordinates
.aa56	80 e6		bra $aa3e			bra 	_GXCircleDraw
.aa58					_GXCFail:
.aa58	38		sec				sec
.aa59	60		rts				rts
.aa5a					GXPlot2:
.aa5a	20 5d aa	jsr $aa5d			jsr 	GXPlot1 						; plot and swap, fall through does twice
.aa5d					GXPlot1:
.aa5d	ad 67 06	lda $0667			lda 	gYCentre 						; if y = 0, don't do it twice (xor)
.aa60	f0 03		beq $aa65			beq 	_GXPlot1Only
.aa62	20 81 aa	jsr $aa81			jsr 	GXPlot0 						; plot and negate
.aa65					_GXPlot1Only:
.aa65	20 81 aa	jsr $aa81			jsr 	GXPlot0 						; twice, undoing negation
.aa68	ad 66 06	lda $0666			lda 	gXCentre 						; swap X and Y
.aa6b	ae 67 06	ldx $0667			ldx	 	gYCentre
.aa6e	8d 67 06	sta $0667			sta 	gYCentre
.aa71	8e 66 06	stx $0666			stx 	gXCentre
.aa74	ad 69 06	lda $0669			lda 	gxYChanged 						; toggle Y Changed flag
.aa77	a9 ff		lda #$ff			lda 	#$FF
.aa79	8d 69 06	sta $0669			sta 	gxYChanged
.aa7c	60		rts				rts
.aa7d	20 81 aa	jsr $aa81			jsr 	GXPlot0 						; do once
.aa80	60		rts				rts
.aa81	ad 68 06	lda $0668	GXPlot0:lda 	gxIsFillMode 					; outline mode, always draw as X or Y will change
.aa84	f0 05		beq $aa8b			beq 	_GXPlot0Always
.aa86	ad 69 06	lda $0669			lda 	gxYChanged						; fill mode, only draw if changed.
.aa89	f0 2d		beq $aab8			beq 	GXPlot0Exit
.aa8b					_GXPlot0Always:
.aa8b	a2 02		ldx #$02			ldx 	#2 								; copy Y1-A => Y0
.aa8d	ad 67 06	lda $0667			lda 	gYCentre
.aa90	20 b9 aa	jsr $aab9			jsr 	GXSubCopy
.aa93	a2 00		ldx #$00			ldx 	#0 								; copy X1-A => X0,
.aa95	ad 66 06	lda $0666			lda 	gXCentre
.aa98	20 b9 aa	jsr $aab9			jsr 	GXSubCopy
.aa9b	48		pha				pha 									; save last offset X
.aa9c	20 6b b1	jsr $b16b			jsr 	GXPositionCalc 					; calculate position/offset.
.aa9f	68		pla				pla
.aaa0	0a		asl a				asl 	a 								; store 2 x last offset in gxzTemp0
.aaa1	85 36		sta $36				sta 	gxzTemp0
.aaa3	64 37		stz $37				stz 	gxzTemp0+1
.aaa5	26 37		rol $37				rol 	gxzTemp0+1
.aaa7	ad 68 06	lda $0668			lda 	gxIsFillMode
.aaaa	69 80		adc #$80			adc 	#128
.aaac	20 49 ae	jsr $ae49			jsr 	GXDrawLineTemp0 				; routine from Rectangle.
.aaaf	38		sec				sec 									; GY = -GY
.aab0	a9 00		lda #$00			lda 	#0
.aab2	ed 67 06	sbc $0667			sbc 	gYCentre
.aab5	8d 67 06	sta $0667			sta 	gYCentre
.aab8					GXPlot0Exit:
.aab8	60		rts				rts
.aab9					GXSubCopy:
.aab9	85 36		sta $36				sta 	gxzTemp0
.aabb	64 37		stz $37				stz 	gxzTemp0+1
.aabd	29 80		and #$80			and 	#$80
.aabf	f0 02		beq $aac3			beq 	_GXNoSx
.aac1	c6 37		dec $37				dec 	gxzTemp0+1
.aac3					_GXNoSx:
.aac3	38		sec				sec
.aac4	bd d1 05	lda $05d1,x			lda 	gXX1,x
.aac7	e5 36		sbc $36				sbc 	gxzTemp0
.aac9	9d cd 05	sta $05cd,x			sta 	gXX0,x
.aacc	bd d2 05	lda $05d2,x			lda 	gXX1+1,x
.aacf	e5 37		sbc $37				sbc 	gxzTemp0+1
.aad1	9d ce 05	sta $05ce,x			sta 	gXX0+1,x
.aad4	a5 36		lda $36				lda 	gxzTemp0 						; return A
.aad6	60		rts				rts
.aad7					GXCircleMove:
.aad7	9c 69 06	stz $0669			stz 	gxYChanged 					; clear Y changed flag
.aada	a5 39		lda $39				lda 	gxzTemp1+1 					; check sign of D
.aadc	10 0d		bpl $aaeb			bpl 	_GXEMPositive
.aade	ee 66 06	inc $0666			inc 	gXCentre 					; X++
.aae1	ad 66 06	lda $0666			lda 	gXCentre
.aae4	20 0a ab	jsr $ab0a			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.aae7	a9 06		lda #$06			lda 	#6  						; and add 6
.aae9	80 15		bra $ab00			bra 	_GXEMAddD
.aaeb					_GXEMPositive:
.aaeb	ee 66 06	inc $0666			inc 	gXCentre					; X++
.aaee	ce 67 06	dec $0667			dec 	gyCentre 					; Y--
.aaf1	38		sec				sec 								; calculate X-Y
.aaf2	ad 66 06	lda $0666			lda 	gXCentre
.aaf5	ed 67 06	sbc $0667			sbc 	gYCentre
.aaf8	20 0a ab	jsr $ab0a			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.aafb	a9 0a		lda #$0a			lda 	#10  						; and add 10
.aafd	ce 69 06	dec $0669			dec 	gxYChanged
.ab00					_GXEMAddD:
.ab00	18		clc				clc
.ab01	65 38		adc $38				adc 	gxzTemp1
.ab03	85 38		sta $38				sta 	gxzTemp1
.ab05	90 02		bcc $ab09			bcc 	_GXEMNoCarry
.ab07	e6 39		inc $39				inc 	gxzTemp1+1
.ab09					_GXEMNoCarry:
.ab09	60		rts				rts
.ab0a					_GXAdd4TimesToD:
.ab0a	85 36		sta $36				sta 	gxzTemp0 					; make 16 bit signed.
.ab0c	29 80		and #$80			and 	#$80
.ab0e	f0 02		beq $ab12			beq 	_GXA4Unsigned
.ab10	a9 ff		lda #$ff			lda 	#$FF
.ab12					_GXA4Unsigned:
.ab12	85 37		sta $37				sta 	gxzTemp0+1
.ab14	06 36		asl $36				asl 	gxzTemp0  					; x 4
.ab16	26 37		rol $37				rol 	gxzTemp0+1
.ab18	06 36		asl $36				asl 	gxzTemp0
.ab1a	26 37		rol $37				rol 	gxzTemp0+1
.ab1c	18		clc				clc 								; add
.ab1d	a5 36		lda $36				lda		gxzTemp0
.ab1f	65 38		adc $38				adc 	gxzTemp1
.ab21	85 38		sta $38				sta 	gxzTemp1
.ab23	a5 37		lda $37				lda		gxzTemp0+1
.ab25	65 39		adc $39				adc 	gxzTemp1+1
.ab27	85 39		sta $39				sta 	gxzTemp1+1
.ab29	60		rts				rts
.ab2a					GXCircleSetup:
.ab2a	38		sec				sec
.ab2b	ad d3 05	lda $05d3			lda 	gxY1
.ab2e	ed cf 05	sbc $05cf			sbc 	gxY0
.ab31	4a		lsr a				lsr 	a
.ab32	8d 65 06	sta $0665			sta 	gxRadius
.ab35	a2 00		ldx #$00			ldx 	#0
.ab37	20 59 ab	jsr $ab59			jsr 	_GXCalculateCentre
.ab3a	a2 02		ldx #$02			ldx 	#2
.ab3c	20 59 ab	jsr $ab59			jsr 	_GXCalculateCentre
.ab3f	9c 66 06	stz $0666			stz 	gXCentre
.ab42	ad 65 06	lda $0665			lda 	gxRadius
.ab45	8d 67 06	sta $0667			sta 	gYCentre
.ab48	0a		asl a				asl 	a 							; R x 2
.ab49	85 36		sta $36				sta 	gxzTemp0
.ab4b	38		sec				sec
.ab4c	a9 03		lda #$03			lda 	#3
.ab4e	e5 36		sbc $36				sbc 	gxzTemp0
.ab50	85 38		sta $38				sta 	gxzTemp1
.ab52	a9 00		lda #$00			lda 	#0
.ab54	e9 00		sbc #$00			sbc 	#0
.ab56	85 39		sta $39				sta 	gxzTemp1+1
.ab58	60		rts				rts
.ab59					_GXCalculateCentre:
.ab59	38		sec				sec
.ab5a	bd d1 05	lda $05d1,x			lda 	gxX1,x
.ab5d	7d cd 05	adc $05cd,x			adc 	gXX0,x
.ab60	9d d1 05	sta $05d1,x			sta 	gXX1,x
.ab63	bd d2 05	lda $05d2,x			lda 	gXX1+1,x
.ab66	7d ce 05	adc $05ce,x			adc 	gXX0+1,x
.ab69	4a		lsr a				lsr 	a
.ab6a	9d d2 05	sta $05d2,x			sta 	gXX1+1,x
.ab6d	7e d1 05	ror $05d1,x			ror 	gXX1,x
.ab70	60		rts				rts
.0665					gxRadius:
>0665							.fill 	1
.0666					gXCentre:
>0666							.fill 	1
.0667					gYCentre:
>0667							.fill 	1
.0668					gxIsFillMode:
>0668							.fill 	1
.0669					gxYChanged:
>0669							.fill  	1
=64000					ScreenSize200 = 320 * 200
=76800					ScreenSize240 = 320 * 240
.ab71					GXClearBitmap:
.ab71	ad d6 05	lda $05d6			lda 	gxBitmapsOn 				; check BMP running.
.ab74	f0 24		beq $ab9a			beq 	_GXCBFail
.ab76	20 5b b1	jsr $b15b			jsr 	GXOpenBitmap 				; start access
.ab79	a0 07		ldy #$07			ldy 	#ScreenSize200 / 8192 		; X is pages to clear
.ab7b	ad d9 05	lda $05d9			lda 	gxHeight
.ab7e	c9 c8		cmp #$c8			cmp 	#200 						; 200 ?
.ab80	a0 09		ldy #$09			ldy 	#ScreenSize240 / 8192
.ab82					_GXCalcLastPage:
.ab82	98		tya				tya 								; add to base page
.ab83	18		clc				clc
.ab84	6d d7 05	adc $05d7			adc 	gxBasePage
.ab87	85 0b		sta $0b				sta 	GXEditSlot  				; clear from this page back
.ab89					_GXClearAll:
.ab89	20 9c ab	jsr $ab9c			jsr 	_GXClearBlock 				; clear 8k block
.ab8c	c6 0b		dec $0b				dec 	GXEditSlot  				; back to previous
.ab8e	a5 0b		lda $0b				lda 	GXEditSlot
.ab90	cd d7 05	cmp $05d7			cmp 	gxBasePage 					; until before base page
.ab93	b0 f4		bcs $ab89			bcs 	_GXClearAll
.ab95	20 63 b1	jsr $b163			jsr 	GXCloseBitmap	 			; stop access
.ab98	18		clc				clc
.ab99	60		rts				rts
.ab9a					_GXCBFail:
.ab9a	38		sec				sec
.ab9b	60		rts				rts
.ab9c					_GXClearBlock:
.ab9c	a9 00		lda #$00			lda 	#((GXMappingAddress) & $FF)
.ab9e	85 38		sta $38				sta 	0+gxzTemp1
.aba0	a9 60		lda #$60			lda 	#((GXMappingAddress) >> 8)
.aba2	85 39		sta $39				sta 	1+gxzTemp1
.aba4					_GXCB0:
.aba4	a5 36		lda $36				lda 	gxzTemp0
.aba6	a0 00		ldy #$00			ldy 	#0
.aba8					_GXCB1:
.aba8	91 38		sta ($38),y			sta 	(gxzTemp1),y
.abaa	c8		iny				iny
.abab	91 38		sta ($38),y			sta 	(gxzTemp1),y
.abad	c8		iny				iny
.abae	91 38		sta ($38),y			sta 	(gxzTemp1),y
.abb0	c8		iny				iny
.abb1	91 38		sta ($38),y			sta 	(gxzTemp1),y
.abb3	c8		iny				iny
.abb4	d0 f2		bne $aba8			bne 	_GXCB1
.abb6	e6 39		inc $39				inc 	gxzTemp1+1
.abb8	a5 39		lda $39				lda 	gxzTemp1+1
.abba	c9 80		cmp #$80			cmp	 	#(GXMappingAddress >> 8)+$20
.abbc	d0 e6		bne $aba4			bne 	_GXCB0
.abbe	60		rts				rts
.abbf					GXInitialise:
.abbf	64 01		stz $01				stz 	1
.abc1	a9 01		lda #$01			lda 	#1
.abc3	8d 00 d0	sta $d000			sta 	$D000
.abc6	18		clc				clc
.abc7	9c d5 05	stz $05d5			stz 	GXSpritesOn
.abca	9c d6 05	stz $05d6			stz 	GXBitmapsOn
.abcd	a2 0f		ldx #$0f			ldx 	#15
.abcf					_GXIClear:
.abcf	9e c5 05	stz $05c5,x			stz 	gxCurrentX,x
.abd2	ca		dex				dex
.abd3	10 fa		bpl $abcf			bpl 	_GXIClear
.abd5	20 70 ac	jsr $ac70			jsr 	GXClearSpriteStore
.abd8	60		rts				rts
.abd9					GXControlBitmap:
.abd9	64 01		stz $01				stz 	1
.abdb	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.abdd	29 01		and #$01			and 	#1 							; set bitmap flag
.abdf	8d d6 05	sta $05d6			sta 	gxBitmapsOn
.abe2	4a		lsr a				lsr 	a 							; bit 0 into carry.
.abe3	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.abe6	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.abe8	29 f7		and #$f7			and 	#$F7 						; clear bitmap bit
.abea	90 02		bcc $abee			bcc 	_CBNotOn
.abec	09 08		ora #$08			ora 	#$08 						; bitmap on if 1 on 0 off
.abee					_CBNotOn:
.abee	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.abf1	a5 36		lda $36				lda 	gxzTemp0 					; get control settings (bits 0-2)
.abf3	29 07		and #$07			and 	#7
.abf5	8d 00 d1	sta $d100			sta 	$D100 						; write in Vicky Bitmap Control Register #0
.abf8	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.abfa	d0 02		bne $abfe			bne 	_CBNotDefault
.abfc	a9 08		lda #$08			lda 	#8  						; if zero, use 8 e.g. bitmap at $10000
.abfe					_CBNotDefault:
.abfe	8d d7 05	sta $05d7			sta 	gxBasePage
.ac01	20 62 ac	jsr $ac62			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.ac04	a5 37		lda $37				lda 	gxzTemp0+1 					; copy address into Bitmap address registers
.ac06	8d 03 d1	sta $d103			sta 	$D103
.ac09	a5 36		lda $36				lda 	gxzTemp0
.ac0b	8d 02 d1	sta $d102			sta 	$D102
.ac0e	9c 01 d1	stz $d101			stz 	$D101
.ac11	a2 f0		ldx #$f0			ldx 	#240 						; height is 240
.ac13	ad 01 d0	lda $d001			lda 	$D001 						; read MCR bit 0
.ac16	29 01		and #$01			and 	#1
.ac18	f0 02		beq $ac1c			beq 	_CBHaveHeight
.ac1a	a2 c8		ldx #$c8			ldx 	#200 						; if bit 0 set 320x200
.ac1c					_CBHaveHeight
.ac1c	8e d9 05	stx $05d9			stx 	gxHeight
.ac1f	18		clc				clc
.ac20	60		rts				rts
.ac21					GXControlSprite:
.ac21	64 01		stz $01				stz 	1
.ac23	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.ac25	29 01		and #$01			and 	#1 							; set sprites flag
.ac27	8d d5 05	sta $05d5			sta 	gxSpritesOn
.ac2a	4a		lsr a				lsr 	a 							; bit 0 into carry.
.ac2b	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.ac2e	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.ac30	29 df		and #$df			and 	#$DF 						; clear sprite bit
.ac32	90 02		bcc $ac36			bcc 	_CSNotOn
.ac34	09 20		ora #$20			ora 	#$20 						; sprite on if 1 on 0 off
.ac36					_CSNotOn:
.ac36	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.ac39	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.ac3b	d0 02		bne $ac3f			bne 	_CSNotDefault
.ac3d	a9 18		lda #$18			lda 	#24  						; if zero, use 24 e.g. sprites at $30000
.ac3f					_CSNotDefault:
.ac3f	8d d8 05	sta $05d8			sta 	gxSpritePage
.ac42	20 62 ac	jsr $ac62			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.ac45	a5 36		lda $36				lda 	zTemp0
.ac47	8d e3 05	sta $05e3			sta 	GXSpriteOffsetBase
.ac4a	a5 37		lda $37				lda 	zTemp0+1
.ac4c	8d e4 05	sta $05e4			sta 	GXSpriteOffsetBase+1
.ac4f	a2 00		ldx #$00			ldx 	#0 							; disable all sprites, clears all sprite memory.
.ac51					_CSClear:
.ac51	9e 00 d9	stz $d900,x			stz 	$D900,x
.ac54	9e 00 da	stz $da00,x			stz 	$DA00,x
.ac57	ca		dex				dex
.ac58	d0 f7		bne $ac51			bne 	_CSClear
.ac5a	9c e2 05	stz $05e2			stz 	GSCurrentSpriteAddr+1 		; no sprite selected.
.ac5d	20 70 ac	jsr $ac70			jsr 	GXClearSpriteStore
.ac60	18		clc				clc
.ac61	60		rts				rts
.ac62					GXCalculateBaseAddress:
.ac62	85 36		sta $36				sta 	gxzTemp0
.ac64	64 37		stz $37				stz 	gxzTemp0+1
.ac66	a9 05		lda #$05			lda 	#5
.ac68					_GXShift:
.ac68	06 36		asl $36				asl 	gxzTemp0
.ac6a	26 37		rol $37				rol 	gxzTemp0+1
.ac6c	3a		dec a				dec		a
.ac6d	d0 f9		bne $ac68			bne 	_GXShift
.ac6f	60		rts				rts
.ac70					GXClearSpriteStore:
.ac70	a2 3f		ldx #$3f			ldx 	#63 						; erase 64 sprite store elements
.ac72					_GXCSSLoop:
.ac72	9e 25 06	stz $0625,x			stz 	GXSpriteHigh,x
.ac75	a9 80		lda #$80			lda 	#$80 						; set the 'hidden' bit.
.ac77	9d e5 05	sta $05e5,x			sta 	GXSpriteLow,x
.ac7a	ca		dex				dex
.ac7b	10 f5		bpl $ac72			bpl 	_GXCSSLoop
.ac7d	60		rts				rts
.ac7e					GXLine:
.ac7e	ad d6 05	lda $05d6			lda 	GXBitmapsOn
.ac81	f0 28		beq $acab			beq 	_GXLFail
.ac83	20 5b b1	jsr $b15b			jsr 	GXOpenBitmap
.ac86	20 a1 b2	jsr $b2a1			jsr 	GXSortY						; sort pairs so Y1 >= Y0 e.g. top to bottom.
.ac89	20 51 ad	jsr $ad51			jsr 	GXLineSetup 				; the calculations in the linescanner constructor
.ac8c	20 6b b1	jsr $b16b			jsr 	GXPositionCalc 				; calculate position/offset.
.ac8f					_GXDrawLoop:
.ac8f	ac df 05	ldy $05df			ldy 	gsOffset 					; draw the pixel
.ac92	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.ac94	2d dd 05	and $05dd			and 	gxANDValue
.ac97	4d dc 05	eor $05dc			eor 	gxEORValue
.ac9a	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.ac9c	20 ad ac	jsr $acad			jsr 	GXLineIsComplete 			; is the line complete ?
.ac9f	f0 05		beq $aca6			beq 	_GXLExit
.aca1	20 c8 ac	jsr $acc8			jsr 	GXLineAdvance 				; code as per advance method
.aca4	80 e9		bra $ac8f			bra 	_GXDrawLoop
.aca6					_GXLExit:
.aca6	20 63 b1	jsr $b163			jsr 	GXCloseBitmap
.aca9	18		clc				clc
.acaa	60		rts				rts
.acab					_GXLFail:
.acab	38		sec				sec
.acac	60		rts				rts
.acad					GXLineIsComplete:
.acad	ad 6c 06	lda $066c			lda 	GXIsDiffYLarger 			; is dy larger
.acb0	d0 0f		bne $acc1			bne 	_GXLICCompareY 				; if so compare Y1/Y0
.acb2	ad cd 05	lda $05cd			lda 	GXX0 						; compare X, LSB and MSB
.acb5	4d d1 05	eor $05d1			eor 	GXX1
.acb8	d0 06		bne $acc0			bne 	_GXLICExit
.acba	ad ce 05	lda $05ce			lda 	GXX0+1
.acbd	4d d2 05	eor $05d2			eor 	GXX1+1
.acc0					_GXLICExit:
.acc0	60		rts				rts
.acc1					_GXLICCompareY:
.acc1	ad d3 05	lda $05d3			lda 	GXY1
.acc4	4d cf 05	eor $05cf			eor 	GXY0
.acc7	60		rts				rts
.acc8					GXLineAdvance:
.acc8	18		clc				clc 								; add adjust to position
.acc9	ad 6e 06	lda $066e			lda 	GXPosition
.accc	6d 6f 06	adc $066f			adc 	GXAdjust
.accf	8d 6e 06	sta $066e			sta 	GXPosition
.acd2	9c 71 06	stz $0671			stz 	GXAddSelect 				; clear add select flag
.acd5	b0 05		bcs $acdc			bcs 	_GXLAOverflow 				; if carry out, overflowed.
.acd7	cd 70 06	cmp $0670			cmp 	GXTotal 					; if exceeded total
.acda	90 0a		bcc $ace6			bcc 	_GXLANoExtra
.acdc					_GXLAOverflow:
.acdc	ce 71 06	dec $0671			dec 	GXAddSelect 				; set addselect to $FF
.acdf	38		sec				sec 								; subtract total and write back
.ace0	ed 70 06	sbc $0670			sbc 	GXTotal
.ace3	8d 6e 06	sta $066e			sta 	GXPosition
.ace6					_GXLANoExtra:
.ace6	ad 6c 06	lda $066c			lda 	GXIsDiffYLarger
.ace9	f0 0d		beq $acf8			beq 	_GXDXLarger
.aceb	20 4a ad	jsr $ad4a			jsr 	GXIncrementY
.acee	ad 71 06	lda $0671			lda 	GXAddSelect
.acf1	f0 10		beq $ad03			beq 	_GXLAExit
.acf3	20 04 ad	jsr $ad04			jsr 	GXAdjustX
.acf6	80 0b		bra $ad03			bra 	_GXLAExit
.acf8					_GXDXLarger:
.acf8	20 04 ad	jsr $ad04			jsr 	GXAdjustX
.acfb	ad 71 06	lda $0671			lda 	GXAddSelect
.acfe	f0 03		beq $ad03			beq 	_GXLAExit
.ad00	20 4a ad	jsr $ad4a			jsr 	GXIncrementY
.ad03					_GXLAExit:
.ad03	60		rts				rts
.ad04					GXAdjustX:
.ad04	ad 6d 06	lda $066d			lda 	GXDXNegative
.ad07	10 25		bpl $ad2e			bpl 	_GXAXRight
.ad09	ad cd 05	lda $05cd			lda 	GXX0
.ad0c	d0 03		bne $ad11			bne 	_GXAXNoBorrow
.ad0e	ce ce 05	dec $05ce			dec 	GXX0+1
.ad11					_GXAXNoBorrow:
.ad11	ce cd 05	dec $05cd			dec 	GXX0
.ad14	ce df 05	dec $05df			dec 	gsOffset 					; pixel left
.ad17	ad df 05	lda $05df			lda 	gsOffset
.ad1a	c9 ff		cmp #$ff			cmp 	#$FF
.ad1c	d0 0f		bne $ad2d			bne 	_GXAYExit 					; underflow
.ad1e	c6 3d		dec $3d				dec 	gxzScreen+1 					; borrow
.ad20	a5 3d		lda $3d				lda 	gxzScreen+1 					; gone off page
.ad22	c9 60		cmp #$60			cmp 	#GXMappingAddress >> 8
.ad24	b0 07		bcs $ad2d			bcs 	_GXAYExit
.ad26	18		clc				clc
.ad27	69 20		adc #$20			adc 	#$20 						; fix up
.ad29	85 3d		sta $3d				sta 	gxzScreen+1
.ad2b	c6 0b		dec $0b				dec 	GXEditSlot 				; back one page
.ad2d					_GXAYExit:
.ad2d	60		rts				rts
.ad2e					_GXAXRight:
.ad2e	ee cd 05	inc $05cd			inc 	GXX0
.ad31	d0 03		bne $ad36			bne 	_GXAXNoCarry
.ad33	ee ce 05	inc $05ce			inc 	GXX0+1
.ad36					_GXAXNoCarry:
.ad36	ee df 05	inc $05df			inc 	gsOffset 					; pixel right
.ad39	d0 0e		bne $ad49			bne 	_GXAXExit 					; if not overflowed, exit.
.ad3b	e6 3d		inc $3d				inc 	gxzScreen+1 					; next line
.ad3d	a5 3d		lda $3d				lda 	gxzScreen+1
.ad3f	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.ad41	90 06		bcc $ad49			bcc 	_GXAXExit
.ad43	e9 20		sbc #$20			sbc 	#$20 						; fix up
.ad45	85 3d		sta $3d				sta 	gxzScreen+1
.ad47	e6 0b		inc $0b				inc 	GXEditSlot 				; next page
.ad49					_GXAXExit:
.ad49	60		rts				rts
.ad4a					GXIncrementY:
.ad4a	ee cf 05	inc $05cf			inc 	GXY0
.ad4d	20 c1 b1	jsr $b1c1			jsr 	GXMovePositionDown
.ad50	60		rts				rts
.ad51					GXLineSetup:
.ad51	ad d3 05	lda $05d3			lda 	GXY1
.ad54	38		sec				sec
.ad55	ed cf 05	sbc $05cf			sbc 	GXY0
.ad58	4a		lsr a				lsr 	a
.ad59	8d 6b 06	sta $066b			sta 	GXDiffY
.ad5c	9c 6d 06	stz $066d			stz 	GXDXNegative 				; clear -ve flag
.ad5f	38		sec				sec
.ad60	ad d1 05	lda $05d1			lda 	GXX1
.ad63	ed cd 05	sbc $05cd			sbc 	GXX0
.ad66	8d 6a 06	sta $066a			sta 	GXDiffX
.ad69	ad d2 05	lda $05d2			lda 	GXX1+1 						; calculate MSB
.ad6c	ed ce 05	sbc $05ce			sbc 	GXX0+1
.ad6f	6a		ror a				ror 	a 							; rotate bit into DiffX halving it
.ad70	6e 6a 06	ror $066a			ror 	GXDiffX
.ad73	0a		asl a				asl 	a
.ad74	10 0c		bpl $ad82			bpl 	_GDXNotNegative
.ad76	a9 00		lda #$00			lda 	#0 							; make absolute value of |dx|
.ad78	38		sec				sec
.ad79	ed 6a 06	sbc $066a			sbc 	GXDiffX
.ad7c	8d 6a 06	sta $066a			sta 	GXDiffX
.ad7f	ce 6d 06	dec $066d			dec 	GXDXNegative 				; -ve flag = $FF.
.ad82					_GDXNotNegative:
.ad82	9c 6c 06	stz $066c			stz 	GXIsDiffYLarger 			; clear larger flag
.ad85	ad 6b 06	lda $066b			lda 	GXDiffY 					; set adjust and total.
.ad88	8d 6f 06	sta $066f			sta 	GXAdjust
.ad8b	ad 6a 06	lda $066a			lda 	GXDiffX
.ad8e	8d 70 06	sta $0670			sta 	GXTotal
.ad91	ad 6b 06	lda $066b			lda 	GXDiffY 					; if dy > dx
.ad94	cd 6a 06	cmp $066a			cmp 	GXDiffX
.ad97	90 0f		bcc $ada8			bcc 	_GDXNotLarger
.ad99	ce 6c 06	dec $066c			dec 	GXIsDiffYLarger 			; set the dy larger flag
.ad9c	ad 6a 06	lda $066a			lda 	GXDiffX 					; set adjust and total other way round
.ad9f	8d 6f 06	sta $066f			sta 	GXAdjust
.ada2	ad 6b 06	lda $066b			lda 	GXDiffY
.ada5	8d 70 06	sta $0670			sta 	GXTotal
.ada8					_GDXNotLarger:
.ada8	ad 70 06	lda $0670			lda 	GXTotal
.adab	4a		lsr a				lsr 	a
.adac	8d 6e 06	sta $066e			sta 	GXPosition
.adaf	60		rts				rts
.066a					GXDiffX:
>066a							.fill 	1
.066b					GXDiffY:
>066b							.fill 	1
.066c					GXIsDiffYLarger:
>066c							.fill 	1
.066d					GXDXNegative:
>066d							.fill 	1
.066e					GXPosition:
>066e							.fill 	1
.066f					GXAdjust:
>066f							.fill 	1
.0670					GXTotal:
>0670							.fill 	1
.0671					GXAddSelect:
>0671							.fill 	1
.adb0					GXSetColourMode:
.adb0	a6 36		ldx $36				ldx 	gxzTemp0
.adb2	8e db 05	stx $05db			stx 	gxColour 								; set colour
.adb5	a5 37		lda $37				lda 	gxzTemp0+1 								;
.adb7	8d da 05	sta $05da			sta 	gxMode 									; set mode
.adba	29 03		and #$03			and 	#3 										; only interested in bits 0-3
.adbc	9c dd 05	stz $05dd			stz 	gxANDValue 								; initially AND with 0, and EOR with Colour
.adbf	ae db 05	ldx $05db			ldx 	gxColour
.adc2	8e dc 05	stx $05dc			stx 	gxEORValue
.adc5	c9 02		cmp #$02			cmp 	#2 										; if mode 2/3 And with colour
.adc7	90 03		bcc $adcc			bcc 	_GXSDCNotAndColour
.adc9	8e dd 05	stx $05dd			stx 	gxANDValue
.adcc					_GXSDCNotAndColour:
.adcc	d0 03		bne $add1			bne 	_GXSDCNotAnd 							; mode 2, Don't EOR with colour
.adce	9c dc 05	stz $05dc			stz 	gxEORValue
.add1					_GXSDCNotAnd:
.add1	4a		lsr a				lsr 	a 										; if bit 0 set, 1's complement AND value
.add2	90 08		bcc $addc			bcc 	_GXSDCNoFlip
.add4	ad dd 05	lda $05dd			lda	 	gxANDValue
.add7	49 ff		eor #$ff			eor 	#$FF
.add9	8d dd 05	sta $05dd			sta 	gxANDValue
.addc					_GXSDCNoFlip:
.addc	18		clc				clc
.addd	60		rts				rts
.adde					GXPlotPoint:
.adde	20 5b b1	jsr $b15b			jsr 	GXOpenBitmap 				; start drawing
.ade1	20 6b b1	jsr $b16b			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.ade4	ac df 05	ldy $05df			ldy 	gsOffset
.ade7	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.ade9	2d dd 05	and $05dd			and 	gxANDValue
.adec	4d dc 05	eor $05dc			eor 	gxEORValue
.adef	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.adf1	20 63 b1	jsr $b163			jsr 	GXCloseBitmap 				; stop drawing and exit
.adf4	18		clc				clc
.adf5	60		rts				rts
.adf6					GXFillRectangle:
.adf6	38		sec				sec
.adf7	80 01		bra $adfa			bra 	GXRectangle
.adf9					GXFrameRectangle:
.adf9	18		clc				clc
.adfa					GXRectangle:
.adfa	ad d6 05	lda $05d6			lda 	gxBitmapsOn
.adfd	f0 35		beq $ae34			beq 	_GXRFail
.adff	08		php				php 								; save Fill flag (CS)
.ae00	20 5b b1	jsr $b15b			jsr 	GXOpenBitmap 				; start drawing
.ae03	20 83 b2	jsr $b283			jsr 	GXSortXY 					; sort both X and Y so top left/bottom right
.ae06	20 6b b1	jsr $b16b			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.ae09	38		sec				sec 								; sec = Draw line
.ae0a	20 36 ae	jsr $ae36			jsr 	GXDrawLineX1X0 				; draw a line length X1-X0
.ae0d	ad cf 05	lda $05cf			lda 	gxY0 						; reached end of rectangle ?
.ae10	cd d3 05	cmp $05d3			cmp 	gxY1
.ae13	f0 19		beq $ae2e			beq 	_GXRectangleExit
.ae15					_GXRectLoop:
.ae15	20 c1 b1	jsr $b1c1			jsr 	GXMovePositionDown 			; down one.
.ae18	ee cf 05	inc $05cf			inc 	gxY0 						; change Y pos
.ae1b	ad cf 05	lda $05cf			lda 	gxY0 						; reached last line
.ae1e	cd d3 05	cmp $05d3			cmp 	gXY1
.ae21	f0 07		beq $ae2a			beq 	_GXLastLine
.ae23	28		plp				plp 								; get flag back
.ae24	08		php				php
.ae25	20 36 ae	jsr $ae36			jsr 	GXDrawLineX1X0 				; draw horizontal line
.ae28	80 eb		bra $ae15			bra 	_GXRectLoop
.ae2a					_GXLastLine:
.ae2a	38		sec				sec
.ae2b	20 36 ae	jsr $ae36			jsr 	GXDrawLineX1X0
.ae2e					_GXRectangleExit:
.ae2e	68		pla				pla 								; throw fill flag.
.ae2f	20 63 b1	jsr $b163			jsr 	GXCloseBitmap 				; stop drawing and exit
.ae32	18		clc				clc
.ae33	60		rts				rts
.ae34					_GXRFail:
.ae34	38		sec				sec
.ae35	60		rts				rts
.ae36					GXDrawLineX1X0:
.ae36	08		php				php 								; save solid/either-end
.ae37	38		sec				sec
.ae38	ad d1 05	lda $05d1			lda		gXX1
.ae3b	ed cd 05	sbc $05cd			sbc 	gXX0
.ae3e	85 36		sta $36				sta 	gxzTemp0
.ae40	ad d2 05	lda $05d2			lda 	gXX1+1
.ae43	ed ce 05	sbc $05ce			sbc 	gXX0+1
.ae46	85 37		sta $37				sta 	gxzTemp0+1
.ae48	28		plp				plp
.ae49					GXDrawLineTemp0:
.ae49	a5 3c		lda $3c				lda 	gxzScreen 						; push gxzScreen, gsOffset and GXEditSlot on stack
.ae4b	48		pha				pha
.ae4c	a5 3d		lda $3d				lda 	gxzScreen+1
.ae4e	48		pha				pha
.ae4f	ad df 05	lda $05df			lda 	gsOffset
.ae52	48		pha				pha
.ae53	a5 0b		lda $0b				lda 	GXEditSlot
.ae55	48		pha				pha
.ae56	ac df 05	ldy $05df			ldy 	gsOffset 					; Y offset
.ae59	90 1e		bcc $ae79			bcc 	_GXDLTEndPoints 			; if CC draw end points only.
.ae5b					_GXDLTLine:
.ae5b	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.ae5d	2d dd 05	and $05dd			and 	gxANDValue
.ae60	4d dc 05	eor $05dc			eor 	gxEORValue
.ae63	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.ae65	a5 36		lda $36				lda 	gxzTemp0 					; decrement counter
.ae67	d0 04		bne $ae6d			bne 	_GXDLTNoBorrow
.ae69	c6 37		dec $37				dec 	gxzTemp0+1 					; borrow, if goes -ve then exit
.ae6b	30 2e		bmi $ae9b			bmi 	_GXDLTExit
.ae6d					_GXDLTNoBorrow:
.ae6d	c6 36		dec $36				dec 	gxzTemp0
.ae6f	c8		iny				iny 								; next slot.
.ae70	d0 e9		bne $ae5b			bne 	_GXDLTLine
.ae72	e6 3d		inc $3d				inc 	gxzScreen+1 					; carry to next
.ae74	20 a9 ae	jsr $aea9			jsr 	GXDLTCheckWrap				; check for new page.
.ae77	80 e2		bra $ae5b			bra 	_GXDLTLine
.ae79					_GXDLTEndPoints:
.ae79	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.ae7b	2d dd 05	and $05dd			and 	gxANDValue
.ae7e	4d dc 05	eor $05dc			eor 	gxEORValue
.ae81	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.ae83	98		tya				tya 								; advance to right side
.ae84	18		clc				clc
.ae85	65 36		adc $36				adc 	gxzTemp0
.ae87	a8		tay				tay
.ae88	a5 3d		lda $3d				lda 	gxzScreen+1
.ae8a	65 37		adc $37				adc 	gxzTemp0+1
.ae8c	85 3d		sta $3d				sta 	gxzScreen+1
.ae8e	20 a9 ae	jsr $aea9			jsr 	GXDLTCheckWrap 			; fix up.
.ae91	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.ae93	2d dd 05	and $05dd			and 	gxANDValue
.ae96	4d dc 05	eor $05dc			eor 	gxEORValue
.ae99	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.ae9b					_GXDLTExit:
.ae9b	68		pla				pla
.ae9c	85 0b		sta $0b				sta 	GXEditSlot
.ae9e	68		pla				pla
.ae9f	8d df 05	sta $05df			sta 	gsOffset
.aea2	68		pla				pla
.aea3	85 3d		sta $3d				sta 	gxzScreen+1
.aea5	68		pla				pla
.aea6	85 3c		sta $3c				sta 	gxzScreen
.aea8	60		rts				rts
.aea9					GXDLTCheckWrap:
.aea9	a5 3d		lda $3d				lda 	gxzScreen+1 					; check end of page
.aeab	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8)
.aead	90 06		bcc $aeb5			bcc 	_GXDLTCWExit
.aeaf	e9 20		sbc #$20			sbc 	#$20 						; fix up
.aeb1	85 3d		sta $3d				sta 	gxzScreen+1
.aeb3	e6 0b		inc $0b				inc 	GXEditSlot
.aeb5					_GXDLTCWExit:
.aeb5	60		rts				rts
.aeb6					GXDrawGraphicElement:
.aeb6	8d 72 06	sta $0672			sta 	gxSize 						; save size
.aeb9	3a		dec a				dec 	a
.aeba	8d 73 06	sta $0673			sta 	gxMask 						; and mask
.aebd	ad d6 05	lda $05d6			lda 	gxBitmapsOn 				; check BMP on
.aec0	f0 67		beq $af29			beq 	_GXSLFail
.aec2	ad cf 05	lda $05cf			lda 	gxY0 						; push Y on stack
.aec5	48		pha				pha
.aec6	8c 75 06	sty $0675			sty 	gxAcquireVector+1 			; and acquisition vector
.aec9	8e 74 06	stx $0674			stx 	gxAcquireVector
.aecc	20 5b b1	jsr $b15b			jsr 	gxOpenBitmap 				; open the bitmap.
.aecf	ad 77 06	lda $0677			lda 	gxUseMode 					; scale bits
.aed2	4a		lsr a				lsr 	a
.aed3	4a		lsr a				lsr 	a
.aed4	4a		lsr a				lsr 	a
.aed5	29 07		and #$07			and		#7
.aed7	1a		inc a				inc 	a
.aed8	8d 76 06	sta $0676			sta 	gxScale
.aedb	64 38		stz $38				stz 	gxzTemp1					; start first line
.aedd					_GXGELoop:
.aedd	a5 38		lda $38				lda 	gxzTemp1 					; current line number to read.
.aedf	2c 77 06	bit $0677			bit 	gxUseMode 					; check for flip.
.aee2	10 06		bpl $aeea			bpl		_GXNoVFlip
.aee4	ad 73 06	lda $0673			lda 	gxMask
.aee7	38		sec				sec
.aee8	e5 38		sbc $38				sbc 	gxzTemp1
.aeea					_GXNoVFlip:
.aeea	aa		tax				tax 								; get the Xth line.
.aeeb	20 2b af	jsr $af2b			jsr 	_GXCallAcquire 				; get that data.
.aeee	ad 76 06	lda $0676			lda 	gxScale 					; do scale identical copies of that line.
.aef1	85 39		sta $39				sta 	gxzTemp1+1
.aef3					_GXGELoop2:
.aef3	ad cf 05	lda $05cf			lda 	gxY0 						; off screen
.aef6	cd d9 05	cmp $05d9			cmp 	gxHeight
.aef9	b0 10		bcs $af0b			bcs 	_GXDGEExit
.aefb	20 2e af	jsr $af2e			jsr 	GXRenderOneLine 			; render line
.aefe	c6 39		dec $39				dec 	gxzTemp1+1 					; scale times.
.af00	d0 f1		bne $aef3			bne 	_GXGELoop2
.af02	e6 38		inc $38				inc 	gxzTemp1 					; done all lines.
.af04	a5 38		lda $38				lda 	gxzTemp1
.af06	cd 72 06	cmp $0672			cmp 	gxSize
.af09	d0 d2		bne $aedd			bne 	_GXGELoop
.af0b					_GXDGEExit:
.af0b	68		pla				pla 								; restore Y for next time
.af0c	8d cf 05	sta $05cf			sta 	gxY0
.af0f	ae 76 06	ldx $0676			ldx 	gxScale 					; get scale (1-8)
.af12					_GXShiftLeft:
.af12	18		clc				clc
.af13	ad 72 06	lda $0672			lda 	gxSize
.af16	6d cd 05	adc $05cd			adc 	gxX0
.af19	8d cd 05	sta $05cd			sta 	gxX0
.af1c	90 03		bcc $af21			bcc 	_GXSLNoCarry
.af1e	ee ce 05	inc $05ce			inc 	gxX0+1
.af21					_GXSLNoCarry:
.af21	ca		dex				dex
.af22	d0 ee		bne $af12			bne 	_GXShiftLeft
.af24	20 63 b1	jsr $b163			jsr 	GXCloseBitmap
.af27	18		clc				clc
.af28	60		rts				rts
.af29					_GXSLFail:
.af29	38		sec				sec
.af2a	60		rts				rts
.af2b					_GXCallAcquire:
.af2b	6c 74 06	jmp ($0674)			jmp 	(gxAcquireVector)
.af2e					GXRenderOneLine:
.af2e	20 6b b1	jsr $b16b			jsr 	GXPositionCalc 				; calculate position/offset.
.af31	ac df 05	ldy $05df			ldy 	gsOffset 					; Y contains position.
.af34	64 3a		stz $3a				stz 	gxzTemp2 					; do size pixels
.af36					_GXROLLoop1:
.af36	ad 76 06	lda $0676			lda 	gxScale 					; set to do 'scale' times
.af39	85 3b		sta $3b				sta 	gxzTemp2+1
.af3b					_GXROLLoop2:
.af3b	a5 3a		lda $3a				lda 	gxzTemp2 					; get current pixel
.af3d	2c da 05	bit $05da			bit 	gxMode 						; check H Flip
.af40	50 06		bvc $af48			bvc 	_GXNoHFlip
.af42	ad 73 06	lda $0673			lda 	gxMask
.af45	38		sec				sec
.af46	e5 3a		sbc $3a				sbc 	gxzTemp2
.af48					_GXNoHFlip:
.af48	aa		tax				tax 								; read from the pixel buffer
.af49	bd 7b 05	lda $057b,x			lda 	gxPixelBuffer,x
.af4c	d0 07		bne $af55			bne 	_GXDraw 					; draw if non zero
.af4e	ad 77 06	lda $0677			lda 	gxUseMode 					; check to see if solid background
.af51	29 04		and #$04			and 	#4
.af53	f0 0a		beq $af5f			beq 	_GXZeroPixel
.af55					_GXDraw:
.af55	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.af57	2d dd 05	and $05dd			and 	gxANDValue
.af5a	5d 7b 05	eor $057b,x			eor 	gxPixelBuffer,x
.af5d	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.af5f					_GXZeroPixel:
.af5f	c8		iny				iny 								; advance pointer
.af60	d0 05		bne $af67			bne 	_GXNoShift
.af62	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.af64	20 a9 ae	jsr $aea9			jsr 	GXDLTCheckWrap				; check for new page.
.af67					_GXNoShift:
.af67	c6 3b		dec $3b				dec 	gxzTemp2+1 					; do the inner loop gxScale times.
.af69	d0 d0		bne $af3b			bne 	_GXROLLoop2
.af6b	e6 3a		inc $3a				inc 	gxzTemp2 					; next pixel.
.af6d	a5 3a		lda $3a				lda 	gxzTemp2
.af6f	cd 72 06	cmp $0672			cmp 	gxSize
.af72	d0 c2		bne $af36			bne 	_GXROLLoop1
.af74	ee cf 05	inc $05cf			inc 	gxY0
.af77	60		rts				rts
.0672					gxSize:
>0672							.fill 	1
.0673					gxMask:
>0673							.fill 	1
.0674					gxAcquireVector:
>0674							.fill 	2
.0676					gxScale:
>0676							.fill 	1
.0677					gxUseMode:
>0677							.fill 	1
.af78					GXFontHandler:
.af78	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.af7a	4d da 05	eor $05da			eor 	gxMode
.af7d	8d 77 06	sta $0677			sta 	gxUseMode
.af80	64 37		stz $37				stz 	gxzTemp0+1 					; gxzTemp0 is font #
.af82	06 36		asl $36				asl	 	gxzTemp0 					; x 2
.af84	26 37		rol $37				rol	 	gxzTemp0+1
.af86	06 36		asl $36				asl	 	gxzTemp0 					; x 4
.af88	26 37		rol $37				rol	 	gxzTemp0+1
.af8a	06 36		asl $36				asl	 	gxzTemp0 					; x 8
.af8c	26 37		rol $37				rol	 	gxzTemp0+1
.af8e	a5 37		lda $37				lda 	gxzTemp0+1 					; put in page C0
.af90	09 c0		ora #$c0			ora 	#$C0
.af92	85 37		sta $37				sta 	gxzTemp0+1
.af94	a9 08		lda #$08			lda 	#8 							; size 8x8
.af96	a2 9e		ldx #$9e			ldx 	#GXGetGraphicDataFont & $FF ; XY = Graphic Data retrieval routine
.af98	a0 af		ldy #$af			ldy 	#GXGetGraphicDataFont >> 8
.af9a	20 b6 ae	jsr $aeb6			jsr 	GXDrawGraphicElement
.af9d	60		rts				rts
.af9e					GXGetGraphicDataFont:
.af9e	8a		txa				txa 								; X->Y
.af9f	a8		tay				tay
.afa0	a6 01		ldx $01				ldx 	1 							; preserve old value
.afa2	a9 01		lda #$01			lda 	#1 							; access page 1 (font memory)
.afa4	85 01		sta $01				sta 	1
.afa6	b1 36		lda ($36),y			lda 	(gxzTemp0),y 				; read the font element.
.afa8	86 01		stx $01				stx 	1 							; put old value back.
.afaa	a2 00		ldx #$00			ldx 	#0 							; do 8 times
.afac					_GXExpand:
.afac	9e 7b 05	stz $057b,x			stz 	gxPixelBuffer,x 			; zero in pixel buffer
.afaf	0a		asl a				asl 	a 							; shift bit 7 into C
.afb0	90 08		bcc $afba			bcc 	_GXNoPixel
.afb2	48		pha				pha 								; if set, set pixel buffer to current colour.
.afb3	ad db 05	lda $05db			lda 	gxColour
.afb6	9d 7b 05	sta $057b,x			sta 	gxPixelBuffer,x
.afb9	68		pla				pla
.afba					_GXNoPixel:
.afba	e8		inx				inx 								; do the whole byte.
.afbb	e0 08		cpx #$08			cpx 	#8
.afbd	d0 ed		bne $afac			bne 	_GXExpand
.afbf	60		rts				rts
.afc0					GXSpriteHandler:
.afc0	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.afc2	4d da 05	eor $05da			eor 	gxMode
.afc5	8d 77 06	sta $0677			sta 	gxUseMode
.afc8	a6 36		ldx $36				ldx 	gxzTemp0 					; sprite #
.afca	da		phx				phx
.afcb	20 5b b1	jsr $b15b			jsr 	GXOpenBitmap 				; can access sprite information
.afce	68		pla				pla
.afcf	20 3c b2	jsr $b23c			jsr 	GXFindSprite 				; get the sprite address
.afd2	08		php				php
.afd3	20 63 b1	jsr $b163			jsr 	GXCloseBitmap
.afd6	28		plp				plp
.afd7	b0 0a		bcs $afe3			bcs		_GXSHExit 					; exit if find failed.
.afd9	ad 78 06	lda $0678			lda 	GXSizePixels 				; return size
.afdc	a2 e4		ldx #$e4			ldx 	#GXSpriteAcquire & $FF
.afde	a0 af		ldy #$af			ldy 	#GXSpriteAcquire >> 8
.afe0	20 b6 ae	jsr $aeb6			jsr 	GXDrawGraphicElement
.afe3					_GXSHExit:
.afe3	60		rts				rts
.afe4					GXSpriteAcquire:
.afe4	ad d8 05	lda $05d8			lda 	GXSpritePage				; point to base page
.afe7	85 0b		sta $0b				sta 	GXEditSlot
.afe9	86 36		stx $36				stx 	zTemp0 						; row number x 1,2,3,4
.afeb	a9 00		lda #$00			lda 	#0
.afed	ae 79 06	ldx $0679			ldx 	GXSizeBits
.aff0					_GXTimesRowNumber:
.aff0	18		clc				clc
.aff1	65 36		adc $36				adc 	zTemp0
.aff3	ca		dex				dex
.aff4	10 fa		bpl $aff0			bpl 	_GXTimesRowNumber
.aff6	64 37		stz $37				stz 	gxzTemp0+1
.aff8	0a		asl a				asl 	a 							; row x 2,4,6,8
.aff9	26 37		rol $37				rol 	gxzTemp0+1
.affb	0a		asl a				asl 	a 							; row x 4,8,12,16
.affc	26 37		rol $37				rol 	gxzTemp0+1
.affe	0a		asl a				asl 	a 							; row x 8,16,24,32
.afff	26 37		rol $37				rol 	gxzTemp0+1
.b001	85 36		sta $36				sta 	gxzTemp0
.b003	18		clc				clc 								; add base address.
.b004	a5 36		lda $36				lda 	gxzTemp0
.b006	6d 7b 06	adc $067b			adc 	GXSpriteOffset
.b009	85 36		sta $36				sta 	gxzTemp0
.b00b	a5 37		lda $37				lda 	gxzTemp0+1
.b00d	6d 7c 06	adc $067c			adc 	GXSpriteOffset+1
.b010					_GXSAFindPage:
.b010	c9 20		cmp #$20			cmp 	#$20 						; on this page
.b012	90 06		bcc $b01a			bcc 	_GXSAFoundPage
.b014	e9 20		sbc #$20			sbc 	#$20 						; forward one page
.b016	e6 0b		inc $0b				inc 	GXEditSlot
.b018	80 f6		bra $b010			bra 	_GXSAFindPage
.b01a					_GXSAFoundPage:
.b01a	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; physical address of page.
.b01c	85 37		sta $37				sta 	gxzTemp0+1 					; gxzTemp0 now points to the page
.b01e	a0 00		ldy #$00			ldy 	#0
.b020					_GXSACopyLoop:
.b020	b1 36		lda ($36),y			lda 	(gxzTemp0),y
.b022	99 7b 05	sta $057b,y			sta 	gxPixelBuffer,y
.b025	c8		iny				iny
.b026	cc 78 06	cpy $0678			cpy 	GXSizePixels
.b029	d0 f5		bne $b020			bne 	_GXSACopyLoop
.b02b	60		rts				rts
.b02c					GXSelect:
.b02c	ad d5 05	lda $05d5			lda 	gxSpritesOn
.b02f	f0 22		beq $b053			beq 	_GXSFail
.b031	a5 36		lda $36				lda 	gxzTemp0 					; illegal sprite #
.b033	c9 40		cmp #$40			cmp 	#64
.b035	b0 1c		bcs $b053			bcs 	_GXSFail
.b037	8d e0 05	sta $05e0			sta 	GSCurrentSpriteID
.b03a	a4 37		ldy $37				ldy 	gxzTemp0+1 					; control value.
.b03c	a9 00		lda #$00			lda  	#0 							; multiply sprite # x 8 => A
.b03e	06 36		asl $36				asl 	gxzTemp0
.b040	06 36		asl $36				asl 	gxzTemp0
.b042	06 36		asl $36				asl 	gxzTemp0
.b044	2a		rol a				rol 	a
.b045	69 d9		adc #$d9			adc 	#$D9 						; sprite area
.b047	8d e2 05	sta $05e2			sta 	GSCurrentSpriteAddr+1 		; address to GSCurrentSprite and gxzTemp
.b04a	85 37		sta $37				sta 	gxzTemp0+1
.b04c	a5 36		lda $36				lda 	gxzTemp0
.b04e	8d e1 05	sta $05e1			sta 	GSCurrentSpriteAddr
.b051	18		clc				clc
.b052	60		rts				rts
.b053					_GXSFail:
.b053	38		sec				sec
.b054	60		rts				rts
.b055					GXSelectImage:
.b055	ad d5 05	lda $05d5			lda 	gxSpritesOn
.b058	f0 74		beq $b0ce			beq 	_GXSIFail
.b05a	ad e2 05	lda $05e2			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b05d	f0 6f		beq $b0ce			beq 	_GXSIFail 					; (checking the MSB)
.b05f	64 01		stz $01				stz 	1
.b061	a5 37		lda $37				lda 	gxzTemp0+1 					; push show/hide on the stack.
.b063	d0 6b		bne $b0d0			bne 	_GXSIHide
.b065	a5 36		lda $36				lda 	gxzTemp0 					; sprite image
.b067	48		pha				pha
.b068	20 5b b1	jsr $b15b			jsr 	GXOpenBitmap
.b06b	68		pla				pla
.b06c	20 3c b2	jsr $b23c			jsr 	GXFindSprite
.b06f	b0 5a		bcs $b0cb			bcs 	_GXSICloseFail 				; no image
.b071	a0 01		ldy #$01			ldy 	#1
.b073	ad e1 05	lda $05e1			lda 	GSCurrentSpriteAddr
.b076	85 36		sta $36				sta 	gxzTemp0
.b078	ad e2 05	lda $05e2			lda 	GSCurrentSpriteAddr+1
.b07b	85 37		sta $37				sta 	gxzTemp0+1
.b07d	ad 7b 06	lda $067b			lda 	GXSpriteOffset
.b080	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b082	18		clc				clc
.b083	ad 7c 06	lda $067c			lda 	GXSpriteOffset+1
.b086	6d e3 05	adc $05e3			adc 	GXSpriteOffsetBase
.b089	c8		iny				iny
.b08a	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b08c	ad e4 05	lda $05e4			lda 	GXSpriteOffsetBase+1
.b08f	69 00		adc #$00			adc 	#0
.b091	c8		iny				iny
.b092	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b094	ad 79 06	lda $0679			lda 	GXSizeBits 					; get raw size
.b097	49 03		eor #$03			eor 	#3 							; make it right (00=32 etc.)
.b099	2a		rol a				rol 	a 							; x 2
.b09a	0a		asl a				asl 	a 							; x 4
.b09b	0a		asl a				asl 	a 							; x 8
.b09c	0a		asl a				asl 	a 							; x 16
.b09d	0d 7a 06	ora $067a			ora 	GXSpriteLUT 				; Or with LUT
.b0a0	0a		asl a				asl 	a 							; 1 shift
.b0a1	09 01		ora #$01			ora 	#1 							; enable sprite.
.b0a3	92 36		sta ($36)			sta 	(gxzTemp0) 					; and write back
.b0a5	20 63 b1	jsr $b163			jsr 	GXCloseBitmap
.b0a8	ae e0 05	ldx $05e0			ldx 	GSCurrentSpriteID 			; point to sprite entries.
.b0ab	bd 25 06	lda $0625,x			lda 	GXSpriteHigh,x 				; clear upper two bits of size
.b0ae	29 3f		and #$3f			and 	#$3F
.b0b0	9d 25 06	sta $0625,x			sta 	GXSpriteHigh,x
.b0b3	ad 79 06	lda $0679			lda 	GXSizeBits 					; get bit size
.b0b6	6a		ror a				ror 	a 							; shift into bits 6/7
.b0b7	6a		ror a				ror 	a
.b0b8	6a		ror a				ror 	a
.b0b9	29 c0		and #$c0			and 	#$C0
.b0bb	1d 25 06	ora $0625,x			ora 	GXSpriteHigh,x 				; put in  upper 2 bits of sprite data
.b0be	9d 25 06	sta $0625,x			sta 	GXSpriteHigh,x
.b0c1	bd e5 05	lda $05e5,x			lda 	GXSpriteLow,x 				; clear hidden flag.
.b0c4	29 7f		and #$7f			and 	#$7F
.b0c6	9d e5 05	sta $05e5,x			sta 	GXSpriteLow,x
.b0c9	18		clc				clc
.b0ca	60		rts				rts
.b0cb					_GXSICloseFail:
.b0cb	20 63 b1	jsr $b163			jsr 	GXCloseBitmap
.b0ce					_GXSIFail:
.b0ce	38		sec				sec
.b0cf	60		rts				rts
.b0d0					_GXSIHide:
.b0d0	ad e1 05	lda $05e1			lda 	GSCurrentSpriteAddr  		; get Sprite h/w address and write there
.b0d3	85 36		sta $36				sta 	gxzTemp0
.b0d5	ad e2 05	lda $05e2			lda 	GSCurrentSpriteAddr+1
.b0d8	85 37		sta $37				sta 	gxzTemp0+1
.b0da	a9 00		lda #$00			lda 	#0
.b0dc	92 36		sta ($36)			sta 	(gxzTemp0)
.b0de	ae e0 05	ldx $05e0			ldx 	GSCurrentSpriteID 			; get sprite ID
.b0e1	bd e5 05	lda $05e5,x			lda 	GXSpriteLow,x 				; set the hidden bit.
.b0e4	09 80		ora #$80			ora 	#$80
.b0e6	9d e5 05	sta $05e5,x			sta 	GXSpriteLow,x
.b0e9	18		clc				clc
.b0ea	60		rts				rts
.b0eb					GXMoveSprite:
.b0eb	ad d5 05	lda $05d5			lda 	gxSpritesOn
.b0ee	f0 65		beq $b155			beq 	_GXSIFail
.b0f0	ad e2 05	lda $05e2			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b0f3	f0 60		beq $b155			beq 	_GXSIFail
.b0f5	85 37		sta $37				sta 	gxzTemp0+1
.b0f7	a0 04		ldy #$04			ldy 	#4
.b0f9	ad e1 05	lda $05e1			lda 	GSCurrentSpriteAddr
.b0fc	85 36		sta $36				sta 	gxzTemp0
.b0fe	ae e0 05	ldx $05e0			ldx 	GSCurrentSpriteID 			; get the size from the upper two bits
.b101	bd 25 06	lda $0625,x			lda 	GXSpriteHigh,x
.b104	2a		rol a				rol 	a	 						; into bits 0,1.
.b105	2a		rol a				rol 	a
.b106	2a		rol a				rol 	a
.b107	29 03		and #$03			and 	#3
.b109	aa		tax				tax
.b10a	bd 57 b1	lda $b157,x			lda 	_GXMSOffset,x 				; get 32-SpriteSize/2
.b10d	48		pha				pha
.b10e	18		clc				clc
.b10f	6d cd 05	adc $05cd			adc 	gxX0						; copy position.
.b112	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b114	c8		iny				iny
.b115	ad ce 05	lda $05ce			lda 	gxX0+1
.b118	69 00		adc #$00			adc 	#0
.b11a	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b11c	c8		iny				iny
.b11d	68		pla				pla
.b11e	18		clc				clc
.b11f	6d cf 05	adc $05cf			adc 	gxY0
.b122	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b124	a9 00		lda #$00			lda 	#0
.b126	69 00		adc #$00			adc 	#0
.b128	c8		iny				iny
.b129	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b12b	4e ce 05	lsr $05ce			lsr 	gxX0+1 						; divide X by 4
.b12e	6e cd 05	ror $05cd			ror 	gxX0
.b131	4e cd 05	lsr $05cd			lsr 	gxX0
.b134	4e cf 05	lsr $05cf			lsr 	gxY0 						; divide Y by 4
.b137	4e cf 05	lsr $05cf			lsr 	gxY0
.b13a	ae e0 05	ldx $05e0			ldx 	GSCurrentSpriteID 			; copy X/4 and Y/4 into the status bytes
.b13d	bd e5 05	lda $05e5,x			lda 	GXSpriteLow,x
.b140	29 80		and #$80			and 	#$80
.b142	0d cd 05	ora $05cd			ora 	gxX0
.b145	9d e5 05	sta $05e5,x			sta 	GXSpriteLow,x
.b148	bd 25 06	lda $0625,x			lda 	GXSpriteHigh,x
.b14b	29 c0		and #$c0			and 	#$C0
.b14d	0d cf 05	ora $05cf			ora 	gxY0
.b150	9d 25 06	sta $0625,x			sta 	GXSpriteHigh,x
.b153	18		clc				clc
.b154	60		rts				rts
.b155					_GXSIFail:
.b155	38		sec				sec
.b156	60		rts				rts
.b157					_GXMSOffset:
>b157	1c						.byte 	32-8/2
>b158	18						.byte 	32-16/2
>b159	14						.byte 	32-24/2
>b15a	10						.byte 	32-32/2
.b15b					GXOpenBitmap:
.b15b	78		sei				sei 								; no interrupts here
.b15c	a5 0b		lda $0b				lda 	GXEditSlot 					; Save the original LUT slot value
.b15e	8d de 05	sta $05de			sta 	gxOriginalLUTValue
.b161	58		cli				cli
.b162	60		rts				rts
.b163					GXCloseBitmap:
.b163	78		sei				sei
.b164	ad de 05	lda $05de			lda 	gxOriginalLUTValue 			; restore LUT slot value
.b167	85 0b		sta $0b				sta 	GXEditSlot
.b169	58		cli				cli
.b16a	60		rts				rts
.b16b					GXPositionCalc:
.b16b	a5 36		lda $36				lda 	gxzTemp0 					; save temp memory slot
.b16d	48		pha				pha
.b16e	ad cf 05	lda $05cf			lda 	GXY0 						; gxzScreen = Y0
.b171	85 3c		sta $3c				sta 	gxzScreen
.b173	64 3d		stz $3d				stz 	gxzScreen+1
.b175	06 3c		asl $3c				asl 	gxzScreen 						; gxzScreen = Y0 * 4
.b177	26 3d		rol $3d				rol 	gxzScreen+1
.b179	06 3c		asl $3c				asl 	gxzScreen
.b17b	26 3d		rol $3d				rol 	gxzScreen+1
.b17d	18		clc				clc 								; gxzScreen = Y0 * 5, as it's still in A
.b17e	65 3c		adc $3c				adc 	gxzScreen
.b180	85 3c		sta $3c				sta 	gxzScreen
.b182	90 02		bcc $b186			bcc 	_GXPCNoCarry
.b184	e6 3d		inc $3d				inc 	gxzScreen+1
.b186					_GXPCNoCarry:
.b186	06 3c		asl $3c				asl 	gxzScreen 						; now Y0 * 10. Needs to be multiplied by another
.b188	26 3d		rol $3d				rol 	gxzScreen+1 					; 32. At this point the MSB contains the offset
.b18a	a5 3d		lda $3d				lda	 	gxzScreen+1 					; so save this in zTemp0 and zero it.
.b18c	85 36		sta $36				sta 	gxzTemp0
.b18e	64 3d		stz $3d				stz 	gxzScreen+1
.b190	a9 05		lda #$05			lda 	#5 							; now multiply by 32, this puts this in the range 0..8191
.b192					_GXPCMultiply32:
.b192	06 3c		asl $3c				asl 	gxzScreen
.b194	26 3d		rol $3d				rol 	gxzScreen+1
.b196	3a		dec a				dec 	a
.b197	d0 f9		bne $b192			bne 	_GXPCMultiply32
.b199	18		clc				clc
.b19a	ad cd 05	lda $05cd			lda 	GXX0 						; add X to this value, put the result in gsOffset, gxzScreen has to be on a page boundary
.b19d	65 3c		adc $3c				adc 	gxzScreen
.b19f	8d df 05	sta $05df			sta 	gsOffset
.b1a2	ad ce 05	lda $05ce			lda 	GXX0+1
.b1a5	65 3d		adc $3d				adc 	gxzScreen+1
.b1a7	c9 20		cmp #$20			cmp 	#$20 						; has it overflowed into the next one ?
.b1a9	90 04		bcc $b1af			bcc 	_GXPCNoOverflow
.b1ab	29 1f		and #$1f			and 	#$1F 						; fix it up
.b1ad	e6 36		inc $36				inc 	gxzTemp0 					; add 1 to the page number
.b1af					_GXPCNoOverflow:
.b1af	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; make it the address mapped in.
.b1b1	85 3d		sta $3d				sta 	gxzScreen+1
.b1b3	64 3c		stz $3c				stz 	gxzScreen
.b1b5	18		clc				clc
.b1b6	a5 36		lda $36				lda 	gxzTemp0 					; get the page number
.b1b8	6d d7 05	adc $05d7			adc 	gxBasePage 					; by adding the base page
.b1bb	85 0b		sta $0b				sta 	GXEditSlot 				; and map it into memory.
.b1bd	68		pla				pla
.b1be	85 36		sta $36				sta 	gxzTemp0
.b1c0	60		rts				rts
.b1c1					GXMovePositionDown:
.b1c1	18		clc				clc 								; add 320 to offset/temp+1
.b1c2	ad df 05	lda $05df			lda 	gsOffset
.b1c5	69 40		adc #$40			adc 	#64
.b1c7	8d df 05	sta $05df			sta 	gsOffset
.b1ca	a5 3d		lda $3d				lda 	gxzScreen+1
.b1cc	69 01		adc #$01			adc 	#1
.b1ce	85 3d		sta $3d				sta 	gxzScreen+1
.b1d0	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page
.b1d2	90 07		bcc $b1db			bcc 	_GXMPDExit
.b1d4	38		sec				sec  								; next page
.b1d5	e9 20		sbc #$20			sbc 	#$20
.b1d7	85 3d		sta $3d				sta 	gxzScreen+1
.b1d9	e6 0b		inc $0b				inc 	GXEditSlot
.b1db					_GXMPDExit:
.b1db	60		rts				rts
.b1dc					GXCollide:
.b1dc	a5 36		lda $36				lda 	gxzTemp0 					; check if sprite numbers are legal.
.b1de	aa		tax				tax
.b1df	05 37		ora $37				ora 	gxzTemp0+1
.b1e1	29 c0		and #$c0			and 	#$C0
.b1e3	38		sec				sec
.b1e4	d0 53		bne $b239			bne 	_GXCollideFail 				; if either >= 64, fail.
.b1e6	a4 37		ldy $37				ldy 	gxzTemp0+1 					; at this point X is 1st sprite and Y is 2nd sprite.
.b1e8	b9 e5 05	lda $05e5,y			lda 	GXSpriteLow,y 				; check if either hidden bit is set
.b1eb	1d e5 05	ora $05e5,x			ora 	GXSpriteLow,x
.b1ee	30 48		bmi $b238			bmi 	_GXOkayFail 				; if either hidden, then they cannot collide.
.b1f0	18		clc				clc 								; need to calculate sum of sizes.
.b1f1	b9 25 06	lda $0625,y			lda 	GXSpriteHigh,y
.b1f4	7d 25 06	adc $0625,x			adc 	GXSpriteHigh,x 				; at this point, CS, Bit 6 and 7 contain that sum.
.b1f7	29 c0		and #$c0			and 	#$C0 					 	; mask off
.b1f9	6a		ror a				ror 	a 							; 5/6/7
.b1fa	4a		lsr a				lsr 	a 							; 4/5/6
.b1fb	4a		lsr a				lsr 	a 							; 3/4/5
.b1fc	4a		lsr a				lsr 	a 							; 2/3/4
.b1fd	18		clc				clc
.b1fe	69 08		adc #$08			adc 	#$08
.b200	4a		lsr a				lsr 	a 							; adjust because all coordinates are divided by 4 to store.
.b201	4a		lsr a				lsr 	a
.b202	85 38		sta $38				sta 	gxzTemp1 					; so the difference between the centres has to be less than this.
.b204	b9 25 06	lda $0625,y			lda 	GXSpriteHigh,y 				; calculate y1-y0
.b207	29 3f		and #$3f			and 	#$3F
.b209	85 39		sta $39				sta 	gxzTemp1+1
.b20b	38		sec				sec
.b20c	bd 25 06	lda $0625,x			lda 	GXSpriteHigh,x
.b20f	29 3f		and #$3f			and 	#$3F
.b211	e5 39		sbc $39				sbc 	gxzTemp1+1
.b213	b0 03		bcs $b218			bcs 	_GXCAbs1 					; calculate |y1-y0|
.b215	49 ff		eor #$ff			eor 	#$FF
.b217	1a		inc a				inc 	a
.b218					_GXCAbs1:
.b218	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b21a	b0 1c		bcs $b238			bcs 	_GXOkayFail
.b21c	85 39		sta $39				sta 	gxzTemp1+1 					; save |y1-y0|
.b21e	38		sec				sec 								; calculate |x1-x0|
.b21f	b9 e5 05	lda $05e5,y			lda 	GXSpriteLow,y
.b222	fd e5 05	sbc $05e5,x			sbc 	GXSpriteLow,x
.b225	b0 03		bcs $b22a			bcs 	_GXCAbs2
.b227	49 ff		eor #$ff			eor 	#$FF
.b229	1a		inc a				inc 	a
.b22a					_GXCAbs2:
.b22a	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b22c	b0 0a		bcs $b238			bcs 	_GXOkayFail
.b22e	c5 39		cmp $39				cmp 	gxzTemp1+1 					; is it less than the previous one.
.b230	90 02		bcc $b234			bcc 	_GXCHaveLowest
.b232	a5 39		lda $39				lda 	gxzTemp1+1 					; if not, that's the smallest difference.
.b234					_GXCHaveLowest:
.b234	0a		asl a				asl 	a 							; scale to allow for >> 2
.b235	0a		asl a				asl 	a
.b236	18		clc				clc
.b237	60		rts				rts
.b238					_GXOkayFail:
.b238	18		clc				clc
.b239					_GXCollideFail:
.b239	a9 ff		lda #$ff			lda 	#$FF
.b23b	60		rts				rts
.b23c					GXFindSprite:
.b23c	aa		tax				tax
.b23d	ad d8 05	lda $05d8			lda 	GXSpritePage 				; access the base page of the sprite
.b240	85 0b		sta $0b				sta 	GXEditSlot
.b242	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; check a valid sprite
.b245	1d 00 60	ora $6000,x			ora 	GXMappingAddress,x
.b248	f0 33		beq $b27d			beq 	_GXFSFail
.b24a	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; MSB
.b24d	8d 7c 06	sta $067c			sta 	GXSpriteOffset+1
.b250	bd 00 60	lda $6000,x			lda 	GXMappingAddress,x 			; LSB
.b253	48		pha				pha 								; save twice
.b254	48		pha				pha
.b255	29 03		and #$03			and 	#3 							; get sprite size
.b257	8d 79 06	sta $0679			sta 	GXSizeBits 					; save raw (0-3)
.b25a	aa		tax				tax
.b25b	bd 7f b2	lda $b27f,x			lda 	_GXFXSSTTable,x 			; read sprite size
.b25e	8d 78 06	sta $0678			sta 	GXSizePixels 					; save (8/16/24/32)
.b261	68		pla				pla 								; get LUT
.b262	4a		lsr a				lsr		a
.b263	4a		lsr a				lsr		a
.b264	29 03		and #$03			and 	#3
.b266	8d 7a 06	sta $067a			sta 	GXSpriteLUT
.b269	68		pla				pla 								; address, neeeds to be x 4
.b26a	29 f0		and #$f0			and 	#$F0
.b26c	8d 7b 06	sta $067b			sta 	GXSpriteOffset
.b26f	0e 7b 06	asl $067b			asl 	GXSpriteOffset
.b272	2e 7c 06	rol $067c			rol 	GXSpriteOffset+1
.b275	0e 7b 06	asl $067b			asl 	GXSpriteOffset
.b278	2e 7c 06	rol $067c			rol 	GXSpriteOffset+1
.b27b	18		clc				clc
.b27c	60		rts				rts
.b27d					_GXFSFail:
.b27d	38		sec				sec
.b27e	60		rts				rts
.b27f					_GXFXSSTTable:
>b27f	08 10 18 20					.byte 	8,16,24,32
.0678					GXSizePixels:
>0678							.fill 	1
.0679					GXSizeBits:
>0679							.fill 	1
.067a					GXSpriteLUT:
>067a							.fill 	1
.067b					GXSpriteOffset:
>067b							.fill 	2
.b283					GXSortXY:
.b283	20 a1 b2	jsr $b2a1			jsr 	GXSortY 					; will be sorted on Y now
.b286	ad cd 05	lda $05cd			lda 	gxX0 						; compare X0 v X1
.b289	cd d1 05	cmp $05d1			cmp 	gxX1
.b28c	ad ce 05	lda $05ce			lda 	gXX0+1
.b28f	ed d2 05	sbc $05d2			sbc 	gXX1+1
.b292	90 0c		bcc $b2a0			bcc 	_GXSXYExit 					; X0 < X1 exit
.b294	a2 00		ldx #$00			ldx 	#0 							; swap them over
.b296	a0 04		ldy #$04			ldy 	#4
.b298	20 b5 b2	jsr $b2b5			jsr 	GXSwapXY
.b29b	e8		inx				inx
.b29c	c8		iny				iny
.b29d	20 b5 b2	jsr $b2b5			jsr 	GXSwapXY
.b2a0					_GXSXYExit:
.b2a0	60		rts				rts
.b2a1					GXSortY:
.b2a1	ad cf 05	lda $05cf			lda 	gxY0 						; if Y0 >= Y1
.b2a4	cd d3 05	cmp $05d3			cmp 	gxY1
.b2a7	90 0b		bcc $b2b4			bcc 	_GXSYSorted
.b2a9	a2 03		ldx #$03			ldx 	#3 							; swap 3-0
.b2ab	a0 07		ldy #$07			ldy 	#7 							; with 4-7
.b2ad					_GXSwap1:
.b2ad	20 b5 b2	jsr $b2b5			jsr 	GXSwapXY
.b2b0	88		dey				dey
.b2b1	ca		dex				dex
.b2b2	10 f9		bpl $b2ad			bpl 	_GXSwap1
.b2b4					_GXSYSorted:
.b2b4	60		rts				rts
.b2b5					GXSwapXY:
.b2b5	bd cd 05	lda $05cd,x			lda 	gxX0,x
.b2b8	48		pha				pha
.b2b9	b9 cd 05	lda $05cd,y			lda 	gxX0,y
.b2bc	9d cd 05	sta $05cd,x			sta 	gxX0,x
.b2bf	68		pla				pla
.b2c0	99 cd 05	sta $05cd,y			sta 	gxX0,y
.b2c3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_tokeniser.module

=1					tokeniserIntegrated=1
.b96a					KeywordSet0:
>b96a	00 65					.text	0,$65,""               ; $80 !0:EOF
>b96c	00 58					.text	0,$58,""               ; $81 !1:SH1
>b96e	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b970	04 fe 41 42 53 28			.text	4,$fe,"ABS("           ; $83 ABS(
>b976	06 93 41 4c 4c 4f 43 28			.text	6,$93,"ALLOC("         ; $84 ALLOC(
>b97e	04 ff 41 53 43 28			.text	4,$ff,"ASC("           ; $85 ASC(
>b984	05 29 43 48 52 24 28			.text	5,$29,"CHR$("          ; $86 CHR$(
>b98b	06 aa 45 56 45 4e 54 28			.text	6,$aa,"EVENT("         ; $87 EVENT(
>b993	05 6b 46 41 4c 53 45			.text	5,$6b,"FALSE"          ; $88 FALSE
>b99a	05 44 46 52 41 43 28			.text	5,$44,"FRAC("          ; $89 FRAC(
>b9a1	04 0d 48 49 54 28			.text	4,$0d,"HIT("           ; $8a HIT(
>b9a7	04 13 49 4e 54 28			.text	4,$13,"INT("           ; $8b INT(
>b9ad	06 a7 49 53 56 41 4c 28			.text	6,$a7,"ISVAL("         ; $8c ISVAL(
>b9b5	05 5c 4a 4f 59 42 28			.text	5,$5c,"JOYB("          ; $8d JOYB(
>b9bc	05 72 4a 4f 59 58 28			.text	5,$72,"JOYX("          ; $8e JOYX(
>b9c3	05 73 4a 4f 59 59 28			.text	5,$73,"JOYY("          ; $8f JOYY(
>b9ca	06 77 4c 45 46 54 24 28			.text	6,$77,"LEFT$("         ; $90 LEFT$(
>b9d2	04 07 4c 45 4e 28			.text	4,$07,"LEN("           ; $91 LEN(
>b9d8	04 0e 4d 41 58 28			.text	4,$0e,"MAX("           ; $92 MAX(
>b9de	05 26 4d 49 44 24 28			.text	5,$26,"MID$("          ; $93 MID$(
>b9e5	04 0c 4d 49 4e 28			.text	4,$0c,"MIN("           ; $94 MIN(
>b9eb	04 19 4e 4f 54 28			.text	4,$19,"NOT("           ; $95 NOT(
>b9f1	08 3c 50 4c 41 59 49 4e			.text	8,$3c,"PLAYING("       ; $96 PLAYING(
>b9f9	47 28
>b9fb	07 e9 52 41 4e 44 4f 4d			.text	7,$e9,"RANDOM("        ; $97 RANDOM(
>ba03	28
>ba04	07 ca 52 49 47 48 54 24			.text	7,$ca,"RIGHT$("        ; $98 RIGHT$(
>ba0c	28
>ba0d	04 0c 52 4e 44 28			.text	4,$0c,"RND("           ; $99 RND(
>ba13	04 10 53 47 4e 28			.text	4,$10,"SGN("           ; $9a SGN(
>ba19	04 0e 53 50 43 28			.text	4,$0e,"SPC("           ; $9b SPC(
>ba1f	05 45 53 54 52 24 28			.text	5,$45,"STR$("          ; $9c STR$(
>ba26	06 a9 54 49 4d 45 52 28			.text	6,$a9,"TIMER("         ; $9d TIMER(
>ba2e	04 40 54 52 55 45			.text	4,$40,"TRUE"           ; $9e TRUE
>ba34	04 0b 56 41 4c 28			.text	4,$0b,"VAL("           ; $9f VAL(
>ba3a	03 e7 46 4f 52				.text	3,$e7,"FOR"            ; $a0 FOR
>ba3f	02 8f 49 46				.text	2,$8f,"IF"             ; $a1 IF
>ba43	04 34 50 52 4f 43			.text	4,$34,"PROC"           ; $a2 PROC
>ba49	06 c1 52 45 50 45 41 54			.text	6,$c1,"REPEAT"         ; $a3 REPEAT
>ba51	05 79 57 48 49 4c 45			.text	5,$79,"WHILE"          ; $a4 WHILE
>ba58	05 66 45 4e 44 49 46			.text	5,$66,"ENDIF"          ; $a5 ENDIF
>ba5f	07 0b 45 4e 44 50 52 4f			.text	7,$0b,"ENDPROC"        ; $a6 ENDPROC
>ba67	43
>ba68	04 3f 4e 45 58 54			.text	4,$3f,"NEXT"           ; $a7 NEXT
>ba6e	04 2f 54 48 45 4e			.text	4,$2f,"THEN"           ; $a8 THEN
>ba74	05 8c 55 4e 54 49 4c			.text	5,$8c,"UNTIL"          ; $a9 UNTIL
>ba7b	04 2e 57 45 4e 44			.text	4,$2e,"WEND"           ; $aa WEND
>ba81	02 9b 42 59				.text	2,$9b,"BY"             ; $ab BY
>ba85	04 1c 43 41 4c 4c			.text	4,$1c,"CALL"           ; $ac CALL
>ba8b	06 b2 43 49 52 43 4c 45			.text	6,$b2,"CIRCLE"         ; $ad CIRCLE
>ba93	05 67 43 4c 45 41 52			.text	5,$67,"CLEAR"          ; $ae CLEAR
>ba9a	03 e2 43 4c 53				.text	3,$e2,"CLS"            ; $af CLS
>ba9f	05 7f 43 4f 4c 4f 52			.text	5,$7f,"COLOR"          ; $b0 COLOR
>baa6	06 d4 43 4f 4c 4f 55 52			.text	6,$d4,"COLOUR"         ; $b1 COLOUR
>baae	04 1a 44 41 54 41			.text	4,$1a,"DATA"           ; $b2 DATA
>bab4	03 da 44 49 4d				.text	3,$da,"DIM"            ; $b3 DIM
>bab9	06 db 44 4f 57 4e 54 4f			.text	6,$db,"DOWNTO"         ; $b4 DOWNTO
>bac1	04 29 45 4c 53 45			.text	4,$29,"ELSE"           ; $b5 ELSE
>bac7	04 34 46 52 4f 4d			.text	4,$34,"FROM"           ; $b6 FROM
>bacd	03 e5 47 46 58				.text	3,$e5,"GFX"            ; $b7 GFX
>bad2	05 80 47 4f 53 55 42			.text	5,$80,"GOSUB"          ; $b8 GOSUB
>bad9	04 39 47 4f 54 4f			.text	4,$39,"GOTO"           ; $b9 GOTO
>badf	04 24 48 45 52 45			.text	4,$24,"HERE"           ; $ba HERE
>bae5	05 63 49 4d 41 47 45			.text	5,$63,"IMAGE"          ; $bb IMAGE
>baec	05 90 49 4e 50 55 54			.text	5,$90,"INPUT"          ; $bc INPUT
>baf3	03 e5 4c 45 54				.text	3,$e5,"LET"            ; $bd LET
>baf8	04 28 4c 49 4e 45			.text	4,$28,"LINE"           ; $be LINE
>bafe	05 6b 4c 4f 43 41 4c			.text	5,$6b,"LOCAL"          ; $bf LOCAL
>bb05	03 db 4f 46 46				.text	3,$db,"OFF"            ; $c0 OFF
>bb0a	02 9d 4f 4e				.text	2,$9d,"ON"             ; $c1 ON
>bb0e	07 20 4f 55 54 4c 49 4e			.text	7,$20,"OUTLINE"        ; $c2 OUTLINE
>bb16	45
>bb17	07 0f 50 41 4c 45 54 54			.text	7,$0f,"PALETTE"        ; $c3 PALETTE
>bb1f	45
>bb20	04 3f 50 4c 4f 54			.text	4,$3f,"PLOT"           ; $c4 PLOT
>bb26	05 8d 50 52 49 4e 54			.text	5,$8d,"PRINT"          ; $c5 PRINT
>bb2d	04 1c 52 45 41 44			.text	4,$1c,"READ"           ; $c6 READ
>bb33	04 2e 52 45 43 54			.text	4,$2e,"RECT"           ; $c7 RECT
>bb39	03 e4 52 45 4d				.text	3,$e4,"REM"            ; $c8 REM
>bb3e	06 e0 52 45 54 55 52 4e			.text	6,$e0,"RETURN"         ; $c9 RETURN
>bb46	05 7b 53 4f 4c 49 44			.text	5,$7b,"SOLID"          ; $ca SOLID
>bb4d	05 89 53 4f 55 4e 44			.text	5,$89,"SOUND"          ; $cb SOUND
>bb54	06 d7 53 50 52 49 54 45			.text	6,$d7,"SPRITE"         ; $cc SPRITE
>bb5c	04 45 54 45 58 54			.text	4,$45,"TEXT"           ; $cd TEXT
>bb62	02 a3 54 4f				.text	2,$a3,"TO"             ; $ce TO
>bb66	ff					.text	$FF
.bb67					KeywordSet1:
>bb67	00 65					.text	0,$65,""               ; $80 !0:EOF
>bb69	00 58					.text	0,$58,""               ; $81 !1:SH1
>bb6b	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bb6d	08 4c 41 53 53 45 4d 42			.text	8,$4c,"ASSEMBLE"       ; $83 ASSEMBLE
>bb75	4c 45
>bb77	06 d2 41 53 53 45 52 54			.text	6,$d2,"ASSERT"         ; $84 ASSERT
>bb7f	06 bd 42 49 54 4d 41 50			.text	6,$bd,"BITMAP"         ; $85 BITMAP
>bb87	03 d7 45 4e 44				.text	3,$d7,"END"            ; $86 END
>bb8c	02 96 47 4f				.text	2,$96,"GO"             ; $87 GO
>bb90	04 3c 4c 49 53 54			.text	4,$3c,"LIST"           ; $88 LIST
>bb96	04 20 4c 4f 41 44			.text	4,$20,"LOAD"           ; $89 LOAD
>bb9c	03 ea 4e 45 57				.text	3,$ea,"NEW"            ; $8a NEW
>bba1	07 24 52 45 53 54 4f 52			.text	7,$24,"RESTORE"        ; $8b RESTORE
>bba9	45
>bbaa	03 f5 52 55 4e				.text	3,$f5,"RUN"            ; $8c RUN
>bbaf	07 2a 53 50 52 49 54 45			.text	7,$2a,"SPRITES"        ; $8d SPRITES
>bbb7	53
>bbb8	04 46 53 54 4f 50			.text	4,$46,"STOP"           ; $8e STOP
>bbbe	03 ee 57 48 4f				.text	3,$ee,"WHO"            ; $8f WHO
>bbc3	ff					.text	$FF
.bbc4					KeywordSet2:
>bbc4	00 65					.text	0,$65,""               ; $80 !0:EOF
>bbc6	00 58					.text	0,$58,""               ; $81 !1:SH1
>bbc8	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bbca	03 c8 41 44 43				.text	3,$c8,"ADC"            ; $83 ADC
>bbcf	03 d3 41 4e 44				.text	3,$d3,"AND"            ; $84 AND
>bbd4	03 e0 41 53 4c				.text	3,$e0,"ASL"            ; $85 ASL
>bbd9	03 c8 42 43 43				.text	3,$c8,"BCC"            ; $86 BCC
>bbde	03 d8 42 43 53				.text	3,$d8,"BCS"            ; $87 BCS
>bbe3	03 d8 42 45 51				.text	3,$d8,"BEQ"            ; $88 BEQ
>bbe8	03 df 42 49 54				.text	3,$df,"BIT"            ; $89 BIT
>bbed	03 d8 42 4d 49				.text	3,$d8,"BMI"            ; $8a BMI
>bbf2	03 d5 42 4e 45				.text	3,$d5,"BNE"            ; $8b BNE
>bbf7	03 de 42 50 4c				.text	3,$de,"BPL"            ; $8c BPL
>bbfc	03 d5 42 52 41				.text	3,$d5,"BRA"            ; $8d BRA
>bc01	03 df 42 52 4b				.text	3,$df,"BRK"            ; $8e BRK
>bc06	03 db 42 56 43				.text	3,$db,"BVC"            ; $8f BVC
>bc0b	03 eb 42 56 53				.text	3,$eb,"BVS"            ; $90 BVS
>bc10	03 d2 43 4c 43				.text	3,$d2,"CLC"            ; $91 CLC
>bc15	03 d3 43 4c 44				.text	3,$d3,"CLD"            ; $92 CLD
>bc1a	03 d8 43 4c 49				.text	3,$d8,"CLI"            ; $93 CLI
>bc1f	03 e5 43 4c 56				.text	3,$e5,"CLV"            ; $94 CLV
>bc24	03 e0 43 4d 50				.text	3,$e0,"CMP"            ; $95 CMP
>bc29	03 eb 43 50 58				.text	3,$eb,"CPX"            ; $96 CPX
>bc2e	03 ec 43 50 59				.text	3,$ec,"CPY"            ; $97 CPY
>bc33	03 cc 44 45 43				.text	3,$cc,"DEC"            ; $98 DEC
>bc38	03 e1 44 45 58				.text	3,$e1,"DEX"            ; $99 DEX
>bc3d	03 e2 44 45 59				.text	3,$e2,"DEY"            ; $9a DEY
>bc42	03 e6 45 4f 52				.text	3,$e6,"EOR"            ; $9b EOR
>bc47	03 da 49 4e 43				.text	3,$da,"INC"            ; $9c INC
>bc4c	03 ef 49 4e 58				.text	3,$ef,"INX"            ; $9d INX
>bc51	03 f0 49 4e 59				.text	3,$f0,"INY"            ; $9e INY
>bc56	03 e7 4a 4d 50				.text	3,$e7,"JMP"            ; $9f JMP
>bc5b	03 ef 4a 53 52				.text	3,$ef,"JSR"            ; $a0 JSR
>bc60	03 d1 4c 44 41				.text	3,$d1,"LDA"            ; $a1 LDA
>bc65	03 e8 4c 44 58				.text	3,$e8,"LDX"            ; $a2 LDX
>bc6a	03 e9 4c 44 59				.text	3,$e9,"LDY"            ; $a3 LDY
>bc6f	03 f1 4c 53 52				.text	3,$f1,"LSR"            ; $a4 LSR
>bc74	03 ed 4e 4f 50				.text	3,$ed,"NOP"            ; $a5 NOP
>bc79	03 e2 4f 52 41				.text	3,$e2,"ORA"            ; $a6 ORA
>bc7e	03 d9 50 48 41				.text	3,$d9,"PHA"            ; $a7 PHA
>bc83	03 e8 50 48 50				.text	3,$e8,"PHP"            ; $a8 PHP
>bc88	03 f0 50 48 58				.text	3,$f0,"PHX"            ; $a9 PHX
>bc8d	03 f1 50 48 59				.text	3,$f1,"PHY"            ; $aa PHY
>bc92	03 dd 50 4c 41				.text	3,$dd,"PLA"            ; $ab PLA
>bc97	03 ec 50 4c 50				.text	3,$ec,"PLP"            ; $ac PLP
>bc9c	03 f4 50 4c 58				.text	3,$f4,"PLX"            ; $ad PLX
>bca1	03 f5 50 4c 59				.text	3,$f5,"PLY"            ; $ae PLY
>bca6	03 ed 52 4f 4c				.text	3,$ed,"ROL"            ; $af ROL
>bcab	03 f3 52 4f 52				.text	3,$f3,"ROR"            ; $b0 ROR
>bcb0	03 ef 52 54 49				.text	3,$ef,"RTI"            ; $b1 RTI
>bcb5	03 f9 52 54 53				.text	3,$f9,"RTS"            ; $b2 RTS
>bcba	03 d8 53 42 43				.text	3,$d8,"SBC"            ; $b3 SBC
>bcbf	03 db 53 45 43				.text	3,$db,"SEC"            ; $b4 SEC
>bcc4	03 dc 53 45 44				.text	3,$dc,"SED"            ; $b5 SED
>bcc9	03 e1 53 45 49				.text	3,$e1,"SEI"            ; $b6 SEI
>bcce	03 e8 53 54 41				.text	3,$e8,"STA"            ; $b7 STA
>bcd3	03 f7 53 54 50				.text	3,$f7,"STP"            ; $b8 STP
>bcd8	03 ff 53 54 58				.text	3,$ff,"STX"            ; $b9 STX
>bcdd	03 00 53 54 59				.text	3,$00,"STY"            ; $ba STY
>bce2	03 01 53 54 5a				.text	3,$01,"STZ"            ; $bb STZ
>bce7	03 ed 54 41 58				.text	3,$ed,"TAX"            ; $bc TAX
>bcec	03 ee 54 41 59				.text	3,$ee,"TAY"            ; $bd TAY
>bcf1	03 e8 54 52 42				.text	3,$e8,"TRB"            ; $be TRB
>bcf6	03 e9 54 53 42				.text	3,$e9,"TSB"            ; $bf TSB
>bcfb	03 ff 54 53 58				.text	3,$ff,"TSX"            ; $c0 TSX
>bd00	03 ed 54 58 41				.text	3,$ed,"TXA"            ; $c1 TXA
>bd05	03 ff 54 58 53				.text	3,$ff,"TXS"            ; $c2 TXS
>bd0a	03 ee 54 59 41				.text	3,$ee,"TYA"            ; $c3 TYA
>bd0f	ff					.text	$FF
.b2c4					ListConvertLine:
.b2c4	48		pha				pha 								; save indent on the stack
.b2c5	9c 1d 04	stz $041d			stz 	tbOffset
.b2c8	9c 2d 04	stz $042d			stz 	tokenBuffer
.b2cb	9c 29 04	stz $0429			stz 	currentListColour
.b2ce	a0 02		ldy #$02			ldy 	#2 							; convert line number to string
.b2d0	b1 30		lda ($30),y			lda 	(codePtr),y
.b2d2	aa		tax				tax
.b2d3	88		dey				dey
.b2d4	b1 30		lda ($30),y			lda 	(codePtr),y
.b2d6	20 af 92	jsr $92af			jsr 	LCLConvertInt16
.b2d9	85 36		sta $36				sta 	zTemp0 						; copy number into buffer
.b2db	86 37		stx $37				stx 	zTemp0+1
.b2dd	a9 89		lda #$89			lda 	#CLINumber+$80
.b2df	20 38 b4	jsr $b438			jsr 	LCLWriteColour
.b2e2	a0 00		ldy #$00			ldy 	#0
.b2e4					_LCCopyNumber:
.b2e4	b1 36		lda ($36),y			lda 	(zTemp0),y
.b2e6	20 41 b4	jsr $b441			jsr 	LCLWrite
.b2e9	c8		iny				iny
.b2ea	b1 36		lda ($36),y			lda 	(zTemp0),y
.b2ec	d0 f6		bne $b2e4			bne 	_LCCopyNumber
.b2ee	68		pla				pla 								; adjustment to indent
.b2ef	48		pha				pha 								; save on stack
.b2f0	10 0c		bpl $b2fe			bpl 	_LCNoAdjust 				; don't adjust indent if +ve, do after.
.b2f2	18		clc				clc 								; add to list indent and make 0 if goes -ve.
.b2f3	6d 26 04	adc $0426			adc 	listIndent
.b2f6	8d 26 04	sta $0426			sta 	listIndent
.b2f9	10 03		bpl $b2fe			bpl 	_LCNoAdjust
.b2fb	9c 26 04	stz $0426			stz 	listIndent
.b2fe					_LCNoAdjust:
.b2fe	18		clc				clc		 							; work out actual indent.
.b2ff	ad 26 04	lda $0426			lda 	listIndent
.b302	0a		asl a				asl 	a
.b303	69 06		adc #$06			adc 	#6
.b305	85 36		sta $36				sta 	zTemp0
.b307					_LCPadOut:
.b307	a9 20		lda #$20			lda 	#' '						; pad out to 6+indent characters
.b309	20 41 b4	jsr $b441			jsr 	LCLWrite
.b30c	ad 1d 04	lda $041d			lda 	tbOffset
.b30f	c5 36		cmp $36				cmp 	zTemp0
.b311	d0 f4		bne $b307			bne 	_LCPadOut
.b313	a0 03		ldy #$03			ldy 	#3 							; start position.
.b315					_LCMainLoop:
.b315	a9 8a		lda #$8a			lda 	#CLIPunctuation+$80
.b317	20 38 b4	jsr $b438			jsr 	LCLWriteColour
.b31a	b1 30		lda ($30),y			lda 	(codePtr),y
.b31c	c9 80		cmp #$80			cmp 	#KWC_EOL 					; end of line ?
.b31e	f0 17		beq $b337			beq 	_LCExit
.b320	c9 10		cmp #$10			cmp 	#16 						; 0-5 are the double punctuations
.b322	90 1e		bcc $b342			bcc 	_LCDoubles
.b324	c9 20		cmp #$20			cmp 	#32 						; 16-31 are shifted punctuation from 64-91
.b326	90 2a		bcc $b352			bcc 	_LCShiftPunc
.b328	c9 40		cmp #$40			cmp 	#64 						; 32-64 are as stored, punc and digits
.b32a	90 35		bcc $b361			bcc 	_LCPunctuation
.b32c	c9 80		cmp #$80			cmp 	#128 						; 64-127 are variable identifiers.
.b32e	90 51		bcc $b381			bcc 	_LCIdentifiers
.b330	c9 fe		cmp #$fe			cmp 	#254 						; 128-253 are tokenised words
.b332	90 73		bcc $b3a7			bcc 	_LCTokens
.b334	4c 07 b4	jmp $b407			jmp 	_LCData 					; 254-5 are data objects
.b337					_LCExit:
.b337	68		pla				pla 								; get old indent adjust
.b338	30 07		bmi $b341			bmi 	_LCExit2
.b33a	18		clc				clc 								; add to indent if +ve
.b33b	6d 26 04	adc $0426			adc 	listIndent
.b33e	8d 26 04	sta $0426			sta 	listIndent
.b341					_LCExit2:
.b341	60		rts				rts
.b342					_LCDoubles:
.b342	48		pha				pha
.b343	4a		lsr a				lsr 	a 							; put bit 2 into bit 1
.b344	29 02		and #$02			and 	#2
.b346	09 3c		ora #$3c			ora 	#60 						; make < >
.b348	20 41 b4	jsr $b441			jsr 	LCLWrite
.b34b	68		pla				pla 								; restore, do lower bit
.b34c	29 03		and #$03			and 	#3
.b34e	09 3c		ora #$3c			ora 	#60
.b350	80 0f		bra $b361			bra		_LCPunctuation 				; print, increment, loop
.b352					_LCShiftPunc:
.b352	aa		tax				tax 								; save in X
.b353	29 07		and #$07			and 	#7 							; lower 3 bits
.b355	f0 02		beq $b359			beq 	_LCNoAdd
.b357	09 18		ora #$18			ora 	#24 						; adds $18 to it.
.b359					_LCNoAdd:
.b359	e0 18		cpx #$18			cpx 	#24 						; if >= 24 add $20
.b35b	90 02		bcc $b35f			bcc 	_LCNoAdd2
.b35d	09 20		ora #$20			ora 	#32 						; adds $20
.b35f					_LCNoAdd2:
.b35f	09 40		ora #$40			ora 	#$40 						; shift into 64-127 range and fall through.
.b361					_LCPunctuation:
.b361	c9 3a		cmp #$3a			cmp 	#':' 						; check if :
.b363	d0 03		bne $b368			bne 	_LCPContinue
.b365	20 57 b4	jsr $b457			jsr 	LCLDeleteLastSpace 			; if so delete any preceding spaces
.b368					_LCPContinue:
.b368	c9 2e		cmp #$2e			cmp 	#'.'
.b36a	f0 08		beq $b374			beq 	_LCPIsConstant
.b36c	c9 30		cmp #$30			cmp 	#'0'
.b36e	90 0b		bcc $b37b			bcc 	_LCPNotConstant
.b370	c9 3a		cmp #$3a			cmp 	#'9'+1
.b372	b0 07		bcs $b37b			bcs 	_LCPNotConstant
.b374					_LCPIsConstant:
.b374	48		pha				pha
.b375	a9 8d		lda #$8d			lda 	#CLIConstant+$80
.b377	20 38 b4	jsr $b438			jsr 	LCLWriteColour
.b37a	68		pla				pla
.b37b					_LCPNotConstant:
.b37b	c8		iny				iny 								; consume character
.b37c	20 41 b4	jsr $b441			jsr 	LCLWrite 					; write it out.
.b37f	80 94		bra $b315			bra 	_LCMainLoop 				; go round again.
.b381					_LCIdentifiers:
.b381	18		clc				clc 								; convert to physical address
.b382	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.b384	85 37		sta $37				sta 	zTemp0+1
.b386	c8		iny				iny
.b387	b1 30		lda ($30),y			lda 	(codePtr),y
.b389	85 36		sta $36				sta 	zTemp0
.b38b	c8		iny				iny
.b38c	5a		phy				phy 								; save position
.b38d	a9 87		lda #$87			lda 	#CLIIdentifier+$80
.b38f	20 38 b4	jsr $b438			jsr 	LCLWriteColour
.b392	a0 07		ldy #$07			ldy 	#7 							; output the identifier at +8
.b394					_LCOutIdentifier:
.b394	c8		iny				iny
.b395	b1 36		lda ($36),y			lda 	(zTemp0),y					; bit 7 set = end.
.b397	29 7f		and #$7f			and 	#$7F
.b399	20 93 b4	jsr $b493			jsr 	LCLLowerCase
.b39c	20 41 b4	jsr $b441			jsr 	LCLWrite
.b39f	b1 36		lda ($36),y			lda 	(zTemp0),y				 	; ends when bit 7 set.
.b3a1	10 f1		bpl $b394			bpl 	_LCOutIdentifier
.b3a3	7a		ply				ply 								; restore position
.b3a4	4c 15 b3	jmp $b315			jmp 	_LCMainLoop
.b3a7					_LCTokens:
.b3a7	aa		tax				tax 								; token in X
.b3a8	a9 c4		lda #$c4			lda 	#((KeywordSet2) & $FF)
.b3aa	85 36		sta $36				sta 	0+zTemp0
.b3ac	a9 bb		lda #$bb			lda 	#((KeywordSet2) >> 8)
.b3ae	85 37		sta $37				sta 	1+zTemp0
.b3b0	e0 82		cpx #$82			cpx 	#$82
.b3b2	f0 16		beq $b3ca			beq 	_LCUseShift
.b3b4	a9 67		lda #$67			lda 	#((KeywordSet1) & $FF)
.b3b6	85 36		sta $36				sta 	0+zTemp0
.b3b8	a9 bb		lda #$bb			lda 	#((KeywordSet1) >> 8)
.b3ba	85 37		sta $37				sta 	1+zTemp0
.b3bc	e0 81		cpx #$81			cpx 	#$81
.b3be	f0 0a		beq $b3ca			beq 	_LCUseShift
.b3c0	a9 6a		lda #$6a			lda 	#((KeywordSet0) & $FF)
.b3c2	85 36		sta $36				sta 	0+zTemp0
.b3c4	a9 b9		lda #$b9			lda 	#((KeywordSet0) >> 8)
.b3c6	85 37		sta $37				sta 	1+zTemp0
.b3c8	80 01		bra $b3cb			bra 	_LCNoShift
.b3ca					_LCUseShift:
.b3ca	c8		iny				iny
.b3cb					_LCNoShift:
.b3cb	20 6b b4	jsr $b46b			jsr 	LCLCheckSpaceRequired 		; do we need a space ?
.b3ce	b1 30		lda ($30),y			lda 	(codePtr),y
.b3d0	aa		tax				tax 								; into X
.b3d1					_LCFindText:
.b3d1	ca		dex				dex
.b3d2	10 0e		bpl $b3e2			bpl 	_LCFoundText 				; found text.
.b3d4	b2 36		lda ($36)			lda 	(zTemp0) 					; length of text
.b3d6	1a		inc a				inc 	a 							; one extra for size
.b3d7	38		sec				sec 								; one extra for checksum
.b3d8	65 36		adc $36				adc 	zTemp0 						; go to next token
.b3da	85 36		sta $36				sta 	zTemp0
.b3dc	90 f3		bcc $b3d1			bcc 	_LCFindText
.b3de	e6 37		inc $37				inc 	zTemp0+1
.b3e0	80 ef		bra $b3d1			bra 	_LCFindText
.b3e2					_LCFoundText:
.b3e2	5a		phy				phy 								; save List position
.b3e3	b2 36		lda ($36)			lda 	(zTemp0)					; count to print
.b3e5	aa		tax				tax
.b3e6	a9 83		lda #$83			lda 	#CLIToken+$80
.b3e8	20 38 b4	jsr $b438			jsr 	LCLWriteColour
.b3eb	a0 02		ldy #$02			ldy 	#2
.b3ed					_LCCopyToken:
.b3ed	b1 36		lda ($36),y			lda 	(zTemp0),y
.b3ef	20 93 b4	jsr $b493			jsr 	LCLLowerCase
.b3f2	20 41 b4	jsr $b441			jsr 	LCLWrite
.b3f5	c8		iny				iny
.b3f6	ca		dex				dex
.b3f7	d0 f4		bne $b3ed			bne 	_LCCopyToken
.b3f9	c9 28		cmp #$28			cmp 	#"(" 						; if last char not ( print a space
.b3fb	f0 05		beq $b402			beq 	_LCNoSpace
.b3fd	a9 20		lda #$20			lda 	#' '
.b3ff	20 41 b4	jsr $b441			jsr 	LCLWrite
.b402					_LCNoSpace:
.b402	7a		ply				ply 								; restore position.
.b403	c8		iny				iny 								; consume token
.b404	4c 15 b3	jmp $b315			jmp 	_LCMainLoop 				; and go around again.
.b407					_LCData:
.b407	48		pha				pha 								; save type $FE/$FF
.b408	a2 24		ldx #$24			ldx 	#'$' 						; figure out $ or "
.b40a	c9 fe		cmp #$fe			cmp 	#$FE
.b40c	f0 07		beq $b415			beq 	_LCHaveOpener
.b40e	a2 22		ldx #$22			ldx 	#'"'
.b410	a9 81		lda #$81			lda 	#CLIData+$80
.b412	20 38 b4	jsr $b438			jsr 	LCLWriteColour
.b415					_LCHaveOpener:
.b415	8a		txa				txa 								; output prefix (# or ")
.b416	20 41 b4	jsr $b441			jsr 	LCLWrite
.b419	c8		iny				iny 								; get count
.b41a	b1 30		lda ($30),y			lda 	(codePtr),y
.b41c	aa		tax				tax
.b41d	c8		iny				iny 								; point at first character
.b41e					_LCOutData:
.b41e	b1 30		lda ($30),y			lda 	(codePtr),y
.b420	c9 00		cmp #$00			cmp 	#0
.b422	f0 03		beq $b427			beq 	_LCNoPrint
.b424	20 41 b4	jsr $b441			jsr 	LCLWrite
.b427					_LCNoPrint:
.b427	c8		iny				iny
.b428	ca		dex				dex
.b429	d0 f3		bne $b41e			bne 	_LCOutData
.b42b	68		pla				pla 								; closing " required ?
.b42c	c9 ff		cmp #$ff			cmp 	#$FF 						; not required for hex constant.
.b42e	d0 05		bne $b435			bne 	_LCNoQuote
.b430	a9 22		lda #$22			lda 	#'"'
.b432	20 41 b4	jsr $b441			jsr 	LCLWrite
.b435					_LCNoQuote:
.b435	4c 15 b3	jmp $b315			jmp 	_LCMainLoop
.b438					LCLWriteColour:
.b438	cd 29 04	cmp $0429			cmp 	currentListColour 			; has the colour changed
.b43b	8d 29 04	sta $0429			sta 	currentListColour 			; (update it anyway)
.b43e	d0 01		bne $b441			bne 	LCLWrite 					; if different, output it
.b440	60		rts				rts
.b441					LCLWrite:
.b441	da		phx				phx
.b442	ae 1d 04	ldx $041d			ldx 	tbOffset 					; write out make ASCIIZ
.b445	9d 2d 04	sta $042d,x			sta 	tokenBuffer,x
.b448	9e 2e 04	stz $042e,x			stz 	tokenBuffer+1,x
.b44b	ee 1d 04	inc $041d			inc 	tbOffset 					; bump the position
.b44e	09 00		ora #$00			ora 	#0 							; don't update last character if colour data
.b450	30 03		bmi $b455			bmi 	_LCLNoColour
.b452	8d 27 04	sta $0427			sta 	LCLastCharacter
.b455					_LCLNoColour:
.b455	fa		plx				plx
.b456	60		rts				rts
.b457					LCLDeleteLastSpace:
.b457	48		pha				pha
.b458	da		phx				phx
.b459	ae 1d 04	ldx $041d			ldx 	tbOffset
.b45c	f0 0a		beq $b468			beq 	_LCDLSExit
.b45e	bd 2c 04	lda $042c,x			lda 	tokenBuffer-1,x
.b461	c9 20		cmp #$20			cmp 	#' '
.b463	d0 03		bne $b468			bne 	_LCDLSExit
.b465	ce 1d 04	dec $041d			dec 	tbOffset
.b468					_LCDLSExit:
.b468	fa		plx				plx
.b469	68		pla				pla
.b46a	60		rts				rts
.b46b					LCLCheckSpaceRequired:
.b46b	ad 27 04	lda $0427			lda 	LCLastCharacter 			; check last character
.b46e	c9 24		cmp #$24			cmp 	#'$' 						; $ # and ) require that token space.
.b470	f0 1b		beq $b48d			beq 	_LCCSRSpace
.b472	c9 29		cmp #$29			cmp 	#')'
.b474	f0 17		beq $b48d			beq 	_LCCSRSpace
.b476	c9 23		cmp #$23			cmp 	#'#'
.b478	f0 13		beq $b48d			beq 	_LCCSRSpace
.b47a	20 93 b4	jsr $b493			jsr 	LCLLowerCase 				; saves a little effort
.b47d	c9 30		cmp #$30			cmp 	#"0" 						; check if it was 0-9 A-Z a-z if so need space.
.b47f	90 11		bcc $b492			bcc 	_LCCSRExit
.b481	c9 3a		cmp #$3a			cmp 	#"9"+1
.b483	90 08		bcc $b48d			bcc 	_LCCSRSpace
.b485	c9 61		cmp #$61			cmp 	#"a"
.b487	90 09		bcc $b492			bcc 	_LCCSRExit
.b489	c9 7b		cmp #$7b			cmp 	#"z"+1
.b48b	b0 05		bcs $b492			bcs 	_LCCSRExit
.b48d					_LCCSRSpace:
.b48d	a9 20		lda #$20			lda 	#' '
.b48f	20 41 b4	jsr $b441			jsr 	LCLWrite
.b492					_LCCSRExit:
.b492	60		rts				rts
.b493					LCLLowerCase:
.b493	c9 41		cmp #$41			cmp 	#"A"
.b495	90 06		bcc $b49d			bcc 	_LCLLCOut
.b497	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b499	b0 02		bcs $b49d			bcs 	_LCLLCOut
.b49b	69 20		adc #$20			adc 	#$20
.b49d					_LCLLCOut:
.b49d	60		rts				rts
.b49e					LCLUpperCase:
.b49e	c9 61		cmp #$61			cmp 	#"a"
.b4a0	90 06		bcc $b4a8			bcc 	_LCLUCOut
.b4a2	c9 7b		cmp #$7b			cmp 	#"z"+1
.b4a4	b0 02		bcs $b4a8			bcs 	_LCLUCOut
.b4a6	e9 1f		sbc #$1f			sbc 	#$1F
.b4a8					_LCLUCOut:
.b4a8	60		rts				rts
.b4a9					TOKSearchTable:
.b4a9	84 37		sty $37				sty 	zTemp0+1 					; (zTemp0),y points to current token being tested.
.b4ab	85 36		sta $36				sta 	zTemp0
.b4ad	a0 00		ldy #$00			ldy 	#0
.b4af	a9 80		lda #$80			lda 	#$80 						; token # so we know which one we are looking at
.b4b1	85 38		sta $38				sta 	zTemp1
.b4b3					_TSTLoop:
.b4b3	b1 36		lda ($36),y			lda 	(zTemp0),y 					; length, 0 (skip) -ve (end)
.b4b5	30 49		bmi $b500			bmi 	_TSTFail 					; -ve = end of table, so fail.
.b4b7	f0 2e		beq $b4e7			beq 	_TSTNext 					; zero, check next as it's a dummy (e.g. EOL, SHIFT)
.b4b9	c8		iny				iny 								; get the hash
.b4ba	b1 36		lda ($36),y			lda 	(zTemp0),y
.b4bc	88		dey				dey
.b4bd	cd 03 04	cmp $0403			cmp 	identHash 					; check they match with the identifier hash, if not go to next
.b4c0	d0 25		bne $b4e7			bne 	_TSTNext
.b4c2	ad 02 04	lda $0402			lda 	identTypeEnd 				; get length of identifier from end-start
.b4c5	38		sec				sec
.b4c6	ed 00 04	sbc $0400			sbc 	identStart
.b4c9	d1 36		cmp ($36),y			cmp 	(zTemp0),y 					; compare against the length in the table, no match, then return.
.b4cb	d0 1a		bne $b4e7			bne 	_TSTNext
.b4cd	5a		phy				phy 								; save Y , we might fail to match.
.b4ce	c8		iny				iny 								; point to text
.b4cf	c8		iny				iny
.b4d0	ae 00 04	ldx $0400			ldx 	identStart 					; offset in line buffer in X
.b4d3					_TSTCompareName:
.b4d3	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; compare text.
.b4d6	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.b4d8	d0 0c		bne $b4e6			bne 	_TSTNextPullY 				; fail, pullY and do next
.b4da	e8		inx				inx
.b4db	c8		iny				iny
.b4dc	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; complete match.
.b4df	d0 f2		bne $b4d3			bne 	_TSTCompareName
.b4e1	7a		ply				ply 								; throw Y
.b4e2	a5 38		lda $38				lda 	zTemp1 						; get token #
.b4e4	38		sec				sec 								; return with CS = passed.
.b4e5	60		rts				rts
.b4e6					_TSTNextPullY:
.b4e6	7a		ply				ply 								; restore current, fall through.
.b4e7					_TSTNext:
.b4e7	e6 38		inc $38				inc 	zTemp1 						; token counter
.b4e9	98		tya				tya
.b4ea	18		clc				clc
.b4eb	71 36		adc ($36),y			adc 	(zTemp0),y 					; add [Length] + 2 to Y
.b4ed	1a		inc a				inc 	a 							; +1
.b4ee	1a		inc a				inc 	a 							; +2
.b4ef	a8		tay				tay
.b4f0	10 c1		bpl $b4b3			bpl 	_TSTLoop 					; if Y < $80 loop back
.b4f2	98		tya				tya 								; add Y to zTemp0 and reset Y
.b4f3	a0 00		ldy #$00			ldy 	#0   						; so we can use Y to search fast
.b4f5	18		clc				clc  								; but have tables > 255 bytes
.b4f6	65 36		adc $36				adc 	zTemp0 						; when Y gets >= 128 we reset Y
.b4f8	85 36		sta $36				sta 	zTemp0 						; and adjust the table pointer/
.b4fa	90 b7		bcc $b4b3			bcc 	_TSTLoop
.b4fc	e6 37		inc $37				inc 	zTemp0+1
.b4fe	80 b3		bra $b4b3			bra 	_TSTLoop
.b500					_TSTFail:
.b500	18		clc				clc
.b501	60		rts				rts
.b502					TokeniseLine:
.b502	20 8a b6	jsr $b68a			jsr 	LCLFixLineBufferCase 		; fix line case
.b505	a9 03		lda #$03			lda 	#3 							; reset the token buffer to empty
.b507	8d 2a 04	sta $042a			sta 	tokenOffset 				; (3 bytes for line number & offset)
.b50a	9c 2b 04	stz $042b			stz 	tokenLineNumber
.b50d	9c 2c 04	stz $042c			stz 	tokenLineNumber+1
.b510	a2 ff		ldx #$ff			ldx 	#$FF
.b512					_TKFindFirst:
.b512	e8		inx				inx
.b513	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.b516	f0 79		beq $b591			beq 	_TKExit
.b518	c9 20		cmp #$20			cmp 	#' '
.b51a	90 f6		bcc $b512			bcc 	_TKFindFirst
.b51c	c9 30		cmp #$30			cmp 	#'0'
.b51e	90 07		bcc $b527			bcc 	_TKNoLineNumber
.b520	c9 3a		cmp #$3a			cmp 	#'9'+1
.b522	b0 03		bcs $b527			bcs 	_TKNoLineNumber
.b524	20 b4 b6	jsr $b6b4			jsr 	TOKExtractLineNumber
.b527					_TKNoLineNumber:
.b527					_TKTokeniseLoop:
.b527	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; next character, exit if zero EOL.
.b52a	f0 65		beq $b591			beq 	_TKExit
.b52c	e8		inx				inx
.b52d	c9 20		cmp #$20			cmp 	#' '
.b52f	f0 f6		beq $b527			beq 	_TKTokeniseLoop 			; keep looping if space found.
.b531	ca		dex				dex 								; undo last get, A contains character, X is position.
.b532	c9 5f		cmp #$5f			cmp 	#'_'						; _ A-Z is identifier *or* token
.b534	f0 61		beq $b597			beq 	_TKTokeniseIdentifier 		; (already case converted outside string constants)
.b536	c9 41		cmp #$41			cmp 	#'A'
.b538	90 04		bcc $b53e			bcc 	_TKTokenisePunctuation
.b53a	c9 5b		cmp #$5b			cmp 	#'Z'+1
.b53c	90 59		bcc $b597			bcc 	_TKTokeniseIdentifier
.b53e					_TKTokenisePunctuation:
.b53e	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.b540	f0 27		beq $b569			beq 	_TKString
.b542	c9 24		cmp #$24			cmp 	#'$'						; hexadecimal constant ($ only appears at end of identifiers)
.b544	f0 28		beq $b56e			beq 	_TKHexConstant
.b546	c9 3c		cmp #$3c			cmp 	#'<' 						; check for < > handlers - these are for <> <= >= >> <<
.b548	f0 29		beq $b573			beq 	_TKCheckDouble
.b54a	c9 3e		cmp #$3e			cmp 	#'>'
.b54c	f0 25		beq $b573			beq 	_TKCheckDouble
.b54e					_TKStandardPunctuation:
.b54e	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get the punctuation token back.
.b551	c9 40		cmp #$40			cmp 	#64 						; are we >= 64
.b553	90 0e		bcc $b563			bcc 	_TKNoShift
.b555	48		pha				pha 								; save. we are about to convert this punctuation token from
.b556	29 07		and #$07			and 	#7 							; lower 3 bits in zTemp0
.b558	85 36		sta $36				sta 	zTemp0
.b55a	68		pla				pla
.b55b	29 20		and #$20			and 	#32 						; bit 5
.b55d	4a		lsr a				lsr 	a 							; shift into bit 3
.b55e	4a		lsr a				lsr 	a
.b55f	05 36		ora $36				ora 	zTemp0
.b561	09 10		ora #$10			ora 	#$10						; now in the range 16-31
.b563					_TKNoShift:
.b563	20 f9 b6	jsr $b6f9			jsr 	TOKWriteByte 				; write the punctuation character
.b566	e8		inx				inx 								; consume the character
.b567	80 be		bra $b527			bra 	_TKTokeniseLoop 			; and loop round again.
.b569					_TKString:
.b569	20 19 b6	jsr $b619			jsr 	TOKTokenString
.b56c	80 b9		bra $b527			bra 	_TKTokeniseLoop
.b56e					_TKHexConstant:
.b56e	20 54 b6	jsr $b654			jsr 	TOKHexConstant
.b571	80 b4		bra $b527			bra 	_TKTokeniseLoop
.b573					_TKCheckDouble:
.b573	bd 2b 05	lda $052b,x			lda 	lineBuffer+1,x 				; get next character
.b576	c9 3c		cmp #$3c			cmp 	#'<'						; if not < = > which are ASCII consecutive go back
.b578	90 d4		bcc $b54e			bcc 	_TKStandardPunctuation 		; and do the normal punctuation handler.
.b57a	c9 3f		cmp #$3f			cmp 	#'>'+1
.b57c	b0 d0		bcs $b54e			bcs 	_TKStandardPunctuation
.b57e	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; this is < (60) or > (62)
.b581	29 02		and #$02			and 	#2 							; now < (0) or > (2)
.b583	0a		asl a				asl 	a 							; now < (0) or > (4), CC also
.b584	7d 2b 05	adc $052b,x			adc 	lineBuffer+1,x 				; add < = > codes - < code
.b587	38		sec				sec
.b588	e9 3c		sbc #$3c			sbc 	#'<'
.b58a	20 f9 b6	jsr $b6f9			jsr 	TOKWriteByte 				; this is in the range 0-7
.b58d	e8		inx				inx 								; consume both
.b58e	e8		inx				inx
.b58f	80 96		bra $b527			bra 	_TKTokeniseLoop
.b591	a9 80		lda #$80	_TKExit:lda 	#KWC_EOL 					; write end of line byte
.b593	20 f9 b6	jsr $b6f9			jsr 	TOKWriteByte
.b596	60		rts				rts
.b597					_TKTokeniseIdentifier:
.b597	8e 00 04	stx $0400			stx 	identStart 					; save start
.b59a	9c 04 04	stz $0404			stz 	identTypeByte 				; zero the type byte
.b59d					_TKCheckLoop:
.b59d	e8		inx				inx 								; look at next, we know first is identifier already.
.b59e	bd 2a 05	lda $052a,x			lda  	lineBuffer,x
.b5a1	c9 5f		cmp #$5f			cmp 	#"_" 						; legal char _ 0-9 A-Z
.b5a3	f0 f8		beq $b59d			beq 	_TKCheckLoop
.b5a5	c9 30		cmp #$30			cmp	 	#"0"
.b5a7	90 0c		bcc $b5b5			bcc 	_TKEndIdentifier
.b5a9	c9 3a		cmp #$3a			cmp 	#"9"+1
.b5ab	90 f0		bcc $b59d			bcc 	_TKCheckLoop
.b5ad	c9 41		cmp #$41			cmp	 	#"A"
.b5af	90 04		bcc $b5b5			bcc 	_TKEndIdentifier
.b5b1	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b5b3	90 e8		bcc $b59d			bcc 	_TKCheckLoop
.b5b5					_TKEndIdentifier:
.b5b5	8e 01 04	stx $0401			stx 	identTypeStart 				; save start of type text (if any !)
.b5b8	a0 08		ldy #$08			ldy 	#$08 						; this is the identifier type byte for #
.b5ba	c9 23		cmp #$23			cmp 	#"#"						; followed by #
.b5bc	f0 06		beq $b5c4			beq 	_TKHasTypeCharacter
.b5be	a0 10		ldy #$10			ldy 	#$10 						; this is the identifier type byte for $
.b5c0	c9 24		cmp #$24			cmp 	#"$"						; followed by $ or #
.b5c2	d0 07		bne $b5cb			bne 	_TKNoTypeCharacter
.b5c4					_TKHasTypeCharacter:
.b5c4	8c 04 04	sty $0404			sty 	identTypeByte 				; has # or $, save the type
.b5c7	e8		inx				inx 								; consume the type character
.b5c8	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.b5cb					_TKNoTypeCharacter:
.b5cb	c9 28		cmp #$28			cmp 	#"("						; is it open parenthesis (e.g. array)
.b5cd	d0 09		bne $b5d8			bne 	_TKNoArray
.b5cf	e8		inx				inx 								; skip the (
.b5d0	ad 04 04	lda $0404			lda 	identTypeByte 				; set bit 2 (e.g. array) in type byte
.b5d3	09 04		ora #$04			ora 	#$04
.b5d5	8d 04 04	sta $0404			sta 	identTypeByte
.b5d8					_TKNoArray:
.b5d8	8e 02 04	stx $0402			stx 	identTypeEnd 				; save end marker, e.g. continue from here.
.b5db	20 75 b6	jsr $b675			jsr 	TOKCalculateHash 			; calculate the has for those tokens
.b5de	a0 b9		ldy #$b9			ldy 	#(KeywordSet0) >> 8
.b5e0	a9 6a		lda #$6a			lda 	#(KeywordSet0) & $FF
.b5e2	20 a9 b4	jsr $b4a9			jsr 	TOKSearchTable
.b5e5	a2 00		ldx #$00			ldx 	#0
.b5e7	b0 1f		bcs $b608			bcs 	_TKFoundToken
.b5e9	a0 bb		ldy #$bb			ldy 	#(KeywordSet1) >> 8
.b5eb	a9 67		lda #$67			lda 	#(KeywordSet1) & $FF
.b5ed	20 a9 b4	jsr $b4a9			jsr 	TOKSearchTable
.b5f0	a2 81		ldx #$81			ldx 	#$81
.b5f2	b0 14		bcs $b608			bcs 	_TKFoundToken
.b5f4	a0 bb		ldy #$bb			ldy 	#(KeywordSet2) >> 8
.b5f6	a9 c4		lda #$c4			lda 	#(KeywordSet2) & $FF
.b5f8	20 a9 b4	jsr $b4a9			jsr 	TOKSearchTable
.b5fb	a2 82		ldx #$82			ldx 	#$82
.b5fd	b0 09		bcs $b608			bcs 	_TKFoundToken
.b5ff	20 05 b7	jsr $b705			jsr 	TOKCheckCreateVariableRecord ; failed all, it's a variable, create record if does not exist.
.b602	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.b605	4c 27 b5	jmp $b527			jmp 	_TKTokeniseLoop 			; and go round again.
.b608					_TKFoundToken:
.b608	48		pha				pha 								; save token
.b609	8a		txa				txa 								; shift in X, is there one ?
.b60a	f0 03		beq $b60f			beq 	_TKNoTShift
.b60c	20 f9 b6	jsr $b6f9			jsr 	TOKWriteByte 				; if so, write it out
.b60f					_TKNoTShift:
.b60f	68		pla				pla 								; restore and write token
.b610	20 f9 b6	jsr $b6f9			jsr 	TOKWriteByte
.b613	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.b616	4c 27 b5	jmp $b527			jmp 	_TKTokeniseLoop 			; and go round again.
.b619					TOKTokenString:
.b619	a9 ff		lda #$ff			lda 	#KWC_STRING 				; string token.
.b61b	20 f9 b6	jsr $b6f9			jsr 	TOKWriteByte
.b61e	e8		inx				inx									; start of quoted string.
.b61f	da		phx				phx 								; push start of string on top
.b620	ca		dex				dex 								; because we pre-increment
.b621					_TSFindEnd:
.b621	e8		inx				inx
.b622	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; next character
.b625	f0 04		beq $b62b			beq 	_TSEndOfString 				; no matching quote, we don't mind.
.b627	c9 22		cmp #$22			cmp 	#'"' 						; go back if quote not found
.b629	d0 f6		bne $b621			bne 	_TSFindEnd
.b62b					_TSEndOfString:
.b62b	7a		ply				ply  								; so now Y is first character, X is character after end.
.b62c	48		pha				pha 								; save terminating character
.b62d	20 35 b6	jsr $b635			jsr 	TOKWriteBlockXY 			; write X to Y as a data block
.b630	68		pla				pla 								; terminating character
.b631	f0 01		beq $b634			beq 	_TSNotQuote					; if it wasn't EOS skip it
.b633	e8		inx				inx
.b634					_TSNotQuote:
.b634	60		rts				rts
.b635					TOKWriteBlockXY:
.b635	86 36		stx $36				stx 	zTemp0 						; save end character
.b637	98		tya				tya 								; use 2's complement to work out the byte size
.b638	49 ff		eor #$ff			eor 	#$FF
.b63a	38		sec				sec
.b63b	65 36		adc $36				adc 	zTemp0
.b63d	1a		inc a				inc 	a 							; one extra for NULL
.b63e	20 f9 b6	jsr $b6f9			jsr 	TOKWriteByte
.b641					_TOBlockLoop:
.b641	c4 36		cpy $36				cpy 	zTemp0 						; exit if reached the end
.b643	f0 09		beq $b64e			beq 	_TOBlockExit
.b645	b9 2a 05	lda $052a,y			lda 	lineBuffer,y 				; write byte out.
.b648	20 f9 b6	jsr $b6f9			jsr 	TOKWriteByte
.b64b	c8		iny				iny
.b64c	80 f3		bra $b641			bra 	_TOBlockLoop
.b64e					_TOBlockExit:
.b64e	a9 00		lda #$00			lda 	#0 							; add NULL.
.b650	20 f9 b6	jsr $b6f9			jsr 	TOKWriteByte
.b653	60		rts				rts
.b654					TOKHexConstant:
.b654	a9 fe		lda #$fe			lda 	#KWC_HEXCONST 				; hex constant token.
.b656	20 f9 b6	jsr $b6f9			jsr 	TOKWriteByte
.b659	e8		inx				inx									; start of quoted string.
.b65a	da		phx				phx 								; push start of constant on top
.b65b	ca		dex				dex
.b65c					_THFindLoop:
.b65c	e8		inx				inx 	 							; this is stored in a block, so find out how long
.b65d	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; the hex constant is.
.b660	c9 30		cmp #$30			cmp 	#"0"
.b662	90 0c		bcc $b670			bcc 	_THFoundEnd
.b664	c9 3a		cmp #$3a			cmp 	#"9"+1
.b666	90 f4		bcc $b65c			bcc 	_THFindLoop
.b668	c9 41		cmp #$41			cmp 	#"A"
.b66a	90 04		bcc $b670			bcc 	_THFoundEnd
.b66c	c9 47		cmp #$47			cmp 	#"F"+1
.b66e	90 ec		bcc $b65c			bcc 	_THFindLoop
.b670					_THFoundEnd:
.b670	7a		ply				ply 								; restore start
.b671	20 35 b6	jsr $b635			jsr 	TOKWriteBlockXY 			; output the block
.b674	60		rts				rts
.b675					TOKCalculateHash:
.b675	da		phx				phx
.b676	ae 00 04	ldx $0400			ldx 	identStart 					; needs to be same as in tokens.py - simple sum at present.
.b679	a9 00		lda #$00			lda 	#0
.b67b					_TCHLoop:
.b67b	18		clc				clc
.b67c	7d 2a 05	adc $052a,x			adc 	lineBuffer,x
.b67f	e8		inx				inx
.b680	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; do the whole thing including type and array markers.
.b683	d0 f6		bne $b67b			bne 	_TCHLoop
.b685	8d 03 04	sta $0403			sta 	identHash 					; save the hash
.b688	fa		plx				plx
.b689	60		rts				rts
.b68a					LCLFixLineBufferCase:
.b68a	a2 00		ldx #$00			ldx 	#0
.b68c					_FLBCLoop:
.b68c	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get next character
.b68f	f0 22		beq $b6b3			beq 	_FLBCExit 					; end of string.
.b691	c9 22		cmp #$22			cmp 	#'"'						; quote, go to in quotes
.b693	f0 11		beq $b6a6			beq 	_FLBCInQuotes
.b695	e8		inx				inx
.b696	c9 61		cmp #$61			cmp 	#'a'						; needs capitalising ?
.b698	90 f2		bcc $b68c			bcc 	_FLBCLoop
.b69a	c9 7b		cmp #$7b			cmp 	#'z'+1
.b69c	b0 ee		bcs $b68c			bcs 	_FLBCLoop
.b69e	38		sec				sec 								; make U/C
.b69f	e9 20		sbc #$20			sbc 	#32
.b6a1	9d 29 05	sta $0529,x			sta	 	lineBuffer-1,x 				; write back
.b6a4	80 e6		bra $b68c			bra 	_FLBCLoop
.b6a6					_FLBCInQuotes:
.b6a6	e8		inx				inx 								; advance
.b6a7	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get next
.b6aa	f0 07		beq $b6b3			beq 	_FLBCExit 					; exit on EOS
.b6ac	c9 22		cmp #$22			cmp 	#'"' 				 		; until " found
.b6ae	d0 f6		bne $b6a6			bne 	_FLBCInQuotes
.b6b0	e8		inx				inx 								; skip over it
.b6b1	80 d9		bra $b68c			bra 	_FLBCLoop
.b6b3					_FLBCExit:
.b6b3	60		rts				rts
.b6b4					TOKExtractLineNumber:
.b6b4	ad 2c 04	lda $042c			lda 	tokenLineNumber+1 			; push current value on stack
.b6b7	48		pha				pha
.b6b8	ad 2b 04	lda $042b			lda 	tokenLineNumber
.b6bb	48		pha				pha
.b6bc	20 f2 b6	jsr $b6f2			jsr 	_LCLNTimes2 				; line # x 2
.b6bf	20 f2 b6	jsr $b6f2			jsr 	_LCLNTimes2 				; line # x 4
.b6c2	18		clc				clc 								; add stacked value
.b6c3	68		pla				pla
.b6c4	6d 2b 04	adc $042b			adc 	tokenLineNumber
.b6c7	8d 2b 04	sta $042b			sta 	tokenLineNumber
.b6ca	68		pla				pla
.b6cb	6d 2c 04	adc $042c			adc 	tokenLineNumber+1
.b6ce	8d 2c 04	sta $042c			sta 	tokenLineNumber+1 			; line # x 5
.b6d1	20 f2 b6	jsr $b6f2			jsr 	_LCLNTimes2 				; line # x 10
.b6d4	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get and consume character
.b6d7	e8		inx				inx
.b6d8	29 0f		and #$0f			and 	#15 						; add to line #
.b6da	18		clc				clc
.b6db	6d 2b 04	adc $042b			adc 	tokenLineNumber
.b6de	8d 2b 04	sta $042b			sta 	tokenLineNumber
.b6e1	90 03		bcc $b6e6			bcc 	_TLENNoCarry
.b6e3	ee 2c 04	inc $042c			inc 	tokenLineNumber+1
.b6e6					_TLENNoCarry:
.b6e6	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; more digits ?
.b6e9	c9 30		cmp #$30			cmp 	#'0'
.b6eb	90 04		bcc $b6f1			bcc 	_TLENExit
.b6ed	c9 3a		cmp #$3a			cmp 	#'9'+1
.b6ef	90 c3		bcc $b6b4			bcc 	TOKExtractLineNumber
.b6f1					_TLENExit:
.b6f1	60		rts				rts
.b6f2					_LCLNTimes2:
.b6f2	0e 2b 04	asl $042b			asl 	tokenLineNumber 			; doubles tokenLineNumber.
.b6f5	2e 2c 04	rol $042c			rol 	tokenLineNumber+1
.b6f8	60		rts				rts
.b6f9					TOKWriteByte:
.b6f9	da		phx				phx
.b6fa	ae 2a 04	ldx $042a			ldx 	tokenOffset 				; next slot to write to
.b6fd	9d 2a 04	sta $042a,x			sta 	tokenOffset,x 				; write byte out
.b700	ee 2a 04	inc $042a			inc 	tokenOffset 				; advance slot.
.b703	fa		plx				plx
.b704	60		rts				rts
.b705					TOKCheckCreateVariableRecord:
.b705	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.b707	85 36		sta $36				sta 	0+zTemp0
.b709	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.b70b	85 37		sta $37				sta 	1+zTemp0
.b70d					_CCVSearch:
.b70d	b2 36		lda ($36)			lda 	(zTemp0) 					; end of list
.b70f	f0 2c		beq $b73d			beq 	_CCVFail
.b711	a0 01		ldy #$01			ldy 	#1 							; read the hash
.b713	b1 36		lda ($36),y			lda 	(zTemp0),y 					; does it match ?
.b715	cd 03 04	cmp $0403			cmp 	identHash 	  				; if not, try the next.
.b718	d0 16		bne $b730			bne 	_CCVNext
.b71a	a0 08		ldy #$08			ldy 	#8 							; name in variable record
.b71c	ae 00 04	ldx $0400			ldx 	identStart
.b71f					_CCVCompare:
.b71f	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; xor them. zero if the same, except
.b722	51 36		eor ($36),y			eor 	(zTemp0),y 					; bit 7 is used for EOS.
.b724	e8		inx				inx 								; advance pointers
.b725	c8		iny				iny
.b726	0a		asl a				asl 	a 							; A = 0 if they match, CS if end.
.b727	d0 07		bne $b730			bne 	_CCVNext  					; didn't match go to next.
.b729	90 f4		bcc $b71f			bcc 	_CCVCompare 				; not finished yet.
.b72b	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; matched whole thing ?
.b72e	f0 47		beq $b777			beq 	_CCVFound 					; yes, we were successful
.b730					_CCVNext:
.b730	18		clc				clc 								; go to next record.
.b731	b2 36		lda ($36)			lda 	(zTemp0) 					; add offset to pointer
.b733	65 36		adc $36				adc 	zTemp0
.b735	85 36		sta $36				sta 	zTemp0
.b737	90 d4		bcc $b70d			bcc 	_CCVSearch
.b739	e6 37		inc $37				inc 	zTemp0+1
.b73b	80 d0		bra $b70d			bra 	_CCVSearch
.b73d					_CCVFail:
.b73d	a5 37		lda $37				lda 	zTemp0+1 					; are we out of space
.b73f	c9 1e		cmp #$1e			cmp 	#(EndVariableSpace-512) >> 8
.b741	b0 44		bcs $b787			bcs 	_CCVMemory
.b743	a0 01		ldy #$01			ldy 	#1 							; create the new record. Offset 1 is hash
.b745	ad 03 04	lda $0403			lda 	identHash
.b748	91 36		sta ($36),y			sta 	(zTemp0),y
.b74a	c8		iny				iny 								; offset 2 is the type byte
.b74b	ad 04 04	lda $0404			lda 	identTypeByte
.b74e	91 36		sta ($36),y			sta 	(zTemp0),y
.b750	c8		iny				iny
.b751					_CCVData:
.b751	a9 00		lda #$00			lda 	#0 							; erase data 3-7 (the 5 value bytes)
.b753	91 36		sta ($36),y			sta 	(zTemp0),y
.b755	c8		iny				iny
.b756	c0 08		cpy #$08			cpy 	#8
.b758	90 f7		bcc $b751			bcc 	_CCVData
.b75a	ae 00 04	ldx $0400			ldx 	identStart 					; copy name into 8 on.
.b75d					_CCVCopyName:
.b75d	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.b760	91 36		sta ($36),y			sta 	(zTemp0),y
.b762	e8		inx				inx
.b763	c8		iny				iny
.b764	ec 02 04	cpx $0402			cpx 	identTypeEnd
.b767	d0 f4		bne $b75d			bne 	_CCVCopyName
.b769	98		tya				tya 								; patch offset
.b76a	92 36		sta ($36)			sta 	(zTemp0)
.b76c	a9 00		lda #$00			lda 	#0 							; offset for next is zero.
.b76e	91 36		sta ($36),y			sta 	(zTemp0),y
.b770	88		dey				dey
.b771	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set bit 7 of last bit
.b773	09 80		ora #$80			ora 	#$80
.b775	91 36		sta ($36),y			sta 	(zTemp0),y
.b777					_CCVFound:
.b777	a5 37		lda $37				lda 	zTemp0+1 					; write out MSB
.b779	38		sec				sec
.b77a	e9 10		sbc #$10			sbc 	#(VariableSpace >> 8) 		; offset from the start of the variable token
.b77c	09 40		ora #$40			ora 	#$40 						; make it a writeable token $4000-$7FFF
.b77e	20 f9 b6	jsr $b6f9			jsr 	TOKWriteByte
.b781	a5 36		lda $36				lda 	zTemp0 						; write out LSB
.b783	20 f9 b6	jsr $b6f9			jsr 	TOKWriteByte
.b786	60		rts				rts
.b787					_CCVMemory:
.b787	a9 06		lda #$06		lda	#6
.b789	4c 40 8e	jmp $8e40		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_sound.module

=1					soundIntegrated=1
.b78c					SNDCheckChannel:
.b78c	aa		tax				tax
.b78d	bd 8b 07	lda $078b,x			lda 	SNDTimeLeft,x 				; currently playing a note
.b790	d0 38		bne $b7ca			bne 	_SNDCCExit
.b792	da		phx				phx 								; save current channel
.b793	8a		txa				txa 								; put in A
.b794	20 10 b8	jsr $b810			jsr 	SNDFindNextNoteForA 		; is there a note for A in the queue ?
.b797	68		pla				pla 								; channel # in A
.b798	90 30		bcc $b7ca			bcc 	_SNDCCExit  				; nothing in the queue for this channel, exit.
.b79a	a8		tay				tay 								; Y is the channel #
.b79b	bd 80 06	lda $0680,x			lda 	SNDQueue+1,x 				; copy data into the slot.
.b79e	99 7f 07	sta $077f,y			sta 	SNDPitchLow,y
.b7a1	bd 81 06	lda $0681,x			lda 	SNDQueue+2,x
.b7a4	99 83 07	sta $0783,y			sta 	SNDPitchHigh,y
.b7a7	bd 82 06	lda $0682,x			lda 	SNDQueue+3,x
.b7aa	99 87 07	sta $0787,y			sta 	SNDVolume,y
.b7ad	bd 83 06	lda $0683,x			lda 	SNDQueue+4,x
.b7b0	99 8b 07	sta $078b,y			sta 	SNDTimeLeft,y
.b7b3	bd 84 06	lda $0684,x			lda 	SNDQueue+5,x
.b7b6	99 8f 07	sta $078f,y			sta 	SNDAdjustLow,y
.b7b9	bd 85 06	lda $0685,x			lda 	SNDQueue+6,x
.b7bc	99 93 07	sta $0793,y			sta 	SNDAdjustHigh,y
.b7bf	5a		phy				phy 								; save channel #
.b7c0	20 2a b8	jsr $b82a			jsr 	SNDDeleteXFromQueue 		; delete record at X from queue
.b7c3	ce 7e 06	dec $067e			dec 	SNDLength 					; reduce the queue length.
.b7c6	68		pla				pla
.b7c7	20 cb b7	jsr $b7cb			jsr 	SNDUpdateNote 				; update channel A
.b7ca					_SNDCCExit:
.b7ca	60		rts				rts
.b7cb					SNDUpdateNote:
.b7cb	aa		tax				tax 								; so we can access records
.b7cc	0a		asl a				asl 	a 							; convert it to a channel bit pair in 5,6
.b7cd	0a		asl a				asl 	a
.b7ce	0a		asl a				asl 	a
.b7cf	0a		asl a				asl 	a
.b7d0	0a		asl a				asl 	a
.b7d1	8d 7d 06	sta $067d			sta 	SNDChannelBits
.b7d4	bd 8b 07	lda $078b,x			lda 	SNDTimeLeft,x 				; are we silent
.b7d7	f0 2e		beq $b807			beq 	_SNDUNIsSilent
.b7d9	ad 7d 06	lda $067d			lda 	SNDChannelBits 				; push channel bits on stack
.b7dc	48		pha				pha
.b7dd	bd 7f 07	lda $077f,x			lda 	SNDPitchLow,x 				; get 4 lowest bits of pitch.
.b7e0	29 0f		and #$0f			and 	#$0F
.b7e2	0d 7d 06	ora $067d			ora 	SNDChannelBits 				; set channel bits
.b7e5	09 80		ora #$80			ora 	#$80 						; write to pitch register
.b7e7	20 74 b8	jsr $b874			jsr 	SNDWritePorts
.b7ea	bd 83 07	lda $0783,x			lda 	SNDPitchHigh,x 				; pitch high => channel temp.
.b7ed	8d 7d 06	sta $067d			sta 	SNDChannelBits
.b7f0	bd 7f 07	lda $077f,x			lda 	SNDPitchLow,x
.b7f3	4e 7d 06	lsr $067d			lsr 	SNDChannelBits 				; shift 2 LSBs into MSB of A
.b7f6	6a		ror a				ror 	a
.b7f7	4e 7d 06	lsr $067d			lsr 	SNDChannelBits
.b7fa	6a		ror a				ror 	a
.b7fb	4a		lsr a				lsr 	a 							; put in bits 0-5
.b7fc	4a		lsr a				lsr 	a
.b7fd	20 74 b8	jsr $b874			jsr 	SNDWritePorts 				; write as rest of pitch register
.b800	68		pla				pla
.b801	09 90		ora #$90			ora 	#$90 						; set to write minimum attentuation.
.b803	20 74 b8	jsr $b874			jsr 	SNDWritePorts
.b806	60		rts				rts
.b807					_SNDUNIsSilent:
.b807	ad 7d 06	lda $067d			lda 	SNDChannelBits 				; channel bits
.b80a	09 9f		ora #$9f			ora 	#$9F 						; maximum attenuation
.b80c	20 74 b8	jsr $b874			jsr 	SNDWritePorts 				; write to the ports
.b80f	60		rts				rts
.b810					SNDFindNextNoteForA:
.b810	ac 7e 06	ldy $067e			ldy 	SNDLength 					; queue size into Y
.b813	f0 13		beq $b828			beq 	_SNDFNNFail 				; queue empty.
.b815	a2 00		ldx #$00			ldx 	#0
.b817					_SNDFNNSearch:
.b817	dd 7f 06	cmp $067f,x			cmp 	SNDQueue,x 					; does it match the channel
.b81a	38		sec				sec
.b81b	f0 0c		beq $b829			beq 	_SNDFNNExit 				; if so exit with CS.
.b81d	e8		inx				inx 								; next queue slot.
.b81e	e8		inx				inx
.b81f	e8		inx				inx
.b820	e8		inx				inx
.b821	e8		inx				inx
.b822	e8		inx				inx
.b823	e8		inx				inx
.b824	e8		inx				inx
.b825	88		dey				dey 								; done the whole queue
.b826	d0 ef		bne $b817			bne 	_SNDFNNSearch 				; no, go back.
.b828					_SNDFNNFail:
.b828	18		clc				clc
.b829					_SNDFNNexit:
.b829	60		rts				rts
.b82a					SNDDeleteXFromQueue:
.b82a	e0 f8		cpx #$f8			cpx 	#SNDQueueSize*8-8 			; reached the end.
.b82c	f0 09		beq $b837			beq 	_SNDDXExit
.b82e	bd 87 06	lda $0687,x			lda 	SNDQueue+8,x
.b831	9d 7f 06	sta $067f,x			sta 	SNDQueue,x
.b834	e8		inx				inx
.b835	80 f3		bra $b82a			bra 	SNDDeleteXFromQueue
.b837					_SNDDXExit:
.b837	60		rts				rts
.067d					SNDChannelBits:
>067d							.fill 	1
.b838					SNDQueueRequest:
.b838	86 36		stx $36				stx 	zTemp0						; save queue address
.b83a	84 37		sty $37				sty 	zTemp0+1
.b83c	ae 7e 06	ldx $067e			ldx 	SNDLength 					; queue is full, can't take any more.
.b83f	e0 20		cpx #$20			cpx 	#SNDQueueSize
.b841	f0 21		beq $b864			beq 	_SNDQRExit
.b843	29 03		and #$03			and 	#3	 						; channel # and push on stack
.b845	48		pha				pha
.b846	8a		txa				txa  								; get offset in queue buffer/
.b847	0a		asl a				asl 	a
.b848	0a		asl a				asl 	a
.b849	0a		asl a				asl 	a
.b84a	aa		tax				tax
.b84b	68		pla				pla 								; get back and push again
.b84c	48		pha				pha
.b84d	9d 7f 06	sta $067f,x			sta 	SNDQueue+0,x 				; save the channel #
.b850	a0 00		ldy #$00			ldy 	#0 							; copy the rest in.
.b852					_SNDQCopy:
.b852	b1 36		lda ($36),y			lda 	(zTemp0),y
.b854	e8		inx				inx
.b855	c8		iny				iny
.b856	9d 7f 06	sta $067f,x			sta 	SNDQueue,x
.b859	c0 06		cpy #$06			cpy 	#6
.b85b	d0 f5		bne $b852			bne 	_SNDQCopy
.b85d	ee 7e 06	inc $067e			inc 	SNDLength 					; bump queue length.
.b860	68		pla				pla 								; get channel # back
.b861	20 8c b7	jsr $b78c			jsr 	SNDCheckChannel 			; check if channel needs refreshing.
.b864					_SNDQRExit:
.b864	60		rts				rts
.b865					SNDSilenceChannel:
.b865	aa		tax				tax 								; zero time left.
.b866	9e 8b 07	stz $078b,x			stz 	SNDTimeLeft,x
.b869	0a		asl a				asl 	a 							; shift into position
.b86a	0a		asl a				asl 	a
.b86b	0a		asl a				asl 	a
.b86c	0a		asl a				asl 	a
.b86d	0a		asl a				asl 	a
.b86e	09 9f		ora #$9f			ora 	#$9F 						; write register attenuation $F
.b870	20 74 b8	jsr $b874			jsr 	SNDWritePorts
.b873	60		rts				rts
.b874					SNDWritePorts:
.b874	da		phx				phx 								; save X
.b875	a6 01		ldx $01				ldx 	1 							; save I/O status
.b877	64 01		stz $01				stz 	1 							; access I/O page 0
.b879	8d 00 d6	sta $d600			sta 	$D600 						; write to both
.b87c	8d 10 d6	sta $d610			sta 	$D610
.b87f	86 01		stx $01				stx 	1 							; restore I/O
.b881	fa		plx				plx 								; restore X
.b882	60		rts				rts
.b883					SNDCommand:
.b883	da		phx				phx 								; save XY
.b884	5a		phy				phy
.b885	c9 0f		cmp #$0f			cmp 	#$0F 						; $0F is initialise
.b887	f0 1d		beq $b8a6			beq 	_SNDInitialise
.b889	90 28		bcc $b8b3			bcc 	_SNDExit
.b88b	c9 3f		cmp #$3f			cmp 	#$3F 						; $3F is silence all
.b88d	f0 17		beq $b8a6			beq 	_SNDSilence
.b88f	b0 22		bcs $b8b3			bcs 	_SNDExit
.b891	c9 20		cmp #$20			cmp 	#$20 						; $2x is check playing => A
.b893	b0 09		bcs $b89e			bcs 	_SNDQueryPlay
.b895	c9 14		cmp #$14			cmp 	#$14 						; $10-$13 is queue sound
.b897	b0 1a		bcs $b8b3			bcs 	_SNDExit
.b899	20 38 b8	jsr $b838			jsr 	SNDQueueRequest
.b89c	80 15		bra $b8b3			bra 	_SNDExit
.b89e					_SNDQueryPlay:
.b89e	29 03		and #$03			and 	#3 							; get channel #
.b8a0	aa		tax				tax
.b8a1	bd 8b 07	lda $078b,x			lda 	SNDTimeLeft,x 				; read time left, if zero then silent
.b8a4	80 0d		bra $b8b3			bra 	_SNDExit
.b8a6					_SNDInitialise:
.b8a6					_SNDSilence:
.b8a6	9c 7e 06	stz $067e			stz 	SNDLength 					; empty the queue.
.b8a9	a9 03		lda #$03			lda 	#$3 						; silence channel 0-3.
.b8ab					_SNDSilenceLoop:
.b8ab	48		pha				pha
.b8ac	20 65 b8	jsr $b865			jsr 	SNDSilenceChannel
.b8af	68		pla				pla
.b8b0	3a		dec a				dec 	a
.b8b1	10 f8		bpl $b8ab			bpl 	_SNDSilenceLoop
.b8b3					_SNDExit:
.b8b3	7a		ply				ply
.b8b4	fa		plx				plx
.b8b5	60		rts				rts
=32					SNDQueueSize = 32 							; number of queue entries
.067e					SNDLength:
>067e							.fill 	1
.067f					SNDQueue:
>067f							.fill 	SNDQueueSize * 8
.077f					SNDPitchLow:
>077f							.fill 	4
.0783					SNDPitchHigh:
>0783							.fill 	4
.0787					SNDVolume:
>0787							.fill 	4
.078b					SNDTimeLeft:
>078b							.fill 	4
.078f					SNDAdjustLow:
>078f							.fill 	4
.0793					SNDAdjustHigh:
>0793							.fill 	4
.b8b6					SNDUpdate:
.b8b6	ad 8b 07	lda $078b			lda 	SNDTimeLeft+0 				; look at time remaining
.b8b9	f0 05		beq $b8c0			beq 	_SNDUNot0 					; not playing
.b8bb	a2 00		ldx #$00			ldx 	#0 							; so we know which channel to update
.b8bd	20 df b8	jsr $b8df			jsr 	SNDUpdateChannel 			; update it.
.b8c0					_SNDUNot0:
.b8c0	ad 8c 07	lda $078c			lda 	SNDTimeLeft+1
.b8c3	f0 05		beq $b8ca			beq 	_SNDUNot1
.b8c5	a2 01		ldx #$01			ldx 	#1
.b8c7	20 df b8	jsr $b8df			jsr 	SNDUpdateChannel
.b8ca					_SNDUNot1:
.b8ca	ad 8d 07	lda $078d			lda 	SNDTimeLeft+2
.b8cd	f0 05		beq $b8d4			beq 	_SNDUNot2
.b8cf	a2 02		ldx #$02			ldx 	#2
.b8d1	20 df b8	jsr $b8df			jsr 	SNDUpdateChannel
.b8d4					_SNDUNot2:
.b8d4	ad 8e 07	lda $078e			lda 	SNDTimeLeft+3
.b8d7	f0 05		beq $b8de			beq 	_SNDUNot3
.b8d9	a2 03		ldx #$03			ldx 	#3
.b8db	20 df b8	jsr $b8df			jsr 	SNDUpdateChannel
.b8de					_SNDUNot3:
.b8de	60		rts				rts
.b8df					SNDUpdateChannel:
.b8df	c9 ff		cmp #$ff			cmp 	#$FF 						; sound $FF play forever until turned off manually
.b8e1	f0 2c		beq $b90f			beq 	_SNDUCExit
.b8e3	3a		dec a				dec 	a 							; decrement and update timer
.b8e4	9d 8b 07	sta $078b,x			sta 	SNDTimeLeft,x
.b8e7	f0 1d		beq $b906			beq 	_SNDUCUpdate 				; if zero, silence channel
.b8e9	bd 8f 07	lda $078f,x			lda 	SNDAdjustLow,x 				; adjust ?
.b8ec	1d 93 07	ora $0793,x			ora 	SNDAdjustHigh,x
.b8ef	f0 1e		beq $b90f			beq 	_SNDUCExit 					; if zero carry on at current tone.
.b8f1	18		clc				clc 								; add adjust, forcing into a 10 bit range
.b8f2	bd 7f 07	lda $077f,x			lda 	SNDPitchLow,x
.b8f5	7d 8f 07	adc $078f,x			adc 	SNDAdjustLow,x
.b8f8	9d 7f 07	sta $077f,x			sta 	SNDPitchLow,x
.b8fb	bd 83 07	lda $0783,x			lda 	SNDPitchHigh,x
.b8fe	7d 93 07	adc $0793,x			adc 	SNDAdjustHigh,x
.b901	29 03		and #$03			and 	#3
.b903	9d 83 07	sta $0783,x			sta 	SNDPitchHigh,x
.b906					_SNDUCUpdate:
.b906	8a		txa				txa 								; which channel.
.b907	48		pha				pha
.b908	20 cb b7	jsr $b7cb			jsr 	SNDUpdateNote 				; update the current note
.b90b	68		pla				pla
.b90c	20 8c b7	jsr $b78c			jsr 	SNDCheckChannel 			; more to do ?
.b90f					_SNDUCExit:
.b90f	60		rts				rts

;******  Return to file: _basic.asm


;******  End of listing
