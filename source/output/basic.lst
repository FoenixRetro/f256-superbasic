
; 64tass Turbo Assembler Macro V1.57.2900 listing file
; 64tass -D AUTORUN=0 "-D MONITOR_ADDRESS=\$E000" "-D LOCKOUT_ADDRESS=\$F000" "-D BASIC_ADDRESS=\$38000" "-D SOURCE_ADDRESS=\$28000" "-D SPRITE_ADDRESS=\$30000" -q -b -Wall -c -D "HARDWARE=0 $'\x9'$'\x9'$'\x9'$'\x9'$'\x9'$'\x9'" -L output/basic.lst -l output/basic.lbl -Wall -o build/basic.rom _basic.asm
; Tue Dec 13 10:00:09 2022

;Offset	;PC	;Hex		;Monitor	;Source

;******  Command line definitions

=0						AUTORUN=0
=$e000						 MONITOR_ADDRESS=$E000
=$f000						 LOCKOUT_ADDRESS=$F000
=$38000						 BASIC_ADDRESS=$38000
=$28000						 SOURCE_ADDRESS=$28000
=$30000						 SPRITE_ADDRESS=$30000
=0						HARDWARE=0

;******  Processing input file: _basic.asm


;******  Processing file: ./common/aa.system/01common.inc

=$30						ZeroPageMandatory = $30
=$50						ZeroPagePreference = $50
=$400						MemoryStorage = $400
=$2000						BasicStart = $2000
=$8000						BasicEnd = $8000
=$8000						CodeStart = $8000
=$1000						VariableSpace = $1000
=$2000						EndVariableSpace = $2000
=8						MathStackSize = 8
=512						BasicStackSize = 512
=3584						BasicStackBase = $1000-BasicStackSize
=80						MaxLineSize = 80

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/02macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/04data.inc

.0030						codePtr:
>0030								.fill 	4
.0034						basicStack:
>0034								.fill 	2
.0036						zTemp0:
>0036								.fill 	2
.0038						zTemp1:
>0038								.fill 	2
.003a						zTemp2:
>003a								.fill 	2
.003c						zsTemp:
>003c								.fill 	2
.003e						zaTemp:
>003e								.fill 	2
=$30						safePtr = codePtr 							; minimise direct tinkering
=$80						NSBIsNegative = $80 						; bit 7 : sign of mantissa (where numeric)
=$20						NSBIsReference = $20 						; bit 5 : is a reference
=$10						NSBIsString = $10 							; bit 4 : set if string (procedures don't go on the stack)
=$18						NSBTypeMask = $18 							; bits 4,3 : 00 int 01 float 10 string 11 procedure
=$03						NSBRefMask = $03 							; bits 0,1 : Bytes of reference, 00 = 4,01 = 1,10=2
=$04						NSBIsArray = $04
=$00						NSTInteger = $00 							; base types for bits 3..4
=$08						NSTFloat = $08
=$10						NSTString = $10
=$18						NSTProcedure = $18
.0050						NSStatus:
>0050								.fill 	MathStackSize
.0058						NSMantissa0:
>0058								.fill 	MathStackSize 				; (this is my integer mantissa system)
.0060						NSMantissa1:
>0060								.fill 	MathStackSize
.0068						NSMantissa2:
>0068								.fill 	MathStackSize
.0070						NSMantissa3:
>0070								.fill 	MathStackSize
.0078						NSExponent:
>0078								.fill 	MathStackSize
.0400						identStart:
>0400								.fill 	1
.0401						identTypeStart:
>0401								.fill 	1
.0402						identTypeEnd:
>0402								.fill 	1
.0403						identHash:
>0403								.fill 	1
.0404						identTypeByte:
>0404								.fill 	1	 						; (see tokenising.pdf)
.0405						encodeState:
>0405								.fill 	1
.0406						digitTemp:
>0406								.fill 	1
.0407						decimalCount:
>0407								.fill 	1
.0408						randomSeed:
>0408								.fill 	4
.040c						lowMemPtr:
>040c								.fill 	2
.040e						stringMemory:
>040e								.fill 	2
.0410						stringInitialised:
>0410								.fill 	1
.0411						stringTempPointer:
>0411								.fill 	2
.0413						breakCheck:
>0413								.fill 	1
.0414						decimalPlaces:
>0414								.fill 	1
.0415						dbOffset:
>0415								.fill 	1
.0416						lastParameter:
>0416								.fill 	1
.0417						dataPointer:
>0417								.fill 	5
.041c						inDataStatement:
>041c								.fill 	1
.041d						tbOffset:
>041d								.fill 	1
.041e						AssemblerAddress:
>041e								.fill 	2
.0420						AssemblerControl:
>0420								.fill 	1
.0421						ParamStart:
>0421								.fill 	2
.0423						IsGroup1:
>0423								.fill 	1
.0424						BaseOpcode:
>0424								.fill 	1
.0425						ModeMask:
>0425								.fill 	1
.0426						listIndent:
>0426								.fill 	1
.0427						lcLastCharacter:
>0427								.fill 	1
.0428						isInputFlag:
>0428								.fill 	1
.0429						currentListColour:
>0429								.fill 	1
.042a						tokenOffset:
>042a								.fill 	1
.042b						tokenLineNumber:
>042b								.fill 	2
.042d						tokenBuffer:
>042d								.fill 	253
.052a						lineBuffer:
>052a								.fill 	253
.0627						numberBuffer:
>0627								.fill 	34
.0649						decimalBuffer:
>0649								.fill 	16

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/constants.inc

=$80						AM_ISZP = $80
=$40						AM_ISG1 = $40
=$20						AM_ISG2 = $20
=224						AM_IMMEDIATE = AM_ISZP+AM_ISG1+AM_ISG2+$00
=228						AM_ZEROPAGE = AM_ISZP+AM_ISG1+AM_ISG2+$04
=40						AM_ACC = AM_ISG2+$08
=108						AM_ABS = AM_ISG1+AM_ISG2+$0C
=208						AM_INDY = AM_ISZP+AM_ISG1+$10
=244						AM_ZEROX = AM_ISZP+AM_ISG1+AM_ISG2+$14
=120						AM_ABSY = AM_ISG1+AM_ISG2+$18
=124						AM_ABSX = AM_ISG1+AM_ISG2+$1C
=209						AM_IND = AM_ISZP+AM_ISG1+$11
=$80						AM_ZEROY = AM_ISZP
=$01						AM_INDABS = $01
=$02						AM_INDABSX = $02
=192						AM_INDX = AM_ISZP+AM_ISG1+$00

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/handlers.inc


;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.inc

=1						ERRID_BREAK = 1
=2						ERRID_SYNTAX = 2
=3						ERRID_DIVZERO = 3
=4						ERRID_RANGE = 4
=5						ERRID_TYPE = 5
=6						ERRID_MEMORY = 6
=7						ERRID_ARGUMENT = 7
=8						ERRID_STOP = 8
=9						ERRID_STRING = 9
=10						ERRID_ASSERT = 10
=11						ERRID_DATA = 11
=12						ERRID_NOTDONE = 12
=13						ERRID_LINE = 13
=14						ERRID_GOSUB = 14
=15						ERRID_REPEAT = 15
=16						ERRID_WHILE = 16
=17						ERRID_FOR = 17
=18						ERRID_STACK = 18
=19						ERRID_STRUCT = 19
=20						ERRID_PROC = 20
=21						ERRID_REDEFINE = 21
=22						ERRID_ARRAYSIZE = 22
=23						ERRID_ARRAYIDX = 23
=24						ERRID_ARRAYDEC = 24

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst.inc

=$00						KWD_LESSLESS                         = $00; $00 <<
=$01						KWD_LESSEQUAL                        = $01; $01 <=
=$02						KWD_LESSGREATER                      = $02; $02 <>
=$03						KWD_PLINGPLING3                      = $03; $03 !!3
=$04						KWD_GREATERLESS                      = $04; $04 ><
=$05						KWD_GREATEREQUAL                     = $05; $05 >=
=$06						KWD_GREATERGREATER                   = $06; $06 >>
=$07						KWD_PLINGPLING7                      = $07; $07 !!7
=$08						KWD_PLINGPLING8                      = $08; $08 !!8
=$09						KWD_PLINGPLING9                      = $09; $09 !!9
=$0a						KWD_PLINGPLING10                     = $0a; $0a !!10
=$0b						KWD_PLINGPLING11                     = $0b; $0b !!11
=$0c						KWD_PLINGPLING12                     = $0c; $0c !!12
=$0d						KWD_PLINGPLING13                     = $0d; $0d !!13
=$0e						KWD_PLINGPLING14                     = $0e; $0e !!14
=$0f						KWD_PLINGPLING15                     = $0f; $0f !!15
=$10						KWD_AT                               = $10; $10 @
=$11						KWD_PLINGPLING17                     = $11; $11 !!17
=$12						KWD_PLINGPLING18                     = $12; $12 !!18
=$13						KWD_LSQPAREN                         = $13; $13 [
=$14						KWD_BACKSLASH                        = $14; $14 \
=$15						KWD_RSQPAREN                         = $15; $15 ]
=$16						KWD_HAT                              = $16; $16 ^
=$17						KWD_UNDERSCORE                       = $17; $17 _
=$18						KWD_BQUOTE                           = $18; $18 `
=$19						KWD_PLINGPLING25                     = $19; $19 !!25
=$1a						KWD_PLINGPLING26                     = $1a; $1a !!26
=$1b						KWD_LCURLY                           = $1b; $1b {
=$1c						KWD_BAR                              = $1c; $1c |
=$1d						KWD_RCURLY                           = $1d; $1d }
=$1e						KWD_TILDE                            = $1e; $1e ~
=$21						KWD_PLING                            = $21; $21 !
=$22						KWD_DQUOTE                           = $22; $22 "
=$23						KWD_HASH                             = $23; $23 #
=$24						KWD_DOLLAR                           = $24; $24 $
=$25						KWD_PERCENT                          = $25; $25 %
=$26						KWD_AMPERSAND                        = $26; $26 &
=$27						KWD_QUOTE                            = $27; $27 '
=$28						KWD_LPAREN                           = $28; $28 (
=$29						KWD_RPAREN                           = $29; $29 )
=$2a						KWD_STAR                             = $2a; $2a *
=$2b						KWD_PLUS                             = $2b; $2b +
=$2c						KWD_COMMA                            = $2c; $2c ,
=$2d						KWD_MINUS                            = $2d; $2d -
=$2e						KWD_PERIOD                           = $2e; $2e .
=$2f						KWD_SLASH                            = $2f; $2f /
=$30						KWD_0                                = $30; $30 0
=$31						KWD_1                                = $31; $31 1
=$32						KWD_2                                = $32; $32 2
=$33						KWD_3                                = $33; $33 3
=$34						KWD_4                                = $34; $34 4
=$35						KWD_5                                = $35; $35 5
=$36						KWD_6                                = $36; $36 6
=$37						KWD_7                                = $37; $37 7
=$38						KWD_8                                = $38; $38 8
=$39						KWD_9                                = $39; $39 9
=$3a						KWD_COLON                            = $3a; $3a :
=$3b						KWD_SEMICOLON                        = $3b; $3b ;
=$3c						KWD_LESS                             = $3c; $3c <
=$3d						KWD_EQUAL                            = $3d; $3d =
=$3e						KWD_GREATER                          = $3e; $3e >
=$3f						KWD_QMARK                            = $3f; $3f ?
=$83						KWD_ABSLPAREN                        = $83; $83 ABS(
=$84						KWD_ALLOCLPAREN                      = $84; $84 ALLOC(
=$85						KWD_ASCLPAREN                        = $85; $85 ASC(
=$86						KWD_CHRDOLLARLPAREN                  = $86; $86 CHR$(
=$87						KWD_DEEKLPAREN                       = $87; $87 DEEK(
=$88						KWD_EVENTLPAREN                      = $88; $88 EVENT(
=$89						KWD_FALSE                            = $89; $89 FALSE
=$8a						KWD_FRACLPAREN                       = $8a; $8a FRAC(
=$8b						KWD_HITLPAREN                        = $8b; $8b HIT(
=$8c						KWD_INTLPAREN                        = $8c; $8c INT(
=$8d						KWD_ISVALLPAREN                      = $8d; $8d ISVAL(
=$8e						KWD_JOYBLPAREN                       = $8e; $8e JOYB(
=$8f						KWD_JOYXLPAREN                       = $8f; $8f JOYX(
=$90						KWD_JOYYLPAREN                       = $90; $90 JOYY(
=$91						KWD_LEFTDOLLARLPAREN                 = $91; $91 LEFT$(
=$92						KWD_LENLPAREN                        = $92; $92 LEN(
=$93						KWD_MAXLPAREN                        = $93; $93 MAX(
=$94						KWD_MIDDOLLARLPAREN                  = $94; $94 MID$(
=$95						KWD_MINLPAREN                        = $95; $95 MIN(
=$96						KWD_NOTLPAREN                        = $96; $96 NOT(
=$97						KWD_PEEKLPAREN                       = $97; $97 PEEK(
=$98						KWD_PLAYINGLPAREN                    = $98; $98 PLAYING(
=$99						KWD_RANDOMLPAREN                     = $99; $99 RANDOM(
=$9a						KWD_RIGHTDOLLARLPAREN                = $9a; $9a RIGHT$(
=$9b						KWD_RNDLPAREN                        = $9b; $9b RND(
=$9c						KWD_SGNLPAREN                        = $9c; $9c SGN(
=$9d						KWD_SPCLPAREN                        = $9d; $9d SPC(
=$9e						KWD_STRDOLLARLPAREN                  = $9e; $9e STR$(
=$9f						KWD_TIMERLPAREN                      = $9f; $9f TIMER(
=$a0						KWD_TRUE                             = $a0; $a0 TRUE
=$a1						KWD_VALLPAREN                        = $a1; $a1 VAL(
=$a2						KWD_FOR                              = $a2; $a2 FOR
=$a3						KWD_IF                               = $a3; $a3 IF
=$a4						KWD_PROC                             = $a4; $a4 PROC
=$a5						KWD_REPEAT                           = $a5; $a5 REPEAT
=$a6						KWD_WHILE                            = $a6; $a6 WHILE
=$a7						KWD_ENDIF                            = $a7; $a7 ENDIF
=$a8						KWD_ENDPROC                          = $a8; $a8 ENDPROC
=$a9						KWD_NEXT                             = $a9; $a9 NEXT
=$aa						KWD_THEN                             = $aa; $aa THEN
=$ab						KWD_UNTIL                            = $ab; $ab UNTIL
=$ac						KWD_WEND                             = $ac; $ac WEND
=$ad						KWD_BY                               = $ad; $ad BY
=$ae						KWD_CALL                             = $ae; $ae CALL
=$af						KWD_CIRCLE                           = $af; $af CIRCLE
=$b0						KWD_CLEAR                            = $b0; $b0 CLEAR
=$b1						KWD_CLS                              = $b1; $b1 CLS
=$b2						KWD_COLOR                            = $b2; $b2 COLOR
=$b3						KWD_COLOUR                           = $b3; $b3 COLOUR
=$b4						KWD_DATA                             = $b4; $b4 DATA
=$b5						KWD_DIM                              = $b5; $b5 DIM
=$b6						KWD_DOKE                             = $b6; $b6 DOKE
=$b7						KWD_DOWNTO                           = $b7; $b7 DOWNTO
=$b8						KWD_ELSE                             = $b8; $b8 ELSE
=$b9						KWD_FROM                             = $b9; $b9 FROM
=$ba						KWD_GFX                              = $ba; $ba GFX
=$bb						KWD_GOSUB                            = $bb; $bb GOSUB
=$bc						KWD_GOTO                             = $bc; $bc GOTO
=$bd						KWD_HERE                             = $bd; $bd HERE
=$be						KWD_IMAGE                            = $be; $be IMAGE
=$bf						KWD_INPUT                            = $bf; $bf INPUT
=$c0						KWD_LET                              = $c0; $c0 LET
=$c1						KWD_LINE                             = $c1; $c1 LINE
=$c2						KWD_LOCAL                            = $c2; $c2 LOCAL
=$c3						KWD_OFF                              = $c3; $c3 OFF
=$c4						KWD_ON                               = $c4; $c4 ON
=$c5						KWD_OUTLINE                          = $c5; $c5 OUTLINE
=$c6						KWD_PALETTE                          = $c6; $c6 PALETTE
=$c7						KWD_PLOT                             = $c7; $c7 PLOT
=$c8						KWD_POKE                             = $c8; $c8 POKE
=$c9						KWD_PRINT                            = $c9; $c9 PRINT
=$ca						KWD_READ                             = $ca; $ca READ
=$cb						KWD_RECT                             = $cb; $cb RECT
=$cc						KWD_REM                              = $cc; $cc REM
=$cd						KWD_RETURN                           = $cd; $cd RETURN
=$ce						KWD_SOLID                            = $ce; $ce SOLID
=$cf						KWD_SOUND                            = $cf; $cf SOUND
=$d0						KWD_SPRITE                           = $d0; $d0 SPRITE
=$d1						KWD_TEXT                             = $d1; $d1 TEXT
=$d2						KWD_TO                               = $d2; $d2 TO

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst0.inc

=$80						KWC_EOL = $80
=$ff						KWC_STRING = $FF
=$fe						KWC_HEXCONST = $FE
=$a2						KWC_FIRST_STRUCTURE = $a2
=$a7						KWC_FIRST_STRUCTURE_DEC = $a7
=$ac						KWC_LAST_STRUCTURE = $ac
=$83						KWC_FIRST_UNARY = $83
=$a1						KWC_LAST_UNARY = $a1

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/access.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/stack.inc

=$e0						STK_GOSUB = $E0
=$d0						STK_FOR = $D0
=$c0						STK_REPEAT = $C0
=$b0						STK_PROC = $B0
=$a0						STK_WHILE = $A0
=$01						STK_LOCALN = $01
=$02						STK_LOCALS = $02

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/00start.asm

.8000		4c 71 80	jmp $8071	Boot:	jmp 	Start

;******  Processing file: ./common/aa.system/../../../modules/_build/_linker.module

=1						PagingEnabled = 1
.8003						EXTPrintCharacter:
.8003		e6 0d		inc $0d			inc 8+5
.8005		20 00 a0	jsr $a000		jsr	Export_EXTPrintCharacter
.8008		08		php			php
.8009		c6 0d		dec $0d			dec 8+5
.800b		28		plp			plp
.800c		60		rts			rts
.800d						EXTInitialise:
.800d		e6 0d		inc $0d			inc 8+5
.800f		20 99 a2	jsr $a299		jsr	Export_EXTInitialise
.8012		08		php			php
.8013		c6 0d		dec $0d			dec 8+5
.8015		28		plp			plp
.8016		60		rts			rts
.8017						EXTInputSingleCharacter:
.8017		e6 0d		inc $0d			inc 8+5
.8019		20 cf a2	jsr $a2cf		jsr	Export_EXTInputSingleCharacter
.801c		08		php			php
.801d		c6 0d		dec $0d			dec 8+5
.801f		28		plp			plp
.8020		60		rts			rts
.8021						EXTBreakCheck:
.8021		e6 0d		inc $0d			inc 8+5
.8023		20 f5 a2	jsr $a2f5		jsr	Export_EXTBreakCheck
.8026		08		php			php
.8027		c6 0d		dec $0d			dec 8+5
.8029		28		plp			plp
.802a		60		rts			rts
.802b						EXTReadController:
.802b		e6 0d		inc $0d			inc 8+5
.802d		20 f8 a2	jsr $a2f8		jsr	Export_EXTReadController
.8030		08		php			php
.8031		c6 0d		dec $0d			dec 8+5
.8033		28		plp			plp
.8034		60		rts			rts
.8035						EXTInputLine:
.8035		e6 0d		inc $0d			inc 8+5
.8037		20 af a1	jsr $a1af		jsr	Export_EXTInputLine
.803a		08		php			php
.803b		c6 0d		dec $0d			dec 8+5
.803d		28		plp			plp
.803e		60		rts			rts
.803f						GXGraphicDraw:
.803f		e6 0d		inc $0d			inc 8+5
.8041		20 93 a3	jsr $a393		jsr	Export_GXGraphicDraw
.8044		08		php			php
.8045		c6 0d		dec $0d			dec 8+5
.8047		28		plp			plp
.8048		60		rts			rts
.8049						SNDCommand:
.8049		e6 0d		inc $0d			inc 8+5
.804b		20 78 b6	jsr $b678		jsr	Export_SNDCommand
.804e		08		php			php
.804f		c6 0d		dec $0d			dec 8+5
.8051		28		plp			plp
.8052		60		rts			rts
.8053						SNDUpdate:
.8053		e6 0d		inc $0d			inc 8+5
.8055		20 ab b6	jsr $b6ab		jsr	Export_SNDUpdate
.8058		08		php			php
.8059		c6 0d		dec $0d			dec 8+5
.805b		28		plp			plp
.805c		60		rts			rts
.805d						TKListConvertLine:
.805d		e6 0d		inc $0d			inc 8+5
.805f		20 6e b0	jsr $b06e		jsr	Export_TKListConvertLine
.8062		08		php			php
.8063		c6 0d		dec $0d			dec 8+5
.8065		28		plp			plp
.8066		60		rts			rts
.8067						TKTokeniseLine:
.8067		e6 0d		inc $0d			inc 8+5
.8069		20 02 b3	jsr $b302		jsr	Export_TKTokeniseLine
.806c		08		php			php
.806d		c6 0d		dec $0d			dec 8+5
.806f		28		plp			plp
.8070		60		rts			rts

;******  Return to file: ./common/aa.system/00start.asm

.8071		a2 ff		ldx #$ff	Start:	ldx 	#$FF 						; stack reset
.8073		9a		txs				txs
.8074		a5 00		lda $00				lda 	0  							; turn on editing of MMU LUT
.8076		09 80		ora #$80			ora 	#$80
.8078		85 00		sta $00				sta 	0
.807a		20 0d 80	jsr $800d			jsr 	EXTInitialise 				; hardware initialise
.807d		a9 00		lda #$00			lda 	#0 							; graphics system initialise.
.807f		aa		tax				tax
.8080		a8		tay				tay
.8081		20 3f 80	jsr $803f			jsr 	GXGraphicDraw
.8084		a9 0f		lda #$0f			lda 	#$0F 						; initialise sound system
.8086		20 49 80	jsr $8049			jsr 	SNDCommand
.8089		a2 80		ldx #$80			ldx 	#Prompt >> 8 				; display prompt
.808b		a9 99		lda #$99			lda 	#Prompt & $FF
.808d		20 aa 8f	jsr $8faa			jsr 	PrintStringXA
.8090		20 86 8a	jsr $8a86			jsr 	NewProgram 					; erase current program
.8093		4c 2f 84	jmp $842f			jmp 	WarmStart					; make same size.
.8096		4c 2f 84	jmp $842f			jmp 	WarmStart
>8099		36 35 30 32 20 53 75 70		Prompt:	.text 	"6502 SuperBASIC ("
>80a1		65 72 42 41 53 49 43 20 28
>80aa		32 34						.text 	"24"
>80ac		6b 29 0d					.text 	"k)",13
>80af		43 6f 70 79 72 69 67 68				.text 	"Copyright 2022 Paul Robson",13
>80b7		74 20 32 30 32 32 20 50 61 75 6c 20 52 6f 62 73
>80c7		6f 6e 0d
>80ca		50 61 75 6c 40 52 6f 62				.text  	"Paul@Robsons.org.uk",13
>80d2		73 6f 6e 73 2e 6f 72 67 2e 75 6b 0d
>80de		46 32 35 36 20					.text "F256 "

;******  Processing file: ./common/aa.system/../generated/timestamp.asm

>80e3		41 6c 70 68 61 20 31 35			.text "Alpha 15 built 12-Dec-22. "
>80eb		20 62 75 69 6c 74 20 31 32 2d 44 65 63 2d 32 32
>80fb		2e 20

;******  Return to file: ./common/aa.system/00start.asm

>80fd		0d						.byte  	13
>80fe		0d 0d 00					.text 	13,13,0

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/assembler.asm

.8101						AssembleGroup1:
.8101		a9 ff		lda #$ff			lda 	#$FF 						; flag for group 1 / mask.
.8103		8d 25 04	sta $0425			sta 	ModeMask 					; initialise the mode mask - all for all
.8106		80 02		bra $810a			bra 	AsmGroup12
.8108						AssembleGroup2:
.8108		a9 00		lda #$00			lda 	#$00 						; flag for group 2
.810a						AsmGroup12:
.810a		8d 23 04	sta $0423			sta 	IsGroup1 					; save the 'group 1' flag
.810d		68		pla				pla 								; pop the return address to access the information following.
.810e		fa		plx				plx
.810f		20 96 81	jsr $8196			jsr 	AccessParameters 			; get opcode and save as base
.8112		8d 24 04	sta $0424			sta 	BaseOpcode
.8115		ad 23 04	lda $0423			lda 	IsGroup1 					; skip if group 1 as we don't have a complex mask.
.8118		d0 08		bne $8122			bne 	_AG12HaveMask
.811a		a9 02		lda #$02			lda 	#2 							; if group 2 the second parameter is the mask
.811c		20 9e 81	jsr $819e			jsr 	GetParameter		 		; e.g. which modes are supported for this operand
.811f		8d 25 04	sta $0425			sta 	ModeMask
.8122						_AG12HaveMask:
.8122		20 d2 82	jsr $82d2			jsr 	TypeAndCalculateOperand 	; get zero page type
.8125		da		phx				phx 								; save found address mode
.8126		20 02 82	jsr $8202			jsr 	AssembleModeX
.8129		fa		plx				plx  								; restore address mode
.812a		b0 0b		bcs $8137			bcs 	_AG12Exit
.812c		20 38 81	jsr $8138			jsr 	PromoteToAbsolute  			; promote ZP to ABS and try that
.812f		20 02 82	jsr $8202			jsr 	AssembleModeX
.8132		b0 03		bcs $8137			bcs 	_AG12Exit
.8134		4c f6 9f	jmp $9ff6			jmp 	SyntaxError 				; can't do either, so must be wrong mode/operand.
.8137						_AG12Exit:
.8137		60		rts				rts
.8138						PromoteToAbsolute:
.8138		a9 6c		lda #$6c			lda 	#AM_ABS 					; lda xx
.813a		e0 e4		cpx #$e4			cpx 	#AM_ZEROPAGE
.813c		f0 19		beq $8157			beq 	_PTADo
.813e		a9 7c		lda #$7c			lda 	#AM_ABSX 					; lda xx,X
.8140		e0 f4		cpx #$f4			cpx 	#AM_ZEROX
.8142		f0 13		beq $8157			beq 	_PTADo
.8144		a9 78		lda #$78			lda 	#AM_ABSY 					; lda xx,Y
.8146		e0 80		cpx #$80			cpx 	#AM_ZEROY
.8148		f0 0d		beq $8157			beq 	_PTADo
.814a		a9 01		lda #$01			lda 	#AM_INDABS 					; lda (xx) (jump)
.814c		e0 d1		cpx #$d1			cpx 	#AM_IND
.814e		f0 07		beq $8157			beq 	_PTADo
.8150		a9 02		lda #$02			lda 	#AM_INDABSX 				; lda (xx,x) (jump)
.8152		e0 c0		cpx #$c0			cpx 	#AM_INDX
.8154		f0 01		beq $8157			beq 	_PTADo
.8156		60		rts				rts
.8157						_PTADo:
.8157		aa		tax				tax
.8158		60		rts				rts
.8159						AssembleGroup3:
.8159		68		pla				pla 								; get parameters, which is just the opcode.
.815a		fa		plx				plx
.815b		20 96 81	jsr $8196			jsr 	AccessParameters 			; get and output opcode
.815e		20 ae 81	jsr $81ae			jsr 	AssemblerWriteByte
.8161		20 36 83	jsr $8336			jsr 	CalculateOperand 			; get a 16 bit operand
.8164		a5 58		lda $58				lda 	NSMantissa0 				; calculate the offset
.8166		38		sec				sec
.8167		ed 1e 04	sbc $041e			sbc 	AssemblerAddress
.816a		48		pha				pha 								; LSB in A
.816b		a5 60		lda $60				lda 	NSMantissa1
.816d		ed 1f 04	sbc $041f			sbc 	AssemblerAddress+1
.8170		aa		tax				tax 								; MSB in X
.8171		68		pla				pla
.8172		18		clc				clc 								; $80 to easy check $80-$7F, plus 1 for offset error
.8173		69 7f		adc #$7f			adc 	#$7F
.8175		90 01		bcc $8178			bcc 	_AG3NoCarry
.8177		e8		inx				inx
.8178						_AG3NoCarry:
.8178		38		sec				sec 								; fix back and write out anyways.
.8179		e9 80		sbc #$80			sbc 	#$80
.817b		20 ae 81	jsr $81ae			jsr 	AssemblerWriteByte
.817e		e0 00		cpx #$00			cpx 	#0 							; was it in range
.8180		f0 0a		beq $818c			beq 	_AG3Exit
.8182		ad 20 04	lda $0420			lda 	AssemblerControl 			; are we allowing bad values ?
.8185		29 01		and #$01			and 	#1
.8187		f0 03		beq $818c			beq 	_AG3Exit
.8189		4c fb 9f	jmp $9ffb			jmp 	RangeError 					; no, branch is out of range
.818c						_AG3Exit:
.818c		60		rts				rts
.818d						AssembleGroup4:
.818d		68		pla				pla 								; pop address
.818e		fa		plx				plx
.818f		20 96 81	jsr $8196			jsr 	AccessParameters 			; access and get first
.8192		20 ae 81	jsr $81ae			jsr 	AssemblerWriteByte 			; output it.
.8195		60		rts				rts
.8196						AccessParameters:
.8196		8d 21 04	sta $0421			sta 	ParamStart
.8199		8e 22 04	stx $0422			stx 	ParamStart+1
.819c		a9 01		lda #$01			lda 	#1
.819e						GetParameter:
.819e		5a		phy				phy
.819f		a8		tay				tay
.81a0		ad 21 04	lda $0421			lda 	ParamStart
.81a3		85 36		sta $36				sta 	zTemp0
.81a5		ad 22 04	lda $0422			lda 	ParamStart+1
.81a8		85 37		sta $37				sta 	zTemp0+1
.81aa		b1 36		lda ($36),y			lda 	(zTemp0),y
.81ac		7a		ply				ply
.81ad		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/aswrite.asm

.81ae						AssemblerWriteByte:
.81ae		48		pha			pha
.81af		ad 20 04	lda $0420		lda 	AssemblerControl 				; check printing bytes ?
.81b2		29 02		and #$02		and 	#2
.81b4		f0 1b		beq $81d1		beq 	_AWBNoPrint
.81b6		ad 1f 04	lda $041f		lda		AssemblerAddress+1 				; print address
.81b9		20 ec 81	jsr $81ec		jsr 	PrintHex
.81bc		ad 1e 04	lda $041e		lda		AssemblerAddress
.81bf		20 ec 81	jsr $81ec		jsr 	PrintHex
.81c2		a9 20		lda #$20		lda 	#' '
.81c4		20 03 80	jsr $8003		jsr 	EXTPrintCharacter
.81c7		68		pla			pla 									; print byte
.81c8		48		pha			pha
.81c9		20 ec 81	jsr $81ec		jsr 	PrintHex
.81cc		a9 0d		lda #$0d		lda 	#13
.81ce		20 03 80	jsr $8003		jsr 	EXTPrintCharacter
.81d1						_AWBNoPrint:
.81d1		ad 1e 04	lda $041e		lda		AssemblerAddress				; copy address to zTemp0
.81d4		85 36		sta $36			sta 	zTemp0
.81d6		ad 1f 04	lda $041f		lda		AssemblerAddress+1
.81d9		f0 0e		beq $81e9		beq 	_AWBRange
.81db		85 37		sta $37			sta 	zTemp0+1
.81dd		68		pla			pla 									; write byte out
.81de		92 36		sta ($36)		sta 	(zTemp0)
.81e0		ee 1e 04	inc $041e		inc 	AssemblerAddress 				; bump address
.81e3		d0 03		bne $81e8		bne 	_AWBNoCarry
.81e5		ee 1f 04	inc $041f		inc 	AssemblerAddress+1
.81e8						_AWBNoCarry:
.81e8		60		rts			rts
.81e9						_AWBRange:
.81e9		4c fb 9f	jmp $9ffb		jmp 	RangeError
.81ec						PrintHex:
.81ec		48		pha				pha
.81ed		4a		lsr a				lsr 	a
.81ee		4a		lsr a				lsr 	a
.81ef		4a		lsr a				lsr 	a
.81f0		4a		lsr a				lsr 	a
.81f1		20 f5 81	jsr $81f5			jsr 	_PrintNibble
.81f4		68		pla				pla
.81f5						_PrintNibble:
.81f5		29 0f		and #$0f			and 	#15
.81f7		c9 0a		cmp #$0a			cmp 	#10
.81f9		90 02		bcc $81fd			bcc 	_NoShift
.81fb		69 06		adc #$06			adc 	#6
.81fd						_NoShift:
.81fd		69 30		adc #$30			adc 	#48
.81ff		4c 03 80	jmp $8003			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/instruction.asm

.8202						AssembleModeX:
.8202		5a		phy				phy
.8203		ad 23 04	lda $0423			lda 	IsGroup1
.8206		f0 17		beq $821f			beq 	_AMXGroup2
.8208		8a		txa				txa 							; is it in group # 1
.8209		29 40		and #$40			and 	#AM_ISG1
.820b		f0 4d		beq $825a			beq 	_AMXFail 				; no, give up.
.820d		8a		txa				txa 							; get back.
.820e		29 1f		and #$1f			and 	#$1F 					; this is now the offset.
.8210		e0 e0		cpx #$e0			cpx 	#AM_IMMEDIATE 			; if not immediate, we can continue.
.8212		d0 22		bne $8236			bne 	_AMXHaveInfo
.8214		ad 24 04	lda $0424			lda 	BaseOpcode 				; cannot store immediate.
.8217		c9 81		cmp #$81			cmp 	#$81
.8219		f0 3f		beq $825a			beq 	_AMXFail
.821b		a9 08		lda #$08			lda 	#8 						; if immediate we use offset 8.
.821d		80 17		bra $8236			bra 	_AMXHaveInfo 			; odd design decision there.
.821f						_AMXGroup2:
.821f		8a		txa				txa 							; is it in group 2 ?
.8220		29 20		and #$20			and 	#AM_ISG2
.8222		f0 36		beq $825a			beq 	_AMXFail 				; no, give up.
.8224		8a		txa				txa 							; get the offset into Y
.8225		29 1f		and #$1f			and 	#$1F
.8227		4a		lsr a				lsr 	a 						; make it 0-7.
.8228		4a		lsr a				lsr  	a
.8229		a8		tay				tay
.822a		ad 25 04	lda $0425			lda 	ModeMask 				; shift the modemask left so you can check it against the requested offset
.822d						_AMXCheckOkay:
.822d		0a		asl a				asl 	a 						; shift modemask left enough times to check legitimate.
.822e		88		dey				dey
.822f		10 fc		bpl $822d			bpl 	_AMXCheckOkay
.8231		90 27		bcc $825a			bcc 	_AMXFail 				; not allowed.
.8233		8a		txa				txa  							; get mask back
.8234		29 1f		and #$1f			and 	#$1F
.8236						_AMXHaveInfo:
.8236		e0 00		cpx #$00			cpx 	#$00 					; does it *require* an 8 bit operand
.8238		10 04		bpl $823e			bpl 	_AMXAnySize 			; checking bit 7, the zero page opcode flag.
.823a		a4 60		ldy $60				ldy 	NSMantissa1 			; fail if it is outside range, e.g. the MSB is set.
.823c		d0 1c		bne $825a			bne 	_AMXFail
.823e						_AMXAnySize:
.823e		18		clc				clc 							; add offset to the base opcode
.823f		6d 24 04	adc $0424			adc 	BaseOpcode
.8242						_AMXOutputCode:
.8242		20 ae 81	jsr $81ae			jsr 	AssemblerWriteByte 		; write the opcode out.
.8245		e0 28		cpx #$28			cpx 	#AM_ACC 				; A mode (e.g. ASL)
.8247		f0 0e		beq $8257			beq 	_AMXExit
.8249		a5 58		lda $58				lda 	NSMantissa0 			; write LSB operand
.824b		20 ae 81	jsr $81ae			jsr 	AssemblerWriteByte
.824e		e0 00		cpx #$00			cpx 	#$00 					; zeropage ?
.8250		30 05		bmi $8257			bmi 	_AMXExit
.8252		a5 60		lda $60				lda 	NSMantissa1 			; write MSB operand
.8254		20 ae 81	jsr $81ae			jsr 	AssemblerWriteByte
.8257						_AMXExit:
.8257		7a		ply				ply
.8258		38		sec				sec
.8259		60		rts				rts
.825a						_AMXFail:
.825a		a0 00		ldy #$00			ldy 	#0
.825c						_AMXCheckOddities:
.825c		8a		txa				txa
.825d		d9 84 82	cmp $8284,y			cmp 	ExtraOpcode+2,y 		; match address mode
.8260		d0 15		bne $8277			bne 	_AMXCONext
.8262		b9 82 82	lda $8282,y			lda 	ExtraOpcode+0,y 		; do the base opcodes match
.8265		cd 24 04	cmp $0424			cmp 	BaseOpcode
.8268		d0 0d		bne $8277			bne 	_AMXCONext
.826a		e0 00		cpx #$00			cpx 	#$00 					; requires zero page ?
.826c		10 04		bpl $8272			bpl 	_AMXCONotZero
.826e		a5 60		lda $60				lda 	NSMantissa1
.8270		d0 05		bne $8277			bne 	_AMXCONext
.8272						_AMXCONotZero:
.8272		b9 83 82	lda $8283,y			lda 	ExtraOpcode+1,y 		; get new opcode
.8275		80 cb		bra $8242			bra 	_AMXOutputCode 			; and assemble it
.8277						_AMXCONext:
.8277		c8		iny				iny
.8278		c8		iny				iny
.8279		c8		iny				iny
.827a		b9 82 82	lda $8282,y			lda 	ExtraOpcode+0,y 		; end of table
.827d		d0 dd		bne $825c			bne 	_AMXCheckOddities
.827f						_AMXCOFail:
.827f		7a		ply				ply
.8280		18		clc				clc
.8281		60		rts				rts
.8282						ExtraOpcode:
>8282		40 6c 01					.byte $40,$6c,AM_INDABS 	; jump
>8285		40 7c 02					.byte $40,$7C,AM_INDABSX 	; jump
>8288		a2 be 78					.byte $a2,$BE,AM_ABSY 		; ldx
>828b		a2 b6 80					.byte $a2,$B6,AM_ZEROY 		; ldx
>828e		82 96 80					.byte $82,$96,AM_ZEROY 		; stx
>8291		e2 1a 28					.byte $e2,$1a,AM_ACC 		; inc
>8294		c2 3a 28					.byte $c2,$3a,AM_ACC 		; dec
>8297		20 89 e0					.byte $20,$89,AM_IMMEDIATE 	; bit
>829a		60 9c 6c					.byte $60,$9c,AM_ABS 		; stz
>829d		60 9e 7c					.byte $60,$9e,AM_ABSX 		; stz
>82a0		00						.byte $00

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/label.asm

.82a1						LabelHere:
.82a1		c8		iny				iny 								; skip .
.82a2		a2 00		ldx #$00			ldx 	#0 							; get a term
.82a4		20 9f 98	jsr $989f			jsr 	EvaluateTerm
.82a7		a5 50		lda $50				lda 	NSStatus 					; needs to be an integer reference.
.82a9		c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.82ab		d0 22		bne $82cf			bne 	_ALType 					; otherwise typing error
.82ad		b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy reference address to zTemp0
.82af		85 36		sta $36				sta 	zTemp0 						; (e.g. where we store the address)
.82b1		b5 60		lda $60,x			lda 	NSMantissa1,x
.82b3		85 37		sta $37				sta 	zTemp0+1
.82b5		5a		phy				phy 								; copy address in (64k)
.82b6		a0 01		ldy #$01			ldy 	#1
.82b8		ad 1e 04	lda $041e			lda	 	AssemblerAddress
.82bb		92 36		sta ($36)			sta 	(zTemp0)
.82bd		ad 1f 04	lda $041f			lda	 	AssemblerAddress+1
.82c0		91 36		sta ($36),y			sta 	(zTemp0),y
.82c2		c8		iny				iny
.82c3		a9 00		lda #$00			lda 	#0 							; zero the rest.
.82c5		91 36		sta ($36),y			sta 	(zTemp0),y
.82c7		c8		iny				iny
.82c8		91 36		sta ($36),y			sta 	(zTemp0),y
.82ca		c8		iny				iny
.82cb		91 36		sta ($36),y			sta 	(zTemp0),y
.82cd		7a		ply				ply
.82ce		60		rts				rts
.82cf						_ALType:
.82cf		4c 00 a0	jmp $a000			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/operands.asm

.82d2						TypeAndCalculateOperand:
.82d2		b1 30		lda ($30),y			lda 	(codePtr),y
.82d4		a2 28		ldx #$28			ldx 	#AM_ACC 					; ACC if : or EOL
.82d6		c9 3a		cmp #$3a			cmp 	#KWD_COLON
.82d8		f0 5b		beq $8335			beq 	_TACOExit
.82da		c9 80		cmp #$80			cmp 	#KWC_EOL
.82dc		f0 57		beq $8335			beq 	_TACOExit
.82de		c8		iny				iny
.82df		a2 e0		ldx #$e0			ldx 	#AM_IMMEDIATE
.82e1		c9 23		cmp #$23			cmp 	#KWD_HASH 					; if hash, then immediate - constant.
.82e3		f0 51		beq $8336			beq 	CalculateOperand
.82e5		c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; if ( then check for indirection
.82e7		f0 1f		beq $8308			beq 	_TACOIndirect
.82e9		88		dey				dey 								; undo get of first character
.82ea		20 36 83	jsr $8336			jsr 	CalculateOperand 			; get operand
.82ed		b1 30		lda ($30),y			lda 	(codePtr),y
.82ef		a2 e4		ldx #$e4			ldx 	#AM_ZEROPAGE 				; if not, try zero page (then absolute)
.82f1		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.82f3		d0 40		bne $8335			bne 	_TACOExit
.82f5		c8		iny				iny
.82f6		20 40 83	jsr $8340			jsr 	TACOCheckXY 				; extract X,Y or 0 (neither) from the variable.
.82f9		a2 f4		ldx #$f4			ldx 	#AM_ZEROX 					; check for X
.82fb		c9 58		cmp #$58			cmp 	#'X'
.82fd		f0 36		beq $8335			beq 	_TACOExit
.82ff		a2 80		ldx #$80			ldx 	#AM_ZEROY 					; check for Y
.8301		c9 59		cmp #$59			cmp 	#'Y'
.8303		f0 30		beq $8335			beq 	_TACOExit
.8305						_TACOSyntax:
.8305		4c f6 9f	jmp $9ff6			jmp 	SyntaxError
.8308						_TACOIndirect:
.8308		20 36 83	jsr $8336			jsr 	CalculateOperand 			; get the operand
.830b		b1 30		lda ($30),y			lda 	(codePtr),y
.830d		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if , then it must be ,X)
.830f		f0 17		beq $8328			beq 	_TACOIndX
.8311		20 38 8f	jsr $8f38			jsr 	CheckRightBracket  			; otherwise must be ) or ),Y
.8314		b1 30		lda ($30),y			lda 	(codePtr),y
.8316		a2 d1		ldx #$d1			ldx 	#AM_IND
.8318		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not comma then exit with (xx)
.831a		d0 19		bne $8335			bne 	_TACOExit
.831c		c8		iny				iny
.831d		20 40 83	jsr $8340			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.8320		c9 59		cmp #$59			cmp 	#'Y' 						; check Y
.8322		d0 e1		bne $8305			bne 	_TACOSyntax
.8324		a2 d0		ldx #$d0			ldx 	#AM_INDY
.8326		80 0d		bra $8335			bra 	_TACOExit
.8328						_TACOIndX:
.8328		c8		iny				iny
.8329		20 40 83	jsr $8340			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.832c		c9 58		cmp #$58			cmp 	#'X' 						; check X
.832e		d0 d5		bne $8305			bne 	_TACOSyntax
.8330		20 38 8f	jsr $8f38			jsr 	CheckRightBracket			; check )
.8333		a2 c0		ldx #$c0			ldx 	#AM_INDX
.8335						_TACOExit:
.8335		60		rts				rts
.8336						CalculateOperand:
.8336		48		pha				pha
.8337		da		phx				phx
.8338		a2 00		ldx #$00			ldx 	#0 							; get 16 bit integer in Slot 0
.833a		20 f8 9d	jsr $9df8			jsr 	Evaluate16BitInteger
.833d		fa		plx				plx
.833e		68		pla				pla
.833f		60		rts				rts
.8340						TACOCheckXY:
.8340		b1 30		lda ($30),y			lda 	(codePtr),y
.8342		29 c0		and #$c0			and 	#$C0 						; check it is an identifier reference.
.8344		c9 40		cmp #$40			cmp 	#$40
.8346		d0 21		bne $8369			bne 	_TCXYFail
.8348		b1 30		lda ($30),y			lda 	(codePtr),y
.834a		18		clc				clc
.834b		69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.834d		85 37		sta $37				sta 	zTemp0+1
.834f		c8		iny				iny
.8350		b1 30		lda ($30),y			lda 	(codePtr),y
.8352		c8		iny				iny
.8353		85 36		sta $36				sta 	zTemp0
.8355		5a		phy				phy 								; save position
.8356		a0 02		ldy #$02			ldy 	#2 							; type is integer ?
.8358		b1 36		lda ($36),y			lda 	(zTemp0),y
.835a		d0 0c		bne $8368			bne 	_TCXYPopFail
.835c		a0 08		ldy #$08			ldy 	#8 							; get first character, should have bit 7 set as also last.
.835e		b1 36		lda ($36),y			lda 	(zTemp0),y
.8360		c9 d8		cmp #$d8			cmp 	#'X'+$80 					; should be X or Y
.8362		f0 08		beq $836c			beq 	_TCXYFound
.8364		c9 d9		cmp #$d9			cmp 	#'Y'+$80
.8366		f0 04		beq $836c			beq 	_TCXYFound
.8368						_TCXYPopFail:
.8368		7a		ply				ply
.8369						_TCXYFail:
.8369		a9 00		lda #$00			lda 	#0
.836b		60		rts				rts
.836c						_TCXYFound:
.836c		7a		ply				ply 								; restore position
.836d		29 7f		and #$7f			and 	#$7F 						; throw bit 7
.836f		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/backload.asm

.8370						BackloadProgram:
.8370		20 86 8a	jsr $8a86			jsr 	NewProgram 					; does the actual NEW.
.8373		a2 83		ldx #$83			ldx 	#_BLLoad >> 8
.8375		a9 c7		lda #$c7			lda 	#_BLLoad & $FF
.8377		20 aa 8f	jsr $8faa			jsr 	PrintStringXA
.837a		a9 14		lda #$14			lda 	#SOURCE_ADDRESS >> 13 		; start page
.837c		8d 59 06	sta $0659			sta 	BackLoadPage
.837f		a9 00		lda #$00			lda 	#(($6000) & $FF)
.8381		8d 5a 06	sta $065a			sta 	0+BackLoadPointer
.8384		a9 60		lda #$60			lda 	#(($6000) >> 8)
.8386		8d 5b 06	sta $065b			sta 	1+BackLoadPointer
.8389		a9 ff		lda #$ff			lda 	#$FF
.838b		8d fa ff	sta $fffa			sta 	$FFFA
.838e						_BPLoop:
.838e		a2 ff		ldx #$ff			ldx 	#$FF
.8390		20 dc 83	jsr $83dc			jsr 	BLReadByte 					; read a byte
.8393		c9 00		cmp #$00			cmp 	#0
.8395		f0 29		beq $83c0			beq 	_BPExit 					; if 0 exit
.8397		30 27		bmi $83c0			bmi 	_BPExit 					; if -ve exit
.8399						_BPCopy:
.8399		e8		inx				inx  								; copy byte into the lineBuffer
.839a		9d 2a 05	sta $052a,x			sta 	lineBuffer,x
.839d		9e 2b 05	stz $052b,x			stz 	lineBuffer+1,x
.83a0		20 dc 83	jsr $83dc			jsr 	BLReadByte 					; read next byte
.83a3		30 0a		bmi $83af			bmi 	_BPEndLine 					; -ve = EOL
.83a5		c9 09		cmp #$09			cmp 	#9 							; handle TAB, make it space.
.83a7		d0 02		bne $83ab			bne 	_BPNotTab
.83a9		a9 20		lda #$20			lda 	#' '
.83ab						_BPNotTab:
.83ab		c9 20		cmp #$20			cmp 	#' ' 						; < ' ' = EOL
.83ad		b0 ea		bcs $8399			bcs 	_BPCopy 					; until a control character, should be 13 received.
.83af						_BPEndLine:
.83af		20 67 80	jsr $8067			jsr 	TKTokeniseLine 				; tokenise the line.
.83b2		ad 2b 04	lda $042b			lda 	TokenLineNumber 			; line number = 0
.83b5		0d 2c 04	ora $042c			ora 	TokenLineNumber+1
.83b8		f0 d4		beq $838e			beq 	_BPLoop 					; not legal code, blank line or maybe a comment.
.83ba		38		sec				sec 								; append not insert
.83bb		20 50 a5	jsr $a550			jsr 	MemoryInsertLine 			; append to current program
.83be		80 ce		bra $838e			bra 	_BPLoop
.83c0						_BPExit:
.83c0		9c fa ff	stz $fffa			stz 	$FFFA
.83c3		20 c5 84	jsr $84c5			jsr 	ClearCommand 				; clear variables etc.
.83c6		60		rts				rts
.83c7						_BLLoad:
>83c7		4c 6f 61 64 69 6e 67 20				.text 	"Loading from Memory",13,0
>83cf		66 72 6f 6d 20 4d 65 6d 6f 72 79 0d 00
.83dc						BLReadByte:
.83dc		da		phx				phx
.83dd		a6 0b		ldx $0b				ldx 	8+3 						; save current mapping for $6000 in X
.83df		ad 59 06	lda $0659			lda 	BackLoadPage	 			; set current page
.83e2		85 0b		sta $0b				sta 	8+3
.83e4		ad 5a 06	lda $065a			lda 	BackLoadPointer 			; copy pointer to zTemp0
.83e7		85 36		sta $36				sta 	zTemp0
.83e9		ad 5b 06	lda $065b			lda 	BackLoadPointer+1
.83ec		85 37		sta $37				sta 	zTemp0+1
.83ee		b2 36		lda ($36)			lda 	(zTemp0) 					; read next byte
.83f0		ee 5a 06	inc $065a			inc 	BackLoadPointer 			; bump pointer
.83f3		d0 0f		bne $8404			bne 	_BLNoCarry
.83f5		ee 5b 06	inc $065b			inc 	BackLoadPointer+1
.83f8		10 0a		bpl $8404			bpl 	_BLNoCarry 					; need a new page
.83fa		48		pha				pha
.83fb		a9 60		lda #$60			lda 	#$60 						; reset pointer
.83fd		8d 5b 06	sta $065b			sta 	BackLoadPointer+1
.8400		ee 59 06	inc $0659			inc 	BackLoadPage 				; next page from source.
.8403		68		pla				pla
.8404						_BLNoCarry:
.8404		86 0b		stx $0b				stx 	8+3 						; restore mapping, then X.
.8406		fa		plx				plx
.8407		c9 00		cmp #$00			cmp 	#0
.8409		60		rts				rts
.0659						BackLoadPage:
>0659								.fill  	1
.065a						BackLoadPointer:
>065a								.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/editor.asm

.840a						EditProgramCode:
.840a		ad 2b 04	lda $042b			lda 	TokenLineNumber 			; try to find the line.
.840d		ae 2c 04	ldx $042c			ldx 	TokenLineNumber+1
.8410		20 f4 a5	jsr $a5f4			jsr 	MemorySearch
.8413		90 05		bcc $841a			bcc 	_EPCNoDelete 				; reached the end : don't delete
.8415		d0 03		bne $841a			bne 	_EPCNoDelete 				; found slot but didn't match : no delete
.8417		20 19 a5	jsr $a519			jsr 	MemoryDeleteLine 			; delete the line
.841a						_EPCNoDelete:
.841a		ad 2d 04	lda $042d			lda 	TokenBuffer 				; buffer empty - we just want to delete a line.
.841d		c9 80		cmp #$80			cmp 	#KWC_EOL
.841f		f0 0d		beq $842e			beq 	_EPCNoInsert
.8421		ad 2b 04	lda $042b			lda 	TokenLineNumber 			; find the line - it cannot exist as we've just deleted it.
.8424		ae 2c 04	ldx $042c			ldx 	TokenLineNumber+1 			; so this can't fail, it returns some point in the code.
.8427		20 f4 a5	jsr $a5f4			jsr 	MemorySearch
.842a		18		clc				clc 								; insert at this point.
.842b		20 50 a5	jsr $a550			jsr 	MemoryInsertLine 			; insert the line
.842e						_EPCNoInsert:
.842e		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/warmstart.asm

.842f						WarmStart:
.842f		a2 ff		ldx #$ff			ldx 	#$FF
.8431		9a		txs				txs
.8432		a9 85		lda #$85			lda 	#CLICommandLine+$80 		; set console colour whatever the current colour is.
.8434		20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8437		20 35 80	jsr $8035			jsr 	EXTInputLine 				; get line to lineBuffer
.843a		20 67 80	jsr $8067			jsr 	TKTokeniseLine 				; tokenise the line
.843d		ad 2b 04	lda $042b			lda 	TokenLineNumber 			; line number <> 0
.8440		0d 2c 04	ora $042c			ora 	TokenLineNumber+1
.8443		d0 17		bne $845c			bne 	_WSEditCode 				; if so,edit code.
.8445		9c 2a 04	stz $042a			stz 	TokenOffset 				; zero the "offset", meaning it only runs one line.
.8448		a9 2a		lda #$2a			lda 	#((TokenOffset) & $FF)
.844a		85 30		sta $30				sta 	codePtr
.844c		a9 04		lda #$04			lda 	#((TokenOffset) >> 8)
.844e		85 31		sta $31				sta 	codePtr+1
.8450		ad 2d 04	lda $042d			lda 	TokenBuffer 				; nothing to run
.8453		c9 80		cmp #$80			cmp 	#KWC_EOL
.8455		f0 d8		beq $842f			beq 	WarmStart
.8457		20 d9 8b	jsr $8bd9			jsr 	RUNCodePointerLine 			; execute that line.
.845a		80 d3		bra $842f			bra 	WarmStart
.845c						_WSEditCode:
.845c		20 0a 84	jsr $840a			jsr 	EditProgramCode 			; edit the program code
.845f		20 c5 84	jsr $84c5			jsr 	ClearCommand 				; clear all variables etc.
.8462		80 cb		bra $842f			bra 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assemble.asm

.8464						AssembleCommand:
.8464		a2 00		ldx #$00			ldx 	#0
.8466		20 f8 9d	jsr $9df8			jsr 	Evaluate16BitInteger 		; start address
.8469		a5 58		lda $58				lda 	NSMantissa0
.846b		8d 1e 04	sta $041e			sta 	AssemblerAddress
.846e		a5 60		lda $60				lda 	NSMantissa1
.8470		8d 1f 04	sta $041f			sta 	AssemblerAddress+1
.8473		20 40 8f	jsr $8f40			jsr 	CheckComma
.8476		20 13 9e	jsr $9e13			jsr 	Evaluate8BitInteger 		; options 0-3
.8479		a5 58		lda $58				lda 	NSMantissa0
.847b		8d 20 04	sta $0420			sta 	AssemblerControl
.847e		60		rts				rts
.847f		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assert.asm

.8480						AssertCommand:
.8480		a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.8482		20 e5 9d	jsr $9de5			jsr 	EvaluateInteger 			; the assert test
.8485		20 9a 9e	jsr $9e9a			jsr 	NSMIsZero 					; exit if result is non zero.
.8488		d0 05		bne $848f			bne 	_ACExit
.848a		a9 0a		lda #$0a		lda	#10
.848c		4c 51 8f	jmp $8f51		jmp	ErrorHandler
.848f						_ACExit:
.848f		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/call.asm

.8490						CallCommand:
.8490		a2 00		ldx #$00			ldx 	#0 							; get the routine address to level 0
.8492		20 f8 9d	jsr $9df8			jsr 	Evaluate16BitInteger
.8495						_CCClear
.8495		e8		inx				inx  								; clear 1,2 and 3 (for A X Y)
.8496		20 78 9e	jsr $9e78			jsr 	NSMSetZero 					; these are optional sequentially.
.8499		e0 04		cpx #$04			cpx 	#4
.849b		d0 f8		bne $8495			bne 	_CCClear
.849d		a2 00		ldx #$00			ldx 	#0 							; and keep trying while there are more values.
.849f						_CCCParam:
.849f		b1 30		lda ($30),y			lda 	(codePtr),y
.84a1		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.84a3		d0 09		bne $84ae			bne 	_CCCRun6502
.84a5		c8		iny				iny 								; skip comma
.84a6		e8		inx				inx	 								; next level
.84a7		20 13 9e	jsr $9e13			jsr 	Evaluate8BitInteger 		; get A/X/Y
.84aa		e0 03		cpx #$03			cpx 	#3
.84ac		90 f1		bcc $849f			bcc 	_CCCParam 					; done all 3 ?
.84ae						_CCCRun6502:
.84ae		5a		phy				phy 								; save position
.84af		a5 60		lda $60				lda 	NSMantissa1 				; put address in zTemp0
.84b1		85 37		sta $37				sta 	zTemp0+1
.84b3		a5 58		lda $58				lda 	NSMantissa0
.84b5		85 36		sta $36				sta 	zTemp0
.84b7		a5 59		lda $59				lda 	NSMantissa0+1 				; get registers into A X Y
.84b9		a6 5a		ldx $5a				ldx 	NSMantissa0+2
.84bb		a4 5b		ldy $5b				ldy 	NSMantissa0+3
.84bd		20 c2 84	jsr $84c2			jsr 	_CCCZTemp0 					; call zTemp0
.84c0		7a		ply				ply 								; restore position and exit
.84c1		60		rts				rts
.84c2						_CCCZTemp0:
.84c2		6c 36 00	jmp ($0036)			jmp 	(zTemp0)

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/clear.asm

.84c5						ClearCommand:
.84c5		a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.84c7		85 36		sta $36				sta 	0+zTemp0
.84c9		a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.84cb		85 37		sta $37				sta 	1+zTemp0
.84cd						_ClearZeroLoop:
.84cd		b2 36		lda ($36)			lda 	(zTemp0) 					; end of variables if offset is zero.
.84cf		f0 24		beq $84f5			beq 	_ClearZeroEnd
.84d1		a0 03		ldy #$03			ldy 	#3 							; erase the variables
.84d3		a9 00		lda #$00			lda 	#0 							; set all the data to zero.
.84d5						_ClearOneVariable:
.84d5		91 36		sta ($36),y			sta 	(zTemp0),y
.84d7		c8		iny				iny
.84d8		c0 08		cpy #$08			cpy 	#8
.84da		d0 f9		bne $84d5			bne 	_ClearOneVariable
.84dc		a0 02		ldy #$02			ldy 	#2 							; has it been marked procedure
.84de		b1 36		lda ($36),y			lda 	(zTemp0),y
.84e0		c9 18		cmp #$18			cmp 	#NSTProcedure
.84e2		d0 04		bne $84e8			bne 	_ClearNotProcedure
.84e4		a9 04		lda #$04			lda 	#NSTInteger+NSBIsArray 		; if so set it back to an integer array
.84e6		91 36		sta ($36),y			sta 	(zTemp0),y 					; will be fixed on the pre-run scan.
.84e8						_ClearNotProcedure:
.84e8		18		clc				clc 								; go to the next variable
.84e9		b2 36		lda ($36)			lda 	(zTemp0) 					; offset to next, add to zTemp0
.84eb		65 36		adc $36				adc 	zTemp0
.84ed		85 36		sta $36				sta 	zTemp0
.84ef		90 dc		bcc $84cd			bcc 	_ClearZeroLoop
.84f1		e6 37		inc $37				inc 	zTemp0+1
.84f3		80 d8		bra $84cd			bra 	_ClearZeroLoop
.84f5						_ClearZeroEnd:
.84f5		18		clc				clc
.84f6		a5 36		lda $36				lda 	zTemp0
.84f8		69 01		adc #$01			adc 	#1
.84fa		8d 0c 04	sta $040c			sta 	lowMemPtr
.84fd		a5 37		lda $37				lda 	zTemp0+1
.84ff		69 00		adc #$00			adc 	#0
.8501		8d 0d 04	sta $040d			sta 	lowMemPtr+1
.8504		20 80 a7	jsr $a780			jsr 	StackReset
.8507		20 e6 a7	jsr $a7e6			jsr 	StringSystemInitialise
.850a		20 41 8e	jsr $8e41			jsr 	ProcedureScan
.850d		20 88 8b	jsr $8b88			jsr 	Command_Restore
.8510		9c 1e 04	stz $041e			stz 	AssemblerAddress
.8513		9c 1f 04	stz $041f			stz 	AssemblerAddress+1
.8516		9c 20 04	stz $0420			stz 	AssemblerControl
.8519		20 8b 9a	jsr $9a8b			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.851c		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/cls.asm

.851d						ClearScreen:
.851d		5a		phy				phy
.851e		a9 0c		lda #$0c			lda 	#12 						; char code 12 clears the screen.
.8520		20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8523		7a		ply				ply
.8524		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/data.asm

.8525						Command_Data:
.8525		a9 3a		lda #$3a			lda 	#KWD_COLON 					; advance to colon/EOL, e.g. ignore anything till then.
.8527		a2 80		ldx #$80			ldx 	#KWC_EOL
.8529		20 93 8e	jsr $8e93			jsr 	ScanForward
.852c		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dim.asm

.852d						DimCommand:
.852d		b1 30		lda ($30),y			lda 	(codePtr),y
.852f		29 c0		and #$c0			and 	#$C0
.8531		c9 40		cmp #$40			cmp 	#$40
.8533		d0 7a		bne $85af			bne 	_DCSyntax 				; n o, error.
.8535		b1 30		lda ($30),y			lda 	(codePtr),y
.8537		18		clc				clc
.8538		69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.853a		85 3f		sta $3f				sta 	zaTemp+1
.853c		c8		iny				iny
.853d		b1 30		lda ($30),y			lda 	(codePtr),y
.853f		c8		iny				iny
.8540		85 3e		sta $3e				sta 	zaTemp
.8542		5a		phy				phy
.8543		a0 02		ldy #$02			ldy 	#2 						; read type byte
.8545		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8547		29 18		and #$18			and 	#NSBTypeMask 			; check it's not a procedure
.8549		c9 18		cmp #$18			cmp 	#NSTProcedure
.854b		f0 62		beq $85af			beq 	_DCSyntax
.854d		b1 3e		lda ($3e),y			lda 	(zaTemp),y 				; check it's an array
.854f		29 04		and #$04			and 	#NSBIsArray
.8551		f0 64		beq $85b7			beq 	_DCType
.8553		a0 04		ldy #$04			ldy 	#4 						; check not already defined
.8555		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8557		d0 59		bne $85b2			bne 	_DCRedefine
.8559		7a		ply				ply
.855a		20 ba 85	jsr $85ba			jsr 	_DCGetSize 				; get array size, check it.
.855d		5a		phy				phy
.855e		a0 05		ldy #$05			ldy 	#5 						; store in first array size slot
.8560		91 3e		sta ($3e),y			sta 	(zaTemp),y 				; second will be zero.
.8562		7a		ply				ply 							; is there a second (e.g. ,x)
.8563		b1 30		lda ($30),y			lda 	(codePtr),y
.8565		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8567		d0 0a		bne $8573			bne 	_DCOneDimension
.8569		c8		iny				iny 							; skip comma
.856a		20 ba 85	jsr $85ba			jsr 	_DCGetSize 				; get 2nd array size
.856d		5a		phy				phy
.856e		a0 06		ldy #$06			ldy 	#6 						; store in 2nd array size
.8570		91 3e		sta ($3e),y			sta 	(zaTemp),y
.8572		7a		ply				ply
.8573						_DCOneDimension:
.8573		5a		phy				phy 							; save position
.8574		a0 05		ldy #$05			ldy 	#5 						; dimensions + 1 in AX (as zero based)
.8576		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8578		aa		tax				tax
.8579		c8		iny				iny
.857a		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.857c		e8		inx				inx 							; bump them.
.857d		1a		inc a				inc 	a
.857e		20 23 9e	jsr $9e23			jsr 	Multiply8x8 			; work out the total number of elements -> zTemp0
.8581		a5 37		lda $37				lda 	zTemp0+1 				; don't allow more than 8192 elements whatever
.8583		29 e0		and #$e0			and 	#$E0
.8585		d0 23		bne $85aa			bne 	_DCSize
.8587		a0 02		ldy #$02			ldy 	#2 						; get base type
.8589		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.858b		20 c8 85	jsr $85c8			jsr 	ScaleByBaseType 		; scale by base type
.858e		a5 36		lda $36				lda 	zTemp0
.8590		a6 37		ldx $37				ldx 	zTemp0+1
.8592		20 4d 9a	jsr $9a4d			jsr 	AllocateXABytes 		; allocate memory
.8595		a0 03		ldy #$03			ldy 	#3 						; copy into the address.
.8597		91 3e		sta ($3e),y			sta 	(zaTemp),y
.8599		c8		iny				iny
.859a		8a		txa				txa
.859b		91 3e		sta ($3e),y			sta 	(zaTemp),y
.859d		7a		ply				ply 							; get position back
.859e		20 38 8f	jsr $8f38			jsr 	CheckRightBracket 		; check )
.85a1		b1 30		lda ($30),y			lda 	(codePtr),y
.85a3		c8		iny				iny 							; consume in case
.85a4		c9 2c		cmp #$2c			cmp 	#KWD_COMMA		 		; if so do another DIM.
.85a6		f0 85		beq $852d			beq 	DimCommand
.85a8		88		dey				dey 							; undo consume
.85a9		60		rts				rts
.85aa						_DCSize:
.85aa		a9 16		lda #$16		lda	#22
.85ac		4c 51 8f	jmp $8f51		jmp	ErrorHandler
.85af						_DCSyntax:
.85af		4c f6 9f	jmp $9ff6			jmp 	SyntaxError
.85b2						_DCRedefine:
.85b2		a9 15		lda #$15		lda	#21
.85b4		4c 51 8f	jmp $8f51		jmp	ErrorHandler
.85b7						_DCType:
.85b7		4c 00 a0	jmp $a000			jmp 	TypeError
.85ba						_DCGetSize:
.85ba		a2 00		ldx #$00			ldx 	#0 						; get first index.
.85bc		20 13 9e	jsr $9e13			jsr 	Evaluate8BitInteger 	; get array dimension
.85bf		c9 00		cmp #$00			cmp 	#0 						; must be 1-254
.85c1		f0 e7		beq $85aa			beq 	_DCSize
.85c3		c9 fe		cmp #$fe			cmp 	#254
.85c5		f0 e3		beq $85aa			beq 	_DCSize
.85c7		60		rts				rts
.85c8						ScaleByBaseType:
.85c8		29 10		and #$10			and 	#NSBIsString 			; is it string
.85ca		d0 19		bne $85e5			bne 	_SBBTString
.85cc		a5 37		lda $37				lda 	zTemp0+1 				; push value on stack
.85ce		48		pha				pha
.85cf		a5 36		lda $36				lda 	zTemp0
.85d1		48		pha				pha
.85d2		06 36		asl $36				asl 	zTemp0 					; x 2
.85d4		26 37		rol $37				rol 	zTemp0+1
.85d6		06 36		asl $36				asl 	zTemp0 					; x 4
.85d8		26 37		rol $37				rol 	zTemp0+1
.85da		68		pla				pla 							; add stacked value = x 5
.85db		65 36		adc $36				adc 	zTemp0
.85dd		85 36		sta $36				sta 	zTemp0
.85df		68		pla				pla
.85e0		65 37		adc $37				adc 	zTemp0+1
.85e2		85 37		sta $37				sta 	zTemp0+1
.85e4		60		rts				rts
.85e5						_SBBTString:
.85e5		06 36		asl $36				asl 	zTemp0
.85e7		26 37		rol $37				rol 	zTemp0+1
.85e9		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dokepoke.asm

.85ea						PokeCommand:
.85ea		18		clc				clc
.85eb		80 01		bra $85ee			bra 	DPCommand
.85ed						DokeCommand:
.85ed		38		sec				sec
.85ee						DPCommand:
.85ee		08		php				php									; save on stack, CS = Doke, CC = Poke
.85ef		a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.85f1		20 f8 9d	jsr $9df8			jsr		Evaluate16BitInteger 		; address
.85f4		20 40 8f	jsr $8f40			jsr 	CheckComma
.85f7		e8		inx				inx
.85f8		20 f8 9d	jsr $9df8			jsr		Evaluate16BitInteger 		; data
.85fb		a5 58		lda $58				lda 	NSMantissa0 				; copy address
.85fd		85 36		sta $36				sta 	zTemp0
.85ff		a5 60		lda $60				lda 	NSMantissa1
.8601		85 37		sta $37				sta 	zTemp0+1
.8603		a5 59		lda $59				lda 	NSMantissa0+1 				; low byte
.8605		92 36		sta ($36)			sta 	(zTemp0)
.8607		28		plp				plp 								; done if POKE
.8608		90 08		bcc $8612			bcc 	_DPExit
.860a		5a		phy				phy 								; write high byte out.
.860b		a0 01		ldy #$01			ldy 	#1
.860d		a5 61		lda $61				lda 	NSMantissa1+1
.860f		91 36		sta ($36),y			sta 	(zTemp0),y
.8611		7a		ply				ply
.8612						_DPExit:
.8612		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/end.asm

.8613						EndCommand:
.8613		4c 2f 84	jmp $842f			jmp 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/for.asm

.8616						ForCommand:
.8616		a9 d9		lda #$d9			lda 	#STK_FOR+9 					; allocate 18 bytes on the return stack (see above).
.8618		20 1a a7	jsr $a71a			jsr 	StackOpen
.861b		a2 00		ldx #$00			ldx 	#0
.861d		20 9f 98	jsr $989f			jsr 	EvaluateTerm
.8620		b5 50		lda $50,x			lda 	NSStatus,x
.8622		c9 20		cmp #$20			cmp 	#NSBIsReference+NSTInteger 	; do we have an integer 4 byte reference.
.8624		d0 47		bne $866d			bne		_FCError
.8626		a9 3d		lda #$3d			lda 	#KWD_EQUAL 					; =
.8628		20 48 8f	jsr $8f48			jsr 	CheckNextA
.862b		e8		inx				inx
.862c		20 e5 9d	jsr $9de5			jsr 	EvaluateInteger 			; <from> in +1
.862f		b1 30		lda ($30),y			lda 	(codePtr),y
.8631		c8		iny				iny 								; consume it
.8632		48		pha				pha 								; save on stack for later
.8633		c9 b7		cmp #$b7			cmp 	#KWD_DOWNTO
.8635		f0 04		beq $863b			beq 	_FCNoSyntax
.8637		c9 d2		cmp #$d2			cmp 	#KWD_TO
.8639		d0 35		bne $8670			bne 	_FCSyntaxError
.863b						_FCNoSyntax:
.863b		e8		inx				inx
.863c		20 e5 9d	jsr $9de5			jsr 	EvaluateInteger
.863f		20 5f a7	jsr $a75f			jsr 	STKSaveCodePosition 		; save loop back position
.8642		68		pla				pla 								; restore DOWNTO or TO
.8643		5a		phy				phy 								; save Y on the stack
.8644		49 b7		eor #$b7			eor 	#KWD_DOWNTO 				; 0 if DOWNTO, #0 if TO
.8646		f0 02		beq $864a			beq 	_FCNotDownTo
.8648		a9 02		lda #$02			lda 	#2
.864a						_FCNotDownTo:
.864a		3a		dec a				dec 	a 							; 255 if DOWNTO, 1 if TO
.864b		a0 10		ldy #$10			ldy 	#16
.864d		91 34		sta ($34),y			sta 	(basicStack),y 				; copy that out to the Basic Stack.
.864f		a0 06		ldy #$06			ldy 	#6 							; this is the address of the loop variable.
.8651		a5 58		lda $58				lda 	NSMantissa0
.8653		91 34		sta ($34),y			sta 	(basicStack),y
.8655		a5 60		lda $60				lda 	NSMantissa1
.8657		c8		iny				iny
.8658		91 34		sta ($34),y			sta 	(basicStack),y
.865a		a0 08		ldy #$08			ldy 	#8 							; set initial index value
.865c		a2 01		ldx #$01			ldx 	#1
.865e		20 73 86	jsr $8673			jsr 	FCIntegerToStack
.8661		a0 0c		ldy #$0c			ldy 	#12 						; set the terminal value
.8663		a2 02		ldx #$02			ldx 	#2
.8665		20 73 86	jsr $8673			jsr 	FCIntegerToStack
.8668		20 8e 86	jsr $868e			jsr 	CopyIndexToReference
.866b		7a		ply				ply 								; restore position
.866c		60		rts				rts
.866d						_FCError:
.866d		4c 00 a0	jmp $a000			jmp 	TypeError
.8670						_FCSyntaxError:
.8670		4c f6 9f	jmp $9ff6			jmp 	SyntaxError
.8673						FCIntegerToStack:
.8673		34 50		bit $50,x			bit 	NSStatus,x 					; is the value negative
.8675		10 03		bpl $867a			bpl	 	_FCNotNegative
.8677		20 41 9e	jsr $9e41			jsr 	NSMNegateMantissa 			; if so 2's complement the mantissa
.867a						_FCNotNegative:
.867a		b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy out to the basic stack
.867c		91 34		sta ($34),y			sta 	(basicStack),y
.867e		c8		iny				iny
.867f		b5 60		lda $60,x			lda 	NSMantissa1,x
.8681		91 34		sta ($34),y			sta 	(basicStack),y
.8683		c8		iny				iny
.8684		b5 68		lda $68,x			lda 	NSMantissa2,x
.8686		91 34		sta ($34),y			sta 	(basicStack),y
.8688		c8		iny				iny
.8689		b5 70		lda $70,x			lda 	NSMantissa3,x
.868b		91 34		sta ($34),y			sta 	(basicStack),y
.868d		60		rts				rts
.868e						CopyIndexToReference:
.868e		5a		phy				phy
.868f		a0 06		ldy #$06			ldy 	#6 							; copy address-8 to write to zTemp0
.8691		38		sec				sec 								; (because we copy from offset 8)
.8692		b1 34		lda ($34),y			lda 	(basicStack),y
.8694		e9 08		sbc #$08			sbc 	#8
.8696		85 36		sta $36				sta 	zTemp0
.8698		c8		iny				iny
.8699		b1 34		lda ($34),y			lda 	(basicStack),y
.869b		e9 00		sbc #$00			sbc 	#0
.869d		85 37		sta $37				sta 	zTemp0+1
.869f		a2 04		ldx #$04			ldx 	#4 							; this is the copy counter/
.86a1		a0 0b		ldy #$0b			ldy 	#8+3 		 				; the MSB of the mantissa
.86a3		b1 34		lda ($34),y			lda 	(basicStack),y
.86a5		0a		asl a				asl 	a 							; into carry
.86a6		a0 08		ldy #$08			ldy 	#8 							; where to copy from.
.86a8		90 14		bcc $86be			bcc 	_CITRNormal
.86aa		38		sec				sec
.86ab						_CITRNegative:
.86ab		a9 00		lda #$00			lda 	#0
.86ad		f1 34		sbc ($34),y			sbc 	(basicStack),y
.86af		91 36		sta ($36),y			sta 	(zTemp0),y
.86b1		c8		iny				iny
.86b2		ca		dex				dex
.86b3		d0 f6		bne $86ab			bne 	_CITRNegative
.86b5		88		dey				dey 								; look at MSB of mantissa
.86b6		b1 36		lda ($36),y			lda 	(zTemp0),y 					; set the MSB as negative packed.
.86b8		09 80		ora #$80			ora 	#$80
.86ba		91 36		sta ($36),y			sta 	(zTemp0),y
.86bc		7a		ply				ply
.86bd		60		rts				rts
.86be						_CITRNormal:
.86be		b1 34		lda ($34),y			lda 	(basicStack),y 				; copy without negation.
.86c0		91 36		sta ($36),y			sta 	(zTemp0),y
.86c2		c8		iny				iny
.86c3		ca		dex				dex
.86c4		d0 f8		bne $86be			bne 	_CITRNormal
.86c6		7a		ply				ply 								; and exit.
.86c7		60		rts				rts
.86c8						NextCommand:
.86c8		a9 d9		lda #$d9			lda 	#STK_FOR+9 					; check FOR is TOS
.86ca		a2 11		ldx #$11			ldx 	#ERRID_FOR 					; this error
.86cc		20 47 a7	jsr $a747			jsr 	StackCheckFrame
.86cf		5a		phy				phy
.86d0		a0 10		ldy #$10			ldy 	#16 						; get the step count
.86d2		b1 34		lda ($34),y			lda 	(basicStack),y
.86d4		85 36		sta $36				sta 	zTemp0 						; this is the sign extend
.86d6		30 02		bmi $86da			bmi 	_NCStepNeg
.86d8		64 36		stz $36				stz 	zTemp0 						; which is 0 or 255
.86da						_NCStepNeg:
.86da		a0 08		ldy #$08			ldy 	#8 							; offset to bump
.86dc		a2 04		ldx #$04			ldx 	#4 							; count to bump
.86de		18		clc				clc
.86df						_NCBump:
.86df		71 34		adc ($34),y			adc 	(basicStack),y 				; add it
.86e1		91 34		sta ($34),y			sta 	(basicStack),y
.86e3		a5 36		lda $36				lda 	zTemp0 						; get sign extend for next time.
.86e5		c8		iny				iny 								; next byte
.86e6		ca		dex				dex 								; do four times
.86e7		d0 f6		bne $86df			bne 	_NCBump
.86e9		20 8e 86	jsr $868e			jsr		CopyIndexToReference		; copy it to the reference variable.
.86ec		a0 10		ldy #$10			ldy 	#16 						; get step count again
.86ee		b1 34		lda ($34),y			lda 	(basicStack),y
.86f0		0a		asl a				asl 	a 							; sign bit to carry
.86f1		a9 0c		lda #$0c			lda 	#12 						; offset of LHS = terminal offset
.86f3		85 38		sta $38				sta 	zTemp1
.86f5		90 02		bcc $86f9			bcc 	_NCCompRev 					; use if step is +ve
.86f7		a9 08		lda #$08			lda 	#8 							; now the LHS = index value
.86f9						_NCCompRev:
.86f9		85 38		sta $38				sta 	zTemp1 						; so zTemp0 is the index for LHS
.86fb		49 04		eor #$04			eor 	#(8^12) 					; and zTemp0+1 is the index for RHS
.86fd		85 39		sta $39				sta 	zTemp1+1
.86ff		a2 04		ldx #$04			ldx 	#4 							; bytes to compare
.8701		38		sec				sec
.8702						_NCCompare:
.8702		a4 38		ldy $38				ldy 	zTemp1 						; do compare using the two indices
.8704		b1 34		lda ($34),y			lda 	(basicStack),y
.8706		a4 39		ldy $39				ldy 	zTemp1+1
.8708		f1 34		sbc ($34),y			sbc 	(basicStack),y
.870a		e6 38		inc $38				inc 	zTemp1 						; bump the indices (inc,dex do not change C or V)
.870c		e6 39		inc $39				inc 	zTemp1+1
.870e		ca		dex				dex 								; do it 4 times.
.870f		d0 f1		bne $8702			bne 	_NCCompare
.8711		50 02		bvc $8715			bvc 	_NCNoOverflow 				; convert to signed comparison
.8713		49 80		eor #$80			eor 	#$80
.8715						_NCNoOverflow:
.8715		7a		ply				ply 								; restore Y position
.8716		0a		asl a				asl 	a 							; is bit 7 set.
.8717		90 04		bcc $871d			bcc 	_NCLoopback 				; if no , >= so loop back
.8719		20 39 a7	jsr $a739			jsr 	StackClose 					; exit the loop
.871c		60		rts				rts
.871d						_NCLoopBack:
.871d		20 70 a7	jsr $a770			jsr 	STKLoadCodePosition 		; loop back
.8720		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/gosub.asm

.8721						Command_GOSUB:
.8721		a2 00		ldx #$00			ldx 	#0
.8723		20 f8 9d	jsr $9df8			jsr 	Evaluate16BitInteger 		; line number in Stack.0
.8726		a9 e3		lda #$e3			lda 	#STK_GOSUB+3
.8728		20 1a a7	jsr $a71a			jsr 	StackOpen 					; create frame
.872b		20 5f a7	jsr $a75f			jsr 	STKSaveCodePosition 		; save current position
.872e		4c 44 87	jmp $8744			jmp 	GotoStackX
.8731						Command_RETURN:
.8731		a9 e0		lda #$e0			lda 	#STK_GOSUB 					; check TOS is this
.8733		a2 0e		ldx #$0e			ldx 	#ERRID_GOSUB 				; this error
.8735		20 47 a7	jsr $a747			jsr 	StackCheckFrame
.8738		20 70 a7	jsr $a770			jsr 	STKLoadCodePosition 		; restore code position
.873b		20 39 a7	jsr $a739			jsr 	StackClose
.873e		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/goto.asm

.873f						GotoCommand:
.873f		a2 00		ldx #$00			ldx 	#0 							; GOTO where
.8741		20 f8 9d	jsr $9df8			jsr 	Evaluate16BitInteger
.8744						GotoStackX:
.8744		b5 60		lda $60,x			lda  	NSMantissa1,x 				; put line # in XA. I'll keep this even though
.8746		48		pha				pha 								; it is slightly inefficient, just in cases.
.8747		b5 58		lda $58,x			lda 	NSMantissa0,x
.8749		fa		plx				plx
.874a		20 f4 a5	jsr $a5f4			jsr 	MemorySearch 				; transfer to line number AX.
.874d		90 05		bcc $8754			bcc 	_GotoError 					; not found, off end.
.874f		d0 03		bne $8754			bne 	_GotoError 					; not found exactly
.8751		4c d2 8b	jmp $8bd2			jmp 	RunNewLine 					; and go straight to new line code.
.8754						_GotoError:
.8754		a9 0d		lda #$0d		lda	#13
.8756		4c 51 8f	jmp $8f51		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/if.asm

.8759						IfCommand:
.8759		a2 00		ldx #$00			ldx 	#0 							; Get the if test.
.875b		20 c6 9d	jsr $9dc6			jsr 	EvaluateNumber
.875e		b1 30		lda ($30),y			lda 	(codePtr),y
.8760		c9 aa		cmp #$aa			cmp 	#KWD_THEN  					; could be THEN <stuff>
.8762		d0 0a		bne $876e			bne 	_IFStructured 				; we still support it.
.8764		c8		iny				iny 								; consume THEN
.8765		20 9a 9e	jsr $9e9a			jsr 	NSMIsZero 					; is it zero
.8768		f0 01		beq $876b			beq 	_IfFail 					; if fail, go to next line
.876a		60		rts				rts 								; if THEN just continue
.876b						_IfFail:
.876b		4c ba 8b	jmp $8bba			jmp 	EOLCommand
.876e						_IfStructured:
.876e		20 9a 9e	jsr $9e9a			jsr 	NSMIsZero 					; is it zero
.8771		d0 07		bne $877a			bne 	_IfExit 					; if not, then continue normally.
.8773		a9 b8		lda #$b8			lda 	#KWD_ELSE 					; look for else/endif
.8775		a2 a7		ldx #$a7			ldx 	#KWD_ENDIF
.8777		20 93 8e	jsr $8e93			jsr 	ScanForward 				; and run from there
.877a						_IfExit:
.877a		60		rts				rts
.877b						ElseCode:
.877b		a9 a7		lda #$a7			lda 	#KWD_ENDIF 					; else is only run after the if clause succeeds
.877d		aa		tax				tax 								; so just go to the structure exit
.877e		20 93 8e	jsr $8e93			jsr 	ScanForward
.8781		60		rts				rts
.8782						EndIf:
.8782		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/inputprint.asm

.8783						Command_Input:
.8783		a9 ff		lda #$ff			lda 	#$FF 						; set input flag
.8785		8d 28 04	sta $0428			sta 	IsInputFlag
.8788		80 03		bra $878d			bra 	Command_IP_Main
.878a						Command_Print:
.878a		9c 28 04	stz $0428			stz 	IsInputFlag 				; clear input flag
.878d						Command_IP_Main:
.878d		18		clc				clc 								; carry being clear means last print wasn't comma/semicolon
.878e						_CPLoop:
.878e		08		php				php 								; save last action flag
.878f		b1 30		lda ($30),y			lda 	(codePtr),y
.8791		c9 80		cmp #$80			cmp  	#KWC_EOL 					; end of line or colon, exit now.
.8793		f0 54		beq $87e9			beq 	_CPExit
.8795		c9 3a		cmp #$3a			cmp 	#KWD_COLON
.8797		f0 50		beq $87e9			beq 	_CPExit
.8799		68		pla				pla 								; throw last action flag
.879a		b1 30		lda ($30),y			lda 	(codePtr),y
.879c		c8		iny				iny
.879d		c9 3b		cmp #$3b			cmp 	#KWD_SEMICOLON				; is it a semicolon
.879f		f0 45		beq $87e6			beq 	_CPContinueWithSameLine
.87a1		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; comma
.87a3		f0 3c		beq $87e1			beq 	_CPTab
.87a5		c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; apostrophe (new line)
.87a7		f0 34		beq $87dd			beq 	_CPNewLine
.87a9		88		dey				dey 								; undo the get.
.87aa		20 53 94	jsr $9453			jsr 	EvaluateExpressionAt0 		; evaluate expression at 0.
.87ad		b5 50		lda $50,x			lda 	NSStatus,x 					; read the status
.87af		29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.87b1		f0 0d		beq $87c0			beq 	_CPIsValue 					; no, display it.
.87b3		ad 28 04	lda $0428			lda 	IsInputFlag 				; if print, dereference and print.
.87b6		f0 05		beq $87bd			beq 	_CPIsPrint 					; otherwise display.
.87b8		20 f2 87	jsr $87f2			jsr 	CIInputValue 				; input a value to the reference
.87bb		80 20		bra $87dd			bra 	_CPNewLine
.87bd						_CPIsPrint:
.87bd		20 18 97	jsr $9718			jsr 	Dereference 				; dereference if required.
.87c0						_CPIsValue:
.87c0		b5 50		lda $50,x			lda 	NSStatus,x 					; is it a number
.87c2		29 10		and #$10			and 	#NSBIsString
.87c4		f0 09		beq $87cf			beq 	_CPNumber
.87c6		a6 60		ldx $60				ldx 	NSMantissa1 				; string, print the text.
.87c8		a5 58		lda $58				lda 	NSMantissa0
.87ca		20 55 88	jsr $8855			jsr 	CPPrintStringXA
.87cd		80 be		bra $878d			bra 	Command_IP_Main 			; loop round clearing carry so NL if end
.87cf						_CPNumber:
.87cf		a9 05		lda #$05			lda 	#5 							; maximum decimals
.87d1		20 ad 9c	jsr $9cad			jsr 	ConvertNumberToString 		; convert to string (in unary str$() function)
.87d4		a2 06		ldx #$06			ldx 	#DecimalBuffer >> 8
.87d6		a9 49		lda #$49			lda 	#DecimalBuffer & $FF
.87d8		20 55 88	jsr $8855			jsr 	CPPrintStringXA 			; print it.
.87db		80 b0		bra $878d			bra 	Command_IP_Main				; loop round clearing carry so NL if end
.87dd						_CPNewLine:
.87dd		a9 0d		lda #$0d			lda 	#13
.87df		80 02		bra $87e3			bra 	_CPPrintChar
.87e1						_CPTab:
.87e1		a9 09		lda #$09			lda 	#9 							; print TAB
.87e3						_CPPrintChar:
.87e3		20 68 88	jsr $8868			jsr 	CPPrintVector
.87e6						_CPContinueWithSameLine:
.87e6		38		sec				sec 								; loop round with carry set, which
.87e7		80 a5		bra $878e			bra 	_CPLoop 					; will inhibit final CR
.87e9						_CPExit:
.87e9		28		plp				plp 								; get last action flag
.87ea		b0 05		bcs $87f1			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.87ec		a9 0d		lda #$0d			lda 	#13 						; print new line
.87ee		20 68 88	jsr $8868			jsr 	CPPrintVector
.87f1						_CPExit2:
.87f1		60		rts				rts
.87f2						CIInputValue:
.87f2		a2 00		ldx #$00			ldx 	#0 							; input a line.
.87f4						_CIInputLine:
.87f4		20 6b 88	jsr $886b			jsr 	CPInputVector 				; get key
.87f7		c9 0d		cmp #$0d			cmp 	#13 						; 13 = End
.87f9		f0 1f		beq $881a			beq 	_CIHaveValue
.87fb		c9 08		cmp #$08			cmp 	#8 							; 8 = BS
.87fd		f0 11		beq $8810			beq 	_CIBackspace
.87ff		c9 20		cmp #$20			cmp 	#32 						; ignore other control characters
.8801		90 f1		bcc $87f4			bcc 	_CIInputLine
.8803		e0 50		cpx #$50			cpx 	#80 						; max length
.8805		b0 ed		bcs $87f4			bcs 	_CIInputLine
.8807		9d 2a 05	sta $052a,x			sta 	lineBuffer,x
.880a		e8		inx				inx
.880b		20 68 88	jsr $8868			jsr 	CPPrintVector 				; echo it.
.880e		80 e4		bra $87f4			bra 	_CIInputLine
.8810						_CIBackSpace:
.8810		e0 00		cpx #$00			cpx 	#0 							; nothing to delete
.8812		f0 e0		beq $87f4			beq 	_CIInputLine
.8814		20 68 88	jsr $8868			jsr 	CPPrintVector 				; echo it.
.8817		ca		dex				dex
.8818		80 da		bra $87f4			bra 	_CIInputLine
.881a						_CIHaveValue:
.881a		9e 2a 05	stz $052a,x			stz 	LineBuffer,x 				; ASCIIZ string now in line buffer.
.881d		a5 50		lda $50				lda 	NSStatus 					; was it a string assignment
.881f		29 10		and #$10			and 	#NSBIsString
.8821		f0 17		beq $883a			beq 	_CIAssignNumber 			; assign a number
.8823		a2 01		ldx #$01			ldx 	#1
.8825		a9 2a		lda #$2a			lda 	#lineBuffer & $FF 			; set up to point to new string
.8827		95 58		sta $58,x			sta 	NSMantissa0,x
.8829		a9 05		lda #$05			lda 	#lineBuffer >> 8
.882b		95 60		sta $60,x			sta 	NSMantissa1,x
.882d		74 68		stz $68,x			stz 	NSMantissa2,x
.882f		74 70		stz $70,x			stz 	NSMantissa3,x
.8831		a9 10		lda #$10			lda 	#NSBIsString 				; so it becomes a string value
.8833		95 50		sta $50,x			sta  	NSStatus,x
.8835		ca		dex				dex 								; X = 0
.8836		20 a7 88	jsr $88a7			jsr 	AssignVariable
.8839		60		rts				rts
.883a						_CIAssignNumber:
.883a		a9 2a		lda #$2a			lda 	#lineBuffer & $FF 			; set up to point to new string
.883c		85 36		sta $36				sta 	zTemp0
.883e		a9 05		lda #$05			lda 	#lineBuffer >> 8
.8840		85 37		sta $37				sta 	zTemp0+1
.8842		a2 01		ldx #$01			ldx 	#1 							; put in slot 1
.8844		20 2f 9c	jsr $9c2f			jsr 	ValEvaluateZTemp0 			; use the VAL() code
.8847		90 07		bcc $8850			bcc 	_CIIsOkay
.8849		a9 3f		lda #$3f			lda 	#"?" 						; error ?
.884b		20 68 88	jsr $8868			jsr 	CPPrintVector
.884e		80 a2		bra $87f2			bra 	CIInputValue
.8850						_CIIsOkay:
.8850		ca		dex				dex 								; X = 0
.8851		20 a7 88	jsr $88a7			jsr 	AssignVariable
.8854		60		rts				rts
.8855						CPPrintStringXA:
.8855		5a		phy				phy
.8856		86 37		stx $37				stx 	zTemp0+1
.8858		85 36		sta $36				sta 	zTemp0
.885a		a0 00		ldy #$00			ldy 	#0
.885c						_PSXALoop:
.885c		b1 36		lda ($36),y			lda 	(zTemp0),y
.885e		f0 06		beq $8866			beq 	_PSXAExit
.8860		20 68 88	jsr $8868			jsr 	CPPrintVector
.8863		c8		iny				iny
.8864		80 f6		bra $885c			bra 	_PSXALoop
.8866						_PSXAExit:
.8866		7a		ply				ply
.8867		60		rts				rts
.8868						CPPrintVector:
.8868		4c 03 80	jmp $8003			jmp 	EXTPrintCharacter
.886b						CPInputVector:
.886b		4c 17 80	jmp $8017			jmp 	EXTInputSingleCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/let.asm

.886e						LetCommand:
.886e		a2 00		ldx #$00			ldx 	#0
.8870		b1 30		lda ($30),y			lda 	(codePtr),y
.8872		c9 10		cmp #$10			cmp 	#KWD_AT
.8874		d0 14		bne $888a			bne 	_LCStandard
.8876		c8		iny				iny 								; skip equal
.8877		20 9f 98	jsr $989f			jsr 	EvaluateTerm 				; get a number (the address of the reference)
.887a		20 18 97	jsr $9718			jsr 	Dereference 				; dereference it to a value
.887d		b5 50		lda $50,x			lda 	NSStatus,x 					; check integer
.887f		49 20		eor #$20			eor 	#NSBIsReference	 			; toggle reference
.8881		95 50		sta $50,x			sta 	NSStatus,x
.8883		29 20		and #$20			and 	#NSBIsReference 			; if it is now a reference, continue
.8885		d0 0f		bne $8896			bne 	_LCMain
.8887		4c 00 a0	jmp $a000			jmp 	TypeError 					; was a reference before.
.888a						_LCStandard:
.888a		ad 3d 94	lda $943d			lda 	PrecedenceLevel+"*"			; precedence > this
.888d		20 57 94	jsr $9457			jsr 	EvaluateExpressionAtPrecedence
.8890		b5 50		lda $50,x			lda 	NSStatus,x 					; is it a reference to an array marked as procedure ?
.8892		c9 38		cmp #$38			cmp		#NSTProcedure+NSBIsReference
.8894		f0 0e		beq $88a4			beq 	_LetGoProc 					; it's a procedure call.
.8896						_LCMain:
.8896		a9 3d		lda #$3d			lda 	#"=" 						; check =
.8898		20 48 8f	jsr $8f48			jsr 	CheckNextA
.889b		e8		inx				inx 								; RHS
.889c		20 bd 9d	jsr $9dbd			jsr 	EvaluateValue
.889f		ca		dex				dex
.88a0		20 a7 88	jsr $88a7			jsr 	AssignVariable
.88a3		60		rts				rts
.88a4						_LetGoProc:
.88a4		4c 90 8a	jmp $8a90			jmp 	CallProcedure
.88a7						AssignVariable:
.88a7		b5 50		lda $50,x			lda 	NSStatus,x 					; check the string/number type bits match
.88a9		48		pha				pha 								; save a copy
.88aa		55 51		eor $51,x			eor 	NSStatus+1,x
.88ac		29 10		and #$10			and 	#NSBIsString
.88ae		d0 0b		bne $88bb			bne 	_ASError
.88b0		68		pla				pla 								; get back
.88b1		29 10		and #$10			and 	#NSBIsString 				; check type
.88b3		d0 03		bne $88b8			bne 	_ASString
.88b5		4c 56 96	jmp $9656			jmp 	AssignNumber
.88b8						_ASString:
.88b8		4c b4 96	jmp $96b4			jmp 	AssignString
.88bb						_ASError:
.88bb		4c 00 a0	jmp $a000			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/list.asm

.88be						Command_List:
.88be		9c 26 04	stz $0426			stz 	listIndent 					; reset indent.
.88c1		b1 30		lda ($30),y			lda 	(codePtr),y
.88c3		29 c0		and #$c0			and 	#$C0 				 		; if so, we are list procedure() which is a seperate block
.88c5		c9 40		cmp #$40			cmp 	#$40  						; of code.
.88c7		f0 6e		beq $8937			beq 	_CLListProcedure
.88c9		64 5c		stz $5c				stz		NSMantissa0+4				; set the lower (slot 4) to 0 and upper (slot 7) to $FFFF
.88cb		64 64		stz $64				stz 	NSMantissa1+4 				; these are the default top and bottom.
.88cd		a9 ff		lda #$ff			lda 	#$FF
.88cf		85 5f		sta $5f				sta 	NSMantissa0+7
.88d1		85 67		sta $67				sta 	NSMantissa1+7
.88d3		b1 30		lda ($30),y			lda 	(codePtr),y
.88d5		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.88d7		f0 1a		beq $88f3			beq 	_CLSecond
.88d9		20 b4 89	jsr $89b4			jsr 	CLIsDigit 					; if not digit, list all
.88dc		b0 20		bcs $88fe			bcs 	_CLStart
.88de		a2 04		ldx #$04			ldx 	#4 							; get 1st range into slot 4
.88e0		20 f8 9d	jsr $9df8			jsr 	Evaluate16BitInteger
.88e3		b1 30		lda ($30),y			lda 	(codePtr),y
.88e5		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.88e7		f0 0a		beq $88f3			beq 	_CLSecond 					; if so go get it
.88e9		a5 5c		lda $5c				lda 	NSMantissa0+4 				; copy 4->7
.88eb		85 5f		sta $5f				sta 	NSMantissa0+7
.88ed		a5 64		lda $64				lda 	NSMantissa1+4
.88ef		85 67		sta $67				sta 	NSMantissa1+7
.88f1		80 0b		bra $88fe			bra 	_CLStart
.88f3						_CLSecond:
.88f3		c8		iny				iny 								; consume comma
.88f4		20 b4 89	jsr $89b4			jsr 	CLIsDigit 					; digit found
.88f7		b0 05		bcs $88fe			bcs 	_CLStart 					; if not, continue listing
.88f9		a2 07		ldx #$07			ldx 	#7 							; load 2nd range into slot 7
.88fb		20 f8 9d	jsr $9df8			jsr 	Evaluate16BitInteger
.88fe						_CLStart
.88fe		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8900		85 30		sta $30				sta 	codePtr
.8902		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8904		85 31		sta $31				sta 	codePtr+1
.8906						_CLLoop:
.8906		20 21 80	jsr $8021			jsr 	EXTBreakCheck 				; break check here, as we want the option of breaking out of long lists.
.8909		f0 27		beq $8932			beq 	_CLBreak
.890b		b2 30		lda ($30)			lda 	(codePtr)
.890d		f0 20		beq $892f			beq 	_CLExit
.890f		a2 04		ldx #$04			ldx 	#4 							; check range every time, line numbers aren't in order.
.8911		20 a3 89	jsr $89a3			jsr 	CLCompareLineNo
.8914		90 0c		bcc $8922			bcc 	_CLNext
.8916		a2 07		ldx #$07			ldx 	#7
.8918		20 a3 89	jsr $89a3			jsr 	CLCompareLineNo
.891b		f0 02		beq $891f			beq 	_CLDoThisOne
.891d		b0 03		bcs $8922			bcs 	_CLNext
.891f						_CLDoThisOne:
.891f		20 90 89	jsr $8990			jsr 	CLListOneLine 				; routine to list the current line.
.8922						_CLNext:
.8922		18		clc				clc
.8923		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8925		65 30		adc $30				adc 	codePtr
.8927		85 30		sta $30				sta 	codePtr
.8929		90 02		bcc $892d			bcc 	_CREExit
.892b		e6 31		inc $31				inc 	codePtr+1 					; carry
.892d						_CREExit:
.892d		80 d7		bra $8906			bra 	_CLLoop
.892f						_CLExit:
.892f		4c 2f 84	jmp $842f			jmp 	WarmStart
.8932						_CLBreak:
.8932		a9 01		lda #$01		lda	#1
.8934		4c 51 8f	jmp $8f51		jmp	ErrorHandler
.8937						_CLListProcedure:
.8937		b1 30		lda ($30),y			lda 	(codePtr),y
.8939		85 38		sta $38				sta 	zTemp1
.893b		c8		iny				iny
.893c		b1 30		lda ($30),y			lda 	(codePtr),y
.893e		85 39		sta $39				sta 	zTemp1+1
.8940		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8942		85 30		sta $30				sta 	codePtr
.8944		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8946		85 31		sta $31				sta 	codePtr+1
.8948						_CLLPSearch:
.8948		b2 30		lda ($30)			lda 	(codePtr)
.894a		c9 00		cmp #$00			cmp 	#0 							; if zero, end
.894c		f0 e1		beq $892f			beq 	_CLExit
.894e		a0 03		ldy #$03			ldy 	#3 							; check if PROC something
.8950		b1 30		lda ($30),y			lda 	(codePtr),y
.8952		c9 a4		cmp #$a4			cmp 	#KWD_PROC
.8954		d0 0e		bne $8964			bne 	_CLLPNext
.8956		c8		iny				iny 								; check if PROC this.
.8957		b1 30		lda ($30),y			lda 	(codePtr),y
.8959		c5 38		cmp $38				cmp 	zTemp1 						; does it match ?
.895b		d0 07		bne $8964			bne 	_CLLPNext
.895d		c8		iny				iny
.895e		b1 30		lda ($30),y			lda 	(codePtr),y
.8960		c5 39		cmp $39				cmp 	zTemp1+1
.8962		f0 0d		beq $8971			beq 	_CLLPFound
.8964						_CLLPNext:
.8964		18		clc				clc
.8965		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8967		65 30		adc $30				adc 	codePtr
.8969		85 30		sta $30				sta 	codePtr
.896b		90 02		bcc $896f			bcc 	_CREExit
.896d		e6 31		inc $31				inc 	codePtr+1 					; carry
.896f						_CREExit:
.896f		80 d7		bra $8948			bra 	_CLLPSearch
.8971						_CLLPFound:
.8971		b2 30		lda ($30)			lda 	(codePtr)
.8973		f0 ba		beq $892f			beq 	_CLExit
.8975		a0 03		ldy #$03			ldy 	#3 							; get first keyword
.8977		b1 30		lda ($30),y			lda 	(codePtr),y
.8979		48		pha				pha
.897a		20 90 89	jsr $8990			jsr 	CLListOneLine 				; list line and go forward
.897d		18		clc				clc
.897e		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8980		65 30		adc $30				adc 	codePtr
.8982		85 30		sta $30				sta 	codePtr
.8984		90 02		bcc $8988			bcc 	_CREExit
.8986		e6 31		inc $31				inc 	codePtr+1 					; carry
.8988						_CREExit:
.8988		68		pla				pla 								; reached ENDPROC ?
.8989		c9 a8		cmp #$a8			cmp 	#KWD_ENDPROC
.898b		d0 e4		bne $8971			bne 	_CLLPFound
.898d		4c 2f 84	jmp $842f			jmp 	WarmStart
.8990						CLListOneLine:
.8990		20 f6 8e	jsr $8ef6			jsr 	ScanGetCurrentLineStep 		; get indent adjust.
.8993		20 5d 80	jsr $805d			jsr 	TKListConvertLine 			; convert line into token Buffer
.8996		a2 04		ldx #$04			ldx 	#(tokenBuffer >> 8) 		; print that line
.8998		a9 2d		lda #$2d			lda 	#(tokenBuffer & $FF)
.899a		20 aa 8f	jsr $8faa			jsr 	PrintStringXA
.899d		a9 0d		lda #$0d			lda 	#13 						; new line
.899f		20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.89a2		60		rts				rts
.89a3						CLCompareLineNo:
.89a3		38		sec				sec
.89a4		a0 01		ldy #$01			ldy 	#1
.89a6		b1 30		lda ($30),y			lda 	(codePtr),y
.89a8		f5 58		sbc $58,x			sbc 	NSMantissa0,x
.89aa		85 36		sta $36				sta 	zTemp0
.89ac		c8		iny				iny
.89ad		b1 30		lda ($30),y			lda 	(codePtr),y
.89af		f5 60		sbc $60,x			sbc 	NSMantissa1,x
.89b1		05 36		ora $36				ora 	zTemp0
.89b3		60		rts				rts
.89b4						CLIsDigit:
.89b4		b1 30		lda ($30),y			lda 	(codePtr),y
.89b6		c9 30		cmp #$30			cmp 	#"0"
.89b8		90 03		bcc $89bd			bcc	 	_CLIDExitFalse
.89ba		c9 3a		cmp #$3a			cmp 	#"9"+1
.89bc		60		rts				rts
.89bd						_CLIDExitFalse:
.89bd		38		sec				sec
.89be		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/local.asm

.89bf						Command_LOCAL:
.89bf		a2 00		ldx #$00			ldx 	#0 							; at level 0
.89c1		20 cd 89	jsr $89cd			jsr 	LocaliseNextTerm 			; convert term to a local.
.89c4		b1 30		lda ($30),y			lda 	(codePtr),y
.89c6		c8		iny				iny
.89c7		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.89c9		f0 f4		beq $89bf			beq 	Command_LOCAL 				; if so, localise another variable.
.89cb		88		dey				dey 								; unpick pre-get
.89cc		60		rts				rts
.89cd						LocaliseNextTerm:
.89cd		20 9f 98	jsr $989f			jsr 	EvaluateTerm 				; evaluate the term
.89d0		b5 50		lda $50,x			lda 	NSStatus,x
.89d2		29 20		and #$20			and 	#NSBIsReference 			; check it is a reference, must be a variable.
.89d4		f0 5c		beq $8a32			beq		_LNTError
.89d6		b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address of variable to zTemp0
.89d8		85 36		sta $36				sta 	zTemp0
.89da		b5 60		lda $60,x			lda 	NSMantissa1,x
.89dc		85 37		sta $37				sta  	zTemp0+1
.89de		b5 50		lda $50,x			lda 	NSStatus,x 					; figure out what it is.
.89e0		29 10		and #$10			and 	#NSBIsString
.89e2		d0 1e		bne $8a02			bne 	_LNTPushString
.89e4		5a		phy				phy
.89e5		a0 00		ldy #$00			ldy 	#0 							; push 0 to 4 inclusive, the number values, on the stack, and zero them as you go.
.89e7						_LNTPushNumLoop:
.89e7		b1 36		lda ($36),y			lda		(zTemp0),y
.89e9		20 f9 a6	jsr $a6f9			jsr 	StackPushByte
.89ec		c8		iny				iny
.89ed		c0 05		cpy #$05			cpy 	#5
.89ef		d0 f6		bne $89e7			bne 	_LNTPushNumLoop
.89f1		a5 36		lda $36				lda 	zTemp0 						; push the actual target address to write on the stack
.89f3		20 f9 a6	jsr $a6f9			jsr 	StackPushByte
.89f6		a5 37		lda $37				lda 	zTemp0+1
.89f8		20 f9 a6	jsr $a6f9			jsr 	StackPushByte
.89fb		a9 01		lda #$01			lda 	#STK_LOCALN 				; push local-number marker.
.89fd		20 f9 a6	jsr $a6f9			jsr 	StackPushByte
.8a00		7a		ply				ply
.8a01		60		rts				rts
.8a02						_LNTPushString:
.8a02		5a		phy				phy
.8a03		b2 36		lda ($36)			lda 	(zTemp0) 					; put address of string in zTemp1
.8a05		85 38		sta $38				sta 	zTemp1
.8a07		a0 01		ldy #$01			ldy 	#1
.8a09		b1 36		lda ($36),y			lda 	(zTemp0),y
.8a0b		85 39		sta $39				sta 	zTemp1+1
.8a0d		a0 00		ldy #$00			ldy 	#0 							; output string
.8a0f		c9 00		cmp #$00			cmp 	#0 							; if not assigned string
.8a11		f0 0a		beq $8a1d			beq 	_LNTStringOut
.8a13						_LNTPushStrLoop:
.8a13		b1 38		lda ($38),y			lda 	(zTemp1),y
.8a15		f0 06		beq $8a1d			beq 	_LNTStringOut
.8a17		20 f9 a6	jsr $a6f9			jsr 	StackPushByte
.8a1a		c8		iny				iny
.8a1b		80 f6		bra $8a13			bra 	_LNTPushStrLoop
.8a1d						_LNTStringOut:
.8a1d		98		tya				tya									; output length (chars written).
.8a1e		20 f9 a6	jsr $a6f9			jsr 	StackPushByte
.8a21		b5 58		lda $58,x			lda 	NSMantissa0,x 				; output address of the string record *not* the string itself
.8a23		20 f9 a6	jsr $a6f9			jsr 	StackPushByte
.8a26		b5 60		lda $60,x			lda 	NSMantissa1,x
.8a28		20 f9 a6	jsr $a6f9			jsr 	StackPushByte
.8a2b		a9 02		lda #$02			lda 	#STK_LOCALS 				; push local-string marker.
.8a2d		20 f9 a6	jsr $a6f9			jsr 	StackPushByte
.8a30		7a		ply				ply
.8a31		60		rts				rts
.8a32						_LNTError:
.8a32		4c f6 9f	jmp $9ff6			jmp 	SyntaxError
.8a35						LocalPopValue:
.8a35		20 11 a7	jsr $a711			jsr 	StackPopByte
.8a38		c9 01		cmp #$01			cmp 	#STK_LOCALN 				; if not local-N
.8a3a		d0 17		bne $8a53			bne 	_LPVString
.8a3c		20 11 a7	jsr $a711			jsr 	StackPopByte 				; address
.8a3f		85 37		sta $37				sta 	zTemp0+1
.8a41		20 11 a7	jsr $a711			jsr 	StackPopByte
.8a44		85 36		sta $36				sta 	zTemp0
.8a46		5a		phy				phy
.8a47		a0 04		ldy #$04			ldy 	#4 							; copy back
.8a49						_LPVNumberCopy:
.8a49		20 11 a7	jsr $a711			jsr 	StackPopByte
.8a4c		91 36		sta ($36),y			sta 	(zTemp0),y
.8a4e		88		dey				dey
.8a4f		10 f8		bpl $8a49			bpl 	_LPVNumberCopy
.8a51		7a		ply				ply 								; and complete
.8a52		60		rts				rts
.8a53						_LPVString:
.8a53		20 11 a7	jsr $a711			jsr 	StackPopByte 				; address of record copied to zTemp0
.8a56		85 37		sta $37				sta 	zTemp0+1
.8a58		20 11 a7	jsr $a711			jsr 	StackPopByte
.8a5b		85 36		sta $36				sta 	zTemp0
.8a5d		5a		phy				phy
.8a5e		b2 36		lda ($36)			lda 	(zTemp0) 					; address to write string to copied to zTemp1
.8a60		85 38		sta $38				sta 	zTemp1
.8a62		a0 01		ldy #$01			ldy 	#1
.8a64		b1 36		lda ($36),y			lda 	(zTemp0),y
.8a66		85 39		sta $39				sta 	zTemp1+1
.8a68		20 11 a7	jsr $a711			jsr 	StackPopByte 				; # chars to get => y
.8a6b		a8		tay				tay
.8a6c		a5 39		lda $39				lda 	zTemp1+1 					; if no target (e.g. was "" originally) exit
.8a6e		f0 0e		beq $8a7e			beq 	_LPVStringCopied
.8a70		a9 00		lda #$00			lda 	#0 							; NULL on end
.8a72		91 38		sta ($38),y			sta 	(zTemp1),y
.8a74						_LPVStringCopy:
.8a74		88		dey				dey
.8a75		30 07		bmi $8a7e			bmi 	_LPVStringCopied
.8a77		20 11 a7	jsr $a711			jsr 	StackPopByte
.8a7a		91 38		sta ($38),y			sta 	(zTemp1),y
.8a7c		80 f6		bra $8a74			bra 	_LPVStringCopy
.8a7e						_LPVStringCopied:
.8a7e		fa		plx				plx
.8a7f		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/new.asm

.8a80						NewCommand:
.8a80		20 86 8a	jsr $8a86			jsr 	NewProgram 					; does the actual NEW.
.8a83		4c 2f 84	jmp $842f			jmp 	WarmStart 					; and warm starts straight away.
.8a86						NewProgram:
.8a86		20 d6 a5	jsr $a5d6			jsr 	MemoryNew
.8a89		9c 00 10	stz $1000			stz 	VariableSpace 				; erase all variables.
.8a8c		20 c5 84	jsr $84c5			jsr 	ClearCommand 				; clear everything.
.8a8f		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/procedure.asm

=2						ParameterStackPos = 2
.8a90						CallProcedure:
.8a90		a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start storing parameters at 2.
.8a92		b1 30		lda ($30),y			lda 	(codePtr),y
.8a94		c9 29		cmp #$29			cmp 	#KWD_RPAREN
.8a96		f0 0c		beq $8aa4			beq 	_CPEndParam
.8a98						_CPParamLoop:
.8a98		20 bd 9d	jsr $9dbd			jsr 	EvaluateValue 				; get parameter onto stack
.8a9b		e8		inx				inx 								; bump next stack
.8a9c		b1 30		lda ($30),y			lda 	(codePtr),y
.8a9e		c8		iny				iny
.8a9f		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if comma, go back and try again.
.8aa1		f0 f5		beq $8a98			beq 	_CPParamLoop
.8aa3		88		dey				dey 								; unpick.
.8aa4						_CPEndParam:
.8aa4		8e 16 04	stx $0416			stx 	LastParameter 				; save the last parameters index.
.8aa7		c8		iny				iny									; skip right bracket
.8aa8		a9 b3		lda #$b3			lda 	#STK_PROC+3 				; allocate 6 bytes on the return stack.
.8aaa		20 1a a7	jsr $a71a			jsr 	StackOpen
.8aad		20 5f a7	jsr $a75f			jsr 	STKSaveCodePosition 		; save loop position
.8ab0		a5 58		lda $58				lda 	NSMantissa0 				; copy variable (e.g. procedure) address to zTemp0
.8ab2		85 36		sta $36				sta 	zTemp0 						; this is the DATA not the RECORD
.8ab4		a5 60		lda $60				lda 	NSMantissa1
.8ab6		85 37		sta $37				sta 	zTemp0+1
.8ab8		a0 01		ldy #$01			ldy 	#1 							; copy code address back.
.8aba		b2 36		lda ($36)			lda 	(zTemp0)
.8abc		85 30		sta $30				sta 	safePtr
.8abe		b1 36		lda ($36),y			lda 	(zTemp0),y
.8ac0		85 31		sta $31				sta 	safePtr+1
.8ac2		c8		iny				iny
.8ac3		b1 36		lda ($36),y			lda 	(zTemp0),y
.8ac5		85 32		sta $32				sta 	safePtr+2
.8ac7		c8		iny				iny
.8ac8		b1 36		lda ($36),y			lda 	(zTemp0),y
.8aca		85 33		sta $33				sta 	safePtr+3
.8acc		c8		iny				iny 								; get Y offset -> Y
.8acd		b1 36		lda ($36),y			lda 	(zTemp0),y
.8acf		a8		tay				tay
.8ad0		a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start position of parameters
.8ad2		ec 16 04	cpx $0416			cpx	 	LastParameter 				; check zero parameters at the start
.8ad5		f0 13		beq $8aea			beq 	_ParamExit 					; if so, exit.
.8ad7						_ParamExtract:
.8ad7		ca		dex				dex 								; put a local term on the level before
.8ad8		20 cd 89	jsr $89cd			jsr 	LocaliseNextTerm			; also pushes original param value to basic stack
.8adb		20 a7 88	jsr $88a7			jsr 	AssignVariable 				; assign stacked value to the variable.
.8ade		e8		inx				inx 								; advance to next parameter to do.
.8adf		e8		inx				inx
.8ae0		ec 16 04	cpx $0416			cpx 	LastParameter 				; are we done ?
.8ae3		f0 05		beq $8aea			beq 	_ParamExit
.8ae5		20 40 8f	jsr $8f40			jsr 	CheckComma 					; comma seperating parameters
.8ae8		80 ed		bra $8ad7			bra 	_ParamExtract
.8aea						_ParamExit:
.8aea		20 38 8f	jsr $8f38			jsr 	CheckRightBracket 			; check )
.8aed		60		rts				rts 								; and continue from here
.8aee						Command_ENDPROC:
.8aee		a9 b0		lda #$b0			lda 	#STK_PROC 					; check TOS is this
.8af0		a2 14		ldx #$14			ldx 	#ERRID_PROC
.8af2		20 47 a7	jsr $a747			jsr 	StackCheckFrame
.8af5		20 70 a7	jsr $a770			jsr 	STKLoadCodePosition 		; restore code position
.8af8		20 39 a7	jsr $a739			jsr 	StackClose
.8afb		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/read.asm

.8afc						Command_Read:
.8afc		a2 00		ldx #$00			ldx 	#0 							; evaluate the term which is the var/array element to assign
.8afe		20 9f 98	jsr $989f			jsr 	EvaluateTerm
.8b01		b5 50		lda $50,x			lda 	NSStatus,x
.8b03		29 20		and #$20			and 	#NSBIsReference				; get status byte on stack, identifies int, float, string.
.8b05		f0 4f		beq $8b56			beq 	_CRSyntax 					; check reference (bit 0) fail if not a reference.
.8b07		20 9f 8b	jsr $8b9f			jsr 	SwapDataCodePtrs 			; swap code and data
.8b0a		ad 1c 04	lda $041c			lda 	inDataStatement 			; if in a data statement, we don't need to search
.8b0d		d0 25		bne $8b34			bne 	_CRContinueData  			; forward for the next one.
.8b0f		b2 30		lda ($30)			lda 	(codePtr)
.8b11		f0 1c		beq $8b2f			beq 	_CRNoData
.8b13						_CRKeepSearching:
.8b13		a9 b4		lda #$b4			lda 	#KWD_DATA 					; scan for instruction
.8b15		a2 80		ldx #$80			ldx 	#KWC_EOL
.8b17		20 93 8e	jsr $8e93			jsr 	ScanForward
.8b1a		c9 b4		cmp #$b4			cmp 	#KWD_DATA 					; found data ?
.8b1c		f0 16		beq $8b34			beq 	_CRHaveData 				; found it
.8b1e		18		clc				clc
.8b1f		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8b21		65 30		adc $30				adc 	codePtr
.8b23		85 30		sta $30				sta 	codePtr
.8b25		90 02		bcc $8b29			bcc 	_CREExit
.8b27		e6 31		inc $31				inc 	codePtr+1 					; carry
.8b29						_CREExit:
.8b29		a0 03		ldy #$03			ldy 	#3 							; start of line.
.8b2b		b2 30		lda ($30)			lda 	(codePtr)
.8b2d		d0 e4		bne $8b13			bne 	_CRKeepSearching
.8b2f						_CRNoData:
.8b2f		a9 0b		lda #$0b		lda	#11
.8b31		4c 51 8f	jmp $8f51		jmp	ErrorHandler
.8b34						_CRHaveData:
.8b34						_CRContinueData:
.8b34		a2 01		ldx #$01			ldx 	#1
.8b36		20 bd 9d	jsr $9dbd			jsr 	EvaluateValue 				; evaluate value into slot # 1
.8b39		ca		dex				dex
.8b3a		20 a7 88	jsr $88a7			jsr		AssignVariable 				; do the assignment
.8b3d		9c 1c 04	stz $041c			stz 	inDataStatement 			; clear in data flag
.8b40		b1 30		lda ($30),y			lda 	(codePtr),y
.8b42		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not, end of data statement and exit
.8b44		d0 04		bne $8b4a			bne 	_CRSwapBack
.8b46		c8		iny				iny 								; consume comma
.8b47		ee 1c 04	inc $041c			inc 	inDataStatement 			; set in data statement currently.
.8b4a						_CRSwapBack:
.8b4a		20 9f 8b	jsr $8b9f			jsr 	SwapDataCodePtrs			; swap them back.
.8b4d		b1 30		lda ($30),y			lda 	(codePtr),y
.8b4f		c8		iny				iny
.8b50		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8b52		f0 a8		beq $8afc			beq 	Command_Read 				; if so go round again.
.8b54		88		dey				dey 								; unpick get.
.8b55		60		rts				rts
.8b56						_CRSyntax:
.8b56		4c f6 9f	jmp $9ff6			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/rem.asm

.8b59						RemCommand:
.8b59		b1 30		lda ($30),y			lda 	(codePtr),y
.8b5b		c9 ff		cmp #$ff			cmp 	#KWC_STRING
.8b5d		d0 06		bne $8b65			bne 	_RMExit
.8b5f		c8		iny				iny 								; point to offset
.8b60		98		tya				tya 								; A = offset position
.8b61		38		sec				sec 								; add size +1 hence SEC
.8b62		71 30		adc ($30),y			adc 	(codePtr),y
.8b64		a8		tay				tay 								; make current position.
.8b65						_RMExit:
.8b65		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/repeat.asm

.8b66						Command_REPEAT:
.8b66		a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; allocate 6 bytes on the return stack.
.8b68		20 1a a7	jsr $a71a			jsr 	StackOpen
.8b6b		20 5f a7	jsr $a75f			jsr 	STKSaveCodePosition 		; save loop position
.8b6e		60		rts				rts
.8b6f						Command_UNTIL:
.8b6f		a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; check REPEAT is TOS
.8b71		a2 0f		ldx #$0f			ldx 	#ERRID_REPEAT 				; this error
.8b73		20 47 a7	jsr $a747			jsr 	StackCheckFrame
.8b76		a2 00		ldx #$00			ldx 	#0
.8b78		20 c6 9d	jsr $9dc6			jsr 	EvaluateNumber 				; work out the number
.8b7b		20 9a 9e	jsr $9e9a			jsr 	NSMIsZero 					; check if zero
.8b7e		f0 04		beq $8b84			beq 	_CULoopBack 				; if so keep looping
.8b80		20 39 a7	jsr $a739			jsr 	StackClose		 			; return
.8b83		60		rts				rts
.8b84						_CULoopBack:
.8b84		20 70 a7	jsr $a770			jsr 	STKLoadCodePosition 		; loop back
.8b87		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/restore.asm

.8b88						Command_Restore:
.8b88		20 9f 8b	jsr $8b9f			jsr 	SwapDataCodePtrs 			; swap code and data
.8b8b		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8b8d		85 30		sta $30				sta 	codePtr
.8b8f		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8b91		85 31		sta $31				sta 	codePtr+1
.8b93		20 9f 8b	jsr $8b9f			jsr 	SwapDataCodePtrs 			; put them back
.8b96		a9 03		lda #$03			lda 	#3 							; start at offset 3, e.g. first instruction of first line.
.8b98		8d 1b 04	sta $041b			sta 	dataPointer+4   			; (read checks not EOF)
.8b9b		9c 1c 04	stz $041c			stz 	inDataStatement 			; not in data statement
.8b9e		60		rts				rts
.8b9f						SwapDataCodePtrs:
.8b9f		da		phx				phx
.8ba0		a2 03		ldx #$03			ldx 	#3 							; swap 32 bit code pointer over
.8ba2						_SDCPLoop:
.8ba2		b5 30		lda $30,x			lda 	safePtr,x
.8ba4		48		pha				pha
.8ba5		bd 17 04	lda $0417,x			lda 	dataPointer,x
.8ba8		95 30		sta $30,x			sta 	safePtr,x
.8baa		68		pla				pla
.8bab		9d 17 04	sta $0417,x			sta 	dataPointer,x
.8bae		ca		dex				dex
.8baf		10 f1		bpl $8ba2			bpl 	_SDCPLoop
.8bb1		ad 1b 04	lda $041b			lda 	dataPointer+4 				; swap Y position over.
.8bb4		8c 1b 04	sty $041b			sty 	dataPointer+4
.8bb7		a8		tay				tay
.8bb8		fa		plx				plx
.8bb9		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/run.asm

.8bba						EOLCommand:
.8bba		18		clc				clc
.8bbb		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8bbd		65 30		adc $30				adc 	codePtr
.8bbf		85 30		sta $30				sta 	codePtr
.8bc1		90 02		bcc $8bc5			bcc 	_CREExit
.8bc3		e6 31		inc $31				inc 	codePtr+1 					; carry
.8bc5						_CREExit:
.8bc5		80 0b		bra $8bd2			bra 	RunNewLine
.8bc7						CommandRUN:
.8bc7		20 c5 84	jsr $84c5			jsr 	ClearCommand 				; clear variable/stacks/etc.
.8bca		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8bcc		85 30		sta $30				sta 	codePtr
.8bce		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8bd0		85 31		sta $31				sta 	codePtr+1
.8bd2						RUNNewLine:
.8bd2		b2 30		lda ($30)			lda 	(codePtr)
.8bd4		f0 7b		beq $8c51			beq 	CRNoProgram         		; no then END.
.8bd6		a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack
.8bd8		9a		txs				txs
.8bd9						RUNCodePointerLine:
.8bd9		a0 02		ldy #$02			ldy 	#2 							; start of program
.8bdb						_CRIncMainLoop:
.8bdb		0e 13 04	asl $0413			asl 	breakCheck 					; clears 1 time in 8
.8bde		d0 22		bne $8c02			bne 	_CRNoBreakCheck
.8be0		ce 13 04	dec $0413			dec	 	breakCheck 					; set it back to $FF
.8be3		20 21 80	jsr $8021			jsr 	EXTBreakCheck 				; break check
.8be6		f0 64		beq $8c4c			beq 	_CRBreak
.8be8		a5 01		lda $01				lda 	1 							; save I/O 0
.8bea		48		pha				pha
.8beb		64 01		stz $01				stz 	1 							; access I/O Page 0
.8bed		38		sec				sec 								; calculate timer - LastTick
.8bee		ad 59 d6	lda $d659			lda 	$D659
.8bf1		aa		tax				tax 								; saving timer in X
.8bf2		ed 5c 06	sbc $065c			sbc 	LastTick
.8bf5		c9 03		cmp #$03			cmp 	#3
.8bf7		90 06		bcc $8bff			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.8bf9		8e 5c 06	stx $065c			stx 	LastTick 					; update last timer
.8bfc		20 a3 9e	jsr $9ea3			jsr 	TickHandler 							; go do the code.
.8bff						_NoFireTick:
.8bff		68		pla				pla 								; restore I/O 0
.8c00		85 01		sta $01				sta 	1
.8c02						_CRNoBreakCheck:
.8c02		c8		iny				iny									; next token
.8c03						_CRMainLoop:
.8c03		9c 10 04	stz $0410			stz 	stringInitialised 			; clear the temporary string initialised flag.
.8c06		b1 30		lda ($30),y			lda 	(codePtr),y
.8c08		10 10		bpl $8c1a			bpl 	_CRNotKeyword				; not a token.
.8c0a		c9 a2		cmp #$a2			cmp 	#KWC_LAST_UNARY+1 			; if after unary, legitimate command
.8c0c		b0 04		bcs $8c12			bcs 	_CRIsKeyword
.8c0e		c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if unary, syntax error.
.8c10		b0 34		bcs $8c46			bcs		_CRSyntaxError
.8c12						_CRIsKeyword:
.8c12		c8		iny				iny 								; consume command
.8c13		0a		asl a				asl 	a 							; double losing the MSB which is '1' as tokens are $80-$FF
.8c14		aa		tax				tax 								; put in X for vector jump
.8c15		20 49 8c	jsr $8c49			jsr 	_CRCallVector0 				; call the vector - effectively jsr (vectortable,X)
.8c18		80 e9		bra $8c03			bra 	_CRMainLoop 				; and loop round
.8c1a						_CRNotKeyword:
.8c1a		c9 3a		cmp #$3a			cmp 	#KWD_COLON 					; if a :, consume it and go round.
.8c1c		f0 bd		beq $8bdb			beq 	_CRIncMainLoop
.8c1e		c9 40		cmp #$40			cmp 	#$40 						; variable/call reference
.8c20		90 05		bcc $8c27			bcc 	_CRNotVariable
.8c22						_CRGoLet:
.8c22		20 6e 88	jsr $886e			jsr 	LetCommand
.8c25		80 dc		bra $8c03			bra 	_CRMainLoop
.8c27						_CRNotVariable:
.8c27		c9 10		cmp #$10			cmp 	#KWD_AT 					; handle @
.8c29		f0 f7		beq $8c22			beq 	_CRGoLet
.8c2b		c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; handle ? !
.8c2d		f0 f3		beq $8c22			beq 	_CRGoLet
.8c2f		c9 21		cmp #$21			cmp 	#KWD_PLING
.8c31		f0 ef		beq $8c22			beq 	_CRGoLet
.8c33		c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; handle ' (comment)
.8c35		f0 09		beq $8c40			beq 	_CRGoRem
.8c37		c9 2e		cmp #$2e			cmp 	#KWD_PERIOD 				; handle . (assembler label)
.8c39		d0 0b		bne $8c46			bne 	_CRSyntaxError
.8c3b		20 a1 82	jsr $82a1			jsr 	LabelHere
.8c3e		80 c3		bra $8c03			bra 	_CRMainLoop
.8c40						_CRGoRem:
.8c40		c8		iny				iny
.8c41		20 59 8b	jsr $8b59			jsr 	RemCommand
.8c44		80 bd		bra $8c03			bra 	_CRMainLoop
.8c46						_CRSyntaxError:
.8c46		4c f6 9f	jmp $9ff6			jmp 	SyntaxError
.8c49						_CRCallVector0:
.8c49		7c e8 8c	jmp ($8ce8,x)			jmp 	(VectorSet0,x)
.8c4c						_CRBreak:
.8c4c		a9 01		lda #$01		lda	#1
.8c4e		4c 51 8f	jmp $8f51		jmp	ErrorHandler
.8c51						CRNoProgram:
.8c51		4c 13 86	jmp $8613			jmp 	EndCommand
.8c54						Shift1Command:
.8c54		b1 30		lda ($30),y			lda 	(codePtr),y
.8c56		c8		iny				iny
.8c57		0a		asl a				asl 	a
.8c58		aa		tax				tax
.8c59		7c 8e 8d	jmp ($8d8e,x)			jmp 	(VectorSet1,x)
.8c5c						Shift2Command:
.8c5c		b1 30		lda ($30),y			lda 	(codePtr),y
.8c5e		c8		iny				iny
.8c5f		0a		asl a				asl 	a
.8c60		aa		tax				tax
.8c61		7c b4 8d	jmp ($8db4,x)			jmp 	(VectorSet2,x)
.8c64						Unused1:
.8c64						Unused2:
.8c64						Unused3:
.8c64						Unused4:
.8c64		4c f6 9f	jmp $9ff6			jmp 	SyntaxError
>8c67								.align 2

;******  Processing file: ./common/commands/../generated/vectors.dat

.8c68						VectorSetPunc:
>8c68		09 92					.word	ShiftLeft                        ; $00 <<
>8c6a		f4 8f					.word	BinaryCompareLessEqual           ; $01 <=
>8c6c		ea 8f					.word	BinaryCompareNotEqual            ; $02 <>
>8c6e		f6 9f					.word	SyntaxError                      ; $03 !!3
>8c70		f6 9f					.word	SyntaxError                      ; $04 ><
>8c72		fe 8f					.word	BinaryCompareGreaterEqual        ; $05 >=
>8c74		0c 92					.word	ShiftRight                       ; $06 >>
>8c76		f6 9f					.word	SyntaxError                      ; $07 !!7
>8c78		f6 9f					.word	SyntaxError                      ; $08 !!8
>8c7a		f6 9f					.word	SyntaxError                      ; $09 !!9
>8c7c		f6 9f					.word	SyntaxError                      ; $0a !!10
>8c7e		f6 9f					.word	SyntaxError                      ; $0b !!11
>8c80		f6 9f					.word	SyntaxError                      ; $0c !!12
>8c82		f6 9f					.word	SyntaxError                      ; $0d !!13
>8c84		f6 9f					.word	SyntaxError                      ; $0e !!14
>8c86		f6 9f					.word	SyntaxError                      ; $0f !!15
>8c88		f6 9f					.word	SyntaxError                      ; $10 @
>8c8a		f6 9f					.word	SyntaxError                      ; $11 !!17
>8c8c		f6 9f					.word	SyntaxError                      ; $12 !!18
>8c8e		f6 9f					.word	SyntaxError                      ; $13 [
>8c90		b5 90					.word	IntegerDivide                    ; $14 \
>8c92		f6 9f					.word	SyntaxError                      ; $15 ]
>8c94		47 93					.word	EorInteger                       ; $16 ^
>8c96		f6 9f					.word	SyntaxError                      ; $17 _
>8c98		f6 9f					.word	SyntaxError                      ; $18 `
>8c9a		f6 9f					.word	SyntaxError                      ; $19 !!25
>8c9c		f6 9f					.word	SyntaxError                      ; $1a !!26
>8c9e		f6 9f					.word	SyntaxError                      ; $1b {
>8ca0		12 93					.word	OraInteger                       ; $1c |
>8ca2		f6 9f					.word	SyntaxError                      ; $1d }
>8ca4		f6 9f					.word	SyntaxError                      ; $1e ~
>8ca6		f6 9f					.word	SyntaxError                      ; $1f [7m<7F>[m
>8ca8		f6 9f					.word	SyntaxError                      ; $20
>8caa		7c 93					.word	WordIndirect                     ; $21 !
>8cac		f6 9f					.word	SyntaxError                      ; $22 "
>8cae		f6 9f					.word	SyntaxError                      ; $23 #
>8cb0		f6 9f					.word	SyntaxError                      ; $24 $
>8cb2		f6 90					.word	IntegerModulus                   ; $25 %
>8cb4		dd 92					.word	AndInteger                       ; $26 &
>8cb6		f6 9f					.word	SyntaxError                      ; $27 '
>8cb8		f6 9f					.word	SyntaxError                      ; $28 (
>8cba		f6 9f					.word	SyntaxError                      ; $29 )
>8cbc		64 91					.word	MulInteger                       ; $2a *
>8cbe		7f 92					.word	AddInteger                       ; $2b +
>8cc0		f6 9f					.word	SyntaxError                      ; $2c ,
>8cc2		b8 92					.word	SubInteger                       ; $2d -
>8cc4		f6 9f					.word	SyntaxError                      ; $2e .
>8cc6		36 95					.word	FDivideCommand                   ; $2f /
>8cc8		f6 9f					.word	SyntaxError                      ; $30 0
>8cca		f6 9f					.word	SyntaxError                      ; $31 1
>8ccc		f6 9f					.word	SyntaxError                      ; $32 2
>8cce		f6 9f					.word	SyntaxError                      ; $33 3
>8cd0		f6 9f					.word	SyntaxError                      ; $34 4
>8cd2		f6 9f					.word	SyntaxError                      ; $35 5
>8cd4		f6 9f					.word	SyntaxError                      ; $36 6
>8cd6		f6 9f					.word	SyntaxError                      ; $37 7
>8cd8		f6 9f					.word	SyntaxError                      ; $38 8
>8cda		f6 9f					.word	SyntaxError                      ; $39 9
>8cdc		f6 9f					.word	SyntaxError                      ; $3a :
>8cde		f6 9f					.word	SyntaxError                      ; $3b ;
>8ce0		d6 8f					.word	BinaryCompareLess                ; $3c <
>8ce2		cc 8f					.word	BinaryCompareEqual               ; $3d =
>8ce4		e0 8f					.word	BinaryCompareGreater             ; $3e >
>8ce6		9e 93					.word	ByteIndirect                     ; $3f ?
.8ce8						VectorSet0:
>8ce8		ba 8b					.word	EOLCommand                       ; $80 !0:EOF
>8cea		54 8c					.word	Shift1Command                    ; $81 !1:SH1
>8cec		5c 8c					.word	Shift2Command                    ; $82 !2:SH2
>8cee		20 9a					.word	AbsUnary                         ; $83 ABS(
>8cf0		2e 9a					.word	AllocUnary                       ; $84 ALLOC(
>8cf2		9e 9a					.word	AscUnary                         ; $85 ASC(
>8cf4		5e 9c					.word	ChrUnary                         ; $86 CHR$(
>8cf6		ae 9a					.word	DeekUnary                        ; $87 DEEK(
>8cf8		56 a4					.word	UnaryEvent                       ; $88 EVENT(
>8cfa		c8 8f					.word	UnaryFalse                       ; $89 FALSE
>8cfc		c0 9a					.word	FracUnary                        ; $8a FRAC(
>8cfe		f2 a3					.word	UnaryHit                         ; $8b HIT(
>8d00		d5 9a					.word	IntUnary                         ; $8c INT(
>8d02		1d 9c					.word	IsValUnary                       ; $8d ISVAL(
>8d04		da a4					.word	UnaryJoyB                        ; $8e JOYB(
>8d06		b3 a4					.word	UnaryJoyX                        ; $8f JOYX(
>8d08		b6 a4					.word	UnaryJoyY                        ; $90 JOYY(
>8d0a		31 9d					.word	Unary_Left                       ; $91 LEFT$(
>8d0c		e6 9a					.word	LenUnary                         ; $92 LEN(
>8d0e		04 9b					.word	Unary_Max                        ; $93 MAX(
>8d10		53 9d					.word	Unary_Mid                        ; $94 MID$(
>8d12		00 9b					.word	Unary_Min                        ; $95 MIN(
>8d14		4f 9b					.word	Unary_Not                        ; $96 NOT(
>8d16		ab 9a					.word	PeekUnary                        ; $97 PEEK(
>8d18		77 a6					.word	UnaryPlaying                     ; $98 PLAYING(
>8d1a		62 9b					.word	Unary_Random                     ; $99 RANDOM(
>8d1c		3e 9d					.word	Unary_Right                      ; $9a RIGHT$(
>8d1e		7f 9b					.word	Unary_Rnd                        ; $9b RND(
>8d20		f5 9b					.word	SgnUnary                         ; $9c SGN(
>8d22		70 9c					.word	SpcUnary                         ; $9d SPC(
>8d24		8b 9c					.word	Unary_Str                        ; $9e STR$(
>8d26		00 a5					.word	UnaryTimer                       ; $9f TIMER(
>8d28		bd 8f					.word	UnaryTrue                        ; $a0 TRUE
>8d2a		13 9c					.word	ValUnary                         ; $a1 VAL(
>8d2c		16 86					.word	ForCommand                       ; $a2 FOR
>8d2e		59 87					.word	IfCommand                        ; $a3 IF
>8d30		64 8c					.word	Unused1                          ; $a4 PROC
>8d32		66 8b					.word	Command_REPEAT                   ; $a5 REPEAT
>8d34		09 8f					.word	Command_WHILE                    ; $a6 WHILE
>8d36		82 87					.word	EndIf                            ; $a7 ENDIF
>8d38		ee 8a					.word	Command_ENDPROC                  ; $a8 ENDPROC
>8d3a		c8 86					.word	NextCommand                      ; $a9 NEXT
>8d3c		64 8c					.word	Unused4                          ; $aa THEN
>8d3e		6f 8b					.word	Command_UNTIL                    ; $ab UNTIL
>8d40		2a 8f					.word	Command_WEND                     ; $ac WEND
>8d42		f6 9f					.word	SyntaxError                      ; $ad BY
>8d44		90 84					.word	CallCommand                      ; $ae CALL
>8d46		a6 a1					.word	CircleCommand                    ; $af CIRCLE
>8d48		c5 84					.word	ClearCommand                     ; $b0 CLEAR
>8d4a		1d 85					.word	ClearScreen                      ; $b1 CLS
>8d4c		f6 9f					.word	SyntaxError                      ; $b2 COLOR
>8d4e		f6 9f					.word	SyntaxError                      ; $b3 COLOUR
>8d50		25 85					.word	Command_Data                     ; $b4 DATA
>8d52		2d 85					.word	DimCommand                       ; $b5 DIM
>8d54		ed 85					.word	DokeCommand                      ; $b6 DOKE
>8d56		64 8c					.word	Unused3                          ; $b7 DOWNTO
>8d58		7b 87					.word	ElseCode                         ; $b8 ELSE
>8d5a		f6 9f					.word	SyntaxError                      ; $b9 FROM
>8d5c		c5 a3					.word	GfxCommand                       ; $ba GFX
>8d5e		21 87					.word	Command_GOSUB                    ; $bb GOSUB
>8d60		3f 87					.word	GotoCommand                      ; $bc GOTO
>8d62		f6 9f					.word	SyntaxError                      ; $bd HERE
>8d64		cf a1					.word	ImageCommand                     ; $be IMAGE
>8d66		83 87					.word	Command_Input                    ; $bf INPUT
>8d68		6e 88					.word	LetCommand                       ; $c0 LET
>8d6a		21 a2					.word	LineCommand                      ; $c1 LINE
>8d6c		bf 89					.word	Command_LOCAL                    ; $c2 LOCAL
>8d6e		f6 9f					.word	SyntaxError                      ; $c3 OFF
>8d70		f6 9f					.word	SyntaxError                      ; $c4 ON
>8d72		f6 9f					.word	SyntaxError                      ; $c5 OUTLINE
>8d74		16 a4					.word	PaletteCommand                   ; $c6 PALETTE
>8d76		1a a2					.word	PlotCommand                      ; $c7 PLOT
>8d78		ea 85					.word	PokeCommand                      ; $c8 POKE
>8d7a		8a 87					.word	Command_Print                    ; $c9 PRINT
>8d7c		fc 8a					.word	Command_Read                     ; $ca READ
>8d7e		a2 a1					.word	RectangleCommand                 ; $cb RECT
>8d80		59 8b					.word	RemCommand                       ; $cc REM
>8d82		31 87					.word	Command_RETURN                   ; $cd RETURN
>8d84		f6 9f					.word	SyntaxError                      ; $ce SOLID
>8d86		93 a6					.word	SoundCommand                     ; $cf SOUND
>8d88		b1 a1					.word	SpriteCommand                    ; $d0 SPRITE
>8d8a		eb a1					.word	TextCommand                      ; $d1 TEXT
>8d8c		64 8c					.word	Unused2                          ; $d2 TO
.8d8e						VectorSet1:
>8d8e		f6 9f					.word	SyntaxError                      ; $80 !0:EOF
>8d90		f6 9f					.word	SyntaxError                      ; $81 !1:SH1
>8d92		f6 9f					.word	SyntaxError                      ; $82 !2:SH2
>8d94		64 84					.word	AssembleCommand                  ; $83 ASSEMBLE
>8d96		80 84					.word	AssertCommand                    ; $84 ASSERT
>8d98		65 a3					.word	BitmapCtrl                       ; $85 BITMAP
>8d9a		13 86					.word	EndCommand                       ; $86 END
>8d9c		4b a6					.word	Explode                          ; $87 EXPLODE
>8d9e		f7 a4					.word	GoCommand                        ; $88 GO
>8da0		be 88					.word	Command_List                     ; $89 LIST
>8da2		ee a4					.word	LoadCommand                      ; $8a LOAD
>8da4		80 8a					.word	NewCommand                       ; $8b NEW
>8da6		27 a6					.word	PingCommand                      ; $8c PING
>8da8		88 8b					.word	Command_Restore                  ; $8d RESTORE
>8daa		c7 8b					.word	CommandRUN                       ; $8e RUN
>8dac		3f a6					.word	ShootCommand                     ; $8f SHOOT
>8dae		aa a3					.word	SpritesCtrl                      ; $90 SPRITES
>8db0		3c 8e					.word	StopCommand                      ; $91 STOP
>8db2		33 a6					.word	ZapCommand                       ; $92 ZAP
.8db4						VectorSet2:
>8db4		f6 9f					.word	SyntaxError                      ; $80 !0:EOF
>8db6		f6 9f					.word	SyntaxError                      ; $81 !1:SH1
>8db8		f6 9f					.word	SyntaxError                      ; $82 !2:SH2
>8dba		b5 9e					.word	Assemble_adc                     ; $83 ADC
>8dbc		ad 9e					.word	Assemble_and                     ; $84 AND
>8dbe		c9 9e					.word	Assemble_asl                     ; $85 ASL
>8dc0		33 9f					.word	Assemble_bcc                     ; $86 BCC
>8dc2		37 9f					.word	Assemble_bcs                     ; $87 BCS
>8dc4		3f 9f					.word	Assemble_beq                     ; $88 BEQ
>8dc6		f6 9e					.word	Assemble_bit                     ; $89 BIT
>8dc8		27 9f					.word	Assemble_bmi                     ; $8a BMI
>8dca		3b 9f					.word	Assemble_bne                     ; $8b BNE
>8dcc		23 9f					.word	Assemble_bpl                     ; $8c BPL
>8dce		43 9f					.word	Assemble_bra                     ; $8d BRA
>8dd0		47 9f					.word	Assemble_brk                     ; $8e BRK
>8dd2		2b 9f					.word	Assemble_bvc                     ; $8f BVC
>8dd4		2f 9f					.word	Assemble_bvs                     ; $90 BVS
>8dd6		4f 9f					.word	Assemble_clc                     ; $91 CLC
>8dd8		a3 9f					.word	Assemble_cld                     ; $92 CLD
>8dda		63 9f					.word	Assemble_cli                     ; $93 CLI
>8ddc		93 9f					.word	Assemble_clv                     ; $94 CLV
>8dde		c1 9e					.word	Assemble_cmp                     ; $95 CMP
>8de0		0a 9f					.word	Assemble_cpx                     ; $96 CPX
>8de2		05 9f					.word	Assemble_cpy                     ; $97 CPY
>8de4		e7 9e					.word	Assemble_dec                     ; $98 DEC
>8de6		9f 9f					.word	Assemble_dex                     ; $99 DEX
>8de8		7b 9f					.word	Assemble_dey                     ; $9a DEY
>8dea		b1 9e					.word	Assemble_eor                     ; $9b EOR
>8dec		ec 9e					.word	Assemble_inc                     ; $9c INC
>8dee		af 9f					.word	Assemble_inx                     ; $9d INX
>8df0		9b 9f					.word	Assemble_iny                     ; $9e INY
>8df2		1e 9f					.word	Assemble_jmp                     ; $9f JMP
>8df4		19 9f					.word	Assemble_jsr                     ; $a0 JSR
>8df6		bd 9e					.word	Assemble_lda                     ; $a1 LDA
>8df8		e2 9e					.word	Assemble_ldx                     ; $a2 LDX
>8dfa		00 9f					.word	Assemble_ldy                     ; $a3 LDY
>8dfc		d3 9e					.word	Assemble_lsr                     ; $a4 LSR
>8dfe		b3 9f					.word	Assemble_nop                     ; $a5 NOP
>8e00		a9 9e					.word	Assemble_ora                     ; $a6 ORA
>8e02		5f 9f					.word	Assemble_pha                     ; $a7 PHA
>8e04		4b 9f					.word	Assemble_php                     ; $a8 PHP
>8e06		a7 9f					.word	Assemble_phx                     ; $a9 PHX
>8e08		67 9f					.word	Assemble_phy                     ; $aa PHY
>8e0a		6f 9f					.word	Assemble_pla                     ; $ab PLA
>8e0c		53 9f					.word	Assemble_plp                     ; $ac PLP
>8e0e		bb 9f					.word	Assemble_plx                     ; $ad PLX
>8e10		77 9f					.word	Assemble_ply                     ; $ae PLY
>8e12		ce 9e					.word	Assemble_rol                     ; $af ROL
>8e14		d8 9e					.word	Assemble_ror                     ; $b0 ROR
>8e16		5b 9f					.word	Assemble_rti                     ; $b1 RTI
>8e18		6b 9f					.word	Assemble_rts                     ; $b2 RTS
>8e1a		c5 9e					.word	Assemble_sbc                     ; $b3 SBC
>8e1c		57 9f					.word	Assemble_sec                     ; $b4 SEC
>8e1e		b7 9f					.word	Assemble_sed                     ; $b5 SED
>8e20		73 9f					.word	Assemble_sei                     ; $b6 SEI
>8e22		b9 9e					.word	Assemble_sta                     ; $b7 STA
>8e24		ab 9f					.word	Assemble_stp                     ; $b8 STP
>8e26		dd 9e					.word	Assemble_stx                     ; $b9 STX
>8e28		fb 9e					.word	Assemble_sty                     ; $ba STY
>8e2a		f1 9e					.word	Assemble_stz                     ; $bb STZ
>8e2c		8f 9f					.word	Assemble_tax                     ; $bc TAX
>8e2e		8b 9f					.word	Assemble_tay                     ; $bd TAY
>8e30		14 9f					.word	Assemble_trb                     ; $be TRB
>8e32		0f 9f					.word	Assemble_tsb                     ; $bf TSB
>8e34		97 9f					.word	Assemble_tsx                     ; $c0 TSX
>8e36		7f 9f					.word	Assemble_txa                     ; $c1 TXA
>8e38		87 9f					.word	Assemble_txs                     ; $c2 TXS
>8e3a		83 9f					.word	Assemble_tya                     ; $c3 TYA

;******  Return to file: ./common/commands/run.asm


;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/stop.asm

.8e3c						StopCommand:
.8e3c		a9 08		lda #$08		lda	#8
.8e3e		4c 51 8f	jmp $8f51		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/procscan.asm

.8e41						ProcedureScan:
.8e41		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8e43		85 30		sta $30				sta 	codePtr
.8e45		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8e47		85 31		sta $31				sta 	codePtr+1
.8e49						_PSLoop:
.8e49		b2 30		lda ($30)			lda 	(codePtr)
.8e4b		f0 42		beq $8e8f			beq 	_PSExit
.8e4d		a0 03		ldy #$03			ldy 	#3 							; is it PROC at start of line ?
.8e4f		b1 30		lda ($30),y			lda 	(codePtr),y
.8e51		c9 a4		cmp #$a4			cmp 	#KWD_PROC
.8e53		d0 2d		bne $8e82			bne 	_PSNext
.8e55		c8		iny				iny 								; get the address of the record to zTemp0 and
.8e56		b1 30		lda ($30),y			lda 	(codePtr),y
.8e58		29 c0		and #$c0			and 	#$C0
.8e5a		c9 40		cmp #$40			cmp 	#$40
.8e5c		d0 32		bne $8e90			bne 	_PSSyntax
.8e5e		b1 30		lda ($30),y			lda 	(codePtr),y
.8e60		18		clc				clc
.8e61		69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8e63		85 37		sta $37				sta 	zTemp0+1
.8e65		c8		iny				iny 								; LSB
.8e66		b1 30		lda ($30),y			lda 	(codePtr),y
.8e68		85 36		sta $36				sta 	zTemp0
.8e6a		c8		iny				iny 								; character after variable call.
.8e6b		98		tya				tya 								; save Y offset at +7 (exponent slot)
.8e6c		a0 07		ldy #$07			ldy 	#7
.8e6e		91 36		sta ($36),y			sta 	(zTemp0),y
.8e70		a9 18		lda #$18			lda 	#NSTProcedure 				; mark it as procedure
.8e72		a0 02		ldy #$02			ldy 	#2
.8e74		91 36		sta ($36),y			sta 	(zTemp0),y
.8e76		a2 00		ldx #$00			ldx 	#0 							; copy code-Ptr into offset 3-6 (mantissa)
.8e78						_PSCopy:
.8e78		b5 30		lda $30,x			lda 	safePtr,x
.8e7a		c8		iny				iny
.8e7b		91 36		sta ($36),y			sta 	(zTemp0),y
.8e7d		e8		inx				inx
.8e7e		e0 04		cpx #$04			cpx 	#4
.8e80		d0 f6		bne $8e78			bne 	_PSCopy
.8e82						_PSNext:
.8e82		18		clc				clc
.8e83		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8e85		65 30		adc $30				adc 	codePtr
.8e87		85 30		sta $30				sta 	codePtr
.8e89		90 02		bcc $8e8d			bcc 	_CREExit
.8e8b		e6 31		inc $31				inc 	codePtr+1 					; carry
.8e8d						_CREExit:
.8e8d		80 ba		bra $8e49			bra 	_PSLoop
.8e8f						_PSExit:
.8e8f		60		rts				rts
.8e90						_PSSyntax:
.8e90		4c f6 9f	jmp $9ff6			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/scanforward.asm

.8e93						ScanForward:
.8e93		64 38		stz $38				stz 	zTemp1 						; zero the structure count - goes up with WHILE/FOR down with WEND/NEXT etc.
.8e95		86 37		stx $37				stx 	zTemp0+1
.8e97		85 36		sta $36				sta 	zTemp0 						; save X & A as the two possible matches.
.8e99						_ScanLoop:
.8e99		b1 30		lda ($30),y			lda 	(codePtr),y
.8e9b		c8		iny				iny
.8e9c		a6 38		ldx $38				ldx 	zTemp1 						; if the count is > 0 cannot match as in substructure
.8e9e		d0 0e		bne $8eae			bne 	_ScanGoNext
.8ea0		c5 36		cmp $36				cmp 	zTemp0 						; see if either matches
.8ea2		f0 04		beq $8ea8			beq 	_ScanMatch
.8ea4		c5 37		cmp $37				cmp 	zTemp0+1
.8ea6		d0 06		bne $8eae			bne 	_ScanGoNext
.8ea8						_ScanMatch:
.8ea8		c9 80		cmp #$80			cmp 	#KWC_EOL 					; if asked for EOL, backtrack.
.8eaa		d0 01		bne $8ead			bne 	_ScanNotEndEOL
.8eac		88		dey				dey
.8ead						_ScanNotEndEOL:
.8ead		60		rts				rts
.8eae						_ScanGoNext:
.8eae		20 b3 8e	jsr $8eb3			jsr  	ScanForwardOne 				; allows for shifts and so on.
.8eb1		80 e6		bra $8e99			bra 	_ScanLoop
.8eb3						ScanForwardOne:
.8eb3		c9 40		cmp #$40			cmp 	#$40 						; if 00-3F, punctuation characters, already done.
.8eb5		90 3e		bcc $8ef5			bcc 	_SFWExit
.8eb7		c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if 40-82, skip one extra as these are 2 byte
.8eb9		90 18		bcc $8ed3			bcc 	_ScanSkipOne	 			; offsets into the identifier table or shifts.
.8ebb		c9 fc		cmp #$fc			cmp 	#$FC 						; FC-FF are data skips (hex consts, strings etc.)
.8ebd		b0 2f		bcs $8eee			bcs 	_ScanSkipData
.8ebf		c9 a2		cmp #$a2			cmp 	#KWC_FIRST_STRUCTURE 		; structure keyword ?
.8ec1		90 32		bcc $8ef5			bcc 	_SFWExit 					; if not, ordinary keywords.
.8ec3		c9 ad		cmp #$ad			cmp 	#KWC_LAST_STRUCTURE+1
.8ec5		b0 2e		bcs $8ef5			bcs 	_SFWExit
.8ec7		c6 38		dec $38				dec 	zTemp1 						; decrement the sructure count
.8ec9		c9 a7		cmp #$a7			cmp 	#KWC_FIRST_STRUCTURE_DEC 	; back if it is a dec structure (e.g. WEND/NEXT)
.8ecb		b0 28		bcs $8ef5			bcs 	_SFWExit
.8ecd		e6 38		inc $38				inc 	zTemp1 						; so it's an increment structure
.8ecf		e6 38		inc $38				inc 	zTemp1 						; twice to undo the dec
.8ed1		80 22		bra $8ef5			bra 	_SFWExit
.8ed3						_ScanSkipOne:
.8ed3		c8		iny				iny 								; consume the extra one.
.8ed4		c9 80		cmp #$80			cmp 	#KWC_EOL 					; if not EOL loop back
.8ed6		d0 1d		bne $8ef5			bne 	_SFWExit
.8ed8		18		clc				clc
.8ed9		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8edb		65 30		adc $30				adc 	codePtr
.8edd		85 30		sta $30				sta 	codePtr
.8edf		90 02		bcc $8ee3			bcc 	_CREExit
.8ee1		e6 31		inc $31				inc 	codePtr+1 					; carry
.8ee3						_CREExit:
.8ee3		a0 03		ldy #$03			ldy 	#3 							; scan start position.
.8ee5		b2 30		lda ($30)			lda 	(codePtr)
.8ee7		d0 0c		bne $8ef5			bne 	_SFWExit 					; if not zero, more to scan
.8ee9		a9 13		lda #$13		lda	#19
.8eeb		4c 51 8f	jmp $8f51		jmp	ErrorHandler
.8eee						_ScanSkipData:
.8eee		88		dey				dey 								; point at data token
.8eef		c8		iny				iny 								; point to offset
.8ef0		98		tya				tya 								; A = offset position
.8ef1		38		sec				sec 								; add size +1 hence SEC
.8ef2		71 30		adc ($30),y			adc 	(codePtr),y
.8ef4		a8		tay				tay 								; make current position.
.8ef5						_SFWExit:
.8ef5		60		rts				rts
.8ef6						ScanGetCurrentLineStep:
.8ef6		64 38		stz $38				stz 	zTemp1
.8ef8		a0 03		ldy #$03			ldy 	#3
.8efa						_SGCLSLoop:
.8efa		b1 30		lda ($30),y			lda 	(codePtr),y
.8efc		c8		iny				iny
.8efd		c9 80		cmp #$80			cmp 	#KWC_EOL	 				; if EOL exit
.8eff		f0 05		beq $8f06			beq 	_SGCLSExit
.8f01		20 b3 8e	jsr $8eb3			jsr 	ScanForwardOne
.8f04		80 f4		bra $8efa			bra 	_SGCLSLoop
.8f06						_SGCLSExit:
.8f06		a5 38		lda $38				lda 	zTemp1 						; return the adjustment
.8f08		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/while.asm

.8f09						Command_WHILE:
.8f09		5a		phy				phy 								; save position of the test
.8f0a		a2 00		ldx #$00			ldx 	#0 							; work out the while test.
.8f0c		20 c6 9d	jsr $9dc6			jsr 	EvaluateNumber
.8f0f		20 9a 9e	jsr $9e9a			jsr 	NSMIsZero 					; check if zero
.8f12		f0 0e		beq $8f22			beq 	_WHExitLoop 				; if so exit the loop, while has failed.
.8f14		98		tya				tya 								; position *after* test.
.8f15		7a		ply				ply 								; restore position before test, at WHILE
.8f16		88		dey				dey 								; so we execute the WHILE command again.
.8f17		48		pha				pha 								; push after test on the stack
.8f18		a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; allocate 6 bytes on the return stack.
.8f1a		20 1a a7	jsr $a71a			jsr 	StackOpen
.8f1d		20 5f a7	jsr $a75f			jsr 	STKSaveCodePosition 		; save loop position - where the test value expr is.
.8f20		7a		ply				ply 								; restore the position *after* the test
.8f21		60		rts				rts
.8f22						_WHExitLoop:
.8f22		68		pla				pla 								; throw post loop position
.8f23		a9 ac		lda #$ac			lda 	#KWD_WEND 					; scan forward past WEND
.8f25		aa		tax				tax
.8f26		20 93 8e	jsr $8e93			jsr 	ScanForward
.8f29		60		rts				rts
.8f2a						Command_WEND:
.8f2a		a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; check WHILE is TOS e.g. in a while loop :)
.8f2c		a2 10		ldx #$10			ldx 	#ERRID_WHILE 				; this error if not.
.8f2e		20 47 a7	jsr $a747			jsr 	StackCheckFrame
.8f31		20 70 a7	jsr $a770			jsr 	STKLoadCodePosition 		; loop back to the WHILE keyword.
.8f34		20 39 a7	jsr $a739			jsr 	StackClose		 			; erase the frame
.8f37		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/charcheck.asm

.8f38						CheckRightBracket:
.8f38		b1 30		lda ($30),y			lda 	(codePtr),y
.8f3a		c8		iny				iny
.8f3b		c9 29		cmp #$29			cmp 	#KWD_RPAREN 						; exit if matches
.8f3d		d0 0f		bne $8f4e			bne 	CNAFail
.8f3f		60		rts				rts
.8f40						CheckComma:
.8f40		b1 30		lda ($30),y			lda 	(codePtr),y
.8f42		c8		iny				iny
.8f43		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 						; exit if matches
.8f45		d0 07		bne $8f4e			bne 	CNAFail
.8f47		60		rts				rts
.8f48						CheckNextA:
.8f48		d1 30		cmp ($30),y			cmp 	(codePtr),y
.8f4a		d0 02		bne $8f4e			bne 	CNAFail
.8f4c		c8		iny				iny 								; skip character
.8f4d		60		rts				rts 								; and exit
.8f4e						CNAFail:
.8f4e		4c f6 9f	jmp $9ff6			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/errors.asm

.8f51						ErrorHandler:
.8f51		a8		tay				tay 								; find the error text
.8f52		f0 49		beq $8f9d			beq 	_EHEnd
.8f54		a2 00		ldx #$00			ldx 	#0
.8f56		a9 0f		lda #$0f			lda 	#((ErrorText) & $FF)
.8f58		85 36		sta $36				sta 	0+zTemp0
.8f5a		a9 a0		lda #$a0			lda 	#((ErrorText) >> 8)
.8f5c		85 37		sta $37				sta 	1+zTemp0
.8f5e						_EHFind:
.8f5e		88		dey				dey 								; keep looking through text
.8f5f		f0 0e		beq $8f6f			beq 	_EHFound
.8f61						_EHFindZero:
.8f61		b2 36		lda ($36)			lda 	(zTemp0) 					; find the next error
.8f63		e6 36		inc $36				inc 	zTemp0
.8f65		d0 02		bne $8f69			bne 	_EHFNoCarry
.8f67		e6 37		inc $37				inc 	zTemp0+1
.8f69						_EHFNoCarry:
.8f69		c9 00		cmp #$00			cmp 	#0
.8f6b		d0 f4		bne $8f61			bne 	_EHFindZero
.8f6d		80 ef		bra $8f5e			bra 	_EHFind
.8f6f						_EHFound:
.8f6f		a5 36		lda $36				lda 	zTemp0 						; print message
.8f71		a6 37		ldx $37				ldx 	zTemp0+1
.8f73		20 aa 8f	jsr $8faa			jsr 	PrintStringXA
.8f76		a0 01		ldy #$01			ldy 	#1 							; if line number zero don't print it
.8f78		b1 30		lda ($30),y			lda 	(codePtr),y
.8f7a		d0 05		bne $8f81			bne 	_EHAtMsg
.8f7c		c8		iny				iny
.8f7d		b1 30		lda ($30),y			lda 	(codePtr),y
.8f7f		f0 17		beq $8f98			beq 	_EHCREnd
.8f81						_EHAtMsg:
.8f81		a2 8f		ldx #$8f			ldx 	#_AtMsg >> 8 				; print " at "
.8f83		a9 a0		lda #$a0			lda 	#_AtMsg & $FF
.8f85		20 aa 8f	jsr $8faa			jsr 	PrintStringXA
.8f88		a0 01		ldy #$01			ldy 	#1 							; line number into XA
.8f8a		b1 30		lda ($30),y			lda 	(codePtr),y
.8f8c		48		pha				pha
.8f8d		c8		iny				iny
.8f8e		b1 30		lda ($30),y			lda 	(codePtr),y
.8f90		aa		tax				tax
.8f91		68		pla				pla
.8f92		20 c0 93	jsr $93c0			jsr 	ConvertInt16 				; convert XA to string
.8f95		20 aa 8f	jsr $8faa			jsr 	PrintStringXA 				; and print it.
.8f98						_EHCREnd:
.8f98		a9 0d		lda #$0d			lda 	#13 						; new line
.8f9a		20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8f9d						_EHEnd:
.8f9d		4c 2f 84	jmp $842f			jmp 	WarmStart
>8fa0		20 61 74 20 6c 69 6e 65		_AtMsg:	.text 	" at line ",0
>8fa8		20 00
.8faa						PrintStringXA:
.8faa		5a		phy				phy
.8fab		86 37		stx $37				stx 	zTemp0+1
.8fad		85 36		sta $36				sta 	zTemp0
.8faf		a0 00		ldy #$00			ldy 	#0
.8fb1						_PSXALoop:
.8fb1		b1 36		lda ($36),y			lda 	(zTemp0),y
.8fb3		f0 06		beq $8fbb			beq 	_PSXAExit
.8fb5		20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8fb8		c8		iny				iny
.8fb9		80 f6		bra $8fb1			bra 	_PSXALoop
.8fbb						_PSXAExit:
.8fbb		7a		ply				ply
.8fbc		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/compare.asm

.8fbd						UnaryTrue:
.8fbd		fa		plx				plx
.8fbe						ReturnTrue:
.8fbe		a9 01		lda #$01			lda 	#1  						; set to 1
.8fc0		20 7a 9e	jsr $9e7a			jsr 	NSMSetByte
.8fc3		a9 80		lda #$80			lda 	#$80 						; set sign flag, so it is -1
.8fc5		95 50		sta $50,x			sta 	NSStatus,x
.8fc7		60		rts				rts
.8fc8						UnaryFalse:
.8fc8		fa		plx				plx
.8fc9						ReturnFalse:
.8fc9		4c 78 9e	jmp $9e78			jmp 	NSMSetZero 					; set it all to zero
.8fcc						BinaryCompareEqual:
.8fcc		fa		plx				plx
.8fcd		20 08 90	jsr $9008			jsr 	CompareBaseCode
.8fd0		c9 00		cmp #$00			cmp 	#0
.8fd2		f0 ea		beq $8fbe			beq 	ReturnTrue
.8fd4		80 f3		bra $8fc9			bra 	ReturnFalse
.8fd6						BinaryCompareLess:
.8fd6		fa		plx				plx
.8fd7		20 08 90	jsr $9008			jsr 	CompareBaseCode
.8fda		c9 ff		cmp #$ff			cmp 	#$FF
.8fdc		f0 e0		beq $8fbe			beq 	ReturnTrue
.8fde		80 e9		bra $8fc9			bra 	ReturnFalse
.8fe0						BinaryCompareGreater:
.8fe0		fa		plx				plx
.8fe1		20 08 90	jsr $9008			jsr 	CompareBaseCode
.8fe4		c9 01		cmp #$01			cmp 	#1
.8fe6		f0 d6		beq $8fbe			beq 	ReturnTrue
.8fe8		80 df		bra $8fc9			bra 	ReturnFalse
.8fea						BinaryCompareNotEqual:
.8fea		fa		plx				plx
.8feb		20 08 90	jsr $9008			jsr 	CompareBaseCode
.8fee		c9 00		cmp #$00			cmp 	#0
.8ff0		d0 cc		bne $8fbe			bne 	ReturnTrue
.8ff2		80 d5		bra $8fc9			bra 	ReturnFalse
.8ff4						BinaryCompareLessEqual:
.8ff4		fa		plx				plx
.8ff5		20 08 90	jsr $9008			jsr 	CompareBaseCode
.8ff8		c9 01		cmp #$01			cmp 	#1
.8ffa		d0 c2		bne $8fbe			bne 	ReturnTrue
.8ffc		80 cb		bra $8fc9			bra 	ReturnFalse
.8ffe						BinaryCompareGreaterEqual:
.8ffe		fa		plx				plx
.8fff		20 08 90	jsr $9008			jsr 	CompareBaseCode
.9002		c9 ff		cmp #$ff			cmp 	#$FF
.9004		d0 b8		bne $8fbe			bne 	ReturnTrue
.9006		80 c1		bra $8fc9			bra 	ReturnFalse
.9008						CompareBaseCode:
.9008		20 13 97	jsr $9713			jsr 	DereferenceTopTwo 			; make both values if references.
.900b		b5 50		lda $50,x			lda 	NSStatus,x 					; check if either is a string.
.900d		15 51		ora $51,x			ora 	NSStatus+1,x
.900f		29 10		and #$10			and 	#NSTString
.9011		d0 37		bne $904a			bne 	_CBCString 					; if so do string code, which will check if both.
.9013		b5 78		lda $78,x			lda 	NSExponent,x 				; check both are integers
.9015		15 79		ora $79,x			ora 	NSExponent+1,x
.9017		d0 34		bne $904d			bne 	_CBCFloat
.9019		b5 50		lda $50,x			lda 	NSStatus,x
.901b		15 51		ora $51,x			ora 	NSStatus+1,x
.901d		29 08		and #$08			and 	#NSTFloat
.901f		d0 2c		bne $904d			bne 	_CBCFloat
.9021		20 50 90	jsr $9050			jsr 	CompareFixMinusZero 		; fix up -0 just in cases.
.9024		e8		inx				inx
.9025		20 50 90	jsr $9050			jsr 	CompareFixMinusZero
.9028		ca		dex				dex
.9029		b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs different ?
.902b		55 51		eor $51,x			eor 	NSStatus+1,x
.902d		10 0a		bpl $9039			bpl 	_CDCSameSign
.902f		b5 50		lda $50,x			lda 	NSStatus,x 					; if first one is -ve
.9031		30 14		bmi $9047			bmi 	_CBCLess 					; return $FF
.9033						_CBCGreater:
.9033		a9 01		lda #$01			lda 	#1
.9035		60		rts				rts
.9036						_CBCEqual:
.9036		a9 00		lda #$00			lda 	#0
.9038		60		rts				rts
.9039						_CDCSameSign:
.9039		20 65 92	jsr $9265			jsr 	SubTopTwoStack 				; unsigned subtract
.903c		20 9a 9e	jsr $9e9a			jsr 	NSMIsZero 					; or the mantissa together
.903f		f0 f5		beq $9036			beq 	_CBCEqual 					; -0 == 0
.9041		b5 70		lda $70,x			lda 	NSMantissa3,x 				; sign of the result. if +ve return $01 else return $FF
.9043		55 51		eor $51,x			eor 	NSStatus+1,x 				; however if both were -ve this is inverted
.9045		10 ec		bpl $9033			bpl 	_CBCGreater
.9047						_CBCLess:
.9047		a9 ff		lda #$ff			lda 	#$FF
.9049		60		rts				rts
.904a						_CBCString:
.904a		4c d6 91	jmp $91d6			jmp 	CompareStrings
.904d						_CBCFloat:
.904d		4c 20 95	jmp $9520			jmp 	CompareFloat
.9050						CompareFixMinusZero:
.9050		20 9a 9e	jsr $9e9a			jsr 	NSMIsZero
.9053		d0 02		bne $9057			bne 	_CFXMZNotZero
.9055		74 50		stz $50,x			stz 	NSStatus,x
.9057						_CFXMZNotZero:
.9057		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/concat.asm

.9058						StringConcat:
.9058		b5 50		lda $50,x			lda 	NSStatus,x 					; check both strings
.905a		35 51		and $51,x			and 	NSStatus+1,x
.905c		29 18		and #$18			and 	#NSBTypeMask
.905e		c9 10		cmp #$10			cmp 	#NSTString
.9060		d0 50		bne $90b2			bne		_SCType
.9062		64 38		stz $38				stz 	zTemp1 						; counting total length
.9064		e8		inx				inx
.9065		20 83 90	jsr $9083			jsr 	_SCSetupZ0 					; setup for second
.9068		20 8c 90	jsr $908c			jsr 	_SCLengthZ0 				; length for second
.906b		ca		dex				dex
.906c		20 83 90	jsr $9083			jsr 	_SCSetupZ0 					; setup for first
.906f		20 8c 90	jsr $908c			jsr 	_SCLengthZ0 				; length for first
.9072		a5 38		lda $38				lda 	zTemp1 						; allocate memory using total.
.9074		20 0a a8	jsr $a80a			jsr 	StringTempAllocate
.9077		20 a3 90	jsr $90a3			jsr 	_SCCopy 					; copy first out, using zTemp0 from above
.907a		e8		inx				inx
.907b		20 83 90	jsr $9083			jsr 	_SCSetupZ0 					; copy second out
.907e		20 a3 90	jsr $90a3			jsr 	_SCCopy
.9081		ca		dex				dex
.9082		60		rts				rts
.9083						_SCSetupZ0:
.9083		b5 58		lda $58,x			lda 	NSMantissa0,x
.9085		85 36		sta $36				sta 	zTemp0
.9087		b5 60		lda $60,x			lda 	NSMantissa1,x
.9089		85 37		sta $37				sta 	zTemp0+1
.908b		60		rts				rts
.908c						_SCLengthZ0:
.908c		5a		phy				phy
.908d		a0 00		ldy #$00			ldy 	#0
.908f						_SCLenLoop:
.908f		b1 36		lda ($36),y			lda 	(zTemp0),y
.9091		f0 0e		beq $90a1			beq 	_SCLExit
.9093		c8		iny				iny
.9094		e6 38		inc $38				inc 	zTemp1
.9096		a5 38		lda $38				lda	 	zTemp1 						; check string too long.
.9098		c9 fd		cmp #$fd			cmp 	#253
.909a		d0 f3		bne $908f			bne		_SCLenLoop
.909c		a9 09		lda #$09		lda	#9
.909e		4c 51 8f	jmp $8f51		jmp	ErrorHandler
.90a1						_SCLExit:
.90a1		7a		ply				ply
.90a2		60		rts				rts
.90a3						_SCCopy:
.90a3		5a		phy				phy
.90a4		a0 00		ldy #$00			ldy 	#0
.90a6						_SCCopyLoop:
.90a6		b1 36		lda ($36),y			lda 	(zTemp0),y
.90a8		f0 06		beq $90b0			beq 	_SCCExit
.90aa		20 43 a8	jsr $a843			jsr 	StringTempWrite
.90ad		c8		iny				iny
.90ae		80 f6		bra $90a6			bra 	_SCCopyLoop
.90b0						_SCCExit:
.90b0		7a		ply				ply
.90b1		60		rts				rts
.90b2						_SCType:
.90b2		4c 00 a0	jmp $a000			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/divide.asm

.90b5						IntegerDivide:
.90b5		fa		plx				plx
.90b6		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.90b8		15 51		ora $51,x			ora 	NSStatus+1,x
.90ba		0a		asl a				asl 	a 							; shift reference bit into sign bit
.90bb		0a		asl a				asl 	a
.90bc		10 05		bpl $90c3			bpl 	_NotRef
.90be		48		pha				pha
.90bf		20 13 97	jsr $9713			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.90c2		68		pla				pla
.90c3						_NotRef:
.90c3		0a		asl a				asl 	a
.90c4		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.90c6		15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.90c8		15 79		ora $79,x			ora 	NSExponent+1,x
.90ca		f0 03		beq $90cf			beq 	_IntegerCode 				; if clear, then we have two integers
.90cc		4c 00 a0	jmp $a000			jmp 	TypeError 					; anything else, type mismatch.
.90cf						_IntegerCode:
.90cf		20 e9 90	jsr $90e9			jsr 	CheckDivideZero 			; do div zero check
.90d2		20 1b 91	jsr $911b			jsr 	Int32Divide 				; do the division
.90d5		20 cc 91	jsr $91cc			jsr 	CalculateSign 				; calculate result sign
.90d8						NSMCopyPlusTwoToZero:
.90d8		b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.90da		95 58		sta $58,x			sta 	NSMantissa0,x
.90dc		b5 62		lda $62,x			lda 	NSMantissa1+2,x
.90de		95 60		sta $60,x			sta 	NSMantissa1,x
.90e0		b5 6a		lda $6a,x			lda 	NSMantissa2+2,x
.90e2		95 68		sta $68,x			sta 	NSMantissa2,x
.90e4		b5 72		lda $72,x			lda 	NSMantissa3+2,x
.90e6		95 70		sta $70,x			sta 	NSMantissa3,x
.90e8		60		rts				rts
.90e9						CheckDivideZero:
.90e9		e8		inx				inx
.90ea		20 9a 9e	jsr $9e9a			jsr 	NSMIsZero
.90ed		f0 02		beq $90f1			beq 	_CDVError
.90ef		ca		dex				dex
.90f0		60		rts				rts
.90f1						_CDVError:
.90f1		a9 03		lda #$03		lda	#3
.90f3		4c 51 8f	jmp $8f51		jmp	ErrorHandler
.90f6						IntegerModulus:
.90f6		fa		plx				plx
.90f7		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.90f9		15 51		ora $51,x			ora 	NSStatus+1,x
.90fb		0a		asl a				asl 	a 							; shift reference bit into sign bit
.90fc		0a		asl a				asl 	a
.90fd		10 05		bpl $9104			bpl 	_NotRef
.90ff		48		pha				pha
.9100		20 13 97	jsr $9713			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9103		68		pla				pla
.9104						_NotRef:
.9104		0a		asl a				asl 	a
.9105		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9107		15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9109		15 79		ora $79,x			ora 	NSExponent+1,x
.910b		f0 03		beq $9110			beq 	_IntegerCode 				; if clear, then we have two integers
.910d		4c 00 a0	jmp $a000			jmp 	TypeError 					; anything else, type mismatch.
.9110						_IntegerCode:
.9110						IntegerModulusNoCheck:
.9110		20 e9 90	jsr $90e9			jsr 	CheckDivideZero 			; do div zero check
.9113		20 1b 91	jsr $911b			jsr 	Int32Divide 				; do the division
.9116		16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.9118		56 50		lsr $50,x			lsr 	NSStatus,x
.911a		60		rts				rts
.911b						Int32Divide:
.911b		48		pha				pha 								; save AXY
.911c		5a		phy				phy
.911d		20 5b 9e	jsr $9e5b			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.9120		20 74 9e	jsr $9e74			jsr 	NSMSetZeroMantissaOnly 		; set S[X] to zero
.9123		a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.9125						_I32DivideLoop:
.9125		e8		inx				inx
.9126		e8		inx				inx
.9127		20 87 9e	jsr $9e87			jsr 	NSMShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.912a		ca		dex				dex
.912b		ca		dex				dex
.912c		20 88 9e	jsr $9e88			jsr 	NSMRotateLeft
.912f		20 5a 91	jsr $915a			jsr 	DivideCheckSubtract 		; check if subtract possible
.9132		90 02		bcc $9136			bcc 	_I32DivideNoCarryIn
.9134		f6 5a		inc $5a,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.9136						_I32DivideNoCarryIn:
.9136		88		dey				dey 								; loop round till division completed.
.9137		d0 ec		bne $9125			bne 	_I32DivideLoop
.9139		7a		ply				ply 								; restore AXY and exit
.913a		68		pla				pla
.913b		60		rts				rts
.913c						Int32ShiftDivide:
.913c		48		pha				pha 								; save AY
.913d		5a		phy				phy
.913e		e8		inx				inx 								; clear S[X+2]
.913f		e8		inx				inx
.9140		20 78 9e	jsr $9e78			jsr 	NSMSetZero
.9143		ca		dex				dex
.9144		ca		dex				dex
.9145		a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.9147						_I32SDLoop:
.9147		20 5a 91	jsr $915a			jsr 	DivideCheckSubtract 		; check if subtract possible
.914a		e8		inx				inx
.914b		e8		inx				inx
.914c		20 88 9e	jsr $9e88			jsr 	NSMRotateLeft				; shift 64 bit FPA left, rotating carry in
.914f		ca		dex				dex
.9150		ca		dex				dex
.9151		20 88 9e	jsr $9e88			jsr 	NSMRotateLeft
.9154		88		dey				dey 	 							; do 31 times
.9155		d0 f0		bne $9147			bne 	_I32SDLoop
.9157		7a		ply				ply 								; restore AY and exit
.9158		68		pla				pla
.9159		60		rts				rts
.915a						DivideCheckSubtract:
.915a		20 65 92	jsr $9265			jsr 	SubTopTwoStack 				; subtract Stack[X+1] from Stack[X+0]
.915d		b0 04		bcs $9163			bcs 	_DCSExit 					; if carry set, then could do, exit
.915f		20 4b 92	jsr $924b			jsr 	AddTopTwoStack 				; add it back in
.9162		18		clc				clc 								; and return False
.9163						_DCSExit:
.9163		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/multiply.asm

.9164						MulInteger:
.9164		fa		plx				plx
.9165		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9167		15 51		ora $51,x			ora 	NSStatus+1,x
.9169		0a		asl a				asl 	a 							; shift reference bit into sign bit
.916a		0a		asl a				asl 	a
.916b		10 05		bpl $9172			bpl 	_NotRef
.916d		48		pha				pha
.916e		20 13 97	jsr $9713			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9171		68		pla				pla
.9172						_NotRef:
.9172		0a		asl a				asl 	a 							; put MSB of type into A:7
.9173		30 09		bmi $917e			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9175		b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9177		15 79		ora $79,x			ora 	NSExponent+1,x
.9179		f0 06		beq $9181			beq 	_IntegerCode 				; if clear, then we have two integers
.917b		4c e2 95	jmp $95e2			jmp 	FloatingPointMultiply 							; otherwise at least one float.
.917e						_StringData:
.917e		4c 0a a0	jmp $a00a			jmp 	NotDoneError							; at least one string - don't know both are strings.
.9181						_IntegerCode:
.9181		20 8e 91	jsr $918e			jsr 	MultiplyShort
.9184		c9 00		cmp #$00			cmp 	#0
.9186		f0 05		beq $918d			beq 	_MIExit
.9188		a9 04		lda #$04		lda	#4
.918a		4c 51 8f	jmp $8f51		jmp	ErrorHandler
.918d						_MIExit:
.918d		60		rts				rts
.918e						MultiplyShort:
.918e		5a		phy				phy 								; save Y
.918f		20 5b 9e	jsr $9e5b			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.9192		20 74 9e	jsr $9e74			jsr 	NSMSetZeroMantissaOnly 		; set mantissa S[X] to zero
.9195		a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.9197						_I32MLoop:
.9197		b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.9199		15 62		ora $62,x			ora 	NSMantissa1+2,x
.919b		15 6a		ora $6a,x			ora 	NSMantissa2+2,x
.919d		15 72		ora $72,x			ora 	NSMantissa3+2,x
.919f		f0 25		beq $91c6			beq 	_I32MExit 					; exit if zero
.91a1		b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.91a3		29 01		and #$01			and 	#1
.91a5		f0 0d		beq $91b4			beq 	_I32MNoAdd
.91a7		20 4b 92	jsr $924b			jsr 	AddTopTwoStack 				; if so add S[X+1] to S[X+0]
.91aa		b5 70		lda $70,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.91ac		10 06		bpl $91b4			bpl 	_I32MNoAdd
.91ae						_I32ShiftRight:
.91ae		20 91 9e	jsr $9e91			jsr 	NSMShiftRight 				; shift S[X] right
.91b1		c8		iny				iny 								; increment shift count
.91b2		80 09		bra $91bd			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.91b4						_I32MNoAdd:
.91b4		34 71		bit $71,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.91b6		70 f6		bvs $91ae			bvs 	_I32ShiftRight 				; instead.
.91b8		e8		inx				inx
.91b9		20 87 9e	jsr $9e87			jsr 	NSMShiftLeft 				; shift additive S[X+1] left
.91bc		ca		dex				dex
.91bd						_I32MShiftUpper:
.91bd		e8		inx				inx 								; shift S[X+2] right
.91be		e8		inx				inx
.91bf		20 91 9e	jsr $9e91			jsr 	NSMShiftRight
.91c2		ca		dex				dex
.91c3		ca		dex				dex
.91c4		80 d1		bra $9197			bra 	_I32MLoop 					; try again.
.91c6						_I32MExit:
.91c6		20 cc 91	jsr $91cc			jsr 	CalculateSign
.91c9		98		tya				tya 								; shift in A
.91ca		7a		ply				ply 								; restore Y and exit
.91cb		60		rts				rts
.91cc						CalculateSign:
.91cc		b5 50		lda $50,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.91ce		16 50		asl $50,x			asl 	NSStatus,x 					; shift result left
.91d0		55 51		eor $51,x			eor 	NSStatus+1,x
.91d2		0a		asl a				asl 	a 							; shift bit 7 into carry
.91d3		76 50		ror $50,x			ror 	NSStatus,x 					; shift right into status byte.
.91d5		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/scompare.asm

.91d6						CompareStrings:
.91d6		b5 50		lda $50,x			lda 	NSStatus,x 					; check both are strings
.91d8		35 51		and $51,x			and 	NSStatus+1,x
.91da		29 10		and #$10			and 	#NSBIsString
.91dc		f0 28		beq $9206			beq 	_CSTypeError
.91de		b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy string addresses to zTemp0/1
.91e0		85 36		sta $36				sta 	zTemp0
.91e2		b5 60		lda $60,x			lda 	NSMantissa1,x
.91e4		85 37		sta $37				sta 	zTemp0+1
.91e6		b5 59		lda $59,x			lda 	NSMantissa0+1,x
.91e8		85 38		sta $38				sta 	zTemp1
.91ea		b5 61		lda $61,x			lda 	NSMantissa1+1,x
.91ec		85 39		sta $39				sta 	zTemp1+1
.91ee		5a		phy				phy 								; save Y so we can access strings
.91ef		a0 ff		ldy #$ff			ldy 	#$FF 						; -1 for pre increment.
.91f1						_CSLoop:
.91f1		c8		iny				iny
.91f2		b1 36		lda ($36),y			lda 	(zTemp0),y 					; check if they are the same
.91f4		d1 38		cmp ($38),y			cmp 	(zTemp1),y
.91f6		d0 06		bne $91fe			bne 	_CSDifferent
.91f8		c9 00		cmp #$00			cmp 	#0 							; reached end ?
.91fa		d0 f5		bne $91f1			bne 	_CSLoop 					; still comparing
.91fc						_CSExit:
.91fc		7a		ply				ply 								; reached end, return zero in A from EOS
.91fd		60		rts				rts
.91fe						_CSDifferent:
.91fe		a9 ff		lda #$ff			lda 	#255 						; if < return $FF
.9200		90 fa		bcc $91fc			bcc		_CSExit
.9202		a9 01		lda #$01			lda 	#1 							; otherwise return 1.
.9204		80 f6		bra $91fc			bra 	_CSExit
.9206						_CSTypeError:
.9206		4c 00 a0	jmp $a000			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/shifts.asm

.9209						ShiftLeft:
.9209		38		sec				sec 								; common code, carry determines which way.
.920a		80 01		bra $920d			bra 	ShiftMain
.920c						ShiftRight:
.920c		18		clc				clc
.920d						ShiftMain:
.920d		fa		plx				plx 								; restore X
.920e		08		php				php 								; save direction
.920f		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9211		15 51		ora $51,x			ora 	NSStatus+1,x
.9213		0a		asl a				asl 	a 							; shift reference bit into sign bit
.9214		0a		asl a				asl 	a
.9215		10 05		bpl $921c			bpl 	_NotRef
.9217		48		pha				pha
.9218		20 13 97	jsr $9713			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.921b		68		pla				pla
.921c						_NotRef:
.921c		0a		asl a				asl 	a
.921d		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.921f		15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9221		15 79		ora $79,x			ora 	NSExponent+1,x
.9223		f0 03		beq $9228			beq 	_IntegerCode 				; if clear, then we have two integers
.9225		4c 00 a0	jmp $a000			jmp 	TypeError 					; anything else, type mismatch.
.9228						_IntegerCode:
.9228		b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; check number < 32
.922a		29 e0		and #$e0			and 	#$E0
.922c		15 61		ora $61,x			ora 	NSMantissa1+1,x
.922e		15 69		ora $69,x			ora 	NSMantissa2+1,x
.9230		15 71		ora $71,x			ora 	NSMantissa3+1,x
.9232		d0 12		bne $9246			bne 	_SMExit0 					; if >= 32 it will always return zero.
.9234						_SMLoop:
.9234		d6 59		dec $59,x			dec 	NSMantissa0+1,x 			; predecrement, could do << 0
.9236		30 11		bmi $9249			bmi 	_SMExit 					; exit if done.
.9238		28		plp				plp 								; restore direction setting
.9239		08		php				php
.923a		90 05		bcc $9241			bcc 	_SMRight
.923c		20 87 9e	jsr $9e87			jsr 	NSMShiftLeft 				; shift left if CS
.923f		80 f3		bra $9234			bra 	_SMLoop
.9241						_SMRight:
.9241		20 91 9e	jsr $9e91			jsr 	NSMShiftRight 				; shift right if CC
.9244		80 ee		bra $9234			bra 	_SMLoop
.9246						_SMExit0:
.9246		20 78 9e	jsr $9e78			jsr 	NSMSetZero 					; return zero.
.9249						_SMExit:
.9249		28		plp				plp 								; throw direction
.924a		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/simple.asm

.924b						AddTopTwoStack:
.924b		18		clc				clc
.924c		b5 58		lda $58,x			lda		NSMantissa0,x
.924e		75 59		adc $59,x			adc 		NSMantissa0+1,x
.9250		95 58		sta $58,x			sta 	NSMantissa0,x
.9252		b5 60		lda $60,x			lda		NSMantissa1,x
.9254		75 61		adc $61,x			adc 		NSMantissa1+1,x
.9256		95 60		sta $60,x			sta 	NSMantissa1,x
.9258		b5 68		lda $68,x			lda		NSMantissa2,x
.925a		75 69		adc $69,x			adc 		NSMantissa2+1,x
.925c		95 68		sta $68,x			sta 	NSMantissa2,x
.925e		b5 70		lda $70,x			lda		NSMantissa3,x
.9260		75 71		adc $71,x			adc 		NSMantissa3+1,x
.9262		95 70		sta $70,x			sta 	NSMantissa3,x
.9264		60		rts				rts
.9265						SubTopTwoStack:
.9265		38		sec				sec
.9266		b5 58		lda $58,x			lda		NSMantissa0,x
.9268		f5 59		sbc $59,x			sbc 		NSMantissa0+1,x
.926a		95 58		sta $58,x			sta 	NSMantissa0,x
.926c		b5 60		lda $60,x			lda		NSMantissa1,x
.926e		f5 61		sbc $61,x			sbc 		NSMantissa1+1,x
.9270		95 60		sta $60,x			sta 	NSMantissa1,x
.9272		b5 68		lda $68,x			lda		NSMantissa2,x
.9274		f5 69		sbc $69,x			sbc 		NSMantissa2+1,x
.9276		95 68		sta $68,x			sta 	NSMantissa2,x
.9278		b5 70		lda $70,x			lda		NSMantissa3,x
.927a		f5 71		sbc $71,x			sbc 		NSMantissa3+1,x
.927c		95 70		sta $70,x			sta 	NSMantissa3,x
.927e		60		rts				rts
.927f						AddInteger:
.927f		fa		plx				plx
.9280		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9282		15 51		ora $51,x			ora 	NSStatus+1,x
.9284		0a		asl a				asl 	a 							; shift reference bit into sign bit
.9285		0a		asl a				asl 	a
.9286		10 05		bpl $928d			bpl 	_NotRef
.9288		48		pha				pha
.9289		20 13 97	jsr $9713			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.928c		68		pla				pla
.928d						_NotRef:
.928d		0a		asl a				asl 	a 							; put MSB of type into A:7
.928e		30 09		bmi $9299			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9290		b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9292		15 79		ora $79,x			ora 	NSExponent+1,x
.9294		f0 06		beq $929c			beq 	_IntegerCode 				; if clear, then we have two integers
.9296		4c 92 94	jmp $9492			jmp 	FloatingPointAdd 							; otherwise at least one float.
.9299						_StringData:
.9299		4c 58 90	jmp $9058			jmp 	StringConcat							; at least one string - don't know both are strings.
.929c						_IntegerCode:
.929c						AddCode:
.929c		b5 50		lda $50,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.929e		55 51		eor $51,x			eor 	NSStatus+1,x
.92a0		10 a9		bpl $924b			bpl 	AddTopTwoStack
.92a2		20 65 92	jsr $9265			jsr 	SubTopTwoStack 				; do a physical subtraction
.92a5		34 70		bit $70,x			bit 	NSMantissa3,x 				; result is +ve, okay
.92a7		10 07		bpl $92b0			bpl 	_AddExit
.92a9		b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign is that of 2nd value
.92ab		95 50		sta $50,x			sta 	NSStatus,x
.92ad		20 41 9e	jsr $9e41			jsr 	NSMNegateMantissa 			; negate the mantissa and exit
.92b0						_AddExit:
.92b0		20 9a 9e	jsr $9e9a			jsr 	NSMIsZero 					; check for -0
.92b3		d0 02		bne $92b7			bne 	_AddNonZero
.92b5		74 50		stz $50,x			stz 	NSStatus,x
.92b7						_AddNonZero:
.92b7		60		rts				rts
.92b8						SubInteger:
.92b8		fa		plx				plx
.92b9		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.92bb		15 51		ora $51,x			ora 	NSStatus+1,x
.92bd		0a		asl a				asl 	a 							; shift reference bit into sign bit
.92be		0a		asl a				asl 	a
.92bf		10 05		bpl $92c6			bpl 	_NotRef
.92c1		48		pha				pha
.92c2		20 13 97	jsr $9713			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92c5		68		pla				pla
.92c6						_NotRef:
.92c6		0a		asl a				asl 	a 							; put MSB of type into A:7
.92c7		30 09		bmi $92d2			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.92c9		b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92cb		15 79		ora $79,x			ora 	NSExponent+1,x
.92cd		f0 06		beq $92d5			beq 	_IntegerCode 				; if clear, then we have two integers
.92cf		4c 97 94	jmp $9497			jmp 	FloatingPointSub 							; otherwise at least one float.
.92d2						_StringData:
.92d2		4c 0a a0	jmp $a00a			jmp 	NotDoneError							; at least one string - don't know both are strings.
.92d5						_IntegerCode:
.92d5		b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate the second value.
.92d7		49 80		eor #$80			eor 	#$80
.92d9		95 51		sta $51,x			sta 	NSStatus+1,x
.92db		80 bf		bra $929c			bra 	AddCode 					; and do the same code as add.
.92dd						AndInteger:
.92dd		fa		plx				plx
.92de		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.92e0		15 51		ora $51,x			ora 	NSStatus+1,x
.92e2		0a		asl a				asl 	a 							; shift reference bit into sign bit
.92e3		0a		asl a				asl 	a
.92e4		10 05		bpl $92eb			bpl 	_NotRef
.92e6		48		pha				pha
.92e7		20 13 97	jsr $9713			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92ea		68		pla				pla
.92eb						_NotRef:
.92eb		0a		asl a				asl 	a
.92ec		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.92ee		15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92f0		15 79		ora $79,x			ora 	NSExponent+1,x
.92f2		f0 03		beq $92f7			beq 	_IntegerCode 				; if clear, then we have two integers
.92f4		4c 00 a0	jmp $a000			jmp 	TypeError 					; anything else, type mismatch.
.92f7						_IntegerCode:
.92f7		b5 58		lda $58,x			lda		NSMantissa0,x
.92f9		35 59		and $59,x			and 		NSMantissa0+1,x
.92fb		95 58		sta $58,x			sta 	NSMantissa0,x
.92fd		b5 60		lda $60,x			lda		NSMantissa1,x
.92ff		35 61		and $61,x			and 		NSMantissa1+1,x
.9301		95 60		sta $60,x			sta 	NSMantissa1,x
.9303		b5 68		lda $68,x			lda		NSMantissa2,x
.9305		35 69		and $69,x			and 		NSMantissa2+1,x
.9307		95 68		sta $68,x			sta 	NSMantissa2,x
.9309		b5 70		lda $70,x			lda		NSMantissa3,x
.930b		35 71		and $71,x			and 		NSMantissa3+1,x
.930d		95 70		sta $70,x			sta 	NSMantissa3,x
.930f		74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.9311		60		rts				rts
.9312						OraInteger:
.9312		fa		plx				plx
.9313		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9315		15 51		ora $51,x			ora 	NSStatus+1,x
.9317		0a		asl a				asl 	a 							; shift reference bit into sign bit
.9318		0a		asl a				asl 	a
.9319		10 05		bpl $9320			bpl 	_NotRef
.931b		48		pha				pha
.931c		20 13 97	jsr $9713			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.931f		68		pla				pla
.9320						_NotRef:
.9320		0a		asl a				asl 	a
.9321		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9323		15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9325		15 79		ora $79,x			ora 	NSExponent+1,x
.9327		f0 03		beq $932c			beq 	_IntegerCode 				; if clear, then we have two integers
.9329		4c 00 a0	jmp $a000			jmp 	TypeError 					; anything else, type mismatch.
.932c						_IntegerCode:
.932c		b5 58		lda $58,x			lda		NSMantissa0,x
.932e		15 59		ora $59,x			ora 		NSMantissa0+1,x
.9330		95 58		sta $58,x			sta 	NSMantissa0,x
.9332		b5 60		lda $60,x			lda		NSMantissa1,x
.9334		15 61		ora $61,x			ora 		NSMantissa1+1,x
.9336		95 60		sta $60,x			sta 	NSMantissa1,x
.9338		b5 68		lda $68,x			lda		NSMantissa2,x
.933a		15 69		ora $69,x			ora 		NSMantissa2+1,x
.933c		95 68		sta $68,x			sta 	NSMantissa2,x
.933e		b5 70		lda $70,x			lda		NSMantissa3,x
.9340		15 71		ora $71,x			ora 		NSMantissa3+1,x
.9342		95 70		sta $70,x			sta 	NSMantissa3,x
.9344		74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.9346		60		rts				rts
.9347						EorInteger:
.9347		fa		plx				plx
.9348		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.934a		15 51		ora $51,x			ora 	NSStatus+1,x
.934c		0a		asl a				asl 	a 							; shift reference bit into sign bit
.934d		0a		asl a				asl 	a
.934e		10 05		bpl $9355			bpl 	_NotRef
.9350		48		pha				pha
.9351		20 13 97	jsr $9713			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9354		68		pla				pla
.9355						_NotRef:
.9355		0a		asl a				asl 	a
.9356		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9358		15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.935a		15 79		ora $79,x			ora 	NSExponent+1,x
.935c		f0 03		beq $9361			beq 	_IntegerCode 				; if clear, then we have two integers
.935e		4c 00 a0	jmp $a000			jmp 	TypeError 					; anything else, type mismatch.
.9361						_IntegerCode:
.9361		b5 58		lda $58,x			lda		NSMantissa0,x
.9363		55 59		eor $59,x			eor 		NSMantissa0+1,x
.9365		95 58		sta $58,x			sta 	NSMantissa0,x
.9367		b5 60		lda $60,x			lda		NSMantissa1,x
.9369		55 61		eor $61,x			eor 		NSMantissa1+1,x
.936b		95 60		sta $60,x			sta 	NSMantissa1,x
.936d		b5 68		lda $68,x			lda		NSMantissa2,x
.936f		55 69		eor $69,x			eor 		NSMantissa2+1,x
.9371		95 68		sta $68,x			sta 	NSMantissa2,x
.9373		b5 70		lda $70,x			lda		NSMantissa3,x
.9375		55 71		eor $71,x			eor 		NSMantissa3+1,x
.9377		95 70		sta $70,x			sta 	NSMantissa3,x
.9379		74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.937b		60		rts				rts
.937c						WordIndirect:
.937c		fa		plx				plx
.937d		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.937f		15 51		ora $51,x			ora 	NSStatus+1,x
.9381		0a		asl a				asl 	a 							; shift reference bit into sign bit
.9382		0a		asl a				asl 	a
.9383		10 05		bpl $938a			bpl 	_NotRef
.9385		48		pha				pha
.9386		20 13 97	jsr $9713			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9389		68		pla				pla
.938a						_NotRef:
.938a		0a		asl a				asl 	a
.938b		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.938d		15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.938f		15 79		ora $79,x			ora 	NSExponent+1,x
.9391		f0 03		beq $9396			beq 	_IntegerCode 				; if clear, then we have two integers
.9393		4c 00 a0	jmp $a000			jmp 	TypeError 					; anything else, type mismatch.
.9396						_IntegerCode:
.9396		20 9c 92	jsr $929c			jsr 	AddCode 					; add the two values
.9399		a9 22		lda #$22			lda 	#NSBIsReference+2 			; make a 2 byte reference
.939b		95 50		sta $50,x			sta 	NSStatus,x
.939d		60		rts				rts
.939e						ByteIndirect:
.939e		fa		plx				plx
.939f		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.93a1		15 51		ora $51,x			ora 	NSStatus+1,x
.93a3		0a		asl a				asl 	a 							; shift reference bit into sign bit
.93a4		0a		asl a				asl 	a
.93a5		10 05		bpl $93ac			bpl 	_NotRef
.93a7		48		pha				pha
.93a8		20 13 97	jsr $9713			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.93ab		68		pla				pla
.93ac						_NotRef:
.93ac		0a		asl a				asl 	a
.93ad		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.93af		15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.93b1		15 79		ora $79,x			ora 	NSExponent+1,x
.93b3		f0 03		beq $93b8			beq 	_IntegerCode 				; if clear, then we have two integers
.93b5		4c 00 a0	jmp $a000			jmp 	TypeError 					; anything else, type mismatch.
.93b8						_IntegerCode:
.93b8		20 9c 92	jsr $929c			jsr 	AddCode 					; add the two values
.93bb		a9 21		lda #$21			lda 	#NSBIsReference+1 			; make a 1 byte reference
.93bd		95 50		sta $50,x			sta 	NSStatus,x
.93bf		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/tostring.asm

.93c0						ConvertInt16:
.93c0		85 58		sta $58				sta 	NSMantissa0 				; set up as 32 bit conversion
.93c2		86 60		stx $60				stx 	NSMantissa1
.93c4		64 68		stz $68				stz 	NSMantissa2
.93c6		64 70		stz $70				stz 	NSMantissa3
.93c8		64 50		stz $50				stz 	NSStatus 					; positive integer
.93ca		a2 00		ldx #$00			ldx 	#0 							; stack level
.93cc		a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.93ce		80 00		bra $93d0			bra 	ConvertInt32
.93d0						ConvertInt32:
.93d0		5a		phy				phy
.93d1		a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.93d3		24 50		bit $50				bit 	NSStatus 					; output a - if not negative.
.93d5		10 08		bpl $93df			bpl 	_CI32NotNeg
.93d7		48		pha				pha
.93d8		a9 2d		lda #$2d			lda 	#'-'
.93da		99 27 06	sta $0627,y			sta 	NumberBuffer,y
.93dd		c8		iny				iny
.93de		68		pla				pla
.93df						_CI32NotNeg:
.93df		20 ed 93	jsr $93ed			jsr 	_CI32DivideConvert 			; recursive conversion
.93e2		a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.93e4		99 27 06	sta $0627,y			sta 	NumberBuffer,y
.93e7		7a		ply				ply
.93e8		a2 06		ldx #$06			ldx 	#NumberBuffer >> 8 			; return address in XA
.93ea		a9 27		lda #$27			lda 	#NumberBuffer & $FF
.93ec		60		rts				rts
.93ed						_CI32DivideConvert:
.93ed		e8		inx				inx 								; write to next slot up
.93ee		20 7a 9e	jsr $9e7a			jsr 	NSMSetByte 		 			; write the base out.
.93f1		ca		dex				dex
.93f2		20 1b 91	jsr $911b			jsr 	Int32Divide 				; divide
.93f5		b5 58		lda $58,x			lda 	NSMantissa0,x 				; save remainder
.93f7		48		pha				pha
.93f8		20 d8 90	jsr $90d8			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.93fb		20 9a 9e	jsr $9e9a			jsr 	NSMIsZero 					; is it zero ?
.93fe		f0 05		beq $9405			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.9400		b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.9402		20 ed 93	jsr $93ed			jsr 	_CI32DivideConvert 			; and recusrively call.
.9405						_CI32NoRecurse:
.9405		68		pla				pla 								; remainder
.9406		c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.9408		90 02		bcc $940c			bcc 	_CI32NotHex
.940a		69 26		adc #$26			adc 	#6+32
.940c						_CI32NotHex:
.940c		69 30		adc #$30			adc 	#48
.940e		99 27 06	sta $0627,y			sta 	NumberBuffer,y 				; write out and exit
.9411		c8		iny				iny
.9412		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/expression.asm


;******  Processing file: ./common/expressions/../generated/precedence.dat

.9413						PrecedenceLevel:
>9413		04					.byte	 4	; $00 <<
>9414		02					.byte	 2	; $01 <=
>9415		02					.byte	 2	; $02 <>
>9416		00					.byte	 0	; $03 !!3
>9417		00					.byte	 0	; $04 ><
>9418		02					.byte	 2	; $05 >=
>9419		04					.byte	 4	; $06 >>
>941a		00					.byte	 0	; $07 !!7
>941b		00					.byte	 0	; $08 !!8
>941c		00					.byte	 0	; $09 !!9
>941d		00					.byte	 0	; $0a !!10
>941e		00					.byte	 0	; $0b !!11
>941f		00					.byte	 0	; $0c !!12
>9420		00					.byte	 0	; $0d !!13
>9421		00					.byte	 0	; $0e !!14
>9422		00					.byte	 0	; $0f !!15
>9423		00					.byte	 0	; $10 @
>9424		00					.byte	 0	; $11 !!17
>9425		00					.byte	 0	; $12 !!18
>9426		00					.byte	 0	; $13 [
>9427		04					.byte	 4	; $14 \
>9428		00					.byte	 0	; $15 ]
>9429		01					.byte	 1	; $16 ^
>942a		00					.byte	 0	; $17 _
>942b		00					.byte	 0	; $18 `
>942c		00					.byte	 0	; $19 !!25
>942d		00					.byte	 0	; $1a !!26
>942e		00					.byte	 0	; $1b {
>942f		01					.byte	 1	; $1c |
>9430		00					.byte	 0	; $1d }
>9431		00					.byte	 0	; $1e ~
>9432		00					.byte	 0	; $1f [7m<7F>[m
>9433		00					.byte	 0	; $20
>9434		05					.byte	 5	; $21 !
>9435		00					.byte	 0	; $22 "
>9436		00					.byte	 0	; $23 #
>9437		05					.byte	 5	; $24 $
>9438		04					.byte	 4	; $25 %
>9439		01					.byte	 1	; $26 &
>943a		00					.byte	 0	; $27 '
>943b		00					.byte	 0	; $28 (
>943c		00					.byte	 0	; $29 )
>943d		04					.byte	 4	; $2a *
>943e		03					.byte	 3	; $2b +
>943f		00					.byte	 0	; $2c ,
>9440		03					.byte	 3	; $2d -
>9441		00					.byte	 0	; $2e .
>9442		04					.byte	 4	; $2f /
>9443		00					.byte	 0	; $30 0
>9444		00					.byte	 0	; $31 1
>9445		00					.byte	 0	; $32 2
>9446		00					.byte	 0	; $33 3
>9447		00					.byte	 0	; $34 4
>9448		00					.byte	 0	; $35 5
>9449		00					.byte	 0	; $36 6
>944a		00					.byte	 0	; $37 7
>944b		00					.byte	 0	; $38 8
>944c		00					.byte	 0	; $39 9
>944d		00					.byte	 0	; $3a :
>944e		00					.byte	 0	; $3b ;
>944f		02					.byte	 2	; $3c <
>9450		02					.byte	 2	; $3d =
>9451		02					.byte	 2	; $3e >
>9452		05					.byte	 5	; $3f ?

;******  Return to file: ./common/expressions/expression.asm

.9453						EvaluateExpressionAt0:
.9453		a2 00		ldx #$00			ldx 	#0 							; bottom stack level
.9455						EvaluateExpression:
.9455		a9 00		lda #$00			lda 	#0 							; lowest precedence level
.9457						EvaluateExpressionAtPrecedence:
.9457		48		pha				pha 								; save precedence level
.9458		20 9f 98	jsr $989f			jsr 	EvaluateTerm 				; evaluate term into level X.
.945b		68		pla				pla 								; restore precedence level.
.945c						_EXPRLoop:
.945c		85 36		sta $36				sta 	zTemp0 						; save current precedence level.
.945e		b1 30		lda ($30),y			lda 	(codePtr),y
.9460		c9 40		cmp #$40			cmp		#$40 						; if >= $40 cannot be an operator
.9462		b0 25		bcs $9489			bcs 	_EXPRExit
.9464		da		phx				phx 								; read the operator precedence
.9465		aa		tax				tax
.9466		bd 13 94	lda $9413,x			lda 	PrecedenceLevel,x
.9469		fa		plx				plx
.946a		c9 00		cmp #$00			cmp 	#0							; if zero exit (not an operator)
.946c		f0 1b		beq $9489			beq 	_EXPRExit
.946e		85 37		sta $37				sta 	zTemp0+1 					; save operator precedence level.
.9470		a5 36		lda $36				lda 	zTemp0 						; compare current precedence vs. operator precedence
.9472		c5 37		cmp $37				cmp 	zTemp0+1
.9474		b0 13		bcs $9489			bcs		_EXPRExit 					; if current >= operator exit
.9476		48		pha				pha 								; save current precedence.
.9477		b1 30		lda ($30),y			lda 	(codePtr),y
.9479		c8		iny				iny
.947a		48		pha				pha
.947b		a5 37		lda $37				lda 	zTemp0+1 					; get operator precedence level
.947d		e8		inx				inx 								; work out the right hand side.
.947e		20 57 94	jsr $9457			jsr 	EvaluateExpressionAtPrecedence
.9481		ca		dex				dex
.9482		68		pla				pla 								; get operator, call the code.
.9483		20 8c 94	jsr $948c			jsr 	_EXPRCaller
.9486		68		pla				pla 								; restore precedence level
.9487		80 d3		bra $945c			bra 	_EXPRLoop 					; and go round.
.9489						_EXPRExit:
.9489		a5 36		lda $36				lda 	zTemp0 						; A = current precedence level.
.948b		60		rts				rts
.948c						_EXPRCaller:
.948c		da		phx				phx 								; save on stack, first thing is to restore it
.948d		0a		asl a				asl 	a 							; double so can use vectors into X
.948e		aa		tax				tax
.948f		7c 68 8c	jmp ($8c68,x)			jmp 	(VectorSetPunc,x) 			; and go to the code.

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/addsub.asm

.9492						FloatingPointAdd:
.9492		20 08 96	jsr $9608			jsr 	FloatPrepare 				; prepare for floats
.9495		80 09		bra $94a0			bra 	FloatAdd
.9497						FloatingPointSub:
.9497		20 08 96	jsr $9608			jsr 	FloatPrepare 				; prepare for floats
.949a						FloatSubtract:
.949a		b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate FPB
.949c		49 80		eor #$80			eor 	#$80
.949e		95 51		sta $51,x			sta 	NSStatus+1,x				; and fall through.
.94a0						FloatAdd:
.94a0		48		pha				pha
.94a1		5a		phy				phy
.94a2		20 17 96	jsr $9617			jsr 	NSNormalise 				; normalise S[X]
.94a5		f0 51		beq $94f8			beq 	_FAReturn1
.94a7		e8		inx				inx 								; normalise S[X+1]
.94a8		20 17 96	jsr $9617			jsr 	NSNormalise
.94ab		ca		dex				dex
.94ac		c9 00		cmp #$00			cmp 	#0
.94ae		f0 60		beq $9510			beq 	_FAExit 					; if so, just return A
.94b0		b5 78		lda $78,x			lda 	NSExponent,x 				; are the exponents the same ?
.94b2		d5 79		cmp $79,x			cmp 	NSExponent+1,x
.94b4		f0 18		beq $94ce			beq 	_FAExponentsEqual
.94b6		b5 78		lda $78,x			lda 	NSExponent,x 				; work out the larger exponent
.94b8		a8		tay				tay
.94b9		38		sec				sec 								; do a signed comparison of the exponents.
.94ba		f5 79		sbc $79,x			sbc 	NSExponent+1,x
.94bc		50 02		bvc $94c0			bvc 	_FANoSignedChange
.94be		49 80		eor #$80			eor 	#$80
.94c0						_FANoSignedChange:
.94c0		29 80		and #$80			and 	#$80
.94c2		10 02		bpl $94c6			bpl 	_FAHaveMax
.94c4		b4 79		ldy $79,x			ldy 	NSExponent+1,x
.94c6						_FAHaveMax:
.94c6		20 13 95	jsr $9513			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.94c9		e8		inx				inx
.94ca		20 13 95	jsr $9513			jsr 	_FAShiftToExponent
.94cd		ca		dex				dex
.94ce						_FAExponentsEqual:
.94ce		b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs the same
.94d0		55 51		eor $51,x			eor 	NSStatus+1,x
.94d2		30 0e		bmi $94e2			bmi 	_FADifferentSigns
.94d4		20 4b 92	jsr $924b			jsr 	AddTopTwoStack 				; do the add of the mantissae
.94d7		b5 70		lda $70,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.94d9		10 35		bpl $9510			bpl 	_FAExit 					; if no, we are done.
.94db		20 91 9e	jsr $9e91			jsr 	NSMShiftRight 				; shift A right, renormalising it.
.94de		f6 78		inc $78,x			inc 	NSExponent,x 				; bump the exponent and exit
.94e0		80 2e		bra $9510			bra 	_FAExit
.94e2						_FADifferentSigns:
.94e2		20 65 92	jsr $9265			jsr 	SubTopTwoStack 				; subtract mantissa B from A
.94e5		b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the result negative ?
.94e7		10 06		bpl $94ef			bpl 	_FACheckZero 				; if no, check for -0
.94e9		20 3a 9e	jsr $9e3a			jsr 	NSMNegate 					; netate result
.94ec		20 41 9e	jsr $9e41			jsr 	NSMNegateMantissa 			; negate (2'c) the mantissa
.94ef						_FACheckZero:
.94ef		20 9a 9e	jsr $9e9a			jsr 	NSMIsZero	 				; check for -0
.94f2		d0 1c		bne $9510			bne 	_FAExit
.94f4		74 50		stz $50,x			stz 	NSStatus,x
.94f6		80 18		bra $9510			bra 	_FAExit
.94f8						_FAReturn1:
.94f8		b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.94fa		95 58		sta $58,x			sta 	NSMantissa0,x
.94fc		b5 61		lda $61,x			lda 	NSMantissa1+1,x
.94fe		95 60		sta $60,x			sta 	NSMantissa1,x
.9500		b5 69		lda $69,x			lda 	NSMantissa2+1,x
.9502		95 68		sta $68,x			sta 	NSMantissa2,x
.9504		b5 71		lda $71,x			lda 	NSMantissa3+1,x
.9506		95 70		sta $70,x			sta 	NSMantissa3,x
.9508		b5 79		lda $79,x			lda 	NSExponent+1,x
.950a		95 78		sta $78,x			sta 	NSExponent,x
.950c		b5 51		lda $51,x			lda 	NSStatus+1,x
.950e		95 50		sta $50,x			sta 	NSStatus,x
.9510						_FAExit:
.9510		7a		ply				ply
.9511		68		pla				pla
.9512		60		rts				rts
.9513						_FAShiftToExponent:
.9513						_FAShiftToExponent2:
.9513		98		tya				tya 								; compare Y to exponent
.9514		d5 78		cmp $78,x			cmp 	NSExponent,x 				; reached the exponent required ?
.9516		f0 07		beq $951f			beq 	_FASEExit 					; exit if so.
.9518		20 91 9e	jsr $9e91			jsr 	NSMShiftRight	 			; shift the mantissa right
.951b		f6 78		inc $78,x			inc 	NSExponent,x 				; increment exponent
.951d		80 f4		bra $9513			bra 	_FAShiftToExponent2
.951f						_FASEExit:
.951f		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/compare.asm

.9520						CompareFloat:
.9520		20 9a 94	jsr $949a			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.9523		b5 60		lda $60,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.9525		29 f8		and #$f8			and 	#$F8
.9527		15 68		ora $68,x			ora 	NSMantissa2,x
.9529		15 70		ora $70,x			ora 	NSMantissa3,x
.952b		f0 08		beq $9535			beq 	_FCExit 					; zero, so approximately identical
.952d		a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.952f		34 50		bit $50,x			bit 	NSStatus,x
.9531		10 02		bpl $9535			bpl 	_FCExit
.9533						_FCNegative:
.9533		a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.9535						_FCExit:
.9535		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/divide.asm

.9536						FDivideCommand:
.9536		fa		plx				plx	 								; restore stack position
.9537		20 08 96	jsr $9608			jsr 	FloatPrepare 				; prepare for floats
.953a						FloatDivide:
.953a		48		pha				pha
.953b		e8		inx				inx
.953c		20 17 96	jsr $9617			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.953f		ca		dex				dex
.9540		c9 00		cmp #$00			cmp 	#0
.9542		f0 1d		beq $9561			beq 	_FDZero
.9544		20 17 96	jsr $9617			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.9547		f0 16		beq $955f			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.9549		20 3c 91	jsr $913c			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.954c		20 d8 90	jsr $90d8			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.954f		20 17 96	jsr $9617			jsr		NSNormalise 				; renormalise
.9552		20 cc 91	jsr $91cc			jsr 	CalculateSign 				; calculate result sign
.9555		b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent
.9557		38		sec				sec
.9558		f5 79		sbc $79,x			sbc 	NSExponent+1,x
.955a		38		sec				sec
.955b		e9 1e		sbc #$1e			sbc 	#30
.955d		95 78		sta $78,x			sta 	NSExponent,x
.955f						_FDExit:
.955f		68		pla				pla
.9560		60		rts				rts
.9561						_FDZero:
.9561		a9 03		lda #$03		lda	#3
.9563		4c 51 8f	jmp $8f51		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/fractional.asm

.9566						FloatFractionalPart:
.9566		5a		phy				phy
.9567		b5 50		lda $50,x			lda 	NSStatus,x 					; take absolute value
.9569		29 7f		and #$7f			and 	#$7F
.956b		95 50		sta $50,x			sta 	NSStatus,x
.956d		20 17 96	jsr $9617			jsr 	NSNormalise
.9570		b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.9572		38		sec				sec
.9573		e9 e0		sbc #$e0			sbc 	#$E0
.9575		90 29		bcc $95a0			bcc 	_FFPExit 					; already fractional
.9577		c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.9579		b0 22		bcs $959d			bcs 	_FFPZero
.957b		a8		tay				tay 								; put count to do in Y
.957c		b5 70		lda $70,x			lda 	NSMantissa3,x 				; do each in turn.
.957e		20 a2 95	jsr $95a2			jsr 	_FFPPartial
.9581		95 70		sta $70,x			sta 	NSMantissa3,x
.9583		b5 68		lda $68,x			lda 	NSMantissa2,x
.9585		20 a2 95	jsr $95a2			jsr 	_FFPPartial
.9588		95 68		sta $68,x			sta 	NSMantissa2,x
.958a		b5 60		lda $60,x			lda 	NSMantissa1,x
.958c		20 a2 95	jsr $95a2			jsr 	_FFPPartial
.958f		95 60		sta $60,x			sta 	NSMantissa1,x
.9591		b5 58		lda $58,x			lda 	NSMantissa0,x
.9593		20 a2 95	jsr $95a2			jsr 	_FFPPartial
.9596		95 58		sta $58,x			sta 	NSMantissa0,x
.9598		20 9a 9e	jsr $9e9a			jsr 	NSMIsZero 					; zeroed check.
.959b		d0 03		bne $95a0			bne 	_FFPExit
.959d						_FFPZero:
.959d		20 78 9e	jsr $9e78			jsr 	NSMSetZero
.95a0						_FFPExit:
.95a0		7a		ply				ply
.95a1		60		rts				rts
.95a2						_FFPPartial:
.95a2		c0 00		cpy #$00			cpy 	#0 							; no more to do
.95a4		f0 17		beq $95bd			beq 	_FFFPPExit
.95a6		c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.95a8		b0 0c		bcs $95b6			bcs 	_FFFPPWholeByte
.95aa		5a		phy				phy
.95ab						_FFFPPLeft:
.95ab		0a		asl a				asl 	a
.95ac		88		dey				dey
.95ad		d0 fc		bne $95ab			bne 	_FFFPPLeft
.95af		7a		ply				ply
.95b0						_FFFPPRight:
.95b0		4a		lsr a				lsr 	a
.95b1		88		dey				dey
.95b2		d0 fc		bne $95b0			bne 	_FFFPPRight
.95b4		80 07		bra $95bd			bra 	_FFFPPExit
.95b6						_FFFPPWholeByte:
.95b6		98		tya				tya 								; subtract 8 from count
.95b7		38		sec				sec
.95b8		e9 08		sbc #$08			sbc 	#8
.95ba		a8		tay				tay
.95bb		a9 00		lda #$00			lda 	#0 							; and clear all
.95bd						_FFFPPExit:
.95bd		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/integer.asm

.95be						FloatIntegerPart:
.95be		48		pha				pha
.95bf		b5 78		lda $78,x			lda 	NSExponent,x 				; is it integer already ?
.95c1		f0 1d		beq $95e0			beq 	_FIPExit 					; if so do nothing
.95c3		20 9a 9e	jsr $9e9a			jsr 	NSMIsZero 					; is it zero ?
.95c6		f0 15		beq $95dd			beq 	_FIPZero 					; if so return zero.
.95c8		20 17 96	jsr $9617			jsr 	NSNormalise 				; normalise
.95cb		f0 10		beq $95dd			beq 	_FIPZero 					; normalised to zero, exit zero
.95cd						_FIPShift:
.95cd		b5 78		lda $78,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.95cf		10 07		bpl $95d8			bpl 	_FIPCheckZero
.95d1		20 91 9e	jsr $9e91			jsr 	NSMShiftRight 				; shift mantissa right
.95d4		f6 78		inc $78,x			inc 	NSExponent,x 				; bump exponent
.95d6		80 f5		bra $95cd			bra 	_FIPShift
.95d8						_FIPCheckZero:
.95d8		20 9a 9e	jsr $9e9a			jsr 	NSMIsZero 					; avoid -0 problem
.95db		d0 03		bne $95e0			bne 	_FIPExit 					; set to zero if mantissa zero.
.95dd						_FIPZero:
.95dd		20 78 9e	jsr $9e78			jsr 	NSMSetZero
.95e0						_FIPExit:
.95e0		68		pla				pla
.95e1		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/multiply.asm

.95e2						FloatingPointMultiply:
.95e2		20 08 96	jsr $9608			jsr 	FloatPrepare 				; prepare for floats
.95e5						FloatMultiply:
.95e5		48		pha				pha
.95e6		20 17 96	jsr $9617			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.95e9		f0 18		beq $9603			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.95eb		e8		inx				inx
.95ec		20 17 96	jsr $9617			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.95ef		ca		dex				dex
.95f0		c9 00		cmp #$00			cmp 	#0
.95f2		f0 0c		beq $9600			beq 	_FDSetZero
.95f4		20 8e 91	jsr $918e			jsr 	MultiplyShort 				; calculate the result.
.95f7		75 78		adc $78,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.95f9		18		clc				clc
.95fa		75 79		adc $79,x			adc 	NSExponent+1,x
.95fc		95 78		sta $78,x			sta 	NSExponent,x
.95fe		80 03		bra $9603			bra 	_FDExit
.9600						_FDSetZero:
.9600		20 78 9e	jsr $9e78			jsr 	NSMSetZero 					; return 0
.9603						_FDExit:
.9603		20 17 96	jsr $9617			jsr 	NSNormalise 				; normalise the result
.9606		68		pla				pla
.9607		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/utility.asm

.9608						FloatPrepare:
.9608		20 13 97	jsr $9713			jsr 	DereferenceTopTwo 			; dereference the top two values
.960b		b5 50		lda $50,x			lda 	NSStatus,x 					; check ints/floats, either will do.
.960d		15 51		ora $51,x			ora 	NSStatus+1,x
.960f		29 10		and #$10			and 	#NSBIsString
.9611		d0 01		bne $9614			bne 	_FDType
.9613		60		rts				rts
.9614						_FDType:
.9614		4c 00 a0	jmp $a000			jmp 	TypeError
.9617						NSNormalise:
.9617		b5 50		lda $50,x			lda 	NSStatus,x 					; make float, keep sign
.9619		29 80		and #$80			and 	#$80
.961b		09 08		ora #$08			ora 	#NSTFloat
.961d		95 50		sta $50,x			sta 	NSStatus,x
.961f		20 9a 9e	jsr $9e9a			jsr 	NSMIsZero 					; if zero exit
.9622		d0 07		bne $962b			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.9624		16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.9626		76 50		ror $50,x			ror 	NSStatus,x 					; (no -0)
.9628		a9 00		lda #$00			lda 	#0 							; set Z flag
.962a		60		rts				rts
.962b						_NSNormaliseOptimise:
.962b		b5 70		lda $70,x			lda 	NSMantissa3,x 				; upper byte zero ?
.962d		d0 19		bne $9648			bne 	_NSNormaliseLoop
.962f		b5 68		lda $68,x			lda 	NSMantissa2,x 				; byte normalise
.9631		30 15		bmi $9648			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.9633		95 70		sta $70,x			sta 	NSMantissa3,x
.9635		b5 60		lda $60,x			lda 	NSMantissa1,x
.9637		95 68		sta $68,x			sta 	NSMantissa2,x
.9639		b5 58		lda $58,x			lda 	NSMantissa0,x
.963b		95 60		sta $60,x			sta 	NSMantissa1,x
.963d		74 58		stz $58,x			stz 	NSMantissa0,x
.963f		b5 78		lda $78,x			lda 	NSExponent,x
.9641		38		sec				sec
.9642		e9 08		sbc #$08			sbc 	#8
.9644		95 78		sta $78,x			sta 	NSExponent,x
.9646		80 e3		bra $962b			bra 	_NSNormaliseOptimise
.9648						_NSNormaliseLoop:
.9648		34 70		bit $70,x			bit 	NSMantissa3,x 				; bit 30 set ?
.964a		70 07		bvs $9653			bvs 	_NSNExit 					; exit if so with Z flag clear
.964c		20 87 9e	jsr $9e87			jsr 	NSMShiftLeft 				; shift mantissa left
.964f		d6 78		dec $78,x			dec 	NSExponent,x 				; adjust exponent
.9651		80 f5		bra $9648			bra 	_NSNormaliseLoop
.9653						_NSNExit:
.9653		a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.9655		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignnumber.asm

.9656						AssignNumber:
.9656		5a		phy				phy
.9657		b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy mantissa0/1 to zTemp0
.9659		85 36		sta $36				sta 	zTemp0
.965b		b5 60		lda $60,x			lda 	NSMantissa1,x
.965d		85 37		sta $37				sta 	zTemp0+1
.965f		b5 50		lda $50,x			lda 	NSStatus,x 					; clear reference bits
.9661		29 df		and #$df			and 	#(NSBIsReference ^ $FF)
.9663		95 50		sta $50,x			sta 	NSStatus,x
.9665		29 18		and #$18			and 	#NSBTypeMask				; assigning to a float ?
.9667		c9 08		cmp #$08			cmp 	#NSTFloat
.9669		f0 24		beq $968f			beq 	_ANFloat
.966b		b5 79		lda $79,x			lda		NSExponent+1,x 				; is it a float
.966d		f0 03		beq $9672			beq		_ANNotFloat
.966f		4c fb 9f	jmp $9ffb			jmp 	RangeError					; if it is, report an error.
.9672						_ANNotFloat:
.9672		b5 50		lda $50,x			lda 	NSStatus,x 					; check if byte/word reference.
.9674		29 03		and #$03			and 	#3
.9676		d0 05		bne $967d			bne 	_ANByteWord
.9678		20 9a 96	jsr $969a			jsr 	_ANCopy4PackSign 			; copy all 4 bytes and sign
.967b		80 1b		bra $9698			bra 	_ANExit
.967d						_ANByteWord:
.967d		48		pha				pha 								; save count
.967e		b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; do byte
.9680		92 36		sta ($36)			sta 	(zTemp0)
.9682		68		pla				pla
.9683		c9 01		cmp #$01			cmp	 	#1
.9685		f0 11		beq $9698			beq 	_ANExit
.9687		b5 61		lda $61,x			lda 	NSMantissa1+1,x 			; do word
.9689		a0 01		ldy #$01			ldy 	#1
.968b		91 36		sta ($36),y			sta 	(zTemp0),y
.968d		80 09		bra $9698			bra 	_ANExit
.968f						_ANFloat:
.968f		20 9a 96	jsr $969a			jsr 	_ANCopy4PackSign 			; write all 4 bytes and packed sign
.9692		b5 79		lda $79,x			lda 	NSExponent+1,x 				; copy exponent to slot 4
.9694		a0 04		ldy #$04			ldy 	#4
.9696		91 36		sta ($36),y			sta 	(zTemp0),y
.9698						_ANExit:
.9698		7a		ply				ply
.9699		60		rts				rts
.969a						_ANCopy4PackSign:
.969a		a0 03		ldy #$03			ldy 	#3
.969c		b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign bit into status
.969e		29 80		and #$80			and 	#$80 						; put into high bit of mantissa 3
.96a0		15 71		ora $71,x			ora 	NSMantissa3+1,x
.96a2		91 36		sta ($36),y			sta 	(zTemp0),y
.96a4		88		dey				dey
.96a5		b5 69		lda $69,x			lda 	NSMantissa2+1,x
.96a7		91 36		sta ($36),y			sta 	(zTemp0),y
.96a9		88		dey				dey
.96aa		b5 61		lda $61,x			lda 	NSMantissa1+1,x
.96ac		91 36		sta ($36),y			sta 	(zTemp0),y
.96ae		88		dey				dey
.96af		b5 59		lda $59,x			lda 	NSMantissa0+1,x
.96b1		91 36		sta ($36),y			sta 	(zTemp0),y
.96b3		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignstring.asm

.96b4						AssignString:
.96b4		5a		phy				phy
.96b5		b5 59		lda $59,x			lda 	NSMantissa0+1,x
.96b7		85 38		sta $38				sta 	zTemp1
.96b9		b5 61		lda $61,x			lda 	NSMantissa1+1,x
.96bb		85 39		sta $39				sta 	zTemp1+1
.96bd		b5 58		lda $58,x			lda 	NSMantissa0,x
.96bf		85 36		sta $36				sta 	zTemp0
.96c1		b5 60		lda $60,x			lda 	NSMantissa1,x
.96c3		85 37		sta $37				sta 	zTemp0+1
.96c5		a0 01		ldy #$01			ldy 	#1 							; the high byte of the target address
.96c7		b1 36		lda ($36),y			lda 	(zTemp0),y
.96c9		f0 23		beq $96ee			beq 	_ASNewStringRequired 		; if zero, a new string is required.
.96cb		38		sec				sec 								; put Address-2 in zsTemp - this is the size/status/string record
.96cc		b2 36		lda ($36)			lda 	(zTemp0) 					; of concreted strings
.96ce		e9 02		sbc #$02			sbc 	#2
.96d0		85 3c		sta $3c				sta 	zsTemp
.96d2		a0 01		ldy #$01			ldy 	#1
.96d4		b1 36		lda ($36),y			lda 	(zTemp0),y
.96d6		e9 00		sbc #$00			sbc 	#0
.96d8		85 3d		sta $3d				sta 	zsTemp+1
.96da		a0 ff		ldy #$ff			ldy 	#$FF 						; get length of new string
.96dc						_ASGetLength:
.96dc		c8		iny				iny
.96dd		b1 38		lda ($38),y			lda 	(zTemp1),y
.96df		d0 fb		bne $96dc			bne 	_ASGetLength
.96e1		98		tya				tya 								; is this length <= current length
.96e2		d2 3c		cmp ($3c)			cmp 	(zsTemp)
.96e4		90 1e		bcc $9704			bcc 	_ASCopyString
.96e6		f0 1c		beq $9704			beq 	_ASCopyString
.96e8		a9 80		lda #$80			lda 	#$80 						; mark as unused.
.96ea		a0 01		ldy #$01			ldy 	#1
.96ec		91 3c		sta ($3c),y			sta 	(zsTemp),y
.96ee						_ASNewStringRequired:
.96ee		e8		inx				inx 								; concrete the new string.
.96ef		20 8d a7	jsr $a78d			jsr 	StringConcrete				; (breaks zTemp1/2, not zTemp0 and zsTemp)
.96f2		ca		dex				dex
.96f3		18		clc				clc
.96f4		b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy that new address to the reference.
.96f6		69 02		adc #$02			adc 	#2 							; add two to point at the data.
.96f8		92 36		sta ($36)			sta 	(zTemp0)
.96fa		b5 61		lda $61,x			lda 	NSMantissa1+1,x
.96fc		69 00		adc #$00			adc 	#0
.96fe		a0 01		ldy #$01			ldy 	#1
.9700		91 36		sta ($36),y			sta 	(zTemp0),y
.9702		80 0d		bra $9711			bra 	_ASExit
.9704						_ASCopyString:
.9704		a0 00		ldy #$00			ldy 	#0
.9706						_ASCopyLoop:
.9706		b1 38		lda ($38),y			lda 	(zTemp1),y
.9708		c8		iny				iny
.9709		c8		iny				iny
.970a		91 3c		sta ($3c),y			sta 	(zsTemp),y
.970c		88		dey				dey
.970d		c9 00		cmp #$00			cmp 	#0
.970f		d0 f5		bne $9706			bne 	_ASCopyLoop
.9711						_ASExit:
.9711		7a		ply				ply
.9712		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/dereference.asm

.9713						DereferenceTopTwo:
.9713		e8		inx				inx
.9714		20 18 97	jsr $9718			jsr 	Dereference 				; deref x+1
.9717		ca		dex				dex  								; falls through to deref x
.9718						Dereference:
.9718		b5 50		lda $50,x			lda 	NSStatus,x 					; get the status byte
.971a		29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.971c		f0 48		beq $9766			beq 	_DRFExit 					; not a reference, so exit.
.971e		5a		phy				phy
.971f		b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address to dereference into zTemp0
.9721		85 36		sta $36				sta 	zTemp0
.9723		b5 60		lda $60,x			lda 	NSMantissa1,x
.9725		85 37		sta $37				sta 	zTemp0+1
.9727		74 60		stz $60,x			stz 	NSMantissa1,x 				; clear second byte.
.9729		b2 36		lda ($36)			lda 	(zTemp0) 					; do the first byte
.972b		95 58		sta $58,x			sta 	NSMantissa0,x
.972d		b5 50		lda $50,x			lda 	NSStatus,x 					; get status byte.
.972f		29 18		and #$18			and 	#NSBTypeMask 				; what type is it ?
.9731		c9 10		cmp #$10			cmp 	#NSTString 					; if string, dereference two
.9733		f0 0e		beq $9743			beq 	_DRFDereferenceTwo
.9735		c9 08		cmp #$08			cmp 	#NSTFloat 					; if float, do full dereference.
.9737		f0 2f		beq $9768			beq 	_DRFFull
.9739		b5 50		lda $50,x			lda 	NSStatus,x 					; must be integer - how many bytes ?
.973b		29 03		and #$03			and 	#3
.973d		f0 29		beq $9768			beq 	_DRFFull 					; the whole word
.973f		c9 01		cmp #$01			cmp 	#1 							; is it 10 (e.g. 2 bytes)
.9741		f0 06		beq $9749			beq		_DRFClear23 				; no, one byte, clear 2 & 3 and exit
.9743						_DRFDereferenceTwo:
.9743		a0 01		ldy #$01			ldy 	#1
.9745		b1 36		lda ($36),y			lda 	(zTemp0),y
.9747		95 60		sta $60,x			sta 	NSMantissa1,x
.9749						_DRFClear23:
.9749		74 68		stz $68,x			stz 	NSMantissa2,x 				; clear upper bytes, only read 1 or 2 bytes
.974b		74 70		stz $70,x			stz 	NSMantissa3,x
.974d		b5 50		lda $50,x			lda 	NSStatus,x 					; make it a value of that type.
.974f		29 18		and #$18			and 	#NSBTypeMask
.9751		95 50		sta $50,x			sta 	NSStatus,x 					; and fall through.
.9753		c9 10		cmp #$10			cmp 	#NSTString  				; is it a string
.9755		d0 0e		bne $9765			bne 	_DRFNotString
.9757		b5 58		lda $58,x			lda 	NSMantissa0,x 				; check address is zero
.9759		15 60		ora $60,x			ora 	NSMantissa1,x
.975b		d0 08		bne $9765			bne 	_DRFNotString
.975d		a9 67		lda #$67			lda 	#_DRFNullString & $FF 		; if so, return reference to ""
.975f		95 58		sta $58,x			sta 	NSMantissa0,X
.9761		a9 97		lda #$97			lda 	#_DRFNullString >> 8
.9763		95 60		sta $60,x			sta 	NSMantissa1,X
.9765						_DRFNotString
.9765		7a		ply				ply 								; restore Y and exit
.9766						_DRFExit:
.9766		60		rts				rts
.9767						_DRFNullString:
>9767		00						.byte 	0
.9768						_DRFFull:
.9768		a0 01		ldy #$01			ldy 	#1 							; get remaining 3 bytes.
.976a		b1 36		lda ($36),y			lda 	(zTemp0),y
.976c		95 60		sta $60,x			sta 	NSMantissa1,x
.976e		c8		iny				iny
.976f		b1 36		lda ($36),y			lda 	(zTemp0),y
.9771		95 68		sta $68,x			sta 	NSMantissa2,x
.9773		c8		iny				iny
.9774		b1 36		lda ($36),y			lda 	(zTemp0),y
.9776		95 70		sta $70,x			sta 	NSMantissa3,x
.9778		74 78		stz $78,x			stz 	NSExponent,x 				; clear exponent.
.977a		b5 50		lda $50,x			lda		NSStatus,x 					; see if type is integer
.977c		29 18		and #$18			and 	#NSBTypeMask  				; type information only
.977e		95 50		sta $50,x			sta 	NSStatus,x 					; update it back.
.9780		f0 05		beq $9787			beq 	_DRFNoExponent
.9782		c8		iny				iny 								; if not, read the exponent as well.
.9783		b1 36		lda ($36),y			lda 	(zTemp0),y
.9785		95 78		sta $78,x			sta 	NSExponent,x
.9787						_DRFNoExponent:
.9787		b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the most significant bit set ?
.9789		10 0a		bpl $9795			bpl 	_DRFExit2 					; if not, then exit.
.978b		29 7f		and #$7f			and 	#$7F 						; clear that bit.
.978d		95 70		sta $70,x			sta 	NSMantissa3,x
.978f		b5 50		lda $50,x			lda 	NSStatus,x 					; set the sign flag
.9791		09 80		ora #$80			ora 	#NSBIsNegative
.9793		95 50		sta $50,x			sta 	NSStatus,x
.9795						_DRFExit2:
.9795		7a		ply				ply
.9796		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/number.asm

=1						ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2						ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3						ESTA_Decimal = 3 							; fractional part.
.9797						EncodeNumberStart:
.9797		38		sec				sec
.9798		80 01		bra $979b			bra 	EncodeNumberContinue+1
.979a						EncodeNumberContinue:
.979a		18		clc				clc
.979b						EncodeNumber:
.979b		08		php				php 								; save reset flag.
.979c		c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.979e		f0 12		beq $97b2			beq 	_ENIsOkay
.97a0		c9 30		cmp #$30			cmp 	#"0"
.97a2		90 04		bcc $97a8			bcc 	_ENBadNumber
.97a4		c9 3a		cmp #$3a			cmp 	#"9"+1
.97a6		90 0a		bcc $97b2			bcc 	_ENIsOkay
.97a8						_ENBadNumber:
.97a8		28		plp				plp 								; throw saved reset
.97a9		ad 05 04	lda $0405			lda 	EncodeState 				; if in decimal mode, construct final number
.97ac		c9 03		cmp #$03			cmp 	#ESTA_Decimal
.97ae		f0 7b		beq $982b			beq 	_ENConstructFinal
.97b0						_ENFail:
.97b0		18		clc				clc 								; not allowed
.97b1		60		rts				rts
.97b2						_ENIsOkay:
.97b2		28		plp				plp 								; are we restarting
.97b3		90 15		bcc $97ca			bcc 	_ENNoRestart
.97b5						_ENStartEncode:
.97b5		c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.97b7		f0 0c		beq $97c5			beq 	_ENFirstDP
.97b9		29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.97bb		20 7a 9e	jsr $9e7a			jsr 	NSMSetByte 					; in single byte mode.
.97be		a9 01		lda #$01			lda 	#ESTA_Low
.97c0						_ENExitChange:
.97c0		8d 05 04	sta $0405			sta 	EncodeState 				; save new state
.97c3		38		sec				sec
.97c4		60		rts				rts
.97c5						_ENFirstDP:
.97c5		20 78 9e	jsr $9e78			jsr 	NSMSetZero 					; clear integer part
.97c8		80 3c		bra $9806			bra 	_ESTASwitchFloat			; go straight to float and exi
.97ca						_ENNoRestart:
.97ca		48		pha				pha 								; save digit or DP on stack.
.97cb		ad 05 04	lda $0405			lda 	EncodeState 				; get current state
.97ce		c9 01		cmp #$01			cmp 	#ESTA_Low
.97d0		f0 09		beq $97db			beq  	_ESTALowState
.97d2		c9 02		cmp #$02			cmp 	#ESTA_High
.97d4		f0 26		beq $97fc			beq 	_ESTAHighState
.97d6		c9 03		cmp #$03			cmp 	#ESTA_Decimal
.97d8		f0 38		beq $9812			beq 	_ESTADecimalState
>97da		db						.byte 	$DB 						; causes a break in the emulator
.97db						_ESTALowState:
.97db		68		pla				pla 								; get value back
.97dc		c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.97de		f0 26		beq $9806			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.97e0		29 0f		and #$0f			and 	#15 						; make digit
.97e2		8d 06 04	sta $0406			sta 	DigitTemp 					; save it.
.97e5		b5 58		lda $58,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.97e7		0a		asl a				asl 	a
.97e8		0a		asl a				asl 	a
.97e9		75 58		adc $58,x			adc 	NSMantissa0,x
.97eb		0a		asl a				asl 	a
.97ec		6d 06 04	adc $0406			adc 	DigitTemp
.97ef		95 58		sta $58,x			sta 	NSMantissa0,x
.97f1		c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.97f3		90 05		bcc $97fa			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.97f5		a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.97f7		8d 05 04	sta $0405			sta 	EncodeState
.97fa						_ESTANoSwitch:
.97fa		38		sec				sec
.97fb		60		rts				rts
.97fc						_ESTAHighState:
.97fc		68		pla				pla 								; get value back
.97fd		c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.97ff		f0 05		beq $9806			beq 	_ESTASwitchFloat
.9801		20 5f 98	jsr $985f			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.9804		38		sec				sec
.9805		60		rts				rts
.9806						_ESTASwitchFloat:
.9806		9c 07 04	stz $0407			stz 	DecimalCount 				; reset the count of digits - we divide by 10^n at the end.
.9809		e8		inx				inx 								; zero the decimal additive.
.980a		20 78 9e	jsr $9e78			jsr 	NSMSetZero
.980d		ca		dex				dex
.980e		a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.9810		80 ae		bra $97c0			bra 	_ENExitChange
.9812						_ESTADecimalState:
.9812		68		pla				pla 								; digit.
.9813		c9 2e		cmp #$2e			cmp 	#"." 						; fail on 2nd decimal point.
.9815		f0 99		beq $97b0			beq 	_ENFail
.9817		e8		inx				inx 								; put digit into fractional part of X+1
.9818		20 5f 98	jsr $985f			jsr 	ESTAShiftDigitIntoMantissa
.981b		ca		dex				dex
.981c		ee 07 04	inc $0407			inc 	DecimalCount 				; bump the count of decimals
.981f		ad 07 04	lda $0407			lda 	DecimalCount 				; too many decimal digits.
.9822		c9 0b		cmp #$0b			cmp 	#11
.9824		f0 02		beq $9828			beq 	_ESTADSFail
.9826		38		sec				sec
.9827		60		rts				rts
.9828						_ESTADSFail:
.9828		4c fb 9f	jmp $9ffb			jmp 	RangeError
.982b						_ENConstructFinal:
.982b		ad 07 04	lda $0407			lda 	DecimalCount 				; get decimal count
.982e		f0 2d		beq $985d			beq 	_ENCFExit 					; no decimals
.9830		5a		phy				phy
.9831		0a		asl a				asl 	a 							; x 4 and CLC
.9832		0a		asl a				asl 	a
.9833		6d 07 04	adc $0407			adc 	DecimalCount
.9836		a8		tay				tay
.9837		b9 ba 9f	lda $9fba,y			lda 	DecimalScalarTable-5,y 		; copy decimal scalar to X+2
.983a		95 5a		sta $5a,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.983c		b9 bb 9f	lda $9fbb,y			lda 	DecimalScalarTable-5+1,y
.983f		95 62		sta $62,x			sta 	NSMantissa1+2,x
.9841		b9 bc 9f	lda $9fbc,y			lda 	DecimalScalarTable-5+2,y
.9844		95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.9846		b9 bd 9f	lda $9fbd,y			lda 	DecimalScalarTable-5+3,y
.9849		95 72		sta $72,x			sta 	NSMantissa3+2,x
.984b		b9 be 9f	lda $9fbe,y			lda 	DecimalScalarTable-5+4,y
.984e		95 7a		sta $7a,x			sta 	NSExponent+2,x
.9850		a9 08		lda #$08			lda 	#NSTFloat
.9852		95 52		sta $52,x			sta 	NSStatus+2,x
.9854		7a		ply				ply
.9855		e8		inx				inx 								; multiply decimal const by decimal scalar
.9856		20 e5 95	jsr $95e5			jsr 	FloatMultiply
.9859		ca		dex				dex
.985a		20 a0 94	jsr $94a0			jsr 	FloatAdd 					; add to integer part.
.985d						_ENCFExit:
.985d		18		clc				clc 								; reject the digit.
.985e		60		rts				rts
.985f						ESTAShiftDigitIntoMantissa:
.985f		29 0f		and #$0f			and 	#15 						; save digit
.9861		48		pha				pha
.9862		b5 70		lda $70,x			lda 	NSMantissa3,x 				; push mantissa on stack
.9864		48		pha				pha
.9865		b5 68		lda $68,x			lda 	NSMantissa2,x
.9867		48		pha				pha
.9868		b5 60		lda $60,x			lda 	NSMantissa1,x
.986a		48		pha				pha
.986b		b5 58		lda $58,x			lda 	NSMantissa0,x
.986d		48		pha				pha
.986e		20 87 9e	jsr $9e87			jsr 	NSMShiftLeft 				; x 2
.9871		20 87 9e	jsr $9e87			jsr 	NSMShiftLeft 				; x 4
.9874		18		clc				clc 								; pop mantissa and add
.9875		68		pla				pla
.9876		75 58		adc $58,x			adc 	NSMantissa0,x
.9878		95 58		sta $58,x			sta 	NSMantissa0,x
.987a		68		pla				pla
.987b		75 60		adc $60,x			adc 	NSMantissa1,x
.987d		95 60		sta $60,x			sta 	NSMantissa1,x
.987f		68		pla				pla
.9880		75 68		adc $68,x			adc 	NSMantissa2,x
.9882		95 68		sta $68,x			sta 	NSMantissa2,x
.9884		68		pla				pla
.9885		75 70		adc $70,x			adc 	NSMantissa3,x
.9887		95 70		sta $70,x			sta 	NSMantissa3,x 				; x 5
.9889		20 87 9e	jsr $9e87			jsr 	NSMShiftLeft 				; x 10
.988c		68		pla				pla 								; add digit
.988d		18		clc				clc
.988e		75 58		adc $58,x			adc 	NSMantissa0,x
.9890		95 58		sta $58,x			sta 	NSMantissa0,x
.9892		90 0a		bcc $989e			bcc 	_ESTASDExit
.9894		f6 60		inc $60,x			inc 	NSMantissa1,x
.9896		d0 06		bne $989e			bne 	_ESTASDExit
.9898		f6 68		inc $68,x			inc 	NSMantissa2,x
.989a		d0 02		bne $989e			bne 	_ESTASDExit
.989c		f6 70		inc $70,x			inc 	NSMantissa3,x
.989e						_ESTASDExit:
.989e		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/term.asm

.989f						EvaluateTerm:
.989f		b1 30		lda ($30),y			lda 	(codePtr),y
.98a1		30 18		bmi $98bb			bmi 	_ETCheckUnary 				; unary function ? (text ones)
.98a3		c9 40		cmp #$40			cmp 	#$40 						; 40-7F => identifier reference
.98a5		b0 6c		bcs $9913			bcs 	_ETVariable
.98a7		c9 30		cmp #$30			cmp 	#'0' 						; is it a number
.98a9		90 6b		bcc $9916			bcc 	_ETPuncUnary 				; if not it might be a punctuation unary.
.98ab		c9 3a		cmp #$3a			cmp 	#'9'+1
.98ad		b0 67		bcs $9916			bcs 	_ETPuncUnary
.98af		20 97 97	jsr $9797			jsr 	EncodeNumberStart 			; can't fail as it's 0-9 !
.98b2						_ETNumber:
.98b2		c8		iny				iny 								; keep encoding until we have the numbers
.98b3		b1 30		lda ($30),y			lda 	(codePtr),y
.98b5		20 9a 97	jsr $979a			jsr 	EncodeNumberContinue
.98b8		b0 f8		bcs $98b2			bcs 	_ETNumber 					; go back if accepted.
.98ba		60		rts				rts
.98bb						_ETCheckUnary:
.98bb		c9 ff		cmp #$ff			cmp 	#KWC_STRING 				; string token
.98bd		f0 3f		beq $98fe			beq 	_ETString
.98bf		c9 fe		cmp #$fe			cmp 	#KWC_HEXCONST 				; hex constant.
.98c1		f0 12		beq $98d5			beq 	_ETHexConstant
.98c3		c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; check it actually is a unary function
.98c5		90 0b		bcc $98d2			bcc 	_ETSyntaxError
.98c7		c9 a2		cmp #$a2			cmp 	#KWC_LAST_UNARY+1
.98c9		b0 07		bcs $98d2			bcs 	_ETSyntaxError
.98cb		da		phx				phx 								; push X on the stack
.98cc		0a		asl a				asl 	a 							; put vector x 2 into X
.98cd		aa		tax				tax
.98ce		c8		iny				iny 								; consume unary function token
.98cf		7c e8 8c	jmp ($8ce8,x)			jmp 	(VectorSet0,x) 				; and do it.
.98d2						_ETSyntaxError:
.98d2		4c f6 9f	jmp $9ff6			jmp 	SyntaxError
.98d5						_ETHexConstant:
.98d5		c8		iny				iny 								; skip #
.98d6		c8		iny				iny 								; skip count
.98d7		20 78 9e	jsr $9e78			jsr 	NSMSetZero 					; clear result
.98da						_ETHLoop:
.98da		b1 30		lda ($30),y			lda 	(codePtr),y
.98dc		c8		iny				iny 								; and consume
.98dd		c9 00		cmp #$00			cmp 	#0 							; exit if zero
.98df		f0 1c		beq $98fd			beq 	_ETHExit
.98e1		48		pha				pha 								; save on stack.
.98e2		20 87 9e	jsr $9e87			jsr 	NSMShiftLeft 				; x 2
.98e5		20 87 9e	jsr $9e87			jsr 	NSMShiftLeft 				; x 4
.98e8		20 87 9e	jsr $9e87			jsr 	NSMShiftLeft 				; x 8
.98eb		20 87 9e	jsr $9e87			jsr 	NSMShiftLeft 				; x 16
.98ee		68		pla				pla 								; ASCII
.98ef		c9 41		cmp #$41			cmp 	#'A'
.98f1		90 02		bcc $98f5			bcc 	_ETHNotChar
.98f3		e9 07		sbc #$07			sbc 	#7
.98f5						_ETHNotChar:
.98f5		29 0f		and #$0f			and 	#15 						; digit now
.98f7		15 58		ora $58,x			ora 	NSMantissa0,x 				; put in LS Nibble
.98f9		95 58		sta $58,x			sta 	NSMantissa0,x
.98fb		80 dd		bra $98da			bra 	_ETHLoop 					; go round.
.98fd						_ETHExit:
.98fd		60		rts				rts
.98fe						_ETString:
.98fe		c8		iny				iny 								; look at length
.98ff		b1 30		lda ($30),y			lda 	(codePtr),y
.9901		48		pha				pha
.9902		c8		iny				iny 								; first character
.9903		20 e3 a5	jsr $a5e3			jsr 	MemoryInline 				; put address of string at (code-Ptr),y on stack
.9906		68		pla				pla 								; restore count and save
.9907		85 36		sta $36				sta 	zTemp0
.9909		98		tya				tya 								; add length to Y to skip it.
.990a		18		clc				clc
.990b		65 36		adc $36				adc 	zTemp0
.990d		a8		tay				tay
.990e		a9 10		lda #$10			lda 	#NSTString 					; mark as string
.9910		95 50		sta $50,x			sta 	NSStatus,x
.9912		60		rts				rts
.9913						_ETVariable:
.9913		4c 68 99	jmp $9968			jmp 	VariableHandler
.9916						_ETPuncUnary:
.9916		c8		iny				iny 								; consume the unary character
.9917		c9 2d		cmp #$2d			cmp 	#KWD_MINUS 					; unary minus
.9919		f0 2b		beq $9946			beq 	_ETUnaryNegate
.991b		c9 10		cmp #$10			cmp 	#KWD_AT 					; @ reference -> constant
.991d		f0 36		beq $9955			beq 	_ETDereference
.991f		c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; parenthesis
.9921		f0 3e		beq $9961			beq 	_ETParenthesis
.9923		64 36		stz $36				stz 	zTemp0 						; zTemp0 is the indirection level.
.9925		c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; byte indirection (0) ?
.9927		f0 06		beq $992f			beq 	_ETIndirection
.9929		e6 36		inc $36				inc 	zTemp0
.992b		c9 21		cmp #$21			cmp 	#KWD_PLING					; word indirection (1) \
.992d		d0 a3		bne $98d2			bne 	_ETSyntaxError
.992f						_ETIndirection:
.992f		a5 36		lda $36				lda 	zTemp0 						; push indirection amount (0-1) => (1-2) on the stack
.9931		1a		inc a				inc 	a
.9932		48		pha				pha
.9933		20 9f 98	jsr $989f			jsr 	EvaluateTerm				; evaluate the term
.9936		20 18 97	jsr $9718			jsr 	Dereference 				; dereference it.
.9939		b5 50		lda $50,x			lda 	NSStatus,x 					; must be a +ve integer.
.993b		d0 06		bne $9943			bne 	_ETTypeMismatch
.993d		68		pla				pla 								; indirection 1-2
.993e		09 20		ora #$20			ora 	#NSBIsReference 			; make it a reference.
.9940		95 50		sta $50,x			sta 	NSStatus,x
.9942		60		rts				rts
.9943						_ETTypeMismatch:
.9943		4c 00 a0	jmp $a000			jmp 	TypeError
.9946						_ETUnaryNegate:
.9946		20 9f 98	jsr $989f			jsr 	EvaluateTerm				; evaluate the term
.9949		20 18 97	jsr $9718			jsr 	Dereference 				; dereference it.
.994c		b5 50		lda $50,x			lda 	NSStatus,x 					; must be a number
.994e		29 10		and #$10			and 	#NSTString
.9950		d0 f1		bne $9943			bne 	_ETTypeMismatch
.9952		4c 3a 9e	jmp $9e3a			jmp 	NSMNegate  					; just toggles the sign bit.
.9955						_ETDereference:
.9955		20 9f 98	jsr $989f			jsr 	EvaluateTerm				; evaluate the term
.9958		b5 50		lda $50,x			lda 	NSStatus,x 					; must be a reference
.995a		29 20		and #$20			and 	#NSBIsReference
.995c		f0 e5		beq $9943			beq 	_ETTypeMismatch
.995e		74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer address
.9960		60		rts				rts
.9961						_ETParenthesis:
.9961		20 55 94	jsr $9455			jsr 	EvaluateExpression 			; evaluate here, from lowest precedence
.9964		20 38 8f	jsr $8f38			jsr 	CheckRightBracket 			; check for )
.9967		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/variable.asm

.9968						VariableHandler:
.9968		b1 30		lda ($30),y			lda 	(codePtr),y
.996a		18		clc				clc
.996b		69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.996d		85 37		sta $37				sta 	zTemp0+1
.996f		c8		iny				iny
.9970		b1 30		lda ($30),y			lda 	(codePtr),y
.9972		85 36		sta $36				sta 	zTemp0
.9974		c8		iny				iny
.9975		18		clc				clc									; copy variable address+3 to mantissa
.9976		69 03		adc #$03			adc 	#3 							; this is the address of the data.
.9978		95 58		sta $58,x			sta 	NSMantissa0,x
.997a		a5 37		lda $37				lda 	zTemp0+1
.997c		69 00		adc #$00			adc 	#0
.997e		95 60		sta $60,x			sta 	NSMantissa1,x
.9980		74 68		stz $68,x			stz 	NSMantissa2,x
.9982		74 70		stz $70,x			stz 	NSMantissa3,x
.9984		74 78		stz $78,x			stz 	NSExponent,x
.9986		5a		phy				phy
.9987		a0 02		ldy #$02			ldy 	#2 							; read type
.9989		b1 36		lda ($36),y			lda 	(zTemp0),y
.998b		7a		ply				ply
.998c		29 1c		and #$1c			and 	#NSBTypeMask+NSBIsArray 	; get type information
.998e		09 20		ora #$20			ora 	#NSBIsReference 			; make a reference.
.9990		95 50		sta $50,x			sta 	NSStatus,x
.9992		29 04		and #$04			and 	#NSBIsArray
.9994		d0 01		bne $9997			bne 	_VHArray
.9996		60		rts				rts
.9997						_VHArray:
.9997		e8		inx				inx
.9998		20 13 9e	jsr $9e13			jsr 	Evaluate8BitInteger 		; get the 1st index.
.999b		a9 ff		lda #$ff			lda 	#$FF 						; set Status of X+2 to a duff value so we know if we picked it up.
.999d		95 51		sta $51,x			sta 	NSStatus+1,x
.999f		b1 30		lda ($30),y			lda 	(codePtr),y
.99a1		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.99a3		d0 06		bne $99ab			bne 	_VHNoSecondIndex
.99a5		c8		iny				iny 								; skip the comma
.99a6		e8		inx				inx
.99a7		20 13 9e	jsr $9e13			jsr 	Evaluate8BitInteger 		; get the 2nd index.
.99aa		ca		dex				dex
.99ab						_VHNoSecondIndex:
.99ab		ca		dex				dex 								; set X back.
.99ac		20 38 8f	jsr $8f38			jsr 	CheckRightBracket 			; and check the right bracket.
.99af		5a		phy				phy 								; save position
.99b0		b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy record address to zaTemp (moved 6/12/22)
.99b2		85 3e		sta $3e				sta 	zaTemp
.99b4		b5 60		lda $60,x			lda 	NSMantissa1,x
.99b6		85 3f		sta $3f				sta 	zaTemp+1
.99b8		a0 02		ldy #$02			ldy 	#2 							; check first index is not-zero, e.g. array defined
.99ba		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99bc		f0 5d		beq $9a1b			beq 	_VHBadArray
.99be		a0 03		ldy #$03			ldy 	#3 							; get the second index - which is 0 if there is one index.
.99c0		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99c2		f0 02		beq $99c6			beq 	_VHHas2Mask
.99c4		a9 ff		lda #$ff			lda 	#$FF
.99c6						_VHHas2Mask:
.99c6		d5 52		cmp $52,x			cmp 	NSStatus+2,x 				; so if they are the same there are the wrong number of indices
.99c8		f0 4c		beq $9a16			beq 	_VHBadIndex
.99ca		0a		asl a				asl 	a 							; carry will be set if a second index
.99cb		90 08		bcc $99d5			bcc 	_VHCheckFirstIndex
.99cd		a0 03		ldy #$03			ldy 	#3 			 				; check the 2nd size >= 2nd index
.99cf		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99d1		d5 5a		cmp $5a,x			cmp 	NSMantissa0+2,x
.99d3		90 41		bcc $9a16			bcc 	_VHBadIndex
.99d5						_VHCheckFirstIndex:
.99d5		a0 02		ldy #$02			ldy 	#2 			 				; check the 2nd size >= 2nd index
.99d7		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99d9		d5 59		cmp $59,x			cmp 	NSMantissa0+1,x
.99db		90 39		bcc $9a16			bcc 	_VHBadIndex
.99dd		64 36		stz $36				stz 	zTemp0 						; clear zTemp0 (if 1 index)
.99df		64 37		stz $37				stz 	zTemp0+1
.99e1		b5 52		lda $52,x			lda 	NSStatus+2,x 				; if only one index provided, don't need to multiply
.99e3		30 0e		bmi $99f3			bmi 	_VHNoMultiply
.99e5		da		phx				phx
.99e6		b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; get 2nd index on stack
.99e8		48		pha				pha
.99e9		a0 02		ldy #$02			ldy 	#2 							; get 1st size in A
.99eb		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99ed		1a		inc a				inc 	a 							; add 1 for zero base
.99ee		fa		plx				plx
.99ef		20 23 9e	jsr $9e23			jsr 	Multiply8x8 				; calculate -> Z0
.99f2		fa		plx				plx
.99f3						_VHNoMultiply:
.99f3		18		clc				clc
.99f4		a5 36		lda $36				lda 	zTemp0
.99f6		75 59		adc $59,x			adc 	NSMantissa0+1,x
.99f8		85 36		sta $36				sta 	zTemp0
.99fa		a5 37		lda $37				lda 	zTemp0+1
.99fc		69 00		adc #$00			adc 	#0
.99fe		85 37		sta $37				sta 	zTemp0+1
.9a00		b5 50		lda $50,x			lda 	NSStatus,x
.9a02		20 c8 85	jsr $85c8			jsr 	ScaleByBaseType
.9a05		18		clc				clc
.9a06		b2 3e		lda ($3e)			lda 	(zaTemp)
.9a08		65 36		adc $36				adc 	zTemp0
.9a0a		95 58		sta $58,x			sta 	NSMantissa0,x
.9a0c		a0 01		ldy #$01			ldy 	#1
.9a0e		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9a10		65 37		adc $37				adc 	zTemp0+1
.9a12		95 60		sta $60,x			sta 	NSMantissa1,x
.9a14		7a		ply				ply 								; restore position
.9a15		60		rts				rts
.9a16						_VHBadIndex:
.9a16		a9 17		lda #$17		lda	#23
.9a18		4c 51 8f	jmp $8f51		jmp	ErrorHandler
.9a1b						_VHBadArray:
.9a1b		a9 18		lda #$18		lda	#24
.9a1d		4c 51 8f	jmp $8f51		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/abs.asm

.9a20						AbsUnary:
.9a20		fa		plx				plx 								; restore stack pos
.9a21		20 c6 9d	jsr $9dc6			jsr 	EvaluateNumber 				; get a float or int
.9a24		20 38 8f	jsr $8f38			jsr 	CheckRightBracket
.9a27		b5 50		lda $50,x			lda 	NSStatus,x 					; clear the sign bit
.9a29		29 7f		and #$7f			and 	#$7F
.9a2b		95 50		sta $50,x			sta 	NSStatus,x
.9a2d		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/alloc.asm

.9a2e						AllocUnary:
.9a2e		fa		plx				plx 								; restore stack pos
.9a2f		20 f8 9d	jsr $9df8			jsr 	Evaluate16BitInteger		; get bytes required.
.9a32		20 38 8f	jsr $8f38			jsr 	CheckRightBracket
.9a35		da		phx				phx 								; save X/Y
.9a36		5a		phy				phy
.9a37		8a		txa				txa 								; copy X into Y
.9a38		a8		tay				tay
.9a39		b9 60 00	lda $0060,y			lda		NSMantissa1,y 				; get size into XA
.9a3c		aa		tax				tax
.9a3d		b9 58 00	lda $0058,y			lda 	NSMantissa0,y
.9a40		20 4d 9a	jsr $9a4d			jsr 	AllocateXABytes 			; allocate memory
.9a43		99 58 00	sta $0058,y			sta 	NSMantissa0,y 				; write address out.
.9a46		8a		txa				txa 	 							; typing is 16 bit integer.
.9a47		99 60 00	sta $0060,y			sta 	NSMantissa1,y
.9a4a		7a		ply				ply
.9a4b		fa		plx				plx
.9a4c		60		rts				rts
.9a4d						AllocateXABytes:
.9a4d		5a		phy				phy
.9a4e		ac 0c 04	ldy $040c			ldy 	lowMemPtr 					; push current address on stack and to zTemp0
.9a51		84 36		sty $36				sty 	zTemp0
.9a53		5a		phy				phy
.9a54		ac 0d 04	ldy $040d			ldy 	lowMemPtr+1
.9a57		84 37		sty $37				sty 	zTemp0+1
.9a59		5a		phy				phy
.9a5a		18		clc				clc 								; add to low memory pointer
.9a5b		6d 0c 04	adc $040c			adc 	lowMemPtr
.9a5e		8d 0c 04	sta $040c			sta 	lowMemPtr
.9a61		8a		txa				txa
.9a62		6d 0d 04	adc $040d			adc 	lowMemPtr+1
.9a65		8d 0d 04	sta $040d			sta 	lowMemPtr+1
.9a68		b0 2f		bcs $9a99			bcs 	CISSMemory
.9a6a		20 8b 9a	jsr $9a8b			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.9a6d						_ClearMemory:
.9a6d		ad 0c 04	lda $040c			lda 	lowMemPtr 					; cleared all memory allocated
.9a70		c5 36		cmp $36				cmp 	zTemp0
.9a72		d0 07		bne $9a7b			bne 	_CMClearNext
.9a74		ad 0d 04	lda $040d			lda 	lowMemPtr+1
.9a77		c5 37		cmp $37				cmp 	zTemp0+1
.9a79		f0 0c		beq $9a87			beq 	_CMExit
.9a7b						_CMClearNext:
.9a7b		a9 00		lda #$00			lda 	#0 							; clear byte, advance to next.
.9a7d		92 36		sta ($36)			sta 	(zTemp0)
.9a7f		e6 36		inc $36				inc 	zTemp0
.9a81		d0 ea		bne $9a6d			bne 	_ClearMemory
.9a83		e6 37		inc $37				inc		zTemp0+1
.9a85		80 e6		bra $9a6d			bra 	_ClearMemory
.9a87						_CMExit:
.9a87		fa		plx				plx
.9a88		68		pla				pla
.9a89		7a		ply				ply
.9a8a		60		rts				rts
.9a8b						CheckIdentifierStringSpace:
.9a8b		48		pha				pha
.9a8c		ad 0d 04	lda $040d			lda 	lowMemPtr+1 				; get low memory pointer
.9a8f		18		clc				clc
.9a90		69 02		adc #$02			adc 	#2 							; need at least 2 256 byte pages
.9a92		cd 0f 04	cmp $040f			cmp 	StringMemory+1 				; is it >= StringMemory
.9a95		b0 02		bcs $9a99			bcs 	CISSMemory
.9a97		68		pla				pla
.9a98		60		rts				rts
.9a99						CISSMemory:
.9a99		a9 06		lda #$06		lda	#6
.9a9b		4c 51 8f	jmp $8f51		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/asc.asm

.9a9e						AscUnary:
.9a9e		fa		plx				plx 								; restore stack pos
.9a9f		20 d0 9d	jsr $9dd0			jsr 	EvaluateString 				; get a string
.9aa2		b2 36		lda ($36)			lda 	(zTemp0)					; get/return first character
.9aa4		20 7a 9e	jsr $9e7a			jsr 	NSMSetByte 					; ASC("") will return zero.
.9aa7		20 38 8f	jsr $8f38			jsr 	CheckRightBracket
.9aaa		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/deekpeek.asm

.9aab						PeekUnary:
.9aab		18		clc				clc
.9aac		80 01		bra $9aaf			bra 	DPUnary
.9aae						DeekUnary:
.9aae		38		sec				sec
.9aaf						DPUnary:
.9aaf		fa		plx				plx 								; restore position.
.9ab0		08		php				php									; save on stack, CS = Deek, CC = Peek
.9ab1		20 f8 9d	jsr $9df8			jsr		Evaluate16BitInteger 		; address as constant.
.9ab4		20 38 8f	jsr $8f38			jsr 	CheckRightBracket
.9ab7		28		plp				plp 								; function back.
.9ab8		a9 21		lda #$21			lda 	#NSBIsReference+NSTInteger+1 ; 1 byte read
.9aba		90 01		bcc $9abd			bcc 	_DPUpdate
.9abc		1a		inc a				inc 	a 							; 2 byte read
.9abd						_DPUpdate:
.9abd		95 50		sta $50,x			sta 	NSStatus,x 					; set to 1/2 byte reference.
.9abf		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/frac.asm

.9ac0						FracUnary:
.9ac0		fa		plx				plx 								; restore stack pos
.9ac1		20 c6 9d	jsr $9dc6			jsr 	EvaluateNumber 				; get a float or int
.9ac4		20 38 8f	jsr $8f38			jsr 	CheckRightBracket
.9ac7		b5 50		lda $50,x			lda 	NSStatus,x
.9ac9		29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9acb		f0 04		beq $9ad1			beq 	_IUZero
.9acd		20 66 95	jsr $9566			jsr 	FloatFractionalPart 		; if so, get the fractional part.
.9ad0		60		rts				rts
.9ad1						_IUZero:
.9ad1		20 78 9e	jsr $9e78			jsr 	NSMSetZero
.9ad4		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/int.asm

.9ad5						IntUnary:
.9ad5		fa		plx				plx 								; restore stack pos
.9ad6		20 c6 9d	jsr $9dc6			jsr 	EvaluateNumber 				; get a float or int
.9ad9		20 38 8f	jsr $8f38			jsr 	CheckRightBracket
.9adc		b5 50		lda $50,x			lda 	NSStatus,x
.9ade		29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9ae0		f0 03		beq $9ae5			beq 	_IUExit
.9ae2		20 be 95	jsr $95be			jsr 	FloatIntegerPart 			; if it is get the integer part.
.9ae5						_IUExit:
.9ae5		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/len.asm

.9ae6						LenUnary:
.9ae6		fa		plx				plx 								; restore stack pos
.9ae7		20 d0 9d	jsr $9dd0			jsr 	EvaluateString 				; get a string
.9aea		5a		phy				phy
.9aeb		a0 00		ldy #$00			ldy 	#0 							; find length
.9aed						_LenFind:
.9aed		b1 36		lda ($36),y			lda 	(zTemp0),y 					; look for trailing NULL.
.9aef		f0 06		beq $9af7			beq 	_LenExit
.9af1		c8		iny				iny
.9af2		d0 f9		bne $9aed			bne 	_LenFind
.9af4		4c fb 9f	jmp $9ffb			jmp 	RangeError 					; string > 255 - no trailing NULL.
.9af7						_LenExit:
.9af7		98		tya				tya		 							; return length
.9af8		20 7a 9e	jsr $9e7a			jsr 	NSMSetByte
.9afb		7a		ply				ply
.9afc		20 38 8f	jsr $8f38			jsr 	CheckRightBracket
.9aff		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/minmax.asm

.9b00						Unary_Min:
.9b00		a9 01		lda #$01			lda 	#1
.9b02		80 02		bra $9b06			bra 	UnaryMinMaxMain
.9b04						Unary_Max:
.9b04		a9 ff		lda #$ff			lda 	#$FF 						; value from comparator to cause a write
.9b06						UnaryMinMaxMain:
.9b06		fa		plx				plx 								; get index on number stack
.9b07		48		pha				pha 								; save comparator
.9b08		20 bd 9d	jsr $9dbd			jsr 	EvaluateValue 				; get the first value.
.9b0b						_UMMMLoop:
.9b0b		b1 30		lda ($30),y			lda 	(codePtr),y
.9b0d		c9 29		cmp #$29			cmp 	#KWD_RPAREN 				; if right bracket then done.
.9b0f		f0 22		beq $9b33			beq 	_UMMMDone
.9b11		20 40 8f	jsr $8f40			jsr 	CheckComma 					; must be a comma
.9b14		e8		inx				inx
.9b15		20 bd 9d	jsr $9dbd			jsr 	EvaluateValue
.9b18		ca		dex				dex
.9b19		20 5b 9e	jsr $9e5b			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] (Compare is destructive)
.9b1c		e8		inx				inx
.9b1d		20 5b 9e	jsr $9e5b			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2], original
.9b20		e8		inx				inx
.9b21		20 08 90	jsr $9008			jsr 	CompareBaseCode 			; part of > = < etc. code, returns 255,0 or 1
.9b24		ca		dex				dex
.9b25		ca		dex				dex
.9b26		85 36		sta $36				sta 	zTemp0 						; save required result
.9b28		68		pla				pla 								; get and save comparator
.9b29		48		pha				pha
.9b2a		c5 36		cmp $36				cmp 	zTemp0 						; if the comparator
.9b2c		d0 dd		bne $9b0b			bne 	_UMMMLoop
.9b2e		20 36 9b	jsr $9b36			jsr 	ExpCopyAboveDown 			; copy next up slot down
.9b31		80 d8		bra $9b0b			bra 	_UMMMLoop
.9b33						_UMMMDone:
.9b33		68		pla				pla 								; throw the comparator
.9b34		c8		iny				iny 								; skip )
.9b35		60		rts				rts
.9b36						ExpCopyAboveDown:
.9b36		b5 51		lda $51,x			lda 	NSStatus+1,x
.9b38		95 50		sta $50,x			sta 	NSStatus,x
.9b3a		b5 79		lda $79,x			lda 	NSExponent+1,x
.9b3c		95 78		sta $78,x			sta 	NSExponent,x
.9b3e		b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9b40		95 58		sta $58,x			sta 	NSMantissa0,x
.9b42		b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9b44		95 60		sta $60,x			sta 	NSMantissa1,x
.9b46		b5 69		lda $69,x			lda 	NSMantissa2+1,x
.9b48		95 68		sta $68,x			sta 	NSMantissa2,x
.9b4a		b5 71		lda $71,x			lda 	NSMantissa3+1,x
.9b4c		95 70		sta $70,x			sta 	NSMantissa3,x
.9b4e		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/not.asm

.9b4f						Unary_Not:
.9b4f		fa		plx				plx
.9b50		20 e5 9d	jsr $9de5			jsr 	EvaluateInteger 			; get integer
.9b53		20 38 8f	jsr $8f38			jsr 	CheckRightBracket
.9b56		20 9a 9e	jsr $9e9a			jsr 	NSMIsZero 					; zero mantissa ?
.9b59		f0 04		beq $9b5f			beq 	_NotZero
.9b5b		20 78 9e	jsr $9e78			jsr 	NSMSetZero
.9b5e		60		rts				rts
.9b5f						_NotZero:
.9b5f		4c be 8f	jmp $8fbe			jmp 	ReturnTrue

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/rnd.asm

.9b62						Unary_Random:
.9b62		fa		plx				plx
.9b63		20 d4 9b	jsr $9bd4			jsr 	Random32Bit 				; get a random number
.9b66		20 bd 9b	jsr $9bbd			jsr 	URCopyToMantissa  			; put in mantissa
.9b69		b1 30		lda ($30),y			lda 	(codePtr),y
.9b6b		c9 29		cmp #$29			cmp 	#KWD_RPAREN
.9b6d		f0 08		beq $9b77			beq 	_URNoModulus 				; then we return a random 30 bit number.
.9b6f		e8		inx				inx
.9b70		20 f8 9d	jsr $9df8			jsr 	Evaluate16BitInteger 		; put modulus value in +1
.9b73		ca		dex				dex
.9b74		20 10 91	jsr $9110			jsr 	IntegerModulusNoCheck 		; calculate modulus, so now 0 .. n-1
.9b77						_URNoModulus:
.9b77		74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer positive
.9b79		74 78		stz $78,x			stz 	NSExponent,x
.9b7b		20 38 8f	jsr $8f38			jsr 	CheckRightBracket
.9b7e		60		rts				rts
.9b7f						Unary_Rnd:
.9b7f		fa		plx				plx
.9b80		20 c6 9d	jsr $9dc6			jsr 	EvaluateNumber 				; number to use.
.9b83		20 38 8f	jsr $8f38			jsr 	CheckRightBracket 			; closing bracket
.9b86		20 9a 9e	jsr $9e9a			jsr 	NSMIsZero 					; if zero, then don't generate a new number
.9b89		f0 26		beq $9bb1			beq 	_URCopySeed
.9b8b		b5 50		lda $50,x			lda 	NSStatus,x 					; if -ve, then seed using parameter
.9b8d		10 1f		bpl $9bae			bpl 	_URDontSeed
.9b8f		b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy - value to seed butchering it.
.9b91		49 17		eor #$17			eor 	#$17
.9b93		8d 08 04	sta $0408			sta 	RandomSeed+0
.9b96		b5 60		lda $60,x			lda 	NSMantissa1,x
.9b98		49 a5		eor #$a5			eor 	#$A5
.9b9a		8d 09 04	sta $0409			sta 	RandomSeed+1
.9b9d		b5 68		lda $68,x			lda 	NSMantissa2,x
.9b9f		49 c2		eor #$c2			eor 	#$C2
.9ba1		8d 0a 04	sta $040a			sta 	RandomSeed+2
.9ba4		b5 70		lda $70,x			lda 	NSMantissa3,x
.9ba6		49 9d		eor #$9d			eor 	#$9D
.9ba8		8d 0b 04	sta $040b			sta 	RandomSeed+3
.9bab		20 d4 9b	jsr $9bd4			jsr 	Random32Bit
.9bae						_URDontSeed:
.9bae		20 d4 9b	jsr $9bd4			jsr 	Random32Bit 				; generate a number
.9bb1						_URCopySeed:
.9bb1		20 bd 9b	jsr $9bbd			jsr 	URCopyToMantissa 			; copy into mantissa
.9bb4		a9 e2		lda #$e2			lda 	#-30 						; force into 0-1 range
.9bb6		95 78		sta $78,x			sta 	NSExponent,x
.9bb8		a9 08		lda #$08			lda 	#NSTFloat
.9bba		95 50		sta $50,x			sta 	NSStatus,x 					; positive float
.9bbc		60		rts				rts
.9bbd						URCopyToMantissa:
.9bbd		ad 08 04	lda $0408			lda 	RandomSeed+0
.9bc0		95 58		sta $58,x			sta 	NSMantissa0,x
.9bc2		ad 09 04	lda $0409			lda 	RandomSeed+1
.9bc5		95 60		sta $60,x			sta 	NSMantissa1,x
.9bc7		ad 0a 04	lda $040a			lda 	RandomSeed+2
.9bca		95 68		sta $68,x			sta 	NSMantissa2,x
.9bcc		ad 0b 04	lda $040b			lda 	RandomSeed+3
.9bcf		29 3f		and #$3f			and 	#$3F 						; make legal mantissa
.9bd1		95 70		sta $70,x			sta 	NSMantissa3,x
.9bd3		60		rts				rts
.9bd4						Random32Bit:
.9bd4		5a		phy				phy
.9bd5		a0 07		ldy #$07			ldy 	#7 							; do it 7 times
.9bd7		ad 08 04	lda $0408			lda 	RandomSeed+0 				; check the seed isn't zero
.9bda		d0 03		bne $9bdf			bne 	_Random1
.9bdc		a8		tay				tay 								; if so do it 256 times
.9bdd		a9 aa		lda #$aa			lda		#$AA 						; and use this to seed the seed....
.9bdf						_Random1:
.9bdf		0a		asl a				asl 	a 							; LSFR RNG
.9be0		2e 09 04	rol $0409			rol 	RandomSeed+1
.9be3		2e 0a 04	rol $040a			rol 	RandomSeed+2
.9be6		2e 0b 04	rol $040b			rol 	RandomSeed+3
.9be9		90 02		bcc $9bed			bcc 	_Random2
.9beb		49 c5		eor #$c5			eor 	#$C5
.9bed						_Random2:
.9bed		88		dey				dey
.9bee		d0 ef		bne $9bdf			bne 	_Random1
.9bf0		8d 08 04	sta $0408			sta 	RandomSeed+0
.9bf3		7a		ply				ply
.9bf4		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/sgn.asm

.9bf5						SgnUnary:
.9bf5		fa		plx				plx 								; restore stack pos
.9bf6		20 c6 9d	jsr $9dc6			jsr 	EvaluateNumber 				; get a float or int
.9bf9		20 38 8f	jsr $8f38			jsr 	CheckRightBracket
.9bfc		20 9a 9e	jsr $9e9a			jsr 	NSMIsZero 					; if zero
.9bff		f0 0e		beq $9c0f			beq 	_SGZero  					; return Int Zero
.9c01		b5 50		lda $50,x			lda 	NSStatus,x 					; get status w/sign
.9c03		48		pha				pha
.9c04		a9 01		lda #$01			lda 	#1 							; set to 1
.9c06		20 7a 9e	jsr $9e7a			jsr 	NSMSetByte
.9c09		68		pla				pla
.9c0a		29 80		and #$80			and		#$80 						; copy the sign byte out
.9c0c		95 50		sta $50,x			sta 	NSStatus,x  				; so it will be -1 or 1
.9c0e		60		rts				rts
.9c0f		20 78 9e	jsr $9e78	_SGZero:jsr 	NSMSetZero
.9c12		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/val.asm

.9c13						ValUnary:
.9c13		fa		plx				plx 								; restore stack pos
.9c14		20 29 9c	jsr $9c29			jsr 	ValMainCode 				; do the main val() code
.9c17		b0 01		bcs $9c1a			bcs 	_VUError 					; couldn't convert
.9c19		60		rts				rts
.9c1a						_VUError:
.9c1a		4c 00 a0	jmp $a000			jmp 	TypeError
.9c1d						IsValUnary:
.9c1d		fa		plx				plx 								; restore stack pos
.9c1e		20 29 9c	jsr $9c29			jsr 	ValMainCode 				; do the main val() code
.9c21		b0 03		bcs $9c26			bcs 	_VUBad
.9c23		4c be 8f	jmp $8fbe			jmp 	ReturnTrue
.9c26						_VUBad:
.9c26		4c c9 8f	jmp $8fc9			jmp 	ReturnFalse
.9c29						ValMainCode:
.9c29		20 d0 9d	jsr $9dd0			jsr 	EvaluateString 				; get a string
.9c2c		20 38 8f	jsr $8f38			jsr 	CheckRightBracket 			; check right bracket present
.9c2f						ValEvaluateZTemp0:
.9c2f		5a		phy				phy
.9c30		b2 36		lda ($36)			lda 	(zTemp0) 					; check not empty string
.9c32		f0 17		beq $9c4b			beq 	_VMCFail2
.9c34		a0 ff		ldy #$ff			ldy 	#$FF 						; start position
.9c36		48		pha				pha 								; save first character
.9c37		c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.9c39		d0 01		bne $9c3c			bne 	_VMCStart
.9c3b		c8		iny				iny 								; skip over -
.9c3c						_VMCStart:
.9c3c		38		sec				sec 								; initialise first time round.
.9c3d						_VMCNext:
.9c3d		c8		iny				iny 								; pre-increment
.9c3e		b1 36		lda ($36),y			lda 	(zTemp0),y 					; next character = EOS ?
.9c40		f0 0c		beq $9c4e			beq 	_VMCSuccess 				; successful.
.9c42		20 9b 97	jsr $979b			jsr 	EncodeNumber 				; send it to the number-builder
.9c45		90 03		bcc $9c4a			bcc 	_VMCFail 					; if failed, give up.
.9c47		18		clc				clc 								; next time round, countinue
.9c48		80 f3		bra $9c3d			bra 	_VMCNext
.9c4a						_VMCFail:
.9c4a		68		pla				pla
.9c4b						_VMCFail2:
.9c4b		7a		ply				ply
.9c4c		38		sec				sec
.9c4d		60		rts				rts
.9c4e						_VMCSuccess:
.9c4e		a9 00		lda #$00			lda 	#0 							; construct final
.9c50		20 9b 97	jsr $979b			jsr 	EncodeNumber 				; by sending a duff value.
.9c53		68		pla				pla 								; if it was -ve
.9c54		c9 2d		cmp #$2d			cmp 	#"-"
.9c56		d0 03		bne $9c5b			bne 	_VMCNotNegative
.9c58		20 3a 9e	jsr $9e3a			jsr		NSMNegate 					; negate it.
.9c5b						_VMCNotNegative:
.9c5b		7a		ply				ply
.9c5c		18		clc				clc
.9c5d		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/chr.asm

.9c5e						ChrUnary:
.9c5e		fa		plx				plx 								; restore stack pos
.9c5f		20 13 9e	jsr $9e13			jsr 	Evaluate8BitInteger			; get value (chr$(0) returns an empty string)
.9c62		48		pha				pha
.9c63		20 38 8f	jsr $8f38			jsr 	CheckRightBracket
.9c66		a9 01		lda #$01			lda 	#1 							; allocate space for one char
.9c68		20 0a a8	jsr $a80a			jsr 	StringTempAllocate
.9c6b		68		pla				pla 								; write number to it
.9c6c		20 43 a8	jsr $a843			jsr 	StringTempWrite
.9c6f		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/spc.asm

.9c70						SpcUnary:
.9c70		fa		plx				plx 								; restore stack pos
.9c71		20 13 9e	jsr $9e13			jsr 	Evaluate8BitInteger			; get value
.9c74		5a		phy				phy
.9c75		48		pha				pha 								; save count
.9c76		20 0a a8	jsr $a80a			jsr 	StringTempAllocate
.9c79		7a		ply				ply 								; to do count in Y
.9c7a						_SpcLoop:
.9c7a		c0 00		cpy #$00			cpy 	#0 							; copy Y spaces in.
.9c7c		f0 08		beq $9c86			beq 	_SpcExit
.9c7e		a9 20		lda #$20			lda 	#32
.9c80		20 43 a8	jsr $a843			jsr 	StringTempWrite
.9c83		88		dey				dey
.9c84		80 f4		bra $9c7a			bra 	_SPCLoop
.9c86						_SpcExit:
.9c86		7a		ply				ply
.9c87		20 38 8f	jsr $8f38			jsr 	CheckRightBracket
.9c8a		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/str.asm

.9c8b						Unary_Str:
.9c8b		fa		plx				plx
.9c8c		20 c6 9d	jsr $9dc6			jsr 	EvaluateNumber  			; get number
.9c8f		20 38 8f	jsr $8f38			jsr 	CheckRightBracket 			; closing bracket
.9c92		a9 05		lda #$05			lda 	#5 							; maximum decimals, from Basic816
.9c94		20 ad 9c	jsr $9cad			jsr 	ConvertNumberToString 		; do the conversion.
.9c97		a9 21		lda #$21			lda		#33 						; create buffer
.9c99		20 0a a8	jsr $a80a			jsr 	StringTempAllocate 			; allocate memory
.9c9c		da		phx				phx  								; copy the converted string into the buffer.
.9c9d		a2 00		ldx #$00			ldx 	#0
.9c9f						_USCopy:
.9c9f		bd 49 06	lda $0649,x			lda 	DecimalBuffer,x
.9ca2		20 43 a8	jsr $a843			jsr 	StringTempWrite
.9ca5		e8		inx				inx
.9ca6		bd 49 06	lda $0649,x			lda 	DecimalBuffer,x
.9ca9		d0 f4		bne $9c9f			bne 	_USCopy
.9cab		fa		plx				plx
.9cac		60		rts				rts
.9cad						ConvertNumberToString:
.9cad		5a		phy				phy 								; save code position
.9cae		8d 14 04	sta $0414			sta 	DecimalPlaces	 			; save number of DPs.
.9cb1		9c 15 04	stz $0415			stz 	dbOffset 					; offset into decimal buffer = start.
.9cb4		b5 50		lda $50,x			lda 	NSStatus,x  				; is it -ve.
.9cb6		10 09		bpl $9cc1			bpl 	_CNTSNotNegative
.9cb8		29 7f		and #$7f			and 	#$7F 						; make +ve
.9cba		95 50		sta $50,x			sta 	NSStatus,x
.9cbc		a9 2d		lda #$2d			lda 	#"-"
.9cbe		20 22 9d	jsr $9d22			jsr 	WriteDecimalBuffer
.9cc1						_CNTSNotNegative:
.9cc1		b5 78		lda $78,x			lda 	NSExponent,x 				; check if decimal
.9cc3		f0 12		beq $9cd7			beq 	_CNTSNotFloat
.9cc5		e8		inx				inx 								; round up so we don't get too many 6.999999
.9cc6		a9 01		lda #$01			lda 	#1
.9cc8		20 7a 9e	jsr $9e7a			jsr 	NSMSetByte
.9ccb		ca		dex				dex
.9ccc		b5 78		lda $78,x			lda		NSExponent,x
.9cce		95 79		sta $79,x			sta 	NSExponent+1,x
.9cd0		a9 08		lda #$08			lda 	#NSTFloat
.9cd2		95 51		sta $51,x			sta 	NSStatus+1,x
.9cd4		20 a0 94	jsr $94a0			jsr 	FloatAdd
.9cd7						_CNTSNotFloat:
.9cd7		20 04 9d	jsr $9d04			jsr 	MakePlusTwoString 			; do the integer part.
.9cda		20 66 95	jsr $9566			jsr 	FloatFractionalPart 		; get the fractional part
.9cdd		20 17 96	jsr $9617			jsr 	NSNormalise					; normalise , exit if zero
.9ce0		f0 20		beq $9d02			beq 	_CNTSExit
.9ce2		a9 2e		lda #$2e			lda 	#"."
.9ce4		20 22 9d	jsr $9d22			jsr 	WriteDecimalBuffer 			; write decimal place
.9ce7						_CNTSDecimal:
.9ce7		ce 14 04	dec $0414			dec 	DecimalPlaces 				; done all the decimals
.9cea		30 16		bmi $9d02			bmi 	_CNTSExit
.9cec		e8		inx				inx 								; x 10.0
.9ced		a9 0a		lda #$0a			lda 	#10
.9cef		20 7a 9e	jsr $9e7a			jsr 	NSMSetByte
.9cf2		a9 08		lda #$08			lda 	#NSTFloat
.9cf4		95 50		sta $50,x			sta 	NSStatus,x
.9cf6		ca		dex				dex
.9cf7		20 e5 95	jsr $95e5			jsr 	FloatMultiply
.9cfa		20 04 9d	jsr $9d04			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.9cfd		20 66 95	jsr $9566			jsr 	FloatFractionalPart 		; get the fractional part
.9d00		80 e5		bra $9ce7			bra 	_CNTSDecimal 				; keep going.
.9d02						_CNTSExit:
.9d02		7a		ply				ply
.9d03		60		rts				rts
.9d04						MakePlusTwoString:
.9d04		da		phx				phx
.9d05		20 5b 9e	jsr $9e5b			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.9d08		e8		inx				inx 								; access it
.9d09		e8		inx				inx
.9d0a		20 be 95	jsr $95be			jsr 	FloatIntegerPart 			; make it an integer
.9d0d		a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.9d0f		20 d0 93	jsr $93d0			jsr 	ConvertInt32
.9d12		a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.9d14						_MPTSCopy:
.9d14		bd 27 06	lda $0627,x			lda 	NumberBuffer,x
.9d17		20 22 9d	jsr $9d22			jsr 	WriteDecimalBuffer
.9d1a		e8		inx				inx
.9d1b		bd 27 06	lda $0627,x			lda 	NumberBuffer,x
.9d1e		d0 f4		bne $9d14			bne 	_MPTSCopy
.9d20		fa		plx				plx
.9d21		60		rts				rts
.9d22						WriteDecimalBuffer:
.9d22		da		phx				phx
.9d23		ae 15 04	ldx $0415			ldx 	dbOffset
.9d26		9d 49 06	sta $0649,x			sta 	DecimalBuffer,x
.9d29		9e 4a 06	stz $064a,x			stz 	DecimalBuffer+1,x
.9d2c		ee 15 04	inc $0415			inc 	dbOffset
.9d2f		fa		plx				plx
.9d30		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/substring.asm

.9d31						Unary_Left:
.9d31		fa		plx				plx
.9d32		18		clc				clc 								; only one parameter
.9d33		20 96 9d	jsr $9d96			jsr 	SubstringInitial 			; set up.
.9d36		b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; Param #1 is the length
.9d38		95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9d3a		74 59		stz $59,x			stz 	NSMantissa0+1,x 			; Start is zero.
.9d3c		80 25		bra $9d63			bra 	SubstringMain
.9d3e						Unary_Right:
.9d3e		fa		plx				plx
.9d3f		18		clc				clc 								; only one parameter
.9d40		20 96 9d	jsr $9d96			jsr 	SubstringInitial 			; set up.
.9d43		b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; length => param 2
.9d45		95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9d47		b5 78		lda $78,x			lda 	NSExponent,x 				; total length
.9d49		f5 59		sbc $59,x			sbc 	NSMantissa0+1,x 			; length - required.
.9d4b		b0 02		bcs $9d4f			bcs 	_URNotUnderflow
.9d4d		a9 00		lda #$00			lda 	#0 							; start from the beginning, as something like right$("AB",3)
.9d4f						_URNotUnderFlow:
.9d4f		95 59		sta $59,x			sta 	NSMantissa0+1,x 			; this is the start position
.9d51		80 10		bra $9d63			bra 	SubStringMain
.9d53						Unary_Mid:
.9d53		fa		plx				plx
.9d54		38		sec				sec 								; two parameters
.9d55		20 96 9d	jsr $9d96			jsr 	SubstringInitial 			; set up.
.9d58		b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; first parameter is zero ?
.9d5a		f0 04		beq $9d60			beq 	_UMError
.9d5c		d6 59		dec $59,x			dec 	NSMantissa0+1,x				; reduce initial offset by 1 as MID$(a$,1..) is actually the first character
.9d5e		80 03		bra $9d63			bra 	SubStringMain
.9d60						_UMError:
.9d60		4c 05 a0	jmp $a005			jmp 	ArgumentError
.9d63						SubStringMain:
.9d63		b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; is the initial offset >= the length
.9d65		d5 78		cmp $78,x			cmp 	NSExponent,x
.9d67		b0 27		bcs $9d90			bcs 	_SSMNull 					; if so, return an empty string.
.9d69		b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; if copy count is zero
.9d6b		f0 23		beq $9d90			beq 	_SSMNull 					; return empty string.
.9d6d		18		clc				clc 								; add the offset +1 to the address and
.9d6e		b5 58		lda $58,x			lda	 	NSMantissa0,x 				; put in zTemp, this is the start of the substring to copy.
.9d70		75 59		adc $59,x			adc 	NSMantissa0+1,x
.9d72		85 36		sta $36				sta 	zTemp0
.9d74		b5 60		lda $60,x			lda	 	NSMantissa1,x
.9d76		69 00		adc #$00			adc 	#0
.9d78		85 37		sta $37				sta 	zTemp0+1
.9d7a						_SSMNoCarry:
.9d7a		b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; characters required.
.9d7c		20 0a a8	jsr $a80a			jsr 	StringTempAllocate 			; allocate that many characters
.9d7f		5a		phy				phy 								; save Y
.9d80		a0 00		ldy #$00			ldy 	#0 							; start copying in.
.9d82						_SSMCopy:
.9d82		b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next character
.9d84		f0 08		beq $9d8e			beq 	_SSMEString 				; no more to copy
.9d86		20 43 a8	jsr $a843			jsr 	StringTempWrite 			; and write it out.
.9d89		c8		iny				iny
.9d8a		d6 5a		dec $5a,x			dec 	NSMantissa0+2,x
.9d8c		d0 f4		bne $9d82			bne 	_SSMCopy
.9d8e						_SSMEString:
.9d8e		7a		ply				ply
.9d8f						_SSMExit:
.9d8f		60		rts				rts
.9d90						_SSMNull:
.9d90		a9 00		lda #$00			lda 	#0
.9d92		20 0a a8	jsr $a80a			jsr 	StringTempAllocate
.9d95		60		rts				rts
.9d96						SubstringInitial:
.9d96		da		phx				phx 								; save initial stack position
.9d97		08		php				php 								; save carry on stack indicating 2 parameters
.9d98		20 d0 9d	jsr $9dd0			jsr 	EvaluateString 				; get a string
.9d9b		5a		phy				phy 								; calculate length to exponent.
.9d9c		a0 ff		ldy #$ff			ldy 	#$FF
.9d9e						_SIFindLength:
.9d9e		c8		iny				iny
.9d9f		b1 36		lda ($36),y			lda 	(zTemp0),y
.9da1		d0 fb		bne $9d9e			bne 	_SIFindLength
.9da3		98		tya				tya
.9da4		95 78		sta $78,x			sta 	NSExponent,x
.9da6		7a		ply				ply
.9da7		e8		inx				inx
.9da8		20 40 8f	jsr $8f40			jsr 	CheckComma 					; comma next
.9dab		20 13 9e	jsr $9e13			jsr 	Evaluate8BitInteger 		; get next parameter
.9dae		28		plp				plp 								; is it the last parameter ?
.9daf		90 07		bcc $9db8			bcc 	_SSIExit 					; if so, exit.
.9db1		e8		inx				inx
.9db2		20 40 8f	jsr $8f40			jsr 	CheckComma 					; comma next
.9db5		20 13 9e	jsr $9e13			jsr 	Evaluate8BitInteger 		; get last parameter
.9db8						_SSIExit:
.9db8		fa		plx				plx
.9db9		20 38 8f	jsr $8f38			jsr 	CheckRightBracket 			; check closing bracket
.9dbc		60		rts				rts 								; exit

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/exprhelper.asm

.9dbd						EvaluateValue:
.9dbd		48		pha				pha
.9dbe		20 55 94	jsr $9455			jsr		EvaluateExpression 			; expression
.9dc1		20 18 97	jsr $9718			jsr 	Dereference					; derefernce it
.9dc4		68		pla				pla
.9dc5		60		rts				rts
.9dc6						EvaluateNumber:
.9dc6		20 bd 9d	jsr $9dbd			jsr 	EvaluateValue 				; get a value
.9dc9		b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.9dcb		29 10		and #$10			and 	#NSBIsString
.9dcd		d0 13		bne $9de2			bne 	HelperTypeError
.9dcf		60		rts				rts
.9dd0						EvaluateString:
.9dd0		20 bd 9d	jsr $9dbd			jsr 	EvaluateValue 				; get a value
.9dd3		b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.9dd5		29 10		and #$10			and 	#NSBIsString
.9dd7		f0 09		beq $9de2			beq 	HelperTypeError
.9dd9						CopyAddressToTemp0:
.9dd9		b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address -> zTemp0
.9ddb		85 36		sta $36				sta 	zTemp0 						; (so we can do something with it)
.9ddd		b5 60		lda $60,x			lda 	NSMantissa1,x
.9ddf		85 37		sta $37				sta 	zTemp0+1
.9de1		60		rts				rts
.9de2						HelperTypeError:
.9de2		4c 00 a0	jmp $a000			jmp 	TypeError
.9de5						EvaluateInteger:
.9de5		20 c6 9d	jsr $9dc6			jsr 	EvaluateNumber
.9de8		b5 78		lda $78,x			lda 	NSExponent,x 				; check exponent is zero
.9dea		d0 09		bne $9df5			bne 	HelperValueError 			; if not, it's a float.
.9dec		60		rts				rts
.9ded						EvaluateUnsignedInteger:
.9ded		20 e5 9d	jsr $9de5			jsr 	EvaluateInteger 			; check integer is +ve
.9df0		b5 50		lda $50,x			lda 	NSStatus,x
.9df2		30 01		bmi $9df5			bmi 	HelperValueError
.9df4		60		rts				rts
.9df5						HelperValueError:
.9df5		4c 05 a0	jmp $a005			jmp 	ArgumentError
.9df8						Evaluate16BitInteger:
.9df8		20 ed 9d	jsr $9ded			jsr	 	EvaluateUnsignedInteger		; get integer
.9dfb		b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9dfd		15 68		ora $68,x			ora 	NSMantissa2,x
.9dff		d0 f4		bne $9df5			bne 	HelperValueError
.9e01		60		rts				rts
.9e02						Evaluate16BitIntegerSigned:
.9e02		20 e5 9d	jsr $9de5			jsr	 	EvaluateInteger				; get integer
.9e05		b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9e07		15 68		ora $68,x			ora 	NSMantissa2,x
.9e09		d0 ea		bne $9df5			bne 	HelperValueError
.9e0b		b5 50		lda $50,x			lda 	NSStatus,x 					; signed ?
.9e0d		10 03		bpl $9e12			bpl 	_EISNotSigned
.9e0f		20 41 9e	jsr $9e41			jsr 	NSMNegateMantissa 			; makes it an actual 2's complement value.
.9e12						_EISNotSigned:
.9e12		60		rts				rts
.9e13						Evaluate8BitInteger:
.9e13		20 ed 9d	jsr $9ded			jsr	 	EvaluateUnsignedInteger 	; get an integer
.9e16		d0 dd		bne $9df5			bne 	HelperValueError
.9e18		b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 1, 2 & 3 must be zero
.9e1a		15 68		ora $68,x			ora 	NSMantissa2,x
.9e1c		15 60		ora $60,x			ora 	NSMantissa1,x
.9e1e		d0 d5		bne $9df5			bne 	HelperValueError
.9e20		b5 58		lda $58,x			lda 	NSMantissa0,x
.9e22		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/mult8x8.asm

.9e23						Multiply8x8:
.9e23		4a		lsr a		  		lsr 	a  							; prime the carry bit for the loop
.9e24		85 36		sta $36			  	sta 	zTemp0
.9e26		86 37		stx $37				stx 	zTemp0+1
.9e28		a9 00		lda #$00			lda 	#0
.9e2a		a2 08		ldx #$08			ldx 	#8
.9e2c						_M88Loop:
.9e2c		90 03		bcc $9e31			bcc 	_M88NoAdd
.9e2e		18		clc				clc
.9e2f		65 37		adc $37				adc 	zTemp0+1
.9e31						_M88NoAdd:
.9e31		6a		ror a				ror 	a
.9e32		66 36		ror $36				ror 	zTemp0  					; pull another bit out for the next iteration
.9e34		ca		dex				dex         						; inc/dec don't modify carry; only shifts and adds do
.9e35		d0 f5		bne $9e2c			bne 	_M88Loop
.9e37		85 37		sta $37				sta 	zTemp0+1 					; store high 8 bits.
.9e39		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/utility.asm

.9e3a						NSMNegate:
.9e3a		b5 50		lda $50,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.9e3c		49 80		eor #$80			eor 	#NSBIsNegative  			; toggle the negative flag
.9e3e		95 50		sta $50,x			sta 	NSStatus,x
.9e40		60		rts				rts
.9e41						NSMNegateMantissa:
.9e41		38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.9e42		a9 00		lda #$00			lda 	#0
.9e44		f5 58		sbc $58,x			sbc 	NSMantissa0,x
.9e46		95 58		sta $58,x			sta 	NSMantissa0,x
.9e48		a9 00		lda #$00			lda 	#0
.9e4a		f5 60		sbc $60,x			sbc 	NSMantissa1,x
.9e4c		95 60		sta $60,x			sta 	NSMantissa1,x
.9e4e		a9 00		lda #$00			lda 	#0
.9e50		f5 68		sbc $68,x			sbc 	NSMantissa2,x
.9e52		95 68		sta $68,x			sta 	NSMantissa2,x
.9e54		a9 00		lda #$00			lda 	#0
.9e56		f5 70		sbc $70,x			sbc 	NSMantissa3,x
.9e58		95 70		sta $70,x			sta 	NSMantissa3,x
.9e5a		60		rts				rts
.9e5b						NSMShiftUpTwo:
.9e5b		b5 58		lda $58,x			lda 	NSMantissa0,x
.9e5d		95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9e5f		b5 60		lda $60,x			lda 	NSMantissa1,x
.9e61		95 62		sta $62,x			sta 	NSMantissa1+2,x
.9e63		b5 68		lda $68,x			lda 	NSMantissa2,x
.9e65		95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.9e67		b5 70		lda $70,x			lda 	NSMantissa3,x
.9e69		95 72		sta $72,x			sta 	NSMantissa3+2,x
.9e6b		b5 78		lda $78,x			lda 	NSExponent,x
.9e6d		95 7a		sta $7a,x			sta 	NSExponent+2,x
.9e6f		b5 50		lda $50,x			lda 	NSStatus,x
.9e71		95 52		sta $52,x			sta 	NSStatus+2,x
.9e73		60		rts				rts
.9e74						NSMSetZeroMantissaOnly:
.9e74		a9 00		lda #$00			lda 	#0
.9e76		80 06		bra $9e7e			bra 	NSMSetMantissa
.9e78						NSMSetZero:
.9e78		a9 00		lda #$00			lda 	#0
.9e7a						NSMSetByte:
.9e7a		74 78		stz $78,x			stz 	NSExponent,x 				; zero exponent, as integer.
.9e7c		74 50		stz $50,x			stz 	NSStatus,x 					; status zero (integer)
.9e7e						NSMSetMantissa:
.9e7e		95 58		sta $58,x			sta 	NSMantissa0,x 				; mantissa
.9e80		74 60		stz $60,x			stz 	NSMantissa1,x
.9e82		74 68		stz $68,x			stz 	NSMantissa2,x
.9e84		74 70		stz $70,x			stz 	NSMantissa3,x
.9e86		60		rts				rts
.9e87						NSMShiftLeft:
.9e87		18		clc				clc
.9e88						NSMRotateLeft:
.9e88		36 58		rol $58,x			rol 	NSMantissa0,x
.9e8a		36 60		rol $60,x			rol		NSMantissa1,x
.9e8c		36 68		rol $68,x			rol		NSMantissa2,x
.9e8e		36 70		rol $70,x			rol		NSMantissa3,x
.9e90		60		rts				rts
.9e91						NSMShiftRight:
.9e91		56 70		lsr $70,x			lsr 	NSMantissa3,x
.9e93		76 68		ror $68,x			ror		NSMantissa2,x
.9e95		76 60		ror $60,x			ror		NSMantissa1,x
.9e97		76 58		ror $58,x			ror		NSMantissa0,x
.9e99		60		rts				rts
.9e9a						NSMIsZero:
.9e9a		b5 70		lda $70,x			lda 	NSMantissa3,x
.9e9c		15 68		ora $68,x			ora		NSMantissa2,x
.9e9e		15 60		ora $60,x			ora		NSMantissa1,x
.9ea0		15 58		ora $58,x			ora		NSMantissa0,x
.9ea2		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.asm

.9ea3						TickHandler:
.9ea3		5a		phy				phy 								; need to preserve Y
.9ea4		20 53 80	jsr $8053			jsr 	SNDUpdate 					; update sound
.9ea7		7a		ply				ply
.9ea8		60		rts				rts
.065c						LastTick:
>065c								.fill 		1

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/asmcore.asm

.9ea9						Assemble_ora:
.9ea9		20 01 81	jsr $8101		jsr	AssembleGroup1
>9eac		01					.byte $01
.9ead						Assemble_and:
.9ead		20 01 81	jsr $8101		jsr	AssembleGroup1
>9eb0		21					.byte $21
.9eb1						Assemble_eor:
.9eb1		20 01 81	jsr $8101		jsr	AssembleGroup1
>9eb4		41					.byte $41
.9eb5						Assemble_adc:
.9eb5		20 01 81	jsr $8101		jsr	AssembleGroup1
>9eb8		61					.byte $61
.9eb9						Assemble_sta:
.9eb9		20 01 81	jsr $8101		jsr	AssembleGroup1
>9ebc		81					.byte $81
.9ebd						Assemble_lda:
.9ebd		20 01 81	jsr $8101		jsr	AssembleGroup1
>9ec0		a1					.byte $a1
.9ec1						Assemble_cmp:
.9ec1		20 01 81	jsr $8101		jsr	AssembleGroup1
>9ec4		c1					.byte $c1
.9ec5						Assemble_sbc:
.9ec5		20 01 81	jsr $8101		jsr	AssembleGroup1
>9ec8		e1					.byte $e1
.9ec9						Assemble_asl:
.9ec9		20 08 81	jsr $8108		jsr	AssembleGroup2
>9ecc		02					.byte $02
>9ecd		75					.byte $75
.9ece						Assemble_rol:
.9ece		20 08 81	jsr $8108		jsr	AssembleGroup2
>9ed1		22					.byte $22
>9ed2		75					.byte $75
.9ed3						Assemble_lsr:
.9ed3		20 08 81	jsr $8108		jsr	AssembleGroup2
>9ed6		42					.byte $42
>9ed7		75					.byte $75
.9ed8						Assemble_ror:
.9ed8		20 08 81	jsr $8108		jsr	AssembleGroup2
>9edb		62					.byte $62
>9edc		75					.byte $75
.9edd						Assemble_stx:
.9edd		20 08 81	jsr $8108		jsr	AssembleGroup2
>9ee0		82					.byte $82
>9ee1		50					.byte $50
.9ee2						Assemble_ldx:
.9ee2		20 08 81	jsr $8108		jsr	AssembleGroup2
>9ee5		a2					.byte $a2
>9ee6		d0					.byte $d0
.9ee7						Assemble_dec:
.9ee7		20 08 81	jsr $8108		jsr	AssembleGroup2
>9eea		c2					.byte $c2
>9eeb		55					.byte $55
.9eec						Assemble_inc:
.9eec		20 08 81	jsr $8108		jsr	AssembleGroup2
>9eef		e2					.byte $e2
>9ef0		55					.byte $55
.9ef1						Assemble_stz:
.9ef1		20 08 81	jsr $8108		jsr	AssembleGroup2
>9ef4		60					.byte $60
>9ef5		44					.byte $44
.9ef6						Assemble_bit:
.9ef6		20 08 81	jsr $8108		jsr	AssembleGroup2
>9ef9		20					.byte $20
>9efa		55					.byte $55
.9efb						Assemble_sty:
.9efb		20 08 81	jsr $8108		jsr	AssembleGroup2
>9efe		80					.byte $80
>9eff		54					.byte $54
.9f00						Assemble_ldy:
.9f00		20 08 81	jsr $8108		jsr	AssembleGroup2
>9f03		a0					.byte $a0
>9f04		d5					.byte $d5
.9f05						Assemble_cpy:
.9f05		20 08 81	jsr $8108		jsr	AssembleGroup2
>9f08		c0					.byte $c0
>9f09		d4					.byte $d4
.9f0a						Assemble_cpx:
.9f0a		20 08 81	jsr $8108		jsr	AssembleGroup2
>9f0d		e0					.byte $e0
>9f0e		d0					.byte $d0
.9f0f						Assemble_tsb:
.9f0f		20 08 81	jsr $8108		jsr	AssembleGroup2
>9f12		00					.byte $00
>9f13		50					.byte $50
.9f14						Assemble_trb:
.9f14		20 08 81	jsr $8108		jsr	AssembleGroup2
>9f17		10					.byte $10
>9f18		50					.byte $50
.9f19						Assemble_jsr:
.9f19		20 08 81	jsr $8108		jsr	AssembleGroup2
>9f1c		14					.byte $14
>9f1d		10					.byte $10
.9f1e						Assemble_jmp:
.9f1e		20 08 81	jsr $8108		jsr	AssembleGroup2
>9f21		40					.byte $40
>9f22		10					.byte $10
.9f23						Assemble_bpl:
.9f23		20 59 81	jsr $8159		jsr	AssembleGroup3
>9f26		10					.byte $10
.9f27						Assemble_bmi:
.9f27		20 59 81	jsr $8159		jsr	AssembleGroup3
>9f2a		30					.byte $30
.9f2b						Assemble_bvc:
.9f2b		20 59 81	jsr $8159		jsr	AssembleGroup3
>9f2e		50					.byte $50
.9f2f						Assemble_bvs:
.9f2f		20 59 81	jsr $8159		jsr	AssembleGroup3
>9f32		70					.byte $70
.9f33						Assemble_bcc:
.9f33		20 59 81	jsr $8159		jsr	AssembleGroup3
>9f36		90					.byte $90
.9f37						Assemble_bcs:
.9f37		20 59 81	jsr $8159		jsr	AssembleGroup3
>9f3a		b0					.byte $b0
.9f3b						Assemble_bne:
.9f3b		20 59 81	jsr $8159		jsr	AssembleGroup3
>9f3e		d0					.byte $d0
.9f3f						Assemble_beq:
.9f3f		20 59 81	jsr $8159		jsr	AssembleGroup3
>9f42		f0					.byte $f0
.9f43						Assemble_bra:
.9f43		20 59 81	jsr $8159		jsr	AssembleGroup3
>9f46		80					.byte $80
.9f47						Assemble_brk:
.9f47		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f4a		00					.byte $00
.9f4b						Assemble_php:
.9f4b		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f4e		08					.byte $08
.9f4f						Assemble_clc:
.9f4f		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f52		18					.byte $18
.9f53						Assemble_plp:
.9f53		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f56		28					.byte $28
.9f57						Assemble_sec:
.9f57		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f5a		38					.byte $38
.9f5b						Assemble_rti:
.9f5b		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f5e		40					.byte $40
.9f5f						Assemble_pha:
.9f5f		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f62		48					.byte $48
.9f63						Assemble_cli:
.9f63		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f66		58					.byte $58
.9f67						Assemble_phy:
.9f67		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f6a		5a					.byte $5a
.9f6b						Assemble_rts:
.9f6b		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f6e		60					.byte $60
.9f6f						Assemble_pla:
.9f6f		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f72		68					.byte $68
.9f73						Assemble_sei:
.9f73		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f76		78					.byte $78
.9f77						Assemble_ply:
.9f77		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f7a		7a					.byte $7a
.9f7b						Assemble_dey:
.9f7b		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f7e		88					.byte $88
.9f7f						Assemble_txa:
.9f7f		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f82		8a					.byte $8a
.9f83						Assemble_tya:
.9f83		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f86		98					.byte $98
.9f87						Assemble_txs:
.9f87		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f8a		9a					.byte $9a
.9f8b						Assemble_tay:
.9f8b		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f8e		a8					.byte $a8
.9f8f						Assemble_tax:
.9f8f		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f92		aa					.byte $aa
.9f93						Assemble_clv:
.9f93		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f96		b8					.byte $b8
.9f97						Assemble_tsx:
.9f97		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f9a		ba					.byte $ba
.9f9b						Assemble_iny:
.9f9b		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f9e		c8					.byte $c8
.9f9f						Assemble_dex:
.9f9f		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9fa2		ca					.byte $ca
.9fa3						Assemble_cld:
.9fa3		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9fa6		d8					.byte $d8
.9fa7						Assemble_phx:
.9fa7		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9faa		da					.byte $da
.9fab						Assemble_stp:
.9fab		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9fae		db					.byte $db
.9faf						Assemble_inx:
.9faf		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9fb2		e8					.byte $e8
.9fb3						Assemble_nop:
.9fb3		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9fb6		ea					.byte $ea
.9fb7						Assemble_sed:
.9fb7		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9fba		f8					.byte $f8
.9fbb						Assemble_plx:
.9fbb		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9fbe		fa					.byte $fa

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/constants.asm

.9fbf						DecimalScalarTable:
>9fbf		66 66 66 66				.dword $66666666 ; 0.1
>9fc3		de					.byte $de
>9fc4		1f 85 eb 51				.dword $51eb851f ; 0.01
>9fc8		db					.byte $db
>9fc9		4c 37 89 41				.dword $4189374c ; 0.001
>9fcd		d8					.byte $d8
>9fce		ac 8b db 68				.dword $68db8bac ; 0.0001
>9fd2		d4					.byte $d4
>9fd3		24 d6 e2 53				.dword $53e2d624 ; 1e-05
>9fd7		d1					.byte $d1
>9fd8		83 de 1b 43				.dword $431bde83 ; 1e-06
>9fdc		ce					.byte $ce
>9fdd		6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>9fe1		ca					.byte $ca
>9fe2		89 3b e6 55				.dword $55e63b89 ; 1e-08
>9fe6		c7					.byte $c7
>9fe7		a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>9feb		c4					.byte $c4
>9fec		67 7f f3 6d				.dword $6df37f67 ; 1e-10
>9ff0		c0					.byte $c0
>9ff1		86 ff f5 57				.dword $57f5ff86 ; 1e-11
>9ff5		bd					.byte $bd

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.asm

.9ff6						SyntaxError:
.9ff6		a9 02		lda #$02		lda	#2
.9ff8		4c 51 8f	jmp $8f51		jmp	ErrorHandler
.9ffb						RangeError:
.9ffb		a9 04		lda #$04		lda	#4
.9ffd		4c 51 8f	jmp $8f51		jmp	ErrorHandler
.a000						TypeError:
.a000		a9 05		lda #$05		lda	#5
.a002		4c 51 8f	jmp $8f51		jmp	ErrorHandler
.a005						ArgumentError:
.a005		a9 07		lda #$07		lda	#7
.a007		4c 51 8f	jmp $8f51		jmp	ErrorHandler
.a00a						NotDoneError:
.a00a		a9 0c		lda #$0c		lda	#12
.a00c		4c 51 8f	jmp $8f51		jmp	ErrorHandler
.a00f						ErrorText:
>a00f		42 72 65 61 6b 00			.text	"Break",0
>a015		53 79 6e 74 61 78 20 65			.text	"Syntax error",0
>a01d		72 72 6f 72 00
>a022		44 69 76 69 73 69 6f 6e			.text	"Division by zero",0
>a02a		20 62 79 20 7a 65 72 6f 00
>a033		4f 75 74 20 6f 66 20 52			.text	"Out of Range",0
>a03b		61 6e 67 65 00
>a040		54 79 70 65 20 6d 69 73			.text	"Type mismatch",0
>a048		6d 61 74 63 68 00
>a04e		4f 75 74 20 6f 66 20 6d			.text	"Out of memory",0
>a056		65 6d 6f 72 79 00
>a05c		49 6c 6c 65 67 61 6c 20			.text	"Illegal argument",0
>a064		61 72 67 75 6d 65 6e 74 00
>a06d		53 74 6f 70 00				.text	"Stop",0
>a072		53 74 72 69 6e 67 20 74			.text	"String too long",0
>a07a		6f 6f 20 6c 6f 6e 67 00
>a082		41 73 73 65 72 74 69 6f			.text	"Assertion failed",0
>a08a		6e 20 66 61 69 6c 65 64 00
>a093		4f 75 74 20 6f 66 20 64			.text	"Out of data",0
>a09b		61 74 61 00
>a09f		55 6e 69 6d 70 6c 65 6d			.text	"Unimplemented",0
>a0a7		65 6e 74 65 64 00
>a0ad		4e 6f 20 73 75 63 68 20			.text	"No such line number",0
>a0b5		6c 69 6e 65 20 6e 75 6d 62 65 72 00
>a0c1		52 65 74 75 72 6e 20 77			.text	"Return without Gosub",0
>a0c9		69 74 68 6f 75 74 20 47 6f 73 75 62 00
>a0d6		55 6e 74 69 6c 20 77 69			.text	"Until without Repeat",0
>a0de		74 68 6f 75 74 20 52 65 70 65 61 74 00
>a0eb		57 65 6e 64 20 77 69 74			.text	"Wend without While",0
>a0f3		68 6f 75 74 20 57 68 69 6c 65 00
>a0fe		4e 65 78 74 20 77 69 74			.text	"Next without For",0
>a106		68 6f 75 74 20 46 6f 72 00
>a10f		42 41 53 49 43 20 53 74			.text	"BASIC Stack full",0
>a117		61 63 6b 20 66 75 6c 6c 00
>a120		4f 70 65 6e 20 53 74 72			.text	"Open Structure",0
>a128		75 63 74 75 72 65 00
>a12f		45 6e 64 50 72 6f 63 20			.text	"EndProc without call",0
>a137		77 69 74 68 6f 75 74 20 63 61 6c 6c 00
>a144		41 72 72 61 79 20 61 6c			.text	"Array already defined",0
>a14c		72 65 61 64 79 20 64 65 66 69 6e 65 64 00
>a15a		41 72 72 61 79 20 73 69			.text	"Array size",0
>a162		7a 65 00
>a165		42 61 64 20 61 72 72 61			.text	"Bad array index",0
>a16d		79 20 69 6e 64 65 78 00
>a175		41 72 72 61 79 20 6e 6f			.text	"Array not declared",0
>a17d		74 20 64 65 63 6c 61 72 65 64 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/timestamp.asm

>a188		41 6c 70 68 61 20 31 35			.text "Alpha 15 built 12-Dec-22. "
>a190		20 62 75 69 6c 74 20 31 32 2d 44 65 63 2d 32 32
>a1a0		2e 20

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcommand.asm

.a1a2						RectangleCommand:
.a1a2		a9 44		lda #$44			lda 	#GCMD_FrameRect				; frame rectangle
.a1a4		80 02		bra $a1a8			bra 	ShapeDrawCmd
.a1a6						CircleCommand:
.a1a6		a9 48		lda #$48			lda 	#GCMD_FrameCircle 				; framed circle
.a1a8						ShapeDrawCmd:
.a1a8		20 32 a2	jsr $a232			jsr 	RunGraphicsCommand
.a1ab						ShapeDraw:
.a1ab		0d 5e 06	ora $065e			ora 	gxFillSolid  				; adjust AXY for solid fill.
.a1ae		4c 26 a2	jmp $a226			jmp 	ExecuteGraphicCommand	 	; and complete
.a1b1						SpriteCommand:
.a1b1		a2 00		ldx #$00			ldx 	#0
.a1b3		20 13 9e	jsr $9e13			jsr 	Evaluate8BitInteger 		; get image number.
.a1b6		5a		phy				phy
.a1b7		a9 0e		lda #$0e			lda 	#GCMD_SpriteUse 			; use that image.
.a1b9		a6 58		ldx $58				ldx 	NSMantissa0
.a1bb		e0 40		cpx #$40			cpx 	#64 						; 0-63 only
.a1bd		b0 0d		bcs $a1cc			bcs 	_SCRange
.a1bf		a0 ff		ldy #$ff			ldy 	#255
.a1c1		20 3f 80	jsr $803f			jsr 	GXGraphicDraw
.a1c4		a9 52		lda #$52			lda 	#GCMD_SpriteMove
.a1c6		7a		ply				ply
.a1c7		20 32 a2	jsr $a232			jsr 	RunGraphicsCommand
.a1ca		80 5a		bra $a226			bra 	ExecuteGraphicCommand
.a1cc						_SCRange:
.a1cc		4c fb 9f	jmp $9ffb			jmp 	RangeError
.a1cf						ImageCommand:
.a1cf		a2 00		ldx #$00			ldx 	#0
.a1d1		20 13 9e	jsr $9e13			jsr 	Evaluate8BitInteger 		; get image number.
.a1d4		20 32 a2	jsr $a232			jsr 	RunGraphicsCommand
.a1d7						ImageRunDraw:
.a1d7		09 40		ora #$40			ora 	#GCMD_Move					; move cursor
.a1d9		20 3f 80	jsr $803f			jsr 	GXGraphicDraw
.a1dc		ad 64 06	lda $0664			lda 	gxDrawScale
.a1df		0a		asl a				asl 	a
.a1e0		0a		asl a				asl 	a
.a1e1		0a		asl a				asl 	a
.a1e2		a8		tay				tay
.a1e3		a9 0c		lda #$0c			lda 	#GCMD_DrawSprite 			; image drawing
.a1e5		a6 58		ldx $58				ldx 	NSMantissa0
.a1e7		20 3f 80	jsr $803f			jsr 	GXGraphicDraw
.a1ea		60		rts				rts
.a1eb						TextCommand:
.a1eb		a2 00		ldx #$00			ldx 	#0
.a1ed		20 d0 9d	jsr $9dd0			jsr 	EvaluateString 				; get text
.a1f0		20 32 a2	jsr $a232			jsr 	RunGraphicsCommand
.a1f3						TextRunDraw:
.a1f3		09 40		ora #$40			ora 	#GCMD_Move 					; move cursor
.a1f5		20 3f 80	jsr $803f			jsr 	GXGraphicDraw
.a1f8		a0 00		ldy #$00			ldy 	#0
.a1fa						_IRDLoop:
.a1fa		a5 60		lda $60				lda 	NSMantissa1 				; access character
.a1fc		85 37		sta $37				sta 	zTemp0+1
.a1fe		a5 58		lda $58				lda 	NSMantissa0
.a200		85 36		sta $36				sta 	zTemp0
.a202		b1 36		lda ($36),y			lda 	(zTemp0),y
.a204		f0 13		beq $a219			beq 	_IRDExit
.a206		5a		phy				phy									; save string pos
.a207		48		pha				pha 								; save char
.a208		ad 64 06	lda $0664			lda 	gxDrawScale 				; get scale
.a20b		0a		asl a				asl 	a
.a20c		0a		asl a				asl 	a
.a20d		0a		asl a				asl 	a
.a20e		a8		tay				tay
.a20f		a9 0a		lda #$0a			lda 	#GCMD_DrawFont 				; char drawing
.a211		fa		plx				plx 								; char to draw
.a212		20 3f 80	jsr $803f			jsr 	GXGraphicDraw
.a215		7a		ply				ply 								; restore string pos
.a216		c8		iny				iny
.a217		90 e1		bcc $a1fa			bcc 	_IRDLoop 					; go back if no error.
.a219						_IRDExit:
.a219		60		rts				rts
.a21a						PlotCommand:
.a21a		a9 50		lda #$50			lda 	#GCMD_Plot 					; command ID to use
.a21c		20 32 a2	jsr $a232			jsr 	RunGraphicsCommand
.a21f		80 05		bra $a226			bra 	ExecuteGraphicCommand
.a221						LineCommand:
.a221		a9 42		lda #$42			lda 	#GCMD_Line 						; command ID to use
.a223		20 32 a2	jsr $a232			jsr 	RunGraphicsCommand
.a226						ExecuteGraphicCommand:
.a226		0d 5d 06	ora $065d			ora 	gxCommandID 				; make a full command
.a229		20 3f 80	jsr $803f			jsr 	GXGraphicDraw 				; draw it and exit
.a22c		b0 01		bcs $a22f			bcs 	_EGCError
.a22e		60		rts				rts
.a22f						_EGCError:
.a22f		4c f6 9f	jmp $9ff6			jmp 	SyntaxError
.a232						RunGraphicsCommand:
.a232		8d 5d 06	sta $065d			sta 	gxCommandID					; save TODO graphics command.
.a235		68		pla				pla 								; pop handler address
.a236		fa		plx				plx
.a237		1a		inc a				inc 	a
.a238		d0 01		bne $a23b			bne 	_RGINoCarry
.a23a		e8		inx				inx
.a23b						_RGINoCarry:
.a23b		8d 62 06	sta $0662			sta 	GXHandler
.a23e		8e 63 06	stx $0663			stx 	GXHandler+1
.a241						_RGICommandLoop:
.a241		b1 30		lda ($30),y			lda 	(codePtr),y
.a243		c8		iny				iny
.a244		c9 d2		cmp #$d2			cmp 	#KWD_TO						; is it TO x,y
.a246		f0 53		beq $a29b			beq 	_RGI_To
.a248		c9 bd		cmp #$bd			cmp 	#KWD_HERE 					; do it here.
.a24a		f0 55		beq $a2a1			beq 	_RGI_Here
.a24c		c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL or : , exit
.a24e		f0 3d		beq $a28d			beq 	_RGI_Exit
.a250		c9 3a		cmp #$3a			cmp 	#KWD_COLON
.a252		f0 39		beq $a28d			beq 	_RGI_Exit
.a254		c9 c5		cmp #$c5			cmp 	#KWD_OUTLINE 				; solid or outline
.a256		f0 3e		beq $a296			beq 	_RGI_Frame
.a258		c9 ce		cmp #$ce			cmp 	#KWD_SOLID
.a25a		f0 33		beq $a28f			beq 	_RGI_Solid
.a25c		c9 ad		cmp #$ad			cmp 	#KWD_BY 					; by offset
.a25e		f0 4b		beq $a2ab			beq 	_RGI_By
.a260		c9 b9		cmp #$b9			cmp 	#KWD_FROM 					; from
.a262		f0 17		beq $a27b			beq 	_RGI_Move2
.a264		c9 b5		cmp #$b5			cmp 	#KWD_DIM 					; dim (set scale)
.a266		f0 62		beq $a2ca			beq 	_RGI_Dim
.a268		c9 b3		cmp #$b3			cmp 	#KWD_COLOUR 				; colour or Color
.a26a		f0 74		beq $a2e0			beq 	_RGI_Colour
.a26c		c9 b2		cmp #$b2			cmp 	#KWD_COLOR
.a26e		f0 70		beq $a2e0			beq 	_RGI_Colour
.a270		ae 5d 06	ldx $065d			ldx 	gxCommandID
.a273		e0 52		cpx #$52			cpx 	#GCMD_SpriteMove 			; if not sprite
.a275		d0 03		bne $a27a			bne 	_RGI_Move 					; move
.a277		4c 08 a3	jmp $a308			jmp		_RGI_SpriteInstructions
.a27a						_RGI_Move:
.a27a		88		dey				dey 								; unpick get.
.a27b						_RGI_Move2:
.a27b		20 2e a3	jsr $a32e			jsr 	GCGetCoordinatePair 		; move to here
.a27e		20 55 a3	jsr $a355			jsr 	GCCopyPairToStore 			; save
.a281		5a		phy				phy
.a282		20 4b a3	jsr $a34b			jsr 	GCLoadAXY 					; load in
.a285		09 40		ora #$40			ora 	#GCMD_Move 					; move there
.a287		20 3f 80	jsr $803f			jsr 	GXGraphicDraw
.a28a		7a		ply				ply
.a28b		80 b4		bra $a241			bra 	_RGICommandLoop 			; and go round
.a28d						_RGI_Exit:
.a28d		88		dey				dey 								; unpick : / EOL
.a28e		60		rts				rts
.a28f						_RGI_Solid:
.a28f		a9 02		lda #$02			lda 	#2
.a291		8d 5e 06	sta $065e			sta 	gxFillSolid
.a294		80 ab		bra $a241			bra 	_RGICommandLoop
.a296						_RGI_Frame:
.a296		9c 5e 06	stz $065e			stz 	gxFillSolid
.a299		80 a6		bra $a241			bra 	_RGICommandLoop
.a29b						_RGI_To:
.a29b		20 2e a3	jsr $a32e			jsr 	GCGetCoordinatePair 		; get coordinate pair into slot #1,#2
.a29e		20 55 a3	jsr $a355			jsr 	GCCopyPairToStore
.a2a1						_RGI_Here:
.a2a1		5a		phy				phy
.a2a2		20 4b a3	jsr $a34b			jsr 	GCLoadAXY 					; load it into AXY
.a2a5		20 05 a3	jsr $a305			jsr 	_RGICallHandler 			; go do whatever it is.
.a2a8		7a		ply				ply
.a2a9		80 96		bra $a241			bra 	_RGICommandLoop 			; and go round
.a2ab						_RGI_By:
.a2ab		20 3b a3	jsr $a33b			jsr 	GCSignedCoordinatePair 		; get coordinate pair into slot #1,#2
.a2ae		18		clc				clc
.a2af		a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.a2b1		6d 5f 06	adc $065f			adc 	gxxPos
.a2b4		8d 5f 06	sta $065f			sta 	gxXPos
.a2b7		a5 61		lda $61				lda 	NSMantissa1+1
.a2b9		6d 60 06	adc $0660			adc 	gxxPos+1
.a2bc		8d 60 06	sta $0660			sta 	gxXPos+1
.a2bf		a5 5a		lda $5a				lda 	NSMantissa0+2
.a2c1		18		clc				clc
.a2c2		6d 61 06	adc $0661			adc 	gxYPos
.a2c5		8d 61 06	sta $0661			sta 	gxYPos
.a2c8		80 d7		bra $a2a1			bra 	_RGI_Here
.a2ca						_RGI_Dim:
.a2ca		a2 01		ldx #$01			ldx	 	#1
.a2cc		20 13 9e	jsr $9e13			jsr 	Evaluate8BitInteger
.a2cf		a5 59		lda $59				lda 	NSMantissa0+1
.a2d1		c9 00		cmp #$00			cmp 	#0
.a2d3		f0 2d		beq $a302			beq 	_RGIRange
.a2d5		c9 09		cmp #$09			cmp 	#8+1
.a2d7		b0 29		bcs $a302			bcs		_RGIRange
.a2d9		3a		dec a				dec 	a
.a2da		8d 64 06	sta $0664			sta 	gxDrawScale
.a2dd		4c 41 a2	jmp $a241			jmp 	_RGICommandLoop
.a2e0						_RGI_Colour:
.a2e0		a2 01		ldx #$01			ldx 	#1 							; colour
.a2e2		20 13 9e	jsr $9e13			jsr 	Evaluate8BitInteger
.a2e5		a2 02		ldx #$02			ldx 	#2 							; default zero for 2nd parameter
.a2e7		20 78 9e	jsr $9e78			jsr 	NSMSetZero
.a2ea		b1 30		lda ($30),y			lda 	(codePtr),y
.a2ec		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; check , => mode.
.a2ee		d0 04		bne $a2f4			bne 	_RGICDefaultMode
.a2f0		c8		iny				iny
.a2f1		20 13 9e	jsr $9e13			jsr 	Evaluate8BitInteger
.a2f4						_RGICDefaultMode:
.a2f4		5a		phy				phy
.a2f5		a9 08		lda #$08			lda 	#GCMD_Colour 				; set colour.
.a2f7		a6 59		ldx $59				ldx 	NSMantissa0+1
.a2f9		a4 5a		ldy $5a				ldy 	NSMantissa0+2
.a2fb		20 3f 80	jsr $803f			jsr 	GXGraphicDraw
.a2fe		7a		ply				ply
.a2ff		4c 41 a2	jmp $a241			jmp 	_RGICommandLoop 			; and go round
.a302						_RGIRange:
.a302		4c fb 9f	jmp $9ffb			jmp 	RangeError
.a305						_RGICallHandler:
.a305		6c 62 06	jmp ($0662)			jmp 	(GXHandler)
.a308						_RGI_SpriteInstructions:
.a308		c9 c3		cmp #$c3			cmp 	#KWD_OFF
.a30a		f0 07		beq $a313			beq 	_RGISpriteOff
.a30c		c9 be		cmp #$be			cmp 	#KWD_IMAGE
.a30e		f0 13		beq $a323			beq 	_RGISetImage
.a310		4c 7a a2	jmp $a27a			jmp 	_RGI_Move
.a313						_RGISpriteOff:
.a313		5a		phy				phy
.a314		a0 01		ldy #$01			ldy 	#1
.a316		a2 00		ldx #$00			ldx 	#0
.a318						_RGIDoCommandLoop:
.a318		a9 10		lda #$10			lda 	#GCMD_SpriteImage
.a31a		20 3f 80	jsr $803f			jsr 	GXGraphicDraw
.a31d		7a		ply				ply
.a31e		b0 e2		bcs $a302			bcs 	_RGIRange
.a320		4c 41 a2	jmp $a241			jmp 	_RGICommandLoop
.a323						_RGISetImage:
.a323		a2 01		ldx #$01			ldx 	#1
.a325		20 13 9e	jsr $9e13			jsr 	Evaluate8BitInteger
.a328		5a		phy				phy
.a329		aa		tax				tax
.a32a		a0 00		ldy #$00			ldy 	#0
.a32c		80 ea		bra $a318			bra 	_RGIDoCommandLoop
.a32e						GCGetCoordinatePair:
.a32e		a2 01		ldx #$01			ldx 	#1
.a330		20 f8 9d	jsr $9df8			jsr 	Evaluate16BitInteger
.a333		20 40 8f	jsr $8f40			jsr 	CheckComma
.a336		e8		inx				inx
.a337		20 f8 9d	jsr $9df8			jsr 	Evaluate16BitInteger
.a33a		60		rts				rts
.a33b						GCSignedCoordinatePair:
.a33b		a2 01		ldx #$01			ldx 	#1
.a33d		20 02 9e	jsr $9e02			jsr 	Evaluate16BitIntegerSigned
.a340		20 40 8f	jsr $8f40			jsr 	CheckComma
.a343		e8		inx				inx
.a344		20 02 9e	jsr $9e02			jsr 	Evaluate16BitIntegerSigned
.a347		60		rts				rts
.a348						_GCCPRange:
.a348		4c fb 9f	jmp $9ffb			jmp 	RangeError
.a34b						GCLoadAXY:
.a34b		ad 60 06	lda $0660			lda 	gxXPos+1
.a34e		ae 5f 06	ldx $065f			ldx 	gxXPos
.a351		ac 61 06	ldy $0661			ldy 	gxYPos
.a354		60		rts				rts
.a355						GCCopyPairToStore:
.a355		a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.a357		8d 5f 06	sta $065f			sta 	gxXPos
.a35a		a5 61		lda $61				lda 	NSMantissa1+1
.a35c		8d 60 06	sta $0660			sta 	gxXPos+1
.a35f		a5 5a		lda $5a				lda 	NSMantissa0+2
.a361		8d 61 06	sta $0661			sta 	gxYPos
.a364		60		rts				rts
.065d						gxCommandID:
>065d								.fill 	1
.065e						gxFillSolid:
>065e								.fill 	1
.065f						gxXPos:
>065f								.fill 	2
.0661						gxYPos:
>0661								.fill 	1
.0662						gxHandler:
>0662								.fill 	2
.0664						gxDrawScale:
>0664								.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcontrol.asm

.a365						BitmapCtrl:
.a365		b1 30		lda ($30),y			lda 	(codePtr),y
.a367		c8		iny				iny
.a368		a2 01		ldx #$01			ldx 	#1
.a36a		c9 c4		cmp #$c4			cmp 	#KWD_ON
.a36c		f0 11		beq $a37f			beq 	BitmapSwitch
.a36e		ca		dex				dex
.a36f		c9 c3		cmp #$c3			cmp 	#KWD_OFF
.a371		f0 0c		beq $a37f			beq 	BitmapSwitch
.a373		20 13 9e	jsr $9e13			jsr 	Evaluate8BitInteger 		; get the colour
.a376		5a		phy				phy
.a377		aa		tax				tax
.a378		a9 06		lda #$06			lda 	#GCMD_Clear					; clear to that colour
.a37a		20 3f 80	jsr $803f			jsr 	GXGraphicDraw
.a37d		7a		ply				ply
.a37e		60		rts				rts
.a37f						BitmapSwitch:
.a37f		5a		phy				phy
.a380		a0 00		ldy #$00			ldy 	#0 							; gfx 1,on/off,0
.a382		a9 02		lda #$02			lda 	#GCMD_BitmapCtl
.a384		20 3f 80	jsr $803f			jsr 	GXGraphicDraw
.a387		a9 08		lda #$08			lda 	#GCMD_Colour				; set colour to $FF
.a389		a0 00		ldy #$00			ldy 	#0
.a38b		a2 ff		ldx #$ff			ldx 	#$FF
.a38d		20 3f 80	jsr $803f			jsr 	GXGraphicDraw
.a390		9c 5e 06	stz $065e			stz 	gxFillSolid
.a393		9c 5f 06	stz $065f			stz 	gxXPos
.a396		9c 60 06	stz $0660			stz 	gxXPos+1
.a399		9c 61 06	stz $0661			stz 	gxYPos
.a39c		9c 64 06	stz $0664			stz 	gxDrawScale
.a39f		a9 40		lda #$40			lda 	#GCMD_Move 						; home cursor
.a3a1		a2 00		ldx #$00			ldx 	#0
.a3a3		a0 00		ldy #$00			ldy 	#0
.a3a5		20 3f 80	jsr $803f			jsr 	GXGraphicDraw
.a3a8		7a		ply				ply
.a3a9		60		rts				rts
.a3aa						SpritesCtrl:
.a3aa		b1 30		lda ($30),y			lda 	(codePtr),y
.a3ac		c8		iny				iny
.a3ad		a2 01		ldx #$01			ldx 	#1
.a3af		c9 c4		cmp #$c4			cmp 	#KWD_ON
.a3b1		f0 08		beq $a3bb			beq 	SpriteSwitch
.a3b3		ca		dex				dex
.a3b4		c9 c3		cmp #$c3			cmp 	#KWD_OFF
.a3b6		f0 03		beq $a3bb			beq 	SpriteSwitch
.a3b8		4c f6 9f	jmp $9ff6			jmp 	SyntaxError
.a3bb						SpriteSwitch:
.a3bb		5a		phy				phy
.a3bc		a0 00		ldy #$00			ldy 	#0 							; gfx 2,on/off,0
.a3be		a9 04		lda #$04			lda 	#GCMD_SpriteCtl
.a3c0		20 3f 80	jsr $803f			jsr 	GXGraphicDraw
.a3c3		7a		ply				ply
.a3c4		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gfx.asm

.a3c5						GfxCommand:
.a3c5		a2 00		ldx #$00			ldx 	#0
.a3c7		20 13 9e	jsr $9e13			jsr 	Evaluate8BitInteger 		; command
.a3ca		20 40 8f	jsr $8f40			jsr 	CheckComma
.a3cd		e8		inx				inx
.a3ce		20 f8 9d	jsr $9df8			jsr 	Evaluate16BitInteger 		; X
.a3d1		20 40 8f	jsr $8f40			jsr 	CheckComma
.a3d4		e8		inx				inx
.a3d5		20 13 9e	jsr $9e13			jsr 	Evaluate8BitInteger 		; Y
.a3d8		a5 61		lda $61				lda 	NSMantissa1+1  				; shift bit 0 of X into CS, should now be zero
.a3da		4a		lsr a				lsr 	a
.a3db		d0 12		bne $a3ef			bne 	_GfxError
.a3dd		26 58		rol $58				rol 	NSMantissa0 				; rotate into command
.a3df		b0 0e		bcs $a3ef			bcs 	_GfxError 					; bit 7 should have been zero
.a3e1		5a		phy				phy 								; save pos
.a3e2		a5 58		lda $58				lda 	NSMantissa0 				; do the command
.a3e4		a6 59		ldx $59				ldx 	NSMantissa0+1
.a3e6		a4 5a		ldy $5a				ldy 	NSMantissa0+2
.a3e8		20 3f 80	jsr $803f			jsr 	GXGraphicDraw
.a3eb		b0 02		bcs $a3ef			bcs 	_GfxError
.a3ed		7a		ply				ply 								; restore pos and exit.
.a3ee		60		rts				rts
.a3ef						_GfxError:
.a3ef		4c fb 9f	jmp $9ffb			jmp 	RangeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/hit.asm

.a3f2						UnaryHit:
.a3f2		fa		plx				plx
.a3f3		a9 36		lda #$36			lda 	#zTemp0
.a3f5		20 13 9e	jsr $9e13			jsr 	Evaluate8BitInteger 		; get sprite number 0
.a3f8		20 40 8f	jsr $8f40			jsr 	CheckComma
.a3fb		e8		inx				inx
.a3fc		20 13 9e	jsr $9e13			jsr 	Evaluate8BitInteger 		; get sprite number 1
.a3ff		20 38 8f	jsr $8f38			jsr		CheckRightBracket
.a402		ca		dex				dex 								; fix back up again.
.a403		da		phx				phx 								; save X/Y
.a404		5a		phy				phy
.a405		b4 59		ldy $59,x			ldy 	NSMantissa0+1,x 			; get the sprite numbers into X/Y
.a407		b5 58		lda $58,x			lda 	NSMantissa0,x
.a409		aa		tax				tax
.a40a		a9 12		lda #$12			lda 	#GCMD_SpriteCollide 		; command check collision.
.a40c		20 3f 80	jsr $803f			jsr 	GXGraphicDraw 				; calculate result
.a40f		1a		inc a				inc 	a 							; so 255 (fail) -> 0, otherwise 1,2,3,4 pixels etc.
.a410		7a		ply				ply 								; restore XY
.a411		fa		plx				plx
.a412		20 7a 9e	jsr $9e7a			jsr 	NSMSetByte 					; return the hit result
.a415		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/palette.asm

.a416						PaletteCommand:
.a416		a2 00		ldx #$00			ldx 	#0
.a418		20 13 9e	jsr $9e13			jsr 	Evaluate8BitInteger 		; colour
.a41b		20 40 8f	jsr $8f40			jsr 	CheckComma
.a41e		e8		inx				inx
.a41f		20 f8 9d	jsr $9df8			jsr 	Evaluate16BitInteger 		; r
.a422		20 40 8f	jsr $8f40			jsr 	CheckComma
.a425		e8		inx				inx
.a426		20 13 9e	jsr $9e13			jsr 	Evaluate8BitInteger 		; g
.a429		20 40 8f	jsr $8f40			jsr 	CheckComma
.a42c		e8		inx				inx
.a42d		20 13 9e	jsr $9e13			jsr 	Evaluate8BitInteger 		; b
.a430		a5 58		lda $58				lda 	NSMantissa0 				; get colour #
.a432		85 36		sta $36				sta 	zTemp0
.a434		a9 34		lda #$34			lda 	#$D0 >> 2 					; MSB = D0/4
.a436		85 37		sta $37				sta 	zTemp0+1
.a438		06 36		asl $36				asl 	zTemp0 						; zTemp = $D000+Colour x 4
.a43a		26 37		rol $37				rol	 	zTemp0+1
.a43c		06 36		asl $36				asl 	zTemp0
.a43e		26 37		rol $37				rol	 	zTemp0+1
.a440		a9 01		lda #$01			lda 	#1 							; I/O Page 2
.a442		85 01		sta $01				sta 	1
.a444		5a		phy				phy
.a445		a5 5b		lda $5b				lda 	NSMantissa0+3 				; fix to r,g,b
.a447		92 36		sta ($36)			sta 	(zTemp0)
.a449		a0 01		ldy #$01			ldy 	#1
.a44b		a5 5a		lda $5a				lda 	NSMantissa0+2
.a44d		91 36		sta ($36),y			sta 	(zTemp0),y
.a44f		a5 59		lda $59				lda 	NSMantissa0+1
.a451		c8		iny				iny
.a452		91 36		sta ($36),y			sta 	(zTemp0),y
.a454		7a		ply				ply
.a455		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/event.asm

.a456						UnaryEvent:
.a456		fa		plx				plx
.a457		20 04 a5	jsr $a504			jsr 	TimerToStackX 				; timer in +0
.a45a		e8		inx				inx  								; put reference into +1
.a45b		20 9f 98	jsr $989f			jsr 	EvaluateTerm
.a45e		b5 50		lda $50,x			lda 	NSStatus,x 					; check if is integer reference
.a460		c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.a462		d0 4c		bne $a4b0			bne 	_UEType
.a464		e8		inx				inx 								; put the step in +2
.a465		20 40 8f	jsr $8f40			jsr 	CheckComma
.a468		20 f8 9d	jsr $9df8			jsr 	Evaluate16BitInteger
.a46b		20 38 8f	jsr $8f38			jsr 	CheckRightBracket
.a46e		ca		dex				dex
.a46f		ca		dex				dex
.a470		b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy reference to zTemp0
.a472		85 36		sta $36				sta 	zTemp0
.a474		b5 61		lda $61,x			lda 	NSMantissa1+1,x
.a476		85 37		sta $37				sta 	zTemp0+1
.a478		5a		phy				phy
.a479		a0 03		ldy #$03			ldy 	#3 							; check bit 7 of last bit, the packed sign bit
.a47b		b1 36		lda ($36),y			lda 	(zTemp0),y
.a47d		30 2d		bmi $a4ac			bmi 	_UEFalse 					; exit if signed.
.a47f		a0 00		ldy #$00			ldy 	#0 							; has it timed out (24 bit)
.a481		b5 58		lda $58,x			lda 	NSMantissa0,x
.a483		d1 36		cmp ($36),y			cmp 	(zTemp0),y
.a485		c8		iny				iny
.a486		b5 60		lda $60,x			lda 	NSMantissa1,x
.a488		f1 36		sbc ($36),y			sbc		(zTemp0),y
.a48a		c8		iny				iny
.a48b		b5 68		lda $68,x			lda 	NSMantissa2,x
.a48d		f1 36		sbc ($36),y			sbc		(zTemp0),y
.a48f		90 1b		bcc $a4ac			bcc 	_UEFalse 					; no, return FALSE.
.a491		18		clc				clc
.a492		a0 00		ldy #$00			ldy 	#0 							; work out new value as timer() + step
.a494		b5 58		lda $58,x			lda 	NSMantissa0,x
.a496		75 5a		adc $5a,x			adc 	NSMantissa0+2,x
.a498		91 36		sta ($36),y			sta 	(zTemp0),y
.a49a		c8		iny				iny
.a49b		b5 60		lda $60,x			lda 	NSMantissa1,x
.a49d		75 62		adc $62,x			adc 	NSMantissa1+2,x
.a49f		91 36		sta ($36),y			sta 	(zTemp0),y
.a4a1		c8		iny				iny
.a4a2		b5 68		lda $68,x			lda 	NSMantissa2,x
.a4a4		75 6a		adc $6a,x			adc 	NSMantissa2+2,x
.a4a6		91 36		sta ($36),y			sta 	(zTemp0),y
.a4a8		7a		ply				ply
.a4a9		4c be 8f	jmp $8fbe			jmp 	ReturnTrue
.a4ac						_UEFalse:
.a4ac		7a		ply				ply 								; restore Y
.a4ad		4c c9 8f	jmp $8fc9			jmp 	ReturnFalse 				; and return False
.a4b0						_UEType:
.a4b0		4c 00 a0	jmp $a000			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/joy.asm

.a4b3						UnaryJoyX:
.a4b3		18		clc				clc
.a4b4		80 01		bra $a4b7			bra 	JoyMain
.a4b6						UnaryJoyY:
.a4b6		38		sec				sec
.a4b7						JoyMain:
.a4b7		fa		plx				plx 								; get pos
.a4b8		08		php				php 								; save carry (set for Y)
.a4b9		20 13 9e	jsr $9e13			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a4bc		20 38 8f	jsr $8f38			jsr 	CheckRightBracket
.a4bf		20 2b 80	jsr $802b			jsr 	EXTReadController 			; read the controller.
.a4c2		28		plp				plp
.a4c3		90 02		bcc $a4c7			bcc 	_JMNoShift 					; if Y then shift bits 3,2 -> 1,0
.a4c5		4a		lsr a				lsr 	a
.a4c6		4a		lsr a				lsr 	a
.a4c7						_JMNoShift:
.a4c7		4a		lsr a				lsr 	a 							; if bit 0 set then right/down e.g. +1
.a4c8		b0 0a		bcs $a4d4			bcs 	_JMIsRight
.a4ca		4a		lsr a				lsr 	a 							; if bit 1 set then left/up e.g. -1
.a4cb		b0 04		bcs $a4d1			bcs 	_JMIsLeft
.a4cd		20 78 9e	jsr $9e78			jsr 	NSMSetZero 					; zero result
.a4d0		60		rts				rts
.a4d1						_JMIsLeft:
.a4d1		4c be 8f	jmp $8fbe			jmp 	ReturnTrue
.a4d4						_JMIsRight:
.a4d4		a9 01		lda #$01			lda 	#1
.a4d6		20 7a 9e	jsr $9e7a			jsr 	NSMSetByte
.a4d9		60		rts				rts
.a4da						UnaryJoyB:
.a4da		fa		plx				plx 								; get pos
.a4db		20 13 9e	jsr $9e13			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a4de		20 38 8f	jsr $8f38			jsr 	CheckRightBracket
.a4e1		20 2b 80	jsr $802b			jsr 	EXTReadController 			; read the controller.
.a4e4		4a		lsr a				lsr 	a
.a4e5		4a		lsr a				lsr 	a
.a4e6		4a		lsr a				lsr 	a
.a4e7		4a		lsr a				lsr 	a
.a4e8		29 01		and #$01			and 	#1
.a4ea		20 7a 9e	jsr $9e7a			jsr 	NSMSetByte
.a4ed		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/load.asm

.a4ee						LoadCommand:
.a4ee		20 86 8a	jsr $8a86			jsr 	NewProgram
.a4f1		20 70 83	jsr $8370			jsr 	BackLoadProgram
.a4f4		4c 2f 84	jmp $842f			jmp 	WarmStart
.a4f7						GoCommand:
.a4f7		20 86 8a	jsr $8a86			jsr 	NewProgram
.a4fa		20 70 83	jsr $8370			jsr 	BackLoadProgram
.a4fd		4c c7 8b	jmp $8bc7			jmp 	CommandRun

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/timer.asm

.a500						UnaryTimer:
.a500		fa		plx				plx
.a501		20 38 8f	jsr $8f38			jsr 	CheckRightBracket
.a504						TimerToStackX:
.a504		20 78 9e	jsr $9e78			jsr 	NSMSetZero 					; zero result
.a507		64 01		stz $01				stz 	1 							; access I/O
.a509		ad 59 d6	lda $d659			lda 	$D659 						; copy timer in
.a50c		95 58		sta $58,x			sta 	NSMantissa0,x
.a50e		ad 5a d6	lda $d65a			lda 	$D65A
.a511		95 60		sta $60,x			sta 	NSMantissa1,x
.a513		ad 5b d6	lda $d65b			lda 	$D65B
.a516		95 68		sta $68,x			sta 	NSMantissa2,x
.a518		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/delete.asm

.a519						MemoryDeleteLine:
.a519		20 38 a5	jsr $a538			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a51c		b2 30		lda ($30)			lda 	(codePtr) 					; size to delete => y
.a51e		a8		tay				tay
.a51f						_MDDLLoop:
.a51f		b1 30		lda ($30),y			lda 	(codePtr),y 				; copy down
.a521		92 30		sta ($30)			sta 	(codePtr)
.a523		a5 30		lda $30				lda 	codePtr 					; check done the lot.
.a525		c5 3a		cmp $3a				cmp 	zTemp2
.a527		d0 07		bne $a530			bne 	_MDLDLNext
.a529		a5 31		lda $31				lda 	codePtr+1
.a52b		c5 3b		cmp $3b				cmp 	zTemp2+1
.a52d		d0 01		bne $a530			bne 	_MDLDLNext
.a52f						_MDDLExit:
.a52f		60		rts				rts
.a530						_MDLDLNext:
.a530		e6 30		inc $30				inc 	codePtr						; next byte
.a532		d0 eb		bne $a51f			bne 	_MDDLLoop
.a534		e6 31		inc $31				inc 	codePtr+1
.a536		80 e7		bra $a51f			bra 	_MDDLLoop
.a538						IMemoryFindEnd:
.a538		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a53a		85 3a		sta $3a				sta 	0+zTemp2
.a53c		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a53e		85 3b		sta $3b				sta 	1+zTemp2
.a540						_MDLFELoop:
.a540		b2 3a		lda ($3a)			lda 	(zTemp2)
.a542		f0 0b		beq $a54f			beq 	_MDLFEExit
.a544		18		clc				clc
.a545		65 3a		adc $3a				adc 	zTemp2
.a547		85 3a		sta $3a				sta 	zTemp2
.a549		90 f5		bcc $a540			bcc 	_MDLFELoop
.a54b		e6 3b		inc $3b				inc 	zTemp2+1
.a54d		80 f1		bra $a540			bra 	_MDLFELoop
.a54f						_MDLFEExit:
.a54f		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/insert.asm

.a550						MemoryInsertLine:
.a550		08		php				php
.a551		20 38 a5	jsr $a538			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a554		a5 3b		lda $3b				lda 	zTemp2+1 					; space ?
.a556		1a		inc a				inc 	a
.a557		c9 7f		cmp #$7f			cmp 	#(BasicEnd >> 8)-1
.a559		b0 36		bcs $a591			bcs 	_MDLIError
.a55b		28		plp				plp
.a55c		90 08		bcc $a566			bcc 	_MDLIFound
.a55e		a5 3a		lda $3a				lda 	zTemp2 						; if CS on entry append.
.a560		85 30		sta $30				sta 	codePtr
.a562		a5 3b		lda $3b				lda 	zTemp2+1
.a564		85 31		sta $31				sta 	codePtr+1
.a566						_MDLIFound:
.a566		ad 2a 04	lda $042a			lda 	tokenOffset 				; insert gap in Y, the offset, e.g. length of the new line
.a569		a8		tay				tay
.a56a						_MDLIInsert:
.a56a		b2 3a		lda ($3a)			lda 	(zTemp2) 					; shift one byte up , at least one covers end case.
.a56c		91 3a		sta ($3a),y			sta 	(zTemp2),y 					; work from top down.
.a56e		a5 30		lda $30				lda 	codePtr 					; done insert point ?
.a570		c5 3a		cmp $3a				cmp 	zTemp2
.a572		d0 06		bne $a57a			bne 	_MDLINext
.a574		a5 31		lda $31				lda 	codePtr+1
.a576		c5 3b		cmp $3b				cmp 	zTemp2+1
.a578		f0 0a		beq $a584			beq 	_MDLIHaveSpace
.a57a						_MDLINext:
.a57a		a5 3a		lda $3a				lda 	zTemp2 						; if no, keep zTemp2 going backwards
.a57c		d0 02		bne $a580			bne 	_MDLINoBorrow
.a57e		c6 3b		dec $3b				dec 	zTemp2+1
.a580						_MDLINoBorrow:
.a580		c6 3a		dec $3a				dec 	zTemp2
.a582		80 e6		bra $a56a			bra 	_MDLIInsert
.a584						_MDLIHaveSpace:
.a584		ac 2a 04	ldy $042a			ldy 	tokenOffset 				; bytes to copy
.a587		88		dey				dey 								; from offset-1 to 0
.a588						_MDLICopy:
.a588		b9 2a 04	lda $042a,y			lda 	tokenOffset,y
.a58b		91 30		sta ($30),y			sta 	(codePtr),y
.a58d		88		dey				dey
.a58e		10 f8		bpl $a588			bpl 	_MDLICopy
.a590		60		rts				rts
.a591						_MDLIError:
.a591		a9 06		lda #$06		lda	#6
.a593		4c 51 8f	jmp $8f51		jmp	ErrorHandler
.a596						MDLAppendLine:
.a596		86 37		stx $37				stx 	zTemp0+1 					; save new line at zTemp0
.a598		85 36		sta $36				sta 	zTemp0
.a59a		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a59c		85 38		sta $38				sta 	0+zTemp1
.a59e		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a5a0		85 39		sta $39				sta 	1+zTemp1
.a5a2		b2 38		lda ($38)			lda 	(zTemp1)
.a5a4		d0 0a		bne $a5b0			bne 	_MDLANoInitialise
.a5a6		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a5a8		8d 65 06	sta $0665			sta 	0+AppendPointer
.a5ab		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a5ad		8d 66 06	sta $0666			sta 	1+AppendPointer
.a5b0						_MDLANoInitialise:
.a5b0		18		clc				clc
.a5b1		ad 65 06	lda $0665			lda 	AppendPointer 				; copy append pointer to zTemp1 adding the offset as you go
.a5b4		85 38		sta $38				sta 	zTemp1
.a5b6		72 36		adc ($36)			adc 	(zTemp0)
.a5b8		8d 65 06	sta $0665			sta 	AppendPointer
.a5bb		ad 66 06	lda $0666			lda 	AppendPointer+1
.a5be		85 39		sta $39				sta 	zTemp1+1
.a5c0		69 00		adc #$00			adc 	#0
.a5c2		8d 66 06	sta $0666			sta 	AppendPointer+1
.a5c5		a0 00		ldy #$00			ldy 	#0
.a5c7						_MDLACopy:
.a5c7		b1 36		lda ($36),y			lda 	(zTemp0),y 					; copy new line in
.a5c9		91 38		sta ($38),y			sta 	(zTemp1),y
.a5cb		c8		iny				iny
.a5cc		98		tya				tya
.a5cd		d2 36		cmp ($36)			cmp 	(zTemp0) 					; done whole line
.a5cf		d0 f6		bne $a5c7			bne 	_MDLACopy
.a5d1		a9 00		lda #$00			lda 	#0 							; end of program.
.a5d3		91 38		sta ($38),y			sta 	(zTemp1),y
.a5d5		60		rts				rts
.0665						AppendPointer:
>0665								.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/memory.asm

.a5d6						MemoryNew:
.a5d6		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a5d8		85 30		sta $30				sta 	codePtr
.a5da		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a5dc		85 31		sta $31				sta 	codePtr+1
.a5de		a9 00		lda #$00			lda 	#0 							; write zero there erasing the program.
.a5e0		92 30		sta ($30)			sta 	(codePtr)
.a5e2		60		rts				rts
.a5e3						MemoryInline:
.a5e3		98		tya				tya 								; put address into stack,x
.a5e4		18		clc				clc  								; get the offset, add codePtr
.a5e5		65 30		adc $30				adc 	codePtr
.a5e7		95 58		sta $58,x			sta 	NSMantissa0,x 				; store the result in the mantissa.
.a5e9		a5 31		lda $31				lda 	codePtr+1
.a5eb		69 00		adc #$00			adc 	#0
.a5ed		95 60		sta $60,x			sta 	NSMantissa1,x
.a5ef		74 68		stz $68,x			stz 	NSMantissa2,x
.a5f1		74 70		stz $70,x			stz 	NSMantissa3,x
.a5f3		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/search.asm

.a5f4						MemorySearch:
.a5f4		85 36		sta $36				sta 	zTemp0 						; save line number in zTemp0
.a5f6		86 37		stx $37				stx 	zTemp0+1
.a5f8		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a5fa		85 30		sta $30				sta 	codePtr
.a5fc		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a5fe		85 31		sta $31				sta 	codePtr+1
.a600						_MTAXLoop:
.a600		b2 30		lda ($30)			lda 	(codePtr)
.a602		18		clc				clc
.a603		f0 21		beq $a626			beq 	_MTAXExit 					; reached end, exit with CC.
.a605		a0 01		ldy #$01			ldy 	#1 							; calculate current line# - requested line#
.a607		b1 30		lda ($30),y			lda 	(codePtr),y
.a609		38		sec				sec
.a60a		e5 36		sbc $36				sbc 	zTemp0
.a60c		85 38		sta $38				sta 	zTemp1 						; save interim to set Z
.a60e		c8		iny				iny 								; do the MSB
.a60f		b1 30		lda ($30),y			lda 	(codePtr),y
.a611		e5 37		sbc $37				sbc 	zTemp0+1
.a613		05 38		ora $38				ora 	zTemp1 						; will set Z if result is zero, doesn't affect carry flag
.a615		f0 0f		beq $a626			beq 	_MTAXExit	 				; found so exit (CS will be set)
.a617		b0 0d		bcs $a626			bcs 	_MTAXExit 					; current < required exit
.a619		18		clc				clc
.a61a		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.a61c		65 30		adc $30				adc 	codePtr
.a61e		85 30		sta $30				sta 	codePtr
.a620		90 02		bcc $a624			bcc 	_CREExit
.a622		e6 31		inc $31				inc 	codePtr+1 					; carry
.a624						_CREExit:
.a624		80 da		bra $a600			bra 	_MTAXLoop
.a626						_MTAXExit:
.a626		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/effects.asm

.a627						PingCommand:
.a627		5a		phy				phy 								; save pos
.a628		a9 01		lda #$01			lda 	#1 						; push channel.
.a62a		48		pha				pha
.a62b		a9 c8		lda #$c8			lda 	#200 						; pitch LSB
.a62d		a2 03		ldx #$03			ldx 	#3 						; length
.a62f		a0 00		ldy #$00			ldy 	#0 						; slide LSB
.a631		80 24		bra $a657			bra 	SoundEffectCommand
.a633						ZapCommand:
.a633		5a		phy				phy 								; save pos
.a634		a9 01		lda #$01			lda 	#1 						; push channel.
.a636		48		pha				pha
.a637		a9 ff		lda #$ff			lda 	#255 						; pitch LSB
.a639		a2 05		ldx #$05			ldx 	#5 						; length
.a63b		a0 14		ldy #$14			ldy 	#20 						; slide LSB
.a63d		80 18		bra $a657			bra 	SoundEffectCommand
.a63f						ShootCommand:
.a63f		5a		phy				phy 								; save pos
.a640		a9 03		lda #$03			lda 	#3 						; push channel.
.a642		48		pha				pha
.a643		a9 20		lda #$20			lda 	#32 						; pitch LSB
.a645		a2 02		ldx #$02			ldx 	#2 						; length
.a647		a0 00		ldy #$00			ldy 	#0 						; slide LSB
.a649		80 0c		bra $a657			bra 	SoundEffectCommand
.a64b						Explode:
.a64b		5a		phy				phy 								; save pos
.a64c		a9 03		lda #$03			lda 	#3 						; push channel.
.a64e		48		pha				pha
.a64f		a9 50		lda #$50			lda 	#80 						; pitch LSB
.a651		a2 05		ldx #$05			ldx 	#5 						; length
.a653		a0 00		ldy #$00			ldy 	#0 						; slide LSB
.a655		80 00		bra $a657			bra 	SoundEffectCommand
.a657						SoundEffectCommand:
.a657		8d 67 06	sta $0667			sta 	SoundCommandBlock 			; set up the command block in sound.asm
.a65a		9c 68 06	stz $0668			stz 	SoundCommandBlock+1
.a65d		a9 0f		lda #$0f			lda 	#15
.a65f		8d 69 06	sta $0669			sta 	SoundCommandBlock+2
.a662		8e 6a 06	stx $066a			stx 	SoundCommandBlock+3
.a665		8c 6b 06	sty $066b			sty 	SoundCommandBlock+4
.a668		9c 6c 06	stz $066c			stz 	SoundCommandBlock+5
.a66b		68		pla				pla
.a66c		09 10		ora #$10			ora 	#$10  						; execute command $11
.a66e		a2 67		ldx #$67			ldx 	#(SoundCommandBlock & $FF)
.a670		a0 06		ldy #$06			ldy 	#(SoundCommandBlock >> 8)
.a672		20 49 80	jsr $8049			jsr 	SNDCommand
.a675		7a		ply				ply
.a676		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/playing.asm

.a677						UnaryPlaying:
.a677		fa		plx				plx
.a678		20 13 9e	jsr $9e13			jsr 	Evaluate8BitInteger 		; get channel #
.a67b		48		pha				pha
.a67c		20 38 8f	jsr $8f38			jsr		CheckRightBracket
.a67f		68		pla				pla
.a680		c9 04		cmp #$04			cmp 	#4
.a682		b0 0c		bcs $a690			bcs 	_UPNotPlaying
.a684		09 20		ora #$20			ora 	#$20 						; query playing ?
.a686		20 49 80	jsr $8049			jsr 	SNDCommand
.a689		c9 00		cmp #$00			cmp 	#0
.a68b		f0 03		beq $a690			beq 	_UPNotPlaying
.a68d		4c be 8f	jmp $8fbe			jmp 	ReturnTrue
.a690						_UPNotPlaying:
.a690		4c c9 8f	jmp $8fc9			jmp 	ReturnFalse

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/sound.asm

.a693						SoundCommand:
.a693		b1 30		lda ($30),y			lda 	(codePtr),y
.a695		c9 c3		cmp #$c3			cmp 	#KWD_OFF 					; SOUND OFF ?
.a697		d0 09		bne $a6a2			bne 	_SNDMain
.a699		c8		iny				iny 								; skip OFF
.a69a		a9 3f		lda #$3f			lda 	#$3F 						; call command $3F (silence)
.a69c		5a		phy				phy
.a69d		20 49 80	jsr $8049			jsr 	SNDCommand
.a6a0		7a		ply				ply
.a6a1		60		rts				rts
.a6a2						_SNDMain:
.a6a2		a2 00		ldx #$00			ldx 	#0
.a6a4		20 13 9e	jsr $9e13			jsr 	Evaluate8BitInteger 		; channel
.a6a7		c9 04		cmp #$04			cmp 	#4 							; must be 0-3
.a6a9		b0 4b		bcs $a6f6			bcs 	_SndError
.a6ab		e8		inx				inx 								; do the rest in slot 1.
.a6ac		20 40 8f	jsr $8f40			jsr 	CheckComma
.a6af		20 f8 9d	jsr $9df8			jsr 	Evaluate16BitInteger 		; Pitch
.a6b2		b5 60		lda $60,x			lda 	NSMantissa1,x 				; must be 10 bit
.a6b4		c9 10		cmp #$10			cmp 	#16
.a6b6		b0 3e		bcs $a6f6			bcs 	_SndError
.a6b8		8d 68 06	sta $0668			sta 	SoundCommandBlock+1 		; Pitch (2 bytes + 0)
.a6bb		b5 58		lda $58,x			lda 	NSMantissa0,x
.a6bd		8d 67 06	sta $0667			sta 	SoundCommandBlock
.a6c0		20 40 8f	jsr $8f40			jsr 	CheckComma
.a6c3		20 13 9e	jsr $9e13			jsr 	Evaluate8BitInteger 		; Length (1 byte + 3)
.a6c6		8d 6a 06	sta $066a			sta 	SoundCommandBlock+3
.a6c9		a9 0f		lda #$0f			lda 	#15
.a6cb		8d 69 06	sta $0669			sta 	SoundCommandBlock+2 		; Volume (1 byte + 2)
.a6ce		9c 6b 06	stz $066b			stz 	SoundCommandBlock+4 		; default slide (2 bytes +4)
.a6d1		9c 6c 06	stz $066c			stz 	SoundCommandBlock+5
.a6d4		b1 30		lda ($30),y			lda 	(codePtr),y
.a6d6		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.a6d8		d0 0e		bne $a6e8			bne 	_SNDPlay
.a6da		c8		iny				iny
.a6db		20 02 9e	jsr $9e02			jsr 	Evaluate16BitIntegerSigned 	; Slide
.a6de		b5 58		lda $58,x			lda 	NSMantissa0,x 				; Slide (2 bytes + 4)
.a6e0		8d 6b 06	sta $066b			sta 	SoundCommandBlock+4
.a6e3		b5 60		lda $60,x			lda 	NSMantissa1,x
.a6e5		8d 6c 06	sta $066c			sta 	SoundCommandBlock+5
.a6e8						_SNDPlay:
.a6e8		5a		phy				phy
.a6e9		a5 58		lda $58				lda 	NSMantissa0 				; channel.
.a6eb		09 10		ora #$10			ora 	#$10 						; 1x = Queue sound
.a6ed		a2 67		ldx #$67			ldx 	#(SoundCommandBlock & $FF)
.a6ef		a0 06		ldy #$06			ldy 	#(SoundCommandBlock >> 8)
.a6f1		20 49 80	jsr $8049			jsr 	SNDCommand
.a6f4		7a		ply				ply
.a6f5		60		rts				rts
.a6f6						_SndError:
.a6f6		4c fb 9f	jmp $9ffb			jmp 	RangeError
.0667						SoundCommandBlock:
>0667								.fill 	6

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/bytes.asm

.a6f9						StackPushByte:
.a6f9		48		pha				pha 								; save byte on stack
.a6fa		a5 34		lda $34				lda 	BasicStack 					; decrement basic stack pointer
.a6fc		d0 08		bne $a706			bne 	_SPBNoBorrow
.a6fe		c6 35		dec $35				dec 	BasicStack+1 				; borrow
.a700		a5 35		lda $35				lda 	BasicStack+1 				; check range.
.a702		c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a704		90 06		bcc $a70c			bcc 	_SPBMemory
.a706						_SPBNoBorrow:
.a706		c6 34		dec $34				dec 	BasicStack
.a708		68		pla				pla 								; get back and write
.a709		92 34		sta ($34)			sta 	(BasicStack)
.a70b		60		rts				rts
.a70c						_SPBMemory:
.a70c		a9 12		lda #$12		lda	#18
.a70e		4c 51 8f	jmp $8f51		jmp	ErrorHandler
.a711						StackPopByte:
.a711		b2 34		lda ($34)			lda 	(BasicStack) 				; bump the stack pointer.
.a713		e6 34		inc $34				inc 	BasicStack
.a715		d0 02		bne $a719			bne 	_SPBNoCarry
.a717		e6 35		inc $35				inc 	BasicStack+1
.a719						_SPBNoCarry:
.a719		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/frames.asm

.a71a						StackOpen:
.a71a		48		pha				pha 								; save frame byte
.a71b		29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.a71d		0a		asl a				asl 	a 							; claim twice this for storage
.a71e		49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.a720		38		sec				sec 								; so basically subtracting from
.a721		65 34		adc $34				adc 	basicStack 	 				; basicStack
.a723		85 34		sta $34				sta 	basicStack
.a725		b0 09		bcs $a730			bcs 	_SONoBorrow
>a727		db						.byte 	$DB 						; causes a break in the emulator
.a728		c6 35		dec $35				dec 	basicStack+1
.a72a		a5 35		lda $35				lda 	basicStack+1 				; have we reached stack overflow
.a72c		c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a72e		90 04		bcc $a734			bcc 	_SOMemory
.a730						_SONoBorrow:
.a730		68		pla				pla 								; get marker back and write at TOS
.a731		92 34		sta ($34)			sta 	(basicStack)
.a733		60		rts				rts
.a734						_SOMemory:
.a734		a9 12		lda #$12		lda	#18
.a736		4c 51 8f	jmp $8f51		jmp	ErrorHandler
.a739						StackClose:
.a739		b2 34		lda ($34)			lda 	(basicStack) 				; get TOS marker
.a73b		29 0f		and #$0f			and 	#$0F 						; bytes to add back
.a73d		0a		asl a				asl 	a 							; claim twice this.
.a73e		65 34		adc $34				adc 	basicStack 					; add to the stack pointer.
.a740		85 34		sta $34				sta 	basicStack
.a742		90 02		bcc $a746			bcc 	_SCExit
.a744		e6 35		inc $35				inc 	basicStack+1
.a746						_SCExit:
.a746		60		rts				rts
.a747						StackCheckFrame:
.a747		48		pha				pha
.a748						_StackRemoveLocals:
.a748		b2 34		lda ($34)			lda 	(basicStack) 				; check for local, keep popping them
.a74a		c9 03		cmp #$03			cmp 	#STK_LOCALS+1 				; is the frame a local ? S or N are 1/0
.a74c		b0 05		bcs $a753			bcs 	_SCNoLocal
.a74e		20 35 8a	jsr $8a35			jsr 	LocalPopValue 				; restore the local value
.a751		80 f5		bra $a748			bra 	_StackRemoveLocals 			; gr round again
.a753						_SCNoLocal:
.a753		68		pla				pla 								; get the frame check.
.a754		52 34		eor ($34)			eor 	(basicStack) 				; xor with toS marker
.a756		29 f0		and #$f0			and 	#$F0 						; check type bits
.a758		d0 01		bne $a75b			bne 	_SCFError 					; different, we have structures mixed up
.a75a		60		rts				rts
.a75b						_SCFError:
.a75b		8a		txa				txa 								; report error X
.a75c		4c 51 8f	jmp $8f51			jmp 	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/location.asm

.a75f						STKSaveCodePosition:
.a75f		5a		phy				phy
.a760		98		tya				tya 								; save Y
.a761		a0 05		ldy #$05			ldy 	#5
.a763		91 34		sta ($34),y			sta 	(basicStack),y
.a765		88		dey				dey 								; save Code Pointer
.a766						_STKSaveLoop:
.a766		b9 2f 00	lda $002f,y			lda 	safePtr-1,y 				; allows us to access the pointer w/out issues.
.a769		91 34		sta ($34),y			sta 	(basicStack),y
.a76b		88		dey				dey
.a76c		d0 f8		bne $a766			bne 	_STKSaveLoop
.a76e		7a		ply				ply
.a76f		60		rts				rts
.a770						STKLoadCodePosition:
.a770		a0 01		ldy #$01			ldy 	#1 							; load code pointer back
.a772						_STKLoadLoop:
.a772		b1 34		lda ($34),y			lda 	(basicStack),y
.a774		99 2f 00	sta $002f,y			sta 	safePtr-1,y
.a777		c8		iny				iny
.a778		c0 05		cpy #$05			cpy 	#5
.a77a		d0 f6		bne $a772			bne 	_STKLoadLoop
.a77c		b1 34		lda ($34),y			lda 	(basicStack),y 				; get Y offset
.a77e		a8		tay				tay
.a77f		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/setup.asm

.a780						StackReset:
.a780		a9 ff		lda #$ff			lda 	#((BasicStackBase+BasicStackSize-1) & $FF)
.a782		85 34		sta $34				sta 	0+basicStack
.a784		a9 0f		lda #$0f			lda 	#((BasicStackBase+BasicStackSize-1) >> 8)
.a786		85 35		sta $35				sta 	1+basicStack
.a788		a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.a78a		92 34		sta ($34)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.a78c		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/concrete.asm

.a78d						StringConcrete:
.a78d		5a		phy				phy 								; save position on stack
.a78e		20 8b 9a	jsr $9a8b			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a791		b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy target string to zTemp1
.a793		85 38		sta $38				sta 	zTemp1
.a795		b5 60		lda $60,x			lda 	NSMantissa1,x
.a797		85 39		sta $39				sta 	zTemp1+1
.a799		a0 ff		ldy #$ff			ldy 	#$FF	 					; calculate string length
.a79b						_SALength:
.a79b		c8		iny				iny
.a79c		b1 38		lda ($38),y			lda 	(zTemp1),y
.a79e		d0 fb		bne $a79b			bne 	_SALength
.a7a0		c0 fd		cpy #$fd			cpy 	#253 						; string too long - cannot concrete.
.a7a2		b0 3d		bcs $a7e1			bcs 	_SALengthError
.a7a4		98		tya				tya 				 				; length of the new string
.a7a5		18		clc				clc
.a7a6		69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.a7a8		90 02		bcc $a7ac			bcc 	_SAHaveLength
.a7aa		a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.a7ac						_SAHaveLength:
.a7ac		48		pha				pha 								; save length.
.a7ad		38		sec				sec
.a7ae		49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.a7b0		6d 0e 04	adc $040e			adc 	StringMemory
.a7b3		8d 0e 04	sta $040e			sta 	StringMemory
.a7b6		85 3a		sta $3a				sta 	zTemp2 						; update storage address
.a7b8		95 58		sta $58,x			sta 	NSMantissa0,x 				; update mantissa address
.a7ba		a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.a7bc		6d 0f 04	adc $040f			adc 	StringMemory+1
.a7bf		8d 0f 04	sta $040f			sta 	StringMemory+1
.a7c2		85 3b		sta $3b				sta 	zTemp2+1
.a7c4		95 60		sta $60,x			sta 	NSMantissa1,x
.a7c6		68		pla				pla 								; save length-3 (chars allowed) in first byte
.a7c7		38		sec				sec
.a7c8		e9 03		sbc #$03			sbc 	#3
.a7ca		92 3a		sta ($3a)			sta 	(zTemp2)
.a7cc		a9 00		lda #$00			lda 	#0 							; clear the status byte.
.a7ce		a0 01		ldy #$01			ldy 	#1
.a7d0		91 3a		sta ($3a),y			sta 	(zTemp2),y
.a7d2						_SACopyNewString:
.a7d2		a0 00		ldy #$00			ldy 	#0
.a7d4						_SACopyNSLoop:
.a7d4		b1 38		lda ($38),y			lda 	(zTemp1),y 					; get character
.a7d6		c8		iny				iny 								; write two on in string storage
.a7d7		c8		iny				iny
.a7d8		91 3a		sta ($3a),y			sta 	(zTemp2),y
.a7da		88		dey				dey 								; this makes it one one.
.a7db		c9 00		cmp #$00			cmp 	#0 							; until EOS copied
.a7dd		d0 f5		bne $a7d4			bne 	_SACopyNSLoop
.a7df		7a		ply				ply
.a7e0		60		rts				rts
.a7e1						_SALengthError:
.a7e1		a9 09		lda #$09		lda	#9
.a7e3		4c 51 8f	jmp $8f51		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/stringalloc.asm

.a7e6						StringSystemInitialise:
.a7e6		a9 ff		lda #$ff			lda 	#((EndVariableSpace-1) & $FF)
.a7e8		8d 0e 04	sta $040e			sta 	0+StringMemory
.a7eb		a9 1f		lda #$1f			lda 	#((EndVariableSpace-1) >> 8)
.a7ed		8d 0f 04	sta $040f			sta 	1+StringMemory
.a7f0		9c ff 1f	stz $1fff			stz 	EndVariableSpace-1 			; put a zero at the end, so know end of string memory.
.a7f3		60		rts				rts
.a7f4						StringSpaceInitialise:
.a7f4		20 8b 9a	jsr $9a8b			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a7f7		a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.a7f9		8d 10 04	sta $0410			sta 	StringInitialised
.a7fc		ad 0e 04	lda $040e			lda 	StringMemory 				; allocate 256 bytes for one concreted string
.a7ff		8d 11 04	sta $0411			sta 	StringTempPointer 			; so temporary string space is allocated below that.
.a802		ad 0f 04	lda $040f			lda 	StringMemory+1
.a805		3a		dec a				dec 	a
.a806		8d 12 04	sta $0412			sta 	StringTempPointer+1
.a809		60		rts				rts
.a80a						StringTempAllocate:
.a80a		c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.a80c		b0 30		bcs $a83e			bcs 	_STALength
.a80e		2c 10 04	bit $0410			bit 	StringInitialised 			; already initialised
.a811		30 05		bmi $a818			bmi 	_STAAllocate
.a813		48		pha				pha 								; save value to subtract.
.a814		20 f4 a7	jsr $a7f4			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.a817		68		pla				pla 								; restore it
.a818						_STAAllocate:
.a818		49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.a81a		18		clc				clc  								; deliberate allows one more
.a81b		6d 11 04	adc $0411			adc 	StringTempPointer 			; subtract from temp pointer
.a81e		8d 11 04	sta $0411			sta 	StringTempPointer
.a821		95 58		sta $58,x			sta 	NSMantissa0,x 				; address in mantissa
.a823		85 3c		sta $3c				sta 	zsTemp 						; and zsTemp
.a825		ad 12 04	lda $0412			lda 	StringTempPointer+1
.a828		69 ff		adc #$ff			adc 	#$FF
.a82a		8d 12 04	sta $0412			sta 	StringTempPointer+1
.a82d		85 3d		sta $3d				sta 	zsTemp+1
.a82f		95 60		sta $60,x			sta 	NSMantissa1,x
.a831		74 68		stz $68,x			stz 	NSMantissa2,x 				; set the typing data and the upper address bytes.
.a833		74 70		stz $70,x			stz 	NSMantissa3,x
.a835		a9 10		lda #$10			lda 	#NSTString
.a837		95 50		sta $50,x			sta 	NSStatus,x
.a839		a9 00		lda #$00			lda 	#0 							; clear the target string
.a83b		92 3c		sta ($3c)			sta 	(zsTemp)
.a83d		60		rts				rts
.a83e						_STALength:
.a83e		a9 09		lda #$09		lda	#9
.a840		4c 51 8f	jmp $8f51		jmp	ErrorHandler
.a843						StringTempWrite:
.a843		48		pha				pha
.a844		92 3c		sta ($3c)			sta 	(zsTemp) 					; write byte
.a846		e6 3c		inc $3c				inc 	zsTemp 						; bump pointer
.a848		d0 02		bne $a84c			bne 	_STWNoCarry
.a84a		e6 3d		inc $3d				inc 	zsTemp+1
.a84c						_STWNoCarry:
.a84c		a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.a84e		92 3c		sta ($3c)			sta 	(zsTemp)
.a850		68		pla				pla
.a851		60		rts				rts

;******  Return to file: _basic.asm

.a852						StartModuleCode:

;******  Processing file: ../modules/_build/_hardware.module

=1						hardwareIntegrated=1
=0						CONBlack = 0
=1						CONWhite = 1
=2						CONRed = 2
=3						CONCyan = 3
=4						CONPurple = 4
=5						CONGreen = 5
=6						CONBlue = 6
=7						CONYellow = 7
=8						CONOrange = 8
=9						CONBrown = 9
=10						CONYellowGreen = 10
=11						CONRosa = 11
=12						CONBlueGreen = 12
=13						CONLightBlue = 13
=14						CONPink = 14
=15						CONLightGreen = 15
=7						CONForeground = CONYellow
=6						CONBackground = CONBlue
=5						CLICommandLine = CONGreen
=0						CLIFComment = CONBlack
=7						CLIBComment = CONYellow
=9						CLILineNumber = CONBrown
=3						CLIToken = CONCyan
=13						CLIConstant = CONLightBlue
=7						CLIIdentifier = CONYellow
=10						CLIPunctuation = CONYellowGreen
=1						CLIData = CONWhite
.c000	a000					Export_EXTPrintCharacter:
.c000	a000					PAGEDPrintCharacter:
.c000	a000	48		pha				pha
.c001	a001	da		phx				phx
.c002	a002	5a		phy				phy
.c003	a003	a6 01		ldx $01				ldx 	1
.c005	a005	da		phx				phx
.c006	a006	ac 6e 06	ldy $066e			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.c009	a009	09 00		ora #$00			ora 	#$00 						; check $80-$FF
.c00b	a00b	30 48		bmi $a055			bmi 	_EXPCColour
.c00d	a00d	c9 20		cmp #$20			cmp 	#$20 						; check $00-$1F
.c00f	a00f	90 4d		bcc $a05e			bcc 	_EXPCControl
.c011	a011	a2 02		ldx #$02			ldx 	#2 							; select char memory
.c013	a013	86 01		stx $01				stx 	1
.c015	a015	91 40		sta ($40),y			sta 	(EXTAddress),y
.c017	a017	e6 01		inc $01				inc 	1 							; select colour memory
.c019	a019	ad 6f 06	lda $066f			lda 	EXTTextColour
.c01c	a01c	91 40		sta ($40),y			sta 	(EXTAddress),y
.c01e	a01e	c8		iny				iny 								; advance horizontal position
.c01f	a01f	8c 6e 06	sty $066e			sty 	EXTColumn
.c022	a022	cc 70 06	cpy $0670			cpy 	EXTScreenWidth 				; reached RHS ?
.c025	a025	90 63		bcc $a08a			bcc 	_EXPCExit 					; no, then exit.
.c027	a027					_EXPCCRLF:
.c027	a027	ee 6d 06	inc $066d			inc 	EXTRow  					; bump row
.c02a	a02a	9c 6e 06	stz $066e			stz 	EXTColumn 					; back to column 0
.c02d	a02d	ad 6d 06	lda $066d			lda 	EXTRow 						; check if reached the bottom ?
.c030	a030	cd 71 06	cmp $0671			cmp 	EXTScreenHeight 			; if so, then scroll.
.c033	a033	f0 18		beq $a04d			beq 	_EXPCScroll
.c035	a035	18		clc				clc 								; add width to address.
.c036	a036	a5 40		lda $40				lda 	EXTAddress
.c038	a038	6d 70 06	adc $0670			adc 	EXTScreenWidth
.c03b	a03b	85 40		sta $40				sta 	EXTAddress
.c03d	a03d	90 4b		bcc $a08a			bcc 	_EXPCExit
.c03f	a03f	e6 41		inc $41				inc 	EXTAddress+1
.c041	a041	80 47		bra $a08a			bra 	_EXPCExit
.c043	a043					_EXPCLeft:
.c043	a043	ce 6e 06	dec $066e			dec 	EXTColumn
.c046	a046	10 42		bpl $a08a			bpl 	_EXPCExit
.c048	a048					_EXPCBegin:
.c048	a048	9c 6e 06	stz $066e			stz 	EXTColumn
.c04b	a04b	80 3d		bra $a08a			bra 	_EXPCExit
.c04d	a04d					_EXPCScroll:
.c04d	a04d	ce 6d 06	dec $066d			dec 	EXTRow 						; the height-1 th line.
.c050	a050	20 3b a1	jsr $a13b			jsr 	EXTScreenScroll 			; scroll the screen
.c053	a053	80 35		bra $a08a			bra 	_EXPCExit
.c055	a055					_EXPCColour:
.c055	a055	c9 a0		cmp #$a0			cmp 	#$A0						; 80-9F set foreground/background
.c057	a057	b0 31		bcs $a08a			bcs 	_EXPCExit
.c059	a059	20 1b a1	jsr $a11b			jsr 	_EXPCHandleColour
.c05c	a05c	80 2c		bra $a08a			bra 	_EXPCExit
.c05e	a05e					_EXPCControl:
.c05e	a05e	c9 11		cmp #$11			cmp 	#$11 						; only handle 00-10.
.c060	a060	b0 28		bcs $a08a			bcs 	_EXPCExit
.c062	a062	0a		asl a				asl 	a 							; double into X
.c063	a063	aa		tax				tax
.c064	a064	7c f9 a0	jmp ($a0f9,x)			jmp 	(_EXPCActionTable,x) 		; and execute code.
.c067	a067					_EXPCUp:
.c067	a067	ad 6d 06	lda $066d			lda 	EXTRow 						; already at top ?
.c06a	a06a	f0 1e		beq $a08a			beq 	_EXPCExit
.c06c	a06c	ce 6d 06	dec $066d			dec 	EXTRow 						; up one in position/address
.c06f	a06f	38		sec				sec
.c070	a070	a5 40		lda $40				lda 	EXTAddress
.c072	a072	ed 70 06	sbc $0670			sbc 	EXTScreenWidth
.c075	a075	85 40		sta $40				sta 	EXTAddress
.c077	a077	b0 11		bcs $a08a			bcs 	_EXPCExit
.c079	a079	c6 41		dec $41				dec 	EXTAddress+1
.c07b	a07b	80 0d		bra $a08a			bra 	_EXPCExit
.c07d	a07d					_EXPCRight:
.c07d	a07d	c8		iny				iny
.c07e	a07e	8c 6e 06	sty $066e			sty 	EXTColumn
.c081	a081	cc 70 06	cpy $0670			cpy 	EXTScreenWidth
.c084	a084	d0 04		bne $a08a			bne 	_EXPCExit
.c086	a086	88		dey				dey
.c087	a087					_EXPCSetColumnY:
.c087	a087	8c 6e 06	sty $066e			sty 	EXTColumn
.c08a	a08a					_EXPCExit:
.c08a	a08a	20 90 a1	jsr $a190			jsr 	EXTSetHardwareCursor 		; place the physical cursor.
.c08d	a08d	68		pla				pla
.c08e	a08e	85 01		sta $01				sta 	1
.c090	a090	7a		ply				ply
.c091	a091	fa		plx				plx
.c092	a092	68		pla				pla
.c093	a093	60		rts				rts
.c094	a094					_EXPCClearScreen:
.c094	a094	20 4d a1	jsr $a14d			jsr		EXTClearScreenCode
.c097	a097	80 f1		bra $a08a			bra 	_EXPCExit
.c099	a099					_EXPCDown:
.c099	a099	ad 71 06	lda $0671			lda 	EXTScreenHeight 			; at the bottom
.c09c	a09c	3a		dec a				dec 	a
.c09d	a09d	cd 6d 06	cmp $066d			cmp 	EXTRow
.c0a0	a0a0	f0 e8		beq $a08a			beq 	_EXPCExit
.c0a2	a0a2	ee 6d 06	inc $066d			inc 	EXTRow 						; down one in position/address
.c0a5	a0a5	18		clc				clc
.c0a6	a0a6	a5 40		lda $40				lda 	EXTAddress
.c0a8	a0a8	6d 70 06	adc $0670			adc 	EXTScreenWidth
.c0ab	a0ab	85 40		sta $40				sta 	EXTAddress
.c0ad	a0ad	90 db		bcc $a08a			bcc 	_EXPCExit
.c0af	a0af	e6 41		inc $41				inc 	EXTAddress+1
.c0b1	a0b1	80 d7		bra $a08a			bra 	_EXPCExit
.c0b3	a0b3					_EXPCTab:
.c0b3	a0b3	ad 6e 06	lda $066e			lda 	EXTColumn 					; next tab stop
.c0b6	a0b6	29 f8		and #$f8			and 	#$F8
.c0b8	a0b8	18		clc				clc
.c0b9	a0b9	69 08		adc #$08			adc 	#8
.c0bb	a0bb	8d 6e 06	sta $066e			sta 	EXTColumn
.c0be	a0be	cd 70 06	cmp $0670			cmp 	EXTScreenWidth 				; too far, stick end of line.
.c0c1	a0c1	90 c7		bcc $a08a			bcc 	_EXPCExit
.c0c3	a0c3	80 10		bra $a0d5			bra 	_EXPCEnd
.c0c5	a0c5					_EXPCBackSpace:
.c0c5	a0c5	88		dey				dey
.c0c6	a0c6	30 c2		bmi $a08a			bmi 	_EXPCExit
.c0c8	a0c8	ce 6e 06	dec $066e			dec 	EXTColumn
.c0cb	a0cb	a9 02		lda #$02			lda 	#2
.c0cd	a0cd	85 01		sta $01				sta 	1
.c0cf	a0cf	a9 20		lda #$20			lda 	#32
.c0d1	a0d1	91 40		sta ($40),y			sta 	(EXTAddress),y
.c0d3	a0d3	80 b5		bra $a08a			bra 	_EXPCExit
.c0d5	a0d5					_EXPCEnd:
.c0d5	a0d5	a9 02		lda #$02			lda 	#2 							; access text screen
.c0d7	a0d7	85 01		sta $01				sta 	1
.c0d9	a0d9	ac 70 06	ldy $0670			ldy 	EXTScreenWidth 				; point to last character
.c0dc	a0dc	88		dey				dey
.c0dd	a0dd					_EXPCEndSearch:
.c0dd	a0dd	88		dey				dey 								; if past start, move to col 0.
.c0de	a0de	30 06		bmi $a0e6			bmi 	_EXPCFound
.c0e0	a0e0	b1 40		lda ($40),y			lda 	(EXTAddress),y 				; keep going back till non space found
.c0e2	a0e2	c9 20		cmp #$20			cmp 	#' '
.c0e4	a0e4	f0 f7		beq $a0dd			beq 	_EXPCEndSearch
.c0e6	a0e6					_EXPCFound:
.c0e6	a0e6	c8		iny				iny 								; move to following cell.
.c0e7	a0e7	80 9e		bra $a087			bra 	_EXPCSetColumnY
.c0e9	a0e9					_EXPCClearEOL:
.c0e9	a0e9	a9 02		lda #$02			lda 	#2 							; access character RAM
.c0eb	a0eb	85 01		sta $01				sta 	1
.c0ed	a0ed	a9 20		lda #$20			lda 	#' ' 						; write space
.c0ef	a0ef	91 40		sta ($40),y			sta 	(EXTAddress),y
.c0f1	a0f1	c8		iny				iny
.c0f2	a0f2	cc 70 06	cpy $0670			cpy 	EXTScreenWidth 				; until RHS of screen.
.c0f5	a0f5	90 f2		bcc $a0e9			bcc 	_EXPCClearEOL
.c0f7	a0f7	80 91		bra $a08a			bra 	_EXPCExit
.c0f9	a0f9					_EXPCActionTable:
>c0f9	a0f9	8a a0						.word 	_EXPCExit 					; 00
>c0fb	a0fb	48 a0						.word 	_EXPCBegin 					; 01 A Start of Line
>c0fd	a0fd	43 a0						.word 	_EXPCLeft 					; 02 B Left
>c0ff	a0ff	8a a0						.word 	_EXPCExit 					; 03 <Break>
>c101	a101	8a a0						.word 	_EXPCExit 					; 04
>c103	a103	d5 a0						.word 	_EXPCEnd 					; 05 E End of Line
>c105	a105	7d a0						.word 	_EXPCRight 					; 06 F Right
>c107	a107	8a a0						.word 	_EXPCExit 					; 07
>c109	a109	c5 a0						.word 	_EXPCBackspace 				; 08 H Backspace
>c10b	a10b	b3 a0						.word 	_EXPCTab 					; 09 I Tab
>c10d	a10d	8a a0						.word 	_EXPCExit 					; 0A
>c10f	a10f	e9 a0						.word 	_EXPCClearEOL 				; 0B K Clear to EOL
>c111	a111	94 a0						.word 	_EXPCClearScreen			; 0C L CLS
>c113	a113	27 a0						.word 	_EXPCCRLF 					; 0D M CR/LF
>c115	a115	99 a0						.word 	_EXPCDown 					; 0E N Down
>c117	a117	8a a0						.word 	_EXPCExit 					; 0F
>c119	a119	67 a0						.word 	_EXPCUp 					; 10 P Up
.c11b	a11b					_EXPCHandleColour
.c11b	a11b	c9 90		cmp #$90			cmp 	#$90 						; 8x foreground 9x background
.c11d	a11d	b0 16		bcs $a135			bcs 	_EXPCBackground
.c11f	a11f	0a		asl a				asl 	a 							; shift it 4 bits to the right.
.c120	a120	0a		asl a				asl 	a
.c121	a121	0a		asl a				asl 	a
.c122	a122	0a		asl a				asl 	a
.c123	a123	a2 0f		ldx #$0f			ldx 	#$0F 						; Mask in X
.c125	a125					_EXPCUpdate:
.c125	a125	48		pha				pha 								; save new colour
.c126	a126	8a		txa				txa 								; get mask
.c127	a127	2d 6f 06	and $066f			and 	EXTTextColour 				; mask out old.
.c12a	a12a	8d 6f 06	sta $066f			sta 	EXTTextColour
.c12d	a12d	68		pla				pla 								; or in new colour
.c12e	a12e	0d 6f 06	ora $066f			ora 	EXTTextColour
.c131	a131	8d 6f 06	sta $066f			sta 	EXTTextColour
.c134	a134	60		rts				rts
.c135	a135					_EXPCBackground:
.c135	a135	29 0f		and #$0f			and 	#$0F 						; get the colour
.c137	a137	a2 f0		ldx #$f0			ldx 	#$F0 						; mask
.c139	a139	80 ea		bra $a125			bra 	_EXPCUpdate
.c13b	a13b					EXTScreenScroll:
.c13b	a13b	a9 02		lda #$02			lda 	#2 							; select text page
.c13d	a13d	85 01		sta $01				sta 	1
.c13f	a13f	a9 20		lda #$20			lda		#32 						; fill with space
.c141	a141	20 54 a2	jsr $a254			jsr 	EXTScrollFill
.c144	a144	e6 01		inc $01				inc 	1 							; select colour page
.c146	a146	ad 6f 06	lda $066f			lda 	EXTTextColour
.c149	a149	20 54 a2	jsr $a254			jsr 	EXTScrollFill
.c14c	a14c	60		rts				rts
.c14d	a14d					EXTClearScreenCode:
.c14d	a14d	a9 02		lda #$02			lda 	#2 							; select text page
.c14f	a14f	85 01		sta $01				sta 	1
.c151	a151	a9 20		lda #$20			lda		#32 						; fill with space
.c153	a153	20 60 a1	jsr $a160			jsr 	_EXTCSFill
.c156	a156	e6 01		inc $01				inc 	1 							; select colour page
.c158	a158	ad 6f 06	lda $066f			lda 	EXTTextColour
.c15b	a15b	20 60 a1	jsr $a160			jsr 	_EXTCSFill
.c15e	a15e	80 22		bra $a182			bra 	EXTHomeCursor
.c160	a160					_EXTCSFill:
.c160	a160	aa		tax				tax
.c161	a161	a9 00		lda #$00			lda 	#EXTMemory & $FF
.c163	a163	85 40		sta $40				sta 	EXTAddress
.c165	a165	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.c167	a167	85 41		sta $41				sta 	EXTAddress+1
.c169	a169					_EXTCSFill1:
.c169	a169	a0 00		ldy #$00			ldy 	#0
.c16b	a16b	8a		txa				txa
.c16c	a16c					_EXTCSFill2:
.c16c	a16c	91 40		sta ($40),y			sta 	(EXTAddress),y
.c16e	a16e	c8		iny				iny
.c16f	a16f	d0 fb		bne $a16c			bne 	_EXTCSFill2
.c171	a171	e6 41		inc $41				inc 	EXTAddress+1
.c173	a173	a5 41		lda $41				lda 	EXTAddress+1
.c175	a175	c9 d2		cmp #$d2			cmp 	#$D2
.c177	a177	d0 f0		bne $a169			bne 	_EXTCSFill1
.c179	a179	8a		txa				txa
.c17a	a17a					_EXTCSFill3:
.c17a	a17a	91 40		sta ($40),y			sta 	(EXTAddress),y
.c17c	a17c	c8		iny				iny
.c17d	a17d	c0 c0		cpy #$c0			cpy 	#$C0
.c17f	a17f	d0 f9		bne $a17a			bne 	_EXTCSFill3
.c181	a181	60		rts				rts
.c182	a182					EXTHomeCursor:
.c182	a182	9c 6d 06	stz $066d			stz 	EXTRow 						; reset row & column
.c185	a185	9c 6e 06	stz $066e			stz 	EXTColumn
.c188	a188	a9 00		lda #$00			lda 	#EXTMemory & $FF 			; set address
.c18a	a18a	85 40		sta $40				sta 	EXTAddress
.c18c	a18c	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.c18e	a18e	85 41		sta $41				sta 	EXTAddress+1
.c190	a190					EXTSetHardwareCursor:
.c190	a190	64 01		stz $01				stz 	1 							; I/O Page zero
.c192	a192	a9 05		lda #$05			lda 	#1+4 						; enable cursor
.c194	a194	8d 10 d0	sta $d010			sta 	$D010
.c197	a197	a9 b1		lda #$b1			lda 	#$B1
.c199	a199	8d 12 d0	sta $d012			sta 	$D012
.c19c	a19c	ad 6e 06	lda $066e			lda 	EXTColumn
.c19f	a19f	8d 14 d0	sta $d014			sta 	$D014 						; set cursor position
.c1a2	a1a2	9c 15 d0	stz $d015			stz 	$D015
.c1a5	a1a5	ad 6d 06	lda $066d			lda 	EXTRow
.c1a8	a1a8	8d 16 d0	sta $d016			sta 	$D016
.c1ab	a1ab	9c 17 d0	stz $d017			stz 	$D017
.c1ae	a1ae	60		rts				rts
.c1af	a1af					Export_EXTInputLine:
.c1af	a1af	48		pha				pha
.c1b0	a1b0	da		phx				phx
.c1b1	a1b1	5a		phy				phy
.c1b2	a1b2	a5 01		lda $01				lda 	1 							; save I/O page
.c1b4	a1b4	48		pha				pha
.c1b5	a1b5					_EILLoop:
.c1b5	a1b5	20 cf a2	jsr $a2cf			jsr 	PagedInputSingleCharacter
.c1b8	a1b8	c9 0d		cmp #$0d			cmp 	#13 						; scrape line if exit.
.c1ba	a1ba	f0 44		beq $a200			beq 	_EILExit
.c1bc	a1bc	c9 04		cmp #$04			cmp 	#4 							; Ctrl+D delete at cursor
.c1be	a1be	f0 2a		beq $a1ea			beq 	_EILDelete
.c1c0	a1c0	c9 08		cmp #$08			cmp 	#8 							; Ctrl+H backspace
.c1c2	a1c2	f0 1c		beq $a1e0			beq 	_EILBackspace
.c1c4	a1c4	c9 20		cmp #$20			cmp 	#' '						; < space, print it
.c1c6	a1c6	90 12		bcc $a1da			bcc 	_EILPrintLoop
.c1c8	a1c8	c9 7f		cmp #$7f			cmp 	#$7F 						; if -ve print it
.c1ca	a1ca	b0 0e		bcs $a1da			bcs 	_EILPrintLoop
.c1cc	a1cc	48		pha				pha 								; save character
.c1cd	a1cd	a9 02		lda #$02			lda 	#2  						; insert a space
.c1cf	a1cf	85 01		sta $01				sta 	1
.c1d1	a1d1	20 42 a2	jsr $a242			jsr 	EXTILInsert 				; insert in text screen
.c1d4	a1d4	e6 01		inc $01				inc 	1
.c1d6	a1d6	20 42 a2	jsr $a242			jsr 	EXTILInsert 				; insert in colour screen
.c1d9	a1d9	68		pla				pla 								; get character back.
.c1da	a1da					_EILPrintLoop:
.c1da	a1da	20 00 a0	jsr $a000			jsr 	PagedPrintCharacter
.c1dd	a1dd	80 d6		bra $a1b5			bra 	_EILLoop
.c1df	a1df	60		rts				rts
.c1e0	a1e0					_EILBackspace:
.c1e0	a1e0	ad 6e 06	lda $066e			lda 	EXTColumn					; can we backspace ?
.c1e3	a1e3	f0 d0		beq $a1b5			beq 	_EILLoop
.c1e5	a1e5	a9 02		lda #$02			lda 	#2 							; move cursor left
.c1e7	a1e7	20 00 a0	jsr $a000			jsr 	PagedPrintCharacter
.c1ea	a1ea					_EILDelete
.c1ea	a1ea	a9 02		lda #$02			lda 	#2 							; text block
.c1ec	a1ec	85 01		sta $01				sta 	1
.c1ee	a1ee	a9 20		lda #$20			lda 	#' ' 						; backspace text.
.c1f0	a1f0	20 2d a2	jsr $a22d			jsr 	EXTILDelete
.c1f3	a1f3	e6 01		inc $01				inc 	1 							; colour block
.c1f5	a1f5	ac 6e 06	ldy $066e			ldy 	EXTColumn 					; get attribute of last character
.c1f8	a1f8	88		dey				dey
.c1f9	a1f9	b1 40		lda ($40),y			lda 	(EXTAddress),y
.c1fb	a1fb	20 2d a2	jsr $a22d			jsr 	EXTILDelete 				; backspace attribute
.c1fe	a1fe	80 b5		bra $a1b5			bra 	_EILLoop 					; and go round.
.c200	a200					_EILExit:
.c200	a200	a9 02		lda #$02			lda 	#2 							; switch to page 2
.c202	a202	85 01		sta $01				sta 	1
.c204	a204	a0 00		ldy #$00			ldy 	#0 							; copy current line into buffer.
.c206	a206					_EILScrapeLine:
.c206	a206	b1 40		lda ($40),y			lda 	(EXTAddress),y
.c208	a208	99 2a 05	sta $052a,y			sta 	lineBuffer,y
.c20b	a20b	c8		iny				iny
.c20c	a20c	cc 70 06	cpy $0670			cpy 	EXTScreenWidth
.c20f	a20f	d0 f5		bne $a206			bne 	_EILScrapeLine
.c211	a211					_EILTrimSpaces:
.c211	a211	88		dey				dey
.c212	a212	f0 08		beq $a21c			beq 	_EILEndTrim
.c214	a214	b9 2a 05	lda $052a,y			lda 	lineBuffer,y
.c217	a217	c9 20		cmp #$20			cmp 	#' '
.c219	a219	f0 f6		beq $a211			beq 	_EILTrimSpaces
.c21b	a21b	c8		iny				iny 								; trim after non space character.
.c21c	a21c					_EILEndTrim:
.c21c	a21c	a9 00		lda #$00			lda 	#0 							; trim here.
.c21e	a21e	99 2a 05	sta $052a,y			sta 	lineBuffer,y
.c221	a221	a9 0d		lda #$0d			lda 	#13 						; echo the RETURN
.c223	a223	20 00 a0	jsr $a000			jsr 	PagedPrintCharacter
.c226	a226	68		pla				pla 								; reset I/O page
.c227	a227	85 01		sta $01				sta 	1
.c229	a229	7a		ply				ply
.c22a	a22a	fa		plx				plx
.c22b	a22b	68		pla				pla
.c22c	a22c	60		rts				rts
.c22d	a22d					EXTILDelete:
.c22d	a22d	48		pha				pha 								; save the new character
.c22e	a22e	ac 6e 06	ldy $066e			ldy 	EXTColumn 					; start copying from here.
.c231	a231					_EXTDLoop:
.c231	a231	c8		iny				iny 								; copy one byte down.
.c232	a232	b1 40		lda ($40),y			lda 	(EXTAddress),y
.c234	a234	88		dey				dey
.c235	a235	91 40		sta ($40),y			sta 	(EXTAddress),y
.c237	a237	c8		iny				iny 								; do till end of line.
.c238	a238	cc 70 06	cpy $0670			cpy 	EXTScreenWidth
.c23b	a23b	90 f4		bcc $a231			bcc 	_EXTDLoop
.c23d	a23d	88		dey				dey 	 							; write in last slot.
.c23e	a23e	68		pla				pla
.c23f	a23f	91 40		sta ($40),y			sta 	(EXTAddress),y
.c241	a241	60		rts				rts
.c242	a242					EXTILInsert:
.c242	a242	ac 70 06	ldy $0670			ldy 	EXTScreenWidth 				; end position
.c245	a245					_EXTILoop:
.c245	a245	88		dey				dey 								; back one
.c246	a246	cc 6e 06	cpy $066e			cpy 	EXTColumn 					; exit if reached insert point.
.c249	a249	f0 08		beq $a253			beq 	_EXTIExit
.c24b	a24b	88		dey				dey 								; copy one byte up.
.c24c	a24c	b1 40		lda ($40),y			lda 	(EXTAddress),y
.c24e	a24e	c8		iny				iny
.c24f	a24f	91 40		sta ($40),y			sta 	(EXTAddress),y
.c251	a251	80 f2		bra $a245			bra 	_EXTILoop
.c253	a253					_EXTIExit:
.c253	a253	60		rts				rts
.c254	a254					EXTScrollFill:
.c254	a254	aa		tax				tax									; save value to fill with
.c255	a255	a5 36		lda $36				lda 	zTemp0 						; save zTemp0 (dest) zTemp1 (src)
.c257	a257	48		pha				pha
.c258	a258	a5 37		lda $37				lda 	zTemp0+1
.c25a	a25a	48		pha				pha
.c25b	a25b	a5 38		lda $38				lda 	zTemp1
.c25d	a25d	48		pha				pha
.c25e	a25e	a5 39		lda $39				lda 	zTemp1+1
.c260	a260	48		pha				pha
.c261	a261	a9 c0		lda #$c0			lda 	#$C0 						; copy from C000+length to C000
.c263	a263	85 37		sta $37				sta 	zTemp0+1
.c265	a265	85 39		sta $39				sta 	zTemp1+1
.c267	a267	64 36		stz $36				stz 	zTemp0
.c269	a269	ad 70 06	lda $0670			lda 	EXTScreenWidth
.c26c	a26c	85 38		sta $38				sta 	zTemp1
.c26e	a26e	a0 00		ldy #$00			ldy 	#0
.c270	a270					_EXSFCopy1:
.c270	a270	b1 38		lda ($38),y			lda 	(zTemp1),y
.c272	a272	91 36		sta ($36),y			sta 	(zTemp0),y
.c274	a274	c8		iny				iny
.c275	a275	d0 f9		bne $a270			bne 	_EXSFCopy1
.c277	a277	e6 37		inc $37				inc 	zTemp0+1 					; next page
.c279	a279	e6 39		inc $39				inc 	zTemp1+1
.c27b	a27b	a5 39		lda $39				lda 	zTemp1+1
.c27d	a27d	c9 d3		cmp #$d3			cmp 	#$D3
.c27f	a27f	d0 ef		bne $a270			bne 	_EXSFCopy1
.c281	a281	ac 70 06	ldy $0670			ldy 	EXTScreenWidth 				; blank the bottom line.
.c284	a284	8a		txa				txa
.c285	a285					_EXSFFill1:
.c285	a285	88		dey				dey
.c286	a286	91 40		sta ($40),y			sta 	(EXTAddress),y
.c288	a288	c0 00		cpy #$00			cpy 	#0
.c28a	a28a	10 f9		bpl $a285			bpl 	_EXSFFill1
.c28c	a28c	68		pla				pla
.c28d	a28d	85 39		sta $39				sta 	zTemp1+1
.c28f	a28f	68		pla				pla
.c290	a290	85 38		sta $38				sta 	zTemp1
.c292	a292	68		pla				pla
.c293	a293	85 37		sta $37				sta 	zTemp0+1
.c295	a295	68		pla				pla
.c296	a296	85 36		sta $36				sta 	zTemp0
.c298	a298	60		rts				rts
=$c000						EXTMemory = $C000
=$02						EXTTextPage = $02
=$03						EXTColourPage = $03
=1						EXTDummySpace = 1 							; fake-space for CR character.
=0						EXTCBlack = 0
.066d						EXTRow:
>066d								.fill 	1
.066e						EXTColumn:
>066e								.fill 	1
.066f						EXTTextColour:
>066f								.fill 	1
.0670						EXTScreenWidth:
>0670								.fill 	1
.0671						EXTScreenHeight:
>0671								.fill 	1
.0040						EXTAddress:
>0040								.fill 	2
.c299	a299					Export_EXTInitialise:
.c299	a299	64 01		stz $01				stz 	1 							; Access I/O page 0
.c29b	a29b	9c 04 d0	stz $d004			stz 	$D004 						; Disable border
.c29e	a29e	9c 08 d0	stz $d008			stz 	$D008
.c2a1	a2a1	9c 09 d0	stz $d009			stz 	$D009
.c2a4	a2a4	a9 09		lda #$09			lda 	#1+8						; Timer On at 70Hz counting up.
.c2a6	a2a6	8d 58 d6	sta $d658			sta 	$D658
.c2a9	a2a9	a9 03		lda #$03			lda 	#3 							; get current text colour from whatever the kernel
.c2ab	a2ab	85 01		sta $01				sta 	1 							; has set it to, looking at top left character
.c2ad	a2ad	ad 00 c0	lda $c000			lda 	$C000
.c2b0	a2b0	8d 6f 06	sta $066f			sta 	EXTTextColour
.c2b3	a2b3	a9 50		lda #$50			lda 	#80 						; set screen dimensions.
.c2b5	a2b5	8d 70 06	sta $0670			sta 	EXTScreenWidth
.c2b8	a2b8	a9 3c		lda #$3c			lda 	#60
.c2ba	a2ba	8d 71 06	sta $0671			sta 	EXTScreenHeight
.c2bd	a2bd	20 82 a1	jsr $a182			jsr 	EXTHomeCursor 				; home cursor
.c2c0	a2c0					_EXMoveDown:
.c2c0	a2c0	a9 0d		lda #$0d			lda 	#13
.c2c2	a2c2	20 00 a0	jsr $a000			jsr 	PAGEDPrintCharacter
.c2c5	a2c5	ad 6d 06	lda $066d			lda 	EXTRow
.c2c8	a2c8	c9 08		cmp #$08			cmp 	#8
.c2ca	a2ca	d0 f4		bne $a2c0			bne 	_EXMoveDown
.c2cc	a2cc	64 01		stz $01				stz 	1
.c2ce	a2ce	60		rts				rts
.c2cf	a2cf					Export_EXTInputSingleCharacter:
.c2cf	a2cf					PagedInputSingleCharacter:
.c2cf	a2cf	da		phx				phx
.c2d0	a2d0	5a		phy				phy
.c2d1	a2d1					_EISCWait:
.c2d1	a2d1	a5 01		lda $01				lda 	1 							; save I/O 0
.c2d3	a2d3	48		pha				pha
.c2d4	a2d4	64 01		stz $01				stz 	1 							; access I/O Page 0
.c2d6	a2d6	38		sec				sec 								; calculate timer - LastTick
.c2d7	a2d7	ad 59 d6	lda $d659			lda 	$D659
.c2da	a2da	aa		tax				tax 								; saving timer in X
.c2db	a2db	ed 5c 06	sbc $065c			sbc 	LastTick
.c2de	a2de	c9 03		cmp #$03			cmp 	#3
.c2e0	a2e0	90 06		bcc $a2e8			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.c2e2	a2e2	8e 5c 06	stx $065c			stx 	LastTick 					; update last timer
.c2e5	a2e5	20 ab b6	jsr $b6ab			jsr 	PagedSNDUpdate 							; go do the code.
.c2e8	a2e8					_NoFireTick:
.c2e8	a2e8	68		pla				pla 								; restore I/O 0
.c2e9	a2e9	85 01		sta $01				sta 	1
.c2eb	a2eb	20 e4 ff	jsr $ffe4			jsr 	$FFE4 						; get a key
.c2ee	a2ee	c9 00		cmp #$00			cmp 	#0 							; loop back if none pressed.
.c2f0	a2f0	f0 df		beq $a2d1			beq 	_EISCWait
.c2f2	a2f2	7a		ply				ply
.c2f3	a2f3	fa		plx				plx
.c2f4	a2f4	60		rts				rts
.c2f5	a2f5					Export_EXTBreakCheck:
.c2f5	a2f5	4c e1 ff	jmp $ffe1			jmp		$FFE1
=3						KP_Z_ROW = 3
=$04						KP_Z_COL = $04
=4						KP_X_ROW = 4
=$04						KP_X_COL = $04
=8						KP_K_ROW = 8
=$04						KP_K_COL = $04
=7						KP_M_ROW = 7
=$04						KP_M_COL = $04
=9						KP_L_ROW = 9
=$08						KP_L_COL = $08
.c2f8	a2f8					Export_EXTReadController:
.c2f8	a2f8	da		phx				phx
.c2f9	a2f9	a2 00		ldx #$00		ldx 	#0
.c2fb	a2fb	a9 04		lda #$04			lda 	#KP_X_ROW
.c2fd	a2fd	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.c300	a300	29 04		and #$04			and 	#KP_X_COL
.c302	a302	f0 04		beq $a308			beq 	_NoSet1
.c304	a304	8a		txa				txa
.c305	a305	09 01		ora #$01			ora 	#1
.c307	a307	aa		tax				tax
.c308	a308					_NoSet1:
.c308	a308	a9 03		lda #$03			lda 	#KP_Z_ROW
.c30a	a30a	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.c30d	a30d	29 04		and #$04			and 	#KP_Z_COL
.c30f	a30f	f0 04		beq $a315			beq 	_NoSet1
.c311	a311	8a		txa				txa
.c312	a312	09 02		ora #$02			ora 	#2
.c314	a314	aa		tax				tax
.c315	a315					_NoSet1:
.c315	a315	a9 07		lda #$07			lda 	#KP_M_ROW
.c317	a317	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.c31a	a31a	29 04		and #$04			and 	#KP_M_COL
.c31c	a31c	f0 04		beq $a322			beq 	_NoSet1
.c31e	a31e	8a		txa				txa
.c31f	a31f	09 04		ora #$04			ora 	#4
.c321	a321	aa		tax				tax
.c322	a322					_NoSet1:
.c322	a322	a9 08		lda #$08			lda 	#KP_K_ROW
.c324	a324	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.c327	a327	29 04		and #$04			and 	#KP_K_COL
.c329	a329	f0 04		beq $a32f			beq 	_NoSet1
.c32b	a32b	8a		txa				txa
.c32c	a32c	09 08		ora #$08			ora 	#8
.c32e	a32e	aa		tax				tax
.c32f	a32f					_NoSet1:
.c32f	a32f	a9 09		lda #$09			lda 	#KP_L_ROW
.c331	a331	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.c334	a334	29 08		and #$08			and 	#KP_L_COL
.c336	a336	f0 04		beq $a33c			beq 	_NoSet1
.c338	a338	8a		txa				txa
.c339	a339	09 10		ora #$10			ora 	#16
.c33b	a33b	aa		tax				tax
.c33c	a33c					_NoSet1:
.c33c	a33c	8a		txa				txa
.c33d	a33d	fa		plx				plx
.c33e	a33e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_graphics.module

=1						graphicsIntegrated=1
=0						GCMD_Initialise = 0*2
=2						GCMD_BitmapCtl = 1*2
=4						GCMD_SpriteCtl = 2*2
=6						GCMD_Clear = 3*2
=8						GCMD_Colour = 4*2
=10						GCMD_DrawFont = 5*2
=12						GCMD_DrawSprite = 6*2
=14						GCMD_SpriteUse = 7*2
=16						GCMD_SpriteImage = 8*2
=18						GCMD_SpriteCollide = 9*2
=64						GCMD_Move = 32*2
=66						GCMD_Line = 33*2
=68						GCMD_FrameRect = 34*2
=70						GCMD_FillRect = 35*2
=72						GCMD_FrameCircle = 36*2
=74						GCMD_FillCircle = 37*2
=80						GCMD_Plot = 40*2
=82						GCMD_SpriteMove = 41*2
=42						GRFirstFreeCode = 42
.c33f	a33f					GRVectorTable:
>c33f	a33f	8e a5					.word	GXInitialise             ; $00 Initialise
>c341	a341	a8 a5					.word	GXControlBitmap          ; $01 BitmapCtl
>c343	a343	f0 a5					.word	GXControlSprite          ; $02 SpriteCtl
>c345	a345	40 a5					.word	GXClearBitmap            ; $03 Clear
>c347	a347	7f a7					.word	GXSetColourMode          ; $04 Colour
>c349	a349	47 a9					.word	GXFontHandler            ; $05 DrawFont
>c34b	a34b	8f a9					.word	GXSpriteHandler          ; $06 DrawSprite
>c34d	a34d	00 aa					.word	GXSelect                 ; $07 SpriteUse
>c34f	a34f	29 aa					.word	GXSelectImage            ; $08 SpriteImage
>c351	a351	b0 ab					.word	GXCollide                ; $09 SpriteCollide
>c353	a353	f2 a3					.word	GRUndefined              ; $0a
>c355	a355	f2 a3					.word	GRUndefined              ; $0b
>c357	a357	f2 a3					.word	GRUndefined              ; $0c
>c359	a359	f2 a3					.word	GRUndefined              ; $0d
>c35b	a35b	f2 a3					.word	GRUndefined              ; $0e
>c35d	a35d	f2 a3					.word	GRUndefined              ; $0f
>c35f	a35f	f2 a3					.word	GRUndefined              ; $10
>c361	a361	f2 a3					.word	GRUndefined              ; $11
>c363	a363	f2 a3					.word	GRUndefined              ; $12
>c365	a365	f2 a3					.word	GRUndefined              ; $13
>c367	a367	f2 a3					.word	GRUndefined              ; $14
>c369	a369	f2 a3					.word	GRUndefined              ; $15
>c36b	a36b	f2 a3					.word	GRUndefined              ; $16
>c36d	a36d	f2 a3					.word	GRUndefined              ; $17
>c36f	a36f	f2 a3					.word	GRUndefined              ; $18
>c371	a371	f2 a3					.word	GRUndefined              ; $19
>c373	a373	f2 a3					.word	GRUndefined              ; $1a
>c375	a375	f2 a3					.word	GRUndefined              ; $1b
>c377	a377	f2 a3					.word	GRUndefined              ; $1c
>c379	a379	f2 a3					.word	GRUndefined              ; $1d
>c37b	a37b	f2 a3					.word	GRUndefined              ; $1e
>c37d	a37d	f2 a3					.word	GRUndefined              ; $1f
>c37f	a37f	f0 a3					.word	GXMove                   ; $20 Move
>c381	a381	4d a6					.word	GXLine                   ; $21 Line
>c383	a383	c8 a7					.word	GXFrameRectangle         ; $22 FrameRect
>c385	a385	c5 a7					.word	GXFillRectangle          ; $23 FillRect
>c387	a387	f7 a3					.word	GXFrameCircle            ; $24 FrameCircle
>c389	a389	f3 a3					.word	GXFillCircle             ; $25 FillCircle
>c38b	a38b	f2 a3					.word	GRUndefined              ; $26
>c38d	a38d	f2 a3					.word	GRUndefined              ; $27
>c38f	a38f	ad a7					.word	GXPlotPoint              ; $28 Plot
>c391	a391	bf aa					.word	GXMoveSprite             ; $29 SpriteMove
=3						GXMappingPage = 3
=24576						GXMappingAddress = ($2000 * GXMappingPage)
=11						GXEditSlot = 8 + GXMappingPage
=$36						gxzTemp0 = zTemp0
=$38						gxzTemp1 = zTemp1
=$3a						gxzTemp2 = zTemp2
=$3c						gxzScreen = zsTemp
=$627						gxPixelBuffer = numberBuffer
.0672						gxCurrentX:
>0672								.fill 	2
.0674						gxCurrentY:
>0674								.fill 	2
.0676						gxLastX:
>0676								.fill 	2
.0678						gxLastY:
>0678								.fill 	2
.067a						gxX0:
>067a								.fill 	2
.067c						gxY0:
>067c								.fill 	2
.067e						gxX1:
>067e								.fill 	2
.0680						gxY1:
>0680								.fill 	2
.0682						gxSpritesOn:
>0682								.fill 	1
.0683						gxBitmapsOn:
>0683								.fill 	1
.0684						gxBasePage:
>0684								.fill 	1
.0685						gxSpritePage:
>0685								.fill 	1
.0686						gxHeight:
>0686								.fill 	1
.0687						gxMode:
>0687								.fill 	1
.0688						gxColour:
>0688								.fill 	1
.0689						gxEORValue:
>0689								.fill 	1
.068a						gxANDValue:
>068a								.fill 	1
.068b						gxOriginalLUTValue:
>068b								.fill 	1
.068c						gsOffset:
>068c								.fill 	1
.068d						GSCurrentSpriteID:
>068d								.fill 	1
.068e						GSCurrentSpriteAddr:
>068e								.fill 	2
.0690						GXSpriteOffsetBase:
>0690								.fill 	2
.0692						GXSpriteLow:
>0692								.fill 	64
.06d2						GXSpriteHigh:
>06d2								.fill 	64
.c393	a393					Export_GXGraphicDraw:
.c393	a393	c9 40		cmp #$40			cmp 	#GCMD_Move					; low instructions don't use coordinates
.c395	a395	b0 06		bcs $a39d			bcs 	_GDCoordinate
.c397	a397	86 36		stx $36				stx 	gxzTemp0 					; save X/Y
.c399	a399	84 37		sty $37				sty 	gxzTemp0+1
.c39b	a39b	80 4b		bra $a3e8			bra 	_GDExecuteA 				; and execute
.c39d	a39d					_GDCoordinate:
.c39d	a39d	48		pha				pha 								; save AXY
.c39e	a39e	da		phx				phx
.c39f	a39f	5a		phy				phy
.c3a0	a3a0	a2 03		ldx #$03			ldx 	#3 							; copy currentX to lastX
.c3a2	a3a2					_GDCopy1:
.c3a2	a3a2	bd 72 06	lda $0672,x			lda 	gxCurrentX,x
.c3a5	a3a5	9d 76 06	sta $0676,x			sta 	gxLastX,x
.c3a8	a3a8	ca		dex				dex
.c3a9	a3a9	10 f7		bpl $a3a2			bpl 	_GDCopy1
.c3ab	a3ab	68		pla				pla 								; update Y
.c3ac	a3ac	8d 74 06	sta $0674			sta 	gxCurrentY
.c3af	a3af	9c 75 06	stz $0675			stz 	gxCurrentY+1
.c3b2	a3b2	68		pla				pla
.c3b3	a3b3	8d 72 06	sta $0672			sta 	gxCurrentX
.c3b6	a3b6	68		pla				pla 								; get A (command+X.1) back
.c3b7	a3b7	48		pha				pha
.c3b8	a3b8	29 01		and #$01			and 	#1 							; put LSB as MSB of Current.X
.c3ba	a3ba	8d 73 06	sta $0673			sta 	gxCurrentX+1
.c3bd	a3bd	68		pla				pla 								; get command back
.c3be	a3be	29 fe		and #$fe			and 	#$FE 						; lose LSB, chuck the stray X bit
.c3c0	a3c0	48		pha				pha 								; push back.
.c3c1	a3c1	c9 52		cmp #$52			cmp 	#GCMD_SpriteMove 			; move sprite does not clip.
.c3c3	a3c3	f0 17		beq $a3dc			beq 	_GDCopyToWorkArea
.c3c5	a3c5	ad 73 06	lda $0673			lda 	gxCurrentX+1 				; X < 256 X okay
.c3c8	a3c8	f0 07		beq $a3d1			beq 	_GDCheckY
.c3ca	a3ca	ad 72 06	lda $0672			lda 	gxCurrentX 					; otherwise X < 320 = 256 + 64
.c3cd	a3cd	c9 40		cmp #$40			cmp 	#64
.c3cf	a3cf	b0 08		bcs $a3d9			bcs 	_GDError1
.c3d1	a3d1					_GDCheckY:
.c3d1	a3d1	ad 74 06	lda $0674			lda 	gxCurrentY 					; check Y < Height.
.c3d4	a3d4	cd 86 06	cmp $0686			cmp 	gxHeight
.c3d7	a3d7	90 03		bcc $a3dc			bcc 	_GDCopyToWorkArea
.c3d9	a3d9					_GDError1:
.c3d9	a3d9	68		pla				pla
.c3da	a3da					_GDError2:
.c3da	a3da	38		sec				sec
.c3db	a3db	60		rts				rts
.c3dc	a3dc					_GDCopyToWorkArea:
.c3dc	a3dc	a2 07		ldx #$07			ldx 	#7 							; copy current and last to gxXY/12 work area
.c3de	a3de					_GDCopy2:
.c3de	a3de	bd 72 06	lda $0672,x			lda 	gxCurrentX,x
.c3e1	a3e1	9d 7a 06	sta $067a,x			sta 	gxX0,x
.c3e4	a3e4	ca		dex				dex
.c3e5	a3e5	10 f7		bpl $a3de			bpl 	_GDCopy2
.c3e7	a3e7	68		pla				pla 								; get command
.c3e8	a3e8					_GDExecuteA:
.c3e8	a3e8	c9 54		cmp #$54			cmp 	#GRFirstFreeCode*2 			; bad ?
.c3ea	a3ea	b0 ee		bcs $a3da			bcs 	_GDError2
.c3ec	a3ec	aa		tax				tax
.c3ed	a3ed	7c 3f a3	jmp ($a33f,x)			jmp 	(GRVectorTable,x)
.c3f0	a3f0					GXMove:
.c3f0	a3f0	18		clc				clc
.c3f1	a3f1	60		rts				rts
.c3f2	a3f2					GRUndefined:
>c3f2	a3f2	db						.byte 	$DB 						; causes a break in the emulator
.c3f3	a3f3					GXFillCircle:
.c3f3	a3f3	a9 ff		lda #$ff			lda 	#255
.c3f5	a3f5	80 02		bra $a3f9			bra 	GXCircle
.c3f7	a3f7					GXFrameCircle:
.c3f7	a3f7	a9 00		lda #$00			lda 	#0
.c3f9	a3f9					GXCircle:
.c3f9	a3f9	8d 15 07	sta $0715			sta 	gxIsFillMode					; save Fill flag
.c3fc	a3fc	ad 83 06	lda $0683			lda 	gxBitmapsOn
.c3ff	a3ff	f0 26		beq $a427			beq 	_GXCFail
.c401	a401	20 57 ac	jsr $ac57			jsr 	GXSortXY 					; topleft/bottomright
.c404	a404	20 2f ab	jsr $ab2f			jsr 	GXOpenBitmap 				; start drawing
.c407	a407	20 f9 a4	jsr $a4f9			jsr 	GXCircleSetup 				; set up for drawing
.c40a	a40a	9c 16 07	stz $0716			stz 	gxYChanged
.c40d	a40d					_GXCircleDraw:
.c40d	a40d	ad 13 07	lda $0713			lda 	gXCentre					; while x <= y
.c410	a410	cd 14 07	cmp $0714			cmp 	gYCentre
.c413	a413	90 0a		bcc $a41f			bcc 	_GXCircleContinue
.c415	a415	d0 03		bne $a41a			bne 	_GXNoLast
.c417	a417	20 2c a4	jsr $a42c			jsr 	GXPlot1
.c41a	a41a					_GXNoLast:
.c41a	a41a	20 37 ab	jsr $ab37			jsr 	GXCloseBitmap 				; close the bitmap
.c41d	a41d	18		clc				clc
.c41e	a41e	60		rts				rts
.c41f	a41f					_GXCircleContinue:
.c41f	a41f	20 29 a4	jsr $a429			jsr 	GXPlot2 					; draw it
.c422	a422	20 a6 a4	jsr $a4a6			jsr 	GXCircleMove 				; adjust the coordinates
.c425	a425	80 e6		bra $a40d			bra 	_GXCircleDraw
.c427	a427					_GXCFail:
.c427	a427	38		sec				sec
.c428	a428	60		rts				rts
.c429	a429					GXPlot2:
.c429	a429	20 2c a4	jsr $a42c			jsr 	GXPlot1 						; plot and swap, fall through does twice
.c42c	a42c					GXPlot1:
.c42c	a42c	ad 14 07	lda $0714			lda 	gYCentre 						; if y = 0, don't do it twice (xor)
.c42f	a42f	f0 03		beq $a434			beq 	_GXPlot1Only
.c431	a431	20 50 a4	jsr $a450			jsr 	GXPlot0 						; plot and negate
.c434	a434					_GXPlot1Only:
.c434	a434	20 50 a4	jsr $a450			jsr 	GXPlot0 						; twice, undoing negation
.c437	a437	ad 13 07	lda $0713			lda 	gXCentre 						; swap X and Y
.c43a	a43a	ae 14 07	ldx $0714			ldx	 	gYCentre
.c43d	a43d	8d 14 07	sta $0714			sta 	gYCentre
.c440	a440	8e 13 07	stx $0713			stx 	gXCentre
.c443	a443	ad 16 07	lda $0716			lda 	gxYChanged 						; toggle Y Changed flag
.c446	a446	a9 ff		lda #$ff			lda 	#$FF
.c448	a448	8d 16 07	sta $0716			sta 	gxYChanged
.c44b	a44b	60		rts				rts
.c44c	a44c	20 50 a4	jsr $a450			jsr 	GXPlot0 						; do once
.c44f	a44f	60		rts				rts
.c450	a450	ad 15 07	lda $0715	GXPlot0:lda 	gxIsFillMode 					; outline mode, always draw as X or Y will change
.c453	a453	f0 05		beq $a45a			beq 	_GXPlot0Always
.c455	a455	ad 16 07	lda $0716			lda 	gxYChanged						; fill mode, only draw if changed.
.c458	a458	f0 2d		beq $a487			beq 	GXPlot0Exit
.c45a	a45a					_GXPlot0Always:
.c45a	a45a	a2 02		ldx #$02			ldx 	#2 								; copy Y1-A => Y0
.c45c	a45c	ad 14 07	lda $0714			lda 	gYCentre
.c45f	a45f	20 88 a4	jsr $a488			jsr 	GXSubCopy
.c462	a462	a2 00		ldx #$00			ldx 	#0 								; copy X1-A => X0,
.c464	a464	ad 13 07	lda $0713			lda 	gXCentre
.c467	a467	20 88 a4	jsr $a488			jsr 	GXSubCopy
.c46a	a46a	48		pha				pha 									; save last offset X
.c46b	a46b	20 3f ab	jsr $ab3f			jsr 	GXPositionCalc 					; calculate position/offset.
.c46e	a46e	68		pla				pla
.c46f	a46f	0a		asl a				asl 	a 								; store 2 x last offset in gxzTemp0
.c470	a470	85 36		sta $36				sta 	gxzTemp0
.c472	a472	64 37		stz $37				stz 	gxzTemp0+1
.c474	a474	26 37		rol $37				rol 	gxzTemp0+1
.c476	a476	ad 15 07	lda $0715			lda 	gxIsFillMode
.c479	a479	69 80		adc #$80			adc 	#128
.c47b	a47b	20 18 a8	jsr $a818			jsr 	GXDrawLineTemp0 				; routine from Rectangle.
.c47e	a47e	38		sec				sec 									; GY = -GY
.c47f	a47f	a9 00		lda #$00			lda 	#0
.c481	a481	ed 14 07	sbc $0714			sbc 	gYCentre
.c484	a484	8d 14 07	sta $0714			sta 	gYCentre
.c487	a487					GXPlot0Exit:
.c487	a487	60		rts				rts
.c488	a488					GXSubCopy:
.c488	a488	85 36		sta $36				sta 	gxzTemp0
.c48a	a48a	64 37		stz $37				stz 	gxzTemp0+1
.c48c	a48c	29 80		and #$80			and 	#$80
.c48e	a48e	f0 02		beq $a492			beq 	_GXNoSx
.c490	a490	c6 37		dec $37				dec 	gxzTemp0+1
.c492	a492					_GXNoSx:
.c492	a492	38		sec				sec
.c493	a493	bd 7e 06	lda $067e,x			lda 	gXX1,x
.c496	a496	e5 36		sbc $36				sbc 	gxzTemp0
.c498	a498	9d 7a 06	sta $067a,x			sta 	gXX0,x
.c49b	a49b	bd 7f 06	lda $067f,x			lda 	gXX1+1,x
.c49e	a49e	e5 37		sbc $37				sbc 	gxzTemp0+1
.c4a0	a4a0	9d 7b 06	sta $067b,x			sta 	gXX0+1,x
.c4a3	a4a3	a5 36		lda $36				lda 	gxzTemp0 						; return A
.c4a5	a4a5	60		rts				rts
.c4a6	a4a6					GXCircleMove:
.c4a6	a4a6	9c 16 07	stz $0716			stz 	gxYChanged 					; clear Y changed flag
.c4a9	a4a9	a5 39		lda $39				lda 	gxzTemp1+1 					; check sign of D
.c4ab	a4ab	10 0d		bpl $a4ba			bpl 	_GXEMPositive
.c4ad	a4ad	ee 13 07	inc $0713			inc 	gXCentre 					; X++
.c4b0	a4b0	ad 13 07	lda $0713			lda 	gXCentre
.c4b3	a4b3	20 d9 a4	jsr $a4d9			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.c4b6	a4b6	a9 06		lda #$06			lda 	#6  						; and add 6
.c4b8	a4b8	80 15		bra $a4cf			bra 	_GXEMAddD
.c4ba	a4ba					_GXEMPositive:
.c4ba	a4ba	ee 13 07	inc $0713			inc 	gXCentre					; X++
.c4bd	a4bd	ce 14 07	dec $0714			dec 	gyCentre 					; Y--
.c4c0	a4c0	38		sec				sec 								; calculate X-Y
.c4c1	a4c1	ad 13 07	lda $0713			lda 	gXCentre
.c4c4	a4c4	ed 14 07	sbc $0714			sbc 	gYCentre
.c4c7	a4c7	20 d9 a4	jsr $a4d9			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.c4ca	a4ca	a9 0a		lda #$0a			lda 	#10  						; and add 10
.c4cc	a4cc	ce 16 07	dec $0716			dec 	gxYChanged
.c4cf	a4cf					_GXEMAddD:
.c4cf	a4cf	18		clc				clc
.c4d0	a4d0	65 38		adc $38				adc 	gxzTemp1
.c4d2	a4d2	85 38		sta $38				sta 	gxzTemp1
.c4d4	a4d4	90 02		bcc $a4d8			bcc 	_GXEMNoCarry
.c4d6	a4d6	e6 39		inc $39				inc 	gxzTemp1+1
.c4d8	a4d8					_GXEMNoCarry:
.c4d8	a4d8	60		rts				rts
.c4d9	a4d9					_GXAdd4TimesToD:
.c4d9	a4d9	85 36		sta $36				sta 	gxzTemp0 					; make 16 bit signed.
.c4db	a4db	29 80		and #$80			and 	#$80
.c4dd	a4dd	f0 02		beq $a4e1			beq 	_GXA4Unsigned
.c4df	a4df	a9 ff		lda #$ff			lda 	#$FF
.c4e1	a4e1					_GXA4Unsigned:
.c4e1	a4e1	85 37		sta $37				sta 	gxzTemp0+1
.c4e3	a4e3	06 36		asl $36				asl 	gxzTemp0  					; x 4
.c4e5	a4e5	26 37		rol $37				rol 	gxzTemp0+1
.c4e7	a4e7	06 36		asl $36				asl 	gxzTemp0
.c4e9	a4e9	26 37		rol $37				rol 	gxzTemp0+1
.c4eb	a4eb	18		clc				clc 								; add
.c4ec	a4ec	a5 36		lda $36				lda		gxzTemp0
.c4ee	a4ee	65 38		adc $38				adc 	gxzTemp1
.c4f0	a4f0	85 38		sta $38				sta 	gxzTemp1
.c4f2	a4f2	a5 37		lda $37				lda		gxzTemp0+1
.c4f4	a4f4	65 39		adc $39				adc 	gxzTemp1+1
.c4f6	a4f6	85 39		sta $39				sta 	gxzTemp1+1
.c4f8	a4f8	60		rts				rts
.c4f9	a4f9					GXCircleSetup:
.c4f9	a4f9	38		sec				sec
.c4fa	a4fa	ad 80 06	lda $0680			lda 	gxY1
.c4fd	a4fd	ed 7c 06	sbc $067c			sbc 	gxY0
.c500	a500	4a		lsr a				lsr 	a
.c501	a501	8d 12 07	sta $0712			sta 	gxRadius
.c504	a504	a2 00		ldx #$00			ldx 	#0
.c506	a506	20 28 a5	jsr $a528			jsr 	_GXCalculateCentre
.c509	a509	a2 02		ldx #$02			ldx 	#2
.c50b	a50b	20 28 a5	jsr $a528			jsr 	_GXCalculateCentre
.c50e	a50e	9c 13 07	stz $0713			stz 	gXCentre
.c511	a511	ad 12 07	lda $0712			lda 	gxRadius
.c514	a514	8d 14 07	sta $0714			sta 	gYCentre
.c517	a517	0a		asl a				asl 	a 							; R x 2
.c518	a518	85 36		sta $36				sta 	gxzTemp0
.c51a	a51a	38		sec				sec
.c51b	a51b	a9 03		lda #$03			lda 	#3
.c51d	a51d	e5 36		sbc $36				sbc 	gxzTemp0
.c51f	a51f	85 38		sta $38				sta 	gxzTemp1
.c521	a521	a9 00		lda #$00			lda 	#0
.c523	a523	e9 00		sbc #$00			sbc 	#0
.c525	a525	85 39		sta $39				sta 	gxzTemp1+1
.c527	a527	60		rts				rts
.c528	a528					_GXCalculateCentre:
.c528	a528	38		sec				sec
.c529	a529	bd 7e 06	lda $067e,x			lda 	gxX1,x
.c52c	a52c	7d 7a 06	adc $067a,x			adc 	gXX0,x
.c52f	a52f	9d 7e 06	sta $067e,x			sta 	gXX1,x
.c532	a532	bd 7f 06	lda $067f,x			lda 	gXX1+1,x
.c535	a535	7d 7b 06	adc $067b,x			adc 	gXX0+1,x
.c538	a538	4a		lsr a				lsr 	a
.c539	a539	9d 7f 06	sta $067f,x			sta 	gXX1+1,x
.c53c	a53c	7e 7e 06	ror $067e,x			ror 	gXX1,x
.c53f	a53f	60		rts				rts
.0712						gxRadius:
>0712								.fill 	1
.0713						gXCentre:
>0713								.fill 	1
.0714						gYCentre:
>0714								.fill 	1
.0715						gxIsFillMode:
>0715								.fill 	1
.0716						gxYChanged:
>0716								.fill  	1
=64000						ScreenSize200 = 320 * 200
=76800						ScreenSize240 = 320 * 240
.c540	a540					GXClearBitmap:
.c540	a540	ad 83 06	lda $0683			lda 	gxBitmapsOn 				; check BMP running.
.c543	a543	f0 24		beq $a569			beq 	_GXCBFail
.c545	a545	20 2f ab	jsr $ab2f			jsr 	GXOpenBitmap 				; start access
.c548	a548	a0 07		ldy #$07			ldy 	#ScreenSize200 / 8192 		; X is pages to clear
.c54a	a54a	ad 86 06	lda $0686			lda 	gxHeight
.c54d	a54d	c9 c8		cmp #$c8			cmp 	#200 						; 200 ?
.c54f	a54f	a0 09		ldy #$09			ldy 	#ScreenSize240 / 8192
.c551	a551					_GXCalcLastPage:
.c551	a551	98		tya				tya 								; add to base page
.c552	a552	18		clc				clc
.c553	a553	6d 84 06	adc $0684			adc 	gxBasePage
.c556	a556	85 0b		sta $0b				sta 	GXEditSlot  				; clear from this page back
.c558	a558					_GXClearAll:
.c558	a558	20 6b a5	jsr $a56b			jsr 	_GXClearBlock 				; clear 8k block
.c55b	a55b	c6 0b		dec $0b				dec 	GXEditSlot  				; back to previous
.c55d	a55d	a5 0b		lda $0b				lda 	GXEditSlot
.c55f	a55f	cd 84 06	cmp $0684			cmp 	gxBasePage 					; until before base page
.c562	a562	b0 f4		bcs $a558			bcs 	_GXClearAll
.c564	a564	20 37 ab	jsr $ab37			jsr 	GXCloseBitmap	 			; stop access
.c567	a567	18		clc				clc
.c568	a568	60		rts				rts
.c569	a569					_GXCBFail:
.c569	a569	38		sec				sec
.c56a	a56a	60		rts				rts
.c56b	a56b					_GXClearBlock:
.c56b	a56b	a9 00		lda #$00			lda 	#((GXMappingAddress) & $FF)
.c56d	a56d	85 38		sta $38				sta 	0+gxzTemp1
.c56f	a56f	a9 60		lda #$60			lda 	#((GXMappingAddress) >> 8)
.c571	a571	85 39		sta $39				sta 	1+gxzTemp1
.c573	a573					_GXCB0:
.c573	a573	a5 36		lda $36				lda 	gxzTemp0
.c575	a575	a0 00		ldy #$00			ldy 	#0
.c577	a577					_GXCB1:
.c577	a577	91 38		sta ($38),y			sta 	(gxzTemp1),y
.c579	a579	c8		iny				iny
.c57a	a57a	91 38		sta ($38),y			sta 	(gxzTemp1),y
.c57c	a57c	c8		iny				iny
.c57d	a57d	91 38		sta ($38),y			sta 	(gxzTemp1),y
.c57f	a57f	c8		iny				iny
.c580	a580	91 38		sta ($38),y			sta 	(gxzTemp1),y
.c582	a582	c8		iny				iny
.c583	a583	d0 f2		bne $a577			bne 	_GXCB1
.c585	a585	e6 39		inc $39				inc 	gxzTemp1+1
.c587	a587	a5 39		lda $39				lda 	gxzTemp1+1
.c589	a589	c9 80		cmp #$80			cmp	 	#(GXMappingAddress >> 8)+$20
.c58b	a58b	d0 e6		bne $a573			bne 	_GXCB0
.c58d	a58d	60		rts				rts
.c58e	a58e					GXInitialise:
.c58e	a58e	64 01		stz $01				stz 	1
.c590	a590	a9 01		lda #$01			lda 	#1
.c592	a592	8d 00 d0	sta $d000			sta 	$D000
.c595	a595	18		clc				clc
.c596	a596	9c 82 06	stz $0682			stz 	GXSpritesOn
.c599	a599	9c 83 06	stz $0683			stz 	GXBitmapsOn
.c59c	a59c	a2 0f		ldx #$0f			ldx 	#15
.c59e	a59e					_GXIClear:
.c59e	a59e	9e 72 06	stz $0672,x			stz 	gxCurrentX,x
.c5a1	a5a1	ca		dex				dex
.c5a2	a5a2	10 fa		bpl $a59e			bpl 	_GXIClear
.c5a4	a5a4	20 3f a6	jsr $a63f			jsr 	GXClearSpriteStore
.c5a7	a5a7	60		rts				rts
.c5a8	a5a8					GXControlBitmap:
.c5a8	a5a8	64 01		stz $01				stz 	1
.c5aa	a5aa	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.c5ac	a5ac	29 01		and #$01			and 	#1 							; set bitmap flag
.c5ae	a5ae	8d 83 06	sta $0683			sta 	gxBitmapsOn
.c5b1	a5b1	4a		lsr a				lsr 	a 							; bit 0 into carry.
.c5b2	a5b2	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.c5b5	a5b5	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.c5b7	a5b7	29 f7		and #$f7			and 	#$F7 						; clear bitmap bit
.c5b9	a5b9	90 02		bcc $a5bd			bcc 	_CBNotOn
.c5bb	a5bb	09 08		ora #$08			ora 	#$08 						; bitmap on if 1 on 0 off
.c5bd	a5bd					_CBNotOn:
.c5bd	a5bd	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.c5c0	a5c0	a5 36		lda $36				lda 	gxzTemp0 					; get control settings (bits 0-2)
.c5c2	a5c2	29 07		and #$07			and 	#7
.c5c4	a5c4	8d 00 d1	sta $d100			sta 	$D100 						; write in Vicky Bitmap Control Register #0
.c5c7	a5c7	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.c5c9	a5c9	d0 02		bne $a5cd			bne 	_CBNotDefault
.c5cb	a5cb	a9 08		lda #$08			lda 	#8  						; if zero, use 8 e.g. bitmap at $10000
.c5cd	a5cd					_CBNotDefault:
.c5cd	a5cd	8d 84 06	sta $0684			sta 	gxBasePage
.c5d0	a5d0	20 31 a6	jsr $a631			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.c5d3	a5d3	a5 37		lda $37				lda 	gxzTemp0+1 					; copy address into Bitmap address registers
.c5d5	a5d5	8d 03 d1	sta $d103			sta 	$D103
.c5d8	a5d8	a5 36		lda $36				lda 	gxzTemp0
.c5da	a5da	8d 02 d1	sta $d102			sta 	$D102
.c5dd	a5dd	9c 01 d1	stz $d101			stz 	$D101
.c5e0	a5e0	a2 f0		ldx #$f0			ldx 	#240 						; height is 240
.c5e2	a5e2	ad 01 d0	lda $d001			lda 	$D001 						; read MCR bit 0
.c5e5	a5e5	29 01		and #$01			and 	#1
.c5e7	a5e7	f0 02		beq $a5eb			beq 	_CBHaveHeight
.c5e9	a5e9	a2 c8		ldx #$c8			ldx 	#200 						; if bit 0 set 320x200
.c5eb	a5eb					_CBHaveHeight
.c5eb	a5eb	8e 86 06	stx $0686			stx 	gxHeight
.c5ee	a5ee	18		clc				clc
.c5ef	a5ef	60		rts				rts
.c5f0	a5f0					GXControlSprite:
.c5f0	a5f0	64 01		stz $01				stz 	1
.c5f2	a5f2	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.c5f4	a5f4	29 01		and #$01			and 	#1 							; set sprites flag
.c5f6	a5f6	8d 82 06	sta $0682			sta 	gxSpritesOn
.c5f9	a5f9	4a		lsr a				lsr 	a 							; bit 0 into carry.
.c5fa	a5fa	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.c5fd	a5fd	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.c5ff	a5ff	29 df		and #$df			and 	#$DF 						; clear sprite bit
.c601	a601	90 02		bcc $a605			bcc 	_CSNotOn
.c603	a603	09 20		ora #$20			ora 	#$20 						; sprite on if 1 on 0 off
.c605	a605					_CSNotOn:
.c605	a605	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.c608	a608	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.c60a	a60a	d0 02		bne $a60e			bne 	_CSNotDefault
.c60c	a60c	a9 18		lda #$18			lda 	#24  						; if zero, use 24 e.g. sprites at $30000
.c60e	a60e					_CSNotDefault:
.c60e	a60e	8d 85 06	sta $0685			sta 	gxSpritePage
.c611	a611	20 31 a6	jsr $a631			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.c614	a614	a5 36		lda $36				lda 	zTemp0
.c616	a616	8d 90 06	sta $0690			sta 	GXSpriteOffsetBase
.c619	a619	a5 37		lda $37				lda 	zTemp0+1
.c61b	a61b	8d 91 06	sta $0691			sta 	GXSpriteOffsetBase+1
.c61e	a61e	a2 00		ldx #$00			ldx 	#0 							; disable all sprites, clears all sprite memory.
.c620	a620					_CSClear:
.c620	a620	9e 00 d9	stz $d900,x			stz 	$D900,x
.c623	a623	9e 00 da	stz $da00,x			stz 	$DA00,x
.c626	a626	ca		dex				dex
.c627	a627	d0 f7		bne $a620			bne 	_CSClear
.c629	a629	9c 8f 06	stz $068f			stz 	GSCurrentSpriteAddr+1 		; no sprite selected.
.c62c	a62c	20 3f a6	jsr $a63f			jsr 	GXClearSpriteStore
.c62f	a62f	18		clc				clc
.c630	a630	60		rts				rts
.c631	a631					GXCalculateBaseAddress:
.c631	a631	85 36		sta $36				sta 	gxzTemp0
.c633	a633	64 37		stz $37				stz 	gxzTemp0+1
.c635	a635	a9 05		lda #$05			lda 	#5
.c637	a637					_GXShift:
.c637	a637	06 36		asl $36				asl 	gxzTemp0
.c639	a639	26 37		rol $37				rol 	gxzTemp0+1
.c63b	a63b	3a		dec a				dec		a
.c63c	a63c	d0 f9		bne $a637			bne 	_GXShift
.c63e	a63e	60		rts				rts
.c63f	a63f					GXClearSpriteStore:
.c63f	a63f	a2 3f		ldx #$3f			ldx 	#63 						; erase 64 sprite store elements
.c641	a641					_GXCSSLoop:
.c641	a641	9e d2 06	stz $06d2,x			stz 	GXSpriteHigh,x
.c644	a644	a9 80		lda #$80			lda 	#$80 						; set the 'hidden' bit.
.c646	a646	9d 92 06	sta $0692,x			sta 	GXSpriteLow,x
.c649	a649	ca		dex				dex
.c64a	a64a	10 f5		bpl $a641			bpl 	_GXCSSLoop
.c64c	a64c	60		rts				rts
.c64d	a64d					GXLine:
.c64d	a64d	ad 83 06	lda $0683			lda 	GXBitmapsOn
.c650	a650	f0 28		beq $a67a			beq 	_GXLFail
.c652	a652	20 2f ab	jsr $ab2f			jsr 	GXOpenBitmap
.c655	a655	20 75 ac	jsr $ac75			jsr 	GXSortY						; sort pairs so Y1 >= Y0 e.g. top to bottom.
.c658	a658	20 20 a7	jsr $a720			jsr 	GXLineSetup 				; the calculations in the linescanner constructor
.c65b	a65b	20 3f ab	jsr $ab3f			jsr 	GXPositionCalc 				; calculate position/offset.
.c65e	a65e					_GXDrawLoop:
.c65e	a65e	ac 8c 06	ldy $068c			ldy 	gsOffset 					; draw the pixel
.c661	a661	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.c663	a663	2d 8a 06	and $068a			and 	gxANDValue
.c666	a666	4d 89 06	eor $0689			eor 	gxEORValue
.c669	a669	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.c66b	a66b	20 7c a6	jsr $a67c			jsr 	GXLineIsComplete 			; is the line complete ?
.c66e	a66e	f0 05		beq $a675			beq 	_GXLExit
.c670	a670	20 97 a6	jsr $a697			jsr 	GXLineAdvance 				; code as per advance method
.c673	a673	80 e9		bra $a65e			bra 	_GXDrawLoop
.c675	a675					_GXLExit:
.c675	a675	20 37 ab	jsr $ab37			jsr 	GXCloseBitmap
.c678	a678	18		clc				clc
.c679	a679	60		rts				rts
.c67a	a67a					_GXLFail:
.c67a	a67a	38		sec				sec
.c67b	a67b	60		rts				rts
.c67c	a67c					GXLineIsComplete:
.c67c	a67c	ad 19 07	lda $0719			lda 	GXIsDiffYLarger 			; is dy larger
.c67f	a67f	d0 0f		bne $a690			bne 	_GXLICCompareY 				; if so compare Y1/Y0
.c681	a681	ad 7a 06	lda $067a			lda 	GXX0 						; compare X, LSB and MSB
.c684	a684	4d 7e 06	eor $067e			eor 	GXX1
.c687	a687	d0 06		bne $a68f			bne 	_GXLICExit
.c689	a689	ad 7b 06	lda $067b			lda 	GXX0+1
.c68c	a68c	4d 7f 06	eor $067f			eor 	GXX1+1
.c68f	a68f					_GXLICExit:
.c68f	a68f	60		rts				rts
.c690	a690					_GXLICCompareY:
.c690	a690	ad 80 06	lda $0680			lda 	GXY1
.c693	a693	4d 7c 06	eor $067c			eor 	GXY0
.c696	a696	60		rts				rts
.c697	a697					GXLineAdvance:
.c697	a697	18		clc				clc 								; add adjust to position
.c698	a698	ad 1b 07	lda $071b			lda 	GXPosition
.c69b	a69b	6d 1c 07	adc $071c			adc 	GXAdjust
.c69e	a69e	8d 1b 07	sta $071b			sta 	GXPosition
.c6a1	a6a1	9c 1e 07	stz $071e			stz 	GXAddSelect 				; clear add select flag
.c6a4	a6a4	b0 05		bcs $a6ab			bcs 	_GXLAOverflow 				; if carry out, overflowed.
.c6a6	a6a6	cd 1d 07	cmp $071d			cmp 	GXTotal 					; if exceeded total
.c6a9	a6a9	90 0a		bcc $a6b5			bcc 	_GXLANoExtra
.c6ab	a6ab					_GXLAOverflow:
.c6ab	a6ab	ce 1e 07	dec $071e			dec 	GXAddSelect 				; set addselect to $FF
.c6ae	a6ae	38		sec				sec 								; subtract total and write back
.c6af	a6af	ed 1d 07	sbc $071d			sbc 	GXTotal
.c6b2	a6b2	8d 1b 07	sta $071b			sta 	GXPosition
.c6b5	a6b5					_GXLANoExtra:
.c6b5	a6b5	ad 19 07	lda $0719			lda 	GXIsDiffYLarger
.c6b8	a6b8	f0 0d		beq $a6c7			beq 	_GXDXLarger
.c6ba	a6ba	20 19 a7	jsr $a719			jsr 	GXIncrementY
.c6bd	a6bd	ad 1e 07	lda $071e			lda 	GXAddSelect
.c6c0	a6c0	f0 10		beq $a6d2			beq 	_GXLAExit
.c6c2	a6c2	20 d3 a6	jsr $a6d3			jsr 	GXAdjustX
.c6c5	a6c5	80 0b		bra $a6d2			bra 	_GXLAExit
.c6c7	a6c7					_GXDXLarger:
.c6c7	a6c7	20 d3 a6	jsr $a6d3			jsr 	GXAdjustX
.c6ca	a6ca	ad 1e 07	lda $071e			lda 	GXAddSelect
.c6cd	a6cd	f0 03		beq $a6d2			beq 	_GXLAExit
.c6cf	a6cf	20 19 a7	jsr $a719			jsr 	GXIncrementY
.c6d2	a6d2					_GXLAExit:
.c6d2	a6d2	60		rts				rts
.c6d3	a6d3					GXAdjustX:
.c6d3	a6d3	ad 1a 07	lda $071a			lda 	GXDXNegative
.c6d6	a6d6	10 25		bpl $a6fd			bpl 	_GXAXRight
.c6d8	a6d8	ad 7a 06	lda $067a			lda 	GXX0
.c6db	a6db	d0 03		bne $a6e0			bne 	_GXAXNoBorrow
.c6dd	a6dd	ce 7b 06	dec $067b			dec 	GXX0+1
.c6e0	a6e0					_GXAXNoBorrow:
.c6e0	a6e0	ce 7a 06	dec $067a			dec 	GXX0
.c6e3	a6e3	ce 8c 06	dec $068c			dec 	gsOffset 					; pixel left
.c6e6	a6e6	ad 8c 06	lda $068c			lda 	gsOffset
.c6e9	a6e9	c9 ff		cmp #$ff			cmp 	#$FF
.c6eb	a6eb	d0 0f		bne $a6fc			bne 	_GXAYExit 					; underflow
.c6ed	a6ed	c6 3d		dec $3d				dec 	gxzScreen+1 					; borrow
.c6ef	a6ef	a5 3d		lda $3d				lda 	gxzScreen+1 					; gone off page
.c6f1	a6f1	c9 60		cmp #$60			cmp 	#GXMappingAddress >> 8
.c6f3	a6f3	b0 07		bcs $a6fc			bcs 	_GXAYExit
.c6f5	a6f5	18		clc				clc
.c6f6	a6f6	69 20		adc #$20			adc 	#$20 						; fix up
.c6f8	a6f8	85 3d		sta $3d				sta 	gxzScreen+1
.c6fa	a6fa	c6 0b		dec $0b				dec 	GXEditSlot 				; back one page
.c6fc	a6fc					_GXAYExit:
.c6fc	a6fc	60		rts				rts
.c6fd	a6fd					_GXAXRight:
.c6fd	a6fd	ee 7a 06	inc $067a			inc 	GXX0
.c700	a700	d0 03		bne $a705			bne 	_GXAXNoCarry
.c702	a702	ee 7b 06	inc $067b			inc 	GXX0+1
.c705	a705					_GXAXNoCarry:
.c705	a705	ee 8c 06	inc $068c			inc 	gsOffset 					; pixel right
.c708	a708	d0 0e		bne $a718			bne 	_GXAXExit 					; if not overflowed, exit.
.c70a	a70a	e6 3d		inc $3d				inc 	gxzScreen+1 					; next line
.c70c	a70c	a5 3d		lda $3d				lda 	gxzScreen+1
.c70e	a70e	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.c710	a710	90 06		bcc $a718			bcc 	_GXAXExit
.c712	a712	e9 20		sbc #$20			sbc 	#$20 						; fix up
.c714	a714	85 3d		sta $3d				sta 	gxzScreen+1
.c716	a716	e6 0b		inc $0b				inc 	GXEditSlot 				; next page
.c718	a718					_GXAXExit:
.c718	a718	60		rts				rts
.c719	a719					GXIncrementY:
.c719	a719	ee 7c 06	inc $067c			inc 	GXY0
.c71c	a71c	20 95 ab	jsr $ab95			jsr 	GXMovePositionDown
.c71f	a71f	60		rts				rts
.c720	a720					GXLineSetup:
.c720	a720	ad 80 06	lda $0680			lda 	GXY1
.c723	a723	38		sec				sec
.c724	a724	ed 7c 06	sbc $067c			sbc 	GXY0
.c727	a727	4a		lsr a				lsr 	a
.c728	a728	8d 18 07	sta $0718			sta 	GXDiffY
.c72b	a72b	9c 1a 07	stz $071a			stz 	GXDXNegative 				; clear -ve flag
.c72e	a72e	38		sec				sec
.c72f	a72f	ad 7e 06	lda $067e			lda 	GXX1
.c732	a732	ed 7a 06	sbc $067a			sbc 	GXX0
.c735	a735	8d 17 07	sta $0717			sta 	GXDiffX
.c738	a738	ad 7f 06	lda $067f			lda 	GXX1+1 						; calculate MSB
.c73b	a73b	ed 7b 06	sbc $067b			sbc 	GXX0+1
.c73e	a73e	6a		ror a				ror 	a 							; rotate bit into DiffX halving it
.c73f	a73f	6e 17 07	ror $0717			ror 	GXDiffX
.c742	a742	0a		asl a				asl 	a
.c743	a743	10 0c		bpl $a751			bpl 	_GDXNotNegative
.c745	a745	a9 00		lda #$00			lda 	#0 							; make absolute value of |dx|
.c747	a747	38		sec				sec
.c748	a748	ed 17 07	sbc $0717			sbc 	GXDiffX
.c74b	a74b	8d 17 07	sta $0717			sta 	GXDiffX
.c74e	a74e	ce 1a 07	dec $071a			dec 	GXDXNegative 				; -ve flag = $FF.
.c751	a751					_GDXNotNegative:
.c751	a751	9c 19 07	stz $0719			stz 	GXIsDiffYLarger 			; clear larger flag
.c754	a754	ad 18 07	lda $0718			lda 	GXDiffY 					; set adjust and total.
.c757	a757	8d 1c 07	sta $071c			sta 	GXAdjust
.c75a	a75a	ad 17 07	lda $0717			lda 	GXDiffX
.c75d	a75d	8d 1d 07	sta $071d			sta 	GXTotal
.c760	a760	ad 18 07	lda $0718			lda 	GXDiffY 					; if dy > dx
.c763	a763	cd 17 07	cmp $0717			cmp 	GXDiffX
.c766	a766	90 0f		bcc $a777			bcc 	_GDXNotLarger
.c768	a768	ce 19 07	dec $0719			dec 	GXIsDiffYLarger 			; set the dy larger flag
.c76b	a76b	ad 17 07	lda $0717			lda 	GXDiffX 					; set adjust and total other way round
.c76e	a76e	8d 1c 07	sta $071c			sta 	GXAdjust
.c771	a771	ad 18 07	lda $0718			lda 	GXDiffY
.c774	a774	8d 1d 07	sta $071d			sta 	GXTotal
.c777	a777					_GDXNotLarger:
.c777	a777	ad 1d 07	lda $071d			lda 	GXTotal
.c77a	a77a	4a		lsr a				lsr 	a
.c77b	a77b	8d 1b 07	sta $071b			sta 	GXPosition
.c77e	a77e	60		rts				rts
.0717						GXDiffX:
>0717								.fill 	1
.0718						GXDiffY:
>0718								.fill 	1
.0719						GXIsDiffYLarger:
>0719								.fill 	1
.071a						GXDXNegative:
>071a								.fill 	1
.071b						GXPosition:
>071b								.fill 	1
.071c						GXAdjust:
>071c								.fill 	1
.071d						GXTotal:
>071d								.fill 	1
.071e						GXAddSelect:
>071e								.fill 	1
.c77f	a77f					GXSetColourMode:
.c77f	a77f	a6 36		ldx $36				ldx 	gxzTemp0
.c781	a781	8e 88 06	stx $0688			stx 	gxColour 								; set colour
.c784	a784	a5 37		lda $37				lda 	gxzTemp0+1 								;
.c786	a786	8d 87 06	sta $0687			sta 	gxMode 									; set mode
.c789	a789	29 03		and #$03			and 	#3 										; only interested in bits 0-3
.c78b	a78b	9c 8a 06	stz $068a			stz 	gxANDValue 								; initially AND with 0, and EOR with Colour
.c78e	a78e	ae 88 06	ldx $0688			ldx 	gxColour
.c791	a791	8e 89 06	stx $0689			stx 	gxEORValue
.c794	a794	c9 02		cmp #$02			cmp 	#2 										; if mode 2/3 And with colour
.c796	a796	90 03		bcc $a79b			bcc 	_GXSDCNotAndColour
.c798	a798	8e 8a 06	stx $068a			stx 	gxANDValue
.c79b	a79b					_GXSDCNotAndColour:
.c79b	a79b	d0 03		bne $a7a0			bne 	_GXSDCNotAnd 							; mode 2, Don't EOR with colour
.c79d	a79d	9c 89 06	stz $0689			stz 	gxEORValue
.c7a0	a7a0					_GXSDCNotAnd:
.c7a0	a7a0	4a		lsr a				lsr 	a 										; if bit 0 set, 1's complement AND value
.c7a1	a7a1	90 08		bcc $a7ab			bcc 	_GXSDCNoFlip
.c7a3	a7a3	ad 8a 06	lda $068a			lda	 	gxANDValue
.c7a6	a7a6	49 ff		eor #$ff			eor 	#$FF
.c7a8	a7a8	8d 8a 06	sta $068a			sta 	gxANDValue
.c7ab	a7ab					_GXSDCNoFlip:
.c7ab	a7ab	18		clc				clc
.c7ac	a7ac	60		rts				rts
.c7ad	a7ad					GXPlotPoint:
.c7ad	a7ad	20 2f ab	jsr $ab2f			jsr 	GXOpenBitmap 				; start drawing
.c7b0	a7b0	20 3f ab	jsr $ab3f			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.c7b3	a7b3	ac 8c 06	ldy $068c			ldy 	gsOffset
.c7b6	a7b6	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.c7b8	a7b8	2d 8a 06	and $068a			and 	gxANDValue
.c7bb	a7bb	4d 89 06	eor $0689			eor 	gxEORValue
.c7be	a7be	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.c7c0	a7c0	20 37 ab	jsr $ab37			jsr 	GXCloseBitmap 				; stop drawing and exit
.c7c3	a7c3	18		clc				clc
.c7c4	a7c4	60		rts				rts
.c7c5	a7c5					GXFillRectangle:
.c7c5	a7c5	38		sec				sec
.c7c6	a7c6	80 01		bra $a7c9			bra 	GXRectangle
.c7c8	a7c8					GXFrameRectangle:
.c7c8	a7c8	18		clc				clc
.c7c9	a7c9					GXRectangle:
.c7c9	a7c9	ad 83 06	lda $0683			lda 	gxBitmapsOn
.c7cc	a7cc	f0 35		beq $a803			beq 	_GXRFail
.c7ce	a7ce	08		php				php 								; save Fill flag (CS)
.c7cf	a7cf	20 2f ab	jsr $ab2f			jsr 	GXOpenBitmap 				; start drawing
.c7d2	a7d2	20 57 ac	jsr $ac57			jsr 	GXSortXY 					; sort both X and Y so top left/bottom right
.c7d5	a7d5	20 3f ab	jsr $ab3f			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.c7d8	a7d8	38		sec				sec 								; sec = Draw line
.c7d9	a7d9	20 05 a8	jsr $a805			jsr 	GXDrawLineX1X0 				; draw a line length X1-X0
.c7dc	a7dc	ad 7c 06	lda $067c			lda 	gxY0 						; reached end of rectangle ?
.c7df	a7df	cd 80 06	cmp $0680			cmp 	gxY1
.c7e2	a7e2	f0 19		beq $a7fd			beq 	_GXRectangleExit
.c7e4	a7e4					_GXRectLoop:
.c7e4	a7e4	20 95 ab	jsr $ab95			jsr 	GXMovePositionDown 			; down one.
.c7e7	a7e7	ee 7c 06	inc $067c			inc 	gxY0 						; change Y pos
.c7ea	a7ea	ad 7c 06	lda $067c			lda 	gxY0 						; reached last line
.c7ed	a7ed	cd 80 06	cmp $0680			cmp 	gXY1
.c7f0	a7f0	f0 07		beq $a7f9			beq 	_GXLastLine
.c7f2	a7f2	28		plp				plp 								; get flag back
.c7f3	a7f3	08		php				php
.c7f4	a7f4	20 05 a8	jsr $a805			jsr 	GXDrawLineX1X0 				; draw horizontal line
.c7f7	a7f7	80 eb		bra $a7e4			bra 	_GXRectLoop
.c7f9	a7f9					_GXLastLine:
.c7f9	a7f9	38		sec				sec
.c7fa	a7fa	20 05 a8	jsr $a805			jsr 	GXDrawLineX1X0
.c7fd	a7fd					_GXRectangleExit:
.c7fd	a7fd	68		pla				pla 								; throw fill flag.
.c7fe	a7fe	20 37 ab	jsr $ab37			jsr 	GXCloseBitmap 				; stop drawing and exit
.c801	a801	18		clc				clc
.c802	a802	60		rts				rts
.c803	a803					_GXRFail:
.c803	a803	38		sec				sec
.c804	a804	60		rts				rts
.c805	a805					GXDrawLineX1X0:
.c805	a805	08		php				php 								; save solid/either-end
.c806	a806	38		sec				sec
.c807	a807	ad 7e 06	lda $067e			lda		gXX1
.c80a	a80a	ed 7a 06	sbc $067a			sbc 	gXX0
.c80d	a80d	85 36		sta $36				sta 	gxzTemp0
.c80f	a80f	ad 7f 06	lda $067f			lda 	gXX1+1
.c812	a812	ed 7b 06	sbc $067b			sbc 	gXX0+1
.c815	a815	85 37		sta $37				sta 	gxzTemp0+1
.c817	a817	28		plp				plp
.c818	a818					GXDrawLineTemp0:
.c818	a818	a5 3c		lda $3c				lda 	gxzScreen 						; push gxzScreen, gsOffset and GXEditSlot on stack
.c81a	a81a	48		pha				pha
.c81b	a81b	a5 3d		lda $3d				lda 	gxzScreen+1
.c81d	a81d	48		pha				pha
.c81e	a81e	ad 8c 06	lda $068c			lda 	gsOffset
.c821	a821	48		pha				pha
.c822	a822	a5 0b		lda $0b				lda 	GXEditSlot
.c824	a824	48		pha				pha
.c825	a825	ac 8c 06	ldy $068c			ldy 	gsOffset 					; Y offset
.c828	a828	90 1e		bcc $a848			bcc 	_GXDLTEndPoints 			; if CC draw end points only.
.c82a	a82a					_GXDLTLine:
.c82a	a82a	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.c82c	a82c	2d 8a 06	and $068a			and 	gxANDValue
.c82f	a82f	4d 89 06	eor $0689			eor 	gxEORValue
.c832	a832	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.c834	a834	a5 36		lda $36				lda 	gxzTemp0 					; decrement counter
.c836	a836	d0 04		bne $a83c			bne 	_GXDLTNoBorrow
.c838	a838	c6 37		dec $37				dec 	gxzTemp0+1 					; borrow, if goes -ve then exit
.c83a	a83a	30 2e		bmi $a86a			bmi 	_GXDLTExit
.c83c	a83c					_GXDLTNoBorrow:
.c83c	a83c	c6 36		dec $36				dec 	gxzTemp0
.c83e	a83e	c8		iny				iny 								; next slot.
.c83f	a83f	d0 e9		bne $a82a			bne 	_GXDLTLine
.c841	a841	e6 3d		inc $3d				inc 	gxzScreen+1 					; carry to next
.c843	a843	20 78 a8	jsr $a878			jsr 	GXDLTCheckWrap				; check for new page.
.c846	a846	80 e2		bra $a82a			bra 	_GXDLTLine
.c848	a848					_GXDLTEndPoints:
.c848	a848	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.c84a	a84a	2d 8a 06	and $068a			and 	gxANDValue
.c84d	a84d	4d 89 06	eor $0689			eor 	gxEORValue
.c850	a850	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.c852	a852	98		tya				tya 								; advance to right side
.c853	a853	18		clc				clc
.c854	a854	65 36		adc $36				adc 	gxzTemp0
.c856	a856	a8		tay				tay
.c857	a857	a5 3d		lda $3d				lda 	gxzScreen+1
.c859	a859	65 37		adc $37				adc 	gxzTemp0+1
.c85b	a85b	85 3d		sta $3d				sta 	gxzScreen+1
.c85d	a85d	20 78 a8	jsr $a878			jsr 	GXDLTCheckWrap 			; fix up.
.c860	a860	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.c862	a862	2d 8a 06	and $068a			and 	gxANDValue
.c865	a865	4d 89 06	eor $0689			eor 	gxEORValue
.c868	a868	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.c86a	a86a					_GXDLTExit:
.c86a	a86a	68		pla				pla
.c86b	a86b	85 0b		sta $0b				sta 	GXEditSlot
.c86d	a86d	68		pla				pla
.c86e	a86e	8d 8c 06	sta $068c			sta 	gsOffset
.c871	a871	68		pla				pla
.c872	a872	85 3d		sta $3d				sta 	gxzScreen+1
.c874	a874	68		pla				pla
.c875	a875	85 3c		sta $3c				sta 	gxzScreen
.c877	a877	60		rts				rts
.c878	a878					GXDLTCheckWrap:
.c878	a878	a5 3d		lda $3d				lda 	gxzScreen+1 					; check end of page
.c87a	a87a	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8)
.c87c	a87c	90 06		bcc $a884			bcc 	_GXDLTCWExit
.c87e	a87e	e9 20		sbc #$20			sbc 	#$20 						; fix up
.c880	a880	85 3d		sta $3d				sta 	gxzScreen+1
.c882	a882	e6 0b		inc $0b				inc 	GXEditSlot
.c884	a884					_GXDLTCWExit:
.c884	a884	60		rts				rts
.c885	a885					GXDrawGraphicElement:
.c885	a885	8d 1f 07	sta $071f			sta 	gxSize 						; save size
.c888	a888	3a		dec a				dec 	a
.c889	a889	8d 20 07	sta $0720			sta 	gxMask 						; and mask
.c88c	a88c	ad 83 06	lda $0683			lda 	gxBitmapsOn 				; check BMP on
.c88f	a88f	f0 67		beq $a8f8			beq 	_GXSLFail
.c891	a891	ad 7c 06	lda $067c			lda 	gxY0 						; push Y on stack
.c894	a894	48		pha				pha
.c895	a895	8c 22 07	sty $0722			sty 	gxAcquireVector+1 			; and acquisition vector
.c898	a898	8e 21 07	stx $0721			stx 	gxAcquireVector
.c89b	a89b	20 2f ab	jsr $ab2f			jsr 	gxOpenBitmap 				; open the bitmap.
.c89e	a89e	ad 24 07	lda $0724			lda 	gxUseMode 					; scale bits
.c8a1	a8a1	4a		lsr a				lsr 	a
.c8a2	a8a2	4a		lsr a				lsr 	a
.c8a3	a8a3	4a		lsr a				lsr 	a
.c8a4	a8a4	29 07		and #$07			and		#7
.c8a6	a8a6	1a		inc a				inc 	a
.c8a7	a8a7	8d 23 07	sta $0723			sta 	gxScale
.c8aa	a8aa	64 38		stz $38				stz 	gxzTemp1					; start first line
.c8ac	a8ac					_GXGELoop:
.c8ac	a8ac	a5 38		lda $38				lda 	gxzTemp1 					; current line number to read.
.c8ae	a8ae	2c 24 07	bit $0724			bit 	gxUseMode 					; check for flip.
.c8b1	a8b1	10 06		bpl $a8b9			bpl		_GXNoVFlip
.c8b3	a8b3	ad 20 07	lda $0720			lda 	gxMask
.c8b6	a8b6	38		sec				sec
.c8b7	a8b7	e5 38		sbc $38				sbc 	gxzTemp1
.c8b9	a8b9					_GXNoVFlip:
.c8b9	a8b9	aa		tax				tax 								; get the Xth line.
.c8ba	a8ba	20 fa a8	jsr $a8fa			jsr 	_GXCallAcquire 				; get that data.
.c8bd	a8bd	ad 23 07	lda $0723			lda 	gxScale 					; do scale identical copies of that line.
.c8c0	a8c0	85 39		sta $39				sta 	gxzTemp1+1
.c8c2	a8c2					_GXGELoop2:
.c8c2	a8c2	ad 7c 06	lda $067c			lda 	gxY0 						; off screen
.c8c5	a8c5	cd 86 06	cmp $0686			cmp 	gxHeight
.c8c8	a8c8	b0 10		bcs $a8da			bcs 	_GXDGEExit
.c8ca	a8ca	20 fd a8	jsr $a8fd			jsr 	GXRenderOneLine 			; render line
.c8cd	a8cd	c6 39		dec $39				dec 	gxzTemp1+1 					; scale times.
.c8cf	a8cf	d0 f1		bne $a8c2			bne 	_GXGELoop2
.c8d1	a8d1	e6 38		inc $38				inc 	gxzTemp1 					; done all lines.
.c8d3	a8d3	a5 38		lda $38				lda 	gxzTemp1
.c8d5	a8d5	cd 1f 07	cmp $071f			cmp 	gxSize
.c8d8	a8d8	d0 d2		bne $a8ac			bne 	_GXGELoop
.c8da	a8da					_GXDGEExit:
.c8da	a8da	68		pla				pla 								; restore Y for next time
.c8db	a8db	8d 7c 06	sta $067c			sta 	gxY0
.c8de	a8de	ae 23 07	ldx $0723			ldx 	gxScale 					; get scale (1-8)
.c8e1	a8e1					_GXShiftLeft:
.c8e1	a8e1	18		clc				clc
.c8e2	a8e2	ad 1f 07	lda $071f			lda 	gxSize
.c8e5	a8e5	6d 7a 06	adc $067a			adc 	gxX0
.c8e8	a8e8	8d 7a 06	sta $067a			sta 	gxX0
.c8eb	a8eb	90 03		bcc $a8f0			bcc 	_GXSLNoCarry
.c8ed	a8ed	ee 7b 06	inc $067b			inc 	gxX0+1
.c8f0	a8f0					_GXSLNoCarry:
.c8f0	a8f0	ca		dex				dex
.c8f1	a8f1	d0 ee		bne $a8e1			bne 	_GXShiftLeft
.c8f3	a8f3	20 37 ab	jsr $ab37			jsr 	GXCloseBitmap
.c8f6	a8f6	18		clc				clc
.c8f7	a8f7	60		rts				rts
.c8f8	a8f8					_GXSLFail:
.c8f8	a8f8	38		sec				sec
.c8f9	a8f9	60		rts				rts
.c8fa	a8fa					_GXCallAcquire:
.c8fa	a8fa	6c 21 07	jmp ($0721)			jmp 	(gxAcquireVector)
.c8fd	a8fd					GXRenderOneLine:
.c8fd	a8fd	20 3f ab	jsr $ab3f			jsr 	GXPositionCalc 				; calculate position/offset.
.c900	a900	ac 8c 06	ldy $068c			ldy 	gsOffset 					; Y contains position.
.c903	a903	64 3a		stz $3a				stz 	gxzTemp2 					; do size pixels
.c905	a905					_GXROLLoop1:
.c905	a905	ad 23 07	lda $0723			lda 	gxScale 					; set to do 'scale' times
.c908	a908	85 3b		sta $3b				sta 	gxzTemp2+1
.c90a	a90a					_GXROLLoop2:
.c90a	a90a	a5 3a		lda $3a				lda 	gxzTemp2 					; get current pixel
.c90c	a90c	2c 87 06	bit $0687			bit 	gxMode 						; check H Flip
.c90f	a90f	50 06		bvc $a917			bvc 	_GXNoHFlip
.c911	a911	ad 20 07	lda $0720			lda 	gxMask
.c914	a914	38		sec				sec
.c915	a915	e5 3a		sbc $3a				sbc 	gxzTemp2
.c917	a917					_GXNoHFlip:
.c917	a917	aa		tax				tax 								; read from the pixel buffer
.c918	a918	bd 27 06	lda $0627,x			lda 	gxPixelBuffer,x
.c91b	a91b	d0 07		bne $a924			bne 	_GXDraw 					; draw if non zero
.c91d	a91d	ad 24 07	lda $0724			lda 	gxUseMode 					; check to see if solid background
.c920	a920	29 04		and #$04			and 	#4
.c922	a922	f0 0a		beq $a92e			beq 	_GXZeroPixel
.c924	a924					_GXDraw:
.c924	a924	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.c926	a926	2d 8a 06	and $068a			and 	gxANDValue
.c929	a929	5d 27 06	eor $0627,x			eor 	gxPixelBuffer,x
.c92c	a92c	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.c92e	a92e					_GXZeroPixel:
.c92e	a92e	c8		iny				iny 								; advance pointer
.c92f	a92f	d0 05		bne $a936			bne 	_GXNoShift
.c931	a931	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.c933	a933	20 78 a8	jsr $a878			jsr 	GXDLTCheckWrap				; check for new page.
.c936	a936					_GXNoShift:
.c936	a936	c6 3b		dec $3b				dec 	gxzTemp2+1 					; do the inner loop gxScale times.
.c938	a938	d0 d0		bne $a90a			bne 	_GXROLLoop2
.c93a	a93a	e6 3a		inc $3a				inc 	gxzTemp2 					; next pixel.
.c93c	a93c	a5 3a		lda $3a				lda 	gxzTemp2
.c93e	a93e	cd 1f 07	cmp $071f			cmp 	gxSize
.c941	a941	d0 c2		bne $a905			bne 	_GXROLLoop1
.c943	a943	ee 7c 06	inc $067c			inc 	gxY0
.c946	a946	60		rts				rts
.071f						gxSize:
>071f								.fill 	1
.0720						gxMask:
>0720								.fill 	1
.0721						gxAcquireVector:
>0721								.fill 	2
.0723						gxScale:
>0723								.fill 	1
.0724						gxUseMode:
>0724								.fill 	1
.c947	a947					GXFontHandler:
.c947	a947	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.c949	a949	4d 87 06	eor $0687			eor 	gxMode
.c94c	a94c	8d 24 07	sta $0724			sta 	gxUseMode
.c94f	a94f	64 37		stz $37				stz 	gxzTemp0+1 					; gxzTemp0 is font #
.c951	a951	06 36		asl $36				asl	 	gxzTemp0 					; x 2
.c953	a953	26 37		rol $37				rol	 	gxzTemp0+1
.c955	a955	06 36		asl $36				asl	 	gxzTemp0 					; x 4
.c957	a957	26 37		rol $37				rol	 	gxzTemp0+1
.c959	a959	06 36		asl $36				asl	 	gxzTemp0 					; x 8
.c95b	a95b	26 37		rol $37				rol	 	gxzTemp0+1
.c95d	a95d	a5 37		lda $37				lda 	gxzTemp0+1 					; put in page C0
.c95f	a95f	09 c0		ora #$c0			ora 	#$C0
.c961	a961	85 37		sta $37				sta 	gxzTemp0+1
.c963	a963	a9 08		lda #$08			lda 	#8 							; size 8x8
.c965	a965	a2 6d		ldx #$6d			ldx 	#GXGetGraphicDataFont & $FF ; XY = Graphic Data retrieval routine
.c967	a967	a0 a9		ldy #$a9			ldy 	#GXGetGraphicDataFont >> 8
.c969	a969	20 85 a8	jsr $a885			jsr 	GXDrawGraphicElement
.c96c	a96c	60		rts				rts
.c96d	a96d					GXGetGraphicDataFont:
.c96d	a96d	8a		txa				txa 								; X->Y
.c96e	a96e	a8		tay				tay
.c96f	a96f	a6 01		ldx $01				ldx 	1 							; preserve old value
.c971	a971	a9 01		lda #$01			lda 	#1 							; access page 1 (font memory)
.c973	a973	85 01		sta $01				sta 	1
.c975	a975	b1 36		lda ($36),y			lda 	(gxzTemp0),y 				; read the font element.
.c977	a977	86 01		stx $01				stx 	1 							; put old value back.
.c979	a979	a2 00		ldx #$00			ldx 	#0 							; do 8 times
.c97b	a97b					_GXExpand:
.c97b	a97b	9e 27 06	stz $0627,x			stz 	gxPixelBuffer,x 			; zero in pixel buffer
.c97e	a97e	0a		asl a				asl 	a 							; shift bit 7 into C
.c97f	a97f	90 08		bcc $a989			bcc 	_GXNoPixel
.c981	a981	48		pha				pha 								; if set, set pixel buffer to current colour.
.c982	a982	ad 88 06	lda $0688			lda 	gxColour
.c985	a985	9d 27 06	sta $0627,x			sta 	gxPixelBuffer,x
.c988	a988	68		pla				pla
.c989	a989					_GXNoPixel:
.c989	a989	e8		inx				inx 								; do the whole byte.
.c98a	a98a	e0 08		cpx #$08			cpx 	#8
.c98c	a98c	d0 ed		bne $a97b			bne 	_GXExpand
.c98e	a98e	60		rts				rts
.c98f	a98f					GXSpriteHandler:
.c98f	a98f	ad 82 06	lda $0682			lda 	gxSpritesOn 				; sprites on ?
.c992	a992	f0 23		beq $a9b7			beq 	_GXSHExit
.c994	a994	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.c996	a996	4d 87 06	eor $0687			eor 	gxMode
.c999	a999	8d 24 07	sta $0724			sta 	gxUseMode
.c99c	a99c	a6 36		ldx $36				ldx 	gxzTemp0 					; sprite #
.c99e	a99e	da		phx				phx
.c99f	a99f	20 2f ab	jsr $ab2f			jsr 	GXOpenBitmap 				; can access sprite information
.c9a2	a9a2	68		pla				pla
.c9a3	a9a3	20 10 ac	jsr $ac10			jsr 	GXFindSprite 				; get the sprite address
.c9a6	a9a6	08		php				php
.c9a7	a9a7	20 37 ab	jsr $ab37			jsr 	GXCloseBitmap
.c9aa	a9aa	28		plp				plp
.c9ab	a9ab	b0 0a		bcs $a9b7			bcs		_GXSHExit 					; exit if find failed.
.c9ad	a9ad	ad 25 07	lda $0725			lda 	GXSizePixels 				; return size
.c9b0	a9b0	a2 b8		ldx #$b8			ldx 	#GXSpriteAcquire & $FF
.c9b2	a9b2	a0 a9		ldy #$a9			ldy 	#GXSpriteAcquire >> 8
.c9b4	a9b4	20 85 a8	jsr $a885			jsr 	GXDrawGraphicElement
.c9b7	a9b7					_GXSHExit:
.c9b7	a9b7	60		rts				rts
.c9b8	a9b8					GXSpriteAcquire:
.c9b8	a9b8	ad 85 06	lda $0685			lda 	GXSpritePage				; point to base page
.c9bb	a9bb	85 0b		sta $0b				sta 	GXEditSlot
.c9bd	a9bd	86 36		stx $36				stx 	zTemp0 						; row number x 1,2,3,4
.c9bf	a9bf	a9 00		lda #$00			lda 	#0
.c9c1	a9c1	ae 26 07	ldx $0726			ldx 	GXSizeBits
.c9c4	a9c4					_GXTimesRowNumber:
.c9c4	a9c4	18		clc				clc
.c9c5	a9c5	65 36		adc $36				adc 	zTemp0
.c9c7	a9c7	ca		dex				dex
.c9c8	a9c8	10 fa		bpl $a9c4			bpl 	_GXTimesRowNumber
.c9ca	a9ca	64 37		stz $37				stz 	gxzTemp0+1
.c9cc	a9cc	0a		asl a				asl 	a 							; row x 2,4,6,8
.c9cd	a9cd	26 37		rol $37				rol 	gxzTemp0+1
.c9cf	a9cf	0a		asl a				asl 	a 							; row x 4,8,12,16
.c9d0	a9d0	26 37		rol $37				rol 	gxzTemp0+1
.c9d2	a9d2	0a		asl a				asl 	a 							; row x 8,16,24,32
.c9d3	a9d3	26 37		rol $37				rol 	gxzTemp0+1
.c9d5	a9d5	85 36		sta $36				sta 	gxzTemp0
.c9d7	a9d7	18		clc				clc 								; add base address.
.c9d8	a9d8	a5 36		lda $36				lda 	gxzTemp0
.c9da	a9da	6d 28 07	adc $0728			adc 	GXSpriteOffset
.c9dd	a9dd	85 36		sta $36				sta 	gxzTemp0
.c9df	a9df	a5 37		lda $37				lda 	gxzTemp0+1
.c9e1	a9e1	6d 29 07	adc $0729			adc 	GXSpriteOffset+1
.c9e4	a9e4					_GXSAFindPage:
.c9e4	a9e4	c9 20		cmp #$20			cmp 	#$20 						; on this page
.c9e6	a9e6	90 06		bcc $a9ee			bcc 	_GXSAFoundPage
.c9e8	a9e8	e9 20		sbc #$20			sbc 	#$20 						; forward one page
.c9ea	a9ea	e6 0b		inc $0b				inc 	GXEditSlot
.c9ec	a9ec	80 f6		bra $a9e4			bra 	_GXSAFindPage
.c9ee	a9ee					_GXSAFoundPage:
.c9ee	a9ee	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; physical address of page.
.c9f0	a9f0	85 37		sta $37				sta 	gxzTemp0+1 					; gxzTemp0 now points to the page
.c9f2	a9f2	a0 00		ldy #$00			ldy 	#0
.c9f4	a9f4					_GXSACopyLoop:
.c9f4	a9f4	b1 36		lda ($36),y			lda 	(gxzTemp0),y
.c9f6	a9f6	99 27 06	sta $0627,y			sta 	gxPixelBuffer,y
.c9f9	a9f9	c8		iny				iny
.c9fa	a9fa	cc 25 07	cpy $0725			cpy 	GXSizePixels
.c9fd	a9fd	d0 f5		bne $a9f4			bne 	_GXSACopyLoop
.c9ff	a9ff	60		rts				rts
.ca00	aa00					GXSelect:
.ca00	aa00	ad 82 06	lda $0682			lda 	gxSpritesOn
.ca03	aa03	f0 22		beq $aa27			beq 	_GXSFail
.ca05	aa05	a5 36		lda $36				lda 	gxzTemp0 					; illegal sprite #
.ca07	aa07	c9 40		cmp #$40			cmp 	#64
.ca09	aa09	b0 1c		bcs $aa27			bcs 	_GXSFail
.ca0b	aa0b	8d 8d 06	sta $068d			sta 	GSCurrentSpriteID
.ca0e	aa0e	a4 37		ldy $37				ldy 	gxzTemp0+1 					; control value.
.ca10	aa10	a9 00		lda #$00			lda  	#0 							; multiply sprite # x 8 => A
.ca12	aa12	06 36		asl $36				asl 	gxzTemp0
.ca14	aa14	06 36		asl $36				asl 	gxzTemp0
.ca16	aa16	06 36		asl $36				asl 	gxzTemp0
.ca18	aa18	2a		rol a				rol 	a
.ca19	aa19	69 d9		adc #$d9			adc 	#$D9 						; sprite area
.ca1b	aa1b	8d 8f 06	sta $068f			sta 	GSCurrentSpriteAddr+1 		; address to GSCurrentSprite and gxzTemp
.ca1e	aa1e	85 37		sta $37				sta 	gxzTemp0+1
.ca20	aa20	a5 36		lda $36				lda 	gxzTemp0
.ca22	aa22	8d 8e 06	sta $068e			sta 	GSCurrentSpriteAddr
.ca25	aa25	18		clc				clc
.ca26	aa26	60		rts				rts
.ca27	aa27					_GXSFail:
.ca27	aa27	38		sec				sec
.ca28	aa28	60		rts				rts
.ca29	aa29					GXSelectImage:
.ca29	aa29	ad 82 06	lda $0682			lda 	gxSpritesOn
.ca2c	aa2c	f0 74		beq $aaa2			beq 	_GXSIFail
.ca2e	aa2e	ad 8f 06	lda $068f			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.ca31	aa31	f0 6f		beq $aaa2			beq 	_GXSIFail 					; (checking the MSB)
.ca33	aa33	64 01		stz $01				stz 	1
.ca35	aa35	a5 37		lda $37				lda 	gxzTemp0+1 					; push show/hide on the stack.
.ca37	aa37	d0 6b		bne $aaa4			bne 	_GXSIHide
.ca39	aa39	a5 36		lda $36				lda 	gxzTemp0 					; sprite image
.ca3b	aa3b	48		pha				pha
.ca3c	aa3c	20 2f ab	jsr $ab2f			jsr 	GXOpenBitmap
.ca3f	aa3f	68		pla				pla
.ca40	aa40	20 10 ac	jsr $ac10			jsr 	GXFindSprite
.ca43	aa43	b0 5a		bcs $aa9f			bcs 	_GXSICloseFail 				; no image
.ca45	aa45	a0 01		ldy #$01			ldy 	#1
.ca47	aa47	ad 8e 06	lda $068e			lda 	GSCurrentSpriteAddr
.ca4a	aa4a	85 36		sta $36				sta 	gxzTemp0
.ca4c	aa4c	ad 8f 06	lda $068f			lda 	GSCurrentSpriteAddr+1
.ca4f	aa4f	85 37		sta $37				sta 	gxzTemp0+1
.ca51	aa51	ad 28 07	lda $0728			lda 	GXSpriteOffset
.ca54	aa54	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.ca56	aa56	18		clc				clc
.ca57	aa57	ad 29 07	lda $0729			lda 	GXSpriteOffset+1
.ca5a	aa5a	6d 90 06	adc $0690			adc 	GXSpriteOffsetBase
.ca5d	aa5d	c8		iny				iny
.ca5e	aa5e	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.ca60	aa60	ad 91 06	lda $0691			lda 	GXSpriteOffsetBase+1
.ca63	aa63	69 00		adc #$00			adc 	#0
.ca65	aa65	c8		iny				iny
.ca66	aa66	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.ca68	aa68	ad 26 07	lda $0726			lda 	GXSizeBits 					; get raw size
.ca6b	aa6b	49 03		eor #$03			eor 	#3 							; make it right (00=32 etc.)
.ca6d	aa6d	2a		rol a				rol 	a 							; x 2
.ca6e	aa6e	0a		asl a				asl 	a 							; x 4
.ca6f	aa6f	0a		asl a				asl 	a 							; x 8
.ca70	aa70	0a		asl a				asl 	a 							; x 16
.ca71	aa71	0d 27 07	ora $0727			ora 	GXSpriteLUT 				; Or with LUT
.ca74	aa74	0a		asl a				asl 	a 							; 1 shift
.ca75	aa75	09 01		ora #$01			ora 	#1 							; enable sprite.
.ca77	aa77	92 36		sta ($36)			sta 	(gxzTemp0) 					; and write back
.ca79	aa79	20 37 ab	jsr $ab37			jsr 	GXCloseBitmap
.ca7c	aa7c	ae 8d 06	ldx $068d			ldx 	GSCurrentSpriteID 			; point to sprite entries.
.ca7f	aa7f	bd d2 06	lda $06d2,x			lda 	GXSpriteHigh,x 				; clear upper two bits of size
.ca82	aa82	29 3f		and #$3f			and 	#$3F
.ca84	aa84	9d d2 06	sta $06d2,x			sta 	GXSpriteHigh,x
.ca87	aa87	ad 26 07	lda $0726			lda 	GXSizeBits 					; get bit size
.ca8a	aa8a	6a		ror a				ror 	a 							; shift into bits 6/7
.ca8b	aa8b	6a		ror a				ror 	a
.ca8c	aa8c	6a		ror a				ror 	a
.ca8d	aa8d	29 c0		and #$c0			and 	#$C0
.ca8f	aa8f	1d d2 06	ora $06d2,x			ora 	GXSpriteHigh,x 				; put in  upper 2 bits of sprite data
.ca92	aa92	9d d2 06	sta $06d2,x			sta 	GXSpriteHigh,x
.ca95	aa95	bd 92 06	lda $0692,x			lda 	GXSpriteLow,x 				; clear hidden flag.
.ca98	aa98	29 7f		and #$7f			and 	#$7F
.ca9a	aa9a	9d 92 06	sta $0692,x			sta 	GXSpriteLow,x
.ca9d	aa9d	18		clc				clc
.ca9e	aa9e	60		rts				rts
.ca9f	aa9f					_GXSICloseFail:
.ca9f	aa9f	20 37 ab	jsr $ab37			jsr 	GXCloseBitmap
.caa2	aaa2					_GXSIFail:
.caa2	aaa2	38		sec				sec
.caa3	aaa3	60		rts				rts
.caa4	aaa4					_GXSIHide:
.caa4	aaa4	ad 8e 06	lda $068e			lda 	GSCurrentSpriteAddr  		; get Sprite h/w address and write there
.caa7	aaa7	85 36		sta $36				sta 	gxzTemp0
.caa9	aaa9	ad 8f 06	lda $068f			lda 	GSCurrentSpriteAddr+1
.caac	aaac	85 37		sta $37				sta 	gxzTemp0+1
.caae	aaae	a9 00		lda #$00			lda 	#0
.cab0	aab0	92 36		sta ($36)			sta 	(gxzTemp0)
.cab2	aab2	ae 8d 06	ldx $068d			ldx 	GSCurrentSpriteID 			; get sprite ID
.cab5	aab5	bd 92 06	lda $0692,x			lda 	GXSpriteLow,x 				; set the hidden bit.
.cab8	aab8	09 80		ora #$80			ora 	#$80
.caba	aaba	9d 92 06	sta $0692,x			sta 	GXSpriteLow,x
.cabd	aabd	18		clc				clc
.cabe	aabe	60		rts				rts
.cabf	aabf					GXMoveSprite:
.cabf	aabf	ad 82 06	lda $0682			lda 	gxSpritesOn
.cac2	aac2	f0 65		beq $ab29			beq 	_GXSIFail
.cac4	aac4	ad 8f 06	lda $068f			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.cac7	aac7	f0 60		beq $ab29			beq 	_GXSIFail
.cac9	aac9	85 37		sta $37				sta 	gxzTemp0+1
.cacb	aacb	a0 04		ldy #$04			ldy 	#4
.cacd	aacd	ad 8e 06	lda $068e			lda 	GSCurrentSpriteAddr
.cad0	aad0	85 36		sta $36				sta 	gxzTemp0
.cad2	aad2	ae 8d 06	ldx $068d			ldx 	GSCurrentSpriteID 			; get the size from the upper two bits
.cad5	aad5	bd d2 06	lda $06d2,x			lda 	GXSpriteHigh,x
.cad8	aad8	2a		rol a				rol 	a	 						; into bits 0,1.
.cad9	aad9	2a		rol a				rol 	a
.cada	aada	2a		rol a				rol 	a
.cadb	aadb	29 03		and #$03			and 	#3
.cadd	aadd	aa		tax				tax
.cade	aade	bd 2b ab	lda $ab2b,x			lda 	_GXMSOffset,x 				; get 32-SpriteSize/2
.cae1	aae1	48		pha				pha
.cae2	aae2	18		clc				clc
.cae3	aae3	6d 7a 06	adc $067a			adc 	gxX0						; copy position.
.cae6	aae6	91 36		sta ($36),y			sta 	(gxzTemp0),y
.cae8	aae8	c8		iny				iny
.cae9	aae9	ad 7b 06	lda $067b			lda 	gxX0+1
.caec	aaec	69 00		adc #$00			adc 	#0
.caee	aaee	91 36		sta ($36),y			sta 	(gxzTemp0),y
.caf0	aaf0	c8		iny				iny
.caf1	aaf1	68		pla				pla
.caf2	aaf2	18		clc				clc
.caf3	aaf3	6d 7c 06	adc $067c			adc 	gxY0
.caf6	aaf6	91 36		sta ($36),y			sta 	(gxzTemp0),y
.caf8	aaf8	a9 00		lda #$00			lda 	#0
.cafa	aafa	69 00		adc #$00			adc 	#0
.cafc	aafc	c8		iny				iny
.cafd	aafd	91 36		sta ($36),y			sta 	(gxzTemp0),y
.caff	aaff	4e 7b 06	lsr $067b			lsr 	gxX0+1 						; divide X by 4
.cb02	ab02	6e 7a 06	ror $067a			ror 	gxX0
.cb05	ab05	4e 7a 06	lsr $067a			lsr 	gxX0
.cb08	ab08	4e 7c 06	lsr $067c			lsr 	gxY0 						; divide Y by 4
.cb0b	ab0b	4e 7c 06	lsr $067c			lsr 	gxY0
.cb0e	ab0e	ae 8d 06	ldx $068d			ldx 	GSCurrentSpriteID 			; copy X/4 and Y/4 into the status bytes
.cb11	ab11	bd 92 06	lda $0692,x			lda 	GXSpriteLow,x
.cb14	ab14	29 80		and #$80			and 	#$80
.cb16	ab16	0d 7a 06	ora $067a			ora 	gxX0
.cb19	ab19	9d 92 06	sta $0692,x			sta 	GXSpriteLow,x
.cb1c	ab1c	bd d2 06	lda $06d2,x			lda 	GXSpriteHigh,x
.cb1f	ab1f	29 c0		and #$c0			and 	#$C0
.cb21	ab21	0d 7c 06	ora $067c			ora 	gxY0
.cb24	ab24	9d d2 06	sta $06d2,x			sta 	GXSpriteHigh,x
.cb27	ab27	18		clc				clc
.cb28	ab28	60		rts				rts
.cb29	ab29					_GXSIFail:
.cb29	ab29	38		sec				sec
.cb2a	ab2a	60		rts				rts
.cb2b	ab2b					_GXMSOffset:
>cb2b	ab2b	1c						.byte 	32-8/2
>cb2c	ab2c	18						.byte 	32-16/2
>cb2d	ab2d	14						.byte 	32-24/2
>cb2e	ab2e	10						.byte 	32-32/2
.cb2f	ab2f					GXOpenBitmap:
.cb2f	ab2f	78		sei				sei 								; no interrupts here
.cb30	ab30	a5 0b		lda $0b				lda 	GXEditSlot 					; Save the original LUT slot value
.cb32	ab32	8d 8b 06	sta $068b			sta 	gxOriginalLUTValue
.cb35	ab35	58		cli				cli
.cb36	ab36	60		rts				rts
.cb37	ab37					GXCloseBitmap:
.cb37	ab37	78		sei				sei
.cb38	ab38	ad 8b 06	lda $068b			lda 	gxOriginalLUTValue 			; restore LUT slot value
.cb3b	ab3b	85 0b		sta $0b				sta 	GXEditSlot
.cb3d	ab3d	58		cli				cli
.cb3e	ab3e	60		rts				rts
.cb3f	ab3f					GXPositionCalc:
.cb3f	ab3f	a5 36		lda $36				lda 	gxzTemp0 					; save temp memory slot
.cb41	ab41	48		pha				pha
.cb42	ab42	ad 7c 06	lda $067c			lda 	GXY0 						; gxzScreen = Y0
.cb45	ab45	85 3c		sta $3c				sta 	gxzScreen
.cb47	ab47	64 3d		stz $3d				stz 	gxzScreen+1
.cb49	ab49	06 3c		asl $3c				asl 	gxzScreen 						; gxzScreen = Y0 * 4
.cb4b	ab4b	26 3d		rol $3d				rol 	gxzScreen+1
.cb4d	ab4d	06 3c		asl $3c				asl 	gxzScreen
.cb4f	ab4f	26 3d		rol $3d				rol 	gxzScreen+1
.cb51	ab51	18		clc				clc 								; gxzScreen = Y0 * 5, as it's still in A
.cb52	ab52	65 3c		adc $3c				adc 	gxzScreen
.cb54	ab54	85 3c		sta $3c				sta 	gxzScreen
.cb56	ab56	90 02		bcc $ab5a			bcc 	_GXPCNoCarry
.cb58	ab58	e6 3d		inc $3d				inc 	gxzScreen+1
.cb5a	ab5a					_GXPCNoCarry:
.cb5a	ab5a	06 3c		asl $3c				asl 	gxzScreen 						; now Y0 * 10. Needs to be multiplied by another
.cb5c	ab5c	26 3d		rol $3d				rol 	gxzScreen+1 					; 32. At this point the MSB contains the offset
.cb5e	ab5e	a5 3d		lda $3d				lda	 	gxzScreen+1 					; so save this in zTemp0 and zero it.
.cb60	ab60	85 36		sta $36				sta 	gxzTemp0
.cb62	ab62	64 3d		stz $3d				stz 	gxzScreen+1
.cb64	ab64	a9 05		lda #$05			lda 	#5 							; now multiply by 32, this puts this in the range 0..8191
.cb66	ab66					_GXPCMultiply32:
.cb66	ab66	06 3c		asl $3c				asl 	gxzScreen
.cb68	ab68	26 3d		rol $3d				rol 	gxzScreen+1
.cb6a	ab6a	3a		dec a				dec 	a
.cb6b	ab6b	d0 f9		bne $ab66			bne 	_GXPCMultiply32
.cb6d	ab6d	18		clc				clc
.cb6e	ab6e	ad 7a 06	lda $067a			lda 	GXX0 						; add X to this value, put the result in gsOffset, gxzScreen has to be on a page boundary
.cb71	ab71	65 3c		adc $3c				adc 	gxzScreen
.cb73	ab73	8d 8c 06	sta $068c			sta 	gsOffset
.cb76	ab76	ad 7b 06	lda $067b			lda 	GXX0+1
.cb79	ab79	65 3d		adc $3d				adc 	gxzScreen+1
.cb7b	ab7b	c9 20		cmp #$20			cmp 	#$20 						; has it overflowed into the next one ?
.cb7d	ab7d	90 04		bcc $ab83			bcc 	_GXPCNoOverflow
.cb7f	ab7f	29 1f		and #$1f			and 	#$1F 						; fix it up
.cb81	ab81	e6 36		inc $36				inc 	gxzTemp0 					; add 1 to the page number
.cb83	ab83					_GXPCNoOverflow:
.cb83	ab83	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; make it the address mapped in.
.cb85	ab85	85 3d		sta $3d				sta 	gxzScreen+1
.cb87	ab87	64 3c		stz $3c				stz 	gxzScreen
.cb89	ab89	18		clc				clc
.cb8a	ab8a	a5 36		lda $36				lda 	gxzTemp0 					; get the page number
.cb8c	ab8c	6d 84 06	adc $0684			adc 	gxBasePage 					; by adding the base page
.cb8f	ab8f	85 0b		sta $0b				sta 	GXEditSlot 				; and map it into memory.
.cb91	ab91	68		pla				pla
.cb92	ab92	85 36		sta $36				sta 	gxzTemp0
.cb94	ab94	60		rts				rts
.cb95	ab95					GXMovePositionDown:
.cb95	ab95	18		clc				clc 								; add 320 to offset/temp+1
.cb96	ab96	ad 8c 06	lda $068c			lda 	gsOffset
.cb99	ab99	69 40		adc #$40			adc 	#64
.cb9b	ab9b	8d 8c 06	sta $068c			sta 	gsOffset
.cb9e	ab9e	a5 3d		lda $3d				lda 	gxzScreen+1
.cba0	aba0	69 01		adc #$01			adc 	#1
.cba2	aba2	85 3d		sta $3d				sta 	gxzScreen+1
.cba4	aba4	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page
.cba6	aba6	90 07		bcc $abaf			bcc 	_GXMPDExit
.cba8	aba8	38		sec				sec  								; next page
.cba9	aba9	e9 20		sbc #$20			sbc 	#$20
.cbab	abab	85 3d		sta $3d				sta 	gxzScreen+1
.cbad	abad	e6 0b		inc $0b				inc 	GXEditSlot
.cbaf	abaf					_GXMPDExit:
.cbaf	abaf	60		rts				rts
.cbb0	abb0					GXCollide:
.cbb0	abb0	a5 36		lda $36				lda 	gxzTemp0 					; check if sprite numbers are legal.
.cbb2	abb2	aa		tax				tax
.cbb3	abb3	05 37		ora $37				ora 	gxzTemp0+1
.cbb5	abb5	29 c0		and #$c0			and 	#$C0
.cbb7	abb7	38		sec				sec
.cbb8	abb8	d0 53		bne $ac0d			bne 	_GXCollideFail 				; if either >= 64, fail.
.cbba	abba	a4 37		ldy $37				ldy 	gxzTemp0+1 					; at this point X is 1st sprite and Y is 2nd sprite.
.cbbc	abbc	b9 92 06	lda $0692,y			lda 	GXSpriteLow,y 				; check if either hidden bit is set
.cbbf	abbf	1d 92 06	ora $0692,x			ora 	GXSpriteLow,x
.cbc2	abc2	30 48		bmi $ac0c			bmi 	_GXOkayFail 				; if either hidden, then they cannot collide.
.cbc4	abc4	18		clc				clc 								; need to calculate sum of sizes.
.cbc5	abc5	b9 d2 06	lda $06d2,y			lda 	GXSpriteHigh,y
.cbc8	abc8	7d d2 06	adc $06d2,x			adc 	GXSpriteHigh,x 				; at this point, CS, Bit 6 and 7 contain that sum.
.cbcb	abcb	29 c0		and #$c0			and 	#$C0 					 	; mask off
.cbcd	abcd	6a		ror a				ror 	a 							; 5/6/7
.cbce	abce	4a		lsr a				lsr 	a 							; 4/5/6
.cbcf	abcf	4a		lsr a				lsr 	a 							; 3/4/5
.cbd0	abd0	4a		lsr a				lsr 	a 							; 2/3/4
.cbd1	abd1	18		clc				clc
.cbd2	abd2	69 08		adc #$08			adc 	#$08
.cbd4	abd4	4a		lsr a				lsr 	a 							; adjust because all coordinates are divided by 4 to store.
.cbd5	abd5	4a		lsr a				lsr 	a
.cbd6	abd6	85 38		sta $38				sta 	gxzTemp1 					; so the difference between the centres has to be less than this.
.cbd8	abd8	b9 d2 06	lda $06d2,y			lda 	GXSpriteHigh,y 				; calculate y1-y0
.cbdb	abdb	29 3f		and #$3f			and 	#$3F
.cbdd	abdd	85 39		sta $39				sta 	gxzTemp1+1
.cbdf	abdf	38		sec				sec
.cbe0	abe0	bd d2 06	lda $06d2,x			lda 	GXSpriteHigh,x
.cbe3	abe3	29 3f		and #$3f			and 	#$3F
.cbe5	abe5	e5 39		sbc $39				sbc 	gxzTemp1+1
.cbe7	abe7	b0 03		bcs $abec			bcs 	_GXCAbs1 					; calculate |y1-y0|
.cbe9	abe9	49 ff		eor #$ff			eor 	#$FF
.cbeb	abeb	1a		inc a				inc 	a
.cbec	abec					_GXCAbs1:
.cbec	abec	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.cbee	abee	b0 1c		bcs $ac0c			bcs 	_GXOkayFail
.cbf0	abf0	85 39		sta $39				sta 	gxzTemp1+1 					; save |y1-y0|
.cbf2	abf2	38		sec				sec 								; calculate |x1-x0|
.cbf3	abf3	b9 92 06	lda $0692,y			lda 	GXSpriteLow,y
.cbf6	abf6	fd 92 06	sbc $0692,x			sbc 	GXSpriteLow,x
.cbf9	abf9	b0 03		bcs $abfe			bcs 	_GXCAbs2
.cbfb	abfb	49 ff		eor #$ff			eor 	#$FF
.cbfd	abfd	1a		inc a				inc 	a
.cbfe	abfe					_GXCAbs2:
.cbfe	abfe	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.cc00	ac00	b0 0a		bcs $ac0c			bcs 	_GXOkayFail
.cc02	ac02	c5 39		cmp $39				cmp 	gxzTemp1+1 					; is it less than the previous one.
.cc04	ac04	90 02		bcc $ac08			bcc 	_GXCHaveLowest
.cc06	ac06	a5 39		lda $39				lda 	gxzTemp1+1 					; if not, that's the smallest difference.
.cc08	ac08					_GXCHaveLowest:
.cc08	ac08	0a		asl a				asl 	a 							; scale to allow for >> 2
.cc09	ac09	0a		asl a				asl 	a
.cc0a	ac0a	18		clc				clc
.cc0b	ac0b	60		rts				rts
.cc0c	ac0c					_GXOkayFail:
.cc0c	ac0c	18		clc				clc
.cc0d	ac0d					_GXCollideFail:
.cc0d	ac0d	a9 ff		lda #$ff			lda 	#$FF
.cc0f	ac0f	60		rts				rts
.cc10	ac10					GXFindSprite:
.cc10	ac10	aa		tax				tax
.cc11	ac11	ad 85 06	lda $0685			lda 	GXSpritePage 				; access the base page of the sprite
.cc14	ac14	85 0b		sta $0b				sta 	GXEditSlot
.cc16	ac16	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; check a valid sprite
.cc19	ac19	1d 00 60	ora $6000,x			ora 	GXMappingAddress,x
.cc1c	ac1c	f0 33		beq $ac51			beq 	_GXFSFail
.cc1e	ac1e	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; MSB
.cc21	ac21	8d 29 07	sta $0729			sta 	GXSpriteOffset+1
.cc24	ac24	bd 00 60	lda $6000,x			lda 	GXMappingAddress,x 			; LSB
.cc27	ac27	48		pha				pha 								; save twice
.cc28	ac28	48		pha				pha
.cc29	ac29	29 03		and #$03			and 	#3 							; get sprite size
.cc2b	ac2b	8d 26 07	sta $0726			sta 	GXSizeBits 					; save raw (0-3)
.cc2e	ac2e	aa		tax				tax
.cc2f	ac2f	bd 53 ac	lda $ac53,x			lda 	_GXFXSSTTable,x 			; read sprite size
.cc32	ac32	8d 25 07	sta $0725			sta 	GXSizePixels 					; save (8/16/24/32)
.cc35	ac35	68		pla				pla 								; get LUT
.cc36	ac36	4a		lsr a				lsr		a
.cc37	ac37	4a		lsr a				lsr		a
.cc38	ac38	29 03		and #$03			and 	#3
.cc3a	ac3a	8d 27 07	sta $0727			sta 	GXSpriteLUT
.cc3d	ac3d	68		pla				pla 								; address, neeeds to be x 4
.cc3e	ac3e	29 f0		and #$f0			and 	#$F0
.cc40	ac40	8d 28 07	sta $0728			sta 	GXSpriteOffset
.cc43	ac43	0e 28 07	asl $0728			asl 	GXSpriteOffset
.cc46	ac46	2e 29 07	rol $0729			rol 	GXSpriteOffset+1
.cc49	ac49	0e 28 07	asl $0728			asl 	GXSpriteOffset
.cc4c	ac4c	2e 29 07	rol $0729			rol 	GXSpriteOffset+1
.cc4f	ac4f	18		clc				clc
.cc50	ac50	60		rts				rts
.cc51	ac51					_GXFSFail:
.cc51	ac51	38		sec				sec
.cc52	ac52	60		rts				rts
.cc53	ac53					_GXFXSSTTable:
>cc53	ac53	08 10 18 20					.byte 	8,16,24,32
.0725						GXSizePixels:
>0725								.fill 	1
.0726						GXSizeBits:
>0726								.fill 	1
.0727						GXSpriteLUT:
>0727								.fill 	1
.0728						GXSpriteOffset:
>0728								.fill 	2
.cc57	ac57					GXSortXY:
.cc57	ac57	20 75 ac	jsr $ac75			jsr 	GXSortY 					; will be sorted on Y now
.cc5a	ac5a	ad 7a 06	lda $067a			lda 	gxX0 						; compare X0 v X1
.cc5d	ac5d	cd 7e 06	cmp $067e			cmp 	gxX1
.cc60	ac60	ad 7b 06	lda $067b			lda 	gXX0+1
.cc63	ac63	ed 7f 06	sbc $067f			sbc 	gXX1+1
.cc66	ac66	90 0c		bcc $ac74			bcc 	_GXSXYExit 					; X0 < X1 exit
.cc68	ac68	a2 00		ldx #$00			ldx 	#0 							; swap them over
.cc6a	ac6a	a0 04		ldy #$04			ldy 	#4
.cc6c	ac6c	20 89 ac	jsr $ac89			jsr 	GXSwapXY
.cc6f	ac6f	e8		inx				inx
.cc70	ac70	c8		iny				iny
.cc71	ac71	20 89 ac	jsr $ac89			jsr 	GXSwapXY
.cc74	ac74					_GXSXYExit:
.cc74	ac74	60		rts				rts
.cc75	ac75					GXSortY:
.cc75	ac75	ad 7c 06	lda $067c			lda 	gxY0 						; if Y0 >= Y1
.cc78	ac78	cd 80 06	cmp $0680			cmp 	gxY1
.cc7b	ac7b	90 0b		bcc $ac88			bcc 	_GXSYSorted
.cc7d	ac7d	a2 03		ldx #$03			ldx 	#3 							; swap 3-0
.cc7f	ac7f	a0 07		ldy #$07			ldy 	#7 							; with 4-7
.cc81	ac81					_GXSwap1:
.cc81	ac81	20 89 ac	jsr $ac89			jsr 	GXSwapXY
.cc84	ac84	88		dey				dey
.cc85	ac85	ca		dex				dex
.cc86	ac86	10 f9		bpl $ac81			bpl 	_GXSwap1
.cc88	ac88					_GXSYSorted:
.cc88	ac88	60		rts				rts
.cc89	ac89					GXSwapXY:
.cc89	ac89	bd 7a 06	lda $067a,x			lda 	gxX0,x
.cc8c	ac8c	48		pha				pha
.cc8d	ac8d	b9 7a 06	lda $067a,y			lda 	gxX0,y
.cc90	ac90	9d 7a 06	sta $067a,x			sta 	gxX0,x
.cc93	ac93	68		pla				pla
.cc94	ac94	99 7a 06	sta $067a,y			sta 	gxX0,y
.cc97	ac97	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_tokeniser.module

=1						tokeniserIntegrated=1
.cc98	ac98					KeywordSet0:
>cc98	ac98	00 65					.text	0,$65,""               ; $80 !0:EOF
>cc9a	ac9a	00 58					.text	0,$58,""               ; $81 !1:SH1
>cc9c	ac9c	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>cc9e	ac9e	04 fe 41 42 53 28			.text	4,$fe,"ABS("           ; $83 ABS(
>cca4	aca4	06 93 41 4c 4c 4f 43 28			.text	6,$93,"ALLOC("         ; $84 ALLOC(
>ccac	acac	04 ff 41 53 43 28			.text	4,$ff,"ASC("           ; $85 ASC(
>ccb2	acb2	05 29 43 48 52 24 28			.text	5,$29,"CHR$("          ; $86 CHR$(
>ccb9	acb9	05 41 44 45 45 4b 28			.text	5,$41,"DEEK("          ; $87 DEEK(
>ccc0	acc0	06 aa 45 56 45 4e 54 28			.text	6,$aa,"EVENT("         ; $88 EVENT(
>ccc8	acc8	05 6b 46 41 4c 53 45			.text	5,$6b,"FALSE"          ; $89 FALSE
>cccf	accf	05 44 46 52 41 43 28			.text	5,$44,"FRAC("          ; $8a FRAC(
>ccd6	acd6	04 0d 48 49 54 28			.text	4,$0d,"HIT("           ; $8b HIT(
>ccdc	acdc	04 13 49 4e 54 28			.text	4,$13,"INT("           ; $8c INT(
>cce2	ace2	06 a7 49 53 56 41 4c 28			.text	6,$a7,"ISVAL("         ; $8d ISVAL(
>ccea	acea	05 5c 4a 4f 59 42 28			.text	5,$5c,"JOYB("          ; $8e JOYB(
>ccf1	acf1	05 72 4a 4f 59 58 28			.text	5,$72,"JOYX("          ; $8f JOYX(
>ccf8	acf8	05 73 4a 4f 59 59 28			.text	5,$73,"JOYY("          ; $90 JOYY(
>ccff	acff	06 77 4c 45 46 54 24 28			.text	6,$77,"LEFT$("         ; $91 LEFT$(
>cd07	ad07	04 07 4c 45 4e 28			.text	4,$07,"LEN("           ; $92 LEN(
>cd0d	ad0d	04 0e 4d 41 58 28			.text	4,$0e,"MAX("           ; $93 MAX(
>cd13	ad13	05 26 4d 49 44 24 28			.text	5,$26,"MID$("          ; $94 MID$(
>cd1a	ad1a	04 0c 4d 49 4e 28			.text	4,$0c,"MIN("           ; $95 MIN(
>cd20	ad20	04 19 4e 4f 54 28			.text	4,$19,"NOT("           ; $96 NOT(
>cd26	ad26	05 4d 50 45 45 4b 28			.text	5,$4d,"PEEK("          ; $97 PEEK(
>cd2d	ad2d	08 3c 50 4c 41 59 49 4e			.text	8,$3c,"PLAYING("       ; $98 PLAYING(
>cd35	ad35	47 28
>cd37	ad37	07 e9 52 41 4e 44 4f 4d			.text	7,$e9,"RANDOM("        ; $99 RANDOM(
>cd3f	ad3f	28
>cd40	ad40	07 ca 52 49 47 48 54 24			.text	7,$ca,"RIGHT$("        ; $9a RIGHT$(
>cd48	ad48	28
>cd49	ad49	04 0c 52 4e 44 28			.text	4,$0c,"RND("           ; $9b RND(
>cd4f	ad4f	04 10 53 47 4e 28			.text	4,$10,"SGN("           ; $9c SGN(
>cd55	ad55	04 0e 53 50 43 28			.text	4,$0e,"SPC("           ; $9d SPC(
>cd5b	ad5b	05 45 53 54 52 24 28			.text	5,$45,"STR$("          ; $9e STR$(
>cd62	ad62	06 a9 54 49 4d 45 52 28			.text	6,$a9,"TIMER("         ; $9f TIMER(
>cd6a	ad6a	04 40 54 52 55 45			.text	4,$40,"TRUE"           ; $a0 TRUE
>cd70	ad70	04 0b 56 41 4c 28			.text	4,$0b,"VAL("           ; $a1 VAL(
>cd76	ad76	03 e7 46 4f 52				.text	3,$e7,"FOR"            ; $a2 FOR
>cd7b	ad7b	02 8f 49 46				.text	2,$8f,"IF"             ; $a3 IF
>cd7f	ad7f	04 34 50 52 4f 43			.text	4,$34,"PROC"           ; $a4 PROC
>cd85	ad85	06 c1 52 45 50 45 41 54			.text	6,$c1,"REPEAT"         ; $a5 REPEAT
>cd8d	ad8d	05 79 57 48 49 4c 45			.text	5,$79,"WHILE"          ; $a6 WHILE
>cd94	ad94	05 66 45 4e 44 49 46			.text	5,$66,"ENDIF"          ; $a7 ENDIF
>cd9b	ad9b	07 0b 45 4e 44 50 52 4f			.text	7,$0b,"ENDPROC"        ; $a8 ENDPROC
>cda3	ada3	43
>cda4	ada4	04 3f 4e 45 58 54			.text	4,$3f,"NEXT"           ; $a9 NEXT
>cdaa	adaa	04 2f 54 48 45 4e			.text	4,$2f,"THEN"           ; $aa THEN
>cdb0	adb0	05 8c 55 4e 54 49 4c			.text	5,$8c,"UNTIL"          ; $ab UNTIL
>cdb7	adb7	04 2e 57 45 4e 44			.text	4,$2e,"WEND"           ; $ac WEND
>cdbd	adbd	02 9b 42 59				.text	2,$9b,"BY"             ; $ad BY
>cdc1	adc1	04 1c 43 41 4c 4c			.text	4,$1c,"CALL"           ; $ae CALL
>cdc7	adc7	06 b2 43 49 52 43 4c 45			.text	6,$b2,"CIRCLE"         ; $af CIRCLE
>cdcf	adcf	05 67 43 4c 45 41 52			.text	5,$67,"CLEAR"          ; $b0 CLEAR
>cdd6	add6	03 e2 43 4c 53				.text	3,$e2,"CLS"            ; $b1 CLS
>cddb	addb	05 7f 43 4f 4c 4f 52			.text	5,$7f,"COLOR"          ; $b2 COLOR
>cde2	ade2	06 d4 43 4f 4c 4f 55 52			.text	6,$d4,"COLOUR"         ; $b3 COLOUR
>cdea	adea	04 1a 44 41 54 41			.text	4,$1a,"DATA"           ; $b4 DATA
>cdf0	adf0	03 da 44 49 4d				.text	3,$da,"DIM"            ; $b5 DIM
>cdf5	adf5	04 23 44 4f 4b 45			.text	4,$23,"DOKE"           ; $b6 DOKE
>cdfb	adfb	06 db 44 4f 57 4e 54 4f			.text	6,$db,"DOWNTO"         ; $b7 DOWNTO
>ce03	ae03	04 29 45 4c 53 45			.text	4,$29,"ELSE"           ; $b8 ELSE
>ce09	ae09	04 34 46 52 4f 4d			.text	4,$34,"FROM"           ; $b9 FROM
>ce0f	ae0f	03 e5 47 46 58				.text	3,$e5,"GFX"            ; $ba GFX
>ce14	ae14	05 80 47 4f 53 55 42			.text	5,$80,"GOSUB"          ; $bb GOSUB
>ce1b	ae1b	04 39 47 4f 54 4f			.text	4,$39,"GOTO"           ; $bc GOTO
>ce21	ae21	04 24 48 45 52 45			.text	4,$24,"HERE"           ; $bd HERE
>ce27	ae27	05 63 49 4d 41 47 45			.text	5,$63,"IMAGE"          ; $be IMAGE
>ce2e	ae2e	05 90 49 4e 50 55 54			.text	5,$90,"INPUT"          ; $bf INPUT
>ce35	ae35	03 e5 4c 45 54				.text	3,$e5,"LET"            ; $c0 LET
>ce3a	ae3a	04 28 4c 49 4e 45			.text	4,$28,"LINE"           ; $c1 LINE
>ce40	ae40	05 6b 4c 4f 43 41 4c			.text	5,$6b,"LOCAL"          ; $c2 LOCAL
>ce47	ae47	03 db 4f 46 46				.text	3,$db,"OFF"            ; $c3 OFF
>ce4c	ae4c	02 9d 4f 4e				.text	2,$9d,"ON"             ; $c4 ON
>ce50	ae50	07 20 4f 55 54 4c 49 4e			.text	7,$20,"OUTLINE"        ; $c5 OUTLINE
>ce58	ae58	45
>ce59	ae59	07 0f 50 41 4c 45 54 54			.text	7,$0f,"PALETTE"        ; $c6 PALETTE
>ce61	ae61	45
>ce62	ae62	04 3f 50 4c 4f 54			.text	4,$3f,"PLOT"           ; $c7 PLOT
>ce68	ae68	04 2f 50 4f 4b 45			.text	4,$2f,"POKE"           ; $c8 POKE
>ce6e	ae6e	05 8d 50 52 49 4e 54			.text	5,$8d,"PRINT"          ; $c9 PRINT
>ce75	ae75	04 1c 52 45 41 44			.text	4,$1c,"READ"           ; $ca READ
>ce7b	ae7b	04 2e 52 45 43 54			.text	4,$2e,"RECT"           ; $cb RECT
>ce81	ae81	03 e4 52 45 4d				.text	3,$e4,"REM"            ; $cc REM
>ce86	ae86	06 e0 52 45 54 55 52 4e			.text	6,$e0,"RETURN"         ; $cd RETURN
>ce8e	ae8e	05 7b 53 4f 4c 49 44			.text	5,$7b,"SOLID"          ; $ce SOLID
>ce95	ae95	05 89 53 4f 55 4e 44			.text	5,$89,"SOUND"          ; $cf SOUND
>ce9c	ae9c	06 d7 53 50 52 49 54 45			.text	6,$d7,"SPRITE"         ; $d0 SPRITE
>cea4	aea4	04 45 54 45 58 54			.text	4,$45,"TEXT"           ; $d1 TEXT
>ceaa	aeaa	02 a3 54 4f				.text	2,$a3,"TO"             ; $d2 TO
>ceae	aeae	ff					.text	$FF
.ceaf	aeaf					KeywordSet1:
>ceaf	aeaf	00 65					.text	0,$65,""               ; $80 !0:EOF
>ceb1	aeb1	00 58					.text	0,$58,""               ; $81 !1:SH1
>ceb3	aeb3	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>ceb5	aeb5	08 4c 41 53 53 45 4d 42			.text	8,$4c,"ASSEMBLE"       ; $83 ASSEMBLE
>cebd	aebd	4c 45
>cebf	aebf	06 d2 41 53 53 45 52 54			.text	6,$d2,"ASSERT"         ; $84 ASSERT
>cec7	aec7	06 bd 42 49 54 4d 41 50			.text	6,$bd,"BITMAP"         ; $85 BITMAP
>cecf	aecf	03 d7 45 4e 44				.text	3,$d7,"END"            ; $86 END
>ced4	aed4	07 11 45 58 50 4c 4f 44			.text	7,$11,"EXPLODE"        ; $87 EXPLODE
>cedc	aedc	45
>cedd	aedd	02 96 47 4f				.text	2,$96,"GO"             ; $88 GO
>cee1	aee1	04 3c 4c 49 53 54			.text	4,$3c,"LIST"           ; $89 LIST
>cee7	aee7	04 20 4c 4f 41 44			.text	4,$20,"LOAD"           ; $8a LOAD
>ceed	aeed	03 ea 4e 45 57				.text	3,$ea,"NEW"            ; $8b NEW
>cef2	aef2	04 2e 50 49 4e 47			.text	4,$2e,"PING"           ; $8c PING
>cef8	aef8	07 24 52 45 53 54 4f 52			.text	7,$24,"RESTORE"        ; $8d RESTORE
>cf00	af00	45
>cf01	af01	03 f5 52 55 4e				.text	3,$f5,"RUN"            ; $8e RUN
>cf06	af06	05 8d 53 48 4f 4f 54			.text	5,$8d,"SHOOT"          ; $8f SHOOT
>cf0d	af0d	07 2a 53 50 52 49 54 45			.text	7,$2a,"SPRITES"        ; $90 SPRITES
>cf15	af15	53
>cf16	af16	04 46 53 54 4f 50			.text	4,$46,"STOP"           ; $91 STOP
>cf1c	af1c	03 eb 5a 41 50				.text	3,$eb,"ZAP"            ; $92 ZAP
>cf21	af21	ff					.text	$FF
.cf22	af22					KeywordSet2:
>cf22	af22	00 65					.text	0,$65,""               ; $80 !0:EOF
>cf24	af24	00 58					.text	0,$58,""               ; $81 !1:SH1
>cf26	af26	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>cf28	af28	03 c8 41 44 43				.text	3,$c8,"ADC"            ; $83 ADC
>cf2d	af2d	03 d3 41 4e 44				.text	3,$d3,"AND"            ; $84 AND
>cf32	af32	03 e0 41 53 4c				.text	3,$e0,"ASL"            ; $85 ASL
>cf37	af37	03 c8 42 43 43				.text	3,$c8,"BCC"            ; $86 BCC
>cf3c	af3c	03 d8 42 43 53				.text	3,$d8,"BCS"            ; $87 BCS
>cf41	af41	03 d8 42 45 51				.text	3,$d8,"BEQ"            ; $88 BEQ
>cf46	af46	03 df 42 49 54				.text	3,$df,"BIT"            ; $89 BIT
>cf4b	af4b	03 d8 42 4d 49				.text	3,$d8,"BMI"            ; $8a BMI
>cf50	af50	03 d5 42 4e 45				.text	3,$d5,"BNE"            ; $8b BNE
>cf55	af55	03 de 42 50 4c				.text	3,$de,"BPL"            ; $8c BPL
>cf5a	af5a	03 d5 42 52 41				.text	3,$d5,"BRA"            ; $8d BRA
>cf5f	af5f	03 df 42 52 4b				.text	3,$df,"BRK"            ; $8e BRK
>cf64	af64	03 db 42 56 43				.text	3,$db,"BVC"            ; $8f BVC
>cf69	af69	03 eb 42 56 53				.text	3,$eb,"BVS"            ; $90 BVS
>cf6e	af6e	03 d2 43 4c 43				.text	3,$d2,"CLC"            ; $91 CLC
>cf73	af73	03 d3 43 4c 44				.text	3,$d3,"CLD"            ; $92 CLD
>cf78	af78	03 d8 43 4c 49				.text	3,$d8,"CLI"            ; $93 CLI
>cf7d	af7d	03 e5 43 4c 56				.text	3,$e5,"CLV"            ; $94 CLV
>cf82	af82	03 e0 43 4d 50				.text	3,$e0,"CMP"            ; $95 CMP
>cf87	af87	03 eb 43 50 58				.text	3,$eb,"CPX"            ; $96 CPX
>cf8c	af8c	03 ec 43 50 59				.text	3,$ec,"CPY"            ; $97 CPY
>cf91	af91	03 cc 44 45 43				.text	3,$cc,"DEC"            ; $98 DEC
>cf96	af96	03 e1 44 45 58				.text	3,$e1,"DEX"            ; $99 DEX
>cf9b	af9b	03 e2 44 45 59				.text	3,$e2,"DEY"            ; $9a DEY
>cfa0	afa0	03 e6 45 4f 52				.text	3,$e6,"EOR"            ; $9b EOR
>cfa5	afa5	03 da 49 4e 43				.text	3,$da,"INC"            ; $9c INC
>cfaa	afaa	03 ef 49 4e 58				.text	3,$ef,"INX"            ; $9d INX
>cfaf	afaf	03 f0 49 4e 59				.text	3,$f0,"INY"            ; $9e INY
>cfb4	afb4	03 e7 4a 4d 50				.text	3,$e7,"JMP"            ; $9f JMP
>cfb9	afb9	03 ef 4a 53 52				.text	3,$ef,"JSR"            ; $a0 JSR
>cfbe	afbe	03 d1 4c 44 41				.text	3,$d1,"LDA"            ; $a1 LDA
>cfc3	afc3	03 e8 4c 44 58				.text	3,$e8,"LDX"            ; $a2 LDX
>cfc8	afc8	03 e9 4c 44 59				.text	3,$e9,"LDY"            ; $a3 LDY
>cfcd	afcd	03 f1 4c 53 52				.text	3,$f1,"LSR"            ; $a4 LSR
>cfd2	afd2	03 ed 4e 4f 50				.text	3,$ed,"NOP"            ; $a5 NOP
>cfd7	afd7	03 e2 4f 52 41				.text	3,$e2,"ORA"            ; $a6 ORA
>cfdc	afdc	03 d9 50 48 41				.text	3,$d9,"PHA"            ; $a7 PHA
>cfe1	afe1	03 e8 50 48 50				.text	3,$e8,"PHP"            ; $a8 PHP
>cfe6	afe6	03 f0 50 48 58				.text	3,$f0,"PHX"            ; $a9 PHX
>cfeb	afeb	03 f1 50 48 59				.text	3,$f1,"PHY"            ; $aa PHY
>cff0	aff0	03 dd 50 4c 41				.text	3,$dd,"PLA"            ; $ab PLA
>cff5	aff5	03 ec 50 4c 50				.text	3,$ec,"PLP"            ; $ac PLP
>cffa	affa	03 f4 50 4c 58				.text	3,$f4,"PLX"            ; $ad PLX
>cfff	afff	03 f5 50 4c 59				.text	3,$f5,"PLY"            ; $ae PLY
>d004	b004	03 ed 52 4f 4c				.text	3,$ed,"ROL"            ; $af ROL
>d009	b009	03 f3 52 4f 52				.text	3,$f3,"ROR"            ; $b0 ROR
>d00e	b00e	03 ef 52 54 49				.text	3,$ef,"RTI"            ; $b1 RTI
>d013	b013	03 f9 52 54 53				.text	3,$f9,"RTS"            ; $b2 RTS
>d018	b018	03 d8 53 42 43				.text	3,$d8,"SBC"            ; $b3 SBC
>d01d	b01d	03 db 53 45 43				.text	3,$db,"SEC"            ; $b4 SEC
>d022	b022	03 dc 53 45 44				.text	3,$dc,"SED"            ; $b5 SED
>d027	b027	03 e1 53 45 49				.text	3,$e1,"SEI"            ; $b6 SEI
>d02c	b02c	03 e8 53 54 41				.text	3,$e8,"STA"            ; $b7 STA
>d031	b031	03 f7 53 54 50				.text	3,$f7,"STP"            ; $b8 STP
>d036	b036	03 ff 53 54 58				.text	3,$ff,"STX"            ; $b9 STX
>d03b	b03b	03 00 53 54 59				.text	3,$00,"STY"            ; $ba STY
>d040	b040	03 01 53 54 5a				.text	3,$01,"STZ"            ; $bb STZ
>d045	b045	03 ed 54 41 58				.text	3,$ed,"TAX"            ; $bc TAX
>d04a	b04a	03 ee 54 41 59				.text	3,$ee,"TAY"            ; $bd TAY
>d04f	b04f	03 e8 54 52 42				.text	3,$e8,"TRB"            ; $be TRB
>d054	b054	03 e9 54 53 42				.text	3,$e9,"TSB"            ; $bf TSB
>d059	b059	03 ff 54 53 58				.text	3,$ff,"TSX"            ; $c0 TSX
>d05e	b05e	03 ed 54 58 41				.text	3,$ed,"TXA"            ; $c1 TXA
>d063	b063	03 ff 54 58 53				.text	3,$ff,"TXS"            ; $c2 TXS
>d068	b068	03 ee 54 59 41				.text	3,$ee,"TYA"            ; $c3 TYA
>d06d	b06d	ff					.text	$FF
.d06e	b06e					Export_TKListConvertLine:
.d06e	b06e	48		pha				pha 								; save indent on the stack
.d06f	b06f	9c 1d 04	stz $041d			stz 	tbOffset
.d072	b072	9c 2d 04	stz $042d			stz 	tokenBuffer
.d075	b075	9c 29 04	stz $0429			stz 	currentListColour
.d078	b078	a9 89		lda #$89			lda 	#CLILineNumber+$80
.d07a	b07a	20 f7 b1	jsr $b1f7			jsr 	LCLWriteColour
.d07d	b07d	a0 02		ldy #$02			ldy 	#2 							; convert line number to string
.d07f	b07f	b1 30		lda ($30),y			lda 	(codePtr),y
.d081	b081	aa		tax				tax
.d082	b082	88		dey				dey
.d083	b083	b1 30		lda ($30),y			lda 	(codePtr),y
.d085	b085	20 68 b2	jsr $b268			jsr 	LCLWriteNumberXA
.d088	b088	68		pla				pla 								; adjustment to indent
.d089	b089	48		pha				pha 								; save on stack
.d08a	b08a	10 0c		bpl $b098			bpl 	_LCNoAdjust 				; don't adjust indent if +ve, do after.
.d08c	b08c	18		clc				clc 								; add to list indent and make 0 if goes -ve.
.d08d	b08d	6d 26 04	adc $0426			adc 	listIndent
.d090	b090	8d 26 04	sta $0426			sta 	listIndent
.d093	b093	10 03		bpl $b098			bpl 	_LCNoAdjust
.d095	b095	9c 26 04	stz $0426			stz 	listIndent
.d098	b098					_LCNoAdjust:
.d098	b098	18		clc				clc		 							; work out actual indent.
.d099	b099	ad 26 04	lda $0426			lda 	listIndent
.d09c	b09c	0a		asl a				asl 	a
.d09d	b09d	69 07		adc #$07			adc 	#7
.d09f	b09f	85 36		sta $36				sta 	zTemp0
.d0a1	b0a1					_LCPadOut:
.d0a1	b0a1	a9 20		lda #$20			lda 	#' '						; pad out to 6+indent characters
.d0a3	b0a3	20 00 b2	jsr $b200			jsr 	LCLWrite
.d0a6	b0a6	ad 1d 04	lda $041d			lda 	tbOffset
.d0a9	b0a9	c5 36		cmp $36				cmp 	zTemp0
.d0ab	b0ab	d0 f4		bne $b0a1			bne 	_LCPadOut
.d0ad	b0ad	a0 03		ldy #$03			ldy 	#3 							; start position.
.d0af	b0af					_LCMainLoop:
.d0af	b0af	a9 8a		lda #$8a			lda 	#CLIPunctuation+$80
.d0b1	b0b1	20 f7 b1	jsr $b1f7			jsr 	LCLWriteColour
.d0b4	b0b4	b1 30		lda ($30),y			lda 	(codePtr),y
.d0b6	b0b6	c9 80		cmp #$80			cmp 	#KWC_EOL 					; end of line ?
.d0b8	b0b8	f0 17		beq $b0d1			beq 	_LCExit
.d0ba	b0ba	c9 10		cmp #$10			cmp 	#16 						; 0-5 are the double punctuations
.d0bc	b0bc	90 1e		bcc $b0dc			bcc 	_LCDoubles
.d0be	b0be	c9 20		cmp #$20			cmp 	#32 						; 16-31 are shifted punctuation from 64-91
.d0c0	b0c0	90 2a		bcc $b0ec			bcc 	_LCShiftPunc
.d0c2	b0c2	c9 40		cmp #$40			cmp 	#64 						; 32-64 are as stored, punc and digits
.d0c4	b0c4	90 35		bcc $b0fb			bcc 	_LCPunctuation
.d0c6	b0c6	c9 80		cmp #$80			cmp 	#128 						; 64-127 are variable identifiers.
.d0c8	b0c8	90 51		bcc $b11b			bcc 	_LCIdentifiers
.d0ca	b0ca	c9 fe		cmp #$fe			cmp 	#254 						; 128-253 are tokenised words
.d0cc	b0cc	90 73		bcc $b141			bcc 	_LCTokens
.d0ce	b0ce	4c a1 b1	jmp $b1a1			jmp 	_LCData 					; 254-5 are data objects
.d0d1	b0d1					_LCExit:
.d0d1	b0d1	68		pla				pla 								; get old indent adjust
.d0d2	b0d2	30 07		bmi $b0db			bmi 	_LCExit2
.d0d4	b0d4	18		clc				clc 								; add to indent if +ve
.d0d5	b0d5	6d 26 04	adc $0426			adc 	listIndent
.d0d8	b0d8	8d 26 04	sta $0426			sta 	listIndent
.d0db	b0db					_LCExit2:
.d0db	b0db	60		rts				rts
.d0dc	b0dc					_LCDoubles:
.d0dc	b0dc	48		pha				pha
.d0dd	b0dd	4a		lsr a				lsr 	a 							; put bit 2 into bit 1
.d0de	b0de	29 02		and #$02			and 	#2
.d0e0	b0e0	09 3c		ora #$3c			ora 	#60 						; make < >
.d0e2	b0e2	20 00 b2	jsr $b200			jsr 	LCLWrite
.d0e5	b0e5	68		pla				pla 								; restore, do lower bit
.d0e6	b0e6	29 03		and #$03			and 	#3
.d0e8	b0e8	09 3c		ora #$3c			ora 	#60
.d0ea	b0ea	80 0f		bra $b0fb			bra		_LCPunctuation 				; print, increment, loop
.d0ec	b0ec					_LCShiftPunc:
.d0ec	b0ec	aa		tax				tax 								; save in X
.d0ed	b0ed	29 07		and #$07			and 	#7 							; lower 3 bits
.d0ef	b0ef	f0 02		beq $b0f3			beq 	_LCNoAdd
.d0f1	b0f1	09 18		ora #$18			ora 	#24 						; adds $18 to it.
.d0f3	b0f3					_LCNoAdd:
.d0f3	b0f3	e0 18		cpx #$18			cpx 	#24 						; if >= 24 add $20
.d0f5	b0f5	90 02		bcc $b0f9			bcc 	_LCNoAdd2
.d0f7	b0f7	09 20		ora #$20			ora 	#32 						; adds $20
.d0f9	b0f9					_LCNoAdd2:
.d0f9	b0f9	09 40		ora #$40			ora 	#$40 						; shift into 64-127 range and fall through.
.d0fb	b0fb					_LCPunctuation:
.d0fb	b0fb	c9 3a		cmp #$3a			cmp 	#':' 						; check if :
.d0fd	b0fd	d0 03		bne $b102			bne 	_LCPContinue
.d0ff	b0ff	20 16 b2	jsr $b216			jsr 	LCLDeleteLastSpace 			; if so delete any preceding spaces
.d102	b102					_LCPContinue:
.d102	b102	c9 2e		cmp #$2e			cmp 	#'.'
.d104	b104	f0 08		beq $b10e			beq 	_LCPIsConstant
.d106	b106	c9 30		cmp #$30			cmp 	#'0'
.d108	b108	90 0b		bcc $b115			bcc 	_LCPNotConstant
.d10a	b10a	c9 3a		cmp #$3a			cmp 	#'9'+1
.d10c	b10c	b0 07		bcs $b115			bcs 	_LCPNotConstant
.d10e	b10e					_LCPIsConstant:
.d10e	b10e	48		pha				pha
.d10f	b10f	a9 8d		lda #$8d			lda 	#CLIConstant+$80
.d111	b111	20 f7 b1	jsr $b1f7			jsr 	LCLWriteColour
.d114	b114	68		pla				pla
.d115	b115					_LCPNotConstant:
.d115	b115	c8		iny				iny 								; consume character
.d116	b116	20 00 b2	jsr $b200			jsr 	LCLWrite 					; write it out.
.d119	b119	80 94		bra $b0af			bra 	_LCMainLoop 				; go round again.
.d11b	b11b					_LCIdentifiers:
.d11b	b11b	18		clc				clc 								; convert to physical address
.d11c	b11c	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.d11e	b11e	85 37		sta $37				sta 	zTemp0+1
.d120	b120	c8		iny				iny
.d121	b121	b1 30		lda ($30),y			lda 	(codePtr),y
.d123	b123	85 36		sta $36				sta 	zTemp0
.d125	b125	c8		iny				iny
.d126	b126	5a		phy				phy 								; save position
.d127	b127	a9 87		lda #$87			lda 	#CLIIdentifier+$80
.d129	b129	20 f7 b1	jsr $b1f7			jsr 	LCLWriteColour
.d12c	b12c	a0 07		ldy #$07			ldy 	#7 							; output the identifier at +8
.d12e	b12e					_LCOutIdentifier:
.d12e	b12e	c8		iny				iny
.d12f	b12f	b1 36		lda ($36),y			lda 	(zTemp0),y					; bit 7 set = end.
.d131	b131	29 7f		and #$7f			and 	#$7F
.d133	b133	20 52 b2	jsr $b252			jsr 	LCLLowerCase
.d136	b136	20 00 b2	jsr $b200			jsr 	LCLWrite
.d139	b139	b1 36		lda ($36),y			lda 	(zTemp0),y				 	; ends when bit 7 set.
.d13b	b13b	10 f1		bpl $b12e			bpl 	_LCOutIdentifier
.d13d	b13d	7a		ply				ply 								; restore position
.d13e	b13e	4c af b0	jmp $b0af			jmp 	_LCMainLoop
.d141	b141					_LCTokens:
.d141	b141	aa		tax				tax 								; token in X
.d142	b142	a9 22		lda #$22			lda 	#((KeywordSet2) & $FF)
.d144	b144	85 36		sta $36				sta 	0+zTemp0
.d146	b146	a9 af		lda #$af			lda 	#((KeywordSet2) >> 8)
.d148	b148	85 37		sta $37				sta 	1+zTemp0
.d14a	b14a	e0 82		cpx #$82			cpx 	#$82
.d14c	b14c	f0 16		beq $b164			beq 	_LCUseShift
.d14e	b14e	a9 af		lda #$af			lda 	#((KeywordSet1) & $FF)
.d150	b150	85 36		sta $36				sta 	0+zTemp0
.d152	b152	a9 ae		lda #$ae			lda 	#((KeywordSet1) >> 8)
.d154	b154	85 37		sta $37				sta 	1+zTemp0
.d156	b156	e0 81		cpx #$81			cpx 	#$81
.d158	b158	f0 0a		beq $b164			beq 	_LCUseShift
.d15a	b15a	a9 98		lda #$98			lda 	#((KeywordSet0) & $FF)
.d15c	b15c	85 36		sta $36				sta 	0+zTemp0
.d15e	b15e	a9 ac		lda #$ac			lda 	#((KeywordSet0) >> 8)
.d160	b160	85 37		sta $37				sta 	1+zTemp0
.d162	b162	80 01		bra $b165			bra 	_LCNoShift
.d164	b164					_LCUseShift:
.d164	b164	c8		iny				iny
.d165	b165					_LCNoShift:
.d165	b165	20 2a b2	jsr $b22a			jsr 	LCLCheckSpaceRequired 		; do we need a space ?
.d168	b168	b1 30		lda ($30),y			lda 	(codePtr),y
.d16a	b16a	aa		tax				tax 								; into X
.d16b	b16b					_LCFindText:
.d16b	b16b	ca		dex				dex
.d16c	b16c	10 0e		bpl $b17c			bpl 	_LCFoundText 				; found text.
.d16e	b16e	b2 36		lda ($36)			lda 	(zTemp0) 					; length of text
.d170	b170	1a		inc a				inc 	a 							; one extra for size
.d171	b171	38		sec				sec 								; one extra for checksum
.d172	b172	65 36		adc $36				adc 	zTemp0 						; go to next token
.d174	b174	85 36		sta $36				sta 	zTemp0
.d176	b176	90 f3		bcc $b16b			bcc 	_LCFindText
.d178	b178	e6 37		inc $37				inc 	zTemp0+1
.d17a	b17a	80 ef		bra $b16b			bra 	_LCFindText
.d17c	b17c					_LCFoundText:
.d17c	b17c	5a		phy				phy 								; save List position
.d17d	b17d	b2 36		lda ($36)			lda 	(zTemp0)					; count to print
.d17f	b17f	aa		tax				tax
.d180	b180	a9 83		lda #$83			lda 	#CLIToken+$80
.d182	b182	20 f7 b1	jsr $b1f7			jsr 	LCLWriteColour
.d185	b185	a0 02		ldy #$02			ldy 	#2
.d187	b187					_LCCopyToken:
.d187	b187	b1 36		lda ($36),y			lda 	(zTemp0),y
.d189	b189	20 52 b2	jsr $b252			jsr 	LCLLowerCase
.d18c	b18c	20 00 b2	jsr $b200			jsr 	LCLWrite
.d18f	b18f	c8		iny				iny
.d190	b190	ca		dex				dex
.d191	b191	d0 f4		bne $b187			bne 	_LCCopyToken
.d193	b193	c9 28		cmp #$28			cmp 	#"(" 						; if last char not ( print a space
.d195	b195	f0 05		beq $b19c			beq 	_LCNoSpace
.d197	b197	a9 20		lda #$20			lda 	#' '
.d199	b199	20 00 b2	jsr $b200			jsr 	LCLWrite
.d19c	b19c					_LCNoSpace:
.d19c	b19c	7a		ply				ply 								; restore position.
.d19d	b19d	c8		iny				iny 								; consume token
.d19e	b19e	4c af b0	jmp $b0af			jmp 	_LCMainLoop 				; and go around again.
.d1a1	b1a1					_LCData:
.d1a1	b1a1	48		pha				pha 								; save type $FE/$FF
.d1a2	b1a2	a2 24		ldx #$24			ldx 	#'$' 						; figure out $ or "
.d1a4	b1a4	c9 fe		cmp #$fe			cmp 	#$FE
.d1a6	b1a6	f0 22		beq $b1ca			beq 	_LCHaveOpener
.d1a8	b1a8	a2 22		ldx #$22			ldx 	#'"'
.d1aa	b1aa	a9 81		lda #$81			lda 	#CLIData+$80
.d1ac	b1ac	20 f7 b1	jsr $b1f7			jsr 	LCLWriteColour
.d1af	b1af	c0 04		cpy #$04			cpy 	#4 							; must be 2nd thing on line
.d1b1	b1b1	d0 17		bne $b1ca			bne 	_LCHaveOpener
.d1b3	b1b3	88		dey				dey 								; what precedes it ?
.d1b4	b1b4	b1 30		lda ($30),y			lda 	(codePtr),y
.d1b6	b1b6	c8		iny				iny
.d1b7	b1b7	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; if quote
.d1b9	b1b9	d0 0f		bne $b1ca			bne 	_LCHaveOpener
.d1bb	b1bb	a9 09		lda #$09			lda 	#9 							; tab
.d1bd	b1bd	20 00 b2	jsr $b200			jsr 	LCLWrite
.d1c0	b1c0	a9 97		lda #$97			lda 	#$90+CLIBComment
.d1c2	b1c2	20 00 b2	jsr $b200			jsr 	LCLWrite
.d1c5	b1c5	a9 80		lda #$80			lda 	#CLIFComment+$80
.d1c7	b1c7	20 f7 b1	jsr $b1f7			jsr 	LCLWriteColour
.d1ca	b1ca					_LCHaveOpener:
.d1ca	b1ca	8a		txa				txa 								; output prefix (# or ")
.d1cb	b1cb	20 00 b2	jsr $b200			jsr 	LCLWrite
.d1ce	b1ce	c8		iny				iny 								; get count
.d1cf	b1cf	b1 30		lda ($30),y			lda 	(codePtr),y
.d1d1	b1d1	aa		tax				tax
.d1d2	b1d2	c8		iny				iny 								; point at first character
.d1d3	b1d3					_LCOutData:
.d1d3	b1d3	b1 30		lda ($30),y			lda 	(codePtr),y
.d1d5	b1d5	c9 00		cmp #$00			cmp 	#0
.d1d7	b1d7	f0 03		beq $b1dc			beq 	_LCNoPrint
.d1d9	b1d9	20 00 b2	jsr $b200			jsr 	LCLWrite
.d1dc	b1dc					_LCNoPrint:
.d1dc	b1dc	c8		iny				iny
.d1dd	b1dd	ca		dex				dex
.d1de	b1de	d0 f3		bne $b1d3			bne 	_LCOutData
.d1e0	b1e0	68		pla				pla 								; closing " required ?
.d1e1	b1e1	c9 ff		cmp #$ff			cmp 	#$FF 						; not required for hex constant.
.d1e3	b1e3	d0 0f		bne $b1f4			bne 	_LCNoQuote
.d1e5	b1e5	a9 22		lda #$22			lda 	#'"'
.d1e7	b1e7	20 00 b2	jsr $b200			jsr 	LCLWrite
.d1ea	b1ea	ad 6f 06	lda $066f			lda 	EXTTextColour
.d1ed	b1ed	29 0f		and #$0f			and 	#$0F
.d1ef	b1ef	09 90		ora #$90			ora 	#$90
.d1f1	b1f1	20 00 b2	jsr $b200			jsr 	LCLWrite
.d1f4	b1f4					_LCNoQuote:
.d1f4	b1f4	4c af b0	jmp $b0af			jmp 	_LCMainLoop
.d1f7	b1f7					LCLWriteColour:
.d1f7	b1f7	cd 29 04	cmp $0429			cmp 	currentListColour 			; has the colour changed
.d1fa	b1fa	8d 29 04	sta $0429			sta 	currentListColour 			; (update it anyway)
.d1fd	b1fd	d0 01		bne $b200			bne 	LCLWrite 					; if different, output it
.d1ff	b1ff	60		rts				rts
.d200	b200					LCLWrite:
.d200	b200	da		phx				phx
.d201	b201	ae 1d 04	ldx $041d			ldx 	tbOffset 					; write out make ASCIIZ
.d204	b204	9d 2d 04	sta $042d,x			sta 	tokenBuffer,x
.d207	b207	9e 2e 04	stz $042e,x			stz 	tokenBuffer+1,x
.d20a	b20a	ee 1d 04	inc $041d			inc 	tbOffset 					; bump the position
.d20d	b20d	09 00		ora #$00			ora 	#0 							; don't update last character if colour data
.d20f	b20f	30 03		bmi $b214			bmi 	_LCLNoColour
.d211	b211	8d 27 04	sta $0427			sta 	LCLastCharacter
.d214	b214					_LCLNoColour:
.d214	b214	fa		plx				plx
.d215	b215	60		rts				rts
.d216	b216					LCLDeleteLastSpace:
.d216	b216	48		pha				pha
.d217	b217	da		phx				phx
.d218	b218	ae 1d 04	ldx $041d			ldx 	tbOffset
.d21b	b21b	f0 0a		beq $b227			beq 	_LCDLSExit
.d21d	b21d	bd 2c 04	lda $042c,x			lda 	tokenBuffer-1,x
.d220	b220	c9 20		cmp #$20			cmp 	#' '
.d222	b222	d0 03		bne $b227			bne 	_LCDLSExit
.d224	b224	ce 1d 04	dec $041d			dec 	tbOffset
.d227	b227					_LCDLSExit:
.d227	b227	fa		plx				plx
.d228	b228	68		pla				pla
.d229	b229	60		rts				rts
.d22a	b22a					LCLCheckSpaceRequired:
.d22a	b22a	ad 27 04	lda $0427			lda 	LCLastCharacter 			; check last character
.d22d	b22d	c9 24		cmp #$24			cmp 	#'$' 						; $ # and ) require that token space.
.d22f	b22f	f0 1b		beq $b24c			beq 	_LCCSRSpace
.d231	b231	c9 29		cmp #$29			cmp 	#')'
.d233	b233	f0 17		beq $b24c			beq 	_LCCSRSpace
.d235	b235	c9 23		cmp #$23			cmp 	#'#'
.d237	b237	f0 13		beq $b24c			beq 	_LCCSRSpace
.d239	b239	20 52 b2	jsr $b252			jsr 	LCLLowerCase 				; saves a little effort
.d23c	b23c	c9 30		cmp #$30			cmp 	#"0" 						; check if it was 0-9 A-Z a-z if so need space.
.d23e	b23e	90 11		bcc $b251			bcc 	_LCCSRExit
.d240	b240	c9 3a		cmp #$3a			cmp 	#"9"+1
.d242	b242	90 08		bcc $b24c			bcc 	_LCCSRSpace
.d244	b244	c9 61		cmp #$61			cmp 	#"a"
.d246	b246	90 09		bcc $b251			bcc 	_LCCSRExit
.d248	b248	c9 7b		cmp #$7b			cmp 	#"z"+1
.d24a	b24a	b0 05		bcs $b251			bcs 	_LCCSRExit
.d24c	b24c					_LCCSRSpace:
.d24c	b24c	a9 20		lda #$20			lda 	#' '
.d24e	b24e	20 00 b2	jsr $b200			jsr 	LCLWrite
.d251	b251					_LCCSRExit:
.d251	b251	60		rts				rts
.d252	b252					LCLLowerCase:
.d252	b252	c9 41		cmp #$41			cmp 	#"A"
.d254	b254	90 06		bcc $b25c			bcc 	_LCLLCOut
.d256	b256	c9 5b		cmp #$5b			cmp 	#"Z"+1
.d258	b258	b0 02		bcs $b25c			bcs 	_LCLLCOut
.d25a	b25a	69 20		adc #$20			adc 	#$20
.d25c	b25c					_LCLLCOut:
.d25c	b25c	60		rts				rts
.d25d	b25d					LCLUpperCase:
.d25d	b25d	c9 61		cmp #$61			cmp 	#"a"
.d25f	b25f	90 06		bcc $b267			bcc 	_LCLUCOut
.d261	b261	c9 7b		cmp #$7b			cmp 	#"z"+1
.d263	b263	b0 02		bcs $b267			bcs 	_LCLUCOut
.d265	b265	e9 1f		sbc #$1f			sbc 	#$1F
.d267	b267					_LCLUCOut:
.d267	b267	60		rts				rts
.d268	b268					LCLWriteNumberXA:
.d268	b268	64 37		stz $37				stz 	zTemp0+1 					; index into digit table.
.d26a	b26a					_LCLWNLoop1:
.d26a	b26a	64 36		stz $36				stz 	zTemp0 						; subtraction count.
.d26c	b26c					_LCLWNLoop2:
.d26c	b26c	48		pha				pha 								; save initial LSB
.d26d	b26d	38		sec				sec
.d26e	b26e	a4 37		ldy $37				ldy 	zTemp0+1 					; position in table.
.d270	b270	f9 a1 b2	sbc $b2a1,y			sbc 	_LCLWNTable,y
.d273	b273	48		pha				pha
.d274	b274	8a		txa				txa
.d275	b275	f9 a2 b2	sbc $b2a2,y			sbc 	_LCLWNTable+1,y
.d278	b278	90 07		bcc $b281			bcc 	_LCLWNUnderflow
.d27a	b27a	e6 36		inc $36				inc 	zTemp0  					; subtracted one without borrow.
.d27c	b27c	aa		tax				tax 								; update X
.d27d	b27d	68		pla				pla 								; restore A
.d27e	b27e	7a		ply				ply 								; throw original
.d27f	b27f	80 eb		bra $b26c			bra 	_LCLWNLoop2 				; try again.
.d281	b281					_LCLWNUnderflow:
.d281	b281	a4 36		ldy $36				ldy 	zTemp0 						; count of subtractions.
.d283	b283	d0 06		bne $b28b			bne 	_LCLWNOut
.d285	b285	ad 1d 04	lda $041d			lda 	tbOffset 					; suppress leading zeroes
.d288	b288	3a		dec a				dec 	a
.d289	b289	f0 04		beq $b28f			beq 	_LCLWNNext
.d28b	b28b					_LCLWNOut:
.d28b	b28b	98		tya				tya
.d28c	b28c	20 9b b2	jsr $b29b			jsr 	_LCLWNOutDigit
.d28f	b28f					_LCLWNNext:
.d28f	b28f	7a		ply				ply 							 	; restore original value.
.d290	b290	68		pla				pla
.d291	b291	a4 37		ldy $37				ldy 	zTemp0+1  					; bump the index
.d293	b293	c8		iny				iny
.d294	b294	c8		iny				iny
.d295	b295	84 37		sty $37				sty 	zTemp0+1
.d297	b297	c0 08		cpy #$08			cpy 	#8 							; done all 4
.d299	b299	d0 cf		bne $b26a			bne 	_LCLWNLoop1
.d29b	b29b					_LCLWNOutDigit:
.d29b	b29b	09 30		ora #$30			ora 	#'0'
.d29d	b29d	20 00 b2	jsr $b200			jsr 	LCLWrite
.d2a0	b2a0	60		rts				rts
.d2a1	b2a1					_LCLWNTable:
>d2a1	b2a1	10 27						.word 	10000
>d2a3	b2a3	e8 03						.word 	1000
>d2a5	b2a5	64 00						.word 	100
>d2a7	b2a7	0a 00						.word 	10
.d2a9	b2a9					TOKSearchTable:
.d2a9	b2a9	84 37		sty $37				sty 	zTemp0+1 					; (zTemp0),y points to current token being tested.
.d2ab	b2ab	85 36		sta $36				sta 	zTemp0
.d2ad	b2ad	a0 00		ldy #$00			ldy 	#0
.d2af	b2af	a9 80		lda #$80			lda 	#$80 						; token # so we know which one we are looking at
.d2b1	b2b1	85 38		sta $38				sta 	zTemp1
.d2b3	b2b3					_TSTLoop:
.d2b3	b2b3	b1 36		lda ($36),y			lda 	(zTemp0),y 					; length, 0 (skip) -ve (end)
.d2b5	b2b5	30 49		bmi $b300			bmi 	_TSTFail 					; -ve = end of table, so fail.
.d2b7	b2b7	f0 2e		beq $b2e7			beq 	_TSTNext 					; zero, check next as it's a dummy (e.g. EOL, SHIFT)
.d2b9	b2b9	c8		iny				iny 								; get the hash
.d2ba	b2ba	b1 36		lda ($36),y			lda 	(zTemp0),y
.d2bc	b2bc	88		dey				dey
.d2bd	b2bd	cd 03 04	cmp $0403			cmp 	identHash 					; check they match with the identifier hash, if not go to next
.d2c0	b2c0	d0 25		bne $b2e7			bne 	_TSTNext
.d2c2	b2c2	ad 02 04	lda $0402			lda 	identTypeEnd 				; get length of identifier from end-start
.d2c5	b2c5	38		sec				sec
.d2c6	b2c6	ed 00 04	sbc $0400			sbc 	identStart
.d2c9	b2c9	d1 36		cmp ($36),y			cmp 	(zTemp0),y 					; compare against the length in the table, no match, then return.
.d2cb	b2cb	d0 1a		bne $b2e7			bne 	_TSTNext
.d2cd	b2cd	5a		phy				phy 								; save Y , we might fail to match.
.d2ce	b2ce	c8		iny				iny 								; point to text
.d2cf	b2cf	c8		iny				iny
.d2d0	b2d0	ae 00 04	ldx $0400			ldx 	identStart 					; offset in line buffer in X
.d2d3	b2d3					_TSTCompareName:
.d2d3	b2d3	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; compare text.
.d2d6	b2d6	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.d2d8	b2d8	d0 0c		bne $b2e6			bne 	_TSTNextPullY 				; fail, pullY and do next
.d2da	b2da	e8		inx				inx
.d2db	b2db	c8		iny				iny
.d2dc	b2dc	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; complete match.
.d2df	b2df	d0 f2		bne $b2d3			bne 	_TSTCompareName
.d2e1	b2e1	7a		ply				ply 								; throw Y
.d2e2	b2e2	a5 38		lda $38				lda 	zTemp1 						; get token #
.d2e4	b2e4	38		sec				sec 								; return with CS = passed.
.d2e5	b2e5	60		rts				rts
.d2e6	b2e6					_TSTNextPullY:
.d2e6	b2e6	7a		ply				ply 								; restore current, fall through.
.d2e7	b2e7					_TSTNext:
.d2e7	b2e7	e6 38		inc $38				inc 	zTemp1 						; token counter
.d2e9	b2e9	98		tya				tya
.d2ea	b2ea	18		clc				clc
.d2eb	b2eb	71 36		adc ($36),y			adc 	(zTemp0),y 					; add [Length] + 2 to Y
.d2ed	b2ed	1a		inc a				inc 	a 							; +1
.d2ee	b2ee	1a		inc a				inc 	a 							; +2
.d2ef	b2ef	a8		tay				tay
.d2f0	b2f0	10 c1		bpl $b2b3			bpl 	_TSTLoop 					; if Y < $80 loop back
.d2f2	b2f2	98		tya				tya 								; add Y to zTemp0 and reset Y
.d2f3	b2f3	a0 00		ldy #$00			ldy 	#0   						; so we can use Y to search fast
.d2f5	b2f5	18		clc				clc  								; but have tables > 255 bytes
.d2f6	b2f6	65 36		adc $36				adc 	zTemp0 						; when Y gets >= 128 we reset Y
.d2f8	b2f8	85 36		sta $36				sta 	zTemp0 						; and adjust the table pointer/
.d2fa	b2fa	90 b7		bcc $b2b3			bcc 	_TSTLoop
.d2fc	b2fc	e6 37		inc $37				inc 	zTemp0+1
.d2fe	b2fe	80 b3		bra $b2b3			bra 	_TSTLoop
.d300	b300					_TSTFail:
.d300	b300	18		clc				clc
.d301	b301	60		rts				rts
.d302	b302					Export_TKTokeniseLine:
.d302	b302	20 8a b4	jsr $b48a			jsr 	LCLFixLineBufferCase 		; fix line case
.d305	b305	a9 03		lda #$03			lda 	#3 							; reset the token buffer to empty
.d307	b307	8d 2a 04	sta $042a			sta 	tokenOffset 				; (3 bytes for line number & offset)
.d30a	b30a	9c 2b 04	stz $042b			stz 	tokenLineNumber
.d30d	b30d	9c 2c 04	stz $042c			stz 	tokenLineNumber+1
.d310	b310	a2 ff		ldx #$ff			ldx 	#$FF
.d312	b312					_TKFindFirst:
.d312	b312	e8		inx				inx
.d313	b313	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.d316	b316	f0 79		beq $b391			beq 	_TKExit
.d318	b318	c9 20		cmp #$20			cmp 	#' '
.d31a	b31a	90 f6		bcc $b312			bcc 	_TKFindFirst
.d31c	b31c	c9 30		cmp #$30			cmp 	#'0'
.d31e	b31e	90 07		bcc $b327			bcc 	_TKNoLineNumber
.d320	b320	c9 3a		cmp #$3a			cmp 	#'9'+1
.d322	b322	b0 03		bcs $b327			bcs 	_TKNoLineNumber
.d324	b324	20 b4 b4	jsr $b4b4			jsr 	TOKExtractLineNumber
.d327	b327					_TKNoLineNumber:
.d327	b327					_TKTokeniseLoop:
.d327	b327	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; next character, exit if zero EOL.
.d32a	b32a	f0 65		beq $b391			beq 	_TKExit
.d32c	b32c	e8		inx				inx
.d32d	b32d	c9 20		cmp #$20			cmp 	#' '
.d32f	b32f	f0 f6		beq $b327			beq 	_TKTokeniseLoop 			; keep looping if space found.
.d331	b331	ca		dex				dex 								; undo last get, A contains character, X is position.
.d332	b332	c9 5f		cmp #$5f			cmp 	#'_'						; _ A-Z is identifier *or* token
.d334	b334	f0 61		beq $b397			beq 	_TKTokeniseIdentifier 		; (already case converted outside string constants)
.d336	b336	c9 41		cmp #$41			cmp 	#'A'
.d338	b338	90 04		bcc $b33e			bcc 	_TKTokenisePunctuation
.d33a	b33a	c9 5b		cmp #$5b			cmp 	#'Z'+1
.d33c	b33c	90 59		bcc $b397			bcc 	_TKTokeniseIdentifier
.d33e	b33e					_TKTokenisePunctuation:
.d33e	b33e	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.d340	b340	f0 27		beq $b369			beq 	_TKString
.d342	b342	c9 24		cmp #$24			cmp 	#'$'						; hexadecimal constant ($ only appears at end of identifiers)
.d344	b344	f0 28		beq $b36e			beq 	_TKHexConstant
.d346	b346	c9 3c		cmp #$3c			cmp 	#'<' 						; check for < > handlers - these are for <> <= >= >> <<
.d348	b348	f0 29		beq $b373			beq 	_TKCheckDouble
.d34a	b34a	c9 3e		cmp #$3e			cmp 	#'>'
.d34c	b34c	f0 25		beq $b373			beq 	_TKCheckDouble
.d34e	b34e					_TKStandardPunctuation:
.d34e	b34e	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get the punctuation token back.
.d351	b351	c9 40		cmp #$40			cmp 	#64 						; are we >= 64
.d353	b353	90 0e		bcc $b363			bcc 	_TKNoShift
.d355	b355	48		pha				pha 								; save. we are about to convert this punctuation token from
.d356	b356	29 07		and #$07			and 	#7 							; lower 3 bits in zTemp0
.d358	b358	85 36		sta $36				sta 	zTemp0
.d35a	b35a	68		pla				pla
.d35b	b35b	29 20		and #$20			and 	#32 						; bit 5
.d35d	b35d	4a		lsr a				lsr 	a 							; shift into bit 3
.d35e	b35e	4a		lsr a				lsr 	a
.d35f	b35f	05 36		ora $36				ora 	zTemp0
.d361	b361	09 10		ora #$10			ora 	#$10						; now in the range 16-31
.d363	b363					_TKNoShift:
.d363	b363	20 f9 b4	jsr $b4f9			jsr 	TOKWriteByte 				; write the punctuation character
.d366	b366	e8		inx				inx 								; consume the character
.d367	b367	80 be		bra $b327			bra 	_TKTokeniseLoop 			; and loop round again.
.d369	b369					_TKString:
.d369	b369	20 19 b4	jsr $b419			jsr 	TOKTokenString
.d36c	b36c	80 b9		bra $b327			bra 	_TKTokeniseLoop
.d36e	b36e					_TKHexConstant:
.d36e	b36e	20 54 b4	jsr $b454			jsr 	TOKHexConstant
.d371	b371	80 b4		bra $b327			bra 	_TKTokeniseLoop
.d373	b373					_TKCheckDouble:
.d373	b373	bd 2b 05	lda $052b,x			lda 	lineBuffer+1,x 				; get next character
.d376	b376	c9 3c		cmp #$3c			cmp 	#'<'						; if not < = > which are ASCII consecutive go back
.d378	b378	90 d4		bcc $b34e			bcc 	_TKStandardPunctuation 		; and do the normal punctuation handler.
.d37a	b37a	c9 3f		cmp #$3f			cmp 	#'>'+1
.d37c	b37c	b0 d0		bcs $b34e			bcs 	_TKStandardPunctuation
.d37e	b37e	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; this is < (60) or > (62)
.d381	b381	29 02		and #$02			and 	#2 							; now < (0) or > (2)
.d383	b383	0a		asl a				asl 	a 							; now < (0) or > (4), CC also
.d384	b384	7d 2b 05	adc $052b,x			adc 	lineBuffer+1,x 				; add < = > codes - < code
.d387	b387	38		sec				sec
.d388	b388	e9 3c		sbc #$3c			sbc 	#'<'
.d38a	b38a	20 f9 b4	jsr $b4f9			jsr 	TOKWriteByte 				; this is in the range 0-7
.d38d	b38d	e8		inx				inx 								; consume both
.d38e	b38e	e8		inx				inx
.d38f	b38f	80 96		bra $b327			bra 	_TKTokeniseLoop
.d391	b391	a9 80		lda #$80	_TKExit:lda 	#KWC_EOL 					; write end of line byte
.d393	b393	20 f9 b4	jsr $b4f9			jsr 	TOKWriteByte
.d396	b396	60		rts				rts
.d397	b397					_TKTokeniseIdentifier:
.d397	b397	8e 00 04	stx $0400			stx 	identStart 					; save start
.d39a	b39a	9c 04 04	stz $0404			stz 	identTypeByte 				; zero the type byte
.d39d	b39d					_TKCheckLoop:
.d39d	b39d	e8		inx				inx 								; look at next, we know first is identifier already.
.d39e	b39e	bd 2a 05	lda $052a,x			lda  	lineBuffer,x
.d3a1	b3a1	c9 5f		cmp #$5f			cmp 	#"_" 						; legal char _ 0-9 A-Z
.d3a3	b3a3	f0 f8		beq $b39d			beq 	_TKCheckLoop
.d3a5	b3a5	c9 30		cmp #$30			cmp	 	#"0"
.d3a7	b3a7	90 0c		bcc $b3b5			bcc 	_TKEndIdentifier
.d3a9	b3a9	c9 3a		cmp #$3a			cmp 	#"9"+1
.d3ab	b3ab	90 f0		bcc $b39d			bcc 	_TKCheckLoop
.d3ad	b3ad	c9 41		cmp #$41			cmp	 	#"A"
.d3af	b3af	90 04		bcc $b3b5			bcc 	_TKEndIdentifier
.d3b1	b3b1	c9 5b		cmp #$5b			cmp 	#"Z"+1
.d3b3	b3b3	90 e8		bcc $b39d			bcc 	_TKCheckLoop
.d3b5	b3b5					_TKEndIdentifier:
.d3b5	b3b5	8e 01 04	stx $0401			stx 	identTypeStart 				; save start of type text (if any !)
.d3b8	b3b8	a0 08		ldy #$08			ldy 	#$08 						; this is the identifier type byte for #
.d3ba	b3ba	c9 23		cmp #$23			cmp 	#"#"						; followed by #
.d3bc	b3bc	f0 06		beq $b3c4			beq 	_TKHasTypeCharacter
.d3be	b3be	a0 10		ldy #$10			ldy 	#$10 						; this is the identifier type byte for $
.d3c0	b3c0	c9 24		cmp #$24			cmp 	#"$"						; followed by $ or #
.d3c2	b3c2	d0 07		bne $b3cb			bne 	_TKNoTypeCharacter
.d3c4	b3c4					_TKHasTypeCharacter:
.d3c4	b3c4	8c 04 04	sty $0404			sty 	identTypeByte 				; has # or $, save the type
.d3c7	b3c7	e8		inx				inx 								; consume the type character
.d3c8	b3c8	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.d3cb	b3cb					_TKNoTypeCharacter:
.d3cb	b3cb	c9 28		cmp #$28			cmp 	#"("						; is it open parenthesis (e.g. array)
.d3cd	b3cd	d0 09		bne $b3d8			bne 	_TKNoArray
.d3cf	b3cf	e8		inx				inx 								; skip the (
.d3d0	b3d0	ad 04 04	lda $0404			lda 	identTypeByte 				; set bit 2 (e.g. array) in type byte
.d3d3	b3d3	09 04		ora #$04			ora 	#$04
.d3d5	b3d5	8d 04 04	sta $0404			sta 	identTypeByte
.d3d8	b3d8					_TKNoArray:
.d3d8	b3d8	8e 02 04	stx $0402			stx 	identTypeEnd 				; save end marker, e.g. continue from here.
.d3db	b3db	20 75 b4	jsr $b475			jsr 	TOKCalculateHash 			; calculate the has for those tokens
.d3de	b3de	a0 ac		ldy #$ac			ldy 	#(KeywordSet0) >> 8
.d3e0	b3e0	a9 98		lda #$98			lda 	#(KeywordSet0) & $FF
.d3e2	b3e2	20 a9 b2	jsr $b2a9			jsr 	TOKSearchTable
.d3e5	b3e5	a2 00		ldx #$00			ldx 	#0
.d3e7	b3e7	b0 1f		bcs $b408			bcs 	_TKFoundToken
.d3e9	b3e9	a0 ae		ldy #$ae			ldy 	#(KeywordSet1) >> 8
.d3eb	b3eb	a9 af		lda #$af			lda 	#(KeywordSet1) & $FF
.d3ed	b3ed	20 a9 b2	jsr $b2a9			jsr 	TOKSearchTable
.d3f0	b3f0	a2 81		ldx #$81			ldx 	#$81
.d3f2	b3f2	b0 14		bcs $b408			bcs 	_TKFoundToken
.d3f4	b3f4	a0 af		ldy #$af			ldy 	#(KeywordSet2) >> 8
.d3f6	b3f6	a9 22		lda #$22			lda 	#(KeywordSet2) & $FF
.d3f8	b3f8	20 a9 b2	jsr $b2a9			jsr 	TOKSearchTable
.d3fb	b3fb	a2 82		ldx #$82			ldx 	#$82
.d3fd	b3fd	b0 09		bcs $b408			bcs 	_TKFoundToken
.d3ff	b3ff	20 05 b5	jsr $b505			jsr 	TOKCheckCreateVariableRecord ; failed all, it's a variable, create record if does not exist.
.d402	b402	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.d405	b405	4c 27 b3	jmp $b327			jmp 	_TKTokeniseLoop 			; and go round again.
.d408	b408					_TKFoundToken:
.d408	b408	48		pha				pha 								; save token
.d409	b409	8a		txa				txa 								; shift in X, is there one ?
.d40a	b40a	f0 03		beq $b40f			beq 	_TKNoTShift
.d40c	b40c	20 f9 b4	jsr $b4f9			jsr 	TOKWriteByte 				; if so, write it out
.d40f	b40f					_TKNoTShift:
.d40f	b40f	68		pla				pla 								; restore and write token
.d410	b410	20 f9 b4	jsr $b4f9			jsr 	TOKWriteByte
.d413	b413	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.d416	b416	4c 27 b3	jmp $b327			jmp 	_TKTokeniseLoop 			; and go round again.
.d419	b419					TOKTokenString:
.d419	b419	a9 ff		lda #$ff			lda 	#KWC_STRING 				; string token.
.d41b	b41b	20 f9 b4	jsr $b4f9			jsr 	TOKWriteByte
.d41e	b41e	e8		inx				inx									; start of quoted string.
.d41f	b41f	da		phx				phx 								; push start of string on top
.d420	b420	ca		dex				dex 								; because we pre-increment
.d421	b421					_TSFindEnd:
.d421	b421	e8		inx				inx
.d422	b422	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; next character
.d425	b425	f0 04		beq $b42b			beq 	_TSEndOfString 				; no matching quote, we don't mind.
.d427	b427	c9 22		cmp #$22			cmp 	#'"' 						; go back if quote not found
.d429	b429	d0 f6		bne $b421			bne 	_TSFindEnd
.d42b	b42b					_TSEndOfString:
.d42b	b42b	7a		ply				ply  								; so now Y is first character, X is character after end.
.d42c	b42c	48		pha				pha 								; save terminating character
.d42d	b42d	20 35 b4	jsr $b435			jsr 	TOKWriteBlockXY 			; write X to Y as a data block
.d430	b430	68		pla				pla 								; terminating character
.d431	b431	f0 01		beq $b434			beq 	_TSNotQuote					; if it wasn't EOS skip it
.d433	b433	e8		inx				inx
.d434	b434					_TSNotQuote:
.d434	b434	60		rts				rts
.d435	b435					TOKWriteBlockXY:
.d435	b435	86 36		stx $36				stx 	zTemp0 						; save end character
.d437	b437	98		tya				tya 								; use 2's complement to work out the byte size
.d438	b438	49 ff		eor #$ff			eor 	#$FF
.d43a	b43a	38		sec				sec
.d43b	b43b	65 36		adc $36				adc 	zTemp0
.d43d	b43d	1a		inc a				inc 	a 							; one extra for NULL
.d43e	b43e	20 f9 b4	jsr $b4f9			jsr 	TOKWriteByte
.d441	b441					_TOBlockLoop:
.d441	b441	c4 36		cpy $36				cpy 	zTemp0 						; exit if reached the end
.d443	b443	f0 09		beq $b44e			beq 	_TOBlockExit
.d445	b445	b9 2a 05	lda $052a,y			lda 	lineBuffer,y 				; write byte out.
.d448	b448	20 f9 b4	jsr $b4f9			jsr 	TOKWriteByte
.d44b	b44b	c8		iny				iny
.d44c	b44c	80 f3		bra $b441			bra 	_TOBlockLoop
.d44e	b44e					_TOBlockExit:
.d44e	b44e	a9 00		lda #$00			lda 	#0 							; add NULL.
.d450	b450	20 f9 b4	jsr $b4f9			jsr 	TOKWriteByte
.d453	b453	60		rts				rts
.d454	b454					TOKHexConstant:
.d454	b454	a9 fe		lda #$fe			lda 	#KWC_HEXCONST 				; hex constant token.
.d456	b456	20 f9 b4	jsr $b4f9			jsr 	TOKWriteByte
.d459	b459	e8		inx				inx									; start of quoted string.
.d45a	b45a	da		phx				phx 								; push start of constant on top
.d45b	b45b	ca		dex				dex
.d45c	b45c					_THFindLoop:
.d45c	b45c	e8		inx				inx 	 							; this is stored in a block, so find out how long
.d45d	b45d	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; the hex constant is.
.d460	b460	c9 30		cmp #$30			cmp 	#"0"
.d462	b462	90 0c		bcc $b470			bcc 	_THFoundEnd
.d464	b464	c9 3a		cmp #$3a			cmp 	#"9"+1
.d466	b466	90 f4		bcc $b45c			bcc 	_THFindLoop
.d468	b468	c9 41		cmp #$41			cmp 	#"A"
.d46a	b46a	90 04		bcc $b470			bcc 	_THFoundEnd
.d46c	b46c	c9 47		cmp #$47			cmp 	#"F"+1
.d46e	b46e	90 ec		bcc $b45c			bcc 	_THFindLoop
.d470	b470					_THFoundEnd:
.d470	b470	7a		ply				ply 								; restore start
.d471	b471	20 35 b4	jsr $b435			jsr 	TOKWriteBlockXY 			; output the block
.d474	b474	60		rts				rts
.d475	b475					TOKCalculateHash:
.d475	b475	da		phx				phx
.d476	b476	ae 00 04	ldx $0400			ldx 	identStart 					; needs to be same as in tokens.py - simple sum at present.
.d479	b479	a9 00		lda #$00			lda 	#0
.d47b	b47b					_TCHLoop:
.d47b	b47b	18		clc				clc
.d47c	b47c	7d 2a 05	adc $052a,x			adc 	lineBuffer,x
.d47f	b47f	e8		inx				inx
.d480	b480	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; do the whole thing including type and array markers.
.d483	b483	d0 f6		bne $b47b			bne 	_TCHLoop
.d485	b485	8d 03 04	sta $0403			sta 	identHash 					; save the hash
.d488	b488	fa		plx				plx
.d489	b489	60		rts				rts
.d48a	b48a					LCLFixLineBufferCase:
.d48a	b48a	a2 00		ldx #$00			ldx 	#0
.d48c	b48c					_FLBCLoop:
.d48c	b48c	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get next character
.d48f	b48f	f0 22		beq $b4b3			beq 	_FLBCExit 					; end of string.
.d491	b491	c9 22		cmp #$22			cmp 	#'"'						; quote, go to in quotes
.d493	b493	f0 11		beq $b4a6			beq 	_FLBCInQuotes
.d495	b495	e8		inx				inx
.d496	b496	c9 61		cmp #$61			cmp 	#'a'						; needs capitalising ?
.d498	b498	90 f2		bcc $b48c			bcc 	_FLBCLoop
.d49a	b49a	c9 7b		cmp #$7b			cmp 	#'z'+1
.d49c	b49c	b0 ee		bcs $b48c			bcs 	_FLBCLoop
.d49e	b49e	38		sec				sec 								; make U/C
.d49f	b49f	e9 20		sbc #$20			sbc 	#32
.d4a1	b4a1	9d 29 05	sta $0529,x			sta	 	lineBuffer-1,x 				; write back
.d4a4	b4a4	80 e6		bra $b48c			bra 	_FLBCLoop
.d4a6	b4a6					_FLBCInQuotes:
.d4a6	b4a6	e8		inx				inx 								; advance
.d4a7	b4a7	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get next
.d4aa	b4aa	f0 07		beq $b4b3			beq 	_FLBCExit 					; exit on EOS
.d4ac	b4ac	c9 22		cmp #$22			cmp 	#'"' 				 		; until " found
.d4ae	b4ae	d0 f6		bne $b4a6			bne 	_FLBCInQuotes
.d4b0	b4b0	e8		inx				inx 								; skip over it
.d4b1	b4b1	80 d9		bra $b48c			bra 	_FLBCLoop
.d4b3	b4b3					_FLBCExit:
.d4b3	b4b3	60		rts				rts
.d4b4	b4b4					TOKExtractLineNumber:
.d4b4	b4b4	ad 2c 04	lda $042c			lda 	tokenLineNumber+1 			; push current value on stack
.d4b7	b4b7	48		pha				pha
.d4b8	b4b8	ad 2b 04	lda $042b			lda 	tokenLineNumber
.d4bb	b4bb	48		pha				pha
.d4bc	b4bc	20 f2 b4	jsr $b4f2			jsr 	_LCLNTimes2 				; line # x 2
.d4bf	b4bf	20 f2 b4	jsr $b4f2			jsr 	_LCLNTimes2 				; line # x 4
.d4c2	b4c2	18		clc				clc 								; add stacked value
.d4c3	b4c3	68		pla				pla
.d4c4	b4c4	6d 2b 04	adc $042b			adc 	tokenLineNumber
.d4c7	b4c7	8d 2b 04	sta $042b			sta 	tokenLineNumber
.d4ca	b4ca	68		pla				pla
.d4cb	b4cb	6d 2c 04	adc $042c			adc 	tokenLineNumber+1
.d4ce	b4ce	8d 2c 04	sta $042c			sta 	tokenLineNumber+1 			; line # x 5
.d4d1	b4d1	20 f2 b4	jsr $b4f2			jsr 	_LCLNTimes2 				; line # x 10
.d4d4	b4d4	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get and consume character
.d4d7	b4d7	e8		inx				inx
.d4d8	b4d8	29 0f		and #$0f			and 	#15 						; add to line #
.d4da	b4da	18		clc				clc
.d4db	b4db	6d 2b 04	adc $042b			adc 	tokenLineNumber
.d4de	b4de	8d 2b 04	sta $042b			sta 	tokenLineNumber
.d4e1	b4e1	90 03		bcc $b4e6			bcc 	_TLENNoCarry
.d4e3	b4e3	ee 2c 04	inc $042c			inc 	tokenLineNumber+1
.d4e6	b4e6					_TLENNoCarry:
.d4e6	b4e6	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; more digits ?
.d4e9	b4e9	c9 30		cmp #$30			cmp 	#'0'
.d4eb	b4eb	90 04		bcc $b4f1			bcc 	_TLENExit
.d4ed	b4ed	c9 3a		cmp #$3a			cmp 	#'9'+1
.d4ef	b4ef	90 c3		bcc $b4b4			bcc 	TOKExtractLineNumber
.d4f1	b4f1					_TLENExit:
.d4f1	b4f1	60		rts				rts
.d4f2	b4f2					_LCLNTimes2:
.d4f2	b4f2	0e 2b 04	asl $042b			asl 	tokenLineNumber 			; doubles tokenLineNumber.
.d4f5	b4f5	2e 2c 04	rol $042c			rol 	tokenLineNumber+1
.d4f8	b4f8	60		rts				rts
.d4f9	b4f9					TOKWriteByte:
.d4f9	b4f9	da		phx				phx
.d4fa	b4fa	ae 2a 04	ldx $042a			ldx 	tokenOffset 				; next slot to write to
.d4fd	b4fd	9d 2a 04	sta $042a,x			sta 	tokenOffset,x 				; write byte out
.d500	b500	ee 2a 04	inc $042a			inc 	tokenOffset 				; advance slot.
.d503	b503	fa		plx				plx
.d504	b504	60		rts				rts
.d505	b505					TOKCheckCreateVariableRecord:
.d505	b505	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.d507	b507	85 36		sta $36				sta 	0+zTemp0
.d509	b509	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.d50b	b50b	85 37		sta $37				sta 	1+zTemp0
.d50d	b50d					_CCVSearch:
.d50d	b50d	b2 36		lda ($36)			lda 	(zTemp0) 					; end of list
.d50f	b50f	f0 2c		beq $b53d			beq 	_CCVFail
.d511	b511	a0 01		ldy #$01			ldy 	#1 							; read the hash
.d513	b513	b1 36		lda ($36),y			lda 	(zTemp0),y 					; does it match ?
.d515	b515	cd 03 04	cmp $0403			cmp 	identHash 	  				; if not, try the next.
.d518	b518	d0 16		bne $b530			bne 	_CCVNext
.d51a	b51a	a0 08		ldy #$08			ldy 	#8 							; name in variable record
.d51c	b51c	ae 00 04	ldx $0400			ldx 	identStart
.d51f	b51f					_CCVCompare:
.d51f	b51f	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; xor them. zero if the same, except
.d522	b522	51 36		eor ($36),y			eor 	(zTemp0),y 					; bit 7 is used for EOS.
.d524	b524	e8		inx				inx 								; advance pointers
.d525	b525	c8		iny				iny
.d526	b526	0a		asl a				asl 	a 							; A = 0 if they match, CS if end.
.d527	b527	d0 07		bne $b530			bne 	_CCVNext  					; didn't match go to next.
.d529	b529	90 f4		bcc $b51f			bcc 	_CCVCompare 				; not finished yet.
.d52b	b52b	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; matched whole thing ?
.d52e	b52e	f0 41		beq $b571			beq 	_CCVFound 					; yes, we were successful
.d530	b530					_CCVNext:
.d530	b530	18		clc				clc 								; go to next record.
.d531	b531	b2 36		lda ($36)			lda 	(zTemp0) 					; add offset to pointer
.d533	b533	65 36		adc $36				adc 	zTemp0
.d535	b535	85 36		sta $36				sta 	zTemp0
.d537	b537	90 d4		bcc $b50d			bcc 	_CCVSearch
.d539	b539	e6 37		inc $37				inc 	zTemp0+1
.d53b	b53b	80 d0		bra $b50d			bra 	_CCVSearch
.d53d	b53d					_CCVFail:
.d53d	b53d	a0 01		ldy #$01			ldy 	#1 							; create the new record. Offset 1 is hash
.d53f	b53f	ad 03 04	lda $0403			lda 	identHash
.d542	b542	91 36		sta ($36),y			sta 	(zTemp0),y
.d544	b544	c8		iny				iny 								; offset 2 is the type byte
.d545	b545	ad 04 04	lda $0404			lda 	identTypeByte
.d548	b548	91 36		sta ($36),y			sta 	(zTemp0),y
.d54a	b54a	c8		iny				iny
.d54b	b54b					_CCVData:
.d54b	b54b	a9 00		lda #$00			lda 	#0 							; erase data 3-7 (the 5 value bytes)
.d54d	b54d	91 36		sta ($36),y			sta 	(zTemp0),y
.d54f	b54f	c8		iny				iny
.d550	b550	c0 08		cpy #$08			cpy 	#8
.d552	b552	90 f7		bcc $b54b			bcc 	_CCVData
.d554	b554	ae 00 04	ldx $0400			ldx 	identStart 					; copy name into 8 on.
.d557	b557					_CCVCopyName:
.d557	b557	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.d55a	b55a	91 36		sta ($36),y			sta 	(zTemp0),y
.d55c	b55c	e8		inx				inx
.d55d	b55d	c8		iny				iny
.d55e	b55e	ec 02 04	cpx $0402			cpx 	identTypeEnd
.d561	b561	d0 f4		bne $b557			bne 	_CCVCopyName
.d563	b563	98		tya				tya 								; patch offset
.d564	b564	92 36		sta ($36)			sta 	(zTemp0)
.d566	b566	a9 00		lda #$00			lda 	#0 							; offset for next is zero.
.d568	b568	91 36		sta ($36),y			sta 	(zTemp0),y
.d56a	b56a	88		dey				dey
.d56b	b56b	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set bit 7 of last bit
.d56d	b56d	09 80		ora #$80			ora 	#$80
.d56f	b56f	91 36		sta ($36),y			sta 	(zTemp0),y
.d571	b571					_CCVFound:
.d571	b571	a5 37		lda $37				lda 	zTemp0+1 					; write out MSB
.d573	b573	38		sec				sec
.d574	b574	e9 10		sbc #$10			sbc 	#(VariableSpace >> 8) 		; offset from the start of the variable token
.d576	b576	09 40		ora #$40			ora 	#$40 						; make it a writeable token $4000-$7FFF
.d578	b578	20 f9 b4	jsr $b4f9			jsr 	TOKWriteByte
.d57b	b57b	a5 36		lda $36				lda 	zTemp0 						; write out LSB
.d57d	b57d	20 f9 b4	jsr $b4f9			jsr 	TOKWriteByte
.d580	b580	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_sound.module

=1						soundIntegrated=1
.d581	b581					SNDCheckChannel:
.d581	b581	aa		tax				tax
.d582	b582	bd 38 08	lda $0838,x			lda 	SNDTimeLeft,x 				; currently playing a note
.d585	b585	d0 38		bne $b5bf			bne 	_SNDCCExit
.d587	b587	da		phx				phx 								; save current channel
.d588	b588	8a		txa				txa 								; put in A
.d589	b589	20 05 b6	jsr $b605			jsr 	SNDFindNextNoteForA 		; is there a note for A in the queue ?
.d58c	b58c	68		pla				pla 								; channel # in A
.d58d	b58d	90 30		bcc $b5bf			bcc 	_SNDCCExit  				; nothing in the queue for this channel, exit.
.d58f	b58f	a8		tay				tay 								; Y is the channel #
.d590	b590	bd 2d 07	lda $072d,x			lda 	SNDQueue+1,x 				; copy data into the slot.
.d593	b593	99 2c 08	sta $082c,y			sta 	SNDPitchLow,y
.d596	b596	bd 2e 07	lda $072e,x			lda 	SNDQueue+2,x
.d599	b599	99 30 08	sta $0830,y			sta 	SNDPitchHigh,y
.d59c	b59c	bd 2f 07	lda $072f,x			lda 	SNDQueue+3,x
.d59f	b59f	99 34 08	sta $0834,y			sta 	SNDVolume,y
.d5a2	b5a2	bd 30 07	lda $0730,x			lda 	SNDQueue+4,x
.d5a5	b5a5	99 38 08	sta $0838,y			sta 	SNDTimeLeft,y
.d5a8	b5a8	bd 31 07	lda $0731,x			lda 	SNDQueue+5,x
.d5ab	b5ab	99 3c 08	sta $083c,y			sta 	SNDAdjustLow,y
.d5ae	b5ae	bd 32 07	lda $0732,x			lda 	SNDQueue+6,x
.d5b1	b5b1	99 40 08	sta $0840,y			sta 	SNDAdjustHigh,y
.d5b4	b5b4	5a		phy				phy 								; save channel #
.d5b5	b5b5	20 1f b6	jsr $b61f			jsr 	SNDDeleteXFromQueue 		; delete record at X from queue
.d5b8	b5b8	ce 2b 07	dec $072b			dec 	SNDLength 					; reduce the queue length.
.d5bb	b5bb	68		pla				pla
.d5bc	b5bc	20 c0 b5	jsr $b5c0			jsr 	SNDUpdateNote 				; update channel A
.d5bf	b5bf					_SNDCCExit:
.d5bf	b5bf	60		rts				rts
.d5c0	b5c0					SNDUpdateNote:
.d5c0	b5c0	aa		tax				tax 								; so we can access records
.d5c1	b5c1	0a		asl a				asl 	a 							; convert it to a channel bit pair in 5,6
.d5c2	b5c2	0a		asl a				asl 	a
.d5c3	b5c3	0a		asl a				asl 	a
.d5c4	b5c4	0a		asl a				asl 	a
.d5c5	b5c5	0a		asl a				asl 	a
.d5c6	b5c6	8d 2a 07	sta $072a			sta 	SNDChannelBits
.d5c9	b5c9	bd 38 08	lda $0838,x			lda 	SNDTimeLeft,x 				; are we silent
.d5cc	b5cc	f0 2e		beq $b5fc			beq 	_SNDUNIsSilent
.d5ce	b5ce	ad 2a 07	lda $072a			lda 	SNDChannelBits 				; push channel bits on stack
.d5d1	b5d1	48		pha				pha
.d5d2	b5d2	bd 2c 08	lda $082c,x			lda 	SNDPitchLow,x 				; get 4 lowest bits of pitch.
.d5d5	b5d5	29 0f		and #$0f			and 	#$0F
.d5d7	b5d7	0d 2a 07	ora $072a			ora 	SNDChannelBits 				; set channel bits
.d5da	b5da	09 80		ora #$80			ora 	#$80 						; write to pitch register
.d5dc	b5dc	20 69 b6	jsr $b669			jsr 	SNDWritePorts
.d5df	b5df	bd 30 08	lda $0830,x			lda 	SNDPitchHigh,x 				; pitch high => channel temp.
.d5e2	b5e2	8d 2a 07	sta $072a			sta 	SNDChannelBits
.d5e5	b5e5	bd 2c 08	lda $082c,x			lda 	SNDPitchLow,x
.d5e8	b5e8	4e 2a 07	lsr $072a			lsr 	SNDChannelBits 				; shift 2 LSBs into MSB of A
.d5eb	b5eb	6a		ror a				ror 	a
.d5ec	b5ec	4e 2a 07	lsr $072a			lsr 	SNDChannelBits
.d5ef	b5ef	6a		ror a				ror 	a
.d5f0	b5f0	4a		lsr a				lsr 	a 							; put in bits 0-5
.d5f1	b5f1	4a		lsr a				lsr 	a
.d5f2	b5f2	20 69 b6	jsr $b669			jsr 	SNDWritePorts 				; write as rest of pitch register
.d5f5	b5f5	68		pla				pla
.d5f6	b5f6	09 90		ora #$90			ora 	#$90 						; set to write minimum attentuation.
.d5f8	b5f8	20 69 b6	jsr $b669			jsr 	SNDWritePorts
.d5fb	b5fb	60		rts				rts
.d5fc	b5fc					_SNDUNIsSilent:
.d5fc	b5fc	ad 2a 07	lda $072a			lda 	SNDChannelBits 				; channel bits
.d5ff	b5ff	09 9f		ora #$9f			ora 	#$9F 						; maximum attenuation
.d601	b601	20 69 b6	jsr $b669			jsr 	SNDWritePorts 				; write to the ports
.d604	b604	60		rts				rts
.d605	b605					SNDFindNextNoteForA:
.d605	b605	ac 2b 07	ldy $072b			ldy 	SNDLength 					; queue size into Y
.d608	b608	f0 13		beq $b61d			beq 	_SNDFNNFail 				; queue empty.
.d60a	b60a	a2 00		ldx #$00			ldx 	#0
.d60c	b60c					_SNDFNNSearch:
.d60c	b60c	dd 2c 07	cmp $072c,x			cmp 	SNDQueue,x 					; does it match the channel
.d60f	b60f	38		sec				sec
.d610	b610	f0 0c		beq $b61e			beq 	_SNDFNNExit 				; if so exit with CS.
.d612	b612	e8		inx				inx 								; next queue slot.
.d613	b613	e8		inx				inx
.d614	b614	e8		inx				inx
.d615	b615	e8		inx				inx
.d616	b616	e8		inx				inx
.d617	b617	e8		inx				inx
.d618	b618	e8		inx				inx
.d619	b619	e8		inx				inx
.d61a	b61a	88		dey				dey 								; done the whole queue
.d61b	b61b	d0 ef		bne $b60c			bne 	_SNDFNNSearch 				; no, go back.
.d61d	b61d					_SNDFNNFail:
.d61d	b61d	18		clc				clc
.d61e	b61e					_SNDFNNexit:
.d61e	b61e	60		rts				rts
.d61f	b61f					SNDDeleteXFromQueue:
.d61f	b61f	e0 f8		cpx #$f8			cpx 	#SNDQueueSize*8-8 			; reached the end.
.d621	b621	f0 09		beq $b62c			beq 	_SNDDXExit
.d623	b623	bd 34 07	lda $0734,x			lda 	SNDQueue+8,x
.d626	b626	9d 2c 07	sta $072c,x			sta 	SNDQueue,x
.d629	b629	e8		inx				inx
.d62a	b62a	80 f3		bra $b61f			bra 	SNDDeleteXFromQueue
.d62c	b62c					_SNDDXExit:
.d62c	b62c	60		rts				rts
.072a						SNDChannelBits:
>072a								.fill 	1
.d62d	b62d					SNDQueueRequest:
.d62d	b62d	86 36		stx $36				stx 	zTemp0						; save queue address
.d62f	b62f	84 37		sty $37				sty 	zTemp0+1
.d631	b631	ae 2b 07	ldx $072b			ldx 	SNDLength 					; queue is full, can't take any more.
.d634	b634	e0 20		cpx #$20			cpx 	#SNDQueueSize
.d636	b636	f0 21		beq $b659			beq 	_SNDQRExit
.d638	b638	29 03		and #$03			and 	#3	 						; channel # and push on stack
.d63a	b63a	48		pha				pha
.d63b	b63b	8a		txa				txa  								; get offset in queue buffer/
.d63c	b63c	0a		asl a				asl 	a
.d63d	b63d	0a		asl a				asl 	a
.d63e	b63e	0a		asl a				asl 	a
.d63f	b63f	aa		tax				tax
.d640	b640	68		pla				pla 								; get back and push again
.d641	b641	48		pha				pha
.d642	b642	9d 2c 07	sta $072c,x			sta 	SNDQueue+0,x 				; save the channel #
.d645	b645	a0 00		ldy #$00			ldy 	#0 							; copy the rest in.
.d647	b647					_SNDQCopy:
.d647	b647	b1 36		lda ($36),y			lda 	(zTemp0),y
.d649	b649	e8		inx				inx
.d64a	b64a	c8		iny				iny
.d64b	b64b	9d 2c 07	sta $072c,x			sta 	SNDQueue,x
.d64e	b64e	c0 06		cpy #$06			cpy 	#6
.d650	b650	d0 f5		bne $b647			bne 	_SNDQCopy
.d652	b652	ee 2b 07	inc $072b			inc 	SNDLength 					; bump queue length.
.d655	b655	68		pla				pla 								; get channel # back
.d656	b656	20 81 b5	jsr $b581			jsr 	SNDCheckChannel 			; check if channel needs refreshing.
.d659	b659					_SNDQRExit:
.d659	b659	60		rts				rts
.d65a	b65a					SNDSilenceChannel:
.d65a	b65a	aa		tax				tax 								; zero time left.
.d65b	b65b	9e 38 08	stz $0838,x			stz 	SNDTimeLeft,x
.d65e	b65e	0a		asl a				asl 	a 							; shift into position
.d65f	b65f	0a		asl a				asl 	a
.d660	b660	0a		asl a				asl 	a
.d661	b661	0a		asl a				asl 	a
.d662	b662	0a		asl a				asl 	a
.d663	b663	09 9f		ora #$9f			ora 	#$9F 						; write register attenuation $F
.d665	b665	20 69 b6	jsr $b669			jsr 	SNDWritePorts
.d668	b668	60		rts				rts
.d669	b669					SNDWritePorts:
.d669	b669	da		phx				phx 								; save X
.d66a	b66a	a6 01		ldx $01				ldx 	1 							; save I/O status
.d66c	b66c	64 01		stz $01				stz 	1 							; access I/O page 0
.d66e	b66e	8d 00 d6	sta $d600			sta 	$D600 						; write to both
.d671	b671	8d 10 d6	sta $d610			sta 	$D610
.d674	b674	86 01		stx $01				stx 	1 							; restore I/O
.d676	b676	fa		plx				plx 								; restore X
.d677	b677	60		rts				rts
.d678	b678					Export_SNDCommand:
.d678	b678	da		phx				phx 								; save XY
.d679	b679	5a		phy				phy
.d67a	b67a	c9 0f		cmp #$0f			cmp 	#$0F 						; $0F is initialise
.d67c	b67c	f0 1d		beq $b69b			beq 	_SNDInitialise
.d67e	b67e	90 28		bcc $b6a8			bcc 	_SNDExit
.d680	b680	c9 3f		cmp #$3f			cmp 	#$3F 						; $3F is silence all
.d682	b682	f0 17		beq $b69b			beq 	_SNDSilence
.d684	b684	b0 22		bcs $b6a8			bcs 	_SNDExit
.d686	b686	c9 20		cmp #$20			cmp 	#$20 						; $2x is check playing => A
.d688	b688	b0 09		bcs $b693			bcs 	_SNDQueryPlay
.d68a	b68a	c9 14		cmp #$14			cmp 	#$14 						; $10-$13 is queue sound
.d68c	b68c	b0 1a		bcs $b6a8			bcs 	_SNDExit
.d68e	b68e	20 2d b6	jsr $b62d			jsr 	SNDQueueRequest
.d691	b691	80 15		bra $b6a8			bra 	_SNDExit
.d693	b693					_SNDQueryPlay:
.d693	b693	29 03		and #$03			and 	#3 							; get channel #
.d695	b695	aa		tax				tax
.d696	b696	bd 38 08	lda $0838,x			lda 	SNDTimeLeft,x 				; read time left, if zero then silent
.d699	b699	80 0d		bra $b6a8			bra 	_SNDExit
.d69b	b69b					_SNDInitialise:
.d69b	b69b					_SNDSilence:
.d69b	b69b	9c 2b 07	stz $072b			stz 	SNDLength 					; empty the queue.
.d69e	b69e	a9 03		lda #$03			lda 	#$3 						; silence channel 0-3.
.d6a0	b6a0					_SNDSilenceLoop:
.d6a0	b6a0	48		pha				pha
.d6a1	b6a1	20 5a b6	jsr $b65a			jsr 	SNDSilenceChannel
.d6a4	b6a4	68		pla				pla
.d6a5	b6a5	3a		dec a				dec 	a
.d6a6	b6a6	10 f8		bpl $b6a0			bpl 	_SNDSilenceLoop
.d6a8	b6a8					_SNDExit:
.d6a8	b6a8	7a		ply				ply
.d6a9	b6a9	fa		plx				plx
.d6aa	b6aa	60		rts				rts
=32						SNDQueueSize = 32 							; number of queue entries
.072b						SNDLength:
>072b								.fill 	1
.072c						SNDQueue:
>072c								.fill 	SNDQueueSize * 8
.082c						SNDPitchLow:
>082c								.fill 	4
.0830						SNDPitchHigh:
>0830								.fill 	4
.0834						SNDVolume:
>0834								.fill 	4
.0838						SNDTimeLeft:
>0838								.fill 	4
.083c						SNDAdjustLow:
>083c								.fill 	4
.0840						SNDAdjustHigh:
>0840								.fill 	4
.d6ab	b6ab					Export_SNDUpdate:
.d6ab	b6ab					PagedSNDUpdate:
.d6ab	b6ab	ad 38 08	lda $0838			lda 	SNDTimeLeft+0 				; look at time remaining
.d6ae	b6ae	f0 05		beq $b6b5			beq 	_SNDUNot0 					; not playing
.d6b0	b6b0	a2 00		ldx #$00			ldx 	#0 							; so we know which channel to update
.d6b2	b6b2	20 d4 b6	jsr $b6d4			jsr 	SNDUpdateChannel 			; update it.
.d6b5	b6b5					_SNDUNot0:
.d6b5	b6b5	ad 39 08	lda $0839			lda 	SNDTimeLeft+1
.d6b8	b6b8	f0 05		beq $b6bf			beq 	_SNDUNot1
.d6ba	b6ba	a2 01		ldx #$01			ldx 	#1
.d6bc	b6bc	20 d4 b6	jsr $b6d4			jsr 	SNDUpdateChannel
.d6bf	b6bf					_SNDUNot1:
.d6bf	b6bf	ad 3a 08	lda $083a			lda 	SNDTimeLeft+2
.d6c2	b6c2	f0 05		beq $b6c9			beq 	_SNDUNot2
.d6c4	b6c4	a2 02		ldx #$02			ldx 	#2
.d6c6	b6c6	20 d4 b6	jsr $b6d4			jsr 	SNDUpdateChannel
.d6c9	b6c9					_SNDUNot2:
.d6c9	b6c9	ad 3b 08	lda $083b			lda 	SNDTimeLeft+3
.d6cc	b6cc	f0 05		beq $b6d3			beq 	_SNDUNot3
.d6ce	b6ce	a2 03		ldx #$03			ldx 	#3
.d6d0	b6d0	20 d4 b6	jsr $b6d4			jsr 	SNDUpdateChannel
.d6d3	b6d3					_SNDUNot3:
.d6d3	b6d3	60		rts				rts
.d6d4	b6d4					SNDUpdateChannel:
.d6d4	b6d4	c9 ff		cmp #$ff			cmp 	#$FF 						; sound $FF play forever until turned off manually
.d6d6	b6d6	f0 2c		beq $b704			beq 	_SNDUCExit
.d6d8	b6d8	3a		dec a				dec 	a 							; decrement and update timer
.d6d9	b6d9	9d 38 08	sta $0838,x			sta 	SNDTimeLeft,x
.d6dc	b6dc	f0 1d		beq $b6fb			beq 	_SNDUCUpdate 				; if zero, silence channel
.d6de	b6de	bd 3c 08	lda $083c,x			lda 	SNDAdjustLow,x 				; adjust ?
.d6e1	b6e1	1d 40 08	ora $0840,x			ora 	SNDAdjustHigh,x
.d6e4	b6e4	f0 1e		beq $b704			beq 	_SNDUCExit 					; if zero carry on at current tone.
.d6e6	b6e6	18		clc				clc 								; add adjust, forcing into a 10 bit range
.d6e7	b6e7	bd 2c 08	lda $082c,x			lda 	SNDPitchLow,x
.d6ea	b6ea	7d 3c 08	adc $083c,x			adc 	SNDAdjustLow,x
.d6ed	b6ed	9d 2c 08	sta $082c,x			sta 	SNDPitchLow,x
.d6f0	b6f0	bd 30 08	lda $0830,x			lda 	SNDPitchHigh,x
.d6f3	b6f3	7d 40 08	adc $0840,x			adc 	SNDAdjustHigh,x
.d6f6	b6f6	29 03		and #$03			and 	#3
.d6f8	b6f8	9d 30 08	sta $0830,x			sta 	SNDPitchHigh,x
.d6fb	b6fb					_SNDUCUpdate:
.d6fb	b6fb	8a		txa				txa 								; which channel.
.d6fc	b6fc	48		pha				pha
.d6fd	b6fd	20 c0 b5	jsr $b5c0			jsr 	SNDUpdateNote 				; update the current note
.d700	b700	68		pla				pla
.d701	b701	20 81 b5	jsr $b581			jsr 	SNDCheckChannel 			; more to do ?
.d704	b704					_SNDUCExit:
.d704	b704	60		rts				rts

;******  Return to file: _basic.asm


;******  End of listing
