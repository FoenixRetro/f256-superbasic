
; 64tass Turbo Assembler Macro V1.57.2900 listing file
; 64tass -D AUTORUN=0 "-D MONITOR_ADDRESS=\$E000" "-D LOCKOUT_ADDRESS=\$F000" "-D BASIC_ADDRESS=\$38000" "-D SOURCE_ADDRESS=\$28000" "-D SPRITE_ADDRESS=\$30000" -q -b -Wall -c -D "HARDWARE=0 $'\x9'$'\x9'$'\x9'$'\x9'$'\x9'$'\x9'" -L output/basic.lst -l output/basic.lbl -Wall -o build/basic.rom _basic.asm
; Mon Dec 12 16:22:33 2022

;Offset	;PC	;Hex		;Monitor	;Source

;******  Command line definitions

=0						AUTORUN=0
=$e000						 MONITOR_ADDRESS=$E000
=$f000						 LOCKOUT_ADDRESS=$F000
=$38000						 BASIC_ADDRESS=$38000
=$28000						 SOURCE_ADDRESS=$28000
=$30000						 SPRITE_ADDRESS=$30000
=0						HARDWARE=0

;******  Processing input file: _basic.asm


;******  Processing file: ./common/aa.system/01common.inc

=$30						ZeroPageMandatory = $30
=$50						ZeroPagePreference = $50
=$400						MemoryStorage = $400
=$2000						BasicStart = $2000
=$8000						BasicEnd = $8000
=$8000						CodeStart = $8000
=$1000						VariableSpace = $1000
=$2000						EndVariableSpace = $2000
=8						MathStackSize = 8
=512						BasicStackSize = 512
=3584						BasicStackBase = $1000-BasicStackSize
=80						MaxLineSize = 80

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/02macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/04data.inc

.0030						codePtr:
>0030								.fill 	4
.0034						basicStack:
>0034								.fill 	2
.0036						zTemp0:
>0036								.fill 	2
.0038						zTemp1:
>0038								.fill 	2
.003a						zTemp2:
>003a								.fill 	2
.003c						zsTemp:
>003c								.fill 	2
.003e						zaTemp:
>003e								.fill 	2
=$30						safePtr = codePtr 							; minimise direct tinkering
=$80						NSBIsNegative = $80 						; bit 7 : sign of mantissa (where numeric)
=$20						NSBIsReference = $20 						; bit 5 : is a reference
=$10						NSBIsString = $10 							; bit 4 : set if string (procedures don't go on the stack)
=$18						NSBTypeMask = $18 							; bits 4,3 : 00 int 01 float 10 string 11 procedure
=$03						NSBRefMask = $03 							; bits 0,1 : Bytes of reference, 00 = 4,01 = 1,10=2
=$04						NSBIsArray = $04
=$00						NSTInteger = $00 							; base types for bits 3..4
=$08						NSTFloat = $08
=$10						NSTString = $10
=$18						NSTProcedure = $18
.0050						NSStatus:
>0050								.fill 	MathStackSize
.0058						NSMantissa0:
>0058								.fill 	MathStackSize 				; (this is my integer mantissa system)
.0060						NSMantissa1:
>0060								.fill 	MathStackSize
.0068						NSMantissa2:
>0068								.fill 	MathStackSize
.0070						NSMantissa3:
>0070								.fill 	MathStackSize
.0078						NSExponent:
>0078								.fill 	MathStackSize
.0400						identStart:
>0400								.fill 	1
.0401						identTypeStart:
>0401								.fill 	1
.0402						identTypeEnd:
>0402								.fill 	1
.0403						identHash:
>0403								.fill 	1
.0404						identTypeByte:
>0404								.fill 	1	 						; (see tokenising.pdf)
.0405						encodeState:
>0405								.fill 	1
.0406						digitTemp:
>0406								.fill 	1
.0407						decimalCount:
>0407								.fill 	1
.0408						randomSeed:
>0408								.fill 	4
.040c						lowMemPtr:
>040c								.fill 	2
.040e						stringMemory:
>040e								.fill 	2
.0410						stringInitialised:
>0410								.fill 	1
.0411						stringTempPointer:
>0411								.fill 	2
.0413						breakCheck:
>0413								.fill 	1
.0414						decimalPlaces:
>0414								.fill 	1
.0415						dbOffset:
>0415								.fill 	1
.0416						lastParameter:
>0416								.fill 	1
.0417						dataPointer:
>0417								.fill 	5
.041c						inDataStatement:
>041c								.fill 	1
.041d						tbOffset:
>041d								.fill 	1
.041e						AssemblerAddress:
>041e								.fill 	2
.0420						AssemblerControl:
>0420								.fill 	1
.0421						ParamStart:
>0421								.fill 	2
.0423						IsGroup1:
>0423								.fill 	1
.0424						BaseOpcode:
>0424								.fill 	1
.0425						ModeMask:
>0425								.fill 	1
.0426						listIndent:
>0426								.fill 	1
.0427						lcLastCharacter:
>0427								.fill 	1
.0428						isInputFlag:
>0428								.fill 	1
.0429						currentListColour:
>0429								.fill 	1
.042a						tokenOffset:
>042a								.fill 	1
.042b						tokenLineNumber:
>042b								.fill 	2
.042d						tokenBuffer:
>042d								.fill 	253
.052a						lineBuffer:
>052a								.fill 	253
.0627						numberBuffer:
>0627								.fill 	34
.0649						decimalBuffer:
>0649								.fill 	16

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/constants.inc

=$80						AM_ISZP = $80
=$40						AM_ISG1 = $40
=$20						AM_ISG2 = $20
=224						AM_IMMEDIATE = AM_ISZP+AM_ISG1+AM_ISG2+$00
=228						AM_ZEROPAGE = AM_ISZP+AM_ISG1+AM_ISG2+$04
=40						AM_ACC = AM_ISG2+$08
=108						AM_ABS = AM_ISG1+AM_ISG2+$0C
=208						AM_INDY = AM_ISZP+AM_ISG1+$10
=244						AM_ZEROX = AM_ISZP+AM_ISG1+AM_ISG2+$14
=120						AM_ABSY = AM_ISG1+AM_ISG2+$18
=124						AM_ABSX = AM_ISG1+AM_ISG2+$1C
=209						AM_IND = AM_ISZP+AM_ISG1+$11
=$80						AM_ZEROY = AM_ISZP
=$01						AM_INDABS = $01
=$02						AM_INDABSX = $02
=192						AM_INDX = AM_ISZP+AM_ISG1+$00

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/handlers.inc


;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.inc

=1						ERRID_BREAK = 1
=2						ERRID_SYNTAX = 2
=3						ERRID_DIVZERO = 3
=4						ERRID_RANGE = 4
=5						ERRID_TYPE = 5
=6						ERRID_MEMORY = 6
=7						ERRID_ARGUMENT = 7
=8						ERRID_STOP = 8
=9						ERRID_STRING = 9
=10						ERRID_ASSERT = 10
=11						ERRID_DATA = 11
=12						ERRID_NOTDONE = 12
=13						ERRID_LINE = 13
=14						ERRID_GOSUB = 14
=15						ERRID_REPEAT = 15
=16						ERRID_WHILE = 16
=17						ERRID_FOR = 17
=18						ERRID_STACK = 18
=19						ERRID_STRUCT = 19
=20						ERRID_PROC = 20
=21						ERRID_REDEFINE = 21
=22						ERRID_ARRAYSIZE = 22
=23						ERRID_ARRAYIDX = 23
=24						ERRID_ARRAYDEC = 24

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst.inc

=$00						KWD_LESSLESS                         = $00; $00 <<
=$01						KWD_LESSEQUAL                        = $01; $01 <=
=$02						KWD_LESSGREATER                      = $02; $02 <>
=$03						KWD_PLINGPLING3                      = $03; $03 !!3
=$04						KWD_GREATERLESS                      = $04; $04 ><
=$05						KWD_GREATEREQUAL                     = $05; $05 >=
=$06						KWD_GREATERGREATER                   = $06; $06 >>
=$07						KWD_PLINGPLING7                      = $07; $07 !!7
=$08						KWD_PLINGPLING8                      = $08; $08 !!8
=$09						KWD_PLINGPLING9                      = $09; $09 !!9
=$0a						KWD_PLINGPLING10                     = $0a; $0a !!10
=$0b						KWD_PLINGPLING11                     = $0b; $0b !!11
=$0c						KWD_PLINGPLING12                     = $0c; $0c !!12
=$0d						KWD_PLINGPLING13                     = $0d; $0d !!13
=$0e						KWD_PLINGPLING14                     = $0e; $0e !!14
=$0f						KWD_PLINGPLING15                     = $0f; $0f !!15
=$10						KWD_AT                               = $10; $10 @
=$11						KWD_PLINGPLING17                     = $11; $11 !!17
=$12						KWD_PLINGPLING18                     = $12; $12 !!18
=$13						KWD_LSQPAREN                         = $13; $13 [
=$14						KWD_BACKSLASH                        = $14; $14 \
=$15						KWD_RSQPAREN                         = $15; $15 ]
=$16						KWD_HAT                              = $16; $16 ^
=$17						KWD_UNDERSCORE                       = $17; $17 _
=$18						KWD_BQUOTE                           = $18; $18 `
=$19						KWD_PLINGPLING25                     = $19; $19 !!25
=$1a						KWD_PLINGPLING26                     = $1a; $1a !!26
=$1b						KWD_LCURLY                           = $1b; $1b {
=$1c						KWD_BAR                              = $1c; $1c |
=$1d						KWD_RCURLY                           = $1d; $1d }
=$1e						KWD_TILDE                            = $1e; $1e ~
=$21						KWD_PLING                            = $21; $21 !
=$22						KWD_DQUOTE                           = $22; $22 "
=$23						KWD_HASH                             = $23; $23 #
=$24						KWD_DOLLAR                           = $24; $24 $
=$25						KWD_PERCENT                          = $25; $25 %
=$26						KWD_AMPERSAND                        = $26; $26 &
=$27						KWD_QUOTE                            = $27; $27 '
=$28						KWD_LPAREN                           = $28; $28 (
=$29						KWD_RPAREN                           = $29; $29 )
=$2a						KWD_STAR                             = $2a; $2a *
=$2b						KWD_PLUS                             = $2b; $2b +
=$2c						KWD_COMMA                            = $2c; $2c ,
=$2d						KWD_MINUS                            = $2d; $2d -
=$2e						KWD_PERIOD                           = $2e; $2e .
=$2f						KWD_SLASH                            = $2f; $2f /
=$30						KWD_0                                = $30; $30 0
=$31						KWD_1                                = $31; $31 1
=$32						KWD_2                                = $32; $32 2
=$33						KWD_3                                = $33; $33 3
=$34						KWD_4                                = $34; $34 4
=$35						KWD_5                                = $35; $35 5
=$36						KWD_6                                = $36; $36 6
=$37						KWD_7                                = $37; $37 7
=$38						KWD_8                                = $38; $38 8
=$39						KWD_9                                = $39; $39 9
=$3a						KWD_COLON                            = $3a; $3a :
=$3b						KWD_SEMICOLON                        = $3b; $3b ;
=$3c						KWD_LESS                             = $3c; $3c <
=$3d						KWD_EQUAL                            = $3d; $3d =
=$3e						KWD_GREATER                          = $3e; $3e >
=$3f						KWD_QMARK                            = $3f; $3f ?
=$83						KWD_ABSLPAREN                        = $83; $83 ABS(
=$84						KWD_ALLOCLPAREN                      = $84; $84 ALLOC(
=$85						KWD_ASCLPAREN                        = $85; $85 ASC(
=$86						KWD_CHRDOLLARLPAREN                  = $86; $86 CHR$(
=$87						KWD_DEEKLPAREN                       = $87; $87 DEEK(
=$88						KWD_EVENTLPAREN                      = $88; $88 EVENT(
=$89						KWD_FALSE                            = $89; $89 FALSE
=$8a						KWD_FRACLPAREN                       = $8a; $8a FRAC(
=$8b						KWD_HITLPAREN                        = $8b; $8b HIT(
=$8c						KWD_INTLPAREN                        = $8c; $8c INT(
=$8d						KWD_ISVALLPAREN                      = $8d; $8d ISVAL(
=$8e						KWD_JOYBLPAREN                       = $8e; $8e JOYB(
=$8f						KWD_JOYXLPAREN                       = $8f; $8f JOYX(
=$90						KWD_JOYYLPAREN                       = $90; $90 JOYY(
=$91						KWD_LEFTDOLLARLPAREN                 = $91; $91 LEFT$(
=$92						KWD_LENLPAREN                        = $92; $92 LEN(
=$93						KWD_MAXLPAREN                        = $93; $93 MAX(
=$94						KWD_MIDDOLLARLPAREN                  = $94; $94 MID$(
=$95						KWD_MINLPAREN                        = $95; $95 MIN(
=$96						KWD_NOTLPAREN                        = $96; $96 NOT(
=$97						KWD_PEEKLPAREN                       = $97; $97 PEEK(
=$98						KWD_PLAYINGLPAREN                    = $98; $98 PLAYING(
=$99						KWD_RANDOMLPAREN                     = $99; $99 RANDOM(
=$9a						KWD_RIGHTDOLLARLPAREN                = $9a; $9a RIGHT$(
=$9b						KWD_RNDLPAREN                        = $9b; $9b RND(
=$9c						KWD_SGNLPAREN                        = $9c; $9c SGN(
=$9d						KWD_SPCLPAREN                        = $9d; $9d SPC(
=$9e						KWD_STRDOLLARLPAREN                  = $9e; $9e STR$(
=$9f						KWD_TIMERLPAREN                      = $9f; $9f TIMER(
=$a0						KWD_TRUE                             = $a0; $a0 TRUE
=$a1						KWD_VALLPAREN                        = $a1; $a1 VAL(
=$a2						KWD_FOR                              = $a2; $a2 FOR
=$a3						KWD_IF                               = $a3; $a3 IF
=$a4						KWD_PROC                             = $a4; $a4 PROC
=$a5						KWD_REPEAT                           = $a5; $a5 REPEAT
=$a6						KWD_WHILE                            = $a6; $a6 WHILE
=$a7						KWD_ENDIF                            = $a7; $a7 ENDIF
=$a8						KWD_ENDPROC                          = $a8; $a8 ENDPROC
=$a9						KWD_NEXT                             = $a9; $a9 NEXT
=$aa						KWD_THEN                             = $aa; $aa THEN
=$ab						KWD_UNTIL                            = $ab; $ab UNTIL
=$ac						KWD_WEND                             = $ac; $ac WEND
=$ad						KWD_BY                               = $ad; $ad BY
=$ae						KWD_CALL                             = $ae; $ae CALL
=$af						KWD_CIRCLE                           = $af; $af CIRCLE
=$b0						KWD_CLEAR                            = $b0; $b0 CLEAR
=$b1						KWD_CLS                              = $b1; $b1 CLS
=$b2						KWD_COLOR                            = $b2; $b2 COLOR
=$b3						KWD_COLOUR                           = $b3; $b3 COLOUR
=$b4						KWD_DATA                             = $b4; $b4 DATA
=$b5						KWD_DIM                              = $b5; $b5 DIM
=$b6						KWD_DOKE                             = $b6; $b6 DOKE
=$b7						KWD_DOWNTO                           = $b7; $b7 DOWNTO
=$b8						KWD_ELSE                             = $b8; $b8 ELSE
=$b9						KWD_FROM                             = $b9; $b9 FROM
=$ba						KWD_GFX                              = $ba; $ba GFX
=$bb						KWD_GOSUB                            = $bb; $bb GOSUB
=$bc						KWD_GOTO                             = $bc; $bc GOTO
=$bd						KWD_HERE                             = $bd; $bd HERE
=$be						KWD_IMAGE                            = $be; $be IMAGE
=$bf						KWD_INPUT                            = $bf; $bf INPUT
=$c0						KWD_LET                              = $c0; $c0 LET
=$c1						KWD_LINE                             = $c1; $c1 LINE
=$c2						KWD_LOCAL                            = $c2; $c2 LOCAL
=$c3						KWD_OFF                              = $c3; $c3 OFF
=$c4						KWD_ON                               = $c4; $c4 ON
=$c5						KWD_OUTLINE                          = $c5; $c5 OUTLINE
=$c6						KWD_PALETTE                          = $c6; $c6 PALETTE
=$c7						KWD_PLOT                             = $c7; $c7 PLOT
=$c8						KWD_POKE                             = $c8; $c8 POKE
=$c9						KWD_PRINT                            = $c9; $c9 PRINT
=$ca						KWD_READ                             = $ca; $ca READ
=$cb						KWD_RECT                             = $cb; $cb RECT
=$cc						KWD_REM                              = $cc; $cc REM
=$cd						KWD_RETURN                           = $cd; $cd RETURN
=$ce						KWD_SOLID                            = $ce; $ce SOLID
=$cf						KWD_SOUND                            = $cf; $cf SOUND
=$d0						KWD_SPRITE                           = $d0; $d0 SPRITE
=$d1						KWD_TEXT                             = $d1; $d1 TEXT
=$d2						KWD_TO                               = $d2; $d2 TO

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst0.inc

=$80						KWC_EOL = $80
=$ff						KWC_STRING = $FF
=$fe						KWC_HEXCONST = $FE
=$a2						KWC_FIRST_STRUCTURE = $a2
=$a7						KWC_FIRST_STRUCTURE_DEC = $a7
=$ac						KWC_LAST_STRUCTURE = $ac
=$83						KWC_FIRST_UNARY = $83
=$a1						KWC_LAST_UNARY = $a1

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/access.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/stack.inc

=$e0						STK_GOSUB = $E0
=$d0						STK_FOR = $D0
=$c0						STK_REPEAT = $C0
=$b0						STK_PROC = $B0
=$a0						STK_WHILE = $A0
=$01						STK_LOCALN = $01
=$02						STK_LOCALS = $02

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/00start.asm

.8000		4c 71 80	jmp $8071	Boot:	jmp 	Start

;******  Processing file: ./common/aa.system/../../../modules/_build/_linker.module

=1						PagingEnabled = 1
.8003						EXTPrintCharacter:
.8003		e6 0d		inc $0d			inc 8+5
.8005		20 00 a0	jsr $a000		jsr	Export_EXTPrintCharacter
.8008		08		php			php
.8009		c6 0d		dec $0d			dec 8+5
.800b		28		plp			plp
.800c		60		rts			rts
.800d						EXTInitialise:
.800d		e6 0d		inc $0d			inc 8+5
.800f		20 99 a2	jsr $a299		jsr	Export_EXTInitialise
.8012		08		php			php
.8013		c6 0d		dec $0d			dec 8+5
.8015		28		plp			plp
.8016		60		rts			rts
.8017						EXTInputSingleCharacter:
.8017		e6 0d		inc $0d			inc 8+5
.8019		20 cf a2	jsr $a2cf		jsr	Export_EXTInputSingleCharacter
.801c		08		php			php
.801d		c6 0d		dec $0d			dec 8+5
.801f		28		plp			plp
.8020		60		rts			rts
.8021						EXTBreakCheck:
.8021		e6 0d		inc $0d			inc 8+5
.8023		20 f5 a2	jsr $a2f5		jsr	Export_EXTBreakCheck
.8026		08		php			php
.8027		c6 0d		dec $0d			dec 8+5
.8029		28		plp			plp
.802a		60		rts			rts
.802b						EXTReadController:
.802b		e6 0d		inc $0d			inc 8+5
.802d		20 f8 a2	jsr $a2f8		jsr	Export_EXTReadController
.8030		08		php			php
.8031		c6 0d		dec $0d			dec 8+5
.8033		28		plp			plp
.8034		60		rts			rts
.8035						EXTInputLine:
.8035		e6 0d		inc $0d			inc 8+5
.8037		20 af a1	jsr $a1af		jsr	Export_EXTInputLine
.803a		08		php			php
.803b		c6 0d		dec $0d			dec 8+5
.803d		28		plp			plp
.803e		60		rts			rts
.803f						GXGraphicDraw:
.803f		e6 0d		inc $0d			inc 8+5
.8041		20 93 a3	jsr $a393		jsr	Export_GXGraphicDraw
.8044		08		php			php
.8045		c6 0d		dec $0d			dec 8+5
.8047		28		plp			plp
.8048		60		rts			rts
.8049						SNDCommand:
.8049		e6 0d		inc $0d			inc 8+5
.804b		20 78 b6	jsr $b678		jsr	Export_SNDCommand
.804e		08		php			php
.804f		c6 0d		dec $0d			dec 8+5
.8051		28		plp			plp
.8052		60		rts			rts
.8053						SNDUpdate:
.8053		e6 0d		inc $0d			inc 8+5
.8055		20 ab b6	jsr $b6ab		jsr	Export_SNDUpdate
.8058		08		php			php
.8059		c6 0d		dec $0d			dec 8+5
.805b		28		plp			plp
.805c		60		rts			rts
.805d						TKListConvertLine:
.805d		e6 0d		inc $0d			inc 8+5
.805f		20 6e b0	jsr $b06e		jsr	Export_TKListConvertLine
.8062		08		php			php
.8063		c6 0d		dec $0d			dec 8+5
.8065		28		plp			plp
.8066		60		rts			rts
.8067						TKTokeniseLine:
.8067		e6 0d		inc $0d			inc 8+5
.8069		20 02 b3	jsr $b302		jsr	Export_TKTokeniseLine
.806c		08		php			php
.806d		c6 0d		dec $0d			dec 8+5
.806f		28		plp			plp
.8070		60		rts			rts

;******  Return to file: ./common/aa.system/00start.asm

.8071		a2 ff		ldx #$ff	Start:	ldx 	#$FF 						; stack reset
.8073		9a		txs				txs
.8074		a5 00		lda $00				lda 	0  							; turn on editing of MMU LUT
.8076		09 80		ora #$80			ora 	#$80
.8078		85 00		sta $00				sta 	0
.807a		20 0d 80	jsr $800d			jsr 	EXTInitialise 				; hardware initialise
.807d		a9 00		lda #$00			lda 	#0 							; graphics system initialise.
.807f		aa		tax				tax
.8080		a8		tay				tay
.8081		20 3f 80	jsr $803f			jsr 	GXGraphicDraw
.8084		a9 0f		lda #$0f			lda 	#$0F 						; initialise sound system
.8086		20 49 80	jsr $8049			jsr 	SNDCommand
.8089		a2 80		ldx #$80			ldx 	#Prompt >> 8 				; display prompt
.808b		a9 99		lda #$99			lda 	#Prompt & $FF
.808d		20 a2 8f	jsr $8fa2			jsr 	PrintStringXA
.8090		20 7e 8a	jsr $8a7e			jsr 	NewProgram 					; erase current program
.8093		4c 27 84	jmp $8427			jmp 	WarmStart					; make same size.
.8096		4c 27 84	jmp $8427			jmp 	WarmStart
>8099		36 35 30 32 20 53 75 70		Prompt:	.text 	"6502 SuperBASIC ("
>80a1		65 72 42 41 53 49 43 20 28
>80aa		32 34						.text 	"24"
>80ac		6b 29 0d					.text 	"k)",13
>80af		43 6f 70 79 72 69 67 68				.text 	"Copyright 2022 Paul Robson",13
>80b7		74 20 32 30 32 32 20 50 61 75 6c 20 52 6f 62 73
>80c7		6f 6e 0d
>80ca		50 61 75 6c 40 52 6f 62				.text  	"Paul@Robsons.org.uk",13
>80d2		73 6f 6e 73 2e 6f 72 67 2e 75 6b 0d
>80de		46 32 35 36 20					.text "F256 "

;******  Processing file: ./common/aa.system/../generated/timestamp.asm

>80e3		41 6c 70 68 61 20 31 35			.text "Alpha 15 built 12-Dec-22. "
>80eb		20 62 75 69 6c 74 20 31 32 2d 44 65 63 2d 32 32
>80fb		2e 20

;******  Return to file: ./common/aa.system/00start.asm

>80fd		0d						.byte  	13
>80fe		0d 0d 00					.text 	13,13,0

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/assembler.asm

.8101						AssembleGroup1:
.8101		a9 ff		lda #$ff			lda 	#$FF 						; flag for group 1 / mask.
.8103		8d 25 04	sta $0425			sta 	ModeMask 					; initialise the mode mask - all for all
.8106		80 02		bra $810a			bra 	AsmGroup12
.8108						AssembleGroup2:
.8108		a9 00		lda #$00			lda 	#$00 						; flag for group 2
.810a						AsmGroup12:
.810a		8d 23 04	sta $0423			sta 	IsGroup1 					; save the 'group 1' flag
.810d		68		pla				pla 								; pop the return address to access the information following.
.810e		fa		plx				plx
.810f		20 96 81	jsr $8196			jsr 	AccessParameters 			; get opcode and save as base
.8112		8d 24 04	sta $0424			sta 	BaseOpcode
.8115		ad 23 04	lda $0423			lda 	IsGroup1 					; skip if group 1 as we don't have a complex mask.
.8118		d0 08		bne $8122			bne 	_AG12HaveMask
.811a		a9 02		lda #$02			lda 	#2 							; if group 2 the second parameter is the mask
.811c		20 9e 81	jsr $819e			jsr 	GetParameter		 		; e.g. which modes are supported for this operand
.811f		8d 25 04	sta $0425			sta 	ModeMask
.8122						_AG12HaveMask:
.8122		20 d2 82	jsr $82d2			jsr 	TypeAndCalculateOperand 	; get zero page type
.8125		da		phx				phx 								; save found address mode
.8126		20 02 82	jsr $8202			jsr 	AssembleModeX
.8129		fa		plx				plx  								; restore address mode
.812a		b0 0b		bcs $8137			bcs 	_AG12Exit
.812c		20 38 81	jsr $8138			jsr 	PromoteToAbsolute  			; promote ZP to ABS and try that
.812f		20 02 82	jsr $8202			jsr 	AssembleModeX
.8132		b0 03		bcs $8137			bcs 	_AG12Exit
.8134		4c ee 9f	jmp $9fee			jmp 	SyntaxError 				; can't do either, so must be wrong mode/operand.
.8137						_AG12Exit:
.8137		60		rts				rts
.8138						PromoteToAbsolute:
.8138		a9 6c		lda #$6c			lda 	#AM_ABS 					; lda xx
.813a		e0 e4		cpx #$e4			cpx 	#AM_ZEROPAGE
.813c		f0 19		beq $8157			beq 	_PTADo
.813e		a9 7c		lda #$7c			lda 	#AM_ABSX 					; lda xx,X
.8140		e0 f4		cpx #$f4			cpx 	#AM_ZEROX
.8142		f0 13		beq $8157			beq 	_PTADo
.8144		a9 78		lda #$78			lda 	#AM_ABSY 					; lda xx,Y
.8146		e0 80		cpx #$80			cpx 	#AM_ZEROY
.8148		f0 0d		beq $8157			beq 	_PTADo
.814a		a9 01		lda #$01			lda 	#AM_INDABS 					; lda (xx) (jump)
.814c		e0 d1		cpx #$d1			cpx 	#AM_IND
.814e		f0 07		beq $8157			beq 	_PTADo
.8150		a9 02		lda #$02			lda 	#AM_INDABSX 				; lda (xx,x) (jump)
.8152		e0 c0		cpx #$c0			cpx 	#AM_INDX
.8154		f0 01		beq $8157			beq 	_PTADo
.8156		60		rts				rts
.8157						_PTADo:
.8157		aa		tax				tax
.8158		60		rts				rts
.8159						AssembleGroup3:
.8159		68		pla				pla 								; get parameters, which is just the opcode.
.815a		fa		plx				plx
.815b		20 96 81	jsr $8196			jsr 	AccessParameters 			; get and output opcode
.815e		20 ae 81	jsr $81ae			jsr 	AssemblerWriteByte
.8161		20 36 83	jsr $8336			jsr 	CalculateOperand 			; get a 16 bit operand
.8164		a5 58		lda $58				lda 	NSMantissa0 				; calculate the offset
.8166		38		sec				sec
.8167		ed 1e 04	sbc $041e			sbc 	AssemblerAddress
.816a		48		pha				pha 								; LSB in A
.816b		a5 60		lda $60				lda 	NSMantissa1
.816d		ed 1f 04	sbc $041f			sbc 	AssemblerAddress+1
.8170		aa		tax				tax 								; MSB in X
.8171		68		pla				pla
.8172		18		clc				clc 								; $80 to easy check $80-$7F, plus 1 for offset error
.8173		69 7f		adc #$7f			adc 	#$7F
.8175		90 01		bcc $8178			bcc 	_AG3NoCarry
.8177		e8		inx				inx
.8178						_AG3NoCarry:
.8178		38		sec				sec 								; fix back and write out anyways.
.8179		e9 80		sbc #$80			sbc 	#$80
.817b		20 ae 81	jsr $81ae			jsr 	AssemblerWriteByte
.817e		e0 00		cpx #$00			cpx 	#0 							; was it in range
.8180		f0 0a		beq $818c			beq 	_AG3Exit
.8182		ad 20 04	lda $0420			lda 	AssemblerControl 			; are we allowing bad values ?
.8185		29 01		and #$01			and 	#1
.8187		f0 03		beq $818c			beq 	_AG3Exit
.8189		4c f3 9f	jmp $9ff3			jmp 	RangeError 					; no, branch is out of range
.818c						_AG3Exit:
.818c		60		rts				rts
.818d						AssembleGroup4:
.818d		68		pla				pla 								; pop address
.818e		fa		plx				plx
.818f		20 96 81	jsr $8196			jsr 	AccessParameters 			; access and get first
.8192		20 ae 81	jsr $81ae			jsr 	AssemblerWriteByte 			; output it.
.8195		60		rts				rts
.8196						AccessParameters:
.8196		8d 21 04	sta $0421			sta 	ParamStart
.8199		8e 22 04	stx $0422			stx 	ParamStart+1
.819c		a9 01		lda #$01			lda 	#1
.819e						GetParameter:
.819e		5a		phy				phy
.819f		a8		tay				tay
.81a0		ad 21 04	lda $0421			lda 	ParamStart
.81a3		85 36		sta $36				sta 	zTemp0
.81a5		ad 22 04	lda $0422			lda 	ParamStart+1
.81a8		85 37		sta $37				sta 	zTemp0+1
.81aa		b1 36		lda ($36),y			lda 	(zTemp0),y
.81ac		7a		ply				ply
.81ad		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/aswrite.asm

.81ae						AssemblerWriteByte:
.81ae		48		pha			pha
.81af		ad 20 04	lda $0420		lda 	AssemblerControl 				; check printing bytes ?
.81b2		29 02		and #$02		and 	#2
.81b4		f0 1b		beq $81d1		beq 	_AWBNoPrint
.81b6		ad 1f 04	lda $041f		lda		AssemblerAddress+1 				; print address
.81b9		20 ec 81	jsr $81ec		jsr 	PrintHex
.81bc		ad 1e 04	lda $041e		lda		AssemblerAddress
.81bf		20 ec 81	jsr $81ec		jsr 	PrintHex
.81c2		a9 20		lda #$20		lda 	#' '
.81c4		20 03 80	jsr $8003		jsr 	EXTPrintCharacter
.81c7		68		pla			pla 									; print byte
.81c8		48		pha			pha
.81c9		20 ec 81	jsr $81ec		jsr 	PrintHex
.81cc		a9 0d		lda #$0d		lda 	#13
.81ce		20 03 80	jsr $8003		jsr 	EXTPrintCharacter
.81d1						_AWBNoPrint:
.81d1		ad 1e 04	lda $041e		lda		AssemblerAddress				; copy address to zTemp0
.81d4		85 36		sta $36			sta 	zTemp0
.81d6		ad 1f 04	lda $041f		lda		AssemblerAddress+1
.81d9		f0 0e		beq $81e9		beq 	_AWBRange
.81db		85 37		sta $37			sta 	zTemp0+1
.81dd		68		pla			pla 									; write byte out
.81de		92 36		sta ($36)		sta 	(zTemp0)
.81e0		ee 1e 04	inc $041e		inc 	AssemblerAddress 				; bump address
.81e3		d0 03		bne $81e8		bne 	_AWBNoCarry
.81e5		ee 1f 04	inc $041f		inc 	AssemblerAddress+1
.81e8						_AWBNoCarry:
.81e8		60		rts			rts
.81e9						_AWBRange:
.81e9		4c f3 9f	jmp $9ff3		jmp 	RangeError
.81ec						PrintHex:
.81ec		48		pha				pha
.81ed		4a		lsr a				lsr 	a
.81ee		4a		lsr a				lsr 	a
.81ef		4a		lsr a				lsr 	a
.81f0		4a		lsr a				lsr 	a
.81f1		20 f5 81	jsr $81f5			jsr 	_PrintNibble
.81f4		68		pla				pla
.81f5						_PrintNibble:
.81f5		29 0f		and #$0f			and 	#15
.81f7		c9 0a		cmp #$0a			cmp 	#10
.81f9		90 02		bcc $81fd			bcc 	_NoShift
.81fb		69 06		adc #$06			adc 	#6
.81fd						_NoShift:
.81fd		69 30		adc #$30			adc 	#48
.81ff		4c 03 80	jmp $8003			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/instruction.asm

.8202						AssembleModeX:
.8202		5a		phy				phy
.8203		ad 23 04	lda $0423			lda 	IsGroup1
.8206		f0 17		beq $821f			beq 	_AMXGroup2
.8208		8a		txa				txa 							; is it in group # 1
.8209		29 40		and #$40			and 	#AM_ISG1
.820b		f0 4d		beq $825a			beq 	_AMXFail 				; no, give up.
.820d		8a		txa				txa 							; get back.
.820e		29 1f		and #$1f			and 	#$1F 					; this is now the offset.
.8210		e0 e0		cpx #$e0			cpx 	#AM_IMMEDIATE 			; if not immediate, we can continue.
.8212		d0 22		bne $8236			bne 	_AMXHaveInfo
.8214		ad 24 04	lda $0424			lda 	BaseOpcode 				; cannot store immediate.
.8217		c9 81		cmp #$81			cmp 	#$81
.8219		f0 3f		beq $825a			beq 	_AMXFail
.821b		a9 08		lda #$08			lda 	#8 						; if immediate we use offset 8.
.821d		80 17		bra $8236			bra 	_AMXHaveInfo 			; odd design decision there.
.821f						_AMXGroup2:
.821f		8a		txa				txa 							; is it in group 2 ?
.8220		29 20		and #$20			and 	#AM_ISG2
.8222		f0 36		beq $825a			beq 	_AMXFail 				; no, give up.
.8224		8a		txa				txa 							; get the offset into Y
.8225		29 1f		and #$1f			and 	#$1F
.8227		4a		lsr a				lsr 	a 						; make it 0-7.
.8228		4a		lsr a				lsr  	a
.8229		a8		tay				tay
.822a		ad 25 04	lda $0425			lda 	ModeMask 				; shift the modemask left so you can check it against the requested offset
.822d						_AMXCheckOkay:
.822d		0a		asl a				asl 	a 						; shift modemask left enough times to check legitimate.
.822e		88		dey				dey
.822f		10 fc		bpl $822d			bpl 	_AMXCheckOkay
.8231		90 27		bcc $825a			bcc 	_AMXFail 				; not allowed.
.8233		8a		txa				txa  							; get mask back
.8234		29 1f		and #$1f			and 	#$1F
.8236						_AMXHaveInfo:
.8236		e0 00		cpx #$00			cpx 	#$00 					; does it *require* an 8 bit operand
.8238		10 04		bpl $823e			bpl 	_AMXAnySize 			; checking bit 7, the zero page opcode flag.
.823a		a4 60		ldy $60				ldy 	NSMantissa1 			; fail if it is outside range, e.g. the MSB is set.
.823c		d0 1c		bne $825a			bne 	_AMXFail
.823e						_AMXAnySize:
.823e		18		clc				clc 							; add offset to the base opcode
.823f		6d 24 04	adc $0424			adc 	BaseOpcode
.8242						_AMXOutputCode:
.8242		20 ae 81	jsr $81ae			jsr 	AssemblerWriteByte 		; write the opcode out.
.8245		e0 28		cpx #$28			cpx 	#AM_ACC 				; A mode (e.g. ASL)
.8247		f0 0e		beq $8257			beq 	_AMXExit
.8249		a5 58		lda $58				lda 	NSMantissa0 			; write LSB operand
.824b		20 ae 81	jsr $81ae			jsr 	AssemblerWriteByte
.824e		e0 00		cpx #$00			cpx 	#$00 					; zeropage ?
.8250		30 05		bmi $8257			bmi 	_AMXExit
.8252		a5 60		lda $60				lda 	NSMantissa1 			; write MSB operand
.8254		20 ae 81	jsr $81ae			jsr 	AssemblerWriteByte
.8257						_AMXExit:
.8257		7a		ply				ply
.8258		38		sec				sec
.8259		60		rts				rts
.825a						_AMXFail:
.825a		a0 00		ldy #$00			ldy 	#0
.825c						_AMXCheckOddities:
.825c		8a		txa				txa
.825d		d9 84 82	cmp $8284,y			cmp 	ExtraOpcode+2,y 		; match address mode
.8260		d0 15		bne $8277			bne 	_AMXCONext
.8262		b9 82 82	lda $8282,y			lda 	ExtraOpcode+0,y 		; do the base opcodes match
.8265		cd 24 04	cmp $0424			cmp 	BaseOpcode
.8268		d0 0d		bne $8277			bne 	_AMXCONext
.826a		e0 00		cpx #$00			cpx 	#$00 					; requires zero page ?
.826c		10 04		bpl $8272			bpl 	_AMXCONotZero
.826e		a5 60		lda $60				lda 	NSMantissa1
.8270		d0 05		bne $8277			bne 	_AMXCONext
.8272						_AMXCONotZero:
.8272		b9 83 82	lda $8283,y			lda 	ExtraOpcode+1,y 		; get new opcode
.8275		80 cb		bra $8242			bra 	_AMXOutputCode 			; and assemble it
.8277						_AMXCONext:
.8277		c8		iny				iny
.8278		c8		iny				iny
.8279		c8		iny				iny
.827a		b9 82 82	lda $8282,y			lda 	ExtraOpcode+0,y 		; end of table
.827d		d0 dd		bne $825c			bne 	_AMXCheckOddities
.827f						_AMXCOFail:
.827f		7a		ply				ply
.8280		18		clc				clc
.8281		60		rts				rts
.8282						ExtraOpcode:
>8282		40 6c 01					.byte $40,$6c,AM_INDABS 	; jump
>8285		40 7c 02					.byte $40,$7C,AM_INDABSX 	; jump
>8288		a2 be 78					.byte $a2,$BE,AM_ABSY 		; ldx
>828b		a2 b6 80					.byte $a2,$B6,AM_ZEROY 		; ldx
>828e		82 96 80					.byte $82,$96,AM_ZEROY 		; stx
>8291		e2 1a 28					.byte $e2,$1a,AM_ACC 		; inc
>8294		c2 3a 28					.byte $c2,$3a,AM_ACC 		; dec
>8297		20 89 e0					.byte $20,$89,AM_IMMEDIATE 	; bit
>829a		60 9c 6c					.byte $60,$9c,AM_ABS 		; stz
>829d		60 9e 7c					.byte $60,$9e,AM_ABSX 		; stz
>82a0		00						.byte $00

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/label.asm

.82a1						LabelHere:
.82a1		c8		iny				iny 								; skip .
.82a2		a2 00		ldx #$00			ldx 	#0 							; get a term
.82a4		20 97 98	jsr $9897			jsr 	EvaluateTerm
.82a7		a5 50		lda $50				lda 	NSStatus 					; needs to be an integer reference.
.82a9		c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.82ab		d0 22		bne $82cf			bne 	_ALType 					; otherwise typing error
.82ad		b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy reference address to zTemp0
.82af		85 36		sta $36				sta 	zTemp0 						; (e.g. where we store the address)
.82b1		b5 60		lda $60,x			lda 	NSMantissa1,x
.82b3		85 37		sta $37				sta 	zTemp0+1
.82b5		5a		phy				phy 								; copy address in (64k)
.82b6		a0 01		ldy #$01			ldy 	#1
.82b8		ad 1e 04	lda $041e			lda	 	AssemblerAddress
.82bb		92 36		sta ($36)			sta 	(zTemp0)
.82bd		ad 1f 04	lda $041f			lda	 	AssemblerAddress+1
.82c0		91 36		sta ($36),y			sta 	(zTemp0),y
.82c2		c8		iny				iny
.82c3		a9 00		lda #$00			lda 	#0 							; zero the rest.
.82c5		91 36		sta ($36),y			sta 	(zTemp0),y
.82c7		c8		iny				iny
.82c8		91 36		sta ($36),y			sta 	(zTemp0),y
.82ca		c8		iny				iny
.82cb		91 36		sta ($36),y			sta 	(zTemp0),y
.82cd		7a		ply				ply
.82ce		60		rts				rts
.82cf						_ALType:
.82cf		4c f8 9f	jmp $9ff8			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/operands.asm

.82d2						TypeAndCalculateOperand:
.82d2		b1 30		lda ($30),y			lda 	(codePtr),y
.82d4		a2 28		ldx #$28			ldx 	#AM_ACC 					; ACC if : or EOL
.82d6		c9 3a		cmp #$3a			cmp 	#KWD_COLON
.82d8		f0 5b		beq $8335			beq 	_TACOExit
.82da		c9 80		cmp #$80			cmp 	#KWC_EOL
.82dc		f0 57		beq $8335			beq 	_TACOExit
.82de		c8		iny				iny
.82df		a2 e0		ldx #$e0			ldx 	#AM_IMMEDIATE
.82e1		c9 23		cmp #$23			cmp 	#KWD_HASH 					; if hash, then immediate - constant.
.82e3		f0 51		beq $8336			beq 	CalculateOperand
.82e5		c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; if ( then check for indirection
.82e7		f0 1f		beq $8308			beq 	_TACOIndirect
.82e9		88		dey				dey 								; undo get of first character
.82ea		20 36 83	jsr $8336			jsr 	CalculateOperand 			; get operand
.82ed		b1 30		lda ($30),y			lda 	(codePtr),y
.82ef		a2 e4		ldx #$e4			ldx 	#AM_ZEROPAGE 				; if not, try zero page (then absolute)
.82f1		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.82f3		d0 40		bne $8335			bne 	_TACOExit
.82f5		c8		iny				iny
.82f6		20 40 83	jsr $8340			jsr 	TACOCheckXY 				; extract X,Y or 0 (neither) from the variable.
.82f9		a2 f4		ldx #$f4			ldx 	#AM_ZEROX 					; check for X
.82fb		c9 58		cmp #$58			cmp 	#'X'
.82fd		f0 36		beq $8335			beq 	_TACOExit
.82ff		a2 80		ldx #$80			ldx 	#AM_ZEROY 					; check for Y
.8301		c9 59		cmp #$59			cmp 	#'Y'
.8303		f0 30		beq $8335			beq 	_TACOExit
.8305						_TACOSyntax:
.8305		4c ee 9f	jmp $9fee			jmp 	SyntaxError
.8308						_TACOIndirect:
.8308		20 36 83	jsr $8336			jsr 	CalculateOperand 			; get the operand
.830b		b1 30		lda ($30),y			lda 	(codePtr),y
.830d		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if , then it must be ,X)
.830f		f0 17		beq $8328			beq 	_TACOIndX
.8311		20 30 8f	jsr $8f30			jsr 	CheckRightBracket  			; otherwise must be ) or ),Y
.8314		b1 30		lda ($30),y			lda 	(codePtr),y
.8316		a2 d1		ldx #$d1			ldx 	#AM_IND
.8318		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not comma then exit with (xx)
.831a		d0 19		bne $8335			bne 	_TACOExit
.831c		c8		iny				iny
.831d		20 40 83	jsr $8340			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.8320		c9 59		cmp #$59			cmp 	#'Y' 						; check Y
.8322		d0 e1		bne $8305			bne 	_TACOSyntax
.8324		a2 d0		ldx #$d0			ldx 	#AM_INDY
.8326		80 0d		bra $8335			bra 	_TACOExit
.8328						_TACOIndX:
.8328		c8		iny				iny
.8329		20 40 83	jsr $8340			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.832c		c9 58		cmp #$58			cmp 	#'X' 						; check X
.832e		d0 d5		bne $8305			bne 	_TACOSyntax
.8330		20 30 8f	jsr $8f30			jsr 	CheckRightBracket			; check )
.8333		a2 c0		ldx #$c0			ldx 	#AM_INDX
.8335						_TACOExit:
.8335		60		rts				rts
.8336						CalculateOperand:
.8336		48		pha				pha
.8337		da		phx				phx
.8338		a2 00		ldx #$00			ldx 	#0 							; get 16 bit integer in Slot 0
.833a		20 f0 9d	jsr $9df0			jsr 	Evaluate16BitInteger
.833d		fa		plx				plx
.833e		68		pla				pla
.833f		60		rts				rts
.8340						TACOCheckXY:
.8340		b1 30		lda ($30),y			lda 	(codePtr),y
.8342		29 c0		and #$c0			and 	#$C0 						; check it is an identifier reference.
.8344		c9 40		cmp #$40			cmp 	#$40
.8346		d0 21		bne $8369			bne 	_TCXYFail
.8348		b1 30		lda ($30),y			lda 	(codePtr),y
.834a		18		clc				clc
.834b		69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.834d		85 37		sta $37				sta 	zTemp0+1
.834f		c8		iny				iny
.8350		b1 30		lda ($30),y			lda 	(codePtr),y
.8352		c8		iny				iny
.8353		85 36		sta $36				sta 	zTemp0
.8355		5a		phy				phy 								; save position
.8356		a0 02		ldy #$02			ldy 	#2 							; type is integer ?
.8358		b1 36		lda ($36),y			lda 	(zTemp0),y
.835a		d0 0c		bne $8368			bne 	_TCXYPopFail
.835c		a0 08		ldy #$08			ldy 	#8 							; get first character, should have bit 7 set as also last.
.835e		b1 36		lda ($36),y			lda 	(zTemp0),y
.8360		c9 d8		cmp #$d8			cmp 	#'X'+$80 					; should be X or Y
.8362		f0 08		beq $836c			beq 	_TCXYFound
.8364		c9 d9		cmp #$d9			cmp 	#'Y'+$80
.8366		f0 04		beq $836c			beq 	_TCXYFound
.8368						_TCXYPopFail:
.8368		7a		ply				ply
.8369						_TCXYFail:
.8369		a9 00		lda #$00			lda 	#0
.836b		60		rts				rts
.836c						_TCXYFound:
.836c		7a		ply				ply 								; restore position
.836d		29 7f		and #$7f			and 	#$7F 						; throw bit 7
.836f		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/backload.asm

.8370						BackloadProgram:
.8370		20 7e 8a	jsr $8a7e			jsr 	NewProgram 					; does the actual NEW.
.8373		a2 83		ldx #$83			ldx 	#_BLLoad >> 8
.8375		a9 bf		lda #$bf			lda 	#_BLLoad & $FF
.8377		20 a2 8f	jsr $8fa2			jsr 	PrintStringXA
.837a		a9 14		lda #$14			lda 	#SOURCE_ADDRESS >> 13 		; start page
.837c		8d 59 06	sta $0659			sta 	BackLoadPage
.837f		a9 00		lda #$00			lda 	#(($6000) & $FF)
.8381		8d 5a 06	sta $065a			sta 	0+BackLoadPointer
.8384		a9 60		lda #$60			lda 	#(($6000) >> 8)
.8386		8d 5b 06	sta $065b			sta 	1+BackLoadPointer
.8389		a9 ff		lda #$ff			lda 	#$FF
.838b		8d fa ff	sta $fffa			sta 	$FFFA
.838e						_BPLoop:
.838e		a2 ff		ldx #$ff			ldx 	#$FF
.8390		20 d4 83	jsr $83d4			jsr 	BLReadByte 					; read a byte
.8393		c9 00		cmp #$00			cmp 	#0
.8395		f0 21		beq $83b8			beq 	_BPExit 					; if 0 exit
.8397		30 1f		bmi $83b8			bmi 	_BPExit 					; if -ve exit
.8399						_BPCopy:
.8399		e8		inx				inx  								; copy byte into the lineBuffer
.839a		9d 2a 05	sta $052a,x			sta 	lineBuffer,x
.839d		9e 2b 05	stz $052b,x			stz 	lineBuffer+1,x
.83a0		20 d4 83	jsr $83d4			jsr 	BLReadByte 					; read next byte
.83a3		30 0a		bmi $83af			bmi 	_BPEndLine 					; -ve = EOL
.83a5		c9 09		cmp #$09			cmp 	#9 							; handle TAB, make it space.
.83a7		d0 02		bne $83ab			bne 	_BPNotTab
.83a9		a9 20		lda #$20			lda 	#' '
.83ab						_BPNotTab:
.83ab		c9 20		cmp #$20			cmp 	#' ' 						; < ' ' = EOL
.83ad		b0 ea		bcs $8399			bcs 	_BPCopy 					; until a control character, should be 13 received.
.83af						_BPEndLine:
.83af		20 67 80	jsr $8067			jsr 	TKTokeniseLine 				; tokenise the line.
.83b2		38		sec				sec 								; append not insert
.83b3		20 48 a5	jsr $a548			jsr 	MemoryInsertLine 			; append to current program
.83b6		80 d6		bra $838e			bra 	_BPLoop
.83b8						_BPExit:
.83b8		9c fa ff	stz $fffa			stz 	$FFFA
.83bb		20 bd 84	jsr $84bd			jsr 	ClearCommand 				; clear variables etc.
.83be		60		rts				rts
.83bf						_BLLoad:
>83bf		4c 6f 61 64 69 6e 67 20				.text 	"Loading from Memory",13,0
>83c7		66 72 6f 6d 20 4d 65 6d 6f 72 79 0d 00
.83d4						BLReadByte:
.83d4		da		phx				phx
.83d5		a6 0b		ldx $0b				ldx 	8+3 						; save current mapping for $6000 in X
.83d7		ad 59 06	lda $0659			lda 	BackLoadPage	 			; set current page
.83da		85 0b		sta $0b				sta 	8+3
.83dc		ad 5a 06	lda $065a			lda 	BackLoadPointer 			; copy pointer to zTemp0
.83df		85 36		sta $36				sta 	zTemp0
.83e1		ad 5b 06	lda $065b			lda 	BackLoadPointer+1
.83e4		85 37		sta $37				sta 	zTemp0+1
.83e6		b2 36		lda ($36)			lda 	(zTemp0) 					; read next byte
.83e8		ee 5a 06	inc $065a			inc 	BackLoadPointer 			; bump pointer
.83eb		d0 0f		bne $83fc			bne 	_BLNoCarry
.83ed		ee 5b 06	inc $065b			inc 	BackLoadPointer+1
.83f0		10 0a		bpl $83fc			bpl 	_BLNoCarry 					; need a new page
.83f2		48		pha				pha
.83f3		a9 60		lda #$60			lda 	#$60 						; reset pointer
.83f5		8d 5b 06	sta $065b			sta 	BackLoadPointer+1
.83f8		ee 59 06	inc $0659			inc 	BackLoadPage 				; next page from source.
.83fb		68		pla				pla
.83fc						_BLNoCarry:
.83fc		86 0b		stx $0b				stx 	8+3 						; restore mapping, then X.
.83fe		fa		plx				plx
.83ff		c9 00		cmp #$00			cmp 	#0
.8401		60		rts				rts
.0659						BackLoadPage:
>0659								.fill  	1
.065a						BackLoadPointer:
>065a								.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/editor.asm

.8402						EditProgramCode:
.8402		ad 2b 04	lda $042b			lda 	TokenLineNumber 			; try to find the line.
.8405		ae 2c 04	ldx $042c			ldx 	TokenLineNumber+1
.8408		20 ec a5	jsr $a5ec			jsr 	MemorySearch
.840b		90 05		bcc $8412			bcc 	_EPCNoDelete 				; reached the end : don't delete
.840d		d0 03		bne $8412			bne 	_EPCNoDelete 				; found slot but didn't match : no delete
.840f		20 11 a5	jsr $a511			jsr 	MemoryDeleteLine 			; delete the line
.8412						_EPCNoDelete:
.8412		ad 2d 04	lda $042d			lda 	TokenBuffer 				; buffer empty - we just want to delete a line.
.8415		c9 80		cmp #$80			cmp 	#KWC_EOL
.8417		f0 0d		beq $8426			beq 	_EPCNoInsert
.8419		ad 2b 04	lda $042b			lda 	TokenLineNumber 			; find the line - it cannot exist as we've just deleted it.
.841c		ae 2c 04	ldx $042c			ldx 	TokenLineNumber+1 			; so this can't fail, it returns some point in the code.
.841f		20 ec a5	jsr $a5ec			jsr 	MemorySearch
.8422		18		clc				clc 								; insert at this point.
.8423		20 48 a5	jsr $a548			jsr 	MemoryInsertLine 			; insert the line
.8426						_EPCNoInsert:
.8426		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/warmstart.asm

.8427						WarmStart:
.8427		a2 ff		ldx #$ff			ldx 	#$FF
.8429		9a		txs				txs
.842a		a9 85		lda #$85			lda 	#CLICommandLine+$80 		; set console colour whatever the current colour is.
.842c		20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.842f		20 35 80	jsr $8035			jsr 	EXTInputLine 				; get line to lineBuffer
.8432		20 67 80	jsr $8067			jsr 	TKTokeniseLine 				; tokenise the line
.8435		ad 2b 04	lda $042b			lda 	TokenLineNumber 			; line number <> 0
.8438		0d 2c 04	ora $042c			ora 	TokenLineNumber+1
.843b		d0 17		bne $8454			bne 	_WSEditCode 				; if so,edit code.
.843d		9c 2a 04	stz $042a			stz 	TokenOffset 				; zero the "offset", meaning it only runs one line.
.8440		a9 2a		lda #$2a			lda 	#((TokenOffset) & $FF)
.8442		85 30		sta $30				sta 	codePtr
.8444		a9 04		lda #$04			lda 	#((TokenOffset) >> 8)
.8446		85 31		sta $31				sta 	codePtr+1
.8448		ad 2d 04	lda $042d			lda 	TokenBuffer 				; nothing to run
.844b		c9 80		cmp #$80			cmp 	#KWC_EOL
.844d		f0 d8		beq $8427			beq 	WarmStart
.844f		20 d1 8b	jsr $8bd1			jsr 	RUNCodePointerLine 			; execute that line.
.8452		80 d3		bra $8427			bra 	WarmStart
.8454						_WSEditCode:
.8454		20 02 84	jsr $8402			jsr 	EditProgramCode 			; edit the program code
.8457		20 bd 84	jsr $84bd			jsr 	ClearCommand 				; clear all variables etc.
.845a		80 cb		bra $8427			bra 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assemble.asm

.845c						AssembleCommand:
.845c		a2 00		ldx #$00			ldx 	#0
.845e		20 f0 9d	jsr $9df0			jsr 	Evaluate16BitInteger 		; start address
.8461		a5 58		lda $58				lda 	NSMantissa0
.8463		8d 1e 04	sta $041e			sta 	AssemblerAddress
.8466		a5 60		lda $60				lda 	NSMantissa1
.8468		8d 1f 04	sta $041f			sta 	AssemblerAddress+1
.846b		20 38 8f	jsr $8f38			jsr 	CheckComma
.846e		20 0b 9e	jsr $9e0b			jsr 	Evaluate8BitInteger 		; options 0-3
.8471		a5 58		lda $58				lda 	NSMantissa0
.8473		8d 20 04	sta $0420			sta 	AssemblerControl
.8476		60		rts				rts
.8477		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assert.asm

.8478						AssertCommand:
.8478		a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.847a		20 dd 9d	jsr $9ddd			jsr 	EvaluateInteger 			; the assert test
.847d		20 92 9e	jsr $9e92			jsr 	NSMIsZero 					; exit if result is non zero.
.8480		d0 05		bne $8487			bne 	_ACExit
.8482		a9 0a		lda #$0a		lda	#10
.8484		4c 49 8f	jmp $8f49		jmp	ErrorHandler
.8487						_ACExit:
.8487		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/call.asm

.8488						CallCommand:
.8488		a2 00		ldx #$00			ldx 	#0 							; get the routine address to level 0
.848a		20 f0 9d	jsr $9df0			jsr 	Evaluate16BitInteger
.848d						_CCClear
.848d		e8		inx				inx  								; clear 1,2 and 3 (for A X Y)
.848e		20 70 9e	jsr $9e70			jsr 	NSMSetZero 					; these are optional sequentially.
.8491		e0 04		cpx #$04			cpx 	#4
.8493		d0 f8		bne $848d			bne 	_CCClear
.8495		a2 00		ldx #$00			ldx 	#0 							; and keep trying while there are more values.
.8497						_CCCParam:
.8497		b1 30		lda ($30),y			lda 	(codePtr),y
.8499		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.849b		d0 09		bne $84a6			bne 	_CCCRun6502
.849d		c8		iny				iny 								; skip comma
.849e		e8		inx				inx	 								; next level
.849f		20 0b 9e	jsr $9e0b			jsr 	Evaluate8BitInteger 		; get A/X/Y
.84a2		e0 03		cpx #$03			cpx 	#3
.84a4		90 f1		bcc $8497			bcc 	_CCCParam 					; done all 3 ?
.84a6						_CCCRun6502:
.84a6		5a		phy				phy 								; save position
.84a7		a5 60		lda $60				lda 	NSMantissa1 				; put address in zTemp0
.84a9		85 37		sta $37				sta 	zTemp0+1
.84ab		a5 58		lda $58				lda 	NSMantissa0
.84ad		85 36		sta $36				sta 	zTemp0
.84af		a5 59		lda $59				lda 	NSMantissa0+1 				; get registers into A X Y
.84b1		a6 5a		ldx $5a				ldx 	NSMantissa0+2
.84b3		a4 5b		ldy $5b				ldy 	NSMantissa0+3
.84b5		20 ba 84	jsr $84ba			jsr 	_CCCZTemp0 					; call zTemp0
.84b8		7a		ply				ply 								; restore position and exit
.84b9		60		rts				rts
.84ba						_CCCZTemp0:
.84ba		6c 36 00	jmp ($0036)			jmp 	(zTemp0)

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/clear.asm

.84bd						ClearCommand:
.84bd		a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.84bf		85 36		sta $36				sta 	0+zTemp0
.84c1		a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.84c3		85 37		sta $37				sta 	1+zTemp0
.84c5						_ClearZeroLoop:
.84c5		b2 36		lda ($36)			lda 	(zTemp0) 					; end of variables if offset is zero.
.84c7		f0 24		beq $84ed			beq 	_ClearZeroEnd
.84c9		a0 03		ldy #$03			ldy 	#3 							; erase the variables
.84cb		a9 00		lda #$00			lda 	#0 							; set all the data to zero.
.84cd						_ClearOneVariable:
.84cd		91 36		sta ($36),y			sta 	(zTemp0),y
.84cf		c8		iny				iny
.84d0		c0 08		cpy #$08			cpy 	#8
.84d2		d0 f9		bne $84cd			bne 	_ClearOneVariable
.84d4		a0 02		ldy #$02			ldy 	#2 							; has it been marked procedure
.84d6		b1 36		lda ($36),y			lda 	(zTemp0),y
.84d8		c9 18		cmp #$18			cmp 	#NSTProcedure
.84da		d0 04		bne $84e0			bne 	_ClearNotProcedure
.84dc		a9 04		lda #$04			lda 	#NSTInteger+NSBIsArray 		; if so set it back to an integer array
.84de		91 36		sta ($36),y			sta 	(zTemp0),y 					; will be fixed on the pre-run scan.
.84e0						_ClearNotProcedure:
.84e0		18		clc				clc 								; go to the next variable
.84e1		b2 36		lda ($36)			lda 	(zTemp0) 					; offset to next, add to zTemp0
.84e3		65 36		adc $36				adc 	zTemp0
.84e5		85 36		sta $36				sta 	zTemp0
.84e7		90 dc		bcc $84c5			bcc 	_ClearZeroLoop
.84e9		e6 37		inc $37				inc 	zTemp0+1
.84eb		80 d8		bra $84c5			bra 	_ClearZeroLoop
.84ed						_ClearZeroEnd:
.84ed		18		clc				clc
.84ee		a5 36		lda $36				lda 	zTemp0
.84f0		69 01		adc #$01			adc 	#1
.84f2		8d 0c 04	sta $040c			sta 	lowMemPtr
.84f5		a5 37		lda $37				lda 	zTemp0+1
.84f7		69 00		adc #$00			adc 	#0
.84f9		8d 0d 04	sta $040d			sta 	lowMemPtr+1
.84fc		20 78 a7	jsr $a778			jsr 	StackReset
.84ff		20 de a7	jsr $a7de			jsr 	StringSystemInitialise
.8502		20 39 8e	jsr $8e39			jsr 	ProcedureScan
.8505		20 80 8b	jsr $8b80			jsr 	Command_Restore
.8508		9c 1e 04	stz $041e			stz 	AssemblerAddress
.850b		9c 1f 04	stz $041f			stz 	AssemblerAddress+1
.850e		9c 20 04	stz $0420			stz 	AssemblerControl
.8511		20 83 9a	jsr $9a83			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.8514		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/cls.asm

.8515						ClearScreen:
.8515		5a		phy				phy
.8516		a9 0c		lda #$0c			lda 	#12 						; char code 12 clears the screen.
.8518		20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.851b		7a		ply				ply
.851c		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/data.asm

.851d						Command_Data:
.851d		a9 3a		lda #$3a			lda 	#KWD_COLON 					; advance to colon/EOL, e.g. ignore anything till then.
.851f		a2 80		ldx #$80			ldx 	#KWC_EOL
.8521		20 8b 8e	jsr $8e8b			jsr 	ScanForward
.8524		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dim.asm

.8525						DimCommand:
.8525		b1 30		lda ($30),y			lda 	(codePtr),y
.8527		29 c0		and #$c0			and 	#$C0
.8529		c9 40		cmp #$40			cmp 	#$40
.852b		d0 7a		bne $85a7			bne 	_DCSyntax 				; n o, error.
.852d		b1 30		lda ($30),y			lda 	(codePtr),y
.852f		18		clc				clc
.8530		69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8532		85 3f		sta $3f				sta 	zaTemp+1
.8534		c8		iny				iny
.8535		b1 30		lda ($30),y			lda 	(codePtr),y
.8537		c8		iny				iny
.8538		85 3e		sta $3e				sta 	zaTemp
.853a		5a		phy				phy
.853b		a0 02		ldy #$02			ldy 	#2 						; read type byte
.853d		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.853f		29 18		and #$18			and 	#NSBTypeMask 			; check it's not a procedure
.8541		c9 18		cmp #$18			cmp 	#NSTProcedure
.8543		f0 62		beq $85a7			beq 	_DCSyntax
.8545		b1 3e		lda ($3e),y			lda 	(zaTemp),y 				; check it's an array
.8547		29 04		and #$04			and 	#NSBIsArray
.8549		f0 64		beq $85af			beq 	_DCType
.854b		a0 04		ldy #$04			ldy 	#4 						; check not already defined
.854d		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.854f		d0 59		bne $85aa			bne 	_DCRedefine
.8551		7a		ply				ply
.8552		20 b2 85	jsr $85b2			jsr 	_DCGetSize 				; get array size, check it.
.8555		5a		phy				phy
.8556		a0 05		ldy #$05			ldy 	#5 						; store in first array size slot
.8558		91 3e		sta ($3e),y			sta 	(zaTemp),y 				; second will be zero.
.855a		7a		ply				ply 							; is there a second (e.g. ,x)
.855b		b1 30		lda ($30),y			lda 	(codePtr),y
.855d		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.855f		d0 0a		bne $856b			bne 	_DCOneDimension
.8561		c8		iny				iny 							; skip comma
.8562		20 b2 85	jsr $85b2			jsr 	_DCGetSize 				; get 2nd array size
.8565		5a		phy				phy
.8566		a0 06		ldy #$06			ldy 	#6 						; store in 2nd array size
.8568		91 3e		sta ($3e),y			sta 	(zaTemp),y
.856a		7a		ply				ply
.856b						_DCOneDimension:
.856b		5a		phy				phy 							; save position
.856c		a0 05		ldy #$05			ldy 	#5 						; dimensions + 1 in AX (as zero based)
.856e		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8570		aa		tax				tax
.8571		c8		iny				iny
.8572		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8574		e8		inx				inx 							; bump them.
.8575		1a		inc a				inc 	a
.8576		20 1b 9e	jsr $9e1b			jsr 	Multiply8x8 			; work out the total number of elements -> zTemp0
.8579		a5 37		lda $37				lda 	zTemp0+1 				; don't allow more than 8192 elements whatever
.857b		29 e0		and #$e0			and 	#$E0
.857d		d0 23		bne $85a2			bne 	_DCSize
.857f		a0 02		ldy #$02			ldy 	#2 						; get base type
.8581		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8583		20 c0 85	jsr $85c0			jsr 	ScaleByBaseType 		; scale by base type
.8586		a5 36		lda $36				lda 	zTemp0
.8588		a6 37		ldx $37				ldx 	zTemp0+1
.858a		20 45 9a	jsr $9a45			jsr 	AllocateXABytes 		; allocate memory
.858d		a0 03		ldy #$03			ldy 	#3 						; copy into the address.
.858f		91 3e		sta ($3e),y			sta 	(zaTemp),y
.8591		c8		iny				iny
.8592		8a		txa				txa
.8593		91 3e		sta ($3e),y			sta 	(zaTemp),y
.8595		7a		ply				ply 							; get position back
.8596		20 30 8f	jsr $8f30			jsr 	CheckRightBracket 		; check )
.8599		b1 30		lda ($30),y			lda 	(codePtr),y
.859b		c8		iny				iny 							; consume in case
.859c		c9 2c		cmp #$2c			cmp 	#KWD_COMMA		 		; if so do another DIM.
.859e		f0 85		beq $8525			beq 	DimCommand
.85a0		88		dey				dey 							; undo consume
.85a1		60		rts				rts
.85a2						_DCSize:
.85a2		a9 16		lda #$16		lda	#22
.85a4		4c 49 8f	jmp $8f49		jmp	ErrorHandler
.85a7						_DCSyntax:
.85a7		4c ee 9f	jmp $9fee			jmp 	SyntaxError
.85aa						_DCRedefine:
.85aa		a9 15		lda #$15		lda	#21
.85ac		4c 49 8f	jmp $8f49		jmp	ErrorHandler
.85af						_DCType:
.85af		4c f8 9f	jmp $9ff8			jmp 	TypeError
.85b2						_DCGetSize:
.85b2		a2 00		ldx #$00			ldx 	#0 						; get first index.
.85b4		20 0b 9e	jsr $9e0b			jsr 	Evaluate8BitInteger 	; get array dimension
.85b7		c9 00		cmp #$00			cmp 	#0 						; must be 1-254
.85b9		f0 e7		beq $85a2			beq 	_DCSize
.85bb		c9 fe		cmp #$fe			cmp 	#254
.85bd		f0 e3		beq $85a2			beq 	_DCSize
.85bf		60		rts				rts
.85c0						ScaleByBaseType:
.85c0		29 10		and #$10			and 	#NSBIsString 			; is it string
.85c2		d0 19		bne $85dd			bne 	_SBBTString
.85c4		a5 37		lda $37				lda 	zTemp0+1 				; push value on stack
.85c6		48		pha				pha
.85c7		a5 36		lda $36				lda 	zTemp0
.85c9		48		pha				pha
.85ca		06 36		asl $36				asl 	zTemp0 					; x 2
.85cc		26 37		rol $37				rol 	zTemp0+1
.85ce		06 36		asl $36				asl 	zTemp0 					; x 4
.85d0		26 37		rol $37				rol 	zTemp0+1
.85d2		68		pla				pla 							; add stacked value = x 5
.85d3		65 36		adc $36				adc 	zTemp0
.85d5		85 36		sta $36				sta 	zTemp0
.85d7		68		pla				pla
.85d8		65 37		adc $37				adc 	zTemp0+1
.85da		85 37		sta $37				sta 	zTemp0+1
.85dc		60		rts				rts
.85dd						_SBBTString:
.85dd		06 36		asl $36				asl 	zTemp0
.85df		26 37		rol $37				rol 	zTemp0+1
.85e1		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dokepoke.asm

.85e2						PokeCommand:
.85e2		18		clc				clc
.85e3		80 01		bra $85e6			bra 	DPCommand
.85e5						DokeCommand:
.85e5		38		sec				sec
.85e6						DPCommand:
.85e6		08		php				php									; save on stack, CS = Doke, CC = Poke
.85e7		a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.85e9		20 f0 9d	jsr $9df0			jsr		Evaluate16BitInteger 		; address
.85ec		20 38 8f	jsr $8f38			jsr 	CheckComma
.85ef		e8		inx				inx
.85f0		20 f0 9d	jsr $9df0			jsr		Evaluate16BitInteger 		; data
.85f3		a5 58		lda $58				lda 	NSMantissa0 				; copy address
.85f5		85 36		sta $36				sta 	zTemp0
.85f7		a5 60		lda $60				lda 	NSMantissa1
.85f9		85 37		sta $37				sta 	zTemp0+1
.85fb		a5 59		lda $59				lda 	NSMantissa0+1 				; low byte
.85fd		92 36		sta ($36)			sta 	(zTemp0)
.85ff		28		plp				plp 								; done if POKE
.8600		90 08		bcc $860a			bcc 	_DPExit
.8602		5a		phy				phy 								; write high byte out.
.8603		a0 01		ldy #$01			ldy 	#1
.8605		a5 61		lda $61				lda 	NSMantissa1+1
.8607		91 36		sta ($36),y			sta 	(zTemp0),y
.8609		7a		ply				ply
.860a						_DPExit:
.860a		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/end.asm

.860b						EndCommand:
.860b		4c 27 84	jmp $8427			jmp 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/for.asm

.860e						ForCommand:
.860e		a9 d9		lda #$d9			lda 	#STK_FOR+9 					; allocate 18 bytes on the return stack (see above).
.8610		20 12 a7	jsr $a712			jsr 	StackOpen
.8613		a2 00		ldx #$00			ldx 	#0
.8615		20 97 98	jsr $9897			jsr 	EvaluateTerm
.8618		b5 50		lda $50,x			lda 	NSStatus,x
.861a		c9 20		cmp #$20			cmp 	#NSBIsReference+NSTInteger 	; do we have an integer 4 byte reference.
.861c		d0 47		bne $8665			bne		_FCError
.861e		a9 3d		lda #$3d			lda 	#KWD_EQUAL 					; =
.8620		20 40 8f	jsr $8f40			jsr 	CheckNextA
.8623		e8		inx				inx
.8624		20 dd 9d	jsr $9ddd			jsr 	EvaluateInteger 			; <from> in +1
.8627		b1 30		lda ($30),y			lda 	(codePtr),y
.8629		c8		iny				iny 								; consume it
.862a		48		pha				pha 								; save on stack for later
.862b		c9 b7		cmp #$b7			cmp 	#KWD_DOWNTO
.862d		f0 04		beq $8633			beq 	_FCNoSyntax
.862f		c9 d2		cmp #$d2			cmp 	#KWD_TO
.8631		d0 35		bne $8668			bne 	_FCSyntaxError
.8633						_FCNoSyntax:
.8633		e8		inx				inx
.8634		20 dd 9d	jsr $9ddd			jsr 	EvaluateInteger
.8637		20 57 a7	jsr $a757			jsr 	STKSaveCodePosition 		; save loop back position
.863a		68		pla				pla 								; restore DOWNTO or TO
.863b		5a		phy				phy 								; save Y on the stack
.863c		49 b7		eor #$b7			eor 	#KWD_DOWNTO 				; 0 if DOWNTO, #0 if TO
.863e		f0 02		beq $8642			beq 	_FCNotDownTo
.8640		a9 02		lda #$02			lda 	#2
.8642						_FCNotDownTo:
.8642		3a		dec a				dec 	a 							; 255 if DOWNTO, 1 if TO
.8643		a0 10		ldy #$10			ldy 	#16
.8645		91 34		sta ($34),y			sta 	(basicStack),y 				; copy that out to the Basic Stack.
.8647		a0 06		ldy #$06			ldy 	#6 							; this is the address of the loop variable.
.8649		a5 58		lda $58				lda 	NSMantissa0
.864b		91 34		sta ($34),y			sta 	(basicStack),y
.864d		a5 60		lda $60				lda 	NSMantissa1
.864f		c8		iny				iny
.8650		91 34		sta ($34),y			sta 	(basicStack),y
.8652		a0 08		ldy #$08			ldy 	#8 							; set initial index value
.8654		a2 01		ldx #$01			ldx 	#1
.8656		20 6b 86	jsr $866b			jsr 	FCIntegerToStack
.8659		a0 0c		ldy #$0c			ldy 	#12 						; set the terminal value
.865b		a2 02		ldx #$02			ldx 	#2
.865d		20 6b 86	jsr $866b			jsr 	FCIntegerToStack
.8660		20 86 86	jsr $8686			jsr 	CopyIndexToReference
.8663		7a		ply				ply 								; restore position
.8664		60		rts				rts
.8665						_FCError:
.8665		4c f8 9f	jmp $9ff8			jmp 	TypeError
.8668						_FCSyntaxError:
.8668		4c ee 9f	jmp $9fee			jmp 	SyntaxError
.866b						FCIntegerToStack:
.866b		34 50		bit $50,x			bit 	NSStatus,x 					; is the value negative
.866d		10 03		bpl $8672			bpl	 	_FCNotNegative
.866f		20 39 9e	jsr $9e39			jsr 	NSMNegateMantissa 			; if so 2's complement the mantissa
.8672						_FCNotNegative:
.8672		b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy out to the basic stack
.8674		91 34		sta ($34),y			sta 	(basicStack),y
.8676		c8		iny				iny
.8677		b5 60		lda $60,x			lda 	NSMantissa1,x
.8679		91 34		sta ($34),y			sta 	(basicStack),y
.867b		c8		iny				iny
.867c		b5 68		lda $68,x			lda 	NSMantissa2,x
.867e		91 34		sta ($34),y			sta 	(basicStack),y
.8680		c8		iny				iny
.8681		b5 70		lda $70,x			lda 	NSMantissa3,x
.8683		91 34		sta ($34),y			sta 	(basicStack),y
.8685		60		rts				rts
.8686						CopyIndexToReference:
.8686		5a		phy				phy
.8687		a0 06		ldy #$06			ldy 	#6 							; copy address-8 to write to zTemp0
.8689		38		sec				sec 								; (because we copy from offset 8)
.868a		b1 34		lda ($34),y			lda 	(basicStack),y
.868c		e9 08		sbc #$08			sbc 	#8
.868e		85 36		sta $36				sta 	zTemp0
.8690		c8		iny				iny
.8691		b1 34		lda ($34),y			lda 	(basicStack),y
.8693		e9 00		sbc #$00			sbc 	#0
.8695		85 37		sta $37				sta 	zTemp0+1
.8697		a2 04		ldx #$04			ldx 	#4 							; this is the copy counter/
.8699		a0 0b		ldy #$0b			ldy 	#8+3 		 				; the MSB of the mantissa
.869b		b1 34		lda ($34),y			lda 	(basicStack),y
.869d		0a		asl a				asl 	a 							; into carry
.869e		a0 08		ldy #$08			ldy 	#8 							; where to copy from.
.86a0		90 14		bcc $86b6			bcc 	_CITRNormal
.86a2		38		sec				sec
.86a3						_CITRNegative:
.86a3		a9 00		lda #$00			lda 	#0
.86a5		f1 34		sbc ($34),y			sbc 	(basicStack),y
.86a7		91 36		sta ($36),y			sta 	(zTemp0),y
.86a9		c8		iny				iny
.86aa		ca		dex				dex
.86ab		d0 f6		bne $86a3			bne 	_CITRNegative
.86ad		88		dey				dey 								; look at MSB of mantissa
.86ae		b1 36		lda ($36),y			lda 	(zTemp0),y 					; set the MSB as negative packed.
.86b0		09 80		ora #$80			ora 	#$80
.86b2		91 36		sta ($36),y			sta 	(zTemp0),y
.86b4		7a		ply				ply
.86b5		60		rts				rts
.86b6						_CITRNormal:
.86b6		b1 34		lda ($34),y			lda 	(basicStack),y 				; copy without negation.
.86b8		91 36		sta ($36),y			sta 	(zTemp0),y
.86ba		c8		iny				iny
.86bb		ca		dex				dex
.86bc		d0 f8		bne $86b6			bne 	_CITRNormal
.86be		7a		ply				ply 								; and exit.
.86bf		60		rts				rts
.86c0						NextCommand:
.86c0		a9 d9		lda #$d9			lda 	#STK_FOR+9 					; check FOR is TOS
.86c2		a2 11		ldx #$11			ldx 	#ERRID_FOR 					; this error
.86c4		20 3f a7	jsr $a73f			jsr 	StackCheckFrame
.86c7		5a		phy				phy
.86c8		a0 10		ldy #$10			ldy 	#16 						; get the step count
.86ca		b1 34		lda ($34),y			lda 	(basicStack),y
.86cc		85 36		sta $36				sta 	zTemp0 						; this is the sign extend
.86ce		30 02		bmi $86d2			bmi 	_NCStepNeg
.86d0		64 36		stz $36				stz 	zTemp0 						; which is 0 or 255
.86d2						_NCStepNeg:
.86d2		a0 08		ldy #$08			ldy 	#8 							; offset to bump
.86d4		a2 04		ldx #$04			ldx 	#4 							; count to bump
.86d6		18		clc				clc
.86d7						_NCBump:
.86d7		71 34		adc ($34),y			adc 	(basicStack),y 				; add it
.86d9		91 34		sta ($34),y			sta 	(basicStack),y
.86db		a5 36		lda $36				lda 	zTemp0 						; get sign extend for next time.
.86dd		c8		iny				iny 								; next byte
.86de		ca		dex				dex 								; do four times
.86df		d0 f6		bne $86d7			bne 	_NCBump
.86e1		20 86 86	jsr $8686			jsr		CopyIndexToReference		; copy it to the reference variable.
.86e4		a0 10		ldy #$10			ldy 	#16 						; get step count again
.86e6		b1 34		lda ($34),y			lda 	(basicStack),y
.86e8		0a		asl a				asl 	a 							; sign bit to carry
.86e9		a9 0c		lda #$0c			lda 	#12 						; offset of LHS = terminal offset
.86eb		85 38		sta $38				sta 	zTemp1
.86ed		90 02		bcc $86f1			bcc 	_NCCompRev 					; use if step is +ve
.86ef		a9 08		lda #$08			lda 	#8 							; now the LHS = index value
.86f1						_NCCompRev:
.86f1		85 38		sta $38				sta 	zTemp1 						; so zTemp0 is the index for LHS
.86f3		49 04		eor #$04			eor 	#(8^12) 					; and zTemp0+1 is the index for RHS
.86f5		85 39		sta $39				sta 	zTemp1+1
.86f7		a2 04		ldx #$04			ldx 	#4 							; bytes to compare
.86f9		38		sec				sec
.86fa						_NCCompare:
.86fa		a4 38		ldy $38				ldy 	zTemp1 						; do compare using the two indices
.86fc		b1 34		lda ($34),y			lda 	(basicStack),y
.86fe		a4 39		ldy $39				ldy 	zTemp1+1
.8700		f1 34		sbc ($34),y			sbc 	(basicStack),y
.8702		e6 38		inc $38				inc 	zTemp1 						; bump the indices (inc,dex do not change C or V)
.8704		e6 39		inc $39				inc 	zTemp1+1
.8706		ca		dex				dex 								; do it 4 times.
.8707		d0 f1		bne $86fa			bne 	_NCCompare
.8709		50 02		bvc $870d			bvc 	_NCNoOverflow 				; convert to signed comparison
.870b		49 80		eor #$80			eor 	#$80
.870d						_NCNoOverflow:
.870d		7a		ply				ply 								; restore Y position
.870e		0a		asl a				asl 	a 							; is bit 7 set.
.870f		90 04		bcc $8715			bcc 	_NCLoopback 				; if no , >= so loop back
.8711		20 31 a7	jsr $a731			jsr 	StackClose 					; exit the loop
.8714		60		rts				rts
.8715						_NCLoopBack:
.8715		20 68 a7	jsr $a768			jsr 	STKLoadCodePosition 		; loop back
.8718		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/gosub.asm

.8719						Command_GOSUB:
.8719		a2 00		ldx #$00			ldx 	#0
.871b		20 f0 9d	jsr $9df0			jsr 	Evaluate16BitInteger 		; line number in Stack.0
.871e		a9 e3		lda #$e3			lda 	#STK_GOSUB+3
.8720		20 12 a7	jsr $a712			jsr 	StackOpen 					; create frame
.8723		20 57 a7	jsr $a757			jsr 	STKSaveCodePosition 		; save current position
.8726		4c 3c 87	jmp $873c			jmp 	GotoStackX
.8729						Command_RETURN:
.8729		a9 e0		lda #$e0			lda 	#STK_GOSUB 					; check TOS is this
.872b		a2 0e		ldx #$0e			ldx 	#ERRID_GOSUB 				; this error
.872d		20 3f a7	jsr $a73f			jsr 	StackCheckFrame
.8730		20 68 a7	jsr $a768			jsr 	STKLoadCodePosition 		; restore code position
.8733		20 31 a7	jsr $a731			jsr 	StackClose
.8736		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/goto.asm

.8737						GotoCommand:
.8737		a2 00		ldx #$00			ldx 	#0 							; GOTO where
.8739		20 f0 9d	jsr $9df0			jsr 	Evaluate16BitInteger
.873c						GotoStackX:
.873c		b5 60		lda $60,x			lda  	NSMantissa1,x 				; put line # in XA. I'll keep this even though
.873e		48		pha				pha 								; it is slightly inefficient, just in cases.
.873f		b5 58		lda $58,x			lda 	NSMantissa0,x
.8741		fa		plx				plx
.8742		20 ec a5	jsr $a5ec			jsr 	MemorySearch 				; transfer to line number AX.
.8745		90 05		bcc $874c			bcc 	_GotoError 					; not found, off end.
.8747		d0 03		bne $874c			bne 	_GotoError 					; not found exactly
.8749		4c ca 8b	jmp $8bca			jmp 	RunNewLine 					; and go straight to new line code.
.874c						_GotoError:
.874c		a9 0d		lda #$0d		lda	#13
.874e		4c 49 8f	jmp $8f49		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/if.asm

.8751						IfCommand:
.8751		a2 00		ldx #$00			ldx 	#0 							; Get the if test.
.8753		20 be 9d	jsr $9dbe			jsr 	EvaluateNumber
.8756		b1 30		lda ($30),y			lda 	(codePtr),y
.8758		c9 aa		cmp #$aa			cmp 	#KWD_THEN  					; could be THEN <stuff>
.875a		d0 0a		bne $8766			bne 	_IFStructured 				; we still support it.
.875c		c8		iny				iny 								; consume THEN
.875d		20 92 9e	jsr $9e92			jsr 	NSMIsZero 					; is it zero
.8760		f0 01		beq $8763			beq 	_IfFail 					; if fail, go to next line
.8762		60		rts				rts 								; if THEN just continue
.8763						_IfFail:
.8763		4c b2 8b	jmp $8bb2			jmp 	EOLCommand
.8766						_IfStructured:
.8766		20 92 9e	jsr $9e92			jsr 	NSMIsZero 					; is it zero
.8769		d0 07		bne $8772			bne 	_IfExit 					; if not, then continue normally.
.876b		a9 b8		lda #$b8			lda 	#KWD_ELSE 					; look for else/endif
.876d		a2 a7		ldx #$a7			ldx 	#KWD_ENDIF
.876f		20 8b 8e	jsr $8e8b			jsr 	ScanForward 				; and run from there
.8772						_IfExit:
.8772		60		rts				rts
.8773						ElseCode:
.8773		a9 a7		lda #$a7			lda 	#KWD_ENDIF 					; else is only run after the if clause succeeds
.8775		aa		tax				tax 								; so just go to the structure exit
.8776		20 8b 8e	jsr $8e8b			jsr 	ScanForward
.8779		60		rts				rts
.877a						EndIf:
.877a		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/inputprint.asm

.877b						Command_Input:
.877b		a9 ff		lda #$ff			lda 	#$FF 						; set input flag
.877d		8d 28 04	sta $0428			sta 	IsInputFlag
.8780		80 03		bra $8785			bra 	Command_IP_Main
.8782						Command_Print:
.8782		9c 28 04	stz $0428			stz 	IsInputFlag 				; clear input flag
.8785						Command_IP_Main:
.8785		18		clc				clc 								; carry being clear means last print wasn't comma/semicolon
.8786						_CPLoop:
.8786		08		php				php 								; save last action flag
.8787		b1 30		lda ($30),y			lda 	(codePtr),y
.8789		c9 80		cmp #$80			cmp  	#KWC_EOL 					; end of line or colon, exit now.
.878b		f0 54		beq $87e1			beq 	_CPExit
.878d		c9 3a		cmp #$3a			cmp 	#KWD_COLON
.878f		f0 50		beq $87e1			beq 	_CPExit
.8791		68		pla				pla 								; throw last action flag
.8792		b1 30		lda ($30),y			lda 	(codePtr),y
.8794		c8		iny				iny
.8795		c9 3b		cmp #$3b			cmp 	#KWD_SEMICOLON				; is it a semicolon
.8797		f0 45		beq $87de			beq 	_CPContinueWithSameLine
.8799		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; comma
.879b		f0 3c		beq $87d9			beq 	_CPTab
.879d		c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; apostrophe (new line)
.879f		f0 34		beq $87d5			beq 	_CPNewLine
.87a1		88		dey				dey 								; undo the get.
.87a2		20 4b 94	jsr $944b			jsr 	EvaluateExpressionAt0 		; evaluate expression at 0.
.87a5		b5 50		lda $50,x			lda 	NSStatus,x 					; read the status
.87a7		29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.87a9		f0 0d		beq $87b8			beq 	_CPIsValue 					; no, display it.
.87ab		ad 28 04	lda $0428			lda 	IsInputFlag 				; if print, dereference and print.
.87ae		f0 05		beq $87b5			beq 	_CPIsPrint 					; otherwise display.
.87b0		20 ea 87	jsr $87ea			jsr 	CIInputValue 				; input a value to the reference
.87b3		80 20		bra $87d5			bra 	_CPNewLine
.87b5						_CPIsPrint:
.87b5		20 10 97	jsr $9710			jsr 	Dereference 				; dereference if required.
.87b8						_CPIsValue:
.87b8		b5 50		lda $50,x			lda 	NSStatus,x 					; is it a number
.87ba		29 10		and #$10			and 	#NSBIsString
.87bc		f0 09		beq $87c7			beq 	_CPNumber
.87be		a6 60		ldx $60				ldx 	NSMantissa1 				; string, print the text.
.87c0		a5 58		lda $58				lda 	NSMantissa0
.87c2		20 4d 88	jsr $884d			jsr 	CPPrintStringXA
.87c5		80 be		bra $8785			bra 	Command_IP_Main 			; loop round clearing carry so NL if end
.87c7						_CPNumber:
.87c7		a9 05		lda #$05			lda 	#5 							; maximum decimals
.87c9		20 a5 9c	jsr $9ca5			jsr 	ConvertNumberToString 		; convert to string (in unary str$() function)
.87cc		a2 06		ldx #$06			ldx 	#DecimalBuffer >> 8
.87ce		a9 49		lda #$49			lda 	#DecimalBuffer & $FF
.87d0		20 4d 88	jsr $884d			jsr 	CPPrintStringXA 			; print it.
.87d3		80 b0		bra $8785			bra 	Command_IP_Main				; loop round clearing carry so NL if end
.87d5						_CPNewLine:
.87d5		a9 0d		lda #$0d			lda 	#13
.87d7		80 02		bra $87db			bra 	_CPPrintChar
.87d9						_CPTab:
.87d9		a9 09		lda #$09			lda 	#9 							; print TAB
.87db						_CPPrintChar:
.87db		20 60 88	jsr $8860			jsr 	CPPrintVector
.87de						_CPContinueWithSameLine:
.87de		38		sec				sec 								; loop round with carry set, which
.87df		80 a5		bra $8786			bra 	_CPLoop 					; will inhibit final CR
.87e1						_CPExit:
.87e1		28		plp				plp 								; get last action flag
.87e2		b0 05		bcs $87e9			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.87e4		a9 0d		lda #$0d			lda 	#13 						; print new line
.87e6		20 60 88	jsr $8860			jsr 	CPPrintVector
.87e9						_CPExit2:
.87e9		60		rts				rts
.87ea						CIInputValue:
.87ea		a2 00		ldx #$00			ldx 	#0 							; input a line.
.87ec						_CIInputLine:
.87ec		20 63 88	jsr $8863			jsr 	CPInputVector 				; get key
.87ef		c9 0d		cmp #$0d			cmp 	#13 						; 13 = End
.87f1		f0 1f		beq $8812			beq 	_CIHaveValue
.87f3		c9 08		cmp #$08			cmp 	#8 							; 8 = BS
.87f5		f0 11		beq $8808			beq 	_CIBackspace
.87f7		c9 20		cmp #$20			cmp 	#32 						; ignore other control characters
.87f9		90 f1		bcc $87ec			bcc 	_CIInputLine
.87fb		e0 50		cpx #$50			cpx 	#80 						; max length
.87fd		b0 ed		bcs $87ec			bcs 	_CIInputLine
.87ff		9d 2a 05	sta $052a,x			sta 	lineBuffer,x
.8802		e8		inx				inx
.8803		20 60 88	jsr $8860			jsr 	CPPrintVector 				; echo it.
.8806		80 e4		bra $87ec			bra 	_CIInputLine
.8808						_CIBackSpace:
.8808		e0 00		cpx #$00			cpx 	#0 							; nothing to delete
.880a		f0 e0		beq $87ec			beq 	_CIInputLine
.880c		20 60 88	jsr $8860			jsr 	CPPrintVector 				; echo it.
.880f		ca		dex				dex
.8810		80 da		bra $87ec			bra 	_CIInputLine
.8812						_CIHaveValue:
.8812		9e 2a 05	stz $052a,x			stz 	LineBuffer,x 				; ASCIIZ string now in line buffer.
.8815		a5 50		lda $50				lda 	NSStatus 					; was it a string assignment
.8817		29 10		and #$10			and 	#NSBIsString
.8819		f0 17		beq $8832			beq 	_CIAssignNumber 			; assign a number
.881b		a2 01		ldx #$01			ldx 	#1
.881d		a9 2a		lda #$2a			lda 	#lineBuffer & $FF 			; set up to point to new string
.881f		95 58		sta $58,x			sta 	NSMantissa0,x
.8821		a9 05		lda #$05			lda 	#lineBuffer >> 8
.8823		95 60		sta $60,x			sta 	NSMantissa1,x
.8825		74 68		stz $68,x			stz 	NSMantissa2,x
.8827		74 70		stz $70,x			stz 	NSMantissa3,x
.8829		a9 10		lda #$10			lda 	#NSBIsString 				; so it becomes a string value
.882b		95 50		sta $50,x			sta  	NSStatus,x
.882d		ca		dex				dex 								; X = 0
.882e		20 9f 88	jsr $889f			jsr 	AssignVariable
.8831		60		rts				rts
.8832						_CIAssignNumber:
.8832		a9 2a		lda #$2a			lda 	#lineBuffer & $FF 			; set up to point to new string
.8834		85 36		sta $36				sta 	zTemp0
.8836		a9 05		lda #$05			lda 	#lineBuffer >> 8
.8838		85 37		sta $37				sta 	zTemp0+1
.883a		a2 01		ldx #$01			ldx 	#1 							; put in slot 1
.883c		20 27 9c	jsr $9c27			jsr 	ValEvaluateZTemp0 			; use the VAL() code
.883f		90 07		bcc $8848			bcc 	_CIIsOkay
.8841		a9 3f		lda #$3f			lda 	#"?" 						; error ?
.8843		20 60 88	jsr $8860			jsr 	CPPrintVector
.8846		80 a2		bra $87ea			bra 	CIInputValue
.8848						_CIIsOkay:
.8848		ca		dex				dex 								; X = 0
.8849		20 9f 88	jsr $889f			jsr 	AssignVariable
.884c		60		rts				rts
.884d						CPPrintStringXA:
.884d		5a		phy				phy
.884e		86 37		stx $37				stx 	zTemp0+1
.8850		85 36		sta $36				sta 	zTemp0
.8852		a0 00		ldy #$00			ldy 	#0
.8854						_PSXALoop:
.8854		b1 36		lda ($36),y			lda 	(zTemp0),y
.8856		f0 06		beq $885e			beq 	_PSXAExit
.8858		20 60 88	jsr $8860			jsr 	CPPrintVector
.885b		c8		iny				iny
.885c		80 f6		bra $8854			bra 	_PSXALoop
.885e						_PSXAExit:
.885e		7a		ply				ply
.885f		60		rts				rts
.8860						CPPrintVector:
.8860		4c 03 80	jmp $8003			jmp 	EXTPrintCharacter
.8863						CPInputVector:
.8863		4c 17 80	jmp $8017			jmp 	EXTInputSingleCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/let.asm

.8866						LetCommand:
.8866		a2 00		ldx #$00			ldx 	#0
.8868		b1 30		lda ($30),y			lda 	(codePtr),y
.886a		c9 10		cmp #$10			cmp 	#KWD_AT
.886c		d0 14		bne $8882			bne 	_LCStandard
.886e		c8		iny				iny 								; skip equal
.886f		20 97 98	jsr $9897			jsr 	EvaluateTerm 				; get a number (the address of the reference)
.8872		20 10 97	jsr $9710			jsr 	Dereference 				; dereference it to a value
.8875		b5 50		lda $50,x			lda 	NSStatus,x 					; check integer
.8877		49 20		eor #$20			eor 	#NSBIsReference	 			; toggle reference
.8879		95 50		sta $50,x			sta 	NSStatus,x
.887b		29 20		and #$20			and 	#NSBIsReference 			; if it is now a reference, continue
.887d		d0 0f		bne $888e			bne 	_LCMain
.887f		4c f8 9f	jmp $9ff8			jmp 	TypeError 					; was a reference before.
.8882						_LCStandard:
.8882		ad 35 94	lda $9435			lda 	PrecedenceLevel+"*"			; precedence > this
.8885		20 4f 94	jsr $944f			jsr 	EvaluateExpressionAtPrecedence
.8888		b5 50		lda $50,x			lda 	NSStatus,x 					; is it a reference to an array marked as procedure ?
.888a		c9 38		cmp #$38			cmp		#NSTProcedure+NSBIsReference
.888c		f0 0e		beq $889c			beq 	_LetGoProc 					; it's a procedure call.
.888e						_LCMain:
.888e		a9 3d		lda #$3d			lda 	#"=" 						; check =
.8890		20 40 8f	jsr $8f40			jsr 	CheckNextA
.8893		e8		inx				inx 								; RHS
.8894		20 b5 9d	jsr $9db5			jsr 	EvaluateValue
.8897		ca		dex				dex
.8898		20 9f 88	jsr $889f			jsr 	AssignVariable
.889b		60		rts				rts
.889c						_LetGoProc:
.889c		4c 88 8a	jmp $8a88			jmp 	CallProcedure
.889f						AssignVariable:
.889f		b5 50		lda $50,x			lda 	NSStatus,x 					; check the string/number type bits match
.88a1		48		pha				pha 								; save a copy
.88a2		55 51		eor $51,x			eor 	NSStatus+1,x
.88a4		29 10		and #$10			and 	#NSBIsString
.88a6		d0 0b		bne $88b3			bne 	_ASError
.88a8		68		pla				pla 								; get back
.88a9		29 10		and #$10			and 	#NSBIsString 				; check type
.88ab		d0 03		bne $88b0			bne 	_ASString
.88ad		4c 4e 96	jmp $964e			jmp 	AssignNumber
.88b0						_ASString:
.88b0		4c ac 96	jmp $96ac			jmp 	AssignString
.88b3						_ASError:
.88b3		4c f8 9f	jmp $9ff8			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/list.asm

.88b6						Command_List:
.88b6		9c 26 04	stz $0426			stz 	listIndent 					; reset indent.
.88b9		b1 30		lda ($30),y			lda 	(codePtr),y
.88bb		29 c0		and #$c0			and 	#$C0 				 		; if so, we are list procedure() which is a seperate block
.88bd		c9 40		cmp #$40			cmp 	#$40  						; of code.
.88bf		f0 6e		beq $892f			beq 	_CLListProcedure
.88c1		64 5c		stz $5c				stz		NSMantissa0+4				; set the lower (slot 4) to 0 and upper (slot 7) to $FFFF
.88c3		64 64		stz $64				stz 	NSMantissa1+4 				; these are the default top and bottom.
.88c5		a9 ff		lda #$ff			lda 	#$FF
.88c7		85 5f		sta $5f				sta 	NSMantissa0+7
.88c9		85 67		sta $67				sta 	NSMantissa1+7
.88cb		b1 30		lda ($30),y			lda 	(codePtr),y
.88cd		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.88cf		f0 1a		beq $88eb			beq 	_CLSecond
.88d1		20 ac 89	jsr $89ac			jsr 	CLIsDigit 					; if not digit, list all
.88d4		b0 20		bcs $88f6			bcs 	_CLStart
.88d6		a2 04		ldx #$04			ldx 	#4 							; get 1st range into slot 4
.88d8		20 f0 9d	jsr $9df0			jsr 	Evaluate16BitInteger
.88db		b1 30		lda ($30),y			lda 	(codePtr),y
.88dd		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.88df		f0 0a		beq $88eb			beq 	_CLSecond 					; if so go get it
.88e1		a5 5c		lda $5c				lda 	NSMantissa0+4 				; copy 4->7
.88e3		85 5f		sta $5f				sta 	NSMantissa0+7
.88e5		a5 64		lda $64				lda 	NSMantissa1+4
.88e7		85 67		sta $67				sta 	NSMantissa1+7
.88e9		80 0b		bra $88f6			bra 	_CLStart
.88eb						_CLSecond:
.88eb		c8		iny				iny 								; consume comma
.88ec		20 ac 89	jsr $89ac			jsr 	CLIsDigit 					; digit found
.88ef		b0 05		bcs $88f6			bcs 	_CLStart 					; if not, continue listing
.88f1		a2 07		ldx #$07			ldx 	#7 							; load 2nd range into slot 7
.88f3		20 f0 9d	jsr $9df0			jsr 	Evaluate16BitInteger
.88f6						_CLStart
.88f6		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.88f8		85 30		sta $30				sta 	codePtr
.88fa		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.88fc		85 31		sta $31				sta 	codePtr+1
.88fe						_CLLoop:
.88fe		20 21 80	jsr $8021			jsr 	EXTBreakCheck 				; break check here, as we want the option of breaking out of long lists.
.8901		f0 27		beq $892a			beq 	_CLBreak
.8903		b2 30		lda ($30)			lda 	(codePtr)
.8905		f0 20		beq $8927			beq 	_CLExit
.8907		a2 04		ldx #$04			ldx 	#4 							; check range every time, line numbers aren't in order.
.8909		20 9b 89	jsr $899b			jsr 	CLCompareLineNo
.890c		90 0c		bcc $891a			bcc 	_CLNext
.890e		a2 07		ldx #$07			ldx 	#7
.8910		20 9b 89	jsr $899b			jsr 	CLCompareLineNo
.8913		f0 02		beq $8917			beq 	_CLDoThisOne
.8915		b0 03		bcs $891a			bcs 	_CLNext
.8917						_CLDoThisOne:
.8917		20 88 89	jsr $8988			jsr 	CLListOneLine 				; routine to list the current line.
.891a						_CLNext:
.891a		18		clc				clc
.891b		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.891d		65 30		adc $30				adc 	codePtr
.891f		85 30		sta $30				sta 	codePtr
.8921		90 02		bcc $8925			bcc 	_CREExit
.8923		e6 31		inc $31				inc 	codePtr+1 					; carry
.8925						_CREExit:
.8925		80 d7		bra $88fe			bra 	_CLLoop
.8927						_CLExit:
.8927		4c 27 84	jmp $8427			jmp 	WarmStart
.892a						_CLBreak:
.892a		a9 01		lda #$01		lda	#1
.892c		4c 49 8f	jmp $8f49		jmp	ErrorHandler
.892f						_CLListProcedure:
.892f		b1 30		lda ($30),y			lda 	(codePtr),y
.8931		85 38		sta $38				sta 	zTemp1
.8933		c8		iny				iny
.8934		b1 30		lda ($30),y			lda 	(codePtr),y
.8936		85 39		sta $39				sta 	zTemp1+1
.8938		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.893a		85 30		sta $30				sta 	codePtr
.893c		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.893e		85 31		sta $31				sta 	codePtr+1
.8940						_CLLPSearch:
.8940		b2 30		lda ($30)			lda 	(codePtr)
.8942		c9 00		cmp #$00			cmp 	#0 							; if zero, end
.8944		f0 e1		beq $8927			beq 	_CLExit
.8946		a0 03		ldy #$03			ldy 	#3 							; check if PROC something
.8948		b1 30		lda ($30),y			lda 	(codePtr),y
.894a		c9 a4		cmp #$a4			cmp 	#KWD_PROC
.894c		d0 0e		bne $895c			bne 	_CLLPNext
.894e		c8		iny				iny 								; check if PROC this.
.894f		b1 30		lda ($30),y			lda 	(codePtr),y
.8951		c5 38		cmp $38				cmp 	zTemp1 						; does it match ?
.8953		d0 07		bne $895c			bne 	_CLLPNext
.8955		c8		iny				iny
.8956		b1 30		lda ($30),y			lda 	(codePtr),y
.8958		c5 39		cmp $39				cmp 	zTemp1+1
.895a		f0 0d		beq $8969			beq 	_CLLPFound
.895c						_CLLPNext:
.895c		18		clc				clc
.895d		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.895f		65 30		adc $30				adc 	codePtr
.8961		85 30		sta $30				sta 	codePtr
.8963		90 02		bcc $8967			bcc 	_CREExit
.8965		e6 31		inc $31				inc 	codePtr+1 					; carry
.8967						_CREExit:
.8967		80 d7		bra $8940			bra 	_CLLPSearch
.8969						_CLLPFound:
.8969		b2 30		lda ($30)			lda 	(codePtr)
.896b		f0 ba		beq $8927			beq 	_CLExit
.896d		a0 03		ldy #$03			ldy 	#3 							; get first keyword
.896f		b1 30		lda ($30),y			lda 	(codePtr),y
.8971		48		pha				pha
.8972		20 88 89	jsr $8988			jsr 	CLListOneLine 				; list line and go forward
.8975		18		clc				clc
.8976		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8978		65 30		adc $30				adc 	codePtr
.897a		85 30		sta $30				sta 	codePtr
.897c		90 02		bcc $8980			bcc 	_CREExit
.897e		e6 31		inc $31				inc 	codePtr+1 					; carry
.8980						_CREExit:
.8980		68		pla				pla 								; reached ENDPROC ?
.8981		c9 a8		cmp #$a8			cmp 	#KWD_ENDPROC
.8983		d0 e4		bne $8969			bne 	_CLLPFound
.8985		4c 27 84	jmp $8427			jmp 	WarmStart
.8988						CLListOneLine:
.8988		20 ee 8e	jsr $8eee			jsr 	ScanGetCurrentLineStep 		; get indent adjust.
.898b		20 5d 80	jsr $805d			jsr 	TKListConvertLine 			; convert line into token Buffer
.898e		a2 04		ldx #$04			ldx 	#(tokenBuffer >> 8) 		; print that line
.8990		a9 2d		lda #$2d			lda 	#(tokenBuffer & $FF)
.8992		20 a2 8f	jsr $8fa2			jsr 	PrintStringXA
.8995		a9 0d		lda #$0d			lda 	#13 						; new line
.8997		20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.899a		60		rts				rts
.899b						CLCompareLineNo:
.899b		38		sec				sec
.899c		a0 01		ldy #$01			ldy 	#1
.899e		b1 30		lda ($30),y			lda 	(codePtr),y
.89a0		f5 58		sbc $58,x			sbc 	NSMantissa0,x
.89a2		85 36		sta $36				sta 	zTemp0
.89a4		c8		iny				iny
.89a5		b1 30		lda ($30),y			lda 	(codePtr),y
.89a7		f5 60		sbc $60,x			sbc 	NSMantissa1,x
.89a9		05 36		ora $36				ora 	zTemp0
.89ab		60		rts				rts
.89ac						CLIsDigit:
.89ac		b1 30		lda ($30),y			lda 	(codePtr),y
.89ae		c9 30		cmp #$30			cmp 	#"0"
.89b0		90 03		bcc $89b5			bcc	 	_CLIDExitFalse
.89b2		c9 3a		cmp #$3a			cmp 	#"9"+1
.89b4		60		rts				rts
.89b5						_CLIDExitFalse:
.89b5		38		sec				sec
.89b6		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/local.asm

.89b7						Command_LOCAL:
.89b7		a2 00		ldx #$00			ldx 	#0 							; at level 0
.89b9		20 c5 89	jsr $89c5			jsr 	LocaliseNextTerm 			; convert term to a local.
.89bc		b1 30		lda ($30),y			lda 	(codePtr),y
.89be		c8		iny				iny
.89bf		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.89c1		f0 f4		beq $89b7			beq 	Command_LOCAL 				; if so, localise another variable.
.89c3		88		dey				dey 								; unpick pre-get
.89c4		60		rts				rts
.89c5						LocaliseNextTerm:
.89c5		20 97 98	jsr $9897			jsr 	EvaluateTerm 				; evaluate the term
.89c8		b5 50		lda $50,x			lda 	NSStatus,x
.89ca		29 20		and #$20			and 	#NSBIsReference 			; check it is a reference, must be a variable.
.89cc		f0 5c		beq $8a2a			beq		_LNTError
.89ce		b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address of variable to zTemp0
.89d0		85 36		sta $36				sta 	zTemp0
.89d2		b5 60		lda $60,x			lda 	NSMantissa1,x
.89d4		85 37		sta $37				sta  	zTemp0+1
.89d6		b5 50		lda $50,x			lda 	NSStatus,x 					; figure out what it is.
.89d8		29 10		and #$10			and 	#NSBIsString
.89da		d0 1e		bne $89fa			bne 	_LNTPushString
.89dc		5a		phy				phy
.89dd		a0 00		ldy #$00			ldy 	#0 							; push 0 to 4 inclusive, the number values, on the stack, and zero them as you go.
.89df						_LNTPushNumLoop:
.89df		b1 36		lda ($36),y			lda		(zTemp0),y
.89e1		20 f1 a6	jsr $a6f1			jsr 	StackPushByte
.89e4		c8		iny				iny
.89e5		c0 05		cpy #$05			cpy 	#5
.89e7		d0 f6		bne $89df			bne 	_LNTPushNumLoop
.89e9		a5 36		lda $36				lda 	zTemp0 						; push the actual target address to write on the stack
.89eb		20 f1 a6	jsr $a6f1			jsr 	StackPushByte
.89ee		a5 37		lda $37				lda 	zTemp0+1
.89f0		20 f1 a6	jsr $a6f1			jsr 	StackPushByte
.89f3		a9 01		lda #$01			lda 	#STK_LOCALN 				; push local-number marker.
.89f5		20 f1 a6	jsr $a6f1			jsr 	StackPushByte
.89f8		7a		ply				ply
.89f9		60		rts				rts
.89fa						_LNTPushString:
.89fa		5a		phy				phy
.89fb		b2 36		lda ($36)			lda 	(zTemp0) 					; put address of string in zTemp1
.89fd		85 38		sta $38				sta 	zTemp1
.89ff		a0 01		ldy #$01			ldy 	#1
.8a01		b1 36		lda ($36),y			lda 	(zTemp0),y
.8a03		85 39		sta $39				sta 	zTemp1+1
.8a05		a0 00		ldy #$00			ldy 	#0 							; output string
.8a07		c9 00		cmp #$00			cmp 	#0 							; if not assigned string
.8a09		f0 0a		beq $8a15			beq 	_LNTStringOut
.8a0b						_LNTPushStrLoop:
.8a0b		b1 38		lda ($38),y			lda 	(zTemp1),y
.8a0d		f0 06		beq $8a15			beq 	_LNTStringOut
.8a0f		20 f1 a6	jsr $a6f1			jsr 	StackPushByte
.8a12		c8		iny				iny
.8a13		80 f6		bra $8a0b			bra 	_LNTPushStrLoop
.8a15						_LNTStringOut:
.8a15		98		tya				tya									; output length (chars written).
.8a16		20 f1 a6	jsr $a6f1			jsr 	StackPushByte
.8a19		b5 58		lda $58,x			lda 	NSMantissa0,x 				; output address of the string record *not* the string itself
.8a1b		20 f1 a6	jsr $a6f1			jsr 	StackPushByte
.8a1e		b5 60		lda $60,x			lda 	NSMantissa1,x
.8a20		20 f1 a6	jsr $a6f1			jsr 	StackPushByte
.8a23		a9 02		lda #$02			lda 	#STK_LOCALS 				; push local-string marker.
.8a25		20 f1 a6	jsr $a6f1			jsr 	StackPushByte
.8a28		7a		ply				ply
.8a29		60		rts				rts
.8a2a						_LNTError:
.8a2a		4c ee 9f	jmp $9fee			jmp 	SyntaxError
.8a2d						LocalPopValue:
.8a2d		20 09 a7	jsr $a709			jsr 	StackPopByte
.8a30		c9 01		cmp #$01			cmp 	#STK_LOCALN 				; if not local-N
.8a32		d0 17		bne $8a4b			bne 	_LPVString
.8a34		20 09 a7	jsr $a709			jsr 	StackPopByte 				; address
.8a37		85 37		sta $37				sta 	zTemp0+1
.8a39		20 09 a7	jsr $a709			jsr 	StackPopByte
.8a3c		85 36		sta $36				sta 	zTemp0
.8a3e		5a		phy				phy
.8a3f		a0 04		ldy #$04			ldy 	#4 							; copy back
.8a41						_LPVNumberCopy:
.8a41		20 09 a7	jsr $a709			jsr 	StackPopByte
.8a44		91 36		sta ($36),y			sta 	(zTemp0),y
.8a46		88		dey				dey
.8a47		10 f8		bpl $8a41			bpl 	_LPVNumberCopy
.8a49		7a		ply				ply 								; and complete
.8a4a		60		rts				rts
.8a4b						_LPVString:
.8a4b		20 09 a7	jsr $a709			jsr 	StackPopByte 				; address of record copied to zTemp0
.8a4e		85 37		sta $37				sta 	zTemp0+1
.8a50		20 09 a7	jsr $a709			jsr 	StackPopByte
.8a53		85 36		sta $36				sta 	zTemp0
.8a55		5a		phy				phy
.8a56		b2 36		lda ($36)			lda 	(zTemp0) 					; address to write string to copied to zTemp1
.8a58		85 38		sta $38				sta 	zTemp1
.8a5a		a0 01		ldy #$01			ldy 	#1
.8a5c		b1 36		lda ($36),y			lda 	(zTemp0),y
.8a5e		85 39		sta $39				sta 	zTemp1+1
.8a60		20 09 a7	jsr $a709			jsr 	StackPopByte 				; # chars to get => y
.8a63		a8		tay				tay
.8a64		a5 39		lda $39				lda 	zTemp1+1 					; if no target (e.g. was "" originally) exit
.8a66		f0 0e		beq $8a76			beq 	_LPVStringCopied
.8a68		a9 00		lda #$00			lda 	#0 							; NULL on end
.8a6a		91 38		sta ($38),y			sta 	(zTemp1),y
.8a6c						_LPVStringCopy:
.8a6c		88		dey				dey
.8a6d		30 07		bmi $8a76			bmi 	_LPVStringCopied
.8a6f		20 09 a7	jsr $a709			jsr 	StackPopByte
.8a72		91 38		sta ($38),y			sta 	(zTemp1),y
.8a74		80 f6		bra $8a6c			bra 	_LPVStringCopy
.8a76						_LPVStringCopied:
.8a76		fa		plx				plx
.8a77		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/new.asm

.8a78						NewCommand:
.8a78		20 7e 8a	jsr $8a7e			jsr 	NewProgram 					; does the actual NEW.
.8a7b		4c 27 84	jmp $8427			jmp 	WarmStart 					; and warm starts straight away.
.8a7e						NewProgram:
.8a7e		20 ce a5	jsr $a5ce			jsr 	MemoryNew
.8a81		9c 00 10	stz $1000			stz 	VariableSpace 				; erase all variables.
.8a84		20 bd 84	jsr $84bd			jsr 	ClearCommand 				; clear everything.
.8a87		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/procedure.asm

=2						ParameterStackPos = 2
.8a88						CallProcedure:
.8a88		a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start storing parameters at 2.
.8a8a		b1 30		lda ($30),y			lda 	(codePtr),y
.8a8c		c9 29		cmp #$29			cmp 	#KWD_RPAREN
.8a8e		f0 0c		beq $8a9c			beq 	_CPEndParam
.8a90						_CPParamLoop:
.8a90		20 b5 9d	jsr $9db5			jsr 	EvaluateValue 				; get parameter onto stack
.8a93		e8		inx				inx 								; bump next stack
.8a94		b1 30		lda ($30),y			lda 	(codePtr),y
.8a96		c8		iny				iny
.8a97		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if comma, go back and try again.
.8a99		f0 f5		beq $8a90			beq 	_CPParamLoop
.8a9b		88		dey				dey 								; unpick.
.8a9c						_CPEndParam:
.8a9c		8e 16 04	stx $0416			stx 	LastParameter 				; save the last parameters index.
.8a9f		c8		iny				iny									; skip right bracket
.8aa0		a9 b3		lda #$b3			lda 	#STK_PROC+3 				; allocate 6 bytes on the return stack.
.8aa2		20 12 a7	jsr $a712			jsr 	StackOpen
.8aa5		20 57 a7	jsr $a757			jsr 	STKSaveCodePosition 		; save loop position
.8aa8		a5 58		lda $58				lda 	NSMantissa0 				; copy variable (e.g. procedure) address to zTemp0
.8aaa		85 36		sta $36				sta 	zTemp0 						; this is the DATA not the RECORD
.8aac		a5 60		lda $60				lda 	NSMantissa1
.8aae		85 37		sta $37				sta 	zTemp0+1
.8ab0		a0 01		ldy #$01			ldy 	#1 							; copy code address back.
.8ab2		b2 36		lda ($36)			lda 	(zTemp0)
.8ab4		85 30		sta $30				sta 	safePtr
.8ab6		b1 36		lda ($36),y			lda 	(zTemp0),y
.8ab8		85 31		sta $31				sta 	safePtr+1
.8aba		c8		iny				iny
.8abb		b1 36		lda ($36),y			lda 	(zTemp0),y
.8abd		85 32		sta $32				sta 	safePtr+2
.8abf		c8		iny				iny
.8ac0		b1 36		lda ($36),y			lda 	(zTemp0),y
.8ac2		85 33		sta $33				sta 	safePtr+3
.8ac4		c8		iny				iny 								; get Y offset -> Y
.8ac5		b1 36		lda ($36),y			lda 	(zTemp0),y
.8ac7		a8		tay				tay
.8ac8		a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start position of parameters
.8aca		ec 16 04	cpx $0416			cpx	 	LastParameter 				; check zero parameters at the start
.8acd		f0 13		beq $8ae2			beq 	_ParamExit 					; if so, exit.
.8acf						_ParamExtract:
.8acf		ca		dex				dex 								; put a local term on the level before
.8ad0		20 c5 89	jsr $89c5			jsr 	LocaliseNextTerm			; also pushes original param value to basic stack
.8ad3		20 9f 88	jsr $889f			jsr 	AssignVariable 				; assign stacked value to the variable.
.8ad6		e8		inx				inx 								; advance to next parameter to do.
.8ad7		e8		inx				inx
.8ad8		ec 16 04	cpx $0416			cpx 	LastParameter 				; are we done ?
.8adb		f0 05		beq $8ae2			beq 	_ParamExit
.8add		20 38 8f	jsr $8f38			jsr 	CheckComma 					; comma seperating parameters
.8ae0		80 ed		bra $8acf			bra 	_ParamExtract
.8ae2						_ParamExit:
.8ae2		20 30 8f	jsr $8f30			jsr 	CheckRightBracket 			; check )
.8ae5		60		rts				rts 								; and continue from here
.8ae6						Command_ENDPROC:
.8ae6		a9 b0		lda #$b0			lda 	#STK_PROC 					; check TOS is this
.8ae8		a2 14		ldx #$14			ldx 	#ERRID_PROC
.8aea		20 3f a7	jsr $a73f			jsr 	StackCheckFrame
.8aed		20 68 a7	jsr $a768			jsr 	STKLoadCodePosition 		; restore code position
.8af0		20 31 a7	jsr $a731			jsr 	StackClose
.8af3		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/read.asm

.8af4						Command_Read:
.8af4		a2 00		ldx #$00			ldx 	#0 							; evaluate the term which is the var/array element to assign
.8af6		20 97 98	jsr $9897			jsr 	EvaluateTerm
.8af9		b5 50		lda $50,x			lda 	NSStatus,x
.8afb		29 20		and #$20			and 	#NSBIsReference				; get status byte on stack, identifies int, float, string.
.8afd		f0 4f		beq $8b4e			beq 	_CRSyntax 					; check reference (bit 0) fail if not a reference.
.8aff		20 97 8b	jsr $8b97			jsr 	SwapDataCodePtrs 			; swap code and data
.8b02		ad 1c 04	lda $041c			lda 	inDataStatement 			; if in a data statement, we don't need to search
.8b05		d0 25		bne $8b2c			bne 	_CRContinueData  			; forward for the next one.
.8b07		b2 30		lda ($30)			lda 	(codePtr)
.8b09		f0 1c		beq $8b27			beq 	_CRNoData
.8b0b						_CRKeepSearching:
.8b0b		a9 b4		lda #$b4			lda 	#KWD_DATA 					; scan for instruction
.8b0d		a2 80		ldx #$80			ldx 	#KWC_EOL
.8b0f		20 8b 8e	jsr $8e8b			jsr 	ScanForward
.8b12		c9 b4		cmp #$b4			cmp 	#KWD_DATA 					; found data ?
.8b14		f0 16		beq $8b2c			beq 	_CRHaveData 				; found it
.8b16		18		clc				clc
.8b17		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8b19		65 30		adc $30				adc 	codePtr
.8b1b		85 30		sta $30				sta 	codePtr
.8b1d		90 02		bcc $8b21			bcc 	_CREExit
.8b1f		e6 31		inc $31				inc 	codePtr+1 					; carry
.8b21						_CREExit:
.8b21		a0 03		ldy #$03			ldy 	#3 							; start of line.
.8b23		b2 30		lda ($30)			lda 	(codePtr)
.8b25		d0 e4		bne $8b0b			bne 	_CRKeepSearching
.8b27						_CRNoData:
.8b27		a9 0b		lda #$0b		lda	#11
.8b29		4c 49 8f	jmp $8f49		jmp	ErrorHandler
.8b2c						_CRHaveData:
.8b2c						_CRContinueData:
.8b2c		a2 01		ldx #$01			ldx 	#1
.8b2e		20 b5 9d	jsr $9db5			jsr 	EvaluateValue 				; evaluate value into slot # 1
.8b31		ca		dex				dex
.8b32		20 9f 88	jsr $889f			jsr		AssignVariable 				; do the assignment
.8b35		9c 1c 04	stz $041c			stz 	inDataStatement 			; clear in data flag
.8b38		b1 30		lda ($30),y			lda 	(codePtr),y
.8b3a		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not, end of data statement and exit
.8b3c		d0 04		bne $8b42			bne 	_CRSwapBack
.8b3e		c8		iny				iny 								; consume comma
.8b3f		ee 1c 04	inc $041c			inc 	inDataStatement 			; set in data statement currently.
.8b42						_CRSwapBack:
.8b42		20 97 8b	jsr $8b97			jsr 	SwapDataCodePtrs			; swap them back.
.8b45		b1 30		lda ($30),y			lda 	(codePtr),y
.8b47		c8		iny				iny
.8b48		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8b4a		f0 a8		beq $8af4			beq 	Command_Read 				; if so go round again.
.8b4c		88		dey				dey 								; unpick get.
.8b4d		60		rts				rts
.8b4e						_CRSyntax:
.8b4e		4c ee 9f	jmp $9fee			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/rem.asm

.8b51						RemCommand:
.8b51		b1 30		lda ($30),y			lda 	(codePtr),y
.8b53		c9 ff		cmp #$ff			cmp 	#KWC_STRING
.8b55		d0 06		bne $8b5d			bne 	_RMExit
.8b57		c8		iny				iny 								; point to offset
.8b58		98		tya				tya 								; A = offset position
.8b59		38		sec				sec 								; add size +1 hence SEC
.8b5a		71 30		adc ($30),y			adc 	(codePtr),y
.8b5c		a8		tay				tay 								; make current position.
.8b5d						_RMExit:
.8b5d		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/repeat.asm

.8b5e						Command_REPEAT:
.8b5e		a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; allocate 6 bytes on the return stack.
.8b60		20 12 a7	jsr $a712			jsr 	StackOpen
.8b63		20 57 a7	jsr $a757			jsr 	STKSaveCodePosition 		; save loop position
.8b66		60		rts				rts
.8b67						Command_UNTIL:
.8b67		a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; check REPEAT is TOS
.8b69		a2 0f		ldx #$0f			ldx 	#ERRID_REPEAT 				; this error
.8b6b		20 3f a7	jsr $a73f			jsr 	StackCheckFrame
.8b6e		a2 00		ldx #$00			ldx 	#0
.8b70		20 be 9d	jsr $9dbe			jsr 	EvaluateNumber 				; work out the number
.8b73		20 92 9e	jsr $9e92			jsr 	NSMIsZero 					; check if zero
.8b76		f0 04		beq $8b7c			beq 	_CULoopBack 				; if so keep looping
.8b78		20 31 a7	jsr $a731			jsr 	StackClose		 			; return
.8b7b		60		rts				rts
.8b7c						_CULoopBack:
.8b7c		20 68 a7	jsr $a768			jsr 	STKLoadCodePosition 		; loop back
.8b7f		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/restore.asm

.8b80						Command_Restore:
.8b80		20 97 8b	jsr $8b97			jsr 	SwapDataCodePtrs 			; swap code and data
.8b83		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8b85		85 30		sta $30				sta 	codePtr
.8b87		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8b89		85 31		sta $31				sta 	codePtr+1
.8b8b		20 97 8b	jsr $8b97			jsr 	SwapDataCodePtrs 			; put them back
.8b8e		a9 03		lda #$03			lda 	#3 							; start at offset 3, e.g. first instruction of first line.
.8b90		8d 1b 04	sta $041b			sta 	dataPointer+4   			; (read checks not EOF)
.8b93		9c 1c 04	stz $041c			stz 	inDataStatement 			; not in data statement
.8b96		60		rts				rts
.8b97						SwapDataCodePtrs:
.8b97		da		phx				phx
.8b98		a2 03		ldx #$03			ldx 	#3 							; swap 32 bit code pointer over
.8b9a						_SDCPLoop:
.8b9a		b5 30		lda $30,x			lda 	safePtr,x
.8b9c		48		pha				pha
.8b9d		bd 17 04	lda $0417,x			lda 	dataPointer,x
.8ba0		95 30		sta $30,x			sta 	safePtr,x
.8ba2		68		pla				pla
.8ba3		9d 17 04	sta $0417,x			sta 	dataPointer,x
.8ba6		ca		dex				dex
.8ba7		10 f1		bpl $8b9a			bpl 	_SDCPLoop
.8ba9		ad 1b 04	lda $041b			lda 	dataPointer+4 				; swap Y position over.
.8bac		8c 1b 04	sty $041b			sty 	dataPointer+4
.8baf		a8		tay				tay
.8bb0		fa		plx				plx
.8bb1		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/run.asm

.8bb2						EOLCommand:
.8bb2		18		clc				clc
.8bb3		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8bb5		65 30		adc $30				adc 	codePtr
.8bb7		85 30		sta $30				sta 	codePtr
.8bb9		90 02		bcc $8bbd			bcc 	_CREExit
.8bbb		e6 31		inc $31				inc 	codePtr+1 					; carry
.8bbd						_CREExit:
.8bbd		80 0b		bra $8bca			bra 	RunNewLine
.8bbf						CommandRUN:
.8bbf		20 bd 84	jsr $84bd			jsr 	ClearCommand 				; clear variable/stacks/etc.
.8bc2		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8bc4		85 30		sta $30				sta 	codePtr
.8bc6		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8bc8		85 31		sta $31				sta 	codePtr+1
.8bca						RUNNewLine:
.8bca		b2 30		lda ($30)			lda 	(codePtr)
.8bcc		f0 7b		beq $8c49			beq 	CRNoProgram         		; no then END.
.8bce		a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack
.8bd0		9a		txs				txs
.8bd1						RUNCodePointerLine:
.8bd1		a0 02		ldy #$02			ldy 	#2 							; start of program
.8bd3						_CRIncMainLoop:
.8bd3		0e 13 04	asl $0413			asl 	breakCheck 					; clears 1 time in 8
.8bd6		d0 22		bne $8bfa			bne 	_CRNoBreakCheck
.8bd8		ce 13 04	dec $0413			dec	 	breakCheck 					; set it back to $FF
.8bdb		20 21 80	jsr $8021			jsr 	EXTBreakCheck 				; break check
.8bde		f0 64		beq $8c44			beq 	_CRBreak
.8be0		a5 01		lda $01				lda 	1 							; save I/O 0
.8be2		48		pha				pha
.8be3		64 01		stz $01				stz 	1 							; access I/O Page 0
.8be5		38		sec				sec 								; calculate timer - LastTick
.8be6		ad 59 d6	lda $d659			lda 	$D659
.8be9		aa		tax				tax 								; saving timer in X
.8bea		ed 5c 06	sbc $065c			sbc 	LastTick
.8bed		c9 03		cmp #$03			cmp 	#3
.8bef		90 06		bcc $8bf7			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.8bf1		8e 5c 06	stx $065c			stx 	LastTick 					; update last timer
.8bf4		20 9b 9e	jsr $9e9b			jsr 	TickHandler 							; go do the code.
.8bf7						_NoFireTick:
.8bf7		68		pla				pla 								; restore I/O 0
.8bf8		85 01		sta $01				sta 	1
.8bfa						_CRNoBreakCheck:
.8bfa		c8		iny				iny									; next token
.8bfb						_CRMainLoop:
.8bfb		9c 10 04	stz $0410			stz 	stringInitialised 			; clear the temporary string initialised flag.
.8bfe		b1 30		lda ($30),y			lda 	(codePtr),y
.8c00		10 10		bpl $8c12			bpl 	_CRNotKeyword				; not a token.
.8c02		c9 a2		cmp #$a2			cmp 	#KWC_LAST_UNARY+1 			; if after unary, legitimate command
.8c04		b0 04		bcs $8c0a			bcs 	_CRIsKeyword
.8c06		c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if unary, syntax error.
.8c08		b0 34		bcs $8c3e			bcs		_CRSyntaxError
.8c0a						_CRIsKeyword:
.8c0a		c8		iny				iny 								; consume command
.8c0b		0a		asl a				asl 	a 							; double losing the MSB which is '1' as tokens are $80-$FF
.8c0c		aa		tax				tax 								; put in X for vector jump
.8c0d		20 41 8c	jsr $8c41			jsr 	_CRCallVector0 				; call the vector - effectively jsr (vectortable,X)
.8c10		80 e9		bra $8bfb			bra 	_CRMainLoop 				; and loop round
.8c12						_CRNotKeyword:
.8c12		c9 3a		cmp #$3a			cmp 	#KWD_COLON 					; if a :, consume it and go round.
.8c14		f0 bd		beq $8bd3			beq 	_CRIncMainLoop
.8c16		c9 40		cmp #$40			cmp 	#$40 						; variable/call reference
.8c18		90 05		bcc $8c1f			bcc 	_CRNotVariable
.8c1a						_CRGoLet:
.8c1a		20 66 88	jsr $8866			jsr 	LetCommand
.8c1d		80 dc		bra $8bfb			bra 	_CRMainLoop
.8c1f						_CRNotVariable:
.8c1f		c9 10		cmp #$10			cmp 	#KWD_AT 					; handle @
.8c21		f0 f7		beq $8c1a			beq 	_CRGoLet
.8c23		c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; handle ? !
.8c25		f0 f3		beq $8c1a			beq 	_CRGoLet
.8c27		c9 21		cmp #$21			cmp 	#KWD_PLING
.8c29		f0 ef		beq $8c1a			beq 	_CRGoLet
.8c2b		c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; handle ' (comment)
.8c2d		f0 09		beq $8c38			beq 	_CRGoRem
.8c2f		c9 2e		cmp #$2e			cmp 	#KWD_PERIOD 				; handle . (assembler label)
.8c31		d0 0b		bne $8c3e			bne 	_CRSyntaxError
.8c33		20 a1 82	jsr $82a1			jsr 	LabelHere
.8c36		80 c3		bra $8bfb			bra 	_CRMainLoop
.8c38						_CRGoRem:
.8c38		c8		iny				iny
.8c39		20 51 8b	jsr $8b51			jsr 	RemCommand
.8c3c		80 bd		bra $8bfb			bra 	_CRMainLoop
.8c3e						_CRSyntaxError:
.8c3e		4c ee 9f	jmp $9fee			jmp 	SyntaxError
.8c41						_CRCallVector0:
.8c41		7c e0 8c	jmp ($8ce0,x)			jmp 	(VectorSet0,x)
.8c44						_CRBreak:
.8c44		a9 01		lda #$01		lda	#1
.8c46		4c 49 8f	jmp $8f49		jmp	ErrorHandler
.8c49						CRNoProgram:
.8c49		4c 0b 86	jmp $860b			jmp 	EndCommand
.8c4c						Shift1Command:
.8c4c		b1 30		lda ($30),y			lda 	(codePtr),y
.8c4e		c8		iny				iny
.8c4f		0a		asl a				asl 	a
.8c50		aa		tax				tax
.8c51		7c 86 8d	jmp ($8d86,x)			jmp 	(VectorSet1,x)
.8c54						Shift2Command:
.8c54		b1 30		lda ($30),y			lda 	(codePtr),y
.8c56		c8		iny				iny
.8c57		0a		asl a				asl 	a
.8c58		aa		tax				tax
.8c59		7c ac 8d	jmp ($8dac,x)			jmp 	(VectorSet2,x)
.8c5c						Unused1:
.8c5c						Unused2:
.8c5c						Unused3:
.8c5c						Unused4:
.8c5c		4c ee 9f	jmp $9fee			jmp 	SyntaxError
>8c5f								.align 2

;******  Processing file: ./common/commands/../generated/vectors.dat

.8c60						VectorSetPunc:
>8c60		01 92					.word	ShiftLeft                        ; $00 <<
>8c62		ec 8f					.word	BinaryCompareLessEqual           ; $01 <=
>8c64		e2 8f					.word	BinaryCompareNotEqual            ; $02 <>
>8c66		ee 9f					.word	SyntaxError                      ; $03 !!3
>8c68		ee 9f					.word	SyntaxError                      ; $04 ><
>8c6a		f6 8f					.word	BinaryCompareGreaterEqual        ; $05 >=
>8c6c		04 92					.word	ShiftRight                       ; $06 >>
>8c6e		ee 9f					.word	SyntaxError                      ; $07 !!7
>8c70		ee 9f					.word	SyntaxError                      ; $08 !!8
>8c72		ee 9f					.word	SyntaxError                      ; $09 !!9
>8c74		ee 9f					.word	SyntaxError                      ; $0a !!10
>8c76		ee 9f					.word	SyntaxError                      ; $0b !!11
>8c78		ee 9f					.word	SyntaxError                      ; $0c !!12
>8c7a		ee 9f					.word	SyntaxError                      ; $0d !!13
>8c7c		ee 9f					.word	SyntaxError                      ; $0e !!14
>8c7e		ee 9f					.word	SyntaxError                      ; $0f !!15
>8c80		ee 9f					.word	SyntaxError                      ; $10 @
>8c82		ee 9f					.word	SyntaxError                      ; $11 !!17
>8c84		ee 9f					.word	SyntaxError                      ; $12 !!18
>8c86		ee 9f					.word	SyntaxError                      ; $13 [
>8c88		ad 90					.word	IntegerDivide                    ; $14 \
>8c8a		ee 9f					.word	SyntaxError                      ; $15 ]
>8c8c		3f 93					.word	EorInteger                       ; $16 ^
>8c8e		ee 9f					.word	SyntaxError                      ; $17 _
>8c90		ee 9f					.word	SyntaxError                      ; $18 `
>8c92		ee 9f					.word	SyntaxError                      ; $19 !!25
>8c94		ee 9f					.word	SyntaxError                      ; $1a !!26
>8c96		ee 9f					.word	SyntaxError                      ; $1b {
>8c98		0a 93					.word	OraInteger                       ; $1c |
>8c9a		ee 9f					.word	SyntaxError                      ; $1d }
>8c9c		ee 9f					.word	SyntaxError                      ; $1e ~
>8c9e		ee 9f					.word	SyntaxError                      ; $1f [7m<7F>[m
>8ca0		ee 9f					.word	SyntaxError                      ; $20
>8ca2		74 93					.word	WordIndirect                     ; $21 !
>8ca4		ee 9f					.word	SyntaxError                      ; $22 "
>8ca6		ee 9f					.word	SyntaxError                      ; $23 #
>8ca8		ee 9f					.word	SyntaxError                      ; $24 $
>8caa		ee 90					.word	IntegerModulus                   ; $25 %
>8cac		d5 92					.word	AndInteger                       ; $26 &
>8cae		ee 9f					.word	SyntaxError                      ; $27 '
>8cb0		ee 9f					.word	SyntaxError                      ; $28 (
>8cb2		ee 9f					.word	SyntaxError                      ; $29 )
>8cb4		5c 91					.word	MulInteger                       ; $2a *
>8cb6		77 92					.word	AddInteger                       ; $2b +
>8cb8		ee 9f					.word	SyntaxError                      ; $2c ,
>8cba		b0 92					.word	SubInteger                       ; $2d -
>8cbc		ee 9f					.word	SyntaxError                      ; $2e .
>8cbe		2e 95					.word	FDivideCommand                   ; $2f /
>8cc0		ee 9f					.word	SyntaxError                      ; $30 0
>8cc2		ee 9f					.word	SyntaxError                      ; $31 1
>8cc4		ee 9f					.word	SyntaxError                      ; $32 2
>8cc6		ee 9f					.word	SyntaxError                      ; $33 3
>8cc8		ee 9f					.word	SyntaxError                      ; $34 4
>8cca		ee 9f					.word	SyntaxError                      ; $35 5
>8ccc		ee 9f					.word	SyntaxError                      ; $36 6
>8cce		ee 9f					.word	SyntaxError                      ; $37 7
>8cd0		ee 9f					.word	SyntaxError                      ; $38 8
>8cd2		ee 9f					.word	SyntaxError                      ; $39 9
>8cd4		ee 9f					.word	SyntaxError                      ; $3a :
>8cd6		ee 9f					.word	SyntaxError                      ; $3b ;
>8cd8		ce 8f					.word	BinaryCompareLess                ; $3c <
>8cda		c4 8f					.word	BinaryCompareEqual               ; $3d =
>8cdc		d8 8f					.word	BinaryCompareGreater             ; $3e >
>8cde		96 93					.word	ByteIndirect                     ; $3f ?
.8ce0						VectorSet0:
>8ce0		b2 8b					.word	EOLCommand                       ; $80 !0:EOF
>8ce2		4c 8c					.word	Shift1Command                    ; $81 !1:SH1
>8ce4		54 8c					.word	Shift2Command                    ; $82 !2:SH2
>8ce6		18 9a					.word	AbsUnary                         ; $83 ABS(
>8ce8		26 9a					.word	AllocUnary                       ; $84 ALLOC(
>8cea		96 9a					.word	AscUnary                         ; $85 ASC(
>8cec		56 9c					.word	ChrUnary                         ; $86 CHR$(
>8cee		a6 9a					.word	DeekUnary                        ; $87 DEEK(
>8cf0		4e a4					.word	UnaryEvent                       ; $88 EVENT(
>8cf2		c0 8f					.word	UnaryFalse                       ; $89 FALSE
>8cf4		b8 9a					.word	FracUnary                        ; $8a FRAC(
>8cf6		ea a3					.word	UnaryHit                         ; $8b HIT(
>8cf8		cd 9a					.word	IntUnary                         ; $8c INT(
>8cfa		15 9c					.word	IsValUnary                       ; $8d ISVAL(
>8cfc		d2 a4					.word	UnaryJoyB                        ; $8e JOYB(
>8cfe		ab a4					.word	UnaryJoyX                        ; $8f JOYX(
>8d00		ae a4					.word	UnaryJoyY                        ; $90 JOYY(
>8d02		29 9d					.word	Unary_Left                       ; $91 LEFT$(
>8d04		de 9a					.word	LenUnary                         ; $92 LEN(
>8d06		fc 9a					.word	Unary_Max                        ; $93 MAX(
>8d08		4b 9d					.word	Unary_Mid                        ; $94 MID$(
>8d0a		f8 9a					.word	Unary_Min                        ; $95 MIN(
>8d0c		47 9b					.word	Unary_Not                        ; $96 NOT(
>8d0e		a3 9a					.word	PeekUnary                        ; $97 PEEK(
>8d10		6f a6					.word	UnaryPlaying                     ; $98 PLAYING(
>8d12		5a 9b					.word	Unary_Random                     ; $99 RANDOM(
>8d14		36 9d					.word	Unary_Right                      ; $9a RIGHT$(
>8d16		77 9b					.word	Unary_Rnd                        ; $9b RND(
>8d18		ed 9b					.word	SgnUnary                         ; $9c SGN(
>8d1a		68 9c					.word	SpcUnary                         ; $9d SPC(
>8d1c		83 9c					.word	Unary_Str                        ; $9e STR$(
>8d1e		f8 a4					.word	UnaryTimer                       ; $9f TIMER(
>8d20		b5 8f					.word	UnaryTrue                        ; $a0 TRUE
>8d22		0b 9c					.word	ValUnary                         ; $a1 VAL(
>8d24		0e 86					.word	ForCommand                       ; $a2 FOR
>8d26		51 87					.word	IfCommand                        ; $a3 IF
>8d28		5c 8c					.word	Unused1                          ; $a4 PROC
>8d2a		5e 8b					.word	Command_REPEAT                   ; $a5 REPEAT
>8d2c		01 8f					.word	Command_WHILE                    ; $a6 WHILE
>8d2e		7a 87					.word	EndIf                            ; $a7 ENDIF
>8d30		e6 8a					.word	Command_ENDPROC                  ; $a8 ENDPROC
>8d32		c0 86					.word	NextCommand                      ; $a9 NEXT
>8d34		5c 8c					.word	Unused4                          ; $aa THEN
>8d36		67 8b					.word	Command_UNTIL                    ; $ab UNTIL
>8d38		22 8f					.word	Command_WEND                     ; $ac WEND
>8d3a		ee 9f					.word	SyntaxError                      ; $ad BY
>8d3c		88 84					.word	CallCommand                      ; $ae CALL
>8d3e		9e a1					.word	CircleCommand                    ; $af CIRCLE
>8d40		bd 84					.word	ClearCommand                     ; $b0 CLEAR
>8d42		15 85					.word	ClearScreen                      ; $b1 CLS
>8d44		ee 9f					.word	SyntaxError                      ; $b2 COLOR
>8d46		ee 9f					.word	SyntaxError                      ; $b3 COLOUR
>8d48		1d 85					.word	Command_Data                     ; $b4 DATA
>8d4a		25 85					.word	DimCommand                       ; $b5 DIM
>8d4c		e5 85					.word	DokeCommand                      ; $b6 DOKE
>8d4e		5c 8c					.word	Unused3                          ; $b7 DOWNTO
>8d50		73 87					.word	ElseCode                         ; $b8 ELSE
>8d52		ee 9f					.word	SyntaxError                      ; $b9 FROM
>8d54		bd a3					.word	GfxCommand                       ; $ba GFX
>8d56		19 87					.word	Command_GOSUB                    ; $bb GOSUB
>8d58		37 87					.word	GotoCommand                      ; $bc GOTO
>8d5a		ee 9f					.word	SyntaxError                      ; $bd HERE
>8d5c		c7 a1					.word	ImageCommand                     ; $be IMAGE
>8d5e		7b 87					.word	Command_Input                    ; $bf INPUT
>8d60		66 88					.word	LetCommand                       ; $c0 LET
>8d62		19 a2					.word	LineCommand                      ; $c1 LINE
>8d64		b7 89					.word	Command_LOCAL                    ; $c2 LOCAL
>8d66		ee 9f					.word	SyntaxError                      ; $c3 OFF
>8d68		ee 9f					.word	SyntaxError                      ; $c4 ON
>8d6a		ee 9f					.word	SyntaxError                      ; $c5 OUTLINE
>8d6c		0e a4					.word	PaletteCommand                   ; $c6 PALETTE
>8d6e		12 a2					.word	PlotCommand                      ; $c7 PLOT
>8d70		e2 85					.word	PokeCommand                      ; $c8 POKE
>8d72		82 87					.word	Command_Print                    ; $c9 PRINT
>8d74		f4 8a					.word	Command_Read                     ; $ca READ
>8d76		9a a1					.word	RectangleCommand                 ; $cb RECT
>8d78		51 8b					.word	RemCommand                       ; $cc REM
>8d7a		29 87					.word	Command_RETURN                   ; $cd RETURN
>8d7c		ee 9f					.word	SyntaxError                      ; $ce SOLID
>8d7e		8b a6					.word	SoundCommand                     ; $cf SOUND
>8d80		a9 a1					.word	SpriteCommand                    ; $d0 SPRITE
>8d82		e3 a1					.word	TextCommand                      ; $d1 TEXT
>8d84		5c 8c					.word	Unused2                          ; $d2 TO
.8d86						VectorSet1:
>8d86		ee 9f					.word	SyntaxError                      ; $80 !0:EOF
>8d88		ee 9f					.word	SyntaxError                      ; $81 !1:SH1
>8d8a		ee 9f					.word	SyntaxError                      ; $82 !2:SH2
>8d8c		5c 84					.word	AssembleCommand                  ; $83 ASSEMBLE
>8d8e		78 84					.word	AssertCommand                    ; $84 ASSERT
>8d90		5d a3					.word	BitmapCtrl                       ; $85 BITMAP
>8d92		0b 86					.word	EndCommand                       ; $86 END
>8d94		43 a6					.word	Explode                          ; $87 EXPLODE
>8d96		ef a4					.word	GoCommand                        ; $88 GO
>8d98		b6 88					.word	Command_List                     ; $89 LIST
>8d9a		e6 a4					.word	LoadCommand                      ; $8a LOAD
>8d9c		78 8a					.word	NewCommand                       ; $8b NEW
>8d9e		1f a6					.word	PingCommand                      ; $8c PING
>8da0		80 8b					.word	Command_Restore                  ; $8d RESTORE
>8da2		bf 8b					.word	CommandRUN                       ; $8e RUN
>8da4		37 a6					.word	ShootCommand                     ; $8f SHOOT
>8da6		a2 a3					.word	SpritesCtrl                      ; $90 SPRITES
>8da8		34 8e					.word	StopCommand                      ; $91 STOP
>8daa		2b a6					.word	ZapCommand                       ; $92 ZAP
.8dac						VectorSet2:
>8dac		ee 9f					.word	SyntaxError                      ; $80 !0:EOF
>8dae		ee 9f					.word	SyntaxError                      ; $81 !1:SH1
>8db0		ee 9f					.word	SyntaxError                      ; $82 !2:SH2
>8db2		ad 9e					.word	Assemble_adc                     ; $83 ADC
>8db4		a5 9e					.word	Assemble_and                     ; $84 AND
>8db6		c1 9e					.word	Assemble_asl                     ; $85 ASL
>8db8		2b 9f					.word	Assemble_bcc                     ; $86 BCC
>8dba		2f 9f					.word	Assemble_bcs                     ; $87 BCS
>8dbc		37 9f					.word	Assemble_beq                     ; $88 BEQ
>8dbe		ee 9e					.word	Assemble_bit                     ; $89 BIT
>8dc0		1f 9f					.word	Assemble_bmi                     ; $8a BMI
>8dc2		33 9f					.word	Assemble_bne                     ; $8b BNE
>8dc4		1b 9f					.word	Assemble_bpl                     ; $8c BPL
>8dc6		3b 9f					.word	Assemble_bra                     ; $8d BRA
>8dc8		3f 9f					.word	Assemble_brk                     ; $8e BRK
>8dca		23 9f					.word	Assemble_bvc                     ; $8f BVC
>8dcc		27 9f					.word	Assemble_bvs                     ; $90 BVS
>8dce		47 9f					.word	Assemble_clc                     ; $91 CLC
>8dd0		9b 9f					.word	Assemble_cld                     ; $92 CLD
>8dd2		5b 9f					.word	Assemble_cli                     ; $93 CLI
>8dd4		8b 9f					.word	Assemble_clv                     ; $94 CLV
>8dd6		b9 9e					.word	Assemble_cmp                     ; $95 CMP
>8dd8		02 9f					.word	Assemble_cpx                     ; $96 CPX
>8dda		fd 9e					.word	Assemble_cpy                     ; $97 CPY
>8ddc		df 9e					.word	Assemble_dec                     ; $98 DEC
>8dde		97 9f					.word	Assemble_dex                     ; $99 DEX
>8de0		73 9f					.word	Assemble_dey                     ; $9a DEY
>8de2		a9 9e					.word	Assemble_eor                     ; $9b EOR
>8de4		e4 9e					.word	Assemble_inc                     ; $9c INC
>8de6		a7 9f					.word	Assemble_inx                     ; $9d INX
>8de8		93 9f					.word	Assemble_iny                     ; $9e INY
>8dea		16 9f					.word	Assemble_jmp                     ; $9f JMP
>8dec		11 9f					.word	Assemble_jsr                     ; $a0 JSR
>8dee		b5 9e					.word	Assemble_lda                     ; $a1 LDA
>8df0		da 9e					.word	Assemble_ldx                     ; $a2 LDX
>8df2		f8 9e					.word	Assemble_ldy                     ; $a3 LDY
>8df4		cb 9e					.word	Assemble_lsr                     ; $a4 LSR
>8df6		ab 9f					.word	Assemble_nop                     ; $a5 NOP
>8df8		a1 9e					.word	Assemble_ora                     ; $a6 ORA
>8dfa		57 9f					.word	Assemble_pha                     ; $a7 PHA
>8dfc		43 9f					.word	Assemble_php                     ; $a8 PHP
>8dfe		9f 9f					.word	Assemble_phx                     ; $a9 PHX
>8e00		5f 9f					.word	Assemble_phy                     ; $aa PHY
>8e02		67 9f					.word	Assemble_pla                     ; $ab PLA
>8e04		4b 9f					.word	Assemble_plp                     ; $ac PLP
>8e06		b3 9f					.word	Assemble_plx                     ; $ad PLX
>8e08		6f 9f					.word	Assemble_ply                     ; $ae PLY
>8e0a		c6 9e					.word	Assemble_rol                     ; $af ROL
>8e0c		d0 9e					.word	Assemble_ror                     ; $b0 ROR
>8e0e		53 9f					.word	Assemble_rti                     ; $b1 RTI
>8e10		63 9f					.word	Assemble_rts                     ; $b2 RTS
>8e12		bd 9e					.word	Assemble_sbc                     ; $b3 SBC
>8e14		4f 9f					.word	Assemble_sec                     ; $b4 SEC
>8e16		af 9f					.word	Assemble_sed                     ; $b5 SED
>8e18		6b 9f					.word	Assemble_sei                     ; $b6 SEI
>8e1a		b1 9e					.word	Assemble_sta                     ; $b7 STA
>8e1c		a3 9f					.word	Assemble_stp                     ; $b8 STP
>8e1e		d5 9e					.word	Assemble_stx                     ; $b9 STX
>8e20		f3 9e					.word	Assemble_sty                     ; $ba STY
>8e22		e9 9e					.word	Assemble_stz                     ; $bb STZ
>8e24		87 9f					.word	Assemble_tax                     ; $bc TAX
>8e26		83 9f					.word	Assemble_tay                     ; $bd TAY
>8e28		0c 9f					.word	Assemble_trb                     ; $be TRB
>8e2a		07 9f					.word	Assemble_tsb                     ; $bf TSB
>8e2c		8f 9f					.word	Assemble_tsx                     ; $c0 TSX
>8e2e		77 9f					.word	Assemble_txa                     ; $c1 TXA
>8e30		7f 9f					.word	Assemble_txs                     ; $c2 TXS
>8e32		7b 9f					.word	Assemble_tya                     ; $c3 TYA

;******  Return to file: ./common/commands/run.asm


;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/stop.asm

.8e34						StopCommand:
.8e34		a9 08		lda #$08		lda	#8
.8e36		4c 49 8f	jmp $8f49		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/procscan.asm

.8e39						ProcedureScan:
.8e39		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8e3b		85 30		sta $30				sta 	codePtr
.8e3d		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8e3f		85 31		sta $31				sta 	codePtr+1
.8e41						_PSLoop:
.8e41		b2 30		lda ($30)			lda 	(codePtr)
.8e43		f0 42		beq $8e87			beq 	_PSExit
.8e45		a0 03		ldy #$03			ldy 	#3 							; is it PROC at start of line ?
.8e47		b1 30		lda ($30),y			lda 	(codePtr),y
.8e49		c9 a4		cmp #$a4			cmp 	#KWD_PROC
.8e4b		d0 2d		bne $8e7a			bne 	_PSNext
.8e4d		c8		iny				iny 								; get the address of the record to zTemp0 and
.8e4e		b1 30		lda ($30),y			lda 	(codePtr),y
.8e50		29 c0		and #$c0			and 	#$C0
.8e52		c9 40		cmp #$40			cmp 	#$40
.8e54		d0 32		bne $8e88			bne 	_PSSyntax
.8e56		b1 30		lda ($30),y			lda 	(codePtr),y
.8e58		18		clc				clc
.8e59		69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8e5b		85 37		sta $37				sta 	zTemp0+1
.8e5d		c8		iny				iny 								; LSB
.8e5e		b1 30		lda ($30),y			lda 	(codePtr),y
.8e60		85 36		sta $36				sta 	zTemp0
.8e62		c8		iny				iny 								; character after variable call.
.8e63		98		tya				tya 								; save Y offset at +7 (exponent slot)
.8e64		a0 07		ldy #$07			ldy 	#7
.8e66		91 36		sta ($36),y			sta 	(zTemp0),y
.8e68		a9 18		lda #$18			lda 	#NSTProcedure 				; mark it as procedure
.8e6a		a0 02		ldy #$02			ldy 	#2
.8e6c		91 36		sta ($36),y			sta 	(zTemp0),y
.8e6e		a2 00		ldx #$00			ldx 	#0 							; copy code-Ptr into offset 3-6 (mantissa)
.8e70						_PSCopy:
.8e70		b5 30		lda $30,x			lda 	safePtr,x
.8e72		c8		iny				iny
.8e73		91 36		sta ($36),y			sta 	(zTemp0),y
.8e75		e8		inx				inx
.8e76		e0 04		cpx #$04			cpx 	#4
.8e78		d0 f6		bne $8e70			bne 	_PSCopy
.8e7a						_PSNext:
.8e7a		18		clc				clc
.8e7b		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8e7d		65 30		adc $30				adc 	codePtr
.8e7f		85 30		sta $30				sta 	codePtr
.8e81		90 02		bcc $8e85			bcc 	_CREExit
.8e83		e6 31		inc $31				inc 	codePtr+1 					; carry
.8e85						_CREExit:
.8e85		80 ba		bra $8e41			bra 	_PSLoop
.8e87						_PSExit:
.8e87		60		rts				rts
.8e88						_PSSyntax:
.8e88		4c ee 9f	jmp $9fee			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/scanforward.asm

.8e8b						ScanForward:
.8e8b		64 38		stz $38				stz 	zTemp1 						; zero the structure count - goes up with WHILE/FOR down with WEND/NEXT etc.
.8e8d		86 37		stx $37				stx 	zTemp0+1
.8e8f		85 36		sta $36				sta 	zTemp0 						; save X & A as the two possible matches.
.8e91						_ScanLoop:
.8e91		b1 30		lda ($30),y			lda 	(codePtr),y
.8e93		c8		iny				iny
.8e94		a6 38		ldx $38				ldx 	zTemp1 						; if the count is > 0 cannot match as in substructure
.8e96		d0 0e		bne $8ea6			bne 	_ScanGoNext
.8e98		c5 36		cmp $36				cmp 	zTemp0 						; see if either matches
.8e9a		f0 04		beq $8ea0			beq 	_ScanMatch
.8e9c		c5 37		cmp $37				cmp 	zTemp0+1
.8e9e		d0 06		bne $8ea6			bne 	_ScanGoNext
.8ea0						_ScanMatch:
.8ea0		c9 80		cmp #$80			cmp 	#KWC_EOL 					; if asked for EOL, backtrack.
.8ea2		d0 01		bne $8ea5			bne 	_ScanNotEndEOL
.8ea4		88		dey				dey
.8ea5						_ScanNotEndEOL:
.8ea5		60		rts				rts
.8ea6						_ScanGoNext:
.8ea6		20 ab 8e	jsr $8eab			jsr  	ScanForwardOne 				; allows for shifts and so on.
.8ea9		80 e6		bra $8e91			bra 	_ScanLoop
.8eab						ScanForwardOne:
.8eab		c9 40		cmp #$40			cmp 	#$40 						; if 00-3F, punctuation characters, already done.
.8ead		90 3e		bcc $8eed			bcc 	_SFWExit
.8eaf		c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if 40-82, skip one extra as these are 2 byte
.8eb1		90 18		bcc $8ecb			bcc 	_ScanSkipOne	 			; offsets into the identifier table or shifts.
.8eb3		c9 fc		cmp #$fc			cmp 	#$FC 						; FC-FF are data skips (hex consts, strings etc.)
.8eb5		b0 2f		bcs $8ee6			bcs 	_ScanSkipData
.8eb7		c9 a2		cmp #$a2			cmp 	#KWC_FIRST_STRUCTURE 		; structure keyword ?
.8eb9		90 32		bcc $8eed			bcc 	_SFWExit 					; if not, ordinary keywords.
.8ebb		c9 ad		cmp #$ad			cmp 	#KWC_LAST_STRUCTURE+1
.8ebd		b0 2e		bcs $8eed			bcs 	_SFWExit
.8ebf		c6 38		dec $38				dec 	zTemp1 						; decrement the sructure count
.8ec1		c9 a7		cmp #$a7			cmp 	#KWC_FIRST_STRUCTURE_DEC 	; back if it is a dec structure (e.g. WEND/NEXT)
.8ec3		b0 28		bcs $8eed			bcs 	_SFWExit
.8ec5		e6 38		inc $38				inc 	zTemp1 						; so it's an increment structure
.8ec7		e6 38		inc $38				inc 	zTemp1 						; twice to undo the dec
.8ec9		80 22		bra $8eed			bra 	_SFWExit
.8ecb						_ScanSkipOne:
.8ecb		c8		iny				iny 								; consume the extra one.
.8ecc		c9 80		cmp #$80			cmp 	#KWC_EOL 					; if not EOL loop back
.8ece		d0 1d		bne $8eed			bne 	_SFWExit
.8ed0		18		clc				clc
.8ed1		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8ed3		65 30		adc $30				adc 	codePtr
.8ed5		85 30		sta $30				sta 	codePtr
.8ed7		90 02		bcc $8edb			bcc 	_CREExit
.8ed9		e6 31		inc $31				inc 	codePtr+1 					; carry
.8edb						_CREExit:
.8edb		a0 03		ldy #$03			ldy 	#3 							; scan start position.
.8edd		b2 30		lda ($30)			lda 	(codePtr)
.8edf		d0 0c		bne $8eed			bne 	_SFWExit 					; if not zero, more to scan
.8ee1		a9 13		lda #$13		lda	#19
.8ee3		4c 49 8f	jmp $8f49		jmp	ErrorHandler
.8ee6						_ScanSkipData:
.8ee6		88		dey				dey 								; point at data token
.8ee7		c8		iny				iny 								; point to offset
.8ee8		98		tya				tya 								; A = offset position
.8ee9		38		sec				sec 								; add size +1 hence SEC
.8eea		71 30		adc ($30),y			adc 	(codePtr),y
.8eec		a8		tay				tay 								; make current position.
.8eed						_SFWExit:
.8eed		60		rts				rts
.8eee						ScanGetCurrentLineStep:
.8eee		64 38		stz $38				stz 	zTemp1
.8ef0		a0 03		ldy #$03			ldy 	#3
.8ef2						_SGCLSLoop:
.8ef2		b1 30		lda ($30),y			lda 	(codePtr),y
.8ef4		c8		iny				iny
.8ef5		c9 80		cmp #$80			cmp 	#KWC_EOL	 				; if EOL exit
.8ef7		f0 05		beq $8efe			beq 	_SGCLSExit
.8ef9		20 ab 8e	jsr $8eab			jsr 	ScanForwardOne
.8efc		80 f4		bra $8ef2			bra 	_SGCLSLoop
.8efe						_SGCLSExit:
.8efe		a5 38		lda $38				lda 	zTemp1 						; return the adjustment
.8f00		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/while.asm

.8f01						Command_WHILE:
.8f01		5a		phy				phy 								; save position of the test
.8f02		a2 00		ldx #$00			ldx 	#0 							; work out the while test.
.8f04		20 be 9d	jsr $9dbe			jsr 	EvaluateNumber
.8f07		20 92 9e	jsr $9e92			jsr 	NSMIsZero 					; check if zero
.8f0a		f0 0e		beq $8f1a			beq 	_WHExitLoop 				; if so exit the loop, while has failed.
.8f0c		98		tya				tya 								; position *after* test.
.8f0d		7a		ply				ply 								; restore position before test, at WHILE
.8f0e		88		dey				dey 								; so we execute the WHILE command again.
.8f0f		48		pha				pha 								; push after test on the stack
.8f10		a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; allocate 6 bytes on the return stack.
.8f12		20 12 a7	jsr $a712			jsr 	StackOpen
.8f15		20 57 a7	jsr $a757			jsr 	STKSaveCodePosition 		; save loop position - where the test value expr is.
.8f18		7a		ply				ply 								; restore the position *after* the test
.8f19		60		rts				rts
.8f1a						_WHExitLoop:
.8f1a		68		pla				pla 								; throw post loop position
.8f1b		a9 ac		lda #$ac			lda 	#KWD_WEND 					; scan forward past WEND
.8f1d		aa		tax				tax
.8f1e		20 8b 8e	jsr $8e8b			jsr 	ScanForward
.8f21		60		rts				rts
.8f22						Command_WEND:
.8f22		a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; check WHILE is TOS e.g. in a while loop :)
.8f24		a2 10		ldx #$10			ldx 	#ERRID_WHILE 				; this error if not.
.8f26		20 3f a7	jsr $a73f			jsr 	StackCheckFrame
.8f29		20 68 a7	jsr $a768			jsr 	STKLoadCodePosition 		; loop back to the WHILE keyword.
.8f2c		20 31 a7	jsr $a731			jsr 	StackClose		 			; erase the frame
.8f2f		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/charcheck.asm

.8f30						CheckRightBracket:
.8f30		b1 30		lda ($30),y			lda 	(codePtr),y
.8f32		c8		iny				iny
.8f33		c9 29		cmp #$29			cmp 	#KWD_RPAREN 						; exit if matches
.8f35		d0 0f		bne $8f46			bne 	CNAFail
.8f37		60		rts				rts
.8f38						CheckComma:
.8f38		b1 30		lda ($30),y			lda 	(codePtr),y
.8f3a		c8		iny				iny
.8f3b		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 						; exit if matches
.8f3d		d0 07		bne $8f46			bne 	CNAFail
.8f3f		60		rts				rts
.8f40						CheckNextA:
.8f40		d1 30		cmp ($30),y			cmp 	(codePtr),y
.8f42		d0 02		bne $8f46			bne 	CNAFail
.8f44		c8		iny				iny 								; skip character
.8f45		60		rts				rts 								; and exit
.8f46						CNAFail:
.8f46		4c ee 9f	jmp $9fee			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/errors.asm

.8f49						ErrorHandler:
.8f49		a8		tay				tay 								; find the error text
.8f4a		f0 49		beq $8f95			beq 	_EHEnd
.8f4c		a2 00		ldx #$00			ldx 	#0
.8f4e		a9 07		lda #$07			lda 	#((ErrorText) & $FF)
.8f50		85 36		sta $36				sta 	0+zTemp0
.8f52		a9 a0		lda #$a0			lda 	#((ErrorText) >> 8)
.8f54		85 37		sta $37				sta 	1+zTemp0
.8f56						_EHFind:
.8f56		88		dey				dey 								; keep looking through text
.8f57		f0 0e		beq $8f67			beq 	_EHFound
.8f59						_EHFindZero:
.8f59		b2 36		lda ($36)			lda 	(zTemp0) 					; find the next error
.8f5b		e6 36		inc $36				inc 	zTemp0
.8f5d		d0 02		bne $8f61			bne 	_EHFNoCarry
.8f5f		e6 37		inc $37				inc 	zTemp0+1
.8f61						_EHFNoCarry:
.8f61		c9 00		cmp #$00			cmp 	#0
.8f63		d0 f4		bne $8f59			bne 	_EHFindZero
.8f65		80 ef		bra $8f56			bra 	_EHFind
.8f67						_EHFound:
.8f67		a5 36		lda $36				lda 	zTemp0 						; print message
.8f69		a6 37		ldx $37				ldx 	zTemp0+1
.8f6b		20 a2 8f	jsr $8fa2			jsr 	PrintStringXA
.8f6e		a0 01		ldy #$01			ldy 	#1 							; if line number zero don't print it
.8f70		b1 30		lda ($30),y			lda 	(codePtr),y
.8f72		d0 05		bne $8f79			bne 	_EHAtMsg
.8f74		c8		iny				iny
.8f75		b1 30		lda ($30),y			lda 	(codePtr),y
.8f77		f0 17		beq $8f90			beq 	_EHCREnd
.8f79						_EHAtMsg:
.8f79		a2 8f		ldx #$8f			ldx 	#_AtMsg >> 8 				; print " at "
.8f7b		a9 98		lda #$98			lda 	#_AtMsg & $FF
.8f7d		20 a2 8f	jsr $8fa2			jsr 	PrintStringXA
.8f80		a0 01		ldy #$01			ldy 	#1 							; line number into XA
.8f82		b1 30		lda ($30),y			lda 	(codePtr),y
.8f84		48		pha				pha
.8f85		c8		iny				iny
.8f86		b1 30		lda ($30),y			lda 	(codePtr),y
.8f88		aa		tax				tax
.8f89		68		pla				pla
.8f8a		20 b8 93	jsr $93b8			jsr 	ConvertInt16 				; convert XA to string
.8f8d		20 a2 8f	jsr $8fa2			jsr 	PrintStringXA 				; and print it.
.8f90						_EHCREnd:
.8f90		a9 0d		lda #$0d			lda 	#13 						; new line
.8f92		20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8f95						_EHEnd:
.8f95		4c 27 84	jmp $8427			jmp 	WarmStart
>8f98		20 61 74 20 6c 69 6e 65		_AtMsg:	.text 	" at line ",0
>8fa0		20 00
.8fa2						PrintStringXA:
.8fa2		5a		phy				phy
.8fa3		86 37		stx $37				stx 	zTemp0+1
.8fa5		85 36		sta $36				sta 	zTemp0
.8fa7		a0 00		ldy #$00			ldy 	#0
.8fa9						_PSXALoop:
.8fa9		b1 36		lda ($36),y			lda 	(zTemp0),y
.8fab		f0 06		beq $8fb3			beq 	_PSXAExit
.8fad		20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8fb0		c8		iny				iny
.8fb1		80 f6		bra $8fa9			bra 	_PSXALoop
.8fb3						_PSXAExit:
.8fb3		7a		ply				ply
.8fb4		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/compare.asm

.8fb5						UnaryTrue:
.8fb5		fa		plx				plx
.8fb6						ReturnTrue:
.8fb6		a9 01		lda #$01			lda 	#1  						; set to 1
.8fb8		20 72 9e	jsr $9e72			jsr 	NSMSetByte
.8fbb		a9 80		lda #$80			lda 	#$80 						; set sign flag, so it is -1
.8fbd		95 50		sta $50,x			sta 	NSStatus,x
.8fbf		60		rts				rts
.8fc0						UnaryFalse:
.8fc0		fa		plx				plx
.8fc1						ReturnFalse:
.8fc1		4c 70 9e	jmp $9e70			jmp 	NSMSetZero 					; set it all to zero
.8fc4						BinaryCompareEqual:
.8fc4		fa		plx				plx
.8fc5		20 00 90	jsr $9000			jsr 	CompareBaseCode
.8fc8		c9 00		cmp #$00			cmp 	#0
.8fca		f0 ea		beq $8fb6			beq 	ReturnTrue
.8fcc		80 f3		bra $8fc1			bra 	ReturnFalse
.8fce						BinaryCompareLess:
.8fce		fa		plx				plx
.8fcf		20 00 90	jsr $9000			jsr 	CompareBaseCode
.8fd2		c9 ff		cmp #$ff			cmp 	#$FF
.8fd4		f0 e0		beq $8fb6			beq 	ReturnTrue
.8fd6		80 e9		bra $8fc1			bra 	ReturnFalse
.8fd8						BinaryCompareGreater:
.8fd8		fa		plx				plx
.8fd9		20 00 90	jsr $9000			jsr 	CompareBaseCode
.8fdc		c9 01		cmp #$01			cmp 	#1
.8fde		f0 d6		beq $8fb6			beq 	ReturnTrue
.8fe0		80 df		bra $8fc1			bra 	ReturnFalse
.8fe2						BinaryCompareNotEqual:
.8fe2		fa		plx				plx
.8fe3		20 00 90	jsr $9000			jsr 	CompareBaseCode
.8fe6		c9 00		cmp #$00			cmp 	#0
.8fe8		d0 cc		bne $8fb6			bne 	ReturnTrue
.8fea		80 d5		bra $8fc1			bra 	ReturnFalse
.8fec						BinaryCompareLessEqual:
.8fec		fa		plx				plx
.8fed		20 00 90	jsr $9000			jsr 	CompareBaseCode
.8ff0		c9 01		cmp #$01			cmp 	#1
.8ff2		d0 c2		bne $8fb6			bne 	ReturnTrue
.8ff4		80 cb		bra $8fc1			bra 	ReturnFalse
.8ff6						BinaryCompareGreaterEqual:
.8ff6		fa		plx				plx
.8ff7		20 00 90	jsr $9000			jsr 	CompareBaseCode
.8ffa		c9 ff		cmp #$ff			cmp 	#$FF
.8ffc		d0 b8		bne $8fb6			bne 	ReturnTrue
.8ffe		80 c1		bra $8fc1			bra 	ReturnFalse
.9000						CompareBaseCode:
.9000		20 0b 97	jsr $970b			jsr 	DereferenceTopTwo 			; make both values if references.
.9003		b5 50		lda $50,x			lda 	NSStatus,x 					; check if either is a string.
.9005		15 51		ora $51,x			ora 	NSStatus+1,x
.9007		29 10		and #$10			and 	#NSTString
.9009		d0 37		bne $9042			bne 	_CBCString 					; if so do string code, which will check if both.
.900b		b5 78		lda $78,x			lda 	NSExponent,x 				; check both are integers
.900d		15 79		ora $79,x			ora 	NSExponent+1,x
.900f		d0 34		bne $9045			bne 	_CBCFloat
.9011		b5 50		lda $50,x			lda 	NSStatus,x
.9013		15 51		ora $51,x			ora 	NSStatus+1,x
.9015		29 08		and #$08			and 	#NSTFloat
.9017		d0 2c		bne $9045			bne 	_CBCFloat
.9019		20 48 90	jsr $9048			jsr 	CompareFixMinusZero 		; fix up -0 just in cases.
.901c		e8		inx				inx
.901d		20 48 90	jsr $9048			jsr 	CompareFixMinusZero
.9020		ca		dex				dex
.9021		b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs different ?
.9023		55 51		eor $51,x			eor 	NSStatus+1,x
.9025		10 0a		bpl $9031			bpl 	_CDCSameSign
.9027		b5 50		lda $50,x			lda 	NSStatus,x 					; if first one is -ve
.9029		30 14		bmi $903f			bmi 	_CBCLess 					; return $FF
.902b						_CBCGreater:
.902b		a9 01		lda #$01			lda 	#1
.902d		60		rts				rts
.902e						_CBCEqual:
.902e		a9 00		lda #$00			lda 	#0
.9030		60		rts				rts
.9031						_CDCSameSign:
.9031		20 5d 92	jsr $925d			jsr 	SubTopTwoStack 				; unsigned subtract
.9034		20 92 9e	jsr $9e92			jsr 	NSMIsZero 					; or the mantissa together
.9037		f0 f5		beq $902e			beq 	_CBCEqual 					; -0 == 0
.9039		b5 70		lda $70,x			lda 	NSMantissa3,x 				; sign of the result. if +ve return $01 else return $FF
.903b		55 51		eor $51,x			eor 	NSStatus+1,x 				; however if both were -ve this is inverted
.903d		10 ec		bpl $902b			bpl 	_CBCGreater
.903f						_CBCLess:
.903f		a9 ff		lda #$ff			lda 	#$FF
.9041		60		rts				rts
.9042						_CBCString:
.9042		4c ce 91	jmp $91ce			jmp 	CompareStrings
.9045						_CBCFloat:
.9045		4c 18 95	jmp $9518			jmp 	CompareFloat
.9048						CompareFixMinusZero:
.9048		20 92 9e	jsr $9e92			jsr 	NSMIsZero
.904b		d0 02		bne $904f			bne 	_CFXMZNotZero
.904d		74 50		stz $50,x			stz 	NSStatus,x
.904f						_CFXMZNotZero:
.904f		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/concat.asm

.9050						StringConcat:
.9050		b5 50		lda $50,x			lda 	NSStatus,x 					; check both strings
.9052		35 51		and $51,x			and 	NSStatus+1,x
.9054		29 18		and #$18			and 	#NSBTypeMask
.9056		c9 10		cmp #$10			cmp 	#NSTString
.9058		d0 50		bne $90aa			bne		_SCType
.905a		64 38		stz $38				stz 	zTemp1 						; counting total length
.905c		e8		inx				inx
.905d		20 7b 90	jsr $907b			jsr 	_SCSetupZ0 					; setup for second
.9060		20 84 90	jsr $9084			jsr 	_SCLengthZ0 				; length for second
.9063		ca		dex				dex
.9064		20 7b 90	jsr $907b			jsr 	_SCSetupZ0 					; setup for first
.9067		20 84 90	jsr $9084			jsr 	_SCLengthZ0 				; length for first
.906a		a5 38		lda $38				lda 	zTemp1 						; allocate memory using total.
.906c		20 02 a8	jsr $a802			jsr 	StringTempAllocate
.906f		20 9b 90	jsr $909b			jsr 	_SCCopy 					; copy first out, using zTemp0 from above
.9072		e8		inx				inx
.9073		20 7b 90	jsr $907b			jsr 	_SCSetupZ0 					; copy second out
.9076		20 9b 90	jsr $909b			jsr 	_SCCopy
.9079		ca		dex				dex
.907a		60		rts				rts
.907b						_SCSetupZ0:
.907b		b5 58		lda $58,x			lda 	NSMantissa0,x
.907d		85 36		sta $36				sta 	zTemp0
.907f		b5 60		lda $60,x			lda 	NSMantissa1,x
.9081		85 37		sta $37				sta 	zTemp0+1
.9083		60		rts				rts
.9084						_SCLengthZ0:
.9084		5a		phy				phy
.9085		a0 00		ldy #$00			ldy 	#0
.9087						_SCLenLoop:
.9087		b1 36		lda ($36),y			lda 	(zTemp0),y
.9089		f0 0e		beq $9099			beq 	_SCLExit
.908b		c8		iny				iny
.908c		e6 38		inc $38				inc 	zTemp1
.908e		a5 38		lda $38				lda	 	zTemp1 						; check string too long.
.9090		c9 fd		cmp #$fd			cmp 	#253
.9092		d0 f3		bne $9087			bne		_SCLenLoop
.9094		a9 09		lda #$09		lda	#9
.9096		4c 49 8f	jmp $8f49		jmp	ErrorHandler
.9099						_SCLExit:
.9099		7a		ply				ply
.909a		60		rts				rts
.909b						_SCCopy:
.909b		5a		phy				phy
.909c		a0 00		ldy #$00			ldy 	#0
.909e						_SCCopyLoop:
.909e		b1 36		lda ($36),y			lda 	(zTemp0),y
.90a0		f0 06		beq $90a8			beq 	_SCCExit
.90a2		20 3b a8	jsr $a83b			jsr 	StringTempWrite
.90a5		c8		iny				iny
.90a6		80 f6		bra $909e			bra 	_SCCopyLoop
.90a8						_SCCExit:
.90a8		7a		ply				ply
.90a9		60		rts				rts
.90aa						_SCType:
.90aa		4c f8 9f	jmp $9ff8			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/divide.asm

.90ad						IntegerDivide:
.90ad		fa		plx				plx
.90ae		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.90b0		15 51		ora $51,x			ora 	NSStatus+1,x
.90b2		0a		asl a				asl 	a 							; shift reference bit into sign bit
.90b3		0a		asl a				asl 	a
.90b4		10 05		bpl $90bb			bpl 	_NotRef
.90b6		48		pha				pha
.90b7		20 0b 97	jsr $970b			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.90ba		68		pla				pla
.90bb						_NotRef:
.90bb		0a		asl a				asl 	a
.90bc		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.90be		15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.90c0		15 79		ora $79,x			ora 	NSExponent+1,x
.90c2		f0 03		beq $90c7			beq 	_IntegerCode 				; if clear, then we have two integers
.90c4		4c f8 9f	jmp $9ff8			jmp 	TypeError 					; anything else, type mismatch.
.90c7						_IntegerCode:
.90c7		20 e1 90	jsr $90e1			jsr 	CheckDivideZero 			; do div zero check
.90ca		20 13 91	jsr $9113			jsr 	Int32Divide 				; do the division
.90cd		20 c4 91	jsr $91c4			jsr 	CalculateSign 				; calculate result sign
.90d0						NSMCopyPlusTwoToZero:
.90d0		b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.90d2		95 58		sta $58,x			sta 	NSMantissa0,x
.90d4		b5 62		lda $62,x			lda 	NSMantissa1+2,x
.90d6		95 60		sta $60,x			sta 	NSMantissa1,x
.90d8		b5 6a		lda $6a,x			lda 	NSMantissa2+2,x
.90da		95 68		sta $68,x			sta 	NSMantissa2,x
.90dc		b5 72		lda $72,x			lda 	NSMantissa3+2,x
.90de		95 70		sta $70,x			sta 	NSMantissa3,x
.90e0		60		rts				rts
.90e1						CheckDivideZero:
.90e1		e8		inx				inx
.90e2		20 92 9e	jsr $9e92			jsr 	NSMIsZero
.90e5		f0 02		beq $90e9			beq 	_CDVError
.90e7		ca		dex				dex
.90e8		60		rts				rts
.90e9						_CDVError:
.90e9		a9 03		lda #$03		lda	#3
.90eb		4c 49 8f	jmp $8f49		jmp	ErrorHandler
.90ee						IntegerModulus:
.90ee		fa		plx				plx
.90ef		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.90f1		15 51		ora $51,x			ora 	NSStatus+1,x
.90f3		0a		asl a				asl 	a 							; shift reference bit into sign bit
.90f4		0a		asl a				asl 	a
.90f5		10 05		bpl $90fc			bpl 	_NotRef
.90f7		48		pha				pha
.90f8		20 0b 97	jsr $970b			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.90fb		68		pla				pla
.90fc						_NotRef:
.90fc		0a		asl a				asl 	a
.90fd		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.90ff		15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9101		15 79		ora $79,x			ora 	NSExponent+1,x
.9103		f0 03		beq $9108			beq 	_IntegerCode 				; if clear, then we have two integers
.9105		4c f8 9f	jmp $9ff8			jmp 	TypeError 					; anything else, type mismatch.
.9108						_IntegerCode:
.9108						IntegerModulusNoCheck:
.9108		20 e1 90	jsr $90e1			jsr 	CheckDivideZero 			; do div zero check
.910b		20 13 91	jsr $9113			jsr 	Int32Divide 				; do the division
.910e		16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.9110		56 50		lsr $50,x			lsr 	NSStatus,x
.9112		60		rts				rts
.9113						Int32Divide:
.9113		48		pha				pha 								; save AXY
.9114		5a		phy				phy
.9115		20 53 9e	jsr $9e53			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.9118		20 6c 9e	jsr $9e6c			jsr 	NSMSetZeroMantissaOnly 		; set S[X] to zero
.911b		a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.911d						_I32DivideLoop:
.911d		e8		inx				inx
.911e		e8		inx				inx
.911f		20 7f 9e	jsr $9e7f			jsr 	NSMShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.9122		ca		dex				dex
.9123		ca		dex				dex
.9124		20 80 9e	jsr $9e80			jsr 	NSMRotateLeft
.9127		20 52 91	jsr $9152			jsr 	DivideCheckSubtract 		; check if subtract possible
.912a		90 02		bcc $912e			bcc 	_I32DivideNoCarryIn
.912c		f6 5a		inc $5a,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.912e						_I32DivideNoCarryIn:
.912e		88		dey				dey 								; loop round till division completed.
.912f		d0 ec		bne $911d			bne 	_I32DivideLoop
.9131		7a		ply				ply 								; restore AXY and exit
.9132		68		pla				pla
.9133		60		rts				rts
.9134						Int32ShiftDivide:
.9134		48		pha				pha 								; save AY
.9135		5a		phy				phy
.9136		e8		inx				inx 								; clear S[X+2]
.9137		e8		inx				inx
.9138		20 70 9e	jsr $9e70			jsr 	NSMSetZero
.913b		ca		dex				dex
.913c		ca		dex				dex
.913d		a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.913f						_I32SDLoop:
.913f		20 52 91	jsr $9152			jsr 	DivideCheckSubtract 		; check if subtract possible
.9142		e8		inx				inx
.9143		e8		inx				inx
.9144		20 80 9e	jsr $9e80			jsr 	NSMRotateLeft				; shift 64 bit FPA left, rotating carry in
.9147		ca		dex				dex
.9148		ca		dex				dex
.9149		20 80 9e	jsr $9e80			jsr 	NSMRotateLeft
.914c		88		dey				dey 	 							; do 31 times
.914d		d0 f0		bne $913f			bne 	_I32SDLoop
.914f		7a		ply				ply 								; restore AY and exit
.9150		68		pla				pla
.9151		60		rts				rts
.9152						DivideCheckSubtract:
.9152		20 5d 92	jsr $925d			jsr 	SubTopTwoStack 				; subtract Stack[X+1] from Stack[X+0]
.9155		b0 04		bcs $915b			bcs 	_DCSExit 					; if carry set, then could do, exit
.9157		20 43 92	jsr $9243			jsr 	AddTopTwoStack 				; add it back in
.915a		18		clc				clc 								; and return False
.915b						_DCSExit:
.915b		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/multiply.asm

.915c						MulInteger:
.915c		fa		plx				plx
.915d		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.915f		15 51		ora $51,x			ora 	NSStatus+1,x
.9161		0a		asl a				asl 	a 							; shift reference bit into sign bit
.9162		0a		asl a				asl 	a
.9163		10 05		bpl $916a			bpl 	_NotRef
.9165		48		pha				pha
.9166		20 0b 97	jsr $970b			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9169		68		pla				pla
.916a						_NotRef:
.916a		0a		asl a				asl 	a 							; put MSB of type into A:7
.916b		30 09		bmi $9176			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.916d		b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.916f		15 79		ora $79,x			ora 	NSExponent+1,x
.9171		f0 06		beq $9179			beq 	_IntegerCode 				; if clear, then we have two integers
.9173		4c da 95	jmp $95da			jmp 	FloatingPointMultiply 							; otherwise at least one float.
.9176						_StringData:
.9176		4c 02 a0	jmp $a002			jmp 	NotDoneError							; at least one string - don't know both are strings.
.9179						_IntegerCode:
.9179		20 86 91	jsr $9186			jsr 	MultiplyShort
.917c		c9 00		cmp #$00			cmp 	#0
.917e		f0 05		beq $9185			beq 	_MIExit
.9180		a9 04		lda #$04		lda	#4
.9182		4c 49 8f	jmp $8f49		jmp	ErrorHandler
.9185						_MIExit:
.9185		60		rts				rts
.9186						MultiplyShort:
.9186		5a		phy				phy 								; save Y
.9187		20 53 9e	jsr $9e53			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.918a		20 6c 9e	jsr $9e6c			jsr 	NSMSetZeroMantissaOnly 		; set mantissa S[X] to zero
.918d		a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.918f						_I32MLoop:
.918f		b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.9191		15 62		ora $62,x			ora 	NSMantissa1+2,x
.9193		15 6a		ora $6a,x			ora 	NSMantissa2+2,x
.9195		15 72		ora $72,x			ora 	NSMantissa3+2,x
.9197		f0 25		beq $91be			beq 	_I32MExit 					; exit if zero
.9199		b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.919b		29 01		and #$01			and 	#1
.919d		f0 0d		beq $91ac			beq 	_I32MNoAdd
.919f		20 43 92	jsr $9243			jsr 	AddTopTwoStack 				; if so add S[X+1] to S[X+0]
.91a2		b5 70		lda $70,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.91a4		10 06		bpl $91ac			bpl 	_I32MNoAdd
.91a6						_I32ShiftRight:
.91a6		20 89 9e	jsr $9e89			jsr 	NSMShiftRight 				; shift S[X] right
.91a9		c8		iny				iny 								; increment shift count
.91aa		80 09		bra $91b5			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.91ac						_I32MNoAdd:
.91ac		34 71		bit $71,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.91ae		70 f6		bvs $91a6			bvs 	_I32ShiftRight 				; instead.
.91b0		e8		inx				inx
.91b1		20 7f 9e	jsr $9e7f			jsr 	NSMShiftLeft 				; shift additive S[X+1] left
.91b4		ca		dex				dex
.91b5						_I32MShiftUpper:
.91b5		e8		inx				inx 								; shift S[X+2] right
.91b6		e8		inx				inx
.91b7		20 89 9e	jsr $9e89			jsr 	NSMShiftRight
.91ba		ca		dex				dex
.91bb		ca		dex				dex
.91bc		80 d1		bra $918f			bra 	_I32MLoop 					; try again.
.91be						_I32MExit:
.91be		20 c4 91	jsr $91c4			jsr 	CalculateSign
.91c1		98		tya				tya 								; shift in A
.91c2		7a		ply				ply 								; restore Y and exit
.91c3		60		rts				rts
.91c4						CalculateSign:
.91c4		b5 50		lda $50,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.91c6		16 50		asl $50,x			asl 	NSStatus,x 					; shift result left
.91c8		55 51		eor $51,x			eor 	NSStatus+1,x
.91ca		0a		asl a				asl 	a 							; shift bit 7 into carry
.91cb		76 50		ror $50,x			ror 	NSStatus,x 					; shift right into status byte.
.91cd		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/scompare.asm

.91ce						CompareStrings:
.91ce		b5 50		lda $50,x			lda 	NSStatus,x 					; check both are strings
.91d0		35 51		and $51,x			and 	NSStatus+1,x
.91d2		29 10		and #$10			and 	#NSBIsString
.91d4		f0 28		beq $91fe			beq 	_CSTypeError
.91d6		b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy string addresses to zTemp0/1
.91d8		85 36		sta $36				sta 	zTemp0
.91da		b5 60		lda $60,x			lda 	NSMantissa1,x
.91dc		85 37		sta $37				sta 	zTemp0+1
.91de		b5 59		lda $59,x			lda 	NSMantissa0+1,x
.91e0		85 38		sta $38				sta 	zTemp1
.91e2		b5 61		lda $61,x			lda 	NSMantissa1+1,x
.91e4		85 39		sta $39				sta 	zTemp1+1
.91e6		5a		phy				phy 								; save Y so we can access strings
.91e7		a0 ff		ldy #$ff			ldy 	#$FF 						; -1 for pre increment.
.91e9						_CSLoop:
.91e9		c8		iny				iny
.91ea		b1 36		lda ($36),y			lda 	(zTemp0),y 					; check if they are the same
.91ec		d1 38		cmp ($38),y			cmp 	(zTemp1),y
.91ee		d0 06		bne $91f6			bne 	_CSDifferent
.91f0		c9 00		cmp #$00			cmp 	#0 							; reached end ?
.91f2		d0 f5		bne $91e9			bne 	_CSLoop 					; still comparing
.91f4						_CSExit:
.91f4		7a		ply				ply 								; reached end, return zero in A from EOS
.91f5		60		rts				rts
.91f6						_CSDifferent:
.91f6		a9 ff		lda #$ff			lda 	#255 						; if < return $FF
.91f8		90 fa		bcc $91f4			bcc		_CSExit
.91fa		a9 01		lda #$01			lda 	#1 							; otherwise return 1.
.91fc		80 f6		bra $91f4			bra 	_CSExit
.91fe						_CSTypeError:
.91fe		4c f8 9f	jmp $9ff8			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/shifts.asm

.9201						ShiftLeft:
.9201		38		sec				sec 								; common code, carry determines which way.
.9202		80 01		bra $9205			bra 	ShiftMain
.9204						ShiftRight:
.9204		18		clc				clc
.9205						ShiftMain:
.9205		fa		plx				plx 								; restore X
.9206		08		php				php 								; save direction
.9207		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9209		15 51		ora $51,x			ora 	NSStatus+1,x
.920b		0a		asl a				asl 	a 							; shift reference bit into sign bit
.920c		0a		asl a				asl 	a
.920d		10 05		bpl $9214			bpl 	_NotRef
.920f		48		pha				pha
.9210		20 0b 97	jsr $970b			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9213		68		pla				pla
.9214						_NotRef:
.9214		0a		asl a				asl 	a
.9215		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9217		15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9219		15 79		ora $79,x			ora 	NSExponent+1,x
.921b		f0 03		beq $9220			beq 	_IntegerCode 				; if clear, then we have two integers
.921d		4c f8 9f	jmp $9ff8			jmp 	TypeError 					; anything else, type mismatch.
.9220						_IntegerCode:
.9220		b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; check number < 32
.9222		29 e0		and #$e0			and 	#$E0
.9224		15 61		ora $61,x			ora 	NSMantissa1+1,x
.9226		15 69		ora $69,x			ora 	NSMantissa2+1,x
.9228		15 71		ora $71,x			ora 	NSMantissa3+1,x
.922a		d0 12		bne $923e			bne 	_SMExit0 					; if >= 32 it will always return zero.
.922c						_SMLoop:
.922c		d6 59		dec $59,x			dec 	NSMantissa0+1,x 			; predecrement, could do << 0
.922e		30 11		bmi $9241			bmi 	_SMExit 					; exit if done.
.9230		28		plp				plp 								; restore direction setting
.9231		08		php				php
.9232		90 05		bcc $9239			bcc 	_SMRight
.9234		20 7f 9e	jsr $9e7f			jsr 	NSMShiftLeft 				; shift left if CS
.9237		80 f3		bra $922c			bra 	_SMLoop
.9239						_SMRight:
.9239		20 89 9e	jsr $9e89			jsr 	NSMShiftRight 				; shift right if CC
.923c		80 ee		bra $922c			bra 	_SMLoop
.923e						_SMExit0:
.923e		20 70 9e	jsr $9e70			jsr 	NSMSetZero 					; return zero.
.9241						_SMExit:
.9241		28		plp				plp 								; throw direction
.9242		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/simple.asm

.9243						AddTopTwoStack:
.9243		18		clc				clc
.9244		b5 58		lda $58,x			lda		NSMantissa0,x
.9246		75 59		adc $59,x			adc 		NSMantissa0+1,x
.9248		95 58		sta $58,x			sta 	NSMantissa0,x
.924a		b5 60		lda $60,x			lda		NSMantissa1,x
.924c		75 61		adc $61,x			adc 		NSMantissa1+1,x
.924e		95 60		sta $60,x			sta 	NSMantissa1,x
.9250		b5 68		lda $68,x			lda		NSMantissa2,x
.9252		75 69		adc $69,x			adc 		NSMantissa2+1,x
.9254		95 68		sta $68,x			sta 	NSMantissa2,x
.9256		b5 70		lda $70,x			lda		NSMantissa3,x
.9258		75 71		adc $71,x			adc 		NSMantissa3+1,x
.925a		95 70		sta $70,x			sta 	NSMantissa3,x
.925c		60		rts				rts
.925d						SubTopTwoStack:
.925d		38		sec				sec
.925e		b5 58		lda $58,x			lda		NSMantissa0,x
.9260		f5 59		sbc $59,x			sbc 		NSMantissa0+1,x
.9262		95 58		sta $58,x			sta 	NSMantissa0,x
.9264		b5 60		lda $60,x			lda		NSMantissa1,x
.9266		f5 61		sbc $61,x			sbc 		NSMantissa1+1,x
.9268		95 60		sta $60,x			sta 	NSMantissa1,x
.926a		b5 68		lda $68,x			lda		NSMantissa2,x
.926c		f5 69		sbc $69,x			sbc 		NSMantissa2+1,x
.926e		95 68		sta $68,x			sta 	NSMantissa2,x
.9270		b5 70		lda $70,x			lda		NSMantissa3,x
.9272		f5 71		sbc $71,x			sbc 		NSMantissa3+1,x
.9274		95 70		sta $70,x			sta 	NSMantissa3,x
.9276		60		rts				rts
.9277						AddInteger:
.9277		fa		plx				plx
.9278		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.927a		15 51		ora $51,x			ora 	NSStatus+1,x
.927c		0a		asl a				asl 	a 							; shift reference bit into sign bit
.927d		0a		asl a				asl 	a
.927e		10 05		bpl $9285			bpl 	_NotRef
.9280		48		pha				pha
.9281		20 0b 97	jsr $970b			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9284		68		pla				pla
.9285						_NotRef:
.9285		0a		asl a				asl 	a 							; put MSB of type into A:7
.9286		30 09		bmi $9291			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9288		b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.928a		15 79		ora $79,x			ora 	NSExponent+1,x
.928c		f0 06		beq $9294			beq 	_IntegerCode 				; if clear, then we have two integers
.928e		4c 8a 94	jmp $948a			jmp 	FloatingPointAdd 							; otherwise at least one float.
.9291						_StringData:
.9291		4c 50 90	jmp $9050			jmp 	StringConcat							; at least one string - don't know both are strings.
.9294						_IntegerCode:
.9294						AddCode:
.9294		b5 50		lda $50,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.9296		55 51		eor $51,x			eor 	NSStatus+1,x
.9298		10 a9		bpl $9243			bpl 	AddTopTwoStack
.929a		20 5d 92	jsr $925d			jsr 	SubTopTwoStack 				; do a physical subtraction
.929d		34 70		bit $70,x			bit 	NSMantissa3,x 				; result is +ve, okay
.929f		10 07		bpl $92a8			bpl 	_AddExit
.92a1		b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign is that of 2nd value
.92a3		95 50		sta $50,x			sta 	NSStatus,x
.92a5		20 39 9e	jsr $9e39			jsr 	NSMNegateMantissa 			; negate the mantissa and exit
.92a8						_AddExit:
.92a8		20 92 9e	jsr $9e92			jsr 	NSMIsZero 					; check for -0
.92ab		d0 02		bne $92af			bne 	_AddNonZero
.92ad		74 50		stz $50,x			stz 	NSStatus,x
.92af						_AddNonZero:
.92af		60		rts				rts
.92b0						SubInteger:
.92b0		fa		plx				plx
.92b1		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.92b3		15 51		ora $51,x			ora 	NSStatus+1,x
.92b5		0a		asl a				asl 	a 							; shift reference bit into sign bit
.92b6		0a		asl a				asl 	a
.92b7		10 05		bpl $92be			bpl 	_NotRef
.92b9		48		pha				pha
.92ba		20 0b 97	jsr $970b			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92bd		68		pla				pla
.92be						_NotRef:
.92be		0a		asl a				asl 	a 							; put MSB of type into A:7
.92bf		30 09		bmi $92ca			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.92c1		b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92c3		15 79		ora $79,x			ora 	NSExponent+1,x
.92c5		f0 06		beq $92cd			beq 	_IntegerCode 				; if clear, then we have two integers
.92c7		4c 8f 94	jmp $948f			jmp 	FloatingPointSub 							; otherwise at least one float.
.92ca						_StringData:
.92ca		4c 02 a0	jmp $a002			jmp 	NotDoneError							; at least one string - don't know both are strings.
.92cd						_IntegerCode:
.92cd		b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate the second value.
.92cf		49 80		eor #$80			eor 	#$80
.92d1		95 51		sta $51,x			sta 	NSStatus+1,x
.92d3		80 bf		bra $9294			bra 	AddCode 					; and do the same code as add.
.92d5						AndInteger:
.92d5		fa		plx				plx
.92d6		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.92d8		15 51		ora $51,x			ora 	NSStatus+1,x
.92da		0a		asl a				asl 	a 							; shift reference bit into sign bit
.92db		0a		asl a				asl 	a
.92dc		10 05		bpl $92e3			bpl 	_NotRef
.92de		48		pha				pha
.92df		20 0b 97	jsr $970b			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92e2		68		pla				pla
.92e3						_NotRef:
.92e3		0a		asl a				asl 	a
.92e4		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.92e6		15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92e8		15 79		ora $79,x			ora 	NSExponent+1,x
.92ea		f0 03		beq $92ef			beq 	_IntegerCode 				; if clear, then we have two integers
.92ec		4c f8 9f	jmp $9ff8			jmp 	TypeError 					; anything else, type mismatch.
.92ef						_IntegerCode:
.92ef		b5 58		lda $58,x			lda		NSMantissa0,x
.92f1		35 59		and $59,x			and 		NSMantissa0+1,x
.92f3		95 58		sta $58,x			sta 	NSMantissa0,x
.92f5		b5 60		lda $60,x			lda		NSMantissa1,x
.92f7		35 61		and $61,x			and 		NSMantissa1+1,x
.92f9		95 60		sta $60,x			sta 	NSMantissa1,x
.92fb		b5 68		lda $68,x			lda		NSMantissa2,x
.92fd		35 69		and $69,x			and 		NSMantissa2+1,x
.92ff		95 68		sta $68,x			sta 	NSMantissa2,x
.9301		b5 70		lda $70,x			lda		NSMantissa3,x
.9303		35 71		and $71,x			and 		NSMantissa3+1,x
.9305		95 70		sta $70,x			sta 	NSMantissa3,x
.9307		74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.9309		60		rts				rts
.930a						OraInteger:
.930a		fa		plx				plx
.930b		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.930d		15 51		ora $51,x			ora 	NSStatus+1,x
.930f		0a		asl a				asl 	a 							; shift reference bit into sign bit
.9310		0a		asl a				asl 	a
.9311		10 05		bpl $9318			bpl 	_NotRef
.9313		48		pha				pha
.9314		20 0b 97	jsr $970b			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9317		68		pla				pla
.9318						_NotRef:
.9318		0a		asl a				asl 	a
.9319		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.931b		15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.931d		15 79		ora $79,x			ora 	NSExponent+1,x
.931f		f0 03		beq $9324			beq 	_IntegerCode 				; if clear, then we have two integers
.9321		4c f8 9f	jmp $9ff8			jmp 	TypeError 					; anything else, type mismatch.
.9324						_IntegerCode:
.9324		b5 58		lda $58,x			lda		NSMantissa0,x
.9326		15 59		ora $59,x			ora 		NSMantissa0+1,x
.9328		95 58		sta $58,x			sta 	NSMantissa0,x
.932a		b5 60		lda $60,x			lda		NSMantissa1,x
.932c		15 61		ora $61,x			ora 		NSMantissa1+1,x
.932e		95 60		sta $60,x			sta 	NSMantissa1,x
.9330		b5 68		lda $68,x			lda		NSMantissa2,x
.9332		15 69		ora $69,x			ora 		NSMantissa2+1,x
.9334		95 68		sta $68,x			sta 	NSMantissa2,x
.9336		b5 70		lda $70,x			lda		NSMantissa3,x
.9338		15 71		ora $71,x			ora 		NSMantissa3+1,x
.933a		95 70		sta $70,x			sta 	NSMantissa3,x
.933c		74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.933e		60		rts				rts
.933f						EorInteger:
.933f		fa		plx				plx
.9340		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9342		15 51		ora $51,x			ora 	NSStatus+1,x
.9344		0a		asl a				asl 	a 							; shift reference bit into sign bit
.9345		0a		asl a				asl 	a
.9346		10 05		bpl $934d			bpl 	_NotRef
.9348		48		pha				pha
.9349		20 0b 97	jsr $970b			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.934c		68		pla				pla
.934d						_NotRef:
.934d		0a		asl a				asl 	a
.934e		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9350		15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9352		15 79		ora $79,x			ora 	NSExponent+1,x
.9354		f0 03		beq $9359			beq 	_IntegerCode 				; if clear, then we have two integers
.9356		4c f8 9f	jmp $9ff8			jmp 	TypeError 					; anything else, type mismatch.
.9359						_IntegerCode:
.9359		b5 58		lda $58,x			lda		NSMantissa0,x
.935b		55 59		eor $59,x			eor 		NSMantissa0+1,x
.935d		95 58		sta $58,x			sta 	NSMantissa0,x
.935f		b5 60		lda $60,x			lda		NSMantissa1,x
.9361		55 61		eor $61,x			eor 		NSMantissa1+1,x
.9363		95 60		sta $60,x			sta 	NSMantissa1,x
.9365		b5 68		lda $68,x			lda		NSMantissa2,x
.9367		55 69		eor $69,x			eor 		NSMantissa2+1,x
.9369		95 68		sta $68,x			sta 	NSMantissa2,x
.936b		b5 70		lda $70,x			lda		NSMantissa3,x
.936d		55 71		eor $71,x			eor 		NSMantissa3+1,x
.936f		95 70		sta $70,x			sta 	NSMantissa3,x
.9371		74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.9373		60		rts				rts
.9374						WordIndirect:
.9374		fa		plx				plx
.9375		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9377		15 51		ora $51,x			ora 	NSStatus+1,x
.9379		0a		asl a				asl 	a 							; shift reference bit into sign bit
.937a		0a		asl a				asl 	a
.937b		10 05		bpl $9382			bpl 	_NotRef
.937d		48		pha				pha
.937e		20 0b 97	jsr $970b			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9381		68		pla				pla
.9382						_NotRef:
.9382		0a		asl a				asl 	a
.9383		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9385		15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9387		15 79		ora $79,x			ora 	NSExponent+1,x
.9389		f0 03		beq $938e			beq 	_IntegerCode 				; if clear, then we have two integers
.938b		4c f8 9f	jmp $9ff8			jmp 	TypeError 					; anything else, type mismatch.
.938e						_IntegerCode:
.938e		20 94 92	jsr $9294			jsr 	AddCode 					; add the two values
.9391		a9 22		lda #$22			lda 	#NSBIsReference+2 			; make a 2 byte reference
.9393		95 50		sta $50,x			sta 	NSStatus,x
.9395		60		rts				rts
.9396						ByteIndirect:
.9396		fa		plx				plx
.9397		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9399		15 51		ora $51,x			ora 	NSStatus+1,x
.939b		0a		asl a				asl 	a 							; shift reference bit into sign bit
.939c		0a		asl a				asl 	a
.939d		10 05		bpl $93a4			bpl 	_NotRef
.939f		48		pha				pha
.93a0		20 0b 97	jsr $970b			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.93a3		68		pla				pla
.93a4						_NotRef:
.93a4		0a		asl a				asl 	a
.93a5		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.93a7		15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.93a9		15 79		ora $79,x			ora 	NSExponent+1,x
.93ab		f0 03		beq $93b0			beq 	_IntegerCode 				; if clear, then we have two integers
.93ad		4c f8 9f	jmp $9ff8			jmp 	TypeError 					; anything else, type mismatch.
.93b0						_IntegerCode:
.93b0		20 94 92	jsr $9294			jsr 	AddCode 					; add the two values
.93b3		a9 21		lda #$21			lda 	#NSBIsReference+1 			; make a 1 byte reference
.93b5		95 50		sta $50,x			sta 	NSStatus,x
.93b7		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/tostring.asm

.93b8						ConvertInt16:
.93b8		85 58		sta $58				sta 	NSMantissa0 				; set up as 32 bit conversion
.93ba		86 60		stx $60				stx 	NSMantissa1
.93bc		64 68		stz $68				stz 	NSMantissa2
.93be		64 70		stz $70				stz 	NSMantissa3
.93c0		64 50		stz $50				stz 	NSStatus 					; positive integer
.93c2		a2 00		ldx #$00			ldx 	#0 							; stack level
.93c4		a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.93c6		80 00		bra $93c8			bra 	ConvertInt32
.93c8						ConvertInt32:
.93c8		5a		phy				phy
.93c9		a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.93cb		24 50		bit $50				bit 	NSStatus 					; output a - if not negative.
.93cd		10 08		bpl $93d7			bpl 	_CI32NotNeg
.93cf		48		pha				pha
.93d0		a9 2d		lda #$2d			lda 	#'-'
.93d2		99 27 06	sta $0627,y			sta 	NumberBuffer,y
.93d5		c8		iny				iny
.93d6		68		pla				pla
.93d7						_CI32NotNeg:
.93d7		20 e5 93	jsr $93e5			jsr 	_CI32DivideConvert 			; recursive conversion
.93da		a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.93dc		99 27 06	sta $0627,y			sta 	NumberBuffer,y
.93df		7a		ply				ply
.93e0		a2 06		ldx #$06			ldx 	#NumberBuffer >> 8 			; return address in XA
.93e2		a9 27		lda #$27			lda 	#NumberBuffer & $FF
.93e4		60		rts				rts
.93e5						_CI32DivideConvert:
.93e5		e8		inx				inx 								; write to next slot up
.93e6		20 72 9e	jsr $9e72			jsr 	NSMSetByte 		 			; write the base out.
.93e9		ca		dex				dex
.93ea		20 13 91	jsr $9113			jsr 	Int32Divide 				; divide
.93ed		b5 58		lda $58,x			lda 	NSMantissa0,x 				; save remainder
.93ef		48		pha				pha
.93f0		20 d0 90	jsr $90d0			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.93f3		20 92 9e	jsr $9e92			jsr 	NSMIsZero 					; is it zero ?
.93f6		f0 05		beq $93fd			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.93f8		b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.93fa		20 e5 93	jsr $93e5			jsr 	_CI32DivideConvert 			; and recusrively call.
.93fd						_CI32NoRecurse:
.93fd		68		pla				pla 								; remainder
.93fe		c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.9400		90 02		bcc $9404			bcc 	_CI32NotHex
.9402		69 26		adc #$26			adc 	#6+32
.9404						_CI32NotHex:
.9404		69 30		adc #$30			adc 	#48
.9406		99 27 06	sta $0627,y			sta 	NumberBuffer,y 				; write out and exit
.9409		c8		iny				iny
.940a		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/expression.asm


;******  Processing file: ./common/expressions/../generated/precedence.dat

.940b						PrecedenceLevel:
>940b		04					.byte	 4	; $00 <<
>940c		02					.byte	 2	; $01 <=
>940d		02					.byte	 2	; $02 <>
>940e		00					.byte	 0	; $03 !!3
>940f		00					.byte	 0	; $04 ><
>9410		02					.byte	 2	; $05 >=
>9411		04					.byte	 4	; $06 >>
>9412		00					.byte	 0	; $07 !!7
>9413		00					.byte	 0	; $08 !!8
>9414		00					.byte	 0	; $09 !!9
>9415		00					.byte	 0	; $0a !!10
>9416		00					.byte	 0	; $0b !!11
>9417		00					.byte	 0	; $0c !!12
>9418		00					.byte	 0	; $0d !!13
>9419		00					.byte	 0	; $0e !!14
>941a		00					.byte	 0	; $0f !!15
>941b		00					.byte	 0	; $10 @
>941c		00					.byte	 0	; $11 !!17
>941d		00					.byte	 0	; $12 !!18
>941e		00					.byte	 0	; $13 [
>941f		04					.byte	 4	; $14 \
>9420		00					.byte	 0	; $15 ]
>9421		01					.byte	 1	; $16 ^
>9422		00					.byte	 0	; $17 _
>9423		00					.byte	 0	; $18 `
>9424		00					.byte	 0	; $19 !!25
>9425		00					.byte	 0	; $1a !!26
>9426		00					.byte	 0	; $1b {
>9427		01					.byte	 1	; $1c |
>9428		00					.byte	 0	; $1d }
>9429		00					.byte	 0	; $1e ~
>942a		00					.byte	 0	; $1f [7m<7F>[m
>942b		00					.byte	 0	; $20
>942c		05					.byte	 5	; $21 !
>942d		00					.byte	 0	; $22 "
>942e		00					.byte	 0	; $23 #
>942f		05					.byte	 5	; $24 $
>9430		04					.byte	 4	; $25 %
>9431		01					.byte	 1	; $26 &
>9432		00					.byte	 0	; $27 '
>9433		00					.byte	 0	; $28 (
>9434		00					.byte	 0	; $29 )
>9435		04					.byte	 4	; $2a *
>9436		03					.byte	 3	; $2b +
>9437		00					.byte	 0	; $2c ,
>9438		03					.byte	 3	; $2d -
>9439		00					.byte	 0	; $2e .
>943a		04					.byte	 4	; $2f /
>943b		00					.byte	 0	; $30 0
>943c		00					.byte	 0	; $31 1
>943d		00					.byte	 0	; $32 2
>943e		00					.byte	 0	; $33 3
>943f		00					.byte	 0	; $34 4
>9440		00					.byte	 0	; $35 5
>9441		00					.byte	 0	; $36 6
>9442		00					.byte	 0	; $37 7
>9443		00					.byte	 0	; $38 8
>9444		00					.byte	 0	; $39 9
>9445		00					.byte	 0	; $3a :
>9446		00					.byte	 0	; $3b ;
>9447		02					.byte	 2	; $3c <
>9448		02					.byte	 2	; $3d =
>9449		02					.byte	 2	; $3e >
>944a		05					.byte	 5	; $3f ?

;******  Return to file: ./common/expressions/expression.asm

.944b						EvaluateExpressionAt0:
.944b		a2 00		ldx #$00			ldx 	#0 							; bottom stack level
.944d						EvaluateExpression:
.944d		a9 00		lda #$00			lda 	#0 							; lowest precedence level
.944f						EvaluateExpressionAtPrecedence:
.944f		48		pha				pha 								; save precedence level
.9450		20 97 98	jsr $9897			jsr 	EvaluateTerm 				; evaluate term into level X.
.9453		68		pla				pla 								; restore precedence level.
.9454						_EXPRLoop:
.9454		85 36		sta $36				sta 	zTemp0 						; save current precedence level.
.9456		b1 30		lda ($30),y			lda 	(codePtr),y
.9458		c9 40		cmp #$40			cmp		#$40 						; if >= $40 cannot be an operator
.945a		b0 25		bcs $9481			bcs 	_EXPRExit
.945c		da		phx				phx 								; read the operator precedence
.945d		aa		tax				tax
.945e		bd 0b 94	lda $940b,x			lda 	PrecedenceLevel,x
.9461		fa		plx				plx
.9462		c9 00		cmp #$00			cmp 	#0							; if zero exit (not an operator)
.9464		f0 1b		beq $9481			beq 	_EXPRExit
.9466		85 37		sta $37				sta 	zTemp0+1 					; save operator precedence level.
.9468		a5 36		lda $36				lda 	zTemp0 						; compare current precedence vs. operator precedence
.946a		c5 37		cmp $37				cmp 	zTemp0+1
.946c		b0 13		bcs $9481			bcs		_EXPRExit 					; if current >= operator exit
.946e		48		pha				pha 								; save current precedence.
.946f		b1 30		lda ($30),y			lda 	(codePtr),y
.9471		c8		iny				iny
.9472		48		pha				pha
.9473		a5 37		lda $37				lda 	zTemp0+1 					; get operator precedence level
.9475		e8		inx				inx 								; work out the right hand side.
.9476		20 4f 94	jsr $944f			jsr 	EvaluateExpressionAtPrecedence
.9479		ca		dex				dex
.947a		68		pla				pla 								; get operator, call the code.
.947b		20 84 94	jsr $9484			jsr 	_EXPRCaller
.947e		68		pla				pla 								; restore precedence level
.947f		80 d3		bra $9454			bra 	_EXPRLoop 					; and go round.
.9481						_EXPRExit:
.9481		a5 36		lda $36				lda 	zTemp0 						; A = current precedence level.
.9483		60		rts				rts
.9484						_EXPRCaller:
.9484		da		phx				phx 								; save on stack, first thing is to restore it
.9485		0a		asl a				asl 	a 							; double so can use vectors into X
.9486		aa		tax				tax
.9487		7c 60 8c	jmp ($8c60,x)			jmp 	(VectorSetPunc,x) 			; and go to the code.

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/addsub.asm

.948a						FloatingPointAdd:
.948a		20 00 96	jsr $9600			jsr 	FloatPrepare 				; prepare for floats
.948d		80 09		bra $9498			bra 	FloatAdd
.948f						FloatingPointSub:
.948f		20 00 96	jsr $9600			jsr 	FloatPrepare 				; prepare for floats
.9492						FloatSubtract:
.9492		b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate FPB
.9494		49 80		eor #$80			eor 	#$80
.9496		95 51		sta $51,x			sta 	NSStatus+1,x				; and fall through.
.9498						FloatAdd:
.9498		48		pha				pha
.9499		5a		phy				phy
.949a		20 0f 96	jsr $960f			jsr 	NSNormalise 				; normalise S[X]
.949d		f0 51		beq $94f0			beq 	_FAReturn1
.949f		e8		inx				inx 								; normalise S[X+1]
.94a0		20 0f 96	jsr $960f			jsr 	NSNormalise
.94a3		ca		dex				dex
.94a4		c9 00		cmp #$00			cmp 	#0
.94a6		f0 60		beq $9508			beq 	_FAExit 					; if so, just return A
.94a8		b5 78		lda $78,x			lda 	NSExponent,x 				; are the exponents the same ?
.94aa		d5 79		cmp $79,x			cmp 	NSExponent+1,x
.94ac		f0 18		beq $94c6			beq 	_FAExponentsEqual
.94ae		b5 78		lda $78,x			lda 	NSExponent,x 				; work out the larger exponent
.94b0		a8		tay				tay
.94b1		38		sec				sec 								; do a signed comparison of the exponents.
.94b2		f5 79		sbc $79,x			sbc 	NSExponent+1,x
.94b4		50 02		bvc $94b8			bvc 	_FANoSignedChange
.94b6		49 80		eor #$80			eor 	#$80
.94b8						_FANoSignedChange:
.94b8		29 80		and #$80			and 	#$80
.94ba		10 02		bpl $94be			bpl 	_FAHaveMax
.94bc		b4 79		ldy $79,x			ldy 	NSExponent+1,x
.94be						_FAHaveMax:
.94be		20 0b 95	jsr $950b			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.94c1		e8		inx				inx
.94c2		20 0b 95	jsr $950b			jsr 	_FAShiftToExponent
.94c5		ca		dex				dex
.94c6						_FAExponentsEqual:
.94c6		b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs the same
.94c8		55 51		eor $51,x			eor 	NSStatus+1,x
.94ca		30 0e		bmi $94da			bmi 	_FADifferentSigns
.94cc		20 43 92	jsr $9243			jsr 	AddTopTwoStack 				; do the add of the mantissae
.94cf		b5 70		lda $70,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.94d1		10 35		bpl $9508			bpl 	_FAExit 					; if no, we are done.
.94d3		20 89 9e	jsr $9e89			jsr 	NSMShiftRight 				; shift A right, renormalising it.
.94d6		f6 78		inc $78,x			inc 	NSExponent,x 				; bump the exponent and exit
.94d8		80 2e		bra $9508			bra 	_FAExit
.94da						_FADifferentSigns:
.94da		20 5d 92	jsr $925d			jsr 	SubTopTwoStack 				; subtract mantissa B from A
.94dd		b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the result negative ?
.94df		10 06		bpl $94e7			bpl 	_FACheckZero 				; if no, check for -0
.94e1		20 32 9e	jsr $9e32			jsr 	NSMNegate 					; netate result
.94e4		20 39 9e	jsr $9e39			jsr 	NSMNegateMantissa 			; negate (2'c) the mantissa
.94e7						_FACheckZero:
.94e7		20 92 9e	jsr $9e92			jsr 	NSMIsZero	 				; check for -0
.94ea		d0 1c		bne $9508			bne 	_FAExit
.94ec		74 50		stz $50,x			stz 	NSStatus,x
.94ee		80 18		bra $9508			bra 	_FAExit
.94f0						_FAReturn1:
.94f0		b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.94f2		95 58		sta $58,x			sta 	NSMantissa0,x
.94f4		b5 61		lda $61,x			lda 	NSMantissa1+1,x
.94f6		95 60		sta $60,x			sta 	NSMantissa1,x
.94f8		b5 69		lda $69,x			lda 	NSMantissa2+1,x
.94fa		95 68		sta $68,x			sta 	NSMantissa2,x
.94fc		b5 71		lda $71,x			lda 	NSMantissa3+1,x
.94fe		95 70		sta $70,x			sta 	NSMantissa3,x
.9500		b5 79		lda $79,x			lda 	NSExponent+1,x
.9502		95 78		sta $78,x			sta 	NSExponent,x
.9504		b5 51		lda $51,x			lda 	NSStatus+1,x
.9506		95 50		sta $50,x			sta 	NSStatus,x
.9508						_FAExit:
.9508		7a		ply				ply
.9509		68		pla				pla
.950a		60		rts				rts
.950b						_FAShiftToExponent:
.950b						_FAShiftToExponent2:
.950b		98		tya				tya 								; compare Y to exponent
.950c		d5 78		cmp $78,x			cmp 	NSExponent,x 				; reached the exponent required ?
.950e		f0 07		beq $9517			beq 	_FASEExit 					; exit if so.
.9510		20 89 9e	jsr $9e89			jsr 	NSMShiftRight	 			; shift the mantissa right
.9513		f6 78		inc $78,x			inc 	NSExponent,x 				; increment exponent
.9515		80 f4		bra $950b			bra 	_FAShiftToExponent2
.9517						_FASEExit:
.9517		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/compare.asm

.9518						CompareFloat:
.9518		20 92 94	jsr $9492			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.951b		b5 60		lda $60,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.951d		29 f8		and #$f8			and 	#$F8
.951f		15 68		ora $68,x			ora 	NSMantissa2,x
.9521		15 70		ora $70,x			ora 	NSMantissa3,x
.9523		f0 08		beq $952d			beq 	_FCExit 					; zero, so approximately identical
.9525		a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.9527		34 50		bit $50,x			bit 	NSStatus,x
.9529		10 02		bpl $952d			bpl 	_FCExit
.952b						_FCNegative:
.952b		a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.952d						_FCExit:
.952d		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/divide.asm

.952e						FDivideCommand:
.952e		fa		plx				plx	 								; restore stack position
.952f		20 00 96	jsr $9600			jsr 	FloatPrepare 				; prepare for floats
.9532						FloatDivide:
.9532		48		pha				pha
.9533		e8		inx				inx
.9534		20 0f 96	jsr $960f			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.9537		ca		dex				dex
.9538		c9 00		cmp #$00			cmp 	#0
.953a		f0 1d		beq $9559			beq 	_FDZero
.953c		20 0f 96	jsr $960f			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.953f		f0 16		beq $9557			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.9541		20 34 91	jsr $9134			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.9544		20 d0 90	jsr $90d0			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.9547		20 0f 96	jsr $960f			jsr		NSNormalise 				; renormalise
.954a		20 c4 91	jsr $91c4			jsr 	CalculateSign 				; calculate result sign
.954d		b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent
.954f		38		sec				sec
.9550		f5 79		sbc $79,x			sbc 	NSExponent+1,x
.9552		38		sec				sec
.9553		e9 1e		sbc #$1e			sbc 	#30
.9555		95 78		sta $78,x			sta 	NSExponent,x
.9557						_FDExit:
.9557		68		pla				pla
.9558		60		rts				rts
.9559						_FDZero:
.9559		a9 03		lda #$03		lda	#3
.955b		4c 49 8f	jmp $8f49		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/fractional.asm

.955e						FloatFractionalPart:
.955e		5a		phy				phy
.955f		b5 50		lda $50,x			lda 	NSStatus,x 					; take absolute value
.9561		29 7f		and #$7f			and 	#$7F
.9563		95 50		sta $50,x			sta 	NSStatus,x
.9565		20 0f 96	jsr $960f			jsr 	NSNormalise
.9568		b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.956a		38		sec				sec
.956b		e9 e0		sbc #$e0			sbc 	#$E0
.956d		90 29		bcc $9598			bcc 	_FFPExit 					; already fractional
.956f		c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.9571		b0 22		bcs $9595			bcs 	_FFPZero
.9573		a8		tay				tay 								; put count to do in Y
.9574		b5 70		lda $70,x			lda 	NSMantissa3,x 				; do each in turn.
.9576		20 9a 95	jsr $959a			jsr 	_FFPPartial
.9579		95 70		sta $70,x			sta 	NSMantissa3,x
.957b		b5 68		lda $68,x			lda 	NSMantissa2,x
.957d		20 9a 95	jsr $959a			jsr 	_FFPPartial
.9580		95 68		sta $68,x			sta 	NSMantissa2,x
.9582		b5 60		lda $60,x			lda 	NSMantissa1,x
.9584		20 9a 95	jsr $959a			jsr 	_FFPPartial
.9587		95 60		sta $60,x			sta 	NSMantissa1,x
.9589		b5 58		lda $58,x			lda 	NSMantissa0,x
.958b		20 9a 95	jsr $959a			jsr 	_FFPPartial
.958e		95 58		sta $58,x			sta 	NSMantissa0,x
.9590		20 92 9e	jsr $9e92			jsr 	NSMIsZero 					; zeroed check.
.9593		d0 03		bne $9598			bne 	_FFPExit
.9595						_FFPZero:
.9595		20 70 9e	jsr $9e70			jsr 	NSMSetZero
.9598						_FFPExit:
.9598		7a		ply				ply
.9599		60		rts				rts
.959a						_FFPPartial:
.959a		c0 00		cpy #$00			cpy 	#0 							; no more to do
.959c		f0 17		beq $95b5			beq 	_FFFPPExit
.959e		c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.95a0		b0 0c		bcs $95ae			bcs 	_FFFPPWholeByte
.95a2		5a		phy				phy
.95a3						_FFFPPLeft:
.95a3		0a		asl a				asl 	a
.95a4		88		dey				dey
.95a5		d0 fc		bne $95a3			bne 	_FFFPPLeft
.95a7		7a		ply				ply
.95a8						_FFFPPRight:
.95a8		4a		lsr a				lsr 	a
.95a9		88		dey				dey
.95aa		d0 fc		bne $95a8			bne 	_FFFPPRight
.95ac		80 07		bra $95b5			bra 	_FFFPPExit
.95ae						_FFFPPWholeByte:
.95ae		98		tya				tya 								; subtract 8 from count
.95af		38		sec				sec
.95b0		e9 08		sbc #$08			sbc 	#8
.95b2		a8		tay				tay
.95b3		a9 00		lda #$00			lda 	#0 							; and clear all
.95b5						_FFFPPExit:
.95b5		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/integer.asm

.95b6						FloatIntegerPart:
.95b6		48		pha				pha
.95b7		b5 78		lda $78,x			lda 	NSExponent,x 				; is it integer already ?
.95b9		f0 1d		beq $95d8			beq 	_FIPExit 					; if so do nothing
.95bb		20 92 9e	jsr $9e92			jsr 	NSMIsZero 					; is it zero ?
.95be		f0 15		beq $95d5			beq 	_FIPZero 					; if so return zero.
.95c0		20 0f 96	jsr $960f			jsr 	NSNormalise 				; normalise
.95c3		f0 10		beq $95d5			beq 	_FIPZero 					; normalised to zero, exit zero
.95c5						_FIPShift:
.95c5		b5 78		lda $78,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.95c7		10 07		bpl $95d0			bpl 	_FIPCheckZero
.95c9		20 89 9e	jsr $9e89			jsr 	NSMShiftRight 				; shift mantissa right
.95cc		f6 78		inc $78,x			inc 	NSExponent,x 				; bump exponent
.95ce		80 f5		bra $95c5			bra 	_FIPShift
.95d0						_FIPCheckZero:
.95d0		20 92 9e	jsr $9e92			jsr 	NSMIsZero 					; avoid -0 problem
.95d3		d0 03		bne $95d8			bne 	_FIPExit 					; set to zero if mantissa zero.
.95d5						_FIPZero:
.95d5		20 70 9e	jsr $9e70			jsr 	NSMSetZero
.95d8						_FIPExit:
.95d8		68		pla				pla
.95d9		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/multiply.asm

.95da						FloatingPointMultiply:
.95da		20 00 96	jsr $9600			jsr 	FloatPrepare 				; prepare for floats
.95dd						FloatMultiply:
.95dd		48		pha				pha
.95de		20 0f 96	jsr $960f			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.95e1		f0 18		beq $95fb			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.95e3		e8		inx				inx
.95e4		20 0f 96	jsr $960f			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.95e7		ca		dex				dex
.95e8		c9 00		cmp #$00			cmp 	#0
.95ea		f0 0c		beq $95f8			beq 	_FDSetZero
.95ec		20 86 91	jsr $9186			jsr 	MultiplyShort 				; calculate the result.
.95ef		75 78		adc $78,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.95f1		18		clc				clc
.95f2		75 79		adc $79,x			adc 	NSExponent+1,x
.95f4		95 78		sta $78,x			sta 	NSExponent,x
.95f6		80 03		bra $95fb			bra 	_FDExit
.95f8						_FDSetZero:
.95f8		20 70 9e	jsr $9e70			jsr 	NSMSetZero 					; return 0
.95fb						_FDExit:
.95fb		20 0f 96	jsr $960f			jsr 	NSNormalise 				; normalise the result
.95fe		68		pla				pla
.95ff		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/utility.asm

.9600						FloatPrepare:
.9600		20 0b 97	jsr $970b			jsr 	DereferenceTopTwo 			; dereference the top two values
.9603		b5 50		lda $50,x			lda 	NSStatus,x 					; check ints/floats, either will do.
.9605		15 51		ora $51,x			ora 	NSStatus+1,x
.9607		29 10		and #$10			and 	#NSBIsString
.9609		d0 01		bne $960c			bne 	_FDType
.960b		60		rts				rts
.960c						_FDType:
.960c		4c f8 9f	jmp $9ff8			jmp 	TypeError
.960f						NSNormalise:
.960f		b5 50		lda $50,x			lda 	NSStatus,x 					; make float, keep sign
.9611		29 80		and #$80			and 	#$80
.9613		09 08		ora #$08			ora 	#NSTFloat
.9615		95 50		sta $50,x			sta 	NSStatus,x
.9617		20 92 9e	jsr $9e92			jsr 	NSMIsZero 					; if zero exit
.961a		d0 07		bne $9623			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.961c		16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.961e		76 50		ror $50,x			ror 	NSStatus,x 					; (no -0)
.9620		a9 00		lda #$00			lda 	#0 							; set Z flag
.9622		60		rts				rts
.9623						_NSNormaliseOptimise:
.9623		b5 70		lda $70,x			lda 	NSMantissa3,x 				; upper byte zero ?
.9625		d0 19		bne $9640			bne 	_NSNormaliseLoop
.9627		b5 68		lda $68,x			lda 	NSMantissa2,x 				; byte normalise
.9629		30 15		bmi $9640			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.962b		95 70		sta $70,x			sta 	NSMantissa3,x
.962d		b5 60		lda $60,x			lda 	NSMantissa1,x
.962f		95 68		sta $68,x			sta 	NSMantissa2,x
.9631		b5 58		lda $58,x			lda 	NSMantissa0,x
.9633		95 60		sta $60,x			sta 	NSMantissa1,x
.9635		74 58		stz $58,x			stz 	NSMantissa0,x
.9637		b5 78		lda $78,x			lda 	NSExponent,x
.9639		38		sec				sec
.963a		e9 08		sbc #$08			sbc 	#8
.963c		95 78		sta $78,x			sta 	NSExponent,x
.963e		80 e3		bra $9623			bra 	_NSNormaliseOptimise
.9640						_NSNormaliseLoop:
.9640		34 70		bit $70,x			bit 	NSMantissa3,x 				; bit 30 set ?
.9642		70 07		bvs $964b			bvs 	_NSNExit 					; exit if so with Z flag clear
.9644		20 7f 9e	jsr $9e7f			jsr 	NSMShiftLeft 				; shift mantissa left
.9647		d6 78		dec $78,x			dec 	NSExponent,x 				; adjust exponent
.9649		80 f5		bra $9640			bra 	_NSNormaliseLoop
.964b						_NSNExit:
.964b		a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.964d		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignnumber.asm

.964e						AssignNumber:
.964e		5a		phy				phy
.964f		b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy mantissa0/1 to zTemp0
.9651		85 36		sta $36				sta 	zTemp0
.9653		b5 60		lda $60,x			lda 	NSMantissa1,x
.9655		85 37		sta $37				sta 	zTemp0+1
.9657		b5 50		lda $50,x			lda 	NSStatus,x 					; clear reference bits
.9659		29 df		and #$df			and 	#(NSBIsReference ^ $FF)
.965b		95 50		sta $50,x			sta 	NSStatus,x
.965d		29 18		and #$18			and 	#NSBTypeMask				; assigning to a float ?
.965f		c9 08		cmp #$08			cmp 	#NSTFloat
.9661		f0 24		beq $9687			beq 	_ANFloat
.9663		b5 79		lda $79,x			lda		NSExponent+1,x 				; is it a float
.9665		f0 03		beq $966a			beq		_ANNotFloat
.9667		4c f3 9f	jmp $9ff3			jmp 	RangeError					; if it is, report an error.
.966a						_ANNotFloat:
.966a		b5 50		lda $50,x			lda 	NSStatus,x 					; check if byte/word reference.
.966c		29 03		and #$03			and 	#3
.966e		d0 05		bne $9675			bne 	_ANByteWord
.9670		20 92 96	jsr $9692			jsr 	_ANCopy4PackSign 			; copy all 4 bytes and sign
.9673		80 1b		bra $9690			bra 	_ANExit
.9675						_ANByteWord:
.9675		48		pha				pha 								; save count
.9676		b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; do byte
.9678		92 36		sta ($36)			sta 	(zTemp0)
.967a		68		pla				pla
.967b		c9 01		cmp #$01			cmp	 	#1
.967d		f0 11		beq $9690			beq 	_ANExit
.967f		b5 61		lda $61,x			lda 	NSMantissa1+1,x 			; do word
.9681		a0 01		ldy #$01			ldy 	#1
.9683		91 36		sta ($36),y			sta 	(zTemp0),y
.9685		80 09		bra $9690			bra 	_ANExit
.9687						_ANFloat:
.9687		20 92 96	jsr $9692			jsr 	_ANCopy4PackSign 			; write all 4 bytes and packed sign
.968a		b5 79		lda $79,x			lda 	NSExponent+1,x 				; copy exponent to slot 4
.968c		a0 04		ldy #$04			ldy 	#4
.968e		91 36		sta ($36),y			sta 	(zTemp0),y
.9690						_ANExit:
.9690		7a		ply				ply
.9691		60		rts				rts
.9692						_ANCopy4PackSign:
.9692		a0 03		ldy #$03			ldy 	#3
.9694		b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign bit into status
.9696		29 80		and #$80			and 	#$80 						; put into high bit of mantissa 3
.9698		15 71		ora $71,x			ora 	NSMantissa3+1,x
.969a		91 36		sta ($36),y			sta 	(zTemp0),y
.969c		88		dey				dey
.969d		b5 69		lda $69,x			lda 	NSMantissa2+1,x
.969f		91 36		sta ($36),y			sta 	(zTemp0),y
.96a1		88		dey				dey
.96a2		b5 61		lda $61,x			lda 	NSMantissa1+1,x
.96a4		91 36		sta ($36),y			sta 	(zTemp0),y
.96a6		88		dey				dey
.96a7		b5 59		lda $59,x			lda 	NSMantissa0+1,x
.96a9		91 36		sta ($36),y			sta 	(zTemp0),y
.96ab		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignstring.asm

.96ac						AssignString:
.96ac		5a		phy				phy
.96ad		b5 59		lda $59,x			lda 	NSMantissa0+1,x
.96af		85 38		sta $38				sta 	zTemp1
.96b1		b5 61		lda $61,x			lda 	NSMantissa1+1,x
.96b3		85 39		sta $39				sta 	zTemp1+1
.96b5		b5 58		lda $58,x			lda 	NSMantissa0,x
.96b7		85 36		sta $36				sta 	zTemp0
.96b9		b5 60		lda $60,x			lda 	NSMantissa1,x
.96bb		85 37		sta $37				sta 	zTemp0+1
.96bd		a0 01		ldy #$01			ldy 	#1 							; the high byte of the target address
.96bf		b1 36		lda ($36),y			lda 	(zTemp0),y
.96c1		f0 23		beq $96e6			beq 	_ASNewStringRequired 		; if zero, a new string is required.
.96c3		38		sec				sec 								; put Address-2 in zsTemp - this is the size/status/string record
.96c4		b2 36		lda ($36)			lda 	(zTemp0) 					; of concreted strings
.96c6		e9 02		sbc #$02			sbc 	#2
.96c8		85 3c		sta $3c				sta 	zsTemp
.96ca		a0 01		ldy #$01			ldy 	#1
.96cc		b1 36		lda ($36),y			lda 	(zTemp0),y
.96ce		e9 00		sbc #$00			sbc 	#0
.96d0		85 3d		sta $3d				sta 	zsTemp+1
.96d2		a0 ff		ldy #$ff			ldy 	#$FF 						; get length of new string
.96d4						_ASGetLength:
.96d4		c8		iny				iny
.96d5		b1 38		lda ($38),y			lda 	(zTemp1),y
.96d7		d0 fb		bne $96d4			bne 	_ASGetLength
.96d9		98		tya				tya 								; is this length <= current length
.96da		d2 3c		cmp ($3c)			cmp 	(zsTemp)
.96dc		90 1e		bcc $96fc			bcc 	_ASCopyString
.96de		f0 1c		beq $96fc			beq 	_ASCopyString
.96e0		a9 80		lda #$80			lda 	#$80 						; mark as unused.
.96e2		a0 01		ldy #$01			ldy 	#1
.96e4		91 3c		sta ($3c),y			sta 	(zsTemp),y
.96e6						_ASNewStringRequired:
.96e6		e8		inx				inx 								; concrete the new string.
.96e7		20 85 a7	jsr $a785			jsr 	StringConcrete				; (breaks zTemp1/2, not zTemp0 and zsTemp)
.96ea		ca		dex				dex
.96eb		18		clc				clc
.96ec		b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy that new address to the reference.
.96ee		69 02		adc #$02			adc 	#2 							; add two to point at the data.
.96f0		92 36		sta ($36)			sta 	(zTemp0)
.96f2		b5 61		lda $61,x			lda 	NSMantissa1+1,x
.96f4		69 00		adc #$00			adc 	#0
.96f6		a0 01		ldy #$01			ldy 	#1
.96f8		91 36		sta ($36),y			sta 	(zTemp0),y
.96fa		80 0d		bra $9709			bra 	_ASExit
.96fc						_ASCopyString:
.96fc		a0 00		ldy #$00			ldy 	#0
.96fe						_ASCopyLoop:
.96fe		b1 38		lda ($38),y			lda 	(zTemp1),y
.9700		c8		iny				iny
.9701		c8		iny				iny
.9702		91 3c		sta ($3c),y			sta 	(zsTemp),y
.9704		88		dey				dey
.9705		c9 00		cmp #$00			cmp 	#0
.9707		d0 f5		bne $96fe			bne 	_ASCopyLoop
.9709						_ASExit:
.9709		7a		ply				ply
.970a		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/dereference.asm

.970b						DereferenceTopTwo:
.970b		e8		inx				inx
.970c		20 10 97	jsr $9710			jsr 	Dereference 				; deref x+1
.970f		ca		dex				dex  								; falls through to deref x
.9710						Dereference:
.9710		b5 50		lda $50,x			lda 	NSStatus,x 					; get the status byte
.9712		29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.9714		f0 48		beq $975e			beq 	_DRFExit 					; not a reference, so exit.
.9716		5a		phy				phy
.9717		b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address to dereference into zTemp0
.9719		85 36		sta $36				sta 	zTemp0
.971b		b5 60		lda $60,x			lda 	NSMantissa1,x
.971d		85 37		sta $37				sta 	zTemp0+1
.971f		74 60		stz $60,x			stz 	NSMantissa1,x 				; clear second byte.
.9721		b2 36		lda ($36)			lda 	(zTemp0) 					; do the first byte
.9723		95 58		sta $58,x			sta 	NSMantissa0,x
.9725		b5 50		lda $50,x			lda 	NSStatus,x 					; get status byte.
.9727		29 18		and #$18			and 	#NSBTypeMask 				; what type is it ?
.9729		c9 10		cmp #$10			cmp 	#NSTString 					; if string, dereference two
.972b		f0 0e		beq $973b			beq 	_DRFDereferenceTwo
.972d		c9 08		cmp #$08			cmp 	#NSTFloat 					; if float, do full dereference.
.972f		f0 2f		beq $9760			beq 	_DRFFull
.9731		b5 50		lda $50,x			lda 	NSStatus,x 					; must be integer - how many bytes ?
.9733		29 03		and #$03			and 	#3
.9735		f0 29		beq $9760			beq 	_DRFFull 					; the whole word
.9737		c9 01		cmp #$01			cmp 	#1 							; is it 10 (e.g. 2 bytes)
.9739		f0 06		beq $9741			beq		_DRFClear23 				; no, one byte, clear 2 & 3 and exit
.973b						_DRFDereferenceTwo:
.973b		a0 01		ldy #$01			ldy 	#1
.973d		b1 36		lda ($36),y			lda 	(zTemp0),y
.973f		95 60		sta $60,x			sta 	NSMantissa1,x
.9741						_DRFClear23:
.9741		74 68		stz $68,x			stz 	NSMantissa2,x 				; clear upper bytes, only read 1 or 2 bytes
.9743		74 70		stz $70,x			stz 	NSMantissa3,x
.9745		b5 50		lda $50,x			lda 	NSStatus,x 					; make it a value of that type.
.9747		29 18		and #$18			and 	#NSBTypeMask
.9749		95 50		sta $50,x			sta 	NSStatus,x 					; and fall through.
.974b		c9 10		cmp #$10			cmp 	#NSTString  				; is it a string
.974d		d0 0e		bne $975d			bne 	_DRFNotString
.974f		b5 58		lda $58,x			lda 	NSMantissa0,x 				; check address is zero
.9751		15 60		ora $60,x			ora 	NSMantissa1,x
.9753		d0 08		bne $975d			bne 	_DRFNotString
.9755		a9 5f		lda #$5f			lda 	#_DRFNullString & $FF 		; if so, return reference to ""
.9757		95 58		sta $58,x			sta 	NSMantissa0,X
.9759		a9 97		lda #$97			lda 	#_DRFNullString >> 8
.975b		95 60		sta $60,x			sta 	NSMantissa1,X
.975d						_DRFNotString
.975d		7a		ply				ply 								; restore Y and exit
.975e						_DRFExit:
.975e		60		rts				rts
.975f						_DRFNullString:
>975f		00						.byte 	0
.9760						_DRFFull:
.9760		a0 01		ldy #$01			ldy 	#1 							; get remaining 3 bytes.
.9762		b1 36		lda ($36),y			lda 	(zTemp0),y
.9764		95 60		sta $60,x			sta 	NSMantissa1,x
.9766		c8		iny				iny
.9767		b1 36		lda ($36),y			lda 	(zTemp0),y
.9769		95 68		sta $68,x			sta 	NSMantissa2,x
.976b		c8		iny				iny
.976c		b1 36		lda ($36),y			lda 	(zTemp0),y
.976e		95 70		sta $70,x			sta 	NSMantissa3,x
.9770		74 78		stz $78,x			stz 	NSExponent,x 				; clear exponent.
.9772		b5 50		lda $50,x			lda		NSStatus,x 					; see if type is integer
.9774		29 18		and #$18			and 	#NSBTypeMask  				; type information only
.9776		95 50		sta $50,x			sta 	NSStatus,x 					; update it back.
.9778		f0 05		beq $977f			beq 	_DRFNoExponent
.977a		c8		iny				iny 								; if not, read the exponent as well.
.977b		b1 36		lda ($36),y			lda 	(zTemp0),y
.977d		95 78		sta $78,x			sta 	NSExponent,x
.977f						_DRFNoExponent:
.977f		b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the most significant bit set ?
.9781		10 0a		bpl $978d			bpl 	_DRFExit2 					; if not, then exit.
.9783		29 7f		and #$7f			and 	#$7F 						; clear that bit.
.9785		95 70		sta $70,x			sta 	NSMantissa3,x
.9787		b5 50		lda $50,x			lda 	NSStatus,x 					; set the sign flag
.9789		09 80		ora #$80			ora 	#NSBIsNegative
.978b		95 50		sta $50,x			sta 	NSStatus,x
.978d						_DRFExit2:
.978d		7a		ply				ply
.978e		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/number.asm

=1						ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2						ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3						ESTA_Decimal = 3 							; fractional part.
.978f						EncodeNumberStart:
.978f		38		sec				sec
.9790		80 01		bra $9793			bra 	EncodeNumberContinue+1
.9792						EncodeNumberContinue:
.9792		18		clc				clc
.9793						EncodeNumber:
.9793		08		php				php 								; save reset flag.
.9794		c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.9796		f0 12		beq $97aa			beq 	_ENIsOkay
.9798		c9 30		cmp #$30			cmp 	#"0"
.979a		90 04		bcc $97a0			bcc 	_ENBadNumber
.979c		c9 3a		cmp #$3a			cmp 	#"9"+1
.979e		90 0a		bcc $97aa			bcc 	_ENIsOkay
.97a0						_ENBadNumber:
.97a0		28		plp				plp 								; throw saved reset
.97a1		ad 05 04	lda $0405			lda 	EncodeState 				; if in decimal mode, construct final number
.97a4		c9 03		cmp #$03			cmp 	#ESTA_Decimal
.97a6		f0 7b		beq $9823			beq 	_ENConstructFinal
.97a8						_ENFail:
.97a8		18		clc				clc 								; not allowed
.97a9		60		rts				rts
.97aa						_ENIsOkay:
.97aa		28		plp				plp 								; are we restarting
.97ab		90 15		bcc $97c2			bcc 	_ENNoRestart
.97ad						_ENStartEncode:
.97ad		c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.97af		f0 0c		beq $97bd			beq 	_ENFirstDP
.97b1		29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.97b3		20 72 9e	jsr $9e72			jsr 	NSMSetByte 					; in single byte mode.
.97b6		a9 01		lda #$01			lda 	#ESTA_Low
.97b8						_ENExitChange:
.97b8		8d 05 04	sta $0405			sta 	EncodeState 				; save new state
.97bb		38		sec				sec
.97bc		60		rts				rts
.97bd						_ENFirstDP:
.97bd		20 70 9e	jsr $9e70			jsr 	NSMSetZero 					; clear integer part
.97c0		80 3c		bra $97fe			bra 	_ESTASwitchFloat			; go straight to float and exi
.97c2						_ENNoRestart:
.97c2		48		pha				pha 								; save digit or DP on stack.
.97c3		ad 05 04	lda $0405			lda 	EncodeState 				; get current state
.97c6		c9 01		cmp #$01			cmp 	#ESTA_Low
.97c8		f0 09		beq $97d3			beq  	_ESTALowState
.97ca		c9 02		cmp #$02			cmp 	#ESTA_High
.97cc		f0 26		beq $97f4			beq 	_ESTAHighState
.97ce		c9 03		cmp #$03			cmp 	#ESTA_Decimal
.97d0		f0 38		beq $980a			beq 	_ESTADecimalState
>97d2		db						.byte 	$DB 						; causes a break in the emulator
.97d3						_ESTALowState:
.97d3		68		pla				pla 								; get value back
.97d4		c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.97d6		f0 26		beq $97fe			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.97d8		29 0f		and #$0f			and 	#15 						; make digit
.97da		8d 06 04	sta $0406			sta 	DigitTemp 					; save it.
.97dd		b5 58		lda $58,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.97df		0a		asl a				asl 	a
.97e0		0a		asl a				asl 	a
.97e1		75 58		adc $58,x			adc 	NSMantissa0,x
.97e3		0a		asl a				asl 	a
.97e4		6d 06 04	adc $0406			adc 	DigitTemp
.97e7		95 58		sta $58,x			sta 	NSMantissa0,x
.97e9		c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.97eb		90 05		bcc $97f2			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.97ed		a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.97ef		8d 05 04	sta $0405			sta 	EncodeState
.97f2						_ESTANoSwitch:
.97f2		38		sec				sec
.97f3		60		rts				rts
.97f4						_ESTAHighState:
.97f4		68		pla				pla 								; get value back
.97f5		c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.97f7		f0 05		beq $97fe			beq 	_ESTASwitchFloat
.97f9		20 57 98	jsr $9857			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.97fc		38		sec				sec
.97fd		60		rts				rts
.97fe						_ESTASwitchFloat:
.97fe		9c 07 04	stz $0407			stz 	DecimalCount 				; reset the count of digits - we divide by 10^n at the end.
.9801		e8		inx				inx 								; zero the decimal additive.
.9802		20 70 9e	jsr $9e70			jsr 	NSMSetZero
.9805		ca		dex				dex
.9806		a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.9808		80 ae		bra $97b8			bra 	_ENExitChange
.980a						_ESTADecimalState:
.980a		68		pla				pla 								; digit.
.980b		c9 2e		cmp #$2e			cmp 	#"." 						; fail on 2nd decimal point.
.980d		f0 99		beq $97a8			beq 	_ENFail
.980f		e8		inx				inx 								; put digit into fractional part of X+1
.9810		20 57 98	jsr $9857			jsr 	ESTAShiftDigitIntoMantissa
.9813		ca		dex				dex
.9814		ee 07 04	inc $0407			inc 	DecimalCount 				; bump the count of decimals
.9817		ad 07 04	lda $0407			lda 	DecimalCount 				; too many decimal digits.
.981a		c9 0b		cmp #$0b			cmp 	#11
.981c		f0 02		beq $9820			beq 	_ESTADSFail
.981e		38		sec				sec
.981f		60		rts				rts
.9820						_ESTADSFail:
.9820		4c f3 9f	jmp $9ff3			jmp 	RangeError
.9823						_ENConstructFinal:
.9823		ad 07 04	lda $0407			lda 	DecimalCount 				; get decimal count
.9826		f0 2d		beq $9855			beq 	_ENCFExit 					; no decimals
.9828		5a		phy				phy
.9829		0a		asl a				asl 	a 							; x 4 and CLC
.982a		0a		asl a				asl 	a
.982b		6d 07 04	adc $0407			adc 	DecimalCount
.982e		a8		tay				tay
.982f		b9 b2 9f	lda $9fb2,y			lda 	DecimalScalarTable-5,y 		; copy decimal scalar to X+2
.9832		95 5a		sta $5a,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.9834		b9 b3 9f	lda $9fb3,y			lda 	DecimalScalarTable-5+1,y
.9837		95 62		sta $62,x			sta 	NSMantissa1+2,x
.9839		b9 b4 9f	lda $9fb4,y			lda 	DecimalScalarTable-5+2,y
.983c		95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.983e		b9 b5 9f	lda $9fb5,y			lda 	DecimalScalarTable-5+3,y
.9841		95 72		sta $72,x			sta 	NSMantissa3+2,x
.9843		b9 b6 9f	lda $9fb6,y			lda 	DecimalScalarTable-5+4,y
.9846		95 7a		sta $7a,x			sta 	NSExponent+2,x
.9848		a9 08		lda #$08			lda 	#NSTFloat
.984a		95 52		sta $52,x			sta 	NSStatus+2,x
.984c		7a		ply				ply
.984d		e8		inx				inx 								; multiply decimal const by decimal scalar
.984e		20 dd 95	jsr $95dd			jsr 	FloatMultiply
.9851		ca		dex				dex
.9852		20 98 94	jsr $9498			jsr 	FloatAdd 					; add to integer part.
.9855						_ENCFExit:
.9855		18		clc				clc 								; reject the digit.
.9856		60		rts				rts
.9857						ESTAShiftDigitIntoMantissa:
.9857		29 0f		and #$0f			and 	#15 						; save digit
.9859		48		pha				pha
.985a		b5 70		lda $70,x			lda 	NSMantissa3,x 				; push mantissa on stack
.985c		48		pha				pha
.985d		b5 68		lda $68,x			lda 	NSMantissa2,x
.985f		48		pha				pha
.9860		b5 60		lda $60,x			lda 	NSMantissa1,x
.9862		48		pha				pha
.9863		b5 58		lda $58,x			lda 	NSMantissa0,x
.9865		48		pha				pha
.9866		20 7f 9e	jsr $9e7f			jsr 	NSMShiftLeft 				; x 2
.9869		20 7f 9e	jsr $9e7f			jsr 	NSMShiftLeft 				; x 4
.986c		18		clc				clc 								; pop mantissa and add
.986d		68		pla				pla
.986e		75 58		adc $58,x			adc 	NSMantissa0,x
.9870		95 58		sta $58,x			sta 	NSMantissa0,x
.9872		68		pla				pla
.9873		75 60		adc $60,x			adc 	NSMantissa1,x
.9875		95 60		sta $60,x			sta 	NSMantissa1,x
.9877		68		pla				pla
.9878		75 68		adc $68,x			adc 	NSMantissa2,x
.987a		95 68		sta $68,x			sta 	NSMantissa2,x
.987c		68		pla				pla
.987d		75 70		adc $70,x			adc 	NSMantissa3,x
.987f		95 70		sta $70,x			sta 	NSMantissa3,x 				; x 5
.9881		20 7f 9e	jsr $9e7f			jsr 	NSMShiftLeft 				; x 10
.9884		68		pla				pla 								; add digit
.9885		18		clc				clc
.9886		75 58		adc $58,x			adc 	NSMantissa0,x
.9888		95 58		sta $58,x			sta 	NSMantissa0,x
.988a		90 0a		bcc $9896			bcc 	_ESTASDExit
.988c		f6 60		inc $60,x			inc 	NSMantissa1,x
.988e		d0 06		bne $9896			bne 	_ESTASDExit
.9890		f6 68		inc $68,x			inc 	NSMantissa2,x
.9892		d0 02		bne $9896			bne 	_ESTASDExit
.9894		f6 70		inc $70,x			inc 	NSMantissa3,x
.9896						_ESTASDExit:
.9896		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/term.asm

.9897						EvaluateTerm:
.9897		b1 30		lda ($30),y			lda 	(codePtr),y
.9899		30 18		bmi $98b3			bmi 	_ETCheckUnary 				; unary function ? (text ones)
.989b		c9 40		cmp #$40			cmp 	#$40 						; 40-7F => identifier reference
.989d		b0 6c		bcs $990b			bcs 	_ETVariable
.989f		c9 30		cmp #$30			cmp 	#'0' 						; is it a number
.98a1		90 6b		bcc $990e			bcc 	_ETPuncUnary 				; if not it might be a punctuation unary.
.98a3		c9 3a		cmp #$3a			cmp 	#'9'+1
.98a5		b0 67		bcs $990e			bcs 	_ETPuncUnary
.98a7		20 8f 97	jsr $978f			jsr 	EncodeNumberStart 			; can't fail as it's 0-9 !
.98aa						_ETNumber:
.98aa		c8		iny				iny 								; keep encoding until we have the numbers
.98ab		b1 30		lda ($30),y			lda 	(codePtr),y
.98ad		20 92 97	jsr $9792			jsr 	EncodeNumberContinue
.98b0		b0 f8		bcs $98aa			bcs 	_ETNumber 					; go back if accepted.
.98b2		60		rts				rts
.98b3						_ETCheckUnary:
.98b3		c9 ff		cmp #$ff			cmp 	#KWC_STRING 				; string token
.98b5		f0 3f		beq $98f6			beq 	_ETString
.98b7		c9 fe		cmp #$fe			cmp 	#KWC_HEXCONST 				; hex constant.
.98b9		f0 12		beq $98cd			beq 	_ETHexConstant
.98bb		c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; check it actually is a unary function
.98bd		90 0b		bcc $98ca			bcc 	_ETSyntaxError
.98bf		c9 a2		cmp #$a2			cmp 	#KWC_LAST_UNARY+1
.98c1		b0 07		bcs $98ca			bcs 	_ETSyntaxError
.98c3		da		phx				phx 								; push X on the stack
.98c4		0a		asl a				asl 	a 							; put vector x 2 into X
.98c5		aa		tax				tax
.98c6		c8		iny				iny 								; consume unary function token
.98c7		7c e0 8c	jmp ($8ce0,x)			jmp 	(VectorSet0,x) 				; and do it.
.98ca						_ETSyntaxError:
.98ca		4c ee 9f	jmp $9fee			jmp 	SyntaxError
.98cd						_ETHexConstant:
.98cd		c8		iny				iny 								; skip #
.98ce		c8		iny				iny 								; skip count
.98cf		20 70 9e	jsr $9e70			jsr 	NSMSetZero 					; clear result
.98d2						_ETHLoop:
.98d2		b1 30		lda ($30),y			lda 	(codePtr),y
.98d4		c8		iny				iny 								; and consume
.98d5		c9 00		cmp #$00			cmp 	#0 							; exit if zero
.98d7		f0 1c		beq $98f5			beq 	_ETHExit
.98d9		48		pha				pha 								; save on stack.
.98da		20 7f 9e	jsr $9e7f			jsr 	NSMShiftLeft 				; x 2
.98dd		20 7f 9e	jsr $9e7f			jsr 	NSMShiftLeft 				; x 4
.98e0		20 7f 9e	jsr $9e7f			jsr 	NSMShiftLeft 				; x 8
.98e3		20 7f 9e	jsr $9e7f			jsr 	NSMShiftLeft 				; x 16
.98e6		68		pla				pla 								; ASCII
.98e7		c9 41		cmp #$41			cmp 	#'A'
.98e9		90 02		bcc $98ed			bcc 	_ETHNotChar
.98eb		e9 07		sbc #$07			sbc 	#7
.98ed						_ETHNotChar:
.98ed		29 0f		and #$0f			and 	#15 						; digit now
.98ef		15 58		ora $58,x			ora 	NSMantissa0,x 				; put in LS Nibble
.98f1		95 58		sta $58,x			sta 	NSMantissa0,x
.98f3		80 dd		bra $98d2			bra 	_ETHLoop 					; go round.
.98f5						_ETHExit:
.98f5		60		rts				rts
.98f6						_ETString:
.98f6		c8		iny				iny 								; look at length
.98f7		b1 30		lda ($30),y			lda 	(codePtr),y
.98f9		48		pha				pha
.98fa		c8		iny				iny 								; first character
.98fb		20 db a5	jsr $a5db			jsr 	MemoryInline 				; put address of string at (code-Ptr),y on stack
.98fe		68		pla				pla 								; restore count and save
.98ff		85 36		sta $36				sta 	zTemp0
.9901		98		tya				tya 								; add length to Y to skip it.
.9902		18		clc				clc
.9903		65 36		adc $36				adc 	zTemp0
.9905		a8		tay				tay
.9906		a9 10		lda #$10			lda 	#NSTString 					; mark as string
.9908		95 50		sta $50,x			sta 	NSStatus,x
.990a		60		rts				rts
.990b						_ETVariable:
.990b		4c 60 99	jmp $9960			jmp 	VariableHandler
.990e						_ETPuncUnary:
.990e		c8		iny				iny 								; consume the unary character
.990f		c9 2d		cmp #$2d			cmp 	#KWD_MINUS 					; unary minus
.9911		f0 2b		beq $993e			beq 	_ETUnaryNegate
.9913		c9 10		cmp #$10			cmp 	#KWD_AT 					; @ reference -> constant
.9915		f0 36		beq $994d			beq 	_ETDereference
.9917		c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; parenthesis
.9919		f0 3e		beq $9959			beq 	_ETParenthesis
.991b		64 36		stz $36				stz 	zTemp0 						; zTemp0 is the indirection level.
.991d		c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; byte indirection (0) ?
.991f		f0 06		beq $9927			beq 	_ETIndirection
.9921		e6 36		inc $36				inc 	zTemp0
.9923		c9 21		cmp #$21			cmp 	#KWD_PLING					; word indirection (1) \
.9925		d0 a3		bne $98ca			bne 	_ETSyntaxError
.9927						_ETIndirection:
.9927		a5 36		lda $36				lda 	zTemp0 						; push indirection amount (0-1) => (1-2) on the stack
.9929		1a		inc a				inc 	a
.992a		48		pha				pha
.992b		20 97 98	jsr $9897			jsr 	EvaluateTerm				; evaluate the term
.992e		20 10 97	jsr $9710			jsr 	Dereference 				; dereference it.
.9931		b5 50		lda $50,x			lda 	NSStatus,x 					; must be a +ve integer.
.9933		d0 06		bne $993b			bne 	_ETTypeMismatch
.9935		68		pla				pla 								; indirection 1-2
.9936		09 20		ora #$20			ora 	#NSBIsReference 			; make it a reference.
.9938		95 50		sta $50,x			sta 	NSStatus,x
.993a		60		rts				rts
.993b						_ETTypeMismatch:
.993b		4c f8 9f	jmp $9ff8			jmp 	TypeError
.993e						_ETUnaryNegate:
.993e		20 97 98	jsr $9897			jsr 	EvaluateTerm				; evaluate the term
.9941		20 10 97	jsr $9710			jsr 	Dereference 				; dereference it.
.9944		b5 50		lda $50,x			lda 	NSStatus,x 					; must be a number
.9946		29 10		and #$10			and 	#NSTString
.9948		d0 f1		bne $993b			bne 	_ETTypeMismatch
.994a		4c 32 9e	jmp $9e32			jmp 	NSMNegate  					; just toggles the sign bit.
.994d						_ETDereference:
.994d		20 97 98	jsr $9897			jsr 	EvaluateTerm				; evaluate the term
.9950		b5 50		lda $50,x			lda 	NSStatus,x 					; must be a reference
.9952		29 20		and #$20			and 	#NSBIsReference
.9954		f0 e5		beq $993b			beq 	_ETTypeMismatch
.9956		74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer address
.9958		60		rts				rts
.9959						_ETParenthesis:
.9959		20 4d 94	jsr $944d			jsr 	EvaluateExpression 			; evaluate here, from lowest precedence
.995c		20 30 8f	jsr $8f30			jsr 	CheckRightBracket 			; check for )
.995f		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/variable.asm

.9960						VariableHandler:
.9960		b1 30		lda ($30),y			lda 	(codePtr),y
.9962		18		clc				clc
.9963		69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.9965		85 37		sta $37				sta 	zTemp0+1
.9967		c8		iny				iny
.9968		b1 30		lda ($30),y			lda 	(codePtr),y
.996a		85 36		sta $36				sta 	zTemp0
.996c		c8		iny				iny
.996d		18		clc				clc									; copy variable address+3 to mantissa
.996e		69 03		adc #$03			adc 	#3 							; this is the address of the data.
.9970		95 58		sta $58,x			sta 	NSMantissa0,x
.9972		a5 37		lda $37				lda 	zTemp0+1
.9974		69 00		adc #$00			adc 	#0
.9976		95 60		sta $60,x			sta 	NSMantissa1,x
.9978		74 68		stz $68,x			stz 	NSMantissa2,x
.997a		74 70		stz $70,x			stz 	NSMantissa3,x
.997c		74 78		stz $78,x			stz 	NSExponent,x
.997e		5a		phy				phy
.997f		a0 02		ldy #$02			ldy 	#2 							; read type
.9981		b1 36		lda ($36),y			lda 	(zTemp0),y
.9983		7a		ply				ply
.9984		29 1c		and #$1c			and 	#NSBTypeMask+NSBIsArray 	; get type information
.9986		09 20		ora #$20			ora 	#NSBIsReference 			; make a reference.
.9988		95 50		sta $50,x			sta 	NSStatus,x
.998a		29 04		and #$04			and 	#NSBIsArray
.998c		d0 01		bne $998f			bne 	_VHArray
.998e		60		rts				rts
.998f						_VHArray:
.998f		e8		inx				inx
.9990		20 0b 9e	jsr $9e0b			jsr 	Evaluate8BitInteger 		; get the 1st index.
.9993		a9 ff		lda #$ff			lda 	#$FF 						; set Status of X+2 to a duff value so we know if we picked it up.
.9995		95 51		sta $51,x			sta 	NSStatus+1,x
.9997		b1 30		lda ($30),y			lda 	(codePtr),y
.9999		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.999b		d0 06		bne $99a3			bne 	_VHNoSecondIndex
.999d		c8		iny				iny 								; skip the comma
.999e		e8		inx				inx
.999f		20 0b 9e	jsr $9e0b			jsr 	Evaluate8BitInteger 		; get the 2nd index.
.99a2		ca		dex				dex
.99a3						_VHNoSecondIndex:
.99a3		ca		dex				dex 								; set X back.
.99a4		20 30 8f	jsr $8f30			jsr 	CheckRightBracket 			; and check the right bracket.
.99a7		5a		phy				phy 								; save position
.99a8		b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy record address to zaTemp (moved 6/12/22)
.99aa		85 3e		sta $3e				sta 	zaTemp
.99ac		b5 60		lda $60,x			lda 	NSMantissa1,x
.99ae		85 3f		sta $3f				sta 	zaTemp+1
.99b0		a0 02		ldy #$02			ldy 	#2 							; check first index is not-zero, e.g. array defined
.99b2		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99b4		f0 5d		beq $9a13			beq 	_VHBadArray
.99b6		a0 03		ldy #$03			ldy 	#3 							; get the second index - which is 0 if there is one index.
.99b8		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99ba		f0 02		beq $99be			beq 	_VHHas2Mask
.99bc		a9 ff		lda #$ff			lda 	#$FF
.99be						_VHHas2Mask:
.99be		d5 52		cmp $52,x			cmp 	NSStatus+2,x 				; so if they are the same there are the wrong number of indices
.99c0		f0 4c		beq $9a0e			beq 	_VHBadIndex
.99c2		0a		asl a				asl 	a 							; carry will be set if a second index
.99c3		90 08		bcc $99cd			bcc 	_VHCheckFirstIndex
.99c5		a0 03		ldy #$03			ldy 	#3 			 				; check the 2nd size >= 2nd index
.99c7		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99c9		d5 5a		cmp $5a,x			cmp 	NSMantissa0+2,x
.99cb		90 41		bcc $9a0e			bcc 	_VHBadIndex
.99cd						_VHCheckFirstIndex:
.99cd		a0 02		ldy #$02			ldy 	#2 			 				; check the 2nd size >= 2nd index
.99cf		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99d1		d5 59		cmp $59,x			cmp 	NSMantissa0+1,x
.99d3		90 39		bcc $9a0e			bcc 	_VHBadIndex
.99d5		64 36		stz $36				stz 	zTemp0 						; clear zTemp0 (if 1 index)
.99d7		64 37		stz $37				stz 	zTemp0+1
.99d9		b5 52		lda $52,x			lda 	NSStatus+2,x 				; if only one index provided, don't need to multiply
.99db		30 0e		bmi $99eb			bmi 	_VHNoMultiply
.99dd		da		phx				phx
.99de		b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; get 2nd index on stack
.99e0		48		pha				pha
.99e1		a0 02		ldy #$02			ldy 	#2 							; get 1st size in A
.99e3		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99e5		1a		inc a				inc 	a 							; add 1 for zero base
.99e6		fa		plx				plx
.99e7		20 1b 9e	jsr $9e1b			jsr 	Multiply8x8 				; calculate -> Z0
.99ea		fa		plx				plx
.99eb						_VHNoMultiply:
.99eb		18		clc				clc
.99ec		a5 36		lda $36				lda 	zTemp0
.99ee		75 59		adc $59,x			adc 	NSMantissa0+1,x
.99f0		85 36		sta $36				sta 	zTemp0
.99f2		a5 37		lda $37				lda 	zTemp0+1
.99f4		69 00		adc #$00			adc 	#0
.99f6		85 37		sta $37				sta 	zTemp0+1
.99f8		b5 50		lda $50,x			lda 	NSStatus,x
.99fa		20 c0 85	jsr $85c0			jsr 	ScaleByBaseType
.99fd		18		clc				clc
.99fe		b2 3e		lda ($3e)			lda 	(zaTemp)
.9a00		65 36		adc $36				adc 	zTemp0
.9a02		95 58		sta $58,x			sta 	NSMantissa0,x
.9a04		a0 01		ldy #$01			ldy 	#1
.9a06		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9a08		65 37		adc $37				adc 	zTemp0+1
.9a0a		95 60		sta $60,x			sta 	NSMantissa1,x
.9a0c		7a		ply				ply 								; restore position
.9a0d		60		rts				rts
.9a0e						_VHBadIndex:
.9a0e		a9 17		lda #$17		lda	#23
.9a10		4c 49 8f	jmp $8f49		jmp	ErrorHandler
.9a13						_VHBadArray:
.9a13		a9 18		lda #$18		lda	#24
.9a15		4c 49 8f	jmp $8f49		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/abs.asm

.9a18						AbsUnary:
.9a18		fa		plx				plx 								; restore stack pos
.9a19		20 be 9d	jsr $9dbe			jsr 	EvaluateNumber 				; get a float or int
.9a1c		20 30 8f	jsr $8f30			jsr 	CheckRightBracket
.9a1f		b5 50		lda $50,x			lda 	NSStatus,x 					; clear the sign bit
.9a21		29 7f		and #$7f			and 	#$7F
.9a23		95 50		sta $50,x			sta 	NSStatus,x
.9a25		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/alloc.asm

.9a26						AllocUnary:
.9a26		fa		plx				plx 								; restore stack pos
.9a27		20 f0 9d	jsr $9df0			jsr 	Evaluate16BitInteger		; get bytes required.
.9a2a		20 30 8f	jsr $8f30			jsr 	CheckRightBracket
.9a2d		da		phx				phx 								; save X/Y
.9a2e		5a		phy				phy
.9a2f		8a		txa				txa 								; copy X into Y
.9a30		a8		tay				tay
.9a31		b9 60 00	lda $0060,y			lda		NSMantissa1,y 				; get size into XA
.9a34		aa		tax				tax
.9a35		b9 58 00	lda $0058,y			lda 	NSMantissa0,y
.9a38		20 45 9a	jsr $9a45			jsr 	AllocateXABytes 			; allocate memory
.9a3b		99 58 00	sta $0058,y			sta 	NSMantissa0,y 				; write address out.
.9a3e		8a		txa				txa 	 							; typing is 16 bit integer.
.9a3f		99 60 00	sta $0060,y			sta 	NSMantissa1,y
.9a42		7a		ply				ply
.9a43		fa		plx				plx
.9a44		60		rts				rts
.9a45						AllocateXABytes:
.9a45		5a		phy				phy
.9a46		ac 0c 04	ldy $040c			ldy 	lowMemPtr 					; push current address on stack and to zTemp0
.9a49		84 36		sty $36				sty 	zTemp0
.9a4b		5a		phy				phy
.9a4c		ac 0d 04	ldy $040d			ldy 	lowMemPtr+1
.9a4f		84 37		sty $37				sty 	zTemp0+1
.9a51		5a		phy				phy
.9a52		18		clc				clc 								; add to low memory pointer
.9a53		6d 0c 04	adc $040c			adc 	lowMemPtr
.9a56		8d 0c 04	sta $040c			sta 	lowMemPtr
.9a59		8a		txa				txa
.9a5a		6d 0d 04	adc $040d			adc 	lowMemPtr+1
.9a5d		8d 0d 04	sta $040d			sta 	lowMemPtr+1
.9a60		b0 2f		bcs $9a91			bcs 	CISSMemory
.9a62		20 83 9a	jsr $9a83			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.9a65						_ClearMemory:
.9a65		ad 0c 04	lda $040c			lda 	lowMemPtr 					; cleared all memory allocated
.9a68		c5 36		cmp $36				cmp 	zTemp0
.9a6a		d0 07		bne $9a73			bne 	_CMClearNext
.9a6c		ad 0d 04	lda $040d			lda 	lowMemPtr+1
.9a6f		c5 37		cmp $37				cmp 	zTemp0+1
.9a71		f0 0c		beq $9a7f			beq 	_CMExit
.9a73						_CMClearNext:
.9a73		a9 00		lda #$00			lda 	#0 							; clear byte, advance to next.
.9a75		92 36		sta ($36)			sta 	(zTemp0)
.9a77		e6 36		inc $36				inc 	zTemp0
.9a79		d0 ea		bne $9a65			bne 	_ClearMemory
.9a7b		e6 37		inc $37				inc		zTemp0+1
.9a7d		80 e6		bra $9a65			bra 	_ClearMemory
.9a7f						_CMExit:
.9a7f		fa		plx				plx
.9a80		68		pla				pla
.9a81		7a		ply				ply
.9a82		60		rts				rts
.9a83						CheckIdentifierStringSpace:
.9a83		48		pha				pha
.9a84		ad 0d 04	lda $040d			lda 	lowMemPtr+1 				; get low memory pointer
.9a87		18		clc				clc
.9a88		69 02		adc #$02			adc 	#2 							; need at least 2 256 byte pages
.9a8a		cd 0f 04	cmp $040f			cmp 	StringMemory+1 				; is it >= StringMemory
.9a8d		b0 02		bcs $9a91			bcs 	CISSMemory
.9a8f		68		pla				pla
.9a90		60		rts				rts
.9a91						CISSMemory:
.9a91		a9 06		lda #$06		lda	#6
.9a93		4c 49 8f	jmp $8f49		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/asc.asm

.9a96						AscUnary:
.9a96		fa		plx				plx 								; restore stack pos
.9a97		20 c8 9d	jsr $9dc8			jsr 	EvaluateString 				; get a string
.9a9a		b2 36		lda ($36)			lda 	(zTemp0)					; get/return first character
.9a9c		20 72 9e	jsr $9e72			jsr 	NSMSetByte 					; ASC("") will return zero.
.9a9f		20 30 8f	jsr $8f30			jsr 	CheckRightBracket
.9aa2		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/deekpeek.asm

.9aa3						PeekUnary:
.9aa3		18		clc				clc
.9aa4		80 01		bra $9aa7			bra 	DPUnary
.9aa6						DeekUnary:
.9aa6		38		sec				sec
.9aa7						DPUnary:
.9aa7		fa		plx				plx 								; restore position.
.9aa8		08		php				php									; save on stack, CS = Deek, CC = Peek
.9aa9		20 f0 9d	jsr $9df0			jsr		Evaluate16BitInteger 		; address as constant.
.9aac		20 30 8f	jsr $8f30			jsr 	CheckRightBracket
.9aaf		28		plp				plp 								; function back.
.9ab0		a9 21		lda #$21			lda 	#NSBIsReference+NSTInteger+1 ; 1 byte read
.9ab2		90 01		bcc $9ab5			bcc 	_DPUpdate
.9ab4		1a		inc a				inc 	a 							; 2 byte read
.9ab5						_DPUpdate:
.9ab5		95 50		sta $50,x			sta 	NSStatus,x 					; set to 1/2 byte reference.
.9ab7		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/frac.asm

.9ab8						FracUnary:
.9ab8		fa		plx				plx 								; restore stack pos
.9ab9		20 be 9d	jsr $9dbe			jsr 	EvaluateNumber 				; get a float or int
.9abc		20 30 8f	jsr $8f30			jsr 	CheckRightBracket
.9abf		b5 50		lda $50,x			lda 	NSStatus,x
.9ac1		29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9ac3		f0 04		beq $9ac9			beq 	_IUZero
.9ac5		20 5e 95	jsr $955e			jsr 	FloatFractionalPart 		; if so, get the fractional part.
.9ac8		60		rts				rts
.9ac9						_IUZero:
.9ac9		20 70 9e	jsr $9e70			jsr 	NSMSetZero
.9acc		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/int.asm

.9acd						IntUnary:
.9acd		fa		plx				plx 								; restore stack pos
.9ace		20 be 9d	jsr $9dbe			jsr 	EvaluateNumber 				; get a float or int
.9ad1		20 30 8f	jsr $8f30			jsr 	CheckRightBracket
.9ad4		b5 50		lda $50,x			lda 	NSStatus,x
.9ad6		29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9ad8		f0 03		beq $9add			beq 	_IUExit
.9ada		20 b6 95	jsr $95b6			jsr 	FloatIntegerPart 			; if it is get the integer part.
.9add						_IUExit:
.9add		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/len.asm

.9ade						LenUnary:
.9ade		fa		plx				plx 								; restore stack pos
.9adf		20 c8 9d	jsr $9dc8			jsr 	EvaluateString 				; get a string
.9ae2		5a		phy				phy
.9ae3		a0 00		ldy #$00			ldy 	#0 							; find length
.9ae5						_LenFind:
.9ae5		b1 36		lda ($36),y			lda 	(zTemp0),y 					; look for trailing NULL.
.9ae7		f0 06		beq $9aef			beq 	_LenExit
.9ae9		c8		iny				iny
.9aea		d0 f9		bne $9ae5			bne 	_LenFind
.9aec		4c f3 9f	jmp $9ff3			jmp 	RangeError 					; string > 255 - no trailing NULL.
.9aef						_LenExit:
.9aef		98		tya				tya		 							; return length
.9af0		20 72 9e	jsr $9e72			jsr 	NSMSetByte
.9af3		7a		ply				ply
.9af4		20 30 8f	jsr $8f30			jsr 	CheckRightBracket
.9af7		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/minmax.asm

.9af8						Unary_Min:
.9af8		a9 01		lda #$01			lda 	#1
.9afa		80 02		bra $9afe			bra 	UnaryMinMaxMain
.9afc						Unary_Max:
.9afc		a9 ff		lda #$ff			lda 	#$FF 						; value from comparator to cause a write
.9afe						UnaryMinMaxMain:
.9afe		fa		plx				plx 								; get index on number stack
.9aff		48		pha				pha 								; save comparator
.9b00		20 b5 9d	jsr $9db5			jsr 	EvaluateValue 				; get the first value.
.9b03						_UMMMLoop:
.9b03		b1 30		lda ($30),y			lda 	(codePtr),y
.9b05		c9 29		cmp #$29			cmp 	#KWD_RPAREN 				; if right bracket then done.
.9b07		f0 22		beq $9b2b			beq 	_UMMMDone
.9b09		20 38 8f	jsr $8f38			jsr 	CheckComma 					; must be a comma
.9b0c		e8		inx				inx
.9b0d		20 b5 9d	jsr $9db5			jsr 	EvaluateValue
.9b10		ca		dex				dex
.9b11		20 53 9e	jsr $9e53			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] (Compare is destructive)
.9b14		e8		inx				inx
.9b15		20 53 9e	jsr $9e53			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2], original
.9b18		e8		inx				inx
.9b19		20 00 90	jsr $9000			jsr 	CompareBaseCode 			; part of > = < etc. code, returns 255,0 or 1
.9b1c		ca		dex				dex
.9b1d		ca		dex				dex
.9b1e		85 36		sta $36				sta 	zTemp0 						; save required result
.9b20		68		pla				pla 								; get and save comparator
.9b21		48		pha				pha
.9b22		c5 36		cmp $36				cmp 	zTemp0 						; if the comparator
.9b24		d0 dd		bne $9b03			bne 	_UMMMLoop
.9b26		20 2e 9b	jsr $9b2e			jsr 	ExpCopyAboveDown 			; copy next up slot down
.9b29		80 d8		bra $9b03			bra 	_UMMMLoop
.9b2b						_UMMMDone:
.9b2b		68		pla				pla 								; throw the comparator
.9b2c		c8		iny				iny 								; skip )
.9b2d		60		rts				rts
.9b2e						ExpCopyAboveDown:
.9b2e		b5 51		lda $51,x			lda 	NSStatus+1,x
.9b30		95 50		sta $50,x			sta 	NSStatus,x
.9b32		b5 79		lda $79,x			lda 	NSExponent+1,x
.9b34		95 78		sta $78,x			sta 	NSExponent,x
.9b36		b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9b38		95 58		sta $58,x			sta 	NSMantissa0,x
.9b3a		b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9b3c		95 60		sta $60,x			sta 	NSMantissa1,x
.9b3e		b5 69		lda $69,x			lda 	NSMantissa2+1,x
.9b40		95 68		sta $68,x			sta 	NSMantissa2,x
.9b42		b5 71		lda $71,x			lda 	NSMantissa3+1,x
.9b44		95 70		sta $70,x			sta 	NSMantissa3,x
.9b46		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/not.asm

.9b47						Unary_Not:
.9b47		fa		plx				plx
.9b48		20 dd 9d	jsr $9ddd			jsr 	EvaluateInteger 			; get integer
.9b4b		20 30 8f	jsr $8f30			jsr 	CheckRightBracket
.9b4e		20 92 9e	jsr $9e92			jsr 	NSMIsZero 					; zero mantissa ?
.9b51		f0 04		beq $9b57			beq 	_NotZero
.9b53		20 70 9e	jsr $9e70			jsr 	NSMSetZero
.9b56		60		rts				rts
.9b57						_NotZero:
.9b57		4c b6 8f	jmp $8fb6			jmp 	ReturnTrue

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/rnd.asm

.9b5a						Unary_Random:
.9b5a		fa		plx				plx
.9b5b		20 cc 9b	jsr $9bcc			jsr 	Random32Bit 				; get a random number
.9b5e		20 b5 9b	jsr $9bb5			jsr 	URCopyToMantissa  			; put in mantissa
.9b61		b1 30		lda ($30),y			lda 	(codePtr),y
.9b63		c9 29		cmp #$29			cmp 	#KWD_RPAREN
.9b65		f0 08		beq $9b6f			beq 	_URNoModulus 				; then we return a random 30 bit number.
.9b67		e8		inx				inx
.9b68		20 f0 9d	jsr $9df0			jsr 	Evaluate16BitInteger 		; put modulus value in +1
.9b6b		ca		dex				dex
.9b6c		20 08 91	jsr $9108			jsr 	IntegerModulusNoCheck 		; calculate modulus, so now 0 .. n-1
.9b6f						_URNoModulus:
.9b6f		74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer positive
.9b71		74 78		stz $78,x			stz 	NSExponent,x
.9b73		20 30 8f	jsr $8f30			jsr 	CheckRightBracket
.9b76		60		rts				rts
.9b77						Unary_Rnd:
.9b77		fa		plx				plx
.9b78		20 be 9d	jsr $9dbe			jsr 	EvaluateNumber 				; number to use.
.9b7b		20 30 8f	jsr $8f30			jsr 	CheckRightBracket 			; closing bracket
.9b7e		20 92 9e	jsr $9e92			jsr 	NSMIsZero 					; if zero, then don't generate a new number
.9b81		f0 26		beq $9ba9			beq 	_URCopySeed
.9b83		b5 50		lda $50,x			lda 	NSStatus,x 					; if -ve, then seed using parameter
.9b85		10 1f		bpl $9ba6			bpl 	_URDontSeed
.9b87		b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy - value to seed butchering it.
.9b89		49 17		eor #$17			eor 	#$17
.9b8b		8d 08 04	sta $0408			sta 	RandomSeed+0
.9b8e		b5 60		lda $60,x			lda 	NSMantissa1,x
.9b90		49 a5		eor #$a5			eor 	#$A5
.9b92		8d 09 04	sta $0409			sta 	RandomSeed+1
.9b95		b5 68		lda $68,x			lda 	NSMantissa2,x
.9b97		49 c2		eor #$c2			eor 	#$C2
.9b99		8d 0a 04	sta $040a			sta 	RandomSeed+2
.9b9c		b5 70		lda $70,x			lda 	NSMantissa3,x
.9b9e		49 9d		eor #$9d			eor 	#$9D
.9ba0		8d 0b 04	sta $040b			sta 	RandomSeed+3
.9ba3		20 cc 9b	jsr $9bcc			jsr 	Random32Bit
.9ba6						_URDontSeed:
.9ba6		20 cc 9b	jsr $9bcc			jsr 	Random32Bit 				; generate a number
.9ba9						_URCopySeed:
.9ba9		20 b5 9b	jsr $9bb5			jsr 	URCopyToMantissa 			; copy into mantissa
.9bac		a9 e2		lda #$e2			lda 	#-30 						; force into 0-1 range
.9bae		95 78		sta $78,x			sta 	NSExponent,x
.9bb0		a9 08		lda #$08			lda 	#NSTFloat
.9bb2		95 50		sta $50,x			sta 	NSStatus,x 					; positive float
.9bb4		60		rts				rts
.9bb5						URCopyToMantissa:
.9bb5		ad 08 04	lda $0408			lda 	RandomSeed+0
.9bb8		95 58		sta $58,x			sta 	NSMantissa0,x
.9bba		ad 09 04	lda $0409			lda 	RandomSeed+1
.9bbd		95 60		sta $60,x			sta 	NSMantissa1,x
.9bbf		ad 0a 04	lda $040a			lda 	RandomSeed+2
.9bc2		95 68		sta $68,x			sta 	NSMantissa2,x
.9bc4		ad 0b 04	lda $040b			lda 	RandomSeed+3
.9bc7		29 3f		and #$3f			and 	#$3F 						; make legal mantissa
.9bc9		95 70		sta $70,x			sta 	NSMantissa3,x
.9bcb		60		rts				rts
.9bcc						Random32Bit:
.9bcc		5a		phy				phy
.9bcd		a0 07		ldy #$07			ldy 	#7 							; do it 7 times
.9bcf		ad 08 04	lda $0408			lda 	RandomSeed+0 				; check the seed isn't zero
.9bd2		d0 03		bne $9bd7			bne 	_Random1
.9bd4		a8		tay				tay 								; if so do it 256 times
.9bd5		a9 aa		lda #$aa			lda		#$AA 						; and use this to seed the seed....
.9bd7						_Random1:
.9bd7		0a		asl a				asl 	a 							; LSFR RNG
.9bd8		2e 09 04	rol $0409			rol 	RandomSeed+1
.9bdb		2e 0a 04	rol $040a			rol 	RandomSeed+2
.9bde		2e 0b 04	rol $040b			rol 	RandomSeed+3
.9be1		90 02		bcc $9be5			bcc 	_Random2
.9be3		49 c5		eor #$c5			eor 	#$C5
.9be5						_Random2:
.9be5		88		dey				dey
.9be6		d0 ef		bne $9bd7			bne 	_Random1
.9be8		8d 08 04	sta $0408			sta 	RandomSeed+0
.9beb		7a		ply				ply
.9bec		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/sgn.asm

.9bed						SgnUnary:
.9bed		fa		plx				plx 								; restore stack pos
.9bee		20 be 9d	jsr $9dbe			jsr 	EvaluateNumber 				; get a float or int
.9bf1		20 30 8f	jsr $8f30			jsr 	CheckRightBracket
.9bf4		20 92 9e	jsr $9e92			jsr 	NSMIsZero 					; if zero
.9bf7		f0 0e		beq $9c07			beq 	_SGZero  					; return Int Zero
.9bf9		b5 50		lda $50,x			lda 	NSStatus,x 					; get status w/sign
.9bfb		48		pha				pha
.9bfc		a9 01		lda #$01			lda 	#1 							; set to 1
.9bfe		20 72 9e	jsr $9e72			jsr 	NSMSetByte
.9c01		68		pla				pla
.9c02		29 80		and #$80			and		#$80 						; copy the sign byte out
.9c04		95 50		sta $50,x			sta 	NSStatus,x  				; so it will be -1 or 1
.9c06		60		rts				rts
.9c07		20 70 9e	jsr $9e70	_SGZero:jsr 	NSMSetZero
.9c0a		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/val.asm

.9c0b						ValUnary:
.9c0b		fa		plx				plx 								; restore stack pos
.9c0c		20 21 9c	jsr $9c21			jsr 	ValMainCode 				; do the main val() code
.9c0f		b0 01		bcs $9c12			bcs 	_VUError 					; couldn't convert
.9c11		60		rts				rts
.9c12						_VUError:
.9c12		4c f8 9f	jmp $9ff8			jmp 	TypeError
.9c15						IsValUnary:
.9c15		fa		plx				plx 								; restore stack pos
.9c16		20 21 9c	jsr $9c21			jsr 	ValMainCode 				; do the main val() code
.9c19		b0 03		bcs $9c1e			bcs 	_VUBad
.9c1b		4c b6 8f	jmp $8fb6			jmp 	ReturnTrue
.9c1e						_VUBad:
.9c1e		4c c1 8f	jmp $8fc1			jmp 	ReturnFalse
.9c21						ValMainCode:
.9c21		20 c8 9d	jsr $9dc8			jsr 	EvaluateString 				; get a string
.9c24		20 30 8f	jsr $8f30			jsr 	CheckRightBracket 			; check right bracket present
.9c27						ValEvaluateZTemp0:
.9c27		5a		phy				phy
.9c28		b2 36		lda ($36)			lda 	(zTemp0) 					; check not empty string
.9c2a		f0 17		beq $9c43			beq 	_VMCFail2
.9c2c		a0 ff		ldy #$ff			ldy 	#$FF 						; start position
.9c2e		48		pha				pha 								; save first character
.9c2f		c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.9c31		d0 01		bne $9c34			bne 	_VMCStart
.9c33		c8		iny				iny 								; skip over -
.9c34						_VMCStart:
.9c34		38		sec				sec 								; initialise first time round.
.9c35						_VMCNext:
.9c35		c8		iny				iny 								; pre-increment
.9c36		b1 36		lda ($36),y			lda 	(zTemp0),y 					; next character = EOS ?
.9c38		f0 0c		beq $9c46			beq 	_VMCSuccess 				; successful.
.9c3a		20 93 97	jsr $9793			jsr 	EncodeNumber 				; send it to the number-builder
.9c3d		90 03		bcc $9c42			bcc 	_VMCFail 					; if failed, give up.
.9c3f		18		clc				clc 								; next time round, countinue
.9c40		80 f3		bra $9c35			bra 	_VMCNext
.9c42						_VMCFail:
.9c42		68		pla				pla
.9c43						_VMCFail2:
.9c43		7a		ply				ply
.9c44		38		sec				sec
.9c45		60		rts				rts
.9c46						_VMCSuccess:
.9c46		a9 00		lda #$00			lda 	#0 							; construct final
.9c48		20 93 97	jsr $9793			jsr 	EncodeNumber 				; by sending a duff value.
.9c4b		68		pla				pla 								; if it was -ve
.9c4c		c9 2d		cmp #$2d			cmp 	#"-"
.9c4e		d0 03		bne $9c53			bne 	_VMCNotNegative
.9c50		20 32 9e	jsr $9e32			jsr		NSMNegate 					; negate it.
.9c53						_VMCNotNegative:
.9c53		7a		ply				ply
.9c54		18		clc				clc
.9c55		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/chr.asm

.9c56						ChrUnary:
.9c56		fa		plx				plx 								; restore stack pos
.9c57		20 0b 9e	jsr $9e0b			jsr 	Evaluate8BitInteger			; get value (chr$(0) returns an empty string)
.9c5a		48		pha				pha
.9c5b		20 30 8f	jsr $8f30			jsr 	CheckRightBracket
.9c5e		a9 01		lda #$01			lda 	#1 							; allocate space for one char
.9c60		20 02 a8	jsr $a802			jsr 	StringTempAllocate
.9c63		68		pla				pla 								; write number to it
.9c64		20 3b a8	jsr $a83b			jsr 	StringTempWrite
.9c67		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/spc.asm

.9c68						SpcUnary:
.9c68		fa		plx				plx 								; restore stack pos
.9c69		20 0b 9e	jsr $9e0b			jsr 	Evaluate8BitInteger			; get value
.9c6c		5a		phy				phy
.9c6d		48		pha				pha 								; save count
.9c6e		20 02 a8	jsr $a802			jsr 	StringTempAllocate
.9c71		7a		ply				ply 								; to do count in Y
.9c72						_SpcLoop:
.9c72		c0 00		cpy #$00			cpy 	#0 							; copy Y spaces in.
.9c74		f0 08		beq $9c7e			beq 	_SpcExit
.9c76		a9 20		lda #$20			lda 	#32
.9c78		20 3b a8	jsr $a83b			jsr 	StringTempWrite
.9c7b		88		dey				dey
.9c7c		80 f4		bra $9c72			bra 	_SPCLoop
.9c7e						_SpcExit:
.9c7e		7a		ply				ply
.9c7f		20 30 8f	jsr $8f30			jsr 	CheckRightBracket
.9c82		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/str.asm

.9c83						Unary_Str:
.9c83		fa		plx				plx
.9c84		20 be 9d	jsr $9dbe			jsr 	EvaluateNumber  			; get number
.9c87		20 30 8f	jsr $8f30			jsr 	CheckRightBracket 			; closing bracket
.9c8a		a9 05		lda #$05			lda 	#5 							; maximum decimals, from Basic816
.9c8c		20 a5 9c	jsr $9ca5			jsr 	ConvertNumberToString 		; do the conversion.
.9c8f		a9 21		lda #$21			lda		#33 						; create buffer
.9c91		20 02 a8	jsr $a802			jsr 	StringTempAllocate 			; allocate memory
.9c94		da		phx				phx  								; copy the converted string into the buffer.
.9c95		a2 00		ldx #$00			ldx 	#0
.9c97						_USCopy:
.9c97		bd 49 06	lda $0649,x			lda 	DecimalBuffer,x
.9c9a		20 3b a8	jsr $a83b			jsr 	StringTempWrite
.9c9d		e8		inx				inx
.9c9e		bd 49 06	lda $0649,x			lda 	DecimalBuffer,x
.9ca1		d0 f4		bne $9c97			bne 	_USCopy
.9ca3		fa		plx				plx
.9ca4		60		rts				rts
.9ca5						ConvertNumberToString:
.9ca5		5a		phy				phy 								; save code position
.9ca6		8d 14 04	sta $0414			sta 	DecimalPlaces	 			; save number of DPs.
.9ca9		9c 15 04	stz $0415			stz 	dbOffset 					; offset into decimal buffer = start.
.9cac		b5 50		lda $50,x			lda 	NSStatus,x  				; is it -ve.
.9cae		10 09		bpl $9cb9			bpl 	_CNTSNotNegative
.9cb0		29 7f		and #$7f			and 	#$7F 						; make +ve
.9cb2		95 50		sta $50,x			sta 	NSStatus,x
.9cb4		a9 2d		lda #$2d			lda 	#"-"
.9cb6		20 1a 9d	jsr $9d1a			jsr 	WriteDecimalBuffer
.9cb9						_CNTSNotNegative:
.9cb9		b5 78		lda $78,x			lda 	NSExponent,x 				; check if decimal
.9cbb		f0 12		beq $9ccf			beq 	_CNTSNotFloat
.9cbd		e8		inx				inx 								; round up so we don't get too many 6.999999
.9cbe		a9 01		lda #$01			lda 	#1
.9cc0		20 72 9e	jsr $9e72			jsr 	NSMSetByte
.9cc3		ca		dex				dex
.9cc4		b5 78		lda $78,x			lda		NSExponent,x
.9cc6		95 79		sta $79,x			sta 	NSExponent+1,x
.9cc8		a9 08		lda #$08			lda 	#NSTFloat
.9cca		95 51		sta $51,x			sta 	NSStatus+1,x
.9ccc		20 98 94	jsr $9498			jsr 	FloatAdd
.9ccf						_CNTSNotFloat:
.9ccf		20 fc 9c	jsr $9cfc			jsr 	MakePlusTwoString 			; do the integer part.
.9cd2		20 5e 95	jsr $955e			jsr 	FloatFractionalPart 		; get the fractional part
.9cd5		20 0f 96	jsr $960f			jsr 	NSNormalise					; normalise , exit if zero
.9cd8		f0 20		beq $9cfa			beq 	_CNTSExit
.9cda		a9 2e		lda #$2e			lda 	#"."
.9cdc		20 1a 9d	jsr $9d1a			jsr 	WriteDecimalBuffer 			; write decimal place
.9cdf						_CNTSDecimal:
.9cdf		ce 14 04	dec $0414			dec 	DecimalPlaces 				; done all the decimals
.9ce2		30 16		bmi $9cfa			bmi 	_CNTSExit
.9ce4		e8		inx				inx 								; x 10.0
.9ce5		a9 0a		lda #$0a			lda 	#10
.9ce7		20 72 9e	jsr $9e72			jsr 	NSMSetByte
.9cea		a9 08		lda #$08			lda 	#NSTFloat
.9cec		95 50		sta $50,x			sta 	NSStatus,x
.9cee		ca		dex				dex
.9cef		20 dd 95	jsr $95dd			jsr 	FloatMultiply
.9cf2		20 fc 9c	jsr $9cfc			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.9cf5		20 5e 95	jsr $955e			jsr 	FloatFractionalPart 		; get the fractional part
.9cf8		80 e5		bra $9cdf			bra 	_CNTSDecimal 				; keep going.
.9cfa						_CNTSExit:
.9cfa		7a		ply				ply
.9cfb		60		rts				rts
.9cfc						MakePlusTwoString:
.9cfc		da		phx				phx
.9cfd		20 53 9e	jsr $9e53			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.9d00		e8		inx				inx 								; access it
.9d01		e8		inx				inx
.9d02		20 b6 95	jsr $95b6			jsr 	FloatIntegerPart 			; make it an integer
.9d05		a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.9d07		20 c8 93	jsr $93c8			jsr 	ConvertInt32
.9d0a		a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.9d0c						_MPTSCopy:
.9d0c		bd 27 06	lda $0627,x			lda 	NumberBuffer,x
.9d0f		20 1a 9d	jsr $9d1a			jsr 	WriteDecimalBuffer
.9d12		e8		inx				inx
.9d13		bd 27 06	lda $0627,x			lda 	NumberBuffer,x
.9d16		d0 f4		bne $9d0c			bne 	_MPTSCopy
.9d18		fa		plx				plx
.9d19		60		rts				rts
.9d1a						WriteDecimalBuffer:
.9d1a		da		phx				phx
.9d1b		ae 15 04	ldx $0415			ldx 	dbOffset
.9d1e		9d 49 06	sta $0649,x			sta 	DecimalBuffer,x
.9d21		9e 4a 06	stz $064a,x			stz 	DecimalBuffer+1,x
.9d24		ee 15 04	inc $0415			inc 	dbOffset
.9d27		fa		plx				plx
.9d28		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/substring.asm

.9d29						Unary_Left:
.9d29		fa		plx				plx
.9d2a		18		clc				clc 								; only one parameter
.9d2b		20 8e 9d	jsr $9d8e			jsr 	SubstringInitial 			; set up.
.9d2e		b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; Param #1 is the length
.9d30		95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9d32		74 59		stz $59,x			stz 	NSMantissa0+1,x 			; Start is zero.
.9d34		80 25		bra $9d5b			bra 	SubstringMain
.9d36						Unary_Right:
.9d36		fa		plx				plx
.9d37		18		clc				clc 								; only one parameter
.9d38		20 8e 9d	jsr $9d8e			jsr 	SubstringInitial 			; set up.
.9d3b		b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; length => param 2
.9d3d		95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9d3f		b5 78		lda $78,x			lda 	NSExponent,x 				; total length
.9d41		f5 59		sbc $59,x			sbc 	NSMantissa0+1,x 			; length - required.
.9d43		b0 02		bcs $9d47			bcs 	_URNotUnderflow
.9d45		a9 00		lda #$00			lda 	#0 							; start from the beginning, as something like right$("AB",3)
.9d47						_URNotUnderFlow:
.9d47		95 59		sta $59,x			sta 	NSMantissa0+1,x 			; this is the start position
.9d49		80 10		bra $9d5b			bra 	SubStringMain
.9d4b						Unary_Mid:
.9d4b		fa		plx				plx
.9d4c		38		sec				sec 								; two parameters
.9d4d		20 8e 9d	jsr $9d8e			jsr 	SubstringInitial 			; set up.
.9d50		b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; first parameter is zero ?
.9d52		f0 04		beq $9d58			beq 	_UMError
.9d54		d6 59		dec $59,x			dec 	NSMantissa0+1,x				; reduce initial offset by 1 as MID$(a$,1..) is actually the first character
.9d56		80 03		bra $9d5b			bra 	SubStringMain
.9d58						_UMError:
.9d58		4c fd 9f	jmp $9ffd			jmp 	ArgumentError
.9d5b						SubStringMain:
.9d5b		b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; is the initial offset >= the length
.9d5d		d5 78		cmp $78,x			cmp 	NSExponent,x
.9d5f		b0 27		bcs $9d88			bcs 	_SSMNull 					; if so, return an empty string.
.9d61		b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; if copy count is zero
.9d63		f0 23		beq $9d88			beq 	_SSMNull 					; return empty string.
.9d65		18		clc				clc 								; add the offset +1 to the address and
.9d66		b5 58		lda $58,x			lda	 	NSMantissa0,x 				; put in zTemp, this is the start of the substring to copy.
.9d68		75 59		adc $59,x			adc 	NSMantissa0+1,x
.9d6a		85 36		sta $36				sta 	zTemp0
.9d6c		b5 60		lda $60,x			lda	 	NSMantissa1,x
.9d6e		69 00		adc #$00			adc 	#0
.9d70		85 37		sta $37				sta 	zTemp0+1
.9d72						_SSMNoCarry:
.9d72		b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; characters required.
.9d74		20 02 a8	jsr $a802			jsr 	StringTempAllocate 			; allocate that many characters
.9d77		5a		phy				phy 								; save Y
.9d78		a0 00		ldy #$00			ldy 	#0 							; start copying in.
.9d7a						_SSMCopy:
.9d7a		b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next character
.9d7c		f0 08		beq $9d86			beq 	_SSMEString 				; no more to copy
.9d7e		20 3b a8	jsr $a83b			jsr 	StringTempWrite 			; and write it out.
.9d81		c8		iny				iny
.9d82		d6 5a		dec $5a,x			dec 	NSMantissa0+2,x
.9d84		d0 f4		bne $9d7a			bne 	_SSMCopy
.9d86						_SSMEString:
.9d86		7a		ply				ply
.9d87						_SSMExit:
.9d87		60		rts				rts
.9d88						_SSMNull:
.9d88		a9 00		lda #$00			lda 	#0
.9d8a		20 02 a8	jsr $a802			jsr 	StringTempAllocate
.9d8d		60		rts				rts
.9d8e						SubstringInitial:
.9d8e		da		phx				phx 								; save initial stack position
.9d8f		08		php				php 								; save carry on stack indicating 2 parameters
.9d90		20 c8 9d	jsr $9dc8			jsr 	EvaluateString 				; get a string
.9d93		5a		phy				phy 								; calculate length to exponent.
.9d94		a0 ff		ldy #$ff			ldy 	#$FF
.9d96						_SIFindLength:
.9d96		c8		iny				iny
.9d97		b1 36		lda ($36),y			lda 	(zTemp0),y
.9d99		d0 fb		bne $9d96			bne 	_SIFindLength
.9d9b		98		tya				tya
.9d9c		95 78		sta $78,x			sta 	NSExponent,x
.9d9e		7a		ply				ply
.9d9f		e8		inx				inx
.9da0		20 38 8f	jsr $8f38			jsr 	CheckComma 					; comma next
.9da3		20 0b 9e	jsr $9e0b			jsr 	Evaluate8BitInteger 		; get next parameter
.9da6		28		plp				plp 								; is it the last parameter ?
.9da7		90 07		bcc $9db0			bcc 	_SSIExit 					; if so, exit.
.9da9		e8		inx				inx
.9daa		20 38 8f	jsr $8f38			jsr 	CheckComma 					; comma next
.9dad		20 0b 9e	jsr $9e0b			jsr 	Evaluate8BitInteger 		; get last parameter
.9db0						_SSIExit:
.9db0		fa		plx				plx
.9db1		20 30 8f	jsr $8f30			jsr 	CheckRightBracket 			; check closing bracket
.9db4		60		rts				rts 								; exit

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/exprhelper.asm

.9db5						EvaluateValue:
.9db5		48		pha				pha
.9db6		20 4d 94	jsr $944d			jsr		EvaluateExpression 			; expression
.9db9		20 10 97	jsr $9710			jsr 	Dereference					; derefernce it
.9dbc		68		pla				pla
.9dbd		60		rts				rts
.9dbe						EvaluateNumber:
.9dbe		20 b5 9d	jsr $9db5			jsr 	EvaluateValue 				; get a value
.9dc1		b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.9dc3		29 10		and #$10			and 	#NSBIsString
.9dc5		d0 13		bne $9dda			bne 	HelperTypeError
.9dc7		60		rts				rts
.9dc8						EvaluateString:
.9dc8		20 b5 9d	jsr $9db5			jsr 	EvaluateValue 				; get a value
.9dcb		b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.9dcd		29 10		and #$10			and 	#NSBIsString
.9dcf		f0 09		beq $9dda			beq 	HelperTypeError
.9dd1						CopyAddressToTemp0:
.9dd1		b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address -> zTemp0
.9dd3		85 36		sta $36				sta 	zTemp0 						; (so we can do something with it)
.9dd5		b5 60		lda $60,x			lda 	NSMantissa1,x
.9dd7		85 37		sta $37				sta 	zTemp0+1
.9dd9		60		rts				rts
.9dda						HelperTypeError:
.9dda		4c f8 9f	jmp $9ff8			jmp 	TypeError
.9ddd						EvaluateInteger:
.9ddd		20 be 9d	jsr $9dbe			jsr 	EvaluateNumber
.9de0		b5 78		lda $78,x			lda 	NSExponent,x 				; check exponent is zero
.9de2		d0 09		bne $9ded			bne 	HelperValueError 			; if not, it's a float.
.9de4		60		rts				rts
.9de5						EvaluateUnsignedInteger:
.9de5		20 dd 9d	jsr $9ddd			jsr 	EvaluateInteger 			; check integer is +ve
.9de8		b5 50		lda $50,x			lda 	NSStatus,x
.9dea		30 01		bmi $9ded			bmi 	HelperValueError
.9dec		60		rts				rts
.9ded						HelperValueError:
.9ded		4c fd 9f	jmp $9ffd			jmp 	ArgumentError
.9df0						Evaluate16BitInteger:
.9df0		20 e5 9d	jsr $9de5			jsr	 	EvaluateUnsignedInteger		; get integer
.9df3		b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9df5		15 68		ora $68,x			ora 	NSMantissa2,x
.9df7		d0 f4		bne $9ded			bne 	HelperValueError
.9df9		60		rts				rts
.9dfa						Evaluate16BitIntegerSigned:
.9dfa		20 dd 9d	jsr $9ddd			jsr	 	EvaluateInteger				; get integer
.9dfd		b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9dff		15 68		ora $68,x			ora 	NSMantissa2,x
.9e01		d0 ea		bne $9ded			bne 	HelperValueError
.9e03		b5 50		lda $50,x			lda 	NSStatus,x 					; signed ?
.9e05		10 03		bpl $9e0a			bpl 	_EISNotSigned
.9e07		20 39 9e	jsr $9e39			jsr 	NSMNegateMantissa 			; makes it an actual 2's complement value.
.9e0a						_EISNotSigned:
.9e0a		60		rts				rts
.9e0b						Evaluate8BitInteger:
.9e0b		20 e5 9d	jsr $9de5			jsr	 	EvaluateUnsignedInteger 	; get an integer
.9e0e		d0 dd		bne $9ded			bne 	HelperValueError
.9e10		b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 1, 2 & 3 must be zero
.9e12		15 68		ora $68,x			ora 	NSMantissa2,x
.9e14		15 60		ora $60,x			ora 	NSMantissa1,x
.9e16		d0 d5		bne $9ded			bne 	HelperValueError
.9e18		b5 58		lda $58,x			lda 	NSMantissa0,x
.9e1a		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/mult8x8.asm

.9e1b						Multiply8x8:
.9e1b		4a		lsr a		  		lsr 	a  							; prime the carry bit for the loop
.9e1c		85 36		sta $36			  	sta 	zTemp0
.9e1e		86 37		stx $37				stx 	zTemp0+1
.9e20		a9 00		lda #$00			lda 	#0
.9e22		a2 08		ldx #$08			ldx 	#8
.9e24						_M88Loop:
.9e24		90 03		bcc $9e29			bcc 	_M88NoAdd
.9e26		18		clc				clc
.9e27		65 37		adc $37				adc 	zTemp0+1
.9e29						_M88NoAdd:
.9e29		6a		ror a				ror 	a
.9e2a		66 36		ror $36				ror 	zTemp0  					; pull another bit out for the next iteration
.9e2c		ca		dex				dex         						; inc/dec don't modify carry; only shifts and adds do
.9e2d		d0 f5		bne $9e24			bne 	_M88Loop
.9e2f		85 37		sta $37				sta 	zTemp0+1 					; store high 8 bits.
.9e31		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/utility.asm

.9e32						NSMNegate:
.9e32		b5 50		lda $50,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.9e34		49 80		eor #$80			eor 	#NSBIsNegative  			; toggle the negative flag
.9e36		95 50		sta $50,x			sta 	NSStatus,x
.9e38		60		rts				rts
.9e39						NSMNegateMantissa:
.9e39		38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.9e3a		a9 00		lda #$00			lda 	#0
.9e3c		f5 58		sbc $58,x			sbc 	NSMantissa0,x
.9e3e		95 58		sta $58,x			sta 	NSMantissa0,x
.9e40		a9 00		lda #$00			lda 	#0
.9e42		f5 60		sbc $60,x			sbc 	NSMantissa1,x
.9e44		95 60		sta $60,x			sta 	NSMantissa1,x
.9e46		a9 00		lda #$00			lda 	#0
.9e48		f5 68		sbc $68,x			sbc 	NSMantissa2,x
.9e4a		95 68		sta $68,x			sta 	NSMantissa2,x
.9e4c		a9 00		lda #$00			lda 	#0
.9e4e		f5 70		sbc $70,x			sbc 	NSMantissa3,x
.9e50		95 70		sta $70,x			sta 	NSMantissa3,x
.9e52		60		rts				rts
.9e53						NSMShiftUpTwo:
.9e53		b5 58		lda $58,x			lda 	NSMantissa0,x
.9e55		95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9e57		b5 60		lda $60,x			lda 	NSMantissa1,x
.9e59		95 62		sta $62,x			sta 	NSMantissa1+2,x
.9e5b		b5 68		lda $68,x			lda 	NSMantissa2,x
.9e5d		95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.9e5f		b5 70		lda $70,x			lda 	NSMantissa3,x
.9e61		95 72		sta $72,x			sta 	NSMantissa3+2,x
.9e63		b5 78		lda $78,x			lda 	NSExponent,x
.9e65		95 7a		sta $7a,x			sta 	NSExponent+2,x
.9e67		b5 50		lda $50,x			lda 	NSStatus,x
.9e69		95 52		sta $52,x			sta 	NSStatus+2,x
.9e6b		60		rts				rts
.9e6c						NSMSetZeroMantissaOnly:
.9e6c		a9 00		lda #$00			lda 	#0
.9e6e		80 06		bra $9e76			bra 	NSMSetMantissa
.9e70						NSMSetZero:
.9e70		a9 00		lda #$00			lda 	#0
.9e72						NSMSetByte:
.9e72		74 78		stz $78,x			stz 	NSExponent,x 				; zero exponent, as integer.
.9e74		74 50		stz $50,x			stz 	NSStatus,x 					; status zero (integer)
.9e76						NSMSetMantissa:
.9e76		95 58		sta $58,x			sta 	NSMantissa0,x 				; mantissa
.9e78		74 60		stz $60,x			stz 	NSMantissa1,x
.9e7a		74 68		stz $68,x			stz 	NSMantissa2,x
.9e7c		74 70		stz $70,x			stz 	NSMantissa3,x
.9e7e		60		rts				rts
.9e7f						NSMShiftLeft:
.9e7f		18		clc				clc
.9e80						NSMRotateLeft:
.9e80		36 58		rol $58,x			rol 	NSMantissa0,x
.9e82		36 60		rol $60,x			rol		NSMantissa1,x
.9e84		36 68		rol $68,x			rol		NSMantissa2,x
.9e86		36 70		rol $70,x			rol		NSMantissa3,x
.9e88		60		rts				rts
.9e89						NSMShiftRight:
.9e89		56 70		lsr $70,x			lsr 	NSMantissa3,x
.9e8b		76 68		ror $68,x			ror		NSMantissa2,x
.9e8d		76 60		ror $60,x			ror		NSMantissa1,x
.9e8f		76 58		ror $58,x			ror		NSMantissa0,x
.9e91		60		rts				rts
.9e92						NSMIsZero:
.9e92		b5 70		lda $70,x			lda 	NSMantissa3,x
.9e94		15 68		ora $68,x			ora		NSMantissa2,x
.9e96		15 60		ora $60,x			ora		NSMantissa1,x
.9e98		15 58		ora $58,x			ora		NSMantissa0,x
.9e9a		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.asm

.9e9b						TickHandler:
.9e9b		5a		phy				phy 								; need to preserve Y
.9e9c		20 53 80	jsr $8053			jsr 	SNDUpdate 					; update sound
.9e9f		7a		ply				ply
.9ea0		60		rts				rts
.065c						LastTick:
>065c								.fill 		1

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/asmcore.asm

.9ea1						Assemble_ora:
.9ea1		20 01 81	jsr $8101		jsr	AssembleGroup1
>9ea4		01					.byte $01
.9ea5						Assemble_and:
.9ea5		20 01 81	jsr $8101		jsr	AssembleGroup1
>9ea8		21					.byte $21
.9ea9						Assemble_eor:
.9ea9		20 01 81	jsr $8101		jsr	AssembleGroup1
>9eac		41					.byte $41
.9ead						Assemble_adc:
.9ead		20 01 81	jsr $8101		jsr	AssembleGroup1
>9eb0		61					.byte $61
.9eb1						Assemble_sta:
.9eb1		20 01 81	jsr $8101		jsr	AssembleGroup1
>9eb4		81					.byte $81
.9eb5						Assemble_lda:
.9eb5		20 01 81	jsr $8101		jsr	AssembleGroup1
>9eb8		a1					.byte $a1
.9eb9						Assemble_cmp:
.9eb9		20 01 81	jsr $8101		jsr	AssembleGroup1
>9ebc		c1					.byte $c1
.9ebd						Assemble_sbc:
.9ebd		20 01 81	jsr $8101		jsr	AssembleGroup1
>9ec0		e1					.byte $e1
.9ec1						Assemble_asl:
.9ec1		20 08 81	jsr $8108		jsr	AssembleGroup2
>9ec4		02					.byte $02
>9ec5		75					.byte $75
.9ec6						Assemble_rol:
.9ec6		20 08 81	jsr $8108		jsr	AssembleGroup2
>9ec9		22					.byte $22
>9eca		75					.byte $75
.9ecb						Assemble_lsr:
.9ecb		20 08 81	jsr $8108		jsr	AssembleGroup2
>9ece		42					.byte $42
>9ecf		75					.byte $75
.9ed0						Assemble_ror:
.9ed0		20 08 81	jsr $8108		jsr	AssembleGroup2
>9ed3		62					.byte $62
>9ed4		75					.byte $75
.9ed5						Assemble_stx:
.9ed5		20 08 81	jsr $8108		jsr	AssembleGroup2
>9ed8		82					.byte $82
>9ed9		50					.byte $50
.9eda						Assemble_ldx:
.9eda		20 08 81	jsr $8108		jsr	AssembleGroup2
>9edd		a2					.byte $a2
>9ede		d0					.byte $d0
.9edf						Assemble_dec:
.9edf		20 08 81	jsr $8108		jsr	AssembleGroup2
>9ee2		c2					.byte $c2
>9ee3		55					.byte $55
.9ee4						Assemble_inc:
.9ee4		20 08 81	jsr $8108		jsr	AssembleGroup2
>9ee7		e2					.byte $e2
>9ee8		55					.byte $55
.9ee9						Assemble_stz:
.9ee9		20 08 81	jsr $8108		jsr	AssembleGroup2
>9eec		60					.byte $60
>9eed		44					.byte $44
.9eee						Assemble_bit:
.9eee		20 08 81	jsr $8108		jsr	AssembleGroup2
>9ef1		20					.byte $20
>9ef2		55					.byte $55
.9ef3						Assemble_sty:
.9ef3		20 08 81	jsr $8108		jsr	AssembleGroup2
>9ef6		80					.byte $80
>9ef7		54					.byte $54
.9ef8						Assemble_ldy:
.9ef8		20 08 81	jsr $8108		jsr	AssembleGroup2
>9efb		a0					.byte $a0
>9efc		d5					.byte $d5
.9efd						Assemble_cpy:
.9efd		20 08 81	jsr $8108		jsr	AssembleGroup2
>9f00		c0					.byte $c0
>9f01		d4					.byte $d4
.9f02						Assemble_cpx:
.9f02		20 08 81	jsr $8108		jsr	AssembleGroup2
>9f05		e0					.byte $e0
>9f06		d0					.byte $d0
.9f07						Assemble_tsb:
.9f07		20 08 81	jsr $8108		jsr	AssembleGroup2
>9f0a		00					.byte $00
>9f0b		50					.byte $50
.9f0c						Assemble_trb:
.9f0c		20 08 81	jsr $8108		jsr	AssembleGroup2
>9f0f		10					.byte $10
>9f10		50					.byte $50
.9f11						Assemble_jsr:
.9f11		20 08 81	jsr $8108		jsr	AssembleGroup2
>9f14		14					.byte $14
>9f15		10					.byte $10
.9f16						Assemble_jmp:
.9f16		20 08 81	jsr $8108		jsr	AssembleGroup2
>9f19		40					.byte $40
>9f1a		10					.byte $10
.9f1b						Assemble_bpl:
.9f1b		20 59 81	jsr $8159		jsr	AssembleGroup3
>9f1e		10					.byte $10
.9f1f						Assemble_bmi:
.9f1f		20 59 81	jsr $8159		jsr	AssembleGroup3
>9f22		30					.byte $30
.9f23						Assemble_bvc:
.9f23		20 59 81	jsr $8159		jsr	AssembleGroup3
>9f26		50					.byte $50
.9f27						Assemble_bvs:
.9f27		20 59 81	jsr $8159		jsr	AssembleGroup3
>9f2a		70					.byte $70
.9f2b						Assemble_bcc:
.9f2b		20 59 81	jsr $8159		jsr	AssembleGroup3
>9f2e		90					.byte $90
.9f2f						Assemble_bcs:
.9f2f		20 59 81	jsr $8159		jsr	AssembleGroup3
>9f32		b0					.byte $b0
.9f33						Assemble_bne:
.9f33		20 59 81	jsr $8159		jsr	AssembleGroup3
>9f36		d0					.byte $d0
.9f37						Assemble_beq:
.9f37		20 59 81	jsr $8159		jsr	AssembleGroup3
>9f3a		f0					.byte $f0
.9f3b						Assemble_bra:
.9f3b		20 59 81	jsr $8159		jsr	AssembleGroup3
>9f3e		80					.byte $80
.9f3f						Assemble_brk:
.9f3f		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f42		00					.byte $00
.9f43						Assemble_php:
.9f43		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f46		08					.byte $08
.9f47						Assemble_clc:
.9f47		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f4a		18					.byte $18
.9f4b						Assemble_plp:
.9f4b		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f4e		28					.byte $28
.9f4f						Assemble_sec:
.9f4f		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f52		38					.byte $38
.9f53						Assemble_rti:
.9f53		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f56		40					.byte $40
.9f57						Assemble_pha:
.9f57		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f5a		48					.byte $48
.9f5b						Assemble_cli:
.9f5b		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f5e		58					.byte $58
.9f5f						Assemble_phy:
.9f5f		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f62		5a					.byte $5a
.9f63						Assemble_rts:
.9f63		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f66		60					.byte $60
.9f67						Assemble_pla:
.9f67		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f6a		68					.byte $68
.9f6b						Assemble_sei:
.9f6b		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f6e		78					.byte $78
.9f6f						Assemble_ply:
.9f6f		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f72		7a					.byte $7a
.9f73						Assemble_dey:
.9f73		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f76		88					.byte $88
.9f77						Assemble_txa:
.9f77		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f7a		8a					.byte $8a
.9f7b						Assemble_tya:
.9f7b		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f7e		98					.byte $98
.9f7f						Assemble_txs:
.9f7f		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f82		9a					.byte $9a
.9f83						Assemble_tay:
.9f83		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f86		a8					.byte $a8
.9f87						Assemble_tax:
.9f87		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f8a		aa					.byte $aa
.9f8b						Assemble_clv:
.9f8b		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f8e		b8					.byte $b8
.9f8f						Assemble_tsx:
.9f8f		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f92		ba					.byte $ba
.9f93						Assemble_iny:
.9f93		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f96		c8					.byte $c8
.9f97						Assemble_dex:
.9f97		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f9a		ca					.byte $ca
.9f9b						Assemble_cld:
.9f9b		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9f9e		d8					.byte $d8
.9f9f						Assemble_phx:
.9f9f		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9fa2		da					.byte $da
.9fa3						Assemble_stp:
.9fa3		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9fa6		db					.byte $db
.9fa7						Assemble_inx:
.9fa7		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9faa		e8					.byte $e8
.9fab						Assemble_nop:
.9fab		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9fae		ea					.byte $ea
.9faf						Assemble_sed:
.9faf		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9fb2		f8					.byte $f8
.9fb3						Assemble_plx:
.9fb3		20 8d 81	jsr $818d		jsr	AssembleGroup4
>9fb6		fa					.byte $fa

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/constants.asm

.9fb7						DecimalScalarTable:
>9fb7		66 66 66 66				.dword $66666666 ; 0.1
>9fbb		de					.byte $de
>9fbc		1f 85 eb 51				.dword $51eb851f ; 0.01
>9fc0		db					.byte $db
>9fc1		4c 37 89 41				.dword $4189374c ; 0.001
>9fc5		d8					.byte $d8
>9fc6		ac 8b db 68				.dword $68db8bac ; 0.0001
>9fca		d4					.byte $d4
>9fcb		24 d6 e2 53				.dword $53e2d624 ; 1e-05
>9fcf		d1					.byte $d1
>9fd0		83 de 1b 43				.dword $431bde83 ; 1e-06
>9fd4		ce					.byte $ce
>9fd5		6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>9fd9		ca					.byte $ca
>9fda		89 3b e6 55				.dword $55e63b89 ; 1e-08
>9fde		c7					.byte $c7
>9fdf		a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>9fe3		c4					.byte $c4
>9fe4		67 7f f3 6d				.dword $6df37f67 ; 1e-10
>9fe8		c0					.byte $c0
>9fe9		86 ff f5 57				.dword $57f5ff86 ; 1e-11
>9fed		bd					.byte $bd

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.asm

.9fee						SyntaxError:
.9fee		a9 02		lda #$02		lda	#2
.9ff0		4c 49 8f	jmp $8f49		jmp	ErrorHandler
.9ff3						RangeError:
.9ff3		a9 04		lda #$04		lda	#4
.9ff5		4c 49 8f	jmp $8f49		jmp	ErrorHandler
.9ff8						TypeError:
.9ff8		a9 05		lda #$05		lda	#5
.9ffa		4c 49 8f	jmp $8f49		jmp	ErrorHandler
.9ffd						ArgumentError:
.9ffd		a9 07		lda #$07		lda	#7
.9fff		4c 49 8f	jmp $8f49		jmp	ErrorHandler
.a002						NotDoneError:
.a002		a9 0c		lda #$0c		lda	#12
.a004		4c 49 8f	jmp $8f49		jmp	ErrorHandler
.a007						ErrorText:
>a007		42 72 65 61 6b 00			.text	"Break",0
>a00d		53 79 6e 74 61 78 20 65			.text	"Syntax error",0
>a015		72 72 6f 72 00
>a01a		44 69 76 69 73 69 6f 6e			.text	"Division by zero",0
>a022		20 62 79 20 7a 65 72 6f 00
>a02b		4f 75 74 20 6f 66 20 52			.text	"Out of Range",0
>a033		61 6e 67 65 00
>a038		54 79 70 65 20 6d 69 73			.text	"Type mismatch",0
>a040		6d 61 74 63 68 00
>a046		4f 75 74 20 6f 66 20 6d			.text	"Out of memory",0
>a04e		65 6d 6f 72 79 00
>a054		49 6c 6c 65 67 61 6c 20			.text	"Illegal argument",0
>a05c		61 72 67 75 6d 65 6e 74 00
>a065		53 74 6f 70 00				.text	"Stop",0
>a06a		53 74 72 69 6e 67 20 74			.text	"String too long",0
>a072		6f 6f 20 6c 6f 6e 67 00
>a07a		41 73 73 65 72 74 69 6f			.text	"Assertion failed",0
>a082		6e 20 66 61 69 6c 65 64 00
>a08b		4f 75 74 20 6f 66 20 64			.text	"Out of data",0
>a093		61 74 61 00
>a097		55 6e 69 6d 70 6c 65 6d			.text	"Unimplemented",0
>a09f		65 6e 74 65 64 00
>a0a5		4e 6f 20 73 75 63 68 20			.text	"No such line number",0
>a0ad		6c 69 6e 65 20 6e 75 6d 62 65 72 00
>a0b9		52 65 74 75 72 6e 20 77			.text	"Return without Gosub",0
>a0c1		69 74 68 6f 75 74 20 47 6f 73 75 62 00
>a0ce		55 6e 74 69 6c 20 77 69			.text	"Until without Repeat",0
>a0d6		74 68 6f 75 74 20 52 65 70 65 61 74 00
>a0e3		57 65 6e 64 20 77 69 74			.text	"Wend without While",0
>a0eb		68 6f 75 74 20 57 68 69 6c 65 00
>a0f6		4e 65 78 74 20 77 69 74			.text	"Next without For",0
>a0fe		68 6f 75 74 20 46 6f 72 00
>a107		42 41 53 49 43 20 53 74			.text	"BASIC Stack full",0
>a10f		61 63 6b 20 66 75 6c 6c 00
>a118		4f 70 65 6e 20 53 74 72			.text	"Open Structure",0
>a120		75 63 74 75 72 65 00
>a127		45 6e 64 50 72 6f 63 20			.text	"EndProc without call",0
>a12f		77 69 74 68 6f 75 74 20 63 61 6c 6c 00
>a13c		41 72 72 61 79 20 61 6c			.text	"Array already defined",0
>a144		72 65 61 64 79 20 64 65 66 69 6e 65 64 00
>a152		41 72 72 61 79 20 73 69			.text	"Array size",0
>a15a		7a 65 00
>a15d		42 61 64 20 61 72 72 61			.text	"Bad array index",0
>a165		79 20 69 6e 64 65 78 00
>a16d		41 72 72 61 79 20 6e 6f			.text	"Array not declared",0
>a175		74 20 64 65 63 6c 61 72 65 64 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/timestamp.asm

>a180		41 6c 70 68 61 20 31 35			.text "Alpha 15 built 12-Dec-22. "
>a188		20 62 75 69 6c 74 20 31 32 2d 44 65 63 2d 32 32
>a198		2e 20

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcommand.asm

.a19a						RectangleCommand:
.a19a		a9 44		lda #$44			lda 	#GCMD_FrameRect				; frame rectangle
.a19c		80 02		bra $a1a0			bra 	ShapeDrawCmd
.a19e						CircleCommand:
.a19e		a9 48		lda #$48			lda 	#GCMD_FrameCircle 				; framed circle
.a1a0						ShapeDrawCmd:
.a1a0		20 2a a2	jsr $a22a			jsr 	RunGraphicsCommand
.a1a3						ShapeDraw:
.a1a3		0d 5e 06	ora $065e			ora 	gxFillSolid  				; adjust AXY for solid fill.
.a1a6		4c 1e a2	jmp $a21e			jmp 	ExecuteGraphicCommand	 	; and complete
.a1a9						SpriteCommand:
.a1a9		a2 00		ldx #$00			ldx 	#0
.a1ab		20 0b 9e	jsr $9e0b			jsr 	Evaluate8BitInteger 		; get image number.
.a1ae		5a		phy				phy
.a1af		a9 0e		lda #$0e			lda 	#GCMD_SpriteUse 			; use that image.
.a1b1		a6 58		ldx $58				ldx 	NSMantissa0
.a1b3		e0 40		cpx #$40			cpx 	#64 						; 0-63 only
.a1b5		b0 0d		bcs $a1c4			bcs 	_SCRange
.a1b7		a0 ff		ldy #$ff			ldy 	#255
.a1b9		20 3f 80	jsr $803f			jsr 	GXGraphicDraw
.a1bc		a9 52		lda #$52			lda 	#GCMD_SpriteMove
.a1be		7a		ply				ply
.a1bf		20 2a a2	jsr $a22a			jsr 	RunGraphicsCommand
.a1c2		80 5a		bra $a21e			bra 	ExecuteGraphicCommand
.a1c4						_SCRange:
.a1c4		4c f3 9f	jmp $9ff3			jmp 	RangeError
.a1c7						ImageCommand:
.a1c7		a2 00		ldx #$00			ldx 	#0
.a1c9		20 0b 9e	jsr $9e0b			jsr 	Evaluate8BitInteger 		; get image number.
.a1cc		20 2a a2	jsr $a22a			jsr 	RunGraphicsCommand
.a1cf						ImageRunDraw:
.a1cf		09 40		ora #$40			ora 	#GCMD_Move					; move cursor
.a1d1		20 3f 80	jsr $803f			jsr 	GXGraphicDraw
.a1d4		ad 64 06	lda $0664			lda 	gxDrawScale
.a1d7		0a		asl a				asl 	a
.a1d8		0a		asl a				asl 	a
.a1d9		0a		asl a				asl 	a
.a1da		a8		tay				tay
.a1db		a9 0c		lda #$0c			lda 	#GCMD_DrawSprite 			; image drawing
.a1dd		a6 58		ldx $58				ldx 	NSMantissa0
.a1df		20 3f 80	jsr $803f			jsr 	GXGraphicDraw
.a1e2		60		rts				rts
.a1e3						TextCommand:
.a1e3		a2 00		ldx #$00			ldx 	#0
.a1e5		20 c8 9d	jsr $9dc8			jsr 	EvaluateString 				; get text
.a1e8		20 2a a2	jsr $a22a			jsr 	RunGraphicsCommand
.a1eb						TextRunDraw:
.a1eb		09 40		ora #$40			ora 	#GCMD_Move 					; move cursor
.a1ed		20 3f 80	jsr $803f			jsr 	GXGraphicDraw
.a1f0		a0 00		ldy #$00			ldy 	#0
.a1f2						_IRDLoop:
.a1f2		a5 60		lda $60				lda 	NSMantissa1 				; access character
.a1f4		85 37		sta $37				sta 	zTemp0+1
.a1f6		a5 58		lda $58				lda 	NSMantissa0
.a1f8		85 36		sta $36				sta 	zTemp0
.a1fa		b1 36		lda ($36),y			lda 	(zTemp0),y
.a1fc		f0 13		beq $a211			beq 	_IRDExit
.a1fe		5a		phy				phy									; save string pos
.a1ff		48		pha				pha 								; save char
.a200		ad 64 06	lda $0664			lda 	gxDrawScale 				; get scale
.a203		0a		asl a				asl 	a
.a204		0a		asl a				asl 	a
.a205		0a		asl a				asl 	a
.a206		a8		tay				tay
.a207		a9 0a		lda #$0a			lda 	#GCMD_DrawFont 				; char drawing
.a209		fa		plx				plx 								; char to draw
.a20a		20 3f 80	jsr $803f			jsr 	GXGraphicDraw
.a20d		7a		ply				ply 								; restore string pos
.a20e		c8		iny				iny
.a20f		90 e1		bcc $a1f2			bcc 	_IRDLoop 					; go back if no error.
.a211						_IRDExit:
.a211		60		rts				rts
.a212						PlotCommand:
.a212		a9 50		lda #$50			lda 	#GCMD_Plot 					; command ID to use
.a214		20 2a a2	jsr $a22a			jsr 	RunGraphicsCommand
.a217		80 05		bra $a21e			bra 	ExecuteGraphicCommand
.a219						LineCommand:
.a219		a9 42		lda #$42			lda 	#GCMD_Line 						; command ID to use
.a21b		20 2a a2	jsr $a22a			jsr 	RunGraphicsCommand
.a21e						ExecuteGraphicCommand:
.a21e		0d 5d 06	ora $065d			ora 	gxCommandID 				; make a full command
.a221		20 3f 80	jsr $803f			jsr 	GXGraphicDraw 				; draw it and exit
.a224		b0 01		bcs $a227			bcs 	_EGCError
.a226		60		rts				rts
.a227						_EGCError:
.a227		4c ee 9f	jmp $9fee			jmp 	SyntaxError
.a22a						RunGraphicsCommand:
.a22a		8d 5d 06	sta $065d			sta 	gxCommandID					; save TODO graphics command.
.a22d		68		pla				pla 								; pop handler address
.a22e		fa		plx				plx
.a22f		1a		inc a				inc 	a
.a230		d0 01		bne $a233			bne 	_RGINoCarry
.a232		e8		inx				inx
.a233						_RGINoCarry:
.a233		8d 62 06	sta $0662			sta 	GXHandler
.a236		8e 63 06	stx $0663			stx 	GXHandler+1
.a239						_RGICommandLoop:
.a239		b1 30		lda ($30),y			lda 	(codePtr),y
.a23b		c8		iny				iny
.a23c		c9 d2		cmp #$d2			cmp 	#KWD_TO						; is it TO x,y
.a23e		f0 53		beq $a293			beq 	_RGI_To
.a240		c9 bd		cmp #$bd			cmp 	#KWD_HERE 					; do it here.
.a242		f0 55		beq $a299			beq 	_RGI_Here
.a244		c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL or : , exit
.a246		f0 3d		beq $a285			beq 	_RGI_Exit
.a248		c9 3a		cmp #$3a			cmp 	#KWD_COLON
.a24a		f0 39		beq $a285			beq 	_RGI_Exit
.a24c		c9 c5		cmp #$c5			cmp 	#KWD_OUTLINE 				; solid or outline
.a24e		f0 3e		beq $a28e			beq 	_RGI_Frame
.a250		c9 ce		cmp #$ce			cmp 	#KWD_SOLID
.a252		f0 33		beq $a287			beq 	_RGI_Solid
.a254		c9 ad		cmp #$ad			cmp 	#KWD_BY 					; by offset
.a256		f0 4b		beq $a2a3			beq 	_RGI_By
.a258		c9 b9		cmp #$b9			cmp 	#KWD_FROM 					; from
.a25a		f0 17		beq $a273			beq 	_RGI_Move2
.a25c		c9 b5		cmp #$b5			cmp 	#KWD_DIM 					; dim (set scale)
.a25e		f0 62		beq $a2c2			beq 	_RGI_Dim
.a260		c9 b3		cmp #$b3			cmp 	#KWD_COLOUR 				; colour or Color
.a262		f0 74		beq $a2d8			beq 	_RGI_Colour
.a264		c9 b2		cmp #$b2			cmp 	#KWD_COLOR
.a266		f0 70		beq $a2d8			beq 	_RGI_Colour
.a268		ae 5d 06	ldx $065d			ldx 	gxCommandID
.a26b		e0 52		cpx #$52			cpx 	#GCMD_SpriteMove 			; if not sprite
.a26d		d0 03		bne $a272			bne 	_RGI_Move 					; move
.a26f		4c 00 a3	jmp $a300			jmp		_RGI_SpriteInstructions
.a272						_RGI_Move:
.a272		88		dey				dey 								; unpick get.
.a273						_RGI_Move2:
.a273		20 26 a3	jsr $a326			jsr 	GCGetCoordinatePair 		; move to here
.a276		20 4d a3	jsr $a34d			jsr 	GCCopyPairToStore 			; save
.a279		5a		phy				phy
.a27a		20 43 a3	jsr $a343			jsr 	GCLoadAXY 					; load in
.a27d		09 40		ora #$40			ora 	#GCMD_Move 					; move there
.a27f		20 3f 80	jsr $803f			jsr 	GXGraphicDraw
.a282		7a		ply				ply
.a283		80 b4		bra $a239			bra 	_RGICommandLoop 			; and go round
.a285						_RGI_Exit:
.a285		88		dey				dey 								; unpick : / EOL
.a286		60		rts				rts
.a287						_RGI_Solid:
.a287		a9 02		lda #$02			lda 	#2
.a289		8d 5e 06	sta $065e			sta 	gxFillSolid
.a28c		80 ab		bra $a239			bra 	_RGICommandLoop
.a28e						_RGI_Frame:
.a28e		9c 5e 06	stz $065e			stz 	gxFillSolid
.a291		80 a6		bra $a239			bra 	_RGICommandLoop
.a293						_RGI_To:
.a293		20 26 a3	jsr $a326			jsr 	GCGetCoordinatePair 		; get coordinate pair into slot #1,#2
.a296		20 4d a3	jsr $a34d			jsr 	GCCopyPairToStore
.a299						_RGI_Here:
.a299		5a		phy				phy
.a29a		20 43 a3	jsr $a343			jsr 	GCLoadAXY 					; load it into AXY
.a29d		20 fd a2	jsr $a2fd			jsr 	_RGICallHandler 			; go do whatever it is.
.a2a0		7a		ply				ply
.a2a1		80 96		bra $a239			bra 	_RGICommandLoop 			; and go round
.a2a3						_RGI_By:
.a2a3		20 33 a3	jsr $a333			jsr 	GCSignedCoordinatePair 		; get coordinate pair into slot #1,#2
.a2a6		18		clc				clc
.a2a7		a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.a2a9		6d 5f 06	adc $065f			adc 	gxxPos
.a2ac		8d 5f 06	sta $065f			sta 	gxXPos
.a2af		a5 61		lda $61				lda 	NSMantissa1+1
.a2b1		6d 60 06	adc $0660			adc 	gxxPos+1
.a2b4		8d 60 06	sta $0660			sta 	gxXPos+1
.a2b7		a5 5a		lda $5a				lda 	NSMantissa0+2
.a2b9		18		clc				clc
.a2ba		6d 61 06	adc $0661			adc 	gxYPos
.a2bd		8d 61 06	sta $0661			sta 	gxYPos
.a2c0		80 d7		bra $a299			bra 	_RGI_Here
.a2c2						_RGI_Dim:
.a2c2		a2 01		ldx #$01			ldx	 	#1
.a2c4		20 0b 9e	jsr $9e0b			jsr 	Evaluate8BitInteger
.a2c7		a5 59		lda $59				lda 	NSMantissa0+1
.a2c9		c9 00		cmp #$00			cmp 	#0
.a2cb		f0 2d		beq $a2fa			beq 	_RGIRange
.a2cd		c9 09		cmp #$09			cmp 	#8+1
.a2cf		b0 29		bcs $a2fa			bcs		_RGIRange
.a2d1		3a		dec a				dec 	a
.a2d2		8d 64 06	sta $0664			sta 	gxDrawScale
.a2d5		4c 39 a2	jmp $a239			jmp 	_RGICommandLoop
.a2d8						_RGI_Colour:
.a2d8		a2 01		ldx #$01			ldx 	#1 							; colour
.a2da		20 0b 9e	jsr $9e0b			jsr 	Evaluate8BitInteger
.a2dd		a2 02		ldx #$02			ldx 	#2 							; default zero for 2nd parameter
.a2df		20 70 9e	jsr $9e70			jsr 	NSMSetZero
.a2e2		b1 30		lda ($30),y			lda 	(codePtr),y
.a2e4		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; check , => mode.
.a2e6		d0 04		bne $a2ec			bne 	_RGICDefaultMode
.a2e8		c8		iny				iny
.a2e9		20 0b 9e	jsr $9e0b			jsr 	Evaluate8BitInteger
.a2ec						_RGICDefaultMode:
.a2ec		5a		phy				phy
.a2ed		a9 08		lda #$08			lda 	#GCMD_Colour 				; set colour.
.a2ef		a6 59		ldx $59				ldx 	NSMantissa0+1
.a2f1		a4 5a		ldy $5a				ldy 	NSMantissa0+2
.a2f3		20 3f 80	jsr $803f			jsr 	GXGraphicDraw
.a2f6		7a		ply				ply
.a2f7		4c 39 a2	jmp $a239			jmp 	_RGICommandLoop 			; and go round
.a2fa						_RGIRange:
.a2fa		4c f3 9f	jmp $9ff3			jmp 	RangeError
.a2fd						_RGICallHandler:
.a2fd		6c 62 06	jmp ($0662)			jmp 	(GXHandler)
.a300						_RGI_SpriteInstructions:
.a300		c9 c3		cmp #$c3			cmp 	#KWD_OFF
.a302		f0 07		beq $a30b			beq 	_RGISpriteOff
.a304		c9 be		cmp #$be			cmp 	#KWD_IMAGE
.a306		f0 13		beq $a31b			beq 	_RGISetImage
.a308		4c 72 a2	jmp $a272			jmp 	_RGI_Move
.a30b						_RGISpriteOff:
.a30b		5a		phy				phy
.a30c		a0 01		ldy #$01			ldy 	#1
.a30e		a2 00		ldx #$00			ldx 	#0
.a310						_RGIDoCommandLoop:
.a310		a9 10		lda #$10			lda 	#GCMD_SpriteImage
.a312		20 3f 80	jsr $803f			jsr 	GXGraphicDraw
.a315		7a		ply				ply
.a316		b0 e2		bcs $a2fa			bcs 	_RGIRange
.a318		4c 39 a2	jmp $a239			jmp 	_RGICommandLoop
.a31b						_RGISetImage:
.a31b		a2 01		ldx #$01			ldx 	#1
.a31d		20 0b 9e	jsr $9e0b			jsr 	Evaluate8BitInteger
.a320		5a		phy				phy
.a321		aa		tax				tax
.a322		a0 00		ldy #$00			ldy 	#0
.a324		80 ea		bra $a310			bra 	_RGIDoCommandLoop
.a326						GCGetCoordinatePair:
.a326		a2 01		ldx #$01			ldx 	#1
.a328		20 f0 9d	jsr $9df0			jsr 	Evaluate16BitInteger
.a32b		20 38 8f	jsr $8f38			jsr 	CheckComma
.a32e		e8		inx				inx
.a32f		20 f0 9d	jsr $9df0			jsr 	Evaluate16BitInteger
.a332		60		rts				rts
.a333						GCSignedCoordinatePair:
.a333		a2 01		ldx #$01			ldx 	#1
.a335		20 fa 9d	jsr $9dfa			jsr 	Evaluate16BitIntegerSigned
.a338		20 38 8f	jsr $8f38			jsr 	CheckComma
.a33b		e8		inx				inx
.a33c		20 fa 9d	jsr $9dfa			jsr 	Evaluate16BitIntegerSigned
.a33f		60		rts				rts
.a340						_GCCPRange:
.a340		4c f3 9f	jmp $9ff3			jmp 	RangeError
.a343						GCLoadAXY:
.a343		ad 60 06	lda $0660			lda 	gxXPos+1
.a346		ae 5f 06	ldx $065f			ldx 	gxXPos
.a349		ac 61 06	ldy $0661			ldy 	gxYPos
.a34c		60		rts				rts
.a34d						GCCopyPairToStore:
.a34d		a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.a34f		8d 5f 06	sta $065f			sta 	gxXPos
.a352		a5 61		lda $61				lda 	NSMantissa1+1
.a354		8d 60 06	sta $0660			sta 	gxXPos+1
.a357		a5 5a		lda $5a				lda 	NSMantissa0+2
.a359		8d 61 06	sta $0661			sta 	gxYPos
.a35c		60		rts				rts
.065d						gxCommandID:
>065d								.fill 	1
.065e						gxFillSolid:
>065e								.fill 	1
.065f						gxXPos:
>065f								.fill 	2
.0661						gxYPos:
>0661								.fill 	1
.0662						gxHandler:
>0662								.fill 	2
.0664						gxDrawScale:
>0664								.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcontrol.asm

.a35d						BitmapCtrl:
.a35d		b1 30		lda ($30),y			lda 	(codePtr),y
.a35f		c8		iny				iny
.a360		a2 01		ldx #$01			ldx 	#1
.a362		c9 c4		cmp #$c4			cmp 	#KWD_ON
.a364		f0 11		beq $a377			beq 	BitmapSwitch
.a366		ca		dex				dex
.a367		c9 c3		cmp #$c3			cmp 	#KWD_OFF
.a369		f0 0c		beq $a377			beq 	BitmapSwitch
.a36b		20 0b 9e	jsr $9e0b			jsr 	Evaluate8BitInteger 		; get the colour
.a36e		5a		phy				phy
.a36f		aa		tax				tax
.a370		a9 06		lda #$06			lda 	#GCMD_Clear					; clear to that colour
.a372		20 3f 80	jsr $803f			jsr 	GXGraphicDraw
.a375		7a		ply				ply
.a376		60		rts				rts
.a377						BitmapSwitch:
.a377		5a		phy				phy
.a378		a0 00		ldy #$00			ldy 	#0 							; gfx 1,on/off,0
.a37a		a9 02		lda #$02			lda 	#GCMD_BitmapCtl
.a37c		20 3f 80	jsr $803f			jsr 	GXGraphicDraw
.a37f		a9 08		lda #$08			lda 	#GCMD_Colour				; set colour to $FF
.a381		a0 00		ldy #$00			ldy 	#0
.a383		a2 ff		ldx #$ff			ldx 	#$FF
.a385		20 3f 80	jsr $803f			jsr 	GXGraphicDraw
.a388		9c 5e 06	stz $065e			stz 	gxFillSolid
.a38b		9c 5f 06	stz $065f			stz 	gxXPos
.a38e		9c 60 06	stz $0660			stz 	gxXPos+1
.a391		9c 61 06	stz $0661			stz 	gxYPos
.a394		9c 64 06	stz $0664			stz 	gxDrawScale
.a397		a9 40		lda #$40			lda 	#GCMD_Move 						; home cursor
.a399		a2 00		ldx #$00			ldx 	#0
.a39b		a0 00		ldy #$00			ldy 	#0
.a39d		20 3f 80	jsr $803f			jsr 	GXGraphicDraw
.a3a0		7a		ply				ply
.a3a1		60		rts				rts
.a3a2						SpritesCtrl:
.a3a2		b1 30		lda ($30),y			lda 	(codePtr),y
.a3a4		c8		iny				iny
.a3a5		a2 01		ldx #$01			ldx 	#1
.a3a7		c9 c4		cmp #$c4			cmp 	#KWD_ON
.a3a9		f0 08		beq $a3b3			beq 	SpriteSwitch
.a3ab		ca		dex				dex
.a3ac		c9 c3		cmp #$c3			cmp 	#KWD_OFF
.a3ae		f0 03		beq $a3b3			beq 	SpriteSwitch
.a3b0		4c ee 9f	jmp $9fee			jmp 	SyntaxError
.a3b3						SpriteSwitch:
.a3b3		5a		phy				phy
.a3b4		a0 00		ldy #$00			ldy 	#0 							; gfx 2,on/off,0
.a3b6		a9 04		lda #$04			lda 	#GCMD_SpriteCtl
.a3b8		20 3f 80	jsr $803f			jsr 	GXGraphicDraw
.a3bb		7a		ply				ply
.a3bc		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gfx.asm

.a3bd						GfxCommand:
.a3bd		a2 00		ldx #$00			ldx 	#0
.a3bf		20 0b 9e	jsr $9e0b			jsr 	Evaluate8BitInteger 		; command
.a3c2		20 38 8f	jsr $8f38			jsr 	CheckComma
.a3c5		e8		inx				inx
.a3c6		20 f0 9d	jsr $9df0			jsr 	Evaluate16BitInteger 		; X
.a3c9		20 38 8f	jsr $8f38			jsr 	CheckComma
.a3cc		e8		inx				inx
.a3cd		20 0b 9e	jsr $9e0b			jsr 	Evaluate8BitInteger 		; Y
.a3d0		a5 61		lda $61				lda 	NSMantissa1+1  				; shift bit 0 of X into CS, should now be zero
.a3d2		4a		lsr a				lsr 	a
.a3d3		d0 12		bne $a3e7			bne 	_GfxError
.a3d5		26 58		rol $58				rol 	NSMantissa0 				; rotate into command
.a3d7		b0 0e		bcs $a3e7			bcs 	_GfxError 					; bit 7 should have been zero
.a3d9		5a		phy				phy 								; save pos
.a3da		a5 58		lda $58				lda 	NSMantissa0 				; do the command
.a3dc		a6 59		ldx $59				ldx 	NSMantissa0+1
.a3de		a4 5a		ldy $5a				ldy 	NSMantissa0+2
.a3e0		20 3f 80	jsr $803f			jsr 	GXGraphicDraw
.a3e3		b0 02		bcs $a3e7			bcs 	_GfxError
.a3e5		7a		ply				ply 								; restore pos and exit.
.a3e6		60		rts				rts
.a3e7						_GfxError:
.a3e7		4c f3 9f	jmp $9ff3			jmp 	RangeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/hit.asm

.a3ea						UnaryHit:
.a3ea		fa		plx				plx
.a3eb		a9 36		lda #$36			lda 	#zTemp0
.a3ed		20 0b 9e	jsr $9e0b			jsr 	Evaluate8BitInteger 		; get sprite number 0
.a3f0		20 38 8f	jsr $8f38			jsr 	CheckComma
.a3f3		e8		inx				inx
.a3f4		20 0b 9e	jsr $9e0b			jsr 	Evaluate8BitInteger 		; get sprite number 1
.a3f7		20 30 8f	jsr $8f30			jsr		CheckRightBracket
.a3fa		ca		dex				dex 								; fix back up again.
.a3fb		da		phx				phx 								; save X/Y
.a3fc		5a		phy				phy
.a3fd		b4 59		ldy $59,x			ldy 	NSMantissa0+1,x 			; get the sprite numbers into X/Y
.a3ff		b5 58		lda $58,x			lda 	NSMantissa0,x
.a401		aa		tax				tax
.a402		a9 12		lda #$12			lda 	#GCMD_SpriteCollide 		; command check collision.
.a404		20 3f 80	jsr $803f			jsr 	GXGraphicDraw 				; calculate result
.a407		1a		inc a				inc 	a 							; so 255 (fail) -> 0, otherwise 1,2,3,4 pixels etc.
.a408		7a		ply				ply 								; restore XY
.a409		fa		plx				plx
.a40a		20 72 9e	jsr $9e72			jsr 	NSMSetByte 					; return the hit result
.a40d		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/palette.asm

.a40e						PaletteCommand:
.a40e		a2 00		ldx #$00			ldx 	#0
.a410		20 0b 9e	jsr $9e0b			jsr 	Evaluate8BitInteger 		; colour
.a413		20 38 8f	jsr $8f38			jsr 	CheckComma
.a416		e8		inx				inx
.a417		20 f0 9d	jsr $9df0			jsr 	Evaluate16BitInteger 		; r
.a41a		20 38 8f	jsr $8f38			jsr 	CheckComma
.a41d		e8		inx				inx
.a41e		20 0b 9e	jsr $9e0b			jsr 	Evaluate8BitInteger 		; g
.a421		20 38 8f	jsr $8f38			jsr 	CheckComma
.a424		e8		inx				inx
.a425		20 0b 9e	jsr $9e0b			jsr 	Evaluate8BitInteger 		; b
.a428		a5 58		lda $58				lda 	NSMantissa0 				; get colour #
.a42a		85 36		sta $36				sta 	zTemp0
.a42c		a9 34		lda #$34			lda 	#$D0 >> 2 					; MSB = D0/4
.a42e		85 37		sta $37				sta 	zTemp0+1
.a430		06 36		asl $36				asl 	zTemp0 						; zTemp = $D000+Colour x 4
.a432		26 37		rol $37				rol	 	zTemp0+1
.a434		06 36		asl $36				asl 	zTemp0
.a436		26 37		rol $37				rol	 	zTemp0+1
.a438		a9 01		lda #$01			lda 	#1 							; I/O Page 2
.a43a		85 01		sta $01				sta 	1
.a43c		5a		phy				phy
.a43d		a5 5b		lda $5b				lda 	NSMantissa0+3 				; fix to r,g,b
.a43f		92 36		sta ($36)			sta 	(zTemp0)
.a441		a0 01		ldy #$01			ldy 	#1
.a443		a5 5a		lda $5a				lda 	NSMantissa0+2
.a445		91 36		sta ($36),y			sta 	(zTemp0),y
.a447		a5 59		lda $59				lda 	NSMantissa0+1
.a449		c8		iny				iny
.a44a		91 36		sta ($36),y			sta 	(zTemp0),y
.a44c		7a		ply				ply
.a44d		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/event.asm

.a44e						UnaryEvent:
.a44e		fa		plx				plx
.a44f		20 fc a4	jsr $a4fc			jsr 	TimerToStackX 				; timer in +0
.a452		e8		inx				inx  								; put reference into +1
.a453		20 97 98	jsr $9897			jsr 	EvaluateTerm
.a456		b5 50		lda $50,x			lda 	NSStatus,x 					; check if is integer reference
.a458		c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.a45a		d0 4c		bne $a4a8			bne 	_UEType
.a45c		e8		inx				inx 								; put the step in +2
.a45d		20 38 8f	jsr $8f38			jsr 	CheckComma
.a460		20 f0 9d	jsr $9df0			jsr 	Evaluate16BitInteger
.a463		20 30 8f	jsr $8f30			jsr 	CheckRightBracket
.a466		ca		dex				dex
.a467		ca		dex				dex
.a468		b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy reference to zTemp0
.a46a		85 36		sta $36				sta 	zTemp0
.a46c		b5 61		lda $61,x			lda 	NSMantissa1+1,x
.a46e		85 37		sta $37				sta 	zTemp0+1
.a470		5a		phy				phy
.a471		a0 03		ldy #$03			ldy 	#3 							; check bit 7 of last bit, the packed sign bit
.a473		b1 36		lda ($36),y			lda 	(zTemp0),y
.a475		30 2d		bmi $a4a4			bmi 	_UEFalse 					; exit if signed.
.a477		a0 00		ldy #$00			ldy 	#0 							; has it timed out (24 bit)
.a479		b5 58		lda $58,x			lda 	NSMantissa0,x
.a47b		d1 36		cmp ($36),y			cmp 	(zTemp0),y
.a47d		c8		iny				iny
.a47e		b5 60		lda $60,x			lda 	NSMantissa1,x
.a480		f1 36		sbc ($36),y			sbc		(zTemp0),y
.a482		c8		iny				iny
.a483		b5 68		lda $68,x			lda 	NSMantissa2,x
.a485		f1 36		sbc ($36),y			sbc		(zTemp0),y
.a487		90 1b		bcc $a4a4			bcc 	_UEFalse 					; no, return FALSE.
.a489		18		clc				clc
.a48a		a0 00		ldy #$00			ldy 	#0 							; work out new value as timer() + step
.a48c		b5 58		lda $58,x			lda 	NSMantissa0,x
.a48e		75 5a		adc $5a,x			adc 	NSMantissa0+2,x
.a490		91 36		sta ($36),y			sta 	(zTemp0),y
.a492		c8		iny				iny
.a493		b5 60		lda $60,x			lda 	NSMantissa1,x
.a495		75 62		adc $62,x			adc 	NSMantissa1+2,x
.a497		91 36		sta ($36),y			sta 	(zTemp0),y
.a499		c8		iny				iny
.a49a		b5 68		lda $68,x			lda 	NSMantissa2,x
.a49c		75 6a		adc $6a,x			adc 	NSMantissa2+2,x
.a49e		91 36		sta ($36),y			sta 	(zTemp0),y
.a4a0		7a		ply				ply
.a4a1		4c b6 8f	jmp $8fb6			jmp 	ReturnTrue
.a4a4						_UEFalse:
.a4a4		7a		ply				ply 								; restore Y
.a4a5		4c c1 8f	jmp $8fc1			jmp 	ReturnFalse 				; and return False
.a4a8						_UEType:
.a4a8		4c f8 9f	jmp $9ff8			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/joy.asm

.a4ab						UnaryJoyX:
.a4ab		18		clc				clc
.a4ac		80 01		bra $a4af			bra 	JoyMain
.a4ae						UnaryJoyY:
.a4ae		38		sec				sec
.a4af						JoyMain:
.a4af		fa		plx				plx 								; get pos
.a4b0		08		php				php 								; save carry (set for Y)
.a4b1		20 0b 9e	jsr $9e0b			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a4b4		20 30 8f	jsr $8f30			jsr 	CheckRightBracket
.a4b7		20 2b 80	jsr $802b			jsr 	EXTReadController 			; read the controller.
.a4ba		28		plp				plp
.a4bb		90 02		bcc $a4bf			bcc 	_JMNoShift 					; if Y then shift bits 3,2 -> 1,0
.a4bd		4a		lsr a				lsr 	a
.a4be		4a		lsr a				lsr 	a
.a4bf						_JMNoShift:
.a4bf		4a		lsr a				lsr 	a 							; if bit 0 set then right/down e.g. +1
.a4c0		b0 0a		bcs $a4cc			bcs 	_JMIsRight
.a4c2		4a		lsr a				lsr 	a 							; if bit 1 set then left/up e.g. -1
.a4c3		b0 04		bcs $a4c9			bcs 	_JMIsLeft
.a4c5		20 70 9e	jsr $9e70			jsr 	NSMSetZero 					; zero result
.a4c8		60		rts				rts
.a4c9						_JMIsLeft:
.a4c9		4c b6 8f	jmp $8fb6			jmp 	ReturnTrue
.a4cc						_JMIsRight:
.a4cc		a9 01		lda #$01			lda 	#1
.a4ce		20 72 9e	jsr $9e72			jsr 	NSMSetByte
.a4d1		60		rts				rts
.a4d2						UnaryJoyB:
.a4d2		fa		plx				plx 								; get pos
.a4d3		20 0b 9e	jsr $9e0b			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a4d6		20 30 8f	jsr $8f30			jsr 	CheckRightBracket
.a4d9		20 2b 80	jsr $802b			jsr 	EXTReadController 			; read the controller.
.a4dc		4a		lsr a				lsr 	a
.a4dd		4a		lsr a				lsr 	a
.a4de		4a		lsr a				lsr 	a
.a4df		4a		lsr a				lsr 	a
.a4e0		29 01		and #$01			and 	#1
.a4e2		20 72 9e	jsr $9e72			jsr 	NSMSetByte
.a4e5		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/load.asm

.a4e6						LoadCommand:
.a4e6		20 7e 8a	jsr $8a7e			jsr 	NewProgram
.a4e9		20 70 83	jsr $8370			jsr 	BackLoadProgram
.a4ec		4c 27 84	jmp $8427			jmp 	WarmStart
.a4ef						GoCommand:
.a4ef		20 7e 8a	jsr $8a7e			jsr 	NewProgram
.a4f2		20 70 83	jsr $8370			jsr 	BackLoadProgram
.a4f5		4c bf 8b	jmp $8bbf			jmp 	CommandRun

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/timer.asm

.a4f8						UnaryTimer:
.a4f8		fa		plx				plx
.a4f9		20 30 8f	jsr $8f30			jsr 	CheckRightBracket
.a4fc						TimerToStackX:
.a4fc		20 70 9e	jsr $9e70			jsr 	NSMSetZero 					; zero result
.a4ff		64 01		stz $01				stz 	1 							; access I/O
.a501		ad 59 d6	lda $d659			lda 	$D659 						; copy timer in
.a504		95 58		sta $58,x			sta 	NSMantissa0,x
.a506		ad 5a d6	lda $d65a			lda 	$D65A
.a509		95 60		sta $60,x			sta 	NSMantissa1,x
.a50b		ad 5b d6	lda $d65b			lda 	$D65B
.a50e		95 68		sta $68,x			sta 	NSMantissa2,x
.a510		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/delete.asm

.a511						MemoryDeleteLine:
.a511		20 30 a5	jsr $a530			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a514		b2 30		lda ($30)			lda 	(codePtr) 					; size to delete => y
.a516		a8		tay				tay
.a517						_MDDLLoop:
.a517		b1 30		lda ($30),y			lda 	(codePtr),y 				; copy down
.a519		92 30		sta ($30)			sta 	(codePtr)
.a51b		a5 30		lda $30				lda 	codePtr 					; check done the lot.
.a51d		c5 3a		cmp $3a				cmp 	zTemp2
.a51f		d0 07		bne $a528			bne 	_MDLDLNext
.a521		a5 31		lda $31				lda 	codePtr+1
.a523		c5 3b		cmp $3b				cmp 	zTemp2+1
.a525		d0 01		bne $a528			bne 	_MDLDLNext
.a527						_MDDLExit:
.a527		60		rts				rts
.a528						_MDLDLNext:
.a528		e6 30		inc $30				inc 	codePtr						; next byte
.a52a		d0 eb		bne $a517			bne 	_MDDLLoop
.a52c		e6 31		inc $31				inc 	codePtr+1
.a52e		80 e7		bra $a517			bra 	_MDDLLoop
.a530						IMemoryFindEnd:
.a530		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a532		85 3a		sta $3a				sta 	0+zTemp2
.a534		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a536		85 3b		sta $3b				sta 	1+zTemp2
.a538						_MDLFELoop:
.a538		b2 3a		lda ($3a)			lda 	(zTemp2)
.a53a		f0 0b		beq $a547			beq 	_MDLFEExit
.a53c		18		clc				clc
.a53d		65 3a		adc $3a				adc 	zTemp2
.a53f		85 3a		sta $3a				sta 	zTemp2
.a541		90 f5		bcc $a538			bcc 	_MDLFELoop
.a543		e6 3b		inc $3b				inc 	zTemp2+1
.a545		80 f1		bra $a538			bra 	_MDLFELoop
.a547						_MDLFEExit:
.a547		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/insert.asm

.a548						MemoryInsertLine:
.a548		08		php				php
.a549		20 30 a5	jsr $a530			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a54c		a5 3b		lda $3b				lda 	zTemp2+1 					; space ?
.a54e		1a		inc a				inc 	a
.a54f		c9 7f		cmp #$7f			cmp 	#(BasicEnd >> 8)-1
.a551		b0 36		bcs $a589			bcs 	_MDLIError
.a553		28		plp				plp
.a554		90 08		bcc $a55e			bcc 	_MDLIFound
.a556		a5 3a		lda $3a				lda 	zTemp2 						; if CS on entry append.
.a558		85 30		sta $30				sta 	codePtr
.a55a		a5 3b		lda $3b				lda 	zTemp2+1
.a55c		85 31		sta $31				sta 	codePtr+1
.a55e						_MDLIFound:
.a55e		ad 2a 04	lda $042a			lda 	tokenOffset 				; insert gap in Y, the offset, e.g. length of the new line
.a561		a8		tay				tay
.a562						_MDLIInsert:
.a562		b2 3a		lda ($3a)			lda 	(zTemp2) 					; shift one byte up , at least one covers end case.
.a564		91 3a		sta ($3a),y			sta 	(zTemp2),y 					; work from top down.
.a566		a5 30		lda $30				lda 	codePtr 					; done insert point ?
.a568		c5 3a		cmp $3a				cmp 	zTemp2
.a56a		d0 06		bne $a572			bne 	_MDLINext
.a56c		a5 31		lda $31				lda 	codePtr+1
.a56e		c5 3b		cmp $3b				cmp 	zTemp2+1
.a570		f0 0a		beq $a57c			beq 	_MDLIHaveSpace
.a572						_MDLINext:
.a572		a5 3a		lda $3a				lda 	zTemp2 						; if no, keep zTemp2 going backwards
.a574		d0 02		bne $a578			bne 	_MDLINoBorrow
.a576		c6 3b		dec $3b				dec 	zTemp2+1
.a578						_MDLINoBorrow:
.a578		c6 3a		dec $3a				dec 	zTemp2
.a57a		80 e6		bra $a562			bra 	_MDLIInsert
.a57c						_MDLIHaveSpace:
.a57c		ac 2a 04	ldy $042a			ldy 	tokenOffset 				; bytes to copy
.a57f		88		dey				dey 								; from offset-1 to 0
.a580						_MDLICopy:
.a580		b9 2a 04	lda $042a,y			lda 	tokenOffset,y
.a583		91 30		sta ($30),y			sta 	(codePtr),y
.a585		88		dey				dey
.a586		10 f8		bpl $a580			bpl 	_MDLICopy
.a588		60		rts				rts
.a589						_MDLIError:
.a589		a9 06		lda #$06		lda	#6
.a58b		4c 49 8f	jmp $8f49		jmp	ErrorHandler
.a58e						MDLAppendLine:
.a58e		86 37		stx $37				stx 	zTemp0+1 					; save new line at zTemp0
.a590		85 36		sta $36				sta 	zTemp0
.a592		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a594		85 38		sta $38				sta 	0+zTemp1
.a596		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a598		85 39		sta $39				sta 	1+zTemp1
.a59a		b2 38		lda ($38)			lda 	(zTemp1)
.a59c		d0 0a		bne $a5a8			bne 	_MDLANoInitialise
.a59e		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a5a0		8d 65 06	sta $0665			sta 	0+AppendPointer
.a5a3		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a5a5		8d 66 06	sta $0666			sta 	1+AppendPointer
.a5a8						_MDLANoInitialise:
.a5a8		18		clc				clc
.a5a9		ad 65 06	lda $0665			lda 	AppendPointer 				; copy append pointer to zTemp1 adding the offset as you go
.a5ac		85 38		sta $38				sta 	zTemp1
.a5ae		72 36		adc ($36)			adc 	(zTemp0)
.a5b0		8d 65 06	sta $0665			sta 	AppendPointer
.a5b3		ad 66 06	lda $0666			lda 	AppendPointer+1
.a5b6		85 39		sta $39				sta 	zTemp1+1
.a5b8		69 00		adc #$00			adc 	#0
.a5ba		8d 66 06	sta $0666			sta 	AppendPointer+1
.a5bd		a0 00		ldy #$00			ldy 	#0
.a5bf						_MDLACopy:
.a5bf		b1 36		lda ($36),y			lda 	(zTemp0),y 					; copy new line in
.a5c1		91 38		sta ($38),y			sta 	(zTemp1),y
.a5c3		c8		iny				iny
.a5c4		98		tya				tya
.a5c5		d2 36		cmp ($36)			cmp 	(zTemp0) 					; done whole line
.a5c7		d0 f6		bne $a5bf			bne 	_MDLACopy
.a5c9		a9 00		lda #$00			lda 	#0 							; end of program.
.a5cb		91 38		sta ($38),y			sta 	(zTemp1),y
.a5cd		60		rts				rts
.0665						AppendPointer:
>0665								.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/memory.asm

.a5ce						MemoryNew:
.a5ce		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a5d0		85 30		sta $30				sta 	codePtr
.a5d2		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a5d4		85 31		sta $31				sta 	codePtr+1
.a5d6		a9 00		lda #$00			lda 	#0 							; write zero there erasing the program.
.a5d8		92 30		sta ($30)			sta 	(codePtr)
.a5da		60		rts				rts
.a5db						MemoryInline:
.a5db		98		tya				tya 								; put address into stack,x
.a5dc		18		clc				clc  								; get the offset, add codePtr
.a5dd		65 30		adc $30				adc 	codePtr
.a5df		95 58		sta $58,x			sta 	NSMantissa0,x 				; store the result in the mantissa.
.a5e1		a5 31		lda $31				lda 	codePtr+1
.a5e3		69 00		adc #$00			adc 	#0
.a5e5		95 60		sta $60,x			sta 	NSMantissa1,x
.a5e7		74 68		stz $68,x			stz 	NSMantissa2,x
.a5e9		74 70		stz $70,x			stz 	NSMantissa3,x
.a5eb		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/search.asm

.a5ec						MemorySearch:
.a5ec		85 36		sta $36				sta 	zTemp0 						; save line number in zTemp0
.a5ee		86 37		stx $37				stx 	zTemp0+1
.a5f0		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a5f2		85 30		sta $30				sta 	codePtr
.a5f4		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a5f6		85 31		sta $31				sta 	codePtr+1
.a5f8						_MTAXLoop:
.a5f8		b2 30		lda ($30)			lda 	(codePtr)
.a5fa		18		clc				clc
.a5fb		f0 21		beq $a61e			beq 	_MTAXExit 					; reached end, exit with CC.
.a5fd		a0 01		ldy #$01			ldy 	#1 							; calculate current line# - requested line#
.a5ff		b1 30		lda ($30),y			lda 	(codePtr),y
.a601		38		sec				sec
.a602		e5 36		sbc $36				sbc 	zTemp0
.a604		85 38		sta $38				sta 	zTemp1 						; save interim to set Z
.a606		c8		iny				iny 								; do the MSB
.a607		b1 30		lda ($30),y			lda 	(codePtr),y
.a609		e5 37		sbc $37				sbc 	zTemp0+1
.a60b		05 38		ora $38				ora 	zTemp1 						; will set Z if result is zero, doesn't affect carry flag
.a60d		f0 0f		beq $a61e			beq 	_MTAXExit	 				; found so exit (CS will be set)
.a60f		b0 0d		bcs $a61e			bcs 	_MTAXExit 					; current < required exit
.a611		18		clc				clc
.a612		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.a614		65 30		adc $30				adc 	codePtr
.a616		85 30		sta $30				sta 	codePtr
.a618		90 02		bcc $a61c			bcc 	_CREExit
.a61a		e6 31		inc $31				inc 	codePtr+1 					; carry
.a61c						_CREExit:
.a61c		80 da		bra $a5f8			bra 	_MTAXLoop
.a61e						_MTAXExit:
.a61e		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/effects.asm

.a61f						PingCommand:
.a61f		5a		phy				phy 								; save pos
.a620		a9 01		lda #$01			lda 	#1 						; push channel.
.a622		48		pha				pha
.a623		a9 c8		lda #$c8			lda 	#200 						; pitch LSB
.a625		a2 03		ldx #$03			ldx 	#3 						; length
.a627		a0 00		ldy #$00			ldy 	#0 						; slide LSB
.a629		80 24		bra $a64f			bra 	SoundEffectCommand
.a62b						ZapCommand:
.a62b		5a		phy				phy 								; save pos
.a62c		a9 01		lda #$01			lda 	#1 						; push channel.
.a62e		48		pha				pha
.a62f		a9 ff		lda #$ff			lda 	#255 						; pitch LSB
.a631		a2 05		ldx #$05			ldx 	#5 						; length
.a633		a0 14		ldy #$14			ldy 	#20 						; slide LSB
.a635		80 18		bra $a64f			bra 	SoundEffectCommand
.a637						ShootCommand:
.a637		5a		phy				phy 								; save pos
.a638		a9 03		lda #$03			lda 	#3 						; push channel.
.a63a		48		pha				pha
.a63b		a9 20		lda #$20			lda 	#32 						; pitch LSB
.a63d		a2 02		ldx #$02			ldx 	#2 						; length
.a63f		a0 00		ldy #$00			ldy 	#0 						; slide LSB
.a641		80 0c		bra $a64f			bra 	SoundEffectCommand
.a643						Explode:
.a643		5a		phy				phy 								; save pos
.a644		a9 03		lda #$03			lda 	#3 						; push channel.
.a646		48		pha				pha
.a647		a9 50		lda #$50			lda 	#80 						; pitch LSB
.a649		a2 05		ldx #$05			ldx 	#5 						; length
.a64b		a0 00		ldy #$00			ldy 	#0 						; slide LSB
.a64d		80 00		bra $a64f			bra 	SoundEffectCommand
.a64f						SoundEffectCommand:
.a64f		8d 67 06	sta $0667			sta 	SoundCommandBlock 			; set up the command block in sound.asm
.a652		9c 68 06	stz $0668			stz 	SoundCommandBlock+1
.a655		a9 0f		lda #$0f			lda 	#15
.a657		8d 69 06	sta $0669			sta 	SoundCommandBlock+2
.a65a		8e 6a 06	stx $066a			stx 	SoundCommandBlock+3
.a65d		8c 6b 06	sty $066b			sty 	SoundCommandBlock+4
.a660		9c 6c 06	stz $066c			stz 	SoundCommandBlock+5
.a663		68		pla				pla
.a664		09 10		ora #$10			ora 	#$10  						; execute command $11
.a666		a2 67		ldx #$67			ldx 	#(SoundCommandBlock & $FF)
.a668		a0 06		ldy #$06			ldy 	#(SoundCommandBlock >> 8)
.a66a		20 49 80	jsr $8049			jsr 	SNDCommand
.a66d		7a		ply				ply
.a66e		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/playing.asm

.a66f						UnaryPlaying:
.a66f		fa		plx				plx
.a670		20 0b 9e	jsr $9e0b			jsr 	Evaluate8BitInteger 		; get channel #
.a673		48		pha				pha
.a674		20 30 8f	jsr $8f30			jsr		CheckRightBracket
.a677		68		pla				pla
.a678		c9 04		cmp #$04			cmp 	#4
.a67a		b0 0c		bcs $a688			bcs 	_UPNotPlaying
.a67c		09 20		ora #$20			ora 	#$20 						; query playing ?
.a67e		20 49 80	jsr $8049			jsr 	SNDCommand
.a681		c9 00		cmp #$00			cmp 	#0
.a683		f0 03		beq $a688			beq 	_UPNotPlaying
.a685		4c b6 8f	jmp $8fb6			jmp 	ReturnTrue
.a688						_UPNotPlaying:
.a688		4c c1 8f	jmp $8fc1			jmp 	ReturnFalse

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/sound.asm

.a68b						SoundCommand:
.a68b		b1 30		lda ($30),y			lda 	(codePtr),y
.a68d		c9 c3		cmp #$c3			cmp 	#KWD_OFF 					; SOUND OFF ?
.a68f		d0 09		bne $a69a			bne 	_SNDMain
.a691		c8		iny				iny 								; skip OFF
.a692		a9 3f		lda #$3f			lda 	#$3F 						; call command $3F (silence)
.a694		5a		phy				phy
.a695		20 49 80	jsr $8049			jsr 	SNDCommand
.a698		7a		ply				ply
.a699		60		rts				rts
.a69a						_SNDMain:
.a69a		a2 00		ldx #$00			ldx 	#0
.a69c		20 0b 9e	jsr $9e0b			jsr 	Evaluate8BitInteger 		; channel
.a69f		c9 04		cmp #$04			cmp 	#4 							; must be 0-3
.a6a1		b0 4b		bcs $a6ee			bcs 	_SndError
.a6a3		e8		inx				inx 								; do the rest in slot 1.
.a6a4		20 38 8f	jsr $8f38			jsr 	CheckComma
.a6a7		20 f0 9d	jsr $9df0			jsr 	Evaluate16BitInteger 		; Pitch
.a6aa		b5 60		lda $60,x			lda 	NSMantissa1,x 				; must be 10 bit
.a6ac		c9 10		cmp #$10			cmp 	#16
.a6ae		b0 3e		bcs $a6ee			bcs 	_SndError
.a6b0		8d 68 06	sta $0668			sta 	SoundCommandBlock+1 		; Pitch (2 bytes + 0)
.a6b3		b5 58		lda $58,x			lda 	NSMantissa0,x
.a6b5		8d 67 06	sta $0667			sta 	SoundCommandBlock
.a6b8		20 38 8f	jsr $8f38			jsr 	CheckComma
.a6bb		20 0b 9e	jsr $9e0b			jsr 	Evaluate8BitInteger 		; Length (1 byte + 3)
.a6be		8d 6a 06	sta $066a			sta 	SoundCommandBlock+3
.a6c1		a9 0f		lda #$0f			lda 	#15
.a6c3		8d 69 06	sta $0669			sta 	SoundCommandBlock+2 		; Volume (1 byte + 2)
.a6c6		9c 6b 06	stz $066b			stz 	SoundCommandBlock+4 		; default slide (2 bytes +4)
.a6c9		9c 6c 06	stz $066c			stz 	SoundCommandBlock+5
.a6cc		b1 30		lda ($30),y			lda 	(codePtr),y
.a6ce		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.a6d0		d0 0e		bne $a6e0			bne 	_SNDPlay
.a6d2		c8		iny				iny
.a6d3		20 fa 9d	jsr $9dfa			jsr 	Evaluate16BitIntegerSigned 	; Slide
.a6d6		b5 58		lda $58,x			lda 	NSMantissa0,x 				; Slide (2 bytes + 4)
.a6d8		8d 6b 06	sta $066b			sta 	SoundCommandBlock+4
.a6db		b5 60		lda $60,x			lda 	NSMantissa1,x
.a6dd		8d 6c 06	sta $066c			sta 	SoundCommandBlock+5
.a6e0						_SNDPlay:
.a6e0		5a		phy				phy
.a6e1		a5 58		lda $58				lda 	NSMantissa0 				; channel.
.a6e3		09 10		ora #$10			ora 	#$10 						; 1x = Queue sound
.a6e5		a2 67		ldx #$67			ldx 	#(SoundCommandBlock & $FF)
.a6e7		a0 06		ldy #$06			ldy 	#(SoundCommandBlock >> 8)
.a6e9		20 49 80	jsr $8049			jsr 	SNDCommand
.a6ec		7a		ply				ply
.a6ed		60		rts				rts
.a6ee						_SndError:
.a6ee		4c f3 9f	jmp $9ff3			jmp 	RangeError
.0667						SoundCommandBlock:
>0667								.fill 	6

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/bytes.asm

.a6f1						StackPushByte:
.a6f1		48		pha				pha 								; save byte on stack
.a6f2		a5 34		lda $34				lda 	BasicStack 					; decrement basic stack pointer
.a6f4		d0 08		bne $a6fe			bne 	_SPBNoBorrow
.a6f6		c6 35		dec $35				dec 	BasicStack+1 				; borrow
.a6f8		a5 35		lda $35				lda 	BasicStack+1 				; check range.
.a6fa		c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a6fc		90 06		bcc $a704			bcc 	_SPBMemory
.a6fe						_SPBNoBorrow:
.a6fe		c6 34		dec $34				dec 	BasicStack
.a700		68		pla				pla 								; get back and write
.a701		92 34		sta ($34)			sta 	(BasicStack)
.a703		60		rts				rts
.a704						_SPBMemory:
.a704		a9 12		lda #$12		lda	#18
.a706		4c 49 8f	jmp $8f49		jmp	ErrorHandler
.a709						StackPopByte:
.a709		b2 34		lda ($34)			lda 	(BasicStack) 				; bump the stack pointer.
.a70b		e6 34		inc $34				inc 	BasicStack
.a70d		d0 02		bne $a711			bne 	_SPBNoCarry
.a70f		e6 35		inc $35				inc 	BasicStack+1
.a711						_SPBNoCarry:
.a711		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/frames.asm

.a712						StackOpen:
.a712		48		pha				pha 								; save frame byte
.a713		29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.a715		0a		asl a				asl 	a 							; claim twice this for storage
.a716		49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.a718		38		sec				sec 								; so basically subtracting from
.a719		65 34		adc $34				adc 	basicStack 	 				; basicStack
.a71b		85 34		sta $34				sta 	basicStack
.a71d		b0 09		bcs $a728			bcs 	_SONoBorrow
>a71f		db						.byte 	$DB 						; causes a break in the emulator
.a720		c6 35		dec $35				dec 	basicStack+1
.a722		a5 35		lda $35				lda 	basicStack+1 				; have we reached stack overflow
.a724		c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a726		90 04		bcc $a72c			bcc 	_SOMemory
.a728						_SONoBorrow:
.a728		68		pla				pla 								; get marker back and write at TOS
.a729		92 34		sta ($34)			sta 	(basicStack)
.a72b		60		rts				rts
.a72c						_SOMemory:
.a72c		a9 12		lda #$12		lda	#18
.a72e		4c 49 8f	jmp $8f49		jmp	ErrorHandler
.a731						StackClose:
.a731		b2 34		lda ($34)			lda 	(basicStack) 				; get TOS marker
.a733		29 0f		and #$0f			and 	#$0F 						; bytes to add back
.a735		0a		asl a				asl 	a 							; claim twice this.
.a736		65 34		adc $34				adc 	basicStack 					; add to the stack pointer.
.a738		85 34		sta $34				sta 	basicStack
.a73a		90 02		bcc $a73e			bcc 	_SCExit
.a73c		e6 35		inc $35				inc 	basicStack+1
.a73e						_SCExit:
.a73e		60		rts				rts
.a73f						StackCheckFrame:
.a73f		48		pha				pha
.a740						_StackRemoveLocals:
.a740		b2 34		lda ($34)			lda 	(basicStack) 				; check for local, keep popping them
.a742		c9 03		cmp #$03			cmp 	#STK_LOCALS+1 				; is the frame a local ? S or N are 1/0
.a744		b0 05		bcs $a74b			bcs 	_SCNoLocal
.a746		20 2d 8a	jsr $8a2d			jsr 	LocalPopValue 				; restore the local value
.a749		80 f5		bra $a740			bra 	_StackRemoveLocals 			; gr round again
.a74b						_SCNoLocal:
.a74b		68		pla				pla 								; get the frame check.
.a74c		52 34		eor ($34)			eor 	(basicStack) 				; xor with toS marker
.a74e		29 f0		and #$f0			and 	#$F0 						; check type bits
.a750		d0 01		bne $a753			bne 	_SCFError 					; different, we have structures mixed up
.a752		60		rts				rts
.a753						_SCFError:
.a753		8a		txa				txa 								; report error X
.a754		4c 49 8f	jmp $8f49			jmp 	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/location.asm

.a757						STKSaveCodePosition:
.a757		5a		phy				phy
.a758		98		tya				tya 								; save Y
.a759		a0 05		ldy #$05			ldy 	#5
.a75b		91 34		sta ($34),y			sta 	(basicStack),y
.a75d		88		dey				dey 								; save Code Pointer
.a75e						_STKSaveLoop:
.a75e		b9 2f 00	lda $002f,y			lda 	safePtr-1,y 				; allows us to access the pointer w/out issues.
.a761		91 34		sta ($34),y			sta 	(basicStack),y
.a763		88		dey				dey
.a764		d0 f8		bne $a75e			bne 	_STKSaveLoop
.a766		7a		ply				ply
.a767		60		rts				rts
.a768						STKLoadCodePosition:
.a768		a0 01		ldy #$01			ldy 	#1 							; load code pointer back
.a76a						_STKLoadLoop:
.a76a		b1 34		lda ($34),y			lda 	(basicStack),y
.a76c		99 2f 00	sta $002f,y			sta 	safePtr-1,y
.a76f		c8		iny				iny
.a770		c0 05		cpy #$05			cpy 	#5
.a772		d0 f6		bne $a76a			bne 	_STKLoadLoop
.a774		b1 34		lda ($34),y			lda 	(basicStack),y 				; get Y offset
.a776		a8		tay				tay
.a777		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/setup.asm

.a778						StackReset:
.a778		a9 ff		lda #$ff			lda 	#((BasicStackBase+BasicStackSize-1) & $FF)
.a77a		85 34		sta $34				sta 	0+basicStack
.a77c		a9 0f		lda #$0f			lda 	#((BasicStackBase+BasicStackSize-1) >> 8)
.a77e		85 35		sta $35				sta 	1+basicStack
.a780		a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.a782		92 34		sta ($34)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.a784		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/concrete.asm

.a785						StringConcrete:
.a785		5a		phy				phy 								; save position on stack
.a786		20 83 9a	jsr $9a83			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a789		b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy target string to zTemp1
.a78b		85 38		sta $38				sta 	zTemp1
.a78d		b5 60		lda $60,x			lda 	NSMantissa1,x
.a78f		85 39		sta $39				sta 	zTemp1+1
.a791		a0 ff		ldy #$ff			ldy 	#$FF	 					; calculate string length
.a793						_SALength:
.a793		c8		iny				iny
.a794		b1 38		lda ($38),y			lda 	(zTemp1),y
.a796		d0 fb		bne $a793			bne 	_SALength
.a798		c0 fd		cpy #$fd			cpy 	#253 						; string too long - cannot concrete.
.a79a		b0 3d		bcs $a7d9			bcs 	_SALengthError
.a79c		98		tya				tya 				 				; length of the new string
.a79d		18		clc				clc
.a79e		69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.a7a0		90 02		bcc $a7a4			bcc 	_SAHaveLength
.a7a2		a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.a7a4						_SAHaveLength:
.a7a4		48		pha				pha 								; save length.
.a7a5		38		sec				sec
.a7a6		49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.a7a8		6d 0e 04	adc $040e			adc 	StringMemory
.a7ab		8d 0e 04	sta $040e			sta 	StringMemory
.a7ae		85 3a		sta $3a				sta 	zTemp2 						; update storage address
.a7b0		95 58		sta $58,x			sta 	NSMantissa0,x 				; update mantissa address
.a7b2		a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.a7b4		6d 0f 04	adc $040f			adc 	StringMemory+1
.a7b7		8d 0f 04	sta $040f			sta 	StringMemory+1
.a7ba		85 3b		sta $3b				sta 	zTemp2+1
.a7bc		95 60		sta $60,x			sta 	NSMantissa1,x
.a7be		68		pla				pla 								; save length-3 (chars allowed) in first byte
.a7bf		38		sec				sec
.a7c0		e9 03		sbc #$03			sbc 	#3
.a7c2		92 3a		sta ($3a)			sta 	(zTemp2)
.a7c4		a9 00		lda #$00			lda 	#0 							; clear the status byte.
.a7c6		a0 01		ldy #$01			ldy 	#1
.a7c8		91 3a		sta ($3a),y			sta 	(zTemp2),y
.a7ca						_SACopyNewString:
.a7ca		a0 00		ldy #$00			ldy 	#0
.a7cc						_SACopyNSLoop:
.a7cc		b1 38		lda ($38),y			lda 	(zTemp1),y 					; get character
.a7ce		c8		iny				iny 								; write two on in string storage
.a7cf		c8		iny				iny
.a7d0		91 3a		sta ($3a),y			sta 	(zTemp2),y
.a7d2		88		dey				dey 								; this makes it one one.
.a7d3		c9 00		cmp #$00			cmp 	#0 							; until EOS copied
.a7d5		d0 f5		bne $a7cc			bne 	_SACopyNSLoop
.a7d7		7a		ply				ply
.a7d8		60		rts				rts
.a7d9						_SALengthError:
.a7d9		a9 09		lda #$09		lda	#9
.a7db		4c 49 8f	jmp $8f49		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/stringalloc.asm

.a7de						StringSystemInitialise:
.a7de		a9 ff		lda #$ff			lda 	#((EndVariableSpace-1) & $FF)
.a7e0		8d 0e 04	sta $040e			sta 	0+StringMemory
.a7e3		a9 1f		lda #$1f			lda 	#((EndVariableSpace-1) >> 8)
.a7e5		8d 0f 04	sta $040f			sta 	1+StringMemory
.a7e8		9c ff 1f	stz $1fff			stz 	EndVariableSpace-1 			; put a zero at the end, so know end of string memory.
.a7eb		60		rts				rts
.a7ec						StringSpaceInitialise:
.a7ec		20 83 9a	jsr $9a83			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a7ef		a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.a7f1		8d 10 04	sta $0410			sta 	StringInitialised
.a7f4		ad 0e 04	lda $040e			lda 	StringMemory 				; allocate 256 bytes for one concreted string
.a7f7		8d 11 04	sta $0411			sta 	StringTempPointer 			; so temporary string space is allocated below that.
.a7fa		ad 0f 04	lda $040f			lda 	StringMemory+1
.a7fd		3a		dec a				dec 	a
.a7fe		8d 12 04	sta $0412			sta 	StringTempPointer+1
.a801		60		rts				rts
.a802						StringTempAllocate:
.a802		c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.a804		b0 30		bcs $a836			bcs 	_STALength
.a806		2c 10 04	bit $0410			bit 	StringInitialised 			; already initialised
.a809		30 05		bmi $a810			bmi 	_STAAllocate
.a80b		48		pha				pha 								; save value to subtract.
.a80c		20 ec a7	jsr $a7ec			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.a80f		68		pla				pla 								; restore it
.a810						_STAAllocate:
.a810		49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.a812		18		clc				clc  								; deliberate allows one more
.a813		6d 11 04	adc $0411			adc 	StringTempPointer 			; subtract from temp pointer
.a816		8d 11 04	sta $0411			sta 	StringTempPointer
.a819		95 58		sta $58,x			sta 	NSMantissa0,x 				; address in mantissa
.a81b		85 3c		sta $3c				sta 	zsTemp 						; and zsTemp
.a81d		ad 12 04	lda $0412			lda 	StringTempPointer+1
.a820		69 ff		adc #$ff			adc 	#$FF
.a822		8d 12 04	sta $0412			sta 	StringTempPointer+1
.a825		85 3d		sta $3d				sta 	zsTemp+1
.a827		95 60		sta $60,x			sta 	NSMantissa1,x
.a829		74 68		stz $68,x			stz 	NSMantissa2,x 				; set the typing data and the upper address bytes.
.a82b		74 70		stz $70,x			stz 	NSMantissa3,x
.a82d		a9 10		lda #$10			lda 	#NSTString
.a82f		95 50		sta $50,x			sta 	NSStatus,x
.a831		a9 00		lda #$00			lda 	#0 							; clear the target string
.a833		92 3c		sta ($3c)			sta 	(zsTemp)
.a835		60		rts				rts
.a836						_STALength:
.a836		a9 09		lda #$09		lda	#9
.a838		4c 49 8f	jmp $8f49		jmp	ErrorHandler
.a83b						StringTempWrite:
.a83b		48		pha				pha
.a83c		92 3c		sta ($3c)			sta 	(zsTemp) 					; write byte
.a83e		e6 3c		inc $3c				inc 	zsTemp 						; bump pointer
.a840		d0 02		bne $a844			bne 	_STWNoCarry
.a842		e6 3d		inc $3d				inc 	zsTemp+1
.a844						_STWNoCarry:
.a844		a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.a846		92 3c		sta ($3c)			sta 	(zsTemp)
.a848		68		pla				pla
.a849		60		rts				rts

;******  Return to file: _basic.asm

.a84a						StartModuleCode:

;******  Processing file: ../modules/_build/_hardware.module

=1						hardwareIntegrated=1
=0						CONBlack = 0
=1						CONWhite = 1
=2						CONRed = 2
=3						CONCyan = 3
=4						CONPurple = 4
=5						CONGreen = 5
=6						CONBlue = 6
=7						CONYellow = 7
=8						CONOrange = 8
=9						CONBrown = 9
=10						CONYellowGreen = 10
=11						CONRosa = 11
=12						CONBlueGreen = 12
=13						CONLightBlue = 13
=14						CONPink = 14
=15						CONLightGreen = 15
=7						CONForeground = CONYellow
=6						CONBackground = CONBlue
=5						CLICommandLine = CONGreen
=0						CLIFComment = CONBlack
=7						CLIBComment = CONYellow
=9						CLILineNumber = CONBrown
=3						CLIToken = CONCyan
=13						CLIConstant = CONLightBlue
=7						CLIIdentifier = CONYellow
=10						CLIPunctuation = CONYellowGreen
=1						CLIData = CONWhite
.c000	a000					Export_EXTPrintCharacter:
.c000	a000					PAGEDPrintCharacter:
.c000	a000	48		pha				pha
.c001	a001	da		phx				phx
.c002	a002	5a		phy				phy
.c003	a003	a6 01		ldx $01				ldx 	1
.c005	a005	da		phx				phx
.c006	a006	ac 6e 06	ldy $066e			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.c009	a009	09 00		ora #$00			ora 	#$00 						; check $80-$FF
.c00b	a00b	30 48		bmi $a055			bmi 	_EXPCColour
.c00d	a00d	c9 20		cmp #$20			cmp 	#$20 						; check $00-$1F
.c00f	a00f	90 4d		bcc $a05e			bcc 	_EXPCControl
.c011	a011	a2 02		ldx #$02			ldx 	#2 							; select char memory
.c013	a013	86 01		stx $01				stx 	1
.c015	a015	91 40		sta ($40),y			sta 	(EXTAddress),y
.c017	a017	e6 01		inc $01				inc 	1 							; select colour memory
.c019	a019	ad 6f 06	lda $066f			lda 	EXTTextColour
.c01c	a01c	91 40		sta ($40),y			sta 	(EXTAddress),y
.c01e	a01e	c8		iny				iny 								; advance horizontal position
.c01f	a01f	8c 6e 06	sty $066e			sty 	EXTColumn
.c022	a022	cc 70 06	cpy $0670			cpy 	EXTScreenWidth 				; reached RHS ?
.c025	a025	90 63		bcc $a08a			bcc 	_EXPCExit 					; no, then exit.
.c027	a027					_EXPCCRLF:
.c027	a027	ee 6d 06	inc $066d			inc 	EXTRow  					; bump row
.c02a	a02a	9c 6e 06	stz $066e			stz 	EXTColumn 					; back to column 0
.c02d	a02d	ad 6d 06	lda $066d			lda 	EXTRow 						; check if reached the bottom ?
.c030	a030	cd 71 06	cmp $0671			cmp 	EXTScreenHeight 			; if so, then scroll.
.c033	a033	f0 18		beq $a04d			beq 	_EXPCScroll
.c035	a035	18		clc				clc 								; add width to address.
.c036	a036	a5 40		lda $40				lda 	EXTAddress
.c038	a038	6d 70 06	adc $0670			adc 	EXTScreenWidth
.c03b	a03b	85 40		sta $40				sta 	EXTAddress
.c03d	a03d	90 4b		bcc $a08a			bcc 	_EXPCExit
.c03f	a03f	e6 41		inc $41				inc 	EXTAddress+1
.c041	a041	80 47		bra $a08a			bra 	_EXPCExit
.c043	a043					_EXPCLeft:
.c043	a043	ce 6e 06	dec $066e			dec 	EXTColumn
.c046	a046	10 42		bpl $a08a			bpl 	_EXPCExit
.c048	a048					_EXPCBegin:
.c048	a048	9c 6e 06	stz $066e			stz 	EXTColumn
.c04b	a04b	80 3d		bra $a08a			bra 	_EXPCExit
.c04d	a04d					_EXPCScroll:
.c04d	a04d	ce 6d 06	dec $066d			dec 	EXTRow 						; the height-1 th line.
.c050	a050	20 3b a1	jsr $a13b			jsr 	EXTScreenScroll 			; scroll the screen
.c053	a053	80 35		bra $a08a			bra 	_EXPCExit
.c055	a055					_EXPCColour:
.c055	a055	c9 a0		cmp #$a0			cmp 	#$A0						; 80-9F set foreground/background
.c057	a057	b0 31		bcs $a08a			bcs 	_EXPCExit
.c059	a059	20 1b a1	jsr $a11b			jsr 	_EXPCHandleColour
.c05c	a05c	80 2c		bra $a08a			bra 	_EXPCExit
.c05e	a05e					_EXPCControl:
.c05e	a05e	c9 11		cmp #$11			cmp 	#$11 						; only handle 00-10.
.c060	a060	b0 28		bcs $a08a			bcs 	_EXPCExit
.c062	a062	0a		asl a				asl 	a 							; double into X
.c063	a063	aa		tax				tax
.c064	a064	7c f9 a0	jmp ($a0f9,x)			jmp 	(_EXPCActionTable,x) 		; and execute code.
.c067	a067					_EXPCUp:
.c067	a067	ad 6d 06	lda $066d			lda 	EXTRow 						; already at top ?
.c06a	a06a	f0 1e		beq $a08a			beq 	_EXPCExit
.c06c	a06c	ce 6d 06	dec $066d			dec 	EXTRow 						; up one in position/address
.c06f	a06f	38		sec				sec
.c070	a070	a5 40		lda $40				lda 	EXTAddress
.c072	a072	ed 70 06	sbc $0670			sbc 	EXTScreenWidth
.c075	a075	85 40		sta $40				sta 	EXTAddress
.c077	a077	b0 11		bcs $a08a			bcs 	_EXPCExit
.c079	a079	c6 41		dec $41				dec 	EXTAddress+1
.c07b	a07b	80 0d		bra $a08a			bra 	_EXPCExit
.c07d	a07d					_EXPCRight:
.c07d	a07d	c8		iny				iny
.c07e	a07e	8c 6e 06	sty $066e			sty 	EXTColumn
.c081	a081	cc 70 06	cpy $0670			cpy 	EXTScreenWidth
.c084	a084	d0 04		bne $a08a			bne 	_EXPCExit
.c086	a086	88		dey				dey
.c087	a087					_EXPCSetColumnY:
.c087	a087	8c 6e 06	sty $066e			sty 	EXTColumn
.c08a	a08a					_EXPCExit:
.c08a	a08a	20 90 a1	jsr $a190			jsr 	EXTSetHardwareCursor 		; place the physical cursor.
.c08d	a08d	68		pla				pla
.c08e	a08e	85 01		sta $01				sta 	1
.c090	a090	7a		ply				ply
.c091	a091	fa		plx				plx
.c092	a092	68		pla				pla
.c093	a093	60		rts				rts
.c094	a094					_EXPCClearScreen:
.c094	a094	20 4d a1	jsr $a14d			jsr		EXTClearScreenCode
.c097	a097	80 f1		bra $a08a			bra 	_EXPCExit
.c099	a099					_EXPCDown:
.c099	a099	ad 71 06	lda $0671			lda 	EXTScreenHeight 			; at the bottom
.c09c	a09c	3a		dec a				dec 	a
.c09d	a09d	cd 6d 06	cmp $066d			cmp 	EXTRow
.c0a0	a0a0	f0 e8		beq $a08a			beq 	_EXPCExit
.c0a2	a0a2	ee 6d 06	inc $066d			inc 	EXTRow 						; down one in position/address
.c0a5	a0a5	18		clc				clc
.c0a6	a0a6	a5 40		lda $40				lda 	EXTAddress
.c0a8	a0a8	6d 70 06	adc $0670			adc 	EXTScreenWidth
.c0ab	a0ab	85 40		sta $40				sta 	EXTAddress
.c0ad	a0ad	90 db		bcc $a08a			bcc 	_EXPCExit
.c0af	a0af	e6 41		inc $41				inc 	EXTAddress+1
.c0b1	a0b1	80 d7		bra $a08a			bra 	_EXPCExit
.c0b3	a0b3					_EXPCTab:
.c0b3	a0b3	ad 6e 06	lda $066e			lda 	EXTColumn 					; next tab stop
.c0b6	a0b6	29 f8		and #$f8			and 	#$F8
.c0b8	a0b8	18		clc				clc
.c0b9	a0b9	69 08		adc #$08			adc 	#8
.c0bb	a0bb	8d 6e 06	sta $066e			sta 	EXTColumn
.c0be	a0be	cd 70 06	cmp $0670			cmp 	EXTScreenWidth 				; too far, stick end of line.
.c0c1	a0c1	90 c7		bcc $a08a			bcc 	_EXPCExit
.c0c3	a0c3	80 10		bra $a0d5			bra 	_EXPCEnd
.c0c5	a0c5					_EXPCBackSpace:
.c0c5	a0c5	88		dey				dey
.c0c6	a0c6	30 c2		bmi $a08a			bmi 	_EXPCExit
.c0c8	a0c8	ce 6e 06	dec $066e			dec 	EXTColumn
.c0cb	a0cb	a9 02		lda #$02			lda 	#2
.c0cd	a0cd	85 01		sta $01				sta 	1
.c0cf	a0cf	a9 20		lda #$20			lda 	#32
.c0d1	a0d1	91 40		sta ($40),y			sta 	(EXTAddress),y
.c0d3	a0d3	80 b5		bra $a08a			bra 	_EXPCExit
.c0d5	a0d5					_EXPCEnd:
.c0d5	a0d5	a9 02		lda #$02			lda 	#2 							; access text screen
.c0d7	a0d7	85 01		sta $01				sta 	1
.c0d9	a0d9	ac 70 06	ldy $0670			ldy 	EXTScreenWidth 				; point to last character
.c0dc	a0dc	88		dey				dey
.c0dd	a0dd					_EXPCEndSearch:
.c0dd	a0dd	88		dey				dey 								; if past start, move to col 0.
.c0de	a0de	30 06		bmi $a0e6			bmi 	_EXPCFound
.c0e0	a0e0	b1 40		lda ($40),y			lda 	(EXTAddress),y 				; keep going back till non space found
.c0e2	a0e2	c9 20		cmp #$20			cmp 	#' '
.c0e4	a0e4	f0 f7		beq $a0dd			beq 	_EXPCEndSearch
.c0e6	a0e6					_EXPCFound:
.c0e6	a0e6	c8		iny				iny 								; move to following cell.
.c0e7	a0e7	80 9e		bra $a087			bra 	_EXPCSetColumnY
.c0e9	a0e9					_EXPCClearEOL:
.c0e9	a0e9	a9 02		lda #$02			lda 	#2 							; access character RAM
.c0eb	a0eb	85 01		sta $01				sta 	1
.c0ed	a0ed	a9 20		lda #$20			lda 	#' ' 						; write space
.c0ef	a0ef	91 40		sta ($40),y			sta 	(EXTAddress),y
.c0f1	a0f1	c8		iny				iny
.c0f2	a0f2	cc 70 06	cpy $0670			cpy 	EXTScreenWidth 				; until RHS of screen.
.c0f5	a0f5	90 f2		bcc $a0e9			bcc 	_EXPCClearEOL
.c0f7	a0f7	80 91		bra $a08a			bra 	_EXPCExit
.c0f9	a0f9					_EXPCActionTable:
>c0f9	a0f9	8a a0						.word 	_EXPCExit 					; 00
>c0fb	a0fb	48 a0						.word 	_EXPCBegin 					; 01 A Start of Line
>c0fd	a0fd	43 a0						.word 	_EXPCLeft 					; 02 B Left
>c0ff	a0ff	8a a0						.word 	_EXPCExit 					; 03 <Break>
>c101	a101	8a a0						.word 	_EXPCExit 					; 04
>c103	a103	d5 a0						.word 	_EXPCEnd 					; 05 E End of Line
>c105	a105	7d a0						.word 	_EXPCRight 					; 06 F Right
>c107	a107	8a a0						.word 	_EXPCExit 					; 07
>c109	a109	c5 a0						.word 	_EXPCBackspace 				; 08 H Backspace
>c10b	a10b	b3 a0						.word 	_EXPCTab 					; 09 I Tab
>c10d	a10d	8a a0						.word 	_EXPCExit 					; 0A
>c10f	a10f	e9 a0						.word 	_EXPCClearEOL 				; 0B K Clear to EOL
>c111	a111	94 a0						.word 	_EXPCClearScreen			; 0C L CLS
>c113	a113	27 a0						.word 	_EXPCCRLF 					; 0D M CR/LF
>c115	a115	99 a0						.word 	_EXPCDown 					; 0E N Down
>c117	a117	8a a0						.word 	_EXPCExit 					; 0F
>c119	a119	67 a0						.word 	_EXPCUp 					; 10 P Up
.c11b	a11b					_EXPCHandleColour
.c11b	a11b	c9 90		cmp #$90			cmp 	#$90 						; 8x foreground 9x background
.c11d	a11d	b0 16		bcs $a135			bcs 	_EXPCBackground
.c11f	a11f	0a		asl a				asl 	a 							; shift it 4 bits to the right.
.c120	a120	0a		asl a				asl 	a
.c121	a121	0a		asl a				asl 	a
.c122	a122	0a		asl a				asl 	a
.c123	a123	a2 0f		ldx #$0f			ldx 	#$0F 						; Mask in X
.c125	a125					_EXPCUpdate:
.c125	a125	48		pha				pha 								; save new colour
.c126	a126	8a		txa				txa 								; get mask
.c127	a127	2d 6f 06	and $066f			and 	EXTTextColour 				; mask out old.
.c12a	a12a	8d 6f 06	sta $066f			sta 	EXTTextColour
.c12d	a12d	68		pla				pla 								; or in new colour
.c12e	a12e	0d 6f 06	ora $066f			ora 	EXTTextColour
.c131	a131	8d 6f 06	sta $066f			sta 	EXTTextColour
.c134	a134	60		rts				rts
.c135	a135					_EXPCBackground:
.c135	a135	29 0f		and #$0f			and 	#$0F 						; get the colour
.c137	a137	a2 f0		ldx #$f0			ldx 	#$F0 						; mask
.c139	a139	80 ea		bra $a125			bra 	_EXPCUpdate
.c13b	a13b					EXTScreenScroll:
.c13b	a13b	a9 02		lda #$02			lda 	#2 							; select text page
.c13d	a13d	85 01		sta $01				sta 	1
.c13f	a13f	a9 20		lda #$20			lda		#32 						; fill with space
.c141	a141	20 54 a2	jsr $a254			jsr 	EXTScrollFill
.c144	a144	e6 01		inc $01				inc 	1 							; select colour page
.c146	a146	ad 6f 06	lda $066f			lda 	EXTTextColour
.c149	a149	20 54 a2	jsr $a254			jsr 	EXTScrollFill
.c14c	a14c	60		rts				rts
.c14d	a14d					EXTClearScreenCode:
.c14d	a14d	a9 02		lda #$02			lda 	#2 							; select text page
.c14f	a14f	85 01		sta $01				sta 	1
.c151	a151	a9 20		lda #$20			lda		#32 						; fill with space
.c153	a153	20 60 a1	jsr $a160			jsr 	_EXTCSFill
.c156	a156	e6 01		inc $01				inc 	1 							; select colour page
.c158	a158	ad 6f 06	lda $066f			lda 	EXTTextColour
.c15b	a15b	20 60 a1	jsr $a160			jsr 	_EXTCSFill
.c15e	a15e	80 22		bra $a182			bra 	EXTHomeCursor
.c160	a160					_EXTCSFill:
.c160	a160	aa		tax				tax
.c161	a161	a9 00		lda #$00			lda 	#EXTMemory & $FF
.c163	a163	85 40		sta $40				sta 	EXTAddress
.c165	a165	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.c167	a167	85 41		sta $41				sta 	EXTAddress+1
.c169	a169					_EXTCSFill1:
.c169	a169	a0 00		ldy #$00			ldy 	#0
.c16b	a16b	8a		txa				txa
.c16c	a16c					_EXTCSFill2:
.c16c	a16c	91 40		sta ($40),y			sta 	(EXTAddress),y
.c16e	a16e	c8		iny				iny
.c16f	a16f	d0 fb		bne $a16c			bne 	_EXTCSFill2
.c171	a171	e6 41		inc $41				inc 	EXTAddress+1
.c173	a173	a5 41		lda $41				lda 	EXTAddress+1
.c175	a175	c9 d2		cmp #$d2			cmp 	#$D2
.c177	a177	d0 f0		bne $a169			bne 	_EXTCSFill1
.c179	a179	8a		txa				txa
.c17a	a17a					_EXTCSFill3:
.c17a	a17a	91 40		sta ($40),y			sta 	(EXTAddress),y
.c17c	a17c	c8		iny				iny
.c17d	a17d	c0 c0		cpy #$c0			cpy 	#$C0
.c17f	a17f	d0 f9		bne $a17a			bne 	_EXTCSFill3
.c181	a181	60		rts				rts
.c182	a182					EXTHomeCursor:
.c182	a182	9c 6d 06	stz $066d			stz 	EXTRow 						; reset row & column
.c185	a185	9c 6e 06	stz $066e			stz 	EXTColumn
.c188	a188	a9 00		lda #$00			lda 	#EXTMemory & $FF 			; set address
.c18a	a18a	85 40		sta $40				sta 	EXTAddress
.c18c	a18c	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.c18e	a18e	85 41		sta $41				sta 	EXTAddress+1
.c190	a190					EXTSetHardwareCursor:
.c190	a190	64 01		stz $01				stz 	1 							; I/O Page zero
.c192	a192	a9 05		lda #$05			lda 	#1+4 						; enable cursor
.c194	a194	8d 10 d0	sta $d010			sta 	$D010
.c197	a197	a9 b1		lda #$b1			lda 	#$B1
.c199	a199	8d 12 d0	sta $d012			sta 	$D012
.c19c	a19c	ad 6e 06	lda $066e			lda 	EXTColumn
.c19f	a19f	8d 14 d0	sta $d014			sta 	$D014 						; set cursor position
.c1a2	a1a2	9c 15 d0	stz $d015			stz 	$D015
.c1a5	a1a5	ad 6d 06	lda $066d			lda 	EXTRow
.c1a8	a1a8	8d 16 d0	sta $d016			sta 	$D016
.c1ab	a1ab	9c 17 d0	stz $d017			stz 	$D017
.c1ae	a1ae	60		rts				rts
.c1af	a1af					Export_EXTInputLine:
.c1af	a1af	48		pha				pha
.c1b0	a1b0	da		phx				phx
.c1b1	a1b1	5a		phy				phy
.c1b2	a1b2	a5 01		lda $01				lda 	1 							; save I/O page
.c1b4	a1b4	48		pha				pha
.c1b5	a1b5					_EILLoop:
.c1b5	a1b5	20 cf a2	jsr $a2cf			jsr 	PagedInputSingleCharacter
.c1b8	a1b8	c9 0d		cmp #$0d			cmp 	#13 						; scrape line if exit.
.c1ba	a1ba	f0 44		beq $a200			beq 	_EILExit
.c1bc	a1bc	c9 04		cmp #$04			cmp 	#4 							; Ctrl+D delete at cursor
.c1be	a1be	f0 2a		beq $a1ea			beq 	_EILDelete
.c1c0	a1c0	c9 08		cmp #$08			cmp 	#8 							; Ctrl+H backspace
.c1c2	a1c2	f0 1c		beq $a1e0			beq 	_EILBackspace
.c1c4	a1c4	c9 20		cmp #$20			cmp 	#' '						; < space, print it
.c1c6	a1c6	90 12		bcc $a1da			bcc 	_EILPrintLoop
.c1c8	a1c8	c9 7f		cmp #$7f			cmp 	#$7F 						; if -ve print it
.c1ca	a1ca	b0 0e		bcs $a1da			bcs 	_EILPrintLoop
.c1cc	a1cc	48		pha				pha 								; save character
.c1cd	a1cd	a9 02		lda #$02			lda 	#2  						; insert a space
.c1cf	a1cf	85 01		sta $01				sta 	1
.c1d1	a1d1	20 42 a2	jsr $a242			jsr 	EXTILInsert 				; insert in text screen
.c1d4	a1d4	e6 01		inc $01				inc 	1
.c1d6	a1d6	20 42 a2	jsr $a242			jsr 	EXTILInsert 				; insert in colour screen
.c1d9	a1d9	68		pla				pla 								; get character back.
.c1da	a1da					_EILPrintLoop:
.c1da	a1da	20 00 a0	jsr $a000			jsr 	PagedPrintCharacter
.c1dd	a1dd	80 d6		bra $a1b5			bra 	_EILLoop
.c1df	a1df	60		rts				rts
.c1e0	a1e0					_EILBackspace:
.c1e0	a1e0	ad 6e 06	lda $066e			lda 	EXTColumn					; can we backspace ?
.c1e3	a1e3	f0 d0		beq $a1b5			beq 	_EILLoop
.c1e5	a1e5	a9 02		lda #$02			lda 	#2 							; move cursor left
.c1e7	a1e7	20 00 a0	jsr $a000			jsr 	PagedPrintCharacter
.c1ea	a1ea					_EILDelete
.c1ea	a1ea	a9 02		lda #$02			lda 	#2 							; text block
.c1ec	a1ec	85 01		sta $01				sta 	1
.c1ee	a1ee	a9 20		lda #$20			lda 	#' ' 						; backspace text.
.c1f0	a1f0	20 2d a2	jsr $a22d			jsr 	EXTILDelete
.c1f3	a1f3	e6 01		inc $01				inc 	1 							; colour block
.c1f5	a1f5	ac 6e 06	ldy $066e			ldy 	EXTColumn 					; get attribute of last character
.c1f8	a1f8	88		dey				dey
.c1f9	a1f9	b1 40		lda ($40),y			lda 	(EXTAddress),y
.c1fb	a1fb	20 2d a2	jsr $a22d			jsr 	EXTILDelete 				; backspace attribute
.c1fe	a1fe	80 b5		bra $a1b5			bra 	_EILLoop 					; and go round.
.c200	a200					_EILExit:
.c200	a200	a9 02		lda #$02			lda 	#2 							; switch to page 2
.c202	a202	85 01		sta $01				sta 	1
.c204	a204	a0 00		ldy #$00			ldy 	#0 							; copy current line into buffer.
.c206	a206					_EILScrapeLine:
.c206	a206	b1 40		lda ($40),y			lda 	(EXTAddress),y
.c208	a208	99 2a 05	sta $052a,y			sta 	lineBuffer,y
.c20b	a20b	c8		iny				iny
.c20c	a20c	cc 70 06	cpy $0670			cpy 	EXTScreenWidth
.c20f	a20f	d0 f5		bne $a206			bne 	_EILScrapeLine
.c211	a211					_EILTrimSpaces:
.c211	a211	88		dey				dey
.c212	a212	f0 08		beq $a21c			beq 	_EILEndTrim
.c214	a214	b9 2a 05	lda $052a,y			lda 	lineBuffer,y
.c217	a217	c9 20		cmp #$20			cmp 	#' '
.c219	a219	f0 f6		beq $a211			beq 	_EILTrimSpaces
.c21b	a21b	c8		iny				iny 								; trim after non space character.
.c21c	a21c					_EILEndTrim:
.c21c	a21c	a9 00		lda #$00			lda 	#0 							; trim here.
.c21e	a21e	99 2a 05	sta $052a,y			sta 	lineBuffer,y
.c221	a221	a9 0d		lda #$0d			lda 	#13 						; echo the RETURN
.c223	a223	20 00 a0	jsr $a000			jsr 	PagedPrintCharacter
.c226	a226	68		pla				pla 								; reset I/O page
.c227	a227	85 01		sta $01				sta 	1
.c229	a229	7a		ply				ply
.c22a	a22a	fa		plx				plx
.c22b	a22b	68		pla				pla
.c22c	a22c	60		rts				rts
.c22d	a22d					EXTILDelete:
.c22d	a22d	48		pha				pha 								; save the new character
.c22e	a22e	ac 6e 06	ldy $066e			ldy 	EXTColumn 					; start copying from here.
.c231	a231					_EXTDLoop:
.c231	a231	c8		iny				iny 								; copy one byte down.
.c232	a232	b1 40		lda ($40),y			lda 	(EXTAddress),y
.c234	a234	88		dey				dey
.c235	a235	91 40		sta ($40),y			sta 	(EXTAddress),y
.c237	a237	c8		iny				iny 								; do till end of line.
.c238	a238	cc 70 06	cpy $0670			cpy 	EXTScreenWidth
.c23b	a23b	90 f4		bcc $a231			bcc 	_EXTDLoop
.c23d	a23d	88		dey				dey 	 							; write in last slot.
.c23e	a23e	68		pla				pla
.c23f	a23f	91 40		sta ($40),y			sta 	(EXTAddress),y
.c241	a241	60		rts				rts
.c242	a242					EXTILInsert:
.c242	a242	ac 70 06	ldy $0670			ldy 	EXTScreenWidth 				; end position
.c245	a245					_EXTILoop:
.c245	a245	88		dey				dey 								; back one
.c246	a246	cc 6e 06	cpy $066e			cpy 	EXTColumn 					; exit if reached insert point.
.c249	a249	f0 08		beq $a253			beq 	_EXTIExit
.c24b	a24b	88		dey				dey 								; copy one byte up.
.c24c	a24c	b1 40		lda ($40),y			lda 	(EXTAddress),y
.c24e	a24e	c8		iny				iny
.c24f	a24f	91 40		sta ($40),y			sta 	(EXTAddress),y
.c251	a251	80 f2		bra $a245			bra 	_EXTILoop
.c253	a253					_EXTIExit:
.c253	a253	60		rts				rts
.c254	a254					EXTScrollFill:
.c254	a254	aa		tax				tax									; save value to fill with
.c255	a255	a5 36		lda $36				lda 	zTemp0 						; save zTemp0 (dest) zTemp1 (src)
.c257	a257	48		pha				pha
.c258	a258	a5 37		lda $37				lda 	zTemp0+1
.c25a	a25a	48		pha				pha
.c25b	a25b	a5 38		lda $38				lda 	zTemp1
.c25d	a25d	48		pha				pha
.c25e	a25e	a5 39		lda $39				lda 	zTemp1+1
.c260	a260	48		pha				pha
.c261	a261	a9 c0		lda #$c0			lda 	#$C0 						; copy from C000+length to C000
.c263	a263	85 37		sta $37				sta 	zTemp0+1
.c265	a265	85 39		sta $39				sta 	zTemp1+1
.c267	a267	64 36		stz $36				stz 	zTemp0
.c269	a269	ad 70 06	lda $0670			lda 	EXTScreenWidth
.c26c	a26c	85 38		sta $38				sta 	zTemp1
.c26e	a26e	a0 00		ldy #$00			ldy 	#0
.c270	a270					_EXSFCopy1:
.c270	a270	b1 38		lda ($38),y			lda 	(zTemp1),y
.c272	a272	91 36		sta ($36),y			sta 	(zTemp0),y
.c274	a274	c8		iny				iny
.c275	a275	d0 f9		bne $a270			bne 	_EXSFCopy1
.c277	a277	e6 37		inc $37				inc 	zTemp0+1 					; next page
.c279	a279	e6 39		inc $39				inc 	zTemp1+1
.c27b	a27b	a5 39		lda $39				lda 	zTemp1+1
.c27d	a27d	c9 d3		cmp #$d3			cmp 	#$D3
.c27f	a27f	d0 ef		bne $a270			bne 	_EXSFCopy1
.c281	a281	ac 70 06	ldy $0670			ldy 	EXTScreenWidth 				; blank the bottom line.
.c284	a284	8a		txa				txa
.c285	a285					_EXSFFill1:
.c285	a285	88		dey				dey
.c286	a286	91 40		sta ($40),y			sta 	(EXTAddress),y
.c288	a288	c0 00		cpy #$00			cpy 	#0
.c28a	a28a	10 f9		bpl $a285			bpl 	_EXSFFill1
.c28c	a28c	68		pla				pla
.c28d	a28d	85 39		sta $39				sta 	zTemp1+1
.c28f	a28f	68		pla				pla
.c290	a290	85 38		sta $38				sta 	zTemp1
.c292	a292	68		pla				pla
.c293	a293	85 37		sta $37				sta 	zTemp0+1
.c295	a295	68		pla				pla
.c296	a296	85 36		sta $36				sta 	zTemp0
.c298	a298	60		rts				rts
=$c000						EXTMemory = $C000
=$02						EXTTextPage = $02
=$03						EXTColourPage = $03
=1						EXTDummySpace = 1 							; fake-space for CR character.
=0						EXTCBlack = 0
.066d						EXTRow:
>066d								.fill 	1
.066e						EXTColumn:
>066e								.fill 	1
.066f						EXTTextColour:
>066f								.fill 	1
.0670						EXTScreenWidth:
>0670								.fill 	1
.0671						EXTScreenHeight:
>0671								.fill 	1
.0040						EXTAddress:
>0040								.fill 	2
.c299	a299					Export_EXTInitialise:
.c299	a299	64 01		stz $01				stz 	1 							; Access I/O page 0
.c29b	a29b	9c 04 d0	stz $d004			stz 	$D004 						; Disable border
.c29e	a29e	9c 08 d0	stz $d008			stz 	$D008
.c2a1	a2a1	9c 09 d0	stz $d009			stz 	$D009
.c2a4	a2a4	a9 09		lda #$09			lda 	#1+8						; Timer On at 70Hz counting up.
.c2a6	a2a6	8d 58 d6	sta $d658			sta 	$D658
.c2a9	a2a9	a9 03		lda #$03			lda 	#3 							; get current text colour from whatever the kernel
.c2ab	a2ab	85 01		sta $01				sta 	1 							; has set it to, looking at top left character
.c2ad	a2ad	ad 00 c0	lda $c000			lda 	$C000
.c2b0	a2b0	8d 6f 06	sta $066f			sta 	EXTTextColour
.c2b3	a2b3	a9 50		lda #$50			lda 	#80 						; set screen dimensions.
.c2b5	a2b5	8d 70 06	sta $0670			sta 	EXTScreenWidth
.c2b8	a2b8	a9 3c		lda #$3c			lda 	#60
.c2ba	a2ba	8d 71 06	sta $0671			sta 	EXTScreenHeight
.c2bd	a2bd	20 82 a1	jsr $a182			jsr 	EXTHomeCursor 				; home cursor
.c2c0	a2c0					_EXMoveDown:
.c2c0	a2c0	a9 0d		lda #$0d			lda 	#13
.c2c2	a2c2	20 00 a0	jsr $a000			jsr 	PAGEDPrintCharacter
.c2c5	a2c5	ad 6d 06	lda $066d			lda 	EXTRow
.c2c8	a2c8	c9 08		cmp #$08			cmp 	#8
.c2ca	a2ca	d0 f4		bne $a2c0			bne 	_EXMoveDown
.c2cc	a2cc	64 01		stz $01				stz 	1
.c2ce	a2ce	60		rts				rts
.c2cf	a2cf					Export_EXTInputSingleCharacter:
.c2cf	a2cf					PagedInputSingleCharacter:
.c2cf	a2cf	da		phx				phx
.c2d0	a2d0	5a		phy				phy
.c2d1	a2d1					_EISCWait:
.c2d1	a2d1	a5 01		lda $01				lda 	1 							; save I/O 0
.c2d3	a2d3	48		pha				pha
.c2d4	a2d4	64 01		stz $01				stz 	1 							; access I/O Page 0
.c2d6	a2d6	38		sec				sec 								; calculate timer - LastTick
.c2d7	a2d7	ad 59 d6	lda $d659			lda 	$D659
.c2da	a2da	aa		tax				tax 								; saving timer in X
.c2db	a2db	ed 5c 06	sbc $065c			sbc 	LastTick
.c2de	a2de	c9 03		cmp #$03			cmp 	#3
.c2e0	a2e0	90 06		bcc $a2e8			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.c2e2	a2e2	8e 5c 06	stx $065c			stx 	LastTick 					; update last timer
.c2e5	a2e5	20 ab b6	jsr $b6ab			jsr 	PagedSNDUpdate 							; go do the code.
.c2e8	a2e8					_NoFireTick:
.c2e8	a2e8	68		pla				pla 								; restore I/O 0
.c2e9	a2e9	85 01		sta $01				sta 	1
.c2eb	a2eb	20 e4 ff	jsr $ffe4			jsr 	$FFE4 						; get a key
.c2ee	a2ee	c9 00		cmp #$00			cmp 	#0 							; loop back if none pressed.
.c2f0	a2f0	f0 df		beq $a2d1			beq 	_EISCWait
.c2f2	a2f2	7a		ply				ply
.c2f3	a2f3	fa		plx				plx
.c2f4	a2f4	60		rts				rts
.c2f5	a2f5					Export_EXTBreakCheck:
.c2f5	a2f5	4c e1 ff	jmp $ffe1			jmp		$FFE1
=3						KP_Z_ROW = 3
=$04						KP_Z_COL = $04
=4						KP_X_ROW = 4
=$04						KP_X_COL = $04
=8						KP_K_ROW = 8
=$04						KP_K_COL = $04
=7						KP_M_ROW = 7
=$04						KP_M_COL = $04
=9						KP_L_ROW = 9
=$08						KP_L_COL = $08
.c2f8	a2f8					Export_EXTReadController:
.c2f8	a2f8	da		phx				phx
.c2f9	a2f9	a2 00		ldx #$00		ldx 	#0
.c2fb	a2fb	a9 04		lda #$04			lda 	#KP_X_ROW
.c2fd	a2fd	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.c300	a300	29 04		and #$04			and 	#KP_X_COL
.c302	a302	f0 04		beq $a308			beq 	_NoSet1
.c304	a304	8a		txa				txa
.c305	a305	09 01		ora #$01			ora 	#1
.c307	a307	aa		tax				tax
.c308	a308					_NoSet1:
.c308	a308	a9 03		lda #$03			lda 	#KP_Z_ROW
.c30a	a30a	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.c30d	a30d	29 04		and #$04			and 	#KP_Z_COL
.c30f	a30f	f0 04		beq $a315			beq 	_NoSet1
.c311	a311	8a		txa				txa
.c312	a312	09 02		ora #$02			ora 	#2
.c314	a314	aa		tax				tax
.c315	a315					_NoSet1:
.c315	a315	a9 07		lda #$07			lda 	#KP_M_ROW
.c317	a317	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.c31a	a31a	29 04		and #$04			and 	#KP_M_COL
.c31c	a31c	f0 04		beq $a322			beq 	_NoSet1
.c31e	a31e	8a		txa				txa
.c31f	a31f	09 04		ora #$04			ora 	#4
.c321	a321	aa		tax				tax
.c322	a322					_NoSet1:
.c322	a322	a9 08		lda #$08			lda 	#KP_K_ROW
.c324	a324	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.c327	a327	29 04		and #$04			and 	#KP_K_COL
.c329	a329	f0 04		beq $a32f			beq 	_NoSet1
.c32b	a32b	8a		txa				txa
.c32c	a32c	09 08		ora #$08			ora 	#8
.c32e	a32e	aa		tax				tax
.c32f	a32f					_NoSet1:
.c32f	a32f	a9 09		lda #$09			lda 	#KP_L_ROW
.c331	a331	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.c334	a334	29 08		and #$08			and 	#KP_L_COL
.c336	a336	f0 04		beq $a33c			beq 	_NoSet1
.c338	a338	8a		txa				txa
.c339	a339	09 10		ora #$10			ora 	#16
.c33b	a33b	aa		tax				tax
.c33c	a33c					_NoSet1:
.c33c	a33c	8a		txa				txa
.c33d	a33d	fa		plx				plx
.c33e	a33e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_graphics.module

=1						graphicsIntegrated=1
=0						GCMD_Initialise = 0*2
=2						GCMD_BitmapCtl = 1*2
=4						GCMD_SpriteCtl = 2*2
=6						GCMD_Clear = 3*2
=8						GCMD_Colour = 4*2
=10						GCMD_DrawFont = 5*2
=12						GCMD_DrawSprite = 6*2
=14						GCMD_SpriteUse = 7*2
=16						GCMD_SpriteImage = 8*2
=18						GCMD_SpriteCollide = 9*2
=64						GCMD_Move = 32*2
=66						GCMD_Line = 33*2
=68						GCMD_FrameRect = 34*2
=70						GCMD_FillRect = 35*2
=72						GCMD_FrameCircle = 36*2
=74						GCMD_FillCircle = 37*2
=80						GCMD_Plot = 40*2
=82						GCMD_SpriteMove = 41*2
=42						GRFirstFreeCode = 42
.c33f	a33f					GRVectorTable:
>c33f	a33f	8e a5					.word	GXInitialise             ; $00 Initialise
>c341	a341	a8 a5					.word	GXControlBitmap          ; $01 BitmapCtl
>c343	a343	f0 a5					.word	GXControlSprite          ; $02 SpriteCtl
>c345	a345	40 a5					.word	GXClearBitmap            ; $03 Clear
>c347	a347	7f a7					.word	GXSetColourMode          ; $04 Colour
>c349	a349	47 a9					.word	GXFontHandler            ; $05 DrawFont
>c34b	a34b	8f a9					.word	GXSpriteHandler          ; $06 DrawSprite
>c34d	a34d	00 aa					.word	GXSelect                 ; $07 SpriteUse
>c34f	a34f	29 aa					.word	GXSelectImage            ; $08 SpriteImage
>c351	a351	b0 ab					.word	GXCollide                ; $09 SpriteCollide
>c353	a353	f2 a3					.word	GRUndefined              ; $0a
>c355	a355	f2 a3					.word	GRUndefined              ; $0b
>c357	a357	f2 a3					.word	GRUndefined              ; $0c
>c359	a359	f2 a3					.word	GRUndefined              ; $0d
>c35b	a35b	f2 a3					.word	GRUndefined              ; $0e
>c35d	a35d	f2 a3					.word	GRUndefined              ; $0f
>c35f	a35f	f2 a3					.word	GRUndefined              ; $10
>c361	a361	f2 a3					.word	GRUndefined              ; $11
>c363	a363	f2 a3					.word	GRUndefined              ; $12
>c365	a365	f2 a3					.word	GRUndefined              ; $13
>c367	a367	f2 a3					.word	GRUndefined              ; $14
>c369	a369	f2 a3					.word	GRUndefined              ; $15
>c36b	a36b	f2 a3					.word	GRUndefined              ; $16
>c36d	a36d	f2 a3					.word	GRUndefined              ; $17
>c36f	a36f	f2 a3					.word	GRUndefined              ; $18
>c371	a371	f2 a3					.word	GRUndefined              ; $19
>c373	a373	f2 a3					.word	GRUndefined              ; $1a
>c375	a375	f2 a3					.word	GRUndefined              ; $1b
>c377	a377	f2 a3					.word	GRUndefined              ; $1c
>c379	a379	f2 a3					.word	GRUndefined              ; $1d
>c37b	a37b	f2 a3					.word	GRUndefined              ; $1e
>c37d	a37d	f2 a3					.word	GRUndefined              ; $1f
>c37f	a37f	f0 a3					.word	GXMove                   ; $20 Move
>c381	a381	4d a6					.word	GXLine                   ; $21 Line
>c383	a383	c8 a7					.word	GXFrameRectangle         ; $22 FrameRect
>c385	a385	c5 a7					.word	GXFillRectangle          ; $23 FillRect
>c387	a387	f7 a3					.word	GXFrameCircle            ; $24 FrameCircle
>c389	a389	f3 a3					.word	GXFillCircle             ; $25 FillCircle
>c38b	a38b	f2 a3					.word	GRUndefined              ; $26
>c38d	a38d	f2 a3					.word	GRUndefined              ; $27
>c38f	a38f	ad a7					.word	GXPlotPoint              ; $28 Plot
>c391	a391	bf aa					.word	GXMoveSprite             ; $29 SpriteMove
=3						GXMappingPage = 3
=24576						GXMappingAddress = ($2000 * GXMappingPage)
=11						GXEditSlot = 8 + GXMappingPage
=$36						gxzTemp0 = zTemp0
=$38						gxzTemp1 = zTemp1
=$3a						gxzTemp2 = zTemp2
=$3c						gxzScreen = zsTemp
=$627						gxPixelBuffer = numberBuffer
.0672						gxCurrentX:
>0672								.fill 	2
.0674						gxCurrentY:
>0674								.fill 	2
.0676						gxLastX:
>0676								.fill 	2
.0678						gxLastY:
>0678								.fill 	2
.067a						gxX0:
>067a								.fill 	2
.067c						gxY0:
>067c								.fill 	2
.067e						gxX1:
>067e								.fill 	2
.0680						gxY1:
>0680								.fill 	2
.0682						gxSpritesOn:
>0682								.fill 	1
.0683						gxBitmapsOn:
>0683								.fill 	1
.0684						gxBasePage:
>0684								.fill 	1
.0685						gxSpritePage:
>0685								.fill 	1
.0686						gxHeight:
>0686								.fill 	1
.0687						gxMode:
>0687								.fill 	1
.0688						gxColour:
>0688								.fill 	1
.0689						gxEORValue:
>0689								.fill 	1
.068a						gxANDValue:
>068a								.fill 	1
.068b						gxOriginalLUTValue:
>068b								.fill 	1
.068c						gsOffset:
>068c								.fill 	1
.068d						GSCurrentSpriteID:
>068d								.fill 	1
.068e						GSCurrentSpriteAddr:
>068e								.fill 	2
.0690						GXSpriteOffsetBase:
>0690								.fill 	2
.0692						GXSpriteLow:
>0692								.fill 	64
.06d2						GXSpriteHigh:
>06d2								.fill 	64
.c393	a393					Export_GXGraphicDraw:
.c393	a393	c9 40		cmp #$40			cmp 	#GCMD_Move					; low instructions don't use coordinates
.c395	a395	b0 06		bcs $a39d			bcs 	_GDCoordinate
.c397	a397	86 36		stx $36				stx 	gxzTemp0 					; save X/Y
.c399	a399	84 37		sty $37				sty 	gxzTemp0+1
.c39b	a39b	80 4b		bra $a3e8			bra 	_GDExecuteA 				; and execute
.c39d	a39d					_GDCoordinate:
.c39d	a39d	48		pha				pha 								; save AXY
.c39e	a39e	da		phx				phx
.c39f	a39f	5a		phy				phy
.c3a0	a3a0	a2 03		ldx #$03			ldx 	#3 							; copy currentX to lastX
.c3a2	a3a2					_GDCopy1:
.c3a2	a3a2	bd 72 06	lda $0672,x			lda 	gxCurrentX,x
.c3a5	a3a5	9d 76 06	sta $0676,x			sta 	gxLastX,x
.c3a8	a3a8	ca		dex				dex
.c3a9	a3a9	10 f7		bpl $a3a2			bpl 	_GDCopy1
.c3ab	a3ab	68		pla				pla 								; update Y
.c3ac	a3ac	8d 74 06	sta $0674			sta 	gxCurrentY
.c3af	a3af	9c 75 06	stz $0675			stz 	gxCurrentY+1
.c3b2	a3b2	68		pla				pla
.c3b3	a3b3	8d 72 06	sta $0672			sta 	gxCurrentX
.c3b6	a3b6	68		pla				pla 								; get A (command+X.1) back
.c3b7	a3b7	48		pha				pha
.c3b8	a3b8	29 01		and #$01			and 	#1 							; put LSB as MSB of Current.X
.c3ba	a3ba	8d 73 06	sta $0673			sta 	gxCurrentX+1
.c3bd	a3bd	68		pla				pla 								; get command back
.c3be	a3be	29 fe		and #$fe			and 	#$FE 						; lose LSB, chuck the stray X bit
.c3c0	a3c0	48		pha				pha 								; push back.
.c3c1	a3c1	c9 52		cmp #$52			cmp 	#GCMD_SpriteMove 			; move sprite does not clip.
.c3c3	a3c3	f0 17		beq $a3dc			beq 	_GDCopyToWorkArea
.c3c5	a3c5	ad 73 06	lda $0673			lda 	gxCurrentX+1 				; X < 256 X okay
.c3c8	a3c8	f0 07		beq $a3d1			beq 	_GDCheckY
.c3ca	a3ca	ad 72 06	lda $0672			lda 	gxCurrentX 					; otherwise X < 320 = 256 + 64
.c3cd	a3cd	c9 40		cmp #$40			cmp 	#64
.c3cf	a3cf	b0 08		bcs $a3d9			bcs 	_GDError1
.c3d1	a3d1					_GDCheckY:
.c3d1	a3d1	ad 74 06	lda $0674			lda 	gxCurrentY 					; check Y < Height.
.c3d4	a3d4	cd 86 06	cmp $0686			cmp 	gxHeight
.c3d7	a3d7	90 03		bcc $a3dc			bcc 	_GDCopyToWorkArea
.c3d9	a3d9					_GDError1:
.c3d9	a3d9	68		pla				pla
.c3da	a3da					_GDError2:
.c3da	a3da	38		sec				sec
.c3db	a3db	60		rts				rts
.c3dc	a3dc					_GDCopyToWorkArea:
.c3dc	a3dc	a2 07		ldx #$07			ldx 	#7 							; copy current and last to gxXY/12 work area
.c3de	a3de					_GDCopy2:
.c3de	a3de	bd 72 06	lda $0672,x			lda 	gxCurrentX,x
.c3e1	a3e1	9d 7a 06	sta $067a,x			sta 	gxX0,x
.c3e4	a3e4	ca		dex				dex
.c3e5	a3e5	10 f7		bpl $a3de			bpl 	_GDCopy2
.c3e7	a3e7	68		pla				pla 								; get command
.c3e8	a3e8					_GDExecuteA:
.c3e8	a3e8	c9 54		cmp #$54			cmp 	#GRFirstFreeCode*2 			; bad ?
.c3ea	a3ea	b0 ee		bcs $a3da			bcs 	_GDError2
.c3ec	a3ec	aa		tax				tax
.c3ed	a3ed	7c 3f a3	jmp ($a33f,x)			jmp 	(GRVectorTable,x)
.c3f0	a3f0					GXMove:
.c3f0	a3f0	18		clc				clc
.c3f1	a3f1	60		rts				rts
.c3f2	a3f2					GRUndefined:
>c3f2	a3f2	db						.byte 	$DB 						; causes a break in the emulator
.c3f3	a3f3					GXFillCircle:
.c3f3	a3f3	a9 ff		lda #$ff			lda 	#255
.c3f5	a3f5	80 02		bra $a3f9			bra 	GXCircle
.c3f7	a3f7					GXFrameCircle:
.c3f7	a3f7	a9 00		lda #$00			lda 	#0
.c3f9	a3f9					GXCircle:
.c3f9	a3f9	8d 15 07	sta $0715			sta 	gxIsFillMode					; save Fill flag
.c3fc	a3fc	ad 83 06	lda $0683			lda 	gxBitmapsOn
.c3ff	a3ff	f0 26		beq $a427			beq 	_GXCFail
.c401	a401	20 57 ac	jsr $ac57			jsr 	GXSortXY 					; topleft/bottomright
.c404	a404	20 2f ab	jsr $ab2f			jsr 	GXOpenBitmap 				; start drawing
.c407	a407	20 f9 a4	jsr $a4f9			jsr 	GXCircleSetup 				; set up for drawing
.c40a	a40a	9c 16 07	stz $0716			stz 	gxYChanged
.c40d	a40d					_GXCircleDraw:
.c40d	a40d	ad 13 07	lda $0713			lda 	gXCentre					; while x <= y
.c410	a410	cd 14 07	cmp $0714			cmp 	gYCentre
.c413	a413	90 0a		bcc $a41f			bcc 	_GXCircleContinue
.c415	a415	d0 03		bne $a41a			bne 	_GXNoLast
.c417	a417	20 2c a4	jsr $a42c			jsr 	GXPlot1
.c41a	a41a					_GXNoLast:
.c41a	a41a	20 37 ab	jsr $ab37			jsr 	GXCloseBitmap 				; close the bitmap
.c41d	a41d	18		clc				clc
.c41e	a41e	60		rts				rts
.c41f	a41f					_GXCircleContinue:
.c41f	a41f	20 29 a4	jsr $a429			jsr 	GXPlot2 					; draw it
.c422	a422	20 a6 a4	jsr $a4a6			jsr 	GXCircleMove 				; adjust the coordinates
.c425	a425	80 e6		bra $a40d			bra 	_GXCircleDraw
.c427	a427					_GXCFail:
.c427	a427	38		sec				sec
.c428	a428	60		rts				rts
.c429	a429					GXPlot2:
.c429	a429	20 2c a4	jsr $a42c			jsr 	GXPlot1 						; plot and swap, fall through does twice
.c42c	a42c					GXPlot1:
.c42c	a42c	ad 14 07	lda $0714			lda 	gYCentre 						; if y = 0, don't do it twice (xor)
.c42f	a42f	f0 03		beq $a434			beq 	_GXPlot1Only
.c431	a431	20 50 a4	jsr $a450			jsr 	GXPlot0 						; plot and negate
.c434	a434					_GXPlot1Only:
.c434	a434	20 50 a4	jsr $a450			jsr 	GXPlot0 						; twice, undoing negation
.c437	a437	ad 13 07	lda $0713			lda 	gXCentre 						; swap X and Y
.c43a	a43a	ae 14 07	ldx $0714			ldx	 	gYCentre
.c43d	a43d	8d 14 07	sta $0714			sta 	gYCentre
.c440	a440	8e 13 07	stx $0713			stx 	gXCentre
.c443	a443	ad 16 07	lda $0716			lda 	gxYChanged 						; toggle Y Changed flag
.c446	a446	a9 ff		lda #$ff			lda 	#$FF
.c448	a448	8d 16 07	sta $0716			sta 	gxYChanged
.c44b	a44b	60		rts				rts
.c44c	a44c	20 50 a4	jsr $a450			jsr 	GXPlot0 						; do once
.c44f	a44f	60		rts				rts
.c450	a450	ad 15 07	lda $0715	GXPlot0:lda 	gxIsFillMode 					; outline mode, always draw as X or Y will change
.c453	a453	f0 05		beq $a45a			beq 	_GXPlot0Always
.c455	a455	ad 16 07	lda $0716			lda 	gxYChanged						; fill mode, only draw if changed.
.c458	a458	f0 2d		beq $a487			beq 	GXPlot0Exit
.c45a	a45a					_GXPlot0Always:
.c45a	a45a	a2 02		ldx #$02			ldx 	#2 								; copy Y1-A => Y0
.c45c	a45c	ad 14 07	lda $0714			lda 	gYCentre
.c45f	a45f	20 88 a4	jsr $a488			jsr 	GXSubCopy
.c462	a462	a2 00		ldx #$00			ldx 	#0 								; copy X1-A => X0,
.c464	a464	ad 13 07	lda $0713			lda 	gXCentre
.c467	a467	20 88 a4	jsr $a488			jsr 	GXSubCopy
.c46a	a46a	48		pha				pha 									; save last offset X
.c46b	a46b	20 3f ab	jsr $ab3f			jsr 	GXPositionCalc 					; calculate position/offset.
.c46e	a46e	68		pla				pla
.c46f	a46f	0a		asl a				asl 	a 								; store 2 x last offset in gxzTemp0
.c470	a470	85 36		sta $36				sta 	gxzTemp0
.c472	a472	64 37		stz $37				stz 	gxzTemp0+1
.c474	a474	26 37		rol $37				rol 	gxzTemp0+1
.c476	a476	ad 15 07	lda $0715			lda 	gxIsFillMode
.c479	a479	69 80		adc #$80			adc 	#128
.c47b	a47b	20 18 a8	jsr $a818			jsr 	GXDrawLineTemp0 				; routine from Rectangle.
.c47e	a47e	38		sec				sec 									; GY = -GY
.c47f	a47f	a9 00		lda #$00			lda 	#0
.c481	a481	ed 14 07	sbc $0714			sbc 	gYCentre
.c484	a484	8d 14 07	sta $0714			sta 	gYCentre
.c487	a487					GXPlot0Exit:
.c487	a487	60		rts				rts
.c488	a488					GXSubCopy:
.c488	a488	85 36		sta $36				sta 	gxzTemp0
.c48a	a48a	64 37		stz $37				stz 	gxzTemp0+1
.c48c	a48c	29 80		and #$80			and 	#$80
.c48e	a48e	f0 02		beq $a492			beq 	_GXNoSx
.c490	a490	c6 37		dec $37				dec 	gxzTemp0+1
.c492	a492					_GXNoSx:
.c492	a492	38		sec				sec
.c493	a493	bd 7e 06	lda $067e,x			lda 	gXX1,x
.c496	a496	e5 36		sbc $36				sbc 	gxzTemp0
.c498	a498	9d 7a 06	sta $067a,x			sta 	gXX0,x
.c49b	a49b	bd 7f 06	lda $067f,x			lda 	gXX1+1,x
.c49e	a49e	e5 37		sbc $37				sbc 	gxzTemp0+1
.c4a0	a4a0	9d 7b 06	sta $067b,x			sta 	gXX0+1,x
.c4a3	a4a3	a5 36		lda $36				lda 	gxzTemp0 						; return A
.c4a5	a4a5	60		rts				rts
.c4a6	a4a6					GXCircleMove:
.c4a6	a4a6	9c 16 07	stz $0716			stz 	gxYChanged 					; clear Y changed flag
.c4a9	a4a9	a5 39		lda $39				lda 	gxzTemp1+1 					; check sign of D
.c4ab	a4ab	10 0d		bpl $a4ba			bpl 	_GXEMPositive
.c4ad	a4ad	ee 13 07	inc $0713			inc 	gXCentre 					; X++
.c4b0	a4b0	ad 13 07	lda $0713			lda 	gXCentre
.c4b3	a4b3	20 d9 a4	jsr $a4d9			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.c4b6	a4b6	a9 06		lda #$06			lda 	#6  						; and add 6
.c4b8	a4b8	80 15		bra $a4cf			bra 	_GXEMAddD
.c4ba	a4ba					_GXEMPositive:
.c4ba	a4ba	ee 13 07	inc $0713			inc 	gXCentre					; X++
.c4bd	a4bd	ce 14 07	dec $0714			dec 	gyCentre 					; Y--
.c4c0	a4c0	38		sec				sec 								; calculate X-Y
.c4c1	a4c1	ad 13 07	lda $0713			lda 	gXCentre
.c4c4	a4c4	ed 14 07	sbc $0714			sbc 	gYCentre
.c4c7	a4c7	20 d9 a4	jsr $a4d9			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.c4ca	a4ca	a9 0a		lda #$0a			lda 	#10  						; and add 10
.c4cc	a4cc	ce 16 07	dec $0716			dec 	gxYChanged
.c4cf	a4cf					_GXEMAddD:
.c4cf	a4cf	18		clc				clc
.c4d0	a4d0	65 38		adc $38				adc 	gxzTemp1
.c4d2	a4d2	85 38		sta $38				sta 	gxzTemp1
.c4d4	a4d4	90 02		bcc $a4d8			bcc 	_GXEMNoCarry
.c4d6	a4d6	e6 39		inc $39				inc 	gxzTemp1+1
.c4d8	a4d8					_GXEMNoCarry:
.c4d8	a4d8	60		rts				rts
.c4d9	a4d9					_GXAdd4TimesToD:
.c4d9	a4d9	85 36		sta $36				sta 	gxzTemp0 					; make 16 bit signed.
.c4db	a4db	29 80		and #$80			and 	#$80
.c4dd	a4dd	f0 02		beq $a4e1			beq 	_GXA4Unsigned
.c4df	a4df	a9 ff		lda #$ff			lda 	#$FF
.c4e1	a4e1					_GXA4Unsigned:
.c4e1	a4e1	85 37		sta $37				sta 	gxzTemp0+1
.c4e3	a4e3	06 36		asl $36				asl 	gxzTemp0  					; x 4
.c4e5	a4e5	26 37		rol $37				rol 	gxzTemp0+1
.c4e7	a4e7	06 36		asl $36				asl 	gxzTemp0
.c4e9	a4e9	26 37		rol $37				rol 	gxzTemp0+1
.c4eb	a4eb	18		clc				clc 								; add
.c4ec	a4ec	a5 36		lda $36				lda		gxzTemp0
.c4ee	a4ee	65 38		adc $38				adc 	gxzTemp1
.c4f0	a4f0	85 38		sta $38				sta 	gxzTemp1
.c4f2	a4f2	a5 37		lda $37				lda		gxzTemp0+1
.c4f4	a4f4	65 39		adc $39				adc 	gxzTemp1+1
.c4f6	a4f6	85 39		sta $39				sta 	gxzTemp1+1
.c4f8	a4f8	60		rts				rts
.c4f9	a4f9					GXCircleSetup:
.c4f9	a4f9	38		sec				sec
.c4fa	a4fa	ad 80 06	lda $0680			lda 	gxY1
.c4fd	a4fd	ed 7c 06	sbc $067c			sbc 	gxY0
.c500	a500	4a		lsr a				lsr 	a
.c501	a501	8d 12 07	sta $0712			sta 	gxRadius
.c504	a504	a2 00		ldx #$00			ldx 	#0
.c506	a506	20 28 a5	jsr $a528			jsr 	_GXCalculateCentre
.c509	a509	a2 02		ldx #$02			ldx 	#2
.c50b	a50b	20 28 a5	jsr $a528			jsr 	_GXCalculateCentre
.c50e	a50e	9c 13 07	stz $0713			stz 	gXCentre
.c511	a511	ad 12 07	lda $0712			lda 	gxRadius
.c514	a514	8d 14 07	sta $0714			sta 	gYCentre
.c517	a517	0a		asl a				asl 	a 							; R x 2
.c518	a518	85 36		sta $36				sta 	gxzTemp0
.c51a	a51a	38		sec				sec
.c51b	a51b	a9 03		lda #$03			lda 	#3
.c51d	a51d	e5 36		sbc $36				sbc 	gxzTemp0
.c51f	a51f	85 38		sta $38				sta 	gxzTemp1
.c521	a521	a9 00		lda #$00			lda 	#0
.c523	a523	e9 00		sbc #$00			sbc 	#0
.c525	a525	85 39		sta $39				sta 	gxzTemp1+1
.c527	a527	60		rts				rts
.c528	a528					_GXCalculateCentre:
.c528	a528	38		sec				sec
.c529	a529	bd 7e 06	lda $067e,x			lda 	gxX1,x
.c52c	a52c	7d 7a 06	adc $067a,x			adc 	gXX0,x
.c52f	a52f	9d 7e 06	sta $067e,x			sta 	gXX1,x
.c532	a532	bd 7f 06	lda $067f,x			lda 	gXX1+1,x
.c535	a535	7d 7b 06	adc $067b,x			adc 	gXX0+1,x
.c538	a538	4a		lsr a				lsr 	a
.c539	a539	9d 7f 06	sta $067f,x			sta 	gXX1+1,x
.c53c	a53c	7e 7e 06	ror $067e,x			ror 	gXX1,x
.c53f	a53f	60		rts				rts
.0712						gxRadius:
>0712								.fill 	1
.0713						gXCentre:
>0713								.fill 	1
.0714						gYCentre:
>0714								.fill 	1
.0715						gxIsFillMode:
>0715								.fill 	1
.0716						gxYChanged:
>0716								.fill  	1
=64000						ScreenSize200 = 320 * 200
=76800						ScreenSize240 = 320 * 240
.c540	a540					GXClearBitmap:
.c540	a540	ad 83 06	lda $0683			lda 	gxBitmapsOn 				; check BMP running.
.c543	a543	f0 24		beq $a569			beq 	_GXCBFail
.c545	a545	20 2f ab	jsr $ab2f			jsr 	GXOpenBitmap 				; start access
.c548	a548	a0 07		ldy #$07			ldy 	#ScreenSize200 / 8192 		; X is pages to clear
.c54a	a54a	ad 86 06	lda $0686			lda 	gxHeight
.c54d	a54d	c9 c8		cmp #$c8			cmp 	#200 						; 200 ?
.c54f	a54f	a0 09		ldy #$09			ldy 	#ScreenSize240 / 8192
.c551	a551					_GXCalcLastPage:
.c551	a551	98		tya				tya 								; add to base page
.c552	a552	18		clc				clc
.c553	a553	6d 84 06	adc $0684			adc 	gxBasePage
.c556	a556	85 0b		sta $0b				sta 	GXEditSlot  				; clear from this page back
.c558	a558					_GXClearAll:
.c558	a558	20 6b a5	jsr $a56b			jsr 	_GXClearBlock 				; clear 8k block
.c55b	a55b	c6 0b		dec $0b				dec 	GXEditSlot  				; back to previous
.c55d	a55d	a5 0b		lda $0b				lda 	GXEditSlot
.c55f	a55f	cd 84 06	cmp $0684			cmp 	gxBasePage 					; until before base page
.c562	a562	b0 f4		bcs $a558			bcs 	_GXClearAll
.c564	a564	20 37 ab	jsr $ab37			jsr 	GXCloseBitmap	 			; stop access
.c567	a567	18		clc				clc
.c568	a568	60		rts				rts
.c569	a569					_GXCBFail:
.c569	a569	38		sec				sec
.c56a	a56a	60		rts				rts
.c56b	a56b					_GXClearBlock:
.c56b	a56b	a9 00		lda #$00			lda 	#((GXMappingAddress) & $FF)
.c56d	a56d	85 38		sta $38				sta 	0+gxzTemp1
.c56f	a56f	a9 60		lda #$60			lda 	#((GXMappingAddress) >> 8)
.c571	a571	85 39		sta $39				sta 	1+gxzTemp1
.c573	a573					_GXCB0:
.c573	a573	a5 36		lda $36				lda 	gxzTemp0
.c575	a575	a0 00		ldy #$00			ldy 	#0
.c577	a577					_GXCB1:
.c577	a577	91 38		sta ($38),y			sta 	(gxzTemp1),y
.c579	a579	c8		iny				iny
.c57a	a57a	91 38		sta ($38),y			sta 	(gxzTemp1),y
.c57c	a57c	c8		iny				iny
.c57d	a57d	91 38		sta ($38),y			sta 	(gxzTemp1),y
.c57f	a57f	c8		iny				iny
.c580	a580	91 38		sta ($38),y			sta 	(gxzTemp1),y
.c582	a582	c8		iny				iny
.c583	a583	d0 f2		bne $a577			bne 	_GXCB1
.c585	a585	e6 39		inc $39				inc 	gxzTemp1+1
.c587	a587	a5 39		lda $39				lda 	gxzTemp1+1
.c589	a589	c9 80		cmp #$80			cmp	 	#(GXMappingAddress >> 8)+$20
.c58b	a58b	d0 e6		bne $a573			bne 	_GXCB0
.c58d	a58d	60		rts				rts
.c58e	a58e					GXInitialise:
.c58e	a58e	64 01		stz $01				stz 	1
.c590	a590	a9 01		lda #$01			lda 	#1
.c592	a592	8d 00 d0	sta $d000			sta 	$D000
.c595	a595	18		clc				clc
.c596	a596	9c 82 06	stz $0682			stz 	GXSpritesOn
.c599	a599	9c 83 06	stz $0683			stz 	GXBitmapsOn
.c59c	a59c	a2 0f		ldx #$0f			ldx 	#15
.c59e	a59e					_GXIClear:
.c59e	a59e	9e 72 06	stz $0672,x			stz 	gxCurrentX,x
.c5a1	a5a1	ca		dex				dex
.c5a2	a5a2	10 fa		bpl $a59e			bpl 	_GXIClear
.c5a4	a5a4	20 3f a6	jsr $a63f			jsr 	GXClearSpriteStore
.c5a7	a5a7	60		rts				rts
.c5a8	a5a8					GXControlBitmap:
.c5a8	a5a8	64 01		stz $01				stz 	1
.c5aa	a5aa	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.c5ac	a5ac	29 01		and #$01			and 	#1 							; set bitmap flag
.c5ae	a5ae	8d 83 06	sta $0683			sta 	gxBitmapsOn
.c5b1	a5b1	4a		lsr a				lsr 	a 							; bit 0 into carry.
.c5b2	a5b2	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.c5b5	a5b5	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.c5b7	a5b7	29 f7		and #$f7			and 	#$F7 						; clear bitmap bit
.c5b9	a5b9	90 02		bcc $a5bd			bcc 	_CBNotOn
.c5bb	a5bb	09 08		ora #$08			ora 	#$08 						; bitmap on if 1 on 0 off
.c5bd	a5bd					_CBNotOn:
.c5bd	a5bd	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.c5c0	a5c0	a5 36		lda $36				lda 	gxzTemp0 					; get control settings (bits 0-2)
.c5c2	a5c2	29 07		and #$07			and 	#7
.c5c4	a5c4	8d 00 d1	sta $d100			sta 	$D100 						; write in Vicky Bitmap Control Register #0
.c5c7	a5c7	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.c5c9	a5c9	d0 02		bne $a5cd			bne 	_CBNotDefault
.c5cb	a5cb	a9 08		lda #$08			lda 	#8  						; if zero, use 8 e.g. bitmap at $10000
.c5cd	a5cd					_CBNotDefault:
.c5cd	a5cd	8d 84 06	sta $0684			sta 	gxBasePage
.c5d0	a5d0	20 31 a6	jsr $a631			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.c5d3	a5d3	a5 37		lda $37				lda 	gxzTemp0+1 					; copy address into Bitmap address registers
.c5d5	a5d5	8d 03 d1	sta $d103			sta 	$D103
.c5d8	a5d8	a5 36		lda $36				lda 	gxzTemp0
.c5da	a5da	8d 02 d1	sta $d102			sta 	$D102
.c5dd	a5dd	9c 01 d1	stz $d101			stz 	$D101
.c5e0	a5e0	a2 f0		ldx #$f0			ldx 	#240 						; height is 240
.c5e2	a5e2	ad 01 d0	lda $d001			lda 	$D001 						; read MCR bit 0
.c5e5	a5e5	29 01		and #$01			and 	#1
.c5e7	a5e7	f0 02		beq $a5eb			beq 	_CBHaveHeight
.c5e9	a5e9	a2 c8		ldx #$c8			ldx 	#200 						; if bit 0 set 320x200
.c5eb	a5eb					_CBHaveHeight
.c5eb	a5eb	8e 86 06	stx $0686			stx 	gxHeight
.c5ee	a5ee	18		clc				clc
.c5ef	a5ef	60		rts				rts
.c5f0	a5f0					GXControlSprite:
.c5f0	a5f0	64 01		stz $01				stz 	1
.c5f2	a5f2	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.c5f4	a5f4	29 01		and #$01			and 	#1 							; set sprites flag
.c5f6	a5f6	8d 82 06	sta $0682			sta 	gxSpritesOn
.c5f9	a5f9	4a		lsr a				lsr 	a 							; bit 0 into carry.
.c5fa	a5fa	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.c5fd	a5fd	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.c5ff	a5ff	29 df		and #$df			and 	#$DF 						; clear sprite bit
.c601	a601	90 02		bcc $a605			bcc 	_CSNotOn
.c603	a603	09 20		ora #$20			ora 	#$20 						; sprite on if 1 on 0 off
.c605	a605					_CSNotOn:
.c605	a605	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.c608	a608	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.c60a	a60a	d0 02		bne $a60e			bne 	_CSNotDefault
.c60c	a60c	a9 18		lda #$18			lda 	#24  						; if zero, use 24 e.g. sprites at $30000
.c60e	a60e					_CSNotDefault:
.c60e	a60e	8d 85 06	sta $0685			sta 	gxSpritePage
.c611	a611	20 31 a6	jsr $a631			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.c614	a614	a5 36		lda $36				lda 	zTemp0
.c616	a616	8d 90 06	sta $0690			sta 	GXSpriteOffsetBase
.c619	a619	a5 37		lda $37				lda 	zTemp0+1
.c61b	a61b	8d 91 06	sta $0691			sta 	GXSpriteOffsetBase+1
.c61e	a61e	a2 00		ldx #$00			ldx 	#0 							; disable all sprites, clears all sprite memory.
.c620	a620					_CSClear:
.c620	a620	9e 00 d9	stz $d900,x			stz 	$D900,x
.c623	a623	9e 00 da	stz $da00,x			stz 	$DA00,x
.c626	a626	ca		dex				dex
.c627	a627	d0 f7		bne $a620			bne 	_CSClear
.c629	a629	9c 8f 06	stz $068f			stz 	GSCurrentSpriteAddr+1 		; no sprite selected.
.c62c	a62c	20 3f a6	jsr $a63f			jsr 	GXClearSpriteStore
.c62f	a62f	18		clc				clc
.c630	a630	60		rts				rts
.c631	a631					GXCalculateBaseAddress:
.c631	a631	85 36		sta $36				sta 	gxzTemp0
.c633	a633	64 37		stz $37				stz 	gxzTemp0+1
.c635	a635	a9 05		lda #$05			lda 	#5
.c637	a637					_GXShift:
.c637	a637	06 36		asl $36				asl 	gxzTemp0
.c639	a639	26 37		rol $37				rol 	gxzTemp0+1
.c63b	a63b	3a		dec a				dec		a
.c63c	a63c	d0 f9		bne $a637			bne 	_GXShift
.c63e	a63e	60		rts				rts
.c63f	a63f					GXClearSpriteStore:
.c63f	a63f	a2 3f		ldx #$3f			ldx 	#63 						; erase 64 sprite store elements
.c641	a641					_GXCSSLoop:
.c641	a641	9e d2 06	stz $06d2,x			stz 	GXSpriteHigh,x
.c644	a644	a9 80		lda #$80			lda 	#$80 						; set the 'hidden' bit.
.c646	a646	9d 92 06	sta $0692,x			sta 	GXSpriteLow,x
.c649	a649	ca		dex				dex
.c64a	a64a	10 f5		bpl $a641			bpl 	_GXCSSLoop
.c64c	a64c	60		rts				rts
.c64d	a64d					GXLine:
.c64d	a64d	ad 83 06	lda $0683			lda 	GXBitmapsOn
.c650	a650	f0 28		beq $a67a			beq 	_GXLFail
.c652	a652	20 2f ab	jsr $ab2f			jsr 	GXOpenBitmap
.c655	a655	20 75 ac	jsr $ac75			jsr 	GXSortY						; sort pairs so Y1 >= Y0 e.g. top to bottom.
.c658	a658	20 20 a7	jsr $a720			jsr 	GXLineSetup 				; the calculations in the linescanner constructor
.c65b	a65b	20 3f ab	jsr $ab3f			jsr 	GXPositionCalc 				; calculate position/offset.
.c65e	a65e					_GXDrawLoop:
.c65e	a65e	ac 8c 06	ldy $068c			ldy 	gsOffset 					; draw the pixel
.c661	a661	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.c663	a663	2d 8a 06	and $068a			and 	gxANDValue
.c666	a666	4d 89 06	eor $0689			eor 	gxEORValue
.c669	a669	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.c66b	a66b	20 7c a6	jsr $a67c			jsr 	GXLineIsComplete 			; is the line complete ?
.c66e	a66e	f0 05		beq $a675			beq 	_GXLExit
.c670	a670	20 97 a6	jsr $a697			jsr 	GXLineAdvance 				; code as per advance method
.c673	a673	80 e9		bra $a65e			bra 	_GXDrawLoop
.c675	a675					_GXLExit:
.c675	a675	20 37 ab	jsr $ab37			jsr 	GXCloseBitmap
.c678	a678	18		clc				clc
.c679	a679	60		rts				rts
.c67a	a67a					_GXLFail:
.c67a	a67a	38		sec				sec
.c67b	a67b	60		rts				rts
.c67c	a67c					GXLineIsComplete:
.c67c	a67c	ad 19 07	lda $0719			lda 	GXIsDiffYLarger 			; is dy larger
.c67f	a67f	d0 0f		bne $a690			bne 	_GXLICCompareY 				; if so compare Y1/Y0
.c681	a681	ad 7a 06	lda $067a			lda 	GXX0 						; compare X, LSB and MSB
.c684	a684	4d 7e 06	eor $067e			eor 	GXX1
.c687	a687	d0 06		bne $a68f			bne 	_GXLICExit
.c689	a689	ad 7b 06	lda $067b			lda 	GXX0+1
.c68c	a68c	4d 7f 06	eor $067f			eor 	GXX1+1
.c68f	a68f					_GXLICExit:
.c68f	a68f	60		rts				rts
.c690	a690					_GXLICCompareY:
.c690	a690	ad 80 06	lda $0680			lda 	GXY1
.c693	a693	4d 7c 06	eor $067c			eor 	GXY0
.c696	a696	60		rts				rts
.c697	a697					GXLineAdvance:
.c697	a697	18		clc				clc 								; add adjust to position
.c698	a698	ad 1b 07	lda $071b			lda 	GXPosition
.c69b	a69b	6d 1c 07	adc $071c			adc 	GXAdjust
.c69e	a69e	8d 1b 07	sta $071b			sta 	GXPosition
.c6a1	a6a1	9c 1e 07	stz $071e			stz 	GXAddSelect 				; clear add select flag
.c6a4	a6a4	b0 05		bcs $a6ab			bcs 	_GXLAOverflow 				; if carry out, overflowed.
.c6a6	a6a6	cd 1d 07	cmp $071d			cmp 	GXTotal 					; if exceeded total
.c6a9	a6a9	90 0a		bcc $a6b5			bcc 	_GXLANoExtra
.c6ab	a6ab					_GXLAOverflow:
.c6ab	a6ab	ce 1e 07	dec $071e			dec 	GXAddSelect 				; set addselect to $FF
.c6ae	a6ae	38		sec				sec 								; subtract total and write back
.c6af	a6af	ed 1d 07	sbc $071d			sbc 	GXTotal
.c6b2	a6b2	8d 1b 07	sta $071b			sta 	GXPosition
.c6b5	a6b5					_GXLANoExtra:
.c6b5	a6b5	ad 19 07	lda $0719			lda 	GXIsDiffYLarger
.c6b8	a6b8	f0 0d		beq $a6c7			beq 	_GXDXLarger
.c6ba	a6ba	20 19 a7	jsr $a719			jsr 	GXIncrementY
.c6bd	a6bd	ad 1e 07	lda $071e			lda 	GXAddSelect
.c6c0	a6c0	f0 10		beq $a6d2			beq 	_GXLAExit
.c6c2	a6c2	20 d3 a6	jsr $a6d3			jsr 	GXAdjustX
.c6c5	a6c5	80 0b		bra $a6d2			bra 	_GXLAExit
.c6c7	a6c7					_GXDXLarger:
.c6c7	a6c7	20 d3 a6	jsr $a6d3			jsr 	GXAdjustX
.c6ca	a6ca	ad 1e 07	lda $071e			lda 	GXAddSelect
.c6cd	a6cd	f0 03		beq $a6d2			beq 	_GXLAExit
.c6cf	a6cf	20 19 a7	jsr $a719			jsr 	GXIncrementY
.c6d2	a6d2					_GXLAExit:
.c6d2	a6d2	60		rts				rts
.c6d3	a6d3					GXAdjustX:
.c6d3	a6d3	ad 1a 07	lda $071a			lda 	GXDXNegative
.c6d6	a6d6	10 25		bpl $a6fd			bpl 	_GXAXRight
.c6d8	a6d8	ad 7a 06	lda $067a			lda 	GXX0
.c6db	a6db	d0 03		bne $a6e0			bne 	_GXAXNoBorrow
.c6dd	a6dd	ce 7b 06	dec $067b			dec 	GXX0+1
.c6e0	a6e0					_GXAXNoBorrow:
.c6e0	a6e0	ce 7a 06	dec $067a			dec 	GXX0
.c6e3	a6e3	ce 8c 06	dec $068c			dec 	gsOffset 					; pixel left
.c6e6	a6e6	ad 8c 06	lda $068c			lda 	gsOffset
.c6e9	a6e9	c9 ff		cmp #$ff			cmp 	#$FF
.c6eb	a6eb	d0 0f		bne $a6fc			bne 	_GXAYExit 					; underflow
.c6ed	a6ed	c6 3d		dec $3d				dec 	gxzScreen+1 					; borrow
.c6ef	a6ef	a5 3d		lda $3d				lda 	gxzScreen+1 					; gone off page
.c6f1	a6f1	c9 60		cmp #$60			cmp 	#GXMappingAddress >> 8
.c6f3	a6f3	b0 07		bcs $a6fc			bcs 	_GXAYExit
.c6f5	a6f5	18		clc				clc
.c6f6	a6f6	69 20		adc #$20			adc 	#$20 						; fix up
.c6f8	a6f8	85 3d		sta $3d				sta 	gxzScreen+1
.c6fa	a6fa	c6 0b		dec $0b				dec 	GXEditSlot 				; back one page
.c6fc	a6fc					_GXAYExit:
.c6fc	a6fc	60		rts				rts
.c6fd	a6fd					_GXAXRight:
.c6fd	a6fd	ee 7a 06	inc $067a			inc 	GXX0
.c700	a700	d0 03		bne $a705			bne 	_GXAXNoCarry
.c702	a702	ee 7b 06	inc $067b			inc 	GXX0+1
.c705	a705					_GXAXNoCarry:
.c705	a705	ee 8c 06	inc $068c			inc 	gsOffset 					; pixel right
.c708	a708	d0 0e		bne $a718			bne 	_GXAXExit 					; if not overflowed, exit.
.c70a	a70a	e6 3d		inc $3d				inc 	gxzScreen+1 					; next line
.c70c	a70c	a5 3d		lda $3d				lda 	gxzScreen+1
.c70e	a70e	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.c710	a710	90 06		bcc $a718			bcc 	_GXAXExit
.c712	a712	e9 20		sbc #$20			sbc 	#$20 						; fix up
.c714	a714	85 3d		sta $3d				sta 	gxzScreen+1
.c716	a716	e6 0b		inc $0b				inc 	GXEditSlot 				; next page
.c718	a718					_GXAXExit:
.c718	a718	60		rts				rts
.c719	a719					GXIncrementY:
.c719	a719	ee 7c 06	inc $067c			inc 	GXY0
.c71c	a71c	20 95 ab	jsr $ab95			jsr 	GXMovePositionDown
.c71f	a71f	60		rts				rts
.c720	a720					GXLineSetup:
.c720	a720	ad 80 06	lda $0680			lda 	GXY1
.c723	a723	38		sec				sec
.c724	a724	ed 7c 06	sbc $067c			sbc 	GXY0
.c727	a727	4a		lsr a				lsr 	a
.c728	a728	8d 18 07	sta $0718			sta 	GXDiffY
.c72b	a72b	9c 1a 07	stz $071a			stz 	GXDXNegative 				; clear -ve flag
.c72e	a72e	38		sec				sec
.c72f	a72f	ad 7e 06	lda $067e			lda 	GXX1
.c732	a732	ed 7a 06	sbc $067a			sbc 	GXX0
.c735	a735	8d 17 07	sta $0717			sta 	GXDiffX
.c738	a738	ad 7f 06	lda $067f			lda 	GXX1+1 						; calculate MSB
.c73b	a73b	ed 7b 06	sbc $067b			sbc 	GXX0+1
.c73e	a73e	6a		ror a				ror 	a 							; rotate bit into DiffX halving it
.c73f	a73f	6e 17 07	ror $0717			ror 	GXDiffX
.c742	a742	0a		asl a				asl 	a
.c743	a743	10 0c		bpl $a751			bpl 	_GDXNotNegative
.c745	a745	a9 00		lda #$00			lda 	#0 							; make absolute value of |dx|
.c747	a747	38		sec				sec
.c748	a748	ed 17 07	sbc $0717			sbc 	GXDiffX
.c74b	a74b	8d 17 07	sta $0717			sta 	GXDiffX
.c74e	a74e	ce 1a 07	dec $071a			dec 	GXDXNegative 				; -ve flag = $FF.
.c751	a751					_GDXNotNegative:
.c751	a751	9c 19 07	stz $0719			stz 	GXIsDiffYLarger 			; clear larger flag
.c754	a754	ad 18 07	lda $0718			lda 	GXDiffY 					; set adjust and total.
.c757	a757	8d 1c 07	sta $071c			sta 	GXAdjust
.c75a	a75a	ad 17 07	lda $0717			lda 	GXDiffX
.c75d	a75d	8d 1d 07	sta $071d			sta 	GXTotal
.c760	a760	ad 18 07	lda $0718			lda 	GXDiffY 					; if dy > dx
.c763	a763	cd 17 07	cmp $0717			cmp 	GXDiffX
.c766	a766	90 0f		bcc $a777			bcc 	_GDXNotLarger
.c768	a768	ce 19 07	dec $0719			dec 	GXIsDiffYLarger 			; set the dy larger flag
.c76b	a76b	ad 17 07	lda $0717			lda 	GXDiffX 					; set adjust and total other way round
.c76e	a76e	8d 1c 07	sta $071c			sta 	GXAdjust
.c771	a771	ad 18 07	lda $0718			lda 	GXDiffY
.c774	a774	8d 1d 07	sta $071d			sta 	GXTotal
.c777	a777					_GDXNotLarger:
.c777	a777	ad 1d 07	lda $071d			lda 	GXTotal
.c77a	a77a	4a		lsr a				lsr 	a
.c77b	a77b	8d 1b 07	sta $071b			sta 	GXPosition
.c77e	a77e	60		rts				rts
.0717						GXDiffX:
>0717								.fill 	1
.0718						GXDiffY:
>0718								.fill 	1
.0719						GXIsDiffYLarger:
>0719								.fill 	1
.071a						GXDXNegative:
>071a								.fill 	1
.071b						GXPosition:
>071b								.fill 	1
.071c						GXAdjust:
>071c								.fill 	1
.071d						GXTotal:
>071d								.fill 	1
.071e						GXAddSelect:
>071e								.fill 	1
.c77f	a77f					GXSetColourMode:
.c77f	a77f	a6 36		ldx $36				ldx 	gxzTemp0
.c781	a781	8e 88 06	stx $0688			stx 	gxColour 								; set colour
.c784	a784	a5 37		lda $37				lda 	gxzTemp0+1 								;
.c786	a786	8d 87 06	sta $0687			sta 	gxMode 									; set mode
.c789	a789	29 03		and #$03			and 	#3 										; only interested in bits 0-3
.c78b	a78b	9c 8a 06	stz $068a			stz 	gxANDValue 								; initially AND with 0, and EOR with Colour
.c78e	a78e	ae 88 06	ldx $0688			ldx 	gxColour
.c791	a791	8e 89 06	stx $0689			stx 	gxEORValue
.c794	a794	c9 02		cmp #$02			cmp 	#2 										; if mode 2/3 And with colour
.c796	a796	90 03		bcc $a79b			bcc 	_GXSDCNotAndColour
.c798	a798	8e 8a 06	stx $068a			stx 	gxANDValue
.c79b	a79b					_GXSDCNotAndColour:
.c79b	a79b	d0 03		bne $a7a0			bne 	_GXSDCNotAnd 							; mode 2, Don't EOR with colour
.c79d	a79d	9c 89 06	stz $0689			stz 	gxEORValue
.c7a0	a7a0					_GXSDCNotAnd:
.c7a0	a7a0	4a		lsr a				lsr 	a 										; if bit 0 set, 1's complement AND value
.c7a1	a7a1	90 08		bcc $a7ab			bcc 	_GXSDCNoFlip
.c7a3	a7a3	ad 8a 06	lda $068a			lda	 	gxANDValue
.c7a6	a7a6	49 ff		eor #$ff			eor 	#$FF
.c7a8	a7a8	8d 8a 06	sta $068a			sta 	gxANDValue
.c7ab	a7ab					_GXSDCNoFlip:
.c7ab	a7ab	18		clc				clc
.c7ac	a7ac	60		rts				rts
.c7ad	a7ad					GXPlotPoint:
.c7ad	a7ad	20 2f ab	jsr $ab2f			jsr 	GXOpenBitmap 				; start drawing
.c7b0	a7b0	20 3f ab	jsr $ab3f			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.c7b3	a7b3	ac 8c 06	ldy $068c			ldy 	gsOffset
.c7b6	a7b6	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.c7b8	a7b8	2d 8a 06	and $068a			and 	gxANDValue
.c7bb	a7bb	4d 89 06	eor $0689			eor 	gxEORValue
.c7be	a7be	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.c7c0	a7c0	20 37 ab	jsr $ab37			jsr 	GXCloseBitmap 				; stop drawing and exit
.c7c3	a7c3	18		clc				clc
.c7c4	a7c4	60		rts				rts
.c7c5	a7c5					GXFillRectangle:
.c7c5	a7c5	38		sec				sec
.c7c6	a7c6	80 01		bra $a7c9			bra 	GXRectangle
.c7c8	a7c8					GXFrameRectangle:
.c7c8	a7c8	18		clc				clc
.c7c9	a7c9					GXRectangle:
.c7c9	a7c9	ad 83 06	lda $0683			lda 	gxBitmapsOn
.c7cc	a7cc	f0 35		beq $a803			beq 	_GXRFail
.c7ce	a7ce	08		php				php 								; save Fill flag (CS)
.c7cf	a7cf	20 2f ab	jsr $ab2f			jsr 	GXOpenBitmap 				; start drawing
.c7d2	a7d2	20 57 ac	jsr $ac57			jsr 	GXSortXY 					; sort both X and Y so top left/bottom right
.c7d5	a7d5	20 3f ab	jsr $ab3f			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.c7d8	a7d8	38		sec				sec 								; sec = Draw line
.c7d9	a7d9	20 05 a8	jsr $a805			jsr 	GXDrawLineX1X0 				; draw a line length X1-X0
.c7dc	a7dc	ad 7c 06	lda $067c			lda 	gxY0 						; reached end of rectangle ?
.c7df	a7df	cd 80 06	cmp $0680			cmp 	gxY1
.c7e2	a7e2	f0 19		beq $a7fd			beq 	_GXRectangleExit
.c7e4	a7e4					_GXRectLoop:
.c7e4	a7e4	20 95 ab	jsr $ab95			jsr 	GXMovePositionDown 			; down one.
.c7e7	a7e7	ee 7c 06	inc $067c			inc 	gxY0 						; change Y pos
.c7ea	a7ea	ad 7c 06	lda $067c			lda 	gxY0 						; reached last line
.c7ed	a7ed	cd 80 06	cmp $0680			cmp 	gXY1
.c7f0	a7f0	f0 07		beq $a7f9			beq 	_GXLastLine
.c7f2	a7f2	28		plp				plp 								; get flag back
.c7f3	a7f3	08		php				php
.c7f4	a7f4	20 05 a8	jsr $a805			jsr 	GXDrawLineX1X0 				; draw horizontal line
.c7f7	a7f7	80 eb		bra $a7e4			bra 	_GXRectLoop
.c7f9	a7f9					_GXLastLine:
.c7f9	a7f9	38		sec				sec
.c7fa	a7fa	20 05 a8	jsr $a805			jsr 	GXDrawLineX1X0
.c7fd	a7fd					_GXRectangleExit:
.c7fd	a7fd	68		pla				pla 								; throw fill flag.
.c7fe	a7fe	20 37 ab	jsr $ab37			jsr 	GXCloseBitmap 				; stop drawing and exit
.c801	a801	18		clc				clc
.c802	a802	60		rts				rts
.c803	a803					_GXRFail:
.c803	a803	38		sec				sec
.c804	a804	60		rts				rts
.c805	a805					GXDrawLineX1X0:
.c805	a805	08		php				php 								; save solid/either-end
.c806	a806	38		sec				sec
.c807	a807	ad 7e 06	lda $067e			lda		gXX1
.c80a	a80a	ed 7a 06	sbc $067a			sbc 	gXX0
.c80d	a80d	85 36		sta $36				sta 	gxzTemp0
.c80f	a80f	ad 7f 06	lda $067f			lda 	gXX1+1
.c812	a812	ed 7b 06	sbc $067b			sbc 	gXX0+1
.c815	a815	85 37		sta $37				sta 	gxzTemp0+1
.c817	a817	28		plp				plp
.c818	a818					GXDrawLineTemp0:
.c818	a818	a5 3c		lda $3c				lda 	gxzScreen 						; push gxzScreen, gsOffset and GXEditSlot on stack
.c81a	a81a	48		pha				pha
.c81b	a81b	a5 3d		lda $3d				lda 	gxzScreen+1
.c81d	a81d	48		pha				pha
.c81e	a81e	ad 8c 06	lda $068c			lda 	gsOffset
.c821	a821	48		pha				pha
.c822	a822	a5 0b		lda $0b				lda 	GXEditSlot
.c824	a824	48		pha				pha
.c825	a825	ac 8c 06	ldy $068c			ldy 	gsOffset 					; Y offset
.c828	a828	90 1e		bcc $a848			bcc 	_GXDLTEndPoints 			; if CC draw end points only.
.c82a	a82a					_GXDLTLine:
.c82a	a82a	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.c82c	a82c	2d 8a 06	and $068a			and 	gxANDValue
.c82f	a82f	4d 89 06	eor $0689			eor 	gxEORValue
.c832	a832	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.c834	a834	a5 36		lda $36				lda 	gxzTemp0 					; decrement counter
.c836	a836	d0 04		bne $a83c			bne 	_GXDLTNoBorrow
.c838	a838	c6 37		dec $37				dec 	gxzTemp0+1 					; borrow, if goes -ve then exit
.c83a	a83a	30 2e		bmi $a86a			bmi 	_GXDLTExit
.c83c	a83c					_GXDLTNoBorrow:
.c83c	a83c	c6 36		dec $36				dec 	gxzTemp0
.c83e	a83e	c8		iny				iny 								; next slot.
.c83f	a83f	d0 e9		bne $a82a			bne 	_GXDLTLine
.c841	a841	e6 3d		inc $3d				inc 	gxzScreen+1 					; carry to next
.c843	a843	20 78 a8	jsr $a878			jsr 	GXDLTCheckWrap				; check for new page.
.c846	a846	80 e2		bra $a82a			bra 	_GXDLTLine
.c848	a848					_GXDLTEndPoints:
.c848	a848	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.c84a	a84a	2d 8a 06	and $068a			and 	gxANDValue
.c84d	a84d	4d 89 06	eor $0689			eor 	gxEORValue
.c850	a850	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.c852	a852	98		tya				tya 								; advance to right side
.c853	a853	18		clc				clc
.c854	a854	65 36		adc $36				adc 	gxzTemp0
.c856	a856	a8		tay				tay
.c857	a857	a5 3d		lda $3d				lda 	gxzScreen+1
.c859	a859	65 37		adc $37				adc 	gxzTemp0+1
.c85b	a85b	85 3d		sta $3d				sta 	gxzScreen+1
.c85d	a85d	20 78 a8	jsr $a878			jsr 	GXDLTCheckWrap 			; fix up.
.c860	a860	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.c862	a862	2d 8a 06	and $068a			and 	gxANDValue
.c865	a865	4d 89 06	eor $0689			eor 	gxEORValue
.c868	a868	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.c86a	a86a					_GXDLTExit:
.c86a	a86a	68		pla				pla
.c86b	a86b	85 0b		sta $0b				sta 	GXEditSlot
.c86d	a86d	68		pla				pla
.c86e	a86e	8d 8c 06	sta $068c			sta 	gsOffset
.c871	a871	68		pla				pla
.c872	a872	85 3d		sta $3d				sta 	gxzScreen+1
.c874	a874	68		pla				pla
.c875	a875	85 3c		sta $3c				sta 	gxzScreen
.c877	a877	60		rts				rts
.c878	a878					GXDLTCheckWrap:
.c878	a878	a5 3d		lda $3d				lda 	gxzScreen+1 					; check end of page
.c87a	a87a	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8)
.c87c	a87c	90 06		bcc $a884			bcc 	_GXDLTCWExit
.c87e	a87e	e9 20		sbc #$20			sbc 	#$20 						; fix up
.c880	a880	85 3d		sta $3d				sta 	gxzScreen+1
.c882	a882	e6 0b		inc $0b				inc 	GXEditSlot
.c884	a884					_GXDLTCWExit:
.c884	a884	60		rts				rts
.c885	a885					GXDrawGraphicElement:
.c885	a885	8d 1f 07	sta $071f			sta 	gxSize 						; save size
.c888	a888	3a		dec a				dec 	a
.c889	a889	8d 20 07	sta $0720			sta 	gxMask 						; and mask
.c88c	a88c	ad 83 06	lda $0683			lda 	gxBitmapsOn 				; check BMP on
.c88f	a88f	f0 67		beq $a8f8			beq 	_GXSLFail
.c891	a891	ad 7c 06	lda $067c			lda 	gxY0 						; push Y on stack
.c894	a894	48		pha				pha
.c895	a895	8c 22 07	sty $0722			sty 	gxAcquireVector+1 			; and acquisition vector
.c898	a898	8e 21 07	stx $0721			stx 	gxAcquireVector
.c89b	a89b	20 2f ab	jsr $ab2f			jsr 	gxOpenBitmap 				; open the bitmap.
.c89e	a89e	ad 24 07	lda $0724			lda 	gxUseMode 					; scale bits
.c8a1	a8a1	4a		lsr a				lsr 	a
.c8a2	a8a2	4a		lsr a				lsr 	a
.c8a3	a8a3	4a		lsr a				lsr 	a
.c8a4	a8a4	29 07		and #$07			and		#7
.c8a6	a8a6	1a		inc a				inc 	a
.c8a7	a8a7	8d 23 07	sta $0723			sta 	gxScale
.c8aa	a8aa	64 38		stz $38				stz 	gxzTemp1					; start first line
.c8ac	a8ac					_GXGELoop:
.c8ac	a8ac	a5 38		lda $38				lda 	gxzTemp1 					; current line number to read.
.c8ae	a8ae	2c 24 07	bit $0724			bit 	gxUseMode 					; check for flip.
.c8b1	a8b1	10 06		bpl $a8b9			bpl		_GXNoVFlip
.c8b3	a8b3	ad 20 07	lda $0720			lda 	gxMask
.c8b6	a8b6	38		sec				sec
.c8b7	a8b7	e5 38		sbc $38				sbc 	gxzTemp1
.c8b9	a8b9					_GXNoVFlip:
.c8b9	a8b9	aa		tax				tax 								; get the Xth line.
.c8ba	a8ba	20 fa a8	jsr $a8fa			jsr 	_GXCallAcquire 				; get that data.
.c8bd	a8bd	ad 23 07	lda $0723			lda 	gxScale 					; do scale identical copies of that line.
.c8c0	a8c0	85 39		sta $39				sta 	gxzTemp1+1
.c8c2	a8c2					_GXGELoop2:
.c8c2	a8c2	ad 7c 06	lda $067c			lda 	gxY0 						; off screen
.c8c5	a8c5	cd 86 06	cmp $0686			cmp 	gxHeight
.c8c8	a8c8	b0 10		bcs $a8da			bcs 	_GXDGEExit
.c8ca	a8ca	20 fd a8	jsr $a8fd			jsr 	GXRenderOneLine 			; render line
.c8cd	a8cd	c6 39		dec $39				dec 	gxzTemp1+1 					; scale times.
.c8cf	a8cf	d0 f1		bne $a8c2			bne 	_GXGELoop2
.c8d1	a8d1	e6 38		inc $38				inc 	gxzTemp1 					; done all lines.
.c8d3	a8d3	a5 38		lda $38				lda 	gxzTemp1
.c8d5	a8d5	cd 1f 07	cmp $071f			cmp 	gxSize
.c8d8	a8d8	d0 d2		bne $a8ac			bne 	_GXGELoop
.c8da	a8da					_GXDGEExit:
.c8da	a8da	68		pla				pla 								; restore Y for next time
.c8db	a8db	8d 7c 06	sta $067c			sta 	gxY0
.c8de	a8de	ae 23 07	ldx $0723			ldx 	gxScale 					; get scale (1-8)
.c8e1	a8e1					_GXShiftLeft:
.c8e1	a8e1	18		clc				clc
.c8e2	a8e2	ad 1f 07	lda $071f			lda 	gxSize
.c8e5	a8e5	6d 7a 06	adc $067a			adc 	gxX0
.c8e8	a8e8	8d 7a 06	sta $067a			sta 	gxX0
.c8eb	a8eb	90 03		bcc $a8f0			bcc 	_GXSLNoCarry
.c8ed	a8ed	ee 7b 06	inc $067b			inc 	gxX0+1
.c8f0	a8f0					_GXSLNoCarry:
.c8f0	a8f0	ca		dex				dex
.c8f1	a8f1	d0 ee		bne $a8e1			bne 	_GXShiftLeft
.c8f3	a8f3	20 37 ab	jsr $ab37			jsr 	GXCloseBitmap
.c8f6	a8f6	18		clc				clc
.c8f7	a8f7	60		rts				rts
.c8f8	a8f8					_GXSLFail:
.c8f8	a8f8	38		sec				sec
.c8f9	a8f9	60		rts				rts
.c8fa	a8fa					_GXCallAcquire:
.c8fa	a8fa	6c 21 07	jmp ($0721)			jmp 	(gxAcquireVector)
.c8fd	a8fd					GXRenderOneLine:
.c8fd	a8fd	20 3f ab	jsr $ab3f			jsr 	GXPositionCalc 				; calculate position/offset.
.c900	a900	ac 8c 06	ldy $068c			ldy 	gsOffset 					; Y contains position.
.c903	a903	64 3a		stz $3a				stz 	gxzTemp2 					; do size pixels
.c905	a905					_GXROLLoop1:
.c905	a905	ad 23 07	lda $0723			lda 	gxScale 					; set to do 'scale' times
.c908	a908	85 3b		sta $3b				sta 	gxzTemp2+1
.c90a	a90a					_GXROLLoop2:
.c90a	a90a	a5 3a		lda $3a				lda 	gxzTemp2 					; get current pixel
.c90c	a90c	2c 87 06	bit $0687			bit 	gxMode 						; check H Flip
.c90f	a90f	50 06		bvc $a917			bvc 	_GXNoHFlip
.c911	a911	ad 20 07	lda $0720			lda 	gxMask
.c914	a914	38		sec				sec
.c915	a915	e5 3a		sbc $3a				sbc 	gxzTemp2
.c917	a917					_GXNoHFlip:
.c917	a917	aa		tax				tax 								; read from the pixel buffer
.c918	a918	bd 27 06	lda $0627,x			lda 	gxPixelBuffer,x
.c91b	a91b	d0 07		bne $a924			bne 	_GXDraw 					; draw if non zero
.c91d	a91d	ad 24 07	lda $0724			lda 	gxUseMode 					; check to see if solid background
.c920	a920	29 04		and #$04			and 	#4
.c922	a922	f0 0a		beq $a92e			beq 	_GXZeroPixel
.c924	a924					_GXDraw:
.c924	a924	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.c926	a926	2d 8a 06	and $068a			and 	gxANDValue
.c929	a929	5d 27 06	eor $0627,x			eor 	gxPixelBuffer,x
.c92c	a92c	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.c92e	a92e					_GXZeroPixel:
.c92e	a92e	c8		iny				iny 								; advance pointer
.c92f	a92f	d0 05		bne $a936			bne 	_GXNoShift
.c931	a931	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.c933	a933	20 78 a8	jsr $a878			jsr 	GXDLTCheckWrap				; check for new page.
.c936	a936					_GXNoShift:
.c936	a936	c6 3b		dec $3b				dec 	gxzTemp2+1 					; do the inner loop gxScale times.
.c938	a938	d0 d0		bne $a90a			bne 	_GXROLLoop2
.c93a	a93a	e6 3a		inc $3a				inc 	gxzTemp2 					; next pixel.
.c93c	a93c	a5 3a		lda $3a				lda 	gxzTemp2
.c93e	a93e	cd 1f 07	cmp $071f			cmp 	gxSize
.c941	a941	d0 c2		bne $a905			bne 	_GXROLLoop1
.c943	a943	ee 7c 06	inc $067c			inc 	gxY0
.c946	a946	60		rts				rts
.071f						gxSize:
>071f								.fill 	1
.0720						gxMask:
>0720								.fill 	1
.0721						gxAcquireVector:
>0721								.fill 	2
.0723						gxScale:
>0723								.fill 	1
.0724						gxUseMode:
>0724								.fill 	1
.c947	a947					GXFontHandler:
.c947	a947	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.c949	a949	4d 87 06	eor $0687			eor 	gxMode
.c94c	a94c	8d 24 07	sta $0724			sta 	gxUseMode
.c94f	a94f	64 37		stz $37				stz 	gxzTemp0+1 					; gxzTemp0 is font #
.c951	a951	06 36		asl $36				asl	 	gxzTemp0 					; x 2
.c953	a953	26 37		rol $37				rol	 	gxzTemp0+1
.c955	a955	06 36		asl $36				asl	 	gxzTemp0 					; x 4
.c957	a957	26 37		rol $37				rol	 	gxzTemp0+1
.c959	a959	06 36		asl $36				asl	 	gxzTemp0 					; x 8
.c95b	a95b	26 37		rol $37				rol	 	gxzTemp0+1
.c95d	a95d	a5 37		lda $37				lda 	gxzTemp0+1 					; put in page C0
.c95f	a95f	09 c0		ora #$c0			ora 	#$C0
.c961	a961	85 37		sta $37				sta 	gxzTemp0+1
.c963	a963	a9 08		lda #$08			lda 	#8 							; size 8x8
.c965	a965	a2 6d		ldx #$6d			ldx 	#GXGetGraphicDataFont & $FF ; XY = Graphic Data retrieval routine
.c967	a967	a0 a9		ldy #$a9			ldy 	#GXGetGraphicDataFont >> 8
.c969	a969	20 85 a8	jsr $a885			jsr 	GXDrawGraphicElement
.c96c	a96c	60		rts				rts
.c96d	a96d					GXGetGraphicDataFont:
.c96d	a96d	8a		txa				txa 								; X->Y
.c96e	a96e	a8		tay				tay
.c96f	a96f	a6 01		ldx $01				ldx 	1 							; preserve old value
.c971	a971	a9 01		lda #$01			lda 	#1 							; access page 1 (font memory)
.c973	a973	85 01		sta $01				sta 	1
.c975	a975	b1 36		lda ($36),y			lda 	(gxzTemp0),y 				; read the font element.
.c977	a977	86 01		stx $01				stx 	1 							; put old value back.
.c979	a979	a2 00		ldx #$00			ldx 	#0 							; do 8 times
.c97b	a97b					_GXExpand:
.c97b	a97b	9e 27 06	stz $0627,x			stz 	gxPixelBuffer,x 			; zero in pixel buffer
.c97e	a97e	0a		asl a				asl 	a 							; shift bit 7 into C
.c97f	a97f	90 08		bcc $a989			bcc 	_GXNoPixel
.c981	a981	48		pha				pha 								; if set, set pixel buffer to current colour.
.c982	a982	ad 88 06	lda $0688			lda 	gxColour
.c985	a985	9d 27 06	sta $0627,x			sta 	gxPixelBuffer,x
.c988	a988	68		pla				pla
.c989	a989					_GXNoPixel:
.c989	a989	e8		inx				inx 								; do the whole byte.
.c98a	a98a	e0 08		cpx #$08			cpx 	#8
.c98c	a98c	d0 ed		bne $a97b			bne 	_GXExpand
.c98e	a98e	60		rts				rts
.c98f	a98f					GXSpriteHandler:
.c98f	a98f	ad 82 06	lda $0682			lda 	gxSpritesOn 				; sprites on ?
.c992	a992	f0 23		beq $a9b7			beq 	_GXSHExit
.c994	a994	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.c996	a996	4d 87 06	eor $0687			eor 	gxMode
.c999	a999	8d 24 07	sta $0724			sta 	gxUseMode
.c99c	a99c	a6 36		ldx $36				ldx 	gxzTemp0 					; sprite #
.c99e	a99e	da		phx				phx
.c99f	a99f	20 2f ab	jsr $ab2f			jsr 	GXOpenBitmap 				; can access sprite information
.c9a2	a9a2	68		pla				pla
.c9a3	a9a3	20 10 ac	jsr $ac10			jsr 	GXFindSprite 				; get the sprite address
.c9a6	a9a6	08		php				php
.c9a7	a9a7	20 37 ab	jsr $ab37			jsr 	GXCloseBitmap
.c9aa	a9aa	28		plp				plp
.c9ab	a9ab	b0 0a		bcs $a9b7			bcs		_GXSHExit 					; exit if find failed.
.c9ad	a9ad	ad 25 07	lda $0725			lda 	GXSizePixels 				; return size
.c9b0	a9b0	a2 b8		ldx #$b8			ldx 	#GXSpriteAcquire & $FF
.c9b2	a9b2	a0 a9		ldy #$a9			ldy 	#GXSpriteAcquire >> 8
.c9b4	a9b4	20 85 a8	jsr $a885			jsr 	GXDrawGraphicElement
.c9b7	a9b7					_GXSHExit:
.c9b7	a9b7	60		rts				rts
.c9b8	a9b8					GXSpriteAcquire:
.c9b8	a9b8	ad 85 06	lda $0685			lda 	GXSpritePage				; point to base page
.c9bb	a9bb	85 0b		sta $0b				sta 	GXEditSlot
.c9bd	a9bd	86 36		stx $36				stx 	zTemp0 						; row number x 1,2,3,4
.c9bf	a9bf	a9 00		lda #$00			lda 	#0
.c9c1	a9c1	ae 26 07	ldx $0726			ldx 	GXSizeBits
.c9c4	a9c4					_GXTimesRowNumber:
.c9c4	a9c4	18		clc				clc
.c9c5	a9c5	65 36		adc $36				adc 	zTemp0
.c9c7	a9c7	ca		dex				dex
.c9c8	a9c8	10 fa		bpl $a9c4			bpl 	_GXTimesRowNumber
.c9ca	a9ca	64 37		stz $37				stz 	gxzTemp0+1
.c9cc	a9cc	0a		asl a				asl 	a 							; row x 2,4,6,8
.c9cd	a9cd	26 37		rol $37				rol 	gxzTemp0+1
.c9cf	a9cf	0a		asl a				asl 	a 							; row x 4,8,12,16
.c9d0	a9d0	26 37		rol $37				rol 	gxzTemp0+1
.c9d2	a9d2	0a		asl a				asl 	a 							; row x 8,16,24,32
.c9d3	a9d3	26 37		rol $37				rol 	gxzTemp0+1
.c9d5	a9d5	85 36		sta $36				sta 	gxzTemp0
.c9d7	a9d7	18		clc				clc 								; add base address.
.c9d8	a9d8	a5 36		lda $36				lda 	gxzTemp0
.c9da	a9da	6d 28 07	adc $0728			adc 	GXSpriteOffset
.c9dd	a9dd	85 36		sta $36				sta 	gxzTemp0
.c9df	a9df	a5 37		lda $37				lda 	gxzTemp0+1
.c9e1	a9e1	6d 29 07	adc $0729			adc 	GXSpriteOffset+1
.c9e4	a9e4					_GXSAFindPage:
.c9e4	a9e4	c9 20		cmp #$20			cmp 	#$20 						; on this page
.c9e6	a9e6	90 06		bcc $a9ee			bcc 	_GXSAFoundPage
.c9e8	a9e8	e9 20		sbc #$20			sbc 	#$20 						; forward one page
.c9ea	a9ea	e6 0b		inc $0b				inc 	GXEditSlot
.c9ec	a9ec	80 f6		bra $a9e4			bra 	_GXSAFindPage
.c9ee	a9ee					_GXSAFoundPage:
.c9ee	a9ee	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; physical address of page.
.c9f0	a9f0	85 37		sta $37				sta 	gxzTemp0+1 					; gxzTemp0 now points to the page
.c9f2	a9f2	a0 00		ldy #$00			ldy 	#0
.c9f4	a9f4					_GXSACopyLoop:
.c9f4	a9f4	b1 36		lda ($36),y			lda 	(gxzTemp0),y
.c9f6	a9f6	99 27 06	sta $0627,y			sta 	gxPixelBuffer,y
.c9f9	a9f9	c8		iny				iny
.c9fa	a9fa	cc 25 07	cpy $0725			cpy 	GXSizePixels
.c9fd	a9fd	d0 f5		bne $a9f4			bne 	_GXSACopyLoop
.c9ff	a9ff	60		rts				rts
.ca00	aa00					GXSelect:
.ca00	aa00	ad 82 06	lda $0682			lda 	gxSpritesOn
.ca03	aa03	f0 22		beq $aa27			beq 	_GXSFail
.ca05	aa05	a5 36		lda $36				lda 	gxzTemp0 					; illegal sprite #
.ca07	aa07	c9 40		cmp #$40			cmp 	#64
.ca09	aa09	b0 1c		bcs $aa27			bcs 	_GXSFail
.ca0b	aa0b	8d 8d 06	sta $068d			sta 	GSCurrentSpriteID
.ca0e	aa0e	a4 37		ldy $37				ldy 	gxzTemp0+1 					; control value.
.ca10	aa10	a9 00		lda #$00			lda  	#0 							; multiply sprite # x 8 => A
.ca12	aa12	06 36		asl $36				asl 	gxzTemp0
.ca14	aa14	06 36		asl $36				asl 	gxzTemp0
.ca16	aa16	06 36		asl $36				asl 	gxzTemp0
.ca18	aa18	2a		rol a				rol 	a
.ca19	aa19	69 d9		adc #$d9			adc 	#$D9 						; sprite area
.ca1b	aa1b	8d 8f 06	sta $068f			sta 	GSCurrentSpriteAddr+1 		; address to GSCurrentSprite and gxzTemp
.ca1e	aa1e	85 37		sta $37				sta 	gxzTemp0+1
.ca20	aa20	a5 36		lda $36				lda 	gxzTemp0
.ca22	aa22	8d 8e 06	sta $068e			sta 	GSCurrentSpriteAddr
.ca25	aa25	18		clc				clc
.ca26	aa26	60		rts				rts
.ca27	aa27					_GXSFail:
.ca27	aa27	38		sec				sec
.ca28	aa28	60		rts				rts
.ca29	aa29					GXSelectImage:
.ca29	aa29	ad 82 06	lda $0682			lda 	gxSpritesOn
.ca2c	aa2c	f0 74		beq $aaa2			beq 	_GXSIFail
.ca2e	aa2e	ad 8f 06	lda $068f			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.ca31	aa31	f0 6f		beq $aaa2			beq 	_GXSIFail 					; (checking the MSB)
.ca33	aa33	64 01		stz $01				stz 	1
.ca35	aa35	a5 37		lda $37				lda 	gxzTemp0+1 					; push show/hide on the stack.
.ca37	aa37	d0 6b		bne $aaa4			bne 	_GXSIHide
.ca39	aa39	a5 36		lda $36				lda 	gxzTemp0 					; sprite image
.ca3b	aa3b	48		pha				pha
.ca3c	aa3c	20 2f ab	jsr $ab2f			jsr 	GXOpenBitmap
.ca3f	aa3f	68		pla				pla
.ca40	aa40	20 10 ac	jsr $ac10			jsr 	GXFindSprite
.ca43	aa43	b0 5a		bcs $aa9f			bcs 	_GXSICloseFail 				; no image
.ca45	aa45	a0 01		ldy #$01			ldy 	#1
.ca47	aa47	ad 8e 06	lda $068e			lda 	GSCurrentSpriteAddr
.ca4a	aa4a	85 36		sta $36				sta 	gxzTemp0
.ca4c	aa4c	ad 8f 06	lda $068f			lda 	GSCurrentSpriteAddr+1
.ca4f	aa4f	85 37		sta $37				sta 	gxzTemp0+1
.ca51	aa51	ad 28 07	lda $0728			lda 	GXSpriteOffset
.ca54	aa54	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.ca56	aa56	18		clc				clc
.ca57	aa57	ad 29 07	lda $0729			lda 	GXSpriteOffset+1
.ca5a	aa5a	6d 90 06	adc $0690			adc 	GXSpriteOffsetBase
.ca5d	aa5d	c8		iny				iny
.ca5e	aa5e	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.ca60	aa60	ad 91 06	lda $0691			lda 	GXSpriteOffsetBase+1
.ca63	aa63	69 00		adc #$00			adc 	#0
.ca65	aa65	c8		iny				iny
.ca66	aa66	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.ca68	aa68	ad 26 07	lda $0726			lda 	GXSizeBits 					; get raw size
.ca6b	aa6b	49 03		eor #$03			eor 	#3 							; make it right (00=32 etc.)
.ca6d	aa6d	2a		rol a				rol 	a 							; x 2
.ca6e	aa6e	0a		asl a				asl 	a 							; x 4
.ca6f	aa6f	0a		asl a				asl 	a 							; x 8
.ca70	aa70	0a		asl a				asl 	a 							; x 16
.ca71	aa71	0d 27 07	ora $0727			ora 	GXSpriteLUT 				; Or with LUT
.ca74	aa74	0a		asl a				asl 	a 							; 1 shift
.ca75	aa75	09 01		ora #$01			ora 	#1 							; enable sprite.
.ca77	aa77	92 36		sta ($36)			sta 	(gxzTemp0) 					; and write back
.ca79	aa79	20 37 ab	jsr $ab37			jsr 	GXCloseBitmap
.ca7c	aa7c	ae 8d 06	ldx $068d			ldx 	GSCurrentSpriteID 			; point to sprite entries.
.ca7f	aa7f	bd d2 06	lda $06d2,x			lda 	GXSpriteHigh,x 				; clear upper two bits of size
.ca82	aa82	29 3f		and #$3f			and 	#$3F
.ca84	aa84	9d d2 06	sta $06d2,x			sta 	GXSpriteHigh,x
.ca87	aa87	ad 26 07	lda $0726			lda 	GXSizeBits 					; get bit size
.ca8a	aa8a	6a		ror a				ror 	a 							; shift into bits 6/7
.ca8b	aa8b	6a		ror a				ror 	a
.ca8c	aa8c	6a		ror a				ror 	a
.ca8d	aa8d	29 c0		and #$c0			and 	#$C0
.ca8f	aa8f	1d d2 06	ora $06d2,x			ora 	GXSpriteHigh,x 				; put in  upper 2 bits of sprite data
.ca92	aa92	9d d2 06	sta $06d2,x			sta 	GXSpriteHigh,x
.ca95	aa95	bd 92 06	lda $0692,x			lda 	GXSpriteLow,x 				; clear hidden flag.
.ca98	aa98	29 7f		and #$7f			and 	#$7F
.ca9a	aa9a	9d 92 06	sta $0692,x			sta 	GXSpriteLow,x
.ca9d	aa9d	18		clc				clc
.ca9e	aa9e	60		rts				rts
.ca9f	aa9f					_GXSICloseFail:
.ca9f	aa9f	20 37 ab	jsr $ab37			jsr 	GXCloseBitmap
.caa2	aaa2					_GXSIFail:
.caa2	aaa2	38		sec				sec
.caa3	aaa3	60		rts				rts
.caa4	aaa4					_GXSIHide:
.caa4	aaa4	ad 8e 06	lda $068e			lda 	GSCurrentSpriteAddr  		; get Sprite h/w address and write there
.caa7	aaa7	85 36		sta $36				sta 	gxzTemp0
.caa9	aaa9	ad 8f 06	lda $068f			lda 	GSCurrentSpriteAddr+1
.caac	aaac	85 37		sta $37				sta 	gxzTemp0+1
.caae	aaae	a9 00		lda #$00			lda 	#0
.cab0	aab0	92 36		sta ($36)			sta 	(gxzTemp0)
.cab2	aab2	ae 8d 06	ldx $068d			ldx 	GSCurrentSpriteID 			; get sprite ID
.cab5	aab5	bd 92 06	lda $0692,x			lda 	GXSpriteLow,x 				; set the hidden bit.
.cab8	aab8	09 80		ora #$80			ora 	#$80
.caba	aaba	9d 92 06	sta $0692,x			sta 	GXSpriteLow,x
.cabd	aabd	18		clc				clc
.cabe	aabe	60		rts				rts
.cabf	aabf					GXMoveSprite:
.cabf	aabf	ad 82 06	lda $0682			lda 	gxSpritesOn
.cac2	aac2	f0 65		beq $ab29			beq 	_GXSIFail
.cac4	aac4	ad 8f 06	lda $068f			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.cac7	aac7	f0 60		beq $ab29			beq 	_GXSIFail
.cac9	aac9	85 37		sta $37				sta 	gxzTemp0+1
.cacb	aacb	a0 04		ldy #$04			ldy 	#4
.cacd	aacd	ad 8e 06	lda $068e			lda 	GSCurrentSpriteAddr
.cad0	aad0	85 36		sta $36				sta 	gxzTemp0
.cad2	aad2	ae 8d 06	ldx $068d			ldx 	GSCurrentSpriteID 			; get the size from the upper two bits
.cad5	aad5	bd d2 06	lda $06d2,x			lda 	GXSpriteHigh,x
.cad8	aad8	2a		rol a				rol 	a	 						; into bits 0,1.
.cad9	aad9	2a		rol a				rol 	a
.cada	aada	2a		rol a				rol 	a
.cadb	aadb	29 03		and #$03			and 	#3
.cadd	aadd	aa		tax				tax
.cade	aade	bd 2b ab	lda $ab2b,x			lda 	_GXMSOffset,x 				; get 32-SpriteSize/2
.cae1	aae1	48		pha				pha
.cae2	aae2	18		clc				clc
.cae3	aae3	6d 7a 06	adc $067a			adc 	gxX0						; copy position.
.cae6	aae6	91 36		sta ($36),y			sta 	(gxzTemp0),y
.cae8	aae8	c8		iny				iny
.cae9	aae9	ad 7b 06	lda $067b			lda 	gxX0+1
.caec	aaec	69 00		adc #$00			adc 	#0
.caee	aaee	91 36		sta ($36),y			sta 	(gxzTemp0),y
.caf0	aaf0	c8		iny				iny
.caf1	aaf1	68		pla				pla
.caf2	aaf2	18		clc				clc
.caf3	aaf3	6d 7c 06	adc $067c			adc 	gxY0
.caf6	aaf6	91 36		sta ($36),y			sta 	(gxzTemp0),y
.caf8	aaf8	a9 00		lda #$00			lda 	#0
.cafa	aafa	69 00		adc #$00			adc 	#0
.cafc	aafc	c8		iny				iny
.cafd	aafd	91 36		sta ($36),y			sta 	(gxzTemp0),y
.caff	aaff	4e 7b 06	lsr $067b			lsr 	gxX0+1 						; divide X by 4
.cb02	ab02	6e 7a 06	ror $067a			ror 	gxX0
.cb05	ab05	4e 7a 06	lsr $067a			lsr 	gxX0
.cb08	ab08	4e 7c 06	lsr $067c			lsr 	gxY0 						; divide Y by 4
.cb0b	ab0b	4e 7c 06	lsr $067c			lsr 	gxY0
.cb0e	ab0e	ae 8d 06	ldx $068d			ldx 	GSCurrentSpriteID 			; copy X/4 and Y/4 into the status bytes
.cb11	ab11	bd 92 06	lda $0692,x			lda 	GXSpriteLow,x
.cb14	ab14	29 80		and #$80			and 	#$80
.cb16	ab16	0d 7a 06	ora $067a			ora 	gxX0
.cb19	ab19	9d 92 06	sta $0692,x			sta 	GXSpriteLow,x
.cb1c	ab1c	bd d2 06	lda $06d2,x			lda 	GXSpriteHigh,x
.cb1f	ab1f	29 c0		and #$c0			and 	#$C0
.cb21	ab21	0d 7c 06	ora $067c			ora 	gxY0
.cb24	ab24	9d d2 06	sta $06d2,x			sta 	GXSpriteHigh,x
.cb27	ab27	18		clc				clc
.cb28	ab28	60		rts				rts
.cb29	ab29					_GXSIFail:
.cb29	ab29	38		sec				sec
.cb2a	ab2a	60		rts				rts
.cb2b	ab2b					_GXMSOffset:
>cb2b	ab2b	1c						.byte 	32-8/2
>cb2c	ab2c	18						.byte 	32-16/2
>cb2d	ab2d	14						.byte 	32-24/2
>cb2e	ab2e	10						.byte 	32-32/2
.cb2f	ab2f					GXOpenBitmap:
.cb2f	ab2f	78		sei				sei 								; no interrupts here
.cb30	ab30	a5 0b		lda $0b				lda 	GXEditSlot 					; Save the original LUT slot value
.cb32	ab32	8d 8b 06	sta $068b			sta 	gxOriginalLUTValue
.cb35	ab35	58		cli				cli
.cb36	ab36	60		rts				rts
.cb37	ab37					GXCloseBitmap:
.cb37	ab37	78		sei				sei
.cb38	ab38	ad 8b 06	lda $068b			lda 	gxOriginalLUTValue 			; restore LUT slot value
.cb3b	ab3b	85 0b		sta $0b				sta 	GXEditSlot
.cb3d	ab3d	58		cli				cli
.cb3e	ab3e	60		rts				rts
.cb3f	ab3f					GXPositionCalc:
.cb3f	ab3f	a5 36		lda $36				lda 	gxzTemp0 					; save temp memory slot
.cb41	ab41	48		pha				pha
.cb42	ab42	ad 7c 06	lda $067c			lda 	GXY0 						; gxzScreen = Y0
.cb45	ab45	85 3c		sta $3c				sta 	gxzScreen
.cb47	ab47	64 3d		stz $3d				stz 	gxzScreen+1
.cb49	ab49	06 3c		asl $3c				asl 	gxzScreen 						; gxzScreen = Y0 * 4
.cb4b	ab4b	26 3d		rol $3d				rol 	gxzScreen+1
.cb4d	ab4d	06 3c		asl $3c				asl 	gxzScreen
.cb4f	ab4f	26 3d		rol $3d				rol 	gxzScreen+1
.cb51	ab51	18		clc				clc 								; gxzScreen = Y0 * 5, as it's still in A
.cb52	ab52	65 3c		adc $3c				adc 	gxzScreen
.cb54	ab54	85 3c		sta $3c				sta 	gxzScreen
.cb56	ab56	90 02		bcc $ab5a			bcc 	_GXPCNoCarry
.cb58	ab58	e6 3d		inc $3d				inc 	gxzScreen+1
.cb5a	ab5a					_GXPCNoCarry:
.cb5a	ab5a	06 3c		asl $3c				asl 	gxzScreen 						; now Y0 * 10. Needs to be multiplied by another
.cb5c	ab5c	26 3d		rol $3d				rol 	gxzScreen+1 					; 32. At this point the MSB contains the offset
.cb5e	ab5e	a5 3d		lda $3d				lda	 	gxzScreen+1 					; so save this in zTemp0 and zero it.
.cb60	ab60	85 36		sta $36				sta 	gxzTemp0
.cb62	ab62	64 3d		stz $3d				stz 	gxzScreen+1
.cb64	ab64	a9 05		lda #$05			lda 	#5 							; now multiply by 32, this puts this in the range 0..8191
.cb66	ab66					_GXPCMultiply32:
.cb66	ab66	06 3c		asl $3c				asl 	gxzScreen
.cb68	ab68	26 3d		rol $3d				rol 	gxzScreen+1
.cb6a	ab6a	3a		dec a				dec 	a
.cb6b	ab6b	d0 f9		bne $ab66			bne 	_GXPCMultiply32
.cb6d	ab6d	18		clc				clc
.cb6e	ab6e	ad 7a 06	lda $067a			lda 	GXX0 						; add X to this value, put the result in gsOffset, gxzScreen has to be on a page boundary
.cb71	ab71	65 3c		adc $3c				adc 	gxzScreen
.cb73	ab73	8d 8c 06	sta $068c			sta 	gsOffset
.cb76	ab76	ad 7b 06	lda $067b			lda 	GXX0+1
.cb79	ab79	65 3d		adc $3d				adc 	gxzScreen+1
.cb7b	ab7b	c9 20		cmp #$20			cmp 	#$20 						; has it overflowed into the next one ?
.cb7d	ab7d	90 04		bcc $ab83			bcc 	_GXPCNoOverflow
.cb7f	ab7f	29 1f		and #$1f			and 	#$1F 						; fix it up
.cb81	ab81	e6 36		inc $36				inc 	gxzTemp0 					; add 1 to the page number
.cb83	ab83					_GXPCNoOverflow:
.cb83	ab83	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; make it the address mapped in.
.cb85	ab85	85 3d		sta $3d				sta 	gxzScreen+1
.cb87	ab87	64 3c		stz $3c				stz 	gxzScreen
.cb89	ab89	18		clc				clc
.cb8a	ab8a	a5 36		lda $36				lda 	gxzTemp0 					; get the page number
.cb8c	ab8c	6d 84 06	adc $0684			adc 	gxBasePage 					; by adding the base page
.cb8f	ab8f	85 0b		sta $0b				sta 	GXEditSlot 				; and map it into memory.
.cb91	ab91	68		pla				pla
.cb92	ab92	85 36		sta $36				sta 	gxzTemp0
.cb94	ab94	60		rts				rts
.cb95	ab95					GXMovePositionDown:
.cb95	ab95	18		clc				clc 								; add 320 to offset/temp+1
.cb96	ab96	ad 8c 06	lda $068c			lda 	gsOffset
.cb99	ab99	69 40		adc #$40			adc 	#64
.cb9b	ab9b	8d 8c 06	sta $068c			sta 	gsOffset
.cb9e	ab9e	a5 3d		lda $3d				lda 	gxzScreen+1
.cba0	aba0	69 01		adc #$01			adc 	#1
.cba2	aba2	85 3d		sta $3d				sta 	gxzScreen+1
.cba4	aba4	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page
.cba6	aba6	90 07		bcc $abaf			bcc 	_GXMPDExit
.cba8	aba8	38		sec				sec  								; next page
.cba9	aba9	e9 20		sbc #$20			sbc 	#$20
.cbab	abab	85 3d		sta $3d				sta 	gxzScreen+1
.cbad	abad	e6 0b		inc $0b				inc 	GXEditSlot
.cbaf	abaf					_GXMPDExit:
.cbaf	abaf	60		rts				rts
.cbb0	abb0					GXCollide:
.cbb0	abb0	a5 36		lda $36				lda 	gxzTemp0 					; check if sprite numbers are legal.
.cbb2	abb2	aa		tax				tax
.cbb3	abb3	05 37		ora $37				ora 	gxzTemp0+1
.cbb5	abb5	29 c0		and #$c0			and 	#$C0
.cbb7	abb7	38		sec				sec
.cbb8	abb8	d0 53		bne $ac0d			bne 	_GXCollideFail 				; if either >= 64, fail.
.cbba	abba	a4 37		ldy $37				ldy 	gxzTemp0+1 					; at this point X is 1st sprite and Y is 2nd sprite.
.cbbc	abbc	b9 92 06	lda $0692,y			lda 	GXSpriteLow,y 				; check if either hidden bit is set
.cbbf	abbf	1d 92 06	ora $0692,x			ora 	GXSpriteLow,x
.cbc2	abc2	30 48		bmi $ac0c			bmi 	_GXOkayFail 				; if either hidden, then they cannot collide.
.cbc4	abc4	18		clc				clc 								; need to calculate sum of sizes.
.cbc5	abc5	b9 d2 06	lda $06d2,y			lda 	GXSpriteHigh,y
.cbc8	abc8	7d d2 06	adc $06d2,x			adc 	GXSpriteHigh,x 				; at this point, CS, Bit 6 and 7 contain that sum.
.cbcb	abcb	29 c0		and #$c0			and 	#$C0 					 	; mask off
.cbcd	abcd	6a		ror a				ror 	a 							; 5/6/7
.cbce	abce	4a		lsr a				lsr 	a 							; 4/5/6
.cbcf	abcf	4a		lsr a				lsr 	a 							; 3/4/5
.cbd0	abd0	4a		lsr a				lsr 	a 							; 2/3/4
.cbd1	abd1	18		clc				clc
.cbd2	abd2	69 08		adc #$08			adc 	#$08
.cbd4	abd4	4a		lsr a				lsr 	a 							; adjust because all coordinates are divided by 4 to store.
.cbd5	abd5	4a		lsr a				lsr 	a
.cbd6	abd6	85 38		sta $38				sta 	gxzTemp1 					; so the difference between the centres has to be less than this.
.cbd8	abd8	b9 d2 06	lda $06d2,y			lda 	GXSpriteHigh,y 				; calculate y1-y0
.cbdb	abdb	29 3f		and #$3f			and 	#$3F
.cbdd	abdd	85 39		sta $39				sta 	gxzTemp1+1
.cbdf	abdf	38		sec				sec
.cbe0	abe0	bd d2 06	lda $06d2,x			lda 	GXSpriteHigh,x
.cbe3	abe3	29 3f		and #$3f			and 	#$3F
.cbe5	abe5	e5 39		sbc $39				sbc 	gxzTemp1+1
.cbe7	abe7	b0 03		bcs $abec			bcs 	_GXCAbs1 					; calculate |y1-y0|
.cbe9	abe9	49 ff		eor #$ff			eor 	#$FF
.cbeb	abeb	1a		inc a				inc 	a
.cbec	abec					_GXCAbs1:
.cbec	abec	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.cbee	abee	b0 1c		bcs $ac0c			bcs 	_GXOkayFail
.cbf0	abf0	85 39		sta $39				sta 	gxzTemp1+1 					; save |y1-y0|
.cbf2	abf2	38		sec				sec 								; calculate |x1-x0|
.cbf3	abf3	b9 92 06	lda $0692,y			lda 	GXSpriteLow,y
.cbf6	abf6	fd 92 06	sbc $0692,x			sbc 	GXSpriteLow,x
.cbf9	abf9	b0 03		bcs $abfe			bcs 	_GXCAbs2
.cbfb	abfb	49 ff		eor #$ff			eor 	#$FF
.cbfd	abfd	1a		inc a				inc 	a
.cbfe	abfe					_GXCAbs2:
.cbfe	abfe	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.cc00	ac00	b0 0a		bcs $ac0c			bcs 	_GXOkayFail
.cc02	ac02	c5 39		cmp $39				cmp 	gxzTemp1+1 					; is it less than the previous one.
.cc04	ac04	90 02		bcc $ac08			bcc 	_GXCHaveLowest
.cc06	ac06	a5 39		lda $39				lda 	gxzTemp1+1 					; if not, that's the smallest difference.
.cc08	ac08					_GXCHaveLowest:
.cc08	ac08	0a		asl a				asl 	a 							; scale to allow for >> 2
.cc09	ac09	0a		asl a				asl 	a
.cc0a	ac0a	18		clc				clc
.cc0b	ac0b	60		rts				rts
.cc0c	ac0c					_GXOkayFail:
.cc0c	ac0c	18		clc				clc
.cc0d	ac0d					_GXCollideFail:
.cc0d	ac0d	a9 ff		lda #$ff			lda 	#$FF
.cc0f	ac0f	60		rts				rts
.cc10	ac10					GXFindSprite:
.cc10	ac10	aa		tax				tax
.cc11	ac11	ad 85 06	lda $0685			lda 	GXSpritePage 				; access the base page of the sprite
.cc14	ac14	85 0b		sta $0b				sta 	GXEditSlot
.cc16	ac16	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; check a valid sprite
.cc19	ac19	1d 00 60	ora $6000,x			ora 	GXMappingAddress,x
.cc1c	ac1c	f0 33		beq $ac51			beq 	_GXFSFail
.cc1e	ac1e	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; MSB
.cc21	ac21	8d 29 07	sta $0729			sta 	GXSpriteOffset+1
.cc24	ac24	bd 00 60	lda $6000,x			lda 	GXMappingAddress,x 			; LSB
.cc27	ac27	48		pha				pha 								; save twice
.cc28	ac28	48		pha				pha
.cc29	ac29	29 03		and #$03			and 	#3 							; get sprite size
.cc2b	ac2b	8d 26 07	sta $0726			sta 	GXSizeBits 					; save raw (0-3)
.cc2e	ac2e	aa		tax				tax
.cc2f	ac2f	bd 53 ac	lda $ac53,x			lda 	_GXFXSSTTable,x 			; read sprite size
.cc32	ac32	8d 25 07	sta $0725			sta 	GXSizePixels 					; save (8/16/24/32)
.cc35	ac35	68		pla				pla 								; get LUT
.cc36	ac36	4a		lsr a				lsr		a
.cc37	ac37	4a		lsr a				lsr		a
.cc38	ac38	29 03		and #$03			and 	#3
.cc3a	ac3a	8d 27 07	sta $0727			sta 	GXSpriteLUT
.cc3d	ac3d	68		pla				pla 								; address, neeeds to be x 4
.cc3e	ac3e	29 f0		and #$f0			and 	#$F0
.cc40	ac40	8d 28 07	sta $0728			sta 	GXSpriteOffset
.cc43	ac43	0e 28 07	asl $0728			asl 	GXSpriteOffset
.cc46	ac46	2e 29 07	rol $0729			rol 	GXSpriteOffset+1
.cc49	ac49	0e 28 07	asl $0728			asl 	GXSpriteOffset
.cc4c	ac4c	2e 29 07	rol $0729			rol 	GXSpriteOffset+1
.cc4f	ac4f	18		clc				clc
.cc50	ac50	60		rts				rts
.cc51	ac51					_GXFSFail:
.cc51	ac51	38		sec				sec
.cc52	ac52	60		rts				rts
.cc53	ac53					_GXFXSSTTable:
>cc53	ac53	08 10 18 20					.byte 	8,16,24,32
.0725						GXSizePixels:
>0725								.fill 	1
.0726						GXSizeBits:
>0726								.fill 	1
.0727						GXSpriteLUT:
>0727								.fill 	1
.0728						GXSpriteOffset:
>0728								.fill 	2
.cc57	ac57					GXSortXY:
.cc57	ac57	20 75 ac	jsr $ac75			jsr 	GXSortY 					; will be sorted on Y now
.cc5a	ac5a	ad 7a 06	lda $067a			lda 	gxX0 						; compare X0 v X1
.cc5d	ac5d	cd 7e 06	cmp $067e			cmp 	gxX1
.cc60	ac60	ad 7b 06	lda $067b			lda 	gXX0+1
.cc63	ac63	ed 7f 06	sbc $067f			sbc 	gXX1+1
.cc66	ac66	90 0c		bcc $ac74			bcc 	_GXSXYExit 					; X0 < X1 exit
.cc68	ac68	a2 00		ldx #$00			ldx 	#0 							; swap them over
.cc6a	ac6a	a0 04		ldy #$04			ldy 	#4
.cc6c	ac6c	20 89 ac	jsr $ac89			jsr 	GXSwapXY
.cc6f	ac6f	e8		inx				inx
.cc70	ac70	c8		iny				iny
.cc71	ac71	20 89 ac	jsr $ac89			jsr 	GXSwapXY
.cc74	ac74					_GXSXYExit:
.cc74	ac74	60		rts				rts
.cc75	ac75					GXSortY:
.cc75	ac75	ad 7c 06	lda $067c			lda 	gxY0 						; if Y0 >= Y1
.cc78	ac78	cd 80 06	cmp $0680			cmp 	gxY1
.cc7b	ac7b	90 0b		bcc $ac88			bcc 	_GXSYSorted
.cc7d	ac7d	a2 03		ldx #$03			ldx 	#3 							; swap 3-0
.cc7f	ac7f	a0 07		ldy #$07			ldy 	#7 							; with 4-7
.cc81	ac81					_GXSwap1:
.cc81	ac81	20 89 ac	jsr $ac89			jsr 	GXSwapXY
.cc84	ac84	88		dey				dey
.cc85	ac85	ca		dex				dex
.cc86	ac86	10 f9		bpl $ac81			bpl 	_GXSwap1
.cc88	ac88					_GXSYSorted:
.cc88	ac88	60		rts				rts
.cc89	ac89					GXSwapXY:
.cc89	ac89	bd 7a 06	lda $067a,x			lda 	gxX0,x
.cc8c	ac8c	48		pha				pha
.cc8d	ac8d	b9 7a 06	lda $067a,y			lda 	gxX0,y
.cc90	ac90	9d 7a 06	sta $067a,x			sta 	gxX0,x
.cc93	ac93	68		pla				pla
.cc94	ac94	99 7a 06	sta $067a,y			sta 	gxX0,y
.cc97	ac97	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_tokeniser.module

=1						tokeniserIntegrated=1
.cc98	ac98					KeywordSet0:
>cc98	ac98	00 65					.text	0,$65,""               ; $80 !0:EOF
>cc9a	ac9a	00 58					.text	0,$58,""               ; $81 !1:SH1
>cc9c	ac9c	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>cc9e	ac9e	04 fe 41 42 53 28			.text	4,$fe,"ABS("           ; $83 ABS(
>cca4	aca4	06 93 41 4c 4c 4f 43 28			.text	6,$93,"ALLOC("         ; $84 ALLOC(
>ccac	acac	04 ff 41 53 43 28			.text	4,$ff,"ASC("           ; $85 ASC(
>ccb2	acb2	05 29 43 48 52 24 28			.text	5,$29,"CHR$("          ; $86 CHR$(
>ccb9	acb9	05 41 44 45 45 4b 28			.text	5,$41,"DEEK("          ; $87 DEEK(
>ccc0	acc0	06 aa 45 56 45 4e 54 28			.text	6,$aa,"EVENT("         ; $88 EVENT(
>ccc8	acc8	05 6b 46 41 4c 53 45			.text	5,$6b,"FALSE"          ; $89 FALSE
>cccf	accf	05 44 46 52 41 43 28			.text	5,$44,"FRAC("          ; $8a FRAC(
>ccd6	acd6	04 0d 48 49 54 28			.text	4,$0d,"HIT("           ; $8b HIT(
>ccdc	acdc	04 13 49 4e 54 28			.text	4,$13,"INT("           ; $8c INT(
>cce2	ace2	06 a7 49 53 56 41 4c 28			.text	6,$a7,"ISVAL("         ; $8d ISVAL(
>ccea	acea	05 5c 4a 4f 59 42 28			.text	5,$5c,"JOYB("          ; $8e JOYB(
>ccf1	acf1	05 72 4a 4f 59 58 28			.text	5,$72,"JOYX("          ; $8f JOYX(
>ccf8	acf8	05 73 4a 4f 59 59 28			.text	5,$73,"JOYY("          ; $90 JOYY(
>ccff	acff	06 77 4c 45 46 54 24 28			.text	6,$77,"LEFT$("         ; $91 LEFT$(
>cd07	ad07	04 07 4c 45 4e 28			.text	4,$07,"LEN("           ; $92 LEN(
>cd0d	ad0d	04 0e 4d 41 58 28			.text	4,$0e,"MAX("           ; $93 MAX(
>cd13	ad13	05 26 4d 49 44 24 28			.text	5,$26,"MID$("          ; $94 MID$(
>cd1a	ad1a	04 0c 4d 49 4e 28			.text	4,$0c,"MIN("           ; $95 MIN(
>cd20	ad20	04 19 4e 4f 54 28			.text	4,$19,"NOT("           ; $96 NOT(
>cd26	ad26	05 4d 50 45 45 4b 28			.text	5,$4d,"PEEK("          ; $97 PEEK(
>cd2d	ad2d	08 3c 50 4c 41 59 49 4e			.text	8,$3c,"PLAYING("       ; $98 PLAYING(
>cd35	ad35	47 28
>cd37	ad37	07 e9 52 41 4e 44 4f 4d			.text	7,$e9,"RANDOM("        ; $99 RANDOM(
>cd3f	ad3f	28
>cd40	ad40	07 ca 52 49 47 48 54 24			.text	7,$ca,"RIGHT$("        ; $9a RIGHT$(
>cd48	ad48	28
>cd49	ad49	04 0c 52 4e 44 28			.text	4,$0c,"RND("           ; $9b RND(
>cd4f	ad4f	04 10 53 47 4e 28			.text	4,$10,"SGN("           ; $9c SGN(
>cd55	ad55	04 0e 53 50 43 28			.text	4,$0e,"SPC("           ; $9d SPC(
>cd5b	ad5b	05 45 53 54 52 24 28			.text	5,$45,"STR$("          ; $9e STR$(
>cd62	ad62	06 a9 54 49 4d 45 52 28			.text	6,$a9,"TIMER("         ; $9f TIMER(
>cd6a	ad6a	04 40 54 52 55 45			.text	4,$40,"TRUE"           ; $a0 TRUE
>cd70	ad70	04 0b 56 41 4c 28			.text	4,$0b,"VAL("           ; $a1 VAL(
>cd76	ad76	03 e7 46 4f 52				.text	3,$e7,"FOR"            ; $a2 FOR
>cd7b	ad7b	02 8f 49 46				.text	2,$8f,"IF"             ; $a3 IF
>cd7f	ad7f	04 34 50 52 4f 43			.text	4,$34,"PROC"           ; $a4 PROC
>cd85	ad85	06 c1 52 45 50 45 41 54			.text	6,$c1,"REPEAT"         ; $a5 REPEAT
>cd8d	ad8d	05 79 57 48 49 4c 45			.text	5,$79,"WHILE"          ; $a6 WHILE
>cd94	ad94	05 66 45 4e 44 49 46			.text	5,$66,"ENDIF"          ; $a7 ENDIF
>cd9b	ad9b	07 0b 45 4e 44 50 52 4f			.text	7,$0b,"ENDPROC"        ; $a8 ENDPROC
>cda3	ada3	43
>cda4	ada4	04 3f 4e 45 58 54			.text	4,$3f,"NEXT"           ; $a9 NEXT
>cdaa	adaa	04 2f 54 48 45 4e			.text	4,$2f,"THEN"           ; $aa THEN
>cdb0	adb0	05 8c 55 4e 54 49 4c			.text	5,$8c,"UNTIL"          ; $ab UNTIL
>cdb7	adb7	04 2e 57 45 4e 44			.text	4,$2e,"WEND"           ; $ac WEND
>cdbd	adbd	02 9b 42 59				.text	2,$9b,"BY"             ; $ad BY
>cdc1	adc1	04 1c 43 41 4c 4c			.text	4,$1c,"CALL"           ; $ae CALL
>cdc7	adc7	06 b2 43 49 52 43 4c 45			.text	6,$b2,"CIRCLE"         ; $af CIRCLE
>cdcf	adcf	05 67 43 4c 45 41 52			.text	5,$67,"CLEAR"          ; $b0 CLEAR
>cdd6	add6	03 e2 43 4c 53				.text	3,$e2,"CLS"            ; $b1 CLS
>cddb	addb	05 7f 43 4f 4c 4f 52			.text	5,$7f,"COLOR"          ; $b2 COLOR
>cde2	ade2	06 d4 43 4f 4c 4f 55 52			.text	6,$d4,"COLOUR"         ; $b3 COLOUR
>cdea	adea	04 1a 44 41 54 41			.text	4,$1a,"DATA"           ; $b4 DATA
>cdf0	adf0	03 da 44 49 4d				.text	3,$da,"DIM"            ; $b5 DIM
>cdf5	adf5	04 23 44 4f 4b 45			.text	4,$23,"DOKE"           ; $b6 DOKE
>cdfb	adfb	06 db 44 4f 57 4e 54 4f			.text	6,$db,"DOWNTO"         ; $b7 DOWNTO
>ce03	ae03	04 29 45 4c 53 45			.text	4,$29,"ELSE"           ; $b8 ELSE
>ce09	ae09	04 34 46 52 4f 4d			.text	4,$34,"FROM"           ; $b9 FROM
>ce0f	ae0f	03 e5 47 46 58				.text	3,$e5,"GFX"            ; $ba GFX
>ce14	ae14	05 80 47 4f 53 55 42			.text	5,$80,"GOSUB"          ; $bb GOSUB
>ce1b	ae1b	04 39 47 4f 54 4f			.text	4,$39,"GOTO"           ; $bc GOTO
>ce21	ae21	04 24 48 45 52 45			.text	4,$24,"HERE"           ; $bd HERE
>ce27	ae27	05 63 49 4d 41 47 45			.text	5,$63,"IMAGE"          ; $be IMAGE
>ce2e	ae2e	05 90 49 4e 50 55 54			.text	5,$90,"INPUT"          ; $bf INPUT
>ce35	ae35	03 e5 4c 45 54				.text	3,$e5,"LET"            ; $c0 LET
>ce3a	ae3a	04 28 4c 49 4e 45			.text	4,$28,"LINE"           ; $c1 LINE
>ce40	ae40	05 6b 4c 4f 43 41 4c			.text	5,$6b,"LOCAL"          ; $c2 LOCAL
>ce47	ae47	03 db 4f 46 46				.text	3,$db,"OFF"            ; $c3 OFF
>ce4c	ae4c	02 9d 4f 4e				.text	2,$9d,"ON"             ; $c4 ON
>ce50	ae50	07 20 4f 55 54 4c 49 4e			.text	7,$20,"OUTLINE"        ; $c5 OUTLINE
>ce58	ae58	45
>ce59	ae59	07 0f 50 41 4c 45 54 54			.text	7,$0f,"PALETTE"        ; $c6 PALETTE
>ce61	ae61	45
>ce62	ae62	04 3f 50 4c 4f 54			.text	4,$3f,"PLOT"           ; $c7 PLOT
>ce68	ae68	04 2f 50 4f 4b 45			.text	4,$2f,"POKE"           ; $c8 POKE
>ce6e	ae6e	05 8d 50 52 49 4e 54			.text	5,$8d,"PRINT"          ; $c9 PRINT
>ce75	ae75	04 1c 52 45 41 44			.text	4,$1c,"READ"           ; $ca READ
>ce7b	ae7b	04 2e 52 45 43 54			.text	4,$2e,"RECT"           ; $cb RECT
>ce81	ae81	03 e4 52 45 4d				.text	3,$e4,"REM"            ; $cc REM
>ce86	ae86	06 e0 52 45 54 55 52 4e			.text	6,$e0,"RETURN"         ; $cd RETURN
>ce8e	ae8e	05 7b 53 4f 4c 49 44			.text	5,$7b,"SOLID"          ; $ce SOLID
>ce95	ae95	05 89 53 4f 55 4e 44			.text	5,$89,"SOUND"          ; $cf SOUND
>ce9c	ae9c	06 d7 53 50 52 49 54 45			.text	6,$d7,"SPRITE"         ; $d0 SPRITE
>cea4	aea4	04 45 54 45 58 54			.text	4,$45,"TEXT"           ; $d1 TEXT
>ceaa	aeaa	02 a3 54 4f				.text	2,$a3,"TO"             ; $d2 TO
>ceae	aeae	ff					.text	$FF
.ceaf	aeaf					KeywordSet1:
>ceaf	aeaf	00 65					.text	0,$65,""               ; $80 !0:EOF
>ceb1	aeb1	00 58					.text	0,$58,""               ; $81 !1:SH1
>ceb3	aeb3	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>ceb5	aeb5	08 4c 41 53 53 45 4d 42			.text	8,$4c,"ASSEMBLE"       ; $83 ASSEMBLE
>cebd	aebd	4c 45
>cebf	aebf	06 d2 41 53 53 45 52 54			.text	6,$d2,"ASSERT"         ; $84 ASSERT
>cec7	aec7	06 bd 42 49 54 4d 41 50			.text	6,$bd,"BITMAP"         ; $85 BITMAP
>cecf	aecf	03 d7 45 4e 44				.text	3,$d7,"END"            ; $86 END
>ced4	aed4	07 11 45 58 50 4c 4f 44			.text	7,$11,"EXPLODE"        ; $87 EXPLODE
>cedc	aedc	45
>cedd	aedd	02 96 47 4f				.text	2,$96,"GO"             ; $88 GO
>cee1	aee1	04 3c 4c 49 53 54			.text	4,$3c,"LIST"           ; $89 LIST
>cee7	aee7	04 20 4c 4f 41 44			.text	4,$20,"LOAD"           ; $8a LOAD
>ceed	aeed	03 ea 4e 45 57				.text	3,$ea,"NEW"            ; $8b NEW
>cef2	aef2	04 2e 50 49 4e 47			.text	4,$2e,"PING"           ; $8c PING
>cef8	aef8	07 24 52 45 53 54 4f 52			.text	7,$24,"RESTORE"        ; $8d RESTORE
>cf00	af00	45
>cf01	af01	03 f5 52 55 4e				.text	3,$f5,"RUN"            ; $8e RUN
>cf06	af06	05 8d 53 48 4f 4f 54			.text	5,$8d,"SHOOT"          ; $8f SHOOT
>cf0d	af0d	07 2a 53 50 52 49 54 45			.text	7,$2a,"SPRITES"        ; $90 SPRITES
>cf15	af15	53
>cf16	af16	04 46 53 54 4f 50			.text	4,$46,"STOP"           ; $91 STOP
>cf1c	af1c	03 eb 5a 41 50				.text	3,$eb,"ZAP"            ; $92 ZAP
>cf21	af21	ff					.text	$FF
.cf22	af22					KeywordSet2:
>cf22	af22	00 65					.text	0,$65,""               ; $80 !0:EOF
>cf24	af24	00 58					.text	0,$58,""               ; $81 !1:SH1
>cf26	af26	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>cf28	af28	03 c8 41 44 43				.text	3,$c8,"ADC"            ; $83 ADC
>cf2d	af2d	03 d3 41 4e 44				.text	3,$d3,"AND"            ; $84 AND
>cf32	af32	03 e0 41 53 4c				.text	3,$e0,"ASL"            ; $85 ASL
>cf37	af37	03 c8 42 43 43				.text	3,$c8,"BCC"            ; $86 BCC
>cf3c	af3c	03 d8 42 43 53				.text	3,$d8,"BCS"            ; $87 BCS
>cf41	af41	03 d8 42 45 51				.text	3,$d8,"BEQ"            ; $88 BEQ
>cf46	af46	03 df 42 49 54				.text	3,$df,"BIT"            ; $89 BIT
>cf4b	af4b	03 d8 42 4d 49				.text	3,$d8,"BMI"            ; $8a BMI
>cf50	af50	03 d5 42 4e 45				.text	3,$d5,"BNE"            ; $8b BNE
>cf55	af55	03 de 42 50 4c				.text	3,$de,"BPL"            ; $8c BPL
>cf5a	af5a	03 d5 42 52 41				.text	3,$d5,"BRA"            ; $8d BRA
>cf5f	af5f	03 df 42 52 4b				.text	3,$df,"BRK"            ; $8e BRK
>cf64	af64	03 db 42 56 43				.text	3,$db,"BVC"            ; $8f BVC
>cf69	af69	03 eb 42 56 53				.text	3,$eb,"BVS"            ; $90 BVS
>cf6e	af6e	03 d2 43 4c 43				.text	3,$d2,"CLC"            ; $91 CLC
>cf73	af73	03 d3 43 4c 44				.text	3,$d3,"CLD"            ; $92 CLD
>cf78	af78	03 d8 43 4c 49				.text	3,$d8,"CLI"            ; $93 CLI
>cf7d	af7d	03 e5 43 4c 56				.text	3,$e5,"CLV"            ; $94 CLV
>cf82	af82	03 e0 43 4d 50				.text	3,$e0,"CMP"            ; $95 CMP
>cf87	af87	03 eb 43 50 58				.text	3,$eb,"CPX"            ; $96 CPX
>cf8c	af8c	03 ec 43 50 59				.text	3,$ec,"CPY"            ; $97 CPY
>cf91	af91	03 cc 44 45 43				.text	3,$cc,"DEC"            ; $98 DEC
>cf96	af96	03 e1 44 45 58				.text	3,$e1,"DEX"            ; $99 DEX
>cf9b	af9b	03 e2 44 45 59				.text	3,$e2,"DEY"            ; $9a DEY
>cfa0	afa0	03 e6 45 4f 52				.text	3,$e6,"EOR"            ; $9b EOR
>cfa5	afa5	03 da 49 4e 43				.text	3,$da,"INC"            ; $9c INC
>cfaa	afaa	03 ef 49 4e 58				.text	3,$ef,"INX"            ; $9d INX
>cfaf	afaf	03 f0 49 4e 59				.text	3,$f0,"INY"            ; $9e INY
>cfb4	afb4	03 e7 4a 4d 50				.text	3,$e7,"JMP"            ; $9f JMP
>cfb9	afb9	03 ef 4a 53 52				.text	3,$ef,"JSR"            ; $a0 JSR
>cfbe	afbe	03 d1 4c 44 41				.text	3,$d1,"LDA"            ; $a1 LDA
>cfc3	afc3	03 e8 4c 44 58				.text	3,$e8,"LDX"            ; $a2 LDX
>cfc8	afc8	03 e9 4c 44 59				.text	3,$e9,"LDY"            ; $a3 LDY
>cfcd	afcd	03 f1 4c 53 52				.text	3,$f1,"LSR"            ; $a4 LSR
>cfd2	afd2	03 ed 4e 4f 50				.text	3,$ed,"NOP"            ; $a5 NOP
>cfd7	afd7	03 e2 4f 52 41				.text	3,$e2,"ORA"            ; $a6 ORA
>cfdc	afdc	03 d9 50 48 41				.text	3,$d9,"PHA"            ; $a7 PHA
>cfe1	afe1	03 e8 50 48 50				.text	3,$e8,"PHP"            ; $a8 PHP
>cfe6	afe6	03 f0 50 48 58				.text	3,$f0,"PHX"            ; $a9 PHX
>cfeb	afeb	03 f1 50 48 59				.text	3,$f1,"PHY"            ; $aa PHY
>cff0	aff0	03 dd 50 4c 41				.text	3,$dd,"PLA"            ; $ab PLA
>cff5	aff5	03 ec 50 4c 50				.text	3,$ec,"PLP"            ; $ac PLP
>cffa	affa	03 f4 50 4c 58				.text	3,$f4,"PLX"            ; $ad PLX
>cfff	afff	03 f5 50 4c 59				.text	3,$f5,"PLY"            ; $ae PLY
>d004	b004	03 ed 52 4f 4c				.text	3,$ed,"ROL"            ; $af ROL
>d009	b009	03 f3 52 4f 52				.text	3,$f3,"ROR"            ; $b0 ROR
>d00e	b00e	03 ef 52 54 49				.text	3,$ef,"RTI"            ; $b1 RTI
>d013	b013	03 f9 52 54 53				.text	3,$f9,"RTS"            ; $b2 RTS
>d018	b018	03 d8 53 42 43				.text	3,$d8,"SBC"            ; $b3 SBC
>d01d	b01d	03 db 53 45 43				.text	3,$db,"SEC"            ; $b4 SEC
>d022	b022	03 dc 53 45 44				.text	3,$dc,"SED"            ; $b5 SED
>d027	b027	03 e1 53 45 49				.text	3,$e1,"SEI"            ; $b6 SEI
>d02c	b02c	03 e8 53 54 41				.text	3,$e8,"STA"            ; $b7 STA
>d031	b031	03 f7 53 54 50				.text	3,$f7,"STP"            ; $b8 STP
>d036	b036	03 ff 53 54 58				.text	3,$ff,"STX"            ; $b9 STX
>d03b	b03b	03 00 53 54 59				.text	3,$00,"STY"            ; $ba STY
>d040	b040	03 01 53 54 5a				.text	3,$01,"STZ"            ; $bb STZ
>d045	b045	03 ed 54 41 58				.text	3,$ed,"TAX"            ; $bc TAX
>d04a	b04a	03 ee 54 41 59				.text	3,$ee,"TAY"            ; $bd TAY
>d04f	b04f	03 e8 54 52 42				.text	3,$e8,"TRB"            ; $be TRB
>d054	b054	03 e9 54 53 42				.text	3,$e9,"TSB"            ; $bf TSB
>d059	b059	03 ff 54 53 58				.text	3,$ff,"TSX"            ; $c0 TSX
>d05e	b05e	03 ed 54 58 41				.text	3,$ed,"TXA"            ; $c1 TXA
>d063	b063	03 ff 54 58 53				.text	3,$ff,"TXS"            ; $c2 TXS
>d068	b068	03 ee 54 59 41				.text	3,$ee,"TYA"            ; $c3 TYA
>d06d	b06d	ff					.text	$FF
.d06e	b06e					Export_TKListConvertLine:
.d06e	b06e	48		pha				pha 								; save indent on the stack
.d06f	b06f	9c 1d 04	stz $041d			stz 	tbOffset
.d072	b072	9c 2d 04	stz $042d			stz 	tokenBuffer
.d075	b075	9c 29 04	stz $0429			stz 	currentListColour
.d078	b078	a9 89		lda #$89			lda 	#CLILineNumber+$80
.d07a	b07a	20 f7 b1	jsr $b1f7			jsr 	LCLWriteColour
.d07d	b07d	a0 02		ldy #$02			ldy 	#2 							; convert line number to string
.d07f	b07f	b1 30		lda ($30),y			lda 	(codePtr),y
.d081	b081	aa		tax				tax
.d082	b082	88		dey				dey
.d083	b083	b1 30		lda ($30),y			lda 	(codePtr),y
.d085	b085	20 68 b2	jsr $b268			jsr 	LCLWriteNumberXA
.d088	b088	68		pla				pla 								; adjustment to indent
.d089	b089	48		pha				pha 								; save on stack
.d08a	b08a	10 0c		bpl $b098			bpl 	_LCNoAdjust 				; don't adjust indent if +ve, do after.
.d08c	b08c	18		clc				clc 								; add to list indent and make 0 if goes -ve.
.d08d	b08d	6d 26 04	adc $0426			adc 	listIndent
.d090	b090	8d 26 04	sta $0426			sta 	listIndent
.d093	b093	10 03		bpl $b098			bpl 	_LCNoAdjust
.d095	b095	9c 26 04	stz $0426			stz 	listIndent
.d098	b098					_LCNoAdjust:
.d098	b098	18		clc				clc		 							; work out actual indent.
.d099	b099	ad 26 04	lda $0426			lda 	listIndent
.d09c	b09c	0a		asl a				asl 	a
.d09d	b09d	69 07		adc #$07			adc 	#7
.d09f	b09f	85 36		sta $36				sta 	zTemp0
.d0a1	b0a1					_LCPadOut:
.d0a1	b0a1	a9 20		lda #$20			lda 	#' '						; pad out to 6+indent characters
.d0a3	b0a3	20 00 b2	jsr $b200			jsr 	LCLWrite
.d0a6	b0a6	ad 1d 04	lda $041d			lda 	tbOffset
.d0a9	b0a9	c5 36		cmp $36				cmp 	zTemp0
.d0ab	b0ab	d0 f4		bne $b0a1			bne 	_LCPadOut
.d0ad	b0ad	a0 03		ldy #$03			ldy 	#3 							; start position.
.d0af	b0af					_LCMainLoop:
.d0af	b0af	a9 8a		lda #$8a			lda 	#CLIPunctuation+$80
.d0b1	b0b1	20 f7 b1	jsr $b1f7			jsr 	LCLWriteColour
.d0b4	b0b4	b1 30		lda ($30),y			lda 	(codePtr),y
.d0b6	b0b6	c9 80		cmp #$80			cmp 	#KWC_EOL 					; end of line ?
.d0b8	b0b8	f0 17		beq $b0d1			beq 	_LCExit
.d0ba	b0ba	c9 10		cmp #$10			cmp 	#16 						; 0-5 are the double punctuations
.d0bc	b0bc	90 1e		bcc $b0dc			bcc 	_LCDoubles
.d0be	b0be	c9 20		cmp #$20			cmp 	#32 						; 16-31 are shifted punctuation from 64-91
.d0c0	b0c0	90 2a		bcc $b0ec			bcc 	_LCShiftPunc
.d0c2	b0c2	c9 40		cmp #$40			cmp 	#64 						; 32-64 are as stored, punc and digits
.d0c4	b0c4	90 35		bcc $b0fb			bcc 	_LCPunctuation
.d0c6	b0c6	c9 80		cmp #$80			cmp 	#128 						; 64-127 are variable identifiers.
.d0c8	b0c8	90 51		bcc $b11b			bcc 	_LCIdentifiers
.d0ca	b0ca	c9 fe		cmp #$fe			cmp 	#254 						; 128-253 are tokenised words
.d0cc	b0cc	90 73		bcc $b141			bcc 	_LCTokens
.d0ce	b0ce	4c a1 b1	jmp $b1a1			jmp 	_LCData 					; 254-5 are data objects
.d0d1	b0d1					_LCExit:
.d0d1	b0d1	68		pla				pla 								; get old indent adjust
.d0d2	b0d2	30 07		bmi $b0db			bmi 	_LCExit2
.d0d4	b0d4	18		clc				clc 								; add to indent if +ve
.d0d5	b0d5	6d 26 04	adc $0426			adc 	listIndent
.d0d8	b0d8	8d 26 04	sta $0426			sta 	listIndent
.d0db	b0db					_LCExit2:
.d0db	b0db	60		rts				rts
.d0dc	b0dc					_LCDoubles:
.d0dc	b0dc	48		pha				pha
.d0dd	b0dd	4a		lsr a				lsr 	a 							; put bit 2 into bit 1
.d0de	b0de	29 02		and #$02			and 	#2
.d0e0	b0e0	09 3c		ora #$3c			ora 	#60 						; make < >
.d0e2	b0e2	20 00 b2	jsr $b200			jsr 	LCLWrite
.d0e5	b0e5	68		pla				pla 								; restore, do lower bit
.d0e6	b0e6	29 03		and #$03			and 	#3
.d0e8	b0e8	09 3c		ora #$3c			ora 	#60
.d0ea	b0ea	80 0f		bra $b0fb			bra		_LCPunctuation 				; print, increment, loop
.d0ec	b0ec					_LCShiftPunc:
.d0ec	b0ec	aa		tax				tax 								; save in X
.d0ed	b0ed	29 07		and #$07			and 	#7 							; lower 3 bits
.d0ef	b0ef	f0 02		beq $b0f3			beq 	_LCNoAdd
.d0f1	b0f1	09 18		ora #$18			ora 	#24 						; adds $18 to it.
.d0f3	b0f3					_LCNoAdd:
.d0f3	b0f3	e0 18		cpx #$18			cpx 	#24 						; if >= 24 add $20
.d0f5	b0f5	90 02		bcc $b0f9			bcc 	_LCNoAdd2
.d0f7	b0f7	09 20		ora #$20			ora 	#32 						; adds $20
.d0f9	b0f9					_LCNoAdd2:
.d0f9	b0f9	09 40		ora #$40			ora 	#$40 						; shift into 64-127 range and fall through.
.d0fb	b0fb					_LCPunctuation:
.d0fb	b0fb	c9 3a		cmp #$3a			cmp 	#':' 						; check if :
.d0fd	b0fd	d0 03		bne $b102			bne 	_LCPContinue
.d0ff	b0ff	20 16 b2	jsr $b216			jsr 	LCLDeleteLastSpace 			; if so delete any preceding spaces
.d102	b102					_LCPContinue:
.d102	b102	c9 2e		cmp #$2e			cmp 	#'.'
.d104	b104	f0 08		beq $b10e			beq 	_LCPIsConstant
.d106	b106	c9 30		cmp #$30			cmp 	#'0'
.d108	b108	90 0b		bcc $b115			bcc 	_LCPNotConstant
.d10a	b10a	c9 3a		cmp #$3a			cmp 	#'9'+1
.d10c	b10c	b0 07		bcs $b115			bcs 	_LCPNotConstant
.d10e	b10e					_LCPIsConstant:
.d10e	b10e	48		pha				pha
.d10f	b10f	a9 8d		lda #$8d			lda 	#CLIConstant+$80
.d111	b111	20 f7 b1	jsr $b1f7			jsr 	LCLWriteColour
.d114	b114	68		pla				pla
.d115	b115					_LCPNotConstant:
.d115	b115	c8		iny				iny 								; consume character
.d116	b116	20 00 b2	jsr $b200			jsr 	LCLWrite 					; write it out.
.d119	b119	80 94		bra $b0af			bra 	_LCMainLoop 				; go round again.
.d11b	b11b					_LCIdentifiers:
.d11b	b11b	18		clc				clc 								; convert to physical address
.d11c	b11c	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.d11e	b11e	85 37		sta $37				sta 	zTemp0+1
.d120	b120	c8		iny				iny
.d121	b121	b1 30		lda ($30),y			lda 	(codePtr),y
.d123	b123	85 36		sta $36				sta 	zTemp0
.d125	b125	c8		iny				iny
.d126	b126	5a		phy				phy 								; save position
.d127	b127	a9 87		lda #$87			lda 	#CLIIdentifier+$80
.d129	b129	20 f7 b1	jsr $b1f7			jsr 	LCLWriteColour
.d12c	b12c	a0 07		ldy #$07			ldy 	#7 							; output the identifier at +8
.d12e	b12e					_LCOutIdentifier:
.d12e	b12e	c8		iny				iny
.d12f	b12f	b1 36		lda ($36),y			lda 	(zTemp0),y					; bit 7 set = end.
.d131	b131	29 7f		and #$7f			and 	#$7F
.d133	b133	20 52 b2	jsr $b252			jsr 	LCLLowerCase
.d136	b136	20 00 b2	jsr $b200			jsr 	LCLWrite
.d139	b139	b1 36		lda ($36),y			lda 	(zTemp0),y				 	; ends when bit 7 set.
.d13b	b13b	10 f1		bpl $b12e			bpl 	_LCOutIdentifier
.d13d	b13d	7a		ply				ply 								; restore position
.d13e	b13e	4c af b0	jmp $b0af			jmp 	_LCMainLoop
.d141	b141					_LCTokens:
.d141	b141	aa		tax				tax 								; token in X
.d142	b142	a9 22		lda #$22			lda 	#((KeywordSet2) & $FF)
.d144	b144	85 36		sta $36				sta 	0+zTemp0
.d146	b146	a9 af		lda #$af			lda 	#((KeywordSet2) >> 8)
.d148	b148	85 37		sta $37				sta 	1+zTemp0
.d14a	b14a	e0 82		cpx #$82			cpx 	#$82
.d14c	b14c	f0 16		beq $b164			beq 	_LCUseShift
.d14e	b14e	a9 af		lda #$af			lda 	#((KeywordSet1) & $FF)
.d150	b150	85 36		sta $36				sta 	0+zTemp0
.d152	b152	a9 ae		lda #$ae			lda 	#((KeywordSet1) >> 8)
.d154	b154	85 37		sta $37				sta 	1+zTemp0
.d156	b156	e0 81		cpx #$81			cpx 	#$81
.d158	b158	f0 0a		beq $b164			beq 	_LCUseShift
.d15a	b15a	a9 98		lda #$98			lda 	#((KeywordSet0) & $FF)
.d15c	b15c	85 36		sta $36				sta 	0+zTemp0
.d15e	b15e	a9 ac		lda #$ac			lda 	#((KeywordSet0) >> 8)
.d160	b160	85 37		sta $37				sta 	1+zTemp0
.d162	b162	80 01		bra $b165			bra 	_LCNoShift
.d164	b164					_LCUseShift:
.d164	b164	c8		iny				iny
.d165	b165					_LCNoShift:
.d165	b165	20 2a b2	jsr $b22a			jsr 	LCLCheckSpaceRequired 		; do we need a space ?
.d168	b168	b1 30		lda ($30),y			lda 	(codePtr),y
.d16a	b16a	aa		tax				tax 								; into X
.d16b	b16b					_LCFindText:
.d16b	b16b	ca		dex				dex
.d16c	b16c	10 0e		bpl $b17c			bpl 	_LCFoundText 				; found text.
.d16e	b16e	b2 36		lda ($36)			lda 	(zTemp0) 					; length of text
.d170	b170	1a		inc a				inc 	a 							; one extra for size
.d171	b171	38		sec				sec 								; one extra for checksum
.d172	b172	65 36		adc $36				adc 	zTemp0 						; go to next token
.d174	b174	85 36		sta $36				sta 	zTemp0
.d176	b176	90 f3		bcc $b16b			bcc 	_LCFindText
.d178	b178	e6 37		inc $37				inc 	zTemp0+1
.d17a	b17a	80 ef		bra $b16b			bra 	_LCFindText
.d17c	b17c					_LCFoundText:
.d17c	b17c	5a		phy				phy 								; save List position
.d17d	b17d	b2 36		lda ($36)			lda 	(zTemp0)					; count to print
.d17f	b17f	aa		tax				tax
.d180	b180	a9 83		lda #$83			lda 	#CLIToken+$80
.d182	b182	20 f7 b1	jsr $b1f7			jsr 	LCLWriteColour
.d185	b185	a0 02		ldy #$02			ldy 	#2
.d187	b187					_LCCopyToken:
.d187	b187	b1 36		lda ($36),y			lda 	(zTemp0),y
.d189	b189	20 52 b2	jsr $b252			jsr 	LCLLowerCase
.d18c	b18c	20 00 b2	jsr $b200			jsr 	LCLWrite
.d18f	b18f	c8		iny				iny
.d190	b190	ca		dex				dex
.d191	b191	d0 f4		bne $b187			bne 	_LCCopyToken
.d193	b193	c9 28		cmp #$28			cmp 	#"(" 						; if last char not ( print a space
.d195	b195	f0 05		beq $b19c			beq 	_LCNoSpace
.d197	b197	a9 20		lda #$20			lda 	#' '
.d199	b199	20 00 b2	jsr $b200			jsr 	LCLWrite
.d19c	b19c					_LCNoSpace:
.d19c	b19c	7a		ply				ply 								; restore position.
.d19d	b19d	c8		iny				iny 								; consume token
.d19e	b19e	4c af b0	jmp $b0af			jmp 	_LCMainLoop 				; and go around again.
.d1a1	b1a1					_LCData:
.d1a1	b1a1	48		pha				pha 								; save type $FE/$FF
.d1a2	b1a2	a2 24		ldx #$24			ldx 	#'$' 						; figure out $ or "
.d1a4	b1a4	c9 fe		cmp #$fe			cmp 	#$FE
.d1a6	b1a6	f0 22		beq $b1ca			beq 	_LCHaveOpener
.d1a8	b1a8	a2 22		ldx #$22			ldx 	#'"'
.d1aa	b1aa	a9 81		lda #$81			lda 	#CLIData+$80
.d1ac	b1ac	20 f7 b1	jsr $b1f7			jsr 	LCLWriteColour
.d1af	b1af	c0 04		cpy #$04			cpy 	#4 							; must be 2nd thing on line
.d1b1	b1b1	d0 17		bne $b1ca			bne 	_LCHaveOpener
.d1b3	b1b3	88		dey				dey 								; what precedes it ?
.d1b4	b1b4	b1 30		lda ($30),y			lda 	(codePtr),y
.d1b6	b1b6	c8		iny				iny
.d1b7	b1b7	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; if quote
.d1b9	b1b9	d0 0f		bne $b1ca			bne 	_LCHaveOpener
.d1bb	b1bb	a9 09		lda #$09			lda 	#9 							; tab
.d1bd	b1bd	20 00 b2	jsr $b200			jsr 	LCLWrite
.d1c0	b1c0	a9 97		lda #$97			lda 	#$90+CLIBComment
.d1c2	b1c2	20 00 b2	jsr $b200			jsr 	LCLWrite
.d1c5	b1c5	a9 80		lda #$80			lda 	#CLIFComment+$80
.d1c7	b1c7	20 f7 b1	jsr $b1f7			jsr 	LCLWriteColour
.d1ca	b1ca					_LCHaveOpener:
.d1ca	b1ca	8a		txa				txa 								; output prefix (# or ")
.d1cb	b1cb	20 00 b2	jsr $b200			jsr 	LCLWrite
.d1ce	b1ce	c8		iny				iny 								; get count
.d1cf	b1cf	b1 30		lda ($30),y			lda 	(codePtr),y
.d1d1	b1d1	aa		tax				tax
.d1d2	b1d2	c8		iny				iny 								; point at first character
.d1d3	b1d3					_LCOutData:
.d1d3	b1d3	b1 30		lda ($30),y			lda 	(codePtr),y
.d1d5	b1d5	c9 00		cmp #$00			cmp 	#0
.d1d7	b1d7	f0 03		beq $b1dc			beq 	_LCNoPrint
.d1d9	b1d9	20 00 b2	jsr $b200			jsr 	LCLWrite
.d1dc	b1dc					_LCNoPrint:
.d1dc	b1dc	c8		iny				iny
.d1dd	b1dd	ca		dex				dex
.d1de	b1de	d0 f3		bne $b1d3			bne 	_LCOutData
.d1e0	b1e0	68		pla				pla 								; closing " required ?
.d1e1	b1e1	c9 ff		cmp #$ff			cmp 	#$FF 						; not required for hex constant.
.d1e3	b1e3	d0 0f		bne $b1f4			bne 	_LCNoQuote
.d1e5	b1e5	a9 22		lda #$22			lda 	#'"'
.d1e7	b1e7	20 00 b2	jsr $b200			jsr 	LCLWrite
.d1ea	b1ea	ad 6f 06	lda $066f			lda 	EXTTextColour
.d1ed	b1ed	29 0f		and #$0f			and 	#$0F
.d1ef	b1ef	09 90		ora #$90			ora 	#$90
.d1f1	b1f1	20 00 b2	jsr $b200			jsr 	LCLWrite
.d1f4	b1f4					_LCNoQuote:
.d1f4	b1f4	4c af b0	jmp $b0af			jmp 	_LCMainLoop
.d1f7	b1f7					LCLWriteColour:
.d1f7	b1f7	cd 29 04	cmp $0429			cmp 	currentListColour 			; has the colour changed
.d1fa	b1fa	8d 29 04	sta $0429			sta 	currentListColour 			; (update it anyway)
.d1fd	b1fd	d0 01		bne $b200			bne 	LCLWrite 					; if different, output it
.d1ff	b1ff	60		rts				rts
.d200	b200					LCLWrite:
.d200	b200	da		phx				phx
.d201	b201	ae 1d 04	ldx $041d			ldx 	tbOffset 					; write out make ASCIIZ
.d204	b204	9d 2d 04	sta $042d,x			sta 	tokenBuffer,x
.d207	b207	9e 2e 04	stz $042e,x			stz 	tokenBuffer+1,x
.d20a	b20a	ee 1d 04	inc $041d			inc 	tbOffset 					; bump the position
.d20d	b20d	09 00		ora #$00			ora 	#0 							; don't update last character if colour data
.d20f	b20f	30 03		bmi $b214			bmi 	_LCLNoColour
.d211	b211	8d 27 04	sta $0427			sta 	LCLastCharacter
.d214	b214					_LCLNoColour:
.d214	b214	fa		plx				plx
.d215	b215	60		rts				rts
.d216	b216					LCLDeleteLastSpace:
.d216	b216	48		pha				pha
.d217	b217	da		phx				phx
.d218	b218	ae 1d 04	ldx $041d			ldx 	tbOffset
.d21b	b21b	f0 0a		beq $b227			beq 	_LCDLSExit
.d21d	b21d	bd 2c 04	lda $042c,x			lda 	tokenBuffer-1,x
.d220	b220	c9 20		cmp #$20			cmp 	#' '
.d222	b222	d0 03		bne $b227			bne 	_LCDLSExit
.d224	b224	ce 1d 04	dec $041d			dec 	tbOffset
.d227	b227					_LCDLSExit:
.d227	b227	fa		plx				plx
.d228	b228	68		pla				pla
.d229	b229	60		rts				rts
.d22a	b22a					LCLCheckSpaceRequired:
.d22a	b22a	ad 27 04	lda $0427			lda 	LCLastCharacter 			; check last character
.d22d	b22d	c9 24		cmp #$24			cmp 	#'$' 						; $ # and ) require that token space.
.d22f	b22f	f0 1b		beq $b24c			beq 	_LCCSRSpace
.d231	b231	c9 29		cmp #$29			cmp 	#')'
.d233	b233	f0 17		beq $b24c			beq 	_LCCSRSpace
.d235	b235	c9 23		cmp #$23			cmp 	#'#'
.d237	b237	f0 13		beq $b24c			beq 	_LCCSRSpace
.d239	b239	20 52 b2	jsr $b252			jsr 	LCLLowerCase 				; saves a little effort
.d23c	b23c	c9 30		cmp #$30			cmp 	#"0" 						; check if it was 0-9 A-Z a-z if so need space.
.d23e	b23e	90 11		bcc $b251			bcc 	_LCCSRExit
.d240	b240	c9 3a		cmp #$3a			cmp 	#"9"+1
.d242	b242	90 08		bcc $b24c			bcc 	_LCCSRSpace
.d244	b244	c9 61		cmp #$61			cmp 	#"a"
.d246	b246	90 09		bcc $b251			bcc 	_LCCSRExit
.d248	b248	c9 7b		cmp #$7b			cmp 	#"z"+1
.d24a	b24a	b0 05		bcs $b251			bcs 	_LCCSRExit
.d24c	b24c					_LCCSRSpace:
.d24c	b24c	a9 20		lda #$20			lda 	#' '
.d24e	b24e	20 00 b2	jsr $b200			jsr 	LCLWrite
.d251	b251					_LCCSRExit:
.d251	b251	60		rts				rts
.d252	b252					LCLLowerCase:
.d252	b252	c9 41		cmp #$41			cmp 	#"A"
.d254	b254	90 06		bcc $b25c			bcc 	_LCLLCOut
.d256	b256	c9 5b		cmp #$5b			cmp 	#"Z"+1
.d258	b258	b0 02		bcs $b25c			bcs 	_LCLLCOut
.d25a	b25a	69 20		adc #$20			adc 	#$20
.d25c	b25c					_LCLLCOut:
.d25c	b25c	60		rts				rts
.d25d	b25d					LCLUpperCase:
.d25d	b25d	c9 61		cmp #$61			cmp 	#"a"
.d25f	b25f	90 06		bcc $b267			bcc 	_LCLUCOut
.d261	b261	c9 7b		cmp #$7b			cmp 	#"z"+1
.d263	b263	b0 02		bcs $b267			bcs 	_LCLUCOut
.d265	b265	e9 1f		sbc #$1f			sbc 	#$1F
.d267	b267					_LCLUCOut:
.d267	b267	60		rts				rts
.d268	b268					LCLWriteNumberXA:
.d268	b268	64 37		stz $37				stz 	zTemp0+1 					; index into digit table.
.d26a	b26a					_LCLWNLoop1:
.d26a	b26a	64 36		stz $36				stz 	zTemp0 						; subtraction count.
.d26c	b26c					_LCLWNLoop2:
.d26c	b26c	48		pha				pha 								; save initial LSB
.d26d	b26d	38		sec				sec
.d26e	b26e	a4 37		ldy $37				ldy 	zTemp0+1 					; position in table.
.d270	b270	f9 a1 b2	sbc $b2a1,y			sbc 	_LCLWNTable,y
.d273	b273	48		pha				pha
.d274	b274	8a		txa				txa
.d275	b275	f9 a2 b2	sbc $b2a2,y			sbc 	_LCLWNTable+1,y
.d278	b278	90 07		bcc $b281			bcc 	_LCLWNUnderflow
.d27a	b27a	e6 36		inc $36				inc 	zTemp0  					; subtracted one without borrow.
.d27c	b27c	aa		tax				tax 								; update X
.d27d	b27d	68		pla				pla 								; restore A
.d27e	b27e	7a		ply				ply 								; throw original
.d27f	b27f	80 eb		bra $b26c			bra 	_LCLWNLoop2 				; try again.
.d281	b281					_LCLWNUnderflow:
.d281	b281	a4 36		ldy $36				ldy 	zTemp0 						; count of subtractions.
.d283	b283	d0 06		bne $b28b			bne 	_LCLWNOut
.d285	b285	ad 1d 04	lda $041d			lda 	tbOffset 					; suppress leading zeroes
.d288	b288	3a		dec a				dec 	a
.d289	b289	f0 04		beq $b28f			beq 	_LCLWNNext
.d28b	b28b					_LCLWNOut:
.d28b	b28b	98		tya				tya
.d28c	b28c	20 9b b2	jsr $b29b			jsr 	_LCLWNOutDigit
.d28f	b28f					_LCLWNNext:
.d28f	b28f	7a		ply				ply 							 	; restore original value.
.d290	b290	68		pla				pla
.d291	b291	a4 37		ldy $37				ldy 	zTemp0+1  					; bump the index
.d293	b293	c8		iny				iny
.d294	b294	c8		iny				iny
.d295	b295	84 37		sty $37				sty 	zTemp0+1
.d297	b297	c0 08		cpy #$08			cpy 	#8 							; done all 4
.d299	b299	d0 cf		bne $b26a			bne 	_LCLWNLoop1
.d29b	b29b					_LCLWNOutDigit:
.d29b	b29b	09 30		ora #$30			ora 	#'0'
.d29d	b29d	20 00 b2	jsr $b200			jsr 	LCLWrite
.d2a0	b2a0	60		rts				rts
.d2a1	b2a1					_LCLWNTable:
>d2a1	b2a1	10 27						.word 	10000
>d2a3	b2a3	e8 03						.word 	1000
>d2a5	b2a5	64 00						.word 	100
>d2a7	b2a7	0a 00						.word 	10
.d2a9	b2a9					TOKSearchTable:
.d2a9	b2a9	84 37		sty $37				sty 	zTemp0+1 					; (zTemp0),y points to current token being tested.
.d2ab	b2ab	85 36		sta $36				sta 	zTemp0
.d2ad	b2ad	a0 00		ldy #$00			ldy 	#0
.d2af	b2af	a9 80		lda #$80			lda 	#$80 						; token # so we know which one we are looking at
.d2b1	b2b1	85 38		sta $38				sta 	zTemp1
.d2b3	b2b3					_TSTLoop:
.d2b3	b2b3	b1 36		lda ($36),y			lda 	(zTemp0),y 					; length, 0 (skip) -ve (end)
.d2b5	b2b5	30 49		bmi $b300			bmi 	_TSTFail 					; -ve = end of table, so fail.
.d2b7	b2b7	f0 2e		beq $b2e7			beq 	_TSTNext 					; zero, check next as it's a dummy (e.g. EOL, SHIFT)
.d2b9	b2b9	c8		iny				iny 								; get the hash
.d2ba	b2ba	b1 36		lda ($36),y			lda 	(zTemp0),y
.d2bc	b2bc	88		dey				dey
.d2bd	b2bd	cd 03 04	cmp $0403			cmp 	identHash 					; check they match with the identifier hash, if not go to next
.d2c0	b2c0	d0 25		bne $b2e7			bne 	_TSTNext
.d2c2	b2c2	ad 02 04	lda $0402			lda 	identTypeEnd 				; get length of identifier from end-start
.d2c5	b2c5	38		sec				sec
.d2c6	b2c6	ed 00 04	sbc $0400			sbc 	identStart
.d2c9	b2c9	d1 36		cmp ($36),y			cmp 	(zTemp0),y 					; compare against the length in the table, no match, then return.
.d2cb	b2cb	d0 1a		bne $b2e7			bne 	_TSTNext
.d2cd	b2cd	5a		phy				phy 								; save Y , we might fail to match.
.d2ce	b2ce	c8		iny				iny 								; point to text
.d2cf	b2cf	c8		iny				iny
.d2d0	b2d0	ae 00 04	ldx $0400			ldx 	identStart 					; offset in line buffer in X
.d2d3	b2d3					_TSTCompareName:
.d2d3	b2d3	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; compare text.
.d2d6	b2d6	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.d2d8	b2d8	d0 0c		bne $b2e6			bne 	_TSTNextPullY 				; fail, pullY and do next
.d2da	b2da	e8		inx				inx
.d2db	b2db	c8		iny				iny
.d2dc	b2dc	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; complete match.
.d2df	b2df	d0 f2		bne $b2d3			bne 	_TSTCompareName
.d2e1	b2e1	7a		ply				ply 								; throw Y
.d2e2	b2e2	a5 38		lda $38				lda 	zTemp1 						; get token #
.d2e4	b2e4	38		sec				sec 								; return with CS = passed.
.d2e5	b2e5	60		rts				rts
.d2e6	b2e6					_TSTNextPullY:
.d2e6	b2e6	7a		ply				ply 								; restore current, fall through.
.d2e7	b2e7					_TSTNext:
.d2e7	b2e7	e6 38		inc $38				inc 	zTemp1 						; token counter
.d2e9	b2e9	98		tya				tya
.d2ea	b2ea	18		clc				clc
.d2eb	b2eb	71 36		adc ($36),y			adc 	(zTemp0),y 					; add [Length] + 2 to Y
.d2ed	b2ed	1a		inc a				inc 	a 							; +1
.d2ee	b2ee	1a		inc a				inc 	a 							; +2
.d2ef	b2ef	a8		tay				tay
.d2f0	b2f0	10 c1		bpl $b2b3			bpl 	_TSTLoop 					; if Y < $80 loop back
.d2f2	b2f2	98		tya				tya 								; add Y to zTemp0 and reset Y
.d2f3	b2f3	a0 00		ldy #$00			ldy 	#0   						; so we can use Y to search fast
.d2f5	b2f5	18		clc				clc  								; but have tables > 255 bytes
.d2f6	b2f6	65 36		adc $36				adc 	zTemp0 						; when Y gets >= 128 we reset Y
.d2f8	b2f8	85 36		sta $36				sta 	zTemp0 						; and adjust the table pointer/
.d2fa	b2fa	90 b7		bcc $b2b3			bcc 	_TSTLoop
.d2fc	b2fc	e6 37		inc $37				inc 	zTemp0+1
.d2fe	b2fe	80 b3		bra $b2b3			bra 	_TSTLoop
.d300	b300					_TSTFail:
.d300	b300	18		clc				clc
.d301	b301	60		rts				rts
.d302	b302					Export_TKTokeniseLine:
.d302	b302	20 8a b4	jsr $b48a			jsr 	LCLFixLineBufferCase 		; fix line case
.d305	b305	a9 03		lda #$03			lda 	#3 							; reset the token buffer to empty
.d307	b307	8d 2a 04	sta $042a			sta 	tokenOffset 				; (3 bytes for line number & offset)
.d30a	b30a	9c 2b 04	stz $042b			stz 	tokenLineNumber
.d30d	b30d	9c 2c 04	stz $042c			stz 	tokenLineNumber+1
.d310	b310	a2 ff		ldx #$ff			ldx 	#$FF
.d312	b312					_TKFindFirst:
.d312	b312	e8		inx				inx
.d313	b313	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.d316	b316	f0 79		beq $b391			beq 	_TKExit
.d318	b318	c9 20		cmp #$20			cmp 	#' '
.d31a	b31a	90 f6		bcc $b312			bcc 	_TKFindFirst
.d31c	b31c	c9 30		cmp #$30			cmp 	#'0'
.d31e	b31e	90 07		bcc $b327			bcc 	_TKNoLineNumber
.d320	b320	c9 3a		cmp #$3a			cmp 	#'9'+1
.d322	b322	b0 03		bcs $b327			bcs 	_TKNoLineNumber
.d324	b324	20 b4 b4	jsr $b4b4			jsr 	TOKExtractLineNumber
.d327	b327					_TKNoLineNumber:
.d327	b327					_TKTokeniseLoop:
.d327	b327	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; next character, exit if zero EOL.
.d32a	b32a	f0 65		beq $b391			beq 	_TKExit
.d32c	b32c	e8		inx				inx
.d32d	b32d	c9 20		cmp #$20			cmp 	#' '
.d32f	b32f	f0 f6		beq $b327			beq 	_TKTokeniseLoop 			; keep looping if space found.
.d331	b331	ca		dex				dex 								; undo last get, A contains character, X is position.
.d332	b332	c9 5f		cmp #$5f			cmp 	#'_'						; _ A-Z is identifier *or* token
.d334	b334	f0 61		beq $b397			beq 	_TKTokeniseIdentifier 		; (already case converted outside string constants)
.d336	b336	c9 41		cmp #$41			cmp 	#'A'
.d338	b338	90 04		bcc $b33e			bcc 	_TKTokenisePunctuation
.d33a	b33a	c9 5b		cmp #$5b			cmp 	#'Z'+1
.d33c	b33c	90 59		bcc $b397			bcc 	_TKTokeniseIdentifier
.d33e	b33e					_TKTokenisePunctuation:
.d33e	b33e	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.d340	b340	f0 27		beq $b369			beq 	_TKString
.d342	b342	c9 24		cmp #$24			cmp 	#'$'						; hexadecimal constant ($ only appears at end of identifiers)
.d344	b344	f0 28		beq $b36e			beq 	_TKHexConstant
.d346	b346	c9 3c		cmp #$3c			cmp 	#'<' 						; check for < > handlers - these are for <> <= >= >> <<
.d348	b348	f0 29		beq $b373			beq 	_TKCheckDouble
.d34a	b34a	c9 3e		cmp #$3e			cmp 	#'>'
.d34c	b34c	f0 25		beq $b373			beq 	_TKCheckDouble
.d34e	b34e					_TKStandardPunctuation:
.d34e	b34e	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get the punctuation token back.
.d351	b351	c9 40		cmp #$40			cmp 	#64 						; are we >= 64
.d353	b353	90 0e		bcc $b363			bcc 	_TKNoShift
.d355	b355	48		pha				pha 								; save. we are about to convert this punctuation token from
.d356	b356	29 07		and #$07			and 	#7 							; lower 3 bits in zTemp0
.d358	b358	85 36		sta $36				sta 	zTemp0
.d35a	b35a	68		pla				pla
.d35b	b35b	29 20		and #$20			and 	#32 						; bit 5
.d35d	b35d	4a		lsr a				lsr 	a 							; shift into bit 3
.d35e	b35e	4a		lsr a				lsr 	a
.d35f	b35f	05 36		ora $36				ora 	zTemp0
.d361	b361	09 10		ora #$10			ora 	#$10						; now in the range 16-31
.d363	b363					_TKNoShift:
.d363	b363	20 f9 b4	jsr $b4f9			jsr 	TOKWriteByte 				; write the punctuation character
.d366	b366	e8		inx				inx 								; consume the character
.d367	b367	80 be		bra $b327			bra 	_TKTokeniseLoop 			; and loop round again.
.d369	b369					_TKString:
.d369	b369	20 19 b4	jsr $b419			jsr 	TOKTokenString
.d36c	b36c	80 b9		bra $b327			bra 	_TKTokeniseLoop
.d36e	b36e					_TKHexConstant:
.d36e	b36e	20 54 b4	jsr $b454			jsr 	TOKHexConstant
.d371	b371	80 b4		bra $b327			bra 	_TKTokeniseLoop
.d373	b373					_TKCheckDouble:
.d373	b373	bd 2b 05	lda $052b,x			lda 	lineBuffer+1,x 				; get next character
.d376	b376	c9 3c		cmp #$3c			cmp 	#'<'						; if not < = > which are ASCII consecutive go back
.d378	b378	90 d4		bcc $b34e			bcc 	_TKStandardPunctuation 		; and do the normal punctuation handler.
.d37a	b37a	c9 3f		cmp #$3f			cmp 	#'>'+1
.d37c	b37c	b0 d0		bcs $b34e			bcs 	_TKStandardPunctuation
.d37e	b37e	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; this is < (60) or > (62)
.d381	b381	29 02		and #$02			and 	#2 							; now < (0) or > (2)
.d383	b383	0a		asl a				asl 	a 							; now < (0) or > (4), CC also
.d384	b384	7d 2b 05	adc $052b,x			adc 	lineBuffer+1,x 				; add < = > codes - < code
.d387	b387	38		sec				sec
.d388	b388	e9 3c		sbc #$3c			sbc 	#'<'
.d38a	b38a	20 f9 b4	jsr $b4f9			jsr 	TOKWriteByte 				; this is in the range 0-7
.d38d	b38d	e8		inx				inx 								; consume both
.d38e	b38e	e8		inx				inx
.d38f	b38f	80 96		bra $b327			bra 	_TKTokeniseLoop
.d391	b391	a9 80		lda #$80	_TKExit:lda 	#KWC_EOL 					; write end of line byte
.d393	b393	20 f9 b4	jsr $b4f9			jsr 	TOKWriteByte
.d396	b396	60		rts				rts
.d397	b397					_TKTokeniseIdentifier:
.d397	b397	8e 00 04	stx $0400			stx 	identStart 					; save start
.d39a	b39a	9c 04 04	stz $0404			stz 	identTypeByte 				; zero the type byte
.d39d	b39d					_TKCheckLoop:
.d39d	b39d	e8		inx				inx 								; look at next, we know first is identifier already.
.d39e	b39e	bd 2a 05	lda $052a,x			lda  	lineBuffer,x
.d3a1	b3a1	c9 5f		cmp #$5f			cmp 	#"_" 						; legal char _ 0-9 A-Z
.d3a3	b3a3	f0 f8		beq $b39d			beq 	_TKCheckLoop
.d3a5	b3a5	c9 30		cmp #$30			cmp	 	#"0"
.d3a7	b3a7	90 0c		bcc $b3b5			bcc 	_TKEndIdentifier
.d3a9	b3a9	c9 3a		cmp #$3a			cmp 	#"9"+1
.d3ab	b3ab	90 f0		bcc $b39d			bcc 	_TKCheckLoop
.d3ad	b3ad	c9 41		cmp #$41			cmp	 	#"A"
.d3af	b3af	90 04		bcc $b3b5			bcc 	_TKEndIdentifier
.d3b1	b3b1	c9 5b		cmp #$5b			cmp 	#"Z"+1
.d3b3	b3b3	90 e8		bcc $b39d			bcc 	_TKCheckLoop
.d3b5	b3b5					_TKEndIdentifier:
.d3b5	b3b5	8e 01 04	stx $0401			stx 	identTypeStart 				; save start of type text (if any !)
.d3b8	b3b8	a0 08		ldy #$08			ldy 	#$08 						; this is the identifier type byte for #
.d3ba	b3ba	c9 23		cmp #$23			cmp 	#"#"						; followed by #
.d3bc	b3bc	f0 06		beq $b3c4			beq 	_TKHasTypeCharacter
.d3be	b3be	a0 10		ldy #$10			ldy 	#$10 						; this is the identifier type byte for $
.d3c0	b3c0	c9 24		cmp #$24			cmp 	#"$"						; followed by $ or #
.d3c2	b3c2	d0 07		bne $b3cb			bne 	_TKNoTypeCharacter
.d3c4	b3c4					_TKHasTypeCharacter:
.d3c4	b3c4	8c 04 04	sty $0404			sty 	identTypeByte 				; has # or $, save the type
.d3c7	b3c7	e8		inx				inx 								; consume the type character
.d3c8	b3c8	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.d3cb	b3cb					_TKNoTypeCharacter:
.d3cb	b3cb	c9 28		cmp #$28			cmp 	#"("						; is it open parenthesis (e.g. array)
.d3cd	b3cd	d0 09		bne $b3d8			bne 	_TKNoArray
.d3cf	b3cf	e8		inx				inx 								; skip the (
.d3d0	b3d0	ad 04 04	lda $0404			lda 	identTypeByte 				; set bit 2 (e.g. array) in type byte
.d3d3	b3d3	09 04		ora #$04			ora 	#$04
.d3d5	b3d5	8d 04 04	sta $0404			sta 	identTypeByte
.d3d8	b3d8					_TKNoArray:
.d3d8	b3d8	8e 02 04	stx $0402			stx 	identTypeEnd 				; save end marker, e.g. continue from here.
.d3db	b3db	20 75 b4	jsr $b475			jsr 	TOKCalculateHash 			; calculate the has for those tokens
.d3de	b3de	a0 ac		ldy #$ac			ldy 	#(KeywordSet0) >> 8
.d3e0	b3e0	a9 98		lda #$98			lda 	#(KeywordSet0) & $FF
.d3e2	b3e2	20 a9 b2	jsr $b2a9			jsr 	TOKSearchTable
.d3e5	b3e5	a2 00		ldx #$00			ldx 	#0
.d3e7	b3e7	b0 1f		bcs $b408			bcs 	_TKFoundToken
.d3e9	b3e9	a0 ae		ldy #$ae			ldy 	#(KeywordSet1) >> 8
.d3eb	b3eb	a9 af		lda #$af			lda 	#(KeywordSet1) & $FF
.d3ed	b3ed	20 a9 b2	jsr $b2a9			jsr 	TOKSearchTable
.d3f0	b3f0	a2 81		ldx #$81			ldx 	#$81
.d3f2	b3f2	b0 14		bcs $b408			bcs 	_TKFoundToken
.d3f4	b3f4	a0 af		ldy #$af			ldy 	#(KeywordSet2) >> 8
.d3f6	b3f6	a9 22		lda #$22			lda 	#(KeywordSet2) & $FF
.d3f8	b3f8	20 a9 b2	jsr $b2a9			jsr 	TOKSearchTable
.d3fb	b3fb	a2 82		ldx #$82			ldx 	#$82
.d3fd	b3fd	b0 09		bcs $b408			bcs 	_TKFoundToken
.d3ff	b3ff	20 05 b5	jsr $b505			jsr 	TOKCheckCreateVariableRecord ; failed all, it's a variable, create record if does not exist.
.d402	b402	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.d405	b405	4c 27 b3	jmp $b327			jmp 	_TKTokeniseLoop 			; and go round again.
.d408	b408					_TKFoundToken:
.d408	b408	48		pha				pha 								; save token
.d409	b409	8a		txa				txa 								; shift in X, is there one ?
.d40a	b40a	f0 03		beq $b40f			beq 	_TKNoTShift
.d40c	b40c	20 f9 b4	jsr $b4f9			jsr 	TOKWriteByte 				; if so, write it out
.d40f	b40f					_TKNoTShift:
.d40f	b40f	68		pla				pla 								; restore and write token
.d410	b410	20 f9 b4	jsr $b4f9			jsr 	TOKWriteByte
.d413	b413	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.d416	b416	4c 27 b3	jmp $b327			jmp 	_TKTokeniseLoop 			; and go round again.
.d419	b419					TOKTokenString:
.d419	b419	a9 ff		lda #$ff			lda 	#KWC_STRING 				; string token.
.d41b	b41b	20 f9 b4	jsr $b4f9			jsr 	TOKWriteByte
.d41e	b41e	e8		inx				inx									; start of quoted string.
.d41f	b41f	da		phx				phx 								; push start of string on top
.d420	b420	ca		dex				dex 								; because we pre-increment
.d421	b421					_TSFindEnd:
.d421	b421	e8		inx				inx
.d422	b422	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; next character
.d425	b425	f0 04		beq $b42b			beq 	_TSEndOfString 				; no matching quote, we don't mind.
.d427	b427	c9 22		cmp #$22			cmp 	#'"' 						; go back if quote not found
.d429	b429	d0 f6		bne $b421			bne 	_TSFindEnd
.d42b	b42b					_TSEndOfString:
.d42b	b42b	7a		ply				ply  								; so now Y is first character, X is character after end.
.d42c	b42c	48		pha				pha 								; save terminating character
.d42d	b42d	20 35 b4	jsr $b435			jsr 	TOKWriteBlockXY 			; write X to Y as a data block
.d430	b430	68		pla				pla 								; terminating character
.d431	b431	f0 01		beq $b434			beq 	_TSNotQuote					; if it wasn't EOS skip it
.d433	b433	e8		inx				inx
.d434	b434					_TSNotQuote:
.d434	b434	60		rts				rts
.d435	b435					TOKWriteBlockXY:
.d435	b435	86 36		stx $36				stx 	zTemp0 						; save end character
.d437	b437	98		tya				tya 								; use 2's complement to work out the byte size
.d438	b438	49 ff		eor #$ff			eor 	#$FF
.d43a	b43a	38		sec				sec
.d43b	b43b	65 36		adc $36				adc 	zTemp0
.d43d	b43d	1a		inc a				inc 	a 							; one extra for NULL
.d43e	b43e	20 f9 b4	jsr $b4f9			jsr 	TOKWriteByte
.d441	b441					_TOBlockLoop:
.d441	b441	c4 36		cpy $36				cpy 	zTemp0 						; exit if reached the end
.d443	b443	f0 09		beq $b44e			beq 	_TOBlockExit
.d445	b445	b9 2a 05	lda $052a,y			lda 	lineBuffer,y 				; write byte out.
.d448	b448	20 f9 b4	jsr $b4f9			jsr 	TOKWriteByte
.d44b	b44b	c8		iny				iny
.d44c	b44c	80 f3		bra $b441			bra 	_TOBlockLoop
.d44e	b44e					_TOBlockExit:
.d44e	b44e	a9 00		lda #$00			lda 	#0 							; add NULL.
.d450	b450	20 f9 b4	jsr $b4f9			jsr 	TOKWriteByte
.d453	b453	60		rts				rts
.d454	b454					TOKHexConstant:
.d454	b454	a9 fe		lda #$fe			lda 	#KWC_HEXCONST 				; hex constant token.
.d456	b456	20 f9 b4	jsr $b4f9			jsr 	TOKWriteByte
.d459	b459	e8		inx				inx									; start of quoted string.
.d45a	b45a	da		phx				phx 								; push start of constant on top
.d45b	b45b	ca		dex				dex
.d45c	b45c					_THFindLoop:
.d45c	b45c	e8		inx				inx 	 							; this is stored in a block, so find out how long
.d45d	b45d	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; the hex constant is.
.d460	b460	c9 30		cmp #$30			cmp 	#"0"
.d462	b462	90 0c		bcc $b470			bcc 	_THFoundEnd
.d464	b464	c9 3a		cmp #$3a			cmp 	#"9"+1
.d466	b466	90 f4		bcc $b45c			bcc 	_THFindLoop
.d468	b468	c9 41		cmp #$41			cmp 	#"A"
.d46a	b46a	90 04		bcc $b470			bcc 	_THFoundEnd
.d46c	b46c	c9 47		cmp #$47			cmp 	#"F"+1
.d46e	b46e	90 ec		bcc $b45c			bcc 	_THFindLoop
.d470	b470					_THFoundEnd:
.d470	b470	7a		ply				ply 								; restore start
.d471	b471	20 35 b4	jsr $b435			jsr 	TOKWriteBlockXY 			; output the block
.d474	b474	60		rts				rts
.d475	b475					TOKCalculateHash:
.d475	b475	da		phx				phx
.d476	b476	ae 00 04	ldx $0400			ldx 	identStart 					; needs to be same as in tokens.py - simple sum at present.
.d479	b479	a9 00		lda #$00			lda 	#0
.d47b	b47b					_TCHLoop:
.d47b	b47b	18		clc				clc
.d47c	b47c	7d 2a 05	adc $052a,x			adc 	lineBuffer,x
.d47f	b47f	e8		inx				inx
.d480	b480	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; do the whole thing including type and array markers.
.d483	b483	d0 f6		bne $b47b			bne 	_TCHLoop
.d485	b485	8d 03 04	sta $0403			sta 	identHash 					; save the hash
.d488	b488	fa		plx				plx
.d489	b489	60		rts				rts
.d48a	b48a					LCLFixLineBufferCase:
.d48a	b48a	a2 00		ldx #$00			ldx 	#0
.d48c	b48c					_FLBCLoop:
.d48c	b48c	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get next character
.d48f	b48f	f0 22		beq $b4b3			beq 	_FLBCExit 					; end of string.
.d491	b491	c9 22		cmp #$22			cmp 	#'"'						; quote, go to in quotes
.d493	b493	f0 11		beq $b4a6			beq 	_FLBCInQuotes
.d495	b495	e8		inx				inx
.d496	b496	c9 61		cmp #$61			cmp 	#'a'						; needs capitalising ?
.d498	b498	90 f2		bcc $b48c			bcc 	_FLBCLoop
.d49a	b49a	c9 7b		cmp #$7b			cmp 	#'z'+1
.d49c	b49c	b0 ee		bcs $b48c			bcs 	_FLBCLoop
.d49e	b49e	38		sec				sec 								; make U/C
.d49f	b49f	e9 20		sbc #$20			sbc 	#32
.d4a1	b4a1	9d 29 05	sta $0529,x			sta	 	lineBuffer-1,x 				; write back
.d4a4	b4a4	80 e6		bra $b48c			bra 	_FLBCLoop
.d4a6	b4a6					_FLBCInQuotes:
.d4a6	b4a6	e8		inx				inx 								; advance
.d4a7	b4a7	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get next
.d4aa	b4aa	f0 07		beq $b4b3			beq 	_FLBCExit 					; exit on EOS
.d4ac	b4ac	c9 22		cmp #$22			cmp 	#'"' 				 		; until " found
.d4ae	b4ae	d0 f6		bne $b4a6			bne 	_FLBCInQuotes
.d4b0	b4b0	e8		inx				inx 								; skip over it
.d4b1	b4b1	80 d9		bra $b48c			bra 	_FLBCLoop
.d4b3	b4b3					_FLBCExit:
.d4b3	b4b3	60		rts				rts
.d4b4	b4b4					TOKExtractLineNumber:
.d4b4	b4b4	ad 2c 04	lda $042c			lda 	tokenLineNumber+1 			; push current value on stack
.d4b7	b4b7	48		pha				pha
.d4b8	b4b8	ad 2b 04	lda $042b			lda 	tokenLineNumber
.d4bb	b4bb	48		pha				pha
.d4bc	b4bc	20 f2 b4	jsr $b4f2			jsr 	_LCLNTimes2 				; line # x 2
.d4bf	b4bf	20 f2 b4	jsr $b4f2			jsr 	_LCLNTimes2 				; line # x 4
.d4c2	b4c2	18		clc				clc 								; add stacked value
.d4c3	b4c3	68		pla				pla
.d4c4	b4c4	6d 2b 04	adc $042b			adc 	tokenLineNumber
.d4c7	b4c7	8d 2b 04	sta $042b			sta 	tokenLineNumber
.d4ca	b4ca	68		pla				pla
.d4cb	b4cb	6d 2c 04	adc $042c			adc 	tokenLineNumber+1
.d4ce	b4ce	8d 2c 04	sta $042c			sta 	tokenLineNumber+1 			; line # x 5
.d4d1	b4d1	20 f2 b4	jsr $b4f2			jsr 	_LCLNTimes2 				; line # x 10
.d4d4	b4d4	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get and consume character
.d4d7	b4d7	e8		inx				inx
.d4d8	b4d8	29 0f		and #$0f			and 	#15 						; add to line #
.d4da	b4da	18		clc				clc
.d4db	b4db	6d 2b 04	adc $042b			adc 	tokenLineNumber
.d4de	b4de	8d 2b 04	sta $042b			sta 	tokenLineNumber
.d4e1	b4e1	90 03		bcc $b4e6			bcc 	_TLENNoCarry
.d4e3	b4e3	ee 2c 04	inc $042c			inc 	tokenLineNumber+1
.d4e6	b4e6					_TLENNoCarry:
.d4e6	b4e6	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; more digits ?
.d4e9	b4e9	c9 30		cmp #$30			cmp 	#'0'
.d4eb	b4eb	90 04		bcc $b4f1			bcc 	_TLENExit
.d4ed	b4ed	c9 3a		cmp #$3a			cmp 	#'9'+1
.d4ef	b4ef	90 c3		bcc $b4b4			bcc 	TOKExtractLineNumber
.d4f1	b4f1					_TLENExit:
.d4f1	b4f1	60		rts				rts
.d4f2	b4f2					_LCLNTimes2:
.d4f2	b4f2	0e 2b 04	asl $042b			asl 	tokenLineNumber 			; doubles tokenLineNumber.
.d4f5	b4f5	2e 2c 04	rol $042c			rol 	tokenLineNumber+1
.d4f8	b4f8	60		rts				rts
.d4f9	b4f9					TOKWriteByte:
.d4f9	b4f9	da		phx				phx
.d4fa	b4fa	ae 2a 04	ldx $042a			ldx 	tokenOffset 				; next slot to write to
.d4fd	b4fd	9d 2a 04	sta $042a,x			sta 	tokenOffset,x 				; write byte out
.d500	b500	ee 2a 04	inc $042a			inc 	tokenOffset 				; advance slot.
.d503	b503	fa		plx				plx
.d504	b504	60		rts				rts
.d505	b505					TOKCheckCreateVariableRecord:
.d505	b505	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.d507	b507	85 36		sta $36				sta 	0+zTemp0
.d509	b509	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.d50b	b50b	85 37		sta $37				sta 	1+zTemp0
.d50d	b50d					_CCVSearch:
.d50d	b50d	b2 36		lda ($36)			lda 	(zTemp0) 					; end of list
.d50f	b50f	f0 2c		beq $b53d			beq 	_CCVFail
.d511	b511	a0 01		ldy #$01			ldy 	#1 							; read the hash
.d513	b513	b1 36		lda ($36),y			lda 	(zTemp0),y 					; does it match ?
.d515	b515	cd 03 04	cmp $0403			cmp 	identHash 	  				; if not, try the next.
.d518	b518	d0 16		bne $b530			bne 	_CCVNext
.d51a	b51a	a0 08		ldy #$08			ldy 	#8 							; name in variable record
.d51c	b51c	ae 00 04	ldx $0400			ldx 	identStart
.d51f	b51f					_CCVCompare:
.d51f	b51f	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; xor them. zero if the same, except
.d522	b522	51 36		eor ($36),y			eor 	(zTemp0),y 					; bit 7 is used for EOS.
.d524	b524	e8		inx				inx 								; advance pointers
.d525	b525	c8		iny				iny
.d526	b526	0a		asl a				asl 	a 							; A = 0 if they match, CS if end.
.d527	b527	d0 07		bne $b530			bne 	_CCVNext  					; didn't match go to next.
.d529	b529	90 f4		bcc $b51f			bcc 	_CCVCompare 				; not finished yet.
.d52b	b52b	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; matched whole thing ?
.d52e	b52e	f0 41		beq $b571			beq 	_CCVFound 					; yes, we were successful
.d530	b530					_CCVNext:
.d530	b530	18		clc				clc 								; go to next record.
.d531	b531	b2 36		lda ($36)			lda 	(zTemp0) 					; add offset to pointer
.d533	b533	65 36		adc $36				adc 	zTemp0
.d535	b535	85 36		sta $36				sta 	zTemp0
.d537	b537	90 d4		bcc $b50d			bcc 	_CCVSearch
.d539	b539	e6 37		inc $37				inc 	zTemp0+1
.d53b	b53b	80 d0		bra $b50d			bra 	_CCVSearch
.d53d	b53d					_CCVFail:
.d53d	b53d	a0 01		ldy #$01			ldy 	#1 							; create the new record. Offset 1 is hash
.d53f	b53f	ad 03 04	lda $0403			lda 	identHash
.d542	b542	91 36		sta ($36),y			sta 	(zTemp0),y
.d544	b544	c8		iny				iny 								; offset 2 is the type byte
.d545	b545	ad 04 04	lda $0404			lda 	identTypeByte
.d548	b548	91 36		sta ($36),y			sta 	(zTemp0),y
.d54a	b54a	c8		iny				iny
.d54b	b54b					_CCVData:
.d54b	b54b	a9 00		lda #$00			lda 	#0 							; erase data 3-7 (the 5 value bytes)
.d54d	b54d	91 36		sta ($36),y			sta 	(zTemp0),y
.d54f	b54f	c8		iny				iny
.d550	b550	c0 08		cpy #$08			cpy 	#8
.d552	b552	90 f7		bcc $b54b			bcc 	_CCVData
.d554	b554	ae 00 04	ldx $0400			ldx 	identStart 					; copy name into 8 on.
.d557	b557					_CCVCopyName:
.d557	b557	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.d55a	b55a	91 36		sta ($36),y			sta 	(zTemp0),y
.d55c	b55c	e8		inx				inx
.d55d	b55d	c8		iny				iny
.d55e	b55e	ec 02 04	cpx $0402			cpx 	identTypeEnd
.d561	b561	d0 f4		bne $b557			bne 	_CCVCopyName
.d563	b563	98		tya				tya 								; patch offset
.d564	b564	92 36		sta ($36)			sta 	(zTemp0)
.d566	b566	a9 00		lda #$00			lda 	#0 							; offset for next is zero.
.d568	b568	91 36		sta ($36),y			sta 	(zTemp0),y
.d56a	b56a	88		dey				dey
.d56b	b56b	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set bit 7 of last bit
.d56d	b56d	09 80		ora #$80			ora 	#$80
.d56f	b56f	91 36		sta ($36),y			sta 	(zTemp0),y
.d571	b571					_CCVFound:
.d571	b571	a5 37		lda $37				lda 	zTemp0+1 					; write out MSB
.d573	b573	38		sec				sec
.d574	b574	e9 10		sbc #$10			sbc 	#(VariableSpace >> 8) 		; offset from the start of the variable token
.d576	b576	09 40		ora #$40			ora 	#$40 						; make it a writeable token $4000-$7FFF
.d578	b578	20 f9 b4	jsr $b4f9			jsr 	TOKWriteByte
.d57b	b57b	a5 36		lda $36				lda 	zTemp0 						; write out LSB
.d57d	b57d	20 f9 b4	jsr $b4f9			jsr 	TOKWriteByte
.d580	b580	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_sound.module

=1						soundIntegrated=1
.d581	b581					SNDCheckChannel:
.d581	b581	aa		tax				tax
.d582	b582	bd 38 08	lda $0838,x			lda 	SNDTimeLeft,x 				; currently playing a note
.d585	b585	d0 38		bne $b5bf			bne 	_SNDCCExit
.d587	b587	da		phx				phx 								; save current channel
.d588	b588	8a		txa				txa 								; put in A
.d589	b589	20 05 b6	jsr $b605			jsr 	SNDFindNextNoteForA 		; is there a note for A in the queue ?
.d58c	b58c	68		pla				pla 								; channel # in A
.d58d	b58d	90 30		bcc $b5bf			bcc 	_SNDCCExit  				; nothing in the queue for this channel, exit.
.d58f	b58f	a8		tay				tay 								; Y is the channel #
.d590	b590	bd 2d 07	lda $072d,x			lda 	SNDQueue+1,x 				; copy data into the slot.
.d593	b593	99 2c 08	sta $082c,y			sta 	SNDPitchLow,y
.d596	b596	bd 2e 07	lda $072e,x			lda 	SNDQueue+2,x
.d599	b599	99 30 08	sta $0830,y			sta 	SNDPitchHigh,y
.d59c	b59c	bd 2f 07	lda $072f,x			lda 	SNDQueue+3,x
.d59f	b59f	99 34 08	sta $0834,y			sta 	SNDVolume,y
.d5a2	b5a2	bd 30 07	lda $0730,x			lda 	SNDQueue+4,x
.d5a5	b5a5	99 38 08	sta $0838,y			sta 	SNDTimeLeft,y
.d5a8	b5a8	bd 31 07	lda $0731,x			lda 	SNDQueue+5,x
.d5ab	b5ab	99 3c 08	sta $083c,y			sta 	SNDAdjustLow,y
.d5ae	b5ae	bd 32 07	lda $0732,x			lda 	SNDQueue+6,x
.d5b1	b5b1	99 40 08	sta $0840,y			sta 	SNDAdjustHigh,y
.d5b4	b5b4	5a		phy				phy 								; save channel #
.d5b5	b5b5	20 1f b6	jsr $b61f			jsr 	SNDDeleteXFromQueue 		; delete record at X from queue
.d5b8	b5b8	ce 2b 07	dec $072b			dec 	SNDLength 					; reduce the queue length.
.d5bb	b5bb	68		pla				pla
.d5bc	b5bc	20 c0 b5	jsr $b5c0			jsr 	SNDUpdateNote 				; update channel A
.d5bf	b5bf					_SNDCCExit:
.d5bf	b5bf	60		rts				rts
.d5c0	b5c0					SNDUpdateNote:
.d5c0	b5c0	aa		tax				tax 								; so we can access records
.d5c1	b5c1	0a		asl a				asl 	a 							; convert it to a channel bit pair in 5,6
.d5c2	b5c2	0a		asl a				asl 	a
.d5c3	b5c3	0a		asl a				asl 	a
.d5c4	b5c4	0a		asl a				asl 	a
.d5c5	b5c5	0a		asl a				asl 	a
.d5c6	b5c6	8d 2a 07	sta $072a			sta 	SNDChannelBits
.d5c9	b5c9	bd 38 08	lda $0838,x			lda 	SNDTimeLeft,x 				; are we silent
.d5cc	b5cc	f0 2e		beq $b5fc			beq 	_SNDUNIsSilent
.d5ce	b5ce	ad 2a 07	lda $072a			lda 	SNDChannelBits 				; push channel bits on stack
.d5d1	b5d1	48		pha				pha
.d5d2	b5d2	bd 2c 08	lda $082c,x			lda 	SNDPitchLow,x 				; get 4 lowest bits of pitch.
.d5d5	b5d5	29 0f		and #$0f			and 	#$0F
.d5d7	b5d7	0d 2a 07	ora $072a			ora 	SNDChannelBits 				; set channel bits
.d5da	b5da	09 80		ora #$80			ora 	#$80 						; write to pitch register
.d5dc	b5dc	20 69 b6	jsr $b669			jsr 	SNDWritePorts
.d5df	b5df	bd 30 08	lda $0830,x			lda 	SNDPitchHigh,x 				; pitch high => channel temp.
.d5e2	b5e2	8d 2a 07	sta $072a			sta 	SNDChannelBits
.d5e5	b5e5	bd 2c 08	lda $082c,x			lda 	SNDPitchLow,x
.d5e8	b5e8	4e 2a 07	lsr $072a			lsr 	SNDChannelBits 				; shift 2 LSBs into MSB of A
.d5eb	b5eb	6a		ror a				ror 	a
.d5ec	b5ec	4e 2a 07	lsr $072a			lsr 	SNDChannelBits
.d5ef	b5ef	6a		ror a				ror 	a
.d5f0	b5f0	4a		lsr a				lsr 	a 							; put in bits 0-5
.d5f1	b5f1	4a		lsr a				lsr 	a
.d5f2	b5f2	20 69 b6	jsr $b669			jsr 	SNDWritePorts 				; write as rest of pitch register
.d5f5	b5f5	68		pla				pla
.d5f6	b5f6	09 90		ora #$90			ora 	#$90 						; set to write minimum attentuation.
.d5f8	b5f8	20 69 b6	jsr $b669			jsr 	SNDWritePorts
.d5fb	b5fb	60		rts				rts
.d5fc	b5fc					_SNDUNIsSilent:
.d5fc	b5fc	ad 2a 07	lda $072a			lda 	SNDChannelBits 				; channel bits
.d5ff	b5ff	09 9f		ora #$9f			ora 	#$9F 						; maximum attenuation
.d601	b601	20 69 b6	jsr $b669			jsr 	SNDWritePorts 				; write to the ports
.d604	b604	60		rts				rts
.d605	b605					SNDFindNextNoteForA:
.d605	b605	ac 2b 07	ldy $072b			ldy 	SNDLength 					; queue size into Y
.d608	b608	f0 13		beq $b61d			beq 	_SNDFNNFail 				; queue empty.
.d60a	b60a	a2 00		ldx #$00			ldx 	#0
.d60c	b60c					_SNDFNNSearch:
.d60c	b60c	dd 2c 07	cmp $072c,x			cmp 	SNDQueue,x 					; does it match the channel
.d60f	b60f	38		sec				sec
.d610	b610	f0 0c		beq $b61e			beq 	_SNDFNNExit 				; if so exit with CS.
.d612	b612	e8		inx				inx 								; next queue slot.
.d613	b613	e8		inx				inx
.d614	b614	e8		inx				inx
.d615	b615	e8		inx				inx
.d616	b616	e8		inx				inx
.d617	b617	e8		inx				inx
.d618	b618	e8		inx				inx
.d619	b619	e8		inx				inx
.d61a	b61a	88		dey				dey 								; done the whole queue
.d61b	b61b	d0 ef		bne $b60c			bne 	_SNDFNNSearch 				; no, go back.
.d61d	b61d					_SNDFNNFail:
.d61d	b61d	18		clc				clc
.d61e	b61e					_SNDFNNexit:
.d61e	b61e	60		rts				rts
.d61f	b61f					SNDDeleteXFromQueue:
.d61f	b61f	e0 f8		cpx #$f8			cpx 	#SNDQueueSize*8-8 			; reached the end.
.d621	b621	f0 09		beq $b62c			beq 	_SNDDXExit
.d623	b623	bd 34 07	lda $0734,x			lda 	SNDQueue+8,x
.d626	b626	9d 2c 07	sta $072c,x			sta 	SNDQueue,x
.d629	b629	e8		inx				inx
.d62a	b62a	80 f3		bra $b61f			bra 	SNDDeleteXFromQueue
.d62c	b62c					_SNDDXExit:
.d62c	b62c	60		rts				rts
.072a						SNDChannelBits:
>072a								.fill 	1
.d62d	b62d					SNDQueueRequest:
.d62d	b62d	86 36		stx $36				stx 	zTemp0						; save queue address
.d62f	b62f	84 37		sty $37				sty 	zTemp0+1
.d631	b631	ae 2b 07	ldx $072b			ldx 	SNDLength 					; queue is full, can't take any more.
.d634	b634	e0 20		cpx #$20			cpx 	#SNDQueueSize
.d636	b636	f0 21		beq $b659			beq 	_SNDQRExit
.d638	b638	29 03		and #$03			and 	#3	 						; channel # and push on stack
.d63a	b63a	48		pha				pha
.d63b	b63b	8a		txa				txa  								; get offset in queue buffer/
.d63c	b63c	0a		asl a				asl 	a
.d63d	b63d	0a		asl a				asl 	a
.d63e	b63e	0a		asl a				asl 	a
.d63f	b63f	aa		tax				tax
.d640	b640	68		pla				pla 								; get back and push again
.d641	b641	48		pha				pha
.d642	b642	9d 2c 07	sta $072c,x			sta 	SNDQueue+0,x 				; save the channel #
.d645	b645	a0 00		ldy #$00			ldy 	#0 							; copy the rest in.
.d647	b647					_SNDQCopy:
.d647	b647	b1 36		lda ($36),y			lda 	(zTemp0),y
.d649	b649	e8		inx				inx
.d64a	b64a	c8		iny				iny
.d64b	b64b	9d 2c 07	sta $072c,x			sta 	SNDQueue,x
.d64e	b64e	c0 06		cpy #$06			cpy 	#6
.d650	b650	d0 f5		bne $b647			bne 	_SNDQCopy
.d652	b652	ee 2b 07	inc $072b			inc 	SNDLength 					; bump queue length.
.d655	b655	68		pla				pla 								; get channel # back
.d656	b656	20 81 b5	jsr $b581			jsr 	SNDCheckChannel 			; check if channel needs refreshing.
.d659	b659					_SNDQRExit:
.d659	b659	60		rts				rts
.d65a	b65a					SNDSilenceChannel:
.d65a	b65a	aa		tax				tax 								; zero time left.
.d65b	b65b	9e 38 08	stz $0838,x			stz 	SNDTimeLeft,x
.d65e	b65e	0a		asl a				asl 	a 							; shift into position
.d65f	b65f	0a		asl a				asl 	a
.d660	b660	0a		asl a				asl 	a
.d661	b661	0a		asl a				asl 	a
.d662	b662	0a		asl a				asl 	a
.d663	b663	09 9f		ora #$9f			ora 	#$9F 						; write register attenuation $F
.d665	b665	20 69 b6	jsr $b669			jsr 	SNDWritePorts
.d668	b668	60		rts				rts
.d669	b669					SNDWritePorts:
.d669	b669	da		phx				phx 								; save X
.d66a	b66a	a6 01		ldx $01				ldx 	1 							; save I/O status
.d66c	b66c	64 01		stz $01				stz 	1 							; access I/O page 0
.d66e	b66e	8d 00 d6	sta $d600			sta 	$D600 						; write to both
.d671	b671	8d 10 d6	sta $d610			sta 	$D610
.d674	b674	86 01		stx $01				stx 	1 							; restore I/O
.d676	b676	fa		plx				plx 								; restore X
.d677	b677	60		rts				rts
.d678	b678					Export_SNDCommand:
.d678	b678	da		phx				phx 								; save XY
.d679	b679	5a		phy				phy
.d67a	b67a	c9 0f		cmp #$0f			cmp 	#$0F 						; $0F is initialise
.d67c	b67c	f0 1d		beq $b69b			beq 	_SNDInitialise
.d67e	b67e	90 28		bcc $b6a8			bcc 	_SNDExit
.d680	b680	c9 3f		cmp #$3f			cmp 	#$3F 						; $3F is silence all
.d682	b682	f0 17		beq $b69b			beq 	_SNDSilence
.d684	b684	b0 22		bcs $b6a8			bcs 	_SNDExit
.d686	b686	c9 20		cmp #$20			cmp 	#$20 						; $2x is check playing => A
.d688	b688	b0 09		bcs $b693			bcs 	_SNDQueryPlay
.d68a	b68a	c9 14		cmp #$14			cmp 	#$14 						; $10-$13 is queue sound
.d68c	b68c	b0 1a		bcs $b6a8			bcs 	_SNDExit
.d68e	b68e	20 2d b6	jsr $b62d			jsr 	SNDQueueRequest
.d691	b691	80 15		bra $b6a8			bra 	_SNDExit
.d693	b693					_SNDQueryPlay:
.d693	b693	29 03		and #$03			and 	#3 							; get channel #
.d695	b695	aa		tax				tax
.d696	b696	bd 38 08	lda $0838,x			lda 	SNDTimeLeft,x 				; read time left, if zero then silent
.d699	b699	80 0d		bra $b6a8			bra 	_SNDExit
.d69b	b69b					_SNDInitialise:
.d69b	b69b					_SNDSilence:
.d69b	b69b	9c 2b 07	stz $072b			stz 	SNDLength 					; empty the queue.
.d69e	b69e	a9 03		lda #$03			lda 	#$3 						; silence channel 0-3.
.d6a0	b6a0					_SNDSilenceLoop:
.d6a0	b6a0	48		pha				pha
.d6a1	b6a1	20 5a b6	jsr $b65a			jsr 	SNDSilenceChannel
.d6a4	b6a4	68		pla				pla
.d6a5	b6a5	3a		dec a				dec 	a
.d6a6	b6a6	10 f8		bpl $b6a0			bpl 	_SNDSilenceLoop
.d6a8	b6a8					_SNDExit:
.d6a8	b6a8	7a		ply				ply
.d6a9	b6a9	fa		plx				plx
.d6aa	b6aa	60		rts				rts
=32						SNDQueueSize = 32 							; number of queue entries
.072b						SNDLength:
>072b								.fill 	1
.072c						SNDQueue:
>072c								.fill 	SNDQueueSize * 8
.082c						SNDPitchLow:
>082c								.fill 	4
.0830						SNDPitchHigh:
>0830								.fill 	4
.0834						SNDVolume:
>0834								.fill 	4
.0838						SNDTimeLeft:
>0838								.fill 	4
.083c						SNDAdjustLow:
>083c								.fill 	4
.0840						SNDAdjustHigh:
>0840								.fill 	4
.d6ab	b6ab					Export_SNDUpdate:
.d6ab	b6ab					PagedSNDUpdate:
.d6ab	b6ab	ad 38 08	lda $0838			lda 	SNDTimeLeft+0 				; look at time remaining
.d6ae	b6ae	f0 05		beq $b6b5			beq 	_SNDUNot0 					; not playing
.d6b0	b6b0	a2 00		ldx #$00			ldx 	#0 							; so we know which channel to update
.d6b2	b6b2	20 d4 b6	jsr $b6d4			jsr 	SNDUpdateChannel 			; update it.
.d6b5	b6b5					_SNDUNot0:
.d6b5	b6b5	ad 39 08	lda $0839			lda 	SNDTimeLeft+1
.d6b8	b6b8	f0 05		beq $b6bf			beq 	_SNDUNot1
.d6ba	b6ba	a2 01		ldx #$01			ldx 	#1
.d6bc	b6bc	20 d4 b6	jsr $b6d4			jsr 	SNDUpdateChannel
.d6bf	b6bf					_SNDUNot1:
.d6bf	b6bf	ad 3a 08	lda $083a			lda 	SNDTimeLeft+2
.d6c2	b6c2	f0 05		beq $b6c9			beq 	_SNDUNot2
.d6c4	b6c4	a2 02		ldx #$02			ldx 	#2
.d6c6	b6c6	20 d4 b6	jsr $b6d4			jsr 	SNDUpdateChannel
.d6c9	b6c9					_SNDUNot2:
.d6c9	b6c9	ad 3b 08	lda $083b			lda 	SNDTimeLeft+3
.d6cc	b6cc	f0 05		beq $b6d3			beq 	_SNDUNot3
.d6ce	b6ce	a2 03		ldx #$03			ldx 	#3
.d6d0	b6d0	20 d4 b6	jsr $b6d4			jsr 	SNDUpdateChannel
.d6d3	b6d3					_SNDUNot3:
.d6d3	b6d3	60		rts				rts
.d6d4	b6d4					SNDUpdateChannel:
.d6d4	b6d4	c9 ff		cmp #$ff			cmp 	#$FF 						; sound $FF play forever until turned off manually
.d6d6	b6d6	f0 2c		beq $b704			beq 	_SNDUCExit
.d6d8	b6d8	3a		dec a				dec 	a 							; decrement and update timer
.d6d9	b6d9	9d 38 08	sta $0838,x			sta 	SNDTimeLeft,x
.d6dc	b6dc	f0 1d		beq $b6fb			beq 	_SNDUCUpdate 				; if zero, silence channel
.d6de	b6de	bd 3c 08	lda $083c,x			lda 	SNDAdjustLow,x 				; adjust ?
.d6e1	b6e1	1d 40 08	ora $0840,x			ora 	SNDAdjustHigh,x
.d6e4	b6e4	f0 1e		beq $b704			beq 	_SNDUCExit 					; if zero carry on at current tone.
.d6e6	b6e6	18		clc				clc 								; add adjust, forcing into a 10 bit range
.d6e7	b6e7	bd 2c 08	lda $082c,x			lda 	SNDPitchLow,x
.d6ea	b6ea	7d 3c 08	adc $083c,x			adc 	SNDAdjustLow,x
.d6ed	b6ed	9d 2c 08	sta $082c,x			sta 	SNDPitchLow,x
.d6f0	b6f0	bd 30 08	lda $0830,x			lda 	SNDPitchHigh,x
.d6f3	b6f3	7d 40 08	adc $0840,x			adc 	SNDAdjustHigh,x
.d6f6	b6f6	29 03		and #$03			and 	#3
.d6f8	b6f8	9d 30 08	sta $0830,x			sta 	SNDPitchHigh,x
.d6fb	b6fb					_SNDUCUpdate:
.d6fb	b6fb	8a		txa				txa 								; which channel.
.d6fc	b6fc	48		pha				pha
.d6fd	b6fd	20 c0 b5	jsr $b5c0			jsr 	SNDUpdateNote 				; update the current note
.d700	b700	68		pla				pla
.d701	b701	20 81 b5	jsr $b581			jsr 	SNDCheckChannel 			; more to do ?
.d704	b704					_SNDUCExit:
.d704	b704	60		rts				rts

;******  Return to file: _basic.asm


;******  End of listing
