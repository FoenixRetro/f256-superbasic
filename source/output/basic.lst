
; 64tass Turbo Assembler Macro V1.57.2900 listing file
; 64tass -D AUTORUN=1 "-D MONITOR_ADDRESS=\$E000" "-D LOCKOUT_ADDRESS=\$F000" "-D BASIC_ADDRESS=\$38000" "-D SOURCE_ADDRESS=\$3000" "-D SPRITE_ADDRESS=\$30000" -q -b -Wall -c -D "HARDWARE=0 $'\x9'$'\x9'$'\x9'$'\x9'$'\x9'$'\x9'" -L output/basic.lst -l output/basic.lbl -Wall -o basic.rom _basic.asm
; Sun Nov 27 11:30:43 2022

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=1					AUTORUN=1
=$e000					 MONITOR_ADDRESS=$E000
=$f000					 LOCKOUT_ADDRESS=$F000
=$38000					 BASIC_ADDRESS=$38000
=$3000					 SOURCE_ADDRESS=$3000
=$30000					 SPRITE_ADDRESS=$30000
=0					HARDWARE=0

;******  Processing input file: _basic.asm


;******  Processing file: ./common/aa.system/01common.inc

=$30					ZeroPageMandatory = $30
=$50					ZeroPagePreference = $50
=$400					MemoryStorage = $400
=$2000					BasicStart = $2000
=$8000					BasicEnd = $8000
=$8000					CodeStart = $8000
=$1000					VariableSpace = $1000
=$2000					EndVariableSpace = $2000
=8					MathStackSize = 8
=512					BasicStackSize = 512
=3584					BasicStackBase = $1000-BasicStackSize
=80					MaxLineSize = 80

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/02macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/04data.inc

.0030					codePtr:
>0030							.fill 	4
.0034					basicStack:
>0034							.fill 	2
.0036					zTemp0:
>0036							.fill 	2
.0038					zTemp1:
>0038							.fill 	2
.003a					zTemp2:
>003a							.fill 	2
.003c					zsTemp:
>003c							.fill 	2
.003e					zaTemp:
>003e							.fill 	2
=$30					safePtr = codePtr 							; minimise direct tinkering
=$80					NSBIsNegative = $80 						; bit 7 : sign of mantissa (where numeric)
=$20					NSBIsReference = $20 						; bit 5 : is a reference
=$10					NSBIsString = $10 							; bit 4 : set if string (procedures don't go on the stack)
=$18					NSBTypeMask = $18 							; bits 4,3 : 00 int 01 float 10 string 11 procedure
=$03					NSBRefMask = $03 							; bits 0,1 : Bytes of reference, -1 (e.g. 00 = 1 byte, 11 = 4 bytes)
=$04					NSBIsArray = $04
=$00					NSTInteger = $00 							; base types for bits 3..4
=$08					NSTFloat = $08
=$10					NSTString = $10
=$18					NSTProcedure = $18
.0050					NSStatus:
>0050							.fill 	MathStackSize
.0058					NSMantissa0:
>0058							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0060					NSMantissa1:
>0060							.fill 	MathStackSize
.0068					NSMantissa2:
>0068							.fill 	MathStackSize
.0070					NSMantissa3:
>0070							.fill 	MathStackSize
.0078					NSExponent:
>0078							.fill 	MathStackSize
.0400					identStart:
>0400							.fill 	1
.0401					identTypeStart:
>0401							.fill 	1
.0402					identTypeEnd:
>0402							.fill 	1
.0403					identHash:
>0403							.fill 	1
.0404					identTypeByte:
>0404							.fill 	1	 						; (see tokenising.pdf)
.0405					encodeState:
>0405							.fill 	1
.0406					digitTemp:
>0406							.fill 	1
.0407					decimalCount:
>0407							.fill 	1
.0408					randomSeed:
>0408							.fill 	4
.040c					lowMemPtr:
>040c							.fill 	2
.040e					stringMemory:
>040e							.fill 	2
.0410					stringInitialised:
>0410							.fill 	1
.0411					stringTempPointer:
>0411							.fill 	2
.0413					breakCheck:
>0413							.fill 	1
.0414					decimalPlaces:
>0414							.fill 	1
.0415					dbOffset:
>0415							.fill 	1
.0416					lastParameter:
>0416							.fill 	1
.0417					dataPointer:
>0417							.fill 	5
.041c					inDataStatement:
>041c							.fill 	1
.041d					tbOffset:
>041d							.fill 	1
.041e					AssemblerAddress:
>041e							.fill 	2
.0420					AssemblerControl:
>0420							.fill 	1
.0421					ParamStart:
>0421							.fill 	2
.0423					IsGroup1:
>0423							.fill 	1
.0424					BaseOpcode:
>0424							.fill 	1
.0425					ModeMask:
>0425							.fill 	1
.0426					listIndent:
>0426							.fill 	1
.0427					lcLastCharacter:
>0427							.fill 	1
.0428					isInputFlag:
>0428							.fill 	1
.0429					currentListColour:
>0429							.fill 	1
.042a					tokenOffset:
>042a							.fill 	1
.042b					tokenLineNumber:
>042b							.fill 	2
.042d					tokenBuffer:
>042d							.fill 	253
.052a					lineBuffer:
>052a							.fill 	MaxLineSize+1
.057b					numberBuffer:
>057b							.fill 	34
.059d					decimalBuffer:
>059d							.fill 	16

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/constants.inc

=$80					AM_ISZP = $80
=$40					AM_ISG1 = $40
=$20					AM_ISG2 = $20
=224					AM_IMMEDIATE = AM_ISZP+AM_ISG1+AM_ISG2+$00
=228					AM_ZEROPAGE = AM_ISZP+AM_ISG1+AM_ISG2+$04
=40					AM_ACC = AM_ISG2+$08
=108					AM_ABS = AM_ISG1+AM_ISG2+$0C
=208					AM_INDY = AM_ISZP+AM_ISG1+$10
=244					AM_ZEROX = AM_ISZP+AM_ISG1+AM_ISG2+$14
=120					AM_ABSY = AM_ISG1+AM_ISG2+$18
=124					AM_ABSX = AM_ISG1+AM_ISG2+$1C
=209					AM_IND = AM_ISZP+AM_ISG1+$11
=$80					AM_ZEROY = AM_ISZP
=$01					AM_INDABS = $01
=$02					AM_INDABSX = $02
=192					AM_INDX = AM_ISZP+AM_ISG1+$00

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/handlers.inc


;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.inc

=1					ERRID_BREAK = 1
=2					ERRID_SYNTAX = 2
=3					ERRID_DIVZERO = 3
=4					ERRID_RANGE = 4
=5					ERRID_TYPE = 5
=6					ERRID_MEMORY = 6
=7					ERRID_ARGUMENT = 7
=8					ERRID_STOP = 8
=9					ERRID_STRING = 9
=10					ERRID_ASSERT = 10
=11					ERRID_DATA = 11
=12					ERRID_NOTDONE = 12
=13					ERRID_LINE = 13
=14					ERRID_GOSUB = 14
=15					ERRID_REPEAT = 15
=16					ERRID_WHILE = 16
=17					ERRID_FOR = 17
=18					ERRID_STACK = 18
=19					ERRID_STRUCT = 19
=20					ERRID_PROC = 20
=21					ERRID_REDEFINE = 21
=22					ERRID_ARRAYSIZE = 22
=23					ERRID_ARRAYIDX = 23

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst.inc

=$00					KWD_LESSLESS                         = $00; $00 <<
=$01					KWD_LESSEQUAL                        = $01; $01 <=
=$02					KWD_LESSGREATER                      = $02; $02 <>
=$03					KWD_PLINGPLING3                      = $03; $03 !!3
=$04					KWD_GREATERLESS                      = $04; $04 ><
=$05					KWD_GREATEREQUAL                     = $05; $05 >=
=$06					KWD_GREATERGREATER                   = $06; $06 >>
=$07					KWD_PLINGPLING7                      = $07; $07 !!7
=$08					KWD_PLINGPLING8                      = $08; $08 !!8
=$09					KWD_PLINGPLING9                      = $09; $09 !!9
=$0a					KWD_PLINGPLING10                     = $0a; $0a !!10
=$0b					KWD_PLINGPLING11                     = $0b; $0b !!11
=$0c					KWD_PLINGPLING12                     = $0c; $0c !!12
=$0d					KWD_PLINGPLING13                     = $0d; $0d !!13
=$0e					KWD_PLINGPLING14                     = $0e; $0e !!14
=$0f					KWD_PLINGPLING15                     = $0f; $0f !!15
=$10					KWD_AT                               = $10; $10 @
=$11					KWD_PLINGPLING17                     = $11; $11 !!17
=$12					KWD_PLINGPLING18                     = $12; $12 !!18
=$13					KWD_LSQPAREN                         = $13; $13 [
=$14					KWD_BACKSLASH                        = $14; $14 \
=$15					KWD_RSQPAREN                         = $15; $15 ]
=$16					KWD_HAT                              = $16; $16 ^
=$17					KWD_UNDERSCORE                       = $17; $17 _
=$18					KWD_BQUOTE                           = $18; $18 `
=$19					KWD_PLINGPLING25                     = $19; $19 !!25
=$1a					KWD_PLINGPLING26                     = $1a; $1a !!26
=$1b					KWD_LCURLY                           = $1b; $1b {
=$1c					KWD_BAR                              = $1c; $1c |
=$1d					KWD_RCURLY                           = $1d; $1d }
=$1e					KWD_TILDE                            = $1e; $1e ~
=$21					KWD_PLING                            = $21; $21 !
=$22					KWD_DQUOTE                           = $22; $22 "
=$23					KWD_HASH                             = $23; $23 #
=$24					KWD_DOLLAR                           = $24; $24 $
=$25					KWD_PERCENT                          = $25; $25 %
=$26					KWD_AMPERSAND                        = $26; $26 &
=$27					KWD_QUOTE                            = $27; $27 '
=$28					KWD_LPAREN                           = $28; $28 (
=$29					KWD_RPAREN                           = $29; $29 )
=$2a					KWD_STAR                             = $2a; $2a *
=$2b					KWD_PLUS                             = $2b; $2b +
=$2c					KWD_COMMA                            = $2c; $2c ,
=$2d					KWD_MINUS                            = $2d; $2d -
=$2e					KWD_PERIOD                           = $2e; $2e .
=$2f					KWD_SLASH                            = $2f; $2f /
=$30					KWD_0                                = $30; $30 0
=$31					KWD_1                                = $31; $31 1
=$32					KWD_2                                = $32; $32 2
=$33					KWD_3                                = $33; $33 3
=$34					KWD_4                                = $34; $34 4
=$35					KWD_5                                = $35; $35 5
=$36					KWD_6                                = $36; $36 6
=$37					KWD_7                                = $37; $37 7
=$38					KWD_8                                = $38; $38 8
=$39					KWD_9                                = $39; $39 9
=$3a					KWD_COLON                            = $3a; $3a :
=$3b					KWD_SEMICOLON                        = $3b; $3b ;
=$3c					KWD_LESS                             = $3c; $3c <
=$3d					KWD_EQUAL                            = $3d; $3d =
=$3e					KWD_GREATER                          = $3e; $3e >
=$3f					KWD_QMARK                            = $3f; $3f ?
=$83					KWD_ABSLPAREN                        = $83; $83 ABS(
=$84					KWD_ALLOCLPAREN                      = $84; $84 ALLOC(
=$85					KWD_ASCLPAREN                        = $85; $85 ASC(
=$86					KWD_CHRDOLLARLPAREN                  = $86; $86 CHR$(
=$87					KWD_EVENTLPAREN                      = $87; $87 EVENT(
=$88					KWD_FALSE                            = $88; $88 FALSE
=$89					KWD_FRACLPAREN                       = $89; $89 FRAC(
=$8a					KWD_HITLPAREN                        = $8a; $8a HIT(
=$8b					KWD_INTLPAREN                        = $8b; $8b INT(
=$8c					KWD_ISVALLPAREN                      = $8c; $8c ISVAL(
=$8d					KWD_JOYBLPAREN                       = $8d; $8d JOYB(
=$8e					KWD_JOYXLPAREN                       = $8e; $8e JOYX(
=$8f					KWD_JOYYLPAREN                       = $8f; $8f JOYY(
=$90					KWD_LEFTDOLLARLPAREN                 = $90; $90 LEFT$(
=$91					KWD_LENLPAREN                        = $91; $91 LEN(
=$92					KWD_MAXLPAREN                        = $92; $92 MAX(
=$93					KWD_MIDDOLLARLPAREN                  = $93; $93 MID$(
=$94					KWD_MINLPAREN                        = $94; $94 MIN(
=$95					KWD_NOTLPAREN                        = $95; $95 NOT(
=$96					KWD_PLAYINGLPAREN                    = $96; $96 PLAYING(
=$97					KWD_RANDOMLPAREN                     = $97; $97 RANDOM(
=$98					KWD_RIGHTDOLLARLPAREN                = $98; $98 RIGHT$(
=$99					KWD_RNDLPAREN                        = $99; $99 RND(
=$9a					KWD_SGNLPAREN                        = $9a; $9a SGN(
=$9b					KWD_SPCLPAREN                        = $9b; $9b SPC(
=$9c					KWD_STRDOLLARLPAREN                  = $9c; $9c STR$(
=$9d					KWD_TIMERLPAREN                      = $9d; $9d TIMER(
=$9e					KWD_TRUE                             = $9e; $9e TRUE
=$9f					KWD_VALLPAREN                        = $9f; $9f VAL(
=$a0					KWD_FOR                              = $a0; $a0 FOR
=$a1					KWD_IF                               = $a1; $a1 IF
=$a2					KWD_PROC                             = $a2; $a2 PROC
=$a3					KWD_REPEAT                           = $a3; $a3 REPEAT
=$a4					KWD_WHILE                            = $a4; $a4 WHILE
=$a5					KWD_ENDIF                            = $a5; $a5 ENDIF
=$a6					KWD_ENDPROC                          = $a6; $a6 ENDPROC
=$a7					KWD_NEXT                             = $a7; $a7 NEXT
=$a8					KWD_THEN                             = $a8; $a8 THEN
=$a9					KWD_UNTIL                            = $a9; $a9 UNTIL
=$aa					KWD_WEND                             = $aa; $aa WEND
=$ab					KWD_BY                               = $ab; $ab BY
=$ac					KWD_CALL                             = $ac; $ac CALL
=$ad					KWD_CIRCLE                           = $ad; $ad CIRCLE
=$ae					KWD_CLEAR                            = $ae; $ae CLEAR
=$af					KWD_CLS                              = $af; $af CLS
=$b0					KWD_COLOR                            = $b0; $b0 COLOR
=$b1					KWD_COLOUR                           = $b1; $b1 COLOUR
=$b2					KWD_DATA                             = $b2; $b2 DATA
=$b3					KWD_DIM                              = $b3; $b3 DIM
=$b4					KWD_DOWNTO                           = $b4; $b4 DOWNTO
=$b5					KWD_ELSE                             = $b5; $b5 ELSE
=$b6					KWD_FROM                             = $b6; $b6 FROM
=$b7					KWD_GFX                              = $b7; $b7 GFX
=$b8					KWD_GOSUB                            = $b8; $b8 GOSUB
=$b9					KWD_GOTO                             = $b9; $b9 GOTO
=$ba					KWD_HERE                             = $ba; $ba HERE
=$bb					KWD_IMAGE                            = $bb; $bb IMAGE
=$bc					KWD_INPUT                            = $bc; $bc INPUT
=$bd					KWD_LET                              = $bd; $bd LET
=$be					KWD_LINE                             = $be; $be LINE
=$bf					KWD_LOCAL                            = $bf; $bf LOCAL
=$c0					KWD_OFF                              = $c0; $c0 OFF
=$c1					KWD_ON                               = $c1; $c1 ON
=$c2					KWD_OUTLINE                          = $c2; $c2 OUTLINE
=$c3					KWD_PALETTE                          = $c3; $c3 PALETTE
=$c4					KWD_PLOT                             = $c4; $c4 PLOT
=$c5					KWD_PRINT                            = $c5; $c5 PRINT
=$c6					KWD_READ                             = $c6; $c6 READ
=$c7					KWD_RECT                             = $c7; $c7 RECT
=$c8					KWD_REM                              = $c8; $c8 REM
=$c9					KWD_RETURN                           = $c9; $c9 RETURN
=$ca					KWD_SOLID                            = $ca; $ca SOLID
=$cb					KWD_SOUND                            = $cb; $cb SOUND
=$cc					KWD_SPRITE                           = $cc; $cc SPRITE
=$cd					KWD_TEXT                             = $cd; $cd TEXT
=$ce					KWD_TO                               = $ce; $ce TO

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst0.inc

=$80					KWC_EOL = $80
=$ff					KWC_STRING = $FF
=$fe					KWC_HEXCONST = $FE
=$a0					KWC_FIRST_STRUCTURE = $a0
=$a5					KWC_FIRST_STRUCTURE_DEC = $a5
=$aa					KWC_LAST_STRUCTURE = $aa
=$83					KWC_FIRST_UNARY = $83
=$9f					KWC_LAST_UNARY = $9f

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/access.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/stack.inc

=$e0					STK_GOSUB = $E0
=$d0					STK_FOR = $D0
=$c0					STK_REPEAT = $C0
=$b0					STK_PROC = $B0
=$a0					STK_WHILE = $A0
=$01					STK_LOCALN = $01
=$02					STK_LOCALS = $02

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/00start.asm

.8000	4c 24 80	jmp $8024	Boot:	jmp 	Start

;******  Processing file: ./common/aa.system/../../../modules/_build/_linker.module

.8003					EXTPrintCharacter:
.8003	4c 4f a7	jmp $a74f		jmp	Export_EXTPrintCharacter
.8006					EXTInitialise:
.8006	4c c3 a9	jmp $a9c3		jmp	Export_EXTInitialise
.8009					EXTInputSingleCharacter:
.8009	4c e5 a9	jmp $a9e5		jmp	Export_EXTInputSingleCharacter
.800c					EXTBreakCheck:
.800c	4c 05 aa	jmp $aa05		jmp	Export_EXTBreakCheck
.800f					EXTReadController:
.800f	4c 08 aa	jmp $aa08		jmp	Export_EXTReadController
.8012					EXTInputLine:
.8012	4c dd a8	jmp $a8dd		jmp	Export_EXTInputLine
.8015					GXGraphicDraw:
.8015	4c 4f aa	jmp $aa4f		jmp	Export_GXGraphicDraw
.8018					SNDCommand:
.8018	4c 59 b9	jmp $b959		jmp	Export_SNDCommand
.801b					SNDUpdate:
.801b	4c 8c b9	jmp $b98c		jmp	Export_SNDUpdate
.801e					TKListConvertLine:
.801e	4c 4f b3	jmp $b34f		jmp	Export_TKListConvertLine
.8021					TKTokeniseLine:
.8021	4c e3 b5	jmp $b5e3		jmp	Export_TKTokeniseLine

;******  Return to file: ./common/aa.system/00start.asm

.8024	a2 ff		ldx #$ff	Start:	ldx 	#$FF 						; stack reset
.8026	9a		txs				txs
.8027	20 06 80	jsr $8006			jsr 	EXTInitialise 				; hardware initialise
.802a	a2 80		ldx #$80			ldx 	#(Prompt >> 8) 				; prompt display
.802c	a9 46		lda #$46			lda 	#(Prompt & $FF)
.802e	20 21 8f	jsr $8f21			jsr 	PrintStringXA
.8031	a9 00		lda #$00			lda 	#0 							; graphics system initialise.
.8033	aa		tax				tax
.8034	a8		tay				tay
.8035	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.8038	a9 0f		lda #$0f			lda 	#$0F 						; initialise sound system
.803a	20 18 80	jsr $8018			jsr 	SNDCommand
.803d	20 b7 89	jsr $89b7			jsr 	NewProgram 					; erase current program
.8040	20 f6 82	jsr $82f6			jsr 	BackloadProgram
.8043	4c f3 8a	jmp $8af3			jmp 	CommandRun
>8046	0c 2a 2a 2a 20 46 32 35		Prompt:	.text 	12,"*** F256 Junior SuperBASIC ***",13,13
>804e	36 20 4a 75 6e 69 6f 72 20 53 75 70 65 72 42 41
>805e	53 49 43 20 2a 2a 2a 0d 0d

;******  Processing file: ./common/aa.system/../generated/timestamp.asm

>8067	52 65 6c 65 61 73 65 20			.text "Release Alpha 6 (26-Nov-22). "
>806f	41 6c 70 68 61 20 36 20 28 32 36 2d 4e 6f 76 2d
>807f	32 32 29 2e 20

;******  Return to file: ./common/aa.system/00start.asm

>8084	0d 0d 00					.byte 	13,13,0

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/assembler.asm

.8087					AssembleGroup1:
.8087	a9 ff		lda #$ff			lda 	#$FF
.8089	8d 25 04	sta $0425			sta 	ModeMask 					; initialise the mode mask - all for all
.808c	80 02		bra $8090			bra 	AsmGroup12
.808e					AssembleGroup2:
.808e	a9 00		lda #$00			lda 	#$00
.8090					AsmGroup12:
.8090	8d 23 04	sta $0423			sta 	IsGroup1 					; save the 'group 1' flag
.8093	68		pla				pla 								; pop the return address to access the information following.
.8094	fa		plx				plx
.8095	20 1c 81	jsr $811c			jsr 	AccessParameters 			; get opcode and save as base
.8098	8d 24 04	sta $0424			sta 	BaseOpcode
.809b	ad 23 04	lda $0423			lda 	IsGroup1 					; skip if group 1 as we don't have a complex mask.
.809e	d0 08		bne $80a8			bne 	_AG12HaveMask
.80a0	a9 02		lda #$02			lda 	#2 							; if group 2 the second parameter is the mask
.80a2	20 24 81	jsr $8124			jsr 	GetParameter		 		; e.g. which modes are supported for this operand
.80a5	8d 25 04	sta $0425			sta 	ModeMask
.80a8					_AG12HaveMask:
.80a8	20 58 82	jsr $8258			jsr 	TypeAndCalculateOperand 	; get zero page type
.80ab	da		phx				phx 								; save found address mode
.80ac	20 88 81	jsr $8188			jsr 	AssembleModeX
.80af	fa		plx				plx  								; restore address mode
.80b0	b0 0b		bcs $80bd			bcs 	_AG12Exit
.80b2	20 be 80	jsr $80be			jsr 	PromoteToAbsolute  			; promote ZP to ABS and try that
.80b5	20 88 81	jsr $8188			jsr 	AssembleModeX
.80b8	b0 03		bcs $80bd			bcs 	_AG12Exit
.80ba	4c 53 9f	jmp $9f53			jmp 	SyntaxError 				; can't do either, so must be wrong mode/operand.
.80bd					_AG12Exit:
.80bd	60		rts				rts
.80be					PromoteToAbsolute:
.80be	a9 6c		lda #$6c			lda 	#AM_ABS 					; lda xx
.80c0	e0 e4		cpx #$e4			cpx 	#AM_ZEROPAGE
.80c2	f0 19		beq $80dd			beq 	_PTADo
.80c4	a9 7c		lda #$7c			lda 	#AM_ABSX 					; lda xx,X
.80c6	e0 f4		cpx #$f4			cpx 	#AM_ZEROX
.80c8	f0 13		beq $80dd			beq 	_PTADo
.80ca	a9 78		lda #$78			lda 	#AM_ABSY 					; lda xx,Y
.80cc	e0 80		cpx #$80			cpx 	#AM_ZEROY
.80ce	f0 0d		beq $80dd			beq 	_PTADo
.80d0	a9 01		lda #$01			lda 	#AM_INDABS 					; lda (xx) (jump)
.80d2	e0 d1		cpx #$d1			cpx 	#AM_IND
.80d4	f0 07		beq $80dd			beq 	_PTADo
.80d6	a9 02		lda #$02			lda 	#AM_INDABSX 				; lda (xx,x) (jump)
.80d8	e0 c0		cpx #$c0			cpx 	#AM_INDX
.80da	f0 01		beq $80dd			beq 	_PTADo
.80dc	60		rts				rts
.80dd					_PTADo:
.80dd	aa		tax				tax
.80de	60		rts				rts
.80df					AssembleGroup3:
.80df	68		pla				pla 								; get parameters, which is just the opcode.
.80e0	fa		plx				plx
.80e1	20 1c 81	jsr $811c			jsr 	AccessParameters 			; get and output opcode
.80e4	20 34 81	jsr $8134			jsr 	AssemblerWriteByte
.80e7	20 bc 82	jsr $82bc			jsr 	CalculateOperand 			; get a 16 bit operand
.80ea	a5 58		lda $58				lda 	NSMantissa0 				; calculate the offset
.80ec	38		sec				sec
.80ed	ed 1e 04	sbc $041e			sbc 	AssemblerAddress
.80f0	48		pha				pha 								; LSB in A
.80f1	a5 60		lda $60				lda 	NSMantissa1
.80f3	ed 1f 04	sbc $041f			sbc 	AssemblerAddress+1
.80f6	aa		tax				tax 								; MSB in X
.80f7	68		pla				pla
.80f8	18		clc				clc 								; $80 to easy check $80-$7F, plus 1 for offset error
.80f9	69 7f		adc #$7f			adc 	#$7F
.80fb	90 01		bcc $80fe			bcc 	_AG3NoCarry
.80fd	e8		inx				inx
.80fe					_AG3NoCarry:
.80fe	38		sec				sec 								; fix back and write out anyways.
.80ff	e9 80		sbc #$80			sbc 	#$80
.8101	20 34 81	jsr $8134			jsr 	AssemblerWriteByte
.8104	e0 00		cpx #$00			cpx 	#0 							; was it in range
.8106	f0 0a		beq $8112			beq 	_AG3Exit
.8108	ad 20 04	lda $0420			lda 	AssemblerControl 			; are we allowing bad values ?
.810b	29 01		and #$01			and 	#1
.810d	f0 03		beq $8112			beq 	_AG3Exit
.810f	4c 58 9f	jmp $9f58			jmp 	RangeError 					; no, branch is out of range
.8112					_AG3Exit:
.8112	60		rts				rts
.8113					AssembleGroup4:
.8113	68		pla				pla 								; pop address
.8114	fa		plx				plx
.8115	20 1c 81	jsr $811c			jsr 	AccessParameters 			; access and get first
.8118	20 34 81	jsr $8134			jsr 	AssemblerWriteByte 			; output it.
.811b	60		rts				rts
.811c					AccessParameters:
.811c	8d 21 04	sta $0421			sta 	ParamStart
.811f	8e 22 04	stx $0422			stx 	ParamStart+1
.8122	a9 01		lda #$01			lda 	#1
.8124					GetParameter:
.8124	5a		phy				phy
.8125	a8		tay				tay
.8126	ad 21 04	lda $0421			lda 	ParamStart
.8129	85 36		sta $36				sta 	zTemp0
.812b	ad 22 04	lda $0422			lda 	ParamStart+1
.812e	85 37		sta $37				sta 	zTemp0+1
.8130	b1 36		lda ($36),y			lda 	(zTemp0),y
.8132	7a		ply				ply
.8133	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/aswrite.asm

.8134					AssemblerWriteByte:
.8134	48		pha			pha
.8135	ad 20 04	lda $0420		lda 	AssemblerControl 				; check printing bytes ?
.8138	29 02		and #$02		and 	#2
.813a	f0 1b		beq $8157		beq 	_AWBNoPrint
.813c	ad 1f 04	lda $041f		lda		AssemblerAddress+1 				; print address
.813f	20 72 81	jsr $8172		jsr 	PrintHex
.8142	ad 1e 04	lda $041e		lda		AssemblerAddress
.8145	20 72 81	jsr $8172		jsr 	PrintHex
.8148	a9 20		lda #$20		lda 	#' '
.814a	20 03 80	jsr $8003		jsr 	EXTPrintCharacter
.814d	68		pla			pla 									; print byte
.814e	48		pha			pha
.814f	20 72 81	jsr $8172		jsr 	PrintHex
.8152	a9 0d		lda #$0d		lda 	#13
.8154	20 03 80	jsr $8003		jsr 	EXTPrintCharacter
.8157					_AWBNoPrint:
.8157	ad 1e 04	lda $041e		lda		AssemblerAddress				; copy address to zTemp0
.815a	85 36		sta $36			sta 	zTemp0
.815c	ad 1f 04	lda $041f		lda		AssemblerAddress+1
.815f	f0 0e		beq $816f		beq 	_AWBRange
.8161	85 37		sta $37			sta 	zTemp0+1
.8163	68		pla			pla 									; write byte out
.8164	92 36		sta ($36)		sta 	(zTemp0)
.8166	ee 1e 04	inc $041e		inc 	AssemblerAddress 				; bump address
.8169	d0 03		bne $816e		bne 	_AWBNoCarry
.816b	ee 1f 04	inc $041f		inc 	AssemblerAddress+1
.816e					_AWBNoCarry:
.816e	60		rts			rts
.816f					_AWBRange:
.816f	4c 58 9f	jmp $9f58		jmp 	RangeError
.8172					PrintHex:
.8172	48		pha				pha
.8173	4a		lsr a				lsr 	a
.8174	4a		lsr a				lsr 	a
.8175	4a		lsr a				lsr 	a
.8176	4a		lsr a				lsr 	a
.8177	20 7b 81	jsr $817b			jsr 	_PrintNibble
.817a	68		pla				pla
.817b					_PrintNibble:
.817b	29 0f		and #$0f			and 	#15
.817d	c9 0a		cmp #$0a			cmp 	#10
.817f	90 02		bcc $8183			bcc 	_NoShift
.8181	69 06		adc #$06			adc 	#6
.8183					_NoShift:
.8183	69 30		adc #$30			adc 	#48
.8185	4c 03 80	jmp $8003			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/instruction.asm

.8188					AssembleModeX:
.8188	5a		phy				phy
.8189	ad 23 04	lda $0423			lda 	IsGroup1
.818c	f0 17		beq $81a5			beq 	_AMXGroup2
.818e	8a		txa				txa 							; is it in group # 1
.818f	29 40		and #$40			and 	#AM_ISG1
.8191	f0 4d		beq $81e0			beq 	_AMXFail 				; no, give up.
.8193	8a		txa				txa 							; get back.
.8194	29 1f		and #$1f			and 	#$1F 					; this is now the offset.
.8196	e0 e0		cpx #$e0			cpx 	#AM_IMMEDIATE 			; if not immediate, we can continue.
.8198	d0 22		bne $81bc			bne 	_AMXHaveInfo
.819a	ad 24 04	lda $0424			lda 	BaseOpcode 				; cannot store immediate.
.819d	c9 81		cmp #$81			cmp 	#$81
.819f	f0 3f		beq $81e0			beq 	_AMXFail
.81a1	a9 08		lda #$08			lda 	#8 						; if immediate we use offset 8.
.81a3	80 17		bra $81bc			bra 	_AMXHaveInfo 			; odd design decision there.
.81a5					_AMXGroup2:
.81a5	8a		txa				txa 							; is it in group 2 ?
.81a6	29 20		and #$20			and 	#AM_ISG2
.81a8	f0 36		beq $81e0			beq 	_AMXFail 				; no, give up.
.81aa	8a		txa				txa 							; get the offset into Y
.81ab	29 1f		and #$1f			and 	#$1F
.81ad	4a		lsr a				lsr 	a 						; make it 0-7.
.81ae	4a		lsr a				lsr  	a
.81af	a8		tay				tay
.81b0	ad 25 04	lda $0425			lda 	ModeMask 				; shift the modemask left so you can check it against the requested offset
.81b3					_AMXCheckOkay:
.81b3	0a		asl a				asl 	a 						; shift modemask left enough times to check legitimate.
.81b4	88		dey				dey
.81b5	10 fc		bpl $81b3			bpl 	_AMXCheckOkay
.81b7	90 27		bcc $81e0			bcc 	_AMXFail 				; not allowed.
.81b9	8a		txa				txa  							; get mask back
.81ba	29 1f		and #$1f			and 	#$1F
.81bc					_AMXHaveInfo:
.81bc	e0 00		cpx #$00			cpx 	#$00 					; does it *require* an 8 bit operand
.81be	10 04		bpl $81c4			bpl 	_AMXAnySize 			; checking bit 7, the zero page opcode flag.
.81c0	a4 60		ldy $60				ldy 	NSMantissa1 			; fail if it is outside range, e.g. the MSB is set.
.81c2	d0 1c		bne $81e0			bne 	_AMXFail
.81c4					_AMXAnySize:
.81c4	18		clc				clc 							; add offset to the base opcode
.81c5	6d 24 04	adc $0424			adc 	BaseOpcode
.81c8					_AMXOutputCode:
.81c8	20 34 81	jsr $8134			jsr 	AssemblerWriteByte 		; write the opcode out.
.81cb	e0 28		cpx #$28			cpx 	#AM_ACC 				; A mode (e.g. ASL A)
.81cd	f0 0e		beq $81dd			beq 	_AMXExit
.81cf	a5 58		lda $58				lda 	NSMantissa0 				; write LSB operand
.81d1	20 34 81	jsr $8134			jsr 	AssemblerWriteByte
.81d4	e0 00		cpx #$00			cpx 	#$00 					; zeropage ?
.81d6	30 05		bmi $81dd			bmi 	_AMXExit
.81d8	a5 60		lda $60				lda 	NSMantissa1 			; write MSB operand
.81da	20 34 81	jsr $8134			jsr 	AssemblerWriteByte
.81dd					_AMXExit:
.81dd	7a		ply				ply
.81de	38		sec				sec
.81df	60		rts				rts
.81e0					_AMXFail:
.81e0	a0 00		ldy #$00			ldy 	#0
.81e2					_AMXCheckOddities:
.81e2	8a		txa				txa
.81e3	d9 0a 82	cmp $820a,y			cmp 	ExtraOpcode+2,y 		; match address mode
.81e6	d0 15		bne $81fd			bne 	_AMXCONext
.81e8	b9 08 82	lda $8208,y			lda 	ExtraOpcode+0,y 		; do the base opcodes match
.81eb	cd 24 04	cmp $0424			cmp 	BaseOpcode
.81ee	d0 0d		bne $81fd			bne 	_AMXCONext
.81f0	e0 00		cpx #$00			cpx 	#$00 					; requires zero page ?
.81f2	10 04		bpl $81f8			bpl 	_AMXCONotZero
.81f4	a5 60		lda $60				lda 	NSMantissa1
.81f6	d0 05		bne $81fd			bne 	_AMXCONext
.81f8					_AMXCONotZero:
.81f8	b9 09 82	lda $8209,y			lda 	ExtraOpcode+1,y 		; get new opcode
.81fb	80 cb		bra $81c8			bra 	_AMXOutputCode 			; and assemble it
.81fd					_AMXCONext:
.81fd	c8		iny				iny
.81fe	c8		iny				iny
.81ff	c8		iny				iny
.8200	b9 08 82	lda $8208,y			lda 	ExtraOpcode+0,y 		; end of table
.8203	d0 dd		bne $81e2			bne 	_AMXCheckOddities
.8205					_AMXCOFail:
.8205	7a		ply				ply
.8206	18		clc				clc
.8207	60		rts				rts
.8208					ExtraOpcode:
>8208	40 6c 01					.byte $40,$6c,AM_INDABS 	; jump
>820b	40 7c 02					.byte $40,$7C,AM_INDABSX 	; jump
>820e	a2 be 78					.byte $a2,$BE,AM_ABSY 		; ldx
>8211	a2 b6 80					.byte $a2,$B6,AM_ZEROY 		; ldx
>8214	82 96 80					.byte $82,$96,AM_ZEROY 		; stx
>8217	e2 1a 28					.byte $e2,$1a,AM_ACC 		; inc
>821a	c2 3a 28					.byte $c2,$3a,AM_ACC 		; dec
>821d	20 89 e0					.byte $20,$89,AM_IMMEDIATE 	; bit
>8220	60 9c 6c					.byte $60,$9c,AM_ABS 		; stz
>8223	60 9e 7c					.byte $60,$9e,AM_ABSX 		; stz
>8226	00						.byte $00

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/label.asm

.8227					LabelHere:
.8227	c8		iny				iny 								; skip .
.8228	a2 00		ldx #$00			ldx 	#0 							; get a term
.822a	20 16 98	jsr $9816			jsr 	EvaluateTerm 				; get a term
.822d	a5 50		lda $50				lda 	NSStatus 					; needs to be an integer reference.
.822f	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.8231	d0 22		bne $8255			bne 	_ALType
.8233	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy reference address to zTemp0
.8235	85 36		sta $36				sta 	zTemp0
.8237	b5 60		lda $60,x			lda 	NSMantissa1,x
.8239	85 37		sta $37				sta 	zTemp0+1
.823b	5a		phy				phy 								; copy address in.
.823c	a0 01		ldy #$01			ldy 	#1
.823e	ad 1e 04	lda $041e			lda	 	AssemblerAddress
.8241	92 36		sta ($36)			sta 	(zTemp0)
.8243	ad 1f 04	lda $041f			lda	 	AssemblerAddress+1
.8246	91 36		sta ($36),y			sta 	(zTemp0),y
.8248	c8		iny				iny
.8249	a9 00		lda #$00			lda 	#0
.824b	91 36		sta ($36),y			sta 	(zTemp0),y
.824d	c8		iny				iny
.824e	91 36		sta ($36),y			sta 	(zTemp0),y
.8250	c8		iny				iny
.8251	91 36		sta ($36),y			sta 	(zTemp0),y
.8253	7a		ply				ply
.8254	60		rts				rts
.8255					_ALType:
.8255	4c 5d 9f	jmp $9f5d			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/operands.asm

.8258					TypeAndCalculateOperand:
.8258	b1 30		lda ($30),y			lda 	(codePtr),y
.825a	a2 28		ldx #$28			ldx 	#AM_ACC 					; ACC if : or EOL
.825c	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.825e	f0 5b		beq $82bb			beq 	_TACOExit
.8260	c9 80		cmp #$80			cmp 	#KWC_EOL
.8262	f0 57		beq $82bb			beq 	_TACOExit
.8264	c8		iny				iny
.8265	a2 e0		ldx #$e0			ldx 	#AM_IMMEDIATE
.8267	c9 23		cmp #$23			cmp 	#KWD_HASH 					; if hash, then immediate - constant.
.8269	f0 51		beq $82bc			beq 	CalculateOperand
.826b	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; if ( then check for indirection
.826d	f0 1f		beq $828e			beq 	_TACOIndirect
.826f	88		dey				dey 								; undo get of first character
.8270	20 bc 82	jsr $82bc			jsr 	CalculateOperand 			; get operand
.8273	b1 30		lda ($30),y			lda 	(codePtr),y
.8275	a2 e4		ldx #$e4			ldx 	#AM_ZEROPAGE 				; if not, try zero page (then absolute)
.8277	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8279	d0 40		bne $82bb			bne 	_TACOExit
.827b	c8		iny				iny
.827c	20 c6 82	jsr $82c6			jsr 	TACOCheckXY 				; extract X,Y or 0 (neither) from the variable.
.827f	a2 f4		ldx #$f4			ldx 	#AM_ZEROX 					; check for X
.8281	c9 58		cmp #$58			cmp 	#'X'
.8283	f0 36		beq $82bb			beq 	_TACOExit
.8285	a2 80		ldx #$80			ldx 	#AM_ZEROY 					; check for Y
.8287	c9 59		cmp #$59			cmp 	#'Y'
.8289	f0 30		beq $82bb			beq 	_TACOExit
.828b					_TACOSyntax:
.828b	4c 53 9f	jmp $9f53			jmp 	SyntaxError
.828e					_TACOIndirect:
.828e	20 bc 82	jsr $82bc			jsr 	CalculateOperand 			; get the operand
.8291	b1 30		lda ($30),y			lda 	(codePtr),y
.8293	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if , then it must be ,X)
.8295	f0 17		beq $82ae			beq 	_TACOIndX
.8297	20 af 8e	jsr $8eaf			jsr 	CheckRightBracket  			; otherwise must be ) or ),Y
.829a	b1 30		lda ($30),y			lda 	(codePtr),y
.829c	a2 d1		ldx #$d1			ldx 	#AM_IND
.829e	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not comma then exit with (xx)
.82a0	d0 19		bne $82bb			bne 	_TACOExit
.82a2	c8		iny				iny
.82a3	20 c6 82	jsr $82c6			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.82a6	c9 59		cmp #$59			cmp 	#'Y' 						; check Y
.82a8	d0 e1		bne $828b			bne 	_TACOSyntax
.82aa	a2 d0		ldx #$d0			ldx 	#AM_INDY
.82ac	80 0d		bra $82bb			bra 	_TACOExit
.82ae					_TACOIndX:
.82ae	c8		iny				iny
.82af	20 c6 82	jsr $82c6			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.82b2	c9 58		cmp #$58			cmp 	#'X' 						; check X
.82b4	d0 d5		bne $828b			bne 	_TACOSyntax
.82b6	20 af 8e	jsr $8eaf			jsr 	CheckRightBracket			; check )
.82b9	a2 c0		ldx #$c0			ldx 	#AM_INDX
.82bb					_TACOExit:
.82bb	60		rts				rts
.82bc					CalculateOperand:
.82bc	48		pha				pha
.82bd	da		phx				phx
.82be	a2 00		ldx #$00			ldx 	#0 							; get 16 bit integer in Slot 0
.82c0	20 55 9d	jsr $9d55			jsr 	Evaluate16BitInteger
.82c3	fa		plx				plx
.82c4	68		pla				pla
.82c5	60		rts				rts
.82c6					TACOCheckXY:
.82c6	b1 30		lda ($30),y			lda 	(codePtr),y
.82c8	29 c0		and #$c0			and 	#$C0 						; check it is an identifier reference.
.82ca	c9 40		cmp #$40			cmp 	#$40
.82cc	d0 21		bne $82ef			bne 	_TCXYFail
.82ce	b1 30		lda ($30),y			lda 	(codePtr),y
.82d0	18		clc				clc
.82d1	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.82d3	85 37		sta $37				sta 	zTemp0+1
.82d5	c8		iny				iny
.82d6	b1 30		lda ($30),y			lda 	(codePtr),y
.82d8	c8		iny				iny
.82d9	85 36		sta $36				sta 	zTemp0
.82db	5a		phy				phy 								; save position
.82dc	a0 02		ldy #$02			ldy 	#2 							; type is integer ?
.82de	b1 36		lda ($36),y			lda 	(zTemp0),y
.82e0	d0 0c		bne $82ee			bne 	_TCXYPopFail
.82e2	a0 08		ldy #$08			ldy 	#8 							; get first character, should have bit 7 set as also last.
.82e4	b1 36		lda ($36),y			lda 	(zTemp0),y
.82e6	c9 d8		cmp #$d8			cmp 	#'X'+$80 					; should be X or Y
.82e8	f0 08		beq $82f2			beq 	_TCXYFound
.82ea	c9 d9		cmp #$d9			cmp 	#'Y'+$80
.82ec	f0 04		beq $82f2			beq 	_TCXYFound
.82ee					_TCXYPopFail:
.82ee	7a		ply				ply
.82ef					_TCXYFail:
.82ef	a9 00		lda #$00			lda 	#0
.82f1	60		rts				rts
.82f2					_TCXYFound:
.82f2	7a		ply				ply 								; restore position
.82f3	29 7f		and #$7f			and 	#$7F 						; throw bit 7
.82f5	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/backload.asm

.82f6					BackloadProgram:
.82f6	a2 83		ldx #$83			ldx 	#_BLLoad >> 8
.82f8	a9 3d		lda #$3d			lda 	#_BLLoad & $FF
.82fa	20 21 8f	jsr $8f21			jsr 	PrintStringXA
.82fd	a9 00		lda #$00			lda 	#((SOURCE_ADDRESS) & $FF)
.82ff	8d ad 05	sta $05ad			sta 	0+BackLoadPointer
.8302	a9 30		lda #$30			lda 	#((SOURCE_ADDRESS) >> 8)
.8304	8d ae 05	sta $05ae			sta 	1+BackLoadPointer
.8307	a9 ff		lda #$ff			lda 	#$FF
.8309	8d fa ff	sta $fffa			sta 	$FFFA
.830c					_BPLoop:
.830c	a2 ff		ldx #$ff			ldx 	#$FF
.830e	20 52 83	jsr $8352			jsr 	BLReadByte 					; read a byte
.8311	c9 00		cmp #$00			cmp 	#0
.8313	f0 21		beq $8336			beq 	_BPExit 					; if 0 exit
.8315	30 1f		bmi $8336			bmi 	_BPExit 					; if -ve exit
.8317					_BPCopy:
.8317	e8		inx				inx  								; copy byte into the lineBuffer
.8318	9d 2a 05	sta $052a,x			sta 	lineBuffer,x
.831b	9e 2b 05	stz $052b,x			stz 	lineBuffer+1,x
.831e	20 52 83	jsr $8352			jsr 	BLReadByte 					; read next byte
.8321	30 0a		bmi $832d			bmi 	_BPEndLine 					; -ve = EOL
.8323	c9 09		cmp #$09			cmp 	#9 							; handle TAB, make it space.
.8325	d0 02		bne $8329			bne 	_BPNotTab
.8327	a9 20		lda #$20			lda 	#' '
.8329					_BPNotTab:
.8329	c9 20		cmp #$20			cmp 	#' ' 						; < ' ' = EOL
.832b	b0 ea		bcs $8317			bcs 	_BPCopy 					; until a control character, should be 13 received.
.832d					_BPEndLine:
.832d	20 21 80	jsr $8021			jsr 	TKTokeniseLine 				; tokenise the line.
.8330	ea		nop				nop
.8331	20 69 83	jsr $8369			jsr 	EditProgramCode
.8334	80 d6		bra $830c			bra 	_BPLoop
.8336					_BPExit:
.8336	9c fa ff	stz $fffa			stz 	$FFFA
.8339	20 24 84	jsr $8424			jsr 	ClearCommand 				; clear variables etc.
.833c	60		rts				rts
.833d					_BLLoad:
>833d	4c 6f 61 64 69 6e 67 20				.text 	"Loading from Memory",13,0
>8345	66 72 6f 6d 20 4d 65 6d 6f 72 79 0d 00
.8352					BLReadByte:
.8352	ad ad 05	lda $05ad			lda 	BackLoadPointer 			; copy pointer to zTemp0
.8355	85 36		sta $36				sta 	zTemp0
.8357	ad ae 05	lda $05ae			lda 	BackLoadPointer+1
.835a	85 37		sta $37				sta 	zTemp0+1
.835c	b2 36		lda ($36)			lda 	(zTemp0) 					; read next byte
.835e	ee ad 05	inc $05ad			inc 	BackLoadPointer 			; bump pointer
.8361	d0 03		bne $8366			bne 	_BLNoCarry
.8363	ee ae 05	inc $05ae			inc 	BackLoadPointer+1
.8366					_BLNoCarry:
.8366	c9 00		cmp #$00			cmp 	#0
.8368	60		rts				rts
.05ad					BackLoadPointer:
>05ad							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/editor.asm

.8369					EditProgramCode:
.8369	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; find the line.
.836c	ae 2c 04	ldx $042c			ldx 	TokenLineNumber+1
.836f	20 41 a5	jsr $a541			jsr 	MemorySearch
.8372	90 05		bcc $8379			bcc 	_EPCNoDelete 				; reached the end don't delete
.8374	d0 03		bne $8379			bne 	_EPCNoDelete 				; found slot but didn't match, no delete
.8376	20 66 a4	jsr $a466			jsr 	MemoryDeleteLine 			; delete the line
.8379					_EPCNoDelete:
.8379	ad 2d 04	lda $042d			lda 	TokenBuffer 				; buffer empty
.837c	c9 80		cmp #$80			cmp 	#KWC_EOL
.837e	f0 0d		beq $838d			beq 	_EPCNoInsert
.8380	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; find the line - it cannot exist.
.8383	ae 2c 04	ldx $042c			ldx 	TokenLineNumber+1 			; so this can't fail, it returns some point in the code.
.8386	20 41 a5	jsr $a541			jsr 	MemorySearch
.8389	18		clc				clc 								; insert at this point.
.838a	20 9d a4	jsr $a49d			jsr 	MemoryInsertLine 			; insert the line
.838d					_EPCNoInsert:
.838d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/warmstart.asm

.838e					WarmStart:
.838e	a2 ff		ldx #$ff			ldx 	#$FF
.8390	9a		txs				txs
.8391	a9 85		lda #$85			lda 	#CLICommandLine+$80 		; set console colour
.8393	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8396	20 12 80	jsr $8012			jsr 	EXTInputLine 				; get line to lineBuffer
.8399	20 21 80	jsr $8021			jsr 	TKTokeniseLine 				; tokenise the line
.839c	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; line number ?
.839f	0d 2c 04	ora $042c			ora 	TokenLineNumber+1
.83a2	d0 17		bne $83bb			bne 	_WSEditCode 				; if so,edit code.
.83a4	9c 2a 04	stz $042a			stz 	TokenOffset 				; zero offset, meaning it only runs one line.
.83a7	a9 2a		lda #$2a			lda 	#((TokenOffset) & $FF)
.83a9	85 30		sta $30				sta 	codePtr
.83ab	a9 04		lda #$04			lda 	#((TokenOffset) >> 8)
.83ad	85 31		sta $31				sta 	codePtr+1
.83af	ad 2d 04	lda $042d			lda 	TokenBuffer 				; nothing to run
.83b2	c9 80		cmp #$80			cmp 	#KWC_EOL
.83b4	f0 d8		beq $838e			beq 	WarmStart
.83b6	20 05 8b	jsr $8b05			jsr 	RUNCodePointerLine 			; execute that line.
.83b9	80 d3		bra $838e			bra 	WarmStart
.83bb					_WSEditCode:
.83bb	20 69 83	jsr $8369			jsr 	EditProgramCode
.83be	20 24 84	jsr $8424			jsr 	ClearCommand
.83c1	80 cb		bra $838e			bra 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assemble.asm

.83c3					AssembleCommand:
.83c3	a2 00		ldx #$00			ldx 	#0
.83c5	20 55 9d	jsr $9d55			jsr 	Evaluate16BitInteger 		; start address
.83c8	a5 58		lda $58				lda 	NSMantissa0
.83ca	8d 1e 04	sta $041e			sta 	AssemblerAddress
.83cd	a5 60		lda $60				lda 	NSMantissa1
.83cf	8d 1f 04	sta $041f			sta 	AssemblerAddress+1
.83d2	20 b7 8e	jsr $8eb7			jsr 	CheckComma
.83d5	20 70 9d	jsr $9d70			jsr 	Evaluate8BitInteger 		; options
.83d8	a5 58		lda $58				lda 	NSMantissa0
.83da	8d 20 04	sta $0420			sta 	AssemblerControl
.83dd	60		rts				rts
.83de	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assert.asm

.83df					AssertCommand:
.83df	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.83e1	20 42 9d	jsr $9d42			jsr 	EvaluateInteger 			; the assert test
.83e4	20 f7 9d	jsr $9df7			jsr 	NSMIsZero 					; exit if result is non zero.
.83e7	d0 05		bne $83ee			bne 	_ACExit
.83e9	a9 0a		lda #$0a		lda	#10
.83eb	4c c8 8e	jmp $8ec8		jmp	ErrorHandler
.83ee					_ACExit:
.83ee	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/call.asm

.83ef					CallCommand:
.83ef	a2 00		ldx #$00			ldx 	#0 							; get the routine address to level 0
.83f1	20 55 9d	jsr $9d55			jsr 	Evaluate16BitInteger
.83f4					_CCClear
.83f4	e8		inx				inx  								; clear 1,2 and 3 (for A X Y)
.83f5	20 d5 9d	jsr $9dd5			jsr 	NSMSetZero 					; these are optional sequentially.
.83f8	e0 04		cpx #$04			cpx 	#4
.83fa	d0 f8		bne $83f4			bne 	_CCClear
.83fc	a2 00		ldx #$00			ldx 	#0 							; and keep trying while there are more values.
.83fe					_CCCParam:
.83fe	b1 30		lda ($30),y			lda 	(codePtr),y
.8400	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8402	d0 09		bne $840d			bne 	_CCCRun6502
.8404	c8		iny				iny 								; skip comma
.8405	e8		inx				inx	 								; next level
.8406	20 70 9d	jsr $9d70			jsr 	Evaluate8BitInteger 		; get A/X/Y
.8409	e0 03		cpx #$03			cpx 	#3
.840b	90 f1		bcc $83fe			bcc 	_CCCParam 					; done all 3 ?
.840d					_CCCRun6502:
.840d	5a		phy				phy 								; save position
.840e	a5 60		lda $60				lda 	NSMantissa1 				; put address in zTemp0
.8410	85 37		sta $37				sta 	zTemp0+1
.8412	a5 58		lda $58				lda 	NSMantissa0
.8414	85 36		sta $36				sta 	zTemp0
.8416	a5 59		lda $59				lda 	NSMantissa0+1 				; get registers into A X Y
.8418	a6 5a		ldx $5a				ldx 	NSMantissa0+2
.841a	a4 5b		ldy $5b				ldy 	NSMantissa0+3
.841c	20 21 84	jsr $8421			jsr 	_CCCZTemp0 					; call zTemp0
.841f	7a		ply				ply 								; restore position and exit
.8420	60		rts				rts
.8421					_CCCZTemp0:
.8421	6c 36 00	jmp ($0036)			jmp 	(zTemp0)

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/clear.asm

.8424					ClearCommand:
.8424	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.8426	85 36		sta $36				sta 	0+zTemp0
.8428	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.842a	85 37		sta $37				sta 	1+zTemp0
.842c					_ClearZeroLoop:
.842c	b2 36		lda ($36)			lda 	(zTemp0) 					; end of variables if offset is zero.
.842e	f0 24		beq $8454			beq 	_ClearZeroEnd
.8430	a0 03		ldy #$03			ldy 	#3 							; erase the variables
.8432	a9 00		lda #$00			lda 	#0 							; set all the data to zero.
.8434					_ClearOneVariable:
.8434	91 36		sta ($36),y			sta 	(zTemp0),y
.8436	c8		iny				iny
.8437	c0 08		cpy #$08			cpy 	#8
.8439	d0 f9		bne $8434			bne 	_ClearOneVariable
.843b	a0 02		ldy #$02			ldy 	#2 							; has it been marked procedure
.843d	b1 36		lda ($36),y			lda 	(zTemp0),y
.843f	c9 18		cmp #$18			cmp 	#NSTProcedure
.8441	d0 04		bne $8447			bne 	_ClearNotProcedure
.8443	a9 04		lda #$04			lda 	#NSTInteger+NSBIsArray 		; if so set it back to an integer array
.8445	91 36		sta ($36),y			sta 	(zTemp0),y 					; will be fixed on the pre-run scan.
.8447					_ClearNotProcedure:
.8447	18		clc				clc 								; go to the next variable
.8448	b2 36		lda ($36)			lda 	(zTemp0) 					; offset to next, add to zTemp0
.844a	65 36		adc $36				adc 	zTemp0
.844c	85 36		sta $36				sta 	zTemp0
.844e	90 dc		bcc $842c			bcc 	_ClearZeroLoop
.8450	e6 37		inc $37				inc 	zTemp0+1
.8452	80 d8		bra $842c			bra 	_ClearZeroLoop
.8454					_ClearZeroEnd:
.8454	18		clc				clc
.8455	a5 36		lda $36				lda 	zTemp0
.8457	69 01		adc #$01			adc 	#1
.8459	8d 0c 04	sta $040c			sta 	lowMemPtr
.845c	a5 37		lda $37				lda 	zTemp0+1
.845e	69 00		adc #$00			adc 	#0
.8460	8d 0d 04	sta $040d			sta 	lowMemPtr+1
.8463	20 7d a6	jsr $a67d			jsr 	StackReset
.8466	20 e3 a6	jsr $a6e3			jsr 	StringSystemInitialise
.8469	20 55 8d	jsr $8d55			jsr 	ProcedureScan
.846c	20 b4 8a	jsr $8ab4			jsr 	Command_Restore
.846f	9c 1e 04	stz $041e			stz 	AssemblerAddress
.8472	9c 1f 04	stz $041f			stz 	AssemblerAddress+1
.8475	9c 20 04	stz $0420			stz 	AssemblerControl
.8478	20 fd 99	jsr $99fd			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.847b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/cls.asm

.847c					ClearScreen:
.847c	5a		phy				phy
.847d	a9 0c		lda #$0c			lda 	#12 						; char code 12 clears the screen.
.847f	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8482	7a		ply				ply
.8483	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/data.asm

.8484					Command_Data:
.8484	a9 3a		lda #$3a			lda 	#KWD_COLON 					; advance to colon/EOL
.8486	a2 80		ldx #$80			ldx 	#KWC_EOL
.8488	20 a7 8d	jsr $8da7			jsr 	ScanForward
.848b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dim.asm

.848c					DimCommand:
.848c	b1 30		lda ($30),y			lda 	(codePtr),y
.848e	29 c0		and #$c0			and 	#$C0
.8490	c9 40		cmp #$40			cmp 	#$40
.8492	d0 7a		bne $850e			bne 	_DCSyntax
.8494	b1 30		lda ($30),y			lda 	(codePtr),y
.8496	18		clc				clc
.8497	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8499	85 3f		sta $3f				sta 	zaTemp+1
.849b	c8		iny				iny
.849c	b1 30		lda ($30),y			lda 	(codePtr),y
.849e	c8		iny				iny
.849f	85 3e		sta $3e				sta 	zaTemp
.84a1	5a		phy				phy
.84a2	a0 02		ldy #$02			ldy 	#2 						; read type byte
.84a4	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84a6	29 18		and #$18			and 	#NSBTypeMask 			; check it's not a procedure
.84a8	c9 18		cmp #$18			cmp 	#NSTProcedure
.84aa	f0 62		beq $850e			beq 	_DCSyntax
.84ac	b1 3e		lda ($3e),y			lda 	(zaTemp),y 				; check it's an array
.84ae	29 04		and #$04			and 	#NSBIsArray
.84b0	f0 64		beq $8516			beq 	_DCType
.84b2	a0 04		ldy #$04			ldy 	#4 						; check not already defined
.84b4	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84b6	d0 59		bne $8511			bne 	_DCRedefine
.84b8	7a		ply				ply
.84b9	20 19 85	jsr $8519			jsr 	_DCGetSize 				; get array size, check it.
.84bc	5a		phy				phy
.84bd	a0 05		ldy #$05			ldy 	#5 						; store in first array size slot
.84bf	91 3e		sta ($3e),y			sta 	(zaTemp),y 				; second will be zero.
.84c1	7a		ply				ply 							; is there a second (e.g. ,x)
.84c2	b1 30		lda ($30),y			lda 	(codePtr),y
.84c4	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.84c6	d0 0a		bne $84d2			bne 	_DCOneDimension
.84c8	c8		iny				iny 							; skip comma
.84c9	20 19 85	jsr $8519			jsr 	_DCGetSize 				; get 2nd array size
.84cc	5a		phy				phy
.84cd	a0 06		ldy #$06			ldy 	#6 						; store in 2nd array size
.84cf	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84d1	7a		ply				ply
.84d2					_DCOneDimension:
.84d2	5a		phy				phy 							; save position
.84d3	a0 05		ldy #$05			ldy 	#5 						; dimensions + 1 in AX (as zero based)
.84d5	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84d7	aa		tax				tax
.84d8	c8		iny				iny
.84d9	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84db	e8		inx				inx 							; bump them.
.84dc	1a		inc a				inc 	a
.84dd	20 80 9d	jsr $9d80			jsr 	Multiply8x8 			; work out the total number of elements -> zTemp0
.84e0	a5 37		lda $37				lda 	zTemp0+1 				; don't allow more than 8192 elements whatever
.84e2	29 e0		and #$e0			and 	#$E0
.84e4	d0 23		bne $8509			bne 	_DCSize
.84e6	a0 02		ldy #$02			ldy 	#2 						; get base type
.84e8	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84ea	20 27 85	jsr $8527			jsr 	ScaleByBaseType 		; scale by base type
.84ed	a5 36		lda $36				lda 	zTemp0
.84ef	a6 37		ldx $37				ldx 	zTemp0+1
.84f1	20 bf 99	jsr $99bf			jsr 	AllocateXABytes 		; allocate memory
.84f4	a0 03		ldy #$03			ldy 	#3 						; copy into the address.
.84f6	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84f8	c8		iny				iny
.84f9	8a		txa				txa
.84fa	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84fc	7a		ply				ply 							; get position back
.84fd	20 af 8e	jsr $8eaf			jsr 	CheckRightBracket 		; check )
.8500	b1 30		lda ($30),y			lda 	(codePtr),y
.8502	c8		iny				iny 							; consume in case
.8503	c9 2c		cmp #$2c			cmp 	#KWD_COMMA		 		; if so do another DIM.
.8505	f0 85		beq $848c			beq 	DimCommand
.8507	88		dey				dey 							; undo consume
.8508	60		rts				rts
.8509					_DCSize:
.8509	a9 16		lda #$16		lda	#22
.850b	4c c8 8e	jmp $8ec8		jmp	ErrorHandler
.850e					_DCSyntax:
.850e	4c 53 9f	jmp $9f53			jmp 	SyntaxError
.8511					_DCRedefine:
.8511	a9 15		lda #$15		lda	#21
.8513	4c c8 8e	jmp $8ec8		jmp	ErrorHandler
.8516					_DCType:
.8516	4c 5d 9f	jmp $9f5d			jmp 	TypeError
.8519					_DCGetSize:
.8519	a2 00		ldx #$00			ldx 	#0 						; get first index.
.851b	20 70 9d	jsr $9d70			jsr 	Evaluate8BitInteger 	; get array dimension
.851e	c9 00		cmp #$00			cmp 	#0 						; must be 1-254
.8520	f0 e7		beq $8509			beq 	_DCSize
.8522	c9 fe		cmp #$fe			cmp 	#254
.8524	f0 e3		beq $8509			beq 	_DCSize
.8526	60		rts				rts
.8527					ScaleByBaseType:
.8527	29 10		and #$10			and 	#NSBIsString 			; is it string
.8529	d0 19		bne $8544			bne 	_SBBTString
.852b	a5 37		lda $37				lda 	zTemp0+1 				; push value on stack
.852d	48		pha				pha
.852e	a5 36		lda $36				lda 	zTemp0
.8530	48		pha				pha
.8531	06 36		asl $36				asl 	zTemp0 					; x 2
.8533	26 37		rol $37				rol 	zTemp0+1
.8535	06 36		asl $36				asl 	zTemp0 					; x 4
.8537	26 37		rol $37				rol 	zTemp0+1
.8539	68		pla				pla 							; add stacked value = x 5
.853a	65 36		adc $36				adc 	zTemp0
.853c	85 36		sta $36				sta 	zTemp0
.853e	68		pla				pla
.853f	65 37		adc $37				adc 	zTemp0+1
.8541	85 37		sta $37				sta 	zTemp0+1
.8543	60		rts				rts
.8544					_SBBTString:
.8544	06 36		asl $36				asl 	zTemp0
.8546	26 37		rol $37				rol 	zTemp0+1
.8548	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/end.asm

.8549					EndCommand:
.8549	4c 8e 83	jmp $838e			jmp 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/for.asm

.854c					ForCommand:
.854c	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; allocate 18 bytes on the return stack.
.854e	20 18 a6	jsr $a618			jsr 	StackOpen
.8551	a2 00		ldx #$00			ldx 	#0
.8553	20 16 98	jsr $9816			jsr 	EvaluateTerm
.8556	b5 50		lda $50,x			lda 	NSStatus,x
.8558	c9 20		cmp #$20			cmp 	#NSBIsReference+NSTInteger 	; do we have an integer 4 byte reference.
.855a	d0 47		bne $85a3			bne		_FCError
.855c	a9 3d		lda #$3d			lda 	#KWD_EQUAL 					; =
.855e	20 bf 8e	jsr $8ebf			jsr 	CheckNextA
.8561	e8		inx				inx
.8562	20 42 9d	jsr $9d42			jsr 	EvaluateInteger 			; <from> in +1
.8565	b1 30		lda ($30),y			lda 	(codePtr),y
.8567	c8		iny				iny 								; consume it
.8568	48		pha				pha 								; save on stack for later
.8569	c9 b4		cmp #$b4			cmp 	#KWD_DOWNTO
.856b	f0 04		beq $8571			beq 	_FCNoSyntax
.856d	c9 ce		cmp #$ce			cmp 	#KWD_TO
.856f	d0 35		bne $85a6			bne 	_FCSyntaxError
.8571					_FCNoSyntax:
.8571	e8		inx				inx
.8572	20 42 9d	jsr $9d42			jsr 	EvaluateInteger
.8575	20 5c a6	jsr $a65c			jsr 	STKSaveCodePosition 		; save loop back position
.8578	68		pla				pla 								; restore DOWNTO or TO
.8579	5a		phy				phy 								; save Y on the stack
.857a	49 b4		eor #$b4			eor 	#KWD_DOWNTO 				; 0 if DOWNTO, #0 if TO
.857c	f0 02		beq $8580			beq 	_FCNotDownTo
.857e	a9 02		lda #$02			lda 	#2
.8580					_FCNotDownTo:
.8580	3a		dec a				dec 	a 							; 255 if DOWNTO, 1 if TO
.8581	a0 10		ldy #$10			ldy 	#16
.8583	91 34		sta ($34),y			sta 	(basicStack),y 				; copy that out to the Basic Stack.
.8585	a0 06		ldy #$06			ldy 	#6
.8587	a5 58		lda $58				lda 	NSMantissa0
.8589	91 34		sta ($34),y			sta 	(basicStack),y
.858b	a5 60		lda $60				lda 	NSMantissa1
.858d	c8		iny				iny
.858e	91 34		sta ($34),y			sta 	(basicStack),y
.8590	a0 08		ldy #$08			ldy 	#8 							; set initial index value
.8592	a2 01		ldx #$01			ldx 	#1
.8594	20 a9 85	jsr $85a9			jsr 	FCIntegerToStack
.8597	a0 0c		ldy #$0c			ldy 	#12 						; set the terminal value
.8599	a2 02		ldx #$02			ldx 	#2
.859b	20 a9 85	jsr $85a9			jsr 	FCIntegerToStack
.859e	20 c4 85	jsr $85c4			jsr 	CopyIndexToReference
.85a1	7a		ply				ply 								; restore position
.85a2	60		rts				rts
.85a3					_FCError:
.85a3	4c 5d 9f	jmp $9f5d			jmp 	TypeError
.85a6					_FCSyntaxError:
.85a6	4c 53 9f	jmp $9f53			jmp 	SyntaxError
.85a9					FCIntegerToStack:
.85a9	34 50		bit $50,x			bit 	NSStatus,x 					; is the value negative
.85ab	10 03		bpl $85b0			bpl	 	_FCNotNegative
.85ad	20 9e 9d	jsr $9d9e			jsr 	NSMNegateMantissa 			; if so 2's complement the mantissa
.85b0					_FCNotNegative:
.85b0	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy out to the basic stack
.85b2	91 34		sta ($34),y			sta 	(basicStack),y
.85b4	c8		iny				iny
.85b5	b5 60		lda $60,x			lda 	NSMantissa1,x
.85b7	91 34		sta ($34),y			sta 	(basicStack),y
.85b9	c8		iny				iny
.85ba	b5 68		lda $68,x			lda 	NSMantissa2,x
.85bc	91 34		sta ($34),y			sta 	(basicStack),y
.85be	c8		iny				iny
.85bf	b5 70		lda $70,x			lda 	NSMantissa3,x
.85c1	91 34		sta ($34),y			sta 	(basicStack),y
.85c3	60		rts				rts
.85c4					CopyIndexToReference:
.85c4	5a		phy				phy
.85c5	a0 06		ldy #$06			ldy 	#6 							; copy address-8 to write to zTemp0
.85c7	38		sec				sec 								; (because we copy from offset 8)
.85c8	b1 34		lda ($34),y			lda 	(basicStack),y
.85ca	e9 08		sbc #$08			sbc 	#8
.85cc	85 36		sta $36				sta 	zTemp0
.85ce	c8		iny				iny
.85cf	b1 34		lda ($34),y			lda 	(basicStack),y
.85d1	e9 00		sbc #$00			sbc 	#0
.85d3	85 37		sta $37				sta 	zTemp0+1
.85d5	a2 04		ldx #$04			ldx 	#4 							; this is the copy counter/
.85d7	a0 0b		ldy #$0b			ldy 	#8+3 		 				; the MSB of the mantissa
.85d9	b1 34		lda ($34),y			lda 	(basicStack),y
.85db	0a		asl a				asl 	a 							; into carry
.85dc	a0 08		ldy #$08			ldy 	#8 							; where to copy from.
.85de	90 14		bcc $85f4			bcc 	_CITRNormal
.85e0	38		sec				sec
.85e1					_CITRNegative:
.85e1	a9 00		lda #$00			lda 	#0
.85e3	f1 34		sbc ($34),y			sbc 	(basicStack),y
.85e5	91 36		sta ($36),y			sta 	(zTemp0),y
.85e7	c8		iny				iny
.85e8	ca		dex				dex
.85e9	d0 f6		bne $85e1			bne 	_CITRNegative
.85eb	88		dey				dey 								; look at MSB of mantissa
.85ec	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set the MSB as negative packed.
.85ee	09 80		ora #$80			ora 	#$80
.85f0	91 36		sta ($36),y			sta 	(zTemp0),y
.85f2	7a		ply				ply
.85f3	60		rts				rts
.85f4					_CITRNormal:
.85f4	b1 34		lda ($34),y			lda 	(basicStack),y 				; copy without negation.
.85f6	91 36		sta ($36),y			sta 	(zTemp0),y
.85f8	c8		iny				iny
.85f9	ca		dex				dex
.85fa	d0 f8		bne $85f4			bne 	_CITRNormal
.85fc	7a		ply				ply 								; and exit.
.85fd	60		rts				rts
.85fe					NextCommand:
.85fe	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; check FOR is TOS
.8600	a2 11		ldx #$11			ldx 	#ERRID_FOR 					; this error
.8602	20 44 a6	jsr $a644			jsr 	StackCheckFrame
.8605	5a		phy				phy
.8606	a0 10		ldy #$10			ldy 	#16 						; get the step count
.8608	b1 34		lda ($34),y			lda 	(basicStack),y
.860a	85 36		sta $36				sta 	zTemp0 						; this is the sign extend
.860c	30 02		bmi $8610			bmi 	_NCStepNeg
.860e	64 36		stz $36				stz 	zTemp0 						; which is 0 or 255
.8610					_NCStepNeg:
.8610	a0 08		ldy #$08			ldy 	#8 							; offset to bump
.8612	a2 04		ldx #$04			ldx 	#4 							; count to bump
.8614	18		clc				clc
.8615					_NCBump:
.8615	71 34		adc ($34),y			adc 	(basicStack),y 				; add it
.8617	91 34		sta ($34),y			sta 	(basicStack),y
.8619	a5 36		lda $36				lda 	zTemp0 						; get sign extend for next time.
.861b	c8		iny				iny 								; next byte
.861c	ca		dex				dex 								; do four times
.861d	d0 f6		bne $8615			bne 	_NCBump
.861f	20 c4 85	jsr $85c4			jsr		CopyIndexToReference		; copy it to the reference variable.
.8622	a0 10		ldy #$10			ldy 	#16 						; get step count again
.8624	b1 34		lda ($34),y			lda 	(basicStack),y
.8626	0a		asl a				asl 	a 							; sign bit to carry
.8627	a9 0c		lda #$0c			lda 	#12 						; offset of LHS = terminal offset
.8629	85 38		sta $38				sta 	zTemp1
.862b	90 02		bcc $862f			bcc 	_NCCompRev 					; use if step is +ve
.862d	a9 08		lda #$08			lda 	#8 							; now the LHS = index value
.862f					_NCCompRev:
.862f	85 38		sta $38				sta 	zTemp1 						; so zTemp0 is the index for LHS
.8631	49 04		eor #$04			eor 	#(8^12) 					; and zTemp0+1 is the index for RHS
.8633	85 39		sta $39				sta 	zTemp1+1
.8635	a2 04		ldx #$04			ldx 	#4 							; bytes to compare
.8637	38		sec				sec
.8638					_NCCompare:
.8638	a4 38		ldy $38				ldy 	zTemp1 						; do compare using the two indices
.863a	b1 34		lda ($34),y			lda 	(basicStack),y
.863c	a4 39		ldy $39				ldy 	zTemp1+1
.863e	f1 34		sbc ($34),y			sbc 	(basicStack),y
.8640	e6 38		inc $38				inc 	zTemp1 						; bump the indices (inc,dex do not change C or V)
.8642	e6 39		inc $39				inc 	zTemp1+1
.8644	ca		dex				dex 								; do it 4 times.
.8645	d0 f1		bne $8638			bne 	_NCCompare
.8647	50 02		bvc $864b			bvc 	_NCNoOverflow 				; convert to signed comparison
.8649	49 80		eor #$80			eor 	#$80
.864b					_NCNoOverflow:
.864b	7a		ply				ply 								; restore Y position
.864c	0a		asl a				asl 	a 							; is bit 7 set.
.864d	90 04		bcc $8653			bcc 	_NCLoopback 				; if no , >= so loop back
.864f	20 36 a6	jsr $a636			jsr 	StackClose 					; exit the loop
.8652	60		rts				rts
.8653					_NCLoopBack:
.8653	20 6d a6	jsr $a66d			jsr 	STKLoadCodePosition 		; loop back
.8656	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/gosub.asm

.8657					Command_GOSUB:
.8657	a2 00		ldx #$00			ldx 	#0
.8659	20 55 9d	jsr $9d55			jsr 	Evaluate16BitInteger 		; line number in Stack.0
.865c	a9 e3		lda #$e3			lda 	#STK_GOSUB+3
.865e	20 18 a6	jsr $a618			jsr 	StackOpen 					; create frame
.8661	20 5c a6	jsr $a65c			jsr 	STKSaveCodePosition 		; save current position
.8664	4c 7a 86	jmp $867a			jmp 	GotoStackX
.8667					Command_RETURN:
.8667	a9 e0		lda #$e0			lda 	#STK_GOSUB 					; check TOS is this
.8669	a2 0e		ldx #$0e			ldx 	#ERRID_GOSUB 				; this error
.866b	20 44 a6	jsr $a644			jsr 	StackCheckFrame
.866e	20 6d a6	jsr $a66d			jsr 	STKLoadCodePosition 		; restore code position
.8671	20 36 a6	jsr $a636			jsr 	StackClose
.8674	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/goto.asm

.8675					GotoCommand:
.8675	a2 00		ldx #$00			ldx 	#0 							; GOTO where
.8677	20 55 9d	jsr $9d55			jsr 	Evaluate16BitInteger
.867a					GotoStackX:
.867a	b5 60		lda $60,x			lda  	NSMantissa1,x 				; put line # in XA. I'll keep this even though
.867c	48		pha				pha 								; it is slightly inefficient, just in cases.
.867d	b5 58		lda $58,x			lda 	NSMantissa0,x
.867f	fa		plx				plx
.8680	20 41 a5	jsr $a541			jsr 	MemorySearch 				; transfer to line number AX.
.8683	90 05		bcc $868a			bcc 	_GotoError 					; not found, off end.
.8685	d0 03		bne $868a			bne 	_GotoError 					; not found exactly
.8687	4c fe 8a	jmp $8afe			jmp 	RunNewLine 					; and go straight to new line code.
.868a					_GotoError:
.868a	a9 0d		lda #$0d		lda	#13
.868c	4c c8 8e	jmp $8ec8		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/if.asm

.868f					IfCommand:
.868f	a2 00		ldx #$00			ldx 	#0 							; If what.
.8691	20 23 9d	jsr $9d23			jsr 	EvaluateNumber
.8694	b1 30		lda ($30),y			lda 	(codePtr),y
.8696	c9 a8		cmp #$a8			cmp 	#KWD_THEN  					; could be THEN <stuff> or GOTO
.8698	d0 0a		bne $86a4			bne 	_IFStructured
.869a	c8		iny				iny 								; consume THEN
.869b	20 f7 9d	jsr $9df7			jsr 	NSMIsZero 					; is it zero
.869e	f0 01		beq $86a1			beq 	_IfFail 					; if fail, go to next line
.86a0	60		rts				rts 								; if THEN just continue
.86a1					_IfFail:
.86a1	4c e6 8a	jmp $8ae6			jmp 	EOLCommand
.86a4					_IfStructured:
.86a4	20 f7 9d	jsr $9df7			jsr 	NSMIsZero 					; is it zero
.86a7	d0 07		bne $86b0			bne 	_IfExit 					; if not, then continue normally.
.86a9	a9 b5		lda #$b5			lda 	#KWD_ELSE 					; look for else/endif
.86ab	a2 a5		ldx #$a5			ldx 	#KWD_ENDIF
.86ad	20 a7 8d	jsr $8da7			jsr 	ScanForward 				; and run from there/
.86b0					_IfExit:
.86b0	60		rts				rts
.86b1					ElseCode:
.86b1	a9 a5		lda #$a5			lda 	#KWD_ENDIF 					; else is only run after the if clause succeeds
.86b3	aa		tax				tax 								; so just go to the structure exit
.86b4	20 a7 8d	jsr $8da7			jsr 	ScanForward
.86b7	60		rts				rts
.86b8					EndIf:
.86b8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/inputprint.asm

.86b9					Command_Input:
.86b9	a9 ff		lda #$ff			lda 	#$FF
.86bb	8d 28 04	sta $0428			sta 	IsInputFlag
.86be	80 03		bra $86c3			bra 	Command_IP_Main
.86c0					Command_Print:
.86c0	9c 28 04	stz $0428			stz 	IsInputFlag
.86c3					Command_IP_Main:
.86c3	18		clc				clc 								; carry being clear means last print wasn't comma/semicolon
.86c4					_CPLoop:
.86c4	08		php				php 								; save last action flag
.86c5	b1 30		lda ($30),y			lda 	(codePtr),y
.86c7	c9 80		cmp #$80			cmp  	#KWC_EOL 					; end of line or colon, exit now.
.86c9	f0 54		beq $871f			beq 	_CPExit
.86cb	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.86cd	f0 50		beq $871f			beq 	_CPExit
.86cf	68		pla				pla 								; throw last action flag
.86d0	b1 30		lda ($30),y			lda 	(codePtr),y
.86d2	c8		iny				iny
.86d3	c9 3b		cmp #$3b			cmp 	#KWD_SEMICOLON				; is it a semicolon
.86d5	f0 45		beq $871c			beq 	_CPContinueWithSameLine
.86d7	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; comma
.86d9	f0 3c		beq $8717			beq 	_CPTab
.86db	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; apostrophe (new line)
.86dd	f0 34		beq $8713			beq 	_CPNewLine
.86df	88		dey				dey 								; undo the get.
.86e0	20 ca 93	jsr $93ca			jsr 	EvaluateExpressionAt0 		; evaluate expression at 0.
.86e3	b5 50		lda $50,x			lda 	NSStatus,x 					; read the status
.86e5	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.86e7	f0 0d		beq $86f6			beq 	_CPIsValue
.86e9	ad 28 04	lda $0428			lda 	IsInputFlag 				; if print, dereference and print.
.86ec	f0 05		beq $86f3			beq 	_CPIsPrint
.86ee	20 28 87	jsr $8728			jsr 	CIInputValue 				; input a value to the reference
.86f1	80 20		bra $8713			bra 	_CPNewLine
.86f3					_CPIsPrint:
.86f3	20 8f 96	jsr $968f			jsr 	Dereference
.86f6					_CPIsValue:
.86f6	b5 50		lda $50,x			lda 	NSStatus,x 					; is it a number
.86f8	29 10		and #$10			and 	#NSBIsString
.86fa	f0 09		beq $8705			beq 	_CPNumber
.86fc	a6 60		ldx $60				ldx 	NSMantissa1 				; string, print the text.
.86fe	a5 58		lda $58				lda 	NSMantissa0
.8700	20 8b 87	jsr $878b			jsr 	CPPrintStringXA
.8703	80 be		bra $86c3			bra 	Command_IP_Main 			; loop round clearing carry so NL if end
.8705					_CPNumber:
.8705	a9 05		lda #$05			lda 	#5 							; maximum decimals
.8707	20 0a 9c	jsr $9c0a			jsr 	ConvertNumberToString 		; convert to string
.870a	a2 05		ldx #$05			ldx 	#DecimalBuffer >> 8
.870c	a9 9d		lda #$9d			lda 	#DecimalBuffer & $FF
.870e	20 8b 87	jsr $878b			jsr 	CPPrintStringXA
.8711	80 b0		bra $86c3			bra 	Command_IP_Main				; loop round clearing carry so NL if end
.8713					_CPNewLine:
.8713	a9 0d		lda #$0d			lda 	#13
.8715	80 02		bra $8719			bra 	_CPPrintChar
.8717					_CPTab:
.8717	a9 09		lda #$09			lda 	#9 							; print TAB
.8719					_CPPrintChar:
.8719	20 9e 87	jsr $879e			jsr 	CPPrintVector
.871c					_CPContinueWithSameLine:
.871c	38		sec				sec 								; loop round with carry set, which
.871d	80 a5		bra $86c4			bra 	_CPLoop 					; will inhibit final CR
.871f					_CPExit:
.871f	28		plp				plp 								; get last action flag
.8720	b0 05		bcs $8727			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.8722	a9 0d		lda #$0d			lda 	#13 						; print new line
.8724	20 9e 87	jsr $879e			jsr 	CPPrintVector
.8727					_CPExit2:
.8727	60		rts				rts
.8728					CIInputValue:
.8728	a2 00		ldx #$00			ldx 	#0 							; input a line.
.872a					_CIInputLine:
.872a	20 a1 87	jsr $87a1			jsr 	CPInputVector 				; get key
.872d	c9 0d		cmp #$0d			cmp 	#13 						; 13 = End
.872f	f0 1f		beq $8750			beq 	_CIHaveValue
.8731	c9 08		cmp #$08			cmp 	#8 							; 8 = BS
.8733	f0 11		beq $8746			beq 	_CIBackspace
.8735	c9 20		cmp #$20			cmp 	#32 						; ignore other control characters
.8737	90 f1		bcc $872a			bcc 	_CIInputLine
.8739	e0 50		cpx #$50			cpx 	#80 						; max length
.873b	b0 ed		bcs $872a			bcs 	_CIInputLine
.873d	9d 2a 05	sta $052a,x			sta 	lineBuffer,x
.8740	e8		inx				inx
.8741	20 9e 87	jsr $879e			jsr 	CPPrintVector 				; echo it.
.8744	80 e4		bra $872a			bra 	_CIInputLine
.8746					_CIBackSpace:
.8746	e0 00		cpx #$00			cpx 	#0 							; nothing to delete
.8748	f0 e0		beq $872a			beq 	_CIInputLine
.874a	20 9e 87	jsr $879e			jsr 	CPPrintVector 				; echo it.
.874d	ca		dex				dex
.874e	80 da		bra $872a			bra 	_CIInputLine
.8750					_CIHaveValue:
.8750	9e 2a 05	stz $052a,x			stz 	LineBuffer,x 				; ASCIIZ string now in line buffer.
.8753	a5 50		lda $50				lda 	NSStatus 					; was it a string assignment
.8755	29 10		and #$10			and 	#NSBIsString
.8757	f0 17		beq $8770			beq 	_CIAssignNumber 			; assign a number
.8759	a2 01		ldx #$01			ldx 	#1
.875b	a9 2a		lda #$2a			lda 	#lineBuffer & $FF 			; set up to point to new string
.875d	95 58		sta $58,x			sta 	NSMantissa0,x
.875f	a9 05		lda #$05			lda 	#lineBuffer >> 8
.8761	95 60		sta $60,x			sta 	NSMantissa1,x
.8763	74 68		stz $68,x			stz 	NSMantissa2,x
.8765	74 70		stz $70,x			stz 	NSMantissa3,x
.8767	a9 10		lda #$10			lda 	#NSBIsString 				; so it becomes a string value
.8769	95 50		sta $50,x			sta  	NSStatus,x
.876b	ca		dex				dex 								; X = 0
.876c	20 dd 87	jsr $87dd			jsr 	AssignVariable
.876f	60		rts				rts
.8770					_CIAssignNumber:
.8770	a9 2a		lda #$2a			lda 	#lineBuffer & $FF 			; set up to point to new string
.8772	85 36		sta $36				sta 	zTemp0
.8774	a9 05		lda #$05			lda 	#lineBuffer >> 8
.8776	85 37		sta $37				sta 	zTemp0+1
.8778	a2 01		ldx #$01			ldx 	#1 							; put in slot 1
.877a	20 8c 9b	jsr $9b8c			jsr 	ValEvaluateZTemp0 			; use the VAL() code
.877d	90 07		bcc $8786			bcc 	_CIIsOkay
.877f	a9 3f		lda #$3f			lda 	#"?" 						; error ?
.8781	20 9e 87	jsr $879e			jsr 	CPPrintVector
.8784	80 a2		bra $8728			bra 	CIInputValue
.8786					_CIIsOkay:
.8786	ca		dex				dex 								; X = 0
.8787	20 dd 87	jsr $87dd			jsr 	AssignVariable
.878a	60		rts				rts
.878b					CPPrintStringXA:
.878b	5a		phy				phy
.878c	86 37		stx $37				stx 	zTemp0+1
.878e	85 36		sta $36				sta 	zTemp0
.8790	a0 00		ldy #$00			ldy 	#0
.8792					_PSXALoop:
.8792	b1 36		lda ($36),y			lda 	(zTemp0),y
.8794	f0 06		beq $879c			beq 	_PSXAExit
.8796	20 9e 87	jsr $879e			jsr 	CPPrintVector
.8799	c8		iny				iny
.879a	80 f6		bra $8792			bra 	_PSXALoop
.879c					_PSXAExit:
.879c	7a		ply				ply
.879d	60		rts				rts
.879e					CPPrintVector:
.879e	4c 03 80	jmp $8003			jmp 	EXTPrintCharacter
.87a1					CPInputVector:
.87a1	4c 09 80	jmp $8009			jmp 	EXTInputSingleCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/let.asm

.87a4					LetCommand:
.87a4	a2 00		ldx #$00			ldx 	#0
.87a6	b1 30		lda ($30),y			lda 	(codePtr),y
.87a8	c9 10		cmp #$10			cmp 	#KWD_AT
.87aa	d0 14		bne $87c0			bne 	_LCStandard
.87ac	c8		iny				iny 								; skip equal
.87ad	20 16 98	jsr $9816			jsr 	EvaluateTerm 				; get a number
.87b0	20 8f 96	jsr $968f			jsr 	Dereference 				; dereference it
.87b3	b5 50		lda $50,x			lda 	NSStatus,x 					; check integer
.87b5	49 20		eor #$20			eor 	#NSBIsReference	 			; toggle reference
.87b7	95 50		sta $50,x			sta 	NSStatus,x
.87b9	29 20		and #$20			and 	#NSBIsReference 			; if it is now a reference, continue
.87bb	d0 0f		bne $87cc			bne 	_LCMain
.87bd	4c 5d 9f	jmp $9f5d			jmp 	TypeError 					; was a reference before.
.87c0					_LCStandard:
.87c0	ad b4 93	lda $93b4			lda 	PrecedenceLevel+"*"			; precedence > this
.87c3	20 ce 93	jsr $93ce			jsr 	EvaluateExpressionAtPrecedence
.87c6	b5 50		lda $50,x			lda 	NSStatus,x 					; is it a reference to an array
.87c8	c9 38		cmp #$38			cmp		#NSTProcedure+NSBIsReference
.87ca	f0 0e		beq $87da			beq 	_LetGoProc 					; it's a procedure call.
.87cc					_LCMain:
.87cc	a9 3d		lda #$3d			lda 	#"=" 						; check =
.87ce	20 bf 8e	jsr $8ebf			jsr 	CheckNextA
.87d1	e8		inx				inx 								; RHS
.87d2	20 1a 9d	jsr $9d1a			jsr 	EvaluateValue
.87d5	ca		dex				dex
.87d6	20 dd 87	jsr $87dd			jsr 	AssignVariable
.87d9	60		rts				rts
.87da					_LetGoProc:
.87da	4c c1 89	jmp $89c1			jmp 	CallProcedure
.87dd					AssignVariable:
.87dd	b5 50		lda $50,x			lda 	NSStatus,x 					; check the string/number type bits match
.87df	48		pha				pha 								; save a copy
.87e0	55 51		eor $51,x			eor 	NSStatus+1,x
.87e2	29 10		and #$10			and 	#NSBIsString
.87e4	d0 0b		bne $87f1			bne 	_ASError
.87e6	68		pla				pla 								; get back
.87e7	29 10		and #$10			and 	#NSBIsString 				; check type
.87e9	d0 03		bne $87ee			bne 	_ASString
.87eb	4c cd 95	jmp $95cd			jmp 	AssignNumber
.87ee					_ASString:
.87ee	4c 2b 96	jmp $962b			jmp 	AssignString
.87f1					_ASError:
.87f1	4c 5d 9f	jmp $9f5d			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/list.asm

.87f4					Command_List:
.87f4	9c 26 04	stz $0426			stz 	listIndent 					; reset indent.
.87f7	b1 30		lda ($30),y			lda 	(codePtr),y
.87f9	29 c0		and #$c0			and 	#$C0
.87fb	c9 40		cmp #$40			cmp 	#$40
.87fd	f0 69		beq $8868			beq 	_CLListProcedure
.87ff	64 5c		stz $5c				stz		NSMantissa0+4				; set the lower (slot 4) to 0 and upper (slot 7) to $FFFF
.8801	64 64		stz $64				stz 	NSMantissa1+4
.8803	a9 ff		lda #$ff			lda 	#$FF
.8805	85 5f		sta $5f				sta 	NSMantissa0+7
.8807	85 67		sta $67				sta 	NSMantissa1+7
.8809	b1 30		lda ($30),y			lda 	(codePtr),y
.880b	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.880d	f0 1a		beq $8829			beq 	_CLSecond
.880f	20 e5 88	jsr $88e5			jsr 	CLIsDigit 					; if not digit, list all
.8812	b0 20		bcs $8834			bcs 	_CLStart
.8814	a2 04		ldx #$04			ldx 	#4 							; get 1st range into slot 4
.8816	20 55 9d	jsr $9d55			jsr 	Evaluate16BitInteger
.8819	b1 30		lda ($30),y			lda 	(codePtr),y
.881b	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.881d	f0 0a		beq $8829			beq 	_CLSecond 					; if so go get it
.881f	a5 5c		lda $5c				lda 	NSMantissa0+4 				; copy 4->7
.8821	85 5f		sta $5f				sta 	NSMantissa0+7
.8823	a5 64		lda $64				lda 	NSMantissa1+4
.8825	85 67		sta $67				sta 	NSMantissa1+7
.8827	80 0b		bra $8834			bra 	_CLStart
.8829					_CLSecond:
.8829	c8		iny				iny 								; consume comma
.882a	20 e5 88	jsr $88e5			jsr 	CLIsDigit 					; digit found
.882d	b0 05		bcs $8834			bcs 	_CLStart 					; if not, continue listing
.882f	a2 07		ldx #$07			ldx 	#7 							; load 2nd range into slot 7
.8831	20 55 9d	jsr $9d55			jsr 	Evaluate16BitInteger
.8834					_CLStart
.8834	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8836	85 30		sta $30				sta 	codePtr
.8838	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.883a	85 31		sta $31				sta 	codePtr+1
.883c					_CLLoop:
.883c	20 0c 80	jsr $800c			jsr 	EXTBreakCheck 				; break check
.883f	f0 24		beq $8865			beq 	_CLExit
.8841	b2 30		lda ($30)			lda 	(codePtr)
.8843	f0 20		beq $8865			beq 	_CLExit
.8845	a2 04		ldx #$04			ldx 	#4 							; check range every time, line numbers aren't in order.
.8847	20 d4 88	jsr $88d4			jsr 	CLCompareLineNo
.884a	90 0c		bcc $8858			bcc 	_CLNext
.884c	a2 07		ldx #$07			ldx 	#7
.884e	20 d4 88	jsr $88d4			jsr 	CLCompareLineNo
.8851	f0 02		beq $8855			beq 	_CLDoThisOne
.8853	b0 03		bcs $8858			bcs 	_CLNext
.8855					_CLDoThisOne:
.8855	20 c1 88	jsr $88c1			jsr 	CLListOneLine
.8858					_CLNext:
.8858	18		clc				clc
.8859	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.885b	65 30		adc $30				adc 	codePtr
.885d	85 30		sta $30				sta 	codePtr
.885f	90 02		bcc $8863			bcc 	_CREExit
.8861	e6 31		inc $31				inc 	codePtr+1 					; carry
.8863					_CREExit:
.8863	80 d7		bra $883c			bra 	_CLLoop
.8865					_CLExit:
.8865	4c 8e 83	jmp $838e			jmp 	WarmStart
.8868					_CLListProcedure:
.8868	b1 30		lda ($30),y			lda 	(codePtr),y
.886a	85 38		sta $38				sta 	zTemp1
.886c	c8		iny				iny
.886d	b1 30		lda ($30),y			lda 	(codePtr),y
.886f	85 39		sta $39				sta 	zTemp1+1
.8871	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8873	85 30		sta $30				sta 	codePtr
.8875	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8877	85 31		sta $31				sta 	codePtr+1
.8879					_CLLPSearch:
.8879	b2 30		lda ($30)			lda 	(codePtr)
.887b	c9 00		cmp #$00			cmp 	#0 							; if zero, end
.887d	f0 e6		beq $8865			beq 	_CLExit
.887f	a0 03		ldy #$03			ldy 	#3 							; check if PROC something
.8881	b1 30		lda ($30),y			lda 	(codePtr),y
.8883	c9 a2		cmp #$a2			cmp 	#KWD_PROC
.8885	d0 0e		bne $8895			bne 	_CLLPNext
.8887	c8		iny				iny 								; check if PROC this.
.8888	b1 30		lda ($30),y			lda 	(codePtr),y
.888a	c5 38		cmp $38				cmp 	zTemp1 						; does it match ?
.888c	d0 07		bne $8895			bne 	_CLLPNext
.888e	c8		iny				iny
.888f	b1 30		lda ($30),y			lda 	(codePtr),y
.8891	c5 39		cmp $39				cmp 	zTemp1+1
.8893	f0 0d		beq $88a2			beq 	_CLLPFound
.8895					_CLLPNext:
.8895	18		clc				clc
.8896	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8898	65 30		adc $30				adc 	codePtr
.889a	85 30		sta $30				sta 	codePtr
.889c	90 02		bcc $88a0			bcc 	_CREExit
.889e	e6 31		inc $31				inc 	codePtr+1 					; carry
.88a0					_CREExit:
.88a0	80 d7		bra $8879			bra 	_CLLPSearch
.88a2					_CLLPFound:
.88a2	b2 30		lda ($30)			lda 	(codePtr)
.88a4	f0 bf		beq $8865			beq 	_CLExit
.88a6	a0 03		ldy #$03			ldy 	#3 							; get first keyword
.88a8	b1 30		lda ($30),y			lda 	(codePtr),y
.88aa	48		pha				pha
.88ab	20 c1 88	jsr $88c1			jsr 	CLListOneLine 				; list line and go forward
.88ae	18		clc				clc
.88af	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.88b1	65 30		adc $30				adc 	codePtr
.88b3	85 30		sta $30				sta 	codePtr
.88b5	90 02		bcc $88b9			bcc 	_CREExit
.88b7	e6 31		inc $31				inc 	codePtr+1 					; carry
.88b9					_CREExit:
.88b9	68		pla				pla 								; reached ENDPROC ?
.88ba	c9 a6		cmp #$a6			cmp 	#KWD_ENDPROC
.88bc	d0 e4		bne $88a2			bne 	_CLLPFound
.88be	4c 8e 83	jmp $838e			jmp 	WarmStart
.88c1					CLListOneLine:
.88c1	20 0a 8e	jsr $8e0a			jsr 	ScanGetCurrentLineStep 		; get indent adjust.
.88c4	20 1e 80	jsr $801e			jsr 	TKListConvertLine 			; convert line into token Buffer
.88c7	a2 04		ldx #$04			ldx 	#(tokenBuffer >> 8) 		; print that line
.88c9	a9 2d		lda #$2d			lda 	#(tokenBuffer & $FF)
.88cb	20 21 8f	jsr $8f21			jsr 	PrintStringXA
.88ce	a9 0d		lda #$0d			lda 	#13 						; new line
.88d0	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.88d3	60		rts				rts
.88d4					CLCompareLineNo:
.88d4	38		sec				sec
.88d5	a0 01		ldy #$01			ldy 	#1
.88d7	b1 30		lda ($30),y			lda 	(codePtr),y
.88d9	f5 58		sbc $58,x			sbc 	NSMantissa0,x
.88db	85 36		sta $36				sta 	zTemp0
.88dd	c8		iny				iny
.88de	b1 30		lda ($30),y			lda 	(codePtr),y
.88e0	f5 60		sbc $60,x			sbc 	NSMantissa1,x
.88e2	05 36		ora $36				ora 	zTemp0
.88e4	60		rts				rts
.88e5					CLIsDigit:
.88e5	b1 30		lda ($30),y			lda 	(codePtr),y
.88e7	c9 30		cmp #$30			cmp 	#"0"
.88e9	90 03		bcc $88ee			bcc	 	_CLIDExitFalse
.88eb	c9 3a		cmp #$3a			cmp 	#"9"+1
.88ed	60		rts				rts
.88ee					_CLIDExitFalse:
.88ee	38		sec				sec
.88ef	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/local.asm

.88f0					Command_LOCAL:
.88f0	a2 00		ldx #$00			ldx 	#0 							; at level 0
.88f2	20 fe 88	jsr $88fe			jsr 	LocaliseNextTerm 			; convert term to a local.
.88f5	b1 30		lda ($30),y			lda 	(codePtr),y
.88f7	c8		iny				iny
.88f8	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.88fa	f0 f4		beq $88f0			beq 	Command_LOCAL
.88fc	88		dey				dey 								; unpick pre-get
.88fd	60		rts				rts
.88fe					LocaliseNextTerm:
.88fe	20 16 98	jsr $9816			jsr 	EvaluateTerm 				; evaluate the term
.8901	b5 50		lda $50,x			lda 	NSStatus,x
.8903	29 20		and #$20			and 	#NSBIsReference 			; check it is a reference
.8905	f0 5c		beq $8963			beq		_LNTError
.8907	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address of variable to zTemp0
.8909	85 36		sta $36				sta 	zTemp0
.890b	b5 60		lda $60,x			lda 	NSMantissa1,x
.890d	85 37		sta $37				sta  	zTemp0+1
.890f	b5 50		lda $50,x			lda 	NSStatus,x
.8911	29 10		and #$10			and 	#NSBIsString
.8913	d0 1e		bne $8933			bne 	_LNTPushString
.8915	5a		phy				phy
.8916	a0 00		ldy #$00			ldy 	#0 							; push 0 to 4 inclusive, the number values, on the stack, and zero them as you go.
.8918					_LNTPushNumLoop:
.8918	b1 36		lda ($36),y			lda		(zTemp0),y
.891a	20 f6 a5	jsr $a5f6			jsr 	StackPushByte
.891d	c8		iny				iny
.891e	c0 05		cpy #$05			cpy 	#5
.8920	d0 f6		bne $8918			bne 	_LNTPushNumLoop
.8922	a5 36		lda $36				lda 	zTemp0 						; push the actual target address to write on the stack
.8924	20 f6 a5	jsr $a5f6			jsr 	StackPushByte
.8927	a5 37		lda $37				lda 	zTemp0+1
.8929	20 f6 a5	jsr $a5f6			jsr 	StackPushByte
.892c	a9 01		lda #$01			lda 	#STK_LOCALN 				; push local-number marker.
.892e	20 f6 a5	jsr $a5f6			jsr 	StackPushByte
.8931	7a		ply				ply
.8932	60		rts				rts
.8933					_LNTPushString:
.8933	5a		phy				phy
.8934	b2 36		lda ($36)			lda 	(zTemp0) 					; put address of string in zTemp1
.8936	85 38		sta $38				sta 	zTemp1
.8938	a0 01		ldy #$01			ldy 	#1
.893a	b1 36		lda ($36),y			lda 	(zTemp0),y
.893c	85 39		sta $39				sta 	zTemp1+1
.893e	a0 00		ldy #$00			ldy 	#0 							; output string
.8940	c9 00		cmp #$00			cmp 	#0 							; if not assigned strin
.8942	f0 0a		beq $894e			beq 	_LNTStringOut
.8944					_LNTPushStrLoop:
.8944	b1 38		lda ($38),y			lda 	(zTemp1),y
.8946	f0 06		beq $894e			beq 	_LNTStringOut
.8948	20 f6 a5	jsr $a5f6			jsr 	StackPushByte
.894b	c8		iny				iny
.894c	80 f6		bra $8944			bra 	_LNTPushStrLoop
.894e					_LNTStringOut:
.894e	98		tya				tya									; output length
.894f	20 f6 a5	jsr $a5f6			jsr 	StackPushByte
.8952	b5 58		lda $58,x			lda 	NSMantissa0,x 				; output address of the string record *not* the string itself
.8954	20 f6 a5	jsr $a5f6			jsr 	StackPushByte
.8957	b5 60		lda $60,x			lda 	NSMantissa1,x
.8959	20 f6 a5	jsr $a5f6			jsr 	StackPushByte
.895c	a9 02		lda #$02			lda 	#STK_LOCALS 				; push local-string marker.
.895e	20 f6 a5	jsr $a5f6			jsr 	StackPushByte
.8961	7a		ply				ply
.8962	60		rts				rts
.8963					_LNTError:
.8963	4c 53 9f	jmp $9f53			jmp 	SyntaxError
.8966					LocalPopValue:
.8966	20 0f a6	jsr $a60f			jsr 	StackPopByte
.8969	c9 01		cmp #$01			cmp 	#STK_LOCALN 				; if not local-N
.896b	d0 17		bne $8984			bne 	_LPVString
.896d	20 0f a6	jsr $a60f			jsr 	StackPopByte 				; address
.8970	85 37		sta $37				sta 	zTemp0+1
.8972	20 0f a6	jsr $a60f			jsr 	StackPopByte
.8975	85 36		sta $36				sta 	zTemp0
.8977	5a		phy				phy
.8978	a0 04		ldy #$04			ldy 	#4 							; copy back
.897a					_LPVNumberCopy:
.897a	20 0f a6	jsr $a60f			jsr 	StackPopByte
.897d	91 36		sta ($36),y			sta 	(zTemp0),y
.897f	88		dey				dey
.8980	10 f8		bpl $897a			bpl 	_LPVNumberCopy
.8982	7a		ply				ply 								; and complete
.8983	60		rts				rts
.8984					_LPVString:
.8984	20 0f a6	jsr $a60f			jsr 	StackPopByte 				; address of record => zTemp0
.8987	85 37		sta $37				sta 	zTemp0+1
.8989	20 0f a6	jsr $a60f			jsr 	StackPopByte
.898c	85 36		sta $36				sta 	zTemp0
.898e	5a		phy				phy
.898f	b2 36		lda ($36)			lda 	(zTemp0) 					; address to write string to => zTemp1
.8991	85 38		sta $38				sta 	zTemp1
.8993	a0 01		ldy #$01			ldy 	#1
.8995	b1 36		lda ($36),y			lda 	(zTemp0),y
.8997	85 39		sta $39				sta 	zTemp1+1
.8999	20 0f a6	jsr $a60f			jsr 	StackPopByte 				; # to get => y
.899c	a8		tay				tay
.899d	a5 39		lda $39				lda 	zTemp1+1 					; if no target (e.g. was "" originally) exit
.899f	f0 0e		beq $89af			beq 	_LPVStringCopied
.89a1	a9 00		lda #$00			lda 	#0 							; NULL on end
.89a3	91 38		sta ($38),y			sta 	(zTemp1),y
.89a5					_LPVStringCopy:
.89a5	88		dey				dey
.89a6	30 07		bmi $89af			bmi 	_LPVStringCopied
.89a8	20 0f a6	jsr $a60f			jsr 	StackPopByte
.89ab	91 38		sta ($38),y			sta 	(zTemp1),y
.89ad	80 f6		bra $89a5			bra 	_LPVStringCopy
.89af					_LPVStringCopied:
.89af	fa		plx				plx
.89b0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/new.asm

.89b1					NewCommand:
.89b1	20 b7 89	jsr $89b7			jsr 	NewProgram 					; does the actual NEW.
.89b4	4c 8e 83	jmp $838e			jmp 	WarmStart 					; and warm starts straight away.
.89b7					NewProgram:
.89b7	20 23 a5	jsr $a523			jsr 	MemoryNew
.89ba	9c 00 10	stz $1000			stz 	VariableSpace 				; erase all variables.
.89bd	20 24 84	jsr $8424			jsr 	ClearCommand 				; clear everything.
.89c0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/procedure.asm

=2					ParameterStackPos = 2
.89c1					CallProcedure:
.89c1	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start storing parameters at 2.
.89c3	b1 30		lda ($30),y			lda 	(codePtr),y
.89c5	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.89c7	f0 0c		beq $89d5			beq 	_CPEndParam
.89c9					_CPParamLoop:
.89c9	20 1a 9d	jsr $9d1a			jsr 	EvaluateValue 				; get parameter onto stack
.89cc	e8		inx				inx 								; bump next stack
.89cd	b1 30		lda ($30),y			lda 	(codePtr),y
.89cf	c8		iny				iny
.89d0	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if comma, go back and try again.
.89d2	f0 f5		beq $89c9			beq 	_CPParamLoop
.89d4	88		dey				dey 								; unpick.
.89d5					_CPEndParam:
.89d5	8e 16 04	stx $0416			stx 	LastParameter 				; save the last parameters index.
.89d8	c8		iny				iny									; skip right bracket
.89d9	a9 b3		lda #$b3			lda 	#STK_PROC+3 				; allocate 6 bytes on the return stack.
.89db	20 18 a6	jsr $a618			jsr 	StackOpen
.89de	20 5c a6	jsr $a65c			jsr 	STKSaveCodePosition 		; save loop position
.89e1	a5 58		lda $58				lda 	NSMantissa0 				; copy variable (e.g. procedure) address to zTemp0
.89e3	85 36		sta $36				sta 	zTemp0 						; this is the DATA not the RECORD
.89e5	a5 60		lda $60				lda 	NSMantissa1
.89e7	85 37		sta $37				sta 	zTemp0+1
.89e9	a0 01		ldy #$01			ldy 	#1 							; copy code address back.
.89eb	b2 36		lda ($36)			lda 	(zTemp0)
.89ed	85 30		sta $30				sta 	safePtr
.89ef	b1 36		lda ($36),y			lda 	(zTemp0),y
.89f1	85 31		sta $31				sta 	safePtr+1
.89f3	c8		iny				iny
.89f4	b1 36		lda ($36),y			lda 	(zTemp0),y
.89f6	85 32		sta $32				sta 	safePtr+2
.89f8	c8		iny				iny
.89f9	b1 36		lda ($36),y			lda 	(zTemp0),y
.89fb	85 33		sta $33				sta 	safePtr+3
.89fd	c8		iny				iny 								; get Y offset -> Y
.89fe	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a00	a8		tay				tay
.8a01	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start position of parameters
.8a03	ec 16 04	cpx $0416			cpx	 	LastParameter 				; check no parameters at the start
.8a06	f0 13		beq $8a1b			beq 	_ParamExit 					; if so, exit.
.8a08					_ParamExtract:
.8a08	ca		dex				dex 								; put a local term on the level before
.8a09	20 fe 88	jsr $88fe			jsr 	LocaliseNextTerm			; also pushes original param value to basic stack
.8a0c	20 dd 87	jsr $87dd			jsr 	AssignVariable 				; assign stacked value to the variable.
.8a0f	e8		inx				inx 								; advance to next parameter to do.
.8a10	e8		inx				inx
.8a11	ec 16 04	cpx $0416			cpx 	LastParameter 				; are we done ?
.8a14	f0 05		beq $8a1b			beq 	_ParamExit
.8a16	20 b7 8e	jsr $8eb7			jsr 	CheckComma 					; comma seperating parameters
.8a19	80 ed		bra $8a08			bra 	_ParamExtract
.8a1b					_ParamExit:
.8a1b	20 af 8e	jsr $8eaf			jsr 	CheckRightBracket 			; check )
.8a1e	60		rts				rts 								; and continue from here
.8a1f					Command_ENDPROC:
.8a1f	a9 b0		lda #$b0			lda 	#STK_PROC 					; check TOS is this
.8a21	a2 14		ldx #$14			ldx 	#ERRID_PROC
.8a23	20 44 a6	jsr $a644			jsr 	StackCheckFrame
.8a26	20 6d a6	jsr $a66d			jsr 	STKLoadCodePosition 		; restore code position
.8a29	20 36 a6	jsr $a636			jsr 	StackClose
.8a2c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/read.asm

.8a2d					Command_Read:
.8a2d	a2 00		ldx #$00			ldx 	#0 							; evaluate the term which is the var/array element to assign
.8a2f	20 16 98	jsr $9816			jsr 	EvaluateTerm
.8a32	b5 50		lda $50,x			lda 	NSStatus,x
.8a34	29 20		and #$20			and 	#NSBIsReference				; get status byte on stack, identifies int, float, string.
.8a36	f0 4a		beq $8a82			beq 	_CRSyntax 					; check reference (bit 0)
.8a38	20 cb 8a	jsr $8acb			jsr 	SwapDataCodePtrs 			; swap code and data
.8a3b	ad 1c 04	lda $041c			lda 	inDataStatement 			; if in a data statement, we don't need to search
.8a3e	d0 20		bne $8a60			bne 	_CRContinueData
.8a40					_CRKeepSearching:
.8a40	a9 b2		lda #$b2			lda 	#KWD_DATA 					; scan for instruction
.8a42	aa		tax				tax
.8a43	20 a7 8d	jsr $8da7			jsr 	ScanForward
.8a46	c9 b2		cmp #$b2			cmp 	#KWD_DATA 					; found data ?
.8a48	f0 16		beq $8a60			beq 	_CRHaveData 				; found it
.8a4a	18		clc				clc
.8a4b	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8a4d	65 30		adc $30				adc 	codePtr
.8a4f	85 30		sta $30				sta 	codePtr
.8a51	90 02		bcc $8a55			bcc 	_CREExit
.8a53	e6 31		inc $31				inc 	codePtr+1 					; carry
.8a55					_CREExit:
.8a55	a0 03		ldy #$03			ldy 	#3 							; start of line.
.8a57	b2 30		lda ($30)			lda 	(codePtr)
.8a59	d0 e5		bne $8a40			bne 	_CRKeepSearching
.8a5b	a9 0b		lda #$0b		lda	#11
.8a5d	4c c8 8e	jmp $8ec8		jmp	ErrorHandler
.8a60					_CRHaveData:
.8a60					_CRContinueData:
.8a60	a2 01		ldx #$01			ldx 	#1
.8a62	20 1a 9d	jsr $9d1a			jsr 	EvaluateValue 				; evaluate value into slot # 1
.8a65	ca		dex				dex
.8a66	20 dd 87	jsr $87dd			jsr		AssignVariable 				; do the assignment
.8a69	9c 1c 04	stz $041c			stz 	inDataStatement 			; clear in data
.8a6c	b1 30		lda ($30),y			lda 	(codePtr),y
.8a6e	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not, end of data statement
.8a70	d0 04		bne $8a76			bne 	_CRSwapBack
.8a72	c8		iny				iny 								; consume comma
.8a73	ee 1c 04	inc $041c			inc 	inDataStatement 			; set in data statement currently.
.8a76					_CRSwapBack:
.8a76	20 cb 8a	jsr $8acb			jsr 	SwapDataCodePtrs			; swap them back.
.8a79	b1 30		lda ($30),y			lda 	(codePtr),y
.8a7b	c8		iny				iny
.8a7c	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8a7e	f0 ad		beq $8a2d			beq 	Command_Read 				; if so go round again.
.8a80	88		dey				dey 								; unpick get.
.8a81	60		rts				rts
.8a82					_CRSyntax:
.8a82	4c 53 9f	jmp $9f53			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/rem.asm

.8a85					RemCommand:
.8a85	b1 30		lda ($30),y			lda 	(codePtr),y
.8a87	c9 ff		cmp #$ff			cmp 	#KWC_STRING
.8a89	d0 06		bne $8a91			bne 	_RMExit
.8a8b	c8		iny				iny 								; point to offset
.8a8c	98		tya				tya 								; A = offset position
.8a8d	38		sec				sec 								; add size +1 hence SEC
.8a8e	71 30		adc ($30),y			adc 	(codePtr),y
.8a90	a8		tay				tay 								; make current position.
.8a91					_RMExit:
.8a91	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/repeat.asm

.8a92					Command_REPEAT:
.8a92	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; allocate 6 bytes on the return stack.
.8a94	20 18 a6	jsr $a618			jsr 	StackOpen
.8a97	20 5c a6	jsr $a65c			jsr 	STKSaveCodePosition 		; save loop position
.8a9a	60		rts				rts
.8a9b					Command_UNTIL:
.8a9b	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; check REPEAT is TOS
.8a9d	a2 0f		ldx #$0f			ldx 	#ERRID_REPEAT 				; this error
.8a9f	20 44 a6	jsr $a644			jsr 	StackCheckFrame
.8aa2	a2 00		ldx #$00			ldx 	#0
.8aa4	20 23 9d	jsr $9d23			jsr 	EvaluateNumber 				; work out the number
.8aa7	20 f7 9d	jsr $9df7			jsr 	NSMIsZero 					; check if zero
.8aaa	f0 04		beq $8ab0			beq 	_CULoopBack 				; if so keep looping
.8aac	20 36 a6	jsr $a636			jsr 	StackClose		 			; return
.8aaf	60		rts				rts
.8ab0					_CULoopBack:
.8ab0	20 6d a6	jsr $a66d			jsr 	STKLoadCodePosition 		; loop back
.8ab3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/restore.asm

.8ab4					Command_Restore:
.8ab4	20 cb 8a	jsr $8acb			jsr 	SwapDataCodePtrs 			; swap code and data
.8ab7	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8ab9	85 30		sta $30				sta 	codePtr
.8abb	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8abd	85 31		sta $31				sta 	codePtr+1
.8abf	20 cb 8a	jsr $8acb			jsr 	SwapDataCodePtrs 			; put them back
.8ac2	a9 03		lda #$03			lda 	#3 							; start at offset 3, e.g. first instruction of first line.
.8ac4	8d 1b 04	sta $041b			sta 	dataPointer+4
.8ac7	9c 1c 04	stz $041c			stz 	inDataStatement 			; not in data statement
.8aca	60		rts				rts
.8acb					SwapDataCodePtrs:
.8acb	da		phx				phx
.8acc	a2 03		ldx #$03			ldx 	#3 							; swap 32 bit code pointer over
.8ace					_SDCPLoop:
.8ace	b5 30		lda $30,x			lda 	safePtr,x
.8ad0	48		pha				pha
.8ad1	bd 17 04	lda $0417,x			lda 	dataPointer,x
.8ad4	95 30		sta $30,x			sta 	safePtr,x
.8ad6	68		pla				pla
.8ad7	9d 17 04	sta $0417,x			sta 	dataPointer,x
.8ada	ca		dex				dex
.8adb	10 f1		bpl $8ace			bpl 	_SDCPLoop
.8add	ad 1b 04	lda $041b			lda 	dataPointer+4 				; swap Y position over.
.8ae0	8c 1b 04	sty $041b			sty 	dataPointer+4
.8ae3	a8		tay				tay
.8ae4	fa		plx				plx
.8ae5	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/run.asm

.8ae6					EOLCommand:
.8ae6	18		clc				clc
.8ae7	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8ae9	65 30		adc $30				adc 	codePtr
.8aeb	85 30		sta $30				sta 	codePtr
.8aed	90 02		bcc $8af1			bcc 	_CREExit
.8aef	e6 31		inc $31				inc 	codePtr+1 					; carry
.8af1					_CREExit:
.8af1	80 0b		bra $8afe			bra 	RunNewLine
.8af3					CommandRUN:
.8af3	20 24 84	jsr $8424			jsr 	ClearCommand 				; clear variable/stacks/etc.
.8af6	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8af8	85 30		sta $30				sta 	codePtr
.8afa	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8afc	85 31		sta $31				sta 	codePtr+1
.8afe					RUNNewLine:
.8afe	b2 30		lda ($30)			lda 	(codePtr)
.8b00	f0 72		beq $8b74			beq 	CRNoProgram         		; no then END.
.8b02	a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack
.8b04	9a		txs				txs
.8b05					RUNCodePointerLine:
.8b05	a0 02		ldy #$02			ldy 	#2 							; start of program
.8b07					_CRIncMainLoop:
.8b07	0e 13 04	asl $0413			asl 	breakCheck 					; clears 1 time in 8
.8b0a	d0 19		bne $8b25			bne 	_CRNoBreakCheck
.8b0c	20 0c 80	jsr $800c			jsr 	EXTBreakCheck 				; break check
.8b0f	f0 5e		beq $8b6f			beq 	_CRBreak
.8b11	64 01		stz $01				stz 	1 							; access I/O Page 0
.8b13	38		sec				sec 								; calculate timer - LastTick
.8b14	ad 59 d6	lda $d659			lda 	$D659
.8b17	aa		tax				tax 								; saving timer in X
.8b18	ed af 05	sbc $05af			sbc 	LastTick
.8b1b	c9 03		cmp #$03			cmp 	#3
.8b1d	90 06		bcc $8b25			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.8b1f	8e af 05	stx $05af			stx 	LastTick 					; update last timer
.8b22	20 00 9e	jsr $9e00			jsr 	TickHandler 							; go do the code.
.8b25					_NoFireTick:
.8b25					_CRNoBreakCheck:
.8b25	c8		iny				iny
.8b26					_CRMainLoop:
.8b26	9c 10 04	stz $0410			stz 	stringInitialised 			; clear the temporary string initialised flag.
.8b29	b1 30		lda ($30),y			lda 	(codePtr),y
.8b2b	10 10		bpl $8b3d			bpl 	_CRNotKeyword
.8b2d	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1 			; if after unary, legitimate command
.8b2f	b0 04		bcs $8b35			bcs 	_CRIsKeyword
.8b31	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if unary, syntax error.
.8b33	b0 34		bcs $8b69			bcs		_CRSyntaxError
.8b35					_CRIsKeyword:
.8b35	c8		iny				iny 								; consume command
.8b36	0a		asl a				asl 	a 							; double losing the MSB which is '1' as tokens are $80-$FF
.8b37	aa		tax				tax 								; put in X for vector jump
.8b38	20 6c 8b	jsr $8b6c			jsr 	_CRCallVector0 				; call the vector - effectively jsr (vectortable,X)
.8b3b	80 e9		bra $8b26			bra 	_CRMainLoop 				; and loop round
.8b3d					_CRNotKeyword:
.8b3d	c9 3a		cmp #$3a			cmp 	#KWD_COLON 					; if a :, consume it and go round.
.8b3f	f0 c6		beq $8b07			beq 	_CRIncMainLoop
.8b41	c9 40		cmp #$40			cmp 	#$40 						; variable/call reference
.8b43	90 05		bcc $8b4a			bcc 	_CRNotVariable
.8b45					_CRGoLet:
.8b45	20 a4 87	jsr $87a4			jsr 	LetCommand
.8b48	80 dc		bra $8b26			bra 	_CRMainLoop
.8b4a					_CRNotVariable:
.8b4a	c9 10		cmp #$10			cmp 	#KWD_AT 					; handle @
.8b4c	f0 f7		beq $8b45			beq 	_CRGoLet
.8b4e	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; handle ? !
.8b50	f0 f3		beq $8b45			beq 	_CRGoLet
.8b52	c9 21		cmp #$21			cmp 	#KWD_PLING
.8b54	f0 ef		beq $8b45			beq 	_CRGoLet
.8b56	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; handle ' (comment)
.8b58	f0 09		beq $8b63			beq 	_CRGoRem
.8b5a	c9 2e		cmp #$2e			cmp 	#KWD_PERIOD 				; handle . (assembler label)
.8b5c	d0 0b		bne $8b69			bne 	_CRSyntaxError
.8b5e	20 27 82	jsr $8227			jsr 	LabelHere
.8b61	80 c3		bra $8b26			bra 	_CRMainLoop
.8b63					_CRGoRem:
.8b63	c8		iny				iny
.8b64	20 85 8a	jsr $8a85			jsr 	RemCommand
.8b67	80 bd		bra $8b26			bra 	_CRMainLoop
.8b69					_CRSyntaxError:
.8b69	4c 53 9f	jmp $9f53			jmp 	SyntaxError
.8b6c					_CRCallVector0:
.8b6c	7c 0a 8c	jmp ($8c0a,x)			jmp 	(VectorSet0,x)
.8b6f					_CRBreak:
.8b6f	a9 01		lda #$01		lda	#1
.8b71	4c c8 8e	jmp $8ec8		jmp	ErrorHandler
.8b74					CRNoProgram:
.8b74	4c 49 85	jmp $8549			jmp 	EndCommand
.8b77					Shift1Command:
.8b77	b1 30		lda ($30),y			lda 	(codePtr),y
.8b79	c8		iny				iny
.8b7a	0a		asl a				asl 	a
.8b7b	aa		tax				tax
.8b7c	7c a8 8c	jmp ($8ca8,x)			jmp 	(VectorSet1,x)
.8b7f					Shift2Command:
.8b7f	b1 30		lda ($30),y			lda 	(codePtr),y
.8b81	c8		iny				iny
.8b82	0a		asl a				asl 	a
.8b83	aa		tax				tax
.8b84	7c c8 8c	jmp ($8cc8,x)			jmp 	(VectorSet2,x)
.8b87					Unused1:
.8b87					Unused2:
.8b87					Unused3:
.8b87					Unused4:
.8b87	4c 53 9f	jmp $9f53			jmp 	SyntaxError
>8b8a							.align 2

;******  Processing file: ./common/commands/../generated/vectors.dat

.8b8a					VectorSetPunc:
>8b8a	80 91					.word	ShiftLeft                        ; $00 <<
>8b8c	6b 8f					.word	BinaryCompareLessEqual           ; $01 <=
>8b8e	61 8f					.word	BinaryCompareNotEqual            ; $02 <>
>8b90	53 9f					.word	SyntaxError                      ; $03 !!3
>8b92	53 9f					.word	SyntaxError                      ; $04 ><
>8b94	75 8f					.word	BinaryCompareGreaterEqual        ; $05 >=
>8b96	83 91					.word	ShiftRight                       ; $06 >>
>8b98	53 9f					.word	SyntaxError                      ; $07 !!7
>8b9a	53 9f					.word	SyntaxError                      ; $08 !!8
>8b9c	53 9f					.word	SyntaxError                      ; $09 !!9
>8b9e	53 9f					.word	SyntaxError                      ; $0a !!10
>8ba0	53 9f					.word	SyntaxError                      ; $0b !!11
>8ba2	53 9f					.word	SyntaxError                      ; $0c !!12
>8ba4	53 9f					.word	SyntaxError                      ; $0d !!13
>8ba6	53 9f					.word	SyntaxError                      ; $0e !!14
>8ba8	53 9f					.word	SyntaxError                      ; $0f !!15
>8baa	53 9f					.word	SyntaxError                      ; $10 @
>8bac	53 9f					.word	SyntaxError                      ; $11 !!17
>8bae	53 9f					.word	SyntaxError                      ; $12 !!18
>8bb0	53 9f					.word	SyntaxError                      ; $13 [
>8bb2	2c 90					.word	IntegerDivide                    ; $14 \
>8bb4	53 9f					.word	SyntaxError                      ; $15 ]
>8bb6	be 92					.word	EorInteger                       ; $16 ^
>8bb8	53 9f					.word	SyntaxError                      ; $17 _
>8bba	53 9f					.word	SyntaxError                      ; $18 `
>8bbc	53 9f					.word	SyntaxError                      ; $19 !!25
>8bbe	53 9f					.word	SyntaxError                      ; $1a !!26
>8bc0	53 9f					.word	SyntaxError                      ; $1b {
>8bc2	89 92					.word	OraInteger                       ; $1c |
>8bc4	53 9f					.word	SyntaxError                      ; $1d }
>8bc6	53 9f					.word	SyntaxError                      ; $1e ~
>8bc8	53 9f					.word	SyntaxError                      ; $1f [7m<7F>[m
>8bca	53 9f					.word	SyntaxError                      ; $20
>8bcc	f3 92					.word	WordIndirect                     ; $21 !
>8bce	53 9f					.word	SyntaxError                      ; $22 "
>8bd0	53 9f					.word	SyntaxError                      ; $23 #
>8bd2	53 9f					.word	SyntaxError                      ; $24 $
>8bd4	6d 90					.word	IntegerModulus                   ; $25 %
>8bd6	54 92					.word	AndInteger                       ; $26 &
>8bd8	53 9f					.word	SyntaxError                      ; $27 '
>8bda	53 9f					.word	SyntaxError                      ; $28 (
>8bdc	53 9f					.word	SyntaxError                      ; $29 )
>8bde	db 90					.word	MulInteger                       ; $2a *
>8be0	f6 91					.word	AddInteger                       ; $2b +
>8be2	53 9f					.word	SyntaxError                      ; $2c ,
>8be4	2f 92					.word	SubInteger                       ; $2d -
>8be6	53 9f					.word	SyntaxError                      ; $2e .
>8be8	ad 94					.word	FDivideCommand                   ; $2f /
>8bea	53 9f					.word	SyntaxError                      ; $30 0
>8bec	53 9f					.word	SyntaxError                      ; $31 1
>8bee	53 9f					.word	SyntaxError                      ; $32 2
>8bf0	53 9f					.word	SyntaxError                      ; $33 3
>8bf2	53 9f					.word	SyntaxError                      ; $34 4
>8bf4	53 9f					.word	SyntaxError                      ; $35 5
>8bf6	53 9f					.word	SyntaxError                      ; $36 6
>8bf8	53 9f					.word	SyntaxError                      ; $37 7
>8bfa	53 9f					.word	SyntaxError                      ; $38 8
>8bfc	53 9f					.word	SyntaxError                      ; $39 9
>8bfe	53 9f					.word	SyntaxError                      ; $3a :
>8c00	53 9f					.word	SyntaxError                      ; $3b ;
>8c02	4d 8f					.word	BinaryCompareLess                ; $3c <
>8c04	43 8f					.word	BinaryCompareEqual               ; $3d =
>8c06	57 8f					.word	BinaryCompareGreater             ; $3e >
>8c08	15 93					.word	ByteIndirect                     ; $3f ?
.8c0a					VectorSet0:
>8c0a	e6 8a					.word	EOLCommand                       ; $80 !0:EOF
>8c0c	77 8b					.word	Shift1Command                    ; $81 !1:SH1
>8c0e	7f 8b					.word	Shift2Command                    ; $82 !2:SH2
>8c10	92 99					.word	AbsUnary                         ; $83 ABS(
>8c12	a0 99					.word	AllocUnary                       ; $84 ALLOC(
>8c14	10 9a					.word	AscUnary                         ; $85 ASC(
>8c16	bb 9b					.word	ChrUnary                         ; $86 CHR$(
>8c18	a3 a3					.word	UnaryEvent                       ; $87 EVENT(
>8c1a	3f 8f					.word	UnaryFalse                       ; $88 FALSE
>8c1c	1d 9a					.word	FracUnary                        ; $89 FRAC(
>8c1e	3f a3					.word	UnaryHit                         ; $8a HIT(
>8c20	32 9a					.word	IntUnary                         ; $8b INT(
>8c22	7a 9b					.word	IsValUnary                       ; $8c ISVAL(
>8c24	27 a4					.word	UnaryJoyB                        ; $8d JOYB(
>8c26	00 a4					.word	UnaryJoyX                        ; $8e JOYX(
>8c28	03 a4					.word	UnaryJoyY                        ; $8f JOYY(
>8c2a	8e 9c					.word	Unary_Left                       ; $90 LEFT$(
>8c2c	43 9a					.word	LenUnary                         ; $91 LEN(
>8c2e	61 9a					.word	Unary_Max                        ; $92 MAX(
>8c30	b0 9c					.word	Unary_Mid                        ; $93 MID$(
>8c32	5d 9a					.word	Unary_Min                        ; $94 MIN(
>8c34	ac 9a					.word	Unary_Not                        ; $95 NOT(
>8c36	74 a5					.word	UnaryPlaying                     ; $96 PLAYING(
>8c38	bf 9a					.word	Unary_Random                     ; $97 RANDOM(
>8c3a	9b 9c					.word	Unary_Right                      ; $98 RIGHT$(
>8c3c	dc 9a					.word	Unary_Rnd                        ; $99 RND(
>8c3e	52 9b					.word	SgnUnary                         ; $9a SGN(
>8c40	cd 9b					.word	SpcUnary                         ; $9b SPC(
>8c42	e8 9b					.word	Unary_Str                        ; $9c STR$(
>8c44	4d a4					.word	UnaryTimer                       ; $9d TIMER(
>8c46	34 8f					.word	UnaryTrue                        ; $9e TRUE
>8c48	70 9b					.word	ValUnary                         ; $9f VAL(
>8c4a	4c 85					.word	ForCommand                       ; $a0 FOR
>8c4c	8f 86					.word	IfCommand                        ; $a1 IF
>8c4e	87 8b					.word	Unused1                          ; $a2 PROC
>8c50	92 8a					.word	Command_REPEAT                   ; $a3 REPEAT
>8c52	1d 8e					.word	Command_WHILE                    ; $a4 WHILE
>8c54	b8 86					.word	EndIf                            ; $a5 ENDIF
>8c56	1f 8a					.word	Command_ENDPROC                  ; $a6 ENDPROC
>8c58	fe 85					.word	NextCommand                      ; $a7 NEXT
>8c5a	87 8b					.word	Unused4                          ; $a8 THEN
>8c5c	9b 8a					.word	Command_UNTIL                    ; $a9 UNTIL
>8c5e	3e 8e					.word	Command_WEND                     ; $aa WEND
>8c60	53 9f					.word	SyntaxError                      ; $ab BY
>8c62	ef 83					.word	CallCommand                      ; $ac CALL
>8c64	f3 a0					.word	CircleCommand                    ; $ad CIRCLE
>8c66	24 84					.word	ClearCommand                     ; $ae CLEAR
>8c68	7c 84					.word	ClearScreen                      ; $af CLS
>8c6a	53 9f					.word	SyntaxError                      ; $b0 COLOR
>8c6c	53 9f					.word	SyntaxError                      ; $b1 COLOUR
>8c6e	84 84					.word	Command_Data                     ; $b2 DATA
>8c70	8c 84					.word	DimCommand                       ; $b3 DIM
>8c72	87 8b					.word	Unused3                          ; $b4 DOWNTO
>8c74	b1 86					.word	ElseCode                         ; $b5 ELSE
>8c76	53 9f					.word	SyntaxError                      ; $b6 FROM
>8c78	12 a3					.word	GfxCommand                       ; $b7 GFX
>8c7a	57 86					.word	Command_GOSUB                    ; $b8 GOSUB
>8c7c	75 86					.word	GotoCommand                      ; $b9 GOTO
>8c7e	53 9f					.word	SyntaxError                      ; $ba HERE
>8c80	1c a1					.word	ImageCommand                     ; $bb IMAGE
>8c82	b9 86					.word	Command_Input                    ; $bc INPUT
>8c84	a4 87					.word	LetCommand                       ; $bd LET
>8c86	6e a1					.word	LineCommand                      ; $be LINE
>8c88	f0 88					.word	Command_LOCAL                    ; $bf LOCAL
>8c8a	53 9f					.word	SyntaxError                      ; $c0 OFF
>8c8c	53 9f					.word	SyntaxError                      ; $c1 ON
>8c8e	53 9f					.word	SyntaxError                      ; $c2 OUTLINE
>8c90	63 a3					.word	PaletteCommand                   ; $c3 PALETTE
>8c92	67 a1					.word	PlotCommand                      ; $c4 PLOT
>8c94	c0 86					.word	Command_Print                    ; $c5 PRINT
>8c96	2d 8a					.word	Command_Read                     ; $c6 READ
>8c98	ef a0					.word	RectangleCommand                 ; $c7 RECT
>8c9a	85 8a					.word	RemCommand                       ; $c8 REM
>8c9c	67 86					.word	Command_RETURN                   ; $c9 RETURN
>8c9e	53 9f					.word	SyntaxError                      ; $ca SOLID
>8ca0	90 a5					.word	SoundCommand                     ; $cb SOUND
>8ca2	fe a0					.word	SpriteCommand                    ; $cc SPRITE
>8ca4	38 a1					.word	TextCommand                      ; $cd TEXT
>8ca6	87 8b					.word	Unused2                          ; $ce TO
.8ca8					VectorSet1:
>8ca8	53 9f					.word	SyntaxError                      ; $80 !0:EOF
>8caa	53 9f					.word	SyntaxError                      ; $81 !1:SH1
>8cac	53 9f					.word	SyntaxError                      ; $82 !2:SH2
>8cae	c3 83					.word	AssembleCommand                  ; $83 ASSEMBLE
>8cb0	df 83					.word	AssertCommand                    ; $84 ASSERT
>8cb2	b2 a2					.word	BitmapCtrl                       ; $85 BITMAP
>8cb4	49 85					.word	EndCommand                       ; $86 END
>8cb6	44 a4					.word	GoCommand                        ; $87 GO
>8cb8	f4 87					.word	Command_List                     ; $88 LIST
>8cba	3b a4					.word	LoadCommand                      ; $89 LOAD
>8cbc	b1 89					.word	NewCommand                       ; $8a NEW
>8cbe	b4 8a					.word	Command_Restore                  ; $8b RESTORE
>8cc0	f3 8a					.word	CommandRUN                       ; $8c RUN
>8cc2	f7 a2					.word	SpritesCtrl                      ; $8d SPRITES
>8cc4	50 8d					.word	StopCommand                      ; $8e STOP
>8cc6	4c 8e					.word	WhoCommand                       ; $8f WHO
.8cc8					VectorSet2:
>8cc8	53 9f					.word	SyntaxError                      ; $80 !0:EOF
>8cca	53 9f					.word	SyntaxError                      ; $81 !1:SH1
>8ccc	53 9f					.word	SyntaxError                      ; $82 !2:SH2
>8cce	12 9e					.word	Assemble_adc                     ; $83 ADC
>8cd0	0a 9e					.word	Assemble_and                     ; $84 AND
>8cd2	26 9e					.word	Assemble_asl                     ; $85 ASL
>8cd4	90 9e					.word	Assemble_bcc                     ; $86 BCC
>8cd6	94 9e					.word	Assemble_bcs                     ; $87 BCS
>8cd8	9c 9e					.word	Assemble_beq                     ; $88 BEQ
>8cda	53 9e					.word	Assemble_bit                     ; $89 BIT
>8cdc	84 9e					.word	Assemble_bmi                     ; $8a BMI
>8cde	98 9e					.word	Assemble_bne                     ; $8b BNE
>8ce0	80 9e					.word	Assemble_bpl                     ; $8c BPL
>8ce2	a0 9e					.word	Assemble_bra                     ; $8d BRA
>8ce4	a4 9e					.word	Assemble_brk                     ; $8e BRK
>8ce6	88 9e					.word	Assemble_bvc                     ; $8f BVC
>8ce8	8c 9e					.word	Assemble_bvs                     ; $90 BVS
>8cea	ac 9e					.word	Assemble_clc                     ; $91 CLC
>8cec	00 9f					.word	Assemble_cld                     ; $92 CLD
>8cee	c0 9e					.word	Assemble_cli                     ; $93 CLI
>8cf0	f0 9e					.word	Assemble_clv                     ; $94 CLV
>8cf2	1e 9e					.word	Assemble_cmp                     ; $95 CMP
>8cf4	67 9e					.word	Assemble_cpx                     ; $96 CPX
>8cf6	62 9e					.word	Assemble_cpy                     ; $97 CPY
>8cf8	44 9e					.word	Assemble_dec                     ; $98 DEC
>8cfa	fc 9e					.word	Assemble_dex                     ; $99 DEX
>8cfc	d8 9e					.word	Assemble_dey                     ; $9a DEY
>8cfe	0e 9e					.word	Assemble_eor                     ; $9b EOR
>8d00	49 9e					.word	Assemble_inc                     ; $9c INC
>8d02	0c 9f					.word	Assemble_inx                     ; $9d INX
>8d04	f8 9e					.word	Assemble_iny                     ; $9e INY
>8d06	7b 9e					.word	Assemble_jmp                     ; $9f JMP
>8d08	76 9e					.word	Assemble_jsr                     ; $a0 JSR
>8d0a	1a 9e					.word	Assemble_lda                     ; $a1 LDA
>8d0c	3f 9e					.word	Assemble_ldx                     ; $a2 LDX
>8d0e	5d 9e					.word	Assemble_ldy                     ; $a3 LDY
>8d10	30 9e					.word	Assemble_lsr                     ; $a4 LSR
>8d12	10 9f					.word	Assemble_nop                     ; $a5 NOP
>8d14	06 9e					.word	Assemble_ora                     ; $a6 ORA
>8d16	bc 9e					.word	Assemble_pha                     ; $a7 PHA
>8d18	a8 9e					.word	Assemble_php                     ; $a8 PHP
>8d1a	04 9f					.word	Assemble_phx                     ; $a9 PHX
>8d1c	c4 9e					.word	Assemble_phy                     ; $aa PHY
>8d1e	cc 9e					.word	Assemble_pla                     ; $ab PLA
>8d20	b0 9e					.word	Assemble_plp                     ; $ac PLP
>8d22	18 9f					.word	Assemble_plx                     ; $ad PLX
>8d24	d4 9e					.word	Assemble_ply                     ; $ae PLY
>8d26	2b 9e					.word	Assemble_rol                     ; $af ROL
>8d28	35 9e					.word	Assemble_ror                     ; $b0 ROR
>8d2a	b8 9e					.word	Assemble_rti                     ; $b1 RTI
>8d2c	c8 9e					.word	Assemble_rts                     ; $b2 RTS
>8d2e	22 9e					.word	Assemble_sbc                     ; $b3 SBC
>8d30	b4 9e					.word	Assemble_sec                     ; $b4 SEC
>8d32	14 9f					.word	Assemble_sed                     ; $b5 SED
>8d34	d0 9e					.word	Assemble_sei                     ; $b6 SEI
>8d36	16 9e					.word	Assemble_sta                     ; $b7 STA
>8d38	08 9f					.word	Assemble_stp                     ; $b8 STP
>8d3a	3a 9e					.word	Assemble_stx                     ; $b9 STX
>8d3c	58 9e					.word	Assemble_sty                     ; $ba STY
>8d3e	4e 9e					.word	Assemble_stz                     ; $bb STZ
>8d40	ec 9e					.word	Assemble_tax                     ; $bc TAX
>8d42	e8 9e					.word	Assemble_tay                     ; $bd TAY
>8d44	71 9e					.word	Assemble_trb                     ; $be TRB
>8d46	6c 9e					.word	Assemble_tsb                     ; $bf TSB
>8d48	f4 9e					.word	Assemble_tsx                     ; $c0 TSX
>8d4a	dc 9e					.word	Assemble_txa                     ; $c1 TXA
>8d4c	e4 9e					.word	Assemble_txs                     ; $c2 TXS
>8d4e	e0 9e					.word	Assemble_tya                     ; $c3 TYA

;******  Return to file: ./common/commands/run.asm


;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/stop.asm

.8d50					StopCommand:
.8d50	a9 08		lda #$08		lda	#8
.8d52	4c c8 8e	jmp $8ec8		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/procscan.asm

.8d55					ProcedureScan:
.8d55	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8d57	85 30		sta $30				sta 	codePtr
.8d59	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8d5b	85 31		sta $31				sta 	codePtr+1
.8d5d					_PSLoop:
.8d5d	b2 30		lda ($30)			lda 	(codePtr)
.8d5f	f0 42		beq $8da3			beq 	_PSExit
.8d61	a0 03		ldy #$03			ldy 	#3 							; is it PROC ?
.8d63	b1 30		lda ($30),y			lda 	(codePtr),y
.8d65	c9 a2		cmp #$a2			cmp 	#KWD_PROC
.8d67	d0 2d		bne $8d96			bne 	_PSNext
.8d69	c8		iny				iny 								; get the address of the record to zTemp0 and
.8d6a	b1 30		lda ($30),y			lda 	(codePtr),y
.8d6c	29 c0		and #$c0			and 	#$C0
.8d6e	c9 40		cmp #$40			cmp 	#$40
.8d70	d0 32		bne $8da4			bne 	_PSSyntax
.8d72	b1 30		lda ($30),y			lda 	(codePtr),y
.8d74	18		clc				clc
.8d75	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8d77	85 37		sta $37				sta 	zTemp0+1
.8d79	c8		iny				iny 								; LSB
.8d7a	b1 30		lda ($30),y			lda 	(codePtr),y
.8d7c	85 36		sta $36				sta 	zTemp0
.8d7e	c8		iny				iny 								; character after variable call.
.8d7f	98		tya				tya 								; save Y offset at +7
.8d80	a0 07		ldy #$07			ldy 	#7
.8d82	91 36		sta ($36),y			sta 	(zTemp0),y
.8d84	a9 18		lda #$18			lda 	#NSTProcedure 				; mark it as procedure
.8d86	a0 02		ldy #$02			ldy 	#2
.8d88	91 36		sta ($36),y			sta 	(zTemp0),y
.8d8a	a2 00		ldx #$00			ldx 	#0 							; copy code-Ptr in
.8d8c					_PSCopy:
.8d8c	b5 30		lda $30,x			lda 	safePtr,x
.8d8e	c8		iny				iny
.8d8f	91 36		sta ($36),y			sta 	(zTemp0),y
.8d91	e8		inx				inx
.8d92	e0 04		cpx #$04			cpx 	#4
.8d94	d0 f6		bne $8d8c			bne 	_PSCopy
.8d96					_PSNext:
.8d96	18		clc				clc
.8d97	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8d99	65 30		adc $30				adc 	codePtr
.8d9b	85 30		sta $30				sta 	codePtr
.8d9d	90 02		bcc $8da1			bcc 	_CREExit
.8d9f	e6 31		inc $31				inc 	codePtr+1 					; carry
.8da1					_CREExit:
.8da1	80 ba		bra $8d5d			bra 	_PSLoop
.8da3					_PSExit:
.8da3	60		rts				rts
.8da4					_PSSyntax:
.8da4	4c 53 9f	jmp $9f53			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/scanforward.asm

.8da7					ScanForward:
.8da7	64 38		stz $38				stz 	zTemp1 						; this is the structure count - goes up with WHILE/FOR
.8da9	86 37		stx $37				stx 	zTemp0+1
.8dab	85 36		sta $36				sta 	zTemp0 						; save XA as the two possible matches.
.8dad					_ScanLoop:
.8dad	b1 30		lda ($30),y			lda 	(codePtr),y
.8daf	c8		iny				iny
.8db0	a6 38		ldx $38				ldx 	zTemp1 						; if the count is > 0 cannot match as in substructure
.8db2	d0 0e		bne $8dc2			bne 	_ScanGoNext
.8db4	c5 36		cmp $36				cmp 	zTemp0 						; see if either matches
.8db6	f0 04		beq $8dbc			beq 	_ScanMatch
.8db8	c5 37		cmp $37				cmp 	zTemp0+1
.8dba	d0 06		bne $8dc2			bne 	_ScanGoNext
.8dbc					_ScanMatch:
.8dbc	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if asked for EOL, backtrack.
.8dbe	d0 01		bne $8dc1			bne 	_ScanNotEndEOL
.8dc0	88		dey				dey
.8dc1					_ScanNotEndEOL:
.8dc1	60		rts				rts
.8dc2					_ScanGoNext:
.8dc2	20 c7 8d	jsr $8dc7			jsr  	ScanForwardOne
.8dc5	80 e6		bra $8dad			bra 	_ScanLoop
.8dc7					ScanForwardOne:
.8dc7	c9 40		cmp #$40			cmp 	#$40 						; if 00-3F, punctuation characters, loop back
.8dc9	90 3e		bcc $8e09			bcc 	_SFWExit
.8dcb	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if 40-82, skip one extra.
.8dcd	90 18		bcc $8de7			bcc 	_ScanSkipOne
.8dcf	c9 fc		cmp #$fc			cmp 	#$FC 						; FC-FF are data skips
.8dd1	b0 2f		bcs $8e02			bcs 	_ScanSkipData
.8dd3	c9 a0		cmp #$a0			cmp 	#KWC_FIRST_STRUCTURE 		; structure keyword ?
.8dd5	90 32		bcc $8e09			bcc 	_SFWExit 					; if not, ordinary keywords.
.8dd7	c9 ab		cmp #$ab			cmp 	#KWC_LAST_STRUCTURE+1
.8dd9	b0 2e		bcs $8e09			bcs 	_SFWExit
.8ddb	c6 38		dec $38				dec 	zTemp1 						; decrement the sructure count
.8ddd	c9 a5		cmp #$a5			cmp 	#KWC_FIRST_STRUCTURE_DEC 	; back if it is a dec structure (e.g. WEND/NEXT)
.8ddf	b0 28		bcs $8e09			bcs 	_SFWExit
.8de1	e6 38		inc $38				inc 	zTemp1 						; so it's an increment structure
.8de3	e6 38		inc $38				inc 	zTemp1 						; twice to undo the dec
.8de5	80 22		bra $8e09			bra 	_SFWExit
.8de7					_ScanSkipOne:
.8de7	c8		iny				iny 								; consume the extra one.
.8de8	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if not EOL loop back
.8dea	d0 1d		bne $8e09			bne 	_SFWExit
.8dec	18		clc				clc
.8ded	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8def	65 30		adc $30				adc 	codePtr
.8df1	85 30		sta $30				sta 	codePtr
.8df3	90 02		bcc $8df7			bcc 	_CREExit
.8df5	e6 31		inc $31				inc 	codePtr+1 					; carry
.8df7					_CREExit:
.8df7	a0 03		ldy #$03			ldy 	#3 							; scan start position.
.8df9	b2 30		lda ($30)			lda 	(codePtr)
.8dfb	d0 0c		bne $8e09			bne 	_SFWExit 					; if not zero, more to scan
.8dfd	a9 13		lda #$13		lda	#19
.8dff	4c c8 8e	jmp $8ec8		jmp	ErrorHandler
.8e02					_ScanSkipData:
.8e02	88		dey				dey 								; point at data token
.8e03	c8		iny				iny 								; point to offset
.8e04	98		tya				tya 								; A = offset position
.8e05	38		sec				sec 								; add size +1 hence SEC
.8e06	71 30		adc ($30),y			adc 	(codePtr),y
.8e08	a8		tay				tay 								; make current position.
.8e09					_SFWExit:
.8e09	60		rts				rts
.8e0a					ScanGetCurrentLineStep:
.8e0a	64 38		stz $38				stz 	zTemp1
.8e0c	a0 03		ldy #$03			ldy 	#3
.8e0e					_SGCLSLoop:
.8e0e	b1 30		lda ($30),y			lda 	(codePtr),y
.8e10	c8		iny				iny
.8e11	c9 80		cmp #$80			cmp 	#KWC_EOL	 				; if EOL exit
.8e13	f0 05		beq $8e1a			beq 	_SGCLSExit
.8e15	20 c7 8d	jsr $8dc7			jsr 	ScanForwardOne
.8e18	80 f4		bra $8e0e			bra 	_SGCLSLoop
.8e1a					_SGCLSExit:
.8e1a	a5 38		lda $38				lda 	zTemp1
.8e1c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/while.asm

.8e1d					Command_WHILE:
.8e1d	5a		phy				phy 								; save position of the test
.8e1e	a2 00		ldx #$00			ldx 	#0
.8e20	20 23 9d	jsr $9d23			jsr 	EvaluateNumber 				; work out the number
.8e23	20 f7 9d	jsr $9df7			jsr 	NSMIsZero 					; check if zero
.8e26	f0 0e		beq $8e36			beq 	_WHExitLoop 				; if so exit the loop
.8e28	98		tya				tya 								; position *after* test.
.8e29	7a		ply				ply 								; restore position before test, at WHILE
.8e2a	88		dey				dey
.8e2b	48		pha				pha 								; push after test on the stack
.8e2c	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; allocate 6 bytes on the return stack.
.8e2e	20 18 a6	jsr $a618			jsr 	StackOpen
.8e31	20 5c a6	jsr $a65c			jsr 	STKSaveCodePosition 		; save loop position - where the test value is.
.8e34	7a		ply				ply 								; restore the position *after* the test
.8e35	60		rts				rts
.8e36					_WHExitLoop:
.8e36	68		pla				pla 								; throw post loop position
.8e37	a9 aa		lda #$aa			lda 	#KWD_WEND 					; scan forward past WEND
.8e39	aa		tax				tax
.8e3a	20 a7 8d	jsr $8da7			jsr 	ScanForward
.8e3d	60		rts				rts
.8e3e					Command_WEND:
.8e3e	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; check WHILE is TOS
.8e40	a2 10		ldx #$10			ldx 	#ERRID_WHILE 				; this error
.8e42	20 44 a6	jsr $a644			jsr 	StackCheckFrame
.8e45	20 6d a6	jsr $a66d			jsr 	STKLoadCodePosition 		; loop back
.8e48	20 36 a6	jsr $a636			jsr 	StackClose		 			; erase the frame
.8e4b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/who.asm

.8e4c					WhoCommand:
.8e4c	a2 8e		ldx #$8e			ldx 	#(_WHOMessage >> 8)
.8e4e	a9 54		lda #$54			lda 	#(_WHOMessage & $FF)
.8e50	20 21 8f	jsr $8f21			jsr 	PrintStringXA
.8e53	60		rts				rts
.8e54					_WHOMessage:
>8e54	81						.byte 	$81
>8e55	42 72 6f 75 67 68 74 20				.text 	"Brought to you by :",13,13
>8e5d	74 6f 20 79 6f 75 20 62 79 20 3a 0d 0d
>8e6a	09 53 74 65 66 61 6e 79				.text 	9,"Stefany Allaire",13
>8e72	20 41 6c 6c 61 69 72 65 0d
>8e7b	09 4a 65 73 73 69 65 20				.text 	9,"Jessie Oberreuter",13
>8e83	4f 62 65 72 72 65 75 74 65 72 0d
>8e8e	09 50 61 75 6c 20 52 6f				.text 	9,"Paul Robson",13
>8e96	62 73 6f 6e 0d
>8e9b	09 50 65 74 65 72 20 57				.text 	9,"Peter Weingartner",13
>8ea3	65 69 6e 67 61 72 74 6e 65 72 0d
>8eae	00						.byte 	0

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/charcheck.asm

.8eaf					CheckRightBracket:
.8eaf	b1 30		lda ($30),y			lda 	(codePtr),y
.8eb1	c8		iny				iny
.8eb2	c9 29		cmp #$29			cmp 	#KWD_RPAREN 						; exit if matches
.8eb4	d0 0f		bne $8ec5			bne 	CNAFail
.8eb6	60		rts				rts
.8eb7					CheckComma:
.8eb7	b1 30		lda ($30),y			lda 	(codePtr),y
.8eb9	c8		iny				iny
.8eba	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 						; exit if matches
.8ebc	d0 07		bne $8ec5			bne 	CNAFail
.8ebe	60		rts				rts
.8ebf					CheckNextA:
.8ebf	d1 30		cmp ($30),y			cmp 	(codePtr),y
.8ec1	d0 02		bne $8ec5			bne 	CNAFail
.8ec3	c8		iny				iny 								; skip character
.8ec4	60		rts				rts 								; and exit
.8ec5					CNAFail:
.8ec5	4c 53 9f	jmp $9f53			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/errors.asm

.8ec8					ErrorHandler:
.8ec8	a8		tay				tay 								; find the error text
.8ec9	f0 49		beq $8f14			beq 	_EHEnd
.8ecb	a2 00		ldx #$00			ldx 	#0
.8ecd	a9 6c		lda #$6c			lda 	#((ErrorText) & $FF)
.8ecf	85 36		sta $36				sta 	0+zTemp0
.8ed1	a9 9f		lda #$9f			lda 	#((ErrorText) >> 8)
.8ed3	85 37		sta $37				sta 	1+zTemp0
.8ed5					_EHFind:
.8ed5	88		dey				dey 								; found the error text ?
.8ed6	f0 0e		beq $8ee6			beq 	_EHFound
.8ed8					_EHFindZero:
.8ed8	b2 36		lda ($36)			lda 	(zTemp0) 					; find the next error
.8eda	e6 36		inc $36				inc 	zTemp0
.8edc	d0 02		bne $8ee0			bne 	_EHFNoCarry
.8ede	e6 37		inc $37				inc 	zTemp0+1
.8ee0					_EHFNoCarry:
.8ee0	c9 00		cmp #$00			cmp 	#0
.8ee2	d0 f4		bne $8ed8			bne 	_EHFindZero
.8ee4	80 ef		bra $8ed5			bra 	_EHFind
.8ee6					_EHFound:
.8ee6	a5 36		lda $36				lda 	zTemp0 						; print message
.8ee8	a6 37		ldx $37				ldx 	zTemp0+1
.8eea	20 21 8f	jsr $8f21			jsr 	PrintStringXA
.8eed	a0 01		ldy #$01			ldy 	#1 							; if line number zero don't print i
.8eef	b1 30		lda ($30),y			lda 	(codePtr),y
.8ef1	d0 05		bne $8ef8			bne 	_EHAtMsg
.8ef3	c8		iny				iny
.8ef4	b1 30		lda ($30),y			lda 	(codePtr),y
.8ef6	f0 17		beq $8f0f			beq 	_EHCREnd
.8ef8					_EHAtMsg:
.8ef8	a2 8f		ldx #$8f			ldx 	#_AtMsg >> 8 				; print " at "
.8efa	a9 17		lda #$17			lda 	#_AtMsg & $FF
.8efc	20 21 8f	jsr $8f21			jsr 	PrintStringXA
.8eff	a0 01		ldy #$01			ldy 	#1 							; line number into XA
.8f01	b1 30		lda ($30),y			lda 	(codePtr),y
.8f03	48		pha				pha
.8f04	c8		iny				iny
.8f05	b1 30		lda ($30),y			lda 	(codePtr),y
.8f07	aa		tax				tax
.8f08	68		pla				pla
.8f09	20 37 93	jsr $9337			jsr 	ConvertInt16 				; convert XA to string
.8f0c	20 21 8f	jsr $8f21			jsr 	PrintStringXA 				; and print it.
.8f0f					_EHCREnd:
.8f0f	a9 0d		lda #$0d			lda 	#13 						; new line
.8f11	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8f14					_EHEnd:
.8f14	4c 8e 83	jmp $838e			jmp 	WarmStart
>8f17	20 61 74 20 6c 69 6e 65		_AtMsg:	.text 	" at line ",0
>8f1f	20 00
.8f21					PrintStringXA:
.8f21	5a		phy				phy
.8f22	86 37		stx $37				stx 	zTemp0+1
.8f24	85 36		sta $36				sta 	zTemp0
.8f26	a0 00		ldy #$00			ldy 	#0
.8f28					_PSXALoop:
.8f28	b1 36		lda ($36),y			lda 	(zTemp0),y
.8f2a	f0 06		beq $8f32			beq 	_PSXAExit
.8f2c	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8f2f	c8		iny				iny
.8f30	80 f6		bra $8f28			bra 	_PSXALoop
.8f32					_PSXAExit:
.8f32	7a		ply				ply
.8f33	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/compare.asm

.8f34					UnaryTrue:
.8f34	fa		plx				plx
.8f35					ReturnTrue:
.8f35	a9 01		lda #$01			lda 	#1  						; set to 1
.8f37	20 d7 9d	jsr $9dd7			jsr 	NSMSetByte
.8f3a	a9 80		lda #$80			lda 	#$80 						; set sign flag, so it is -1
.8f3c	95 50		sta $50,x			sta 	NSStatus,x
.8f3e	60		rts				rts
.8f3f					UnaryFalse:
.8f3f	fa		plx				plx
.8f40					ReturnFalse:
.8f40	4c d5 9d	jmp $9dd5			jmp 	NSMSetZero 					; set it all to zero
.8f43					BinaryCompareEqual:
.8f43	fa		plx				plx
.8f44	20 7f 8f	jsr $8f7f			jsr 	CompareBaseCode
.8f47	c9 00		cmp #$00			cmp 	#0
.8f49	f0 ea		beq $8f35			beq 	ReturnTrue
.8f4b	80 f3		bra $8f40			bra 	ReturnFalse
.8f4d					BinaryCompareLess:
.8f4d	fa		plx				plx
.8f4e	20 7f 8f	jsr $8f7f			jsr 	CompareBaseCode
.8f51	c9 ff		cmp #$ff			cmp 	#$FF
.8f53	f0 e0		beq $8f35			beq 	ReturnTrue
.8f55	80 e9		bra $8f40			bra 	ReturnFalse
.8f57					BinaryCompareGreater:
.8f57	fa		plx				plx
.8f58	20 7f 8f	jsr $8f7f			jsr 	CompareBaseCode
.8f5b	c9 01		cmp #$01			cmp 	#1
.8f5d	f0 d6		beq $8f35			beq 	ReturnTrue
.8f5f	80 df		bra $8f40			bra 	ReturnFalse
.8f61					BinaryCompareNotEqual:
.8f61	fa		plx				plx
.8f62	20 7f 8f	jsr $8f7f			jsr 	CompareBaseCode
.8f65	c9 00		cmp #$00			cmp 	#0
.8f67	d0 cc		bne $8f35			bne 	ReturnTrue
.8f69	80 d5		bra $8f40			bra 	ReturnFalse
.8f6b					BinaryCompareLessEqual:
.8f6b	fa		plx				plx
.8f6c	20 7f 8f	jsr $8f7f			jsr 	CompareBaseCode
.8f6f	c9 01		cmp #$01			cmp 	#1
.8f71	d0 c2		bne $8f35			bne 	ReturnTrue
.8f73	80 cb		bra $8f40			bra 	ReturnFalse
.8f75					BinaryCompareGreaterEqual:
.8f75	fa		plx				plx
.8f76	20 7f 8f	jsr $8f7f			jsr 	CompareBaseCode
.8f79	c9 ff		cmp #$ff			cmp 	#$FF
.8f7b	d0 b8		bne $8f35			bne 	ReturnTrue
.8f7d	80 c1		bra $8f40			bra 	ReturnFalse
.8f7f					CompareBaseCode:
.8f7f	20 8a 96	jsr $968a			jsr 	DereferenceTopTwo 			; make both values if references.
.8f82	b5 50		lda $50,x			lda 	NSStatus,x 					; check if either is a string.
.8f84	15 51		ora $51,x			ora 	NSStatus+1,x
.8f86	29 10		and #$10			and 	#NSTString
.8f88	d0 37		bne $8fc1			bne 	_CBCString 					; if so do string code, which will check if both.
.8f8a	b5 78		lda $78,x			lda 	NSExponent,x 				; check both are integers
.8f8c	15 79		ora $79,x			ora 	NSExponent+1,x
.8f8e	d0 34		bne $8fc4			bne 	_CBCFloat
.8f90	b5 50		lda $50,x			lda 	NSStatus,x
.8f92	15 51		ora $51,x			ora 	NSStatus+1,x
.8f94	29 08		and #$08			and 	#NSTFloat
.8f96	d0 2c		bne $8fc4			bne 	_CBCFloat
.8f98	20 c7 8f	jsr $8fc7			jsr 	CompareFixMinusZero 		; fix up -0 just in cases.
.8f9b	e8		inx				inx
.8f9c	20 c7 8f	jsr $8fc7			jsr 	CompareFixMinusZero
.8f9f	ca		dex				dex
.8fa0	b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs different ?
.8fa2	55 51		eor $51,x			eor 	NSStatus+1,x
.8fa4	10 0a		bpl $8fb0			bpl 	_CDCSameSign
.8fa6	b5 50		lda $50,x			lda 	NSStatus,x 					; if first one is -ve
.8fa8	30 14		bmi $8fbe			bmi 	_CBCLess 					; return $FF
.8faa					_CBCGreater:
.8faa	a9 01		lda #$01			lda 	#1
.8fac	60		rts				rts
.8fad					_CBCEqual:
.8fad	a9 00		lda #$00			lda 	#0
.8faf	60		rts				rts
.8fb0					_CDCSameSign:
.8fb0	20 dc 91	jsr $91dc			jsr 	SubTopTwoStack 				; unsigned subtract
.8fb3	20 f7 9d	jsr $9df7			jsr 	NSMIsZero 					; or the mantissa together
.8fb6	f0 f5		beq $8fad			beq 	_CBCEqual 					; -0 == 0
.8fb8	b5 70		lda $70,x			lda 	NSMantissa3,x 				; sign of the result. if +ve return $01 else return $FF
.8fba	55 51		eor $51,x			eor 	NSStatus+1,x 				; however if both were -ve this is inverted
.8fbc	10 ec		bpl $8faa			bpl 	_CBCGreater
.8fbe					_CBCLess:
.8fbe	a9 ff		lda #$ff			lda 	#$FF
.8fc0	60		rts				rts
.8fc1					_CBCString:
.8fc1	4c 4d 91	jmp $914d			jmp 	CompareStrings
.8fc4					_CBCFloat:
.8fc4	4c 97 94	jmp $9497			jmp 	CompareFloat
.8fc7					CompareFixMinusZero:
.8fc7	20 f7 9d	jsr $9df7			jsr 	NSMIsZero
.8fca	d0 02		bne $8fce			bne 	_CFXMZNotZero
.8fcc	74 50		stz $50,x			stz 	NSStatus,x
.8fce					_CFXMZNotZero:
.8fce	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/concat.asm

.8fcf					StringConcat:
.8fcf	b5 50		lda $50,x			lda 	NSStatus,x 					; check both strings
.8fd1	35 51		and $51,x			and 	NSStatus+1,x
.8fd3	29 18		and #$18			and 	#NSBTypeMask
.8fd5	c9 10		cmp #$10			cmp 	#NSTString
.8fd7	d0 50		bne $9029			bne		_SCType
.8fd9	64 38		stz $38				stz 	zTemp1 						; counting total length
.8fdb	e8		inx				inx
.8fdc	20 fa 8f	jsr $8ffa			jsr 	_SCSetupZ0 					; setup for second
.8fdf	20 03 90	jsr $9003			jsr 	_SCLengthZ0 				; length for second
.8fe2	ca		dex				dex
.8fe3	20 fa 8f	jsr $8ffa			jsr 	_SCSetupZ0 					; setup for first
.8fe6	20 03 90	jsr $9003			jsr 	_SCLengthZ0 				; length for first
.8fe9	a5 38		lda $38				lda 	zTemp1 						; allocate memory using total.
.8feb	20 07 a7	jsr $a707			jsr 	StringTempAllocate
.8fee	20 1a 90	jsr $901a			jsr 	_SCCopy 					; copy first out, using zTemp0 from above
.8ff1	e8		inx				inx
.8ff2	20 fa 8f	jsr $8ffa			jsr 	_SCSetupZ0 					; copy second out
.8ff5	20 1a 90	jsr $901a			jsr 	_SCCopy
.8ff8	ca		dex				dex
.8ff9	60		rts				rts
.8ffa					_SCSetupZ0:
.8ffa	b5 58		lda $58,x			lda 	NSMantissa0,x
.8ffc	85 36		sta $36				sta 	zTemp0
.8ffe	b5 60		lda $60,x			lda 	NSMantissa1,x
.9000	85 37		sta $37				sta 	zTemp0+1
.9002	60		rts				rts
.9003					_SCLengthZ0:
.9003	5a		phy				phy
.9004	a0 00		ldy #$00			ldy 	#0
.9006					_SCLenLoop:
.9006	b1 36		lda ($36),y			lda 	(zTemp0),y
.9008	f0 0e		beq $9018			beq 	_SCLExit
.900a	c8		iny				iny
.900b	e6 38		inc $38				inc 	zTemp1
.900d	a5 38		lda $38				lda	 	zTemp1 						; check string too long.
.900f	c9 fd		cmp #$fd			cmp 	#253
.9011	d0 f3		bne $9006			bne		_SCLenLoop
.9013	a9 09		lda #$09		lda	#9
.9015	4c c8 8e	jmp $8ec8		jmp	ErrorHandler
.9018					_SCLExit:
.9018	7a		ply				ply
.9019	60		rts				rts
.901a					_SCCopy:
.901a	5a		phy				phy
.901b	a0 00		ldy #$00			ldy 	#0
.901d					_SCCopyLoop:
.901d	b1 36		lda ($36),y			lda 	(zTemp0),y
.901f	f0 06		beq $9027			beq 	_SCCExit
.9021	20 40 a7	jsr $a740			jsr 	StringTempWrite
.9024	c8		iny				iny
.9025	80 f6		bra $901d			bra 	_SCCopyLoop
.9027					_SCCExit:
.9027	7a		ply				ply
.9028	60		rts				rts
.9029					_SCType:
.9029	4c 5d 9f	jmp $9f5d			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/divide.asm

.902c					IntegerDivide:
.902c	fa		plx				plx
.902d	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.902f	15 51		ora $51,x			ora 	NSStatus+1,x
.9031	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9032	0a		asl a				asl 	a
.9033	10 05		bpl $903a			bpl 	_NotRef
.9035	48		pha				pha
.9036	20 8a 96	jsr $968a			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9039	68		pla				pla
.903a					_NotRef:
.903a	0a		asl a				asl 	a
.903b	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.903d	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.903f	15 79		ora $79,x			ora 	NSExponent+1,x
.9041	f0 03		beq $9046			beq 	_IntegerCode 				; if clear, then we have two integers
.9043	4c 5d 9f	jmp $9f5d			jmp 	TypeError 					; anything else, type mismatch.
.9046					_IntegerCode:
.9046	20 60 90	jsr $9060			jsr 	CheckDivideZero 			; do div zero check
.9049	20 92 90	jsr $9092			jsr 	Int32Divide 				; do the division
.904c	20 43 91	jsr $9143			jsr 	CalculateSign 				; calculate result sign
.904f					NSMCopyPlusTwoToZero:
.904f	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.9051	95 58		sta $58,x			sta 	NSMantissa0,x
.9053	b5 62		lda $62,x			lda 	NSMantissa1+2,x
.9055	95 60		sta $60,x			sta 	NSMantissa1,x
.9057	b5 6a		lda $6a,x			lda 	NSMantissa2+2,x
.9059	95 68		sta $68,x			sta 	NSMantissa2,x
.905b	b5 72		lda $72,x			lda 	NSMantissa3+2,x
.905d	95 70		sta $70,x			sta 	NSMantissa3,x
.905f	60		rts				rts
.9060					CheckDivideZero:
.9060	e8		inx				inx
.9061	20 f7 9d	jsr $9df7			jsr 	NSMIsZero
.9064	f0 02		beq $9068			beq 	_CDVError
.9066	ca		dex				dex
.9067	60		rts				rts
.9068					_CDVError:
.9068	a9 03		lda #$03		lda	#3
.906a	4c c8 8e	jmp $8ec8		jmp	ErrorHandler
.906d					IntegerModulus:
.906d	fa		plx				plx
.906e	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9070	15 51		ora $51,x			ora 	NSStatus+1,x
.9072	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9073	0a		asl a				asl 	a
.9074	10 05		bpl $907b			bpl 	_NotRef
.9076	48		pha				pha
.9077	20 8a 96	jsr $968a			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.907a	68		pla				pla
.907b					_NotRef:
.907b	0a		asl a				asl 	a
.907c	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.907e	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9080	15 79		ora $79,x			ora 	NSExponent+1,x
.9082	f0 03		beq $9087			beq 	_IntegerCode 				; if clear, then we have two integers
.9084	4c 5d 9f	jmp $9f5d			jmp 	TypeError 					; anything else, type mismatch.
.9087					_IntegerCode:
.9087					IntegerModulusNoCheck:
.9087	20 60 90	jsr $9060			jsr 	CheckDivideZero 			; do div zero check
.908a	20 92 90	jsr $9092			jsr 	Int32Divide 				; do the division
.908d	16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.908f	56 50		lsr $50,x			lsr 	NSStatus,x
.9091	60		rts				rts
.9092					Int32Divide:
.9092	48		pha				pha 								; save AXY
.9093	5a		phy				phy
.9094	20 b8 9d	jsr $9db8			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.9097	20 d1 9d	jsr $9dd1			jsr 	NSMSetZeroMantissaOnly 		; set S[X] to zero
.909a	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.909c					_I32DivideLoop:
.909c	e8		inx				inx
.909d	e8		inx				inx
.909e	20 e4 9d	jsr $9de4			jsr 	NSMShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.90a1	ca		dex				dex
.90a2	ca		dex				dex
.90a3	20 e5 9d	jsr $9de5			jsr 	NSMRotateLeft
.90a6	20 d1 90	jsr $90d1			jsr 	DivideCheckSubtract 		; check if subtract possible
.90a9	90 02		bcc $90ad			bcc 	_I32DivideNoCarryIn
.90ab	f6 5a		inc $5a,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.90ad					_I32DivideNoCarryIn:
.90ad	88		dey				dey 								; loop round till division completed.
.90ae	d0 ec		bne $909c			bne 	_I32DivideLoop
.90b0	7a		ply				ply 								; restore AXY and exit
.90b1	68		pla				pla
.90b2	60		rts				rts
.90b3					Int32ShiftDivide:
.90b3	48		pha				pha 								; save AY
.90b4	5a		phy				phy
.90b5	e8		inx				inx 								; clear S[X+2]
.90b6	e8		inx				inx
.90b7	20 d5 9d	jsr $9dd5			jsr 	NSMSetZero
.90ba	ca		dex				dex
.90bb	ca		dex				dex
.90bc	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.90be					_I32SDLoop:
.90be	20 d1 90	jsr $90d1			jsr 	DivideCheckSubtract 		; check if subtract possible
.90c1	e8		inx				inx
.90c2	e8		inx				inx
.90c3	20 e5 9d	jsr $9de5			jsr 	NSMRotateLeft				; shift 64 bit FPA left, rotating carry in
.90c6	ca		dex				dex
.90c7	ca		dex				dex
.90c8	20 e5 9d	jsr $9de5			jsr 	NSMRotateLeft
.90cb	88		dey				dey 	 							; do 31 times
.90cc	d0 f0		bne $90be			bne 	_I32SDLoop
.90ce	7a		ply				ply 								; restore AY and exit
.90cf	68		pla				pla
.90d0	60		rts				rts
.90d1					DivideCheckSubtract:
.90d1	20 dc 91	jsr $91dc			jsr 	SubTopTwoStack 				; subtract Stack[X+1] from Stack[X+0]
.90d4	b0 04		bcs $90da			bcs 	_DCSExit 					; if carry set, then could do, exit
.90d6	20 c2 91	jsr $91c2			jsr 	AddTopTwoStack 				; add it back in
.90d9	18		clc				clc 								; and return False
.90da					_DCSExit:
.90da	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/multiply.asm

.90db					MulInteger:
.90db	fa		plx				plx
.90dc	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.90de	15 51		ora $51,x			ora 	NSStatus+1,x
.90e0	0a		asl a				asl 	a 							; shift reference bit into sign bit
.90e1	0a		asl a				asl 	a
.90e2	10 05		bpl $90e9			bpl 	_NotRef
.90e4	48		pha				pha
.90e5	20 8a 96	jsr $968a			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.90e8	68		pla				pla
.90e9					_NotRef:
.90e9	0a		asl a				asl 	a 							; put MSB of type into A:7
.90ea	30 09		bmi $90f5			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.90ec	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.90ee	15 79		ora $79,x			ora 	NSExponent+1,x
.90f0	f0 06		beq $90f8			beq 	_IntegerCode 				; if clear, then we have two integers
.90f2	4c 59 95	jmp $9559			jmp 	FloatingPointMultiply 							; otherwise at least one float.
.90f5					_StringData:
.90f5	4c 67 9f	jmp $9f67			jmp 	NotDoneError							; at least one string - don't know both are strings.
.90f8					_IntegerCode:
.90f8	20 05 91	jsr $9105			jsr 	MultiplyShort
.90fb	c9 00		cmp #$00			cmp 	#0
.90fd	f0 05		beq $9104			beq 	_MIExit
.90ff	a9 04		lda #$04		lda	#4
.9101	4c c8 8e	jmp $8ec8		jmp	ErrorHandler
.9104					_MIExit:
.9104	60		rts				rts
.9105					MultiplyShort:
.9105	5a		phy				phy 								; save Y
.9106	20 b8 9d	jsr $9db8			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.9109	20 d1 9d	jsr $9dd1			jsr 	NSMSetZeroMantissaOnly 		; set mantissa S[X] to zero
.910c	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.910e					_I32MLoop:
.910e	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.9110	15 62		ora $62,x			ora 	NSMantissa1+2,x
.9112	15 6a		ora $6a,x			ora 	NSMantissa2+2,x
.9114	15 72		ora $72,x			ora 	NSMantissa3+2,x
.9116	f0 25		beq $913d			beq 	_I32MExit 					; exit if zero
.9118	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.911a	29 01		and #$01			and 	#1
.911c	f0 0d		beq $912b			beq 	_I32MNoAdd
.911e	20 c2 91	jsr $91c2			jsr 	AddTopTwoStack 				; if so add S[X+1] to S[X+0]
.9121	b5 70		lda $70,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.9123	10 06		bpl $912b			bpl 	_I32MNoAdd
.9125					_I32ShiftRight:
.9125	20 ee 9d	jsr $9dee			jsr 	NSMShiftRight 				; shift S[X] right
.9128	c8		iny				iny 								; increment shift count
.9129	80 09		bra $9134			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.912b					_I32MNoAdd:
.912b	34 71		bit $71,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.912d	70 f6		bvs $9125			bvs 	_I32ShiftRight 				; instead.
.912f	e8		inx				inx
.9130	20 e4 9d	jsr $9de4			jsr 	NSMShiftLeft 				; shift additive S[X+1] left
.9133	ca		dex				dex
.9134					_I32MShiftUpper:
.9134	e8		inx				inx 								; shift S[X+2] right
.9135	e8		inx				inx
.9136	20 ee 9d	jsr $9dee			jsr 	NSMShiftRight
.9139	ca		dex				dex
.913a	ca		dex				dex
.913b	80 d1		bra $910e			bra 	_I32MLoop 					; try again.
.913d					_I32MExit:
.913d	20 43 91	jsr $9143			jsr 	CalculateSign
.9140	98		tya				tya 								; shift in A
.9141	7a		ply				ply 								; restore Y and exit
.9142	60		rts				rts
.9143					CalculateSign:
.9143	b5 50		lda $50,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.9145	16 50		asl $50,x			asl 	NSStatus,x 					; shift result left
.9147	55 51		eor $51,x			eor 	NSStatus+1,x
.9149	0a		asl a				asl 	a 							; shift bit 7 into carry
.914a	76 50		ror $50,x			ror 	NSStatus,x 					; shift right into status byte.
.914c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/scompare.asm

.914d					CompareStrings:
.914d	b5 50		lda $50,x			lda 	NSStatus,x 					; check both are strings
.914f	35 51		and $51,x			and 	NSStatus+1,x
.9151	29 10		and #$10			and 	#NSBIsString
.9153	f0 28		beq $917d			beq 	_CSTypeError
.9155	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy string addresses to zTemp0/1
.9157	85 36		sta $36				sta 	zTemp0
.9159	b5 60		lda $60,x			lda 	NSMantissa1,x
.915b	85 37		sta $37				sta 	zTemp0+1
.915d	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.915f	85 38		sta $38				sta 	zTemp1
.9161	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9163	85 39		sta $39				sta 	zTemp1+1
.9165	5a		phy				phy 								; save Y so we can access strings
.9166	a0 ff		ldy #$ff			ldy 	#$FF 						; -1 for pre increment.
.9168					_CSLoop:
.9168	c8		iny				iny
.9169	b1 36		lda ($36),y			lda 	(zTemp0),y 					; check if they are the same
.916b	d1 38		cmp ($38),y			cmp 	(zTemp1),y
.916d	d0 06		bne $9175			bne 	_CSDifferent
.916f	c9 00		cmp #$00			cmp 	#0 							; reached end ?
.9171	d0 f5		bne $9168			bne 	_CSLoop 					; still comparing
.9173					_CSExit:
.9173	7a		ply				ply 								; reached end, return zero in A from EOS
.9174	60		rts				rts
.9175					_CSDifferent:
.9175	a9 ff		lda #$ff			lda 	#255 						; if < return $FF
.9177	90 fa		bcc $9173			bcc		_CSExit
.9179	a9 01		lda #$01			lda 	#1 							; otherwise return 1.
.917b	80 f6		bra $9173			bra 	_CSExit
.917d					_CSTypeError:
.917d	4c 5d 9f	jmp $9f5d			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/shifts.asm

.9180					ShiftLeft:
.9180	38		sec				sec 								; common code, carry determines which way.
.9181	80 01		bra $9184			bra 	ShiftMain
.9183					ShiftRight:
.9183	18		clc				clc
.9184					ShiftMain:
.9184	fa		plx				plx 								; restore X
.9185	08		php				php 								; save direction
.9186	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9188	15 51		ora $51,x			ora 	NSStatus+1,x
.918a	0a		asl a				asl 	a 							; shift reference bit into sign bit
.918b	0a		asl a				asl 	a
.918c	10 05		bpl $9193			bpl 	_NotRef
.918e	48		pha				pha
.918f	20 8a 96	jsr $968a			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9192	68		pla				pla
.9193					_NotRef:
.9193	0a		asl a				asl 	a
.9194	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9196	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9198	15 79		ora $79,x			ora 	NSExponent+1,x
.919a	f0 03		beq $919f			beq 	_IntegerCode 				; if clear, then we have two integers
.919c	4c 5d 9f	jmp $9f5d			jmp 	TypeError 					; anything else, type mismatch.
.919f					_IntegerCode:
.919f	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; check number < 32
.91a1	29 e0		and #$e0			and 	#$E0
.91a3	15 61		ora $61,x			ora 	NSMantissa1+1,x
.91a5	15 69		ora $69,x			ora 	NSMantissa2+1,x
.91a7	15 71		ora $71,x			ora 	NSMantissa3+1,x
.91a9	d0 12		bne $91bd			bne 	_SMExit0 					; if >= 32 it will always return zero.
.91ab					_SMLoop:
.91ab	d6 59		dec $59,x			dec 	NSMantissa0+1,x 			; predecrement, could do << 0
.91ad	30 11		bmi $91c0			bmi 	_SMExit 					; exit if done.
.91af	28		plp				plp 								; restore direction setting
.91b0	08		php				php
.91b1	90 05		bcc $91b8			bcc 	_SMRight
.91b3	20 e4 9d	jsr $9de4			jsr 	NSMShiftLeft 				; shift left if CS
.91b6	80 f3		bra $91ab			bra 	_SMLoop
.91b8					_SMRight:
.91b8	20 ee 9d	jsr $9dee			jsr 	NSMShiftRight 				; shift right if CC
.91bb	80 ee		bra $91ab			bra 	_SMLoop
.91bd					_SMExit0:
.91bd	20 d5 9d	jsr $9dd5			jsr 	NSMSetZero 					; return zero.
.91c0					_SMExit:
.91c0	28		plp				plp 								; throw direction
.91c1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/simple.asm

.91c2					AddTopTwoStack:
.91c2	18		clc				clc
.91c3	b5 58		lda $58,x			lda		NSMantissa0,x
.91c5	75 59		adc $59,x			adc 		NSMantissa0+1,x
.91c7	95 58		sta $58,x			sta 	NSMantissa0,x
.91c9	b5 60		lda $60,x			lda		NSMantissa1,x
.91cb	75 61		adc $61,x			adc 		NSMantissa1+1,x
.91cd	95 60		sta $60,x			sta 	NSMantissa1,x
.91cf	b5 68		lda $68,x			lda		NSMantissa2,x
.91d1	75 69		adc $69,x			adc 		NSMantissa2+1,x
.91d3	95 68		sta $68,x			sta 	NSMantissa2,x
.91d5	b5 70		lda $70,x			lda		NSMantissa3,x
.91d7	75 71		adc $71,x			adc 		NSMantissa3+1,x
.91d9	95 70		sta $70,x			sta 	NSMantissa3,x
.91db	60		rts				rts
.91dc					SubTopTwoStack:
.91dc	38		sec				sec
.91dd	b5 58		lda $58,x			lda		NSMantissa0,x
.91df	f5 59		sbc $59,x			sbc 		NSMantissa0+1,x
.91e1	95 58		sta $58,x			sta 	NSMantissa0,x
.91e3	b5 60		lda $60,x			lda		NSMantissa1,x
.91e5	f5 61		sbc $61,x			sbc 		NSMantissa1+1,x
.91e7	95 60		sta $60,x			sta 	NSMantissa1,x
.91e9	b5 68		lda $68,x			lda		NSMantissa2,x
.91eb	f5 69		sbc $69,x			sbc 		NSMantissa2+1,x
.91ed	95 68		sta $68,x			sta 	NSMantissa2,x
.91ef	b5 70		lda $70,x			lda		NSMantissa3,x
.91f1	f5 71		sbc $71,x			sbc 		NSMantissa3+1,x
.91f3	95 70		sta $70,x			sta 	NSMantissa3,x
.91f5	60		rts				rts
.91f6					AddInteger:
.91f6	fa		plx				plx
.91f7	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.91f9	15 51		ora $51,x			ora 	NSStatus+1,x
.91fb	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91fc	0a		asl a				asl 	a
.91fd	10 05		bpl $9204			bpl 	_NotRef
.91ff	48		pha				pha
.9200	20 8a 96	jsr $968a			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9203	68		pla				pla
.9204					_NotRef:
.9204	0a		asl a				asl 	a 							; put MSB of type into A:7
.9205	30 09		bmi $9210			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9207	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9209	15 79		ora $79,x			ora 	NSExponent+1,x
.920b	f0 06		beq $9213			beq 	_IntegerCode 				; if clear, then we have two integers
.920d	4c 09 94	jmp $9409			jmp 	FloatingPointAdd 							; otherwise at least one float.
.9210					_StringData:
.9210	4c cf 8f	jmp $8fcf			jmp 	StringConcat							; at least one string - don't know both are strings.
.9213					_IntegerCode:
.9213					AddCode:
.9213	b5 50		lda $50,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.9215	55 51		eor $51,x			eor 	NSStatus+1,x
.9217	10 a9		bpl $91c2			bpl 	AddTopTwoStack
.9219	20 dc 91	jsr $91dc			jsr 	SubTopTwoStack 				; do a physical subtraction
.921c	34 70		bit $70,x			bit 	NSMantissa3,x 				; result is +ve, okay
.921e	10 07		bpl $9227			bpl 	_AddExit
.9220	b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign is that of 2nd value
.9222	95 50		sta $50,x			sta 	NSStatus,x
.9224	20 9e 9d	jsr $9d9e			jsr 	NSMNegateMantissa 			; negate the mantissa and exit
.9227					_AddExit:
.9227	20 f7 9d	jsr $9df7			jsr 	NSMIsZero 					; check for -0
.922a	d0 02		bne $922e			bne 	_AddNonZero
.922c	74 50		stz $50,x			stz 	NSStatus,x
.922e					_AddNonZero:
.922e	60		rts				rts
.922f					SubInteger:
.922f	fa		plx				plx
.9230	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9232	15 51		ora $51,x			ora 	NSStatus+1,x
.9234	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9235	0a		asl a				asl 	a
.9236	10 05		bpl $923d			bpl 	_NotRef
.9238	48		pha				pha
.9239	20 8a 96	jsr $968a			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.923c	68		pla				pla
.923d					_NotRef:
.923d	0a		asl a				asl 	a 							; put MSB of type into A:7
.923e	30 09		bmi $9249			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9240	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9242	15 79		ora $79,x			ora 	NSExponent+1,x
.9244	f0 06		beq $924c			beq 	_IntegerCode 				; if clear, then we have two integers
.9246	4c 0e 94	jmp $940e			jmp 	FloatingPointSub 							; otherwise at least one float.
.9249					_StringData:
.9249	4c 67 9f	jmp $9f67			jmp 	NotDoneError							; at least one string - don't know both are strings.
.924c					_IntegerCode:
.924c	b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate the second value.
.924e	49 80		eor #$80			eor 	#$80
.9250	95 51		sta $51,x			sta 	NSStatus+1,x
.9252	80 bf		bra $9213			bra 	AddCode 					; and do the same code as add.
.9254					AndInteger:
.9254	fa		plx				plx
.9255	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9257	15 51		ora $51,x			ora 	NSStatus+1,x
.9259	0a		asl a				asl 	a 							; shift reference bit into sign bit
.925a	0a		asl a				asl 	a
.925b	10 05		bpl $9262			bpl 	_NotRef
.925d	48		pha				pha
.925e	20 8a 96	jsr $968a			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9261	68		pla				pla
.9262					_NotRef:
.9262	0a		asl a				asl 	a
.9263	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9265	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9267	15 79		ora $79,x			ora 	NSExponent+1,x
.9269	f0 03		beq $926e			beq 	_IntegerCode 				; if clear, then we have two integers
.926b	4c 5d 9f	jmp $9f5d			jmp 	TypeError 					; anything else, type mismatch.
.926e					_IntegerCode:
.926e	b5 58		lda $58,x			lda		NSMantissa0,x
.9270	35 59		and $59,x			and 		NSMantissa0+1,x
.9272	95 58		sta $58,x			sta 	NSMantissa0,x
.9274	b5 60		lda $60,x			lda		NSMantissa1,x
.9276	35 61		and $61,x			and 		NSMantissa1+1,x
.9278	95 60		sta $60,x			sta 	NSMantissa1,x
.927a	b5 68		lda $68,x			lda		NSMantissa2,x
.927c	35 69		and $69,x			and 		NSMantissa2+1,x
.927e	95 68		sta $68,x			sta 	NSMantissa2,x
.9280	b5 70		lda $70,x			lda		NSMantissa3,x
.9282	35 71		and $71,x			and 		NSMantissa3+1,x
.9284	95 70		sta $70,x			sta 	NSMantissa3,x
.9286	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.9288	60		rts				rts
.9289					OraInteger:
.9289	fa		plx				plx
.928a	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.928c	15 51		ora $51,x			ora 	NSStatus+1,x
.928e	0a		asl a				asl 	a 							; shift reference bit into sign bit
.928f	0a		asl a				asl 	a
.9290	10 05		bpl $9297			bpl 	_NotRef
.9292	48		pha				pha
.9293	20 8a 96	jsr $968a			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9296	68		pla				pla
.9297					_NotRef:
.9297	0a		asl a				asl 	a
.9298	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.929a	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.929c	15 79		ora $79,x			ora 	NSExponent+1,x
.929e	f0 03		beq $92a3			beq 	_IntegerCode 				; if clear, then we have two integers
.92a0	4c 5d 9f	jmp $9f5d			jmp 	TypeError 					; anything else, type mismatch.
.92a3					_IntegerCode:
.92a3	b5 58		lda $58,x			lda		NSMantissa0,x
.92a5	15 59		ora $59,x			ora 		NSMantissa0+1,x
.92a7	95 58		sta $58,x			sta 	NSMantissa0,x
.92a9	b5 60		lda $60,x			lda		NSMantissa1,x
.92ab	15 61		ora $61,x			ora 		NSMantissa1+1,x
.92ad	95 60		sta $60,x			sta 	NSMantissa1,x
.92af	b5 68		lda $68,x			lda		NSMantissa2,x
.92b1	15 69		ora $69,x			ora 		NSMantissa2+1,x
.92b3	95 68		sta $68,x			sta 	NSMantissa2,x
.92b5	b5 70		lda $70,x			lda		NSMantissa3,x
.92b7	15 71		ora $71,x			ora 		NSMantissa3+1,x
.92b9	95 70		sta $70,x			sta 	NSMantissa3,x
.92bb	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.92bd	60		rts				rts
.92be					EorInteger:
.92be	fa		plx				plx
.92bf	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.92c1	15 51		ora $51,x			ora 	NSStatus+1,x
.92c3	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92c4	0a		asl a				asl 	a
.92c5	10 05		bpl $92cc			bpl 	_NotRef
.92c7	48		pha				pha
.92c8	20 8a 96	jsr $968a			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92cb	68		pla				pla
.92cc					_NotRef:
.92cc	0a		asl a				asl 	a
.92cd	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.92cf	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92d1	15 79		ora $79,x			ora 	NSExponent+1,x
.92d3	f0 03		beq $92d8			beq 	_IntegerCode 				; if clear, then we have two integers
.92d5	4c 5d 9f	jmp $9f5d			jmp 	TypeError 					; anything else, type mismatch.
.92d8					_IntegerCode:
.92d8	b5 58		lda $58,x			lda		NSMantissa0,x
.92da	55 59		eor $59,x			eor 		NSMantissa0+1,x
.92dc	95 58		sta $58,x			sta 	NSMantissa0,x
.92de	b5 60		lda $60,x			lda		NSMantissa1,x
.92e0	55 61		eor $61,x			eor 		NSMantissa1+1,x
.92e2	95 60		sta $60,x			sta 	NSMantissa1,x
.92e4	b5 68		lda $68,x			lda		NSMantissa2,x
.92e6	55 69		eor $69,x			eor 		NSMantissa2+1,x
.92e8	95 68		sta $68,x			sta 	NSMantissa2,x
.92ea	b5 70		lda $70,x			lda		NSMantissa3,x
.92ec	55 71		eor $71,x			eor 		NSMantissa3+1,x
.92ee	95 70		sta $70,x			sta 	NSMantissa3,x
.92f0	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.92f2	60		rts				rts
.92f3					WordIndirect:
.92f3	fa		plx				plx
.92f4	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.92f6	15 51		ora $51,x			ora 	NSStatus+1,x
.92f8	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92f9	0a		asl a				asl 	a
.92fa	10 05		bpl $9301			bpl 	_NotRef
.92fc	48		pha				pha
.92fd	20 8a 96	jsr $968a			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9300	68		pla				pla
.9301					_NotRef:
.9301	0a		asl a				asl 	a
.9302	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9304	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9306	15 79		ora $79,x			ora 	NSExponent+1,x
.9308	f0 03		beq $930d			beq 	_IntegerCode 				; if clear, then we have two integers
.930a	4c 5d 9f	jmp $9f5d			jmp 	TypeError 					; anything else, type mismatch.
.930d					_IntegerCode:
.930d	20 13 92	jsr $9213			jsr 	AddCode 					; add the two values
.9310	a9 22		lda #$22			lda 	#NSBIsReference+2 			; make a 2 byte reference
.9312	95 50		sta $50,x			sta 	NSStatus,x
.9314	60		rts				rts
.9315					ByteIndirect:
.9315	fa		plx				plx
.9316	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9318	15 51		ora $51,x			ora 	NSStatus+1,x
.931a	0a		asl a				asl 	a 							; shift reference bit into sign bit
.931b	0a		asl a				asl 	a
.931c	10 05		bpl $9323			bpl 	_NotRef
.931e	48		pha				pha
.931f	20 8a 96	jsr $968a			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9322	68		pla				pla
.9323					_NotRef:
.9323	0a		asl a				asl 	a
.9324	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9326	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9328	15 79		ora $79,x			ora 	NSExponent+1,x
.932a	f0 03		beq $932f			beq 	_IntegerCode 				; if clear, then we have two integers
.932c	4c 5d 9f	jmp $9f5d			jmp 	TypeError 					; anything else, type mismatch.
.932f					_IntegerCode:
.932f	20 13 92	jsr $9213			jsr 	AddCode 					; add the two values
.9332	a9 21		lda #$21			lda 	#NSBIsReference+1 			; make a 1 byte reference
.9334	95 50		sta $50,x			sta 	NSStatus,x
.9336	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/tostring.asm

.9337					ConvertInt16:
.9337	85 58		sta $58				sta 	NSMantissa0 				; set up as 32 bit conversion
.9339	86 60		stx $60				stx 	NSMantissa1
.933b	64 68		stz $68				stz 	NSMantissa2
.933d	64 70		stz $70				stz 	NSMantissa3
.933f	64 50		stz $50				stz 	NSStatus 					; positive integer
.9341	a2 00		ldx #$00			ldx 	#0 							; stack level
.9343	a9 0a		lda #$0a			lda 	#10 						; base
.9345	80 00		bra $9347			bra 	ConvertInt32
.9347					ConvertInt32:
.9347	5a		phy				phy
.9348	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.934a	24 50		bit $50				bit 	NSStatus 					; output a - if not negative.
.934c	10 08		bpl $9356			bpl 	_CI32NotNeg
.934e	48		pha				pha
.934f	a9 2d		lda #$2d			lda 	#'-'
.9351	99 7b 05	sta $057b,y			sta 	NumberBuffer,y
.9354	c8		iny				iny
.9355	68		pla				pla
.9356					_CI32NotNeg:
.9356	20 64 93	jsr $9364			jsr 	_CI32DivideConvert 			; recursive conversion
.9359	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.935b	99 7b 05	sta $057b,y			sta 	NumberBuffer,y
.935e	7a		ply				ply
.935f	a2 05		ldx #$05			ldx 	#NumberBuffer >> 8
.9361	a9 7b		lda #$7b			lda 	#NumberBuffer & $FF
.9363	60		rts				rts
.9364					_CI32DivideConvert:
.9364	e8		inx				inx 								; write to next slot up
.9365	20 d7 9d	jsr $9dd7			jsr 	NSMSetByte
.9368	ca		dex				dex
.9369	20 92 90	jsr $9092			jsr 	Int32Divide 				; divide
.936c	b5 58		lda $58,x			lda 	NSMantissa0,x 				; save remainder
.936e	48		pha				pha
.936f	20 4f 90	jsr $904f			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.9372	20 f7 9d	jsr $9df7			jsr 	NSMIsZero 					; is it zero ?
.9375	f0 05		beq $937c			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.9377	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.9379	20 64 93	jsr $9364			jsr 	_CI32DivideConvert 			; and recusrively call.
.937c					_CI32NoRecurse:
.937c	68		pla				pla 								; remainder
.937d	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.937f	90 02		bcc $9383			bcc 	_CI32NotHex
.9381	69 26		adc #$26			adc 	#6+32
.9383					_CI32NotHex:
.9383	69 30		adc #$30			adc 	#48
.9385	99 7b 05	sta $057b,y			sta 	NumberBuffer,y 				; write out and exit
.9388	c8		iny				iny
.9389	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/expression.asm


;******  Processing file: ./common/expressions/../generated/precedence.dat

.938a					PrecedenceLevel:
>938a	04					.byte	 4	; $00 <<
>938b	02					.byte	 2	; $01 <=
>938c	02					.byte	 2	; $02 <>
>938d	00					.byte	 0	; $03 !!3
>938e	00					.byte	 0	; $04 ><
>938f	02					.byte	 2	; $05 >=
>9390	04					.byte	 4	; $06 >>
>9391	00					.byte	 0	; $07 !!7
>9392	00					.byte	 0	; $08 !!8
>9393	00					.byte	 0	; $09 !!9
>9394	00					.byte	 0	; $0a !!10
>9395	00					.byte	 0	; $0b !!11
>9396	00					.byte	 0	; $0c !!12
>9397	00					.byte	 0	; $0d !!13
>9398	00					.byte	 0	; $0e !!14
>9399	00					.byte	 0	; $0f !!15
>939a	00					.byte	 0	; $10 @
>939b	00					.byte	 0	; $11 !!17
>939c	00					.byte	 0	; $12 !!18
>939d	00					.byte	 0	; $13 [
>939e	04					.byte	 4	; $14 \
>939f	00					.byte	 0	; $15 ]
>93a0	01					.byte	 1	; $16 ^
>93a1	00					.byte	 0	; $17 _
>93a2	00					.byte	 0	; $18 `
>93a3	00					.byte	 0	; $19 !!25
>93a4	00					.byte	 0	; $1a !!26
>93a5	00					.byte	 0	; $1b {
>93a6	01					.byte	 1	; $1c |
>93a7	00					.byte	 0	; $1d }
>93a8	00					.byte	 0	; $1e ~
>93a9	00					.byte	 0	; $1f [7m<7F>[m
>93aa	00					.byte	 0	; $20
>93ab	05					.byte	 5	; $21 !
>93ac	00					.byte	 0	; $22 "
>93ad	00					.byte	 0	; $23 #
>93ae	05					.byte	 5	; $24 $
>93af	04					.byte	 4	; $25 %
>93b0	01					.byte	 1	; $26 &
>93b1	00					.byte	 0	; $27 '
>93b2	00					.byte	 0	; $28 (
>93b3	00					.byte	 0	; $29 )
>93b4	04					.byte	 4	; $2a *
>93b5	03					.byte	 3	; $2b +
>93b6	00					.byte	 0	; $2c ,
>93b7	03					.byte	 3	; $2d -
>93b8	00					.byte	 0	; $2e .
>93b9	04					.byte	 4	; $2f /
>93ba	00					.byte	 0	; $30 0
>93bb	00					.byte	 0	; $31 1
>93bc	00					.byte	 0	; $32 2
>93bd	00					.byte	 0	; $33 3
>93be	00					.byte	 0	; $34 4
>93bf	00					.byte	 0	; $35 5
>93c0	00					.byte	 0	; $36 6
>93c1	00					.byte	 0	; $37 7
>93c2	00					.byte	 0	; $38 8
>93c3	00					.byte	 0	; $39 9
>93c4	00					.byte	 0	; $3a :
>93c5	00					.byte	 0	; $3b ;
>93c6	02					.byte	 2	; $3c <
>93c7	02					.byte	 2	; $3d =
>93c8	02					.byte	 2	; $3e >
>93c9	05					.byte	 5	; $3f ?

;******  Return to file: ./common/expressions/expression.asm

.93ca					EvaluateExpressionAt0:
.93ca	a2 00		ldx #$00			ldx 	#0 							; bottom stack level
.93cc					EvaluateExpression:
.93cc	a9 00		lda #$00			lda 	#0 							; lowest precedence level
.93ce					EvaluateExpressionAtPrecedence:
.93ce	48		pha				pha 								; save precedence level
.93cf	20 16 98	jsr $9816			jsr 	EvaluateTerm 				; evaluate term into level X.
.93d2	68		pla				pla 								; restore precedence level.
.93d3					_EXPRLoop:
.93d3	85 36		sta $36				sta 	zTemp0 						; save current precedence level.
.93d5	b1 30		lda ($30),y			lda 	(codePtr),y
.93d7	c9 40		cmp #$40			cmp		#$40 						; if >= $40 cannot be an operator
.93d9	b0 25		bcs $9400			bcs 	_EXPRExit
.93db	da		phx				phx 								; read the operator precedence
.93dc	aa		tax				tax
.93dd	bd 8a 93	lda $938a,x			lda 	PrecedenceLevel,x
.93e0	fa		plx				plx
.93e1	c9 00		cmp #$00			cmp 	#0							; if zero exit (not an operator)
.93e3	f0 1b		beq $9400			beq 	_EXPRExit
.93e5	85 37		sta $37				sta 	zTemp0+1 					; save operator precedence level.
.93e7	a5 36		lda $36				lda 	zTemp0 						; compare current precedence vs. operator precedence
.93e9	c5 37		cmp $37				cmp 	zTemp0+1
.93eb	b0 13		bcs $9400			bcs		_EXPRExit 					; if current >= operator exit
.93ed	48		pha				pha 								; save current precedence.
.93ee	b1 30		lda ($30),y			lda 	(codePtr),y
.93f0	c8		iny				iny
.93f1	48		pha				pha
.93f2	a5 37		lda $37				lda 	zTemp0+1 					; get operator precedence level
.93f4	e8		inx				inx 								; work out the right hand side.
.93f5	20 ce 93	jsr $93ce			jsr 	EvaluateExpressionAtPrecedence
.93f8	ca		dex				dex
.93f9	68		pla				pla 								; get operator, call the code.
.93fa	20 03 94	jsr $9403			jsr 	_EXPRCaller
.93fd	68		pla				pla 								; restore precedence level
.93fe	80 d3		bra $93d3			bra 	_EXPRLoop 					; and go round.
.9400					_EXPRExit:
.9400	a5 36		lda $36				lda 	zTemp0 						; A = current precedence level.
.9402	60		rts				rts
.9403					_EXPRCaller:
.9403	da		phx				phx 								; save on stack, first thing is to restore it
.9404	0a		asl a				asl 	a 							; double so can use vectors into X
.9405	aa		tax				tax
.9406	7c 8a 8b	jmp ($8b8a,x)			jmp 	(VectorSetPunc,x) 			; and go to the code.

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/addsub.asm

.9409					FloatingPointAdd:
.9409	20 7f 95	jsr $957f			jsr 	FloatPrepare 				; prepare for floats
.940c	80 09		bra $9417			bra 	FloatAdd
.940e					FloatingPointSub:
.940e	20 7f 95	jsr $957f			jsr 	FloatPrepare 				; prepare for floats
.9411					FloatSubtract:
.9411	b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate FPB
.9413	49 80		eor #$80			eor 	#$80
.9415	95 51		sta $51,x			sta 	NSStatus+1,x				; and fall through.
.9417					FloatAdd:
.9417	48		pha				pha
.9418	5a		phy				phy
.9419	20 8e 95	jsr $958e			jsr 	NSNormalise 				; normalise S[X]
.941c	f0 51		beq $946f			beq 	_FAReturn1
.941e	e8		inx				inx 								; normalise S[X+1]
.941f	20 8e 95	jsr $958e			jsr 	NSNormalise
.9422	ca		dex				dex
.9423	c9 00		cmp #$00			cmp 	#0
.9425	f0 60		beq $9487			beq 	_FAExit 					; if so, just return A
.9427	b5 78		lda $78,x			lda 	NSExponent,x 				; are the exponents the same ?
.9429	d5 79		cmp $79,x			cmp 	NSExponent+1,x
.942b	f0 18		beq $9445			beq 	_FAExponentsEqual
.942d	b5 78		lda $78,x			lda 	NSExponent,x 				; work out the larger exponent
.942f	a8		tay				tay
.9430	38		sec				sec 								; do a signed comparison of the exponents.
.9431	f5 79		sbc $79,x			sbc 	NSExponent+1,x
.9433	50 02		bvc $9437			bvc 	_FANoSignedChange
.9435	49 80		eor #$80			eor 	#$80
.9437					_FANoSignedChange:
.9437	29 80		and #$80			and 	#$80
.9439	10 02		bpl $943d			bpl 	_FAHaveMax
.943b	b4 79		ldy $79,x			ldy 	NSExponent+1,x
.943d					_FAHaveMax:
.943d	20 8a 94	jsr $948a			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.9440	e8		inx				inx
.9441	20 8a 94	jsr $948a			jsr 	_FAShiftToExponent
.9444	ca		dex				dex
.9445					_FAExponentsEqual:
.9445	b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs the same
.9447	55 51		eor $51,x			eor 	NSStatus+1,x
.9449	30 0e		bmi $9459			bmi 	_FADifferentSigns
.944b	20 c2 91	jsr $91c2			jsr 	AddTopTwoStack 				; do the add of the mantissae
.944e	b5 70		lda $70,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.9450	10 35		bpl $9487			bpl 	_FAExit 					; if no, we are done.
.9452	20 ee 9d	jsr $9dee			jsr 	NSMShiftRight 				; shift A right, renormalising it.
.9455	f6 78		inc $78,x			inc 	NSExponent,x 				; bump the exponent and exit
.9457	80 2e		bra $9487			bra 	_FAExit
.9459					_FADifferentSigns:
.9459	20 dc 91	jsr $91dc			jsr 	SubTopTwoStack 				; subtract mantissa B from A
.945c	b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the result negative ?
.945e	10 06		bpl $9466			bpl 	_FACheckZero 				; if no, check for -0
.9460	20 97 9d	jsr $9d97			jsr 	NSMNegate 					; netate result
.9463	20 9e 9d	jsr $9d9e			jsr 	NSMNegateMantissa 			; negate (2'c) the mantissa
.9466					_FACheckZero:
.9466	20 f7 9d	jsr $9df7			jsr 	NSMIsZero	 				; check for -0
.9469	d0 1c		bne $9487			bne 	_FAExit
.946b	74 50		stz $50,x			stz 	NSStatus,x
.946d	80 18		bra $9487			bra 	_FAExit
.946f					_FAReturn1:
.946f	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9471	95 58		sta $58,x			sta 	NSMantissa0,x
.9473	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9475	95 60		sta $60,x			sta 	NSMantissa1,x
.9477	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.9479	95 68		sta $68,x			sta 	NSMantissa2,x
.947b	b5 71		lda $71,x			lda 	NSMantissa3+1,x
.947d	95 70		sta $70,x			sta 	NSMantissa3,x
.947f	b5 79		lda $79,x			lda 	NSExponent+1,x
.9481	95 78		sta $78,x			sta 	NSExponent,x
.9483	b5 51		lda $51,x			lda 	NSStatus+1,x
.9485	95 50		sta $50,x			sta 	NSStatus,x
.9487					_FAExit:
.9487	7a		ply				ply
.9488	68		pla				pla
.9489	60		rts				rts
.948a					_FAShiftToExponent:
.948a					_FAShiftToExponent2:
.948a	98		tya				tya 								; compare Y to exponent
.948b	d5 78		cmp $78,x			cmp 	NSExponent,x 				; reached the exponent required ?
.948d	f0 07		beq $9496			beq 	_FASEExit 					; exit if so.
.948f	20 ee 9d	jsr $9dee			jsr 	NSMShiftRight	 			; shift the mantissa right
.9492	f6 78		inc $78,x			inc 	NSExponent,x 				; increment exponent
.9494	80 f4		bra $948a			bra 	_FAShiftToExponent2
.9496					_FASEExit:
.9496	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/compare.asm

.9497					CompareFloat:
.9497	20 11 94	jsr $9411			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.949a	b5 60		lda $60,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.949c	29 f8		and #$f8			and 	#$F8
.949e	15 68		ora $68,x			ora 	NSMantissa2,x
.94a0	15 70		ora $70,x			ora 	NSMantissa3,x
.94a2	f0 08		beq $94ac			beq 	_FCExit 					; zero, so approximately identical
.94a4	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.94a6	34 50		bit $50,x			bit 	NSStatus,x
.94a8	10 02		bpl $94ac			bpl 	_FCExit
.94aa					_FCNegative:
.94aa	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.94ac					_FCExit:
.94ac	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/divide.asm

.94ad					FDivideCommand:
.94ad	fa		plx				plx	 								; restore stack position
.94ae	20 7f 95	jsr $957f			jsr 	FloatPrepare 				; prepare for floats
.94b1					FloatDivide:
.94b1	48		pha				pha
.94b2	e8		inx				inx
.94b3	20 8e 95	jsr $958e			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.94b6	ca		dex				dex
.94b7	c9 00		cmp #$00			cmp 	#0
.94b9	f0 1d		beq $94d8			beq 	_FDZero
.94bb	20 8e 95	jsr $958e			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.94be	f0 16		beq $94d6			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.94c0	20 b3 90	jsr $90b3			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.94c3	20 4f 90	jsr $904f			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.94c6	20 8e 95	jsr $958e			jsr		NSNormalise 				; renormalise
.94c9	20 43 91	jsr $9143			jsr 	CalculateSign 				; calculate result sign
.94cc	b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent
.94ce	38		sec				sec
.94cf	f5 79		sbc $79,x			sbc 	NSExponent+1,x
.94d1	38		sec				sec
.94d2	e9 1e		sbc #$1e			sbc 	#30
.94d4	95 78		sta $78,x			sta 	NSExponent,x
.94d6					_FDExit:
.94d6	68		pla				pla
.94d7	60		rts				rts
.94d8					_FDZero:
.94d8	a9 03		lda #$03		lda	#3
.94da	4c c8 8e	jmp $8ec8		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/fractional.asm

.94dd					FloatFractionalPart:
.94dd	5a		phy				phy
.94de	b5 50		lda $50,x			lda 	NSStatus,x 					; take absolute value
.94e0	29 7f		and #$7f			and 	#$7F
.94e2	95 50		sta $50,x			sta 	NSStatus,x
.94e4	20 8e 95	jsr $958e			jsr 	NSNormalise
.94e7	b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.94e9	38		sec				sec
.94ea	e9 e0		sbc #$e0			sbc 	#$E0
.94ec	90 29		bcc $9517			bcc 	_FFPExit 					; already fractional
.94ee	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.94f0	b0 22		bcs $9514			bcs 	_FFPZero
.94f2	a8		tay				tay 								; put count to do in Y
.94f3	b5 70		lda $70,x			lda 	NSMantissa3,x 				; do each in turn.
.94f5	20 19 95	jsr $9519			jsr 	_FFPPartial
.94f8	95 70		sta $70,x			sta 	NSMantissa3,x
.94fa	b5 68		lda $68,x			lda 	NSMantissa2,x
.94fc	20 19 95	jsr $9519			jsr 	_FFPPartial
.94ff	95 68		sta $68,x			sta 	NSMantissa2,x
.9501	b5 60		lda $60,x			lda 	NSMantissa1,x
.9503	20 19 95	jsr $9519			jsr 	_FFPPartial
.9506	95 60		sta $60,x			sta 	NSMantissa1,x
.9508	b5 58		lda $58,x			lda 	NSMantissa0,x
.950a	20 19 95	jsr $9519			jsr 	_FFPPartial
.950d	95 58		sta $58,x			sta 	NSMantissa0,x
.950f	20 f7 9d	jsr $9df7			jsr 	NSMIsZero 					; zeroed check.
.9512	d0 03		bne $9517			bne 	_FFPExit
.9514					_FFPZero:
.9514	20 d5 9d	jsr $9dd5			jsr 	NSMSetZero
.9517					_FFPExit:
.9517	7a		ply				ply
.9518	60		rts				rts
.9519					_FFPPartial:
.9519	c0 00		cpy #$00			cpy 	#0 							; no more to do
.951b	f0 17		beq $9534			beq 	_FFFPPExit
.951d	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.951f	b0 0c		bcs $952d			bcs 	_FFFPPWholeByte
.9521	5a		phy				phy
.9522					_FFFPPLeft:
.9522	0a		asl a				asl 	a
.9523	88		dey				dey
.9524	d0 fc		bne $9522			bne 	_FFFPPLeft
.9526	7a		ply				ply
.9527					_FFFPPRight:
.9527	4a		lsr a				lsr 	a
.9528	88		dey				dey
.9529	d0 fc		bne $9527			bne 	_FFFPPRight
.952b	80 07		bra $9534			bra 	_FFFPPExit
.952d					_FFFPPWholeByte:
.952d	98		tya				tya 								; subtract 8 from count
.952e	38		sec				sec
.952f	e9 08		sbc #$08			sbc 	#8
.9531	a8		tay				tay
.9532	a9 00		lda #$00			lda 	#0 							; and clear all
.9534					_FFFPPExit:
.9534	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/integer.asm

.9535					FloatIntegerPart:
.9535	48		pha				pha
.9536	b5 78		lda $78,x			lda 	NSExponent,x 				; is it integer already ?
.9538	f0 1d		beq $9557			beq 	_FIPExit 					; if so do nothing
.953a	20 f7 9d	jsr $9df7			jsr 	NSMIsZero 					; is it zero ?
.953d	f0 15		beq $9554			beq 	_FIPZero 					; if so return zero.
.953f	20 8e 95	jsr $958e			jsr 	NSNormalise 				; normalise
.9542	f0 10		beq $9554			beq 	_FIPZero 					; normalised to zero, exit zero
.9544					_FIPShift:
.9544	b5 78		lda $78,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.9546	10 07		bpl $954f			bpl 	_FIPCheckZero
.9548	20 ee 9d	jsr $9dee			jsr 	NSMShiftRight 				; shift mantissa right
.954b	f6 78		inc $78,x			inc 	NSExponent,x 				; bump exponent
.954d	80 f5		bra $9544			bra 	_FIPShift
.954f					_FIPCheckZero:
.954f	20 f7 9d	jsr $9df7			jsr 	NSMIsZero 					; avoid -0 problem
.9552	d0 03		bne $9557			bne 	_FIPExit 					; set to zero if mantissa zero.
.9554					_FIPZero:
.9554	20 d5 9d	jsr $9dd5			jsr 	NSMSetZero
.9557					_FIPExit:
.9557	68		pla				pla
.9558	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/multiply.asm

.9559					FloatingPointMultiply:
.9559	20 7f 95	jsr $957f			jsr 	FloatPrepare 				; prepare for floats
.955c					FloatMultiply:
.955c	48		pha				pha
.955d	20 8e 95	jsr $958e			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.9560	f0 18		beq $957a			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.9562	e8		inx				inx
.9563	20 8e 95	jsr $958e			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.9566	ca		dex				dex
.9567	c9 00		cmp #$00			cmp 	#0
.9569	f0 0c		beq $9577			beq 	_FDSetZero
.956b	20 05 91	jsr $9105			jsr 	MultiplyShort 				; calculate the result.
.956e	75 78		adc $78,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.9570	18		clc				clc
.9571	75 79		adc $79,x			adc 	NSExponent+1,x
.9573	95 78		sta $78,x			sta 	NSExponent,x
.9575	80 03		bra $957a			bra 	_FDExit
.9577					_FDSetZero:
.9577	20 d5 9d	jsr $9dd5			jsr 	NSMSetZero 					; return 0
.957a					_FDExit:
.957a	20 8e 95	jsr $958e			jsr 	NSNormalise 				; normalise the result
.957d	68		pla				pla
.957e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/utility.asm

.957f					FloatPrepare:
.957f	20 8a 96	jsr $968a			jsr 	DereferenceTopTwo 			; dereference the top two values
.9582	b5 50		lda $50,x			lda 	NSStatus,x 					; check ints/floats
.9584	15 51		ora $51,x			ora 	NSStatus+1,x
.9586	29 10		and #$10			and 	#NSBIsString
.9588	d0 01		bne $958b			bne 	_FDType
.958a	60		rts				rts
.958b					_FDType:
.958b	4c 5d 9f	jmp $9f5d			jmp 	TypeError
.958e					NSNormalise:
.958e	b5 50		lda $50,x			lda 	NSStatus,x 					; make float, keep sign
.9590	29 80		and #$80			and 	#$80
.9592	09 08		ora #$08			ora 	#NSTFloat
.9594	95 50		sta $50,x			sta 	NSStatus,x
.9596	20 f7 9d	jsr $9df7			jsr 	NSMIsZero 					; if zero exit
.9599	d0 07		bne $95a2			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.959b	16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.959d	76 50		ror $50,x			ror 	NSStatus,x 					; (no -0)
.959f	a9 00		lda #$00			lda 	#0 							; set Z flag
.95a1	60		rts				rts
.95a2					_NSNormaliseOptimise:
.95a2	b5 70		lda $70,x			lda 	NSMantissa3,x 				; upper byte zero ?
.95a4	d0 19		bne $95bf			bne 	_NSNormaliseLoop
.95a6	b5 68		lda $68,x			lda 	NSMantissa2,x 				; byte normalise
.95a8	30 15		bmi $95bf			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.95aa	95 70		sta $70,x			sta 	NSMantissa3,x
.95ac	b5 60		lda $60,x			lda 	NSMantissa1,x
.95ae	95 68		sta $68,x			sta 	NSMantissa2,x
.95b0	b5 58		lda $58,x			lda 	NSMantissa0,x
.95b2	95 60		sta $60,x			sta 	NSMantissa1,x
.95b4	74 58		stz $58,x			stz 	NSMantissa0,x
.95b6	b5 78		lda $78,x			lda 	NSExponent,x
.95b8	38		sec				sec
.95b9	e9 08		sbc #$08			sbc 	#8
.95bb	95 78		sta $78,x			sta 	NSExponent,x
.95bd	80 e3		bra $95a2			bra 	_NSNormaliseOptimise
.95bf					_NSNormaliseLoop:
.95bf	34 70		bit $70,x			bit 	NSMantissa3,x 				; bit 30 set ?
.95c1	70 07		bvs $95ca			bvs 	_NSNExit 					; exit if so with Z flag clear
.95c3	20 e4 9d	jsr $9de4			jsr 	NSMShiftLeft 				; shift mantissa left
.95c6	d6 78		dec $78,x			dec 	NSExponent,x 				; adjust exponent
.95c8	80 f5		bra $95bf			bra 	_NSNormaliseLoop
.95ca					_NSNExit:
.95ca	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.95cc	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignnumber.asm

.95cd					AssignNumber:
.95cd	5a		phy				phy
.95ce	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy mantissa0/1 to zTemp0
.95d0	85 36		sta $36				sta 	zTemp0
.95d2	b5 60		lda $60,x			lda 	NSMantissa1,x
.95d4	85 37		sta $37				sta 	zTemp0+1
.95d6	b5 50		lda $50,x			lda 	NSStatus,x 					; clear reference bits
.95d8	29 df		and #$df			and 	#(NSBIsReference ^ $FF)
.95da	95 50		sta $50,x			sta 	NSStatus,x
.95dc	29 18		and #$18			and 	#NSBTypeMask				; assigning to a float ?
.95de	c9 08		cmp #$08			cmp 	#NSTFloat
.95e0	f0 24		beq $9606			beq 	_ANFloat
.95e2	b5 79		lda $79,x			lda		NSExponent+1,x 				; is it a float
.95e4	f0 03		beq $95e9			beq		_ANNotFloat
.95e6	4c 58 9f	jmp $9f58			jmp 	RangeError
.95e9					_ANNotFloat:
.95e9	b5 50		lda $50,x			lda 	NSStatus,x 					; check if byte/word reference.
.95eb	29 03		and #$03			and 	#3
.95ed	d0 05		bne $95f4			bne 	_ANByteWord
.95ef	20 11 96	jsr $9611			jsr 	_ANCopy4PackSign 			; copy all 4 bytes and sign
.95f2	80 1b		bra $960f			bra 	_ANExit
.95f4					_ANByteWord:
.95f4	48		pha				pha 								; save count
.95f5	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; do byte
.95f7	92 36		sta ($36)			sta 	(zTemp0)
.95f9	68		pla				pla
.95fa	c9 01		cmp #$01			cmp	 	#1
.95fc	f0 11		beq $960f			beq 	_ANExit
.95fe	b5 61		lda $61,x			lda 	NSMantissa1+1,x 			; do word
.9600	a0 01		ldy #$01			ldy 	#1
.9602	91 36		sta ($36),y			sta 	(zTemp0),y
.9604	80 09		bra $960f			bra 	_ANExit
.9606					_ANFloat:
.9606	20 11 96	jsr $9611			jsr 	_ANCopy4PackSign 			; write all 4 bytes and packed sign
.9609	b5 79		lda $79,x			lda 	NSExponent+1,x 				; copy exponent to slot 4
.960b	a0 04		ldy #$04			ldy 	#4
.960d	91 36		sta ($36),y			sta 	(zTemp0),y
.960f					_ANExit:
.960f	7a		ply				ply
.9610	60		rts				rts
.9611					_ANCopy4PackSign:
.9611	a0 03		ldy #$03			ldy 	#3
.9613	b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign bit into status
.9615	29 80		and #$80			and 	#$80 						; put into high bit of mantissa 3
.9617	15 71		ora $71,x			ora 	NSMantissa3+1,x
.9619	91 36		sta ($36),y			sta 	(zTemp0),y
.961b	88		dey				dey
.961c	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.961e	91 36		sta ($36),y			sta 	(zTemp0),y
.9620	88		dey				dey
.9621	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9623	91 36		sta ($36),y			sta 	(zTemp0),y
.9625	88		dey				dey
.9626	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9628	91 36		sta ($36),y			sta 	(zTemp0),y
.962a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignstring.asm

.962b					AssignString:
.962b	5a		phy				phy
.962c	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.962e	85 38		sta $38				sta 	zTemp1
.9630	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9632	85 39		sta $39				sta 	zTemp1+1
.9634	b5 58		lda $58,x			lda 	NSMantissa0,x
.9636	85 36		sta $36				sta 	zTemp0
.9638	b5 60		lda $60,x			lda 	NSMantissa1,x
.963a	85 37		sta $37				sta 	zTemp0+1
.963c	a0 01		ldy #$01			ldy 	#1 							; the high byte of the target address
.963e	b1 36		lda ($36),y			lda 	(zTemp0),y
.9640	f0 23		beq $9665			beq 	_ASNewStringRequired 		; if zero, a new string is required.
.9642	38		sec				sec 								; put Address-2 in zsTemp - this is the size/status/string record
.9643	b2 36		lda ($36)			lda 	(zTemp0) 					; of concreted strings
.9645	e9 02		sbc #$02			sbc 	#2
.9647	85 3c		sta $3c				sta 	zsTemp
.9649	a0 01		ldy #$01			ldy 	#1
.964b	b1 36		lda ($36),y			lda 	(zTemp0),y
.964d	e9 00		sbc #$00			sbc 	#0
.964f	85 3d		sta $3d				sta 	zsTemp+1
.9651	a0 ff		ldy #$ff			ldy 	#$FF 						; get length of new string
.9653					_ASGetLength:
.9653	c8		iny				iny
.9654	b1 38		lda ($38),y			lda 	(zTemp1),y
.9656	d0 fb		bne $9653			bne 	_ASGetLength
.9658	98		tya				tya 								; is this length <= current length
.9659	d2 3c		cmp ($3c)			cmp 	(zsTemp)
.965b	90 1e		bcc $967b			bcc 	_ASCopyString
.965d	f0 1c		beq $967b			beq 	_ASCopyString
.965f	a9 80		lda #$80			lda 	#$80 						; mark as unused.
.9661	a0 01		ldy #$01			ldy 	#1
.9663	91 3c		sta ($3c),y			sta 	(zsTemp),y
.9665					_ASNewStringRequired:
.9665	e8		inx				inx 								; concrete the new string.
.9666	20 8a a6	jsr $a68a			jsr 	StringConcrete				; (breaks zTemp1/2, not zTemp0 and zsTemp)
.9669	ca		dex				dex
.966a	18		clc				clc
.966b	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy that new address to the reference.
.966d	69 02		adc #$02			adc 	#2 							; add two to point at the data.
.966f	92 36		sta ($36)			sta 	(zTemp0)
.9671	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9673	69 00		adc #$00			adc 	#0
.9675	a0 01		ldy #$01			ldy 	#1
.9677	91 36		sta ($36),y			sta 	(zTemp0),y
.9679	80 0d		bra $9688			bra 	_ASExit
.967b					_ASCopyString:
.967b	a0 00		ldy #$00			ldy 	#0
.967d					_ASCopyLoop:
.967d	b1 38		lda ($38),y			lda 	(zTemp1),y
.967f	c8		iny				iny
.9680	c8		iny				iny
.9681	91 3c		sta ($3c),y			sta 	(zsTemp),y
.9683	88		dey				dey
.9684	c9 00		cmp #$00			cmp 	#0
.9686	d0 f5		bne $967d			bne 	_ASCopyLoop
.9688					_ASExit:
.9688	7a		ply				ply
.9689	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/dereference.asm

.968a					DereferenceTopTwo:
.968a	e8		inx				inx
.968b	20 8f 96	jsr $968f			jsr 	Dereference 				; deref x+1
.968e	ca		dex				dex  								; falls through to deref x
.968f					Dereference:
.968f	b5 50		lda $50,x			lda 	NSStatus,x 					; get the status byte
.9691	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.9693	f0 48		beq $96dd			beq 	_DRFExit 					; not a reference, so exit.
.9695	5a		phy				phy
.9696	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address to dereference into zTemp0
.9698	85 36		sta $36				sta 	zTemp0
.969a	b5 60		lda $60,x			lda 	NSMantissa1,x
.969c	85 37		sta $37				sta 	zTemp0+1
.969e	74 60		stz $60,x			stz 	NSMantissa1,x 				; clear second byte.
.96a0	b2 36		lda ($36)			lda 	(zTemp0) 					; do the first byte
.96a2	95 58		sta $58,x			sta 	NSMantissa0,x
.96a4	b5 50		lda $50,x			lda 	NSStatus,x 					; get status byte.
.96a6	29 18		and #$18			and 	#NSBTypeMask 				; what type is it ?
.96a8	c9 10		cmp #$10			cmp 	#NSTString 					; if string, dereference two
.96aa	f0 0e		beq $96ba			beq 	_DRFDereferenceTwo
.96ac	c9 08		cmp #$08			cmp 	#NSTFloat 					; if float, do full dereference.
.96ae	f0 2f		beq $96df			beq 	_DRFFull
.96b0	b5 50		lda $50,x			lda 	NSStatus,x 					; must be integer - how many bytes ?
.96b2	29 03		and #$03			and 	#3
.96b4	f0 29		beq $96df			beq 	_DRFFull 					; the whole word
.96b6	c9 01		cmp #$01			cmp 	#1 							; is it 10 (e.g. 2 bytes)
.96b8	f0 06		beq $96c0			beq		_DRFClear23 				; no, one byte, clear 2 & 3 and exit
.96ba					_DRFDereferenceTwo:
.96ba	a0 01		ldy #$01			ldy 	#1
.96bc	b1 36		lda ($36),y			lda 	(zTemp0),y
.96be	95 60		sta $60,x			sta 	NSMantissa1,x
.96c0					_DRFClear23:
.96c0	74 68		stz $68,x			stz 	NSMantissa2,x 				; clear upper bytes, only read 1 or 2 bytes
.96c2	74 70		stz $70,x			stz 	NSMantissa3,x
.96c4	b5 50		lda $50,x			lda 	NSStatus,x 					; make it a value of that type.
.96c6	29 18		and #$18			and 	#NSBTypeMask
.96c8	95 50		sta $50,x			sta 	NSStatus,x 					; and fall through.
.96ca	c9 10		cmp #$10			cmp 	#NSTString  				; is it a string
.96cc	d0 0e		bne $96dc			bne 	_DRFNotString
.96ce	b5 58		lda $58,x			lda 	NSMantissa0,x 				; check address is zero
.96d0	15 60		ora $60,x			ora 	NSMantissa1,x
.96d2	d0 08		bne $96dc			bne 	_DRFNotString
.96d4	a9 de		lda #$de			lda 	#_DRFNullString & $FF 		; if so, return reference to ""
.96d6	95 58		sta $58,x			sta 	NSMantissa0,X
.96d8	a9 96		lda #$96			lda 	#_DRFNullString >> 8
.96da	95 60		sta $60,x			sta 	NSMantissa1,X
.96dc					_DRFNotString
.96dc	7a		ply				ply 								; restore Y and exit
.96dd					_DRFExit:
.96dd	60		rts				rts
.96de					_DRFNullString:
>96de	00						.byte 	0
.96df					_DRFFull:
.96df	a0 01		ldy #$01			ldy 	#1 							; get remaining 3 bytes.
.96e1	b1 36		lda ($36),y			lda 	(zTemp0),y
.96e3	95 60		sta $60,x			sta 	NSMantissa1,x
.96e5	c8		iny				iny
.96e6	b1 36		lda ($36),y			lda 	(zTemp0),y
.96e8	95 68		sta $68,x			sta 	NSMantissa2,x
.96ea	c8		iny				iny
.96eb	b1 36		lda ($36),y			lda 	(zTemp0),y
.96ed	95 70		sta $70,x			sta 	NSMantissa3,x
.96ef	74 78		stz $78,x			stz 	NSExponent,x 				; clear exponent.
.96f1	b5 50		lda $50,x			lda		NSStatus,x 					; see if type is integer
.96f3	29 18		and #$18			and 	#NSBTypeMask  				; type information only
.96f5	95 50		sta $50,x			sta 	NSStatus,x 					; update it back.
.96f7	f0 05		beq $96fe			beq 	_DRFNoExponent
.96f9	c8		iny				iny 								; if not, read the exponent as well.
.96fa	b1 36		lda ($36),y			lda 	(zTemp0),y
.96fc	95 78		sta $78,x			sta 	NSExponent,x
.96fe					_DRFNoExponent:
.96fe	b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the most significant bit set ?
.9700	10 0a		bpl $970c			bpl 	_DRFExit2 					; if not, then exit.
.9702	29 7f		and #$7f			and 	#$7F 						; clear that bit.
.9704	95 70		sta $70,x			sta 	NSMantissa3,x
.9706	b5 50		lda $50,x			lda 	NSStatus,x 					; set the sign flag
.9708	09 80		ora #$80			ora 	#NSBIsNegative
.970a	95 50		sta $50,x			sta 	NSStatus,x
.970c					_DRFExit2:
.970c	7a		ply				ply
.970d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/number.asm

=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.970e					EncodeNumberStart:
.970e	38		sec				sec
.970f	80 01		bra $9712			bra 	EncodeNumberContinue+1
.9711					EncodeNumberContinue:
.9711	18		clc				clc
.9712					EncodeNumber:
.9712	08		php				php 								; save reset flag.
.9713	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.9715	f0 12		beq $9729			beq 	_ENIsOkay
.9717	c9 30		cmp #$30			cmp 	#"0"
.9719	90 04		bcc $971f			bcc 	_ENBadNumber
.971b	c9 3a		cmp #$3a			cmp 	#"9"+1
.971d	90 0a		bcc $9729			bcc 	_ENIsOkay
.971f					_ENBadNumber:
.971f	28		plp				plp 								; throw saved reset
.9720	ad 05 04	lda $0405			lda 	EncodeState 				; if in decimal mode, construct final number
.9723	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.9725	f0 7b		beq $97a2			beq 	_ENConstructFinal
.9727					_ENFail:
.9727	18		clc				clc 								; not allowed
.9728	60		rts				rts
.9729					_ENIsOkay:
.9729	28		plp				plp 								; are we restarting
.972a	90 15		bcc $9741			bcc 	_ENNoRestart
.972c					_ENStartEncode:
.972c	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.972e	f0 0c		beq $973c			beq 	_ENFirstDP
.9730	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.9732	20 d7 9d	jsr $9dd7			jsr 	NSMSetByte 					; in single byte mode.
.9735	a9 01		lda #$01			lda 	#ESTA_Low
.9737					_ENExitChange:
.9737	8d 05 04	sta $0405			sta 	EncodeState 				; save new state
.973a	38		sec				sec
.973b	60		rts				rts
.973c					_ENFirstDP:
.973c	20 d5 9d	jsr $9dd5			jsr 	NSMSetZero 					; clear integer part
.973f	80 3c		bra $977d			bra 	_ESTASwitchFloat			; go straight to float and exi
.9741					_ENNoRestart:
.9741	48		pha				pha 								; save digit or DP on stack.
.9742	ad 05 04	lda $0405			lda 	EncodeState 				; get current state
.9745	c9 01		cmp #$01			cmp 	#ESTA_Low
.9747	f0 09		beq $9752			beq  	_ESTALowState
.9749	c9 02		cmp #$02			cmp 	#ESTA_High
.974b	f0 26		beq $9773			beq 	_ESTAHighState
.974d	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.974f	f0 38		beq $9789			beq 	_ESTADecimalState
>9751	db						.byte 	$DB 						; causes a break in the emulator
.9752					_ESTALowState:
.9752	68		pla				pla 								; get value back
.9753	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.9755	f0 26		beq $977d			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.9757	29 0f		and #$0f			and 	#15 						; make digit
.9759	8d 06 04	sta $0406			sta 	DigitTemp 					; save it.
.975c	b5 58		lda $58,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.975e	0a		asl a				asl 	a
.975f	0a		asl a				asl 	a
.9760	75 58		adc $58,x			adc 	NSMantissa0,x
.9762	0a		asl a				asl 	a
.9763	6d 06 04	adc $0406			adc 	DigitTemp
.9766	95 58		sta $58,x			sta 	NSMantissa0,x
.9768	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.976a	90 05		bcc $9771			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.976c	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.976e	8d 05 04	sta $0405			sta 	EncodeState
.9771					_ESTANoSwitch:
.9771	38		sec				sec
.9772	60		rts				rts
.9773					_ESTAHighState:
.9773	68		pla				pla 								; get value back
.9774	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.9776	f0 05		beq $977d			beq 	_ESTASwitchFloat
.9778	20 d6 97	jsr $97d6			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.977b	38		sec				sec
.977c	60		rts				rts
.977d					_ESTASwitchFloat:
.977d	9c 07 04	stz $0407			stz 	DecimalCount 				; reset the count of digits - we divide by 10^n at the end.
.9780	e8		inx				inx 								; zero the decimal additive.
.9781	20 d5 9d	jsr $9dd5			jsr 	NSMSetZero
.9784	ca		dex				dex
.9785	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.9787	80 ae		bra $9737			bra 	_ENExitChange
.9789					_ESTADecimalState:
.9789	68		pla				pla 								; digit.
.978a	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 2nd decimal point.
.978c	f0 99		beq $9727			beq 	_ENFail
.978e	e8		inx				inx 								; put digit into fractional part of X+1
.978f	20 d6 97	jsr $97d6			jsr 	ESTAShiftDigitIntoMantissa
.9792	ca		dex				dex
.9793	ee 07 04	inc $0407			inc 	DecimalCount 				; bump the count of decimals
.9796	ad 07 04	lda $0407			lda 	DecimalCount 				; too many decimal digits.
.9799	c9 0b		cmp #$0b			cmp 	#11
.979b	f0 02		beq $979f			beq 	_ESTADSFail
.979d	38		sec				sec
.979e	60		rts				rts
.979f					_ESTADSFail:
.979f	4c 58 9f	jmp $9f58			jmp 	RangeError
.97a2					_ENConstructFinal:
.97a2	ad 07 04	lda $0407			lda 	DecimalCount 				; get decimal count
.97a5	f0 2d		beq $97d4			beq 	_ENCFExit 					; no decimals
.97a7	5a		phy				phy
.97a8	0a		asl a				asl 	a 							; x 4 and CLC
.97a9	0a		asl a				asl 	a
.97aa	6d 07 04	adc $0407			adc 	DecimalCount
.97ad	a8		tay				tay
.97ae	b9 17 9f	lda $9f17,y			lda 	DecimalScalarTable-5,y 		; copy decimal scalar to X+2
.97b1	95 5a		sta $5a,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.97b3	b9 18 9f	lda $9f18,y			lda 	DecimalScalarTable-5+1,y
.97b6	95 62		sta $62,x			sta 	NSMantissa1+2,x
.97b8	b9 19 9f	lda $9f19,y			lda 	DecimalScalarTable-5+2,y
.97bb	95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.97bd	b9 1a 9f	lda $9f1a,y			lda 	DecimalScalarTable-5+3,y
.97c0	95 72		sta $72,x			sta 	NSMantissa3+2,x
.97c2	b9 1b 9f	lda $9f1b,y			lda 	DecimalScalarTable-5+4,y
.97c5	95 7a		sta $7a,x			sta 	NSExponent+2,x
.97c7	a9 08		lda #$08			lda 	#NSTFloat
.97c9	95 52		sta $52,x			sta 	NSStatus+2,x
.97cb	7a		ply				ply
.97cc	e8		inx				inx 								; multiply decimal const by decimal scalar
.97cd	20 5c 95	jsr $955c			jsr 	FloatMultiply
.97d0	ca		dex				dex
.97d1	20 17 94	jsr $9417			jsr 	FloatAdd 					; add to integer part.
.97d4					_ENCFExit:
.97d4	18		clc				clc 								; reject the digit.
.97d5	60		rts				rts
.97d6					ESTAShiftDigitIntoMantissa:
.97d6	29 0f		and #$0f			and 	#15 						; save digit
.97d8	48		pha				pha
.97d9	b5 70		lda $70,x			lda 	NSMantissa3,x 				; push mantissa on stack
.97db	48		pha				pha
.97dc	b5 68		lda $68,x			lda 	NSMantissa2,x
.97de	48		pha				pha
.97df	b5 60		lda $60,x			lda 	NSMantissa1,x
.97e1	48		pha				pha
.97e2	b5 58		lda $58,x			lda 	NSMantissa0,x
.97e4	48		pha				pha
.97e5	20 e4 9d	jsr $9de4			jsr 	NSMShiftLeft 				; x 2
.97e8	20 e4 9d	jsr $9de4			jsr 	NSMShiftLeft 				; x 4
.97eb	18		clc				clc 								; pop mantissa and add
.97ec	68		pla				pla
.97ed	75 58		adc $58,x			adc 	NSMantissa0,x
.97ef	95 58		sta $58,x			sta 	NSMantissa0,x
.97f1	68		pla				pla
.97f2	75 60		adc $60,x			adc 	NSMantissa1,x
.97f4	95 60		sta $60,x			sta 	NSMantissa1,x
.97f6	68		pla				pla
.97f7	75 68		adc $68,x			adc 	NSMantissa2,x
.97f9	95 68		sta $68,x			sta 	NSMantissa2,x
.97fb	68		pla				pla
.97fc	75 70		adc $70,x			adc 	NSMantissa3,x
.97fe	95 70		sta $70,x			sta 	NSMantissa3,x 				; x 5
.9800	20 e4 9d	jsr $9de4			jsr 	NSMShiftLeft 				; x 10
.9803	68		pla				pla 								; add digit
.9804	18		clc				clc
.9805	75 58		adc $58,x			adc 	NSMantissa0,x
.9807	95 58		sta $58,x			sta 	NSMantissa0,x
.9809	90 0a		bcc $9815			bcc 	_ESTASDExit
.980b	f6 60		inc $60,x			inc 	NSMantissa1,x
.980d	d0 06		bne $9815			bne 	_ESTASDExit
.980f	f6 68		inc $68,x			inc 	NSMantissa2,x
.9811	d0 02		bne $9815			bne 	_ESTASDExit
.9813	f6 70		inc $70,x			inc 	NSMantissa3,x
.9815					_ESTASDExit:
.9815	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/term.asm

.9816					EvaluateTerm:
.9816	b1 30		lda ($30),y			lda 	(codePtr),y
.9818	30 18		bmi $9832			bmi 	_ETCheckUnary 				; unary function ? (text ones)
.981a	c9 40		cmp #$40			cmp 	#$40 						; 40-7F => identifier reference
.981c	b0 6c		bcs $988a			bcs 	_ETVariable
.981e	c9 30		cmp #$30			cmp 	#'0' 						; is it a number
.9820	90 6b		bcc $988d			bcc 	_ETPuncUnary 				; if not it might be a punctuation unary.
.9822	c9 3a		cmp #$3a			cmp 	#'9'+1
.9824	b0 67		bcs $988d			bcs 	_ETPuncUnary
.9826	20 0e 97	jsr $970e			jsr 	EncodeNumberStart 			; can't fail as it's 0-9 !
.9829					_ETNumber:
.9829	c8		iny				iny 								; keep encoding until we have the numbers
.982a	b1 30		lda ($30),y			lda 	(codePtr),y
.982c	20 11 97	jsr $9711			jsr 	EncodeNumberContinue
.982f	b0 f8		bcs $9829			bcs 	_ETNumber 					; go back if accepted.
.9831	60		rts				rts
.9832					_ETCheckUnary:
.9832	c9 ff		cmp #$ff			cmp 	#KWC_STRING 				; string token
.9834	f0 3f		beq $9875			beq 	_ETString
.9836	c9 fe		cmp #$fe			cmp 	#KWC_HEXCONST 				; hex constant.
.9838	f0 12		beq $984c			beq 	_ETHexConstant
.983a	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; check it actually is a unary function
.983c	90 0b		bcc $9849			bcc 	_ETSyntaxError
.983e	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1
.9840	b0 07		bcs $9849			bcs 	_ETSyntaxError
.9842	da		phx				phx 								; push X on the stack
.9843	0a		asl a				asl 	a 							; put vector x 2 into X
.9844	aa		tax				tax
.9845	c8		iny				iny 								; consume unary function token
.9846	7c 0a 8c	jmp ($8c0a,x)			jmp 	(VectorSet0,x) 				; and do it.
.9849					_ETSyntaxError:
.9849	4c 53 9f	jmp $9f53			jmp 	SyntaxError
.984c					_ETHexConstant:
.984c	c8		iny				iny 								; skip #
.984d	c8		iny				iny 								; skip count
.984e	20 d5 9d	jsr $9dd5			jsr 	NSMSetZero 					; clear result
.9851					_ETHLoop:
.9851	b1 30		lda ($30),y			lda 	(codePtr),y
.9853	c8		iny				iny 								; and consume
.9854	c9 00		cmp #$00			cmp 	#0 							; exit if zero
.9856	f0 1c		beq $9874			beq 	_ETHExit
.9858	48		pha				pha 								; save on stack.
.9859	20 e4 9d	jsr $9de4			jsr 	NSMShiftLeft 				; x 2
.985c	20 e4 9d	jsr $9de4			jsr 	NSMShiftLeft 				; x 4
.985f	20 e4 9d	jsr $9de4			jsr 	NSMShiftLeft 				; x 8
.9862	20 e4 9d	jsr $9de4			jsr 	NSMShiftLeft 				; x 16
.9865	68		pla				pla 								; ASCII
.9866	c9 41		cmp #$41			cmp 	#'A'
.9868	90 02		bcc $986c			bcc 	_ETHNotChar
.986a	e9 07		sbc #$07			sbc 	#7
.986c					_ETHNotChar:
.986c	29 0f		and #$0f			and 	#15 						; digit now
.986e	15 58		ora $58,x			ora 	NSMantissa0,x 				; put in LS Nibble
.9870	95 58		sta $58,x			sta 	NSMantissa0,x
.9872	80 dd		bra $9851			bra 	_ETHLoop 					; go round.
.9874					_ETHExit:
.9874	60		rts				rts
.9875					_ETString:
.9875	c8		iny				iny 								; look at length
.9876	b1 30		lda ($30),y			lda 	(codePtr),y
.9878	48		pha				pha
.9879	c8		iny				iny 								; first character
.987a	20 30 a5	jsr $a530			jsr 	MemoryInline 				; put address of string at (code-Ptr),y on stack
.987d	68		pla				pla 								; restore count and save
.987e	85 36		sta $36				sta 	zTemp0
.9880	98		tya				tya 								; add length to Y to skip it.
.9881	18		clc				clc
.9882	65 36		adc $36				adc 	zTemp0
.9884	a8		tay				tay
.9885	a9 10		lda #$10			lda 	#NSTString 					; mark as string
.9887	95 50		sta $50,x			sta 	NSStatus,x
.9889	60		rts				rts
.988a					_ETVariable:
.988a	4c df 98	jmp $98df			jmp 	VariableHandler
.988d					_ETPuncUnary:
.988d	c8		iny				iny 								; consume the unary character
.988e	c9 2d		cmp #$2d			cmp 	#KWD_MINUS 					; unary minus
.9890	f0 2b		beq $98bd			beq 	_ETUnaryNegate
.9892	c9 10		cmp #$10			cmp 	#KWD_AT 					; @ reference -> constant
.9894	f0 36		beq $98cc			beq 	_ETDereference
.9896	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; parenthesis
.9898	f0 3e		beq $98d8			beq 	_ETParenthesis
.989a	64 36		stz $36				stz 	zTemp0 						; zTemp0 is the indirection level.
.989c	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; byte indirection (0) ?
.989e	f0 06		beq $98a6			beq 	_ETIndirection
.98a0	e6 36		inc $36				inc 	zTemp0
.98a2	c9 21		cmp #$21			cmp 	#KWD_PLING					; word indirection (1) \
.98a4	d0 a3		bne $9849			bne 	_ETSyntaxError
.98a6					_ETIndirection:
.98a6	a5 36		lda $36				lda 	zTemp0 						; push indirection amount (0-1) => (1-2) on the stack
.98a8	1a		inc a				inc 	a
.98a9	48		pha				pha
.98aa	20 16 98	jsr $9816			jsr 	EvaluateTerm				; evaluate the term
.98ad	20 8f 96	jsr $968f			jsr 	Dereference 				; dereference it.
.98b0	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a +ve integer.
.98b2	d0 06		bne $98ba			bne 	_ETTypeMismatch
.98b4	68		pla				pla 								; indirection 1-2
.98b5	09 20		ora #$20			ora 	#NSBIsReference 			; make it a reference.
.98b7	95 50		sta $50,x			sta 	NSStatus,x
.98b9	60		rts				rts
.98ba					_ETTypeMismatch:
.98ba	4c 5d 9f	jmp $9f5d			jmp 	TypeError
.98bd					_ETUnaryNegate:
.98bd	20 16 98	jsr $9816			jsr 	EvaluateTerm				; evaluate the term
.98c0	20 8f 96	jsr $968f			jsr 	Dereference 				; dereference it.
.98c3	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a number
.98c5	29 10		and #$10			and 	#NSTString
.98c7	d0 f1		bne $98ba			bne 	_ETTypeMismatch
.98c9	4c 97 9d	jmp $9d97			jmp 	NSMNegate  					; just toggles the sign bit.
.98cc					_ETDereference:
.98cc	20 16 98	jsr $9816			jsr 	EvaluateTerm				; evaluate the term
.98cf	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a reference
.98d1	29 20		and #$20			and 	#NSBIsReference
.98d3	f0 e5		beq $98ba			beq 	_ETTypeMismatch
.98d5	74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer address
.98d7	60		rts				rts
.98d8					_ETParenthesis:
.98d8	20 cc 93	jsr $93cc			jsr 	EvaluateExpression 			; evaluate here, from lowest precedence
.98db	20 af 8e	jsr $8eaf			jsr 	CheckRightBracket 			; check for )
.98de	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/variable.asm

.98df					VariableHandler:
.98df	b1 30		lda ($30),y			lda 	(codePtr),y
.98e1	18		clc				clc
.98e2	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.98e4	85 37		sta $37				sta 	zTemp0+1
.98e6	c8		iny				iny
.98e7	b1 30		lda ($30),y			lda 	(codePtr),y
.98e9	85 36		sta $36				sta 	zTemp0
.98eb	c8		iny				iny
.98ec	18		clc				clc									; copy variable address+3 to mantissa
.98ed	69 03		adc #$03			adc 	#3
.98ef	95 58		sta $58,x			sta 	NSMantissa0,x
.98f1	a5 37		lda $37				lda 	zTemp0+1
.98f3	69 00		adc #$00			adc 	#0
.98f5	95 60		sta $60,x			sta 	NSMantissa1,x
.98f7	74 68		stz $68,x			stz 	NSMantissa2,x
.98f9	74 70		stz $70,x			stz 	NSMantissa3,x
.98fb	74 78		stz $78,x			stz 	NSExponent,x
.98fd	5a		phy				phy
.98fe	a0 02		ldy #$02			ldy 	#2 							; read type
.9900	b1 36		lda ($36),y			lda 	(zTemp0),y
.9902	7a		ply				ply
.9903	29 1c		and #$1c			and 	#NSBTypeMask+NSBIsArray 	; get type information
.9905	09 20		ora #$20			ora 	#NSBIsReference 			; make a reference.
.9907	95 50		sta $50,x			sta 	NSStatus,x
.9909	29 04		and #$04			and 	#NSBIsArray
.990b	d0 01		bne $990e			bne 	_VHArray
.990d	60		rts				rts
.990e					_VHArray:
.990e	e8		inx				inx
.990f	20 70 9d	jsr $9d70			jsr 	Evaluate8BitInteger 		; get the 1st index.
.9912	a9 ff		lda #$ff			lda 	#$FF 						; set Status of X+2 to a duff value so we know if we picked it up.
.9914	95 51		sta $51,x			sta 	NSStatus+1,x
.9916	b1 30		lda ($30),y			lda 	(codePtr),y
.9918	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.991a	d0 06		bne $9922			bne 	_VHNoSecondIndex
.991c	c8		iny				iny 								; skip the comma
.991d	e8		inx				inx
.991e	20 70 9d	jsr $9d70			jsr 	Evaluate8BitInteger 		; get the 2nd index.
.9921	ca		dex				dex
.9922					_VHNoSecondIndex:
.9922	ca		dex				dex 								; set X back.
.9923	20 af 8e	jsr $8eaf			jsr 	CheckRightBracket 			; and check the right bracket.
.9926	5a		phy				phy 								; save position
.9927	a0 02		ldy #$02			ldy 	#2 							; check first index is not-zero, e.g. array defined
.9929	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.992b	f0 60		beq $998d			beq 	_VHBadIndex
.992d	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy record address to zaTemp
.992f	85 3e		sta $3e				sta 	zaTemp
.9931	b5 60		lda $60,x			lda 	NSMantissa1,x
.9933	85 3f		sta $3f				sta 	zaTemp+1
.9935	a0 03		ldy #$03			ldy 	#3 							; get the second index - which is 0 if there is one index.
.9937	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9939	f0 02		beq $993d			beq 	_VHHas2Mask
.993b	a9 ff		lda #$ff			lda 	#$FF
.993d					_VHHas2Mask:
.993d	d5 52		cmp $52,x			cmp 	NSStatus+2,x 				; so if they are the same there are the wrong number of indices
.993f	f0 4c		beq $998d			beq 	_VHBadIndex
.9941	0a		asl a				asl 	a 							; carry will be set if a second index
.9942	90 08		bcc $994c			bcc 	_VHCheckFirstIndex
.9944	a0 03		ldy #$03			ldy 	#3 			 				; check the 2nd size >= 2nd index
.9946	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9948	d5 5a		cmp $5a,x			cmp 	NSMantissa0+2,x
.994a	90 41		bcc $998d			bcc 	_VHBadIndex
.994c					_VHCheckFirstIndex:
.994c	a0 02		ldy #$02			ldy 	#2 			 				; check the 2nd size >= 2nd index
.994e	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9950	d5 59		cmp $59,x			cmp 	NSMantissa0+1,x
.9952	90 39		bcc $998d			bcc 	_VHBadIndex
.9954	64 36		stz $36				stz 	zTemp0 						; clear zTemp0 (if 1 index)
.9956	64 37		stz $37				stz 	zTemp0+1
.9958	b5 52		lda $52,x			lda 	NSStatus+2,x 				; if only one index provided, don't need to multiply
.995a	30 0e		bmi $996a			bmi 	_VHNoMultiply
.995c	da		phx				phx
.995d	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; get 2nd index on stack
.995f	48		pha				pha
.9960	a0 02		ldy #$02			ldy 	#2 							; get 1st size in A
.9962	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9964	1a		inc a				inc 	a 							; add 1 for zero base
.9965	fa		plx				plx
.9966	20 80 9d	jsr $9d80			jsr 	Multiply8x8 				; calculate -> Z0
.9969	fa		plx				plx
.996a					_VHNoMultiply:
.996a	18		clc				clc
.996b	a5 36		lda $36				lda 	zTemp0
.996d	75 59		adc $59,x			adc 	NSMantissa0+1,x
.996f	85 36		sta $36				sta 	zTemp0
.9971	a5 37		lda $37				lda 	zTemp0+1
.9973	69 00		adc #$00			adc 	#0
.9975	85 37		sta $37				sta 	zTemp0+1
.9977	b5 50		lda $50,x			lda 	NSStatus,x
.9979	20 27 85	jsr $8527			jsr 	ScaleByBaseType
.997c	18		clc				clc
.997d	b2 3e		lda ($3e)			lda 	(zaTemp)
.997f	65 36		adc $36				adc 	zTemp0
.9981	95 58		sta $58,x			sta 	NSMantissa0,x
.9983	a0 01		ldy #$01			ldy 	#1
.9985	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9987	65 37		adc $37				adc 	zTemp0+1
.9989	95 60		sta $60,x			sta 	NSMantissa1,x
.998b	7a		ply				ply 								; restore position
.998c	60		rts				rts
.998d					_VHBadIndex:
.998d	a9 17		lda #$17		lda	#23
.998f	4c c8 8e	jmp $8ec8		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/abs.asm

.9992					AbsUnary:
.9992	fa		plx				plx 								; restore stack pos
.9993	20 23 9d	jsr $9d23			jsr 	EvaluateNumber 				; get a float or int
.9996	20 af 8e	jsr $8eaf			jsr 	CheckRightBracket
.9999	b5 50		lda $50,x			lda 	NSStatus,x 					; clear the sign bit
.999b	29 7f		and #$7f			and 	#$7F
.999d	95 50		sta $50,x			sta 	NSStatus,x
.999f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/alloc.asm

.99a0					AllocUnary:
.99a0	fa		plx				plx 								; restore stack pos
.99a1	20 55 9d	jsr $9d55			jsr 	Evaluate16BitInteger		; get bytes required.
.99a4	20 af 8e	jsr $8eaf			jsr 	CheckRightBracket
.99a7	da		phx				phx 								; save X/Y
.99a8	5a		phy				phy
.99a9	8a		txa				txa 								; copy X into Y
.99aa	a8		tay				tay
.99ab	b9 60 00	lda $0060,y			lda		NSMantissa1,y 				; get size
.99ae	aa		tax				tax
.99af	b9 58 00	lda $0058,y			lda 	NSMantissa0,y
.99b2	20 bf 99	jsr $99bf			jsr 	AllocateXABytes 			; allocate memory
.99b5	99 58 00	sta $0058,y			sta 	NSMantissa0,y 				; write address out.
.99b8	8a		txa				txa
.99b9	99 60 00	sta $0060,y			sta 	NSMantissa1,y
.99bc	7a		ply				ply
.99bd	fa		plx				plx
.99be	60		rts				rts
.99bf					AllocateXABytes:
.99bf	5a		phy				phy
.99c0	ac 0c 04	ldy $040c			ldy 	lowMemPtr 					; push current address on stack and to zTemp0
.99c3	84 36		sty $36				sty 	zTemp0
.99c5	5a		phy				phy
.99c6	ac 0d 04	ldy $040d			ldy 	lowMemPtr+1
.99c9	84 37		sty $37				sty 	zTemp0+1
.99cb	5a		phy				phy
.99cc	18		clc				clc 								; add to low memory pointer
.99cd	6d 0c 04	adc $040c			adc 	lowMemPtr
.99d0	8d 0c 04	sta $040c			sta 	lowMemPtr
.99d3	8a		txa				txa
.99d4	6d 0d 04	adc $040d			adc 	lowMemPtr+1
.99d7	8d 0d 04	sta $040d			sta 	lowMemPtr+1
.99da	b0 2f		bcs $9a0b			bcs 	CISSMemory
.99dc	20 fd 99	jsr $99fd			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.99df					_ClearMemory:
.99df	ad 0c 04	lda $040c			lda 	lowMemPtr 					; cleared all memory allocated
.99e2	c5 36		cmp $36				cmp 	zTemp0
.99e4	d0 07		bne $99ed			bne 	_CMClearNext
.99e6	ad 0d 04	lda $040d			lda 	lowMemPtr+1
.99e9	c5 37		cmp $37				cmp 	zTemp0+1
.99eb	f0 0c		beq $99f9			beq 	_CMExit
.99ed					_CMClearNext:
.99ed	a9 00		lda #$00			lda 	#0 							; clear byte, advance to next.
.99ef	92 36		sta ($36)			sta 	(zTemp0)
.99f1	e6 36		inc $36				inc 	zTemp0
.99f3	d0 ea		bne $99df			bne 	_ClearMemory
.99f5	e6 37		inc $37				inc		zTemp0+1
.99f7	80 e6		bra $99df			bra 	_ClearMemory
.99f9					_CMExit:
.99f9	fa		plx				plx
.99fa	68		pla				pla
.99fb	7a		ply				ply
.99fc	60		rts				rts
.99fd					CheckIdentifierStringSpace:
.99fd	48		pha				pha
.99fe	ad 0d 04	lda $040d			lda 	lowMemPtr+1 				; get low memory pointer
.9a01	18		clc				clc
.9a02	69 02		adc #$02			adc 	#2 							; need at least 2 256 byte pages
.9a04	cd 0f 04	cmp $040f			cmp 	StringMemory+1 				; is it >= StringMemory
.9a07	b0 02		bcs $9a0b			bcs 	CISSMemory
.9a09	68		pla				pla
.9a0a	60		rts				rts
.9a0b					CISSMemory:
.9a0b	a9 06		lda #$06		lda	#6
.9a0d	4c c8 8e	jmp $8ec8		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/asc.asm

.9a10					AscUnary:
.9a10	fa		plx				plx 								; restore stack pos
.9a11	20 2d 9d	jsr $9d2d			jsr 	EvaluateString 				; get a string
.9a14	b2 36		lda ($36)			lda 	(zTemp0)					; get/return first character
.9a16	20 d7 9d	jsr $9dd7			jsr 	NSMSetByte 					; ASC("") will return zero.
.9a19	20 af 8e	jsr $8eaf			jsr 	CheckRightBracket
.9a1c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/frac.asm

.9a1d					FracUnary:
.9a1d	fa		plx				plx 								; restore stack pos
.9a1e	20 23 9d	jsr $9d23			jsr 	EvaluateNumber 				; get a float or int
.9a21	20 af 8e	jsr $8eaf			jsr 	CheckRightBracket
.9a24	b5 50		lda $50,x			lda 	NSStatus,x
.9a26	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9a28	f0 04		beq $9a2e			beq 	_IUZero
.9a2a	20 dd 94	jsr $94dd			jsr 	FloatFractionalPart
.9a2d	60		rts				rts
.9a2e					_IUZero:
.9a2e	20 d5 9d	jsr $9dd5			jsr 	NSMSetZero
.9a31	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/int.asm

.9a32					IntUnary:
.9a32	fa		plx				plx 								; restore stack pos
.9a33	20 23 9d	jsr $9d23			jsr 	EvaluateNumber 				; get a float or int
.9a36	20 af 8e	jsr $8eaf			jsr 	CheckRightBracket
.9a39	b5 50		lda $50,x			lda 	NSStatus,x
.9a3b	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9a3d	f0 03		beq $9a42			beq 	_IUExit
.9a3f	20 35 95	jsr $9535			jsr 	FloatIntegerPart
.9a42					_IUExit:
.9a42	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/len.asm

.9a43					LenUnary:
.9a43	fa		plx				plx 								; restore stack pos
.9a44	20 2d 9d	jsr $9d2d			jsr 	EvaluateString 				; get a string
.9a47	5a		phy				phy
.9a48	a0 00		ldy #$00			ldy 	#0 							; find length
.9a4a					_LenFind:
.9a4a	b1 36		lda ($36),y			lda 	(zTemp0),y 					; look for trailing NULL.
.9a4c	f0 06		beq $9a54			beq 	_LenExit
.9a4e	c8		iny				iny
.9a4f	d0 f9		bne $9a4a			bne 	_LenFind
.9a51	4c 58 9f	jmp $9f58			jmp 	RangeError 					; string > 255 - no trailing NULL.
.9a54					_LenExit:
.9a54	98		tya				tya		 							; return length
.9a55	20 d7 9d	jsr $9dd7			jsr 	NSMSetByte
.9a58	7a		ply				ply
.9a59	20 af 8e	jsr $8eaf			jsr 	CheckRightBracket
.9a5c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/minmax.asm

.9a5d					Unary_Min:
.9a5d	a9 01		lda #$01			lda 	#1
.9a5f	80 02		bra $9a63			bra 	UnaryMinMaxMain
.9a61					Unary_Max:
.9a61	a9 ff		lda #$ff			lda 	#$FF 						; value from comparator to cause a write
.9a63					UnaryMinMaxMain:
.9a63	fa		plx				plx 								; get index on number stack
.9a64	48		pha				pha 								; save comparator
.9a65	20 1a 9d	jsr $9d1a			jsr 	EvaluateValue 				; get the first value.
.9a68					_UMMMLoop:
.9a68	b1 30		lda ($30),y			lda 	(codePtr),y
.9a6a	c9 29		cmp #$29			cmp 	#KWD_RPAREN 				; if right bracket then done.
.9a6c	f0 22		beq $9a90			beq 	_UMMMDone
.9a6e	20 b7 8e	jsr $8eb7			jsr 	CheckComma 					; must be a comma
.9a71	e8		inx				inx
.9a72	20 1a 9d	jsr $9d1a			jsr 	EvaluateValue
.9a75	ca		dex				dex
.9a76	20 b8 9d	jsr $9db8			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] (Compare is destructive)
.9a79	e8		inx				inx
.9a7a	20 b8 9d	jsr $9db8			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2], original
.9a7d	e8		inx				inx
.9a7e	20 7f 8f	jsr $8f7f			jsr 	CompareBaseCode 			; part of > = < etc. code, returns 255,0 or 1
.9a81	ca		dex				dex
.9a82	ca		dex				dex
.9a83	85 36		sta $36				sta 	zTemp0 						; save required result
.9a85	68		pla				pla 								; get and save comparator
.9a86	48		pha				pha
.9a87	c5 36		cmp $36				cmp 	zTemp0 						; if the comparator
.9a89	d0 dd		bne $9a68			bne 	_UMMMLoop
.9a8b	20 93 9a	jsr $9a93			jsr 	ExpCopyAboveDown 			; copy next up slot down
.9a8e	80 d8		bra $9a68			bra 	_UMMMLoop
.9a90					_UMMMDone:
.9a90	68		pla				pla 								; throw the comparator
.9a91	c8		iny				iny 								; skip )
.9a92	60		rts				rts
.9a93					ExpCopyAboveDown:
.9a93	b5 51		lda $51,x			lda 	NSStatus+1,x
.9a95	95 50		sta $50,x			sta 	NSStatus,x
.9a97	b5 79		lda $79,x			lda 	NSExponent+1,x
.9a99	95 78		sta $78,x			sta 	NSExponent,x
.9a9b	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9a9d	95 58		sta $58,x			sta 	NSMantissa0,x
.9a9f	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9aa1	95 60		sta $60,x			sta 	NSMantissa1,x
.9aa3	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.9aa5	95 68		sta $68,x			sta 	NSMantissa2,x
.9aa7	b5 71		lda $71,x			lda 	NSMantissa3+1,x
.9aa9	95 70		sta $70,x			sta 	NSMantissa3,x
.9aab	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/not.asm

.9aac					Unary_Not:
.9aac	fa		plx				plx
.9aad	20 42 9d	jsr $9d42			jsr 	EvaluateInteger 			; get integer
.9ab0	20 af 8e	jsr $8eaf			jsr 	CheckRightBracket
.9ab3	20 f7 9d	jsr $9df7			jsr 	NSMIsZero 					; zero mantissa ?
.9ab6	f0 04		beq $9abc			beq 	_NotZero
.9ab8	20 d5 9d	jsr $9dd5			jsr 	NSMSetZero
.9abb	60		rts				rts
.9abc					_NotZero:
.9abc	4c 35 8f	jmp $8f35			jmp 	ReturnTrue

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/rnd.asm

.9abf					Unary_Random:
.9abf	fa		plx				plx
.9ac0	20 31 9b	jsr $9b31			jsr 	Random32Bit 				; get a random number
.9ac3	20 1a 9b	jsr $9b1a			jsr 	URCopyToMantissa  			; put in mantissa
.9ac6	b1 30		lda ($30),y			lda 	(codePtr),y
.9ac8	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.9aca	f0 08		beq $9ad4			beq 	_URNoModulus 				; then we return a random 30 bit number.
.9acc	e8		inx				inx
.9acd	20 55 9d	jsr $9d55			jsr 	Evaluate16BitInteger 		; put modulus value in +1
.9ad0	ca		dex				dex
.9ad1	20 87 90	jsr $9087			jsr 	IntegerModulusNoCheck 		; calculate modulus, so now 0 .. n-1
.9ad4					_URNoModulus:
.9ad4	74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer positive
.9ad6	74 78		stz $78,x			stz 	NSExponent,x
.9ad8	20 af 8e	jsr $8eaf			jsr 	CheckRightBracket
.9adb	60		rts				rts
.9adc					Unary_Rnd:
.9adc	fa		plx				plx
.9add	20 23 9d	jsr $9d23			jsr 	EvaluateNumber 				; number to use.
.9ae0	20 af 8e	jsr $8eaf			jsr 	CheckRightBracket 			; closing bracket
.9ae3	20 f7 9d	jsr $9df7			jsr 	NSMIsZero 					; if zero, then don't generate a new number
.9ae6	f0 26		beq $9b0e			beq 	_URCopySeed
.9ae8	b5 50		lda $50,x			lda 	NSStatus,x 					; if -ve, then seed using parameter
.9aea	10 1f		bpl $9b0b			bpl 	_URDontSeed
.9aec	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy - value to seed butchering it.
.9aee	49 17		eor #$17			eor 	#$17
.9af0	8d 08 04	sta $0408			sta 	RandomSeed+0
.9af3	b5 60		lda $60,x			lda 	NSMantissa1,x
.9af5	49 a5		eor #$a5			eor 	#$A5
.9af7	8d 09 04	sta $0409			sta 	RandomSeed+1
.9afa	b5 68		lda $68,x			lda 	NSMantissa2,x
.9afc	49 c2		eor #$c2			eor 	#$C2
.9afe	8d 0a 04	sta $040a			sta 	RandomSeed+2
.9b01	b5 70		lda $70,x			lda 	NSMantissa3,x
.9b03	49 9d		eor #$9d			eor 	#$9D
.9b05	8d 0b 04	sta $040b			sta 	RandomSeed+3
.9b08	20 31 9b	jsr $9b31			jsr 	Random32Bit
.9b0b					_URDontSeed:
.9b0b	20 31 9b	jsr $9b31			jsr 	Random32Bit 				; generate a number
.9b0e					_URCopySeed:
.9b0e	20 1a 9b	jsr $9b1a			jsr 	URCopyToMantissa 			; copy into mantissa
.9b11	a9 e2		lda #$e2			lda 	#-30 						; force into 0-1 range
.9b13	95 78		sta $78,x			sta 	NSExponent,x
.9b15	a9 08		lda #$08			lda 	#NSTFloat
.9b17	95 50		sta $50,x			sta 	NSStatus,x 					; positive float
.9b19	60		rts				rts
.9b1a					URCopyToMantissa:
.9b1a	ad 08 04	lda $0408			lda 	RandomSeed+0
.9b1d	95 58		sta $58,x			sta 	NSMantissa0,x
.9b1f	ad 09 04	lda $0409			lda 	RandomSeed+1
.9b22	95 60		sta $60,x			sta 	NSMantissa1,x
.9b24	ad 0a 04	lda $040a			lda 	RandomSeed+2
.9b27	95 68		sta $68,x			sta 	NSMantissa2,x
.9b29	ad 0b 04	lda $040b			lda 	RandomSeed+3
.9b2c	29 3f		and #$3f			and 	#$3F 						; make legal mantissa
.9b2e	95 70		sta $70,x			sta 	NSMantissa3,x
.9b30	60		rts				rts
.9b31					Random32Bit:
.9b31	5a		phy				phy
.9b32	a0 07		ldy #$07			ldy 	#7 							; do it 7 times
.9b34	ad 08 04	lda $0408			lda 	RandomSeed+0 				; check the seed isn't zero
.9b37	d0 03		bne $9b3c			bne 	_Random1
.9b39	a8		tay				tay 								; if so do it 256 times
.9b3a	a9 aa		lda #$aa			lda		#$AA 						; and use this to seed the seed....
.9b3c					_Random1:
.9b3c	0a		asl a				asl 	a 							; LSFR RNG
.9b3d	2e 09 04	rol $0409			rol 	RandomSeed+1
.9b40	2e 0a 04	rol $040a			rol 	RandomSeed+2
.9b43	2e 0b 04	rol $040b			rol 	RandomSeed+3
.9b46	90 02		bcc $9b4a			bcc 	_Random2
.9b48	49 c5		eor #$c5			eor 	#$C5
.9b4a					_Random2:
.9b4a	88		dey				dey
.9b4b	d0 ef		bne $9b3c			bne 	_Random1
.9b4d	8d 08 04	sta $0408			sta 	RandomSeed+0
.9b50	7a		ply				ply
.9b51	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/sgn.asm

.9b52					SgnUnary:
.9b52	fa		plx				plx 								; restore stack pos
.9b53	20 23 9d	jsr $9d23			jsr 	EvaluateNumber 				; get a float or int
.9b56	20 af 8e	jsr $8eaf			jsr 	CheckRightBracket
.9b59	20 f7 9d	jsr $9df7			jsr 	NSMIsZero 					; if zero
.9b5c	f0 0e		beq $9b6c			beq 	_SGZero  					; return Int Zero
.9b5e	b5 50		lda $50,x			lda 	NSStatus,x 					; get status w/sign
.9b60	48		pha				pha
.9b61	a9 01		lda #$01			lda 	#1 							; set to 1
.9b63	20 d7 9d	jsr $9dd7			jsr 	NSMSetByte
.9b66	68		pla				pla
.9b67	29 80		and #$80			and		#$80 						; copy the sign byte out
.9b69	95 50		sta $50,x			sta 	NSStatus,x  				; so it will be -1 or 1
.9b6b	60		rts				rts
.9b6c	20 d5 9d	jsr $9dd5	_SGZero:jsr 	NSMSetZero
.9b6f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/val.asm

.9b70					ValUnary:
.9b70	fa		plx				plx 								; restore stack pos
.9b71	20 86 9b	jsr $9b86			jsr 	ValMainCode 				; do the main val() code
.9b74	b0 01		bcs $9b77			bcs 	_VUError 					; couldn't convert
.9b76	60		rts				rts
.9b77					_VUError:
.9b77	4c 5d 9f	jmp $9f5d			jmp 	TypeError
.9b7a					IsValUnary:
.9b7a	fa		plx				plx 								; restore stack pos
.9b7b	20 86 9b	jsr $9b86			jsr 	ValMainCode 				; do the main val() code
.9b7e	b0 03		bcs $9b83			bcs 	_VUBad
.9b80	4c 35 8f	jmp $8f35			jmp 	ReturnTrue
.9b83					_VUBad:
.9b83	4c 40 8f	jmp $8f40			jmp 	ReturnFalse
.9b86					ValMainCode:
.9b86	20 2d 9d	jsr $9d2d			jsr 	EvaluateString 				; get a string
.9b89	20 af 8e	jsr $8eaf			jsr 	CheckRightBracket 			; check right bracket present
.9b8c					ValEvaluateZTemp0:
.9b8c	5a		phy				phy
.9b8d	b2 36		lda ($36)			lda 	(zTemp0) 					; check not empty string
.9b8f	f0 17		beq $9ba8			beq 	_VMCFail2
.9b91	a0 ff		ldy #$ff			ldy 	#$FF 						; start position
.9b93	48		pha				pha 								; save first character
.9b94	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.9b96	d0 01		bne $9b99			bne 	_VMCStart
.9b98	c8		iny				iny 								; skip over -
.9b99					_VMCStart:
.9b99	38		sec				sec 								; initialise first time round.
.9b9a					_VMCNext:
.9b9a	c8		iny				iny 								; pre-increment
.9b9b	b1 36		lda ($36),y			lda 	(zTemp0),y 					; next character = EOS ?
.9b9d	f0 0c		beq $9bab			beq 	_VMCSuccess 				; successful.
.9b9f	20 12 97	jsr $9712			jsr 	EncodeNumber 				; send it to the number-builder
.9ba2	90 03		bcc $9ba7			bcc 	_VMCFail 					; if failed, give up.
.9ba4	18		clc				clc 								; next time round, countinue
.9ba5	80 f3		bra $9b9a			bra 	_VMCNext
.9ba7					_VMCFail:
.9ba7	68		pla				pla
.9ba8					_VMCFail2:
.9ba8	7a		ply				ply
.9ba9	38		sec				sec
.9baa	60		rts				rts
.9bab					_VMCSuccess:
.9bab	a9 00		lda #$00			lda 	#0 							; construct final
.9bad	20 12 97	jsr $9712			jsr 	EncodeNumber 				; by sending a duff value.
.9bb0	68		pla				pla 								; if it was -ve
.9bb1	c9 2d		cmp #$2d			cmp 	#"-"
.9bb3	d0 03		bne $9bb8			bne 	_VMCNotNegative
.9bb5	20 97 9d	jsr $9d97			jsr		NSMNegate 					; negate it.
.9bb8					_VMCNotNegative:
.9bb8	7a		ply				ply
.9bb9	18		clc				clc
.9bba	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/chr.asm

.9bbb					ChrUnary:
.9bbb	fa		plx				plx 								; restore stack pos
.9bbc	20 70 9d	jsr $9d70			jsr 	Evaluate8BitInteger			; get value
.9bbf	48		pha				pha
.9bc0	20 af 8e	jsr $8eaf			jsr 	CheckRightBracket
.9bc3	a9 01		lda #$01			lda 	#1 							; allocate space for one char
.9bc5	20 07 a7	jsr $a707			jsr 	StringTempAllocate
.9bc8	68		pla				pla 								; write number to it
.9bc9	20 40 a7	jsr $a740			jsr 	StringTempWrite
.9bcc	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/spc.asm

.9bcd					SpcUnary:
.9bcd	fa		plx				plx 								; restore stack pos
.9bce	20 70 9d	jsr $9d70			jsr 	Evaluate8BitInteger			; get value
.9bd1	5a		phy				phy
.9bd2	48		pha				pha 								; save count
.9bd3	20 07 a7	jsr $a707			jsr 	StringTempAllocate
.9bd6	7a		ply				ply 								; to do count in Y
.9bd7					_SpcLoop:
.9bd7	c0 00		cpy #$00			cpy 	#0
.9bd9	f0 08		beq $9be3			beq 	_SpcExit
.9bdb	a9 20		lda #$20			lda 	#32
.9bdd	20 40 a7	jsr $a740			jsr 	StringTempWrite
.9be0	88		dey				dey
.9be1	80 f4		bra $9bd7			bra 	_SPCLoop
.9be3					_SpcExit:
.9be3	7a		ply				ply
.9be4	20 af 8e	jsr $8eaf			jsr 	CheckRightBracket
.9be7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/str.asm

.9be8					Unary_Str:
.9be8	fa		plx				plx
.9be9	20 23 9d	jsr $9d23			jsr 	EvaluateNumber  			; get number
.9bec	20 af 8e	jsr $8eaf			jsr 	CheckRightBracket 			; closing bracket
.9bef	a9 05		lda #$05			lda 	#5 							; maximum decimals, from Basic816
.9bf1	20 0a 9c	jsr $9c0a			jsr 	ConvertNumberToString 		; do the conversion.
.9bf4	a9 21		lda #$21			lda		#33 						; create buffer
.9bf6	20 07 a7	jsr $a707			jsr 	StringTempAllocate 			; allocate memory
.9bf9	da		phx				phx
.9bfa	a2 00		ldx #$00			ldx 	#0
.9bfc					_USCopy:
.9bfc	bd 9d 05	lda $059d,x			lda 	DecimalBuffer,x
.9bff	20 40 a7	jsr $a740			jsr 	StringTempWrite
.9c02	e8		inx				inx
.9c03	bd 9d 05	lda $059d,x			lda 	DecimalBuffer,x
.9c06	d0 f4		bne $9bfc			bne 	_USCopy
.9c08	fa		plx				plx
.9c09	60		rts				rts
.9c0a					ConvertNumberToString:
.9c0a	5a		phy				phy 								; save code position
.9c0b	8d 14 04	sta $0414			sta 	DecimalPlaces	 			; save number of DPs.
.9c0e	9c 15 04	stz $0415			stz 	dbOffset 					; offset into decimal buffer = start.
.9c11	b5 50		lda $50,x			lda 	NSStatus,x  				; is it -ve.
.9c13	10 09		bpl $9c1e			bpl 	_CNTSNotNegative
.9c15	29 7f		and #$7f			and 	#$7F 						; make +ve
.9c17	95 50		sta $50,x			sta 	NSStatus,x
.9c19	a9 2d		lda #$2d			lda 	#"-"
.9c1b	20 7f 9c	jsr $9c7f			jsr 	WriteDecimalBuffer
.9c1e					_CNTSNotNegative:
.9c1e	b5 78		lda $78,x			lda 	NSExponent,x 				; check if decimal
.9c20	f0 12		beq $9c34			beq 	_CNTSNotFloat
.9c22	e8		inx				inx 								; round up
.9c23	a9 01		lda #$01			lda 	#1
.9c25	20 d7 9d	jsr $9dd7			jsr 	NSMSetByte
.9c28	ca		dex				dex
.9c29	b5 78		lda $78,x			lda		NSExponent,x
.9c2b	95 79		sta $79,x			sta 	NSExponent+1,x
.9c2d	a9 08		lda #$08			lda 	#NSTFloat
.9c2f	95 51		sta $51,x			sta 	NSStatus+1,x
.9c31	20 17 94	jsr $9417			jsr 	FloatAdd
.9c34					_CNTSNotFloat:
.9c34	20 61 9c	jsr $9c61			jsr 	MakePlusTwoString
.9c37	20 dd 94	jsr $94dd			jsr 	FloatFractionalPart 		; get the fractional part
.9c3a	20 8e 95	jsr $958e			jsr 	NSNormalise					; normalise , exit if zero
.9c3d	f0 20		beq $9c5f			beq 	_CNTSExit
.9c3f	a9 2e		lda #$2e			lda 	#"."
.9c41	20 7f 9c	jsr $9c7f			jsr 	WriteDecimalBuffer 			; write decimal place
.9c44					_CNTSDecimal:
.9c44	ce 14 04	dec $0414			dec 	DecimalPlaces 				; done all the decimals
.9c47	30 16		bmi $9c5f			bmi 	_CNTSExit
.9c49	e8		inx				inx 								; x 10.0
.9c4a	a9 0a		lda #$0a			lda 	#10
.9c4c	20 d7 9d	jsr $9dd7			jsr 	NSMSetByte
.9c4f	a9 08		lda #$08			lda 	#NSTFloat
.9c51	95 50		sta $50,x			sta 	NSStatus,x
.9c53	ca		dex				dex
.9c54	20 5c 95	jsr $955c			jsr 	FloatMultiply
.9c57	20 61 9c	jsr $9c61			jsr 	MakePlusTwoString
.9c5a	20 dd 94	jsr $94dd			jsr 	FloatFractionalPart 		; get the fractional part
.9c5d	80 e5		bra $9c44			bra 	_CNTSDecimal 				; keep going.
.9c5f					_CNTSExit:
.9c5f	7a		ply				ply
.9c60	60		rts				rts
.9c61					MakePlusTwoString:
.9c61	da		phx				phx
.9c62	20 b8 9d	jsr $9db8			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.9c65	e8		inx				inx 								; access it
.9c66	e8		inx				inx
.9c67	20 35 95	jsr $9535			jsr 	FloatIntegerPart 			; make it an integer
.9c6a	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.9c6c	20 47 93	jsr $9347			jsr 	ConvertInt32
.9c6f	a2 00		ldx #$00			ldx	 	#0
.9c71					_MPTSCopy:
.9c71	bd 7b 05	lda $057b,x			lda 	NumberBuffer,x
.9c74	20 7f 9c	jsr $9c7f			jsr 	WriteDecimalBuffer
.9c77	e8		inx				inx
.9c78	bd 7b 05	lda $057b,x			lda 	NumberBuffer,x
.9c7b	d0 f4		bne $9c71			bne 	_MPTSCopy
.9c7d	fa		plx				plx
.9c7e	60		rts				rts
.9c7f					WriteDecimalBuffer:
.9c7f	da		phx				phx
.9c80	ae 15 04	ldx $0415			ldx 	dbOffset
.9c83	9d 9d 05	sta $059d,x			sta 	DecimalBuffer,x
.9c86	9e 9e 05	stz $059e,x			stz 	DecimalBuffer+1,x
.9c89	ee 15 04	inc $0415			inc 	dbOffset
.9c8c	fa		plx				plx
.9c8d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/substring.asm

.9c8e					Unary_Left:
.9c8e	fa		plx				plx
.9c8f	18		clc				clc 								; only one parameter
.9c90	20 f3 9c	jsr $9cf3			jsr 	SubstringInitial 			; set up.
.9c93	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; Param #1 is the length
.9c95	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9c97	74 59		stz $59,x			stz 	NSMantissa0+1,x 			; Start is zero.
.9c99	80 25		bra $9cc0			bra 	SubstringMain
.9c9b					Unary_Right:
.9c9b	fa		plx				plx
.9c9c	18		clc				clc 								; only one parameter
.9c9d	20 f3 9c	jsr $9cf3			jsr 	SubstringInitial 			; set up.
.9ca0	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; length => param 2
.9ca2	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9ca4	b5 78		lda $78,x			lda 	NSExponent,x 				; total length
.9ca6	f5 59		sbc $59,x			sbc 	NSMantissa0+1,x 			; length - required.
.9ca8	b0 02		bcs $9cac			bcs 	_URNotUnderflow
.9caa	a9 00		lda #$00			lda 	#0 							; start from the beginning, as something like right$("AB",3)
.9cac					_URNotUnderFlow:
.9cac	95 59		sta $59,x			sta 	NSMantissa0+1,x 			; this is the start position
.9cae	80 10		bra $9cc0			bra 	SubStringMain
.9cb0					Unary_Mid:
.9cb0	fa		plx				plx
.9cb1	38		sec				sec 								; two parameters
.9cb2	20 f3 9c	jsr $9cf3			jsr 	SubstringInitial 			; set up.
.9cb5	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; first parameter is zero ?
.9cb7	f0 04		beq $9cbd			beq 	_UMError
.9cb9	d6 59		dec $59,x			dec 	NSMantissa0+1,x				; reduce initial offset by 1 as MID$(a$,1..) is actually the first character
.9cbb	80 03		bra $9cc0			bra 	SubStringMain
.9cbd					_UMError:
.9cbd	4c 62 9f	jmp $9f62			jmp 	ArgumentError
.9cc0					SubStringMain:
.9cc0	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; is the initial offset >= the length
.9cc2	d5 78		cmp $78,x			cmp 	NSExponent,x
.9cc4	b0 27		bcs $9ced			bcs 	_SSMNull 					; if so, return an empty string.
.9cc6	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; if copy count is zero
.9cc8	f0 23		beq $9ced			beq 	_SSMNull 					; return empty string.
.9cca	18		clc				clc 								; add the offset +1 to the address and
.9ccb	b5 58		lda $58,x			lda	 	NSMantissa0,x 				; put in zTemp
.9ccd	75 59		adc $59,x			adc 	NSMantissa0+1,x
.9ccf	85 36		sta $36				sta 	zTemp0
.9cd1	b5 60		lda $60,x			lda	 	NSMantissa1,x
.9cd3	69 00		adc #$00			adc 	#0
.9cd5	85 37		sta $37				sta 	zTemp0+1
.9cd7					_SSMNoCarry:
.9cd7	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; characters required.
.9cd9	20 07 a7	jsr $a707			jsr 	StringTempAllocate 			; allocate that many characters
.9cdc	5a		phy				phy 								; save Y
.9cdd	a0 00		ldy #$00			ldy 	#0 							; start copying in.
.9cdf					_SSMCopy:
.9cdf	b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next character
.9ce1	f0 08		beq $9ceb			beq 	_SSMEString 				; no more to copy
.9ce3	20 40 a7	jsr $a740			jsr 	StringTempWrite 			; and write it out.
.9ce6	c8		iny				iny
.9ce7	d6 5a		dec $5a,x			dec 	NSMantissa0+2,x
.9ce9	d0 f4		bne $9cdf			bne 	_SSMCopy
.9ceb					_SSMEString:
.9ceb	7a		ply				ply
.9cec					_SSMExit:
.9cec	60		rts				rts
.9ced					_SSMNull:
.9ced	a9 00		lda #$00			lda 	#0
.9cef	20 07 a7	jsr $a707			jsr 	StringTempAllocate
.9cf2	60		rts				rts
.9cf3					SubstringInitial:
.9cf3	da		phx				phx 								; save initial stack position
.9cf4	08		php				php 								; save carry on stack indicating 2 parameters
.9cf5	20 2d 9d	jsr $9d2d			jsr 	EvaluateString 				; get a string
.9cf8	5a		phy				phy 								; calculate length to exponent.
.9cf9	a0 ff		ldy #$ff			ldy 	#$FF
.9cfb					_SIFindLength:
.9cfb	c8		iny				iny
.9cfc	b1 36		lda ($36),y			lda 	(zTemp0),y
.9cfe	d0 fb		bne $9cfb			bne 	_SIFindLength
.9d00	98		tya				tya
.9d01	95 78		sta $78,x			sta 	NSExponent,x
.9d03	7a		ply				ply
.9d04	e8		inx				inx
.9d05	20 b7 8e	jsr $8eb7			jsr 	CheckComma 					; comma next
.9d08	20 70 9d	jsr $9d70			jsr 	Evaluate8BitInteger 		; get next parameter
.9d0b	28		plp				plp 								; is it the last parameter ?
.9d0c	90 07		bcc $9d15			bcc 	_SSIExit 					; if so, exit.
.9d0e	e8		inx				inx
.9d0f	20 b7 8e	jsr $8eb7			jsr 	CheckComma 					; comma next
.9d12	20 70 9d	jsr $9d70			jsr 	Evaluate8BitInteger 		; get last parameter
.9d15					_SSIExit:
.9d15	fa		plx				plx
.9d16	20 af 8e	jsr $8eaf			jsr 	CheckRightBracket 			; check closing bracket
.9d19	60		rts				rts 								; exit

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/exprhelper.asm

.9d1a					EvaluateValue:
.9d1a	48		pha				pha
.9d1b	20 cc 93	jsr $93cc			jsr		EvaluateExpression 			; expression
.9d1e	20 8f 96	jsr $968f			jsr 	Dereference					; derefernce it
.9d21	68		pla				pla
.9d22	60		rts				rts
.9d23					EvaluateNumber:
.9d23	20 1a 9d	jsr $9d1a			jsr 	EvaluateValue 				; get a value
.9d26	b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.9d28	29 10		and #$10			and 	#NSBIsString
.9d2a	d0 13		bne $9d3f			bne 	HelperTypeError
.9d2c	60		rts				rts
.9d2d					EvaluateString:
.9d2d	20 1a 9d	jsr $9d1a			jsr 	EvaluateValue 				; get a value
.9d30	b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.9d32	29 10		and #$10			and 	#NSBIsString
.9d34	f0 09		beq $9d3f			beq 	HelperTypeError
.9d36					CopyAddressToTemp0:
.9d36	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address -> zTemp0
.9d38	85 36		sta $36				sta 	zTemp0 						; (so we can do something with it)
.9d3a	b5 60		lda $60,x			lda 	NSMantissa1,x
.9d3c	85 37		sta $37				sta 	zTemp0+1
.9d3e	60		rts				rts
.9d3f					HelperTypeError:
.9d3f	4c 5d 9f	jmp $9f5d			jmp 	TypeError
.9d42					EvaluateInteger:
.9d42	20 23 9d	jsr $9d23			jsr 	EvaluateNumber
.9d45	b5 78		lda $78,x			lda 	NSExponent,x 				; check exponent is zero
.9d47	d0 09		bne $9d52			bne 	HelperValueError 			; if not, it's a float.
.9d49	60		rts				rts
.9d4a					EvaluateUnsignedInteger:
.9d4a	20 42 9d	jsr $9d42			jsr 	EvaluateInteger 			; check integer is +ve
.9d4d	b5 50		lda $50,x			lda 	NSStatus,x
.9d4f	30 01		bmi $9d52			bmi 	HelperValueError
.9d51	60		rts				rts
.9d52					HelperValueError:
.9d52	4c 62 9f	jmp $9f62			jmp 	ArgumentError
.9d55						Evaluate16BitInteger:
.9d55	20 4a 9d	jsr $9d4a			jsr	 	EvaluateUnsignedInteger		; get integer
.9d58	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9d5a	15 68		ora $68,x			ora 	NSMantissa2,x
.9d5c	d0 f4		bne $9d52			bne 	HelperValueError
.9d5e	60		rts				rts
.9d5f					Evaluate16BitIntegerSigned:
.9d5f	20 42 9d	jsr $9d42			jsr	 	EvaluateInteger				; get integer
.9d62	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9d64	15 68		ora $68,x			ora 	NSMantissa2,x
.9d66	d0 ea		bne $9d52			bne 	HelperValueError
.9d68	b5 50		lda $50,x			lda 	NSStatus,x 					; signed ?
.9d6a	10 03		bpl $9d6f			bpl 	_EISNotSigned
.9d6c	20 9e 9d	jsr $9d9e			jsr 	NSMNegateMantissa 			; makes it an actual 2's complement value.
.9d6f					_EISNotSigned:
.9d6f	60		rts				rts
.9d70					Evaluate8BitInteger:
.9d70	20 4a 9d	jsr $9d4a			jsr	 	EvaluateUnsignedInteger 	; get an integer
.9d73	d0 dd		bne $9d52			bne 	HelperValueError
.9d75	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 1, 2 & 3 must be zero
.9d77	15 68		ora $68,x			ora 	NSMantissa2,x
.9d79	15 60		ora $60,x			ora 	NSMantissa1,x
.9d7b	d0 d5		bne $9d52			bne 	HelperValueError
.9d7d	b5 58		lda $58,x			lda 	NSMantissa0,x
.9d7f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/mult8x8.asm

.9d80					Multiply8x8:
.9d80	4a		lsr a		  		lsr 	a  							; prime the carry bit for the loop
.9d81	85 36		sta $36			  	sta 	zTemp0
.9d83	86 37		stx $37				stx 	zTemp0+1
.9d85	a9 00		lda #$00			lda 	#0
.9d87	a2 08		ldx #$08			ldx 	#8
.9d89					_M88Loop:
.9d89	90 03		bcc $9d8e			bcc 	_M88NoAdd
.9d8b	18		clc				clc
.9d8c	65 37		adc $37				adc 	zTemp0+1
.9d8e					_M88NoAdd:
.9d8e	6a		ror a				ror 	a
.9d8f	66 36		ror $36				ror 	zTemp0  					; pull another bit out for the next iteration
.9d91	ca		dex				dex         						; inc/dec don't modify carry; only shifts and adds do
.9d92	d0 f5		bne $9d89			bne 	_M88Loop
.9d94	85 37		sta $37				sta 	zTemp0+1 					; store high 8 bits.
.9d96	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/utility.asm

.9d97					NSMNegate:
.9d97	b5 50		lda $50,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.9d99	49 80		eor #$80			eor 	#NSBIsNegative  			; toggle the negative flag
.9d9b	95 50		sta $50,x			sta 	NSStatus,x
.9d9d	60		rts				rts
.9d9e					NSMNegateMantissa:
.9d9e	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.9d9f	a9 00		lda #$00			lda 	#0
.9da1	f5 58		sbc $58,x			sbc 	NSMantissa0,x
.9da3	95 58		sta $58,x			sta 	NSMantissa0,x
.9da5	a9 00		lda #$00			lda 	#0
.9da7	f5 60		sbc $60,x			sbc 	NSMantissa1,x
.9da9	95 60		sta $60,x			sta 	NSMantissa1,x
.9dab	a9 00		lda #$00			lda 	#0
.9dad	f5 68		sbc $68,x			sbc 	NSMantissa2,x
.9daf	95 68		sta $68,x			sta 	NSMantissa2,x
.9db1	a9 00		lda #$00			lda 	#0
.9db3	f5 70		sbc $70,x			sbc 	NSMantissa3,x
.9db5	95 70		sta $70,x			sta 	NSMantissa3,x
.9db7	60		rts				rts
.9db8					NSMShiftUpTwo:
.9db8	b5 58		lda $58,x			lda 	NSMantissa0,x
.9dba	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9dbc	b5 60		lda $60,x			lda 	NSMantissa1,x
.9dbe	95 62		sta $62,x			sta 	NSMantissa1+2,x
.9dc0	b5 68		lda $68,x			lda 	NSMantissa2,x
.9dc2	95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.9dc4	b5 70		lda $70,x			lda 	NSMantissa3,x
.9dc6	95 72		sta $72,x			sta 	NSMantissa3+2,x
.9dc8	b5 78		lda $78,x			lda 	NSExponent,x
.9dca	95 7a		sta $7a,x			sta 	NSExponent+2,x
.9dcc	b5 50		lda $50,x			lda 	NSStatus,x
.9dce	95 52		sta $52,x			sta 	NSStatus+2,x
.9dd0	60		rts				rts
.9dd1					NSMSetZeroMantissaOnly:
.9dd1	a9 00		lda #$00			lda 	#0
.9dd3	80 06		bra $9ddb			bra 	NSMSetMantissa
.9dd5					NSMSetZero:
.9dd5	a9 00		lda #$00			lda 	#0
.9dd7					NSMSetByte:
.9dd7	74 78		stz $78,x			stz 	NSExponent,x 				; zero exponent, as integer.
.9dd9	74 50		stz $50,x			stz 	NSStatus,x 					; status zero (integer)
.9ddb					NSMSetMantissa:
.9ddb	95 58		sta $58,x			sta 	NSMantissa0,x 				; mantissa
.9ddd	74 60		stz $60,x			stz 	NSMantissa1,x
.9ddf	74 68		stz $68,x			stz 	NSMantissa2,x
.9de1	74 70		stz $70,x			stz 	NSMantissa3,x
.9de3	60		rts				rts
.9de4					NSMShiftLeft:
.9de4	18		clc				clc
.9de5					NSMRotateLeft:
.9de5	36 58		rol $58,x			rol 	NSMantissa0,x
.9de7	36 60		rol $60,x			rol		NSMantissa1,x
.9de9	36 68		rol $68,x			rol		NSMantissa2,x
.9deb	36 70		rol $70,x			rol		NSMantissa3,x
.9ded	60		rts				rts
.9dee					NSMShiftRight:
.9dee	56 70		lsr $70,x			lsr 	NSMantissa3,x
.9df0	76 68		ror $68,x			ror		NSMantissa2,x
.9df2	76 60		ror $60,x			ror		NSMantissa1,x
.9df4	76 58		ror $58,x			ror		NSMantissa0,x
.9df6	60		rts				rts
.9df7					NSMIsZero:
.9df7	b5 70		lda $70,x			lda 	NSMantissa3,x
.9df9	15 68		ora $68,x			ora		NSMantissa2,x
.9dfb	15 60		ora $60,x			ora		NSMantissa1,x
.9dfd	15 58		ora $58,x			ora		NSMantissa0,x
.9dff	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.asm

.9e00					TickHandler:
.9e00	5a		phy				phy 								; need to preserve Y
.9e01	20 1b 80	jsr $801b			jsr 	SNDUpdate 					; update sound
.9e04	7a		ply				ply
.9e05	60		rts				rts
.05af					LastTick:
>05af							.fill 		1

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/asmcore.asm

.9e06					Assemble_ora:
.9e06	20 87 80	jsr $8087		jsr	AssembleGroup1
>9e09	01					.byte $01
.9e0a					Assemble_and:
.9e0a	20 87 80	jsr $8087		jsr	AssembleGroup1
>9e0d	21					.byte $21
.9e0e					Assemble_eor:
.9e0e	20 87 80	jsr $8087		jsr	AssembleGroup1
>9e11	41					.byte $41
.9e12					Assemble_adc:
.9e12	20 87 80	jsr $8087		jsr	AssembleGroup1
>9e15	61					.byte $61
.9e16					Assemble_sta:
.9e16	20 87 80	jsr $8087		jsr	AssembleGroup1
>9e19	81					.byte $81
.9e1a					Assemble_lda:
.9e1a	20 87 80	jsr $8087		jsr	AssembleGroup1
>9e1d	a1					.byte $a1
.9e1e					Assemble_cmp:
.9e1e	20 87 80	jsr $8087		jsr	AssembleGroup1
>9e21	c1					.byte $c1
.9e22					Assemble_sbc:
.9e22	20 87 80	jsr $8087		jsr	AssembleGroup1
>9e25	e1					.byte $e1
.9e26					Assemble_asl:
.9e26	20 8e 80	jsr $808e		jsr	AssembleGroup2
>9e29	02					.byte $02
>9e2a	75					.byte $75
.9e2b					Assemble_rol:
.9e2b	20 8e 80	jsr $808e		jsr	AssembleGroup2
>9e2e	22					.byte $22
>9e2f	75					.byte $75
.9e30					Assemble_lsr:
.9e30	20 8e 80	jsr $808e		jsr	AssembleGroup2
>9e33	42					.byte $42
>9e34	75					.byte $75
.9e35					Assemble_ror:
.9e35	20 8e 80	jsr $808e		jsr	AssembleGroup2
>9e38	62					.byte $62
>9e39	75					.byte $75
.9e3a					Assemble_stx:
.9e3a	20 8e 80	jsr $808e		jsr	AssembleGroup2
>9e3d	82					.byte $82
>9e3e	50					.byte $50
.9e3f					Assemble_ldx:
.9e3f	20 8e 80	jsr $808e		jsr	AssembleGroup2
>9e42	a2					.byte $a2
>9e43	d0					.byte $d0
.9e44					Assemble_dec:
.9e44	20 8e 80	jsr $808e		jsr	AssembleGroup2
>9e47	c2					.byte $c2
>9e48	55					.byte $55
.9e49					Assemble_inc:
.9e49	20 8e 80	jsr $808e		jsr	AssembleGroup2
>9e4c	e2					.byte $e2
>9e4d	55					.byte $55
.9e4e					Assemble_stz:
.9e4e	20 8e 80	jsr $808e		jsr	AssembleGroup2
>9e51	60					.byte $60
>9e52	44					.byte $44
.9e53					Assemble_bit:
.9e53	20 8e 80	jsr $808e		jsr	AssembleGroup2
>9e56	20					.byte $20
>9e57	55					.byte $55
.9e58					Assemble_sty:
.9e58	20 8e 80	jsr $808e		jsr	AssembleGroup2
>9e5b	80					.byte $80
>9e5c	54					.byte $54
.9e5d					Assemble_ldy:
.9e5d	20 8e 80	jsr $808e		jsr	AssembleGroup2
>9e60	a0					.byte $a0
>9e61	d5					.byte $d5
.9e62					Assemble_cpy:
.9e62	20 8e 80	jsr $808e		jsr	AssembleGroup2
>9e65	c0					.byte $c0
>9e66	d4					.byte $d4
.9e67					Assemble_cpx:
.9e67	20 8e 80	jsr $808e		jsr	AssembleGroup2
>9e6a	e0					.byte $e0
>9e6b	d0					.byte $d0
.9e6c					Assemble_tsb:
.9e6c	20 8e 80	jsr $808e		jsr	AssembleGroup2
>9e6f	00					.byte $00
>9e70	50					.byte $50
.9e71					Assemble_trb:
.9e71	20 8e 80	jsr $808e		jsr	AssembleGroup2
>9e74	10					.byte $10
>9e75	50					.byte $50
.9e76					Assemble_jsr:
.9e76	20 8e 80	jsr $808e		jsr	AssembleGroup2
>9e79	14					.byte $14
>9e7a	10					.byte $10
.9e7b					Assemble_jmp:
.9e7b	20 8e 80	jsr $808e		jsr	AssembleGroup2
>9e7e	40					.byte $40
>9e7f	10					.byte $10
.9e80					Assemble_bpl:
.9e80	20 df 80	jsr $80df		jsr	AssembleGroup3
>9e83	10					.byte $10
.9e84					Assemble_bmi:
.9e84	20 df 80	jsr $80df		jsr	AssembleGroup3
>9e87	30					.byte $30
.9e88					Assemble_bvc:
.9e88	20 df 80	jsr $80df		jsr	AssembleGroup3
>9e8b	50					.byte $50
.9e8c					Assemble_bvs:
.9e8c	20 df 80	jsr $80df		jsr	AssembleGroup3
>9e8f	70					.byte $70
.9e90					Assemble_bcc:
.9e90	20 df 80	jsr $80df		jsr	AssembleGroup3
>9e93	90					.byte $90
.9e94					Assemble_bcs:
.9e94	20 df 80	jsr $80df		jsr	AssembleGroup3
>9e97	b0					.byte $b0
.9e98					Assemble_bne:
.9e98	20 df 80	jsr $80df		jsr	AssembleGroup3
>9e9b	d0					.byte $d0
.9e9c					Assemble_beq:
.9e9c	20 df 80	jsr $80df		jsr	AssembleGroup3
>9e9f	f0					.byte $f0
.9ea0					Assemble_bra:
.9ea0	20 df 80	jsr $80df		jsr	AssembleGroup3
>9ea3	80					.byte $80
.9ea4					Assemble_brk:
.9ea4	20 13 81	jsr $8113		jsr	AssembleGroup4
>9ea7	00					.byte $00
.9ea8					Assemble_php:
.9ea8	20 13 81	jsr $8113		jsr	AssembleGroup4
>9eab	08					.byte $08
.9eac					Assemble_clc:
.9eac	20 13 81	jsr $8113		jsr	AssembleGroup4
>9eaf	18					.byte $18
.9eb0					Assemble_plp:
.9eb0	20 13 81	jsr $8113		jsr	AssembleGroup4
>9eb3	28					.byte $28
.9eb4					Assemble_sec:
.9eb4	20 13 81	jsr $8113		jsr	AssembleGroup4
>9eb7	38					.byte $38
.9eb8					Assemble_rti:
.9eb8	20 13 81	jsr $8113		jsr	AssembleGroup4
>9ebb	40					.byte $40
.9ebc					Assemble_pha:
.9ebc	20 13 81	jsr $8113		jsr	AssembleGroup4
>9ebf	48					.byte $48
.9ec0					Assemble_cli:
.9ec0	20 13 81	jsr $8113		jsr	AssembleGroup4
>9ec3	58					.byte $58
.9ec4					Assemble_phy:
.9ec4	20 13 81	jsr $8113		jsr	AssembleGroup4
>9ec7	5a					.byte $5a
.9ec8					Assemble_rts:
.9ec8	20 13 81	jsr $8113		jsr	AssembleGroup4
>9ecb	60					.byte $60
.9ecc					Assemble_pla:
.9ecc	20 13 81	jsr $8113		jsr	AssembleGroup4
>9ecf	68					.byte $68
.9ed0					Assemble_sei:
.9ed0	20 13 81	jsr $8113		jsr	AssembleGroup4
>9ed3	78					.byte $78
.9ed4					Assemble_ply:
.9ed4	20 13 81	jsr $8113		jsr	AssembleGroup4
>9ed7	7a					.byte $7a
.9ed8					Assemble_dey:
.9ed8	20 13 81	jsr $8113		jsr	AssembleGroup4
>9edb	88					.byte $88
.9edc					Assemble_txa:
.9edc	20 13 81	jsr $8113		jsr	AssembleGroup4
>9edf	8a					.byte $8a
.9ee0					Assemble_tya:
.9ee0	20 13 81	jsr $8113		jsr	AssembleGroup4
>9ee3	98					.byte $98
.9ee4					Assemble_txs:
.9ee4	20 13 81	jsr $8113		jsr	AssembleGroup4
>9ee7	9a					.byte $9a
.9ee8					Assemble_tay:
.9ee8	20 13 81	jsr $8113		jsr	AssembleGroup4
>9eeb	a8					.byte $a8
.9eec					Assemble_tax:
.9eec	20 13 81	jsr $8113		jsr	AssembleGroup4
>9eef	aa					.byte $aa
.9ef0					Assemble_clv:
.9ef0	20 13 81	jsr $8113		jsr	AssembleGroup4
>9ef3	b8					.byte $b8
.9ef4					Assemble_tsx:
.9ef4	20 13 81	jsr $8113		jsr	AssembleGroup4
>9ef7	ba					.byte $ba
.9ef8					Assemble_iny:
.9ef8	20 13 81	jsr $8113		jsr	AssembleGroup4
>9efb	c8					.byte $c8
.9efc					Assemble_dex:
.9efc	20 13 81	jsr $8113		jsr	AssembleGroup4
>9eff	ca					.byte $ca
.9f00					Assemble_cld:
.9f00	20 13 81	jsr $8113		jsr	AssembleGroup4
>9f03	d8					.byte $d8
.9f04					Assemble_phx:
.9f04	20 13 81	jsr $8113		jsr	AssembleGroup4
>9f07	da					.byte $da
.9f08					Assemble_stp:
.9f08	20 13 81	jsr $8113		jsr	AssembleGroup4
>9f0b	db					.byte $db
.9f0c					Assemble_inx:
.9f0c	20 13 81	jsr $8113		jsr	AssembleGroup4
>9f0f	e8					.byte $e8
.9f10					Assemble_nop:
.9f10	20 13 81	jsr $8113		jsr	AssembleGroup4
>9f13	ea					.byte $ea
.9f14					Assemble_sed:
.9f14	20 13 81	jsr $8113		jsr	AssembleGroup4
>9f17	f8					.byte $f8
.9f18					Assemble_plx:
.9f18	20 13 81	jsr $8113		jsr	AssembleGroup4
>9f1b	fa					.byte $fa

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/constants.asm

.9f1c					DecimalScalarTable:
>9f1c	66 66 66 66				.dword $66666666 ; 0.1
>9f20	de					.byte $de
>9f21	1f 85 eb 51				.dword $51eb851f ; 0.01
>9f25	db					.byte $db
>9f26	4c 37 89 41				.dword $4189374c ; 0.001
>9f2a	d8					.byte $d8
>9f2b	ac 8b db 68				.dword $68db8bac ; 0.0001
>9f2f	d4					.byte $d4
>9f30	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>9f34	d1					.byte $d1
>9f35	83 de 1b 43				.dword $431bde83 ; 1e-06
>9f39	ce					.byte $ce
>9f3a	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>9f3e	ca					.byte $ca
>9f3f	89 3b e6 55				.dword $55e63b89 ; 1e-08
>9f43	c7					.byte $c7
>9f44	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>9f48	c4					.byte $c4
>9f49	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>9f4d	c0					.byte $c0
>9f4e	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>9f52	bd					.byte $bd

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.asm

.9f53					SyntaxError:
.9f53	a9 02		lda #$02		lda	#2
.9f55	4c c8 8e	jmp $8ec8		jmp	ErrorHandler
.9f58					RangeError:
.9f58	a9 04		lda #$04		lda	#4
.9f5a	4c c8 8e	jmp $8ec8		jmp	ErrorHandler
.9f5d					TypeError:
.9f5d	a9 05		lda #$05		lda	#5
.9f5f	4c c8 8e	jmp $8ec8		jmp	ErrorHandler
.9f62					ArgumentError:
.9f62	a9 07		lda #$07		lda	#7
.9f64	4c c8 8e	jmp $8ec8		jmp	ErrorHandler
.9f67					NotDoneError:
.9f67	a9 0c		lda #$0c		lda	#12
.9f69	4c c8 8e	jmp $8ec8		jmp	ErrorHandler
.9f6c					ErrorText:
>9f6c	42 72 65 61 6b 00			.text	"Break",0
>9f72	53 79 6e 74 61 78 20 65			.text	"Syntax error",0
>9f7a	72 72 6f 72 00
>9f7f	44 69 76 69 73 69 6f 6e			.text	"Division by zero",0
>9f87	20 62 79 20 7a 65 72 6f 00
>9f90	4f 75 74 20 6f 66 20 52			.text	"Out of Range",0
>9f98	61 6e 67 65 00
>9f9d	54 79 70 65 20 6d 69 73			.text	"Type mismatch",0
>9fa5	6d 61 74 63 68 00
>9fab	4f 75 74 20 6f 66 20 6d			.text	"Out of memory",0
>9fb3	65 6d 6f 72 79 00
>9fb9	49 6c 6c 65 67 61 6c 20			.text	"Illegal argument",0
>9fc1	61 72 67 75 6d 65 6e 74 00
>9fca	53 74 6f 70 00				.text	"Stop",0
>9fcf	53 74 72 69 6e 67 20 74			.text	"String too long",0
>9fd7	6f 6f 20 6c 6f 6e 67 00
>9fdf	41 73 73 65 72 74 69 6f			.text	"Assertion failed",0
>9fe7	6e 20 66 61 69 6c 65 64 00
>9ff0	4f 75 74 20 6f 66 20 64			.text	"Out of data",0
>9ff8	61 74 61 00
>9ffc	55 6e 69 6d 70 6c 65 6d			.text	"Unimplemented",0
>a004	65 6e 74 65 64 00
>a00a	4e 6f 20 73 75 63 68 20			.text	"No such line number",0
>a012	6c 69 6e 65 20 6e 75 6d 62 65 72 00
>a01e	52 65 74 75 72 6e 20 77			.text	"Return without Gosub",0
>a026	69 74 68 6f 75 74 20 47 6f 73 75 62 00
>a033	55 6e 74 69 6c 20 77 69			.text	"Until without Repeat",0
>a03b	74 68 6f 75 74 20 52 65 70 65 61 74 00
>a048	57 65 6e 64 20 77 69 74			.text	"Wend without While",0
>a050	68 6f 75 74 20 57 68 69 6c 65 00
>a05b	4e 65 78 74 20 77 69 74			.text	"Next without For",0
>a063	68 6f 75 74 20 46 6f 72 00
>a06c	42 41 53 49 43 20 53 74			.text	"BASIC Stack full",0
>a074	61 63 6b 20 66 75 6c 6c 00
>a07d	4f 70 65 6e 20 53 74 72			.text	"Open Structure",0
>a085	75 63 74 75 72 65 00
>a08c	45 6e 64 50 72 6f 63 20			.text	"EndProc without call",0
>a094	77 69 74 68 6f 75 74 20 63 61 6c 6c 00
>a0a1	41 72 72 61 79 20 61 6c			.text	"Array already defined",0
>a0a9	72 65 61 64 79 20 64 65 66 69 6e 65 64 00
>a0b7	41 72 72 61 79 20 73 69			.text	"Array size",0
>a0bf	7a 65 00
>a0c2	42 61 64 20 61 72 72 61			.text	"Bad array index",0
>a0ca	79 20 69 6e 64 65 78 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/timestamp.asm

>a0d2	52 65 6c 65 61 73 65 20			.text "Release Alpha 6 (26-Nov-22). "
>a0da	41 6c 70 68 61 20 36 20 28 32 36 2d 4e 6f 76 2d
>a0ea	32 32 29 2e 20

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcommand.asm

.a0ef					RectangleCommand:
.a0ef	a9 44		lda #$44			lda 	#GCMD_FrameRect				; frame rectangle
.a0f1	80 02		bra $a0f5			bra 	ShapeDrawCmd
.a0f3					CircleCommand:
.a0f3	a9 48		lda #$48			lda 	#GCMD_FrameCircle 				; framed circle
.a0f5					ShapeDrawCmd:
.a0f5	20 7f a1	jsr $a17f			jsr 	RunGraphicsCommand
.a0f8					ShapeDraw:
.a0f8	0d b1 05	ora $05b1			ora 	gxFillSolid  				; adjust AXY for solid fill.
.a0fb	4c 73 a1	jmp $a173			jmp 	ExecuteGraphicCommand	 	; and complete
.a0fe					SpriteCommand:
.a0fe	a2 00		ldx #$00			ldx 	#0
.a100	20 70 9d	jsr $9d70			jsr 	Evaluate8BitInteger 		; get image number.
.a103	5a		phy				phy
.a104	a9 0e		lda #$0e			lda 	#GCMD_SpriteUse 			; use that image.
.a106	a6 58		ldx $58				ldx 	NSMantissa0
.a108	e0 40		cpx #$40			cpx 	#64 						; 0-63 only
.a10a	b0 0d		bcs $a119			bcs 	_SCRange
.a10c	a0 ff		ldy #$ff			ldy 	#255
.a10e	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a111	a9 52		lda #$52			lda 	#GCMD_SpriteMove
.a113	7a		ply				ply
.a114	20 7f a1	jsr $a17f			jsr 	RunGraphicsCommand
.a117	80 5a		bra $a173			bra 	ExecuteGraphicCommand
.a119					_SCRange:
.a119	4c 58 9f	jmp $9f58			jmp 	RangeError
.a11c					ImageCommand:
.a11c	a2 00		ldx #$00			ldx 	#0
.a11e	20 70 9d	jsr $9d70			jsr 	Evaluate8BitInteger 		; get image number.
.a121	20 7f a1	jsr $a17f			jsr 	RunGraphicsCommand
.a124					ImageRunDraw:
.a124	09 40		ora #$40			ora 	#GCMD_Move					; move cursor
.a126	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a129	ad b7 05	lda $05b7			lda 	gxDrawScale
.a12c	0a		asl a				asl 	a
.a12d	0a		asl a				asl 	a
.a12e	0a		asl a				asl 	a
.a12f	a8		tay				tay
.a130	a9 0c		lda #$0c			lda 	#GCMD_DrawSprite 			; image drawing
.a132	a6 58		ldx $58				ldx 	NSMantissa0
.a134	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a137	60		rts				rts
.a138					TextCommand:
.a138	a2 00		ldx #$00			ldx 	#0
.a13a	20 2d 9d	jsr $9d2d			jsr 	EvaluateString 				; get text
.a13d	20 7f a1	jsr $a17f			jsr 	RunGraphicsCommand
.a140					TextRunDraw:
.a140	09 40		ora #$40			ora 	#GCMD_Move 					; move cursor
.a142	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a145	a0 00		ldy #$00			ldy 	#0
.a147					_IRDLoop:
.a147	a5 60		lda $60				lda 	NSMantissa1 				; access character
.a149	85 37		sta $37				sta 	zTemp0+1
.a14b	a5 58		lda $58				lda 	NSMantissa0
.a14d	85 36		sta $36				sta 	zTemp0
.a14f	b1 36		lda ($36),y			lda 	(zTemp0),y
.a151	f0 13		beq $a166			beq 	_IRDExit
.a153	5a		phy				phy									; save string pos
.a154	48		pha				pha 								; save char
.a155	ad b7 05	lda $05b7			lda 	gxDrawScale 				; get scale
.a158	0a		asl a				asl 	a
.a159	0a		asl a				asl 	a
.a15a	0a		asl a				asl 	a
.a15b	a8		tay				tay
.a15c	a9 0a		lda #$0a			lda 	#GCMD_DrawFont 				; char drawing
.a15e	fa		plx				plx 								; char to draw
.a15f	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a162	7a		ply				ply 								; restore string pos
.a163	c8		iny				iny
.a164	90 e1		bcc $a147			bcc 	_IRDLoop 					; go back if no error.
.a166					_IRDExit:
.a166	60		rts				rts
.a167					PlotCommand:
.a167	a9 50		lda #$50			lda 	#GCMD_Plot 					; command ID to use
.a169	20 7f a1	jsr $a17f			jsr 	RunGraphicsCommand
.a16c	80 05		bra $a173			bra 	ExecuteGraphicCommand
.a16e					LineCommand:
.a16e	a9 42		lda #$42			lda 	#GCMD_Line 						; command ID to use
.a170	20 7f a1	jsr $a17f			jsr 	RunGraphicsCommand
.a173					ExecuteGraphicCommand:
.a173	0d b0 05	ora $05b0			ora 	gxCommandID 				; make a full command
.a176	20 15 80	jsr $8015			jsr 	GXGraphicDraw 				; draw it and exit
.a179	b0 01		bcs $a17c			bcs 	_EGCError
.a17b	60		rts				rts
.a17c					_EGCError:
.a17c	4c 53 9f	jmp $9f53			jmp 	SyntaxError
.a17f					RunGraphicsCommand:
.a17f	8d b0 05	sta $05b0			sta 	gxCommandID					; save TODO graphics command.
.a182	68		pla				pla 								; pop handler address
.a183	fa		plx				plx
.a184	1a		inc a				inc 	a
.a185	d0 01		bne $a188			bne 	_RGINoCarry
.a187	e8		inx				inx
.a188					_RGINoCarry:
.a188	8d b5 05	sta $05b5			sta 	GXHandler
.a18b	8e b6 05	stx $05b6			stx 	GXHandler+1
.a18e					_RGICommandLoop:
.a18e	b1 30		lda ($30),y			lda 	(codePtr),y
.a190	c8		iny				iny
.a191	c9 ce		cmp #$ce			cmp 	#KWD_TO						; is it TO x,y
.a193	f0 53		beq $a1e8			beq 	_RGI_To
.a195	c9 ba		cmp #$ba			cmp 	#KWD_HERE 					; do it here.
.a197	f0 55		beq $a1ee			beq 	_RGI_Here
.a199	c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL or : , exit
.a19b	f0 3d		beq $a1da			beq 	_RGI_Exit
.a19d	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.a19f	f0 39		beq $a1da			beq 	_RGI_Exit
.a1a1	c9 c2		cmp #$c2			cmp 	#KWD_OUTLINE 				; solid or outline
.a1a3	f0 3e		beq $a1e3			beq 	_RGI_Frame
.a1a5	c9 ca		cmp #$ca			cmp 	#KWD_SOLID
.a1a7	f0 33		beq $a1dc			beq 	_RGI_Solid
.a1a9	c9 ab		cmp #$ab			cmp 	#KWD_BY 					; by offset
.a1ab	f0 4b		beq $a1f8			beq 	_RGI_By
.a1ad	c9 b6		cmp #$b6			cmp 	#KWD_FROM 					; from
.a1af	f0 17		beq $a1c8			beq 	_RGI_Move2
.a1b1	c9 b3		cmp #$b3			cmp 	#KWD_DIM 					; dim (set scale)
.a1b3	f0 62		beq $a217			beq 	_RGI_Dim
.a1b5	c9 b1		cmp #$b1			cmp 	#KWD_COLOUR 				; colour or Color
.a1b7	f0 74		beq $a22d			beq 	_RGI_Colour
.a1b9	c9 b0		cmp #$b0			cmp 	#KWD_COLOR
.a1bb	f0 70		beq $a22d			beq 	_RGI_Colour
.a1bd	ae b0 05	ldx $05b0			ldx 	gxCommandID
.a1c0	e0 52		cpx #$52			cpx 	#GCMD_SpriteMove 			; if not sprite
.a1c2	d0 03		bne $a1c7			bne 	_RGI_Move 					; move
.a1c4	4c 55 a2	jmp $a255			jmp		_RGI_SpriteInstructions
.a1c7					_RGI_Move:
.a1c7	88		dey				dey 								; unpick get.
.a1c8					_RGI_Move2:
.a1c8	20 7b a2	jsr $a27b			jsr 	GCGetCoordinatePair 		; move to here
.a1cb	20 a2 a2	jsr $a2a2			jsr 	GCCopyPairToStore 			; save
.a1ce	5a		phy				phy
.a1cf	20 98 a2	jsr $a298			jsr 	GCLoadAXY 					; load in
.a1d2	09 40		ora #$40			ora 	#GCMD_Move 					; move there
.a1d4	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a1d7	7a		ply				ply
.a1d8	80 b4		bra $a18e			bra 	_RGICommandLoop 			; and go round
.a1da					_RGI_Exit:
.a1da	88		dey				dey 								; unpick : / EOL
.a1db	60		rts				rts
.a1dc					_RGI_Solid:
.a1dc	a9 02		lda #$02			lda 	#2
.a1de	8d b1 05	sta $05b1			sta 	gxFillSolid
.a1e1	80 ab		bra $a18e			bra 	_RGICommandLoop
.a1e3					_RGI_Frame:
.a1e3	9c b1 05	stz $05b1			stz 	gxFillSolid
.a1e6	80 a6		bra $a18e			bra 	_RGICommandLoop
.a1e8					_RGI_To:
.a1e8	20 7b a2	jsr $a27b			jsr 	GCGetCoordinatePair 		; get coordinate pair into slot #1,#2
.a1eb	20 a2 a2	jsr $a2a2			jsr 	GCCopyPairToStore
.a1ee					_RGI_Here:
.a1ee	5a		phy				phy
.a1ef	20 98 a2	jsr $a298			jsr 	GCLoadAXY 					; load it into AXY
.a1f2	20 52 a2	jsr $a252			jsr 	_RGICallHandler 			; go do whatever it is.
.a1f5	7a		ply				ply
.a1f6	80 96		bra $a18e			bra 	_RGICommandLoop 			; and go round
.a1f8					_RGI_By:
.a1f8	20 88 a2	jsr $a288			jsr 	GCSignedCoordinatePair 		; get coordinate pair into slot #1,#2
.a1fb	18		clc				clc
.a1fc	a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.a1fe	6d b2 05	adc $05b2			adc 	gxxPos
.a201	8d b2 05	sta $05b2			sta 	gxXPos
.a204	a5 61		lda $61				lda 	NSMantissa1+1
.a206	6d b3 05	adc $05b3			adc 	gxxPos+1
.a209	8d b3 05	sta $05b3			sta 	gxXPos+1
.a20c	a5 5a		lda $5a				lda 	NSMantissa0+2
.a20e	18		clc				clc
.a20f	6d b4 05	adc $05b4			adc 	gxYPos
.a212	8d b4 05	sta $05b4			sta 	gxYPos
.a215	80 d7		bra $a1ee			bra 	_RGI_Here
.a217					_RGI_Dim:
.a217	a2 01		ldx #$01			ldx	 	#1
.a219	20 70 9d	jsr $9d70			jsr 	Evaluate8BitInteger
.a21c	a5 59		lda $59				lda 	NSMantissa0+1
.a21e	c9 00		cmp #$00			cmp 	#0
.a220	f0 2d		beq $a24f			beq 	_RGIRange
.a222	c9 09		cmp #$09			cmp 	#8+1
.a224	b0 29		bcs $a24f			bcs		_RGIRange
.a226	3a		dec a				dec 	a
.a227	8d b7 05	sta $05b7			sta 	gxDrawScale
.a22a	4c 8e a1	jmp $a18e			jmp 	_RGICommandLoop
.a22d					_RGI_Colour:
.a22d	a2 01		ldx #$01			ldx 	#1 							; colour
.a22f	20 70 9d	jsr $9d70			jsr 	Evaluate8BitInteger
.a232	a2 02		ldx #$02			ldx 	#2 							; default zero for 2nd parameter
.a234	20 d5 9d	jsr $9dd5			jsr 	NSMSetZero
.a237	b1 30		lda ($30),y			lda 	(codePtr),y
.a239	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; check , => mode.
.a23b	d0 04		bne $a241			bne 	_RGICDefaultMode
.a23d	c8		iny				iny
.a23e	20 70 9d	jsr $9d70			jsr 	Evaluate8BitInteger
.a241					_RGICDefaultMode:
.a241	5a		phy				phy
.a242	a9 08		lda #$08			lda 	#GCMD_Colour 				; set colour.
.a244	a6 59		ldx $59				ldx 	NSMantissa0+1
.a246	a4 5a		ldy $5a				ldy 	NSMantissa0+2
.a248	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a24b	7a		ply				ply
.a24c	4c 8e a1	jmp $a18e			jmp 	_RGICommandLoop 			; and go round
.a24f					_RGIRange:
.a24f	4c 58 9f	jmp $9f58			jmp 	RangeError
.a252					_RGICallHandler:
.a252	6c b5 05	jmp ($05b5)			jmp 	(GXHandler)
.a255					_RGI_SpriteInstructions:
.a255	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a257	f0 07		beq $a260			beq 	_RGISpriteOff
.a259	c9 bb		cmp #$bb			cmp 	#KWD_IMAGE
.a25b	f0 13		beq $a270			beq 	_RGISetImage
.a25d	4c c7 a1	jmp $a1c7			jmp 	_RGI_Move
.a260					_RGISpriteOff:
.a260	5a		phy				phy
.a261	a0 01		ldy #$01			ldy 	#1
.a263	a2 00		ldx #$00			ldx 	#0
.a265					_RGIDoCommandLoop:
.a265	a9 10		lda #$10			lda 	#GCMD_SpriteImage
.a267	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a26a	7a		ply				ply
.a26b	b0 e2		bcs $a24f			bcs 	_RGIRange
.a26d	4c 8e a1	jmp $a18e			jmp 	_RGICommandLoop
.a270					_RGISetImage:
.a270	a2 01		ldx #$01			ldx 	#1
.a272	20 70 9d	jsr $9d70			jsr 	Evaluate8BitInteger
.a275	5a		phy				phy
.a276	aa		tax				tax
.a277	a0 00		ldy #$00			ldy 	#0
.a279	80 ea		bra $a265			bra 	_RGIDoCommandLoop
.a27b					GCGetCoordinatePair:
.a27b	a2 01		ldx #$01			ldx 	#1
.a27d	20 55 9d	jsr $9d55			jsr 	Evaluate16BitInteger
.a280	20 b7 8e	jsr $8eb7			jsr 	CheckComma
.a283	e8		inx				inx
.a284	20 55 9d	jsr $9d55			jsr 	Evaluate16BitInteger
.a287	60		rts				rts
.a288					GCSignedCoordinatePair:
.a288	a2 01		ldx #$01			ldx 	#1
.a28a	20 5f 9d	jsr $9d5f			jsr 	Evaluate16BitIntegerSigned
.a28d	20 b7 8e	jsr $8eb7			jsr 	CheckComma
.a290	e8		inx				inx
.a291	20 5f 9d	jsr $9d5f			jsr 	Evaluate16BitIntegerSigned
.a294	60		rts				rts
.a295					_GCCPRange:
.a295	4c 58 9f	jmp $9f58			jmp 	RangeError
.a298					GCLoadAXY:
.a298	ad b3 05	lda $05b3			lda 	gxXPos+1
.a29b	ae b2 05	ldx $05b2			ldx 	gxXPos
.a29e	ac b4 05	ldy $05b4			ldy 	gxYPos
.a2a1	60		rts				rts
.a2a2					GCCopyPairToStore:
.a2a2	a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.a2a4	8d b2 05	sta $05b2			sta 	gxXPos
.a2a7	a5 61		lda $61				lda 	NSMantissa1+1
.a2a9	8d b3 05	sta $05b3			sta 	gxXPos+1
.a2ac	a5 5a		lda $5a				lda 	NSMantissa0+2
.a2ae	8d b4 05	sta $05b4			sta 	gxYPos
.a2b1	60		rts				rts
.05b0					gxCommandID:
>05b0							.fill 	1
.05b1					gxFillSolid:
>05b1							.fill 	1
.05b2					gxXPos:
>05b2							.fill 	2
.05b4					gxYPos:
>05b4							.fill 	1
.05b5					gxHandler:
>05b5							.fill 	2
.05b7					gxDrawScale:
>05b7							.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcontrol.asm

.a2b2					BitmapCtrl:
.a2b2	b1 30		lda ($30),y			lda 	(codePtr),y
.a2b4	c8		iny				iny
.a2b5	a2 01		ldx #$01			ldx 	#1
.a2b7	c9 c1		cmp #$c1			cmp 	#KWD_ON
.a2b9	f0 11		beq $a2cc			beq 	BitmapSwitch
.a2bb	ca		dex				dex
.a2bc	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a2be	f0 0c		beq $a2cc			beq 	BitmapSwitch
.a2c0	20 70 9d	jsr $9d70			jsr 	Evaluate8BitInteger 		; get the colour
.a2c3	5a		phy				phy
.a2c4	aa		tax				tax
.a2c5	a9 06		lda #$06			lda 	#GCMD_Clear					; clear to that colour
.a2c7	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a2ca	7a		ply				ply
.a2cb	60		rts				rts
.a2cc					BitmapSwitch:
.a2cc	5a		phy				phy
.a2cd	a0 00		ldy #$00			ldy 	#0 							; gfx 1,on/off,0
.a2cf	a9 02		lda #$02			lda 	#GCMD_BitmapCtl
.a2d1	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a2d4	a9 08		lda #$08			lda 	#GCMD_Colour				; set colour to $FF
.a2d6	a0 00		ldy #$00			ldy 	#0
.a2d8	a2 ff		ldx #$ff			ldx 	#$FF
.a2da	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a2dd	9c b1 05	stz $05b1			stz 	gxFillSolid
.a2e0	9c b2 05	stz $05b2			stz 	gxXPos
.a2e3	9c b3 05	stz $05b3			stz 	gxXPos+1
.a2e6	9c b4 05	stz $05b4			stz 	gxYPos
.a2e9	9c b7 05	stz $05b7			stz 	gxDrawScale
.a2ec	a9 40		lda #$40			lda 	#GCMD_Move 						; home cursor
.a2ee	a2 00		ldx #$00			ldx 	#0
.a2f0	a0 00		ldy #$00			ldy 	#0
.a2f2	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a2f5	7a		ply				ply
.a2f6	60		rts				rts
.a2f7					SpritesCtrl:
.a2f7	b1 30		lda ($30),y			lda 	(codePtr),y
.a2f9	c8		iny				iny
.a2fa	a2 01		ldx #$01			ldx 	#1
.a2fc	c9 c1		cmp #$c1			cmp 	#KWD_ON
.a2fe	f0 08		beq $a308			beq 	SpriteSwitch
.a300	ca		dex				dex
.a301	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a303	f0 03		beq $a308			beq 	SpriteSwitch
.a305	4c 53 9f	jmp $9f53			jmp 	SyntaxError
.a308					SpriteSwitch:
.a308	5a		phy				phy
.a309	a0 00		ldy #$00			ldy 	#0 							; gfx 2,on/off,0
.a30b	a9 04		lda #$04			lda 	#GCMD_SpriteCtl
.a30d	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a310	7a		ply				ply
.a311	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gfx.asm

.a312					GfxCommand:
.a312	a2 00		ldx #$00			ldx 	#0
.a314	20 70 9d	jsr $9d70			jsr 	Evaluate8BitInteger 		; command
.a317	20 b7 8e	jsr $8eb7			jsr 	CheckComma
.a31a	e8		inx				inx
.a31b	20 55 9d	jsr $9d55			jsr 	Evaluate16BitInteger 		; X
.a31e	20 b7 8e	jsr $8eb7			jsr 	CheckComma
.a321	e8		inx				inx
.a322	20 70 9d	jsr $9d70			jsr 	Evaluate8BitInteger 		; Y
.a325	a5 61		lda $61				lda 	NSMantissa1+1  				; shift bit 0 of X into CS, should now be zero
.a327	4a		lsr a				lsr 	a
.a328	d0 12		bne $a33c			bne 	_GfxError
.a32a	26 58		rol $58				rol 	NSMantissa0 				; rotate into command
.a32c	b0 0e		bcs $a33c			bcs 	_GfxError 					; bit 7 should have been zero
.a32e	5a		phy				phy 								; save pos
.a32f	a5 58		lda $58				lda 	NSMantissa0 				; do the command
.a331	a6 59		ldx $59				ldx 	NSMantissa0+1
.a333	a4 5a		ldy $5a				ldy 	NSMantissa0+2
.a335	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a338	b0 02		bcs $a33c			bcs 	_GfxError
.a33a	7a		ply				ply 								; restore pos and exit.
.a33b	60		rts				rts
.a33c					_GfxError:
.a33c	4c 58 9f	jmp $9f58			jmp 	RangeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/hit.asm

.a33f					UnaryHit:
.a33f	fa		plx				plx
.a340	a9 36		lda #$36			lda 	#zTemp0
.a342	20 70 9d	jsr $9d70			jsr 	Evaluate8BitInteger 		; get sprite number 0
.a345	20 b7 8e	jsr $8eb7			jsr 	CheckComma
.a348	e8		inx				inx
.a349	20 70 9d	jsr $9d70			jsr 	Evaluate8BitInteger 		; get sprite number 1
.a34c	20 af 8e	jsr $8eaf			jsr		CheckRightBracket
.a34f	ca		dex				dex 								; fix back up again.
.a350	da		phx				phx 								; save X/Y
.a351	5a		phy				phy
.a352	b4 59		ldy $59,x			ldy 	NSMantissa0+1,x 			; get the sprite numbers into X/Y
.a354	b5 58		lda $58,x			lda 	NSMantissa0,x
.a356	aa		tax				tax
.a357	a9 12		lda #$12			lda 	#GCMD_SpriteCollide 		; command check collision.
.a359	20 15 80	jsr $8015			jsr 	GXGraphicDraw 				; calculate result
.a35c	1a		inc a				inc 	a 							; so 255 (fail) -> 0, otherwise 1,2,3,4 pixels etc.
.a35d	7a		ply				ply 								; restore XY
.a35e	fa		plx				plx
.a35f	20 d7 9d	jsr $9dd7			jsr 	NSMSetByte 					; return the hit result
.a362	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/palette.asm

.a363					PaletteCommand:
.a363	a2 00		ldx #$00			ldx 	#0
.a365	20 70 9d	jsr $9d70			jsr 	Evaluate8BitInteger 		; colour
.a368	20 b7 8e	jsr $8eb7			jsr 	CheckComma
.a36b	e8		inx				inx
.a36c	20 55 9d	jsr $9d55			jsr 	Evaluate16BitInteger 		; r
.a36f	20 b7 8e	jsr $8eb7			jsr 	CheckComma
.a372	e8		inx				inx
.a373	20 70 9d	jsr $9d70			jsr 	Evaluate8BitInteger 		; g
.a376	20 b7 8e	jsr $8eb7			jsr 	CheckComma
.a379	e8		inx				inx
.a37a	20 70 9d	jsr $9d70			jsr 	Evaluate8BitInteger 		; b
.a37d	a5 58		lda $58				lda 	NSMantissa0 				; get colour #
.a37f	85 36		sta $36				sta 	zTemp0
.a381	a9 34		lda #$34			lda 	#$D0 >> 2 					; MSB = D0/4
.a383	85 37		sta $37				sta 	zTemp0+1
.a385	06 36		asl $36				asl 	zTemp0 						; zTemp = $D000+Colour x 4
.a387	26 37		rol $37				rol	 	zTemp0+1
.a389	06 36		asl $36				asl 	zTemp0
.a38b	26 37		rol $37				rol	 	zTemp0+1
.a38d	a9 01		lda #$01			lda 	#1 							; I/O Page 2
.a38f	85 01		sta $01				sta 	1
.a391	5a		phy				phy
.a392	a5 5b		lda $5b				lda 	NSMantissa0+3 				; fix to r,g,b
.a394	92 36		sta ($36)			sta 	(zTemp0)
.a396	a0 01		ldy #$01			ldy 	#1
.a398	a5 5a		lda $5a				lda 	NSMantissa0+2
.a39a	91 36		sta ($36),y			sta 	(zTemp0),y
.a39c	a5 59		lda $59				lda 	NSMantissa0+1
.a39e	c8		iny				iny
.a39f	91 36		sta ($36),y			sta 	(zTemp0),y
.a3a1	7a		ply				ply
.a3a2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/event.asm

.a3a3					UnaryEvent:
.a3a3	fa		plx				plx
.a3a4	20 51 a4	jsr $a451			jsr 	TimerToStackX 				; timer in +0
.a3a7	e8		inx				inx  								; put reference into +1
.a3a8	20 16 98	jsr $9816			jsr 	EvaluateTerm
.a3ab	b5 50		lda $50,x			lda 	NSStatus,x 					; check if is integer reference
.a3ad	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.a3af	d0 4c		bne $a3fd			bne 	_UEType
.a3b1	e8		inx				inx 								; put the step in +2
.a3b2	20 b7 8e	jsr $8eb7			jsr 	CheckComma
.a3b5	20 55 9d	jsr $9d55			jsr 	Evaluate16BitInteger
.a3b8	20 af 8e	jsr $8eaf			jsr 	CheckRightBracket
.a3bb	ca		dex				dex
.a3bc	ca		dex				dex
.a3bd	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy reference to zTemp0
.a3bf	85 36		sta $36				sta 	zTemp0
.a3c1	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.a3c3	85 37		sta $37				sta 	zTemp0+1
.a3c5	5a		phy				phy
.a3c6	a0 03		ldy #$03			ldy 	#3 							; check bit 7 of last bit, the packed sign bit
.a3c8	b1 36		lda ($36),y			lda 	(zTemp0),y
.a3ca	30 2d		bmi $a3f9			bmi 	_UEFalse 					; exit if signed.
.a3cc	a0 00		ldy #$00			ldy 	#0 							; has it timed out (24 bit)
.a3ce	b5 58		lda $58,x			lda 	NSMantissa0,x
.a3d0	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.a3d2	c8		iny				iny
.a3d3	b5 60		lda $60,x			lda 	NSMantissa1,x
.a3d5	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a3d7	c8		iny				iny
.a3d8	b5 68		lda $68,x			lda 	NSMantissa2,x
.a3da	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a3dc	90 1b		bcc $a3f9			bcc 	_UEFalse 					; no, return FALSE.
.a3de	18		clc				clc
.a3df	a0 00		ldy #$00			ldy 	#0 							; work out new value as timer() + step
.a3e1	b5 58		lda $58,x			lda 	NSMantissa0,x
.a3e3	75 5a		adc $5a,x			adc 	NSMantissa0+2,x
.a3e5	91 36		sta ($36),y			sta 	(zTemp0),y
.a3e7	c8		iny				iny
.a3e8	b5 60		lda $60,x			lda 	NSMantissa1,x
.a3ea	75 62		adc $62,x			adc 	NSMantissa1+2,x
.a3ec	91 36		sta ($36),y			sta 	(zTemp0),y
.a3ee	c8		iny				iny
.a3ef	b5 68		lda $68,x			lda 	NSMantissa2,x
.a3f1	75 6a		adc $6a,x			adc 	NSMantissa2+2,x
.a3f3	91 36		sta ($36),y			sta 	(zTemp0),y
.a3f5	7a		ply				ply
.a3f6	4c 35 8f	jmp $8f35			jmp 	ReturnTrue
.a3f9					_UEFalse:
.a3f9	7a		ply				ply 								; restore Y
.a3fa	4c 40 8f	jmp $8f40			jmp 	ReturnFalse 				; and return False
.a3fd					_UEType:
.a3fd	4c 5d 9f	jmp $9f5d			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/joy.asm

.a400					UnaryJoyX:
.a400	18		clc				clc
.a401	80 01		bra $a404			bra 	JoyMain
.a403					UnaryJoyY:
.a403	38		sec				sec
.a404					JoyMain:
.a404	fa		plx				plx 								; get pos
.a405	08		php				php 								; save carry (set for Y)
.a406	20 70 9d	jsr $9d70			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a409	20 af 8e	jsr $8eaf			jsr 	CheckRightBracket
.a40c	20 0f 80	jsr $800f			jsr 	EXTReadController 			; read the controller.
.a40f	28		plp				plp
.a410	90 02		bcc $a414			bcc 	_JMNoShift 					; if Y then shift bits 3,2 -> 1,0
.a412	4a		lsr a				lsr 	a
.a413	4a		lsr a				lsr 	a
.a414					_JMNoShift:
.a414	4a		lsr a				lsr 	a 							; if bit 0 set then right/down e.g. +1
.a415	b0 0a		bcs $a421			bcs 	_JMIsRight
.a417	4a		lsr a				lsr 	a 							; if bit 1 set then left/up e.g. -1
.a418	b0 04		bcs $a41e			bcs 	_JMIsLeft
.a41a	20 d5 9d	jsr $9dd5			jsr 	NSMSetZero 					; zero result
.a41d	60		rts				rts
.a41e					_JMIsLeft:
.a41e	4c 35 8f	jmp $8f35			jmp 	ReturnTrue
.a421					_JMIsRight:
.a421	a9 01		lda #$01			lda 	#1
.a423	20 d7 9d	jsr $9dd7			jsr 	NSMSetByte
.a426	60		rts				rts
.a427					UnaryJoyB:
.a427	fa		plx				plx 								; get pos
.a428	20 70 9d	jsr $9d70			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a42b	20 af 8e	jsr $8eaf			jsr 	CheckRightBracket
.a42e	20 0f 80	jsr $800f			jsr 	EXTReadController 			; read the controller.
.a431	4a		lsr a				lsr 	a
.a432	4a		lsr a				lsr 	a
.a433	4a		lsr a				lsr 	a
.a434	4a		lsr a				lsr 	a
.a435	29 01		and #$01			and 	#1
.a437	20 d7 9d	jsr $9dd7			jsr 	NSMSetByte
.a43a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/load.asm

.a43b					LoadCommand:
.a43b	20 b7 89	jsr $89b7			jsr 	NewProgram
.a43e	20 f6 82	jsr $82f6			jsr 	BackLoadProgram
.a441	4c 8e 83	jmp $838e			jmp 	WarmStart
.a444					GoCommand:
.a444	20 b7 89	jsr $89b7			jsr 	NewProgram
.a447	20 f6 82	jsr $82f6			jsr 	BackLoadProgram
.a44a	4c f3 8a	jmp $8af3			jmp 	CommandRun

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/timer.asm

.a44d					UnaryTimer:
.a44d	fa		plx				plx
.a44e	20 af 8e	jsr $8eaf			jsr 	CheckRightBracket
.a451					TimerToStackX:
.a451	20 d5 9d	jsr $9dd5			jsr 	NSMSetZero 					; zero result
.a454	64 01		stz $01				stz 	1 							; access I/O
.a456	ad 59 d6	lda $d659			lda 	$D659 						; copy timer in
.a459	95 58		sta $58,x			sta 	NSMantissa0,x
.a45b	ad 5a d6	lda $d65a			lda 	$D65A
.a45e	95 60		sta $60,x			sta 	NSMantissa1,x
.a460	ad 5b d6	lda $d65b			lda 	$D65B
.a463	95 68		sta $68,x			sta 	NSMantissa2,x
.a465	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/delete.asm

.a466					MemoryDeleteLine:
.a466	20 85 a4	jsr $a485			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a469	b2 30		lda ($30)			lda 	(codePtr) 					; size to delete => y
.a46b	a8		tay				tay
.a46c					_MDDLLoop:
.a46c	b1 30		lda ($30),y			lda 	(codePtr),y 				; copy down
.a46e	92 30		sta ($30)			sta 	(codePtr)
.a470	a5 30		lda $30				lda 	codePtr 					; check done the lot.
.a472	c5 3a		cmp $3a				cmp 	zTemp2
.a474	d0 07		bne $a47d			bne 	_MDLDLNext
.a476	a5 31		lda $31				lda 	codePtr+1
.a478	c5 3b		cmp $3b				cmp 	zTemp2+1
.a47a	d0 01		bne $a47d			bne 	_MDLDLNext
.a47c					_MDDLExit:
.a47c	60		rts				rts
.a47d					_MDLDLNext:
.a47d	e6 30		inc $30				inc 	codePtr						; next byte
.a47f	d0 eb		bne $a46c			bne 	_MDDLLoop
.a481	e6 31		inc $31				inc 	codePtr+1
.a483	80 e7		bra $a46c			bra 	_MDDLLoop
.a485					IMemoryFindEnd:
.a485	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a487	85 3a		sta $3a				sta 	0+zTemp2
.a489	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a48b	85 3b		sta $3b				sta 	1+zTemp2
.a48d					_MDLFELoop:
.a48d	b2 3a		lda ($3a)			lda 	(zTemp2)
.a48f	f0 0b		beq $a49c			beq 	_MDLFEExit
.a491	18		clc				clc
.a492	65 3a		adc $3a				adc 	zTemp2
.a494	85 3a		sta $3a				sta 	zTemp2
.a496	90 f5		bcc $a48d			bcc 	_MDLFELoop
.a498	e6 3b		inc $3b				inc 	zTemp2+1
.a49a	80 f1		bra $a48d			bra 	_MDLFELoop
.a49c					_MDLFEExit:
.a49c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/insert.asm

.a49d					MemoryInsertLine:
.a49d	08		php				php
.a49e	20 85 a4	jsr $a485			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a4a1	a5 3b		lda $3b				lda 	zTemp2+1 					; space ?
.a4a3	1a		inc a				inc 	a
.a4a4	c9 7f		cmp #$7f			cmp 	#(BasicEnd >> 8)-1
.a4a6	b0 36		bcs $a4de			bcs 	_MDLIError
.a4a8	28		plp				plp
.a4a9	90 08		bcc $a4b3			bcc 	_MDLIFound
.a4ab	a5 3a		lda $3a				lda 	zTemp2 						; if CS on entry append.
.a4ad	85 30		sta $30				sta 	codePtr
.a4af	a5 3b		lda $3b				lda 	zTemp2+1
.a4b1	85 31		sta $31				sta 	codePtr+1
.a4b3					_MDLIFound:
.a4b3	ad 2a 04	lda $042a			lda 	tokenOffset 				; insert gap in Y, the offset, e.g. length of the new line
.a4b6	a8		tay				tay
.a4b7					_MDLIInsert:
.a4b7	b2 3a		lda ($3a)			lda 	(zTemp2) 					; shift one byte up , at least one covers end case.
.a4b9	91 3a		sta ($3a),y			sta 	(zTemp2),y 					; work from top down.
.a4bb	a5 30		lda $30				lda 	codePtr 					; done insert point ?
.a4bd	c5 3a		cmp $3a				cmp 	zTemp2
.a4bf	d0 06		bne $a4c7			bne 	_MDLINext
.a4c1	a5 31		lda $31				lda 	codePtr+1
.a4c3	c5 3b		cmp $3b				cmp 	zTemp2+1
.a4c5	f0 0a		beq $a4d1			beq 	_MDLIHaveSpace
.a4c7					_MDLINext:
.a4c7	a5 3a		lda $3a				lda 	zTemp2 						; if no, keep zTemp2 going backwards
.a4c9	d0 02		bne $a4cd			bne 	_MDLINoBorrow
.a4cb	c6 3b		dec $3b				dec 	zTemp2+1
.a4cd					_MDLINoBorrow:
.a4cd	c6 3a		dec $3a				dec 	zTemp2
.a4cf	80 e6		bra $a4b7			bra 	_MDLIInsert
.a4d1					_MDLIHaveSpace:
.a4d1	ac 2a 04	ldy $042a			ldy 	tokenOffset 				; bytes to copy
.a4d4	88		dey				dey 								; from offset-1 to 0
.a4d5					_MDLICopy:
.a4d5	b9 2a 04	lda $042a,y			lda 	tokenOffset,y
.a4d8	91 30		sta ($30),y			sta 	(codePtr),y
.a4da	88		dey				dey
.a4db	10 f8		bpl $a4d5			bpl 	_MDLICopy
.a4dd	60		rts				rts
.a4de					_MDLIError:
.a4de	a9 06		lda #$06		lda	#6
.a4e0	4c c8 8e	jmp $8ec8		jmp	ErrorHandler
.a4e3					MDLAppendLine:
.a4e3	86 37		stx $37				stx 	zTemp0+1 					; save new line at zTemp0
.a4e5	85 36		sta $36				sta 	zTemp0
.a4e7	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a4e9	85 38		sta $38				sta 	0+zTemp1
.a4eb	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a4ed	85 39		sta $39				sta 	1+zTemp1
.a4ef	b2 38		lda ($38)			lda 	(zTemp1)
.a4f1	d0 0a		bne $a4fd			bne 	_MDLANoInitialise
.a4f3	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a4f5	8d b8 05	sta $05b8			sta 	0+AppendPointer
.a4f8	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a4fa	8d b9 05	sta $05b9			sta 	1+AppendPointer
.a4fd					_MDLANoInitialise:
.a4fd	18		clc				clc
.a4fe	ad b8 05	lda $05b8			lda 	AppendPointer 				; copy append pointer to zTemp1 adding the offset as you go
.a501	85 38		sta $38				sta 	zTemp1
.a503	72 36		adc ($36)			adc 	(zTemp0)
.a505	8d b8 05	sta $05b8			sta 	AppendPointer
.a508	ad b9 05	lda $05b9			lda 	AppendPointer+1
.a50b	85 39		sta $39				sta 	zTemp1+1
.a50d	69 00		adc #$00			adc 	#0
.a50f	8d b9 05	sta $05b9			sta 	AppendPointer+1
.a512	a0 00		ldy #$00			ldy 	#0
.a514					_MDLACopy:
.a514	b1 36		lda ($36),y			lda 	(zTemp0),y 					; copy new line in
.a516	91 38		sta ($38),y			sta 	(zTemp1),y
.a518	c8		iny				iny
.a519	98		tya				tya
.a51a	d2 36		cmp ($36)			cmp 	(zTemp0) 					; done whole line
.a51c	d0 f6		bne $a514			bne 	_MDLACopy
.a51e	a9 00		lda #$00			lda 	#0 							; end of program.
.a520	91 38		sta ($38),y			sta 	(zTemp1),y
.a522	60		rts				rts
.05b8					AppendPointer:
>05b8							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/memory.asm

.a523					MemoryNew:
.a523	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a525	85 30		sta $30				sta 	codePtr
.a527	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a529	85 31		sta $31				sta 	codePtr+1
.a52b	a9 00		lda #$00			lda 	#0 							; write zero there erasing the program.
.a52d	92 30		sta ($30)			sta 	(codePtr)
.a52f	60		rts				rts
.a530					MemoryInline:
.a530	98		tya				tya 								; put address into stack,x
.a531	18		clc				clc  								; get the offset, add codePtr
.a532	65 30		adc $30				adc 	codePtr
.a534	95 58		sta $58,x			sta 	NSMantissa0,x 				; store the result in the mantissa.
.a536	a5 31		lda $31				lda 	codePtr+1
.a538	69 00		adc #$00			adc 	#0
.a53a	95 60		sta $60,x			sta 	NSMantissa1,x
.a53c	74 68		stz $68,x			stz 	NSMantissa2,x
.a53e	74 70		stz $70,x			stz 	NSMantissa3,x
.a540	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/search.asm

.a541					MemorySearch:
.a541	85 36		sta $36				sta 	zTemp0 						; save line number in zTemp0
.a543	86 37		stx $37				stx 	zTemp0+1
.a545	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a547	85 30		sta $30				sta 	codePtr
.a549	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a54b	85 31		sta $31				sta 	codePtr+1
.a54d					_MTAXLoop:
.a54d	b2 30		lda ($30)			lda 	(codePtr)
.a54f	18		clc				clc
.a550	f0 21		beq $a573			beq 	_MTAXExit 					; reached end, exit with CC.
.a552	a0 01		ldy #$01			ldy 	#1 							; calculate current line# - requested line#
.a554	b1 30		lda ($30),y			lda 	(codePtr),y
.a556	38		sec				sec
.a557	e5 36		sbc $36				sbc 	zTemp0
.a559	85 38		sta $38				sta 	zTemp1 						; save interim to set Z
.a55b	c8		iny				iny 								; do the MSB
.a55c	b1 30		lda ($30),y			lda 	(codePtr),y
.a55e	e5 37		sbc $37				sbc 	zTemp0+1
.a560	05 38		ora $38				ora 	zTemp1 						; will set Z if result is zero, doesn't affect carry flag
.a562	f0 0f		beq $a573			beq 	_MTAXExit	 				; found so exit (CS will be set)
.a564	b0 0d		bcs $a573			bcs 	_MTAXExit 					; current < required exit
.a566	18		clc				clc
.a567	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.a569	65 30		adc $30				adc 	codePtr
.a56b	85 30		sta $30				sta 	codePtr
.a56d	90 02		bcc $a571			bcc 	_CREExit
.a56f	e6 31		inc $31				inc 	codePtr+1 					; carry
.a571					_CREExit:
.a571	80 da		bra $a54d			bra 	_MTAXLoop
.a573					_MTAXExit:
.a573	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/playing.asm

.a574					UnaryPlaying:
.a574	fa		plx				plx
.a575	20 70 9d	jsr $9d70			jsr 	Evaluate8BitInteger 		; get channel #
.a578	48		pha				pha
.a579	20 af 8e	jsr $8eaf			jsr		CheckRightBracket
.a57c	68		pla				pla
.a57d	c9 04		cmp #$04			cmp 	#4
.a57f	b0 0c		bcs $a58d			bcs 	_UPNotPlaying
.a581	09 20		ora #$20			ora 	#$20 						; query playing ?
.a583	20 18 80	jsr $8018			jsr 	SNDCommand
.a586	c9 00		cmp #$00			cmp 	#0
.a588	f0 03		beq $a58d			beq 	_UPNotPlaying
.a58a	4c 35 8f	jmp $8f35			jmp 	ReturnTrue
.a58d					_UPNotPlaying:
.a58d	4c 40 8f	jmp $8f40			jmp 	ReturnFalse

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/sound.asm

.a590					SoundCommand:
.a590	b1 30		lda ($30),y			lda 	(codePtr),y
.a592	c9 c0		cmp #$c0			cmp 	#KWD_OFF 					; SOUND OFF ?
.a594	d0 09		bne $a59f			bne 	_SNDMain
.a596	c8		iny				iny 								; skip OFF
.a597	a9 3f		lda #$3f			lda 	#$3F 						; call command $3F (silence)
.a599	5a		phy				phy
.a59a	20 18 80	jsr $8018			jsr 	SNDCommand
.a59d	7a		ply				ply
.a59e	60		rts				rts
.a59f					_SNDMain:
.a59f	a2 00		ldx #$00			ldx 	#0
.a5a1	20 70 9d	jsr $9d70			jsr 	Evaluate8BitInteger 		; channel
.a5a4	c9 04		cmp #$04			cmp 	#4 							; must be 0-3
.a5a6	b0 4b		bcs $a5f3			bcs 	_SndError
.a5a8	e8		inx				inx 								; do the rest in slot 1.
.a5a9	20 b7 8e	jsr $8eb7			jsr 	CheckComma
.a5ac	20 55 9d	jsr $9d55			jsr 	Evaluate16BitInteger 		; Pitch
.a5af	b5 60		lda $60,x			lda 	NSMantissa1,x 				; must be 10 bit
.a5b1	c9 10		cmp #$10			cmp 	#16
.a5b3	b0 3e		bcs $a5f3			bcs 	_SndError
.a5b5	8d bb 05	sta $05bb			sta 	SoundCommandBlock+1 		; Pitch (2 bytes + 0)
.a5b8	b5 58		lda $58,x			lda 	NSMantissa0,x
.a5ba	8d ba 05	sta $05ba			sta 	SoundCommandBlock
.a5bd	20 b7 8e	jsr $8eb7			jsr 	CheckComma
.a5c0	20 70 9d	jsr $9d70			jsr 	Evaluate8BitInteger 		; Length (1 byte + 3)
.a5c3	8d bd 05	sta $05bd			sta 	SoundCommandBlock+3
.a5c6	a9 0f		lda #$0f			lda 	#15
.a5c8	8d bc 05	sta $05bc			sta 	SoundCommandBlock+2 		; Volume (1 byte + 2)
.a5cb	9c be 05	stz $05be			stz 	SoundCommandBlock+4 		; default slide (2 bytes +4)
.a5ce	9c bf 05	stz $05bf			stz 	SoundCommandBlock+5
.a5d1	b1 30		lda ($30),y			lda 	(codePtr),y
.a5d3	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.a5d5	d0 0e		bne $a5e5			bne 	_SNDPlay
.a5d7	c8		iny				iny
.a5d8	20 5f 9d	jsr $9d5f			jsr 	Evaluate16BitIntegerSigned 	; Slide
.a5db	b5 58		lda $58,x			lda 	NSMantissa0,x 				; Slide (2 bytes + 4)
.a5dd	8d be 05	sta $05be			sta 	SoundCommandBlock+4
.a5e0	b5 60		lda $60,x			lda 	NSMantissa1,x
.a5e2	8d bf 05	sta $05bf			sta 	SoundCommandBlock+5
.a5e5					_SNDPlay:
.a5e5	5a		phy				phy
.a5e6	a5 58		lda $58				lda 	NSMantissa0 				; channel.
.a5e8	09 10		ora #$10			ora 	#$10 						; 1x = Queue sound
.a5ea	a2 ba		ldx #$ba			ldx 	#(SoundCommandBlock & $FF)
.a5ec	a0 05		ldy #$05			ldy 	#(SoundCommandBlock >> 8)
.a5ee	20 18 80	jsr $8018			jsr 	SNDCommand
.a5f1	7a		ply				ply
.a5f2	60		rts				rts
.a5f3					_SndError:
.a5f3	4c 58 9f	jmp $9f58			jmp 	RangeError
.05ba					SoundCommandBlock:
>05ba							.fill 	6

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/bytes.asm

.a5f6					StackPushByte:
.a5f6	48		pha				pha 								; save byte
.a5f7	a5 34		lda $34				lda 	BasicStack
.a5f9	d0 09		bne $a604			bne 	_SPBNoBorrow
.a5fb	c6 35		dec $35				dec 	BasicStack+1
.a5fd	48		pha				pha
.a5fe	a5 35		lda $35				lda 	BasicStack+1
.a600	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a602	90 06		bcc $a60a			bcc 	_SPBMemory
.a604					_SPBNoBorrow:
.a604	c6 34		dec $34				dec 	BasicStack
.a606	68		pla				pla 								; get back and write
.a607	92 34		sta ($34)			sta 	(BasicStack)
.a609	60		rts				rts
.a60a					_SPBMemory:
.a60a	a9 12		lda #$12		lda	#18
.a60c	4c c8 8e	jmp $8ec8		jmp	ErrorHandler
.a60f					StackPopByte:
.a60f	b2 34		lda ($34)			lda 	(BasicStack)
.a611	e6 34		inc $34				inc 	BasicStack
.a613	d0 02		bne $a617			bne 	_SPBNoCarry
.a615	e6 35		inc $35				inc 	BasicStack+1
.a617					_SPBNoCarry:
.a617	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/frames.asm

.a618					StackOpen:
.a618	48		pha				pha 								; save frame byte
.a619	29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.a61b	0a		asl a				asl 	a 							; claim twice this for storage
.a61c	49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.a61e	38		sec				sec 								; so basically subtracting from
.a61f	65 34		adc $34				adc 	basicStack 	 				; basicStack
.a621	85 34		sta $34				sta 	basicStack
.a623	b0 08		bcs $a62d			bcs 	_SONoBorrow
.a625	c6 35		dec $35				dec 	basicStack+1
.a627	a5 35		lda $35				lda 	basicStack+1 				; have we reached stack overflow
.a629	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a62b	90 04		bcc $a631			bcc 	_SOMemory
.a62d					_SONoBorrow:
.a62d	68		pla				pla 								; get marker back and write at TOS
.a62e	92 34		sta ($34)			sta 	(basicStack)
.a630	60		rts				rts
.a631					_SOMemory:
.a631	a9 12		lda #$12		lda	#18
.a633	4c c8 8e	jmp $8ec8		jmp	ErrorHandler
.a636					StackClose:
.a636	b2 34		lda ($34)			lda 	(basicStack) 				; get TOS marker
.a638	29 0f		and #$0f			and 	#$0F 						; bytes to add back
.a63a	0a		asl a				asl 	a 							; claim twice this.
.a63b	65 34		adc $34				adc 	basicStack 					; add to the stack pointer.
.a63d	85 34		sta $34				sta 	basicStack
.a63f	90 02		bcc $a643			bcc 	_SCExit
.a641	e6 35		inc $35				inc 	basicStack+1
.a643					_SCExit:
.a643	60		rts				rts
.a644					StackCheckFrame:
.a644	48		pha				pha
.a645					_StackRemoveLocals:
.a645	b2 34		lda ($34)			lda 	(basicStack) 				; check for local, keep popping them
.a647	c9 03		cmp #$03			cmp 	#STK_LOCALS+1
.a649	b0 05		bcs $a650			bcs 	_SCNoLocal
.a64b	20 66 89	jsr $8966			jsr 	LocalPopValue
.a64e	80 f5		bra $a645			bra 	_StackRemoveLocals
.a650					_SCNoLocal:
.a650	68		pla				pla
.a651	52 34		eor ($34)			eor 	(basicStack) 				; xor with toS marker
.a653	29 f0		and #$f0			and 	#$F0 						; check type bits
.a655	d0 01		bne $a658			bne 	_SCFError 					; different, we have structures mixed up
.a657	60		rts				rts
.a658					_SCFError:
.a658	8a		txa				txa 								; report error X
.a659	4c c8 8e	jmp $8ec8			jmp 	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/location.asm

.a65c					STKSaveCodePosition:
.a65c	5a		phy				phy
.a65d	98		tya				tya 								; save Y
.a65e	a0 05		ldy #$05			ldy 	#5
.a660	91 34		sta ($34),y			sta 	(basicStack),y
.a662	88		dey				dey 								; save Code Pointer
.a663					_STKSaveLoop:
.a663	b9 2f 00	lda $002f,y			lda 	safePtr-1,y 				; allows us to access the pointer w/out issues.
.a666	91 34		sta ($34),y			sta 	(basicStack),y
.a668	88		dey				dey
.a669	d0 f8		bne $a663			bne 	_STKSaveLoop
.a66b	7a		ply				ply
.a66c	60		rts				rts
.a66d					STKLoadCodePosition:
.a66d	a0 01		ldy #$01			ldy 	#1 							; load code pointer back
.a66f					_STKLoadLoop:
.a66f	b1 34		lda ($34),y			lda 	(basicStack),y
.a671	99 2f 00	sta $002f,y			sta 	safePtr-1,y
.a674	c8		iny				iny
.a675	c0 05		cpy #$05			cpy 	#5
.a677	d0 f6		bne $a66f			bne 	_STKLoadLoop
.a679	b1 34		lda ($34),y			lda 	(basicStack),y 				; get Y offset
.a67b	a8		tay				tay
.a67c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/setup.asm

.a67d					StackReset:
.a67d	a9 ff		lda #$ff			lda 	#((BasicStackBase+BasicStackSize-1) & $FF)
.a67f	85 34		sta $34				sta 	0+basicStack
.a681	a9 0f		lda #$0f			lda 	#((BasicStackBase+BasicStackSize-1) >> 8)
.a683	85 35		sta $35				sta 	1+basicStack
.a685	a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.a687	92 34		sta ($34)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.a689	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/concrete.asm

.a68a					StringConcrete:
.a68a	5a		phy				phy 								; save position on stack
.a68b	20 fd 99	jsr $99fd			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a68e	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy target string to zTemp1
.a690	85 38		sta $38				sta 	zTemp1
.a692	b5 60		lda $60,x			lda 	NSMantissa1,x
.a694	85 39		sta $39				sta 	zTemp1+1
.a696	a0 ff		ldy #$ff			ldy 	#$FF	 					; calculate string length
.a698					_SALength:
.a698	c8		iny				iny
.a699	b1 38		lda ($38),y			lda 	(zTemp1),y
.a69b	d0 fb		bne $a698			bne 	_SALength
.a69d	c0 fd		cpy #$fd			cpy 	#253 						; string too long
.a69f	b0 3d		bcs $a6de			bcs 	_SALengthError
.a6a1	98		tya				tya 				 				; length of the new string
.a6a2	18		clc				clc
.a6a3	69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.a6a5	90 02		bcc $a6a9			bcc 	_SAHaveLength
.a6a7	a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.a6a9					_SAHaveLength:
.a6a9	48		pha				pha 								; save length.
.a6aa	38		sec				sec
.a6ab	49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.a6ad	6d 0e 04	adc $040e			adc 	StringMemory
.a6b0	8d 0e 04	sta $040e			sta 	StringMemory
.a6b3	85 3a		sta $3a				sta 	zTemp2 						; update storage address
.a6b5	95 58		sta $58,x			sta 	NSMantissa0,x 				; update mantissa address
.a6b7	a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.a6b9	6d 0f 04	adc $040f			adc 	StringMemory+1
.a6bc	8d 0f 04	sta $040f			sta 	StringMemory+1
.a6bf	85 3b		sta $3b				sta 	zTemp2+1
.a6c1	95 60		sta $60,x			sta 	NSMantissa1,x
.a6c3	68		pla				pla 								; save length-3 (chars allowed) in first byte
.a6c4	38		sec				sec
.a6c5	e9 03		sbc #$03			sbc 	#3
.a6c7	92 3a		sta ($3a)			sta 	(zTemp2)
.a6c9	a9 00		lda #$00			lda 	#0 							; clear the status byte.
.a6cb	a0 01		ldy #$01			ldy 	#1
.a6cd	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a6cf					_SACopyNewString:
.a6cf	a0 00		ldy #$00			ldy 	#0
.a6d1					_SACopyNSLoop:
.a6d1	b1 38		lda ($38),y			lda 	(zTemp1),y 					; get character
.a6d3	c8		iny				iny 								; write two on in string storage
.a6d4	c8		iny				iny
.a6d5	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a6d7	88		dey				dey 								; this makes it one one.
.a6d8	c9 00		cmp #$00			cmp 	#0 							; until EOS copied
.a6da	d0 f5		bne $a6d1			bne 	_SACopyNSLoop
.a6dc	7a		ply				ply
.a6dd	60		rts				rts
.a6de					_SALengthError:
.a6de	a9 09		lda #$09		lda	#9
.a6e0	4c c8 8e	jmp $8ec8		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/stringalloc.asm

.a6e3					StringSystemInitialise:
.a6e3	a9 ff		lda #$ff			lda 	#((EndVariableSpace-1) & $FF)
.a6e5	8d 0e 04	sta $040e			sta 	0+StringMemory
.a6e8	a9 1f		lda #$1f			lda 	#((EndVariableSpace-1) >> 8)
.a6ea	8d 0f 04	sta $040f			sta 	1+StringMemory
.a6ed	9c ff 1f	stz $1fff			stz 	EndVariableSpace-1 			; put a zero at the end, so know end of string memory.
.a6f0	60		rts				rts
.a6f1					StringSpaceInitialise:
.a6f1	20 fd 99	jsr $99fd			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a6f4	a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.a6f6	8d 10 04	sta $0410			sta 	StringInitialised
.a6f9	ad 0e 04	lda $040e			lda 	StringMemory 				; allocate 256 bytes for one concreted string
.a6fc	8d 11 04	sta $0411			sta 	StringTempPointer
.a6ff	ad 0f 04	lda $040f			lda 	StringMemory+1
.a702	3a		dec a				dec 	a
.a703	8d 12 04	sta $0412			sta 	StringTempPointer+1
.a706	60		rts				rts
.a707					StringTempAllocate:
.a707	c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.a709	b0 30		bcs $a73b			bcs 	_STALength
.a70b	2c 10 04	bit $0410			bit 	StringInitialised 			; already initialised
.a70e	30 05		bmi $a715			bmi 	_STAAllocate
.a710	48		pha				pha 								; save value to subtract.
.a711	20 f1 a6	jsr $a6f1			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.a714	68		pla				pla 								; restore it
.a715					_STAAllocate:
.a715	49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.a717	18		clc				clc  								; deliberate allows one more
.a718	6d 11 04	adc $0411			adc 	StringTempPointer 			; subtract from temp pointer
.a71b	8d 11 04	sta $0411			sta 	StringTempPointer
.a71e	95 58		sta $58,x			sta 	NSMantissa0,x 				; address in mantissa
.a720	85 3c		sta $3c				sta 	zsTemp 						; and zsTemp
.a722	ad 12 04	lda $0412			lda 	StringTempPointer+1
.a725	69 ff		adc #$ff			adc 	#$FF
.a727	8d 12 04	sta $0412			sta 	StringTempPointer+1
.a72a	85 3d		sta $3d				sta 	zsTemp+1
.a72c	95 60		sta $60,x			sta 	NSMantissa1,x
.a72e	74 68		stz $68,x			stz 	NSMantissa2,x 				; set the typing data
.a730	74 70		stz $70,x			stz 	NSMantissa3,x
.a732	a9 10		lda #$10			lda 	#NSTString
.a734	95 50		sta $50,x			sta 	NSStatus,x
.a736	a9 00		lda #$00			lda 	#0 							; clear the target string
.a738	92 3c		sta ($3c)			sta 	(zsTemp)
.a73a	60		rts				rts
.a73b					_STALength:
.a73b	a9 09		lda #$09		lda	#9
.a73d	4c c8 8e	jmp $8ec8		jmp	ErrorHandler
.a740					StringTempWrite:
.a740	48		pha				pha
.a741	92 3c		sta ($3c)			sta 	(zsTemp)
.a743	e6 3c		inc $3c				inc 	zsTemp
.a745	d0 02		bne $a749			bne 	_STWNoCarry
.a747	e6 3d		inc $3d				inc 	zsTemp+1
.a749					_STWNoCarry:
.a749	a9 00		lda #$00			lda 	#0
.a74b	92 3c		sta ($3c)			sta 	(zsTemp)
.a74d	68		pla				pla
.a74e	60		rts				rts

;******  Return to file: _basic.asm

.a74f					StartModuleCode:

;******  Processing file: ../modules/_build/_hardware.module

=1					hardwareIntegrated=1
=0					CONBlack = 0
=1					CONWhite = 1
=2					CONRed = 2
=3					CONCyan = 3
=4					CONPurple = 4
=5					CONGreen = 5
=6					CONBlue = 6
=7					CONYellow = 7
=8					CONOrange = 8
=9					CONBrown = 9
=10					CONYellowGreen = 10
=11					CONRosa = 11
=12					CONBlueGreen = 12
=13					CONLightBlue = 13
=14					CONPink = 14
=15					CONLightGreen = 15
=7					CONForeground = CONYellow
=6					CONBackground = CONBlue
=5					CLICommandLine = CONGreen
=0					CLIFComment = CONBlack
=7					CLIBComment = CONYellow
=9					CLILineNumber = CONBrown
=3					CLIToken = CONCyan
=13					CLIConstant = CONLightBlue
=7					CLIIdentifier = CONYellow
=10					CLIPunctuation = CONYellowGreen
=1					CLIData = CONWhite
.a74f					Export_EXTPrintCharacter:
.a74f					PAGEDPrintCharacter:
.a74f	48		pha				pha
.a750	da		phx				phx
.a751	5a		phy				phy
.a752	a6 01		ldx $01				ldx 	1
.a754	da		phx				phx
.a755	ac c1 05	ldy $05c1			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.a758	09 00		ora #$00			ora 	#$00 						; check $80-$FF
.a75a	30 48		bmi $a7a4			bmi 	_EXPCColour
.a75c	c9 20		cmp #$20			cmp 	#$20 						; check $00-$1F
.a75e	90 4d		bcc $a7ad			bcc 	_EXPCControl
.a760	a2 02		ldx #$02			ldx 	#2 							; select char memory
.a762	86 01		stx $01				stx 	1
.a764	91 40		sta ($40),y			sta 	(EXTAddress),y
.a766	e6 01		inc $01				inc 	1 							; select colour memory
.a768	ad c2 05	lda $05c2			lda 	EXTTextColour
.a76b	91 40		sta ($40),y			sta 	(EXTAddress),y
.a76d	c8		iny				iny 								; advance horizontal position
.a76e	8c c1 05	sty $05c1			sty 	EXTColumn
.a771	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth 				; reached RHS ?
.a774	90 66		bcc $a7dc			bcc 	_EXPCExit 					; no, then exit.
.a776					_EXPCCRLF:
.a776	ee c0 05	inc $05c0			inc 	EXTRow  					; bump row
.a779	9c c1 05	stz $05c1			stz 	EXTColumn 					; back to column 0
.a77c	ad c0 05	lda $05c0			lda 	EXTRow 						; check if reached the bottom ?
.a77f	cd c4 05	cmp $05c4			cmp 	EXTScreenHeight 			; if so, then scroll.
.a782	f0 18		beq $a79c			beq 	_EXPCScroll
.a784	18		clc				clc 								; add width to address.
.a785	a5 40		lda $40				lda 	EXTAddress
.a787	6d c3 05	adc $05c3			adc 	EXTScreenWidth
.a78a	85 40		sta $40				sta 	EXTAddress
.a78c	90 4e		bcc $a7dc			bcc 	_EXPCExit
.a78e	e6 41		inc $41				inc 	EXTAddress+1
.a790	80 4a		bra $a7dc			bra 	_EXPCExit
.a792					_EXPCLeft:
.a792	ce c1 05	dec $05c1			dec 	EXTColumn
.a795	10 45		bpl $a7dc			bpl 	_EXPCExit
.a797					_EXPCBegin:
.a797	9c c1 05	stz $05c1			stz 	EXTColumn
.a79a	80 40		bra $a7dc			bra 	_EXPCExit
.a79c					_EXPCScroll:
.a79c	ce c0 05	dec $05c0			dec 	EXTRow 						; the height-1 th line.
.a79f	20 69 a8	jsr $a869			jsr 	EXTScreenScroll 			; scroll the screen
.a7a2	80 38		bra $a7dc			bra 	_EXPCExit
.a7a4					_EXPCColour:
.a7a4	c9 a0		cmp #$a0			cmp 	#$A0						; 80-9F set foreground/background
.a7a6	b0 34		bcs $a7dc			bcs 	_EXPCExit
.a7a8	20 49 a8	jsr $a849			jsr 	_EXPCHandleColour
.a7ab	80 2f		bra $a7dc			bra 	_EXPCExit
.a7ad					_EXPCControl:
.a7ad	c9 11		cmp #$11			cmp 	#$11 						; only handle 00-10.
.a7af	b0 2b		bcs $a7dc			bcs 	_EXPCExit
.a7b1	0a		asl a				asl 	a 							; double into X
.a7b2	aa		tax				tax
.a7b3	7c 27 a8	jmp ($a827,x)			jmp 	(_EXPCActionTable,x) 		; and execute code.
.a7b6					_EXPCUp:
.a7b6	ad c0 05	lda $05c0			lda 	EXTRow 						; already at top ?
.a7b9	f0 21		beq $a7dc			beq 	_EXPCExit
.a7bb	ce c0 05	dec $05c0			dec 	EXTRow 						; up one in position/address
.a7be	38		sec				sec
.a7bf	a5 40		lda $40				lda 	EXTAddress
.a7c1	ed c3 05	sbc $05c3			sbc 	EXTScreenWidth
.a7c4	85 40		sta $40				sta 	EXTAddress
.a7c6	b0 14		bcs $a7dc			bcs 	_EXPCExit
.a7c8	c6 41		dec $41				dec 	EXTAddress+1
.a7ca	80 10		bra $a7dc			bra 	_EXPCExit
.a7cc					_EXPCRight:
.a7cc	c8		iny				iny
.a7cd	8c c1 05	sty $05c1			sty 	EXTColumn
.a7d0	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth
.a7d3	d0 07		bne $a7dc			bne 	_EXPCExit
.a7d5					_EXPCEnd:
.a7d5	ad c3 05	lda $05c3			lda 	EXTScreenWidth
.a7d8	3a		dec a				dec 	a
.a7d9	8d c1 05	sta $05c1			sta 	EXTColumn
.a7dc					_EXPCExit:
.a7dc	20 be a8	jsr $a8be			jsr 	EXTSetHardwareCursor 		; place the physical cursor.
.a7df	68		pla				pla
.a7e0	85 01		sta $01				sta 	1
.a7e2	7a		ply				ply
.a7e3	fa		plx				plx
.a7e4	68		pla				pla
.a7e5	60		rts				rts
.a7e6					_EXPCClearScreen:
.a7e6	20 7b a8	jsr $a87b			jsr		EXTClearScreenCode
.a7e9	80 f1		bra $a7dc			bra 	_EXPCExit
.a7eb					_EXPCDown:
.a7eb	ad c4 05	lda $05c4			lda 	EXTScreenHeight 			; at the bottom
.a7ee	3a		dec a				dec 	a
.a7ef	cd c0 05	cmp $05c0			cmp 	EXTRow
.a7f2	f0 e8		beq $a7dc			beq 	_EXPCExit
.a7f4	ee c0 05	inc $05c0			inc 	EXTRow 						; down one in position/address
.a7f7	18		clc				clc
.a7f8	a5 40		lda $40				lda 	EXTAddress
.a7fa	6d c3 05	adc $05c3			adc 	EXTScreenWidth
.a7fd	85 40		sta $40				sta 	EXTAddress
.a7ff	90 db		bcc $a7dc			bcc 	_EXPCExit
.a801	e6 41		inc $41				inc 	EXTAddress+1
.a803	80 d7		bra $a7dc			bra 	_EXPCExit
.a805					_EXPCTab:
.a805	ad c1 05	lda $05c1			lda 	EXTColumn 					; next tab stop
.a808	29 f8		and #$f8			and 	#$F8
.a80a	18		clc				clc
.a80b	69 08		adc #$08			adc 	#8
.a80d	8d c1 05	sta $05c1			sta 	EXTColumn
.a810	cd c3 05	cmp $05c3			cmp 	EXTScreenWidth 				; too far, stick end of line.
.a813	90 c7		bcc $a7dc			bcc 	_EXPCExit
.a815	80 be		bra $a7d5			bra 	_EXPCEnd
.a817					_EXPCBackSpace:
.a817	88		dey				dey
.a818	30 c2		bmi $a7dc			bmi 	_EXPCExit
.a81a	ce c1 05	dec $05c1			dec 	EXTColumn
.a81d	a9 02		lda #$02			lda 	#2
.a81f	85 01		sta $01				sta 	1
.a821	a9 20		lda #$20			lda 	#32
.a823	91 40		sta ($40),y			sta 	(EXTAddress),y
.a825	80 b5		bra $a7dc			bra 	_EXPCExit
.a827					_EXPCActionTable:
>a827	dc a7						.word 	_EXPCExit 					; 00
>a829	97 a7						.word 	_EXPCBegin 					; 01 A Start of Line
>a82b	92 a7						.word 	_EXPCLeft 					; 02 B Left
>a82d	dc a7						.word 	_EXPCExit 					; 03 <Break>
>a82f	dc a7						.word 	_EXPCExit 					; 04
>a831	d5 a7						.word 	_EXPCEnd 					; 05 E End of Line
>a833	cc a7						.word 	_EXPCRight 					; 06 F Right
>a835	dc a7						.word 	_EXPCExit 					; 07
>a837	17 a8						.word 	_EXPCBackspace 				; 08 H Backspace
>a839	05 a8						.word 	_EXPCTab 					; 09 I Tab
>a83b	dc a7						.word 	_EXPCExit 					; 0A
>a83d	dc a7						.word 	_EXPCExit 					; 0B
>a83f	e6 a7						.word 	_EXPCClearScreen			; 0C L CLS
>a841	76 a7						.word 	_EXPCCRLF 					; 0D M CR/LF
>a843	eb a7						.word 	_EXPCDown 					; 0E N Down
>a845	dc a7						.word 	_EXPCExit 					; 0F
>a847	b6 a7						.word 	_EXPCUp 					; 10 P Up
.a849					_EXPCHandleColour
.a849	c9 90		cmp #$90			cmp 	#$90 						; 8x foreground 9x background
.a84b	b0 16		bcs $a863			bcs 	_EXPCBackground
.a84d	0a		asl a				asl 	a 							; shift it 4 bits to the right.
.a84e	0a		asl a				asl 	a
.a84f	0a		asl a				asl 	a
.a850	0a		asl a				asl 	a
.a851	a2 0f		ldx #$0f			ldx 	#$0F 						; Mask in X
.a853					_EXPCUpdate:
.a853	48		pha				pha 								; save new colour
.a854	8a		txa				txa 								; get mask
.a855	2d c2 05	and $05c2			and 	EXTTextColour 				; mask out old.
.a858	8d c2 05	sta $05c2			sta 	EXTTextColour
.a85b	68		pla				pla 								; or in new colour
.a85c	0d c2 05	ora $05c2			ora 	EXTTextColour
.a85f	8d c2 05	sta $05c2			sta 	EXTTextColour
.a862	60		rts				rts
.a863					_EXPCBackground:
.a863	29 0f		and #$0f			and 	#$0F 						; get the colour
.a865	a2 f0		ldx #$f0			ldx 	#$F0 						; mask
.a867	80 ea		bra $a853			bra 	_EXPCUpdate
.a869					EXTScreenScroll:
.a869	a9 02		lda #$02			lda 	#2 							; select text page
.a86b	85 01		sta $01				sta 	1
.a86d	a9 20		lda #$20			lda		#32 						; fill with space
.a86f	20 7e a9	jsr $a97e			jsr 	EXTScrollFill
.a872	e6 01		inc $01				inc 	1 							; select colour page
.a874	ad c2 05	lda $05c2			lda 	EXTTextColour
.a877	20 7e a9	jsr $a97e			jsr 	EXTScrollFill
.a87a	60		rts				rts
.a87b					EXTClearScreenCode:
.a87b	a9 02		lda #$02			lda 	#2 							; select text page
.a87d	85 01		sta $01				sta 	1
.a87f	a9 20		lda #$20			lda		#32 						; fill with space
.a881	20 8e a8	jsr $a88e			jsr 	_EXTCSFill
.a884	e6 01		inc $01				inc 	1 							; select colour page
.a886	ad c2 05	lda $05c2			lda 	EXTTextColour
.a889	20 8e a8	jsr $a88e			jsr 	_EXTCSFill
.a88c	80 22		bra $a8b0			bra 	EXTHomeCursor
.a88e					_EXTCSFill:
.a88e	aa		tax				tax
.a88f	a9 00		lda #$00			lda 	#EXTMemory & $FF
.a891	85 40		sta $40				sta 	EXTAddress
.a893	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a895	85 41		sta $41				sta 	EXTAddress+1
.a897					_EXTCSFill1:
.a897	a0 00		ldy #$00			ldy 	#0
.a899	8a		txa				txa
.a89a					_EXTCSFill2:
.a89a	91 40		sta ($40),y			sta 	(EXTAddress),y
.a89c	c8		iny				iny
.a89d	d0 fb		bne $a89a			bne 	_EXTCSFill2
.a89f	e6 41		inc $41				inc 	EXTAddress+1
.a8a1	a5 41		lda $41				lda 	EXTAddress+1
.a8a3	c9 d2		cmp #$d2			cmp 	#$D2
.a8a5	d0 f0		bne $a897			bne 	_EXTCSFill1
.a8a7	8a		txa				txa
.a8a8					_EXTCSFill3:
.a8a8	91 40		sta ($40),y			sta 	(EXTAddress),y
.a8aa	c8		iny				iny
.a8ab	c0 c0		cpy #$c0			cpy 	#$C0
.a8ad	d0 f9		bne $a8a8			bne 	_EXTCSFill3
.a8af	60		rts				rts
.a8b0					EXTHomeCursor:
.a8b0	9c c0 05	stz $05c0			stz 	EXTRow 						; reset row & column
.a8b3	9c c1 05	stz $05c1			stz 	EXTColumn
.a8b6	a9 00		lda #$00			lda 	#EXTMemory & $FF 			; set address
.a8b8	85 40		sta $40				sta 	EXTAddress
.a8ba	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a8bc	85 41		sta $41				sta 	EXTAddress+1
.a8be					EXTSetHardwareCursor:
.a8be	64 01		stz $01				stz 	1 							; I/O Page zero
.a8c0	a9 05		lda #$05			lda 	#1+4 						; enable cursor
.a8c2	8d 10 d0	sta $d010			sta 	$D010
.a8c5	a9 b1		lda #$b1			lda 	#$B1
.a8c7	8d 12 d0	sta $d012			sta 	$D012
.a8ca	ad c1 05	lda $05c1			lda 	EXTColumn
.a8cd	8d 14 d0	sta $d014			sta 	$D014 						; set cursor position
.a8d0	9c 15 d0	stz $d015			stz 	$D015
.a8d3	ad c0 05	lda $05c0			lda 	EXTRow
.a8d6	8d 16 d0	sta $d016			sta 	$D016
.a8d9	9c 17 d0	stz $d017			stz 	$D017
.a8dc	60		rts				rts
.a8dd					Export_EXTInputLine:
.a8dd	48		pha				pha
.a8de	da		phx				phx
.a8df	5a		phy				phy
.a8e0	a5 01		lda $01				lda 	1 							; save I/O page
.a8e2	48		pha				pha
.a8e3					_EILLoop:
.a8e3	20 e5 a9	jsr $a9e5			jsr 	PagedInputSingleCharacter
.a8e6	c9 0d		cmp #$0d			cmp 	#13 						; scrape line if exit.
.a8e8	f0 40		beq $a92a			beq 	_EILExit
.a8ea	c9 08		cmp #$08			cmp 	#8 							; handle backspace
.a8ec	f0 1c		beq $a90a			beq 	_EILBackspace
.a8ee	c9 20		cmp #$20			cmp 	#' '						; < space, print it
.a8f0	90 12		bcc $a904			bcc 	_EILPrintLoop
.a8f2	c9 7f		cmp #$7f			cmp 	#$7F 						; if -ve print it
.a8f4	b0 0e		bcs $a904			bcs 	_EILPrintLoop
.a8f6	48		pha				pha 								; save character
.a8f7	a9 02		lda #$02			lda 	#2  						; insert a space
.a8f9	85 01		sta $01				sta 	1
.a8fb	20 6c a9	jsr $a96c			jsr 	EXTILInsert 				; insert in text screen
.a8fe	e6 01		inc $01				inc 	1
.a900	20 6c a9	jsr $a96c			jsr 	EXTILInsert 				; insert in colour screen
.a903	68		pla				pla 								; get character back.
.a904					_EILPrintLoop:
.a904	20 4f a7	jsr $a74f			jsr 	PagedPrintCharacter
.a907	80 da		bra $a8e3			bra 	_EILLoop
.a909	60		rts				rts
.a90a					_EILBackspace:
.a90a	ad c1 05	lda $05c1			lda 	EXTColumn					; can we backspace ?
.a90d	f0 d4		beq $a8e3			beq 	_EILLoop
.a90f	a9 02		lda #$02			lda 	#2 							; move cursor left
.a911	20 4f a7	jsr $a74f			jsr 	PagedPrintCharacter
.a914	a9 02		lda #$02			lda 	#2 							; text block
.a916	85 01		sta $01				sta 	1
.a918	a9 20		lda #$20			lda 	#' ' 						; backspace text.
.a91a	20 57 a9	jsr $a957			jsr 	EXTILDelete
.a91d	e6 01		inc $01				inc 	1 							; colour block
.a91f	ac c1 05	ldy $05c1			ldy 	EXTColumn 					; get attribute of last character
.a922	88		dey				dey
.a923	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a925	20 57 a9	jsr $a957			jsr 	EXTILDelete 				; backspace attribute
.a928	80 b9		bra $a8e3			bra 	_EILLoop 					; and go round.
.a92a					_EILExit:
.a92a	a9 02		lda #$02			lda 	#2 							; switch to page 2
.a92c	85 01		sta $01				sta 	1
.a92e	a0 00		ldy #$00			ldy 	#0 							; copy current line into buffer.
.a930					_EILScrapeLine:
.a930	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a932	99 2a 05	sta $052a,y			sta 	lineBuffer,y
.a935	c8		iny				iny
.a936	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth
.a939	d0 f5		bne $a930			bne 	_EILScrapeLine
.a93b					_EILTrimSpaces:
.a93b	88		dey				dey
.a93c	f0 08		beq $a946			beq 	_EILEndTrim
.a93e	b9 2a 05	lda $052a,y			lda 	lineBuffer,y
.a941	c9 20		cmp #$20			cmp 	#' '
.a943	f0 f6		beq $a93b			beq 	_EILTrimSpaces
.a945	c8		iny				iny 								; trim after non space character.
.a946					_EILEndTrim:
.a946	a9 00		lda #$00			lda 	#0 							; trim here.
.a948	99 2a 05	sta $052a,y			sta 	lineBuffer,y
.a94b	a9 0d		lda #$0d			lda 	#13 						; echo the RETURN
.a94d	20 4f a7	jsr $a74f			jsr 	PagedPrintCharacter
.a950	68		pla				pla 								; reset I/O page
.a951	85 01		sta $01				sta 	1
.a953	7a		ply				ply
.a954	fa		plx				plx
.a955	68		pla				pla
.a956	60		rts				rts
.a957					EXTILDelete:
.a957	48		pha				pha 								; save the new character
.a958	ac c1 05	ldy $05c1			ldy 	EXTColumn 					; start copying from here.
.a95b					_EXTDLoop:
.a95b	c8		iny				iny 								; copy one byte down.
.a95c	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a95e	88		dey				dey
.a95f	91 40		sta ($40),y			sta 	(EXTAddress),y
.a961	c8		iny				iny 								; do till end of line.
.a962	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth
.a965	90 f4		bcc $a95b			bcc 	_EXTDLoop
.a967	88		dey				dey 	 							; write in last slot.
.a968	68		pla				pla
.a969	91 40		sta ($40),y			sta 	(EXTAddress),y
.a96b	60		rts				rts
.a96c					EXTILInsert:
.a96c	ac c3 05	ldy $05c3			ldy 	EXTScreenWidth 				; end position
.a96f					_EXTILoop:
.a96f	88		dey				dey 								; back one
.a970	cc c1 05	cpy $05c1			cpy 	EXTColumn 					; exit if reached insert point.
.a973	f0 08		beq $a97d			beq 	_EXTIExit
.a975	88		dey				dey 								; copy one byte up.
.a976	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a978	c8		iny				iny
.a979	91 40		sta ($40),y			sta 	(EXTAddress),y
.a97b	80 f2		bra $a96f			bra 	_EXTILoop
.a97d					_EXTIExit:
.a97d	60		rts				rts
.a97e					EXTScrollFill:
.a97e	aa		tax				tax									; save value to fill with
.a97f	a5 36		lda $36				lda 	zTemp0 						; save zTemp0 (dest) zTemp1 (src)
.a981	48		pha				pha
.a982	a5 37		lda $37				lda 	zTemp0+1
.a984	48		pha				pha
.a985	a5 38		lda $38				lda 	zTemp1
.a987	48		pha				pha
.a988	a5 39		lda $39				lda 	zTemp1+1
.a98a	48		pha				pha
.a98b	a9 c0		lda #$c0			lda 	#$C0 						; copy from C000+length to C000
.a98d	85 37		sta $37				sta 	zTemp0+1
.a98f	85 39		sta $39				sta 	zTemp1+1
.a991	64 36		stz $36				stz 	zTemp0
.a993	ad c3 05	lda $05c3			lda 	EXTScreenWidth
.a996	85 38		sta $38				sta 	zTemp1
.a998	a0 00		ldy #$00			ldy 	#0
.a99a					_EXSFCopy1:
.a99a	b1 38		lda ($38),y			lda 	(zTemp1),y
.a99c	91 36		sta ($36),y			sta 	(zTemp0),y
.a99e	c8		iny				iny
.a99f	d0 f9		bne $a99a			bne 	_EXSFCopy1
.a9a1	e6 37		inc $37				inc 	zTemp0+1 					; next page
.a9a3	e6 39		inc $39				inc 	zTemp1+1
.a9a5	a5 39		lda $39				lda 	zTemp1+1
.a9a7	c9 d3		cmp #$d3			cmp 	#$D3
.a9a9	d0 ef		bne $a99a			bne 	_EXSFCopy1
.a9ab	ac c3 05	ldy $05c3			ldy 	EXTScreenWidth 				; blank the bottom line.
.a9ae	8a		txa				txa
.a9af					_EXSFFill1:
.a9af	88		dey				dey
.a9b0	91 40		sta ($40),y			sta 	(EXTAddress),y
.a9b2	c0 00		cpy #$00			cpy 	#0
.a9b4	10 f9		bpl $a9af			bpl 	_EXSFFill1
.a9b6	68		pla				pla
.a9b7	85 39		sta $39				sta 	zTemp1+1
.a9b9	68		pla				pla
.a9ba	85 38		sta $38				sta 	zTemp1
.a9bc	68		pla				pla
.a9bd	85 37		sta $37				sta 	zTemp0+1
.a9bf	68		pla				pla
.a9c0	85 36		sta $36				sta 	zTemp0
.a9c2	60		rts				rts
=$c000					EXTMemory = $C000
=$02					EXTTextPage = $02
=$03					EXTColourPage = $03
=1					EXTDummySpace = 1 							; fake-space for CR character.
=0					EXTCBlack = 0
.05c0					EXTRow:
>05c0							.fill 	1
.05c1					EXTColumn:
>05c1							.fill 	1
.05c2					EXTTextColour:
>05c2							.fill 	1
.05c3					EXTScreenWidth:
>05c3							.fill 	1
.05c4					EXTScreenHeight:
>05c4							.fill 	1
.0040					EXTAddress:
>0040							.fill 	2
.a9c3					Export_EXTInitialise:
.a9c3	64 01		stz $01				stz 	1 							; Access I/O
.a9c5	9c 04 d0	stz $d004			stz 	$D004 						; Disable border
.a9c8	9c 08 d0	stz $d008			stz 	$D008
.a9cb	9c 09 d0	stz $d009			stz 	$D009
.a9ce	a9 09		lda #$09			lda 	#1+8						; Timer On at 70Hz counting up.
.a9d0	8d 58 d6	sta $d658			sta 	$D658
.a9d3	a9 76		lda #$76			lda 	#CONForeground * 16 + CONBackground
.a9d5	8d c2 05	sta $05c2			sta 	EXTTextColour
.a9d8	a9 50		lda #$50			lda 	#80 						; set screen dimensions.
.a9da	8d c3 05	sta $05c3			sta 	EXTScreenWidth
.a9dd	a9 3c		lda #$3c			lda 	#60
.a9df	8d c4 05	sta $05c4			sta 	EXTScreenHeight
.a9e2	64 01		stz $01				stz 	1
.a9e4	60		rts				rts
.a9e5					Export_EXTInputSingleCharacter:
.a9e5					PagedInputSingleCharacter:
.a9e5	da		phx				phx
.a9e6	5a		phy				phy
.a9e7					_EISCWait:
.a9e7	64 01		stz $01				stz 	1 							; access I/O Page 0
.a9e9	38		sec				sec 								; calculate timer - LastTick
.a9ea	ad 59 d6	lda $d659			lda 	$D659
.a9ed	aa		tax				tax 								; saving timer in X
.a9ee	ed af 05	sbc $05af			sbc 	LastTick
.a9f1	c9 03		cmp #$03			cmp 	#3
.a9f3	90 06		bcc $a9fb			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.a9f5	8e af 05	stx $05af			stx 	LastTick 					; update last timer
.a9f8	20 8c b9	jsr $b98c			jsr 	PagedSNDUpdate 							; go do the code.
.a9fb					_NoFireTick:
.a9fb	20 e4 ff	jsr $ffe4			jsr 	$FFE4
.a9fe	c9 00		cmp #$00			cmp 	#0
.aa00	f0 e5		beq $a9e7			beq 	_EISCWait
.aa02	7a		ply				ply
.aa03	fa		plx				plx
.aa04	60		rts				rts
.aa05					Export_EXTBreakCheck:
.aa05	4c e1 ff	jmp $ffe1			jmp		$FFE1
.aa08					Export_EXTReadController:
.aa08	da		phx				phx
.aa09	a2 00		ldx #$00			ldx 	#0
.aa0b	a9 05		lda #$05			lda 	#(($2D) >> 3)
.aa0d	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa10	29 20		and #$20			and 	#($01 << (($2D) & 7))
.aa12	f0 04		beq $aa18			beq 	_NoSet1
.aa14	8a		txa				txa
.aa15	09 01		ora #$01			ora 	#1
.aa17	aa		tax				tax
.aa18					_NoSet1:
.aa18	a9 05		lda #$05			lda 	#(($2C) >> 3)
.aa1a	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa1d	29 10		and #$10			and 	#($01 << (($2C) & 7))
.aa1f	f0 04		beq $aa25			beq 	_NoSet1
.aa21	8a		txa				txa
.aa22	09 02		ora #$02			ora 	#2
.aa24	aa		tax				tax
.aa25					_NoSet1:
.aa25	a9 06		lda #$06			lda 	#(($32) >> 3)
.aa27	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa2a	29 04		and #$04			and 	#($01 << (($32) & 7))
.aa2c	f0 04		beq $aa32			beq 	_NoSet1
.aa2e	8a		txa				txa
.aa2f	09 04		ora #$04			ora 	#4
.aa31	aa		tax				tax
.aa32					_NoSet1:
.aa32	a9 04		lda #$04			lda 	#(($25) >> 3)
.aa34	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa37	29 20		and #$20			and 	#($01 << (($25) & 7))
.aa39	f0 04		beq $aa3f			beq 	_NoSet1
.aa3b	8a		txa				txa
.aa3c	09 08		ora #$08			ora 	#8
.aa3e	aa		tax				tax
.aa3f					_NoSet1:
.aa3f	a9 04		lda #$04			lda 	#(($26) >> 3)
.aa41	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa44	29 40		and #$40			and 	#($01 << (($26) & 7))
.aa46	f0 04		beq $aa4c			beq 	_NoSet1
.aa48	8a		txa				txa
.aa49	09 10		ora #$10			ora 	#16
.aa4b	aa		tax				tax
.aa4c					_NoSet1:
.aa4c	8a		txa				txa
.aa4d	fa		plx				plx
.aa4e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_graphics.module

=1					graphicsIntegrated=1
=0					GCMD_Initialise = 0*2
=2					GCMD_BitmapCtl = 1*2
=4					GCMD_SpriteCtl = 2*2
=6					GCMD_Clear = 3*2
=8					GCMD_Colour = 4*2
=10					GCMD_DrawFont = 5*2
=12					GCMD_DrawSprite = 6*2
=14					GCMD_SpriteUse = 7*2
=16					GCMD_SpriteImage = 8*2
=18					GCMD_SpriteCollide = 9*2
=64					GCMD_Move = 32*2
=66					GCMD_Line = 33*2
=68					GCMD_FrameRect = 34*2
=70					GCMD_FillRect = 35*2
=72					GCMD_FrameCircle = 36*2
=74					GCMD_FillCircle = 37*2
=80					GCMD_Plot = 40*2
=82					GCMD_SpriteMove = 41*2
=42					GRFirstFreeCode = 42
.b9e6					GRVectorTable:
>b9e6	4a ac					.word	GXInitialise             ; $00 Initialise
>b9e8	64 ac					.word	GXControlBitmap          ; $01 BitmapCtl
>b9ea	ac ac					.word	GXControlSprite          ; $02 SpriteCtl
>b9ec	fc ab					.word	GXClearBitmap            ; $03 Clear
>b9ee	3b ae					.word	GXSetColourMode          ; $04 Colour
>b9f0	03 b0					.word	GXFontHandler            ; $05 DrawFont
>b9f2	4b b0					.word	GXSpriteHandler          ; $06 DrawSprite
>b9f4	b7 b0					.word	GXSelect                 ; $07 SpriteUse
>b9f6	e0 b0					.word	GXSelectImage            ; $08 SpriteImage
>b9f8	67 b2					.word	GXCollide                ; $09 SpriteCollide
>b9fa	ae aa					.word	GRUndefined              ; $0a
>b9fc	ae aa					.word	GRUndefined              ; $0b
>b9fe	ae aa					.word	GRUndefined              ; $0c
>ba00	ae aa					.word	GRUndefined              ; $0d
>ba02	ae aa					.word	GRUndefined              ; $0e
>ba04	ae aa					.word	GRUndefined              ; $0f
>ba06	ae aa					.word	GRUndefined              ; $10
>ba08	ae aa					.word	GRUndefined              ; $11
>ba0a	ae aa					.word	GRUndefined              ; $12
>ba0c	ae aa					.word	GRUndefined              ; $13
>ba0e	ae aa					.word	GRUndefined              ; $14
>ba10	ae aa					.word	GRUndefined              ; $15
>ba12	ae aa					.word	GRUndefined              ; $16
>ba14	ae aa					.word	GRUndefined              ; $17
>ba16	ae aa					.word	GRUndefined              ; $18
>ba18	ae aa					.word	GRUndefined              ; $19
>ba1a	ae aa					.word	GRUndefined              ; $1a
>ba1c	ae aa					.word	GRUndefined              ; $1b
>ba1e	ae aa					.word	GRUndefined              ; $1c
>ba20	ae aa					.word	GRUndefined              ; $1d
>ba22	ae aa					.word	GRUndefined              ; $1e
>ba24	ae aa					.word	GRUndefined              ; $1f
>ba26	ac aa					.word	GXMove                   ; $20 Move
>ba28	09 ad					.word	GXLine                   ; $21 Line
>ba2a	84 ae					.word	GXFrameRectangle         ; $22 FrameRect
>ba2c	81 ae					.word	GXFillRectangle          ; $23 FillRect
>ba2e	b3 aa					.word	GXFrameCircle            ; $24 FrameCircle
>ba30	af aa					.word	GXFillCircle             ; $25 FillCircle
>ba32	ae aa					.word	GRUndefined              ; $26
>ba34	ae aa					.word	GRUndefined              ; $27
>ba36	69 ae					.word	GXPlotPoint              ; $28 Plot
>ba38	76 b1					.word	GXMoveSprite             ; $29 SpriteMove
=3					GXMappingPage = 3
=24576					GXMappingAddress = ($2000 * GXMappingPage)
=11					GXEditSlot = 8 + GXMappingPage
=$36					gxzTemp0 = zTemp0
=$38					gxzTemp1 = zTemp1
=$3a					gxzTemp2 = zTemp2
=$3c					gxzScreen = zsTemp
=$57b					gxPixelBuffer = numberBuffer
.05c5					gxCurrentX:
>05c5							.fill 	2
.05c7					gxCurrentY:
>05c7							.fill 	2
.05c9					gxLastX:
>05c9							.fill 	2
.05cb					gxLastY:
>05cb							.fill 	2
.05cd					gxX0:
>05cd							.fill 	2
.05cf					gxY0:
>05cf							.fill 	2
.05d1					gxX1:
>05d1							.fill 	2
.05d3					gxY1:
>05d3							.fill 	2
.05d5					gxSpritesOn:
>05d5							.fill 	1
.05d6					gxBitmapsOn:
>05d6							.fill 	1
.05d7					gxBasePage:
>05d7							.fill 	1
.05d8					gxSpritePage:
>05d8							.fill 	1
.05d9					gxHeight:
>05d9							.fill 	1
.05da					gxMode:
>05da							.fill 	1
.05db					gxColour:
>05db							.fill 	1
.05dc					gxEORValue:
>05dc							.fill 	1
.05dd					gxANDValue:
>05dd							.fill 	1
.05de					gxOriginalLUTValue:
>05de							.fill 	1
.05df					gsOffset:
>05df							.fill 	1
.05e0					GSCurrentSpriteID:
>05e0							.fill 	1
.05e1					GSCurrentSpriteAddr:
>05e1							.fill 	2
.05e3					GXSpriteOffsetBase:
>05e3							.fill 	2
.05e5					GXSpriteLow:
>05e5							.fill 	64
.0625					GXSpriteHigh:
>0625							.fill 	64
.aa4f					Export_GXGraphicDraw:
.aa4f	c9 40		cmp #$40			cmp 	#GCMD_Move					; low instructions don't use coordinates
.aa51	b0 06		bcs $aa59			bcs 	_GDCoordinate
.aa53	86 36		stx $36				stx 	gxzTemp0 					; save X/Y
.aa55	84 37		sty $37				sty 	gxzTemp0+1
.aa57	80 4b		bra $aaa4			bra 	_GDExecuteA 				; and execute
.aa59					_GDCoordinate:
.aa59	48		pha				pha 								; save AXY
.aa5a	da		phx				phx
.aa5b	5a		phy				phy
.aa5c	a2 03		ldx #$03			ldx 	#3 							; copy currentX to lastX
.aa5e					_GDCopy1:
.aa5e	bd c5 05	lda $05c5,x			lda 	gxCurrentX,x
.aa61	9d c9 05	sta $05c9,x			sta 	gxLastX,x
.aa64	ca		dex				dex
.aa65	10 f7		bpl $aa5e			bpl 	_GDCopy1
.aa67	68		pla				pla 								; update Y
.aa68	8d c7 05	sta $05c7			sta 	gxCurrentY
.aa6b	9c c8 05	stz $05c8			stz 	gxCurrentY+1
.aa6e	68		pla				pla
.aa6f	8d c5 05	sta $05c5			sta 	gxCurrentX
.aa72	68		pla				pla 								; get A (command+X.1) back
.aa73	48		pha				pha
.aa74	29 01		and #$01			and 	#1 							; put LSB as MSB of Current.X
.aa76	8d c6 05	sta $05c6			sta 	gxCurrentX+1
.aa79	68		pla				pla 								; get command back
.aa7a	29 fe		and #$fe			and 	#$FE 						; lose LSB, chuck the stray X bit
.aa7c	48		pha				pha 								; push back.
.aa7d	c9 52		cmp #$52			cmp 	#GCMD_SpriteMove 			; move sprite does not clip.
.aa7f	f0 17		beq $aa98			beq 	_GDCopyToWorkArea
.aa81	ad c6 05	lda $05c6			lda 	gxCurrentX+1 				; X < 256 X okay
.aa84	f0 07		beq $aa8d			beq 	_GDCheckY
.aa86	ad c5 05	lda $05c5			lda 	gxCurrentX 					; otherwise X < 320 = 256 + 64
.aa89	c9 40		cmp #$40			cmp 	#64
.aa8b	b0 08		bcs $aa95			bcs 	_GDError1
.aa8d					_GDCheckY:
.aa8d	ad c7 05	lda $05c7			lda 	gxCurrentY 					; check Y < Height.
.aa90	cd d9 05	cmp $05d9			cmp 	gxHeight
.aa93	90 03		bcc $aa98			bcc 	_GDCopyToWorkArea
.aa95					_GDError1:
.aa95	68		pla				pla
.aa96					_GDError2:
.aa96	38		sec				sec
.aa97	60		rts				rts
.aa98					_GDCopyToWorkArea:
.aa98	a2 07		ldx #$07			ldx 	#7 							; copy current and last to gxXY/12 work area
.aa9a					_GDCopy2:
.aa9a	bd c5 05	lda $05c5,x			lda 	gxCurrentX,x
.aa9d	9d cd 05	sta $05cd,x			sta 	gxX0,x
.aaa0	ca		dex				dex
.aaa1	10 f7		bpl $aa9a			bpl 	_GDCopy2
.aaa3	68		pla				pla 								; get command
.aaa4					_GDExecuteA:
.aaa4	c9 54		cmp #$54			cmp 	#GRFirstFreeCode*2 			; bad ?
.aaa6	b0 ee		bcs $aa96			bcs 	_GDError2
.aaa8	aa		tax				tax
.aaa9	7c e6 b9	jmp ($b9e6,x)			jmp 	(GRVectorTable,x)
.aaac					GXMove:
.aaac	18		clc				clc
.aaad	60		rts				rts
.aaae					GRUndefined:
>aaae	db						.byte 	$DB 						; causes a break in the emulator
.aaaf					GXFillCircle:
.aaaf	a9 ff		lda #$ff			lda 	#255
.aab1	80 02		bra $aab5			bra 	GXCircle
.aab3					GXFrameCircle:
.aab3	a9 00		lda #$00			lda 	#0
.aab5					GXCircle:
.aab5	8d 68 06	sta $0668			sta 	gxIsFillMode					; save Fill flag
.aab8	ad d6 05	lda $05d6			lda 	gxBitmapsOn
.aabb	f0 26		beq $aae3			beq 	_GXCFail
.aabd	20 0e b3	jsr $b30e			jsr 	GXSortXY 					; topleft/bottomright
.aac0	20 e6 b1	jsr $b1e6			jsr 	GXOpenBitmap 				; start drawing
.aac3	20 b5 ab	jsr $abb5			jsr 	GXCircleSetup 				; set up for drawing
.aac6	9c 69 06	stz $0669			stz 	gxYChanged
.aac9					_GXCircleDraw:
.aac9	ad 66 06	lda $0666			lda 	gXCentre					; while x <= y
.aacc	cd 67 06	cmp $0667			cmp 	gYCentre
.aacf	90 0a		bcc $aadb			bcc 	_GXCircleContinue
.aad1	d0 03		bne $aad6			bne 	_GXNoLast
.aad3	20 e8 aa	jsr $aae8			jsr 	GXPlot1
.aad6					_GXNoLast:
.aad6	20 ee b1	jsr $b1ee			jsr 	GXCloseBitmap 				; close the bitmap
.aad9	18		clc				clc
.aada	60		rts				rts
.aadb					_GXCircleContinue:
.aadb	20 e5 aa	jsr $aae5			jsr 	GXPlot2 					; draw it
.aade	20 62 ab	jsr $ab62			jsr 	GXCircleMove 				; adjust the coordinates
.aae1	80 e6		bra $aac9			bra 	_GXCircleDraw
.aae3					_GXCFail:
.aae3	38		sec				sec
.aae4	60		rts				rts
.aae5					GXPlot2:
.aae5	20 e8 aa	jsr $aae8			jsr 	GXPlot1 						; plot and swap, fall through does twice
.aae8					GXPlot1:
.aae8	ad 67 06	lda $0667			lda 	gYCentre 						; if y = 0, don't do it twice (xor)
.aaeb	f0 03		beq $aaf0			beq 	_GXPlot1Only
.aaed	20 0c ab	jsr $ab0c			jsr 	GXPlot0 						; plot and negate
.aaf0					_GXPlot1Only:
.aaf0	20 0c ab	jsr $ab0c			jsr 	GXPlot0 						; twice, undoing negation
.aaf3	ad 66 06	lda $0666			lda 	gXCentre 						; swap X and Y
.aaf6	ae 67 06	ldx $0667			ldx	 	gYCentre
.aaf9	8d 67 06	sta $0667			sta 	gYCentre
.aafc	8e 66 06	stx $0666			stx 	gXCentre
.aaff	ad 69 06	lda $0669			lda 	gxYChanged 						; toggle Y Changed flag
.ab02	a9 ff		lda #$ff			lda 	#$FF
.ab04	8d 69 06	sta $0669			sta 	gxYChanged
.ab07	60		rts				rts
.ab08	20 0c ab	jsr $ab0c			jsr 	GXPlot0 						; do once
.ab0b	60		rts				rts
.ab0c	ad 68 06	lda $0668	GXPlot0:lda 	gxIsFillMode 					; outline mode, always draw as X or Y will change
.ab0f	f0 05		beq $ab16			beq 	_GXPlot0Always
.ab11	ad 69 06	lda $0669			lda 	gxYChanged						; fill mode, only draw if changed.
.ab14	f0 2d		beq $ab43			beq 	GXPlot0Exit
.ab16					_GXPlot0Always:
.ab16	a2 02		ldx #$02			ldx 	#2 								; copy Y1-A => Y0
.ab18	ad 67 06	lda $0667			lda 	gYCentre
.ab1b	20 44 ab	jsr $ab44			jsr 	GXSubCopy
.ab1e	a2 00		ldx #$00			ldx 	#0 								; copy X1-A => X0,
.ab20	ad 66 06	lda $0666			lda 	gXCentre
.ab23	20 44 ab	jsr $ab44			jsr 	GXSubCopy
.ab26	48		pha				pha 									; save last offset X
.ab27	20 f6 b1	jsr $b1f6			jsr 	GXPositionCalc 					; calculate position/offset.
.ab2a	68		pla				pla
.ab2b	0a		asl a				asl 	a 								; store 2 x last offset in gxzTemp0
.ab2c	85 36		sta $36				sta 	gxzTemp0
.ab2e	64 37		stz $37				stz 	gxzTemp0+1
.ab30	26 37		rol $37				rol 	gxzTemp0+1
.ab32	ad 68 06	lda $0668			lda 	gxIsFillMode
.ab35	69 80		adc #$80			adc 	#128
.ab37	20 d4 ae	jsr $aed4			jsr 	GXDrawLineTemp0 				; routine from Rectangle.
.ab3a	38		sec				sec 									; GY = -GY
.ab3b	a9 00		lda #$00			lda 	#0
.ab3d	ed 67 06	sbc $0667			sbc 	gYCentre
.ab40	8d 67 06	sta $0667			sta 	gYCentre
.ab43					GXPlot0Exit:
.ab43	60		rts				rts
.ab44					GXSubCopy:
.ab44	85 36		sta $36				sta 	gxzTemp0
.ab46	64 37		stz $37				stz 	gxzTemp0+1
.ab48	29 80		and #$80			and 	#$80
.ab4a	f0 02		beq $ab4e			beq 	_GXNoSx
.ab4c	c6 37		dec $37				dec 	gxzTemp0+1
.ab4e					_GXNoSx:
.ab4e	38		sec				sec
.ab4f	bd d1 05	lda $05d1,x			lda 	gXX1,x
.ab52	e5 36		sbc $36				sbc 	gxzTemp0
.ab54	9d cd 05	sta $05cd,x			sta 	gXX0,x
.ab57	bd d2 05	lda $05d2,x			lda 	gXX1+1,x
.ab5a	e5 37		sbc $37				sbc 	gxzTemp0+1
.ab5c	9d ce 05	sta $05ce,x			sta 	gXX0+1,x
.ab5f	a5 36		lda $36				lda 	gxzTemp0 						; return A
.ab61	60		rts				rts
.ab62					GXCircleMove:
.ab62	9c 69 06	stz $0669			stz 	gxYChanged 					; clear Y changed flag
.ab65	a5 39		lda $39				lda 	gxzTemp1+1 					; check sign of D
.ab67	10 0d		bpl $ab76			bpl 	_GXEMPositive
.ab69	ee 66 06	inc $0666			inc 	gXCentre 					; X++
.ab6c	ad 66 06	lda $0666			lda 	gXCentre
.ab6f	20 95 ab	jsr $ab95			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.ab72	a9 06		lda #$06			lda 	#6  						; and add 6
.ab74	80 15		bra $ab8b			bra 	_GXEMAddD
.ab76					_GXEMPositive:
.ab76	ee 66 06	inc $0666			inc 	gXCentre					; X++
.ab79	ce 67 06	dec $0667			dec 	gyCentre 					; Y--
.ab7c	38		sec				sec 								; calculate X-Y
.ab7d	ad 66 06	lda $0666			lda 	gXCentre
.ab80	ed 67 06	sbc $0667			sbc 	gYCentre
.ab83	20 95 ab	jsr $ab95			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.ab86	a9 0a		lda #$0a			lda 	#10  						; and add 10
.ab88	ce 69 06	dec $0669			dec 	gxYChanged
.ab8b					_GXEMAddD:
.ab8b	18		clc				clc
.ab8c	65 38		adc $38				adc 	gxzTemp1
.ab8e	85 38		sta $38				sta 	gxzTemp1
.ab90	90 02		bcc $ab94			bcc 	_GXEMNoCarry
.ab92	e6 39		inc $39				inc 	gxzTemp1+1
.ab94					_GXEMNoCarry:
.ab94	60		rts				rts
.ab95					_GXAdd4TimesToD:
.ab95	85 36		sta $36				sta 	gxzTemp0 					; make 16 bit signed.
.ab97	29 80		and #$80			and 	#$80
.ab99	f0 02		beq $ab9d			beq 	_GXA4Unsigned
.ab9b	a9 ff		lda #$ff			lda 	#$FF
.ab9d					_GXA4Unsigned:
.ab9d	85 37		sta $37				sta 	gxzTemp0+1
.ab9f	06 36		asl $36				asl 	gxzTemp0  					; x 4
.aba1	26 37		rol $37				rol 	gxzTemp0+1
.aba3	06 36		asl $36				asl 	gxzTemp0
.aba5	26 37		rol $37				rol 	gxzTemp0+1
.aba7	18		clc				clc 								; add
.aba8	a5 36		lda $36				lda		gxzTemp0
.abaa	65 38		adc $38				adc 	gxzTemp1
.abac	85 38		sta $38				sta 	gxzTemp1
.abae	a5 37		lda $37				lda		gxzTemp0+1
.abb0	65 39		adc $39				adc 	gxzTemp1+1
.abb2	85 39		sta $39				sta 	gxzTemp1+1
.abb4	60		rts				rts
.abb5					GXCircleSetup:
.abb5	38		sec				sec
.abb6	ad d3 05	lda $05d3			lda 	gxY1
.abb9	ed cf 05	sbc $05cf			sbc 	gxY0
.abbc	4a		lsr a				lsr 	a
.abbd	8d 65 06	sta $0665			sta 	gxRadius
.abc0	a2 00		ldx #$00			ldx 	#0
.abc2	20 e4 ab	jsr $abe4			jsr 	_GXCalculateCentre
.abc5	a2 02		ldx #$02			ldx 	#2
.abc7	20 e4 ab	jsr $abe4			jsr 	_GXCalculateCentre
.abca	9c 66 06	stz $0666			stz 	gXCentre
.abcd	ad 65 06	lda $0665			lda 	gxRadius
.abd0	8d 67 06	sta $0667			sta 	gYCentre
.abd3	0a		asl a				asl 	a 							; R x 2
.abd4	85 36		sta $36				sta 	gxzTemp0
.abd6	38		sec				sec
.abd7	a9 03		lda #$03			lda 	#3
.abd9	e5 36		sbc $36				sbc 	gxzTemp0
.abdb	85 38		sta $38				sta 	gxzTemp1
.abdd	a9 00		lda #$00			lda 	#0
.abdf	e9 00		sbc #$00			sbc 	#0
.abe1	85 39		sta $39				sta 	gxzTemp1+1
.abe3	60		rts				rts
.abe4					_GXCalculateCentre:
.abe4	38		sec				sec
.abe5	bd d1 05	lda $05d1,x			lda 	gxX1,x
.abe8	7d cd 05	adc $05cd,x			adc 	gXX0,x
.abeb	9d d1 05	sta $05d1,x			sta 	gXX1,x
.abee	bd d2 05	lda $05d2,x			lda 	gXX1+1,x
.abf1	7d ce 05	adc $05ce,x			adc 	gXX0+1,x
.abf4	4a		lsr a				lsr 	a
.abf5	9d d2 05	sta $05d2,x			sta 	gXX1+1,x
.abf8	7e d1 05	ror $05d1,x			ror 	gXX1,x
.abfb	60		rts				rts
.0665					gxRadius:
>0665							.fill 	1
.0666					gXCentre:
>0666							.fill 	1
.0667					gYCentre:
>0667							.fill 	1
.0668					gxIsFillMode:
>0668							.fill 	1
.0669					gxYChanged:
>0669							.fill  	1
=64000					ScreenSize200 = 320 * 200
=76800					ScreenSize240 = 320 * 240
.abfc					GXClearBitmap:
.abfc	ad d6 05	lda $05d6			lda 	gxBitmapsOn 				; check BMP running.
.abff	f0 24		beq $ac25			beq 	_GXCBFail
.ac01	20 e6 b1	jsr $b1e6			jsr 	GXOpenBitmap 				; start access
.ac04	a0 07		ldy #$07			ldy 	#ScreenSize200 / 8192 		; X is pages to clear
.ac06	ad d9 05	lda $05d9			lda 	gxHeight
.ac09	c9 c8		cmp #$c8			cmp 	#200 						; 200 ?
.ac0b	a0 09		ldy #$09			ldy 	#ScreenSize240 / 8192
.ac0d					_GXCalcLastPage:
.ac0d	98		tya				tya 								; add to base page
.ac0e	18		clc				clc
.ac0f	6d d7 05	adc $05d7			adc 	gxBasePage
.ac12	85 0b		sta $0b				sta 	GXEditSlot  				; clear from this page back
.ac14					_GXClearAll:
.ac14	20 27 ac	jsr $ac27			jsr 	_GXClearBlock 				; clear 8k block
.ac17	c6 0b		dec $0b				dec 	GXEditSlot  				; back to previous
.ac19	a5 0b		lda $0b				lda 	GXEditSlot
.ac1b	cd d7 05	cmp $05d7			cmp 	gxBasePage 					; until before base page
.ac1e	b0 f4		bcs $ac14			bcs 	_GXClearAll
.ac20	20 ee b1	jsr $b1ee			jsr 	GXCloseBitmap	 			; stop access
.ac23	18		clc				clc
.ac24	60		rts				rts
.ac25					_GXCBFail:
.ac25	38		sec				sec
.ac26	60		rts				rts
.ac27					_GXClearBlock:
.ac27	a9 00		lda #$00			lda 	#((GXMappingAddress) & $FF)
.ac29	85 38		sta $38				sta 	0+gxzTemp1
.ac2b	a9 60		lda #$60			lda 	#((GXMappingAddress) >> 8)
.ac2d	85 39		sta $39				sta 	1+gxzTemp1
.ac2f					_GXCB0:
.ac2f	a5 36		lda $36				lda 	gxzTemp0
.ac31	a0 00		ldy #$00			ldy 	#0
.ac33					_GXCB1:
.ac33	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ac35	c8		iny				iny
.ac36	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ac38	c8		iny				iny
.ac39	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ac3b	c8		iny				iny
.ac3c	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ac3e	c8		iny				iny
.ac3f	d0 f2		bne $ac33			bne 	_GXCB1
.ac41	e6 39		inc $39				inc 	gxzTemp1+1
.ac43	a5 39		lda $39				lda 	gxzTemp1+1
.ac45	c9 80		cmp #$80			cmp	 	#(GXMappingAddress >> 8)+$20
.ac47	d0 e6		bne $ac2f			bne 	_GXCB0
.ac49	60		rts				rts
.ac4a					GXInitialise:
.ac4a	64 01		stz $01				stz 	1
.ac4c	a9 01		lda #$01			lda 	#1
.ac4e	8d 00 d0	sta $d000			sta 	$D000
.ac51	18		clc				clc
.ac52	9c d5 05	stz $05d5			stz 	GXSpritesOn
.ac55	9c d6 05	stz $05d6			stz 	GXBitmapsOn
.ac58	a2 0f		ldx #$0f			ldx 	#15
.ac5a					_GXIClear:
.ac5a	9e c5 05	stz $05c5,x			stz 	gxCurrentX,x
.ac5d	ca		dex				dex
.ac5e	10 fa		bpl $ac5a			bpl 	_GXIClear
.ac60	20 fb ac	jsr $acfb			jsr 	GXClearSpriteStore
.ac63	60		rts				rts
.ac64					GXControlBitmap:
.ac64	64 01		stz $01				stz 	1
.ac66	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.ac68	29 01		and #$01			and 	#1 							; set bitmap flag
.ac6a	8d d6 05	sta $05d6			sta 	gxBitmapsOn
.ac6d	4a		lsr a				lsr 	a 							; bit 0 into carry.
.ac6e	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.ac71	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.ac73	29 f7		and #$f7			and 	#$F7 						; clear bitmap bit
.ac75	90 02		bcc $ac79			bcc 	_CBNotOn
.ac77	09 08		ora #$08			ora 	#$08 						; bitmap on if 1 on 0 off
.ac79					_CBNotOn:
.ac79	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.ac7c	a5 36		lda $36				lda 	gxzTemp0 					; get control settings (bits 0-2)
.ac7e	29 07		and #$07			and 	#7
.ac80	8d 00 d1	sta $d100			sta 	$D100 						; write in Vicky Bitmap Control Register #0
.ac83	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.ac85	d0 02		bne $ac89			bne 	_CBNotDefault
.ac87	a9 08		lda #$08			lda 	#8  						; if zero, use 8 e.g. bitmap at $10000
.ac89					_CBNotDefault:
.ac89	8d d7 05	sta $05d7			sta 	gxBasePage
.ac8c	20 ed ac	jsr $aced			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.ac8f	a5 37		lda $37				lda 	gxzTemp0+1 					; copy address into Bitmap address registers
.ac91	8d 03 d1	sta $d103			sta 	$D103
.ac94	a5 36		lda $36				lda 	gxzTemp0
.ac96	8d 02 d1	sta $d102			sta 	$D102
.ac99	9c 01 d1	stz $d101			stz 	$D101
.ac9c	a2 f0		ldx #$f0			ldx 	#240 						; height is 240
.ac9e	ad 01 d0	lda $d001			lda 	$D001 						; read MCR bit 0
.aca1	29 01		and #$01			and 	#1
.aca3	f0 02		beq $aca7			beq 	_CBHaveHeight
.aca5	a2 c8		ldx #$c8			ldx 	#200 						; if bit 0 set 320x200
.aca7					_CBHaveHeight
.aca7	8e d9 05	stx $05d9			stx 	gxHeight
.acaa	18		clc				clc
.acab	60		rts				rts
.acac					GXControlSprite:
.acac	64 01		stz $01				stz 	1
.acae	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.acb0	29 01		and #$01			and 	#1 							; set sprites flag
.acb2	8d d5 05	sta $05d5			sta 	gxSpritesOn
.acb5	4a		lsr a				lsr 	a 							; bit 0 into carry.
.acb6	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.acb9	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.acbb	29 df		and #$df			and 	#$DF 						; clear sprite bit
.acbd	90 02		bcc $acc1			bcc 	_CSNotOn
.acbf	09 20		ora #$20			ora 	#$20 						; sprite on if 1 on 0 off
.acc1					_CSNotOn:
.acc1	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.acc4	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.acc6	d0 02		bne $acca			bne 	_CSNotDefault
.acc8	a9 18		lda #$18			lda 	#24  						; if zero, use 24 e.g. sprites at $30000
.acca					_CSNotDefault:
.acca	8d d8 05	sta $05d8			sta 	gxSpritePage
.accd	20 ed ac	jsr $aced			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.acd0	a5 36		lda $36				lda 	zTemp0
.acd2	8d e3 05	sta $05e3			sta 	GXSpriteOffsetBase
.acd5	a5 37		lda $37				lda 	zTemp0+1
.acd7	8d e4 05	sta $05e4			sta 	GXSpriteOffsetBase+1
.acda	a2 00		ldx #$00			ldx 	#0 							; disable all sprites, clears all sprite memory.
.acdc					_CSClear:
.acdc	9e 00 d9	stz $d900,x			stz 	$D900,x
.acdf	9e 00 da	stz $da00,x			stz 	$DA00,x
.ace2	ca		dex				dex
.ace3	d0 f7		bne $acdc			bne 	_CSClear
.ace5	9c e2 05	stz $05e2			stz 	GSCurrentSpriteAddr+1 		; no sprite selected.
.ace8	20 fb ac	jsr $acfb			jsr 	GXClearSpriteStore
.aceb	18		clc				clc
.acec	60		rts				rts
.aced					GXCalculateBaseAddress:
.aced	85 36		sta $36				sta 	gxzTemp0
.acef	64 37		stz $37				stz 	gxzTemp0+1
.acf1	a9 05		lda #$05			lda 	#5
.acf3					_GXShift:
.acf3	06 36		asl $36				asl 	gxzTemp0
.acf5	26 37		rol $37				rol 	gxzTemp0+1
.acf7	3a		dec a				dec		a
.acf8	d0 f9		bne $acf3			bne 	_GXShift
.acfa	60		rts				rts
.acfb					GXClearSpriteStore:
.acfb	a2 3f		ldx #$3f			ldx 	#63 						; erase 64 sprite store elements
.acfd					_GXCSSLoop:
.acfd	9e 25 06	stz $0625,x			stz 	GXSpriteHigh,x
.ad00	a9 80		lda #$80			lda 	#$80 						; set the 'hidden' bit.
.ad02	9d e5 05	sta $05e5,x			sta 	GXSpriteLow,x
.ad05	ca		dex				dex
.ad06	10 f5		bpl $acfd			bpl 	_GXCSSLoop
.ad08	60		rts				rts
.ad09					GXLine:
.ad09	ad d6 05	lda $05d6			lda 	GXBitmapsOn
.ad0c	f0 28		beq $ad36			beq 	_GXLFail
.ad0e	20 e6 b1	jsr $b1e6			jsr 	GXOpenBitmap
.ad11	20 2c b3	jsr $b32c			jsr 	GXSortY						; sort pairs so Y1 >= Y0 e.g. top to bottom.
.ad14	20 dc ad	jsr $addc			jsr 	GXLineSetup 				; the calculations in the linescanner constructor
.ad17	20 f6 b1	jsr $b1f6			jsr 	GXPositionCalc 				; calculate position/offset.
.ad1a					_GXDrawLoop:
.ad1a	ac df 05	ldy $05df			ldy 	gsOffset 					; draw the pixel
.ad1d	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.ad1f	2d dd 05	and $05dd			and 	gxANDValue
.ad22	4d dc 05	eor $05dc			eor 	gxEORValue
.ad25	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.ad27	20 38 ad	jsr $ad38			jsr 	GXLineIsComplete 			; is the line complete ?
.ad2a	f0 05		beq $ad31			beq 	_GXLExit
.ad2c	20 53 ad	jsr $ad53			jsr 	GXLineAdvance 				; code as per advance method
.ad2f	80 e9		bra $ad1a			bra 	_GXDrawLoop
.ad31					_GXLExit:
.ad31	20 ee b1	jsr $b1ee			jsr 	GXCloseBitmap
.ad34	18		clc				clc
.ad35	60		rts				rts
.ad36					_GXLFail:
.ad36	38		sec				sec
.ad37	60		rts				rts
.ad38					GXLineIsComplete:
.ad38	ad 6c 06	lda $066c			lda 	GXIsDiffYLarger 			; is dy larger
.ad3b	d0 0f		bne $ad4c			bne 	_GXLICCompareY 				; if so compare Y1/Y0
.ad3d	ad cd 05	lda $05cd			lda 	GXX0 						; compare X, LSB and MSB
.ad40	4d d1 05	eor $05d1			eor 	GXX1
.ad43	d0 06		bne $ad4b			bne 	_GXLICExit
.ad45	ad ce 05	lda $05ce			lda 	GXX0+1
.ad48	4d d2 05	eor $05d2			eor 	GXX1+1
.ad4b					_GXLICExit:
.ad4b	60		rts				rts
.ad4c					_GXLICCompareY:
.ad4c	ad d3 05	lda $05d3			lda 	GXY1
.ad4f	4d cf 05	eor $05cf			eor 	GXY0
.ad52	60		rts				rts
.ad53					GXLineAdvance:
.ad53	18		clc				clc 								; add adjust to position
.ad54	ad 6e 06	lda $066e			lda 	GXPosition
.ad57	6d 6f 06	adc $066f			adc 	GXAdjust
.ad5a	8d 6e 06	sta $066e			sta 	GXPosition
.ad5d	9c 71 06	stz $0671			stz 	GXAddSelect 				; clear add select flag
.ad60	b0 05		bcs $ad67			bcs 	_GXLAOverflow 				; if carry out, overflowed.
.ad62	cd 70 06	cmp $0670			cmp 	GXTotal 					; if exceeded total
.ad65	90 0a		bcc $ad71			bcc 	_GXLANoExtra
.ad67					_GXLAOverflow:
.ad67	ce 71 06	dec $0671			dec 	GXAddSelect 				; set addselect to $FF
.ad6a	38		sec				sec 								; subtract total and write back
.ad6b	ed 70 06	sbc $0670			sbc 	GXTotal
.ad6e	8d 6e 06	sta $066e			sta 	GXPosition
.ad71					_GXLANoExtra:
.ad71	ad 6c 06	lda $066c			lda 	GXIsDiffYLarger
.ad74	f0 0d		beq $ad83			beq 	_GXDXLarger
.ad76	20 d5 ad	jsr $add5			jsr 	GXIncrementY
.ad79	ad 71 06	lda $0671			lda 	GXAddSelect
.ad7c	f0 10		beq $ad8e			beq 	_GXLAExit
.ad7e	20 8f ad	jsr $ad8f			jsr 	GXAdjustX
.ad81	80 0b		bra $ad8e			bra 	_GXLAExit
.ad83					_GXDXLarger:
.ad83	20 8f ad	jsr $ad8f			jsr 	GXAdjustX
.ad86	ad 71 06	lda $0671			lda 	GXAddSelect
.ad89	f0 03		beq $ad8e			beq 	_GXLAExit
.ad8b	20 d5 ad	jsr $add5			jsr 	GXIncrementY
.ad8e					_GXLAExit:
.ad8e	60		rts				rts
.ad8f					GXAdjustX:
.ad8f	ad 6d 06	lda $066d			lda 	GXDXNegative
.ad92	10 25		bpl $adb9			bpl 	_GXAXRight
.ad94	ad cd 05	lda $05cd			lda 	GXX0
.ad97	d0 03		bne $ad9c			bne 	_GXAXNoBorrow
.ad99	ce ce 05	dec $05ce			dec 	GXX0+1
.ad9c					_GXAXNoBorrow:
.ad9c	ce cd 05	dec $05cd			dec 	GXX0
.ad9f	ce df 05	dec $05df			dec 	gsOffset 					; pixel left
.ada2	ad df 05	lda $05df			lda 	gsOffset
.ada5	c9 ff		cmp #$ff			cmp 	#$FF
.ada7	d0 0f		bne $adb8			bne 	_GXAYExit 					; underflow
.ada9	c6 3d		dec $3d				dec 	gxzScreen+1 					; borrow
.adab	a5 3d		lda $3d				lda 	gxzScreen+1 					; gone off page
.adad	c9 60		cmp #$60			cmp 	#GXMappingAddress >> 8
.adaf	b0 07		bcs $adb8			bcs 	_GXAYExit
.adb1	18		clc				clc
.adb2	69 20		adc #$20			adc 	#$20 						; fix up
.adb4	85 3d		sta $3d				sta 	gxzScreen+1
.adb6	c6 0b		dec $0b				dec 	GXEditSlot 				; back one page
.adb8					_GXAYExit:
.adb8	60		rts				rts
.adb9					_GXAXRight:
.adb9	ee cd 05	inc $05cd			inc 	GXX0
.adbc	d0 03		bne $adc1			bne 	_GXAXNoCarry
.adbe	ee ce 05	inc $05ce			inc 	GXX0+1
.adc1					_GXAXNoCarry:
.adc1	ee df 05	inc $05df			inc 	gsOffset 					; pixel right
.adc4	d0 0e		bne $add4			bne 	_GXAXExit 					; if not overflowed, exit.
.adc6	e6 3d		inc $3d				inc 	gxzScreen+1 					; next line
.adc8	a5 3d		lda $3d				lda 	gxzScreen+1
.adca	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.adcc	90 06		bcc $add4			bcc 	_GXAXExit
.adce	e9 20		sbc #$20			sbc 	#$20 						; fix up
.add0	85 3d		sta $3d				sta 	gxzScreen+1
.add2	e6 0b		inc $0b				inc 	GXEditSlot 				; next page
.add4					_GXAXExit:
.add4	60		rts				rts
.add5					GXIncrementY:
.add5	ee cf 05	inc $05cf			inc 	GXY0
.add8	20 4c b2	jsr $b24c			jsr 	GXMovePositionDown
.addb	60		rts				rts
.addc					GXLineSetup:
.addc	ad d3 05	lda $05d3			lda 	GXY1
.addf	38		sec				sec
.ade0	ed cf 05	sbc $05cf			sbc 	GXY0
.ade3	4a		lsr a				lsr 	a
.ade4	8d 6b 06	sta $066b			sta 	GXDiffY
.ade7	9c 6d 06	stz $066d			stz 	GXDXNegative 				; clear -ve flag
.adea	38		sec				sec
.adeb	ad d1 05	lda $05d1			lda 	GXX1
.adee	ed cd 05	sbc $05cd			sbc 	GXX0
.adf1	8d 6a 06	sta $066a			sta 	GXDiffX
.adf4	ad d2 05	lda $05d2			lda 	GXX1+1 						; calculate MSB
.adf7	ed ce 05	sbc $05ce			sbc 	GXX0+1
.adfa	6a		ror a				ror 	a 							; rotate bit into DiffX halving it
.adfb	6e 6a 06	ror $066a			ror 	GXDiffX
.adfe	0a		asl a				asl 	a
.adff	10 0c		bpl $ae0d			bpl 	_GDXNotNegative
.ae01	a9 00		lda #$00			lda 	#0 							; make absolute value of |dx|
.ae03	38		sec				sec
.ae04	ed 6a 06	sbc $066a			sbc 	GXDiffX
.ae07	8d 6a 06	sta $066a			sta 	GXDiffX
.ae0a	ce 6d 06	dec $066d			dec 	GXDXNegative 				; -ve flag = $FF.
.ae0d					_GDXNotNegative:
.ae0d	9c 6c 06	stz $066c			stz 	GXIsDiffYLarger 			; clear larger flag
.ae10	ad 6b 06	lda $066b			lda 	GXDiffY 					; set adjust and total.
.ae13	8d 6f 06	sta $066f			sta 	GXAdjust
.ae16	ad 6a 06	lda $066a			lda 	GXDiffX
.ae19	8d 70 06	sta $0670			sta 	GXTotal
.ae1c	ad 6b 06	lda $066b			lda 	GXDiffY 					; if dy > dx
.ae1f	cd 6a 06	cmp $066a			cmp 	GXDiffX
.ae22	90 0f		bcc $ae33			bcc 	_GDXNotLarger
.ae24	ce 6c 06	dec $066c			dec 	GXIsDiffYLarger 			; set the dy larger flag
.ae27	ad 6a 06	lda $066a			lda 	GXDiffX 					; set adjust and total other way round
.ae2a	8d 6f 06	sta $066f			sta 	GXAdjust
.ae2d	ad 6b 06	lda $066b			lda 	GXDiffY
.ae30	8d 70 06	sta $0670			sta 	GXTotal
.ae33					_GDXNotLarger:
.ae33	ad 70 06	lda $0670			lda 	GXTotal
.ae36	4a		lsr a				lsr 	a
.ae37	8d 6e 06	sta $066e			sta 	GXPosition
.ae3a	60		rts				rts
.066a					GXDiffX:
>066a							.fill 	1
.066b					GXDiffY:
>066b							.fill 	1
.066c					GXIsDiffYLarger:
>066c							.fill 	1
.066d					GXDXNegative:
>066d							.fill 	1
.066e					GXPosition:
>066e							.fill 	1
.066f					GXAdjust:
>066f							.fill 	1
.0670					GXTotal:
>0670							.fill 	1
.0671					GXAddSelect:
>0671							.fill 	1
.ae3b					GXSetColourMode:
.ae3b	a6 36		ldx $36				ldx 	gxzTemp0
.ae3d	8e db 05	stx $05db			stx 	gxColour 								; set colour
.ae40	a5 37		lda $37				lda 	gxzTemp0+1 								;
.ae42	8d da 05	sta $05da			sta 	gxMode 									; set mode
.ae45	29 03		and #$03			and 	#3 										; only interested in bits 0-3
.ae47	9c dd 05	stz $05dd			stz 	gxANDValue 								; initially AND with 0, and EOR with Colour
.ae4a	ae db 05	ldx $05db			ldx 	gxColour
.ae4d	8e dc 05	stx $05dc			stx 	gxEORValue
.ae50	c9 02		cmp #$02			cmp 	#2 										; if mode 2/3 And with colour
.ae52	90 03		bcc $ae57			bcc 	_GXSDCNotAndColour
.ae54	8e dd 05	stx $05dd			stx 	gxANDValue
.ae57					_GXSDCNotAndColour:
.ae57	d0 03		bne $ae5c			bne 	_GXSDCNotAnd 							; mode 2, Don't EOR with colour
.ae59	9c dc 05	stz $05dc			stz 	gxEORValue
.ae5c					_GXSDCNotAnd:
.ae5c	4a		lsr a				lsr 	a 										; if bit 0 set, 1's complement AND value
.ae5d	90 08		bcc $ae67			bcc 	_GXSDCNoFlip
.ae5f	ad dd 05	lda $05dd			lda	 	gxANDValue
.ae62	49 ff		eor #$ff			eor 	#$FF
.ae64	8d dd 05	sta $05dd			sta 	gxANDValue
.ae67					_GXSDCNoFlip:
.ae67	18		clc				clc
.ae68	60		rts				rts
.ae69					GXPlotPoint:
.ae69	20 e6 b1	jsr $b1e6			jsr 	GXOpenBitmap 				; start drawing
.ae6c	20 f6 b1	jsr $b1f6			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.ae6f	ac df 05	ldy $05df			ldy 	gsOffset
.ae72	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.ae74	2d dd 05	and $05dd			and 	gxANDValue
.ae77	4d dc 05	eor $05dc			eor 	gxEORValue
.ae7a	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.ae7c	20 ee b1	jsr $b1ee			jsr 	GXCloseBitmap 				; stop drawing and exit
.ae7f	18		clc				clc
.ae80	60		rts				rts
.ae81					GXFillRectangle:
.ae81	38		sec				sec
.ae82	80 01		bra $ae85			bra 	GXRectangle
.ae84					GXFrameRectangle:
.ae84	18		clc				clc
.ae85					GXRectangle:
.ae85	ad d6 05	lda $05d6			lda 	gxBitmapsOn
.ae88	f0 35		beq $aebf			beq 	_GXRFail
.ae8a	08		php				php 								; save Fill flag (CS)
.ae8b	20 e6 b1	jsr $b1e6			jsr 	GXOpenBitmap 				; start drawing
.ae8e	20 0e b3	jsr $b30e			jsr 	GXSortXY 					; sort both X and Y so top left/bottom right
.ae91	20 f6 b1	jsr $b1f6			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.ae94	38		sec				sec 								; sec = Draw line
.ae95	20 c1 ae	jsr $aec1			jsr 	GXDrawLineX1X0 				; draw a line length X1-X0
.ae98	ad cf 05	lda $05cf			lda 	gxY0 						; reached end of rectangle ?
.ae9b	cd d3 05	cmp $05d3			cmp 	gxY1
.ae9e	f0 19		beq $aeb9			beq 	_GXRectangleExit
.aea0					_GXRectLoop:
.aea0	20 4c b2	jsr $b24c			jsr 	GXMovePositionDown 			; down one.
.aea3	ee cf 05	inc $05cf			inc 	gxY0 						; change Y pos
.aea6	ad cf 05	lda $05cf			lda 	gxY0 						; reached last line
.aea9	cd d3 05	cmp $05d3			cmp 	gXY1
.aeac	f0 07		beq $aeb5			beq 	_GXLastLine
.aeae	28		plp				plp 								; get flag back
.aeaf	08		php				php
.aeb0	20 c1 ae	jsr $aec1			jsr 	GXDrawLineX1X0 				; draw horizontal line
.aeb3	80 eb		bra $aea0			bra 	_GXRectLoop
.aeb5					_GXLastLine:
.aeb5	38		sec				sec
.aeb6	20 c1 ae	jsr $aec1			jsr 	GXDrawLineX1X0
.aeb9					_GXRectangleExit:
.aeb9	68		pla				pla 								; throw fill flag.
.aeba	20 ee b1	jsr $b1ee			jsr 	GXCloseBitmap 				; stop drawing and exit
.aebd	18		clc				clc
.aebe	60		rts				rts
.aebf					_GXRFail:
.aebf	38		sec				sec
.aec0	60		rts				rts
.aec1					GXDrawLineX1X0:
.aec1	08		php				php 								; save solid/either-end
.aec2	38		sec				sec
.aec3	ad d1 05	lda $05d1			lda		gXX1
.aec6	ed cd 05	sbc $05cd			sbc 	gXX0
.aec9	85 36		sta $36				sta 	gxzTemp0
.aecb	ad d2 05	lda $05d2			lda 	gXX1+1
.aece	ed ce 05	sbc $05ce			sbc 	gXX0+1
.aed1	85 37		sta $37				sta 	gxzTemp0+1
.aed3	28		plp				plp
.aed4					GXDrawLineTemp0:
.aed4	a5 3c		lda $3c				lda 	gxzScreen 						; push gxzScreen, gsOffset and GXEditSlot on stack
.aed6	48		pha				pha
.aed7	a5 3d		lda $3d				lda 	gxzScreen+1
.aed9	48		pha				pha
.aeda	ad df 05	lda $05df			lda 	gsOffset
.aedd	48		pha				pha
.aede	a5 0b		lda $0b				lda 	GXEditSlot
.aee0	48		pha				pha
.aee1	ac df 05	ldy $05df			ldy 	gsOffset 					; Y offset
.aee4	90 1e		bcc $af04			bcc 	_GXDLTEndPoints 			; if CC draw end points only.
.aee6					_GXDLTLine:
.aee6	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.aee8	2d dd 05	and $05dd			and 	gxANDValue
.aeeb	4d dc 05	eor $05dc			eor 	gxEORValue
.aeee	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.aef0	a5 36		lda $36				lda 	gxzTemp0 					; decrement counter
.aef2	d0 04		bne $aef8			bne 	_GXDLTNoBorrow
.aef4	c6 37		dec $37				dec 	gxzTemp0+1 					; borrow, if goes -ve then exit
.aef6	30 2e		bmi $af26			bmi 	_GXDLTExit
.aef8					_GXDLTNoBorrow:
.aef8	c6 36		dec $36				dec 	gxzTemp0
.aefa	c8		iny				iny 								; next slot.
.aefb	d0 e9		bne $aee6			bne 	_GXDLTLine
.aefd	e6 3d		inc $3d				inc 	gxzScreen+1 					; carry to next
.aeff	20 34 af	jsr $af34			jsr 	GXDLTCheckWrap				; check for new page.
.af02	80 e2		bra $aee6			bra 	_GXDLTLine
.af04					_GXDLTEndPoints:
.af04	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.af06	2d dd 05	and $05dd			and 	gxANDValue
.af09	4d dc 05	eor $05dc			eor 	gxEORValue
.af0c	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.af0e	98		tya				tya 								; advance to right side
.af0f	18		clc				clc
.af10	65 36		adc $36				adc 	gxzTemp0
.af12	a8		tay				tay
.af13	a5 3d		lda $3d				lda 	gxzScreen+1
.af15	65 37		adc $37				adc 	gxzTemp0+1
.af17	85 3d		sta $3d				sta 	gxzScreen+1
.af19	20 34 af	jsr $af34			jsr 	GXDLTCheckWrap 			; fix up.
.af1c	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.af1e	2d dd 05	and $05dd			and 	gxANDValue
.af21	4d dc 05	eor $05dc			eor 	gxEORValue
.af24	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.af26					_GXDLTExit:
.af26	68		pla				pla
.af27	85 0b		sta $0b				sta 	GXEditSlot
.af29	68		pla				pla
.af2a	8d df 05	sta $05df			sta 	gsOffset
.af2d	68		pla				pla
.af2e	85 3d		sta $3d				sta 	gxzScreen+1
.af30	68		pla				pla
.af31	85 3c		sta $3c				sta 	gxzScreen
.af33	60		rts				rts
.af34					GXDLTCheckWrap:
.af34	a5 3d		lda $3d				lda 	gxzScreen+1 					; check end of page
.af36	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8)
.af38	90 06		bcc $af40			bcc 	_GXDLTCWExit
.af3a	e9 20		sbc #$20			sbc 	#$20 						; fix up
.af3c	85 3d		sta $3d				sta 	gxzScreen+1
.af3e	e6 0b		inc $0b				inc 	GXEditSlot
.af40					_GXDLTCWExit:
.af40	60		rts				rts
.af41					GXDrawGraphicElement:
.af41	8d 72 06	sta $0672			sta 	gxSize 						; save size
.af44	3a		dec a				dec 	a
.af45	8d 73 06	sta $0673			sta 	gxMask 						; and mask
.af48	ad d6 05	lda $05d6			lda 	gxBitmapsOn 				; check BMP on
.af4b	f0 67		beq $afb4			beq 	_GXSLFail
.af4d	ad cf 05	lda $05cf			lda 	gxY0 						; push Y on stack
.af50	48		pha				pha
.af51	8c 75 06	sty $0675			sty 	gxAcquireVector+1 			; and acquisition vector
.af54	8e 74 06	stx $0674			stx 	gxAcquireVector
.af57	20 e6 b1	jsr $b1e6			jsr 	gxOpenBitmap 				; open the bitmap.
.af5a	ad 77 06	lda $0677			lda 	gxUseMode 					; scale bits
.af5d	4a		lsr a				lsr 	a
.af5e	4a		lsr a				lsr 	a
.af5f	4a		lsr a				lsr 	a
.af60	29 07		and #$07			and		#7
.af62	1a		inc a				inc 	a
.af63	8d 76 06	sta $0676			sta 	gxScale
.af66	64 38		stz $38				stz 	gxzTemp1					; start first line
.af68					_GXGELoop:
.af68	a5 38		lda $38				lda 	gxzTemp1 					; current line number to read.
.af6a	2c 77 06	bit $0677			bit 	gxUseMode 					; check for flip.
.af6d	10 06		bpl $af75			bpl		_GXNoVFlip
.af6f	ad 73 06	lda $0673			lda 	gxMask
.af72	38		sec				sec
.af73	e5 38		sbc $38				sbc 	gxzTemp1
.af75					_GXNoVFlip:
.af75	aa		tax				tax 								; get the Xth line.
.af76	20 b6 af	jsr $afb6			jsr 	_GXCallAcquire 				; get that data.
.af79	ad 76 06	lda $0676			lda 	gxScale 					; do scale identical copies of that line.
.af7c	85 39		sta $39				sta 	gxzTemp1+1
.af7e					_GXGELoop2:
.af7e	ad cf 05	lda $05cf			lda 	gxY0 						; off screen
.af81	cd d9 05	cmp $05d9			cmp 	gxHeight
.af84	b0 10		bcs $af96			bcs 	_GXDGEExit
.af86	20 b9 af	jsr $afb9			jsr 	GXRenderOneLine 			; render line
.af89	c6 39		dec $39				dec 	gxzTemp1+1 					; scale times.
.af8b	d0 f1		bne $af7e			bne 	_GXGELoop2
.af8d	e6 38		inc $38				inc 	gxzTemp1 					; done all lines.
.af8f	a5 38		lda $38				lda 	gxzTemp1
.af91	cd 72 06	cmp $0672			cmp 	gxSize
.af94	d0 d2		bne $af68			bne 	_GXGELoop
.af96					_GXDGEExit:
.af96	68		pla				pla 								; restore Y for next time
.af97	8d cf 05	sta $05cf			sta 	gxY0
.af9a	ae 76 06	ldx $0676			ldx 	gxScale 					; get scale (1-8)
.af9d					_GXShiftLeft:
.af9d	18		clc				clc
.af9e	ad 72 06	lda $0672			lda 	gxSize
.afa1	6d cd 05	adc $05cd			adc 	gxX0
.afa4	8d cd 05	sta $05cd			sta 	gxX0
.afa7	90 03		bcc $afac			bcc 	_GXSLNoCarry
.afa9	ee ce 05	inc $05ce			inc 	gxX0+1
.afac					_GXSLNoCarry:
.afac	ca		dex				dex
.afad	d0 ee		bne $af9d			bne 	_GXShiftLeft
.afaf	20 ee b1	jsr $b1ee			jsr 	GXCloseBitmap
.afb2	18		clc				clc
.afb3	60		rts				rts
.afb4					_GXSLFail:
.afb4	38		sec				sec
.afb5	60		rts				rts
.afb6					_GXCallAcquire:
.afb6	6c 74 06	jmp ($0674)			jmp 	(gxAcquireVector)
.afb9					GXRenderOneLine:
.afb9	20 f6 b1	jsr $b1f6			jsr 	GXPositionCalc 				; calculate position/offset.
.afbc	ac df 05	ldy $05df			ldy 	gsOffset 					; Y contains position.
.afbf	64 3a		stz $3a				stz 	gxzTemp2 					; do size pixels
.afc1					_GXROLLoop1:
.afc1	ad 76 06	lda $0676			lda 	gxScale 					; set to do 'scale' times
.afc4	85 3b		sta $3b				sta 	gxzTemp2+1
.afc6					_GXROLLoop2:
.afc6	a5 3a		lda $3a				lda 	gxzTemp2 					; get current pixel
.afc8	2c da 05	bit $05da			bit 	gxMode 						; check H Flip
.afcb	50 06		bvc $afd3			bvc 	_GXNoHFlip
.afcd	ad 73 06	lda $0673			lda 	gxMask
.afd0	38		sec				sec
.afd1	e5 3a		sbc $3a				sbc 	gxzTemp2
.afd3					_GXNoHFlip:
.afd3	aa		tax				tax 								; read from the pixel buffer
.afd4	bd 7b 05	lda $057b,x			lda 	gxPixelBuffer,x
.afd7	d0 07		bne $afe0			bne 	_GXDraw 					; draw if non zero
.afd9	ad 77 06	lda $0677			lda 	gxUseMode 					; check to see if solid background
.afdc	29 04		and #$04			and 	#4
.afde	f0 0a		beq $afea			beq 	_GXZeroPixel
.afe0					_GXDraw:
.afe0	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.afe2	2d dd 05	and $05dd			and 	gxANDValue
.afe5	5d 7b 05	eor $057b,x			eor 	gxPixelBuffer,x
.afe8	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.afea					_GXZeroPixel:
.afea	c8		iny				iny 								; advance pointer
.afeb	d0 05		bne $aff2			bne 	_GXNoShift
.afed	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.afef	20 34 af	jsr $af34			jsr 	GXDLTCheckWrap				; check for new page.
.aff2					_GXNoShift:
.aff2	c6 3b		dec $3b				dec 	gxzTemp2+1 					; do the inner loop gxScale times.
.aff4	d0 d0		bne $afc6			bne 	_GXROLLoop2
.aff6	e6 3a		inc $3a				inc 	gxzTemp2 					; next pixel.
.aff8	a5 3a		lda $3a				lda 	gxzTemp2
.affa	cd 72 06	cmp $0672			cmp 	gxSize
.affd	d0 c2		bne $afc1			bne 	_GXROLLoop1
.afff	ee cf 05	inc $05cf			inc 	gxY0
.b002	60		rts				rts
.0672					gxSize:
>0672							.fill 	1
.0673					gxMask:
>0673							.fill 	1
.0674					gxAcquireVector:
>0674							.fill 	2
.0676					gxScale:
>0676							.fill 	1
.0677					gxUseMode:
>0677							.fill 	1
.b003					GXFontHandler:
.b003	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b005	4d da 05	eor $05da			eor 	gxMode
.b008	8d 77 06	sta $0677			sta 	gxUseMode
.b00b	64 37		stz $37				stz 	gxzTemp0+1 					; gxzTemp0 is font #
.b00d	06 36		asl $36				asl	 	gxzTemp0 					; x 2
.b00f	26 37		rol $37				rol	 	gxzTemp0+1
.b011	06 36		asl $36				asl	 	gxzTemp0 					; x 4
.b013	26 37		rol $37				rol	 	gxzTemp0+1
.b015	06 36		asl $36				asl	 	gxzTemp0 					; x 8
.b017	26 37		rol $37				rol	 	gxzTemp0+1
.b019	a5 37		lda $37				lda 	gxzTemp0+1 					; put in page C0
.b01b	09 c0		ora #$c0			ora 	#$C0
.b01d	85 37		sta $37				sta 	gxzTemp0+1
.b01f	a9 08		lda #$08			lda 	#8 							; size 8x8
.b021	a2 29		ldx #$29			ldx 	#GXGetGraphicDataFont & $FF ; XY = Graphic Data retrieval routine
.b023	a0 b0		ldy #$b0			ldy 	#GXGetGraphicDataFont >> 8
.b025	20 41 af	jsr $af41			jsr 	GXDrawGraphicElement
.b028	60		rts				rts
.b029					GXGetGraphicDataFont:
.b029	8a		txa				txa 								; X->Y
.b02a	a8		tay				tay
.b02b	a6 01		ldx $01				ldx 	1 							; preserve old value
.b02d	a9 01		lda #$01			lda 	#1 							; access page 1 (font memory)
.b02f	85 01		sta $01				sta 	1
.b031	b1 36		lda ($36),y			lda 	(gxzTemp0),y 				; read the font element.
.b033	86 01		stx $01				stx 	1 							; put old value back.
.b035	a2 00		ldx #$00			ldx 	#0 							; do 8 times
.b037					_GXExpand:
.b037	9e 7b 05	stz $057b,x			stz 	gxPixelBuffer,x 			; zero in pixel buffer
.b03a	0a		asl a				asl 	a 							; shift bit 7 into C
.b03b	90 08		bcc $b045			bcc 	_GXNoPixel
.b03d	48		pha				pha 								; if set, set pixel buffer to current colour.
.b03e	ad db 05	lda $05db			lda 	gxColour
.b041	9d 7b 05	sta $057b,x			sta 	gxPixelBuffer,x
.b044	68		pla				pla
.b045					_GXNoPixel:
.b045	e8		inx				inx 								; do the whole byte.
.b046	e0 08		cpx #$08			cpx 	#8
.b048	d0 ed		bne $b037			bne 	_GXExpand
.b04a	60		rts				rts
.b04b					GXSpriteHandler:
.b04b	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b04d	4d da 05	eor $05da			eor 	gxMode
.b050	8d 77 06	sta $0677			sta 	gxUseMode
.b053	a6 36		ldx $36				ldx 	gxzTemp0 					; sprite #
.b055	da		phx				phx
.b056	20 e6 b1	jsr $b1e6			jsr 	GXOpenBitmap 				; can access sprite information
.b059	68		pla				pla
.b05a	20 c7 b2	jsr $b2c7			jsr 	GXFindSprite 				; get the sprite address
.b05d	08		php				php
.b05e	20 ee b1	jsr $b1ee			jsr 	GXCloseBitmap
.b061	28		plp				plp
.b062	b0 0a		bcs $b06e			bcs		_GXSHExit 					; exit if find failed.
.b064	ad 78 06	lda $0678			lda 	GXSizePixels 				; return size
.b067	a2 6f		ldx #$6f			ldx 	#GXSpriteAcquire & $FF
.b069	a0 b0		ldy #$b0			ldy 	#GXSpriteAcquire >> 8
.b06b	20 41 af	jsr $af41			jsr 	GXDrawGraphicElement
.b06e					_GXSHExit:
.b06e	60		rts				rts
.b06f					GXSpriteAcquire:
.b06f	ad d8 05	lda $05d8			lda 	GXSpritePage				; point to base page
.b072	85 0b		sta $0b				sta 	GXEditSlot
.b074	86 36		stx $36				stx 	zTemp0 						; row number x 1,2,3,4
.b076	a9 00		lda #$00			lda 	#0
.b078	ae 79 06	ldx $0679			ldx 	GXSizeBits
.b07b					_GXTimesRowNumber:
.b07b	18		clc				clc
.b07c	65 36		adc $36				adc 	zTemp0
.b07e	ca		dex				dex
.b07f	10 fa		bpl $b07b			bpl 	_GXTimesRowNumber
.b081	64 37		stz $37				stz 	gxzTemp0+1
.b083	0a		asl a				asl 	a 							; row x 2,4,6,8
.b084	26 37		rol $37				rol 	gxzTemp0+1
.b086	0a		asl a				asl 	a 							; row x 4,8,12,16
.b087	26 37		rol $37				rol 	gxzTemp0+1
.b089	0a		asl a				asl 	a 							; row x 8,16,24,32
.b08a	26 37		rol $37				rol 	gxzTemp0+1
.b08c	85 36		sta $36				sta 	gxzTemp0
.b08e	18		clc				clc 								; add base address.
.b08f	a5 36		lda $36				lda 	gxzTemp0
.b091	6d 7b 06	adc $067b			adc 	GXSpriteOffset
.b094	85 36		sta $36				sta 	gxzTemp0
.b096	a5 37		lda $37				lda 	gxzTemp0+1
.b098	6d 7c 06	adc $067c			adc 	GXSpriteOffset+1
.b09b					_GXSAFindPage:
.b09b	c9 20		cmp #$20			cmp 	#$20 						; on this page
.b09d	90 06		bcc $b0a5			bcc 	_GXSAFoundPage
.b09f	e9 20		sbc #$20			sbc 	#$20 						; forward one page
.b0a1	e6 0b		inc $0b				inc 	GXEditSlot
.b0a3	80 f6		bra $b09b			bra 	_GXSAFindPage
.b0a5					_GXSAFoundPage:
.b0a5	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; physical address of page.
.b0a7	85 37		sta $37				sta 	gxzTemp0+1 					; gxzTemp0 now points to the page
.b0a9	a0 00		ldy #$00			ldy 	#0
.b0ab					_GXSACopyLoop:
.b0ab	b1 36		lda ($36),y			lda 	(gxzTemp0),y
.b0ad	99 7b 05	sta $057b,y			sta 	gxPixelBuffer,y
.b0b0	c8		iny				iny
.b0b1	cc 78 06	cpy $0678			cpy 	GXSizePixels
.b0b4	d0 f5		bne $b0ab			bne 	_GXSACopyLoop
.b0b6	60		rts				rts
.b0b7					GXSelect:
.b0b7	ad d5 05	lda $05d5			lda 	gxSpritesOn
.b0ba	f0 22		beq $b0de			beq 	_GXSFail
.b0bc	a5 36		lda $36				lda 	gxzTemp0 					; illegal sprite #
.b0be	c9 40		cmp #$40			cmp 	#64
.b0c0	b0 1c		bcs $b0de			bcs 	_GXSFail
.b0c2	8d e0 05	sta $05e0			sta 	GSCurrentSpriteID
.b0c5	a4 37		ldy $37				ldy 	gxzTemp0+1 					; control value.
.b0c7	a9 00		lda #$00			lda  	#0 							; multiply sprite # x 8 => A
.b0c9	06 36		asl $36				asl 	gxzTemp0
.b0cb	06 36		asl $36				asl 	gxzTemp0
.b0cd	06 36		asl $36				asl 	gxzTemp0
.b0cf	2a		rol a				rol 	a
.b0d0	69 d9		adc #$d9			adc 	#$D9 						; sprite area
.b0d2	8d e2 05	sta $05e2			sta 	GSCurrentSpriteAddr+1 		; address to GSCurrentSprite and gxzTemp
.b0d5	85 37		sta $37				sta 	gxzTemp0+1
.b0d7	a5 36		lda $36				lda 	gxzTemp0
.b0d9	8d e1 05	sta $05e1			sta 	GSCurrentSpriteAddr
.b0dc	18		clc				clc
.b0dd	60		rts				rts
.b0de					_GXSFail:
.b0de	38		sec				sec
.b0df	60		rts				rts
.b0e0					GXSelectImage:
.b0e0	ad d5 05	lda $05d5			lda 	gxSpritesOn
.b0e3	f0 74		beq $b159			beq 	_GXSIFail
.b0e5	ad e2 05	lda $05e2			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b0e8	f0 6f		beq $b159			beq 	_GXSIFail 					; (checking the MSB)
.b0ea	64 01		stz $01				stz 	1
.b0ec	a5 37		lda $37				lda 	gxzTemp0+1 					; push show/hide on the stack.
.b0ee	d0 6b		bne $b15b			bne 	_GXSIHide
.b0f0	a5 36		lda $36				lda 	gxzTemp0 					; sprite image
.b0f2	48		pha				pha
.b0f3	20 e6 b1	jsr $b1e6			jsr 	GXOpenBitmap
.b0f6	68		pla				pla
.b0f7	20 c7 b2	jsr $b2c7			jsr 	GXFindSprite
.b0fa	b0 5a		bcs $b156			bcs 	_GXSICloseFail 				; no image
.b0fc	a0 01		ldy #$01			ldy 	#1
.b0fe	ad e1 05	lda $05e1			lda 	GSCurrentSpriteAddr
.b101	85 36		sta $36				sta 	gxzTemp0
.b103	ad e2 05	lda $05e2			lda 	GSCurrentSpriteAddr+1
.b106	85 37		sta $37				sta 	gxzTemp0+1
.b108	ad 7b 06	lda $067b			lda 	GXSpriteOffset
.b10b	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b10d	18		clc				clc
.b10e	ad 7c 06	lda $067c			lda 	GXSpriteOffset+1
.b111	6d e3 05	adc $05e3			adc 	GXSpriteOffsetBase
.b114	c8		iny				iny
.b115	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b117	ad e4 05	lda $05e4			lda 	GXSpriteOffsetBase+1
.b11a	69 00		adc #$00			adc 	#0
.b11c	c8		iny				iny
.b11d	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b11f	ad 79 06	lda $0679			lda 	GXSizeBits 					; get raw size
.b122	49 03		eor #$03			eor 	#3 							; make it right (00=32 etc.)
.b124	2a		rol a				rol 	a 							; x 2
.b125	0a		asl a				asl 	a 							; x 4
.b126	0a		asl a				asl 	a 							; x 8
.b127	0a		asl a				asl 	a 							; x 16
.b128	0d 7a 06	ora $067a			ora 	GXSpriteLUT 				; Or with LUT
.b12b	0a		asl a				asl 	a 							; 1 shift
.b12c	09 01		ora #$01			ora 	#1 							; enable sprite.
.b12e	92 36		sta ($36)			sta 	(gxzTemp0) 					; and write back
.b130	20 ee b1	jsr $b1ee			jsr 	GXCloseBitmap
.b133	ae e0 05	ldx $05e0			ldx 	GSCurrentSpriteID 			; point to sprite entries.
.b136	bd 25 06	lda $0625,x			lda 	GXSpriteHigh,x 				; clear upper two bits of size
.b139	29 3f		and #$3f			and 	#$3F
.b13b	9d 25 06	sta $0625,x			sta 	GXSpriteHigh,x
.b13e	ad 79 06	lda $0679			lda 	GXSizeBits 					; get bit size
.b141	6a		ror a				ror 	a 							; shift into bits 6/7
.b142	6a		ror a				ror 	a
.b143	6a		ror a				ror 	a
.b144	29 c0		and #$c0			and 	#$C0
.b146	1d 25 06	ora $0625,x			ora 	GXSpriteHigh,x 				; put in  upper 2 bits of sprite data
.b149	9d 25 06	sta $0625,x			sta 	GXSpriteHigh,x
.b14c	bd e5 05	lda $05e5,x			lda 	GXSpriteLow,x 				; clear hidden flag.
.b14f	29 7f		and #$7f			and 	#$7F
.b151	9d e5 05	sta $05e5,x			sta 	GXSpriteLow,x
.b154	18		clc				clc
.b155	60		rts				rts
.b156					_GXSICloseFail:
.b156	20 ee b1	jsr $b1ee			jsr 	GXCloseBitmap
.b159					_GXSIFail:
.b159	38		sec				sec
.b15a	60		rts				rts
.b15b					_GXSIHide:
.b15b	ad e1 05	lda $05e1			lda 	GSCurrentSpriteAddr  		; get Sprite h/w address and write there
.b15e	85 36		sta $36				sta 	gxzTemp0
.b160	ad e2 05	lda $05e2			lda 	GSCurrentSpriteAddr+1
.b163	85 37		sta $37				sta 	gxzTemp0+1
.b165	a9 00		lda #$00			lda 	#0
.b167	92 36		sta ($36)			sta 	(gxzTemp0)
.b169	ae e0 05	ldx $05e0			ldx 	GSCurrentSpriteID 			; get sprite ID
.b16c	bd e5 05	lda $05e5,x			lda 	GXSpriteLow,x 				; set the hidden bit.
.b16f	09 80		ora #$80			ora 	#$80
.b171	9d e5 05	sta $05e5,x			sta 	GXSpriteLow,x
.b174	18		clc				clc
.b175	60		rts				rts
.b176					GXMoveSprite:
.b176	ad d5 05	lda $05d5			lda 	gxSpritesOn
.b179	f0 65		beq $b1e0			beq 	_GXSIFail
.b17b	ad e2 05	lda $05e2			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b17e	f0 60		beq $b1e0			beq 	_GXSIFail
.b180	85 37		sta $37				sta 	gxzTemp0+1
.b182	a0 04		ldy #$04			ldy 	#4
.b184	ad e1 05	lda $05e1			lda 	GSCurrentSpriteAddr
.b187	85 36		sta $36				sta 	gxzTemp0
.b189	ae e0 05	ldx $05e0			ldx 	GSCurrentSpriteID 			; get the size from the upper two bits
.b18c	bd 25 06	lda $0625,x			lda 	GXSpriteHigh,x
.b18f	2a		rol a				rol 	a	 						; into bits 0,1.
.b190	2a		rol a				rol 	a
.b191	2a		rol a				rol 	a
.b192	29 03		and #$03			and 	#3
.b194	aa		tax				tax
.b195	bd e2 b1	lda $b1e2,x			lda 	_GXMSOffset,x 				; get 32-SpriteSize/2
.b198	48		pha				pha
.b199	18		clc				clc
.b19a	6d cd 05	adc $05cd			adc 	gxX0						; copy position.
.b19d	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b19f	c8		iny				iny
.b1a0	ad ce 05	lda $05ce			lda 	gxX0+1
.b1a3	69 00		adc #$00			adc 	#0
.b1a5	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b1a7	c8		iny				iny
.b1a8	68		pla				pla
.b1a9	18		clc				clc
.b1aa	6d cf 05	adc $05cf			adc 	gxY0
.b1ad	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b1af	a9 00		lda #$00			lda 	#0
.b1b1	69 00		adc #$00			adc 	#0
.b1b3	c8		iny				iny
.b1b4	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b1b6	4e ce 05	lsr $05ce			lsr 	gxX0+1 						; divide X by 4
.b1b9	6e cd 05	ror $05cd			ror 	gxX0
.b1bc	4e cd 05	lsr $05cd			lsr 	gxX0
.b1bf	4e cf 05	lsr $05cf			lsr 	gxY0 						; divide Y by 4
.b1c2	4e cf 05	lsr $05cf			lsr 	gxY0
.b1c5	ae e0 05	ldx $05e0			ldx 	GSCurrentSpriteID 			; copy X/4 and Y/4 into the status bytes
.b1c8	bd e5 05	lda $05e5,x			lda 	GXSpriteLow,x
.b1cb	29 80		and #$80			and 	#$80
.b1cd	0d cd 05	ora $05cd			ora 	gxX0
.b1d0	9d e5 05	sta $05e5,x			sta 	GXSpriteLow,x
.b1d3	bd 25 06	lda $0625,x			lda 	GXSpriteHigh,x
.b1d6	29 c0		and #$c0			and 	#$C0
.b1d8	0d cf 05	ora $05cf			ora 	gxY0
.b1db	9d 25 06	sta $0625,x			sta 	GXSpriteHigh,x
.b1de	18		clc				clc
.b1df	60		rts				rts
.b1e0					_GXSIFail:
.b1e0	38		sec				sec
.b1e1	60		rts				rts
.b1e2					_GXMSOffset:
>b1e2	1c						.byte 	32-8/2
>b1e3	18						.byte 	32-16/2
>b1e4	14						.byte 	32-24/2
>b1e5	10						.byte 	32-32/2
.b1e6					GXOpenBitmap:
.b1e6	78		sei				sei 								; no interrupts here
.b1e7	a5 0b		lda $0b				lda 	GXEditSlot 					; Save the original LUT slot value
.b1e9	8d de 05	sta $05de			sta 	gxOriginalLUTValue
.b1ec	58		cli				cli
.b1ed	60		rts				rts
.b1ee					GXCloseBitmap:
.b1ee	78		sei				sei
.b1ef	ad de 05	lda $05de			lda 	gxOriginalLUTValue 			; restore LUT slot value
.b1f2	85 0b		sta $0b				sta 	GXEditSlot
.b1f4	58		cli				cli
.b1f5	60		rts				rts
.b1f6					GXPositionCalc:
.b1f6	a5 36		lda $36				lda 	gxzTemp0 					; save temp memory slot
.b1f8	48		pha				pha
.b1f9	ad cf 05	lda $05cf			lda 	GXY0 						; gxzScreen = Y0
.b1fc	85 3c		sta $3c				sta 	gxzScreen
.b1fe	64 3d		stz $3d				stz 	gxzScreen+1
.b200	06 3c		asl $3c				asl 	gxzScreen 						; gxzScreen = Y0 * 4
.b202	26 3d		rol $3d				rol 	gxzScreen+1
.b204	06 3c		asl $3c				asl 	gxzScreen
.b206	26 3d		rol $3d				rol 	gxzScreen+1
.b208	18		clc				clc 								; gxzScreen = Y0 * 5, as it's still in A
.b209	65 3c		adc $3c				adc 	gxzScreen
.b20b	85 3c		sta $3c				sta 	gxzScreen
.b20d	90 02		bcc $b211			bcc 	_GXPCNoCarry
.b20f	e6 3d		inc $3d				inc 	gxzScreen+1
.b211					_GXPCNoCarry:
.b211	06 3c		asl $3c				asl 	gxzScreen 						; now Y0 * 10. Needs to be multiplied by another
.b213	26 3d		rol $3d				rol 	gxzScreen+1 					; 32. At this point the MSB contains the offset
.b215	a5 3d		lda $3d				lda	 	gxzScreen+1 					; so save this in zTemp0 and zero it.
.b217	85 36		sta $36				sta 	gxzTemp0
.b219	64 3d		stz $3d				stz 	gxzScreen+1
.b21b	a9 05		lda #$05			lda 	#5 							; now multiply by 32, this puts this in the range 0..8191
.b21d					_GXPCMultiply32:
.b21d	06 3c		asl $3c				asl 	gxzScreen
.b21f	26 3d		rol $3d				rol 	gxzScreen+1
.b221	3a		dec a				dec 	a
.b222	d0 f9		bne $b21d			bne 	_GXPCMultiply32
.b224	18		clc				clc
.b225	ad cd 05	lda $05cd			lda 	GXX0 						; add X to this value, put the result in gsOffset, gxzScreen has to be on a page boundary
.b228	65 3c		adc $3c				adc 	gxzScreen
.b22a	8d df 05	sta $05df			sta 	gsOffset
.b22d	ad ce 05	lda $05ce			lda 	GXX0+1
.b230	65 3d		adc $3d				adc 	gxzScreen+1
.b232	c9 20		cmp #$20			cmp 	#$20 						; has it overflowed into the next one ?
.b234	90 04		bcc $b23a			bcc 	_GXPCNoOverflow
.b236	29 1f		and #$1f			and 	#$1F 						; fix it up
.b238	e6 36		inc $36				inc 	gxzTemp0 					; add 1 to the page number
.b23a					_GXPCNoOverflow:
.b23a	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; make it the address mapped in.
.b23c	85 3d		sta $3d				sta 	gxzScreen+1
.b23e	64 3c		stz $3c				stz 	gxzScreen
.b240	18		clc				clc
.b241	a5 36		lda $36				lda 	gxzTemp0 					; get the page number
.b243	6d d7 05	adc $05d7			adc 	gxBasePage 					; by adding the base page
.b246	85 0b		sta $0b				sta 	GXEditSlot 				; and map it into memory.
.b248	68		pla				pla
.b249	85 36		sta $36				sta 	gxzTemp0
.b24b	60		rts				rts
.b24c					GXMovePositionDown:
.b24c	18		clc				clc 								; add 320 to offset/temp+1
.b24d	ad df 05	lda $05df			lda 	gsOffset
.b250	69 40		adc #$40			adc 	#64
.b252	8d df 05	sta $05df			sta 	gsOffset
.b255	a5 3d		lda $3d				lda 	gxzScreen+1
.b257	69 01		adc #$01			adc 	#1
.b259	85 3d		sta $3d				sta 	gxzScreen+1
.b25b	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page
.b25d	90 07		bcc $b266			bcc 	_GXMPDExit
.b25f	38		sec				sec  								; next page
.b260	e9 20		sbc #$20			sbc 	#$20
.b262	85 3d		sta $3d				sta 	gxzScreen+1
.b264	e6 0b		inc $0b				inc 	GXEditSlot
.b266					_GXMPDExit:
.b266	60		rts				rts
.b267					GXCollide:
.b267	a5 36		lda $36				lda 	gxzTemp0 					; check if sprite numbers are legal.
.b269	aa		tax				tax
.b26a	05 37		ora $37				ora 	gxzTemp0+1
.b26c	29 c0		and #$c0			and 	#$C0
.b26e	38		sec				sec
.b26f	d0 53		bne $b2c4			bne 	_GXCollideFail 				; if either >= 64, fail.
.b271	a4 37		ldy $37				ldy 	gxzTemp0+1 					; at this point X is 1st sprite and Y is 2nd sprite.
.b273	b9 e5 05	lda $05e5,y			lda 	GXSpriteLow,y 				; check if either hidden bit is set
.b276	1d e5 05	ora $05e5,x			ora 	GXSpriteLow,x
.b279	30 48		bmi $b2c3			bmi 	_GXOkayFail 				; if either hidden, then they cannot collide.
.b27b	18		clc				clc 								; need to calculate sum of sizes.
.b27c	b9 25 06	lda $0625,y			lda 	GXSpriteHigh,y
.b27f	7d 25 06	adc $0625,x			adc 	GXSpriteHigh,x 				; at this point, CS, Bit 6 and 7 contain that sum.
.b282	29 c0		and #$c0			and 	#$C0 					 	; mask off
.b284	6a		ror a				ror 	a 							; 5/6/7
.b285	4a		lsr a				lsr 	a 							; 4/5/6
.b286	4a		lsr a				lsr 	a 							; 3/4/5
.b287	4a		lsr a				lsr 	a 							; 2/3/4
.b288	18		clc				clc
.b289	69 08		adc #$08			adc 	#$08
.b28b	4a		lsr a				lsr 	a 							; adjust because all coordinates are divided by 4 to store.
.b28c	4a		lsr a				lsr 	a
.b28d	85 38		sta $38				sta 	gxzTemp1 					; so the difference between the centres has to be less than this.
.b28f	b9 25 06	lda $0625,y			lda 	GXSpriteHigh,y 				; calculate y1-y0
.b292	29 3f		and #$3f			and 	#$3F
.b294	85 39		sta $39				sta 	gxzTemp1+1
.b296	38		sec				sec
.b297	bd 25 06	lda $0625,x			lda 	GXSpriteHigh,x
.b29a	29 3f		and #$3f			and 	#$3F
.b29c	e5 39		sbc $39				sbc 	gxzTemp1+1
.b29e	b0 03		bcs $b2a3			bcs 	_GXCAbs1 					; calculate |y1-y0|
.b2a0	49 ff		eor #$ff			eor 	#$FF
.b2a2	1a		inc a				inc 	a
.b2a3					_GXCAbs1:
.b2a3	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b2a5	b0 1c		bcs $b2c3			bcs 	_GXOkayFail
.b2a7	85 39		sta $39				sta 	gxzTemp1+1 					; save |y1-y0|
.b2a9	38		sec				sec 								; calculate |x1-x0|
.b2aa	b9 e5 05	lda $05e5,y			lda 	GXSpriteLow,y
.b2ad	fd e5 05	sbc $05e5,x			sbc 	GXSpriteLow,x
.b2b0	b0 03		bcs $b2b5			bcs 	_GXCAbs2
.b2b2	49 ff		eor #$ff			eor 	#$FF
.b2b4	1a		inc a				inc 	a
.b2b5					_GXCAbs2:
.b2b5	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b2b7	b0 0a		bcs $b2c3			bcs 	_GXOkayFail
.b2b9	c5 39		cmp $39				cmp 	gxzTemp1+1 					; is it less than the previous one.
.b2bb	90 02		bcc $b2bf			bcc 	_GXCHaveLowest
.b2bd	a5 39		lda $39				lda 	gxzTemp1+1 					; if not, that's the smallest difference.
.b2bf					_GXCHaveLowest:
.b2bf	0a		asl a				asl 	a 							; scale to allow for >> 2
.b2c0	0a		asl a				asl 	a
.b2c1	18		clc				clc
.b2c2	60		rts				rts
.b2c3					_GXOkayFail:
.b2c3	18		clc				clc
.b2c4					_GXCollideFail:
.b2c4	a9 ff		lda #$ff			lda 	#$FF
.b2c6	60		rts				rts
.b2c7					GXFindSprite:
.b2c7	aa		tax				tax
.b2c8	ad d8 05	lda $05d8			lda 	GXSpritePage 				; access the base page of the sprite
.b2cb	85 0b		sta $0b				sta 	GXEditSlot
.b2cd	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; check a valid sprite
.b2d0	1d 00 60	ora $6000,x			ora 	GXMappingAddress,x
.b2d3	f0 33		beq $b308			beq 	_GXFSFail
.b2d5	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; MSB
.b2d8	8d 7c 06	sta $067c			sta 	GXSpriteOffset+1
.b2db	bd 00 60	lda $6000,x			lda 	GXMappingAddress,x 			; LSB
.b2de	48		pha				pha 								; save twice
.b2df	48		pha				pha
.b2e0	29 03		and #$03			and 	#3 							; get sprite size
.b2e2	8d 79 06	sta $0679			sta 	GXSizeBits 					; save raw (0-3)
.b2e5	aa		tax				tax
.b2e6	bd 0a b3	lda $b30a,x			lda 	_GXFXSSTTable,x 			; read sprite size
.b2e9	8d 78 06	sta $0678			sta 	GXSizePixels 					; save (8/16/24/32)
.b2ec	68		pla				pla 								; get LUT
.b2ed	4a		lsr a				lsr		a
.b2ee	4a		lsr a				lsr		a
.b2ef	29 03		and #$03			and 	#3
.b2f1	8d 7a 06	sta $067a			sta 	GXSpriteLUT
.b2f4	68		pla				pla 								; address, neeeds to be x 4
.b2f5	29 f0		and #$f0			and 	#$F0
.b2f7	8d 7b 06	sta $067b			sta 	GXSpriteOffset
.b2fa	0e 7b 06	asl $067b			asl 	GXSpriteOffset
.b2fd	2e 7c 06	rol $067c			rol 	GXSpriteOffset+1
.b300	0e 7b 06	asl $067b			asl 	GXSpriteOffset
.b303	2e 7c 06	rol $067c			rol 	GXSpriteOffset+1
.b306	18		clc				clc
.b307	60		rts				rts
.b308					_GXFSFail:
.b308	38		sec				sec
.b309	60		rts				rts
.b30a					_GXFXSSTTable:
>b30a	08 10 18 20					.byte 	8,16,24,32
.0678					GXSizePixels:
>0678							.fill 	1
.0679					GXSizeBits:
>0679							.fill 	1
.067a					GXSpriteLUT:
>067a							.fill 	1
.067b					GXSpriteOffset:
>067b							.fill 	2
.b30e					GXSortXY:
.b30e	20 2c b3	jsr $b32c			jsr 	GXSortY 					; will be sorted on Y now
.b311	ad cd 05	lda $05cd			lda 	gxX0 						; compare X0 v X1
.b314	cd d1 05	cmp $05d1			cmp 	gxX1
.b317	ad ce 05	lda $05ce			lda 	gXX0+1
.b31a	ed d2 05	sbc $05d2			sbc 	gXX1+1
.b31d	90 0c		bcc $b32b			bcc 	_GXSXYExit 					; X0 < X1 exit
.b31f	a2 00		ldx #$00			ldx 	#0 							; swap them over
.b321	a0 04		ldy #$04			ldy 	#4
.b323	20 40 b3	jsr $b340			jsr 	GXSwapXY
.b326	e8		inx				inx
.b327	c8		iny				iny
.b328	20 40 b3	jsr $b340			jsr 	GXSwapXY
.b32b					_GXSXYExit:
.b32b	60		rts				rts
.b32c					GXSortY:
.b32c	ad cf 05	lda $05cf			lda 	gxY0 						; if Y0 >= Y1
.b32f	cd d3 05	cmp $05d3			cmp 	gxY1
.b332	90 0b		bcc $b33f			bcc 	_GXSYSorted
.b334	a2 03		ldx #$03			ldx 	#3 							; swap 3-0
.b336	a0 07		ldy #$07			ldy 	#7 							; with 4-7
.b338					_GXSwap1:
.b338	20 40 b3	jsr $b340			jsr 	GXSwapXY
.b33b	88		dey				dey
.b33c	ca		dex				dex
.b33d	10 f9		bpl $b338			bpl 	_GXSwap1
.b33f					_GXSYSorted:
.b33f	60		rts				rts
.b340					GXSwapXY:
.b340	bd cd 05	lda $05cd,x			lda 	gxX0,x
.b343	48		pha				pha
.b344	b9 cd 05	lda $05cd,y			lda 	gxX0,y
.b347	9d cd 05	sta $05cd,x			sta 	gxX0,x
.b34a	68		pla				pla
.b34b	99 cd 05	sta $05cd,y			sta 	gxX0,y
.b34e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_tokeniser.module

=1					tokeniserIntegrated=1
.ba3a					KeywordSet0:
>ba3a	00 65					.text	0,$65,""               ; $80 !0:EOF
>ba3c	00 58					.text	0,$58,""               ; $81 !1:SH1
>ba3e	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>ba40	04 fe 41 42 53 28			.text	4,$fe,"ABS("           ; $83 ABS(
>ba46	06 93 41 4c 4c 4f 43 28			.text	6,$93,"ALLOC("         ; $84 ALLOC(
>ba4e	04 ff 41 53 43 28			.text	4,$ff,"ASC("           ; $85 ASC(
>ba54	05 29 43 48 52 24 28			.text	5,$29,"CHR$("          ; $86 CHR$(
>ba5b	06 aa 45 56 45 4e 54 28			.text	6,$aa,"EVENT("         ; $87 EVENT(
>ba63	05 6b 46 41 4c 53 45			.text	5,$6b,"FALSE"          ; $88 FALSE
>ba6a	05 44 46 52 41 43 28			.text	5,$44,"FRAC("          ; $89 FRAC(
>ba71	04 0d 48 49 54 28			.text	4,$0d,"HIT("           ; $8a HIT(
>ba77	04 13 49 4e 54 28			.text	4,$13,"INT("           ; $8b INT(
>ba7d	06 a7 49 53 56 41 4c 28			.text	6,$a7,"ISVAL("         ; $8c ISVAL(
>ba85	05 5c 4a 4f 59 42 28			.text	5,$5c,"JOYB("          ; $8d JOYB(
>ba8c	05 72 4a 4f 59 58 28			.text	5,$72,"JOYX("          ; $8e JOYX(
>ba93	05 73 4a 4f 59 59 28			.text	5,$73,"JOYY("          ; $8f JOYY(
>ba9a	06 77 4c 45 46 54 24 28			.text	6,$77,"LEFT$("         ; $90 LEFT$(
>baa2	04 07 4c 45 4e 28			.text	4,$07,"LEN("           ; $91 LEN(
>baa8	04 0e 4d 41 58 28			.text	4,$0e,"MAX("           ; $92 MAX(
>baae	05 26 4d 49 44 24 28			.text	5,$26,"MID$("          ; $93 MID$(
>bab5	04 0c 4d 49 4e 28			.text	4,$0c,"MIN("           ; $94 MIN(
>babb	04 19 4e 4f 54 28			.text	4,$19,"NOT("           ; $95 NOT(
>bac1	08 3c 50 4c 41 59 49 4e			.text	8,$3c,"PLAYING("       ; $96 PLAYING(
>bac9	47 28
>bacb	07 e9 52 41 4e 44 4f 4d			.text	7,$e9,"RANDOM("        ; $97 RANDOM(
>bad3	28
>bad4	07 ca 52 49 47 48 54 24			.text	7,$ca,"RIGHT$("        ; $98 RIGHT$(
>badc	28
>badd	04 0c 52 4e 44 28			.text	4,$0c,"RND("           ; $99 RND(
>bae3	04 10 53 47 4e 28			.text	4,$10,"SGN("           ; $9a SGN(
>bae9	04 0e 53 50 43 28			.text	4,$0e,"SPC("           ; $9b SPC(
>baef	05 45 53 54 52 24 28			.text	5,$45,"STR$("          ; $9c STR$(
>baf6	06 a9 54 49 4d 45 52 28			.text	6,$a9,"TIMER("         ; $9d TIMER(
>bafe	04 40 54 52 55 45			.text	4,$40,"TRUE"           ; $9e TRUE
>bb04	04 0b 56 41 4c 28			.text	4,$0b,"VAL("           ; $9f VAL(
>bb0a	03 e7 46 4f 52				.text	3,$e7,"FOR"            ; $a0 FOR
>bb0f	02 8f 49 46				.text	2,$8f,"IF"             ; $a1 IF
>bb13	04 34 50 52 4f 43			.text	4,$34,"PROC"           ; $a2 PROC
>bb19	06 c1 52 45 50 45 41 54			.text	6,$c1,"REPEAT"         ; $a3 REPEAT
>bb21	05 79 57 48 49 4c 45			.text	5,$79,"WHILE"          ; $a4 WHILE
>bb28	05 66 45 4e 44 49 46			.text	5,$66,"ENDIF"          ; $a5 ENDIF
>bb2f	07 0b 45 4e 44 50 52 4f			.text	7,$0b,"ENDPROC"        ; $a6 ENDPROC
>bb37	43
>bb38	04 3f 4e 45 58 54			.text	4,$3f,"NEXT"           ; $a7 NEXT
>bb3e	04 2f 54 48 45 4e			.text	4,$2f,"THEN"           ; $a8 THEN
>bb44	05 8c 55 4e 54 49 4c			.text	5,$8c,"UNTIL"          ; $a9 UNTIL
>bb4b	04 2e 57 45 4e 44			.text	4,$2e,"WEND"           ; $aa WEND
>bb51	02 9b 42 59				.text	2,$9b,"BY"             ; $ab BY
>bb55	04 1c 43 41 4c 4c			.text	4,$1c,"CALL"           ; $ac CALL
>bb5b	06 b2 43 49 52 43 4c 45			.text	6,$b2,"CIRCLE"         ; $ad CIRCLE
>bb63	05 67 43 4c 45 41 52			.text	5,$67,"CLEAR"          ; $ae CLEAR
>bb6a	03 e2 43 4c 53				.text	3,$e2,"CLS"            ; $af CLS
>bb6f	05 7f 43 4f 4c 4f 52			.text	5,$7f,"COLOR"          ; $b0 COLOR
>bb76	06 d4 43 4f 4c 4f 55 52			.text	6,$d4,"COLOUR"         ; $b1 COLOUR
>bb7e	04 1a 44 41 54 41			.text	4,$1a,"DATA"           ; $b2 DATA
>bb84	03 da 44 49 4d				.text	3,$da,"DIM"            ; $b3 DIM
>bb89	06 db 44 4f 57 4e 54 4f			.text	6,$db,"DOWNTO"         ; $b4 DOWNTO
>bb91	04 29 45 4c 53 45			.text	4,$29,"ELSE"           ; $b5 ELSE
>bb97	04 34 46 52 4f 4d			.text	4,$34,"FROM"           ; $b6 FROM
>bb9d	03 e5 47 46 58				.text	3,$e5,"GFX"            ; $b7 GFX
>bba2	05 80 47 4f 53 55 42			.text	5,$80,"GOSUB"          ; $b8 GOSUB
>bba9	04 39 47 4f 54 4f			.text	4,$39,"GOTO"           ; $b9 GOTO
>bbaf	04 24 48 45 52 45			.text	4,$24,"HERE"           ; $ba HERE
>bbb5	05 63 49 4d 41 47 45			.text	5,$63,"IMAGE"          ; $bb IMAGE
>bbbc	05 90 49 4e 50 55 54			.text	5,$90,"INPUT"          ; $bc INPUT
>bbc3	03 e5 4c 45 54				.text	3,$e5,"LET"            ; $bd LET
>bbc8	04 28 4c 49 4e 45			.text	4,$28,"LINE"           ; $be LINE
>bbce	05 6b 4c 4f 43 41 4c			.text	5,$6b,"LOCAL"          ; $bf LOCAL
>bbd5	03 db 4f 46 46				.text	3,$db,"OFF"            ; $c0 OFF
>bbda	02 9d 4f 4e				.text	2,$9d,"ON"             ; $c1 ON
>bbde	07 20 4f 55 54 4c 49 4e			.text	7,$20,"OUTLINE"        ; $c2 OUTLINE
>bbe6	45
>bbe7	07 0f 50 41 4c 45 54 54			.text	7,$0f,"PALETTE"        ; $c3 PALETTE
>bbef	45
>bbf0	04 3f 50 4c 4f 54			.text	4,$3f,"PLOT"           ; $c4 PLOT
>bbf6	05 8d 50 52 49 4e 54			.text	5,$8d,"PRINT"          ; $c5 PRINT
>bbfd	04 1c 52 45 41 44			.text	4,$1c,"READ"           ; $c6 READ
>bc03	04 2e 52 45 43 54			.text	4,$2e,"RECT"           ; $c7 RECT
>bc09	03 e4 52 45 4d				.text	3,$e4,"REM"            ; $c8 REM
>bc0e	06 e0 52 45 54 55 52 4e			.text	6,$e0,"RETURN"         ; $c9 RETURN
>bc16	05 7b 53 4f 4c 49 44			.text	5,$7b,"SOLID"          ; $ca SOLID
>bc1d	05 89 53 4f 55 4e 44			.text	5,$89,"SOUND"          ; $cb SOUND
>bc24	06 d7 53 50 52 49 54 45			.text	6,$d7,"SPRITE"         ; $cc SPRITE
>bc2c	04 45 54 45 58 54			.text	4,$45,"TEXT"           ; $cd TEXT
>bc32	02 a3 54 4f				.text	2,$a3,"TO"             ; $ce TO
>bc36	ff					.text	$FF
.bc37					KeywordSet1:
>bc37	00 65					.text	0,$65,""               ; $80 !0:EOF
>bc39	00 58					.text	0,$58,""               ; $81 !1:SH1
>bc3b	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bc3d	08 4c 41 53 53 45 4d 42			.text	8,$4c,"ASSEMBLE"       ; $83 ASSEMBLE
>bc45	4c 45
>bc47	06 d2 41 53 53 45 52 54			.text	6,$d2,"ASSERT"         ; $84 ASSERT
>bc4f	06 bd 42 49 54 4d 41 50			.text	6,$bd,"BITMAP"         ; $85 BITMAP
>bc57	03 d7 45 4e 44				.text	3,$d7,"END"            ; $86 END
>bc5c	02 96 47 4f				.text	2,$96,"GO"             ; $87 GO
>bc60	04 3c 4c 49 53 54			.text	4,$3c,"LIST"           ; $88 LIST
>bc66	04 20 4c 4f 41 44			.text	4,$20,"LOAD"           ; $89 LOAD
>bc6c	03 ea 4e 45 57				.text	3,$ea,"NEW"            ; $8a NEW
>bc71	07 24 52 45 53 54 4f 52			.text	7,$24,"RESTORE"        ; $8b RESTORE
>bc79	45
>bc7a	03 f5 52 55 4e				.text	3,$f5,"RUN"            ; $8c RUN
>bc7f	07 2a 53 50 52 49 54 45			.text	7,$2a,"SPRITES"        ; $8d SPRITES
>bc87	53
>bc88	04 46 53 54 4f 50			.text	4,$46,"STOP"           ; $8e STOP
>bc8e	03 ee 57 48 4f				.text	3,$ee,"WHO"            ; $8f WHO
>bc93	ff					.text	$FF
.bc94					KeywordSet2:
>bc94	00 65					.text	0,$65,""               ; $80 !0:EOF
>bc96	00 58					.text	0,$58,""               ; $81 !1:SH1
>bc98	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bc9a	03 c8 41 44 43				.text	3,$c8,"ADC"            ; $83 ADC
>bc9f	03 d3 41 4e 44				.text	3,$d3,"AND"            ; $84 AND
>bca4	03 e0 41 53 4c				.text	3,$e0,"ASL"            ; $85 ASL
>bca9	03 c8 42 43 43				.text	3,$c8,"BCC"            ; $86 BCC
>bcae	03 d8 42 43 53				.text	3,$d8,"BCS"            ; $87 BCS
>bcb3	03 d8 42 45 51				.text	3,$d8,"BEQ"            ; $88 BEQ
>bcb8	03 df 42 49 54				.text	3,$df,"BIT"            ; $89 BIT
>bcbd	03 d8 42 4d 49				.text	3,$d8,"BMI"            ; $8a BMI
>bcc2	03 d5 42 4e 45				.text	3,$d5,"BNE"            ; $8b BNE
>bcc7	03 de 42 50 4c				.text	3,$de,"BPL"            ; $8c BPL
>bccc	03 d5 42 52 41				.text	3,$d5,"BRA"            ; $8d BRA
>bcd1	03 df 42 52 4b				.text	3,$df,"BRK"            ; $8e BRK
>bcd6	03 db 42 56 43				.text	3,$db,"BVC"            ; $8f BVC
>bcdb	03 eb 42 56 53				.text	3,$eb,"BVS"            ; $90 BVS
>bce0	03 d2 43 4c 43				.text	3,$d2,"CLC"            ; $91 CLC
>bce5	03 d3 43 4c 44				.text	3,$d3,"CLD"            ; $92 CLD
>bcea	03 d8 43 4c 49				.text	3,$d8,"CLI"            ; $93 CLI
>bcef	03 e5 43 4c 56				.text	3,$e5,"CLV"            ; $94 CLV
>bcf4	03 e0 43 4d 50				.text	3,$e0,"CMP"            ; $95 CMP
>bcf9	03 eb 43 50 58				.text	3,$eb,"CPX"            ; $96 CPX
>bcfe	03 ec 43 50 59				.text	3,$ec,"CPY"            ; $97 CPY
>bd03	03 cc 44 45 43				.text	3,$cc,"DEC"            ; $98 DEC
>bd08	03 e1 44 45 58				.text	3,$e1,"DEX"            ; $99 DEX
>bd0d	03 e2 44 45 59				.text	3,$e2,"DEY"            ; $9a DEY
>bd12	03 e6 45 4f 52				.text	3,$e6,"EOR"            ; $9b EOR
>bd17	03 da 49 4e 43				.text	3,$da,"INC"            ; $9c INC
>bd1c	03 ef 49 4e 58				.text	3,$ef,"INX"            ; $9d INX
>bd21	03 f0 49 4e 59				.text	3,$f0,"INY"            ; $9e INY
>bd26	03 e7 4a 4d 50				.text	3,$e7,"JMP"            ; $9f JMP
>bd2b	03 ef 4a 53 52				.text	3,$ef,"JSR"            ; $a0 JSR
>bd30	03 d1 4c 44 41				.text	3,$d1,"LDA"            ; $a1 LDA
>bd35	03 e8 4c 44 58				.text	3,$e8,"LDX"            ; $a2 LDX
>bd3a	03 e9 4c 44 59				.text	3,$e9,"LDY"            ; $a3 LDY
>bd3f	03 f1 4c 53 52				.text	3,$f1,"LSR"            ; $a4 LSR
>bd44	03 ed 4e 4f 50				.text	3,$ed,"NOP"            ; $a5 NOP
>bd49	03 e2 4f 52 41				.text	3,$e2,"ORA"            ; $a6 ORA
>bd4e	03 d9 50 48 41				.text	3,$d9,"PHA"            ; $a7 PHA
>bd53	03 e8 50 48 50				.text	3,$e8,"PHP"            ; $a8 PHP
>bd58	03 f0 50 48 58				.text	3,$f0,"PHX"            ; $a9 PHX
>bd5d	03 f1 50 48 59				.text	3,$f1,"PHY"            ; $aa PHY
>bd62	03 dd 50 4c 41				.text	3,$dd,"PLA"            ; $ab PLA
>bd67	03 ec 50 4c 50				.text	3,$ec,"PLP"            ; $ac PLP
>bd6c	03 f4 50 4c 58				.text	3,$f4,"PLX"            ; $ad PLX
>bd71	03 f5 50 4c 59				.text	3,$f5,"PLY"            ; $ae PLY
>bd76	03 ed 52 4f 4c				.text	3,$ed,"ROL"            ; $af ROL
>bd7b	03 f3 52 4f 52				.text	3,$f3,"ROR"            ; $b0 ROR
>bd80	03 ef 52 54 49				.text	3,$ef,"RTI"            ; $b1 RTI
>bd85	03 f9 52 54 53				.text	3,$f9,"RTS"            ; $b2 RTS
>bd8a	03 d8 53 42 43				.text	3,$d8,"SBC"            ; $b3 SBC
>bd8f	03 db 53 45 43				.text	3,$db,"SEC"            ; $b4 SEC
>bd94	03 dc 53 45 44				.text	3,$dc,"SED"            ; $b5 SED
>bd99	03 e1 53 45 49				.text	3,$e1,"SEI"            ; $b6 SEI
>bd9e	03 e8 53 54 41				.text	3,$e8,"STA"            ; $b7 STA
>bda3	03 f7 53 54 50				.text	3,$f7,"STP"            ; $b8 STP
>bda8	03 ff 53 54 58				.text	3,$ff,"STX"            ; $b9 STX
>bdad	03 00 53 54 59				.text	3,$00,"STY"            ; $ba STY
>bdb2	03 01 53 54 5a				.text	3,$01,"STZ"            ; $bb STZ
>bdb7	03 ed 54 41 58				.text	3,$ed,"TAX"            ; $bc TAX
>bdbc	03 ee 54 41 59				.text	3,$ee,"TAY"            ; $bd TAY
>bdc1	03 e8 54 52 42				.text	3,$e8,"TRB"            ; $be TRB
>bdc6	03 e9 54 53 42				.text	3,$e9,"TSB"            ; $bf TSB
>bdcb	03 ff 54 53 58				.text	3,$ff,"TSX"            ; $c0 TSX
>bdd0	03 ed 54 58 41				.text	3,$ed,"TXA"            ; $c1 TXA
>bdd5	03 ff 54 58 53				.text	3,$ff,"TXS"            ; $c2 TXS
>bdda	03 ee 54 59 41				.text	3,$ee,"TYA"            ; $c3 TYA
>bddf	ff					.text	$FF
.b34f					Export_TKListConvertLine:
.b34f	48		pha				pha 								; save indent on the stack
.b350	9c 1d 04	stz $041d			stz 	tbOffset
.b353	9c 2d 04	stz $042d			stz 	tokenBuffer
.b356	9c 29 04	stz $0429			stz 	currentListColour
.b359	a9 89		lda #$89			lda 	#CLILineNumber+$80
.b35b	20 d8 b4	jsr $b4d8			jsr 	LCLWriteColour
.b35e	a0 02		ldy #$02			ldy 	#2 							; convert line number to string
.b360	b1 30		lda ($30),y			lda 	(codePtr),y
.b362	aa		tax				tax
.b363	88		dey				dey
.b364	b1 30		lda ($30),y			lda 	(codePtr),y
.b366	20 49 b5	jsr $b549			jsr 	LCLWriteNumberXA
.b369	68		pla				pla 								; adjustment to indent
.b36a	48		pha				pha 								; save on stack
.b36b	10 0c		bpl $b379			bpl 	_LCNoAdjust 				; don't adjust indent if +ve, do after.
.b36d	18		clc				clc 								; add to list indent and make 0 if goes -ve.
.b36e	6d 26 04	adc $0426			adc 	listIndent
.b371	8d 26 04	sta $0426			sta 	listIndent
.b374	10 03		bpl $b379			bpl 	_LCNoAdjust
.b376	9c 26 04	stz $0426			stz 	listIndent
.b379					_LCNoAdjust:
.b379	18		clc				clc		 							; work out actual indent.
.b37a	ad 26 04	lda $0426			lda 	listIndent
.b37d	0a		asl a				asl 	a
.b37e	69 07		adc #$07			adc 	#7
.b380	85 36		sta $36				sta 	zTemp0
.b382					_LCPadOut:
.b382	a9 20		lda #$20			lda 	#' '						; pad out to 6+indent characters
.b384	20 e1 b4	jsr $b4e1			jsr 	LCLWrite
.b387	ad 1d 04	lda $041d			lda 	tbOffset
.b38a	c5 36		cmp $36				cmp 	zTemp0
.b38c	d0 f4		bne $b382			bne 	_LCPadOut
.b38e	a0 03		ldy #$03			ldy 	#3 							; start position.
.b390					_LCMainLoop:
.b390	a9 8a		lda #$8a			lda 	#CLIPunctuation+$80
.b392	20 d8 b4	jsr $b4d8			jsr 	LCLWriteColour
.b395	b1 30		lda ($30),y			lda 	(codePtr),y
.b397	c9 80		cmp #$80			cmp 	#KWC_EOL 					; end of line ?
.b399	f0 17		beq $b3b2			beq 	_LCExit
.b39b	c9 10		cmp #$10			cmp 	#16 						; 0-5 are the double punctuations
.b39d	90 1e		bcc $b3bd			bcc 	_LCDoubles
.b39f	c9 20		cmp #$20			cmp 	#32 						; 16-31 are shifted punctuation from 64-91
.b3a1	90 2a		bcc $b3cd			bcc 	_LCShiftPunc
.b3a3	c9 40		cmp #$40			cmp 	#64 						; 32-64 are as stored, punc and digits
.b3a5	90 35		bcc $b3dc			bcc 	_LCPunctuation
.b3a7	c9 80		cmp #$80			cmp 	#128 						; 64-127 are variable identifiers.
.b3a9	90 51		bcc $b3fc			bcc 	_LCIdentifiers
.b3ab	c9 fe		cmp #$fe			cmp 	#254 						; 128-253 are tokenised words
.b3ad	90 73		bcc $b422			bcc 	_LCTokens
.b3af	4c 82 b4	jmp $b482			jmp 	_LCData 					; 254-5 are data objects
.b3b2					_LCExit:
.b3b2	68		pla				pla 								; get old indent adjust
.b3b3	30 07		bmi $b3bc			bmi 	_LCExit2
.b3b5	18		clc				clc 								; add to indent if +ve
.b3b6	6d 26 04	adc $0426			adc 	listIndent
.b3b9	8d 26 04	sta $0426			sta 	listIndent
.b3bc					_LCExit2:
.b3bc	60		rts				rts
.b3bd					_LCDoubles:
.b3bd	48		pha				pha
.b3be	4a		lsr a				lsr 	a 							; put bit 2 into bit 1
.b3bf	29 02		and #$02			and 	#2
.b3c1	09 3c		ora #$3c			ora 	#60 						; make < >
.b3c3	20 e1 b4	jsr $b4e1			jsr 	LCLWrite
.b3c6	68		pla				pla 								; restore, do lower bit
.b3c7	29 03		and #$03			and 	#3
.b3c9	09 3c		ora #$3c			ora 	#60
.b3cb	80 0f		bra $b3dc			bra		_LCPunctuation 				; print, increment, loop
.b3cd					_LCShiftPunc:
.b3cd	aa		tax				tax 								; save in X
.b3ce	29 07		and #$07			and 	#7 							; lower 3 bits
.b3d0	f0 02		beq $b3d4			beq 	_LCNoAdd
.b3d2	09 18		ora #$18			ora 	#24 						; adds $18 to it.
.b3d4					_LCNoAdd:
.b3d4	e0 18		cpx #$18			cpx 	#24 						; if >= 24 add $20
.b3d6	90 02		bcc $b3da			bcc 	_LCNoAdd2
.b3d8	09 20		ora #$20			ora 	#32 						; adds $20
.b3da					_LCNoAdd2:
.b3da	09 40		ora #$40			ora 	#$40 						; shift into 64-127 range and fall through.
.b3dc					_LCPunctuation:
.b3dc	c9 3a		cmp #$3a			cmp 	#':' 						; check if :
.b3de	d0 03		bne $b3e3			bne 	_LCPContinue
.b3e0	20 f7 b4	jsr $b4f7			jsr 	LCLDeleteLastSpace 			; if so delete any preceding spaces
.b3e3					_LCPContinue:
.b3e3	c9 2e		cmp #$2e			cmp 	#'.'
.b3e5	f0 08		beq $b3ef			beq 	_LCPIsConstant
.b3e7	c9 30		cmp #$30			cmp 	#'0'
.b3e9	90 0b		bcc $b3f6			bcc 	_LCPNotConstant
.b3eb	c9 3a		cmp #$3a			cmp 	#'9'+1
.b3ed	b0 07		bcs $b3f6			bcs 	_LCPNotConstant
.b3ef					_LCPIsConstant:
.b3ef	48		pha				pha
.b3f0	a9 8d		lda #$8d			lda 	#CLIConstant+$80
.b3f2	20 d8 b4	jsr $b4d8			jsr 	LCLWriteColour
.b3f5	68		pla				pla
.b3f6					_LCPNotConstant:
.b3f6	c8		iny				iny 								; consume character
.b3f7	20 e1 b4	jsr $b4e1			jsr 	LCLWrite 					; write it out.
.b3fa	80 94		bra $b390			bra 	_LCMainLoop 				; go round again.
.b3fc					_LCIdentifiers:
.b3fc	18		clc				clc 								; convert to physical address
.b3fd	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.b3ff	85 37		sta $37				sta 	zTemp0+1
.b401	c8		iny				iny
.b402	b1 30		lda ($30),y			lda 	(codePtr),y
.b404	85 36		sta $36				sta 	zTemp0
.b406	c8		iny				iny
.b407	5a		phy				phy 								; save position
.b408	a9 87		lda #$87			lda 	#CLIIdentifier+$80
.b40a	20 d8 b4	jsr $b4d8			jsr 	LCLWriteColour
.b40d	a0 07		ldy #$07			ldy 	#7 							; output the identifier at +8
.b40f					_LCOutIdentifier:
.b40f	c8		iny				iny
.b410	b1 36		lda ($36),y			lda 	(zTemp0),y					; bit 7 set = end.
.b412	29 7f		and #$7f			and 	#$7F
.b414	20 33 b5	jsr $b533			jsr 	LCLLowerCase
.b417	20 e1 b4	jsr $b4e1			jsr 	LCLWrite
.b41a	b1 36		lda ($36),y			lda 	(zTemp0),y				 	; ends when bit 7 set.
.b41c	10 f1		bpl $b40f			bpl 	_LCOutIdentifier
.b41e	7a		ply				ply 								; restore position
.b41f	4c 90 b3	jmp $b390			jmp 	_LCMainLoop
.b422					_LCTokens:
.b422	aa		tax				tax 								; token in X
.b423	a9 94		lda #$94			lda 	#((KeywordSet2) & $FF)
.b425	85 36		sta $36				sta 	0+zTemp0
.b427	a9 bc		lda #$bc			lda 	#((KeywordSet2) >> 8)
.b429	85 37		sta $37				sta 	1+zTemp0
.b42b	e0 82		cpx #$82			cpx 	#$82
.b42d	f0 16		beq $b445			beq 	_LCUseShift
.b42f	a9 37		lda #$37			lda 	#((KeywordSet1) & $FF)
.b431	85 36		sta $36				sta 	0+zTemp0
.b433	a9 bc		lda #$bc			lda 	#((KeywordSet1) >> 8)
.b435	85 37		sta $37				sta 	1+zTemp0
.b437	e0 81		cpx #$81			cpx 	#$81
.b439	f0 0a		beq $b445			beq 	_LCUseShift
.b43b	a9 3a		lda #$3a			lda 	#((KeywordSet0) & $FF)
.b43d	85 36		sta $36				sta 	0+zTemp0
.b43f	a9 ba		lda #$ba			lda 	#((KeywordSet0) >> 8)
.b441	85 37		sta $37				sta 	1+zTemp0
.b443	80 01		bra $b446			bra 	_LCNoShift
.b445					_LCUseShift:
.b445	c8		iny				iny
.b446					_LCNoShift:
.b446	20 0b b5	jsr $b50b			jsr 	LCLCheckSpaceRequired 		; do we need a space ?
.b449	b1 30		lda ($30),y			lda 	(codePtr),y
.b44b	aa		tax				tax 								; into X
.b44c					_LCFindText:
.b44c	ca		dex				dex
.b44d	10 0e		bpl $b45d			bpl 	_LCFoundText 				; found text.
.b44f	b2 36		lda ($36)			lda 	(zTemp0) 					; length of text
.b451	1a		inc a				inc 	a 							; one extra for size
.b452	38		sec				sec 								; one extra for checksum
.b453	65 36		adc $36				adc 	zTemp0 						; go to next token
.b455	85 36		sta $36				sta 	zTemp0
.b457	90 f3		bcc $b44c			bcc 	_LCFindText
.b459	e6 37		inc $37				inc 	zTemp0+1
.b45b	80 ef		bra $b44c			bra 	_LCFindText
.b45d					_LCFoundText:
.b45d	5a		phy				phy 								; save List position
.b45e	b2 36		lda ($36)			lda 	(zTemp0)					; count to print
.b460	aa		tax				tax
.b461	a9 83		lda #$83			lda 	#CLIToken+$80
.b463	20 d8 b4	jsr $b4d8			jsr 	LCLWriteColour
.b466	a0 02		ldy #$02			ldy 	#2
.b468					_LCCopyToken:
.b468	b1 36		lda ($36),y			lda 	(zTemp0),y
.b46a	20 33 b5	jsr $b533			jsr 	LCLLowerCase
.b46d	20 e1 b4	jsr $b4e1			jsr 	LCLWrite
.b470	c8		iny				iny
.b471	ca		dex				dex
.b472	d0 f4		bne $b468			bne 	_LCCopyToken
.b474	c9 28		cmp #$28			cmp 	#"(" 						; if last char not ( print a space
.b476	f0 05		beq $b47d			beq 	_LCNoSpace
.b478	a9 20		lda #$20			lda 	#' '
.b47a	20 e1 b4	jsr $b4e1			jsr 	LCLWrite
.b47d					_LCNoSpace:
.b47d	7a		ply				ply 								; restore position.
.b47e	c8		iny				iny 								; consume token
.b47f	4c 90 b3	jmp $b390			jmp 	_LCMainLoop 				; and go around again.
.b482					_LCData:
.b482	48		pha				pha 								; save type $FE/$FF
.b483	a2 24		ldx #$24			ldx 	#'$' 						; figure out $ or "
.b485	c9 fe		cmp #$fe			cmp 	#$FE
.b487	f0 22		beq $b4ab			beq 	_LCHaveOpener
.b489	a2 22		ldx #$22			ldx 	#'"'
.b48b	a9 81		lda #$81			lda 	#CLIData+$80
.b48d	20 d8 b4	jsr $b4d8			jsr 	LCLWriteColour
.b490	c0 04		cpy #$04			cpy 	#4 							; must be 2nd thing on line
.b492	d0 17		bne $b4ab			bne 	_LCHaveOpener
.b494	88		dey				dey 								; what precedes it ?
.b495	b1 30		lda ($30),y			lda 	(codePtr),y
.b497	c8		iny				iny
.b498	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; if quote
.b49a	d0 0f		bne $b4ab			bne 	_LCHaveOpener
.b49c	a9 09		lda #$09			lda 	#9 							; tab
.b49e	20 e1 b4	jsr $b4e1			jsr 	LCLWrite
.b4a1	a9 97		lda #$97			lda 	#$90+CLIBComment
.b4a3	20 e1 b4	jsr $b4e1			jsr 	LCLWrite
.b4a6	a9 80		lda #$80			lda 	#CLIFComment+$80
.b4a8	20 d8 b4	jsr $b4d8			jsr 	LCLWriteColour
.b4ab					_LCHaveOpener:
.b4ab	8a		txa				txa 								; output prefix (# or ")
.b4ac	20 e1 b4	jsr $b4e1			jsr 	LCLWrite
.b4af	c8		iny				iny 								; get count
.b4b0	b1 30		lda ($30),y			lda 	(codePtr),y
.b4b2	aa		tax				tax
.b4b3	c8		iny				iny 								; point at first character
.b4b4					_LCOutData:
.b4b4	b1 30		lda ($30),y			lda 	(codePtr),y
.b4b6	c9 00		cmp #$00			cmp 	#0
.b4b8	f0 03		beq $b4bd			beq 	_LCNoPrint
.b4ba	20 e1 b4	jsr $b4e1			jsr 	LCLWrite
.b4bd					_LCNoPrint:
.b4bd	c8		iny				iny
.b4be	ca		dex				dex
.b4bf	d0 f3		bne $b4b4			bne 	_LCOutData
.b4c1	68		pla				pla 								; closing " required ?
.b4c2	c9 ff		cmp #$ff			cmp 	#$FF 						; not required for hex constant.
.b4c4	d0 0f		bne $b4d5			bne 	_LCNoQuote
.b4c6	a9 22		lda #$22			lda 	#'"'
.b4c8	20 e1 b4	jsr $b4e1			jsr 	LCLWrite
.b4cb	ad c2 05	lda $05c2			lda 	EXTTextColour
.b4ce	29 0f		and #$0f			and 	#$0F
.b4d0	09 90		ora #$90			ora 	#$90
.b4d2	20 e1 b4	jsr $b4e1			jsr 	LCLWrite
.b4d5					_LCNoQuote:
.b4d5	4c 90 b3	jmp $b390			jmp 	_LCMainLoop
.b4d8					LCLWriteColour:
.b4d8	cd 29 04	cmp $0429			cmp 	currentListColour 			; has the colour changed
.b4db	8d 29 04	sta $0429			sta 	currentListColour 			; (update it anyway)
.b4de	d0 01		bne $b4e1			bne 	LCLWrite 					; if different, output it
.b4e0	60		rts				rts
.b4e1					LCLWrite:
.b4e1	da		phx				phx
.b4e2	ae 1d 04	ldx $041d			ldx 	tbOffset 					; write out make ASCIIZ
.b4e5	9d 2d 04	sta $042d,x			sta 	tokenBuffer,x
.b4e8	9e 2e 04	stz $042e,x			stz 	tokenBuffer+1,x
.b4eb	ee 1d 04	inc $041d			inc 	tbOffset 					; bump the position
.b4ee	09 00		ora #$00			ora 	#0 							; don't update last character if colour data
.b4f0	30 03		bmi $b4f5			bmi 	_LCLNoColour
.b4f2	8d 27 04	sta $0427			sta 	LCLastCharacter
.b4f5					_LCLNoColour:
.b4f5	fa		plx				plx
.b4f6	60		rts				rts
.b4f7					LCLDeleteLastSpace:
.b4f7	48		pha				pha
.b4f8	da		phx				phx
.b4f9	ae 1d 04	ldx $041d			ldx 	tbOffset
.b4fc	f0 0a		beq $b508			beq 	_LCDLSExit
.b4fe	bd 2c 04	lda $042c,x			lda 	tokenBuffer-1,x
.b501	c9 20		cmp #$20			cmp 	#' '
.b503	d0 03		bne $b508			bne 	_LCDLSExit
.b505	ce 1d 04	dec $041d			dec 	tbOffset
.b508					_LCDLSExit:
.b508	fa		plx				plx
.b509	68		pla				pla
.b50a	60		rts				rts
.b50b					LCLCheckSpaceRequired:
.b50b	ad 27 04	lda $0427			lda 	LCLastCharacter 			; check last character
.b50e	c9 24		cmp #$24			cmp 	#'$' 						; $ # and ) require that token space.
.b510	f0 1b		beq $b52d			beq 	_LCCSRSpace
.b512	c9 29		cmp #$29			cmp 	#')'
.b514	f0 17		beq $b52d			beq 	_LCCSRSpace
.b516	c9 23		cmp #$23			cmp 	#'#'
.b518	f0 13		beq $b52d			beq 	_LCCSRSpace
.b51a	20 33 b5	jsr $b533			jsr 	LCLLowerCase 				; saves a little effort
.b51d	c9 30		cmp #$30			cmp 	#"0" 						; check if it was 0-9 A-Z a-z if so need space.
.b51f	90 11		bcc $b532			bcc 	_LCCSRExit
.b521	c9 3a		cmp #$3a			cmp 	#"9"+1
.b523	90 08		bcc $b52d			bcc 	_LCCSRSpace
.b525	c9 61		cmp #$61			cmp 	#"a"
.b527	90 09		bcc $b532			bcc 	_LCCSRExit
.b529	c9 7b		cmp #$7b			cmp 	#"z"+1
.b52b	b0 05		bcs $b532			bcs 	_LCCSRExit
.b52d					_LCCSRSpace:
.b52d	a9 20		lda #$20			lda 	#' '
.b52f	20 e1 b4	jsr $b4e1			jsr 	LCLWrite
.b532					_LCCSRExit:
.b532	60		rts				rts
.b533					LCLLowerCase:
.b533	c9 41		cmp #$41			cmp 	#"A"
.b535	90 06		bcc $b53d			bcc 	_LCLLCOut
.b537	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b539	b0 02		bcs $b53d			bcs 	_LCLLCOut
.b53b	69 20		adc #$20			adc 	#$20
.b53d					_LCLLCOut:
.b53d	60		rts				rts
.b53e					LCLUpperCase:
.b53e	c9 61		cmp #$61			cmp 	#"a"
.b540	90 06		bcc $b548			bcc 	_LCLUCOut
.b542	c9 7b		cmp #$7b			cmp 	#"z"+1
.b544	b0 02		bcs $b548			bcs 	_LCLUCOut
.b546	e9 1f		sbc #$1f			sbc 	#$1F
.b548					_LCLUCOut:
.b548	60		rts				rts
.b549					LCLWriteNumberXA:
.b549	64 37		stz $37				stz 	zTemp0+1 					; index into digit table.
.b54b					_LCLWNLoop1:
.b54b	64 36		stz $36				stz 	zTemp0 						; subtraction count.
.b54d					_LCLWNLoop2:
.b54d	48		pha				pha 								; save initial LSB
.b54e	38		sec				sec
.b54f	a4 37		ldy $37				ldy 	zTemp0+1 					; position in table.
.b551	f9 82 b5	sbc $b582,y			sbc 	_LCLWNTable,y
.b554	48		pha				pha
.b555	8a		txa				txa
.b556	f9 83 b5	sbc $b583,y			sbc 	_LCLWNTable+1,y
.b559	90 07		bcc $b562			bcc 	_LCLWNUnderflow
.b55b	e6 36		inc $36				inc 	zTemp0  					; subtracted one without borrow.
.b55d	aa		tax				tax 								; update X
.b55e	68		pla				pla 								; restore A
.b55f	7a		ply				ply 								; throw original
.b560	80 eb		bra $b54d			bra 	_LCLWNLoop2 				; try again.
.b562					_LCLWNUnderflow:
.b562	a4 36		ldy $36				ldy 	zTemp0 						; count of subtractions.
.b564	d0 06		bne $b56c			bne 	_LCLWNOut
.b566	ad 1d 04	lda $041d			lda 	tbOffset 					; suppress leading zeroes
.b569	3a		dec a				dec 	a
.b56a	f0 04		beq $b570			beq 	_LCLWNNext
.b56c					_LCLWNOut:
.b56c	98		tya				tya
.b56d	20 7c b5	jsr $b57c			jsr 	_LCLWNOutDigit
.b570					_LCLWNNext:
.b570	7a		ply				ply 							 	; restore original value.
.b571	68		pla				pla
.b572	a4 37		ldy $37				ldy 	zTemp0+1  					; bump the index
.b574	c8		iny				iny
.b575	c8		iny				iny
.b576	84 37		sty $37				sty 	zTemp0+1
.b578	c0 08		cpy #$08			cpy 	#8 							; done all 4
.b57a	d0 cf		bne $b54b			bne 	_LCLWNLoop1
.b57c					_LCLWNOutDigit:
.b57c	09 30		ora #$30			ora 	#'0'
.b57e	20 e1 b4	jsr $b4e1			jsr 	LCLWrite
.b581	60		rts				rts
.b582					_LCLWNTable:
>b582	10 27						.word 	10000
>b584	e8 03						.word 	1000
>b586	64 00						.word 	100
>b588	0a 00						.word 	10
.b58a					TOKSearchTable:
.b58a	84 37		sty $37				sty 	zTemp0+1 					; (zTemp0),y points to current token being tested.
.b58c	85 36		sta $36				sta 	zTemp0
.b58e	a0 00		ldy #$00			ldy 	#0
.b590	a9 80		lda #$80			lda 	#$80 						; token # so we know which one we are looking at
.b592	85 38		sta $38				sta 	zTemp1
.b594					_TSTLoop:
.b594	b1 36		lda ($36),y			lda 	(zTemp0),y 					; length, 0 (skip) -ve (end)
.b596	30 49		bmi $b5e1			bmi 	_TSTFail 					; -ve = end of table, so fail.
.b598	f0 2e		beq $b5c8			beq 	_TSTNext 					; zero, check next as it's a dummy (e.g. EOL, SHIFT)
.b59a	c8		iny				iny 								; get the hash
.b59b	b1 36		lda ($36),y			lda 	(zTemp0),y
.b59d	88		dey				dey
.b59e	cd 03 04	cmp $0403			cmp 	identHash 					; check they match with the identifier hash, if not go to next
.b5a1	d0 25		bne $b5c8			bne 	_TSTNext
.b5a3	ad 02 04	lda $0402			lda 	identTypeEnd 				; get length of identifier from end-start
.b5a6	38		sec				sec
.b5a7	ed 00 04	sbc $0400			sbc 	identStart
.b5aa	d1 36		cmp ($36),y			cmp 	(zTemp0),y 					; compare against the length in the table, no match, then return.
.b5ac	d0 1a		bne $b5c8			bne 	_TSTNext
.b5ae	5a		phy				phy 								; save Y , we might fail to match.
.b5af	c8		iny				iny 								; point to text
.b5b0	c8		iny				iny
.b5b1	ae 00 04	ldx $0400			ldx 	identStart 					; offset in line buffer in X
.b5b4					_TSTCompareName:
.b5b4	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; compare text.
.b5b7	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.b5b9	d0 0c		bne $b5c7			bne 	_TSTNextPullY 				; fail, pullY and do next
.b5bb	e8		inx				inx
.b5bc	c8		iny				iny
.b5bd	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; complete match.
.b5c0	d0 f2		bne $b5b4			bne 	_TSTCompareName
.b5c2	7a		ply				ply 								; throw Y
.b5c3	a5 38		lda $38				lda 	zTemp1 						; get token #
.b5c5	38		sec				sec 								; return with CS = passed.
.b5c6	60		rts				rts
.b5c7					_TSTNextPullY:
.b5c7	7a		ply				ply 								; restore current, fall through.
.b5c8					_TSTNext:
.b5c8	e6 38		inc $38				inc 	zTemp1 						; token counter
.b5ca	98		tya				tya
.b5cb	18		clc				clc
.b5cc	71 36		adc ($36),y			adc 	(zTemp0),y 					; add [Length] + 2 to Y
.b5ce	1a		inc a				inc 	a 							; +1
.b5cf	1a		inc a				inc 	a 							; +2
.b5d0	a8		tay				tay
.b5d1	10 c1		bpl $b594			bpl 	_TSTLoop 					; if Y < $80 loop back
.b5d3	98		tya				tya 								; add Y to zTemp0 and reset Y
.b5d4	a0 00		ldy #$00			ldy 	#0   						; so we can use Y to search fast
.b5d6	18		clc				clc  								; but have tables > 255 bytes
.b5d7	65 36		adc $36				adc 	zTemp0 						; when Y gets >= 128 we reset Y
.b5d9	85 36		sta $36				sta 	zTemp0 						; and adjust the table pointer/
.b5db	90 b7		bcc $b594			bcc 	_TSTLoop
.b5dd	e6 37		inc $37				inc 	zTemp0+1
.b5df	80 b3		bra $b594			bra 	_TSTLoop
.b5e1					_TSTFail:
.b5e1	18		clc				clc
.b5e2	60		rts				rts
.b5e3					Export_TKTokeniseLine:
.b5e3	20 6b b7	jsr $b76b			jsr 	LCLFixLineBufferCase 		; fix line case
.b5e6	a9 03		lda #$03			lda 	#3 							; reset the token buffer to empty
.b5e8	8d 2a 04	sta $042a			sta 	tokenOffset 				; (3 bytes for line number & offset)
.b5eb	9c 2b 04	stz $042b			stz 	tokenLineNumber
.b5ee	9c 2c 04	stz $042c			stz 	tokenLineNumber+1
.b5f1	a2 ff		ldx #$ff			ldx 	#$FF
.b5f3					_TKFindFirst:
.b5f3	e8		inx				inx
.b5f4	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.b5f7	f0 79		beq $b672			beq 	_TKExit
.b5f9	c9 20		cmp #$20			cmp 	#' '
.b5fb	90 f6		bcc $b5f3			bcc 	_TKFindFirst
.b5fd	c9 30		cmp #$30			cmp 	#'0'
.b5ff	90 07		bcc $b608			bcc 	_TKNoLineNumber
.b601	c9 3a		cmp #$3a			cmp 	#'9'+1
.b603	b0 03		bcs $b608			bcs 	_TKNoLineNumber
.b605	20 95 b7	jsr $b795			jsr 	TOKExtractLineNumber
.b608					_TKNoLineNumber:
.b608					_TKTokeniseLoop:
.b608	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; next character, exit if zero EOL.
.b60b	f0 65		beq $b672			beq 	_TKExit
.b60d	e8		inx				inx
.b60e	c9 20		cmp #$20			cmp 	#' '
.b610	f0 f6		beq $b608			beq 	_TKTokeniseLoop 			; keep looping if space found.
.b612	ca		dex				dex 								; undo last get, A contains character, X is position.
.b613	c9 5f		cmp #$5f			cmp 	#'_'						; _ A-Z is identifier *or* token
.b615	f0 61		beq $b678			beq 	_TKTokeniseIdentifier 		; (already case converted outside string constants)
.b617	c9 41		cmp #$41			cmp 	#'A'
.b619	90 04		bcc $b61f			bcc 	_TKTokenisePunctuation
.b61b	c9 5b		cmp #$5b			cmp 	#'Z'+1
.b61d	90 59		bcc $b678			bcc 	_TKTokeniseIdentifier
.b61f					_TKTokenisePunctuation:
.b61f	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.b621	f0 27		beq $b64a			beq 	_TKString
.b623	c9 24		cmp #$24			cmp 	#'$'						; hexadecimal constant ($ only appears at end of identifiers)
.b625	f0 28		beq $b64f			beq 	_TKHexConstant
.b627	c9 3c		cmp #$3c			cmp 	#'<' 						; check for < > handlers - these are for <> <= >= >> <<
.b629	f0 29		beq $b654			beq 	_TKCheckDouble
.b62b	c9 3e		cmp #$3e			cmp 	#'>'
.b62d	f0 25		beq $b654			beq 	_TKCheckDouble
.b62f					_TKStandardPunctuation:
.b62f	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get the punctuation token back.
.b632	c9 40		cmp #$40			cmp 	#64 						; are we >= 64
.b634	90 0e		bcc $b644			bcc 	_TKNoShift
.b636	48		pha				pha 								; save. we are about to convert this punctuation token from
.b637	29 07		and #$07			and 	#7 							; lower 3 bits in zTemp0
.b639	85 36		sta $36				sta 	zTemp0
.b63b	68		pla				pla
.b63c	29 20		and #$20			and 	#32 						; bit 5
.b63e	4a		lsr a				lsr 	a 							; shift into bit 3
.b63f	4a		lsr a				lsr 	a
.b640	05 36		ora $36				ora 	zTemp0
.b642	09 10		ora #$10			ora 	#$10						; now in the range 16-31
.b644					_TKNoShift:
.b644	20 da b7	jsr $b7da			jsr 	TOKWriteByte 				; write the punctuation character
.b647	e8		inx				inx 								; consume the character
.b648	80 be		bra $b608			bra 	_TKTokeniseLoop 			; and loop round again.
.b64a					_TKString:
.b64a	20 fa b6	jsr $b6fa			jsr 	TOKTokenString
.b64d	80 b9		bra $b608			bra 	_TKTokeniseLoop
.b64f					_TKHexConstant:
.b64f	20 35 b7	jsr $b735			jsr 	TOKHexConstant
.b652	80 b4		bra $b608			bra 	_TKTokeniseLoop
.b654					_TKCheckDouble:
.b654	bd 2b 05	lda $052b,x			lda 	lineBuffer+1,x 				; get next character
.b657	c9 3c		cmp #$3c			cmp 	#'<'						; if not < = > which are ASCII consecutive go back
.b659	90 d4		bcc $b62f			bcc 	_TKStandardPunctuation 		; and do the normal punctuation handler.
.b65b	c9 3f		cmp #$3f			cmp 	#'>'+1
.b65d	b0 d0		bcs $b62f			bcs 	_TKStandardPunctuation
.b65f	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; this is < (60) or > (62)
.b662	29 02		and #$02			and 	#2 							; now < (0) or > (2)
.b664	0a		asl a				asl 	a 							; now < (0) or > (4), CC also
.b665	7d 2b 05	adc $052b,x			adc 	lineBuffer+1,x 				; add < = > codes - < code
.b668	38		sec				sec
.b669	e9 3c		sbc #$3c			sbc 	#'<'
.b66b	20 da b7	jsr $b7da			jsr 	TOKWriteByte 				; this is in the range 0-7
.b66e	e8		inx				inx 								; consume both
.b66f	e8		inx				inx
.b670	80 96		bra $b608			bra 	_TKTokeniseLoop
.b672	a9 80		lda #$80	_TKExit:lda 	#KWC_EOL 					; write end of line byte
.b674	20 da b7	jsr $b7da			jsr 	TOKWriteByte
.b677	60		rts				rts
.b678					_TKTokeniseIdentifier:
.b678	8e 00 04	stx $0400			stx 	identStart 					; save start
.b67b	9c 04 04	stz $0404			stz 	identTypeByte 				; zero the type byte
.b67e					_TKCheckLoop:
.b67e	e8		inx				inx 								; look at next, we know first is identifier already.
.b67f	bd 2a 05	lda $052a,x			lda  	lineBuffer,x
.b682	c9 5f		cmp #$5f			cmp 	#"_" 						; legal char _ 0-9 A-Z
.b684	f0 f8		beq $b67e			beq 	_TKCheckLoop
.b686	c9 30		cmp #$30			cmp	 	#"0"
.b688	90 0c		bcc $b696			bcc 	_TKEndIdentifier
.b68a	c9 3a		cmp #$3a			cmp 	#"9"+1
.b68c	90 f0		bcc $b67e			bcc 	_TKCheckLoop
.b68e	c9 41		cmp #$41			cmp	 	#"A"
.b690	90 04		bcc $b696			bcc 	_TKEndIdentifier
.b692	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b694	90 e8		bcc $b67e			bcc 	_TKCheckLoop
.b696					_TKEndIdentifier:
.b696	8e 01 04	stx $0401			stx 	identTypeStart 				; save start of type text (if any !)
.b699	a0 08		ldy #$08			ldy 	#$08 						; this is the identifier type byte for #
.b69b	c9 23		cmp #$23			cmp 	#"#"						; followed by #
.b69d	f0 06		beq $b6a5			beq 	_TKHasTypeCharacter
.b69f	a0 10		ldy #$10			ldy 	#$10 						; this is the identifier type byte for $
.b6a1	c9 24		cmp #$24			cmp 	#"$"						; followed by $ or #
.b6a3	d0 07		bne $b6ac			bne 	_TKNoTypeCharacter
.b6a5					_TKHasTypeCharacter:
.b6a5	8c 04 04	sty $0404			sty 	identTypeByte 				; has # or $, save the type
.b6a8	e8		inx				inx 								; consume the type character
.b6a9	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.b6ac					_TKNoTypeCharacter:
.b6ac	c9 28		cmp #$28			cmp 	#"("						; is it open parenthesis (e.g. array)
.b6ae	d0 09		bne $b6b9			bne 	_TKNoArray
.b6b0	e8		inx				inx 								; skip the (
.b6b1	ad 04 04	lda $0404			lda 	identTypeByte 				; set bit 2 (e.g. array) in type byte
.b6b4	09 04		ora #$04			ora 	#$04
.b6b6	8d 04 04	sta $0404			sta 	identTypeByte
.b6b9					_TKNoArray:
.b6b9	8e 02 04	stx $0402			stx 	identTypeEnd 				; save end marker, e.g. continue from here.
.b6bc	20 56 b7	jsr $b756			jsr 	TOKCalculateHash 			; calculate the has for those tokens
.b6bf	a0 ba		ldy #$ba			ldy 	#(KeywordSet0) >> 8
.b6c1	a9 3a		lda #$3a			lda 	#(KeywordSet0) & $FF
.b6c3	20 8a b5	jsr $b58a			jsr 	TOKSearchTable
.b6c6	a2 00		ldx #$00			ldx 	#0
.b6c8	b0 1f		bcs $b6e9			bcs 	_TKFoundToken
.b6ca	a0 bc		ldy #$bc			ldy 	#(KeywordSet1) >> 8
.b6cc	a9 37		lda #$37			lda 	#(KeywordSet1) & $FF
.b6ce	20 8a b5	jsr $b58a			jsr 	TOKSearchTable
.b6d1	a2 81		ldx #$81			ldx 	#$81
.b6d3	b0 14		bcs $b6e9			bcs 	_TKFoundToken
.b6d5	a0 bc		ldy #$bc			ldy 	#(KeywordSet2) >> 8
.b6d7	a9 94		lda #$94			lda 	#(KeywordSet2) & $FF
.b6d9	20 8a b5	jsr $b58a			jsr 	TOKSearchTable
.b6dc	a2 82		ldx #$82			ldx 	#$82
.b6de	b0 09		bcs $b6e9			bcs 	_TKFoundToken
.b6e0	20 e6 b7	jsr $b7e6			jsr 	TOKCheckCreateVariableRecord ; failed all, it's a variable, create record if does not exist.
.b6e3	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.b6e6	4c 08 b6	jmp $b608			jmp 	_TKTokeniseLoop 			; and go round again.
.b6e9					_TKFoundToken:
.b6e9	48		pha				pha 								; save token
.b6ea	8a		txa				txa 								; shift in X, is there one ?
.b6eb	f0 03		beq $b6f0			beq 	_TKNoTShift
.b6ed	20 da b7	jsr $b7da			jsr 	TOKWriteByte 				; if so, write it out
.b6f0					_TKNoTShift:
.b6f0	68		pla				pla 								; restore and write token
.b6f1	20 da b7	jsr $b7da			jsr 	TOKWriteByte
.b6f4	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.b6f7	4c 08 b6	jmp $b608			jmp 	_TKTokeniseLoop 			; and go round again.
.b6fa					TOKTokenString:
.b6fa	a9 ff		lda #$ff			lda 	#KWC_STRING 				; string token.
.b6fc	20 da b7	jsr $b7da			jsr 	TOKWriteByte
.b6ff	e8		inx				inx									; start of quoted string.
.b700	da		phx				phx 								; push start of string on top
.b701	ca		dex				dex 								; because we pre-increment
.b702					_TSFindEnd:
.b702	e8		inx				inx
.b703	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; next character
.b706	f0 04		beq $b70c			beq 	_TSEndOfString 				; no matching quote, we don't mind.
.b708	c9 22		cmp #$22			cmp 	#'"' 						; go back if quote not found
.b70a	d0 f6		bne $b702			bne 	_TSFindEnd
.b70c					_TSEndOfString:
.b70c	7a		ply				ply  								; so now Y is first character, X is character after end.
.b70d	48		pha				pha 								; save terminating character
.b70e	20 16 b7	jsr $b716			jsr 	TOKWriteBlockXY 			; write X to Y as a data block
.b711	68		pla				pla 								; terminating character
.b712	f0 01		beq $b715			beq 	_TSNotQuote					; if it wasn't EOS skip it
.b714	e8		inx				inx
.b715					_TSNotQuote:
.b715	60		rts				rts
.b716					TOKWriteBlockXY:
.b716	86 36		stx $36				stx 	zTemp0 						; save end character
.b718	98		tya				tya 								; use 2's complement to work out the byte size
.b719	49 ff		eor #$ff			eor 	#$FF
.b71b	38		sec				sec
.b71c	65 36		adc $36				adc 	zTemp0
.b71e	1a		inc a				inc 	a 							; one extra for NULL
.b71f	20 da b7	jsr $b7da			jsr 	TOKWriteByte
.b722					_TOBlockLoop:
.b722	c4 36		cpy $36				cpy 	zTemp0 						; exit if reached the end
.b724	f0 09		beq $b72f			beq 	_TOBlockExit
.b726	b9 2a 05	lda $052a,y			lda 	lineBuffer,y 				; write byte out.
.b729	20 da b7	jsr $b7da			jsr 	TOKWriteByte
.b72c	c8		iny				iny
.b72d	80 f3		bra $b722			bra 	_TOBlockLoop
.b72f					_TOBlockExit:
.b72f	a9 00		lda #$00			lda 	#0 							; add NULL.
.b731	20 da b7	jsr $b7da			jsr 	TOKWriteByte
.b734	60		rts				rts
.b735					TOKHexConstant:
.b735	a9 fe		lda #$fe			lda 	#KWC_HEXCONST 				; hex constant token.
.b737	20 da b7	jsr $b7da			jsr 	TOKWriteByte
.b73a	e8		inx				inx									; start of quoted string.
.b73b	da		phx				phx 								; push start of constant on top
.b73c	ca		dex				dex
.b73d					_THFindLoop:
.b73d	e8		inx				inx 	 							; this is stored in a block, so find out how long
.b73e	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; the hex constant is.
.b741	c9 30		cmp #$30			cmp 	#"0"
.b743	90 0c		bcc $b751			bcc 	_THFoundEnd
.b745	c9 3a		cmp #$3a			cmp 	#"9"+1
.b747	90 f4		bcc $b73d			bcc 	_THFindLoop
.b749	c9 41		cmp #$41			cmp 	#"A"
.b74b	90 04		bcc $b751			bcc 	_THFoundEnd
.b74d	c9 47		cmp #$47			cmp 	#"F"+1
.b74f	90 ec		bcc $b73d			bcc 	_THFindLoop
.b751					_THFoundEnd:
.b751	7a		ply				ply 								; restore start
.b752	20 16 b7	jsr $b716			jsr 	TOKWriteBlockXY 			; output the block
.b755	60		rts				rts
.b756					TOKCalculateHash:
.b756	da		phx				phx
.b757	ae 00 04	ldx $0400			ldx 	identStart 					; needs to be same as in tokens.py - simple sum at present.
.b75a	a9 00		lda #$00			lda 	#0
.b75c					_TCHLoop:
.b75c	18		clc				clc
.b75d	7d 2a 05	adc $052a,x			adc 	lineBuffer,x
.b760	e8		inx				inx
.b761	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; do the whole thing including type and array markers.
.b764	d0 f6		bne $b75c			bne 	_TCHLoop
.b766	8d 03 04	sta $0403			sta 	identHash 					; save the hash
.b769	fa		plx				plx
.b76a	60		rts				rts
.b76b					LCLFixLineBufferCase:
.b76b	a2 00		ldx #$00			ldx 	#0
.b76d					_FLBCLoop:
.b76d	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get next character
.b770	f0 22		beq $b794			beq 	_FLBCExit 					; end of string.
.b772	c9 22		cmp #$22			cmp 	#'"'						; quote, go to in quotes
.b774	f0 11		beq $b787			beq 	_FLBCInQuotes
.b776	e8		inx				inx
.b777	c9 61		cmp #$61			cmp 	#'a'						; needs capitalising ?
.b779	90 f2		bcc $b76d			bcc 	_FLBCLoop
.b77b	c9 7b		cmp #$7b			cmp 	#'z'+1
.b77d	b0 ee		bcs $b76d			bcs 	_FLBCLoop
.b77f	38		sec				sec 								; make U/C
.b780	e9 20		sbc #$20			sbc 	#32
.b782	9d 29 05	sta $0529,x			sta	 	lineBuffer-1,x 				; write back
.b785	80 e6		bra $b76d			bra 	_FLBCLoop
.b787					_FLBCInQuotes:
.b787	e8		inx				inx 								; advance
.b788	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get next
.b78b	f0 07		beq $b794			beq 	_FLBCExit 					; exit on EOS
.b78d	c9 22		cmp #$22			cmp 	#'"' 				 		; until " found
.b78f	d0 f6		bne $b787			bne 	_FLBCInQuotes
.b791	e8		inx				inx 								; skip over it
.b792	80 d9		bra $b76d			bra 	_FLBCLoop
.b794					_FLBCExit:
.b794	60		rts				rts
.b795					TOKExtractLineNumber:
.b795	ad 2c 04	lda $042c			lda 	tokenLineNumber+1 			; push current value on stack
.b798	48		pha				pha
.b799	ad 2b 04	lda $042b			lda 	tokenLineNumber
.b79c	48		pha				pha
.b79d	20 d3 b7	jsr $b7d3			jsr 	_LCLNTimes2 				; line # x 2
.b7a0	20 d3 b7	jsr $b7d3			jsr 	_LCLNTimes2 				; line # x 4
.b7a3	18		clc				clc 								; add stacked value
.b7a4	68		pla				pla
.b7a5	6d 2b 04	adc $042b			adc 	tokenLineNumber
.b7a8	8d 2b 04	sta $042b			sta 	tokenLineNumber
.b7ab	68		pla				pla
.b7ac	6d 2c 04	adc $042c			adc 	tokenLineNumber+1
.b7af	8d 2c 04	sta $042c			sta 	tokenLineNumber+1 			; line # x 5
.b7b2	20 d3 b7	jsr $b7d3			jsr 	_LCLNTimes2 				; line # x 10
.b7b5	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get and consume character
.b7b8	e8		inx				inx
.b7b9	29 0f		and #$0f			and 	#15 						; add to line #
.b7bb	18		clc				clc
.b7bc	6d 2b 04	adc $042b			adc 	tokenLineNumber
.b7bf	8d 2b 04	sta $042b			sta 	tokenLineNumber
.b7c2	90 03		bcc $b7c7			bcc 	_TLENNoCarry
.b7c4	ee 2c 04	inc $042c			inc 	tokenLineNumber+1
.b7c7					_TLENNoCarry:
.b7c7	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; more digits ?
.b7ca	c9 30		cmp #$30			cmp 	#'0'
.b7cc	90 04		bcc $b7d2			bcc 	_TLENExit
.b7ce	c9 3a		cmp #$3a			cmp 	#'9'+1
.b7d0	90 c3		bcc $b795			bcc 	TOKExtractLineNumber
.b7d2					_TLENExit:
.b7d2	60		rts				rts
.b7d3					_LCLNTimes2:
.b7d3	0e 2b 04	asl $042b			asl 	tokenLineNumber 			; doubles tokenLineNumber.
.b7d6	2e 2c 04	rol $042c			rol 	tokenLineNumber+1
.b7d9	60		rts				rts
.b7da					TOKWriteByte:
.b7da	da		phx				phx
.b7db	ae 2a 04	ldx $042a			ldx 	tokenOffset 				; next slot to write to
.b7de	9d 2a 04	sta $042a,x			sta 	tokenOffset,x 				; write byte out
.b7e1	ee 2a 04	inc $042a			inc 	tokenOffset 				; advance slot.
.b7e4	fa		plx				plx
.b7e5	60		rts				rts
.b7e6					TOKCheckCreateVariableRecord:
.b7e6	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.b7e8	85 36		sta $36				sta 	0+zTemp0
.b7ea	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.b7ec	85 37		sta $37				sta 	1+zTemp0
.b7ee					_CCVSearch:
.b7ee	b2 36		lda ($36)			lda 	(zTemp0) 					; end of list
.b7f0	f0 2c		beq $b81e			beq 	_CCVFail
.b7f2	a0 01		ldy #$01			ldy 	#1 							; read the hash
.b7f4	b1 36		lda ($36),y			lda 	(zTemp0),y 					; does it match ?
.b7f6	cd 03 04	cmp $0403			cmp 	identHash 	  				; if not, try the next.
.b7f9	d0 16		bne $b811			bne 	_CCVNext
.b7fb	a0 08		ldy #$08			ldy 	#8 							; name in variable record
.b7fd	ae 00 04	ldx $0400			ldx 	identStart
.b800					_CCVCompare:
.b800	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; xor them. zero if the same, except
.b803	51 36		eor ($36),y			eor 	(zTemp0),y 					; bit 7 is used for EOS.
.b805	e8		inx				inx 								; advance pointers
.b806	c8		iny				iny
.b807	0a		asl a				asl 	a 							; A = 0 if they match, CS if end.
.b808	d0 07		bne $b811			bne 	_CCVNext  					; didn't match go to next.
.b80a	90 f4		bcc $b800			bcc 	_CCVCompare 				; not finished yet.
.b80c	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; matched whole thing ?
.b80f	f0 41		beq $b852			beq 	_CCVFound 					; yes, we were successful
.b811					_CCVNext:
.b811	18		clc				clc 								; go to next record.
.b812	b2 36		lda ($36)			lda 	(zTemp0) 					; add offset to pointer
.b814	65 36		adc $36				adc 	zTemp0
.b816	85 36		sta $36				sta 	zTemp0
.b818	90 d4		bcc $b7ee			bcc 	_CCVSearch
.b81a	e6 37		inc $37				inc 	zTemp0+1
.b81c	80 d0		bra $b7ee			bra 	_CCVSearch
.b81e					_CCVFail:
.b81e	a0 01		ldy #$01			ldy 	#1 							; create the new record. Offset 1 is hash
.b820	ad 03 04	lda $0403			lda 	identHash
.b823	91 36		sta ($36),y			sta 	(zTemp0),y
.b825	c8		iny				iny 								; offset 2 is the type byte
.b826	ad 04 04	lda $0404			lda 	identTypeByte
.b829	91 36		sta ($36),y			sta 	(zTemp0),y
.b82b	c8		iny				iny
.b82c					_CCVData:
.b82c	a9 00		lda #$00			lda 	#0 							; erase data 3-7 (the 5 value bytes)
.b82e	91 36		sta ($36),y			sta 	(zTemp0),y
.b830	c8		iny				iny
.b831	c0 08		cpy #$08			cpy 	#8
.b833	90 f7		bcc $b82c			bcc 	_CCVData
.b835	ae 00 04	ldx $0400			ldx 	identStart 					; copy name into 8 on.
.b838					_CCVCopyName:
.b838	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.b83b	91 36		sta ($36),y			sta 	(zTemp0),y
.b83d	e8		inx				inx
.b83e	c8		iny				iny
.b83f	ec 02 04	cpx $0402			cpx 	identTypeEnd
.b842	d0 f4		bne $b838			bne 	_CCVCopyName
.b844	98		tya				tya 								; patch offset
.b845	92 36		sta ($36)			sta 	(zTemp0)
.b847	a9 00		lda #$00			lda 	#0 							; offset for next is zero.
.b849	91 36		sta ($36),y			sta 	(zTemp0),y
.b84b	88		dey				dey
.b84c	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set bit 7 of last bit
.b84e	09 80		ora #$80			ora 	#$80
.b850	91 36		sta ($36),y			sta 	(zTemp0),y
.b852					_CCVFound:
.b852	a5 37		lda $37				lda 	zTemp0+1 					; write out MSB
.b854	38		sec				sec
.b855	e9 10		sbc #$10			sbc 	#(VariableSpace >> 8) 		; offset from the start of the variable token
.b857	09 40		ora #$40			ora 	#$40 						; make it a writeable token $4000-$7FFF
.b859	20 da b7	jsr $b7da			jsr 	TOKWriteByte
.b85c	a5 36		lda $36				lda 	zTemp0 						; write out LSB
.b85e	20 da b7	jsr $b7da			jsr 	TOKWriteByte
.b861	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_sound.module

=1					soundIntegrated=1
.b862					SNDCheckChannel:
.b862	aa		tax				tax
.b863	bd 8b 07	lda $078b,x			lda 	SNDTimeLeft,x 				; currently playing a note
.b866	d0 38		bne $b8a0			bne 	_SNDCCExit
.b868	da		phx				phx 								; save current channel
.b869	8a		txa				txa 								; put in A
.b86a	20 e6 b8	jsr $b8e6			jsr 	SNDFindNextNoteForA 		; is there a note for A in the queue ?
.b86d	68		pla				pla 								; channel # in A
.b86e	90 30		bcc $b8a0			bcc 	_SNDCCExit  				; nothing in the queue for this channel, exit.
.b870	a8		tay				tay 								; Y is the channel #
.b871	bd 80 06	lda $0680,x			lda 	SNDQueue+1,x 				; copy data into the slot.
.b874	99 7f 07	sta $077f,y			sta 	SNDPitchLow,y
.b877	bd 81 06	lda $0681,x			lda 	SNDQueue+2,x
.b87a	99 83 07	sta $0783,y			sta 	SNDPitchHigh,y
.b87d	bd 82 06	lda $0682,x			lda 	SNDQueue+3,x
.b880	99 87 07	sta $0787,y			sta 	SNDVolume,y
.b883	bd 83 06	lda $0683,x			lda 	SNDQueue+4,x
.b886	99 8b 07	sta $078b,y			sta 	SNDTimeLeft,y
.b889	bd 84 06	lda $0684,x			lda 	SNDQueue+5,x
.b88c	99 8f 07	sta $078f,y			sta 	SNDAdjustLow,y
.b88f	bd 85 06	lda $0685,x			lda 	SNDQueue+6,x
.b892	99 93 07	sta $0793,y			sta 	SNDAdjustHigh,y
.b895	5a		phy				phy 								; save channel #
.b896	20 00 b9	jsr $b900			jsr 	SNDDeleteXFromQueue 		; delete record at X from queue
.b899	ce 7e 06	dec $067e			dec 	SNDLength 					; reduce the queue length.
.b89c	68		pla				pla
.b89d	20 a1 b8	jsr $b8a1			jsr 	SNDUpdateNote 				; update channel A
.b8a0					_SNDCCExit:
.b8a0	60		rts				rts
.b8a1					SNDUpdateNote:
.b8a1	aa		tax				tax 								; so we can access records
.b8a2	0a		asl a				asl 	a 							; convert it to a channel bit pair in 5,6
.b8a3	0a		asl a				asl 	a
.b8a4	0a		asl a				asl 	a
.b8a5	0a		asl a				asl 	a
.b8a6	0a		asl a				asl 	a
.b8a7	8d 7d 06	sta $067d			sta 	SNDChannelBits
.b8aa	bd 8b 07	lda $078b,x			lda 	SNDTimeLeft,x 				; are we silent
.b8ad	f0 2e		beq $b8dd			beq 	_SNDUNIsSilent
.b8af	ad 7d 06	lda $067d			lda 	SNDChannelBits 				; push channel bits on stack
.b8b2	48		pha				pha
.b8b3	bd 7f 07	lda $077f,x			lda 	SNDPitchLow,x 				; get 4 lowest bits of pitch.
.b8b6	29 0f		and #$0f			and 	#$0F
.b8b8	0d 7d 06	ora $067d			ora 	SNDChannelBits 				; set channel bits
.b8bb	09 80		ora #$80			ora 	#$80 						; write to pitch register
.b8bd	20 4a b9	jsr $b94a			jsr 	SNDWritePorts
.b8c0	bd 83 07	lda $0783,x			lda 	SNDPitchHigh,x 				; pitch high => channel temp.
.b8c3	8d 7d 06	sta $067d			sta 	SNDChannelBits
.b8c6	bd 7f 07	lda $077f,x			lda 	SNDPitchLow,x
.b8c9	4e 7d 06	lsr $067d			lsr 	SNDChannelBits 				; shift 2 LSBs into MSB of A
.b8cc	6a		ror a				ror 	a
.b8cd	4e 7d 06	lsr $067d			lsr 	SNDChannelBits
.b8d0	6a		ror a				ror 	a
.b8d1	4a		lsr a				lsr 	a 							; put in bits 0-5
.b8d2	4a		lsr a				lsr 	a
.b8d3	20 4a b9	jsr $b94a			jsr 	SNDWritePorts 				; write as rest of pitch register
.b8d6	68		pla				pla
.b8d7	09 90		ora #$90			ora 	#$90 						; set to write minimum attentuation.
.b8d9	20 4a b9	jsr $b94a			jsr 	SNDWritePorts
.b8dc	60		rts				rts
.b8dd					_SNDUNIsSilent:
.b8dd	ad 7d 06	lda $067d			lda 	SNDChannelBits 				; channel bits
.b8e0	09 9f		ora #$9f			ora 	#$9F 						; maximum attenuation
.b8e2	20 4a b9	jsr $b94a			jsr 	SNDWritePorts 				; write to the ports
.b8e5	60		rts				rts
.b8e6					SNDFindNextNoteForA:
.b8e6	ac 7e 06	ldy $067e			ldy 	SNDLength 					; queue size into Y
.b8e9	f0 13		beq $b8fe			beq 	_SNDFNNFail 				; queue empty.
.b8eb	a2 00		ldx #$00			ldx 	#0
.b8ed					_SNDFNNSearch:
.b8ed	dd 7f 06	cmp $067f,x			cmp 	SNDQueue,x 					; does it match the channel
.b8f0	38		sec				sec
.b8f1	f0 0c		beq $b8ff			beq 	_SNDFNNExit 				; if so exit with CS.
.b8f3	e8		inx				inx 								; next queue slot.
.b8f4	e8		inx				inx
.b8f5	e8		inx				inx
.b8f6	e8		inx				inx
.b8f7	e8		inx				inx
.b8f8	e8		inx				inx
.b8f9	e8		inx				inx
.b8fa	e8		inx				inx
.b8fb	88		dey				dey 								; done the whole queue
.b8fc	d0 ef		bne $b8ed			bne 	_SNDFNNSearch 				; no, go back.
.b8fe					_SNDFNNFail:
.b8fe	18		clc				clc
.b8ff					_SNDFNNexit:
.b8ff	60		rts				rts
.b900					SNDDeleteXFromQueue:
.b900	e0 f8		cpx #$f8			cpx 	#SNDQueueSize*8-8 			; reached the end.
.b902	f0 09		beq $b90d			beq 	_SNDDXExit
.b904	bd 87 06	lda $0687,x			lda 	SNDQueue+8,x
.b907	9d 7f 06	sta $067f,x			sta 	SNDQueue,x
.b90a	e8		inx				inx
.b90b	80 f3		bra $b900			bra 	SNDDeleteXFromQueue
.b90d					_SNDDXExit:
.b90d	60		rts				rts
.067d					SNDChannelBits:
>067d							.fill 	1
.b90e					SNDQueueRequest:
.b90e	86 36		stx $36				stx 	zTemp0						; save queue address
.b910	84 37		sty $37				sty 	zTemp0+1
.b912	ae 7e 06	ldx $067e			ldx 	SNDLength 					; queue is full, can't take any more.
.b915	e0 20		cpx #$20			cpx 	#SNDQueueSize
.b917	f0 21		beq $b93a			beq 	_SNDQRExit
.b919	29 03		and #$03			and 	#3	 						; channel # and push on stack
.b91b	48		pha				pha
.b91c	8a		txa				txa  								; get offset in queue buffer/
.b91d	0a		asl a				asl 	a
.b91e	0a		asl a				asl 	a
.b91f	0a		asl a				asl 	a
.b920	aa		tax				tax
.b921	68		pla				pla 								; get back and push again
.b922	48		pha				pha
.b923	9d 7f 06	sta $067f,x			sta 	SNDQueue+0,x 				; save the channel #
.b926	a0 00		ldy #$00			ldy 	#0 							; copy the rest in.
.b928					_SNDQCopy:
.b928	b1 36		lda ($36),y			lda 	(zTemp0),y
.b92a	e8		inx				inx
.b92b	c8		iny				iny
.b92c	9d 7f 06	sta $067f,x			sta 	SNDQueue,x
.b92f	c0 06		cpy #$06			cpy 	#6
.b931	d0 f5		bne $b928			bne 	_SNDQCopy
.b933	ee 7e 06	inc $067e			inc 	SNDLength 					; bump queue length.
.b936	68		pla				pla 								; get channel # back
.b937	20 62 b8	jsr $b862			jsr 	SNDCheckChannel 			; check if channel needs refreshing.
.b93a					_SNDQRExit:
.b93a	60		rts				rts
.b93b					SNDSilenceChannel:
.b93b	aa		tax				tax 								; zero time left.
.b93c	9e 8b 07	stz $078b,x			stz 	SNDTimeLeft,x
.b93f	0a		asl a				asl 	a 							; shift into position
.b940	0a		asl a				asl 	a
.b941	0a		asl a				asl 	a
.b942	0a		asl a				asl 	a
.b943	0a		asl a				asl 	a
.b944	09 9f		ora #$9f			ora 	#$9F 						; write register attenuation $F
.b946	20 4a b9	jsr $b94a			jsr 	SNDWritePorts
.b949	60		rts				rts
.b94a					SNDWritePorts:
.b94a	da		phx				phx 								; save X
.b94b	a6 01		ldx $01				ldx 	1 							; save I/O status
.b94d	64 01		stz $01				stz 	1 							; access I/O page 0
.b94f	8d 00 d6	sta $d600			sta 	$D600 						; write to both
.b952	8d 10 d6	sta $d610			sta 	$D610
.b955	86 01		stx $01				stx 	1 							; restore I/O
.b957	fa		plx				plx 								; restore X
.b958	60		rts				rts
.b959					Export_SNDCommand:
.b959	da		phx				phx 								; save XY
.b95a	5a		phy				phy
.b95b	c9 0f		cmp #$0f			cmp 	#$0F 						; $0F is initialise
.b95d	f0 1d		beq $b97c			beq 	_SNDInitialise
.b95f	90 28		bcc $b989			bcc 	_SNDExit
.b961	c9 3f		cmp #$3f			cmp 	#$3F 						; $3F is silence all
.b963	f0 17		beq $b97c			beq 	_SNDSilence
.b965	b0 22		bcs $b989			bcs 	_SNDExit
.b967	c9 20		cmp #$20			cmp 	#$20 						; $2x is check playing => A
.b969	b0 09		bcs $b974			bcs 	_SNDQueryPlay
.b96b	c9 14		cmp #$14			cmp 	#$14 						; $10-$13 is queue sound
.b96d	b0 1a		bcs $b989			bcs 	_SNDExit
.b96f	20 0e b9	jsr $b90e			jsr 	SNDQueueRequest
.b972	80 15		bra $b989			bra 	_SNDExit
.b974					_SNDQueryPlay:
.b974	29 03		and #$03			and 	#3 							; get channel #
.b976	aa		tax				tax
.b977	bd 8b 07	lda $078b,x			lda 	SNDTimeLeft,x 				; read time left, if zero then silent
.b97a	80 0d		bra $b989			bra 	_SNDExit
.b97c					_SNDInitialise:
.b97c					_SNDSilence:
.b97c	9c 7e 06	stz $067e			stz 	SNDLength 					; empty the queue.
.b97f	a9 03		lda #$03			lda 	#$3 						; silence channel 0-3.
.b981					_SNDSilenceLoop:
.b981	48		pha				pha
.b982	20 3b b9	jsr $b93b			jsr 	SNDSilenceChannel
.b985	68		pla				pla
.b986	3a		dec a				dec 	a
.b987	10 f8		bpl $b981			bpl 	_SNDSilenceLoop
.b989					_SNDExit:
.b989	7a		ply				ply
.b98a	fa		plx				plx
.b98b	60		rts				rts
=32					SNDQueueSize = 32 							; number of queue entries
.067e					SNDLength:
>067e							.fill 	1
.067f					SNDQueue:
>067f							.fill 	SNDQueueSize * 8
.077f					SNDPitchLow:
>077f							.fill 	4
.0783					SNDPitchHigh:
>0783							.fill 	4
.0787					SNDVolume:
>0787							.fill 	4
.078b					SNDTimeLeft:
>078b							.fill 	4
.078f					SNDAdjustLow:
>078f							.fill 	4
.0793					SNDAdjustHigh:
>0793							.fill 	4
.b98c					Export_SNDUpdate:
.b98c					PagedSNDUpdate:
.b98c	ad 8b 07	lda $078b			lda 	SNDTimeLeft+0 				; look at time remaining
.b98f	f0 05		beq $b996			beq 	_SNDUNot0 					; not playing
.b991	a2 00		ldx #$00			ldx 	#0 							; so we know which channel to update
.b993	20 b5 b9	jsr $b9b5			jsr 	SNDUpdateChannel 			; update it.
.b996					_SNDUNot0:
.b996	ad 8c 07	lda $078c			lda 	SNDTimeLeft+1
.b999	f0 05		beq $b9a0			beq 	_SNDUNot1
.b99b	a2 01		ldx #$01			ldx 	#1
.b99d	20 b5 b9	jsr $b9b5			jsr 	SNDUpdateChannel
.b9a0					_SNDUNot1:
.b9a0	ad 8d 07	lda $078d			lda 	SNDTimeLeft+2
.b9a3	f0 05		beq $b9aa			beq 	_SNDUNot2
.b9a5	a2 02		ldx #$02			ldx 	#2
.b9a7	20 b5 b9	jsr $b9b5			jsr 	SNDUpdateChannel
.b9aa					_SNDUNot2:
.b9aa	ad 8e 07	lda $078e			lda 	SNDTimeLeft+3
.b9ad	f0 05		beq $b9b4			beq 	_SNDUNot3
.b9af	a2 03		ldx #$03			ldx 	#3
.b9b1	20 b5 b9	jsr $b9b5			jsr 	SNDUpdateChannel
.b9b4					_SNDUNot3:
.b9b4	60		rts				rts
.b9b5					SNDUpdateChannel:
.b9b5	c9 ff		cmp #$ff			cmp 	#$FF 						; sound $FF play forever until turned off manually
.b9b7	f0 2c		beq $b9e5			beq 	_SNDUCExit
.b9b9	3a		dec a				dec 	a 							; decrement and update timer
.b9ba	9d 8b 07	sta $078b,x			sta 	SNDTimeLeft,x
.b9bd	f0 1d		beq $b9dc			beq 	_SNDUCUpdate 				; if zero, silence channel
.b9bf	bd 8f 07	lda $078f,x			lda 	SNDAdjustLow,x 				; adjust ?
.b9c2	1d 93 07	ora $0793,x			ora 	SNDAdjustHigh,x
.b9c5	f0 1e		beq $b9e5			beq 	_SNDUCExit 					; if zero carry on at current tone.
.b9c7	18		clc				clc 								; add adjust, forcing into a 10 bit range
.b9c8	bd 7f 07	lda $077f,x			lda 	SNDPitchLow,x
.b9cb	7d 8f 07	adc $078f,x			adc 	SNDAdjustLow,x
.b9ce	9d 7f 07	sta $077f,x			sta 	SNDPitchLow,x
.b9d1	bd 83 07	lda $0783,x			lda 	SNDPitchHigh,x
.b9d4	7d 93 07	adc $0793,x			adc 	SNDAdjustHigh,x
.b9d7	29 03		and #$03			and 	#3
.b9d9	9d 83 07	sta $0783,x			sta 	SNDPitchHigh,x
.b9dc					_SNDUCUpdate:
.b9dc	8a		txa				txa 								; which channel.
.b9dd	48		pha				pha
.b9de	20 a1 b8	jsr $b8a1			jsr 	SNDUpdateNote 				; update the current note
.b9e1	68		pla				pla
.b9e2	20 62 b8	jsr $b862			jsr 	SNDCheckChannel 			; more to do ?
.b9e5					_SNDUCExit:
.b9e5	60		rts				rts

;******  Return to file: _basic.asm


;******  End of listing
