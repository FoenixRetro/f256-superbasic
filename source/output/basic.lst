
; 64tass Turbo Assembler Macro V1.58.2974? listing file
; 64tass -D AUTORUN=0 "-D MONITOR_ADDRESS=\$E000" "-D LOCKOUT_ADDRESS=\$F000" "-D BASIC_ADDRESS=\$34000" "-D SOURCE_ADDRESS=\$28000" "-D SPRITE_ADDRESS=\$30000" -q -b -Wall -c -C -D "HARDWARE=0 $'\x9'$'\x9'$'\x9'$'\x9'$'\x9'$'\x9'" -L output/basic.lst -l output/basic.lbl -Wall -o build/basic.rom _basic.asm
; Mon Jan 30 20:57:28 2023

;Offset	;PC	;Hex		;Monitor	;Source

;******  Command line definitions

=0						AUTORUN=0
=$e000						 MONITOR_ADDRESS=$E000
=$f000						 LOCKOUT_ADDRESS=$F000
=$34000						 BASIC_ADDRESS=$34000
=$28000						 SOURCE_ADDRESS=$28000
=$30000						 SPRITE_ADDRESS=$30000
=0						HARDWARE=0

;******  Processing input file: _basic.asm


;******  Processing file: ./common/aa.system/01common.inc

=$30						ZeroPageMandatory = $30
=$50						ZeroPagePreference = $50
=$400						MemoryStorage = $400
=$2000						BasicStart = $2000
=$8000						BasicEnd = $8000
=$8000						CodeStart = $8000
=$1000						VariableSpace = $1000
=$2000						EndVariableSpace = $2000
=8						MathStackSize = 8
=512						BasicStackSize = 512
=3584						BasicStackBase = $1000-BasicStackSize
=80						MaxLineSize = 80

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/02macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/04data.inc

.0030						codePtr:
>0030								.fill 	4
.0034						basicStack:
>0034								.fill 	2
.0036						zTemp0:
>0036								.fill 	2
.0038						zTemp1:
>0038								.fill 	2
.003a						zTemp2:
>003a								.fill 	2
.003c						zsTemp:
>003c								.fill 	2
.003e						zaTemp:
>003e								.fill 	2
=$30						safePtr = codePtr 							; minimise direct tinkering
=$80						NSBIsNegative = $80 						; bit 7 : sign of mantissa (where numeric)
=$20						NSBIsReference = $20 						; bit 5 : is a reference
=$10						NSBIsString = $10 							; bit 4 : set if string (procedures don't go on the stack)
=$18						NSBTypeMask = $18 							; bits 4,3 : 00 int 01 float 10 string 11 procedure
=$03						NSBRefMask = $03 							; bits 0,1 : Bytes of reference, 00 = 4,01 = 1,10=2
=$04						NSBIsArray = $04
=$00						NSTInteger = $00 							; base types for bits 3..4
=$08						NSTFloat = $08
=$10						NSTString = $10
=$18						NSTProcedure = $18
.0050						NSStatus:
>0050								.fill 	MathStackSize
.0058						NSMantissa0:
>0058								.fill 	MathStackSize 				; (this is my integer mantissa system)
.0060						NSMantissa1:
>0060								.fill 	MathStackSize
.0068						NSMantissa2:
>0068								.fill 	MathStackSize
.0070						NSMantissa3:
>0070								.fill 	MathStackSize
.0078						NSExponent:
>0078								.fill 	MathStackSize
.0400						identStart:
>0400								.fill 	1
.0401						identTypeStart:
>0401								.fill 	1
.0402						identTypeEnd:
>0402								.fill 	1
.0403						identHash:
>0403								.fill 	1
.0404						identTypeByte:
>0404								.fill 	1	 						; (see tokenising.pdf)
.0405						encodeState:
>0405								.fill 	1
.0406						digitTemp:
>0406								.fill 	1
.0407						decimalCount:
>0407								.fill 	1
.0408						lowMemPtr:
>0408								.fill 	2
.040a						stringMemory:
>040a								.fill 	2
.040c						stringInitialised:
>040c								.fill 	1
.040d						stringTempPointer:
>040d								.fill 	2
.040f						breakCheck:
>040f								.fill 	1
.0410						decimalPlaces:
>0410								.fill 	1
.0411						dbOffset:
>0411								.fill 	1
.0412						lastParameter:
>0412								.fill 	1
.0413						dataPointer:
>0413								.fill 	5
.0418						inDataStatement:
>0418								.fill 	1
.0419						tbOffset:
>0419								.fill 	1
.041a						AssemblerAddress:
>041a								.fill 	2
.041c						AssemblerControl:
>041c								.fill 	1
.041d						ParamStart:
>041d								.fill 	2
.041f						IsGroup1:
>041f								.fill 	1
.0420						BaseOpcode:
>0420								.fill 	1
.0421						ModeMask:
>0421								.fill 	1
.0422						listIndent:
>0422								.fill 	1
.0423						lcLastCharacter:
>0423								.fill 	1
.0424						isPrintFlag:
>0424								.fill 	1
.0425						currentListColour:
>0425								.fill 	1
.0426						tokenOffset:
>0426								.fill 	1
.0427						tokenLineNumber:
>0427								.fill 	2
.0429						tokenBuffer:
>0429								.fill 	253
.0526						lineBuffer:
>0526								.fill 	253
.0623						numberBuffer:
>0623								.fill 	34
.0645						decimalBuffer:
>0645								.fill 	16

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/ab.system/macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/ab.system/ticktask.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/constants.inc

=$80						AM_ISZP = $80
=$40						AM_ISG1 = $40
=$20						AM_ISG2 = $20
=224						AM_IMMEDIATE = AM_ISZP+AM_ISG1+AM_ISG2+$00
=228						AM_ZEROPAGE = AM_ISZP+AM_ISG1+AM_ISG2+$04
=40						AM_ACC = AM_ISG2+$08
=108						AM_ABS = AM_ISG1+AM_ISG2+$0C
=208						AM_INDY = AM_ISZP+AM_ISG1+$10
=244						AM_ZEROX = AM_ISZP+AM_ISG1+AM_ISG2+$14
=120						AM_ABSY = AM_ISG1+AM_ISG2+$18
=124						AM_ABSX = AM_ISG1+AM_ISG2+$1C
=209						AM_IND = AM_ISZP+AM_ISG1+$11
=$80						AM_ZEROY = AM_ISZP
=$01						AM_INDABS = $01
=$02						AM_INDABSX = $02
=192						AM_INDX = AM_ISZP+AM_ISG1+$00

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/handlers.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.inc

=1						ERRID_BREAK = 1
=2						ERRID_SYNTAX = 2
=3						ERRID_DIVZERO = 3
=4						ERRID_RANGE = 4
=5						ERRID_TYPE = 5
=6						ERRID_MEMORY = 6
=7						ERRID_ARGUMENT = 7
=8						ERRID_STOP = 8
=9						ERRID_STRING = 9
=10						ERRID_ASSERT = 10
=11						ERRID_DATA = 11
=12						ERRID_NOTDONE = 12
=13						ERRID_LINE = 13
=14						ERRID_GOSUB = 14
=15						ERRID_REPEAT = 15
=16						ERRID_WHILE = 16
=17						ERRID_FOR = 17
=18						ERRID_STACK = 18
=19						ERRID_STRUCT = 19
=20						ERRID_PROC = 20
=21						ERRID_REDEFINE = 21
=22						ERRID_ARRAYSIZE = 22
=23						ERRID_ARRAYIDX = 23
=24						ERRID_ARRAYDEC = 24
=25						ERRID_NOTFOUND = 25
=26						ERRID_DRIVEIO = 26
=27						ERRID_VERIFY = 27

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst.inc

=$00						KWD_LESSLESS                         = $00; $00 <<
=$01						KWD_LESSEQUAL                        = $01; $01 <=
=$02						KWD_LESSGREATER                      = $02; $02 <>
=$03						KWD_PLINGPLING3                      = $03; $03 !!3
=$04						KWD_GREATERLESS                      = $04; $04 ><
=$05						KWD_GREATEREQUAL                     = $05; $05 >=
=$06						KWD_GREATERGREATER                   = $06; $06 >>
=$07						KWD_PLINGPLING7                      = $07; $07 !!7
=$08						KWD_PLINGPLING8                      = $08; $08 !!8
=$09						KWD_PLINGPLING9                      = $09; $09 !!9
=$0a						KWD_PLINGPLING10                     = $0a; $0a !!10
=$0b						KWD_PLINGPLING11                     = $0b; $0b !!11
=$0c						KWD_PLINGPLING12                     = $0c; $0c !!12
=$0d						KWD_PLINGPLING13                     = $0d; $0d !!13
=$0e						KWD_PLINGPLING14                     = $0e; $0e !!14
=$0f						KWD_PLINGPLING15                     = $0f; $0f !!15
=$10						KWD_ATCH                             = $10; $10 @
=$11						KWD_PLINGPLING17                     = $11; $11 !!17
=$12						KWD_PLINGPLING18                     = $12; $12 !!18
=$13						KWD_LSQPAREN                         = $13; $13 [
=$14						KWD_BACKSLASH                        = $14; $14 \
=$15						KWD_RSQPAREN                         = $15; $15 ]
=$16						KWD_HAT                              = $16; $16 ^
=$17						KWD_UNDERSCORE                       = $17; $17 _
=$18						KWD_BQUOTE                           = $18; $18 `
=$19						KWD_PLINGPLING25                     = $19; $19 !!25
=$1a						KWD_PLINGPLING26                     = $1a; $1a !!26
=$1b						KWD_LCURLY                           = $1b; $1b {
=$1c						KWD_BAR                              = $1c; $1c |
=$1d						KWD_RCURLY                           = $1d; $1d }
=$1e						KWD_TILDE                            = $1e; $1e ~
=$21						KWD_PLING                            = $21; $21 !
=$22						KWD_DQUOTE                           = $22; $22 "
=$23						KWD_HASH                             = $23; $23 #
=$24						KWD_DOLLAR                           = $24; $24 $
=$25						KWD_PERCENT                          = $25; $25 %
=$26						KWD_AMPERSAND                        = $26; $26 &
=$27						KWD_QUOTE                            = $27; $27 '
=$28						KWD_LPAREN                           = $28; $28 (
=$29						KWD_RPAREN                           = $29; $29 )
=$2a						KWD_STAR                             = $2a; $2a *
=$2b						KWD_PLUS                             = $2b; $2b +
=$2c						KWD_COMMA                            = $2c; $2c ,
=$2d						KWD_MINUS                            = $2d; $2d -
=$2e						KWD_PERIOD                           = $2e; $2e .
=$2f						KWD_SLASH                            = $2f; $2f /
=$30						KWD_0                                = $30; $30 0
=$31						KWD_1                                = $31; $31 1
=$32						KWD_2                                = $32; $32 2
=$33						KWD_3                                = $33; $33 3
=$34						KWD_4                                = $34; $34 4
=$35						KWD_5                                = $35; $35 5
=$36						KWD_6                                = $36; $36 6
=$37						KWD_7                                = $37; $37 7
=$38						KWD_8                                = $38; $38 8
=$39						KWD_9                                = $39; $39 9
=$3a						KWD_COLON                            = $3a; $3a :
=$3b						KWD_SEMICOLON                        = $3b; $3b ;
=$3c						KWD_LESS                             = $3c; $3c <
=$3d						KWD_EQUAL                            = $3d; $3d =
=$3e						KWD_GREATER                          = $3e; $3e >
=$3f						KWD_QMARK                            = $3f; $3f ?
=$83						KWD_ABSLPAREN                        = $83; $83 ABS(
=$84						KWD_ALLOCLPAREN                      = $84; $84 ALLOC(
=$85						KWD_ASCLPAREN                        = $85; $85 ASC(
=$86						KWD_CHRDOLLARLPAREN                  = $86; $86 CHR$(
=$87						KWD_EVENTLPAREN                      = $87; $87 EVENT(
=$88						KWD_FALSE                            = $88; $88 FALSE
=$89						KWD_FRACLPAREN                       = $89; $89 FRAC(
=$8a						KWD_GETDOLLARLPAREN                  = $8a; $8a GET$(
=$8b						KWD_GETLPAREN                        = $8b; $8b GET(
=$8c						KWD_GETDATEDOLLARLPAREN              = $8c; $8c GETDATE$(
=$8d						KWD_GETTIMEDOLLARLPAREN              = $8d; $8d GETTIME$(
=$8e						KWD_HITLPAREN                        = $8e; $8e HIT(
=$8f						KWD_INKEYDOLLARLPAREN                = $8f; $8f INKEY$(
=$90						KWD_INKEYLPAREN                      = $90; $90 INKEY(
=$91						KWD_INTLPAREN                        = $91; $91 INT(
=$92						KWD_ISVALLPAREN                      = $92; $92 ISVAL(
=$93						KWD_ITEMCOUNTLPAREN                  = $93; $93 ITEMCOUNT(
=$94						KWD_ITEMGETDOLLARLPAREN              = $94; $94 ITEMGET$(
=$95						KWD_JOYBLPAREN                       = $95; $95 JOYB(
=$96						KWD_JOYXLPAREN                       = $96; $96 JOYX(
=$97						KWD_JOYYLPAREN                       = $97; $97 JOYY(
=$98						KWD_KEYDOWNLPAREN                    = $98; $98 KEYDOWN(
=$99						KWD_LEFTDOLLARLPAREN                 = $99; $99 LEFT$(
=$9a						KWD_LENLPAREN                        = $9a; $9a LEN(
=$9b						KWD_MAXLPAREN                        = $9b; $9b MAX(
=$9c						KWD_MIDDOLLARLPAREN                  = $9c; $9c MID$(
=$9d						KWD_MINLPAREN                        = $9d; $9d MIN(
=$9e						KWD_NOTLPAREN                        = $9e; $9e NOT(
=$9f						KWD_PEEKLPAREN                       = $9f; $9f PEEK(
=$a0						KWD_PEEKDLPAREN                      = $a0; $a0 PEEKD(
=$a1						KWD_PEEKLLPAREN                      = $a1; $a1 PEEKL(
=$a2						KWD_PEEKWLPAREN                      = $a2; $a2 PEEKW(
=$a3						KWD_PLAYINGLPAREN                    = $a3; $a3 PLAYING(
=$a4						KWD_RANDOMLPAREN                     = $a4; $a4 RANDOM(
=$a5						KWD_RIGHTDOLLARLPAREN                = $a5; $a5 RIGHT$(
=$a6						KWD_RNDLPAREN                        = $a6; $a6 RND(
=$a7						KWD_SGNLPAREN                        = $a7; $a7 SGN(
=$a8						KWD_SPCLPAREN                        = $a8; $a8 SPC(
=$a9						KWD_STRDOLLARLPAREN                  = $a9; $a9 STR$(
=$aa						KWD_TIMERLPAREN                      = $aa; $aa TIMER(
=$ab						KWD_TRUE                             = $ab; $ab TRUE
=$ac						KWD_VALLPAREN                        = $ac; $ac VAL(
=$ad						KWD_FOR                              = $ad; $ad FOR
=$ae						KWD_IF                               = $ae; $ae IF
=$af						KWD_PROC                             = $af; $af PROC
=$b0						KWD_REPEAT                           = $b0; $b0 REPEAT
=$b1						KWD_WHILE                            = $b1; $b1 WHILE
=$b2						KWD_ENDIF                            = $b2; $b2 ENDIF
=$b3						KWD_ENDPROC                          = $b3; $b3 ENDPROC
=$b4						KWD_NEXT                             = $b4; $b4 NEXT
=$b5						KWD_THEN                             = $b5; $b5 THEN
=$b6						KWD_UNTIL                            = $b6; $b6 UNTIL
=$b7						KWD_WEND                             = $b7; $b7 WEND
=$b8						KWD_AT                               = $b8; $b8 AT
=$b9						KWD_BY                               = $b9; $b9 BY
=$ba						KWD_CALL                             = $ba; $ba CALL
=$bb						KWD_CIRCLE                           = $bb; $bb CIRCLE
=$bc						KWD_CLEAR                            = $bc; $bc CLEAR
=$bd						KWD_COLOR                            = $bd; $bd COLOR
=$be						KWD_COLOUR                           = $be; $be COLOUR
=$bf						KWD_DATA                             = $bf; $bf DATA
=$c0						KWD_DIM                              = $c0; $c0 DIM
=$c1						KWD_DOWNTO                           = $c1; $c1 DOWNTO
=$c2						KWD_ELSE                             = $c2; $c2 ELSE
=$c3						KWD_FROM                             = $c3; $c3 FROM
=$c4						KWD_GFX                              = $c4; $c4 GFX
=$c5						KWD_HERE                             = $c5; $c5 HERE
=$c6						KWD_IMAGE                            = $c6; $c6 IMAGE
=$c7						KWD_LET                              = $c7; $c7 LET
=$c8						KWD_LINE                             = $c8; $c8 LINE
=$c9						KWD_LOCAL                            = $c9; $c9 LOCAL
=$ca						KWD_MEMCOPY                          = $ca; $ca MEMCOPY
=$cb						KWD_OFF                              = $cb; $cb OFF
=$cc						KWD_ON                               = $cc; $cc ON
=$cd						KWD_OUTLINE                          = $cd; $cd OUTLINE
=$ce						KWD_PALETTE                          = $ce; $ce PALETTE
=$cf						KWD_PLOT                             = $cf; $cf PLOT
=$d0						KWD_POKE                             = $d0; $d0 POKE
=$d1						KWD_POKED                            = $d1; $d1 POKED
=$d2						KWD_POKEL                            = $d2; $d2 POKEL
=$d3						KWD_POKEW                            = $d3; $d3 POKEW
=$d4						KWD_READ                             = $d4; $d4 READ
=$d5						KWD_RECT                             = $d5; $d5 RECT
=$d6						KWD_REM                              = $d6; $d6 REM
=$d7						KWD_SOLID                            = $d7; $d7 SOLID
=$d8						KWD_SOUND                            = $d8; $d8 SOUND
=$d9						KWD_SPRITE                           = $d9; $d9 SPRITE
=$da						KWD_TEXT                             = $da; $da TEXT
=$db						KWD_TO                               = $db; $db TO

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst0.inc

=$80						KWC_EOL = $80
=$ff						KWC_STRING = $FF
=$fe						KWC_HEXCONST = $FE
=$ad						KWC_FIRST_STRUCTURE = $ad
=$b2						KWC_FIRST_STRUCTURE_DEC = $b2
=$b7						KWC_LAST_STRUCTURE = $b7
=$83						KWC_FIRST_UNARY = $83
=$ac						KWC_LAST_UNARY = $ac

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/memory/memory.flat/access.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/stack.inc

=$e0						STK_GOSUB = $E0
=$d0						STK_FOR = $D0
=$c0						STK_REPEAT = $C0
=$b0						STK_PROC = $B0
=$a0						STK_WHILE = $A0
=$01						STK_LOCALN = $01
=$02						STK_LOCALS = $02

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/00start.asm

.8000						F256Header:
>8000		f2 56						.text	$f2,$56         			; Signature
>8002		04						.byte   4               			; 4 blocks
>8003		04						.byte   4               			; mount at $8000
>8004		40 80						.word   Boot 	      				; Start here
>8006		00 00						.word   0 			               	; version
>8008		00 00						.word   0               			; kernel
>800a		53 75 70 65 72 42 41 53				.text   "SuperBASIC",0 				; name of program.
>8012		49 43 00
.8040		4c 93 80	jmp $8093	Boot:	jmp 	Start

;******  Processing file: ./common/aa.system/../../../modules/_build/_linker.module

=1						PagingEnabled = 1
.8043						EXTPrintCharacter:
.8043		e6 0d		inc $0d			inc 8+5
.8045		20 0b a0	jsr $a00b		jsr	Export_EXTPrintCharacter
.8048		08		php			php
.8049		c6 0d		dec $0d			dec 8+5
.804b		28		plp			plp
.804c		60		rts			rts
.804d						EXTPrintNoControl:
.804d		e6 0d		inc $0d			inc 8+5
.804f		20 00 a0	jsr $a000		jsr	Export_EXTPrintNoControl
.8052		08		php			php
.8053		c6 0d		dec $0d			dec 8+5
.8055		28		plp			plp
.8056		60		rts			rts
.8057						EXTInitialise:
.8057		e6 0d		inc $0d			inc 8+5
.8059		20 da a1	jsr $a1da		jsr	Export_EXTInitialise
.805c		08		php			php
.805d		c6 0d		dec $0d			dec 8+5
.805f		28		plp			plp
.8060		60		rts			rts
.8061						GXGraphicDraw:
.8061		e6 0d		inc $0d			inc 8+5
.8063		20 3b a3	jsr $a33b		jsr	Export_GXGraphicDraw
.8066		08		php			php
.8067		c6 0d		dec $0d			dec 8+5
.8069		28		plp			plp
.806a		60		rts			rts
.806b						SNDCommand:
.806b		e6 0d		inc $0d			inc 8+5
.806d		20 48 b7	jsr $b748		jsr	Export_SNDCommand
.8070		08		php			php
.8071		c6 0d		dec $0d			dec 8+5
.8073		28		plp			plp
.8074		60		rts			rts
.8075						SNDUpdate:
.8075		e6 0d		inc $0d			inc 8+5
.8077		20 7b b7	jsr $b77b		jsr	Export_SNDUpdate
.807a		08		php			php
.807b		c6 0d		dec $0d			dec 8+5
.807d		28		plp			plp
.807e		60		rts			rts
.807f						TKListConvertLine:
.807f		e6 0d		inc $0d			inc 8+5
.8081		20 f9 b0	jsr $b0f9		jsr	Export_TKListConvertLine
.8084		08		php			php
.8085		c6 0d		dec $0d			dec 8+5
.8087		28		plp			plp
.8088		60		rts			rts
.8089						TKTokeniseLine:
.8089		e6 0d		inc $0d			inc 8+5
.808b		20 8d b3	jsr $b38d		jsr	Export_TKTokeniseLine
.808e		08		php			php
.808f		c6 0d		dec $0d			dec 8+5
.8091		28		plp			plp
.8092		60		rts			rts

;******  Return to file: ./common/aa.system/00start.asm

.8093		a2 ff		ldx #$ff	Start:	ldx 	#$FF 						; stack reset
.8095		9a		txs				txs
.8096		20 57 80	jsr $8057			jsr 	EXTInitialise 				; hardware initialise
.8099		a5 00		lda $00				lda 	0  							; turn on editing of MMU LUT
.809b		09 80		ora #$80			ora 	#$80
.809d		85 00		sta $00				sta 	0
.809f		ad 02 20	lda $2002			lda 	$2002 						; if $2002..5 is BT65 then jump to $2000
.80a2		c9 42		cmp #$42			cmp 	#"B"
.80a4		d0 18		bne $80be			bne 	_NoMachineCode
.80a6		ad 03 20	lda $2003			lda 	$2003
.80a9		c9 54		cmp #$54			cmp 	#"T"
.80ab		d0 11		bne $80be			bne 	_NoMachineCode
.80ad		ad 04 20	lda $2004			lda 	$2004
.80b0		c9 36		cmp #$36			cmp 	#"6"
.80b2		d0 0a		bne $80be			bne 	_NoMachineCode
.80b4		ad 05 20	lda $2005			lda 	$2005
.80b7		c9 35		cmp #$35			cmp 	#"5"
.80b9		d0 03		bne $80be			bne 	_NoMachineCode
.80bb		4c 00 20	jmp $2000			jmp 	$2000
.80be						_NoMachineCode:
.80be		a9 00		lda #$00			lda 	#0 							; zero the default drive.
.80c0		20 2b 83	jsr $832b			jsr 	KNLSetDrive
.80c3		a9 00		lda #$00			lda 	#0 							; graphics system initialise.
.80c5		aa		tax				tax
.80c6		a8		tay				tay
.80c7		20 61 80	jsr $8061			jsr 	GXGraphicDraw
.80ca		a9 0f		lda #$0f			lda 	#$0F 						; initialise sound system
.80cc		20 6b 80	jsr $806b			jsr 	SNDCommand
.80cf		a9 8d		lda #$8d			lda 	#128+13 					; Display FPGA information.
.80d1		20 43 80	jsr $8043			jsr 	EXTPrintCharacter
.80d4		a9 09		lda #$09			lda 	#9
.80d6		20 43 80	jsr $8043			jsr 	EXTPrintCharacter
.80d9		20 43 80	jsr $8043			jsr 	EXTPrintCharacter
.80dc		64 01		stz $01				stz 	1
.80de		ad ad d6	lda $d6ad			lda 	$D6AD
.80e1		20 00 85	jsr $8500			jsr 	PrintHex
.80e4		ad ac d6	lda $d6ac			lda 	$D6AC
.80e7		20 00 85	jsr $8500			jsr 	PrintHex
.80ea		ad ab d6	lda $d6ab			lda 	$D6AB
.80ed		20 00 85	jsr $8500			jsr 	PrintHex
.80f0		ad aa d6	lda $d6aa			lda 	$D6AA
.80f3		20 00 85	jsr $8500			jsr 	PrintHex
.80f6		a9 20		lda #$20			lda 	#32
.80f8		20 43 80	jsr $8043			jsr 	EXTPrintCharacter
.80fb		ad a8 d6	lda $d6a8			lda 	$D6A8
.80fe		20 43 80	jsr $8043			jsr 	EXTPrintCharacter
.8101		ad a9 d6	lda $d6a9			lda 	$D6A9
.8104		20 43 80	jsr $8043			jsr 	EXTPrintCharacter
.8107		a2 81		ldx #$81			ldx 	#Prompt >> 8 				; display prompt
.8109		a9 17		lda #$17			lda 	#Prompt & $FF
.810b		20 c8 99	jsr $99c8			jsr 	PrintStringXA
.810e		20 33 93	jsr $9333			jsr 	NewProgram 					; erase current program
.8111		4c 6c 87	jmp $876c			jmp 	WarmStart					; make same size.
.8114		4c 6c 87	jmp $876c			jmp 	WarmStart
>8117		0d 0d				Prompt:	.text 	13,13

;******  Processing file: ./common/aa.system/../generated/timestamp.asm

>8119		09 09 33 30 2f 30 31 2f			.text 9,9,"30/01/23 33"
>8121		32 33 20 33 33

;******  Return to file: ./common/aa.system/00start.asm

>8126		0d 0d 0d 00					.text 	13,13,13,0

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/ab.system/events.asm

.812a						ProcessEvents:
.812a		20 6a 83	jsr $836a			jsr 	KNLSetEventPointer
.812d		20 5b 82	jsr $825b			jsr     GetNextEvent 				; get next event
.8130		b0 27		bcs $8159			bcs 	_PEExitZ 					; nothing left to process.
.8132		ad 8e 07	lda $078e			lda 	KNLEvent.type 				; go back if event not key.pressed.
.8135		c9 08		cmp #$08			cmp 	#kernel.event.key.PRESSED
.8137		d0 f1		bne $812a			bne 	ProcessEvents
.8139		ad 94 07	lda $0794			lda	 	KNLEvent.key.flags 			; is KNLEvent.key.flags = 0 ?
.813c		d0 ec		bne $812a			bne 	ProcessEvents
.813e		ad 93 07	lda $0793			lda 	KNLEvent.key.ascii 			; is it Ctrl+C
.8141		c9 03		cmp #$03			cmp 	#3
.8143		f0 11		beq $8156			beq 	_PEReturnBreak  			; no, keep going.
.8145		da		phx				phx
.8146		ae 5d 06	ldx $065d			ldx 	KeyboardQueueEntries 		; get keyboard queue size into X
.8149		e0 08		cpx #$08			cpx 	#KBDQueueSize 				; if full, then ignore
.814b		f0 06		beq $8153			beq 	_PENoQueue
.814d		9d 55 06	sta $0655,x			sta 	KeyboardQueue,x 			; write into queue
.8150		ee 5d 06	inc $065d			inc 	KeyboardQueueEntries 		; bump count
.8153						_PENoQueue:
.8153		fa		plx				plx
.8154		80 d4		bra $812a			bra 	ProcessEvents
.8156						_PEReturnBreak:
.8156		a9 ff		lda #$ff			lda 	#255 						; return with NZ state
.8158		60		rts				rts
.8159						_PEExitZ:
.8159		a9 00		lda #$00			lda 	#0
.815b		60		rts				rts
.815c						PopKeyboardQueue:
.815c		ad 5d 06	lda $065d			lda 	KeyboardQueueEntries 		; get keyboard queue entries.
.815f		f0 17		beq $8178			beq 	_PKQExit 					; zero, then exit.
.8161		ad 55 06	lda $0655			lda 	KeyboardQueue 				; save head of keyboard queue
.8164		48		pha				pha
.8165		da		phx				phx 								; drop head of queue
.8166		a2 00		ldx #$00			ldx 	#0
.8168						_PKQLoop:
.8168		bd 56 06	lda $0656,x			lda 	KeyboardQueue+1,x 			; shift everything back one.
.816b		9d 55 06	sta $0655,x			sta 	KeyboardQueue,x  			; not efficient but doesn't matter.
.816e		e8		inx				inx
.816f		e0 07		cpx #$07			cpx 	#7
.8171		d0 f5		bne $8168			bne 	_PKQLoop
.8173		fa		plx				plx
.8174		ce 5d 06	dec $065d			dec 	KeyboardQueueEntries 		; one fewer in queue.
.8177		68		pla				pla 								; restore head of queue.
.8178						_PKQExit:
.8178		60		rts				rts
.8179						KNLGetKeyPressed:
.8179		a5 01		lda $01				lda 	1 							; save I/O 0
.817b		48		pha				pha
.817c		64 01		stz $01				stz 	1 							; access I/O Page 0
.817e		38		sec				sec 								; calculate timer - LastTick
.817f		ad 59 d6	lda $d659			lda 	$D659
.8182		cd 5e 06	cmp $065e			cmp 	LastTick
.8185		f0 06		beq $818d			beq 	_NoFireTick 				; if < 3 clocks don't fire.
.8187		8d 5e 06	sta $065e			sta 	LastTick 					; update last timer
.818a		20 4a 82	jsr $824a			jsr 	TickHandler 							; go do the code.
.818d						_NoFireTick:
.818d		68		pla				pla 								; restore I/O 0
.818e		85 01		sta $01				sta 	1
.8190		ad 5d 06	lda $065d			lda 	KeyboardQueueEntries 		; something in the queue
.8193		d0 c7		bne $815c			bne 	PopKeyboardQueue 			; if so, pop and return it
.8195		20 2a 81	jsr $812a			jsr 	ProcessEvents 				; process any outstanding events
.8198		a9 00		lda #$00			lda 	#0
.819a		60		rts				rts
.819b						KNLGetSingleCharacter:
.819b		20 79 81	jsr $8179			jsr 	KNLGetKeyPressed
.819e		c9 00		cmp #$00			cmp 	#0
.81a0		f0 f9		beq $819b			beq 	KNLGetSingleCharacter
.81a2		60		rts				rts
=8						KBDQueueSize = 8
.0655						KeyboardQueue:
>0655								.fill 	KBDQueueSize
.065d						KeyboardQueueEntries:
>065d								.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/ab.system/input.asm

.81a3						EXTInputLine:
.81a3		48		pha				pha
.81a4		da		phx				phx
.81a5		5a		phy				phy
.81a6		a5 01		lda $01				lda 	1 							; save I/O page
.81a8		48		pha				pha
.81a9						_EILLoop:
.81a9		20 9b 81	jsr $819b			jsr 	KNLGetSingleCharacter 		; get one single character
.81ac		c9 0d		cmp #$0d			cmp 	#13 						; scrape line if exit.
.81ae		f0 44		beq $81f4			beq 	_EILExit
.81b0		c9 04		cmp #$04			cmp 	#4 							; Ctrl+D delete at cursor
.81b2		f0 2a		beq $81de			beq 	_EILDelete
.81b4		c9 08		cmp #$08			cmp 	#8 							; Ctrl+H backspace
.81b6		f0 1c		beq $81d4			beq 	_EILBackspace
.81b8		c9 20		cmp #$20			cmp 	#' '						; < space, print it
.81ba		90 12		bcc $81ce			bcc 	_EILPrintLoop
.81bc		c9 7f		cmp #$7f			cmp 	#$7F 						; if -ve print it
.81be		b0 0e		bcs $81ce			bcs 	_EILPrintLoop
.81c0		48		pha				pha 								; save character
.81c1		a9 02		lda #$02			lda 	#2  						; insert a space
.81c3		85 01		sta $01				sta 	1
.81c5		20 38 82	jsr $8238			jsr 	EXTILInsert 				; insert in text screen
.81c8		e6 01		inc $01				inc 	1
.81ca		20 38 82	jsr $8238			jsr 	EXTILInsert 				; insert in colour screen
.81cd		68		pla				pla 								; get character back.
.81ce						_EILPrintLoop:
.81ce		20 43 80	jsr $8043			jsr 	EXTPrintCharacter
.81d1		80 d6		bra $81a9			bra 	_EILLoop
.81d3		60		rts				rts
.81d4						_EILBackspace:
.81d4		ad b5 07	lda $07b5			lda 	EXTColumn					; can we backspace ?
.81d7		f0 d0		beq $81a9			beq 	_EILLoop
.81d9		a9 02		lda #$02			lda 	#2 							; move cursor left
.81db		20 43 80	jsr $8043			jsr 	EXTPrintCharacter
.81de						_EILDelete
.81de		a9 02		lda #$02			lda 	#2 							; text block
.81e0		85 01		sta $01				sta 	1
.81e2		a9 20		lda #$20			lda 	#' ' 						; backspace text.
.81e4		20 23 82	jsr $8223			jsr 	EXTILDelete
.81e7		e6 01		inc $01				inc 	1 							; colour block
.81e9		ac b5 07	ldy $07b5			ldy 	EXTColumn 					; get attribute of last character
.81ec		88		dey				dey
.81ed		b1 40		lda ($40),y			lda 	(EXTAddress),y
.81ef		20 23 82	jsr $8223			jsr 	EXTILDelete 				; backspace attribute
.81f2		80 b5		bra $81a9			bra 	_EILLoop 					; and go round.
.81f4						_EILExit:
.81f4		a9 02		lda #$02			lda 	#2 							; switch to page 2
.81f6		85 01		sta $01				sta 	1
.81f8		a0 00		ldy #$00			ldy 	#0 							; copy current line into buffer.
.81fa						_EILScrapeLine:
.81fa		b1 40		lda ($40),y			lda 	(EXTAddress),y
.81fc		99 26 05	sta $0526,y			sta 	lineBuffer,y
.81ff		c8		iny				iny
.8200		cc b7 07	cpy $07b7			cpy 	EXTScreenWidth
.8203		d0 f5		bne $81fa			bne 	_EILScrapeLine
.8205						_EILTrimSpaces:
.8205		88		dey				dey
.8206		c0 ff		cpy #$ff			cpy 	#$FF 						; back past the start
.8208		f0 07		beq $8211			beq 	_EILEndTrim		 			; zero the input line.
.820a		b9 26 05	lda $0526,y			lda 	lineBuffer,y
.820d		c9 20		cmp #$20			cmp 	#' '
.820f		f0 f4		beq $8205			beq 	_EILTrimSpaces 				; if fail this found non space character
.8211						_EILEndTrim:
.8211		c8		iny				iny 								; trim after non space character.
.8212		a9 00		lda #$00			lda 	#0 							; trim here.
.8214		99 26 05	sta $0526,y			sta 	lineBuffer,y
.8217		a9 0d		lda #$0d			lda 	#13 						; echo the RETURN
.8219		20 43 80	jsr $8043			jsr 	EXTPrintCharacter
.821c		68		pla				pla 								; reset I/O page
.821d		85 01		sta $01				sta 	1
.821f		7a		ply				ply
.8220		fa		plx				plx
.8221		68		pla				pla
.8222		60		rts				rts
.8223						EXTILDelete:
.8223		48		pha				pha 								; save the new character
.8224		ac b5 07	ldy $07b5			ldy 	EXTColumn 					; start copying from here.
.8227						_EXTDLoop:
.8227		c8		iny				iny 								; copy one byte down.
.8228		b1 40		lda ($40),y			lda 	(EXTAddress),y
.822a		88		dey				dey
.822b		91 40		sta ($40),y			sta 	(EXTAddress),y
.822d		c8		iny				iny 								; do till end of line.
.822e		cc b7 07	cpy $07b7			cpy 	EXTScreenWidth
.8231		90 f4		bcc $8227			bcc 	_EXTDLoop
.8233		88		dey				dey 	 							; write in last slot.
.8234		68		pla				pla
.8235		91 40		sta ($40),y			sta 	(EXTAddress),y
.8237		60		rts				rts
.8238						EXTILInsert:
.8238		ac b7 07	ldy $07b7			ldy 	EXTScreenWidth 				; end position
.823b						_EXTILoop:
.823b		88		dey				dey 								; back one
.823c		cc b5 07	cpy $07b5			cpy 	EXTColumn 					; exit if reached insert point.
.823f		f0 08		beq $8249			beq 	_EXTIExit
.8241		88		dey				dey 								; copy one byte up.
.8242		b1 40		lda ($40),y			lda 	(EXTAddress),y
.8244		c8		iny				iny
.8245		91 40		sta ($40),y			sta 	(EXTAddress),y
.8247		80 f2		bra $823b			bra 	_EXTILoop
.8249						_EXTIExit:
.8249		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/ab.system/ticktask.asm

.824a						TickHandler:
.824a		da		phx				phx
.824b		5a		phy				phy 								; need to preserve Y
.824c		20 75 80	jsr $8075			jsr 	SNDUpdate 					; update sound
.824f		7a		ply				ply
.8250		fa		plx				plx
.8251		60		rts				rts
.065e						LastTick:
>065e								.fill 		1

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/ab.system/trackio.asm

.8252						ResetIOTracking:
.8252		a2 2d		ldx #$2d			ldx 	#GNEEnd-GNEBegin-1
.8254						_RIOLoop:
.8254		9e 5f 06	stz $065f,x			stz 	GNEBegin,x
.8257		ca		dex				dex
.8258		10 fa		bpl $8254			bpl 	_RIOLoop
.825a		60		rts				rts
.825b						GetNextEvent:
.825b		20 00 ff	jsr $ff00			jsr 	kernel.NextEvent 			; get event
.825e		08		php				php									; save yes/no flag.
.825f		b0 29		bcs $828a			bcs 	_GNEExit
.8261		48		pha				pha 								; save registers
.8262		da		phx				phx
.8263		5a		phy				phy
.8264		ad 8e 07	lda $078e			lda 	KNLEvent.type	 			; check for PRESSED or RELEASED
.8267		c9 08		cmp #$08			cmp 	#kernel.event.key.PRESSED
.8269		f0 04		beq $826f			beq 	_GNEKeyEvent
.826b		c9 0a		cmp #$0a			cmp 	#kernel.event.key.RELEASED
.826d		d0 08		bne $8277			bne 	_GNECheckMouseEvent
.826f						_GNEKeyEvent:
.826f		20 d9 82	jsr $82d9			jsr 	ProcessKeyboardEvent 		; process keyboard up/down.
.8272		20 f6 82	jsr $82f6			jsr 	UpdateKeyboardJoystick 		; update the keyboard-joystick.
.8275		80 10		bra $8287			bra 	_GNEEventExit
.8277						_GNECheckMouseEvent:
.8277		c9 0c		cmp #$0c			cmp 	#kernel.event.mouse.DELTA 	; check for move events
.8279		d0 05		bne $8280			bne 	_GNENotDelta
.827b		20 8c 82	jsr $828c			jsr 	ProcessMouseDeltaEvent 		; process them.
.827e		80 07		bra $8287			bra 	_GNEEventExit
.8280						_GNENotDelta:
.8280		c9 0e		cmp #$0e			cmp 	#kernel.event.mouse.CLICKS 	; check for click events
.8282		d0 03		bne $8287			bne 	_GNEEventExit
.8284		20 a1 82	jsr $82a1			jsr 	ProcessMouseClickEvent 		; process them.
.8287						_GNEEventExit:
.8287		7a		ply				ply 								; restore registers
.8288		fa		plx				plx
.8289		68		pla				pla
.828a						_GNEExit:
.828a		28		plp				plp
.828b		60		rts				rts
.828c						ProcessMouseDeltaEvent:
.828c		a2 22		ldx #$22			ldx 	#MouseDeltaX-GNEBegin
.828e		ad 91 07	lda $0791			lda 	KNLEvent.mouse.delta.x
.8291		20 b6 82	jsr $82b6			jsr 	PMKAddSubtract
.8294		ad 92 07	lda $0792			lda 	KNLEvent.mouse.delta.y
.8297		20 b6 82	jsr $82b6			jsr 	PMKAddSubtract
.829a		ad 93 07	lda $0793			lda 	KNLEvent.mouse.delta.z
.829d		20 b6 82	jsr $82b6			jsr 	PMKAddSubtract
.82a0		60		rts				rts
.82a1						ProcessMouseClickEvent:
.82a1		a2 28		ldx #$28			ldx 	#MouseCountInner-GNEBegin
.82a3		ad 91 07	lda $0791			lda 	KNLEvent.mouse.clicks.inner
.82a6		20 ba 82	jsr $82ba			jsr 	PMKAdd
.82a9		ad 92 07	lda $0792			lda 	KNLEvent.mouse.clicks.middle
.82ac		20 ba 82	jsr $82ba			jsr 	PMKAdd
.82af		ad 93 07	lda $0793			lda 	KNLEvent.mouse.clicks.outer
.82b2		20 ba 82	jsr $82ba			jsr 	PMKAdd
.82b5		60		rts				rts
.82b6						PMKAddSubtract:
.82b6		c9 00		cmp #$00			cmp 	#0 							; subtracting ?
.82b8		30 0e		bmi $82c8			bmi 	PMKSubtract
.82ba						PMKAdd:
.82ba		18		clc				clc
.82bb		7d 5f 06	adc $065f,x			adc 	GNEBegin,x
.82be		9d 5f 06	sta $065f,x			sta 	GNEBegin,x
.82c1		90 13		bcc $82d6			bcc 	PMKExit
.82c3		fe 60 06	inc $0660,x			inc 	GNEBegin+1,x
.82c6		80 0e		bra $82d6			bra 	PMKExit
.82c8						PMKSubtract:
.82c8		38		sec				sec
.82c9		49 ff		eor #$ff			eor 	#$FF
.82cb		7d 5f 06	adc $065f,x			adc 	GNEBegin,x
.82ce		9d 5f 06	sta $065f,x			sta 	GNEBegin,x
.82d1		b0 03		bcs $82d6			bcs 	PMKExit
.82d3		de 60 06	dec $0660,x			dec 	GNEBegin+1,x
.82d6						PMKExit:
.82d6		e8		inx				inx 								; next slot ?
.82d7		e8		inx				inx
.82d8		60		rts				rts
.82d9						ProcessKeyboardEvent:
.82d9		ad 92 07	lda $0792			lda 	KNLEvent.key.raw 			; raw key code.
.82dc		20 17 83	jsr $8317			jsr 	KeyboardConvertXA  			; convert to index in X, mask in A
.82df		ac 8e 07	ldy $078e			ldy 	KNLEvent.type
.82e2		c0 0a		cpy #$0a			cpy 	#kernel.event.key.RELEASED 	; check if pressed/released
.82e4		f0 07		beq $82ed			beq 	_PKERelease
.82e6		1d 5f 06	ora $065f,x			ora 	KeyStatus,x 				; set bit
.82e9		9d 5f 06	sta $065f,x			sta 	KeyStatus,x
.82ec		60		rts				rts
.82ed						_PKERelease:
.82ed		49 ff		eor #$ff			eor 	#$FF						; clear bit
.82ef		3d 5f 06	and $065f,x			and 	KeyStatus,x
.82f2		9d 5f 06	sta $065f,x			sta 	KeyStatus,x
.82f5		60		rts				rts
.82f6						UpdateKeyboardJoystick:
.82f6		9c 80 06	stz $0680			stz 	KeyJoystick
.82f9		a2 00		ldx #$00			ldx 	#0
.82fb						_UKJLoop:
.82fb		bd 12 83	lda $8312,x			lda 	_UKJKeys,x 					; which key
.82fe		29 1f		and #$1f			and 	#$1F
.8300		a8		tay				tay
.8301		b9 5f 06	lda $065f,y			lda 	KeyStatus,y 				; get status
.8304		29 10		and #$10			and 	#$10 						; letters always bit 4 (actually ASCII of L/C)
.8306		18		clc				clc  								; set C if bit set
.8307		69 ff		adc #$ff			adc 	#$FF
.8309		2e 80 06	rol $0680			rol 	KeyJoystick 				; shift into place
.830c		e8		inx				inx
.830d		e0 05		cpx #$05			cpx 	#5 							; do all 5
.830f		d0 ea		bne $82fb			bne 	_UKJLoop
.8311		60		rts				rts
.8312						_UKJKeys:
>8312		4c 58 5a 4d 4b					.byte	'L','X','Z','M','K'
.8317						KeyboardConvertXA:
.8317		a2 01		ldx #$01			ldx 	#1 							; set the mask temp to %00000001
.8319		8e 7f 06	stx $067f			stx 	KeyMaskTemp
.831c						_KCCALoop:
.831c		18		clc				clc
.831d		69 20		adc #$20			adc 	#$20 						; upper 3 bits are the mask, if causes CS A will be in the range 00-1F
.831f		b0 05		bcs $8326			bcs 	_KCCADone
.8321		0e 7f 06	asl $067f			asl 	KeyMaskTemp 				; shift the mask temp
.8324		80 f6		bra $831c			bra 	_KCCALoop
.8326						_KCCADone:
.8326		aa		tax				tax 								; table entry in X
.8327		ad 7f 06	lda $067f			lda 	KeyMaskTemp 				; mask temp in A.
.832a		60		rts				rts
.065f						GNEBegin:
.065f						KeyStatus:
>065f								.fill 	32
.067f						KeyMaskTemp:
>067f								.fill 	1
.0680						KeyJoystick:
>0680								.fill 	1
.0681						MouseDeltaX:
>0681								.fill 	2
.0683						MouseDeltaY:
>0683								.fill 	2
.0685						MouseDeltaZ:
>0685								.fill 	2
.0687						MouseCountInner:
>0687								.fill 	2
.0689						MouseCountMiddle:
>0689								.fill 	2
.068b						MouseCountOuter:
>068b								.fill 	2
.068d						GNEEnd:

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/ab.system/wrapper.asm

=56						KERR_GENERAL = kernel.event.file.ERROR 		; Event $38
=50						KERR_CLOSED = kernel.event.file.CLOSED 		; Event $32
=40						KERR_NOTFOUND = kernel.event.file.NOT_FOUND ; Event $28
=48						KERR_EOF = kernel.event.file.EOF 			; Event $30
=64						KNLReadBufferLen = 64 								; read buffer size.
.832b						KNLSetDrive:
.832b		8d 8d 07	sta $078d			sta 	KNLDefaultDrive
.832e		60		rts				rts
.832f						KNLOpenFileWrite:
.832f		48		pha				pha
.8330		a9 01		lda #$01			lda 	#kernel.args.file.open.WRITE
.8332		80 03		bra $8337			bra 	KNLOpenStart
.8334						KNLOpenFileRead:
.8334		48		pha				pha
.8335		a9 00		lda #$00			lda     #kernel.args.file.open.READ ; set READ mode.
.8337						KNLOpenStart:
.8337		85 f5		sta $f5				sta     kernel.args.file.open.mode
.8339		68		pla				pla
.833a		20 75 83	jsr $8375			jsr 	KNLSetupFileName
.833d		20 6a 83	jsr $836a			jsr 	KNLSetEventPointer
.8340		ad 8d 07	lda $078d			lda 	KNLDefaultDrive 			; currently drive zero only.
.8343		85 f3		sta $f3				sta 	kernel.args.file.open.drive
.8345		20 5c ff	jsr $ff5c			jsr     kernel.File.Open 			; open the file and exit.
.8348		a9 38		lda #$38			lda     #kernel.event.file.ERROR
.834a		b0 1d		bcs $8369			bcs     _out
.834c						_loop
.834c		20 0c ff	jsr $ff0c			jsr     kernel.Yield    			; event wait
.834f		20 5b 82	jsr $825b			jsr     GetNextEvent
.8352		b0 f8		bcs $834c			bcs     _loop
.8354		ad 8e 07	lda $078e			lda 	KNLEvent.type
.8357		c9 2a		cmp #$2a			cmp     #kernel.event.file.OPENED
.8359		f0 0a		beq $8365			beq 	_success
.835b		c9 28		cmp #$28			cmp     #kernel.event.file.NOT_FOUND
.835d		f0 0a		beq $8369			beq 	_out
.835f		c9 38		cmp #$38			cmp     #kernel.event.file.ERROR
.8361		f0 06		beq $8369			beq 	_out
.8363		80 e7		bra $834c			bra     _loop
.8365						_success
.8365		ad 91 07	lda $0791			lda     KNLEvent.file.stream
.8368		18		clc				clc
.8369						_out
.8369		60		rts				rts
.836a						KNLSetEventPointer:
.836a		48		pha				pha
.836b		a9 8e		lda #$8e			lda     #KNLEvent & $FF 			; tell kernel where to store event data
.836d		85 f0		sta $f0				sta     kernel.args.events+0
.836f		a9 07		lda #$07			lda     #KNLEvent >> 8
.8371		85 f1		sta $f1				sta     kernel.args.events+1
.8373		68		pla				pla
.8374		60		rts				rts
.8375						KNLSetupFileName:
.8375		5a		phy				phy 								; save Y on stack
.8376		85 36		sta $36				sta 	zTemp0 						; save filename position in temp, and in kenrel slot
.8378		86 37		stx $37				stx 	zTemp0+1
.837a		85 fb		sta $fb				sta     kernel.args.file.open.fname+0
.837c		86 fc		stx $fc				stx     kernel.args.file.open.fname+1
.837e		a0 ff		ldy #$ff			ldy 	#$FF 						; get the filename length => Kernel slot
.8380						_KNLGetLength:
.8380		c8		iny				iny
.8381		b1 36		lda ($36),y			lda 	(zTemp0),y
.8383		d0 fb		bne $8380			bne 	_KNLGetLength
.8385		84 fd		sty $fd				sty 	kernel.args.file.open.fname_len
.8387		7a		ply				ply
.8388		60		rts				rts
.8389						KNLReadBlock:
.8389		85 f3		sta $f3				sta     kernel.args.file.read.stream
.838b		86 f4		stx $f4				stx     kernel.args.file.read.buflen
.838d		20 60 ff	jsr $ff60			jsr     kernel.File.Read 			; read request
.8390		a9 38		lda #$38			lda     #kernel.event.file.ERROR    ; Kernel out of events/buffers; shouldn't happen
.8392		b0 2e		bcs $83c2			bcs     _KGNBExitFail               ; report as general error
.8394						_KGRBEventLoop:
.8394		20 0c ff	jsr $ff0c			jsr     kernel.Yield    			; event wait
.8397		20 5b 82	jsr $825b			jsr     GetNextEvent
.839a		b0 f8		bcs $8394			bcs     _KGRBEventLoop
.839c		ad 8e 07	lda $078e			lda 	KNLEvent.type 				; get event
.839f		c9 2c		cmp #$2c			cmp     #kernel.event.file.DATA 	; data, return data
.83a1		f0 0a		beq $83ad			beq     _KNLRBGetNextByte
.83a3		c9 38		cmp #$38			cmp     #kernel.event.file.ERROR  	; errors on file i/o, return as appropriate.
.83a5		f0 1b		beq $83c2			beq 	_KGNBExitFail
.83a7		c9 30		cmp #$30			cmp     #kernel.event.file.EOF
.83a9		f0 17		beq $83c2			beq 	_KGNBExitFail
.83ab		80 e7		bra $8394			bra 	_KGRBEventLoop
.83ad						_KNLRBGetNextByte:
.83ad		a9 8d		lda #$8d			lda     #<KNLReadBuffer 			; Set the target buffer
.83af		85 fb		sta $fb				sta     kernel.args.recv.buf+0
.83b1		a9 06		lda #$06			lda     #>KNLReadBuffer
.83b3		85 fc		sta $fc				sta     kernel.args.recv.buf+1
.83b5		ad 94 07	lda $0794			lda     KNLEvent.file.data.read 	; Set the target length
.83b8		85 fd		sta $fd				sta     kernel.args.recv.buflen
.83ba		20 04 ff	jsr $ff04			jsr     kernel.ReadData		       	; Get the data from the kernel  (Synchronous call, no error)
.83bd		ad 94 07	lda $0794			lda     KNLEvent.file.data.read 	; Return # of bytes read (in A)
.83c0		18		clc				clc
.83c1		60		rts				rts
.83c2						_KGNBExitFail:
.83c2		38		sec				sec
.83c3		60		rts				rts
.83c4						KNLWriteBlock:
.83c4		da		phx				phx
.83c5		5a		phy				phy
.83c6		85 f3		sta $f3				sta     kernel.args.file.write.stream ; save the stream.
.83c8		a5 36		lda $36				lda     zTemp0 						; save the data location.
.83ca		85 fb		sta $fb				sta     kernel.args.file.write.buf+0
.83cc		a5 37		lda $37				lda     zTemp0+1
.83ce		85 fc		sta $fc				sta     kernel.args.file.write.buf+1
.83d0		86 fd		stx $fd				stx     kernel.args.file.write.buflen ; Set the buffer length
.83d2		20 64 ff	jsr $ff64			jsr     kernel.File.Write 			; write it out.
.83d5		a9 38		lda #$38			lda 	#kernel.event.file.ERROR 	; in case it fails.
.83d7		b0 21		bcs $83fa			bcs 	_KWBFailed
.83d9						_KNLWLoop:
.83d9		20 0c ff	jsr $ff0c			jsr     kernel.Yield
.83dc		20 5b 82	jsr $825b			jsr     GetNextEvent
.83df		b0 f8		bcs $83d9			bcs     _KNLWLoop
.83e1		ad 8e 07	lda $078e			lda     KNLEvent.type 				; various errors.
.83e4		c9 32		cmp #$32			cmp     #kernel.event.file.CLOSED
.83e6		f0 12		beq $83fa			beq 	_KWBFailed
.83e8		c9 38		cmp #$38			cmp     #kernel.event.file.ERROR
.83ea		f0 0e		beq $83fa			beq 	_KWBFailed
.83ec		c9 30		cmp #$30			cmp     #kernel.event.file.EOF
.83ee		f0 0a		beq $83fa			beq 	_KWBFailed
.83f0		c9 2e		cmp #$2e			cmp     #kernel.event.file.WROTE 	; wait until block write succeeds
.83f2		d0 e5		bne $83d9			bne 	_KNLWLoop
.83f4		18		clc				clc
.83f5		ad 94 07	lda $0794			lda    KNLEvent.file.wrote.wrote 	; get bytes written.
.83f8		80 01		bra $83fb			bra 	_KWBExit
.83fa						_KWBFailed:
.83fa		38		sec				sec
.83fb						_KWBExit:
.83fb		7a		ply				ply
.83fc		fa		plx				plx
.83fd		60		rts				rts
.83fe						KNLCloseFile:
.83fe		85 f3		sta $f3				sta     kernel.args.file.close.stream
.8400		20 68 ff	jsr $ff68			jsr     kernel.File.Close
.8403		60		rts				rts
.8404						KNLReadController:
.8404		da		phx				phx
.8405		a6 01		ldx $01				ldx 	1 							; save current I/O in X
.8407		64 01		stz $01				stz 	1 							; switch to I/O 0
.8409		ad 00 dc	lda $dc00			lda 	$DC00  						; read VIA register
.840c		49 ff		eor #$ff			eor 	#$FF 						; make active '1'
.840e		0d 80 06	ora $0680			ora 	KeyJoystick 				; use key joystick.
.8411		86 01		stx $01				stx 	1 							; repair old I/O and exit
.8413		fa		plx				plx
.8414		60		rts				rts
.068d						KNLReadBuffer:
>068d								.fill   256
.078d						KNLDefaultDrive:
>078d								.byte 	?
.078e						KNLEvent
>078e						type        .byte   ?   ; Enum above
>078f						buf         .byte   ?   ; page id or zero
>0790						ext         .byte   ?   ; page id or zero
.0791						key
>0791						keyboard    .byte   ?   ; Keyboard ID
>0792						raw         .byte   ?   ; Raw key ID
>0793						ascii       .byte   ?   ; ASCII value
>0794						flags       .byte   ?   ; Flags (META)
=$80						META        = $80       ; Meta key; no associated ASCII value.
.0791						mouse
.0791						delta
>0791						x           .byte   ?
>0792						y           .byte   ?
>0793						z           .byte   ?
>0794						buttons     .byte   ?
.0791						clicks
>0791						inner       .byte   ?
>0792						middle      .byte   ?
>0793						outer       .byte   ?
.0791						joystick
>0791						joy0        .byte   ?
>0792						joy1        .byte   ?
.0791						udp
>0791						token       .byte   ?   ; TODO: break out into fields
.0791						file
>0791						stream      .byte   ?
>0792						cookie      .byte   ?
.0793						data
>0793						requested   .byte   ?   ; Requested number of bytes to read
>0794						read        .byte   ?   ; Number of bytes actually read
.0793						wrote
>0793						requested   .byte   ?   ; Requested number of bytes to read
>0794						wrote       .byte   ?   ; Number of bytes actually read
.0791						directory
>0791						stream      .byte   ?
>0792						cookie      .byte   ?
.0793						volume
>0793						len         .byte   ?   ; Length of volname (in buf)
>0794						flags       .byte   ?   ; block size, text encoding
.0793						file
>0793						len         .byte   ?
>0794						flags       .byte   ?   ; block scale, text encoding, approx size
.0793						free
>0793						flags       .byte   ?   ; block scale, text encoding, approx size

;******  Return to file: _basic.asm


;******  Processing file: ./common/api/api.asm

>ff00						NextEvent   .fill   4   ; Copy the next event into user-space.
>ff04						ReadData    .fill   4   ; Copy primary bulk event data into user-space
>ff08						ReadExt     .fill   4   ; Copy secondary bolk event data into user-space
>ff0c						Yield       .fill   4   ; Give unused time to the kernel.
>ff10						Putch       .fill   4   ; deprecated
>ff14						Basic       .fill   4   ; deprecated
>ff18						RunNamed    .fill   4   ; Chain to resident program by name.
>ff1c						            .fill   4   ; reserved
>ff20						List        .fill   4   ; Returns a bit-set of available block-accessible devices.
>ff24						GetName     .fill   4   ; Gets the hardware level name of the given block device or media.
>ff28						GetSize     .fill   4   ; Get the number of raw sectors (48 bits) for the given device
>ff2c						Read        .fill   4   ; Read a raw sector (48 bit LBA)
>ff30						Write       .fill   4   ; Write a raw sector (48 bit LBA)
>ff34						Format      .fill   4   ; Perform a low-level format if the media support it.
>ff38						Export      .fill   4   ; Update the FileSystem table with the partition table (if present).
>ff3c						List        .fill   4   ; Returns a bit-set of available logical devices.
>ff40						GetSize     .fill   4   ; Get the size of the partition or logical device in sectors.
>ff44						MkFS        .fill   4   ; Creates a new file-system on the logical device.
>ff48						CheckFS     .fill   4   ; Checks the file-system for errors and corrects them.
>ff4c						Mount       .fill   4   ; Mark the file-system as available for File and Directory operations.
>ff50						Unmount     .fill   4   ; Mark the file-system as unavailable for File and Directory operations.
>ff54						ReadBlock   .fill   4   ; Read a partition-local raw sector on an unmounted device.
>ff58						WriteBlock  .fill   4   ; Write a partition-local raw sector on an unmounted device.
>ff5c						Open        .fill   4   ; Open the given file for read, create, or append.
>ff60						Read        .fill   4   ; Request bytes from a file opened for reading.
>ff64						Write       .fill   4   ; Write bytes to a file opened for create or append.
>ff68						Close       .fill   4   ; Close an open file.
>ff6c						Rename      .fill   4   ; Rename a closed file.
>ff70						Delete      .fill   4   ; Delete a closed file.
>ff74						Open        .fill   4   ; Open a directory for reading.
>ff78						Read        .fill   4   ; Read a directory entry; may also return VOLUME and FREE events.
>ff7c						Close       .fill   4   ; Close a directory once finished reading.
>ff80						            .fill   4   ; call gate
>ff84						Reset       .fill   4   ; Re-init the display
>ff88						GetSize     .fill   4   ; Returns rows/cols in kernel args.
>ff8c						DrawRow     .fill   4   ; Draw text/color buffers left-to-right
>ff90						DrawColumn  .fill   4   ; Draw text/color buffers top-to-bottom
>ff94						GetIP       .fill   4   ; Get the local IP address.
>ff98						SetIP       .fill   4   ; Set the local IP address.
>ff9c						GetDNS      .fill   4   ; Get the configured DNS IP address.
>ffa0						SetDNS      .fill   4   ; Set the configured DNS IP address.
>ffa4						GetTime     .fill   4
>ffa8						SetTime     .fill   4
>ffac						GetSysInfo  .fill   4
>ffb0						SetBPS      .fill   4   ; Set the serial BPS (should match the SLIP router's speed).
>ffb4						InitUDP     .fill   4
>ffb8						SendUDP     .fill   4
>ffbc						RecvUDP     .fill   4
>ffc0						InitTCP     .fill   4
>ffc4						SendTCP     .fill   4
>ffc8						RecvTCP     .fill   4
>ffcc						SendICMP    .fill   4
>ffd0						RecvICMP    .fill   4
.00f0						args
.00f0						events
>00f0						dest        .word       ?   ; GetNextEvent copies event data here
>00f2						pending     .byte       ?   ; Negative count of pending events
.00f3						end
.00f3						recv
=$fb						buf         = args.buf
=$fd						buflen      = args.buflen
.00f3						fs
.00f3						format
>00f3						drive       .byte       ?
>00f4						cookie      .byte       ?
=$fb						label       = args.buf
=$fd						label_len   = args.buflen
.00f3						mkfs
>00f3						drive       .byte       ?
>00f4						cookie      .byte       ?
=$fb						label       = args.buf
=$fd						label_len   = args.buflen
.00f3						file
.00f3						open
>00f3						drive       .byte       ?
>00f4						cookie      .byte       ?
=$fb						fname       = args.buf
=$fd						fname_len   = args.buflen
>00f5						mode        .byte       ?
=0						READ        = 0
=1						WRITE       = 1
=2						END         = 2
.00f3						read
>00f3						stream      .byte       ?
>00f4						buflen      .byte       ?
.00f3						write
>00f3						stream      .byte       ?
=$fb						buf         = args.buf
=$fd						buflen      = args.buflen
.00f3						close
>00f3						stream      .byte       ?
.00f3						rename
>00f3						drive       .byte       ?
>00f4						cookie      .byte       ?
=$fb						old         = args.buf
=$fd						old_len     = args.buflen
=$f8						new         = args.ext
=$fa						new_len     = args.extlen
.00f3						delete
>00f3						drive       .byte       ?
>00f4						cookie      .byte       ?
=$fb						fname       = args.buf
=$fd						fname_len   = args.buflen
>00f5						mode        .byte       ?
=0						READ        = 0
=1						WRITE       = 1
=2						END         = 2
.00f3						directory
.00f3						open
>00f3						drive       .byte       ?
>00f4						cookie      .byte       ?
=$fb						path        = args.buf
=$fd						path_len    = args.buflen
.00f3						read
>00f3						stream      .byte       ?
>00f4						buflen      .byte       ?
.00f3						close
>00f3						stream      .byte       ?
.00f3						display
>00f3						x           .byte       ?   ; coordinate or size
>00f4						y           .byte       ?   ; coordinate or size
=$fb						text        = args.buf      ; text
=$f8						color       = args.ext      ; color
=$fb						buf         = args.buf      ; deprecated
=$f8						buf2        = args.ext      ; deprecated
=$fd						buflen      = args.buflen
.00f3						net
=$fb						socket      = args.buf
>00f3						src_port    .word       ?
>00f5						dest_port   .word       ?
>00f7						dest_ip     .fill       4
>00f3						accepted    .byte       ?
=$f8						buf         = args.ext
=$fa						buflen      = args.extlen
=$f8						ext         = $f8
=$fa						extlen      = $fa
=$fb						buf         = $fb
=$fd						buflen      = $fd
=$fe						ptr         = $fe
.0000						args_t
.0000						events
>0000						dest        .word       ?   ; GetNextEvent copies event data here
>0002						pending     .byte       ?   ; Negative count of pending events
.0003						end
.0003						recv
=$fb						buf         = args.buf
=$fd						buflen      = args.buflen
.0003						fs
.0003						format
>0003						drive       .byte       ?
>0004						cookie      .byte       ?
=$fb						label       = args.buf
=$fd						label_len   = args.buflen
.0003						mkfs
>0003						drive       .byte       ?
>0004						cookie      .byte       ?
=$fb						label       = args.buf
=$fd						label_len   = args.buflen
.0003						file
.0003						open
>0003						drive       .byte       ?
>0004						cookie      .byte       ?
=$fb						fname       = args.buf
=$fd						fname_len   = args.buflen
>0005						mode        .byte       ?
=0						READ        = 0
=1						WRITE       = 1
=2						END         = 2
.0003						read
>0003						stream      .byte       ?
>0004						buflen      .byte       ?
.0003						write
>0003						stream      .byte       ?
=$fb						buf         = args.buf
=$fd						buflen      = args.buflen
.0003						close
>0003						stream      .byte       ?
.0003						rename
>0003						drive       .byte       ?
>0004						cookie      .byte       ?
=$fb						old         = args.buf
=$fd						old_len     = args.buflen
=$f8						new         = args.ext
=$fa						new_len     = args.extlen
.0003						delete
>0003						drive       .byte       ?
>0004						cookie      .byte       ?
=$fb						fname       = args.buf
=$fd						fname_len   = args.buflen
>0005						mode        .byte       ?
=0						READ        = 0
=1						WRITE       = 1
=2						END         = 2
.0003						directory
.0003						open
>0003						drive       .byte       ?
>0004						cookie      .byte       ?
=$fb						path        = args.buf
=$fd						path_len    = args.buflen
.0003						read
>0003						stream      .byte       ?
>0004						buflen      .byte       ?
.0003						close
>0003						stream      .byte       ?
.0003						display
>0003						x           .byte       ?   ; coordinate or size
>0004						y           .byte       ?   ; coordinate or size
=$fb						text        = args.buf      ; text
=$f8						color       = args.ext      ; color
=$fb						buf         = args.buf      ; deprecated
=$f8						buf2        = args.ext      ; deprecated
=$fd						buflen      = args.buflen
.0003						net
=$fb						socket      = args.buf
>0003						src_port    .word       ?
>0005						dest_port   .word       ?
>0007						dest_ip     .fill       4
>0003						accepted    .byte       ?
=$f8						buf         = args.ext
=$fa						buflen      = args.extlen
=$f8						ext         = $f8
=$fa						extlen      = $fa
=$fb						buf         = $fb
=$fd						buflen      = $fd
=$fe						ptr         = $fe
.0000						event_t
>0000						dest        .word       ?   ; GetNextEvent copies event data here
>0002						pending     .byte       ?   ; Negative count of pending events
.0003						end
.0000						recv_t
=$fb						buf         = args.buf
=$fd						buflen      = args.buflen
.0000						fs_t
.0000						format
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						label       = args.buf
=$fd						label_len   = args.buflen
.0000						mkfs
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						label       = args.buf
=$fd						label_len   = args.buflen
.0000						fs_mkfs_t
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						label       = args.buf
=$fd						label_len   = args.buflen
.0000						file_t
.0000						open
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						fname       = args.buf
=$fd						fname_len   = args.buflen
>0002						mode        .byte       ?
=0						READ        = 0
=1						WRITE       = 1
=2						END         = 2
.0000						read
>0000						stream      .byte       ?
>0001						buflen      .byte       ?
.0000						write
>0000						stream      .byte       ?
=$fb						buf         = args.buf
=$fd						buflen      = args.buflen
.0000						close
>0000						stream      .byte       ?
.0000						rename
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						old         = args.buf
=$fd						old_len     = args.buflen
=$f8						new         = args.ext
=$fa						new_len     = args.extlen
.0000						delete
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						fname       = args.buf
=$fd						fname_len   = args.buflen
>0002						mode        .byte       ?
=0						READ        = 0
=1						WRITE       = 1
=2						END         = 2
.0000						fs_open_t
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						fname       = args.buf
=$fd						fname_len   = args.buflen
>0002						mode        .byte       ?
=0						READ        = 0
=1						WRITE       = 1
=2						END         = 2
.0000						fs_read_t
>0000						stream      .byte       ?
>0001						buflen      .byte       ?
.0000						fs_write_t
>0000						stream      .byte       ?
=$fb						buf         = args.buf
=$fd						buflen      = args.buflen
.0000						fs_close_t
>0000						stream      .byte       ?
.0000						fs_rename_t
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						old         = args.buf
=$fd						old_len     = args.buflen
=$f8						new         = args.ext
=$fa						new_len     = args.extlen
.0000						fs_delete_t
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						fnane       = args.buf
=$fd						fname_len   = args.buflen
.0000						dir_t
.0000						open
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						path        = args.buf
=$fd						path_len    = args.buflen
.0000						read
>0000						stream      .byte       ?
>0001						buflen      .byte       ?
.0000						close
>0000						stream      .byte       ?
.0000						dir_open_t
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						path        = args.buf
=$fd						path_len    = args.buflen
.0000						dir_read_t
>0000						stream      .byte       ?
>0001						buflen      .byte       ?
.0000						dir_close_t
>0000						stream      .byte       ?
.0000						display_t
>0000						x           .byte       ?   ; coordinate or size
>0001						y           .byte       ?   ; coordinate or size
=$fb						text        = args.buf      ; text
=$f8						color       = args.ext      ; color
=$fb						buf         = args.buf      ; deprecated
=$f8						buf2        = args.ext      ; deprecated
=$fd						buflen      = args.buflen
.0000						net_t
=$fb						socket      = args.buf
>0000						src_port    .word       ?
>0002						dest_port   .word       ?
>0004						dest_ip     .fill       4
>0000						accepted    .byte       ?
=$f8						buf         = args.ext
=$fa						buflen      = args.extlen
>0000						            .word   ?   ; Reserved
>0002						            .word   ?   ; Deprecated
>0004						JOYSTICK    .word   ?   ; Game Controller changes.
>0006						DEVICE      .word   ?   ; Device added/removed.
>0008						PRESSED     .word   ?   ; Key pressed
>000a						RELEASED    .word   ?   ; Key released.
>000c						DELTA       .word   ?   ; Regular mouse move and button state
>000e						CLICKS      .word   ?   ; Click counts
>0010						NAME        .word   ?
>0012						SIZE        .word   ?
>0014						DATA        .word   ?   ; The read request has succeeded.
>0016						WROTE       .word   ?   ; The write request has completed.
>0018						FORMATTED   .word   ?   ; The low-level format has completed.
>001a						ERROR       .word   ?
>001c						SIZE        .word   ?
>001e						CREATED     .word   ?
>0020						CHECKED     .word   ?
>0022						DATA        .word   ?   ; The read request has succeeded.
>0024						WROTE       .word   ?   ; The write request has completed.
>0026						ERROR       .word   ?
>0028						NOT_FOUND   .word   ?   ; The file file was not found.
>002a						OPENED      .word   ?   ; The file was successfully opened.
>002c						DATA        .word   ?   ; The read request has succeeded.
>002e						WROTE       .word   ?   ; The write request has completed.
>0030						EOF         .word   ?   ; All file data has been read.
>0032						CLOSED      .word   ?   ; The close request has completed.
>0034						RENAMED     .word   ?   ; The rename request has completed.
>0036						DELETED     .word   ?   ; The delete request has completed.
>0038						ERROR       .word   ?   ; An error occured; close the file if opened.
>003a						OPENED      .word   ?   ; The directory open request succeeded.
>003c						VOLUME      .word   ?   ; A volume record was found.
>003e						FILE        .word   ?   ; A file record was found.
>0040						FREE        .word   ?   ; A file-system free-space record was found.
>0042						EOF         .word   ?   ; All data has been read.
>0044						CLOSED      .word   ?   ; The directory file has been closed.
>0046						ERROR       .word   ?   ; An error occured; user should close.
>0048						TCP         .word   ?
>004a						UDP         .word   ?
.0000						event_t
>0000						type        .byte   ?   ; Enum above
>0001						buf         .byte   ?   ; page id or zero
>0002						ext         .byte   ?   ; page id or zero
.0003						key
>0003						keyboard    .byte   ?   ; Keyboard ID
>0004						raw         .byte   ?   ; Raw key ID
>0005						ascii       .byte   ?   ; ASCII value
>0006						flags       .byte   ?   ; Flags (META)
=$80						META        = $80       ; Meta key; no associated ASCII value.
.0003						mouse
.0003						delta
>0003						x           .byte   ?
>0004						y           .byte   ?
>0005						z           .byte   ?
>0006						buttons     .byte   ?
.0003						clicks
>0003						inner       .byte   ?
>0004						middle      .byte   ?
>0005						outer       .byte   ?
.0003						joystick
>0003						joy0        .byte   ?
>0004						joy1        .byte   ?
.0003						udp
>0003						token       .byte   ?   ; TODO: break out into fields
.0003						file
>0003						stream      .byte   ?
>0004						cookie      .byte   ?
.0005						data
>0005						requested   .byte   ?   ; Requested number of bytes to read
>0006						read        .byte   ?   ; Number of bytes actually read
.0005						wrote
>0005						requested   .byte   ?   ; Requested number of bytes to read
>0006						wrote       .byte   ?   ; Number of bytes actually read
.0003						directory
>0003						stream      .byte   ?
>0004						cookie      .byte   ?
.0005						volume
>0005						len         .byte   ?   ; Length of volname (in buf)
>0006						flags       .byte   ?   ; block size, text encoding
.0005						file
>0005						len         .byte   ?
>0006						flags       .byte   ?   ; block scale, text encoding, approx size
.0005						free
>0005						flags       .byte   ?   ; block scale, text encoding, approx size
.0000						key_t
>0000						keyboard    .byte   ?   ; Keyboard ID
>0001						raw         .byte   ?   ; Raw key ID
>0002						ascii       .byte   ?   ; ASCII value
>0003						flags       .byte   ?   ; Flags (META)
=$80						META        = $80       ; Meta key; no associated ASCII value.
.0000						mouse_t
.0000						delta
>0000						x           .byte   ?
>0001						y           .byte   ?
>0002						z           .byte   ?
>0003						buttons     .byte   ?
.0000						clicks
>0000						inner       .byte   ?
>0001						middle      .byte   ?
>0002						outer       .byte   ?
.0000						m_delta_t
>0000						x           .byte   ?
>0001						y           .byte   ?
>0002						z           .byte   ?
>0003						buttons     .byte   ?
.0000						m_clicks_t
>0000						inner       .byte   ?
>0001						middle      .byte   ?
>0002						outer       .byte   ?
.0000						joystick_t
>0000						joy0        .byte   ?
>0001						joy1        .byte   ?
.0000						file_t
>0000						stream      .byte   ?
>0001						cookie      .byte   ?
.0002						data
>0002						requested   .byte   ?   ; Requested number of bytes to read
>0003						read        .byte   ?   ; Number of bytes actually read
.0002						wrote
>0002						requested   .byte   ?   ; Requested number of bytes to read
>0003						wrote       .byte   ?   ; Number of bytes actually read
.0000						fs_data_t
>0000						requested   .byte   ?   ; Requested number of bytes to read
>0001						read        .byte   ?   ; Number of bytes actually read
.0000						fs_wrote_t
>0000						requested   .byte   ?   ; Requested number of bytes to read
>0001						wrote       .byte   ?   ; Number of bytes actually read
.0000						dir_t
>0000						stream      .byte   ?
>0001						cookie      .byte   ?
.0002						volume
>0002						len         .byte   ?   ; Length of volname (in buf)
>0003						flags       .byte   ?   ; block size, text encoding
.0002						file
>0002						len         .byte   ?
>0003						flags       .byte   ?   ; block scale, text encoding, approx size
.0002						free
>0002						flags       .byte   ?   ; block scale, text encoding, approx size
.0000						dir_vol_t
>0000						len         .byte   ?   ; Length of volname (in buf)
>0001						flags       .byte   ?   ; block size, text encoding
.0000						dir_file_t
>0000						len         .byte   ?
>0001						flags       .byte   ?   ; block scale, text encoding, approx size
.0000						dir_free_t
>0000						flags       .byte   ?   ; block scale, text encoding, approx size
.0000						dir_ext_t
>0000						free        .fill   6   ; blocks used/free
.0000						udp_t
>0000						token       .byte   ?   ; TODO: break out into fields

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/assembler.asm

.8415						AssembleGroup1:
.8415		a9 ff		lda #$ff			lda 	#$FF 						; flag for group 1 / mask.
.8417		8d 21 04	sta $0421			sta 	ModeMask 					; initialise the mode mask - all for all
.841a		80 02		bra $841e			bra 	AsmGroup12
.841c						AssembleGroup2:
.841c		a9 00		lda #$00			lda 	#$00 						; flag for group 2
.841e						AsmGroup12:
.841e		8d 1f 04	sta $041f			sta 	IsGroup1 					; save the 'group 1' flag
.8421		68		pla				pla 								; pop the return address to access the information following.
.8422		fa		plx				plx
.8423		20 aa 84	jsr $84aa			jsr 	AccessParameters 			; get opcode and save as base
.8426		8d 20 04	sta $0420			sta 	BaseOpcode
.8429		ad 1f 04	lda $041f			lda 	IsGroup1 					; skip if group 1 as we don't have a complex mask.
.842c		d0 08		bne $8436			bne 	_AG12HaveMask
.842e		a9 02		lda #$02			lda 	#2 							; if group 2 the second parameter is the mask
.8430		20 b2 84	jsr $84b2			jsr 	GetParameter		 		; e.g. which modes are supported for this operand
.8433		8d 21 04	sta $0421			sta 	ModeMask
.8436						_AG12HaveMask:
.8436		20 e6 85	jsr $85e6			jsr 	TypeAndCalculateOperand 	; get zero page type
.8439		da		phx				phx 								; save found address mode
.843a		20 16 85	jsr $8516			jsr 	AssembleModeX
.843d		fa		plx				plx  								; restore address mode
.843e		b0 0b		bcs $844b			bcs 	_AG12Exit
.8440		20 4c 84	jsr $844c			jsr 	PromoteToAbsolute  			; promote ZP to ABS and try that
.8443		20 16 85	jsr $8516			jsr 	AssembleModeX
.8446		b0 03		bcs $844b			bcs 	_AG12Exit
.8448		4c 65 ab	jmp $ab65			jmp 	SyntaxError 				; can't do either, so must be wrong mode/operand.
.844b						_AG12Exit:
.844b		60		rts				rts
.844c						PromoteToAbsolute:
.844c		a9 6c		lda #$6c			lda 	#AM_ABS 					; lda xx
.844e		e0 e4		cpx #$e4			cpx 	#AM_ZEROPAGE
.8450		f0 19		beq $846b			beq 	_PTADo
.8452		a9 7c		lda #$7c			lda 	#AM_ABSX 					; lda xx,X
.8454		e0 f4		cpx #$f4			cpx 	#AM_ZEROX
.8456		f0 13		beq $846b			beq 	_PTADo
.8458		a9 78		lda #$78			lda 	#AM_ABSY 					; lda xx,Y
.845a		e0 80		cpx #$80			cpx 	#AM_ZEROY
.845c		f0 0d		beq $846b			beq 	_PTADo
.845e		a9 01		lda #$01			lda 	#AM_INDABS 					; lda (xx) (jump)
.8460		e0 d1		cpx #$d1			cpx 	#AM_IND
.8462		f0 07		beq $846b			beq 	_PTADo
.8464		a9 02		lda #$02			lda 	#AM_INDABSX 				; lda (xx,x) (jump)
.8466		e0 c0		cpx #$c0			cpx 	#AM_INDX
.8468		f0 01		beq $846b			beq 	_PTADo
.846a		60		rts				rts
.846b						_PTADo:
.846b		aa		tax				tax
.846c		60		rts				rts
.846d						AssembleGroup3:
.846d		68		pla				pla 								; get parameters, which is just the opcode.
.846e		fa		plx				plx
.846f		20 aa 84	jsr $84aa			jsr 	AccessParameters 			; get and output opcode
.8472		20 c2 84	jsr $84c2			jsr 	AssemblerWriteByte
.8475		20 4a 86	jsr $864a			jsr 	CalculateOperand 			; get a 16 bit operand
.8478		a5 58		lda $58				lda 	NSMantissa0 				; calculate the offset
.847a		38		sec				sec
.847b		ed 1a 04	sbc $041a			sbc 	AssemblerAddress
.847e		48		pha				pha 								; LSB in A
.847f		a5 60		lda $60				lda 	NSMantissa1
.8481		ed 1b 04	sbc $041b			sbc 	AssemblerAddress+1
.8484		aa		tax				tax 								; MSB in X
.8485		68		pla				pla
.8486		18		clc				clc 								; $80 to easy check $80-$7F, plus 1 for offset error
.8487		69 7f		adc #$7f			adc 	#$7F
.8489		90 01		bcc $848c			bcc 	_AG3NoCarry
.848b		e8		inx				inx
.848c						_AG3NoCarry:
.848c		38		sec				sec 								; fix back and write out anyways.
.848d		e9 80		sbc #$80			sbc 	#$80
.848f		20 c2 84	jsr $84c2			jsr 	AssemblerWriteByte
.8492		e0 00		cpx #$00			cpx 	#0 							; was it in range
.8494		f0 0a		beq $84a0			beq 	_AG3Exit
.8496		ad 1c 04	lda $041c			lda 	AssemblerControl 			; are we allowing bad values ?
.8499		29 01		and #$01			and 	#1
.849b		f0 03		beq $84a0			beq 	_AG3Exit
.849d		4c 6a ab	jmp $ab6a			jmp 	RangeError 					; no, branch is out of range
.84a0						_AG3Exit:
.84a0		60		rts				rts
.84a1						AssembleGroup4:
.84a1		68		pla				pla 								; pop address
.84a2		fa		plx				plx
.84a3		20 aa 84	jsr $84aa			jsr 	AccessParameters 			; access and get first
.84a6		20 c2 84	jsr $84c2			jsr 	AssemblerWriteByte 			; output it.
.84a9		60		rts				rts
.84aa						AccessParameters:
.84aa		8d 1d 04	sta $041d			sta 	ParamStart
.84ad		8e 1e 04	stx $041e			stx 	ParamStart+1
.84b0		a9 01		lda #$01			lda 	#1
.84b2						GetParameter:
.84b2		5a		phy				phy
.84b3		a8		tay				tay
.84b4		ad 1d 04	lda $041d			lda 	ParamStart
.84b7		85 36		sta $36				sta 	zTemp0
.84b9		ad 1e 04	lda $041e			lda 	ParamStart+1
.84bc		85 37		sta $37				sta 	zTemp0+1
.84be		b1 36		lda ($36),y			lda 	(zTemp0),y
.84c0		7a		ply				ply
.84c1		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/aswrite.asm

.84c2						AssemblerWriteByte:
.84c2		48		pha			pha
.84c3		ad 1c 04	lda $041c		lda 	AssemblerControl 				; check printing bytes ?
.84c6		29 02		and #$02		and 	#2
.84c8		f0 1b		beq $84e5		beq 	_AWBNoPrint
.84ca		ad 1b 04	lda $041b		lda		AssemblerAddress+1 				; print address
.84cd		20 00 85	jsr $8500		jsr 	PrintHex
.84d0		ad 1a 04	lda $041a		lda		AssemblerAddress
.84d3		20 00 85	jsr $8500		jsr 	PrintHex
.84d6		a9 20		lda #$20		lda 	#' '
.84d8		20 43 80	jsr $8043		jsr 	EXTPrintCharacter
.84db		68		pla			pla 									; print byte
.84dc		48		pha			pha
.84dd		20 00 85	jsr $8500		jsr 	PrintHex
.84e0		a9 0d		lda #$0d		lda 	#13
.84e2		20 43 80	jsr $8043		jsr 	EXTPrintCharacter
.84e5						_AWBNoPrint:
.84e5		ad 1a 04	lda $041a		lda		AssemblerAddress				; copy address to zTemp0
.84e8		85 36		sta $36			sta 	zTemp0
.84ea		ad 1b 04	lda $041b		lda		AssemblerAddress+1
.84ed		f0 0e		beq $84fd		beq 	_AWBRange
.84ef		85 37		sta $37			sta 	zTemp0+1
.84f1		68		pla			pla 									; write byte out
.84f2		92 36		sta ($36)		sta 	(zTemp0)
.84f4		ee 1a 04	inc $041a		inc 	AssemblerAddress 				; bump address
.84f7		d0 03		bne $84fc		bne 	_AWBNoCarry
.84f9		ee 1b 04	inc $041b		inc 	AssemblerAddress+1
.84fc						_AWBNoCarry:
.84fc		60		rts			rts
.84fd						_AWBRange:
.84fd		4c 6a ab	jmp $ab6a		jmp 	RangeError
.8500						PrintHex:
.8500		48		pha				pha
.8501		4a		lsr a				lsr 	a
.8502		4a		lsr a				lsr 	a
.8503		4a		lsr a				lsr 	a
.8504		4a		lsr a				lsr 	a
.8505		20 09 85	jsr $8509			jsr 	_PrintNibble
.8508		68		pla				pla
.8509						_PrintNibble:
.8509		29 0f		and #$0f			and 	#15
.850b		c9 0a		cmp #$0a			cmp 	#10
.850d		90 02		bcc $8511			bcc 	_NoShift
.850f		69 06		adc #$06			adc 	#6
.8511						_NoShift:
.8511		69 30		adc #$30			adc 	#48
.8513		4c 43 80	jmp $8043			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/instruction.asm

.8516						AssembleModeX:
.8516		5a		phy				phy
.8517		ad 1f 04	lda $041f			lda 	IsGroup1
.851a		f0 17		beq $8533			beq 	_AMXGroup2
.851c		8a		txa				txa 							; is it in group # 1
.851d		29 40		and #$40			and 	#AM_ISG1
.851f		f0 4d		beq $856e			beq 	_AMXFail 				; no, give up.
.8521		8a		txa				txa 							; get back.
.8522		29 1f		and #$1f			and 	#$1F 					; this is now the offset.
.8524		e0 e0		cpx #$e0			cpx 	#AM_IMMEDIATE 			; if not immediate, we can continue.
.8526		d0 22		bne $854a			bne 	_AMXHaveInfo
.8528		ad 20 04	lda $0420			lda 	BaseOpcode 				; cannot store immediate.
.852b		c9 81		cmp #$81			cmp 	#$81
.852d		f0 3f		beq $856e			beq 	_AMXFail
.852f		a9 08		lda #$08			lda 	#8 						; if immediate we use offset 8.
.8531		80 17		bra $854a			bra 	_AMXHaveInfo 			; odd design decision there.
.8533						_AMXGroup2:
.8533		8a		txa				txa 							; is it in group 2 ?
.8534		29 20		and #$20			and 	#AM_ISG2
.8536		f0 36		beq $856e			beq 	_AMXFail 				; no, give up.
.8538		8a		txa				txa 							; get the offset into Y
.8539		29 1f		and #$1f			and 	#$1F
.853b		4a		lsr a				lsr 	a 						; make it 0-7.
.853c		4a		lsr a				lsr  	a
.853d		a8		tay				tay
.853e		ad 21 04	lda $0421			lda 	ModeMask 				; shift the modemask left so you can check it against the requested offset
.8541						_AMXCheckOkay:
.8541		0a		asl a				asl 	a 						; shift modemask left enough times to check legitimate.
.8542		88		dey				dey
.8543		10 fc		bpl $8541			bpl 	_AMXCheckOkay
.8545		90 27		bcc $856e			bcc 	_AMXFail 				; not allowed.
.8547		8a		txa				txa  							; get mask back
.8548		29 1f		and #$1f			and 	#$1F
.854a						_AMXHaveInfo:
.854a		e0 00		cpx #$00			cpx 	#$00 					; does it *require* an 8 bit operand
.854c		10 04		bpl $8552			bpl 	_AMXAnySize 			; checking bit 7, the zero page opcode flag.
.854e		a4 60		ldy $60				ldy 	NSMantissa1 			; fail if it is outside range, e.g. the MSB is set.
.8550		d0 1c		bne $856e			bne 	_AMXFail
.8552						_AMXAnySize:
.8552		18		clc				clc 							; add offset to the base opcode
.8553		6d 20 04	adc $0420			adc 	BaseOpcode
.8556						_AMXOutputCode:
.8556		20 c2 84	jsr $84c2			jsr 	AssemblerWriteByte 		; write the opcode out.
.8559		e0 28		cpx #$28			cpx 	#AM_ACC 				; A mode (e.g. ASL)
.855b		f0 0e		beq $856b			beq 	_AMXExit
.855d		a5 58		lda $58				lda 	NSMantissa0 			; write LSB operand
.855f		20 c2 84	jsr $84c2			jsr 	AssemblerWriteByte
.8562		e0 00		cpx #$00			cpx 	#$00 					; zeropage ?
.8564		30 05		bmi $856b			bmi 	_AMXExit
.8566		a5 60		lda $60				lda 	NSMantissa1 			; write MSB operand
.8568		20 c2 84	jsr $84c2			jsr 	AssemblerWriteByte
.856b						_AMXExit:
.856b		7a		ply				ply
.856c		38		sec				sec
.856d		60		rts				rts
.856e						_AMXFail:
.856e		a0 00		ldy #$00			ldy 	#0
.8570						_AMXCheckOddities:
.8570		8a		txa				txa
.8571		d9 98 85	cmp $8598,y			cmp 	ExtraOpcode+2,y 		; match address mode
.8574		d0 15		bne $858b			bne 	_AMXCONext
.8576		b9 96 85	lda $8596,y			lda 	ExtraOpcode+0,y 		; do the base opcodes match
.8579		cd 20 04	cmp $0420			cmp 	BaseOpcode
.857c		d0 0d		bne $858b			bne 	_AMXCONext
.857e		e0 00		cpx #$00			cpx 	#$00 					; requires zero page ?
.8580		10 04		bpl $8586			bpl 	_AMXCONotZero
.8582		a5 60		lda $60				lda 	NSMantissa1
.8584		d0 05		bne $858b			bne 	_AMXCONext
.8586						_AMXCONotZero:
.8586		b9 97 85	lda $8597,y			lda 	ExtraOpcode+1,y 		; get new opcode
.8589		80 cb		bra $8556			bra 	_AMXOutputCode 			; and assemble it
.858b						_AMXCONext:
.858b		c8		iny				iny
.858c		c8		iny				iny
.858d		c8		iny				iny
.858e		b9 96 85	lda $8596,y			lda 	ExtraOpcode+0,y 		; end of table
.8591		d0 dd		bne $8570			bne 	_AMXCheckOddities
.8593						_AMXCOFail:
.8593		7a		ply				ply
.8594		18		clc				clc
.8595		60		rts				rts
.8596						ExtraOpcode:
>8596		40 6c 01					.byte $40,$6c,AM_INDABS 	; jump
>8599		40 7c 02					.byte $40,$7C,AM_INDABSX 	; jump
>859c		a2 be 78					.byte $a2,$BE,AM_ABSY 		; ldx
>859f		a2 b6 80					.byte $a2,$B6,AM_ZEROY 		; ldx
>85a2		82 96 80					.byte $82,$96,AM_ZEROY 		; stx
>85a5		e2 1a 28					.byte $e2,$1a,AM_ACC 		; inc
>85a8		c2 3a 28					.byte $c2,$3a,AM_ACC 		; dec
>85ab		20 89 e0					.byte $20,$89,AM_IMMEDIATE 	; bit
>85ae		60 9c 6c					.byte $60,$9c,AM_ABS 		; stz
>85b1		60 9e 7c					.byte $60,$9e,AM_ABSX 		; stz
>85b4		00						.byte $00

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/label.asm

.85b5						LabelHere:
.85b5		c8		iny				iny 								; skip .
.85b6		a2 00		ldx #$00			ldx 	#0 							; get a term
.85b8		20 bd a2	jsr $a2bd			jsr 	EvaluateTerm
.85bb		a5 50		lda $50				lda 	NSStatus 					; needs to be an integer reference.
.85bd		c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.85bf		d0 22		bne $85e3			bne 	_ALType 					; otherwise typing error
.85c1		b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy reference address to zTemp0
.85c3		85 36		sta $36				sta 	zTemp0 						; (e.g. where we store the address)
.85c5		b5 60		lda $60,x			lda 	NSMantissa1,x
.85c7		85 37		sta $37				sta 	zTemp0+1
.85c9		5a		phy				phy 								; copy address in (64k)
.85ca		a0 01		ldy #$01			ldy 	#1
.85cc		ad 1a 04	lda $041a			lda	 	AssemblerAddress
.85cf		92 36		sta ($36)			sta 	(zTemp0)
.85d1		ad 1b 04	lda $041b			lda	 	AssemblerAddress+1
.85d4		91 36		sta ($36),y			sta 	(zTemp0),y
.85d6		c8		iny				iny
.85d7		a9 00		lda #$00			lda 	#0 							; zero the rest.
.85d9		91 36		sta ($36),y			sta 	(zTemp0),y
.85db		c8		iny				iny
.85dc		91 36		sta ($36),y			sta 	(zTemp0),y
.85de		c8		iny				iny
.85df		91 36		sta ($36),y			sta 	(zTemp0),y
.85e1		7a		ply				ply
.85e2		60		rts				rts
.85e3						_ALType:
.85e3		4c 6f ab	jmp $ab6f			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/operands.asm

.85e6						TypeAndCalculateOperand:
.85e6		b1 30		lda ($30),y			lda 	(codePtr),y
.85e8		a2 28		ldx #$28			ldx 	#AM_ACC 					; ACC if : or EOL
.85ea		c9 3a		cmp #$3a			cmp 	#KWD_COLON
.85ec		f0 5b		beq $8649			beq 	_TACOExit
.85ee		c9 80		cmp #$80			cmp 	#KWC_EOL
.85f0		f0 57		beq $8649			beq 	_TACOExit
.85f2		c8		iny				iny
.85f3		a2 e0		ldx #$e0			ldx 	#AM_IMMEDIATE
.85f5		c9 23		cmp #$23			cmp 	#KWD_HASH 					; if hash, then immediate - constant.
.85f7		f0 51		beq $864a			beq 	CalculateOperand
.85f9		c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; if ( then check for indirection
.85fb		f0 1f		beq $861c			beq 	_TACOIndirect
.85fd		88		dey				dey 								; undo get of first character
.85fe		20 4a 86	jsr $864a			jsr 	CalculateOperand 			; get operand
.8601		b1 30		lda ($30),y			lda 	(codePtr),y
.8603		a2 e4		ldx #$e4			ldx 	#AM_ZEROPAGE 				; if not, try zero page (then absolute)
.8605		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8607		d0 40		bne $8649			bne 	_TACOExit
.8609		c8		iny				iny
.860a		20 54 86	jsr $8654			jsr 	TACOCheckXY 				; extract X,Y or 0 (neither) from the variable.
.860d		a2 f4		ldx #$f4			ldx 	#AM_ZEROX 					; check for X
.860f		c9 58		cmp #$58			cmp 	#'X'
.8611		f0 36		beq $8649			beq 	_TACOExit
.8613		a2 80		ldx #$80			ldx 	#AM_ZEROY 					; check for Y
.8615		c9 59		cmp #$59			cmp 	#'Y'
.8617		f0 30		beq $8649			beq 	_TACOExit
.8619						_TACOSyntax:
.8619		4c 65 ab	jmp $ab65			jmp 	SyntaxError
.861c						_TACOIndirect:
.861c		20 4a 86	jsr $864a			jsr 	CalculateOperand 			; get the operand
.861f		b1 30		lda ($30),y			lda 	(codePtr),y
.8621		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if , then it must be ,X)
.8623		f0 17		beq $863c			beq 	_TACOIndX
.8625		20 50 99	jsr $9950			jsr 	CheckRightBracket  			; otherwise must be ) or ),Y
.8628		b1 30		lda ($30),y			lda 	(codePtr),y
.862a		a2 d1		ldx #$d1			ldx 	#AM_IND
.862c		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not comma then exit with (xx)
.862e		d0 19		bne $8649			bne 	_TACOExit
.8630		c8		iny				iny
.8631		20 54 86	jsr $8654			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.8634		c9 59		cmp #$59			cmp 	#'Y' 						; check Y
.8636		d0 e1		bne $8619			bne 	_TACOSyntax
.8638		a2 d0		ldx #$d0			ldx 	#AM_INDY
.863a		80 0d		bra $8649			bra 	_TACOExit
.863c						_TACOIndX:
.863c		c8		iny				iny
.863d		20 54 86	jsr $8654			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.8640		c9 58		cmp #$58			cmp 	#'X' 						; check X
.8642		d0 d5		bne $8619			bne 	_TACOSyntax
.8644		20 50 99	jsr $9950			jsr 	CheckRightBracket			; check )
.8647		a2 c0		ldx #$c0			ldx 	#AM_INDX
.8649						_TACOExit:
.8649		60		rts				rts
.864a						CalculateOperand:
.864a		48		pha				pha
.864b		da		phx				phx
.864c		a2 00		ldx #$00			ldx 	#0 							; get 16 bit integer in Slot 0
.864e		20 49 a8	jsr $a849			jsr 	Evaluate16BitInteger
.8651		fa		plx				plx
.8652		68		pla				pla
.8653		60		rts				rts
.8654						TACOCheckXY:
.8654		b1 30		lda ($30),y			lda 	(codePtr),y
.8656		29 c0		and #$c0			and 	#$C0 						; check it is an identifier reference.
.8658		c9 40		cmp #$40			cmp 	#$40
.865a		d0 21		bne $867d			bne 	_TCXYFail
.865c		b1 30		lda ($30),y			lda 	(codePtr),y
.865e		18		clc				clc
.865f		69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8661		85 37		sta $37				sta 	zTemp0+1
.8663		c8		iny				iny
.8664		b1 30		lda ($30),y			lda 	(codePtr),y
.8666		c8		iny				iny
.8667		85 36		sta $36				sta 	zTemp0
.8669		5a		phy				phy 								; save position
.866a		a0 02		ldy #$02			ldy 	#2 							; type is integer ?
.866c		b1 36		lda ($36),y			lda 	(zTemp0),y
.866e		d0 0c		bne $867c			bne 	_TCXYPopFail
.8670		a0 08		ldy #$08			ldy 	#8 							; get first character, should have bit 7 set as also last.
.8672		b1 36		lda ($36),y			lda 	(zTemp0),y
.8674		c9 d8		cmp #$d8			cmp 	#'X'+$80 					; should be X or Y
.8676		f0 08		beq $8680			beq 	_TCXYFound
.8678		c9 d9		cmp #$d9			cmp 	#'Y'+$80
.867a		f0 04		beq $8680			beq 	_TCXYFound
.867c						_TCXYPopFail:
.867c		7a		ply				ply
.867d						_TCXYFail:
.867d		a9 00		lda #$00			lda 	#0
.867f		60		rts				rts
.8680						_TCXYFound:
.8680		7a		ply				ply 								; restore position
.8681		29 7f		and #$7f			and 	#$7F 						; throw bit 7
.8683		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/backload.asm

.8684						BackloadProgram:
.8684		20 33 93	jsr $9333			jsr 	NewProgram 					; does the actual NEW.
.8687		a2 86		ldx #$86			ldx 	#_BLLoad >> 8
.8689		a9 e4		lda #$e4			lda 	#_BLLoad & $FF
.868b		20 c8 99	jsr $99c8			jsr 	PrintStringXA
.868e		a9 14		lda #$14			lda 	#SOURCE_ADDRESS >> 13 		; start page
.8690		8d 95 07	sta $0795			sta 	BackLoadPage
.8693		a9 00		lda #$00			lda 	#(($6000) & $FF)
.8695		8d 96 07	sta $0796			sta 	0+BackLoadPointer
.8698		a9 60		lda #$60			lda 	#(($6000) >> 8)
.869a		8d 97 07	sta $0797			sta 	1+BackLoadPointer
.869d		9c 98 07	stz $0798			stz 	BackLoadLast 				; reset backload last.
.86a0		9c 99 07	stz $0799			stz 	BackLoadLast+1
.86a3		a9 ff		lda #$ff			lda 	#$FF
.86a5		8d fa ff	sta $fffa			sta 	$FFFA
.86a8						_BPLoop:
.86a8		a2 ff		ldx #$ff			ldx 	#$FF
.86aa		20 19 87	jsr $8719			jsr 	BLReadByte 					; read a byte
.86ad		c9 00		cmp #$00			cmp 	#0
.86af		f0 2c		beq $86dd			beq 	_BPExit 					; if 0 exit
.86b1		30 2a		bmi $86dd			bmi 	_BPExit 					; if -ve exit
.86b3						_BPCopy:
.86b3		e8		inx				inx  								; copy byte into the lineBuffer
.86b4		9d 26 05	sta $0526,x			sta 	lineBuffer,x
.86b7		9e 27 05	stz $0527,x			stz 	lineBuffer+1,x
.86ba		20 19 87	jsr $8719			jsr 	BLReadByte 					; read next byte
.86bd		30 0a		bmi $86c9			bmi 	_BPEndLine 					; -ve = EOL
.86bf		c9 09		cmp #$09			cmp 	#9 							; handle TAB, make it space.
.86c1		d0 02		bne $86c5			bne 	_BPNotTab
.86c3		a9 20		lda #$20			lda 	#' '
.86c5						_BPNotTab:
.86c5		c9 20		cmp #$20			cmp 	#' ' 						; < ' ' = EOL
.86c7		b0 ea		bcs $86b3			bcs 	_BPCopy 					; until a control character, should be 13 received.
.86c9						_BPEndLine:
.86c9		20 89 80	jsr $8089			jsr 	TKTokeniseLine 				; tokenise the line.
.86cc		ad 27 04	lda $0427			lda 	tokenLineNumber 			; line number = 0
.86cf		0d 28 04	ora $0428			ora 	tokenLineNumber+1
.86d2		f0 d4		beq $86a8			beq 	_BPLoop 					; not legal code, blank line or maybe a comment.
.86d4		20 f9 86	jsr $86f9			jsr 	BLCheckLast 				; check last backload okay.
.86d7		38		sec				sec 								; append not insert
.86d8		20 59 ad	jsr $ad59			jsr 	MemoryInsertLine 			; append to current program
.86db		80 cb		bra $86a8			bra 	_BPLoop
.86dd						_BPExit:
.86dd		9c fa ff	stz $fffa			stz 	$FFFA
.86e0		20 f8 97	jsr $97f8			jsr 	ClearSystem 				; clear variables etc.
.86e3		60		rts				rts
.86e4						_BLLoad:
>86e4		4c 6f 61 64 69 6e 67 20				.text 	"Loading from Memory",13,0
>86ec		66 72 6f 6d 20 4d 65 6d 6f 72 79 0d 00
.86f9						BLCheckLast:
.86f9		ad 98 07	lda $0798			lda 	BackLoadLast 				; check last < current
.86fc		cd 27 04	cmp $0427			cmp 	tokenLineNumber
.86ff		ad 99 07	lda $0799			lda 	BackLoadLast+1
.8702		ed 28 04	sbc $0428			sbc 	tokenLineNumber+1
.8705		b0 0d		bcs $8714			bcs 	_BLCheckFail
.8707		ad 27 04	lda $0427			lda 	tokenLineNumber 			; update
.870a		8d 98 07	sta $0798			sta 	BackLoadLast
.870d		ad 28 04	lda $0428			lda 	tokenLineNumber+1
.8710		8d 99 07	sta $0799			sta 	BackLoadLast+1
.8713		60		rts				rts
.8714						_BLCheckFail:
.8714		a9 02		lda #$02		lda	#2
.8716		4c 69 99	jmp $9969		jmp	ErrorHandler
.8719						BLReadByte:
.8719		da		phx				phx
.871a		a6 0b		ldx $0b				ldx 	8+3 						; save current mapping for $6000 in X
.871c		ad 95 07	lda $0795			lda 	BackLoadPage	 			; set current page
.871f		85 0b		sta $0b				sta 	8+3
.8721		ad 96 07	lda $0796			lda 	BackLoadPointer 			; copy pointer to zTemp0
.8724		85 36		sta $36				sta 	zTemp0
.8726		ad 97 07	lda $0797			lda 	BackLoadPointer+1
.8729		85 37		sta $37				sta 	zTemp0+1
.872b		b2 36		lda ($36)			lda 	(zTemp0) 					; read next byte
.872d		ee 96 07	inc $0796			inc 	BackLoadPointer 			; bump pointer
.8730		d0 0f		bne $8741			bne 	_BLNoCarry
.8732		ee 97 07	inc $0797			inc 	BackLoadPointer+1
.8735		10 0a		bpl $8741			bpl 	_BLNoCarry 					; need a new page
.8737		48		pha				pha
.8738		a9 60		lda #$60			lda 	#$60 						; reset pointer
.873a		8d 97 07	sta $0797			sta 	BackLoadPointer+1
.873d		ee 95 07	inc $0795			inc 	BackLoadPage 				; next page from source.
.8740		68		pla				pla
.8741						_BLNoCarry:
.8741		86 0b		stx $0b				stx 	8+3 						; restore mapping, then X.
.8743		fa		plx				plx
.8744		c9 00		cmp #$00			cmp 	#0
.8746		60		rts				rts
.0795						BackLoadPage:
>0795								.fill  	1
.0796						BackLoadPointer:
>0796								.fill 	2
.0798						BackLoadLast:
>0798								.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/editor.asm

.8747						EditProgramCode:
.8747		ad 27 04	lda $0427			lda 	tokenLineNumber 			; try to find the line.
.874a		ae 28 04	ldx $0428			ldx 	tokenLineNumber+1
.874d		20 fd ad	jsr $adfd			jsr 	MemorySearch
.8750		90 05		bcc $8757			bcc 	_EPCNoDelete 				; reached the end : don't delete
.8752		d0 03		bne $8757			bne 	_EPCNoDelete 				; found slot but didn't match : no delete
.8754		20 22 ad	jsr $ad22			jsr 	MemoryDeleteLine 			; delete the line
.8757						_EPCNoDelete:
.8757		ad 29 04	lda $0429			lda 	tokenBuffer 				; buffer empty - we just want to delete a line.
.875a		c9 80		cmp #$80			cmp 	#KWC_EOL
.875c		f0 0d		beq $876b			beq 	_EPCNoInsert
.875e		ad 27 04	lda $0427			lda 	tokenLineNumber 			; find the line - it cannot exist as we've just deleted it.
.8761		ae 28 04	ldx $0428			ldx 	tokenLineNumber+1 			; so this can't fail, it returns some point in the code.
.8764		20 fd ad	jsr $adfd			jsr 	MemorySearch
.8767		18		clc				clc 								; insert at this point.
.8768		20 59 ad	jsr $ad59			jsr 	MemoryInsertLine 			; insert the line
.876b						_EPCNoInsert:
.876b		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/warmstart.asm

.876c						WarmStart:
.876c		a2 ff		ldx #$ff			ldx 	#$FF
.876e		9a		txs				txs
.876f		a9 89		lda #$89			lda 	#CLICommandLine+$80 		; set console colour whatever the current colour is.
.8771		20 43 80	jsr $8043			jsr 	EXTPrintCharacter
.8774		20 52 82	jsr $8252			jsr 	ResetIOTracking 			; reset the I/O tracking.
.8777		20 a3 81	jsr $81a3			jsr 	EXTInputLine 				; get line to lineBuffer
.877a		20 89 80	jsr $8089			jsr 	TKTokeniseLine 				; tokenise the line
.877d		ad 27 04	lda $0427			lda 	tokenLineNumber 			; line number <> 0
.8780		0d 28 04	ora $0428			ora 	tokenLineNumber+1
.8783		d0 17		bne $879c			bne 	_WSEditCode 				; if so,edit code.
.8785		9c 26 04	stz $0426			stz 	tokenOffset 				; zero the "offset", meaning it only runs one line.
.8788		a9 26		lda #$26			lda 	#((tokenOffset) & $FF)
.878a		85 30		sta $30				sta 	codePtr
.878c		a9 04		lda #$04			lda 	#((tokenOffset) >> 8)
.878e		85 31		sta $31				sta 	codePtr+1
.8790		ad 29 04	lda $0429			lda 	tokenBuffer 				; nothing to run
.8793		c9 80		cmp #$80			cmp 	#KWC_EOL
.8795		f0 d5		beq $876c			beq 	WarmStart
.8797		20 d0 94	jsr $94d0			jsr 	RUNCodePointerLine 			; execute that line.
.879a		80 d0		bra $876c			bra 	WarmStart
.879c						_WSEditCode:
.879c		20 47 87	jsr $8747			jsr 	EditProgramCode 			; edit the program code
.879f		20 f8 97	jsr $97f8			jsr 	ClearSystem 				; clear all variables etc.
.87a2		80 c8		bra $876c			bra 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assemble.asm

.87a4						AssembleCommand:
.87a4		a2 00		ldx #$00			ldx 	#0
.87a6		20 49 a8	jsr $a849			jsr 	Evaluate16BitInteger 		; start address
.87a9		a5 58		lda $58				lda 	NSMantissa0
.87ab		8d 1a 04	sta $041a			sta 	AssemblerAddress
.87ae		a5 60		lda $60				lda 	NSMantissa1
.87b0		8d 1b 04	sta $041b			sta 	AssemblerAddress+1
.87b3		20 58 99	jsr $9958			jsr 	CheckComma
.87b6		20 64 a8	jsr $a864			jsr 	Evaluate8BitInteger 		; options 0-3
.87b9		a5 58		lda $58				lda 	NSMantissa0
.87bb		8d 1c 04	sta $041c			sta 	AssemblerControl
.87be		60		rts				rts
.87bf		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assert.asm

.87c0						AssertCommand:
.87c0		a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.87c2		20 36 a8	jsr $a836			jsr 	EvaluateInteger 			; the assert test
.87c5		20 eb a8	jsr $a8eb			jsr 	NSMIsZero 					; exit if result is non zero.
.87c8		d0 05		bne $87cf			bne 	_ACExit
.87ca		a9 0a		lda #$0a		lda	#10
.87cc		4c 69 99	jmp $9969		jmp	ErrorHandler
.87cf						_ACExit:
.87cf		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/call.asm

.87d0						CallCommand:
.87d0		a2 00		ldx #$00			ldx 	#0 							; get the routine address to level 0
.87d2		20 49 a8	jsr $a849			jsr 	Evaluate16BitInteger
.87d5						_CCClear
.87d5		e8		inx				inx  								; clear 1,2 and 3 (for A X Y)
.87d6		20 c9 a8	jsr $a8c9			jsr 	NSMSetZero 					; these are optional sequentially.
.87d9		e0 04		cpx #$04			cpx 	#4
.87db		d0 f8		bne $87d5			bne 	_CCClear
.87dd		a2 00		ldx #$00			ldx 	#0 							; and keep trying while there are more values.
.87df						_CCCParam:
.87df		b1 30		lda ($30),y			lda 	(codePtr),y
.87e1		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.87e3		d0 09		bne $87ee			bne 	_CCCRun6502
.87e5		c8		iny				iny 								; skip comma
.87e6		e8		inx				inx	 								; next level
.87e7		20 64 a8	jsr $a864			jsr 	Evaluate8BitInteger 		; get A/X/Y
.87ea		e0 03		cpx #$03			cpx 	#3
.87ec		90 f1		bcc $87df			bcc 	_CCCParam 					; done all 3 ?
.87ee						_CCCRun6502:
.87ee		5a		phy				phy 								; save position
.87ef		a5 60		lda $60				lda 	NSMantissa1 				; put address in zTemp0
.87f1		85 37		sta $37				sta 	zTemp0+1
.87f3		a5 58		lda $58				lda 	NSMantissa0
.87f5		85 36		sta $36				sta 	zTemp0
.87f7		a5 59		lda $59				lda 	NSMantissa0+1 				; get registers into A X Y
.87f9		a6 5a		ldx $5a				ldx 	NSMantissa0+2
.87fb		a4 5b		ldy $5b				ldy 	NSMantissa0+3
.87fd		20 02 88	jsr $8802			jsr 	_CCCZTemp0 					; call zTemp0
.8800		7a		ply				ply 								; restore position and exit
.8801		60		rts				rts
.8802						_CCCZTemp0:
.8802		6c 36 00	jmp ($0036)			jmp 	(zTemp0)

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/commands/crossdev.asm

.8805						XLoadCommand:
.8805		20 33 93	jsr $9333			jsr 	NewProgram
.8808		20 84 86	jsr $8684			jsr 	BackloadProgram
.880b		4c 6c 87	jmp $876c			jmp 	WarmStart
.880e						XGoCommand:
.880e		20 33 93	jsr $9333			jsr 	NewProgram
.8811		20 84 86	jsr $8684			jsr 	BackloadProgram
.8814		4c be 94	jmp $94be			jmp 	RunCurrentProgram

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/data.asm

.8817						Command_Data:
.8817		a9 3a		lda #$3a			lda 	#KWD_COLON 					; advance to colon/EOL, e.g. ignore anything till then.
.8819		a2 80		ldx #$80			ldx 	#KWC_EOL
.881b		20 ab 98	jsr $98ab			jsr 	ScanForward
.881e		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dim.asm

.881f						DimCommand:
.881f		b1 30		lda ($30),y			lda 	(codePtr),y
.8821		29 c0		and #$c0			and 	#$C0
.8823		c9 40		cmp #$40			cmp 	#$40
.8825		d0 7a		bne $88a1			bne 	_DCSyntax 				; n o, error.
.8827		b1 30		lda ($30),y			lda 	(codePtr),y
.8829		18		clc				clc
.882a		69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.882c		85 3f		sta $3f				sta 	zaTemp+1
.882e		c8		iny				iny
.882f		b1 30		lda ($30),y			lda 	(codePtr),y
.8831		c8		iny				iny
.8832		85 3e		sta $3e				sta 	zaTemp
.8834		5a		phy				phy
.8835		a0 02		ldy #$02			ldy 	#2 						; read type byte
.8837		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8839		29 18		and #$18			and 	#NSBTypeMask 			; check it's not a procedure
.883b		c9 18		cmp #$18			cmp 	#NSTProcedure
.883d		f0 62		beq $88a1			beq 	_DCSyntax
.883f		b1 3e		lda ($3e),y			lda 	(zaTemp),y 				; check it's an array
.8841		29 04		and #$04			and 	#NSBIsArray
.8843		f0 64		beq $88a9			beq 	_DCType
.8845		a0 04		ldy #$04			ldy 	#4 						; check not already defined
.8847		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8849		d0 59		bne $88a4			bne 	_DCRedefine
.884b		7a		ply				ply
.884c		20 ac 88	jsr $88ac			jsr 	_DCGetSize 				; get array size, check it.
.884f		5a		phy				phy
.8850		a0 05		ldy #$05			ldy 	#5 						; store in first array size slot
.8852		91 3e		sta ($3e),y			sta 	(zaTemp),y 				; second will be zero.
.8854		7a		ply				ply 							; is there a second (e.g. ,x)
.8855		b1 30		lda ($30),y			lda 	(codePtr),y
.8857		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8859		d0 0a		bne $8865			bne 	_DCOneDimension
.885b		c8		iny				iny 							; skip comma
.885c		20 ac 88	jsr $88ac			jsr 	_DCGetSize 				; get 2nd array size
.885f		5a		phy				phy
.8860		a0 06		ldy #$06			ldy 	#6 						; store in 2nd array size
.8862		91 3e		sta ($3e),y			sta 	(zaTemp),y
.8864		7a		ply				ply
.8865						_DCOneDimension:
.8865		5a		phy				phy 							; save position
.8866		a0 05		ldy #$05			ldy 	#5 						; dimensions + 1 in AX (as zero based)
.8868		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.886a		aa		tax				tax
.886b		c8		iny				iny
.886c		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.886e		e8		inx				inx 							; bump them.
.886f		1a		inc a				inc 	a
.8870		20 74 a8	jsr $a874			jsr 	Multiply8x8 			; work out the total number of elements -> zTemp0
.8873		a5 37		lda $37				lda 	zTemp0+1 				; don't allow more than 8192 elements whatever
.8875		29 e0		and #$e0			and 	#$E0
.8877		d0 23		bne $889c			bne 	_DCSize
.8879		a0 02		ldy #$02			ldy 	#2 						; get base type
.887b		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.887d		20 ba 88	jsr $88ba			jsr 	ScaleByBaseType 		; scale by base type
.8880		a5 36		lda $36				lda 	zTemp0
.8882		a6 37		ldx $37				ldx 	zTemp0+1
.8884		20 6b a4	jsr $a46b			jsr 	AllocateXABytes 		; allocate memory
.8887		a0 03		ldy #$03			ldy 	#3 						; copy into the address.
.8889		91 3e		sta ($3e),y			sta 	(zaTemp),y
.888b		c8		iny				iny
.888c		8a		txa				txa
.888d		91 3e		sta ($3e),y			sta 	(zaTemp),y
.888f		7a		ply				ply 							; get position back
.8890		20 50 99	jsr $9950			jsr 	CheckRightBracket 		; check )
.8893		b1 30		lda ($30),y			lda 	(codePtr),y
.8895		c8		iny				iny 							; consume in case
.8896		c9 2c		cmp #$2c			cmp 	#KWD_COMMA		 		; if so do another DIM.
.8898		f0 85		beq $881f			beq 	DimCommand
.889a		88		dey				dey 							; undo consume
.889b		60		rts				rts
.889c						_DCSize:
.889c		a9 16		lda #$16		lda	#22
.889e		4c 69 99	jmp $9969		jmp	ErrorHandler
.88a1						_DCSyntax:
.88a1		4c 65 ab	jmp $ab65			jmp 	SyntaxError
.88a4						_DCRedefine:
.88a4		a9 15		lda #$15		lda	#21
.88a6		4c 69 99	jmp $9969		jmp	ErrorHandler
.88a9						_DCType:
.88a9		4c 6f ab	jmp $ab6f			jmp 	TypeError
.88ac						_DCGetSize:
.88ac		a2 00		ldx #$00			ldx 	#0 						; get first index.
.88ae		20 64 a8	jsr $a864			jsr 	Evaluate8BitInteger 	; get array dimension
.88b1		c9 00		cmp #$00			cmp 	#0 						; must be 1-254
.88b3		f0 e7		beq $889c			beq 	_DCSize
.88b5		c9 fe		cmp #$fe			cmp 	#254
.88b7		f0 e3		beq $889c			beq 	_DCSize
.88b9		60		rts				rts
.88ba						ScaleByBaseType:
.88ba		29 10		and #$10			and 	#NSBIsString 			; is it string
.88bc		d0 19		bne $88d7			bne 	_SBBTString
.88be		a5 37		lda $37				lda 	zTemp0+1 				; push value on stack
.88c0		48		pha				pha
.88c1		a5 36		lda $36				lda 	zTemp0
.88c3		48		pha				pha
.88c4		06 36		asl $36				asl 	zTemp0 					; x 2
.88c6		26 37		rol $37				rol 	zTemp0+1
.88c8		06 36		asl $36				asl 	zTemp0 					; x 4
.88ca		26 37		rol $37				rol 	zTemp0+1
.88cc		68		pla				pla 							; add stacked value = x 5
.88cd		65 36		adc $36				adc 	zTemp0
.88cf		85 36		sta $36				sta 	zTemp0
.88d1		68		pla				pla
.88d2		65 37		adc $37				adc 	zTemp0+1
.88d4		85 37		sta $37				sta 	zTemp0+1
.88d6		60		rts				rts
.88d7						_SBBTString:
.88d7		06 36		asl $36				asl 	zTemp0
.88d9		26 37		rol $37				rol 	zTemp0+1
.88db		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/commands/dos.asm

.88dc						BootDOS:
.88dc		a9 ea		lda #$ea	            lda     #dosName & $FF
.88de		85 fb		sta $fb		            sta     kernel.args.buf+0
.88e0		a9 88		lda #$88	            lda     #dosName >> 8
.88e2		85 fc		sta $fc		            sta     kernel.args.buf+1
.88e4		20 18 ff	jsr $ff18	            jsr     kernel.RunNamed
.88e7		4c 6c 87	jmp $876c	            jmp 	WarmStart
>88ea		44 4f 53 00			dosName:	.text 	"DOS",0

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/end.asm

.88ee						EndCommand:
.88ee		4c 6c 87	jmp $876c			jmp 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/commands/event.asm

.88f1						UnaryEvent:
.88f1		fa		plx				plx
.88f2		20 e3 97	jsr $97e3			jsr 	TimerToStackX 				; timer in +0
.88f5		e8		inx				inx  								; put reference into +1
.88f6		20 bd a2	jsr $a2bd			jsr 	EvaluateTerm
.88f9		b5 50		lda $50,x			lda 	NSStatus,x 					; check if is integer reference
.88fb		c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.88fd		d0 4c		bne $894b			bne 	_UEType
.88ff		e8		inx				inx 								; put the step in +2
.8900		20 58 99	jsr $9958			jsr 	CheckComma
.8903		20 49 a8	jsr $a849			jsr 	Evaluate16BitInteger
.8906		20 50 99	jsr $9950			jsr 	CheckRightBracket
.8909		ca		dex				dex
.890a		ca		dex				dex
.890b		b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy reference to zTemp0
.890d		85 36		sta $36				sta 	zTemp0
.890f		b5 61		lda $61,x			lda 	NSMantissa1+1,x
.8911		85 37		sta $37				sta 	zTemp0+1
.8913		5a		phy				phy
.8914		a0 03		ldy #$03			ldy 	#3 							; check bit 7 of last bit, the packed sign bit
.8916		b1 36		lda ($36),y			lda 	(zTemp0),y
.8918		30 2d		bmi $8947			bmi 	_UEFalse 					; exit if signed.
.891a		a0 00		ldy #$00			ldy 	#0 							; has it timed out (24 bit)
.891c		b5 58		lda $58,x			lda 	NSMantissa0,x
.891e		d1 36		cmp ($36),y			cmp 	(zTemp0),y
.8920		c8		iny				iny
.8921		b5 60		lda $60,x			lda 	NSMantissa1,x
.8923		f1 36		sbc ($36),y			sbc		(zTemp0),y
.8925		c8		iny				iny
.8926		b5 68		lda $68,x			lda 	NSMantissa2,x
.8928		f1 36		sbc ($36),y			sbc		(zTemp0),y
.892a		90 1b		bcc $8947			bcc 	_UEFalse 					; no, return FALSE.
.892c		18		clc				clc
.892d		a0 00		ldy #$00			ldy 	#0 							; work out new value as timer() + step
.892f		b5 58		lda $58,x			lda 	NSMantissa0,x
.8931		75 5a		adc $5a,x			adc 	NSMantissa0+2,x
.8933		91 36		sta ($36),y			sta 	(zTemp0),y
.8935		c8		iny				iny
.8936		b5 60		lda $60,x			lda 	NSMantissa1,x
.8938		75 62		adc $62,x			adc 	NSMantissa1+2,x
.893a		91 36		sta ($36),y			sta 	(zTemp0),y
.893c		c8		iny				iny
.893d		b5 68		lda $68,x			lda 	NSMantissa2,x
.893f		75 6a		adc $6a,x			adc 	NSMantissa2+2,x
.8941		91 36		sta ($36),y			sta 	(zTemp0),y
.8943		7a		ply				ply
.8944		4c dc 99	jmp $99dc			jmp 	ReturnTrue
.8947						_UEFalse:
.8947		7a		ply				ply 								; restore Y
.8948		4c e7 99	jmp $99e7			jmp 	ReturnFalse 				; and return False
.894b						_UEType:
.894b		4c 6f ab	jmp $ab6f			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/commands/files/bload.asm

.894e						Command_BLoad:
.894e		20 59 89	jsr $8959			jsr 	BLOADHandler
.8951		c9 00		cmp #$00			cmp 	#0
.8953		d0 01		bne $8956			bne 	_BLError
.8955		60		rts				rts
.8956						_BLError:
.8956		4c a8 8b	jmp $8ba8			jmp 	CLErrorHandler
.8959						BLOADHandler:
.8959		a2 00		ldx #$00			ldx 	#0
.895b		20 21 a8	jsr $a821			jsr 	EvaluateString 				; file name to load
.895e		20 58 99	jsr $9958			jsr 	CheckComma 					; consume comma
.8961		e8		inx				inx
.8962		20 36 a8	jsr $a836			jsr 	EvaluateInteger 			; load address (full physical address)
.8965		5a		phy				phy
.8966		a5 58		lda $58				lda 	NSMantissa0					; file name -> XA
.8968		a6 60		ldx $60				ldx 	NSMantissa1
.896a		20 34 83	jsr $8334			jsr 	KNLOpenFileRead 			; open file for reading
.896d		b0 50		bcs $89bf			bcs 	_BLErrorExit 				; error, so fail.
.896f		8d 9e 07	sta $079e			sta 	BasicFileStream 			; save the reading stream.
.8972		a2 01		ldx #$01			ldx 	#1 							; address is in slot # 1
.8974		20 c1 89	jsr $89c1			jsr 	BLOpenPhysicalMemory 		; open for access.
.8977						_BLReadFile:
.8977		ad 9e 07	lda $079e			lda 	BasicFileStream
.897a		a2 40		ldx #$40			ldx     #KNLReadBufferLen 			; set bytes to read.
.897c		20 89 83	jsr $8389			jsr 	KNLReadBlock 				; read next block
.897f		b0 22		bcs $89a3			bcs 	_BLFileError 				; file error, which might be EOF.
.8981		c9 00		cmp #$00			cmp 	#0 							; read nothing.
.8983		f0 f2		beq $8977			beq 	_BLReadFile
.8985		8d 9c 07	sta $079c			sta 	BLCopyCounter 				; counter.
.8988		ac 9b 07	ldy $079b			ldy 	BLYOffset 					; copy the buffer out here
.898b		a2 00		ldx #$00			ldx 	#0 							; offset in buffer.
.898d						_BLCopyLoop:
.898d		bd 8d 06	lda $068d,x			lda 	KNLReadBuffer,x 			; copy byte and advance
.8990		91 3a		sta ($3a),y			sta 	(zTemp2),y
.8992		c8		iny				iny
.8993		d0 03		bne $8998			bne 	_BLNoAdjust 				; check changed 256 byte or 8k page.
.8995		20 e9 89	jsr $89e9			jsr 	BLAdvancePhysicalMemory
.8998						_BLNoAdjust:
.8998		e8		inx				inx
.8999		ce 9c 07	dec $079c			dec 	BLCopyCounter
.899c		d0 ef		bne $898d			bne 	_BLCopyLoop
.899e		8c 9b 07	sty $079b			sty 	BLYOffset 					; update Y offset
.89a1		80 d4		bra $8977			bra 	_BLReadFile 				; go ask for more.
.89a3						_BLFileError:
.89a3		c9 30		cmp #$30			cmp 	#KERR_EOF 					; End of file
.89a5		d0 0d		bne $89b4			bne 	_BLErrorHandler				; no, it's an actual error
.89a7		20 e3 89	jsr $89e3			jsr 	BLClosePhysicalMemory 		; close the access.
.89aa		ad 9e 07	lda $079e			lda 	BasicFileStream 			; close the file
.89ad		20 fe 83	jsr $83fe			jsr 	KNLCloseFile
.89b0		a9 00		lda #$00			lda 	#0 							; and return zero.
.89b2		7a		ply				ply
.89b3		60		rts				rts
.89b4						_BLErrorHandler:
.89b4		48		pha				pha 								; save code
.89b5		20 e3 89	jsr $89e3			jsr 	BLClosePhysicalMemory 		; close access
.89b8		ad 9e 07	lda $079e			lda 	BasicFileStream 			; close the open file
.89bb		20 fe 83	jsr $83fe			jsr 	KNLCloseFile
.89be		68		pla				pla 								; get error code
.89bf						_BLErrorExit:
.89bf		7a		ply				ply 								; restore position and exit.
.89c0		60		rts				rts
=3						BLAccessPage = 3 							; page to use for actual memory.
.89c1						BLOpenPhysicalMemory:
.89c1		a5 0b		lda $0b				lda 	BLAccessPage+8 				; save current mapping
.89c3		8d 9a 07	sta $079a			sta 	BLNormalMapping
.89c6		b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address, 13 bit adjusted for page -> (zTemp2),BLYOffset
.89c8		8d 9b 07	sta $079b			sta 	BLYOffset 					; zTemp2 0 is *always* zero.
.89cb		64 3a		stz $3a				stz 	zTemp2
.89cd		b5 60		lda $60,x			lda 	NSMantissa1,x
.89cf		29 1f		and #$1f			and 	#$1F
.89d1		09 60		ora #$60			ora 	#BLAccessPage << 5
.89d3		85 3b		sta $3b				sta 	zTemp2+1
.89d5		b5 68		lda $68,x			lda 	NSMantissa2,x 				; shift M2:M1 right 3 times to give page # required
.89d7		16 60		asl $60,x			asl 	NSMantissa1,x
.89d9		2a		rol a				rol 	a
.89da		16 60		asl $60,x			asl 	NSMantissa1,x
.89dc		2a		rol a				rol 	a
.89dd		16 60		asl $60,x			asl 	NSMantissa1,x
.89df		2a		rol a				rol 	a
.89e0		85 0b		sta $0b				sta 	BLAccessPage+8 				; access that page
.89e2		60		rts				rts
.89e3						BLClosePhysicalMemory:
.89e3		ad 9a 07	lda $079a			lda 	BLNormalMapping
.89e6		85 0b		sta $0b				sta 	BLAccessPage+8
.89e8		60		rts				rts
.89e9						BLAdvancePhysicalMemory:
.89e9		48		pha				pha
.89ea		e6 3b		inc $3b				inc		zTemp2+1 					; bump MSB
.89ec		a5 3b		lda $3b				lda 	zTemp2+1
.89ee		c9 80		cmp #$80			cmp 	#(BLAccessPage+1) << 5 		; reached next page ?
.89f0		d0 06		bne $89f8			bne 	_BLAPMExit 					; (e.g. end of the mapped page.)
.89f2		e6 0b		inc $0b				inc 	BLAccessPage+8 				; next physical page
.89f4		a9 60		lda #$60			lda 	#BLAccessPage << 5 			; page back to start of transfer page
.89f6		85 3b		sta $3b				sta 	zTemp2+1
.89f8						_BLAPMExit:
.89f8		68		pla				pla
.89f9		60		rts				rts
.079a						BLNormalMapping:
>079a								.fill 	1
.079b						BLYOffset:
>079b								.fill 	1
.079c						BLCopyCounter:
>079c								.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/commands/files/bsave.asm

.89fa						Command_BSave:
.89fa		20 05 8a	jsr $8a05			jsr 	BSaveHandler
.89fd		c9 00		cmp #$00			cmp 	#0
.89ff		d0 01		bne $8a02			bne 	_BSError
.8a01		60		rts				rts
.8a02						_BSError:
.8a02		4c a8 8b	jmp $8ba8			jmp 	CLErrorHandler
.8a05						BSaveHandler:
.8a05		a2 00		ldx #$00			ldx 	#0
.8a07		20 21 a8	jsr $a821			jsr 	EvaluateString 				; file name to load
.8a0a		20 58 99	jsr $9958			jsr 	CheckComma 					; consume comma
.8a0d		e8		inx				inx
.8a0e		20 36 a8	jsr $a836			jsr 	EvaluateInteger 			; load address (full physical address)
.8a11		20 58 99	jsr $9958			jsr 	CheckComma 					; consume comma
.8a14		e8		inx				inx
.8a15		20 36 a8	jsr $a836			jsr 	EvaluateInteger 			; data length (3 bytes only)
.8a18		5a		phy				phy
.8a19		a5 58		lda $58				lda 	NSMantissa0					; file name -> XA
.8a1b		a6 60		ldx $60				ldx 	NSMantissa1
.8a1d		20 2f 83	jsr $832f			jsr 	KNLOpenFileWrite 			; open file for reading
.8a20		b0 47		bcs $8a69			bcs 	_BSErrorExit 				; error, so fail.
.8a22		8d 9e 07	sta $079e			sta 	BasicFileStream 			; save the reading stream.
.8a25		a2 01		ldx #$01			ldx 	#1 							; address is in slot # 1
.8a27		20 c1 89	jsr $89c1			jsr 	BLOpenPhysicalMemory 		; open for access.
.8a2a		a2 00		ldx #$00			ldx 	#0 							; number of bytes in kernel buffer
.8a2c		ac 9b 07	ldy $079b			ldy 	BLYOffset 					; used for data offset.
.8a2f						_BSWriteToFileLoop:
.8a2f		38		sec				sec 								; pre decrement count.
.8a30		a5 5a		lda $5a				lda 	NSMantissa0+2
.8a32		e9 01		sbc #$01			sbc 	#1
.8a34		85 5a		sta $5a				sta 	NSMantissa0+2
.8a36		a5 62		lda $62				lda 	NSMantissa1+2
.8a38		e9 00		sbc #$00			sbc 	#0
.8a3a		85 62		sta $62				sta 	NSMantissa1+2
.8a3c		a5 6a		lda $6a				lda 	NSMantissa2+2
.8a3e		e9 00		sbc #$00			sbc 	#0
.8a40		85 6a		sta $6a				sta 	NSMantissa2+2
.8a42		30 15		bmi $8a59			bmi 	_BSFileComplete 			; undercounted, so exit.
.8a44		b1 3a		lda ($3a),y			lda 	(zTemp2),y 					; get byte to save
.8a46		9d 8d 06	sta $068d,x			sta 	KNLReadBuffer,x 			; save in the buffer and bump buffer index
.8a49		e8		inx				inx
.8a4a		c8		iny				iny 								; next byte
.8a4b		d0 03		bne $8a50			bne 	_BSNoCheck
.8a4d		20 e9 89	jsr $89e9			jsr 	BLAdvancePhysicalMemory 	; check not gone to next page.
.8a50						_BSNoCheck:
.8a50		e0 40		cpx #$40			cpx 	#KNLReadBufferLen 			; done the whole buffer
.8a52		d0 db		bne $8a2f			bne 	_BSWriteToFileLoop 			; no , do the next byte.
.8a54		20 6b 8a	jsr $8a6b			jsr 	BSFlushBuffer 				; yes, flush the buffer
.8a57		80 d6		bra $8a2f			bra 	_BSWriteToFileLoop 			; and keep on going
.8a59						_BSFileComplete:
.8a59		20 6b 8a	jsr $8a6b			jsr 	BSFlushBuffer 				; write the buffer remainder.
.8a5c		20 e3 89	jsr $89e3			jsr 	BLClosePhysicalMemory 		; close the access.
.8a5f		ad 9e 07	lda $079e			lda 	BasicFileStream 			; close the file
.8a62		20 fe 83	jsr $83fe			jsr 	KNLCloseFile
.8a65		a9 00		lda #$00			lda 	#0
.8a67		7a		ply				ply
.8a68		60		rts				rts
.8a69						_BSErrorExit:
.8a69		7a		ply				ply
.8a6a		60		rts				rts
.8a6b						BSFlushBuffer:
.8a6b		e0 00		cpx #$00			cpx 	#0 							; buffer empty ?
.8a6d		f0 0d		beq $8a7c			beq 	_BSFBExit 					; if so, exit.
.8a6f		a9 8d		lda #$8d			lda 	#KNLReadBuffer & $FF 		; where to write from.
.8a71		85 36		sta $36				sta 	zTemp0
.8a73		a9 06		lda #$06			lda 	#KNLReadBuffer >> 8
.8a75		85 37		sta $37				sta 	zTemp0+1 					; # of bytes in X
.8a77		20 64 8c	jsr $8c64			jsr 	CLWriteByteBlock 			; write it.
.8a7a		a2 00		ldx #$00			ldx 	#0 							; buffer is empty.
.8a7c						_BSFBExit:
.8a7c		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/commands/files/dir.asm

.8a7d						Command_Dir:
.8a7d		ad 8d 07	lda $078d			lda     KNLDefaultDrive				; set drive to list.
.8a80		85 f3		sta $f3				sta     kernel.args.directory.open.drive
.8a82		64 fd		stz $fd				stz     kernel.args.directory.open.path_len
.8a84		20 74 ff	jsr $ff74			jsr     kernel.Directory.Open
.8a87		b0 4f		bcs $8ad8			bcs     _CDExit
.8a89						_CDEventLoop:
.8a89		20 0c ff	jsr $ff0c			jsr     kernel.Yield        		; Polite, not actually needed.
.8a8c		20 5b 82	jsr $825b			jsr     GetNextEvent
.8a8f		b0 f8		bcs $8a89			bcs     _CDEventLoop
.8a91		ad 8e 07	lda $078e			lda     KNLEvent.type
.8a94		c9 44		cmp #$44			cmp     #kernel.event.directory.CLOSED
.8a96		f0 40		beq $8ad8			beq    	_CDExit
.8a98		20 9d 8a	jsr $8a9d			jsr     _CDMessages 				; handle various messages
.8a9b		80 ec		bra $8a89			bra     _CDEventLoop
.8a9d						_CDMessages:
.8a9d		c9 3a		cmp #$3a			cmp     #kernel.event.directory.OPENED
.8a9f		f0 15		beq $8ab6			beq     _CDEVRead
.8aa1		c9 3c		cmp #$3c			cmp     #kernel.event.directory.VOLUME
.8aa3		f0 19		beq $8abe			beq     _CDEVVolume
.8aa5		c9 3e		cmp #$3e			cmp     #kernel.event.directory.FILE
.8aa7		f0 32		beq $8adb			beq     _CDEVFile
.8aa9		c9 40		cmp #$40			cmp     #kernel.event.directory.FREE
.8aab		f0 70		beq $8b1d			beq     _CDEVFree
.8aad		c9 42		cmp #$42			cmp     #kernel.event.directory.EOF
.8aaf		f0 6e		beq $8b1f			beq     _CDEVEOF
.8ab1		c9 46		cmp #$46			cmp     #kernel.event.directory.ERROR
.8ab3		f0 6a		beq $8b1f			beq     _CDEVEOF
.8ab5		60		rts				rts
.8ab6						_CDEVRead:
.8ab6		ad 91 07	lda $0791			lda     KNLEvent.directory.stream
.8ab9		85 f3		sta $f3				sta     kernel.args.directory.read.stream
.8abb		4c 78 ff	jmp $ff78			jmp     kernel.Directory.Read
.8abe						_CDEVVolume:
.8abe		a9 5b		lda #$5b			lda 	#"["
.8ac0		20 43 80	jsr $8043			jsr 	EXTPrintCharacter
.8ac3		ad 93 07	lda $0793			lda     KNLEvent.directory.volume.len
.8ac6		20 27 8b	jsr $8b27			jsr     _CDReadData
.8ac9		20 c8 99	jsr $99c8			jsr 	PrintStringXA
.8acc		a9 5d		lda #$5d			lda 	#"]"
.8ace		20 43 80	jsr $8043			jsr 	EXTPrintCharacter
.8ad1		a9 0d		lda #$0d			lda 	#13
.8ad3		20 43 80	jsr $8043			jsr 	EXTPrintCharacter
.8ad6		80 de		bra $8ab6			bra     _CDEVRead
.8ad8						_CDExit:
.8ad8		4c 6c 87	jmp $876c			jmp 	WarmStart
.8adb						_CDEVFile:
.8adb		a9 20		lda #$20			lda 	#32
.8add		20 43 80	jsr $8043			jsr 	EXTPrintCharacter
.8ae0		ad 93 07	lda $0793			lda     KNLEvent.directory.file.len
.8ae3		48		pha				pha
.8ae4		20 27 8b	jsr $8b27			jsr     _CDReadData
.8ae7		20 c8 99	jsr $99c8			jsr 	PrintStringXA
.8aea		68		pla				pla
.8aeb		49 ff		eor #$ff			eor 	#$FF
.8aed		38		sec				sec
.8aee		69 10		adc #$10			adc 	#16
.8af0		aa		tax				tax
.8af1						_CDEVTab:
.8af1		a9 20		lda #$20			lda 	#32
.8af3		20 43 80	jsr $8043			jsr 	EXTPrintCharacter
.8af6		ca		dex				dex
.8af7		10 f8		bpl $8af1			bpl 	_CDEVTab
.8af9		20 3e 8b	jsr $8b3e			jsr 	_CDReadExtended
.8afc		ad 26 05	lda $0526			lda 	lineBuffer
.8aff		ae 27 05	ldx $0527			ldx 	lineBuffer+1
.8b02		20 de 9d	jsr $9dde			jsr 	ConvertInt16
.8b05		20 c8 99	jsr $99c8			jsr 	PrintStringXA
.8b08		a2 8b		ldx #$8b			ldx 	#_CDEVFMessage >> 8
.8b0a		a9 11		lda #$11			lda 	#_CDEVFMessage & $FF
.8b0c		20 c8 99	jsr $99c8			jsr 	PrintStringXA
.8b0f		80 a5		bra $8ab6			bra     _CDEVRead
.8b11						_CDEVFMessage:
>8b11		20 62 6c 6f 63 6b 28 73				.text 	" block(s).",13,0
>8b19		29 2e 0d 00
.8b1d						_CDEVFree:
.8b1d		80 00		bra $8b1f			bra     _CDEVEOF
.8b1f						_CDEVEOF:
.8b1f		ad 91 07	lda $0791			lda     KNLEvent.directory.stream
.8b22		85 f3		sta $f3				sta     kernel.args.directory.close.stream
.8b24		4c 7c ff	jmp $ff7c			jmp     kernel.Directory.Close
.8b27						_CDReadData:
.8b27		85 fd		sta $fd				sta     kernel.args.recv.buflen
.8b29		a9 26		lda #$26			lda     #lineBuffer & $FF
.8b2b		85 fb		sta $fb				sta     kernel.args.recv.buf+0
.8b2d		a9 05		lda #$05			lda     #lineBuffer >> 8
.8b2f		85 fc		sta $fc				sta     kernel.args.recv.buf+1
.8b31		20 04 ff	jsr $ff04			jsr     kernel.ReadData
.8b34		a6 fd		ldx $fd				ldx     kernel.args.recv.buflen
.8b36		9e 26 05	stz $0526,x			stz     lineBuffer,x
.8b39		a9 26		lda #$26			lda 	#lineBuffer & $FF
.8b3b		a2 05		ldx #$05			ldx 	#lineBuffer >> 8
.8b3d		60		rts				rts
.8b3e						_CDReadExtended:
.8b3e		a9 02		lda #$02			lda     #2
.8b40		85 fd		sta $fd				sta     kernel.args.recv.buflen
.8b42		a9 26		lda #$26			lda     #lineBuffer & $FF
.8b44		85 fb		sta $fb				sta     kernel.args.recv.buf+0
.8b46		a9 05		lda #$05			lda     #lineBuffer >> 8
.8b48		85 fc		sta $fc				sta     kernel.args.recv.buf+1
.8b4a		4c 08 ff	jmp $ff08			jmp     kernel.ReadExt

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/commands/files/drive.asm

.8b4d						Command_Drive:
.8b4d		20 64 a8	jsr $a864			jsr 	Evaluate8BitInteger
.8b50		20 2b 83	jsr $832b			jsr 	KNLSetDrive
.8b53		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/commands/files/load.asm

.8b54						Command_Load:
.8b54		20 5a 8b	jsr $8b5a			jsr 	LoadFile
.8b57		4c 6c 87	jmp $876c			jmp 	WarmStart
.8b5a						LoadFile:
.8b5a		20 21 a8	jsr $a821			jsr 	EvaluateString 				; file name to load
.8b5d		a6 37		ldx $37				ldx 	zTemp0+1					; zTemp0 -> XA
.8b5f		a5 36		lda $36				lda 	zTemp0
.8b61		20 34 83	jsr $8334			jsr 	KNLOpenFileRead 			; open file for reading
.8b64		b0 42		bcs $8ba8			bcs 	CLErrorHandler 				; error, so fail.
.8b66		8d 9e 07	sta $079e			sta 	BasicFileStream 			; save the reading stream.
.8b69		20 f8 8b	jsr $8bf8			jsr     LoadReadByteInit            ; Init reader with the stream
.8b6c		20 33 93	jsr $9333			jsr 	NewProgram 					; does the actual NEW.
.8b6f		9c 9d 07	stz $079d			stz 	LoadEOFFlag 				; clear EOF Flag.
.8b72						_CLLoop:
.8b72		20 b6 8b	jsr $8bb6			jsr 	LoadReadLine 				; get next line.
.8b75		f0 10		beq $8b87			beq 	_CLExit 					; end, exit.
.8b77		20 89 80	jsr $8089			jsr 	TKTokeniseLine 				; tokenise the line.
.8b7a		ad 27 04	lda $0427			lda 	tokenLineNumber 			; line number = 0
.8b7d		0d 28 04	ora $0428			ora 	tokenLineNumber+1
.8b80		f0 f0		beq $8b72			beq 	_CLLoop 					; not legal code, blank line or maybe a comment.
.8b82		20 47 87	jsr $8747			jsr 	EditProgramCode 			; do the editing etc.
.8b85		80 eb		bra $8b72			bra 	_CLLoop
.8b87						_CLExit:
.8b87		ad 9e 07	lda $079e			lda 	BasicFileStream
.8b8a		20 fe 83	jsr $83fe			jsr 	KNLCloseFile
.8b8d						CLComplete:
.8b8d		a9 95		lda #$95			lda 	#_CLCMsg & $FF
.8b8f		a2 8b		ldx #$8b			ldx 	#_CLCMsg >> 8
.8b91		20 c8 99	jsr $99c8			jsr 	PrintStringXA
.8b94		60		rts				rts
.8b95						_CLCMsg:
>8b95		43 6f 6d 70 6c 65 74 65				.text 	"Complete.",13,0
>8b9d		2e 0d 00
.8ba0						CLCloseError:
.8ba0		48		pha				pha
.8ba1		ad 9e 07	lda $079e			lda 	BasicFileStream
.8ba4		20 fe 83	jsr $83fe			jsr 	KNLCloseFile
.8ba7		68		pla				pla
.8ba8						CLErrorHandler:
.8ba8		c9 28		cmp #$28			cmp 	#KERR_NOTFOUND
.8baa		f0 05		beq $8bb1			beq 	_CLEHNotFound
.8bac		a9 1a		lda #$1a		lda	#26
.8bae		4c 69 99	jmp $9969		jmp	ErrorHandler
.8bb1						_CLEHNotFound:
.8bb1		a9 19		lda #$19		lda	#25
.8bb3		4c 69 99	jmp $9969		jmp	ErrorHandler
.8bb6						LoadReadLine:
.8bb6		a2 00		ldx #$00			ldx 	#0 							; look for first character non space/ctl
.8bb8		20 d2 8b	jsr $8bd2			jsr 	LoadReadCharacter
.8bbb		f0 14		beq $8bd1			beq 	_LRLExit 					; eof ?
.8bbd		c9 21		cmp #$21			cmp 	#' '+1 						; space control tab skip
.8bbf		90 f5		bcc $8bb6			bcc 	LoadReadLine
.8bc1						_LRLLoop:
.8bc1		9d 26 05	sta $0526,x			sta 	lineBuffer,x 				; write into line buffer
.8bc4		9e 27 05	stz $0527,x			stz 	lineBuffer+1,x 				; make ASCIIZ
.8bc7		e8		inx				inx
.8bc8		20 d2 8b	jsr $8bd2			jsr 	LoadReadCharacter 			; next line
.8bcb		c9 20		cmp #$20			cmp 	#32 						; until < space ctrl/eof.
.8bcd		b0 f2		bcs $8bc1			bcs 	_LRLLoop
.8bcf		a9 01		lda #$01			lda 	#1 							; return code 1, okay.
.8bd1						_LRLExit:
.8bd1		60		rts				rts
.8bd2						LoadReadCharacter:
.8bd2		da		phx				phx
.8bd3		5a		phy				phy
.8bd4		ad 9d 07	lda $079d			lda 	LoadEOFFlag 				; already done EOF.
.8bd7		d0 0c		bne $8be5			bne 	_LRCIsEOF
.8bd9		20 02 8c	jsr $8c02			jsr 	LoadReadByte 				; read a byte
.8bdc		90 09		bcc $8be7			bcc		_LRCExit 					; read okay.
.8bde		c9 30		cmp #$30			cmp 	#KERR_EOF 					; if error not EOF it's an actual error.
.8be0		d0 be		bne $8ba0			bne 	CLCloseError
.8be2		ce 9d 07	dec $079d			dec 	LoadEOFFlag
.8be5						_LRCIsEOF:
.8be5		a9 00		lda #$00			lda 	#0
.8be7						_LRCExit:
.8be7		c9 09		cmp #$09			cmp 	#9 							; convert tab to space
.8be9		d0 02		bne $8bed			bne 	_LRCNotTab
.8beb		a9 20		lda #$20			lda 	#' '
.8bed						_LRCNotTab:
.8bed		c9 0a		cmp #$0a			cmp 	#$0A
.8bef		d0 02		bne $8bf3			bne 	_LRCNotLF
.8bf1		a9 0d		lda #$0d			lda 	#$0D
.8bf3						_LRCNotLF:
.8bf3		7a		ply				ply
.8bf4		fa		plx				plx
.8bf5		c9 00		cmp #$00			cmp 	#0 							; set Z flag if EOF.
.8bf7		60		rts				rts
.8bf8						LoadReadByteInit:
.8bf8		8d 9f 07	sta $079f			sta     LoadFileStream 				; save stream
.8bfb		9c a0 07	stz $07a0			stz     LoadNextCharacter 			; reset buffer
.8bfe		9c a1 07	stz $07a1			stz     LoadEndCharacter
.8c01		60		rts				rts
.8c02						LoadReadByte:
.8c02		da		phx				phx
.8c03		ae a0 07	ldx $07a0			ldx     LoadNextCharacter 					; all data consumed ?
.8c06		ec a1 07	cpx $07a1			cpx     LoadEndCharacter
.8c09		d0 12		bne $8c1d			bne     _KNLRBGetNextByte
.8c0b		ad 9f 07	lda $079f			lda     LoadFileStream
.8c0e		a2 40		ldx #$40			ldx     #KNLReadBufferLen 			; set bytes to read.
.8c10		20 89 83	jsr $8389			jsr     KNLReadBlock 				; read next chunk from the stream
.8c13		b0 0f		bcs $8c24			bcs     _KNLRBError 				; error has occurred on read.
.8c15		8d a1 07	sta $07a1			sta     LoadEndCharacter 						; # read is the number available
.8c18		a2 00		ldx #$00			ldx     #0 							; reset the read pointer.
.8c1a		8e a0 07	stx $07a0			stx     LoadNextCharacter
.8c1d						_KNLRBGetNextByte:
.8c1d		bd 8d 06	lda $068d,x			lda     KNLReadBuffer,x 			; get the next data item
.8c20		ee a0 07	inc $07a0			inc     LoadNextCharacter 					; and advance the index
.8c23		18		clc				clc 								; succeeded
.8c24						_KNLRBError:
.8c24		fa		plx				plx
.8c25		60		rts				rts
.079d						LoadEOFFlag:
>079d								.fill 	1
.079e						BasicFileStream:
>079e								.fill 	1
.079f						LoadFileStream:
>079f								.byte   ?
.07a0						LoadNextCharacter:
>07a0								.byte   ?
.07a1						LoadEndCharacter:
>07a1								.byte   ?

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/commands/files/save.asm

.8c26						Command_Save:
.8c26		20 21 a8	jsr $a821			jsr 	EvaluateString 				; file name to load
.8c29		a6 37		ldx $37				ldx 	zTemp0+1					; zTemp0 -> XA
.8c2b		a5 36		lda $36				lda 	zTemp0
.8c2d		20 2f 83	jsr $832f			jsr 	KNLOpenFileWrite 			; open file for writing
.8c30		b0 2f		bcs $8c61			bcs 	CSErrorHandler 				; error, so fail.
.8c32		8d 9e 07	sta $079e			sta 	BasicFileStream 			; save the reading stream.
.8c35		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8c37		85 30		sta $30				sta 	codePtr
.8c39		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8c3b		85 31		sta $31				sta 	codePtr+1
.8c3d						_CSLoop:
.8c3d		b2 30		lda ($30)			lda 	(codePtr)
.8c3f		f0 17		beq $8c58			beq 	_CSExit
.8c41		20 85 8c	jsr $8c85			jsr 	CSGetCleanLine
.8c44		84 37		sty $37				sty 	zTemp0+1 					; save write address of data
.8c46		85 36		sta $36				sta 	zTemp0
.8c48		20 64 8c	jsr $8c64			jsr 	CLWriteByteBlock 			; write the block out.
.8c4b		18		clc				clc
.8c4c		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8c4e		65 30		adc $30				adc 	codePtr
.8c50		85 30		sta $30				sta 	codePtr
.8c52		90 02		bcc $8c56			bcc 	_CREExit
.8c54		e6 31		inc $31				inc 	codePtr+1 					; carry
.8c56						_CREExit:
.8c56		80 e5		bra $8c3d			bra 	_CSLoop
.8c58						_CSExit:
.8c58		ad 9e 07	lda $079e			lda 	BasicFileStream 			; close file
.8c5b		20 fe 83	jsr $83fe			jsr 	KNLCloseFile
.8c5e		4c 8d 8b	jmp $8b8d			jmp 	CLComplete 					; display complete message.
.8c61						CSErrorHandler:
.8c61		4c a8 8b	jmp $8ba8			jmp 	CLErrorHandler
.8c64						CLWriteByteBlock:
.8c64		e0 00		cpx #$00			cpx 	#0 							; written the lot ?
.8c66		f0 1c		beq $8c84			beq 	_CLWBBExit					; if so, exit
.8c68		ad 9e 07	lda $079e			lda 	BasicFileStream 			; stream to write, count in X
.8c6b		20 c4 83	jsr $83c4			jsr 	KNLWriteBlock 				; call one write attempt
.8c6e		b0 f1		bcs $8c61			bcs 	CSErrorHandler 				; error occurred
.8c70		85 38		sta $38				sta 	zTemp1 						; save bytes written.
.8c72		8a		txa				txa 								; subtract bytes written from X, total count.
.8c73		38		sec				sec
.8c74		e5 38		sbc $38				sbc 	zTemp1
.8c76		aa		tax				tax
.8c77		18		clc				clc 								; advance zTemp0 pointer by bytes written.
.8c78		a5 36		lda $36				lda 	zTemp0
.8c7a		65 38		adc $38				adc 	zTemp1
.8c7c		85 36		sta $36				sta 	zTemp0
.8c7e		90 e4		bcc $8c64			bcc 	CLWriteByteBlock
.8c80		e6 37		inc $37				inc 	zTemp0+1
.8c82		80 e0		bra $8c64			bra 	CLWriteByteBlock 			; and retry write out.
.8c84						_CLWBBExit:
.8c84		60		rts				rts
.8c85						CSGetCleanLine:
.8c85		a9 00		lda #$00			lda 	#0 							; no indent.
.8c87		20 7f 80	jsr $807f			jsr 	TKListConvertLine 			; convert line into token Buffer
.8c8a		a2 00		ldx #$00			ldx 	#0 							; copy stripping controls.
.8c8c		a0 00		ldy #$00			ldy 	#0
.8c8e						_CSClean:
.8c8e		b9 29 04	lda $0429,y			lda 	tokenBuffer,y
.8c91		f0 09		beq $8c9c			beq 	_CSDoneClean
.8c93		30 04		bmi $8c99			bmi 	_CSIgnoreCharacter
.8c95		9d 26 05	sta $0526,x			sta 	lineBuffer,x
.8c98		e8		inx				inx
.8c99						_CSIgnoreCharacter:
.8c99		c8		iny				iny
.8c9a		80 f2		bra $8c8e			bra 	_CSClean
.8c9c						_CSDoneClean:
.8c9c		a9 0d		lda #$0d			lda 	#13 						; add CR, length now in X and ASCIIZ.
.8c9e		9d 26 05	sta $0526,x			sta 	lineBuffer,x
.8ca1		e8		inx				inx
.8ca2		9e 26 05	stz $0526,x			stz 	lineBuffer,x
.8ca5		a0 05		ldy #$05			ldy 	#(lineBuffer >> 8) 			; line address in YA
.8ca7		a9 26		lda #$26			lda 	#(lineBuffer & $FF)
.8ca9		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/commands/files/verify.asm

.e7fa						m
.8caa						Command_VERIFY:
.8caa		20 21 a8	jsr $a821			jsr 	EvaluateString 				; file name to verify
.8cad		a6 37		ldx $37				ldx 	zTemp0+1					; zTemp0 -> XA
.8caf		a5 36		lda $36				lda 	zTemp0
.8cb1		20 34 83	jsr $8334			jsr 	KNLOpenFileRead 			; open file for reading
.8cb4		b0 4b		bcs $8d01			bcs 	_CVErrorHandler 			; error, so fail.
.8cb6		8d 9e 07	sta $079e			sta 	BasicFileStream 			; save the reading stream.
.8cb9		20 f8 8b	jsr $8bf8			jsr     LoadReadByteInit            ; Init reader with the stream
.8cbc		9c 9d 07	stz $079d			stz 	LoadEOFFlag 				; clear EOF Flag.
.8cbf		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8cc1		85 30		sta $30				sta 	codePtr
.8cc3		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8cc5		85 31		sta $31				sta 	codePtr+1
.8cc7						_CVLoop:
.8cc7		20 b6 8b	jsr $8bb6			jsr 	LoadReadLine 				; get next line.
.8cca		f0 27		beq $8cf3			beq 	_CVExit 					; end, exit.
.8ccc		20 89 80	jsr $8089			jsr 	TKTokeniseLine 				; tokenise the line.
.8ccf		ad 27 04	lda $0427			lda 	tokenLineNumber 			; line number = 0
.8cd2		0d 28 04	ora $0428			ora 	tokenLineNumber+1
.8cd5		f0 f0		beq $8cc7			beq 	_CVLoop 					; not legal code, blank line or maybe a comment.
.8cd7		a0 00		ldy #$00			ldy 	#0 							; start compare
.8cd9						_CVCompareLoop:
.8cd9		b1 30		lda ($30),y			lda 	(codePtr),y
.8cdb		d9 26 04	cmp $0426,y			cmp 	tokenOffset,y 				; compare against actual code.
.8cde		d0 1c		bne $8cfc			bne 	_CVCompareError
.8ce0		c8		iny				iny
.8ce1		cc 26 04	cpy $0426			cpy 	tokenOffset 				; until done whole line of code
.8ce4		d0 f3		bne $8cd9			bne 	_CVCompareLoop
.8ce6		18		clc				clc
.8ce7		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8ce9		65 30		adc $30				adc 	codePtr
.8ceb		85 30		sta $30				sta 	codePtr
.8ced		90 02		bcc $8cf1			bcc 	_CREExit
.8cef		e6 31		inc $31				inc 	codePtr+1 					; carry
.8cf1						_CREExit:
.8cf1		80 d4		bra $8cc7			bra 	_CVLoop
.8cf3						_CVExit:
.8cf3		ad 9e 07	lda $079e			lda 	BasicFileStream
.8cf6		20 fe 83	jsr $83fe			jsr 	KNLCloseFile
.8cf9		4c 8d 8b	jmp $8b8d			jmp 	CLComplete
.8cfc						_CVCompareError:
.8cfc		a9 1b		lda #$1b		lda	#27
.8cfe		4c 69 99	jmp $9969		jmp	ErrorHandler
.8d01						_CVErrorHandler:
.8d01		4c a8 8b	jmp $8ba8			jmp 	CLErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/for.asm

.8d04						ForCommand:
.8d04		a9 d9		lda #$d9			lda 	#STK_FOR+9 					; allocate 18 bytes on the return stack (see above).
.8d06		20 df b1	jsr $b1df			jsr 	StackOpen
.8d09		a2 00		ldx #$00			ldx 	#0
.8d0b		20 bd a2	jsr $a2bd			jsr 	EvaluateTerm
.8d0e		b5 50		lda $50,x			lda 	NSStatus,x
.8d10		c9 20		cmp #$20			cmp 	#NSBIsReference+NSTInteger 	; do we have an integer 4 byte reference.
.8d12		d0 47		bne $8d5b			bne		_FCError
.8d14		a9 3d		lda #$3d			lda 	#KWD_EQUAL 					; =
.8d16		20 60 99	jsr $9960			jsr 	CheckNextA
.8d19		e8		inx				inx
.8d1a		20 36 a8	jsr $a836			jsr 	EvaluateInteger 			; <from> in +1
.8d1d		b1 30		lda ($30),y			lda 	(codePtr),y
.8d1f		c8		iny				iny 								; consume it
.8d20		48		pha				pha 								; save on stack for later
.8d21		c9 c1		cmp #$c1			cmp 	#KWD_DOWNTO
.8d23		f0 04		beq $8d29			beq 	_FCNoSyntax
.8d25		c9 db		cmp #$db			cmp 	#KWD_TO
.8d27		d0 35		bne $8d5e			bne 	_FCSyntaxError
.8d29						_FCNoSyntax:
.8d29		e8		inx				inx
.8d2a		20 36 a8	jsr $a836			jsr 	EvaluateInteger
.8d2d		20 24 b2	jsr $b224			jsr 	STKSaveCodePosition 		; save loop back position
.8d30		68		pla				pla 								; restore DOWNTO or TO
.8d31		5a		phy				phy 								; save Y on the stack
.8d32		49 c1		eor #$c1			eor 	#KWD_DOWNTO 				; 0 if DOWNTO, #0 if TO
.8d34		f0 02		beq $8d38			beq 	_FCNotDownTo
.8d36		a9 02		lda #$02			lda 	#2
.8d38						_FCNotDownTo:
.8d38		3a		dec a				dec 	a 							; 255 if DOWNTO, 1 if TO
.8d39		a0 10		ldy #$10			ldy 	#16
.8d3b		91 34		sta ($34),y			sta 	(basicStack),y 				; copy that out to the Basic Stack.
.8d3d		a0 06		ldy #$06			ldy 	#6 							; this is the address of the loop variable.
.8d3f		a5 58		lda $58				lda 	NSMantissa0
.8d41		91 34		sta ($34),y			sta 	(basicStack),y
.8d43		a5 60		lda $60				lda 	NSMantissa1
.8d45		c8		iny				iny
.8d46		91 34		sta ($34),y			sta 	(basicStack),y
.8d48		a0 08		ldy #$08			ldy 	#8 							; set initial index value
.8d4a		a2 01		ldx #$01			ldx 	#1
.8d4c		20 61 8d	jsr $8d61			jsr 	FCIntegerToStack
.8d4f		a0 0c		ldy #$0c			ldy 	#12 						; set the terminal value
.8d51		a2 02		ldx #$02			ldx 	#2
.8d53		20 61 8d	jsr $8d61			jsr 	FCIntegerToStack
.8d56		20 7c 8d	jsr $8d7c			jsr 	CopyIndexToReference
.8d59		7a		ply				ply 								; restore position
.8d5a		60		rts				rts
.8d5b						_FCError:
.8d5b		4c 6f ab	jmp $ab6f			jmp 	TypeError
.8d5e						_FCSyntaxError:
.8d5e		4c 65 ab	jmp $ab65			jmp 	SyntaxError
.8d61						FCIntegerToStack:
.8d61		34 50		bit $50,x			bit 	NSStatus,x 					; is the value negative
.8d63		10 03		bpl $8d68			bpl	 	_FCNotNegative
.8d65		20 92 a8	jsr $a892			jsr 	NSMNegateMantissa 			; if so 2's complement the mantissa
.8d68						_FCNotNegative:
.8d68		b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy out to the basic stack
.8d6a		91 34		sta ($34),y			sta 	(basicStack),y
.8d6c		c8		iny				iny
.8d6d		b5 60		lda $60,x			lda 	NSMantissa1,x
.8d6f		91 34		sta ($34),y			sta 	(basicStack),y
.8d71		c8		iny				iny
.8d72		b5 68		lda $68,x			lda 	NSMantissa2,x
.8d74		91 34		sta ($34),y			sta 	(basicStack),y
.8d76		c8		iny				iny
.8d77		b5 70		lda $70,x			lda 	NSMantissa3,x
.8d79		91 34		sta ($34),y			sta 	(basicStack),y
.8d7b		60		rts				rts
.8d7c						CopyIndexToReference:
.8d7c		5a		phy				phy
.8d7d		a0 06		ldy #$06			ldy 	#6 							; copy address-8 to write to zTemp0
.8d7f		38		sec				sec 								; (because we copy from offset 8)
.8d80		b1 34		lda ($34),y			lda 	(basicStack),y
.8d82		e9 08		sbc #$08			sbc 	#8
.8d84		85 36		sta $36				sta 	zTemp0
.8d86		c8		iny				iny
.8d87		b1 34		lda ($34),y			lda 	(basicStack),y
.8d89		e9 00		sbc #$00			sbc 	#0
.8d8b		85 37		sta $37				sta 	zTemp0+1
.8d8d		a2 04		ldx #$04			ldx 	#4 							; this is the copy counter/
.8d8f		a0 0b		ldy #$0b			ldy 	#8+3 		 				; the MSB of the mantissa
.8d91		b1 34		lda ($34),y			lda 	(basicStack),y
.8d93		0a		asl a				asl 	a 							; into carry
.8d94		a0 08		ldy #$08			ldy 	#8 							; where to copy from.
.8d96		90 14		bcc $8dac			bcc 	_CITRNormal
.8d98		38		sec				sec
.8d99						_CITRNegative:
.8d99		a9 00		lda #$00			lda 	#0
.8d9b		f1 34		sbc ($34),y			sbc 	(basicStack),y
.8d9d		91 36		sta ($36),y			sta 	(zTemp0),y
.8d9f		c8		iny				iny
.8da0		ca		dex				dex
.8da1		d0 f6		bne $8d99			bne 	_CITRNegative
.8da3		88		dey				dey 								; look at MSB of mantissa
.8da4		b1 36		lda ($36),y			lda 	(zTemp0),y 					; set the MSB as negative packed.
.8da6		09 80		ora #$80			ora 	#$80
.8da8		91 36		sta ($36),y			sta 	(zTemp0),y
.8daa		7a		ply				ply
.8dab		60		rts				rts
.8dac						_CITRNormal:
.8dac		b1 34		lda ($34),y			lda 	(basicStack),y 				; copy without negation.
.8dae		91 36		sta ($36),y			sta 	(zTemp0),y
.8db0		c8		iny				iny
.8db1		ca		dex				dex
.8db2		d0 f8		bne $8dac			bne 	_CITRNormal
.8db4		7a		ply				ply 								; and exit.
.8db5		60		rts				rts
.8db6						NextCommand:
.8db6		a9 d9		lda #$d9			lda 	#STK_FOR+9 					; check FOR is TOS
.8db8		a2 11		ldx #$11			ldx 	#ERRID_FOR 					; this error
.8dba		20 0c b2	jsr $b20c			jsr 	StackCheckFrame
.8dbd		5a		phy				phy
.8dbe		a0 10		ldy #$10			ldy 	#16 						; get the step count
.8dc0		b1 34		lda ($34),y			lda 	(basicStack),y
.8dc2		85 36		sta $36				sta 	zTemp0 						; this is the sign extend
.8dc4		30 02		bmi $8dc8			bmi 	_NCStepNeg
.8dc6		64 36		stz $36				stz 	zTemp0 						; which is 0 or 255
.8dc8						_NCStepNeg:
.8dc8		a0 08		ldy #$08			ldy 	#8 							; offset to bump
.8dca		a2 04		ldx #$04			ldx 	#4 							; count to bump
.8dcc		18		clc				clc
.8dcd						_NCBump:
.8dcd		71 34		adc ($34),y			adc 	(basicStack),y 				; add it
.8dcf		91 34		sta ($34),y			sta 	(basicStack),y
.8dd1		a5 36		lda $36				lda 	zTemp0 						; get sign extend for next time.
.8dd3		c8		iny				iny 								; next byte
.8dd4		ca		dex				dex 								; do four times
.8dd5		d0 f6		bne $8dcd			bne 	_NCBump
.8dd7		20 7c 8d	jsr $8d7c			jsr		CopyIndexToReference		; copy it to the reference variable.
.8dda		a0 10		ldy #$10			ldy 	#16 						; get step count again
.8ddc		b1 34		lda ($34),y			lda 	(basicStack),y
.8dde		0a		asl a				asl 	a 							; sign bit to carry
.8ddf		a9 0c		lda #$0c			lda 	#12 						; offset of LHS = terminal offset
.8de1		85 38		sta $38				sta 	zTemp1
.8de3		90 02		bcc $8de7			bcc 	_NCCompRev 					; use if step is +ve
.8de5		a9 08		lda #$08			lda 	#8 							; now the LHS = index value
.8de7						_NCCompRev:
.8de7		85 38		sta $38				sta 	zTemp1 						; so zTemp0 is the index for LHS
.8de9		49 04		eor #$04			eor 	#(8^12) 					; and zTemp0+1 is the index for RHS
.8deb		85 39		sta $39				sta 	zTemp1+1
.8ded		a2 04		ldx #$04			ldx 	#4 							; bytes to compare
.8def		38		sec				sec
.8df0						_NCCompare:
.8df0		a4 38		ldy $38				ldy 	zTemp1 						; do compare using the two indices
.8df2		b1 34		lda ($34),y			lda 	(basicStack),y
.8df4		a4 39		ldy $39				ldy 	zTemp1+1
.8df6		f1 34		sbc ($34),y			sbc 	(basicStack),y
.8df8		e6 38		inc $38				inc 	zTemp1 						; bump the indices (inc,dex do not change C or V)
.8dfa		e6 39		inc $39				inc 	zTemp1+1
.8dfc		ca		dex				dex 								; do it 4 times.
.8dfd		d0 f1		bne $8df0			bne 	_NCCompare
.8dff		50 02		bvc $8e03			bvc 	_NCNoOverflow 				; convert to signed comparison
.8e01		49 80		eor #$80			eor 	#$80
.8e03						_NCNoOverflow:
.8e03		7a		ply				ply 								; restore Y position
.8e04		0a		asl a				asl 	a 							; is bit 7 set.
.8e05		90 04		bcc $8e0b			bcc 	_NCLoopBack 				; if no , >= so loop back
.8e07		20 fe b1	jsr $b1fe			jsr 	StackClose 					; exit the loop
.8e0a		60		rts				rts
.8e0b						_NCLoopBack:
.8e0b		20 35 b2	jsr $b235			jsr 	STKLoadCodePosition 		; loop back
.8e0e		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/gosub.asm

.8e0f						Command_GOSUB:
.8e0f		a2 00		ldx #$00			ldx 	#0
.8e11		20 49 a8	jsr $a849			jsr 	Evaluate16BitInteger 		; line number in Stack.0
.8e14		a9 e3		lda #$e3			lda 	#STK_GOSUB+3
.8e16		20 df b1	jsr $b1df			jsr 	StackOpen 					; create frame
.8e19		20 24 b2	jsr $b224			jsr 	STKSaveCodePosition 		; save current position
.8e1c		4c 32 8e	jmp $8e32			jmp 	GotoStackX
.8e1f						Command_RETURN:
.8e1f		a9 e0		lda #$e0			lda 	#STK_GOSUB 					; check TOS is this
.8e21		a2 0e		ldx #$0e			ldx 	#ERRID_GOSUB 				; this error
.8e23		20 0c b2	jsr $b20c			jsr 	StackCheckFrame
.8e26		20 35 b2	jsr $b235			jsr 	STKLoadCodePosition 		; restore code position
.8e29		20 fe b1	jsr $b1fe			jsr 	StackClose
.8e2c		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/goto.asm

.8e2d						GotoCommand:
.8e2d		a2 00		ldx #$00			ldx 	#0 							; GOTO where
.8e2f		20 49 a8	jsr $a849			jsr 	Evaluate16BitInteger
.8e32						GotoStackX:
.8e32		b5 60		lda $60,x			lda  	NSMantissa1,x 				; put line # in XA. I'll keep this even though
.8e34		48		pha				pha 								; it is slightly inefficient, just in cases.
.8e35		b5 58		lda $58,x			lda 	NSMantissa0,x
.8e37		fa		plx				plx
.8e38		20 fd ad	jsr $adfd			jsr 	MemorySearch 				; transfer to line number AX.
.8e3b		90 05		bcc $8e42			bcc 	_GotoError 					; not found, off end.
.8e3d		d0 03		bne $8e42			bne 	_GotoError 					; not found exactly
.8e3f		4c c9 94	jmp $94c9			jmp 	RunNewLine 					; and go straight to new line code.
.8e42						_GotoError:
.8e42		a9 0d		lda #$0d		lda	#13
.8e44		4c 69 99	jmp $9969		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/if.asm

.8e47						IfCommand:
.8e47		a2 00		ldx #$00			ldx 	#0 							; Get the if test.
.8e49		20 17 a8	jsr $a817			jsr 	EvaluateNumber
.8e4c		b1 30		lda ($30),y			lda 	(codePtr),y
.8e4e		c9 b5		cmp #$b5			cmp 	#KWD_THEN  					; could be THEN <stuff>
.8e50		d0 0a		bne $8e5c			bne 	_IfStructured 				; we still support it.
.8e52		c8		iny				iny 								; consume THEN
.8e53		20 eb a8	jsr $a8eb			jsr 	NSMIsZero 					; is it zero
.8e56		f0 01		beq $8e59			beq 	_IfFail 					; if fail, go to next line
.8e58		60		rts				rts 								; if THEN just continue
.8e59						_IfFail:
.8e59		4c a4 94	jmp $94a4			jmp 	EOLCommand
.8e5c						_IfStructured:
.8e5c		20 eb a8	jsr $a8eb			jsr 	NSMIsZero 					; is it zero
.8e5f		d0 07		bne $8e68			bne 	_IfExit 					; if not, then continue normally.
.8e61		a9 c2		lda #$c2			lda 	#KWD_ELSE 					; look for else/endif
.8e63		a2 b2		ldx #$b2			ldx 	#KWD_ENDIF
.8e65		20 ab 98	jsr $98ab			jsr 	ScanForward 				; and run from there
.8e68						_IfExit:
.8e68		60		rts				rts
.8e69						ElseCode:
.8e69		a9 b2		lda #$b2			lda 	#KWD_ENDIF 					; else is only run after the if clause succeeds
.8e6b		aa		tax				tax 								; so just go to the structure exit
.8e6c		20 ab 98	jsr $98ab			jsr 	ScanForward
.8e6f		60		rts				rts
.8e70						EndIf:
.8e70		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/inputprint.asm

.8e71						Command_Input:
.8e71		9c 24 04	stz $0424			stz 	isPrintFlag
.8e74		80 0c		bra $8e82			bra 	Command_IP_Main
.8e76						Command_CPrint:
.8e76		a9 7f		lda #$7f			lda 	#$7F 						; set input flag to character mode
.8e78		8d 24 04	sta $0424			sta 	isPrintFlag 				; clear input flag
.8e7b		80 05		bra $8e82			bra 	Command_IP_Main
.8e7d						Command_Print:
.8e7d		a9 ff		lda #$ff			lda 	#$FF 						; set input flag
.8e7f		8d 24 04	sta $0424			sta 	isPrintFlag 				; clear input flag
.8e82						Command_IP_Main:
.8e82		18		clc				clc 								; carry being clear means last print wasn't comma/semicolon
.8e83						_CPLoop:
.8e83		08		php				php 								; save last action flag
.8e84		b1 30		lda ($30),y			lda 	(codePtr),y
.8e86		c9 80		cmp #$80			cmp  	#KWC_EOL 					; end of line or colon, exit now.
.8e88		f0 54		beq $8ede			beq 	_CPExit
.8e8a		c9 3a		cmp #$3a			cmp 	#KWD_COLON
.8e8c		f0 50		beq $8ede			beq 	_CPExit
.8e8e		68		pla				pla 								; throw last action flag
.8e8f		b1 30		lda ($30),y			lda 	(codePtr),y
.8e91		c8		iny				iny
.8e92		c9 3b		cmp #$3b			cmp 	#KWD_SEMICOLON				; is it a semicolon
.8e94		f0 45		beq $8edb			beq 	_CPContinueWithSameLine
.8e96		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; comma
.8e98		f0 3c		beq $8ed6			beq 	_CPTab
.8e9a		c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; apostrophe (new line)
.8e9c		f0 34		beq $8ed2			beq 	_CPNewLine
.8e9e		88		dey				dey 								; undo the get.
.8e9f		20 71 9e	jsr $9e71			jsr 	EvaluateExpressionAt0 		; evaluate expression at 0.
.8ea2		b5 50		lda $50,x			lda 	NSStatus,x 					; read the status
.8ea4		29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.8ea6		f0 0d		beq $8eb5			beq 	_CPIsValue 					; no, display it.
.8ea8		ad 24 04	lda $0424			lda 	isPrintFlag 				; if print, dereference and print.
.8eab		d0 05		bne $8eb2			bne 	_CPIsPrint 					; otherwise display.
.8ead		20 e7 8e	jsr $8ee7			jsr 	CIInputValue 				; input a value to the reference
.8eb0		80 20		bra $8ed2			bra 	_CPNewLine
.8eb2						_CPIsPrint:
.8eb2		20 36 a1	jsr $a136			jsr 	Dereference 				; dereference if required.
.8eb5						_CPIsValue:
.8eb5		b5 50		lda $50,x			lda 	NSStatus,x 					; is it a number
.8eb7		29 10		and #$10			and 	#NSBIsString
.8eb9		f0 09		beq $8ec4			beq 	_CPNumber
.8ebb		a6 60		ldx $60				ldx 	NSMantissa1 				; string, print the text.
.8ebd		a5 58		lda $58				lda 	NSMantissa0
.8ebf		20 4a 8f	jsr $8f4a			jsr 	CPPrintStringXA
.8ec2		80 be		bra $8e82			bra 	Command_IP_Main 			; loop round clearing carry so NL if end
.8ec4						_CPNumber:
.8ec4		a9 05		lda #$05			lda 	#5 							; maximum decimals
.8ec6		20 fe a6	jsr $a6fe			jsr 	ConvertNumberToString 		; convert to string (in unary str$() function)
.8ec9		a2 06		ldx #$06			ldx 	#decimalBuffer >> 8
.8ecb		a9 45		lda #$45			lda 	#decimalBuffer & $FF
.8ecd		20 4a 8f	jsr $8f4a			jsr 	CPPrintStringXA 			; print it.
.8ed0		80 b0		bra $8e82			bra 	Command_IP_Main				; loop round clearing carry so NL if end
.8ed2						_CPNewLine:
.8ed2		a9 0d		lda #$0d			lda 	#13
.8ed4		80 02		bra $8ed8			bra 	_CPPrintCharDirect
.8ed6						_CPTab:
.8ed6		a9 09		lda #$09			lda 	#9 							; print TAB
.8ed8						_CPPrintCharDirect:
.8ed8		20 65 8f	jsr $8f65			jsr 	CPPVControl 				; print TAB/CR using the non PETSCII
.8edb						_CPContinueWithSameLine:
.8edb		38		sec				sec 								; loop round with carry set, which
.8edc		80 a5		bra $8e83			bra 	_CPLoop 					; will inhibit final CR
.8ede						_CPExit:
.8ede		28		plp				plp 								; get last action flag
.8edf		b0 05		bcs $8ee6			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.8ee1		a9 0d		lda #$0d			lda 	#13 						; print new line
.8ee3		20 65 8f	jsr $8f65			jsr 	CPPVControl
.8ee6						_CPExit2:
.8ee6		60		rts				rts
.8ee7						CIInputValue:
.8ee7		a2 00		ldx #$00			ldx 	#0 							; input a line.
.8ee9						_CIInputLine:
.8ee9		20 68 8f	jsr $8f68			jsr 	CPInputVector 				; get key
.8eec		c9 0d		cmp #$0d			cmp 	#13 						; 13 = End
.8eee		f0 1f		beq $8f0f			beq 	_CIHaveValue
.8ef0		c9 08		cmp #$08			cmp 	#8 							; 8 = BS
.8ef2		f0 11		beq $8f05			beq 	_CIBackspace
.8ef4		c9 20		cmp #$20			cmp 	#32 						; ignore other control characters
.8ef6		90 f1		bcc $8ee9			bcc 	_CIInputLine
.8ef8		e0 50		cpx #$50			cpx 	#80 						; max length
.8efa		b0 ed		bcs $8ee9			bcs 	_CIInputLine
.8efc		9d 26 05	sta $0526,x			sta 	lineBuffer,x
.8eff		e8		inx				inx
.8f00		20 43 80	jsr $8043			jsr 	EXTPrintCharacter 			; echo it.
.8f03		80 e4		bra $8ee9			bra 	_CIInputLine
.8f05						_CIBackspace:
.8f05		e0 00		cpx #$00			cpx 	#0 							; nothing to delete
.8f07		f0 e0		beq $8ee9			beq 	_CIInputLine
.8f09		20 43 80	jsr $8043			jsr 	EXTPrintCharacter 			; echo it.
.8f0c		ca		dex				dex
.8f0d		80 da		bra $8ee9			bra 	_CIInputLine
.8f0f						_CIHaveValue:
.8f0f		9e 26 05	stz $0526,x			stz 	lineBuffer,x 				; ASCIIZ string now in line buffer.
.8f12		a5 50		lda $50				lda 	NSStatus 					; was it a string assignment
.8f14		29 10		and #$10			and 	#NSBIsString
.8f16		f0 17		beq $8f2f			beq 	_CIAssignNumber 			; assign a number
.8f18		a2 01		ldx #$01			ldx 	#1
.8f1a		a9 26		lda #$26			lda 	#lineBuffer & $FF 			; set up to point to new string
.8f1c		95 58		sta $58,x			sta 	NSMantissa0,x
.8f1e		a9 05		lda #$05			lda 	#lineBuffer >> 8
.8f20		95 60		sta $60,x			sta 	NSMantissa1,x
.8f22		74 68		stz $68,x			stz 	NSMantissa2,x
.8f24		74 70		stz $70,x			stz 	NSMantissa3,x
.8f26		a9 10		lda #$10			lda 	#NSBIsString 				; so it becomes a string value
.8f28		95 50		sta $50,x			sta  	NSStatus,x
.8f2a		ca		dex				dex 								; X = 0
.8f2b		20 dd 8f	jsr $8fdd			jsr 	AssignVariable
.8f2e		60		rts				rts
.8f2f						_CIAssignNumber:
.8f2f		a9 26		lda #$26			lda 	#lineBuffer & $FF 			; set up to point to new string
.8f31		85 36		sta $36				sta 	zTemp0
.8f33		a9 05		lda #$05			lda 	#lineBuffer >> 8
.8f35		85 37		sta $37				sta 	zTemp0+1
.8f37		a2 01		ldx #$01			ldx 	#1 							; put in slot 1
.8f39		20 de a5	jsr $a5de			jsr 	ValEvaluateZTemp0 			; use the VAL() code
.8f3c		90 07		bcc $8f45			bcc 	_CIIsOkay
.8f3e		a9 3f		lda #$3f			lda 	#"?" 						; error ?
.8f40		20 5d 8f	jsr $8f5d			jsr 	CPPrintVector
.8f43		80 a2		bra $8ee7			bra 	CIInputValue
.8f45						_CIIsOkay:
.8f45		ca		dex				dex 								; X = 0
.8f46		20 dd 8f	jsr $8fdd			jsr 	AssignVariable
.8f49		60		rts				rts
.8f4a						CPPrintStringXA:
.8f4a		5a		phy				phy
.8f4b		86 37		stx $37				stx 	zTemp0+1
.8f4d		85 36		sta $36				sta 	zTemp0
.8f4f		a0 00		ldy #$00			ldy 	#0
.8f51						_PSXALoop:
.8f51		b1 36		lda ($36),y			lda 	(zTemp0),y
.8f53		f0 06		beq $8f5b			beq 	_PSXAExit
.8f55		20 5d 8f	jsr $8f5d			jsr 	CPPrintVector
.8f58		c8		iny				iny
.8f59		80 f6		bra $8f51			bra 	_PSXALoop
.8f5b						_PSXAExit:
.8f5b		7a		ply				ply
.8f5c		60		rts				rts
.8f5d						CPPrintVector:
.8f5d		2c 24 04	bit $0424			bit 	isPrintFlag 				; check if char only mode and call appropriate handler.
.8f60		30 03		bmi $8f65			bmi 	CPPVControl
.8f62		4c 4d 80	jmp $804d			jmp 	EXTPrintNoControl
.8f65						CPPVControl:
.8f65		4c 43 80	jmp $8043			jmp 	EXTPrintCharacter
.8f68						CPInputVector:
.8f68		4c 9b 81	jmp $819b			jmp 	KNLGetSingleCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/commands/joy.asm

.8f6b						UnaryJoyX:
.8f6b		18		clc				clc
.8f6c		80 01		bra $8f6f			bra 	JoyMain
.8f6e						UnaryJoyY:
.8f6e		38		sec				sec
.8f6f						JoyMain:
.8f6f		fa		plx				plx 								; get pos
.8f70		08		php				php 								; save carry (set for Y)
.8f71		20 64 a8	jsr $a864			jsr 	Evaluate8BitInteger 		; ignore the parameter
.8f74		20 50 99	jsr $9950			jsr 	CheckRightBracket
.8f77		20 04 84	jsr $8404			jsr 	KNLReadController 			; read the controller.
.8f7a		28		plp				plp
.8f7b		b0 02		bcs $8f7f			bcs 	_JMNoShift 					; if X then shift bits 3,2 -> 1,0
.8f7d		4a		lsr a				lsr 	a
.8f7e		4a		lsr a				lsr 	a
.8f7f						_JMNoShift:
.8f7f		4a		lsr a				lsr 	a 							; if bit 0 set then left/up e.g. -1
.8f80		b0 07		bcs $8f89			bcs 	JMIsLeft
.8f82		4a		lsr a				lsr 	a 							; if bit 1 set then right/down e.g. +1
.8f83		b0 07		bcs $8f8c			bcs 	JMIsRight
.8f85		20 c9 a8	jsr $a8c9			jsr 	NSMSetZero 					; zero result
.8f88		60		rts				rts
.8f89						JMIsLeft:
.8f89		4c dc 99	jmp $99dc			jmp 	ReturnTrue
.8f8c						JMIsRight:
.8f8c		a9 01		lda #$01			lda 	#1
.8f8e		20 cb a8	jsr $a8cb			jsr 	NSMSetByte
.8f91		60		rts				rts
.8f92						UnaryJoyB:
.8f92		fa		plx				plx 								; get pos
.8f93		20 64 a8	jsr $a864			jsr 	Evaluate8BitInteger 		; ignore the parameter
.8f96		20 50 99	jsr $9950			jsr 	CheckRightBracket
.8f99		20 04 84	jsr $8404			jsr 	KNLReadController 			; read the controller.
.8f9c		29 10		and #$10			and 	#$10
.8f9e		d0 e9		bne $8f89			bne 	JMIsLeft
.8fa0		20 c9 a8	jsr $a8c9			jsr 	NSMSetZero
.8fa3		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/let.asm

.8fa4						LetCommand:
.8fa4		a2 00		ldx #$00			ldx 	#0
.8fa6		b1 30		lda ($30),y			lda 	(codePtr),y
.8fa8		c9 b8		cmp #$b8			cmp 	#KWD_AT
.8faa		d0 14		bne $8fc0			bne 	_LCStandard
.8fac		c8		iny				iny 								; skip equal
.8fad		20 bd a2	jsr $a2bd			jsr 	EvaluateTerm 				; get a number (the address of the reference)
.8fb0		20 36 a1	jsr $a136			jsr 	Dereference 				; dereference it to a value
.8fb3		b5 50		lda $50,x			lda 	NSStatus,x 					; check integer
.8fb5		49 20		eor #$20			eor 	#NSBIsReference	 			; toggle reference
.8fb7		95 50		sta $50,x			sta 	NSStatus,x
.8fb9		29 20		and #$20			and 	#NSBIsReference 			; if it is now a reference, continue
.8fbb		d0 0f		bne $8fcc			bne 	_LCMain
.8fbd		4c 6f ab	jmp $ab6f			jmp 	TypeError 					; was a reference before.
.8fc0						_LCStandard:
.8fc0		ad 5b 9e	lda $9e5b			lda 	PrecedenceLevel+"*"			; precedence > this
.8fc3		20 75 9e	jsr $9e75			jsr 	EvaluateExpressionAtPrecedence
.8fc6		b5 50		lda $50,x			lda 	NSStatus,x 					; is it a reference to an array marked as procedure ?
.8fc8		c9 38		cmp #$38			cmp		#NSTProcedure+NSBIsReference
.8fca		f0 0e		beq $8fda			beq 	_LetGoProc 					; it's a procedure call.
.8fcc						_LCMain:
.8fcc		a9 3d		lda #$3d			lda 	#"=" 						; check =
.8fce		20 60 99	jsr $9960			jsr 	CheckNextA
.8fd1		e8		inx				inx 								; RHS
.8fd2		20 0e a8	jsr $a80e			jsr 	EvaluateValue
.8fd5		ca		dex				dex
.8fd6		20 dd 8f	jsr $8fdd			jsr 	AssignVariable
.8fd9		60		rts				rts
.8fda						_LetGoProc:
.8fda		4c 7a 93	jmp $937a			jmp 	CallProcedure
.8fdd						AssignVariable:
.8fdd		b5 50		lda $50,x			lda 	NSStatus,x 					; check the string/number type bits match
.8fdf		48		pha				pha 								; save a copy
.8fe0		55 51		eor $51,x			eor 	NSStatus+1,x
.8fe2		29 10		and #$10			and 	#NSBIsString
.8fe4		d0 0b		bne $8ff1			bne 	_ASError
.8fe6		68		pla				pla 								; get back
.8fe7		29 10		and #$10			and 	#NSBIsString 				; check type
.8fe9		d0 03		bne $8fee			bne 	_ASString
.8feb		4c 74 a0	jmp $a074			jmp 	AssignNumber
.8fee						_ASString:
.8fee		4c d2 a0	jmp $a0d2			jmp 	AssignString
.8ff1						_ASError:
.8ff1		4c 6f ab	jmp $ab6f			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/list.asm

.8ff4						Command_List:
.8ff4		9c 22 04	stz $0422			stz 	listIndent 					; reset indent.
.8ff7		a9 3f		lda #$3f			lda 	#$3F 						; silence at list.
.8ff9		20 6b 80	jsr $806b			jsr 	SNDCommand
.8ffc		b1 30		lda ($30),y			lda 	(codePtr),y
.8ffe		29 c0		and #$c0			and 	#$C0 				 		; if so, we are list procedure() which is a seperate block
.9000		c9 40		cmp #$40			cmp 	#$40  						; of code.
.9002		f0 72		beq $9076			beq 	_CLListProcedure
.9004		64 5c		stz $5c				stz		NSMantissa0+4				; set the lower (slot 4) to 0 and upper (slot 7) to $FFFF
.9006		64 64		stz $64				stz 	NSMantissa1+4 				; these are the default top and bottom.
.9008		a9 ff		lda #$ff			lda 	#$FF
.900a		85 5f		sta $5f				sta 	NSMantissa0+7
.900c		85 67		sta $67				sta 	NSMantissa1+7
.900e		b1 30		lda ($30),y			lda 	(codePtr),y
.9010		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.9012		f0 1a		beq $902e			beq 	_CLSecond
.9014		20 f3 90	jsr $90f3			jsr 	CLIsDigit 					; if not digit, list all
.9017		b0 20		bcs $9039			bcs 	_CLStart
.9019		a2 04		ldx #$04			ldx 	#4 							; get 1st range into slot 4
.901b		20 49 a8	jsr $a849			jsr 	Evaluate16BitInteger
.901e		b1 30		lda ($30),y			lda 	(codePtr),y
.9020		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.9022		f0 0a		beq $902e			beq 	_CLSecond 					; if so go get it
.9024		a5 5c		lda $5c				lda 	NSMantissa0+4 				; copy 4->7
.9026		85 5f		sta $5f				sta 	NSMantissa0+7
.9028		a5 64		lda $64				lda 	NSMantissa1+4
.902a		85 67		sta $67				sta 	NSMantissa1+7
.902c		80 0b		bra $9039			bra 	_CLStart
.902e						_CLSecond:
.902e		c8		iny				iny 								; consume comma
.902f		20 f3 90	jsr $90f3			jsr 	CLIsDigit 					; digit found
.9032		b0 05		bcs $9039			bcs 	_CLStart 					; if not, continue listing
.9034		a2 07		ldx #$07			ldx 	#7 							; load 2nd range into slot 7
.9036		20 49 a8	jsr $a849			jsr 	Evaluate16BitInteger
.9039						_CLStart
.9039		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.903b		85 30		sta $30				sta 	codePtr
.903d		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.903f		85 31		sta $31				sta 	codePtr+1
.9041						_CLLoop:
.9041		a5 f2		lda $f2				lda 	kernel.args.events.pending 	; load pending event count into accumulator
.9043		f0 03		beq $9048			beq 	_NoEvents					; if zero, skip with Z flag set.
.9045		20 2a 81	jsr $812a			jsr 	ProcessEvents
.9048						_NoEvents:
.9048		d0 27		bne $9071			bne 	_CLBreak
.904a		b2 30		lda ($30)			lda 	(codePtr)
.904c		f0 20		beq $906e			beq 	_CLExit
.904e		a2 04		ldx #$04			ldx 	#4 							; check range every time, line numbers aren't in order.
.9050		20 e2 90	jsr $90e2			jsr 	CLCompareLineNo
.9053		90 0c		bcc $9061			bcc 	_CLNext
.9055		a2 07		ldx #$07			ldx 	#7
.9057		20 e2 90	jsr $90e2			jsr 	CLCompareLineNo
.905a		f0 02		beq $905e			beq 	_CLDoThisOne
.905c		b0 03		bcs $9061			bcs 	_CLNext
.905e						_CLDoThisOne:
.905e		20 cf 90	jsr $90cf			jsr 	CLListOneLine 				; routine to list the current line.
.9061						_CLNext:
.9061		18		clc				clc
.9062		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.9064		65 30		adc $30				adc 	codePtr
.9066		85 30		sta $30				sta 	codePtr
.9068		90 02		bcc $906c			bcc 	_CREExit
.906a		e6 31		inc $31				inc 	codePtr+1 					; carry
.906c						_CREExit:
.906c		80 d3		bra $9041			bra 	_CLLoop
.906e						_CLExit:
.906e		4c 6c 87	jmp $876c			jmp 	WarmStart
.9071						_CLBreak:
.9071		a9 01		lda #$01		lda	#1
.9073		4c 69 99	jmp $9969		jmp	ErrorHandler
.9076						_CLListProcedure:
.9076		b1 30		lda ($30),y			lda 	(codePtr),y
.9078		85 38		sta $38				sta 	zTemp1
.907a		c8		iny				iny
.907b		b1 30		lda ($30),y			lda 	(codePtr),y
.907d		85 39		sta $39				sta 	zTemp1+1
.907f		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.9081		85 30		sta $30				sta 	codePtr
.9083		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.9085		85 31		sta $31				sta 	codePtr+1
.9087						_CLLPSearch:
.9087		b2 30		lda ($30)			lda 	(codePtr)
.9089		c9 00		cmp #$00			cmp 	#0 							; if zero, end
.908b		f0 e1		beq $906e			beq 	_CLExit
.908d		a0 03		ldy #$03			ldy 	#3 							; check if PROC something
.908f		b1 30		lda ($30),y			lda 	(codePtr),y
.9091		c9 af		cmp #$af			cmp 	#KWD_PROC
.9093		d0 0e		bne $90a3			bne 	_CLLPNext
.9095		c8		iny				iny 								; check if PROC this.
.9096		b1 30		lda ($30),y			lda 	(codePtr),y
.9098		c5 38		cmp $38				cmp 	zTemp1 						; does it match ?
.909a		d0 07		bne $90a3			bne 	_CLLPNext
.909c		c8		iny				iny
.909d		b1 30		lda ($30),y			lda 	(codePtr),y
.909f		c5 39		cmp $39				cmp 	zTemp1+1
.90a1		f0 0d		beq $90b0			beq 	_CLLPFound
.90a3						_CLLPNext:
.90a3		18		clc				clc
.90a4		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.90a6		65 30		adc $30				adc 	codePtr
.90a8		85 30		sta $30				sta 	codePtr
.90aa		90 02		bcc $90ae			bcc 	_CREExit
.90ac		e6 31		inc $31				inc 	codePtr+1 					; carry
.90ae						_CREExit:
.90ae		80 d7		bra $9087			bra 	_CLLPSearch
.90b0						_CLLPFound:
.90b0		b2 30		lda ($30)			lda 	(codePtr)
.90b2		f0 ba		beq $906e			beq 	_CLExit
.90b4		a0 03		ldy #$03			ldy 	#3 							; get first keyword
.90b6		b1 30		lda ($30),y			lda 	(codePtr),y
.90b8		48		pha				pha
.90b9		20 cf 90	jsr $90cf			jsr 	CLListOneLine 				; list line and go forward
.90bc		18		clc				clc
.90bd		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.90bf		65 30		adc $30				adc 	codePtr
.90c1		85 30		sta $30				sta 	codePtr
.90c3		90 02		bcc $90c7			bcc 	_CREExit
.90c5		e6 31		inc $31				inc 	codePtr+1 					; carry
.90c7						_CREExit:
.90c7		68		pla				pla 								; reached ENDPROC ?
.90c8		c9 b3		cmp #$b3			cmp 	#KWD_ENDPROC
.90ca		d0 e4		bne $90b0			bne 	_CLLPFound
.90cc		4c 6c 87	jmp $876c			jmp 	WarmStart
.90cf						CLListOneLine:
.90cf		20 0e 99	jsr $990e			jsr 	ScanGetCurrentLineStep 		; get indent adjust.
.90d2		20 7f 80	jsr $807f			jsr 	TKListConvertLine 			; convert line into token Buffer
.90d5		a2 04		ldx #$04			ldx 	#(tokenBuffer >> 8) 		; print that line
.90d7		a9 29		lda #$29			lda 	#(tokenBuffer & $FF)
.90d9		20 c8 99	jsr $99c8			jsr 	PrintStringXA
.90dc		a9 0d		lda #$0d			lda 	#13 						; new line
.90de		20 43 80	jsr $8043			jsr 	EXTPrintCharacter
.90e1		60		rts				rts
.90e2						CLCompareLineNo:
.90e2		38		sec				sec
.90e3		a0 01		ldy #$01			ldy 	#1
.90e5		b1 30		lda ($30),y			lda 	(codePtr),y
.90e7		f5 58		sbc $58,x			sbc 	NSMantissa0,x
.90e9		85 36		sta $36				sta 	zTemp0
.90eb		c8		iny				iny
.90ec		b1 30		lda ($30),y			lda 	(codePtr),y
.90ee		f5 60		sbc $60,x			sbc 	NSMantissa1,x
.90f0		05 36		ora $36				ora 	zTemp0
.90f2		60		rts				rts
.90f3						CLIsDigit:
.90f3		b1 30		lda ($30),y			lda 	(codePtr),y
.90f5		c9 30		cmp #$30			cmp 	#"0"
.90f7		90 03		bcc $90fc			bcc	 	_CLIDExitFalse
.90f9		c9 3a		cmp #$3a			cmp 	#"9"+1
.90fb		60		rts				rts
.90fc						_CLIDExitFalse:
.90fc		38		sec				sec
.90fd		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/local.asm

.90fe						Command_LOCAL:
.90fe		a2 00		ldx #$00			ldx 	#0 							; at level 0
.9100		20 0c 91	jsr $910c			jsr 	LocaliseNextTerm 			; convert term to a local.
.9103		b1 30		lda ($30),y			lda 	(codePtr),y
.9105		c8		iny				iny
.9106		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.9108		f0 f4		beq $90fe			beq 	Command_LOCAL 				; if so, localise another variable.
.910a		88		dey				dey 								; unpick pre-get
.910b		60		rts				rts
.910c						LocaliseNextTerm:
.910c		20 bd a2	jsr $a2bd			jsr 	EvaluateTerm 				; evaluate the term
.910f		b5 50		lda $50,x			lda 	NSStatus,x
.9111		29 20		and #$20			and 	#NSBIsReference 			; check it is a reference, must be a variable.
.9113		f0 5c		beq $9171			beq		_LNTError
.9115		b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address of variable to zTemp0
.9117		85 36		sta $36				sta 	zTemp0
.9119		b5 60		lda $60,x			lda 	NSMantissa1,x
.911b		85 37		sta $37				sta  	zTemp0+1
.911d		b5 50		lda $50,x			lda 	NSStatus,x 					; figure out what it is.
.911f		29 10		and #$10			and 	#NSBIsString
.9121		d0 1e		bne $9141			bne 	_LNTPushString
.9123		5a		phy				phy
.9124		a0 00		ldy #$00			ldy 	#0 							; push 0 to 4 inclusive, the number values, on the stack, and zero them as you go.
.9126						_LNTPushNumLoop:
.9126		b1 36		lda ($36),y			lda		(zTemp0),y
.9128		20 be b1	jsr $b1be			jsr 	StackPushByte
.912b		c8		iny				iny
.912c		c0 05		cpy #$05			cpy 	#5
.912e		d0 f6		bne $9126			bne 	_LNTPushNumLoop
.9130		a5 36		lda $36				lda 	zTemp0 						; push the actual target address to write on the stack
.9132		20 be b1	jsr $b1be			jsr 	StackPushByte
.9135		a5 37		lda $37				lda 	zTemp0+1
.9137		20 be b1	jsr $b1be			jsr 	StackPushByte
.913a		a9 01		lda #$01			lda 	#STK_LOCALN 				; push local-number marker.
.913c		20 be b1	jsr $b1be			jsr 	StackPushByte
.913f		7a		ply				ply
.9140		60		rts				rts
.9141						_LNTPushString:
.9141		5a		phy				phy
.9142		b2 36		lda ($36)			lda 	(zTemp0) 					; put address of string in zTemp1
.9144		85 38		sta $38				sta 	zTemp1
.9146		a0 01		ldy #$01			ldy 	#1
.9148		b1 36		lda ($36),y			lda 	(zTemp0),y
.914a		85 39		sta $39				sta 	zTemp1+1
.914c		a0 00		ldy #$00			ldy 	#0 							; output string
.914e		c9 00		cmp #$00			cmp 	#0 							; if not assigned string
.9150		f0 0a		beq $915c			beq 	_LNTStringOut
.9152						_LNTPushStrLoop:
.9152		b1 38		lda ($38),y			lda 	(zTemp1),y
.9154		f0 06		beq $915c			beq 	_LNTStringOut
.9156		20 be b1	jsr $b1be			jsr 	StackPushByte
.9159		c8		iny				iny
.915a		80 f6		bra $9152			bra 	_LNTPushStrLoop
.915c						_LNTStringOut:
.915c		98		tya				tya									; output length (chars written).
.915d		20 be b1	jsr $b1be			jsr 	StackPushByte
.9160		b5 58		lda $58,x			lda 	NSMantissa0,x 				; output address of the string record *not* the string itself
.9162		20 be b1	jsr $b1be			jsr 	StackPushByte
.9165		b5 60		lda $60,x			lda 	NSMantissa1,x
.9167		20 be b1	jsr $b1be			jsr 	StackPushByte
.916a		a9 02		lda #$02			lda 	#STK_LOCALS 				; push local-string marker.
.916c		20 be b1	jsr $b1be			jsr 	StackPushByte
.916f		7a		ply				ply
.9170		60		rts				rts
.9171						_LNTError:
.9171		4c 65 ab	jmp $ab65			jmp 	SyntaxError
.9174						LocalPopValue:
.9174		20 d6 b1	jsr $b1d6			jsr 	StackPopByte
.9177		c9 01		cmp #$01			cmp 	#STK_LOCALN 				; if not local-N
.9179		d0 17		bne $9192			bne 	_LPVString
.917b		20 d6 b1	jsr $b1d6			jsr 	StackPopByte 				; address
.917e		85 37		sta $37				sta 	zTemp0+1
.9180		20 d6 b1	jsr $b1d6			jsr 	StackPopByte
.9183		85 36		sta $36				sta 	zTemp0
.9185		5a		phy				phy
.9186		a0 04		ldy #$04			ldy 	#4 							; copy back
.9188						_LPVNumberCopy:
.9188		20 d6 b1	jsr $b1d6			jsr 	StackPopByte
.918b		91 36		sta ($36),y			sta 	(zTemp0),y
.918d		88		dey				dey
.918e		10 f8		bpl $9188			bpl 	_LPVNumberCopy
.9190		7a		ply				ply 								; and complete
.9191		60		rts				rts
.9192						_LPVString:
.9192		20 d6 b1	jsr $b1d6			jsr 	StackPopByte 				; address of record copied to zTemp0
.9195		85 37		sta $37				sta 	zTemp0+1
.9197		20 d6 b1	jsr $b1d6			jsr 	StackPopByte
.919a		85 36		sta $36				sta 	zTemp0
.919c		5a		phy				phy
.919d		b2 36		lda ($36)			lda 	(zTemp0) 					; address to write string to copied to zTemp1
.919f		85 38		sta $38				sta 	zTemp1
.91a1		a0 01		ldy #$01			ldy 	#1
.91a3		b1 36		lda ($36),y			lda 	(zTemp0),y
.91a5		85 39		sta $39				sta 	zTemp1+1
.91a7		20 d6 b1	jsr $b1d6			jsr 	StackPopByte 				; # chars to get => y
.91aa		a8		tay				tay
.91ab		a5 39		lda $39				lda 	zTemp1+1 					; if no target (e.g. was "" originally) exit
.91ad		f0 0e		beq $91bd			beq 	_LPVStringCopied
.91af		a9 00		lda #$00			lda 	#0 							; NULL on end
.91b1		91 38		sta ($38),y			sta 	(zTemp1),y
.91b3						_LPVStringCopy:
.91b3		88		dey				dey
.91b4		30 07		bmi $91bd			bmi 	_LPVStringCopied
.91b6		20 d6 b1	jsr $b1d6			jsr 	StackPopByte
.91b9		91 38		sta ($38),y			sta 	(zTemp1),y
.91bb		80 f6		bra $91b3			bra 	_LPVStringCopy
.91bd						_LPVStringCopied:
.91bd		fa		plx				plx
.91be		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/commands/memcopy.asm

.91bf						MCCommand:
.91bf		a5 01		lda $01				lda 	1 							; save current I/O ; switch to I/O 0
.91c1		48		pha				pha
.91c2		64 01		stz $01				stz 	1
.91c4		9c 00 df	stz $df00			stz 	$DF00 						; zero control byte.
.91c7		a9 81		lda #$81			lda 	#$81 						; standard start byte (DMA Enabled, Start set)
.91c9		8d a2 07	sta $07a2			sta 	DMAControlByte
.91cc		20 7a 92	jsr $927a			jsr 	MCPosition 					; start position
.91cf		a2 04		ldx #$04			ldx 	#4 							; write to source AND $DF04 destination address $DF08
.91d1		20 4b 92	jsr $924b			jsr 	MCCopyAddress
.91d4		a2 08		ldx #$08			ldx 	#8
.91d6		20 4b 92	jsr $924b			jsr 	MCCopyAddress
.91d9		b1 30		lda ($30),y			lda 	(codePtr),y
.91db		c8		iny				iny
.91dc		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; , <size>
.91de		f0 09		beq $91e9			beq 	_MCSize1D
.91e0		c9 d5		cmp #$d5			cmp 	#KWD_RECT 					; RECT <x>,<y>
.91e2		f0 11		beq $91f5			beq 	_MCRect2D
.91e4						_MCSyntax:
.91e4		a9 02		lda #$02		lda	#2
.91e6		4c 69 99	jmp $9969		jmp	ErrorHandler
.91e9						_MCSize1D:
.91e9		a2 00		ldx #$00			ldx 	#0 							; get size
.91eb		20 36 a8	jsr $a836			jsr 	EvaluateInteger
.91ee		a2 0c		ldx #$0c			ldx 	#$C 						; copy to size $DF0C-E
.91f0		20 4b 92	jsr $924b			jsr 	MCCopyAddress
.91f3		80 24		bra $9219			bra 	_MCDestination
.91f5						_MCRect2D:
.91f5		a2 0c		ldx #$0c			ldx 	#$C 						; width to $DF0C,D
.91f7		20 68 92	jsr $9268			jsr 	MCEvalCopyData16
.91fa		20 58 99	jsr $9958			jsr 	CheckComma
.91fd		a2 0e		ldx #$0e			ldx 	#$E 						; height to $DF0E,F
.91ff		20 68 92	jsr $9268			jsr 	MCEvalCopyData16
.9202		a9 b9		lda #$b9			lda 	#KWD_BY 					; BY keyword.
.9204		20 60 99	jsr $9960			jsr 	CheckNextA
.9207		a2 10		ldx #$10			ldx 	#$10 						; store source and destination stride
.9209		20 68 92	jsr $9268			jsr 	MCEvalCopyData16
.920c		a2 12		ldx #$12			ldx 	#$12
.920e		20 6f 92	jsr $926f			jsr 	MCCopyData16
.9211		ad a2 07	lda $07a2			lda 	DMAControlByte 				; set bit 4 of DMA control indicating 2D.
.9214		09 02		ora #$02			ora 	#$02
.9216		8d a2 07	sta $07a2			sta 	DMAControlByte
.9219						_MCDestination:
.9219		b1 30		lda ($30),y			lda 	(codePtr),y
.921b		c8		iny				iny
.921c		c9 d0		cmp #$d0			cmp 	#KWD_POKE 					; is it POKE n
.921e		f0 0e		beq $922e			beq 	_MCDestPoke
.9220		c9 db		cmp #$db			cmp 	#KWD_TO 					; is it TO n
.9222		d0 c0		bne $91e4			bne 	_MCSyntax
.9224		20 7a 92	jsr $927a			jsr 	MCPosition 					; get target address
.9227		a2 08		ldx #$08			ldx 	#8							; copy to target address at $DF08-A
.9229		20 4b 92	jsr $924b			jsr 	MCCopyAddress
.922c		80 0e		bra $923c			bra 	_MCDoDMA 					; and we can go.
.922e						_MCDestPoke:
.922e		20 64 a8	jsr $a864			jsr 	Evaluate8BitInteger 		; POKE what
.9231		8d 01 df	sta $df01			sta 	$DF01 						; set the FILL register
.9234		ad a2 07	lda $07a2			lda 	DMAControlByte 				; set bit 2 of control byte indicating FILL.
.9237		09 04		ora #$04			ora 	#$04
.9239		8d a2 07	sta $07a2			sta 	DMAControlByte
.923c						_MCDoDMA:
.923c		ad a2 07	lda $07a2			lda 	DMAControlByte 				; set the DMA Control byte to go !
.923f		8d 00 df	sta $df00			sta 	$DF00
.9242						_MCWaitBUSD:
.9242		ad 01 df	lda $df01			lda 	$DF01
.9245		30 fb		bmi $9242			bmi 	_MCWaitBUSD
.9247		68		pla				pla 								; restore I/O.
.9248		85 01		sta $01				sta 	1
.924a		60		rts				rts
.924b						MCCopyAddress:
.924b		a5 68		lda $68				lda 	NSMantissa2 				; check valid vlaue
.924d		29 fc		and #$fc			and 	#$FC
.924f		05 70		ora $70				ora 	NSMantissa3
.9251		d0 10		bne $9263			bne 	_MCRange
.9253		a5 58		lda $58				lda 	NSMantissa0
.9255		9d 00 df	sta $df00,x			sta 	$DF00,x
.9258		a5 60		lda $60				lda 	NSMantissa1
.925a		9d 01 df	sta $df01,x			sta 	$DF01,x
.925d		a5 68		lda $68				lda 	NSMantissa2
.925f		9d 02 df	sta $df02,x			sta 	$DF02,x
.9262		60		rts				rts
.9263						_MCRange:
.9263		a9 04		lda #$04		lda	#4
.9265		4c 69 99	jmp $9969		jmp	ErrorHandler
.9268						MCEvalCopyData16:
.9268		da		phx				phx
.9269		a2 00		ldx #$00			ldx 	#0
.926b		20 49 a8	jsr $a849			jsr 	Evaluate16BitInteger
.926e		fa		plx				plx
.926f						MCCopyData16:
.926f		a5 58		lda $58				lda 	NSMantissa0
.9271		9d 00 df	sta $df00,x			sta 	$DF00,x
.9274		a5 60		lda $60				lda 	NSMantissa1
.9276		9d 01 df	sta $df01,x			sta 	$DF01,x
.9279		60		rts				rts
.927a						MCPosition:
.927a		a2 00		ldx #$00			ldx 	#0 							; get start address.
.927c		b1 30		lda ($30),y			lda 	(codePtr),y
.927e		c9 b8		cmp #$b8			cmp 	#KWD_AT
.9280		f0 04		beq $9286			beq 	_MCPAt
.9282		20 36 a8	jsr $a836			jsr 	EvaluateInteger
.9285		60		rts				rts
.9286						_MCPAt:
.9286		c8		iny				iny
.9287		20 64 a8	jsr $a864			jsr 	Evaluate8BitInteger 		; X position
.928a		48		pha				pha
.928b		20 58 99	jsr $9958			jsr 	CheckComma
.928e		e8		inx				inx
.928f		20 64 a8	jsr $a864			jsr 	Evaluate8BitInteger 		; Y position
.9292		ca		dex				dex
.9293		85 60		sta $60				sta 	NSMantissa1 				; put Y x 64 in Mantissa.0
.9295		64 58		stz $58				stz 	NSMantissa0
.9297		64 68		stz $68				stz 	NSMantissa2
.9299		64 70		stz $70				stz 	NSMantissa3
.929b		46 60		lsr $60				lsr 	NSMantissa1
.929d		66 58		ror $58				ror 	NSMantissa0
.929f		46 60		lsr $60				lsr 	NSMantissa1
.92a1		66 58		ror $58				ror 	NSMantissa0
.92a3		68		pla				pla
.92a4		18		clc				clc
.92a5		65 58		adc $58				adc 	NSMantissa0 				; add X, Y * 256 and the
.92a7		85 58		sta $58				sta 	NSMantissa0
.92a9		a5 60		lda $60				lda 	NSMantissa1
.92ab		65 59		adc $59				adc 	NSMantissa0+1
.92ad		85 60		sta $60				sta 	NSMantissa1
.92af		90 02		bcc $92b3			bcc 	_MCPNoCarry
.92b1		e6 68		inc $68				inc 	NSMantissa2
.92b3						_MCPNoCarry:
.92b3		ad cb 07	lda $07cb			lda 	gxBasePage
.92b6		85 69		sta $69				sta 	NSMantissa2+1
.92b8		64 59		stz $59				stz 	NSMantissa0+1
.92ba		64 61		stz $61				stz 	NSMantissa1+1
.92bc		64 71		stz $71				stz 	NSMantissa3+1
.92be		a2 01		ldx #$01			ldx 	#1
.92c0		20 e2 a8	jsr $a8e2			jsr 	NSMShiftRight
.92c3		20 e2 a8	jsr $a8e2			jsr 	NSMShiftRight
.92c6		20 e2 a8	jsr $a8e2			jsr 	NSMShiftRight
.92c9		a2 00		ldx #$00			ldx 	#0
.92cb		20 69 9c	jsr $9c69			jsr 	AddTopTwoStack
.92ce		60		rts				rts
.07a2						DMAControlByte:
>07a2								.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/commands/mouse.asm

.92cf						MouseStatus:
.92cf		a2 00		ldx #$00	        ldx     #0
.92d1						_MouseCommandLoop:
.92d1		da		phx		        phx                                 ; save slot.
.92d2		20 71 9e	jsr $9e71	        jsr     EvaluateExpressionAt0       ; evaluate a reference.
.92d5		a5 50		lda $50		        lda     NSStatus                    ; check it's a reference.
.92d7		c9 20		cmp #$20	        cmp     #NSBIsReference
.92d9		d0 4d		bne $9328	        bne     _MouseNotRef
.92db		b1 30		lda ($30),y			lda 	(codePtr),y
.92dd		c9 2c		cmp #$2c	        cmp     #KWD_COMMA
.92df		d0 01		bne $92e2	        bne     _MouseNoSkipComma
.92e1		c8		iny		        iny
.92e2						_MouseNoSkipComma:
.92e2		fa		plx		        plx                                 ; restore X
.92e3		5a		phy		        phy                                 ; save Y
.92e4		a5 58		lda $58		        lda     NSMantissa0                 ; copy address to zTemp0
.92e6		85 36		sta $36		        sta     zTemp0
.92e8		a5 60		lda $60		        lda     NSMantissa1
.92ea		85 37		sta $37		        sta     zTemp0+1
.92ec		a0 04		ldy #$04	        ldy     #4                          ; set exponent, m3, m2 , m1 , m0
.92ee		a9 00		lda #$00	        lda     #0
.92f0		91 36		sta ($36),y	        sta     (zTemp0),y                  ; exponent
.92f2		88		dey		        dey
.92f3		91 36		sta ($36),y	        sta     (zTemp0),y                  ; m3
.92f5		88		dey		        dey
.92f6		91 36		sta ($36),y	        sta     (zTemp0),y                  ; m2
.92f8		88		dey		        dey
.92f9		bd 81 06	lda $0681,x	        lda     MouseDeltaX,x
.92fc		92 36		sta ($36)	        sta     (zTemp0)                    ; m0
.92fe		bd 82 06	lda $0682,x	        lda     MouseDeltaX+1,x
.9301		91 36		sta ($36),y	        sta     (zTemp0),y                  ; m1
.9303		10 15		bpl $931a	        bpl     _MouseDataPos               ; signed 16 bit value, so fix up if -ve.
.9305		38		sec		        sec                                 ; negate the mantissa 2 bytes
.9306		a9 00		lda #$00	        lda     #0
.9308		f2 36		sbc ($36)	        sbc     (zTemp0)
.930a		92 36		sta ($36)	        sta     (zTemp0)
.930c		a9 00		lda #$00	        lda     #0
.930e		f1 36		sbc ($36),y	        sbc     (zTemp0),y
.9310		91 36		sta ($36),y	        sta     (zTemp0),y
.9312		a0 03		ldy #$03	        ldy     #3
.9314		b1 36		lda ($36),y	        lda     (zTemp0),y                  ; set upper bit of mantissa
.9316		09 80		ora #$80	        ora     #$80
.9318		91 36		sta ($36),y	        sta     (zTemp0),y
.931a						_MouseDataPos:
.931a		7a		ply		        ply                                 ; restore Y.
.931b		9e 81 06	stz $0681,x	        stz     MouseDeltaX,x               ; clear entry in current table
.931e		9e 82 06	stz $0682,x	        stz     MouseDeltaX+1,x
.9321		e8		inx		        inx                                 ; next entry
.9322		e8		inx		        inx
.9323		e0 0c		cpx #$0c	        cpx     #6*2                        ; done 6 reads to variables.
.9325		d0 aa		bne $92d1	        bne     _MouseCommandLoop
.9327		60		rts		        rts
.9328						_MouseNotRef:
.9328		a9 07		lda #$07		lda	#7
.932a		4c 69 99	jmp $9969		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/new.asm

.932d						NewCommand:
.932d		20 33 93	jsr $9333			jsr 	NewProgram 					; does the actual NEW.
.9330		4c 6c 87	jmp $876c			jmp 	WarmStart 					; and warm starts straight away.
.9333						NewProgram:
.9333		20 df ad	jsr $addf			jsr 	MemoryNew
.9336		9c 00 10	stz $1000			stz 	VariableSpace 				; erase all variables.
.9339		20 f8 97	jsr $97f8			jsr 	ClearSystem					; clear everything.
.933c		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/poke.asm

.933d						PokeBCommand:
.933d		a9 01		lda #$01			lda 	#1
.933f		80 0c		bra $934d			bra 	PokeCommand
.9341						PokeWCommand:
.9341		a9 02		lda #$02			lda 	#2
.9343		80 08		bra $934d			bra 	PokeCommand
.9345						PokeLCommand:
.9345		a9 03		lda #$03			lda 	#3
.9347		80 04		bra $934d			bra 	PokeCommand
.9349						PokeDCommand:
.9349		a9 04		lda #$04			lda 	#4
.934b		80 00		bra $934d			bra 	PokeCommand
.934d						PokeCommand:
.934d		48		pha				pha 								; save count on stack
.934e		a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.9350		20 49 a8	jsr $a849			jsr		Evaluate16BitInteger 		; address
.9353		20 58 99	jsr $9958			jsr 	CheckComma
.9356		e8		inx				inx
.9357		20 36 a8	jsr $a836			jsr		EvaluateInteger 			; data
.935a		a5 58		lda $58				lda 	NSMantissa0 				; copy address
.935c		85 36		sta $36				sta 	zTemp0
.935e		a5 60		lda $60				lda 	NSMantissa1
.9360		85 37		sta $37				sta 	zTemp0+1
.9362		68		pla				pla 								; count -> zTemp1
.9363		85 38		sta $38				sta 	zTemp1
.9365		5a		phy				phy 								; save Y position.
.9366		a0 00		ldy #$00			ldy 	#0 							; index to write
.9368		a2 00		ldx #$00			ldx 	#0 							; index to read
.936a						_PCLoop:
.936a		b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; read byte from mantissa and copy out
.936c		91 36		sta ($36),y			sta 	(zTemp0),y
.936e		c8		iny				iny 								; next byte to write
.936f		8a		txa				txa 								; next byte to read - stack layout in 04data.inc
.9370		18		clc				clc
.9371		69 08		adc #$08			adc 	#MathStackSize
.9373		aa		tax				tax
.9374		c6 38		dec $38				dec 	zTemp1 						; done them all
.9376		d0 f2		bne $936a			bne 	_PCLoop
.9378		7a		ply				ply 								; restore position.
.9379		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/procedure.asm

=2						ParameterStackPos = 2
.937a						CallProcedure:
.937a		a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start storing parameters at 2.
.937c		b1 30		lda ($30),y			lda 	(codePtr),y
.937e		c9 29		cmp #$29			cmp 	#KWD_RPAREN
.9380		f0 0c		beq $938e			beq 	_CPEndParam
.9382						_CPParamLoop:
.9382		20 0e a8	jsr $a80e			jsr 	EvaluateValue 				; get parameter onto stack
.9385		e8		inx				inx 								; bump next stack
.9386		b1 30		lda ($30),y			lda 	(codePtr),y
.9388		c8		iny				iny
.9389		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if comma, go back and try again.
.938b		f0 f5		beq $9382			beq 	_CPParamLoop
.938d		88		dey				dey 								; unpick.
.938e						_CPEndParam:
.938e		8e 12 04	stx $0412			stx 	lastParameter 				; save the last parameters index.
.9391		c8		iny				iny									; skip right bracket
.9392		a9 b3		lda #$b3			lda 	#STK_PROC+3 				; allocate 6 bytes on the return stack.
.9394		20 df b1	jsr $b1df			jsr 	StackOpen
.9397		20 24 b2	jsr $b224			jsr 	STKSaveCodePosition 		; save loop position
.939a		a5 58		lda $58				lda 	NSMantissa0 				; copy variable (e.g. procedure) address to zTemp0
.939c		85 36		sta $36				sta 	zTemp0 						; this is the DATA not the RECORD
.939e		a5 60		lda $60				lda 	NSMantissa1
.93a0		85 37		sta $37				sta 	zTemp0+1
.93a2		a0 01		ldy #$01			ldy 	#1 							; copy code address back.
.93a4		b2 36		lda ($36)			lda 	(zTemp0)
.93a6		85 30		sta $30				sta 	safePtr
.93a8		b1 36		lda ($36),y			lda 	(zTemp0),y
.93aa		85 31		sta $31				sta 	safePtr+1
.93ac		c8		iny				iny
.93ad		b1 36		lda ($36),y			lda 	(zTemp0),y
.93af		85 32		sta $32				sta 	safePtr+2
.93b1		c8		iny				iny
.93b2		b1 36		lda ($36),y			lda 	(zTemp0),y
.93b4		85 33		sta $33				sta 	safePtr+3
.93b6		c8		iny				iny 								; get Y offset -> Y
.93b7		b1 36		lda ($36),y			lda 	(zTemp0),y
.93b9		a8		tay				tay
.93ba		a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start position of parameters
.93bc		ec 12 04	cpx $0412			cpx	 	lastParameter 				; check zero parameters at the start
.93bf		f0 13		beq $93d4			beq 	_ParamExit 					; if so, exit.
.93c1						_ParamExtract:
.93c1		ca		dex				dex 								; put a local term on the level before
.93c2		20 0c 91	jsr $910c			jsr 	LocaliseNextTerm			; also pushes original param value to basic stack
.93c5		20 dd 8f	jsr $8fdd			jsr 	AssignVariable 				; assign stacked value to the variable.
.93c8		e8		inx				inx 								; advance to next parameter to do.
.93c9		e8		inx				inx
.93ca		ec 12 04	cpx $0412			cpx 	lastParameter 				; are we done ?
.93cd		f0 05		beq $93d4			beq 	_ParamExit
.93cf		20 58 99	jsr $9958			jsr 	CheckComma 					; comma seperating parameters
.93d2		80 ed		bra $93c1			bra 	_ParamExtract
.93d4						_ParamExit:
.93d4		20 50 99	jsr $9950			jsr 	CheckRightBracket 			; check )
.93d7		60		rts				rts 								; and continue from here
.93d8						Command_ENDPROC:
.93d8		a9 b0		lda #$b0			lda 	#STK_PROC 					; check TOS is this
.93da		a2 14		ldx #$14			ldx 	#ERRID_PROC
.93dc		20 0c b2	jsr $b20c			jsr 	StackCheckFrame
.93df		20 35 b2	jsr $b235			jsr 	STKLoadCodePosition 		; restore code position
.93e2		20 fe b1	jsr $b1fe			jsr 	StackClose
.93e5		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/read.asm

.93e6						Command_Read:
.93e6		a2 00		ldx #$00			ldx 	#0 							; evaluate the term which is the var/array element to assign
.93e8		20 bd a2	jsr $a2bd			jsr 	EvaluateTerm
.93eb		b5 50		lda $50,x			lda 	NSStatus,x
.93ed		29 20		and #$20			and 	#NSBIsReference				; get status byte on stack, identifies int, float, string.
.93ef		f0 4f		beq $9440			beq 	_CRSyntax 					; check reference (bit 0) fail if not a reference.
.93f1		20 89 94	jsr $9489			jsr 	SwapDataCodePtrs 			; swap code and data
.93f4		ad 18 04	lda $0418			lda 	inDataStatement 			; if in a data statement, we don't need to search
.93f7		d0 25		bne $941e			bne 	_CRContinueData  			; forward for the next one.
.93f9		b2 30		lda ($30)			lda 	(codePtr)
.93fb		f0 1c		beq $9419			beq 	_CRNoData
.93fd						_CRKeepSearching:
.93fd		a9 bf		lda #$bf			lda 	#KWD_DATA 					; scan for instruction
.93ff		a2 80		ldx #$80			ldx 	#KWC_EOL
.9401		20 ab 98	jsr $98ab			jsr 	ScanForward
.9404		c9 bf		cmp #$bf			cmp 	#KWD_DATA 					; found data ?
.9406		f0 16		beq $941e			beq 	_CRHaveData 				; found it
.9408		18		clc				clc
.9409		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.940b		65 30		adc $30				adc 	codePtr
.940d		85 30		sta $30				sta 	codePtr
.940f		90 02		bcc $9413			bcc 	_CREExit
.9411		e6 31		inc $31				inc 	codePtr+1 					; carry
.9413						_CREExit:
.9413		a0 03		ldy #$03			ldy 	#3 							; start of line.
.9415		b2 30		lda ($30)			lda 	(codePtr)
.9417		d0 e4		bne $93fd			bne 	_CRKeepSearching
.9419						_CRNoData:
.9419		a9 0b		lda #$0b		lda	#11
.941b		4c 69 99	jmp $9969		jmp	ErrorHandler
.941e						_CRHaveData:
.941e						_CRContinueData:
.941e		a2 01		ldx #$01			ldx 	#1
.9420		20 0e a8	jsr $a80e			jsr 	EvaluateValue 				; evaluate value into slot # 1
.9423		ca		dex				dex
.9424		20 dd 8f	jsr $8fdd			jsr		AssignVariable 				; do the assignment
.9427		9c 18 04	stz $0418			stz 	inDataStatement 			; clear in data flag
.942a		b1 30		lda ($30),y			lda 	(codePtr),y
.942c		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not, end of data statement and exit
.942e		d0 04		bne $9434			bne 	_CRSwapBack
.9430		c8		iny				iny 								; consume comma
.9431		ee 18 04	inc $0418			inc 	inDataStatement 			; set in data statement currently.
.9434						_CRSwapBack:
.9434		20 89 94	jsr $9489			jsr 	SwapDataCodePtrs			; swap them back.
.9437		b1 30		lda ($30),y			lda 	(codePtr),y
.9439		c8		iny				iny
.943a		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.943c		f0 a8		beq $93e6			beq 	Command_Read 				; if so go round again.
.943e		88		dey				dey 								; unpick get.
.943f		60		rts				rts
.9440						_CRSyntax:
.9440		4c 65 ab	jmp $ab65			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/rem.asm

.9443						RemCommand:
.9443		b1 30		lda ($30),y			lda 	(codePtr),y
.9445		c9 ff		cmp #$ff			cmp 	#KWC_STRING
.9447		d0 06		bne $944f			bne 	_RMExit
.9449		c8		iny				iny 								; point to offset
.944a		98		tya				tya 								; A = offset position
.944b		38		sec				sec 								; add size +1 hence SEC
.944c		71 30		adc ($30),y			adc 	(codePtr),y
.944e		a8		tay				tay 								; make current position.
.944f						_RMExit:
.944f		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/repeat.asm

.9450						Command_REPEAT:
.9450		a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; allocate 6 bytes on the return stack.
.9452		20 df b1	jsr $b1df			jsr 	StackOpen
.9455		20 24 b2	jsr $b224			jsr 	STKSaveCodePosition 		; save loop position
.9458		60		rts				rts
.9459						Command_UNTIL:
.9459		a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; check REPEAT is TOS
.945b		a2 0f		ldx #$0f			ldx 	#ERRID_REPEAT 				; this error
.945d		20 0c b2	jsr $b20c			jsr 	StackCheckFrame
.9460		a2 00		ldx #$00			ldx 	#0
.9462		20 17 a8	jsr $a817			jsr 	EvaluateNumber 				; work out the number
.9465		20 eb a8	jsr $a8eb			jsr 	NSMIsZero 					; check if zero
.9468		f0 04		beq $946e			beq 	_CULoopBack 				; if so keep looping
.946a		20 fe b1	jsr $b1fe			jsr 	StackClose		 			; return
.946d		60		rts				rts
.946e						_CULoopBack:
.946e		20 35 b2	jsr $b235			jsr 	STKLoadCodePosition 		; loop back
.9471		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/restore.asm

.9472						Command_Restore:
.9472		20 89 94	jsr $9489			jsr 	SwapDataCodePtrs 			; swap code and data
.9475		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.9477		85 30		sta $30				sta 	codePtr
.9479		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.947b		85 31		sta $31				sta 	codePtr+1
.947d		20 89 94	jsr $9489			jsr 	SwapDataCodePtrs 			; put them back
.9480		a9 03		lda #$03			lda 	#3 							; start at offset 3, e.g. first instruction of first line.
.9482		8d 17 04	sta $0417			sta 	dataPointer+4   			; (read checks not EOF)
.9485		9c 18 04	stz $0418			stz 	inDataStatement 			; not in data statement
.9488		60		rts				rts
.9489						SwapDataCodePtrs:
.9489		da		phx				phx
.948a		a2 03		ldx #$03			ldx 	#3 							; swap 32 bit code pointer over
.948c						_SDCPLoop:
.948c		b5 30		lda $30,x			lda 	safePtr,x
.948e		48		pha				pha
.948f		bd 13 04	lda $0413,x			lda 	dataPointer,x
.9492		95 30		sta $30,x			sta 	safePtr,x
.9494		68		pla				pla
.9495		9d 13 04	sta $0413,x			sta 	dataPointer,x
.9498		ca		dex				dex
.9499		10 f1		bpl $948c			bpl 	_SDCPLoop
.949b		ad 17 04	lda $0417			lda 	dataPointer+4 				; swap Y position over.
.949e		8c 17 04	sty $0417			sty 	dataPointer+4
.94a1		a8		tay				tay
.94a2		fa		plx				plx
.94a3		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/run.asm

.94a4						EOLCommand:
.94a4		18		clc				clc
.94a5		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.94a7		65 30		adc $30				adc 	codePtr
.94a9		85 30		sta $30				sta 	codePtr
.94ab		90 02		bcc $94af			bcc 	_CREExit
.94ad		e6 31		inc $31				inc 	codePtr+1 					; carry
.94af						_CREExit:
.94af		80 18		bra $94c9			bra 	RunNewLine
.94b1						CommandRUNOptLoad:
.94b1		b1 30		lda ($30),y			lda 	(codePtr),y
.94b3		c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL / : just RUN
.94b5		f0 07		beq $94be			beq 	RunCurrentProgram
.94b7		c9 3a		cmp #$3a			cmp 	#KWD_COLON
.94b9		f0 03		beq $94be			beq 	RunCurrentProgram
.94bb		20 5a 8b	jsr $8b5a			jsr 	LoadFile 					; load expected name file.
.94be						RunCurrentProgram:
.94be		20 f8 97	jsr $97f8			jsr 	ClearSystem 				; clear variable/stacks/etc.
.94c1		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.94c3		85 30		sta $30				sta 	codePtr
.94c5		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.94c7		85 31		sta $31				sta 	codePtr+1
.94c9						RunNewLine:
.94c9		b2 30		lda ($30)			lda 	(codePtr)
.94cb		f0 74		beq $9541			beq 	CRNoProgram         		; no then END.
.94cd		a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack
.94cf		9a		txs				txs
.94d0						RUNCodePointerLine:
.94d0		a0 02		ldy #$02			ldy 	#2 							; start of program
.94d2						_CRIncMainLoop:
.94d2		a5 f2		lda $f2				lda 	kernel.args.events.pending 	; load pending event count into accumulator
.94d4		f0 03		beq $94d9			beq 	_NoEvents					; if zero, skip with Z flag set.
.94d6		20 2a 81	jsr $812a			jsr 	ProcessEvents
.94d9						_NoEvents:
.94d9		d0 61		bne $953c			bne 	_CRBreak
.94db		a5 01		lda $01				lda 	1 							; save I/O 0
.94dd		48		pha				pha
.94de		64 01		stz $01				stz 	1 							; access I/O Page 0
.94e0		38		sec				sec 								; calculate timer - LastTick
.94e1		ad 59 d6	lda $d659			lda 	$D659
.94e4		cd 5e 06	cmp $065e			cmp 	LastTick
.94e7		f0 06		beq $94ef			beq 	_NoFireTick 				; if < 3 clocks don't fire.
.94e9		8d 5e 06	sta $065e			sta 	LastTick 					; update last timer
.94ec		20 4a 82	jsr $824a			jsr 	TickHandler 							; go do the code.
.94ef						_NoFireTick:
.94ef		68		pla				pla 								; restore I/O 0
.94f0		85 01		sta $01				sta 	1
.94f2						_CRNoBreakCheck:
.94f2		c8		iny				iny									; next token
.94f3						_CRMainLoop:
.94f3		9c 0c 04	stz $040c			stz 	stringInitialised 			; clear the temporary string initialised flag.
.94f6		b1 30		lda ($30),y			lda 	(codePtr),y
.94f8		10 10		bpl $950a			bpl 	_CRNotKeyword				; not a token.
.94fa		c9 ad		cmp #$ad			cmp 	#KWC_LAST_UNARY+1 			; if after unary, legitimate command
.94fc		b0 04		bcs $9502			bcs 	_CRIsKeyword
.94fe		c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if unary, syntax error.
.9500		b0 34		bcs $9536			bcs		_CRSyntaxError
.9502						_CRIsKeyword:
.9502		c8		iny				iny 								; consume command
.9503		0a		asl a				asl 	a 							; double losing the MSB which is '1' as tokens are $80-$FF
.9504		aa		tax				tax 								; put in X for vector jump
.9505		20 39 95	jsr $9539			jsr 	_CRCallVector0 				; call the vector - effectively jsr (vectortable,X)
.9508		80 e9		bra $94f3			bra 	_CRMainLoop 				; and loop round
.950a						_CRNotKeyword:
.950a		c9 3a		cmp #$3a			cmp 	#KWD_COLON 					; if a :, consume it and go round.
.950c		f0 c4		beq $94d2			beq 	_CRIncMainLoop
.950e		c9 40		cmp #$40			cmp 	#$40 						; variable/call reference
.9510		90 05		bcc $9517			bcc 	_CRNotVariable
.9512						_CRGoLet:
.9512		20 a4 8f	jsr $8fa4			jsr 	LetCommand
.9515		80 dc		bra $94f3			bra 	_CRMainLoop
.9517						_CRNotVariable:
.9517		c9 b8		cmp #$b8			cmp 	#KWD_AT 					; handle @
.9519		f0 f7		beq $9512			beq 	_CRGoLet
.951b		c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; handle ? !
.951d		f0 f3		beq $9512			beq 	_CRGoLet
.951f		c9 21		cmp #$21			cmp 	#KWD_PLING
.9521		f0 ef		beq $9512			beq 	_CRGoLet
.9523		c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; handle ' (comment)
.9525		f0 09		beq $9530			beq 	_CRGoRem
.9527		c9 2e		cmp #$2e			cmp 	#KWD_PERIOD 				; handle . (assembler label)
.9529		d0 0b		bne $9536			bne 	_CRSyntaxError
.952b		20 b5 85	jsr $85b5			jsr 	LabelHere
.952e		80 c3		bra $94f3			bra 	_CRMainLoop
.9530						_CRGoRem:
.9530		c8		iny				iny
.9531		20 43 94	jsr $9443			jsr 	RemCommand
.9534		80 bd		bra $94f3			bra 	_CRMainLoop
.9536						_CRSyntaxError:
.9536		4c 65 ab	jmp $ab65			jmp 	SyntaxError
.9539						_CRCallVector0:
.9539		7c d8 95	jmp ($95d8,x)			jmp 	(VectorSet0,x)
.953c						_CRBreak:
.953c		a9 01		lda #$01		lda	#1
.953e		4c 69 99	jmp $9969		jmp	ErrorHandler
.9541						CRNoProgram:
.9541		4c ee 88	jmp $88ee			jmp 	EndCommand
.9544						Shift1Command:
.9544		b1 30		lda ($30),y			lda 	(codePtr),y
.9546		c8		iny				iny
.9547		0a		asl a				asl 	a
.9548		aa		tax				tax
.9549		7c 90 96	jmp ($9690,x)			jmp 	(VectorSet1,x)
.954c						Shift2Command:
.954c		b1 30		lda ($30),y			lda 	(codePtr),y
.954e		c8		iny				iny
.954f		0a		asl a				asl 	a
.9550		aa		tax				tax
.9551		7c de 96	jmp ($96de,x)			jmp 	(VectorSet2,x)
.9554						Unused1:
.9554						Unused2:
.9554						Unused3:
.9554						Unused4:
.9554		4c 65 ab	jmp $ab65			jmp 	SyntaxError
>9557								.align 2

;******  Processing file: ./common/commands/../generated/vectors.dat

.9558						VectorSetPunc:
>9558		27 9c					.word	ShiftLeft                        ; $00 <<
>955a		12 9a					.word	BinaryCompareLessEqual           ; $01 <=
>955c		08 9a					.word	BinaryCompareNotEqual            ; $02 <>
>955e		65 ab					.word	SyntaxError                      ; $03 !!3
>9560		65 ab					.word	SyntaxError                      ; $04 ><
>9562		1c 9a					.word	BinaryCompareGreaterEqual        ; $05 >=
>9564		2a 9c					.word	ShiftRight                       ; $06 >>
>9566		65 ab					.word	SyntaxError                      ; $07 !!7
>9568		65 ab					.word	SyntaxError                      ; $08 !!8
>956a		65 ab					.word	SyntaxError                      ; $09 !!9
>956c		65 ab					.word	SyntaxError                      ; $0a !!10
>956e		65 ab					.word	SyntaxError                      ; $0b !!11
>9570		65 ab					.word	SyntaxError                      ; $0c !!12
>9572		65 ab					.word	SyntaxError                      ; $0d !!13
>9574		65 ab					.word	SyntaxError                      ; $0e !!14
>9576		65 ab					.word	SyntaxError                      ; $0f !!15
>9578		65 ab					.word	SyntaxError                      ; $10 @
>957a		65 ab					.word	SyntaxError                      ; $11 !!17
>957c		65 ab					.word	SyntaxError                      ; $12 !!18
>957e		65 ab					.word	SyntaxError                      ; $13 [
>9580		d3 9a					.word	IntegerDivide                    ; $14 \
>9582		65 ab					.word	SyntaxError                      ; $15 ]
>9584		65 9d					.word	EorInteger                       ; $16 ^
>9586		65 ab					.word	SyntaxError                      ; $17 _
>9588		65 ab					.word	SyntaxError                      ; $18 `
>958a		65 ab					.word	SyntaxError                      ; $19 !!25
>958c		65 ab					.word	SyntaxError                      ; $1a !!26
>958e		65 ab					.word	SyntaxError                      ; $1b {
>9590		30 9d					.word	OraInteger                       ; $1c |
>9592		65 ab					.word	SyntaxError                      ; $1d }
>9594		65 ab					.word	SyntaxError                      ; $1e ~
>9596		65 ab					.word	SyntaxError                      ; $1f <7F>
>9598		65 ab					.word	SyntaxError                      ; $20
>959a		9a 9d					.word	WordIndirect                     ; $21 !
>959c		65 ab					.word	SyntaxError                      ; $22 "
>959e		65 ab					.word	SyntaxError                      ; $23 #
>95a0		65 ab					.word	SyntaxError                      ; $24 $
>95a2		14 9b					.word	IntegerModulus                   ; $25 %
>95a4		fb 9c					.word	AndInteger                       ; $26 &
>95a6		65 ab					.word	SyntaxError                      ; $27 '
>95a8		65 ab					.word	SyntaxError                      ; $28 (
>95aa		65 ab					.word	SyntaxError                      ; $29 )
>95ac		82 9b					.word	MulInteger                       ; $2a *
>95ae		9d 9c					.word	AddInteger                       ; $2b +
>95b0		65 ab					.word	SyntaxError                      ; $2c ,
>95b2		d6 9c					.word	SubInteger                       ; $2d -
>95b4		65 ab					.word	SyntaxError                      ; $2e .
>95b6		54 9f					.word	FDivideCommand                   ; $2f /
>95b8		65 ab					.word	SyntaxError                      ; $30 0
>95ba		65 ab					.word	SyntaxError                      ; $31 1
>95bc		65 ab					.word	SyntaxError                      ; $32 2
>95be		65 ab					.word	SyntaxError                      ; $33 3
>95c0		65 ab					.word	SyntaxError                      ; $34 4
>95c2		65 ab					.word	SyntaxError                      ; $35 5
>95c4		65 ab					.word	SyntaxError                      ; $36 6
>95c6		65 ab					.word	SyntaxError                      ; $37 7
>95c8		65 ab					.word	SyntaxError                      ; $38 8
>95ca		65 ab					.word	SyntaxError                      ; $39 9
>95cc		65 ab					.word	SyntaxError                      ; $3a :
>95ce		65 ab					.word	SyntaxError                      ; $3b ;
>95d0		f4 99					.word	BinaryCompareLess                ; $3c <
>95d2		ea 99					.word	BinaryCompareEqual               ; $3d =
>95d4		fe 99					.word	BinaryCompareGreater             ; $3e >
>95d6		bc 9d					.word	ByteIndirect                     ; $3f ?
.95d8						VectorSet0:
>95d8		a4 94					.word	EOLCommand                       ; $80 !0:EOF
>95da		44 95					.word	Shift1Command                    ; $81 !1:SH1
>95dc		4c 95					.word	Shift2Command                    ; $82 !2:SH2
>95de		3e a4					.word	AbsUnary                         ; $83 ABS(
>95e0		4c a4					.word	AllocUnary                       ; $84 ALLOC(
>95e2		bc a4					.word	AscUnary                         ; $85 ASC(
>95e4		0d a6					.word	ChrUnary                         ; $86 CHR$(
>95e6		f1 88					.word	UnaryEvent                       ; $87 EVENT(
>95e8		e6 99					.word	UnaryFalse                       ; $88 FALSE
>95ea		c9 a4					.word	FracUnary                        ; $89 FRAC(
>95ec		69 a9					.word	ChrGet                           ; $8a GET$(
>95ee		4e a9					.word	AscGet                           ; $8b GET(
>95f0		f8 a8					.word	UnaryGetDate                     ; $8c GETDATE$(
>95f2		f4 a8					.word	UnaryGetTime                     ; $8d GETTIME$(
>95f4		80 b0					.word	UnaryHit                         ; $8e HIT(
>95f6		70 a9					.word	ChrInkey                         ; $8f INKEY$(
>95f8		5e a9					.word	AscInkey                         ; $90 INKEY(
>95fa		de a4					.word	IntUnary                         ; $91 INT(
>95fc		cc a5					.word	IsValUnary                       ; $92 ISVAL(
>95fe		1f a6					.word	ItemCountUnary                   ; $93 ITEMCOUNT(
>9600		43 a6					.word	ItemGetUnary                     ; $94 ITEMGET$(
>9602		92 8f					.word	UnaryJoyB                        ; $95 JOYB(
>9604		6b 8f					.word	UnaryJoyX                        ; $96 JOYX(
>9606		6e 8f					.word	UnaryJoyY                        ; $97 JOYY(
>9608		89 a9					.word	KeyDown                          ; $98 KEYDOWN(
>960a		82 a7					.word	Unary_Left                       ; $99 LEFT$(
>960c		ef a4					.word	LenUnary                         ; $9a LEN(
>960e		0d a5					.word	Unary_Max                        ; $9b MAX(
>9610		a4 a7					.word	Unary_Mid                        ; $9c MID$(
>9612		09 a5					.word	Unary_Min                        ; $9d MIN(
>9614		58 a5					.word	Unary_Not                        ; $9e NOT(
>9616		6b a5					.word	PeekByteUnary                    ; $9f PEEK(
>9618		77 a5					.word	PeekDUnary                       ; $a0 PEEKD(
>961a		73 a5					.word	PeekLUnary                       ; $a1 PEEKL(
>961c		6f a5					.word	PeekWUnary                       ; $a2 PEEKW(
>961e		3c b1					.word	UnaryPlaying                     ; $a3 PLAYING(
>9620		a3 a9					.word	Unary_Random                     ; $a4 RANDOM(
>9622		8f a7					.word	Unary_Right                      ; $a5 RIGHT$(
>9624		bd a9					.word	Unary_Rnd                        ; $a6 RND(
>9626		a4 a5					.word	SgnUnary                         ; $a7 SGN(
>9628		c1 a6					.word	SpcUnary                         ; $a8 SPC(
>962a		dc a6					.word	Unary_Str                        ; $a9 STR$(
>962c		df 97					.word	UnaryTimer                       ; $aa TIMER(
>962e		db 99					.word	UnaryTrue                        ; $ab TRUE
>9630		c2 a5					.word	ValUnary                         ; $ac VAL(
>9632		04 8d					.word	ForCommand                       ; $ad FOR
>9634		47 8e					.word	IfCommand                        ; $ae IF
>9636		54 95					.word	Unused1                          ; $af PROC
>9638		50 94					.word	Command_REPEAT                   ; $b0 REPEAT
>963a		21 99					.word	Command_WHILE                    ; $b1 WHILE
>963c		70 8e					.word	EndIf                            ; $b2 ENDIF
>963e		d8 93					.word	Command_ENDPROC                  ; $b3 ENDPROC
>9640		b6 8d					.word	NextCommand                      ; $b4 NEXT
>9642		54 95					.word	Unused4                          ; $b5 THEN
>9644		59 94					.word	Command_UNTIL                    ; $b6 UNTIL
>9646		42 99					.word	Command_WEND                     ; $b7 WEND
>9648		65 ab					.word	SyntaxError                      ; $b8 AT
>964a		65 ab					.word	SyntaxError                      ; $b9 BY
>964c		d0 87					.word	CallCommand                      ; $ba CALL
>964e		34 ae					.word	CircleCommand                    ; $bb CIRCLE
>9650		65 ab					.word	SyntaxError                      ; $bc CLEAR
>9652		65 ab					.word	SyntaxError                      ; $bd COLOR
>9654		65 ab					.word	SyntaxError                      ; $be COLOUR
>9656		17 88					.word	Command_Data                     ; $bf DATA
>9658		1f 88					.word	DimCommand                       ; $c0 DIM
>965a		54 95					.word	Unused3                          ; $c1 DOWNTO
>965c		69 8e					.word	ElseCode                         ; $c2 ELSE
>965e		65 ab					.word	SyntaxError                      ; $c3 FROM
>9660		53 b0					.word	GfxCommand                       ; $c4 GFX
>9662		65 ab					.word	SyntaxError                      ; $c5 HERE
>9664		5d ae					.word	ImageCommand                     ; $c6 IMAGE
>9666		a4 8f					.word	LetCommand                       ; $c7 LET
>9668		af ae					.word	LineCommand                      ; $c8 LINE
>966a		fe 90					.word	Command_LOCAL                    ; $c9 LOCAL
>966c		bf 91					.word	MCCommand                        ; $ca MEMCOPY
>966e		65 ab					.word	SyntaxError                      ; $cb OFF
>9670		65 ab					.word	SyntaxError                      ; $cc ON
>9672		65 ab					.word	SyntaxError                      ; $cd OUTLINE
>9674		a4 b0					.word	PaletteCommand                   ; $ce PALETTE
>9676		a8 ae					.word	PlotCommand                      ; $cf PLOT
>9678		3d 93					.word	PokeBCommand                     ; $d0 POKE
>967a		49 93					.word	PokeDCommand                     ; $d1 POKED
>967c		45 93					.word	PokeLCommand                     ; $d2 POKEL
>967e		41 93					.word	PokeWCommand                     ; $d3 POKEW
>9680		e6 93					.word	Command_Read                     ; $d4 READ
>9682		30 ae					.word	RectangleCommand                 ; $d5 RECT
>9684		43 94					.word	RemCommand                       ; $d6 REM
>9686		65 ab					.word	SyntaxError                      ; $d7 SOLID
>9688		58 b1					.word	SoundCommand                     ; $d8 SOUND
>968a		3f ae					.word	SpriteCommand                    ; $d9 SPRITE
>968c		79 ae					.word	TextCommand                      ; $da TEXT
>968e		54 95					.word	Unused2                          ; $db TO
.9690						VectorSet1:
>9690		65 ab					.word	SyntaxError                      ; $80 !0:EOF
>9692		65 ab					.word	SyntaxError                      ; $81 !1:SH1
>9694		65 ab					.word	SyntaxError                      ; $82 !2:SH2
>9696		a4 87					.word	AssembleCommand                  ; $83 ASSEMBLE
>9698		c0 87					.word	AssertCommand                    ; $84 ASSERT
>969a		f3 af					.word	BitmapCtrl                       ; $85 BITMAP
>969c		4e 89					.word	Command_BLoad                    ; $86 BLOAD
>969e		fa 89					.word	Command_BSave                    ; $87 BSAVE
>96a0		e4 b0					.word	ClearScreen                      ; $88 CLS
>96a2		76 8e					.word	Command_CPrint                   ; $89 CPRINT
>96a4		7d 8a					.word	Command_Dir                      ; $8a DIR
>96a6		dc 88					.word	BootDOS                          ; $8b DOS
>96a8		4d 8b					.word	Command_Drive                    ; $8c DRIVE
>96aa		ee 88					.word	EndCommand                       ; $8d END
>96ac		10 b1					.word	Explode                          ; $8e EXPLODE
>96ae		65 ab					.word	SyntaxError                      ; $8f GO
>96b0		0f 8e					.word	Command_GOSUB                    ; $90 GOSUB
>96b2		2d 8e					.word	GotoCommand                      ; $91 GOTO
>96b4		65 ab					.word	SyntaxError                      ; $92 HIMEM
>96b6		71 8e					.word	Command_Input                    ; $93 INPUT
>96b8		f4 8f					.word	Command_List                     ; $94 LIST
>96ba		54 8b					.word	Command_Load                     ; $95 LOAD
>96bc		cf 92					.word	MouseStatus                      ; $96 MOUSE
>96be		2d 93					.word	NewCommand                       ; $97 NEW
>96c0		ec b0					.word	PingCommand                      ; $98 PING
>96c2		7d 8e					.word	Command_Print                    ; $99 PRINT
>96c4		72 94					.word	Command_Restore                  ; $9a RESTORE
>96c6		1f 8e					.word	Command_RETURN                   ; $9b RETURN
>96c8		b1 94					.word	CommandRUNOptLoad                ; $9c RUN
>96ca		26 8c					.word	Command_Save                     ; $9d SAVE
>96cc		66 97					.word	CommandSetDate                   ; $9e SETDATE
>96ce		6a 97					.word	CommandSetTime                   ; $9f SETTIME
>96d0		04 b1					.word	ShootCommand                     ; $a0 SHOOT
>96d2		38 b0					.word	SpritesCtrl                      ; $a1 SPRITES
>96d4		da 97					.word	StopCommand                      ; $a2 STOP
>96d6		aa 8c					.word	Command_VERIFY                   ; $a3 VERIFY
>96d8		0e 88					.word	XGoCommand                       ; $a4 XGO
>96da		05 88					.word	XLoadCommand                     ; $a5 XLOAD
>96dc		f8 b0					.word	ZapCommand                       ; $a6 ZAP
.96de						VectorSet2:
>96de		65 ab					.word	SyntaxError                      ; $80 !0:EOF
>96e0		65 ab					.word	SyntaxError                      ; $81 !1:SH1
>96e2		65 ab					.word	SyntaxError                      ; $82 !2:SH2
>96e4		24 aa					.word	Assemble_adc                     ; $83 ADC
>96e6		1c aa					.word	Assemble_and                     ; $84 AND
>96e8		38 aa					.word	Assemble_asl                     ; $85 ASL
>96ea		a2 aa					.word	Assemble_bcc                     ; $86 BCC
>96ec		a6 aa					.word	Assemble_bcs                     ; $87 BCS
>96ee		ae aa					.word	Assemble_beq                     ; $88 BEQ
>96f0		65 aa					.word	Assemble_bit                     ; $89 BIT
>96f2		96 aa					.word	Assemble_bmi                     ; $8a BMI
>96f4		aa aa					.word	Assemble_bne                     ; $8b BNE
>96f6		92 aa					.word	Assemble_bpl                     ; $8c BPL
>96f8		b2 aa					.word	Assemble_bra                     ; $8d BRA
>96fa		b6 aa					.word	Assemble_brk                     ; $8e BRK
>96fc		9a aa					.word	Assemble_bvc                     ; $8f BVC
>96fe		9e aa					.word	Assemble_bvs                     ; $90 BVS
>9700		be aa					.word	Assemble_clc                     ; $91 CLC
>9702		12 ab					.word	Assemble_cld                     ; $92 CLD
>9704		d2 aa					.word	Assemble_cli                     ; $93 CLI
>9706		02 ab					.word	Assemble_clv                     ; $94 CLV
>9708		30 aa					.word	Assemble_cmp                     ; $95 CMP
>970a		79 aa					.word	Assemble_cpx                     ; $96 CPX
>970c		74 aa					.word	Assemble_cpy                     ; $97 CPY
>970e		56 aa					.word	Assemble_dec                     ; $98 DEC
>9710		0e ab					.word	Assemble_dex                     ; $99 DEX
>9712		ea aa					.word	Assemble_dey                     ; $9a DEY
>9714		20 aa					.word	Assemble_eor                     ; $9b EOR
>9716		5b aa					.word	Assemble_inc                     ; $9c INC
>9718		1e ab					.word	Assemble_inx                     ; $9d INX
>971a		0a ab					.word	Assemble_iny                     ; $9e INY
>971c		8d aa					.word	Assemble_jmp                     ; $9f JMP
>971e		88 aa					.word	Assemble_jsr                     ; $a0 JSR
>9720		2c aa					.word	Assemble_lda                     ; $a1 LDA
>9722		51 aa					.word	Assemble_ldx                     ; $a2 LDX
>9724		6f aa					.word	Assemble_ldy                     ; $a3 LDY
>9726		42 aa					.word	Assemble_lsr                     ; $a4 LSR
>9728		22 ab					.word	Assemble_nop                     ; $a5 NOP
>972a		18 aa					.word	Assemble_ora                     ; $a6 ORA
>972c		ce aa					.word	Assemble_pha                     ; $a7 PHA
>972e		ba aa					.word	Assemble_php                     ; $a8 PHP
>9730		16 ab					.word	Assemble_phx                     ; $a9 PHX
>9732		d6 aa					.word	Assemble_phy                     ; $aa PHY
>9734		de aa					.word	Assemble_pla                     ; $ab PLA
>9736		c2 aa					.word	Assemble_plp                     ; $ac PLP
>9738		2a ab					.word	Assemble_plx                     ; $ad PLX
>973a		e6 aa					.word	Assemble_ply                     ; $ae PLY
>973c		3d aa					.word	Assemble_rol                     ; $af ROL
>973e		47 aa					.word	Assemble_ror                     ; $b0 ROR
>9740		ca aa					.word	Assemble_rti                     ; $b1 RTI
>9742		da aa					.word	Assemble_rts                     ; $b2 RTS
>9744		34 aa					.word	Assemble_sbc                     ; $b3 SBC
>9746		c6 aa					.word	Assemble_sec                     ; $b4 SEC
>9748		26 ab					.word	Assemble_sed                     ; $b5 SED
>974a		e2 aa					.word	Assemble_sei                     ; $b6 SEI
>974c		28 aa					.word	Assemble_sta                     ; $b7 STA
>974e		1a ab					.word	Assemble_stp                     ; $b8 STP
>9750		4c aa					.word	Assemble_stx                     ; $b9 STX
>9752		6a aa					.word	Assemble_sty                     ; $ba STY
>9754		60 aa					.word	Assemble_stz                     ; $bb STZ
>9756		fe aa					.word	Assemble_tax                     ; $bc TAX
>9758		fa aa					.word	Assemble_tay                     ; $bd TAY
>975a		83 aa					.word	Assemble_trb                     ; $be TRB
>975c		7e aa					.word	Assemble_tsb                     ; $bf TSB
>975e		06 ab					.word	Assemble_tsx                     ; $c0 TSX
>9760		ee aa					.word	Assemble_txa                     ; $c1 TXA
>9762		f6 aa					.word	Assemble_txs                     ; $c2 TXS
>9764		f2 aa					.word	Assemble_tya                     ; $c3 TYA

;******  Return to file: ./common/commands/run.asm


;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/commands/setdatetime.asm

.9766						CommandSetDate:
.9766		a9 03		lda #$03			lda 	#3
.9768		80 02		bra $976c			bra 	CSDTMain
.976a						CommandSetTime:
.976a		a9 00		lda #$00			lda 	#0
.976c						CSDTMain:
.976c		48		pha				pha 								; save table offsets 0 or 3
.976d		a2 00		ldx #$00			ldx 	#0 							; input 3 values.
.976f		20 64 a8	jsr $a864			jsr 	Evaluate8BitInteger
.9772		20 58 99	jsr $9958			jsr 	CheckComma
.9775		e8		inx				inx
.9776		20 64 a8	jsr $a864			jsr 	Evaluate8BitInteger
.9779		20 58 99	jsr $9958			jsr 	CheckComma
.977c		e8		inx				inx
.977d		20 64 a8	jsr $a864			jsr 	Evaluate8BitInteger
.9780		68		pla				pla 								; table offset in Y, saving Y
.9781		5a		phy				phy
.9782		a8		tay				tay
.9783		a2 00		ldx #$00			ldx 	#0 							; first number
.9785		a5 01		lda $01				lda 	1 							; save I/O page, switch to zero
.9787		48		pha				pha
.9788		64 01		stz $01				stz 	1
.978a						_CSDTCopy:
.978a		b5 58		lda $58,x			lda 	NSMantissa0,x 				; get first number
.978c		d9 ce 97	cmp $97ce,y			cmp 	RTCWMinValues,y 			; check range
.978f		90 1b		bcc $97ac			bcc 	_CSDTRange
.9791		d9 d4 97	cmp $97d4,y			cmp 	RTCWMaxValues,y
.9794		b0 16		bcs $97ac			bcs 	_CSDTRange
.9796		20 b1 97	jsr $97b1			jsr 	CSDTDecimalToBCD
.9799		da		phx				phx 								; save X
.979a		be c8 97	ldx $97c8,y			ldx 	RTCWOffset,y 				; offset in RTC in X
.979d		9d 90 d6	sta $d690,x			sta 	$D690,x 					; write to RTC
.97a0		fa		plx				plx 								; restore X
.97a1		e8		inx				inx 								; next number
.97a2		c8		iny				iny 								; next table entries
.97a3		e0 03		cpx #$03			cpx 	#3 							; until done all 3.
.97a5		d0 e3		bne $978a			bne 	_CSDTCopy
.97a7		68		pla				pla 								; restore I/O space
.97a8		85 01		sta $01				sta 	1
.97aa		7a		ply				ply 								; restore code pos and exit.
.97ab		60		rts				rts
.97ac						_CSDTRange:
.97ac		a9 04		lda #$04		lda	#4
.97ae		4c 69 99	jmp $9969		jmp	ErrorHandler
.97b1						CSDTDecimalToBCD:
.97b1		da		phx				phx 								; 10 count in X
.97b2		a2 00		ldx #$00			ldx 	#0
.97b4						_CSDTDBLoop:
.97b4		c9 0a		cmp #$0a			cmp 	#10 						; < 10 evaluate result.
.97b6		90 05		bcc $97bd			bcc 	_CSDTDBExit
.97b8		e9 0a		sbc #$0a			sbc 	#10 						; 10 from value
.97ba		e8		inx				inx 								; one more 10s.
.97bb		80 f7		bra $97b4			bra 	_CSDTDBLoop
.97bd						_CSDTDBExit:
.97bd		85 36		sta $36				sta 	zTemp0 						; units
.97bf		8a		txa				txa 								; 10s x 16
.97c0		0a		asl a				asl 	a
.97c1		0a		asl a				asl 	a
.97c2		0a		asl a				asl 	a
.97c3		0a		asl a				asl 	a
.97c4		05 36		ora $36				ora 	zTemp0 						; BCD result and exit
.97c6		fa		plx				plx
.97c7		60		rts				rts
.97c8						RTCWOffset:
>97c8		04 02 00 06 09 0a				.byte 	4,2,0,6,9,10
.97ce						RTCWMinValues:
>97ce		00 00 00 01 01 00				.byte 	0,0,0,1,1,0
.97d4						RTCWMaxValues:
>97d4		18 3c 3c 20 0d 64				.byte 	24,60,60,32,13,100

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/stop.asm

.97da						StopCommand:
.97da		a9 08		lda #$08		lda	#8
.97dc		4c 69 99	jmp $9969		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/commands/timer.asm

.97df						UnaryTimer:
.97df		fa		plx				plx
.97e0		20 50 99	jsr $9950			jsr 	CheckRightBracket
.97e3						TimerToStackX:
.97e3		20 c9 a8	jsr $a8c9			jsr 	NSMSetZero 					; zero result
.97e6		64 01		stz $01				stz 	1 							; access I/O
.97e8		ad 59 d6	lda $d659			lda 	$D659 						; copy timer in
.97eb		95 58		sta $58,x			sta 	NSMantissa0,x
.97ed		ad 5a d6	lda $d65a			lda 	$D65A
.97f0		95 60		sta $60,x			sta 	NSMantissa1,x
.97f2		ad 5b d6	lda $d65b			lda 	$D65B
.97f5		95 68		sta $68,x			sta 	NSMantissa2,x
.97f7		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/clear.asm

.97f8						ClearSystem:
.97f8		a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.97fa		85 36		sta $36				sta 	0+zTemp0
.97fc		a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.97fe		85 37		sta $37				sta 	1+zTemp0
.9800						_ClearZeroLoop:
.9800		b2 36		lda ($36)			lda 	(zTemp0) 					; end of variables if offset is zero.
.9802		f0 24		beq $9828			beq 	_ClearZeroEnd
.9804		a0 03		ldy #$03			ldy 	#3 							; erase the variables
.9806		a9 00		lda #$00			lda 	#0 							; set all the data to zero.
.9808						_ClearOneVariable:
.9808		91 36		sta ($36),y			sta 	(zTemp0),y
.980a		c8		iny				iny
.980b		c0 08		cpy #$08			cpy 	#8
.980d		d0 f9		bne $9808			bne 	_ClearOneVariable
.980f		a0 02		ldy #$02			ldy 	#2 							; has it been marked procedure
.9811		b1 36		lda ($36),y			lda 	(zTemp0),y
.9813		c9 18		cmp #$18			cmp 	#NSTProcedure
.9815		d0 04		bne $981b			bne 	_ClearNotProcedure
.9817		a9 04		lda #$04			lda 	#NSTInteger+NSBIsArray 		; if so set it back to an integer array
.9819		91 36		sta ($36),y			sta 	(zTemp0),y 					; will be fixed on the pre-run scan.
.981b						_ClearNotProcedure:
.981b		18		clc				clc 								; go to the next variable
.981c		b2 36		lda ($36)			lda 	(zTemp0) 					; offset to next, add to zTemp0
.981e		65 36		adc $36				adc 	zTemp0
.9820		85 36		sta $36				sta 	zTemp0
.9822		90 dc		bcc $9800			bcc 	_ClearZeroLoop
.9824		e6 37		inc $37				inc 	zTemp0+1
.9826		80 d8		bra $9800			bra 	_ClearZeroLoop
.9828						_ClearZeroEnd:
.9828		18		clc				clc
.9829		a5 36		lda $36				lda 	zTemp0
.982b		69 01		adc #$01			adc 	#1
.982d		8d 08 04	sta $0408			sta 	lowMemPtr
.9830		a5 37		lda $37				lda 	zTemp0+1
.9832		69 00		adc #$00			adc 	#0
.9834		8d 09 04	sta $0409			sta 	lowMemPtr+1
.9837		20 45 b2	jsr $b245			jsr 	StackReset
.983a		20 ab b2	jsr $b2ab			jsr 	StringSystemInitialise
.983d		20 53 98	jsr $9853			jsr 	ProcedureScan
.9840		20 72 94	jsr $9472			jsr 	Command_Restore
.9843		9c 1a 04	stz $041a			stz 	AssemblerAddress
.9846		9c 1b 04	stz $041b			stz 	AssemblerAddress+1
.9849		9c 1c 04	stz $041c			stz 	AssemblerControl
.984c		9c 5d 06	stz $065d			stz 	KeyboardQueueEntries
.984f		20 a9 a4	jsr $a4a9			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.9852		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/procscan.asm

.9853						ProcedureScan:
.9853		20 89 94	jsr $9489			jsr 	SwapDataCodePtrs 			; swap code and data
.9856		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.9858		85 30		sta $30				sta 	codePtr
.985a		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.985c		85 31		sta $31				sta 	codePtr+1
.985e						_PSLoop:
.985e		b2 30		lda ($30)			lda 	(codePtr)
.9860		f0 42		beq $98a4			beq 	_PSExit
.9862		a0 03		ldy #$03			ldy 	#3 							; is it PROC at start of line ?
.9864		b1 30		lda ($30),y			lda 	(codePtr),y
.9866		c9 af		cmp #$af			cmp 	#KWD_PROC
.9868		d0 2d		bne $9897			bne 	_PSNext
.986a		c8		iny				iny 								; get the address of the record to zTemp0 and
.986b		b1 30		lda ($30),y			lda 	(codePtr),y
.986d		29 c0		and #$c0			and 	#$C0
.986f		c9 40		cmp #$40			cmp 	#$40
.9871		d0 35		bne $98a8			bne 	_PSSyntax
.9873		b1 30		lda ($30),y			lda 	(codePtr),y
.9875		18		clc				clc
.9876		69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.9878		85 37		sta $37				sta 	zTemp0+1
.987a		c8		iny				iny 								; LSB
.987b		b1 30		lda ($30),y			lda 	(codePtr),y
.987d		85 36		sta $36				sta 	zTemp0
.987f		c8		iny				iny 								; character after variable call.
.9880		98		tya				tya 								; save Y offset at +7 (exponent slot)
.9881		a0 07		ldy #$07			ldy 	#7
.9883		91 36		sta ($36),y			sta 	(zTemp0),y
.9885		a9 18		lda #$18			lda 	#NSTProcedure 				; mark it as procedure
.9887		a0 02		ldy #$02			ldy 	#2
.9889		91 36		sta ($36),y			sta 	(zTemp0),y
.988b		a2 00		ldx #$00			ldx 	#0 							; copy code-Ptr into offset 3-6 (mantissa)
.988d						_PSCopy:
.988d		b5 30		lda $30,x			lda 	safePtr,x
.988f		c8		iny				iny
.9890		91 36		sta ($36),y			sta 	(zTemp0),y
.9892		e8		inx				inx
.9893		e0 04		cpx #$04			cpx 	#4
.9895		d0 f6		bne $988d			bne 	_PSCopy
.9897						_PSNext:
.9897		18		clc				clc
.9898		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.989a		65 30		adc $30				adc 	codePtr
.989c		85 30		sta $30				sta 	codePtr
.989e		90 02		bcc $98a2			bcc 	_CREExit
.98a0		e6 31		inc $31				inc 	codePtr+1 					; carry
.98a2						_CREExit:
.98a2		80 ba		bra $985e			bra 	_PSLoop
.98a4						_PSExit:
.98a4		20 89 94	jsr $9489			jsr 	SwapDataCodePtrs 			; swap code and data
.98a7		60		rts				rts
.98a8						_PSSyntax:
.98a8		4c 65 ab	jmp $ab65			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/scanforward.asm

.98ab						ScanForward:
.98ab		64 38		stz $38				stz 	zTemp1 						; zero the structure count - goes up with WHILE/FOR down with WEND/NEXT etc.
.98ad		86 37		stx $37				stx 	zTemp0+1
.98af		85 36		sta $36				sta 	zTemp0 						; save X & A as the two possible matches.
.98b1						_ScanLoop:
.98b1		b1 30		lda ($30),y			lda 	(codePtr),y
.98b3		c8		iny				iny
.98b4		a6 38		ldx $38				ldx 	zTemp1 						; if the count is > 0 cannot match as in substructure
.98b6		d0 0e		bne $98c6			bne 	_ScanGoNext
.98b8		c5 36		cmp $36				cmp 	zTemp0 						; see if either matches
.98ba		f0 04		beq $98c0			beq 	_ScanMatch
.98bc		c5 37		cmp $37				cmp 	zTemp0+1
.98be		d0 06		bne $98c6			bne 	_ScanGoNext
.98c0						_ScanMatch:
.98c0		c9 80		cmp #$80			cmp 	#KWC_EOL 					; if asked for EOL, backtrack.
.98c2		d0 01		bne $98c5			bne 	_ScanNotEndEOL
.98c4		88		dey				dey
.98c5						_ScanNotEndEOL:
.98c5		60		rts				rts
.98c6						_ScanGoNext:
.98c6		20 cb 98	jsr $98cb			jsr  	ScanForwardOne 				; allows for shifts and so on.
.98c9		80 e6		bra $98b1			bra 	_ScanLoop
.98cb						ScanForwardOne:
.98cb		c9 40		cmp #$40			cmp 	#$40 						; if 00-3F, punctuation characters, already done.
.98cd		90 3e		bcc $990d			bcc 	_SFWExit
.98cf		c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if 40-82, skip one extra as these are 2 byte
.98d1		90 18		bcc $98eb			bcc 	_ScanSkipOne	 			; offsets into the identifier table or shifts.
.98d3		c9 fc		cmp #$fc			cmp 	#$FC 						; FC-FF are data skips (hex consts, strings etc.)
.98d5		b0 2f		bcs $9906			bcs 	_ScanSkipData
.98d7		c9 ad		cmp #$ad			cmp 	#KWC_FIRST_STRUCTURE 		; structure keyword ?
.98d9		90 32		bcc $990d			bcc 	_SFWExit 					; if not, ordinary keywords.
.98db		c9 b8		cmp #$b8			cmp 	#KWC_LAST_STRUCTURE+1
.98dd		b0 2e		bcs $990d			bcs 	_SFWExit
.98df		c6 38		dec $38				dec 	zTemp1 						; decrement the sructure count
.98e1		c9 b2		cmp #$b2			cmp 	#KWC_FIRST_STRUCTURE_DEC 	; back if it is a dec structure (e.g. WEND/NEXT)
.98e3		b0 28		bcs $990d			bcs 	_SFWExit
.98e5		e6 38		inc $38				inc 	zTemp1 						; so it's an increment structure
.98e7		e6 38		inc $38				inc 	zTemp1 						; twice to undo the dec
.98e9		80 22		bra $990d			bra 	_SFWExit
.98eb						_ScanSkipOne:
.98eb		c8		iny				iny 								; consume the extra one.
.98ec		c9 80		cmp #$80			cmp 	#KWC_EOL 					; if not EOL loop back
.98ee		d0 1d		bne $990d			bne 	_SFWExit
.98f0		18		clc				clc
.98f1		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.98f3		65 30		adc $30				adc 	codePtr
.98f5		85 30		sta $30				sta 	codePtr
.98f7		90 02		bcc $98fb			bcc 	_CREExit
.98f9		e6 31		inc $31				inc 	codePtr+1 					; carry
.98fb						_CREExit:
.98fb		a0 03		ldy #$03			ldy 	#3 							; scan start position.
.98fd		b2 30		lda ($30)			lda 	(codePtr)
.98ff		d0 0c		bne $990d			bne 	_SFWExit 					; if not zero, more to scan
.9901		a9 13		lda #$13		lda	#19
.9903		4c 69 99	jmp $9969		jmp	ErrorHandler
.9906						_ScanSkipData:
.9906		88		dey				dey 								; point at data token
.9907		c8		iny				iny 								; point to offset
.9908		98		tya				tya 								; A = offset position
.9909		38		sec				sec 								; add size +1 hence SEC
.990a		71 30		adc ($30),y			adc 	(codePtr),y
.990c		a8		tay				tay 								; make current position.
.990d						_SFWExit:
.990d		60		rts				rts
.990e						ScanGetCurrentLineStep:
.990e		64 38		stz $38				stz 	zTemp1
.9910		a0 03		ldy #$03			ldy 	#3
.9912						_SGCLSLoop:
.9912		b1 30		lda ($30),y			lda 	(codePtr),y
.9914		c8		iny				iny
.9915		c9 80		cmp #$80			cmp 	#KWC_EOL	 				; if EOL exit
.9917		f0 05		beq $991e			beq 	_SGCLSExit
.9919		20 cb 98	jsr $98cb			jsr 	ScanForwardOne
.991c		80 f4		bra $9912			bra 	_SGCLSLoop
.991e						_SGCLSExit:
.991e		a5 38		lda $38				lda 	zTemp1 						; return the adjustment
.9920		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/while.asm

.9921						Command_WHILE:
.9921		5a		phy				phy 								; save position of the test
.9922		a2 00		ldx #$00			ldx 	#0 							; work out the while test.
.9924		20 17 a8	jsr $a817			jsr 	EvaluateNumber
.9927		20 eb a8	jsr $a8eb			jsr 	NSMIsZero 					; check if zero
.992a		f0 0e		beq $993a			beq 	_WHExitLoop 				; if so exit the loop, while has failed.
.992c		98		tya				tya 								; position *after* test.
.992d		7a		ply				ply 								; restore position before test, at WHILE
.992e		88		dey				dey 								; so we execute the WHILE command again.
.992f		48		pha				pha 								; push after test on the stack
.9930		a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; allocate 6 bytes on the return stack.
.9932		20 df b1	jsr $b1df			jsr 	StackOpen
.9935		20 24 b2	jsr $b224			jsr 	STKSaveCodePosition 		; save loop position - where the test value expr is.
.9938		7a		ply				ply 								; restore the position *after* the test
.9939		60		rts				rts
.993a						_WHExitLoop:
.993a		68		pla				pla 								; throw post loop position
.993b		a9 b7		lda #$b7			lda 	#KWD_WEND 					; scan forward past WEND
.993d		aa		tax				tax
.993e		20 ab 98	jsr $98ab			jsr 	ScanForward
.9941		60		rts				rts
.9942						Command_WEND:
.9942		a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; check WHILE is TOS e.g. in a while loop :)
.9944		a2 10		ldx #$10			ldx 	#ERRID_WHILE 				; this error if not.
.9946		20 0c b2	jsr $b20c			jsr 	StackCheckFrame
.9949		20 35 b2	jsr $b235			jsr 	STKLoadCodePosition 		; loop back to the WHILE keyword.
.994c		20 fe b1	jsr $b1fe			jsr 	StackClose		 			; erase the frame
.994f		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/charcheck.asm

.9950						CheckRightBracket:
.9950		b1 30		lda ($30),y			lda 	(codePtr),y
.9952		c8		iny				iny
.9953		c9 29		cmp #$29			cmp 	#KWD_RPAREN 						; exit if matches
.9955		d0 0f		bne $9966			bne 	CNAFail
.9957		60		rts				rts
.9958						CheckComma:
.9958		b1 30		lda ($30),y			lda 	(codePtr),y
.995a		c8		iny				iny
.995b		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 						; exit if matches
.995d		d0 07		bne $9966			bne 	CNAFail
.995f		60		rts				rts
.9960						CheckNextA:
.9960		d1 30		cmp ($30),y			cmp 	(codePtr),y
.9962		d0 02		bne $9966			bne 	CNAFail
.9964		c8		iny				iny 								; skip character
.9965		60		rts				rts 								; and exit
.9966						CNAFail:
.9966		4c 65 ab	jmp $ab65			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/errors.asm

.9969						ErrorHandler:
.9969		48		pha				pha 								; save error #
.996a		a8		tay				tay 								; find the error text
.996b		f0 4e		beq $99bb			beq 	_EHEnd
.996d		a2 00		ldx #$00			ldx 	#0
.996f		a9 7e		lda #$7e			lda 	#((ErrorText) & $FF)
.9971		85 36		sta $36				sta 	0+zTemp0
.9973		a9 ab		lda #$ab			lda 	#((ErrorText) >> 8)
.9975		85 37		sta $37				sta 	1+zTemp0
.9977						_EHFind:
.9977		88		dey				dey 								; keep looking through text
.9978		f0 0e		beq $9988			beq 	_EHFound
.997a						_EHFindZero:
.997a		b2 36		lda ($36)			lda 	(zTemp0) 					; find the next error
.997c		e6 36		inc $36				inc 	zTemp0
.997e		d0 02		bne $9982			bne 	_EHFNoCarry
.9980		e6 37		inc $37				inc 	zTemp0+1
.9982						_EHFNoCarry:
.9982		c9 00		cmp #$00			cmp 	#0
.9984		d0 f4		bne $997a			bne 	_EHFindZero
.9986		80 ef		bra $9977			bra 	_EHFind
.9988						_EHFound:
.9988		a5 36		lda $36				lda 	zTemp0 						; print message
.998a		a6 37		ldx $37				ldx 	zTemp0+1
.998c		20 c8 99	jsr $99c8			jsr 	PrintStringXA
.998f		68		pla				pla  								; check if error is 'open structure'
.9990		c9 13		cmp #$13			cmp 	#ERRID_STRUCT
.9992		f0 22		beq $99b6			beq 	_EHCREnd
.9994		a0 01		ldy #$01			ldy 	#1 							; if line number zero don't print it
.9996		b1 30		lda ($30),y			lda 	(codePtr),y
.9998		d0 05		bne $999f			bne 	_EHAtMsg
.999a		c8		iny				iny
.999b		b1 30		lda ($30),y			lda 	(codePtr),y
.999d		f0 17		beq $99b6			beq 	_EHCREnd
.999f						_EHAtMsg:
.999f		a2 99		ldx #$99			ldx 	#_AtMsg >> 8 				; print " at "
.99a1		a9 be		lda #$be			lda 	#_AtMsg & $FF
.99a3		20 c8 99	jsr $99c8			jsr 	PrintStringXA
.99a6		a0 01		ldy #$01			ldy 	#1 							; line number into XA
.99a8		b1 30		lda ($30),y			lda 	(codePtr),y
.99aa		48		pha				pha
.99ab		c8		iny				iny
.99ac		b1 30		lda ($30),y			lda 	(codePtr),y
.99ae		aa		tax				tax
.99af		68		pla				pla
.99b0		20 de 9d	jsr $9dde			jsr 	ConvertInt16 				; convert XA to string
.99b3		20 c8 99	jsr $99c8			jsr 	PrintStringXA 				; and print it.
.99b6						_EHCREnd:
.99b6		a9 0d		lda #$0d			lda 	#13 						; new line
.99b8		20 43 80	jsr $8043			jsr 	EXTPrintCharacter
.99bb						_EHEnd:
.99bb		4c 6c 87	jmp $876c			jmp 	WarmStart
>99be		20 61 74 20 6c 69 6e 65		_AtMsg:	.text 	" at line ",0
>99c6		20 00
.99c8						PrintStringXA:
.99c8		5a		phy				phy
.99c9		86 37		stx $37				stx 	zTemp0+1
.99cb		85 36		sta $36				sta 	zTemp0
.99cd		a0 00		ldy #$00			ldy 	#0
.99cf						_PSXALoop:
.99cf		b1 36		lda ($36),y			lda 	(zTemp0),y
.99d1		f0 06		beq $99d9			beq 	_PSXAExit
.99d3		20 43 80	jsr $8043			jsr 	EXTPrintCharacter
.99d6		c8		iny				iny
.99d7		80 f6		bra $99cf			bra 	_PSXALoop
.99d9						_PSXAExit:
.99d9		7a		ply				ply
.99da		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/compare.asm

.99db						UnaryTrue:
.99db		fa		plx				plx
.99dc						ReturnTrue:
.99dc		a9 01		lda #$01			lda 	#1  						; set to 1
.99de		20 cb a8	jsr $a8cb			jsr 	NSMSetByte
.99e1		a9 80		lda #$80			lda 	#$80 						; set sign flag, so it is -1
.99e3		95 50		sta $50,x			sta 	NSStatus,x
.99e5		60		rts				rts
.99e6						UnaryFalse:
.99e6		fa		plx				plx
.99e7						ReturnFalse:
.99e7		4c c9 a8	jmp $a8c9			jmp 	NSMSetZero 					; set it all to zero
.99ea						BinaryCompareEqual:
.99ea		fa		plx				plx
.99eb		20 26 9a	jsr $9a26			jsr 	CompareBaseCode
.99ee		c9 00		cmp #$00			cmp 	#0
.99f0		f0 ea		beq $99dc			beq 	ReturnTrue
.99f2		80 f3		bra $99e7			bra 	ReturnFalse
.99f4						BinaryCompareLess:
.99f4		fa		plx				plx
.99f5		20 26 9a	jsr $9a26			jsr 	CompareBaseCode
.99f8		c9 ff		cmp #$ff			cmp 	#$FF
.99fa		f0 e0		beq $99dc			beq 	ReturnTrue
.99fc		80 e9		bra $99e7			bra 	ReturnFalse
.99fe						BinaryCompareGreater:
.99fe		fa		plx				plx
.99ff		20 26 9a	jsr $9a26			jsr 	CompareBaseCode
.9a02		c9 01		cmp #$01			cmp 	#1
.9a04		f0 d6		beq $99dc			beq 	ReturnTrue
.9a06		80 df		bra $99e7			bra 	ReturnFalse
.9a08						BinaryCompareNotEqual:
.9a08		fa		plx				plx
.9a09		20 26 9a	jsr $9a26			jsr 	CompareBaseCode
.9a0c		c9 00		cmp #$00			cmp 	#0
.9a0e		d0 cc		bne $99dc			bne 	ReturnTrue
.9a10		80 d5		bra $99e7			bra 	ReturnFalse
.9a12						BinaryCompareLessEqual:
.9a12		fa		plx				plx
.9a13		20 26 9a	jsr $9a26			jsr 	CompareBaseCode
.9a16		c9 01		cmp #$01			cmp 	#1
.9a18		d0 c2		bne $99dc			bne 	ReturnTrue
.9a1a		80 cb		bra $99e7			bra 	ReturnFalse
.9a1c						BinaryCompareGreaterEqual:
.9a1c		fa		plx				plx
.9a1d		20 26 9a	jsr $9a26			jsr 	CompareBaseCode
.9a20		c9 ff		cmp #$ff			cmp 	#$FF
.9a22		d0 b8		bne $99dc			bne 	ReturnTrue
.9a24		80 c1		bra $99e7			bra 	ReturnFalse
.9a26						CompareBaseCode:
.9a26		20 31 a1	jsr $a131			jsr 	DereferenceTopTwo 			; make both values if references.
.9a29		b5 50		lda $50,x			lda 	NSStatus,x 					; check if either is a string.
.9a2b		15 51		ora $51,x			ora 	NSStatus+1,x
.9a2d		29 10		and #$10			and 	#NSTString
.9a2f		d0 37		bne $9a68			bne 	_CBCString 					; if so do string code, which will check if both.
.9a31		b5 78		lda $78,x			lda 	NSExponent,x 				; check both are integers
.9a33		15 79		ora $79,x			ora 	NSExponent+1,x
.9a35		d0 34		bne $9a6b			bne 	_CBCFloat
.9a37		b5 50		lda $50,x			lda 	NSStatus,x
.9a39		15 51		ora $51,x			ora 	NSStatus+1,x
.9a3b		29 08		and #$08			and 	#NSTFloat
.9a3d		d0 2c		bne $9a6b			bne 	_CBCFloat
.9a3f		20 6e 9a	jsr $9a6e			jsr 	CompareFixMinusZero 		; fix up -0 just in cases.
.9a42		e8		inx				inx
.9a43		20 6e 9a	jsr $9a6e			jsr 	CompareFixMinusZero
.9a46		ca		dex				dex
.9a47		b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs different ?
.9a49		55 51		eor $51,x			eor 	NSStatus+1,x
.9a4b		10 0a		bpl $9a57			bpl 	_CDCSameSign
.9a4d		b5 50		lda $50,x			lda 	NSStatus,x 					; if first one is -ve
.9a4f		30 14		bmi $9a65			bmi 	_CBCLess 					; return $FF
.9a51						_CBCGreater:
.9a51		a9 01		lda #$01			lda 	#1
.9a53		60		rts				rts
.9a54						_CBCEqual:
.9a54		a9 00		lda #$00			lda 	#0
.9a56		60		rts				rts
.9a57						_CDCSameSign:
.9a57		20 83 9c	jsr $9c83			jsr 	SubTopTwoStack 				; unsigned subtract
.9a5a		20 eb a8	jsr $a8eb			jsr 	NSMIsZero 					; or the mantissa together
.9a5d		f0 f5		beq $9a54			beq 	_CBCEqual 					; -0 == 0
.9a5f		b5 70		lda $70,x			lda 	NSMantissa3,x 				; sign of the result. if +ve return $01 else return $FF
.9a61		55 51		eor $51,x			eor 	NSStatus+1,x 				; however if both were -ve this is inverted
.9a63		10 ec		bpl $9a51			bpl 	_CBCGreater
.9a65						_CBCLess:
.9a65		a9 ff		lda #$ff			lda 	#$FF
.9a67		60		rts				rts
.9a68						_CBCString:
.9a68		4c f4 9b	jmp $9bf4			jmp 	CompareStrings
.9a6b						_CBCFloat:
.9a6b		4c 3e 9f	jmp $9f3e			jmp 	CompareFloat
.9a6e						CompareFixMinusZero:
.9a6e		20 eb a8	jsr $a8eb			jsr 	NSMIsZero
.9a71		d0 02		bne $9a75			bne 	_CFXMZNotZero
.9a73		74 50		stz $50,x			stz 	NSStatus,x
.9a75						_CFXMZNotZero:
.9a75		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/concat.asm

.9a76						StringConcat:
.9a76		b5 50		lda $50,x			lda 	NSStatus,x 					; check both strings
.9a78		35 51		and $51,x			and 	NSStatus+1,x
.9a7a		29 18		and #$18			and 	#NSBTypeMask
.9a7c		c9 10		cmp #$10			cmp 	#NSTString
.9a7e		d0 50		bne $9ad0			bne		_SCType
.9a80		64 38		stz $38				stz 	zTemp1 						; counting total length
.9a82		e8		inx				inx
.9a83		20 a1 9a	jsr $9aa1			jsr 	_SCSetupZ0 					; setup for second
.9a86		20 aa 9a	jsr $9aaa			jsr 	_SCLengthZ0 				; length for second
.9a89		ca		dex				dex
.9a8a		20 a1 9a	jsr $9aa1			jsr 	_SCSetupZ0 					; setup for first
.9a8d		20 aa 9a	jsr $9aaa			jsr 	_SCLengthZ0 				; length for first
.9a90		a5 38		lda $38				lda 	zTemp1 						; allocate memory using total.
.9a92		20 cf b2	jsr $b2cf			jsr 	StringTempAllocate
.9a95		20 c1 9a	jsr $9ac1			jsr 	_SCCopy 					; copy first out, using zTemp0 from above
.9a98		e8		inx				inx
.9a99		20 a1 9a	jsr $9aa1			jsr 	_SCSetupZ0 					; copy second out
.9a9c		20 c1 9a	jsr $9ac1			jsr 	_SCCopy
.9a9f		ca		dex				dex
.9aa0		60		rts				rts
.9aa1						_SCSetupZ0:
.9aa1		b5 58		lda $58,x			lda 	NSMantissa0,x
.9aa3		85 36		sta $36				sta 	zTemp0
.9aa5		b5 60		lda $60,x			lda 	NSMantissa1,x
.9aa7		85 37		sta $37				sta 	zTemp0+1
.9aa9		60		rts				rts
.9aaa						_SCLengthZ0:
.9aaa		5a		phy				phy
.9aab		a0 00		ldy #$00			ldy 	#0
.9aad						_SCLenLoop:
.9aad		b1 36		lda ($36),y			lda 	(zTemp0),y
.9aaf		f0 0e		beq $9abf			beq 	_SCLExit
.9ab1		c8		iny				iny
.9ab2		e6 38		inc $38				inc 	zTemp1
.9ab4		a5 38		lda $38				lda	 	zTemp1 						; check string too long.
.9ab6		c9 fd		cmp #$fd			cmp 	#253
.9ab8		d0 f3		bne $9aad			bne		_SCLenLoop
.9aba		a9 09		lda #$09		lda	#9
.9abc		4c 69 99	jmp $9969		jmp	ErrorHandler
.9abf						_SCLExit:
.9abf		7a		ply				ply
.9ac0		60		rts				rts
.9ac1						_SCCopy:
.9ac1		5a		phy				phy
.9ac2		a0 00		ldy #$00			ldy 	#0
.9ac4						_SCCopyLoop:
.9ac4		b1 36		lda ($36),y			lda 	(zTemp0),y
.9ac6		f0 06		beq $9ace			beq 	_SCCExit
.9ac8		20 08 b3	jsr $b308			jsr 	StringTempWrite
.9acb		c8		iny				iny
.9acc		80 f6		bra $9ac4			bra 	_SCCopyLoop
.9ace						_SCCExit:
.9ace		7a		ply				ply
.9acf		60		rts				rts
.9ad0						_SCType:
.9ad0		4c 6f ab	jmp $ab6f			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/divide.asm

.9ad3						IntegerDivide:
.9ad3		fa		plx				plx
.9ad4		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9ad6		15 51		ora $51,x			ora 	NSStatus+1,x
.9ad8		0a		asl a				asl 	a 							; shift reference bit into sign bit
.9ad9		0a		asl a				asl 	a
.9ada		10 05		bpl $9ae1			bpl 	_NotRef
.9adc		48		pha				pha
.9add		20 31 a1	jsr $a131			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9ae0		68		pla				pla
.9ae1						_NotRef:
.9ae1		0a		asl a				asl 	a
.9ae2		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9ae4		15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9ae6		15 79		ora $79,x			ora 	NSExponent+1,x
.9ae8		f0 03		beq $9aed			beq 	_IntegerCode 				; if clear, then we have two integers
.9aea		4c 6f ab	jmp $ab6f			jmp 	TypeError 					; anything else, type mismatch.
.9aed						_IntegerCode:
.9aed		20 07 9b	jsr $9b07			jsr 	CheckDivideZero 			; do div zero check
.9af0		20 39 9b	jsr $9b39			jsr 	Int32Divide 				; do the division
.9af3		20 ea 9b	jsr $9bea			jsr 	CalculateSign 				; calculate result sign
.9af6						NSMCopyPlusTwoToZero:
.9af6		b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.9af8		95 58		sta $58,x			sta 	NSMantissa0,x
.9afa		b5 62		lda $62,x			lda 	NSMantissa1+2,x
.9afc		95 60		sta $60,x			sta 	NSMantissa1,x
.9afe		b5 6a		lda $6a,x			lda 	NSMantissa2+2,x
.9b00		95 68		sta $68,x			sta 	NSMantissa2,x
.9b02		b5 72		lda $72,x			lda 	NSMantissa3+2,x
.9b04		95 70		sta $70,x			sta 	NSMantissa3,x
.9b06		60		rts				rts
.9b07						CheckDivideZero:
.9b07		e8		inx				inx
.9b08		20 eb a8	jsr $a8eb			jsr 	NSMIsZero
.9b0b		f0 02		beq $9b0f			beq 	_CDVError
.9b0d		ca		dex				dex
.9b0e		60		rts				rts
.9b0f						_CDVError:
.9b0f		a9 03		lda #$03		lda	#3
.9b11		4c 69 99	jmp $9969		jmp	ErrorHandler
.9b14						IntegerModulus:
.9b14		fa		plx				plx
.9b15		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9b17		15 51		ora $51,x			ora 	NSStatus+1,x
.9b19		0a		asl a				asl 	a 							; shift reference bit into sign bit
.9b1a		0a		asl a				asl 	a
.9b1b		10 05		bpl $9b22			bpl 	_NotRef
.9b1d		48		pha				pha
.9b1e		20 31 a1	jsr $a131			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9b21		68		pla				pla
.9b22						_NotRef:
.9b22		0a		asl a				asl 	a
.9b23		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9b25		15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9b27		15 79		ora $79,x			ora 	NSExponent+1,x
.9b29		f0 03		beq $9b2e			beq 	_IntegerCode 				; if clear, then we have two integers
.9b2b		4c 6f ab	jmp $ab6f			jmp 	TypeError 					; anything else, type mismatch.
.9b2e						_IntegerCode:
.9b2e						IntegerModulusNoCheck:
.9b2e		20 07 9b	jsr $9b07			jsr 	CheckDivideZero 			; do div zero check
.9b31		20 39 9b	jsr $9b39			jsr 	Int32Divide 				; do the division
.9b34		16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.9b36		56 50		lsr $50,x			lsr 	NSStatus,x
.9b38		60		rts				rts
.9b39						Int32Divide:
.9b39		48		pha				pha 								; save AXY
.9b3a		5a		phy				phy
.9b3b		20 ac a8	jsr $a8ac			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.9b3e		20 c5 a8	jsr $a8c5			jsr 	NSMSetZeroMantissaOnly 		; set S[X] to zero
.9b41		a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.9b43						_I32DivideLoop:
.9b43		e8		inx				inx
.9b44		e8		inx				inx
.9b45		20 d8 a8	jsr $a8d8			jsr 	NSMShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.9b48		ca		dex				dex
.9b49		ca		dex				dex
.9b4a		20 d9 a8	jsr $a8d9			jsr 	NSMRotateLeft
.9b4d		20 78 9b	jsr $9b78			jsr 	DivideCheckSubtract 		; check if subtract possible
.9b50		90 02		bcc $9b54			bcc 	_I32DivideNoCarryIn
.9b52		f6 5a		inc $5a,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.9b54						_I32DivideNoCarryIn:
.9b54		88		dey				dey 								; loop round till division completed.
.9b55		d0 ec		bne $9b43			bne 	_I32DivideLoop
.9b57		7a		ply				ply 								; restore AXY and exit
.9b58		68		pla				pla
.9b59		60		rts				rts
.9b5a						Int32ShiftDivide:
.9b5a		48		pha				pha 								; save AY
.9b5b		5a		phy				phy
.9b5c		e8		inx				inx 								; clear S[X+2]
.9b5d		e8		inx				inx
.9b5e		20 c9 a8	jsr $a8c9			jsr 	NSMSetZero
.9b61		ca		dex				dex
.9b62		ca		dex				dex
.9b63		a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.9b65						_I32SDLoop:
.9b65		20 78 9b	jsr $9b78			jsr 	DivideCheckSubtract 		; check if subtract possible
.9b68		e8		inx				inx
.9b69		e8		inx				inx
.9b6a		20 d9 a8	jsr $a8d9			jsr 	NSMRotateLeft				; shift 64 bit FPA left, rotating carry in
.9b6d		ca		dex				dex
.9b6e		ca		dex				dex
.9b6f		20 d9 a8	jsr $a8d9			jsr 	NSMRotateLeft
.9b72		88		dey				dey 	 							; do 31 times
.9b73		d0 f0		bne $9b65			bne 	_I32SDLoop
.9b75		7a		ply				ply 								; restore AY and exit
.9b76		68		pla				pla
.9b77		60		rts				rts
.9b78						DivideCheckSubtract:
.9b78		20 83 9c	jsr $9c83			jsr 	SubTopTwoStack 				; subtract Stack[X+1] from Stack[X+0]
.9b7b		b0 04		bcs $9b81			bcs 	_DCSExit 					; if carry set, then could do, exit
.9b7d		20 69 9c	jsr $9c69			jsr 	AddTopTwoStack 				; add it back in
.9b80		18		clc				clc 								; and return False
.9b81						_DCSExit:
.9b81		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/multiply.asm

.9b82						MulInteger:
.9b82		fa		plx				plx
.9b83		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9b85		15 51		ora $51,x			ora 	NSStatus+1,x
.9b87		0a		asl a				asl 	a 							; shift reference bit into sign bit
.9b88		0a		asl a				asl 	a
.9b89		10 05		bpl $9b90			bpl 	_NotRef
.9b8b		48		pha				pha
.9b8c		20 31 a1	jsr $a131			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9b8f		68		pla				pla
.9b90						_NotRef:
.9b90		0a		asl a				asl 	a 							; put MSB of type into A:7
.9b91		30 09		bmi $9b9c			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9b93		b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9b95		15 79		ora $79,x			ora 	NSExponent+1,x
.9b97		f0 06		beq $9b9f			beq 	_IntegerCode 				; if clear, then we have two integers
.9b99		4c 00 a0	jmp $a000			jmp 	FloatingPointMultiply 							; otherwise at least one float.
.9b9c						_StringData:
.9b9c		4c 79 ab	jmp $ab79			jmp 	NotDoneError							; at least one string - don't know both are strings.
.9b9f						_IntegerCode:
.9b9f		20 ac 9b	jsr $9bac			jsr 	MultiplyShort
.9ba2		c9 00		cmp #$00			cmp 	#0
.9ba4		f0 05		beq $9bab			beq 	_MIExit
.9ba6		a9 04		lda #$04		lda	#4
.9ba8		4c 69 99	jmp $9969		jmp	ErrorHandler
.9bab						_MIExit:
.9bab		60		rts				rts
.9bac						MultiplyShort:
.9bac		5a		phy				phy 								; save Y
.9bad		20 ac a8	jsr $a8ac			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.9bb0		20 c5 a8	jsr $a8c5			jsr 	NSMSetZeroMantissaOnly 		; set mantissa S[X] to zero
.9bb3		a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.9bb5						_I32MLoop:
.9bb5		b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.9bb7		15 62		ora $62,x			ora 	NSMantissa1+2,x
.9bb9		15 6a		ora $6a,x			ora 	NSMantissa2+2,x
.9bbb		15 72		ora $72,x			ora 	NSMantissa3+2,x
.9bbd		f0 25		beq $9be4			beq 	_I32MExit 					; exit if zero
.9bbf		b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.9bc1		29 01		and #$01			and 	#1
.9bc3		f0 0d		beq $9bd2			beq 	_I32MNoAdd
.9bc5		20 69 9c	jsr $9c69			jsr 	AddTopTwoStack 				; if so add S[X+1] to S[X+0]
.9bc8		b5 70		lda $70,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.9bca		10 06		bpl $9bd2			bpl 	_I32MNoAdd
.9bcc						_I32ShiftRight:
.9bcc		20 e2 a8	jsr $a8e2			jsr 	NSMShiftRight 				; shift S[X] right
.9bcf		c8		iny				iny 								; increment shift count
.9bd0		80 09		bra $9bdb			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.9bd2						_I32MNoAdd:
.9bd2		34 71		bit $71,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.9bd4		70 f6		bvs $9bcc			bvs 	_I32ShiftRight 				; instead.
.9bd6		e8		inx				inx
.9bd7		20 d8 a8	jsr $a8d8			jsr 	NSMShiftLeft 				; shift additive S[X+1] left
.9bda		ca		dex				dex
.9bdb						_I32MShiftUpper:
.9bdb		e8		inx				inx 								; shift S[X+2] right
.9bdc		e8		inx				inx
.9bdd		20 e2 a8	jsr $a8e2			jsr 	NSMShiftRight
.9be0		ca		dex				dex
.9be1		ca		dex				dex
.9be2		80 d1		bra $9bb5			bra 	_I32MLoop 					; try again.
.9be4						_I32MExit:
.9be4		20 ea 9b	jsr $9bea			jsr 	CalculateSign
.9be7		98		tya				tya 								; shift in A
.9be8		7a		ply				ply 								; restore Y and exit
.9be9		60		rts				rts
.9bea						CalculateSign:
.9bea		b5 50		lda $50,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.9bec		16 50		asl $50,x			asl 	NSStatus,x 					; shift result left
.9bee		55 51		eor $51,x			eor 	NSStatus+1,x
.9bf0		0a		asl a				asl 	a 							; shift bit 7 into carry
.9bf1		76 50		ror $50,x			ror 	NSStatus,x 					; shift right into status byte.
.9bf3		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/scompare.asm

.9bf4						CompareStrings:
.9bf4		b5 50		lda $50,x			lda 	NSStatus,x 					; check both are strings
.9bf6		35 51		and $51,x			and 	NSStatus+1,x
.9bf8		29 10		and #$10			and 	#NSBIsString
.9bfa		f0 28		beq $9c24			beq 	_CSTypeError
.9bfc		b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy string addresses to zTemp0/1
.9bfe		85 36		sta $36				sta 	zTemp0
.9c00		b5 60		lda $60,x			lda 	NSMantissa1,x
.9c02		85 37		sta $37				sta 	zTemp0+1
.9c04		b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9c06		85 38		sta $38				sta 	zTemp1
.9c08		b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9c0a		85 39		sta $39				sta 	zTemp1+1
.9c0c		5a		phy				phy 								; save Y so we can access strings
.9c0d		a0 ff		ldy #$ff			ldy 	#$FF 						; -1 for pre increment.
.9c0f						_CSLoop:
.9c0f		c8		iny				iny
.9c10		b1 36		lda ($36),y			lda 	(zTemp0),y 					; check if they are the same
.9c12		d1 38		cmp ($38),y			cmp 	(zTemp1),y
.9c14		d0 06		bne $9c1c			bne 	_CSDifferent
.9c16		c9 00		cmp #$00			cmp 	#0 							; reached end ?
.9c18		d0 f5		bne $9c0f			bne 	_CSLoop 					; still comparing
.9c1a						_CSExit:
.9c1a		7a		ply				ply 								; reached end, return zero in A from EOS
.9c1b		60		rts				rts
.9c1c						_CSDifferent:
.9c1c		a9 ff		lda #$ff			lda 	#255 						; if < return $FF
.9c1e		90 fa		bcc $9c1a			bcc		_CSExit
.9c20		a9 01		lda #$01			lda 	#1 							; otherwise return 1.
.9c22		80 f6		bra $9c1a			bra 	_CSExit
.9c24						_CSTypeError:
.9c24		4c 6f ab	jmp $ab6f			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/shifts.asm

.9c27						ShiftLeft:
.9c27		38		sec				sec 								; common code, carry determines which way.
.9c28		80 01		bra $9c2b			bra 	ShiftMain
.9c2a						ShiftRight:
.9c2a		18		clc				clc
.9c2b						ShiftMain:
.9c2b		fa		plx				plx 								; restore X
.9c2c		08		php				php 								; save direction
.9c2d		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9c2f		15 51		ora $51,x			ora 	NSStatus+1,x
.9c31		0a		asl a				asl 	a 							; shift reference bit into sign bit
.9c32		0a		asl a				asl 	a
.9c33		10 05		bpl $9c3a			bpl 	_NotRef
.9c35		48		pha				pha
.9c36		20 31 a1	jsr $a131			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9c39		68		pla				pla
.9c3a						_NotRef:
.9c3a		0a		asl a				asl 	a
.9c3b		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9c3d		15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9c3f		15 79		ora $79,x			ora 	NSExponent+1,x
.9c41		f0 03		beq $9c46			beq 	_IntegerCode 				; if clear, then we have two integers
.9c43		4c 6f ab	jmp $ab6f			jmp 	TypeError 					; anything else, type mismatch.
.9c46						_IntegerCode:
.9c46		b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; check number < 32
.9c48		29 e0		and #$e0			and 	#$E0
.9c4a		15 61		ora $61,x			ora 	NSMantissa1+1,x
.9c4c		15 69		ora $69,x			ora 	NSMantissa2+1,x
.9c4e		15 71		ora $71,x			ora 	NSMantissa3+1,x
.9c50		d0 12		bne $9c64			bne 	_SMExit0 					; if >= 32 it will always return zero.
.9c52						_SMLoop:
.9c52		d6 59		dec $59,x			dec 	NSMantissa0+1,x 			; predecrement, could do << 0
.9c54		30 11		bmi $9c67			bmi 	_SMExit 					; exit if done.
.9c56		28		plp				plp 								; restore direction setting
.9c57		08		php				php
.9c58		90 05		bcc $9c5f			bcc 	_SMRight
.9c5a		20 d8 a8	jsr $a8d8			jsr 	NSMShiftLeft 				; shift left if CS
.9c5d		80 f3		bra $9c52			bra 	_SMLoop
.9c5f						_SMRight:
.9c5f		20 e2 a8	jsr $a8e2			jsr 	NSMShiftRight 				; shift right if CC
.9c62		80 ee		bra $9c52			bra 	_SMLoop
.9c64						_SMExit0:
.9c64		20 c9 a8	jsr $a8c9			jsr 	NSMSetZero 					; return zero.
.9c67						_SMExit:
.9c67		28		plp				plp 								; throw direction
.9c68		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/simple.asm

.9c69						AddTopTwoStack:
.9c69		18		clc				clc
.9c6a		b5 58		lda $58,x			lda		NSMantissa0,x
.9c6c		75 59		adc $59,x			adc 		NSMantissa0+1,x
.9c6e		95 58		sta $58,x			sta 	NSMantissa0,x
.9c70		b5 60		lda $60,x			lda		NSMantissa1,x
.9c72		75 61		adc $61,x			adc 		NSMantissa1+1,x
.9c74		95 60		sta $60,x			sta 	NSMantissa1,x
.9c76		b5 68		lda $68,x			lda		NSMantissa2,x
.9c78		75 69		adc $69,x			adc 		NSMantissa2+1,x
.9c7a		95 68		sta $68,x			sta 	NSMantissa2,x
.9c7c		b5 70		lda $70,x			lda		NSMantissa3,x
.9c7e		75 71		adc $71,x			adc 		NSMantissa3+1,x
.9c80		95 70		sta $70,x			sta 	NSMantissa3,x
.9c82		60		rts				rts
.9c83						SubTopTwoStack:
.9c83		38		sec				sec
.9c84		b5 58		lda $58,x			lda		NSMantissa0,x
.9c86		f5 59		sbc $59,x			sbc 		NSMantissa0+1,x
.9c88		95 58		sta $58,x			sta 	NSMantissa0,x
.9c8a		b5 60		lda $60,x			lda		NSMantissa1,x
.9c8c		f5 61		sbc $61,x			sbc 		NSMantissa1+1,x
.9c8e		95 60		sta $60,x			sta 	NSMantissa1,x
.9c90		b5 68		lda $68,x			lda		NSMantissa2,x
.9c92		f5 69		sbc $69,x			sbc 		NSMantissa2+1,x
.9c94		95 68		sta $68,x			sta 	NSMantissa2,x
.9c96		b5 70		lda $70,x			lda		NSMantissa3,x
.9c98		f5 71		sbc $71,x			sbc 		NSMantissa3+1,x
.9c9a		95 70		sta $70,x			sta 	NSMantissa3,x
.9c9c		60		rts				rts
.9c9d						AddInteger:
.9c9d		fa		plx				plx
.9c9e		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9ca0		15 51		ora $51,x			ora 	NSStatus+1,x
.9ca2		0a		asl a				asl 	a 							; shift reference bit into sign bit
.9ca3		0a		asl a				asl 	a
.9ca4		10 05		bpl $9cab			bpl 	_NotRef
.9ca6		48		pha				pha
.9ca7		20 31 a1	jsr $a131			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9caa		68		pla				pla
.9cab						_NotRef:
.9cab		0a		asl a				asl 	a 							; put MSB of type into A:7
.9cac		30 09		bmi $9cb7			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9cae		b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9cb0		15 79		ora $79,x			ora 	NSExponent+1,x
.9cb2		f0 06		beq $9cba			beq 	_IntegerCode 				; if clear, then we have two integers
.9cb4		4c b0 9e	jmp $9eb0			jmp 	FloatingPointAdd 							; otherwise at least one float.
.9cb7						_StringData:
.9cb7		4c 76 9a	jmp $9a76			jmp 	StringConcat							; at least one string - don't know both are strings.
.9cba						_IntegerCode:
.9cba						AddCode:
.9cba		b5 50		lda $50,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.9cbc		55 51		eor $51,x			eor 	NSStatus+1,x
.9cbe		10 a9		bpl $9c69			bpl 	AddTopTwoStack
.9cc0		20 83 9c	jsr $9c83			jsr 	SubTopTwoStack 				; do a physical subtraction
.9cc3		34 70		bit $70,x			bit 	NSMantissa3,x 				; result is +ve, okay
.9cc5		10 07		bpl $9cce			bpl 	_AddExit
.9cc7		b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign is that of 2nd value
.9cc9		95 50		sta $50,x			sta 	NSStatus,x
.9ccb		20 92 a8	jsr $a892			jsr 	NSMNegateMantissa 			; negate the mantissa and exit
.9cce						_AddExit:
.9cce		20 eb a8	jsr $a8eb			jsr 	NSMIsZero 					; check for -0
.9cd1		d0 02		bne $9cd5			bne 	_AddNonZero
.9cd3		74 50		stz $50,x			stz 	NSStatus,x
.9cd5						_AddNonZero:
.9cd5		60		rts				rts
.9cd6						SubInteger:
.9cd6		fa		plx				plx
.9cd7		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9cd9		15 51		ora $51,x			ora 	NSStatus+1,x
.9cdb		0a		asl a				asl 	a 							; shift reference bit into sign bit
.9cdc		0a		asl a				asl 	a
.9cdd		10 05		bpl $9ce4			bpl 	_NotRef
.9cdf		48		pha				pha
.9ce0		20 31 a1	jsr $a131			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9ce3		68		pla				pla
.9ce4						_NotRef:
.9ce4		0a		asl a				asl 	a 							; put MSB of type into A:7
.9ce5		30 09		bmi $9cf0			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9ce7		b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9ce9		15 79		ora $79,x			ora 	NSExponent+1,x
.9ceb		f0 06		beq $9cf3			beq 	_IntegerCode 				; if clear, then we have two integers
.9ced		4c b5 9e	jmp $9eb5			jmp 	FloatingPointSub 							; otherwise at least one float.
.9cf0						_StringData:
.9cf0		4c 79 ab	jmp $ab79			jmp 	NotDoneError							; at least one string - don't know both are strings.
.9cf3						_IntegerCode:
.9cf3		b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate the second value.
.9cf5		49 80		eor #$80			eor 	#$80
.9cf7		95 51		sta $51,x			sta 	NSStatus+1,x
.9cf9		80 bf		bra $9cba			bra 	AddCode 					; and do the same code as add.
.9cfb						AndInteger:
.9cfb		fa		plx				plx
.9cfc		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9cfe		15 51		ora $51,x			ora 	NSStatus+1,x
.9d00		0a		asl a				asl 	a 							; shift reference bit into sign bit
.9d01		0a		asl a				asl 	a
.9d02		10 05		bpl $9d09			bpl 	_NotRef
.9d04		48		pha				pha
.9d05		20 31 a1	jsr $a131			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9d08		68		pla				pla
.9d09						_NotRef:
.9d09		0a		asl a				asl 	a
.9d0a		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9d0c		15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9d0e		15 79		ora $79,x			ora 	NSExponent+1,x
.9d10		f0 03		beq $9d15			beq 	_IntegerCode 				; if clear, then we have two integers
.9d12		4c 6f ab	jmp $ab6f			jmp 	TypeError 					; anything else, type mismatch.
.9d15						_IntegerCode:
.9d15		b5 58		lda $58,x			lda		NSMantissa0,x
.9d17		35 59		and $59,x			and 		NSMantissa0+1,x
.9d19		95 58		sta $58,x			sta 	NSMantissa0,x
.9d1b		b5 60		lda $60,x			lda		NSMantissa1,x
.9d1d		35 61		and $61,x			and 		NSMantissa1+1,x
.9d1f		95 60		sta $60,x			sta 	NSMantissa1,x
.9d21		b5 68		lda $68,x			lda		NSMantissa2,x
.9d23		35 69		and $69,x			and 		NSMantissa2+1,x
.9d25		95 68		sta $68,x			sta 	NSMantissa2,x
.9d27		b5 70		lda $70,x			lda		NSMantissa3,x
.9d29		35 71		and $71,x			and 		NSMantissa3+1,x
.9d2b		95 70		sta $70,x			sta 	NSMantissa3,x
.9d2d		74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.9d2f		60		rts				rts
.9d30						OraInteger:
.9d30		fa		plx				plx
.9d31		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9d33		15 51		ora $51,x			ora 	NSStatus+1,x
.9d35		0a		asl a				asl 	a 							; shift reference bit into sign bit
.9d36		0a		asl a				asl 	a
.9d37		10 05		bpl $9d3e			bpl 	_NotRef
.9d39		48		pha				pha
.9d3a		20 31 a1	jsr $a131			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9d3d		68		pla				pla
.9d3e						_NotRef:
.9d3e		0a		asl a				asl 	a
.9d3f		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9d41		15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9d43		15 79		ora $79,x			ora 	NSExponent+1,x
.9d45		f0 03		beq $9d4a			beq 	_IntegerCode 				; if clear, then we have two integers
.9d47		4c 6f ab	jmp $ab6f			jmp 	TypeError 					; anything else, type mismatch.
.9d4a						_IntegerCode:
.9d4a		b5 58		lda $58,x			lda		NSMantissa0,x
.9d4c		15 59		ora $59,x			ora 		NSMantissa0+1,x
.9d4e		95 58		sta $58,x			sta 	NSMantissa0,x
.9d50		b5 60		lda $60,x			lda		NSMantissa1,x
.9d52		15 61		ora $61,x			ora 		NSMantissa1+1,x
.9d54		95 60		sta $60,x			sta 	NSMantissa1,x
.9d56		b5 68		lda $68,x			lda		NSMantissa2,x
.9d58		15 69		ora $69,x			ora 		NSMantissa2+1,x
.9d5a		95 68		sta $68,x			sta 	NSMantissa2,x
.9d5c		b5 70		lda $70,x			lda		NSMantissa3,x
.9d5e		15 71		ora $71,x			ora 		NSMantissa3+1,x
.9d60		95 70		sta $70,x			sta 	NSMantissa3,x
.9d62		74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.9d64		60		rts				rts
.9d65						EorInteger:
.9d65		fa		plx				plx
.9d66		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9d68		15 51		ora $51,x			ora 	NSStatus+1,x
.9d6a		0a		asl a				asl 	a 							; shift reference bit into sign bit
.9d6b		0a		asl a				asl 	a
.9d6c		10 05		bpl $9d73			bpl 	_NotRef
.9d6e		48		pha				pha
.9d6f		20 31 a1	jsr $a131			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9d72		68		pla				pla
.9d73						_NotRef:
.9d73		0a		asl a				asl 	a
.9d74		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9d76		15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9d78		15 79		ora $79,x			ora 	NSExponent+1,x
.9d7a		f0 03		beq $9d7f			beq 	_IntegerCode 				; if clear, then we have two integers
.9d7c		4c 6f ab	jmp $ab6f			jmp 	TypeError 					; anything else, type mismatch.
.9d7f						_IntegerCode:
.9d7f		b5 58		lda $58,x			lda		NSMantissa0,x
.9d81		55 59		eor $59,x			eor 		NSMantissa0+1,x
.9d83		95 58		sta $58,x			sta 	NSMantissa0,x
.9d85		b5 60		lda $60,x			lda		NSMantissa1,x
.9d87		55 61		eor $61,x			eor 		NSMantissa1+1,x
.9d89		95 60		sta $60,x			sta 	NSMantissa1,x
.9d8b		b5 68		lda $68,x			lda		NSMantissa2,x
.9d8d		55 69		eor $69,x			eor 		NSMantissa2+1,x
.9d8f		95 68		sta $68,x			sta 	NSMantissa2,x
.9d91		b5 70		lda $70,x			lda		NSMantissa3,x
.9d93		55 71		eor $71,x			eor 		NSMantissa3+1,x
.9d95		95 70		sta $70,x			sta 	NSMantissa3,x
.9d97		74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.9d99		60		rts				rts
.9d9a						WordIndirect:
.9d9a		fa		plx				plx
.9d9b		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9d9d		15 51		ora $51,x			ora 	NSStatus+1,x
.9d9f		0a		asl a				asl 	a 							; shift reference bit into sign bit
.9da0		0a		asl a				asl 	a
.9da1		10 05		bpl $9da8			bpl 	_NotRef
.9da3		48		pha				pha
.9da4		20 31 a1	jsr $a131			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9da7		68		pla				pla
.9da8						_NotRef:
.9da8		0a		asl a				asl 	a
.9da9		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9dab		15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9dad		15 79		ora $79,x			ora 	NSExponent+1,x
.9daf		f0 03		beq $9db4			beq 	_IntegerCode 				; if clear, then we have two integers
.9db1		4c 6f ab	jmp $ab6f			jmp 	TypeError 					; anything else, type mismatch.
.9db4						_IntegerCode:
.9db4		20 ba 9c	jsr $9cba			jsr 	AddCode 					; add the two values
.9db7		a9 22		lda #$22			lda 	#NSBIsReference+2 			; make a 2 byte reference
.9db9		95 50		sta $50,x			sta 	NSStatus,x
.9dbb		60		rts				rts
.9dbc						ByteIndirect:
.9dbc		fa		plx				plx
.9dbd		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9dbf		15 51		ora $51,x			ora 	NSStatus+1,x
.9dc1		0a		asl a				asl 	a 							; shift reference bit into sign bit
.9dc2		0a		asl a				asl 	a
.9dc3		10 05		bpl $9dca			bpl 	_NotRef
.9dc5		48		pha				pha
.9dc6		20 31 a1	jsr $a131			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9dc9		68		pla				pla
.9dca						_NotRef:
.9dca		0a		asl a				asl 	a
.9dcb		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9dcd		15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9dcf		15 79		ora $79,x			ora 	NSExponent+1,x
.9dd1		f0 03		beq $9dd6			beq 	_IntegerCode 				; if clear, then we have two integers
.9dd3		4c 6f ab	jmp $ab6f			jmp 	TypeError 					; anything else, type mismatch.
.9dd6						_IntegerCode:
.9dd6		20 ba 9c	jsr $9cba			jsr 	AddCode 					; add the two values
.9dd9		a9 21		lda #$21			lda 	#NSBIsReference+1 			; make a 1 byte reference
.9ddb		95 50		sta $50,x			sta 	NSStatus,x
.9ddd		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/tostring.asm

.9dde						ConvertInt16:
.9dde		85 58		sta $58				sta 	NSMantissa0 				; set up as 32 bit conversion
.9de0		86 60		stx $60				stx 	NSMantissa1
.9de2		64 68		stz $68				stz 	NSMantissa2
.9de4		64 70		stz $70				stz 	NSMantissa3
.9de6		64 50		stz $50				stz 	NSStatus 					; positive integer
.9de8		a2 00		ldx #$00			ldx 	#0 							; stack level
.9dea		a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.9dec		80 00		bra $9dee			bra 	ConvertInt32
.9dee						ConvertInt32:
.9dee		5a		phy				phy
.9def		a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.9df1		24 50		bit $50				bit 	NSStatus 					; output a - if not negative.
.9df3		10 08		bpl $9dfd			bpl 	_CI32NotNeg
.9df5		48		pha				pha
.9df6		a9 2d		lda #$2d			lda 	#'-'
.9df8		99 23 06	sta $0623,y			sta 	numberBuffer,y
.9dfb		c8		iny				iny
.9dfc		68		pla				pla
.9dfd						_CI32NotNeg:
.9dfd		20 0b 9e	jsr $9e0b			jsr 	_CI32DivideConvert 			; recursive conversion
.9e00		a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.9e02		99 23 06	sta $0623,y			sta 	numberBuffer,y
.9e05		7a		ply				ply
.9e06		a2 06		ldx #$06			ldx 	#numberBuffer >> 8 			; return address in XA
.9e08		a9 23		lda #$23			lda 	#numberBuffer & $FF
.9e0a		60		rts				rts
.9e0b						_CI32DivideConvert:
.9e0b		e8		inx				inx 								; write to next slot up
.9e0c		20 cb a8	jsr $a8cb			jsr 	NSMSetByte 		 			; write the base out.
.9e0f		ca		dex				dex
.9e10		20 39 9b	jsr $9b39			jsr 	Int32Divide 				; divide
.9e13		b5 58		lda $58,x			lda 	NSMantissa0,x 				; save remainder
.9e15		48		pha				pha
.9e16		20 f6 9a	jsr $9af6			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.9e19		20 eb a8	jsr $a8eb			jsr 	NSMIsZero 					; is it zero ?
.9e1c		f0 05		beq $9e23			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.9e1e		b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.9e20		20 0b 9e	jsr $9e0b			jsr 	_CI32DivideConvert 			; and recusrively call.
.9e23						_CI32NoRecurse:
.9e23		68		pla				pla 								; remainder
.9e24		c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.9e26		90 02		bcc $9e2a			bcc 	_CI32NotHex
.9e28		69 26		adc #$26			adc 	#6+32
.9e2a						_CI32NotHex:
.9e2a		69 30		adc #$30			adc 	#48
.9e2c		99 23 06	sta $0623,y			sta 	numberBuffer,y 				; write out and exit
.9e2f		c8		iny				iny
.9e30		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/expression.asm


;******  Processing file: ./common/expressions/../generated/precedence.dat

.9e31						PrecedenceLevel:
>9e31		04					.byte	 4	; $00 <<
>9e32		02					.byte	 2	; $01 <=
>9e33		02					.byte	 2	; $02 <>
>9e34		00					.byte	 0	; $03 !!3
>9e35		00					.byte	 0	; $04 ><
>9e36		02					.byte	 2	; $05 >=
>9e37		04					.byte	 4	; $06 >>
>9e38		00					.byte	 0	; $07 !!7
>9e39		00					.byte	 0	; $08 !!8
>9e3a		00					.byte	 0	; $09 !!9
>9e3b		00					.byte	 0	; $0a !!10
>9e3c		00					.byte	 0	; $0b !!11
>9e3d		00					.byte	 0	; $0c !!12
>9e3e		00					.byte	 0	; $0d !!13
>9e3f		00					.byte	 0	; $0e !!14
>9e40		00					.byte	 0	; $0f !!15
>9e41		00					.byte	 0	; $10 @
>9e42		00					.byte	 0	; $11 !!17
>9e43		00					.byte	 0	; $12 !!18
>9e44		00					.byte	 0	; $13 [
>9e45		04					.byte	 4	; $14 \
>9e46		00					.byte	 0	; $15 ]
>9e47		01					.byte	 1	; $16 ^
>9e48		00					.byte	 0	; $17 _
>9e49		00					.byte	 0	; $18 `
>9e4a		00					.byte	 0	; $19 !!25
>9e4b		00					.byte	 0	; $1a !!26
>9e4c		00					.byte	 0	; $1b {
>9e4d		01					.byte	 1	; $1c |
>9e4e		00					.byte	 0	; $1d }
>9e4f		00					.byte	 0	; $1e ~
>9e50		00					.byte	 0	; $1f <7F>
>9e51		00					.byte	 0	; $20
>9e52		05					.byte	 5	; $21 !
>9e53		00					.byte	 0	; $22 "
>9e54		00					.byte	 0	; $23 #
>9e55		05					.byte	 5	; $24 $
>9e56		04					.byte	 4	; $25 %
>9e57		01					.byte	 1	; $26 &
>9e58		00					.byte	 0	; $27 '
>9e59		00					.byte	 0	; $28 (
>9e5a		00					.byte	 0	; $29 )
>9e5b		04					.byte	 4	; $2a *
>9e5c		03					.byte	 3	; $2b +
>9e5d		00					.byte	 0	; $2c ,
>9e5e		03					.byte	 3	; $2d -
>9e5f		00					.byte	 0	; $2e .
>9e60		04					.byte	 4	; $2f /
>9e61		00					.byte	 0	; $30 0
>9e62		00					.byte	 0	; $31 1
>9e63		00					.byte	 0	; $32 2
>9e64		00					.byte	 0	; $33 3
>9e65		00					.byte	 0	; $34 4
>9e66		00					.byte	 0	; $35 5
>9e67		00					.byte	 0	; $36 6
>9e68		00					.byte	 0	; $37 7
>9e69		00					.byte	 0	; $38 8
>9e6a		00					.byte	 0	; $39 9
>9e6b		00					.byte	 0	; $3a :
>9e6c		00					.byte	 0	; $3b ;
>9e6d		02					.byte	 2	; $3c <
>9e6e		02					.byte	 2	; $3d =
>9e6f		02					.byte	 2	; $3e >
>9e70		05					.byte	 5	; $3f ?

;******  Return to file: ./common/expressions/expression.asm

.9e71						EvaluateExpressionAt0:
.9e71		a2 00		ldx #$00			ldx 	#0 							; bottom stack level
.9e73						EvaluateExpression:
.9e73		a9 00		lda #$00			lda 	#0 							; lowest precedence level
.9e75						EvaluateExpressionAtPrecedence:
.9e75		48		pha				pha 								; save precedence level
.9e76		20 bd a2	jsr $a2bd			jsr 	EvaluateTerm 				; evaluate term into level X.
.9e79		68		pla				pla 								; restore precedence level.
.9e7a						_EXPRLoop:
.9e7a		85 36		sta $36				sta 	zTemp0 						; save current precedence level.
.9e7c		b1 30		lda ($30),y			lda 	(codePtr),y
.9e7e		c9 40		cmp #$40			cmp		#$40 						; if >= $40 cannot be an operator
.9e80		b0 25		bcs $9ea7			bcs 	_EXPRExit
.9e82		da		phx				phx 								; read the operator precedence
.9e83		aa		tax				tax
.9e84		bd 31 9e	lda $9e31,x			lda 	PrecedenceLevel,x
.9e87		fa		plx				plx
.9e88		c9 00		cmp #$00			cmp 	#0							; if zero exit (not an operator)
.9e8a		f0 1b		beq $9ea7			beq 	_EXPRExit
.9e8c		85 37		sta $37				sta 	zTemp0+1 					; save operator precedence level.
.9e8e		a5 36		lda $36				lda 	zTemp0 						; compare current precedence vs. operator precedence
.9e90		c5 37		cmp $37				cmp 	zTemp0+1
.9e92		b0 13		bcs $9ea7			bcs		_EXPRExit 					; if current >= operator exit
.9e94		48		pha				pha 								; save current precedence.
.9e95		b1 30		lda ($30),y			lda 	(codePtr),y
.9e97		c8		iny				iny
.9e98		48		pha				pha
.9e99		a5 37		lda $37				lda 	zTemp0+1 					; get operator precedence level
.9e9b		e8		inx				inx 								; work out the right hand side.
.9e9c		20 75 9e	jsr $9e75			jsr 	EvaluateExpressionAtPrecedence
.9e9f		ca		dex				dex
.9ea0		68		pla				pla 								; get operator, call the code.
.9ea1		20 aa 9e	jsr $9eaa			jsr 	_EXPRCaller
.9ea4		68		pla				pla 								; restore precedence level
.9ea5		80 d3		bra $9e7a			bra 	_EXPRLoop 					; and go round.
.9ea7						_EXPRExit:
.9ea7		a5 36		lda $36				lda 	zTemp0 						; A = current precedence level.
.9ea9		60		rts				rts
.9eaa						_EXPRCaller:
.9eaa		da		phx				phx 								; save on stack, first thing is to restore it
.9eab		0a		asl a				asl 	a 							; double so can use vectors into X
.9eac		aa		tax				tax
.9ead		7c 58 95	jmp ($9558,x)			jmp 	(VectorSetPunc,x) 			; and go to the code.

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/addsub.asm

.9eb0						FloatingPointAdd:
.9eb0		20 26 a0	jsr $a026			jsr 	FloatPrepare 				; prepare for floats
.9eb3		80 09		bra $9ebe			bra 	FloatAdd
.9eb5						FloatingPointSub:
.9eb5		20 26 a0	jsr $a026			jsr 	FloatPrepare 				; prepare for floats
.9eb8						FloatSubtract:
.9eb8		b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate FPB
.9eba		49 80		eor #$80			eor 	#$80
.9ebc		95 51		sta $51,x			sta 	NSStatus+1,x				; and fall through.
.9ebe						FloatAdd:
.9ebe		48		pha				pha
.9ebf		5a		phy				phy
.9ec0		20 35 a0	jsr $a035			jsr 	NSNormalise 				; normalise S[X]
.9ec3		f0 51		beq $9f16			beq 	_FAReturn1
.9ec5		e8		inx				inx 								; normalise S[X+1]
.9ec6		20 35 a0	jsr $a035			jsr 	NSNormalise
.9ec9		ca		dex				dex
.9eca		c9 00		cmp #$00			cmp 	#0
.9ecc		f0 60		beq $9f2e			beq 	_FAExit 					; if so, just return A
.9ece		b5 78		lda $78,x			lda 	NSExponent,x 				; are the exponents the same ?
.9ed0		d5 79		cmp $79,x			cmp 	NSExponent+1,x
.9ed2		f0 18		beq $9eec			beq 	_FAExponentsEqual
.9ed4		b5 78		lda $78,x			lda 	NSExponent,x 				; work out the larger exponent
.9ed6		a8		tay				tay
.9ed7		38		sec				sec 								; do a signed comparison of the exponents.
.9ed8		f5 79		sbc $79,x			sbc 	NSExponent+1,x
.9eda		50 02		bvc $9ede			bvc 	_FANoSignedChange
.9edc		49 80		eor #$80			eor 	#$80
.9ede						_FANoSignedChange:
.9ede		29 80		and #$80			and 	#$80
.9ee0		10 02		bpl $9ee4			bpl 	_FAHaveMax
.9ee2		b4 79		ldy $79,x			ldy 	NSExponent+1,x
.9ee4						_FAHaveMax:
.9ee4		20 31 9f	jsr $9f31			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.9ee7		e8		inx				inx
.9ee8		20 31 9f	jsr $9f31			jsr 	_FAShiftToExponent
.9eeb		ca		dex				dex
.9eec						_FAExponentsEqual:
.9eec		b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs the same
.9eee		55 51		eor $51,x			eor 	NSStatus+1,x
.9ef0		30 0e		bmi $9f00			bmi 	_FADifferentSigns
.9ef2		20 69 9c	jsr $9c69			jsr 	AddTopTwoStack 				; do the add of the mantissae
.9ef5		b5 70		lda $70,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.9ef7		10 35		bpl $9f2e			bpl 	_FAExit 					; if no, we are done.
.9ef9		20 e2 a8	jsr $a8e2			jsr 	NSMShiftRight 				; shift A right, renormalising it.
.9efc		f6 78		inc $78,x			inc 	NSExponent,x 				; bump the exponent and exit
.9efe		80 2e		bra $9f2e			bra 	_FAExit
.9f00						_FADifferentSigns:
.9f00		20 83 9c	jsr $9c83			jsr 	SubTopTwoStack 				; subtract mantissa B from A
.9f03		b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the result negative ?
.9f05		10 06		bpl $9f0d			bpl 	_FACheckZero 				; if no, check for -0
.9f07		20 8b a8	jsr $a88b			jsr 	NSMNegate 					; netate result
.9f0a		20 92 a8	jsr $a892			jsr 	NSMNegateMantissa 			; negate (2'c) the mantissa
.9f0d						_FACheckZero:
.9f0d		20 eb a8	jsr $a8eb			jsr 	NSMIsZero	 				; check for -0
.9f10		d0 1c		bne $9f2e			bne 	_FAExit
.9f12		74 50		stz $50,x			stz 	NSStatus,x
.9f14		80 18		bra $9f2e			bra 	_FAExit
.9f16						_FAReturn1:
.9f16		b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.9f18		95 58		sta $58,x			sta 	NSMantissa0,x
.9f1a		b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9f1c		95 60		sta $60,x			sta 	NSMantissa1,x
.9f1e		b5 69		lda $69,x			lda 	NSMantissa2+1,x
.9f20		95 68		sta $68,x			sta 	NSMantissa2,x
.9f22		b5 71		lda $71,x			lda 	NSMantissa3+1,x
.9f24		95 70		sta $70,x			sta 	NSMantissa3,x
.9f26		b5 79		lda $79,x			lda 	NSExponent+1,x
.9f28		95 78		sta $78,x			sta 	NSExponent,x
.9f2a		b5 51		lda $51,x			lda 	NSStatus+1,x
.9f2c		95 50		sta $50,x			sta 	NSStatus,x
.9f2e						_FAExit:
.9f2e		7a		ply				ply
.9f2f		68		pla				pla
.9f30		60		rts				rts
.9f31						_FAShiftToExponent:
.9f31						_FAShiftToExponent2:
.9f31		98		tya				tya 								; compare Y to exponent
.9f32		d5 78		cmp $78,x			cmp 	NSExponent,x 				; reached the exponent required ?
.9f34		f0 07		beq $9f3d			beq 	_FASEExit 					; exit if so.
.9f36		20 e2 a8	jsr $a8e2			jsr 	NSMShiftRight	 			; shift the mantissa right
.9f39		f6 78		inc $78,x			inc 	NSExponent,x 				; increment exponent
.9f3b		80 f4		bra $9f31			bra 	_FAShiftToExponent2
.9f3d						_FASEExit:
.9f3d		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/compare.asm

.9f3e						CompareFloat:
.9f3e		20 b8 9e	jsr $9eb8			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.9f41		b5 60		lda $60,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.9f43		29 f8		and #$f8			and 	#$F8
.9f45		15 68		ora $68,x			ora 	NSMantissa2,x
.9f47		15 70		ora $70,x			ora 	NSMantissa3,x
.9f49		f0 08		beq $9f53			beq 	_FCExit 					; zero, so approximately identical
.9f4b		a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.9f4d		34 50		bit $50,x			bit 	NSStatus,x
.9f4f		10 02		bpl $9f53			bpl 	_FCExit
.9f51						_FCNegative:
.9f51		a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.9f53						_FCExit:
.9f53		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/divide.asm

.9f54						FDivideCommand:
.9f54		fa		plx				plx	 								; restore stack position
.9f55		20 26 a0	jsr $a026			jsr 	FloatPrepare 				; prepare for floats
.9f58						FloatDivide:
.9f58		48		pha				pha
.9f59		e8		inx				inx
.9f5a		20 35 a0	jsr $a035			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.9f5d		ca		dex				dex
.9f5e		c9 00		cmp #$00			cmp 	#0
.9f60		f0 1d		beq $9f7f			beq 	_FDZero
.9f62		20 35 a0	jsr $a035			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.9f65		f0 16		beq $9f7d			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.9f67		20 5a 9b	jsr $9b5a			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.9f6a		20 f6 9a	jsr $9af6			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.9f6d		20 35 a0	jsr $a035			jsr		NSNormalise 				; renormalise
.9f70		20 ea 9b	jsr $9bea			jsr 	CalculateSign 				; calculate result sign
.9f73		b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent
.9f75		38		sec				sec
.9f76		f5 79		sbc $79,x			sbc 	NSExponent+1,x
.9f78		38		sec				sec
.9f79		e9 1e		sbc #$1e			sbc 	#30
.9f7b		95 78		sta $78,x			sta 	NSExponent,x
.9f7d						_FDExit:
.9f7d		68		pla				pla
.9f7e		60		rts				rts
.9f7f						_FDZero:
.9f7f		a9 03		lda #$03		lda	#3
.9f81		4c 69 99	jmp $9969		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/fractional.asm

.9f84						FloatFractionalPart:
.9f84		5a		phy				phy
.9f85		b5 50		lda $50,x			lda 	NSStatus,x 					; take absolute value
.9f87		29 7f		and #$7f			and 	#$7F
.9f89		95 50		sta $50,x			sta 	NSStatus,x
.9f8b		20 35 a0	jsr $a035			jsr 	NSNormalise
.9f8e		b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.9f90		38		sec				sec
.9f91		e9 e0		sbc #$e0			sbc 	#$E0
.9f93		90 29		bcc $9fbe			bcc 	_FFPExit 					; already fractional
.9f95		c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.9f97		b0 22		bcs $9fbb			bcs 	_FFPZero
.9f99		a8		tay				tay 								; put count to do in Y
.9f9a		b5 70		lda $70,x			lda 	NSMantissa3,x 				; do each in turn.
.9f9c		20 c0 9f	jsr $9fc0			jsr 	_FFPPartial
.9f9f		95 70		sta $70,x			sta 	NSMantissa3,x
.9fa1		b5 68		lda $68,x			lda 	NSMantissa2,x
.9fa3		20 c0 9f	jsr $9fc0			jsr 	_FFPPartial
.9fa6		95 68		sta $68,x			sta 	NSMantissa2,x
.9fa8		b5 60		lda $60,x			lda 	NSMantissa1,x
.9faa		20 c0 9f	jsr $9fc0			jsr 	_FFPPartial
.9fad		95 60		sta $60,x			sta 	NSMantissa1,x
.9faf		b5 58		lda $58,x			lda 	NSMantissa0,x
.9fb1		20 c0 9f	jsr $9fc0			jsr 	_FFPPartial
.9fb4		95 58		sta $58,x			sta 	NSMantissa0,x
.9fb6		20 eb a8	jsr $a8eb			jsr 	NSMIsZero 					; zeroed check.
.9fb9		d0 03		bne $9fbe			bne 	_FFPExit
.9fbb						_FFPZero:
.9fbb		20 c9 a8	jsr $a8c9			jsr 	NSMSetZero
.9fbe						_FFPExit:
.9fbe		7a		ply				ply
.9fbf		60		rts				rts
.9fc0						_FFPPartial:
.9fc0		c0 00		cpy #$00			cpy 	#0 							; no more to do
.9fc2		f0 17		beq $9fdb			beq 	_FFFPPExit
.9fc4		c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.9fc6		b0 0c		bcs $9fd4			bcs 	_FFFPPWholeByte
.9fc8		5a		phy				phy
.9fc9						_FFFPPLeft:
.9fc9		0a		asl a				asl 	a
.9fca		88		dey				dey
.9fcb		d0 fc		bne $9fc9			bne 	_FFFPPLeft
.9fcd		7a		ply				ply
.9fce						_FFFPPRight:
.9fce		4a		lsr a				lsr 	a
.9fcf		88		dey				dey
.9fd0		d0 fc		bne $9fce			bne 	_FFFPPRight
.9fd2		80 07		bra $9fdb			bra 	_FFFPPExit
.9fd4						_FFFPPWholeByte:
.9fd4		98		tya				tya 								; subtract 8 from count
.9fd5		38		sec				sec
.9fd6		e9 08		sbc #$08			sbc 	#8
.9fd8		a8		tay				tay
.9fd9		a9 00		lda #$00			lda 	#0 							; and clear all
.9fdb						_FFFPPExit:
.9fdb		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/integer.asm

.9fdc						FloatIntegerPart:
.9fdc		48		pha				pha
.9fdd		b5 78		lda $78,x			lda 	NSExponent,x 				; is it integer already ?
.9fdf		f0 1d		beq $9ffe			beq 	_FIPExit 					; if so do nothing
.9fe1		20 eb a8	jsr $a8eb			jsr 	NSMIsZero 					; is it zero ?
.9fe4		f0 15		beq $9ffb			beq 	_FIPZero 					; if so return zero.
.9fe6		20 35 a0	jsr $a035			jsr 	NSNormalise 				; normalise
.9fe9		f0 10		beq $9ffb			beq 	_FIPZero 					; normalised to zero, exit zero
.9feb						_FIPShift:
.9feb		b5 78		lda $78,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.9fed		10 07		bpl $9ff6			bpl 	_FIPCheckZero
.9fef		20 e2 a8	jsr $a8e2			jsr 	NSMShiftRight 				; shift mantissa right
.9ff2		f6 78		inc $78,x			inc 	NSExponent,x 				; bump exponent
.9ff4		80 f5		bra $9feb			bra 	_FIPShift
.9ff6						_FIPCheckZero:
.9ff6		20 eb a8	jsr $a8eb			jsr 	NSMIsZero 					; avoid -0 problem
.9ff9		d0 03		bne $9ffe			bne 	_FIPExit 					; set to zero if mantissa zero.
.9ffb						_FIPZero:
.9ffb		20 c9 a8	jsr $a8c9			jsr 	NSMSetZero
.9ffe						_FIPExit:
.9ffe		68		pla				pla
.9fff		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/multiply.asm

.a000						FloatingPointMultiply:
.a000		20 26 a0	jsr $a026			jsr 	FloatPrepare 				; prepare for floats
.a003						FloatMultiply:
.a003		48		pha				pha
.a004		20 35 a0	jsr $a035			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.a007		f0 18		beq $a021			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.a009		e8		inx				inx
.a00a		20 35 a0	jsr $a035			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.a00d		ca		dex				dex
.a00e		c9 00		cmp #$00			cmp 	#0
.a010		f0 0c		beq $a01e			beq 	_FDSetZero
.a012		20 ac 9b	jsr $9bac			jsr 	MultiplyShort 				; calculate the result.
.a015		75 78		adc $78,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.a017		18		clc				clc
.a018		75 79		adc $79,x			adc 	NSExponent+1,x
.a01a		95 78		sta $78,x			sta 	NSExponent,x
.a01c		80 03		bra $a021			bra 	_FDExit
.a01e						_FDSetZero:
.a01e		20 c9 a8	jsr $a8c9			jsr 	NSMSetZero 					; return 0
.a021						_FDExit:
.a021		20 35 a0	jsr $a035			jsr 	NSNormalise 				; normalise the result
.a024		68		pla				pla
.a025		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/utility.asm

.a026						FloatPrepare:
.a026		20 31 a1	jsr $a131			jsr 	DereferenceTopTwo 			; dereference the top two values
.a029		b5 50		lda $50,x			lda 	NSStatus,x 					; check ints/floats, either will do.
.a02b		15 51		ora $51,x			ora 	NSStatus+1,x
.a02d		29 10		and #$10			and 	#NSBIsString
.a02f		d0 01		bne $a032			bne 	_FDType
.a031		60		rts				rts
.a032						_FDType:
.a032		4c 6f ab	jmp $ab6f			jmp 	TypeError
.a035						NSNormalise:
.a035		b5 50		lda $50,x			lda 	NSStatus,x 					; make float, keep sign
.a037		29 80		and #$80			and 	#$80
.a039		09 08		ora #$08			ora 	#NSTFloat
.a03b		95 50		sta $50,x			sta 	NSStatus,x
.a03d		20 eb a8	jsr $a8eb			jsr 	NSMIsZero 					; if zero exit
.a040		d0 07		bne $a049			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.a042		16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.a044		76 50		ror $50,x			ror 	NSStatus,x 					; (no -0)
.a046		a9 00		lda #$00			lda 	#0 							; set Z flag
.a048		60		rts				rts
.a049						_NSNormaliseOptimise:
.a049		b5 70		lda $70,x			lda 	NSMantissa3,x 				; upper byte zero ?
.a04b		d0 19		bne $a066			bne 	_NSNormaliseLoop
.a04d		b5 68		lda $68,x			lda 	NSMantissa2,x 				; byte normalise
.a04f		30 15		bmi $a066			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.a051		95 70		sta $70,x			sta 	NSMantissa3,x
.a053		b5 60		lda $60,x			lda 	NSMantissa1,x
.a055		95 68		sta $68,x			sta 	NSMantissa2,x
.a057		b5 58		lda $58,x			lda 	NSMantissa0,x
.a059		95 60		sta $60,x			sta 	NSMantissa1,x
.a05b		74 58		stz $58,x			stz 	NSMantissa0,x
.a05d		b5 78		lda $78,x			lda 	NSExponent,x
.a05f		38		sec				sec
.a060		e9 08		sbc #$08			sbc 	#8
.a062		95 78		sta $78,x			sta 	NSExponent,x
.a064		80 e3		bra $a049			bra 	_NSNormaliseOptimise
.a066						_NSNormaliseLoop:
.a066		34 70		bit $70,x			bit 	NSMantissa3,x 				; bit 30 set ?
.a068		70 07		bvs $a071			bvs 	_NSNExit 					; exit if so with Z flag clear
.a06a		20 d8 a8	jsr $a8d8			jsr 	NSMShiftLeft 				; shift mantissa left
.a06d		d6 78		dec $78,x			dec 	NSExponent,x 				; adjust exponent
.a06f		80 f5		bra $a066			bra 	_NSNormaliseLoop
.a071						_NSNExit:
.a071		a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.a073		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignnumber.asm

.a074						AssignNumber:
.a074		5a		phy				phy
.a075		b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy mantissa0/1 to zTemp0
.a077		85 36		sta $36				sta 	zTemp0
.a079		b5 60		lda $60,x			lda 	NSMantissa1,x
.a07b		85 37		sta $37				sta 	zTemp0+1
.a07d		b5 50		lda $50,x			lda 	NSStatus,x 					; clear reference bits
.a07f		29 df		and #$df			and 	#(NSBIsReference ^ $FF)
.a081		95 50		sta $50,x			sta 	NSStatus,x
.a083		29 18		and #$18			and 	#NSBTypeMask				; assigning to a float ?
.a085		c9 08		cmp #$08			cmp 	#NSTFloat
.a087		f0 24		beq $a0ad			beq 	_ANFloat
.a089		b5 79		lda $79,x			lda		NSExponent+1,x 				; is it a float
.a08b		f0 03		beq $a090			beq		_ANNotFloat
.a08d		4c 6a ab	jmp $ab6a			jmp 	RangeError					; if it is, report an error.
.a090						_ANNotFloat:
.a090		b5 50		lda $50,x			lda 	NSStatus,x 					; check if byte/word reference.
.a092		29 03		and #$03			and 	#3
.a094		d0 05		bne $a09b			bne 	_ANByteWord
.a096		20 b8 a0	jsr $a0b8			jsr 	_ANCopy4PackSign 			; copy all 4 bytes and sign
.a099		80 1b		bra $a0b6			bra 	_ANExit
.a09b						_ANByteWord:
.a09b		48		pha				pha 								; save count
.a09c		b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; do byte
.a09e		92 36		sta ($36)			sta 	(zTemp0)
.a0a0		68		pla				pla
.a0a1		c9 01		cmp #$01			cmp	 	#1
.a0a3		f0 11		beq $a0b6			beq 	_ANExit
.a0a5		b5 61		lda $61,x			lda 	NSMantissa1+1,x 			; do word
.a0a7		a0 01		ldy #$01			ldy 	#1
.a0a9		91 36		sta ($36),y			sta 	(zTemp0),y
.a0ab		80 09		bra $a0b6			bra 	_ANExit
.a0ad						_ANFloat:
.a0ad		20 b8 a0	jsr $a0b8			jsr 	_ANCopy4PackSign 			; write all 4 bytes and packed sign
.a0b0		b5 79		lda $79,x			lda 	NSExponent+1,x 				; copy exponent to slot 4
.a0b2		a0 04		ldy #$04			ldy 	#4
.a0b4		91 36		sta ($36),y			sta 	(zTemp0),y
.a0b6						_ANExit:
.a0b6		7a		ply				ply
.a0b7		60		rts				rts
.a0b8						_ANCopy4PackSign:
.a0b8		a0 03		ldy #$03			ldy 	#3
.a0ba		b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign bit into status
.a0bc		29 80		and #$80			and 	#$80 						; put into high bit of mantissa 3
.a0be		15 71		ora $71,x			ora 	NSMantissa3+1,x
.a0c0		91 36		sta ($36),y			sta 	(zTemp0),y
.a0c2		88		dey				dey
.a0c3		b5 69		lda $69,x			lda 	NSMantissa2+1,x
.a0c5		91 36		sta ($36),y			sta 	(zTemp0),y
.a0c7		88		dey				dey
.a0c8		b5 61		lda $61,x			lda 	NSMantissa1+1,x
.a0ca		91 36		sta ($36),y			sta 	(zTemp0),y
.a0cc		88		dey				dey
.a0cd		b5 59		lda $59,x			lda 	NSMantissa0+1,x
.a0cf		91 36		sta ($36),y			sta 	(zTemp0),y
.a0d1		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignstring.asm

.a0d2						AssignString:
.a0d2		5a		phy				phy
.a0d3		b5 59		lda $59,x			lda 	NSMantissa0+1,x
.a0d5		85 38		sta $38				sta 	zTemp1
.a0d7		b5 61		lda $61,x			lda 	NSMantissa1+1,x
.a0d9		85 39		sta $39				sta 	zTemp1+1
.a0db		b5 58		lda $58,x			lda 	NSMantissa0,x
.a0dd		85 36		sta $36				sta 	zTemp0
.a0df		b5 60		lda $60,x			lda 	NSMantissa1,x
.a0e1		85 37		sta $37				sta 	zTemp0+1
.a0e3		a0 01		ldy #$01			ldy 	#1 							; the high byte of the target address
.a0e5		b1 36		lda ($36),y			lda 	(zTemp0),y
.a0e7		f0 23		beq $a10c			beq 	_ASNewStringRequired 		; if zero, a new string is required.
.a0e9		38		sec				sec 								; put Address-2 in zsTemp - this is the size/status/string record
.a0ea		b2 36		lda ($36)			lda 	(zTemp0) 					; of concreted strings
.a0ec		e9 02		sbc #$02			sbc 	#2
.a0ee		85 3c		sta $3c				sta 	zsTemp
.a0f0		a0 01		ldy #$01			ldy 	#1
.a0f2		b1 36		lda ($36),y			lda 	(zTemp0),y
.a0f4		e9 00		sbc #$00			sbc 	#0
.a0f6		85 3d		sta $3d				sta 	zsTemp+1
.a0f8		a0 ff		ldy #$ff			ldy 	#$FF 						; get length of new string
.a0fa						_ASGetLength:
.a0fa		c8		iny				iny
.a0fb		b1 38		lda ($38),y			lda 	(zTemp1),y
.a0fd		d0 fb		bne $a0fa			bne 	_ASGetLength
.a0ff		98		tya				tya 								; is this length <= current length
.a100		d2 3c		cmp ($3c)			cmp 	(zsTemp)
.a102		90 1e		bcc $a122			bcc 	_ASCopyString
.a104		f0 1c		beq $a122			beq 	_ASCopyString
.a106		a9 80		lda #$80			lda 	#$80 						; mark as unused.
.a108		a0 01		ldy #$01			ldy 	#1
.a10a		91 3c		sta ($3c),y			sta 	(zsTemp),y
.a10c						_ASNewStringRequired:
.a10c		e8		inx				inx 								; concrete the new string.
.a10d		20 52 b2	jsr $b252			jsr 	StringConcrete				; (breaks zTemp1/2, not zTemp0 and zsTemp)
.a110		ca		dex				dex
.a111		18		clc				clc
.a112		b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy that new address to the reference.
.a114		69 02		adc #$02			adc 	#2 							; add two to point at the data.
.a116		92 36		sta ($36)			sta 	(zTemp0)
.a118		b5 61		lda $61,x			lda 	NSMantissa1+1,x
.a11a		69 00		adc #$00			adc 	#0
.a11c		a0 01		ldy #$01			ldy 	#1
.a11e		91 36		sta ($36),y			sta 	(zTemp0),y
.a120		80 0d		bra $a12f			bra 	_ASExit
.a122						_ASCopyString:
.a122		a0 00		ldy #$00			ldy 	#0
.a124						_ASCopyLoop:
.a124		b1 38		lda ($38),y			lda 	(zTemp1),y
.a126		c8		iny				iny
.a127		c8		iny				iny
.a128		91 3c		sta ($3c),y			sta 	(zsTemp),y
.a12a		88		dey				dey
.a12b		c9 00		cmp #$00			cmp 	#0
.a12d		d0 f5		bne $a124			bne 	_ASCopyLoop
.a12f						_ASExit:
.a12f		7a		ply				ply
.a130		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/dereference.asm

.a131						DereferenceTopTwo:
.a131		e8		inx				inx
.a132		20 36 a1	jsr $a136			jsr 	Dereference 				; deref x+1
.a135		ca		dex				dex  								; falls through to deref x
.a136						Dereference:
.a136		b5 50		lda $50,x			lda 	NSStatus,x 					; get the status byte
.a138		29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.a13a		f0 48		beq $a184			beq 	_DRFExit 					; not a reference, so exit.
.a13c		5a		phy				phy
.a13d		b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address to dereference into zTemp0
.a13f		85 36		sta $36				sta 	zTemp0
.a141		b5 60		lda $60,x			lda 	NSMantissa1,x
.a143		85 37		sta $37				sta 	zTemp0+1
.a145		74 60		stz $60,x			stz 	NSMantissa1,x 				; clear second byte.
.a147		b2 36		lda ($36)			lda 	(zTemp0) 					; do the first byte
.a149		95 58		sta $58,x			sta 	NSMantissa0,x
.a14b		b5 50		lda $50,x			lda 	NSStatus,x 					; get status byte.
.a14d		29 18		and #$18			and 	#NSBTypeMask 				; what type is it ?
.a14f		c9 10		cmp #$10			cmp 	#NSTString 					; if string, dereference two
.a151		f0 0e		beq $a161			beq 	_DRFDereferenceTwo
.a153		c9 08		cmp #$08			cmp 	#NSTFloat 					; if float, do full dereference.
.a155		f0 2f		beq $a186			beq 	_DRFFull
.a157		b5 50		lda $50,x			lda 	NSStatus,x 					; must be integer - how many bytes ?
.a159		29 03		and #$03			and 	#3
.a15b		f0 29		beq $a186			beq 	_DRFFull 					; the whole word
.a15d		c9 01		cmp #$01			cmp 	#1 							; is it 10 (e.g. 2 bytes)
.a15f		f0 06		beq $a167			beq		_DRFClear23 				; no, one byte, clear 2 & 3 and exit
.a161						_DRFDereferenceTwo:
.a161		a0 01		ldy #$01			ldy 	#1
.a163		b1 36		lda ($36),y			lda 	(zTemp0),y
.a165		95 60		sta $60,x			sta 	NSMantissa1,x
.a167						_DRFClear23:
.a167		74 68		stz $68,x			stz 	NSMantissa2,x 				; clear upper bytes, only read 1 or 2 bytes
.a169		74 70		stz $70,x			stz 	NSMantissa3,x
.a16b		b5 50		lda $50,x			lda 	NSStatus,x 					; make it a value of that type.
.a16d		29 18		and #$18			and 	#NSBTypeMask
.a16f		95 50		sta $50,x			sta 	NSStatus,x 					; and fall through.
.a171		c9 10		cmp #$10			cmp 	#NSTString  				; is it a string
.a173		d0 0e		bne $a183			bne 	_DRFNotString
.a175		b5 58		lda $58,x			lda 	NSMantissa0,x 				; check address is zero
.a177		15 60		ora $60,x			ora 	NSMantissa1,x
.a179		d0 08		bne $a183			bne 	_DRFNotString
.a17b		a9 85		lda #$85			lda 	#_DRFNullString & $FF 		; if so, return reference to ""
.a17d		95 58		sta $58,x			sta 	NSMantissa0,x
.a17f		a9 a1		lda #$a1			lda 	#_DRFNullString >> 8
.a181		95 60		sta $60,x			sta 	NSMantissa1,x
.a183						_DRFNotString
.a183		7a		ply				ply 								; restore Y and exit
.a184						_DRFExit:
.a184		60		rts				rts
.a185						_DRFNullString:
>a185		00						.byte 	0
.a186						_DRFFull:
.a186		a0 01		ldy #$01			ldy 	#1 							; get remaining 3 bytes.
.a188		b1 36		lda ($36),y			lda 	(zTemp0),y
.a18a		95 60		sta $60,x			sta 	NSMantissa1,x
.a18c		c8		iny				iny
.a18d		b1 36		lda ($36),y			lda 	(zTemp0),y
.a18f		95 68		sta $68,x			sta 	NSMantissa2,x
.a191		c8		iny				iny
.a192		b1 36		lda ($36),y			lda 	(zTemp0),y
.a194		95 70		sta $70,x			sta 	NSMantissa3,x
.a196		74 78		stz $78,x			stz 	NSExponent,x 				; clear exponent.
.a198		b5 50		lda $50,x			lda		NSStatus,x 					; see if type is integer
.a19a		29 18		and #$18			and 	#NSBTypeMask  				; type information only
.a19c		95 50		sta $50,x			sta 	NSStatus,x 					; update it back.
.a19e		f0 05		beq $a1a5			beq 	_DRFNoExponent
.a1a0		c8		iny				iny 								; if not, read the exponent as well.
.a1a1		b1 36		lda ($36),y			lda 	(zTemp0),y
.a1a3		95 78		sta $78,x			sta 	NSExponent,x
.a1a5						_DRFNoExponent:
.a1a5		b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the most significant bit set ?
.a1a7		10 0a		bpl $a1b3			bpl 	_DRFExit2 					; if not, then exit.
.a1a9		29 7f		and #$7f			and 	#$7F 						; clear that bit.
.a1ab		95 70		sta $70,x			sta 	NSMantissa3,x
.a1ad		b5 50		lda $50,x			lda 	NSStatus,x 					; set the sign flag
.a1af		09 80		ora #$80			ora 	#NSBIsNegative
.a1b1		95 50		sta $50,x			sta 	NSStatus,x
.a1b3						_DRFExit2:
.a1b3		7a		ply				ply
.a1b4		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/number.asm

=1						ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2						ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3						ESTA_Decimal = 3 							; fractional part.
.a1b5						EncodeNumberStart:
.a1b5		38		sec				sec
.a1b6		80 01		bra $a1b9			bra 	EncodeNumberContinue+1
.a1b8						EncodeNumberContinue:
.a1b8		18		clc				clc
.a1b9						EncodeNumber:
.a1b9		08		php				php 								; save reset flag.
.a1ba		c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.a1bc		f0 12		beq $a1d0			beq 	_ENIsOkay
.a1be		c9 30		cmp #$30			cmp 	#"0"
.a1c0		90 04		bcc $a1c6			bcc 	_ENBadNumber
.a1c2		c9 3a		cmp #$3a			cmp 	#"9"+1
.a1c4		90 0a		bcc $a1d0			bcc 	_ENIsOkay
.a1c6						_ENBadNumber:
.a1c6		28		plp				plp 								; throw saved reset
.a1c7		ad 05 04	lda $0405			lda 	encodeState 				; if in decimal mode, construct final number
.a1ca		c9 03		cmp #$03			cmp 	#ESTA_Decimal
.a1cc		f0 7b		beq $a249			beq 	_ENConstructFinal
.a1ce						_ENFail:
.a1ce		18		clc				clc 								; not allowed
.a1cf		60		rts				rts
.a1d0						_ENIsOkay:
.a1d0		28		plp				plp 								; are we restarting
.a1d1		90 15		bcc $a1e8			bcc 	_ENNoRestart
.a1d3						_ENStartEncode:
.a1d3		c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.a1d5		f0 0c		beq $a1e3			beq 	_ENFirstDP
.a1d7		29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.a1d9		20 cb a8	jsr $a8cb			jsr 	NSMSetByte 					; in single byte mode.
.a1dc		a9 01		lda #$01			lda 	#ESTA_Low
.a1de						_ENExitChange:
.a1de		8d 05 04	sta $0405			sta 	encodeState 				; save new state
.a1e1		38		sec				sec
.a1e2		60		rts				rts
.a1e3						_ENFirstDP:
.a1e3		20 c9 a8	jsr $a8c9			jsr 	NSMSetZero 					; clear integer part
.a1e6		80 3c		bra $a224			bra 	_ESTASwitchFloat			; go straight to float and exi
.a1e8						_ENNoRestart:
.a1e8		48		pha				pha 								; save digit or DP on stack.
.a1e9		ad 05 04	lda $0405			lda 	encodeState 				; get current state
.a1ec		c9 01		cmp #$01			cmp 	#ESTA_Low
.a1ee		f0 09		beq $a1f9			beq  	_ESTALowState
.a1f0		c9 02		cmp #$02			cmp 	#ESTA_High
.a1f2		f0 26		beq $a21a			beq 	_ESTAHighState
.a1f4		c9 03		cmp #$03			cmp 	#ESTA_Decimal
.a1f6		f0 38		beq $a230			beq 	_ESTADecimalState
>a1f8		db						.byte 	$DB 						; causes a break in the emulator
.a1f9						_ESTALowState:
.a1f9		68		pla				pla 								; get value back
.a1fa		c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.a1fc		f0 26		beq $a224			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.a1fe		29 0f		and #$0f			and 	#15 						; make digit
.a200		8d 06 04	sta $0406			sta 	digitTemp 					; save it.
.a203		b5 58		lda $58,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.a205		0a		asl a				asl 	a
.a206		0a		asl a				asl 	a
.a207		75 58		adc $58,x			adc 	NSMantissa0,x
.a209		0a		asl a				asl 	a
.a20a		6d 06 04	adc $0406			adc 	digitTemp
.a20d		95 58		sta $58,x			sta 	NSMantissa0,x
.a20f		c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.a211		90 05		bcc $a218			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.a213		a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.a215		8d 05 04	sta $0405			sta 	encodeState
.a218						_ESTANoSwitch:
.a218		38		sec				sec
.a219		60		rts				rts
.a21a						_ESTAHighState:
.a21a		68		pla				pla 								; get value back
.a21b		c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.a21d		f0 05		beq $a224			beq 	_ESTASwitchFloat
.a21f		20 7d a2	jsr $a27d			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.a222		38		sec				sec
.a223		60		rts				rts
.a224						_ESTASwitchFloat:
.a224		9c 07 04	stz $0407			stz 	decimalCount 				; reset the count of digits - we divide by 10^n at the end.
.a227		e8		inx				inx 								; zero the decimal additive.
.a228		20 c9 a8	jsr $a8c9			jsr 	NSMSetZero
.a22b		ca		dex				dex
.a22c		a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.a22e		80 ae		bra $a1de			bra 	_ENExitChange
.a230						_ESTADecimalState:
.a230		68		pla				pla 								; digit.
.a231		c9 2e		cmp #$2e			cmp 	#"." 						; fail on 2nd decimal point.
.a233		f0 99		beq $a1ce			beq 	_ENFail
.a235		e8		inx				inx 								; put digit into fractional part of X+1
.a236		20 7d a2	jsr $a27d			jsr 	ESTAShiftDigitIntoMantissa
.a239		ca		dex				dex
.a23a		ee 07 04	inc $0407			inc 	decimalCount 				; bump the count of decimals
.a23d		ad 07 04	lda $0407			lda 	decimalCount 				; too many decimal digits.
.a240		c9 0b		cmp #$0b			cmp 	#11
.a242		f0 02		beq $a246			beq 	_ESTADSFail
.a244		38		sec				sec
.a245		60		rts				rts
.a246						_ESTADSFail:
.a246		4c 6a ab	jmp $ab6a			jmp 	RangeError
.a249						_ENConstructFinal:
.a249		ad 07 04	lda $0407			lda 	decimalCount 				; get decimal count
.a24c		f0 2d		beq $a27b			beq 	_ENCFExit 					; no decimals
.a24e		5a		phy				phy
.a24f		0a		asl a				asl 	a 							; x 4 and CLC
.a250		0a		asl a				asl 	a
.a251		6d 07 04	adc $0407			adc 	decimalCount
.a254		a8		tay				tay
.a255		b9 29 ab	lda $ab29,y			lda 	DecimalScalarTable-5,y 		; copy decimal scalar to X+2
.a258		95 5a		sta $5a,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.a25a		b9 2a ab	lda $ab2a,y			lda 	DecimalScalarTable-5+1,y
.a25d		95 62		sta $62,x			sta 	NSMantissa1+2,x
.a25f		b9 2b ab	lda $ab2b,y			lda 	DecimalScalarTable-5+2,y
.a262		95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.a264		b9 2c ab	lda $ab2c,y			lda 	DecimalScalarTable-5+3,y
.a267		95 72		sta $72,x			sta 	NSMantissa3+2,x
.a269		b9 2d ab	lda $ab2d,y			lda 	DecimalScalarTable-5+4,y
.a26c		95 7a		sta $7a,x			sta 	NSExponent+2,x
.a26e		a9 08		lda #$08			lda 	#NSTFloat
.a270		95 52		sta $52,x			sta 	NSStatus+2,x
.a272		7a		ply				ply
.a273		e8		inx				inx 								; multiply decimal const by decimal scalar
.a274		20 03 a0	jsr $a003			jsr 	FloatMultiply
.a277		ca		dex				dex
.a278		20 be 9e	jsr $9ebe			jsr 	FloatAdd 					; add to integer part.
.a27b						_ENCFExit:
.a27b		18		clc				clc 								; reject the digit.
.a27c		60		rts				rts
.a27d						ESTAShiftDigitIntoMantissa:
.a27d		29 0f		and #$0f			and 	#15 						; save digit
.a27f		48		pha				pha
.a280		b5 70		lda $70,x			lda 	NSMantissa3,x 				; push mantissa on stack
.a282		48		pha				pha
.a283		b5 68		lda $68,x			lda 	NSMantissa2,x
.a285		48		pha				pha
.a286		b5 60		lda $60,x			lda 	NSMantissa1,x
.a288		48		pha				pha
.a289		b5 58		lda $58,x			lda 	NSMantissa0,x
.a28b		48		pha				pha
.a28c		20 d8 a8	jsr $a8d8			jsr 	NSMShiftLeft 				; x 2
.a28f		20 d8 a8	jsr $a8d8			jsr 	NSMShiftLeft 				; x 4
.a292		18		clc				clc 								; pop mantissa and add
.a293		68		pla				pla
.a294		75 58		adc $58,x			adc 	NSMantissa0,x
.a296		95 58		sta $58,x			sta 	NSMantissa0,x
.a298		68		pla				pla
.a299		75 60		adc $60,x			adc 	NSMantissa1,x
.a29b		95 60		sta $60,x			sta 	NSMantissa1,x
.a29d		68		pla				pla
.a29e		75 68		adc $68,x			adc 	NSMantissa2,x
.a2a0		95 68		sta $68,x			sta 	NSMantissa2,x
.a2a2		68		pla				pla
.a2a3		75 70		adc $70,x			adc 	NSMantissa3,x
.a2a5		95 70		sta $70,x			sta 	NSMantissa3,x 				; x 5
.a2a7		20 d8 a8	jsr $a8d8			jsr 	NSMShiftLeft 				; x 10
.a2aa		68		pla				pla 								; add digit
.a2ab		18		clc				clc
.a2ac		75 58		adc $58,x			adc 	NSMantissa0,x
.a2ae		95 58		sta $58,x			sta 	NSMantissa0,x
.a2b0		90 0a		bcc $a2bc			bcc 	_ESTASDExit
.a2b2		f6 60		inc $60,x			inc 	NSMantissa1,x
.a2b4		d0 06		bne $a2bc			bne 	_ESTASDExit
.a2b6		f6 68		inc $68,x			inc 	NSMantissa2,x
.a2b8		d0 02		bne $a2bc			bne 	_ESTASDExit
.a2ba		f6 70		inc $70,x			inc 	NSMantissa3,x
.a2bc						_ESTASDExit:
.a2bc		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/term.asm

.a2bd						EvaluateTerm:
.a2bd		b1 30		lda ($30),y			lda 	(codePtr),y
.a2bf		30 18		bmi $a2d9			bmi 	_ETCheckUnary 				; unary function ? (text ones)
.a2c1		c9 40		cmp #$40			cmp 	#$40 						; 40-7F => identifier reference
.a2c3		b0 6c		bcs $a331			bcs 	_ETVariable
.a2c5		c9 30		cmp #$30			cmp 	#'0' 						; is it a number
.a2c7		90 6b		bcc $a334			bcc 	_ETPuncUnary 				; if not it might be a punctuation unary.
.a2c9		c9 3a		cmp #$3a			cmp 	#'9'+1
.a2cb		b0 67		bcs $a334			bcs 	_ETPuncUnary
.a2cd		20 b5 a1	jsr $a1b5			jsr 	EncodeNumberStart 			; can't fail as it's 0-9 !
.a2d0						_ETNumber:
.a2d0		c8		iny				iny 								; keep encoding until we have the numbers
.a2d1		b1 30		lda ($30),y			lda 	(codePtr),y
.a2d3		20 b8 a1	jsr $a1b8			jsr 	EncodeNumberContinue
.a2d6		b0 f8		bcs $a2d0			bcs 	_ETNumber 					; go back if accepted.
.a2d8		60		rts				rts
.a2d9						_ETCheckUnary:
.a2d9		c9 ff		cmp #$ff			cmp 	#KWC_STRING 				; string token
.a2db		f0 3f		beq $a31c			beq 	_ETString
.a2dd		c9 fe		cmp #$fe			cmp 	#KWC_HEXCONST 				; hex constant.
.a2df		f0 12		beq $a2f3			beq 	_ETHexConstant
.a2e1		c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; check it actually is a unary function
.a2e3		90 0b		bcc $a2f0			bcc 	_ETSyntaxError
.a2e5		c9 ad		cmp #$ad			cmp 	#KWC_LAST_UNARY+1
.a2e7		b0 07		bcs $a2f0			bcs 	_ETSyntaxError
.a2e9		da		phx				phx 								; push X on the stack
.a2ea		0a		asl a				asl 	a 							; put vector x 2 into X
.a2eb		aa		tax				tax
.a2ec		c8		iny				iny 								; consume unary function token
.a2ed		7c d8 95	jmp ($95d8,x)			jmp 	(VectorSet0,x) 				; and do it.
.a2f0						_ETSyntaxError:
.a2f0		4c 65 ab	jmp $ab65			jmp 	SyntaxError
.a2f3						_ETHexConstant:
.a2f3		c8		iny				iny 								; skip #
.a2f4		c8		iny				iny 								; skip count
.a2f5		20 c9 a8	jsr $a8c9			jsr 	NSMSetZero 					; clear result
.a2f8						_ETHLoop:
.a2f8		b1 30		lda ($30),y			lda 	(codePtr),y
.a2fa		c8		iny				iny 								; and consume
.a2fb		c9 00		cmp #$00			cmp 	#0 							; exit if zero
.a2fd		f0 1c		beq $a31b			beq 	_ETHExit
.a2ff		48		pha				pha 								; save on stack.
.a300		20 d8 a8	jsr $a8d8			jsr 	NSMShiftLeft 				; x 2
.a303		20 d8 a8	jsr $a8d8			jsr 	NSMShiftLeft 				; x 4
.a306		20 d8 a8	jsr $a8d8			jsr 	NSMShiftLeft 				; x 8
.a309		20 d8 a8	jsr $a8d8			jsr 	NSMShiftLeft 				; x 16
.a30c		68		pla				pla 								; ASCII
.a30d		c9 41		cmp #$41			cmp 	#'A'
.a30f		90 02		bcc $a313			bcc 	_ETHNotChar
.a311		e9 07		sbc #$07			sbc 	#7
.a313						_ETHNotChar:
.a313		29 0f		and #$0f			and 	#15 						; digit now
.a315		15 58		ora $58,x			ora 	NSMantissa0,x 				; put in LS Nibble
.a317		95 58		sta $58,x			sta 	NSMantissa0,x
.a319		80 dd		bra $a2f8			bra 	_ETHLoop 					; go round.
.a31b						_ETHExit:
.a31b		60		rts				rts
.a31c						_ETString:
.a31c		c8		iny				iny 								; look at length
.a31d		b1 30		lda ($30),y			lda 	(codePtr),y
.a31f		48		pha				pha
.a320		c8		iny				iny 								; first character
.a321		20 ec ad	jsr $adec			jsr 	MemoryInline 				; put address of string at (code-Ptr),y on stack
.a324		68		pla				pla 								; restore count and save
.a325		85 36		sta $36				sta 	zTemp0
.a327		98		tya				tya 								; add length to Y to skip it.
.a328		18		clc				clc
.a329		65 36		adc $36				adc 	zTemp0
.a32b		a8		tay				tay
.a32c		a9 10		lda #$10			lda 	#NSTString 					; mark as string
.a32e		95 50		sta $50,x			sta 	NSStatus,x
.a330		60		rts				rts
.a331						_ETVariable:
.a331		4c 86 a3	jmp $a386			jmp 	VariableHandler
.a334						_ETPuncUnary:
.a334		c8		iny				iny 								; consume the unary character
.a335		c9 2d		cmp #$2d			cmp 	#KWD_MINUS 					; unary minus
.a337		f0 2b		beq $a364			beq 	_ETUnaryNegate
.a339		c9 b8		cmp #$b8			cmp 	#KWD_AT 					; @ reference -> constant
.a33b		f0 36		beq $a373			beq 	_ETDereference
.a33d		c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; parenthesis
.a33f		f0 3e		beq $a37f			beq 	_ETParenthesis
.a341		64 36		stz $36				stz 	zTemp0 						; zTemp0 is the indirection level.
.a343		c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; byte indirection (0) ?
.a345		f0 06		beq $a34d			beq 	_ETIndirection
.a347		e6 36		inc $36				inc 	zTemp0
.a349		c9 21		cmp #$21			cmp 	#KWD_PLING					; word indirection (1) \
.a34b		d0 a3		bne $a2f0			bne 	_ETSyntaxError
.a34d						_ETIndirection:
.a34d		a5 36		lda $36				lda 	zTemp0 						; push indirection amount (0-1) => (1-2) on the stack
.a34f		1a		inc a				inc 	a
.a350		48		pha				pha
.a351		20 bd a2	jsr $a2bd			jsr 	EvaluateTerm				; evaluate the term
.a354		20 36 a1	jsr $a136			jsr 	Dereference 				; dereference it.
.a357		b5 50		lda $50,x			lda 	NSStatus,x 					; must be a +ve integer.
.a359		d0 06		bne $a361			bne 	_ETTypeMismatch
.a35b		68		pla				pla 								; indirection 1-2
.a35c		09 20		ora #$20			ora 	#NSBIsReference 			; make it a reference.
.a35e		95 50		sta $50,x			sta 	NSStatus,x
.a360		60		rts				rts
.a361						_ETTypeMismatch:
.a361		4c 6f ab	jmp $ab6f			jmp 	TypeError
.a364						_ETUnaryNegate:
.a364		20 bd a2	jsr $a2bd			jsr 	EvaluateTerm				; evaluate the term
.a367		20 36 a1	jsr $a136			jsr 	Dereference 				; dereference it.
.a36a		b5 50		lda $50,x			lda 	NSStatus,x 					; must be a number
.a36c		29 10		and #$10			and 	#NSTString
.a36e		d0 f1		bne $a361			bne 	_ETTypeMismatch
.a370		4c 8b a8	jmp $a88b			jmp 	NSMNegate  					; just toggles the sign bit.
.a373						_ETDereference:
.a373		20 bd a2	jsr $a2bd			jsr 	EvaluateTerm				; evaluate the term
.a376		b5 50		lda $50,x			lda 	NSStatus,x 					; must be a reference
.a378		29 20		and #$20			and 	#NSBIsReference
.a37a		f0 e5		beq $a361			beq 	_ETTypeMismatch
.a37c		74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer address
.a37e		60		rts				rts
.a37f						_ETParenthesis:
.a37f		20 73 9e	jsr $9e73			jsr 	EvaluateExpression 			; evaluate here, from lowest precedence
.a382		20 50 99	jsr $9950			jsr 	CheckRightBracket 			; check for )
.a385		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/variable.asm

.a386						VariableHandler:
.a386		b1 30		lda ($30),y			lda 	(codePtr),y
.a388		18		clc				clc
.a389		69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.a38b		85 37		sta $37				sta 	zTemp0+1
.a38d		c8		iny				iny
.a38e		b1 30		lda ($30),y			lda 	(codePtr),y
.a390		85 36		sta $36				sta 	zTemp0
.a392		c8		iny				iny
.a393		18		clc				clc									; copy variable address+3 to mantissa
.a394		69 03		adc #$03			adc 	#3 							; this is the address of the data.
.a396		95 58		sta $58,x			sta 	NSMantissa0,x
.a398		a5 37		lda $37				lda 	zTemp0+1
.a39a		69 00		adc #$00			adc 	#0
.a39c		95 60		sta $60,x			sta 	NSMantissa1,x
.a39e		74 68		stz $68,x			stz 	NSMantissa2,x
.a3a0		74 70		stz $70,x			stz 	NSMantissa3,x
.a3a2		74 78		stz $78,x			stz 	NSExponent,x
.a3a4		5a		phy				phy
.a3a5		a0 02		ldy #$02			ldy 	#2 							; read type
.a3a7		b1 36		lda ($36),y			lda 	(zTemp0),y
.a3a9		7a		ply				ply
.a3aa		29 1c		and #$1c			and 	#NSBTypeMask+NSBIsArray 	; get type information
.a3ac		09 20		ora #$20			ora 	#NSBIsReference 			; make a reference.
.a3ae		95 50		sta $50,x			sta 	NSStatus,x
.a3b0		29 04		and #$04			and 	#NSBIsArray
.a3b2		d0 01		bne $a3b5			bne 	_VHArray
.a3b4		60		rts				rts
.a3b5						_VHArray:
.a3b5		e8		inx				inx
.a3b6		20 64 a8	jsr $a864			jsr 	Evaluate8BitInteger 		; get the 1st index.
.a3b9		a9 ff		lda #$ff			lda 	#$FF 						; set Status of X+2 to a duff value so we know if we picked it up.
.a3bb		95 51		sta $51,x			sta 	NSStatus+1,x
.a3bd		b1 30		lda ($30),y			lda 	(codePtr),y
.a3bf		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.a3c1		d0 06		bne $a3c9			bne 	_VHNoSecondIndex
.a3c3		c8		iny				iny 								; skip the comma
.a3c4		e8		inx				inx
.a3c5		20 64 a8	jsr $a864			jsr 	Evaluate8BitInteger 		; get the 2nd index.
.a3c8		ca		dex				dex
.a3c9						_VHNoSecondIndex:
.a3c9		ca		dex				dex 								; set X back.
.a3ca		20 50 99	jsr $9950			jsr 	CheckRightBracket 			; and check the right bracket.
.a3cd		5a		phy				phy 								; save position
.a3ce		b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy record address to zaTemp (moved 6/12/22)
.a3d0		85 3e		sta $3e				sta 	zaTemp
.a3d2		b5 60		lda $60,x			lda 	NSMantissa1,x
.a3d4		85 3f		sta $3f				sta 	zaTemp+1
.a3d6		a0 02		ldy #$02			ldy 	#2 							; check first index is not-zero, e.g. array defined
.a3d8		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.a3da		f0 5d		beq $a439			beq 	_VHBadArray
.a3dc		a0 03		ldy #$03			ldy 	#3 							; get the second index - which is 0 if there is one index.
.a3de		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.a3e0		f0 02		beq $a3e4			beq 	_VHHas2Mask
.a3e2		a9 ff		lda #$ff			lda 	#$FF
.a3e4						_VHHas2Mask:
.a3e4		d5 52		cmp $52,x			cmp 	NSStatus+2,x 				; so if they are the same there are the wrong number of indices
.a3e6		f0 4c		beq $a434			beq 	_VHBadIndex
.a3e8		0a		asl a				asl 	a 							; carry will be set if a second index
.a3e9		90 08		bcc $a3f3			bcc 	_VHCheckFirstIndex
.a3eb		a0 03		ldy #$03			ldy 	#3 			 				; check the 2nd size >= 2nd index
.a3ed		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.a3ef		d5 5a		cmp $5a,x			cmp 	NSMantissa0+2,x
.a3f1		90 41		bcc $a434			bcc 	_VHBadIndex
.a3f3						_VHCheckFirstIndex:
.a3f3		a0 02		ldy #$02			ldy 	#2 			 				; check the 2nd size >= 2nd index
.a3f5		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.a3f7		d5 59		cmp $59,x			cmp 	NSMantissa0+1,x
.a3f9		90 39		bcc $a434			bcc 	_VHBadIndex
.a3fb		64 36		stz $36				stz 	zTemp0 						; clear zTemp0 (if 1 index)
.a3fd		64 37		stz $37				stz 	zTemp0+1
.a3ff		b5 52		lda $52,x			lda 	NSStatus+2,x 				; if only one index provided, don't need to multiply
.a401		30 0e		bmi $a411			bmi 	_VHNoMultiply
.a403		da		phx				phx
.a404		b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; get 2nd index on stack
.a406		48		pha				pha
.a407		a0 02		ldy #$02			ldy 	#2 							; get 1st size in A
.a409		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.a40b		1a		inc a				inc 	a 							; add 1 for zero base
.a40c		fa		plx				plx
.a40d		20 74 a8	jsr $a874			jsr 	Multiply8x8 				; calculate -> Z0
.a410		fa		plx				plx
.a411						_VHNoMultiply:
.a411		18		clc				clc
.a412		a5 36		lda $36				lda 	zTemp0
.a414		75 59		adc $59,x			adc 	NSMantissa0+1,x
.a416		85 36		sta $36				sta 	zTemp0
.a418		a5 37		lda $37				lda 	zTemp0+1
.a41a		69 00		adc #$00			adc 	#0
.a41c		85 37		sta $37				sta 	zTemp0+1
.a41e		b5 50		lda $50,x			lda 	NSStatus,x
.a420		20 ba 88	jsr $88ba			jsr 	ScaleByBaseType
.a423		18		clc				clc
.a424		b2 3e		lda ($3e)			lda 	(zaTemp)
.a426		65 36		adc $36				adc 	zTemp0
.a428		95 58		sta $58,x			sta 	NSMantissa0,x
.a42a		a0 01		ldy #$01			ldy 	#1
.a42c		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.a42e		65 37		adc $37				adc 	zTemp0+1
.a430		95 60		sta $60,x			sta 	NSMantissa1,x
.a432		7a		ply				ply 								; restore position
.a433		60		rts				rts
.a434						_VHBadIndex:
.a434		a9 17		lda #$17		lda	#23
.a436		4c 69 99	jmp $9969		jmp	ErrorHandler
.a439						_VHBadArray:
.a439		a9 18		lda #$18		lda	#24
.a43b		4c 69 99	jmp $9969		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/abs.asm

.a43e						AbsUnary:
.a43e		fa		plx				plx 								; restore stack pos
.a43f		20 17 a8	jsr $a817			jsr 	EvaluateNumber 				; get a float or int
.a442		20 50 99	jsr $9950			jsr 	CheckRightBracket
.a445		b5 50		lda $50,x			lda 	NSStatus,x 					; clear the sign bit
.a447		29 7f		and #$7f			and 	#$7F
.a449		95 50		sta $50,x			sta 	NSStatus,x
.a44b		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/alloc.asm

.a44c						AllocUnary:
.a44c		fa		plx				plx 								; restore stack pos
.a44d		20 49 a8	jsr $a849			jsr 	Evaluate16BitInteger		; get bytes required.
.a450		20 50 99	jsr $9950			jsr 	CheckRightBracket
.a453		da		phx				phx 								; save X/Y
.a454		5a		phy				phy
.a455		8a		txa				txa 								; copy X into Y
.a456		a8		tay				tay
.a457		b9 60 00	lda $0060,y			lda		NSMantissa1,y 				; get size into XA
.a45a		aa		tax				tax
.a45b		b9 58 00	lda $0058,y			lda 	NSMantissa0,y
.a45e		20 6b a4	jsr $a46b			jsr 	AllocateXABytes 			; allocate memory
.a461		99 58 00	sta $0058,y			sta 	NSMantissa0,y 				; write address out.
.a464		8a		txa				txa 	 							; typing is 16 bit integer.
.a465		99 60 00	sta $0060,y			sta 	NSMantissa1,y
.a468		7a		ply				ply
.a469		fa		plx				plx
.a46a		60		rts				rts
.a46b						AllocateXABytes:
.a46b		5a		phy				phy
.a46c		ac 08 04	ldy $0408			ldy 	lowMemPtr 					; push current address on stack and to zTemp0
.a46f		84 36		sty $36				sty 	zTemp0
.a471		5a		phy				phy
.a472		ac 09 04	ldy $0409			ldy 	lowMemPtr+1
.a475		84 37		sty $37				sty 	zTemp0+1
.a477		5a		phy				phy
.a478		18		clc				clc 								; add to low memory pointer
.a479		6d 08 04	adc $0408			adc 	lowMemPtr
.a47c		8d 08 04	sta $0408			sta 	lowMemPtr
.a47f		8a		txa				txa
.a480		6d 09 04	adc $0409			adc 	lowMemPtr+1
.a483		8d 09 04	sta $0409			sta 	lowMemPtr+1
.a486		b0 2f		bcs $a4b7			bcs 	CISSMemory
.a488		20 a9 a4	jsr $a4a9			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.a48b						_ClearMemory:
.a48b		ad 08 04	lda $0408			lda 	lowMemPtr 					; cleared all memory allocated
.a48e		c5 36		cmp $36				cmp 	zTemp0
.a490		d0 07		bne $a499			bne 	_CMClearNext
.a492		ad 09 04	lda $0409			lda 	lowMemPtr+1
.a495		c5 37		cmp $37				cmp 	zTemp0+1
.a497		f0 0c		beq $a4a5			beq 	_CMExit
.a499						_CMClearNext:
.a499		a9 00		lda #$00			lda 	#0 							; clear byte, advance to next.
.a49b		92 36		sta ($36)			sta 	(zTemp0)
.a49d		e6 36		inc $36				inc 	zTemp0
.a49f		d0 ea		bne $a48b			bne 	_ClearMemory
.a4a1		e6 37		inc $37				inc		zTemp0+1
.a4a3		80 e6		bra $a48b			bra 	_ClearMemory
.a4a5						_CMExit:
.a4a5		fa		plx				plx
.a4a6		68		pla				pla
.a4a7		7a		ply				ply
.a4a8		60		rts				rts
.a4a9						CheckIdentifierStringSpace:
.a4a9		48		pha				pha
.a4aa		ad 09 04	lda $0409			lda 	lowMemPtr+1 				; get low memory pointer
.a4ad		18		clc				clc
.a4ae		69 02		adc #$02			adc 	#2 							; need at least 2 256 byte pages
.a4b0		cd 0b 04	cmp $040b			cmp 	stringMemory+1 				; is it >= StringMemory
.a4b3		b0 02		bcs $a4b7			bcs 	CISSMemory
.a4b5		68		pla				pla
.a4b6		60		rts				rts
.a4b7						CISSMemory:
.a4b7		a9 06		lda #$06		lda	#6
.a4b9		4c 69 99	jmp $9969		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/asc.asm

.a4bc						AscUnary:
.a4bc		fa		plx				plx 								; restore stack pos
.a4bd		20 21 a8	jsr $a821			jsr 	EvaluateString 				; get a string
.a4c0		b2 36		lda ($36)			lda 	(zTemp0)					; get/return first character
.a4c2		20 cb a8	jsr $a8cb			jsr 	NSMSetByte 					; ASC("") will return zero.
.a4c5		20 50 99	jsr $9950			jsr 	CheckRightBracket
.a4c8		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/frac.asm

.a4c9						FracUnary:
.a4c9		fa		plx				plx 								; restore stack pos
.a4ca		20 17 a8	jsr $a817			jsr 	EvaluateNumber 				; get a float or int
.a4cd		20 50 99	jsr $9950			jsr 	CheckRightBracket
.a4d0		b5 50		lda $50,x			lda 	NSStatus,x
.a4d2		29 08		and #$08			and 	#NSTFloat 					; check it is a float
.a4d4		f0 04		beq $a4da			beq 	_IUZero
.a4d6		20 84 9f	jsr $9f84			jsr 	FloatFractionalPart 		; if so, get the fractional part.
.a4d9		60		rts				rts
.a4da						_IUZero:
.a4da		20 c9 a8	jsr $a8c9			jsr 	NSMSetZero
.a4dd		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/int.asm

.a4de						IntUnary:
.a4de		fa		plx				plx 								; restore stack pos
.a4df		20 17 a8	jsr $a817			jsr 	EvaluateNumber 				; get a float or int
.a4e2		20 50 99	jsr $9950			jsr 	CheckRightBracket
.a4e5		b5 50		lda $50,x			lda 	NSStatus,x
.a4e7		29 08		and #$08			and 	#NSTFloat 					; check it is a float
.a4e9		f0 03		beq $a4ee			beq 	_IUExit
.a4eb		20 dc 9f	jsr $9fdc			jsr 	FloatIntegerPart 			; if it is get the integer part.
.a4ee						_IUExit:
.a4ee		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/len.asm

.a4ef						LenUnary:
.a4ef		fa		plx				plx 								; restore stack pos
.a4f0		20 21 a8	jsr $a821			jsr 	EvaluateString 				; get a string
.a4f3		5a		phy				phy
.a4f4		a0 00		ldy #$00			ldy 	#0 							; find length
.a4f6						_LenFind:
.a4f6		b1 36		lda ($36),y			lda 	(zTemp0),y 					; look for trailing NULL.
.a4f8		f0 06		beq $a500			beq 	_LenExit
.a4fa		c8		iny				iny
.a4fb		d0 f9		bne $a4f6			bne 	_LenFind
.a4fd		4c 6a ab	jmp $ab6a			jmp 	RangeError 					; string > 255 - no trailing NULL.
.a500						_LenExit:
.a500		98		tya				tya		 							; return length
.a501		20 cb a8	jsr $a8cb			jsr 	NSMSetByte
.a504		7a		ply				ply
.a505		20 50 99	jsr $9950			jsr 	CheckRightBracket
.a508		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/minmax.asm

.a509						Unary_Min:
.a509		a9 01		lda #$01			lda 	#1
.a50b		80 02		bra $a50f			bra 	UnaryMinMaxMain
.a50d						Unary_Max:
.a50d		a9 ff		lda #$ff			lda 	#$FF 						; value from comparator to cause a write
.a50f						UnaryMinMaxMain:
.a50f		fa		plx				plx 								; get index on number stack
.a510		48		pha				pha 								; save comparator
.a511		20 0e a8	jsr $a80e			jsr 	EvaluateValue 				; get the first value.
.a514						_UMMMLoop:
.a514		b1 30		lda ($30),y			lda 	(codePtr),y
.a516		c9 29		cmp #$29			cmp 	#KWD_RPAREN 				; if right bracket then done.
.a518		f0 22		beq $a53c			beq 	_UMMMDone
.a51a		20 58 99	jsr $9958			jsr 	CheckComma 					; must be a comma
.a51d		e8		inx				inx
.a51e		20 0e a8	jsr $a80e			jsr 	EvaluateValue
.a521		ca		dex				dex
.a522		20 ac a8	jsr $a8ac			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] (Compare is destructive)
.a525		e8		inx				inx
.a526		20 ac a8	jsr $a8ac			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2], original
.a529		e8		inx				inx
.a52a		20 26 9a	jsr $9a26			jsr 	CompareBaseCode 			; part of > = < etc. code, returns 255,0 or 1
.a52d		ca		dex				dex
.a52e		ca		dex				dex
.a52f		85 36		sta $36				sta 	zTemp0 						; save required result
.a531		68		pla				pla 								; get and save comparator
.a532		48		pha				pha
.a533		c5 36		cmp $36				cmp 	zTemp0 						; if the comparator
.a535		d0 dd		bne $a514			bne 	_UMMMLoop
.a537		20 3f a5	jsr $a53f			jsr 	ExpCopyAboveDown 			; copy next up slot down
.a53a		80 d8		bra $a514			bra 	_UMMMLoop
.a53c						_UMMMDone:
.a53c		68		pla				pla 								; throw the comparator
.a53d		c8		iny				iny 								; skip )
.a53e		60		rts				rts
.a53f						ExpCopyAboveDown:
.a53f		b5 51		lda $51,x			lda 	NSStatus+1,x
.a541		95 50		sta $50,x			sta 	NSStatus,x
.a543		b5 79		lda $79,x			lda 	NSExponent+1,x
.a545		95 78		sta $78,x			sta 	NSExponent,x
.a547		b5 59		lda $59,x			lda 	NSMantissa0+1,x
.a549		95 58		sta $58,x			sta 	NSMantissa0,x
.a54b		b5 61		lda $61,x			lda 	NSMantissa1+1,x
.a54d		95 60		sta $60,x			sta 	NSMantissa1,x
.a54f		b5 69		lda $69,x			lda 	NSMantissa2+1,x
.a551		95 68		sta $68,x			sta 	NSMantissa2,x
.a553		b5 71		lda $71,x			lda 	NSMantissa3+1,x
.a555		95 70		sta $70,x			sta 	NSMantissa3,x
.a557		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/not.asm

.a558						Unary_Not:
.a558		fa		plx				plx
.a559		20 36 a8	jsr $a836			jsr 	EvaluateInteger 			; get integer
.a55c		20 50 99	jsr $9950			jsr 	CheckRightBracket
.a55f		20 eb a8	jsr $a8eb			jsr 	NSMIsZero 					; zero mantissa ?
.a562		f0 04		beq $a568			beq 	_NotZero
.a564		20 c9 a8	jsr $a8c9			jsr 	NSMSetZero
.a567		60		rts				rts
.a568						_NotZero:
.a568		4c dc 99	jmp $99dc			jmp 	ReturnTrue

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/peek.asm

.a56b						PeekByteUnary:
.a56b		a9 01		lda #$01			lda 	#1
.a56d		80 0a		bra $a579			bra 	PeekUnary
.a56f						PeekWUnary:
.a56f		a9 02		lda #$02			lda 	#2
.a571		80 06		bra $a579			bra 	PeekUnary
.a573						PeekLUnary:
.a573		a9 03		lda #$03			lda 	#3
.a575		80 02		bra $a579			bra 	PeekUnary
.a577						PeekDUnary:
.a577		a9 04		lda #$04			lda 	#4
.a579						PeekUnary:
.a579		fa		plx				plx 								; restore position.
.a57a		48		pha				pha 								; save count to copy on stack
.a57b		20 49 a8	jsr $a849			jsr		Evaluate16BitInteger 		; address as constant.
.a57e		20 50 99	jsr $9950			jsr 	CheckRightBracket
.a581		b5 58		lda $58,x			lda 	NSMantissa0,x 				; save mantissa in zTemp0 as address
.a583		85 36		sta $36				sta 	zTemp0
.a585		b5 60		lda $60,x			lda 	NSMantissa1,x
.a587		85 37		sta $37				sta 	zTemp0+1
.a589		20 c9 a8	jsr $a8c9			jsr 	NSMSetZero 					; clear the result to zero.
.a58c		68		pla				pla 								; count in zTemp2
.a58d		85 3a		sta $3a				sta 	zTemp2
.a58f		da		phx				phx 								; save stack position and offset of read
.a590		5a		phy				phy
.a591		a0 00		ldy #$00			ldy 	#0 							; byte read offset.
.a593						_PULoop:
.a593		b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next byte, write to mantissa0,x
.a595		95 58		sta $58,x			sta 	NSMantissa0,x 				; we change X not the index before it.
.a597		c8		iny				iny 								; next byte to write
.a598		8a		txa				txa 								; next byte to read - stack layout in 04data.inc
.a599		18		clc				clc
.a59a		69 08		adc #$08			adc 	#MathStackSize
.a59c		aa		tax				tax
.a59d		c6 3a		dec $3a				dec 	zTemp2 						; done them all
.a59f		d0 f2		bne $a593			bne 	_PULoop
.a5a1		7a		ply				ply 								; restore stack/code pos and exit.
.a5a2		fa		plx				plx
.a5a3		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/sgn.asm

.a5a4						SgnUnary:
.a5a4		fa		plx				plx 								; restore stack pos
.a5a5		20 17 a8	jsr $a817			jsr 	EvaluateNumber 				; get a float or int
.a5a8		20 50 99	jsr $9950			jsr 	CheckRightBracket
.a5ab		20 eb a8	jsr $a8eb			jsr 	NSMIsZero 					; if zero
.a5ae		f0 0e		beq $a5be			beq 	_SGZero  					; return Int Zero
.a5b0		b5 50		lda $50,x			lda 	NSStatus,x 					; get status w/sign
.a5b2		48		pha				pha
.a5b3		a9 01		lda #$01			lda 	#1 							; set to 1
.a5b5		20 cb a8	jsr $a8cb			jsr 	NSMSetByte
.a5b8		68		pla				pla
.a5b9		29 80		and #$80			and		#$80 						; copy the sign byte out
.a5bb		95 50		sta $50,x			sta 	NSStatus,x  				; so it will be -1 or 1
.a5bd		60		rts				rts
.a5be		20 c9 a8	jsr $a8c9	_SGZero:jsr 	NSMSetZero
.a5c1		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/val.asm

.a5c2						ValUnary:
.a5c2		fa		plx				plx 								; restore stack pos
.a5c3		20 d8 a5	jsr $a5d8			jsr 	ValMainCode 				; do the main val() code
.a5c6		b0 01		bcs $a5c9			bcs 	_VUError 					; couldn't convert
.a5c8		60		rts				rts
.a5c9						_VUError:
.a5c9		4c 6f ab	jmp $ab6f			jmp 	TypeError
.a5cc						IsValUnary:
.a5cc		fa		plx				plx 								; restore stack pos
.a5cd		20 d8 a5	jsr $a5d8			jsr 	ValMainCode 				; do the main val() code
.a5d0		b0 03		bcs $a5d5			bcs 	_VUBad
.a5d2		4c dc 99	jmp $99dc			jmp 	ReturnTrue
.a5d5						_VUBad:
.a5d5		4c e7 99	jmp $99e7			jmp 	ReturnFalse
.a5d8						ValMainCode:
.a5d8		20 21 a8	jsr $a821			jsr 	EvaluateString 				; get a string
.a5db		20 50 99	jsr $9950			jsr 	CheckRightBracket 			; check right bracket present
.a5de						ValEvaluateZTemp0:
.a5de		5a		phy				phy
.a5df		b2 36		lda ($36)			lda 	(zTemp0) 					; check not empty string
.a5e1		f0 17		beq $a5fa			beq 	_VMCFail2
.a5e3		a0 ff		ldy #$ff			ldy 	#$FF 						; start position
.a5e5		48		pha				pha 								; save first character
.a5e6		c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.a5e8		d0 01		bne $a5eb			bne 	_VMCStart
.a5ea		c8		iny				iny 								; skip over -
.a5eb						_VMCStart:
.a5eb		38		sec				sec 								; initialise first time round.
.a5ec						_VMCNext:
.a5ec		c8		iny				iny 								; pre-increment
.a5ed		b1 36		lda ($36),y			lda 	(zTemp0),y 					; next character = EOS ?
.a5ef		f0 0c		beq $a5fd			beq 	_VMCSuccess 				; successful.
.a5f1		20 b9 a1	jsr $a1b9			jsr 	EncodeNumber 				; send it to the number-builder
.a5f4		90 03		bcc $a5f9			bcc 	_VMCFail 					; if failed, give up.
.a5f6		18		clc				clc 								; next time round, countinue
.a5f7		80 f3		bra $a5ec			bra 	_VMCNext
.a5f9						_VMCFail:
.a5f9		68		pla				pla
.a5fa						_VMCFail2:
.a5fa		7a		ply				ply
.a5fb		38		sec				sec
.a5fc		60		rts				rts
.a5fd						_VMCSuccess:
.a5fd		a9 00		lda #$00			lda 	#0 							; construct final
.a5ff		20 b9 a1	jsr $a1b9			jsr 	EncodeNumber 				; by sending a duff value.
.a602		68		pla				pla 								; if it was -ve
.a603		c9 2d		cmp #$2d			cmp 	#"-"
.a605		d0 03		bne $a60a			bne 	_VMCNotNegative
.a607		20 8b a8	jsr $a88b			jsr		NSMNegate 					; negate it.
.a60a						_VMCNotNegative:
.a60a		7a		ply				ply
.a60b		18		clc				clc
.a60c		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/chr.asm

.a60d						ChrUnary:
.a60d		fa		plx				plx 								; restore stack pos
.a60e		20 64 a8	jsr $a864			jsr 	Evaluate8BitInteger			; get value (chr$(0) returns an empty string)
.a611		48		pha				pha
.a612		20 50 99	jsr $9950			jsr 	CheckRightBracket
.a615		a9 01		lda #$01			lda 	#1 							; allocate space for one char
.a617		20 cf b2	jsr $b2cf			jsr 	StringTempAllocate
.a61a		68		pla				pla 								; write number to it
.a61b		20 08 b3	jsr $b308			jsr 	StringTempWrite
.a61e		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/items.asm

.a61f						ItemCountUnary:
.a61f		fa		plx				plx
.a620		20 21 a8	jsr $a821			jsr 	EvaluateString
.a623		e8		inx				inx
.a624		20 97 a6	jsr $a697			jsr 	ICGetSeperator
.a627		ca		dex				dex
.a628		20 b8 a6	jsr $a6b8			jsr 	ICSetPointer 				; zTemp0 = (string)
.a62b		20 c9 a8	jsr $a8c9			jsr 	NSMSetZero 					; zero the result.
.a62e		5a		phy				phy
.a62f		a0 ff		ldy #$ff			ldy 	#$FF 						; loop counting seperators in mantissa
.a631						_ICULoop:
.a631		c8		iny				iny
.a632		b1 36		lda ($36),y			lda 	(zTemp0),y
.a634		cd a3 07	cmp $07a3			cmp 	ICSeperator
.a637		d0 02		bne $a63b			bne 	_ICUNoMatch
.a639		f6 58		inc $58,x			inc 	NSMantissa0,x
.a63b						_ICUNoMatch:
.a63b		c9 00		cmp #$00			cmp 	#0
.a63d		d0 f2		bne $a631			bne 	_ICULoop
.a63f		f6 58		inc $58,x			inc 	NSMantissa0,x 				; +1
.a641		7a		ply				ply
.a642		60		rts				rts
.a643						ItemGetUnary:
.a643		fa		plx				plx
.a644		20 21 a8	jsr $a821			jsr 	EvaluateString 				; search string
.a647		20 58 99	jsr $9958			jsr 	CheckComma
.a64a		e8		inx				inx 								; get count
.a64b		20 64 a8	jsr $a864			jsr 	Evaluate8BitInteger
.a64e		c9 00		cmp #$00			cmp 	#0 							; must be > 0, index starts at 1.
.a650		f0 61		beq $a6b3			beq 	ICGSRange
.a652		e8		inx				inx 								; get seperator.
.a653		20 97 a6	jsr $a697			jsr 	ICGetSeperator
.a656		ca		dex				dex
.a657		ca		dex				dex
.a658		5a		phy				phy
.a659		20 b8 a6	jsr $a6b8			jsr 	ICSetPointer 				; zTemp0 points to string.
.a65c		a0 00		ldy #$00			ldy 	#0
.a65e		d6 59		dec $59,x			dec 	NSMantissa0+1,x 			; first element.
.a660		f0 0e		beq $a670			beq 	_IGUFoundStart
.a662						_IGUFindNext:
.a662		b1 36		lda ($36),y			lda 	(zTemp0),y		 			; next
.a664		f0 4d		beq $a6b3			beq 	ICGSRange 					; eol, not found.
.a666		c8		iny				iny
.a667		cd a3 07	cmp $07a3			cmp 	ICSeperator 				; until found a seperator (or EOS)
.a66a		d0 f6		bne $a662			bne 	_IGUFindNext
.a66c		d6 59		dec $59,x			dec 	NSMantissa0+1,x
.a66e		d0 f2		bne $a662			bne 	_IGUFindNext
.a670						_IGUFoundStart:
.a670		84 38		sty $38				sty 	zTemp1 						; save start
.a672		88		dey				dey
.a673						_IGUFindLength:
.a673		c8		iny				iny 								; forward till seperator/EOS
.a674		b1 36		lda ($36),y			lda 	(zTemp0),y
.a676		f0 05		beq $a67d			beq 	_IGUFoundLength
.a678		cd a3 07	cmp $07a3			cmp 	ICSeperator
.a67b		d0 f6		bne $a673			bne 	_IGUFindLength
.a67d						_IGUFoundLength:
.a67d		84 39		sty $39				sty 	zTemp1+1 					; save end of copy string
.a67f		98		tya				tya 								; calculate length of new string.
.a680		38		sec				sec
.a681		e5 38		sbc $38				sbc 	zTemp1
.a683		20 cf b2	jsr $b2cf			jsr 	StringTempAllocate 			; allocate bytes for it.
.a686		a4 38		ldy $38				ldy 	zTemp1
.a688						_IGUCopySub:
.a688		c4 39		cpy $39				cpy 	zTemp1+1
.a68a		f0 08		beq $a694			beq 	_IGUCopyOver
.a68c		b1 36		lda ($36),y			lda 	(zTemp0),y
.a68e		20 08 b3	jsr $b308			jsr 	StringTempWrite
.a691		c8		iny				iny
.a692		80 f4		bra $a688			bra 	_IGUCopySub
.a694						_IGUCopyOver:
.a694		7a		ply				ply
.a695		60		rts				rts
>a696		db						.byte 	$DB 						; causes a break in the emulator
.a697						ICGetSeperator:
.a697		20 58 99	jsr $9958			jsr 	CheckComma 					; preceding comma
.a69a		20 21 a8	jsr $a821			jsr 	EvaluateString 				; seperator string
.a69d		20 b8 a6	jsr $a6b8			jsr 	ICSetPointer 				; access it
.a6a0		b2 36		lda ($36)			lda 	(zTemp0) 					; get sep char
.a6a2		8d a3 07	sta $07a3			sta 	ICSeperator
.a6a5		f0 0c		beq $a6b3			beq 	ICGSRange 					; check LEN(seperator) = 1
.a6a7		5a		phy				phy
.a6a8		a0 01		ldy #$01			ldy 	#1
.a6aa		b1 36		lda ($36),y			lda 	(zTemp0),y
.a6ac		d0 05		bne $a6b3			bne 	ICGSRange
.a6ae		7a		ply				ply
.a6af		20 50 99	jsr $9950			jsr 	CheckRightBracket 			; check following )
.a6b2		60		rts				rts
.a6b3						ICGSRange:
.a6b3		a9 04		lda #$04		lda	#4
.a6b5		4c 69 99	jmp $9969		jmp	ErrorHandler
.a6b8						ICSetPointer:
.a6b8		b5 58		lda $58,x			lda 	NSMantissa0,x 				; set zTemp0 to point to it.
.a6ba		85 36		sta $36				sta 	zTemp0
.a6bc		b5 60		lda $60,x			lda 	NSMantissa1,x
.a6be		85 37		sta $37				sta 	zTemp0+1
.a6c0		60		rts				rts
.07a3						ICSeperator:
>07a3								.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/spc.asm

.a6c1						SpcUnary:
.a6c1		fa		plx				plx 								; restore stack pos
.a6c2		20 64 a8	jsr $a864			jsr 	Evaluate8BitInteger			; get value
.a6c5		5a		phy				phy
.a6c6		48		pha				pha 								; save count
.a6c7		20 cf b2	jsr $b2cf			jsr 	StringTempAllocate
.a6ca		7a		ply				ply 								; to do count in Y
.a6cb						_SpcLoop:
.a6cb		c0 00		cpy #$00			cpy 	#0 							; copy Y spaces in.
.a6cd		f0 08		beq $a6d7			beq 	_SpcExit
.a6cf		a9 20		lda #$20			lda 	#32
.a6d1		20 08 b3	jsr $b308			jsr 	StringTempWrite
.a6d4		88		dey				dey
.a6d5		80 f4		bra $a6cb			bra 	_SpcLoop
.a6d7						_SpcExit:
.a6d7		7a		ply				ply
.a6d8		20 50 99	jsr $9950			jsr 	CheckRightBracket
.a6db		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/str.asm

.a6dc						Unary_Str:
.a6dc		fa		plx				plx
.a6dd		20 17 a8	jsr $a817			jsr 	EvaluateNumber  			; get number
.a6e0		20 50 99	jsr $9950			jsr 	CheckRightBracket 			; closing bracket
.a6e3		a9 05		lda #$05			lda 	#5 							; maximum decimals, from Basic816
.a6e5		20 fe a6	jsr $a6fe			jsr 	ConvertNumberToString 		; do the conversion.
.a6e8		a9 21		lda #$21			lda		#33 						; create buffer
.a6ea		20 cf b2	jsr $b2cf			jsr 	StringTempAllocate 			; allocate memory
.a6ed		da		phx				phx  								; copy the converted string into the buffer.
.a6ee		a2 00		ldx #$00			ldx 	#0
.a6f0						_USCopy:
.a6f0		bd 45 06	lda $0645,x			lda 	decimalBuffer,x
.a6f3		20 08 b3	jsr $b308			jsr 	StringTempWrite
.a6f6		e8		inx				inx
.a6f7		bd 45 06	lda $0645,x			lda 	decimalBuffer,x
.a6fa		d0 f4		bne $a6f0			bne 	_USCopy
.a6fc		fa		plx				plx
.a6fd		60		rts				rts
.a6fe						ConvertNumberToString:
.a6fe		5a		phy				phy 								; save code position
.a6ff		8d 10 04	sta $0410			sta 	decimalPlaces	 			; save number of DPs.
.a702		9c 11 04	stz $0411			stz 	dbOffset 					; offset into decimal buffer = start.
.a705		b5 50		lda $50,x			lda 	NSStatus,x  				; is it -ve.
.a707		10 09		bpl $a712			bpl 	_CNTSNotNegative
.a709		29 7f		and #$7f			and 	#$7F 						; make +ve
.a70b		95 50		sta $50,x			sta 	NSStatus,x
.a70d		a9 2d		lda #$2d			lda 	#"-"
.a70f		20 73 a7	jsr $a773			jsr 	WriteDecimalBuffer
.a712						_CNTSNotNegative:
.a712		b5 78		lda $78,x			lda 	NSExponent,x 				; check if decimal
.a714		f0 12		beq $a728			beq 	_CNTSNotFloat
.a716		e8		inx				inx 								; round up so we don't get too many 6.999999
.a717		a9 01		lda #$01			lda 	#1
.a719		20 cb a8	jsr $a8cb			jsr 	NSMSetByte
.a71c		ca		dex				dex
.a71d		b5 78		lda $78,x			lda		NSExponent,x
.a71f		95 79		sta $79,x			sta 	NSExponent+1,x
.a721		a9 08		lda #$08			lda 	#NSTFloat
.a723		95 51		sta $51,x			sta 	NSStatus+1,x
.a725		20 be 9e	jsr $9ebe			jsr 	FloatAdd
.a728						_CNTSNotFloat:
.a728		20 55 a7	jsr $a755			jsr 	MakePlusTwoString 			; do the integer part.
.a72b		20 84 9f	jsr $9f84			jsr 	FloatFractionalPart 		; get the fractional part
.a72e		20 35 a0	jsr $a035			jsr 	NSNormalise					; normalise , exit if zero
.a731		f0 20		beq $a753			beq 	_CNTSExit
.a733		a9 2e		lda #$2e			lda 	#"."
.a735		20 73 a7	jsr $a773			jsr 	WriteDecimalBuffer 			; write decimal place
.a738						_CNTSDecimal:
.a738		ce 10 04	dec $0410			dec 	decimalPlaces 				; done all the decimals
.a73b		30 16		bmi $a753			bmi 	_CNTSExit
.a73d		e8		inx				inx 								; x 10.0
.a73e		a9 0a		lda #$0a			lda 	#10
.a740		20 cb a8	jsr $a8cb			jsr 	NSMSetByte
.a743		a9 08		lda #$08			lda 	#NSTFloat
.a745		95 50		sta $50,x			sta 	NSStatus,x
.a747		ca		dex				dex
.a748		20 03 a0	jsr $a003			jsr 	FloatMultiply
.a74b		20 55 a7	jsr $a755			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.a74e		20 84 9f	jsr $9f84			jsr 	FloatFractionalPart 		; get the fractional part
.a751		80 e5		bra $a738			bra 	_CNTSDecimal 				; keep going.
.a753						_CNTSExit:
.a753		7a		ply				ply
.a754		60		rts				rts
.a755						MakePlusTwoString:
.a755		da		phx				phx
.a756		20 ac a8	jsr $a8ac			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.a759		e8		inx				inx 								; access it
.a75a		e8		inx				inx
.a75b		20 dc 9f	jsr $9fdc			jsr 	FloatIntegerPart 			; make it an integer
.a75e		a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.a760		20 ee 9d	jsr $9dee			jsr 	ConvertInt32
.a763		a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.a765						_MPTSCopy:
.a765		bd 23 06	lda $0623,x			lda 	numberBuffer,x
.a768		20 73 a7	jsr $a773			jsr 	WriteDecimalBuffer
.a76b		e8		inx				inx
.a76c		bd 23 06	lda $0623,x			lda 	numberBuffer,x
.a76f		d0 f4		bne $a765			bne 	_MPTSCopy
.a771		fa		plx				plx
.a772		60		rts				rts
.a773						WriteDecimalBuffer:
.a773		da		phx				phx
.a774		ae 11 04	ldx $0411			ldx 	dbOffset
.a777		9d 45 06	sta $0645,x			sta 	decimalBuffer,x
.a77a		9e 46 06	stz $0646,x			stz 	decimalBuffer+1,x
.a77d		ee 11 04	inc $0411			inc 	dbOffset
.a780		fa		plx				plx
.a781		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/substring.asm

.a782						Unary_Left:
.a782		fa		plx				plx
.a783		18		clc				clc 								; only one parameter
.a784		20 e7 a7	jsr $a7e7			jsr 	SubstringInitial 			; set up.
.a787		b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; Param #1 is the length
.a789		95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.a78b		74 59		stz $59,x			stz 	NSMantissa0+1,x 			; Start is zero.
.a78d		80 25		bra $a7b4			bra 	SubstringMain
.a78f						Unary_Right:
.a78f		fa		plx				plx
.a790		18		clc				clc 								; only one parameter
.a791		20 e7 a7	jsr $a7e7			jsr 	SubstringInitial 			; set up.
.a794		b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; length => param 2
.a796		95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.a798		b5 78		lda $78,x			lda 	NSExponent,x 				; total length
.a79a		f5 59		sbc $59,x			sbc 	NSMantissa0+1,x 			; length - required.
.a79c		b0 02		bcs $a7a0			bcs 	_URNotUnderflow
.a79e		a9 00		lda #$00			lda 	#0 							; start from the beginning, as something like right$("AB",3)
.a7a0						_URNotUnderflow:
.a7a0		95 59		sta $59,x			sta 	NSMantissa0+1,x 			; this is the start position
.a7a2		80 10		bra $a7b4			bra 	SubstringMain
.a7a4						Unary_Mid:
.a7a4		fa		plx				plx
.a7a5		38		sec				sec 								; two parameters
.a7a6		20 e7 a7	jsr $a7e7			jsr 	SubstringInitial 			; set up.
.a7a9		b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; first parameter is zero ?
.a7ab		f0 04		beq $a7b1			beq 	_UMError
.a7ad		d6 59		dec $59,x			dec 	NSMantissa0+1,x				; reduce initial offset by 1 as MID$(a$,1..) is actually the first character
.a7af		80 03		bra $a7b4			bra 	SubstringMain
.a7b1						_UMError:
.a7b1		4c 74 ab	jmp $ab74			jmp 	ArgumentError
.a7b4						SubstringMain:
.a7b4		b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; is the initial offset >= the length
.a7b6		d5 78		cmp $78,x			cmp 	NSExponent,x
.a7b8		b0 27		bcs $a7e1			bcs 	_SSMNull 					; if so, return an empty string.
.a7ba		b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; if copy count is zero
.a7bc		f0 23		beq $a7e1			beq 	_SSMNull 					; return empty string.
.a7be		18		clc				clc 								; add the offset +1 to the address and
.a7bf		b5 58		lda $58,x			lda	 	NSMantissa0,x 				; put in zTemp, this is the start of the substring to copy.
.a7c1		75 59		adc $59,x			adc 	NSMantissa0+1,x
.a7c3		85 36		sta $36				sta 	zTemp0
.a7c5		b5 60		lda $60,x			lda	 	NSMantissa1,x
.a7c7		69 00		adc #$00			adc 	#0
.a7c9		85 37		sta $37				sta 	zTemp0+1
.a7cb						_SSMNoCarry:
.a7cb		b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; characters required.
.a7cd		20 cf b2	jsr $b2cf			jsr 	StringTempAllocate 			; allocate that many characters
.a7d0		5a		phy				phy 								; save Y
.a7d1		a0 00		ldy #$00			ldy 	#0 							; start copying in.
.a7d3						_SSMCopy:
.a7d3		b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next character
.a7d5		f0 08		beq $a7df			beq 	_SSMEString 				; no more to copy
.a7d7		20 08 b3	jsr $b308			jsr 	StringTempWrite 			; and write it out.
.a7da		c8		iny				iny
.a7db		d6 5a		dec $5a,x			dec 	NSMantissa0+2,x
.a7dd		d0 f4		bne $a7d3			bne 	_SSMCopy
.a7df						_SSMEString:
.a7df		7a		ply				ply
.a7e0						_SSMExit:
.a7e0		60		rts				rts
.a7e1						_SSMNull:
.a7e1		a9 00		lda #$00			lda 	#0
.a7e3		20 cf b2	jsr $b2cf			jsr 	StringTempAllocate
.a7e6		60		rts				rts
.a7e7						SubstringInitial:
.a7e7		da		phx				phx 								; save initial stack position
.a7e8		08		php				php 								; save carry on stack indicating 2 parameters
.a7e9		20 21 a8	jsr $a821			jsr 	EvaluateString 				; get a string
.a7ec		5a		phy				phy 								; calculate length to exponent.
.a7ed		a0 ff		ldy #$ff			ldy 	#$FF
.a7ef						_SIFindLength:
.a7ef		c8		iny				iny
.a7f0		b1 36		lda ($36),y			lda 	(zTemp0),y
.a7f2		d0 fb		bne $a7ef			bne 	_SIFindLength
.a7f4		98		tya				tya
.a7f5		95 78		sta $78,x			sta 	NSExponent,x
.a7f7		7a		ply				ply
.a7f8		e8		inx				inx
.a7f9		20 58 99	jsr $9958			jsr 	CheckComma 					; comma next
.a7fc		20 64 a8	jsr $a864			jsr 	Evaluate8BitInteger 		; get next parameter
.a7ff		28		plp				plp 								; is it the last parameter ?
.a800		90 07		bcc $a809			bcc 	_SSIExit 					; if so, exit.
.a802		e8		inx				inx
.a803		20 58 99	jsr $9958			jsr 	CheckComma 					; comma next
.a806		20 64 a8	jsr $a864			jsr 	Evaluate8BitInteger 		; get last parameter
.a809						_SSIExit:
.a809		fa		plx				plx
.a80a		20 50 99	jsr $9950			jsr 	CheckRightBracket 			; check closing bracket
.a80d		60		rts				rts 								; exit

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/exprhelper.asm

.a80e						EvaluateValue:
.a80e		48		pha				pha
.a80f		20 73 9e	jsr $9e73			jsr		EvaluateExpression 			; expression
.a812		20 36 a1	jsr $a136			jsr 	Dereference					; derefernce it
.a815		68		pla				pla
.a816		60		rts				rts
.a817						EvaluateNumber:
.a817		20 0e a8	jsr $a80e			jsr 	EvaluateValue 				; get a value
.a81a		b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.a81c		29 10		and #$10			and 	#NSBIsString
.a81e		d0 13		bne $a833			bne 	HelperTypeError
.a820		60		rts				rts
.a821						EvaluateString:
.a821		20 0e a8	jsr $a80e			jsr 	EvaluateValue 				; get a value
.a824		b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.a826		29 10		and #$10			and 	#NSBIsString
.a828		f0 09		beq $a833			beq 	HelperTypeError
.a82a						CopyAddressToTemp0:
.a82a		b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address -> zTemp0
.a82c		85 36		sta $36				sta 	zTemp0 						; (so we can do something with it)
.a82e		b5 60		lda $60,x			lda 	NSMantissa1,x
.a830		85 37		sta $37				sta 	zTemp0+1
.a832		60		rts				rts
.a833						HelperTypeError:
.a833		4c 6f ab	jmp $ab6f			jmp 	TypeError
.a836						EvaluateInteger:
.a836		20 17 a8	jsr $a817			jsr 	EvaluateNumber
.a839		b5 78		lda $78,x			lda 	NSExponent,x 				; check exponent is zero
.a83b		d0 09		bne $a846			bne 	HelperValueError 			; if not, it's a float.
.a83d		60		rts				rts
.a83e						EvaluateUnsignedInteger:
.a83e		20 36 a8	jsr $a836			jsr 	EvaluateInteger 			; check integer is +ve
.a841		b5 50		lda $50,x			lda 	NSStatus,x
.a843		30 01		bmi $a846			bmi 	HelperValueError
.a845		60		rts				rts
.a846						HelperValueError:
.a846		4c 74 ab	jmp $ab74			jmp 	ArgumentError
.a849						Evaluate16BitInteger:
.a849		20 3e a8	jsr $a83e			jsr	 	EvaluateUnsignedInteger		; get integer
.a84c		b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.a84e		15 68		ora $68,x			ora 	NSMantissa2,x
.a850		d0 f4		bne $a846			bne 	HelperValueError
.a852		60		rts				rts
.a853						Evaluate16BitIntegerSigned:
.a853		20 36 a8	jsr $a836			jsr	 	EvaluateInteger				; get integer
.a856		b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.a858		15 68		ora $68,x			ora 	NSMantissa2,x
.a85a		d0 ea		bne $a846			bne 	HelperValueError
.a85c		b5 50		lda $50,x			lda 	NSStatus,x 					; signed ?
.a85e		10 03		bpl $a863			bpl 	_EISNotSigned
.a860		20 92 a8	jsr $a892			jsr 	NSMNegateMantissa 			; makes it an actual 2's complement value.
.a863						_EISNotSigned:
.a863		60		rts				rts
.a864						Evaluate8BitInteger:
.a864		20 3e a8	jsr $a83e			jsr	 	EvaluateUnsignedInteger 	; get an integer
.a867		d0 dd		bne $a846			bne 	HelperValueError
.a869		b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 1, 2 & 3 must be zero
.a86b		15 68		ora $68,x			ora 	NSMantissa2,x
.a86d		15 60		ora $60,x			ora 	NSMantissa1,x
.a86f		d0 d5		bne $a846			bne 	HelperValueError
.a871		b5 58		lda $58,x			lda 	NSMantissa0,x
.a873		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/mult8x8.asm

.a874						Multiply8x8:
.a874		4a		lsr a		  		lsr 	a  							; prime the carry bit for the loop
.a875		85 36		sta $36			  	sta 	zTemp0
.a877		86 37		stx $37				stx 	zTemp0+1
.a879		a9 00		lda #$00			lda 	#0
.a87b		a2 08		ldx #$08			ldx 	#8
.a87d						_M88Loop:
.a87d		90 03		bcc $a882			bcc 	_M88NoAdd
.a87f		18		clc				clc
.a880		65 37		adc $37				adc 	zTemp0+1
.a882						_M88NoAdd:
.a882		6a		ror a				ror 	a
.a883		66 36		ror $36				ror 	zTemp0  					; pull another bit out for the next iteration
.a885		ca		dex				dex         						; inc/dec don't modify carry; only shifts and adds do
.a886		d0 f5		bne $a87d			bne 	_M88Loop
.a888		85 37		sta $37				sta 	zTemp0+1 					; store high 8 bits.
.a88a		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/utility.asm

.a88b						NSMNegate:
.a88b		b5 50		lda $50,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.a88d		49 80		eor #$80			eor 	#NSBIsNegative  			; toggle the negative flag
.a88f		95 50		sta $50,x			sta 	NSStatus,x
.a891		60		rts				rts
.a892						NSMNegateMantissa:
.a892		38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.a893		a9 00		lda #$00			lda 	#0
.a895		f5 58		sbc $58,x			sbc 	NSMantissa0,x
.a897		95 58		sta $58,x			sta 	NSMantissa0,x
.a899		a9 00		lda #$00			lda 	#0
.a89b		f5 60		sbc $60,x			sbc 	NSMantissa1,x
.a89d		95 60		sta $60,x			sta 	NSMantissa1,x
.a89f		a9 00		lda #$00			lda 	#0
.a8a1		f5 68		sbc $68,x			sbc 	NSMantissa2,x
.a8a3		95 68		sta $68,x			sta 	NSMantissa2,x
.a8a5		a9 00		lda #$00			lda 	#0
.a8a7		f5 70		sbc $70,x			sbc 	NSMantissa3,x
.a8a9		95 70		sta $70,x			sta 	NSMantissa3,x
.a8ab		60		rts				rts
.a8ac						NSMShiftUpTwo:
.a8ac		b5 58		lda $58,x			lda 	NSMantissa0,x
.a8ae		95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.a8b0		b5 60		lda $60,x			lda 	NSMantissa1,x
.a8b2		95 62		sta $62,x			sta 	NSMantissa1+2,x
.a8b4		b5 68		lda $68,x			lda 	NSMantissa2,x
.a8b6		95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.a8b8		b5 70		lda $70,x			lda 	NSMantissa3,x
.a8ba		95 72		sta $72,x			sta 	NSMantissa3+2,x
.a8bc		b5 78		lda $78,x			lda 	NSExponent,x
.a8be		95 7a		sta $7a,x			sta 	NSExponent+2,x
.a8c0		b5 50		lda $50,x			lda 	NSStatus,x
.a8c2		95 52		sta $52,x			sta 	NSStatus+2,x
.a8c4		60		rts				rts
.a8c5						NSMSetZeroMantissaOnly:
.a8c5		a9 00		lda #$00			lda 	#0
.a8c7		80 06		bra $a8cf			bra 	NSMSetMantissa
.a8c9						NSMSetZero:
.a8c9		a9 00		lda #$00			lda 	#0
.a8cb						NSMSetByte:
.a8cb		74 78		stz $78,x			stz 	NSExponent,x 				; zero exponent, as integer.
.a8cd		74 50		stz $50,x			stz 	NSStatus,x 					; status zero (integer)
.a8cf						NSMSetMantissa:
.a8cf		95 58		sta $58,x			sta 	NSMantissa0,x 				; mantissa
.a8d1		74 60		stz $60,x			stz 	NSMantissa1,x
.a8d3		74 68		stz $68,x			stz 	NSMantissa2,x
.a8d5		74 70		stz $70,x			stz 	NSMantissa3,x
.a8d7		60		rts				rts
.a8d8						NSMShiftLeft:
.a8d8		18		clc				clc
.a8d9						NSMRotateLeft:
.a8d9		36 58		rol $58,x			rol 	NSMantissa0,x
.a8db		36 60		rol $60,x			rol		NSMantissa1,x
.a8dd		36 68		rol $68,x			rol		NSMantissa2,x
.a8df		36 70		rol $70,x			rol		NSMantissa3,x
.a8e1		60		rts				rts
.a8e2						NSMShiftRight:
.a8e2		56 70		lsr $70,x			lsr 	NSMantissa3,x
.a8e4		76 68		ror $68,x			ror		NSMantissa2,x
.a8e6		76 60		ror $60,x			ror		NSMantissa1,x
.a8e8		76 58		ror $58,x			ror		NSMantissa0,x
.a8ea		60		rts				rts
.a8eb						NSMIsZero:
.a8eb		b5 70		lda $70,x			lda 	NSMantissa3,x
.a8ed		15 68		ora $68,x			ora		NSMantissa2,x
.a8ef		15 60		ora $60,x			ora		NSMantissa1,x
.a8f1		15 58		ora $58,x			ora		NSMantissa0,x
.a8f3		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/functions/getdatetime.asm

.a8f4						UnaryGetTime:
.a8f4		a9 00		lda #$00			lda 	#0
.a8f6		80 02		bra $a8fa			bra 	UGDTMain
.a8f8						UnaryGetDate:
.a8f8		a9 03		lda #$03			lda 	#3
.a8fa						UGDTMain:
.a8fa		fa		plx				plx 								; get stack position back
.a8fb		48		pha				pha 								; save table offset
.a8fc		20 64 a8	jsr $a864			jsr 	Evaluate8BitInteger			; ignored parameter
.a8ff		20 50 99	jsr $9950			jsr 	CheckRightBracket 			; closing )
.a902		68		pla				pla 								; table offset in A
.a903		5a		phy				phy 								; saving Y
.a904		a8		tay				tay 								; table offset in Y
.a905		a9 08		lda #$08			lda 	#8							; allocate space for 8 chars DD:MM:YY
.a907		20 cf b2	jsr $b2cf			jsr 	StringTempAllocate
.a90a		a5 01		lda $01				lda 	1 							; save I/O table and switch to I/O page 0
.a90c		48		pha				pha
.a90d		64 01		stz $01				stz 	1
.a90f		20 22 a9	jsr $a922			jsr 	UGDTDigit 					; do XX:YY:ZZ
.a912		20 1d a9	jsr $a91d			jsr 	UGDTColonDigit
.a915		20 1d a9	jsr $a91d			jsr 	UGDTColonDigit
.a918		68		pla				pla 								; restore I/O select
.a919		85 01		sta $01				sta 	1
.a91b		7a		ply				ply  								; restore code position
.a91c		60		rts				rts
.a91d						UGDTColonDigit:
.a91d		a9 3a		lda #$3a			lda 	#':'
.a91f		20 08 b3	jsr $b308			jsr 	StringTempWrite
.a922						UGDTDigit:
.a922		da		phx				phx 								; save X
.a923		b9 42 a9	lda $a942,y			lda 	RTCROffset,y 				; get offset in RTC register
.a926		aa		tax				tax
.a927		bd 90 d6	lda $d690,x			lda 	$D690,x 					; read RTC register
.a92a		39 48 a9	and $a948,y			and 	RTCRMask,y 					; and with Mask.
.a92d		fa		plx				plx
.a92e		48		pha				pha 								; output in BCD
.a92f		4a		lsr a				lsr 	a
.a930		4a		lsr a				lsr 	a
.a931		4a		lsr a				lsr 	a
.a932		4a		lsr a				lsr 	a
.a933		09 30		ora #$30			ora 	#48
.a935		20 08 b3	jsr $b308			jsr 	StringTempWrite
.a938		68		pla				pla
.a939		29 0f		and #$0f			and 	#15
.a93b		09 30		ora #$30			ora 	#48
.a93d		20 08 b3	jsr $b308			jsr 	StringTempWrite
.a940		c8		iny				iny
.a941		60		rts				rts
.a942						RTCROffset:
>a942		04 02 00 06 09 0a				.byte 	4,2,0,6,9,10
.a948						RTCRMask:
>a948		3f 7f 7f 3f 1f 7f				.byte 	$3F,$7F,$7F,$3F,$1F,$7F

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/functions/getinkey.asm

.a94e						AscGet:
.a94e		fa		plx				plx 								; restore stack pos
.a94f						AscGet2:
.a94f		20 50 99	jsr $9950			jsr 	CheckRightBracket
.a952		20 9b 81	jsr $819b			jsr 	KNLGetSingleCharacter
.a955		20 cb a8	jsr $a8cb			jsr 	NSMSetByte
.a958		60		rts				rts
.a959						_AGBreak:
.a959		a9 01		lda #$01		lda	#1
.a95b		4c 69 99	jmp $9969		jmp	ErrorHandler
.a95e						AscInkey:
.a95e		fa		plx				plx 								; restore stack pos
.a95f						AscInkey2:
.a95f		20 50 99	jsr $9950			jsr 	CheckRightBracket
.a962		20 79 81	jsr $8179			jsr 	KNLGetKeyPressed
.a965		20 cb a8	jsr $a8cb			jsr 	NSMSetByte
.a968		60		rts				rts
.a969						ChrGet:
.a969		fa		plx				plx
.a96a		20 4f a9	jsr $a94f			jsr 	AscGet2
.a96d		4c 74 a9	jmp $a974			jmp 	GetInkeyToString
.a970						ChrInkey:
.a970		fa		plx				plx
.a971		20 5f a9	jsr $a95f			jsr 	AscInkey2
.a974						GetInkeyToString:
.a974		c9 00		cmp #$00			cmp 	#0 							; if zero, return ""
.a976		f0 0b		beq $a983			beq 	_GKISNull
.a978		48		pha				pha
.a979		a9 01		lda #$01			lda 	#1 							; allocate space for one char
.a97b		20 cf b2	jsr $b2cf			jsr 	StringTempAllocate
.a97e		68		pla				pla 								; write number to it
.a97f		20 08 b3	jsr $b308			jsr 	StringTempWrite
.a982		60		rts				rts
.a983						_GKISNull:
.a983		a9 00		lda #$00			lda 	#0
.a985		20 cf b2	jsr $b2cf			jsr 	StringTempAllocate
.a988		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/functions/keydown.asm

.a989						KeyDown:
.a989		20 2a 81	jsr $812a			jsr 	ProcessEvents 				; process outstanding events.
.a98c		fa		plx				plx 								; restore stack pos
.a98d		20 64 a8	jsr $a864			jsr 	Evaluate8BitInteger 		; key to check.
.a990		48		pha				pha 								; check right bracket.
.a991		20 50 99	jsr $9950			jsr 	CheckRightBracket
.a994		68		pla				pla
.a995		20 17 83	jsr $8317			jsr 	KeyboardConvertXA 			; get offset and mask.
.a998		3d 5f 06	and $065f,x			and 	KeyStatus,x 				; is it zero ?
.a99b		f0 03		beq $a9a0			beq 	_KeyUp
.a99d		4c dc 99	jmp $99dc			jmp 	ReturnTrue
.a9a0		4c e7 99	jmp $99e7	_KeyUp:	jmp 	ReturnFalse

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/functions/rnd.asm

.a9a3						Unary_Random:
.a9a3		fa		plx				plx
.a9a4		20 f4 a9	jsr $a9f4			jsr 	URCopyToMantissa  			; put random # in mantissa
.a9a7		b1 30		lda ($30),y			lda 	(codePtr),y
.a9a9		c9 29		cmp #$29			cmp 	#KWD_RPAREN
.a9ab		f0 08		beq $a9b5			beq 	_URNoModulus 				; then we return a random 30 bit number.
.a9ad		e8		inx				inx
.a9ae		20 49 a8	jsr $a849			jsr 	Evaluate16BitInteger 		; put modulus value in +1
.a9b1		ca		dex				dex
.a9b2		20 2e 9b	jsr $9b2e			jsr 	IntegerModulusNoCheck 		; calculate modulus, so now 0 .. n-1
.a9b5						_URNoModulus:
.a9b5		74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer positive
.a9b7		74 78		stz $78,x			stz 	NSExponent,x
.a9b9		20 50 99	jsr $9950			jsr 	CheckRightBracket
.a9bc		60		rts				rts
.a9bd						Unary_Rnd:
.a9bd		fa		plx				plx
.a9be		20 17 a8	jsr $a817			jsr 	EvaluateNumber 				; number to use.
.a9c1		20 50 99	jsr $9950			jsr 	CheckRightBracket 			; closing bracket
.a9c4		b5 50		lda $50,x			lda 	NSStatus,x 					; if -ve, then seed using parameter
.a9c6		10 20		bpl $a9e8			bpl 	_URDontSeed
.a9c8		a5 01		lda $01				lda 	1 							; switch to page 0
.a9ca		48		pha				pha
.a9cb		64 01		stz $01				stz 	1
.a9cd		b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy - value to seed butchering it.
.a9cf		49 17		eor #$17			eor 	#$17
.a9d1		8d a4 d6	sta $d6a4			sta 	$D6A4
.a9d4		b5 60		lda $60,x			lda 	NSMantissa1,x
.a9d6		49 a5		eor #$a5			eor 	#$A5
.a9d8		8d a5 d6	sta $d6a5			sta 	$D6A5
.a9db		a9 03		lda #$03			lda 	#3 							; set bit 1 high/low to set seed.
.a9dd		8d a6 d6	sta $d6a6			sta 	$D6A6
.a9e0		a9 01		lda #$01			lda 	#1
.a9e2		8d a6 d6	sta $d6a6			sta 	$D6A6
.a9e5		68		pla				pla
.a9e6		85 01		sta $01				sta 	1
.a9e8						_URDontSeed:
.a9e8		20 f4 a9	jsr $a9f4			jsr 	URCopyToMantissa 			; copy into mantissa
.a9eb		a9 e2		lda #$e2			lda 	#-30 						; force into 0-1 range
.a9ed		95 78		sta $78,x			sta 	NSExponent,x
.a9ef		a9 08		lda #$08			lda 	#NSTFloat
.a9f1		95 50		sta $50,x			sta 	NSStatus,x 					; positive float
.a9f3		60		rts				rts
.a9f4						URCopyToMantissa:
.a9f4		a5 01		lda $01				lda 	1 							; switch to I/O page 1
.a9f6		48		pha				pha
.a9f7		64 01		stz $01				stz 	1
.a9f9		a9 01		lda #$01			lda 	#1
.a9fb		8d a6 d6	sta $d6a6			sta 	$D6A6 						; enable LFSR
.a9fe		ad a4 d6	lda $d6a4			lda 	$D6A4
.aa01		95 58		sta $58,x			sta 	NSMantissa0,x
.aa03		ad a5 d6	lda $d6a5			lda 	$D6A5
.aa06		95 60		sta $60,x			sta 	NSMantissa1,x
.aa08		ad a4 d6	lda $d6a4			lda 	$D6A4
.aa0b		95 68		sta $68,x			sta 	NSMantissa2,x
.aa0d		ad a5 d6	lda $d6a5			lda 	$D6A5
.aa10		29 3f		and #$3f			and 	#$3F 						; make legal mantissa
.aa12		95 70		sta $70,x			sta 	NSMantissa3,x
.aa14		68		pla				pla
.aa15		85 01		sta $01				sta 	1
.aa17		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/asmcore.asm

.aa18						Assemble_ora:
.aa18		20 15 84	jsr $8415		jsr	AssembleGroup1
>aa1b		01					.byte $01
.aa1c						Assemble_and:
.aa1c		20 15 84	jsr $8415		jsr	AssembleGroup1
>aa1f		21					.byte $21
.aa20						Assemble_eor:
.aa20		20 15 84	jsr $8415		jsr	AssembleGroup1
>aa23		41					.byte $41
.aa24						Assemble_adc:
.aa24		20 15 84	jsr $8415		jsr	AssembleGroup1
>aa27		61					.byte $61
.aa28						Assemble_sta:
.aa28		20 15 84	jsr $8415		jsr	AssembleGroup1
>aa2b		81					.byte $81
.aa2c						Assemble_lda:
.aa2c		20 15 84	jsr $8415		jsr	AssembleGroup1
>aa2f		a1					.byte $a1
.aa30						Assemble_cmp:
.aa30		20 15 84	jsr $8415		jsr	AssembleGroup1
>aa33		c1					.byte $c1
.aa34						Assemble_sbc:
.aa34		20 15 84	jsr $8415		jsr	AssembleGroup1
>aa37		e1					.byte $e1
.aa38						Assemble_asl:
.aa38		20 1c 84	jsr $841c		jsr	AssembleGroup2
>aa3b		02					.byte $02
>aa3c		75					.byte $75
.aa3d						Assemble_rol:
.aa3d		20 1c 84	jsr $841c		jsr	AssembleGroup2
>aa40		22					.byte $22
>aa41		75					.byte $75
.aa42						Assemble_lsr:
.aa42		20 1c 84	jsr $841c		jsr	AssembleGroup2
>aa45		42					.byte $42
>aa46		75					.byte $75
.aa47						Assemble_ror:
.aa47		20 1c 84	jsr $841c		jsr	AssembleGroup2
>aa4a		62					.byte $62
>aa4b		75					.byte $75
.aa4c						Assemble_stx:
.aa4c		20 1c 84	jsr $841c		jsr	AssembleGroup2
>aa4f		82					.byte $82
>aa50		50					.byte $50
.aa51						Assemble_ldx:
.aa51		20 1c 84	jsr $841c		jsr	AssembleGroup2
>aa54		a2					.byte $a2
>aa55		d0					.byte $d0
.aa56						Assemble_dec:
.aa56		20 1c 84	jsr $841c		jsr	AssembleGroup2
>aa59		c2					.byte $c2
>aa5a		55					.byte $55
.aa5b						Assemble_inc:
.aa5b		20 1c 84	jsr $841c		jsr	AssembleGroup2
>aa5e		e2					.byte $e2
>aa5f		55					.byte $55
.aa60						Assemble_stz:
.aa60		20 1c 84	jsr $841c		jsr	AssembleGroup2
>aa63		60					.byte $60
>aa64		44					.byte $44
.aa65						Assemble_bit:
.aa65		20 1c 84	jsr $841c		jsr	AssembleGroup2
>aa68		20					.byte $20
>aa69		55					.byte $55
.aa6a						Assemble_sty:
.aa6a		20 1c 84	jsr $841c		jsr	AssembleGroup2
>aa6d		80					.byte $80
>aa6e		54					.byte $54
.aa6f						Assemble_ldy:
.aa6f		20 1c 84	jsr $841c		jsr	AssembleGroup2
>aa72		a0					.byte $a0
>aa73		d5					.byte $d5
.aa74						Assemble_cpy:
.aa74		20 1c 84	jsr $841c		jsr	AssembleGroup2
>aa77		c0					.byte $c0
>aa78		d4					.byte $d4
.aa79						Assemble_cpx:
.aa79		20 1c 84	jsr $841c		jsr	AssembleGroup2
>aa7c		e0					.byte $e0
>aa7d		d0					.byte $d0
.aa7e						Assemble_tsb:
.aa7e		20 1c 84	jsr $841c		jsr	AssembleGroup2
>aa81		00					.byte $00
>aa82		50					.byte $50
.aa83						Assemble_trb:
.aa83		20 1c 84	jsr $841c		jsr	AssembleGroup2
>aa86		10					.byte $10
>aa87		50					.byte $50
.aa88						Assemble_jsr:
.aa88		20 1c 84	jsr $841c		jsr	AssembleGroup2
>aa8b		14					.byte $14
>aa8c		10					.byte $10
.aa8d						Assemble_jmp:
.aa8d		20 1c 84	jsr $841c		jsr	AssembleGroup2
>aa90		40					.byte $40
>aa91		10					.byte $10
.aa92						Assemble_bpl:
.aa92		20 6d 84	jsr $846d		jsr	AssembleGroup3
>aa95		10					.byte $10
.aa96						Assemble_bmi:
.aa96		20 6d 84	jsr $846d		jsr	AssembleGroup3
>aa99		30					.byte $30
.aa9a						Assemble_bvc:
.aa9a		20 6d 84	jsr $846d		jsr	AssembleGroup3
>aa9d		50					.byte $50
.aa9e						Assemble_bvs:
.aa9e		20 6d 84	jsr $846d		jsr	AssembleGroup3
>aaa1		70					.byte $70
.aaa2						Assemble_bcc:
.aaa2		20 6d 84	jsr $846d		jsr	AssembleGroup3
>aaa5		90					.byte $90
.aaa6						Assemble_bcs:
.aaa6		20 6d 84	jsr $846d		jsr	AssembleGroup3
>aaa9		b0					.byte $b0
.aaaa						Assemble_bne:
.aaaa		20 6d 84	jsr $846d		jsr	AssembleGroup3
>aaad		d0					.byte $d0
.aaae						Assemble_beq:
.aaae		20 6d 84	jsr $846d		jsr	AssembleGroup3
>aab1		f0					.byte $f0
.aab2						Assemble_bra:
.aab2		20 6d 84	jsr $846d		jsr	AssembleGroup3
>aab5		80					.byte $80
.aab6						Assemble_brk:
.aab6		20 a1 84	jsr $84a1		jsr	AssembleGroup4
>aab9		00					.byte $00
.aaba						Assemble_php:
.aaba		20 a1 84	jsr $84a1		jsr	AssembleGroup4
>aabd		08					.byte $08
.aabe						Assemble_clc:
.aabe		20 a1 84	jsr $84a1		jsr	AssembleGroup4
>aac1		18					.byte $18
.aac2						Assemble_plp:
.aac2		20 a1 84	jsr $84a1		jsr	AssembleGroup4
>aac5		28					.byte $28
.aac6						Assemble_sec:
.aac6		20 a1 84	jsr $84a1		jsr	AssembleGroup4
>aac9		38					.byte $38
.aaca						Assemble_rti:
.aaca		20 a1 84	jsr $84a1		jsr	AssembleGroup4
>aacd		40					.byte $40
.aace						Assemble_pha:
.aace		20 a1 84	jsr $84a1		jsr	AssembleGroup4
>aad1		48					.byte $48
.aad2						Assemble_cli:
.aad2		20 a1 84	jsr $84a1		jsr	AssembleGroup4
>aad5		58					.byte $58
.aad6						Assemble_phy:
.aad6		20 a1 84	jsr $84a1		jsr	AssembleGroup4
>aad9		5a					.byte $5a
.aada						Assemble_rts:
.aada		20 a1 84	jsr $84a1		jsr	AssembleGroup4
>aadd		60					.byte $60
.aade						Assemble_pla:
.aade		20 a1 84	jsr $84a1		jsr	AssembleGroup4
>aae1		68					.byte $68
.aae2						Assemble_sei:
.aae2		20 a1 84	jsr $84a1		jsr	AssembleGroup4
>aae5		78					.byte $78
.aae6						Assemble_ply:
.aae6		20 a1 84	jsr $84a1		jsr	AssembleGroup4
>aae9		7a					.byte $7a
.aaea						Assemble_dey:
.aaea		20 a1 84	jsr $84a1		jsr	AssembleGroup4
>aaed		88					.byte $88
.aaee						Assemble_txa:
.aaee		20 a1 84	jsr $84a1		jsr	AssembleGroup4
>aaf1		8a					.byte $8a
.aaf2						Assemble_tya:
.aaf2		20 a1 84	jsr $84a1		jsr	AssembleGroup4
>aaf5		98					.byte $98
.aaf6						Assemble_txs:
.aaf6		20 a1 84	jsr $84a1		jsr	AssembleGroup4
>aaf9		9a					.byte $9a
.aafa						Assemble_tay:
.aafa		20 a1 84	jsr $84a1		jsr	AssembleGroup4
>aafd		a8					.byte $a8
.aafe						Assemble_tax:
.aafe		20 a1 84	jsr $84a1		jsr	AssembleGroup4
>ab01		aa					.byte $aa
.ab02						Assemble_clv:
.ab02		20 a1 84	jsr $84a1		jsr	AssembleGroup4
>ab05		b8					.byte $b8
.ab06						Assemble_tsx:
.ab06		20 a1 84	jsr $84a1		jsr	AssembleGroup4
>ab09		ba					.byte $ba
.ab0a						Assemble_iny:
.ab0a		20 a1 84	jsr $84a1		jsr	AssembleGroup4
>ab0d		c8					.byte $c8
.ab0e						Assemble_dex:
.ab0e		20 a1 84	jsr $84a1		jsr	AssembleGroup4
>ab11		ca					.byte $ca
.ab12						Assemble_cld:
.ab12		20 a1 84	jsr $84a1		jsr	AssembleGroup4
>ab15		d8					.byte $d8
.ab16						Assemble_phx:
.ab16		20 a1 84	jsr $84a1		jsr	AssembleGroup4
>ab19		da					.byte $da
.ab1a						Assemble_stp:
.ab1a		20 a1 84	jsr $84a1		jsr	AssembleGroup4
>ab1d		db					.byte $db
.ab1e						Assemble_inx:
.ab1e		20 a1 84	jsr $84a1		jsr	AssembleGroup4
>ab21		e8					.byte $e8
.ab22						Assemble_nop:
.ab22		20 a1 84	jsr $84a1		jsr	AssembleGroup4
>ab25		ea					.byte $ea
.ab26						Assemble_sed:
.ab26		20 a1 84	jsr $84a1		jsr	AssembleGroup4
>ab29		f8					.byte $f8
.ab2a						Assemble_plx:
.ab2a		20 a1 84	jsr $84a1		jsr	AssembleGroup4
>ab2d		fa					.byte $fa

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/constants.asm

.ab2e						DecimalScalarTable:
>ab2e		66 66 66 66				.dword $66666666 ; 0.1
>ab32		de					.byte $de
>ab33		1f 85 eb 51				.dword $51eb851f ; 0.01
>ab37		db					.byte $db
>ab38		4c 37 89 41				.dword $4189374c ; 0.001
>ab3c		d8					.byte $d8
>ab3d		ac 8b db 68				.dword $68db8bac ; 0.0001
>ab41		d4					.byte $d4
>ab42		24 d6 e2 53				.dword $53e2d624 ; 1e-05
>ab46		d1					.byte $d1
>ab47		83 de 1b 43				.dword $431bde83 ; 1e-06
>ab4b		ce					.byte $ce
>ab4c		6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>ab50		ca					.byte $ca
>ab51		89 3b e6 55				.dword $55e63b89 ; 1e-08
>ab55		c7					.byte $c7
>ab56		a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>ab5a		c4					.byte $c4
>ab5b		67 7f f3 6d				.dword $6df37f67 ; 1e-10
>ab5f		c0					.byte $c0
>ab60		86 ff f5 57				.dword $57f5ff86 ; 1e-11
>ab64		bd					.byte $bd

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.asm

.ab65						SyntaxError:
.ab65		a9 02		lda #$02		lda	#2
.ab67		4c 69 99	jmp $9969		jmp	ErrorHandler
.ab6a						RangeError:
.ab6a		a9 04		lda #$04		lda	#4
.ab6c		4c 69 99	jmp $9969		jmp	ErrorHandler
.ab6f						TypeError:
.ab6f		a9 05		lda #$05		lda	#5
.ab71		4c 69 99	jmp $9969		jmp	ErrorHandler
.ab74						ArgumentError:
.ab74		a9 07		lda #$07		lda	#7
.ab76		4c 69 99	jmp $9969		jmp	ErrorHandler
.ab79						NotDoneError:
.ab79		a9 0c		lda #$0c		lda	#12
.ab7b		4c 69 99	jmp $9969		jmp	ErrorHandler
.ab7e						ErrorText:
>ab7e		42 72 65 61 6b 00			.text	"Break",0
>ab84		53 79 6e 74 61 78 20 65			.text	"Syntax error",0
>ab8c		72 72 6f 72 00
>ab91		44 69 76 69 73 69 6f 6e			.text	"Division by zero",0
>ab99		20 62 79 20 7a 65 72 6f 00
>aba2		4f 75 74 20 6f 66 20 52			.text	"Out of Range",0
>abaa		61 6e 67 65 00
>abaf		54 79 70 65 20 6d 69 73			.text	"Type mismatch",0
>abb7		6d 61 74 63 68 00
>abbd		4f 75 74 20 6f 66 20 6d			.text	"Out of memory",0
>abc5		65 6d 6f 72 79 00
>abcb		49 6c 6c 65 67 61 6c 20			.text	"Illegal argument",0
>abd3		61 72 67 75 6d 65 6e 74 00
>abdc		53 74 6f 70 00				.text	"Stop",0
>abe1		53 74 72 69 6e 67 20 74			.text	"String too long",0
>abe9		6f 6f 20 6c 6f 6e 67 00
>abf1		41 73 73 65 72 74 69 6f			.text	"Assertion failed",0
>abf9		6e 20 66 61 69 6c 65 64 00
>ac02		4f 75 74 20 6f 66 20 64			.text	"Out of data",0
>ac0a		61 74 61 00
>ac0e		55 6e 69 6d 70 6c 65 6d			.text	"Unimplemented",0
>ac16		65 6e 74 65 64 00
>ac1c		4e 6f 20 73 75 63 68 20			.text	"No such line number",0
>ac24		6c 69 6e 65 20 6e 75 6d 62 65 72 00
>ac30		52 65 74 75 72 6e 20 77			.text	"Return without Gosub",0
>ac38		69 74 68 6f 75 74 20 47 6f 73 75 62 00
>ac45		55 6e 74 69 6c 20 77 69			.text	"Until without Repeat",0
>ac4d		74 68 6f 75 74 20 52 65 70 65 61 74 00
>ac5a		57 65 6e 64 20 77 69 74			.text	"Wend without While",0
>ac62		68 6f 75 74 20 57 68 69 6c 65 00
>ac6d		4e 65 78 74 20 77 69 74			.text	"Next without For",0
>ac75		68 6f 75 74 20 46 6f 72 00
>ac7e		42 41 53 49 43 20 53 74			.text	"BASIC Stack full",0
>ac86		61 63 6b 20 66 75 6c 6c 00
>ac8f		4f 70 65 6e 20 53 74 72			.text	"Open Structure",0
>ac97		75 63 74 75 72 65 00
>ac9e		45 6e 64 50 72 6f 63 20			.text	"EndProc without call",0
>aca6		77 69 74 68 6f 75 74 20 63 61 6c 6c 00
>acb3		41 72 72 61 79 20 61 6c			.text	"Array already defined",0
>acbb		72 65 61 64 79 20 64 65 66 69 6e 65 64 00
>acc9		41 72 72 61 79 20 73 69			.text	"Array size",0
>acd1		7a 65 00
>acd4		42 61 64 20 61 72 72 61			.text	"Bad array index",0
>acdc		79 20 69 6e 64 65 78 00
>ace4		41 72 72 61 79 20 6e 6f			.text	"Array not declared",0
>acec		74 20 64 65 63 6c 61 72 65 64 00
>acf7		46 69 6c 65 20 6e 6f 74			.text	"File not found",0
>acff		20 66 6f 75 6e 64 00
>ad06		53 74 6f 72 61 67 65 20			.text	"Storage error",0
>ad0e		65 72 72 6f 72 00
>ad14		56 65 72 69 66 79 20 66			.text	"Verify failed",0
>ad1c		61 69 6c 65 64 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/timestamp.asm

>e7fa		09 09 33 30 2f 30 31 2f			.text 9,9,"30/01/23 33"
>e802		32 33 20 33 33

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/memory/memory.flat/delete.asm

.ad22						MemoryDeleteLine:
.ad22		20 41 ad	jsr $ad41			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.ad25		b2 30		lda ($30)			lda 	(codePtr) 					; size to delete => y
.ad27		a8		tay				tay
.ad28						_MDDLLoop:
.ad28		b1 30		lda ($30),y			lda 	(codePtr),y 				; copy down
.ad2a		92 30		sta ($30)			sta 	(codePtr)
.ad2c		a5 30		lda $30				lda 	codePtr 					; check done the lot.
.ad2e		c5 3a		cmp $3a				cmp 	zTemp2 						; has codePtr (copyFrom) reached the last byte to copy.
.ad30		d0 07		bne $ad39			bne 	_MDLDLNext
.ad32		a5 31		lda $31				lda 	codePtr+1
.ad34		c5 3b		cmp $3b				cmp 	zTemp2+1
.ad36		d0 01		bne $ad39			bne 	_MDLDLNext
.ad38						_MDDLExit:
.ad38		60		rts				rts
.ad39						_MDLDLNext:
.ad39		e6 30		inc $30				inc 	codePtr						; next byte
.ad3b		d0 eb		bne $ad28			bne 	_MDDLLoop
.ad3d		e6 31		inc $31				inc 	codePtr+1
.ad3f		80 e7		bra $ad28			bra 	_MDDLLoop
.ad41						IMemoryFindEnd:
.ad41		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.ad43		85 3a		sta $3a				sta 	0+zTemp2
.ad45		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.ad47		85 3b		sta $3b				sta 	1+zTemp2
.ad49						_MDLFELoop:
.ad49		b2 3a		lda ($3a)			lda 	(zTemp2) 					; scan forward using offsets.
.ad4b		f0 0b		beq $ad58			beq 	_MDLFEExit
.ad4d		18		clc				clc
.ad4e		65 3a		adc $3a				adc 	zTemp2
.ad50		85 3a		sta $3a				sta 	zTemp2
.ad52		90 f5		bcc $ad49			bcc 	_MDLFELoop
.ad54		e6 3b		inc $3b				inc 	zTemp2+1
.ad56		80 f1		bra $ad49			bra 	_MDLFELoop
.ad58						_MDLFEExit:
.ad58		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/memory/memory.flat/insert.asm

.ad59						MemoryInsertLine:
.ad59		08		php				php
.ad5a		20 41 ad	jsr $ad41			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.ad5d		a5 3b		lda $3b				lda 	zTemp2+1 					; is there space for the new line ?
.ad5f		1a		inc a				inc 	a
.ad60		c9 7f		cmp #$7f			cmp 	#(BasicEnd >> 8)-1
.ad62		b0 36		bcs $ad9a			bcs 	_MDLIError 					; no, fail.
.ad64		28		plp				plp 								; do at a specific point or the end ?
.ad65		90 08		bcc $ad6f			bcc 	_MDLIFound 					; if specific point already set.
.ad67		a5 3a		lda $3a				lda 	zTemp2 						; if CS on entry append, so put on the
.ad69		85 30		sta $30				sta 	codePtr 					; end.
.ad6b		a5 3b		lda $3b				lda 	zTemp2+1
.ad6d		85 31		sta $31				sta 	codePtr+1
.ad6f						_MDLIFound:
.ad6f		ad 26 04	lda $0426			lda 	tokenOffset 				; insert gap in Y, the offset, e.g. length of the new line
.ad72		a8		tay				tay
.ad73						_MDLIInsert:
.ad73		b2 3a		lda ($3a)			lda 	(zTemp2) 					; shift one byte up , at least one covers end case (copying link 0)
.ad75		91 3a		sta ($3a),y			sta 	(zTemp2),y 					; work from top down.
.ad77		a5 30		lda $30				lda 	codePtr 					; reached insert point ?
.ad79		c5 3a		cmp $3a				cmp 	zTemp2
.ad7b		d0 06		bne $ad83			bne 	_MDLINext
.ad7d		a5 31		lda $31				lda 	codePtr+1
.ad7f		c5 3b		cmp $3b				cmp 	zTemp2+1
.ad81		f0 0a		beq $ad8d			beq 	_MDLIHaveSpace
.ad83						_MDLINext:
.ad83		a5 3a		lda $3a				lda 	zTemp2 						; if no, keep zTemp2 going backwards opening up space.
.ad85		d0 02		bne $ad89			bne 	_MDLINoBorrow
.ad87		c6 3b		dec $3b				dec 	zTemp2+1
.ad89						_MDLINoBorrow:
.ad89		c6 3a		dec $3a				dec 	zTemp2
.ad8b		80 e6		bra $ad73			bra 	_MDLIInsert
.ad8d						_MDLIHaveSpace:
.ad8d		ac 26 04	ldy $0426			ldy 	tokenOffset 				; bytes to copy
.ad90		88		dey				dey 								; from offset-1 (last written) to the end of the buffer.
.ad91						_MDLICopy:
.ad91		b9 26 04	lda $0426,y			lda 	tokenOffset,y
.ad94		91 30		sta ($30),y			sta 	(codePtr),y
.ad96		88		dey				dey
.ad97		10 f8		bpl $ad91			bpl 	_MDLICopy
.ad99		60		rts				rts
.ad9a						_MDLIError:
.ad9a		a9 06		lda #$06		lda	#6
.ad9c		4c 69 99	jmp $9969		jmp	ErrorHandler
.ad9f						MDLAppendLine:
.ad9f		86 37		stx $37				stx 	zTemp0+1 					; save new line at zTemp0
.ada1		85 36		sta $36				sta 	zTemp0
.ada3		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.ada5		85 38		sta $38				sta 	0+zTemp1
.ada7		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.ada9		85 39		sta $39				sta 	1+zTemp1
.adab		b2 38		lda ($38)			lda 	(zTemp1)
.adad		d0 0a		bne $adb9			bne 	_MDLANoInitialise
.adaf		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.adb1		8d a4 07	sta $07a4			sta 	0+AppendPointer
.adb4		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.adb6		8d a5 07	sta $07a5			sta 	1+AppendPointer
.adb9						_MDLANoInitialise:
.adb9		18		clc				clc
.adba		ad a4 07	lda $07a4			lda 	AppendPointer 				; copy append pointer to zTemp1 adding the offset as you go
.adbd		85 38		sta $38				sta 	zTemp1
.adbf		72 36		adc ($36)			adc 	(zTemp0)
.adc1		8d a4 07	sta $07a4			sta 	AppendPointer
.adc4		ad a5 07	lda $07a5			lda 	AppendPointer+1
.adc7		85 39		sta $39				sta 	zTemp1+1
.adc9		69 00		adc #$00			adc 	#0
.adcb		8d a5 07	sta $07a5			sta 	AppendPointer+1
.adce		a0 00		ldy #$00			ldy 	#0
.add0						_MDLACopy:
.add0		b1 36		lda ($36),y			lda 	(zTemp0),y 					; copy new line in
.add2		91 38		sta ($38),y			sta 	(zTemp1),y
.add4		c8		iny				iny
.add5		98		tya				tya
.add6		d2 36		cmp ($36)			cmp 	(zTemp0) 					; done whole line
.add8		d0 f6		bne $add0			bne 	_MDLACopy
.adda		a9 00		lda #$00			lda 	#0 							; end of program.
.addc		91 38		sta ($38),y			sta 	(zTemp1),y
.adde		60		rts				rts
.07a4						AppendPointer:
>07a4								.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/memory/memory.flat/memory.asm

.addf						MemoryNew:
.addf		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.ade1		85 30		sta $30				sta 	codePtr
.ade3		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.ade5		85 31		sta $31				sta 	codePtr+1
.ade7		a9 00		lda #$00			lda 	#0 							; write zero there erasing the program.
.ade9		92 30		sta ($30)			sta 	(codePtr)
.adeb		60		rts				rts
.adec						MemoryInline:
.adec		98		tya				tya 								; put address into stack,x
.aded		18		clc				clc  								; get the offset, add codePtr
.adee		65 30		adc $30				adc 	codePtr
.adf0		95 58		sta $58,x			sta 	NSMantissa0,x 				; store the result in the mantissa.
.adf2		a5 31		lda $31				lda 	codePtr+1
.adf4		69 00		adc #$00			adc 	#0
.adf6		95 60		sta $60,x			sta 	NSMantissa1,x
.adf8		74 68		stz $68,x			stz 	NSMantissa2,x
.adfa		74 70		stz $70,x			stz 	NSMantissa3,x
.adfc		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/memory/memory.flat/search.asm

.adfd						MemorySearch:
.adfd		85 36		sta $36				sta 	zTemp0 						; save line number in zTemp0
.adff		86 37		stx $37				stx 	zTemp0+1
.ae01		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.ae03		85 30		sta $30				sta 	codePtr
.ae05		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.ae07		85 31		sta $31				sta 	codePtr+1
.ae09						_MTAXLoop:
.ae09		b2 30		lda ($30)			lda 	(codePtr)
.ae0b		18		clc				clc
.ae0c		f0 21		beq $ae2f			beq 	_MTAXExit 					; reached end, exit with CC.
.ae0e		a0 01		ldy #$01			ldy 	#1 							; calculate current line# - requested line#
.ae10		b1 30		lda ($30),y			lda 	(codePtr),y
.ae12		38		sec				sec
.ae13		e5 36		sbc $36				sbc 	zTemp0
.ae15		85 38		sta $38				sta 	zTemp1 						; save interim to set Z
.ae17		c8		iny				iny 								; do the MSB
.ae18		b1 30		lda ($30),y			lda 	(codePtr),y
.ae1a		e5 37		sbc $37				sbc 	zTemp0+1
.ae1c		05 38		ora $38				ora 	zTemp1 						; will set Z if result is zero, doesn't affect carry flag
.ae1e		f0 0f		beq $ae2f			beq 	_MTAXExit	 				; found so exit (CS will be set)
.ae20		b0 0d		bcs $ae2f			bcs 	_MTAXExit 					; current < required exit
.ae22		18		clc				clc
.ae23		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.ae25		65 30		adc $30				adc 	codePtr
.ae27		85 30		sta $30				sta 	codePtr
.ae29		90 02		bcc $ae2d			bcc 	_CREExit
.ae2b		e6 31		inc $31				inc 	codePtr+1 					; carry
.ae2d						_CREExit:
.ae2d		80 da		bra $ae09			bra 	_MTAXLoop
.ae2f						_MTAXExit:
.ae2f		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/graphics/gcommand.asm

.ae30						RectangleCommand:
.ae30		a9 44		lda #$44			lda 	#GCMD_FrameRect				; frame rectangle
.ae32		80 02		bra $ae36			bra 	ShapeDrawCmd
.ae34						CircleCommand:
.ae34		a9 48		lda #$48			lda 	#GCMD_FrameCircle 				; framed circle
.ae36						ShapeDrawCmd:
.ae36		20 c0 ae	jsr $aec0			jsr 	RunGraphicsCommand
.ae39						ShapeDraw:
.ae39		0d a7 07	ora $07a7			ora 	gxFillSolid  				; adjust AXY for solid fill.
.ae3c		4c b4 ae	jmp $aeb4			jmp 	ExecuteGraphicCommand	 	; and complete
.ae3f						SpriteCommand:
.ae3f		a2 00		ldx #$00			ldx 	#0
.ae41		20 64 a8	jsr $a864			jsr 	Evaluate8BitInteger 		; get image number.
.ae44		5a		phy				phy
.ae45		a9 0e		lda #$0e			lda 	#GCMD_SpriteUse 			; use that image.
.ae47		a6 58		ldx $58				ldx 	NSMantissa0
.ae49		e0 40		cpx #$40			cpx 	#64 						; 0-63 only
.ae4b		b0 0d		bcs $ae5a			bcs 	_SCRange
.ae4d		a0 ff		ldy #$ff			ldy 	#255
.ae4f		20 61 80	jsr $8061			jsr 	GXGraphicDraw
.ae52		a9 52		lda #$52			lda 	#GCMD_SpriteMove
.ae54		7a		ply				ply
.ae55		20 c0 ae	jsr $aec0			jsr 	RunGraphicsCommand
.ae58		80 5a		bra $aeb4			bra 	ExecuteGraphicCommand
.ae5a						_SCRange:
.ae5a		4c 6a ab	jmp $ab6a			jmp 	RangeError
.ae5d						ImageCommand:
.ae5d		a2 00		ldx #$00			ldx 	#0
.ae5f		20 64 a8	jsr $a864			jsr 	Evaluate8BitInteger 		; get image number.
.ae62		20 c0 ae	jsr $aec0			jsr 	RunGraphicsCommand
.ae65						ImageRunDraw:
.ae65		09 40		ora #$40			ora 	#GCMD_Move					; move cursor
.ae67		20 61 80	jsr $8061			jsr 	GXGraphicDraw
.ae6a		ad ad 07	lda $07ad			lda 	gxDrawScale
.ae6d		0a		asl a				asl 	a
.ae6e		0a		asl a				asl 	a
.ae6f		0a		asl a				asl 	a
.ae70		a8		tay				tay
.ae71		a9 0c		lda #$0c			lda 	#GCMD_DrawSprite 			; image drawing
.ae73		a6 58		ldx $58				ldx 	NSMantissa0
.ae75		20 61 80	jsr $8061			jsr 	GXGraphicDraw
.ae78		60		rts				rts
.ae79						TextCommand:
.ae79		a2 00		ldx #$00			ldx 	#0
.ae7b		20 21 a8	jsr $a821			jsr 	EvaluateString 				; get text
.ae7e		20 c0 ae	jsr $aec0			jsr 	RunGraphicsCommand
.ae81						TextRunDraw:
.ae81		09 40		ora #$40			ora 	#GCMD_Move 					; move cursor
.ae83		20 61 80	jsr $8061			jsr 	GXGraphicDraw
.ae86		a0 00		ldy #$00			ldy 	#0
.ae88						_IRDLoop:
.ae88		a5 60		lda $60				lda 	NSMantissa1 				; access character
.ae8a		85 37		sta $37				sta 	zTemp0+1
.ae8c		a5 58		lda $58				lda 	NSMantissa0
.ae8e		85 36		sta $36				sta 	zTemp0
.ae90		b1 36		lda ($36),y			lda 	(zTemp0),y
.ae92		f0 13		beq $aea7			beq 	_IRDExit
.ae94		5a		phy				phy									; save string pos
.ae95		48		pha				pha 								; save char
.ae96		ad ad 07	lda $07ad			lda 	gxDrawScale 				; get scale
.ae99		0a		asl a				asl 	a
.ae9a		0a		asl a				asl 	a
.ae9b		0a		asl a				asl 	a
.ae9c		a8		tay				tay
.ae9d		a9 0a		lda #$0a			lda 	#GCMD_DrawFont 				; char drawing
.ae9f		fa		plx				plx 								; char to draw
.aea0		20 61 80	jsr $8061			jsr 	GXGraphicDraw
.aea3		7a		ply				ply 								; restore string pos
.aea4		c8		iny				iny
.aea5		90 e1		bcc $ae88			bcc 	_IRDLoop 					; go back if no error.
.aea7						_IRDExit:
.aea7		60		rts				rts
.aea8						PlotCommand:
.aea8		a9 50		lda #$50			lda 	#GCMD_Plot 					; command ID to use
.aeaa		20 c0 ae	jsr $aec0			jsr 	RunGraphicsCommand
.aead		80 05		bra $aeb4			bra 	ExecuteGraphicCommand
.aeaf						LineCommand:
.aeaf		a9 42		lda #$42			lda 	#GCMD_Line 						; command ID to use
.aeb1		20 c0 ae	jsr $aec0			jsr 	RunGraphicsCommand
.aeb4						ExecuteGraphicCommand:
.aeb4		0d a6 07	ora $07a6			ora 	gxCommandID 				; make a full command
.aeb7		20 61 80	jsr $8061			jsr 	GXGraphicDraw 				; draw it and exit
.aeba		b0 01		bcs $aebd			bcs 	_EGCError
.aebc		60		rts				rts
.aebd						_EGCError:
.aebd		4c 65 ab	jmp $ab65			jmp 	SyntaxError
.aec0						RunGraphicsCommand:
.aec0		8d a6 07	sta $07a6			sta 	gxCommandID					; save TODO graphics command.
.aec3		68		pla				pla 								; pop handler address
.aec4		fa		plx				plx
.aec5		1a		inc a				inc 	a
.aec6		d0 01		bne $aec9			bne 	_RGINoCarry
.aec8		e8		inx				inx
.aec9						_RGINoCarry:
.aec9		8d ab 07	sta $07ab			sta 	gxHandler
.aecc		8e ac 07	stx $07ac			stx 	gxHandler+1
.aecf						_RGICommandLoop:
.aecf		b1 30		lda ($30),y			lda 	(codePtr),y
.aed1		c8		iny				iny
.aed2		c9 db		cmp #$db			cmp 	#KWD_TO						; is it TO x,y
.aed4		f0 53		beq $af29			beq 	_RGI_To
.aed6		c9 c5		cmp #$c5			cmp 	#KWD_HERE 					; do it here.
.aed8		f0 55		beq $af2f			beq 	_RGI_Here
.aeda		c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL or : , exit
.aedc		f0 3d		beq $af1b			beq 	_RGI_Exit
.aede		c9 3a		cmp #$3a			cmp 	#KWD_COLON
.aee0		f0 39		beq $af1b			beq 	_RGI_Exit
.aee2		c9 cd		cmp #$cd			cmp 	#KWD_OUTLINE 				; solid or outline
.aee4		f0 3e		beq $af24			beq 	_RGI_Frame
.aee6		c9 d7		cmp #$d7			cmp 	#KWD_SOLID
.aee8		f0 33		beq $af1d			beq 	_RGI_Solid
.aeea		c9 b9		cmp #$b9			cmp 	#KWD_BY 					; by offset
.aeec		f0 4b		beq $af39			beq 	_RGI_By
.aeee		c9 c3		cmp #$c3			cmp 	#KWD_FROM 					; from
.aef0		f0 17		beq $af09			beq 	_RGI_Move2
.aef2		c9 c0		cmp #$c0			cmp 	#KWD_DIM 					; dim (set scale)
.aef4		f0 62		beq $af58			beq 	_RGI_Dim
.aef6		c9 be		cmp #$be			cmp 	#KWD_COLOUR 				; colour or Color
.aef8		f0 74		beq $af6e			beq 	_RGI_Colour
.aefa		c9 bd		cmp #$bd			cmp 	#KWD_COLOR
.aefc		f0 70		beq $af6e			beq 	_RGI_Colour
.aefe		ae a6 07	ldx $07a6			ldx 	gxCommandID
.af01		e0 52		cpx #$52			cpx 	#GCMD_SpriteMove 			; if not sprite
.af03		d0 03		bne $af08			bne 	_RGI_Move 					; move
.af05		4c 96 af	jmp $af96			jmp		_RGI_SpriteInstructions
.af08						_RGI_Move:
.af08		88		dey				dey 								; unpick get.
.af09						_RGI_Move2:
.af09		20 bc af	jsr $afbc			jsr 	GCGetCoordinatePair 		; move to here
.af0c		20 e3 af	jsr $afe3			jsr 	GCCopyPairToStore 			; save
.af0f		5a		phy				phy
.af10		20 d9 af	jsr $afd9			jsr 	GCLoadAXY 					; load in
.af13		09 40		ora #$40			ora 	#GCMD_Move 					; move there
.af15		20 61 80	jsr $8061			jsr 	GXGraphicDraw
.af18		7a		ply				ply
.af19		80 b4		bra $aecf			bra 	_RGICommandLoop 			; and go round
.af1b						_RGI_Exit:
.af1b		88		dey				dey 								; unpick : / EOL
.af1c		60		rts				rts
.af1d						_RGI_Solid:
.af1d		a9 02		lda #$02			lda 	#2
.af1f		8d a7 07	sta $07a7			sta 	gxFillSolid
.af22		80 ab		bra $aecf			bra 	_RGICommandLoop
.af24						_RGI_Frame:
.af24		9c a7 07	stz $07a7			stz 	gxFillSolid
.af27		80 a6		bra $aecf			bra 	_RGICommandLoop
.af29						_RGI_To:
.af29		20 bc af	jsr $afbc			jsr 	GCGetCoordinatePair 		; get coordinate pair into slot #1,#2
.af2c		20 e3 af	jsr $afe3			jsr 	GCCopyPairToStore
.af2f						_RGI_Here:
.af2f		5a		phy				phy
.af30		20 d9 af	jsr $afd9			jsr 	GCLoadAXY 					; load it into AXY
.af33		20 93 af	jsr $af93			jsr 	_RGICallHandler 			; go do whatever it is.
.af36		7a		ply				ply
.af37		80 96		bra $aecf			bra 	_RGICommandLoop 			; and go round
.af39						_RGI_By:
.af39		20 c9 af	jsr $afc9			jsr 	GCSignedCoordinatePair 		; get coordinate pair into slot #1,#2
.af3c		18		clc				clc
.af3d		a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.af3f		6d a8 07	adc $07a8			adc 	gxXPos
.af42		8d a8 07	sta $07a8			sta 	gxXPos
.af45		a5 61		lda $61				lda 	NSMantissa1+1
.af47		6d a9 07	adc $07a9			adc 	gxXPos+1
.af4a		8d a9 07	sta $07a9			sta 	gxXPos+1
.af4d		a5 5a		lda $5a				lda 	NSMantissa0+2
.af4f		18		clc				clc
.af50		6d aa 07	adc $07aa			adc 	gxYPos
.af53		8d aa 07	sta $07aa			sta 	gxYPos
.af56		80 d7		bra $af2f			bra 	_RGI_Here
.af58						_RGI_Dim:
.af58		a2 01		ldx #$01			ldx	 	#1
.af5a		20 64 a8	jsr $a864			jsr 	Evaluate8BitInteger
.af5d		a5 59		lda $59				lda 	NSMantissa0+1
.af5f		c9 00		cmp #$00			cmp 	#0
.af61		f0 2d		beq $af90			beq 	_RGIRange
.af63		c9 09		cmp #$09			cmp 	#8+1
.af65		b0 29		bcs $af90			bcs		_RGIRange
.af67		3a		dec a				dec 	a
.af68		8d ad 07	sta $07ad			sta 	gxDrawScale
.af6b		4c cf ae	jmp $aecf			jmp 	_RGICommandLoop
.af6e						_RGI_Colour:
.af6e		a2 01		ldx #$01			ldx 	#1 							; colour
.af70		20 64 a8	jsr $a864			jsr 	Evaluate8BitInteger
.af73		a2 02		ldx #$02			ldx 	#2 							; default zero for 2nd parameter
.af75		20 c9 a8	jsr $a8c9			jsr 	NSMSetZero
.af78		b1 30		lda ($30),y			lda 	(codePtr),y
.af7a		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; check , => mode.
.af7c		d0 04		bne $af82			bne 	_RGICDefaultMode
.af7e		c8		iny				iny
.af7f		20 64 a8	jsr $a864			jsr 	Evaluate8BitInteger
.af82						_RGICDefaultMode:
.af82		5a		phy				phy
.af83		a9 08		lda #$08			lda 	#GCMD_Colour 				; set colour.
.af85		a6 59		ldx $59				ldx 	NSMantissa0+1
.af87		a4 5a		ldy $5a				ldy 	NSMantissa0+2
.af89		20 61 80	jsr $8061			jsr 	GXGraphicDraw
.af8c		7a		ply				ply
.af8d		4c cf ae	jmp $aecf			jmp 	_RGICommandLoop 			; and go round
.af90						_RGIRange:
.af90		4c 6a ab	jmp $ab6a			jmp 	RangeError
.af93						_RGICallHandler:
.af93		6c ab 07	jmp ($07ab)			jmp 	(gxHandler)
.af96						_RGI_SpriteInstructions:
.af96		c9 cb		cmp #$cb			cmp 	#KWD_OFF
.af98		f0 07		beq $afa1			beq 	_RGISpriteOff
.af9a		c9 c6		cmp #$c6			cmp 	#KWD_IMAGE
.af9c		f0 13		beq $afb1			beq 	_RGISetImage
.af9e		4c 08 af	jmp $af08			jmp 	_RGI_Move
.afa1						_RGISpriteOff:
.afa1		5a		phy				phy
.afa2		a0 01		ldy #$01			ldy 	#1
.afa4		a2 00		ldx #$00			ldx 	#0
.afa6						_RGIDoCommandLoop:
.afa6		a9 10		lda #$10			lda 	#GCMD_SpriteImage
.afa8		20 61 80	jsr $8061			jsr 	GXGraphicDraw
.afab		7a		ply				ply
.afac		b0 e2		bcs $af90			bcs 	_RGIRange
.afae		4c cf ae	jmp $aecf			jmp 	_RGICommandLoop
.afb1						_RGISetImage:
.afb1		a2 01		ldx #$01			ldx 	#1
.afb3		20 64 a8	jsr $a864			jsr 	Evaluate8BitInteger
.afb6		5a		phy				phy
.afb7		aa		tax				tax
.afb8		a0 00		ldy #$00			ldy 	#0
.afba		80 ea		bra $afa6			bra 	_RGIDoCommandLoop
.afbc						GCGetCoordinatePair:
.afbc		a2 01		ldx #$01			ldx 	#1
.afbe		20 49 a8	jsr $a849			jsr 	Evaluate16BitInteger
.afc1		20 58 99	jsr $9958			jsr 	CheckComma
.afc4		e8		inx				inx
.afc5		20 49 a8	jsr $a849			jsr 	Evaluate16BitInteger
.afc8		60		rts				rts
.afc9						GCSignedCoordinatePair:
.afc9		a2 01		ldx #$01			ldx 	#1
.afcb		20 53 a8	jsr $a853			jsr 	Evaluate16BitIntegerSigned
.afce		20 58 99	jsr $9958			jsr 	CheckComma
.afd1		e8		inx				inx
.afd2		20 53 a8	jsr $a853			jsr 	Evaluate16BitIntegerSigned
.afd5		60		rts				rts
.afd6						_GCCPRange:
.afd6		4c 6a ab	jmp $ab6a			jmp 	RangeError
.afd9						GCLoadAXY:
.afd9		ad a9 07	lda $07a9			lda 	gxXPos+1
.afdc		ae a8 07	ldx $07a8			ldx 	gxXPos
.afdf		ac aa 07	ldy $07aa			ldy 	gxYPos
.afe2		60		rts				rts
.afe3						GCCopyPairToStore:
.afe3		a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.afe5		8d a8 07	sta $07a8			sta 	gxXPos
.afe8		a5 61		lda $61				lda 	NSMantissa1+1
.afea		8d a9 07	sta $07a9			sta 	gxXPos+1
.afed		a5 5a		lda $5a				lda 	NSMantissa0+2
.afef		8d aa 07	sta $07aa			sta 	gxYPos
.aff2		60		rts				rts
.07a6						gxCommandID:
>07a6								.fill 	1
.07a7						gxFillSolid:
>07a7								.fill 	1
.07a8						gxXPos:
>07a8								.fill 	2
.07aa						gxYPos:
>07aa								.fill 	1
.07ab						gxHandler:
>07ab								.fill 	2
.07ad						gxDrawScale:
>07ad								.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/graphics/gcontrol.asm

.aff3						BitmapCtrl:
.aff3		b1 30		lda ($30),y			lda 	(codePtr),y
.aff5		c8		iny				iny
.aff6		a2 01		ldx #$01			ldx 	#1
.aff8		c9 cc		cmp #$cc			cmp 	#KWD_ON
.affa		f0 11		beq $b00d			beq 	BitmapSwitch
.affc		ca		dex				dex
.affd		c9 cb		cmp #$cb			cmp 	#KWD_OFF
.afff		f0 0c		beq $b00d			beq 	BitmapSwitch
.b001		20 64 a8	jsr $a864			jsr 	Evaluate8BitInteger 		; get the colour
.b004		5a		phy				phy
.b005		aa		tax				tax
.b006		a9 06		lda #$06			lda 	#GCMD_Clear					; clear to that colour
.b008		20 61 80	jsr $8061			jsr 	GXGraphicDraw
.b00b		7a		ply				ply
.b00c		60		rts				rts
.b00d						BitmapSwitch:
.b00d		5a		phy				phy
.b00e		a0 00		ldy #$00			ldy 	#0 							; gfx 1,on/off,0
.b010		a9 02		lda #$02			lda 	#GCMD_BitmapCtl
.b012		20 61 80	jsr $8061			jsr 	GXGraphicDraw
.b015		a9 08		lda #$08			lda 	#GCMD_Colour				; set colour to $FF
.b017		a0 00		ldy #$00			ldy 	#0
.b019		a2 ff		ldx #$ff			ldx 	#$FF
.b01b		20 61 80	jsr $8061			jsr 	GXGraphicDraw
.b01e		9c a7 07	stz $07a7			stz 	gxFillSolid
.b021		9c a8 07	stz $07a8			stz 	gxXPos
.b024		9c a9 07	stz $07a9			stz 	gxXPos+1
.b027		9c aa 07	stz $07aa			stz 	gxYPos
.b02a		9c ad 07	stz $07ad			stz 	gxDrawScale
.b02d		a9 40		lda #$40			lda 	#GCMD_Move 						; home cursor
.b02f		a2 00		ldx #$00			ldx 	#0
.b031		a0 00		ldy #$00			ldy 	#0
.b033		20 61 80	jsr $8061			jsr 	GXGraphicDraw
.b036		7a		ply				ply
.b037		60		rts				rts
.b038						SpritesCtrl:
.b038		b1 30		lda ($30),y			lda 	(codePtr),y
.b03a		c8		iny				iny
.b03b		a2 01		ldx #$01			ldx 	#1
.b03d		c9 cc		cmp #$cc			cmp 	#KWD_ON
.b03f		f0 08		beq $b049			beq 	SpriteSwitch
.b041		ca		dex				dex
.b042		c9 cb		cmp #$cb			cmp 	#KWD_OFF
.b044		f0 03		beq $b049			beq 	SpriteSwitch
.b046		4c 65 ab	jmp $ab65			jmp 	SyntaxError
.b049						SpriteSwitch:
.b049		5a		phy				phy
.b04a		a0 00		ldy #$00			ldy 	#0 							; gfx 2,on/off,0
.b04c		a9 04		lda #$04			lda 	#GCMD_SpriteCtl
.b04e		20 61 80	jsr $8061			jsr 	GXGraphicDraw
.b051		7a		ply				ply
.b052		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/graphics/gfx.asm

.b053						GfxCommand:
.b053		a2 00		ldx #$00			ldx 	#0
.b055		20 64 a8	jsr $a864			jsr 	Evaluate8BitInteger 		; command
.b058		20 58 99	jsr $9958			jsr 	CheckComma
.b05b		e8		inx				inx
.b05c		20 49 a8	jsr $a849			jsr 	Evaluate16BitInteger 		; X
.b05f		20 58 99	jsr $9958			jsr 	CheckComma
.b062		e8		inx				inx
.b063		20 64 a8	jsr $a864			jsr 	Evaluate8BitInteger 		; Y
.b066		a5 61		lda $61				lda 	NSMantissa1+1  				; shift bit 0 of X into CS, should now be zero
.b068		4a		lsr a				lsr 	a
.b069		d0 12		bne $b07d			bne 	_GfxError
.b06b		26 58		rol $58				rol 	NSMantissa0 				; rotate into command
.b06d		b0 0e		bcs $b07d			bcs 	_GfxError 					; bit 7 should have been zero
.b06f		5a		phy				phy 								; save pos
.b070		a5 58		lda $58				lda 	NSMantissa0 				; do the command
.b072		a6 59		ldx $59				ldx 	NSMantissa0+1
.b074		a4 5a		ldy $5a				ldy 	NSMantissa0+2
.b076		20 61 80	jsr $8061			jsr 	GXGraphicDraw
.b079		b0 02		bcs $b07d			bcs 	_GfxError
.b07b		7a		ply				ply 								; restore pos and exit.
.b07c		60		rts				rts
.b07d						_GfxError:
.b07d		4c 6a ab	jmp $ab6a			jmp 	RangeError

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/graphics/hit.asm

.b080						UnaryHit:
.b080		fa		plx				plx
.b081		a9 36		lda #$36			lda 	#zTemp0
.b083		20 64 a8	jsr $a864			jsr 	Evaluate8BitInteger 		; get sprite number 0
.b086		20 58 99	jsr $9958			jsr 	CheckComma
.b089		e8		inx				inx
.b08a		20 64 a8	jsr $a864			jsr 	Evaluate8BitInteger 		; get sprite number 1
.b08d		20 50 99	jsr $9950			jsr		CheckRightBracket
.b090		ca		dex				dex 								; fix back up again.
.b091		da		phx				phx 								; save X/Y
.b092		5a		phy				phy
.b093		b4 59		ldy $59,x			ldy 	NSMantissa0+1,x 			; get the sprite numbers into X/Y
.b095		b5 58		lda $58,x			lda 	NSMantissa0,x
.b097		aa		tax				tax
.b098		a9 12		lda #$12			lda 	#GCMD_SpriteCollide 		; command check collision.
.b09a		20 61 80	jsr $8061			jsr 	GXGraphicDraw 				; calculate result
.b09d		1a		inc a				inc 	a 							; so 255 (fail) -> 0, otherwise 1,2,3,4 pixels etc.
.b09e		7a		ply				ply 								; restore XY
.b09f		fa		plx				plx
.b0a0		20 cb a8	jsr $a8cb			jsr 	NSMSetByte 					; return the hit result
.b0a3		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/graphics/palette.asm

.b0a4						PaletteCommand:
.b0a4		a2 00		ldx #$00			ldx 	#0
.b0a6		20 64 a8	jsr $a864			jsr 	Evaluate8BitInteger 		; colour
.b0a9		20 58 99	jsr $9958			jsr 	CheckComma
.b0ac		e8		inx				inx
.b0ad		20 49 a8	jsr $a849			jsr 	Evaluate16BitInteger 		; r
.b0b0		20 58 99	jsr $9958			jsr 	CheckComma
.b0b3		e8		inx				inx
.b0b4		20 64 a8	jsr $a864			jsr 	Evaluate8BitInteger 		; g
.b0b7		20 58 99	jsr $9958			jsr 	CheckComma
.b0ba		e8		inx				inx
.b0bb		20 64 a8	jsr $a864			jsr 	Evaluate8BitInteger 		; b
.b0be		a5 58		lda $58				lda 	NSMantissa0 				; get colour #
.b0c0		85 36		sta $36				sta 	zTemp0
.b0c2		a9 34		lda #$34			lda 	#$D0 >> 2 					; MSB = D0/4
.b0c4		85 37		sta $37				sta 	zTemp0+1
.b0c6		06 36		asl $36				asl 	zTemp0 						; zTemp = $D000+Colour x 4
.b0c8		26 37		rol $37				rol	 	zTemp0+1
.b0ca		06 36		asl $36				asl 	zTemp0
.b0cc		26 37		rol $37				rol	 	zTemp0+1
.b0ce		a9 01		lda #$01			lda 	#1 							; I/O Page 2
.b0d0		85 01		sta $01				sta 	1
.b0d2		5a		phy				phy
.b0d3		a5 5b		lda $5b				lda 	NSMantissa0+3 				; fix to r,g,b
.b0d5		92 36		sta ($36)			sta 	(zTemp0)
.b0d7		a0 01		ldy #$01			ldy 	#1
.b0d9		a5 5a		lda $5a				lda 	NSMantissa0+2
.b0db		91 36		sta ($36),y			sta 	(zTemp0),y
.b0dd		a5 59		lda $59				lda 	NSMantissa0+1
.b0df		c8		iny				iny
.b0e0		91 36		sta ($36),y			sta 	(zTemp0),y
.b0e2		7a		ply				ply
.b0e3		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/hardware/cls.asm

.b0e4						ClearScreen:
.b0e4		5a		phy				phy
.b0e5		a9 0c		lda #$0c			lda 	#12 						; char code 12 clears the screen.
.b0e7		20 43 80	jsr $8043			jsr 	EXTPrintCharacter
.b0ea		7a		ply				ply
.b0eb		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/sound/effects.asm

.b0ec						PingCommand:
.b0ec		5a		phy				phy 								; save pos
.b0ed		a9 01		lda #$01			lda 	#1 						; push channel.
.b0ef		48		pha				pha
.b0f0		a9 c8		lda #$c8			lda 	#200 						; pitch LSB
.b0f2		a2 06		ldx #$06			ldx 	#6 						; length
.b0f4		a0 00		ldy #$00			ldy 	#0 						; slide LSB
.b0f6		80 24		bra $b11c			bra 	SoundEffectCommand
.b0f8						ZapCommand:
.b0f8		5a		phy				phy 								; save pos
.b0f9		a9 01		lda #$01			lda 	#1 						; push channel.
.b0fb		48		pha				pha
.b0fc		a9 ff		lda #$ff			lda 	#255 						; pitch LSB
.b0fe		a2 0a		ldx #$0a			ldx 	#10 						; length
.b100		a0 0a		ldy #$0a			ldy 	#10 						; slide LSB
.b102		80 18		bra $b11c			bra 	SoundEffectCommand
.b104						ShootCommand:
.b104		5a		phy				phy 								; save pos
.b105		a9 03		lda #$03			lda 	#3 						; push channel.
.b107		48		pha				pha
.b108		a9 20		lda #$20			lda 	#32 						; pitch LSB
.b10a		a2 04		ldx #$04			ldx 	#4 						; length
.b10c		a0 00		ldy #$00			ldy 	#0 						; slide LSB
.b10e		80 0c		bra $b11c			bra 	SoundEffectCommand
.b110						Explode:
.b110		5a		phy				phy 								; save pos
.b111		a9 03		lda #$03			lda 	#3 						; push channel.
.b113		48		pha				pha
.b114		a9 50		lda #$50			lda 	#80 						; pitch LSB
.b116		a2 0a		ldx #$0a			ldx 	#10 						; length
.b118		a0 00		ldy #$00			ldy 	#0 						; slide LSB
.b11a		80 00		bra $b11c			bra 	SoundEffectCommand
.b11c						SoundEffectCommand:
.b11c		8d ae 07	sta $07ae			sta 	SoundCommandBlock 			; set up the command block in sound.asm
.b11f		9c af 07	stz $07af			stz 	SoundCommandBlock+1
.b122		a9 0f		lda #$0f			lda 	#15
.b124		8d b0 07	sta $07b0			sta 	SoundCommandBlock+2
.b127		8e b1 07	stx $07b1			stx 	SoundCommandBlock+3
.b12a		8c b2 07	sty $07b2			sty 	SoundCommandBlock+4
.b12d		9c b3 07	stz $07b3			stz 	SoundCommandBlock+5
.b130		68		pla				pla
.b131		09 10		ora #$10			ora 	#$10  						; execute command $11
.b133		a2 ae		ldx #$ae			ldx 	#(SoundCommandBlock & $FF)
.b135		a0 07		ldy #$07			ldy 	#(SoundCommandBlock >> 8)
.b137		20 6b 80	jsr $806b			jsr 	SNDCommand
.b13a		7a		ply				ply
.b13b		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/sound/playing.asm

.b13c						UnaryPlaying:
.b13c		fa		plx				plx
.b13d		20 64 a8	jsr $a864			jsr 	Evaluate8BitInteger 		; get channel #
.b140		48		pha				pha
.b141		20 50 99	jsr $9950			jsr		CheckRightBracket
.b144		68		pla				pla
.b145		c9 04		cmp #$04			cmp 	#4
.b147		b0 0c		bcs $b155			bcs 	_UPNotPlaying
.b149		09 20		ora #$20			ora 	#$20 						; query playing ?
.b14b		20 6b 80	jsr $806b			jsr 	SNDCommand
.b14e		c9 00		cmp #$00			cmp 	#0
.b150		f0 03		beq $b155			beq 	_UPNotPlaying
.b152		4c dc 99	jmp $99dc			jmp 	ReturnTrue
.b155						_UPNotPlaying:
.b155		4c e7 99	jmp $99e7			jmp 	ReturnFalse

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/sound/sound.asm

.b158						SoundCommand:
.b158		b1 30		lda ($30),y			lda 	(codePtr),y
.b15a		c9 cb		cmp #$cb			cmp 	#KWD_OFF 					; SOUND OFF ?
.b15c		d0 09		bne $b167			bne 	_SNDMain
.b15e		c8		iny				iny 								; skip OFF
.b15f		a9 3f		lda #$3f			lda 	#$3F 						; call command $3F (silence)
.b161		5a		phy				phy
.b162		20 6b 80	jsr $806b			jsr 	SNDCommand
.b165		7a		ply				ply
.b166		60		rts				rts
.b167						_SNDMain:
.b167		a2 00		ldx #$00			ldx 	#0
.b169		20 64 a8	jsr $a864			jsr 	Evaluate8BitInteger 		; channel
.b16c		c9 04		cmp #$04			cmp 	#4 							; must be 0-3
.b16e		b0 4b		bcs $b1bb			bcs 	_SndError
.b170		e8		inx				inx 								; do the rest in slot 1.
.b171		20 58 99	jsr $9958			jsr 	CheckComma
.b174		20 49 a8	jsr $a849			jsr 	Evaluate16BitInteger 		; Pitch
.b177		b5 60		lda $60,x			lda 	NSMantissa1,x 				; must be 10 bit
.b179		c9 10		cmp #$10			cmp 	#16
.b17b		b0 3e		bcs $b1bb			bcs 	_SndError
.b17d		8d af 07	sta $07af			sta 	SoundCommandBlock+1 		; Pitch (2 bytes + 0)
.b180		b5 58		lda $58,x			lda 	NSMantissa0,x
.b182		8d ae 07	sta $07ae			sta 	SoundCommandBlock
.b185		20 58 99	jsr $9958			jsr 	CheckComma
.b188		20 64 a8	jsr $a864			jsr 	Evaluate8BitInteger 		; Length (1 byte + 3)
.b18b		8d b1 07	sta $07b1			sta 	SoundCommandBlock+3
.b18e		a9 0f		lda #$0f			lda 	#15
.b190		8d b0 07	sta $07b0			sta 	SoundCommandBlock+2 		; Volume (1 byte + 2)
.b193		9c b2 07	stz $07b2			stz 	SoundCommandBlock+4 		; default slide (2 bytes +4)
.b196		9c b3 07	stz $07b3			stz 	SoundCommandBlock+5
.b199		b1 30		lda ($30),y			lda 	(codePtr),y
.b19b		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.b19d		d0 0e		bne $b1ad			bne 	_SNDPlay
.b19f		c8		iny				iny
.b1a0		20 53 a8	jsr $a853			jsr 	Evaluate16BitIntegerSigned 	; Slide
.b1a3		b5 58		lda $58,x			lda 	NSMantissa0,x 				; Slide (2 bytes + 4)
.b1a5		8d b2 07	sta $07b2			sta 	SoundCommandBlock+4
.b1a8		b5 60		lda $60,x			lda 	NSMantissa1,x
.b1aa		8d b3 07	sta $07b3			sta 	SoundCommandBlock+5
.b1ad						_SNDPlay:
.b1ad		5a		phy				phy
.b1ae		a5 58		lda $58				lda 	NSMantissa0 				; channel.
.b1b0		09 10		ora #$10			ora 	#$10 						; 1x = Queue sound
.b1b2		a2 ae		ldx #$ae			ldx 	#(SoundCommandBlock & $FF)
.b1b4		a0 07		ldy #$07			ldy 	#(SoundCommandBlock >> 8)
.b1b6		20 6b 80	jsr $806b			jsr 	SNDCommand
.b1b9		7a		ply				ply
.b1ba		60		rts				rts
.b1bb						_SndError:
.b1bb		4c 6a ab	jmp $ab6a			jmp 	RangeError
.07ae						SoundCommandBlock:
>07ae								.fill 	6

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/bytes.asm

.b1be						StackPushByte:
.b1be		48		pha				pha 								; save byte on stack
.b1bf		a5 34		lda $34				lda 	basicStack 					; decrement basic stack pointer
.b1c1		d0 08		bne $b1cb			bne 	_SPBNoBorrow
.b1c3		c6 35		dec $35				dec 	basicStack+1 				; borrow
.b1c5		a5 35		lda $35				lda 	basicStack+1 				; check range.
.b1c7		c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.b1c9		90 06		bcc $b1d1			bcc 	_SPBMemory
.b1cb						_SPBNoBorrow:
.b1cb		c6 34		dec $34				dec 	basicStack
.b1cd		68		pla				pla 								; get back and write
.b1ce		92 34		sta ($34)			sta 	(basicStack)
.b1d0		60		rts				rts
.b1d1						_SPBMemory:
.b1d1		a9 12		lda #$12		lda	#18
.b1d3		4c 69 99	jmp $9969		jmp	ErrorHandler
.b1d6						StackPopByte:
.b1d6		b2 34		lda ($34)			lda 	(basicStack) 				; bump the stack pointer.
.b1d8		e6 34		inc $34				inc 	basicStack
.b1da		d0 02		bne $b1de			bne 	_SPBNoCarry
.b1dc		e6 35		inc $35				inc 	basicStack+1
.b1de						_SPBNoCarry:
.b1de		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/frames.asm

.b1df						StackOpen:
.b1df		48		pha				pha 								; save frame byte
.b1e0		29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.b1e2		0a		asl a				asl 	a 							; claim twice this for storage
.b1e3		49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.b1e5		38		sec				sec 								; so basically subtracting from
.b1e6		65 34		adc $34				adc 	basicStack 	 				; basicStack
.b1e8		85 34		sta $34				sta 	basicStack
.b1ea		b0 09		bcs $b1f5			bcs 	_SONoBorrow
>b1ec		db						.byte 	$DB 						; causes a break in the emulator
.b1ed		c6 35		dec $35				dec 	basicStack+1
.b1ef		a5 35		lda $35				lda 	basicStack+1 				; have we reached stack overflow
.b1f1		c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.b1f3		90 04		bcc $b1f9			bcc 	_SOMemory
.b1f5						_SONoBorrow:
.b1f5		68		pla				pla 								; get marker back and write at TOS
.b1f6		92 34		sta ($34)			sta 	(basicStack)
.b1f8		60		rts				rts
.b1f9						_SOMemory:
.b1f9		a9 12		lda #$12		lda	#18
.b1fb		4c 69 99	jmp $9969		jmp	ErrorHandler
.b1fe						StackClose:
.b1fe		b2 34		lda ($34)			lda 	(basicStack) 				; get TOS marker
.b200		29 0f		and #$0f			and 	#$0F 						; bytes to add back
.b202		0a		asl a				asl 	a 							; claim twice this.
.b203		65 34		adc $34				adc 	basicStack 					; add to the stack pointer.
.b205		85 34		sta $34				sta 	basicStack
.b207		90 02		bcc $b20b			bcc 	_SCExit
.b209		e6 35		inc $35				inc 	basicStack+1
.b20b						_SCExit:
.b20b		60		rts				rts
.b20c						StackCheckFrame:
.b20c		48		pha				pha
.b20d						_StackRemoveLocals:
.b20d		b2 34		lda ($34)			lda 	(basicStack) 				; check for local, keep popping them
.b20f		c9 03		cmp #$03			cmp 	#STK_LOCALS+1 				; is the frame a local ? S or N are 1/0
.b211		b0 05		bcs $b218			bcs 	_SCNoLocal
.b213		20 74 91	jsr $9174			jsr 	LocalPopValue 				; restore the local value
.b216		80 f5		bra $b20d			bra 	_StackRemoveLocals 			; gr round again
.b218						_SCNoLocal:
.b218		68		pla				pla 								; get the frame check.
.b219		52 34		eor ($34)			eor 	(basicStack) 				; xor with toS marker
.b21b		29 f0		and #$f0			and 	#$F0 						; check type bits
.b21d		d0 01		bne $b220			bne 	_SCFError 					; different, we have structures mixed up
.b21f		60		rts				rts
.b220						_SCFError:
.b220		8a		txa				txa 								; report error X
.b221		4c 69 99	jmp $9969			jmp 	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/location.asm

.b224						STKSaveCodePosition:
.b224		5a		phy				phy
.b225		98		tya				tya 								; save Y
.b226		a0 05		ldy #$05			ldy 	#5
.b228		91 34		sta ($34),y			sta 	(basicStack),y
.b22a		88		dey				dey 								; save Code Pointer
.b22b						_STKSaveLoop:
.b22b		b9 2f 00	lda $002f,y			lda 	safePtr-1,y 				; allows us to access the pointer w/out issues.
.b22e		91 34		sta ($34),y			sta 	(basicStack),y
.b230		88		dey				dey
.b231		d0 f8		bne $b22b			bne 	_STKSaveLoop
.b233		7a		ply				ply
.b234		60		rts				rts
.b235						STKLoadCodePosition:
.b235		a0 01		ldy #$01			ldy 	#1 							; load code pointer back
.b237						_STKLoadLoop:
.b237		b1 34		lda ($34),y			lda 	(basicStack),y
.b239		99 2f 00	sta $002f,y			sta 	safePtr-1,y
.b23c		c8		iny				iny
.b23d		c0 05		cpy #$05			cpy 	#5
.b23f		d0 f6		bne $b237			bne 	_STKLoadLoop
.b241		b1 34		lda ($34),y			lda 	(basicStack),y 				; get Y offset
.b243		a8		tay				tay
.b244		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/setup.asm

.b245						StackReset:
.b245		a9 ff		lda #$ff			lda 	#((BasicStackBase+BasicStackSize-1) & $FF)
.b247		85 34		sta $34				sta 	0+basicStack
.b249		a9 0f		lda #$0f			lda 	#((BasicStackBase+BasicStackSize-1) >> 8)
.b24b		85 35		sta $35				sta 	1+basicStack
.b24d		a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.b24f		92 34		sta ($34)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.b251		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/concrete.asm

.b252						StringConcrete:
.b252		5a		phy				phy 								; save position on stack
.b253		20 a9 a4	jsr $a4a9			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.b256		b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy target string to zTemp1
.b258		85 38		sta $38				sta 	zTemp1
.b25a		b5 60		lda $60,x			lda 	NSMantissa1,x
.b25c		85 39		sta $39				sta 	zTemp1+1
.b25e		a0 ff		ldy #$ff			ldy 	#$FF	 					; calculate string length
.b260						_SALength:
.b260		c8		iny				iny
.b261		b1 38		lda ($38),y			lda 	(zTemp1),y
.b263		d0 fb		bne $b260			bne 	_SALength
.b265		c0 fd		cpy #$fd			cpy 	#253 						; string too long - cannot concrete.
.b267		b0 3d		bcs $b2a6			bcs 	_SALengthError
.b269		98		tya				tya 				 				; length of the new string
.b26a		18		clc				clc
.b26b		69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.b26d		90 02		bcc $b271			bcc 	_SAHaveLength
.b26f		a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.b271						_SAHaveLength:
.b271		48		pha				pha 								; save length.
.b272		38		sec				sec
.b273		49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.b275		6d 0a 04	adc $040a			adc 	stringMemory
.b278		8d 0a 04	sta $040a			sta 	stringMemory
.b27b		85 3a		sta $3a				sta 	zTemp2 						; update storage address
.b27d		95 58		sta $58,x			sta 	NSMantissa0,x 				; update mantissa address
.b27f		a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.b281		6d 0b 04	adc $040b			adc 	stringMemory+1
.b284		8d 0b 04	sta $040b			sta 	stringMemory+1
.b287		85 3b		sta $3b				sta 	zTemp2+1
.b289		95 60		sta $60,x			sta 	NSMantissa1,x
.b28b		68		pla				pla 								; save length-3 (chars allowed) in first byte
.b28c		38		sec				sec
.b28d		e9 03		sbc #$03			sbc 	#3
.b28f		92 3a		sta ($3a)			sta 	(zTemp2)
.b291		a9 00		lda #$00			lda 	#0 							; clear the status byte.
.b293		a0 01		ldy #$01			ldy 	#1
.b295		91 3a		sta ($3a),y			sta 	(zTemp2),y
.b297						_SACopyNewString:
.b297		a0 00		ldy #$00			ldy 	#0
.b299						_SACopyNSLoop:
.b299		b1 38		lda ($38),y			lda 	(zTemp1),y 					; get character
.b29b		c8		iny				iny 								; write two on in string storage
.b29c		c8		iny				iny
.b29d		91 3a		sta ($3a),y			sta 	(zTemp2),y
.b29f		88		dey				dey 								; this makes it one one.
.b2a0		c9 00		cmp #$00			cmp 	#0 							; until EOS copied
.b2a2		d0 f5		bne $b299			bne 	_SACopyNSLoop
.b2a4		7a		ply				ply
.b2a5		60		rts				rts
.b2a6						_SALengthError:
.b2a6		a9 09		lda #$09		lda	#9
.b2a8		4c 69 99	jmp $9969		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/stringalloc.asm

.b2ab						StringSystemInitialise:
.b2ab		a9 ff		lda #$ff			lda 	#((EndVariableSpace-1) & $FF)
.b2ad		8d 0a 04	sta $040a			sta 	0+stringMemory
.b2b0		a9 1f		lda #$1f			lda 	#((EndVariableSpace-1) >> 8)
.b2b2		8d 0b 04	sta $040b			sta 	1+stringMemory
.b2b5		9c ff 1f	stz $1fff			stz 	EndVariableSpace-1 			; put a zero at the end, so know end of string memory.
.b2b8		60		rts				rts
.b2b9						StringSpaceInitialise:
.b2b9		20 a9 a4	jsr $a4a9			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.b2bc		a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.b2be		8d 0c 04	sta $040c			sta 	stringInitialised
.b2c1		ad 0a 04	lda $040a			lda 	stringMemory 				; allocate 256 bytes for one concreted string
.b2c4		8d 0d 04	sta $040d			sta 	stringTempPointer 			; so temporary string space is allocated below that.
.b2c7		ad 0b 04	lda $040b			lda 	stringMemory+1
.b2ca		3a		dec a				dec 	a
.b2cb		8d 0e 04	sta $040e			sta 	stringTempPointer+1
.b2ce		60		rts				rts
.b2cf						StringTempAllocate:
.b2cf		c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.b2d1		b0 30		bcs $b303			bcs 	_STALength
.b2d3		2c 0c 04	bit $040c			bit 	stringInitialised 			; already initialised
.b2d6		30 05		bmi $b2dd			bmi 	_STAAllocate
.b2d8		48		pha				pha 								; save value to subtract.
.b2d9		20 b9 b2	jsr $b2b9			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.b2dc		68		pla				pla 								; restore it
.b2dd						_STAAllocate:
.b2dd		49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.b2df		18		clc				clc  								; deliberate allows one more
.b2e0		6d 0d 04	adc $040d			adc 	stringTempPointer 			; subtract from temp pointer
.b2e3		8d 0d 04	sta $040d			sta 	stringTempPointer
.b2e6		95 58		sta $58,x			sta 	NSMantissa0,x 				; address in mantissa
.b2e8		85 3c		sta $3c				sta 	zsTemp 						; and zsTemp
.b2ea		ad 0e 04	lda $040e			lda 	stringTempPointer+1
.b2ed		69 ff		adc #$ff			adc 	#$FF
.b2ef		8d 0e 04	sta $040e			sta 	stringTempPointer+1
.b2f2		85 3d		sta $3d				sta 	zsTemp+1
.b2f4		95 60		sta $60,x			sta 	NSMantissa1,x
.b2f6		74 68		stz $68,x			stz 	NSMantissa2,x 				; set the typing data and the upper address bytes.
.b2f8		74 70		stz $70,x			stz 	NSMantissa3,x
.b2fa		a9 10		lda #$10			lda 	#NSTString
.b2fc		95 50		sta $50,x			sta 	NSStatus,x
.b2fe		a9 00		lda #$00			lda 	#0 							; clear the target string
.b300		92 3c		sta ($3c)			sta 	(zsTemp)
.b302		60		rts				rts
.b303						_STALength:
.b303		a9 09		lda #$09		lda	#9
.b305		4c 69 99	jmp $9969		jmp	ErrorHandler
.b308						StringTempWrite:
.b308		48		pha				pha
.b309		92 3c		sta ($3c)			sta 	(zsTemp) 					; write byte
.b30b		e6 3c		inc $3c				inc 	zsTemp 						; bump pointer
.b30d		d0 02		bne $b311			bne 	_STWNoCarry
.b30f		e6 3d		inc $3d				inc 	zsTemp+1
.b311						_STWNoCarry:
.b311		a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.b313		92 3c		sta ($3c)			sta 	(zsTemp)
.b315		68		pla				pla
.b316		60		rts				rts

;******  Return to file: _basic.asm

.b317						StartModuleCode:

;******  Processing file: ../modules/_build/_hardware.module

=1						hardwareIntegrated=1
=0						CONBlack = 0
=1						CONGrey = 1
=2						CONDarkBlue = 2
=3						CONGreen = 3
=4						CONPurple = 4
=5						CONBrown = 5
=6						CONOrange = 6
=7						CONCyan = 7
=8						CONDarkGrey = 8
=9						CONLightGrey = 9
=10						CONLightBlue = 10
=11						CONLightGreen = 11
=12						CONPink = 12
=13						CONRed = 13
=14						CONYellow = 14
=15						CONWhite = 15
=9						CONForeground = CONLightGrey
=2						CONBackground = CONDarkBlue
=9						CLICommandLine = CONLightGrey
=5						CLIFComment = CONBrown
=14						CLIBComment = CONYellow
=13						CLILineNumber = CONRed
=6						CLIToken = CONOrange
=7						CLIConstant = CONCyan
=14						CLIIdentifier = CONYellow
=12						CLIPunctuation = CONPink
=15						CLIData = CONWhite
.c000	a000					Export_EXTPrintNoControl:
.c000	a000	48		pha				pha
.c001	a001	da		phx				phx
.c002	a002	5a		phy				phy
.c003	a003	a6 01		ldx $01				ldx 	1
.c005	a005	da		phx				phx
.c006	a006	ac b5 07	ldy $07b5			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.c009	a009	80 11		bra $a01c			bra 	PrintCharacterOnly
.c00b	a00b					Export_EXTPrintCharacter:
.c00b	a00b					PAGEDPrintCharacter:
.c00b	a00b	48		pha				pha
.c00c	a00c	da		phx				phx
.c00d	a00d	5a		phy				phy
.c00e	a00e	a6 01		ldx $01				ldx 	1
.c010	a010	da		phx				phx
.c011	a011	ac b5 07	ldy $07b5			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.c014	a014	09 00		ora #$00			ora 	#$00 						; check $80-$FF
.c016	a016	30 48		bmi $a060			bmi 	EXPCColour
.c018	a018	c9 20		cmp #$20			cmp 	#$20 						; check $00-$1F
.c01a	a01a	90 4d		bcc $a069			bcc 	EXPCControl
.c01c	a01c					PrintCharacterOnly:
.c01c	a01c	a2 02		ldx #$02			ldx 	#2 							; select char memory
.c01e	a01e	86 01		stx $01				stx 	1
.c020	a020	91 40		sta ($40),y			sta 	(EXTAddress),y
.c022	a022	e6 01		inc $01				inc 	1 							; select colour memory
.c024	a024	ad b6 07	lda $07b6			lda 	EXTTextColour
.c027	a027	91 40		sta ($40),y			sta 	(EXTAddress),y
.c029	a029	c8		iny				iny 								; advance horizontal position
.c02a	a02a	8c b5 07	sty $07b5			sty 	EXTColumn
.c02d	a02d	cc b7 07	cpy $07b7			cpy 	EXTScreenWidth 				; reached RHS ?
.c030	a030	90 63		bcc $a095			bcc 	EXPCExit 					; no, then exit.
.c032	a032					EXPCCRLF:
.c032	a032	ee b4 07	inc $07b4			inc 	EXTRow  					; bump row
.c035	a035	9c b5 07	stz $07b5			stz 	EXTColumn 					; back to column 0
.c038	a038	ad b4 07	lda $07b4			lda 	EXTRow 						; check if reached the bottom ?
.c03b	a03b	cd b8 07	cmp $07b8			cmp 	EXTScreenHeight 			; if so, then scroll.
.c03e	a03e	f0 18		beq $a058			beq 	EXPCScroll
.c040	a040	18		clc				clc 								; add width to address.
.c041	a041	a5 40		lda $40				lda 	EXTAddress
.c043	a043	6d b7 07	adc $07b7			adc 	EXTScreenWidth
.c046	a046	85 40		sta $40				sta 	EXTAddress
.c048	a048	90 4b		bcc $a095			bcc 	EXPCExit
.c04a	a04a	e6 41		inc $41				inc 	EXTAddress+1
.c04c	a04c	80 47		bra $a095			bra 	EXPCExit
.c04e	a04e					EXPCLeft:
.c04e	a04e	ce b5 07	dec $07b5			dec 	EXTColumn
.c051	a051	10 42		bpl $a095			bpl 	EXPCExit
.c053	a053					EXPCBegin:
.c053	a053	9c b5 07	stz $07b5			stz 	EXTColumn
.c056	a056	80 3d		bra $a095			bra 	EXPCExit
.c058	a058					EXPCScroll:
.c058	a058	ce b4 07	dec $07b4			dec 	EXTRow 						; the height-1 th line.
.c05b	a05b	20 46 a1	jsr $a146			jsr 	EXTScreenScroll 			; scroll the screen
.c05e	a05e	80 35		bra $a095			bra 	EXPCExit
.c060	a060					EXPCColour:
.c060	a060	c9 a0		cmp #$a0			cmp 	#$A0						; 80-9F set foreground/background
.c062	a062	b0 31		bcs $a095			bcs 	EXPCExit
.c064	a064	20 26 a1	jsr $a126			jsr 	EXPCHandleColour
.c067	a067	80 2c		bra $a095			bra 	EXPCExit
.c069	a069					EXPCControl:
.c069	a069	c9 11		cmp #$11			cmp 	#$11 						; only handle 00-10.
.c06b	a06b	b0 28		bcs $a095			bcs 	EXPCExit
.c06d	a06d	0a		asl a				asl 	a 							; double into X
.c06e	a06e	aa		tax				tax
.c06f	a06f	7c 04 a1	jmp ($a104,x)			jmp 	(EXPCActionTable,x) 		; and execute code.
.c072	a072					EXPCUp:
.c072	a072	ad b4 07	lda $07b4			lda 	EXTRow 						; already at top ?
.c075	a075	f0 1e		beq $a095			beq 	EXPCExit
.c077	a077	ce b4 07	dec $07b4			dec 	EXTRow 						; up one in position/address
.c07a	a07a	38		sec				sec
.c07b	a07b	a5 40		lda $40				lda 	EXTAddress
.c07d	a07d	ed b7 07	sbc $07b7			sbc 	EXTScreenWidth
.c080	a080	85 40		sta $40				sta 	EXTAddress
.c082	a082	b0 11		bcs $a095			bcs 	EXPCExit
.c084	a084	c6 41		dec $41				dec 	EXTAddress+1
.c086	a086	80 0d		bra $a095			bra 	EXPCExit
.c088	a088					EXPCRight:
.c088	a088	c8		iny				iny
.c089	a089	8c b5 07	sty $07b5			sty 	EXTColumn
.c08c	a08c	cc b7 07	cpy $07b7			cpy 	EXTScreenWidth
.c08f	a08f	d0 04		bne $a095			bne 	EXPCExit
.c091	a091	88		dey				dey
.c092	a092					EXPCSetColumnY:
.c092	a092	8c b5 07	sty $07b5			sty 	EXTColumn
.c095	a095					EXPCExit:
.c095	a095	20 bb a1	jsr $a1bb			jsr 	EXTSetHardwareCursor 		; place the physical cursor.
.c098	a098	68		pla				pla
.c099	a099	85 01		sta $01				sta 	1
.c09b	a09b	7a		ply				ply
.c09c	a09c	fa		plx				plx
.c09d	a09d	68		pla				pla
.c09e	a09e	60		rts				rts
.c09f	a09f					EXPCClearScreen:
.c09f	a09f	20 78 a1	jsr $a178			jsr		EXTClearScreenCode
.c0a2	a0a2	80 f1		bra $a095			bra 	EXPCExit
.c0a4	a0a4					EXPCDown:
.c0a4	a0a4	ad b8 07	lda $07b8			lda 	EXTScreenHeight 			; at the bottom
.c0a7	a0a7	3a		dec a				dec 	a
.c0a8	a0a8	cd b4 07	cmp $07b4			cmp 	EXTRow
.c0ab	a0ab	f0 e8		beq $a095			beq 	EXPCExit
.c0ad	a0ad	ee b4 07	inc $07b4			inc 	EXTRow 						; down one in position/address
.c0b0	a0b0	18		clc				clc
.c0b1	a0b1	a5 40		lda $40				lda 	EXTAddress
.c0b3	a0b3	6d b7 07	adc $07b7			adc 	EXTScreenWidth
.c0b6	a0b6	85 40		sta $40				sta 	EXTAddress
.c0b8	a0b8	90 db		bcc $a095			bcc 	EXPCExit
.c0ba	a0ba	e6 41		inc $41				inc 	EXTAddress+1
.c0bc	a0bc	80 d7		bra $a095			bra 	EXPCExit
.c0be	a0be					EXPCTab:
.c0be	a0be	ad b5 07	lda $07b5			lda 	EXTColumn 					; next tab stop
.c0c1	a0c1	29 f8		and #$f8			and 	#$F8
.c0c3	a0c3	18		clc				clc
.c0c4	a0c4	69 08		adc #$08			adc 	#8
.c0c6	a0c6	8d b5 07	sta $07b5			sta 	EXTColumn
.c0c9	a0c9	cd b7 07	cmp $07b7			cmp 	EXTScreenWidth 				; too far, stick end of line.
.c0cc	a0cc	90 c7		bcc $a095			bcc 	EXPCExit
.c0ce	a0ce	80 10		bra $a0e0			bra 	EXPCEnd
.c0d0	a0d0					EXPCBackSpace:
.c0d0	a0d0	88		dey				dey
.c0d1	a0d1	30 c2		bmi $a095			bmi 	EXPCExit
.c0d3	a0d3	ce b5 07	dec $07b5			dec 	EXTColumn
.c0d6	a0d6	a9 02		lda #$02			lda 	#2
.c0d8	a0d8	85 01		sta $01				sta 	1
.c0da	a0da	a9 20		lda #$20			lda 	#32
.c0dc	a0dc	91 40		sta ($40),y			sta 	(EXTAddress),y
.c0de	a0de	80 b5		bra $a095			bra 	EXPCExit
.c0e0	a0e0					EXPCEnd:
.c0e0	a0e0	a9 02		lda #$02			lda 	#2 							; access text screen
.c0e2	a0e2	85 01		sta $01				sta 	1
.c0e4	a0e4	ac b7 07	ldy $07b7			ldy 	EXTScreenWidth 				; point to last character
.c0e7	a0e7	88		dey				dey
.c0e8	a0e8					EXPCEndSearch:
.c0e8	a0e8	88		dey				dey 								; if past start, move to col 0.
.c0e9	a0e9	30 06		bmi $a0f1			bmi 	EXPCFound
.c0eb	a0eb	b1 40		lda ($40),y			lda 	(EXTAddress),y 				; keep going back till non space found
.c0ed	a0ed	c9 20		cmp #$20			cmp 	#' '
.c0ef	a0ef	f0 f7		beq $a0e8			beq 	EXPCEndSearch
.c0f1	a0f1					EXPCFound:
.c0f1	a0f1	c8		iny				iny 								; move to following cell.
.c0f2	a0f2	80 9e		bra $a092			bra 	EXPCSetColumnY
.c0f4	a0f4					EXPCClearEOL:
.c0f4	a0f4	a9 02		lda #$02			lda 	#2 							; access character RAM
.c0f6	a0f6	85 01		sta $01				sta 	1
.c0f8	a0f8	a9 20		lda #$20			lda 	#' ' 						; write space
.c0fa	a0fa	91 40		sta ($40),y			sta 	(EXTAddress),y
.c0fc	a0fc	c8		iny				iny
.c0fd	a0fd	cc b7 07	cpy $07b7			cpy 	EXTScreenWidth 				; until RHS of screen.
.c100	a100	90 f2		bcc $a0f4			bcc 	EXPCClearEOL
.c102	a102	80 91		bra $a095			bra 	EXPCExit
.c104	a104					EXPCActionTable:
>c104	a104	95 a0						.word 	EXPCExit 					; 00
>c106	a106	53 a0						.word 	EXPCBegin 					; 01 A Start of Line
>c108	a108	4e a0						.word 	EXPCLeft 					; 02 B Left
>c10a	a10a	95 a0						.word 	EXPCExit 					; 03 <Break>
>c10c	a10c	95 a0						.word 	EXPCExit 					; 04
>c10e	a10e	e0 a0						.word 	EXPCEnd 					; 05 E End of Line
>c110	a110	88 a0						.word 	EXPCRight 					; 06 F Right
>c112	a112	95 a0						.word 	EXPCExit 					; 07
>c114	a114	d0 a0						.word 	EXPCBackSpace 				; 08 H Backspace
>c116	a116	be a0						.word 	EXPCTab 					; 09 I Tab
>c118	a118	95 a0						.word 	EXPCExit 					; 0A
>c11a	a11a	f4 a0						.word 	EXPCClearEOL 				; 0B K Clear to EOL
>c11c	a11c	9f a0						.word 	EXPCClearScreen			; 0C L CLS
>c11e	a11e	32 a0						.word 	EXPCCRLF 					; 0D M CR/LF
>c120	a120	a4 a0						.word 	EXPCDown 					; 0E N Down
>c122	a122	95 a0						.word 	EXPCExit 					; 0F
>c124	a124	72 a0						.word 	EXPCUp 					; 10 P Up
.c126	a126					EXPCHandleColour:
.c126	a126	c9 90		cmp #$90			cmp 	#$90 						; 8x foreground 9x background
.c128	a128	b0 16		bcs $a140			bcs 	EXPCBackground
.c12a	a12a	0a		asl a				asl 	a 							; shift it 4 bits to the right.
.c12b	a12b	0a		asl a				asl 	a
.c12c	a12c	0a		asl a				asl 	a
.c12d	a12d	0a		asl a				asl 	a
.c12e	a12e	a2 0f		ldx #$0f			ldx 	#$0F 						; Mask in X
.c130	a130					EXPCUpdate:
.c130	a130	48		pha				pha 								; save new colour
.c131	a131	8a		txa				txa 								; get mask
.c132	a132	2d b6 07	and $07b6			and 	EXTTextColour 				; mask out old.
.c135	a135	8d b6 07	sta $07b6			sta 	EXTTextColour
.c138	a138	68		pla				pla 								; or in new colour
.c139	a139	0d b6 07	ora $07b6			ora 	EXTTextColour
.c13c	a13c	8d b6 07	sta $07b6			sta 	EXTTextColour
.c13f	a13f	60		rts				rts
.c140	a140					EXPCBackground:
.c140	a140	29 0f		and #$0f			and 	#$0F 						; get the colour
.c142	a142	a2 f0		ldx #$f0			ldx 	#$F0 						; mask
.c144	a144	80 ea		bra $a130			bra 	EXPCUpdate
.c146	a146					EXTScreenScroll:
.c146	a146	a9 02		lda #$02			lda 	#2 							; select text page
.c148	a148	85 01		sta $01				sta 	1
.c14a	a14a	a9 20		lda #$20			lda		#32 						; fill with space
.c14c	a14c	20 a2 a2	jsr $a2a2			jsr 	EXTScrollFill
.c14f	a14f	e6 01		inc $01				inc 	1 							; select colour page
.c151	a151	ad b6 07	lda $07b6			lda 	EXTTextColour
.c154	a154	20 a2 a2	jsr $a2a2			jsr 	EXTScrollFill
.c157	a157	60		rts				rts
.c158	a158					PAGEDPrintHex:
.c158	a158	48		pha				pha
.c159	a159	a9 20		lda #$20			lda 	#' '
.c15b	a15b	20 0b a0	jsr $a00b			jsr 	PAGEDPrintCharacter
.c15e	a15e	68		pla				pla
.c15f	a15f	48		pha				pha
.c160	a160	4a		lsr a				lsr 	a
.c161	a161	4a		lsr a				lsr 	a
.c162	a162	4a		lsr a				lsr 	a
.c163	a163	4a		lsr a				lsr 	a
.c164	a164	20 68 a1	jsr $a168			jsr 	_PPHNibble
.c167	a167	68		pla				pla
.c168	a168					_PPHNibble:
.c168	a168	48		pha				pha
.c169	a169	29 0f		and #$0f			and 	#15
.c16b	a16b	c9 0a		cmp #$0a			cmp 	#10
.c16d	a16d	90 02		bcc $a171			bcc 	_PPHOut
.c16f	a16f	69 06		adc #$06			adc 	#6
.c171	a171	69 30		adc #$30	_PPHOut:adc 	#48
.c173	a173	20 0b a0	jsr $a00b			jsr		PAGEDPrintCharacter
.c176	a176	68		pla				pla
.c177	a177	60		rts				rts
.c178	a178					EXTClearScreenCode:
.c178	a178	a9 02		lda #$02			lda 	#2 							; select text page
.c17a	a17a	85 01		sta $01				sta 	1
.c17c	a17c	a9 20		lda #$20			lda		#32 						; fill with space
.c17e	a17e	20 8b a1	jsr $a18b			jsr 	_EXTCSFill
.c181	a181	e6 01		inc $01				inc 	1 							; select colour page
.c183	a183	ad b6 07	lda $07b6			lda 	EXTTextColour
.c186	a186	20 8b a1	jsr $a18b			jsr 	_EXTCSFill
.c189	a189	80 22		bra $a1ad			bra 	EXTHomeCursor
.c18b	a18b					_EXTCSFill:
.c18b	a18b	aa		tax				tax
.c18c	a18c	a9 00		lda #$00			lda 	#EXTMemory & $FF
.c18e	a18e	85 40		sta $40				sta 	EXTAddress
.c190	a190	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.c192	a192	85 41		sta $41				sta 	EXTAddress+1
.c194	a194					_EXTCSFill1:
.c194	a194	a0 00		ldy #$00			ldy 	#0
.c196	a196	8a		txa				txa
.c197	a197					_EXTCSFill2:
.c197	a197	91 40		sta ($40),y			sta 	(EXTAddress),y
.c199	a199	c8		iny				iny
.c19a	a19a	d0 fb		bne $a197			bne 	_EXTCSFill2
.c19c	a19c	e6 41		inc $41				inc 	EXTAddress+1
.c19e	a19e	a5 41		lda $41				lda 	EXTAddress+1
.c1a0	a1a0	c9 d2		cmp #$d2			cmp 	#$D2
.c1a2	a1a2	d0 f0		bne $a194			bne 	_EXTCSFill1
.c1a4	a1a4	8a		txa				txa
.c1a5	a1a5					_EXTCSFill3:
.c1a5	a1a5	91 40		sta ($40),y			sta 	(EXTAddress),y
.c1a7	a1a7	c8		iny				iny
.c1a8	a1a8	c0 c0		cpy #$c0			cpy 	#$C0
.c1aa	a1aa	d0 f9		bne $a1a5			bne 	_EXTCSFill3
.c1ac	a1ac	60		rts				rts
.c1ad	a1ad					EXTHomeCursor:
.c1ad	a1ad	9c b4 07	stz $07b4			stz 	EXTRow 						; reset row & column
.c1b0	a1b0	9c b5 07	stz $07b5			stz 	EXTColumn
.c1b3	a1b3	a9 00		lda #$00			lda 	#EXTMemory & $FF 			; set address
.c1b5	a1b5	85 40		sta $40				sta 	EXTAddress
.c1b7	a1b7	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.c1b9	a1b9	85 41		sta $41				sta 	EXTAddress+1
.c1bb	a1bb					EXTSetHardwareCursor:
.c1bb	a1bb	64 01		stz $01				stz 	1 							; I/O Page zero
.c1bd	a1bd	a9 05		lda #$05			lda 	#1+4 						; enable cursor
.c1bf	a1bf	8d 10 d0	sta $d010			sta 	$D010
.c1c2	a1c2	a9 d6		lda #$d6			lda 	#214
.c1c4	a1c4	8d 12 d0	sta $d012			sta 	$D012
.c1c7	a1c7	ad b5 07	lda $07b5			lda 	EXTColumn
.c1ca	a1ca	8d 14 d0	sta $d014			sta 	$D014 						; set cursor position
.c1cd	a1cd	9c 15 d0	stz $d015			stz 	$D015
.c1d0	a1d0	ad b4 07	lda $07b4			lda 	EXTRow
.c1d3	a1d3	8d 16 d0	sta $d016			sta 	$D016
.c1d6	a1d6	9c 17 d0	stz $d017			stz 	$D017
.c1d9	a1d9	60		rts				rts
=$c000						EXTMemory = $C000
=$02						EXTTextPage = $02
=$03						EXTColourPage = $03
=1						EXTDummySpace = 1 							; fake-space for CR character.
=0						EXTCBlack = 0
.07b4						EXTRow:
>07b4								.fill 	1
.07b5						EXTColumn:
>07b5								.fill 	1
.07b6						EXTTextColour:
>07b6								.fill 	1
.07b7						EXTScreenWidth:
>07b7								.fill 	1
.07b8						EXTScreenHeight:
>07b8								.fill 	1
.0040						EXTAddress:
>0040								.fill 	2
.c1da	a1da					Export_EXTInitialise:
.c1da	a1da	64 01		stz $01				stz 	1 							; Access I/O page 0
.c1dc	a1dc	9c 04 d0	stz $d004			stz 	$D004 						; Disable border
.c1df	a1df	9c 08 d0	stz $d008			stz 	$D008
.c1e2	a1e2	9c 09 d0	stz $d009			stz 	$D009
.c1e5	a1e5	a9 09		lda #$09			lda 	#1+8						; Timer On at 70Hz counting up.
.c1e7	a1e7	8d 58 d6	sta $d658			sta 	$D658
.c1ea	a1ea	a9 52		lda #$52			lda 	#$52
.c1ec	a1ec	8d b6 07	sta $07b6			sta 	EXTTextColour
.c1ef	a1ef	a9 50		lda #$50			lda 	#80 						; set screen dimensions.
.c1f1	a1f1	8d b7 07	sta $07b7			sta 	EXTScreenWidth
.c1f4	a1f4	a9 3c		lda #$3c			lda 	#60
.c1f6	a1f6	8d b8 07	sta $07b8			sta 	EXTScreenHeight
.c1f9	a1f9	20 78 a1	jsr $a178			jsr 	EXTClearScreenCode 			; clear the screen
.c1fc	a1fc					_EXMoveDown:
.c1fc	a1fc	a9 0d		lda #$0d			lda 	#13
.c1fe	a1fe	20 0b a0	jsr $a00b			jsr 	PAGEDPrintCharacter
.c201	a201	ad b4 07	lda $07b4			lda 	EXTRow
.c204	a204	c9 0a		cmp #$0a			cmp 	#Header_Height-4
.c206	a206	d0 f4		bne $a1fc			bne 	_EXMoveDown
.c208	a208	20 0e a2	jsr $a20e			jsr 	EXTShowHeader
.c20b	a20b	64 01		stz $01				stz 	1
.c20d	a20d	60		rts				rts
.c20e	a20e					EXTShowHeader:
.c20e	a20e	a5 01		lda $01				lda 	1
.c210	a210	48		pha				pha
.c211	a211	a5 0b		lda $0b				lda 	8+3
.c213	a213	48		pha				pha
.c214	a214	a5 0c		lda $0c				lda 	8+4
.c216	a216	18		clc				clc
.c217	a217	69 03		adc #$03			adc 	#3
.c219	a219	85 0b		sta $0b				sta 	8+3
.c21b	a21b	a2 98		ldx #$98			ldx 	#(Header_jchars & $FF)
.c21d	a21d	a0 61		ldy #$61			ldy 	#(Header_jchars >> 8)-$40
.c21f	a21f	64 01		stz $01				stz 	1
.c221	a221	ad a7 d6	lda $d6a7			lda 	$D6A7
.c224	a224	29 10		and #$10			and 	#$10
.c226	a226	f0 04		beq $a22c			beq 	_EXTSHNotK1
.c228	a228	a2 b0		ldx #$b0			ldx 	#(Header_kchars & $FF)
.c22a	a22a	a0 65		ldy #$65			ldy 	#(Header_kchars >> 8)-$40
.c22c	a22c					_EXTSHNotK1:
.c22c	a22c	a9 02		lda #$02			lda 	#2
.c22e	a22e	20 5c a2	jsr $a25c			jsr 	_ESHCopyBlock
.c231	a231	a2 00		ldx #$00			ldx 	#(Header_jattrs & $FF)
.c233	a233	a0 60		ldy #$60			ldy 	#(Header_jattrs >> 8)-$40
.c235	a235	64 01		stz $01				stz 	1
.c237	a237	ad a7 d6	lda $d6a7			lda 	$D6A7
.c23a	a23a	29 10		and #$10			and 	#$10
.c23c	a23c	f0 04		beq $a242			beq 	_EXTSHNotK2
.c23e	a23e	a2 c8		ldx #$c8			ldx 	#(Header_kattrs & $FF)
.c240	a240	a0 63		ldy #$63			ldy 	#(Header_kattrs >> 8)-$40
.c242	a242					_EXTSHNotK2:
.c242	a242	a9 03		lda #$03			lda 	#3
.c244	a244	20 5c a2	jsr $a25c			jsr 	_ESHCopyBlock
.c247	a247	64 01		stz $01				stz 	1
.c249	a249	a2 3f		ldx #$3f			ldx 	#16*4-1
.c24b	a24b					_EXTCopyLUT:
.c24b	a24b	bd b2 67	lda $67b2,x			lda 	Header_Palette-$4000,x
.c24e	a24e	9d 00 d8	sta $d800,x			sta 	$D800,x
.c251	a251	9d 40 d8	sta $d840,x			sta 	$D840,x
.c254	a254	ca		dex				dex
.c255	a255	10 f4		bpl $a24b			bpl 	_EXTCopyLUT
.c257	a257	68		pla				pla
.c258	a258	85 0b		sta $0b				sta 	8+3
.c25a	a25a	68		pla				pla
.c25b	a25b	60		rts				rts
.c25c	a25c					_ESHCopyBlock:
.c25c	a25c	85 01		sta $01				sta 	1
.c25e	a25e	86 36		stx $36				stx 	zTemp0 						; zTemp0 is RLE packed data
.c260	a260	84 37		sty $37				sty 	zTemp0+1
.c262	a262	a9 00		lda #$00			lda 	#(($C000) & $FF)
.c264	a264	85 38		sta $38				sta 	0+zTemp1
.c266	a266	a9 c0		lda #$c0			lda 	#(($C000) >> 8)
.c268	a268	85 39		sta $39				sta 	1+zTemp1
.c26a	a26a					_ESHCopyLoop:
.c26a	a26a	b2 36		lda ($36)			lda 	(zTemp0) 					; get next character
.c26c	a26c	c9 ff		cmp #$ff			cmp 	#Header_RLE 				; packed ?
.c26e	a26e	f0 1b		beq $a28b			beq 	_ESHUnpack
.c270	a270	92 38		sta ($38)			sta 	(zTemp1) 					; copy it out.
.c272	a272	a9 01		lda #$01			lda 	#1 							; source add 1
.c274	a274	a0 01		ldy #$01			ldy 	#1 							; dest add 1
.c276	a276					_ESHNext:
.c276	a276	18		clc				clc 								; zTemp0 + A
.c277	a277	65 36		adc $36				adc 	zTemp0
.c279	a279	85 36		sta $36				sta 	zTemp0
.c27b	a27b	90 02		bcc $a27f			bcc 	_ESHNoCarry
.c27d	a27d	e6 37		inc $37				inc 	zTemp0+1
.c27f	a27f					_ESHNoCarry:
.c27f	a27f	98		tya				tya 								; zTemp1 + Y
.c280	a280	18		clc				clc
.c281	a281	65 38		adc $38				adc 	zTemp1
.c283	a283	85 38		sta $38				sta 	zTemp1
.c285	a285	90 e3		bcc $a26a			bcc 	_ESHCopyLoop
.c287	a287	e6 39		inc $39				inc 	zTemp1+1
.c289	a289	80 df		bra $a26a			bra 	_ESHCopyLoop
.c28b	a28b					_ESHUnpack:
.c28b	a28b	a0 02		ldy #$02			ldy 	#2 							; get count into X
.c28d	a28d	b1 36		lda ($36),y			lda 	(zTemp0),y
.c28f	a28f	aa		tax				tax
.c290	a290	88		dey				dey 								; byte into A
.c291	a291	b1 36		lda ($36),y			lda 	(zTemp0),y
.c293	a293	f0 0c		beq $a2a1			beq 	_ESHExit 					; exit if zero.
.c295	a295	a0 00		ldy #$00			ldy 	#0 							; copy start position
.c297	a297					_ESHCopyOut:
.c297	a297	91 38		sta ($38),y			sta 	(zTemp1),y
.c299	a299	c8		iny				iny
.c29a	a29a	ca		dex				dex
.c29b	a29b	d0 fa		bne $a297			bne 	_ESHCopyOut
.c29d	a29d	a9 03		lda #$03			lda 	#3 							; Y is bytes on screen, 3 bytes from source
.c29f	a29f	80 d5		bra $a276			bra 	_ESHNext
.c2a1	a2a1					_ESHExit:
.c2a1	a2a1	60		rts				rts
.c2a2	a2a2					EXTScrollFill:
.c2a2	a2a2	aa		tax				tax									; save value to fill with
.c2a3	a2a3	a5 36		lda $36				lda 	zTemp0 						; save zTemp0 (dest) zTemp1 (src)
.c2a5	a2a5	48		pha				pha
.c2a6	a2a6	a5 37		lda $37				lda 	zTemp0+1
.c2a8	a2a8	48		pha				pha
.c2a9	a2a9	a5 38		lda $38				lda 	zTemp1
.c2ab	a2ab	48		pha				pha
.c2ac	a2ac	a5 39		lda $39				lda 	zTemp1+1
.c2ae	a2ae	48		pha				pha
.c2af	a2af	a9 c0		lda #$c0			lda 	#$C0 						; copy from C000+length to C000
.c2b1	a2b1	85 37		sta $37				sta 	zTemp0+1
.c2b3	a2b3	85 39		sta $39				sta 	zTemp1+1
.c2b5	a2b5	64 36		stz $36				stz 	zTemp0
.c2b7	a2b7	ad b7 07	lda $07b7			lda 	EXTScreenWidth
.c2ba	a2ba	85 38		sta $38				sta 	zTemp1
.c2bc	a2bc	a0 00		ldy #$00			ldy 	#0
.c2be	a2be					_EXSFCopy1:
.c2be	a2be	b1 38		lda ($38),y			lda 	(zTemp1),y
.c2c0	a2c0	91 36		sta ($36),y			sta 	(zTemp0),y
.c2c2	a2c2	c8		iny				iny
.c2c3	a2c3	d0 f9		bne $a2be			bne 	_EXSFCopy1
.c2c5	a2c5	e6 37		inc $37				inc 	zTemp0+1 					; next page
.c2c7	a2c7	e6 39		inc $39				inc 	zTemp1+1
.c2c9	a2c9	a5 39		lda $39				lda 	zTemp1+1
.c2cb	a2cb	c9 d3		cmp #$d3			cmp 	#$D3
.c2cd	a2cd	d0 ef		bne $a2be			bne 	_EXSFCopy1
.c2cf	a2cf	ac b7 07	ldy $07b7			ldy 	EXTScreenWidth 				; blank the bottom line.
.c2d2	a2d2	8a		txa				txa
.c2d3	a2d3					_EXSFFill1:
.c2d3	a2d3	88		dey				dey
.c2d4	a2d4	91 40		sta ($40),y			sta 	(EXTAddress),y
.c2d6	a2d6	c0 00		cpy #$00			cpy 	#0
.c2d8	a2d8	10 f9		bpl $a2d3			bpl 	_EXSFFill1
.c2da	a2da	68		pla				pla
.c2db	a2db	85 39		sta $39				sta 	zTemp1+1
.c2dd	a2dd	68		pla				pla
.c2de	a2de	85 38		sta $38				sta 	zTemp1
.c2e0	a2e0	68		pla				pla
.c2e1	a2e1	85 37		sta $37				sta 	zTemp0+1
.c2e3	a2e3	68		pla				pla
.c2e4	a2e4	85 36		sta $36				sta 	zTemp0
.c2e6	a2e6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_graphics.module

=1						graphicsIntegrated=1
=0						GCMD_Initialise = 0*2
=2						GCMD_BitmapCtl = 1*2
=4						GCMD_SpriteCtl = 2*2
=6						GCMD_Clear = 3*2
=8						GCMD_Colour = 4*2
=10						GCMD_DrawFont = 5*2
=12						GCMD_DrawSprite = 6*2
=14						GCMD_SpriteUse = 7*2
=16						GCMD_SpriteImage = 8*2
=18						GCMD_SpriteCollide = 9*2
=64						GCMD_Move = 32*2
=66						GCMD_Line = 33*2
=68						GCMD_FrameRect = 34*2
=70						GCMD_FillRect = 35*2
=72						GCMD_FrameCircle = 36*2
=74						GCMD_FillCircle = 37*2
=80						GCMD_Plot = 40*2
=82						GCMD_SpriteMove = 41*2
=42						GRFirstFreeCode = 42
.c2e7	a2e7					GRVectorTable:
>c2e7	a2e7	36 a5					.word	GXInitialise             ; $00 Initialise
>c2e9	a2e9	50 a5					.word	GXControlBitmap          ; $01 BitmapCtl
>c2eb	a2eb	98 a5					.word	GXControlSprite          ; $02 SpriteCtl
>c2ed	a2ed	e8 a4					.word	GXClearBitmap            ; $03 Clear
>c2ef	a2ef	27 a7					.word	GXSetColourMode          ; $04 Colour
>c2f1	a2f1	ef a8					.word	GXFontHandler            ; $05 DrawFont
>c2f3	a2f3	37 a9					.word	GXSpriteHandler          ; $06 DrawSprite
>c2f5	a2f5	a8 a9					.word	GXSelect                 ; $07 SpriteUse
>c2f7	a2f7	d1 a9					.word	GXSelectImage            ; $08 SpriteImage
>c2f9	a2f9	58 ab					.word	GXCollide                ; $09 SpriteCollide
>c2fb	a2fb	9a a3					.word	GRUndefined              ; $0a
>c2fd	a2fd	9a a3					.word	GRUndefined              ; $0b
>c2ff	a2ff	9a a3					.word	GRUndefined              ; $0c
>c301	a301	9a a3					.word	GRUndefined              ; $0d
>c303	a303	9a a3					.word	GRUndefined              ; $0e
>c305	a305	9a a3					.word	GRUndefined              ; $0f
>c307	a307	9a a3					.word	GRUndefined              ; $10
>c309	a309	9a a3					.word	GRUndefined              ; $11
>c30b	a30b	9a a3					.word	GRUndefined              ; $12
>c30d	a30d	9a a3					.word	GRUndefined              ; $13
>c30f	a30f	9a a3					.word	GRUndefined              ; $14
>c311	a311	9a a3					.word	GRUndefined              ; $15
>c313	a313	9a a3					.word	GRUndefined              ; $16
>c315	a315	9a a3					.word	GRUndefined              ; $17
>c317	a317	9a a3					.word	GRUndefined              ; $18
>c319	a319	9a a3					.word	GRUndefined              ; $19
>c31b	a31b	9a a3					.word	GRUndefined              ; $1a
>c31d	a31d	9a a3					.word	GRUndefined              ; $1b
>c31f	a31f	9a a3					.word	GRUndefined              ; $1c
>c321	a321	9a a3					.word	GRUndefined              ; $1d
>c323	a323	9a a3					.word	GRUndefined              ; $1e
>c325	a325	9a a3					.word	GRUndefined              ; $1f
>c327	a327	98 a3					.word	GXMove                   ; $20 Move
>c329	a329	f5 a5					.word	GXLine                   ; $21 Line
>c32b	a32b	70 a7					.word	GXFrameRectangle         ; $22 FrameRect
>c32d	a32d	6d a7					.word	GXFillRectangle          ; $23 FillRect
>c32f	a32f	9f a3					.word	GXFrameCircle            ; $24 FrameCircle
>c331	a331	9b a3					.word	GXFillCircle             ; $25 FillCircle
>c333	a333	9a a3					.word	GRUndefined              ; $26
>c335	a335	9a a3					.word	GRUndefined              ; $27
>c337	a337	55 a7					.word	GXPlotPoint              ; $28 Plot
>c339	a339	67 aa					.word	GXMoveSprite             ; $29 SpriteMove
=3						GXMappingPage = 3
=24576						GXMappingAddress = ($2000 * GXMappingPage)
=11						GXEditSlot = 8 + GXMappingPage
=$36						gxzTemp0 = zTemp0
=$38						gxzTemp1 = zTemp1
=$3a						gxzTemp2 = zTemp2
=$3c						gxzScreen = zsTemp
=$623						gxPixelBuffer = numberBuffer
.07b9						gxCurrentX:
>07b9								.fill 	2
.07bb						gxCurrentY:
>07bb								.fill 	2
.07bd						gxLastX:
>07bd								.fill 	2
.07bf						gxLastY:
>07bf								.fill 	2
.07c1						gxX0:
>07c1								.fill 	2
.07c3						gxY0:
>07c3								.fill 	2
.07c5						gxX1:
>07c5								.fill 	2
.07c7						gxY1:
>07c7								.fill 	2
.07c9						gxSpritesOn:
>07c9								.fill 	1
.07ca						gxBitmapsOn:
>07ca								.fill 	1
.07cb						gxBasePage:
>07cb								.fill 	1
.07cc						gxSpritePage:
>07cc								.fill 	1
.07cd						gxHeight:
>07cd								.fill 	1
.07ce						gxMode:
>07ce								.fill 	1
.07cf						gxColour:
>07cf								.fill 	1
.07d0						gxEORValue:
>07d0								.fill 	1
.07d1						gxANDValue:
>07d1								.fill 	1
.07d2						gxOriginalLUTValue:
>07d2								.fill 	1
.07d3						gxOffset:
>07d3								.fill 	1
.07d4						GSCurrentSpriteID:
>07d4								.fill 	1
.07d5						GSCurrentSpriteAddr:
>07d5								.fill 	2
.07d7						gxSpriteOffsetBase:
>07d7								.fill 	2
.07d9						gxSpriteLow:
>07d9								.fill 	64
.0819						gxSpriteHigh:
>0819								.fill 	64
.c33b	a33b					Export_GXGraphicDraw:
.c33b	a33b	c9 40		cmp #$40			cmp 	#GCMD_Move					; low instructions don't use coordinates
.c33d	a33d	b0 06		bcs $a345			bcs 	_GDCoordinate
.c33f	a33f	86 36		stx $36				stx 	gxzTemp0 					; save X/Y
.c341	a341	84 37		sty $37				sty 	gxzTemp0+1
.c343	a343	80 4b		bra $a390			bra 	_GDExecuteA 				; and execute
.c345	a345					_GDCoordinate:
.c345	a345	48		pha				pha 								; save AXY
.c346	a346	da		phx				phx
.c347	a347	5a		phy				phy
.c348	a348	a2 03		ldx #$03			ldx 	#3 							; copy currentX to lastX
.c34a	a34a					_GDCopy1:
.c34a	a34a	bd b9 07	lda $07b9,x			lda 	gxCurrentX,x
.c34d	a34d	9d bd 07	sta $07bd,x			sta 	gxLastX,x
.c350	a350	ca		dex				dex
.c351	a351	10 f7		bpl $a34a			bpl 	_GDCopy1
.c353	a353	68		pla				pla 								; update Y
.c354	a354	8d bb 07	sta $07bb			sta 	gxCurrentY
.c357	a357	9c bc 07	stz $07bc			stz 	gxCurrentY+1
.c35a	a35a	68		pla				pla
.c35b	a35b	8d b9 07	sta $07b9			sta 	gxCurrentX
.c35e	a35e	68		pla				pla 								; get A (command+X.1) back
.c35f	a35f	48		pha				pha
.c360	a360	29 01		and #$01			and 	#1 							; put LSB as MSB of Current.X
.c362	a362	8d ba 07	sta $07ba			sta 	gxCurrentX+1
.c365	a365	68		pla				pla 								; get command back
.c366	a366	29 fe		and #$fe			and 	#$FE 						; lose LSB, chuck the stray X bit
.c368	a368	48		pha				pha 								; push back.
.c369	a369	c9 52		cmp #$52			cmp 	#GCMD_SpriteMove 			; move sprite does not clip.
.c36b	a36b	f0 17		beq $a384			beq 	_GDCopyToWorkArea
.c36d	a36d	ad ba 07	lda $07ba			lda 	gxCurrentX+1 				; X < 256 X okay
.c370	a370	f0 07		beq $a379			beq 	_GDCheckY
.c372	a372	ad b9 07	lda $07b9			lda 	gxCurrentX 					; otherwise X < 320 = 256 + 64
.c375	a375	c9 40		cmp #$40			cmp 	#64
.c377	a377	b0 08		bcs $a381			bcs 	_GDError1
.c379	a379					_GDCheckY:
.c379	a379	ad bb 07	lda $07bb			lda 	gxCurrentY 					; check Y < Height.
.c37c	a37c	cd cd 07	cmp $07cd			cmp 	gxHeight
.c37f	a37f	90 03		bcc $a384			bcc 	_GDCopyToWorkArea
.c381	a381					_GDError1:
.c381	a381	68		pla				pla
.c382	a382					_GDError2:
.c382	a382	38		sec				sec
.c383	a383	60		rts				rts
.c384	a384					_GDCopyToWorkArea:
.c384	a384	a2 07		ldx #$07			ldx 	#7 							; copy current and last to gxXY/12 work area
.c386	a386					_GDCopy2:
.c386	a386	bd b9 07	lda $07b9,x			lda 	gxCurrentX,x
.c389	a389	9d c1 07	sta $07c1,x			sta 	gxX0,x
.c38c	a38c	ca		dex				dex
.c38d	a38d	10 f7		bpl $a386			bpl 	_GDCopy2
.c38f	a38f	68		pla				pla 								; get command
.c390	a390					_GDExecuteA:
.c390	a390	c9 54		cmp #$54			cmp 	#GRFirstFreeCode*2 			; bad ?
.c392	a392	b0 ee		bcs $a382			bcs 	_GDError2
.c394	a394	aa		tax				tax
.c395	a395	7c e7 a2	jmp ($a2e7,x)			jmp 	(GRVectorTable,x)
.c398	a398					GXMove:
.c398	a398	18		clc				clc
.c399	a399	60		rts				rts
.c39a	a39a					GRUndefined:
>c39a	a39a	db						.byte 	$DB 						; causes a break in the emulator
.c39b	a39b					GXFillCircle:
.c39b	a39b	a9 ff		lda #$ff			lda 	#255
.c39d	a39d	80 02		bra $a3a1			bra 	GXCircle
.c39f	a39f					GXFrameCircle:
.c39f	a39f	a9 00		lda #$00			lda 	#0
.c3a1	a3a1					GXCircle:
.c3a1	a3a1	8d 5c 08	sta $085c			sta 	gxIsFillMode					; save Fill flag
.c3a4	a3a4	ad ca 07	lda $07ca			lda 	gxBitmapsOn
.c3a7	a3a7	f0 26		beq $a3cf			beq 	_GXCFail
.c3a9	a3a9	20 ff ab	jsr $abff			jsr 	GXSortXY 					; topleft/bottomright
.c3ac	a3ac	20 d7 aa	jsr $aad7			jsr 	GXOpenBitmap 				; start drawing
.c3af	a3af	20 a1 a4	jsr $a4a1			jsr 	GXCircleSetup 				; set up for drawing
.c3b2	a3b2	9c 5d 08	stz $085d			stz 	gxYChanged
.c3b5	a3b5					_GXCircleDraw:
.c3b5	a3b5	ad 5a 08	lda $085a			lda 	gxxCentre					; while x <= y
.c3b8	a3b8	cd 5b 08	cmp $085b			cmp 	gxYCentre
.c3bb	a3bb	90 0a		bcc $a3c7			bcc 	_GXCircleContinue
.c3bd	a3bd	d0 03		bne $a3c2			bne 	_GXNoLast
.c3bf	a3bf	20 d4 a3	jsr $a3d4			jsr 	GXPlot1
.c3c2	a3c2					_GXNoLast:
.c3c2	a3c2	20 df aa	jsr $aadf			jsr 	GXCloseBitmap 				; close the bitmap
.c3c5	a3c5	18		clc				clc
.c3c6	a3c6	60		rts				rts
.c3c7	a3c7					_GXCircleContinue:
.c3c7	a3c7	20 d1 a3	jsr $a3d1			jsr 	GXPlot2 					; draw it
.c3ca	a3ca	20 4e a4	jsr $a44e			jsr 	GXCircleMove 				; adjust the coordinates
.c3cd	a3cd	80 e6		bra $a3b5			bra 	_GXCircleDraw
.c3cf	a3cf					_GXCFail:
.c3cf	a3cf	38		sec				sec
.c3d0	a3d0	60		rts				rts
.c3d1	a3d1					GXPlot2:
.c3d1	a3d1	20 d4 a3	jsr $a3d4			jsr 	GXPlot1 						; plot and swap, fall through does twice
.c3d4	a3d4					GXPlot1:
.c3d4	a3d4	ad 5b 08	lda $085b			lda 	gxYCentre 						; if y = 0, don't do it twice (xor)
.c3d7	a3d7	f0 03		beq $a3dc			beq 	_GXPlot1Only
.c3d9	a3d9	20 f8 a3	jsr $a3f8			jsr 	GXPlot0 						; plot and negate
.c3dc	a3dc					_GXPlot1Only:
.c3dc	a3dc	20 f8 a3	jsr $a3f8			jsr 	GXPlot0 						; twice, undoing negation
.c3df	a3df	ad 5a 08	lda $085a			lda 	gxxCentre 						; swap X and Y
.c3e2	a3e2	ae 5b 08	ldx $085b			ldx	 	gxYCentre
.c3e5	a3e5	8d 5b 08	sta $085b			sta 	gxYCentre
.c3e8	a3e8	8e 5a 08	stx $085a			stx 	gxxCentre
.c3eb	a3eb	ad 5d 08	lda $085d			lda 	gxYChanged 						; toggle Y Changed flag
.c3ee	a3ee	a9 ff		lda #$ff			lda 	#$FF
.c3f0	a3f0	8d 5d 08	sta $085d			sta 	gxYChanged
.c3f3	a3f3	60		rts				rts
.c3f4	a3f4	20 f8 a3	jsr $a3f8			jsr 	GXPlot0 						; do once
.c3f7	a3f7	60		rts				rts
.c3f8	a3f8	ad 5c 08	lda $085c	GXPlot0:lda 	gxIsFillMode 					; outline mode, always draw as X or Y will change
.c3fb	a3fb	f0 05		beq $a402			beq 	_GXPlot0Always
.c3fd	a3fd	ad 5d 08	lda $085d			lda 	gxYChanged						; fill mode, only draw if changed.
.c400	a400	f0 2d		beq $a42f			beq 	GXPlot0Exit
.c402	a402					_GXPlot0Always:
.c402	a402	a2 02		ldx #$02			ldx 	#2 								; copy Y1-A => Y0
.c404	a404	ad 5b 08	lda $085b			lda 	gxYCentre
.c407	a407	20 30 a4	jsr $a430			jsr 	GXSubCopy
.c40a	a40a	a2 00		ldx #$00			ldx 	#0 								; copy X1-A => X0,
.c40c	a40c	ad 5a 08	lda $085a			lda 	gxxCentre
.c40f	a40f	20 30 a4	jsr $a430			jsr 	GXSubCopy
.c412	a412	48		pha				pha 									; save last offset X
.c413	a413	20 e7 aa	jsr $aae7			jsr 	gxPositionCalc 					; calculate position/offset.
.c416	a416	68		pla				pla
.c417	a417	0a		asl a				asl 	a 								; store 2 x last offset in gxzTemp0
.c418	a418	85 36		sta $36				sta 	gxzTemp0
.c41a	a41a	64 37		stz $37				stz 	gxzTemp0+1
.c41c	a41c	26 37		rol $37				rol 	gxzTemp0+1
.c41e	a41e	ad 5c 08	lda $085c			lda 	gxIsFillMode
.c421	a421	69 80		adc #$80			adc 	#128
.c423	a423	20 c0 a7	jsr $a7c0			jsr 	GXDrawLineTemp0 				; routine from Rectangle.
.c426	a426	38		sec				sec 									; GY = -GY
.c427	a427	a9 00		lda #$00			lda 	#0
.c429	a429	ed 5b 08	sbc $085b			sbc 	gxYCentre
.c42c	a42c	8d 5b 08	sta $085b			sta 	gxYCentre
.c42f	a42f					GXPlot0Exit:
.c42f	a42f	60		rts				rts
.c430	a430					GXSubCopy:
.c430	a430	85 36		sta $36				sta 	gxzTemp0
.c432	a432	64 37		stz $37				stz 	gxzTemp0+1
.c434	a434	29 80		and #$80			and 	#$80
.c436	a436	f0 02		beq $a43a			beq 	_GXNoSx
.c438	a438	c6 37		dec $37				dec 	gxzTemp0+1
.c43a	a43a					_GXNoSx:
.c43a	a43a	38		sec				sec
.c43b	a43b	bd c5 07	lda $07c5,x			lda 	gxX1,x
.c43e	a43e	e5 36		sbc $36				sbc 	gxzTemp0
.c440	a440	9d c1 07	sta $07c1,x			sta 	gxX0,x
.c443	a443	bd c6 07	lda $07c6,x			lda 	gxX1+1,x
.c446	a446	e5 37		sbc $37				sbc 	gxzTemp0+1
.c448	a448	9d c2 07	sta $07c2,x			sta 	gxX0+1,x
.c44b	a44b	a5 36		lda $36				lda 	gxzTemp0 						; return A
.c44d	a44d	60		rts				rts
.c44e	a44e					GXCircleMove:
.c44e	a44e	9c 5d 08	stz $085d			stz 	gxYChanged 					; clear Y changed flag
.c451	a451	a5 39		lda $39				lda 	gxzTemp1+1 					; check sign of D
.c453	a453	10 0d		bpl $a462			bpl 	_GXEMPositive
.c455	a455	ee 5a 08	inc $085a			inc 	gxxCentre 					; X++
.c458	a458	ad 5a 08	lda $085a			lda 	gxxCentre
.c45b	a45b	20 81 a4	jsr $a481			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.c45e	a45e	a9 06		lda #$06			lda 	#6  						; and add 6
.c460	a460	80 15		bra $a477			bra 	_GXEMAddD
.c462	a462					_GXEMPositive:
.c462	a462	ee 5a 08	inc $085a			inc 	gxxCentre					; X++
.c465	a465	ce 5b 08	dec $085b			dec 	gxYCentre 					; Y--
.c468	a468	38		sec				sec 								; calculate X-Y
.c469	a469	ad 5a 08	lda $085a			lda 	gxxCentre
.c46c	a46c	ed 5b 08	sbc $085b			sbc 	gxYCentre
.c46f	a46f	20 81 a4	jsr $a481			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.c472	a472	a9 0a		lda #$0a			lda 	#10  						; and add 10
.c474	a474	ce 5d 08	dec $085d			dec 	gxYChanged
.c477	a477					_GXEMAddD:
.c477	a477	18		clc				clc
.c478	a478	65 38		adc $38				adc 	gxzTemp1
.c47a	a47a	85 38		sta $38				sta 	gxzTemp1
.c47c	a47c	90 02		bcc $a480			bcc 	_GXEMNoCarry
.c47e	a47e	e6 39		inc $39				inc 	gxzTemp1+1
.c480	a480					_GXEMNoCarry:
.c480	a480	60		rts				rts
.c481	a481					_GXAdd4TimesToD:
.c481	a481	85 36		sta $36				sta 	gxzTemp0 					; make 16 bit signed.
.c483	a483	29 80		and #$80			and 	#$80
.c485	a485	f0 02		beq $a489			beq 	_GXA4Unsigned
.c487	a487	a9 ff		lda #$ff			lda 	#$FF
.c489	a489					_GXA4Unsigned:
.c489	a489	85 37		sta $37				sta 	gxzTemp0+1
.c48b	a48b	06 36		asl $36				asl 	gxzTemp0  					; x 4
.c48d	a48d	26 37		rol $37				rol 	gxzTemp0+1
.c48f	a48f	06 36		asl $36				asl 	gxzTemp0
.c491	a491	26 37		rol $37				rol 	gxzTemp0+1
.c493	a493	18		clc				clc 								; add
.c494	a494	a5 36		lda $36				lda		gxzTemp0
.c496	a496	65 38		adc $38				adc 	gxzTemp1
.c498	a498	85 38		sta $38				sta 	gxzTemp1
.c49a	a49a	a5 37		lda $37				lda		gxzTemp0+1
.c49c	a49c	65 39		adc $39				adc 	gxzTemp1+1
.c49e	a49e	85 39		sta $39				sta 	gxzTemp1+1
.c4a0	a4a0	60		rts				rts
.c4a1	a4a1					GXCircleSetup:
.c4a1	a4a1	38		sec				sec
.c4a2	a4a2	ad c7 07	lda $07c7			lda 	gxY1
.c4a5	a4a5	ed c3 07	sbc $07c3			sbc 	gxY0
.c4a8	a4a8	4a		lsr a				lsr 	a
.c4a9	a4a9	8d 59 08	sta $0859			sta 	gxRadius
.c4ac	a4ac	a2 00		ldx #$00			ldx 	#0
.c4ae	a4ae	20 d0 a4	jsr $a4d0			jsr 	_GXCalculateCentre
.c4b1	a4b1	a2 02		ldx #$02			ldx 	#2
.c4b3	a4b3	20 d0 a4	jsr $a4d0			jsr 	_GXCalculateCentre
.c4b6	a4b6	9c 5a 08	stz $085a			stz 	gxxCentre
.c4b9	a4b9	ad 59 08	lda $0859			lda 	gxRadius
.c4bc	a4bc	8d 5b 08	sta $085b			sta 	gxYCentre
.c4bf	a4bf	0a		asl a				asl 	a 							; R x 2
.c4c0	a4c0	85 36		sta $36				sta 	gxzTemp0
.c4c2	a4c2	38		sec				sec
.c4c3	a4c3	a9 03		lda #$03			lda 	#3
.c4c5	a4c5	e5 36		sbc $36				sbc 	gxzTemp0
.c4c7	a4c7	85 38		sta $38				sta 	gxzTemp1
.c4c9	a4c9	a9 00		lda #$00			lda 	#0
.c4cb	a4cb	e9 00		sbc #$00			sbc 	#0
.c4cd	a4cd	85 39		sta $39				sta 	gxzTemp1+1
.c4cf	a4cf	60		rts				rts
.c4d0	a4d0					_GXCalculateCentre:
.c4d0	a4d0	38		sec				sec
.c4d1	a4d1	bd c5 07	lda $07c5,x			lda 	gxX1,x
.c4d4	a4d4	7d c1 07	adc $07c1,x			adc 	gxX0,x
.c4d7	a4d7	9d c5 07	sta $07c5,x			sta 	gxX1,x
.c4da	a4da	bd c6 07	lda $07c6,x			lda 	gxX1+1,x
.c4dd	a4dd	7d c2 07	adc $07c2,x			adc 	gxX0+1,x
.c4e0	a4e0	4a		lsr a				lsr 	a
.c4e1	a4e1	9d c6 07	sta $07c6,x			sta 	gxX1+1,x
.c4e4	a4e4	7e c5 07	ror $07c5,x			ror 	gxX1,x
.c4e7	a4e7	60		rts				rts
.0859						gxRadius:
>0859								.fill 	1
.085a						gxxCentre:
>085a								.fill 	1
.085b						gxYCentre:
>085b								.fill 	1
.085c						gxIsFillMode:
>085c								.fill 	1
.085d						gxYChanged:
>085d								.fill  	1
=64000						ScreenSize200 = 320 * 200
=76800						ScreenSize240 = 320 * 240
.c4e8	a4e8					GXClearBitmap:
.c4e8	a4e8	ad ca 07	lda $07ca			lda 	gxBitmapsOn 				; check BMP running.
.c4eb	a4eb	f0 24		beq $a511			beq 	_GXCBFail
.c4ed	a4ed	20 d7 aa	jsr $aad7			jsr 	GXOpenBitmap 				; start access
.c4f0	a4f0	a0 07		ldy #$07			ldy 	#ScreenSize200 / 8192 		; X is pages to clear
.c4f2	a4f2	ad cd 07	lda $07cd			lda 	gxHeight
.c4f5	a4f5	c9 c8		cmp #$c8			cmp 	#200 						; 200 ?
.c4f7	a4f7	a0 09		ldy #$09			ldy 	#ScreenSize240 / 8192
.c4f9	a4f9					_GXCalcLastPage:
.c4f9	a4f9	98		tya				tya 								; add to base page
.c4fa	a4fa	18		clc				clc
.c4fb	a4fb	6d cb 07	adc $07cb			adc 	gxBasePage
.c4fe	a4fe	85 0b		sta $0b				sta 	GXEditSlot  				; clear from this page back
.c500	a500					_GXClearAll:
.c500	a500	20 13 a5	jsr $a513			jsr 	_GXClearBlock 				; clear 8k block
.c503	a503	c6 0b		dec $0b				dec 	GXEditSlot  				; back to previous
.c505	a505	a5 0b		lda $0b				lda 	GXEditSlot
.c507	a507	cd cb 07	cmp $07cb			cmp 	gxBasePage 					; until before base page
.c50a	a50a	b0 f4		bcs $a500			bcs 	_GXClearAll
.c50c	a50c	20 df aa	jsr $aadf			jsr 	GXCloseBitmap	 			; stop access
.c50f	a50f	18		clc				clc
.c510	a510	60		rts				rts
.c511	a511					_GXCBFail:
.c511	a511	38		sec				sec
.c512	a512	60		rts				rts
.c513	a513					_GXClearBlock:
.c513	a513	a9 00		lda #$00			lda 	#((GXMappingAddress) & $FF)
.c515	a515	85 38		sta $38				sta 	0+gxzTemp1
.c517	a517	a9 60		lda #$60			lda 	#((GXMappingAddress) >> 8)
.c519	a519	85 39		sta $39				sta 	1+gxzTemp1
.c51b	a51b					_GXCB0:
.c51b	a51b	a5 36		lda $36				lda 	gxzTemp0
.c51d	a51d	a0 00		ldy #$00			ldy 	#0
.c51f	a51f					_GXCB1:
.c51f	a51f	91 38		sta ($38),y			sta 	(gxzTemp1),y
.c521	a521	c8		iny				iny
.c522	a522	91 38		sta ($38),y			sta 	(gxzTemp1),y
.c524	a524	c8		iny				iny
.c525	a525	91 38		sta ($38),y			sta 	(gxzTemp1),y
.c527	a527	c8		iny				iny
.c528	a528	91 38		sta ($38),y			sta 	(gxzTemp1),y
.c52a	a52a	c8		iny				iny
.c52b	a52b	d0 f2		bne $a51f			bne 	_GXCB1
.c52d	a52d	e6 39		inc $39				inc 	gxzTemp1+1
.c52f	a52f	a5 39		lda $39				lda 	gxzTemp1+1
.c531	a531	c9 80		cmp #$80			cmp	 	#(GXMappingAddress >> 8)+$20
.c533	a533	d0 e6		bne $a51b			bne 	_GXCB0
.c535	a535	60		rts				rts
.c536	a536					GXInitialise:
.c536	a536	64 01		stz $01				stz 	1
.c538	a538	a9 01		lda #$01			lda 	#1
.c53a	a53a	8d 00 d0	sta $d000			sta 	$D000
.c53d	a53d	18		clc				clc
.c53e	a53e	9c c9 07	stz $07c9			stz 	gxSpritesOn
.c541	a541	9c ca 07	stz $07ca			stz 	gxBitmapsOn
.c544	a544	a2 0f		ldx #$0f			ldx 	#15
.c546	a546					_GXIClear:
.c546	a546	9e b9 07	stz $07b9,x			stz 	gxCurrentX,x
.c549	a549	ca		dex				dex
.c54a	a54a	10 fa		bpl $a546			bpl 	_GXIClear
.c54c	a54c	20 e7 a5	jsr $a5e7			jsr 	GXClearSpriteStore
.c54f	a54f	60		rts				rts
.c550	a550					GXControlBitmap:
.c550	a550	64 01		stz $01				stz 	1
.c552	a552	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.c554	a554	29 01		and #$01			and 	#1 							; set bitmap flag
.c556	a556	8d ca 07	sta $07ca			sta 	gxBitmapsOn
.c559	a559	4a		lsr a				lsr 	a 							; bit 0 into carry.
.c55a	a55a	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.c55d	a55d	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.c55f	a55f	29 f7		and #$f7			and 	#$F7 						; clear bitmap bit
.c561	a561	90 02		bcc $a565			bcc 	_CBNotOn
.c563	a563	09 08		ora #$08			ora 	#$08 						; bitmap on if 1 on 0 off
.c565	a565					_CBNotOn:
.c565	a565	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.c568	a568	a5 36		lda $36				lda 	gxzTemp0 					; get control settings (bits 0-2)
.c56a	a56a	29 07		and #$07			and 	#7
.c56c	a56c	8d 00 d1	sta $d100			sta 	$D100 						; write in Vicky Bitmap Control Register #0
.c56f	a56f	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.c571	a571	d0 02		bne $a575			bne 	_CBNotDefault
.c573	a573	a9 08		lda #$08			lda 	#8  						; if zero, use 8 e.g. bitmap at $10000
.c575	a575					_CBNotDefault:
.c575	a575	8d cb 07	sta $07cb			sta 	gxBasePage
.c578	a578	20 d9 a5	jsr $a5d9			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.c57b	a57b	a5 37		lda $37				lda 	gxzTemp0+1 					; copy address into Bitmap address registers
.c57d	a57d	8d 03 d1	sta $d103			sta 	$D103
.c580	a580	a5 36		lda $36				lda 	gxzTemp0
.c582	a582	8d 02 d1	sta $d102			sta 	$D102
.c585	a585	9c 01 d1	stz $d101			stz 	$D101
.c588	a588	a2 f0		ldx #$f0			ldx 	#240 						; height is 240
.c58a	a58a	ad 01 d0	lda $d001			lda 	$D001 						; read MCR bit 0
.c58d	a58d	29 01		and #$01			and 	#1
.c58f	a58f	f0 02		beq $a593			beq 	_CBHaveHeight
.c591	a591	a2 c8		ldx #$c8			ldx 	#200 						; if bit 0 set 320x200
.c593	a593					_CBHaveHeight
.c593	a593	8e cd 07	stx $07cd			stx 	gxHeight
.c596	a596	18		clc				clc
.c597	a597	60		rts				rts
.c598	a598					GXControlSprite:
.c598	a598	64 01		stz $01				stz 	1
.c59a	a59a	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.c59c	a59c	29 01		and #$01			and 	#1 							; set sprites flag
.c59e	a59e	8d c9 07	sta $07c9			sta 	gxSpritesOn
.c5a1	a5a1	4a		lsr a				lsr 	a 							; bit 0 into carry.
.c5a2	a5a2	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.c5a5	a5a5	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.c5a7	a5a7	29 df		and #$df			and 	#$DF 						; clear sprite bit
.c5a9	a5a9	90 02		bcc $a5ad			bcc 	_CSNotOn
.c5ab	a5ab	09 20		ora #$20			ora 	#$20 						; sprite on if 1 on 0 off
.c5ad	a5ad					_CSNotOn:
.c5ad	a5ad	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.c5b0	a5b0	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.c5b2	a5b2	d0 02		bne $a5b6			bne 	_CSNotDefault
.c5b4	a5b4	a9 18		lda #$18			lda 	#24  						; if zero, use 24 e.g. sprites at $30000
.c5b6	a5b6					_CSNotDefault:
.c5b6	a5b6	8d cc 07	sta $07cc			sta 	gxSpritePage
.c5b9	a5b9	20 d9 a5	jsr $a5d9			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.c5bc	a5bc	a5 36		lda $36				lda 	gxzTemp0
.c5be	a5be	8d d7 07	sta $07d7			sta 	gxSpriteOffsetBase
.c5c1	a5c1	a5 37		lda $37				lda 	gxzTemp0+1
.c5c3	a5c3	8d d8 07	sta $07d8			sta 	gxSpriteOffsetBase+1
.c5c6	a5c6	a2 00		ldx #$00			ldx 	#0 							; disable all sprites, clears all sprite memory.
.c5c8	a5c8					_CSClear:
.c5c8	a5c8	9e 00 d9	stz $d900,x			stz 	$D900,x
.c5cb	a5cb	9e 00 da	stz $da00,x			stz 	$DA00,x
.c5ce	a5ce	ca		dex				dex
.c5cf	a5cf	d0 f7		bne $a5c8			bne 	_CSClear
.c5d1	a5d1	9c d6 07	stz $07d6			stz 	GSCurrentSpriteAddr+1 		; no sprite selected.
.c5d4	a5d4	20 e7 a5	jsr $a5e7			jsr 	GXClearSpriteStore
.c5d7	a5d7	18		clc				clc
.c5d8	a5d8	60		rts				rts
.c5d9	a5d9					GXCalculateBaseAddress:
.c5d9	a5d9	85 36		sta $36				sta 	gxzTemp0
.c5db	a5db	64 37		stz $37				stz 	gxzTemp0+1
.c5dd	a5dd	a9 05		lda #$05			lda 	#5
.c5df	a5df					_GXShift:
.c5df	a5df	06 36		asl $36				asl 	gxzTemp0
.c5e1	a5e1	26 37		rol $37				rol 	gxzTemp0+1
.c5e3	a5e3	3a		dec a				dec		a
.c5e4	a5e4	d0 f9		bne $a5df			bne 	_GXShift
.c5e6	a5e6	60		rts				rts
.c5e7	a5e7					GXClearSpriteStore:
.c5e7	a5e7	a2 3f		ldx #$3f			ldx 	#63 						; erase 64 sprite store elements
.c5e9	a5e9					_GXCSSLoop:
.c5e9	a5e9	9e 19 08	stz $0819,x			stz 	gxSpriteHigh,x
.c5ec	a5ec	a9 80		lda #$80			lda 	#$80 						; set the 'hidden' bit.
.c5ee	a5ee	9d d9 07	sta $07d9,x			sta 	gxSpriteLow,x
.c5f1	a5f1	ca		dex				dex
.c5f2	a5f2	10 f5		bpl $a5e9			bpl 	_GXCSSLoop
.c5f4	a5f4	60		rts				rts
.c5f5	a5f5					GXLine:
.c5f5	a5f5	ad ca 07	lda $07ca			lda 	gxBitmapsOn
.c5f8	a5f8	f0 28		beq $a622			beq 	_GXLFail
.c5fa	a5fa	20 d7 aa	jsr $aad7			jsr 	GXOpenBitmap
.c5fd	a5fd	20 1d ac	jsr $ac1d			jsr 	GXSortY						; sort pairs so Y1 >= Y0 e.g. top to bottom.
.c600	a600	20 c8 a6	jsr $a6c8			jsr 	GXLineSetup 				; the calculations in the linescanner constructor
.c603	a603	20 e7 aa	jsr $aae7			jsr 	gxPositionCalc 				; calculate position/offset.
.c606	a606					_GXDrawLoop:
.c606	a606	ac d3 07	ldy $07d3			ldy 	gxOffset 					; draw the pixel
.c609	a609	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.c60b	a60b	2d d1 07	and $07d1			and 	gxANDValue
.c60e	a60e	4d d0 07	eor $07d0			eor 	gxEORValue
.c611	a611	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.c613	a613	20 24 a6	jsr $a624			jsr 	GXLineIsComplete 			; is the line complete ?
.c616	a616	f0 05		beq $a61d			beq 	_GXLExit
.c618	a618	20 3f a6	jsr $a63f			jsr 	GXLineAdvance 				; code as per advance method
.c61b	a61b	80 e9		bra $a606			bra 	_GXDrawLoop
.c61d	a61d					_GXLExit:
.c61d	a61d	20 df aa	jsr $aadf			jsr 	GXCloseBitmap
.c620	a620	18		clc				clc
.c621	a621	60		rts				rts
.c622	a622					_GXLFail:
.c622	a622	38		sec				sec
.c623	a623	60		rts				rts
.c624	a624					GXLineIsComplete:
.c624	a624	ad 60 08	lda $0860			lda 	gxIsDiffYLarger 			; is dy larger
.c627	a627	d0 0f		bne $a638			bne 	_GXLICCompareY 				; if so compare Y1/Y0
.c629	a629	ad c1 07	lda $07c1			lda 	gxX0 						; compare X, LSB and MSB
.c62c	a62c	4d c5 07	eor $07c5			eor 	gxX1
.c62f	a62f	d0 06		bne $a637			bne 	_GXLICExit
.c631	a631	ad c2 07	lda $07c2			lda 	gxX0+1
.c634	a634	4d c6 07	eor $07c6			eor 	gxX1+1
.c637	a637					_GXLICExit:
.c637	a637	60		rts				rts
.c638	a638					_GXLICCompareY:
.c638	a638	ad c7 07	lda $07c7			lda 	gxY1
.c63b	a63b	4d c3 07	eor $07c3			eor 	gxY0
.c63e	a63e	60		rts				rts
.c63f	a63f					GXLineAdvance:
.c63f	a63f	18		clc				clc 								; add adjust to position
.c640	a640	ad 62 08	lda $0862			lda 	gxPosition
.c643	a643	6d 63 08	adc $0863			adc 	gxAdjust
.c646	a646	8d 62 08	sta $0862			sta 	gxPosition
.c649	a649	9c 65 08	stz $0865			stz 	gxAddSelect 				; clear add select flag
.c64c	a64c	b0 05		bcs $a653			bcs 	_GXLAOverflow 				; if carry out, overflowed.
.c64e	a64e	cd 64 08	cmp $0864			cmp 	gxTotal 					; if exceeded total
.c651	a651	90 0a		bcc $a65d			bcc 	_GXLANoExtra
.c653	a653					_GXLAOverflow:
.c653	a653	ce 65 08	dec $0865			dec 	gxAddSelect 				; set addselect to $FF
.c656	a656	38		sec				sec 								; subtract total and write back
.c657	a657	ed 64 08	sbc $0864			sbc 	gxTotal
.c65a	a65a	8d 62 08	sta $0862			sta 	gxPosition
.c65d	a65d					_GXLANoExtra:
.c65d	a65d	ad 60 08	lda $0860			lda 	gxIsDiffYLarger
.c660	a660	f0 0d		beq $a66f			beq 	_GXDXLarger
.c662	a662	20 c1 a6	jsr $a6c1			jsr 	GXIncrementY
.c665	a665	ad 65 08	lda $0865			lda 	gxAddSelect
.c668	a668	f0 10		beq $a67a			beq 	_GXLAExit
.c66a	a66a	20 7b a6	jsr $a67b			jsr 	gxAdjustX
.c66d	a66d	80 0b		bra $a67a			bra 	_GXLAExit
.c66f	a66f					_GXDXLarger:
.c66f	a66f	20 7b a6	jsr $a67b			jsr 	gxAdjustX
.c672	a672	ad 65 08	lda $0865			lda 	gxAddSelect
.c675	a675	f0 03		beq $a67a			beq 	_GXLAExit
.c677	a677	20 c1 a6	jsr $a6c1			jsr 	GXIncrementY
.c67a	a67a					_GXLAExit:
.c67a	a67a	60		rts				rts
.c67b	a67b					gxAdjustX:
.c67b	a67b	ad 61 08	lda $0861			lda 	gxDXNegative
.c67e	a67e	10 25		bpl $a6a5			bpl 	_GXAXRight
.c680	a680	ad c1 07	lda $07c1			lda 	gxX0
.c683	a683	d0 03		bne $a688			bne 	_GXAXNoBorrow
.c685	a685	ce c2 07	dec $07c2			dec 	gxX0+1
.c688	a688					_GXAXNoBorrow:
.c688	a688	ce c1 07	dec $07c1			dec 	gxX0
.c68b	a68b	ce d3 07	dec $07d3			dec 	gxOffset 					; pixel left
.c68e	a68e	ad d3 07	lda $07d3			lda 	gxOffset
.c691	a691	c9 ff		cmp #$ff			cmp 	#$FF
.c693	a693	d0 0f		bne $a6a4			bne 	_GXAYExit 					; underflow
.c695	a695	c6 3d		dec $3d				dec 	gxzScreen+1 					; borrow
.c697	a697	a5 3d		lda $3d				lda 	gxzScreen+1 					; gone off page
.c699	a699	c9 60		cmp #$60			cmp 	#GXMappingAddress >> 8
.c69b	a69b	b0 07		bcs $a6a4			bcs 	_GXAYExit
.c69d	a69d	18		clc				clc
.c69e	a69e	69 20		adc #$20			adc 	#$20 						; fix up
.c6a0	a6a0	85 3d		sta $3d				sta 	gxzScreen+1
.c6a2	a6a2	c6 0b		dec $0b				dec 	GXEditSlot 				; back one page
.c6a4	a6a4					_GXAYExit:
.c6a4	a6a4	60		rts				rts
.c6a5	a6a5					_GXAXRight:
.c6a5	a6a5	ee c1 07	inc $07c1			inc 	gxX0
.c6a8	a6a8	d0 03		bne $a6ad			bne 	_GXAXNoCarry
.c6aa	a6aa	ee c2 07	inc $07c2			inc 	gxX0+1
.c6ad	a6ad					_GXAXNoCarry:
.c6ad	a6ad	ee d3 07	inc $07d3			inc 	gxOffset 					; pixel right
.c6b0	a6b0	d0 0e		bne $a6c0			bne 	_GXAXExit 					; if not overflowed, exit.
.c6b2	a6b2	e6 3d		inc $3d				inc 	gxzScreen+1 					; next line
.c6b4	a6b4	a5 3d		lda $3d				lda 	gxzScreen+1
.c6b6	a6b6	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.c6b8	a6b8	90 06		bcc $a6c0			bcc 	_GXAXExit
.c6ba	a6ba	e9 20		sbc #$20			sbc 	#$20 						; fix up
.c6bc	a6bc	85 3d		sta $3d				sta 	gxzScreen+1
.c6be	a6be	e6 0b		inc $0b				inc 	GXEditSlot 				; next page
.c6c0	a6c0					_GXAXExit:
.c6c0	a6c0	60		rts				rts
.c6c1	a6c1					GXIncrementY:
.c6c1	a6c1	ee c3 07	inc $07c3			inc 	gxY0
.c6c4	a6c4	20 3d ab	jsr $ab3d			jsr 	GXMovePositionDown
.c6c7	a6c7	60		rts				rts
.c6c8	a6c8					GXLineSetup:
.c6c8	a6c8	ad c7 07	lda $07c7			lda 	gxY1
.c6cb	a6cb	38		sec				sec
.c6cc	a6cc	ed c3 07	sbc $07c3			sbc 	gxY0
.c6cf	a6cf	4a		lsr a				lsr 	a
.c6d0	a6d0	8d 5f 08	sta $085f			sta 	gxDiffY
.c6d3	a6d3	9c 61 08	stz $0861			stz 	gxDXNegative 				; clear -ve flag
.c6d6	a6d6	38		sec				sec
.c6d7	a6d7	ad c5 07	lda $07c5			lda 	gxX1
.c6da	a6da	ed c1 07	sbc $07c1			sbc 	gxX0
.c6dd	a6dd	8d 5e 08	sta $085e			sta 	gxDiffX
.c6e0	a6e0	ad c6 07	lda $07c6			lda 	gxX1+1 						; calculate MSB
.c6e3	a6e3	ed c2 07	sbc $07c2			sbc 	gxX0+1
.c6e6	a6e6	6a		ror a				ror 	a 							; rotate bit into DiffX halving it
.c6e7	a6e7	6e 5e 08	ror $085e			ror 	gxDiffX
.c6ea	a6ea	0a		asl a				asl 	a
.c6eb	a6eb	10 0c		bpl $a6f9			bpl 	_GDXNotNegative
.c6ed	a6ed	a9 00		lda #$00			lda 	#0 							; make absolute value of |dx|
.c6ef	a6ef	38		sec				sec
.c6f0	a6f0	ed 5e 08	sbc $085e			sbc 	gxDiffX
.c6f3	a6f3	8d 5e 08	sta $085e			sta 	gxDiffX
.c6f6	a6f6	ce 61 08	dec $0861			dec 	gxDXNegative 				; -ve flag = $FF.
.c6f9	a6f9					_GDXNotNegative:
.c6f9	a6f9	9c 60 08	stz $0860			stz 	gxIsDiffYLarger 			; clear larger flag
.c6fc	a6fc	ad 5f 08	lda $085f			lda 	gxDiffY 					; set adjust and total.
.c6ff	a6ff	8d 63 08	sta $0863			sta 	gxAdjust
.c702	a702	ad 5e 08	lda $085e			lda 	gxDiffX
.c705	a705	8d 64 08	sta $0864			sta 	gxTotal
.c708	a708	ad 5f 08	lda $085f			lda 	gxDiffY 					; if dy > dx
.c70b	a70b	cd 5e 08	cmp $085e			cmp 	gxDiffX
.c70e	a70e	90 0f		bcc $a71f			bcc 	_GDXNotLarger
.c710	a710	ce 60 08	dec $0860			dec 	gxIsDiffYLarger 			; set the dy larger flag
.c713	a713	ad 5e 08	lda $085e			lda 	gxDiffX 					; set adjust and total other way round
.c716	a716	8d 63 08	sta $0863			sta 	gxAdjust
.c719	a719	ad 5f 08	lda $085f			lda 	gxDiffY
.c71c	a71c	8d 64 08	sta $0864			sta 	gxTotal
.c71f	a71f					_GDXNotLarger:
.c71f	a71f	ad 64 08	lda $0864			lda 	gxTotal
.c722	a722	4a		lsr a				lsr 	a
.c723	a723	8d 62 08	sta $0862			sta 	gxPosition
.c726	a726	60		rts				rts
.085e						gxDiffX:
>085e								.fill 	1
.085f						gxDiffY:
>085f								.fill 	1
.0860						gxIsDiffYLarger:
>0860								.fill 	1
.0861						gxDXNegative:
>0861								.fill 	1
.0862						gxPosition:
>0862								.fill 	1
.0863						gxAdjust:
>0863								.fill 	1
.0864						gxTotal:
>0864								.fill 	1
.0865						gxAddSelect:
>0865								.fill 	1
.c727	a727					GXSetColourMode:
.c727	a727	a6 36		ldx $36				ldx 	gxzTemp0
.c729	a729	8e cf 07	stx $07cf			stx 	gxColour 								; set colour
.c72c	a72c	a5 37		lda $37				lda 	gxzTemp0+1 								;
.c72e	a72e	8d ce 07	sta $07ce			sta 	gxMode 									; set mode
.c731	a731	29 03		and #$03			and 	#3 										; only interested in bits 0-3
.c733	a733	9c d1 07	stz $07d1			stz 	gxANDValue 								; initially AND with 0, and EOR with Colour
.c736	a736	ae cf 07	ldx $07cf			ldx 	gxColour
.c739	a739	8e d0 07	stx $07d0			stx 	gxEORValue
.c73c	a73c	c9 02		cmp #$02			cmp 	#2 										; if mode 2/3 And with colour
.c73e	a73e	90 03		bcc $a743			bcc 	_GXSDCNotAndColour
.c740	a740	8e d1 07	stx $07d1			stx 	gxANDValue
.c743	a743					_GXSDCNotAndColour:
.c743	a743	d0 03		bne $a748			bne 	_GXSDCNotAnd 							; mode 2, Don't EOR with colour
.c745	a745	9c d0 07	stz $07d0			stz 	gxEORValue
.c748	a748					_GXSDCNotAnd:
.c748	a748	4a		lsr a				lsr 	a 										; if bit 0 set, 1's complement AND value
.c749	a749	90 08		bcc $a753			bcc 	_GXSDCNoFlip
.c74b	a74b	ad d1 07	lda $07d1			lda	 	gxANDValue
.c74e	a74e	49 ff		eor #$ff			eor 	#$FF
.c750	a750	8d d1 07	sta $07d1			sta 	gxANDValue
.c753	a753					_GXSDCNoFlip:
.c753	a753	18		clc				clc
.c754	a754	60		rts				rts
.c755	a755					GXPlotPoint:
.c755	a755	20 d7 aa	jsr $aad7			jsr 	GXOpenBitmap 				; start drawing
.c758	a758	20 e7 aa	jsr $aae7			jsr 	gxPositionCalc 				; setup gxzScreen, gxOffset and the position.
.c75b	a75b	ac d3 07	ldy $07d3			ldy 	gxOffset
.c75e	a75e	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.c760	a760	2d d1 07	and $07d1			and 	gxANDValue
.c763	a763	4d d0 07	eor $07d0			eor 	gxEORValue
.c766	a766	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.c768	a768	20 df aa	jsr $aadf			jsr 	GXCloseBitmap 				; stop drawing and exit
.c76b	a76b	18		clc				clc
.c76c	a76c	60		rts				rts
.c76d	a76d					GXFillRectangle:
.c76d	a76d	38		sec				sec
.c76e	a76e	80 01		bra $a771			bra 	GXRectangle
.c770	a770					GXFrameRectangle:
.c770	a770	18		clc				clc
.c771	a771					GXRectangle:
.c771	a771	ad ca 07	lda $07ca			lda 	gxBitmapsOn
.c774	a774	f0 35		beq $a7ab			beq 	_GXRFail
.c776	a776	08		php				php 								; save Fill flag (CS)
.c777	a777	20 d7 aa	jsr $aad7			jsr 	GXOpenBitmap 				; start drawing
.c77a	a77a	20 ff ab	jsr $abff			jsr 	GXSortXY 					; sort both X and Y so top left/bottom right
.c77d	a77d	20 e7 aa	jsr $aae7			jsr 	gxPositionCalc 				; setup gxzScreen, gxOffset and the position.
.c780	a780	38		sec				sec 								; sec = Draw line
.c781	a781	20 ad a7	jsr $a7ad			jsr 	GXDrawLineX1X0 				; draw a line length X1-X0
.c784	a784	ad c3 07	lda $07c3			lda 	gxY0 						; reached end of rectangle ?
.c787	a787	cd c7 07	cmp $07c7			cmp 	gxY1
.c78a	a78a	f0 19		beq $a7a5			beq 	_GXRectangleExit
.c78c	a78c					_GXRectLoop:
.c78c	a78c	20 3d ab	jsr $ab3d			jsr 	GXMovePositionDown 			; down one.
.c78f	a78f	ee c3 07	inc $07c3			inc 	gxY0 						; change Y pos
.c792	a792	ad c3 07	lda $07c3			lda 	gxY0 						; reached last line
.c795	a795	cd c7 07	cmp $07c7			cmp 	gxY1
.c798	a798	f0 07		beq $a7a1			beq 	_GXLastLine
.c79a	a79a	28		plp				plp 								; get flag back
.c79b	a79b	08		php				php
.c79c	a79c	20 ad a7	jsr $a7ad			jsr 	GXDrawLineX1X0 				; draw horizontal line
.c79f	a79f	80 eb		bra $a78c			bra 	_GXRectLoop
.c7a1	a7a1					_GXLastLine:
.c7a1	a7a1	38		sec				sec
.c7a2	a7a2	20 ad a7	jsr $a7ad			jsr 	GXDrawLineX1X0
.c7a5	a7a5					_GXRectangleExit:
.c7a5	a7a5	68		pla				pla 								; throw fill flag.
.c7a6	a7a6	20 df aa	jsr $aadf			jsr 	GXCloseBitmap 				; stop drawing and exit
.c7a9	a7a9	18		clc				clc
.c7aa	a7aa	60		rts				rts
.c7ab	a7ab					_GXRFail:
.c7ab	a7ab	38		sec				sec
.c7ac	a7ac	60		rts				rts
.c7ad	a7ad					GXDrawLineX1X0:
.c7ad	a7ad	08		php				php 								; save solid/either-end
.c7ae	a7ae	38		sec				sec
.c7af	a7af	ad c5 07	lda $07c5			lda		gxX1
.c7b2	a7b2	ed c1 07	sbc $07c1			sbc 	gxX0
.c7b5	a7b5	85 36		sta $36				sta 	gxzTemp0
.c7b7	a7b7	ad c6 07	lda $07c6			lda 	gxX1+1
.c7ba	a7ba	ed c2 07	sbc $07c2			sbc 	gxX0+1
.c7bd	a7bd	85 37		sta $37				sta 	gxzTemp0+1
.c7bf	a7bf	28		plp				plp
.c7c0	a7c0					GXDrawLineTemp0:
.c7c0	a7c0	a5 3c		lda $3c				lda 	gxzScreen 						; push gxzScreen, gxOffset and GXEditSlot on stack
.c7c2	a7c2	48		pha				pha
.c7c3	a7c3	a5 3d		lda $3d				lda 	gxzScreen+1
.c7c5	a7c5	48		pha				pha
.c7c6	a7c6	ad d3 07	lda $07d3			lda 	gxOffset
.c7c9	a7c9	48		pha				pha
.c7ca	a7ca	a5 0b		lda $0b				lda 	GXEditSlot
.c7cc	a7cc	48		pha				pha
.c7cd	a7cd	ac d3 07	ldy $07d3			ldy 	gxOffset 					; Y offset
.c7d0	a7d0	90 1e		bcc $a7f0			bcc 	_GXDLTEndPoints 			; if CC draw end points only.
.c7d2	a7d2					_GXDLTLine:
.c7d2	a7d2	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.c7d4	a7d4	2d d1 07	and $07d1			and 	gxANDValue
.c7d7	a7d7	4d d0 07	eor $07d0			eor 	gxEORValue
.c7da	a7da	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.c7dc	a7dc	a5 36		lda $36				lda 	gxzTemp0 					; decrement counter
.c7de	a7de	d0 04		bne $a7e4			bne 	_GXDLTNoBorrow
.c7e0	a7e0	c6 37		dec $37				dec 	gxzTemp0+1 					; borrow, if goes -ve then exit
.c7e2	a7e2	30 2e		bmi $a812			bmi 	_GXDLTExit
.c7e4	a7e4					_GXDLTNoBorrow:
.c7e4	a7e4	c6 36		dec $36				dec 	gxzTemp0
.c7e6	a7e6	c8		iny				iny 								; next slot.
.c7e7	a7e7	d0 e9		bne $a7d2			bne 	_GXDLTLine
.c7e9	a7e9	e6 3d		inc $3d				inc 	gxzScreen+1 					; carry to next
.c7eb	a7eb	20 20 a8	jsr $a820			jsr 	GXDLTCheckWrap				; check for new page.
.c7ee	a7ee	80 e2		bra $a7d2			bra 	_GXDLTLine
.c7f0	a7f0					_GXDLTEndPoints:
.c7f0	a7f0	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.c7f2	a7f2	2d d1 07	and $07d1			and 	gxANDValue
.c7f5	a7f5	4d d0 07	eor $07d0			eor 	gxEORValue
.c7f8	a7f8	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.c7fa	a7fa	98		tya				tya 								; advance to right side
.c7fb	a7fb	18		clc				clc
.c7fc	a7fc	65 36		adc $36				adc 	gxzTemp0
.c7fe	a7fe	a8		tay				tay
.c7ff	a7ff	a5 3d		lda $3d				lda 	gxzScreen+1
.c801	a801	65 37		adc $37				adc 	gxzTemp0+1
.c803	a803	85 3d		sta $3d				sta 	gxzScreen+1
.c805	a805	20 20 a8	jsr $a820			jsr 	GXDLTCheckWrap 			; fix up.
.c808	a808	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.c80a	a80a	2d d1 07	and $07d1			and 	gxANDValue
.c80d	a80d	4d d0 07	eor $07d0			eor 	gxEORValue
.c810	a810	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.c812	a812					_GXDLTExit:
.c812	a812	68		pla				pla
.c813	a813	85 0b		sta $0b				sta 	GXEditSlot
.c815	a815	68		pla				pla
.c816	a816	8d d3 07	sta $07d3			sta 	gxOffset
.c819	a819	68		pla				pla
.c81a	a81a	85 3d		sta $3d				sta 	gxzScreen+1
.c81c	a81c	68		pla				pla
.c81d	a81d	85 3c		sta $3c				sta 	gxzScreen
.c81f	a81f	60		rts				rts
.c820	a820					GXDLTCheckWrap:
.c820	a820	a5 3d		lda $3d				lda 	gxzScreen+1 					; check end of page
.c822	a822	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8)
.c824	a824	90 06		bcc $a82c			bcc 	_GXDLTCWExit
.c826	a826	e9 20		sbc #$20			sbc 	#$20 						; fix up
.c828	a828	85 3d		sta $3d				sta 	gxzScreen+1
.c82a	a82a	e6 0b		inc $0b				inc 	GXEditSlot
.c82c	a82c					_GXDLTCWExit:
.c82c	a82c	60		rts				rts
.c82d	a82d					GXDrawGraphicElement:
.c82d	a82d	8d 66 08	sta $0866			sta 	gxSize 						; save size
.c830	a830	3a		dec a				dec 	a
.c831	a831	8d 67 08	sta $0867			sta 	gxMask 						; and mask
.c834	a834	ad ca 07	lda $07ca			lda 	gxBitmapsOn 				; check BMP on
.c837	a837	f0 67		beq $a8a0			beq 	_GXSLFail
.c839	a839	ad c3 07	lda $07c3			lda 	gxY0 						; push Y on stack
.c83c	a83c	48		pha				pha
.c83d	a83d	8c 69 08	sty $0869			sty 	gxAcquireVector+1 			; and acquisition vector
.c840	a840	8e 68 08	stx $0868			stx 	gxAcquireVector
.c843	a843	20 d7 aa	jsr $aad7			jsr 	GXOpenBitmap 				; open the bitmap.
.c846	a846	ad 6b 08	lda $086b			lda 	gxUseMode 					; scale bits
.c849	a849	4a		lsr a				lsr 	a
.c84a	a84a	4a		lsr a				lsr 	a
.c84b	a84b	4a		lsr a				lsr 	a
.c84c	a84c	29 07		and #$07			and		#7
.c84e	a84e	1a		inc a				inc 	a
.c84f	a84f	8d 6a 08	sta $086a			sta 	gxScale
.c852	a852	64 38		stz $38				stz 	gxzTemp1					; start first line
.c854	a854					_GXGELoop:
.c854	a854	a5 38		lda $38				lda 	gxzTemp1 					; current line number to read.
.c856	a856	2c 6b 08	bit $086b			bit 	gxUseMode 					; check for flip.
.c859	a859	10 06		bpl $a861			bpl		_GXNoVFlip
.c85b	a85b	ad 67 08	lda $0867			lda 	gxMask
.c85e	a85e	38		sec				sec
.c85f	a85f	e5 38		sbc $38				sbc 	gxzTemp1
.c861	a861					_GXNoVFlip:
.c861	a861	aa		tax				tax 								; get the Xth line.
.c862	a862	20 a2 a8	jsr $a8a2			jsr 	_GXCallAcquire 				; get that data.
.c865	a865	ad 6a 08	lda $086a			lda 	gxScale 					; do scale identical copies of that line.
.c868	a868	85 39		sta $39				sta 	gxzTemp1+1
.c86a	a86a					_GXGELoop2:
.c86a	a86a	ad c3 07	lda $07c3			lda 	gxY0 						; off screen
.c86d	a86d	cd cd 07	cmp $07cd			cmp 	gxHeight
.c870	a870	b0 10		bcs $a882			bcs 	_GXDGEExit
.c872	a872	20 a5 a8	jsr $a8a5			jsr 	GXRenderOneLine 			; render line
.c875	a875	c6 39		dec $39				dec 	gxzTemp1+1 					; scale times.
.c877	a877	d0 f1		bne $a86a			bne 	_GXGELoop2
.c879	a879	e6 38		inc $38				inc 	gxzTemp1 					; done all lines.
.c87b	a87b	a5 38		lda $38				lda 	gxzTemp1
.c87d	a87d	cd 66 08	cmp $0866			cmp 	gxSize
.c880	a880	d0 d2		bne $a854			bne 	_GXGELoop
.c882	a882					_GXDGEExit:
.c882	a882	68		pla				pla 								; restore Y for next time
.c883	a883	8d c3 07	sta $07c3			sta 	gxY0
.c886	a886	ae 6a 08	ldx $086a			ldx 	gxScale 					; get scale (1-8)
.c889	a889					_GXShiftLeft:
.c889	a889	18		clc				clc
.c88a	a88a	ad 66 08	lda $0866			lda 	gxSize
.c88d	a88d	6d c1 07	adc $07c1			adc 	gxX0
.c890	a890	8d c1 07	sta $07c1			sta 	gxX0
.c893	a893	90 03		bcc $a898			bcc 	_GXSLNoCarry
.c895	a895	ee c2 07	inc $07c2			inc 	gxX0+1
.c898	a898					_GXSLNoCarry:
.c898	a898	ca		dex				dex
.c899	a899	d0 ee		bne $a889			bne 	_GXShiftLeft
.c89b	a89b	20 df aa	jsr $aadf			jsr 	GXCloseBitmap
.c89e	a89e	18		clc				clc
.c89f	a89f	60		rts				rts
.c8a0	a8a0					_GXSLFail:
.c8a0	a8a0	38		sec				sec
.c8a1	a8a1	60		rts				rts
.c8a2	a8a2					_GXCallAcquire:
.c8a2	a8a2	6c 68 08	jmp ($0868)			jmp 	(gxAcquireVector)
.c8a5	a8a5					GXRenderOneLine:
.c8a5	a8a5	20 e7 aa	jsr $aae7			jsr 	gxPositionCalc 				; calculate position/offset.
.c8a8	a8a8	ac d3 07	ldy $07d3			ldy 	gxOffset 					; Y contains position.
.c8ab	a8ab	64 3a		stz $3a				stz 	gxzTemp2 					; do size pixels
.c8ad	a8ad					_GXROLLoop1:
.c8ad	a8ad	ad 6a 08	lda $086a			lda 	gxScale 					; set to do 'scale' times
.c8b0	a8b0	85 3b		sta $3b				sta 	gxzTemp2+1
.c8b2	a8b2					_GXROLLoop2:
.c8b2	a8b2	a5 3a		lda $3a				lda 	gxzTemp2 					; get current pixel
.c8b4	a8b4	2c ce 07	bit $07ce			bit 	gxMode 						; check H Flip
.c8b7	a8b7	50 06		bvc $a8bf			bvc 	_GXNoHFlip
.c8b9	a8b9	ad 67 08	lda $0867			lda 	gxMask
.c8bc	a8bc	38		sec				sec
.c8bd	a8bd	e5 3a		sbc $3a				sbc 	gxzTemp2
.c8bf	a8bf					_GXNoHFlip:
.c8bf	a8bf	aa		tax				tax 								; read from the pixel buffer
.c8c0	a8c0	bd 23 06	lda $0623,x			lda 	gxPixelBuffer,x
.c8c3	a8c3	d0 07		bne $a8cc			bne 	_GXDraw 					; draw if non zero
.c8c5	a8c5	ad 6b 08	lda $086b			lda 	gxUseMode 					; check to see if solid background
.c8c8	a8c8	29 04		and #$04			and 	#4
.c8ca	a8ca	f0 0a		beq $a8d6			beq 	_GXZeroPixel
.c8cc	a8cc					_GXDraw:
.c8cc	a8cc	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.c8ce	a8ce	2d d1 07	and $07d1			and 	gxANDValue
.c8d1	a8d1	5d 23 06	eor $0623,x			eor 	gxPixelBuffer,x
.c8d4	a8d4	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.c8d6	a8d6					_GXZeroPixel:
.c8d6	a8d6	c8		iny				iny 								; advance pointer
.c8d7	a8d7	d0 05		bne $a8de			bne 	_GXNoShift
.c8d9	a8d9	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.c8db	a8db	20 20 a8	jsr $a820			jsr 	GXDLTCheckWrap				; check for new page.
.c8de	a8de					_GXNoShift:
.c8de	a8de	c6 3b		dec $3b				dec 	gxzTemp2+1 					; do the inner loop gxScale times.
.c8e0	a8e0	d0 d0		bne $a8b2			bne 	_GXROLLoop2
.c8e2	a8e2	e6 3a		inc $3a				inc 	gxzTemp2 					; next pixel.
.c8e4	a8e4	a5 3a		lda $3a				lda 	gxzTemp2
.c8e6	a8e6	cd 66 08	cmp $0866			cmp 	gxSize
.c8e9	a8e9	d0 c2		bne $a8ad			bne 	_GXROLLoop1
.c8eb	a8eb	ee c3 07	inc $07c3			inc 	gxY0
.c8ee	a8ee	60		rts				rts
.0866						gxSize:
>0866								.fill 	1
.0867						gxMask:
>0867								.fill 	1
.0868						gxAcquireVector:
>0868								.fill 	2
.086a						gxScale:
>086a								.fill 	1
.086b						gxUseMode:
>086b								.fill 	1
.c8ef	a8ef					GXFontHandler:
.c8ef	a8ef	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.c8f1	a8f1	4d ce 07	eor $07ce			eor 	gxMode
.c8f4	a8f4	8d 6b 08	sta $086b			sta 	gxUseMode
.c8f7	a8f7	64 37		stz $37				stz 	gxzTemp0+1 					; gxzTemp0 is font #
.c8f9	a8f9	06 36		asl $36				asl	 	gxzTemp0 					; x 2
.c8fb	a8fb	26 37		rol $37				rol	 	gxzTemp0+1
.c8fd	a8fd	06 36		asl $36				asl	 	gxzTemp0 					; x 4
.c8ff	a8ff	26 37		rol $37				rol	 	gxzTemp0+1
.c901	a901	06 36		asl $36				asl	 	gxzTemp0 					; x 8
.c903	a903	26 37		rol $37				rol	 	gxzTemp0+1
.c905	a905	a5 37		lda $37				lda 	gxzTemp0+1 					; put in page C0
.c907	a907	09 c0		ora #$c0			ora 	#$C0
.c909	a909	85 37		sta $37				sta 	gxzTemp0+1
.c90b	a90b	a9 08		lda #$08			lda 	#8 							; size 8x8
.c90d	a90d	a2 15		ldx #$15			ldx 	#GXGetGraphicDataFont & $FF ; XY = Graphic Data retrieval routine
.c90f	a90f	a0 a9		ldy #$a9			ldy 	#GXGetGraphicDataFont >> 8
.c911	a911	20 2d a8	jsr $a82d			jsr 	GXDrawGraphicElement
.c914	a914	60		rts				rts
.c915	a915					GXGetGraphicDataFont:
.c915	a915	8a		txa				txa 								; X->Y
.c916	a916	a8		tay				tay
.c917	a917	a6 01		ldx $01				ldx 	1 							; preserve old value
.c919	a919	a9 01		lda #$01			lda 	#1 							; access page 1 (font memory)
.c91b	a91b	85 01		sta $01				sta 	1
.c91d	a91d	b1 36		lda ($36),y			lda 	(gxzTemp0),y 				; read the font element.
.c91f	a91f	86 01		stx $01				stx 	1 							; put old value back.
.c921	a921	a2 00		ldx #$00			ldx 	#0 							; do 8 times
.c923	a923					_GXExpand:
.c923	a923	9e 23 06	stz $0623,x			stz 	gxPixelBuffer,x 			; zero in pixel buffer
.c926	a926	0a		asl a				asl 	a 							; shift bit 7 into C
.c927	a927	90 08		bcc $a931			bcc 	_GXNoPixel
.c929	a929	48		pha				pha 								; if set, set pixel buffer to current colour.
.c92a	a92a	ad cf 07	lda $07cf			lda 	gxColour
.c92d	a92d	9d 23 06	sta $0623,x			sta 	gxPixelBuffer,x
.c930	a930	68		pla				pla
.c931	a931					_GXNoPixel:
.c931	a931	e8		inx				inx 								; do the whole byte.
.c932	a932	e0 08		cpx #$08			cpx 	#8
.c934	a934	d0 ed		bne $a923			bne 	_GXExpand
.c936	a936	60		rts				rts
.c937	a937					GXSpriteHandler:
.c937	a937	ad c9 07	lda $07c9			lda 	gxSpritesOn 				; sprites on ?
.c93a	a93a	f0 23		beq $a95f			beq 	_GXSHExit
.c93c	a93c	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.c93e	a93e	4d ce 07	eor $07ce			eor 	gxMode
.c941	a941	8d 6b 08	sta $086b			sta 	gxUseMode
.c944	a944	a6 36		ldx $36				ldx 	gxzTemp0 					; sprite #
.c946	a946	da		phx				phx
.c947	a947	20 d7 aa	jsr $aad7			jsr 	GXOpenBitmap 				; can access sprite information
.c94a	a94a	68		pla				pla
.c94b	a94b	20 b8 ab	jsr $abb8			jsr 	GXFindSprite 				; get the sprite address
.c94e	a94e	08		php				php
.c94f	a94f	20 df aa	jsr $aadf			jsr 	GXCloseBitmap
.c952	a952	28		plp				plp
.c953	a953	b0 0a		bcs $a95f			bcs		_GXSHExit 					; exit if find failed.
.c955	a955	ad 6c 08	lda $086c			lda 	gxSizePixels 				; return size
.c958	a958	a2 60		ldx #$60			ldx 	#GXSpriteAcquire & $FF
.c95a	a95a	a0 a9		ldy #$a9			ldy 	#GXSpriteAcquire >> 8
.c95c	a95c	20 2d a8	jsr $a82d			jsr 	GXDrawGraphicElement
.c95f	a95f					_GXSHExit:
.c95f	a95f	60		rts				rts
.c960	a960					GXSpriteAcquire:
.c960	a960	ad cc 07	lda $07cc			lda 	gxSpritePage				; point to base page
.c963	a963	85 0b		sta $0b				sta 	GXEditSlot
.c965	a965	86 36		stx $36				stx 	gxzTemp0 					; row number x 1,2,3,4
.c967	a967	a9 00		lda #$00			lda 	#0
.c969	a969	ae 6d 08	ldx $086d			ldx 	gxSizeBits
.c96c	a96c					_GXTimesRowNumber:
.c96c	a96c	18		clc				clc
.c96d	a96d	65 36		adc $36				adc 	gxzTemp0
.c96f	a96f	ca		dex				dex
.c970	a970	10 fa		bpl $a96c			bpl 	_GXTimesRowNumber
.c972	a972	64 37		stz $37				stz 	gxzTemp0+1
.c974	a974	0a		asl a				asl 	a 							; row x 2,4,6,8
.c975	a975	26 37		rol $37				rol 	gxzTemp0+1
.c977	a977	0a		asl a				asl 	a 							; row x 4,8,12,16
.c978	a978	26 37		rol $37				rol 	gxzTemp0+1
.c97a	a97a	0a		asl a				asl 	a 							; row x 8,16,24,32
.c97b	a97b	26 37		rol $37				rol 	gxzTemp0+1
.c97d	a97d	85 36		sta $36				sta 	gxzTemp0
.c97f	a97f	18		clc				clc 								; add base address.
.c980	a980	a5 36		lda $36				lda 	gxzTemp0
.c982	a982	6d 6f 08	adc $086f			adc 	gxSpriteOffset
.c985	a985	85 36		sta $36				sta 	gxzTemp0
.c987	a987	a5 37		lda $37				lda 	gxzTemp0+1
.c989	a989	6d 70 08	adc $0870			adc 	gxSpriteOffset+1
.c98c	a98c					_GXSAFindPage:
.c98c	a98c	c9 20		cmp #$20			cmp 	#$20 						; on this page
.c98e	a98e	90 06		bcc $a996			bcc 	_GXSAFoundPage
.c990	a990	e9 20		sbc #$20			sbc 	#$20 						; forward one page
.c992	a992	e6 0b		inc $0b				inc 	GXEditSlot
.c994	a994	80 f6		bra $a98c			bra 	_GXSAFindPage
.c996	a996					_GXSAFoundPage:
.c996	a996	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; physical address of page.
.c998	a998	85 37		sta $37				sta 	gxzTemp0+1 					; gxzTemp0 now points to the page
.c99a	a99a	a0 00		ldy #$00			ldy 	#0
.c99c	a99c					_GXSACopyLoop:
.c99c	a99c	b1 36		lda ($36),y			lda 	(gxzTemp0),y
.c99e	a99e	99 23 06	sta $0623,y			sta 	gxPixelBuffer,y
.c9a1	a9a1	c8		iny				iny
.c9a2	a9a2	cc 6c 08	cpy $086c			cpy 	gxSizePixels
.c9a5	a9a5	d0 f5		bne $a99c			bne 	_GXSACopyLoop
.c9a7	a9a7	60		rts				rts
.c9a8	a9a8					GXSelect:
.c9a8	a9a8	ad c9 07	lda $07c9			lda 	gxSpritesOn
.c9ab	a9ab	f0 22		beq $a9cf			beq 	_GXSFail
.c9ad	a9ad	a5 36		lda $36				lda 	gxzTemp0 					; illegal sprite #
.c9af	a9af	c9 40		cmp #$40			cmp 	#64
.c9b1	a9b1	b0 1c		bcs $a9cf			bcs 	_GXSFail
.c9b3	a9b3	8d d4 07	sta $07d4			sta 	GSCurrentSpriteID
.c9b6	a9b6	a4 37		ldy $37				ldy 	gxzTemp0+1 					; control value.
.c9b8	a9b8	a9 00		lda #$00			lda  	#0 							; multiply sprite # x 8 => A
.c9ba	a9ba	06 36		asl $36				asl 	gxzTemp0
.c9bc	a9bc	06 36		asl $36				asl 	gxzTemp0
.c9be	a9be	06 36		asl $36				asl 	gxzTemp0
.c9c0	a9c0	2a		rol a				rol 	a
.c9c1	a9c1	69 d9		adc #$d9			adc 	#$D9 						; sprite area
.c9c3	a9c3	8d d6 07	sta $07d6			sta 	GSCurrentSpriteAddr+1 		; address to GSCurrentSprite and gxzTemp
.c9c6	a9c6	85 37		sta $37				sta 	gxzTemp0+1
.c9c8	a9c8	a5 36		lda $36				lda 	gxzTemp0
.c9ca	a9ca	8d d5 07	sta $07d5			sta 	GSCurrentSpriteAddr
.c9cd	a9cd	18		clc				clc
.c9ce	a9ce	60		rts				rts
.c9cf	a9cf					_GXSFail:
.c9cf	a9cf	38		sec				sec
.c9d0	a9d0	60		rts				rts
.c9d1	a9d1					GXSelectImage:
.c9d1	a9d1	ad c9 07	lda $07c9			lda 	gxSpritesOn
.c9d4	a9d4	f0 74		beq $aa4a			beq 	_GXSIFail
.c9d6	a9d6	ad d6 07	lda $07d6			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.c9d9	a9d9	f0 6f		beq $aa4a			beq 	_GXSIFail 					; (checking the MSB)
.c9db	a9db	64 01		stz $01				stz 	1
.c9dd	a9dd	a5 37		lda $37				lda 	gxzTemp0+1 					; push show/hide on the stack.
.c9df	a9df	d0 6b		bne $aa4c			bne 	_GXSIHide
.c9e1	a9e1	a5 36		lda $36				lda 	gxzTemp0 					; sprite image
.c9e3	a9e3	48		pha				pha
.c9e4	a9e4	20 d7 aa	jsr $aad7			jsr 	GXOpenBitmap
.c9e7	a9e7	68		pla				pla
.c9e8	a9e8	20 b8 ab	jsr $abb8			jsr 	GXFindSprite
.c9eb	a9eb	b0 5a		bcs $aa47			bcs 	_GXSICloseFail 				; no image
.c9ed	a9ed	a0 01		ldy #$01			ldy 	#1
.c9ef	a9ef	ad d5 07	lda $07d5			lda 	GSCurrentSpriteAddr
.c9f2	a9f2	85 36		sta $36				sta 	gxzTemp0
.c9f4	a9f4	ad d6 07	lda $07d6			lda 	GSCurrentSpriteAddr+1
.c9f7	a9f7	85 37		sta $37				sta 	gxzTemp0+1
.c9f9	a9f9	ad 6f 08	lda $086f			lda 	gxSpriteOffset
.c9fc	a9fc	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.c9fe	a9fe	18		clc				clc
.c9ff	a9ff	ad 70 08	lda $0870			lda 	gxSpriteOffset+1
.ca02	aa02	6d d7 07	adc $07d7			adc 	gxSpriteOffsetBase
.ca05	aa05	c8		iny				iny
.ca06	aa06	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.ca08	aa08	ad d8 07	lda $07d8			lda 	gxSpriteOffsetBase+1
.ca0b	aa0b	69 00		adc #$00			adc 	#0
.ca0d	aa0d	c8		iny				iny
.ca0e	aa0e	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.ca10	aa10	ad 6d 08	lda $086d			lda 	gxSizeBits 					; get raw size
.ca13	aa13	49 03		eor #$03			eor 	#3 							; make it right (00=32 etc.)
.ca15	aa15	2a		rol a				rol 	a 							; x 2
.ca16	aa16	0a		asl a				asl 	a 							; x 4
.ca17	aa17	0a		asl a				asl 	a 							; x 8
.ca18	aa18	0a		asl a				asl 	a 							; x 16
.ca19	aa19	0d 6e 08	ora $086e			ora 	gxSpriteLUT 				; Or with LUT
.ca1c	aa1c	0a		asl a				asl 	a 							; 1 shift
.ca1d	aa1d	09 01		ora #$01			ora 	#1 							; enable sprite.
.ca1f	aa1f	92 36		sta ($36)			sta 	(gxzTemp0) 					; and write back
.ca21	aa21	20 df aa	jsr $aadf			jsr 	GXCloseBitmap
.ca24	aa24	ae d4 07	ldx $07d4			ldx 	GSCurrentSpriteID 			; point to sprite entries.
.ca27	aa27	bd 19 08	lda $0819,x			lda 	gxSpriteHigh,x 				; clear upper two bits of size
.ca2a	aa2a	29 3f		and #$3f			and 	#$3F
.ca2c	aa2c	9d 19 08	sta $0819,x			sta 	gxSpriteHigh,x
.ca2f	aa2f	ad 6d 08	lda $086d			lda 	gxSizeBits 					; get bit size
.ca32	aa32	6a		ror a				ror 	a 							; shift into bits 6/7
.ca33	aa33	6a		ror a				ror 	a
.ca34	aa34	6a		ror a				ror 	a
.ca35	aa35	29 c0		and #$c0			and 	#$C0
.ca37	aa37	1d 19 08	ora $0819,x			ora 	gxSpriteHigh,x 				; put in  upper 2 bits of sprite data
.ca3a	aa3a	9d 19 08	sta $0819,x			sta 	gxSpriteHigh,x
.ca3d	aa3d	bd d9 07	lda $07d9,x			lda 	gxSpriteLow,x 				; clear hidden flag.
.ca40	aa40	29 7f		and #$7f			and 	#$7F
.ca42	aa42	9d d9 07	sta $07d9,x			sta 	gxSpriteLow,x
.ca45	aa45	18		clc				clc
.ca46	aa46	60		rts				rts
.ca47	aa47					_GXSICloseFail:
.ca47	aa47	20 df aa	jsr $aadf			jsr 	GXCloseBitmap
.ca4a	aa4a					_GXSIFail:
.ca4a	aa4a	38		sec				sec
.ca4b	aa4b	60		rts				rts
.ca4c	aa4c					_GXSIHide:
.ca4c	aa4c	ad d5 07	lda $07d5			lda 	GSCurrentSpriteAddr  		; get Sprite h/w address and write there
.ca4f	aa4f	85 36		sta $36				sta 	gxzTemp0
.ca51	aa51	ad d6 07	lda $07d6			lda 	GSCurrentSpriteAddr+1
.ca54	aa54	85 37		sta $37				sta 	gxzTemp0+1
.ca56	aa56	a9 00		lda #$00			lda 	#0
.ca58	aa58	92 36		sta ($36)			sta 	(gxzTemp0)
.ca5a	aa5a	ae d4 07	ldx $07d4			ldx 	GSCurrentSpriteID 			; get sprite ID
.ca5d	aa5d	bd d9 07	lda $07d9,x			lda 	gxSpriteLow,x 				; set the hidden bit.
.ca60	aa60	09 80		ora #$80			ora 	#$80
.ca62	aa62	9d d9 07	sta $07d9,x			sta 	gxSpriteLow,x
.ca65	aa65	18		clc				clc
.ca66	aa66	60		rts				rts
.ca67	aa67					GXMoveSprite:
.ca67	aa67	ad c9 07	lda $07c9			lda 	gxSpritesOn
.ca6a	aa6a	f0 65		beq $aad1			beq 	_GXSIFail
.ca6c	aa6c	ad d6 07	lda $07d6			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.ca6f	aa6f	f0 60		beq $aad1			beq 	_GXSIFail
.ca71	aa71	85 37		sta $37				sta 	gxzTemp0+1
.ca73	aa73	a0 04		ldy #$04			ldy 	#4
.ca75	aa75	ad d5 07	lda $07d5			lda 	GSCurrentSpriteAddr
.ca78	aa78	85 36		sta $36				sta 	gxzTemp0
.ca7a	aa7a	ae d4 07	ldx $07d4			ldx 	GSCurrentSpriteID 			; get the size from the upper two bits
.ca7d	aa7d	bd 19 08	lda $0819,x			lda 	gxSpriteHigh,x
.ca80	aa80	2a		rol a				rol 	a	 						; into bits 0,1.
.ca81	aa81	2a		rol a				rol 	a
.ca82	aa82	2a		rol a				rol 	a
.ca83	aa83	29 03		and #$03			and 	#3
.ca85	aa85	aa		tax				tax
.ca86	aa86	bd d3 aa	lda $aad3,x			lda 	_GXMSOffset,x 				; get 32-SpriteSize/2
.ca89	aa89	48		pha				pha
.ca8a	aa8a	18		clc				clc
.ca8b	aa8b	6d c1 07	adc $07c1			adc 	gxX0						; copy position.
.ca8e	aa8e	91 36		sta ($36),y			sta 	(gxzTemp0),y
.ca90	aa90	c8		iny				iny
.ca91	aa91	ad c2 07	lda $07c2			lda 	gxX0+1
.ca94	aa94	69 00		adc #$00			adc 	#0
.ca96	aa96	91 36		sta ($36),y			sta 	(gxzTemp0),y
.ca98	aa98	c8		iny				iny
.ca99	aa99	68		pla				pla
.ca9a	aa9a	18		clc				clc
.ca9b	aa9b	6d c3 07	adc $07c3			adc 	gxY0
.ca9e	aa9e	91 36		sta ($36),y			sta 	(gxzTemp0),y
.caa0	aaa0	a9 00		lda #$00			lda 	#0
.caa2	aaa2	69 00		adc #$00			adc 	#0
.caa4	aaa4	c8		iny				iny
.caa5	aaa5	91 36		sta ($36),y			sta 	(gxzTemp0),y
.caa7	aaa7	4e c2 07	lsr $07c2			lsr 	gxX0+1 						; divide X by 4
.caaa	aaaa	6e c1 07	ror $07c1			ror 	gxX0
.caad	aaad	4e c1 07	lsr $07c1			lsr 	gxX0
.cab0	aab0	4e c3 07	lsr $07c3			lsr 	gxY0 						; divide Y by 4
.cab3	aab3	4e c3 07	lsr $07c3			lsr 	gxY0
.cab6	aab6	ae d4 07	ldx $07d4			ldx 	GSCurrentSpriteID 			; copy X/4 and Y/4 into the status bytes
.cab9	aab9	bd d9 07	lda $07d9,x			lda 	gxSpriteLow,x
.cabc	aabc	29 80		and #$80			and 	#$80
.cabe	aabe	0d c1 07	ora $07c1			ora 	gxX0
.cac1	aac1	9d d9 07	sta $07d9,x			sta 	gxSpriteLow,x
.cac4	aac4	bd 19 08	lda $0819,x			lda 	gxSpriteHigh,x
.cac7	aac7	29 c0		and #$c0			and 	#$C0
.cac9	aac9	0d c3 07	ora $07c3			ora 	gxY0
.cacc	aacc	9d 19 08	sta $0819,x			sta 	gxSpriteHigh,x
.cacf	aacf	18		clc				clc
.cad0	aad0	60		rts				rts
.cad1	aad1					_GXSIFail:
.cad1	aad1	38		sec				sec
.cad2	aad2	60		rts				rts
.cad3	aad3					_GXMSOffset:
>cad3	aad3	1c						.byte 	32-8/2
>cad4	aad4	18						.byte 	32-16/2
>cad5	aad5	14						.byte 	32-24/2
>cad6	aad6	10						.byte 	32-32/2
.cad7	aad7					GXOpenBitmap:
.cad7	aad7	78		sei				sei 								; no interrupts here
.cad8	aad8	a5 0b		lda $0b				lda 	GXEditSlot 					; Save the original LUT slot value
.cada	aada	8d d2 07	sta $07d2			sta 	gxOriginalLUTValue
.cadd	aadd	58		cli				cli
.cade	aade	60		rts				rts
.cadf	aadf					GXCloseBitmap:
.cadf	aadf	78		sei				sei
.cae0	aae0	ad d2 07	lda $07d2			lda 	gxOriginalLUTValue 			; restore LUT slot value
.cae3	aae3	85 0b		sta $0b				sta 	GXEditSlot
.cae5	aae5	58		cli				cli
.cae6	aae6	60		rts				rts
.cae7	aae7					gxPositionCalc:
.cae7	aae7	a5 36		lda $36				lda 	gxzTemp0 					; save temp memory slot
.cae9	aae9	48		pha				pha
.caea	aaea	ad c3 07	lda $07c3			lda 	gxY0 						; gxzScreen = Y0
.caed	aaed	85 3c		sta $3c				sta 	gxzScreen
.caef	aaef	64 3d		stz $3d				stz 	gxzScreen+1
.caf1	aaf1	06 3c		asl $3c				asl 	gxzScreen 						; gxzScreen = Y0 * 4
.caf3	aaf3	26 3d		rol $3d				rol 	gxzScreen+1
.caf5	aaf5	06 3c		asl $3c				asl 	gxzScreen
.caf7	aaf7	26 3d		rol $3d				rol 	gxzScreen+1
.caf9	aaf9	18		clc				clc 								; gxzScreen = Y0 * 5, as it's still in A
.cafa	aafa	65 3c		adc $3c				adc 	gxzScreen
.cafc	aafc	85 3c		sta $3c				sta 	gxzScreen
.cafe	aafe	90 02		bcc $ab02			bcc 	_GXPCNoCarry
.cb00	ab00	e6 3d		inc $3d				inc 	gxzScreen+1
.cb02	ab02					_GXPCNoCarry:
.cb02	ab02	06 3c		asl $3c				asl 	gxzScreen 						; now Y0 * 10. Needs to be multiplied by another
.cb04	ab04	26 3d		rol $3d				rol 	gxzScreen+1 					; 32. At this point the MSB contains the offset
.cb06	ab06	a5 3d		lda $3d				lda	 	gxzScreen+1 					; so save this in zTemp0 and zero it.
.cb08	ab08	85 36		sta $36				sta 	gxzTemp0
.cb0a	ab0a	64 3d		stz $3d				stz 	gxzScreen+1
.cb0c	ab0c	a9 05		lda #$05			lda 	#5 							; now multiply by 32, this puts this in the range 0..8191
.cb0e	ab0e					_GXPCMultiply32:
.cb0e	ab0e	06 3c		asl $3c				asl 	gxzScreen
.cb10	ab10	26 3d		rol $3d				rol 	gxzScreen+1
.cb12	ab12	3a		dec a				dec 	a
.cb13	ab13	d0 f9		bne $ab0e			bne 	_GXPCMultiply32
.cb15	ab15	18		clc				clc
.cb16	ab16	ad c1 07	lda $07c1			lda 	gxX0 						; add X to this value, put the result in gxOffset, gxzScreen has to be on a page boundary
.cb19	ab19	65 3c		adc $3c				adc 	gxzScreen
.cb1b	ab1b	8d d3 07	sta $07d3			sta 	gxOffset
.cb1e	ab1e	ad c2 07	lda $07c2			lda 	gxX0+1
.cb21	ab21	65 3d		adc $3d				adc 	gxzScreen+1
.cb23	ab23	c9 20		cmp #$20			cmp 	#$20 						; has it overflowed into the next one ?
.cb25	ab25	90 04		bcc $ab2b			bcc 	_GXPCNoOverflow
.cb27	ab27	29 1f		and #$1f			and 	#$1F 						; fix it up
.cb29	ab29	e6 36		inc $36				inc 	gxzTemp0 					; add 1 to the page number
.cb2b	ab2b					_GXPCNoOverflow:
.cb2b	ab2b	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; make it the address mapped in.
.cb2d	ab2d	85 3d		sta $3d				sta 	gxzScreen+1
.cb2f	ab2f	64 3c		stz $3c				stz 	gxzScreen
.cb31	ab31	18		clc				clc
.cb32	ab32	a5 36		lda $36				lda 	gxzTemp0 					; get the page number
.cb34	ab34	6d cb 07	adc $07cb			adc 	gxBasePage 					; by adding the base page
.cb37	ab37	85 0b		sta $0b				sta 	GXEditSlot 				; and map it into memory.
.cb39	ab39	68		pla				pla
.cb3a	ab3a	85 36		sta $36				sta 	gxzTemp0
.cb3c	ab3c	60		rts				rts
.cb3d	ab3d					GXMovePositionDown:
.cb3d	ab3d	18		clc				clc 								; add 320 to offset/temp+1
.cb3e	ab3e	ad d3 07	lda $07d3			lda 	gxOffset
.cb41	ab41	69 40		adc #$40			adc 	#64
.cb43	ab43	8d d3 07	sta $07d3			sta 	gxOffset
.cb46	ab46	a5 3d		lda $3d				lda 	gxzScreen+1
.cb48	ab48	69 01		adc #$01			adc 	#1
.cb4a	ab4a	85 3d		sta $3d				sta 	gxzScreen+1
.cb4c	ab4c	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page
.cb4e	ab4e	90 07		bcc $ab57			bcc 	_GXMPDExit
.cb50	ab50	38		sec				sec  								; next page
.cb51	ab51	e9 20		sbc #$20			sbc 	#$20
.cb53	ab53	85 3d		sta $3d				sta 	gxzScreen+1
.cb55	ab55	e6 0b		inc $0b				inc 	GXEditSlot
.cb57	ab57					_GXMPDExit:
.cb57	ab57	60		rts				rts
.cb58	ab58					GXCollide:
.cb58	ab58	a5 36		lda $36				lda 	gxzTemp0 					; check if sprite numbers are legal.
.cb5a	ab5a	aa		tax				tax
.cb5b	ab5b	05 37		ora $37				ora 	gxzTemp0+1
.cb5d	ab5d	29 c0		and #$c0			and 	#$C0
.cb5f	ab5f	38		sec				sec
.cb60	ab60	d0 53		bne $abb5			bne 	_GXCollideFail 				; if either >= 64, fail.
.cb62	ab62	a4 37		ldy $37				ldy 	gxzTemp0+1 					; at this point X is 1st sprite and Y is 2nd sprite.
.cb64	ab64	b9 d9 07	lda $07d9,y			lda 	gxSpriteLow,y 				; check if either hidden bit is set
.cb67	ab67	1d d9 07	ora $07d9,x			ora 	gxSpriteLow,x
.cb6a	ab6a	30 48		bmi $abb4			bmi 	_GXOkayFail 				; if either hidden, then they cannot collide.
.cb6c	ab6c	18		clc				clc 								; need to calculate sum of sizes.
.cb6d	ab6d	b9 19 08	lda $0819,y			lda 	gxSpriteHigh,y
.cb70	ab70	7d 19 08	adc $0819,x			adc 	gxSpriteHigh,x 				; at this point, CS, Bit 6 and 7 contain that sum.
.cb73	ab73	29 c0		and #$c0			and 	#$C0 					 	; mask off
.cb75	ab75	6a		ror a				ror 	a 							; 5/6/7
.cb76	ab76	4a		lsr a				lsr 	a 							; 4/5/6
.cb77	ab77	4a		lsr a				lsr 	a 							; 3/4/5
.cb78	ab78	4a		lsr a				lsr 	a 							; 2/3/4
.cb79	ab79	18		clc				clc
.cb7a	ab7a	69 08		adc #$08			adc 	#$08
.cb7c	ab7c	4a		lsr a				lsr 	a 							; adjust because all coordinates are divided by 4 to store.
.cb7d	ab7d	4a		lsr a				lsr 	a
.cb7e	ab7e	85 38		sta $38				sta 	gxzTemp1 					; so the difference between the centres has to be less than this.
.cb80	ab80	b9 19 08	lda $0819,y			lda 	gxSpriteHigh,y 				; calculate y1-y0
.cb83	ab83	29 3f		and #$3f			and 	#$3F
.cb85	ab85	85 39		sta $39				sta 	gxzTemp1+1
.cb87	ab87	38		sec				sec
.cb88	ab88	bd 19 08	lda $0819,x			lda 	gxSpriteHigh,x
.cb8b	ab8b	29 3f		and #$3f			and 	#$3F
.cb8d	ab8d	e5 39		sbc $39				sbc 	gxzTemp1+1
.cb8f	ab8f	b0 03		bcs $ab94			bcs 	_GXCAbs1 					; calculate |y1-y0|
.cb91	ab91	49 ff		eor #$ff			eor 	#$FF
.cb93	ab93	1a		inc a				inc 	a
.cb94	ab94					_GXCAbs1:
.cb94	ab94	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.cb96	ab96	b0 1c		bcs $abb4			bcs 	_GXOkayFail
.cb98	ab98	85 39		sta $39				sta 	gxzTemp1+1 					; save |y1-y0|
.cb9a	ab9a	38		sec				sec 								; calculate |x1-x0|
.cb9b	ab9b	b9 d9 07	lda $07d9,y			lda 	gxSpriteLow,y
.cb9e	ab9e	fd d9 07	sbc $07d9,x			sbc 	gxSpriteLow,x
.cba1	aba1	b0 03		bcs $aba6			bcs 	_GXCAbs2
.cba3	aba3	49 ff		eor #$ff			eor 	#$FF
.cba5	aba5	1a		inc a				inc 	a
.cba6	aba6					_GXCAbs2:
.cba6	aba6	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.cba8	aba8	b0 0a		bcs $abb4			bcs 	_GXOkayFail
.cbaa	abaa	c5 39		cmp $39				cmp 	gxzTemp1+1 					; is it less than the previous one.
.cbac	abac	90 02		bcc $abb0			bcc 	_GXCHaveLowest
.cbae	abae	a5 39		lda $39				lda 	gxzTemp1+1 					; if not, that's the smallest difference.
.cbb0	abb0					_GXCHaveLowest:
.cbb0	abb0	0a		asl a				asl 	a 							; scale to allow for >> 2
.cbb1	abb1	0a		asl a				asl 	a
.cbb2	abb2	18		clc				clc
.cbb3	abb3	60		rts				rts
.cbb4	abb4					_GXOkayFail:
.cbb4	abb4	18		clc				clc
.cbb5	abb5					_GXCollideFail:
.cbb5	abb5	a9 ff		lda #$ff			lda 	#$FF
.cbb7	abb7	60		rts				rts
.cbb8	abb8					GXFindSprite:
.cbb8	abb8	aa		tax				tax
.cbb9	abb9	ad cc 07	lda $07cc			lda 	gxSpritePage 				; access the base page of the sprite
.cbbc	abbc	85 0b		sta $0b				sta 	GXEditSlot
.cbbe	abbe	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; check a valid sprite
.cbc1	abc1	1d 00 60	ora $6000,x			ora 	GXMappingAddress,x
.cbc4	abc4	f0 33		beq $abf9			beq 	_GXFSFail
.cbc6	abc6	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; MSB
.cbc9	abc9	8d 70 08	sta $0870			sta 	gxSpriteOffset+1
.cbcc	abcc	bd 00 60	lda $6000,x			lda 	GXMappingAddress,x 			; LSB
.cbcf	abcf	48		pha				pha 								; save twice
.cbd0	abd0	48		pha				pha
.cbd1	abd1	29 03		and #$03			and 	#3 							; get sprite size
.cbd3	abd3	8d 6d 08	sta $086d			sta 	gxSizeBits 					; save raw (0-3)
.cbd6	abd6	aa		tax				tax
.cbd7	abd7	bd fb ab	lda $abfb,x			lda 	_GXFXSSTTable,x 			; read sprite size
.cbda	abda	8d 6c 08	sta $086c			sta 	gxSizePixels 					; save (8/16/24/32)
.cbdd	abdd	68		pla				pla 								; get LUT
.cbde	abde	4a		lsr a				lsr		a
.cbdf	abdf	4a		lsr a				lsr		a
.cbe0	abe0	29 03		and #$03			and 	#3
.cbe2	abe2	8d 6e 08	sta $086e			sta 	gxSpriteLUT
.cbe5	abe5	68		pla				pla 								; address, neeeds to be x 4
.cbe6	abe6	29 f0		and #$f0			and 	#$F0
.cbe8	abe8	8d 6f 08	sta $086f			sta 	gxSpriteOffset
.cbeb	abeb	0e 6f 08	asl $086f			asl 	gxSpriteOffset
.cbee	abee	2e 70 08	rol $0870			rol 	gxSpriteOffset+1
.cbf1	abf1	0e 6f 08	asl $086f			asl 	gxSpriteOffset
.cbf4	abf4	2e 70 08	rol $0870			rol 	gxSpriteOffset+1
.cbf7	abf7	18		clc				clc
.cbf8	abf8	60		rts				rts
.cbf9	abf9					_GXFSFail:
.cbf9	abf9	38		sec				sec
.cbfa	abfa	60		rts				rts
.cbfb	abfb					_GXFXSSTTable:
>cbfb	abfb	08 10 18 20					.byte 	8,16,24,32
.086c						gxSizePixels:
>086c								.fill 	1
.086d						gxSizeBits:
>086d								.fill 	1
.086e						gxSpriteLUT:
>086e								.fill 	1
.086f						gxSpriteOffset:
>086f								.fill 	2
.cbff	abff					GXSortXY:
.cbff	abff	20 1d ac	jsr $ac1d			jsr 	GXSortY 					; will be sorted on Y now
.cc02	ac02	ad c1 07	lda $07c1			lda 	gxX0 						; compare X0 v X1
.cc05	ac05	cd c5 07	cmp $07c5			cmp 	gxX1
.cc08	ac08	ad c2 07	lda $07c2			lda 	gxX0+1
.cc0b	ac0b	ed c6 07	sbc $07c6			sbc 	gxX1+1
.cc0e	ac0e	90 0c		bcc $ac1c			bcc 	_GXSXYExit 					; X0 < X1 exit
.cc10	ac10	a2 00		ldx #$00			ldx 	#0 							; swap them over
.cc12	ac12	a0 04		ldy #$04			ldy 	#4
.cc14	ac14	20 31 ac	jsr $ac31			jsr 	GXSwapXY
.cc17	ac17	e8		inx				inx
.cc18	ac18	c8		iny				iny
.cc19	ac19	20 31 ac	jsr $ac31			jsr 	GXSwapXY
.cc1c	ac1c					_GXSXYExit:
.cc1c	ac1c	60		rts				rts
.cc1d	ac1d					GXSortY:
.cc1d	ac1d	ad c3 07	lda $07c3			lda 	gxY0 						; if Y0 >= Y1
.cc20	ac20	cd c7 07	cmp $07c7			cmp 	gxY1
.cc23	ac23	90 0b		bcc $ac30			bcc 	_GXSYSorted
.cc25	ac25	a2 03		ldx #$03			ldx 	#3 							; swap 3-0
.cc27	ac27	a0 07		ldy #$07			ldy 	#7 							; with 4-7
.cc29	ac29					_GXSwap1:
.cc29	ac29	20 31 ac	jsr $ac31			jsr 	GXSwapXY
.cc2c	ac2c	88		dey				dey
.cc2d	ac2d	ca		dex				dex
.cc2e	ac2e	10 f9		bpl $ac29			bpl 	_GXSwap1
.cc30	ac30					_GXSYSorted:
.cc30	ac30	60		rts				rts
.cc31	ac31					GXSwapXY:
.cc31	ac31	bd c1 07	lda $07c1,x			lda 	gxX0,x
.cc34	ac34	48		pha				pha
.cc35	ac35	b9 c1 07	lda $07c1,y			lda 	gxX0,y
.cc38	ac38	9d c1 07	sta $07c1,x			sta 	gxX0,x
.cc3b	ac3b	68		pla				pla
.cc3c	ac3c	99 c1 07	sta $07c1,y			sta 	gxX0,y
.cc3f	ac3f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_tokeniser.module

=1						tokeniserIntegrated=1
.cc40	ac40					KeywordSet0:
>cc40	ac40	00 65					.text	0,$65,""               ; $80 !0:EOF
>cc42	ac42	00 58					.text	0,$58,""               ; $81 !1:SH1
>cc44	ac44	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>cc46	ac46	04 fe 41 42 53 28			.text	4,$fe,"ABS("           ; $83 ABS(
>cc4c	ac4c	06 93 41 4c 4c 4f 43 28			.text	6,$93,"ALLOC("         ; $84 ALLOC(
>cc54	ac54	04 ff 41 53 43 28			.text	4,$ff,"ASC("           ; $85 ASC(
>cc5a	ac5a	05 29 43 48 52 24 28			.text	5,$29,"CHR$("          ; $86 CHR$(
>cc61	ac61	06 aa 45 56 45 4e 54 28			.text	6,$aa,"EVENT("         ; $87 EVENT(
>cc69	ac69	05 6b 46 41 4c 53 45			.text	5,$6b,"FALSE"          ; $88 FALSE
>cc70	ac70	05 44 46 52 41 43 28			.text	5,$44,"FRAC("          ; $89 FRAC(
>cc77	ac77	05 2c 47 45 54 24 28			.text	5,$2c,"GET$("          ; $8a GET$(
>cc7e	ac7e	04 08 47 45 54 28			.text	4,$08,"GET("           ; $8b GET(
>cc84	ac84	09 4a 47 45 54 44 41 54			.text	9,$4a,"GETDATE$("      ; $8c GETDATE$(
>cc8c	ac8c	45 24 28
>cc8f	ac8f	09 5b 47 45 54 54 49 4d			.text	9,$5b,"GETTIME$("      ; $8d GETTIME$(
>cc97	ac97	45 24 28
>cc9a	ac9a	04 0d 48 49 54 28			.text	4,$0d,"HIT("           ; $8e HIT(
>cca0	aca0	07 cc 49 4e 4b 45 59 24			.text	7,$cc,"INKEY$("        ; $8f INKEY$(
>cca8	aca8	28
>cca9	aca9	06 a8 49 4e 4b 45 59 28			.text	6,$a8,"INKEY("         ; $90 INKEY(
>ccb1	acb1	04 13 49 4e 54 28			.text	4,$13,"INT("           ; $91 INT(
>ccb7	acb7	06 a7 49 53 56 41 4c 28			.text	6,$a7,"ISVAL("         ; $92 ISVAL(
>ccbf	acbf	0a e0 49 54 45 4d 43 4f			.text	10,$e0,"ITEMCOUNT("     ; $93 ITEMCOUNT(
>ccc7	acc7	55 4e 54 28
>cccb	accb	09 5b 49 54 45 4d 47 45			.text	9,$5b,"ITEMGET$("      ; $94 ITEMGET$(
>ccd3	acd3	54 24 28
>ccd6	acd6	05 5c 4a 4f 59 42 28			.text	5,$5c,"JOYB("          ; $95 JOYB(
>ccdd	acdd	05 72 4a 4f 59 58 28			.text	5,$72,"JOYX("          ; $96 JOYX(
>cce4	ace4	05 73 4a 4f 59 59 28			.text	5,$73,"JOYY("          ; $97 JOYY(
>cceb	aceb	08 49 4b 45 59 44 4f 57			.text	8,$49,"KEYDOWN("       ; $98 KEYDOWN(
>ccf3	acf3	4e 28
>ccf5	acf5	06 77 4c 45 46 54 24 28			.text	6,$77,"LEFT$("         ; $99 LEFT$(
>ccfd	acfd	04 07 4c 45 4e 28			.text	4,$07,"LEN("           ; $9a LEN(
>cd03	ad03	04 0e 4d 41 58 28			.text	4,$0e,"MAX("           ; $9b MAX(
>cd09	ad09	05 26 4d 49 44 24 28			.text	5,$26,"MID$("          ; $9c MID$(
>cd10	ad10	04 0c 4d 49 4e 28			.text	4,$0c,"MIN("           ; $9d MIN(
>cd16	ad16	04 19 4e 4f 54 28			.text	4,$19,"NOT("           ; $9e NOT(
>cd1c	ad1c	05 4d 50 45 45 4b 28			.text	5,$4d,"PEEK("          ; $9f PEEK(
>cd23	ad23	06 91 50 45 45 4b 44 28			.text	6,$91,"PEEKD("         ; $a0 PEEKD(
>cd2b	ad2b	06 99 50 45 45 4b 4c 28			.text	6,$99,"PEEKL("         ; $a1 PEEKL(
>cd33	ad33	06 a4 50 45 45 4b 57 28			.text	6,$a4,"PEEKW("         ; $a2 PEEKW(
>cd3b	ad3b	08 3c 50 4c 41 59 49 4e			.text	8,$3c,"PLAYING("       ; $a3 PLAYING(
>cd43	ad43	47 28
>cd45	ad45	07 e9 52 41 4e 44 4f 4d			.text	7,$e9,"RANDOM("        ; $a4 RANDOM(
>cd4d	ad4d	28
>cd4e	ad4e	07 ca 52 49 47 48 54 24			.text	7,$ca,"RIGHT$("        ; $a5 RIGHT$(
>cd56	ad56	28
>cd57	ad57	04 0c 52 4e 44 28			.text	4,$0c,"RND("           ; $a6 RND(
>cd5d	ad5d	04 10 53 47 4e 28			.text	4,$10,"SGN("           ; $a7 SGN(
>cd63	ad63	04 0e 53 50 43 28			.text	4,$0e,"SPC("           ; $a8 SPC(
>cd69	ad69	05 45 53 54 52 24 28			.text	5,$45,"STR$("          ; $a9 STR$(
>cd70	ad70	06 a9 54 49 4d 45 52 28			.text	6,$a9,"TIMER("         ; $aa TIMER(
>cd78	ad78	04 40 54 52 55 45			.text	4,$40,"TRUE"           ; $ab TRUE
>cd7e	ad7e	04 0b 56 41 4c 28			.text	4,$0b,"VAL("           ; $ac VAL(
>cd84	ad84	03 e7 46 4f 52				.text	3,$e7,"FOR"            ; $ad FOR
>cd89	ad89	02 8f 49 46				.text	2,$8f,"IF"             ; $ae IF
>cd8d	ad8d	04 34 50 52 4f 43			.text	4,$34,"PROC"           ; $af PROC
>cd93	ad93	06 c1 52 45 50 45 41 54			.text	6,$c1,"REPEAT"         ; $b0 REPEAT
>cd9b	ad9b	05 79 57 48 49 4c 45			.text	5,$79,"WHILE"          ; $b1 WHILE
>cda2	ada2	05 66 45 4e 44 49 46			.text	5,$66,"ENDIF"          ; $b2 ENDIF
>cda9	ada9	07 0b 45 4e 44 50 52 4f			.text	7,$0b,"ENDPROC"        ; $b3 ENDPROC
>cdb1	adb1	43
>cdb2	adb2	04 3f 4e 45 58 54			.text	4,$3f,"NEXT"           ; $b4 NEXT
>cdb8	adb8	04 2f 54 48 45 4e			.text	4,$2f,"THEN"           ; $b5 THEN
>cdbe	adbe	05 8c 55 4e 54 49 4c			.text	5,$8c,"UNTIL"          ; $b6 UNTIL
>cdc5	adc5	04 2e 57 45 4e 44			.text	4,$2e,"WEND"           ; $b7 WEND
>cdcb	adcb	02 95 41 54				.text	2,$95,"AT"             ; $b8 AT
>cdcf	adcf	02 9b 42 59				.text	2,$9b,"BY"             ; $b9 BY
>cdd3	add3	04 1c 43 41 4c 4c			.text	4,$1c,"CALL"           ; $ba CALL
>cdd9	add9	06 b2 43 49 52 43 4c 45			.text	6,$b2,"CIRCLE"         ; $bb CIRCLE
>cde1	ade1	05 67 43 4c 45 41 52			.text	5,$67,"CLEAR"          ; $bc CLEAR
>cde8	ade8	05 7f 43 4f 4c 4f 52			.text	5,$7f,"COLOR"          ; $bd COLOR
>cdef	adef	06 d4 43 4f 4c 4f 55 52			.text	6,$d4,"COLOUR"         ; $be COLOUR
>cdf7	adf7	04 1a 44 41 54 41			.text	4,$1a,"DATA"           ; $bf DATA
>cdfd	adfd	03 da 44 49 4d				.text	3,$da,"DIM"            ; $c0 DIM
>ce02	ae02	06 db 44 4f 57 4e 54 4f			.text	6,$db,"DOWNTO"         ; $c1 DOWNTO
>ce0a	ae0a	04 29 45 4c 53 45			.text	4,$29,"ELSE"           ; $c2 ELSE
>ce10	ae10	04 34 46 52 4f 4d			.text	4,$34,"FROM"           ; $c3 FROM
>ce16	ae16	03 e5 47 46 58				.text	3,$e5,"GFX"            ; $c4 GFX
>ce1b	ae1b	04 24 48 45 52 45			.text	4,$24,"HERE"           ; $c5 HERE
>ce21	ae21	05 63 49 4d 41 47 45			.text	5,$63,"IMAGE"          ; $c6 IMAGE
>ce28	ae28	03 e5 4c 45 54				.text	3,$e5,"LET"            ; $c7 LET
>ce2d	ae2d	04 28 4c 49 4e 45			.text	4,$28,"LINE"           ; $c8 LINE
>ce33	ae33	05 6b 4c 4f 43 41 4c			.text	5,$6b,"LOCAL"          ; $c9 LOCAL
>ce3a	ae3a	07 1a 4d 45 4d 43 4f 50			.text	7,$1a,"MEMCOPY"        ; $ca MEMCOPY
>ce42	ae42	59
>ce43	ae43	03 db 4f 46 46				.text	3,$db,"OFF"            ; $cb OFF
>ce48	ae48	02 9d 4f 4e				.text	2,$9d,"ON"             ; $cc ON
>ce4c	ae4c	07 20 4f 55 54 4c 49 4e			.text	7,$20,"OUTLINE"        ; $cd OUTLINE
>ce54	ae54	45
>ce55	ae55	07 0f 50 41 4c 45 54 54			.text	7,$0f,"PALETTE"        ; $ce PALETTE
>ce5d	ae5d	45
>ce5e	ae5e	04 3f 50 4c 4f 54			.text	4,$3f,"PLOT"           ; $cf PLOT
>ce64	ae64	04 2f 50 4f 4b 45			.text	4,$2f,"POKE"           ; $d0 POKE
>ce6a	ae6a	05 73 50 4f 4b 45 44			.text	5,$73,"POKED"          ; $d1 POKED
>ce71	ae71	05 7b 50 4f 4b 45 4c			.text	5,$7b,"POKEL"          ; $d2 POKEL
>ce78	ae78	05 86 50 4f 4b 45 57			.text	5,$86,"POKEW"          ; $d3 POKEW
>ce7f	ae7f	04 1c 52 45 41 44			.text	4,$1c,"READ"           ; $d4 READ
>ce85	ae85	04 2e 52 45 43 54			.text	4,$2e,"RECT"           ; $d5 RECT
>ce8b	ae8b	03 e4 52 45 4d				.text	3,$e4,"REM"            ; $d6 REM
>ce90	ae90	05 7b 53 4f 4c 49 44			.text	5,$7b,"SOLID"          ; $d7 SOLID
>ce97	ae97	05 89 53 4f 55 4e 44			.text	5,$89,"SOUND"          ; $d8 SOUND
>ce9e	ae9e	06 d7 53 50 52 49 54 45			.text	6,$d7,"SPRITE"         ; $d9 SPRITE
>cea6	aea6	04 45 54 45 58 54			.text	4,$45,"TEXT"           ; $da TEXT
>ceac	aeac	02 a3 54 4f				.text	2,$a3,"TO"             ; $db TO
>ceb0	aeb0	ff					.text	$FF
.ceb1	aeb1					KeywordSet1:
>ceb1	aeb1	00 65					.text	0,$65,""               ; $80 !0:EOF
>ceb3	aeb3	00 58					.text	0,$58,""               ; $81 !1:SH1
>ceb5	aeb5	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>ceb7	aeb7	08 4c 41 53 53 45 4d 42			.text	8,$4c,"ASSEMBLE"       ; $83 ASSEMBLE
>cebf	aebf	4c 45
>cec1	aec1	06 d2 41 53 53 45 52 54			.text	6,$d2,"ASSERT"         ; $84 ASSERT
>cec9	aec9	06 bd 42 49 54 4d 41 50			.text	6,$bd,"BITMAP"         ; $85 BITMAP
>ced1	aed1	05 62 42 4c 4f 41 44			.text	5,$62,"BLOAD"          ; $86 BLOAD
>ced8	aed8	05 71 42 53 41 56 45			.text	5,$71,"BSAVE"          ; $87 BSAVE
>cedf	aedf	03 e2 43 4c 53				.text	3,$e2,"CLS"            ; $88 CLS
>cee4	aee4	06 d0 43 50 52 49 4e 54			.text	6,$d0,"CPRINT"         ; $89 CPRINT
>ceec	aeec	03 df 44 49 52				.text	3,$df,"DIR"            ; $8a DIR
>cef1	aef1	03 e6 44 4f 53				.text	3,$e6,"DOS"            ; $8b DOS
>cef6	aef6	05 7a 44 52 49 56 45			.text	5,$7a,"DRIVE"          ; $8c DRIVE
>cefd	aefd	03 d7 45 4e 44				.text	3,$d7,"END"            ; $8d END
>cf02	af02	07 11 45 58 50 4c 4f 44			.text	7,$11,"EXPLODE"        ; $8e EXPLODE
>cf0a	af0a	45
>cf0b	af0b	02 96 47 4f				.text	2,$96,"GO"             ; $8f GO
>cf0f	af0f	05 80 47 4f 53 55 42			.text	5,$80,"GOSUB"          ; $90 GOSUB
>cf16	af16	04 39 47 4f 54 4f			.text	4,$39,"GOTO"           ; $91 GOTO
>cf1c	af1c	05 70 48 49 4d 45 4d			.text	5,$70,"HIMEM"          ; $92 HIMEM
>cf23	af23	05 90 49 4e 50 55 54			.text	5,$90,"INPUT"          ; $93 INPUT
>cf2a	af2a	04 3c 4c 49 53 54			.text	4,$3c,"LIST"           ; $94 LIST
>cf30	af30	04 20 4c 4f 41 44			.text	4,$20,"LOAD"           ; $95 LOAD
>cf36	af36	05 89 4d 4f 55 53 45			.text	5,$89,"MOUSE"          ; $96 MOUSE
>cf3d	af3d	03 ea 4e 45 57				.text	3,$ea,"NEW"            ; $97 NEW
>cf42	af42	04 2e 50 49 4e 47			.text	4,$2e,"PING"           ; $98 PING
>cf48	af48	05 8d 50 52 49 4e 54			.text	5,$8d,"PRINT"          ; $99 PRINT
>cf4f	af4f	07 24 52 45 53 54 4f 52			.text	7,$24,"RESTORE"        ; $9a RESTORE
>cf57	af57	45
>cf58	af58	06 e0 52 45 54 55 52 4e			.text	6,$e0,"RETURN"         ; $9b RETURN
>cf60	af60	03 f5 52 55 4e				.text	3,$f5,"RUN"            ; $9c RUN
>cf65	af65	04 2f 53 41 56 45			.text	4,$2f,"SAVE"           ; $9d SAVE
>cf6b	af6b	07 0a 53 45 54 44 41 54			.text	7,$0a,"SETDATE"        ; $9e SETDATE
>cf73	af73	45
>cf74	af74	07 1b 53 45 54 54 49 4d			.text	7,$1b,"SETTIME"        ; $9f SETTIME
>cf7c	af7c	45
>cf7d	af7d	05 8d 53 48 4f 4f 54			.text	5,$8d,"SHOOT"          ; $a0 SHOOT
>cf84	af84	07 2a 53 50 52 49 54 45			.text	7,$2a,"SPRITES"        ; $a1 SPRITES
>cf8c	af8c	53
>cf8d	af8d	04 46 53 54 4f 50			.text	4,$46,"STOP"           ; $a2 STOP
>cf93	af93	06 d5 56 45 52 49 46 59			.text	6,$d5,"VERIFY"         ; $a3 VERIFY
>cf9b	af9b	03 ee 58 47 4f				.text	3,$ee,"XGO"            ; $a4 XGO
>cfa0	afa0	05 78 58 4c 4f 41 44			.text	5,$78,"XLOAD"          ; $a5 XLOAD
>cfa7	afa7	03 eb 5a 41 50				.text	3,$eb,"ZAP"            ; $a6 ZAP
>cfac	afac	ff					.text	$FF
.cfad	afad					KeywordSet2:
>cfad	afad	00 65					.text	0,$65,""               ; $80 !0:EOF
>cfaf	afaf	00 58					.text	0,$58,""               ; $81 !1:SH1
>cfb1	afb1	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>cfb3	afb3	03 c8 41 44 43				.text	3,$c8,"ADC"            ; $83 ADC
>cfb8	afb8	03 d3 41 4e 44				.text	3,$d3,"AND"            ; $84 AND
>cfbd	afbd	03 e0 41 53 4c				.text	3,$e0,"ASL"            ; $85 ASL
>cfc2	afc2	03 c8 42 43 43				.text	3,$c8,"BCC"            ; $86 BCC
>cfc7	afc7	03 d8 42 43 53				.text	3,$d8,"BCS"            ; $87 BCS
>cfcc	afcc	03 d8 42 45 51				.text	3,$d8,"BEQ"            ; $88 BEQ
>cfd1	afd1	03 df 42 49 54				.text	3,$df,"BIT"            ; $89 BIT
>cfd6	afd6	03 d8 42 4d 49				.text	3,$d8,"BMI"            ; $8a BMI
>cfdb	afdb	03 d5 42 4e 45				.text	3,$d5,"BNE"            ; $8b BNE
>cfe0	afe0	03 de 42 50 4c				.text	3,$de,"BPL"            ; $8c BPL
>cfe5	afe5	03 d5 42 52 41				.text	3,$d5,"BRA"            ; $8d BRA
>cfea	afea	03 df 42 52 4b				.text	3,$df,"BRK"            ; $8e BRK
>cfef	afef	03 db 42 56 43				.text	3,$db,"BVC"            ; $8f BVC
>cff4	aff4	03 eb 42 56 53				.text	3,$eb,"BVS"            ; $90 BVS
>cff9	aff9	03 d2 43 4c 43				.text	3,$d2,"CLC"            ; $91 CLC
>cffe	affe	03 d3 43 4c 44				.text	3,$d3,"CLD"            ; $92 CLD
>d003	b003	03 d8 43 4c 49				.text	3,$d8,"CLI"            ; $93 CLI
>d008	b008	03 e5 43 4c 56				.text	3,$e5,"CLV"            ; $94 CLV
>d00d	b00d	03 e0 43 4d 50				.text	3,$e0,"CMP"            ; $95 CMP
>d012	b012	03 eb 43 50 58				.text	3,$eb,"CPX"            ; $96 CPX
>d017	b017	03 ec 43 50 59				.text	3,$ec,"CPY"            ; $97 CPY
>d01c	b01c	03 cc 44 45 43				.text	3,$cc,"DEC"            ; $98 DEC
>d021	b021	03 e1 44 45 58				.text	3,$e1,"DEX"            ; $99 DEX
>d026	b026	03 e2 44 45 59				.text	3,$e2,"DEY"            ; $9a DEY
>d02b	b02b	03 e6 45 4f 52				.text	3,$e6,"EOR"            ; $9b EOR
>d030	b030	03 da 49 4e 43				.text	3,$da,"INC"            ; $9c INC
>d035	b035	03 ef 49 4e 58				.text	3,$ef,"INX"            ; $9d INX
>d03a	b03a	03 f0 49 4e 59				.text	3,$f0,"INY"            ; $9e INY
>d03f	b03f	03 e7 4a 4d 50				.text	3,$e7,"JMP"            ; $9f JMP
>d044	b044	03 ef 4a 53 52				.text	3,$ef,"JSR"            ; $a0 JSR
>d049	b049	03 d1 4c 44 41				.text	3,$d1,"LDA"            ; $a1 LDA
>d04e	b04e	03 e8 4c 44 58				.text	3,$e8,"LDX"            ; $a2 LDX
>d053	b053	03 e9 4c 44 59				.text	3,$e9,"LDY"            ; $a3 LDY
>d058	b058	03 f1 4c 53 52				.text	3,$f1,"LSR"            ; $a4 LSR
>d05d	b05d	03 ed 4e 4f 50				.text	3,$ed,"NOP"            ; $a5 NOP
>d062	b062	03 e2 4f 52 41				.text	3,$e2,"ORA"            ; $a6 ORA
>d067	b067	03 d9 50 48 41				.text	3,$d9,"PHA"            ; $a7 PHA
>d06c	b06c	03 e8 50 48 50				.text	3,$e8,"PHP"            ; $a8 PHP
>d071	b071	03 f0 50 48 58				.text	3,$f0,"PHX"            ; $a9 PHX
>d076	b076	03 f1 50 48 59				.text	3,$f1,"PHY"            ; $aa PHY
>d07b	b07b	03 dd 50 4c 41				.text	3,$dd,"PLA"            ; $ab PLA
>d080	b080	03 ec 50 4c 50				.text	3,$ec,"PLP"            ; $ac PLP
>d085	b085	03 f4 50 4c 58				.text	3,$f4,"PLX"            ; $ad PLX
>d08a	b08a	03 f5 50 4c 59				.text	3,$f5,"PLY"            ; $ae PLY
>d08f	b08f	03 ed 52 4f 4c				.text	3,$ed,"ROL"            ; $af ROL
>d094	b094	03 f3 52 4f 52				.text	3,$f3,"ROR"            ; $b0 ROR
>d099	b099	03 ef 52 54 49				.text	3,$ef,"RTI"            ; $b1 RTI
>d09e	b09e	03 f9 52 54 53				.text	3,$f9,"RTS"            ; $b2 RTS
>d0a3	b0a3	03 d8 53 42 43				.text	3,$d8,"SBC"            ; $b3 SBC
>d0a8	b0a8	03 db 53 45 43				.text	3,$db,"SEC"            ; $b4 SEC
>d0ad	b0ad	03 dc 53 45 44				.text	3,$dc,"SED"            ; $b5 SED
>d0b2	b0b2	03 e1 53 45 49				.text	3,$e1,"SEI"            ; $b6 SEI
>d0b7	b0b7	03 e8 53 54 41				.text	3,$e8,"STA"            ; $b7 STA
>d0bc	b0bc	03 f7 53 54 50				.text	3,$f7,"STP"            ; $b8 STP
>d0c1	b0c1	03 ff 53 54 58				.text	3,$ff,"STX"            ; $b9 STX
>d0c6	b0c6	03 00 53 54 59				.text	3,$00,"STY"            ; $ba STY
>d0cb	b0cb	03 01 53 54 5a				.text	3,$01,"STZ"            ; $bb STZ
>d0d0	b0d0	03 ed 54 41 58				.text	3,$ed,"TAX"            ; $bc TAX
>d0d5	b0d5	03 ee 54 41 59				.text	3,$ee,"TAY"            ; $bd TAY
>d0da	b0da	03 e8 54 52 42				.text	3,$e8,"TRB"            ; $be TRB
>d0df	b0df	03 e9 54 53 42				.text	3,$e9,"TSB"            ; $bf TSB
>d0e4	b0e4	03 ff 54 53 58				.text	3,$ff,"TSX"            ; $c0 TSX
>d0e9	b0e9	03 ed 54 58 41				.text	3,$ed,"TXA"            ; $c1 TXA
>d0ee	b0ee	03 ff 54 58 53				.text	3,$ff,"TXS"            ; $c2 TXS
>d0f3	b0f3	03 ee 54 59 41				.text	3,$ee,"TYA"            ; $c3 TYA
>d0f8	b0f8	ff					.text	$FF
.d0f9	b0f9					Export_TKListConvertLine:
.d0f9	b0f9	48		pha				pha 								; save indent on the stack
.d0fa	b0fa	9c 19 04	stz $0419			stz 	tbOffset
.d0fd	b0fd	9c 29 04	stz $0429			stz 	tokenBuffer
.d100	b100	9c 25 04	stz $0425			stz 	currentListColour
.d103	b103	a9 8d		lda #$8d			lda 	#CLILineNumber+$80
.d105	b105	20 82 b2	jsr $b282			jsr 	LCLWriteColour
.d108	b108	a0 02		ldy #$02			ldy 	#2 							; convert line number to string
.d10a	b10a	b1 30		lda ($30),y			lda 	(codePtr),y
.d10c	b10c	aa		tax				tax
.d10d	b10d	88		dey				dey
.d10e	b10e	b1 30		lda ($30),y			lda 	(codePtr),y
.d110	b110	20 f3 b2	jsr $b2f3			jsr 	LCLWriteNumberXA
.d113	b113	68		pla				pla 								; adjustment to indent
.d114	b114	48		pha				pha 								; save on stack
.d115	b115	10 0c		bpl $b123			bpl 	_LCNoAdjust 				; don't adjust indent if +ve, do after.
.d117	b117	18		clc				clc 								; add to list indent and make 0 if goes -ve.
.d118	b118	6d 22 04	adc $0422			adc 	listIndent
.d11b	b11b	8d 22 04	sta $0422			sta 	listIndent
.d11e	b11e	10 03		bpl $b123			bpl 	_LCNoAdjust
.d120	b120	9c 22 04	stz $0422			stz 	listIndent
.d123	b123					_LCNoAdjust:
.d123	b123	18		clc				clc		 							; work out actual indent.
.d124	b124	ad 22 04	lda $0422			lda 	listIndent
.d127	b127	0a		asl a				asl 	a
.d128	b128	69 07		adc #$07			adc 	#7
.d12a	b12a	85 36		sta $36				sta 	zTemp0
.d12c	b12c					_LCPadOut:
.d12c	b12c	a9 20		lda #$20			lda 	#' '						; pad out to 6+indent characters
.d12e	b12e	20 8b b2	jsr $b28b			jsr 	LCLWrite
.d131	b131	ad 19 04	lda $0419			lda 	tbOffset
.d134	b134	c5 36		cmp $36				cmp 	zTemp0
.d136	b136	d0 f4		bne $b12c			bne 	_LCPadOut
.d138	b138	a0 03		ldy #$03			ldy 	#3 							; start position.
.d13a	b13a					_LCMainLoop:
.d13a	b13a	a9 8c		lda #$8c			lda 	#CLIPunctuation+$80
.d13c	b13c	20 82 b2	jsr $b282			jsr 	LCLWriteColour
.d13f	b13f	b1 30		lda ($30),y			lda 	(codePtr),y
.d141	b141	c9 80		cmp #$80			cmp 	#KWC_EOL 					; end of line ?
.d143	b143	f0 17		beq $b15c			beq 	_LCExit
.d145	b145	c9 10		cmp #$10			cmp 	#16 						; 0-5 are the double punctuations
.d147	b147	90 1e		bcc $b167			bcc 	_LCDoubles
.d149	b149	c9 20		cmp #$20			cmp 	#32 						; 16-31 are shifted punctuation from 64-91
.d14b	b14b	90 2a		bcc $b177			bcc 	_LCShiftPunc
.d14d	b14d	c9 40		cmp #$40			cmp 	#64 						; 32-64 are as stored, punc and digits
.d14f	b14f	90 35		bcc $b186			bcc 	_LCPunctuation
.d151	b151	c9 80		cmp #$80			cmp 	#128 						; 64-127 are variable identifiers.
.d153	b153	90 51		bcc $b1a6			bcc 	_LCIdentifiers
.d155	b155	c9 fe		cmp #$fe			cmp 	#254 						; 128-253 are tokenised words
.d157	b157	90 73		bcc $b1cc			bcc 	_LCTokens
.d159	b159	4c 2c b2	jmp $b22c			jmp 	_LCData 					; 254-5 are data objects
.d15c	b15c					_LCExit:
.d15c	b15c	68		pla				pla 								; get old indent adjust
.d15d	b15d	30 07		bmi $b166			bmi 	_LCExit2
.d15f	b15f	18		clc				clc 								; add to indent if +ve
.d160	b160	6d 22 04	adc $0422			adc 	listIndent
.d163	b163	8d 22 04	sta $0422			sta 	listIndent
.d166	b166					_LCExit2:
.d166	b166	60		rts				rts
.d167	b167					_LCDoubles:
.d167	b167	48		pha				pha
.d168	b168	4a		lsr a				lsr 	a 							; put bit 2 into bit 1
.d169	b169	29 02		and #$02			and 	#2
.d16b	b16b	09 3c		ora #$3c			ora 	#60 						; make < >
.d16d	b16d	20 8b b2	jsr $b28b			jsr 	LCLWrite
.d170	b170	68		pla				pla 								; restore, do lower bit
.d171	b171	29 03		and #$03			and 	#3
.d173	b173	09 3c		ora #$3c			ora 	#60
.d175	b175	80 0f		bra $b186			bra		_LCPunctuation 				; print, increment, loop
.d177	b177					_LCShiftPunc:
.d177	b177	aa		tax				tax 								; save in X
.d178	b178	29 07		and #$07			and 	#7 							; lower 3 bits
.d17a	b17a	f0 02		beq $b17e			beq 	_LCNoAdd
.d17c	b17c	09 18		ora #$18			ora 	#24 						; adds $18 to it.
.d17e	b17e					_LCNoAdd:
.d17e	b17e	e0 18		cpx #$18			cpx 	#24 						; if >= 24 add $20
.d180	b180	90 02		bcc $b184			bcc 	_LCNoAdd2
.d182	b182	09 20		ora #$20			ora 	#32 						; adds $20
.d184	b184					_LCNoAdd2:
.d184	b184	09 40		ora #$40			ora 	#$40 						; shift into 64-127 range and fall through.
.d186	b186					_LCPunctuation:
.d186	b186	c9 3a		cmp #$3a			cmp 	#':' 						; check if :
.d188	b188	d0 03		bne $b18d			bne 	_LCPContinue
.d18a	b18a	20 a1 b2	jsr $b2a1			jsr 	LCLDeleteLastSpace 			; if so delete any preceding spaces
.d18d	b18d					_LCPContinue:
.d18d	b18d	c9 2e		cmp #$2e			cmp 	#'.'
.d18f	b18f	f0 08		beq $b199			beq 	_LCPIsConstant
.d191	b191	c9 30		cmp #$30			cmp 	#'0'
.d193	b193	90 0b		bcc $b1a0			bcc 	_LCPNotConstant
.d195	b195	c9 3a		cmp #$3a			cmp 	#'9'+1
.d197	b197	b0 07		bcs $b1a0			bcs 	_LCPNotConstant
.d199	b199					_LCPIsConstant:
.d199	b199	48		pha				pha
.d19a	b19a	a9 87		lda #$87			lda 	#CLIConstant+$80
.d19c	b19c	20 82 b2	jsr $b282			jsr 	LCLWriteColour
.d19f	b19f	68		pla				pla
.d1a0	b1a0					_LCPNotConstant:
.d1a0	b1a0	c8		iny				iny 								; consume character
.d1a1	b1a1	20 8b b2	jsr $b28b			jsr 	LCLWrite 					; write it out.
.d1a4	b1a4	80 94		bra $b13a			bra 	_LCMainLoop 				; go round again.
.d1a6	b1a6					_LCIdentifiers:
.d1a6	b1a6	18		clc				clc 								; convert to physical address
.d1a7	b1a7	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.d1a9	b1a9	85 37		sta $37				sta 	zTemp0+1
.d1ab	b1ab	c8		iny				iny
.d1ac	b1ac	b1 30		lda ($30),y			lda 	(codePtr),y
.d1ae	b1ae	85 36		sta $36				sta 	zTemp0
.d1b0	b1b0	c8		iny				iny
.d1b1	b1b1	5a		phy				phy 								; save position
.d1b2	b1b2	a9 8e		lda #$8e			lda 	#CLIIdentifier+$80
.d1b4	b1b4	20 82 b2	jsr $b282			jsr 	LCLWriteColour
.d1b7	b1b7	a0 07		ldy #$07			ldy 	#7 							; output the identifier at +8
.d1b9	b1b9					_LCOutIdentifier:
.d1b9	b1b9	c8		iny				iny
.d1ba	b1ba	b1 36		lda ($36),y			lda 	(zTemp0),y					; bit 7 set = end.
.d1bc	b1bc	29 7f		and #$7f			and 	#$7F
.d1be	b1be	20 dd b2	jsr $b2dd			jsr 	LCLLowerCase
.d1c1	b1c1	20 8b b2	jsr $b28b			jsr 	LCLWrite
.d1c4	b1c4	b1 36		lda ($36),y			lda 	(zTemp0),y				 	; ends when bit 7 set.
.d1c6	b1c6	10 f1		bpl $b1b9			bpl 	_LCOutIdentifier
.d1c8	b1c8	7a		ply				ply 								; restore position
.d1c9	b1c9	4c 3a b1	jmp $b13a			jmp 	_LCMainLoop
.d1cc	b1cc					_LCTokens:
.d1cc	b1cc	aa		tax				tax 								; token in X
.d1cd	b1cd	a9 ad		lda #$ad			lda 	#((KeywordSet2) & $FF)
.d1cf	b1cf	85 36		sta $36				sta 	0+zTemp0
.d1d1	b1d1	a9 af		lda #$af			lda 	#((KeywordSet2) >> 8)
.d1d3	b1d3	85 37		sta $37				sta 	1+zTemp0
.d1d5	b1d5	e0 82		cpx #$82			cpx 	#$82
.d1d7	b1d7	f0 16		beq $b1ef			beq 	_LCUseShift
.d1d9	b1d9	a9 b1		lda #$b1			lda 	#((KeywordSet1) & $FF)
.d1db	b1db	85 36		sta $36				sta 	0+zTemp0
.d1dd	b1dd	a9 ae		lda #$ae			lda 	#((KeywordSet1) >> 8)
.d1df	b1df	85 37		sta $37				sta 	1+zTemp0
.d1e1	b1e1	e0 81		cpx #$81			cpx 	#$81
.d1e3	b1e3	f0 0a		beq $b1ef			beq 	_LCUseShift
.d1e5	b1e5	a9 40		lda #$40			lda 	#((KeywordSet0) & $FF)
.d1e7	b1e7	85 36		sta $36				sta 	0+zTemp0
.d1e9	b1e9	a9 ac		lda #$ac			lda 	#((KeywordSet0) >> 8)
.d1eb	b1eb	85 37		sta $37				sta 	1+zTemp0
.d1ed	b1ed	80 01		bra $b1f0			bra 	_LCNoShift
.d1ef	b1ef					_LCUseShift:
.d1ef	b1ef	c8		iny				iny
.d1f0	b1f0					_LCNoShift:
.d1f0	b1f0	20 b5 b2	jsr $b2b5			jsr 	LCLCheckSpaceRequired 		; do we need a space ?
.d1f3	b1f3	b1 30		lda ($30),y			lda 	(codePtr),y
.d1f5	b1f5	aa		tax				tax 								; into X
.d1f6	b1f6					_LCFindText:
.d1f6	b1f6	ca		dex				dex
.d1f7	b1f7	10 0e		bpl $b207			bpl 	_LCFoundText 				; found text.
.d1f9	b1f9	b2 36		lda ($36)			lda 	(zTemp0) 					; length of text
.d1fb	b1fb	1a		inc a				inc 	a 							; one extra for size
.d1fc	b1fc	38		sec				sec 								; one extra for checksum
.d1fd	b1fd	65 36		adc $36				adc 	zTemp0 						; go to next token
.d1ff	b1ff	85 36		sta $36				sta 	zTemp0
.d201	b201	90 f3		bcc $b1f6			bcc 	_LCFindText
.d203	b203	e6 37		inc $37				inc 	zTemp0+1
.d205	b205	80 ef		bra $b1f6			bra 	_LCFindText
.d207	b207					_LCFoundText:
.d207	b207	5a		phy				phy 								; save List position
.d208	b208	b2 36		lda ($36)			lda 	(zTemp0)					; count to print
.d20a	b20a	aa		tax				tax
.d20b	b20b	a9 86		lda #$86			lda 	#CLIToken+$80
.d20d	b20d	20 82 b2	jsr $b282			jsr 	LCLWriteColour
.d210	b210	a0 02		ldy #$02			ldy 	#2
.d212	b212					_LCCopyToken:
.d212	b212	b1 36		lda ($36),y			lda 	(zTemp0),y
.d214	b214	20 dd b2	jsr $b2dd			jsr 	LCLLowerCase
.d217	b217	20 8b b2	jsr $b28b			jsr 	LCLWrite
.d21a	b21a	c8		iny				iny
.d21b	b21b	ca		dex				dex
.d21c	b21c	d0 f4		bne $b212			bne 	_LCCopyToken
.d21e	b21e	c9 28		cmp #$28			cmp 	#"(" 						; if last char not ( print a space
.d220	b220	f0 05		beq $b227			beq 	_LCNoSpace
.d222	b222	a9 20		lda #$20			lda 	#' '
.d224	b224	20 8b b2	jsr $b28b			jsr 	LCLWrite
.d227	b227					_LCNoSpace:
.d227	b227	7a		ply				ply 								; restore position.
.d228	b228	c8		iny				iny 								; consume token
.d229	b229	4c 3a b1	jmp $b13a			jmp 	_LCMainLoop 				; and go around again.
.d22c	b22c					_LCData:
.d22c	b22c	48		pha				pha 								; save type $FE/$FF
.d22d	b22d	a2 24		ldx #$24			ldx 	#'$' 						; figure out $ or "
.d22f	b22f	c9 fe		cmp #$fe			cmp 	#$FE
.d231	b231	f0 22		beq $b255			beq 	_LCHaveOpener
.d233	b233	a2 22		ldx #$22			ldx 	#'"'
.d235	b235	a9 8f		lda #$8f			lda 	#CLIData+$80
.d237	b237	20 82 b2	jsr $b282			jsr 	LCLWriteColour
.d23a	b23a	c0 04		cpy #$04			cpy 	#4 							; must be 2nd thing on line
.d23c	b23c	d0 17		bne $b255			bne 	_LCHaveOpener
.d23e	b23e	88		dey				dey 								; what precedes it ?
.d23f	b23f	b1 30		lda ($30),y			lda 	(codePtr),y
.d241	b241	c8		iny				iny
.d242	b242	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; if quote
.d244	b244	d0 0f		bne $b255			bne 	_LCHaveOpener
.d246	b246	a9 09		lda #$09			lda 	#9 							; tab
.d248	b248	20 8b b2	jsr $b28b			jsr 	LCLWrite
.d24b	b24b	a9 9e		lda #$9e			lda 	#$90+CLIBComment
.d24d	b24d	20 8b b2	jsr $b28b			jsr 	LCLWrite
.d250	b250	a9 85		lda #$85			lda 	#CLIFComment+$80
.d252	b252	20 82 b2	jsr $b282			jsr 	LCLWriteColour
.d255	b255					_LCHaveOpener:
.d255	b255	8a		txa				txa 								; output prefix (# or ")
.d256	b256	20 8b b2	jsr $b28b			jsr 	LCLWrite
.d259	b259	c8		iny				iny 								; get count
.d25a	b25a	b1 30		lda ($30),y			lda 	(codePtr),y
.d25c	b25c	aa		tax				tax
.d25d	b25d	c8		iny				iny 								; point at first character
.d25e	b25e					_LCOutData:
.d25e	b25e	b1 30		lda ($30),y			lda 	(codePtr),y
.d260	b260	c9 00		cmp #$00			cmp 	#0
.d262	b262	f0 03		beq $b267			beq 	_LCNoPrint
.d264	b264	20 8b b2	jsr $b28b			jsr 	LCLWrite
.d267	b267					_LCNoPrint:
.d267	b267	c8		iny				iny
.d268	b268	ca		dex				dex
.d269	b269	d0 f3		bne $b25e			bne 	_LCOutData
.d26b	b26b	68		pla				pla 								; closing " required ?
.d26c	b26c	c9 ff		cmp #$ff			cmp 	#$FF 						; not required for hex constant.
.d26e	b26e	d0 0f		bne $b27f			bne 	_LCNoQuote
.d270	b270	a9 22		lda #$22			lda 	#'"'
.d272	b272	20 8b b2	jsr $b28b			jsr 	LCLWrite
.d275	b275	ad b6 07	lda $07b6			lda 	EXTTextColour
.d278	b278	29 0f		and #$0f			and 	#$0F
.d27a	b27a	09 90		ora #$90			ora 	#$90
.d27c	b27c	20 8b b2	jsr $b28b			jsr 	LCLWrite
.d27f	b27f					_LCNoQuote:
.d27f	b27f	4c 3a b1	jmp $b13a			jmp 	_LCMainLoop
.d282	b282					LCLWriteColour:
.d282	b282	cd 25 04	cmp $0425			cmp 	currentListColour 			; has the colour changed
.d285	b285	8d 25 04	sta $0425			sta 	currentListColour 			; (update it anyway)
.d288	b288	d0 01		bne $b28b			bne 	LCLWrite 					; if different, output it
.d28a	b28a	60		rts				rts
.d28b	b28b					LCLWrite:
.d28b	b28b	da		phx				phx
.d28c	b28c	ae 19 04	ldx $0419			ldx 	tbOffset 					; write out make ASCIIZ
.d28f	b28f	9d 29 04	sta $0429,x			sta 	tokenBuffer,x
.d292	b292	9e 2a 04	stz $042a,x			stz 	tokenBuffer+1,x
.d295	b295	ee 19 04	inc $0419			inc 	tbOffset 					; bump the position
.d298	b298	09 00		ora #$00			ora 	#0 							; don't update last character if colour data
.d29a	b29a	30 03		bmi $b29f			bmi 	_LCLNoColour
.d29c	b29c	8d 23 04	sta $0423			sta 	lcLastCharacter
.d29f	b29f					_LCLNoColour:
.d29f	b29f	fa		plx				plx
.d2a0	b2a0	60		rts				rts
.d2a1	b2a1					LCLDeleteLastSpace:
.d2a1	b2a1	48		pha				pha
.d2a2	b2a2	da		phx				phx
.d2a3	b2a3	ae 19 04	ldx $0419			ldx 	tbOffset
.d2a6	b2a6	f0 0a		beq $b2b2			beq 	_LCDLSExit
.d2a8	b2a8	bd 28 04	lda $0428,x			lda 	tokenBuffer-1,x
.d2ab	b2ab	c9 20		cmp #$20			cmp 	#' '
.d2ad	b2ad	d0 03		bne $b2b2			bne 	_LCDLSExit
.d2af	b2af	ce 19 04	dec $0419			dec 	tbOffset
.d2b2	b2b2					_LCDLSExit:
.d2b2	b2b2	fa		plx				plx
.d2b3	b2b3	68		pla				pla
.d2b4	b2b4	60		rts				rts
.d2b5	b2b5					LCLCheckSpaceRequired:
.d2b5	b2b5	ad 23 04	lda $0423			lda 	lcLastCharacter 			; check last character
.d2b8	b2b8	c9 24		cmp #$24			cmp 	#'$' 						; $ # and ) require that token space.
.d2ba	b2ba	f0 1b		beq $b2d7			beq 	_LCCSRSpace
.d2bc	b2bc	c9 29		cmp #$29			cmp 	#')'
.d2be	b2be	f0 17		beq $b2d7			beq 	_LCCSRSpace
.d2c0	b2c0	c9 23		cmp #$23			cmp 	#'#'
.d2c2	b2c2	f0 13		beq $b2d7			beq 	_LCCSRSpace
.d2c4	b2c4	20 dd b2	jsr $b2dd			jsr 	LCLLowerCase 				; saves a little effort
.d2c7	b2c7	c9 30		cmp #$30			cmp 	#"0" 						; check if it was 0-9 A-Z a-z if so need space.
.d2c9	b2c9	90 11		bcc $b2dc			bcc 	_LCCSRExit
.d2cb	b2cb	c9 3a		cmp #$3a			cmp 	#"9"+1
.d2cd	b2cd	90 08		bcc $b2d7			bcc 	_LCCSRSpace
.d2cf	b2cf	c9 61		cmp #$61			cmp 	#"a"
.d2d1	b2d1	90 09		bcc $b2dc			bcc 	_LCCSRExit
.d2d3	b2d3	c9 7b		cmp #$7b			cmp 	#"z"+1
.d2d5	b2d5	b0 05		bcs $b2dc			bcs 	_LCCSRExit
.d2d7	b2d7					_LCCSRSpace:
.d2d7	b2d7	a9 20		lda #$20			lda 	#' '
.d2d9	b2d9	20 8b b2	jsr $b28b			jsr 	LCLWrite
.d2dc	b2dc					_LCCSRExit:
.d2dc	b2dc	60		rts				rts
.d2dd	b2dd					LCLLowerCase:
.d2dd	b2dd	c9 41		cmp #$41			cmp 	#"A"
.d2df	b2df	90 06		bcc $b2e7			bcc 	_LCLLCOut
.d2e1	b2e1	c9 5b		cmp #$5b			cmp 	#"Z"+1
.d2e3	b2e3	b0 02		bcs $b2e7			bcs 	_LCLLCOut
.d2e5	b2e5	69 20		adc #$20			adc 	#$20
.d2e7	b2e7					_LCLLCOut:
.d2e7	b2e7	60		rts				rts
.d2e8	b2e8					LCLUpperCase:
.d2e8	b2e8	c9 61		cmp #$61			cmp 	#"a"
.d2ea	b2ea	90 06		bcc $b2f2			bcc 	_LCLUCOut
.d2ec	b2ec	c9 7b		cmp #$7b			cmp 	#"z"+1
.d2ee	b2ee	b0 02		bcs $b2f2			bcs 	_LCLUCOut
.d2f0	b2f0	e9 1f		sbc #$1f			sbc 	#$1F
.d2f2	b2f2					_LCLUCOut:
.d2f2	b2f2	60		rts				rts
.d2f3	b2f3					LCLWriteNumberXA:
.d2f3	b2f3	64 37		stz $37				stz 	zTemp0+1 					; index into digit table.
.d2f5	b2f5					_LCLWNLoop1:
.d2f5	b2f5	64 36		stz $36				stz 	zTemp0 						; subtraction count.
.d2f7	b2f7					_LCLWNLoop2:
.d2f7	b2f7	48		pha				pha 								; save initial LSB
.d2f8	b2f8	38		sec				sec
.d2f9	b2f9	a4 37		ldy $37				ldy 	zTemp0+1 					; position in table.
.d2fb	b2fb	f9 2c b3	sbc $b32c,y			sbc 	_LCLWNTable,y
.d2fe	b2fe	48		pha				pha
.d2ff	b2ff	8a		txa				txa
.d300	b300	f9 2d b3	sbc $b32d,y			sbc 	_LCLWNTable+1,y
.d303	b303	90 07		bcc $b30c			bcc 	_LCLWNUnderflow
.d305	b305	e6 36		inc $36				inc 	zTemp0  					; subtracted one without borrow.
.d307	b307	aa		tax				tax 								; update X
.d308	b308	68		pla				pla 								; restore A
.d309	b309	7a		ply				ply 								; throw original
.d30a	b30a	80 eb		bra $b2f7			bra 	_LCLWNLoop2 				; try again.
.d30c	b30c					_LCLWNUnderflow:
.d30c	b30c	a4 36		ldy $36				ldy 	zTemp0 						; count of subtractions.
.d30e	b30e	d0 06		bne $b316			bne 	_LCLWNOut
.d310	b310	ad 19 04	lda $0419			lda 	tbOffset 					; suppress leading zeroes
.d313	b313	3a		dec a				dec 	a
.d314	b314	f0 04		beq $b31a			beq 	_LCLWNNext
.d316	b316					_LCLWNOut:
.d316	b316	98		tya				tya
.d317	b317	20 26 b3	jsr $b326			jsr 	_LCLWNOutDigit
.d31a	b31a					_LCLWNNext:
.d31a	b31a	7a		ply				ply 							 	; restore original value.
.d31b	b31b	68		pla				pla
.d31c	b31c	a4 37		ldy $37				ldy 	zTemp0+1  					; bump the index
.d31e	b31e	c8		iny				iny
.d31f	b31f	c8		iny				iny
.d320	b320	84 37		sty $37				sty 	zTemp0+1
.d322	b322	c0 08		cpy #$08			cpy 	#8 							; done all 4
.d324	b324	d0 cf		bne $b2f5			bne 	_LCLWNLoop1
.d326	b326					_LCLWNOutDigit:
.d326	b326	09 30		ora #$30			ora 	#'0'
.d328	b328	20 8b b2	jsr $b28b			jsr 	LCLWrite
.d32b	b32b	60		rts				rts
.d32c	b32c					_LCLWNTable:
>d32c	b32c	10 27						.word 	10000
>d32e	b32e	e8 03						.word 	1000
>d330	b330	64 00						.word 	100
>d332	b332	0a 00						.word 	10
.d334	b334					TOKSearchTable:
.d334	b334	84 37		sty $37				sty 	zTemp0+1 					; (zTemp0),y points to current token being tested.
.d336	b336	85 36		sta $36				sta 	zTemp0
.d338	b338	a0 00		ldy #$00			ldy 	#0
.d33a	b33a	a9 80		lda #$80			lda 	#$80 						; token # so we know which one we are looking at
.d33c	b33c	85 38		sta $38				sta 	zTemp1
.d33e	b33e					_TSTLoop:
.d33e	b33e	b1 36		lda ($36),y			lda 	(zTemp0),y 					; length, 0 (skip) -ve (end)
.d340	b340	30 49		bmi $b38b			bmi 	_TSTFail 					; -ve = end of table, so fail.
.d342	b342	f0 2e		beq $b372			beq 	_TSTNext 					; zero, check next as it's a dummy (e.g. EOL, SHIFT)
.d344	b344	c8		iny				iny 								; get the hash
.d345	b345	b1 36		lda ($36),y			lda 	(zTemp0),y
.d347	b347	88		dey				dey
.d348	b348	cd 03 04	cmp $0403			cmp 	identHash 					; check they match with the identifier hash, if not go to next
.d34b	b34b	d0 25		bne $b372			bne 	_TSTNext
.d34d	b34d	ad 02 04	lda $0402			lda 	identTypeEnd 				; get length of identifier from end-start
.d350	b350	38		sec				sec
.d351	b351	ed 00 04	sbc $0400			sbc 	identStart
.d354	b354	d1 36		cmp ($36),y			cmp 	(zTemp0),y 					; compare against the length in the table, no match, then return.
.d356	b356	d0 1a		bne $b372			bne 	_TSTNext
.d358	b358	5a		phy				phy 								; save Y , we might fail to match.
.d359	b359	c8		iny				iny 								; point to text
.d35a	b35a	c8		iny				iny
.d35b	b35b	ae 00 04	ldx $0400			ldx 	identStart 					; offset in line buffer in X
.d35e	b35e					_TSTCompareName:
.d35e	b35e	bd 26 05	lda $0526,x			lda 	lineBuffer,x 				; compare text.
.d361	b361	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.d363	b363	d0 0c		bne $b371			bne 	_TSTNextPullY 				; fail, pullY and do next
.d365	b365	e8		inx				inx
.d366	b366	c8		iny				iny
.d367	b367	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; complete match.
.d36a	b36a	d0 f2		bne $b35e			bne 	_TSTCompareName
.d36c	b36c	7a		ply				ply 								; throw Y
.d36d	b36d	a5 38		lda $38				lda 	zTemp1 						; get token #
.d36f	b36f	38		sec				sec 								; return with CS = passed.
.d370	b370	60		rts				rts
.d371	b371					_TSTNextPullY:
.d371	b371	7a		ply				ply 								; restore current, fall through.
.d372	b372					_TSTNext:
.d372	b372	e6 38		inc $38				inc 	zTemp1 						; token counter
.d374	b374	98		tya				tya
.d375	b375	18		clc				clc
.d376	b376	71 36		adc ($36),y			adc 	(zTemp0),y 					; add [Length] + 2 to Y
.d378	b378	1a		inc a				inc 	a 							; +1
.d379	b379	1a		inc a				inc 	a 							; +2
.d37a	b37a	a8		tay				tay
.d37b	b37b	10 c1		bpl $b33e			bpl 	_TSTLoop 					; if Y < $80 loop back
.d37d	b37d	98		tya				tya 								; add Y to zTemp0 and reset Y
.d37e	b37e	a0 00		ldy #$00			ldy 	#0   						; so we can use Y to search fast
.d380	b380	18		clc				clc  								; but have tables > 255 bytes
.d381	b381	65 36		adc $36				adc 	zTemp0 						; when Y gets >= 128 we reset Y
.d383	b383	85 36		sta $36				sta 	zTemp0 						; and adjust the table pointer/
.d385	b385	90 b7		bcc $b33e			bcc 	_TSTLoop
.d387	b387	e6 37		inc $37				inc 	zTemp0+1
.d389	b389	80 b3		bra $b33e			bra 	_TSTLoop
.d38b	b38b					_TSTFail:
.d38b	b38b	18		clc				clc
.d38c	b38c	60		rts				rts
.d38d	b38d					Export_TKTokeniseLine:
.d38d	b38d	20 5a b5	jsr $b55a			jsr 	LCLFixLineBufferCase 		; fix line case
.d390	b390	a9 03		lda #$03			lda 	#3 							; reset the token buffer to empty
.d392	b392	8d 26 04	sta $0426			sta 	tokenOffset 				; (3 bytes for line number & offset)
.d395	b395	9c 27 04	stz $0427			stz 	tokenLineNumber
.d398	b398	9c 28 04	stz $0428			stz 	tokenLineNumber+1
.d39b	b39b	a2 ff		ldx #$ff			ldx 	#$FF
.d39d	b39d					_TKFindFirst:
.d39d	b39d	e8		inx				inx
.d39e	b39e	bd 26 05	lda $0526,x			lda 	lineBuffer,x
.d3a1	b3a1	f0 62		beq $b405			beq 	_TKExit
.d3a3	b3a3	c9 20		cmp #$20			cmp 	#' '
.d3a5	b3a5	90 f6		bcc $b39d			bcc 	_TKFindFirst
.d3a7	b3a7	c9 30		cmp #$30			cmp 	#'0'
.d3a9	b3a9	90 07		bcc $b3b2			bcc 	_TKNoLineNumber
.d3ab	b3ab	c9 3a		cmp #$3a			cmp 	#'9'+1
.d3ad	b3ad	b0 03		bcs $b3b2			bcs 	_TKNoLineNumber
.d3af	b3af	20 84 b5	jsr $b584			jsr 	TOKExtractLineNumber
.d3b2	b3b2					_TKNoLineNumber:
.d3b2	b3b2					_TKTokeniseLoop:
.d3b2	b3b2	bd 26 05	lda $0526,x			lda 	lineBuffer,x 				; next character, exit if zero EOL.
.d3b5	b3b5	f0 4e		beq $b405			beq 	_TKExit
.d3b7	b3b7	e8		inx				inx
.d3b8	b3b8	c9 20		cmp #$20			cmp 	#' '
.d3ba	b3ba	f0 f6		beq $b3b2			beq 	_TKTokeniseLoop 			; keep looping if space found.
.d3bc	b3bc	ca		dex				dex 								; undo last get, A contains character, X is position.
.d3bd	b3bd	c9 5f		cmp #$5f			cmp 	#'_'						; _ A-Z is identifier *or* token
.d3bf	b3bf	f0 68		beq $b429			beq 	_TKTokeniseIdentifier 		; (already case converted outside string constants)
.d3c1	b3c1	c9 41		cmp #$41			cmp 	#'A'
.d3c3	b3c3	90 04		bcc $b3c9			bcc 	_TKTokenisePunctuation
.d3c5	b3c5	c9 5b		cmp #$5b			cmp 	#'Z'+1
.d3c7	b3c7	90 60		bcc $b429			bcc 	_TKTokeniseIdentifier
.d3c9	b3c9					_TKTokenisePunctuation:
.d3c9	b3c9	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.d3cb	b3cb	f0 2e		beq $b3fb			beq 	_TKString
.d3cd	b3cd	c9 24		cmp #$24			cmp 	#'$'						; hexadecimal constant ($ only appears at end of identifiers)
.d3cf	b3cf	f0 2f		beq $b400			beq 	_TKHexConstant
.d3d1	b3d1	c9 3c		cmp #$3c			cmp 	#'<' 						; check for < > handlers - these are for <> <= >= >> <<
.d3d3	b3d3	f0 36		beq $b40b			beq 	_TKCheckDouble
.d3d5	b3d5	c9 3e		cmp #$3e			cmp 	#'>'
.d3d7	b3d7	f0 32		beq $b40b			beq 	_TKCheckDouble
.d3d9	b3d9					_TKStandardPunctuation:
.d3d9	b3d9	bd 26 05	lda $0526,x			lda 	lineBuffer,x 				; get the punctuation token back.
.d3dc	b3dc	c9 40		cmp #$40			cmp 	#64 						; are we >= 64
.d3de	b3de	90 0e		bcc $b3ee			bcc 	_TKNoShift
.d3e0	b3e0	48		pha				pha 								; save. we are about to convert this punctuation token from
.d3e1	b3e1	29 07		and #$07			and 	#7 							; lower 3 bits in zTemp0
.d3e3	b3e3	85 36		sta $36				sta 	zTemp0
.d3e5	b3e5	68		pla				pla
.d3e6	b3e6	29 20		and #$20			and 	#32 						; bit 5
.d3e8	b3e8	4a		lsr a				lsr 	a 							; shift into bit 3
.d3e9	b3e9	4a		lsr a				lsr 	a
.d3ea	b3ea	05 36		ora $36				ora 	zTemp0
.d3ec	b3ec	09 10		ora #$10			ora 	#$10						; now in the range 16-31
.d3ee	b3ee					_TKNoShift:
.d3ee	b3ee	20 c9 b5	jsr $b5c9			jsr 	TOKWriteByte 				; write the punctuation character
.d3f1	b3f1	e8		inx				inx 								; consume the character
.d3f2	b3f2	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; quote found ?
.d3f4	b3f4	d0 bc		bne $b3b2			bne 	_TKTokeniseLoop 			; and loop round again.
.d3f6	b3f6	20 bc b4	jsr $b4bc			jsr 	TOKCheckComment 			; comment checl
.d3f9	b3f9	80 b7		bra $b3b2			bra 	_TKTokeniseLoop
.d3fb	b3fb					_TKString:
.d3fb	b3fb	20 e9 b4	jsr $b4e9			jsr 	TOKTokenString
.d3fe	b3fe	80 b2		bra $b3b2			bra 	_TKTokeniseLoop
.d400	b400					_TKHexConstant:
.d400	b400	20 24 b5	jsr $b524			jsr 	TOKHexConstant
.d403	b403	80 ad		bra $b3b2			bra 	_TKTokeniseLoop
.d405	b405	a9 80		lda #$80	_TKExit:lda 	#KWC_EOL 					; write end of line byte
.d407	b407	20 c9 b5	jsr $b5c9			jsr 	TOKWriteByte
.d40a	b40a	60		rts				rts
.d40b	b40b					_TKCheckDouble:
.d40b	b40b	bd 27 05	lda $0527,x			lda 	lineBuffer+1,x 				; get next character
.d40e	b40e	c9 3c		cmp #$3c			cmp 	#'<'						; if not < = > which are ASCII consecutive go back
.d410	b410	90 c7		bcc $b3d9			bcc 	_TKStandardPunctuation 		; and do the normal punctuation handler.
.d412	b412	c9 3f		cmp #$3f			cmp 	#'>'+1
.d414	b414	b0 c3		bcs $b3d9			bcs 	_TKStandardPunctuation
.d416	b416	bd 26 05	lda $0526,x			lda 	lineBuffer,x 				; this is < (60) or > (62)
.d419	b419	29 02		and #$02			and 	#2 							; now < (0) or > (2)
.d41b	b41b	0a		asl a				asl 	a 							; now < (0) or > (4), CC also
.d41c	b41c	7d 27 05	adc $0527,x			adc 	lineBuffer+1,x 				; add < = > codes - < code
.d41f	b41f	38		sec				sec
.d420	b420	e9 3c		sbc #$3c			sbc 	#'<'
.d422	b422	20 c9 b5	jsr $b5c9			jsr 	TOKWriteByte 				; this is in the range 0-7
.d425	b425	e8		inx				inx 								; consume both
.d426	b426	e8		inx				inx
.d427	b427	80 89		bra $b3b2			bra 	_TKTokeniseLoop
.d429	b429					_TKTokeniseIdentifier:
.d429	b429	8e 00 04	stx $0400			stx 	identStart 					; save start
.d42c	b42c	9c 04 04	stz $0404			stz 	identTypeByte 				; zero the type byte
.d42f	b42f					_TKCheckLoop:
.d42f	b42f	e8		inx				inx 								; look at next, we know first is identifier already.
.d430	b430	bd 26 05	lda $0526,x			lda  	lineBuffer,x
.d433	b433	c9 5f		cmp #$5f			cmp 	#"_" 						; legal char _ 0-9 A-Z
.d435	b435	f0 f8		beq $b42f			beq 	_TKCheckLoop
.d437	b437	c9 30		cmp #$30			cmp	 	#"0"
.d439	b439	90 0c		bcc $b447			bcc 	_TKEndIdentifier
.d43b	b43b	c9 3a		cmp #$3a			cmp 	#"9"+1
.d43d	b43d	90 f0		bcc $b42f			bcc 	_TKCheckLoop
.d43f	b43f	c9 41		cmp #$41			cmp	 	#"A"
.d441	b441	90 04		bcc $b447			bcc 	_TKEndIdentifier
.d443	b443	c9 5b		cmp #$5b			cmp 	#"Z"+1
.d445	b445	90 e8		bcc $b42f			bcc 	_TKCheckLoop
.d447	b447					_TKEndIdentifier:
.d447	b447	8e 01 04	stx $0401			stx 	identTypeStart 				; save start of type text (if any !)
.d44a	b44a	a0 08		ldy #$08			ldy 	#$08 						; this is the identifier type byte for #
.d44c	b44c	c9 23		cmp #$23			cmp 	#"#"						; followed by #
.d44e	b44e	f0 06		beq $b456			beq 	_TKHasTypeCharacter
.d450	b450	a0 10		ldy #$10			ldy 	#$10 						; this is the identifier type byte for $
.d452	b452	c9 24		cmp #$24			cmp 	#"$"						; followed by $ or #
.d454	b454	d0 07		bne $b45d			bne 	_TKNoTypeCharacter
.d456	b456					_TKHasTypeCharacter:
.d456	b456	8c 04 04	sty $0404			sty 	identTypeByte 				; has # or $, save the type
.d459	b459	e8		inx				inx 								; consume the type character
.d45a	b45a	bd 26 05	lda $0526,x			lda 	lineBuffer,x
.d45d	b45d					_TKNoTypeCharacter:
.d45d	b45d	c9 28		cmp #$28			cmp 	#"("						; is it open parenthesis (e.g. array)
.d45f	b45f	d0 09		bne $b46a			bne 	_TKNoArray
.d461	b461	e8		inx				inx 								; skip the (
.d462	b462	ad 04 04	lda $0404			lda 	identTypeByte 				; set bit 2 (e.g. array) in type byte
.d465	b465	09 04		ora #$04			ora 	#$04
.d467	b467	8d 04 04	sta $0404			sta 	identTypeByte
.d46a	b46a					_TKNoArray:
.d46a	b46a	8e 02 04	stx $0402			stx 	identTypeEnd 				; save end marker, e.g. continue from here.
.d46d	b46d	20 45 b5	jsr $b545			jsr 	TOKCalculateHash 			; calculate the has for those tokens
.d470	b470	a0 ac		ldy #$ac			ldy 	#(KeywordSet0) >> 8
.d472	b472	a9 40		lda #$40			lda 	#(KeywordSet0) & $FF
.d474	b474	20 34 b3	jsr $b334			jsr 	TOKSearchTable
.d477	b477	a2 00		ldx #$00			ldx 	#0
.d479	b479	b0 1f		bcs $b49a			bcs 	_TKFoundToken
.d47b	b47b	a0 ae		ldy #$ae			ldy 	#(KeywordSet1) >> 8
.d47d	b47d	a9 b1		lda #$b1			lda 	#(KeywordSet1) & $FF
.d47f	b47f	20 34 b3	jsr $b334			jsr 	TOKSearchTable
.d482	b482	a2 81		ldx #$81			ldx 	#$81
.d484	b484	b0 14		bcs $b49a			bcs 	_TKFoundToken
.d486	b486	a0 af		ldy #$af			ldy 	#(KeywordSet2) >> 8
.d488	b488	a9 ad		lda #$ad			lda 	#(KeywordSet2) & $FF
.d48a	b48a	20 34 b3	jsr $b334			jsr 	TOKSearchTable
.d48d	b48d	a2 82		ldx #$82			ldx 	#$82
.d48f	b48f	b0 09		bcs $b49a			bcs 	_TKFoundToken
.d491	b491	20 d5 b5	jsr $b5d5			jsr 	TOKCheckCreateVariableRecord ; failed all, it's a variable, create record if does not exist.
.d494	b494	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.d497	b497	4c b2 b3	jmp $b3b2			jmp 	_TKTokeniseLoop 			; and go round again.
.d49a	b49a					_TKFoundToken:
.d49a	b49a	48		pha				pha 								; save token
.d49b	b49b	8a		txa				txa 								; shift in X, is there one ?
.d49c	b49c	f0 03		beq $b4a1			beq 	_TKNoTShift
.d49e	b49e	20 c9 b5	jsr $b5c9			jsr 	TOKWriteByte 				; if so, write it out
.d4a1	b4a1					_TKNoTShift:
.d4a1	b4a1	68		pla				pla 								; restore and write token
.d4a2	b4a2	20 c9 b5	jsr $b5c9			jsr 	TOKWriteByte
.d4a5	b4a5	e0 00		cpx #$00			cpx 	#0 							; check for REM and '
.d4a7	b4a7	d0 0d		bne $b4b6			bne 	_TKNotRem 			 		; not shifted ?
.d4a9	b4a9	c9 d6		cmp #$d6			cmp 	#KWD_REM
.d4ab	b4ab	d0 09		bne $b4b6			bne 	_TKNotRem
.d4ad	b4ad	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; check if comment follows.
.d4b0	b4b0	20 bc b4	jsr $b4bc			jsr 	TOKCheckComment
.d4b3	b4b3	4c b2 b3	jmp $b3b2			jmp 	_TKTokeniseLoop
.d4b6	b4b6					_TKNotRem:
.d4b6	b4b6	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.d4b9	b4b9	4c b2 b3	jmp $b3b2			jmp 	_TKTokeniseLoop 			; and go round again.
.d4bc	b4bc					TOKCheckComment:
.d4bc	b4bc	bd 26 05	lda $0526,x			lda 	lineBuffer,x 				; skip over space
.d4bf	b4bf	e8		inx				inx
.d4c0	b4c0	c9 20		cmp #$20			cmp 	#' '
.d4c2	b4c2	f0 f8		beq $b4bc			beq 	TOKCheckComment
.d4c4	b4c4	ca		dex				dex 								; first non space character
.d4c5	b4c5	c9 22		cmp #$22			cmp 	#'"'						; quote mark
.d4c7	b4c7	f0 1f		beq $b4e8			beq 	_TOKCCExit 					; then we are okay
.d4c9	b4c9	c9 00		cmp #$00			cmp 	#0 							; EOL
.d4cb	b4cb	f0 1b		beq $b4e8			beq 	_TOKCCExit 					; then we are okay
.d4cd	b4cd	da		phx				phx
.d4ce	b4ce					_TOKCCLowerCase:
.d4ce	b4ce	bd 26 05	lda $0526,x			lda 	lineBuffer,x 				; about making it lower case it all, but I thought
.d4d1	b4d1	c9 41		cmp #$41			cmp 	#"A"		 				; that was a bit risky. So it's converted to L/C here.
.d4d3	b4d3	90 09		bcc $b4de			bcc 	_TOKKCNotUC
.d4d5	b4d5	c9 5b		cmp #$5b			cmp 	#"Z"+1
.d4d7	b4d7	b0 05		bcs $b4de			bcs 	_TOKKCNotUC
.d4d9	b4d9	49 20		eor #$20			eor 	#$20
.d4db	b4db	9d 26 05	sta $0526,x			sta 	lineBuffer,x
.d4de	b4de					_TOKKCNotUC:
.d4de	b4de	e8		inx				inx
.d4df	b4df	c9 00		cmp #$00			cmp 	#0
.d4e1	b4e1	d0 eb		bne $b4ce			bne 	_TOKCCLowerCase
.d4e3	b4e3	fa		plx				plx
.d4e4	b4e4	ca		dex				dex 								; tokenise string expects initial skip.
.d4e5	b4e5	20 e9 b4	jsr $b4e9			jsr 	TOKTokenString 				; tokenise rest of line as a string.
.d4e8	b4e8					_TOKCCExit:
.d4e8	b4e8	60		rts				rts
.d4e9	b4e9					TOKTokenString:
.d4e9	b4e9	a9 ff		lda #$ff			lda 	#KWC_STRING 				; string token.
.d4eb	b4eb	20 c9 b5	jsr $b5c9			jsr 	TOKWriteByte
.d4ee	b4ee	e8		inx				inx									; start of quoted string.
.d4ef	b4ef	da		phx				phx 								; push start of string on top
.d4f0	b4f0	ca		dex				dex 								; because we pre-increment
.d4f1	b4f1					_TSFindEnd:
.d4f1	b4f1	e8		inx				inx
.d4f2	b4f2	bd 26 05	lda $0526,x			lda 	lineBuffer,x 				; next character
.d4f5	b4f5	f0 04		beq $b4fb			beq 	_TSEndOfString 				; no matching quote, we don't mind.
.d4f7	b4f7	c9 22		cmp #$22			cmp 	#'"' 						; go back if quote not found
.d4f9	b4f9	d0 f6		bne $b4f1			bne 	_TSFindEnd
.d4fb	b4fb					_TSEndOfString:
.d4fb	b4fb	7a		ply				ply  								; so now Y is first character, X is character after end.
.d4fc	b4fc	48		pha				pha 								; save terminating character
.d4fd	b4fd	20 05 b5	jsr $b505			jsr 	TOKWriteBlockXY 			; write X to Y as a data block
.d500	b500	68		pla				pla 								; terminating character
.d501	b501	f0 01		beq $b504			beq 	_TSNotQuote					; if it wasn't EOS skip it
.d503	b503	e8		inx				inx
.d504	b504					_TSNotQuote:
.d504	b504	60		rts				rts
.d505	b505					TOKWriteBlockXY:
.d505	b505	86 36		stx $36				stx 	zTemp0 						; save end character
.d507	b507	98		tya				tya 								; use 2's complement to work out the byte size
.d508	b508	49 ff		eor #$ff			eor 	#$FF
.d50a	b50a	38		sec				sec
.d50b	b50b	65 36		adc $36				adc 	zTemp0
.d50d	b50d	1a		inc a				inc 	a 							; one extra for NULL
.d50e	b50e	20 c9 b5	jsr $b5c9			jsr 	TOKWriteByte
.d511	b511					_TOBlockLoop:
.d511	b511	c4 36		cpy $36				cpy 	zTemp0 						; exit if reached the end
.d513	b513	f0 09		beq $b51e			beq 	_TOBlockExit
.d515	b515	b9 26 05	lda $0526,y			lda 	lineBuffer,y 				; write byte out.
.d518	b518	20 c9 b5	jsr $b5c9			jsr 	TOKWriteByte
.d51b	b51b	c8		iny				iny
.d51c	b51c	80 f3		bra $b511			bra 	_TOBlockLoop
.d51e	b51e					_TOBlockExit:
.d51e	b51e	a9 00		lda #$00			lda 	#0 							; add NULL.
.d520	b520	20 c9 b5	jsr $b5c9			jsr 	TOKWriteByte
.d523	b523	60		rts				rts
.d524	b524					TOKHexConstant:
.d524	b524	a9 fe		lda #$fe			lda 	#KWC_HEXCONST 				; hex constant token.
.d526	b526	20 c9 b5	jsr $b5c9			jsr 	TOKWriteByte
.d529	b529	e8		inx				inx									; start of quoted string.
.d52a	b52a	da		phx				phx 								; push start of constant on top
.d52b	b52b	ca		dex				dex
.d52c	b52c					_THFindLoop:
.d52c	b52c	e8		inx				inx 	 							; this is stored in a block, so find out how long
.d52d	b52d	bd 26 05	lda $0526,x			lda 	lineBuffer,x 				; the hex constant is.
.d530	b530	c9 30		cmp #$30			cmp 	#"0"
.d532	b532	90 0c		bcc $b540			bcc 	_THFoundEnd
.d534	b534	c9 3a		cmp #$3a			cmp 	#"9"+1
.d536	b536	90 f4		bcc $b52c			bcc 	_THFindLoop
.d538	b538	c9 41		cmp #$41			cmp 	#"A"
.d53a	b53a	90 04		bcc $b540			bcc 	_THFoundEnd
.d53c	b53c	c9 47		cmp #$47			cmp 	#"F"+1
.d53e	b53e	90 ec		bcc $b52c			bcc 	_THFindLoop
.d540	b540					_THFoundEnd:
.d540	b540	7a		ply				ply 								; restore start
.d541	b541	20 05 b5	jsr $b505			jsr 	TOKWriteBlockXY 			; output the block
.d544	b544	60		rts				rts
.d545	b545					TOKCalculateHash:
.d545	b545	da		phx				phx
.d546	b546	ae 00 04	ldx $0400			ldx 	identStart 					; needs to be same as in tokens.py - simple sum at present.
.d549	b549	a9 00		lda #$00			lda 	#0
.d54b	b54b					_TCHLoop:
.d54b	b54b	18		clc				clc
.d54c	b54c	7d 26 05	adc $0526,x			adc 	lineBuffer,x
.d54f	b54f	e8		inx				inx
.d550	b550	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; do the whole thing including type and array markers.
.d553	b553	d0 f6		bne $b54b			bne 	_TCHLoop
.d555	b555	8d 03 04	sta $0403			sta 	identHash 					; save the hash
.d558	b558	fa		plx				plx
.d559	b559	60		rts				rts
.d55a	b55a					LCLFixLineBufferCase:
.d55a	b55a	a2 00		ldx #$00			ldx 	#0
.d55c	b55c					_FLBCLoop:
.d55c	b55c	bd 26 05	lda $0526,x			lda 	lineBuffer,x 				; get next character
.d55f	b55f	f0 22		beq $b583			beq 	_FLBCExit 					; end of string.
.d561	b561	c9 22		cmp #$22			cmp 	#'"'						; quote, go to in quotes
.d563	b563	f0 11		beq $b576			beq 	_FLBCInQuotes
.d565	b565	e8		inx				inx
.d566	b566	c9 61		cmp #$61			cmp 	#'a'						; needs capitalising ?
.d568	b568	90 f2		bcc $b55c			bcc 	_FLBCLoop
.d56a	b56a	c9 7b		cmp #$7b			cmp 	#'z'+1
.d56c	b56c	b0 ee		bcs $b55c			bcs 	_FLBCLoop
.d56e	b56e	38		sec				sec 								; make U/C
.d56f	b56f	e9 20		sbc #$20			sbc 	#32
.d571	b571	9d 25 05	sta $0525,x			sta	 	lineBuffer-1,x 				; write back
.d574	b574	80 e6		bra $b55c			bra 	_FLBCLoop
.d576	b576					_FLBCInQuotes:
.d576	b576	e8		inx				inx 								; advance
.d577	b577	bd 26 05	lda $0526,x			lda 	lineBuffer,x 				; get next
.d57a	b57a	f0 07		beq $b583			beq 	_FLBCExit 					; exit on EOS
.d57c	b57c	c9 22		cmp #$22			cmp 	#'"' 				 		; until " found
.d57e	b57e	d0 f6		bne $b576			bne 	_FLBCInQuotes
.d580	b580	e8		inx				inx 								; skip over it
.d581	b581	80 d9		bra $b55c			bra 	_FLBCLoop
.d583	b583					_FLBCExit:
.d583	b583	60		rts				rts
.d584	b584					TOKExtractLineNumber:
.d584	b584	ad 28 04	lda $0428			lda 	tokenLineNumber+1 			; push current value on stack
.d587	b587	48		pha				pha
.d588	b588	ad 27 04	lda $0427			lda 	tokenLineNumber
.d58b	b58b	48		pha				pha
.d58c	b58c	20 c2 b5	jsr $b5c2			jsr 	_LCLNTimes2 				; line # x 2
.d58f	b58f	20 c2 b5	jsr $b5c2			jsr 	_LCLNTimes2 				; line # x 4
.d592	b592	18		clc				clc 								; add stacked value
.d593	b593	68		pla				pla
.d594	b594	6d 27 04	adc $0427			adc 	tokenLineNumber
.d597	b597	8d 27 04	sta $0427			sta 	tokenLineNumber
.d59a	b59a	68		pla				pla
.d59b	b59b	6d 28 04	adc $0428			adc 	tokenLineNumber+1
.d59e	b59e	8d 28 04	sta $0428			sta 	tokenLineNumber+1 			; line # x 5
.d5a1	b5a1	20 c2 b5	jsr $b5c2			jsr 	_LCLNTimes2 				; line # x 10
.d5a4	b5a4	bd 26 05	lda $0526,x			lda 	lineBuffer,x 				; get and consume character
.d5a7	b5a7	e8		inx				inx
.d5a8	b5a8	29 0f		and #$0f			and 	#15 						; add to line #
.d5aa	b5aa	18		clc				clc
.d5ab	b5ab	6d 27 04	adc $0427			adc 	tokenLineNumber
.d5ae	b5ae	8d 27 04	sta $0427			sta 	tokenLineNumber
.d5b1	b5b1	90 03		bcc $b5b6			bcc 	_TLENNoCarry
.d5b3	b5b3	ee 28 04	inc $0428			inc 	tokenLineNumber+1
.d5b6	b5b6					_TLENNoCarry:
.d5b6	b5b6	bd 26 05	lda $0526,x			lda 	lineBuffer,x 				; more digits ?
.d5b9	b5b9	c9 30		cmp #$30			cmp 	#'0'
.d5bb	b5bb	90 04		bcc $b5c1			bcc 	_TLENExit
.d5bd	b5bd	c9 3a		cmp #$3a			cmp 	#'9'+1
.d5bf	b5bf	90 c3		bcc $b584			bcc 	TOKExtractLineNumber
.d5c1	b5c1					_TLENExit:
.d5c1	b5c1	60		rts				rts
.d5c2	b5c2					_LCLNTimes2:
.d5c2	b5c2	0e 27 04	asl $0427			asl 	tokenLineNumber 			; doubles tokenLineNumber.
.d5c5	b5c5	2e 28 04	rol $0428			rol 	tokenLineNumber+1
.d5c8	b5c8	60		rts				rts
.d5c9	b5c9					TOKWriteByte:
.d5c9	b5c9	da		phx				phx
.d5ca	b5ca	ae 26 04	ldx $0426			ldx 	tokenOffset 				; next slot to write to
.d5cd	b5cd	9d 26 04	sta $0426,x			sta 	tokenOffset,x 				; write byte out
.d5d0	b5d0	ee 26 04	inc $0426			inc 	tokenOffset 				; advance slot.
.d5d3	b5d3	fa		plx				plx
.d5d4	b5d4	60		rts				rts
.d5d5	b5d5					TOKCheckCreateVariableRecord:
.d5d5	b5d5	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.d5d7	b5d7	85 36		sta $36				sta 	0+zTemp0
.d5d9	b5d9	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.d5db	b5db	85 37		sta $37				sta 	1+zTemp0
.d5dd	b5dd					_CCVSearch:
.d5dd	b5dd	b2 36		lda ($36)			lda 	(zTemp0) 					; end of list
.d5df	b5df	f0 2c		beq $b60d			beq 	_CCVFail
.d5e1	b5e1	a0 01		ldy #$01			ldy 	#1 							; read the hash
.d5e3	b5e3	b1 36		lda ($36),y			lda 	(zTemp0),y 					; does it match ?
.d5e5	b5e5	cd 03 04	cmp $0403			cmp 	identHash 	  				; if not, try the next.
.d5e8	b5e8	d0 16		bne $b600			bne 	_CCVNext
.d5ea	b5ea	a0 08		ldy #$08			ldy 	#8 							; name in variable record
.d5ec	b5ec	ae 00 04	ldx $0400			ldx 	identStart
.d5ef	b5ef					_CCVCompare:
.d5ef	b5ef	bd 26 05	lda $0526,x			lda 	lineBuffer,x 				; xor them. zero if the same, except
.d5f2	b5f2	51 36		eor ($36),y			eor 	(zTemp0),y 					; bit 7 is used for EOS.
.d5f4	b5f4	e8		inx				inx 								; advance pointers
.d5f5	b5f5	c8		iny				iny
.d5f6	b5f6	0a		asl a				asl 	a 							; A = 0 if they match, CS if end.
.d5f7	b5f7	d0 07		bne $b600			bne 	_CCVNext  					; didn't match go to next.
.d5f9	b5f9	90 f4		bcc $b5ef			bcc 	_CCVCompare 				; not finished yet.
.d5fb	b5fb	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; matched whole thing ?
.d5fe	b5fe	f0 41		beq $b641			beq 	_CCVFound 					; yes, we were successful
.d600	b600					_CCVNext:
.d600	b600	18		clc				clc 								; go to next record.
.d601	b601	b2 36		lda ($36)			lda 	(zTemp0) 					; add offset to pointer
.d603	b603	65 36		adc $36				adc 	zTemp0
.d605	b605	85 36		sta $36				sta 	zTemp0
.d607	b607	90 d4		bcc $b5dd			bcc 	_CCVSearch
.d609	b609	e6 37		inc $37				inc 	zTemp0+1
.d60b	b60b	80 d0		bra $b5dd			bra 	_CCVSearch
.d60d	b60d					_CCVFail:
.d60d	b60d	a0 01		ldy #$01			ldy 	#1 							; create the new record. Offset 1 is hash
.d60f	b60f	ad 03 04	lda $0403			lda 	identHash
.d612	b612	91 36		sta ($36),y			sta 	(zTemp0),y
.d614	b614	c8		iny				iny 								; offset 2 is the type byte
.d615	b615	ad 04 04	lda $0404			lda 	identTypeByte
.d618	b618	91 36		sta ($36),y			sta 	(zTemp0),y
.d61a	b61a	c8		iny				iny
.d61b	b61b					_CCVData:
.d61b	b61b	a9 00		lda #$00			lda 	#0 							; erase data 3-7 (the 5 value bytes)
.d61d	b61d	91 36		sta ($36),y			sta 	(zTemp0),y
.d61f	b61f	c8		iny				iny
.d620	b620	c0 08		cpy #$08			cpy 	#8
.d622	b622	90 f7		bcc $b61b			bcc 	_CCVData
.d624	b624	ae 00 04	ldx $0400			ldx 	identStart 					; copy name into 8 on.
.d627	b627					_CCVCopyName:
.d627	b627	bd 26 05	lda $0526,x			lda 	lineBuffer,x
.d62a	b62a	91 36		sta ($36),y			sta 	(zTemp0),y
.d62c	b62c	e8		inx				inx
.d62d	b62d	c8		iny				iny
.d62e	b62e	ec 02 04	cpx $0402			cpx 	identTypeEnd
.d631	b631	d0 f4		bne $b627			bne 	_CCVCopyName
.d633	b633	98		tya				tya 								; patch offset
.d634	b634	92 36		sta ($36)			sta 	(zTemp0)
.d636	b636	a9 00		lda #$00			lda 	#0 							; offset for next is zero.
.d638	b638	91 36		sta ($36),y			sta 	(zTemp0),y
.d63a	b63a	88		dey				dey
.d63b	b63b	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set bit 7 of last bit
.d63d	b63d	09 80		ora #$80			ora 	#$80
.d63f	b63f	91 36		sta ($36),y			sta 	(zTemp0),y
.d641	b641					_CCVFound:
.d641	b641	a5 37		lda $37				lda 	zTemp0+1 					; write out MSB
.d643	b643	38		sec				sec
.d644	b644	e9 10		sbc #$10			sbc 	#(VariableSpace >> 8) 		; offset from the start of the variable token
.d646	b646	09 40		ora #$40			ora 	#$40 						; make it a writeable token $4000-$7FFF
.d648	b648	20 c9 b5	jsr $b5c9			jsr 	TOKWriteByte
.d64b	b64b	a5 36		lda $36				lda 	zTemp0 						; write out LSB
.d64d	b64d	20 c9 b5	jsr $b5c9			jsr 	TOKWriteByte
.d650	b650	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_sound.module

=1						soundIntegrated=1
.d651	b651					SNDCheckChannel:
.d651	b651	aa		tax				tax
.d652	b652	bd 7f 09	lda $097f,x			lda 	SNDTimeLeft,x 				; currently playing a note
.d655	b655	d0 38		bne $b68f			bne 	_SNDCCExit
.d657	b657	da		phx				phx 								; save current channel
.d658	b658	8a		txa				txa 								; put in A
.d659	b659	20 d5 b6	jsr $b6d5			jsr 	SNDFindNextNoteForA 		; is there a note for A in the queue ?
.d65c	b65c	68		pla				pla 								; channel # in A
.d65d	b65d	90 30		bcc $b68f			bcc 	_SNDCCExit  				; nothing in the queue for this channel, exit.
.d65f	b65f	a8		tay				tay 								; Y is the channel #
.d660	b660	bd 74 08	lda $0874,x			lda 	SNDQueue+1,x 				; copy data into the slot.
.d663	b663	99 73 09	sta $0973,y			sta 	SNDPitchLow,y
.d666	b666	bd 75 08	lda $0875,x			lda 	SNDQueue+2,x
.d669	b669	99 77 09	sta $0977,y			sta 	SNDPitchHigh,y
.d66c	b66c	bd 76 08	lda $0876,x			lda 	SNDQueue+3,x
.d66f	b66f	99 7b 09	sta $097b,y			sta 	SNDVolume,y
.d672	b672	bd 77 08	lda $0877,x			lda 	SNDQueue+4,x
.d675	b675	99 7f 09	sta $097f,y			sta 	SNDTimeLeft,y
.d678	b678	bd 78 08	lda $0878,x			lda 	SNDQueue+5,x
.d67b	b67b	99 83 09	sta $0983,y			sta 	SNDAdjustLow,y
.d67e	b67e	bd 79 08	lda $0879,x			lda 	SNDQueue+6,x
.d681	b681	99 87 09	sta $0987,y			sta 	SNDAdjustHigh,y
.d684	b684	5a		phy				phy 								; save channel #
.d685	b685	20 ef b6	jsr $b6ef			jsr 	SNDDeleteXFromQueue 		; delete record at X from queue
.d688	b688	ce 72 08	dec $0872			dec 	SNDLength 					; reduce the queue length.
.d68b	b68b	68		pla				pla
.d68c	b68c	20 90 b6	jsr $b690			jsr 	SNDUpdateNote 				; update channel A
.d68f	b68f					_SNDCCExit:
.d68f	b68f	60		rts				rts
.d690	b690					SNDUpdateNote:
.d690	b690	aa		tax				tax 								; so we can access records
.d691	b691	0a		asl a				asl 	a 							; convert it to a channel bit pair in 5,6
.d692	b692	0a		asl a				asl 	a
.d693	b693	0a		asl a				asl 	a
.d694	b694	0a		asl a				asl 	a
.d695	b695	0a		asl a				asl 	a
.d696	b696	8d 71 08	sta $0871			sta 	SNDChannelBits
.d699	b699	bd 7f 09	lda $097f,x			lda 	SNDTimeLeft,x 				; are we silent
.d69c	b69c	f0 2e		beq $b6cc			beq 	_SNDUNIsSilent
.d69e	b69e	ad 71 08	lda $0871			lda 	SNDChannelBits 				; push channel bits on stack
.d6a1	b6a1	48		pha				pha
.d6a2	b6a2	bd 73 09	lda $0973,x			lda 	SNDPitchLow,x 				; get 4 lowest bits of pitch.
.d6a5	b6a5	29 0f		and #$0f			and 	#$0F
.d6a7	b6a7	0d 71 08	ora $0871			ora 	SNDChannelBits 				; set channel bits
.d6aa	b6aa	09 80		ora #$80			ora 	#$80 						; write to pitch register
.d6ac	b6ac	20 39 b7	jsr $b739			jsr 	SNDWritePorts
.d6af	b6af	bd 77 09	lda $0977,x			lda 	SNDPitchHigh,x 				; pitch high => channel temp.
.d6b2	b6b2	8d 71 08	sta $0871			sta 	SNDChannelBits
.d6b5	b6b5	bd 73 09	lda $0973,x			lda 	SNDPitchLow,x
.d6b8	b6b8	4e 71 08	lsr $0871			lsr 	SNDChannelBits 				; shift 2 LSBs into MSB of A
.d6bb	b6bb	6a		ror a				ror 	a
.d6bc	b6bc	4e 71 08	lsr $0871			lsr 	SNDChannelBits
.d6bf	b6bf	6a		ror a				ror 	a
.d6c0	b6c0	4a		lsr a				lsr 	a 							; put in bits 0-5
.d6c1	b6c1	4a		lsr a				lsr 	a
.d6c2	b6c2	20 39 b7	jsr $b739			jsr 	SNDWritePorts 				; write as rest of pitch register
.d6c5	b6c5	68		pla				pla
.d6c6	b6c6	09 90		ora #$90			ora 	#$90 						; set to write minimum attentuation.
.d6c8	b6c8	20 39 b7	jsr $b739			jsr 	SNDWritePorts
.d6cb	b6cb	60		rts				rts
.d6cc	b6cc					_SNDUNIsSilent:
.d6cc	b6cc	ad 71 08	lda $0871			lda 	SNDChannelBits 				; channel bits
.d6cf	b6cf	09 9f		ora #$9f			ora 	#$9F 						; maximum attenuation
.d6d1	b6d1	20 39 b7	jsr $b739			jsr 	SNDWritePorts 				; write to the ports
.d6d4	b6d4	60		rts				rts
.d6d5	b6d5					SNDFindNextNoteForA:
.d6d5	b6d5	ac 72 08	ldy $0872			ldy 	SNDLength 					; queue size into Y
.d6d8	b6d8	f0 13		beq $b6ed			beq 	_SNDFNNFail 				; queue empty.
.d6da	b6da	a2 00		ldx #$00			ldx 	#0
.d6dc	b6dc					_SNDFNNSearch:
.d6dc	b6dc	dd 73 08	cmp $0873,x			cmp 	SNDQueue,x 					; does it match the channel
.d6df	b6df	38		sec				sec
.d6e0	b6e0	f0 0c		beq $b6ee			beq 	_SNDFNNExit 				; if so exit with CS.
.d6e2	b6e2	e8		inx				inx 								; next queue slot.
.d6e3	b6e3	e8		inx				inx
.d6e4	b6e4	e8		inx				inx
.d6e5	b6e5	e8		inx				inx
.d6e6	b6e6	e8		inx				inx
.d6e7	b6e7	e8		inx				inx
.d6e8	b6e8	e8		inx				inx
.d6e9	b6e9	e8		inx				inx
.d6ea	b6ea	88		dey				dey 								; done the whole queue
.d6eb	b6eb	d0 ef		bne $b6dc			bne 	_SNDFNNSearch 				; no, go back.
.d6ed	b6ed					_SNDFNNFail:
.d6ed	b6ed	18		clc				clc
.d6ee	b6ee					_SNDFNNExit:
.d6ee	b6ee	60		rts				rts
.d6ef	b6ef					SNDDeleteXFromQueue:
.d6ef	b6ef	e0 f8		cpx #$f8			cpx 	#SNDQueueSize*8-8 			; reached the end.
.d6f1	b6f1	f0 09		beq $b6fc			beq 	_SNDDXExit
.d6f3	b6f3	bd 7b 08	lda $087b,x			lda 	SNDQueue+8,x
.d6f6	b6f6	9d 73 08	sta $0873,x			sta 	SNDQueue,x
.d6f9	b6f9	e8		inx				inx
.d6fa	b6fa	80 f3		bra $b6ef			bra 	SNDDeleteXFromQueue
.d6fc	b6fc					_SNDDXExit:
.d6fc	b6fc	60		rts				rts
.0871						SNDChannelBits:
>0871								.fill 	1
.d6fd	b6fd					SNDQueueRequest:
.d6fd	b6fd	86 36		stx $36				stx 	zTemp0						; save queue address
.d6ff	b6ff	84 37		sty $37				sty 	zTemp0+1
.d701	b701	ae 72 08	ldx $0872			ldx 	SNDLength 					; queue is full, can't take any more.
.d704	b704	e0 20		cpx #$20			cpx 	#SNDQueueSize
.d706	b706	f0 21		beq $b729			beq 	_SNDQRExit
.d708	b708	29 03		and #$03			and 	#3	 						; channel # and push on stack
.d70a	b70a	48		pha				pha
.d70b	b70b	8a		txa				txa  								; get offset in queue buffer/
.d70c	b70c	0a		asl a				asl 	a
.d70d	b70d	0a		asl a				asl 	a
.d70e	b70e	0a		asl a				asl 	a
.d70f	b70f	aa		tax				tax
.d710	b710	68		pla				pla 								; get back and push again
.d711	b711	48		pha				pha
.d712	b712	9d 73 08	sta $0873,x			sta 	SNDQueue+0,x 				; save the channel #
.d715	b715	a0 00		ldy #$00			ldy 	#0 							; copy the rest in.
.d717	b717					_SNDQCopy:
.d717	b717	b1 36		lda ($36),y			lda 	(zTemp0),y
.d719	b719	e8		inx				inx
.d71a	b71a	c8		iny				iny
.d71b	b71b	9d 73 08	sta $0873,x			sta 	SNDQueue,x
.d71e	b71e	c0 06		cpy #$06			cpy 	#6
.d720	b720	d0 f5		bne $b717			bne 	_SNDQCopy
.d722	b722	ee 72 08	inc $0872			inc 	SNDLength 					; bump queue length.
.d725	b725	68		pla				pla 								; get channel # back
.d726	b726	20 51 b6	jsr $b651			jsr 	SNDCheckChannel 			; check if channel needs refreshing.
.d729	b729					_SNDQRExit:
.d729	b729	60		rts				rts
.d72a	b72a					SNDSilenceChannel:
.d72a	b72a	aa		tax				tax 								; zero time left.
.d72b	b72b	9e 7f 09	stz $097f,x			stz 	SNDTimeLeft,x
.d72e	b72e	0a		asl a				asl 	a 							; shift into position
.d72f	b72f	0a		asl a				asl 	a
.d730	b730	0a		asl a				asl 	a
.d731	b731	0a		asl a				asl 	a
.d732	b732	0a		asl a				asl 	a
.d733	b733	09 9f		ora #$9f			ora 	#$9F 						; write register attenuation $F
.d735	b735	20 39 b7	jsr $b739			jsr 	SNDWritePorts
.d738	b738	60		rts				rts
.d739	b739					SNDWritePorts:
.d739	b739	da		phx				phx 								; save X
.d73a	b73a	a6 01		ldx $01				ldx 	1 							; save I/O status
.d73c	b73c	64 01		stz $01				stz 	1 							; access I/O page 0
.d73e	b73e	8d 00 d6	sta $d600			sta 	$D600 						; write to both
.d741	b741	8d 10 d6	sta $d610			sta 	$D610
.d744	b744	86 01		stx $01				stx 	1 							; restore I/O
.d746	b746	fa		plx				plx 								; restore X
.d747	b747	60		rts				rts
.d748	b748					Export_SNDCommand:
.d748	b748	da		phx				phx 								; save XY
.d749	b749	5a		phy				phy
.d74a	b74a	c9 0f		cmp #$0f			cmp 	#$0F 						; $0F is initialise
.d74c	b74c	f0 1d		beq $b76b			beq 	_SNDInitialise
.d74e	b74e	90 28		bcc $b778			bcc 	_SNDExit
.d750	b750	c9 3f		cmp #$3f			cmp 	#$3F 						; $3F is silence all
.d752	b752	f0 17		beq $b76b			beq 	_SNDSilence
.d754	b754	b0 22		bcs $b778			bcs 	_SNDExit
.d756	b756	c9 20		cmp #$20			cmp 	#$20 						; $2x is check playing => A
.d758	b758	b0 09		bcs $b763			bcs 	_SNDQueryPlay
.d75a	b75a	c9 14		cmp #$14			cmp 	#$14 						; $10-$13 is queue sound
.d75c	b75c	b0 1a		bcs $b778			bcs 	_SNDExit
.d75e	b75e	20 fd b6	jsr $b6fd			jsr 	SNDQueueRequest
.d761	b761	80 15		bra $b778			bra 	_SNDExit
.d763	b763					_SNDQueryPlay:
.d763	b763	29 03		and #$03			and 	#3 							; get channel #
.d765	b765	aa		tax				tax
.d766	b766	bd 7f 09	lda $097f,x			lda 	SNDTimeLeft,x 				; read time left, if zero then silent
.d769	b769	80 0d		bra $b778			bra 	_SNDExit
.d76b	b76b					_SNDInitialise:
.d76b	b76b					_SNDSilence:
.d76b	b76b	9c 72 08	stz $0872			stz 	SNDLength 					; empty the queue.
.d76e	b76e	a9 03		lda #$03			lda 	#$3 						; silence channel 0-3.
.d770	b770					_SNDSilenceLoop:
.d770	b770	48		pha				pha
.d771	b771	20 2a b7	jsr $b72a			jsr 	SNDSilenceChannel
.d774	b774	68		pla				pla
.d775	b775	3a		dec a				dec 	a
.d776	b776	10 f8		bpl $b770			bpl 	_SNDSilenceLoop
.d778	b778					_SNDExit:
.d778	b778	7a		ply				ply
.d779	b779	fa		plx				plx
.d77a	b77a	60		rts				rts
=32						SNDQueueSize = 32 							; number of queue entries
.0872						SNDLength:
>0872								.fill 	1
.0873						SNDQueue:
>0873								.fill 	SNDQueueSize * 8
.0973						SNDPitchLow:
>0973								.fill 	4
.0977						SNDPitchHigh:
>0977								.fill 	4
.097b						SNDVolume:
>097b								.fill 	4
.097f						SNDTimeLeft:
>097f								.fill 	4
.0983						SNDAdjustLow:
>0983								.fill 	4
.0987						SNDAdjustHigh:
>0987								.fill 	4
.d77b	b77b					Export_SNDUpdate:
.d77b	b77b					PagedSNDUpdate:
.d77b	b77b	ad 7f 09	lda $097f			lda 	SNDTimeLeft+0 				; look at time remaining
.d77e	b77e	f0 05		beq $b785			beq 	_SNDUNot0 					; not playing
.d780	b780	a2 00		ldx #$00			ldx 	#0 							; so we know which channel to update
.d782	b782	20 a4 b7	jsr $b7a4			jsr 	SNDUpdateChannel 			; update it.
.d785	b785					_SNDUNot0:
.d785	b785	ad 80 09	lda $0980			lda 	SNDTimeLeft+1
.d788	b788	f0 05		beq $b78f			beq 	_SNDUNot1
.d78a	b78a	a2 01		ldx #$01			ldx 	#1
.d78c	b78c	20 a4 b7	jsr $b7a4			jsr 	SNDUpdateChannel
.d78f	b78f					_SNDUNot1:
.d78f	b78f	ad 81 09	lda $0981			lda 	SNDTimeLeft+2
.d792	b792	f0 05		beq $b799			beq 	_SNDUNot2
.d794	b794	a2 02		ldx #$02			ldx 	#2
.d796	b796	20 a4 b7	jsr $b7a4			jsr 	SNDUpdateChannel
.d799	b799					_SNDUNot2:
.d799	b799	ad 82 09	lda $0982			lda 	SNDTimeLeft+3
.d79c	b79c	f0 05		beq $b7a3			beq 	_SNDUNot3
.d79e	b79e	a2 03		ldx #$03			ldx 	#3
.d7a0	b7a0	20 a4 b7	jsr $b7a4			jsr 	SNDUpdateChannel
.d7a3	b7a3					_SNDUNot3:
.d7a3	b7a3	60		rts				rts
.d7a4	b7a4					SNDUpdateChannel:
.d7a4	b7a4	c9 ff		cmp #$ff			cmp 	#$FF 						; sound $FF play forever until turned off manually
.d7a6	b7a6	f0 2c		beq $b7d4			beq 	_SNDUCExit
.d7a8	b7a8	3a		dec a				dec 	a 							; decrement and update timer
.d7a9	b7a9	9d 7f 09	sta $097f,x			sta 	SNDTimeLeft,x
.d7ac	b7ac	f0 1d		beq $b7cb			beq 	_SNDUCUpdate 				; if zero, silence channel
.d7ae	b7ae	bd 83 09	lda $0983,x			lda 	SNDAdjustLow,x 				; adjust ?
.d7b1	b7b1	1d 87 09	ora $0987,x			ora 	SNDAdjustHigh,x
.d7b4	b7b4	f0 1e		beq $b7d4			beq 	_SNDUCExit 					; if zero carry on at current tone.
.d7b6	b7b6	18		clc				clc 								; add adjust, forcing into a 10 bit range
.d7b7	b7b7	bd 73 09	lda $0973,x			lda 	SNDPitchLow,x
.d7ba	b7ba	7d 83 09	adc $0983,x			adc 	SNDAdjustLow,x
.d7bd	b7bd	9d 73 09	sta $0973,x			sta 	SNDPitchLow,x
.d7c0	b7c0	bd 77 09	lda $0977,x			lda 	SNDPitchHigh,x
.d7c3	b7c3	7d 87 09	adc $0987,x			adc 	SNDAdjustHigh,x
.d7c6	b7c6	29 03		and #$03			and 	#3
.d7c8	b7c8	9d 77 09	sta $0977,x			sta 	SNDPitchHigh,x
.d7cb	b7cb					_SNDUCUpdate:
.d7cb	b7cb	8a		txa				txa 								; which channel.
.d7cc	b7cc	48		pha				pha
.d7cd	b7cd	20 90 b6	jsr $b690			jsr 	SNDUpdateNote 				; update the current note
.d7d0	b7d0	68		pla				pla
.d7d1	b7d1	20 51 b6	jsr $b651			jsr 	SNDCheckChannel 			; more to do ?
.d7d4	b7d4					_SNDUCExit:
.d7d4	b7d4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/hardware/header/headerdata.dat

=14						Header_Height = 14
=255						Header_RLE = 255
.e000	a000					Header_jattrs:
>e000	a000	ff 52 59 52 ff d8 07 d8			.byte	255,82,89,82,255,216,7,216,255,82,2,82,255,216,6,216,255,82,2,82,255,216,7,216,255,82,2,82,255,216,6,216,255,82,8,82,210,210,82,82,255,210,7,210,255,82,19,82,104,104,255,82,7,82,104,104,255,82,4,82,104,104,82,82,104,104,255,82,7,82,104,104,255,82,4,82,104,104,255,82,7,82,210,210,82,82,210,210,255,82,4,82,210,210,255,82,18,82,232,232,255,82,14,82,232,232,82,82,232,232,255,82,7,82,232,232,255,82,14,82,210,210,82,82,210,210,255,82,4,82,210,210,255,82,18,82,255,56,5,56,255,82,4,82,255,56,6,56,255,82,2,82,255,56,6,56,255,82,2,82,255,56,7,56,255,82,8,82,210,210,82,82,255,210,7,210,255,82,19,82,120,120,255,82,7,82,120,120,255,82,14,82,120,120,82,82,120,120,255,82,4,82,120,120,82,82,210,210,255,82,3,82,210,210,82,82,210,210,255,82,2,82,210,210,255,82,20,82,168,168,255,82,7,82,168,168,255,82,8,82,168,168,255,82,3,82,168,168,82,82,168,168,255,82,4,82,168,168,82,82,210,210,255,82,3,82,210,210,82,82,210,210,255,82,3,82,210,210,255,82,19,82,72,72,255,82,7,82,255,72,8,72,82,66,82,255,72,5,72,255,82,3,82,255,72,6,72,255,82,3,82,255,210,5,210,255,82,2,82,210,210,255,82,4,82,210,210,255,82,88,82,255,114,80,114,255,226,7,226,255,146,19,146,114,255,146,4,146,255,114,18,114,255,194,24,194,114,114,255,226,10,226,255,146,16,146,114,255,146,4,146,255,114,18,114,255,194,24,194,114,114,255,226,9,226,255,146,17,146,114,255,146,4,146,255,114,18,114,255,194,24,194,255,114,80,114,255,0
>e008	a008	ff 52 02 52 ff d8 06 d8 ff 52 02 52 ff d8 07 d8
>e018	a018	ff 52 02 52 ff d8 06 d8 ff 52 08 52 d2 d2 52 52
>e028	a028	ff d2 07 d2 ff 52 13 52 68 68 ff 52 07 52 68 68
>e038	a038	ff 52 04 52 68 68 52 52 68 68 ff 52 07 52 68 68
>e048	a048	ff 52 04 52 68 68 ff 52 07 52 d2 d2 52 52 d2 d2
>e058	a058	ff 52 04 52 d2 d2 ff 52 12 52 e8 e8 ff 52 0e 52
>e068	a068	e8 e8 52 52 e8 e8 ff 52 07 52 e8 e8 ff 52 0e 52
>e078	a078	d2 d2 52 52 d2 d2 ff 52 04 52 d2 d2 ff 52 12 52
>e088	a088	ff 38 05 38 ff 52 04 52 ff 38 06 38 ff 52 02 52
>e098	a098	ff 38 06 38 ff 52 02 52 ff 38 07 38 ff 52 08 52
>e0a8	a0a8	d2 d2 52 52 ff d2 07 d2 ff 52 13 52 78 78 ff 52
>e0b8	a0b8	07 52 78 78 ff 52 0e 52 78 78 52 52 78 78 ff 52
>e0c8	a0c8	04 52 78 78 52 52 d2 d2 ff 52 03 52 d2 d2 52 52
>e0d8	a0d8	d2 d2 ff 52 02 52 d2 d2 ff 52 14 52 a8 a8 ff 52
>e0e8	a0e8	07 52 a8 a8 ff 52 08 52 a8 a8 ff 52 03 52 a8 a8
>e0f8	a0f8	52 52 a8 a8 ff 52 04 52 a8 a8 52 52 d2 d2 ff 52
>e108	a108	03 52 d2 d2 52 52 d2 d2 ff 52 03 52 d2 d2 ff 52
>e118	a118	13 52 48 48 ff 52 07 52 ff 48 08 48 52 42 52 ff
>e128	a128	48 05 48 ff 52 03 52 ff 48 06 48 ff 52 03 52 ff
>e138	a138	d2 05 d2 ff 52 02 52 d2 d2 ff 52 04 52 d2 d2 ff
>e148	a148	52 58 52 ff 72 50 72 ff e2 07 e2 ff 92 13 92 72
>e158	a158	ff 92 04 92 ff 72 12 72 ff c2 18 c2 72 72 ff e2
>e168	a168	0a e2 ff 92 10 92 72 ff 92 04 92 ff 72 12 72 ff
>e178	a178	c2 18 c2 72 72 ff e2 09 e2 ff 92 11 92 72 ff 92
>e188	a188	04 92 ff 72 12 72 ff c2 18 c2 ff 72 50 72 ff 00
.e198	a198					Header_jchars:
>e198	a198	ff 20 59 20 ff 08 07 08			.byte	255,32,89,32,255,8,7,8,255,32,2,32,255,8,6,8,255,32,2,32,255,8,7,8,255,32,2,32,255,8,6,8,255,32,8,32,252,252,32,32,255,252,7,252,255,32,19,32,8,8,255,32,7,32,8,8,255,32,4,32,8,8,32,32,8,8,255,32,7,32,8,8,255,32,4,32,8,8,255,32,7,32,252,252,32,32,252,252,255,32,4,32,252,252,255,32,18,32,8,8,255,32,14,32,8,8,32,32,8,8,255,32,7,32,8,8,255,32,14,32,252,252,32,32,252,252,255,32,4,32,252,252,255,32,18,32,255,8,5,8,255,32,4,32,255,8,6,8,255,32,2,32,255,8,6,8,255,32,2,32,255,8,7,8,255,32,8,32,252,252,32,32,255,252,7,252,255,32,19,32,8,8,255,32,7,32,8,8,255,32,14,32,8,8,32,32,8,8,255,32,4,32,8,8,32,32,252,252,255,32,3,32,252,252,32,32,252,252,255,32,2,32,252,252,255,32,20,32,8,8,255,32,7,32,8,8,255,32,8,32,8,8,255,32,3,32,8,8,32,32,8,8,255,32,4,32,8,8,32,32,252,252,255,32,3,32,252,252,32,32,252,252,255,32,3,32,252,252,255,32,19,32,8,8,255,32,7,32,255,8,8,8,255,32,2,32,255,8,5,8,255,32,3,32,255,8,6,8,255,32,3,32,255,252,5,252,255,32,2,32,252,252,255,32,4,32,252,252,255,32,88,32,160,255,150,27,150,155,255,150,22,150,155,255,150,24,150,161,130,72,97,114,100,119,97,114,101,255,32,19,32,130,221,50,48,50,50,32,83,116,101,102,97,110,121,32,65,108,108,97,105,114,101,32,32,130,99,50,53,54,102,111,101,110,105,120,46,99,111,109,47,102,50,53,54,45,106,114,255,32,2,32,130,130,77,105,99,114,111,75,101,114,110,101,108,255,32,16,32,130,221,50,48,50,50,32,74,101,115,115,105,101,32,79,98,101,114,114,101,117,116,101,114,130,71,97,100,103,101,116,64,72,97,99,107,119,114,101,110,99,104,76,97,98,115,46,99,111,109,130,130,83,117,112,101,114,66,65,83,73,67,255,32,17,32,130,221,50,48,50,50,32,80,97,117,108,32,82,111,98,115,111,110,255,32,5,32,130,80,97,117,108,64,82,111,98,115,111,110,115,46,111,114,103,46,117,107,255,32,5,32,130,162,255,150,27,150,157,255,150,22,150,157,255,150,24,150,163,255,0
>e1a0	a1a0	ff 20 02 20 ff 08 06 08 ff 20 02 20 ff 08 07 08
>e1b0	a1b0	ff 20 02 20 ff 08 06 08 ff 20 08 20 fc fc 20 20
>e1c0	a1c0	ff fc 07 fc ff 20 13 20 08 08 ff 20 07 20 08 08
>e1d0	a1d0	ff 20 04 20 08 08 20 20 08 08 ff 20 07 20 08 08
>e1e0	a1e0	ff 20 04 20 08 08 ff 20 07 20 fc fc 20 20 fc fc
>e1f0	a1f0	ff 20 04 20 fc fc ff 20 12 20 08 08 ff 20 0e 20
>e200	a200	08 08 20 20 08 08 ff 20 07 20 08 08 ff 20 0e 20
>e210	a210	fc fc 20 20 fc fc ff 20 04 20 fc fc ff 20 12 20
>e220	a220	ff 08 05 08 ff 20 04 20 ff 08 06 08 ff 20 02 20
>e230	a230	ff 08 06 08 ff 20 02 20 ff 08 07 08 ff 20 08 20
>e240	a240	fc fc 20 20 ff fc 07 fc ff 20 13 20 08 08 ff 20
>e250	a250	07 20 08 08 ff 20 0e 20 08 08 20 20 08 08 ff 20
>e260	a260	04 20 08 08 20 20 fc fc ff 20 03 20 fc fc 20 20
>e270	a270	fc fc ff 20 02 20 fc fc ff 20 14 20 08 08 ff 20
>e280	a280	07 20 08 08 ff 20 08 20 08 08 ff 20 03 20 08 08
>e290	a290	20 20 08 08 ff 20 04 20 08 08 20 20 fc fc ff 20
>e2a0	a2a0	03 20 fc fc 20 20 fc fc ff 20 03 20 fc fc ff 20
>e2b0	a2b0	13 20 08 08 ff 20 07 20 ff 08 08 08 ff 20 02 20
>e2c0	a2c0	ff 08 05 08 ff 20 03 20 ff 08 06 08 ff 20 03 20
>e2d0	a2d0	ff fc 05 fc ff 20 02 20 fc fc ff 20 04 20 fc fc
>e2e0	a2e0	ff 20 58 20 a0 ff 96 1b 96 9b ff 96 16 96 9b ff
>e2f0	a2f0	96 18 96 a1 82 48 61 72 64 77 61 72 65 ff 20 13
>e300	a300	20 82 dd 32 30 32 32 20 53 74 65 66 61 6e 79 20
>e310	a310	41 6c 6c 61 69 72 65 20 20 82 63 32 35 36 66 6f
>e320	a320	65 6e 69 78 2e 63 6f 6d 2f 66 32 35 36 2d 6a 72
>e330	a330	ff 20 02 20 82 82 4d 69 63 72 6f 4b 65 72 6e 65
>e340	a340	6c ff 20 10 20 82 dd 32 30 32 32 20 4a 65 73 73
>e350	a350	69 65 20 4f 62 65 72 72 65 75 74 65 72 82 47 61
>e360	a360	64 67 65 74 40 48 61 63 6b 77 72 65 6e 63 68 4c
>e370	a370	61 62 73 2e 63 6f 6d 82 82 53 75 70 65 72 42 41
>e380	a380	53 49 43 ff 20 11 20 82 dd 32 30 32 32 20 50 61
>e390	a390	75 6c 20 52 6f 62 73 6f 6e ff 20 05 20 82 50 61
>e3a0	a3a0	75 6c 40 52 6f 62 73 6f 6e 73 2e 6f 72 67 2e 75
>e3b0	a3b0	6b ff 20 05 20 82 a2 ff 96 1b 96 9d ff 96 16 96
>e3c0	a3c0	9d ff 96 18 96 a3 ff 00
.e3c8	a3c8					Header_kattrs:
>e3c8	a3c8	72 ff 62 09 62 ff 72 37			.byte	114,255,98,9,98,255,114,55,114,255,98,9,98,255,114,3,114,255,98,9,98,255,114,3,114,255,216,7,216,255,114,2,114,255,216,6,216,255,114,2,114,255,216,7,216,255,114,2,114,255,216,6,216,255,114,2,114,210,210,255,114,3,114,210,210,114,114,255,98,9,98,255,114,3,114,255,98,9,98,255,114,3,114,104,104,255,114,7,114,104,104,255,114,4,114,104,104,114,114,104,104,255,114,7,114,104,104,255,114,4,114,104,104,114,114,210,210,255,114,2,114,210,210,255,114,2,114,255,98,9,98,255,114,3,114,255,98,9,98,255,114,3,114,232,232,255,114,14,114,232,232,114,114,232,232,255,114,7,114,232,232,255,114,8,114,210,210,114,114,210,210,255,114,3,114,255,98,9,98,255,114,3,114,255,98,9,98,255,114,3,114,255,56,5,56,255,114,4,114,255,56,6,56,255,114,2,114,255,56,6,56,255,114,2,114,255,56,7,56,255,114,2,114,255,210,4,210,255,114,4,114,255,98,9,98,255,114,3,114,255,98,9,98,255,114,3,114,120,120,255,114,7,114,120,120,255,114,14,114,113,113,114,114,113,113,255,114,4,114,113,113,114,114,210,210,114,114,210,210,255,114,3,114,255,98,9,98,255,114,3,114,255,98,9,98,255,114,3,114,168,168,255,114,7,114,168,168,255,114,8,114,168,168,255,114,3,114,168,168,114,114,168,168,255,114,4,114,168,168,114,114,210,210,255,114,2,114,210,210,255,114,2,114,255,98,9,98,255,114,3,114,255,98,9,98,255,114,3,114,72,72,255,114,7,114,255,72,8,72,255,114,2,114,255,72,5,72,255,114,3,114,255,72,6,72,255,114,2,114,210,210,255,114,3,114,210,210,114,114,255,98,9,98,255,114,2,114,255,2,79,2,255,114,80,114,255,226,7,226,255,146,19,146,114,255,146,4,146,255,114,18,114,255,194,24,194,114,114,255,226,10,226,255,146,16,146,114,255,146,4,146,255,114,18,114,255,194,24,194,114,114,255,226,9,226,255,146,17,146,114,255,146,4,146,255,114,18,114,255,194,24,194,255,114,80,114,255,0
>e3d0	a3d0	72 ff 62 09 62 ff 72 03 72 ff 62 09 62 ff 72 03
>e3e0	a3e0	72 ff d8 07 d8 ff 72 02 72 ff d8 06 d8 ff 72 02
>e3f0	a3f0	72 ff d8 07 d8 ff 72 02 72 ff d8 06 d8 ff 72 02
>e400	a400	72 d2 d2 ff 72 03 72 d2 d2 72 72 ff 62 09 62 ff
>e410	a410	72 03 72 ff 62 09 62 ff 72 03 72 68 68 ff 72 07
>e420	a420	72 68 68 ff 72 04 72 68 68 72 72 68 68 ff 72 07
>e430	a430	72 68 68 ff 72 04 72 68 68 72 72 d2 d2 ff 72 02
>e440	a440	72 d2 d2 ff 72 02 72 ff 62 09 62 ff 72 03 72 ff
>e450	a450	62 09 62 ff 72 03 72 e8 e8 ff 72 0e 72 e8 e8 72
>e460	a460	72 e8 e8 ff 72 07 72 e8 e8 ff 72 08 72 d2 d2 72
>e470	a470	72 d2 d2 ff 72 03 72 ff 62 09 62 ff 72 03 72 ff
>e480	a480	62 09 62 ff 72 03 72 ff 38 05 38 ff 72 04 72 ff
>e490	a490	38 06 38 ff 72 02 72 ff 38 06 38 ff 72 02 72 ff
>e4a0	a4a0	38 07 38 ff 72 02 72 ff d2 04 d2 ff 72 04 72 ff
>e4b0	a4b0	62 09 62 ff 72 03 72 ff 62 09 62 ff 72 03 72 78
>e4c0	a4c0	78 ff 72 07 72 78 78 ff 72 0e 72 71 71 72 72 71
>e4d0	a4d0	71 ff 72 04 72 71 71 72 72 d2 d2 72 72 d2 d2 ff
>e4e0	a4e0	72 03 72 ff 62 09 62 ff 72 03 72 ff 62 09 62 ff
>e4f0	a4f0	72 03 72 a8 a8 ff 72 07 72 a8 a8 ff 72 08 72 a8
>e500	a500	a8 ff 72 03 72 a8 a8 72 72 a8 a8 ff 72 04 72 a8
>e510	a510	a8 72 72 d2 d2 ff 72 02 72 d2 d2 ff 72 02 72 ff
>e520	a520	62 09 62 ff 72 03 72 ff 62 09 62 ff 72 03 72 48
>e530	a530	48 ff 72 07 72 ff 48 08 48 ff 72 02 72 ff 48 05
>e540	a540	48 ff 72 03 72 ff 48 06 48 ff 72 02 72 d2 d2 ff
>e550	a550	72 03 72 d2 d2 72 72 ff 62 09 62 ff 72 02 72 ff
>e560	a560	02 4f 02 ff 72 50 72 ff e2 07 e2 ff 92 13 92 72
>e570	a570	ff 92 04 92 ff 72 12 72 ff c2 18 c2 72 72 ff e2
>e580	a580	0a e2 ff 92 10 92 72 ff 92 04 92 ff 72 12 72 ff
>e590	a590	c2 18 c2 72 72 ff e2 09 e2 ff 92 11 92 72 ff 92
>e5a0	a5a0	04 92 ff 72 12 72 ff c2 18 c2 ff 72 50 72 ff 00
.e5b0	a5b0					Header_kchars:
>e5b0	a5b0	ff 20 5e 20 ff 08 07 08			.byte	255,32,94,32,255,8,7,8,255,32,2,32,255,8,6,8,255,32,2,32,255,8,7,8,255,32,2,32,255,8,6,8,255,32,2,32,183,183,255,32,3,32,183,183,255,32,29,32,8,8,255,32,7,32,8,8,255,32,4,32,8,8,32,32,8,8,255,32,7,32,8,8,255,32,4,32,8,8,32,32,183,183,255,32,2,32,183,183,255,32,30,32,8,8,255,32,14,32,8,8,32,32,8,8,255,32,7,32,8,8,255,32,8,32,183,183,32,32,183,183,255,32,31,32,255,8,5,8,255,32,4,32,255,8,6,8,255,32,2,32,255,8,6,8,255,32,2,32,255,8,7,8,255,32,2,32,255,183,4,183,255,32,32,32,8,8,255,32,7,32,8,8,255,32,14,32,8,8,32,32,8,8,255,32,4,32,8,8,32,32,183,183,32,32,183,183,255,32,31,32,8,8,255,32,7,32,8,8,255,32,8,32,8,8,255,32,3,32,8,8,32,32,8,8,255,32,4,32,8,8,32,32,183,183,255,32,2,32,183,183,255,32,30,32,8,8,255,32,7,32,255,8,8,8,255,32,2,32,255,8,5,8,255,32,3,32,255,8,6,8,255,32,2,32,183,183,255,32,3,32,183,183,255,32,94,32,160,255,150,27,150,155,255,150,22,150,155,255,150,24,150,161,130,72,97,114,100,119,97,114,101,255,32,19,32,130,221,50,48,50,50,32,83,116,101,102,97,110,121,32,65,108,108,97,105,114,101,32,32,130,99,50,53,54,102,111,101,110,105,120,46,99,111,109,47,102,50,53,54,45,106,114,255,32,2,32,130,130,77,105,99,114,111,75,101,114,110,101,108,255,32,16,32,130,221,50,48,50,50,32,74,101,115,115,105,101,32,79,98,101,114,114,101,117,116,101,114,130,71,97,100,103,101,116,64,72,97,99,107,119,114,101,110,99,104,76,97,98,115,46,99,111,109,130,130,83,117,112,101,114,66,65,83,73,67,255,32,17,32,130,221,50,48,50,50,32,80,97,117,108,32,82,111,98,115,111,110,255,32,5,32,130,80,97,117,108,64,82,111,98,115,111,110,115,46,111,114,103,46,117,107,255,32,5,32,130,162,255,150,27,150,157,255,150,22,150,157,255,150,24,150,163,255,0
>e5b8	a5b8	ff 20 02 20 ff 08 06 08 ff 20 02 20 ff 08 07 08
>e5c8	a5c8	ff 20 02 20 ff 08 06 08 ff 20 02 20 b7 b7 ff 20
>e5d8	a5d8	03 20 b7 b7 ff 20 1d 20 08 08 ff 20 07 20 08 08
>e5e8	a5e8	ff 20 04 20 08 08 20 20 08 08 ff 20 07 20 08 08
>e5f8	a5f8	ff 20 04 20 08 08 20 20 b7 b7 ff 20 02 20 b7 b7
>e608	a608	ff 20 1e 20 08 08 ff 20 0e 20 08 08 20 20 08 08
>e618	a618	ff 20 07 20 08 08 ff 20 08 20 b7 b7 20 20 b7 b7
>e628	a628	ff 20 1f 20 ff 08 05 08 ff 20 04 20 ff 08 06 08
>e638	a638	ff 20 02 20 ff 08 06 08 ff 20 02 20 ff 08 07 08
>e648	a648	ff 20 02 20 ff b7 04 b7 ff 20 20 20 08 08 ff 20
>e658	a658	07 20 08 08 ff 20 0e 20 08 08 20 20 08 08 ff 20
>e668	a668	04 20 08 08 20 20 b7 b7 20 20 b7 b7 ff 20 1f 20
>e678	a678	08 08 ff 20 07 20 08 08 ff 20 08 20 08 08 ff 20
>e688	a688	03 20 08 08 20 20 08 08 ff 20 04 20 08 08 20 20
>e698	a698	b7 b7 ff 20 02 20 b7 b7 ff 20 1e 20 08 08 ff 20
>e6a8	a6a8	07 20 ff 08 08 08 ff 20 02 20 ff 08 05 08 ff 20
>e6b8	a6b8	03 20 ff 08 06 08 ff 20 02 20 b7 b7 ff 20 03 20
>e6c8	a6c8	b7 b7 ff 20 5e 20 a0 ff 96 1b 96 9b ff 96 16 96
>e6d8	a6d8	9b ff 96 18 96 a1 82 48 61 72 64 77 61 72 65 ff
>e6e8	a6e8	20 13 20 82 dd 32 30 32 32 20 53 74 65 66 61 6e
>e6f8	a6f8	79 20 41 6c 6c 61 69 72 65 20 20 82 63 32 35 36
>e708	a708	66 6f 65 6e 69 78 2e 63 6f 6d 2f 66 32 35 36 2d
>e718	a718	6a 72 ff 20 02 20 82 82 4d 69 63 72 6f 4b 65 72
>e728	a728	6e 65 6c ff 20 10 20 82 dd 32 30 32 32 20 4a 65
>e738	a738	73 73 69 65 20 4f 62 65 72 72 65 75 74 65 72 82
>e748	a748	47 61 64 67 65 74 40 48 61 63 6b 77 72 65 6e 63
>e758	a758	68 4c 61 62 73 2e 63 6f 6d 82 82 53 75 70 65 72
>e768	a768	42 41 53 49 43 ff 20 11 20 82 dd 32 30 32 32 20
>e778	a778	50 61 75 6c 20 52 6f 62 73 6f 6e ff 20 05 20 82
>e788	a788	50 61 75 6c 40 52 6f 62 73 6f 6e 73 2e 6f 72 67
>e798	a798	2e 75 6b ff 20 05 20 82 a2 ff 96 1b 96 9d ff 96
>e7a8	a7a8	16 96 9d ff 96 18 96 a3 ff 00
.e7b2	a7b2					Header_Palette:
>e7b2	a7b2	00 00 00 00				.dword $000000
>e7b6	a7b6	66 66 66 00				.dword $666666
>e7ba	a7ba	aa 00 00 00				.dword $0000aa
>e7be	a7be	00 aa 00 00				.dword $00aa00
>e7c2	a7c2	ea 41 c0 00				.dword $c041ea
>e7c6	a7c6	00 48 87 00				.dword $874800
>e7ca	a7ca	00 9c ff 00				.dword $ff9c00
>e7ce	a7ce	ff db 57 00				.dword $57dbff
>e7d2	a7d2	28 3f 3f 00				.dword $3f3f28
>e7d6	a7d6	8a aa aa 00				.dword $aaaa8a
>e7da	a7da	ff 55 55 00				.dword $5555ff
>e7de	a7de	55 ff 55 00				.dword $55ff55
>e7e2	a7e2	ed 8d ff 00				.dword $ff8ded
>e7e6	a7e6	00 00 ff 00				.dword $ff0000
>e7ea	a7ea	55 ff ff 00				.dword $ffff55
>e7ee	a7ee	ff ff ff 00				.dword $ffffff
>e7f2	a7f2	ff ff ff 00				.dword $ffffff
>e7f6	a7f6	ff ff ff 00				.dword $ffffff

;******  Return to file: _basic.asm


;******  End of listing
