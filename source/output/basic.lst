
; 64tass Turbo Assembler Macro V1.57.2900 listing file
; 64tass -D AUTORUN=0 "-D MONITOR_ADDRESS=\$E000" "-D LOCKOUT_ADDRESS=\$F000" "-D BASIC_ADDRESS=\$38000" "-D SOURCE_ADDRESS=\$3000" "-D SPRITE_ADDRESS=\$30000" -q -b -Wall -c -D "HARDWARE=0 $'\x9'$'\x9'$'\x9'$'\x9'$'\x9'$'\x9'" -L output/basic.lst -l output/basic.lbl -Wall -o basic.rom _basic.asm
; Sat Nov 26 11:37:25 2022

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=0					AUTORUN=0
=$e000					 MONITOR_ADDRESS=$E000
=$f000					 LOCKOUT_ADDRESS=$F000
=$38000					 BASIC_ADDRESS=$38000
=$3000					 SOURCE_ADDRESS=$3000
=$30000					 SPRITE_ADDRESS=$30000
=0					HARDWARE=0

;******  Processing input file: _basic.asm


;******  Processing file: ./common/aa.system/01common.inc

=$30					ZeroPageMandatory = $30
=$400					ZeroPagePreference = $400
=$480					MemoryStorage = $480
=$2000					BasicStart = $2000
=$8000					BasicEnd = $8000
=$8000					CodeStart = $8000
=$1000					VariableSpace = $1000
=$2000					EndVariableSpace = $2000
=8					MathStackSize = 8
=512					BasicStackSize = 512
=3584					BasicStackBase = $1000-BasicStackSize
=80					MaxLineSize = 80

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/02macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/04data.inc

.0030					codePtr:
>0030							.fill 	4
.0034					basicStack:
>0034							.fill 	2
.0036					zTemp0:
>0036							.fill 	2
.0038					zTemp1:
>0038							.fill 	2
.003a					zTemp2:
>003a							.fill 	2
.003c					zsTemp:
>003c							.fill 	2
.003e					zaTemp:
>003e							.fill 	2
=$30					safePtr = codePtr 							; minimise direct tinkering
=$80					NSBIsNegative = $80 						; bit 7 : sign of mantissa (where numeric)
=$20					NSBIsReference = $20 						; bit 5 : is a reference
=$10					NSBIsString = $10 							; bit 4 : set if string (procedures don't go on the stack)
=$18					NSBTypeMask = $18 							; bits 4,3 : 00 int 01 float 10 string 11 procedure
=$03					NSBRefMask = $03 							; bits 0,1 : Bytes of reference, -1 (e.g. 00 = 1 byte, 11 = 4 bytes)
=$04					NSBIsArray = $04
=$00					NSTInteger = $00 							; base types for bits 3..4
=$08					NSTFloat = $08
=$10					NSTString = $10
=$18					NSTProcedure = $18
.0400					NSStatus:
>0400							.fill 	MathStackSize
.0408					NSMantissa0:
>0408							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0410					NSMantissa1:
>0410							.fill 	MathStackSize
.0418					NSMantissa2:
>0418							.fill 	MathStackSize
.0420					NSMantissa3:
>0420							.fill 	MathStackSize
.0428					NSExponent:
>0428							.fill 	MathStackSize
.0480					identStart:
>0480							.fill 	1
.0481					identTypeStart:
>0481							.fill 	1
.0482					identTypeEnd:
>0482							.fill 	1
.0483					identHash:
>0483							.fill 	1
.0484					identTypeByte:
>0484							.fill 	1	 						; (see tokenising.pdf)
.0485					encodeState:
>0485							.fill 	1
.0486					digitTemp:
>0486							.fill 	1
.0487					decimalCount:
>0487							.fill 	1
.0488					randomSeed:
>0488							.fill 	4
.048c					lowMemPtr:
>048c							.fill 	2
.048e					stringMemory:
>048e							.fill 	2
.0490					stringInitialised:
>0490							.fill 	1
.0491					stringTempPointer:
>0491							.fill 	2
.0493					breakCheck:
>0493							.fill 	1
.0494					decimalPlaces:
>0494							.fill 	1
.0495					dbOffset:
>0495							.fill 	1
.0496					lastParameter:
>0496							.fill 	1
.0497					dataPointer:
>0497							.fill 	5
.049c					inDataStatement:
>049c							.fill 	1
.049d					tbOffset:
>049d							.fill 	1
.049e					AssemblerAddress:
>049e							.fill 	2
.04a0					AssemblerControl:
>04a0							.fill 	1
.04a1					ParamStart:
>04a1							.fill 	2
.04a3					IsGroup1:
>04a3							.fill 	1
.04a4					BaseOpcode:
>04a4							.fill 	1
.04a5					ModeMask:
>04a5							.fill 	1
.04a6					listIndent:
>04a6							.fill 	1
.04a7					lcLastCharacter:
>04a7							.fill 	1
.04a8					isInputFlag:
>04a8							.fill 	1
.04a9					currentListColour:
>04a9							.fill 	1
.04aa					tokenOffset:
>04aa							.fill 	1
.04ab					tokenLineNumber:
>04ab							.fill 	2
.04ad					tokenBuffer:
>04ad							.fill 	253
.05aa					lineBuffer:
>05aa							.fill 	MaxLineSize+1
.05fb					numberBuffer:
>05fb							.fill 	34
.061d					decimalBuffer:
>061d							.fill 	16

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/constants.inc

=$80					AM_ISZP = $80
=$40					AM_ISG1 = $40
=$20					AM_ISG2 = $20
=224					AM_IMMEDIATE = AM_ISZP+AM_ISG1+AM_ISG2+$00
=228					AM_ZEROPAGE = AM_ISZP+AM_ISG1+AM_ISG2+$04
=40					AM_ACC = AM_ISG2+$08
=108					AM_ABS = AM_ISG1+AM_ISG2+$0C
=208					AM_INDY = AM_ISZP+AM_ISG1+$10
=244					AM_ZEROX = AM_ISZP+AM_ISG1+AM_ISG2+$14
=120					AM_ABSY = AM_ISG1+AM_ISG2+$18
=124					AM_ABSX = AM_ISG1+AM_ISG2+$1C
=209					AM_IND = AM_ISZP+AM_ISG1+$11
=$80					AM_ZEROY = AM_ISZP
=$01					AM_INDABS = $01
=$02					AM_INDABSX = $02
=192					AM_INDX = AM_ISZP+AM_ISG1+$00

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/handlers.inc


;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.inc

=1					ERRID_BREAK = 1
=2					ERRID_SYNTAX = 2
=3					ERRID_DIVZERO = 3
=4					ERRID_RANGE = 4
=5					ERRID_TYPE = 5
=6					ERRID_MEMORY = 6
=7					ERRID_ARGUMENT = 7
=8					ERRID_STOP = 8
=9					ERRID_STRING = 9
=10					ERRID_ASSERT = 10
=11					ERRID_DATA = 11
=12					ERRID_NOTDONE = 12
=13					ERRID_LINE = 13
=14					ERRID_GOSUB = 14
=15					ERRID_REPEAT = 15
=16					ERRID_WHILE = 16
=17					ERRID_FOR = 17
=18					ERRID_STACK = 18
=19					ERRID_STRUCT = 19
=20					ERRID_PROC = 20
=21					ERRID_REDEFINE = 21
=22					ERRID_ARRAYSIZE = 22
=23					ERRID_ARRAYIDX = 23

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst.inc

=$00					KWD_LESSLESS                         = $00; $00 <<
=$01					KWD_LESSEQUAL                        = $01; $01 <=
=$02					KWD_LESSGREATER                      = $02; $02 <>
=$03					KWD_PLINGPLING3                      = $03; $03 !!3
=$04					KWD_GREATERLESS                      = $04; $04 ><
=$05					KWD_GREATEREQUAL                     = $05; $05 >=
=$06					KWD_GREATERGREATER                   = $06; $06 >>
=$07					KWD_PLINGPLING7                      = $07; $07 !!7
=$08					KWD_PLINGPLING8                      = $08; $08 !!8
=$09					KWD_PLINGPLING9                      = $09; $09 !!9
=$0a					KWD_PLINGPLING10                     = $0a; $0a !!10
=$0b					KWD_PLINGPLING11                     = $0b; $0b !!11
=$0c					KWD_PLINGPLING12                     = $0c; $0c !!12
=$0d					KWD_PLINGPLING13                     = $0d; $0d !!13
=$0e					KWD_PLINGPLING14                     = $0e; $0e !!14
=$0f					KWD_PLINGPLING15                     = $0f; $0f !!15
=$10					KWD_AT                               = $10; $10 @
=$11					KWD_PLINGPLING17                     = $11; $11 !!17
=$12					KWD_PLINGPLING18                     = $12; $12 !!18
=$13					KWD_LSQPAREN                         = $13; $13 [
=$14					KWD_BACKSLASH                        = $14; $14 \
=$15					KWD_RSQPAREN                         = $15; $15 ]
=$16					KWD_HAT                              = $16; $16 ^
=$17					KWD_UNDERSCORE                       = $17; $17 _
=$18					KWD_BQUOTE                           = $18; $18 `
=$19					KWD_PLINGPLING25                     = $19; $19 !!25
=$1a					KWD_PLINGPLING26                     = $1a; $1a !!26
=$1b					KWD_LCURLY                           = $1b; $1b {
=$1c					KWD_BAR                              = $1c; $1c |
=$1d					KWD_RCURLY                           = $1d; $1d }
=$1e					KWD_TILDE                            = $1e; $1e ~
=$21					KWD_PLING                            = $21; $21 !
=$22					KWD_DQUOTE                           = $22; $22 "
=$23					KWD_HASH                             = $23; $23 #
=$24					KWD_DOLLAR                           = $24; $24 $
=$25					KWD_PERCENT                          = $25; $25 %
=$26					KWD_AMPERSAND                        = $26; $26 &
=$27					KWD_QUOTE                            = $27; $27 '
=$28					KWD_LPAREN                           = $28; $28 (
=$29					KWD_RPAREN                           = $29; $29 )
=$2a					KWD_STAR                             = $2a; $2a *
=$2b					KWD_PLUS                             = $2b; $2b +
=$2c					KWD_COMMA                            = $2c; $2c ,
=$2d					KWD_MINUS                            = $2d; $2d -
=$2e					KWD_PERIOD                           = $2e; $2e .
=$2f					KWD_SLASH                            = $2f; $2f /
=$30					KWD_0                                = $30; $30 0
=$31					KWD_1                                = $31; $31 1
=$32					KWD_2                                = $32; $32 2
=$33					KWD_3                                = $33; $33 3
=$34					KWD_4                                = $34; $34 4
=$35					KWD_5                                = $35; $35 5
=$36					KWD_6                                = $36; $36 6
=$37					KWD_7                                = $37; $37 7
=$38					KWD_8                                = $38; $38 8
=$39					KWD_9                                = $39; $39 9
=$3a					KWD_COLON                            = $3a; $3a :
=$3b					KWD_SEMICOLON                        = $3b; $3b ;
=$3c					KWD_LESS                             = $3c; $3c <
=$3d					KWD_EQUAL                            = $3d; $3d =
=$3e					KWD_GREATER                          = $3e; $3e >
=$3f					KWD_QMARK                            = $3f; $3f ?
=$83					KWD_ABSLPAREN                        = $83; $83 ABS(
=$84					KWD_ALLOCLPAREN                      = $84; $84 ALLOC(
=$85					KWD_ASCLPAREN                        = $85; $85 ASC(
=$86					KWD_CHRDOLLARLPAREN                  = $86; $86 CHR$(
=$87					KWD_EVENTLPAREN                      = $87; $87 EVENT(
=$88					KWD_FALSE                            = $88; $88 FALSE
=$89					KWD_FRACLPAREN                       = $89; $89 FRAC(
=$8a					KWD_HITLPAREN                        = $8a; $8a HIT(
=$8b					KWD_INTLPAREN                        = $8b; $8b INT(
=$8c					KWD_ISVALLPAREN                      = $8c; $8c ISVAL(
=$8d					KWD_JOYBLPAREN                       = $8d; $8d JOYB(
=$8e					KWD_JOYXLPAREN                       = $8e; $8e JOYX(
=$8f					KWD_JOYYLPAREN                       = $8f; $8f JOYY(
=$90					KWD_LEFTDOLLARLPAREN                 = $90; $90 LEFT$(
=$91					KWD_LENLPAREN                        = $91; $91 LEN(
=$92					KWD_MAXLPAREN                        = $92; $92 MAX(
=$93					KWD_MIDDOLLARLPAREN                  = $93; $93 MID$(
=$94					KWD_MINLPAREN                        = $94; $94 MIN(
=$95					KWD_NOTLPAREN                        = $95; $95 NOT(
=$96					KWD_PLAYINGLPAREN                    = $96; $96 PLAYING(
=$97					KWD_RANDOMLPAREN                     = $97; $97 RANDOM(
=$98					KWD_RIGHTDOLLARLPAREN                = $98; $98 RIGHT$(
=$99					KWD_RNDLPAREN                        = $99; $99 RND(
=$9a					KWD_SGNLPAREN                        = $9a; $9a SGN(
=$9b					KWD_SPCLPAREN                        = $9b; $9b SPC(
=$9c					KWD_STRDOLLARLPAREN                  = $9c; $9c STR$(
=$9d					KWD_TIMERLPAREN                      = $9d; $9d TIMER(
=$9e					KWD_TRUE                             = $9e; $9e TRUE
=$9f					KWD_VALLPAREN                        = $9f; $9f VAL(
=$a0					KWD_FOR                              = $a0; $a0 FOR
=$a1					KWD_IF                               = $a1; $a1 IF
=$a2					KWD_PROC                             = $a2; $a2 PROC
=$a3					KWD_REPEAT                           = $a3; $a3 REPEAT
=$a4					KWD_WHILE                            = $a4; $a4 WHILE
=$a5					KWD_ENDIF                            = $a5; $a5 ENDIF
=$a6					KWD_ENDPROC                          = $a6; $a6 ENDPROC
=$a7					KWD_NEXT                             = $a7; $a7 NEXT
=$a8					KWD_THEN                             = $a8; $a8 THEN
=$a9					KWD_UNTIL                            = $a9; $a9 UNTIL
=$aa					KWD_WEND                             = $aa; $aa WEND
=$ab					KWD_BY                               = $ab; $ab BY
=$ac					KWD_CALL                             = $ac; $ac CALL
=$ad					KWD_CIRCLE                           = $ad; $ad CIRCLE
=$ae					KWD_CLEAR                            = $ae; $ae CLEAR
=$af					KWD_CLS                              = $af; $af CLS
=$b0					KWD_COLOR                            = $b0; $b0 COLOR
=$b1					KWD_COLOUR                           = $b1; $b1 COLOUR
=$b2					KWD_DATA                             = $b2; $b2 DATA
=$b3					KWD_DIM                              = $b3; $b3 DIM
=$b4					KWD_DOWNTO                           = $b4; $b4 DOWNTO
=$b5					KWD_ELSE                             = $b5; $b5 ELSE
=$b6					KWD_FROM                             = $b6; $b6 FROM
=$b7					KWD_GFX                              = $b7; $b7 GFX
=$b8					KWD_GOSUB                            = $b8; $b8 GOSUB
=$b9					KWD_GOTO                             = $b9; $b9 GOTO
=$ba					KWD_HERE                             = $ba; $ba HERE
=$bb					KWD_IMAGE                            = $bb; $bb IMAGE
=$bc					KWD_INPUT                            = $bc; $bc INPUT
=$bd					KWD_LET                              = $bd; $bd LET
=$be					KWD_LINE                             = $be; $be LINE
=$bf					KWD_LOCAL                            = $bf; $bf LOCAL
=$c0					KWD_OFF                              = $c0; $c0 OFF
=$c1					KWD_ON                               = $c1; $c1 ON
=$c2					KWD_OUTLINE                          = $c2; $c2 OUTLINE
=$c3					KWD_PALETTE                          = $c3; $c3 PALETTE
=$c4					KWD_PLOT                             = $c4; $c4 PLOT
=$c5					KWD_PRINT                            = $c5; $c5 PRINT
=$c6					KWD_READ                             = $c6; $c6 READ
=$c7					KWD_RECT                             = $c7; $c7 RECT
=$c8					KWD_REM                              = $c8; $c8 REM
=$c9					KWD_RETURN                           = $c9; $c9 RETURN
=$ca					KWD_SOLID                            = $ca; $ca SOLID
=$cb					KWD_SOUND                            = $cb; $cb SOUND
=$cc					KWD_SPRITE                           = $cc; $cc SPRITE
=$cd					KWD_TEXT                             = $cd; $cd TEXT
=$ce					KWD_TO                               = $ce; $ce TO

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst0.inc

=$80					KWC_EOL = $80
=$ff					KWC_STRING = $FF
=$fe					KWC_HEXCONST = $FE
=$a0					KWC_FIRST_STRUCTURE = $a0
=$a5					KWC_FIRST_STRUCTURE_DEC = $a5
=$aa					KWC_LAST_STRUCTURE = $aa
=$83					KWC_FIRST_UNARY = $83
=$9f					KWC_LAST_UNARY = $9f

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/access.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/stack.inc

=$e0					STK_GOSUB = $E0
=$d0					STK_FOR = $D0
=$c0					STK_REPEAT = $C0
=$b0					STK_PROC = $B0
=$a0					STK_WHILE = $A0
=$01					STK_LOCALN = $01
=$02					STK_LOCALS = $02

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/00start.asm

.8000	a2 ff		ldx #$ff	Start:	ldx 	#$FF 						; stack reset
.8002	9a		txs				txs
.8003	20 05 ab	jsr $ab05			jsr 	EXTInitialise 				; hardware initialise
.8006	a2 80		ldx #$80			ldx 	#(Prompt >> 8) 				; prompt display
.8008	a9 22		lda #$22			lda 	#(Prompt & $FF)
.800a	20 64 8e	jsr $8e64			jsr 	PrintStringXA
.800d	a9 00		lda #$00			lda 	#0 							; graphics system initialise.
.800f	aa		tax				tax
.8010	a8		tay				tay
.8011	20 91 ab	jsr $ab91			jsr 	GXGraphicDraw
.8014	a9 0f		lda #$0f			lda 	#$0F 						; initialise sound system
.8016	20 2b ba	jsr $ba2b			jsr 	SNDCommand
.8019	20 5b 89	jsr $895b			jsr 	NewProgram 					; erase current program
.801c	4c 6b 83	jmp $836b			jmp 	WarmStart					; make same size.
.801f	4c 6b 83	jmp $836b			jmp 	WarmStart
>8022	0c 2a 2a 2a 20 46 32 35		Prompt:	.text 	12,"*** F256 Junior SuperBASIC ***",13,13
>802a	36 20 4a 75 6e 69 6f 72 20 53 75 70 65 72 42 41
>803a	53 49 43 20 2a 2a 2a 0d 0d

;******  Processing file: ./common/aa.system/../generated/timestamp.asm

>8043	52 65 6c 65 61 73 65 20			.text "Release Alpha 5 (26-Nov-22). "
>804b	41 6c 70 68 61 20 35 20 28 32 36 2d 4e 6f 76 2d
>805b	32 32 29 2e 20

;******  Return to file: ./common/aa.system/00start.asm

>8060	0d 0d 00					.byte 	13,13,0

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/assembler.asm

.8063					AssembleGroup1:
.8063	a9 ff		lda #$ff			lda 	#$FF
.8065	8d a5 04	sta $04a5			sta 	ModeMask 					; initialise the mode mask - all for all
.8068	80 02		bra $806c			bra 	AsmGroup12
.806a					AssembleGroup2:
.806a	a9 00		lda #$00			lda 	#$00
.806c					AsmGroup12:
.806c	8d a3 04	sta $04a3			sta 	IsGroup1 					; save the 'group 1' flag
.806f	68		pla				pla 								; pop the return address to access the information following.
.8070	fa		plx				plx
.8071	20 fa 80	jsr $80fa			jsr 	AccessParameters 			; get opcode and save as base
.8074	8d a4 04	sta $04a4			sta 	BaseOpcode
.8077	ad a3 04	lda $04a3			lda 	IsGroup1 					; skip if group 1 as we don't have a complex mask.
.807a	d0 08		bne $8084			bne 	_AG12HaveMask
.807c	a9 02		lda #$02			lda 	#2 							; if group 2 the second parameter is the mask
.807e	20 02 81	jsr $8102			jsr 	GetParameter		 		; e.g. which modes are supported for this operand
.8081	8d a5 04	sta $04a5			sta 	ModeMask
.8084					_AG12HaveMask:
.8084	20 3d 82	jsr $823d			jsr 	TypeAndCalculateOperand 	; get zero page type
.8087	da		phx				phx 								; save found address mode
.8088	20 66 81	jsr $8166			jsr 	AssembleModeX
.808b	fa		plx				plx  								; restore address mode
.808c	b0 0b		bcs $8099			bcs 	_AG12Exit
.808e	20 9a 80	jsr $809a			jsr 	PromoteToAbsolute  			; promote ZP to ABS and try that
.8091	20 66 81	jsr $8166			jsr 	AssembleModeX
.8094	b0 03		bcs $8099			bcs 	_AG12Exit
.8096	4c 5c a0	jmp $a05c			jmp 	SyntaxError 				; can't do either, so must be wrong mode/operand.
.8099					_AG12Exit:
.8099	60		rts				rts
.809a					PromoteToAbsolute:
.809a	a9 6c		lda #$6c			lda 	#AM_ABS 					; lda xx
.809c	e0 e4		cpx #$e4			cpx 	#AM_ZEROPAGE
.809e	f0 19		beq $80b9			beq 	_PTADo
.80a0	a9 7c		lda #$7c			lda 	#AM_ABSX 					; lda xx,X
.80a2	e0 f4		cpx #$f4			cpx 	#AM_ZEROX
.80a4	f0 13		beq $80b9			beq 	_PTADo
.80a6	a9 78		lda #$78			lda 	#AM_ABSY 					; lda xx,Y
.80a8	e0 80		cpx #$80			cpx 	#AM_ZEROY
.80aa	f0 0d		beq $80b9			beq 	_PTADo
.80ac	a9 01		lda #$01			lda 	#AM_INDABS 					; lda (xx) (jump)
.80ae	e0 d1		cpx #$d1			cpx 	#AM_IND
.80b0	f0 07		beq $80b9			beq 	_PTADo
.80b2	a9 02		lda #$02			lda 	#AM_INDABSX 				; lda (xx,x) (jump)
.80b4	e0 c0		cpx #$c0			cpx 	#AM_INDX
.80b6	f0 01		beq $80b9			beq 	_PTADo
.80b8	60		rts				rts
.80b9					_PTADo:
.80b9	aa		tax				tax
.80ba	60		rts				rts
.80bb					AssembleGroup3:
.80bb	68		pla				pla 								; get parameters, which is just the opcode.
.80bc	fa		plx				plx
.80bd	20 fa 80	jsr $80fa			jsr 	AccessParameters 			; get and output opcode
.80c0	20 12 81	jsr $8112			jsr 	AssemblerWriteByte
.80c3	20 a1 82	jsr $82a1			jsr 	CalculateOperand 			; get a 16 bit operand
.80c6	ad 08 04	lda $0408			lda 	NSMantissa0 				; calculate the offset
.80c9	38		sec				sec
.80ca	ed 9e 04	sbc $049e			sbc 	AssemblerAddress
.80cd	48		pha				pha 								; LSB in A
.80ce	ad 10 04	lda $0410			lda 	NSMantissa1
.80d1	ed 9f 04	sbc $049f			sbc 	AssemblerAddress+1
.80d4	aa		tax				tax 								; MSB in X
.80d5	68		pla				pla
.80d6	18		clc				clc 								; $80 to easy check $80-$7F, plus 1 for offset error
.80d7	69 7f		adc #$7f			adc 	#$7F
.80d9	90 01		bcc $80dc			bcc 	_AG3NoCarry
.80db	e8		inx				inx
.80dc					_AG3NoCarry:
.80dc	38		sec				sec 								; fix back and write out anyways.
.80dd	e9 80		sbc #$80			sbc 	#$80
.80df	20 12 81	jsr $8112			jsr 	AssemblerWriteByte
.80e2	e0 00		cpx #$00			cpx 	#0 							; was it in range
.80e4	f0 0a		beq $80f0			beq 	_AG3Exit
.80e6	ad a0 04	lda $04a0			lda 	AssemblerControl 			; are we allowing bad values ?
.80e9	29 01		and #$01			and 	#1
.80eb	f0 03		beq $80f0			beq 	_AG3Exit
.80ed	4c 61 a0	jmp $a061			jmp 	RangeError 					; no, branch is out of range
.80f0					_AG3Exit:
.80f0	60		rts				rts
.80f1					AssembleGroup4:
.80f1	68		pla				pla 								; pop address
.80f2	fa		plx				plx
.80f3	20 fa 80	jsr $80fa			jsr 	AccessParameters 			; access and get first
.80f6	20 12 81	jsr $8112			jsr 	AssemblerWriteByte 			; output it.
.80f9	60		rts				rts
.80fa					AccessParameters:
.80fa	8d a1 04	sta $04a1			sta 	ParamStart
.80fd	8e a2 04	stx $04a2			stx 	ParamStart+1
.8100	a9 01		lda #$01			lda 	#1
.8102					GetParameter:
.8102	5a		phy				phy
.8103	a8		tay				tay
.8104	ad a1 04	lda $04a1			lda 	ParamStart
.8107	85 36		sta $36				sta 	zTemp0
.8109	ad a2 04	lda $04a2			lda 	ParamStart+1
.810c	85 37		sta $37				sta 	zTemp0+1
.810e	b1 36		lda ($36),y			lda 	(zTemp0),y
.8110	7a		ply				ply
.8111	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/aswrite.asm

.8112					AssemblerWriteByte:
.8112	48		pha			pha
.8113	ad a0 04	lda $04a0		lda 	AssemblerControl 				; check printing bytes ?
.8116	29 02		and #$02		and 	#2
.8118	f0 1b		beq $8135		beq 	_AWBNoPrint
.811a	ad 9f 04	lda $049f		lda		AssemblerAddress+1 				; print address
.811d	20 50 81	jsr $8150		jsr 	PrintHex
.8120	ad 9e 04	lda $049e		lda		AssemblerAddress
.8123	20 50 81	jsr $8150		jsr 	PrintHex
.8126	a9 20		lda #$20		lda 	#' '
.8128	20 91 a8	jsr $a891		jsr 	EXTPrintCharacter
.812b	68		pla			pla 									; print byte
.812c	48		pha			pha
.812d	20 50 81	jsr $8150		jsr 	PrintHex
.8130	a9 0d		lda #$0d		lda 	#13
.8132	20 91 a8	jsr $a891		jsr 	EXTPrintCharacter
.8135					_AWBNoPrint:
.8135	ad 9e 04	lda $049e		lda		AssemblerAddress				; copy address to zTemp0
.8138	85 36		sta $36			sta 	zTemp0
.813a	ad 9f 04	lda $049f		lda		AssemblerAddress+1
.813d	f0 0e		beq $814d		beq 	_AWBRange
.813f	85 37		sta $37			sta 	zTemp0+1
.8141	68		pla			pla 									; write byte out
.8142	92 36		sta ($36)		sta 	(zTemp0)
.8144	ee 9e 04	inc $049e		inc 	AssemblerAddress 				; bump address
.8147	d0 03		bne $814c		bne 	_AWBNoCarry
.8149	ee 9f 04	inc $049f		inc 	AssemblerAddress+1
.814c					_AWBNoCarry:
.814c	60		rts			rts
.814d					_AWBRange:
.814d	4c 61 a0	jmp $a061		jmp 	RangeError
.8150					PrintHex:
.8150	48		pha				pha
.8151	4a		lsr a				lsr 	a
.8152	4a		lsr a				lsr 	a
.8153	4a		lsr a				lsr 	a
.8154	4a		lsr a				lsr 	a
.8155	20 59 81	jsr $8159			jsr 	_PrintNibble
.8158	68		pla				pla
.8159					_PrintNibble:
.8159	29 0f		and #$0f			and 	#15
.815b	c9 0a		cmp #$0a			cmp 	#10
.815d	90 02		bcc $8161			bcc 	_NoShift
.815f	69 06		adc #$06			adc 	#6
.8161					_NoShift:
.8161	69 30		adc #$30			adc 	#48
.8163	4c 91 a8	jmp $a891			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/instruction.asm

.8166					AssembleModeX:
.8166	5a		phy				phy
.8167	ad a3 04	lda $04a3			lda 	IsGroup1
.816a	f0 17		beq $8183			beq 	_AMXGroup2
.816c	8a		txa				txa 							; is it in group # 1
.816d	29 40		and #$40			and 	#AM_ISG1
.816f	f0 50		beq $81c1			beq 	_AMXFail 				; no, give up.
.8171	8a		txa				txa 							; get back.
.8172	29 1f		and #$1f			and 	#$1F 					; this is now the offset.
.8174	e0 e0		cpx #$e0			cpx 	#AM_IMMEDIATE 			; if not immediate, we can continue.
.8176	d0 22		bne $819a			bne 	_AMXHaveInfo
.8178	ad a4 04	lda $04a4			lda 	BaseOpcode 				; cannot store immediate.
.817b	c9 81		cmp #$81			cmp 	#$81
.817d	f0 42		beq $81c1			beq 	_AMXFail
.817f	a9 08		lda #$08			lda 	#8 						; if immediate we use offset 8.
.8181	80 17		bra $819a			bra 	_AMXHaveInfo 			; odd design decision there.
.8183					_AMXGroup2:
.8183	8a		txa				txa 							; is it in group 2 ?
.8184	29 20		and #$20			and 	#AM_ISG2
.8186	f0 39		beq $81c1			beq 	_AMXFail 				; no, give up.
.8188	8a		txa				txa 							; get the offset into Y
.8189	29 1f		and #$1f			and 	#$1F
.818b	4a		lsr a				lsr 	a 						; make it 0-7.
.818c	4a		lsr a				lsr  	a
.818d	a8		tay				tay
.818e	ad a5 04	lda $04a5			lda 	ModeMask 				; shift the modemask left so you can check it against the requested offset
.8191					_AMXCheckOkay:
.8191	0a		asl a				asl 	a 						; shift modemask left enough times to check legitimate.
.8192	88		dey				dey
.8193	10 fc		bpl $8191			bpl 	_AMXCheckOkay
.8195	90 2a		bcc $81c1			bcc 	_AMXFail 				; not allowed.
.8197	8a		txa				txa  							; get mask back
.8198	29 1f		and #$1f			and 	#$1F
.819a					_AMXHaveInfo:
.819a	e0 00		cpx #$00			cpx 	#$00 					; does it *require* an 8 bit operand
.819c	10 05		bpl $81a3			bpl 	_AMXAnySize 			; checking bit 7, the zero page opcode flag.
.819e	ac 10 04	ldy $0410			ldy 	NSMantissa1 			; fail if it is outside range, e.g. the MSB is set.
.81a1	d0 1e		bne $81c1			bne 	_AMXFail
.81a3					_AMXAnySize:
.81a3	18		clc				clc 							; add offset to the base opcode
.81a4	6d a4 04	adc $04a4			adc 	BaseOpcode
.81a7					_AMXOutputCode:
.81a7	20 12 81	jsr $8112			jsr 	AssemblerWriteByte 		; write the opcode out.
.81aa	e0 28		cpx #$28			cpx 	#AM_ACC 				; A mode (e.g. ASL A)
.81ac	f0 10		beq $81be			beq 	_AMXExit
.81ae	ad 08 04	lda $0408			lda 	NSMantissa0 				; write LSB operand
.81b1	20 12 81	jsr $8112			jsr 	AssemblerWriteByte
.81b4	e0 00		cpx #$00			cpx 	#$00 					; zeropage ?
.81b6	30 06		bmi $81be			bmi 	_AMXExit
.81b8	ad 10 04	lda $0410			lda 	NSMantissa1 			; write MSB operand
.81bb	20 12 81	jsr $8112			jsr 	AssemblerWriteByte
.81be					_AMXExit:
.81be	7a		ply				ply
.81bf	38		sec				sec
.81c0	60		rts				rts
.81c1					_AMXFail:
.81c1	a0 00		ldy #$00			ldy 	#0
.81c3					_AMXCheckOddities:
.81c3	8a		txa				txa
.81c4	d9 ec 81	cmp $81ec,y			cmp 	ExtraOpcode+2,y 		; match address mode
.81c7	d0 16		bne $81df			bne 	_AMXCONext
.81c9	b9 ea 81	lda $81ea,y			lda 	ExtraOpcode+0,y 		; do the base opcodes match
.81cc	cd a4 04	cmp $04a4			cmp 	BaseOpcode
.81cf	d0 0e		bne $81df			bne 	_AMXCONext
.81d1	e0 00		cpx #$00			cpx 	#$00 					; requires zero page ?
.81d3	10 05		bpl $81da			bpl 	_AMXCONotZero
.81d5	ad 10 04	lda $0410			lda 	NSMantissa1
.81d8	d0 05		bne $81df			bne 	_AMXCONext
.81da					_AMXCONotZero:
.81da	b9 eb 81	lda $81eb,y			lda 	ExtraOpcode+1,y 		; get new opcode
.81dd	80 c8		bra $81a7			bra 	_AMXOutputCode 			; and assemble it
.81df					_AMXCONext:
.81df	c8		iny				iny
.81e0	c8		iny				iny
.81e1	c8		iny				iny
.81e2	b9 ea 81	lda $81ea,y			lda 	ExtraOpcode+0,y 		; end of table
.81e5	d0 dc		bne $81c3			bne 	_AMXCheckOddities
.81e7					_AMXCOFail:
.81e7	7a		ply				ply
.81e8	18		clc				clc
.81e9	60		rts				rts
.81ea					ExtraOpcode:
>81ea	40 6c 01					.byte $40,$6c,AM_INDABS 	; jmp
>81ed	40 7c 02					.byte $40,$7C,AM_INDABSX 	; jmp
>81f0	a2 be 78					.byte $a2,$BE,AM_ABSY 		; ldx
>81f3	a2 b6 80					.byte $a2,$B6,AM_ZEROY 		; ldx
>81f6	82 96 80					.byte $82,$96,AM_ZEROY 		; stx
>81f9	e2 1a 28					.byte $e2,$1a,AM_ACC 		; inc
>81fc	c2 3a 28					.byte $c2,$3a,AM_ACC 		; dec
>81ff	20 89 e0					.byte $20,$89,AM_IMMEDIATE 	; bit
>8202	60 9c 6c					.byte $60,$9c,AM_ABS 		; stz
>8205	60 9e 7c					.byte $60,$9e,AM_ABSX 		; stz
>8208	00						.byte $00

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/label.asm

.8209					LabelHere:
.8209	c8		iny				iny 								; skip .
.820a	a2 00		ldx #$00			ldx 	#0 							; get a term
.820c	20 98 98	jsr $9898			jsr 	EvaluateTerm 				; get a term
.820f	ad 00 04	lda $0400			lda 	NSStatus 					; needs to be an integer reference.
.8212	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.8214	d0 24		bne $823a			bne 	_ALType
.8216	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy reference address to zTemp0
.8219	85 36		sta $36				sta 	zTemp0
.821b	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.821e	85 37		sta $37				sta 	zTemp0+1
.8220	5a		phy				phy 								; copy address in.
.8221	a0 01		ldy #$01			ldy 	#1
.8223	ad 9e 04	lda $049e			lda	 	AssemblerAddress
.8226	92 36		sta ($36)			sta 	(zTemp0)
.8228	ad 9f 04	lda $049f			lda	 	AssemblerAddress+1
.822b	91 36		sta ($36),y			sta 	(zTemp0),y
.822d	c8		iny				iny
.822e	a9 00		lda #$00			lda 	#0
.8230	91 36		sta ($36),y			sta 	(zTemp0),y
.8232	c8		iny				iny
.8233	91 36		sta ($36),y			sta 	(zTemp0),y
.8235	c8		iny				iny
.8236	91 36		sta ($36),y			sta 	(zTemp0),y
.8238	7a		ply				ply
.8239	60		rts				rts
.823a					_ALType:
.823a	4c 66 a0	jmp $a066			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/operands.asm

.823d					TypeAndCalculateOperand:
.823d	b1 30		lda ($30),y			lda 	(codePtr),y
.823f	a2 28		ldx #$28			ldx 	#AM_ACC 					; ACC if : or EOL
.8241	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.8243	f0 5b		beq $82a0			beq 	_TACOExit
.8245	c9 80		cmp #$80			cmp 	#KWC_EOL
.8247	f0 57		beq $82a0			beq 	_TACOExit
.8249	c8		iny				iny
.824a	a2 e0		ldx #$e0			ldx 	#AM_IMMEDIATE
.824c	c9 23		cmp #$23			cmp 	#KWD_HASH 					; if hash, then immediate - constant.
.824e	f0 51		beq $82a1			beq 	CalculateOperand
.8250	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; if ( then check for indirection
.8252	f0 1f		beq $8273			beq 	_TACOIndirect
.8254	88		dey				dey 								; undo get of first character
.8255	20 a1 82	jsr $82a1			jsr 	CalculateOperand 			; get operand
.8258	b1 30		lda ($30),y			lda 	(codePtr),y
.825a	a2 e4		ldx #$e4			ldx 	#AM_ZEROPAGE 				; if not, try zero page (then absolute)
.825c	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.825e	d0 40		bne $82a0			bne 	_TACOExit
.8260	c8		iny				iny
.8261	20 ab 82	jsr $82ab			jsr 	TACOCheckXY 				; extract X,Y or 0 (neither) from the variable.
.8264	a2 f4		ldx #$f4			ldx 	#AM_ZEROX 					; check for X
.8266	c9 58		cmp #$58			cmp 	#'X'
.8268	f0 36		beq $82a0			beq 	_TACOExit
.826a	a2 80		ldx #$80			ldx 	#AM_ZEROY 					; check for Y
.826c	c9 59		cmp #$59			cmp 	#'Y'
.826e	f0 30		beq $82a0			beq 	_TACOExit
.8270					_TACOSyntax:
.8270	4c 5c a0	jmp $a05c			jmp 	SyntaxError
.8273					_TACOIndirect:
.8273	20 a1 82	jsr $82a1			jsr 	CalculateOperand 			; get the operand
.8276	b1 30		lda ($30),y			lda 	(codePtr),y
.8278	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if , then it must be ,X)
.827a	f0 17		beq $8293			beq 	_TACOIndX
.827c	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket  			; otherwise must be ) or ),Y
.827f	b1 30		lda ($30),y			lda 	(codePtr),y
.8281	a2 d1		ldx #$d1			ldx 	#AM_IND
.8283	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not comma then exit with (xx)
.8285	d0 19		bne $82a0			bne 	_TACOExit
.8287	c8		iny				iny
.8288	20 ab 82	jsr $82ab			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.828b	c9 59		cmp #$59			cmp 	#'Y' 						; check Y
.828d	d0 e1		bne $8270			bne 	_TACOSyntax
.828f	a2 d0		ldx #$d0			ldx 	#AM_INDY
.8291	80 0d		bra $82a0			bra 	_TACOExit
.8293					_TACOIndX:
.8293	c8		iny				iny
.8294	20 ab 82	jsr $82ab			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.8297	c9 58		cmp #$58			cmp 	#'X' 						; check X
.8299	d0 d5		bne $8270			bne 	_TACOSyntax
.829b	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket			; check )
.829e	a2 c0		ldx #$c0			ldx 	#AM_INDX
.82a0					_TACOExit:
.82a0	60		rts				rts
.82a1					CalculateOperand:
.82a1	48		pha				pha
.82a2	da		phx				phx
.82a3	a2 00		ldx #$00			ldx 	#0 							; get 16 bit integer in Slot 0
.82a5	20 33 9e	jsr $9e33			jsr 	Evaluate16BitInteger
.82a8	fa		plx				plx
.82a9	68		pla				pla
.82aa	60		rts				rts
.82ab					TACOCheckXY:
.82ab	b1 30		lda ($30),y			lda 	(codePtr),y
.82ad	29 c0		and #$c0			and 	#$C0 						; check it is an identifier reference.
.82af	c9 40		cmp #$40			cmp 	#$40
.82b1	d0 21		bne $82d4			bne 	_TCXYFail
.82b3	b1 30		lda ($30),y			lda 	(codePtr),y
.82b5	18		clc				clc
.82b6	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.82b8	85 37		sta $37				sta 	zTemp0+1
.82ba	c8		iny				iny
.82bb	b1 30		lda ($30),y			lda 	(codePtr),y
.82bd	c8		iny				iny
.82be	85 36		sta $36				sta 	zTemp0
.82c0	5a		phy				phy 								; save position
.82c1	a0 02		ldy #$02			ldy 	#2 							; type is integer ?
.82c3	b1 36		lda ($36),y			lda 	(zTemp0),y
.82c5	d0 0c		bne $82d3			bne 	_TCXYPopFail
.82c7	a0 08		ldy #$08			ldy 	#8 							; get first character, should have bit 7 set as also last.
.82c9	b1 36		lda ($36),y			lda 	(zTemp0),y
.82cb	c9 d8		cmp #$d8			cmp 	#'X'+$80 					; should be X or Y
.82cd	f0 08		beq $82d7			beq 	_TCXYFound
.82cf	c9 d9		cmp #$d9			cmp 	#'Y'+$80
.82d1	f0 04		beq $82d7			beq 	_TCXYFound
.82d3					_TCXYPopFail:
.82d3	7a		ply				ply
.82d4					_TCXYFail:
.82d4	a9 00		lda #$00			lda 	#0
.82d6	60		rts				rts
.82d7					_TCXYFound:
.82d7	7a		ply				ply 								; restore position
.82d8	29 7f		and #$7f			and 	#$7F 						; throw bit 7
.82da	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/backload.asm

.82db					BackloadProgram:
.82db	a2 83		ldx #$83			ldx 	#_BLLoad >> 8
.82dd	a9 1a		lda #$1a			lda 	#_BLLoad & $FF
.82df	20 64 8e	jsr $8e64			jsr 	PrintStringXA
.82e2	a9 00		lda #$00			lda 	#((SOURCE_ADDRESS) & $FF)
.82e4	8d 2d 06	sta $062d			sta 	0+BackLoadPointer
.82e7	a9 30		lda #$30			lda 	#((SOURCE_ADDRESS) >> 8)
.82e9	8d 2e 06	sta $062e			sta 	1+BackLoadPointer
.82ec					_BPLoop:
.82ec	a2 ff		ldx #$ff			ldx 	#$FF
.82ee	20 2f 83	jsr $832f			jsr 	BLReadByte 					; read a byte
.82f1	c9 00		cmp #$00			cmp 	#0
.82f3	f0 21		beq $8316			beq 	_BPExit 					; if 0 exit
.82f5	30 1f		bmi $8316			bmi 	_BPExit 					; if -ve exit
.82f7					_BPCopy:
.82f7	e8		inx				inx  								; copy byte into the lineBuffer
.82f8	9d aa 05	sta $05aa,x			sta 	lineBuffer,x
.82fb	9e ab 05	stz $05ab,x			stz 	lineBuffer+1,x
.82fe	20 2f 83	jsr $832f			jsr 	BLReadByte 					; read next byte
.8301	30 0a		bmi $830d			bmi 	_BPEndLine 					; -ve = EOL
.8303	c9 09		cmp #$09			cmp 	#9 							; handle TAB, make it space.
.8305	d0 02		bne $8309			bne 	_BPNotTab
.8307	a9 20		lda #$20			lda 	#' '
.8309					_BPNotTab:
.8309	c9 20		cmp #$20			cmp 	#' ' 						; < ' ' = EOL
.830b	b0 ea		bcs $82f7			bcs 	_BPCopy 					; until a control character, should be 13 received.
.830d					_BPEndLine:
.830d	20 bb b6	jsr $b6bb			jsr 	TokeniseLine 				; tokenise the line.
.8310	38		sec				sec 								; append not insert
.8311	20 cd a5	jsr $a5cd			jsr 	MemoryInsertLine 			; append to current program
.8314	80 d6		bra $82ec			bra 	_BPLoop
.8316					_BPExit:
.8316	20 04 84	jsr $8404			jsr 	ClearCommand 				; clear variables etc.
.8319	60		rts				rts
.831a					_BLLoad:
>831a	4c 6f 61 64 69 6e 67 20				.text 	"Loading from Memory",13,0
>8322	66 72 6f 6d 20 4d 65 6d 6f 72 79 0d 00
.832f					BLReadByte:
.832f	ad 2d 06	lda $062d			lda 	BackLoadPointer 			; copy pointer to zTemp0
.8332	85 36		sta $36				sta 	zTemp0
.8334	ad 2e 06	lda $062e			lda 	BackLoadPointer+1
.8337	85 37		sta $37				sta 	zTemp0+1
.8339	b2 36		lda ($36)			lda 	(zTemp0) 					; read next byte
.833b	ee 2d 06	inc $062d			inc 	BackLoadPointer 			; bump pointer
.833e	d0 03		bne $8343			bne 	_BLNoCarry
.8340	ee 2e 06	inc $062e			inc 	BackLoadPointer+1
.8343					_BLNoCarry:
.8343	c9 00		cmp #$00			cmp 	#0
.8345	60		rts				rts
.062d					BackLoadPointer:
>062d							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/editor.asm

.8346					EditProgramCode:
.8346	ad ab 04	lda $04ab			lda 	TokenLineNumber 			; find the line.
.8349	ae ac 04	ldx $04ac			ldx 	TokenLineNumber+1
.834c	20 75 a6	jsr $a675			jsr 	MemorySearch
.834f	90 05		bcc $8356			bcc 	_EPCNoDelete 				; reached the end don't delete
.8351	d0 03		bne $8356			bne 	_EPCNoDelete 				; found slot but didn't match, no delete
.8353	20 96 a5	jsr $a596			jsr 	MemoryDeleteLine 			; delete the line
.8356					_EPCNoDelete:
.8356	ad ad 04	lda $04ad			lda 	TokenBuffer 				; buffer empty
.8359	c9 80		cmp #$80			cmp 	#KWC_EOL
.835b	f0 0d		beq $836a			beq 	_EPCNoInsert
.835d	ad ab 04	lda $04ab			lda 	TokenLineNumber 			; find the line - it cannot exist.
.8360	ae ac 04	ldx $04ac			ldx 	TokenLineNumber+1 			; so this can't fail, it returns some point in the code.
.8363	20 75 a6	jsr $a675			jsr 	MemorySearch
.8366	18		clc				clc 								; insert at this point.
.8367	20 cd a5	jsr $a5cd			jsr 	MemoryInsertLine 			; insert the line
.836a					_EPCNoInsert:
.836a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/warmstart.asm

.836b					WarmStart:
.836b	a2 ff		ldx #$ff			ldx 	#$FF
.836d	9a		txs				txs
.836e	20 1f aa	jsr $aa1f			jsr 	EXTInputLine 				; get line to lineBuffer
.8371	20 bb b6	jsr $b6bb			jsr 	TokeniseLine 				; tokenise the line
.8374	ad ab 04	lda $04ab			lda 	TokenLineNumber 			; line number ?
.8377	0d ac 04	ora $04ac			ora 	TokenLineNumber+1
.837a	d0 17		bne $8393			bne 	_WSEditCode 				; if so,edit code.
.837c	9c aa 04	stz $04aa			stz 	TokenOffset 				; zero offset, meaning it only runs one line.
.837f	a9 aa		lda #$aa			lda 	#((TokenOffset) & $FF)
.8381	85 30		sta $30				sta 	codePtr
.8383	a9 04		lda #$04			lda 	#((TokenOffset) >> 8)
.8385	85 31		sta $31				sta 	codePtr+1
.8387	ad ad 04	lda $04ad			lda 	TokenBuffer 				; nothing to run
.838a	c9 80		cmp #$80			cmp 	#KWC_EOL
.838c	f0 dd		beq $836b			beq 	WarmStart
.838e	20 ac 8a	jsr $8aac			jsr 	RUNCodePointerLine 			; execute that line.
.8391	80 d8		bra $836b			bra 	WarmStart
.8393					_WSEditCode:
.8393	20 46 83	jsr $8346			jsr 	EditProgramCode
.8396	20 04 84	jsr $8404			jsr 	ClearCommand
.8399	80 d0		bra $836b			bra 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assemble.asm

.839b					AssembleCommand:
.839b	a2 00		ldx #$00			ldx 	#0
.839d	20 33 9e	jsr $9e33			jsr 	Evaluate16BitInteger 		; start address
.83a0	ad 08 04	lda $0408			lda 	NSMantissa0
.83a3	8d 9e 04	sta $049e			sta 	AssemblerAddress
.83a6	ad 10 04	lda $0410			lda 	NSMantissa1
.83a9	8d 9f 04	sta $049f			sta 	AssemblerAddress+1
.83ac	20 fa 8d	jsr $8dfa			jsr 	CheckComma
.83af	20 53 9e	jsr $9e53			jsr 	Evaluate8BitInteger 		; options
.83b2	ad 08 04	lda $0408			lda 	NSMantissa0
.83b5	8d a0 04	sta $04a0			sta 	AssemblerControl
.83b8	60		rts				rts
.83b9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assert.asm

.83ba					AssertCommand:
.83ba	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.83bc	20 1e 9e	jsr $9e1e			jsr 	EvaluateInteger 			; the assert test
.83bf	20 02 9f	jsr $9f02			jsr 	NSMIsZero 					; exit if result is non zero.
.83c2	d0 05		bne $83c9			bne 	_ACExit
.83c4	a9 0a		lda #$0a		lda	#10
.83c6	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler
.83c9					_ACExit:
.83c9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/call.asm

.83ca					CallCommand:
.83ca	a2 00		ldx #$00			ldx 	#0 							; get the routine address to level 0
.83cc	20 33 9e	jsr $9e33			jsr 	Evaluate16BitInteger
.83cf					_CCClear
.83cf	e8		inx				inx  								; clear 1,2 and 3 (for A X Y)
.83d0	20 d2 9e	jsr $9ed2			jsr 	NSMSetZero 					; these are optional sequentially.
.83d3	e0 04		cpx #$04			cpx 	#4
.83d5	d0 f8		bne $83cf			bne 	_CCClear
.83d7	a2 00		ldx #$00			ldx 	#0 							; and keep trying while there are more values.
.83d9					_CCCParam:
.83d9	b1 30		lda ($30),y			lda 	(codePtr),y
.83db	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.83dd	d0 09		bne $83e8			bne 	_CCCRun6502
.83df	c8		iny				iny 								; skip comma
.83e0	e8		inx				inx	 								; next level
.83e1	20 53 9e	jsr $9e53			jsr 	Evaluate8BitInteger 		; get A/X/Y
.83e4	e0 03		cpx #$03			cpx 	#3
.83e6	90 f1		bcc $83d9			bcc 	_CCCParam 					; done all 3 ?
.83e8					_CCCRun6502:
.83e8	5a		phy				phy 								; save position
.83e9	ad 10 04	lda $0410			lda 	NSMantissa1 				; put address in zTemp0
.83ec	85 37		sta $37				sta 	zTemp0+1
.83ee	ad 08 04	lda $0408			lda 	NSMantissa0
.83f1	85 36		sta $36				sta 	zTemp0
.83f3	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; get registers into A X Y
.83f6	ae 0a 04	ldx $040a			ldx 	NSMantissa0+2
.83f9	ac 0b 04	ldy $040b			ldy 	NSMantissa0+3
.83fc	20 01 84	jsr $8401			jsr 	_CCCZTemp0 					; call zTemp0
.83ff	7a		ply				ply 								; restore position and exit
.8400	60		rts				rts
.8401					_CCCZTemp0:
.8401	6c 36 00	jmp ($0036)			jmp 	(zTemp0)

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/clear.asm

.8404					ClearCommand:
.8404	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.8406	85 36		sta $36				sta 	0+zTemp0
.8408	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.840a	85 37		sta $37				sta 	1+zTemp0
.840c					_ClearZeroLoop:
.840c	b2 36		lda ($36)			lda 	(zTemp0) 					; end of variables if offset is zero.
.840e	f0 24		beq $8434			beq 	_ClearZeroEnd
.8410	a0 03		ldy #$03			ldy 	#3 							; erase the variables
.8412	a9 00		lda #$00			lda 	#0 							; set all the data to zero.
.8414					_ClearOneVariable:
.8414	91 36		sta ($36),y			sta 	(zTemp0),y
.8416	c8		iny				iny
.8417	c0 08		cpy #$08			cpy 	#8
.8419	d0 f9		bne $8414			bne 	_ClearOneVariable
.841b	a0 02		ldy #$02			ldy 	#2 							; has it been marked procedure
.841d	b1 36		lda ($36),y			lda 	(zTemp0),y
.841f	c9 18		cmp #$18			cmp 	#NSTProcedure
.8421	d0 04		bne $8427			bne 	_ClearNotProcedure
.8423	a9 04		lda #$04			lda 	#NSTInteger+NSBIsArray 		; if so set it back to an integer array
.8425	91 36		sta ($36),y			sta 	(zTemp0),y 					; will be fixed on the pre-run scan.
.8427					_ClearNotProcedure:
.8427	18		clc				clc 								; go to the next variable
.8428	b2 36		lda ($36)			lda 	(zTemp0) 					; offset to next, add to zTemp0
.842a	65 36		adc $36				adc 	zTemp0
.842c	85 36		sta $36				sta 	zTemp0
.842e	90 dc		bcc $840c			bcc 	_ClearZeroLoop
.8430	e6 37		inc $37				inc 	zTemp0+1
.8432	80 d8		bra $840c			bra 	_ClearZeroLoop
.8434					_ClearZeroEnd:
.8434	18		clc				clc
.8435	a5 36		lda $36				lda 	zTemp0
.8437	69 01		adc #$01			adc 	#1
.8439	8d 8c 04	sta $048c			sta 	lowMemPtr
.843c	a5 37		lda $37				lda 	zTemp0+1
.843e	69 00		adc #$00			adc 	#0
.8440	8d 8d 04	sta $048d			sta 	lowMemPtr+1
.8443	20 b6 a7	jsr $a7b6			jsr 	StackReset
.8446	20 20 a8	jsr $a820			jsr 	StringSystemInitialise
.8449	20 fb 8c	jsr $8cfb			jsr 	ProcedureScan
.844c	20 5b 8a	jsr $8a5b			jsr 	Command_Restore
.844f	9c 9e 04	stz $049e			stz 	AssemblerAddress
.8452	9c 9f 04	stz $049f			stz 	AssemblerAddress+1
.8455	9c a0 04	stz $04a0			stz 	AssemblerControl
.8458	20 9b 9a	jsr $9a9b			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.845b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/cls.asm

.845c					ClearScreen:
.845c	5a		phy				phy
.845d	a9 0c		lda #$0c			lda 	#12 						; char code 12 clears the screen.
.845f	20 91 a8	jsr $a891			jsr 	EXTPrintCharacter
.8462	7a		ply				ply
.8463	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/data.asm

.8464					Command_Data:
.8464	a9 3a		lda #$3a			lda 	#KWD_COLON 					; advance to colon/EOL
.8466	a2 80		ldx #$80			ldx 	#KWC_EOL
.8468	20 4d 8d	jsr $8d4d			jsr 	ScanForward
.846b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dim.asm

.846c					DimCommand:
.846c	b1 30		lda ($30),y			lda 	(codePtr),y
.846e	29 c0		and #$c0			and 	#$C0
.8470	c9 40		cmp #$40			cmp 	#$40
.8472	d0 7a		bne $84ee			bne 	_DCSyntax
.8474	b1 30		lda ($30),y			lda 	(codePtr),y
.8476	18		clc				clc
.8477	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8479	85 3f		sta $3f				sta 	zaTemp+1
.847b	c8		iny				iny
.847c	b1 30		lda ($30),y			lda 	(codePtr),y
.847e	c8		iny				iny
.847f	85 3e		sta $3e				sta 	zaTemp
.8481	5a		phy				phy
.8482	a0 02		ldy #$02			ldy 	#2 						; read type byte
.8484	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8486	29 18		and #$18			and 	#NSBTypeMask 			; check it's not a procedure
.8488	c9 18		cmp #$18			cmp 	#NSTProcedure
.848a	f0 62		beq $84ee			beq 	_DCSyntax
.848c	b1 3e		lda ($3e),y			lda 	(zaTemp),y 				; check it's an array
.848e	29 04		and #$04			and 	#NSBIsArray
.8490	f0 64		beq $84f6			beq 	_DCType
.8492	a0 04		ldy #$04			ldy 	#4 						; check not already defined
.8494	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8496	d0 59		bne $84f1			bne 	_DCRedefine
.8498	7a		ply				ply
.8499	20 f9 84	jsr $84f9			jsr 	_DCGetSize 				; get array size, check it.
.849c	5a		phy				phy
.849d	a0 05		ldy #$05			ldy 	#5 						; store in first array size slot
.849f	91 3e		sta ($3e),y			sta 	(zaTemp),y 				; second will be zero.
.84a1	7a		ply				ply 							; is there a second (e.g. ,x)
.84a2	b1 30		lda ($30),y			lda 	(codePtr),y
.84a4	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.84a6	d0 0a		bne $84b2			bne 	_DCOneDimension
.84a8	c8		iny				iny 							; skip comma
.84a9	20 f9 84	jsr $84f9			jsr 	_DCGetSize 				; get 2nd array size
.84ac	5a		phy				phy
.84ad	a0 06		ldy #$06			ldy 	#6 						; store in 2nd array size
.84af	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84b1	7a		ply				ply
.84b2					_DCOneDimension:
.84b2	5a		phy				phy 							; save position
.84b3	a0 05		ldy #$05			ldy 	#5 						; dimensions + 1 in AX (as zero based)
.84b5	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84b7	aa		tax				tax
.84b8	c8		iny				iny
.84b9	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84bb	e8		inx				inx 							; bump them.
.84bc	1a		inc a				inc 	a
.84bd	20 67 9e	jsr $9e67			jsr 	Multiply8x8 			; work out the total number of elements -> zTemp0
.84c0	a5 37		lda $37				lda 	zTemp0+1 				; don't allow more than 8192 elements whatever
.84c2	29 e0		and #$e0			and 	#$E0
.84c4	d0 23		bne $84e9			bne 	_DCSize
.84c6	a0 02		ldy #$02			ldy 	#2 						; get base type
.84c8	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84ca	20 07 85	jsr $8507			jsr 	ScaleByBaseType 		; scale by base type
.84cd	a5 36		lda $36				lda 	zTemp0
.84cf	a6 37		ldx $37				ldx 	zTemp0+1
.84d1	20 5d 9a	jsr $9a5d			jsr 	AllocateXABytes 		; allocate memory
.84d4	a0 03		ldy #$03			ldy 	#3 						; copy into the address.
.84d6	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84d8	c8		iny				iny
.84d9	8a		txa				txa
.84da	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84dc	7a		ply				ply 							; get position back
.84dd	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket 		; check )
.84e0	b1 30		lda ($30),y			lda 	(codePtr),y
.84e2	c8		iny				iny 							; consume in case
.84e3	c9 2c		cmp #$2c			cmp 	#KWD_COMMA		 		; if so do another DIM.
.84e5	f0 85		beq $846c			beq 	DimCommand
.84e7	88		dey				dey 							; undo consume
.84e8	60		rts				rts
.84e9					_DCSize:
.84e9	a9 16		lda #$16		lda	#22
.84eb	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler
.84ee					_DCSyntax:
.84ee	4c 5c a0	jmp $a05c			jmp 	SyntaxError
.84f1					_DCRedefine:
.84f1	a9 15		lda #$15		lda	#21
.84f3	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler
.84f6					_DCType:
.84f6	4c 66 a0	jmp $a066			jmp 	TypeError
.84f9					_DCGetSize:
.84f9	a2 00		ldx #$00			ldx 	#0 						; get first index.
.84fb	20 53 9e	jsr $9e53			jsr 	Evaluate8BitInteger 	; get array dimension
.84fe	c9 00		cmp #$00			cmp 	#0 						; must be 1-254
.8500	f0 e7		beq $84e9			beq 	_DCSize
.8502	c9 fe		cmp #$fe			cmp 	#254
.8504	f0 e3		beq $84e9			beq 	_DCSize
.8506	60		rts				rts
.8507					ScaleByBaseType:
.8507	29 10		and #$10			and 	#NSBIsString 			; is it string
.8509	d0 19		bne $8524			bne 	_SBBTString
.850b	a5 37		lda $37				lda 	zTemp0+1 				; push value on stack
.850d	48		pha				pha
.850e	a5 36		lda $36				lda 	zTemp0
.8510	48		pha				pha
.8511	06 36		asl $36				asl 	zTemp0 					; x 2
.8513	26 37		rol $37				rol 	zTemp0+1
.8515	06 36		asl $36				asl 	zTemp0 					; x 4
.8517	26 37		rol $37				rol 	zTemp0+1
.8519	68		pla				pla 							; add stacked value = x 5
.851a	65 36		adc $36				adc 	zTemp0
.851c	85 36		sta $36				sta 	zTemp0
.851e	68		pla				pla
.851f	65 37		adc $37				adc 	zTemp0+1
.8521	85 37		sta $37				sta 	zTemp0+1
.8523	60		rts				rts
.8524					_SBBTString:
.8524	06 36		asl $36				asl 	zTemp0
.8526	26 37		rol $37				rol 	zTemp0+1
.8528	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/end.asm

.8529					EndCommand:
.8529	4c 6b 83	jmp $836b			jmp 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/for.asm

.852c					ForCommand:
.852c	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; allocate 18 bytes on the return stack.
.852e	20 51 a7	jsr $a751			jsr 	StackOpen
.8531	a2 00		ldx #$00			ldx 	#0
.8533	20 98 98	jsr $9898			jsr 	EvaluateTerm
.8536	bd 00 04	lda $0400,x			lda 	NSStatus,x
.8539	c9 20		cmp #$20			cmp 	#NSBIsReference+NSTInteger 	; do we have an integer 4 byte reference.
.853b	d0 49		bne $8586			bne		_FCError
.853d	a9 3d		lda #$3d			lda 	#KWD_EQUAL 					; =
.853f	20 02 8e	jsr $8e02			jsr 	CheckNextA
.8542	e8		inx				inx
.8543	20 1e 9e	jsr $9e1e			jsr 	EvaluateInteger 			; <from> in +1
.8546	b1 30		lda ($30),y			lda 	(codePtr),y
.8548	c8		iny				iny 								; consume it
.8549	48		pha				pha 								; save on stack for later
.854a	c9 b4		cmp #$b4			cmp 	#KWD_DOWNTO
.854c	f0 04		beq $8552			beq 	_FCNoSyntax
.854e	c9 ce		cmp #$ce			cmp 	#KWD_TO
.8550	d0 37		bne $8589			bne 	_FCSyntaxError
.8552					_FCNoSyntax:
.8552	e8		inx				inx
.8553	20 1e 9e	jsr $9e1e			jsr 	EvaluateInteger
.8556	20 95 a7	jsr $a795			jsr 	STKSaveCodePosition 		; save loop back position
.8559	68		pla				pla 								; restore DOWNTO or TO
.855a	5a		phy				phy 								; save Y on the stack
.855b	49 b4		eor #$b4			eor 	#KWD_DOWNTO 				; 0 if DOWNTO, #0 if TO
.855d	f0 02		beq $8561			beq 	_FCNotDownTo
.855f	a9 02		lda #$02			lda 	#2
.8561					_FCNotDownTo:
.8561	3a		dec a				dec 	a 							; 255 if DOWNTO, 1 if TO
.8562	a0 10		ldy #$10			ldy 	#16
.8564	91 34		sta ($34),y			sta 	(basicStack),y 				; copy that out to the Basic Stack.
.8566	a0 06		ldy #$06			ldy 	#6
.8568	ad 08 04	lda $0408			lda 	NSMantissa0
.856b	91 34		sta ($34),y			sta 	(basicStack),y
.856d	ad 10 04	lda $0410			lda 	NSMantissa1
.8570	c8		iny				iny
.8571	91 34		sta ($34),y			sta 	(basicStack),y
.8573	a0 08		ldy #$08			ldy 	#8 							; set initial index value
.8575	a2 01		ldx #$01			ldx 	#1
.8577	20 8c 85	jsr $858c			jsr 	FCIntegerToStack
.857a	a0 0c		ldy #$0c			ldy 	#12 						; set the terminal value
.857c	a2 02		ldx #$02			ldx 	#2
.857e	20 8c 85	jsr $858c			jsr 	FCIntegerToStack
.8581	20 ac 85	jsr $85ac			jsr 	CopyIndexToReference
.8584	7a		ply				ply 								; restore position
.8585	60		rts				rts
.8586					_FCError:
.8586	4c 66 a0	jmp $a066			jmp 	TypeError
.8589					_FCSyntaxError:
.8589	4c 5c a0	jmp $a05c			jmp 	SyntaxError
.858c					FCIntegerToStack:
.858c	3c 00 04	bit $0400,x			bit 	NSStatus,x 					; is the value negative
.858f	10 03		bpl $8594			bpl	 	_FCNotNegative
.8591	20 87 9e	jsr $9e87			jsr 	NSMNegateMantissa 			; if so 2's complement the mantissa
.8594					_FCNotNegative:
.8594	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy out to the basic stack
.8597	91 34		sta ($34),y			sta 	(basicStack),y
.8599	c8		iny				iny
.859a	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.859d	91 34		sta ($34),y			sta 	(basicStack),y
.859f	c8		iny				iny
.85a0	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.85a3	91 34		sta ($34),y			sta 	(basicStack),y
.85a5	c8		iny				iny
.85a6	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.85a9	91 34		sta ($34),y			sta 	(basicStack),y
.85ab	60		rts				rts
.85ac					CopyIndexToReference:
.85ac	5a		phy				phy
.85ad	a0 06		ldy #$06			ldy 	#6 							; copy address-8 to write to zTemp0
.85af	38		sec				sec 								; (because we copy from offset 8)
.85b0	b1 34		lda ($34),y			lda 	(basicStack),y
.85b2	e9 08		sbc #$08			sbc 	#8
.85b4	85 36		sta $36				sta 	zTemp0
.85b6	c8		iny				iny
.85b7	b1 34		lda ($34),y			lda 	(basicStack),y
.85b9	e9 00		sbc #$00			sbc 	#0
.85bb	85 37		sta $37				sta 	zTemp0+1
.85bd	a2 04		ldx #$04			ldx 	#4 							; this is the copy counter/
.85bf	a0 0b		ldy #$0b			ldy 	#8+3 		 				; the MSB of the mantissa
.85c1	b1 34		lda ($34),y			lda 	(basicStack),y
.85c3	0a		asl a				asl 	a 							; into carry
.85c4	a0 08		ldy #$08			ldy 	#8 							; where to copy from.
.85c6	90 14		bcc $85dc			bcc 	_CITRNormal
.85c8	38		sec				sec
.85c9					_CITRNegative:
.85c9	a9 00		lda #$00			lda 	#0
.85cb	f1 34		sbc ($34),y			sbc 	(basicStack),y
.85cd	91 36		sta ($36),y			sta 	(zTemp0),y
.85cf	c8		iny				iny
.85d0	ca		dex				dex
.85d1	d0 f6		bne $85c9			bne 	_CITRNegative
.85d3	88		dey				dey 								; look at MSB of mantissa
.85d4	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set the MSB as negative packed.
.85d6	09 80		ora #$80			ora 	#$80
.85d8	91 36		sta ($36),y			sta 	(zTemp0),y
.85da	7a		ply				ply
.85db	60		rts				rts
.85dc					_CITRNormal:
.85dc	b1 34		lda ($34),y			lda 	(basicStack),y 				; copy without negation.
.85de	91 36		sta ($36),y			sta 	(zTemp0),y
.85e0	c8		iny				iny
.85e1	ca		dex				dex
.85e2	d0 f8		bne $85dc			bne 	_CITRNormal
.85e4	7a		ply				ply 								; and exit.
.85e5	60		rts				rts
.85e6					NextCommand:
.85e6	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; check FOR is TOS
.85e8	a2 11		ldx #$11			ldx 	#ERRID_FOR 					; this error
.85ea	20 7d a7	jsr $a77d			jsr 	StackCheckFrame
.85ed	5a		phy				phy
.85ee	a0 10		ldy #$10			ldy 	#16 						; get the step count
.85f0	b1 34		lda ($34),y			lda 	(basicStack),y
.85f2	85 36		sta $36				sta 	zTemp0 						; this is the sign extend
.85f4	30 02		bmi $85f8			bmi 	_NCStepNeg
.85f6	64 36		stz $36				stz 	zTemp0 						; which is 0 or 255
.85f8					_NCStepNeg:
.85f8	a0 08		ldy #$08			ldy 	#8 							; offset to bump
.85fa	a2 04		ldx #$04			ldx 	#4 							; count to bump
.85fc	18		clc				clc
.85fd					_NCBump:
.85fd	71 34		adc ($34),y			adc 	(basicStack),y 				; add it
.85ff	91 34		sta ($34),y			sta 	(basicStack),y
.8601	a5 36		lda $36				lda 	zTemp0 						; get sign extend for next time.
.8603	c8		iny				iny 								; next byte
.8604	ca		dex				dex 								; do four times
.8605	d0 f6		bne $85fd			bne 	_NCBump
.8607	20 ac 85	jsr $85ac			jsr		CopyIndexToReference		; copy it to the reference variable.
.860a	a0 10		ldy #$10			ldy 	#16 						; get step count again
.860c	b1 34		lda ($34),y			lda 	(basicStack),y
.860e	0a		asl a				asl 	a 							; sign bit to carry
.860f	a9 0c		lda #$0c			lda 	#12 						; offset of LHS = terminal offset
.8611	85 38		sta $38				sta 	zTemp1
.8613	90 02		bcc $8617			bcc 	_NCCompRev 					; use if step is +ve
.8615	a9 08		lda #$08			lda 	#8 							; now the LHS = index value
.8617					_NCCompRev:
.8617	85 38		sta $38				sta 	zTemp1 						; so zTemp0 is the index for LHS
.8619	49 04		eor #$04			eor 	#(8^12) 					; and zTemp0+1 is the index for RHS
.861b	85 39		sta $39				sta 	zTemp1+1
.861d	a2 04		ldx #$04			ldx 	#4 							; bytes to compare
.861f	38		sec				sec
.8620					_NCCompare:
.8620	a4 38		ldy $38				ldy 	zTemp1 						; do compare using the two indices
.8622	b1 34		lda ($34),y			lda 	(basicStack),y
.8624	a4 39		ldy $39				ldy 	zTemp1+1
.8626	f1 34		sbc ($34),y			sbc 	(basicStack),y
.8628	e6 38		inc $38				inc 	zTemp1 						; bump the indices (inc,dex do not change C or V)
.862a	e6 39		inc $39				inc 	zTemp1+1
.862c	ca		dex				dex 								; do it 4 times.
.862d	d0 f1		bne $8620			bne 	_NCCompare
.862f	50 02		bvc $8633			bvc 	_NCNoOverflow 				; convert to signed comparison
.8631	49 80		eor #$80			eor 	#$80
.8633					_NCNoOverflow:
.8633	7a		ply				ply 								; restore Y position
.8634	0a		asl a				asl 	a 							; is bit 7 set.
.8635	90 04		bcc $863b			bcc 	_NCLoopback 				; if no , >= so loop back
.8637	20 6f a7	jsr $a76f			jsr 	StackClose 					; exit the loop
.863a	60		rts				rts
.863b					_NCLoopBack:
.863b	20 a6 a7	jsr $a7a6			jsr 	STKLoadCodePosition 		; loop back
.863e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/gosub.asm

.863f					Command_GOSUB:
.863f	a2 00		ldx #$00			ldx 	#0
.8641	20 33 9e	jsr $9e33			jsr 	Evaluate16BitInteger 		; line number in Stack.0
.8644	a9 e3		lda #$e3			lda 	#STK_GOSUB+3
.8646	20 51 a7	jsr $a751			jsr 	StackOpen 					; create frame
.8649	20 95 a7	jsr $a795			jsr 	STKSaveCodePosition 		; save current position
.864c	4c 62 86	jmp $8662			jmp 	GotoStackX
.864f					Command_RETURN:
.864f	a9 e0		lda #$e0			lda 	#STK_GOSUB 					; check TOS is this
.8651	a2 0e		ldx #$0e			ldx 	#ERRID_GOSUB 				; this error
.8653	20 7d a7	jsr $a77d			jsr 	StackCheckFrame
.8656	20 a6 a7	jsr $a7a6			jsr 	STKLoadCodePosition 		; restore code position
.8659	20 6f a7	jsr $a76f			jsr 	StackClose
.865c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/goto.asm

.865d					GotoCommand:
.865d	a2 00		ldx #$00			ldx 	#0 							; GOTO where
.865f	20 33 9e	jsr $9e33			jsr 	Evaluate16BitInteger
.8662					GotoStackX:
.8662	bd 10 04	lda $0410,x			lda  	NSMantissa1,x 				; put line # in XA. I'll keep this even though
.8665	48		pha				pha 								; it is slightly inefficient, just in cases.
.8666	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.8669	fa		plx				plx
.866a	20 75 a6	jsr $a675			jsr 	MemorySearch 				; transfer to line number AX.
.866d	90 05		bcc $8674			bcc 	_GotoError 					; not found, off end.
.866f	d0 03		bne $8674			bne 	_GotoError 					; not found exactly
.8671	4c a5 8a	jmp $8aa5			jmp 	RunNewLine 					; and go straight to new line code.
.8674					_GotoError:
.8674	a9 0d		lda #$0d		lda	#13
.8676	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/if.asm

.8679					IfCommand:
.8679	a2 00		ldx #$00			ldx 	#0 							; If what.
.867b	20 fb 9d	jsr $9dfb			jsr 	EvaluateNumber
.867e	b1 30		lda ($30),y			lda 	(codePtr),y
.8680	c9 a8		cmp #$a8			cmp 	#KWD_THEN  					; could be THEN <stuff> or GOTO
.8682	d0 0a		bne $868e			bne 	_IFStructured
.8684	c8		iny				iny 								; consume THEN
.8685	20 02 9f	jsr $9f02			jsr 	NSMIsZero 					; is it zero
.8688	f0 01		beq $868b			beq 	_IfFail 					; if fail, go to next line
.868a	60		rts				rts 								; if THEN just continue
.868b					_IfFail:
.868b	4c 8d 8a	jmp $8a8d			jmp 	EOLCommand
.868e					_IfStructured:
.868e	20 02 9f	jsr $9f02			jsr 	NSMIsZero 					; is it zero
.8691	d0 07		bne $869a			bne 	_IfExit 					; if not, then continue normally.
.8693	a9 b5		lda #$b5			lda 	#KWD_ELSE 					; look for else/endif
.8695	a2 a5		ldx #$a5			ldx 	#KWD_ENDIF
.8697	20 4d 8d	jsr $8d4d			jsr 	ScanForward 				; and run from there/
.869a					_IfExit:
.869a	60		rts				rts
.869b					ElseCode:
.869b	a9 a5		lda #$a5			lda 	#KWD_ENDIF 					; else is only run after the if clause succeeds
.869d	aa		tax				tax 								; so just go to the structure exit
.869e	20 4d 8d	jsr $8d4d			jsr 	ScanForward
.86a1	60		rts				rts
.86a2					EndIf:
.86a2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/inputprint.asm

.86a3					Command_Input:
.86a3	a9 ff		lda #$ff			lda 	#$FF
.86a5	8d a8 04	sta $04a8			sta 	IsInputFlag
.86a8	80 03		bra $86ad			bra 	Command_IP_Main
.86aa					Command_Print:
.86aa	9c a8 04	stz $04a8			stz 	IsInputFlag
.86ad					Command_IP_Main:
.86ad	18		clc				clc 								; carry being clear means last print wasn't comma/semicolon
.86ae					_CPLoop:
.86ae	08		php				php 								; save last action flag
.86af	b1 30		lda ($30),y			lda 	(codePtr),y
.86b1	c9 80		cmp #$80			cmp  	#KWC_EOL 					; end of line or colon, exit now.
.86b3	f0 58		beq $870d			beq 	_CPExit
.86b5	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.86b7	f0 54		beq $870d			beq 	_CPExit
.86b9	68		pla				pla 								; throw last action flag
.86ba	b1 30		lda ($30),y			lda 	(codePtr),y
.86bc	c8		iny				iny
.86bd	c9 3b		cmp #$3b			cmp 	#KWD_SEMICOLON				; is it a semicolon
.86bf	f0 49		beq $870a			beq 	_CPContinueWithSameLine
.86c1	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; comma
.86c3	f0 40		beq $8705			beq 	_CPTab
.86c5	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; apostrophe (new line)
.86c7	f0 38		beq $8701			beq 	_CPNewLine
.86c9	88		dey				dey 								; undo the get.
.86ca	20 bc 93	jsr $93bc			jsr 	EvaluateExpressionAt0 		; evaluate expression at 0.
.86cd	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; read the status
.86d0	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.86d2	f0 0d		beq $86e1			beq 	_CPIsValue
.86d4	ad a8 04	lda $04a8			lda 	IsInputFlag 				; if print, dereference and print.
.86d7	f0 05		beq $86de			beq 	_CPIsPrint
.86d9	20 16 87	jsr $8716			jsr 	CIInputValue 				; input a value to the reference
.86dc	80 23		bra $8701			bra 	_CPNewLine
.86de					_CPIsPrint:
.86de	20 dc 96	jsr $96dc			jsr 	Dereference
.86e1					_CPIsValue:
.86e1	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; is it a number
.86e4	29 10		and #$10			and 	#NSBIsString
.86e6	f0 0b		beq $86f3			beq 	_CPNumber
.86e8	ae 10 04	ldx $0410			ldx 	NSMantissa1 				; string, print the text.
.86eb	ad 08 04	lda $0408			lda 	NSMantissa0
.86ee	20 7f 87	jsr $877f			jsr 	CPPrintStringXA
.86f1	80 ba		bra $86ad			bra 	Command_IP_Main 			; loop round clearing carry so NL if end
.86f3					_CPNumber:
.86f3	a9 05		lda #$05			lda 	#5 							; maximum decimals
.86f5	20 c8 9c	jsr $9cc8			jsr 	ConvertNumberToString 		; convert to string
.86f8	a2 06		ldx #$06			ldx 	#DecimalBuffer >> 8
.86fa	a9 1d		lda #$1d			lda 	#DecimalBuffer & $FF
.86fc	20 7f 87	jsr $877f			jsr 	CPPrintStringXA
.86ff	80 ac		bra $86ad			bra 	Command_IP_Main				; loop round clearing carry so NL if end
.8701					_CPNewLine:
.8701	a9 0d		lda #$0d			lda 	#13
.8703	80 02		bra $8707			bra 	_CPPrintChar
.8705					_CPTab:
.8705	a9 09		lda #$09			lda 	#9 							; print TAB
.8707					_CPPrintChar:
.8707	20 92 87	jsr $8792			jsr 	CPPrintVector
.870a					_CPContinueWithSameLine:
.870a	38		sec				sec 								; loop round with carry set, which
.870b	80 a1		bra $86ae			bra 	_CPLoop 					; will inhibit final CR
.870d					_CPExit:
.870d	28		plp				plp 								; get last action flag
.870e	b0 05		bcs $8715			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.8710	a9 0d		lda #$0d			lda 	#13 						; print new line
.8712	20 92 87	jsr $8792			jsr 	CPPrintVector
.8715					_CPExit2:
.8715	60		rts				rts
.8716					CIInputValue:
.8716	a2 00		ldx #$00			ldx 	#0 							; input a line.
.8718					_CIInputLine:
.8718	20 95 87	jsr $8795			jsr 	CPInputVector 				; get key
.871b	c9 0d		cmp #$0d			cmp 	#13 						; 13 = End
.871d	f0 1f		beq $873e			beq 	_CIHaveValue
.871f	c9 08		cmp #$08			cmp 	#8 							; 8 = BS
.8721	f0 11		beq $8734			beq 	_CIBackspace
.8723	c9 20		cmp #$20			cmp 	#32 						; ignore other control characters
.8725	90 f1		bcc $8718			bcc 	_CIInputLine
.8727	e0 50		cpx #$50			cpx 	#80 						; max length
.8729	b0 ed		bcs $8718			bcs 	_CIInputLine
.872b	9d aa 05	sta $05aa,x			sta 	lineBuffer,x
.872e	e8		inx				inx
.872f	20 92 87	jsr $8792			jsr 	CPPrintVector 				; echo it.
.8732	80 e4		bra $8718			bra 	_CIInputLine
.8734					_CIBackSpace:
.8734	e0 00		cpx #$00			cpx 	#0 							; nothing to delete
.8736	f0 e0		beq $8718			beq 	_CIInputLine
.8738	20 92 87	jsr $8792			jsr 	CPPrintVector 				; echo it.
.873b	ca		dex				dex
.873c	80 da		bra $8718			bra 	_CIInputLine
.873e					_CIHaveValue:
.873e	9e aa 05	stz $05aa,x			stz 	LineBuffer,x 				; ASCIIZ string now in line buffer.
.8741	ad 00 04	lda $0400			lda 	NSStatus 					; was it a string assignment
.8744	29 10		and #$10			and 	#NSBIsString
.8746	f0 1c		beq $8764			beq 	_CIAssignNumber 			; assign a number
.8748	a2 01		ldx #$01			ldx 	#1
.874a	a9 aa		lda #$aa			lda 	#lineBuffer & $FF 			; set up to point to new string
.874c	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.874f	a9 05		lda #$05			lda 	#lineBuffer >> 8
.8751	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.8754	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.8757	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.875a	a9 10		lda #$10			lda 	#NSBIsString 				; so it becomes a string value
.875c	9d 00 04	sta $0400,x			sta  	NSStatus,x
.875f	ca		dex				dex 								; X = 0
.8760	20 d4 87	jsr $87d4			jsr 	AssignVariable
.8763	60		rts				rts
.8764					_CIAssignNumber:
.8764	a9 aa		lda #$aa			lda 	#lineBuffer & $FF 			; set up to point to new string
.8766	85 36		sta $36				sta 	zTemp0
.8768	a9 05		lda #$05			lda 	#lineBuffer >> 8
.876a	85 37		sta $37				sta 	zTemp0+1
.876c	a2 01		ldx #$01			ldx 	#1 							; put in slot 1
.876e	20 4a 9c	jsr $9c4a			jsr 	ValEvaluateZTemp0 			; use the VAL() code
.8771	90 07		bcc $877a			bcc 	_CIIsOkay
.8773	a9 3f		lda #$3f			lda 	#"?" 						; error ?
.8775	20 92 87	jsr $8792			jsr 	CPPrintVector
.8778	80 9c		bra $8716			bra 	CIInputValue
.877a					_CIIsOkay:
.877a	ca		dex				dex 								; X = 0
.877b	20 d4 87	jsr $87d4			jsr 	AssignVariable
.877e	60		rts				rts
.877f					CPPrintStringXA:
.877f	5a		phy				phy
.8780	86 37		stx $37				stx 	zTemp0+1
.8782	85 36		sta $36				sta 	zTemp0
.8784	a0 00		ldy #$00			ldy 	#0
.8786					_PSXALoop:
.8786	b1 36		lda ($36),y			lda 	(zTemp0),y
.8788	f0 06		beq $8790			beq 	_PSXAExit
.878a	20 92 87	jsr $8792			jsr 	CPPrintVector
.878d	c8		iny				iny
.878e	80 f6		bra $8786			bra 	_PSXALoop
.8790					_PSXAExit:
.8790	7a		ply				ply
.8791	60		rts				rts
.8792					CPPrintVector:
.8792	4c 91 a8	jmp $a891			jmp 	EXTPrintCharacter
.8795					CPInputVector:
.8795	4c 27 ab	jmp $ab27			jmp 	EXTInputSingleCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/let.asm

.8798					LetCommand:
.8798	a2 00		ldx #$00			ldx 	#0
.879a	b1 30		lda ($30),y			lda 	(codePtr),y
.879c	c9 10		cmp #$10			cmp 	#KWD_AT
.879e	d0 16		bne $87b6			bne 	_LCStandard
.87a0	c8		iny				iny 								; skip equal
.87a1	20 98 98	jsr $9898			jsr 	EvaluateTerm 				; get a number
.87a4	20 dc 96	jsr $96dc			jsr 	Dereference 				; dereference it
.87a7	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check integer
.87aa	49 20		eor #$20			eor 	#NSBIsReference	 			; toggle reference
.87ac	9d 00 04	sta $0400,x			sta 	NSStatus,x
.87af	29 20		and #$20			and 	#NSBIsReference 			; if it is now a reference, continue
.87b1	d0 10		bne $87c3			bne 	_LCMain
.87b3	4c 66 a0	jmp $a066			jmp 	TypeError 					; was a reference before.
.87b6					_LCStandard:
.87b6	ad a6 93	lda $93a6			lda 	PrecedenceLevel+"*"			; precedence > this
.87b9	20 c0 93	jsr $93c0			jsr 	EvaluateExpressionAtPrecedence
.87bc	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; is it a reference to an array
.87bf	c9 38		cmp #$38			cmp		#NSTProcedure+NSBIsReference
.87c1	f0 0e		beq $87d1			beq 	_LetGoProc 					; it's a procedure call.
.87c3					_LCMain:
.87c3	a9 3d		lda #$3d			lda 	#"=" 						; check =
.87c5	20 02 8e	jsr $8e02			jsr 	CheckNextA
.87c8	e8		inx				inx 								; RHS
.87c9	20 f2 9d	jsr $9df2			jsr 	EvaluateValue
.87cc	ca		dex				dex
.87cd	20 d4 87	jsr $87d4			jsr 	AssignVariable
.87d0	60		rts				rts
.87d1					_LetGoProc:
.87d1	4c 65 89	jmp $8965			jmp 	CallProcedure
.87d4					AssignVariable:
.87d4	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check the string/number type bits match
.87d7	48		pha				pha 								; save a copy
.87d8	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.87db	29 10		and #$10			and 	#NSBIsString
.87dd	d0 0b		bne $87ea			bne 	_ASError
.87df	68		pla				pla 								; get back
.87e0	29 10		and #$10			and 	#NSBIsString 				; check type
.87e2	d0 03		bne $87e7			bne 	_ASString
.87e4	4c 04 96	jmp $9604			jmp 	AssignNumber
.87e7					_ASString:
.87e7	4c 72 96	jmp $9672			jmp 	AssignString
.87ea					_ASError:
.87ea	4c 66 a0	jmp $a066			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/list.asm

.87ed					Command_List:
.87ed	9c a6 04	stz $04a6			stz 	listIndent 					; reset indent.
.87f0	9c 0c 04	stz $040c			stz		NSMantissa0+4				; set the lower (slot 4) to 0 and upper (slot 7) to $FFFF
.87f3	9c 14 04	stz $0414			stz 	NSMantissa1+4
.87f6	a9 ff		lda #$ff			lda 	#$FF
.87f8	8d 0f 04	sta $040f			sta 	NSMantissa0+7
.87fb	8d 17 04	sta $0417			sta 	NSMantissa1+7
.87fe	b1 30		lda ($30),y			lda 	(codePtr),y
.8800	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8802	f0 1e		beq $8822			beq 	_CLSecond
.8804	20 83 88	jsr $8883			jsr 	CLIsDigit 					; if not digit, list all
.8807	b0 24		bcs $882d			bcs 	_CLStart
.8809	a2 04		ldx #$04			ldx 	#4 							; get 1st range into slot 4
.880b	20 33 9e	jsr $9e33			jsr 	Evaluate16BitInteger
.880e	b1 30		lda ($30),y			lda 	(codePtr),y
.8810	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8812	f0 0e		beq $8822			beq 	_CLSecond 					; if so go get it
.8814	ad 0c 04	lda $040c			lda 	NSMantissa0+4 				; copy 4->7
.8817	8d 0f 04	sta $040f			sta 	NSMantissa0+7
.881a	ad 14 04	lda $0414			lda 	NSMantissa1+4
.881d	8d 17 04	sta $0417			sta 	NSMantissa1+7
.8820	80 0b		bra $882d			bra 	_CLStart
.8822					_CLSecond:
.8822	c8		iny				iny 								; consume comma
.8823	20 83 88	jsr $8883			jsr 	CLIsDigit 					; digit found
.8826	b0 05		bcs $882d			bcs 	_CLStart 					; if not, continue listing
.8828	a2 07		ldx #$07			ldx 	#7 							; load 2nd range into slot 7
.882a	20 33 9e	jsr $9e33			jsr 	Evaluate16BitInteger
.882d					_CLStart
.882d	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.882f	85 30		sta $30				sta 	codePtr
.8831	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8833	85 31		sta $31				sta 	codePtr+1
.8835					_CLLoop:
.8835	20 47 ab	jsr $ab47			jsr 	EXTBreakCheck 				; break check
.8838	f0 33		beq $886d			beq 	_CLExit
.883a	b2 30		lda ($30)			lda 	(codePtr)
.883c	f0 2f		beq $886d			beq 	_CLExit
.883e	a2 04		ldx #$04			ldx 	#4 							; check range every time, line numbers aren't in order.
.8840	20 70 88	jsr $8870			jsr 	CLCompareLineNo
.8843	90 1b		bcc $8860			bcc 	_CLNext
.8845	a2 07		ldx #$07			ldx 	#7
.8847	20 70 88	jsr $8870			jsr 	CLCompareLineNo
.884a	f0 02		beq $884e			beq 	_CLDoThisOne
.884c	b0 12		bcs $8860			bcs 	_CLNext
.884e					_CLDoThisOne:
.884e	20 b0 8d	jsr $8db0			jsr 	ScanGetCurrentLineStep 		; get indent adjust.
.8851	20 91 b4	jsr $b491			jsr 	ListConvertLine 			; convert line into token Buffer
.8854	a2 04		ldx #$04			ldx 	#(tokenBuffer >> 8) 		; print that line
.8856	a9 ad		lda #$ad			lda 	#(tokenBuffer & $FF)
.8858	20 64 8e	jsr $8e64			jsr 	PrintStringXA
.885b	a9 0d		lda #$0d			lda 	#13 						; new line
.885d	20 91 a8	jsr $a891			jsr 	EXTPrintCharacter
.8860					_CLNext:
.8860	18		clc				clc
.8861	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8863	65 30		adc $30				adc 	codePtr
.8865	85 30		sta $30				sta 	codePtr
.8867	90 02		bcc $886b			bcc 	_CREExit
.8869	e6 31		inc $31				inc 	codePtr+1 					; carry
.886b					_CREExit:
.886b	80 c8		bra $8835			bra 	_CLLoop
.886d					_CLExit:
.886d	4c 6b 83	jmp $836b			jmp 	WarmStart
.8870					CLCompareLineNo:
.8870	38		sec				sec
.8871	a0 01		ldy #$01			ldy 	#1
.8873	b1 30		lda ($30),y			lda 	(codePtr),y
.8875	fd 08 04	sbc $0408,x			sbc 	NSMantissa0,x
.8878	85 36		sta $36				sta 	zTemp0
.887a	c8		iny				iny
.887b	b1 30		lda ($30),y			lda 	(codePtr),y
.887d	fd 10 04	sbc $0410,x			sbc 	NSMantissa1,x
.8880	05 36		ora $36				ora 	zTemp0
.8882	60		rts				rts
.8883					CLIsDigit:
.8883	b1 30		lda ($30),y			lda 	(codePtr),y
.8885	c9 30		cmp #$30			cmp 	#"0"
.8887	90 03		bcc $888c			bcc	 	_CLIDExitFalse
.8889	c9 3a		cmp #$3a			cmp 	#"9"+1
.888b	60		rts				rts
.888c					_CLIDExitFalse:
.888c	38		sec				sec
.888d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/local.asm

.888e					Command_LOCAL:
.888e	a2 00		ldx #$00			ldx 	#0 							; at level 0
.8890	20 9c 88	jsr $889c			jsr 	LocaliseNextTerm 			; convert term to a local.
.8893	b1 30		lda ($30),y			lda 	(codePtr),y
.8895	c8		iny				iny
.8896	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8898	f0 f4		beq $888e			beq 	Command_LOCAL
.889a	88		dey				dey 								; unpick pre-get
.889b	60		rts				rts
.889c					LocaliseNextTerm:
.889c	20 98 98	jsr $9898			jsr 	EvaluateTerm 				; evaluate the term
.889f	bd 00 04	lda $0400,x			lda 	NSStatus,x
.88a2	29 20		and #$20			and 	#NSBIsReference 			; check it is a reference
.88a4	f0 61		beq $8907			beq		_LNTError
.88a6	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address of variable to zTemp0
.88a9	85 36		sta $36				sta 	zTemp0
.88ab	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.88ae	85 37		sta $37				sta  	zTemp0+1
.88b0	bd 00 04	lda $0400,x			lda 	NSStatus,x
.88b3	29 10		and #$10			and 	#NSBIsString
.88b5	d0 1e		bne $88d5			bne 	_LNTPushString
.88b7	5a		phy				phy
.88b8	a0 00		ldy #$00			ldy 	#0 							; push 0 to 4 inclusive, the number values, on the stack, and zero them as you go.
.88ba					_LNTPushNumLoop:
.88ba	b1 36		lda ($36),y			lda		(zTemp0),y
.88bc	20 2f a7	jsr $a72f			jsr 	StackPushByte
.88bf	c8		iny				iny
.88c0	c0 05		cpy #$05			cpy 	#5
.88c2	d0 f6		bne $88ba			bne 	_LNTPushNumLoop
.88c4	a5 36		lda $36				lda 	zTemp0 						; push the actual target address to write on the stack
.88c6	20 2f a7	jsr $a72f			jsr 	StackPushByte
.88c9	a5 37		lda $37				lda 	zTemp0+1
.88cb	20 2f a7	jsr $a72f			jsr 	StackPushByte
.88ce	a9 01		lda #$01			lda 	#STK_LOCALN 				; push local-number marker.
.88d0	20 2f a7	jsr $a72f			jsr 	StackPushByte
.88d3	7a		ply				ply
.88d4	60		rts				rts
.88d5					_LNTPushString:
.88d5	5a		phy				phy
.88d6	b2 36		lda ($36)			lda 	(zTemp0) 					; put address of string in zTemp1
.88d8	85 38		sta $38				sta 	zTemp1
.88da	a0 01		ldy #$01			ldy 	#1
.88dc	b1 36		lda ($36),y			lda 	(zTemp0),y
.88de	85 39		sta $39				sta 	zTemp1+1
.88e0	a0 00		ldy #$00			ldy 	#0 							; output string
.88e2	c9 00		cmp #$00			cmp 	#0 							; if not assigned strin
.88e4	f0 0a		beq $88f0			beq 	_LNTStringOut
.88e6					_LNTPushStrLoop:
.88e6	b1 38		lda ($38),y			lda 	(zTemp1),y
.88e8	f0 06		beq $88f0			beq 	_LNTStringOut
.88ea	20 2f a7	jsr $a72f			jsr 	StackPushByte
.88ed	c8		iny				iny
.88ee	80 f6		bra $88e6			bra 	_LNTPushStrLoop
.88f0					_LNTStringOut:
.88f0	98		tya				tya									; output length
.88f1	20 2f a7	jsr $a72f			jsr 	StackPushByte
.88f4	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; output address of the string record *not* the string itself
.88f7	20 2f a7	jsr $a72f			jsr 	StackPushByte
.88fa	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.88fd	20 2f a7	jsr $a72f			jsr 	StackPushByte
.8900	a9 02		lda #$02			lda 	#STK_LOCALS 				; push local-string marker.
.8902	20 2f a7	jsr $a72f			jsr 	StackPushByte
.8905	7a		ply				ply
.8906	60		rts				rts
.8907					_LNTError:
.8907	4c 5c a0	jmp $a05c			jmp 	SyntaxError
.890a					LocalPopValue:
.890a	20 48 a7	jsr $a748			jsr 	StackPopByte
.890d	c9 01		cmp #$01			cmp 	#STK_LOCALN 				; if not local-N
.890f	d0 17		bne $8928			bne 	_LPVString
.8911	20 48 a7	jsr $a748			jsr 	StackPopByte 				; address
.8914	85 37		sta $37				sta 	zTemp0+1
.8916	20 48 a7	jsr $a748			jsr 	StackPopByte
.8919	85 36		sta $36				sta 	zTemp0
.891b	5a		phy				phy
.891c	a0 04		ldy #$04			ldy 	#4 							; copy back
.891e					_LPVNumberCopy:
.891e	20 48 a7	jsr $a748			jsr 	StackPopByte
.8921	91 36		sta ($36),y			sta 	(zTemp0),y
.8923	88		dey				dey
.8924	10 f8		bpl $891e			bpl 	_LPVNumberCopy
.8926	7a		ply				ply 								; and complete
.8927	60		rts				rts
.8928					_LPVString:
.8928	20 48 a7	jsr $a748			jsr 	StackPopByte 				; address of record => zTemp0
.892b	85 37		sta $37				sta 	zTemp0+1
.892d	20 48 a7	jsr $a748			jsr 	StackPopByte
.8930	85 36		sta $36				sta 	zTemp0
.8932	5a		phy				phy
.8933	b2 36		lda ($36)			lda 	(zTemp0) 					; address to write string to => zTemp1
.8935	85 38		sta $38				sta 	zTemp1
.8937	a0 01		ldy #$01			ldy 	#1
.8939	b1 36		lda ($36),y			lda 	(zTemp0),y
.893b	85 39		sta $39				sta 	zTemp1+1
.893d	20 48 a7	jsr $a748			jsr 	StackPopByte 				; # to get => y
.8940	a8		tay				tay
.8941	a5 39		lda $39				lda 	zTemp1+1 					; if no target (e.g. was "" originally) exit
.8943	f0 0e		beq $8953			beq 	_LPVStringCopied
.8945	a9 00		lda #$00			lda 	#0 							; NULL on end
.8947	91 38		sta ($38),y			sta 	(zTemp1),y
.8949					_LPVStringCopy:
.8949	88		dey				dey
.894a	30 07		bmi $8953			bmi 	_LPVStringCopied
.894c	20 48 a7	jsr $a748			jsr 	StackPopByte
.894f	91 38		sta ($38),y			sta 	(zTemp1),y
.8951	80 f6		bra $8949			bra 	_LPVStringCopy
.8953					_LPVStringCopied:
.8953	fa		plx				plx
.8954	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/new.asm

.8955					NewCommand:
.8955	20 5b 89	jsr $895b			jsr 	NewProgram 					; does the actual NEW.
.8958	4c 6b 83	jmp $836b			jmp 	WarmStart 					; and warm starts straight away.
.895b					NewProgram:
.895b	20 53 a6	jsr $a653			jsr 	MemoryNew
.895e	9c 00 10	stz $1000			stz 	VariableSpace 				; erase all variables.
.8961	20 04 84	jsr $8404			jsr 	ClearCommand 				; clear everything.
.8964	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/procedure.asm

=2					ParameterStackPos = 2
.8965					CallProcedure:
.8965	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start storing parameters at 2.
.8967	b1 30		lda ($30),y			lda 	(codePtr),y
.8969	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.896b	f0 0c		beq $8979			beq 	_CPEndParam
.896d					_CPParamLoop:
.896d	20 f2 9d	jsr $9df2			jsr 	EvaluateValue 				; get parameter onto stack
.8970	e8		inx				inx 								; bump next stack
.8971	b1 30		lda ($30),y			lda 	(codePtr),y
.8973	c8		iny				iny
.8974	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if comma, go back and try again.
.8976	f0 f5		beq $896d			beq 	_CPParamLoop
.8978	88		dey				dey 								; unpick.
.8979					_CPEndParam:
.8979	8e 96 04	stx $0496			stx 	LastParameter 				; save the last parameters index.
.897c	c8		iny				iny									; skip right bracket
.897d	a9 b3		lda #$b3			lda 	#STK_PROC+3 				; allocate 6 bytes on the return stack.
.897f	20 51 a7	jsr $a751			jsr 	StackOpen
.8982	20 95 a7	jsr $a795			jsr 	STKSaveCodePosition 		; save loop position
.8985	ad 08 04	lda $0408			lda 	NSMantissa0 				; copy variable (e.g. procedure) address to zTemp0
.8988	85 36		sta $36				sta 	zTemp0 						; this is the DATA not the RECORD
.898a	ad 10 04	lda $0410			lda 	NSMantissa1
.898d	85 37		sta $37				sta 	zTemp0+1
.898f	a0 01		ldy #$01			ldy 	#1 							; copy code address back.
.8991	b2 36		lda ($36)			lda 	(zTemp0)
.8993	85 30		sta $30				sta 	safePtr
.8995	b1 36		lda ($36),y			lda 	(zTemp0),y
.8997	85 31		sta $31				sta 	safePtr+1
.8999	c8		iny				iny
.899a	b1 36		lda ($36),y			lda 	(zTemp0),y
.899c	85 32		sta $32				sta 	safePtr+2
.899e	c8		iny				iny
.899f	b1 36		lda ($36),y			lda 	(zTemp0),y
.89a1	85 33		sta $33				sta 	safePtr+3
.89a3	c8		iny				iny 								; get Y offset -> Y
.89a4	b1 36		lda ($36),y			lda 	(zTemp0),y
.89a6	a8		tay				tay
.89a7	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start position of parameters
.89a9	ec 96 04	cpx $0496			cpx	 	LastParameter 				; check no parameters at the start
.89ac	f0 13		beq $89c1			beq 	_ParamExit 					; if so, exit.
.89ae					_ParamExtract:
.89ae	ca		dex				dex 								; put a local term on the level before
.89af	20 9c 88	jsr $889c			jsr 	LocaliseNextTerm			; also pushes original param value to basic stack
.89b2	20 d4 87	jsr $87d4			jsr 	AssignVariable 				; assign stacked value to the variable.
.89b5	e8		inx				inx 								; advance to next parameter to do.
.89b6	e8		inx				inx
.89b7	ec 96 04	cpx $0496			cpx 	LastParameter 				; are we done ?
.89ba	f0 05		beq $89c1			beq 	_ParamExit
.89bc	20 fa 8d	jsr $8dfa			jsr 	CheckComma 					; comma seperating parameters
.89bf	80 ed		bra $89ae			bra 	_ParamExtract
.89c1					_ParamExit:
.89c1	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket 			; check )
.89c4	60		rts				rts 								; and continue from here
.89c5					Command_ENDPROC:
.89c5	a9 b0		lda #$b0			lda 	#STK_PROC 					; check TOS is this
.89c7	a2 14		ldx #$14			ldx 	#ERRID_PROC
.89c9	20 7d a7	jsr $a77d			jsr 	StackCheckFrame
.89cc	20 a6 a7	jsr $a7a6			jsr 	STKLoadCodePosition 		; restore code position
.89cf	20 6f a7	jsr $a76f			jsr 	StackClose
.89d2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/read.asm

.89d3					Command_Read:
.89d3	a2 00		ldx #$00			ldx 	#0 							; evaluate the term which is the var/array element to assign
.89d5	20 98 98	jsr $9898			jsr 	EvaluateTerm
.89d8	bd 00 04	lda $0400,x			lda 	NSStatus,x
.89db	29 20		and #$20			and 	#NSBIsReference				; get status byte on stack, identifies int, float, string.
.89dd	f0 4a		beq $8a29			beq 	_CRSyntax 					; check reference (bit 0)
.89df	20 72 8a	jsr $8a72			jsr 	SwapDataCodePtrs 			; swap code and data
.89e2	ad 9c 04	lda $049c			lda 	inDataStatement 			; if in a data statement, we don't need to search
.89e5	d0 20		bne $8a07			bne 	_CRContinueData
.89e7					_CRKeepSearching:
.89e7	a9 b2		lda #$b2			lda 	#KWD_DATA 					; scan for instruction
.89e9	aa		tax				tax
.89ea	20 4d 8d	jsr $8d4d			jsr 	ScanForward
.89ed	c9 b2		cmp #$b2			cmp 	#KWD_DATA 					; found data ?
.89ef	f0 16		beq $8a07			beq 	_CRHaveData 				; found it
.89f1	18		clc				clc
.89f2	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.89f4	65 30		adc $30				adc 	codePtr
.89f6	85 30		sta $30				sta 	codePtr
.89f8	90 02		bcc $89fc			bcc 	_CREExit
.89fa	e6 31		inc $31				inc 	codePtr+1 					; carry
.89fc					_CREExit:
.89fc	a0 03		ldy #$03			ldy 	#3 							; start of line.
.89fe	b2 30		lda ($30)			lda 	(codePtr)
.8a00	d0 e5		bne $89e7			bne 	_CRKeepSearching
.8a02	a9 0b		lda #$0b		lda	#11
.8a04	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler
.8a07					_CRHaveData:
.8a07					_CRContinueData:
.8a07	a2 01		ldx #$01			ldx 	#1
.8a09	20 f2 9d	jsr $9df2			jsr 	EvaluateValue 				; evaluate value into slot # 1
.8a0c	ca		dex				dex
.8a0d	20 d4 87	jsr $87d4			jsr		AssignVariable 				; do the assignment
.8a10	9c 9c 04	stz $049c			stz 	inDataStatement 			; clear in data
.8a13	b1 30		lda ($30),y			lda 	(codePtr),y
.8a15	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not, end of data statement
.8a17	d0 04		bne $8a1d			bne 	_CRSwapBack
.8a19	c8		iny				iny 								; consume comma
.8a1a	ee 9c 04	inc $049c			inc 	inDataStatement 			; set in data statement currently.
.8a1d					_CRSwapBack:
.8a1d	20 72 8a	jsr $8a72			jsr 	SwapDataCodePtrs			; swap them back.
.8a20	b1 30		lda ($30),y			lda 	(codePtr),y
.8a22	c8		iny				iny
.8a23	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8a25	f0 ac		beq $89d3			beq 	Command_Read 				; if so go round again.
.8a27	88		dey				dey 								; unpick get.
.8a28	60		rts				rts
.8a29					_CRSyntax:
.8a29	4c 5c a0	jmp $a05c			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/rem.asm

.8a2c					RemCommand:
.8a2c	b1 30		lda ($30),y			lda 	(codePtr),y
.8a2e	c9 ff		cmp #$ff			cmp 	#KWC_STRING
.8a30	d0 06		bne $8a38			bne 	_RMExit
.8a32	c8		iny				iny 								; point to offset
.8a33	98		tya				tya 								; A = offset position
.8a34	38		sec				sec 								; add size +1 hence SEC
.8a35	71 30		adc ($30),y			adc 	(codePtr),y
.8a37	a8		tay				tay 								; make current position.
.8a38					_RMExit:
.8a38	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/repeat.asm

.8a39					Command_REPEAT:
.8a39	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; allocate 6 bytes on the return stack.
.8a3b	20 51 a7	jsr $a751			jsr 	StackOpen
.8a3e	20 95 a7	jsr $a795			jsr 	STKSaveCodePosition 		; save loop position
.8a41	60		rts				rts
.8a42					Command_UNTIL:
.8a42	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; check REPEAT is TOS
.8a44	a2 0f		ldx #$0f			ldx 	#ERRID_REPEAT 				; this error
.8a46	20 7d a7	jsr $a77d			jsr 	StackCheckFrame
.8a49	a2 00		ldx #$00			ldx 	#0
.8a4b	20 fb 9d	jsr $9dfb			jsr 	EvaluateNumber 				; work out the number
.8a4e	20 02 9f	jsr $9f02			jsr 	NSMIsZero 					; check if zero
.8a51	f0 04		beq $8a57			beq 	_CULoopBack 				; if so keep looping
.8a53	20 6f a7	jsr $a76f			jsr 	StackClose		 			; return
.8a56	60		rts				rts
.8a57					_CULoopBack:
.8a57	20 a6 a7	jsr $a7a6			jsr 	STKLoadCodePosition 		; loop back
.8a5a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/restore.asm

.8a5b					Command_Restore:
.8a5b	20 72 8a	jsr $8a72			jsr 	SwapDataCodePtrs 			; swap code and data
.8a5e	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8a60	85 30		sta $30				sta 	codePtr
.8a62	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8a64	85 31		sta $31				sta 	codePtr+1
.8a66	20 72 8a	jsr $8a72			jsr 	SwapDataCodePtrs 			; put them back
.8a69	a9 03		lda #$03			lda 	#3 							; start at offset 3, e.g. first instruction of first line.
.8a6b	8d 9b 04	sta $049b			sta 	dataPointer+4
.8a6e	9c 9c 04	stz $049c			stz 	inDataStatement 			; not in data statement
.8a71	60		rts				rts
.8a72					SwapDataCodePtrs:
.8a72	da		phx				phx
.8a73	a2 03		ldx #$03			ldx 	#3 							; swap 32 bit code pointer over
.8a75					_SDCPLoop:
.8a75	b5 30		lda $30,x			lda 	safePtr,x
.8a77	48		pha				pha
.8a78	bd 97 04	lda $0497,x			lda 	dataPointer,x
.8a7b	95 30		sta $30,x			sta 	safePtr,x
.8a7d	68		pla				pla
.8a7e	9d 97 04	sta $0497,x			sta 	dataPointer,x
.8a81	ca		dex				dex
.8a82	10 f1		bpl $8a75			bpl 	_SDCPLoop
.8a84	ad 9b 04	lda $049b			lda 	dataPointer+4 				; swap Y position over.
.8a87	8c 9b 04	sty $049b			sty 	dataPointer+4
.8a8a	a8		tay				tay
.8a8b	fa		plx				plx
.8a8c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/run.asm

.8a8d					EOLCommand:
.8a8d	18		clc				clc
.8a8e	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8a90	65 30		adc $30				adc 	codePtr
.8a92	85 30		sta $30				sta 	codePtr
.8a94	90 02		bcc $8a98			bcc 	_CREExit
.8a96	e6 31		inc $31				inc 	codePtr+1 					; carry
.8a98					_CREExit:
.8a98	80 0b		bra $8aa5			bra 	RunNewLine
.8a9a					CommandRUN:
.8a9a	20 04 84	jsr $8404			jsr 	ClearCommand 				; clear variable/stacks/etc.
.8a9d	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8a9f	85 30		sta $30				sta 	codePtr
.8aa1	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8aa3	85 31		sta $31				sta 	codePtr+1
.8aa5					RUNNewLine:
.8aa5	b2 30		lda ($30)			lda 	(codePtr)
.8aa7	f0 72		beq $8b1b			beq 	CRNoProgram         		; no then END.
.8aa9	a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack
.8aab	9a		txs				txs
.8aac					RUNCodePointerLine:
.8aac	a0 02		ldy #$02			ldy 	#2 							; start of program
.8aae					_CRIncMainLoop:
.8aae	0e 93 04	asl $0493			asl 	breakCheck 					; clears 1 time in 8
.8ab1	d0 19		bne $8acc			bne 	_CRNoBreakCheck
.8ab3	20 47 ab	jsr $ab47			jsr 	EXTBreakCheck 				; break check
.8ab6	f0 5e		beq $8b16			beq 	_CRBreak
.8ab8	64 01		stz $01				stz 	1 							; access I/O Page 0
.8aba	38		sec				sec 								; calculate timer - LastTick
.8abb	ad 59 d6	lda $d659			lda 	$D659
.8abe	aa		tax				tax 								; saving timer in X
.8abf	ed 2f 06	sbc $062f			sbc 	LastTick
.8ac2	c9 03		cmp #$03			cmp 	#3
.8ac4	90 06		bcc $8acc			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.8ac6	8e 2f 06	stx $062f			stx 	LastTick 					; update last timer
.8ac9	20 b8 ba	jsr $bab8			jsr 	TickHandler 				; go do the code.
.8acc					_NoFireTick:
.8acc					_CRNoBreakCheck:
.8acc	c8		iny				iny
.8acd					_CRMainLoop:
.8acd	9c 90 04	stz $0490			stz 	stringInitialised 			; clear the temporary string initialised flag.
.8ad0	b1 30		lda ($30),y			lda 	(codePtr),y
.8ad2	10 10		bpl $8ae4			bpl 	_CRNotKeyword
.8ad4	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1 			; if after unary, legitimate command
.8ad6	b0 04		bcs $8adc			bcs 	_CRIsKeyword
.8ad8	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if unary, syntax error.
.8ada	b0 34		bcs $8b10			bcs		_CRSyntaxError
.8adc					_CRIsKeyword:
.8adc	c8		iny				iny 								; consume command
.8add	0a		asl a				asl 	a 							; double losing the MSB which is '1' as tokens are $80-$FF
.8ade	aa		tax				tax 								; put in X for vector jump
.8adf	20 13 8b	jsr $8b13			jsr 	_CRCallVector0 				; call the vector - effectively jsr (vectortable,X)
.8ae2	80 e9		bra $8acd			bra 	_CRMainLoop 				; and loop round
.8ae4					_CRNotKeyword:
.8ae4	c9 3a		cmp #$3a			cmp 	#KWD_COLON 					; if a :, consume it and go round.
.8ae6	f0 c6		beq $8aae			beq 	_CRIncMainLoop
.8ae8	c9 40		cmp #$40			cmp 	#$40 						; variable/call reference
.8aea	90 05		bcc $8af1			bcc 	_CRNotVariable
.8aec					_CRGoLet:
.8aec	20 98 87	jsr $8798			jsr 	LetCommand
.8aef	80 dc		bra $8acd			bra 	_CRMainLoop
.8af1					_CRNotVariable:
.8af1	c9 10		cmp #$10			cmp 	#KWD_AT 					; handle @
.8af3	f0 f7		beq $8aec			beq 	_CRGoLet
.8af5	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; handle ? !
.8af7	f0 f3		beq $8aec			beq 	_CRGoLet
.8af9	c9 21		cmp #$21			cmp 	#KWD_PLING
.8afb	f0 ef		beq $8aec			beq 	_CRGoLet
.8afd	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; handle ' (comment)
.8aff	f0 09		beq $8b0a			beq 	_CRGoRem
.8b01	c9 2e		cmp #$2e			cmp 	#KWD_PERIOD 				; handle . (assembler label)
.8b03	d0 0b		bne $8b10			bne 	_CRSyntaxError
.8b05	20 09 82	jsr $8209			jsr 	LabelHere
.8b08	80 c3		bra $8acd			bra 	_CRMainLoop
.8b0a					_CRGoRem:
.8b0a	c8		iny				iny
.8b0b	20 2c 8a	jsr $8a2c			jsr 	RemCommand
.8b0e	80 bd		bra $8acd			bra 	_CRMainLoop
.8b10					_CRSyntaxError:
.8b10	4c 5c a0	jmp $a05c			jmp 	SyntaxError
.8b13					_CRCallVector0:
.8b13	7c b2 8b	jmp ($8bb2,x)			jmp 	(VectorSet0,x)
.8b16					_CRBreak:
.8b16	a9 01		lda #$01		lda	#1
.8b18	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler
.8b1b					CRNoProgram:
.8b1b	4c 29 85	jmp $8529			jmp 	EndCommand
.8b1e					Shift1Command:
.8b1e	b1 30		lda ($30),y			lda 	(codePtr),y
.8b20	c8		iny				iny
.8b21	0a		asl a				asl 	a
.8b22	aa		tax				tax
.8b23	7c 50 8c	jmp ($8c50,x)			jmp 	(VectorSet1,x)
.8b26					Shift2Command:
.8b26	b1 30		lda ($30),y			lda 	(codePtr),y
.8b28	c8		iny				iny
.8b29	0a		asl a				asl 	a
.8b2a	aa		tax				tax
.8b2b	7c 6e 8c	jmp ($8c6e,x)			jmp 	(VectorSet2,x)
.8b2e					Unused1:
.8b2e					Unused2:
.8b2e					Unused3:
.8b2e					Unused4:
.8b2e	4c 5c a0	jmp $a05c			jmp 	SyntaxError
>8b31							.align 2

;******  Processing file: ./common/commands/../generated/vectors.dat

.8b32					VectorSetPunc:
>8b32	fc 90					.word	ShiftLeft                        ; $00 <<
>8b34	af 8e					.word	BinaryCompareLessEqual           ; $01 <=
>8b36	a5 8e					.word	BinaryCompareNotEqual            ; $02 <>
>8b38	5c a0					.word	SyntaxError                      ; $03 !!3
>8b3a	5c a0					.word	SyntaxError                      ; $04 ><
>8b3c	b9 8e					.word	BinaryCompareGreaterEqual        ; $05 >=
>8b3e	ff 90					.word	ShiftRight                       ; $06 >>
>8b40	5c a0					.word	SyntaxError                      ; $07 !!7
>8b42	5c a0					.word	SyntaxError                      ; $08 !!8
>8b44	5c a0					.word	SyntaxError                      ; $09 !!9
>8b46	5c a0					.word	SyntaxError                      ; $0a !!10
>8b48	5c a0					.word	SyntaxError                      ; $0b !!11
>8b4a	5c a0					.word	SyntaxError                      ; $0c !!12
>8b4c	5c a0					.word	SyntaxError                      ; $0d !!13
>8b4e	5c a0					.word	SyntaxError                      ; $0e !!14
>8b50	5c a0					.word	SyntaxError                      ; $0f !!15
>8b52	5c a0					.word	SyntaxError                      ; $10 @
>8b54	5c a0					.word	SyntaxError                      ; $11 !!17
>8b56	5c a0					.word	SyntaxError                      ; $12 !!18
>8b58	5c a0					.word	SyntaxError                      ; $13 [
>8b5a	80 8f					.word	IntegerDivide                    ; $14 \
>8b5c	5c a0					.word	SyntaxError                      ; $15 ]
>8b5e	8d 92					.word	EorInteger                       ; $16 ^
>8b60	5c a0					.word	SyntaxError                      ; $17 _
>8b62	5c a0					.word	SyntaxError                      ; $18 `
>8b64	5c a0					.word	SyntaxError                      ; $19 !!25
>8b66	5c a0					.word	SyntaxError                      ; $1a !!26
>8b68	5c a0					.word	SyntaxError                      ; $1b {
>8b6a	47 92					.word	OraInteger                       ; $1c |
>8b6c	5c a0					.word	SyntaxError                      ; $1d }
>8b6e	5c a0					.word	SyntaxError                      ; $1e ~
>8b70	5c a0					.word	SyntaxError                      ; $1f [7m<7F>[m
>8b72	5c a0					.word	SyntaxError                      ; $20
>8b74	d3 92					.word	WordIndirect                     ; $21 !
>8b76	5c a0					.word	SyntaxError                      ; $22 "
>8b78	5c a0					.word	SyntaxError                      ; $23 #
>8b7a	5c a0					.word	SyntaxError                      ; $24 $
>8b7c	cd 8f					.word	IntegerModulus                   ; $25 %
>8b7e	01 92					.word	AndInteger                       ; $26 &
>8b80	5c a0					.word	SyntaxError                      ; $27 '
>8b82	5c a0					.word	SyntaxError                      ; $28 (
>8b84	5c a0					.word	SyntaxError                      ; $29 )
>8b86	42 90					.word	MulInteger                       ; $2a *
>8b88	93 91					.word	AddInteger                       ; $2b +
>8b8a	5c a0					.word	SyntaxError                      ; $2c ,
>8b8c	d6 91					.word	SubInteger                       ; $2d -
>8b8e	5c a0					.word	SyntaxError                      ; $2e .
>8b90	be 94					.word	FDivideCommand                   ; $2f /
>8b92	5c a0					.word	SyntaxError                      ; $30 0
>8b94	5c a0					.word	SyntaxError                      ; $31 1
>8b96	5c a0					.word	SyntaxError                      ; $32 2
>8b98	5c a0					.word	SyntaxError                      ; $33 3
>8b9a	5c a0					.word	SyntaxError                      ; $34 4
>8b9c	5c a0					.word	SyntaxError                      ; $35 5
>8b9e	5c a0					.word	SyntaxError                      ; $36 6
>8ba0	5c a0					.word	SyntaxError                      ; $37 7
>8ba2	5c a0					.word	SyntaxError                      ; $38 8
>8ba4	5c a0					.word	SyntaxError                      ; $39 9
>8ba6	5c a0					.word	SyntaxError                      ; $3a :
>8ba8	5c a0					.word	SyntaxError                      ; $3b ;
>8baa	91 8e					.word	BinaryCompareLess                ; $3c <
>8bac	87 8e					.word	BinaryCompareEqual               ; $3d =
>8bae	9b 8e					.word	BinaryCompareGreater             ; $3e >
>8bb0	fa 92					.word	ByteIndirect                     ; $3f ?
.8bb2					VectorSet0:
>8bb2	8d 8a					.word	EOLCommand                       ; $80 !0:EOF
>8bb4	1e 8b					.word	Shift1Command                    ; $81 !1:SH1
>8bb6	26 8b					.word	Shift2Command                    ; $82 !2:SH2
>8bb8	2e 9a					.word	AbsUnary                         ; $83 ABS(
>8bba	3e 9a					.word	AllocUnary                       ; $84 ALLOC(
>8bbc	ae 9a					.word	AscUnary                         ; $85 ASC(
>8bbe	79 9c					.word	ChrUnary                         ; $86 CHR$(
>8bc0	c4 a4					.word	UnaryEvent                       ; $87 EVENT(
>8bc2	83 8e					.word	UnaryFalse                       ; $88 FALSE
>8bc4	bb 9a					.word	FracUnary                        ; $89 FRAC(
>8bc6	5a a4					.word	UnaryHit                         ; $8a HIT(
>8bc8	d1 9a					.word	IntUnary                         ; $8b INT(
>8bca	38 9c					.word	IsValUnary                       ; $8c ISVAL(
>8bcc	54 a5					.word	UnaryJoyB                        ; $8d JOYB(
>8bce	2d a5					.word	UnaryJoyX                        ; $8e JOYX(
>8bd0	30 a5					.word	UnaryJoyY                        ; $8f JOYY(
>8bd2	53 9d					.word	Unary_Left                       ; $90 LEFT$(
>8bd4	e3 9a					.word	LenUnary                         ; $91 LEN(
>8bd6	01 9b					.word	Unary_Max                        ; $92 MAX(
>8bd8	7d 9d					.word	Unary_Mid                        ; $93 MID$(
>8bda	fd 9a					.word	Unary_Min                        ; $94 MIN(
>8bdc	58 9b					.word	Unary_Not                        ; $95 NOT(
>8bde	a8 a6					.word	UnaryPlaying                     ; $96 PLAYING(
>8be0	6e 9b					.word	Unary_Random                     ; $97 RANDOM(
>8be2	63 9d					.word	Unary_Right                      ; $98 RIGHT$(
>8be4	8d 9b					.word	Unary_Rnd                        ; $99 RND(
>8be6	0e 9c					.word	SgnUnary                         ; $9a SGN(
>8be8	8b 9c					.word	SpcUnary                         ; $9b SPC(
>8bea	a6 9c					.word	Unary_Str                        ; $9c STR$(
>8bec	7a a5					.word	UnaryTimer                       ; $9d TIMER(
>8bee	77 8e					.word	UnaryTrue                        ; $9e TRUE
>8bf0	2e 9c					.word	ValUnary                         ; $9f VAL(
>8bf2	2c 85					.word	ForCommand                       ; $a0 FOR
>8bf4	79 86					.word	IfCommand                        ; $a1 IF
>8bf6	2e 8b					.word	Unused1                          ; $a2 PROC
>8bf8	39 8a					.word	Command_REPEAT                   ; $a3 REPEAT
>8bfa	c3 8d					.word	Command_WHILE                    ; $a4 WHILE
>8bfc	a2 86					.word	EndIf                            ; $a5 ENDIF
>8bfe	c5 89					.word	Command_ENDPROC                  ; $a6 ENDPROC
>8c00	e6 85					.word	NextCommand                      ; $a7 NEXT
>8c02	2e 8b					.word	Unused4                          ; $a8 THEN
>8c04	42 8a					.word	Command_UNTIL                    ; $a9 UNTIL
>8c06	e4 8d					.word	Command_WEND                     ; $aa WEND
>8c08	5c a0					.word	SyntaxError                      ; $ab BY
>8c0a	ca 83					.word	CallCommand                      ; $ac CALL
>8c0c	fc a1					.word	CircleCommand                    ; $ad CIRCLE
>8c0e	04 84					.word	ClearCommand                     ; $ae CLEAR
>8c10	5c 84					.word	ClearScreen                      ; $af CLS
>8c12	5c a0					.word	SyntaxError                      ; $b0 COLOR
>8c14	5c a0					.word	SyntaxError                      ; $b1 COLOUR
>8c16	64 84					.word	Command_Data                     ; $b2 DATA
>8c18	6c 84					.word	DimCommand                       ; $b3 DIM
>8c1a	2e 8b					.word	Unused3                          ; $b4 DOWNTO
>8c1c	9b 86					.word	ElseCode                         ; $b5 ELSE
>8c1e	5c a0					.word	SyntaxError                      ; $b6 FROM
>8c20	28 a4					.word	GfxCommand                       ; $b7 GFX
>8c22	3f 86					.word	Command_GOSUB                    ; $b8 GOSUB
>8c24	5d 86					.word	GotoCommand                      ; $b9 GOTO
>8c26	5c a0					.word	SyntaxError                      ; $ba HERE
>8c28	26 a2					.word	ImageCommand                     ; $bb IMAGE
>8c2a	a3 86					.word	Command_Input                    ; $bc INPUT
>8c2c	98 87					.word	LetCommand                       ; $bd LET
>8c2e	7b a2					.word	LineCommand                      ; $be LINE
>8c30	8e 88					.word	Command_LOCAL                    ; $bf LOCAL
>8c32	5c a0					.word	SyntaxError                      ; $c0 OFF
>8c34	5c a0					.word	SyntaxError                      ; $c1 ON
>8c36	5c a0					.word	SyntaxError                      ; $c2 OUTLINE
>8c38	80 a4					.word	PaletteCommand                   ; $c3 PALETTE
>8c3a	74 a2					.word	PlotCommand                      ; $c4 PLOT
>8c3c	aa 86					.word	Command_Print                    ; $c5 PRINT
>8c3e	d3 89					.word	Command_Read                     ; $c6 READ
>8c40	f8 a1					.word	RectangleCommand                 ; $c7 RECT
>8c42	2c 8a					.word	RemCommand                       ; $c8 REM
>8c44	4f 86					.word	Command_RETURN                   ; $c9 RETURN
>8c46	5c a0					.word	SyntaxError                      ; $ca SOLID
>8c48	c4 a6					.word	SoundCommand                     ; $cb SOUND
>8c4a	07 a2					.word	SpriteCommand                    ; $cc SPRITE
>8c4c	43 a2					.word	TextCommand                      ; $cd TEXT
>8c4e	2e 8b					.word	Unused2                          ; $ce TO
.8c50					VectorSet1:
>8c50	5c a0					.word	SyntaxError                      ; $80 !0:EOF
>8c52	5c a0					.word	SyntaxError                      ; $81 !1:SH1
>8c54	5c a0					.word	SyntaxError                      ; $82 !2:SH2
>8c56	9b 83					.word	AssembleCommand                  ; $83 ASSEMBLE
>8c58	ba 83					.word	AssertCommand                    ; $84 ASSERT
>8c5a	c8 a3					.word	BitmapCtrl                       ; $85 BITMAP
>8c5c	29 85					.word	EndCommand                       ; $86 END
>8c5e	71 a5					.word	GoCommand                        ; $87 GO
>8c60	ed 87					.word	Command_List                     ; $88 LIST
>8c62	68 a5					.word	LoadCommand                      ; $89 LOAD
>8c64	55 89					.word	NewCommand                       ; $8a NEW
>8c66	5b 8a					.word	Command_Restore                  ; $8b RESTORE
>8c68	9a 8a					.word	CommandRUN                       ; $8c RUN
>8c6a	0d a4					.word	SpritesCtrl                      ; $8d SPRITES
>8c6c	f6 8c					.word	StopCommand                      ; $8e STOP
.8c6e					VectorSet2:
>8c6e	5c a0					.word	SyntaxError                      ; $80 !0:EOF
>8c70	5c a0					.word	SyntaxError                      ; $81 !1:SH1
>8c72	5c a0					.word	SyntaxError                      ; $82 !2:SH2
>8c74	1b 9f					.word	Assemble_adc                     ; $83 ADC
>8c76	13 9f					.word	Assemble_and                     ; $84 AND
>8c78	2f 9f					.word	Assemble_asl                     ; $85 ASL
>8c7a	99 9f					.word	Assemble_bcc                     ; $86 BCC
>8c7c	9d 9f					.word	Assemble_bcs                     ; $87 BCS
>8c7e	a5 9f					.word	Assemble_beq                     ; $88 BEQ
>8c80	5c 9f					.word	Assemble_bit                     ; $89 BIT
>8c82	8d 9f					.word	Assemble_bmi                     ; $8a BMI
>8c84	a1 9f					.word	Assemble_bne                     ; $8b BNE
>8c86	89 9f					.word	Assemble_bpl                     ; $8c BPL
>8c88	a9 9f					.word	Assemble_bra                     ; $8d BRA
>8c8a	ad 9f					.word	Assemble_brk                     ; $8e BRK
>8c8c	91 9f					.word	Assemble_bvc                     ; $8f BVC
>8c8e	95 9f					.word	Assemble_bvs                     ; $90 BVS
>8c90	b5 9f					.word	Assemble_clc                     ; $91 CLC
>8c92	09 a0					.word	Assemble_cld                     ; $92 CLD
>8c94	c9 9f					.word	Assemble_cli                     ; $93 CLI
>8c96	f9 9f					.word	Assemble_clv                     ; $94 CLV
>8c98	27 9f					.word	Assemble_cmp                     ; $95 CMP
>8c9a	70 9f					.word	Assemble_cpx                     ; $96 CPX
>8c9c	6b 9f					.word	Assemble_cpy                     ; $97 CPY
>8c9e	4d 9f					.word	Assemble_dec                     ; $98 DEC
>8ca0	05 a0					.word	Assemble_dex                     ; $99 DEX
>8ca2	e1 9f					.word	Assemble_dey                     ; $9a DEY
>8ca4	17 9f					.word	Assemble_eor                     ; $9b EOR
>8ca6	52 9f					.word	Assemble_inc                     ; $9c INC
>8ca8	15 a0					.word	Assemble_inx                     ; $9d INX
>8caa	01 a0					.word	Assemble_iny                     ; $9e INY
>8cac	84 9f					.word	Assemble_jmp                     ; $9f JMP
>8cae	7f 9f					.word	Assemble_jsr                     ; $a0 JSR
>8cb0	23 9f					.word	Assemble_lda                     ; $a1 LDA
>8cb2	48 9f					.word	Assemble_ldx                     ; $a2 LDX
>8cb4	66 9f					.word	Assemble_ldy                     ; $a3 LDY
>8cb6	39 9f					.word	Assemble_lsr                     ; $a4 LSR
>8cb8	19 a0					.word	Assemble_nop                     ; $a5 NOP
>8cba	0f 9f					.word	Assemble_ora                     ; $a6 ORA
>8cbc	c5 9f					.word	Assemble_pha                     ; $a7 PHA
>8cbe	b1 9f					.word	Assemble_php                     ; $a8 PHP
>8cc0	0d a0					.word	Assemble_phx                     ; $a9 PHX
>8cc2	cd 9f					.word	Assemble_phy                     ; $aa PHY
>8cc4	d5 9f					.word	Assemble_pla                     ; $ab PLA
>8cc6	b9 9f					.word	Assemble_plp                     ; $ac PLP
>8cc8	21 a0					.word	Assemble_plx                     ; $ad PLX
>8cca	dd 9f					.word	Assemble_ply                     ; $ae PLY
>8ccc	34 9f					.word	Assemble_rol                     ; $af ROL
>8cce	3e 9f					.word	Assemble_ror                     ; $b0 ROR
>8cd0	c1 9f					.word	Assemble_rti                     ; $b1 RTI
>8cd2	d1 9f					.word	Assemble_rts                     ; $b2 RTS
>8cd4	2b 9f					.word	Assemble_sbc                     ; $b3 SBC
>8cd6	bd 9f					.word	Assemble_sec                     ; $b4 SEC
>8cd8	1d a0					.word	Assemble_sed                     ; $b5 SED
>8cda	d9 9f					.word	Assemble_sei                     ; $b6 SEI
>8cdc	1f 9f					.word	Assemble_sta                     ; $b7 STA
>8cde	11 a0					.word	Assemble_stp                     ; $b8 STP
>8ce0	43 9f					.word	Assemble_stx                     ; $b9 STX
>8ce2	61 9f					.word	Assemble_sty                     ; $ba STY
>8ce4	57 9f					.word	Assemble_stz                     ; $bb STZ
>8ce6	f5 9f					.word	Assemble_tax                     ; $bc TAX
>8ce8	f1 9f					.word	Assemble_tay                     ; $bd TAY
>8cea	7a 9f					.word	Assemble_trb                     ; $be TRB
>8cec	75 9f					.word	Assemble_tsb                     ; $bf TSB
>8cee	fd 9f					.word	Assemble_tsx                     ; $c0 TSX
>8cf0	e5 9f					.word	Assemble_txa                     ; $c1 TXA
>8cf2	ed 9f					.word	Assemble_txs                     ; $c2 TXS
>8cf4	e9 9f					.word	Assemble_tya                     ; $c3 TYA

;******  Return to file: ./common/commands/run.asm


;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/stop.asm

.8cf6					StopCommand:
.8cf6	a9 08		lda #$08		lda	#8
.8cf8	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/procscan.asm

.8cfb					ProcedureScan:
.8cfb	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8cfd	85 30		sta $30				sta 	codePtr
.8cff	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8d01	85 31		sta $31				sta 	codePtr+1
.8d03					_PSLoop:
.8d03	b2 30		lda ($30)			lda 	(codePtr)
.8d05	f0 42		beq $8d49			beq 	_PSExit
.8d07	a0 03		ldy #$03			ldy 	#3 							; is it PROC ?
.8d09	b1 30		lda ($30),y			lda 	(codePtr),y
.8d0b	c9 a2		cmp #$a2			cmp 	#KWD_PROC
.8d0d	d0 2d		bne $8d3c			bne 	_PSNext
.8d0f	c8		iny				iny 								; get the address of the record to zTemp0 and
.8d10	b1 30		lda ($30),y			lda 	(codePtr),y
.8d12	29 c0		and #$c0			and 	#$C0
.8d14	c9 40		cmp #$40			cmp 	#$40
.8d16	d0 32		bne $8d4a			bne 	_PSSyntax
.8d18	b1 30		lda ($30),y			lda 	(codePtr),y
.8d1a	18		clc				clc
.8d1b	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8d1d	85 37		sta $37				sta 	zTemp0+1
.8d1f	c8		iny				iny 								; LSB
.8d20	b1 30		lda ($30),y			lda 	(codePtr),y
.8d22	85 36		sta $36				sta 	zTemp0
.8d24	c8		iny				iny 								; character after variable call.
.8d25	98		tya				tya 								; save Y offset at +7
.8d26	a0 07		ldy #$07			ldy 	#7
.8d28	91 36		sta ($36),y			sta 	(zTemp0),y
.8d2a	a9 18		lda #$18			lda 	#NSTProcedure 				; mark it as procedure
.8d2c	a0 02		ldy #$02			ldy 	#2
.8d2e	91 36		sta ($36),y			sta 	(zTemp0),y
.8d30	a2 00		ldx #$00			ldx 	#0 							; copy code-Ptr in
.8d32					_PSCopy:
.8d32	b5 30		lda $30,x			lda 	safePtr,x
.8d34	c8		iny				iny
.8d35	91 36		sta ($36),y			sta 	(zTemp0),y
.8d37	e8		inx				inx
.8d38	e0 04		cpx #$04			cpx 	#4
.8d3a	d0 f6		bne $8d32			bne 	_PSCopy
.8d3c					_PSNext:
.8d3c	18		clc				clc
.8d3d	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8d3f	65 30		adc $30				adc 	codePtr
.8d41	85 30		sta $30				sta 	codePtr
.8d43	90 02		bcc $8d47			bcc 	_CREExit
.8d45	e6 31		inc $31				inc 	codePtr+1 					; carry
.8d47					_CREExit:
.8d47	80 ba		bra $8d03			bra 	_PSLoop
.8d49					_PSExit:
.8d49	60		rts				rts
.8d4a					_PSSyntax:
.8d4a	4c 5c a0	jmp $a05c			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/scanforward.asm

.8d4d					ScanForward:
.8d4d	64 38		stz $38				stz 	zTemp1 						; this is the structure count - goes up with WHILE/FOR
.8d4f	86 37		stx $37				stx 	zTemp0+1
.8d51	85 36		sta $36				sta 	zTemp0 						; save XA as the two possible matches.
.8d53					_ScanLoop:
.8d53	b1 30		lda ($30),y			lda 	(codePtr),y
.8d55	c8		iny				iny
.8d56	a6 38		ldx $38				ldx 	zTemp1 						; if the count is > 0 cannot match as in substructure
.8d58	d0 0e		bne $8d68			bne 	_ScanGoNext
.8d5a	c5 36		cmp $36				cmp 	zTemp0 						; see if either matches
.8d5c	f0 04		beq $8d62			beq 	_ScanMatch
.8d5e	c5 37		cmp $37				cmp 	zTemp0+1
.8d60	d0 06		bne $8d68			bne 	_ScanGoNext
.8d62					_ScanMatch:
.8d62	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if asked for EOL, backtrack.
.8d64	d0 01		bne $8d67			bne 	_ScanNotEndEOL
.8d66	88		dey				dey
.8d67					_ScanNotEndEOL:
.8d67	60		rts				rts
.8d68					_ScanGoNext:
.8d68	20 6d 8d	jsr $8d6d			jsr  	ScanForwardOne
.8d6b	80 e6		bra $8d53			bra 	_ScanLoop
.8d6d					ScanForwardOne:
.8d6d	c9 40		cmp #$40			cmp 	#$40 						; if 00-3F, punctuation characters, loop back
.8d6f	90 3e		bcc $8daf			bcc 	_SFWExit
.8d71	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if 40-82, skip one extra.
.8d73	90 18		bcc $8d8d			bcc 	_ScanSkipOne
.8d75	c9 fc		cmp #$fc			cmp 	#$FC 						; FC-FF are data skips
.8d77	b0 2f		bcs $8da8			bcs 	_ScanSkipData
.8d79	c9 a0		cmp #$a0			cmp 	#KWC_FIRST_STRUCTURE 		; structure keyword ?
.8d7b	90 32		bcc $8daf			bcc 	_SFWExit 					; if not, ordinary keywords.
.8d7d	c9 ab		cmp #$ab			cmp 	#KWC_LAST_STRUCTURE+1
.8d7f	b0 2e		bcs $8daf			bcs 	_SFWExit
.8d81	c6 38		dec $38				dec 	zTemp1 						; decrement the sructure count
.8d83	c9 a5		cmp #$a5			cmp 	#KWC_FIRST_STRUCTURE_DEC 	; back if it is a dec structure (e.g. WEND/NEXT)
.8d85	b0 28		bcs $8daf			bcs 	_SFWExit
.8d87	e6 38		inc $38				inc 	zTemp1 						; so it's an increment structure
.8d89	e6 38		inc $38				inc 	zTemp1 						; twice to undo the dec
.8d8b	80 22		bra $8daf			bra 	_SFWExit
.8d8d					_ScanSkipOne:
.8d8d	c8		iny				iny 								; consume the extra one.
.8d8e	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if not EOL loop back
.8d90	d0 1d		bne $8daf			bne 	_SFWExit
.8d92	18		clc				clc
.8d93	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8d95	65 30		adc $30				adc 	codePtr
.8d97	85 30		sta $30				sta 	codePtr
.8d99	90 02		bcc $8d9d			bcc 	_CREExit
.8d9b	e6 31		inc $31				inc 	codePtr+1 					; carry
.8d9d					_CREExit:
.8d9d	a0 03		ldy #$03			ldy 	#3 							; scan start position.
.8d9f	b2 30		lda ($30)			lda 	(codePtr)
.8da1	d0 0c		bne $8daf			bne 	_SFWExit 					; if not zero, more to scan
.8da3	a9 13		lda #$13		lda	#19
.8da5	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler
.8da8					_ScanSkipData:
.8da8	88		dey				dey 								; point at data token
.8da9	c8		iny				iny 								; point to offset
.8daa	98		tya				tya 								; A = offset position
.8dab	38		sec				sec 								; add size +1 hence SEC
.8dac	71 30		adc ($30),y			adc 	(codePtr),y
.8dae	a8		tay				tay 								; make current position.
.8daf					_SFWExit:
.8daf	60		rts				rts
.8db0					ScanGetCurrentLineStep:
.8db0	64 38		stz $38				stz 	zTemp1
.8db2	a0 03		ldy #$03			ldy 	#3
.8db4					_SGCLSLoop:
.8db4	b1 30		lda ($30),y			lda 	(codePtr),y
.8db6	c8		iny				iny
.8db7	c9 80		cmp #$80			cmp 	#KWC_EOL	 				; if EOL exit
.8db9	f0 05		beq $8dc0			beq 	_SGCLSExit
.8dbb	20 6d 8d	jsr $8d6d			jsr 	ScanForwardOne
.8dbe	80 f4		bra $8db4			bra 	_SGCLSLoop
.8dc0					_SGCLSExit:
.8dc0	a5 38		lda $38				lda 	zTemp1
.8dc2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/while.asm

.8dc3					Command_WHILE:
.8dc3	5a		phy				phy 								; save position of the test
.8dc4	a2 00		ldx #$00			ldx 	#0
.8dc6	20 fb 9d	jsr $9dfb			jsr 	EvaluateNumber 				; work out the number
.8dc9	20 02 9f	jsr $9f02			jsr 	NSMIsZero 					; check if zero
.8dcc	f0 0e		beq $8ddc			beq 	_WHExitLoop 				; if so exit the loop
.8dce	98		tya				tya 								; position *after* test.
.8dcf	7a		ply				ply 								; restore position before test, at WHILE
.8dd0	88		dey				dey
.8dd1	48		pha				pha 								; push after test on the stack
.8dd2	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; allocate 6 bytes on the return stack.
.8dd4	20 51 a7	jsr $a751			jsr 	StackOpen
.8dd7	20 95 a7	jsr $a795			jsr 	STKSaveCodePosition 		; save loop position - where the test value is.
.8dda	7a		ply				ply 								; restore the position *after* the test
.8ddb	60		rts				rts
.8ddc					_WHExitLoop:
.8ddc	68		pla				pla 								; throw post loop position
.8ddd	a9 aa		lda #$aa			lda 	#KWD_WEND 					; scan forward past WEND
.8ddf	aa		tax				tax
.8de0	20 4d 8d	jsr $8d4d			jsr 	ScanForward
.8de3	60		rts				rts
.8de4					Command_WEND:
.8de4	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; check WHILE is TOS
.8de6	a2 10		ldx #$10			ldx 	#ERRID_WHILE 				; this error
.8de8	20 7d a7	jsr $a77d			jsr 	StackCheckFrame
.8deb	20 a6 a7	jsr $a7a6			jsr 	STKLoadCodePosition 		; loop back
.8dee	20 6f a7	jsr $a76f			jsr 	StackClose		 			; erase the frame
.8df1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/charcheck.asm

.8df2					CheckRightBracket:
.8df2	b1 30		lda ($30),y			lda 	(codePtr),y
.8df4	c8		iny				iny
.8df5	c9 29		cmp #$29			cmp 	#KWD_RPAREN 						; exit if matches
.8df7	d0 0f		bne $8e08			bne 	CNAFail
.8df9	60		rts				rts
.8dfa					CheckComma:
.8dfa	b1 30		lda ($30),y			lda 	(codePtr),y
.8dfc	c8		iny				iny
.8dfd	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 						; exit if matches
.8dff	d0 07		bne $8e08			bne 	CNAFail
.8e01	60		rts				rts
.8e02					CheckNextA:
.8e02	d1 30		cmp ($30),y			cmp 	(codePtr),y
.8e04	d0 02		bne $8e08			bne 	CNAFail
.8e06	c8		iny				iny 								; skip character
.8e07	60		rts				rts 								; and exit
.8e08					CNAFail:
.8e08	4c 5c a0	jmp $a05c			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/errors.asm

.8e0b					ErrorHandler:
.8e0b	a8		tay				tay 								; find the error text
.8e0c	f0 49		beq $8e57			beq 	_EHEnd
.8e0e	a2 00		ldx #$00			ldx 	#0
.8e10	a9 75		lda #$75			lda 	#((ErrorText) & $FF)
.8e12	85 36		sta $36				sta 	0+zTemp0
.8e14	a9 a0		lda #$a0			lda 	#((ErrorText) >> 8)
.8e16	85 37		sta $37				sta 	1+zTemp0
.8e18					_EHFind:
.8e18	88		dey				dey 								; found the error text ?
.8e19	f0 0e		beq $8e29			beq 	_EHFound
.8e1b					_EHFindZero:
.8e1b	b2 36		lda ($36)			lda 	(zTemp0) 					; find the next error
.8e1d	e6 36		inc $36				inc 	zTemp0
.8e1f	d0 02		bne $8e23			bne 	_EHFNoCarry
.8e21	e6 37		inc $37				inc 	zTemp0+1
.8e23					_EHFNoCarry:
.8e23	c9 00		cmp #$00			cmp 	#0
.8e25	d0 f4		bne $8e1b			bne 	_EHFindZero
.8e27	80 ef		bra $8e18			bra 	_EHFind
.8e29					_EHFound:
.8e29	a5 36		lda $36				lda 	zTemp0 						; print message
.8e2b	a6 37		ldx $37				ldx 	zTemp0+1
.8e2d	20 64 8e	jsr $8e64			jsr 	PrintStringXA
.8e30	a0 01		ldy #$01			ldy 	#1 							; if line number zero don't print i
.8e32	b1 30		lda ($30),y			lda 	(codePtr),y
.8e34	d0 05		bne $8e3b			bne 	_EHAtMsg
.8e36	c8		iny				iny
.8e37	b1 30		lda ($30),y			lda 	(codePtr),y
.8e39	f0 17		beq $8e52			beq 	_EHCREnd
.8e3b					_EHAtMsg:
.8e3b	a2 8e		ldx #$8e			ldx 	#_AtMsg >> 8 				; print " at "
.8e3d	a9 5a		lda #$5a			lda 	#_AtMsg & $FF
.8e3f	20 64 8e	jsr $8e64			jsr 	PrintStringXA
.8e42	a0 01		ldy #$01			ldy 	#1 							; line number into XA
.8e44	b1 30		lda ($30),y			lda 	(codePtr),y
.8e46	48		pha				pha
.8e47	c8		iny				iny
.8e48	b1 30		lda ($30),y			lda 	(codePtr),y
.8e4a	aa		tax				tax
.8e4b	68		pla				pla
.8e4c	20 21 93	jsr $9321			jsr 	LCLConvertInt16 				; convert XA to string
.8e4f	20 64 8e	jsr $8e64			jsr 	PrintStringXA 				; and print it.
.8e52					_EHCREnd:
.8e52	a9 0d		lda #$0d			lda 	#13 						; new line
.8e54	20 91 a8	jsr $a891			jsr 	EXTPrintCharacter
.8e57					_EHEnd:
.8e57	4c 6b 83	jmp $836b			jmp 	WarmStart
>8e5a	20 61 74 20 6c 69 6e 65		_AtMsg:	.text 	" at line ",0
>8e62	20 00
.8e64					PrintStringXA:
.8e64	5a		phy				phy
.8e65	86 37		stx $37				stx 	zTemp0+1
.8e67	85 36		sta $36				sta 	zTemp0
.8e69	a0 00		ldy #$00			ldy 	#0
.8e6b					_PSXALoop:
.8e6b	b1 36		lda ($36),y			lda 	(zTemp0),y
.8e6d	f0 06		beq $8e75			beq 	_PSXAExit
.8e6f	20 91 a8	jsr $a891			jsr 	EXTPrintCharacter
.8e72	c8		iny				iny
.8e73	80 f6		bra $8e6b			bra 	_PSXALoop
.8e75					_PSXAExit:
.8e75	7a		ply				ply
.8e76	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/compare.asm

.8e77					UnaryTrue:
.8e77	fa		plx				plx
.8e78					ReturnTrue:
.8e78	a9 01		lda #$01			lda 	#1  						; set to 1
.8e7a	20 d4 9e	jsr $9ed4			jsr 	NSMSetByte
.8e7d	a9 80		lda #$80			lda 	#$80 						; set sign flag, so it is -1
.8e7f	9d 00 04	sta $0400,x			sta 	NSStatus,x
.8e82	60		rts				rts
.8e83					UnaryFalse:
.8e83	fa		plx				plx
.8e84					ReturnFalse:
.8e84	4c d2 9e	jmp $9ed2			jmp 	NSMSetZero 					; set it all to zero
.8e87					BinaryCompareEqual:
.8e87	fa		plx				plx
.8e88	20 c3 8e	jsr $8ec3			jsr 	CompareBaseCode
.8e8b	c9 00		cmp #$00			cmp 	#0
.8e8d	f0 e9		beq $8e78			beq 	ReturnTrue
.8e8f	80 f3		bra $8e84			bra 	ReturnFalse
.8e91					BinaryCompareLess:
.8e91	fa		plx				plx
.8e92	20 c3 8e	jsr $8ec3			jsr 	CompareBaseCode
.8e95	c9 ff		cmp #$ff			cmp 	#$FF
.8e97	f0 df		beq $8e78			beq 	ReturnTrue
.8e99	80 e9		bra $8e84			bra 	ReturnFalse
.8e9b					BinaryCompareGreater:
.8e9b	fa		plx				plx
.8e9c	20 c3 8e	jsr $8ec3			jsr 	CompareBaseCode
.8e9f	c9 01		cmp #$01			cmp 	#1
.8ea1	f0 d5		beq $8e78			beq 	ReturnTrue
.8ea3	80 df		bra $8e84			bra 	ReturnFalse
.8ea5					BinaryCompareNotEqual:
.8ea5	fa		plx				plx
.8ea6	20 c3 8e	jsr $8ec3			jsr 	CompareBaseCode
.8ea9	c9 00		cmp #$00			cmp 	#0
.8eab	d0 cb		bne $8e78			bne 	ReturnTrue
.8ead	80 d5		bra $8e84			bra 	ReturnFalse
.8eaf					BinaryCompareLessEqual:
.8eaf	fa		plx				plx
.8eb0	20 c3 8e	jsr $8ec3			jsr 	CompareBaseCode
.8eb3	c9 01		cmp #$01			cmp 	#1
.8eb5	d0 c1		bne $8e78			bne 	ReturnTrue
.8eb7	80 cb		bra $8e84			bra 	ReturnFalse
.8eb9					BinaryCompareGreaterEqual:
.8eb9	fa		plx				plx
.8eba	20 c3 8e	jsr $8ec3			jsr 	CompareBaseCode
.8ebd	c9 ff		cmp #$ff			cmp 	#$FF
.8ebf	d0 b7		bne $8e78			bne 	ReturnTrue
.8ec1	80 c1		bra $8e84			bra 	ReturnFalse
.8ec3					CompareBaseCode:
.8ec3	20 d7 96	jsr $96d7			jsr 	DereferenceTopTwo 			; make both values if references.
.8ec6	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if either is a string.
.8ec9	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8ecc	29 10		and #$10			and 	#NSTString
.8ece	d0 40		bne $8f10			bne 	_CBCString 					; if so do string code, which will check if both.
.8ed0	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check both are integers
.8ed3	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8ed6	d0 3b		bne $8f13			bne 	_CBCFloat
.8ed8	bd 00 04	lda $0400,x			lda 	NSStatus,x
.8edb	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8ede	29 08		and #$08			and 	#NSTFloat
.8ee0	d0 31		bne $8f13			bne 	_CBCFloat
.8ee2	20 16 8f	jsr $8f16			jsr 	CompareFixMinusZero 		; fix up -0 just in cases.
.8ee5	e8		inx				inx
.8ee6	20 16 8f	jsr $8f16			jsr 	CompareFixMinusZero
.8ee9	ca		dex				dex
.8eea	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; are the signs different ?
.8eed	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.8ef0	10 0b		bpl $8efd			bpl 	_CDCSameSign
.8ef2	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; if first one is -ve
.8ef5	30 16		bmi $8f0d			bmi 	_CBCLess 					; return $FF
.8ef7					_CBCGreater:
.8ef7	a9 01		lda #$01			lda 	#1
.8ef9	60		rts				rts
.8efa					_CBCEqual:
.8efa	a9 00		lda #$00			lda 	#0
.8efc	60		rts				rts
.8efd					_CDCSameSign:
.8efd	20 6d 91	jsr $916d			jsr 	SubTopTwoStack 				; unsigned subtract
.8f00	20 02 9f	jsr $9f02			jsr 	NSMIsZero 					; or the mantissa together
.8f03	f0 f5		beq $8efa			beq 	_CBCEqual 					; -0 == 0
.8f05	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; sign of the result. if +ve return $01 else return $FF
.8f08	5d 01 04	eor $0401,x			eor 	NSStatus+1,x 				; however if both were -ve this is inverted
.8f0b	10 ea		bpl $8ef7			bpl 	_CBCGreater
.8f0d					_CBCLess:
.8f0d	a9 ff		lda #$ff			lda 	#$FF
.8f0f	60		rts				rts
.8f10					_CBCString:
.8f10	4c c3 90	jmp $90c3			jmp 	CompareStrings
.8f13					_CBCFloat:
.8f13	4c a4 94	jmp $94a4			jmp 	CompareFloat
.8f16					CompareFixMinusZero:
.8f16	20 02 9f	jsr $9f02			jsr 	NSMIsZero
.8f19	d0 03		bne $8f1e			bne 	_CFXMZNotZero
.8f1b	9e 00 04	stz $0400,x			stz 	NSStatus,x
.8f1e					_CFXMZNotZero:
.8f1e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/concat.asm

.8f1f					StringConcat:
.8f1f	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check both strings
.8f22	3d 01 04	and $0401,x			and 	NSStatus+1,x
.8f25	29 18		and #$18			and 	#NSBTypeMask
.8f27	c9 10		cmp #$10			cmp 	#NSTString
.8f29	d0 52		bne $8f7d			bne		_SCType
.8f2b	64 38		stz $38				stz 	zTemp1 						; counting total length
.8f2d	e8		inx				inx
.8f2e	20 4c 8f	jsr $8f4c			jsr 	_SCSetupZ0 					; setup for second
.8f31	20 57 8f	jsr $8f57			jsr 	_SCLengthZ0 				; length for second
.8f34	ca		dex				dex
.8f35	20 4c 8f	jsr $8f4c			jsr 	_SCSetupZ0 					; setup for first
.8f38	20 57 8f	jsr $8f57			jsr 	_SCLengthZ0 				; length for first
.8f3b	a5 38		lda $38				lda 	zTemp1 						; allocate memory using total.
.8f3d	20 44 a8	jsr $a844			jsr 	StringTempAllocate
.8f40	20 6e 8f	jsr $8f6e			jsr 	_SCCopy 					; copy first out, using zTemp0 from above
.8f43	e8		inx				inx
.8f44	20 4c 8f	jsr $8f4c			jsr 	_SCSetupZ0 					; copy second out
.8f47	20 6e 8f	jsr $8f6e			jsr 	_SCCopy
.8f4a	ca		dex				dex
.8f4b	60		rts				rts
.8f4c					_SCSetupZ0:
.8f4c	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.8f4f	85 36		sta $36				sta 	zTemp0
.8f51	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.8f54	85 37		sta $37				sta 	zTemp0+1
.8f56	60		rts				rts
.8f57					_SCLengthZ0:
.8f57	5a		phy				phy
.8f58	a0 00		ldy #$00			ldy 	#0
.8f5a					_SCLenLoop:
.8f5a	b1 36		lda ($36),y			lda 	(zTemp0),y
.8f5c	f0 0e		beq $8f6c			beq 	_SCLExit
.8f5e	c8		iny				iny
.8f5f	e6 38		inc $38				inc 	zTemp1
.8f61	a5 38		lda $38				lda	 	zTemp1 						; check string too long.
.8f63	c9 fd		cmp #$fd			cmp 	#253
.8f65	d0 f3		bne $8f5a			bne		_SCLenLoop
.8f67	a9 09		lda #$09		lda	#9
.8f69	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler
.8f6c					_SCLExit:
.8f6c	7a		ply				ply
.8f6d	60		rts				rts
.8f6e					_SCCopy:
.8f6e	5a		phy				phy
.8f6f	a0 00		ldy #$00			ldy 	#0
.8f71					_SCCopyLoop:
.8f71	b1 36		lda ($36),y			lda 	(zTemp0),y
.8f73	f0 06		beq $8f7b			beq 	_SCCExit
.8f75	20 82 a8	jsr $a882			jsr 	StringTempWrite
.8f78	c8		iny				iny
.8f79	80 f6		bra $8f71			bra 	_SCCopyLoop
.8f7b					_SCCExit:
.8f7b	7a		ply				ply
.8f7c	60		rts				rts
.8f7d					_SCType:
.8f7d	4c 66 a0	jmp $a066			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/divide.asm

.8f80					IntegerDivide:
.8f80	fa		plx				plx
.8f81	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.8f84	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8f87	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8f88	0a		asl a				asl 	a
.8f89	10 05		bpl $8f90			bpl 	_NotRef
.8f8b	48		pha				pha
.8f8c	20 d7 96	jsr $96d7			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8f8f	68		pla				pla
.8f90					_NotRef:
.8f90	0a		asl a				asl 	a
.8f91	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.8f93	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8f96	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8f99	f0 03		beq $8f9e			beq 	_IntegerCode 				; if clear, then we have two integers
.8f9b	4c 66 a0	jmp $a066			jmp 	TypeError 					; anything else, type mismatch.
.8f9e					_IntegerCode:
.8f9e	20 c0 8f	jsr $8fc0			jsr 	CheckDivideZero 			; do div zero check
.8fa1	20 f8 8f	jsr $8ff8			jsr 	Int32Divide 				; do the division
.8fa4	20 b5 90	jsr $90b5			jsr 	CalculateSign 				; calculate result sign
.8fa7					NSMCopyPlusTwoToZero:
.8fa7	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.8faa	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.8fad	bd 12 04	lda $0412,x			lda 	NSMantissa1+2,x
.8fb0	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.8fb3	bd 1a 04	lda $041a,x			lda 	NSMantissa2+2,x
.8fb6	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.8fb9	bd 22 04	lda $0422,x			lda 	NSMantissa3+2,x
.8fbc	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.8fbf	60		rts				rts
.8fc0					CheckDivideZero:
.8fc0	e8		inx				inx
.8fc1	20 02 9f	jsr $9f02			jsr 	NSMIsZero
.8fc4	f0 02		beq $8fc8			beq 	_CDVError
.8fc6	ca		dex				dex
.8fc7	60		rts				rts
.8fc8					_CDVError:
.8fc8	a9 03		lda #$03		lda	#3
.8fca	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler
.8fcd					IntegerModulus:
.8fcd	fa		plx				plx
.8fce	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.8fd1	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8fd4	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8fd5	0a		asl a				asl 	a
.8fd6	10 05		bpl $8fdd			bpl 	_NotRef
.8fd8	48		pha				pha
.8fd9	20 d7 96	jsr $96d7			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8fdc	68		pla				pla
.8fdd					_NotRef:
.8fdd	0a		asl a				asl 	a
.8fde	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.8fe0	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8fe3	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8fe6	f0 03		beq $8feb			beq 	_IntegerCode 				; if clear, then we have two integers
.8fe8	4c 66 a0	jmp $a066			jmp 	TypeError 					; anything else, type mismatch.
.8feb					_IntegerCode:
.8feb					IntegerModulusNoCheck:
.8feb	20 c0 8f	jsr $8fc0			jsr 	CheckDivideZero 			; do div zero check
.8fee	20 f8 8f	jsr $8ff8			jsr 	Int32Divide 				; do the division
.8ff1	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; clear the sign bit.
.8ff4	5e 00 04	lsr $0400,x			lsr 	NSStatus,x
.8ff7	60		rts				rts
.8ff8					Int32Divide:
.8ff8	48		pha				pha 								; save AXY
.8ff9	5a		phy				phy
.8ffa	20 a9 9e	jsr $9ea9			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.8ffd	20 ce 9e	jsr $9ece			jsr 	NSMSetZeroMantissaOnly 		; set S[X] to zero
.9000	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.9002					_I32DivideLoop:
.9002	e8		inx				inx
.9003	e8		inx				inx
.9004	20 e7 9e	jsr $9ee7			jsr 	NSMShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.9007	ca		dex				dex
.9008	ca		dex				dex
.9009	20 e8 9e	jsr $9ee8			jsr 	NSMRotateLeft
.900c	20 38 90	jsr $9038			jsr 	DivideCheckSubtract 		; check if subtract possible
.900f	90 03		bcc $9014			bcc 	_I32DivideNoCarryIn
.9011	fe 0a 04	inc $040a,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.9014					_I32DivideNoCarryIn:
.9014	88		dey				dey 								; loop round till division completed.
.9015	d0 eb		bne $9002			bne 	_I32DivideLoop
.9017	7a		ply				ply 								; restore AXY and exit
.9018	68		pla				pla
.9019	60		rts				rts
.901a					Int32ShiftDivide:
.901a	48		pha				pha 								; save AY
.901b	5a		phy				phy
.901c	e8		inx				inx 								; clear S[X+2]
.901d	e8		inx				inx
.901e	20 d2 9e	jsr $9ed2			jsr 	NSMSetZero
.9021	ca		dex				dex
.9022	ca		dex				dex
.9023	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.9025					_I32SDLoop:
.9025	20 38 90	jsr $9038			jsr 	DivideCheckSubtract 		; check if subtract possible
.9028	e8		inx				inx
.9029	e8		inx				inx
.902a	20 e8 9e	jsr $9ee8			jsr 	NSMRotateLeft				; shift 64 bit FPA left, rotating carry in
.902d	ca		dex				dex
.902e	ca		dex				dex
.902f	20 e8 9e	jsr $9ee8			jsr 	NSMRotateLeft
.9032	88		dey				dey 	 							; do 31 times
.9033	d0 f0		bne $9025			bne 	_I32SDLoop
.9035	7a		ply				ply 								; restore AY and exit
.9036	68		pla				pla
.9037	60		rts				rts
.9038					DivideCheckSubtract:
.9038	20 6d 91	jsr $916d			jsr 	SubTopTwoStack 				; subtract Stack[X+1] from Stack[X+0]
.903b	b0 04		bcs $9041			bcs 	_DCSExit 					; if carry set, then could do, exit
.903d	20 47 91	jsr $9147			jsr 	AddTopTwoStack 				; add it back in
.9040	18		clc				clc 								; and return False
.9041					_DCSExit:
.9041	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/multiply.asm

.9042					MulInteger:
.9042	fa		plx				plx
.9043	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9046	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9049	0a		asl a				asl 	a 							; shift reference bit into sign bit
.904a	0a		asl a				asl 	a
.904b	10 05		bpl $9052			bpl 	_NotRef
.904d	48		pha				pha
.904e	20 d7 96	jsr $96d7			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9051	68		pla				pla
.9052					_NotRef:
.9052	0a		asl a				asl 	a 							; put MSB of type into A:7
.9053	30 0b		bmi $9060			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9055	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9058	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.905b	f0 06		beq $9063			beq 	_IntegerCode 				; if clear, then we have two integers
.905d	4c 7b 95	jmp $957b			jmp 	FloatingPointMultiply 							; otherwise at least one float.
.9060					_StringData:
.9060	4c 70 a0	jmp $a070			jmp 	NotDoneError							; at least one string - don't know both are strings.
.9063					_IntegerCode:
.9063	20 70 90	jsr $9070			jsr 	MultiplyShort
.9066	c9 00		cmp #$00			cmp 	#0
.9068	f0 05		beq $906f			beq 	_MIExit
.906a	a9 04		lda #$04		lda	#4
.906c	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler
.906f					_MIExit:
.906f	60		rts				rts
.9070					MultiplyShort:
.9070	5a		phy				phy 								; save Y
.9071	20 a9 9e	jsr $9ea9			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.9074	20 ce 9e	jsr $9ece			jsr 	NSMSetZeroMantissaOnly 		; set mantissa S[X] to zero
.9077	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.9079					_I32MLoop:
.9079	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.907c	1d 12 04	ora $0412,x			ora 	NSMantissa1+2,x
.907f	1d 1a 04	ora $041a,x			ora 	NSMantissa2+2,x
.9082	1d 22 04	ora $0422,x			ora 	NSMantissa3+2,x
.9085	f0 28		beq $90af			beq 	_I32MExit 					; exit if zero
.9087	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.908a	29 01		and #$01			and 	#1
.908c	f0 0e		beq $909c			beq 	_I32MNoAdd
.908e	20 47 91	jsr $9147			jsr 	AddTopTwoStack 				; if so add S[X+1] to S[X+0]
.9091	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.9094	10 06		bpl $909c			bpl 	_I32MNoAdd
.9096					_I32ShiftRight:
.9096	20 f5 9e	jsr $9ef5			jsr 	NSMShiftRight 				; shift S[X] right
.9099	c8		iny				iny 								; increment shift count
.909a	80 0a		bra $90a6			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.909c					_I32MNoAdd:
.909c	3c 21 04	bit $0421,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.909f	70 f5		bvs $9096			bvs 	_I32ShiftRight 				; instead.
.90a1	e8		inx				inx
.90a2	20 e7 9e	jsr $9ee7			jsr 	NSMShiftLeft 				; shift additive S[X+1] left
.90a5	ca		dex				dex
.90a6					_I32MShiftUpper:
.90a6	e8		inx				inx 								; shift S[X+2] right
.90a7	e8		inx				inx
.90a8	20 f5 9e	jsr $9ef5			jsr 	NSMShiftRight
.90ab	ca		dex				dex
.90ac	ca		dex				dex
.90ad	80 ca		bra $9079			bra 	_I32MLoop 					; try again.
.90af					_I32MExit:
.90af	20 b5 90	jsr $90b5			jsr 	CalculateSign
.90b2	98		tya				tya 								; shift in A
.90b3	7a		ply				ply 								; restore Y and exit
.90b4	60		rts				rts
.90b5					CalculateSign:
.90b5	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.90b8	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; shift result left
.90bb	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.90be	0a		asl a				asl 	a 							; shift bit 7 into carry
.90bf	7e 00 04	ror $0400,x			ror 	NSStatus,x 					; shift right into status byte.
.90c2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/scompare.asm

.90c3					CompareStrings:
.90c3	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check both are strings
.90c6	3d 01 04	and $0401,x			and 	NSStatus+1,x
.90c9	29 10		and #$10			and 	#NSBIsString
.90cb	f0 2c		beq $90f9			beq 	_CSTypeError
.90cd	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy string addresses to zTemp0/1
.90d0	85 36		sta $36				sta 	zTemp0
.90d2	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.90d5	85 37		sta $37				sta 	zTemp0+1
.90d7	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.90da	85 38		sta $38				sta 	zTemp1
.90dc	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.90df	85 39		sta $39				sta 	zTemp1+1
.90e1	5a		phy				phy 								; save Y so we can access strings
.90e2	a0 ff		ldy #$ff			ldy 	#$FF 						; -1 for pre increment.
.90e4					_CSLoop:
.90e4	c8		iny				iny
.90e5	b1 36		lda ($36),y			lda 	(zTemp0),y 					; check if they are the same
.90e7	d1 38		cmp ($38),y			cmp 	(zTemp1),y
.90e9	d0 06		bne $90f1			bne 	_CSDifferent
.90eb	c9 00		cmp #$00			cmp 	#0 							; reached end ?
.90ed	d0 f5		bne $90e4			bne 	_CSLoop 					; still comparing
.90ef					_CSExit:
.90ef	7a		ply				ply 								; reached end, return zero in A from EOS
.90f0	60		rts				rts
.90f1					_CSDifferent:
.90f1	a9 ff		lda #$ff			lda 	#255 						; if < return $FF
.90f3	90 fa		bcc $90ef			bcc		_CSExit
.90f5	a9 01		lda #$01			lda 	#1 							; otherwise return 1.
.90f7	80 f6		bra $90ef			bra 	_CSExit
.90f9					_CSTypeError:
.90f9	4c 66 a0	jmp $a066			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/shifts.asm

.90fc					ShiftLeft:
.90fc	38		sec				sec 								; common code, carry determines which way.
.90fd	80 01		bra $9100			bra 	ShiftMain
.90ff					ShiftRight:
.90ff	18		clc				clc
.9100					ShiftMain:
.9100	fa		plx				plx 								; restore X
.9101	08		php				php 								; save direction
.9102	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9105	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9108	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9109	0a		asl a				asl 	a
.910a	10 05		bpl $9111			bpl 	_NotRef
.910c	48		pha				pha
.910d	20 d7 96	jsr $96d7			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9110	68		pla				pla
.9111					_NotRef:
.9111	0a		asl a				asl 	a
.9112	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9114	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9117	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.911a	f0 03		beq $911f			beq 	_IntegerCode 				; if clear, then we have two integers
.911c	4c 66 a0	jmp $a066			jmp 	TypeError 					; anything else, type mismatch.
.911f					_IntegerCode:
.911f	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; check number < 32
.9122	29 e0		and #$e0			and 	#$E0
.9124	1d 11 04	ora $0411,x			ora 	NSMantissa1+1,x
.9127	1d 19 04	ora $0419,x			ora 	NSMantissa2+1,x
.912a	1d 21 04	ora $0421,x			ora 	NSMantissa3+1,x
.912d	d0 13		bne $9142			bne 	_SMExit0 					; if >= 32 it will always return zero.
.912f					_SMLoop:
.912f	de 09 04	dec $0409,x			dec 	NSMantissa0+1,x 			; predecrement, could do << 0
.9132	30 11		bmi $9145			bmi 	_SMExit 					; exit if done.
.9134	28		plp				plp 								; restore direction setting
.9135	08		php				php
.9136	90 05		bcc $913d			bcc 	_SMRight
.9138	20 e7 9e	jsr $9ee7			jsr 	NSMShiftLeft 				; shift left if CS
.913b	80 f2		bra $912f			bra 	_SMLoop
.913d					_SMRight:
.913d	20 f5 9e	jsr $9ef5			jsr 	NSMShiftRight 				; shift right if CC
.9140	80 ed		bra $912f			bra 	_SMLoop
.9142					_SMExit0:
.9142	20 d2 9e	jsr $9ed2			jsr 	NSMSetZero 					; return zero.
.9145					_SMExit:
.9145	28		plp				plp 								; throw direction
.9146	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/simple.asm

.9147					AddTopTwoStack:
.9147	18		clc				clc
.9148	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.914b	7d 09 04	adc $0409,x			adc 		NSMantissa0+1,x
.914e	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9151	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.9154	7d 11 04	adc $0411,x			adc 		NSMantissa1+1,x
.9157	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.915a	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.915d	7d 19 04	adc $0419,x			adc 		NSMantissa2+1,x
.9160	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9163	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.9166	7d 21 04	adc $0421,x			adc 		NSMantissa3+1,x
.9169	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.916c	60		rts				rts
.916d					SubTopTwoStack:
.916d	38		sec				sec
.916e	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.9171	fd 09 04	sbc $0409,x			sbc 		NSMantissa0+1,x
.9174	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9177	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.917a	fd 11 04	sbc $0411,x			sbc 		NSMantissa1+1,x
.917d	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9180	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.9183	fd 19 04	sbc $0419,x			sbc 		NSMantissa2+1,x
.9186	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9189	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.918c	fd 21 04	sbc $0421,x			sbc 		NSMantissa3+1,x
.918f	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9192	60		rts				rts
.9193					AddInteger:
.9193	fa		plx				plx
.9194	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9197	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.919a	0a		asl a				asl 	a 							; shift reference bit into sign bit
.919b	0a		asl a				asl 	a
.919c	10 05		bpl $91a3			bpl 	_NotRef
.919e	48		pha				pha
.919f	20 d7 96	jsr $96d7			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91a2	68		pla				pla
.91a3					_NotRef:
.91a3	0a		asl a				asl 	a 							; put MSB of type into A:7
.91a4	30 0b		bmi $91b1			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.91a6	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91a9	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.91ac	f0 06		beq $91b4			beq 	_IntegerCode 				; if clear, then we have two integers
.91ae	4c fb 93	jmp $93fb			jmp 	FloatingPointAdd 							; otherwise at least one float.
.91b1					_StringData:
.91b1	4c 1f 8f	jmp $8f1f			jmp 	StringConcat							; at least one string - don't know both are strings.
.91b4					_IntegerCode:
.91b4					AddCode:
.91b4	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.91b7	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.91ba	10 8b		bpl $9147			bpl 	AddTopTwoStack
.91bc	20 6d 91	jsr $916d			jsr 	SubTopTwoStack 				; do a physical subtraction
.91bf	3c 20 04	bit $0420,x			bit 	NSMantissa3,x 				; result is +ve, okay
.91c2	10 09		bpl $91cd			bpl 	_AddExit
.91c4	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; sign is that of 2nd value
.91c7	9d 00 04	sta $0400,x			sta 	NSStatus,x
.91ca	20 87 9e	jsr $9e87			jsr 	NSMNegateMantissa 			; negate the mantissa and exit
.91cd					_AddExit:
.91cd	20 02 9f	jsr $9f02			jsr 	NSMIsZero 					; check for -0
.91d0	d0 03		bne $91d5			bne 	_AddNonZero
.91d2	9e 00 04	stz $0400,x			stz 	NSStatus,x
.91d5					_AddNonZero:
.91d5	60		rts				rts
.91d6					SubInteger:
.91d6	fa		plx				plx
.91d7	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.91da	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.91dd	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91de	0a		asl a				asl 	a
.91df	10 05		bpl $91e6			bpl 	_NotRef
.91e1	48		pha				pha
.91e2	20 d7 96	jsr $96d7			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91e5	68		pla				pla
.91e6					_NotRef:
.91e6	0a		asl a				asl 	a 							; put MSB of type into A:7
.91e7	30 0b		bmi $91f4			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.91e9	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91ec	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.91ef	f0 06		beq $91f7			beq 	_IntegerCode 				; if clear, then we have two integers
.91f1	4c 00 94	jmp $9400			jmp 	FloatingPointSub 							; otherwise at least one float.
.91f4					_StringData:
.91f4	4c 70 a0	jmp $a070			jmp 	NotDoneError							; at least one string - don't know both are strings.
.91f7					_IntegerCode:
.91f7	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; negate the second value.
.91fa	49 80		eor #$80			eor 	#$80
.91fc	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.91ff	80 b3		bra $91b4			bra 	AddCode 					; and do the same code as add.
.9201					AndInteger:
.9201	fa		plx				plx
.9202	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9205	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9208	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9209	0a		asl a				asl 	a
.920a	10 05		bpl $9211			bpl 	_NotRef
.920c	48		pha				pha
.920d	20 d7 96	jsr $96d7			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9210	68		pla				pla
.9211					_NotRef:
.9211	0a		asl a				asl 	a
.9212	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9214	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9217	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.921a	f0 03		beq $921f			beq 	_IntegerCode 				; if clear, then we have two integers
.921c	4c 66 a0	jmp $a066			jmp 	TypeError 					; anything else, type mismatch.
.921f					_IntegerCode:
.921f	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.9222	3d 09 04	and $0409,x			and 		NSMantissa0+1,x
.9225	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9228	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.922b	3d 11 04	and $0411,x			and 		NSMantissa1+1,x
.922e	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9231	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.9234	3d 19 04	and $0419,x			and 		NSMantissa2+1,x
.9237	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.923a	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.923d	3d 21 04	and $0421,x			and 		NSMantissa3+1,x
.9240	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9243	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.9246	60		rts				rts
.9247					OraInteger:
.9247	fa		plx				plx
.9248	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.924b	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.924e	0a		asl a				asl 	a 							; shift reference bit into sign bit
.924f	0a		asl a				asl 	a
.9250	10 05		bpl $9257			bpl 	_NotRef
.9252	48		pha				pha
.9253	20 d7 96	jsr $96d7			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9256	68		pla				pla
.9257					_NotRef:
.9257	0a		asl a				asl 	a
.9258	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.925a	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.925d	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9260	f0 03		beq $9265			beq 	_IntegerCode 				; if clear, then we have two integers
.9262	4c 66 a0	jmp $a066			jmp 	TypeError 					; anything else, type mismatch.
.9265					_IntegerCode:
.9265	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.9268	1d 09 04	ora $0409,x			ora 		NSMantissa0+1,x
.926b	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.926e	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.9271	1d 11 04	ora $0411,x			ora 		NSMantissa1+1,x
.9274	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9277	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.927a	1d 19 04	ora $0419,x			ora 		NSMantissa2+1,x
.927d	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9280	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.9283	1d 21 04	ora $0421,x			ora 		NSMantissa3+1,x
.9286	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9289	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.928c	60		rts				rts
.928d					EorInteger:
.928d	fa		plx				plx
.928e	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9291	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9294	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9295	0a		asl a				asl 	a
.9296	10 05		bpl $929d			bpl 	_NotRef
.9298	48		pha				pha
.9299	20 d7 96	jsr $96d7			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.929c	68		pla				pla
.929d					_NotRef:
.929d	0a		asl a				asl 	a
.929e	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.92a0	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92a3	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.92a6	f0 03		beq $92ab			beq 	_IntegerCode 				; if clear, then we have two integers
.92a8	4c 66 a0	jmp $a066			jmp 	TypeError 					; anything else, type mismatch.
.92ab					_IntegerCode:
.92ab	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.92ae	5d 09 04	eor $0409,x			eor 		NSMantissa0+1,x
.92b1	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.92b4	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.92b7	5d 11 04	eor $0411,x			eor 		NSMantissa1+1,x
.92ba	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.92bd	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.92c0	5d 19 04	eor $0419,x			eor 		NSMantissa2+1,x
.92c3	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.92c6	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.92c9	5d 21 04	eor $0421,x			eor 		NSMantissa3+1,x
.92cc	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.92cf	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.92d2	60		rts				rts
.92d3					WordIndirect:
.92d3	fa		plx				plx
.92d4	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.92d7	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.92da	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92db	0a		asl a				asl 	a
.92dc	10 05		bpl $92e3			bpl 	_NotRef
.92de	48		pha				pha
.92df	20 d7 96	jsr $96d7			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92e2	68		pla				pla
.92e3					_NotRef:
.92e3	0a		asl a				asl 	a
.92e4	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.92e6	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92e9	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.92ec	f0 03		beq $92f1			beq 	_IntegerCode 				; if clear, then we have two integers
.92ee	4c 66 a0	jmp $a066			jmp 	TypeError 					; anything else, type mismatch.
.92f1					_IntegerCode:
.92f1	20 b4 91	jsr $91b4			jsr 	AddCode 					; add the two values
.92f4	a9 22		lda #$22			lda 	#NSBIsReference+2 			; make a 2 byte reference
.92f6	9d 00 04	sta $0400,x			sta 	NSStatus,x
.92f9	60		rts				rts
.92fa					ByteIndirect:
.92fa	fa		plx				plx
.92fb	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.92fe	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9301	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9302	0a		asl a				asl 	a
.9303	10 05		bpl $930a			bpl 	_NotRef
.9305	48		pha				pha
.9306	20 d7 96	jsr $96d7			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9309	68		pla				pla
.930a					_NotRef:
.930a	0a		asl a				asl 	a
.930b	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.930d	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9310	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9313	f0 03		beq $9318			beq 	_IntegerCode 				; if clear, then we have two integers
.9315	4c 66 a0	jmp $a066			jmp 	TypeError 					; anything else, type mismatch.
.9318					_IntegerCode:
.9318	20 b4 91	jsr $91b4			jsr 	AddCode 					; add the two values
.931b	a9 21		lda #$21			lda 	#NSBIsReference+1 			; make a 1 byte reference
.931d	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9320	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/tostring.asm

.9321					LCLConvertInt16:
.9321	8d 08 04	sta $0408			sta 	NSMantissa0 				; set up as 32 bit conversion
.9324	8e 10 04	stx $0410			stx 	NSMantissa1
.9327	9c 18 04	stz $0418			stz 	NSMantissa2
.932a	9c 20 04	stz $0420			stz 	NSMantissa3
.932d	9c 00 04	stz $0400			stz 	NSStatus 					; positive integer
.9330	a2 00		ldx #$00			ldx 	#0 							; stack level
.9332	a9 0a		lda #$0a			lda 	#10 						; base
.9334	80 00		bra $9336			bra 	ConvertInt32
.9336					ConvertInt32:
.9336	5a		phy				phy
.9337	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.9339	2c 00 04	bit $0400			bit 	NSStatus 					; output a - if not negative.
.933c	10 08		bpl $9346			bpl 	_CI32NotNeg
.933e	48		pha				pha
.933f	a9 2d		lda #$2d			lda 	#'-'
.9341	99 fb 05	sta $05fb,y			sta 	NumberBuffer,y
.9344	c8		iny				iny
.9345	68		pla				pla
.9346					_CI32NotNeg:
.9346	20 54 93	jsr $9354			jsr 	_CI32DivideConvert 			; recursive conversion
.9349	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.934b	99 fb 05	sta $05fb,y			sta 	NumberBuffer,y
.934e	7a		ply				ply
.934f	a2 05		ldx #$05			ldx 	#NumberBuffer >> 8
.9351	a9 fb		lda #$fb			lda 	#NumberBuffer & $FF
.9353	60		rts				rts
.9354					_CI32DivideConvert:
.9354	e8		inx				inx 								; write to next slot up
.9355	20 d4 9e	jsr $9ed4			jsr 	NSMSetByte
.9358	ca		dex				dex
.9359	20 f8 8f	jsr $8ff8			jsr 	Int32Divide 				; divide
.935c	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; save remainder
.935f	48		pha				pha
.9360	20 a7 8f	jsr $8fa7			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.9363	20 02 9f	jsr $9f02			jsr 	NSMIsZero 					; is it zero ?
.9366	f0 06		beq $936e			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.9368	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.936b	20 54 93	jsr $9354			jsr 	_CI32DivideConvert 			; and recusrively call.
.936e					_CI32NoRecurse:
.936e	68		pla				pla 								; remainder
.936f	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.9371	90 02		bcc $9375			bcc 	_CI32NotHex
.9373	69 26		adc #$26			adc 	#6+32
.9375					_CI32NotHex:
.9375	69 30		adc #$30			adc 	#48
.9377	99 fb 05	sta $05fb,y			sta 	NumberBuffer,y 				; write out and exit
.937a	c8		iny				iny
.937b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/expression.asm


;******  Processing file: ./common/expressions/../generated/precedence.dat

.937c					PrecedenceLevel:
>937c	04					.byte	 4	; $00 <<
>937d	02					.byte	 2	; $01 <=
>937e	02					.byte	 2	; $02 <>
>937f	00					.byte	 0	; $03 !!3
>9380	00					.byte	 0	; $04 ><
>9381	02					.byte	 2	; $05 >=
>9382	04					.byte	 4	; $06 >>
>9383	00					.byte	 0	; $07 !!7
>9384	00					.byte	 0	; $08 !!8
>9385	00					.byte	 0	; $09 !!9
>9386	00					.byte	 0	; $0a !!10
>9387	00					.byte	 0	; $0b !!11
>9388	00					.byte	 0	; $0c !!12
>9389	00					.byte	 0	; $0d !!13
>938a	00					.byte	 0	; $0e !!14
>938b	00					.byte	 0	; $0f !!15
>938c	00					.byte	 0	; $10 @
>938d	00					.byte	 0	; $11 !!17
>938e	00					.byte	 0	; $12 !!18
>938f	00					.byte	 0	; $13 [
>9390	04					.byte	 4	; $14 \
>9391	00					.byte	 0	; $15 ]
>9392	01					.byte	 1	; $16 ^
>9393	00					.byte	 0	; $17 _
>9394	00					.byte	 0	; $18 `
>9395	00					.byte	 0	; $19 !!25
>9396	00					.byte	 0	; $1a !!26
>9397	00					.byte	 0	; $1b {
>9398	01					.byte	 1	; $1c |
>9399	00					.byte	 0	; $1d }
>939a	00					.byte	 0	; $1e ~
>939b	00					.byte	 0	; $1f [7m<7F>[m
>939c	00					.byte	 0	; $20
>939d	05					.byte	 5	; $21 !
>939e	00					.byte	 0	; $22 "
>939f	00					.byte	 0	; $23 #
>93a0	05					.byte	 5	; $24 $
>93a1	04					.byte	 4	; $25 %
>93a2	01					.byte	 1	; $26 &
>93a3	00					.byte	 0	; $27 '
>93a4	00					.byte	 0	; $28 (
>93a5	00					.byte	 0	; $29 )
>93a6	04					.byte	 4	; $2a *
>93a7	03					.byte	 3	; $2b +
>93a8	00					.byte	 0	; $2c ,
>93a9	03					.byte	 3	; $2d -
>93aa	00					.byte	 0	; $2e .
>93ab	04					.byte	 4	; $2f /
>93ac	00					.byte	 0	; $30 0
>93ad	00					.byte	 0	; $31 1
>93ae	00					.byte	 0	; $32 2
>93af	00					.byte	 0	; $33 3
>93b0	00					.byte	 0	; $34 4
>93b1	00					.byte	 0	; $35 5
>93b2	00					.byte	 0	; $36 6
>93b3	00					.byte	 0	; $37 7
>93b4	00					.byte	 0	; $38 8
>93b5	00					.byte	 0	; $39 9
>93b6	00					.byte	 0	; $3a :
>93b7	00					.byte	 0	; $3b ;
>93b8	02					.byte	 2	; $3c <
>93b9	02					.byte	 2	; $3d =
>93ba	02					.byte	 2	; $3e >
>93bb	05					.byte	 5	; $3f ?

;******  Return to file: ./common/expressions/expression.asm

.93bc					EvaluateExpressionAt0:
.93bc	a2 00		ldx #$00			ldx 	#0 							; bottom stack level
.93be					EvaluateExpression:
.93be	a9 00		lda #$00			lda 	#0 							; lowest precedence level
.93c0					EvaluateExpressionAtPrecedence:
.93c0	48		pha				pha 								; save precedence level
.93c1	20 98 98	jsr $9898			jsr 	EvaluateTerm 				; evaluate term into level X.
.93c4	68		pla				pla 								; restore precedence level.
.93c5					_EXPRLoop:
.93c5	85 36		sta $36				sta 	zTemp0 						; save current precedence level.
.93c7	b1 30		lda ($30),y			lda 	(codePtr),y
.93c9	c9 40		cmp #$40			cmp		#$40 						; if >= $40 cannot be an operator
.93cb	b0 25		bcs $93f2			bcs 	_EXPRExit
.93cd	da		phx				phx 								; read the operator precedence
.93ce	aa		tax				tax
.93cf	bd 7c 93	lda $937c,x			lda 	PrecedenceLevel,x
.93d2	fa		plx				plx
.93d3	c9 00		cmp #$00			cmp 	#0							; if zero exit (not an operator)
.93d5	f0 1b		beq $93f2			beq 	_EXPRExit
.93d7	85 37		sta $37				sta 	zTemp0+1 					; save operator precedence level.
.93d9	a5 36		lda $36				lda 	zTemp0 						; compare current precedence vs. operator precedence
.93db	c5 37		cmp $37				cmp 	zTemp0+1
.93dd	b0 13		bcs $93f2			bcs		_EXPRExit 					; if current >= operator exit
.93df	48		pha				pha 								; save current precedence.
.93e0	b1 30		lda ($30),y			lda 	(codePtr),y
.93e2	c8		iny				iny
.93e3	48		pha				pha
.93e4	a5 37		lda $37				lda 	zTemp0+1 					; get operator precedence level
.93e6	e8		inx				inx 								; work out the right hand side.
.93e7	20 c0 93	jsr $93c0			jsr 	EvaluateExpressionAtPrecedence
.93ea	ca		dex				dex
.93eb	68		pla				pla 								; get operator, call the code.
.93ec	20 f5 93	jsr $93f5			jsr 	_EXPRCaller
.93ef	68		pla				pla 								; restore precedence level
.93f0	80 d3		bra $93c5			bra 	_EXPRLoop 					; and go round.
.93f2					_EXPRExit:
.93f2	a5 36		lda $36				lda 	zTemp0 						; A = current precedence level.
.93f4	60		rts				rts
.93f5					_EXPRCaller:
.93f5	da		phx				phx 								; save on stack, first thing is to restore it
.93f6	0a		asl a				asl 	a 							; double so can use vectors into X
.93f7	aa		tax				tax
.93f8	7c 32 8b	jmp ($8b32,x)			jmp 	(VectorSetPunc,x) 			; and go to the code.

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/addsub.asm

.93fb					FloatingPointAdd:
.93fb	20 a4 95	jsr $95a4			jsr 	FloatPrepare 				; prepare for floats
.93fe	80 0b		bra $940b			bra 	FloatAdd
.9400					FloatingPointSub:
.9400	20 a4 95	jsr $95a4			jsr 	FloatPrepare 				; prepare for floats
.9403					FloatSubtract:
.9403	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; negate FPB
.9406	49 80		eor #$80			eor 	#$80
.9408	9d 01 04	sta $0401,x			sta 	NSStatus+1,x				; and fall through.
.940b					FloatAdd:
.940b	48		pha				pha
.940c	5a		phy				phy
.940d	20 b5 95	jsr $95b5			jsr 	NSNormalise 				; normalise S[X]
.9410	f0 5c		beq $946e			beq 	_FAReturn1
.9412	e8		inx				inx 								; normalise S[X+1]
.9413	20 b5 95	jsr $95b5			jsr 	NSNormalise
.9416	ca		dex				dex
.9417	c9 00		cmp #$00			cmp 	#0
.9419	f0 77		beq $9492			beq 	_FAExit 					; if so, just return A
.941b	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; are the exponents the same ?
.941e	dd 29 04	cmp $0429,x			cmp 	NSExponent+1,x
.9421	f0 1b		beq $943e			beq 	_FAExponentsEqual
.9423	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; work out the larger exponent
.9426	a8		tay				tay
.9427	38		sec				sec 								; do a signed comparison of the exponents.
.9428	fd 29 04	sbc $0429,x			sbc 	NSExponent+1,x
.942b	50 02		bvc $942f			bvc 	_FANoSignedChange
.942d	49 80		eor #$80			eor 	#$80
.942f					_FANoSignedChange:
.942f	29 80		and #$80			and 	#$80
.9431	10 03		bpl $9436			bpl 	_FAHaveMax
.9433	bc 29 04	ldy $0429,x			ldy 	NSExponent+1,x
.9436					_FAHaveMax:
.9436	20 95 94	jsr $9495			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.9439	e8		inx				inx
.943a	20 95 94	jsr $9495			jsr 	_FAShiftToExponent
.943d	ca		dex				dex
.943e					_FAExponentsEqual:
.943e	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; are the signs the same
.9441	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.9444	30 10		bmi $9456			bmi 	_FADifferentSigns
.9446	20 47 91	jsr $9147			jsr 	AddTopTwoStack 				; do the add of the mantissae
.9449	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.944c	10 44		bpl $9492			bpl 	_FAExit 					; if no, we are done.
.944e	20 f5 9e	jsr $9ef5			jsr 	NSMShiftRight 				; shift A right, renormalising it.
.9451	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; bump the exponent and exit
.9454	80 3c		bra $9492			bra 	_FAExit
.9456					_FADifferentSigns:
.9456	20 6d 91	jsr $916d			jsr 	SubTopTwoStack 				; subtract mantissa B from A
.9459	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; is the result negative ?
.945c	10 06		bpl $9464			bpl 	_FACheckZero 				; if no, check for -0
.945e	20 7e 9e	jsr $9e7e			jsr 	NSMNegate 					; netate result
.9461	20 87 9e	jsr $9e87			jsr 	NSMNegateMantissa 			; negate (2'c) the mantissa
.9464					_FACheckZero:
.9464	20 02 9f	jsr $9f02			jsr 	NSMIsZero	 				; check for -0
.9467	d0 29		bne $9492			bne 	_FAExit
.9469	9e 00 04	stz $0400,x			stz 	NSStatus,x
.946c	80 24		bra $9492			bra 	_FAExit
.946e					_FAReturn1:
.946e	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.9471	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9474	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.9477	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.947a	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.947d	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9480	bd 21 04	lda $0421,x			lda 	NSMantissa3+1,x
.9483	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9486	bd 29 04	lda $0429,x			lda 	NSExponent+1,x
.9489	9d 28 04	sta $0428,x			sta 	NSExponent,x
.948c	bd 01 04	lda $0401,x			lda 	NSStatus+1,x
.948f	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9492					_FAExit:
.9492	7a		ply				ply
.9493	68		pla				pla
.9494	60		rts				rts
.9495					_FAShiftToExponent:
.9495					_FAShiftToExponent2:
.9495	98		tya				tya 								; compare Y to exponent
.9496	dd 28 04	cmp $0428,x			cmp 	NSExponent,x 				; reached the exponent required ?
.9499	f0 08		beq $94a3			beq 	_FASEExit 					; exit if so.
.949b	20 f5 9e	jsr $9ef5			jsr 	NSMShiftRight	 			; shift the mantissa right
.949e	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; increment exponent
.94a1	80 f2		bra $9495			bra 	_FAShiftToExponent2
.94a3					_FASEExit:
.94a3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/compare.asm

.94a4					CompareFloat:
.94a4	20 03 94	jsr $9403			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.94a7	bd 10 04	lda $0410,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.94aa	29 f8		and #$f8			and 	#$F8
.94ac	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.94af	1d 20 04	ora $0420,x			ora 	NSMantissa3,x
.94b2	f0 09		beq $94bd			beq 	_FCExit 					; zero, so approximately identical
.94b4	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.94b6	3c 00 04	bit $0400,x			bit 	NSStatus,x
.94b9	10 02		bpl $94bd			bpl 	_FCExit
.94bb					_FCNegative:
.94bb	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.94bd					_FCExit:
.94bd	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/divide.asm

.94be					FDivideCommand:
.94be	fa		plx				plx	 								; restore stack position
.94bf	20 a4 95	jsr $95a4			jsr 	FloatPrepare 				; prepare for floats
.94c2					FloatDivide:
.94c2	48		pha				pha
.94c3	e8		inx				inx
.94c4	20 b5 95	jsr $95b5			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.94c7	ca		dex				dex
.94c8	c9 00		cmp #$00			cmp 	#0
.94ca	f0 20		beq $94ec			beq 	_FDZero
.94cc	20 b5 95	jsr $95b5			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.94cf	f0 19		beq $94ea			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.94d1	20 1a 90	jsr $901a			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.94d4	20 a7 8f	jsr $8fa7			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.94d7	20 b5 95	jsr $95b5			jsr		NSNormalise 				; renormalise
.94da	20 b5 90	jsr $90b5			jsr 	CalculateSign 				; calculate result sign
.94dd	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; calculate exponent
.94e0	38		sec				sec
.94e1	fd 29 04	sbc $0429,x			sbc 	NSExponent+1,x
.94e4	38		sec				sec
.94e5	e9 1e		sbc #$1e			sbc 	#30
.94e7	9d 28 04	sta $0428,x			sta 	NSExponent,x
.94ea					_FDExit:
.94ea	68		pla				pla
.94eb	60		rts				rts
.94ec					_FDZero:
.94ec	a9 03		lda #$03		lda	#3
.94ee	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/fractional.asm

.94f1					FloatFractionalPart:
.94f1	5a		phy				phy
.94f2	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; take absolute value
.94f5	29 7f		and #$7f			and 	#$7F
.94f7	9d 00 04	sta $0400,x			sta 	NSStatus,x
.94fa	20 b5 95	jsr $95b5			jsr 	NSNormalise
.94fd	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.9500	38		sec				sec
.9501	e9 e0		sbc #$e0			sbc 	#$E0
.9503	90 31		bcc $9536			bcc 	_FFPExit 					; already fractional
.9505	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.9507	b0 2a		bcs $9533			bcs 	_FFPZero
.9509	a8		tay				tay 								; put count to do in Y
.950a	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; do each in turn.
.950d	20 38 95	jsr $9538			jsr 	_FFPPartial
.9510	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9513	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9516	20 38 95	jsr $9538			jsr 	_FFPPartial
.9519	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.951c	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.951f	20 38 95	jsr $9538			jsr 	_FFPPartial
.9522	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9525	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9528	20 38 95	jsr $9538			jsr 	_FFPPartial
.952b	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.952e	20 02 9f	jsr $9f02			jsr 	NSMIsZero 					; zeroed check.
.9531	d0 03		bne $9536			bne 	_FFPExit
.9533					_FFPZero:
.9533	20 d2 9e	jsr $9ed2			jsr 	NSMSetZero
.9536					_FFPExit:
.9536	7a		ply				ply
.9537	60		rts				rts
.9538					_FFPPartial:
.9538	c0 00		cpy #$00			cpy 	#0 							; no more to do
.953a	f0 17		beq $9553			beq 	_FFFPPExit
.953c	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.953e	b0 0c		bcs $954c			bcs 	_FFFPPWholeByte
.9540	5a		phy				phy
.9541					_FFFPPLeft:
.9541	0a		asl a				asl 	a
.9542	88		dey				dey
.9543	d0 fc		bne $9541			bne 	_FFFPPLeft
.9545	7a		ply				ply
.9546					_FFFPPRight:
.9546	4a		lsr a				lsr 	a
.9547	88		dey				dey
.9548	d0 fc		bne $9546			bne 	_FFFPPRight
.954a	80 07		bra $9553			bra 	_FFFPPExit
.954c					_FFFPPWholeByte:
.954c	98		tya				tya 								; subtract 8 from count
.954d	38		sec				sec
.954e	e9 08		sbc #$08			sbc 	#8
.9550	a8		tay				tay
.9551	a9 00		lda #$00			lda 	#0 							; and clear all
.9553					_FFFPPExit:
.9553	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/integer.asm

.9554					FloatIntegerPart:
.9554	48		pha				pha
.9555	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; is it integer already ?
.9558	f0 1f		beq $9579			beq 	_FIPExit 					; if so do nothing
.955a	20 02 9f	jsr $9f02			jsr 	NSMIsZero 					; is it zero ?
.955d	f0 17		beq $9576			beq 	_FIPZero 					; if so return zero.
.955f	20 b5 95	jsr $95b5			jsr 	NSNormalise 				; normalise
.9562	f0 12		beq $9576			beq 	_FIPZero 					; normalised to zero, exit zero
.9564					_FIPShift:
.9564	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.9567	10 08		bpl $9571			bpl 	_FIPCheckZero
.9569	20 f5 9e	jsr $9ef5			jsr 	NSMShiftRight 				; shift mantissa right
.956c	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; bump exponent
.956f	80 f3		bra $9564			bra 	_FIPShift
.9571					_FIPCheckZero:
.9571	20 02 9f	jsr $9f02			jsr 	NSMIsZero 					; avoid -0 problem
.9574	d0 03		bne $9579			bne 	_FIPExit 					; set to zero if mantissa zero.
.9576					_FIPZero:
.9576	20 d2 9e	jsr $9ed2			jsr 	NSMSetZero
.9579					_FIPExit:
.9579	68		pla				pla
.957a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/multiply.asm

.957b					FloatingPointMultiply:
.957b	20 a4 95	jsr $95a4			jsr 	FloatPrepare 				; prepare for floats
.957e					FloatMultiply:
.957e	48		pha				pha
.957f	20 b5 95	jsr $95b5			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.9582	f0 1b		beq $959f			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.9584	e8		inx				inx
.9585	20 b5 95	jsr $95b5			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.9588	ca		dex				dex
.9589	c9 00		cmp #$00			cmp 	#0
.958b	f0 0f		beq $959c			beq 	_FDSetZero
.958d	20 70 90	jsr $9070			jsr 	MultiplyShort 				; calculate the result.
.9590	7d 28 04	adc $0428,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.9593	18		clc				clc
.9594	7d 29 04	adc $0429,x			adc 	NSExponent+1,x
.9597	9d 28 04	sta $0428,x			sta 	NSExponent,x
.959a	80 03		bra $959f			bra 	_FDExit
.959c					_FDSetZero:
.959c	20 d2 9e	jsr $9ed2			jsr 	NSMSetZero 					; return 0
.959f					_FDExit:
.959f	20 b5 95	jsr $95b5			jsr 	NSNormalise 				; normalise the result
.95a2	68		pla				pla
.95a3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/utility.asm

.95a4					FloatPrepare:
.95a4	20 d7 96	jsr $96d7			jsr 	DereferenceTopTwo 			; dereference the top two values
.95a7	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check ints/floats
.95aa	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.95ad	29 10		and #$10			and 	#NSBIsString
.95af	d0 01		bne $95b2			bne 	_FDType
.95b1	60		rts				rts
.95b2					_FDType:
.95b2	4c 66 a0	jmp $a066			jmp 	TypeError
.95b5					NSNormalise:
.95b5	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; make float, keep sign
.95b8	29 80		and #$80			and 	#$80
.95ba	09 08		ora #$08			ora 	#NSTFloat
.95bc	9d 00 04	sta $0400,x			sta 	NSStatus,x
.95bf	20 02 9f	jsr $9f02			jsr 	NSMIsZero 					; if zero exit
.95c2	d0 09		bne $95cd			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.95c4	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; clear the sign bit.
.95c7	7e 00 04	ror $0400,x			ror 	NSStatus,x 					; (no -0)
.95ca	a9 00		lda #$00			lda 	#0 							; set Z flag
.95cc	60		rts				rts
.95cd					_NSNormaliseOptimise:
.95cd	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; upper byte zero ?
.95d0	d0 22		bne $95f4			bne 	_NSNormaliseLoop
.95d2	bd 18 04	lda $0418,x			lda 	NSMantissa2,x 				; byte normalise
.95d5	30 1d		bmi $95f4			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.95d7	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.95da	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.95dd	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.95e0	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.95e3	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.95e6	9e 08 04	stz $0408,x			stz 	NSMantissa0,x
.95e9	bd 28 04	lda $0428,x			lda 	NSExponent,x
.95ec	38		sec				sec
.95ed	e9 08		sbc #$08			sbc 	#8
.95ef	9d 28 04	sta $0428,x			sta 	NSExponent,x
.95f2	80 d9		bra $95cd			bra 	_NSNormaliseOptimise
.95f4					_NSNormaliseLoop:
.95f4	3c 20 04	bit $0420,x			bit 	NSMantissa3,x 				; bit 30 set ?
.95f7	70 08		bvs $9601			bvs 	_NSNExit 					; exit if so with Z flag clear
.95f9	20 e7 9e	jsr $9ee7			jsr 	NSMShiftLeft 				; shift mantissa left
.95fc	de 28 04	dec $0428,x			dec 	NSExponent,x 				; adjust exponent
.95ff	80 f3		bra $95f4			bra 	_NSNormaliseLoop
.9601					_NSNExit:
.9601	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.9603	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignnumber.asm

.9604					AssignNumber:
.9604	5a		phy				phy
.9605	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy mantissa0/1 to zTemp0
.9608	85 36		sta $36				sta 	zTemp0
.960a	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.960d	85 37		sta $37				sta 	zTemp0+1
.960f	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; clear reference bits
.9612	29 df		and #$df			and 	#(NSBIsReference ^ $FF)
.9614	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9617	29 18		and #$18			and 	#NSBTypeMask				; assigning to a float ?
.9619	c9 08		cmp #$08			cmp 	#NSTFloat
.961b	f0 2a		beq $9647			beq 	_ANFloat
.961d	bd 29 04	lda $0429,x			lda		NSExponent+1,x 				; is it a float
.9620	f0 05		beq $9627			beq		_ANNotFloat
.9622	e8		inx				inx
.9623	20 54 95	jsr $9554			jsr 	FloatIntegerPart 			; make it an integer
.9626	ca		dex				dex
.9627					_ANNotFloat:
.9627	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if byte/word reference.
.962a	29 03		and #$03			and 	#3
.962c	d0 05		bne $9633			bne 	_ANByteWord
.962e	20 53 96	jsr $9653			jsr 	_ANCopy4PackSign 			; copy all 4 bytes and sign
.9631	80 1e		bra $9651			bra 	_ANExit
.9633					_ANByteWord:
.9633	48		pha				pha 								; save count
.9634	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; do byte
.9637	92 36		sta ($36)			sta 	(zTemp0)
.9639	68		pla				pla
.963a	c9 01		cmp #$01			cmp	 	#1
.963c	f0 13		beq $9651			beq 	_ANExit
.963e	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x 			; do word
.9641	a0 01		ldy #$01			ldy 	#1
.9643	91 36		sta ($36),y			sta 	(zTemp0),y
.9645	80 0a		bra $9651			bra 	_ANExit
.9647					_ANFloat:
.9647	20 53 96	jsr $9653			jsr 	_ANCopy4PackSign 			; write all 4 bytes and packed sign
.964a	bd 29 04	lda $0429,x			lda 	NSExponent+1,x 				; copy exponent to slot 4
.964d	a0 04		ldy #$04			ldy 	#4
.964f	91 36		sta ($36),y			sta 	(zTemp0),y
.9651					_ANExit:
.9651	7a		ply				ply
.9652	60		rts				rts
.9653					_ANCopy4PackSign:
.9653	a0 03		ldy #$03			ldy 	#3
.9655	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; sign bit into status
.9658	29 80		and #$80			and 	#$80 						; put into high bit of mantissa 3
.965a	1d 21 04	ora $0421,x			ora 	NSMantissa3+1,x
.965d	91 36		sta ($36),y			sta 	(zTemp0),y
.965f	88		dey				dey
.9660	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.9663	91 36		sta ($36),y			sta 	(zTemp0),y
.9665	88		dey				dey
.9666	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.9669	91 36		sta ($36),y			sta 	(zTemp0),y
.966b	88		dey				dey
.966c	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.966f	91 36		sta ($36),y			sta 	(zTemp0),y
.9671	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignstring.asm

.9672					AssignString:
.9672	5a		phy				phy
.9673	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.9676	85 38		sta $38				sta 	zTemp1
.9678	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.967b	85 39		sta $39				sta 	zTemp1+1
.967d	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9680	85 36		sta $36				sta 	zTemp0
.9682	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9685	85 37		sta $37				sta 	zTemp0+1
.9687	a0 01		ldy #$01			ldy 	#1 							; the high byte of the target address
.9689	b1 36		lda ($36),y			lda 	(zTemp0),y
.968b	f0 23		beq $96b0			beq 	_ASNewStringRequired 		; if zero, a new string is required.
.968d	38		sec				sec 								; put Address-2 in zsTemp - this is the size/status/string record
.968e	b2 36		lda ($36)			lda 	(zTemp0) 					; of concreted strings
.9690	e9 02		sbc #$02			sbc 	#2
.9692	85 3c		sta $3c				sta 	zsTemp
.9694	a0 01		ldy #$01			ldy 	#1
.9696	b1 36		lda ($36),y			lda 	(zTemp0),y
.9698	e9 00		sbc #$00			sbc 	#0
.969a	85 3d		sta $3d				sta 	zsTemp+1
.969c	a0 ff		ldy #$ff			ldy 	#$FF 						; get length of new string
.969e					_ASGetLength:
.969e	c8		iny				iny
.969f	b1 38		lda ($38),y			lda 	(zTemp1),y
.96a1	d0 fb		bne $969e			bne 	_ASGetLength
.96a3	98		tya				tya 								; is this length <= current length
.96a4	d2 3c		cmp ($3c)			cmp 	(zsTemp)
.96a6	90 20		bcc $96c8			bcc 	_ASCopyString
.96a8	f0 1e		beq $96c8			beq 	_ASCopyString
.96aa	a9 80		lda #$80			lda 	#$80 						; mark as unused.
.96ac	a0 01		ldy #$01			ldy 	#1
.96ae	91 3c		sta ($3c),y			sta 	(zsTemp),y
.96b0					_ASNewStringRequired:
.96b0	e8		inx				inx 								; concrete the new string.
.96b1	20 c3 a7	jsr $a7c3			jsr 	StringConcrete				; (breaks zTemp1/2, not zTemp0 and zsTemp)
.96b4	ca		dex				dex
.96b5	18		clc				clc
.96b6	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; copy that new address to the reference.
.96b9	69 02		adc #$02			adc 	#2 							; add two to point at the data.
.96bb	92 36		sta ($36)			sta 	(zTemp0)
.96bd	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.96c0	69 00		adc #$00			adc 	#0
.96c2	a0 01		ldy #$01			ldy 	#1
.96c4	91 36		sta ($36),y			sta 	(zTemp0),y
.96c6	80 0d		bra $96d5			bra 	_ASExit
.96c8					_ASCopyString:
.96c8	a0 00		ldy #$00			ldy 	#0
.96ca					_ASCopyLoop:
.96ca	b1 38		lda ($38),y			lda 	(zTemp1),y
.96cc	c8		iny				iny
.96cd	c8		iny				iny
.96ce	91 3c		sta ($3c),y			sta 	(zsTemp),y
.96d0	88		dey				dey
.96d1	c9 00		cmp #$00			cmp 	#0
.96d3	d0 f5		bne $96ca			bne 	_ASCopyLoop
.96d5					_ASExit:
.96d5	7a		ply				ply
.96d6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/dereference.asm

.96d7					DereferenceTopTwo:
.96d7	e8		inx				inx
.96d8	20 dc 96	jsr $96dc			jsr 	Dereference 				; deref x+1
.96db	ca		dex				dex  								; falls through to deref x
.96dc					Dereference:
.96dc	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get the status byte
.96df	29 20		and #$20			and 	#NSBIsReference 			; shift sign bit to carry, reference to bit 7
.96e1	f0 57		beq $973a			beq 	_DRFExit 					; not a reference
.96e3	5a		phy				phy
.96e4	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address to dereference into zTemp0
.96e7	85 36		sta $36				sta 	zTemp0
.96e9	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.96ec	85 37		sta $37				sta 	zTemp0+1
.96ee	9e 10 04	stz $0410,x			stz 	NSMantissa1,x 				; clear second byte.
.96f1	b2 36		lda ($36)			lda 	(zTemp0) 					; do the first byte
.96f3	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.96f6	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get status byte.
.96f9	29 18		and #$18			and 	#NSBTypeMask 				; what type is it ?
.96fb	c9 10		cmp #$10			cmp 	#NSTString 					; if string, dereference two
.96fd	f0 0f		beq $970e			beq 	_DRFDereferenceTwo
.96ff	c9 08		cmp #$08			cmp 	#NSTFloat 					; if float, do full dereference.
.9701	f0 39		beq $973c			beq 	_DRFFull
.9703	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be integer - how many bytes ?
.9706	29 03		and #$03			and 	#3
.9708	f0 32		beq $973c			beq 	_DRFFull 					; the whole word
.970a	c9 01		cmp #$01			cmp 	#1 							; is it 10 (e.g. 2 bytes)
.970c	f0 07		beq $9715			beq		_DRFClear23 				; no, one byte, clear 2 & 3 and exit
.970e					_DRFDereferenceTwo:
.970e	a0 01		ldy #$01			ldy 	#1
.9710	b1 36		lda ($36),y			lda 	(zTemp0),y
.9712	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9715					_DRFClear23:
.9715	9e 18 04	stz $0418,x			stz 	NSMantissa2,x 				; clear upper bytes, only read 1 or 2 bytes
.9718	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.971b	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; make it a value of that type.
.971e	29 18		and #$18			and 	#NSBTypeMask
.9720	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9723	c9 10		cmp #$10			cmp 	#NSTString  				; is it a string
.9725	d0 12		bne $9739			bne 	_DRFNotString
.9727	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; check address is zero
.972a	1d 10 04	ora $0410,x			ora 	NSMantissa1,x
.972d	d0 0a		bne $9739			bne 	_DRFNotString
.972f	a9 3b		lda #$3b			lda 	#_DRFNullString & $FF 		; if so, return reference to ""
.9731	9d 08 04	sta $0408,x			sta 	NSMantissa0,X
.9734	a9 97		lda #$97			lda 	#_DRFNullString >> 8
.9736	9d 10 04	sta $0410,x			sta 	NSMantissa1,X
.9739					_DRFNotString
.9739	7a		ply				ply 								; restore Y and exit
.973a					_DRFExit:
.973a	60		rts				rts
.973b					_DRFNullString:
>973b	00						.byte 	0
.973c					_DRFFull:
.973c	a0 01		ldy #$01			ldy 	#1 							; get remaining 3 bytes.
.973e	b1 36		lda ($36),y			lda 	(zTemp0),y
.9740	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9743	c8		iny				iny
.9744	b1 36		lda ($36),y			lda 	(zTemp0),y
.9746	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9749	c8		iny				iny
.974a	b1 36		lda ($36),y			lda 	(zTemp0),y
.974c	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.974f	9e 28 04	stz $0428,x			stz 	NSExponent,x 				; clear exponent.
.9752	bd 00 04	lda $0400,x			lda		NSStatus,x 					; see if type is integer
.9755	29 18		and #$18			and 	#NSBTypeMask  				; type information only
.9757	9d 00 04	sta $0400,x			sta 	NSStatus,x 					; update it back.
.975a	f0 06		beq $9762			beq 	_DRFNoExponent
.975c	c8		iny				iny 								; if not, read the exponent as well.
.975d	b1 36		lda ($36),y			lda 	(zTemp0),y
.975f	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9762					_DRFNoExponent:
.9762	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; is the most significant bit set ?
.9765	10 0d		bpl $9774			bpl 	_DRFExit2 					; if not, then exit.
.9767	29 7f		and #$7f			and 	#$7F 						; clear that bit.
.9769	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.976c	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; set the sign flag
.976f	09 80		ora #$80			ora 	#NSBIsNegative
.9771	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9774					_DRFExit2:
.9774	7a		ply				ply
.9775	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/number.asm

=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.9776					EncodeNumberStart:
.9776	38		sec				sec
.9777	80 01		bra $977a			bra 	EncodeNumberContinue+1
.9779					EncodeNumberContinue:
.9779	18		clc				clc
.977a					EncodeNumber:
.977a	08		php				php 								; save reset.
.977b	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.977d	f0 12		beq $9791			beq 	_ENIsOkay
.977f	c9 30		cmp #$30			cmp 	#"0"
.9781	90 04		bcc $9787			bcc 	_ENBadNumber
.9783	c9 3a		cmp #$3a			cmp 	#"9"+1
.9785	90 0a		bcc $9791			bcc 	_ENIsOkay
.9787					_ENBadNumber:
.9787	28		plp				plp 								; throw saved reset
.9788	ad 85 04	lda $0485			lda 	EncodeState 				; decimal mode, construct final number
.978b	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.978d	f0 7e		beq $980d			beq 	_ENConstructFinal
.978f					_ENFail:
.978f	18		clc				clc 								; not allowed
.9790	60		rts				rts
.9791					_ENIsOkay:
.9791	28		plp				plp 								; are we restarting
.9792	90 15		bcc $97a9			bcc 	_ENNoRestart
.9794					_ENStartEncode:
.9794	c9 2e		cmp #$2e			cmp 	#'.'						; first is DP
.9796	f0 0c		beq $97a4			beq 	_ENFirstDP
.9798	29 0f		and #$0f			and 	#15 						; put digit in mantissa
.979a	20 d4 9e	jsr $9ed4			jsr 	NSMSetByte
.979d	a9 01		lda #$01			lda 	#ESTA_Low
.979f					_ENExitChange:
.979f	8d 85 04	sta $0485			sta 	EncodeState 				; save new state
.97a2	38		sec				sec
.97a3	60		rts				rts
.97a4					_ENFirstDP:
.97a4	20 d2 9e	jsr $9ed2			jsr 	NSMSetZero 					; clear integer part
.97a7	80 3f		bra $97e8			bra 	_ESTASwitchFloat			; go straight to float and exi
.97a9					_ENNoRestart:
.97a9	48		pha				pha 								; save on stack.
.97aa	ad 85 04	lda $0485			lda 	EncodeState 				; get current state
.97ad	c9 01		cmp #$01			cmp 	#ESTA_Low
.97af	f0 09		beq $97ba			beq  	_ESTALowState
.97b1	c9 02		cmp #$02			cmp 	#ESTA_High
.97b3	f0 29		beq $97de			beq 	_ESTAHighState
.97b5	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.97b7	f0 3b		beq $97f4			beq 	_ESTADecimalState
>97b9	db						.byte 	$DB 						; causes a break in the emulator
.97ba					_ESTALowState:
.97ba	68		pla				pla 								; get value back
.97bb	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.97bd	f0 29		beq $97e8			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.97bf	29 0f		and #$0f			and 	#15 						; make digit
.97c1	8d 86 04	sta $0486			sta 	DigitTemp 					; save it.
.97c4	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.97c7	0a		asl a				asl 	a
.97c8	0a		asl a				asl 	a
.97c9	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.97cc	0a		asl a				asl 	a
.97cd	6d 86 04	adc $0486			adc 	DigitTemp
.97d0	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.97d3	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.97d5	90 05		bcc $97dc			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.97d7	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.97d9	8d 85 04	sta $0485			sta 	EncodeState
.97dc					_ESTANoSwitch:
.97dc	38		sec				sec
.97dd	60		rts				rts
.97de					_ESTAHighState:
.97de	68		pla				pla 								; get value back
.97df	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.97e1	f0 05		beq $97e8			beq 	_ESTASwitchFloat
.97e3	20 47 98	jsr $9847			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.97e6	38		sec				sec
.97e7	60		rts				rts
.97e8					_ESTASwitchFloat:
.97e8	9c 87 04	stz $0487			stz 	DecimalCount
.97eb	e8		inx				inx 								; zero the decimal additive.
.97ec	20 d2 9e	jsr $9ed2			jsr 	NSMSetZero
.97ef	ca		dex				dex
.97f0	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.97f2	80 ab		bra $979f			bra 	_ENExitChange
.97f4					_ESTADecimalState:
.97f4	68		pla				pla 								; digit.
.97f5	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 2nd decimal point.
.97f7	f0 96		beq $978f			beq 	_ENFail
.97f9	e8		inx				inx 								; put digit into fractional part of X+1
.97fa	20 47 98	jsr $9847			jsr 	ESTAShiftDigitIntoMantissa
.97fd	ca		dex				dex
.97fe	ee 87 04	inc $0487			inc 	DecimalCount 				; bump the count of decimals
.9801	ad 87 04	lda $0487			lda 	DecimalCount
.9804	c9 0b		cmp #$0b			cmp 	#11
.9806	f0 02		beq $980a			beq 	_ESTADSFail
.9808	38		sec				sec
.9809	60		rts				rts
.980a					_ESTADSFail:
.980a	4c 61 a0	jmp $a061			jmp 	RangeError
.980d					_ENConstructFinal:
.980d	ad 87 04	lda $0487			lda 	DecimalCount 				; get decimal count
.9810	f0 33		beq $9845			beq 	_ENCFExit 					; no decimals
.9812	5a		phy				phy
.9813	0a		asl a				asl 	a 							; x 4 and CLC
.9814	0a		asl a				asl 	a
.9815	6d 87 04	adc $0487			adc 	DecimalCount
.9818	a8		tay				tay
.9819	b9 20 a0	lda $a020,y			lda 	DecimalScalarTable-5,y 		; copy decimal scalar to X+2
.981c	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.981f	b9 21 a0	lda $a021,y			lda 	DecimalScalarTable-5+1,y
.9822	9d 12 04	sta $0412,x			sta 	NSMantissa1+2,x
.9825	b9 22 a0	lda $a022,y			lda 	DecimalScalarTable-5+2,y
.9828	9d 1a 04	sta $041a,x			sta 	NSMantissa2+2,x
.982b	b9 23 a0	lda $a023,y			lda 	DecimalScalarTable-5+3,y
.982e	9d 22 04	sta $0422,x			sta 	NSMantissa3+2,x
.9831	b9 24 a0	lda $a024,y			lda 	DecimalScalarTable-5+4,y
.9834	9d 2a 04	sta $042a,x			sta 	NSExponent+2,x
.9837	a9 08		lda #$08			lda 	#NSTFloat
.9839	9d 02 04	sta $0402,x			sta 	NSStatus+2,x
.983c	7a		ply				ply
.983d	e8		inx				inx 								; multiply decimal const by decimal scalar
.983e	20 7e 95	jsr $957e			jsr 	FloatMultiply
.9841	ca		dex				dex
.9842	20 0b 94	jsr $940b			jsr 	FloatAdd 					; add to integer part.
.9845					_ENCFExit:
.9845	18		clc				clc 								; reject the digit.
.9846	60		rts				rts
.9847					ESTAShiftDigitIntoMantissa:
.9847	29 0f		and #$0f			and 	#15 						; save digit
.9849	48		pha				pha
.984a	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; push mantissa on stack
.984d	48		pha				pha
.984e	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9851	48		pha				pha
.9852	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9855	48		pha				pha
.9856	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9859	48		pha				pha
.985a	20 e7 9e	jsr $9ee7			jsr 	NSMShiftLeft 				; x 2
.985d	20 e7 9e	jsr $9ee7			jsr 	NSMShiftLeft 				; x 4
.9860	18		clc				clc 								; pop mantissa and add
.9861	68		pla				pla
.9862	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.9865	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9868	68		pla				pla
.9869	7d 10 04	adc $0410,x			adc 	NSMantissa1,x
.986c	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.986f	68		pla				pla
.9870	7d 18 04	adc $0418,x			adc 	NSMantissa2,x
.9873	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9876	68		pla				pla
.9877	7d 20 04	adc $0420,x			adc 	NSMantissa3,x
.987a	9d 20 04	sta $0420,x			sta 	NSMantissa3,x 				; x 5
.987d	20 e7 9e	jsr $9ee7			jsr 	NSMShiftLeft 				; x 10
.9880	68		pla				pla 								; add digit
.9881	18		clc				clc
.9882	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.9885	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9888	90 0d		bcc $9897			bcc 	_ESTASDExit
.988a	fe 10 04	inc $0410,x			inc 	NSMantissa1,x
.988d	d0 08		bne $9897			bne 	_ESTASDExit
.988f	fe 18 04	inc $0418,x			inc 	NSMantissa2,x
.9892	d0 03		bne $9897			bne 	_ESTASDExit
.9894	fe 20 04	inc $0420,x			inc 	NSMantissa3,x
.9897					_ESTASDExit:
.9897	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/term.asm

.9898					EvaluateTerm:
.9898	b1 30		lda ($30),y			lda 	(codePtr),y
.989a	30 18		bmi $98b4			bmi 	_ETCheckUnary 				; unary function ? (text ones)
.989c	c9 40		cmp #$40			cmp 	#$40 						; 40-7F => identifier reference
.989e	b0 6f		bcs $990f			bcs 	_ETVariable
.98a0	c9 30		cmp #$30			cmp 	#'0' 						; is it a number
.98a2	90 6e		bcc $9912			bcc 	_ETPuncUnary 				; if not it might be a punctuation unary.
.98a4	c9 3a		cmp #$3a			cmp 	#'9'+1
.98a6	b0 6a		bcs $9912			bcs 	_ETPuncUnary
.98a8	20 76 97	jsr $9776			jsr 	EncodeNumberStart 			; can't fail as it's 0-9 !
.98ab					_ETNumber:
.98ab	c8		iny				iny 								; keep encoding until we have the numbers
.98ac	b1 30		lda ($30),y			lda 	(codePtr),y
.98ae	20 79 97	jsr $9779			jsr 	EncodeNumberContinue
.98b1	b0 f8		bcs $98ab			bcs 	_ETNumber 					; go back if accepted.
.98b3	60		rts				rts
.98b4					_ETCheckUnary:
.98b4	c9 ff		cmp #$ff			cmp 	#KWC_STRING 				; string token
.98b6	f0 41		beq $98f9			beq 	_ETString
.98b8	c9 fe		cmp #$fe			cmp 	#KWC_HEXCONST 				; hex constant.
.98ba	f0 12		beq $98ce			beq 	_ETHexConstant
.98bc	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; check it actually is a unary function
.98be	90 0b		bcc $98cb			bcc 	_ETSyntaxError
.98c0	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1
.98c2	b0 07		bcs $98cb			bcs 	_ETSyntaxError
.98c4	da		phx				phx 								; push X on the stack
.98c5	0a		asl a				asl 	a 							; put vector x 2 into X
.98c6	aa		tax				tax
.98c7	c8		iny				iny 								; consume unary function token
.98c8	7c b2 8b	jmp ($8bb2,x)			jmp 	(VectorSet0,x) 				; and do it.
.98cb					_ETSyntaxError:
.98cb	4c 5c a0	jmp $a05c			jmp 	SyntaxError
.98ce					_ETHexConstant:
.98ce	c8		iny				iny 								; skip #
.98cf	c8		iny				iny 								; skip count
.98d0	20 d2 9e	jsr $9ed2			jsr 	NSMSetZero 					; clear result
.98d3					_ETHLoop:
.98d3	b1 30		lda ($30),y			lda 	(codePtr),y
.98d5	c8		iny				iny 								; and consume
.98d6	c9 00		cmp #$00			cmp 	#0 							; exit if zero
.98d8	f0 1e		beq $98f8			beq 	_ETHExit
.98da	48		pha				pha 								; save on stack.
.98db	20 e7 9e	jsr $9ee7			jsr 	NSMShiftLeft 				; x 2
.98de	20 e7 9e	jsr $9ee7			jsr 	NSMShiftLeft 				; x 4
.98e1	20 e7 9e	jsr $9ee7			jsr 	NSMShiftLeft 				; x 8
.98e4	20 e7 9e	jsr $9ee7			jsr 	NSMShiftLeft 				; x 16
.98e7	68		pla				pla 								; ASCII
.98e8	c9 41		cmp #$41			cmp 	#'A'
.98ea	90 02		bcc $98ee			bcc 	_ETHNotChar
.98ec	e9 07		sbc #$07			sbc 	#7
.98ee					_ETHNotChar:
.98ee	29 0f		and #$0f			and 	#15 						; digit now
.98f0	1d 08 04	ora $0408,x			ora 	NSMantissa0,x 				; put in LS Nibble
.98f3	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.98f6	80 db		bra $98d3			bra 	_ETHLoop 					; go round.
.98f8					_ETHExit:
.98f8	60		rts				rts
.98f9					_ETString:
.98f9	c8		iny				iny 								; look at length
.98fa	b1 30		lda ($30),y			lda 	(codePtr),y
.98fc	48		pha				pha
.98fd	c8		iny				iny 								; first character
.98fe	20 60 a6	jsr $a660			jsr 	MemoryInline 				; put address of string at (code-Ptr),y on stack
.9901	68		pla				pla 								; restore count and save
.9902	85 36		sta $36				sta 	zTemp0
.9904	98		tya				tya 								; add length to Y to skip it.
.9905	18		clc				clc
.9906	65 36		adc $36				adc 	zTemp0
.9908	a8		tay				tay
.9909	a9 10		lda #$10			lda 	#NSTString 					; mark as string
.990b	9d 00 04	sta $0400,x			sta 	NSStatus,x
.990e	60		rts				rts
.990f					_ETVariable:
.990f	4c 69 99	jmp $9969			jmp 	VariableHandler
.9912					_ETPuncUnary:
.9912	c8		iny				iny 								; consume the unary character
.9913	c9 2d		cmp #$2d			cmp 	#KWD_MINUS 					; unary minus
.9915	f0 2d		beq $9944			beq 	_ETUnaryNegate
.9917	c9 10		cmp #$10			cmp 	#KWD_AT 					; @ reference -> constant
.9919	f0 39		beq $9954			beq 	_ETDereference
.991b	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; parenthesis
.991d	f0 43		beq $9962			beq 	_ETParenthesis
.991f	64 36		stz $36				stz 	zTemp0 						; zTemp0 is the indirection level.
.9921	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; byte indirection (0) ?
.9923	f0 06		beq $992b			beq 	_ETIndirection
.9925	e6 36		inc $36				inc 	zTemp0
.9927	c9 21		cmp #$21			cmp 	#KWD_PLING					; word indirection (1) \
.9929	d0 a0		bne $98cb			bne 	_ETSyntaxError
.992b					_ETIndirection:
.992b	a5 36		lda $36				lda 	zTemp0 						; push indirection amount (0-1) => (1-2) on the stack
.992d	1a		inc a				inc 	a
.992e	48		pha				pha
.992f	20 98 98	jsr $9898			jsr 	EvaluateTerm				; evaluate the term
.9932	20 dc 96	jsr $96dc			jsr 	Dereference 				; dereference it.
.9935	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a +ve integer.
.9938	d0 07		bne $9941			bne 	_ETTypeMismatch
.993a	68		pla				pla 								; indirection 1-2
.993b	09 20		ora #$20			ora 	#NSBIsReference 			; make it a reference.
.993d	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9940	60		rts				rts
.9941					_ETTypeMismatch:
.9941	4c 66 a0	jmp $a066			jmp 	TypeError
.9944					_ETUnaryNegate:
.9944	20 98 98	jsr $9898			jsr 	EvaluateTerm				; evaluate the term
.9947	20 dc 96	jsr $96dc			jsr 	Dereference 				; dereference it.
.994a	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a number
.994d	29 10		and #$10			and 	#NSTString
.994f	d0 f0		bne $9941			bne 	_ETTypeMismatch
.9951	4c 7e 9e	jmp $9e7e			jmp 	NSMNegate  					; just toggles the sign bit.
.9954					_ETDereference:
.9954	20 98 98	jsr $9898			jsr 	EvaluateTerm				; evaluate the term
.9957	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a reference
.995a	29 20		and #$20			and 	#NSBIsReference
.995c	f0 e3		beq $9941			beq 	_ETTypeMismatch
.995e	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; make it an integer address
.9961	60		rts				rts
.9962					_ETParenthesis:
.9962	20 be 93	jsr $93be			jsr 	EvaluateExpression 			; evaluate here, from lowest precedence
.9965	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket 			; check for )
.9968	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/variable.asm

.9969					VariableHandler:
.9969	b1 30		lda ($30),y			lda 	(codePtr),y
.996b	18		clc				clc
.996c	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.996e	85 37		sta $37				sta 	zTemp0+1
.9970	c8		iny				iny
.9971	b1 30		lda ($30),y			lda 	(codePtr),y
.9973	85 36		sta $36				sta 	zTemp0
.9975	c8		iny				iny
.9976	18		clc				clc									; copy variable address+3 to mantissa
.9977	69 03		adc #$03			adc 	#3
.9979	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.997c	a5 37		lda $37				lda 	zTemp0+1
.997e	69 00		adc #$00			adc 	#0
.9980	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9983	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.9986	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.9989	9e 28 04	stz $0428,x			stz 	NSExponent,x
.998c	5a		phy				phy
.998d	a0 02		ldy #$02			ldy 	#2 							; read type
.998f	b1 36		lda ($36),y			lda 	(zTemp0),y
.9991	7a		ply				ply
.9992	29 1c		and #$1c			and 	#NSBTypeMask+NSBIsArray 	; get type information
.9994	09 20		ora #$20			ora 	#NSBIsReference 			; make a reference.
.9996	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9999	29 04		and #$04			and 	#NSBIsArray
.999b	d0 01		bne $999e			bne 	_VHArray
.999d	60		rts				rts
.999e					_VHArray:
.999e	e8		inx				inx
.999f	20 53 9e	jsr $9e53			jsr 	Evaluate8BitInteger 		; get the 1st index.
.99a2	a9 ff		lda #$ff			lda 	#$FF 						; set Status of X+2 to a duff value so we know if we picked it up.
.99a4	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.99a7	b1 30		lda ($30),y			lda 	(codePtr),y
.99a9	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.99ab	d0 06		bne $99b3			bne 	_VHNoSecondIndex
.99ad	c8		iny				iny 								; skip the comma
.99ae	e8		inx				inx
.99af	20 53 9e	jsr $9e53			jsr 	Evaluate8BitInteger 		; get the 2nd index.
.99b2	ca		dex				dex
.99b3					_VHNoSecondIndex:
.99b3	ca		dex				dex 								; set X back.
.99b4	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket 			; and check the right bracket.
.99b7	5a		phy				phy 								; save position
.99b8	a0 02		ldy #$02			ldy 	#2 							; check first index is not-zero, e.g. array defined
.99ba	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99bc	f0 6b		beq $9a29			beq 	_VHBadIndex
.99be	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy record address to zaTemp
.99c1	85 3e		sta $3e				sta 	zaTemp
.99c3	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.99c6	85 3f		sta $3f				sta 	zaTemp+1
.99c8	a0 03		ldy #$03			ldy 	#3 							; get the second index - which is 0 if there is one index.
.99ca	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99cc	f0 02		beq $99d0			beq 	_VHHas2Mask
.99ce	a9 ff		lda #$ff			lda 	#$FF
.99d0					_VHHas2Mask:
.99d0	dd 02 04	cmp $0402,x			cmp 	NSStatus+2,x 				; so if they are the same there are the wrong number of indices
.99d3	f0 54		beq $9a29			beq 	_VHBadIndex
.99d5	0a		asl a				asl 	a 							; carry will be set if a second index
.99d6	90 09		bcc $99e1			bcc 	_VHCheckFirstIndex
.99d8	a0 03		ldy #$03			ldy 	#3 			 				; check the 2nd size >= 2nd index
.99da	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99dc	dd 0a 04	cmp $040a,x			cmp 	NSMantissa0+2,x
.99df	90 48		bcc $9a29			bcc 	_VHBadIndex
.99e1					_VHCheckFirstIndex:
.99e1	a0 02		ldy #$02			ldy 	#2 			 				; check the 2nd size >= 2nd index
.99e3	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99e5	dd 09 04	cmp $0409,x			cmp 	NSMantissa0+1,x
.99e8	90 3f		bcc $9a29			bcc 	_VHBadIndex
.99ea	64 36		stz $36				stz 	zTemp0 						; clear zTemp0 (if 1 index)
.99ec	64 37		stz $37				stz 	zTemp0+1
.99ee	bd 02 04	lda $0402,x			lda 	NSStatus+2,x 				; if only one index provided, don't need to multiply
.99f1	30 0f		bmi $9a02			bmi 	_VHNoMultiply
.99f3	da		phx				phx
.99f4	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; get 2nd index on stack
.99f7	48		pha				pha
.99f8	a0 02		ldy #$02			ldy 	#2 							; get 1st size in A
.99fa	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99fc	1a		inc a				inc 	a 							; add 1 for zero base
.99fd	fa		plx				plx
.99fe	20 67 9e	jsr $9e67			jsr 	Multiply8x8 				; calculate -> Z0
.9a01	fa		plx				plx
.9a02					_VHNoMultiply:
.9a02	18		clc				clc
.9a03	a5 36		lda $36				lda 	zTemp0
.9a05	7d 09 04	adc $0409,x			adc 	NSMantissa0+1,x
.9a08	85 36		sta $36				sta 	zTemp0
.9a0a	a5 37		lda $37				lda 	zTemp0+1
.9a0c	69 00		adc #$00			adc 	#0
.9a0e	85 37		sta $37				sta 	zTemp0+1
.9a10	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9a13	20 07 85	jsr $8507			jsr 	ScaleByBaseType
.9a16	18		clc				clc
.9a17	b2 3e		lda ($3e)			lda 	(zaTemp)
.9a19	65 36		adc $36				adc 	zTemp0
.9a1b	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9a1e	a0 01		ldy #$01			ldy 	#1
.9a20	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9a22	65 37		adc $37				adc 	zTemp0+1
.9a24	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9a27	7a		ply				ply 								; restore position
.9a28	60		rts				rts
.9a29					_VHBadIndex:
.9a29	a9 17		lda #$17		lda	#23
.9a2b	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/abs.asm

.9a2e					AbsUnary:
.9a2e	fa		plx				plx 								; restore stack pos
.9a2f	20 fb 9d	jsr $9dfb			jsr 	EvaluateNumber 				; get a float or int
.9a32	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket
.9a35	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; clear the sign bit
.9a38	29 7f		and #$7f			and 	#$7F
.9a3a	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9a3d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/alloc.asm

.9a3e					AllocUnary:
.9a3e	fa		plx				plx 								; restore stack pos
.9a3f	20 33 9e	jsr $9e33			jsr 	Evaluate16BitInteger		; get bytes required.
.9a42	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket
.9a45	da		phx				phx 								; save X/Y
.9a46	5a		phy				phy
.9a47	8a		txa				txa 								; copy X into Y
.9a48	a8		tay				tay
.9a49	b9 10 04	lda $0410,y			lda		NSMantissa1,y 				; get size
.9a4c	aa		tax				tax
.9a4d	b9 08 04	lda $0408,y			lda 	NSMantissa0,y
.9a50	20 5d 9a	jsr $9a5d			jsr 	AllocateXABytes 			; allocate memory
.9a53	99 08 04	sta $0408,y			sta 	NSMantissa0,y 				; write address out.
.9a56	8a		txa				txa
.9a57	99 10 04	sta $0410,y			sta 	NSMantissa1,y
.9a5a	7a		ply				ply
.9a5b	fa		plx				plx
.9a5c	60		rts				rts
.9a5d					AllocateXABytes:
.9a5d	5a		phy				phy
.9a5e	ac 8c 04	ldy $048c			ldy 	lowMemPtr 					; push current address on stack and to zTemp0
.9a61	84 36		sty $36				sty 	zTemp0
.9a63	5a		phy				phy
.9a64	ac 8d 04	ldy $048d			ldy 	lowMemPtr+1
.9a67	84 37		sty $37				sty 	zTemp0+1
.9a69	5a		phy				phy
.9a6a	18		clc				clc 								; add to low memory pointer
.9a6b	6d 8c 04	adc $048c			adc 	lowMemPtr
.9a6e	8d 8c 04	sta $048c			sta 	lowMemPtr
.9a71	8a		txa				txa
.9a72	6d 8d 04	adc $048d			adc 	lowMemPtr+1
.9a75	8d 8d 04	sta $048d			sta 	lowMemPtr+1
.9a78	b0 2f		bcs $9aa9			bcs 	CISSMemory
.9a7a	20 9b 9a	jsr $9a9b			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.9a7d					_ClearMemory:
.9a7d	ad 8c 04	lda $048c			lda 	lowMemPtr 					; cleared all memory allocated
.9a80	c5 36		cmp $36				cmp 	zTemp0
.9a82	d0 07		bne $9a8b			bne 	_CMClearNext
.9a84	ad 8d 04	lda $048d			lda 	lowMemPtr+1
.9a87	c5 37		cmp $37				cmp 	zTemp0+1
.9a89	f0 0c		beq $9a97			beq 	_CMExit
.9a8b					_CMClearNext:
.9a8b	a9 00		lda #$00			lda 	#0 							; clear byte, advance to next.
.9a8d	92 36		sta ($36)			sta 	(zTemp0)
.9a8f	e6 36		inc $36				inc 	zTemp0
.9a91	d0 ea		bne $9a7d			bne 	_ClearMemory
.9a93	e6 37		inc $37				inc		zTemp0+1
.9a95	80 e6		bra $9a7d			bra 	_ClearMemory
.9a97					_CMExit:
.9a97	fa		plx				plx
.9a98	68		pla				pla
.9a99	7a		ply				ply
.9a9a	60		rts				rts
.9a9b					CheckIdentifierStringSpace:
.9a9b	48		pha				pha
.9a9c	ad 8d 04	lda $048d			lda 	lowMemPtr+1 				; get low memory pointer
.9a9f	18		clc				clc
.9aa0	69 02		adc #$02			adc 	#2 							; need at least 2 256 byte pages
.9aa2	cd 8f 04	cmp $048f			cmp 	StringMemory+1 				; is it >= StringMemory
.9aa5	b0 02		bcs $9aa9			bcs 	CISSMemory
.9aa7	68		pla				pla
.9aa8	60		rts				rts
.9aa9					CISSMemory:
.9aa9	a9 06		lda #$06		lda	#6
.9aab	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/asc.asm

.9aae					AscUnary:
.9aae	fa		plx				plx 								; restore stack pos
.9aaf	20 06 9e	jsr $9e06			jsr 	EvaluateString 				; get a string
.9ab2	b2 36		lda ($36)			lda 	(zTemp0)					; get/return first character
.9ab4	20 d4 9e	jsr $9ed4			jsr 	NSMSetByte 					; ASC("") will return zero.
.9ab7	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket
.9aba	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/frac.asm

.9abb					FracUnary:
.9abb	fa		plx				plx 								; restore stack pos
.9abc	20 fb 9d	jsr $9dfb			jsr 	EvaluateNumber 				; get a float or int
.9abf	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket
.9ac2	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9ac5	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9ac7	f0 04		beq $9acd			beq 	_IUZero
.9ac9	20 f1 94	jsr $94f1			jsr 	FloatFractionalPart
.9acc	60		rts				rts
.9acd					_IUZero:
.9acd	20 d2 9e	jsr $9ed2			jsr 	NSMSetZero
.9ad0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/int.asm

.9ad1					IntUnary:
.9ad1	fa		plx				plx 								; restore stack pos
.9ad2	20 fb 9d	jsr $9dfb			jsr 	EvaluateNumber 				; get a float or int
.9ad5	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket
.9ad8	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9adb	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9add	f0 03		beq $9ae2			beq 	_IUExit
.9adf	20 54 95	jsr $9554			jsr 	FloatIntegerPart
.9ae2					_IUExit:
.9ae2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/len.asm

.9ae3					LenUnary:
.9ae3	fa		plx				plx 								; restore stack pos
.9ae4	20 06 9e	jsr $9e06			jsr 	EvaluateString 				; get a string
.9ae7	5a		phy				phy
.9ae8	a0 00		ldy #$00			ldy 	#0 							; find length
.9aea					_LenFind:
.9aea	b1 36		lda ($36),y			lda 	(zTemp0),y 					; look for trailing NULL.
.9aec	f0 06		beq $9af4			beq 	_LenExit
.9aee	c8		iny				iny
.9aef	d0 f9		bne $9aea			bne 	_LenFind
.9af1	4c 61 a0	jmp $a061			jmp 	RangeError 					; string > 255 - no trailing NULL.
.9af4					_LenExit:
.9af4	98		tya				tya		 							; return length
.9af5	20 d4 9e	jsr $9ed4			jsr 	NSMSetByte
.9af8	7a		ply				ply
.9af9	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket
.9afc	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/minmax.asm

.9afd					Unary_Min:
.9afd	a9 01		lda #$01			lda 	#1
.9aff	80 02		bra $9b03			bra 	UnaryMinMaxMain
.9b01					Unary_Max:
.9b01	a9 ff		lda #$ff			lda 	#$FF 						; value from comparator to cause a write
.9b03					UnaryMinMaxMain:
.9b03	fa		plx				plx 								; get index on number stack
.9b04	48		pha				pha 								; save comparator
.9b05	20 f2 9d	jsr $9df2			jsr 	EvaluateValue 				; get the first value.
.9b08					_UMMMLoop:
.9b08	b1 30		lda ($30),y			lda 	(codePtr),y
.9b0a	c9 29		cmp #$29			cmp 	#KWD_RPAREN 				; if right bracket then done.
.9b0c	f0 22		beq $9b30			beq 	_UMMMDone
.9b0e	20 fa 8d	jsr $8dfa			jsr 	CheckComma 					; must be a comma
.9b11	e8		inx				inx
.9b12	20 f2 9d	jsr $9df2			jsr 	EvaluateValue
.9b15	ca		dex				dex
.9b16	20 a9 9e	jsr $9ea9			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] (Compare is destructive)
.9b19	e8		inx				inx
.9b1a	20 a9 9e	jsr $9ea9			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2], original
.9b1d	e8		inx				inx
.9b1e	20 c3 8e	jsr $8ec3			jsr 	CompareBaseCode 			; part of > = < etc. code, returns 255,0 or 1
.9b21	ca		dex				dex
.9b22	ca		dex				dex
.9b23	85 36		sta $36				sta 	zTemp0 						; save required result
.9b25	68		pla				pla 								; get and save comparator
.9b26	48		pha				pha
.9b27	c5 36		cmp $36				cmp 	zTemp0 						; if the comparator
.9b29	d0 dd		bne $9b08			bne 	_UMMMLoop
.9b2b	20 33 9b	jsr $9b33			jsr 	ExpCopyAboveDown 			; copy next up slot down
.9b2e	80 d8		bra $9b08			bra 	_UMMMLoop
.9b30					_UMMMDone:
.9b30	68		pla				pla 								; throw the comparator
.9b31	c8		iny				iny 								; skip )
.9b32	60		rts				rts
.9b33					ExpCopyAboveDown:
.9b33	bd 01 04	lda $0401,x			lda 	NSStatus+1,x
.9b36	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9b39	bd 29 04	lda $0429,x			lda 	NSExponent+1,x
.9b3c	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9b3f	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.9b42	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9b45	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.9b48	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9b4b	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.9b4e	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9b51	bd 21 04	lda $0421,x			lda 	NSMantissa3+1,x
.9b54	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9b57	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/not.asm

.9b58					Unary_Not:
.9b58	fa		plx				plx
.9b59	20 1e 9e	jsr $9e1e			jsr 	EvaluateInteger 			; get integer
.9b5c	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket
.9b5f	20 02 9f	jsr $9f02			jsr 	NSMIsZero 					; zero mantissa ?
.9b62	f0 04		beq $9b68			beq 	_NotZero
.9b64	20 d2 9e	jsr $9ed2			jsr 	NSMSetZero
.9b67	60		rts				rts
.9b68					_NotZero:
.9b68	4c 78 8e	jmp $8e78			jmp 	ReturnTrue
.9b6b					_UNBad:
.9b6b	4c 6b a0	jmp $a06b			jmp 	ArgumentError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/rnd.asm

.9b6e					Unary_Random:
.9b6e	fa		plx				plx
.9b6f	20 ed 9b	jsr $9bed			jsr 	Random32Bit 				; get a random number
.9b72	20 d2 9b	jsr $9bd2			jsr 	URCopyToMantissa  			; put in mantissa
.9b75	b1 30		lda ($30),y			lda 	(codePtr),y
.9b77	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.9b79	f0 08		beq $9b83			beq 	_URNoModulus
.9b7b	e8		inx				inx
.9b7c	20 33 9e	jsr $9e33			jsr 	Evaluate16BitInteger 		; put modulus value in +1
.9b7f	ca		dex				dex
.9b80	20 eb 8f	jsr $8feb			jsr 	IntegerModulusNoCheck 		; calculate modulus
.9b83					_URNoModulus:
.9b83	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; make it an integer positive
.9b86	9e 28 04	stz $0428,x			stz 	NSExponent,x
.9b89	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket
.9b8c	60		rts				rts
.9b8d					Unary_Rnd:
.9b8d	fa		plx				plx
.9b8e	20 fb 9d	jsr $9dfb			jsr 	EvaluateNumber 				; number to use.
.9b91	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket 			; closing bracket
.9b94	20 02 9f	jsr $9f02			jsr 	NSMIsZero 					; if zero, then don't generate a new number
.9b97	f0 2b		beq $9bc4			beq 	_URCopySeed
.9b99	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; if -ve, then seed using parameter
.9b9c	10 23		bpl $9bc1			bpl 	_URDontSeed
.9b9e	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy - value to seed butchering it.
.9ba1	49 17		eor #$17			eor 	#$17
.9ba3	8d 88 04	sta $0488			sta 	RandomSeed+0
.9ba6	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9ba9	49 a5		eor #$a5			eor 	#$A5
.9bab	8d 89 04	sta $0489			sta 	RandomSeed+1
.9bae	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9bb1	49 c2		eor #$c2			eor 	#$C2
.9bb3	8d 8a 04	sta $048a			sta 	RandomSeed+2
.9bb6	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9bb9	49 9d		eor #$9d			eor 	#$9D
.9bbb	8d 8b 04	sta $048b			sta 	RandomSeed+3
.9bbe	20 ed 9b	jsr $9bed			jsr 	Random32Bit
.9bc1					_URDontSeed:
.9bc1	20 ed 9b	jsr $9bed			jsr 	Random32Bit 				; generate a number.
.9bc4					_URCopySeed:
.9bc4	20 d2 9b	jsr $9bd2			jsr 	URCopyToMantissa 			; copy into mantissa
.9bc7	a9 e2		lda #$e2			lda 	#-30 						; force into 0-1 range
.9bc9	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9bcc	a9 08		lda #$08			lda 	#NSTFloat
.9bce	9d 00 04	sta $0400,x			sta 	NSStatus,x 					; positive.
.9bd1	60		rts				rts
.9bd2					URCopyToMantissa:
.9bd2	ad 88 04	lda $0488			lda 	RandomSeed+0
.9bd5	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9bd8	ad 89 04	lda $0489			lda 	RandomSeed+1
.9bdb	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9bde	ad 8a 04	lda $048a			lda 	RandomSeed+2
.9be1	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9be4	ad 8b 04	lda $048b			lda 	RandomSeed+3
.9be7	29 3f		and #$3f			and 	#$3F 						; make legal mantissa
.9be9	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9bec	60		rts				rts
.9bed					Random32Bit:
.9bed	5a		phy				phy
.9bee	a0 07		ldy #$07			ldy 	#7 							; do it 7 times
.9bf0	ad 88 04	lda $0488			lda 	RandomSeed+0 				; check the seed isn't zero
.9bf3	d0 03		bne $9bf8			bne 	_Random1
.9bf5	a8		tay				tay 								; if so do it 256 times
.9bf6	a9 aa		lda #$aa			lda		#$AA 						; and use this to seed the seed....
.9bf8					_Random1:
.9bf8	0a		asl a				asl 	a 							; LSFR RNG
.9bf9	2e 89 04	rol $0489			rol 	RandomSeed+1
.9bfc	2e 8a 04	rol $048a			rol 	RandomSeed+2
.9bff	2e 8b 04	rol $048b			rol 	RandomSeed+3
.9c02	90 02		bcc $9c06			bcc 	_Random2
.9c04	49 c5		eor #$c5			eor 	#$C5
.9c06					_Random2:
.9c06	88		dey				dey
.9c07	d0 ef		bne $9bf8			bne 	_Random1
.9c09	8d 88 04	sta $0488			sta 	RandomSeed+0
.9c0c	7a		ply				ply
.9c0d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/sgn.asm

.9c0e					SgnUnary:
.9c0e	fa		plx				plx 								; restore stack pos
.9c0f	20 fb 9d	jsr $9dfb			jsr 	EvaluateNumber 				; get a float or int
.9c12	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket
.9c15	20 02 9f	jsr $9f02			jsr 	NSMIsZero 					; if zero
.9c18	f0 10		beq $9c2a			beq 	_SGZero  					; return Int Zero
.9c1a	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get status w/sign
.9c1d	48		pha				pha
.9c1e	a9 01		lda #$01			lda 	#1 							; set to 1
.9c20	20 d4 9e	jsr $9ed4			jsr 	NSMSetByte
.9c23	68		pla				pla
.9c24	29 80		and #$80			and		#$80 						; copy the sign byte out
.9c26	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9c29	60		rts				rts
.9c2a	20 d2 9e	jsr $9ed2	_SGZero:jsr 	NSMSetZero
.9c2d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/val.asm

.9c2e					ValUnary:
.9c2e	fa		plx				plx 								; restore stack pos
.9c2f	20 44 9c	jsr $9c44			jsr 	ValMainCode 				; do the main val() code
.9c32	b0 01		bcs $9c35			bcs 	_VUError 					; couldn't convert
.9c34	60		rts				rts
.9c35					_VUError:
.9c35	4c 66 a0	jmp $a066			jmp 	TypeError
.9c38					IsValUnary:
.9c38	fa		plx				plx 								; restore stack pos
.9c39	20 44 9c	jsr $9c44			jsr 	ValMainCode 				; do the main val() code
.9c3c	b0 03		bcs $9c41			bcs 	_VUBad
.9c3e	4c 78 8e	jmp $8e78			jmp 	ReturnTrue
.9c41					_VUBad:
.9c41	4c 84 8e	jmp $8e84			jmp 	ReturnFalse
.9c44					ValMainCode:
.9c44	20 06 9e	jsr $9e06			jsr 	EvaluateString 				; get a string
.9c47	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket 			; check right bracket present
.9c4a					ValEvaluateZTemp0:
.9c4a	5a		phy				phy
.9c4b	b2 36		lda ($36)			lda 	(zTemp0) 					; check not empty string
.9c4d	f0 17		beq $9c66			beq 	_VMCFail2
.9c4f	a0 ff		ldy #$ff			ldy 	#$FF 						; start position
.9c51	48		pha				pha 								; save first character
.9c52	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it -
.9c54	d0 01		bne $9c57			bne 	_VMCStart
.9c56	c8		iny				iny 								; skip over -
.9c57					_VMCStart:
.9c57	38		sec				sec 								; initialise first time round.
.9c58					_VMCNext:
.9c58	c8		iny				iny 								; pre-increment
.9c59	b1 36		lda ($36),y			lda 	(zTemp0),y 					; next character
.9c5b	f0 0c		beq $9c69			beq 	_VMCSuccess 				; successful.
.9c5d	20 7a 97	jsr $977a			jsr 	EncodeNumber 				; send it to the number-builder
.9c60	90 03		bcc $9c65			bcc 	_VMCFail 					; if failed, give up.
.9c62	18		clc				clc 								; next time round, countinue
.9c63	80 f3		bra $9c58			bra 	_VMCNext
.9c65					_VMCFail:
.9c65	68		pla				pla
.9c66					_VMCFail2:
.9c66	7a		ply				ply
.9c67	38		sec				sec
.9c68	60		rts				rts
.9c69					_VMCSuccess:
.9c69	a9 00		lda #$00			lda 	#0 							; construct final
.9c6b	20 7a 97	jsr $977a			jsr 	EncodeNumber
.9c6e	68		pla				pla
.9c6f	c9 2d		cmp #$2d			cmp 	#"-"
.9c71	d0 03		bne $9c76			bne 	_VMCNotNegative
.9c73	20 7e 9e	jsr $9e7e			jsr		NSMNegate
.9c76					_VMCNotNegative:
.9c76	7a		ply				ply
.9c77	18		clc				clc
.9c78	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/chr.asm

.9c79					ChrUnary:
.9c79	fa		plx				plx 								; restore stack pos
.9c7a	20 53 9e	jsr $9e53			jsr 	Evaluate8BitInteger			; get value
.9c7d	48		pha				pha
.9c7e	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket
.9c81	a9 01		lda #$01			lda 	#1 							; allocate space for one char
.9c83	20 44 a8	jsr $a844			jsr 	StringTempAllocate
.9c86	68		pla				pla 								; write number to it
.9c87	20 82 a8	jsr $a882			jsr 	StringTempWrite
.9c8a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/spc.asm

.9c8b					SpcUnary:
.9c8b	fa		plx				plx 								; restore stack pos
.9c8c	20 53 9e	jsr $9e53			jsr 	Evaluate8BitInteger			; get value
.9c8f	5a		phy				phy
.9c90	48		pha				pha 								; save count
.9c91	20 44 a8	jsr $a844			jsr 	StringTempAllocate
.9c94	7a		ply				ply 								; to do count in Y
.9c95					_SpcLoop:
.9c95	c0 00		cpy #$00			cpy 	#0
.9c97	f0 08		beq $9ca1			beq 	_SpcExit
.9c99	a9 20		lda #$20			lda 	#32
.9c9b	20 82 a8	jsr $a882			jsr 	StringTempWrite
.9c9e	88		dey				dey
.9c9f	80 f4		bra $9c95			bra 	_SPCLoop
.9ca1					_SpcExit:
.9ca1	7a		ply				ply
.9ca2	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket
.9ca5	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/str.asm

.9ca6					Unary_Str:
.9ca6	fa		plx				plx
.9ca7	20 fb 9d	jsr $9dfb			jsr 	EvaluateNumber  			; get number
.9caa	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket 			; closing bracket
.9cad	a9 05		lda #$05			lda 	#5 							; maximum decimals, from Basic816
.9caf	20 c8 9c	jsr $9cc8			jsr 	ConvertNumberToString 		; do the conversion.
.9cb2	a9 21		lda #$21			lda		#33 						; create buffer
.9cb4	20 44 a8	jsr $a844			jsr 	StringTempAllocate 			; allocate memory
.9cb7	da		phx				phx
.9cb8	a2 00		ldx #$00			ldx 	#0
.9cba					_USCopy:
.9cba	bd 1d 06	lda $061d,x			lda 	DecimalBuffer,x
.9cbd	20 82 a8	jsr $a882			jsr 	StringTempWrite
.9cc0	e8		inx				inx
.9cc1	bd 1d 06	lda $061d,x			lda 	DecimalBuffer,x
.9cc4	d0 f4		bne $9cba			bne 	_USCopy
.9cc6	fa		plx				plx
.9cc7	60		rts				rts
.9cc8					ConvertNumberToString:
.9cc8	5a		phy				phy 								; save code position
.9cc9	8d 94 04	sta $0494			sta 	DecimalPlaces	 			; save number of DPs.
.9ccc	9c 95 04	stz $0495			stz 	dbOffset 					; offset into decimal buffer = start.
.9ccf	bd 00 04	lda $0400,x			lda 	NSStatus,x  				; is it -ve.
.9cd2	10 0a		bpl $9cde			bpl 	_CNTSNotNegative
.9cd4	29 7f		and #$7f			and 	#$7F 						; make +ve
.9cd6	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9cd9	a9 2d		lda #$2d			lda 	#"-"
.9cdb	20 44 9d	jsr $9d44			jsr 	WriteDecimalBuffer
.9cde					_CNTSNotNegative:
.9cde	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if decimal
.9ce1	f0 15		beq $9cf8			beq 	_CNTSNotFloat
.9ce3	e8		inx				inx 								; round up
.9ce4	a9 01		lda #$01			lda 	#1
.9ce6	20 d4 9e	jsr $9ed4			jsr 	NSMSetByte
.9ce9	ca		dex				dex
.9cea	bd 28 04	lda $0428,x			lda		NSExponent,x
.9ced	9d 29 04	sta $0429,x			sta 	NSExponent+1,x
.9cf0	a9 08		lda #$08			lda 	#NSTFloat
.9cf2	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.9cf5	20 0b 94	jsr $940b			jsr 	FloatAdd
.9cf8					_CNTSNotFloat:
.9cf8	20 26 9d	jsr $9d26			jsr 	MakePlusTwoString
.9cfb	20 f1 94	jsr $94f1			jsr 	FloatFractionalPart 		; get the fractional part
.9cfe	20 b5 95	jsr $95b5			jsr 	NSNormalise					; normalise , exit if zero
.9d01	f0 21		beq $9d24			beq 	_CNTSExit
.9d03	a9 2e		lda #$2e			lda 	#"."
.9d05	20 44 9d	jsr $9d44			jsr 	WriteDecimalBuffer 			; write decimal place
.9d08					_CNTSDecimal:
.9d08	ce 94 04	dec $0494			dec 	DecimalPlaces 				; done all the decimals
.9d0b	30 17		bmi $9d24			bmi 	_CNTSExit
.9d0d	e8		inx				inx 								; x 10.0
.9d0e	a9 0a		lda #$0a			lda 	#10
.9d10	20 d4 9e	jsr $9ed4			jsr 	NSMSetByte
.9d13	a9 08		lda #$08			lda 	#NSTFloat
.9d15	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9d18	ca		dex				dex
.9d19	20 7e 95	jsr $957e			jsr 	FloatMultiply
.9d1c	20 26 9d	jsr $9d26			jsr 	MakePlusTwoString
.9d1f	20 f1 94	jsr $94f1			jsr 	FloatFractionalPart 		; get the fractional part
.9d22	80 e4		bra $9d08			bra 	_CNTSDecimal 				; keep going.
.9d24					_CNTSExit:
.9d24	7a		ply				ply
.9d25	60		rts				rts
.9d26					MakePlusTwoString:
.9d26	da		phx				phx
.9d27	20 a9 9e	jsr $9ea9			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.9d2a	e8		inx				inx 								; access it
.9d2b	e8		inx				inx
.9d2c	20 54 95	jsr $9554			jsr 	FloatIntegerPart 			; make it an integer
.9d2f	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.9d31	20 36 93	jsr $9336			jsr 	ConvertInt32
.9d34	a2 00		ldx #$00			ldx	 	#0
.9d36					_MPTSCopy:
.9d36	bd fb 05	lda $05fb,x			lda 	NumberBuffer,x
.9d39	20 44 9d	jsr $9d44			jsr 	WriteDecimalBuffer
.9d3c	e8		inx				inx
.9d3d	bd fb 05	lda $05fb,x			lda 	NumberBuffer,x
.9d40	d0 f4		bne $9d36			bne 	_MPTSCopy
.9d42	fa		plx				plx
.9d43	60		rts				rts
.9d44					WriteDecimalBuffer:
.9d44	da		phx				phx
.9d45	ae 95 04	ldx $0495			ldx 	dbOffset
.9d48	9d 1d 06	sta $061d,x			sta 	DecimalBuffer,x
.9d4b	9e 1e 06	stz $061e,x			stz 	DecimalBuffer+1,x
.9d4e	ee 95 04	inc $0495			inc 	dbOffset
.9d51	fa		plx				plx
.9d52	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/substring.asm

.9d53					Unary_Left:
.9d53	fa		plx				plx
.9d54	18		clc				clc 								; only one parameter
.9d55	20 ca 9d	jsr $9dca			jsr 	SubstringInitial 			; set up.
.9d58	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; Param #1 is the length
.9d5b	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9d5e	9e 09 04	stz $0409,x			stz 	NSMantissa0+1,x 			; Start is zero.
.9d61	80 2c		bra $9d8f			bra 	SubstringMain
.9d63					Unary_Right:
.9d63	fa		plx				plx
.9d64	18		clc				clc 								; only one parameter
.9d65	20 ca 9d	jsr $9dca			jsr 	SubstringInitial 			; set up.
.9d68	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; length => param 2
.9d6b	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9d6e	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; total length
.9d71	fd 09 04	sbc $0409,x			sbc 	NSMantissa0+1,x 			; length - required.
.9d74	b0 02		bcs $9d78			bcs 	_URNotUnderflow
.9d76	a9 00		lda #$00			lda 	#0 							; start from the beginning, as something like right$("AB",3)
.9d78					_URNotUnderFlow:
.9d78	9d 09 04	sta $0409,x			sta 	NSMantissa0+1,x 			; this is the start position
.9d7b	80 12		bra $9d8f			bra 	SubStringMain
.9d7d					Unary_Mid:
.9d7d	fa		plx				plx
.9d7e	38		sec				sec 								; two parameters
.9d7f	20 ca 9d	jsr $9dca			jsr 	SubstringInitial 			; set up.
.9d82	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; first parameter is zero ?
.9d85	f0 05		beq $9d8c			beq 	_UMError
.9d87	de 09 04	dec $0409,x			dec 	NSMantissa0+1,x				; reduce initial offset by 1 as MID$(a$,1..) is actually the first character
.9d8a	80 03		bra $9d8f			bra 	SubStringMain
.9d8c					_UMError:
.9d8c	4c 6b a0	jmp $a06b			jmp 	ArgumentError
.9d8f					SubStringMain:
.9d8f	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; is the initial offset >= the length
.9d92	dd 28 04	cmp $0428,x			cmp 	NSExponent,x
.9d95	b0 2d		bcs $9dc4			bcs 	_SSMNull 					; if so, return an empty string.
.9d97	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; if copy count is zero
.9d9a	f0 28		beq $9dc4			beq 	_SSMNull 					; return empty string.
.9d9c	18		clc				clc 								; add the offset +1 to the address and
.9d9d	bd 08 04	lda $0408,x			lda	 	NSMantissa0,x 				; put in zTemp
.9da0	7d 09 04	adc $0409,x			adc 	NSMantissa0+1,x
.9da3	85 36		sta $36				sta 	zTemp0
.9da5	bd 10 04	lda $0410,x			lda	 	NSMantissa1,x
.9da8	69 00		adc #$00			adc 	#0
.9daa	85 37		sta $37				sta 	zTemp0+1
.9dac					_SSMNoCarry:
.9dac	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; characters required.
.9daf	20 44 a8	jsr $a844			jsr 	StringTempAllocate 			; allocate that many characters
.9db2	5a		phy				phy 								; save Y
.9db3	a0 00		ldy #$00			ldy 	#0 							; start copying in.
.9db5					_SSMCopy:
.9db5	b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next character
.9db7	f0 09		beq $9dc2			beq 	_SSMEString 				; no more to copy
.9db9	20 82 a8	jsr $a882			jsr 	StringTempWrite 			; and write it out.
.9dbc	c8		iny				iny
.9dbd	de 0a 04	dec $040a,x			dec 	NSMantissa0+2,x
.9dc0	d0 f3		bne $9db5			bne 	_SSMCopy
.9dc2					_SSMEString:
.9dc2	7a		ply				ply
.9dc3					_SSMExit:
.9dc3	60		rts				rts
.9dc4					_SSMNull:
.9dc4	a9 00		lda #$00			lda 	#0
.9dc6	20 44 a8	jsr $a844			jsr 	StringTempAllocate
.9dc9	60		rts				rts
.9dca					SubstringInitial:
.9dca	da		phx				phx 								; save initial stack position
.9dcb	08		php				php 								; save carry on stack indicating 2 parameters
.9dcc	20 06 9e	jsr $9e06			jsr 	EvaluateString 				; get a string
.9dcf	5a		phy				phy 								; calculate length to exponent.
.9dd0	a0 ff		ldy #$ff			ldy 	#$FF
.9dd2					_SIFindLength:
.9dd2	c8		iny				iny
.9dd3	b1 36		lda ($36),y			lda 	(zTemp0),y
.9dd5	d0 fb		bne $9dd2			bne 	_SIFindLength
.9dd7	98		tya				tya
.9dd8	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9ddb	7a		ply				ply
.9ddc	e8		inx				inx
.9ddd	20 fa 8d	jsr $8dfa			jsr 	CheckComma 					; comma next
.9de0	20 53 9e	jsr $9e53			jsr 	Evaluate8BitInteger 		; get next parameter
.9de3	28		plp				plp 								; is it the last parameter ?
.9de4	90 07		bcc $9ded			bcc 	_SSIExit 					; if so, exit.
.9de6	e8		inx				inx
.9de7	20 fa 8d	jsr $8dfa			jsr 	CheckComma 					; comma next
.9dea	20 53 9e	jsr $9e53			jsr 	Evaluate8BitInteger 		; get last parameter
.9ded					_SSIExit:
.9ded	fa		plx				plx
.9dee	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket 			; check closing bracket
.9df1	60		rts				rts 								; exit

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/exprhelper.asm

.9df2					EvaluateValue:
.9df2	48		pha				pha
.9df3	20 be 93	jsr $93be			jsr		EvaluateExpression 			; expression
.9df6	20 dc 96	jsr $96dc			jsr 	Dereference					; derefernce it
.9df9	68		pla				pla
.9dfa	60		rts				rts
.9dfb					EvaluateNumber:
.9dfb	20 f2 9d	jsr $9df2			jsr 	EvaluateValue 				; get a value
.9dfe	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if string.
.9e01	29 10		and #$10			and 	#NSBIsString
.9e03	d0 16		bne $9e1b			bne 	HelperTypeError
.9e05	60		rts				rts
.9e06					EvaluateString:
.9e06	20 f2 9d	jsr $9df2			jsr 	EvaluateValue 				; get a value
.9e09	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if string.
.9e0c	29 10		and #$10			and 	#NSBIsString
.9e0e	f0 0b		beq $9e1b			beq 	HelperTypeError
.9e10					CopyAddressToTemp0:
.9e10	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address -> zTemp0
.9e13	85 36		sta $36				sta 	zTemp0 						; (so we can do something with it)
.9e15	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9e18	85 37		sta $37				sta 	zTemp0+1
.9e1a	60		rts				rts
.9e1b					HelperTypeError:
.9e1b	4c 66 a0	jmp $a066			jmp 	TypeError
.9e1e					EvaluateInteger:
.9e1e	20 fb 9d	jsr $9dfb			jsr 	EvaluateNumber
.9e21	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check exponent is zero
.9e24	d0 0a		bne $9e30			bne 	HelperValueError 			; if not, it's a float.
.9e26	60		rts				rts
.9e27					EvaluateUnsignedInteger:
.9e27	20 1e 9e	jsr $9e1e			jsr 	EvaluateInteger 			; check integer is +ve
.9e2a	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9e2d	30 01		bmi $9e30			bmi 	HelperValueError
.9e2f	60		rts				rts
.9e30					HelperValueError:
.9e30	4c 6b a0	jmp $a06b			jmp 	ArgumentError
.9e33						Evaluate16BitInteger:
.9e33	20 27 9e	jsr $9e27			jsr	 	EvaluateUnsignedInteger		; get integer
.9e36	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9e39	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9e3c	d0 f2		bne $9e30			bne 	HelperValueError
.9e3e	60		rts				rts
.9e3f					Evaluate16BitIntegerSigned:
.9e3f	20 1e 9e	jsr $9e1e			jsr	 	EvaluateInteger				; get integer
.9e42	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9e45	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9e48	d0 e6		bne $9e30			bne 	HelperValueError
.9e4a	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; signed ?
.9e4d	10 03		bpl $9e52			bpl 	_EISNotSigned
.9e4f	20 87 9e	jsr $9e87			jsr 	NSMNegateMantissa 			; makes it an actual 2's complement value.
.9e52					_EISNotSigned:
.9e52	60		rts				rts
.9e53					Evaluate8BitInteger:
.9e53	20 27 9e	jsr $9e27			jsr	 	EvaluateUnsignedInteger 	; get an integer
.9e56	d0 d8		bne $9e30			bne 	HelperValueError
.9e58	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 1, 2 & 3 must be zero
.9e5b	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9e5e	1d 10 04	ora $0410,x			ora 	NSMantissa1,x
.9e61	d0 cd		bne $9e30			bne 	HelperValueError
.9e63	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9e66	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/mult8x8.asm

.9e67					Multiply8x8:
.9e67	4a		lsr a		  		lsr 	a  							; prime the carry bit for the loop
.9e68	85 36		sta $36			  	sta 	zTemp0
.9e6a	86 37		stx $37				stx 	zTemp0+1
.9e6c	a9 00		lda #$00			lda 	#0
.9e6e	a2 08		ldx #$08			ldx 	#8
.9e70					_M88Loop:
.9e70	90 03		bcc $9e75			bcc 	_M88NoAdd
.9e72	18		clc				clc
.9e73	65 37		adc $37				adc 	zTemp0+1
.9e75					_M88NoAdd:
.9e75	6a		ror a				ror 	a
.9e76	66 36		ror $36				ror 	zTemp0  					; pull another bit out for the next iteration
.9e78	ca		dex				dex         						; inc/dec don't modify carry; only shifts and adds do
.9e79	d0 f5		bne $9e70			bne 	_M88Loop
.9e7b	85 37		sta $37				sta 	zTemp0+1 					; store high 8 bits.
.9e7d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/utility.asm

.9e7e					NSMNegate:
.9e7e	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.9e81	49 80		eor #$80			eor 	#NSBIsNegative  			; toggle the negative flag
.9e83	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9e86	60		rts				rts
.9e87					NSMNegateMantissa:
.9e87	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.9e88	a9 00		lda #$00			lda 	#0
.9e8a	fd 08 04	sbc $0408,x			sbc 	NSMantissa0,x
.9e8d	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9e90	a9 00		lda #$00			lda 	#0
.9e92	fd 10 04	sbc $0410,x			sbc 	NSMantissa1,x
.9e95	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9e98	a9 00		lda #$00			lda 	#0
.9e9a	fd 18 04	sbc $0418,x			sbc 	NSMantissa2,x
.9e9d	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9ea0	a9 00		lda #$00			lda 	#0
.9ea2	fd 20 04	sbc $0420,x			sbc 	NSMantissa3,x
.9ea5	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9ea8	60		rts				rts
.9ea9					NSMShiftUpTwo:
.9ea9	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9eac	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9eaf	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9eb2	9d 12 04	sta $0412,x			sta 	NSMantissa1+2,x
.9eb5	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9eb8	9d 1a 04	sta $041a,x			sta 	NSMantissa2+2,x
.9ebb	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9ebe	9d 22 04	sta $0422,x			sta 	NSMantissa3+2,x
.9ec1	bd 28 04	lda $0428,x			lda 	NSExponent,x
.9ec4	9d 2a 04	sta $042a,x			sta 	NSExponent+2,x
.9ec7	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9eca	9d 02 04	sta $0402,x			sta 	NSStatus+2,x
.9ecd	60		rts				rts
.9ece					NSMSetZeroMantissaOnly:
.9ece	a9 00		lda #$00			lda 	#0
.9ed0	80 08		bra $9eda			bra 	NSMSetMantissa
.9ed2					NSMSetZero:
.9ed2	a9 00		lda #$00			lda 	#0
.9ed4					NSMSetByte:
.9ed4	9e 28 04	stz $0428,x			stz 	NSExponent,x 				; zero exponent, as integer.
.9ed7	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; status zero (integer)
.9eda					NSMSetMantissa:
.9eda	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; mantissa
.9edd	9e 10 04	stz $0410,x			stz 	NSMantissa1,x
.9ee0	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.9ee3	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.9ee6	60		rts				rts
.9ee7					NSMShiftLeft:
.9ee7	18		clc				clc
.9ee8					NSMRotateLeft:
.9ee8	3e 08 04	rol $0408,x			rol 	NSMantissa0,x
.9eeb	3e 10 04	rol $0410,x			rol		NSMantissa1,x
.9eee	3e 18 04	rol $0418,x			rol		NSMantissa2,x
.9ef1	3e 20 04	rol $0420,x			rol		NSMantissa3,x
.9ef4	60		rts				rts
.9ef5					NSMShiftRight:
.9ef5	5e 20 04	lsr $0420,x			lsr 	NSMantissa3,x
.9ef8	7e 18 04	ror $0418,x			ror		NSMantissa2,x
.9efb	7e 10 04	ror $0410,x			ror		NSMantissa1,x
.9efe	7e 08 04	ror $0408,x			ror		NSMantissa0,x
.9f01	60		rts				rts
.9f02					NSMIsZero:
.9f02	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9f05	1d 18 04	ora $0418,x			ora		NSMantissa2,x
.9f08	1d 10 04	ora $0410,x			ora		NSMantissa1,x
.9f0b	1d 08 04	ora $0408,x			ora		NSMantissa0,x
.9f0e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.asm

.bab8					TickHandler:
.bab8	5a		phy				phy 								; need to preserve Y
.bab9	20 5e ba	jsr $ba5e			jsr 	SNDUpdate 					; update sound
.babc	7a		ply				ply
.babd	60		rts				rts
.062f					LastTick:
>062f							.fill 		1

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/asmcore.asm

.9f0f					Assemble_ora:
.9f0f	20 63 80	jsr $8063		jsr	AssembleGroup1
>9f12	01					.byte $01
.9f13					Assemble_and:
.9f13	20 63 80	jsr $8063		jsr	AssembleGroup1
>9f16	21					.byte $21
.9f17					Assemble_eor:
.9f17	20 63 80	jsr $8063		jsr	AssembleGroup1
>9f1a	41					.byte $41
.9f1b					Assemble_adc:
.9f1b	20 63 80	jsr $8063		jsr	AssembleGroup1
>9f1e	61					.byte $61
.9f1f					Assemble_sta:
.9f1f	20 63 80	jsr $8063		jsr	AssembleGroup1
>9f22	81					.byte $81
.9f23					Assemble_lda:
.9f23	20 63 80	jsr $8063		jsr	AssembleGroup1
>9f26	a1					.byte $a1
.9f27					Assemble_cmp:
.9f27	20 63 80	jsr $8063		jsr	AssembleGroup1
>9f2a	c1					.byte $c1
.9f2b					Assemble_sbc:
.9f2b	20 63 80	jsr $8063		jsr	AssembleGroup1
>9f2e	e1					.byte $e1
.9f2f					Assemble_asl:
.9f2f	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9f32	02					.byte $02
>9f33	75					.byte $75
.9f34					Assemble_rol:
.9f34	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9f37	22					.byte $22
>9f38	75					.byte $75
.9f39					Assemble_lsr:
.9f39	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9f3c	42					.byte $42
>9f3d	75					.byte $75
.9f3e					Assemble_ror:
.9f3e	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9f41	62					.byte $62
>9f42	75					.byte $75
.9f43					Assemble_stx:
.9f43	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9f46	82					.byte $82
>9f47	50					.byte $50
.9f48					Assemble_ldx:
.9f48	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9f4b	a2					.byte $a2
>9f4c	d0					.byte $d0
.9f4d					Assemble_dec:
.9f4d	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9f50	c2					.byte $c2
>9f51	55					.byte $55
.9f52					Assemble_inc:
.9f52	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9f55	e2					.byte $e2
>9f56	55					.byte $55
.9f57					Assemble_stz:
.9f57	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9f5a	60					.byte $60
>9f5b	44					.byte $44
.9f5c					Assemble_bit:
.9f5c	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9f5f	20					.byte $20
>9f60	55					.byte $55
.9f61					Assemble_sty:
.9f61	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9f64	80					.byte $80
>9f65	54					.byte $54
.9f66					Assemble_ldy:
.9f66	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9f69	a0					.byte $a0
>9f6a	d5					.byte $d5
.9f6b					Assemble_cpy:
.9f6b	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9f6e	c0					.byte $c0
>9f6f	d4					.byte $d4
.9f70					Assemble_cpx:
.9f70	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9f73	e0					.byte $e0
>9f74	d0					.byte $d0
.9f75					Assemble_tsb:
.9f75	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9f78	00					.byte $00
>9f79	50					.byte $50
.9f7a					Assemble_trb:
.9f7a	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9f7d	10					.byte $10
>9f7e	50					.byte $50
.9f7f					Assemble_jsr:
.9f7f	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9f82	14					.byte $14
>9f83	10					.byte $10
.9f84					Assemble_jmp:
.9f84	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9f87	40					.byte $40
>9f88	10					.byte $10
.9f89					Assemble_bpl:
.9f89	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9f8c	10					.byte $10
.9f8d					Assemble_bmi:
.9f8d	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9f90	30					.byte $30
.9f91					Assemble_bvc:
.9f91	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9f94	50					.byte $50
.9f95					Assemble_bvs:
.9f95	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9f98	70					.byte $70
.9f99					Assemble_bcc:
.9f99	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9f9c	90					.byte $90
.9f9d					Assemble_bcs:
.9f9d	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9fa0	b0					.byte $b0
.9fa1					Assemble_bne:
.9fa1	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9fa4	d0					.byte $d0
.9fa5					Assemble_beq:
.9fa5	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9fa8	f0					.byte $f0
.9fa9					Assemble_bra:
.9fa9	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9fac	80					.byte $80
.9fad					Assemble_brk:
.9fad	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>9fb0	00					.byte $00
.9fb1					Assemble_php:
.9fb1	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>9fb4	08					.byte $08
.9fb5					Assemble_clc:
.9fb5	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>9fb8	18					.byte $18
.9fb9					Assemble_plp:
.9fb9	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>9fbc	28					.byte $28
.9fbd					Assemble_sec:
.9fbd	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>9fc0	38					.byte $38
.9fc1					Assemble_rti:
.9fc1	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>9fc4	40					.byte $40
.9fc5					Assemble_pha:
.9fc5	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>9fc8	48					.byte $48
.9fc9					Assemble_cli:
.9fc9	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>9fcc	58					.byte $58
.9fcd					Assemble_phy:
.9fcd	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>9fd0	5a					.byte $5a
.9fd1					Assemble_rts:
.9fd1	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>9fd4	60					.byte $60
.9fd5					Assemble_pla:
.9fd5	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>9fd8	68					.byte $68
.9fd9					Assemble_sei:
.9fd9	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>9fdc	78					.byte $78
.9fdd					Assemble_ply:
.9fdd	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>9fe0	7a					.byte $7a
.9fe1					Assemble_dey:
.9fe1	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>9fe4	88					.byte $88
.9fe5					Assemble_txa:
.9fe5	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>9fe8	8a					.byte $8a
.9fe9					Assemble_tya:
.9fe9	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>9fec	98					.byte $98
.9fed					Assemble_txs:
.9fed	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>9ff0	9a					.byte $9a
.9ff1					Assemble_tay:
.9ff1	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>9ff4	a8					.byte $a8
.9ff5					Assemble_tax:
.9ff5	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>9ff8	aa					.byte $aa
.9ff9					Assemble_clv:
.9ff9	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>9ffc	b8					.byte $b8
.9ffd					Assemble_tsx:
.9ffd	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>a000	ba					.byte $ba
.a001					Assemble_iny:
.a001	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>a004	c8					.byte $c8
.a005					Assemble_dex:
.a005	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>a008	ca					.byte $ca
.a009					Assemble_cld:
.a009	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>a00c	d8					.byte $d8
.a00d					Assemble_phx:
.a00d	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>a010	da					.byte $da
.a011					Assemble_stp:
.a011	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>a014	db					.byte $db
.a015					Assemble_inx:
.a015	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>a018	e8					.byte $e8
.a019					Assemble_nop:
.a019	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>a01c	ea					.byte $ea
.a01d					Assemble_sed:
.a01d	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>a020	f8					.byte $f8
.a021					Assemble_plx:
.a021	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>a024	fa					.byte $fa

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/constants.asm

.a025					DecimalScalarTable:
>a025	66 66 66 66				.dword $66666666 ; 0.1
>a029	de					.byte $de
>a02a	1f 85 eb 51				.dword $51eb851f ; 0.01
>a02e	db					.byte $db
>a02f	4c 37 89 41				.dword $4189374c ; 0.001
>a033	d8					.byte $d8
>a034	ac 8b db 68				.dword $68db8bac ; 0.0001
>a038	d4					.byte $d4
>a039	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>a03d	d1					.byte $d1
>a03e	83 de 1b 43				.dword $431bde83 ; 1e-06
>a042	ce					.byte $ce
>a043	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>a047	ca					.byte $ca
>a048	89 3b e6 55				.dword $55e63b89 ; 1e-08
>a04c	c7					.byte $c7
>a04d	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>a051	c4					.byte $c4
>a052	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>a056	c0					.byte $c0
>a057	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>a05b	bd					.byte $bd

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.asm

.a05c					SyntaxError:
.a05c	a9 02		lda #$02		lda	#2
.a05e	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler
.a061					RangeError:
.a061	a9 04		lda #$04		lda	#4
.a063	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler
.a066					TypeError:
.a066	a9 05		lda #$05		lda	#5
.a068	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler
.a06b					ArgumentError:
.a06b	a9 07		lda #$07		lda	#7
.a06d	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler
.a070					NotDoneError:
.a070	a9 0c		lda #$0c		lda	#12
.a072	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler
.a075					ErrorText:
>a075	42 72 65 61 6b 00			.text	"Break",0
>a07b	53 79 6e 74 61 78 20 65			.text	"Syntax error",0
>a083	72 72 6f 72 00
>a088	44 69 76 69 73 69 6f 6e			.text	"Division by zero",0
>a090	20 62 79 20 7a 65 72 6f 00
>a099	4f 75 74 20 6f 66 20 52			.text	"Out of Range",0
>a0a1	61 6e 67 65 00
>a0a6	54 79 70 65 20 6d 69 73			.text	"Type mismatch",0
>a0ae	6d 61 74 63 68 00
>a0b4	4f 75 74 20 6f 66 20 6d			.text	"Out of memory",0
>a0bc	65 6d 6f 72 79 00
>a0c2	49 6c 6c 65 67 61 6c 20			.text	"Illegal argument",0
>a0ca	61 72 67 75 6d 65 6e 74 00
>a0d3	53 74 6f 70 00				.text	"Stop",0
>a0d8	53 74 72 69 6e 67 20 74			.text	"String too long",0
>a0e0	6f 6f 20 6c 6f 6e 67 00
>a0e8	41 73 73 65 72 74 69 6f			.text	"Assertion failed",0
>a0f0	6e 20 66 61 69 6c 65 64 00
>a0f9	4f 75 74 20 6f 66 20 64			.text	"Out of data",0
>a101	61 74 61 00
>a105	55 6e 69 6d 70 6c 65 6d			.text	"Unimplemented",0
>a10d	65 6e 74 65 64 00
>a113	4e 6f 20 73 75 63 68 20			.text	"No such line number",0
>a11b	6c 69 6e 65 20 6e 75 6d 62 65 72 00
>a127	52 65 74 75 72 6e 20 77			.text	"Return without Gosub",0
>a12f	69 74 68 6f 75 74 20 47 6f 73 75 62 00
>a13c	55 6e 74 69 6c 20 77 69			.text	"Until without Repeat",0
>a144	74 68 6f 75 74 20 52 65 70 65 61 74 00
>a151	57 65 6e 64 20 77 69 74			.text	"Wend without While",0
>a159	68 6f 75 74 20 57 68 69 6c 65 00
>a164	4e 65 78 74 20 77 69 74			.text	"Next without For",0
>a16c	68 6f 75 74 20 46 6f 72 00
>a175	42 41 53 49 43 20 53 74			.text	"BASIC Stack full",0
>a17d	61 63 6b 20 66 75 6c 6c 00
>a186	4f 70 65 6e 20 53 74 72			.text	"Open Structure",0
>a18e	75 63 74 75 72 65 00
>a195	45 6e 64 50 72 6f 63 20			.text	"EndProc without call",0
>a19d	77 69 74 68 6f 75 74 20 63 61 6c 6c 00
>a1aa	41 72 72 61 79 20 61 6c			.text	"Array already defined",0
>a1b2	72 65 61 64 79 20 64 65 66 69 6e 65 64 00
>a1c0	41 72 72 61 79 20 73 69			.text	"Array size",0
>a1c8	7a 65 00
>a1cb	42 61 64 20 61 72 72 61			.text	"Bad array index",0
>a1d3	79 20 69 6e 64 65 78 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/timestamp.asm

>a1db	52 65 6c 65 61 73 65 20			.text "Release Alpha 5 (26-Nov-22). "
>a1e3	41 6c 70 68 61 20 35 20 28 32 36 2d 4e 6f 76 2d
>a1f3	32 32 29 2e 20

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcommand.asm

.a1f8					RectangleCommand:
.a1f8	a9 44		lda #$44			lda 	#GCMD_FrameRect				; frame rectangle
.a1fa	80 02		bra $a1fe			bra 	ShapeDrawCmd
.a1fc					CircleCommand:
.a1fc	a9 48		lda #$48			lda 	#GCMD_FrameCircle 				; framed circle
.a1fe					ShapeDrawCmd:
.a1fe	20 8c a2	jsr $a28c			jsr 	RunGraphicsCommand
.a201					ShapeDraw:
.a201	0d 31 06	ora $0631			ora 	gxFillSolid  				; adjust AXY for solid fill.
.a204	4c 80 a2	jmp $a280			jmp 	ExecuteGraphicCommand	 	; and complete
.a207					SpriteCommand:
.a207	a2 00		ldx #$00			ldx 	#0
.a209	20 53 9e	jsr $9e53			jsr 	Evaluate8BitInteger 		; get image number.
.a20c	5a		phy				phy
.a20d	a9 0e		lda #$0e			lda 	#GCMD_SpriteUse 			; use that image.
.a20f	ae 08 04	ldx $0408			ldx 	NSMantissa0
.a212	e0 40		cpx #$40			cpx 	#64 						; 0-63 only
.a214	b0 0d		bcs $a223			bcs 	_SCRange
.a216	a0 ff		ldy #$ff			ldy 	#255
.a218	20 91 ab	jsr $ab91			jsr 	GXGraphicDraw
.a21b	a9 52		lda #$52			lda 	#GCMD_SpriteMove
.a21d	7a		ply				ply
.a21e	20 8c a2	jsr $a28c			jsr 	RunGraphicsCommand
.a221	80 5d		bra $a280			bra 	ExecuteGraphicCommand
.a223					_SCRange:
.a223	4c 61 a0	jmp $a061			jmp 	RangeError
.a226					ImageCommand:
.a226	a2 00		ldx #$00			ldx 	#0
.a228	20 53 9e	jsr $9e53			jsr 	Evaluate8BitInteger 		; get image number.
.a22b	20 8c a2	jsr $a28c			jsr 	RunGraphicsCommand
.a22e					ImageRunDraw:
.a22e	09 40		ora #$40			ora 	#GCMD_Move					; move cursor
.a230	20 91 ab	jsr $ab91			jsr 	GXGraphicDraw
.a233	ad 37 06	lda $0637			lda 	gxDrawScale
.a236	0a		asl a				asl 	a
.a237	0a		asl a				asl 	a
.a238	0a		asl a				asl 	a
.a239	a8		tay				tay
.a23a	a9 0c		lda #$0c			lda 	#GCMD_DrawSprite 			; image drawing
.a23c	ae 08 04	ldx $0408			ldx 	NSMantissa0
.a23f	20 91 ab	jsr $ab91			jsr 	GXGraphicDraw
.a242	60		rts				rts
.a243					TextCommand:
.a243	a2 00		ldx #$00			ldx 	#0
.a245	20 06 9e	jsr $9e06			jsr 	EvaluateString 				; get text
.a248	20 8c a2	jsr $a28c			jsr 	RunGraphicsCommand
.a24b					TextRunDraw:
.a24b	09 40		ora #$40			ora 	#GCMD_Move 					; move cursor
.a24d	20 91 ab	jsr $ab91			jsr 	GXGraphicDraw
.a250	a0 00		ldy #$00			ldy 	#0
.a252					_IRDLoop:
.a252	ad 10 04	lda $0410			lda 	NSMantissa1 				; access character
.a255	85 37		sta $37				sta 	zTemp0+1
.a257	ad 08 04	lda $0408			lda 	NSMantissa0
.a25a	85 36		sta $36				sta 	zTemp0
.a25c	b1 36		lda ($36),y			lda 	(zTemp0),y
.a25e	f0 13		beq $a273			beq 	_IRDExit
.a260	5a		phy				phy									; save string pos
.a261	48		pha				pha 								; save char
.a262	ad 37 06	lda $0637			lda 	gxDrawScale 				; get scale
.a265	0a		asl a				asl 	a
.a266	0a		asl a				asl 	a
.a267	0a		asl a				asl 	a
.a268	a8		tay				tay
.a269	a9 0a		lda #$0a			lda 	#GCMD_DrawFont 				; char drawing
.a26b	fa		plx				plx 								; char to draw
.a26c	20 91 ab	jsr $ab91			jsr 	GXGraphicDraw
.a26f	7a		ply				ply 								; restore string pos
.a270	c8		iny				iny
.a271	90 df		bcc $a252			bcc 	_IRDLoop 					; go back if no error.
.a273					_IRDExit:
.a273	60		rts				rts
.a274					PlotCommand:
.a274	a9 50		lda #$50			lda 	#GCMD_Plot 					; command ID to use
.a276	20 8c a2	jsr $a28c			jsr 	RunGraphicsCommand
.a279	80 05		bra $a280			bra 	ExecuteGraphicCommand
.a27b					LineCommand:
.a27b	a9 42		lda #$42			lda 	#GCMD_Line 						; command ID to use
.a27d	20 8c a2	jsr $a28c			jsr 	RunGraphicsCommand
.a280					ExecuteGraphicCommand:
.a280	0d 30 06	ora $0630			ora 	gxCommandID 				; make a full command
.a283	20 91 ab	jsr $ab91			jsr 	GXGraphicDraw 				; draw it and exit
.a286	b0 01		bcs $a289			bcs 	_EGCError
.a288	60		rts				rts
.a289					_EGCError:
.a289	4c 5c a0	jmp $a05c			jmp 	SyntaxError
.a28c					RunGraphicsCommand:
.a28c	8d 30 06	sta $0630			sta 	gxCommandID					; save TODO graphics command.
.a28f	68		pla				pla 								; pop handler address
.a290	fa		plx				plx
.a291	1a		inc a				inc 	a
.a292	d0 01		bne $a295			bne 	_RGINoCarry
.a294	e8		inx				inx
.a295					_RGINoCarry:
.a295	8d 35 06	sta $0635			sta 	GXHandler
.a298	8e 36 06	stx $0636			stx 	GXHandler+1
.a29b					_RGICommandLoop:
.a29b	b1 30		lda ($30),y			lda 	(codePtr),y
.a29d	c8		iny				iny
.a29e	c9 ce		cmp #$ce			cmp 	#KWD_TO						; is it TO x,y
.a2a0	f0 53		beq $a2f5			beq 	_RGI_To
.a2a2	c9 ba		cmp #$ba			cmp 	#KWD_HERE 					; do it here.
.a2a4	f0 55		beq $a2fb			beq 	_RGI_Here
.a2a6	c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL or : , exit
.a2a8	f0 3d		beq $a2e7			beq 	_RGI_Exit
.a2aa	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.a2ac	f0 39		beq $a2e7			beq 	_RGI_Exit
.a2ae	c9 c2		cmp #$c2			cmp 	#KWD_OUTLINE 				; solid or outline
.a2b0	f0 3e		beq $a2f0			beq 	_RGI_Frame
.a2b2	c9 ca		cmp #$ca			cmp 	#KWD_SOLID
.a2b4	f0 33		beq $a2e9			beq 	_RGI_Solid
.a2b6	c9 ab		cmp #$ab			cmp 	#KWD_BY 					; by offset
.a2b8	f0 4b		beq $a305			beq 	_RGI_By
.a2ba	c9 b6		cmp #$b6			cmp 	#KWD_FROM 					; from
.a2bc	f0 17		beq $a2d5			beq 	_RGI_Move2
.a2be	c9 b3		cmp #$b3			cmp 	#KWD_DIM 					; dim (set scale)
.a2c0	f0 65		beq $a327			beq 	_RGI_Dim
.a2c2	c9 b1		cmp #$b1			cmp 	#KWD_COLOUR 				; colour or Color
.a2c4	f0 78		beq $a33e			beq 	_RGI_Colour
.a2c6	c9 b0		cmp #$b0			cmp 	#KWD_COLOR
.a2c8	f0 74		beq $a33e			beq 	_RGI_Colour
.a2ca	ae 30 06	ldx $0630			ldx 	gxCommandID
.a2cd	e0 52		cpx #$52			cpx 	#GCMD_SpriteMove 			; if not sprite
.a2cf	d0 03		bne $a2d4			bne 	_RGI_Move 					; move
.a2d1	4c 68 a3	jmp $a368			jmp		_RGI_SpriteInstructions
.a2d4					_RGI_Move:
.a2d4	88		dey				dey 								; unpick get.
.a2d5					_RGI_Move2:
.a2d5	20 8e a3	jsr $a38e			jsr 	GCGetCoordinatePair 		; move to here
.a2d8	20 b5 a3	jsr $a3b5			jsr 	GCCopyPairToStore 			; save
.a2db	5a		phy				phy
.a2dc	20 ab a3	jsr $a3ab			jsr 	GCLoadAXY 					; load in
.a2df	09 40		ora #$40			ora 	#GCMD_Move 					; move there
.a2e1	20 91 ab	jsr $ab91			jsr 	GXGraphicDraw
.a2e4	7a		ply				ply
.a2e5	80 b4		bra $a29b			bra 	_RGICommandLoop 			; and go round
.a2e7					_RGI_Exit:
.a2e7	88		dey				dey 								; unpick : / EOL
.a2e8	60		rts				rts
.a2e9					_RGI_Solid:
.a2e9	a9 02		lda #$02			lda 	#2
.a2eb	8d 31 06	sta $0631			sta 	gxFillSolid
.a2ee	80 ab		bra $a29b			bra 	_RGICommandLoop
.a2f0					_RGI_Frame:
.a2f0	9c 31 06	stz $0631			stz 	gxFillSolid
.a2f3	80 a6		bra $a29b			bra 	_RGICommandLoop
.a2f5					_RGI_To:
.a2f5	20 8e a3	jsr $a38e			jsr 	GCGetCoordinatePair 		; get coordinate pair into slot #1,#2
.a2f8	20 b5 a3	jsr $a3b5			jsr 	GCCopyPairToStore
.a2fb					_RGI_Here:
.a2fb	5a		phy				phy
.a2fc	20 ab a3	jsr $a3ab			jsr 	GCLoadAXY 					; load it into AXY
.a2ff	20 65 a3	jsr $a365			jsr 	_RGICallHandler 			; go do whatever it is.
.a302	7a		ply				ply
.a303	80 96		bra $a29b			bra 	_RGICommandLoop 			; and go round
.a305					_RGI_By:
.a305	20 9b a3	jsr $a39b			jsr 	GCSignedCoordinatePair 		; get coordinate pair into slot #1,#2
.a308	18		clc				clc
.a309	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; copy it into space.
.a30c	6d 32 06	adc $0632			adc 	gxxPos
.a30f	8d 32 06	sta $0632			sta 	gxXPos
.a312	ad 11 04	lda $0411			lda 	NSMantissa1+1
.a315	6d 33 06	adc $0633			adc 	gxxPos+1
.a318	8d 33 06	sta $0633			sta 	gxXPos+1
.a31b	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a31e	18		clc				clc
.a31f	6d 34 06	adc $0634			adc 	gxYPos
.a322	8d 34 06	sta $0634			sta 	gxYPos
.a325	80 d4		bra $a2fb			bra 	_RGI_Here
.a327					_RGI_Dim:
.a327	a2 01		ldx #$01			ldx	 	#1
.a329	20 53 9e	jsr $9e53			jsr 	Evaluate8BitInteger
.a32c	ad 09 04	lda $0409			lda 	NSMantissa0+1
.a32f	c9 00		cmp #$00			cmp 	#0
.a331	f0 2f		beq $a362			beq 	_RGIRange
.a333	c9 09		cmp #$09			cmp 	#8+1
.a335	b0 2b		bcs $a362			bcs		_RGIRange
.a337	3a		dec a				dec 	a
.a338	8d 37 06	sta $0637			sta 	gxDrawScale
.a33b	4c 9b a2	jmp $a29b			jmp 	_RGICommandLoop
.a33e					_RGI_Colour:
.a33e	a2 01		ldx #$01			ldx 	#1 							; colour
.a340	20 53 9e	jsr $9e53			jsr 	Evaluate8BitInteger
.a343	a2 02		ldx #$02			ldx 	#2 							; default zero for 2nd parameter
.a345	20 d2 9e	jsr $9ed2			jsr 	NSMSetZero
.a348	b1 30		lda ($30),y			lda 	(codePtr),y
.a34a	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; check , => mode.
.a34c	d0 04		bne $a352			bne 	_RGICDefaultMode
.a34e	c8		iny				iny
.a34f	20 53 9e	jsr $9e53			jsr 	Evaluate8BitInteger
.a352					_RGICDefaultMode:
.a352	5a		phy				phy
.a353	a9 08		lda #$08			lda 	#GCMD_Colour 				; set colour.
.a355	ae 09 04	ldx $0409			ldx 	NSMantissa0+1
.a358	ac 0a 04	ldy $040a			ldy 	NSMantissa0+2
.a35b	20 91 ab	jsr $ab91			jsr 	GXGraphicDraw
.a35e	7a		ply				ply
.a35f	4c 9b a2	jmp $a29b			jmp 	_RGICommandLoop 			; and go round
.a362					_RGIRange:
.a362	4c 61 a0	jmp $a061			jmp 	RangeError
.a365					_RGICallHandler:
.a365	6c 35 06	jmp ($0635)			jmp 	(GXHandler)
.a368					_RGI_SpriteInstructions:
.a368	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a36a	f0 07		beq $a373			beq 	_RGISpriteOff
.a36c	c9 bb		cmp #$bb			cmp 	#KWD_IMAGE
.a36e	f0 13		beq $a383			beq 	_RGISetImage
.a370	4c d4 a2	jmp $a2d4			jmp 	_RGI_Move
.a373					_RGISpriteOff:
.a373	5a		phy				phy
.a374	a0 01		ldy #$01			ldy 	#1
.a376	a2 00		ldx #$00			ldx 	#0
.a378					_RGIDoCommandLoop:
.a378	a9 10		lda #$10			lda 	#GCMD_SpriteImage
.a37a	20 91 ab	jsr $ab91			jsr 	GXGraphicDraw
.a37d	7a		ply				ply
.a37e	b0 e2		bcs $a362			bcs 	_RGIRange
.a380	4c 9b a2	jmp $a29b			jmp 	_RGICommandLoop
.a383					_RGISetImage:
.a383	a2 01		ldx #$01			ldx 	#1
.a385	20 53 9e	jsr $9e53			jsr 	Evaluate8BitInteger
.a388	5a		phy				phy
.a389	aa		tax				tax
.a38a	a0 00		ldy #$00			ldy 	#0
.a38c	80 ea		bra $a378			bra 	_RGIDoCommandLoop
.a38e					GCGetCoordinatePair:
.a38e	a2 01		ldx #$01			ldx 	#1
.a390	20 33 9e	jsr $9e33			jsr 	Evaluate16BitInteger
.a393	20 fa 8d	jsr $8dfa			jsr 	CheckComma
.a396	e8		inx				inx
.a397	20 33 9e	jsr $9e33			jsr 	Evaluate16BitInteger
.a39a	60		rts				rts
.a39b					GCSignedCoordinatePair:
.a39b	a2 01		ldx #$01			ldx 	#1
.a39d	20 3f 9e	jsr $9e3f			jsr 	Evaluate16BitIntegerSigned
.a3a0	20 fa 8d	jsr $8dfa			jsr 	CheckComma
.a3a3	e8		inx				inx
.a3a4	20 3f 9e	jsr $9e3f			jsr 	Evaluate16BitIntegerSigned
.a3a7	60		rts				rts
.a3a8					_GCCPRange:
.a3a8	4c 61 a0	jmp $a061			jmp 	RangeError
.a3ab					GCLoadAXY:
.a3ab	ad 33 06	lda $0633			lda 	gxXPos+1
.a3ae	ae 32 06	ldx $0632			ldx 	gxXPos
.a3b1	ac 34 06	ldy $0634			ldy 	gxYPos
.a3b4	60		rts				rts
.a3b5					GCCopyPairToStore:
.a3b5	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; copy it into space.
.a3b8	8d 32 06	sta $0632			sta 	gxXPos
.a3bb	ad 11 04	lda $0411			lda 	NSMantissa1+1
.a3be	8d 33 06	sta $0633			sta 	gxXPos+1
.a3c1	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a3c4	8d 34 06	sta $0634			sta 	gxYPos
.a3c7	60		rts				rts
.0630					gxCommandID:
>0630							.fill 	1
.0631					gxFillSolid:
>0631							.fill 	1
.0632					gxXPos:
>0632							.fill 	2
.0634					gxYPos:
>0634							.fill 	1
.0635					gxHandler:
>0635							.fill 	2
.0637					gxDrawScale:
>0637							.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcontrol.asm

.a3c8					BitmapCtrl:
.a3c8	b1 30		lda ($30),y			lda 	(codePtr),y
.a3ca	c8		iny				iny
.a3cb	a2 01		ldx #$01			ldx 	#1
.a3cd	c9 c1		cmp #$c1			cmp 	#KWD_ON
.a3cf	f0 11		beq $a3e2			beq 	BitmapSwitch
.a3d1	ca		dex				dex
.a3d2	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a3d4	f0 0c		beq $a3e2			beq 	BitmapSwitch
.a3d6	20 53 9e	jsr $9e53			jsr 	Evaluate8BitInteger 		; get the colour
.a3d9	5a		phy				phy
.a3da	aa		tax				tax
.a3db	a9 06		lda #$06			lda 	#GCMD_Clear					; clear to that colour
.a3dd	20 91 ab	jsr $ab91			jsr 	GXGraphicDraw
.a3e0	7a		ply				ply
.a3e1	60		rts				rts
.a3e2					BitmapSwitch:
.a3e2	5a		phy				phy
.a3e3	a0 00		ldy #$00			ldy 	#0 							; gfx 1,on/off,0
.a3e5	a9 02		lda #$02			lda 	#GCMD_BitmapCtl
.a3e7	20 91 ab	jsr $ab91			jsr 	GXGraphicDraw
.a3ea	a9 08		lda #$08			lda 	#GCMD_Colour				; set colour to $FF
.a3ec	a0 00		ldy #$00			ldy 	#0
.a3ee	a2 ff		ldx #$ff			ldx 	#$FF
.a3f0	20 91 ab	jsr $ab91			jsr 	GXGraphicDraw
.a3f3	9c 31 06	stz $0631			stz 	gxFillSolid
.a3f6	9c 32 06	stz $0632			stz 	gxXPos
.a3f9	9c 33 06	stz $0633			stz 	gxXPos+1
.a3fc	9c 34 06	stz $0634			stz 	gxYPos
.a3ff	9c 37 06	stz $0637			stz 	gxDrawScale
.a402	a9 40		lda #$40			lda 	#GCMD_Move 						; home cursor
.a404	a2 00		ldx #$00			ldx 	#0
.a406	a0 00		ldy #$00			ldy 	#0
.a408	20 91 ab	jsr $ab91			jsr 	GXGraphicDraw
.a40b	7a		ply				ply
.a40c	60		rts				rts
.a40d					SpritesCtrl:
.a40d	b1 30		lda ($30),y			lda 	(codePtr),y
.a40f	c8		iny				iny
.a410	a2 01		ldx #$01			ldx 	#1
.a412	c9 c1		cmp #$c1			cmp 	#KWD_ON
.a414	f0 08		beq $a41e			beq 	SpriteSwitch
.a416	ca		dex				dex
.a417	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a419	f0 03		beq $a41e			beq 	SpriteSwitch
.a41b	4c 5c a0	jmp $a05c			jmp 	SyntaxError
.a41e					SpriteSwitch:
.a41e	5a		phy				phy
.a41f	a0 00		ldy #$00			ldy 	#0 							; gfx 2,on/off,0
.a421	a9 04		lda #$04			lda 	#GCMD_SpriteCtl
.a423	20 91 ab	jsr $ab91			jsr 	GXGraphicDraw
.a426	7a		ply				ply
.a427	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gfx.asm

.a428					GfxCommand:
.a428	a2 00		ldx #$00			ldx 	#0
.a42a	20 53 9e	jsr $9e53			jsr 	Evaluate8BitInteger 		; command
.a42d	20 fa 8d	jsr $8dfa			jsr 	CheckComma
.a430	e8		inx				inx
.a431	20 33 9e	jsr $9e33			jsr 	Evaluate16BitInteger 		; X
.a434	20 fa 8d	jsr $8dfa			jsr 	CheckComma
.a437	e8		inx				inx
.a438	20 53 9e	jsr $9e53			jsr 	Evaluate8BitInteger 		; Y
.a43b	ad 11 04	lda $0411			lda 	NSMantissa1+1  				; shift bit 0 of X into CS, should now be zero
.a43e	4a		lsr a				lsr 	a
.a43f	d0 16		bne $a457			bne 	_GfxError
.a441	2e 08 04	rol $0408			rol 	NSMantissa0 				; rotate into command
.a444	b0 11		bcs $a457			bcs 	_GfxError 					; bit 7 should have been zero
.a446	5a		phy				phy 								; save pos
.a447	ad 08 04	lda $0408			lda 	NSMantissa0 				; do the command
.a44a	ae 09 04	ldx $0409			ldx 	NSMantissa0+1
.a44d	ac 0a 04	ldy $040a			ldy 	NSMantissa0+2
.a450	20 91 ab	jsr $ab91			jsr 	GXGraphicDraw
.a453	b0 02		bcs $a457			bcs 	_GfxError
.a455	7a		ply				ply 								; restore pos and exit.
.a456	60		rts				rts
.a457					_GfxError:
.a457	4c 61 a0	jmp $a061			jmp 	RangeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/hit.asm

.a45a					UnaryHit:
.a45a	fa		plx				plx
.a45b	a9 36		lda #$36			lda 	#zTemp0
.a45d	20 53 9e	jsr $9e53			jsr 	Evaluate8BitInteger 		; get sprite number 0
.a460	20 fa 8d	jsr $8dfa			jsr 	CheckComma
.a463	e8		inx				inx
.a464	20 53 9e	jsr $9e53			jsr 	Evaluate8BitInteger 		; get sprite number 1
.a467	20 f2 8d	jsr $8df2			jsr		CheckRightBracket
.a46a	ca		dex				dex 								; fix back up again.
.a46b	da		phx				phx 								; save X/Y
.a46c	5a		phy				phy
.a46d	bc 09 04	ldy $0409,x			ldy 	NSMantissa0+1,x 			; get the sprite numbers into X/Y
.a470	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a473	aa		tax				tax
.a474	a9 12		lda #$12			lda 	#GCMD_SpriteCollide 		; command check collision.
.a476	20 91 ab	jsr $ab91			jsr 	GXGraphicDraw 				; calculate result
.a479	1a		inc a				inc 	a 							; so 255 (fail) -> 0, otherwise 1,2,3,4 pixels etc.
.a47a	7a		ply				ply 								; restore XY
.a47b	fa		plx				plx
.a47c	20 d4 9e	jsr $9ed4			jsr 	NSMSetByte 					; return the hit result
.a47f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/palette.asm

.a480					PaletteCommand:
.a480	a2 00		ldx #$00			ldx 	#0
.a482	20 53 9e	jsr $9e53			jsr 	Evaluate8BitInteger 		; colour
.a485	20 fa 8d	jsr $8dfa			jsr 	CheckComma
.a488	e8		inx				inx
.a489	20 33 9e	jsr $9e33			jsr 	Evaluate16BitInteger 		; r
.a48c	20 fa 8d	jsr $8dfa			jsr 	CheckComma
.a48f	e8		inx				inx
.a490	20 53 9e	jsr $9e53			jsr 	Evaluate8BitInteger 		; g
.a493	20 fa 8d	jsr $8dfa			jsr 	CheckComma
.a496	e8		inx				inx
.a497	20 53 9e	jsr $9e53			jsr 	Evaluate8BitInteger 		; b
.a49a	ad 08 04	lda $0408			lda 	NSMantissa0 				; get colour #
.a49d	85 36		sta $36				sta 	zTemp0
.a49f	a9 34		lda #$34			lda 	#$D0 >> 2 					; MSB = D0/4
.a4a1	85 37		sta $37				sta 	zTemp0+1
.a4a3	06 36		asl $36				asl 	zTemp0 						; zTemp = $D000+Colour x 4
.a4a5	26 37		rol $37				rol	 	zTemp0+1
.a4a7	06 36		asl $36				asl 	zTemp0
.a4a9	26 37		rol $37				rol	 	zTemp0+1
.a4ab	a9 01		lda #$01			lda 	#1 							; I/O Page 2
.a4ad	85 01		sta $01				sta 	1
.a4af	5a		phy				phy
.a4b0	ad 0b 04	lda $040b			lda 	NSMantissa0+3 				; fix to r,g,b
.a4b3	92 36		sta ($36)			sta 	(zTemp0)
.a4b5	a0 01		ldy #$01			ldy 	#1
.a4b7	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a4ba	91 36		sta ($36),y			sta 	(zTemp0),y
.a4bc	ad 09 04	lda $0409			lda 	NSMantissa0+1
.a4bf	c8		iny				iny
.a4c0	91 36		sta ($36),y			sta 	(zTemp0),y
.a4c2	7a		ply				ply
.a4c3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/event.asm

.a4c4					UnaryEvent:
.a4c4	fa		plx				plx
.a4c5	20 7e a5	jsr $a57e			jsr 	TimerToStackX 				; timer in +0
.a4c8	e8		inx				inx  								; put reference into +1
.a4c9	20 98 98	jsr $9898			jsr 	EvaluateTerm
.a4cc	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if is integer reference
.a4cf	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.a4d1	d0 57		bne $a52a			bne 	_UEType
.a4d3	e8		inx				inx 								; put the step in +2
.a4d4	20 fa 8d	jsr $8dfa			jsr 	CheckComma
.a4d7	20 33 9e	jsr $9e33			jsr 	Evaluate16BitInteger
.a4da	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket
.a4dd	ca		dex				dex
.a4de	ca		dex				dex
.a4df	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; copy reference to zTemp0
.a4e2	85 36		sta $36				sta 	zTemp0
.a4e4	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.a4e7	85 37		sta $37				sta 	zTemp0+1
.a4e9	5a		phy				phy
.a4ea	a0 03		ldy #$03			ldy 	#3 							; check bit 7 of last bit, the packed sign bit
.a4ec	b1 36		lda ($36),y			lda 	(zTemp0),y
.a4ee	30 36		bmi $a526			bmi 	_UEFalse 					; exit if signed.
.a4f0	a0 00		ldy #$00			ldy 	#0 							; has it timed out (24 bit)
.a4f2	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a4f5	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.a4f7	c8		iny				iny
.a4f8	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a4fb	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a4fd	c8		iny				iny
.a4fe	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.a501	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a503	90 21		bcc $a526			bcc 	_UEFalse 					; no, return FALSE.
.a505	18		clc				clc
.a506	a0 00		ldy #$00			ldy 	#0 							; work out new value as timer() + step
.a508	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a50b	7d 0a 04	adc $040a,x			adc 	NSMantissa0+2,x
.a50e	91 36		sta ($36),y			sta 	(zTemp0),y
.a510	c8		iny				iny
.a511	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a514	7d 12 04	adc $0412,x			adc 	NSMantissa1+2,x
.a517	91 36		sta ($36),y			sta 	(zTemp0),y
.a519	c8		iny				iny
.a51a	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.a51d	7d 1a 04	adc $041a,x			adc 	NSMantissa2+2,x
.a520	91 36		sta ($36),y			sta 	(zTemp0),y
.a522	7a		ply				ply
.a523	4c 78 8e	jmp $8e78			jmp 	ReturnTrue
.a526					_UEFalse:
.a526	7a		ply				ply 								; restore Y
.a527	4c 84 8e	jmp $8e84			jmp 	ReturnFalse 				; and return False
.a52a					_UEType:
.a52a	4c 66 a0	jmp $a066			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/joy.asm

.a52d					UnaryJoyX:
.a52d	18		clc				clc
.a52e	80 01		bra $a531			bra 	JoyMain
.a530					UnaryJoyY:
.a530	38		sec				sec
.a531					JoyMain:
.a531	fa		plx				plx 								; get pos
.a532	08		php				php 								; save carry (set for Y)
.a533	20 53 9e	jsr $9e53			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a536	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket
.a539	20 4a ab	jsr $ab4a			jsr 	EXTReadController 			; read the controller.
.a53c	28		plp				plp
.a53d	90 02		bcc $a541			bcc 	_JMNoShift 					; if Y then shift bits 3,2 -> 1,0
.a53f	4a		lsr a				lsr 	a
.a540	4a		lsr a				lsr 	a
.a541					_JMNoShift:
.a541	4a		lsr a				lsr 	a 							; if bit 0 set then right/down e.g. +1
.a542	b0 0a		bcs $a54e			bcs 	_JMIsRight
.a544	4a		lsr a				lsr 	a 							; if bit 1 set then left/up e.g. -1
.a545	b0 04		bcs $a54b			bcs 	_JMIsLeft
.a547	20 d2 9e	jsr $9ed2			jsr 	NSMSetZero 					; zero result
.a54a	60		rts				rts
.a54b					_JMIsLeft:
.a54b	4c 78 8e	jmp $8e78			jmp 	ReturnTrue
.a54e					_JMIsRight:
.a54e	a9 01		lda #$01			lda 	#1
.a550	20 d4 9e	jsr $9ed4			jsr 	NSMSetByte
.a553	60		rts				rts
.a554					UnaryJoyB:
.a554	fa		plx				plx 								; get pos
.a555	20 53 9e	jsr $9e53			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a558	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket
.a55b	20 4a ab	jsr $ab4a			jsr 	EXTReadController 			; read the controller.
.a55e	4a		lsr a				lsr 	a
.a55f	4a		lsr a				lsr 	a
.a560	4a		lsr a				lsr 	a
.a561	4a		lsr a				lsr 	a
.a562	29 01		and #$01			and 	#1
.a564	20 d4 9e	jsr $9ed4			jsr 	NSMSetByte
.a567	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/load.asm

.a568					LoadCommand:
.a568	20 5b 89	jsr $895b			jsr 	NewProgram
.a56b	20 db 82	jsr $82db			jsr 	BackLoadProgram
.a56e	4c 6b 83	jmp $836b			jmp 	WarmStart
.a571					GoCommand:
.a571	20 5b 89	jsr $895b			jsr 	NewProgram
.a574	20 db 82	jsr $82db			jsr 	BackLoadProgram
.a577	4c 9a 8a	jmp $8a9a			jmp 	CommandRun

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/timer.asm

.a57a					UnaryTimer:
.a57a	fa		plx				plx
.a57b	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket
.a57e					TimerToStackX:
.a57e	20 d2 9e	jsr $9ed2			jsr 	NSMSetZero 					; zero result
.a581	64 01		stz $01				stz 	1 							; access I/O
.a583	ad 59 d6	lda $d659			lda 	$D659 						; copy timer in
.a586	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.a589	ad 5a d6	lda $d65a			lda 	$D65A
.a58c	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a58f	ad 5b d6	lda $d65b			lda 	$D65B
.a592	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.a595	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/delete.asm

.a596					MemoryDeleteLine:
.a596	20 b5 a5	jsr $a5b5			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a599	b2 30		lda ($30)			lda 	(codePtr) 					; size to delete => y
.a59b	a8		tay				tay
.a59c					_MDDLLoop:
.a59c	b1 30		lda ($30),y			lda 	(codePtr),y 				; copy down
.a59e	92 30		sta ($30)			sta 	(codePtr)
.a5a0	a5 30		lda $30				lda 	codePtr 					; check done the lot.
.a5a2	c5 3a		cmp $3a				cmp 	zTemp2
.a5a4	d0 07		bne $a5ad			bne 	_MDLDLNext
.a5a6	a5 31		lda $31				lda 	codePtr+1
.a5a8	c5 3b		cmp $3b				cmp 	zTemp2+1
.a5aa	d0 01		bne $a5ad			bne 	_MDLDLNext
.a5ac					_MDDLExit:
.a5ac	60		rts				rts
.a5ad					_MDLDLNext:
.a5ad	e6 30		inc $30				inc 	codePtr						; next byte
.a5af	d0 eb		bne $a59c			bne 	_MDDLLoop
.a5b1	e6 31		inc $31				inc 	codePtr+1
.a5b3	80 e7		bra $a59c			bra 	_MDDLLoop
.a5b5					IMemoryFindEnd:
.a5b5	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a5b7	85 3a		sta $3a				sta 	0+zTemp2
.a5b9	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a5bb	85 3b		sta $3b				sta 	1+zTemp2
.a5bd					_MDLFELoop:
.a5bd	b2 3a		lda ($3a)			lda 	(zTemp2)
.a5bf	f0 0b		beq $a5cc			beq 	_MDLFEExit
.a5c1	18		clc				clc
.a5c2	65 3a		adc $3a				adc 	zTemp2
.a5c4	85 3a		sta $3a				sta 	zTemp2
.a5c6	90 f5		bcc $a5bd			bcc 	_MDLFELoop
.a5c8	e6 3b		inc $3b				inc 	zTemp2+1
.a5ca	80 f1		bra $a5bd			bra 	_MDLFELoop
.a5cc					_MDLFEExit:
.a5cc	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/insert.asm

.a5cd					MemoryInsertLine:
.a5cd	08		php				php
.a5ce	20 b5 a5	jsr $a5b5			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a5d1	a5 3b		lda $3b				lda 	zTemp2+1 					; space ?
.a5d3	1a		inc a				inc 	a
.a5d4	c9 7f		cmp #$7f			cmp 	#(BasicEnd >> 8)-1
.a5d6	b0 36		bcs $a60e			bcs 	_MDLIError
.a5d8	28		plp				plp
.a5d9	90 08		bcc $a5e3			bcc 	_MDLIFound
.a5db	a5 3a		lda $3a				lda 	zTemp2 						; if CS on entry append.
.a5dd	85 30		sta $30				sta 	codePtr
.a5df	a5 3b		lda $3b				lda 	zTemp2+1
.a5e1	85 31		sta $31				sta 	codePtr+1
.a5e3					_MDLIFound:
.a5e3	ad aa 04	lda $04aa			lda 	tokenOffset 				; insert gap in Y, the offset, e.g. length of the new line
.a5e6	a8		tay				tay
.a5e7					_MDLIInsert:
.a5e7	b2 3a		lda ($3a)			lda 	(zTemp2) 					; shift one byte up , at least one covers end case.
.a5e9	91 3a		sta ($3a),y			sta 	(zTemp2),y 					; work from top down.
.a5eb	a5 30		lda $30				lda 	codePtr 					; done insert point ?
.a5ed	c5 3a		cmp $3a				cmp 	zTemp2
.a5ef	d0 06		bne $a5f7			bne 	_MDLINext
.a5f1	a5 31		lda $31				lda 	codePtr+1
.a5f3	c5 3b		cmp $3b				cmp 	zTemp2+1
.a5f5	f0 0a		beq $a601			beq 	_MDLIHaveSpace
.a5f7					_MDLINext:
.a5f7	a5 3a		lda $3a				lda 	zTemp2 						; if no, keep zTemp2 going backwards
.a5f9	d0 02		bne $a5fd			bne 	_MDLINoBorrow
.a5fb	c6 3b		dec $3b				dec 	zTemp2+1
.a5fd					_MDLINoBorrow:
.a5fd	c6 3a		dec $3a				dec 	zTemp2
.a5ff	80 e6		bra $a5e7			bra 	_MDLIInsert
.a601					_MDLIHaveSpace:
.a601	ac aa 04	ldy $04aa			ldy 	tokenOffset 				; bytes to copy
.a604	88		dey				dey 								; from offset-1 to 0
.a605					_MDLICopy:
.a605	b9 aa 04	lda $04aa,y			lda 	tokenOffset,y
.a608	91 30		sta ($30),y			sta 	(codePtr),y
.a60a	88		dey				dey
.a60b	10 f8		bpl $a605			bpl 	_MDLICopy
.a60d	60		rts				rts
.a60e					_MDLIError:
.a60e	a9 06		lda #$06		lda	#6
.a610	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler
.a613					MDLAppendLine:
.a613	86 37		stx $37				stx 	zTemp0+1 					; save new line at zTemp0
.a615	85 36		sta $36				sta 	zTemp0
.a617	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a619	85 38		sta $38				sta 	0+zTemp1
.a61b	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a61d	85 39		sta $39				sta 	1+zTemp1
.a61f	b2 38		lda ($38)			lda 	(zTemp1)
.a621	d0 0a		bne $a62d			bne 	_MDLANoInitialise
.a623	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a625	8d 38 06	sta $0638			sta 	0+AppendPointer
.a628	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a62a	8d 39 06	sta $0639			sta 	1+AppendPointer
.a62d					_MDLANoInitialise:
.a62d	18		clc				clc
.a62e	ad 38 06	lda $0638			lda 	AppendPointer 				; copy append pointer to zTemp1 adding the offset as you go
.a631	85 38		sta $38				sta 	zTemp1
.a633	72 36		adc ($36)			adc 	(zTemp0)
.a635	8d 38 06	sta $0638			sta 	AppendPointer
.a638	ad 39 06	lda $0639			lda 	AppendPointer+1
.a63b	85 39		sta $39				sta 	zTemp1+1
.a63d	69 00		adc #$00			adc 	#0
.a63f	8d 39 06	sta $0639			sta 	AppendPointer+1
.a642	a0 00		ldy #$00			ldy 	#0
.a644					_MDLACopy:
.a644	b1 36		lda ($36),y			lda 	(zTemp0),y 					; copy new line in
.a646	91 38		sta ($38),y			sta 	(zTemp1),y
.a648	c8		iny				iny
.a649	98		tya				tya
.a64a	d2 36		cmp ($36)			cmp 	(zTemp0) 					; done whole line
.a64c	d0 f6		bne $a644			bne 	_MDLACopy
.a64e	a9 00		lda #$00			lda 	#0 							; end of program.
.a650	91 38		sta ($38),y			sta 	(zTemp1),y
.a652	60		rts				rts
.0638					AppendPointer:
>0638							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/memory.asm

.a653					MemoryNew:
.a653	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a655	85 30		sta $30				sta 	codePtr
.a657	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a659	85 31		sta $31				sta 	codePtr+1
.a65b	a9 00		lda #$00			lda 	#0 							; write zero there erasing the program.
.a65d	92 30		sta ($30)			sta 	(codePtr)
.a65f	60		rts				rts
.a660					MemoryInline:
.a660	98		tya				tya 								; put address into stack,x
.a661	18		clc				clc  								; get the offset, add codePtr
.a662	65 30		adc $30				adc 	codePtr
.a664	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; store the result in the mantissa.
.a667	a5 31		lda $31				lda 	codePtr+1
.a669	69 00		adc #$00			adc 	#0
.a66b	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a66e	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.a671	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.a674	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/search.asm

.a675					MemorySearch:
.a675	85 36		sta $36				sta 	zTemp0 						; save line number in zTemp0
.a677	86 37		stx $37				stx 	zTemp0+1
.a679	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a67b	85 30		sta $30				sta 	codePtr
.a67d	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a67f	85 31		sta $31				sta 	codePtr+1
.a681					_MTAXLoop:
.a681	b2 30		lda ($30)			lda 	(codePtr)
.a683	18		clc				clc
.a684	f0 21		beq $a6a7			beq 	_MTAXExit 					; reached end, exit with CC.
.a686	a0 01		ldy #$01			ldy 	#1 							; calculate current line# - requested line#
.a688	b1 30		lda ($30),y			lda 	(codePtr),y
.a68a	38		sec				sec
.a68b	e5 36		sbc $36				sbc 	zTemp0
.a68d	85 38		sta $38				sta 	zTemp1 						; save interim to set Z
.a68f	c8		iny				iny 								; do the MSB
.a690	b1 30		lda ($30),y			lda 	(codePtr),y
.a692	e5 37		sbc $37				sbc 	zTemp0+1
.a694	05 38		ora $38				ora 	zTemp1 						; will set Z if result is zero, doesn't affect carry flag
.a696	f0 0f		beq $a6a7			beq 	_MTAXExit	 				; found so exit (CS will be set)
.a698	b0 0d		bcs $a6a7			bcs 	_MTAXExit 					; current < required exit
.a69a	18		clc				clc
.a69b	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.a69d	65 30		adc $30				adc 	codePtr
.a69f	85 30		sta $30				sta 	codePtr
.a6a1	90 02		bcc $a6a5			bcc 	_CREExit
.a6a3	e6 31		inc $31				inc 	codePtr+1 					; carry
.a6a5					_CREExit:
.a6a5	80 da		bra $a681			bra 	_MTAXLoop
.a6a7					_MTAXExit:
.a6a7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/playing.asm

.a6a8					UnaryPlaying:
.a6a8	fa		plx				plx
.a6a9	20 53 9e	jsr $9e53			jsr 	Evaluate8BitInteger 		; get channel #
.a6ac	48		pha				pha
.a6ad	20 f2 8d	jsr $8df2			jsr		CheckRightBracket
.a6b0	68		pla				pla
.a6b1	c9 04		cmp #$04			cmp 	#4
.a6b3	b0 0c		bcs $a6c1			bcs 	_UPNotPlaying
.a6b5	09 20		ora #$20			ora 	#$20 						; query playing ?
.a6b7	20 2b ba	jsr $ba2b			jsr 	SNDCommand
.a6ba	c9 00		cmp #$00			cmp 	#0
.a6bc	f0 03		beq $a6c1			beq 	_UPNotPlaying
.a6be	4c 78 8e	jmp $8e78			jmp 	ReturnTrue
.a6c1					_UPNotPlaying:
.a6c1	4c 84 8e	jmp $8e84			jmp 	ReturnFalse

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/sound.asm

.a6c4					SoundCommand:
.a6c4	b1 30		lda ($30),y			lda 	(codePtr),y
.a6c6	c9 c0		cmp #$c0			cmp 	#KWD_OFF 					; SOUND OFF ?
.a6c8	d0 09		bne $a6d3			bne 	_SNDMain
.a6ca	c8		iny				iny 								; skip OFF
.a6cb	a9 3f		lda #$3f			lda 	#$3F 						; call command $3F (silence)
.a6cd	5a		phy				phy
.a6ce	20 2b ba	jsr $ba2b			jsr 	SNDCommand
.a6d1	7a		ply				ply
.a6d2	60		rts				rts
.a6d3					_SNDMain:
.a6d3	a2 00		ldx #$00			ldx 	#0
.a6d5	20 53 9e	jsr $9e53			jsr 	Evaluate8BitInteger 		; channel
.a6d8	c9 04		cmp #$04			cmp 	#4 							; must be 0-3
.a6da	b0 50		bcs $a72c			bcs 	_SndError
.a6dc	e8		inx				inx 								; do the rest in slot 1.
.a6dd	20 fa 8d	jsr $8dfa			jsr 	CheckComma
.a6e0	20 33 9e	jsr $9e33			jsr 	Evaluate16BitInteger 		; Pitch
.a6e3	bd 10 04	lda $0410,x			lda 	NSMantissa1,x 				; must be 10 bit
.a6e6	c9 10		cmp #$10			cmp 	#16
.a6e8	b0 42		bcs $a72c			bcs 	_SndError
.a6ea	8d 3b 06	sta $063b			sta 	SoundCommandBlock+1 		; Pitch (2 bytes + 0)
.a6ed	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a6f0	8d 3a 06	sta $063a			sta 	SoundCommandBlock
.a6f3	20 fa 8d	jsr $8dfa			jsr 	CheckComma
.a6f6	20 53 9e	jsr $9e53			jsr 	Evaluate8BitInteger 		; Length (1 byte + 3)
.a6f9	8d 3d 06	sta $063d			sta 	SoundCommandBlock+3
.a6fc	a9 0f		lda #$0f			lda 	#15
.a6fe	8d 3c 06	sta $063c			sta 	SoundCommandBlock+2 		; Volume (1 byte + 2)
.a701	9c 3e 06	stz $063e			stz 	SoundCommandBlock+4 		; default slide (2 bytes +4)
.a704	9c 3f 06	stz $063f			stz 	SoundCommandBlock+5
.a707	b1 30		lda ($30),y			lda 	(codePtr),y
.a709	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.a70b	d0 10		bne $a71d			bne 	_SNDPlay
.a70d	c8		iny				iny
.a70e	20 3f 9e	jsr $9e3f			jsr 	Evaluate16BitIntegerSigned 	; Slide
.a711	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; Slide (2 bytes + 4)
.a714	8d 3e 06	sta $063e			sta 	SoundCommandBlock+4
.a717	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a71a	8d 3f 06	sta $063f			sta 	SoundCommandBlock+5
.a71d					_SNDPlay:
.a71d	5a		phy				phy
.a71e	ad 08 04	lda $0408			lda 	NSMantissa0 				; channel.
.a721	09 10		ora #$10			ora 	#$10 						; 1x = Queue sound
.a723	a2 3a		ldx #$3a			ldx 	#(SoundCommandBlock & $FF)
.a725	a0 06		ldy #$06			ldy 	#(SoundCommandBlock >> 8)
.a727	20 2b ba	jsr $ba2b			jsr 	SNDCommand
.a72a	7a		ply				ply
.a72b	60		rts				rts
.a72c					_SndError:
.a72c	4c 61 a0	jmp $a061			jmp 	RangeError
.063a					SoundCommandBlock:
>063a							.fill 	6

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/bytes.asm

.a72f					StackPushByte:
.a72f	48		pha				pha 								; save byte
.a730	a5 34		lda $34				lda 	BasicStack
.a732	d0 09		bne $a73d			bne 	_SPBNoBorrow
.a734	c6 35		dec $35				dec 	BasicStack+1
.a736	48		pha				pha
.a737	a5 35		lda $35				lda 	BasicStack+1
.a739	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a73b	90 06		bcc $a743			bcc 	_SPBMemory
.a73d					_SPBNoBorrow:
.a73d	c6 34		dec $34				dec 	BasicStack
.a73f	68		pla				pla 								; get back and write
.a740	92 34		sta ($34)			sta 	(BasicStack)
.a742	60		rts				rts
.a743					_SPBMemory:
.a743	a9 12		lda #$12		lda	#18
.a745	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler
.a748					StackPopByte:
.a748	b2 34		lda ($34)			lda 	(BasicStack)
.a74a	e6 34		inc $34				inc 	BasicStack
.a74c	d0 02		bne $a750			bne 	_SPBNoCarry
.a74e	e6 35		inc $35				inc 	BasicStack+1
.a750					_SPBNoCarry:
.a750	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/frames.asm

.a751					StackOpen:
.a751	48		pha				pha 								; save frame byte
.a752	29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.a754	0a		asl a				asl 	a 							; claim twice this for storage
.a755	49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.a757	38		sec				sec 								; so basically subtracting from
.a758	65 34		adc $34				adc 	basicStack 	 				; basicStack
.a75a	85 34		sta $34				sta 	basicStack
.a75c	b0 08		bcs $a766			bcs 	_SONoBorrow
.a75e	c6 35		dec $35				dec 	basicStack+1
.a760	a5 35		lda $35				lda 	basicStack+1 				; have we reached stack overflow
.a762	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a764	90 04		bcc $a76a			bcc 	_SOMemory
.a766					_SONoBorrow:
.a766	68		pla				pla 								; get marker back and write at TOS
.a767	92 34		sta ($34)			sta 	(basicStack)
.a769	60		rts				rts
.a76a					_SOMemory:
.a76a	a9 12		lda #$12		lda	#18
.a76c	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler
.a76f					StackClose:
.a76f	b2 34		lda ($34)			lda 	(basicStack) 				; get TOS marker
.a771	29 0f		and #$0f			and 	#$0F 						; bytes to add back
.a773	0a		asl a				asl 	a 							; claim twice this.
.a774	65 34		adc $34				adc 	basicStack 					; add to the stack pointer.
.a776	85 34		sta $34				sta 	basicStack
.a778	90 02		bcc $a77c			bcc 	_SCExit
.a77a	e6 35		inc $35				inc 	basicStack+1
.a77c					_SCExit:
.a77c	60		rts				rts
.a77d					StackCheckFrame:
.a77d	48		pha				pha
.a77e					_StackRemoveLocals:
.a77e	b2 34		lda ($34)			lda 	(basicStack) 				; check for local, keep popping them
.a780	c9 03		cmp #$03			cmp 	#STK_LOCALS+1
.a782	b0 05		bcs $a789			bcs 	_SCNoLocal
.a784	20 0a 89	jsr $890a			jsr 	LocalPopValue
.a787	80 f5		bra $a77e			bra 	_StackRemoveLocals
.a789					_SCNoLocal:
.a789	68		pla				pla
.a78a	52 34		eor ($34)			eor 	(basicStack) 				; xor with toS marker
.a78c	29 f0		and #$f0			and 	#$F0 						; check type bits
.a78e	d0 01		bne $a791			bne 	_SCFError 					; different, we have structures mixed up
.a790	60		rts				rts
.a791					_SCFError:
.a791	8a		txa				txa 								; report error X
.a792	4c 0b 8e	jmp $8e0b			jmp 	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/location.asm

.a795					STKSaveCodePosition:
.a795	5a		phy				phy
.a796	98		tya				tya 								; save Y
.a797	a0 05		ldy #$05			ldy 	#5
.a799	91 34		sta ($34),y			sta 	(basicStack),y
.a79b	88		dey				dey 								; save Code Pointer
.a79c					_STKSaveLoop:
.a79c	b9 2f 00	lda $002f,y			lda 	safePtr-1,y 				; allows us to access the pointer w/out issues.
.a79f	91 34		sta ($34),y			sta 	(basicStack),y
.a7a1	88		dey				dey
.a7a2	d0 f8		bne $a79c			bne 	_STKSaveLoop
.a7a4	7a		ply				ply
.a7a5	60		rts				rts
.a7a6					STKLoadCodePosition:
.a7a6	a0 01		ldy #$01			ldy 	#1 							; load code pointer back
.a7a8					_STKLoadLoop:
.a7a8	b1 34		lda ($34),y			lda 	(basicStack),y
.a7aa	99 2f 00	sta $002f,y			sta 	safePtr-1,y
.a7ad	c8		iny				iny
.a7ae	c0 05		cpy #$05			cpy 	#5
.a7b0	d0 f6		bne $a7a8			bne 	_STKLoadLoop
.a7b2	b1 34		lda ($34),y			lda 	(basicStack),y 				; get Y offset
.a7b4	a8		tay				tay
.a7b5	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/setup.asm

.a7b6					StackReset:
.a7b6	a9 ff		lda #$ff			lda 	#((BasicStackBase+BasicStackSize-1) & $FF)
.a7b8	85 34		sta $34				sta 	0+basicStack
.a7ba	a9 0f		lda #$0f			lda 	#((BasicStackBase+BasicStackSize-1) >> 8)
.a7bc	85 35		sta $35				sta 	1+basicStack
.a7be	a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.a7c0	92 34		sta ($34)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.a7c2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/concrete.asm

.a7c3					StringConcrete:
.a7c3	5a		phy				phy 								; save position on stack
.a7c4	20 9b 9a	jsr $9a9b			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a7c7	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy target string to zTemp1
.a7ca	85 38		sta $38				sta 	zTemp1
.a7cc	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a7cf	85 39		sta $39				sta 	zTemp1+1
.a7d1	a0 ff		ldy #$ff			ldy 	#$FF	 					; calculate string length
.a7d3					_SALength:
.a7d3	c8		iny				iny
.a7d4	b1 38		lda ($38),y			lda 	(zTemp1),y
.a7d6	d0 fb		bne $a7d3			bne 	_SALength
.a7d8	c0 fd		cpy #$fd			cpy 	#253 						; string too long
.a7da	b0 3f		bcs $a81b			bcs 	_SALengthError
.a7dc	98		tya				tya 				 				; length of the new string
.a7dd	18		clc				clc
.a7de	69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.a7e0	90 02		bcc $a7e4			bcc 	_SAHaveLength
.a7e2	a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.a7e4					_SAHaveLength:
.a7e4	48		pha				pha 								; save length.
.a7e5	38		sec				sec
.a7e6	49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.a7e8	6d 8e 04	adc $048e			adc 	StringMemory
.a7eb	8d 8e 04	sta $048e			sta 	StringMemory
.a7ee	85 3a		sta $3a				sta 	zTemp2 						; update storage address
.a7f0	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; update mantissa address
.a7f3	a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.a7f5	6d 8f 04	adc $048f			adc 	StringMemory+1
.a7f8	8d 8f 04	sta $048f			sta 	StringMemory+1
.a7fb	85 3b		sta $3b				sta 	zTemp2+1
.a7fd	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a800	68		pla				pla 								; save length-3 (chars allowed) in first byte
.a801	38		sec				sec
.a802	e9 03		sbc #$03			sbc 	#3
.a804	92 3a		sta ($3a)			sta 	(zTemp2)
.a806	a9 00		lda #$00			lda 	#0 							; clear the status byte.
.a808	a0 01		ldy #$01			ldy 	#1
.a80a	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a80c					_SACopyNewString:
.a80c	a0 00		ldy #$00			ldy 	#0
.a80e					_SACopyNSLoop:
.a80e	b1 38		lda ($38),y			lda 	(zTemp1),y 					; get character
.a810	c8		iny				iny 								; write two on in string storage
.a811	c8		iny				iny
.a812	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a814	88		dey				dey 								; this makes it one one.
.a815	c9 00		cmp #$00			cmp 	#0 							; until EOS copied
.a817	d0 f5		bne $a80e			bne 	_SACopyNSLoop
.a819	7a		ply				ply
.a81a	60		rts				rts
.a81b					_SALengthError:
.a81b	a9 09		lda #$09		lda	#9
.a81d	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/stringalloc.asm

.a820					StringSystemInitialise:
.a820	a9 ff		lda #$ff			lda 	#((EndVariableSpace-1) & $FF)
.a822	8d 8e 04	sta $048e			sta 	0+StringMemory
.a825	a9 1f		lda #$1f			lda 	#((EndVariableSpace-1) >> 8)
.a827	8d 8f 04	sta $048f			sta 	1+StringMemory
.a82a	9c ff 1f	stz $1fff			stz 	EndVariableSpace-1 			; put a zero at the end, so know end of string memory.
.a82d	60		rts				rts
.a82e					StringSpaceInitialise:
.a82e	20 9b 9a	jsr $9a9b			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a831	a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.a833	8d 90 04	sta $0490			sta 	StringInitialised
.a836	ad 8e 04	lda $048e			lda 	StringMemory 				; allocate 256 bytes for one concreted string
.a839	8d 91 04	sta $0491			sta 	StringTempPointer
.a83c	ad 8f 04	lda $048f			lda 	StringMemory+1
.a83f	3a		dec a				dec 	a
.a840	8d 92 04	sta $0492			sta 	StringTempPointer+1
.a843	60		rts				rts
.a844					StringTempAllocate:
.a844	c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.a846	b0 35		bcs $a87d			bcs 	_STALength
.a848	2c 90 04	bit $0490			bit 	StringInitialised 			; already initialised
.a84b	30 05		bmi $a852			bmi 	_STAAllocate
.a84d	48		pha				pha 								; save value to subtract.
.a84e	20 2e a8	jsr $a82e			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.a851	68		pla				pla 								; restore it
.a852					_STAAllocate:
.a852	49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.a854	18		clc				clc  								; deliberate allows one more
.a855	6d 91 04	adc $0491			adc 	StringTempPointer 			; subtract from temp pointer
.a858	8d 91 04	sta $0491			sta 	StringTempPointer
.a85b	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; address in mantissa
.a85e	85 3c		sta $3c				sta 	zsTemp 						; and zsTemp
.a860	ad 92 04	lda $0492			lda 	StringTempPointer+1
.a863	69 ff		adc #$ff			adc 	#$FF
.a865	8d 92 04	sta $0492			sta 	StringTempPointer+1
.a868	85 3d		sta $3d				sta 	zsTemp+1
.a86a	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a86d	9e 18 04	stz $0418,x			stz 	NSMantissa2,x 				; set the typing data
.a870	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.a873	a9 10		lda #$10			lda 	#NSTString
.a875	9d 00 04	sta $0400,x			sta 	NSStatus,x
.a878	a9 00		lda #$00			lda 	#0 							; clear the target string
.a87a	92 3c		sta ($3c)			sta 	(zsTemp)
.a87c	60		rts				rts
.a87d					_STALength:
.a87d	a9 09		lda #$09		lda	#9
.a87f	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler
.a882					StringTempWrite:
.a882	48		pha				pha
.a883	92 3c		sta ($3c)			sta 	(zsTemp)
.a885	e6 3c		inc $3c				inc 	zsTemp
.a887	d0 02		bne $a88b			bne 	_STWNoCarry
.a889	e6 3d		inc $3d				inc 	zsTemp+1
.a88b					_STWNoCarry:
.a88b	a9 00		lda #$00			lda 	#0
.a88d	92 3c		sta ($3c)			sta 	(zsTemp)
.a88f	68		pla				pla
.a890	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_hardware.module

=1					hardwareIntegrated=1
=0					CONBlack = 0
=1					CONWhite = 1
=2					CONRed = 2
=3					CONCyan = 3
=4					CONPurple = 4
=5					CONGreen = 5
=6					CONBlue = 6
=7					CONYellow = 7
=8					CONOrange = 8
=9					CONBrown = 9
=10					CONYellowGreen = 10
=11					CONRosa = 11
=12					CONBlueGreen = 12
=13					CONLightBlue = 13
=14					CONPink = 14
=15					CONLightGreen = 15
=7					CONForeground = CONYellow
=6					CONBackground = CONBlue
=12					CLINumber = CONBlueGreen
=3					CLIToken = CONCyan
=13					CLIConstant = CONLightBlue
=7					CLIIdentifier = CONYellow
=10					CLIPunctuation = CONYellowGreen
=1					CLIData = CONWhite
.a891					EXTPrintCharacter:
.a891	48		pha				pha
.a892	da		phx				phx
.a893	5a		phy				phy
.a894	a6 01		ldx $01				ldx 	1
.a896	da		phx				phx
.a897	ac 41 06	ldy $0641			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.a89a	09 00		ora #$00			ora 	#$00 						; check $80-$FF
.a89c	30 48		bmi $a8e6			bmi 	_EXPCColour
.a89e	c9 20		cmp #$20			cmp 	#$20 						; check $00-$1F
.a8a0	90 4d		bcc $a8ef			bcc 	_EXPCControl
.a8a2	a2 02		ldx #$02			ldx 	#2 							; select char memory
.a8a4	86 01		stx $01				stx 	1
.a8a6	91 40		sta ($40),y			sta 	(EXTAddress),y
.a8a8	e6 01		inc $01				inc 	1 							; select colour memory
.a8aa	ad 42 06	lda $0642			lda 	EXTTextColour
.a8ad	91 40		sta ($40),y			sta 	(EXTAddress),y
.a8af	c8		iny				iny 								; advance horizontal position
.a8b0	8c 41 06	sty $0641			sty 	EXTColumn
.a8b3	cc 43 06	cpy $0643			cpy 	EXTScreenWidth 				; reached RHS ?
.a8b6	90 66		bcc $a91e			bcc 	_EXPCExit 					; no, then exit.
.a8b8					_EXPCCRLF:
.a8b8	ee 40 06	inc $0640			inc 	EXTRow  					; bump row
.a8bb	9c 41 06	stz $0641			stz 	EXTColumn 					; back to column 0
.a8be	ad 40 06	lda $0640			lda 	EXTRow 						; check if reached the bottom ?
.a8c1	cd 44 06	cmp $0644			cmp 	EXTScreenHeight 			; if so, then scroll.
.a8c4	f0 18		beq $a8de			beq 	_EXPCScroll
.a8c6	18		clc				clc 								; add width to address.
.a8c7	a5 40		lda $40				lda 	EXTAddress
.a8c9	6d 43 06	adc $0643			adc 	EXTScreenWidth
.a8cc	85 40		sta $40				sta 	EXTAddress
.a8ce	90 4e		bcc $a91e			bcc 	_EXPCExit
.a8d0	e6 41		inc $41				inc 	EXTAddress+1
.a8d2	80 4a		bra $a91e			bra 	_EXPCExit
.a8d4					_EXPCLeft:
.a8d4	ce 41 06	dec $0641			dec 	EXTColumn
.a8d7	10 45		bpl $a91e			bpl 	_EXPCExit
.a8d9					_EXPCBegin:
.a8d9	9c 41 06	stz $0641			stz 	EXTColumn
.a8dc	80 40		bra $a91e			bra 	_EXPCExit
.a8de					_EXPCScroll:
.a8de	ce 40 06	dec $0640			dec 	EXTRow 						; the height-1 th line.
.a8e1	20 ab a9	jsr $a9ab			jsr 	EXTScreenScroll 			; scroll the screen
.a8e4	80 38		bra $a91e			bra 	_EXPCExit
.a8e6					_EXPCColour:
.a8e6	c9 a0		cmp #$a0			cmp 	#$A0						; 80-9F set foreground/background
.a8e8	b0 34		bcs $a91e			bcs 	_EXPCExit
.a8ea	20 8b a9	jsr $a98b			jsr 	_EXPCHandleColour
.a8ed	80 2f		bra $a91e			bra 	_EXPCExit
.a8ef					_EXPCControl:
.a8ef	c9 11		cmp #$11			cmp 	#$11 						; only handle 00-10.
.a8f1	b0 2b		bcs $a91e			bcs 	_EXPCExit
.a8f3	0a		asl a				asl 	a 							; double into X
.a8f4	aa		tax				tax
.a8f5	7c 69 a9	jmp ($a969,x)			jmp 	(_EXPCActionTable,x) 		; and execute code.
.a8f8					_EXPCUp:
.a8f8	ad 40 06	lda $0640			lda 	EXTRow 						; already at top ?
.a8fb	f0 21		beq $a91e			beq 	_EXPCExit
.a8fd	ce 40 06	dec $0640			dec 	EXTRow 						; up one in position/address
.a900	38		sec				sec
.a901	a5 40		lda $40				lda 	EXTAddress
.a903	ed 43 06	sbc $0643			sbc 	EXTScreenWidth
.a906	85 40		sta $40				sta 	EXTAddress
.a908	b0 14		bcs $a91e			bcs 	_EXPCExit
.a90a	c6 41		dec $41				dec 	EXTAddress+1
.a90c	80 10		bra $a91e			bra 	_EXPCExit
.a90e					_EXPCRight:
.a90e	c8		iny				iny
.a90f	8c 41 06	sty $0641			sty 	EXTColumn
.a912	cc 43 06	cpy $0643			cpy 	EXTScreenWidth
.a915	d0 07		bne $a91e			bne 	_EXPCExit
.a917					_EXPCEnd:
.a917	ad 43 06	lda $0643			lda 	EXTScreenWidth
.a91a	3a		dec a				dec 	a
.a91b	8d 41 06	sta $0641			sta 	EXTColumn
.a91e					_EXPCExit:
.a91e	20 00 aa	jsr $aa00			jsr 	EXTSetHardwareCursor 		; place the physical cursor.
.a921	68		pla				pla
.a922	85 01		sta $01				sta 	1
.a924	7a		ply				ply
.a925	fa		plx				plx
.a926	68		pla				pla
.a927	60		rts				rts
.a928					_EXPCClearScreen:
.a928	20 bd a9	jsr $a9bd			jsr		EXTClearScreenCode
.a92b	80 f1		bra $a91e			bra 	_EXPCExit
.a92d					_EXPCDown:
.a92d	ad 44 06	lda $0644			lda 	EXTScreenHeight 			; at the bottom
.a930	3a		dec a				dec 	a
.a931	cd 40 06	cmp $0640			cmp 	EXTRow
.a934	f0 e8		beq $a91e			beq 	_EXPCExit
.a936	ee 40 06	inc $0640			inc 	EXTRow 						; down one in position/address
.a939	18		clc				clc
.a93a	a5 40		lda $40				lda 	EXTAddress
.a93c	6d 43 06	adc $0643			adc 	EXTScreenWidth
.a93f	85 40		sta $40				sta 	EXTAddress
.a941	90 db		bcc $a91e			bcc 	_EXPCExit
.a943	e6 41		inc $41				inc 	EXTAddress+1
.a945	80 d7		bra $a91e			bra 	_EXPCExit
.a947					_EXPCTab:
.a947	ad 41 06	lda $0641			lda 	EXTColumn 					; next tab stop
.a94a	29 f8		and #$f8			and 	#$F8
.a94c	18		clc				clc
.a94d	69 08		adc #$08			adc 	#8
.a94f	8d 41 06	sta $0641			sta 	EXTColumn
.a952	cd 43 06	cmp $0643			cmp 	EXTScreenWidth 				; too far, stick end of line.
.a955	90 c7		bcc $a91e			bcc 	_EXPCExit
.a957	80 be		bra $a917			bra 	_EXPCEnd
.a959					_EXPCBackSpace:
.a959	88		dey				dey
.a95a	30 c2		bmi $a91e			bmi 	_EXPCExit
.a95c	ce 41 06	dec $0641			dec 	EXTColumn
.a95f	a9 02		lda #$02			lda 	#2
.a961	85 01		sta $01				sta 	1
.a963	a9 20		lda #$20			lda 	#32
.a965	91 40		sta ($40),y			sta 	(EXTAddress),y
.a967	80 b5		bra $a91e			bra 	_EXPCExit
.a969					_EXPCActionTable:
>a969	1e a9						.word 	_EXPCExit 					; 00
>a96b	d9 a8						.word 	_EXPCBegin 					; 01 A Start of Line
>a96d	d4 a8						.word 	_EXPCLeft 					; 02 B Left
>a96f	1e a9						.word 	_EXPCExit 					; 03 <Break>
>a971	1e a9						.word 	_EXPCExit 					; 04
>a973	17 a9						.word 	_EXPCEnd 					; 05 E End of Line
>a975	0e a9						.word 	_EXPCRight 					; 06 F Right
>a977	1e a9						.word 	_EXPCExit 					; 07
>a979	59 a9						.word 	_EXPCBackspace 				; 08 H Backspace
>a97b	47 a9						.word 	_EXPCTab 					; 09 I Tab
>a97d	1e a9						.word 	_EXPCExit 					; 0A
>a97f	1e a9						.word 	_EXPCExit 					; 0B
>a981	28 a9						.word 	_EXPCClearScreen			; 0C L CLS
>a983	b8 a8						.word 	_EXPCCRLF 					; 0D M CR/LF
>a985	2d a9						.word 	_EXPCDown 					; 0E N Down
>a987	1e a9						.word 	_EXPCExit 					; 0F
>a989	f8 a8						.word 	_EXPCUp 					; 10 P Up
.a98b					_EXPCHandleColour
.a98b	c9 90		cmp #$90			cmp 	#$90 						; 8x foreground 9x background
.a98d	b0 16		bcs $a9a5			bcs 	_EXPCBackground
.a98f	0a		asl a				asl 	a 							; shift it 4 bits to the right.
.a990	0a		asl a				asl 	a
.a991	0a		asl a				asl 	a
.a992	0a		asl a				asl 	a
.a993	a2 0f		ldx #$0f			ldx 	#$0F 						; Mask in X
.a995					_EXPCUpdate:
.a995	48		pha				pha 								; save new colour
.a996	8a		txa				txa 								; get mask
.a997	2d 42 06	and $0642			and 	EXTTextColour 				; mask out old.
.a99a	8d 42 06	sta $0642			sta 	EXTTextColour
.a99d	68		pla				pla 								; or in new colour
.a99e	0d 42 06	ora $0642			ora 	EXTTextColour
.a9a1	8d 42 06	sta $0642			sta 	EXTTextColour
.a9a4	60		rts				rts
.a9a5					_EXPCBackground:
.a9a5	29 0f		and #$0f			and 	#$0F 						; get the colour
.a9a7	a2 f0		ldx #$f0			ldx 	#$F0 						; mask
.a9a9	80 ea		bra $a995			bra 	_EXPCUpdate
.a9ab					EXTScreenScroll:
.a9ab	a9 02		lda #$02			lda 	#2 							; select text page
.a9ad	85 01		sta $01				sta 	1
.a9af	a9 20		lda #$20			lda		#32 						; fill with space
.a9b1	20 c0 aa	jsr $aac0			jsr 	EXTScrollFill
.a9b4	e6 01		inc $01				inc 	1 							; select colour page
.a9b6	ad 42 06	lda $0642			lda 	EXTTextColour
.a9b9	20 c0 aa	jsr $aac0			jsr 	EXTScrollFill
.a9bc	60		rts				rts
.a9bd					EXTClearScreenCode:
.a9bd	a9 02		lda #$02			lda 	#2 							; select text page
.a9bf	85 01		sta $01				sta 	1
.a9c1	a9 20		lda #$20			lda		#32 						; fill with space
.a9c3	20 d0 a9	jsr $a9d0			jsr 	_EXTCSFill
.a9c6	e6 01		inc $01				inc 	1 							; select colour page
.a9c8	ad 42 06	lda $0642			lda 	EXTTextColour
.a9cb	20 d0 a9	jsr $a9d0			jsr 	_EXTCSFill
.a9ce	80 22		bra $a9f2			bra 	EXTHomeCursor
.a9d0					_EXTCSFill:
.a9d0	aa		tax				tax
.a9d1	a9 00		lda #$00			lda 	#EXTMemory & $FF
.a9d3	85 40		sta $40				sta 	EXTAddress
.a9d5	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a9d7	85 41		sta $41				sta 	EXTAddress+1
.a9d9					_EXTCSFill1:
.a9d9	a0 00		ldy #$00			ldy 	#0
.a9db	8a		txa				txa
.a9dc					_EXTCSFill2:
.a9dc	91 40		sta ($40),y			sta 	(EXTAddress),y
.a9de	c8		iny				iny
.a9df	d0 fb		bne $a9dc			bne 	_EXTCSFill2
.a9e1	e6 41		inc $41				inc 	EXTAddress+1
.a9e3	a5 41		lda $41				lda 	EXTAddress+1
.a9e5	c9 d2		cmp #$d2			cmp 	#$D2
.a9e7	d0 f0		bne $a9d9			bne 	_EXTCSFill1
.a9e9	8a		txa				txa
.a9ea					_EXTCSFill3:
.a9ea	91 40		sta ($40),y			sta 	(EXTAddress),y
.a9ec	c8		iny				iny
.a9ed	c0 c0		cpy #$c0			cpy 	#$C0
.a9ef	d0 f9		bne $a9ea			bne 	_EXTCSFill3
.a9f1	60		rts				rts
.a9f2					EXTHomeCursor:
.a9f2	9c 40 06	stz $0640			stz 	EXTRow 						; reset row & column
.a9f5	9c 41 06	stz $0641			stz 	EXTColumn
.a9f8	a9 00		lda #$00			lda 	#EXTMemory & $FF 			; set address
.a9fa	85 40		sta $40				sta 	EXTAddress
.a9fc	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a9fe	85 41		sta $41				sta 	EXTAddress+1
.aa00					EXTSetHardwareCursor:
.aa00	64 01		stz $01				stz 	1 							; I/O Page zero
.aa02	a9 05		lda #$05			lda 	#1+4 						; enable cursor
.aa04	8d 10 d0	sta $d010			sta 	$D010
.aa07	a9 b1		lda #$b1			lda 	#$B1
.aa09	8d 12 d0	sta $d012			sta 	$D012
.aa0c	ad 41 06	lda $0641			lda 	EXTColumn
.aa0f	8d 14 d0	sta $d014			sta 	$D014 						; set cursor position
.aa12	9c 15 d0	stz $d015			stz 	$D015
.aa15	ad 40 06	lda $0640			lda 	EXTRow
.aa18	8d 16 d0	sta $d016			sta 	$D016
.aa1b	9c 17 d0	stz $d017			stz 	$D017
.aa1e	60		rts				rts
.aa1f					EXTInputLine:
.aa1f	48		pha				pha
.aa20	da		phx				phx
.aa21	5a		phy				phy
.aa22	a5 01		lda $01				lda 	1 							; save I/O page
.aa24	48		pha				pha
.aa25					_EILLoop:
.aa25	20 27 ab	jsr $ab27			jsr 	ExtInputSingleCharacter
.aa28	c9 0d		cmp #$0d			cmp 	#13 						; scrape line if exit.
.aa2a	f0 40		beq $aa6c			beq 	_EILExit
.aa2c	c9 08		cmp #$08			cmp 	#8 							; handle backspace
.aa2e	f0 1c		beq $aa4c			beq 	_EILBackspace
.aa30	c9 20		cmp #$20			cmp 	#' '						; < space, print it
.aa32	90 12		bcc $aa46			bcc 	_EILPrintLoop
.aa34	c9 7f		cmp #$7f			cmp 	#$7F 						; if -ve print it
.aa36	b0 0e		bcs $aa46			bcs 	_EILPrintLoop
.aa38	48		pha				pha 								; save character
.aa39	a9 02		lda #$02			lda 	#2  						; insert a space
.aa3b	85 01		sta $01				sta 	1
.aa3d	20 ae aa	jsr $aaae			jsr 	EXTILInsert 				; insert in text screen
.aa40	e6 01		inc $01				inc 	1
.aa42	20 ae aa	jsr $aaae			jsr 	EXTILInsert 				; insert in colour screen
.aa45	68		pla				pla 								; get character back.
.aa46					_EILPrintLoop:
.aa46	20 91 a8	jsr $a891			jsr 	ExtPrintCharacter
.aa49	80 da		bra $aa25			bra 	_EILLoop
.aa4b	60		rts				rts
.aa4c					_EILBackspace:
.aa4c	ad 41 06	lda $0641			lda 	EXTColumn					; can we backspace ?
.aa4f	f0 d4		beq $aa25			beq 	_EILLoop
.aa51	a9 02		lda #$02			lda 	#2 							; move cursor left
.aa53	20 91 a8	jsr $a891			jsr 	EXTPrintCharacter
.aa56	a9 02		lda #$02			lda 	#2 							; text block
.aa58	85 01		sta $01				sta 	1
.aa5a	a9 20		lda #$20			lda 	#' ' 						; backspace text.
.aa5c	20 99 aa	jsr $aa99			jsr 	EXTILDelete
.aa5f	e6 01		inc $01				inc 	1 							; colour block
.aa61	ac 41 06	ldy $0641			ldy 	EXTColumn 					; get attribute of last character
.aa64	88		dey				dey
.aa65	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa67	20 99 aa	jsr $aa99			jsr 	EXTILDelete 				; backspace attribute
.aa6a	80 b9		bra $aa25			bra 	_EILLoop 					; and go round.
.aa6c					_EILExit:
.aa6c	a9 02		lda #$02			lda 	#2 							; switch to page 2
.aa6e	85 01		sta $01				sta 	1
.aa70	a0 00		ldy #$00			ldy 	#0 							; copy current line into buffer.
.aa72					_EILScrapeLine:
.aa72	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa74	99 aa 05	sta $05aa,y			sta 	lineBuffer,y
.aa77	c8		iny				iny
.aa78	cc 43 06	cpy $0643			cpy 	EXTScreenWidth
.aa7b	d0 f5		bne $aa72			bne 	_EILScrapeLine
.aa7d					_EILTrimSpaces:
.aa7d	88		dey				dey
.aa7e	f0 08		beq $aa88			beq 	_EILEndTrim
.aa80	b9 aa 05	lda $05aa,y			lda 	lineBuffer,y
.aa83	c9 20		cmp #$20			cmp 	#' '
.aa85	f0 f6		beq $aa7d			beq 	_EILTrimSpaces
.aa87	c8		iny				iny 								; trim after non space character.
.aa88					_EILEndTrim:
.aa88	a9 00		lda #$00			lda 	#0 							; trim here.
.aa8a	99 aa 05	sta $05aa,y			sta 	lineBuffer,y
.aa8d	a9 0d		lda #$0d			lda 	#13 						; echo the RETURN
.aa8f	20 91 a8	jsr $a891			jsr 	ExtPrintCharacter
.aa92	68		pla				pla 								; reset I/O page
.aa93	85 01		sta $01				sta 	1
.aa95	7a		ply				ply
.aa96	fa		plx				plx
.aa97	68		pla				pla
.aa98	60		rts				rts
.aa99					EXTILDelete:
.aa99	48		pha				pha 								; save the new character
.aa9a	ac 41 06	ldy $0641			ldy 	EXTColumn 					; start copying from here.
.aa9d					_EXTDLoop:
.aa9d	c8		iny				iny 								; copy one byte down.
.aa9e	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aaa0	88		dey				dey
.aaa1	91 40		sta ($40),y			sta 	(EXTAddress),y
.aaa3	c8		iny				iny 								; do till end of line.
.aaa4	cc 43 06	cpy $0643			cpy 	EXTScreenWidth
.aaa7	90 f4		bcc $aa9d			bcc 	_EXTDLoop
.aaa9	88		dey				dey 	 							; write in last slot.
.aaaa	68		pla				pla
.aaab	91 40		sta ($40),y			sta 	(EXTAddress),y
.aaad	60		rts				rts
.aaae					EXTILInsert:
.aaae	ac 43 06	ldy $0643			ldy 	EXTScreenWidth 				; end position
.aab1					_EXTILoop:
.aab1	88		dey				dey 								; back one
.aab2	cc 41 06	cpy $0641			cpy 	EXTColumn 					; exit if reached insert point.
.aab5	f0 08		beq $aabf			beq 	_EXTIExit
.aab7	88		dey				dey 								; copy one byte up.
.aab8	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aaba	c8		iny				iny
.aabb	91 40		sta ($40),y			sta 	(EXTAddress),y
.aabd	80 f2		bra $aab1			bra 	_EXTILoop
.aabf					_EXTIExit:
.aabf	60		rts				rts
.aac0					EXTScrollFill:
.aac0	aa		tax				tax									; save value to fill with
.aac1	a5 36		lda $36				lda 	zTemp0 						; save zTemp0 (dest) zTemp1 (src)
.aac3	48		pha				pha
.aac4	a5 37		lda $37				lda 	zTemp0+1
.aac6	48		pha				pha
.aac7	a5 38		lda $38				lda 	zTemp1
.aac9	48		pha				pha
.aaca	a5 39		lda $39				lda 	zTemp1+1
.aacc	48		pha				pha
.aacd	a9 c0		lda #$c0			lda 	#$C0 						; copy from C000+length to C000
.aacf	85 37		sta $37				sta 	zTemp0+1
.aad1	85 39		sta $39				sta 	zTemp1+1
.aad3	64 36		stz $36				stz 	zTemp0
.aad5	ad 43 06	lda $0643			lda 	EXTScreenWidth
.aad8	85 38		sta $38				sta 	zTemp1
.aada	a0 00		ldy #$00			ldy 	#0
.aadc					_EXSFCopy1:
.aadc	b1 38		lda ($38),y			lda 	(zTemp1),y
.aade	91 36		sta ($36),y			sta 	(zTemp0),y
.aae0	c8		iny				iny
.aae1	d0 f9		bne $aadc			bne 	_EXSFCopy1
.aae3	e6 37		inc $37				inc 	zTemp0+1 					; next page
.aae5	e6 39		inc $39				inc 	zTemp1+1
.aae7	a5 39		lda $39				lda 	zTemp1+1
.aae9	c9 d3		cmp #$d3			cmp 	#$D3
.aaeb	d0 ef		bne $aadc			bne 	_EXSFCopy1
.aaed	ac 43 06	ldy $0643			ldy 	EXTScreenWidth 				; blank the bottom line.
.aaf0	8a		txa				txa
.aaf1					_EXSFFill1:
.aaf1	88		dey				dey
.aaf2	91 40		sta ($40),y			sta 	(EXTAddress),y
.aaf4	c0 00		cpy #$00			cpy 	#0
.aaf6	10 f9		bpl $aaf1			bpl 	_EXSFFill1
.aaf8	68		pla				pla
.aaf9	85 39		sta $39				sta 	zTemp1+1
.aafb	68		pla				pla
.aafc	85 38		sta $38				sta 	zTemp1
.aafe	68		pla				pla
.aaff	85 37		sta $37				sta 	zTemp0+1
.ab01	68		pla				pla
.ab02	85 36		sta $36				sta 	zTemp0
.ab04	60		rts				rts
=$c000					EXTMemory = $C000
=$02					EXTTextPage = $02
=$03					EXTColourPage = $03
=1					EXTDummySpace = 1 							; fake-space for CR character.
=0					EXTCBlack = 0
.0640					EXTRow:
>0640							.fill 	1
.0641					EXTColumn:
>0641							.fill 	1
.0642					EXTTextColour:
>0642							.fill 	1
.0643					EXTScreenWidth:
>0643							.fill 	1
.0644					EXTScreenHeight:
>0644							.fill 	1
.0040					EXTAddress:
>0040							.fill 	2
.ab05					EXTInitialise:
.ab05	64 01		stz $01				stz 	1 							; Access I/O
.ab07	9c 04 d0	stz $d004			stz 	$D004 						; Disable border
.ab0a	9c 08 d0	stz $d008			stz 	$D008
.ab0d	9c 09 d0	stz $d009			stz 	$D009
.ab10	a9 09		lda #$09			lda 	#1+8						; Timer On at 70Hz counting up.
.ab12	8d 58 d6	sta $d658			sta 	$D658
.ab15	a9 76		lda #$76			lda 	#CONForeground * 16 + CONBackground
.ab17	8d 42 06	sta $0642			sta 	EXTTextColour
.ab1a	a9 50		lda #$50			lda 	#80 						; set screen dimensions.
.ab1c	8d 43 06	sta $0643			sta 	EXTScreenWidth
.ab1f	a9 3c		lda #$3c			lda 	#60
.ab21	8d 44 06	sta $0644			sta 	EXTScreenHeight
.ab24	64 01		stz $01				stz 	1
.ab26	60		rts				rts
.ab27					EXTInputSingleCharacter:
.ab27	da		phx				phx
.ab28	5a		phy				phy
.ab29					_EISCWait:
.ab29	64 01		stz $01				stz 	1 							; access I/O Page 0
.ab2b	38		sec				sec 								; calculate timer - LastTick
.ab2c	ad 59 d6	lda $d659			lda 	$D659
.ab2f	aa		tax				tax 								; saving timer in X
.ab30	ed 2f 06	sbc $062f			sbc 	LastTick
.ab33	c9 03		cmp #$03			cmp 	#3
.ab35	90 06		bcc $ab3d			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.ab37	8e 2f 06	stx $062f			stx 	LastTick 					; update last timer
.ab3a	20 b8 ba	jsr $bab8			jsr 	TickHandler 				; go do the code.
.ab3d					_NoFireTick:
.ab3d	20 e4 ff	jsr $ffe4			jsr 	$FFE4
.ab40	c9 00		cmp #$00			cmp 	#0
.ab42	f0 e5		beq $ab29			beq 	_EISCWait
.ab44	7a		ply				ply
.ab45	fa		plx				plx
.ab46	60		rts				rts
.ab47					EXTBreakCheck:
.ab47	4c e1 ff	jmp $ffe1			jmp		$FFE1
.ab4a					EXTReadController:
.ab4a	da		phx				phx
.ab4b	a2 00		ldx #$00			ldx 	#0
.ab4d	a9 05		lda #$05			lda 	#(($2D) >> 3)
.ab4f	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab52	29 20		and #$20			and 	#($01 << (($2D) & 7))
.ab54	f0 04		beq $ab5a			beq 	_NoSet1
.ab56	8a		txa				txa
.ab57	09 01		ora #$01			ora 	#1
.ab59	aa		tax				tax
.ab5a					_NoSet1:
.ab5a	a9 05		lda #$05			lda 	#(($2C) >> 3)
.ab5c	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab5f	29 10		and #$10			and 	#($01 << (($2C) & 7))
.ab61	f0 04		beq $ab67			beq 	_NoSet1
.ab63	8a		txa				txa
.ab64	09 02		ora #$02			ora 	#2
.ab66	aa		tax				tax
.ab67					_NoSet1:
.ab67	a9 06		lda #$06			lda 	#(($32) >> 3)
.ab69	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab6c	29 04		and #$04			and 	#($01 << (($32) & 7))
.ab6e	f0 04		beq $ab74			beq 	_NoSet1
.ab70	8a		txa				txa
.ab71	09 04		ora #$04			ora 	#4
.ab73	aa		tax				tax
.ab74					_NoSet1:
.ab74	a9 04		lda #$04			lda 	#(($25) >> 3)
.ab76	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab79	29 20		and #$20			and 	#($01 << (($25) & 7))
.ab7b	f0 04		beq $ab81			beq 	_NoSet1
.ab7d	8a		txa				txa
.ab7e	09 08		ora #$08			ora 	#8
.ab80	aa		tax				tax
.ab81					_NoSet1:
.ab81	a9 04		lda #$04			lda 	#(($26) >> 3)
.ab83	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab86	29 40		and #$40			and 	#($01 << (($26) & 7))
.ab88	f0 04		beq $ab8e			beq 	_NoSet1
.ab8a	8a		txa				txa
.ab8b	09 10		ora #$10			ora 	#16
.ab8d	aa		tax				tax
.ab8e					_NoSet1:
.ab8e	8a		txa				txa
.ab8f	fa		plx				plx
.ab90	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_graphics.module

=1					graphicsIntegrated=1
=0					GCMD_Initialise = 0*2
=2					GCMD_BitmapCtl = 1*2
=4					GCMD_SpriteCtl = 2*2
=6					GCMD_Clear = 3*2
=8					GCMD_Colour = 4*2
=10					GCMD_DrawFont = 5*2
=12					GCMD_DrawSprite = 6*2
=14					GCMD_SpriteUse = 7*2
=16					GCMD_SpriteImage = 8*2
=18					GCMD_SpriteCollide = 9*2
=64					GCMD_Move = 32*2
=66					GCMD_Line = 33*2
=68					GCMD_FrameRect = 34*2
=70					GCMD_FillRect = 35*2
=72					GCMD_FrameCircle = 36*2
=74					GCMD_FillCircle = 37*2
=80					GCMD_Plot = 40*2
=82					GCMD_SpriteMove = 41*2
=42					GRFirstFreeCode = 42
.babe					GRVectorTable:
>babe	8c ad					.word	GXInitialise             ; $00 Initialise
>bac0	a6 ad					.word	GXControlBitmap          ; $01 BitmapCtl
>bac2	ee ad					.word	GXControlSprite          ; $02 SpriteCtl
>bac4	3e ad					.word	GXClearBitmap            ; $03 Clear
>bac6	7d af					.word	GXSetColourMode          ; $04 Colour
>bac8	45 b1					.word	GXFontHandler            ; $05 DrawFont
>baca	8d b1					.word	GXSpriteHandler          ; $06 DrawSprite
>bacc	f9 b1					.word	GXSelect                 ; $07 SpriteUse
>bace	22 b2					.word	GXSelectImage            ; $08 SpriteImage
>bad0	a9 b3					.word	GXCollide                ; $09 SpriteCollide
>bad2	f0 ab					.word	GRUndefined              ; $0a
>bad4	f0 ab					.word	GRUndefined              ; $0b
>bad6	f0 ab					.word	GRUndefined              ; $0c
>bad8	f0 ab					.word	GRUndefined              ; $0d
>bada	f0 ab					.word	GRUndefined              ; $0e
>badc	f0 ab					.word	GRUndefined              ; $0f
>bade	f0 ab					.word	GRUndefined              ; $10
>bae0	f0 ab					.word	GRUndefined              ; $11
>bae2	f0 ab					.word	GRUndefined              ; $12
>bae4	f0 ab					.word	GRUndefined              ; $13
>bae6	f0 ab					.word	GRUndefined              ; $14
>bae8	f0 ab					.word	GRUndefined              ; $15
>baea	f0 ab					.word	GRUndefined              ; $16
>baec	f0 ab					.word	GRUndefined              ; $17
>baee	f0 ab					.word	GRUndefined              ; $18
>baf0	f0 ab					.word	GRUndefined              ; $19
>baf2	f0 ab					.word	GRUndefined              ; $1a
>baf4	f0 ab					.word	GRUndefined              ; $1b
>baf6	f0 ab					.word	GRUndefined              ; $1c
>baf8	f0 ab					.word	GRUndefined              ; $1d
>bafa	f0 ab					.word	GRUndefined              ; $1e
>bafc	f0 ab					.word	GRUndefined              ; $1f
>bafe	ee ab					.word	GXMove                   ; $20 Move
>bb00	4b ae					.word	GXLine                   ; $21 Line
>bb02	c6 af					.word	GXFrameRectangle         ; $22 FrameRect
>bb04	c3 af					.word	GXFillRectangle          ; $23 FillRect
>bb06	f5 ab					.word	GXFrameCircle            ; $24 FrameCircle
>bb08	f1 ab					.word	GXFillCircle             ; $25 FillCircle
>bb0a	f0 ab					.word	GRUndefined              ; $26
>bb0c	f0 ab					.word	GRUndefined              ; $27
>bb0e	ab af					.word	GXPlotPoint              ; $28 Plot
>bb10	b8 b2					.word	GXMoveSprite             ; $29 SpriteMove
=3					GXMappingPage = 3
=24576					GXMappingAddress = ($2000 * GXMappingPage)
=11					GXEditSlot = 8 + GXMappingPage
=$36					gxzTemp0 = zTemp0
=$38					gxzTemp1 = zTemp1
=$3a					gxzTemp2 = zTemp2
=$3c					gxzScreen = zsTemp
=$5fb					gxPixelBuffer = numberBuffer
.0645					gxCurrentX:
>0645							.fill 	2
.0647					gxCurrentY:
>0647							.fill 	2
.0649					gxLastX:
>0649							.fill 	2
.064b					gxLastY:
>064b							.fill 	2
.064d					gxX0:
>064d							.fill 	2
.064f					gxY0:
>064f							.fill 	2
.0651					gxX1:
>0651							.fill 	2
.0653					gxY1:
>0653							.fill 	2
.0655					gxSpritesOn:
>0655							.fill 	1
.0656					gxBitmapsOn:
>0656							.fill 	1
.0657					gxBasePage:
>0657							.fill 	1
.0658					gxSpritePage:
>0658							.fill 	1
.0659					gxHeight:
>0659							.fill 	1
.065a					gxMode:
>065a							.fill 	1
.065b					gxColour:
>065b							.fill 	1
.065c					gxEORValue:
>065c							.fill 	1
.065d					gxANDValue:
>065d							.fill 	1
.065e					gxOriginalLUTValue:
>065e							.fill 	1
.065f					gsOffset:
>065f							.fill 	1
.0660					GSCurrentSpriteID:
>0660							.fill 	1
.0661					GSCurrentSpriteAddr:
>0661							.fill 	2
.0663					GXSpriteOffsetBase:
>0663							.fill 	2
.0665					GXSpriteLow:
>0665							.fill 	64
.06a5					GXSpriteHigh:
>06a5							.fill 	64
.ab91					GXGraphicDraw:
.ab91	c9 40		cmp #$40			cmp 	#GCMD_Move					; low instructions don't use coordinates
.ab93	b0 06		bcs $ab9b			bcs 	_GDCoordinate
.ab95	86 36		stx $36				stx 	gxzTemp0 					; save X/Y
.ab97	84 37		sty $37				sty 	gxzTemp0+1
.ab99	80 4b		bra $abe6			bra 	_GDExecuteA 				; and execute
.ab9b					_GDCoordinate:
.ab9b	48		pha				pha 								; save AXY
.ab9c	da		phx				phx
.ab9d	5a		phy				phy
.ab9e	a2 03		ldx #$03			ldx 	#3 							; copy currentX to lastX
.aba0					_GDCopy1:
.aba0	bd 45 06	lda $0645,x			lda 	gxCurrentX,x
.aba3	9d 49 06	sta $0649,x			sta 	gxLastX,x
.aba6	ca		dex				dex
.aba7	10 f7		bpl $aba0			bpl 	_GDCopy1
.aba9	68		pla				pla 								; update Y
.abaa	8d 47 06	sta $0647			sta 	gxCurrentY
.abad	9c 48 06	stz $0648			stz 	gxCurrentY+1
.abb0	68		pla				pla
.abb1	8d 45 06	sta $0645			sta 	gxCurrentX
.abb4	68		pla				pla 								; get A (command+X.1) back
.abb5	48		pha				pha
.abb6	29 01		and #$01			and 	#1 							; put LSB as MSB of Current.X
.abb8	8d 46 06	sta $0646			sta 	gxCurrentX+1
.abbb	68		pla				pla 								; get command back
.abbc	29 fe		and #$fe			and 	#$FE 						; lose LSB, chuck the stray X bit
.abbe	48		pha				pha 								; push back.
.abbf	c9 52		cmp #$52			cmp 	#GCMD_SpriteMove 			; move sprite does not clip.
.abc1	f0 17		beq $abda			beq 	_GDCopyToWorkArea
.abc3	ad 46 06	lda $0646			lda 	gxCurrentX+1 				; X < 256 X okay
.abc6	f0 07		beq $abcf			beq 	_GDCheckY
.abc8	ad 45 06	lda $0645			lda 	gxCurrentX 					; otherwise X < 320 = 256 + 64
.abcb	c9 40		cmp #$40			cmp 	#64
.abcd	b0 08		bcs $abd7			bcs 	_GDError1
.abcf					_GDCheckY:
.abcf	ad 47 06	lda $0647			lda 	gxCurrentY 					; check Y < Height.
.abd2	cd 59 06	cmp $0659			cmp 	gxHeight
.abd5	90 03		bcc $abda			bcc 	_GDCopyToWorkArea
.abd7					_GDError1:
.abd7	68		pla				pla
.abd8					_GDError2:
.abd8	38		sec				sec
.abd9	60		rts				rts
.abda					_GDCopyToWorkArea:
.abda	a2 07		ldx #$07			ldx 	#7 							; copy current and last to gxXY/12 work area
.abdc					_GDCopy2:
.abdc	bd 45 06	lda $0645,x			lda 	gxCurrentX,x
.abdf	9d 4d 06	sta $064d,x			sta 	gxX0,x
.abe2	ca		dex				dex
.abe3	10 f7		bpl $abdc			bpl 	_GDCopy2
.abe5	68		pla				pla 								; get command
.abe6					_GDExecuteA:
.abe6	c9 54		cmp #$54			cmp 	#GRFirstFreeCode*2 			; bad ?
.abe8	b0 ee		bcs $abd8			bcs 	_GDError2
.abea	aa		tax				tax
.abeb	7c be ba	jmp ($babe,x)			jmp 	(GRVectorTable,x)
.abee					GXMove:
.abee	18		clc				clc
.abef	60		rts				rts
.abf0					GRUndefined:
>abf0	db						.byte 	$DB 						; causes a break in the emulator
.abf1					GXFillCircle:
.abf1	a9 ff		lda #$ff			lda 	#255
.abf3	80 02		bra $abf7			bra 	GXCircle
.abf5					GXFrameCircle:
.abf5	a9 00		lda #$00			lda 	#0
.abf7					GXCircle:
.abf7	8d e8 06	sta $06e8			sta 	gxIsFillMode					; save Fill flag
.abfa	ad 56 06	lda $0656			lda 	gxBitmapsOn
.abfd	f0 26		beq $ac25			beq 	_GXCFail
.abff	20 50 b4	jsr $b450			jsr 	GXSortXY 					; topleft/bottomright
.ac02	20 28 b3	jsr $b328			jsr 	GXOpenBitmap 				; start drawing
.ac05	20 f7 ac	jsr $acf7			jsr 	GXCircleSetup 				; set up for drawing
.ac08	9c e9 06	stz $06e9			stz 	gxYChanged
.ac0b					_GXCircleDraw:
.ac0b	ad e6 06	lda $06e6			lda 	gXCentre					; while x <= y
.ac0e	cd e7 06	cmp $06e7			cmp 	gYCentre
.ac11	90 0a		bcc $ac1d			bcc 	_GXCircleContinue
.ac13	d0 03		bne $ac18			bne 	_GXNoLast
.ac15	20 2a ac	jsr $ac2a			jsr 	GXPlot1
.ac18					_GXNoLast:
.ac18	20 30 b3	jsr $b330			jsr 	GXCloseBitmap 				; close the bitmap
.ac1b	18		clc				clc
.ac1c	60		rts				rts
.ac1d					_GXCircleContinue:
.ac1d	20 27 ac	jsr $ac27			jsr 	GXPlot2 					; draw it
.ac20	20 a4 ac	jsr $aca4			jsr 	GXCircleMove 				; adjust the coordinates
.ac23	80 e6		bra $ac0b			bra 	_GXCircleDraw
.ac25					_GXCFail:
.ac25	38		sec				sec
.ac26	60		rts				rts
.ac27					GXPlot2:
.ac27	20 2a ac	jsr $ac2a			jsr 	GXPlot1 						; plot and swap, fall through does twice
.ac2a					GXPlot1:
.ac2a	ad e7 06	lda $06e7			lda 	gYCentre 						; if y = 0, don't do it twice (xor)
.ac2d	f0 03		beq $ac32			beq 	_GXPlot1Only
.ac2f	20 4e ac	jsr $ac4e			jsr 	GXPlot0 						; plot and negate
.ac32					_GXPlot1Only:
.ac32	20 4e ac	jsr $ac4e			jsr 	GXPlot0 						; twice, undoing negation
.ac35	ad e6 06	lda $06e6			lda 	gXCentre 						; swap X and Y
.ac38	ae e7 06	ldx $06e7			ldx	 	gYCentre
.ac3b	8d e7 06	sta $06e7			sta 	gYCentre
.ac3e	8e e6 06	stx $06e6			stx 	gXCentre
.ac41	ad e9 06	lda $06e9			lda 	gxYChanged 						; toggle Y Changed flag
.ac44	a9 ff		lda #$ff			lda 	#$FF
.ac46	8d e9 06	sta $06e9			sta 	gxYChanged
.ac49	60		rts				rts
.ac4a	20 4e ac	jsr $ac4e			jsr 	GXPlot0 						; do once
.ac4d	60		rts				rts
.ac4e	ad e8 06	lda $06e8	GXPlot0:lda 	gxIsFillMode 					; outline mode, always draw as X or Y will change
.ac51	f0 05		beq $ac58			beq 	_GXPlot0Always
.ac53	ad e9 06	lda $06e9			lda 	gxYChanged						; fill mode, only draw if changed.
.ac56	f0 2d		beq $ac85			beq 	GXPlot0Exit
.ac58					_GXPlot0Always:
.ac58	a2 02		ldx #$02			ldx 	#2 								; copy Y1-A => Y0
.ac5a	ad e7 06	lda $06e7			lda 	gYCentre
.ac5d	20 86 ac	jsr $ac86			jsr 	GXSubCopy
.ac60	a2 00		ldx #$00			ldx 	#0 								; copy X1-A => X0,
.ac62	ad e6 06	lda $06e6			lda 	gXCentre
.ac65	20 86 ac	jsr $ac86			jsr 	GXSubCopy
.ac68	48		pha				pha 									; save last offset X
.ac69	20 38 b3	jsr $b338			jsr 	GXPositionCalc 					; calculate position/offset.
.ac6c	68		pla				pla
.ac6d	0a		asl a				asl 	a 								; store 2 x last offset in gxzTemp0
.ac6e	85 36		sta $36				sta 	gxzTemp0
.ac70	64 37		stz $37				stz 	gxzTemp0+1
.ac72	26 37		rol $37				rol 	gxzTemp0+1
.ac74	ad e8 06	lda $06e8			lda 	gxIsFillMode
.ac77	69 80		adc #$80			adc 	#128
.ac79	20 16 b0	jsr $b016			jsr 	GXDrawLineTemp0 				; routine from Rectangle.
.ac7c	38		sec				sec 									; GY = -GY
.ac7d	a9 00		lda #$00			lda 	#0
.ac7f	ed e7 06	sbc $06e7			sbc 	gYCentre
.ac82	8d e7 06	sta $06e7			sta 	gYCentre
.ac85					GXPlot0Exit:
.ac85	60		rts				rts
.ac86					GXSubCopy:
.ac86	85 36		sta $36				sta 	gxzTemp0
.ac88	64 37		stz $37				stz 	gxzTemp0+1
.ac8a	29 80		and #$80			and 	#$80
.ac8c	f0 02		beq $ac90			beq 	_GXNoSx
.ac8e	c6 37		dec $37				dec 	gxzTemp0+1
.ac90					_GXNoSx:
.ac90	38		sec				sec
.ac91	bd 51 06	lda $0651,x			lda 	gXX1,x
.ac94	e5 36		sbc $36				sbc 	gxzTemp0
.ac96	9d 4d 06	sta $064d,x			sta 	gXX0,x
.ac99	bd 52 06	lda $0652,x			lda 	gXX1+1,x
.ac9c	e5 37		sbc $37				sbc 	gxzTemp0+1
.ac9e	9d 4e 06	sta $064e,x			sta 	gXX0+1,x
.aca1	a5 36		lda $36				lda 	gxzTemp0 						; return A
.aca3	60		rts				rts
.aca4					GXCircleMove:
.aca4	9c e9 06	stz $06e9			stz 	gxYChanged 					; clear Y changed flag
.aca7	a5 39		lda $39				lda 	gxzTemp1+1 					; check sign of D
.aca9	10 0d		bpl $acb8			bpl 	_GXEMPositive
.acab	ee e6 06	inc $06e6			inc 	gXCentre 					; X++
.acae	ad e6 06	lda $06e6			lda 	gXCentre
.acb1	20 d7 ac	jsr $acd7			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.acb4	a9 06		lda #$06			lda 	#6  						; and add 6
.acb6	80 15		bra $accd			bra 	_GXEMAddD
.acb8					_GXEMPositive:
.acb8	ee e6 06	inc $06e6			inc 	gXCentre					; X++
.acbb	ce e7 06	dec $06e7			dec 	gyCentre 					; Y--
.acbe	38		sec				sec 								; calculate X-Y
.acbf	ad e6 06	lda $06e6			lda 	gXCentre
.acc2	ed e7 06	sbc $06e7			sbc 	gYCentre
.acc5	20 d7 ac	jsr $acd7			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.acc8	a9 0a		lda #$0a			lda 	#10  						; and add 10
.acca	ce e9 06	dec $06e9			dec 	gxYChanged
.accd					_GXEMAddD:
.accd	18		clc				clc
.acce	65 38		adc $38				adc 	gxzTemp1
.acd0	85 38		sta $38				sta 	gxzTemp1
.acd2	90 02		bcc $acd6			bcc 	_GXEMNoCarry
.acd4	e6 39		inc $39				inc 	gxzTemp1+1
.acd6					_GXEMNoCarry:
.acd6	60		rts				rts
.acd7					_GXAdd4TimesToD:
.acd7	85 36		sta $36				sta 	gxzTemp0 					; make 16 bit signed.
.acd9	29 80		and #$80			and 	#$80
.acdb	f0 02		beq $acdf			beq 	_GXA4Unsigned
.acdd	a9 ff		lda #$ff			lda 	#$FF
.acdf					_GXA4Unsigned:
.acdf	85 37		sta $37				sta 	gxzTemp0+1
.ace1	06 36		asl $36				asl 	gxzTemp0  					; x 4
.ace3	26 37		rol $37				rol 	gxzTemp0+1
.ace5	06 36		asl $36				asl 	gxzTemp0
.ace7	26 37		rol $37				rol 	gxzTemp0+1
.ace9	18		clc				clc 								; add
.acea	a5 36		lda $36				lda		gxzTemp0
.acec	65 38		adc $38				adc 	gxzTemp1
.acee	85 38		sta $38				sta 	gxzTemp1
.acf0	a5 37		lda $37				lda		gxzTemp0+1
.acf2	65 39		adc $39				adc 	gxzTemp1+1
.acf4	85 39		sta $39				sta 	gxzTemp1+1
.acf6	60		rts				rts
.acf7					GXCircleSetup:
.acf7	38		sec				sec
.acf8	ad 53 06	lda $0653			lda 	gxY1
.acfb	ed 4f 06	sbc $064f			sbc 	gxY0
.acfe	4a		lsr a				lsr 	a
.acff	8d e5 06	sta $06e5			sta 	gxRadius
.ad02	a2 00		ldx #$00			ldx 	#0
.ad04	20 26 ad	jsr $ad26			jsr 	_GXCalculateCentre
.ad07	a2 02		ldx #$02			ldx 	#2
.ad09	20 26 ad	jsr $ad26			jsr 	_GXCalculateCentre
.ad0c	9c e6 06	stz $06e6			stz 	gXCentre
.ad0f	ad e5 06	lda $06e5			lda 	gxRadius
.ad12	8d e7 06	sta $06e7			sta 	gYCentre
.ad15	0a		asl a				asl 	a 							; R x 2
.ad16	85 36		sta $36				sta 	gxzTemp0
.ad18	38		sec				sec
.ad19	a9 03		lda #$03			lda 	#3
.ad1b	e5 36		sbc $36				sbc 	gxzTemp0
.ad1d	85 38		sta $38				sta 	gxzTemp1
.ad1f	a9 00		lda #$00			lda 	#0
.ad21	e9 00		sbc #$00			sbc 	#0
.ad23	85 39		sta $39				sta 	gxzTemp1+1
.ad25	60		rts				rts
.ad26					_GXCalculateCentre:
.ad26	38		sec				sec
.ad27	bd 51 06	lda $0651,x			lda 	gxX1,x
.ad2a	7d 4d 06	adc $064d,x			adc 	gXX0,x
.ad2d	9d 51 06	sta $0651,x			sta 	gXX1,x
.ad30	bd 52 06	lda $0652,x			lda 	gXX1+1,x
.ad33	7d 4e 06	adc $064e,x			adc 	gXX0+1,x
.ad36	4a		lsr a				lsr 	a
.ad37	9d 52 06	sta $0652,x			sta 	gXX1+1,x
.ad3a	7e 51 06	ror $0651,x			ror 	gXX1,x
.ad3d	60		rts				rts
.06e5					gxRadius:
>06e5							.fill 	1
.06e6					gXCentre:
>06e6							.fill 	1
.06e7					gYCentre:
>06e7							.fill 	1
.06e8					gxIsFillMode:
>06e8							.fill 	1
.06e9					gxYChanged:
>06e9							.fill  	1
=64000					ScreenSize200 = 320 * 200
=76800					ScreenSize240 = 320 * 240
.ad3e					GXClearBitmap:
.ad3e	ad 56 06	lda $0656			lda 	gxBitmapsOn 				; check BMP running.
.ad41	f0 24		beq $ad67			beq 	_GXCBFail
.ad43	20 28 b3	jsr $b328			jsr 	GXOpenBitmap 				; start access
.ad46	a0 07		ldy #$07			ldy 	#ScreenSize200 / 8192 		; X is pages to clear
.ad48	ad 59 06	lda $0659			lda 	gxHeight
.ad4b	c9 c8		cmp #$c8			cmp 	#200 						; 200 ?
.ad4d	a0 09		ldy #$09			ldy 	#ScreenSize240 / 8192
.ad4f					_GXCalcLastPage:
.ad4f	98		tya				tya 								; add to base page
.ad50	18		clc				clc
.ad51	6d 57 06	adc $0657			adc 	gxBasePage
.ad54	85 0b		sta $0b				sta 	GXEditSlot  				; clear from this page back
.ad56					_GXClearAll:
.ad56	20 69 ad	jsr $ad69			jsr 	_GXClearBlock 				; clear 8k block
.ad59	c6 0b		dec $0b				dec 	GXEditSlot  				; back to previous
.ad5b	a5 0b		lda $0b				lda 	GXEditSlot
.ad5d	cd 57 06	cmp $0657			cmp 	gxBasePage 					; until before base page
.ad60	b0 f4		bcs $ad56			bcs 	_GXClearAll
.ad62	20 30 b3	jsr $b330			jsr 	GXCloseBitmap	 			; stop access
.ad65	18		clc				clc
.ad66	60		rts				rts
.ad67					_GXCBFail:
.ad67	38		sec				sec
.ad68	60		rts				rts
.ad69					_GXClearBlock:
.ad69	a9 00		lda #$00			lda 	#((GXMappingAddress) & $FF)
.ad6b	85 38		sta $38				sta 	0+gxzTemp1
.ad6d	a9 60		lda #$60			lda 	#((GXMappingAddress) >> 8)
.ad6f	85 39		sta $39				sta 	1+gxzTemp1
.ad71					_GXCB0:
.ad71	a5 36		lda $36				lda 	gxzTemp0
.ad73	a0 00		ldy #$00			ldy 	#0
.ad75					_GXCB1:
.ad75	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad77	c8		iny				iny
.ad78	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad7a	c8		iny				iny
.ad7b	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad7d	c8		iny				iny
.ad7e	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad80	c8		iny				iny
.ad81	d0 f2		bne $ad75			bne 	_GXCB1
.ad83	e6 39		inc $39				inc 	gxzTemp1+1
.ad85	a5 39		lda $39				lda 	gxzTemp1+1
.ad87	c9 80		cmp #$80			cmp	 	#(GXMappingAddress >> 8)+$20
.ad89	d0 e6		bne $ad71			bne 	_GXCB0
.ad8b	60		rts				rts
.ad8c					GXInitialise:
.ad8c	64 01		stz $01				stz 	1
.ad8e	a9 01		lda #$01			lda 	#1
.ad90	8d 00 d0	sta $d000			sta 	$D000
.ad93	18		clc				clc
.ad94	9c 55 06	stz $0655			stz 	GXSpritesOn
.ad97	9c 56 06	stz $0656			stz 	GXBitmapsOn
.ad9a	a2 0f		ldx #$0f			ldx 	#15
.ad9c					_GXIClear:
.ad9c	9e 45 06	stz $0645,x			stz 	gxCurrentX,x
.ad9f	ca		dex				dex
.ada0	10 fa		bpl $ad9c			bpl 	_GXIClear
.ada2	20 3d ae	jsr $ae3d			jsr 	GXClearSpriteStore
.ada5	60		rts				rts
.ada6					GXControlBitmap:
.ada6	64 01		stz $01				stz 	1
.ada8	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.adaa	29 01		and #$01			and 	#1 							; set bitmap flag
.adac	8d 56 06	sta $0656			sta 	gxBitmapsOn
.adaf	4a		lsr a				lsr 	a 							; bit 0 into carry.
.adb0	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.adb3	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.adb5	29 f7		and #$f7			and 	#$F7 						; clear bitmap bit
.adb7	90 02		bcc $adbb			bcc 	_CBNotOn
.adb9	09 08		ora #$08			ora 	#$08 						; bitmap on if 1 on 0 off
.adbb					_CBNotOn:
.adbb	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.adbe	a5 36		lda $36				lda 	gxzTemp0 					; get control settings (bits 0-2)
.adc0	29 07		and #$07			and 	#7
.adc2	8d 00 d1	sta $d100			sta 	$D100 						; write in Vicky Bitmap Control Register #0
.adc5	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.adc7	d0 02		bne $adcb			bne 	_CBNotDefault
.adc9	a9 08		lda #$08			lda 	#8  						; if zero, use 8 e.g. bitmap at $10000
.adcb					_CBNotDefault:
.adcb	8d 57 06	sta $0657			sta 	gxBasePage
.adce	20 2f ae	jsr $ae2f			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.add1	a5 37		lda $37				lda 	gxzTemp0+1 					; copy address into Bitmap address registers
.add3	8d 03 d1	sta $d103			sta 	$D103
.add6	a5 36		lda $36				lda 	gxzTemp0
.add8	8d 02 d1	sta $d102			sta 	$D102
.addb	9c 01 d1	stz $d101			stz 	$D101
.adde	a2 f0		ldx #$f0			ldx 	#240 						; height is 240
.ade0	ad 01 d0	lda $d001			lda 	$D001 						; read MCR bit 0
.ade3	29 01		and #$01			and 	#1
.ade5	f0 02		beq $ade9			beq 	_CBHaveHeight
.ade7	a2 c8		ldx #$c8			ldx 	#200 						; if bit 0 set 320x200
.ade9					_CBHaveHeight
.ade9	8e 59 06	stx $0659			stx 	gxHeight
.adec	18		clc				clc
.aded	60		rts				rts
.adee					GXControlSprite:
.adee	64 01		stz $01				stz 	1
.adf0	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.adf2	29 01		and #$01			and 	#1 							; set sprites flag
.adf4	8d 55 06	sta $0655			sta 	gxSpritesOn
.adf7	4a		lsr a				lsr 	a 							; bit 0 into carry.
.adf8	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.adfb	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.adfd	29 df		and #$df			and 	#$DF 						; clear sprite bit
.adff	90 02		bcc $ae03			bcc 	_CSNotOn
.ae01	09 20		ora #$20			ora 	#$20 						; sprite on if 1 on 0 off
.ae03					_CSNotOn:
.ae03	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.ae06	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.ae08	d0 02		bne $ae0c			bne 	_CSNotDefault
.ae0a	a9 18		lda #$18			lda 	#24  						; if zero, use 24 e.g. sprites at $30000
.ae0c					_CSNotDefault:
.ae0c	8d 58 06	sta $0658			sta 	gxSpritePage
.ae0f	20 2f ae	jsr $ae2f			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.ae12	a5 36		lda $36				lda 	zTemp0
.ae14	8d 63 06	sta $0663			sta 	GXSpriteOffsetBase
.ae17	a5 37		lda $37				lda 	zTemp0+1
.ae19	8d 64 06	sta $0664			sta 	GXSpriteOffsetBase+1
.ae1c	a2 00		ldx #$00			ldx 	#0 							; disable all sprites, clears all sprite memory.
.ae1e					_CSClear:
.ae1e	9e 00 d9	stz $d900,x			stz 	$D900,x
.ae21	9e 00 da	stz $da00,x			stz 	$DA00,x
.ae24	ca		dex				dex
.ae25	d0 f7		bne $ae1e			bne 	_CSClear
.ae27	9c 62 06	stz $0662			stz 	GSCurrentSpriteAddr+1 		; no sprite selected.
.ae2a	20 3d ae	jsr $ae3d			jsr 	GXClearSpriteStore
.ae2d	18		clc				clc
.ae2e	60		rts				rts
.ae2f					GXCalculateBaseAddress:
.ae2f	85 36		sta $36				sta 	gxzTemp0
.ae31	64 37		stz $37				stz 	gxzTemp0+1
.ae33	a9 05		lda #$05			lda 	#5
.ae35					_GXShift:
.ae35	06 36		asl $36				asl 	gxzTemp0
.ae37	26 37		rol $37				rol 	gxzTemp0+1
.ae39	3a		dec a				dec		a
.ae3a	d0 f9		bne $ae35			bne 	_GXShift
.ae3c	60		rts				rts
.ae3d					GXClearSpriteStore:
.ae3d	a2 3f		ldx #$3f			ldx 	#63 						; erase 64 sprite store elements
.ae3f					_GXCSSLoop:
.ae3f	9e a5 06	stz $06a5,x			stz 	GXSpriteHigh,x
.ae42	a9 80		lda #$80			lda 	#$80 						; set the 'hidden' bit.
.ae44	9d 65 06	sta $0665,x			sta 	GXSpriteLow,x
.ae47	ca		dex				dex
.ae48	10 f5		bpl $ae3f			bpl 	_GXCSSLoop
.ae4a	60		rts				rts
.ae4b					GXLine:
.ae4b	ad 56 06	lda $0656			lda 	GXBitmapsOn
.ae4e	f0 28		beq $ae78			beq 	_GXLFail
.ae50	20 28 b3	jsr $b328			jsr 	GXOpenBitmap
.ae53	20 6e b4	jsr $b46e			jsr 	GXSortY						; sort pairs so Y1 >= Y0 e.g. top to bottom.
.ae56	20 1e af	jsr $af1e			jsr 	GXLineSetup 				; the calculations in the linescanner constructor
.ae59	20 38 b3	jsr $b338			jsr 	GXPositionCalc 				; calculate position/offset.
.ae5c					_GXDrawLoop:
.ae5c	ac 5f 06	ldy $065f			ldy 	gsOffset 					; draw the pixel
.ae5f	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.ae61	2d 5d 06	and $065d			and 	gxANDValue
.ae64	4d 5c 06	eor $065c			eor 	gxEORValue
.ae67	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.ae69	20 7a ae	jsr $ae7a			jsr 	GXLineIsComplete 			; is the line complete ?
.ae6c	f0 05		beq $ae73			beq 	_GXLExit
.ae6e	20 95 ae	jsr $ae95			jsr 	GXLineAdvance 				; code as per advance method
.ae71	80 e9		bra $ae5c			bra 	_GXDrawLoop
.ae73					_GXLExit:
.ae73	20 30 b3	jsr $b330			jsr 	GXCloseBitmap
.ae76	18		clc				clc
.ae77	60		rts				rts
.ae78					_GXLFail:
.ae78	38		sec				sec
.ae79	60		rts				rts
.ae7a					GXLineIsComplete:
.ae7a	ad ec 06	lda $06ec			lda 	GXIsDiffYLarger 			; is dy larger
.ae7d	d0 0f		bne $ae8e			bne 	_GXLICCompareY 				; if so compare Y1/Y0
.ae7f	ad 4d 06	lda $064d			lda 	GXX0 						; compare X, LSB and MSB
.ae82	4d 51 06	eor $0651			eor 	GXX1
.ae85	d0 06		bne $ae8d			bne 	_GXLICExit
.ae87	ad 4e 06	lda $064e			lda 	GXX0+1
.ae8a	4d 52 06	eor $0652			eor 	GXX1+1
.ae8d					_GXLICExit:
.ae8d	60		rts				rts
.ae8e					_GXLICCompareY:
.ae8e	ad 53 06	lda $0653			lda 	GXY1
.ae91	4d 4f 06	eor $064f			eor 	GXY0
.ae94	60		rts				rts
.ae95					GXLineAdvance:
.ae95	18		clc				clc 								; add adjust to position
.ae96	ad ee 06	lda $06ee			lda 	GXPosition
.ae99	6d ef 06	adc $06ef			adc 	GXAdjust
.ae9c	8d ee 06	sta $06ee			sta 	GXPosition
.ae9f	9c f1 06	stz $06f1			stz 	GXAddSelect 				; clear add select flag
.aea2	b0 05		bcs $aea9			bcs 	_GXLAOverflow 				; if carry out, overflowed.
.aea4	cd f0 06	cmp $06f0			cmp 	GXTotal 					; if exceeded total
.aea7	90 0a		bcc $aeb3			bcc 	_GXLANoExtra
.aea9					_GXLAOverflow:
.aea9	ce f1 06	dec $06f1			dec 	GXAddSelect 				; set addselect to $FF
.aeac	38		sec				sec 								; subtract total and write back
.aead	ed f0 06	sbc $06f0			sbc 	GXTotal
.aeb0	8d ee 06	sta $06ee			sta 	GXPosition
.aeb3					_GXLANoExtra:
.aeb3	ad ec 06	lda $06ec			lda 	GXIsDiffYLarger
.aeb6	f0 0d		beq $aec5			beq 	_GXDXLarger
.aeb8	20 17 af	jsr $af17			jsr 	GXIncrementY
.aebb	ad f1 06	lda $06f1			lda 	GXAddSelect
.aebe	f0 10		beq $aed0			beq 	_GXLAExit
.aec0	20 d1 ae	jsr $aed1			jsr 	GXAdjustX
.aec3	80 0b		bra $aed0			bra 	_GXLAExit
.aec5					_GXDXLarger:
.aec5	20 d1 ae	jsr $aed1			jsr 	GXAdjustX
.aec8	ad f1 06	lda $06f1			lda 	GXAddSelect
.aecb	f0 03		beq $aed0			beq 	_GXLAExit
.aecd	20 17 af	jsr $af17			jsr 	GXIncrementY
.aed0					_GXLAExit:
.aed0	60		rts				rts
.aed1					GXAdjustX:
.aed1	ad ed 06	lda $06ed			lda 	GXDXNegative
.aed4	10 25		bpl $aefb			bpl 	_GXAXRight
.aed6	ad 4d 06	lda $064d			lda 	GXX0
.aed9	d0 03		bne $aede			bne 	_GXAXNoBorrow
.aedb	ce 4e 06	dec $064e			dec 	GXX0+1
.aede					_GXAXNoBorrow:
.aede	ce 4d 06	dec $064d			dec 	GXX0
.aee1	ce 5f 06	dec $065f			dec 	gsOffset 					; pixel left
.aee4	ad 5f 06	lda $065f			lda 	gsOffset
.aee7	c9 ff		cmp #$ff			cmp 	#$FF
.aee9	d0 0f		bne $aefa			bne 	_GXAYExit 					; underflow
.aeeb	c6 3d		dec $3d				dec 	gxzScreen+1 					; borrow
.aeed	a5 3d		lda $3d				lda 	gxzScreen+1 					; gone off page
.aeef	c9 60		cmp #$60			cmp 	#GXMappingAddress >> 8
.aef1	b0 07		bcs $aefa			bcs 	_GXAYExit
.aef3	18		clc				clc
.aef4	69 20		adc #$20			adc 	#$20 						; fix up
.aef6	85 3d		sta $3d				sta 	gxzScreen+1
.aef8	c6 0b		dec $0b				dec 	GXEditSlot 				; back one page
.aefa					_GXAYExit:
.aefa	60		rts				rts
.aefb					_GXAXRight:
.aefb	ee 4d 06	inc $064d			inc 	GXX0
.aefe	d0 03		bne $af03			bne 	_GXAXNoCarry
.af00	ee 4e 06	inc $064e			inc 	GXX0+1
.af03					_GXAXNoCarry:
.af03	ee 5f 06	inc $065f			inc 	gsOffset 					; pixel right
.af06	d0 0e		bne $af16			bne 	_GXAXExit 					; if not overflowed, exit.
.af08	e6 3d		inc $3d				inc 	gxzScreen+1 					; next line
.af0a	a5 3d		lda $3d				lda 	gxzScreen+1
.af0c	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.af0e	90 06		bcc $af16			bcc 	_GXAXExit
.af10	e9 20		sbc #$20			sbc 	#$20 						; fix up
.af12	85 3d		sta $3d				sta 	gxzScreen+1
.af14	e6 0b		inc $0b				inc 	GXEditSlot 				; next page
.af16					_GXAXExit:
.af16	60		rts				rts
.af17					GXIncrementY:
.af17	ee 4f 06	inc $064f			inc 	GXY0
.af1a	20 8e b3	jsr $b38e			jsr 	GXMovePositionDown
.af1d	60		rts				rts
.af1e					GXLineSetup:
.af1e	ad 53 06	lda $0653			lda 	GXY1
.af21	38		sec				sec
.af22	ed 4f 06	sbc $064f			sbc 	GXY0
.af25	4a		lsr a				lsr 	a
.af26	8d eb 06	sta $06eb			sta 	GXDiffY
.af29	9c ed 06	stz $06ed			stz 	GXDXNegative 				; clear -ve flag
.af2c	38		sec				sec
.af2d	ad 51 06	lda $0651			lda 	GXX1
.af30	ed 4d 06	sbc $064d			sbc 	GXX0
.af33	8d ea 06	sta $06ea			sta 	GXDiffX
.af36	ad 52 06	lda $0652			lda 	GXX1+1 						; calculate MSB
.af39	ed 4e 06	sbc $064e			sbc 	GXX0+1
.af3c	6a		ror a				ror 	a 							; rotate bit into DiffX halving it
.af3d	6e ea 06	ror $06ea			ror 	GXDiffX
.af40	0a		asl a				asl 	a
.af41	10 0c		bpl $af4f			bpl 	_GDXNotNegative
.af43	a9 00		lda #$00			lda 	#0 							; make absolute value of |dx|
.af45	38		sec				sec
.af46	ed ea 06	sbc $06ea			sbc 	GXDiffX
.af49	8d ea 06	sta $06ea			sta 	GXDiffX
.af4c	ce ed 06	dec $06ed			dec 	GXDXNegative 				; -ve flag = $FF.
.af4f					_GDXNotNegative:
.af4f	9c ec 06	stz $06ec			stz 	GXIsDiffYLarger 			; clear larger flag
.af52	ad eb 06	lda $06eb			lda 	GXDiffY 					; set adjust and total.
.af55	8d ef 06	sta $06ef			sta 	GXAdjust
.af58	ad ea 06	lda $06ea			lda 	GXDiffX
.af5b	8d f0 06	sta $06f0			sta 	GXTotal
.af5e	ad eb 06	lda $06eb			lda 	GXDiffY 					; if dy > dx
.af61	cd ea 06	cmp $06ea			cmp 	GXDiffX
.af64	90 0f		bcc $af75			bcc 	_GDXNotLarger
.af66	ce ec 06	dec $06ec			dec 	GXIsDiffYLarger 			; set the dy larger flag
.af69	ad ea 06	lda $06ea			lda 	GXDiffX 					; set adjust and total other way round
.af6c	8d ef 06	sta $06ef			sta 	GXAdjust
.af6f	ad eb 06	lda $06eb			lda 	GXDiffY
.af72	8d f0 06	sta $06f0			sta 	GXTotal
.af75					_GDXNotLarger:
.af75	ad f0 06	lda $06f0			lda 	GXTotal
.af78	4a		lsr a				lsr 	a
.af79	8d ee 06	sta $06ee			sta 	GXPosition
.af7c	60		rts				rts
.06ea					GXDiffX:
>06ea							.fill 	1
.06eb					GXDiffY:
>06eb							.fill 	1
.06ec					GXIsDiffYLarger:
>06ec							.fill 	1
.06ed					GXDXNegative:
>06ed							.fill 	1
.06ee					GXPosition:
>06ee							.fill 	1
.06ef					GXAdjust:
>06ef							.fill 	1
.06f0					GXTotal:
>06f0							.fill 	1
.06f1					GXAddSelect:
>06f1							.fill 	1
.af7d					GXSetColourMode:
.af7d	a6 36		ldx $36				ldx 	gxzTemp0
.af7f	8e 5b 06	stx $065b			stx 	gxColour 								; set colour
.af82	a5 37		lda $37				lda 	gxzTemp0+1 								;
.af84	8d 5a 06	sta $065a			sta 	gxMode 									; set mode
.af87	29 03		and #$03			and 	#3 										; only interested in bits 0-3
.af89	9c 5d 06	stz $065d			stz 	gxANDValue 								; initially AND with 0, and EOR with Colour
.af8c	ae 5b 06	ldx $065b			ldx 	gxColour
.af8f	8e 5c 06	stx $065c			stx 	gxEORValue
.af92	c9 02		cmp #$02			cmp 	#2 										; if mode 2/3 And with colour
.af94	90 03		bcc $af99			bcc 	_GXSDCNotAndColour
.af96	8e 5d 06	stx $065d			stx 	gxANDValue
.af99					_GXSDCNotAndColour:
.af99	d0 03		bne $af9e			bne 	_GXSDCNotAnd 							; mode 2, Don't EOR with colour
.af9b	9c 5c 06	stz $065c			stz 	gxEORValue
.af9e					_GXSDCNotAnd:
.af9e	4a		lsr a				lsr 	a 										; if bit 0 set, 1's complement AND value
.af9f	90 08		bcc $afa9			bcc 	_GXSDCNoFlip
.afa1	ad 5d 06	lda $065d			lda	 	gxANDValue
.afa4	49 ff		eor #$ff			eor 	#$FF
.afa6	8d 5d 06	sta $065d			sta 	gxANDValue
.afa9					_GXSDCNoFlip:
.afa9	18		clc				clc
.afaa	60		rts				rts
.afab					GXPlotPoint:
.afab	20 28 b3	jsr $b328			jsr 	GXOpenBitmap 				; start drawing
.afae	20 38 b3	jsr $b338			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.afb1	ac 5f 06	ldy $065f			ldy 	gsOffset
.afb4	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.afb6	2d 5d 06	and $065d			and 	gxANDValue
.afb9	4d 5c 06	eor $065c			eor 	gxEORValue
.afbc	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.afbe	20 30 b3	jsr $b330			jsr 	GXCloseBitmap 				; stop drawing and exit
.afc1	18		clc				clc
.afc2	60		rts				rts
.afc3					GXFillRectangle:
.afc3	38		sec				sec
.afc4	80 01		bra $afc7			bra 	GXRectangle
.afc6					GXFrameRectangle:
.afc6	18		clc				clc
.afc7					GXRectangle:
.afc7	ad 56 06	lda $0656			lda 	gxBitmapsOn
.afca	f0 35		beq $b001			beq 	_GXRFail
.afcc	08		php				php 								; save Fill flag (CS)
.afcd	20 28 b3	jsr $b328			jsr 	GXOpenBitmap 				; start drawing
.afd0	20 50 b4	jsr $b450			jsr 	GXSortXY 					; sort both X and Y so top left/bottom right
.afd3	20 38 b3	jsr $b338			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.afd6	38		sec				sec 								; sec = Draw line
.afd7	20 03 b0	jsr $b003			jsr 	GXDrawLineX1X0 				; draw a line length X1-X0
.afda	ad 4f 06	lda $064f			lda 	gxY0 						; reached end of rectangle ?
.afdd	cd 53 06	cmp $0653			cmp 	gxY1
.afe0	f0 19		beq $affb			beq 	_GXRectangleExit
.afe2					_GXRectLoop:
.afe2	20 8e b3	jsr $b38e			jsr 	GXMovePositionDown 			; down one.
.afe5	ee 4f 06	inc $064f			inc 	gxY0 						; change Y pos
.afe8	ad 4f 06	lda $064f			lda 	gxY0 						; reached last line
.afeb	cd 53 06	cmp $0653			cmp 	gXY1
.afee	f0 07		beq $aff7			beq 	_GXLastLine
.aff0	28		plp				plp 								; get flag back
.aff1	08		php				php
.aff2	20 03 b0	jsr $b003			jsr 	GXDrawLineX1X0 				; draw horizontal line
.aff5	80 eb		bra $afe2			bra 	_GXRectLoop
.aff7					_GXLastLine:
.aff7	38		sec				sec
.aff8	20 03 b0	jsr $b003			jsr 	GXDrawLineX1X0
.affb					_GXRectangleExit:
.affb	68		pla				pla 								; throw fill flag.
.affc	20 30 b3	jsr $b330			jsr 	GXCloseBitmap 				; stop drawing and exit
.afff	18		clc				clc
.b000	60		rts				rts
.b001					_GXRFail:
.b001	38		sec				sec
.b002	60		rts				rts
.b003					GXDrawLineX1X0:
.b003	08		php				php 								; save solid/either-end
.b004	38		sec				sec
.b005	ad 51 06	lda $0651			lda		gXX1
.b008	ed 4d 06	sbc $064d			sbc 	gXX0
.b00b	85 36		sta $36				sta 	gxzTemp0
.b00d	ad 52 06	lda $0652			lda 	gXX1+1
.b010	ed 4e 06	sbc $064e			sbc 	gXX0+1
.b013	85 37		sta $37				sta 	gxzTemp0+1
.b015	28		plp				plp
.b016					GXDrawLineTemp0:
.b016	a5 3c		lda $3c				lda 	gxzScreen 						; push gxzScreen, gsOffset and GXEditSlot on stack
.b018	48		pha				pha
.b019	a5 3d		lda $3d				lda 	gxzScreen+1
.b01b	48		pha				pha
.b01c	ad 5f 06	lda $065f			lda 	gsOffset
.b01f	48		pha				pha
.b020	a5 0b		lda $0b				lda 	GXEditSlot
.b022	48		pha				pha
.b023	ac 5f 06	ldy $065f			ldy 	gsOffset 					; Y offset
.b026	90 1e		bcc $b046			bcc 	_GXDLTEndPoints 			; if CC draw end points only.
.b028					_GXDLTLine:
.b028	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.b02a	2d 5d 06	and $065d			and 	gxANDValue
.b02d	4d 5c 06	eor $065c			eor 	gxEORValue
.b030	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b032	a5 36		lda $36				lda 	gxzTemp0 					; decrement counter
.b034	d0 04		bne $b03a			bne 	_GXDLTNoBorrow
.b036	c6 37		dec $37				dec 	gxzTemp0+1 					; borrow, if goes -ve then exit
.b038	30 2e		bmi $b068			bmi 	_GXDLTExit
.b03a					_GXDLTNoBorrow:
.b03a	c6 36		dec $36				dec 	gxzTemp0
.b03c	c8		iny				iny 								; next slot.
.b03d	d0 e9		bne $b028			bne 	_GXDLTLine
.b03f	e6 3d		inc $3d				inc 	gxzScreen+1 					; carry to next
.b041	20 76 b0	jsr $b076			jsr 	GXDLTCheckWrap				; check for new page.
.b044	80 e2		bra $b028			bra 	_GXDLTLine
.b046					_GXDLTEndPoints:
.b046	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.b048	2d 5d 06	and $065d			and 	gxANDValue
.b04b	4d 5c 06	eor $065c			eor 	gxEORValue
.b04e	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b050	98		tya				tya 								; advance to right side
.b051	18		clc				clc
.b052	65 36		adc $36				adc 	gxzTemp0
.b054	a8		tay				tay
.b055	a5 3d		lda $3d				lda 	gxzScreen+1
.b057	65 37		adc $37				adc 	gxzTemp0+1
.b059	85 3d		sta $3d				sta 	gxzScreen+1
.b05b	20 76 b0	jsr $b076			jsr 	GXDLTCheckWrap 			; fix up.
.b05e	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.b060	2d 5d 06	and $065d			and 	gxANDValue
.b063	4d 5c 06	eor $065c			eor 	gxEORValue
.b066	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b068					_GXDLTExit:
.b068	68		pla				pla
.b069	85 0b		sta $0b				sta 	GXEditSlot
.b06b	68		pla				pla
.b06c	8d 5f 06	sta $065f			sta 	gsOffset
.b06f	68		pla				pla
.b070	85 3d		sta $3d				sta 	gxzScreen+1
.b072	68		pla				pla
.b073	85 3c		sta $3c				sta 	gxzScreen
.b075	60		rts				rts
.b076					GXDLTCheckWrap:
.b076	a5 3d		lda $3d				lda 	gxzScreen+1 					; check end of page
.b078	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8)
.b07a	90 06		bcc $b082			bcc 	_GXDLTCWExit
.b07c	e9 20		sbc #$20			sbc 	#$20 						; fix up
.b07e	85 3d		sta $3d				sta 	gxzScreen+1
.b080	e6 0b		inc $0b				inc 	GXEditSlot
.b082					_GXDLTCWExit:
.b082	60		rts				rts
.b083					GXDrawGraphicElement:
.b083	8d f2 06	sta $06f2			sta 	gxSize 						; save size
.b086	3a		dec a				dec 	a
.b087	8d f3 06	sta $06f3			sta 	gxMask 						; and mask
.b08a	ad 56 06	lda $0656			lda 	gxBitmapsOn 				; check BMP on
.b08d	f0 67		beq $b0f6			beq 	_GXSLFail
.b08f	ad 4f 06	lda $064f			lda 	gxY0 						; push Y on stack
.b092	48		pha				pha
.b093	8c f5 06	sty $06f5			sty 	gxAcquireVector+1 			; and acquisition vector
.b096	8e f4 06	stx $06f4			stx 	gxAcquireVector
.b099	20 28 b3	jsr $b328			jsr 	gxOpenBitmap 				; open the bitmap.
.b09c	ad f7 06	lda $06f7			lda 	gxUseMode 					; scale bits
.b09f	4a		lsr a				lsr 	a
.b0a0	4a		lsr a				lsr 	a
.b0a1	4a		lsr a				lsr 	a
.b0a2	29 07		and #$07			and		#7
.b0a4	1a		inc a				inc 	a
.b0a5	8d f6 06	sta $06f6			sta 	gxScale
.b0a8	64 38		stz $38				stz 	gxzTemp1					; start first line
.b0aa					_GXGELoop:
.b0aa	a5 38		lda $38				lda 	gxzTemp1 					; current line number to read.
.b0ac	2c f7 06	bit $06f7			bit 	gxUseMode 					; check for flip.
.b0af	10 06		bpl $b0b7			bpl		_GXNoVFlip
.b0b1	ad f3 06	lda $06f3			lda 	gxMask
.b0b4	38		sec				sec
.b0b5	e5 38		sbc $38				sbc 	gxzTemp1
.b0b7					_GXNoVFlip:
.b0b7	aa		tax				tax 								; get the Xth line.
.b0b8	20 f8 b0	jsr $b0f8			jsr 	_GXCallAcquire 				; get that data.
.b0bb	ad f6 06	lda $06f6			lda 	gxScale 					; do scale identical copies of that line.
.b0be	85 39		sta $39				sta 	gxzTemp1+1
.b0c0					_GXGELoop2:
.b0c0	ad 4f 06	lda $064f			lda 	gxY0 						; off screen
.b0c3	cd 59 06	cmp $0659			cmp 	gxHeight
.b0c6	b0 10		bcs $b0d8			bcs 	_GXDGEExit
.b0c8	20 fb b0	jsr $b0fb			jsr 	GXRenderOneLine 			; render line
.b0cb	c6 39		dec $39				dec 	gxzTemp1+1 					; scale times.
.b0cd	d0 f1		bne $b0c0			bne 	_GXGELoop2
.b0cf	e6 38		inc $38				inc 	gxzTemp1 					; done all lines.
.b0d1	a5 38		lda $38				lda 	gxzTemp1
.b0d3	cd f2 06	cmp $06f2			cmp 	gxSize
.b0d6	d0 d2		bne $b0aa			bne 	_GXGELoop
.b0d8					_GXDGEExit:
.b0d8	68		pla				pla 								; restore Y for next time
.b0d9	8d 4f 06	sta $064f			sta 	gxY0
.b0dc	ae f6 06	ldx $06f6			ldx 	gxScale 					; get scale (1-8)
.b0df					_GXShiftLeft:
.b0df	18		clc				clc
.b0e0	ad f2 06	lda $06f2			lda 	gxSize
.b0e3	6d 4d 06	adc $064d			adc 	gxX0
.b0e6	8d 4d 06	sta $064d			sta 	gxX0
.b0e9	90 03		bcc $b0ee			bcc 	_GXSLNoCarry
.b0eb	ee 4e 06	inc $064e			inc 	gxX0+1
.b0ee					_GXSLNoCarry:
.b0ee	ca		dex				dex
.b0ef	d0 ee		bne $b0df			bne 	_GXShiftLeft
.b0f1	20 30 b3	jsr $b330			jsr 	GXCloseBitmap
.b0f4	18		clc				clc
.b0f5	60		rts				rts
.b0f6					_GXSLFail:
.b0f6	38		sec				sec
.b0f7	60		rts				rts
.b0f8					_GXCallAcquire:
.b0f8	6c f4 06	jmp ($06f4)			jmp 	(gxAcquireVector)
.b0fb					GXRenderOneLine:
.b0fb	20 38 b3	jsr $b338			jsr 	GXPositionCalc 				; calculate position/offset.
.b0fe	ac 5f 06	ldy $065f			ldy 	gsOffset 					; Y contains position.
.b101	64 3a		stz $3a				stz 	gxzTemp2 					; do size pixels
.b103					_GXROLLoop1:
.b103	ad f6 06	lda $06f6			lda 	gxScale 					; set to do 'scale' times
.b106	85 3b		sta $3b				sta 	gxzTemp2+1
.b108					_GXROLLoop2:
.b108	a5 3a		lda $3a				lda 	gxzTemp2 					; get current pixel
.b10a	2c 5a 06	bit $065a			bit 	gxMode 						; check H Flip
.b10d	50 06		bvc $b115			bvc 	_GXNoHFlip
.b10f	ad f3 06	lda $06f3			lda 	gxMask
.b112	38		sec				sec
.b113	e5 3a		sbc $3a				sbc 	gxzTemp2
.b115					_GXNoHFlip:
.b115	aa		tax				tax 								; read from the pixel buffer
.b116	bd fb 05	lda $05fb,x			lda 	gxPixelBuffer,x
.b119	d0 07		bne $b122			bne 	_GXDraw 					; draw if non zero
.b11b	ad f7 06	lda $06f7			lda 	gxUseMode 					; check to see if solid background
.b11e	29 04		and #$04			and 	#4
.b120	f0 0a		beq $b12c			beq 	_GXZeroPixel
.b122					_GXDraw:
.b122	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.b124	2d 5d 06	and $065d			and 	gxANDValue
.b127	5d fb 05	eor $05fb,x			eor 	gxPixelBuffer,x
.b12a	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b12c					_GXZeroPixel:
.b12c	c8		iny				iny 								; advance pointer
.b12d	d0 05		bne $b134			bne 	_GXNoShift
.b12f	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.b131	20 76 b0	jsr $b076			jsr 	GXDLTCheckWrap				; check for new page.
.b134					_GXNoShift:
.b134	c6 3b		dec $3b				dec 	gxzTemp2+1 					; do the inner loop gxScale times.
.b136	d0 d0		bne $b108			bne 	_GXROLLoop2
.b138	e6 3a		inc $3a				inc 	gxzTemp2 					; next pixel.
.b13a	a5 3a		lda $3a				lda 	gxzTemp2
.b13c	cd f2 06	cmp $06f2			cmp 	gxSize
.b13f	d0 c2		bne $b103			bne 	_GXROLLoop1
.b141	ee 4f 06	inc $064f			inc 	gxY0
.b144	60		rts				rts
.06f2					gxSize:
>06f2							.fill 	1
.06f3					gxMask:
>06f3							.fill 	1
.06f4					gxAcquireVector:
>06f4							.fill 	2
.06f6					gxScale:
>06f6							.fill 	1
.06f7					gxUseMode:
>06f7							.fill 	1
.b145					GXFontHandler:
.b145	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b147	4d 5a 06	eor $065a			eor 	gxMode
.b14a	8d f7 06	sta $06f7			sta 	gxUseMode
.b14d	64 37		stz $37				stz 	gxzTemp0+1 					; gxzTemp0 is font #
.b14f	06 36		asl $36				asl	 	gxzTemp0 					; x 2
.b151	26 37		rol $37				rol	 	gxzTemp0+1
.b153	06 36		asl $36				asl	 	gxzTemp0 					; x 4
.b155	26 37		rol $37				rol	 	gxzTemp0+1
.b157	06 36		asl $36				asl	 	gxzTemp0 					; x 8
.b159	26 37		rol $37				rol	 	gxzTemp0+1
.b15b	a5 37		lda $37				lda 	gxzTemp0+1 					; put in page C0
.b15d	09 c0		ora #$c0			ora 	#$C0
.b15f	85 37		sta $37				sta 	gxzTemp0+1
.b161	a9 08		lda #$08			lda 	#8 							; size 8x8
.b163	a2 6b		ldx #$6b			ldx 	#GXGetGraphicDataFont & $FF ; XY = Graphic Data retrieval routine
.b165	a0 b1		ldy #$b1			ldy 	#GXGetGraphicDataFont >> 8
.b167	20 83 b0	jsr $b083			jsr 	GXDrawGraphicElement
.b16a	60		rts				rts
.b16b					GXGetGraphicDataFont:
.b16b	8a		txa				txa 								; X->Y
.b16c	a8		tay				tay
.b16d	a6 01		ldx $01				ldx 	1 							; preserve old value
.b16f	a9 01		lda #$01			lda 	#1 							; access page 1 (font memory)
.b171	85 01		sta $01				sta 	1
.b173	b1 36		lda ($36),y			lda 	(gxzTemp0),y 				; read the font element.
.b175	86 01		stx $01				stx 	1 							; put old value back.
.b177	a2 00		ldx #$00			ldx 	#0 							; do 8 times
.b179					_GXExpand:
.b179	9e fb 05	stz $05fb,x			stz 	gxPixelBuffer,x 			; zero in pixel buffer
.b17c	0a		asl a				asl 	a 							; shift bit 7 into C
.b17d	90 08		bcc $b187			bcc 	_GXNoPixel
.b17f	48		pha				pha 								; if set, set pixel buffer to current colour.
.b180	ad 5b 06	lda $065b			lda 	gxColour
.b183	9d fb 05	sta $05fb,x			sta 	gxPixelBuffer,x
.b186	68		pla				pla
.b187					_GXNoPixel:
.b187	e8		inx				inx 								; do the whole byte.
.b188	e0 08		cpx #$08			cpx 	#8
.b18a	d0 ed		bne $b179			bne 	_GXExpand
.b18c	60		rts				rts
.b18d					GXSpriteHandler:
.b18d	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b18f	4d 5a 06	eor $065a			eor 	gxMode
.b192	8d f7 06	sta $06f7			sta 	gxUseMode
.b195	a6 36		ldx $36				ldx 	gxzTemp0 					; sprite #
.b197	da		phx				phx
.b198	20 28 b3	jsr $b328			jsr 	GXOpenBitmap 				; can access sprite information
.b19b	68		pla				pla
.b19c	20 09 b4	jsr $b409			jsr 	GXFindSprite 				; get the sprite address
.b19f	08		php				php
.b1a0	20 30 b3	jsr $b330			jsr 	GXCloseBitmap
.b1a3	28		plp				plp
.b1a4	b0 0a		bcs $b1b0			bcs		_GXSHExit 					; exit if find failed.
.b1a6	ad f8 06	lda $06f8			lda 	GXSizePixels 				; return size
.b1a9	a2 b1		ldx #$b1			ldx 	#GXSpriteAcquire & $FF
.b1ab	a0 b1		ldy #$b1			ldy 	#GXSpriteAcquire >> 8
.b1ad	20 83 b0	jsr $b083			jsr 	GXDrawGraphicElement
.b1b0					_GXSHExit:
.b1b0	60		rts				rts
.b1b1					GXSpriteAcquire:
.b1b1	ad 58 06	lda $0658			lda 	GXSpritePage				; point to base page
.b1b4	85 0b		sta $0b				sta 	GXEditSlot
.b1b6	86 36		stx $36				stx 	zTemp0 						; row number x 1,2,3,4
.b1b8	a9 00		lda #$00			lda 	#0
.b1ba	ae f9 06	ldx $06f9			ldx 	GXSizeBits
.b1bd					_GXTimesRowNumber:
.b1bd	18		clc				clc
.b1be	65 36		adc $36				adc 	zTemp0
.b1c0	ca		dex				dex
.b1c1	10 fa		bpl $b1bd			bpl 	_GXTimesRowNumber
.b1c3	64 37		stz $37				stz 	gxzTemp0+1
.b1c5	0a		asl a				asl 	a 							; row x 2,4,6,8
.b1c6	26 37		rol $37				rol 	gxzTemp0+1
.b1c8	0a		asl a				asl 	a 							; row x 4,8,12,16
.b1c9	26 37		rol $37				rol 	gxzTemp0+1
.b1cb	0a		asl a				asl 	a 							; row x 8,16,24,32
.b1cc	26 37		rol $37				rol 	gxzTemp0+1
.b1ce	85 36		sta $36				sta 	gxzTemp0
.b1d0	18		clc				clc 								; add base address.
.b1d1	a5 36		lda $36				lda 	gxzTemp0
.b1d3	6d fb 06	adc $06fb			adc 	GXSpriteOffset
.b1d6	85 36		sta $36				sta 	gxzTemp0
.b1d8	a5 37		lda $37				lda 	gxzTemp0+1
.b1da	6d fc 06	adc $06fc			adc 	GXSpriteOffset+1
.b1dd					_GXSAFindPage:
.b1dd	c9 20		cmp #$20			cmp 	#$20 						; on this page
.b1df	90 06		bcc $b1e7			bcc 	_GXSAFoundPage
.b1e1	e9 20		sbc #$20			sbc 	#$20 						; forward one page
.b1e3	e6 0b		inc $0b				inc 	GXEditSlot
.b1e5	80 f6		bra $b1dd			bra 	_GXSAFindPage
.b1e7					_GXSAFoundPage:
.b1e7	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; physical address of page.
.b1e9	85 37		sta $37				sta 	gxzTemp0+1 					; gxzTemp0 now points to the page
.b1eb	a0 00		ldy #$00			ldy 	#0
.b1ed					_GXSACopyLoop:
.b1ed	b1 36		lda ($36),y			lda 	(gxzTemp0),y
.b1ef	99 fb 05	sta $05fb,y			sta 	gxPixelBuffer,y
.b1f2	c8		iny				iny
.b1f3	cc f8 06	cpy $06f8			cpy 	GXSizePixels
.b1f6	d0 f5		bne $b1ed			bne 	_GXSACopyLoop
.b1f8	60		rts				rts
.b1f9					GXSelect:
.b1f9	ad 55 06	lda $0655			lda 	gxSpritesOn
.b1fc	f0 22		beq $b220			beq 	_GXSFail
.b1fe	a5 36		lda $36				lda 	gxzTemp0 					; illegal sprite #
.b200	c9 40		cmp #$40			cmp 	#64
.b202	b0 1c		bcs $b220			bcs 	_GXSFail
.b204	8d 60 06	sta $0660			sta 	GSCurrentSpriteID
.b207	a4 37		ldy $37				ldy 	gxzTemp0+1 					; control value.
.b209	a9 00		lda #$00			lda  	#0 							; multiply sprite # x 8 => A
.b20b	06 36		asl $36				asl 	gxzTemp0
.b20d	06 36		asl $36				asl 	gxzTemp0
.b20f	06 36		asl $36				asl 	gxzTemp0
.b211	2a		rol a				rol 	a
.b212	69 d9		adc #$d9			adc 	#$D9 						; sprite area
.b214	8d 62 06	sta $0662			sta 	GSCurrentSpriteAddr+1 		; address to GSCurrentSprite and gxzTemp
.b217	85 37		sta $37				sta 	gxzTemp0+1
.b219	a5 36		lda $36				lda 	gxzTemp0
.b21b	8d 61 06	sta $0661			sta 	GSCurrentSpriteAddr
.b21e	18		clc				clc
.b21f	60		rts				rts
.b220					_GXSFail:
.b220	38		sec				sec
.b221	60		rts				rts
.b222					GXSelectImage:
.b222	ad 55 06	lda $0655			lda 	gxSpritesOn
.b225	f0 74		beq $b29b			beq 	_GXSIFail
.b227	ad 62 06	lda $0662			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b22a	f0 6f		beq $b29b			beq 	_GXSIFail 					; (checking the MSB)
.b22c	64 01		stz $01				stz 	1
.b22e	a5 37		lda $37				lda 	gxzTemp0+1 					; push show/hide on the stack.
.b230	d0 6b		bne $b29d			bne 	_GXSIHide
.b232	a5 36		lda $36				lda 	gxzTemp0 					; sprite image
.b234	48		pha				pha
.b235	20 28 b3	jsr $b328			jsr 	GXOpenBitmap
.b238	68		pla				pla
.b239	20 09 b4	jsr $b409			jsr 	GXFindSprite
.b23c	b0 5a		bcs $b298			bcs 	_GXSICloseFail 				; no image
.b23e	a0 01		ldy #$01			ldy 	#1
.b240	ad 61 06	lda $0661			lda 	GSCurrentSpriteAddr
.b243	85 36		sta $36				sta 	gxzTemp0
.b245	ad 62 06	lda $0662			lda 	GSCurrentSpriteAddr+1
.b248	85 37		sta $37				sta 	gxzTemp0+1
.b24a	ad fb 06	lda $06fb			lda 	GXSpriteOffset
.b24d	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b24f	18		clc				clc
.b250	ad fc 06	lda $06fc			lda 	GXSpriteOffset+1
.b253	6d 63 06	adc $0663			adc 	GXSpriteOffsetBase
.b256	c8		iny				iny
.b257	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b259	ad 64 06	lda $0664			lda 	GXSpriteOffsetBase+1
.b25c	69 00		adc #$00			adc 	#0
.b25e	c8		iny				iny
.b25f	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b261	ad f9 06	lda $06f9			lda 	GXSizeBits 					; get raw size
.b264	49 03		eor #$03			eor 	#3 							; make it right (00=32 etc.)
.b266	2a		rol a				rol 	a 							; x 2
.b267	0a		asl a				asl 	a 							; x 4
.b268	0a		asl a				asl 	a 							; x 8
.b269	0a		asl a				asl 	a 							; x 16
.b26a	0d fa 06	ora $06fa			ora 	GXSpriteLUT 				; Or with LUT
.b26d	0a		asl a				asl 	a 							; 1 shift
.b26e	09 01		ora #$01			ora 	#1 							; enable sprite.
.b270	92 36		sta ($36)			sta 	(gxzTemp0) 					; and write back
.b272	20 30 b3	jsr $b330			jsr 	GXCloseBitmap
.b275	ae 60 06	ldx $0660			ldx 	GSCurrentSpriteID 			; point to sprite entries.
.b278	bd a5 06	lda $06a5,x			lda 	GXSpriteHigh,x 				; clear upper two bits of size
.b27b	29 3f		and #$3f			and 	#$3F
.b27d	9d a5 06	sta $06a5,x			sta 	GXSpriteHigh,x
.b280	ad f9 06	lda $06f9			lda 	GXSizeBits 					; get bit size
.b283	6a		ror a				ror 	a 							; shift into bits 6/7
.b284	6a		ror a				ror 	a
.b285	6a		ror a				ror 	a
.b286	29 c0		and #$c0			and 	#$C0
.b288	1d a5 06	ora $06a5,x			ora 	GXSpriteHigh,x 				; put in  upper 2 bits of sprite data
.b28b	9d a5 06	sta $06a5,x			sta 	GXSpriteHigh,x
.b28e	bd 65 06	lda $0665,x			lda 	GXSpriteLow,x 				; clear hidden flag.
.b291	29 7f		and #$7f			and 	#$7F
.b293	9d 65 06	sta $0665,x			sta 	GXSpriteLow,x
.b296	18		clc				clc
.b297	60		rts				rts
.b298					_GXSICloseFail:
.b298	20 30 b3	jsr $b330			jsr 	GXCloseBitmap
.b29b					_GXSIFail:
.b29b	38		sec				sec
.b29c	60		rts				rts
.b29d					_GXSIHide:
.b29d	ad 61 06	lda $0661			lda 	GSCurrentSpriteAddr  		; get Sprite h/w address and write there
.b2a0	85 36		sta $36				sta 	gxzTemp0
.b2a2	ad 62 06	lda $0662			lda 	GSCurrentSpriteAddr+1
.b2a5	85 37		sta $37				sta 	gxzTemp0+1
.b2a7	a9 00		lda #$00			lda 	#0
.b2a9	92 36		sta ($36)			sta 	(gxzTemp0)
.b2ab	ae 60 06	ldx $0660			ldx 	GSCurrentSpriteID 			; get sprite ID
.b2ae	bd 65 06	lda $0665,x			lda 	GXSpriteLow,x 				; set the hidden bit.
.b2b1	09 80		ora #$80			ora 	#$80
.b2b3	9d 65 06	sta $0665,x			sta 	GXSpriteLow,x
.b2b6	18		clc				clc
.b2b7	60		rts				rts
.b2b8					GXMoveSprite:
.b2b8	ad 55 06	lda $0655			lda 	gxSpritesOn
.b2bb	f0 65		beq $b322			beq 	_GXSIFail
.b2bd	ad 62 06	lda $0662			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b2c0	f0 60		beq $b322			beq 	_GXSIFail
.b2c2	85 37		sta $37				sta 	gxzTemp0+1
.b2c4	a0 04		ldy #$04			ldy 	#4
.b2c6	ad 61 06	lda $0661			lda 	GSCurrentSpriteAddr
.b2c9	85 36		sta $36				sta 	gxzTemp0
.b2cb	ae 60 06	ldx $0660			ldx 	GSCurrentSpriteID 			; get the size from the upper two bits
.b2ce	bd a5 06	lda $06a5,x			lda 	GXSpriteHigh,x
.b2d1	2a		rol a				rol 	a	 						; into bits 0,1.
.b2d2	2a		rol a				rol 	a
.b2d3	2a		rol a				rol 	a
.b2d4	29 03		and #$03			and 	#3
.b2d6	aa		tax				tax
.b2d7	bd 24 b3	lda $b324,x			lda 	_GXMSOffset,x 				; get 32-SpriteSize/2
.b2da	48		pha				pha
.b2db	18		clc				clc
.b2dc	6d 4d 06	adc $064d			adc 	gxX0						; copy position.
.b2df	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2e1	c8		iny				iny
.b2e2	ad 4e 06	lda $064e			lda 	gxX0+1
.b2e5	69 00		adc #$00			adc 	#0
.b2e7	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2e9	c8		iny				iny
.b2ea	68		pla				pla
.b2eb	18		clc				clc
.b2ec	6d 4f 06	adc $064f			adc 	gxY0
.b2ef	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2f1	a9 00		lda #$00			lda 	#0
.b2f3	69 00		adc #$00			adc 	#0
.b2f5	c8		iny				iny
.b2f6	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2f8	4e 4e 06	lsr $064e			lsr 	gxX0+1 						; divide X by 4
.b2fb	6e 4d 06	ror $064d			ror 	gxX0
.b2fe	4e 4d 06	lsr $064d			lsr 	gxX0
.b301	4e 4f 06	lsr $064f			lsr 	gxY0 						; divide Y by 4
.b304	4e 4f 06	lsr $064f			lsr 	gxY0
.b307	ae 60 06	ldx $0660			ldx 	GSCurrentSpriteID 			; copy X/4 and Y/4 into the status bytes
.b30a	bd 65 06	lda $0665,x			lda 	GXSpriteLow,x
.b30d	29 80		and #$80			and 	#$80
.b30f	0d 4d 06	ora $064d			ora 	gxX0
.b312	9d 65 06	sta $0665,x			sta 	GXSpriteLow,x
.b315	bd a5 06	lda $06a5,x			lda 	GXSpriteHigh,x
.b318	29 c0		and #$c0			and 	#$C0
.b31a	0d 4f 06	ora $064f			ora 	gxY0
.b31d	9d a5 06	sta $06a5,x			sta 	GXSpriteHigh,x
.b320	18		clc				clc
.b321	60		rts				rts
.b322					_GXSIFail:
.b322	38		sec				sec
.b323	60		rts				rts
.b324					_GXMSOffset:
>b324	1c						.byte 	32-8/2
>b325	18						.byte 	32-16/2
>b326	14						.byte 	32-24/2
>b327	10						.byte 	32-32/2
.b328					GXOpenBitmap:
.b328	78		sei				sei 								; no interrupts here
.b329	a5 0b		lda $0b				lda 	GXEditSlot 					; Save the original LUT slot value
.b32b	8d 5e 06	sta $065e			sta 	gxOriginalLUTValue
.b32e	58		cli				cli
.b32f	60		rts				rts
.b330					GXCloseBitmap:
.b330	78		sei				sei
.b331	ad 5e 06	lda $065e			lda 	gxOriginalLUTValue 			; restore LUT slot value
.b334	85 0b		sta $0b				sta 	GXEditSlot
.b336	58		cli				cli
.b337	60		rts				rts
.b338					GXPositionCalc:
.b338	a5 36		lda $36				lda 	gxzTemp0 					; save temp memory slot
.b33a	48		pha				pha
.b33b	ad 4f 06	lda $064f			lda 	GXY0 						; gxzScreen = Y0
.b33e	85 3c		sta $3c				sta 	gxzScreen
.b340	64 3d		stz $3d				stz 	gxzScreen+1
.b342	06 3c		asl $3c				asl 	gxzScreen 						; gxzScreen = Y0 * 4
.b344	26 3d		rol $3d				rol 	gxzScreen+1
.b346	06 3c		asl $3c				asl 	gxzScreen
.b348	26 3d		rol $3d				rol 	gxzScreen+1
.b34a	18		clc				clc 								; gxzScreen = Y0 * 5, as it's still in A
.b34b	65 3c		adc $3c				adc 	gxzScreen
.b34d	85 3c		sta $3c				sta 	gxzScreen
.b34f	90 02		bcc $b353			bcc 	_GXPCNoCarry
.b351	e6 3d		inc $3d				inc 	gxzScreen+1
.b353					_GXPCNoCarry:
.b353	06 3c		asl $3c				asl 	gxzScreen 						; now Y0 * 10. Needs to be multiplied by another
.b355	26 3d		rol $3d				rol 	gxzScreen+1 					; 32. At this point the MSB contains the offset
.b357	a5 3d		lda $3d				lda	 	gxzScreen+1 					; so save this in zTemp0 and zero it.
.b359	85 36		sta $36				sta 	gxzTemp0
.b35b	64 3d		stz $3d				stz 	gxzScreen+1
.b35d	a9 05		lda #$05			lda 	#5 							; now multiply by 32, this puts this in the range 0..8191
.b35f					_GXPCMultiply32:
.b35f	06 3c		asl $3c				asl 	gxzScreen
.b361	26 3d		rol $3d				rol 	gxzScreen+1
.b363	3a		dec a				dec 	a
.b364	d0 f9		bne $b35f			bne 	_GXPCMultiply32
.b366	18		clc				clc
.b367	ad 4d 06	lda $064d			lda 	GXX0 						; add X to this value, put the result in gsOffset, gxzScreen has to be on a page boundary
.b36a	65 3c		adc $3c				adc 	gxzScreen
.b36c	8d 5f 06	sta $065f			sta 	gsOffset
.b36f	ad 4e 06	lda $064e			lda 	GXX0+1
.b372	65 3d		adc $3d				adc 	gxzScreen+1
.b374	c9 20		cmp #$20			cmp 	#$20 						; has it overflowed into the next one ?
.b376	90 04		bcc $b37c			bcc 	_GXPCNoOverflow
.b378	29 1f		and #$1f			and 	#$1F 						; fix it up
.b37a	e6 36		inc $36				inc 	gxzTemp0 					; add 1 to the page number
.b37c					_GXPCNoOverflow:
.b37c	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; make it the address mapped in.
.b37e	85 3d		sta $3d				sta 	gxzScreen+1
.b380	64 3c		stz $3c				stz 	gxzScreen
.b382	18		clc				clc
.b383	a5 36		lda $36				lda 	gxzTemp0 					; get the page number
.b385	6d 57 06	adc $0657			adc 	gxBasePage 					; by adding the base page
.b388	85 0b		sta $0b				sta 	GXEditSlot 				; and map it into memory.
.b38a	68		pla				pla
.b38b	85 36		sta $36				sta 	gxzTemp0
.b38d	60		rts				rts
.b38e					GXMovePositionDown:
.b38e	18		clc				clc 								; add 320 to offset/temp+1
.b38f	ad 5f 06	lda $065f			lda 	gsOffset
.b392	69 40		adc #$40			adc 	#64
.b394	8d 5f 06	sta $065f			sta 	gsOffset
.b397	a5 3d		lda $3d				lda 	gxzScreen+1
.b399	69 01		adc #$01			adc 	#1
.b39b	85 3d		sta $3d				sta 	gxzScreen+1
.b39d	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page
.b39f	90 07		bcc $b3a8			bcc 	_GXMPDExit
.b3a1	38		sec				sec  								; next page
.b3a2	e9 20		sbc #$20			sbc 	#$20
.b3a4	85 3d		sta $3d				sta 	gxzScreen+1
.b3a6	e6 0b		inc $0b				inc 	GXEditSlot
.b3a8					_GXMPDExit:
.b3a8	60		rts				rts
.b3a9					GXCollide:
.b3a9	a5 36		lda $36				lda 	gxzTemp0 					; check if sprite numbers are legal.
.b3ab	aa		tax				tax
.b3ac	05 37		ora $37				ora 	gxzTemp0+1
.b3ae	29 c0		and #$c0			and 	#$C0
.b3b0	38		sec				sec
.b3b1	d0 53		bne $b406			bne 	_GXCollideFail 				; if either >= 64, fail.
.b3b3	a4 37		ldy $37				ldy 	gxzTemp0+1 					; at this point X is 1st sprite and Y is 2nd sprite.
.b3b5	b9 65 06	lda $0665,y			lda 	GXSpriteLow,y 				; check if either hidden bit is set
.b3b8	1d 65 06	ora $0665,x			ora 	GXSpriteLow,x
.b3bb	30 48		bmi $b405			bmi 	_GXOkayFail 				; if either hidden, then they cannot collide.
.b3bd	18		clc				clc 								; need to calculate sum of sizes.
.b3be	b9 a5 06	lda $06a5,y			lda 	GXSpriteHigh,y
.b3c1	7d a5 06	adc $06a5,x			adc 	GXSpriteHigh,x 				; at this point, CS, Bit 6 and 7 contain that sum.
.b3c4	29 c0		and #$c0			and 	#$C0 					 	; mask off
.b3c6	6a		ror a				ror 	a 							; 5/6/7
.b3c7	4a		lsr a				lsr 	a 							; 4/5/6
.b3c8	4a		lsr a				lsr 	a 							; 3/4/5
.b3c9	4a		lsr a				lsr 	a 							; 2/3/4
.b3ca	18		clc				clc
.b3cb	69 08		adc #$08			adc 	#$08
.b3cd	4a		lsr a				lsr 	a 							; adjust because all coordinates are divided by 4 to store.
.b3ce	4a		lsr a				lsr 	a
.b3cf	85 38		sta $38				sta 	gxzTemp1 					; so the difference between the centres has to be less than this.
.b3d1	b9 a5 06	lda $06a5,y			lda 	GXSpriteHigh,y 				; calculate y1-y0
.b3d4	29 3f		and #$3f			and 	#$3F
.b3d6	85 39		sta $39				sta 	gxzTemp1+1
.b3d8	38		sec				sec
.b3d9	bd a5 06	lda $06a5,x			lda 	GXSpriteHigh,x
.b3dc	29 3f		and #$3f			and 	#$3F
.b3de	e5 39		sbc $39				sbc 	gxzTemp1+1
.b3e0	b0 03		bcs $b3e5			bcs 	_GXCAbs1 					; calculate |y1-y0|
.b3e2	49 ff		eor #$ff			eor 	#$FF
.b3e4	1a		inc a				inc 	a
.b3e5					_GXCAbs1:
.b3e5	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b3e7	b0 1c		bcs $b405			bcs 	_GXOkayFail
.b3e9	85 39		sta $39				sta 	gxzTemp1+1 					; save |y1-y0|
.b3eb	38		sec				sec 								; calculate |x1-x0|
.b3ec	b9 65 06	lda $0665,y			lda 	GXSpriteLow,y
.b3ef	fd 65 06	sbc $0665,x			sbc 	GXSpriteLow,x
.b3f2	b0 03		bcs $b3f7			bcs 	_GXCAbs2
.b3f4	49 ff		eor #$ff			eor 	#$FF
.b3f6	1a		inc a				inc 	a
.b3f7					_GXCAbs2:
.b3f7	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b3f9	b0 0a		bcs $b405			bcs 	_GXOkayFail
.b3fb	c5 39		cmp $39				cmp 	gxzTemp1+1 					; is it less than the previous one.
.b3fd	90 02		bcc $b401			bcc 	_GXCHaveLowest
.b3ff	a5 39		lda $39				lda 	gxzTemp1+1 					; if not, that's the smallest difference.
.b401					_GXCHaveLowest:
.b401	0a		asl a				asl 	a 							; scale to allow for >> 2
.b402	0a		asl a				asl 	a
.b403	18		clc				clc
.b404	60		rts				rts
.b405					_GXOkayFail:
.b405	18		clc				clc
.b406					_GXCollideFail:
.b406	a9 ff		lda #$ff			lda 	#$FF
.b408	60		rts				rts
.b409					GXFindSprite:
.b409	aa		tax				tax
.b40a	ad 58 06	lda $0658			lda 	GXSpritePage 				; access the base page of the sprite
.b40d	85 0b		sta $0b				sta 	GXEditSlot
.b40f	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; check a valid sprite
.b412	1d 00 60	ora $6000,x			ora 	GXMappingAddress,x
.b415	f0 33		beq $b44a			beq 	_GXFSFail
.b417	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; MSB
.b41a	8d fc 06	sta $06fc			sta 	GXSpriteOffset+1
.b41d	bd 00 60	lda $6000,x			lda 	GXMappingAddress,x 			; LSB
.b420	48		pha				pha 								; save twice
.b421	48		pha				pha
.b422	29 03		and #$03			and 	#3 							; get sprite size
.b424	8d f9 06	sta $06f9			sta 	GXSizeBits 					; save raw (0-3)
.b427	aa		tax				tax
.b428	bd 4c b4	lda $b44c,x			lda 	_GXFXSSTTable,x 			; read sprite size
.b42b	8d f8 06	sta $06f8			sta 	GXSizePixels 					; save (8/16/24/32)
.b42e	68		pla				pla 								; get LUT
.b42f	4a		lsr a				lsr		a
.b430	4a		lsr a				lsr		a
.b431	29 03		and #$03			and 	#3
.b433	8d fa 06	sta $06fa			sta 	GXSpriteLUT
.b436	68		pla				pla 								; address, neeeds to be x 4
.b437	29 f0		and #$f0			and 	#$F0
.b439	8d fb 06	sta $06fb			sta 	GXSpriteOffset
.b43c	0e fb 06	asl $06fb			asl 	GXSpriteOffset
.b43f	2e fc 06	rol $06fc			rol 	GXSpriteOffset+1
.b442	0e fb 06	asl $06fb			asl 	GXSpriteOffset
.b445	2e fc 06	rol $06fc			rol 	GXSpriteOffset+1
.b448	18		clc				clc
.b449	60		rts				rts
.b44a					_GXFSFail:
.b44a	38		sec				sec
.b44b	60		rts				rts
.b44c					_GXFXSSTTable:
>b44c	08 10 18 20					.byte 	8,16,24,32
.06f8					GXSizePixels:
>06f8							.fill 	1
.06f9					GXSizeBits:
>06f9							.fill 	1
.06fa					GXSpriteLUT:
>06fa							.fill 	1
.06fb					GXSpriteOffset:
>06fb							.fill 	2
.b450					GXSortXY:
.b450	20 6e b4	jsr $b46e			jsr 	GXSortY 					; will be sorted on Y now
.b453	ad 4d 06	lda $064d			lda 	gxX0 						; compare X0 v X1
.b456	cd 51 06	cmp $0651			cmp 	gxX1
.b459	ad 4e 06	lda $064e			lda 	gXX0+1
.b45c	ed 52 06	sbc $0652			sbc 	gXX1+1
.b45f	90 0c		bcc $b46d			bcc 	_GXSXYExit 					; X0 < X1 exit
.b461	a2 00		ldx #$00			ldx 	#0 							; swap them over
.b463	a0 04		ldy #$04			ldy 	#4
.b465	20 82 b4	jsr $b482			jsr 	GXSwapXY
.b468	e8		inx				inx
.b469	c8		iny				iny
.b46a	20 82 b4	jsr $b482			jsr 	GXSwapXY
.b46d					_GXSXYExit:
.b46d	60		rts				rts
.b46e					GXSortY:
.b46e	ad 4f 06	lda $064f			lda 	gxY0 						; if Y0 >= Y1
.b471	cd 53 06	cmp $0653			cmp 	gxY1
.b474	90 0b		bcc $b481			bcc 	_GXSYSorted
.b476	a2 03		ldx #$03			ldx 	#3 							; swap 3-0
.b478	a0 07		ldy #$07			ldy 	#7 							; with 4-7
.b47a					_GXSwap1:
.b47a	20 82 b4	jsr $b482			jsr 	GXSwapXY
.b47d	88		dey				dey
.b47e	ca		dex				dex
.b47f	10 f9		bpl $b47a			bpl 	_GXSwap1
.b481					_GXSYSorted:
.b481	60		rts				rts
.b482					GXSwapXY:
.b482	bd 4d 06	lda $064d,x			lda 	gxX0,x
.b485	48		pha				pha
.b486	b9 4d 06	lda $064d,y			lda 	gxX0,y
.b489	9d 4d 06	sta $064d,x			sta 	gxX0,x
.b48c	68		pla				pla
.b48d	99 4d 06	sta $064d,y			sta 	gxX0,y
.b490	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_tokeniser.module

=1					tokeniserIntegrated=1
.bb12					KeywordSet0:
>bb12	00 65					.text	0,$65,""               ; $80 !0:EOF
>bb14	00 58					.text	0,$58,""               ; $81 !1:SH1
>bb16	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bb18	04 fe 41 42 53 28			.text	4,$fe,"ABS("           ; $83 ABS(
>bb1e	06 93 41 4c 4c 4f 43 28			.text	6,$93,"ALLOC("         ; $84 ALLOC(
>bb26	04 ff 41 53 43 28			.text	4,$ff,"ASC("           ; $85 ASC(
>bb2c	05 29 43 48 52 24 28			.text	5,$29,"CHR$("          ; $86 CHR$(
>bb33	06 aa 45 56 45 4e 54 28			.text	6,$aa,"EVENT("         ; $87 EVENT(
>bb3b	05 6b 46 41 4c 53 45			.text	5,$6b,"FALSE"          ; $88 FALSE
>bb42	05 44 46 52 41 43 28			.text	5,$44,"FRAC("          ; $89 FRAC(
>bb49	04 0d 48 49 54 28			.text	4,$0d,"HIT("           ; $8a HIT(
>bb4f	04 13 49 4e 54 28			.text	4,$13,"INT("           ; $8b INT(
>bb55	06 a7 49 53 56 41 4c 28			.text	6,$a7,"ISVAL("         ; $8c ISVAL(
>bb5d	05 5c 4a 4f 59 42 28			.text	5,$5c,"JOYB("          ; $8d JOYB(
>bb64	05 72 4a 4f 59 58 28			.text	5,$72,"JOYX("          ; $8e JOYX(
>bb6b	05 73 4a 4f 59 59 28			.text	5,$73,"JOYY("          ; $8f JOYY(
>bb72	06 77 4c 45 46 54 24 28			.text	6,$77,"LEFT$("         ; $90 LEFT$(
>bb7a	04 07 4c 45 4e 28			.text	4,$07,"LEN("           ; $91 LEN(
>bb80	04 0e 4d 41 58 28			.text	4,$0e,"MAX("           ; $92 MAX(
>bb86	05 26 4d 49 44 24 28			.text	5,$26,"MID$("          ; $93 MID$(
>bb8d	04 0c 4d 49 4e 28			.text	4,$0c,"MIN("           ; $94 MIN(
>bb93	04 19 4e 4f 54 28			.text	4,$19,"NOT("           ; $95 NOT(
>bb99	08 3c 50 4c 41 59 49 4e			.text	8,$3c,"PLAYING("       ; $96 PLAYING(
>bba1	47 28
>bba3	07 e9 52 41 4e 44 4f 4d			.text	7,$e9,"RANDOM("        ; $97 RANDOM(
>bbab	28
>bbac	07 ca 52 49 47 48 54 24			.text	7,$ca,"RIGHT$("        ; $98 RIGHT$(
>bbb4	28
>bbb5	04 0c 52 4e 44 28			.text	4,$0c,"RND("           ; $99 RND(
>bbbb	04 10 53 47 4e 28			.text	4,$10,"SGN("           ; $9a SGN(
>bbc1	04 0e 53 50 43 28			.text	4,$0e,"SPC("           ; $9b SPC(
>bbc7	05 45 53 54 52 24 28			.text	5,$45,"STR$("          ; $9c STR$(
>bbce	06 a9 54 49 4d 45 52 28			.text	6,$a9,"TIMER("         ; $9d TIMER(
>bbd6	04 40 54 52 55 45			.text	4,$40,"TRUE"           ; $9e TRUE
>bbdc	04 0b 56 41 4c 28			.text	4,$0b,"VAL("           ; $9f VAL(
>bbe2	03 e7 46 4f 52				.text	3,$e7,"FOR"            ; $a0 FOR
>bbe7	02 8f 49 46				.text	2,$8f,"IF"             ; $a1 IF
>bbeb	04 34 50 52 4f 43			.text	4,$34,"PROC"           ; $a2 PROC
>bbf1	06 c1 52 45 50 45 41 54			.text	6,$c1,"REPEAT"         ; $a3 REPEAT
>bbf9	05 79 57 48 49 4c 45			.text	5,$79,"WHILE"          ; $a4 WHILE
>bc00	05 66 45 4e 44 49 46			.text	5,$66,"ENDIF"          ; $a5 ENDIF
>bc07	07 0b 45 4e 44 50 52 4f			.text	7,$0b,"ENDPROC"        ; $a6 ENDPROC
>bc0f	43
>bc10	04 3f 4e 45 58 54			.text	4,$3f,"NEXT"           ; $a7 NEXT
>bc16	04 2f 54 48 45 4e			.text	4,$2f,"THEN"           ; $a8 THEN
>bc1c	05 8c 55 4e 54 49 4c			.text	5,$8c,"UNTIL"          ; $a9 UNTIL
>bc23	04 2e 57 45 4e 44			.text	4,$2e,"WEND"           ; $aa WEND
>bc29	02 9b 42 59				.text	2,$9b,"BY"             ; $ab BY
>bc2d	04 1c 43 41 4c 4c			.text	4,$1c,"CALL"           ; $ac CALL
>bc33	06 b2 43 49 52 43 4c 45			.text	6,$b2,"CIRCLE"         ; $ad CIRCLE
>bc3b	05 67 43 4c 45 41 52			.text	5,$67,"CLEAR"          ; $ae CLEAR
>bc42	03 e2 43 4c 53				.text	3,$e2,"CLS"            ; $af CLS
>bc47	05 7f 43 4f 4c 4f 52			.text	5,$7f,"COLOR"          ; $b0 COLOR
>bc4e	06 d4 43 4f 4c 4f 55 52			.text	6,$d4,"COLOUR"         ; $b1 COLOUR
>bc56	04 1a 44 41 54 41			.text	4,$1a,"DATA"           ; $b2 DATA
>bc5c	03 da 44 49 4d				.text	3,$da,"DIM"            ; $b3 DIM
>bc61	06 db 44 4f 57 4e 54 4f			.text	6,$db,"DOWNTO"         ; $b4 DOWNTO
>bc69	04 29 45 4c 53 45			.text	4,$29,"ELSE"           ; $b5 ELSE
>bc6f	04 34 46 52 4f 4d			.text	4,$34,"FROM"           ; $b6 FROM
>bc75	03 e5 47 46 58				.text	3,$e5,"GFX"            ; $b7 GFX
>bc7a	05 80 47 4f 53 55 42			.text	5,$80,"GOSUB"          ; $b8 GOSUB
>bc81	04 39 47 4f 54 4f			.text	4,$39,"GOTO"           ; $b9 GOTO
>bc87	04 24 48 45 52 45			.text	4,$24,"HERE"           ; $ba HERE
>bc8d	05 63 49 4d 41 47 45			.text	5,$63,"IMAGE"          ; $bb IMAGE
>bc94	05 90 49 4e 50 55 54			.text	5,$90,"INPUT"          ; $bc INPUT
>bc9b	03 e5 4c 45 54				.text	3,$e5,"LET"            ; $bd LET
>bca0	04 28 4c 49 4e 45			.text	4,$28,"LINE"           ; $be LINE
>bca6	05 6b 4c 4f 43 41 4c			.text	5,$6b,"LOCAL"          ; $bf LOCAL
>bcad	03 db 4f 46 46				.text	3,$db,"OFF"            ; $c0 OFF
>bcb2	02 9d 4f 4e				.text	2,$9d,"ON"             ; $c1 ON
>bcb6	07 20 4f 55 54 4c 49 4e			.text	7,$20,"OUTLINE"        ; $c2 OUTLINE
>bcbe	45
>bcbf	07 0f 50 41 4c 45 54 54			.text	7,$0f,"PALETTE"        ; $c3 PALETTE
>bcc7	45
>bcc8	04 3f 50 4c 4f 54			.text	4,$3f,"PLOT"           ; $c4 PLOT
>bcce	05 8d 50 52 49 4e 54			.text	5,$8d,"PRINT"          ; $c5 PRINT
>bcd5	04 1c 52 45 41 44			.text	4,$1c,"READ"           ; $c6 READ
>bcdb	04 2e 52 45 43 54			.text	4,$2e,"RECT"           ; $c7 RECT
>bce1	03 e4 52 45 4d				.text	3,$e4,"REM"            ; $c8 REM
>bce6	06 e0 52 45 54 55 52 4e			.text	6,$e0,"RETURN"         ; $c9 RETURN
>bcee	05 7b 53 4f 4c 49 44			.text	5,$7b,"SOLID"          ; $ca SOLID
>bcf5	05 89 53 4f 55 4e 44			.text	5,$89,"SOUND"          ; $cb SOUND
>bcfc	06 d7 53 50 52 49 54 45			.text	6,$d7,"SPRITE"         ; $cc SPRITE
>bd04	04 45 54 45 58 54			.text	4,$45,"TEXT"           ; $cd TEXT
>bd0a	02 a3 54 4f				.text	2,$a3,"TO"             ; $ce TO
>bd0e	ff					.text	$FF
.bd0f					KeywordSet1:
>bd0f	00 65					.text	0,$65,""               ; $80 !0:EOF
>bd11	00 58					.text	0,$58,""               ; $81 !1:SH1
>bd13	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bd15	08 4c 41 53 53 45 4d 42			.text	8,$4c,"ASSEMBLE"       ; $83 ASSEMBLE
>bd1d	4c 45
>bd1f	06 d2 41 53 53 45 52 54			.text	6,$d2,"ASSERT"         ; $84 ASSERT
>bd27	06 bd 42 49 54 4d 41 50			.text	6,$bd,"BITMAP"         ; $85 BITMAP
>bd2f	03 d7 45 4e 44				.text	3,$d7,"END"            ; $86 END
>bd34	02 96 47 4f				.text	2,$96,"GO"             ; $87 GO
>bd38	04 3c 4c 49 53 54			.text	4,$3c,"LIST"           ; $88 LIST
>bd3e	04 20 4c 4f 41 44			.text	4,$20,"LOAD"           ; $89 LOAD
>bd44	03 ea 4e 45 57				.text	3,$ea,"NEW"            ; $8a NEW
>bd49	07 24 52 45 53 54 4f 52			.text	7,$24,"RESTORE"        ; $8b RESTORE
>bd51	45
>bd52	03 f5 52 55 4e				.text	3,$f5,"RUN"            ; $8c RUN
>bd57	07 2a 53 50 52 49 54 45			.text	7,$2a,"SPRITES"        ; $8d SPRITES
>bd5f	53
>bd60	04 46 53 54 4f 50			.text	4,$46,"STOP"           ; $8e STOP
>bd66	ff					.text	$FF
.bd67					KeywordSet2:
>bd67	00 65					.text	0,$65,""               ; $80 !0:EOF
>bd69	00 58					.text	0,$58,""               ; $81 !1:SH1
>bd6b	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bd6d	03 c8 41 44 43				.text	3,$c8,"ADC"            ; $83 ADC
>bd72	03 d3 41 4e 44				.text	3,$d3,"AND"            ; $84 AND
>bd77	03 e0 41 53 4c				.text	3,$e0,"ASL"            ; $85 ASL
>bd7c	03 c8 42 43 43				.text	3,$c8,"BCC"            ; $86 BCC
>bd81	03 d8 42 43 53				.text	3,$d8,"BCS"            ; $87 BCS
>bd86	03 d8 42 45 51				.text	3,$d8,"BEQ"            ; $88 BEQ
>bd8b	03 df 42 49 54				.text	3,$df,"BIT"            ; $89 BIT
>bd90	03 d8 42 4d 49				.text	3,$d8,"BMI"            ; $8a BMI
>bd95	03 d5 42 4e 45				.text	3,$d5,"BNE"            ; $8b BNE
>bd9a	03 de 42 50 4c				.text	3,$de,"BPL"            ; $8c BPL
>bd9f	03 d5 42 52 41				.text	3,$d5,"BRA"            ; $8d BRA
>bda4	03 df 42 52 4b				.text	3,$df,"BRK"            ; $8e BRK
>bda9	03 db 42 56 43				.text	3,$db,"BVC"            ; $8f BVC
>bdae	03 eb 42 56 53				.text	3,$eb,"BVS"            ; $90 BVS
>bdb3	03 d2 43 4c 43				.text	3,$d2,"CLC"            ; $91 CLC
>bdb8	03 d3 43 4c 44				.text	3,$d3,"CLD"            ; $92 CLD
>bdbd	03 d8 43 4c 49				.text	3,$d8,"CLI"            ; $93 CLI
>bdc2	03 e5 43 4c 56				.text	3,$e5,"CLV"            ; $94 CLV
>bdc7	03 e0 43 4d 50				.text	3,$e0,"CMP"            ; $95 CMP
>bdcc	03 eb 43 50 58				.text	3,$eb,"CPX"            ; $96 CPX
>bdd1	03 ec 43 50 59				.text	3,$ec,"CPY"            ; $97 CPY
>bdd6	03 cc 44 45 43				.text	3,$cc,"DEC"            ; $98 DEC
>bddb	03 e1 44 45 58				.text	3,$e1,"DEX"            ; $99 DEX
>bde0	03 e2 44 45 59				.text	3,$e2,"DEY"            ; $9a DEY
>bde5	03 e6 45 4f 52				.text	3,$e6,"EOR"            ; $9b EOR
>bdea	03 da 49 4e 43				.text	3,$da,"INC"            ; $9c INC
>bdef	03 ef 49 4e 58				.text	3,$ef,"INX"            ; $9d INX
>bdf4	03 f0 49 4e 59				.text	3,$f0,"INY"            ; $9e INY
>bdf9	03 e7 4a 4d 50				.text	3,$e7,"JMP"            ; $9f JMP
>bdfe	03 ef 4a 53 52				.text	3,$ef,"JSR"            ; $a0 JSR
>be03	03 d1 4c 44 41				.text	3,$d1,"LDA"            ; $a1 LDA
>be08	03 e8 4c 44 58				.text	3,$e8,"LDX"            ; $a2 LDX
>be0d	03 e9 4c 44 59				.text	3,$e9,"LDY"            ; $a3 LDY
>be12	03 f1 4c 53 52				.text	3,$f1,"LSR"            ; $a4 LSR
>be17	03 ed 4e 4f 50				.text	3,$ed,"NOP"            ; $a5 NOP
>be1c	03 e2 4f 52 41				.text	3,$e2,"ORA"            ; $a6 ORA
>be21	03 d9 50 48 41				.text	3,$d9,"PHA"            ; $a7 PHA
>be26	03 e8 50 48 50				.text	3,$e8,"PHP"            ; $a8 PHP
>be2b	03 f0 50 48 58				.text	3,$f0,"PHX"            ; $a9 PHX
>be30	03 f1 50 48 59				.text	3,$f1,"PHY"            ; $aa PHY
>be35	03 dd 50 4c 41				.text	3,$dd,"PLA"            ; $ab PLA
>be3a	03 ec 50 4c 50				.text	3,$ec,"PLP"            ; $ac PLP
>be3f	03 f4 50 4c 58				.text	3,$f4,"PLX"            ; $ad PLX
>be44	03 f5 50 4c 59				.text	3,$f5,"PLY"            ; $ae PLY
>be49	03 ed 52 4f 4c				.text	3,$ed,"ROL"            ; $af ROL
>be4e	03 f3 52 4f 52				.text	3,$f3,"ROR"            ; $b0 ROR
>be53	03 ef 52 54 49				.text	3,$ef,"RTI"            ; $b1 RTI
>be58	03 f9 52 54 53				.text	3,$f9,"RTS"            ; $b2 RTS
>be5d	03 d8 53 42 43				.text	3,$d8,"SBC"            ; $b3 SBC
>be62	03 db 53 45 43				.text	3,$db,"SEC"            ; $b4 SEC
>be67	03 dc 53 45 44				.text	3,$dc,"SED"            ; $b5 SED
>be6c	03 e1 53 45 49				.text	3,$e1,"SEI"            ; $b6 SEI
>be71	03 e8 53 54 41				.text	3,$e8,"STA"            ; $b7 STA
>be76	03 f7 53 54 50				.text	3,$f7,"STP"            ; $b8 STP
>be7b	03 ff 53 54 58				.text	3,$ff,"STX"            ; $b9 STX
>be80	03 00 53 54 59				.text	3,$00,"STY"            ; $ba STY
>be85	03 01 53 54 5a				.text	3,$01,"STZ"            ; $bb STZ
>be8a	03 ed 54 41 58				.text	3,$ed,"TAX"            ; $bc TAX
>be8f	03 ee 54 41 59				.text	3,$ee,"TAY"            ; $bd TAY
>be94	03 e8 54 52 42				.text	3,$e8,"TRB"            ; $be TRB
>be99	03 e9 54 53 42				.text	3,$e9,"TSB"            ; $bf TSB
>be9e	03 ff 54 53 58				.text	3,$ff,"TSX"            ; $c0 TSX
>bea3	03 ed 54 58 41				.text	3,$ed,"TXA"            ; $c1 TXA
>bea8	03 ff 54 58 53				.text	3,$ff,"TXS"            ; $c2 TXS
>bead	03 ee 54 59 41				.text	3,$ee,"TYA"            ; $c3 TYA
>beb2	ff					.text	$FF
.b491					ListConvertLine:
.b491	48		pha				pha 								; save indent on the stack
.b492	9c 9d 04	stz $049d			stz 	tbOffset
.b495	9c ad 04	stz $04ad			stz 	tokenBuffer
.b498	9c a9 04	stz $04a9			stz 	currentListColour
.b49b	a0 02		ldy #$02			ldy 	#2 							; convert line number to string
.b49d	b1 30		lda ($30),y			lda 	(codePtr),y
.b49f	aa		tax				tax
.b4a0	88		dey				dey
.b4a1	b1 30		lda ($30),y			lda 	(codePtr),y
.b4a3	20 21 93	jsr $9321			jsr 	LCLConvertInt16
.b4a6	85 36		sta $36				sta 	zTemp0 						; copy number into buffer
.b4a8	86 37		stx $37				stx 	zTemp0+1
.b4aa	a9 8c		lda #$8c			lda 	#CLINumber+$80
.b4ac	20 f1 b5	jsr $b5f1			jsr 	LCLWriteColour
.b4af	a0 00		ldy #$00			ldy 	#0
.b4b1					_LCCopyNumber:
.b4b1	b1 36		lda ($36),y			lda 	(zTemp0),y
.b4b3	20 fa b5	jsr $b5fa			jsr 	LCLWrite
.b4b6	c8		iny				iny
.b4b7	b1 36		lda ($36),y			lda 	(zTemp0),y
.b4b9	d0 f6		bne $b4b1			bne 	_LCCopyNumber
.b4bb	68		pla				pla 								; adjustment to indent
.b4bc	48		pha				pha 								; save on stack
.b4bd	10 0c		bpl $b4cb			bpl 	_LCNoAdjust 				; don't adjust indent if +ve, do after.
.b4bf	18		clc				clc 								; add to list indent and make 0 if goes -ve.
.b4c0	6d a6 04	adc $04a6			adc 	listIndent
.b4c3	8d a6 04	sta $04a6			sta 	listIndent
.b4c6	10 03		bpl $b4cb			bpl 	_LCNoAdjust
.b4c8	9c a6 04	stz $04a6			stz 	listIndent
.b4cb					_LCNoAdjust:
.b4cb	18		clc				clc		 							; work out actual indent.
.b4cc	ad a6 04	lda $04a6			lda 	listIndent
.b4cf	0a		asl a				asl 	a
.b4d0	69 06		adc #$06			adc 	#6
.b4d2	85 36		sta $36				sta 	zTemp0
.b4d4					_LCPadOut:
.b4d4	a9 20		lda #$20			lda 	#' '						; pad out to 6+indent characters
.b4d6	20 fa b5	jsr $b5fa			jsr 	LCLWrite
.b4d9	ad 9d 04	lda $049d			lda 	tbOffset
.b4dc	c5 36		cmp $36				cmp 	zTemp0
.b4de	d0 f4		bne $b4d4			bne 	_LCPadOut
.b4e0	a0 03		ldy #$03			ldy 	#3 							; start position.
.b4e2					_LCMainLoop:
.b4e2	a9 8a		lda #$8a			lda 	#CLIPunctuation+$80
.b4e4	20 f1 b5	jsr $b5f1			jsr 	LCLWriteColour
.b4e7	b1 30		lda ($30),y			lda 	(codePtr),y
.b4e9	c9 80		cmp #$80			cmp 	#KWC_EOL 					; end of line ?
.b4eb	f0 17		beq $b504			beq 	_LCExit
.b4ed	c9 10		cmp #$10			cmp 	#16 						; 0-5 are the double punctuations
.b4ef	90 1e		bcc $b50f			bcc 	_LCDoubles
.b4f1	c9 20		cmp #$20			cmp 	#32 						; 16-31 are shifted punctuation from 64-91
.b4f3	90 2a		bcc $b51f			bcc 	_LCShiftPunc
.b4f5	c9 40		cmp #$40			cmp 	#64 						; 32-64 are as stored, punc and digits
.b4f7	90 35		bcc $b52e			bcc 	_LCPunctuation
.b4f9	c9 80		cmp #$80			cmp 	#128 						; 64-127 are variable identifiers.
.b4fb	90 3e		bcc $b53b			bcc 	_LCIdentifiers
.b4fd	c9 fe		cmp #$fe			cmp 	#254 						; 128-253 are tokenised words
.b4ff	90 5f		bcc $b560			bcc 	_LCTokens
.b501	4c c0 b5	jmp $b5c0			jmp 	_LCData 					; 254-5 are data objects
.b504					_LCExit:
.b504	68		pla				pla 								; get old indent adjust
.b505	30 07		bmi $b50e			bmi 	_LCExit2
.b507	18		clc				clc 								; add to indent if +ve
.b508	6d a6 04	adc $04a6			adc 	listIndent
.b50b	8d a6 04	sta $04a6			sta 	listIndent
.b50e					_LCExit2:
.b50e	60		rts				rts
.b50f					_LCDoubles:
.b50f	48		pha				pha
.b510	4a		lsr a				lsr 	a 							; put bit 2 into bit 1
.b511	29 02		and #$02			and 	#2
.b513	09 3c		ora #$3c			ora 	#60 						; make < >
.b515	20 fa b5	jsr $b5fa			jsr 	LCLWrite
.b518	68		pla				pla 								; restore, do lower bit
.b519	29 03		and #$03			and 	#3
.b51b	09 3c		ora #$3c			ora 	#60
.b51d	80 0f		bra $b52e			bra		_LCPunctuation 				; print, increment, loop
.b51f					_LCShiftPunc:
.b51f	aa		tax				tax 								; save in X
.b520	29 07		and #$07			and 	#7 							; lower 3 bits
.b522	f0 02		beq $b526			beq 	_LCNoAdd
.b524	09 18		ora #$18			ora 	#24 						; adds $18 to it.
.b526					_LCNoAdd:
.b526	e0 18		cpx #$18			cpx 	#24 						; if >= 24 add $20
.b528	90 02		bcc $b52c			bcc 	_LCNoAdd2
.b52a	09 20		ora #$20			ora 	#32 						; adds $20
.b52c					_LCNoAdd2:
.b52c	09 40		ora #$40			ora 	#$40 						; shift into 64-127 range and fall through.
.b52e					_LCPunctuation:
.b52e	c9 3a		cmp #$3a			cmp 	#':' 						; check if :
.b530	d0 03		bne $b535			bne 	_LCPContinue
.b532	20 10 b6	jsr $b610			jsr 	LCLDeleteLastSpace 			; if so delete any preceding spaces
.b535					_LCPContinue:
.b535	c8		iny				iny 								; consume character
.b536	20 fa b5	jsr $b5fa			jsr 	LCLWrite 					; write it out.
.b539	80 a7		bra $b4e2			bra 	_LCMainLoop 				; go round again.
.b53b					_LCIdentifiers:
.b53b	18		clc				clc 								; convert to physical address
.b53c	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.b53e	85 37		sta $37				sta 	zTemp0+1
.b540	c8		iny				iny
.b541	b1 30		lda ($30),y			lda 	(codePtr),y
.b543	85 36		sta $36				sta 	zTemp0
.b545	c8		iny				iny
.b546	5a		phy				phy 								; save position
.b547	a9 87		lda #$87			lda 	#CLIIdentifier+$80
.b549	20 f1 b5	jsr $b5f1			jsr 	LCLWriteColour
.b54c	a0 07		ldy #$07			ldy 	#7 							; output the identifier at +8
.b54e					_LCOutIdentifier:
.b54e	c8		iny				iny
.b54f	b1 36		lda ($36),y			lda 	(zTemp0),y					; bit 7 set = end.
.b551	29 7f		and #$7f			and 	#$7F
.b553	20 4c b6	jsr $b64c			jsr 	LCLLowerCase
.b556	20 fa b5	jsr $b5fa			jsr 	LCLWrite
.b559	b1 36		lda ($36),y			lda 	(zTemp0),y				 	; ends when bit 7 set.
.b55b	10 f1		bpl $b54e			bpl 	_LCOutIdentifier
.b55d	7a		ply				ply 								; restore position
.b55e	80 82		bra $b4e2			bra 	_LCMainLoop
.b560					_LCTokens:
.b560	aa		tax				tax 								; token in X
.b561	a9 67		lda #$67			lda 	#((KeywordSet2) & $FF)
.b563	85 36		sta $36				sta 	0+zTemp0
.b565	a9 bd		lda #$bd			lda 	#((KeywordSet2) >> 8)
.b567	85 37		sta $37				sta 	1+zTemp0
.b569	e0 82		cpx #$82			cpx 	#$82
.b56b	f0 16		beq $b583			beq 	_LCUseShift
.b56d	a9 0f		lda #$0f			lda 	#((KeywordSet1) & $FF)
.b56f	85 36		sta $36				sta 	0+zTemp0
.b571	a9 bd		lda #$bd			lda 	#((KeywordSet1) >> 8)
.b573	85 37		sta $37				sta 	1+zTemp0
.b575	e0 81		cpx #$81			cpx 	#$81
.b577	f0 0a		beq $b583			beq 	_LCUseShift
.b579	a9 12		lda #$12			lda 	#((KeywordSet0) & $FF)
.b57b	85 36		sta $36				sta 	0+zTemp0
.b57d	a9 bb		lda #$bb			lda 	#((KeywordSet0) >> 8)
.b57f	85 37		sta $37				sta 	1+zTemp0
.b581	80 01		bra $b584			bra 	_LCNoShift
.b583					_LCUseShift:
.b583	c8		iny				iny
.b584					_LCNoShift:
.b584	20 24 b6	jsr $b624			jsr 	LCLCheckSpaceRequired 		; do we need a space ?
.b587	b1 30		lda ($30),y			lda 	(codePtr),y
.b589	aa		tax				tax 								; into X
.b58a					_LCFindText:
.b58a	ca		dex				dex
.b58b	10 0e		bpl $b59b			bpl 	_LCFoundText 				; found text.
.b58d	b2 36		lda ($36)			lda 	(zTemp0) 					; length of text
.b58f	1a		inc a				inc 	a 							; one extra for size
.b590	38		sec				sec 								; one extra for checksum
.b591	65 36		adc $36				adc 	zTemp0 						; go to next token
.b593	85 36		sta $36				sta 	zTemp0
.b595	90 f3		bcc $b58a			bcc 	_LCFindText
.b597	e6 37		inc $37				inc 	zTemp0+1
.b599	80 ef		bra $b58a			bra 	_LCFindText
.b59b					_LCFoundText:
.b59b	5a		phy				phy 								; save List position
.b59c	b2 36		lda ($36)			lda 	(zTemp0)					; count to print
.b59e	aa		tax				tax
.b59f	a9 83		lda #$83			lda 	#CLIToken+$80
.b5a1	20 f1 b5	jsr $b5f1			jsr 	LCLWriteColour
.b5a4	a0 02		ldy #$02			ldy 	#2
.b5a6					_LCCopyToken:
.b5a6	b1 36		lda ($36),y			lda 	(zTemp0),y
.b5a8	20 4c b6	jsr $b64c			jsr 	LCLLowerCase
.b5ab	20 fa b5	jsr $b5fa			jsr 	LCLWrite
.b5ae	c8		iny				iny
.b5af	ca		dex				dex
.b5b0	d0 f4		bne $b5a6			bne 	_LCCopyToken
.b5b2	c9 28		cmp #$28			cmp 	#"(" 						; if last char not ( print a space
.b5b4	f0 05		beq $b5bb			beq 	_LCNoSpace
.b5b6	a9 20		lda #$20			lda 	#' '
.b5b8	20 fa b5	jsr $b5fa			jsr 	LCLWrite
.b5bb					_LCNoSpace:
.b5bb	7a		ply				ply 								; restore position.
.b5bc	c8		iny				iny 								; consume token
.b5bd	4c e2 b4	jmp $b4e2			jmp 	_LCMainLoop 				; and go around again.
.b5c0					_LCData:
.b5c0	48		pha				pha 								; save type $FE/$FF
.b5c1	a2 24		ldx #$24			ldx 	#'$' 						; figure out $ or "
.b5c3	c9 fe		cmp #$fe			cmp 	#$FE
.b5c5	f0 07		beq $b5ce			beq 	_LCHaveOpener
.b5c7	a2 22		ldx #$22			ldx 	#'"'
.b5c9	a9 81		lda #$81			lda 	#CLIData+$80
.b5cb	20 f1 b5	jsr $b5f1			jsr 	LCLWriteColour
.b5ce					_LCHaveOpener:
.b5ce	8a		txa				txa 								; output prefix (# or ")
.b5cf	20 fa b5	jsr $b5fa			jsr 	LCLWrite
.b5d2	c8		iny				iny 								; get count
.b5d3	b1 30		lda ($30),y			lda 	(codePtr),y
.b5d5	aa		tax				tax
.b5d6	c8		iny				iny 								; point at first character
.b5d7					_LCOutData:
.b5d7	b1 30		lda ($30),y			lda 	(codePtr),y
.b5d9	c9 00		cmp #$00			cmp 	#0
.b5db	f0 03		beq $b5e0			beq 	_LCNoPrint
.b5dd	20 fa b5	jsr $b5fa			jsr 	LCLWrite
.b5e0					_LCNoPrint:
.b5e0	c8		iny				iny
.b5e1	ca		dex				dex
.b5e2	d0 f3		bne $b5d7			bne 	_LCOutData
.b5e4	68		pla				pla 								; closing " required ?
.b5e5	c9 ff		cmp #$ff			cmp 	#$FF 						; not required for hex constant.
.b5e7	d0 05		bne $b5ee			bne 	_LCNoQuote
.b5e9	a9 22		lda #$22			lda 	#'"'
.b5eb	20 fa b5	jsr $b5fa			jsr 	LCLWrite
.b5ee					_LCNoQuote:
.b5ee	4c e2 b4	jmp $b4e2			jmp 	_LCMainLoop
.b5f1					LCLWriteColour:
.b5f1	cd a9 04	cmp $04a9			cmp 	currentListColour 			; has the colour changed
.b5f4	8d a9 04	sta $04a9			sta 	currentListColour 			; (update it anyway)
.b5f7	d0 01		bne $b5fa			bne 	LCLWrite 					; if different, output it
.b5f9	60		rts				rts
.b5fa					LCLWrite:
.b5fa	da		phx				phx
.b5fb	ae 9d 04	ldx $049d			ldx 	tbOffset 					; write out make ASCIIZ
.b5fe	9d ad 04	sta $04ad,x			sta 	tokenBuffer,x
.b601	9e ae 04	stz $04ae,x			stz 	tokenBuffer+1,x
.b604	ee 9d 04	inc $049d			inc 	tbOffset 					; bump the position
.b607	09 00		ora #$00			ora 	#0 							; don't update last character if colour data
.b609	30 03		bmi $b60e			bmi 	_LCLNoColour
.b60b	8d a7 04	sta $04a7			sta 	LCLastCharacter
.b60e					_LCLNoColour:
.b60e	fa		plx				plx
.b60f	60		rts				rts
.b610					LCLDeleteLastSpace:
.b610	48		pha				pha
.b611	da		phx				phx
.b612	ae 9d 04	ldx $049d			ldx 	tbOffset
.b615	f0 0a		beq $b621			beq 	_LCDLSExit
.b617	bd ac 04	lda $04ac,x			lda 	tokenBuffer-1,x
.b61a	c9 20		cmp #$20			cmp 	#' '
.b61c	d0 03		bne $b621			bne 	_LCDLSExit
.b61e	ce 9d 04	dec $049d			dec 	tbOffset
.b621					_LCDLSExit:
.b621	fa		plx				plx
.b622	68		pla				pla
.b623	60		rts				rts
.b624					LCLCheckSpaceRequired:
.b624	ad a7 04	lda $04a7			lda 	LCLastCharacter 			; check last character
.b627	c9 24		cmp #$24			cmp 	#'$' 						; $ # and ) require that token space.
.b629	f0 1b		beq $b646			beq 	_LCCSRSpace
.b62b	c9 29		cmp #$29			cmp 	#')'
.b62d	f0 17		beq $b646			beq 	_LCCSRSpace
.b62f	c9 23		cmp #$23			cmp 	#'#'
.b631	f0 13		beq $b646			beq 	_LCCSRSpace
.b633	20 4c b6	jsr $b64c			jsr 	LCLLowerCase 				; saves a little effort
.b636	c9 30		cmp #$30			cmp 	#"0" 						; check if it was 0-9 A-Z a-z if so need space.
.b638	90 11		bcc $b64b			bcc 	_LCCSRExit
.b63a	c9 3a		cmp #$3a			cmp 	#"9"+1
.b63c	90 08		bcc $b646			bcc 	_LCCSRSpace
.b63e	c9 61		cmp #$61			cmp 	#"a"
.b640	90 09		bcc $b64b			bcc 	_LCCSRExit
.b642	c9 7b		cmp #$7b			cmp 	#"z"+1
.b644	b0 05		bcs $b64b			bcs 	_LCCSRExit
.b646					_LCCSRSpace:
.b646	a9 20		lda #$20			lda 	#' '
.b648	20 fa b5	jsr $b5fa			jsr 	LCLWrite
.b64b					_LCCSRExit:
.b64b	60		rts				rts
.b64c					LCLLowerCase:
.b64c	c9 41		cmp #$41			cmp 	#"A"
.b64e	90 06		bcc $b656			bcc 	_LCLLCOut
.b650	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b652	b0 02		bcs $b656			bcs 	_LCLLCOut
.b654	69 20		adc #$20			adc 	#$20
.b656					_LCLLCOut:
.b656	60		rts				rts
.b657					LCLUpperCase:
.b657	c9 61		cmp #$61			cmp 	#"a"
.b659	90 06		bcc $b661			bcc 	_LCLUCOut
.b65b	c9 7b		cmp #$7b			cmp 	#"z"+1
.b65d	b0 02		bcs $b661			bcs 	_LCLUCOut
.b65f	e9 1f		sbc #$1f			sbc 	#$1F
.b661					_LCLUCOut:
.b661	60		rts				rts
.b662					TOKSearchTable:
.b662	84 37		sty $37				sty 	zTemp0+1 					; (zTemp0),y points to current token being tested.
.b664	85 36		sta $36				sta 	zTemp0
.b666	a0 00		ldy #$00			ldy 	#0
.b668	a9 80		lda #$80			lda 	#$80 						; token # so we know which one we are looking at
.b66a	85 38		sta $38				sta 	zTemp1
.b66c					_TSTLoop:
.b66c	b1 36		lda ($36),y			lda 	(zTemp0),y 					; length, 0 (skip) -ve (end)
.b66e	30 49		bmi $b6b9			bmi 	_TSTFail 					; -ve = end of table, so fail.
.b670	f0 2e		beq $b6a0			beq 	_TSTNext 					; zero, check next as it's a dummy (e.g. EOL, SHIFT)
.b672	c8		iny				iny 								; get the hash
.b673	b1 36		lda ($36),y			lda 	(zTemp0),y
.b675	88		dey				dey
.b676	cd 83 04	cmp $0483			cmp 	identHash 					; check they match with the identifier hash, if not go to next
.b679	d0 25		bne $b6a0			bne 	_TSTNext
.b67b	ad 82 04	lda $0482			lda 	identTypeEnd 				; get length of identifier from end-start
.b67e	38		sec				sec
.b67f	ed 80 04	sbc $0480			sbc 	identStart
.b682	d1 36		cmp ($36),y			cmp 	(zTemp0),y 					; compare against the length in the table, no match, then return.
.b684	d0 1a		bne $b6a0			bne 	_TSTNext
.b686	5a		phy				phy 								; save Y , we might fail to match.
.b687	c8		iny				iny 								; point to text
.b688	c8		iny				iny
.b689	ae 80 04	ldx $0480			ldx 	identStart 					; offset in line buffer in X
.b68c					_TSTCompareName:
.b68c	bd aa 05	lda $05aa,x			lda 	lineBuffer,x 				; compare text.
.b68f	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.b691	d0 0c		bne $b69f			bne 	_TSTNextPullY 				; fail, pullY and do next
.b693	e8		inx				inx
.b694	c8		iny				iny
.b695	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; complete match.
.b698	d0 f2		bne $b68c			bne 	_TSTCompareName
.b69a	7a		ply				ply 								; throw Y
.b69b	a5 38		lda $38				lda 	zTemp1 						; get token #
.b69d	38		sec				sec 								; return with CS = passed.
.b69e	60		rts				rts
.b69f					_TSTNextPullY:
.b69f	7a		ply				ply 								; restore current, fall through.
.b6a0					_TSTNext:
.b6a0	e6 38		inc $38				inc 	zTemp1 						; token counter
.b6a2	98		tya				tya
.b6a3	18		clc				clc
.b6a4	71 36		adc ($36),y			adc 	(zTemp0),y 					; add [Length] + 2 to Y
.b6a6	1a		inc a				inc 	a 							; +1
.b6a7	1a		inc a				inc 	a 							; +2
.b6a8	a8		tay				tay
.b6a9	10 c1		bpl $b66c			bpl 	_TSTLoop 					; if Y < $80 loop back
.b6ab	98		tya				tya 								; add Y to zTemp0 and reset Y
.b6ac	a0 00		ldy #$00			ldy 	#0   						; so we can use Y to search fast
.b6ae	18		clc				clc  								; but have tables > 255 bytes
.b6af	65 36		adc $36				adc 	zTemp0 						; when Y gets >= 128 we reset Y
.b6b1	85 36		sta $36				sta 	zTemp0 						; and adjust the table pointer/
.b6b3	90 b7		bcc $b66c			bcc 	_TSTLoop
.b6b5	e6 37		inc $37				inc 	zTemp0+1
.b6b7	80 b3		bra $b66c			bra 	_TSTLoop
.b6b9					_TSTFail:
.b6b9	18		clc				clc
.b6ba	60		rts				rts
.b6bb					TokeniseLine:
.b6bb	20 43 b8	jsr $b843			jsr 	LCLFixLineBufferCase 		; fix line case
.b6be	a9 03		lda #$03			lda 	#3 							; reset the token buffer to empty
.b6c0	8d aa 04	sta $04aa			sta 	tokenOffset 				; (3 bytes for line number & offset)
.b6c3	9c ab 04	stz $04ab			stz 	tokenLineNumber
.b6c6	9c ac 04	stz $04ac			stz 	tokenLineNumber+1
.b6c9	a2 ff		ldx #$ff			ldx 	#$FF
.b6cb					_TKFindFirst:
.b6cb	e8		inx				inx
.b6cc	bd aa 05	lda $05aa,x			lda 	lineBuffer,x
.b6cf	f0 79		beq $b74a			beq 	_TKExit
.b6d1	c9 20		cmp #$20			cmp 	#' '
.b6d3	90 f6		bcc $b6cb			bcc 	_TKFindFirst
.b6d5	c9 30		cmp #$30			cmp 	#'0'
.b6d7	90 07		bcc $b6e0			bcc 	_TKNoLineNumber
.b6d9	c9 3a		cmp #$3a			cmp 	#'9'+1
.b6db	b0 03		bcs $b6e0			bcs 	_TKNoLineNumber
.b6dd	20 6d b8	jsr $b86d			jsr 	TOKExtractLineNumber
.b6e0					_TKNoLineNumber:
.b6e0					_TKTokeniseLoop:
.b6e0	bd aa 05	lda $05aa,x			lda 	lineBuffer,x 				; next character, exit if zero EOL.
.b6e3	f0 65		beq $b74a			beq 	_TKExit
.b6e5	e8		inx				inx
.b6e6	c9 20		cmp #$20			cmp 	#' '
.b6e8	f0 f6		beq $b6e0			beq 	_TKTokeniseLoop 			; keep looping if space found.
.b6ea	ca		dex				dex 								; undo last get, A contains character, X is position.
.b6eb	c9 5f		cmp #$5f			cmp 	#'_'						; _ A-Z is identifier *or* token
.b6ed	f0 61		beq $b750			beq 	_TKTokeniseIdentifier 		; (already case converted outside string constants)
.b6ef	c9 41		cmp #$41			cmp 	#'A'
.b6f1	90 04		bcc $b6f7			bcc 	_TKTokenisePunctuation
.b6f3	c9 5b		cmp #$5b			cmp 	#'Z'+1
.b6f5	90 59		bcc $b750			bcc 	_TKTokeniseIdentifier
.b6f7					_TKTokenisePunctuation:
.b6f7	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.b6f9	f0 27		beq $b722			beq 	_TKString
.b6fb	c9 24		cmp #$24			cmp 	#'$'						; hexadecimal constant ($ only appears at end of identifiers)
.b6fd	f0 28		beq $b727			beq 	_TKHexConstant
.b6ff	c9 3c		cmp #$3c			cmp 	#'<' 						; check for < > handlers - these are for <> <= >= >> <<
.b701	f0 29		beq $b72c			beq 	_TKCheckDouble
.b703	c9 3e		cmp #$3e			cmp 	#'>'
.b705	f0 25		beq $b72c			beq 	_TKCheckDouble
.b707					_TKStandardPunctuation:
.b707	bd aa 05	lda $05aa,x			lda 	lineBuffer,x 				; get the punctuation token back.
.b70a	c9 40		cmp #$40			cmp 	#64 						; are we >= 64
.b70c	90 0e		bcc $b71c			bcc 	_TKNoShift
.b70e	48		pha				pha 								; save. we are about to convert this punctuation token from
.b70f	29 07		and #$07			and 	#7 							; lower 3 bits in zTemp0
.b711	85 36		sta $36				sta 	zTemp0
.b713	68		pla				pla
.b714	29 20		and #$20			and 	#32 						; bit 5
.b716	4a		lsr a				lsr 	a 							; shift into bit 3
.b717	4a		lsr a				lsr 	a
.b718	05 36		ora $36				ora 	zTemp0
.b71a	09 10		ora #$10			ora 	#$10						; now in the range 16-31
.b71c					_TKNoShift:
.b71c	20 b2 b8	jsr $b8b2			jsr 	TOKWriteByte 				; write the punctuation character
.b71f	e8		inx				inx 								; consume the character
.b720	80 be		bra $b6e0			bra 	_TKTokeniseLoop 			; and loop round again.
.b722					_TKString:
.b722	20 d2 b7	jsr $b7d2			jsr 	TOKTokenString
.b725	80 b9		bra $b6e0			bra 	_TKTokeniseLoop
.b727					_TKHexConstant:
.b727	20 0d b8	jsr $b80d			jsr 	TOKHexConstant
.b72a	80 b4		bra $b6e0			bra 	_TKTokeniseLoop
.b72c					_TKCheckDouble:
.b72c	bd ab 05	lda $05ab,x			lda 	lineBuffer+1,x 				; get next character
.b72f	c9 3c		cmp #$3c			cmp 	#'<'						; if not < = > which are ASCII consecutive go back
.b731	90 d4		bcc $b707			bcc 	_TKStandardPunctuation 		; and do the normal punctuation handler.
.b733	c9 3f		cmp #$3f			cmp 	#'>'+1
.b735	b0 d0		bcs $b707			bcs 	_TKStandardPunctuation
.b737	bd aa 05	lda $05aa,x			lda 	lineBuffer,x 				; this is < (60) or > (62)
.b73a	29 02		and #$02			and 	#2 							; now < (0) or > (2)
.b73c	0a		asl a				asl 	a 							; now < (0) or > (4), CC also
.b73d	7d ab 05	adc $05ab,x			adc 	lineBuffer+1,x 				; add < = > codes - < code
.b740	38		sec				sec
.b741	e9 3c		sbc #$3c			sbc 	#'<'
.b743	20 b2 b8	jsr $b8b2			jsr 	TOKWriteByte 				; this is in the range 0-7
.b746	e8		inx				inx 								; consume both
.b747	e8		inx				inx
.b748	80 96		bra $b6e0			bra 	_TKTokeniseLoop
.b74a	a9 80		lda #$80	_TKExit:lda 	#KWC_EOL 					; write end of line byte
.b74c	20 b2 b8	jsr $b8b2			jsr 	TOKWriteByte
.b74f	60		rts				rts
.b750					_TKTokeniseIdentifier:
.b750	8e 80 04	stx $0480			stx 	identStart 					; save start
.b753	9c 84 04	stz $0484			stz 	identTypeByte 				; zero the type byte
.b756					_TKCheckLoop:
.b756	e8		inx				inx 								; look at next, we know first is identifier already.
.b757	bd aa 05	lda $05aa,x			lda  	lineBuffer,x
.b75a	c9 5f		cmp #$5f			cmp 	#"_" 						; legal char _ 0-9 A-Z
.b75c	f0 f8		beq $b756			beq 	_TKCheckLoop
.b75e	c9 30		cmp #$30			cmp	 	#"0"
.b760	90 0c		bcc $b76e			bcc 	_TKEndIdentifier
.b762	c9 3a		cmp #$3a			cmp 	#"9"+1
.b764	90 f0		bcc $b756			bcc 	_TKCheckLoop
.b766	c9 41		cmp #$41			cmp	 	#"A"
.b768	90 04		bcc $b76e			bcc 	_TKEndIdentifier
.b76a	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b76c	90 e8		bcc $b756			bcc 	_TKCheckLoop
.b76e					_TKEndIdentifier:
.b76e	8e 81 04	stx $0481			stx 	identTypeStart 				; save start of type text (if any !)
.b771	a0 08		ldy #$08			ldy 	#$08 						; this is the identifier type byte for #
.b773	c9 23		cmp #$23			cmp 	#"#"						; followed by #
.b775	f0 06		beq $b77d			beq 	_TKHasTypeCharacter
.b777	a0 10		ldy #$10			ldy 	#$10 						; this is the identifier type byte for $
.b779	c9 24		cmp #$24			cmp 	#"$"						; followed by $ or #
.b77b	d0 07		bne $b784			bne 	_TKNoTypeCharacter
.b77d					_TKHasTypeCharacter:
.b77d	8c 84 04	sty $0484			sty 	identTypeByte 				; has # or $, save the type
.b780	e8		inx				inx 								; consume the type character
.b781	bd aa 05	lda $05aa,x			lda 	lineBuffer,x
.b784					_TKNoTypeCharacter:
.b784	c9 28		cmp #$28			cmp 	#"("						; is it open parenthesis (e.g. array)
.b786	d0 09		bne $b791			bne 	_TKNoArray
.b788	e8		inx				inx 								; skip the (
.b789	ad 84 04	lda $0484			lda 	identTypeByte 				; set bit 2 (e.g. array) in type byte
.b78c	09 04		ora #$04			ora 	#$04
.b78e	8d 84 04	sta $0484			sta 	identTypeByte
.b791					_TKNoArray:
.b791	8e 82 04	stx $0482			stx 	identTypeEnd 				; save end marker, e.g. continue from here.
.b794	20 2e b8	jsr $b82e			jsr 	TOKCalculateHash 			; calculate the has for those tokens
.b797	a0 bb		ldy #$bb			ldy 	#(KeywordSet0) >> 8
.b799	a9 12		lda #$12			lda 	#(KeywordSet0) & $FF
.b79b	20 62 b6	jsr $b662			jsr 	TOKSearchTable
.b79e	a2 00		ldx #$00			ldx 	#0
.b7a0	b0 1f		bcs $b7c1			bcs 	_TKFoundToken
.b7a2	a0 bd		ldy #$bd			ldy 	#(KeywordSet1) >> 8
.b7a4	a9 0f		lda #$0f			lda 	#(KeywordSet1) & $FF
.b7a6	20 62 b6	jsr $b662			jsr 	TOKSearchTable
.b7a9	a2 81		ldx #$81			ldx 	#$81
.b7ab	b0 14		bcs $b7c1			bcs 	_TKFoundToken
.b7ad	a0 bd		ldy #$bd			ldy 	#(KeywordSet2) >> 8
.b7af	a9 67		lda #$67			lda 	#(KeywordSet2) & $FF
.b7b1	20 62 b6	jsr $b662			jsr 	TOKSearchTable
.b7b4	a2 82		ldx #$82			ldx 	#$82
.b7b6	b0 09		bcs $b7c1			bcs 	_TKFoundToken
.b7b8	20 be b8	jsr $b8be			jsr 	TOKCheckCreateVariableRecord ; failed all, it's a variable, create record if does not exist.
.b7bb	ae 82 04	ldx $0482			ldx 	identTypeEnd 				; X points to following byte
.b7be	4c e0 b6	jmp $b6e0			jmp 	_TKTokeniseLoop 			; and go round again.
.b7c1					_TKFoundToken:
.b7c1	48		pha				pha 								; save token
.b7c2	8a		txa				txa 								; shift in X, is there one ?
.b7c3	f0 03		beq $b7c8			beq 	_TKNoTShift
.b7c5	20 b2 b8	jsr $b8b2			jsr 	TOKWriteByte 				; if so, write it out
.b7c8					_TKNoTShift:
.b7c8	68		pla				pla 								; restore and write token
.b7c9	20 b2 b8	jsr $b8b2			jsr 	TOKWriteByte
.b7cc	ae 82 04	ldx $0482			ldx 	identTypeEnd 				; X points to following byte
.b7cf	4c e0 b6	jmp $b6e0			jmp 	_TKTokeniseLoop 			; and go round again.
.b7d2					TOKTokenString:
.b7d2	a9 ff		lda #$ff			lda 	#KWC_STRING 				; string token.
.b7d4	20 b2 b8	jsr $b8b2			jsr 	TOKWriteByte
.b7d7	e8		inx				inx									; start of quoted string.
.b7d8	da		phx				phx 								; push start of string on top
.b7d9	ca		dex				dex 								; because we pre-increment
.b7da					_TSFindEnd:
.b7da	e8		inx				inx
.b7db	bd aa 05	lda $05aa,x			lda 	lineBuffer,x 				; next character
.b7de	f0 04		beq $b7e4			beq 	_TSEndOfString 				; no matching quote, we don't mind.
.b7e0	c9 22		cmp #$22			cmp 	#'"' 						; go back if quote not found
.b7e2	d0 f6		bne $b7da			bne 	_TSFindEnd
.b7e4					_TSEndOfString:
.b7e4	7a		ply				ply  								; so now Y is first character, X is character after end.
.b7e5	48		pha				pha 								; save terminating character
.b7e6	20 ee b7	jsr $b7ee			jsr 	TOKWriteBlockXY 			; write X to Y as a data block
.b7e9	68		pla				pla 								; terminating character
.b7ea	f0 01		beq $b7ed			beq 	_TSNotQuote					; if it wasn't EOS skip it
.b7ec	e8		inx				inx
.b7ed					_TSNotQuote:
.b7ed	60		rts				rts
.b7ee					TOKWriteBlockXY:
.b7ee	86 36		stx $36				stx 	zTemp0 						; save end character
.b7f0	98		tya				tya 								; use 2's complement to work out the byte size
.b7f1	49 ff		eor #$ff			eor 	#$FF
.b7f3	38		sec				sec
.b7f4	65 36		adc $36				adc 	zTemp0
.b7f6	1a		inc a				inc 	a 							; one extra for NULL
.b7f7	20 b2 b8	jsr $b8b2			jsr 	TOKWriteByte
.b7fa					_TOBlockLoop:
.b7fa	c4 36		cpy $36				cpy 	zTemp0 						; exit if reached the end
.b7fc	f0 09		beq $b807			beq 	_TOBlockExit
.b7fe	b9 aa 05	lda $05aa,y			lda 	lineBuffer,y 				; write byte out.
.b801	20 b2 b8	jsr $b8b2			jsr 	TOKWriteByte
.b804	c8		iny				iny
.b805	80 f3		bra $b7fa			bra 	_TOBlockLoop
.b807					_TOBlockExit:
.b807	a9 00		lda #$00			lda 	#0 							; add NULL.
.b809	20 b2 b8	jsr $b8b2			jsr 	TOKWriteByte
.b80c	60		rts				rts
.b80d					TOKHexConstant:
.b80d	a9 fe		lda #$fe			lda 	#KWC_HEXCONST 				; hex constant token.
.b80f	20 b2 b8	jsr $b8b2			jsr 	TOKWriteByte
.b812	e8		inx				inx									; start of quoted string.
.b813	da		phx				phx 								; push start of constant on top
.b814	ca		dex				dex
.b815					_THFindLoop:
.b815	e8		inx				inx 	 							; this is stored in a block, so find out how long
.b816	bd aa 05	lda $05aa,x			lda 	lineBuffer,x 				; the hex constant is.
.b819	c9 30		cmp #$30			cmp 	#"0"
.b81b	90 0c		bcc $b829			bcc 	_THFoundEnd
.b81d	c9 3a		cmp #$3a			cmp 	#"9"+1
.b81f	90 f4		bcc $b815			bcc 	_THFindLoop
.b821	c9 41		cmp #$41			cmp 	#"A"
.b823	90 04		bcc $b829			bcc 	_THFoundEnd
.b825	c9 47		cmp #$47			cmp 	#"F"+1
.b827	90 ec		bcc $b815			bcc 	_THFindLoop
.b829					_THFoundEnd:
.b829	7a		ply				ply 								; restore start
.b82a	20 ee b7	jsr $b7ee			jsr 	TOKWriteBlockXY 			; output the block
.b82d	60		rts				rts
.b82e					TOKCalculateHash:
.b82e	da		phx				phx
.b82f	ae 80 04	ldx $0480			ldx 	identStart 					; needs to be same as in tokens.py - simple sum at present.
.b832	a9 00		lda #$00			lda 	#0
.b834					_TCHLoop:
.b834	18		clc				clc
.b835	7d aa 05	adc $05aa,x			adc 	lineBuffer,x
.b838	e8		inx				inx
.b839	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; do the whole thing including type and array markers.
.b83c	d0 f6		bne $b834			bne 	_TCHLoop
.b83e	8d 83 04	sta $0483			sta 	identHash 					; save the hash
.b841	fa		plx				plx
.b842	60		rts				rts
.b843					LCLFixLineBufferCase:
.b843	a2 00		ldx #$00			ldx 	#0
.b845					_FLBCLoop:
.b845	bd aa 05	lda $05aa,x			lda 	lineBuffer,x 				; get next character
.b848	f0 22		beq $b86c			beq 	_FLBCExit 					; end of string.
.b84a	c9 22		cmp #$22			cmp 	#'"'						; quote, go to in quotes
.b84c	f0 11		beq $b85f			beq 	_FLBCInQuotes
.b84e	e8		inx				inx
.b84f	c9 61		cmp #$61			cmp 	#'a'						; needs capitalising ?
.b851	90 f2		bcc $b845			bcc 	_FLBCLoop
.b853	c9 7b		cmp #$7b			cmp 	#'z'+1
.b855	b0 ee		bcs $b845			bcs 	_FLBCLoop
.b857	38		sec				sec 								; make U/C
.b858	e9 20		sbc #$20			sbc 	#32
.b85a	9d a9 05	sta $05a9,x			sta	 	lineBuffer-1,x 				; write back
.b85d	80 e6		bra $b845			bra 	_FLBCLoop
.b85f					_FLBCInQuotes:
.b85f	e8		inx				inx 								; advance
.b860	bd aa 05	lda $05aa,x			lda 	lineBuffer,x 				; get next
.b863	f0 07		beq $b86c			beq 	_FLBCExit 					; exit on EOS
.b865	c9 22		cmp #$22			cmp 	#'"' 				 		; until " found
.b867	d0 f6		bne $b85f			bne 	_FLBCInQuotes
.b869	e8		inx				inx 								; skip over it
.b86a	80 d9		bra $b845			bra 	_FLBCLoop
.b86c					_FLBCExit:
.b86c	60		rts				rts
.b86d					TOKExtractLineNumber:
.b86d	ad ac 04	lda $04ac			lda 	tokenLineNumber+1 			; push current value on stack
.b870	48		pha				pha
.b871	ad ab 04	lda $04ab			lda 	tokenLineNumber
.b874	48		pha				pha
.b875	20 ab b8	jsr $b8ab			jsr 	_LCLNTimes2 				; line # x 2
.b878	20 ab b8	jsr $b8ab			jsr 	_LCLNTimes2 				; line # x 4
.b87b	18		clc				clc 								; add stacked value
.b87c	68		pla				pla
.b87d	6d ab 04	adc $04ab			adc 	tokenLineNumber
.b880	8d ab 04	sta $04ab			sta 	tokenLineNumber
.b883	68		pla				pla
.b884	6d ac 04	adc $04ac			adc 	tokenLineNumber+1
.b887	8d ac 04	sta $04ac			sta 	tokenLineNumber+1 			; line # x 5
.b88a	20 ab b8	jsr $b8ab			jsr 	_LCLNTimes2 				; line # x 10
.b88d	bd aa 05	lda $05aa,x			lda 	lineBuffer,x 				; get and consume character
.b890	e8		inx				inx
.b891	29 0f		and #$0f			and 	#15 						; add to line #
.b893	18		clc				clc
.b894	6d ab 04	adc $04ab			adc 	tokenLineNumber
.b897	8d ab 04	sta $04ab			sta 	tokenLineNumber
.b89a	90 03		bcc $b89f			bcc 	_TLENNoCarry
.b89c	ee ac 04	inc $04ac			inc 	tokenLineNumber+1
.b89f					_TLENNoCarry:
.b89f	bd aa 05	lda $05aa,x			lda 	lineBuffer,x 				; more digits ?
.b8a2	c9 30		cmp #$30			cmp 	#'0'
.b8a4	90 04		bcc $b8aa			bcc 	_TLENExit
.b8a6	c9 3a		cmp #$3a			cmp 	#'9'+1
.b8a8	90 c3		bcc $b86d			bcc 	TOKExtractLineNumber
.b8aa					_TLENExit:
.b8aa	60		rts				rts
.b8ab					_LCLNTimes2:
.b8ab	0e ab 04	asl $04ab			asl 	tokenLineNumber 			; doubles tokenLineNumber.
.b8ae	2e ac 04	rol $04ac			rol 	tokenLineNumber+1
.b8b1	60		rts				rts
.b8b2					TOKWriteByte:
.b8b2	da		phx				phx
.b8b3	ae aa 04	ldx $04aa			ldx 	tokenOffset 				; next slot to write to
.b8b6	9d aa 04	sta $04aa,x			sta 	tokenOffset,x 				; write byte out
.b8b9	ee aa 04	inc $04aa			inc 	tokenOffset 				; advance slot.
.b8bc	fa		plx				plx
.b8bd	60		rts				rts
.b8be					TOKCheckCreateVariableRecord:
.b8be	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.b8c0	85 36		sta $36				sta 	0+zTemp0
.b8c2	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.b8c4	85 37		sta $37				sta 	1+zTemp0
.b8c6					_CCVSearch:
.b8c6	b2 36		lda ($36)			lda 	(zTemp0) 					; end of list
.b8c8	f0 2c		beq $b8f6			beq 	_CCVFail
.b8ca	a0 01		ldy #$01			ldy 	#1 							; read the hash
.b8cc	b1 36		lda ($36),y			lda 	(zTemp0),y 					; does it match ?
.b8ce	cd 83 04	cmp $0483			cmp 	identHash 	  				; if not, try the next.
.b8d1	d0 16		bne $b8e9			bne 	_CCVNext
.b8d3	a0 08		ldy #$08			ldy 	#8 							; name in variable record
.b8d5	ae 80 04	ldx $0480			ldx 	identStart
.b8d8					_CCVCompare:
.b8d8	bd aa 05	lda $05aa,x			lda 	lineBuffer,x 				; xor them. zero if the same, except
.b8db	51 36		eor ($36),y			eor 	(zTemp0),y 					; bit 7 is used for EOS.
.b8dd	e8		inx				inx 								; advance pointers
.b8de	c8		iny				iny
.b8df	0a		asl a				asl 	a 							; A = 0 if they match, CS if end.
.b8e0	d0 07		bne $b8e9			bne 	_CCVNext  					; didn't match go to next.
.b8e2	90 f4		bcc $b8d8			bcc 	_CCVCompare 				; not finished yet.
.b8e4	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; matched whole thing ?
.b8e7	f0 41		beq $b92a			beq 	_CCVFound 					; yes, we were successful
.b8e9					_CCVNext:
.b8e9	18		clc				clc 								; go to next record.
.b8ea	b2 36		lda ($36)			lda 	(zTemp0) 					; add offset to pointer
.b8ec	65 36		adc $36				adc 	zTemp0
.b8ee	85 36		sta $36				sta 	zTemp0
.b8f0	90 d4		bcc $b8c6			bcc 	_CCVSearch
.b8f2	e6 37		inc $37				inc 	zTemp0+1
.b8f4	80 d0		bra $b8c6			bra 	_CCVSearch
.b8f6					_CCVFail:
.b8f6	a0 01		ldy #$01			ldy 	#1 							; create the new record. Offset 1 is hash
.b8f8	ad 83 04	lda $0483			lda 	identHash
.b8fb	91 36		sta ($36),y			sta 	(zTemp0),y
.b8fd	c8		iny				iny 								; offset 2 is the type byte
.b8fe	ad 84 04	lda $0484			lda 	identTypeByte
.b901	91 36		sta ($36),y			sta 	(zTemp0),y
.b903	c8		iny				iny
.b904					_CCVData:
.b904	a9 00		lda #$00			lda 	#0 							; erase data 3-7 (the 5 value bytes)
.b906	91 36		sta ($36),y			sta 	(zTemp0),y
.b908	c8		iny				iny
.b909	c0 08		cpy #$08			cpy 	#8
.b90b	90 f7		bcc $b904			bcc 	_CCVData
.b90d	ae 80 04	ldx $0480			ldx 	identStart 					; copy name into 8 on.
.b910					_CCVCopyName:
.b910	bd aa 05	lda $05aa,x			lda 	lineBuffer,x
.b913	91 36		sta ($36),y			sta 	(zTemp0),y
.b915	e8		inx				inx
.b916	c8		iny				iny
.b917	ec 82 04	cpx $0482			cpx 	identTypeEnd
.b91a	d0 f4		bne $b910			bne 	_CCVCopyName
.b91c	98		tya				tya 								; patch offset
.b91d	92 36		sta ($36)			sta 	(zTemp0)
.b91f	a9 00		lda #$00			lda 	#0 							; offset for next is zero.
.b921	91 36		sta ($36),y			sta 	(zTemp0),y
.b923	88		dey				dey
.b924	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set bit 7 of last bit
.b926	09 80		ora #$80			ora 	#$80
.b928	91 36		sta ($36),y			sta 	(zTemp0),y
.b92a					_CCVFound:
.b92a	a5 37		lda $37				lda 	zTemp0+1 					; write out MSB
.b92c	38		sec				sec
.b92d	e9 10		sbc #$10			sbc 	#(VariableSpace >> 8) 		; offset from the start of the variable token
.b92f	09 40		ora #$40			ora 	#$40 						; make it a writeable token $4000-$7FFF
.b931	20 b2 b8	jsr $b8b2			jsr 	TOKWriteByte
.b934	a5 36		lda $36				lda 	zTemp0 						; write out LSB
.b936	20 b2 b8	jsr $b8b2			jsr 	TOKWriteByte
.b939	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_sound.module

=1					soundIntegrated=1
.b93a					SNDCheckChannel:
.b93a	aa		tax				tax
.b93b	bd 0b 08	lda $080b,x			lda 	SNDTimeLeft,x 				; currently playing a note
.b93e	d0 38		bne $b978			bne 	_SNDCCExit
.b940	da		phx				phx 								; save current channel
.b941	8a		txa				txa 								; put in A
.b942	20 be b9	jsr $b9be			jsr 	SNDFindNextNoteForA 		; is there a note for A in the queue ?
.b945	68		pla				pla 								; channel # in A
.b946	90 30		bcc $b978			bcc 	_SNDCCExit  				; nothing in the queue for this channel, exit.
.b948	a8		tay				tay 								; Y is the channel #
.b949	bd 00 07	lda $0700,x			lda 	SNDQueue+1,x 				; copy data into the slot.
.b94c	99 ff 07	sta $07ff,y			sta 	SNDPitchLow,y
.b94f	bd 01 07	lda $0701,x			lda 	SNDQueue+2,x
.b952	99 03 08	sta $0803,y			sta 	SNDPitchHigh,y
.b955	bd 02 07	lda $0702,x			lda 	SNDQueue+3,x
.b958	99 07 08	sta $0807,y			sta 	SNDVolume,y
.b95b	bd 03 07	lda $0703,x			lda 	SNDQueue+4,x
.b95e	99 0b 08	sta $080b,y			sta 	SNDTimeLeft,y
.b961	bd 04 07	lda $0704,x			lda 	SNDQueue+5,x
.b964	99 0f 08	sta $080f,y			sta 	SNDAdjustLow,y
.b967	bd 05 07	lda $0705,x			lda 	SNDQueue+6,x
.b96a	99 13 08	sta $0813,y			sta 	SNDAdjustHigh,y
.b96d	5a		phy				phy 								; save channel #
.b96e	20 d8 b9	jsr $b9d8			jsr 	SNDDeleteXFromQueue 		; delete record at X from queue
.b971	ce fe 06	dec $06fe			dec 	SNDLength 					; reduce the queue length.
.b974	68		pla				pla
.b975	20 79 b9	jsr $b979			jsr 	SNDUpdateNote 				; update channel A
.b978					_SNDCCExit:
.b978	60		rts				rts
.b979					SNDUpdateNote:
.b979	aa		tax				tax 								; so we can access records
.b97a	0a		asl a				asl 	a 							; convert it to a channel bit pair in 5,6
.b97b	0a		asl a				asl 	a
.b97c	0a		asl a				asl 	a
.b97d	0a		asl a				asl 	a
.b97e	0a		asl a				asl 	a
.b97f	8d fd 06	sta $06fd			sta 	SNDChannelBits
.b982	bd 0b 08	lda $080b,x			lda 	SNDTimeLeft,x 				; are we silent
.b985	f0 2e		beq $b9b5			beq 	_SNDUNIsSilent
.b987	ad fd 06	lda $06fd			lda 	SNDChannelBits 				; push channel bits on stack
.b98a	48		pha				pha
.b98b	bd ff 07	lda $07ff,x			lda 	SNDPitchLow,x 				; get 4 lowest bits of pitch.
.b98e	29 0f		and #$0f			and 	#$0F
.b990	0d fd 06	ora $06fd			ora 	SNDChannelBits 				; set channel bits
.b993	09 80		ora #$80			ora 	#$80 						; write to pitch register
.b995	20 22 ba	jsr $ba22			jsr 	SNDWritePorts
.b998	bd 03 08	lda $0803,x			lda 	SNDPitchHigh,x 				; pitch high => channel temp.
.b99b	8d fd 06	sta $06fd			sta 	SNDChannelBits
.b99e	bd ff 07	lda $07ff,x			lda 	SNDPitchLow,x
.b9a1	4e fd 06	lsr $06fd			lsr 	SNDChannelBits 				; shift 2 LSBs into MSB of A
.b9a4	6a		ror a				ror 	a
.b9a5	4e fd 06	lsr $06fd			lsr 	SNDChannelBits
.b9a8	6a		ror a				ror 	a
.b9a9	4a		lsr a				lsr 	a 							; put in bits 0-5
.b9aa	4a		lsr a				lsr 	a
.b9ab	20 22 ba	jsr $ba22			jsr 	SNDWritePorts 				; write as rest of pitch register
.b9ae	68		pla				pla
.b9af	09 90		ora #$90			ora 	#$90 						; set to write minimum attentuation.
.b9b1	20 22 ba	jsr $ba22			jsr 	SNDWritePorts
.b9b4	60		rts				rts
.b9b5					_SNDUNIsSilent:
.b9b5	ad fd 06	lda $06fd			lda 	SNDChannelBits 				; channel bits
.b9b8	09 9f		ora #$9f			ora 	#$9F 						; maximum attenuation
.b9ba	20 22 ba	jsr $ba22			jsr 	SNDWritePorts 				; write to the ports
.b9bd	60		rts				rts
.b9be					SNDFindNextNoteForA:
.b9be	ac fe 06	ldy $06fe			ldy 	SNDLength 					; queue size into Y
.b9c1	f0 13		beq $b9d6			beq 	_SNDFNNFail 				; queue empty.
.b9c3	a2 00		ldx #$00			ldx 	#0
.b9c5					_SNDFNNSearch:
.b9c5	dd ff 06	cmp $06ff,x			cmp 	SNDQueue,x 					; does it match the channel
.b9c8	38		sec				sec
.b9c9	f0 0c		beq $b9d7			beq 	_SNDFNNExit 				; if so exit with CS.
.b9cb	e8		inx				inx 								; next queue slot.
.b9cc	e8		inx				inx
.b9cd	e8		inx				inx
.b9ce	e8		inx				inx
.b9cf	e8		inx				inx
.b9d0	e8		inx				inx
.b9d1	e8		inx				inx
.b9d2	e8		inx				inx
.b9d3	88		dey				dey 								; done the whole queue
.b9d4	d0 ef		bne $b9c5			bne 	_SNDFNNSearch 				; no, go back.
.b9d6					_SNDFNNFail:
.b9d6	18		clc				clc
.b9d7					_SNDFNNexit:
.b9d7	60		rts				rts
.b9d8					SNDDeleteXFromQueue:
.b9d8	e0 f8		cpx #$f8			cpx 	#SNDQueueSize*8-8 			; reached the end.
.b9da	f0 09		beq $b9e5			beq 	_SNDDXExit
.b9dc	bd 07 07	lda $0707,x			lda 	SNDQueue+8,x
.b9df	9d ff 06	sta $06ff,x			sta 	SNDQueue,x
.b9e2	e8		inx				inx
.b9e3	80 f3		bra $b9d8			bra 	SNDDeleteXFromQueue
.b9e5					_SNDDXExit:
.b9e5	60		rts				rts
.06fd					SNDChannelBits:
>06fd							.fill 	1
.b9e6					SNDQueueRequest:
.b9e6	86 36		stx $36				stx 	zTemp0						; save queue address
.b9e8	84 37		sty $37				sty 	zTemp0+1
.b9ea	ae fe 06	ldx $06fe			ldx 	SNDLength 					; queue is full, can't take any more.
.b9ed	e0 20		cpx #$20			cpx 	#SNDQueueSize
.b9ef	f0 21		beq $ba12			beq 	_SNDQRExit
.b9f1	29 03		and #$03			and 	#3	 						; channel # and push on stack
.b9f3	48		pha				pha
.b9f4	8a		txa				txa  								; get offset in queue buffer/
.b9f5	0a		asl a				asl 	a
.b9f6	0a		asl a				asl 	a
.b9f7	0a		asl a				asl 	a
.b9f8	aa		tax				tax
.b9f9	68		pla				pla 								; get back and push again
.b9fa	48		pha				pha
.b9fb	9d ff 06	sta $06ff,x			sta 	SNDQueue+0,x 				; save the channel #
.b9fe	a0 00		ldy #$00			ldy 	#0 							; copy the rest in.
.ba00					_SNDQCopy:
.ba00	b1 36		lda ($36),y			lda 	(zTemp0),y
.ba02	e8		inx				inx
.ba03	c8		iny				iny
.ba04	9d ff 06	sta $06ff,x			sta 	SNDQueue,x
.ba07	c0 06		cpy #$06			cpy 	#6
.ba09	d0 f5		bne $ba00			bne 	_SNDQCopy
.ba0b	ee fe 06	inc $06fe			inc 	SNDLength 					; bump queue length.
.ba0e	68		pla				pla 								; get channel # back
.ba0f	20 3a b9	jsr $b93a			jsr 	SNDCheckChannel 			; check if channel needs refreshing.
.ba12					_SNDQRExit:
.ba12	60		rts				rts
.ba13					SNDSilenceChannel:
.ba13	aa		tax				tax 								; zero time left.
.ba14	9e 0b 08	stz $080b,x			stz 	SNDTimeLeft,x
.ba17	0a		asl a				asl 	a 							; shift into position
.ba18	0a		asl a				asl 	a
.ba19	0a		asl a				asl 	a
.ba1a	0a		asl a				asl 	a
.ba1b	0a		asl a				asl 	a
.ba1c	09 9f		ora #$9f			ora 	#$9F 						; write register attenuation $F
.ba1e	20 22 ba	jsr $ba22			jsr 	SNDWritePorts
.ba21	60		rts				rts
.ba22					SNDWritePorts:
.ba22	64 01		stz $01				stz 	1
.ba24	8d 00 d6	sta $d600			sta 	$D600
.ba27	8d 10 d6	sta $d610			sta 	$D610
.ba2a	60		rts				rts
.ba2b					SNDCommand:
.ba2b	da		phx				phx
.ba2c	5a		phy				phy
.ba2d	c9 0f		cmp #$0f			cmp 	#$0F 						; $0F is initialise
.ba2f	f0 1d		beq $ba4e			beq 	_SNDInitialise
.ba31	90 28		bcc $ba5b			bcc 	_SNDExit
.ba33	c9 3f		cmp #$3f			cmp 	#$3F 						; $3F is silence all
.ba35	f0 17		beq $ba4e			beq 	_SNDSilence
.ba37	b0 22		bcs $ba5b			bcs 	_SNDExit
.ba39	c9 20		cmp #$20			cmp 	#$20 						; $2x is check playing => A
.ba3b	b0 09		bcs $ba46			bcs 	_SNDQueryPlay
.ba3d	c9 14		cmp #$14			cmp 	#$14 						; $10-$13 is queue sound
.ba3f	b0 1a		bcs $ba5b			bcs 	_SNDExit
.ba41	20 e6 b9	jsr $b9e6			jsr 	SNDQueueRequest
.ba44	80 15		bra $ba5b			bra 	_SNDExit
.ba46					_SNDQueryPlay:
.ba46	29 03		and #$03			and 	#3 							; get channel #
.ba48	aa		tax				tax
.ba49	bd 0b 08	lda $080b,x			lda 	SNDTimeLeft,x 				; read time left, if zero then silent
.ba4c	80 0d		bra $ba5b			bra 	_SNDExit
.ba4e					_SNDInitialise:
.ba4e					_SNDSilence:
.ba4e	9c fe 06	stz $06fe			stz 	SNDLength 					; empty the queue.
.ba51	a9 03		lda #$03			lda 	#$3 						; silence channel 0-3.
.ba53					_SNDSilenceLoop:
.ba53	48		pha				pha
.ba54	20 13 ba	jsr $ba13			jsr 	SNDSilenceChannel
.ba57	68		pla				pla
.ba58	3a		dec a				dec 	a
.ba59	10 f8		bpl $ba53			bpl 	_SNDSilenceLoop
.ba5b					_SNDExit:
.ba5b	7a		ply				ply
.ba5c	fa		plx				plx
.ba5d	60		rts				rts
=32					SNDQueueSize = 32 							; number of queue entries
.06fe					SNDLength:
>06fe							.fill 	1
.06ff					SNDQueue:
>06ff							.fill 	SNDQueueSize * 8
.07ff					SNDPitchLow:
>07ff							.fill 	4
.0803					SNDPitchHigh:
>0803							.fill 	4
.0807					SNDVolume:
>0807							.fill 	4
.080b					SNDTimeLeft:
>080b							.fill 	4
.080f					SNDAdjustLow:
>080f							.fill 	4
.0813					SNDAdjustHigh:
>0813							.fill 	4
.ba5e					SNDUpdate:
.ba5e	ad 0b 08	lda $080b			lda 	SNDTimeLeft+0 				; look at time remaining
.ba61	f0 05		beq $ba68			beq 	_SNDUNot0 					; not playing
.ba63	a2 00		ldx #$00			ldx 	#0 							; so we know which channel to update
.ba65	20 87 ba	jsr $ba87			jsr 	SNDUpdateChannel 			; update it.
.ba68					_SNDUNot0:
.ba68	ad 0c 08	lda $080c			lda 	SNDTimeLeft+1
.ba6b	f0 05		beq $ba72			beq 	_SNDUNot1
.ba6d	a2 01		ldx #$01			ldx 	#1
.ba6f	20 87 ba	jsr $ba87			jsr 	SNDUpdateChannel
.ba72					_SNDUNot1:
.ba72	ad 0d 08	lda $080d			lda 	SNDTimeLeft+2
.ba75	f0 05		beq $ba7c			beq 	_SNDUNot2
.ba77	a2 02		ldx #$02			ldx 	#2
.ba79	20 87 ba	jsr $ba87			jsr 	SNDUpdateChannel
.ba7c					_SNDUNot2:
.ba7c	ad 0e 08	lda $080e			lda 	SNDTimeLeft+3
.ba7f	f0 05		beq $ba86			beq 	_SNDUNot3
.ba81	a2 03		ldx #$03			ldx 	#3
.ba83	20 87 ba	jsr $ba87			jsr 	SNDUpdateChannel
.ba86					_SNDUNot3:
.ba86	60		rts				rts
.ba87					SNDUpdateChannel:
.ba87	c9 ff		cmp #$ff			cmp 	#$FF 						; sound $FF play forever until turned off manually
.ba89	f0 2c		beq $bab7			beq 	_SNDUCExit
.ba8b	3a		dec a				dec 	a 							; decrement and update timer
.ba8c	9d 0b 08	sta $080b,x			sta 	SNDTimeLeft,x
.ba8f	f0 1d		beq $baae			beq 	_SNDUCUpdate 				; if zero, silence channel
.ba91	bd 0f 08	lda $080f,x			lda 	SNDAdjustLow,x 				; adjust ?
.ba94	1d 13 08	ora $0813,x			ora 	SNDAdjustHigh,x
.ba97	f0 1e		beq $bab7			beq 	_SNDUCExit 					; if zero carry on at current tone.
.ba99	18		clc				clc 								; add adjust, forcing into a 10 bit range
.ba9a	bd ff 07	lda $07ff,x			lda 	SNDPitchLow,x
.ba9d	7d 0f 08	adc $080f,x			adc 	SNDAdjustLow,x
.baa0	9d ff 07	sta $07ff,x			sta 	SNDPitchLow,x
.baa3	bd 03 08	lda $0803,x			lda 	SNDPitchHigh,x
.baa6	7d 13 08	adc $0813,x			adc 	SNDAdjustHigh,x
.baa9	29 03		and #$03			and 	#3
.baab	9d 03 08	sta $0803,x			sta 	SNDPitchHigh,x
.baae					_SNDUCUpdate:
.baae	8a		txa				txa 								; which channel.
.baaf	48		pha				pha
.bab0	20 79 b9	jsr $b979			jsr 	SNDUpdateNote 				; update the current note
.bab3	68		pla				pla
.bab4	20 3a b9	jsr $b93a			jsr 	SNDCheckChannel 			; more to do ?
.bab7					_SNDUCExit:
.bab7	60		rts				rts

;******  Return to file: _basic.asm


;******  End of listing
