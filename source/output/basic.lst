
; 64tass Turbo Assembler Macro V1.57.2900 listing file
; 64tass -D AUTORUN=1 "-D MONITOR_ADDRESS=\$E000" "-D LOCKOUT_ADDRESS=\$F000" "-D BASIC_ADDRESS=\$38000" "-D SOURCE_ADDRESS=\$28000" "-D SPRITE_ADDRESS=\$30000" -q -b -Wall -c -D "HARDWARE=0 $'\x9'$'\x9'$'\x9'$'\x9'$'\x9'$'\x9'" -L output/basic.lst -l output/basic.lbl -Wall -o build/basic.rom _basic.asm
; Tue Dec  6 08:26:00 2022

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=1					AUTORUN=1
=$e000					 MONITOR_ADDRESS=$E000
=$f000					 LOCKOUT_ADDRESS=$F000
=$38000					 BASIC_ADDRESS=$38000
=$28000					 SOURCE_ADDRESS=$28000
=$30000					 SPRITE_ADDRESS=$30000
=0					HARDWARE=0

;******  Processing input file: _basic.asm


;******  Processing file: ./common/aa.system/01common.inc

=$30					ZeroPageMandatory = $30
=$50					ZeroPagePreference = $50
=$400					MemoryStorage = $400
=$2000					BasicStart = $2000
=$8000					BasicEnd = $8000
=$8000					CodeStart = $8000
=$1000					VariableSpace = $1000
=$2000					EndVariableSpace = $2000
=8					MathStackSize = 8
=512					BasicStackSize = 512
=3584					BasicStackBase = $1000-BasicStackSize
=80					MaxLineSize = 80

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/02macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/04data.inc

.0030					codePtr:
>0030							.fill 	4
.0034					basicStack:
>0034							.fill 	2
.0036					zTemp0:
>0036							.fill 	2
.0038					zTemp1:
>0038							.fill 	2
.003a					zTemp2:
>003a							.fill 	2
.003c					zsTemp:
>003c							.fill 	2
.003e					zaTemp:
>003e							.fill 	2
=$30					safePtr = codePtr 							; minimise direct tinkering
=$80					NSBIsNegative = $80 						; bit 7 : sign of mantissa (where numeric)
=$20					NSBIsReference = $20 						; bit 5 : is a reference
=$10					NSBIsString = $10 							; bit 4 : set if string (procedures don't go on the stack)
=$18					NSBTypeMask = $18 							; bits 4,3 : 00 int 01 float 10 string 11 procedure
=$03					NSBRefMask = $03 							; bits 0,1 : Bytes of reference, 00 = 4,01 = 1,10=2
=$04					NSBIsArray = $04
=$00					NSTInteger = $00 							; base types for bits 3..4
=$08					NSTFloat = $08
=$10					NSTString = $10
=$18					NSTProcedure = $18
.0050					NSStatus:
>0050							.fill 	MathStackSize
.0058					NSMantissa0:
>0058							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0060					NSMantissa1:
>0060							.fill 	MathStackSize
.0068					NSMantissa2:
>0068							.fill 	MathStackSize
.0070					NSMantissa3:
>0070							.fill 	MathStackSize
.0078					NSExponent:
>0078							.fill 	MathStackSize
.0400					identStart:
>0400							.fill 	1
.0401					identTypeStart:
>0401							.fill 	1
.0402					identTypeEnd:
>0402							.fill 	1
.0403					identHash:
>0403							.fill 	1
.0404					identTypeByte:
>0404							.fill 	1	 						; (see tokenising.pdf)
.0405					encodeState:
>0405							.fill 	1
.0406					digitTemp:
>0406							.fill 	1
.0407					decimalCount:
>0407							.fill 	1
.0408					randomSeed:
>0408							.fill 	4
.040c					lowMemPtr:
>040c							.fill 	2
.040e					stringMemory:
>040e							.fill 	2
.0410					stringInitialised:
>0410							.fill 	1
.0411					stringTempPointer:
>0411							.fill 	2
.0413					breakCheck:
>0413							.fill 	1
.0414					decimalPlaces:
>0414							.fill 	1
.0415					dbOffset:
>0415							.fill 	1
.0416					lastParameter:
>0416							.fill 	1
.0417					dataPointer:
>0417							.fill 	5
.041c					inDataStatement:
>041c							.fill 	1
.041d					tbOffset:
>041d							.fill 	1
.041e					AssemblerAddress:
>041e							.fill 	2
.0420					AssemblerControl:
>0420							.fill 	1
.0421					ParamStart:
>0421							.fill 	2
.0423					IsGroup1:
>0423							.fill 	1
.0424					BaseOpcode:
>0424							.fill 	1
.0425					ModeMask:
>0425							.fill 	1
.0426					listIndent:
>0426							.fill 	1
.0427					lcLastCharacter:
>0427							.fill 	1
.0428					isInputFlag:
>0428							.fill 	1
.0429					currentListColour:
>0429							.fill 	1
.042a					tokenOffset:
>042a							.fill 	1
.042b					tokenLineNumber:
>042b							.fill 	2
.042d					tokenBuffer:
>042d							.fill 	253
.052a					lineBuffer:
>052a							.fill 	253
.0627					numberBuffer:
>0627							.fill 	34
.0649					decimalBuffer:
>0649							.fill 	16

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/constants.inc

=$80					AM_ISZP = $80
=$40					AM_ISG1 = $40
=$20					AM_ISG2 = $20
=224					AM_IMMEDIATE = AM_ISZP+AM_ISG1+AM_ISG2+$00
=228					AM_ZEROPAGE = AM_ISZP+AM_ISG1+AM_ISG2+$04
=40					AM_ACC = AM_ISG2+$08
=108					AM_ABS = AM_ISG1+AM_ISG2+$0C
=208					AM_INDY = AM_ISZP+AM_ISG1+$10
=244					AM_ZEROX = AM_ISZP+AM_ISG1+AM_ISG2+$14
=120					AM_ABSY = AM_ISG1+AM_ISG2+$18
=124					AM_ABSX = AM_ISG1+AM_ISG2+$1C
=209					AM_IND = AM_ISZP+AM_ISG1+$11
=$80					AM_ZEROY = AM_ISZP
=$01					AM_INDABS = $01
=$02					AM_INDABSX = $02
=192					AM_INDX = AM_ISZP+AM_ISG1+$00

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/handlers.inc


;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.inc

=1					ERRID_BREAK = 1
=2					ERRID_SYNTAX = 2
=3					ERRID_DIVZERO = 3
=4					ERRID_RANGE = 4
=5					ERRID_TYPE = 5
=6					ERRID_MEMORY = 6
=7					ERRID_ARGUMENT = 7
=8					ERRID_STOP = 8
=9					ERRID_STRING = 9
=10					ERRID_ASSERT = 10
=11					ERRID_DATA = 11
=12					ERRID_NOTDONE = 12
=13					ERRID_LINE = 13
=14					ERRID_GOSUB = 14
=15					ERRID_REPEAT = 15
=16					ERRID_WHILE = 16
=17					ERRID_FOR = 17
=18					ERRID_STACK = 18
=19					ERRID_STRUCT = 19
=20					ERRID_PROC = 20
=21					ERRID_REDEFINE = 21
=22					ERRID_ARRAYSIZE = 22
=23					ERRID_ARRAYIDX = 23
=24					ERRID_ARRAYDEC = 24

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst.inc

=$00					KWD_LESSLESS                         = $00; $00 <<
=$01					KWD_LESSEQUAL                        = $01; $01 <=
=$02					KWD_LESSGREATER                      = $02; $02 <>
=$03					KWD_PLINGPLING3                      = $03; $03 !!3
=$04					KWD_GREATERLESS                      = $04; $04 ><
=$05					KWD_GREATEREQUAL                     = $05; $05 >=
=$06					KWD_GREATERGREATER                   = $06; $06 >>
=$07					KWD_PLINGPLING7                      = $07; $07 !!7
=$08					KWD_PLINGPLING8                      = $08; $08 !!8
=$09					KWD_PLINGPLING9                      = $09; $09 !!9
=$0a					KWD_PLINGPLING10                     = $0a; $0a !!10
=$0b					KWD_PLINGPLING11                     = $0b; $0b !!11
=$0c					KWD_PLINGPLING12                     = $0c; $0c !!12
=$0d					KWD_PLINGPLING13                     = $0d; $0d !!13
=$0e					KWD_PLINGPLING14                     = $0e; $0e !!14
=$0f					KWD_PLINGPLING15                     = $0f; $0f !!15
=$10					KWD_AT                               = $10; $10 @
=$11					KWD_PLINGPLING17                     = $11; $11 !!17
=$12					KWD_PLINGPLING18                     = $12; $12 !!18
=$13					KWD_LSQPAREN                         = $13; $13 [
=$14					KWD_BACKSLASH                        = $14; $14 \
=$15					KWD_RSQPAREN                         = $15; $15 ]
=$16					KWD_HAT                              = $16; $16 ^
=$17					KWD_UNDERSCORE                       = $17; $17 _
=$18					KWD_BQUOTE                           = $18; $18 `
=$19					KWD_PLINGPLING25                     = $19; $19 !!25
=$1a					KWD_PLINGPLING26                     = $1a; $1a !!26
=$1b					KWD_LCURLY                           = $1b; $1b {
=$1c					KWD_BAR                              = $1c; $1c |
=$1d					KWD_RCURLY                           = $1d; $1d }
=$1e					KWD_TILDE                            = $1e; $1e ~
=$21					KWD_PLING                            = $21; $21 !
=$22					KWD_DQUOTE                           = $22; $22 "
=$23					KWD_HASH                             = $23; $23 #
=$24					KWD_DOLLAR                           = $24; $24 $
=$25					KWD_PERCENT                          = $25; $25 %
=$26					KWD_AMPERSAND                        = $26; $26 &
=$27					KWD_QUOTE                            = $27; $27 '
=$28					KWD_LPAREN                           = $28; $28 (
=$29					KWD_RPAREN                           = $29; $29 )
=$2a					KWD_STAR                             = $2a; $2a *
=$2b					KWD_PLUS                             = $2b; $2b +
=$2c					KWD_COMMA                            = $2c; $2c ,
=$2d					KWD_MINUS                            = $2d; $2d -
=$2e					KWD_PERIOD                           = $2e; $2e .
=$2f					KWD_SLASH                            = $2f; $2f /
=$30					KWD_0                                = $30; $30 0
=$31					KWD_1                                = $31; $31 1
=$32					KWD_2                                = $32; $32 2
=$33					KWD_3                                = $33; $33 3
=$34					KWD_4                                = $34; $34 4
=$35					KWD_5                                = $35; $35 5
=$36					KWD_6                                = $36; $36 6
=$37					KWD_7                                = $37; $37 7
=$38					KWD_8                                = $38; $38 8
=$39					KWD_9                                = $39; $39 9
=$3a					KWD_COLON                            = $3a; $3a :
=$3b					KWD_SEMICOLON                        = $3b; $3b ;
=$3c					KWD_LESS                             = $3c; $3c <
=$3d					KWD_EQUAL                            = $3d; $3d =
=$3e					KWD_GREATER                          = $3e; $3e >
=$3f					KWD_QMARK                            = $3f; $3f ?
=$83					KWD_ABSLPAREN                        = $83; $83 ABS(
=$84					KWD_ALLOCLPAREN                      = $84; $84 ALLOC(
=$85					KWD_ASCLPAREN                        = $85; $85 ASC(
=$86					KWD_CHRDOLLARLPAREN                  = $86; $86 CHR$(
=$87					KWD_DEEKLPAREN                       = $87; $87 DEEK(
=$88					KWD_EVENTLPAREN                      = $88; $88 EVENT(
=$89					KWD_FALSE                            = $89; $89 FALSE
=$8a					KWD_FRACLPAREN                       = $8a; $8a FRAC(
=$8b					KWD_HITLPAREN                        = $8b; $8b HIT(
=$8c					KWD_INTLPAREN                        = $8c; $8c INT(
=$8d					KWD_ISVALLPAREN                      = $8d; $8d ISVAL(
=$8e					KWD_JOYBLPAREN                       = $8e; $8e JOYB(
=$8f					KWD_JOYXLPAREN                       = $8f; $8f JOYX(
=$90					KWD_JOYYLPAREN                       = $90; $90 JOYY(
=$91					KWD_LEFTDOLLARLPAREN                 = $91; $91 LEFT$(
=$92					KWD_LENLPAREN                        = $92; $92 LEN(
=$93					KWD_MAXLPAREN                        = $93; $93 MAX(
=$94					KWD_MIDDOLLARLPAREN                  = $94; $94 MID$(
=$95					KWD_MINLPAREN                        = $95; $95 MIN(
=$96					KWD_NOTLPAREN                        = $96; $96 NOT(
=$97					KWD_PEEKLPAREN                       = $97; $97 PEEK(
=$98					KWD_PLAYINGLPAREN                    = $98; $98 PLAYING(
=$99					KWD_RANDOMLPAREN                     = $99; $99 RANDOM(
=$9a					KWD_RIGHTDOLLARLPAREN                = $9a; $9a RIGHT$(
=$9b					KWD_RNDLPAREN                        = $9b; $9b RND(
=$9c					KWD_SGNLPAREN                        = $9c; $9c SGN(
=$9d					KWD_SPCLPAREN                        = $9d; $9d SPC(
=$9e					KWD_STRDOLLARLPAREN                  = $9e; $9e STR$(
=$9f					KWD_TIMERLPAREN                      = $9f; $9f TIMER(
=$a0					KWD_TRUE                             = $a0; $a0 TRUE
=$a1					KWD_VALLPAREN                        = $a1; $a1 VAL(
=$a2					KWD_FOR                              = $a2; $a2 FOR
=$a3					KWD_IF                               = $a3; $a3 IF
=$a4					KWD_PROC                             = $a4; $a4 PROC
=$a5					KWD_REPEAT                           = $a5; $a5 REPEAT
=$a6					KWD_WHILE                            = $a6; $a6 WHILE
=$a7					KWD_ENDIF                            = $a7; $a7 ENDIF
=$a8					KWD_ENDPROC                          = $a8; $a8 ENDPROC
=$a9					KWD_NEXT                             = $a9; $a9 NEXT
=$aa					KWD_THEN                             = $aa; $aa THEN
=$ab					KWD_UNTIL                            = $ab; $ab UNTIL
=$ac					KWD_WEND                             = $ac; $ac WEND
=$ad					KWD_BY                               = $ad; $ad BY
=$ae					KWD_CALL                             = $ae; $ae CALL
=$af					KWD_CIRCLE                           = $af; $af CIRCLE
=$b0					KWD_CLEAR                            = $b0; $b0 CLEAR
=$b1					KWD_CLS                              = $b1; $b1 CLS
=$b2					KWD_COLOR                            = $b2; $b2 COLOR
=$b3					KWD_COLOUR                           = $b3; $b3 COLOUR
=$b4					KWD_DATA                             = $b4; $b4 DATA
=$b5					KWD_DIM                              = $b5; $b5 DIM
=$b6					KWD_DOKE                             = $b6; $b6 DOKE
=$b7					KWD_DOWNTO                           = $b7; $b7 DOWNTO
=$b8					KWD_ELSE                             = $b8; $b8 ELSE
=$b9					KWD_FROM                             = $b9; $b9 FROM
=$ba					KWD_GFX                              = $ba; $ba GFX
=$bb					KWD_GOSUB                            = $bb; $bb GOSUB
=$bc					KWD_GOTO                             = $bc; $bc GOTO
=$bd					KWD_HERE                             = $bd; $bd HERE
=$be					KWD_IMAGE                            = $be; $be IMAGE
=$bf					KWD_INPUT                            = $bf; $bf INPUT
=$c0					KWD_LET                              = $c0; $c0 LET
=$c1					KWD_LINE                             = $c1; $c1 LINE
=$c2					KWD_LOCAL                            = $c2; $c2 LOCAL
=$c3					KWD_OFF                              = $c3; $c3 OFF
=$c4					KWD_ON                               = $c4; $c4 ON
=$c5					KWD_OUTLINE                          = $c5; $c5 OUTLINE
=$c6					KWD_PALETTE                          = $c6; $c6 PALETTE
=$c7					KWD_PLOT                             = $c7; $c7 PLOT
=$c8					KWD_POKE                             = $c8; $c8 POKE
=$c9					KWD_PRINT                            = $c9; $c9 PRINT
=$ca					KWD_READ                             = $ca; $ca READ
=$cb					KWD_RECT                             = $cb; $cb RECT
=$cc					KWD_REM                              = $cc; $cc REM
=$cd					KWD_RETURN                           = $cd; $cd RETURN
=$ce					KWD_SOLID                            = $ce; $ce SOLID
=$cf					KWD_SOUND                            = $cf; $cf SOUND
=$d0					KWD_SPRITE                           = $d0; $d0 SPRITE
=$d1					KWD_TEXT                             = $d1; $d1 TEXT
=$d2					KWD_TO                               = $d2; $d2 TO

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst0.inc

=$80					KWC_EOL = $80
=$ff					KWC_STRING = $FF
=$fe					KWC_HEXCONST = $FE
=$a2					KWC_FIRST_STRUCTURE = $a2
=$a7					KWC_FIRST_STRUCTURE_DEC = $a7
=$ac					KWC_LAST_STRUCTURE = $ac
=$83					KWC_FIRST_UNARY = $83
=$a1					KWC_LAST_UNARY = $a1

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/access.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/stack.inc

=$e0					STK_GOSUB = $E0
=$d0					STK_FOR = $D0
=$c0					STK_REPEAT = $C0
=$b0					STK_PROC = $B0
=$a0					STK_WHILE = $A0
=$01					STK_LOCALN = $01
=$02					STK_LOCALS = $02

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/00start.asm

.8000	4c 24 80	jmp $8024	Boot:	jmp 	Start

;******  Processing file: ./common/aa.system/../../../modules/_build/_linker.module

=0					PagingEnabled = 0
.8003					EXTPrintCharacter:
.8003	4c fa a7	jmp $a7fa		jmp	Export_EXTPrintCharacter
.8006					EXTInitialise:
.8006	4c 93 aa	jmp $aa93		jmp	Export_EXTInitialise
.8009					EXTInputSingleCharacter:
.8009	4c c9 aa	jmp $aac9		jmp	Export_EXTInputSingleCharacter
.800c					EXTBreakCheck:
.800c	4c ef aa	jmp $aaef		jmp	Export_EXTBreakCheck
.800f					EXTReadController:
.800f	4c f2 aa	jmp $aaf2		jmp	Export_EXTReadController
.8012					EXTInputLine:
.8012	4c a9 a9	jmp $a9a9		jmp	Export_EXTInputLine
.8015					GXGraphicDraw:
.8015	4c 8d ab	jmp $ab8d		jmp	Export_GXGraphicDraw
.8018					SNDCommand:
.8018	4c 72 be	jmp $be72		jmp	Export_SNDCommand
.801b					SNDUpdate:
.801b	4c a5 be	jmp $bea5		jmp	Export_SNDUpdate
.801e					TKListConvertLine:
.801e	4c 68 b8	jmp $b868		jmp	Export_TKListConvertLine
.8021					TKTokeniseLine:
.8021	4c fc ba	jmp $bafc		jmp	Export_TKTokeniseLine

;******  Return to file: ./common/aa.system/00start.asm

.8024	a2 ff		ldx #$ff	Start:	ldx 	#$FF 						; stack reset
.8026	9a		txs				txs
.8027	20 0c 80	jsr $800c			jsr 	EXTBreakCheck 				; added to stop initial break bug.
.802a	a5 00		lda $00				lda 	0  							; turn on editing of MMU LUT
.802c	09 80		ora #$80			ora 	#$80
.802e	85 00		sta $00				sta 	0
.8030	20 06 80	jsr $8006			jsr 	EXTInitialise 				; hardware initialise
.8033	a9 00		lda #$00			lda 	#0 							; graphics system initialise.
.8035	aa		tax				tax
.8036	a8		tay				tay
.8037	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.803a	a9 0f		lda #$0f			lda 	#$0F 						; initialise sound system
.803c	20 18 80	jsr $8018			jsr 	SNDCommand
.803f	a2 80		ldx #$80			ldx 	#Prompt >> 8 				; display prompt
.8041	a9 4f		lda #$4f			lda 	#Prompt & $FF
.8043	20 52 8f	jsr $8f52			jsr 	PrintStringXA
.8046	20 2e 8a	jsr $8a2e			jsr 	NewProgram 					; erase current program
.8049	20 20 83	jsr $8320			jsr 	BackloadProgram
.804c	4c 6f 8b	jmp $8b6f			jmp 	CommandRun
>804f	36 35 30 32 20 53 75 70		Prompt:	.text 	"6502 SuperBASIC",13
>8057	65 72 42 41 53 49 43 0d
>805f	43 6f 70 79 72 69 67 68				.text 	"Copyright 2022 Paul Robson",13
>8067	74 20 32 30 32 32 20 50 61 75 6c 20 52 6f 62 73
>8077	6f 6e 0d
>807a	50 61 75 6c 40 52 6f 62				.text  	"Paul@Robsons.org.uk",13
>8082	73 6f 6e 73 2e 6f 72 67 2e 75 6b 0d
>808e	46 32 35 36 20					.text "F256 "

;******  Processing file: ./common/aa.system/../generated/timestamp.asm

>8093	41 6c 70 68 61 20 31 32			.text "Alpha 12 built 06-Dec-22. "
>809b	20 62 75 69 6c 74 20 30 36 2d 44 65 63 2d 32 32
>80ab	2e 20

;******  Return to file: ./common/aa.system/00start.asm

>80ad	0d						.byte  	13
>80ae	0d 0d 00					.text 	13,13,0

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/assembler.asm

.80b1					AssembleGroup1:
.80b1	a9 ff		lda #$ff			lda 	#$FF 						; flag for group 1 / mask.
.80b3	8d 25 04	sta $0425			sta 	ModeMask 					; initialise the mode mask - all for all
.80b6	80 02		bra $80ba			bra 	AsmGroup12
.80b8					AssembleGroup2:
.80b8	a9 00		lda #$00			lda 	#$00 						; flag for group 2
.80ba					AsmGroup12:
.80ba	8d 23 04	sta $0423			sta 	IsGroup1 					; save the 'group 1' flag
.80bd	68		pla				pla 								; pop the return address to access the information following.
.80be	fa		plx				plx
.80bf	20 46 81	jsr $8146			jsr 	AccessParameters 			; get opcode and save as base
.80c2	8d 24 04	sta $0424			sta 	BaseOpcode
.80c5	ad 23 04	lda $0423			lda 	IsGroup1 					; skip if group 1 as we don't have a complex mask.
.80c8	d0 08		bne $80d2			bne 	_AG12HaveMask
.80ca	a9 02		lda #$02			lda 	#2 							; if group 2 the second parameter is the mask
.80cc	20 4e 81	jsr $814e			jsr 	GetParameter		 		; e.g. which modes are supported for this operand
.80cf	8d 25 04	sta $0425			sta 	ModeMask
.80d2					_AG12HaveMask:
.80d2	20 82 82	jsr $8282			jsr 	TypeAndCalculateOperand 	; get zero page type
.80d5	da		phx				phx 								; save found address mode
.80d6	20 b2 81	jsr $81b2			jsr 	AssembleModeX
.80d9	fa		plx				plx  								; restore address mode
.80da	b0 0b		bcs $80e7			bcs 	_AG12Exit
.80dc	20 e8 80	jsr $80e8			jsr 	PromoteToAbsolute  			; promote ZP to ABS and try that
.80df	20 b2 81	jsr $81b2			jsr 	AssembleModeX
.80e2	b0 03		bcs $80e7			bcs 	_AG12Exit
.80e4	4c 9e 9f	jmp $9f9e			jmp 	SyntaxError 				; can't do either, so must be wrong mode/operand.
.80e7					_AG12Exit:
.80e7	60		rts				rts
.80e8					PromoteToAbsolute:
.80e8	a9 6c		lda #$6c			lda 	#AM_ABS 					; lda xx
.80ea	e0 e4		cpx #$e4			cpx 	#AM_ZEROPAGE
.80ec	f0 19		beq $8107			beq 	_PTADo
.80ee	a9 7c		lda #$7c			lda 	#AM_ABSX 					; lda xx,X
.80f0	e0 f4		cpx #$f4			cpx 	#AM_ZEROX
.80f2	f0 13		beq $8107			beq 	_PTADo
.80f4	a9 78		lda #$78			lda 	#AM_ABSY 					; lda xx,Y
.80f6	e0 80		cpx #$80			cpx 	#AM_ZEROY
.80f8	f0 0d		beq $8107			beq 	_PTADo
.80fa	a9 01		lda #$01			lda 	#AM_INDABS 					; lda (xx) (jump)
.80fc	e0 d1		cpx #$d1			cpx 	#AM_IND
.80fe	f0 07		beq $8107			beq 	_PTADo
.8100	a9 02		lda #$02			lda 	#AM_INDABSX 				; lda (xx,x) (jump)
.8102	e0 c0		cpx #$c0			cpx 	#AM_INDX
.8104	f0 01		beq $8107			beq 	_PTADo
.8106	60		rts				rts
.8107					_PTADo:
.8107	aa		tax				tax
.8108	60		rts				rts
.8109					AssembleGroup3:
.8109	68		pla				pla 								; get parameters, which is just the opcode.
.810a	fa		plx				plx
.810b	20 46 81	jsr $8146			jsr 	AccessParameters 			; get and output opcode
.810e	20 5e 81	jsr $815e			jsr 	AssemblerWriteByte
.8111	20 e6 82	jsr $82e6			jsr 	CalculateOperand 			; get a 16 bit operand
.8114	a5 58		lda $58				lda 	NSMantissa0 				; calculate the offset
.8116	38		sec				sec
.8117	ed 1e 04	sbc $041e			sbc 	AssemblerAddress
.811a	48		pha				pha 								; LSB in A
.811b	a5 60		lda $60				lda 	NSMantissa1
.811d	ed 1f 04	sbc $041f			sbc 	AssemblerAddress+1
.8120	aa		tax				tax 								; MSB in X
.8121	68		pla				pla
.8122	18		clc				clc 								; $80 to easy check $80-$7F, plus 1 for offset error
.8123	69 7f		adc #$7f			adc 	#$7F
.8125	90 01		bcc $8128			bcc 	_AG3NoCarry
.8127	e8		inx				inx
.8128					_AG3NoCarry:
.8128	38		sec				sec 								; fix back and write out anyways.
.8129	e9 80		sbc #$80			sbc 	#$80
.812b	20 5e 81	jsr $815e			jsr 	AssemblerWriteByte
.812e	e0 00		cpx #$00			cpx 	#0 							; was it in range
.8130	f0 0a		beq $813c			beq 	_AG3Exit
.8132	ad 20 04	lda $0420			lda 	AssemblerControl 			; are we allowing bad values ?
.8135	29 01		and #$01			and 	#1
.8137	f0 03		beq $813c			beq 	_AG3Exit
.8139	4c a3 9f	jmp $9fa3			jmp 	RangeError 					; no, branch is out of range
.813c					_AG3Exit:
.813c	60		rts				rts
.813d					AssembleGroup4:
.813d	68		pla				pla 								; pop address
.813e	fa		plx				plx
.813f	20 46 81	jsr $8146			jsr 	AccessParameters 			; access and get first
.8142	20 5e 81	jsr $815e			jsr 	AssemblerWriteByte 			; output it.
.8145	60		rts				rts
.8146					AccessParameters:
.8146	8d 21 04	sta $0421			sta 	ParamStart
.8149	8e 22 04	stx $0422			stx 	ParamStart+1
.814c	a9 01		lda #$01			lda 	#1
.814e					GetParameter:
.814e	5a		phy				phy
.814f	a8		tay				tay
.8150	ad 21 04	lda $0421			lda 	ParamStart
.8153	85 36		sta $36				sta 	zTemp0
.8155	ad 22 04	lda $0422			lda 	ParamStart+1
.8158	85 37		sta $37				sta 	zTemp0+1
.815a	b1 36		lda ($36),y			lda 	(zTemp0),y
.815c	7a		ply				ply
.815d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/aswrite.asm

.815e					AssemblerWriteByte:
.815e	48		pha			pha
.815f	ad 20 04	lda $0420		lda 	AssemblerControl 				; check printing bytes ?
.8162	29 02		and #$02		and 	#2
.8164	f0 1b		beq $8181		beq 	_AWBNoPrint
.8166	ad 1f 04	lda $041f		lda		AssemblerAddress+1 				; print address
.8169	20 9c 81	jsr $819c		jsr 	PrintHex
.816c	ad 1e 04	lda $041e		lda		AssemblerAddress
.816f	20 9c 81	jsr $819c		jsr 	PrintHex
.8172	a9 20		lda #$20		lda 	#' '
.8174	20 03 80	jsr $8003		jsr 	EXTPrintCharacter
.8177	68		pla			pla 									; print byte
.8178	48		pha			pha
.8179	20 9c 81	jsr $819c		jsr 	PrintHex
.817c	a9 0d		lda #$0d		lda 	#13
.817e	20 03 80	jsr $8003		jsr 	EXTPrintCharacter
.8181					_AWBNoPrint:
.8181	ad 1e 04	lda $041e		lda		AssemblerAddress				; copy address to zTemp0
.8184	85 36		sta $36			sta 	zTemp0
.8186	ad 1f 04	lda $041f		lda		AssemblerAddress+1
.8189	f0 0e		beq $8199		beq 	_AWBRange
.818b	85 37		sta $37			sta 	zTemp0+1
.818d	68		pla			pla 									; write byte out
.818e	92 36		sta ($36)		sta 	(zTemp0)
.8190	ee 1e 04	inc $041e		inc 	AssemblerAddress 				; bump address
.8193	d0 03		bne $8198		bne 	_AWBNoCarry
.8195	ee 1f 04	inc $041f		inc 	AssemblerAddress+1
.8198					_AWBNoCarry:
.8198	60		rts			rts
.8199					_AWBRange:
.8199	4c a3 9f	jmp $9fa3		jmp 	RangeError
.819c					PrintHex:
.819c	48		pha				pha
.819d	4a		lsr a				lsr 	a
.819e	4a		lsr a				lsr 	a
.819f	4a		lsr a				lsr 	a
.81a0	4a		lsr a				lsr 	a
.81a1	20 a5 81	jsr $81a5			jsr 	_PrintNibble
.81a4	68		pla				pla
.81a5					_PrintNibble:
.81a5	29 0f		and #$0f			and 	#15
.81a7	c9 0a		cmp #$0a			cmp 	#10
.81a9	90 02		bcc $81ad			bcc 	_NoShift
.81ab	69 06		adc #$06			adc 	#6
.81ad					_NoShift:
.81ad	69 30		adc #$30			adc 	#48
.81af	4c 03 80	jmp $8003			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/instruction.asm

.81b2					AssembleModeX:
.81b2	5a		phy				phy
.81b3	ad 23 04	lda $0423			lda 	IsGroup1
.81b6	f0 17		beq $81cf			beq 	_AMXGroup2
.81b8	8a		txa				txa 							; is it in group # 1
.81b9	29 40		and #$40			and 	#AM_ISG1
.81bb	f0 4d		beq $820a			beq 	_AMXFail 				; no, give up.
.81bd	8a		txa				txa 							; get back.
.81be	29 1f		and #$1f			and 	#$1F 					; this is now the offset.
.81c0	e0 e0		cpx #$e0			cpx 	#AM_IMMEDIATE 			; if not immediate, we can continue.
.81c2	d0 22		bne $81e6			bne 	_AMXHaveInfo
.81c4	ad 24 04	lda $0424			lda 	BaseOpcode 				; cannot store immediate.
.81c7	c9 81		cmp #$81			cmp 	#$81
.81c9	f0 3f		beq $820a			beq 	_AMXFail
.81cb	a9 08		lda #$08			lda 	#8 						; if immediate we use offset 8.
.81cd	80 17		bra $81e6			bra 	_AMXHaveInfo 			; odd design decision there.
.81cf					_AMXGroup2:
.81cf	8a		txa				txa 							; is it in group 2 ?
.81d0	29 20		and #$20			and 	#AM_ISG2
.81d2	f0 36		beq $820a			beq 	_AMXFail 				; no, give up.
.81d4	8a		txa				txa 							; get the offset into Y
.81d5	29 1f		and #$1f			and 	#$1F
.81d7	4a		lsr a				lsr 	a 						; make it 0-7.
.81d8	4a		lsr a				lsr  	a
.81d9	a8		tay				tay
.81da	ad 25 04	lda $0425			lda 	ModeMask 				; shift the modemask left so you can check it against the requested offset
.81dd					_AMXCheckOkay:
.81dd	0a		asl a				asl 	a 						; shift modemask left enough times to check legitimate.
.81de	88		dey				dey
.81df	10 fc		bpl $81dd			bpl 	_AMXCheckOkay
.81e1	90 27		bcc $820a			bcc 	_AMXFail 				; not allowed.
.81e3	8a		txa				txa  							; get mask back
.81e4	29 1f		and #$1f			and 	#$1F
.81e6					_AMXHaveInfo:
.81e6	e0 00		cpx #$00			cpx 	#$00 					; does it *require* an 8 bit operand
.81e8	10 04		bpl $81ee			bpl 	_AMXAnySize 			; checking bit 7, the zero page opcode flag.
.81ea	a4 60		ldy $60				ldy 	NSMantissa1 			; fail if it is outside range, e.g. the MSB is set.
.81ec	d0 1c		bne $820a			bne 	_AMXFail
.81ee					_AMXAnySize:
.81ee	18		clc				clc 							; add offset to the base opcode
.81ef	6d 24 04	adc $0424			adc 	BaseOpcode
.81f2					_AMXOutputCode:
.81f2	20 5e 81	jsr $815e			jsr 	AssemblerWriteByte 		; write the opcode out.
.81f5	e0 28		cpx #$28			cpx 	#AM_ACC 				; A mode (e.g. ASL)
.81f7	f0 0e		beq $8207			beq 	_AMXExit
.81f9	a5 58		lda $58				lda 	NSMantissa0 			; write LSB operand
.81fb	20 5e 81	jsr $815e			jsr 	AssemblerWriteByte
.81fe	e0 00		cpx #$00			cpx 	#$00 					; zeropage ?
.8200	30 05		bmi $8207			bmi 	_AMXExit
.8202	a5 60		lda $60				lda 	NSMantissa1 			; write MSB operand
.8204	20 5e 81	jsr $815e			jsr 	AssemblerWriteByte
.8207					_AMXExit:
.8207	7a		ply				ply
.8208	38		sec				sec
.8209	60		rts				rts
.820a					_AMXFail:
.820a	a0 00		ldy #$00			ldy 	#0
.820c					_AMXCheckOddities:
.820c	8a		txa				txa
.820d	d9 34 82	cmp $8234,y			cmp 	ExtraOpcode+2,y 		; match address mode
.8210	d0 15		bne $8227			bne 	_AMXCONext
.8212	b9 32 82	lda $8232,y			lda 	ExtraOpcode+0,y 		; do the base opcodes match
.8215	cd 24 04	cmp $0424			cmp 	BaseOpcode
.8218	d0 0d		bne $8227			bne 	_AMXCONext
.821a	e0 00		cpx #$00			cpx 	#$00 					; requires zero page ?
.821c	10 04		bpl $8222			bpl 	_AMXCONotZero
.821e	a5 60		lda $60				lda 	NSMantissa1
.8220	d0 05		bne $8227			bne 	_AMXCONext
.8222					_AMXCONotZero:
.8222	b9 33 82	lda $8233,y			lda 	ExtraOpcode+1,y 		; get new opcode
.8225	80 cb		bra $81f2			bra 	_AMXOutputCode 			; and assemble it
.8227					_AMXCONext:
.8227	c8		iny				iny
.8228	c8		iny				iny
.8229	c8		iny				iny
.822a	b9 32 82	lda $8232,y			lda 	ExtraOpcode+0,y 		; end of table
.822d	d0 dd		bne $820c			bne 	_AMXCheckOddities
.822f					_AMXCOFail:
.822f	7a		ply				ply
.8230	18		clc				clc
.8231	60		rts				rts
.8232					ExtraOpcode:
>8232	40 6c 01					.byte $40,$6c,AM_INDABS 	; jump
>8235	40 7c 02					.byte $40,$7C,AM_INDABSX 	; jump
>8238	a2 be 78					.byte $a2,$BE,AM_ABSY 		; ldx
>823b	a2 b6 80					.byte $a2,$B6,AM_ZEROY 		; ldx
>823e	82 96 80					.byte $82,$96,AM_ZEROY 		; stx
>8241	e2 1a 28					.byte $e2,$1a,AM_ACC 		; inc
>8244	c2 3a 28					.byte $c2,$3a,AM_ACC 		; dec
>8247	20 89 e0					.byte $20,$89,AM_IMMEDIATE 	; bit
>824a	60 9c 6c					.byte $60,$9c,AM_ABS 		; stz
>824d	60 9e 7c					.byte $60,$9e,AM_ABSX 		; stz
>8250	00						.byte $00

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/label.asm

.8251					LabelHere:
.8251	c8		iny				iny 								; skip .
.8252	a2 00		ldx #$00			ldx 	#0 							; get a term
.8254	20 47 98	jsr $9847			jsr 	EvaluateTerm
.8257	a5 50		lda $50				lda 	NSStatus 					; needs to be an integer reference.
.8259	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.825b	d0 22		bne $827f			bne 	_ALType 					; otherwise typing error
.825d	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy reference address to zTemp0
.825f	85 36		sta $36				sta 	zTemp0 						; (e.g. where we store the address)
.8261	b5 60		lda $60,x			lda 	NSMantissa1,x
.8263	85 37		sta $37				sta 	zTemp0+1
.8265	5a		phy				phy 								; copy address in (64k)
.8266	a0 01		ldy #$01			ldy 	#1
.8268	ad 1e 04	lda $041e			lda	 	AssemblerAddress
.826b	92 36		sta ($36)			sta 	(zTemp0)
.826d	ad 1f 04	lda $041f			lda	 	AssemblerAddress+1
.8270	91 36		sta ($36),y			sta 	(zTemp0),y
.8272	c8		iny				iny
.8273	a9 00		lda #$00			lda 	#0 							; zero the rest.
.8275	91 36		sta ($36),y			sta 	(zTemp0),y
.8277	c8		iny				iny
.8278	91 36		sta ($36),y			sta 	(zTemp0),y
.827a	c8		iny				iny
.827b	91 36		sta ($36),y			sta 	(zTemp0),y
.827d	7a		ply				ply
.827e	60		rts				rts
.827f					_ALType:
.827f	4c a8 9f	jmp $9fa8			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/operands.asm

.8282					TypeAndCalculateOperand:
.8282	b1 30		lda ($30),y			lda 	(codePtr),y
.8284	a2 28		ldx #$28			ldx 	#AM_ACC 					; ACC if : or EOL
.8286	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.8288	f0 5b		beq $82e5			beq 	_TACOExit
.828a	c9 80		cmp #$80			cmp 	#KWC_EOL
.828c	f0 57		beq $82e5			beq 	_TACOExit
.828e	c8		iny				iny
.828f	a2 e0		ldx #$e0			ldx 	#AM_IMMEDIATE
.8291	c9 23		cmp #$23			cmp 	#KWD_HASH 					; if hash, then immediate - constant.
.8293	f0 51		beq $82e6			beq 	CalculateOperand
.8295	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; if ( then check for indirection
.8297	f0 1f		beq $82b8			beq 	_TACOIndirect
.8299	88		dey				dey 								; undo get of first character
.829a	20 e6 82	jsr $82e6			jsr 	CalculateOperand 			; get operand
.829d	b1 30		lda ($30),y			lda 	(codePtr),y
.829f	a2 e4		ldx #$e4			ldx 	#AM_ZEROPAGE 				; if not, try zero page (then absolute)
.82a1	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.82a3	d0 40		bne $82e5			bne 	_TACOExit
.82a5	c8		iny				iny
.82a6	20 f0 82	jsr $82f0			jsr 	TACOCheckXY 				; extract X,Y or 0 (neither) from the variable.
.82a9	a2 f4		ldx #$f4			ldx 	#AM_ZEROX 					; check for X
.82ab	c9 58		cmp #$58			cmp 	#'X'
.82ad	f0 36		beq $82e5			beq 	_TACOExit
.82af	a2 80		ldx #$80			ldx 	#AM_ZEROY 					; check for Y
.82b1	c9 59		cmp #$59			cmp 	#'Y'
.82b3	f0 30		beq $82e5			beq 	_TACOExit
.82b5					_TACOSyntax:
.82b5	4c 9e 9f	jmp $9f9e			jmp 	SyntaxError
.82b8					_TACOIndirect:
.82b8	20 e6 82	jsr $82e6			jsr 	CalculateOperand 			; get the operand
.82bb	b1 30		lda ($30),y			lda 	(codePtr),y
.82bd	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if , then it must be ,X)
.82bf	f0 17		beq $82d8			beq 	_TACOIndX
.82c1	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket  			; otherwise must be ) or ),Y
.82c4	b1 30		lda ($30),y			lda 	(codePtr),y
.82c6	a2 d1		ldx #$d1			ldx 	#AM_IND
.82c8	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not comma then exit with (xx)
.82ca	d0 19		bne $82e5			bne 	_TACOExit
.82cc	c8		iny				iny
.82cd	20 f0 82	jsr $82f0			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.82d0	c9 59		cmp #$59			cmp 	#'Y' 						; check Y
.82d2	d0 e1		bne $82b5			bne 	_TACOSyntax
.82d4	a2 d0		ldx #$d0			ldx 	#AM_INDY
.82d6	80 0d		bra $82e5			bra 	_TACOExit
.82d8					_TACOIndX:
.82d8	c8		iny				iny
.82d9	20 f0 82	jsr $82f0			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.82dc	c9 58		cmp #$58			cmp 	#'X' 						; check X
.82de	d0 d5		bne $82b5			bne 	_TACOSyntax
.82e0	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket			; check )
.82e3	a2 c0		ldx #$c0			ldx 	#AM_INDX
.82e5					_TACOExit:
.82e5	60		rts				rts
.82e6					CalculateOperand:
.82e6	48		pha				pha
.82e7	da		phx				phx
.82e8	a2 00		ldx #$00			ldx 	#0 							; get 16 bit integer in Slot 0
.82ea	20 a0 9d	jsr $9da0			jsr 	Evaluate16BitInteger
.82ed	fa		plx				plx
.82ee	68		pla				pla
.82ef	60		rts				rts
.82f0					TACOCheckXY:
.82f0	b1 30		lda ($30),y			lda 	(codePtr),y
.82f2	29 c0		and #$c0			and 	#$C0 						; check it is an identifier reference.
.82f4	c9 40		cmp #$40			cmp 	#$40
.82f6	d0 21		bne $8319			bne 	_TCXYFail
.82f8	b1 30		lda ($30),y			lda 	(codePtr),y
.82fa	18		clc				clc
.82fb	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.82fd	85 37		sta $37				sta 	zTemp0+1
.82ff	c8		iny				iny
.8300	b1 30		lda ($30),y			lda 	(codePtr),y
.8302	c8		iny				iny
.8303	85 36		sta $36				sta 	zTemp0
.8305	5a		phy				phy 								; save position
.8306	a0 02		ldy #$02			ldy 	#2 							; type is integer ?
.8308	b1 36		lda ($36),y			lda 	(zTemp0),y
.830a	d0 0c		bne $8318			bne 	_TCXYPopFail
.830c	a0 08		ldy #$08			ldy 	#8 							; get first character, should have bit 7 set as also last.
.830e	b1 36		lda ($36),y			lda 	(zTemp0),y
.8310	c9 d8		cmp #$d8			cmp 	#'X'+$80 					; should be X or Y
.8312	f0 08		beq $831c			beq 	_TCXYFound
.8314	c9 d9		cmp #$d9			cmp 	#'Y'+$80
.8316	f0 04		beq $831c			beq 	_TCXYFound
.8318					_TCXYPopFail:
.8318	7a		ply				ply
.8319					_TCXYFail:
.8319	a9 00		lda #$00			lda 	#0
.831b	60		rts				rts
.831c					_TCXYFound:
.831c	7a		ply				ply 								; restore position
.831d	29 7f		and #$7f			and 	#$7F 						; throw bit 7
.831f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/backload.asm

.8320					BackloadProgram:
.8320	20 2e 8a	jsr $8a2e			jsr 	NewProgram 					; does the actual NEW.
.8323	a2 83		ldx #$83			ldx 	#_BLLoad >> 8
.8325	a9 6f		lda #$6f			lda 	#_BLLoad & $FF
.8327	20 52 8f	jsr $8f52			jsr 	PrintStringXA
.832a	a9 14		lda #$14			lda 	#SOURCE_ADDRESS >> 13 		; start page
.832c	8d 59 06	sta $0659			sta 	BackLoadPage
.832f	a9 00		lda #$00			lda 	#(($6000) & $FF)
.8331	8d 5a 06	sta $065a			sta 	0+BackLoadPointer
.8334	a9 60		lda #$60			lda 	#(($6000) >> 8)
.8336	8d 5b 06	sta $065b			sta 	1+BackLoadPointer
.8339	a9 ff		lda #$ff			lda 	#$FF
.833b	8d fa ff	sta $fffa			sta 	$FFFA
.833e					_BPLoop:
.833e	a2 ff		ldx #$ff			ldx 	#$FF
.8340	20 84 83	jsr $8384			jsr 	BLReadByte 					; read a byte
.8343	c9 00		cmp #$00			cmp 	#0
.8345	f0 21		beq $8368			beq 	_BPExit 					; if 0 exit
.8347	30 1f		bmi $8368			bmi 	_BPExit 					; if -ve exit
.8349					_BPCopy:
.8349	e8		inx				inx  								; copy byte into the lineBuffer
.834a	9d 2a 05	sta $052a,x			sta 	lineBuffer,x
.834d	9e 2b 05	stz $052b,x			stz 	lineBuffer+1,x
.8350	20 84 83	jsr $8384			jsr 	BLReadByte 					; read next byte
.8353	30 0a		bmi $835f			bmi 	_BPEndLine 					; -ve = EOL
.8355	c9 09		cmp #$09			cmp 	#9 							; handle TAB, make it space.
.8357	d0 02		bne $835b			bne 	_BPNotTab
.8359	a9 20		lda #$20			lda 	#' '
.835b					_BPNotTab:
.835b	c9 20		cmp #$20			cmp 	#' ' 						; < ' ' = EOL
.835d	b0 ea		bcs $8349			bcs 	_BPCopy 					; until a control character, should be 13 received.
.835f					_BPEndLine:
.835f	20 21 80	jsr $8021			jsr 	TKTokeniseLine 				; tokenise the line.
.8362	ea		nop				nop
.8363	20 b2 83	jsr $83b2			jsr 	EditProgramCode
.8366	80 d6		bra $833e			bra 	_BPLoop
.8368					_BPExit:
.8368	9c fa ff	stz $fffa			stz 	$FFFA
.836b	20 6d 84	jsr $846d			jsr 	ClearCommand 				; clear variables etc.
.836e	60		rts				rts
.836f					_BLLoad:
>836f	4c 6f 61 64 69 6e 67 20				.text 	"Loading from Memory",13,0
>8377	66 72 6f 6d 20 4d 65 6d 6f 72 79 0d 00
.8384					BLReadByte:
.8384	da		phx				phx
.8385	a6 0b		ldx $0b				ldx 	8+3 						; save current mapping for $6000 in X
.8387	ad 59 06	lda $0659			lda 	BackLoadPage	 			; set current page
.838a	85 0b		sta $0b				sta 	8+3
.838c	ad 5a 06	lda $065a			lda 	BackLoadPointer 			; copy pointer to zTemp0
.838f	85 36		sta $36				sta 	zTemp0
.8391	ad 5b 06	lda $065b			lda 	BackLoadPointer+1
.8394	85 37		sta $37				sta 	zTemp0+1
.8396	b2 36		lda ($36)			lda 	(zTemp0) 					; read next byte
.8398	ee 5a 06	inc $065a			inc 	BackLoadPointer 			; bump pointer
.839b	d0 0f		bne $83ac			bne 	_BLNoCarry
.839d	ee 5b 06	inc $065b			inc 	BackLoadPointer+1
.83a0	10 0a		bpl $83ac			bpl 	_BLNoCarry 					; need a new page
.83a2	48		pha				pha
.83a3	a9 60		lda #$60			lda 	#$60 						; reset pointer
.83a5	8d 5b 06	sta $065b			sta 	BackLoadPointer+1
.83a8	ee 59 06	inc $0659			inc 	BackLoadPage 				; next page from source.
.83ab	68		pla				pla
.83ac					_BLNoCarry:
.83ac	86 0b		stx $0b				stx 	8+3 						; restore mapping, then X.
.83ae	fa		plx				plx
.83af	c9 00		cmp #$00			cmp 	#0
.83b1	60		rts				rts
.0659					BackLoadPage:
>0659							.fill  	1
.065a					BackLoadPointer:
>065a							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/editor.asm

.83b2					EditProgramCode:
.83b2	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; try to find the line.
.83b5	ae 2c 04	ldx $042c			ldx 	TokenLineNumber+1
.83b8	20 9c a5	jsr $a59c			jsr 	MemorySearch
.83bb	90 05		bcc $83c2			bcc 	_EPCNoDelete 				; reached the end : don't delete
.83bd	d0 03		bne $83c2			bne 	_EPCNoDelete 				; found slot but didn't match : no delete
.83bf	20 c1 a4	jsr $a4c1			jsr 	MemoryDeleteLine 			; delete the line
.83c2					_EPCNoDelete:
.83c2	ad 2d 04	lda $042d			lda 	TokenBuffer 				; buffer empty - we just want to delete a line.
.83c5	c9 80		cmp #$80			cmp 	#KWC_EOL
.83c7	f0 0d		beq $83d6			beq 	_EPCNoInsert
.83c9	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; find the line - it cannot exist as we've just deleted it.
.83cc	ae 2c 04	ldx $042c			ldx 	TokenLineNumber+1 			; so this can't fail, it returns some point in the code.
.83cf	20 9c a5	jsr $a59c			jsr 	MemorySearch
.83d2	18		clc				clc 								; insert at this point.
.83d3	20 f8 a4	jsr $a4f8			jsr 	MemoryInsertLine 			; insert the line
.83d6					_EPCNoInsert:
.83d6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/warmstart.asm

.83d7					WarmStart:
.83d7	a2 ff		ldx #$ff			ldx 	#$FF
.83d9	9a		txs				txs
.83da	a9 85		lda #$85			lda 	#CLICommandLine+$80 		; set console colour whatever the current colour is.
.83dc	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.83df	20 12 80	jsr $8012			jsr 	EXTInputLine 				; get line to lineBuffer
.83e2	20 21 80	jsr $8021			jsr 	TKTokeniseLine 				; tokenise the line
.83e5	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; line number <> 0
.83e8	0d 2c 04	ora $042c			ora 	TokenLineNumber+1
.83eb	d0 17		bne $8404			bne 	_WSEditCode 				; if so,edit code.
.83ed	9c 2a 04	stz $042a			stz 	TokenOffset 				; zero the "offset", meaning it only runs one line.
.83f0	a9 2a		lda #$2a			lda 	#((TokenOffset) & $FF)
.83f2	85 30		sta $30				sta 	codePtr
.83f4	a9 04		lda #$04			lda 	#((TokenOffset) >> 8)
.83f6	85 31		sta $31				sta 	codePtr+1
.83f8	ad 2d 04	lda $042d			lda 	TokenBuffer 				; nothing to run
.83fb	c9 80		cmp #$80			cmp 	#KWC_EOL
.83fd	f0 d8		beq $83d7			beq 	WarmStart
.83ff	20 81 8b	jsr $8b81			jsr 	RUNCodePointerLine 			; execute that line.
.8402	80 d3		bra $83d7			bra 	WarmStart
.8404					_WSEditCode:
.8404	20 b2 83	jsr $83b2			jsr 	EditProgramCode 			; edit the program code
.8407	20 6d 84	jsr $846d			jsr 	ClearCommand 				; clear all variables etc.
.840a	80 cb		bra $83d7			bra 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assemble.asm

.840c					AssembleCommand:
.840c	a2 00		ldx #$00			ldx 	#0
.840e	20 a0 9d	jsr $9da0			jsr 	Evaluate16BitInteger 		; start address
.8411	a5 58		lda $58				lda 	NSMantissa0
.8413	8d 1e 04	sta $041e			sta 	AssemblerAddress
.8416	a5 60		lda $60				lda 	NSMantissa1
.8418	8d 1f 04	sta $041f			sta 	AssemblerAddress+1
.841b	20 e8 8e	jsr $8ee8			jsr 	CheckComma
.841e	20 bb 9d	jsr $9dbb			jsr 	Evaluate8BitInteger 		; options 0-3
.8421	a5 58		lda $58				lda 	NSMantissa0
.8423	8d 20 04	sta $0420			sta 	AssemblerControl
.8426	60		rts				rts
.8427	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assert.asm

.8428					AssertCommand:
.8428	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.842a	20 8d 9d	jsr $9d8d			jsr 	EvaluateInteger 			; the assert test
.842d	20 42 9e	jsr $9e42			jsr 	NSMIsZero 					; exit if result is non zero.
.8430	d0 05		bne $8437			bne 	_ACExit
.8432	a9 0a		lda #$0a		lda	#10
.8434	4c f9 8e	jmp $8ef9		jmp	ErrorHandler
.8437					_ACExit:
.8437	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/call.asm

.8438					CallCommand:
.8438	a2 00		ldx #$00			ldx 	#0 							; get the routine address to level 0
.843a	20 a0 9d	jsr $9da0			jsr 	Evaluate16BitInteger
.843d					_CCClear
.843d	e8		inx				inx  								; clear 1,2 and 3 (for A X Y)
.843e	20 20 9e	jsr $9e20			jsr 	NSMSetZero 					; these are optional sequentially.
.8441	e0 04		cpx #$04			cpx 	#4
.8443	d0 f8		bne $843d			bne 	_CCClear
.8445	a2 00		ldx #$00			ldx 	#0 							; and keep trying while there are more values.
.8447					_CCCParam:
.8447	b1 30		lda ($30),y			lda 	(codePtr),y
.8449	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.844b	d0 09		bne $8456			bne 	_CCCRun6502
.844d	c8		iny				iny 								; skip comma
.844e	e8		inx				inx	 								; next level
.844f	20 bb 9d	jsr $9dbb			jsr 	Evaluate8BitInteger 		; get A/X/Y
.8452	e0 03		cpx #$03			cpx 	#3
.8454	90 f1		bcc $8447			bcc 	_CCCParam 					; done all 3 ?
.8456					_CCCRun6502:
.8456	5a		phy				phy 								; save position
.8457	a5 60		lda $60				lda 	NSMantissa1 				; put address in zTemp0
.8459	85 37		sta $37				sta 	zTemp0+1
.845b	a5 58		lda $58				lda 	NSMantissa0
.845d	85 36		sta $36				sta 	zTemp0
.845f	a5 59		lda $59				lda 	NSMantissa0+1 				; get registers into A X Y
.8461	a6 5a		ldx $5a				ldx 	NSMantissa0+2
.8463	a4 5b		ldy $5b				ldy 	NSMantissa0+3
.8465	20 6a 84	jsr $846a			jsr 	_CCCZTemp0 					; call zTemp0
.8468	7a		ply				ply 								; restore position and exit
.8469	60		rts				rts
.846a					_CCCZTemp0:
.846a	6c 36 00	jmp ($0036)			jmp 	(zTemp0)

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/clear.asm

.846d					ClearCommand:
.846d	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.846f	85 36		sta $36				sta 	0+zTemp0
.8471	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.8473	85 37		sta $37				sta 	1+zTemp0
.8475					_ClearZeroLoop:
.8475	b2 36		lda ($36)			lda 	(zTemp0) 					; end of variables if offset is zero.
.8477	f0 24		beq $849d			beq 	_ClearZeroEnd
.8479	a0 03		ldy #$03			ldy 	#3 							; erase the variables
.847b	a9 00		lda #$00			lda 	#0 							; set all the data to zero.
.847d					_ClearOneVariable:
.847d	91 36		sta ($36),y			sta 	(zTemp0),y
.847f	c8		iny				iny
.8480	c0 08		cpy #$08			cpy 	#8
.8482	d0 f9		bne $847d			bne 	_ClearOneVariable
.8484	a0 02		ldy #$02			ldy 	#2 							; has it been marked procedure
.8486	b1 36		lda ($36),y			lda 	(zTemp0),y
.8488	c9 18		cmp #$18			cmp 	#NSTProcedure
.848a	d0 04		bne $8490			bne 	_ClearNotProcedure
.848c	a9 04		lda #$04			lda 	#NSTInteger+NSBIsArray 		; if so set it back to an integer array
.848e	91 36		sta ($36),y			sta 	(zTemp0),y 					; will be fixed on the pre-run scan.
.8490					_ClearNotProcedure:
.8490	18		clc				clc 								; go to the next variable
.8491	b2 36		lda ($36)			lda 	(zTemp0) 					; offset to next, add to zTemp0
.8493	65 36		adc $36				adc 	zTemp0
.8495	85 36		sta $36				sta 	zTemp0
.8497	90 dc		bcc $8475			bcc 	_ClearZeroLoop
.8499	e6 37		inc $37				inc 	zTemp0+1
.849b	80 d8		bra $8475			bra 	_ClearZeroLoop
.849d					_ClearZeroEnd:
.849d	18		clc				clc
.849e	a5 36		lda $36				lda 	zTemp0
.84a0	69 01		adc #$01			adc 	#1
.84a2	8d 0c 04	sta $040c			sta 	lowMemPtr
.84a5	a5 37		lda $37				lda 	zTemp0+1
.84a7	69 00		adc #$00			adc 	#0
.84a9	8d 0d 04	sta $040d			sta 	lowMemPtr+1
.84ac	20 28 a7	jsr $a728			jsr 	StackReset
.84af	20 8e a7	jsr $a78e			jsr 	StringSystemInitialise
.84b2	20 e9 8d	jsr $8de9			jsr 	ProcedureScan
.84b5	20 30 8b	jsr $8b30			jsr 	Command_Restore
.84b8	9c 1e 04	stz $041e			stz 	AssemblerAddress
.84bb	9c 1f 04	stz $041f			stz 	AssemblerAddress+1
.84be	9c 20 04	stz $0420			stz 	AssemblerControl
.84c1	20 33 9a	jsr $9a33			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.84c4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/cls.asm

.84c5					ClearScreen:
.84c5	5a		phy				phy
.84c6	a9 0c		lda #$0c			lda 	#12 						; char code 12 clears the screen.
.84c8	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.84cb	7a		ply				ply
.84cc	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/data.asm

.84cd					Command_Data:
.84cd	a9 3a		lda #$3a			lda 	#KWD_COLON 					; advance to colon/EOL, e.g. ignore anything till then.
.84cf	a2 80		ldx #$80			ldx 	#KWC_EOL
.84d1	20 3b 8e	jsr $8e3b			jsr 	ScanForward
.84d4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dim.asm

.84d5					DimCommand:
.84d5	b1 30		lda ($30),y			lda 	(codePtr),y
.84d7	29 c0		and #$c0			and 	#$C0
.84d9	c9 40		cmp #$40			cmp 	#$40
.84db	d0 7a		bne $8557			bne 	_DCSyntax 				; n o, error.
.84dd	b1 30		lda ($30),y			lda 	(codePtr),y
.84df	18		clc				clc
.84e0	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.84e2	85 3f		sta $3f				sta 	zaTemp+1
.84e4	c8		iny				iny
.84e5	b1 30		lda ($30),y			lda 	(codePtr),y
.84e7	c8		iny				iny
.84e8	85 3e		sta $3e				sta 	zaTemp
.84ea	5a		phy				phy
.84eb	a0 02		ldy #$02			ldy 	#2 						; read type byte
.84ed	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84ef	29 18		and #$18			and 	#NSBTypeMask 			; check it's not a procedure
.84f1	c9 18		cmp #$18			cmp 	#NSTProcedure
.84f3	f0 62		beq $8557			beq 	_DCSyntax
.84f5	b1 3e		lda ($3e),y			lda 	(zaTemp),y 				; check it's an array
.84f7	29 04		and #$04			and 	#NSBIsArray
.84f9	f0 64		beq $855f			beq 	_DCType
.84fb	a0 04		ldy #$04			ldy 	#4 						; check not already defined
.84fd	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84ff	d0 59		bne $855a			bne 	_DCRedefine
.8501	7a		ply				ply
.8502	20 62 85	jsr $8562			jsr 	_DCGetSize 				; get array size, check it.
.8505	5a		phy				phy
.8506	a0 05		ldy #$05			ldy 	#5 						; store in first array size slot
.8508	91 3e		sta ($3e),y			sta 	(zaTemp),y 				; second will be zero.
.850a	7a		ply				ply 							; is there a second (e.g. ,x)
.850b	b1 30		lda ($30),y			lda 	(codePtr),y
.850d	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.850f	d0 0a		bne $851b			bne 	_DCOneDimension
.8511	c8		iny				iny 							; skip comma
.8512	20 62 85	jsr $8562			jsr 	_DCGetSize 				; get 2nd array size
.8515	5a		phy				phy
.8516	a0 06		ldy #$06			ldy 	#6 						; store in 2nd array size
.8518	91 3e		sta ($3e),y			sta 	(zaTemp),y
.851a	7a		ply				ply
.851b					_DCOneDimension:
.851b	5a		phy				phy 							; save position
.851c	a0 05		ldy #$05			ldy 	#5 						; dimensions + 1 in AX (as zero based)
.851e	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8520	aa		tax				tax
.8521	c8		iny				iny
.8522	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8524	e8		inx				inx 							; bump them.
.8525	1a		inc a				inc 	a
.8526	20 cb 9d	jsr $9dcb			jsr 	Multiply8x8 			; work out the total number of elements -> zTemp0
.8529	a5 37		lda $37				lda 	zTemp0+1 				; don't allow more than 8192 elements whatever
.852b	29 e0		and #$e0			and 	#$E0
.852d	d0 23		bne $8552			bne 	_DCSize
.852f	a0 02		ldy #$02			ldy 	#2 						; get base type
.8531	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8533	20 70 85	jsr $8570			jsr 	ScaleByBaseType 		; scale by base type
.8536	a5 36		lda $36				lda 	zTemp0
.8538	a6 37		ldx $37				ldx 	zTemp0+1
.853a	20 f5 99	jsr $99f5			jsr 	AllocateXABytes 		; allocate memory
.853d	a0 03		ldy #$03			ldy 	#3 						; copy into the address.
.853f	91 3e		sta ($3e),y			sta 	(zaTemp),y
.8541	c8		iny				iny
.8542	8a		txa				txa
.8543	91 3e		sta ($3e),y			sta 	(zaTemp),y
.8545	7a		ply				ply 							; get position back
.8546	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket 		; check )
.8549	b1 30		lda ($30),y			lda 	(codePtr),y
.854b	c8		iny				iny 							; consume in case
.854c	c9 2c		cmp #$2c			cmp 	#KWD_COMMA		 		; if so do another DIM.
.854e	f0 85		beq $84d5			beq 	DimCommand
.8550	88		dey				dey 							; undo consume
.8551	60		rts				rts
.8552					_DCSize:
.8552	a9 16		lda #$16		lda	#22
.8554	4c f9 8e	jmp $8ef9		jmp	ErrorHandler
.8557					_DCSyntax:
.8557	4c 9e 9f	jmp $9f9e			jmp 	SyntaxError
.855a					_DCRedefine:
.855a	a9 15		lda #$15		lda	#21
.855c	4c f9 8e	jmp $8ef9		jmp	ErrorHandler
.855f					_DCType:
.855f	4c a8 9f	jmp $9fa8			jmp 	TypeError
.8562					_DCGetSize:
.8562	a2 00		ldx #$00			ldx 	#0 						; get first index.
.8564	20 bb 9d	jsr $9dbb			jsr 	Evaluate8BitInteger 	; get array dimension
.8567	c9 00		cmp #$00			cmp 	#0 						; must be 1-254
.8569	f0 e7		beq $8552			beq 	_DCSize
.856b	c9 fe		cmp #$fe			cmp 	#254
.856d	f0 e3		beq $8552			beq 	_DCSize
.856f	60		rts				rts
.8570					ScaleByBaseType:
.8570	29 10		and #$10			and 	#NSBIsString 			; is it string
.8572	d0 19		bne $858d			bne 	_SBBTString
.8574	a5 37		lda $37				lda 	zTemp0+1 				; push value on stack
.8576	48		pha				pha
.8577	a5 36		lda $36				lda 	zTemp0
.8579	48		pha				pha
.857a	06 36		asl $36				asl 	zTemp0 					; x 2
.857c	26 37		rol $37				rol 	zTemp0+1
.857e	06 36		asl $36				asl 	zTemp0 					; x 4
.8580	26 37		rol $37				rol 	zTemp0+1
.8582	68		pla				pla 							; add stacked value = x 5
.8583	65 36		adc $36				adc 	zTemp0
.8585	85 36		sta $36				sta 	zTemp0
.8587	68		pla				pla
.8588	65 37		adc $37				adc 	zTemp0+1
.858a	85 37		sta $37				sta 	zTemp0+1
.858c	60		rts				rts
.858d					_SBBTString:
.858d	06 36		asl $36				asl 	zTemp0
.858f	26 37		rol $37				rol 	zTemp0+1
.8591	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dokepoke.asm

.8592					PokeCommand:
.8592	18		clc				clc
.8593	80 01		bra $8596			bra 	DPCommand
.8595					DokeCommand:
.8595	38		sec				sec
.8596					DPCommand:
.8596	08		php				php									; save on stack, CS = Doke, CC = Poke
.8597	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.8599	20 a0 9d	jsr $9da0			jsr		Evaluate16BitInteger 		; address
.859c	20 e8 8e	jsr $8ee8			jsr 	CheckComma
.859f	e8		inx				inx
.85a0	20 a0 9d	jsr $9da0			jsr		Evaluate16BitInteger 		; data
.85a3	a5 58		lda $58				lda 	NSMantissa0 				; copy address
.85a5	85 36		sta $36				sta 	zTemp0
.85a7	a5 60		lda $60				lda 	NSMantissa1
.85a9	85 37		sta $37				sta 	zTemp0+1
.85ab	a5 59		lda $59				lda 	NSMantissa0+1 				; low byte
.85ad	92 36		sta ($36)			sta 	(zTemp0)
.85af	28		plp				plp 								; done if POKE
.85b0	90 08		bcc $85ba			bcc 	_DPExit
.85b2	5a		phy				phy 								; write high byte out.
.85b3	a0 01		ldy #$01			ldy 	#1
.85b5	a5 61		lda $61				lda 	NSMantissa1+1
.85b7	91 36		sta ($36),y			sta 	(zTemp0),y
.85b9	7a		ply				ply
.85ba					_DPExit:
.85ba	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/end.asm

.85bb					EndCommand:
.85bb	4c d7 83	jmp $83d7			jmp 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/for.asm

.85be					ForCommand:
.85be	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; allocate 18 bytes on the return stack (see above).
.85c0	20 c2 a6	jsr $a6c2			jsr 	StackOpen
.85c3	a2 00		ldx #$00			ldx 	#0
.85c5	20 47 98	jsr $9847			jsr 	EvaluateTerm
.85c8	b5 50		lda $50,x			lda 	NSStatus,x
.85ca	c9 20		cmp #$20			cmp 	#NSBIsReference+NSTInteger 	; do we have an integer 4 byte reference.
.85cc	d0 47		bne $8615			bne		_FCError
.85ce	a9 3d		lda #$3d			lda 	#KWD_EQUAL 					; =
.85d0	20 f0 8e	jsr $8ef0			jsr 	CheckNextA
.85d3	e8		inx				inx
.85d4	20 8d 9d	jsr $9d8d			jsr 	EvaluateInteger 			; <from> in +1
.85d7	b1 30		lda ($30),y			lda 	(codePtr),y
.85d9	c8		iny				iny 								; consume it
.85da	48		pha				pha 								; save on stack for later
.85db	c9 b7		cmp #$b7			cmp 	#KWD_DOWNTO
.85dd	f0 04		beq $85e3			beq 	_FCNoSyntax
.85df	c9 d2		cmp #$d2			cmp 	#KWD_TO
.85e1	d0 35		bne $8618			bne 	_FCSyntaxError
.85e3					_FCNoSyntax:
.85e3	e8		inx				inx
.85e4	20 8d 9d	jsr $9d8d			jsr 	EvaluateInteger
.85e7	20 07 a7	jsr $a707			jsr 	STKSaveCodePosition 		; save loop back position
.85ea	68		pla				pla 								; restore DOWNTO or TO
.85eb	5a		phy				phy 								; save Y on the stack
.85ec	49 b7		eor #$b7			eor 	#KWD_DOWNTO 				; 0 if DOWNTO, #0 if TO
.85ee	f0 02		beq $85f2			beq 	_FCNotDownTo
.85f0	a9 02		lda #$02			lda 	#2
.85f2					_FCNotDownTo:
.85f2	3a		dec a				dec 	a 							; 255 if DOWNTO, 1 if TO
.85f3	a0 10		ldy #$10			ldy 	#16
.85f5	91 34		sta ($34),y			sta 	(basicStack),y 				; copy that out to the Basic Stack.
.85f7	a0 06		ldy #$06			ldy 	#6 							; this is the address of the loop variable.
.85f9	a5 58		lda $58				lda 	NSMantissa0
.85fb	91 34		sta ($34),y			sta 	(basicStack),y
.85fd	a5 60		lda $60				lda 	NSMantissa1
.85ff	c8		iny				iny
.8600	91 34		sta ($34),y			sta 	(basicStack),y
.8602	a0 08		ldy #$08			ldy 	#8 							; set initial index value
.8604	a2 01		ldx #$01			ldx 	#1
.8606	20 1b 86	jsr $861b			jsr 	FCIntegerToStack
.8609	a0 0c		ldy #$0c			ldy 	#12 						; set the terminal value
.860b	a2 02		ldx #$02			ldx 	#2
.860d	20 1b 86	jsr $861b			jsr 	FCIntegerToStack
.8610	20 36 86	jsr $8636			jsr 	CopyIndexToReference
.8613	7a		ply				ply 								; restore position
.8614	60		rts				rts
.8615					_FCError:
.8615	4c a8 9f	jmp $9fa8			jmp 	TypeError
.8618					_FCSyntaxError:
.8618	4c 9e 9f	jmp $9f9e			jmp 	SyntaxError
.861b					FCIntegerToStack:
.861b	34 50		bit $50,x			bit 	NSStatus,x 					; is the value negative
.861d	10 03		bpl $8622			bpl	 	_FCNotNegative
.861f	20 e9 9d	jsr $9de9			jsr 	NSMNegateMantissa 			; if so 2's complement the mantissa
.8622					_FCNotNegative:
.8622	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy out to the basic stack
.8624	91 34		sta ($34),y			sta 	(basicStack),y
.8626	c8		iny				iny
.8627	b5 60		lda $60,x			lda 	NSMantissa1,x
.8629	91 34		sta ($34),y			sta 	(basicStack),y
.862b	c8		iny				iny
.862c	b5 68		lda $68,x			lda 	NSMantissa2,x
.862e	91 34		sta ($34),y			sta 	(basicStack),y
.8630	c8		iny				iny
.8631	b5 70		lda $70,x			lda 	NSMantissa3,x
.8633	91 34		sta ($34),y			sta 	(basicStack),y
.8635	60		rts				rts
.8636					CopyIndexToReference:
.8636	5a		phy				phy
.8637	a0 06		ldy #$06			ldy 	#6 							; copy address-8 to write to zTemp0
.8639	38		sec				sec 								; (because we copy from offset 8)
.863a	b1 34		lda ($34),y			lda 	(basicStack),y
.863c	e9 08		sbc #$08			sbc 	#8
.863e	85 36		sta $36				sta 	zTemp0
.8640	c8		iny				iny
.8641	b1 34		lda ($34),y			lda 	(basicStack),y
.8643	e9 00		sbc #$00			sbc 	#0
.8645	85 37		sta $37				sta 	zTemp0+1
.8647	a2 04		ldx #$04			ldx 	#4 							; this is the copy counter/
.8649	a0 0b		ldy #$0b			ldy 	#8+3 		 				; the MSB of the mantissa
.864b	b1 34		lda ($34),y			lda 	(basicStack),y
.864d	0a		asl a				asl 	a 							; into carry
.864e	a0 08		ldy #$08			ldy 	#8 							; where to copy from.
.8650	90 14		bcc $8666			bcc 	_CITRNormal
.8652	38		sec				sec
.8653					_CITRNegative:
.8653	a9 00		lda #$00			lda 	#0
.8655	f1 34		sbc ($34),y			sbc 	(basicStack),y
.8657	91 36		sta ($36),y			sta 	(zTemp0),y
.8659	c8		iny				iny
.865a	ca		dex				dex
.865b	d0 f6		bne $8653			bne 	_CITRNegative
.865d	88		dey				dey 								; look at MSB of mantissa
.865e	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set the MSB as negative packed.
.8660	09 80		ora #$80			ora 	#$80
.8662	91 36		sta ($36),y			sta 	(zTemp0),y
.8664	7a		ply				ply
.8665	60		rts				rts
.8666					_CITRNormal:
.8666	b1 34		lda ($34),y			lda 	(basicStack),y 				; copy without negation.
.8668	91 36		sta ($36),y			sta 	(zTemp0),y
.866a	c8		iny				iny
.866b	ca		dex				dex
.866c	d0 f8		bne $8666			bne 	_CITRNormal
.866e	7a		ply				ply 								; and exit.
.866f	60		rts				rts
.8670					NextCommand:
.8670	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; check FOR is TOS
.8672	a2 11		ldx #$11			ldx 	#ERRID_FOR 					; this error
.8674	20 ef a6	jsr $a6ef			jsr 	StackCheckFrame
.8677	5a		phy				phy
.8678	a0 10		ldy #$10			ldy 	#16 						; get the step count
.867a	b1 34		lda ($34),y			lda 	(basicStack),y
.867c	85 36		sta $36				sta 	zTemp0 						; this is the sign extend
.867e	30 02		bmi $8682			bmi 	_NCStepNeg
.8680	64 36		stz $36				stz 	zTemp0 						; which is 0 or 255
.8682					_NCStepNeg:
.8682	a0 08		ldy #$08			ldy 	#8 							; offset to bump
.8684	a2 04		ldx #$04			ldx 	#4 							; count to bump
.8686	18		clc				clc
.8687					_NCBump:
.8687	71 34		adc ($34),y			adc 	(basicStack),y 				; add it
.8689	91 34		sta ($34),y			sta 	(basicStack),y
.868b	a5 36		lda $36				lda 	zTemp0 						; get sign extend for next time.
.868d	c8		iny				iny 								; next byte
.868e	ca		dex				dex 								; do four times
.868f	d0 f6		bne $8687			bne 	_NCBump
.8691	20 36 86	jsr $8636			jsr		CopyIndexToReference		; copy it to the reference variable.
.8694	a0 10		ldy #$10			ldy 	#16 						; get step count again
.8696	b1 34		lda ($34),y			lda 	(basicStack),y
.8698	0a		asl a				asl 	a 							; sign bit to carry
.8699	a9 0c		lda #$0c			lda 	#12 						; offset of LHS = terminal offset
.869b	85 38		sta $38				sta 	zTemp1
.869d	90 02		bcc $86a1			bcc 	_NCCompRev 					; use if step is +ve
.869f	a9 08		lda #$08			lda 	#8 							; now the LHS = index value
.86a1					_NCCompRev:
.86a1	85 38		sta $38				sta 	zTemp1 						; so zTemp0 is the index for LHS
.86a3	49 04		eor #$04			eor 	#(8^12) 					; and zTemp0+1 is the index for RHS
.86a5	85 39		sta $39				sta 	zTemp1+1
.86a7	a2 04		ldx #$04			ldx 	#4 							; bytes to compare
.86a9	38		sec				sec
.86aa					_NCCompare:
.86aa	a4 38		ldy $38				ldy 	zTemp1 						; do compare using the two indices
.86ac	b1 34		lda ($34),y			lda 	(basicStack),y
.86ae	a4 39		ldy $39				ldy 	zTemp1+1
.86b0	f1 34		sbc ($34),y			sbc 	(basicStack),y
.86b2	e6 38		inc $38				inc 	zTemp1 						; bump the indices (inc,dex do not change C or V)
.86b4	e6 39		inc $39				inc 	zTemp1+1
.86b6	ca		dex				dex 								; do it 4 times.
.86b7	d0 f1		bne $86aa			bne 	_NCCompare
.86b9	50 02		bvc $86bd			bvc 	_NCNoOverflow 				; convert to signed comparison
.86bb	49 80		eor #$80			eor 	#$80
.86bd					_NCNoOverflow:
.86bd	7a		ply				ply 								; restore Y position
.86be	0a		asl a				asl 	a 							; is bit 7 set.
.86bf	90 04		bcc $86c5			bcc 	_NCLoopback 				; if no , >= so loop back
.86c1	20 e1 a6	jsr $a6e1			jsr 	StackClose 					; exit the loop
.86c4	60		rts				rts
.86c5					_NCLoopBack:
.86c5	20 18 a7	jsr $a718			jsr 	STKLoadCodePosition 		; loop back
.86c8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/gosub.asm

.86c9					Command_GOSUB:
.86c9	a2 00		ldx #$00			ldx 	#0
.86cb	20 a0 9d	jsr $9da0			jsr 	Evaluate16BitInteger 		; line number in Stack.0
.86ce	a9 e3		lda #$e3			lda 	#STK_GOSUB+3
.86d0	20 c2 a6	jsr $a6c2			jsr 	StackOpen 					; create frame
.86d3	20 07 a7	jsr $a707			jsr 	STKSaveCodePosition 		; save current position
.86d6	4c ec 86	jmp $86ec			jmp 	GotoStackX
.86d9					Command_RETURN:
.86d9	a9 e0		lda #$e0			lda 	#STK_GOSUB 					; check TOS is this
.86db	a2 0e		ldx #$0e			ldx 	#ERRID_GOSUB 				; this error
.86dd	20 ef a6	jsr $a6ef			jsr 	StackCheckFrame
.86e0	20 18 a7	jsr $a718			jsr 	STKLoadCodePosition 		; restore code position
.86e3	20 e1 a6	jsr $a6e1			jsr 	StackClose
.86e6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/goto.asm

.86e7					GotoCommand:
.86e7	a2 00		ldx #$00			ldx 	#0 							; GOTO where
.86e9	20 a0 9d	jsr $9da0			jsr 	Evaluate16BitInteger
.86ec					GotoStackX:
.86ec	b5 60		lda $60,x			lda  	NSMantissa1,x 				; put line # in XA. I'll keep this even though
.86ee	48		pha				pha 								; it is slightly inefficient, just in cases.
.86ef	b5 58		lda $58,x			lda 	NSMantissa0,x
.86f1	fa		plx				plx
.86f2	20 9c a5	jsr $a59c			jsr 	MemorySearch 				; transfer to line number AX.
.86f5	90 05		bcc $86fc			bcc 	_GotoError 					; not found, off end.
.86f7	d0 03		bne $86fc			bne 	_GotoError 					; not found exactly
.86f9	4c 7a 8b	jmp $8b7a			jmp 	RunNewLine 					; and go straight to new line code.
.86fc					_GotoError:
.86fc	a9 0d		lda #$0d		lda	#13
.86fe	4c f9 8e	jmp $8ef9		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/if.asm

.8701					IfCommand:
.8701	a2 00		ldx #$00			ldx 	#0 							; Get the if test.
.8703	20 6e 9d	jsr $9d6e			jsr 	EvaluateNumber
.8706	b1 30		lda ($30),y			lda 	(codePtr),y
.8708	c9 aa		cmp #$aa			cmp 	#KWD_THEN  					; could be THEN <stuff>
.870a	d0 0a		bne $8716			bne 	_IFStructured 				; we still support it.
.870c	c8		iny				iny 								; consume THEN
.870d	20 42 9e	jsr $9e42			jsr 	NSMIsZero 					; is it zero
.8710	f0 01		beq $8713			beq 	_IfFail 					; if fail, go to next line
.8712	60		rts				rts 								; if THEN just continue
.8713					_IfFail:
.8713	4c 62 8b	jmp $8b62			jmp 	EOLCommand
.8716					_IfStructured:
.8716	20 42 9e	jsr $9e42			jsr 	NSMIsZero 					; is it zero
.8719	d0 07		bne $8722			bne 	_IfExit 					; if not, then continue normally.
.871b	a9 b8		lda #$b8			lda 	#KWD_ELSE 					; look for else/endif
.871d	a2 a7		ldx #$a7			ldx 	#KWD_ENDIF
.871f	20 3b 8e	jsr $8e3b			jsr 	ScanForward 				; and run from there
.8722					_IfExit:
.8722	60		rts				rts
.8723					ElseCode:
.8723	a9 a7		lda #$a7			lda 	#KWD_ENDIF 					; else is only run after the if clause succeeds
.8725	aa		tax				tax 								; so just go to the structure exit
.8726	20 3b 8e	jsr $8e3b			jsr 	ScanForward
.8729	60		rts				rts
.872a					EndIf:
.872a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/inputprint.asm

.872b					Command_Input:
.872b	a9 ff		lda #$ff			lda 	#$FF 						; set input flag
.872d	8d 28 04	sta $0428			sta 	IsInputFlag
.8730	80 03		bra $8735			bra 	Command_IP_Main
.8732					Command_Print:
.8732	9c 28 04	stz $0428			stz 	IsInputFlag 				; clear input flag
.8735					Command_IP_Main:
.8735	18		clc				clc 								; carry being clear means last print wasn't comma/semicolon
.8736					_CPLoop:
.8736	08		php				php 								; save last action flag
.8737	b1 30		lda ($30),y			lda 	(codePtr),y
.8739	c9 80		cmp #$80			cmp  	#KWC_EOL 					; end of line or colon, exit now.
.873b	f0 54		beq $8791			beq 	_CPExit
.873d	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.873f	f0 50		beq $8791			beq 	_CPExit
.8741	68		pla				pla 								; throw last action flag
.8742	b1 30		lda ($30),y			lda 	(codePtr),y
.8744	c8		iny				iny
.8745	c9 3b		cmp #$3b			cmp 	#KWD_SEMICOLON				; is it a semicolon
.8747	f0 45		beq $878e			beq 	_CPContinueWithSameLine
.8749	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; comma
.874b	f0 3c		beq $8789			beq 	_CPTab
.874d	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; apostrophe (new line)
.874f	f0 34		beq $8785			beq 	_CPNewLine
.8751	88		dey				dey 								; undo the get.
.8752	20 fb 93	jsr $93fb			jsr 	EvaluateExpressionAt0 		; evaluate expression at 0.
.8755	b5 50		lda $50,x			lda 	NSStatus,x 					; read the status
.8757	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.8759	f0 0d		beq $8768			beq 	_CPIsValue 					; no, display it.
.875b	ad 28 04	lda $0428			lda 	IsInputFlag 				; if print, dereference and print.
.875e	f0 05		beq $8765			beq 	_CPIsPrint 					; otherwise display.
.8760	20 9a 87	jsr $879a			jsr 	CIInputValue 				; input a value to the reference
.8763	80 20		bra $8785			bra 	_CPNewLine
.8765					_CPIsPrint:
.8765	20 c0 96	jsr $96c0			jsr 	Dereference 				; dereference if required.
.8768					_CPIsValue:
.8768	b5 50		lda $50,x			lda 	NSStatus,x 					; is it a number
.876a	29 10		and #$10			and 	#NSBIsString
.876c	f0 09		beq $8777			beq 	_CPNumber
.876e	a6 60		ldx $60				ldx 	NSMantissa1 				; string, print the text.
.8770	a5 58		lda $58				lda 	NSMantissa0
.8772	20 fd 87	jsr $87fd			jsr 	CPPrintStringXA
.8775	80 be		bra $8735			bra 	Command_IP_Main 			; loop round clearing carry so NL if end
.8777					_CPNumber:
.8777	a9 05		lda #$05			lda 	#5 							; maximum decimals
.8779	20 55 9c	jsr $9c55			jsr 	ConvertNumberToString 		; convert to string (in unary str$() function)
.877c	a2 06		ldx #$06			ldx 	#DecimalBuffer >> 8
.877e	a9 49		lda #$49			lda 	#DecimalBuffer & $FF
.8780	20 fd 87	jsr $87fd			jsr 	CPPrintStringXA 			; print it.
.8783	80 b0		bra $8735			bra 	Command_IP_Main				; loop round clearing carry so NL if end
.8785					_CPNewLine:
.8785	a9 0d		lda #$0d			lda 	#13
.8787	80 02		bra $878b			bra 	_CPPrintChar
.8789					_CPTab:
.8789	a9 09		lda #$09			lda 	#9 							; print TAB
.878b					_CPPrintChar:
.878b	20 10 88	jsr $8810			jsr 	CPPrintVector
.878e					_CPContinueWithSameLine:
.878e	38		sec				sec 								; loop round with carry set, which
.878f	80 a5		bra $8736			bra 	_CPLoop 					; will inhibit final CR
.8791					_CPExit:
.8791	28		plp				plp 								; get last action flag
.8792	b0 05		bcs $8799			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.8794	a9 0d		lda #$0d			lda 	#13 						; print new line
.8796	20 10 88	jsr $8810			jsr 	CPPrintVector
.8799					_CPExit2:
.8799	60		rts				rts
.879a					CIInputValue:
.879a	a2 00		ldx #$00			ldx 	#0 							; input a line.
.879c					_CIInputLine:
.879c	20 13 88	jsr $8813			jsr 	CPInputVector 				; get key
.879f	c9 0d		cmp #$0d			cmp 	#13 						; 13 = End
.87a1	f0 1f		beq $87c2			beq 	_CIHaveValue
.87a3	c9 08		cmp #$08			cmp 	#8 							; 8 = BS
.87a5	f0 11		beq $87b8			beq 	_CIBackspace
.87a7	c9 20		cmp #$20			cmp 	#32 						; ignore other control characters
.87a9	90 f1		bcc $879c			bcc 	_CIInputLine
.87ab	e0 50		cpx #$50			cpx 	#80 						; max length
.87ad	b0 ed		bcs $879c			bcs 	_CIInputLine
.87af	9d 2a 05	sta $052a,x			sta 	lineBuffer,x
.87b2	e8		inx				inx
.87b3	20 10 88	jsr $8810			jsr 	CPPrintVector 				; echo it.
.87b6	80 e4		bra $879c			bra 	_CIInputLine
.87b8					_CIBackSpace:
.87b8	e0 00		cpx #$00			cpx 	#0 							; nothing to delete
.87ba	f0 e0		beq $879c			beq 	_CIInputLine
.87bc	20 10 88	jsr $8810			jsr 	CPPrintVector 				; echo it.
.87bf	ca		dex				dex
.87c0	80 da		bra $879c			bra 	_CIInputLine
.87c2					_CIHaveValue:
.87c2	9e 2a 05	stz $052a,x			stz 	LineBuffer,x 				; ASCIIZ string now in line buffer.
.87c5	a5 50		lda $50				lda 	NSStatus 					; was it a string assignment
.87c7	29 10		and #$10			and 	#NSBIsString
.87c9	f0 17		beq $87e2			beq 	_CIAssignNumber 			; assign a number
.87cb	a2 01		ldx #$01			ldx 	#1
.87cd	a9 2a		lda #$2a			lda 	#lineBuffer & $FF 			; set up to point to new string
.87cf	95 58		sta $58,x			sta 	NSMantissa0,x
.87d1	a9 05		lda #$05			lda 	#lineBuffer >> 8
.87d3	95 60		sta $60,x			sta 	NSMantissa1,x
.87d5	74 68		stz $68,x			stz 	NSMantissa2,x
.87d7	74 70		stz $70,x			stz 	NSMantissa3,x
.87d9	a9 10		lda #$10			lda 	#NSBIsString 				; so it becomes a string value
.87db	95 50		sta $50,x			sta  	NSStatus,x
.87dd	ca		dex				dex 								; X = 0
.87de	20 4f 88	jsr $884f			jsr 	AssignVariable
.87e1	60		rts				rts
.87e2					_CIAssignNumber:
.87e2	a9 2a		lda #$2a			lda 	#lineBuffer & $FF 			; set up to point to new string
.87e4	85 36		sta $36				sta 	zTemp0
.87e6	a9 05		lda #$05			lda 	#lineBuffer >> 8
.87e8	85 37		sta $37				sta 	zTemp0+1
.87ea	a2 01		ldx #$01			ldx 	#1 							; put in slot 1
.87ec	20 d7 9b	jsr $9bd7			jsr 	ValEvaluateZTemp0 			; use the VAL() code
.87ef	90 07		bcc $87f8			bcc 	_CIIsOkay
.87f1	a9 3f		lda #$3f			lda 	#"?" 						; error ?
.87f3	20 10 88	jsr $8810			jsr 	CPPrintVector
.87f6	80 a2		bra $879a			bra 	CIInputValue
.87f8					_CIIsOkay:
.87f8	ca		dex				dex 								; X = 0
.87f9	20 4f 88	jsr $884f			jsr 	AssignVariable
.87fc	60		rts				rts
.87fd					CPPrintStringXA:
.87fd	5a		phy				phy
.87fe	86 37		stx $37				stx 	zTemp0+1
.8800	85 36		sta $36				sta 	zTemp0
.8802	a0 00		ldy #$00			ldy 	#0
.8804					_PSXALoop:
.8804	b1 36		lda ($36),y			lda 	(zTemp0),y
.8806	f0 06		beq $880e			beq 	_PSXAExit
.8808	20 10 88	jsr $8810			jsr 	CPPrintVector
.880b	c8		iny				iny
.880c	80 f6		bra $8804			bra 	_PSXALoop
.880e					_PSXAExit:
.880e	7a		ply				ply
.880f	60		rts				rts
.8810					CPPrintVector:
.8810	4c 03 80	jmp $8003			jmp 	EXTPrintCharacter
.8813					CPInputVector:
.8813	4c 09 80	jmp $8009			jmp 	EXTInputSingleCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/let.asm

.8816					LetCommand:
.8816	a2 00		ldx #$00			ldx 	#0
.8818	b1 30		lda ($30),y			lda 	(codePtr),y
.881a	c9 10		cmp #$10			cmp 	#KWD_AT
.881c	d0 14		bne $8832			bne 	_LCStandard
.881e	c8		iny				iny 								; skip equal
.881f	20 47 98	jsr $9847			jsr 	EvaluateTerm 				; get a number (the address of the reference)
.8822	20 c0 96	jsr $96c0			jsr 	Dereference 				; dereference it to a value
.8825	b5 50		lda $50,x			lda 	NSStatus,x 					; check integer
.8827	49 20		eor #$20			eor 	#NSBIsReference	 			; toggle reference
.8829	95 50		sta $50,x			sta 	NSStatus,x
.882b	29 20		and #$20			and 	#NSBIsReference 			; if it is now a reference, continue
.882d	d0 0f		bne $883e			bne 	_LCMain
.882f	4c a8 9f	jmp $9fa8			jmp 	TypeError 					; was a reference before.
.8832					_LCStandard:
.8832	ad e5 93	lda $93e5			lda 	PrecedenceLevel+"*"			; precedence > this
.8835	20 ff 93	jsr $93ff			jsr 	EvaluateExpressionAtPrecedence
.8838	b5 50		lda $50,x			lda 	NSStatus,x 					; is it a reference to an array marked as procedure ?
.883a	c9 38		cmp #$38			cmp		#NSTProcedure+NSBIsReference
.883c	f0 0e		beq $884c			beq 	_LetGoProc 					; it's a procedure call.
.883e					_LCMain:
.883e	a9 3d		lda #$3d			lda 	#"=" 						; check =
.8840	20 f0 8e	jsr $8ef0			jsr 	CheckNextA
.8843	e8		inx				inx 								; RHS
.8844	20 65 9d	jsr $9d65			jsr 	EvaluateValue
.8847	ca		dex				dex
.8848	20 4f 88	jsr $884f			jsr 	AssignVariable
.884b	60		rts				rts
.884c					_LetGoProc:
.884c	4c 38 8a	jmp $8a38			jmp 	CallProcedure
.884f					AssignVariable:
.884f	b5 50		lda $50,x			lda 	NSStatus,x 					; check the string/number type bits match
.8851	48		pha				pha 								; save a copy
.8852	55 51		eor $51,x			eor 	NSStatus+1,x
.8854	29 10		and #$10			and 	#NSBIsString
.8856	d0 0b		bne $8863			bne 	_ASError
.8858	68		pla				pla 								; get back
.8859	29 10		and #$10			and 	#NSBIsString 				; check type
.885b	d0 03		bne $8860			bne 	_ASString
.885d	4c fe 95	jmp $95fe			jmp 	AssignNumber
.8860					_ASString:
.8860	4c 5c 96	jmp $965c			jmp 	AssignString
.8863					_ASError:
.8863	4c a8 9f	jmp $9fa8			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/list.asm

.8866					Command_List:
.8866	9c 26 04	stz $0426			stz 	listIndent 					; reset indent.
.8869	b1 30		lda ($30),y			lda 	(codePtr),y
.886b	29 c0		and #$c0			and 	#$C0 				 		; if so, we are list procedure() which is a seperate block
.886d	c9 40		cmp #$40			cmp 	#$40  						; of code.
.886f	f0 6e		beq $88df			beq 	_CLListProcedure
.8871	64 5c		stz $5c				stz		NSMantissa0+4				; set the lower (slot 4) to 0 and upper (slot 7) to $FFFF
.8873	64 64		stz $64				stz 	NSMantissa1+4 				; these are the default top and bottom.
.8875	a9 ff		lda #$ff			lda 	#$FF
.8877	85 5f		sta $5f				sta 	NSMantissa0+7
.8879	85 67		sta $67				sta 	NSMantissa1+7
.887b	b1 30		lda ($30),y			lda 	(codePtr),y
.887d	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.887f	f0 1a		beq $889b			beq 	_CLSecond
.8881	20 5c 89	jsr $895c			jsr 	CLIsDigit 					; if not digit, list all
.8884	b0 20		bcs $88a6			bcs 	_CLStart
.8886	a2 04		ldx #$04			ldx 	#4 							; get 1st range into slot 4
.8888	20 a0 9d	jsr $9da0			jsr 	Evaluate16BitInteger
.888b	b1 30		lda ($30),y			lda 	(codePtr),y
.888d	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.888f	f0 0a		beq $889b			beq 	_CLSecond 					; if so go get it
.8891	a5 5c		lda $5c				lda 	NSMantissa0+4 				; copy 4->7
.8893	85 5f		sta $5f				sta 	NSMantissa0+7
.8895	a5 64		lda $64				lda 	NSMantissa1+4
.8897	85 67		sta $67				sta 	NSMantissa1+7
.8899	80 0b		bra $88a6			bra 	_CLStart
.889b					_CLSecond:
.889b	c8		iny				iny 								; consume comma
.889c	20 5c 89	jsr $895c			jsr 	CLIsDigit 					; digit found
.889f	b0 05		bcs $88a6			bcs 	_CLStart 					; if not, continue listing
.88a1	a2 07		ldx #$07			ldx 	#7 							; load 2nd range into slot 7
.88a3	20 a0 9d	jsr $9da0			jsr 	Evaluate16BitInteger
.88a6					_CLStart
.88a6	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.88a8	85 30		sta $30				sta 	codePtr
.88aa	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.88ac	85 31		sta $31				sta 	codePtr+1
.88ae					_CLLoop:
.88ae	20 0c 80	jsr $800c			jsr 	EXTBreakCheck 				; break check here, as we want the option of breaking out of long lists.
.88b1	f0 27		beq $88da			beq 	_CLBreak
.88b3	b2 30		lda ($30)			lda 	(codePtr)
.88b5	f0 20		beq $88d7			beq 	_CLExit
.88b7	a2 04		ldx #$04			ldx 	#4 							; check range every time, line numbers aren't in order.
.88b9	20 4b 89	jsr $894b			jsr 	CLCompareLineNo
.88bc	90 0c		bcc $88ca			bcc 	_CLNext
.88be	a2 07		ldx #$07			ldx 	#7
.88c0	20 4b 89	jsr $894b			jsr 	CLCompareLineNo
.88c3	f0 02		beq $88c7			beq 	_CLDoThisOne
.88c5	b0 03		bcs $88ca			bcs 	_CLNext
.88c7					_CLDoThisOne:
.88c7	20 38 89	jsr $8938			jsr 	CLListOneLine 				; routine to list the current line.
.88ca					_CLNext:
.88ca	18		clc				clc
.88cb	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.88cd	65 30		adc $30				adc 	codePtr
.88cf	85 30		sta $30				sta 	codePtr
.88d1	90 02		bcc $88d5			bcc 	_CREExit
.88d3	e6 31		inc $31				inc 	codePtr+1 					; carry
.88d5					_CREExit:
.88d5	80 d7		bra $88ae			bra 	_CLLoop
.88d7					_CLExit:
.88d7	4c d7 83	jmp $83d7			jmp 	WarmStart
.88da					_CLBreak:
.88da	a9 01		lda #$01		lda	#1
.88dc	4c f9 8e	jmp $8ef9		jmp	ErrorHandler
.88df					_CLListProcedure:
.88df	b1 30		lda ($30),y			lda 	(codePtr),y
.88e1	85 38		sta $38				sta 	zTemp1
.88e3	c8		iny				iny
.88e4	b1 30		lda ($30),y			lda 	(codePtr),y
.88e6	85 39		sta $39				sta 	zTemp1+1
.88e8	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.88ea	85 30		sta $30				sta 	codePtr
.88ec	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.88ee	85 31		sta $31				sta 	codePtr+1
.88f0					_CLLPSearch:
.88f0	b2 30		lda ($30)			lda 	(codePtr)
.88f2	c9 00		cmp #$00			cmp 	#0 							; if zero, end
.88f4	f0 e1		beq $88d7			beq 	_CLExit
.88f6	a0 03		ldy #$03			ldy 	#3 							; check if PROC something
.88f8	b1 30		lda ($30),y			lda 	(codePtr),y
.88fa	c9 a4		cmp #$a4			cmp 	#KWD_PROC
.88fc	d0 0e		bne $890c			bne 	_CLLPNext
.88fe	c8		iny				iny 								; check if PROC this.
.88ff	b1 30		lda ($30),y			lda 	(codePtr),y
.8901	c5 38		cmp $38				cmp 	zTemp1 						; does it match ?
.8903	d0 07		bne $890c			bne 	_CLLPNext
.8905	c8		iny				iny
.8906	b1 30		lda ($30),y			lda 	(codePtr),y
.8908	c5 39		cmp $39				cmp 	zTemp1+1
.890a	f0 0d		beq $8919			beq 	_CLLPFound
.890c					_CLLPNext:
.890c	18		clc				clc
.890d	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.890f	65 30		adc $30				adc 	codePtr
.8911	85 30		sta $30				sta 	codePtr
.8913	90 02		bcc $8917			bcc 	_CREExit
.8915	e6 31		inc $31				inc 	codePtr+1 					; carry
.8917					_CREExit:
.8917	80 d7		bra $88f0			bra 	_CLLPSearch
.8919					_CLLPFound:
.8919	b2 30		lda ($30)			lda 	(codePtr)
.891b	f0 ba		beq $88d7			beq 	_CLExit
.891d	a0 03		ldy #$03			ldy 	#3 							; get first keyword
.891f	b1 30		lda ($30),y			lda 	(codePtr),y
.8921	48		pha				pha
.8922	20 38 89	jsr $8938			jsr 	CLListOneLine 				; list line and go forward
.8925	18		clc				clc
.8926	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8928	65 30		adc $30				adc 	codePtr
.892a	85 30		sta $30				sta 	codePtr
.892c	90 02		bcc $8930			bcc 	_CREExit
.892e	e6 31		inc $31				inc 	codePtr+1 					; carry
.8930					_CREExit:
.8930	68		pla				pla 								; reached ENDPROC ?
.8931	c9 a8		cmp #$a8			cmp 	#KWD_ENDPROC
.8933	d0 e4		bne $8919			bne 	_CLLPFound
.8935	4c d7 83	jmp $83d7			jmp 	WarmStart
.8938					CLListOneLine:
.8938	20 9e 8e	jsr $8e9e			jsr 	ScanGetCurrentLineStep 		; get indent adjust.
.893b	20 1e 80	jsr $801e			jsr 	TKListConvertLine 			; convert line into token Buffer
.893e	a2 04		ldx #$04			ldx 	#(tokenBuffer >> 8) 		; print that line
.8940	a9 2d		lda #$2d			lda 	#(tokenBuffer & $FF)
.8942	20 52 8f	jsr $8f52			jsr 	PrintStringXA
.8945	a9 0d		lda #$0d			lda 	#13 						; new line
.8947	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.894a	60		rts				rts
.894b					CLCompareLineNo:
.894b	38		sec				sec
.894c	a0 01		ldy #$01			ldy 	#1
.894e	b1 30		lda ($30),y			lda 	(codePtr),y
.8950	f5 58		sbc $58,x			sbc 	NSMantissa0,x
.8952	85 36		sta $36				sta 	zTemp0
.8954	c8		iny				iny
.8955	b1 30		lda ($30),y			lda 	(codePtr),y
.8957	f5 60		sbc $60,x			sbc 	NSMantissa1,x
.8959	05 36		ora $36				ora 	zTemp0
.895b	60		rts				rts
.895c					CLIsDigit:
.895c	b1 30		lda ($30),y			lda 	(codePtr),y
.895e	c9 30		cmp #$30			cmp 	#"0"
.8960	90 03		bcc $8965			bcc	 	_CLIDExitFalse
.8962	c9 3a		cmp #$3a			cmp 	#"9"+1
.8964	60		rts				rts
.8965					_CLIDExitFalse:
.8965	38		sec				sec
.8966	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/local.asm

.8967					Command_LOCAL:
.8967	a2 00		ldx #$00			ldx 	#0 							; at level 0
.8969	20 75 89	jsr $8975			jsr 	LocaliseNextTerm 			; convert term to a local.
.896c	b1 30		lda ($30),y			lda 	(codePtr),y
.896e	c8		iny				iny
.896f	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8971	f0 f4		beq $8967			beq 	Command_LOCAL 				; if so, localise another variable.
.8973	88		dey				dey 								; unpick pre-get
.8974	60		rts				rts
.8975					LocaliseNextTerm:
.8975	20 47 98	jsr $9847			jsr 	EvaluateTerm 				; evaluate the term
.8978	b5 50		lda $50,x			lda 	NSStatus,x
.897a	29 20		and #$20			and 	#NSBIsReference 			; check it is a reference, must be a variable.
.897c	f0 5c		beq $89da			beq		_LNTError
.897e	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address of variable to zTemp0
.8980	85 36		sta $36				sta 	zTemp0
.8982	b5 60		lda $60,x			lda 	NSMantissa1,x
.8984	85 37		sta $37				sta  	zTemp0+1
.8986	b5 50		lda $50,x			lda 	NSStatus,x 					; figure out what it is.
.8988	29 10		and #$10			and 	#NSBIsString
.898a	d0 1e		bne $89aa			bne 	_LNTPushString
.898c	5a		phy				phy
.898d	a0 00		ldy #$00			ldy 	#0 							; push 0 to 4 inclusive, the number values, on the stack, and zero them as you go.
.898f					_LNTPushNumLoop:
.898f	b1 36		lda ($36),y			lda		(zTemp0),y
.8991	20 a1 a6	jsr $a6a1			jsr 	StackPushByte
.8994	c8		iny				iny
.8995	c0 05		cpy #$05			cpy 	#5
.8997	d0 f6		bne $898f			bne 	_LNTPushNumLoop
.8999	a5 36		lda $36				lda 	zTemp0 						; push the actual target address to write on the stack
.899b	20 a1 a6	jsr $a6a1			jsr 	StackPushByte
.899e	a5 37		lda $37				lda 	zTemp0+1
.89a0	20 a1 a6	jsr $a6a1			jsr 	StackPushByte
.89a3	a9 01		lda #$01			lda 	#STK_LOCALN 				; push local-number marker.
.89a5	20 a1 a6	jsr $a6a1			jsr 	StackPushByte
.89a8	7a		ply				ply
.89a9	60		rts				rts
.89aa					_LNTPushString:
.89aa	5a		phy				phy
.89ab	b2 36		lda ($36)			lda 	(zTemp0) 					; put address of string in zTemp1
.89ad	85 38		sta $38				sta 	zTemp1
.89af	a0 01		ldy #$01			ldy 	#1
.89b1	b1 36		lda ($36),y			lda 	(zTemp0),y
.89b3	85 39		sta $39				sta 	zTemp1+1
.89b5	a0 00		ldy #$00			ldy 	#0 							; output string
.89b7	c9 00		cmp #$00			cmp 	#0 							; if not assigned string
.89b9	f0 0a		beq $89c5			beq 	_LNTStringOut
.89bb					_LNTPushStrLoop:
.89bb	b1 38		lda ($38),y			lda 	(zTemp1),y
.89bd	f0 06		beq $89c5			beq 	_LNTStringOut
.89bf	20 a1 a6	jsr $a6a1			jsr 	StackPushByte
.89c2	c8		iny				iny
.89c3	80 f6		bra $89bb			bra 	_LNTPushStrLoop
.89c5					_LNTStringOut:
.89c5	98		tya				tya									; output length (chars written).
.89c6	20 a1 a6	jsr $a6a1			jsr 	StackPushByte
.89c9	b5 58		lda $58,x			lda 	NSMantissa0,x 				; output address of the string record *not* the string itself
.89cb	20 a1 a6	jsr $a6a1			jsr 	StackPushByte
.89ce	b5 60		lda $60,x			lda 	NSMantissa1,x
.89d0	20 a1 a6	jsr $a6a1			jsr 	StackPushByte
.89d3	a9 02		lda #$02			lda 	#STK_LOCALS 				; push local-string marker.
.89d5	20 a1 a6	jsr $a6a1			jsr 	StackPushByte
.89d8	7a		ply				ply
.89d9	60		rts				rts
.89da					_LNTError:
.89da	4c 9e 9f	jmp $9f9e			jmp 	SyntaxError
.89dd					LocalPopValue:
.89dd	20 b9 a6	jsr $a6b9			jsr 	StackPopByte
.89e0	c9 01		cmp #$01			cmp 	#STK_LOCALN 				; if not local-N
.89e2	d0 17		bne $89fb			bne 	_LPVString
.89e4	20 b9 a6	jsr $a6b9			jsr 	StackPopByte 				; address
.89e7	85 37		sta $37				sta 	zTemp0+1
.89e9	20 b9 a6	jsr $a6b9			jsr 	StackPopByte
.89ec	85 36		sta $36				sta 	zTemp0
.89ee	5a		phy				phy
.89ef	a0 04		ldy #$04			ldy 	#4 							; copy back
.89f1					_LPVNumberCopy:
.89f1	20 b9 a6	jsr $a6b9			jsr 	StackPopByte
.89f4	91 36		sta ($36),y			sta 	(zTemp0),y
.89f6	88		dey				dey
.89f7	10 f8		bpl $89f1			bpl 	_LPVNumberCopy
.89f9	7a		ply				ply 								; and complete
.89fa	60		rts				rts
.89fb					_LPVString:
.89fb	20 b9 a6	jsr $a6b9			jsr 	StackPopByte 				; address of record copied to zTemp0
.89fe	85 37		sta $37				sta 	zTemp0+1
.8a00	20 b9 a6	jsr $a6b9			jsr 	StackPopByte
.8a03	85 36		sta $36				sta 	zTemp0
.8a05	5a		phy				phy
.8a06	b2 36		lda ($36)			lda 	(zTemp0) 					; address to write string to copied to zTemp1
.8a08	85 38		sta $38				sta 	zTemp1
.8a0a	a0 01		ldy #$01			ldy 	#1
.8a0c	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a0e	85 39		sta $39				sta 	zTemp1+1
.8a10	20 b9 a6	jsr $a6b9			jsr 	StackPopByte 				; # chars to get => y
.8a13	a8		tay				tay
.8a14	a5 39		lda $39				lda 	zTemp1+1 					; if no target (e.g. was "" originally) exit
.8a16	f0 0e		beq $8a26			beq 	_LPVStringCopied
.8a18	a9 00		lda #$00			lda 	#0 							; NULL on end
.8a1a	91 38		sta ($38),y			sta 	(zTemp1),y
.8a1c					_LPVStringCopy:
.8a1c	88		dey				dey
.8a1d	30 07		bmi $8a26			bmi 	_LPVStringCopied
.8a1f	20 b9 a6	jsr $a6b9			jsr 	StackPopByte
.8a22	91 38		sta ($38),y			sta 	(zTemp1),y
.8a24	80 f6		bra $8a1c			bra 	_LPVStringCopy
.8a26					_LPVStringCopied:
.8a26	fa		plx				plx
.8a27	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/new.asm

.8a28					NewCommand:
.8a28	20 2e 8a	jsr $8a2e			jsr 	NewProgram 					; does the actual NEW.
.8a2b	4c d7 83	jmp $83d7			jmp 	WarmStart 					; and warm starts straight away.
.8a2e					NewProgram:
.8a2e	20 7e a5	jsr $a57e			jsr 	MemoryNew
.8a31	9c 00 10	stz $1000			stz 	VariableSpace 				; erase all variables.
.8a34	20 6d 84	jsr $846d			jsr 	ClearCommand 				; clear everything.
.8a37	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/procedure.asm

=2					ParameterStackPos = 2
.8a38					CallProcedure:
.8a38	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start storing parameters at 2.
.8a3a	b1 30		lda ($30),y			lda 	(codePtr),y
.8a3c	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.8a3e	f0 0c		beq $8a4c			beq 	_CPEndParam
.8a40					_CPParamLoop:
.8a40	20 65 9d	jsr $9d65			jsr 	EvaluateValue 				; get parameter onto stack
.8a43	e8		inx				inx 								; bump next stack
.8a44	b1 30		lda ($30),y			lda 	(codePtr),y
.8a46	c8		iny				iny
.8a47	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if comma, go back and try again.
.8a49	f0 f5		beq $8a40			beq 	_CPParamLoop
.8a4b	88		dey				dey 								; unpick.
.8a4c					_CPEndParam:
.8a4c	8e 16 04	stx $0416			stx 	LastParameter 				; save the last parameters index.
.8a4f	c8		iny				iny									; skip right bracket
.8a50	a9 b3		lda #$b3			lda 	#STK_PROC+3 				; allocate 6 bytes on the return stack.
.8a52	20 c2 a6	jsr $a6c2			jsr 	StackOpen
.8a55	20 07 a7	jsr $a707			jsr 	STKSaveCodePosition 		; save loop position
.8a58	a5 58		lda $58				lda 	NSMantissa0 				; copy variable (e.g. procedure) address to zTemp0
.8a5a	85 36		sta $36				sta 	zTemp0 						; this is the DATA not the RECORD
.8a5c	a5 60		lda $60				lda 	NSMantissa1
.8a5e	85 37		sta $37				sta 	zTemp0+1
.8a60	a0 01		ldy #$01			ldy 	#1 							; copy code address back.
.8a62	b2 36		lda ($36)			lda 	(zTemp0)
.8a64	85 30		sta $30				sta 	safePtr
.8a66	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a68	85 31		sta $31				sta 	safePtr+1
.8a6a	c8		iny				iny
.8a6b	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a6d	85 32		sta $32				sta 	safePtr+2
.8a6f	c8		iny				iny
.8a70	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a72	85 33		sta $33				sta 	safePtr+3
.8a74	c8		iny				iny 								; get Y offset -> Y
.8a75	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a77	a8		tay				tay
.8a78	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start position of parameters
.8a7a	ec 16 04	cpx $0416			cpx	 	LastParameter 				; check zero parameters at the start
.8a7d	f0 13		beq $8a92			beq 	_ParamExit 					; if so, exit.
.8a7f					_ParamExtract:
.8a7f	ca		dex				dex 								; put a local term on the level before
.8a80	20 75 89	jsr $8975			jsr 	LocaliseNextTerm			; also pushes original param value to basic stack
.8a83	20 4f 88	jsr $884f			jsr 	AssignVariable 				; assign stacked value to the variable.
.8a86	e8		inx				inx 								; advance to next parameter to do.
.8a87	e8		inx				inx
.8a88	ec 16 04	cpx $0416			cpx 	LastParameter 				; are we done ?
.8a8b	f0 05		beq $8a92			beq 	_ParamExit
.8a8d	20 e8 8e	jsr $8ee8			jsr 	CheckComma 					; comma seperating parameters
.8a90	80 ed		bra $8a7f			bra 	_ParamExtract
.8a92					_ParamExit:
.8a92	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket 			; check )
.8a95	60		rts				rts 								; and continue from here
.8a96					Command_ENDPROC:
.8a96	a9 b0		lda #$b0			lda 	#STK_PROC 					; check TOS is this
.8a98	a2 14		ldx #$14			ldx 	#ERRID_PROC
.8a9a	20 ef a6	jsr $a6ef			jsr 	StackCheckFrame
.8a9d	20 18 a7	jsr $a718			jsr 	STKLoadCodePosition 		; restore code position
.8aa0	20 e1 a6	jsr $a6e1			jsr 	StackClose
.8aa3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/read.asm

.8aa4					Command_Read:
.8aa4	a2 00		ldx #$00			ldx 	#0 							; evaluate the term which is the var/array element to assign
.8aa6	20 47 98	jsr $9847			jsr 	EvaluateTerm
.8aa9	b5 50		lda $50,x			lda 	NSStatus,x
.8aab	29 20		and #$20			and 	#NSBIsReference				; get status byte on stack, identifies int, float, string.
.8aad	f0 4f		beq $8afe			beq 	_CRSyntax 					; check reference (bit 0) fail if not a reference.
.8aaf	20 47 8b	jsr $8b47			jsr 	SwapDataCodePtrs 			; swap code and data
.8ab2	ad 1c 04	lda $041c			lda 	inDataStatement 			; if in a data statement, we don't need to search
.8ab5	d0 25		bne $8adc			bne 	_CRContinueData  			; forward for the next one.
.8ab7	b2 30		lda ($30)			lda 	(codePtr)
.8ab9	f0 1c		beq $8ad7			beq 	_CRNoData
.8abb					_CRKeepSearching:
.8abb	a9 b4		lda #$b4			lda 	#KWD_DATA 					; scan for instruction
.8abd	a2 80		ldx #$80			ldx 	#KWC_EOL
.8abf	20 3b 8e	jsr $8e3b			jsr 	ScanForward
.8ac2	c9 b4		cmp #$b4			cmp 	#KWD_DATA 					; found data ?
.8ac4	f0 16		beq $8adc			beq 	_CRHaveData 				; found it
.8ac6	18		clc				clc
.8ac7	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8ac9	65 30		adc $30				adc 	codePtr
.8acb	85 30		sta $30				sta 	codePtr
.8acd	90 02		bcc $8ad1			bcc 	_CREExit
.8acf	e6 31		inc $31				inc 	codePtr+1 					; carry
.8ad1					_CREExit:
.8ad1	a0 03		ldy #$03			ldy 	#3 							; start of line.
.8ad3	b2 30		lda ($30)			lda 	(codePtr)
.8ad5	d0 e4		bne $8abb			bne 	_CRKeepSearching
.8ad7					_CRNoData:
.8ad7	a9 0b		lda #$0b		lda	#11
.8ad9	4c f9 8e	jmp $8ef9		jmp	ErrorHandler
.8adc					_CRHaveData:
.8adc					_CRContinueData:
.8adc	a2 01		ldx #$01			ldx 	#1
.8ade	20 65 9d	jsr $9d65			jsr 	EvaluateValue 				; evaluate value into slot # 1
.8ae1	ca		dex				dex
.8ae2	20 4f 88	jsr $884f			jsr		AssignVariable 				; do the assignment
.8ae5	9c 1c 04	stz $041c			stz 	inDataStatement 			; clear in data flag
.8ae8	b1 30		lda ($30),y			lda 	(codePtr),y
.8aea	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not, end of data statement and exit
.8aec	d0 04		bne $8af2			bne 	_CRSwapBack
.8aee	c8		iny				iny 								; consume comma
.8aef	ee 1c 04	inc $041c			inc 	inDataStatement 			; set in data statement currently.
.8af2					_CRSwapBack:
.8af2	20 47 8b	jsr $8b47			jsr 	SwapDataCodePtrs			; swap them back.
.8af5	b1 30		lda ($30),y			lda 	(codePtr),y
.8af7	c8		iny				iny
.8af8	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8afa	f0 a8		beq $8aa4			beq 	Command_Read 				; if so go round again.
.8afc	88		dey				dey 								; unpick get.
.8afd	60		rts				rts
.8afe					_CRSyntax:
.8afe	4c 9e 9f	jmp $9f9e			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/rem.asm

.8b01					RemCommand:
.8b01	b1 30		lda ($30),y			lda 	(codePtr),y
.8b03	c9 ff		cmp #$ff			cmp 	#KWC_STRING
.8b05	d0 06		bne $8b0d			bne 	_RMExit
.8b07	c8		iny				iny 								; point to offset
.8b08	98		tya				tya 								; A = offset position
.8b09	38		sec				sec 								; add size +1 hence SEC
.8b0a	71 30		adc ($30),y			adc 	(codePtr),y
.8b0c	a8		tay				tay 								; make current position.
.8b0d					_RMExit:
.8b0d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/repeat.asm

.8b0e					Command_REPEAT:
.8b0e	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; allocate 6 bytes on the return stack.
.8b10	20 c2 a6	jsr $a6c2			jsr 	StackOpen
.8b13	20 07 a7	jsr $a707			jsr 	STKSaveCodePosition 		; save loop position
.8b16	60		rts				rts
.8b17					Command_UNTIL:
.8b17	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; check REPEAT is TOS
.8b19	a2 0f		ldx #$0f			ldx 	#ERRID_REPEAT 				; this error
.8b1b	20 ef a6	jsr $a6ef			jsr 	StackCheckFrame
.8b1e	a2 00		ldx #$00			ldx 	#0
.8b20	20 6e 9d	jsr $9d6e			jsr 	EvaluateNumber 				; work out the number
.8b23	20 42 9e	jsr $9e42			jsr 	NSMIsZero 					; check if zero
.8b26	f0 04		beq $8b2c			beq 	_CULoopBack 				; if so keep looping
.8b28	20 e1 a6	jsr $a6e1			jsr 	StackClose		 			; return
.8b2b	60		rts				rts
.8b2c					_CULoopBack:
.8b2c	20 18 a7	jsr $a718			jsr 	STKLoadCodePosition 		; loop back
.8b2f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/restore.asm

.8b30					Command_Restore:
.8b30	20 47 8b	jsr $8b47			jsr 	SwapDataCodePtrs 			; swap code and data
.8b33	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8b35	85 30		sta $30				sta 	codePtr
.8b37	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8b39	85 31		sta $31				sta 	codePtr+1
.8b3b	20 47 8b	jsr $8b47			jsr 	SwapDataCodePtrs 			; put them back
.8b3e	a9 03		lda #$03			lda 	#3 							; start at offset 3, e.g. first instruction of first line.
.8b40	8d 1b 04	sta $041b			sta 	dataPointer+4   			; (read checks not EOF)
.8b43	9c 1c 04	stz $041c			stz 	inDataStatement 			; not in data statement
.8b46	60		rts				rts
.8b47					SwapDataCodePtrs:
.8b47	da		phx				phx
.8b48	a2 03		ldx #$03			ldx 	#3 							; swap 32 bit code pointer over
.8b4a					_SDCPLoop:
.8b4a	b5 30		lda $30,x			lda 	safePtr,x
.8b4c	48		pha				pha
.8b4d	bd 17 04	lda $0417,x			lda 	dataPointer,x
.8b50	95 30		sta $30,x			sta 	safePtr,x
.8b52	68		pla				pla
.8b53	9d 17 04	sta $0417,x			sta 	dataPointer,x
.8b56	ca		dex				dex
.8b57	10 f1		bpl $8b4a			bpl 	_SDCPLoop
.8b59	ad 1b 04	lda $041b			lda 	dataPointer+4 				; swap Y position over.
.8b5c	8c 1b 04	sty $041b			sty 	dataPointer+4
.8b5f	a8		tay				tay
.8b60	fa		plx				plx
.8b61	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/run.asm

.8b62					EOLCommand:
.8b62	18		clc				clc
.8b63	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8b65	65 30		adc $30				adc 	codePtr
.8b67	85 30		sta $30				sta 	codePtr
.8b69	90 02		bcc $8b6d			bcc 	_CREExit
.8b6b	e6 31		inc $31				inc 	codePtr+1 					; carry
.8b6d					_CREExit:
.8b6d	80 0b		bra $8b7a			bra 	RunNewLine
.8b6f					CommandRUN:
.8b6f	20 6d 84	jsr $846d			jsr 	ClearCommand 				; clear variable/stacks/etc.
.8b72	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8b74	85 30		sta $30				sta 	codePtr
.8b76	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8b78	85 31		sta $31				sta 	codePtr+1
.8b7a					RUNNewLine:
.8b7a	b2 30		lda ($30)			lda 	(codePtr)
.8b7c	f0 7b		beq $8bf9			beq 	CRNoProgram         		; no then END.
.8b7e	a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack
.8b80	9a		txs				txs
.8b81					RUNCodePointerLine:
.8b81	a0 02		ldy #$02			ldy 	#2 							; start of program
.8b83					_CRIncMainLoop:
.8b83	0e 13 04	asl $0413			asl 	breakCheck 					; clears 1 time in 8
.8b86	d0 22		bne $8baa			bne 	_CRNoBreakCheck
.8b88	ce 13 04	dec $0413			dec	 	breakCheck 					; set it back to $FF
.8b8b	20 0c 80	jsr $800c			jsr 	EXTBreakCheck 				; break check
.8b8e	f0 64		beq $8bf4			beq 	_CRBreak
.8b90	a5 01		lda $01				lda 	1 							; save I/O 0
.8b92	48		pha				pha
.8b93	64 01		stz $01				stz 	1 							; access I/O Page 0
.8b95	38		sec				sec 								; calculate timer - LastTick
.8b96	ad 59 d6	lda $d659			lda 	$D659
.8b99	aa		tax				tax 								; saving timer in X
.8b9a	ed 5c 06	sbc $065c			sbc 	LastTick
.8b9d	c9 03		cmp #$03			cmp 	#3
.8b9f	90 06		bcc $8ba7			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.8ba1	8e 5c 06	stx $065c			stx 	LastTick 					; update last timer
.8ba4	20 4b 9e	jsr $9e4b			jsr 	TickHandler 							; go do the code.
.8ba7					_NoFireTick:
.8ba7	68		pla				pla 								; restore I/O 0
.8ba8	85 01		sta $01				sta 	1
.8baa					_CRNoBreakCheck:
.8baa	c8		iny				iny									; next token
.8bab					_CRMainLoop:
.8bab	9c 10 04	stz $0410			stz 	stringInitialised 			; clear the temporary string initialised flag.
.8bae	b1 30		lda ($30),y			lda 	(codePtr),y
.8bb0	10 10		bpl $8bc2			bpl 	_CRNotKeyword				; not a token.
.8bb2	c9 a2		cmp #$a2			cmp 	#KWC_LAST_UNARY+1 			; if after unary, legitimate command
.8bb4	b0 04		bcs $8bba			bcs 	_CRIsKeyword
.8bb6	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if unary, syntax error.
.8bb8	b0 34		bcs $8bee			bcs		_CRSyntaxError
.8bba					_CRIsKeyword:
.8bba	c8		iny				iny 								; consume command
.8bbb	0a		asl a				asl 	a 							; double losing the MSB which is '1' as tokens are $80-$FF
.8bbc	aa		tax				tax 								; put in X for vector jump
.8bbd	20 f1 8b	jsr $8bf1			jsr 	_CRCallVector0 				; call the vector - effectively jsr (vectortable,X)
.8bc0	80 e9		bra $8bab			bra 	_CRMainLoop 				; and loop round
.8bc2					_CRNotKeyword:
.8bc2	c9 3a		cmp #$3a			cmp 	#KWD_COLON 					; if a :, consume it and go round.
.8bc4	f0 bd		beq $8b83			beq 	_CRIncMainLoop
.8bc6	c9 40		cmp #$40			cmp 	#$40 						; variable/call reference
.8bc8	90 05		bcc $8bcf			bcc 	_CRNotVariable
.8bca					_CRGoLet:
.8bca	20 16 88	jsr $8816			jsr 	LetCommand
.8bcd	80 dc		bra $8bab			bra 	_CRMainLoop
.8bcf					_CRNotVariable:
.8bcf	c9 10		cmp #$10			cmp 	#KWD_AT 					; handle @
.8bd1	f0 f7		beq $8bca			beq 	_CRGoLet
.8bd3	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; handle ? !
.8bd5	f0 f3		beq $8bca			beq 	_CRGoLet
.8bd7	c9 21		cmp #$21			cmp 	#KWD_PLING
.8bd9	f0 ef		beq $8bca			beq 	_CRGoLet
.8bdb	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; handle ' (comment)
.8bdd	f0 09		beq $8be8			beq 	_CRGoRem
.8bdf	c9 2e		cmp #$2e			cmp 	#KWD_PERIOD 				; handle . (assembler label)
.8be1	d0 0b		bne $8bee			bne 	_CRSyntaxError
.8be3	20 51 82	jsr $8251			jsr 	LabelHere
.8be6	80 c3		bra $8bab			bra 	_CRMainLoop
.8be8					_CRGoRem:
.8be8	c8		iny				iny
.8be9	20 01 8b	jsr $8b01			jsr 	RemCommand
.8bec	80 bd		bra $8bab			bra 	_CRMainLoop
.8bee					_CRSyntaxError:
.8bee	4c 9e 9f	jmp $9f9e			jmp 	SyntaxError
.8bf1					_CRCallVector0:
.8bf1	7c 90 8c	jmp ($8c90,x)			jmp 	(VectorSet0,x)
.8bf4					_CRBreak:
.8bf4	a9 01		lda #$01		lda	#1
.8bf6	4c f9 8e	jmp $8ef9		jmp	ErrorHandler
.8bf9					CRNoProgram:
.8bf9	4c bb 85	jmp $85bb			jmp 	EndCommand
.8bfc					Shift1Command:
.8bfc	b1 30		lda ($30),y			lda 	(codePtr),y
.8bfe	c8		iny				iny
.8bff	0a		asl a				asl 	a
.8c00	aa		tax				tax
.8c01	7c 36 8d	jmp ($8d36,x)			jmp 	(VectorSet1,x)
.8c04					Shift2Command:
.8c04	b1 30		lda ($30),y			lda 	(codePtr),y
.8c06	c8		iny				iny
.8c07	0a		asl a				asl 	a
.8c08	aa		tax				tax
.8c09	7c 5c 8d	jmp ($8d5c,x)			jmp 	(VectorSet2,x)
.8c0c					Unused1:
.8c0c					Unused2:
.8c0c					Unused3:
.8c0c					Unused4:
.8c0c	4c 9e 9f	jmp $9f9e			jmp 	SyntaxError
>8c0f							.align 2

;******  Processing file: ./common/commands/../generated/vectors.dat

.8c10					VectorSetPunc:
>8c10	b1 91					.word	ShiftLeft                        ; $00 <<
>8c12	9c 8f					.word	BinaryCompareLessEqual           ; $01 <=
>8c14	92 8f					.word	BinaryCompareNotEqual            ; $02 <>
>8c16	9e 9f					.word	SyntaxError                      ; $03 !!3
>8c18	9e 9f					.word	SyntaxError                      ; $04 ><
>8c1a	a6 8f					.word	BinaryCompareGreaterEqual        ; $05 >=
>8c1c	b4 91					.word	ShiftRight                       ; $06 >>
>8c1e	9e 9f					.word	SyntaxError                      ; $07 !!7
>8c20	9e 9f					.word	SyntaxError                      ; $08 !!8
>8c22	9e 9f					.word	SyntaxError                      ; $09 !!9
>8c24	9e 9f					.word	SyntaxError                      ; $0a !!10
>8c26	9e 9f					.word	SyntaxError                      ; $0b !!11
>8c28	9e 9f					.word	SyntaxError                      ; $0c !!12
>8c2a	9e 9f					.word	SyntaxError                      ; $0d !!13
>8c2c	9e 9f					.word	SyntaxError                      ; $0e !!14
>8c2e	9e 9f					.word	SyntaxError                      ; $0f !!15
>8c30	9e 9f					.word	SyntaxError                      ; $10 @
>8c32	9e 9f					.word	SyntaxError                      ; $11 !!17
>8c34	9e 9f					.word	SyntaxError                      ; $12 !!18
>8c36	9e 9f					.word	SyntaxError                      ; $13 [
>8c38	5d 90					.word	IntegerDivide                    ; $14 \
>8c3a	9e 9f					.word	SyntaxError                      ; $15 ]
>8c3c	ef 92					.word	EorInteger                       ; $16 ^
>8c3e	9e 9f					.word	SyntaxError                      ; $17 _
>8c40	9e 9f					.word	SyntaxError                      ; $18 `
>8c42	9e 9f					.word	SyntaxError                      ; $19 !!25
>8c44	9e 9f					.word	SyntaxError                      ; $1a !!26
>8c46	9e 9f					.word	SyntaxError                      ; $1b {
>8c48	ba 92					.word	OraInteger                       ; $1c |
>8c4a	9e 9f					.word	SyntaxError                      ; $1d }
>8c4c	9e 9f					.word	SyntaxError                      ; $1e ~
>8c4e	9e 9f					.word	SyntaxError                      ; $1f [7m<7F>[m
>8c50	9e 9f					.word	SyntaxError                      ; $20
>8c52	24 93					.word	WordIndirect                     ; $21 !
>8c54	9e 9f					.word	SyntaxError                      ; $22 "
>8c56	9e 9f					.word	SyntaxError                      ; $23 #
>8c58	9e 9f					.word	SyntaxError                      ; $24 $
>8c5a	9e 90					.word	IntegerModulus                   ; $25 %
>8c5c	85 92					.word	AndInteger                       ; $26 &
>8c5e	9e 9f					.word	SyntaxError                      ; $27 '
>8c60	9e 9f					.word	SyntaxError                      ; $28 (
>8c62	9e 9f					.word	SyntaxError                      ; $29 )
>8c64	0c 91					.word	MulInteger                       ; $2a *
>8c66	27 92					.word	AddInteger                       ; $2b +
>8c68	9e 9f					.word	SyntaxError                      ; $2c ,
>8c6a	60 92					.word	SubInteger                       ; $2d -
>8c6c	9e 9f					.word	SyntaxError                      ; $2e .
>8c6e	de 94					.word	FDivideCommand                   ; $2f /
>8c70	9e 9f					.word	SyntaxError                      ; $30 0
>8c72	9e 9f					.word	SyntaxError                      ; $31 1
>8c74	9e 9f					.word	SyntaxError                      ; $32 2
>8c76	9e 9f					.word	SyntaxError                      ; $33 3
>8c78	9e 9f					.word	SyntaxError                      ; $34 4
>8c7a	9e 9f					.word	SyntaxError                      ; $35 5
>8c7c	9e 9f					.word	SyntaxError                      ; $36 6
>8c7e	9e 9f					.word	SyntaxError                      ; $37 7
>8c80	9e 9f					.word	SyntaxError                      ; $38 8
>8c82	9e 9f					.word	SyntaxError                      ; $39 9
>8c84	9e 9f					.word	SyntaxError                      ; $3a :
>8c86	9e 9f					.word	SyntaxError                      ; $3b ;
>8c88	7e 8f					.word	BinaryCompareLess                ; $3c <
>8c8a	74 8f					.word	BinaryCompareEqual               ; $3d =
>8c8c	88 8f					.word	BinaryCompareGreater             ; $3e >
>8c8e	46 93					.word	ByteIndirect                     ; $3f ?
.8c90					VectorSet0:
>8c90	62 8b					.word	EOLCommand                       ; $80 !0:EOF
>8c92	fc 8b					.word	Shift1Command                    ; $81 !1:SH1
>8c94	04 8c					.word	Shift2Command                    ; $82 !2:SH2
>8c96	c8 99					.word	AbsUnary                         ; $83 ABS(
>8c98	d6 99					.word	AllocUnary                       ; $84 ALLOC(
>8c9a	46 9a					.word	AscUnary                         ; $85 ASC(
>8c9c	06 9c					.word	ChrUnary                         ; $86 CHR$(
>8c9e	56 9a					.word	DeekUnary                        ; $87 DEEK(
>8ca0	fe a3					.word	UnaryEvent                       ; $88 EVENT(
>8ca2	70 8f					.word	UnaryFalse                       ; $89 FALSE
>8ca4	68 9a					.word	FracUnary                        ; $8a FRAC(
>8ca6	9a a3					.word	UnaryHit                         ; $8b HIT(
>8ca8	7d 9a					.word	IntUnary                         ; $8c INT(
>8caa	c5 9b					.word	IsValUnary                       ; $8d ISVAL(
>8cac	82 a4					.word	UnaryJoyB                        ; $8e JOYB(
>8cae	5b a4					.word	UnaryJoyX                        ; $8f JOYX(
>8cb0	5e a4					.word	UnaryJoyY                        ; $90 JOYY(
>8cb2	d9 9c					.word	Unary_Left                       ; $91 LEFT$(
>8cb4	8e 9a					.word	LenUnary                         ; $92 LEN(
>8cb6	ac 9a					.word	Unary_Max                        ; $93 MAX(
>8cb8	fb 9c					.word	Unary_Mid                        ; $94 MID$(
>8cba	a8 9a					.word	Unary_Min                        ; $95 MIN(
>8cbc	f7 9a					.word	Unary_Not                        ; $96 NOT(
>8cbe	53 9a					.word	PeekUnary                        ; $97 PEEK(
>8cc0	1f a6					.word	UnaryPlaying                     ; $98 PLAYING(
>8cc2	0a 9b					.word	Unary_Random                     ; $99 RANDOM(
>8cc4	e6 9c					.word	Unary_Right                      ; $9a RIGHT$(
>8cc6	27 9b					.word	Unary_Rnd                        ; $9b RND(
>8cc8	9d 9b					.word	SgnUnary                         ; $9c SGN(
>8cca	18 9c					.word	SpcUnary                         ; $9d SPC(
>8ccc	33 9c					.word	Unary_Str                        ; $9e STR$(
>8cce	a8 a4					.word	UnaryTimer                       ; $9f TIMER(
>8cd0	65 8f					.word	UnaryTrue                        ; $a0 TRUE
>8cd2	bb 9b					.word	ValUnary                         ; $a1 VAL(
>8cd4	be 85					.word	ForCommand                       ; $a2 FOR
>8cd6	01 87					.word	IfCommand                        ; $a3 IF
>8cd8	0c 8c					.word	Unused1                          ; $a4 PROC
>8cda	0e 8b					.word	Command_REPEAT                   ; $a5 REPEAT
>8cdc	b1 8e					.word	Command_WHILE                    ; $a6 WHILE
>8cde	2a 87					.word	EndIf                            ; $a7 ENDIF
>8ce0	96 8a					.word	Command_ENDPROC                  ; $a8 ENDPROC
>8ce2	70 86					.word	NextCommand                      ; $a9 NEXT
>8ce4	0c 8c					.word	Unused4                          ; $aa THEN
>8ce6	17 8b					.word	Command_UNTIL                    ; $ab UNTIL
>8ce8	d2 8e					.word	Command_WEND                     ; $ac WEND
>8cea	9e 9f					.word	SyntaxError                      ; $ad BY
>8cec	38 84					.word	CallCommand                      ; $ae CALL
>8cee	4e a1					.word	CircleCommand                    ; $af CIRCLE
>8cf0	6d 84					.word	ClearCommand                     ; $b0 CLEAR
>8cf2	c5 84					.word	ClearScreen                      ; $b1 CLS
>8cf4	9e 9f					.word	SyntaxError                      ; $b2 COLOR
>8cf6	9e 9f					.word	SyntaxError                      ; $b3 COLOUR
>8cf8	cd 84					.word	Command_Data                     ; $b4 DATA
>8cfa	d5 84					.word	DimCommand                       ; $b5 DIM
>8cfc	95 85					.word	DokeCommand                      ; $b6 DOKE
>8cfe	0c 8c					.word	Unused3                          ; $b7 DOWNTO
>8d00	23 87					.word	ElseCode                         ; $b8 ELSE
>8d02	9e 9f					.word	SyntaxError                      ; $b9 FROM
>8d04	6d a3					.word	GfxCommand                       ; $ba GFX
>8d06	c9 86					.word	Command_GOSUB                    ; $bb GOSUB
>8d08	e7 86					.word	GotoCommand                      ; $bc GOTO
>8d0a	9e 9f					.word	SyntaxError                      ; $bd HERE
>8d0c	77 a1					.word	ImageCommand                     ; $be IMAGE
>8d0e	2b 87					.word	Command_Input                    ; $bf INPUT
>8d10	16 88					.word	LetCommand                       ; $c0 LET
>8d12	c9 a1					.word	LineCommand                      ; $c1 LINE
>8d14	67 89					.word	Command_LOCAL                    ; $c2 LOCAL
>8d16	9e 9f					.word	SyntaxError                      ; $c3 OFF
>8d18	9e 9f					.word	SyntaxError                      ; $c4 ON
>8d1a	9e 9f					.word	SyntaxError                      ; $c5 OUTLINE
>8d1c	be a3					.word	PaletteCommand                   ; $c6 PALETTE
>8d1e	c2 a1					.word	PlotCommand                      ; $c7 PLOT
>8d20	92 85					.word	PokeCommand                      ; $c8 POKE
>8d22	32 87					.word	Command_Print                    ; $c9 PRINT
>8d24	a4 8a					.word	Command_Read                     ; $ca READ
>8d26	4a a1					.word	RectangleCommand                 ; $cb RECT
>8d28	01 8b					.word	RemCommand                       ; $cc REM
>8d2a	d9 86					.word	Command_RETURN                   ; $cd RETURN
>8d2c	9e 9f					.word	SyntaxError                      ; $ce SOLID
>8d2e	3b a6					.word	SoundCommand                     ; $cf SOUND
>8d30	59 a1					.word	SpriteCommand                    ; $d0 SPRITE
>8d32	93 a1					.word	TextCommand                      ; $d1 TEXT
>8d34	0c 8c					.word	Unused2                          ; $d2 TO
.8d36					VectorSet1:
>8d36	9e 9f					.word	SyntaxError                      ; $80 !0:EOF
>8d38	9e 9f					.word	SyntaxError                      ; $81 !1:SH1
>8d3a	9e 9f					.word	SyntaxError                      ; $82 !2:SH2
>8d3c	0c 84					.word	AssembleCommand                  ; $83 ASSEMBLE
>8d3e	28 84					.word	AssertCommand                    ; $84 ASSERT
>8d40	0d a3					.word	BitmapCtrl                       ; $85 BITMAP
>8d42	bb 85					.word	EndCommand                       ; $86 END
>8d44	f3 a5					.word	Explode                          ; $87 EXPLODE
>8d46	9f a4					.word	GoCommand                        ; $88 GO
>8d48	66 88					.word	Command_List                     ; $89 LIST
>8d4a	96 a4					.word	LoadCommand                      ; $8a LOAD
>8d4c	28 8a					.word	NewCommand                       ; $8b NEW
>8d4e	cf a5					.word	PingCommand                      ; $8c PING
>8d50	30 8b					.word	Command_Restore                  ; $8d RESTORE
>8d52	6f 8b					.word	CommandRUN                       ; $8e RUN
>8d54	e7 a5					.word	ShootCommand                     ; $8f SHOOT
>8d56	52 a3					.word	SpritesCtrl                      ; $90 SPRITES
>8d58	e4 8d					.word	StopCommand                      ; $91 STOP
>8d5a	db a5					.word	ZapCommand                       ; $92 ZAP
.8d5c					VectorSet2:
>8d5c	9e 9f					.word	SyntaxError                      ; $80 !0:EOF
>8d5e	9e 9f					.word	SyntaxError                      ; $81 !1:SH1
>8d60	9e 9f					.word	SyntaxError                      ; $82 !2:SH2
>8d62	5d 9e					.word	Assemble_adc                     ; $83 ADC
>8d64	55 9e					.word	Assemble_and                     ; $84 AND
>8d66	71 9e					.word	Assemble_asl                     ; $85 ASL
>8d68	db 9e					.word	Assemble_bcc                     ; $86 BCC
>8d6a	df 9e					.word	Assemble_bcs                     ; $87 BCS
>8d6c	e7 9e					.word	Assemble_beq                     ; $88 BEQ
>8d6e	9e 9e					.word	Assemble_bit                     ; $89 BIT
>8d70	cf 9e					.word	Assemble_bmi                     ; $8a BMI
>8d72	e3 9e					.word	Assemble_bne                     ; $8b BNE
>8d74	cb 9e					.word	Assemble_bpl                     ; $8c BPL
>8d76	eb 9e					.word	Assemble_bra                     ; $8d BRA
>8d78	ef 9e					.word	Assemble_brk                     ; $8e BRK
>8d7a	d3 9e					.word	Assemble_bvc                     ; $8f BVC
>8d7c	d7 9e					.word	Assemble_bvs                     ; $90 BVS
>8d7e	f7 9e					.word	Assemble_clc                     ; $91 CLC
>8d80	4b 9f					.word	Assemble_cld                     ; $92 CLD
>8d82	0b 9f					.word	Assemble_cli                     ; $93 CLI
>8d84	3b 9f					.word	Assemble_clv                     ; $94 CLV
>8d86	69 9e					.word	Assemble_cmp                     ; $95 CMP
>8d88	b2 9e					.word	Assemble_cpx                     ; $96 CPX
>8d8a	ad 9e					.word	Assemble_cpy                     ; $97 CPY
>8d8c	8f 9e					.word	Assemble_dec                     ; $98 DEC
>8d8e	47 9f					.word	Assemble_dex                     ; $99 DEX
>8d90	23 9f					.word	Assemble_dey                     ; $9a DEY
>8d92	59 9e					.word	Assemble_eor                     ; $9b EOR
>8d94	94 9e					.word	Assemble_inc                     ; $9c INC
>8d96	57 9f					.word	Assemble_inx                     ; $9d INX
>8d98	43 9f					.word	Assemble_iny                     ; $9e INY
>8d9a	c6 9e					.word	Assemble_jmp                     ; $9f JMP
>8d9c	c1 9e					.word	Assemble_jsr                     ; $a0 JSR
>8d9e	65 9e					.word	Assemble_lda                     ; $a1 LDA
>8da0	8a 9e					.word	Assemble_ldx                     ; $a2 LDX
>8da2	a8 9e					.word	Assemble_ldy                     ; $a3 LDY
>8da4	7b 9e					.word	Assemble_lsr                     ; $a4 LSR
>8da6	5b 9f					.word	Assemble_nop                     ; $a5 NOP
>8da8	51 9e					.word	Assemble_ora                     ; $a6 ORA
>8daa	07 9f					.word	Assemble_pha                     ; $a7 PHA
>8dac	f3 9e					.word	Assemble_php                     ; $a8 PHP
>8dae	4f 9f					.word	Assemble_phx                     ; $a9 PHX
>8db0	0f 9f					.word	Assemble_phy                     ; $aa PHY
>8db2	17 9f					.word	Assemble_pla                     ; $ab PLA
>8db4	fb 9e					.word	Assemble_plp                     ; $ac PLP
>8db6	63 9f					.word	Assemble_plx                     ; $ad PLX
>8db8	1f 9f					.word	Assemble_ply                     ; $ae PLY
>8dba	76 9e					.word	Assemble_rol                     ; $af ROL
>8dbc	80 9e					.word	Assemble_ror                     ; $b0 ROR
>8dbe	03 9f					.word	Assemble_rti                     ; $b1 RTI
>8dc0	13 9f					.word	Assemble_rts                     ; $b2 RTS
>8dc2	6d 9e					.word	Assemble_sbc                     ; $b3 SBC
>8dc4	ff 9e					.word	Assemble_sec                     ; $b4 SEC
>8dc6	5f 9f					.word	Assemble_sed                     ; $b5 SED
>8dc8	1b 9f					.word	Assemble_sei                     ; $b6 SEI
>8dca	61 9e					.word	Assemble_sta                     ; $b7 STA
>8dcc	53 9f					.word	Assemble_stp                     ; $b8 STP
>8dce	85 9e					.word	Assemble_stx                     ; $b9 STX
>8dd0	a3 9e					.word	Assemble_sty                     ; $ba STY
>8dd2	99 9e					.word	Assemble_stz                     ; $bb STZ
>8dd4	37 9f					.word	Assemble_tax                     ; $bc TAX
>8dd6	33 9f					.word	Assemble_tay                     ; $bd TAY
>8dd8	bc 9e					.word	Assemble_trb                     ; $be TRB
>8dda	b7 9e					.word	Assemble_tsb                     ; $bf TSB
>8ddc	3f 9f					.word	Assemble_tsx                     ; $c0 TSX
>8dde	27 9f					.word	Assemble_txa                     ; $c1 TXA
>8de0	2f 9f					.word	Assemble_txs                     ; $c2 TXS
>8de2	2b 9f					.word	Assemble_tya                     ; $c3 TYA

;******  Return to file: ./common/commands/run.asm


;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/stop.asm

.8de4					StopCommand:
.8de4	a9 08		lda #$08		lda	#8
.8de6	4c f9 8e	jmp $8ef9		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/procscan.asm

.8de9					ProcedureScan:
.8de9	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8deb	85 30		sta $30				sta 	codePtr
.8ded	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8def	85 31		sta $31				sta 	codePtr+1
.8df1					_PSLoop:
.8df1	b2 30		lda ($30)			lda 	(codePtr)
.8df3	f0 42		beq $8e37			beq 	_PSExit
.8df5	a0 03		ldy #$03			ldy 	#3 							; is it PROC at start of line ?
.8df7	b1 30		lda ($30),y			lda 	(codePtr),y
.8df9	c9 a4		cmp #$a4			cmp 	#KWD_PROC
.8dfb	d0 2d		bne $8e2a			bne 	_PSNext
.8dfd	c8		iny				iny 								; get the address of the record to zTemp0 and
.8dfe	b1 30		lda ($30),y			lda 	(codePtr),y
.8e00	29 c0		and #$c0			and 	#$C0
.8e02	c9 40		cmp #$40			cmp 	#$40
.8e04	d0 32		bne $8e38			bne 	_PSSyntax
.8e06	b1 30		lda ($30),y			lda 	(codePtr),y
.8e08	18		clc				clc
.8e09	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8e0b	85 37		sta $37				sta 	zTemp0+1
.8e0d	c8		iny				iny 								; LSB
.8e0e	b1 30		lda ($30),y			lda 	(codePtr),y
.8e10	85 36		sta $36				sta 	zTemp0
.8e12	c8		iny				iny 								; character after variable call.
.8e13	98		tya				tya 								; save Y offset at +7 (exponent slot)
.8e14	a0 07		ldy #$07			ldy 	#7
.8e16	91 36		sta ($36),y			sta 	(zTemp0),y
.8e18	a9 18		lda #$18			lda 	#NSTProcedure 				; mark it as procedure
.8e1a	a0 02		ldy #$02			ldy 	#2
.8e1c	91 36		sta ($36),y			sta 	(zTemp0),y
.8e1e	a2 00		ldx #$00			ldx 	#0 							; copy code-Ptr into offset 3-6 (mantissa)
.8e20					_PSCopy:
.8e20	b5 30		lda $30,x			lda 	safePtr,x
.8e22	c8		iny				iny
.8e23	91 36		sta ($36),y			sta 	(zTemp0),y
.8e25	e8		inx				inx
.8e26	e0 04		cpx #$04			cpx 	#4
.8e28	d0 f6		bne $8e20			bne 	_PSCopy
.8e2a					_PSNext:
.8e2a	18		clc				clc
.8e2b	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8e2d	65 30		adc $30				adc 	codePtr
.8e2f	85 30		sta $30				sta 	codePtr
.8e31	90 02		bcc $8e35			bcc 	_CREExit
.8e33	e6 31		inc $31				inc 	codePtr+1 					; carry
.8e35					_CREExit:
.8e35	80 ba		bra $8df1			bra 	_PSLoop
.8e37					_PSExit:
.8e37	60		rts				rts
.8e38					_PSSyntax:
.8e38	4c 9e 9f	jmp $9f9e			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/scanforward.asm

.8e3b					ScanForward:
.8e3b	64 38		stz $38				stz 	zTemp1 						; zero the structure count - goes up with WHILE/FOR down with WEND/NEXT etc.
.8e3d	86 37		stx $37				stx 	zTemp0+1
.8e3f	85 36		sta $36				sta 	zTemp0 						; save X & A as the two possible matches.
.8e41					_ScanLoop:
.8e41	b1 30		lda ($30),y			lda 	(codePtr),y
.8e43	c8		iny				iny
.8e44	a6 38		ldx $38				ldx 	zTemp1 						; if the count is > 0 cannot match as in substructure
.8e46	d0 0e		bne $8e56			bne 	_ScanGoNext
.8e48	c5 36		cmp $36				cmp 	zTemp0 						; see if either matches
.8e4a	f0 04		beq $8e50			beq 	_ScanMatch
.8e4c	c5 37		cmp $37				cmp 	zTemp0+1
.8e4e	d0 06		bne $8e56			bne 	_ScanGoNext
.8e50					_ScanMatch:
.8e50	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if asked for EOL, backtrack.
.8e52	d0 01		bne $8e55			bne 	_ScanNotEndEOL
.8e54	88		dey				dey
.8e55					_ScanNotEndEOL:
.8e55	60		rts				rts
.8e56					_ScanGoNext:
.8e56	20 5b 8e	jsr $8e5b			jsr  	ScanForwardOne 				; allows for shifts and so on.
.8e59	80 e6		bra $8e41			bra 	_ScanLoop
.8e5b					ScanForwardOne:
.8e5b	c9 40		cmp #$40			cmp 	#$40 						; if 00-3F, punctuation characters, already done.
.8e5d	90 3e		bcc $8e9d			bcc 	_SFWExit
.8e5f	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if 40-82, skip one extra as these are 2 byte
.8e61	90 18		bcc $8e7b			bcc 	_ScanSkipOne	 			; offsets into the identifier table or shifts.
.8e63	c9 fc		cmp #$fc			cmp 	#$FC 						; FC-FF are data skips (hex consts, strings etc.)
.8e65	b0 2f		bcs $8e96			bcs 	_ScanSkipData
.8e67	c9 a2		cmp #$a2			cmp 	#KWC_FIRST_STRUCTURE 		; structure keyword ?
.8e69	90 32		bcc $8e9d			bcc 	_SFWExit 					; if not, ordinary keywords.
.8e6b	c9 ad		cmp #$ad			cmp 	#KWC_LAST_STRUCTURE+1
.8e6d	b0 2e		bcs $8e9d			bcs 	_SFWExit
.8e6f	c6 38		dec $38				dec 	zTemp1 						; decrement the sructure count
.8e71	c9 a7		cmp #$a7			cmp 	#KWC_FIRST_STRUCTURE_DEC 	; back if it is a dec structure (e.g. WEND/NEXT)
.8e73	b0 28		bcs $8e9d			bcs 	_SFWExit
.8e75	e6 38		inc $38				inc 	zTemp1 						; so it's an increment structure
.8e77	e6 38		inc $38				inc 	zTemp1 						; twice to undo the dec
.8e79	80 22		bra $8e9d			bra 	_SFWExit
.8e7b					_ScanSkipOne:
.8e7b	c8		iny				iny 								; consume the extra one.
.8e7c	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if not EOL loop back
.8e7e	d0 1d		bne $8e9d			bne 	_SFWExit
.8e80	18		clc				clc
.8e81	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8e83	65 30		adc $30				adc 	codePtr
.8e85	85 30		sta $30				sta 	codePtr
.8e87	90 02		bcc $8e8b			bcc 	_CREExit
.8e89	e6 31		inc $31				inc 	codePtr+1 					; carry
.8e8b					_CREExit:
.8e8b	a0 03		ldy #$03			ldy 	#3 							; scan start position.
.8e8d	b2 30		lda ($30)			lda 	(codePtr)
.8e8f	d0 0c		bne $8e9d			bne 	_SFWExit 					; if not zero, more to scan
.8e91	a9 13		lda #$13		lda	#19
.8e93	4c f9 8e	jmp $8ef9		jmp	ErrorHandler
.8e96					_ScanSkipData:
.8e96	88		dey				dey 								; point at data token
.8e97	c8		iny				iny 								; point to offset
.8e98	98		tya				tya 								; A = offset position
.8e99	38		sec				sec 								; add size +1 hence SEC
.8e9a	71 30		adc ($30),y			adc 	(codePtr),y
.8e9c	a8		tay				tay 								; make current position.
.8e9d					_SFWExit:
.8e9d	60		rts				rts
.8e9e					ScanGetCurrentLineStep:
.8e9e	64 38		stz $38				stz 	zTemp1
.8ea0	a0 03		ldy #$03			ldy 	#3
.8ea2					_SGCLSLoop:
.8ea2	b1 30		lda ($30),y			lda 	(codePtr),y
.8ea4	c8		iny				iny
.8ea5	c9 80		cmp #$80			cmp 	#KWC_EOL	 				; if EOL exit
.8ea7	f0 05		beq $8eae			beq 	_SGCLSExit
.8ea9	20 5b 8e	jsr $8e5b			jsr 	ScanForwardOne
.8eac	80 f4		bra $8ea2			bra 	_SGCLSLoop
.8eae					_SGCLSExit:
.8eae	a5 38		lda $38				lda 	zTemp1 						; return the adjustment
.8eb0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/while.asm

.8eb1					Command_WHILE:
.8eb1	5a		phy				phy 								; save position of the test
.8eb2	a2 00		ldx #$00			ldx 	#0 							; work out the while test.
.8eb4	20 6e 9d	jsr $9d6e			jsr 	EvaluateNumber
.8eb7	20 42 9e	jsr $9e42			jsr 	NSMIsZero 					; check if zero
.8eba	f0 0e		beq $8eca			beq 	_WHExitLoop 				; if so exit the loop, while has failed.
.8ebc	98		tya				tya 								; position *after* test.
.8ebd	7a		ply				ply 								; restore position before test, at WHILE
.8ebe	88		dey				dey 								; so we execute the WHILE command again.
.8ebf	48		pha				pha 								; push after test on the stack
.8ec0	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; allocate 6 bytes on the return stack.
.8ec2	20 c2 a6	jsr $a6c2			jsr 	StackOpen
.8ec5	20 07 a7	jsr $a707			jsr 	STKSaveCodePosition 		; save loop position - where the test value expr is.
.8ec8	7a		ply				ply 								; restore the position *after* the test
.8ec9	60		rts				rts
.8eca					_WHExitLoop:
.8eca	68		pla				pla 								; throw post loop position
.8ecb	a9 ac		lda #$ac			lda 	#KWD_WEND 					; scan forward past WEND
.8ecd	aa		tax				tax
.8ece	20 3b 8e	jsr $8e3b			jsr 	ScanForward
.8ed1	60		rts				rts
.8ed2					Command_WEND:
.8ed2	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; check WHILE is TOS e.g. in a while loop :)
.8ed4	a2 10		ldx #$10			ldx 	#ERRID_WHILE 				; this error if not.
.8ed6	20 ef a6	jsr $a6ef			jsr 	StackCheckFrame
.8ed9	20 18 a7	jsr $a718			jsr 	STKLoadCodePosition 		; loop back to the WHILE keyword.
.8edc	20 e1 a6	jsr $a6e1			jsr 	StackClose		 			; erase the frame
.8edf	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/charcheck.asm

.8ee0					CheckRightBracket:
.8ee0	b1 30		lda ($30),y			lda 	(codePtr),y
.8ee2	c8		iny				iny
.8ee3	c9 29		cmp #$29			cmp 	#KWD_RPAREN 						; exit if matches
.8ee5	d0 0f		bne $8ef6			bne 	CNAFail
.8ee7	60		rts				rts
.8ee8					CheckComma:
.8ee8	b1 30		lda ($30),y			lda 	(codePtr),y
.8eea	c8		iny				iny
.8eeb	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 						; exit if matches
.8eed	d0 07		bne $8ef6			bne 	CNAFail
.8eef	60		rts				rts
.8ef0					CheckNextA:
.8ef0	d1 30		cmp ($30),y			cmp 	(codePtr),y
.8ef2	d0 02		bne $8ef6			bne 	CNAFail
.8ef4	c8		iny				iny 								; skip character
.8ef5	60		rts				rts 								; and exit
.8ef6					CNAFail:
.8ef6	4c 9e 9f	jmp $9f9e			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/errors.asm

.8ef9					ErrorHandler:
.8ef9	a8		tay				tay 								; find the error text
.8efa	f0 49		beq $8f45			beq 	_EHEnd
.8efc	a2 00		ldx #$00			ldx 	#0
.8efe	a9 b7		lda #$b7			lda 	#((ErrorText) & $FF)
.8f00	85 36		sta $36				sta 	0+zTemp0
.8f02	a9 9f		lda #$9f			lda 	#((ErrorText) >> 8)
.8f04	85 37		sta $37				sta 	1+zTemp0
.8f06					_EHFind:
.8f06	88		dey				dey 								; keep looking through text
.8f07	f0 0e		beq $8f17			beq 	_EHFound
.8f09					_EHFindZero:
.8f09	b2 36		lda ($36)			lda 	(zTemp0) 					; find the next error
.8f0b	e6 36		inc $36				inc 	zTemp0
.8f0d	d0 02		bne $8f11			bne 	_EHFNoCarry
.8f0f	e6 37		inc $37				inc 	zTemp0+1
.8f11					_EHFNoCarry:
.8f11	c9 00		cmp #$00			cmp 	#0
.8f13	d0 f4		bne $8f09			bne 	_EHFindZero
.8f15	80 ef		bra $8f06			bra 	_EHFind
.8f17					_EHFound:
.8f17	a5 36		lda $36				lda 	zTemp0 						; print message
.8f19	a6 37		ldx $37				ldx 	zTemp0+1
.8f1b	20 52 8f	jsr $8f52			jsr 	PrintStringXA
.8f1e	a0 01		ldy #$01			ldy 	#1 							; if line number zero don't print it
.8f20	b1 30		lda ($30),y			lda 	(codePtr),y
.8f22	d0 05		bne $8f29			bne 	_EHAtMsg
.8f24	c8		iny				iny
.8f25	b1 30		lda ($30),y			lda 	(codePtr),y
.8f27	f0 17		beq $8f40			beq 	_EHCREnd
.8f29					_EHAtMsg:
.8f29	a2 8f		ldx #$8f			ldx 	#_AtMsg >> 8 				; print " at "
.8f2b	a9 48		lda #$48			lda 	#_AtMsg & $FF
.8f2d	20 52 8f	jsr $8f52			jsr 	PrintStringXA
.8f30	a0 01		ldy #$01			ldy 	#1 							; line number into XA
.8f32	b1 30		lda ($30),y			lda 	(codePtr),y
.8f34	48		pha				pha
.8f35	c8		iny				iny
.8f36	b1 30		lda ($30),y			lda 	(codePtr),y
.8f38	aa		tax				tax
.8f39	68		pla				pla
.8f3a	20 68 93	jsr $9368			jsr 	ConvertInt16 				; convert XA to string
.8f3d	20 52 8f	jsr $8f52			jsr 	PrintStringXA 				; and print it.
.8f40					_EHCREnd:
.8f40	a9 0d		lda #$0d			lda 	#13 						; new line
.8f42	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8f45					_EHEnd:
.8f45	4c d7 83	jmp $83d7			jmp 	WarmStart
>8f48	20 61 74 20 6c 69 6e 65		_AtMsg:	.text 	" at line ",0
>8f50	20 00
.8f52					PrintStringXA:
.8f52	5a		phy				phy
.8f53	86 37		stx $37				stx 	zTemp0+1
.8f55	85 36		sta $36				sta 	zTemp0
.8f57	a0 00		ldy #$00			ldy 	#0
.8f59					_PSXALoop:
.8f59	b1 36		lda ($36),y			lda 	(zTemp0),y
.8f5b	f0 06		beq $8f63			beq 	_PSXAExit
.8f5d	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8f60	c8		iny				iny
.8f61	80 f6		bra $8f59			bra 	_PSXALoop
.8f63					_PSXAExit:
.8f63	7a		ply				ply
.8f64	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/compare.asm

.8f65					UnaryTrue:
.8f65	fa		plx				plx
.8f66					ReturnTrue:
.8f66	a9 01		lda #$01			lda 	#1  						; set to 1
.8f68	20 22 9e	jsr $9e22			jsr 	NSMSetByte
.8f6b	a9 80		lda #$80			lda 	#$80 						; set sign flag, so it is -1
.8f6d	95 50		sta $50,x			sta 	NSStatus,x
.8f6f	60		rts				rts
.8f70					UnaryFalse:
.8f70	fa		plx				plx
.8f71					ReturnFalse:
.8f71	4c 20 9e	jmp $9e20			jmp 	NSMSetZero 					; set it all to zero
.8f74					BinaryCompareEqual:
.8f74	fa		plx				plx
.8f75	20 b0 8f	jsr $8fb0			jsr 	CompareBaseCode
.8f78	c9 00		cmp #$00			cmp 	#0
.8f7a	f0 ea		beq $8f66			beq 	ReturnTrue
.8f7c	80 f3		bra $8f71			bra 	ReturnFalse
.8f7e					BinaryCompareLess:
.8f7e	fa		plx				plx
.8f7f	20 b0 8f	jsr $8fb0			jsr 	CompareBaseCode
.8f82	c9 ff		cmp #$ff			cmp 	#$FF
.8f84	f0 e0		beq $8f66			beq 	ReturnTrue
.8f86	80 e9		bra $8f71			bra 	ReturnFalse
.8f88					BinaryCompareGreater:
.8f88	fa		plx				plx
.8f89	20 b0 8f	jsr $8fb0			jsr 	CompareBaseCode
.8f8c	c9 01		cmp #$01			cmp 	#1
.8f8e	f0 d6		beq $8f66			beq 	ReturnTrue
.8f90	80 df		bra $8f71			bra 	ReturnFalse
.8f92					BinaryCompareNotEqual:
.8f92	fa		plx				plx
.8f93	20 b0 8f	jsr $8fb0			jsr 	CompareBaseCode
.8f96	c9 00		cmp #$00			cmp 	#0
.8f98	d0 cc		bne $8f66			bne 	ReturnTrue
.8f9a	80 d5		bra $8f71			bra 	ReturnFalse
.8f9c					BinaryCompareLessEqual:
.8f9c	fa		plx				plx
.8f9d	20 b0 8f	jsr $8fb0			jsr 	CompareBaseCode
.8fa0	c9 01		cmp #$01			cmp 	#1
.8fa2	d0 c2		bne $8f66			bne 	ReturnTrue
.8fa4	80 cb		bra $8f71			bra 	ReturnFalse
.8fa6					BinaryCompareGreaterEqual:
.8fa6	fa		plx				plx
.8fa7	20 b0 8f	jsr $8fb0			jsr 	CompareBaseCode
.8faa	c9 ff		cmp #$ff			cmp 	#$FF
.8fac	d0 b8		bne $8f66			bne 	ReturnTrue
.8fae	80 c1		bra $8f71			bra 	ReturnFalse
.8fb0					CompareBaseCode:
.8fb0	20 bb 96	jsr $96bb			jsr 	DereferenceTopTwo 			; make both values if references.
.8fb3	b5 50		lda $50,x			lda 	NSStatus,x 					; check if either is a string.
.8fb5	15 51		ora $51,x			ora 	NSStatus+1,x
.8fb7	29 10		and #$10			and 	#NSTString
.8fb9	d0 37		bne $8ff2			bne 	_CBCString 					; if so do string code, which will check if both.
.8fbb	b5 78		lda $78,x			lda 	NSExponent,x 				; check both are integers
.8fbd	15 79		ora $79,x			ora 	NSExponent+1,x
.8fbf	d0 34		bne $8ff5			bne 	_CBCFloat
.8fc1	b5 50		lda $50,x			lda 	NSStatus,x
.8fc3	15 51		ora $51,x			ora 	NSStatus+1,x
.8fc5	29 08		and #$08			and 	#NSTFloat
.8fc7	d0 2c		bne $8ff5			bne 	_CBCFloat
.8fc9	20 f8 8f	jsr $8ff8			jsr 	CompareFixMinusZero 		; fix up -0 just in cases.
.8fcc	e8		inx				inx
.8fcd	20 f8 8f	jsr $8ff8			jsr 	CompareFixMinusZero
.8fd0	ca		dex				dex
.8fd1	b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs different ?
.8fd3	55 51		eor $51,x			eor 	NSStatus+1,x
.8fd5	10 0a		bpl $8fe1			bpl 	_CDCSameSign
.8fd7	b5 50		lda $50,x			lda 	NSStatus,x 					; if first one is -ve
.8fd9	30 14		bmi $8fef			bmi 	_CBCLess 					; return $FF
.8fdb					_CBCGreater:
.8fdb	a9 01		lda #$01			lda 	#1
.8fdd	60		rts				rts
.8fde					_CBCEqual:
.8fde	a9 00		lda #$00			lda 	#0
.8fe0	60		rts				rts
.8fe1					_CDCSameSign:
.8fe1	20 0d 92	jsr $920d			jsr 	SubTopTwoStack 				; unsigned subtract
.8fe4	20 42 9e	jsr $9e42			jsr 	NSMIsZero 					; or the mantissa together
.8fe7	f0 f5		beq $8fde			beq 	_CBCEqual 					; -0 == 0
.8fe9	b5 70		lda $70,x			lda 	NSMantissa3,x 				; sign of the result. if +ve return $01 else return $FF
.8feb	55 51		eor $51,x			eor 	NSStatus+1,x 				; however if both were -ve this is inverted
.8fed	10 ec		bpl $8fdb			bpl 	_CBCGreater
.8fef					_CBCLess:
.8fef	a9 ff		lda #$ff			lda 	#$FF
.8ff1	60		rts				rts
.8ff2					_CBCString:
.8ff2	4c 7e 91	jmp $917e			jmp 	CompareStrings
.8ff5					_CBCFloat:
.8ff5	4c c8 94	jmp $94c8			jmp 	CompareFloat
.8ff8					CompareFixMinusZero:
.8ff8	20 42 9e	jsr $9e42			jsr 	NSMIsZero
.8ffb	d0 02		bne $8fff			bne 	_CFXMZNotZero
.8ffd	74 50		stz $50,x			stz 	NSStatus,x
.8fff					_CFXMZNotZero:
.8fff	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/concat.asm

.9000					StringConcat:
.9000	b5 50		lda $50,x			lda 	NSStatus,x 					; check both strings
.9002	35 51		and $51,x			and 	NSStatus+1,x
.9004	29 18		and #$18			and 	#NSBTypeMask
.9006	c9 10		cmp #$10			cmp 	#NSTString
.9008	d0 50		bne $905a			bne		_SCType
.900a	64 38		stz $38				stz 	zTemp1 						; counting total length
.900c	e8		inx				inx
.900d	20 2b 90	jsr $902b			jsr 	_SCSetupZ0 					; setup for second
.9010	20 34 90	jsr $9034			jsr 	_SCLengthZ0 				; length for second
.9013	ca		dex				dex
.9014	20 2b 90	jsr $902b			jsr 	_SCSetupZ0 					; setup for first
.9017	20 34 90	jsr $9034			jsr 	_SCLengthZ0 				; length for first
.901a	a5 38		lda $38				lda 	zTemp1 						; allocate memory using total.
.901c	20 b2 a7	jsr $a7b2			jsr 	StringTempAllocate
.901f	20 4b 90	jsr $904b			jsr 	_SCCopy 					; copy first out, using zTemp0 from above
.9022	e8		inx				inx
.9023	20 2b 90	jsr $902b			jsr 	_SCSetupZ0 					; copy second out
.9026	20 4b 90	jsr $904b			jsr 	_SCCopy
.9029	ca		dex				dex
.902a	60		rts				rts
.902b					_SCSetupZ0:
.902b	b5 58		lda $58,x			lda 	NSMantissa0,x
.902d	85 36		sta $36				sta 	zTemp0
.902f	b5 60		lda $60,x			lda 	NSMantissa1,x
.9031	85 37		sta $37				sta 	zTemp0+1
.9033	60		rts				rts
.9034					_SCLengthZ0:
.9034	5a		phy				phy
.9035	a0 00		ldy #$00			ldy 	#0
.9037					_SCLenLoop:
.9037	b1 36		lda ($36),y			lda 	(zTemp0),y
.9039	f0 0e		beq $9049			beq 	_SCLExit
.903b	c8		iny				iny
.903c	e6 38		inc $38				inc 	zTemp1
.903e	a5 38		lda $38				lda	 	zTemp1 						; check string too long.
.9040	c9 fd		cmp #$fd			cmp 	#253
.9042	d0 f3		bne $9037			bne		_SCLenLoop
.9044	a9 09		lda #$09		lda	#9
.9046	4c f9 8e	jmp $8ef9		jmp	ErrorHandler
.9049					_SCLExit:
.9049	7a		ply				ply
.904a	60		rts				rts
.904b					_SCCopy:
.904b	5a		phy				phy
.904c	a0 00		ldy #$00			ldy 	#0
.904e					_SCCopyLoop:
.904e	b1 36		lda ($36),y			lda 	(zTemp0),y
.9050	f0 06		beq $9058			beq 	_SCCExit
.9052	20 eb a7	jsr $a7eb			jsr 	StringTempWrite
.9055	c8		iny				iny
.9056	80 f6		bra $904e			bra 	_SCCopyLoop
.9058					_SCCExit:
.9058	7a		ply				ply
.9059	60		rts				rts
.905a					_SCType:
.905a	4c a8 9f	jmp $9fa8			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/divide.asm

.905d					IntegerDivide:
.905d	fa		plx				plx
.905e	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9060	15 51		ora $51,x			ora 	NSStatus+1,x
.9062	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9063	0a		asl a				asl 	a
.9064	10 05		bpl $906b			bpl 	_NotRef
.9066	48		pha				pha
.9067	20 bb 96	jsr $96bb			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.906a	68		pla				pla
.906b					_NotRef:
.906b	0a		asl a				asl 	a
.906c	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.906e	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9070	15 79		ora $79,x			ora 	NSExponent+1,x
.9072	f0 03		beq $9077			beq 	_IntegerCode 				; if clear, then we have two integers
.9074	4c a8 9f	jmp $9fa8			jmp 	TypeError 					; anything else, type mismatch.
.9077					_IntegerCode:
.9077	20 91 90	jsr $9091			jsr 	CheckDivideZero 			; do div zero check
.907a	20 c3 90	jsr $90c3			jsr 	Int32Divide 				; do the division
.907d	20 74 91	jsr $9174			jsr 	CalculateSign 				; calculate result sign
.9080					NSMCopyPlusTwoToZero:
.9080	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.9082	95 58		sta $58,x			sta 	NSMantissa0,x
.9084	b5 62		lda $62,x			lda 	NSMantissa1+2,x
.9086	95 60		sta $60,x			sta 	NSMantissa1,x
.9088	b5 6a		lda $6a,x			lda 	NSMantissa2+2,x
.908a	95 68		sta $68,x			sta 	NSMantissa2,x
.908c	b5 72		lda $72,x			lda 	NSMantissa3+2,x
.908e	95 70		sta $70,x			sta 	NSMantissa3,x
.9090	60		rts				rts
.9091					CheckDivideZero:
.9091	e8		inx				inx
.9092	20 42 9e	jsr $9e42			jsr 	NSMIsZero
.9095	f0 02		beq $9099			beq 	_CDVError
.9097	ca		dex				dex
.9098	60		rts				rts
.9099					_CDVError:
.9099	a9 03		lda #$03		lda	#3
.909b	4c f9 8e	jmp $8ef9		jmp	ErrorHandler
.909e					IntegerModulus:
.909e	fa		plx				plx
.909f	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.90a1	15 51		ora $51,x			ora 	NSStatus+1,x
.90a3	0a		asl a				asl 	a 							; shift reference bit into sign bit
.90a4	0a		asl a				asl 	a
.90a5	10 05		bpl $90ac			bpl 	_NotRef
.90a7	48		pha				pha
.90a8	20 bb 96	jsr $96bb			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.90ab	68		pla				pla
.90ac					_NotRef:
.90ac	0a		asl a				asl 	a
.90ad	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.90af	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.90b1	15 79		ora $79,x			ora 	NSExponent+1,x
.90b3	f0 03		beq $90b8			beq 	_IntegerCode 				; if clear, then we have two integers
.90b5	4c a8 9f	jmp $9fa8			jmp 	TypeError 					; anything else, type mismatch.
.90b8					_IntegerCode:
.90b8					IntegerModulusNoCheck:
.90b8	20 91 90	jsr $9091			jsr 	CheckDivideZero 			; do div zero check
.90bb	20 c3 90	jsr $90c3			jsr 	Int32Divide 				; do the division
.90be	16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.90c0	56 50		lsr $50,x			lsr 	NSStatus,x
.90c2	60		rts				rts
.90c3					Int32Divide:
.90c3	48		pha				pha 								; save AXY
.90c4	5a		phy				phy
.90c5	20 03 9e	jsr $9e03			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.90c8	20 1c 9e	jsr $9e1c			jsr 	NSMSetZeroMantissaOnly 		; set S[X] to zero
.90cb	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.90cd					_I32DivideLoop:
.90cd	e8		inx				inx
.90ce	e8		inx				inx
.90cf	20 2f 9e	jsr $9e2f			jsr 	NSMShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.90d2	ca		dex				dex
.90d3	ca		dex				dex
.90d4	20 30 9e	jsr $9e30			jsr 	NSMRotateLeft
.90d7	20 02 91	jsr $9102			jsr 	DivideCheckSubtract 		; check if subtract possible
.90da	90 02		bcc $90de			bcc 	_I32DivideNoCarryIn
.90dc	f6 5a		inc $5a,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.90de					_I32DivideNoCarryIn:
.90de	88		dey				dey 								; loop round till division completed.
.90df	d0 ec		bne $90cd			bne 	_I32DivideLoop
.90e1	7a		ply				ply 								; restore AXY and exit
.90e2	68		pla				pla
.90e3	60		rts				rts
.90e4					Int32ShiftDivide:
.90e4	48		pha				pha 								; save AY
.90e5	5a		phy				phy
.90e6	e8		inx				inx 								; clear S[X+2]
.90e7	e8		inx				inx
.90e8	20 20 9e	jsr $9e20			jsr 	NSMSetZero
.90eb	ca		dex				dex
.90ec	ca		dex				dex
.90ed	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.90ef					_I32SDLoop:
.90ef	20 02 91	jsr $9102			jsr 	DivideCheckSubtract 		; check if subtract possible
.90f2	e8		inx				inx
.90f3	e8		inx				inx
.90f4	20 30 9e	jsr $9e30			jsr 	NSMRotateLeft				; shift 64 bit FPA left, rotating carry in
.90f7	ca		dex				dex
.90f8	ca		dex				dex
.90f9	20 30 9e	jsr $9e30			jsr 	NSMRotateLeft
.90fc	88		dey				dey 	 							; do 31 times
.90fd	d0 f0		bne $90ef			bne 	_I32SDLoop
.90ff	7a		ply				ply 								; restore AY and exit
.9100	68		pla				pla
.9101	60		rts				rts
.9102					DivideCheckSubtract:
.9102	20 0d 92	jsr $920d			jsr 	SubTopTwoStack 				; subtract Stack[X+1] from Stack[X+0]
.9105	b0 04		bcs $910b			bcs 	_DCSExit 					; if carry set, then could do, exit
.9107	20 f3 91	jsr $91f3			jsr 	AddTopTwoStack 				; add it back in
.910a	18		clc				clc 								; and return False
.910b					_DCSExit:
.910b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/multiply.asm

.910c					MulInteger:
.910c	fa		plx				plx
.910d	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.910f	15 51		ora $51,x			ora 	NSStatus+1,x
.9111	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9112	0a		asl a				asl 	a
.9113	10 05		bpl $911a			bpl 	_NotRef
.9115	48		pha				pha
.9116	20 bb 96	jsr $96bb			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9119	68		pla				pla
.911a					_NotRef:
.911a	0a		asl a				asl 	a 							; put MSB of type into A:7
.911b	30 09		bmi $9126			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.911d	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.911f	15 79		ora $79,x			ora 	NSExponent+1,x
.9121	f0 06		beq $9129			beq 	_IntegerCode 				; if clear, then we have two integers
.9123	4c 8a 95	jmp $958a			jmp 	FloatingPointMultiply 							; otherwise at least one float.
.9126					_StringData:
.9126	4c b2 9f	jmp $9fb2			jmp 	NotDoneError							; at least one string - don't know both are strings.
.9129					_IntegerCode:
.9129	20 36 91	jsr $9136			jsr 	MultiplyShort
.912c	c9 00		cmp #$00			cmp 	#0
.912e	f0 05		beq $9135			beq 	_MIExit
.9130	a9 04		lda #$04		lda	#4
.9132	4c f9 8e	jmp $8ef9		jmp	ErrorHandler
.9135					_MIExit:
.9135	60		rts				rts
.9136					MultiplyShort:
.9136	5a		phy				phy 								; save Y
.9137	20 03 9e	jsr $9e03			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.913a	20 1c 9e	jsr $9e1c			jsr 	NSMSetZeroMantissaOnly 		; set mantissa S[X] to zero
.913d	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.913f					_I32MLoop:
.913f	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.9141	15 62		ora $62,x			ora 	NSMantissa1+2,x
.9143	15 6a		ora $6a,x			ora 	NSMantissa2+2,x
.9145	15 72		ora $72,x			ora 	NSMantissa3+2,x
.9147	f0 25		beq $916e			beq 	_I32MExit 					; exit if zero
.9149	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.914b	29 01		and #$01			and 	#1
.914d	f0 0d		beq $915c			beq 	_I32MNoAdd
.914f	20 f3 91	jsr $91f3			jsr 	AddTopTwoStack 				; if so add S[X+1] to S[X+0]
.9152	b5 70		lda $70,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.9154	10 06		bpl $915c			bpl 	_I32MNoAdd
.9156					_I32ShiftRight:
.9156	20 39 9e	jsr $9e39			jsr 	NSMShiftRight 				; shift S[X] right
.9159	c8		iny				iny 								; increment shift count
.915a	80 09		bra $9165			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.915c					_I32MNoAdd:
.915c	34 71		bit $71,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.915e	70 f6		bvs $9156			bvs 	_I32ShiftRight 				; instead.
.9160	e8		inx				inx
.9161	20 2f 9e	jsr $9e2f			jsr 	NSMShiftLeft 				; shift additive S[X+1] left
.9164	ca		dex				dex
.9165					_I32MShiftUpper:
.9165	e8		inx				inx 								; shift S[X+2] right
.9166	e8		inx				inx
.9167	20 39 9e	jsr $9e39			jsr 	NSMShiftRight
.916a	ca		dex				dex
.916b	ca		dex				dex
.916c	80 d1		bra $913f			bra 	_I32MLoop 					; try again.
.916e					_I32MExit:
.916e	20 74 91	jsr $9174			jsr 	CalculateSign
.9171	98		tya				tya 								; shift in A
.9172	7a		ply				ply 								; restore Y and exit
.9173	60		rts				rts
.9174					CalculateSign:
.9174	b5 50		lda $50,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.9176	16 50		asl $50,x			asl 	NSStatus,x 					; shift result left
.9178	55 51		eor $51,x			eor 	NSStatus+1,x
.917a	0a		asl a				asl 	a 							; shift bit 7 into carry
.917b	76 50		ror $50,x			ror 	NSStatus,x 					; shift right into status byte.
.917d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/scompare.asm

.917e					CompareStrings:
.917e	b5 50		lda $50,x			lda 	NSStatus,x 					; check both are strings
.9180	35 51		and $51,x			and 	NSStatus+1,x
.9182	29 10		and #$10			and 	#NSBIsString
.9184	f0 28		beq $91ae			beq 	_CSTypeError
.9186	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy string addresses to zTemp0/1
.9188	85 36		sta $36				sta 	zTemp0
.918a	b5 60		lda $60,x			lda 	NSMantissa1,x
.918c	85 37		sta $37				sta 	zTemp0+1
.918e	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9190	85 38		sta $38				sta 	zTemp1
.9192	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9194	85 39		sta $39				sta 	zTemp1+1
.9196	5a		phy				phy 								; save Y so we can access strings
.9197	a0 ff		ldy #$ff			ldy 	#$FF 						; -1 for pre increment.
.9199					_CSLoop:
.9199	c8		iny				iny
.919a	b1 36		lda ($36),y			lda 	(zTemp0),y 					; check if they are the same
.919c	d1 38		cmp ($38),y			cmp 	(zTemp1),y
.919e	d0 06		bne $91a6			bne 	_CSDifferent
.91a0	c9 00		cmp #$00			cmp 	#0 							; reached end ?
.91a2	d0 f5		bne $9199			bne 	_CSLoop 					; still comparing
.91a4					_CSExit:
.91a4	7a		ply				ply 								; reached end, return zero in A from EOS
.91a5	60		rts				rts
.91a6					_CSDifferent:
.91a6	a9 ff		lda #$ff			lda 	#255 						; if < return $FF
.91a8	90 fa		bcc $91a4			bcc		_CSExit
.91aa	a9 01		lda #$01			lda 	#1 							; otherwise return 1.
.91ac	80 f6		bra $91a4			bra 	_CSExit
.91ae					_CSTypeError:
.91ae	4c a8 9f	jmp $9fa8			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/shifts.asm

.91b1					ShiftLeft:
.91b1	38		sec				sec 								; common code, carry determines which way.
.91b2	80 01		bra $91b5			bra 	ShiftMain
.91b4					ShiftRight:
.91b4	18		clc				clc
.91b5					ShiftMain:
.91b5	fa		plx				plx 								; restore X
.91b6	08		php				php 								; save direction
.91b7	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.91b9	15 51		ora $51,x			ora 	NSStatus+1,x
.91bb	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91bc	0a		asl a				asl 	a
.91bd	10 05		bpl $91c4			bpl 	_NotRef
.91bf	48		pha				pha
.91c0	20 bb 96	jsr $96bb			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91c3	68		pla				pla
.91c4					_NotRef:
.91c4	0a		asl a				asl 	a
.91c5	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.91c7	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91c9	15 79		ora $79,x			ora 	NSExponent+1,x
.91cb	f0 03		beq $91d0			beq 	_IntegerCode 				; if clear, then we have two integers
.91cd	4c a8 9f	jmp $9fa8			jmp 	TypeError 					; anything else, type mismatch.
.91d0					_IntegerCode:
.91d0	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; check number < 32
.91d2	29 e0		and #$e0			and 	#$E0
.91d4	15 61		ora $61,x			ora 	NSMantissa1+1,x
.91d6	15 69		ora $69,x			ora 	NSMantissa2+1,x
.91d8	15 71		ora $71,x			ora 	NSMantissa3+1,x
.91da	d0 12		bne $91ee			bne 	_SMExit0 					; if >= 32 it will always return zero.
.91dc					_SMLoop:
.91dc	d6 59		dec $59,x			dec 	NSMantissa0+1,x 			; predecrement, could do << 0
.91de	30 11		bmi $91f1			bmi 	_SMExit 					; exit if done.
.91e0	28		plp				plp 								; restore direction setting
.91e1	08		php				php
.91e2	90 05		bcc $91e9			bcc 	_SMRight
.91e4	20 2f 9e	jsr $9e2f			jsr 	NSMShiftLeft 				; shift left if CS
.91e7	80 f3		bra $91dc			bra 	_SMLoop
.91e9					_SMRight:
.91e9	20 39 9e	jsr $9e39			jsr 	NSMShiftRight 				; shift right if CC
.91ec	80 ee		bra $91dc			bra 	_SMLoop
.91ee					_SMExit0:
.91ee	20 20 9e	jsr $9e20			jsr 	NSMSetZero 					; return zero.
.91f1					_SMExit:
.91f1	28		plp				plp 								; throw direction
.91f2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/simple.asm

.91f3					AddTopTwoStack:
.91f3	18		clc				clc
.91f4	b5 58		lda $58,x			lda		NSMantissa0,x
.91f6	75 59		adc $59,x			adc 		NSMantissa0+1,x
.91f8	95 58		sta $58,x			sta 	NSMantissa0,x
.91fa	b5 60		lda $60,x			lda		NSMantissa1,x
.91fc	75 61		adc $61,x			adc 		NSMantissa1+1,x
.91fe	95 60		sta $60,x			sta 	NSMantissa1,x
.9200	b5 68		lda $68,x			lda		NSMantissa2,x
.9202	75 69		adc $69,x			adc 		NSMantissa2+1,x
.9204	95 68		sta $68,x			sta 	NSMantissa2,x
.9206	b5 70		lda $70,x			lda		NSMantissa3,x
.9208	75 71		adc $71,x			adc 		NSMantissa3+1,x
.920a	95 70		sta $70,x			sta 	NSMantissa3,x
.920c	60		rts				rts
.920d					SubTopTwoStack:
.920d	38		sec				sec
.920e	b5 58		lda $58,x			lda		NSMantissa0,x
.9210	f5 59		sbc $59,x			sbc 		NSMantissa0+1,x
.9212	95 58		sta $58,x			sta 	NSMantissa0,x
.9214	b5 60		lda $60,x			lda		NSMantissa1,x
.9216	f5 61		sbc $61,x			sbc 		NSMantissa1+1,x
.9218	95 60		sta $60,x			sta 	NSMantissa1,x
.921a	b5 68		lda $68,x			lda		NSMantissa2,x
.921c	f5 69		sbc $69,x			sbc 		NSMantissa2+1,x
.921e	95 68		sta $68,x			sta 	NSMantissa2,x
.9220	b5 70		lda $70,x			lda		NSMantissa3,x
.9222	f5 71		sbc $71,x			sbc 		NSMantissa3+1,x
.9224	95 70		sta $70,x			sta 	NSMantissa3,x
.9226	60		rts				rts
.9227					AddInteger:
.9227	fa		plx				plx
.9228	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.922a	15 51		ora $51,x			ora 	NSStatus+1,x
.922c	0a		asl a				asl 	a 							; shift reference bit into sign bit
.922d	0a		asl a				asl 	a
.922e	10 05		bpl $9235			bpl 	_NotRef
.9230	48		pha				pha
.9231	20 bb 96	jsr $96bb			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9234	68		pla				pla
.9235					_NotRef:
.9235	0a		asl a				asl 	a 							; put MSB of type into A:7
.9236	30 09		bmi $9241			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9238	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.923a	15 79		ora $79,x			ora 	NSExponent+1,x
.923c	f0 06		beq $9244			beq 	_IntegerCode 				; if clear, then we have two integers
.923e	4c 3a 94	jmp $943a			jmp 	FloatingPointAdd 							; otherwise at least one float.
.9241					_StringData:
.9241	4c 00 90	jmp $9000			jmp 	StringConcat							; at least one string - don't know both are strings.
.9244					_IntegerCode:
.9244					AddCode:
.9244	b5 50		lda $50,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.9246	55 51		eor $51,x			eor 	NSStatus+1,x
.9248	10 a9		bpl $91f3			bpl 	AddTopTwoStack
.924a	20 0d 92	jsr $920d			jsr 	SubTopTwoStack 				; do a physical subtraction
.924d	34 70		bit $70,x			bit 	NSMantissa3,x 				; result is +ve, okay
.924f	10 07		bpl $9258			bpl 	_AddExit
.9251	b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign is that of 2nd value
.9253	95 50		sta $50,x			sta 	NSStatus,x
.9255	20 e9 9d	jsr $9de9			jsr 	NSMNegateMantissa 			; negate the mantissa and exit
.9258					_AddExit:
.9258	20 42 9e	jsr $9e42			jsr 	NSMIsZero 					; check for -0
.925b	d0 02		bne $925f			bne 	_AddNonZero
.925d	74 50		stz $50,x			stz 	NSStatus,x
.925f					_AddNonZero:
.925f	60		rts				rts
.9260					SubInteger:
.9260	fa		plx				plx
.9261	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9263	15 51		ora $51,x			ora 	NSStatus+1,x
.9265	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9266	0a		asl a				asl 	a
.9267	10 05		bpl $926e			bpl 	_NotRef
.9269	48		pha				pha
.926a	20 bb 96	jsr $96bb			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.926d	68		pla				pla
.926e					_NotRef:
.926e	0a		asl a				asl 	a 							; put MSB of type into A:7
.926f	30 09		bmi $927a			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9271	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9273	15 79		ora $79,x			ora 	NSExponent+1,x
.9275	f0 06		beq $927d			beq 	_IntegerCode 				; if clear, then we have two integers
.9277	4c 3f 94	jmp $943f			jmp 	FloatingPointSub 							; otherwise at least one float.
.927a					_StringData:
.927a	4c b2 9f	jmp $9fb2			jmp 	NotDoneError							; at least one string - don't know both are strings.
.927d					_IntegerCode:
.927d	b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate the second value.
.927f	49 80		eor #$80			eor 	#$80
.9281	95 51		sta $51,x			sta 	NSStatus+1,x
.9283	80 bf		bra $9244			bra 	AddCode 					; and do the same code as add.
.9285					AndInteger:
.9285	fa		plx				plx
.9286	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9288	15 51		ora $51,x			ora 	NSStatus+1,x
.928a	0a		asl a				asl 	a 							; shift reference bit into sign bit
.928b	0a		asl a				asl 	a
.928c	10 05		bpl $9293			bpl 	_NotRef
.928e	48		pha				pha
.928f	20 bb 96	jsr $96bb			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9292	68		pla				pla
.9293					_NotRef:
.9293	0a		asl a				asl 	a
.9294	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9296	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9298	15 79		ora $79,x			ora 	NSExponent+1,x
.929a	f0 03		beq $929f			beq 	_IntegerCode 				; if clear, then we have two integers
.929c	4c a8 9f	jmp $9fa8			jmp 	TypeError 					; anything else, type mismatch.
.929f					_IntegerCode:
.929f	b5 58		lda $58,x			lda		NSMantissa0,x
.92a1	35 59		and $59,x			and 		NSMantissa0+1,x
.92a3	95 58		sta $58,x			sta 	NSMantissa0,x
.92a5	b5 60		lda $60,x			lda		NSMantissa1,x
.92a7	35 61		and $61,x			and 		NSMantissa1+1,x
.92a9	95 60		sta $60,x			sta 	NSMantissa1,x
.92ab	b5 68		lda $68,x			lda		NSMantissa2,x
.92ad	35 69		and $69,x			and 		NSMantissa2+1,x
.92af	95 68		sta $68,x			sta 	NSMantissa2,x
.92b1	b5 70		lda $70,x			lda		NSMantissa3,x
.92b3	35 71		and $71,x			and 		NSMantissa3+1,x
.92b5	95 70		sta $70,x			sta 	NSMantissa3,x
.92b7	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.92b9	60		rts				rts
.92ba					OraInteger:
.92ba	fa		plx				plx
.92bb	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.92bd	15 51		ora $51,x			ora 	NSStatus+1,x
.92bf	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92c0	0a		asl a				asl 	a
.92c1	10 05		bpl $92c8			bpl 	_NotRef
.92c3	48		pha				pha
.92c4	20 bb 96	jsr $96bb			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92c7	68		pla				pla
.92c8					_NotRef:
.92c8	0a		asl a				asl 	a
.92c9	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.92cb	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92cd	15 79		ora $79,x			ora 	NSExponent+1,x
.92cf	f0 03		beq $92d4			beq 	_IntegerCode 				; if clear, then we have two integers
.92d1	4c a8 9f	jmp $9fa8			jmp 	TypeError 					; anything else, type mismatch.
.92d4					_IntegerCode:
.92d4	b5 58		lda $58,x			lda		NSMantissa0,x
.92d6	15 59		ora $59,x			ora 		NSMantissa0+1,x
.92d8	95 58		sta $58,x			sta 	NSMantissa0,x
.92da	b5 60		lda $60,x			lda		NSMantissa1,x
.92dc	15 61		ora $61,x			ora 		NSMantissa1+1,x
.92de	95 60		sta $60,x			sta 	NSMantissa1,x
.92e0	b5 68		lda $68,x			lda		NSMantissa2,x
.92e2	15 69		ora $69,x			ora 		NSMantissa2+1,x
.92e4	95 68		sta $68,x			sta 	NSMantissa2,x
.92e6	b5 70		lda $70,x			lda		NSMantissa3,x
.92e8	15 71		ora $71,x			ora 		NSMantissa3+1,x
.92ea	95 70		sta $70,x			sta 	NSMantissa3,x
.92ec	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.92ee	60		rts				rts
.92ef					EorInteger:
.92ef	fa		plx				plx
.92f0	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.92f2	15 51		ora $51,x			ora 	NSStatus+1,x
.92f4	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92f5	0a		asl a				asl 	a
.92f6	10 05		bpl $92fd			bpl 	_NotRef
.92f8	48		pha				pha
.92f9	20 bb 96	jsr $96bb			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92fc	68		pla				pla
.92fd					_NotRef:
.92fd	0a		asl a				asl 	a
.92fe	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9300	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9302	15 79		ora $79,x			ora 	NSExponent+1,x
.9304	f0 03		beq $9309			beq 	_IntegerCode 				; if clear, then we have two integers
.9306	4c a8 9f	jmp $9fa8			jmp 	TypeError 					; anything else, type mismatch.
.9309					_IntegerCode:
.9309	b5 58		lda $58,x			lda		NSMantissa0,x
.930b	55 59		eor $59,x			eor 		NSMantissa0+1,x
.930d	95 58		sta $58,x			sta 	NSMantissa0,x
.930f	b5 60		lda $60,x			lda		NSMantissa1,x
.9311	55 61		eor $61,x			eor 		NSMantissa1+1,x
.9313	95 60		sta $60,x			sta 	NSMantissa1,x
.9315	b5 68		lda $68,x			lda		NSMantissa2,x
.9317	55 69		eor $69,x			eor 		NSMantissa2+1,x
.9319	95 68		sta $68,x			sta 	NSMantissa2,x
.931b	b5 70		lda $70,x			lda		NSMantissa3,x
.931d	55 71		eor $71,x			eor 		NSMantissa3+1,x
.931f	95 70		sta $70,x			sta 	NSMantissa3,x
.9321	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.9323	60		rts				rts
.9324					WordIndirect:
.9324	fa		plx				plx
.9325	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9327	15 51		ora $51,x			ora 	NSStatus+1,x
.9329	0a		asl a				asl 	a 							; shift reference bit into sign bit
.932a	0a		asl a				asl 	a
.932b	10 05		bpl $9332			bpl 	_NotRef
.932d	48		pha				pha
.932e	20 bb 96	jsr $96bb			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9331	68		pla				pla
.9332					_NotRef:
.9332	0a		asl a				asl 	a
.9333	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9335	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9337	15 79		ora $79,x			ora 	NSExponent+1,x
.9339	f0 03		beq $933e			beq 	_IntegerCode 				; if clear, then we have two integers
.933b	4c a8 9f	jmp $9fa8			jmp 	TypeError 					; anything else, type mismatch.
.933e					_IntegerCode:
.933e	20 44 92	jsr $9244			jsr 	AddCode 					; add the two values
.9341	a9 22		lda #$22			lda 	#NSBIsReference+2 			; make a 2 byte reference
.9343	95 50		sta $50,x			sta 	NSStatus,x
.9345	60		rts				rts
.9346					ByteIndirect:
.9346	fa		plx				plx
.9347	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9349	15 51		ora $51,x			ora 	NSStatus+1,x
.934b	0a		asl a				asl 	a 							; shift reference bit into sign bit
.934c	0a		asl a				asl 	a
.934d	10 05		bpl $9354			bpl 	_NotRef
.934f	48		pha				pha
.9350	20 bb 96	jsr $96bb			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9353	68		pla				pla
.9354					_NotRef:
.9354	0a		asl a				asl 	a
.9355	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9357	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9359	15 79		ora $79,x			ora 	NSExponent+1,x
.935b	f0 03		beq $9360			beq 	_IntegerCode 				; if clear, then we have two integers
.935d	4c a8 9f	jmp $9fa8			jmp 	TypeError 					; anything else, type mismatch.
.9360					_IntegerCode:
.9360	20 44 92	jsr $9244			jsr 	AddCode 					; add the two values
.9363	a9 21		lda #$21			lda 	#NSBIsReference+1 			; make a 1 byte reference
.9365	95 50		sta $50,x			sta 	NSStatus,x
.9367	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/tostring.asm

.9368					ConvertInt16:
.9368	85 58		sta $58				sta 	NSMantissa0 				; set up as 32 bit conversion
.936a	86 60		stx $60				stx 	NSMantissa1
.936c	64 68		stz $68				stz 	NSMantissa2
.936e	64 70		stz $70				stz 	NSMantissa3
.9370	64 50		stz $50				stz 	NSStatus 					; positive integer
.9372	a2 00		ldx #$00			ldx 	#0 							; stack level
.9374	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.9376	80 00		bra $9378			bra 	ConvertInt32
.9378					ConvertInt32:
.9378	5a		phy				phy
.9379	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.937b	24 50		bit $50				bit 	NSStatus 					; output a - if not negative.
.937d	10 08		bpl $9387			bpl 	_CI32NotNeg
.937f	48		pha				pha
.9380	a9 2d		lda #$2d			lda 	#'-'
.9382	99 27 06	sta $0627,y			sta 	NumberBuffer,y
.9385	c8		iny				iny
.9386	68		pla				pla
.9387					_CI32NotNeg:
.9387	20 95 93	jsr $9395			jsr 	_CI32DivideConvert 			; recursive conversion
.938a	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.938c	99 27 06	sta $0627,y			sta 	NumberBuffer,y
.938f	7a		ply				ply
.9390	a2 06		ldx #$06			ldx 	#NumberBuffer >> 8 			; return address in XA
.9392	a9 27		lda #$27			lda 	#NumberBuffer & $FF
.9394	60		rts				rts
.9395					_CI32DivideConvert:
.9395	e8		inx				inx 								; write to next slot up
.9396	20 22 9e	jsr $9e22			jsr 	NSMSetByte 		 			; write the base out.
.9399	ca		dex				dex
.939a	20 c3 90	jsr $90c3			jsr 	Int32Divide 				; divide
.939d	b5 58		lda $58,x			lda 	NSMantissa0,x 				; save remainder
.939f	48		pha				pha
.93a0	20 80 90	jsr $9080			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.93a3	20 42 9e	jsr $9e42			jsr 	NSMIsZero 					; is it zero ?
.93a6	f0 05		beq $93ad			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.93a8	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.93aa	20 95 93	jsr $9395			jsr 	_CI32DivideConvert 			; and recusrively call.
.93ad					_CI32NoRecurse:
.93ad	68		pla				pla 								; remainder
.93ae	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.93b0	90 02		bcc $93b4			bcc 	_CI32NotHex
.93b2	69 26		adc #$26			adc 	#6+32
.93b4					_CI32NotHex:
.93b4	69 30		adc #$30			adc 	#48
.93b6	99 27 06	sta $0627,y			sta 	NumberBuffer,y 				; write out and exit
.93b9	c8		iny				iny
.93ba	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/expression.asm


;******  Processing file: ./common/expressions/../generated/precedence.dat

.93bb					PrecedenceLevel:
>93bb	04					.byte	 4	; $00 <<
>93bc	02					.byte	 2	; $01 <=
>93bd	02					.byte	 2	; $02 <>
>93be	00					.byte	 0	; $03 !!3
>93bf	00					.byte	 0	; $04 ><
>93c0	02					.byte	 2	; $05 >=
>93c1	04					.byte	 4	; $06 >>
>93c2	00					.byte	 0	; $07 !!7
>93c3	00					.byte	 0	; $08 !!8
>93c4	00					.byte	 0	; $09 !!9
>93c5	00					.byte	 0	; $0a !!10
>93c6	00					.byte	 0	; $0b !!11
>93c7	00					.byte	 0	; $0c !!12
>93c8	00					.byte	 0	; $0d !!13
>93c9	00					.byte	 0	; $0e !!14
>93ca	00					.byte	 0	; $0f !!15
>93cb	00					.byte	 0	; $10 @
>93cc	00					.byte	 0	; $11 !!17
>93cd	00					.byte	 0	; $12 !!18
>93ce	00					.byte	 0	; $13 [
>93cf	04					.byte	 4	; $14 \
>93d0	00					.byte	 0	; $15 ]
>93d1	01					.byte	 1	; $16 ^
>93d2	00					.byte	 0	; $17 _
>93d3	00					.byte	 0	; $18 `
>93d4	00					.byte	 0	; $19 !!25
>93d5	00					.byte	 0	; $1a !!26
>93d6	00					.byte	 0	; $1b {
>93d7	01					.byte	 1	; $1c |
>93d8	00					.byte	 0	; $1d }
>93d9	00					.byte	 0	; $1e ~
>93da	00					.byte	 0	; $1f [7m<7F>[m
>93db	00					.byte	 0	; $20
>93dc	05					.byte	 5	; $21 !
>93dd	00					.byte	 0	; $22 "
>93de	00					.byte	 0	; $23 #
>93df	05					.byte	 5	; $24 $
>93e0	04					.byte	 4	; $25 %
>93e1	01					.byte	 1	; $26 &
>93e2	00					.byte	 0	; $27 '
>93e3	00					.byte	 0	; $28 (
>93e4	00					.byte	 0	; $29 )
>93e5	04					.byte	 4	; $2a *
>93e6	03					.byte	 3	; $2b +
>93e7	00					.byte	 0	; $2c ,
>93e8	03					.byte	 3	; $2d -
>93e9	00					.byte	 0	; $2e .
>93ea	04					.byte	 4	; $2f /
>93eb	00					.byte	 0	; $30 0
>93ec	00					.byte	 0	; $31 1
>93ed	00					.byte	 0	; $32 2
>93ee	00					.byte	 0	; $33 3
>93ef	00					.byte	 0	; $34 4
>93f0	00					.byte	 0	; $35 5
>93f1	00					.byte	 0	; $36 6
>93f2	00					.byte	 0	; $37 7
>93f3	00					.byte	 0	; $38 8
>93f4	00					.byte	 0	; $39 9
>93f5	00					.byte	 0	; $3a :
>93f6	00					.byte	 0	; $3b ;
>93f7	02					.byte	 2	; $3c <
>93f8	02					.byte	 2	; $3d =
>93f9	02					.byte	 2	; $3e >
>93fa	05					.byte	 5	; $3f ?

;******  Return to file: ./common/expressions/expression.asm

.93fb					EvaluateExpressionAt0:
.93fb	a2 00		ldx #$00			ldx 	#0 							; bottom stack level
.93fd					EvaluateExpression:
.93fd	a9 00		lda #$00			lda 	#0 							; lowest precedence level
.93ff					EvaluateExpressionAtPrecedence:
.93ff	48		pha				pha 								; save precedence level
.9400	20 47 98	jsr $9847			jsr 	EvaluateTerm 				; evaluate term into level X.
.9403	68		pla				pla 								; restore precedence level.
.9404					_EXPRLoop:
.9404	85 36		sta $36				sta 	zTemp0 						; save current precedence level.
.9406	b1 30		lda ($30),y			lda 	(codePtr),y
.9408	c9 40		cmp #$40			cmp		#$40 						; if >= $40 cannot be an operator
.940a	b0 25		bcs $9431			bcs 	_EXPRExit
.940c	da		phx				phx 								; read the operator precedence
.940d	aa		tax				tax
.940e	bd bb 93	lda $93bb,x			lda 	PrecedenceLevel,x
.9411	fa		plx				plx
.9412	c9 00		cmp #$00			cmp 	#0							; if zero exit (not an operator)
.9414	f0 1b		beq $9431			beq 	_EXPRExit
.9416	85 37		sta $37				sta 	zTemp0+1 					; save operator precedence level.
.9418	a5 36		lda $36				lda 	zTemp0 						; compare current precedence vs. operator precedence
.941a	c5 37		cmp $37				cmp 	zTemp0+1
.941c	b0 13		bcs $9431			bcs		_EXPRExit 					; if current >= operator exit
.941e	48		pha				pha 								; save current precedence.
.941f	b1 30		lda ($30),y			lda 	(codePtr),y
.9421	c8		iny				iny
.9422	48		pha				pha
.9423	a5 37		lda $37				lda 	zTemp0+1 					; get operator precedence level
.9425	e8		inx				inx 								; work out the right hand side.
.9426	20 ff 93	jsr $93ff			jsr 	EvaluateExpressionAtPrecedence
.9429	ca		dex				dex
.942a	68		pla				pla 								; get operator, call the code.
.942b	20 34 94	jsr $9434			jsr 	_EXPRCaller
.942e	68		pla				pla 								; restore precedence level
.942f	80 d3		bra $9404			bra 	_EXPRLoop 					; and go round.
.9431					_EXPRExit:
.9431	a5 36		lda $36				lda 	zTemp0 						; A = current precedence level.
.9433	60		rts				rts
.9434					_EXPRCaller:
.9434	da		phx				phx 								; save on stack, first thing is to restore it
.9435	0a		asl a				asl 	a 							; double so can use vectors into X
.9436	aa		tax				tax
.9437	7c 10 8c	jmp ($8c10,x)			jmp 	(VectorSetPunc,x) 			; and go to the code.

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/addsub.asm

.943a					FloatingPointAdd:
.943a	20 b0 95	jsr $95b0			jsr 	FloatPrepare 				; prepare for floats
.943d	80 09		bra $9448			bra 	FloatAdd
.943f					FloatingPointSub:
.943f	20 b0 95	jsr $95b0			jsr 	FloatPrepare 				; prepare for floats
.9442					FloatSubtract:
.9442	b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate FPB
.9444	49 80		eor #$80			eor 	#$80
.9446	95 51		sta $51,x			sta 	NSStatus+1,x				; and fall through.
.9448					FloatAdd:
.9448	48		pha				pha
.9449	5a		phy				phy
.944a	20 bf 95	jsr $95bf			jsr 	NSNormalise 				; normalise S[X]
.944d	f0 51		beq $94a0			beq 	_FAReturn1
.944f	e8		inx				inx 								; normalise S[X+1]
.9450	20 bf 95	jsr $95bf			jsr 	NSNormalise
.9453	ca		dex				dex
.9454	c9 00		cmp #$00			cmp 	#0
.9456	f0 60		beq $94b8			beq 	_FAExit 					; if so, just return A
.9458	b5 78		lda $78,x			lda 	NSExponent,x 				; are the exponents the same ?
.945a	d5 79		cmp $79,x			cmp 	NSExponent+1,x
.945c	f0 18		beq $9476			beq 	_FAExponentsEqual
.945e	b5 78		lda $78,x			lda 	NSExponent,x 				; work out the larger exponent
.9460	a8		tay				tay
.9461	38		sec				sec 								; do a signed comparison of the exponents.
.9462	f5 79		sbc $79,x			sbc 	NSExponent+1,x
.9464	50 02		bvc $9468			bvc 	_FANoSignedChange
.9466	49 80		eor #$80			eor 	#$80
.9468					_FANoSignedChange:
.9468	29 80		and #$80			and 	#$80
.946a	10 02		bpl $946e			bpl 	_FAHaveMax
.946c	b4 79		ldy $79,x			ldy 	NSExponent+1,x
.946e					_FAHaveMax:
.946e	20 bb 94	jsr $94bb			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.9471	e8		inx				inx
.9472	20 bb 94	jsr $94bb			jsr 	_FAShiftToExponent
.9475	ca		dex				dex
.9476					_FAExponentsEqual:
.9476	b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs the same
.9478	55 51		eor $51,x			eor 	NSStatus+1,x
.947a	30 0e		bmi $948a			bmi 	_FADifferentSigns
.947c	20 f3 91	jsr $91f3			jsr 	AddTopTwoStack 				; do the add of the mantissae
.947f	b5 70		lda $70,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.9481	10 35		bpl $94b8			bpl 	_FAExit 					; if no, we are done.
.9483	20 39 9e	jsr $9e39			jsr 	NSMShiftRight 				; shift A right, renormalising it.
.9486	f6 78		inc $78,x			inc 	NSExponent,x 				; bump the exponent and exit
.9488	80 2e		bra $94b8			bra 	_FAExit
.948a					_FADifferentSigns:
.948a	20 0d 92	jsr $920d			jsr 	SubTopTwoStack 				; subtract mantissa B from A
.948d	b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the result negative ?
.948f	10 06		bpl $9497			bpl 	_FACheckZero 				; if no, check for -0
.9491	20 e2 9d	jsr $9de2			jsr 	NSMNegate 					; netate result
.9494	20 e9 9d	jsr $9de9			jsr 	NSMNegateMantissa 			; negate (2'c) the mantissa
.9497					_FACheckZero:
.9497	20 42 9e	jsr $9e42			jsr 	NSMIsZero	 				; check for -0
.949a	d0 1c		bne $94b8			bne 	_FAExit
.949c	74 50		stz $50,x			stz 	NSStatus,x
.949e	80 18		bra $94b8			bra 	_FAExit
.94a0					_FAReturn1:
.94a0	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.94a2	95 58		sta $58,x			sta 	NSMantissa0,x
.94a4	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.94a6	95 60		sta $60,x			sta 	NSMantissa1,x
.94a8	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.94aa	95 68		sta $68,x			sta 	NSMantissa2,x
.94ac	b5 71		lda $71,x			lda 	NSMantissa3+1,x
.94ae	95 70		sta $70,x			sta 	NSMantissa3,x
.94b0	b5 79		lda $79,x			lda 	NSExponent+1,x
.94b2	95 78		sta $78,x			sta 	NSExponent,x
.94b4	b5 51		lda $51,x			lda 	NSStatus+1,x
.94b6	95 50		sta $50,x			sta 	NSStatus,x
.94b8					_FAExit:
.94b8	7a		ply				ply
.94b9	68		pla				pla
.94ba	60		rts				rts
.94bb					_FAShiftToExponent:
.94bb					_FAShiftToExponent2:
.94bb	98		tya				tya 								; compare Y to exponent
.94bc	d5 78		cmp $78,x			cmp 	NSExponent,x 				; reached the exponent required ?
.94be	f0 07		beq $94c7			beq 	_FASEExit 					; exit if so.
.94c0	20 39 9e	jsr $9e39			jsr 	NSMShiftRight	 			; shift the mantissa right
.94c3	f6 78		inc $78,x			inc 	NSExponent,x 				; increment exponent
.94c5	80 f4		bra $94bb			bra 	_FAShiftToExponent2
.94c7					_FASEExit:
.94c7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/compare.asm

.94c8					CompareFloat:
.94c8	20 42 94	jsr $9442			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.94cb	b5 60		lda $60,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.94cd	29 f8		and #$f8			and 	#$F8
.94cf	15 68		ora $68,x			ora 	NSMantissa2,x
.94d1	15 70		ora $70,x			ora 	NSMantissa3,x
.94d3	f0 08		beq $94dd			beq 	_FCExit 					; zero, so approximately identical
.94d5	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.94d7	34 50		bit $50,x			bit 	NSStatus,x
.94d9	10 02		bpl $94dd			bpl 	_FCExit
.94db					_FCNegative:
.94db	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.94dd					_FCExit:
.94dd	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/divide.asm

.94de					FDivideCommand:
.94de	fa		plx				plx	 								; restore stack position
.94df	20 b0 95	jsr $95b0			jsr 	FloatPrepare 				; prepare for floats
.94e2					FloatDivide:
.94e2	48		pha				pha
.94e3	e8		inx				inx
.94e4	20 bf 95	jsr $95bf			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.94e7	ca		dex				dex
.94e8	c9 00		cmp #$00			cmp 	#0
.94ea	f0 1d		beq $9509			beq 	_FDZero
.94ec	20 bf 95	jsr $95bf			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.94ef	f0 16		beq $9507			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.94f1	20 e4 90	jsr $90e4			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.94f4	20 80 90	jsr $9080			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.94f7	20 bf 95	jsr $95bf			jsr		NSNormalise 				; renormalise
.94fa	20 74 91	jsr $9174			jsr 	CalculateSign 				; calculate result sign
.94fd	b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent
.94ff	38		sec				sec
.9500	f5 79		sbc $79,x			sbc 	NSExponent+1,x
.9502	38		sec				sec
.9503	e9 1e		sbc #$1e			sbc 	#30
.9505	95 78		sta $78,x			sta 	NSExponent,x
.9507					_FDExit:
.9507	68		pla				pla
.9508	60		rts				rts
.9509					_FDZero:
.9509	a9 03		lda #$03		lda	#3
.950b	4c f9 8e	jmp $8ef9		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/fractional.asm

.950e					FloatFractionalPart:
.950e	5a		phy				phy
.950f	b5 50		lda $50,x			lda 	NSStatus,x 					; take absolute value
.9511	29 7f		and #$7f			and 	#$7F
.9513	95 50		sta $50,x			sta 	NSStatus,x
.9515	20 bf 95	jsr $95bf			jsr 	NSNormalise
.9518	b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.951a	38		sec				sec
.951b	e9 e0		sbc #$e0			sbc 	#$E0
.951d	90 29		bcc $9548			bcc 	_FFPExit 					; already fractional
.951f	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.9521	b0 22		bcs $9545			bcs 	_FFPZero
.9523	a8		tay				tay 								; put count to do in Y
.9524	b5 70		lda $70,x			lda 	NSMantissa3,x 				; do each in turn.
.9526	20 4a 95	jsr $954a			jsr 	_FFPPartial
.9529	95 70		sta $70,x			sta 	NSMantissa3,x
.952b	b5 68		lda $68,x			lda 	NSMantissa2,x
.952d	20 4a 95	jsr $954a			jsr 	_FFPPartial
.9530	95 68		sta $68,x			sta 	NSMantissa2,x
.9532	b5 60		lda $60,x			lda 	NSMantissa1,x
.9534	20 4a 95	jsr $954a			jsr 	_FFPPartial
.9537	95 60		sta $60,x			sta 	NSMantissa1,x
.9539	b5 58		lda $58,x			lda 	NSMantissa0,x
.953b	20 4a 95	jsr $954a			jsr 	_FFPPartial
.953e	95 58		sta $58,x			sta 	NSMantissa0,x
.9540	20 42 9e	jsr $9e42			jsr 	NSMIsZero 					; zeroed check.
.9543	d0 03		bne $9548			bne 	_FFPExit
.9545					_FFPZero:
.9545	20 20 9e	jsr $9e20			jsr 	NSMSetZero
.9548					_FFPExit:
.9548	7a		ply				ply
.9549	60		rts				rts
.954a					_FFPPartial:
.954a	c0 00		cpy #$00			cpy 	#0 							; no more to do
.954c	f0 17		beq $9565			beq 	_FFFPPExit
.954e	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.9550	b0 0c		bcs $955e			bcs 	_FFFPPWholeByte
.9552	5a		phy				phy
.9553					_FFFPPLeft:
.9553	0a		asl a				asl 	a
.9554	88		dey				dey
.9555	d0 fc		bne $9553			bne 	_FFFPPLeft
.9557	7a		ply				ply
.9558					_FFFPPRight:
.9558	4a		lsr a				lsr 	a
.9559	88		dey				dey
.955a	d0 fc		bne $9558			bne 	_FFFPPRight
.955c	80 07		bra $9565			bra 	_FFFPPExit
.955e					_FFFPPWholeByte:
.955e	98		tya				tya 								; subtract 8 from count
.955f	38		sec				sec
.9560	e9 08		sbc #$08			sbc 	#8
.9562	a8		tay				tay
.9563	a9 00		lda #$00			lda 	#0 							; and clear all
.9565					_FFFPPExit:
.9565	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/integer.asm

.9566					FloatIntegerPart:
.9566	48		pha				pha
.9567	b5 78		lda $78,x			lda 	NSExponent,x 				; is it integer already ?
.9569	f0 1d		beq $9588			beq 	_FIPExit 					; if so do nothing
.956b	20 42 9e	jsr $9e42			jsr 	NSMIsZero 					; is it zero ?
.956e	f0 15		beq $9585			beq 	_FIPZero 					; if so return zero.
.9570	20 bf 95	jsr $95bf			jsr 	NSNormalise 				; normalise
.9573	f0 10		beq $9585			beq 	_FIPZero 					; normalised to zero, exit zero
.9575					_FIPShift:
.9575	b5 78		lda $78,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.9577	10 07		bpl $9580			bpl 	_FIPCheckZero
.9579	20 39 9e	jsr $9e39			jsr 	NSMShiftRight 				; shift mantissa right
.957c	f6 78		inc $78,x			inc 	NSExponent,x 				; bump exponent
.957e	80 f5		bra $9575			bra 	_FIPShift
.9580					_FIPCheckZero:
.9580	20 42 9e	jsr $9e42			jsr 	NSMIsZero 					; avoid -0 problem
.9583	d0 03		bne $9588			bne 	_FIPExit 					; set to zero if mantissa zero.
.9585					_FIPZero:
.9585	20 20 9e	jsr $9e20			jsr 	NSMSetZero
.9588					_FIPExit:
.9588	68		pla				pla
.9589	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/multiply.asm

.958a					FloatingPointMultiply:
.958a	20 b0 95	jsr $95b0			jsr 	FloatPrepare 				; prepare for floats
.958d					FloatMultiply:
.958d	48		pha				pha
.958e	20 bf 95	jsr $95bf			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.9591	f0 18		beq $95ab			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.9593	e8		inx				inx
.9594	20 bf 95	jsr $95bf			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.9597	ca		dex				dex
.9598	c9 00		cmp #$00			cmp 	#0
.959a	f0 0c		beq $95a8			beq 	_FDSetZero
.959c	20 36 91	jsr $9136			jsr 	MultiplyShort 				; calculate the result.
.959f	75 78		adc $78,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.95a1	18		clc				clc
.95a2	75 79		adc $79,x			adc 	NSExponent+1,x
.95a4	95 78		sta $78,x			sta 	NSExponent,x
.95a6	80 03		bra $95ab			bra 	_FDExit
.95a8					_FDSetZero:
.95a8	20 20 9e	jsr $9e20			jsr 	NSMSetZero 					; return 0
.95ab					_FDExit:
.95ab	20 bf 95	jsr $95bf			jsr 	NSNormalise 				; normalise the result
.95ae	68		pla				pla
.95af	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/utility.asm

.95b0					FloatPrepare:
.95b0	20 bb 96	jsr $96bb			jsr 	DereferenceTopTwo 			; dereference the top two values
.95b3	b5 50		lda $50,x			lda 	NSStatus,x 					; check ints/floats, either will do.
.95b5	15 51		ora $51,x			ora 	NSStatus+1,x
.95b7	29 10		and #$10			and 	#NSBIsString
.95b9	d0 01		bne $95bc			bne 	_FDType
.95bb	60		rts				rts
.95bc					_FDType:
.95bc	4c a8 9f	jmp $9fa8			jmp 	TypeError
.95bf					NSNormalise:
.95bf	b5 50		lda $50,x			lda 	NSStatus,x 					; make float, keep sign
.95c1	29 80		and #$80			and 	#$80
.95c3	09 08		ora #$08			ora 	#NSTFloat
.95c5	95 50		sta $50,x			sta 	NSStatus,x
.95c7	20 42 9e	jsr $9e42			jsr 	NSMIsZero 					; if zero exit
.95ca	d0 07		bne $95d3			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.95cc	16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.95ce	76 50		ror $50,x			ror 	NSStatus,x 					; (no -0)
.95d0	a9 00		lda #$00			lda 	#0 							; set Z flag
.95d2	60		rts				rts
.95d3					_NSNormaliseOptimise:
.95d3	b5 70		lda $70,x			lda 	NSMantissa3,x 				; upper byte zero ?
.95d5	d0 19		bne $95f0			bne 	_NSNormaliseLoop
.95d7	b5 68		lda $68,x			lda 	NSMantissa2,x 				; byte normalise
.95d9	30 15		bmi $95f0			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.95db	95 70		sta $70,x			sta 	NSMantissa3,x
.95dd	b5 60		lda $60,x			lda 	NSMantissa1,x
.95df	95 68		sta $68,x			sta 	NSMantissa2,x
.95e1	b5 58		lda $58,x			lda 	NSMantissa0,x
.95e3	95 60		sta $60,x			sta 	NSMantissa1,x
.95e5	74 58		stz $58,x			stz 	NSMantissa0,x
.95e7	b5 78		lda $78,x			lda 	NSExponent,x
.95e9	38		sec				sec
.95ea	e9 08		sbc #$08			sbc 	#8
.95ec	95 78		sta $78,x			sta 	NSExponent,x
.95ee	80 e3		bra $95d3			bra 	_NSNormaliseOptimise
.95f0					_NSNormaliseLoop:
.95f0	34 70		bit $70,x			bit 	NSMantissa3,x 				; bit 30 set ?
.95f2	70 07		bvs $95fb			bvs 	_NSNExit 					; exit if so with Z flag clear
.95f4	20 2f 9e	jsr $9e2f			jsr 	NSMShiftLeft 				; shift mantissa left
.95f7	d6 78		dec $78,x			dec 	NSExponent,x 				; adjust exponent
.95f9	80 f5		bra $95f0			bra 	_NSNormaliseLoop
.95fb					_NSNExit:
.95fb	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.95fd	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignnumber.asm

.95fe					AssignNumber:
.95fe	5a		phy				phy
.95ff	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy mantissa0/1 to zTemp0
.9601	85 36		sta $36				sta 	zTemp0
.9603	b5 60		lda $60,x			lda 	NSMantissa1,x
.9605	85 37		sta $37				sta 	zTemp0+1
.9607	b5 50		lda $50,x			lda 	NSStatus,x 					; clear reference bits
.9609	29 df		and #$df			and 	#(NSBIsReference ^ $FF)
.960b	95 50		sta $50,x			sta 	NSStatus,x
.960d	29 18		and #$18			and 	#NSBTypeMask				; assigning to a float ?
.960f	c9 08		cmp #$08			cmp 	#NSTFloat
.9611	f0 24		beq $9637			beq 	_ANFloat
.9613	b5 79		lda $79,x			lda		NSExponent+1,x 				; is it a float
.9615	f0 03		beq $961a			beq		_ANNotFloat
.9617	4c a3 9f	jmp $9fa3			jmp 	RangeError					; if it is, report an error.
.961a					_ANNotFloat:
.961a	b5 50		lda $50,x			lda 	NSStatus,x 					; check if byte/word reference.
.961c	29 03		and #$03			and 	#3
.961e	d0 05		bne $9625			bne 	_ANByteWord
.9620	20 42 96	jsr $9642			jsr 	_ANCopy4PackSign 			; copy all 4 bytes and sign
.9623	80 1b		bra $9640			bra 	_ANExit
.9625					_ANByteWord:
.9625	48		pha				pha 								; save count
.9626	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; do byte
.9628	92 36		sta ($36)			sta 	(zTemp0)
.962a	68		pla				pla
.962b	c9 01		cmp #$01			cmp	 	#1
.962d	f0 11		beq $9640			beq 	_ANExit
.962f	b5 61		lda $61,x			lda 	NSMantissa1+1,x 			; do word
.9631	a0 01		ldy #$01			ldy 	#1
.9633	91 36		sta ($36),y			sta 	(zTemp0),y
.9635	80 09		bra $9640			bra 	_ANExit
.9637					_ANFloat:
.9637	20 42 96	jsr $9642			jsr 	_ANCopy4PackSign 			; write all 4 bytes and packed sign
.963a	b5 79		lda $79,x			lda 	NSExponent+1,x 				; copy exponent to slot 4
.963c	a0 04		ldy #$04			ldy 	#4
.963e	91 36		sta ($36),y			sta 	(zTemp0),y
.9640					_ANExit:
.9640	7a		ply				ply
.9641	60		rts				rts
.9642					_ANCopy4PackSign:
.9642	a0 03		ldy #$03			ldy 	#3
.9644	b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign bit into status
.9646	29 80		and #$80			and 	#$80 						; put into high bit of mantissa 3
.9648	15 71		ora $71,x			ora 	NSMantissa3+1,x
.964a	91 36		sta ($36),y			sta 	(zTemp0),y
.964c	88		dey				dey
.964d	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.964f	91 36		sta ($36),y			sta 	(zTemp0),y
.9651	88		dey				dey
.9652	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9654	91 36		sta ($36),y			sta 	(zTemp0),y
.9656	88		dey				dey
.9657	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9659	91 36		sta ($36),y			sta 	(zTemp0),y
.965b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignstring.asm

.965c					AssignString:
.965c	5a		phy				phy
.965d	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.965f	85 38		sta $38				sta 	zTemp1
.9661	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9663	85 39		sta $39				sta 	zTemp1+1
.9665	b5 58		lda $58,x			lda 	NSMantissa0,x
.9667	85 36		sta $36				sta 	zTemp0
.9669	b5 60		lda $60,x			lda 	NSMantissa1,x
.966b	85 37		sta $37				sta 	zTemp0+1
.966d	a0 01		ldy #$01			ldy 	#1 							; the high byte of the target address
.966f	b1 36		lda ($36),y			lda 	(zTemp0),y
.9671	f0 23		beq $9696			beq 	_ASNewStringRequired 		; if zero, a new string is required.
.9673	38		sec				sec 								; put Address-2 in zsTemp - this is the size/status/string record
.9674	b2 36		lda ($36)			lda 	(zTemp0) 					; of concreted strings
.9676	e9 02		sbc #$02			sbc 	#2
.9678	85 3c		sta $3c				sta 	zsTemp
.967a	a0 01		ldy #$01			ldy 	#1
.967c	b1 36		lda ($36),y			lda 	(zTemp0),y
.967e	e9 00		sbc #$00			sbc 	#0
.9680	85 3d		sta $3d				sta 	zsTemp+1
.9682	a0 ff		ldy #$ff			ldy 	#$FF 						; get length of new string
.9684					_ASGetLength:
.9684	c8		iny				iny
.9685	b1 38		lda ($38),y			lda 	(zTemp1),y
.9687	d0 fb		bne $9684			bne 	_ASGetLength
.9689	98		tya				tya 								; is this length <= current length
.968a	d2 3c		cmp ($3c)			cmp 	(zsTemp)
.968c	90 1e		bcc $96ac			bcc 	_ASCopyString
.968e	f0 1c		beq $96ac			beq 	_ASCopyString
.9690	a9 80		lda #$80			lda 	#$80 						; mark as unused.
.9692	a0 01		ldy #$01			ldy 	#1
.9694	91 3c		sta ($3c),y			sta 	(zsTemp),y
.9696					_ASNewStringRequired:
.9696	e8		inx				inx 								; concrete the new string.
.9697	20 35 a7	jsr $a735			jsr 	StringConcrete				; (breaks zTemp1/2, not zTemp0 and zsTemp)
.969a	ca		dex				dex
.969b	18		clc				clc
.969c	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy that new address to the reference.
.969e	69 02		adc #$02			adc 	#2 							; add two to point at the data.
.96a0	92 36		sta ($36)			sta 	(zTemp0)
.96a2	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.96a4	69 00		adc #$00			adc 	#0
.96a6	a0 01		ldy #$01			ldy 	#1
.96a8	91 36		sta ($36),y			sta 	(zTemp0),y
.96aa	80 0d		bra $96b9			bra 	_ASExit
.96ac					_ASCopyString:
.96ac	a0 00		ldy #$00			ldy 	#0
.96ae					_ASCopyLoop:
.96ae	b1 38		lda ($38),y			lda 	(zTemp1),y
.96b0	c8		iny				iny
.96b1	c8		iny				iny
.96b2	91 3c		sta ($3c),y			sta 	(zsTemp),y
.96b4	88		dey				dey
.96b5	c9 00		cmp #$00			cmp 	#0
.96b7	d0 f5		bne $96ae			bne 	_ASCopyLoop
.96b9					_ASExit:
.96b9	7a		ply				ply
.96ba	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/dereference.asm

.96bb					DereferenceTopTwo:
.96bb	e8		inx				inx
.96bc	20 c0 96	jsr $96c0			jsr 	Dereference 				; deref x+1
.96bf	ca		dex				dex  								; falls through to deref x
.96c0					Dereference:
.96c0	b5 50		lda $50,x			lda 	NSStatus,x 					; get the status byte
.96c2	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.96c4	f0 48		beq $970e			beq 	_DRFExit 					; not a reference, so exit.
.96c6	5a		phy				phy
.96c7	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address to dereference into zTemp0
.96c9	85 36		sta $36				sta 	zTemp0
.96cb	b5 60		lda $60,x			lda 	NSMantissa1,x
.96cd	85 37		sta $37				sta 	zTemp0+1
.96cf	74 60		stz $60,x			stz 	NSMantissa1,x 				; clear second byte.
.96d1	b2 36		lda ($36)			lda 	(zTemp0) 					; do the first byte
.96d3	95 58		sta $58,x			sta 	NSMantissa0,x
.96d5	b5 50		lda $50,x			lda 	NSStatus,x 					; get status byte.
.96d7	29 18		and #$18			and 	#NSBTypeMask 				; what type is it ?
.96d9	c9 10		cmp #$10			cmp 	#NSTString 					; if string, dereference two
.96db	f0 0e		beq $96eb			beq 	_DRFDereferenceTwo
.96dd	c9 08		cmp #$08			cmp 	#NSTFloat 					; if float, do full dereference.
.96df	f0 2f		beq $9710			beq 	_DRFFull
.96e1	b5 50		lda $50,x			lda 	NSStatus,x 					; must be integer - how many bytes ?
.96e3	29 03		and #$03			and 	#3
.96e5	f0 29		beq $9710			beq 	_DRFFull 					; the whole word
.96e7	c9 01		cmp #$01			cmp 	#1 							; is it 10 (e.g. 2 bytes)
.96e9	f0 06		beq $96f1			beq		_DRFClear23 				; no, one byte, clear 2 & 3 and exit
.96eb					_DRFDereferenceTwo:
.96eb	a0 01		ldy #$01			ldy 	#1
.96ed	b1 36		lda ($36),y			lda 	(zTemp0),y
.96ef	95 60		sta $60,x			sta 	NSMantissa1,x
.96f1					_DRFClear23:
.96f1	74 68		stz $68,x			stz 	NSMantissa2,x 				; clear upper bytes, only read 1 or 2 bytes
.96f3	74 70		stz $70,x			stz 	NSMantissa3,x
.96f5	b5 50		lda $50,x			lda 	NSStatus,x 					; make it a value of that type.
.96f7	29 18		and #$18			and 	#NSBTypeMask
.96f9	95 50		sta $50,x			sta 	NSStatus,x 					; and fall through.
.96fb	c9 10		cmp #$10			cmp 	#NSTString  				; is it a string
.96fd	d0 0e		bne $970d			bne 	_DRFNotString
.96ff	b5 58		lda $58,x			lda 	NSMantissa0,x 				; check address is zero
.9701	15 60		ora $60,x			ora 	NSMantissa1,x
.9703	d0 08		bne $970d			bne 	_DRFNotString
.9705	a9 0f		lda #$0f			lda 	#_DRFNullString & $FF 		; if so, return reference to ""
.9707	95 58		sta $58,x			sta 	NSMantissa0,X
.9709	a9 97		lda #$97			lda 	#_DRFNullString >> 8
.970b	95 60		sta $60,x			sta 	NSMantissa1,X
.970d					_DRFNotString
.970d	7a		ply				ply 								; restore Y and exit
.970e					_DRFExit:
.970e	60		rts				rts
.970f					_DRFNullString:
>970f	00						.byte 	0
.9710					_DRFFull:
.9710	a0 01		ldy #$01			ldy 	#1 							; get remaining 3 bytes.
.9712	b1 36		lda ($36),y			lda 	(zTemp0),y
.9714	95 60		sta $60,x			sta 	NSMantissa1,x
.9716	c8		iny				iny
.9717	b1 36		lda ($36),y			lda 	(zTemp0),y
.9719	95 68		sta $68,x			sta 	NSMantissa2,x
.971b	c8		iny				iny
.971c	b1 36		lda ($36),y			lda 	(zTemp0),y
.971e	95 70		sta $70,x			sta 	NSMantissa3,x
.9720	74 78		stz $78,x			stz 	NSExponent,x 				; clear exponent.
.9722	b5 50		lda $50,x			lda		NSStatus,x 					; see if type is integer
.9724	29 18		and #$18			and 	#NSBTypeMask  				; type information only
.9726	95 50		sta $50,x			sta 	NSStatus,x 					; update it back.
.9728	f0 05		beq $972f			beq 	_DRFNoExponent
.972a	c8		iny				iny 								; if not, read the exponent as well.
.972b	b1 36		lda ($36),y			lda 	(zTemp0),y
.972d	95 78		sta $78,x			sta 	NSExponent,x
.972f					_DRFNoExponent:
.972f	b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the most significant bit set ?
.9731	10 0a		bpl $973d			bpl 	_DRFExit2 					; if not, then exit.
.9733	29 7f		and #$7f			and 	#$7F 						; clear that bit.
.9735	95 70		sta $70,x			sta 	NSMantissa3,x
.9737	b5 50		lda $50,x			lda 	NSStatus,x 					; set the sign flag
.9739	09 80		ora #$80			ora 	#NSBIsNegative
.973b	95 50		sta $50,x			sta 	NSStatus,x
.973d					_DRFExit2:
.973d	7a		ply				ply
.973e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/number.asm

=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.973f					EncodeNumberStart:
.973f	38		sec				sec
.9740	80 01		bra $9743			bra 	EncodeNumberContinue+1
.9742					EncodeNumberContinue:
.9742	18		clc				clc
.9743					EncodeNumber:
.9743	08		php				php 								; save reset flag.
.9744	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.9746	f0 12		beq $975a			beq 	_ENIsOkay
.9748	c9 30		cmp #$30			cmp 	#"0"
.974a	90 04		bcc $9750			bcc 	_ENBadNumber
.974c	c9 3a		cmp #$3a			cmp 	#"9"+1
.974e	90 0a		bcc $975a			bcc 	_ENIsOkay
.9750					_ENBadNumber:
.9750	28		plp				plp 								; throw saved reset
.9751	ad 05 04	lda $0405			lda 	EncodeState 				; if in decimal mode, construct final number
.9754	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.9756	f0 7b		beq $97d3			beq 	_ENConstructFinal
.9758					_ENFail:
.9758	18		clc				clc 								; not allowed
.9759	60		rts				rts
.975a					_ENIsOkay:
.975a	28		plp				plp 								; are we restarting
.975b	90 15		bcc $9772			bcc 	_ENNoRestart
.975d					_ENStartEncode:
.975d	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.975f	f0 0c		beq $976d			beq 	_ENFirstDP
.9761	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.9763	20 22 9e	jsr $9e22			jsr 	NSMSetByte 					; in single byte mode.
.9766	a9 01		lda #$01			lda 	#ESTA_Low
.9768					_ENExitChange:
.9768	8d 05 04	sta $0405			sta 	EncodeState 				; save new state
.976b	38		sec				sec
.976c	60		rts				rts
.976d					_ENFirstDP:
.976d	20 20 9e	jsr $9e20			jsr 	NSMSetZero 					; clear integer part
.9770	80 3c		bra $97ae			bra 	_ESTASwitchFloat			; go straight to float and exi
.9772					_ENNoRestart:
.9772	48		pha				pha 								; save digit or DP on stack.
.9773	ad 05 04	lda $0405			lda 	EncodeState 				; get current state
.9776	c9 01		cmp #$01			cmp 	#ESTA_Low
.9778	f0 09		beq $9783			beq  	_ESTALowState
.977a	c9 02		cmp #$02			cmp 	#ESTA_High
.977c	f0 26		beq $97a4			beq 	_ESTAHighState
.977e	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.9780	f0 38		beq $97ba			beq 	_ESTADecimalState
>9782	db						.byte 	$DB 						; causes a break in the emulator
.9783					_ESTALowState:
.9783	68		pla				pla 								; get value back
.9784	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.9786	f0 26		beq $97ae			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.9788	29 0f		and #$0f			and 	#15 						; make digit
.978a	8d 06 04	sta $0406			sta 	DigitTemp 					; save it.
.978d	b5 58		lda $58,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.978f	0a		asl a				asl 	a
.9790	0a		asl a				asl 	a
.9791	75 58		adc $58,x			adc 	NSMantissa0,x
.9793	0a		asl a				asl 	a
.9794	6d 06 04	adc $0406			adc 	DigitTemp
.9797	95 58		sta $58,x			sta 	NSMantissa0,x
.9799	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.979b	90 05		bcc $97a2			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.979d	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.979f	8d 05 04	sta $0405			sta 	EncodeState
.97a2					_ESTANoSwitch:
.97a2	38		sec				sec
.97a3	60		rts				rts
.97a4					_ESTAHighState:
.97a4	68		pla				pla 								; get value back
.97a5	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.97a7	f0 05		beq $97ae			beq 	_ESTASwitchFloat
.97a9	20 07 98	jsr $9807			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.97ac	38		sec				sec
.97ad	60		rts				rts
.97ae					_ESTASwitchFloat:
.97ae	9c 07 04	stz $0407			stz 	DecimalCount 				; reset the count of digits - we divide by 10^n at the end.
.97b1	e8		inx				inx 								; zero the decimal additive.
.97b2	20 20 9e	jsr $9e20			jsr 	NSMSetZero
.97b5	ca		dex				dex
.97b6	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.97b8	80 ae		bra $9768			bra 	_ENExitChange
.97ba					_ESTADecimalState:
.97ba	68		pla				pla 								; digit.
.97bb	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 2nd decimal point.
.97bd	f0 99		beq $9758			beq 	_ENFail
.97bf	e8		inx				inx 								; put digit into fractional part of X+1
.97c0	20 07 98	jsr $9807			jsr 	ESTAShiftDigitIntoMantissa
.97c3	ca		dex				dex
.97c4	ee 07 04	inc $0407			inc 	DecimalCount 				; bump the count of decimals
.97c7	ad 07 04	lda $0407			lda 	DecimalCount 				; too many decimal digits.
.97ca	c9 0b		cmp #$0b			cmp 	#11
.97cc	f0 02		beq $97d0			beq 	_ESTADSFail
.97ce	38		sec				sec
.97cf	60		rts				rts
.97d0					_ESTADSFail:
.97d0	4c a3 9f	jmp $9fa3			jmp 	RangeError
.97d3					_ENConstructFinal:
.97d3	ad 07 04	lda $0407			lda 	DecimalCount 				; get decimal count
.97d6	f0 2d		beq $9805			beq 	_ENCFExit 					; no decimals
.97d8	5a		phy				phy
.97d9	0a		asl a				asl 	a 							; x 4 and CLC
.97da	0a		asl a				asl 	a
.97db	6d 07 04	adc $0407			adc 	DecimalCount
.97de	a8		tay				tay
.97df	b9 62 9f	lda $9f62,y			lda 	DecimalScalarTable-5,y 		; copy decimal scalar to X+2
.97e2	95 5a		sta $5a,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.97e4	b9 63 9f	lda $9f63,y			lda 	DecimalScalarTable-5+1,y
.97e7	95 62		sta $62,x			sta 	NSMantissa1+2,x
.97e9	b9 64 9f	lda $9f64,y			lda 	DecimalScalarTable-5+2,y
.97ec	95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.97ee	b9 65 9f	lda $9f65,y			lda 	DecimalScalarTable-5+3,y
.97f1	95 72		sta $72,x			sta 	NSMantissa3+2,x
.97f3	b9 66 9f	lda $9f66,y			lda 	DecimalScalarTable-5+4,y
.97f6	95 7a		sta $7a,x			sta 	NSExponent+2,x
.97f8	a9 08		lda #$08			lda 	#NSTFloat
.97fa	95 52		sta $52,x			sta 	NSStatus+2,x
.97fc	7a		ply				ply
.97fd	e8		inx				inx 								; multiply decimal const by decimal scalar
.97fe	20 8d 95	jsr $958d			jsr 	FloatMultiply
.9801	ca		dex				dex
.9802	20 48 94	jsr $9448			jsr 	FloatAdd 					; add to integer part.
.9805					_ENCFExit:
.9805	18		clc				clc 								; reject the digit.
.9806	60		rts				rts
.9807					ESTAShiftDigitIntoMantissa:
.9807	29 0f		and #$0f			and 	#15 						; save digit
.9809	48		pha				pha
.980a	b5 70		lda $70,x			lda 	NSMantissa3,x 				; push mantissa on stack
.980c	48		pha				pha
.980d	b5 68		lda $68,x			lda 	NSMantissa2,x
.980f	48		pha				pha
.9810	b5 60		lda $60,x			lda 	NSMantissa1,x
.9812	48		pha				pha
.9813	b5 58		lda $58,x			lda 	NSMantissa0,x
.9815	48		pha				pha
.9816	20 2f 9e	jsr $9e2f			jsr 	NSMShiftLeft 				; x 2
.9819	20 2f 9e	jsr $9e2f			jsr 	NSMShiftLeft 				; x 4
.981c	18		clc				clc 								; pop mantissa and add
.981d	68		pla				pla
.981e	75 58		adc $58,x			adc 	NSMantissa0,x
.9820	95 58		sta $58,x			sta 	NSMantissa0,x
.9822	68		pla				pla
.9823	75 60		adc $60,x			adc 	NSMantissa1,x
.9825	95 60		sta $60,x			sta 	NSMantissa1,x
.9827	68		pla				pla
.9828	75 68		adc $68,x			adc 	NSMantissa2,x
.982a	95 68		sta $68,x			sta 	NSMantissa2,x
.982c	68		pla				pla
.982d	75 70		adc $70,x			adc 	NSMantissa3,x
.982f	95 70		sta $70,x			sta 	NSMantissa3,x 				; x 5
.9831	20 2f 9e	jsr $9e2f			jsr 	NSMShiftLeft 				; x 10
.9834	68		pla				pla 								; add digit
.9835	18		clc				clc
.9836	75 58		adc $58,x			adc 	NSMantissa0,x
.9838	95 58		sta $58,x			sta 	NSMantissa0,x
.983a	90 0a		bcc $9846			bcc 	_ESTASDExit
.983c	f6 60		inc $60,x			inc 	NSMantissa1,x
.983e	d0 06		bne $9846			bne 	_ESTASDExit
.9840	f6 68		inc $68,x			inc 	NSMantissa2,x
.9842	d0 02		bne $9846			bne 	_ESTASDExit
.9844	f6 70		inc $70,x			inc 	NSMantissa3,x
.9846					_ESTASDExit:
.9846	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/term.asm

.9847					EvaluateTerm:
.9847	b1 30		lda ($30),y			lda 	(codePtr),y
.9849	30 18		bmi $9863			bmi 	_ETCheckUnary 				; unary function ? (text ones)
.984b	c9 40		cmp #$40			cmp 	#$40 						; 40-7F => identifier reference
.984d	b0 6c		bcs $98bb			bcs 	_ETVariable
.984f	c9 30		cmp #$30			cmp 	#'0' 						; is it a number
.9851	90 6b		bcc $98be			bcc 	_ETPuncUnary 				; if not it might be a punctuation unary.
.9853	c9 3a		cmp #$3a			cmp 	#'9'+1
.9855	b0 67		bcs $98be			bcs 	_ETPuncUnary
.9857	20 3f 97	jsr $973f			jsr 	EncodeNumberStart 			; can't fail as it's 0-9 !
.985a					_ETNumber:
.985a	c8		iny				iny 								; keep encoding until we have the numbers
.985b	b1 30		lda ($30),y			lda 	(codePtr),y
.985d	20 42 97	jsr $9742			jsr 	EncodeNumberContinue
.9860	b0 f8		bcs $985a			bcs 	_ETNumber 					; go back if accepted.
.9862	60		rts				rts
.9863					_ETCheckUnary:
.9863	c9 ff		cmp #$ff			cmp 	#KWC_STRING 				; string token
.9865	f0 3f		beq $98a6			beq 	_ETString
.9867	c9 fe		cmp #$fe			cmp 	#KWC_HEXCONST 				; hex constant.
.9869	f0 12		beq $987d			beq 	_ETHexConstant
.986b	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; check it actually is a unary function
.986d	90 0b		bcc $987a			bcc 	_ETSyntaxError
.986f	c9 a2		cmp #$a2			cmp 	#KWC_LAST_UNARY+1
.9871	b0 07		bcs $987a			bcs 	_ETSyntaxError
.9873	da		phx				phx 								; push X on the stack
.9874	0a		asl a				asl 	a 							; put vector x 2 into X
.9875	aa		tax				tax
.9876	c8		iny				iny 								; consume unary function token
.9877	7c 90 8c	jmp ($8c90,x)			jmp 	(VectorSet0,x) 				; and do it.
.987a					_ETSyntaxError:
.987a	4c 9e 9f	jmp $9f9e			jmp 	SyntaxError
.987d					_ETHexConstant:
.987d	c8		iny				iny 								; skip #
.987e	c8		iny				iny 								; skip count
.987f	20 20 9e	jsr $9e20			jsr 	NSMSetZero 					; clear result
.9882					_ETHLoop:
.9882	b1 30		lda ($30),y			lda 	(codePtr),y
.9884	c8		iny				iny 								; and consume
.9885	c9 00		cmp #$00			cmp 	#0 							; exit if zero
.9887	f0 1c		beq $98a5			beq 	_ETHExit
.9889	48		pha				pha 								; save on stack.
.988a	20 2f 9e	jsr $9e2f			jsr 	NSMShiftLeft 				; x 2
.988d	20 2f 9e	jsr $9e2f			jsr 	NSMShiftLeft 				; x 4
.9890	20 2f 9e	jsr $9e2f			jsr 	NSMShiftLeft 				; x 8
.9893	20 2f 9e	jsr $9e2f			jsr 	NSMShiftLeft 				; x 16
.9896	68		pla				pla 								; ASCII
.9897	c9 41		cmp #$41			cmp 	#'A'
.9899	90 02		bcc $989d			bcc 	_ETHNotChar
.989b	e9 07		sbc #$07			sbc 	#7
.989d					_ETHNotChar:
.989d	29 0f		and #$0f			and 	#15 						; digit now
.989f	15 58		ora $58,x			ora 	NSMantissa0,x 				; put in LS Nibble
.98a1	95 58		sta $58,x			sta 	NSMantissa0,x
.98a3	80 dd		bra $9882			bra 	_ETHLoop 					; go round.
.98a5					_ETHExit:
.98a5	60		rts				rts
.98a6					_ETString:
.98a6	c8		iny				iny 								; look at length
.98a7	b1 30		lda ($30),y			lda 	(codePtr),y
.98a9	48		pha				pha
.98aa	c8		iny				iny 								; first character
.98ab	20 8b a5	jsr $a58b			jsr 	MemoryInline 				; put address of string at (code-Ptr),y on stack
.98ae	68		pla				pla 								; restore count and save
.98af	85 36		sta $36				sta 	zTemp0
.98b1	98		tya				tya 								; add length to Y to skip it.
.98b2	18		clc				clc
.98b3	65 36		adc $36				adc 	zTemp0
.98b5	a8		tay				tay
.98b6	a9 10		lda #$10			lda 	#NSTString 					; mark as string
.98b8	95 50		sta $50,x			sta 	NSStatus,x
.98ba	60		rts				rts
.98bb					_ETVariable:
.98bb	4c 10 99	jmp $9910			jmp 	VariableHandler
.98be					_ETPuncUnary:
.98be	c8		iny				iny 								; consume the unary character
.98bf	c9 2d		cmp #$2d			cmp 	#KWD_MINUS 					; unary minus
.98c1	f0 2b		beq $98ee			beq 	_ETUnaryNegate
.98c3	c9 10		cmp #$10			cmp 	#KWD_AT 					; @ reference -> constant
.98c5	f0 36		beq $98fd			beq 	_ETDereference
.98c7	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; parenthesis
.98c9	f0 3e		beq $9909			beq 	_ETParenthesis
.98cb	64 36		stz $36				stz 	zTemp0 						; zTemp0 is the indirection level.
.98cd	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; byte indirection (0) ?
.98cf	f0 06		beq $98d7			beq 	_ETIndirection
.98d1	e6 36		inc $36				inc 	zTemp0
.98d3	c9 21		cmp #$21			cmp 	#KWD_PLING					; word indirection (1) \
.98d5	d0 a3		bne $987a			bne 	_ETSyntaxError
.98d7					_ETIndirection:
.98d7	a5 36		lda $36				lda 	zTemp0 						; push indirection amount (0-1) => (1-2) on the stack
.98d9	1a		inc a				inc 	a
.98da	48		pha				pha
.98db	20 47 98	jsr $9847			jsr 	EvaluateTerm				; evaluate the term
.98de	20 c0 96	jsr $96c0			jsr 	Dereference 				; dereference it.
.98e1	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a +ve integer.
.98e3	d0 06		bne $98eb			bne 	_ETTypeMismatch
.98e5	68		pla				pla 								; indirection 1-2
.98e6	09 20		ora #$20			ora 	#NSBIsReference 			; make it a reference.
.98e8	95 50		sta $50,x			sta 	NSStatus,x
.98ea	60		rts				rts
.98eb					_ETTypeMismatch:
.98eb	4c a8 9f	jmp $9fa8			jmp 	TypeError
.98ee					_ETUnaryNegate:
.98ee	20 47 98	jsr $9847			jsr 	EvaluateTerm				; evaluate the term
.98f1	20 c0 96	jsr $96c0			jsr 	Dereference 				; dereference it.
.98f4	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a number
.98f6	29 10		and #$10			and 	#NSTString
.98f8	d0 f1		bne $98eb			bne 	_ETTypeMismatch
.98fa	4c e2 9d	jmp $9de2			jmp 	NSMNegate  					; just toggles the sign bit.
.98fd					_ETDereference:
.98fd	20 47 98	jsr $9847			jsr 	EvaluateTerm				; evaluate the term
.9900	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a reference
.9902	29 20		and #$20			and 	#NSBIsReference
.9904	f0 e5		beq $98eb			beq 	_ETTypeMismatch
.9906	74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer address
.9908	60		rts				rts
.9909					_ETParenthesis:
.9909	20 fd 93	jsr $93fd			jsr 	EvaluateExpression 			; evaluate here, from lowest precedence
.990c	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket 			; check for )
.990f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/variable.asm

.9910					VariableHandler:
.9910	b1 30		lda ($30),y			lda 	(codePtr),y
.9912	18		clc				clc
.9913	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.9915	85 37		sta $37				sta 	zTemp0+1
.9917	c8		iny				iny
.9918	b1 30		lda ($30),y			lda 	(codePtr),y
.991a	85 36		sta $36				sta 	zTemp0
.991c	c8		iny				iny
.991d	18		clc				clc									; copy variable address+3 to mantissa
.991e	69 03		adc #$03			adc 	#3 							; this is the address of the data.
.9920	95 58		sta $58,x			sta 	NSMantissa0,x
.9922	a5 37		lda $37				lda 	zTemp0+1
.9924	69 00		adc #$00			adc 	#0
.9926	95 60		sta $60,x			sta 	NSMantissa1,x
.9928	74 68		stz $68,x			stz 	NSMantissa2,x
.992a	74 70		stz $70,x			stz 	NSMantissa3,x
.992c	74 78		stz $78,x			stz 	NSExponent,x
.992e	5a		phy				phy
.992f	a0 02		ldy #$02			ldy 	#2 							; read type
.9931	b1 36		lda ($36),y			lda 	(zTemp0),y
.9933	7a		ply				ply
.9934	29 1c		and #$1c			and 	#NSBTypeMask+NSBIsArray 	; get type information
.9936	09 20		ora #$20			ora 	#NSBIsReference 			; make a reference.
.9938	95 50		sta $50,x			sta 	NSStatus,x
.993a	29 04		and #$04			and 	#NSBIsArray
.993c	d0 01		bne $993f			bne 	_VHArray
.993e	60		rts				rts
.993f					_VHArray:
.993f	e8		inx				inx
.9940	20 bb 9d	jsr $9dbb			jsr 	Evaluate8BitInteger 		; get the 1st index.
.9943	a9 ff		lda #$ff			lda 	#$FF 						; set Status of X+2 to a duff value so we know if we picked it up.
.9945	95 51		sta $51,x			sta 	NSStatus+1,x
.9947	b1 30		lda ($30),y			lda 	(codePtr),y
.9949	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.994b	d0 06		bne $9953			bne 	_VHNoSecondIndex
.994d	c8		iny				iny 								; skip the comma
.994e	e8		inx				inx
.994f	20 bb 9d	jsr $9dbb			jsr 	Evaluate8BitInteger 		; get the 2nd index.
.9952	ca		dex				dex
.9953					_VHNoSecondIndex:
.9953	ca		dex				dex 								; set X back.
.9954	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket 			; and check the right bracket.
.9957	5a		phy				phy 								; save position
.9958	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy record address to zaTemp
.995a	85 3e		sta $3e				sta 	zaTemp
.995c	b5 60		lda $60,x			lda 	NSMantissa1,x
.995e	85 3f		sta $3f				sta 	zaTemp+1
.9960	a0 02		ldy #$02			ldy 	#2 							; check first index is not-zero, e.g. array defined
.9962	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9964	f0 5d		beq $99c3			beq 	_VHBadArray
.9966	a0 03		ldy #$03			ldy 	#3 							; get the second index - which is 0 if there is one index.
.9968	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.996a	f0 02		beq $996e			beq 	_VHHas2Mask
.996c	a9 ff		lda #$ff			lda 	#$FF
.996e					_VHHas2Mask:
.996e	d5 52		cmp $52,x			cmp 	NSStatus+2,x 				; so if they are the same there are the wrong number of indices
.9970	f0 4c		beq $99be			beq 	_VHBadIndex
.9972	0a		asl a				asl 	a 							; carry will be set if a second index
.9973	90 08		bcc $997d			bcc 	_VHCheckFirstIndex
.9975	a0 03		ldy #$03			ldy 	#3 			 				; check the 2nd size >= 2nd index
.9977	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9979	d5 5a		cmp $5a,x			cmp 	NSMantissa0+2,x
.997b	90 41		bcc $99be			bcc 	_VHBadIndex
.997d					_VHCheckFirstIndex:
.997d	a0 02		ldy #$02			ldy 	#2 			 				; check the 2nd size >= 2nd index
.997f	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9981	d5 59		cmp $59,x			cmp 	NSMantissa0+1,x
.9983	90 39		bcc $99be			bcc 	_VHBadIndex
.9985	64 36		stz $36				stz 	zTemp0 						; clear zTemp0 (if 1 index)
.9987	64 37		stz $37				stz 	zTemp0+1
.9989	b5 52		lda $52,x			lda 	NSStatus+2,x 				; if only one index provided, don't need to multiply
.998b	30 0e		bmi $999b			bmi 	_VHNoMultiply
.998d	da		phx				phx
.998e	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; get 2nd index on stack
.9990	48		pha				pha
.9991	a0 02		ldy #$02			ldy 	#2 							; get 1st size in A
.9993	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9995	1a		inc a				inc 	a 							; add 1 for zero base
.9996	fa		plx				plx
.9997	20 cb 9d	jsr $9dcb			jsr 	Multiply8x8 				; calculate -> Z0
.999a	fa		plx				plx
.999b					_VHNoMultiply:
.999b	18		clc				clc
.999c	a5 36		lda $36				lda 	zTemp0
.999e	75 59		adc $59,x			adc 	NSMantissa0+1,x
.99a0	85 36		sta $36				sta 	zTemp0
.99a2	a5 37		lda $37				lda 	zTemp0+1
.99a4	69 00		adc #$00			adc 	#0
.99a6	85 37		sta $37				sta 	zTemp0+1
.99a8	b5 50		lda $50,x			lda 	NSStatus,x
.99aa	20 70 85	jsr $8570			jsr 	ScaleByBaseType
.99ad	18		clc				clc
.99ae	b2 3e		lda ($3e)			lda 	(zaTemp)
.99b0	65 36		adc $36				adc 	zTemp0
.99b2	95 58		sta $58,x			sta 	NSMantissa0,x
.99b4	a0 01		ldy #$01			ldy 	#1
.99b6	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99b8	65 37		adc $37				adc 	zTemp0+1
.99ba	95 60		sta $60,x			sta 	NSMantissa1,x
.99bc	7a		ply				ply 								; restore position
.99bd	60		rts				rts
.99be					_VHBadIndex:
.99be	a9 17		lda #$17		lda	#23
.99c0	4c f9 8e	jmp $8ef9		jmp	ErrorHandler
.99c3					_VHBadArray:
.99c3	a9 18		lda #$18		lda	#24
.99c5	4c f9 8e	jmp $8ef9		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/abs.asm

.99c8					AbsUnary:
.99c8	fa		plx				plx 								; restore stack pos
.99c9	20 6e 9d	jsr $9d6e			jsr 	EvaluateNumber 				; get a float or int
.99cc	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket
.99cf	b5 50		lda $50,x			lda 	NSStatus,x 					; clear the sign bit
.99d1	29 7f		and #$7f			and 	#$7F
.99d3	95 50		sta $50,x			sta 	NSStatus,x
.99d5	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/alloc.asm

.99d6					AllocUnary:
.99d6	fa		plx				plx 								; restore stack pos
.99d7	20 a0 9d	jsr $9da0			jsr 	Evaluate16BitInteger		; get bytes required.
.99da	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket
.99dd	da		phx				phx 								; save X/Y
.99de	5a		phy				phy
.99df	8a		txa				txa 								; copy X into Y
.99e0	a8		tay				tay
.99e1	b9 60 00	lda $0060,y			lda		NSMantissa1,y 				; get size into XA
.99e4	aa		tax				tax
.99e5	b9 58 00	lda $0058,y			lda 	NSMantissa0,y
.99e8	20 f5 99	jsr $99f5			jsr 	AllocateXABytes 			; allocate memory
.99eb	99 58 00	sta $0058,y			sta 	NSMantissa0,y 				; write address out.
.99ee	8a		txa				txa 	 							; typing is 16 bit integer.
.99ef	99 60 00	sta $0060,y			sta 	NSMantissa1,y
.99f2	7a		ply				ply
.99f3	fa		plx				plx
.99f4	60		rts				rts
.99f5					AllocateXABytes:
.99f5	5a		phy				phy
.99f6	ac 0c 04	ldy $040c			ldy 	lowMemPtr 					; push current address on stack and to zTemp0
.99f9	84 36		sty $36				sty 	zTemp0
.99fb	5a		phy				phy
.99fc	ac 0d 04	ldy $040d			ldy 	lowMemPtr+1
.99ff	84 37		sty $37				sty 	zTemp0+1
.9a01	5a		phy				phy
.9a02	18		clc				clc 								; add to low memory pointer
.9a03	6d 0c 04	adc $040c			adc 	lowMemPtr
.9a06	8d 0c 04	sta $040c			sta 	lowMemPtr
.9a09	8a		txa				txa
.9a0a	6d 0d 04	adc $040d			adc 	lowMemPtr+1
.9a0d	8d 0d 04	sta $040d			sta 	lowMemPtr+1
.9a10	b0 2f		bcs $9a41			bcs 	CISSMemory
.9a12	20 33 9a	jsr $9a33			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.9a15					_ClearMemory:
.9a15	ad 0c 04	lda $040c			lda 	lowMemPtr 					; cleared all memory allocated
.9a18	c5 36		cmp $36				cmp 	zTemp0
.9a1a	d0 07		bne $9a23			bne 	_CMClearNext
.9a1c	ad 0d 04	lda $040d			lda 	lowMemPtr+1
.9a1f	c5 37		cmp $37				cmp 	zTemp0+1
.9a21	f0 0c		beq $9a2f			beq 	_CMExit
.9a23					_CMClearNext:
.9a23	a9 00		lda #$00			lda 	#0 							; clear byte, advance to next.
.9a25	92 36		sta ($36)			sta 	(zTemp0)
.9a27	e6 36		inc $36				inc 	zTemp0
.9a29	d0 ea		bne $9a15			bne 	_ClearMemory
.9a2b	e6 37		inc $37				inc		zTemp0+1
.9a2d	80 e6		bra $9a15			bra 	_ClearMemory
.9a2f					_CMExit:
.9a2f	fa		plx				plx
.9a30	68		pla				pla
.9a31	7a		ply				ply
.9a32	60		rts				rts
.9a33					CheckIdentifierStringSpace:
.9a33	48		pha				pha
.9a34	ad 0d 04	lda $040d			lda 	lowMemPtr+1 				; get low memory pointer
.9a37	18		clc				clc
.9a38	69 02		adc #$02			adc 	#2 							; need at least 2 256 byte pages
.9a3a	cd 0f 04	cmp $040f			cmp 	StringMemory+1 				; is it >= StringMemory
.9a3d	b0 02		bcs $9a41			bcs 	CISSMemory
.9a3f	68		pla				pla
.9a40	60		rts				rts
.9a41					CISSMemory:
.9a41	a9 06		lda #$06		lda	#6
.9a43	4c f9 8e	jmp $8ef9		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/asc.asm

.9a46					AscUnary:
.9a46	fa		plx				plx 								; restore stack pos
.9a47	20 78 9d	jsr $9d78			jsr 	EvaluateString 				; get a string
.9a4a	b2 36		lda ($36)			lda 	(zTemp0)					; get/return first character
.9a4c	20 22 9e	jsr $9e22			jsr 	NSMSetByte 					; ASC("") will return zero.
.9a4f	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket
.9a52	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/deekpeek.asm

.9a53					PeekUnary:
.9a53	18		clc				clc
.9a54	80 01		bra $9a57			bra 	DPUnary
.9a56					DeekUnary:
.9a56	38		sec				sec
.9a57					DPUnary:
.9a57	fa		plx				plx 								; restore position.
.9a58	08		php				php									; save on stack, CS = Deek, CC = Peek
.9a59	20 a0 9d	jsr $9da0			jsr		Evaluate16BitInteger 		; address as constant.
.9a5c	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket
.9a5f	28		plp				plp 								; function back.
.9a60	a9 21		lda #$21			lda 	#NSBIsReference+NSTInteger+1 ; 1 byte read
.9a62	90 01		bcc $9a65			bcc 	_DPUpdate
.9a64	1a		inc a				inc 	a 							; 2 byte read
.9a65					_DPUpdate:
.9a65	95 50		sta $50,x			sta 	NSStatus,x 					; set to 1/2 byte reference.
.9a67	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/frac.asm

.9a68					FracUnary:
.9a68	fa		plx				plx 								; restore stack pos
.9a69	20 6e 9d	jsr $9d6e			jsr 	EvaluateNumber 				; get a float or int
.9a6c	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket
.9a6f	b5 50		lda $50,x			lda 	NSStatus,x
.9a71	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9a73	f0 04		beq $9a79			beq 	_IUZero
.9a75	20 0e 95	jsr $950e			jsr 	FloatFractionalPart 		; if so, get the fractional part.
.9a78	60		rts				rts
.9a79					_IUZero:
.9a79	20 20 9e	jsr $9e20			jsr 	NSMSetZero
.9a7c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/int.asm

.9a7d					IntUnary:
.9a7d	fa		plx				plx 								; restore stack pos
.9a7e	20 6e 9d	jsr $9d6e			jsr 	EvaluateNumber 				; get a float or int
.9a81	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket
.9a84	b5 50		lda $50,x			lda 	NSStatus,x
.9a86	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9a88	f0 03		beq $9a8d			beq 	_IUExit
.9a8a	20 66 95	jsr $9566			jsr 	FloatIntegerPart 			; if it is get the integer part.
.9a8d					_IUExit:
.9a8d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/len.asm

.9a8e					LenUnary:
.9a8e	fa		plx				plx 								; restore stack pos
.9a8f	20 78 9d	jsr $9d78			jsr 	EvaluateString 				; get a string
.9a92	5a		phy				phy
.9a93	a0 00		ldy #$00			ldy 	#0 							; find length
.9a95					_LenFind:
.9a95	b1 36		lda ($36),y			lda 	(zTemp0),y 					; look for trailing NULL.
.9a97	f0 06		beq $9a9f			beq 	_LenExit
.9a99	c8		iny				iny
.9a9a	d0 f9		bne $9a95			bne 	_LenFind
.9a9c	4c a3 9f	jmp $9fa3			jmp 	RangeError 					; string > 255 - no trailing NULL.
.9a9f					_LenExit:
.9a9f	98		tya				tya		 							; return length
.9aa0	20 22 9e	jsr $9e22			jsr 	NSMSetByte
.9aa3	7a		ply				ply
.9aa4	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket
.9aa7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/minmax.asm

.9aa8					Unary_Min:
.9aa8	a9 01		lda #$01			lda 	#1
.9aaa	80 02		bra $9aae			bra 	UnaryMinMaxMain
.9aac					Unary_Max:
.9aac	a9 ff		lda #$ff			lda 	#$FF 						; value from comparator to cause a write
.9aae					UnaryMinMaxMain:
.9aae	fa		plx				plx 								; get index on number stack
.9aaf	48		pha				pha 								; save comparator
.9ab0	20 65 9d	jsr $9d65			jsr 	EvaluateValue 				; get the first value.
.9ab3					_UMMMLoop:
.9ab3	b1 30		lda ($30),y			lda 	(codePtr),y
.9ab5	c9 29		cmp #$29			cmp 	#KWD_RPAREN 				; if right bracket then done.
.9ab7	f0 22		beq $9adb			beq 	_UMMMDone
.9ab9	20 e8 8e	jsr $8ee8			jsr 	CheckComma 					; must be a comma
.9abc	e8		inx				inx
.9abd	20 65 9d	jsr $9d65			jsr 	EvaluateValue
.9ac0	ca		dex				dex
.9ac1	20 03 9e	jsr $9e03			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] (Compare is destructive)
.9ac4	e8		inx				inx
.9ac5	20 03 9e	jsr $9e03			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2], original
.9ac8	e8		inx				inx
.9ac9	20 b0 8f	jsr $8fb0			jsr 	CompareBaseCode 			; part of > = < etc. code, returns 255,0 or 1
.9acc	ca		dex				dex
.9acd	ca		dex				dex
.9ace	85 36		sta $36				sta 	zTemp0 						; save required result
.9ad0	68		pla				pla 								; get and save comparator
.9ad1	48		pha				pha
.9ad2	c5 36		cmp $36				cmp 	zTemp0 						; if the comparator
.9ad4	d0 dd		bne $9ab3			bne 	_UMMMLoop
.9ad6	20 de 9a	jsr $9ade			jsr 	ExpCopyAboveDown 			; copy next up slot down
.9ad9	80 d8		bra $9ab3			bra 	_UMMMLoop
.9adb					_UMMMDone:
.9adb	68		pla				pla 								; throw the comparator
.9adc	c8		iny				iny 								; skip )
.9add	60		rts				rts
.9ade					ExpCopyAboveDown:
.9ade	b5 51		lda $51,x			lda 	NSStatus+1,x
.9ae0	95 50		sta $50,x			sta 	NSStatus,x
.9ae2	b5 79		lda $79,x			lda 	NSExponent+1,x
.9ae4	95 78		sta $78,x			sta 	NSExponent,x
.9ae6	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9ae8	95 58		sta $58,x			sta 	NSMantissa0,x
.9aea	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9aec	95 60		sta $60,x			sta 	NSMantissa1,x
.9aee	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.9af0	95 68		sta $68,x			sta 	NSMantissa2,x
.9af2	b5 71		lda $71,x			lda 	NSMantissa3+1,x
.9af4	95 70		sta $70,x			sta 	NSMantissa3,x
.9af6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/not.asm

.9af7					Unary_Not:
.9af7	fa		plx				plx
.9af8	20 8d 9d	jsr $9d8d			jsr 	EvaluateInteger 			; get integer
.9afb	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket
.9afe	20 42 9e	jsr $9e42			jsr 	NSMIsZero 					; zero mantissa ?
.9b01	f0 04		beq $9b07			beq 	_NotZero
.9b03	20 20 9e	jsr $9e20			jsr 	NSMSetZero
.9b06	60		rts				rts
.9b07					_NotZero:
.9b07	4c 66 8f	jmp $8f66			jmp 	ReturnTrue

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/rnd.asm

.9b0a					Unary_Random:
.9b0a	fa		plx				plx
.9b0b	20 7c 9b	jsr $9b7c			jsr 	Random32Bit 				; get a random number
.9b0e	20 65 9b	jsr $9b65			jsr 	URCopyToMantissa  			; put in mantissa
.9b11	b1 30		lda ($30),y			lda 	(codePtr),y
.9b13	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.9b15	f0 08		beq $9b1f			beq 	_URNoModulus 				; then we return a random 30 bit number.
.9b17	e8		inx				inx
.9b18	20 a0 9d	jsr $9da0			jsr 	Evaluate16BitInteger 		; put modulus value in +1
.9b1b	ca		dex				dex
.9b1c	20 b8 90	jsr $90b8			jsr 	IntegerModulusNoCheck 		; calculate modulus, so now 0 .. n-1
.9b1f					_URNoModulus:
.9b1f	74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer positive
.9b21	74 78		stz $78,x			stz 	NSExponent,x
.9b23	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket
.9b26	60		rts				rts
.9b27					Unary_Rnd:
.9b27	fa		plx				plx
.9b28	20 6e 9d	jsr $9d6e			jsr 	EvaluateNumber 				; number to use.
.9b2b	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket 			; closing bracket
.9b2e	20 42 9e	jsr $9e42			jsr 	NSMIsZero 					; if zero, then don't generate a new number
.9b31	f0 26		beq $9b59			beq 	_URCopySeed
.9b33	b5 50		lda $50,x			lda 	NSStatus,x 					; if -ve, then seed using parameter
.9b35	10 1f		bpl $9b56			bpl 	_URDontSeed
.9b37	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy - value to seed butchering it.
.9b39	49 17		eor #$17			eor 	#$17
.9b3b	8d 08 04	sta $0408			sta 	RandomSeed+0
.9b3e	b5 60		lda $60,x			lda 	NSMantissa1,x
.9b40	49 a5		eor #$a5			eor 	#$A5
.9b42	8d 09 04	sta $0409			sta 	RandomSeed+1
.9b45	b5 68		lda $68,x			lda 	NSMantissa2,x
.9b47	49 c2		eor #$c2			eor 	#$C2
.9b49	8d 0a 04	sta $040a			sta 	RandomSeed+2
.9b4c	b5 70		lda $70,x			lda 	NSMantissa3,x
.9b4e	49 9d		eor #$9d			eor 	#$9D
.9b50	8d 0b 04	sta $040b			sta 	RandomSeed+3
.9b53	20 7c 9b	jsr $9b7c			jsr 	Random32Bit
.9b56					_URDontSeed:
.9b56	20 7c 9b	jsr $9b7c			jsr 	Random32Bit 				; generate a number
.9b59					_URCopySeed:
.9b59	20 65 9b	jsr $9b65			jsr 	URCopyToMantissa 			; copy into mantissa
.9b5c	a9 e2		lda #$e2			lda 	#-30 						; force into 0-1 range
.9b5e	95 78		sta $78,x			sta 	NSExponent,x
.9b60	a9 08		lda #$08			lda 	#NSTFloat
.9b62	95 50		sta $50,x			sta 	NSStatus,x 					; positive float
.9b64	60		rts				rts
.9b65					URCopyToMantissa:
.9b65	ad 08 04	lda $0408			lda 	RandomSeed+0
.9b68	95 58		sta $58,x			sta 	NSMantissa0,x
.9b6a	ad 09 04	lda $0409			lda 	RandomSeed+1
.9b6d	95 60		sta $60,x			sta 	NSMantissa1,x
.9b6f	ad 0a 04	lda $040a			lda 	RandomSeed+2
.9b72	95 68		sta $68,x			sta 	NSMantissa2,x
.9b74	ad 0b 04	lda $040b			lda 	RandomSeed+3
.9b77	29 3f		and #$3f			and 	#$3F 						; make legal mantissa
.9b79	95 70		sta $70,x			sta 	NSMantissa3,x
.9b7b	60		rts				rts
.9b7c					Random32Bit:
.9b7c	5a		phy				phy
.9b7d	a0 07		ldy #$07			ldy 	#7 							; do it 7 times
.9b7f	ad 08 04	lda $0408			lda 	RandomSeed+0 				; check the seed isn't zero
.9b82	d0 03		bne $9b87			bne 	_Random1
.9b84	a8		tay				tay 								; if so do it 256 times
.9b85	a9 aa		lda #$aa			lda		#$AA 						; and use this to seed the seed....
.9b87					_Random1:
.9b87	0a		asl a				asl 	a 							; LSFR RNG
.9b88	2e 09 04	rol $0409			rol 	RandomSeed+1
.9b8b	2e 0a 04	rol $040a			rol 	RandomSeed+2
.9b8e	2e 0b 04	rol $040b			rol 	RandomSeed+3
.9b91	90 02		bcc $9b95			bcc 	_Random2
.9b93	49 c5		eor #$c5			eor 	#$C5
.9b95					_Random2:
.9b95	88		dey				dey
.9b96	d0 ef		bne $9b87			bne 	_Random1
.9b98	8d 08 04	sta $0408			sta 	RandomSeed+0
.9b9b	7a		ply				ply
.9b9c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/sgn.asm

.9b9d					SgnUnary:
.9b9d	fa		plx				plx 								; restore stack pos
.9b9e	20 6e 9d	jsr $9d6e			jsr 	EvaluateNumber 				; get a float or int
.9ba1	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket
.9ba4	20 42 9e	jsr $9e42			jsr 	NSMIsZero 					; if zero
.9ba7	f0 0e		beq $9bb7			beq 	_SGZero  					; return Int Zero
.9ba9	b5 50		lda $50,x			lda 	NSStatus,x 					; get status w/sign
.9bab	48		pha				pha
.9bac	a9 01		lda #$01			lda 	#1 							; set to 1
.9bae	20 22 9e	jsr $9e22			jsr 	NSMSetByte
.9bb1	68		pla				pla
.9bb2	29 80		and #$80			and		#$80 						; copy the sign byte out
.9bb4	95 50		sta $50,x			sta 	NSStatus,x  				; so it will be -1 or 1
.9bb6	60		rts				rts
.9bb7	20 20 9e	jsr $9e20	_SGZero:jsr 	NSMSetZero
.9bba	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/val.asm

.9bbb					ValUnary:
.9bbb	fa		plx				plx 								; restore stack pos
.9bbc	20 d1 9b	jsr $9bd1			jsr 	ValMainCode 				; do the main val() code
.9bbf	b0 01		bcs $9bc2			bcs 	_VUError 					; couldn't convert
.9bc1	60		rts				rts
.9bc2					_VUError:
.9bc2	4c a8 9f	jmp $9fa8			jmp 	TypeError
.9bc5					IsValUnary:
.9bc5	fa		plx				plx 								; restore stack pos
.9bc6	20 d1 9b	jsr $9bd1			jsr 	ValMainCode 				; do the main val() code
.9bc9	b0 03		bcs $9bce			bcs 	_VUBad
.9bcb	4c 66 8f	jmp $8f66			jmp 	ReturnTrue
.9bce					_VUBad:
.9bce	4c 71 8f	jmp $8f71			jmp 	ReturnFalse
.9bd1					ValMainCode:
.9bd1	20 78 9d	jsr $9d78			jsr 	EvaluateString 				; get a string
.9bd4	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket 			; check right bracket present
.9bd7					ValEvaluateZTemp0:
.9bd7	5a		phy				phy
.9bd8	b2 36		lda ($36)			lda 	(zTemp0) 					; check not empty string
.9bda	f0 17		beq $9bf3			beq 	_VMCFail2
.9bdc	a0 ff		ldy #$ff			ldy 	#$FF 						; start position
.9bde	48		pha				pha 								; save first character
.9bdf	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.9be1	d0 01		bne $9be4			bne 	_VMCStart
.9be3	c8		iny				iny 								; skip over -
.9be4					_VMCStart:
.9be4	38		sec				sec 								; initialise first time round.
.9be5					_VMCNext:
.9be5	c8		iny				iny 								; pre-increment
.9be6	b1 36		lda ($36),y			lda 	(zTemp0),y 					; next character = EOS ?
.9be8	f0 0c		beq $9bf6			beq 	_VMCSuccess 				; successful.
.9bea	20 43 97	jsr $9743			jsr 	EncodeNumber 				; send it to the number-builder
.9bed	90 03		bcc $9bf2			bcc 	_VMCFail 					; if failed, give up.
.9bef	18		clc				clc 								; next time round, countinue
.9bf0	80 f3		bra $9be5			bra 	_VMCNext
.9bf2					_VMCFail:
.9bf2	68		pla				pla
.9bf3					_VMCFail2:
.9bf3	7a		ply				ply
.9bf4	38		sec				sec
.9bf5	60		rts				rts
.9bf6					_VMCSuccess:
.9bf6	a9 00		lda #$00			lda 	#0 							; construct final
.9bf8	20 43 97	jsr $9743			jsr 	EncodeNumber 				; by sending a duff value.
.9bfb	68		pla				pla 								; if it was -ve
.9bfc	c9 2d		cmp #$2d			cmp 	#"-"
.9bfe	d0 03		bne $9c03			bne 	_VMCNotNegative
.9c00	20 e2 9d	jsr $9de2			jsr		NSMNegate 					; negate it.
.9c03					_VMCNotNegative:
.9c03	7a		ply				ply
.9c04	18		clc				clc
.9c05	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/chr.asm

.9c06					ChrUnary:
.9c06	fa		plx				plx 								; restore stack pos
.9c07	20 bb 9d	jsr $9dbb			jsr 	Evaluate8BitInteger			; get value (chr$(0) returns an empty string)
.9c0a	48		pha				pha
.9c0b	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket
.9c0e	a9 01		lda #$01			lda 	#1 							; allocate space for one char
.9c10	20 b2 a7	jsr $a7b2			jsr 	StringTempAllocate
.9c13	68		pla				pla 								; write number to it
.9c14	20 eb a7	jsr $a7eb			jsr 	StringTempWrite
.9c17	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/spc.asm

.9c18					SpcUnary:
.9c18	fa		plx				plx 								; restore stack pos
.9c19	20 bb 9d	jsr $9dbb			jsr 	Evaluate8BitInteger			; get value
.9c1c	5a		phy				phy
.9c1d	48		pha				pha 								; save count
.9c1e	20 b2 a7	jsr $a7b2			jsr 	StringTempAllocate
.9c21	7a		ply				ply 								; to do count in Y
.9c22					_SpcLoop:
.9c22	c0 00		cpy #$00			cpy 	#0 							; copy Y spaces in.
.9c24	f0 08		beq $9c2e			beq 	_SpcExit
.9c26	a9 20		lda #$20			lda 	#32
.9c28	20 eb a7	jsr $a7eb			jsr 	StringTempWrite
.9c2b	88		dey				dey
.9c2c	80 f4		bra $9c22			bra 	_SPCLoop
.9c2e					_SpcExit:
.9c2e	7a		ply				ply
.9c2f	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket
.9c32	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/str.asm

.9c33					Unary_Str:
.9c33	fa		plx				plx
.9c34	20 6e 9d	jsr $9d6e			jsr 	EvaluateNumber  			; get number
.9c37	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket 			; closing bracket
.9c3a	a9 05		lda #$05			lda 	#5 							; maximum decimals, from Basic816
.9c3c	20 55 9c	jsr $9c55			jsr 	ConvertNumberToString 		; do the conversion.
.9c3f	a9 21		lda #$21			lda		#33 						; create buffer
.9c41	20 b2 a7	jsr $a7b2			jsr 	StringTempAllocate 			; allocate memory
.9c44	da		phx				phx  								; copy the converted string into the buffer.
.9c45	a2 00		ldx #$00			ldx 	#0
.9c47					_USCopy:
.9c47	bd 49 06	lda $0649,x			lda 	DecimalBuffer,x
.9c4a	20 eb a7	jsr $a7eb			jsr 	StringTempWrite
.9c4d	e8		inx				inx
.9c4e	bd 49 06	lda $0649,x			lda 	DecimalBuffer,x
.9c51	d0 f4		bne $9c47			bne 	_USCopy
.9c53	fa		plx				plx
.9c54	60		rts				rts
.9c55					ConvertNumberToString:
.9c55	5a		phy				phy 								; save code position
.9c56	8d 14 04	sta $0414			sta 	DecimalPlaces	 			; save number of DPs.
.9c59	9c 15 04	stz $0415			stz 	dbOffset 					; offset into decimal buffer = start.
.9c5c	b5 50		lda $50,x			lda 	NSStatus,x  				; is it -ve.
.9c5e	10 09		bpl $9c69			bpl 	_CNTSNotNegative
.9c60	29 7f		and #$7f			and 	#$7F 						; make +ve
.9c62	95 50		sta $50,x			sta 	NSStatus,x
.9c64	a9 2d		lda #$2d			lda 	#"-"
.9c66	20 ca 9c	jsr $9cca			jsr 	WriteDecimalBuffer
.9c69					_CNTSNotNegative:
.9c69	b5 78		lda $78,x			lda 	NSExponent,x 				; check if decimal
.9c6b	f0 12		beq $9c7f			beq 	_CNTSNotFloat
.9c6d	e8		inx				inx 								; round up so we don't get too many 6.999999
.9c6e	a9 01		lda #$01			lda 	#1
.9c70	20 22 9e	jsr $9e22			jsr 	NSMSetByte
.9c73	ca		dex				dex
.9c74	b5 78		lda $78,x			lda		NSExponent,x
.9c76	95 79		sta $79,x			sta 	NSExponent+1,x
.9c78	a9 08		lda #$08			lda 	#NSTFloat
.9c7a	95 51		sta $51,x			sta 	NSStatus+1,x
.9c7c	20 48 94	jsr $9448			jsr 	FloatAdd
.9c7f					_CNTSNotFloat:
.9c7f	20 ac 9c	jsr $9cac			jsr 	MakePlusTwoString 			; do the integer part.
.9c82	20 0e 95	jsr $950e			jsr 	FloatFractionalPart 		; get the fractional part
.9c85	20 bf 95	jsr $95bf			jsr 	NSNormalise					; normalise , exit if zero
.9c88	f0 20		beq $9caa			beq 	_CNTSExit
.9c8a	a9 2e		lda #$2e			lda 	#"."
.9c8c	20 ca 9c	jsr $9cca			jsr 	WriteDecimalBuffer 			; write decimal place
.9c8f					_CNTSDecimal:
.9c8f	ce 14 04	dec $0414			dec 	DecimalPlaces 				; done all the decimals
.9c92	30 16		bmi $9caa			bmi 	_CNTSExit
.9c94	e8		inx				inx 								; x 10.0
.9c95	a9 0a		lda #$0a			lda 	#10
.9c97	20 22 9e	jsr $9e22			jsr 	NSMSetByte
.9c9a	a9 08		lda #$08			lda 	#NSTFloat
.9c9c	95 50		sta $50,x			sta 	NSStatus,x
.9c9e	ca		dex				dex
.9c9f	20 8d 95	jsr $958d			jsr 	FloatMultiply
.9ca2	20 ac 9c	jsr $9cac			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.9ca5	20 0e 95	jsr $950e			jsr 	FloatFractionalPart 		; get the fractional part
.9ca8	80 e5		bra $9c8f			bra 	_CNTSDecimal 				; keep going.
.9caa					_CNTSExit:
.9caa	7a		ply				ply
.9cab	60		rts				rts
.9cac					MakePlusTwoString:
.9cac	da		phx				phx
.9cad	20 03 9e	jsr $9e03			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.9cb0	e8		inx				inx 								; access it
.9cb1	e8		inx				inx
.9cb2	20 66 95	jsr $9566			jsr 	FloatIntegerPart 			; make it an integer
.9cb5	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.9cb7	20 78 93	jsr $9378			jsr 	ConvertInt32
.9cba	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.9cbc					_MPTSCopy:
.9cbc	bd 27 06	lda $0627,x			lda 	NumberBuffer,x
.9cbf	20 ca 9c	jsr $9cca			jsr 	WriteDecimalBuffer
.9cc2	e8		inx				inx
.9cc3	bd 27 06	lda $0627,x			lda 	NumberBuffer,x
.9cc6	d0 f4		bne $9cbc			bne 	_MPTSCopy
.9cc8	fa		plx				plx
.9cc9	60		rts				rts
.9cca					WriteDecimalBuffer:
.9cca	da		phx				phx
.9ccb	ae 15 04	ldx $0415			ldx 	dbOffset
.9cce	9d 49 06	sta $0649,x			sta 	DecimalBuffer,x
.9cd1	9e 4a 06	stz $064a,x			stz 	DecimalBuffer+1,x
.9cd4	ee 15 04	inc $0415			inc 	dbOffset
.9cd7	fa		plx				plx
.9cd8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/substring.asm

.9cd9					Unary_Left:
.9cd9	fa		plx				plx
.9cda	18		clc				clc 								; only one parameter
.9cdb	20 3e 9d	jsr $9d3e			jsr 	SubstringInitial 			; set up.
.9cde	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; Param #1 is the length
.9ce0	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9ce2	74 59		stz $59,x			stz 	NSMantissa0+1,x 			; Start is zero.
.9ce4	80 25		bra $9d0b			bra 	SubstringMain
.9ce6					Unary_Right:
.9ce6	fa		plx				plx
.9ce7	18		clc				clc 								; only one parameter
.9ce8	20 3e 9d	jsr $9d3e			jsr 	SubstringInitial 			; set up.
.9ceb	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; length => param 2
.9ced	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9cef	b5 78		lda $78,x			lda 	NSExponent,x 				; total length
.9cf1	f5 59		sbc $59,x			sbc 	NSMantissa0+1,x 			; length - required.
.9cf3	b0 02		bcs $9cf7			bcs 	_URNotUnderflow
.9cf5	a9 00		lda #$00			lda 	#0 							; start from the beginning, as something like right$("AB",3)
.9cf7					_URNotUnderFlow:
.9cf7	95 59		sta $59,x			sta 	NSMantissa0+1,x 			; this is the start position
.9cf9	80 10		bra $9d0b			bra 	SubStringMain
.9cfb					Unary_Mid:
.9cfb	fa		plx				plx
.9cfc	38		sec				sec 								; two parameters
.9cfd	20 3e 9d	jsr $9d3e			jsr 	SubstringInitial 			; set up.
.9d00	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; first parameter is zero ?
.9d02	f0 04		beq $9d08			beq 	_UMError
.9d04	d6 59		dec $59,x			dec 	NSMantissa0+1,x				; reduce initial offset by 1 as MID$(a$,1..) is actually the first character
.9d06	80 03		bra $9d0b			bra 	SubStringMain
.9d08					_UMError:
.9d08	4c ad 9f	jmp $9fad			jmp 	ArgumentError
.9d0b					SubStringMain:
.9d0b	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; is the initial offset >= the length
.9d0d	d5 78		cmp $78,x			cmp 	NSExponent,x
.9d0f	b0 27		bcs $9d38			bcs 	_SSMNull 					; if so, return an empty string.
.9d11	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; if copy count is zero
.9d13	f0 23		beq $9d38			beq 	_SSMNull 					; return empty string.
.9d15	18		clc				clc 								; add the offset +1 to the address and
.9d16	b5 58		lda $58,x			lda	 	NSMantissa0,x 				; put in zTemp, this is the start of the substring to copy.
.9d18	75 59		adc $59,x			adc 	NSMantissa0+1,x
.9d1a	85 36		sta $36				sta 	zTemp0
.9d1c	b5 60		lda $60,x			lda	 	NSMantissa1,x
.9d1e	69 00		adc #$00			adc 	#0
.9d20	85 37		sta $37				sta 	zTemp0+1
.9d22					_SSMNoCarry:
.9d22	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; characters required.
.9d24	20 b2 a7	jsr $a7b2			jsr 	StringTempAllocate 			; allocate that many characters
.9d27	5a		phy				phy 								; save Y
.9d28	a0 00		ldy #$00			ldy 	#0 							; start copying in.
.9d2a					_SSMCopy:
.9d2a	b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next character
.9d2c	f0 08		beq $9d36			beq 	_SSMEString 				; no more to copy
.9d2e	20 eb a7	jsr $a7eb			jsr 	StringTempWrite 			; and write it out.
.9d31	c8		iny				iny
.9d32	d6 5a		dec $5a,x			dec 	NSMantissa0+2,x
.9d34	d0 f4		bne $9d2a			bne 	_SSMCopy
.9d36					_SSMEString:
.9d36	7a		ply				ply
.9d37					_SSMExit:
.9d37	60		rts				rts
.9d38					_SSMNull:
.9d38	a9 00		lda #$00			lda 	#0
.9d3a	20 b2 a7	jsr $a7b2			jsr 	StringTempAllocate
.9d3d	60		rts				rts
.9d3e					SubstringInitial:
.9d3e	da		phx				phx 								; save initial stack position
.9d3f	08		php				php 								; save carry on stack indicating 2 parameters
.9d40	20 78 9d	jsr $9d78			jsr 	EvaluateString 				; get a string
.9d43	5a		phy				phy 								; calculate length to exponent.
.9d44	a0 ff		ldy #$ff			ldy 	#$FF
.9d46					_SIFindLength:
.9d46	c8		iny				iny
.9d47	b1 36		lda ($36),y			lda 	(zTemp0),y
.9d49	d0 fb		bne $9d46			bne 	_SIFindLength
.9d4b	98		tya				tya
.9d4c	95 78		sta $78,x			sta 	NSExponent,x
.9d4e	7a		ply				ply
.9d4f	e8		inx				inx
.9d50	20 e8 8e	jsr $8ee8			jsr 	CheckComma 					; comma next
.9d53	20 bb 9d	jsr $9dbb			jsr 	Evaluate8BitInteger 		; get next parameter
.9d56	28		plp				plp 								; is it the last parameter ?
.9d57	90 07		bcc $9d60			bcc 	_SSIExit 					; if so, exit.
.9d59	e8		inx				inx
.9d5a	20 e8 8e	jsr $8ee8			jsr 	CheckComma 					; comma next
.9d5d	20 bb 9d	jsr $9dbb			jsr 	Evaluate8BitInteger 		; get last parameter
.9d60					_SSIExit:
.9d60	fa		plx				plx
.9d61	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket 			; check closing bracket
.9d64	60		rts				rts 								; exit

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/exprhelper.asm

.9d65					EvaluateValue:
.9d65	48		pha				pha
.9d66	20 fd 93	jsr $93fd			jsr		EvaluateExpression 			; expression
.9d69	20 c0 96	jsr $96c0			jsr 	Dereference					; derefernce it
.9d6c	68		pla				pla
.9d6d	60		rts				rts
.9d6e					EvaluateNumber:
.9d6e	20 65 9d	jsr $9d65			jsr 	EvaluateValue 				; get a value
.9d71	b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.9d73	29 10		and #$10			and 	#NSBIsString
.9d75	d0 13		bne $9d8a			bne 	HelperTypeError
.9d77	60		rts				rts
.9d78					EvaluateString:
.9d78	20 65 9d	jsr $9d65			jsr 	EvaluateValue 				; get a value
.9d7b	b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.9d7d	29 10		and #$10			and 	#NSBIsString
.9d7f	f0 09		beq $9d8a			beq 	HelperTypeError
.9d81					CopyAddressToTemp0:
.9d81	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address -> zTemp0
.9d83	85 36		sta $36				sta 	zTemp0 						; (so we can do something with it)
.9d85	b5 60		lda $60,x			lda 	NSMantissa1,x
.9d87	85 37		sta $37				sta 	zTemp0+1
.9d89	60		rts				rts
.9d8a					HelperTypeError:
.9d8a	4c a8 9f	jmp $9fa8			jmp 	TypeError
.9d8d					EvaluateInteger:
.9d8d	20 6e 9d	jsr $9d6e			jsr 	EvaluateNumber
.9d90	b5 78		lda $78,x			lda 	NSExponent,x 				; check exponent is zero
.9d92	d0 09		bne $9d9d			bne 	HelperValueError 			; if not, it's a float.
.9d94	60		rts				rts
.9d95					EvaluateUnsignedInteger:
.9d95	20 8d 9d	jsr $9d8d			jsr 	EvaluateInteger 			; check integer is +ve
.9d98	b5 50		lda $50,x			lda 	NSStatus,x
.9d9a	30 01		bmi $9d9d			bmi 	HelperValueError
.9d9c	60		rts				rts
.9d9d					HelperValueError:
.9d9d	4c ad 9f	jmp $9fad			jmp 	ArgumentError
.9da0					Evaluate16BitInteger:
.9da0	20 95 9d	jsr $9d95			jsr	 	EvaluateUnsignedInteger		; get integer
.9da3	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9da5	15 68		ora $68,x			ora 	NSMantissa2,x
.9da7	d0 f4		bne $9d9d			bne 	HelperValueError
.9da9	60		rts				rts
.9daa					Evaluate16BitIntegerSigned:
.9daa	20 8d 9d	jsr $9d8d			jsr	 	EvaluateInteger				; get integer
.9dad	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9daf	15 68		ora $68,x			ora 	NSMantissa2,x
.9db1	d0 ea		bne $9d9d			bne 	HelperValueError
.9db3	b5 50		lda $50,x			lda 	NSStatus,x 					; signed ?
.9db5	10 03		bpl $9dba			bpl 	_EISNotSigned
.9db7	20 e9 9d	jsr $9de9			jsr 	NSMNegateMantissa 			; makes it an actual 2's complement value.
.9dba					_EISNotSigned:
.9dba	60		rts				rts
.9dbb					Evaluate8BitInteger:
.9dbb	20 95 9d	jsr $9d95			jsr	 	EvaluateUnsignedInteger 	; get an integer
.9dbe	d0 dd		bne $9d9d			bne 	HelperValueError
.9dc0	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 1, 2 & 3 must be zero
.9dc2	15 68		ora $68,x			ora 	NSMantissa2,x
.9dc4	15 60		ora $60,x			ora 	NSMantissa1,x
.9dc6	d0 d5		bne $9d9d			bne 	HelperValueError
.9dc8	b5 58		lda $58,x			lda 	NSMantissa0,x
.9dca	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/mult8x8.asm

.9dcb					Multiply8x8:
.9dcb	4a		lsr a		  		lsr 	a  							; prime the carry bit for the loop
.9dcc	85 36		sta $36			  	sta 	zTemp0
.9dce	86 37		stx $37				stx 	zTemp0+1
.9dd0	a9 00		lda #$00			lda 	#0
.9dd2	a2 08		ldx #$08			ldx 	#8
.9dd4					_M88Loop:
.9dd4	90 03		bcc $9dd9			bcc 	_M88NoAdd
.9dd6	18		clc				clc
.9dd7	65 37		adc $37				adc 	zTemp0+1
.9dd9					_M88NoAdd:
.9dd9	6a		ror a				ror 	a
.9dda	66 36		ror $36				ror 	zTemp0  					; pull another bit out for the next iteration
.9ddc	ca		dex				dex         						; inc/dec don't modify carry; only shifts and adds do
.9ddd	d0 f5		bne $9dd4			bne 	_M88Loop
.9ddf	85 37		sta $37				sta 	zTemp0+1 					; store high 8 bits.
.9de1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/utility.asm

.9de2					NSMNegate:
.9de2	b5 50		lda $50,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.9de4	49 80		eor #$80			eor 	#NSBIsNegative  			; toggle the negative flag
.9de6	95 50		sta $50,x			sta 	NSStatus,x
.9de8	60		rts				rts
.9de9					NSMNegateMantissa:
.9de9	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.9dea	a9 00		lda #$00			lda 	#0
.9dec	f5 58		sbc $58,x			sbc 	NSMantissa0,x
.9dee	95 58		sta $58,x			sta 	NSMantissa0,x
.9df0	a9 00		lda #$00			lda 	#0
.9df2	f5 60		sbc $60,x			sbc 	NSMantissa1,x
.9df4	95 60		sta $60,x			sta 	NSMantissa1,x
.9df6	a9 00		lda #$00			lda 	#0
.9df8	f5 68		sbc $68,x			sbc 	NSMantissa2,x
.9dfa	95 68		sta $68,x			sta 	NSMantissa2,x
.9dfc	a9 00		lda #$00			lda 	#0
.9dfe	f5 70		sbc $70,x			sbc 	NSMantissa3,x
.9e00	95 70		sta $70,x			sta 	NSMantissa3,x
.9e02	60		rts				rts
.9e03					NSMShiftUpTwo:
.9e03	b5 58		lda $58,x			lda 	NSMantissa0,x
.9e05	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9e07	b5 60		lda $60,x			lda 	NSMantissa1,x
.9e09	95 62		sta $62,x			sta 	NSMantissa1+2,x
.9e0b	b5 68		lda $68,x			lda 	NSMantissa2,x
.9e0d	95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.9e0f	b5 70		lda $70,x			lda 	NSMantissa3,x
.9e11	95 72		sta $72,x			sta 	NSMantissa3+2,x
.9e13	b5 78		lda $78,x			lda 	NSExponent,x
.9e15	95 7a		sta $7a,x			sta 	NSExponent+2,x
.9e17	b5 50		lda $50,x			lda 	NSStatus,x
.9e19	95 52		sta $52,x			sta 	NSStatus+2,x
.9e1b	60		rts				rts
.9e1c					NSMSetZeroMantissaOnly:
.9e1c	a9 00		lda #$00			lda 	#0
.9e1e	80 06		bra $9e26			bra 	NSMSetMantissa
.9e20					NSMSetZero:
.9e20	a9 00		lda #$00			lda 	#0
.9e22					NSMSetByte:
.9e22	74 78		stz $78,x			stz 	NSExponent,x 				; zero exponent, as integer.
.9e24	74 50		stz $50,x			stz 	NSStatus,x 					; status zero (integer)
.9e26					NSMSetMantissa:
.9e26	95 58		sta $58,x			sta 	NSMantissa0,x 				; mantissa
.9e28	74 60		stz $60,x			stz 	NSMantissa1,x
.9e2a	74 68		stz $68,x			stz 	NSMantissa2,x
.9e2c	74 70		stz $70,x			stz 	NSMantissa3,x
.9e2e	60		rts				rts
.9e2f					NSMShiftLeft:
.9e2f	18		clc				clc
.9e30					NSMRotateLeft:
.9e30	36 58		rol $58,x			rol 	NSMantissa0,x
.9e32	36 60		rol $60,x			rol		NSMantissa1,x
.9e34	36 68		rol $68,x			rol		NSMantissa2,x
.9e36	36 70		rol $70,x			rol		NSMantissa3,x
.9e38	60		rts				rts
.9e39					NSMShiftRight:
.9e39	56 70		lsr $70,x			lsr 	NSMantissa3,x
.9e3b	76 68		ror $68,x			ror		NSMantissa2,x
.9e3d	76 60		ror $60,x			ror		NSMantissa1,x
.9e3f	76 58		ror $58,x			ror		NSMantissa0,x
.9e41	60		rts				rts
.9e42					NSMIsZero:
.9e42	b5 70		lda $70,x			lda 	NSMantissa3,x
.9e44	15 68		ora $68,x			ora		NSMantissa2,x
.9e46	15 60		ora $60,x			ora		NSMantissa1,x
.9e48	15 58		ora $58,x			ora		NSMantissa0,x
.9e4a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.asm

.9e4b					TickHandler:
.9e4b	5a		phy				phy 								; need to preserve Y
.9e4c	20 1b 80	jsr $801b			jsr 	SNDUpdate 					; update sound
.9e4f	7a		ply				ply
.9e50	60		rts				rts
.065c					LastTick:
>065c							.fill 		1

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/asmcore.asm

.9e51					Assemble_ora:
.9e51	20 b1 80	jsr $80b1		jsr	AssembleGroup1
>9e54	01					.byte $01
.9e55					Assemble_and:
.9e55	20 b1 80	jsr $80b1		jsr	AssembleGroup1
>9e58	21					.byte $21
.9e59					Assemble_eor:
.9e59	20 b1 80	jsr $80b1		jsr	AssembleGroup1
>9e5c	41					.byte $41
.9e5d					Assemble_adc:
.9e5d	20 b1 80	jsr $80b1		jsr	AssembleGroup1
>9e60	61					.byte $61
.9e61					Assemble_sta:
.9e61	20 b1 80	jsr $80b1		jsr	AssembleGroup1
>9e64	81					.byte $81
.9e65					Assemble_lda:
.9e65	20 b1 80	jsr $80b1		jsr	AssembleGroup1
>9e68	a1					.byte $a1
.9e69					Assemble_cmp:
.9e69	20 b1 80	jsr $80b1		jsr	AssembleGroup1
>9e6c	c1					.byte $c1
.9e6d					Assemble_sbc:
.9e6d	20 b1 80	jsr $80b1		jsr	AssembleGroup1
>9e70	e1					.byte $e1
.9e71					Assemble_asl:
.9e71	20 b8 80	jsr $80b8		jsr	AssembleGroup2
>9e74	02					.byte $02
>9e75	75					.byte $75
.9e76					Assemble_rol:
.9e76	20 b8 80	jsr $80b8		jsr	AssembleGroup2
>9e79	22					.byte $22
>9e7a	75					.byte $75
.9e7b					Assemble_lsr:
.9e7b	20 b8 80	jsr $80b8		jsr	AssembleGroup2
>9e7e	42					.byte $42
>9e7f	75					.byte $75
.9e80					Assemble_ror:
.9e80	20 b8 80	jsr $80b8		jsr	AssembleGroup2
>9e83	62					.byte $62
>9e84	75					.byte $75
.9e85					Assemble_stx:
.9e85	20 b8 80	jsr $80b8		jsr	AssembleGroup2
>9e88	82					.byte $82
>9e89	50					.byte $50
.9e8a					Assemble_ldx:
.9e8a	20 b8 80	jsr $80b8		jsr	AssembleGroup2
>9e8d	a2					.byte $a2
>9e8e	d0					.byte $d0
.9e8f					Assemble_dec:
.9e8f	20 b8 80	jsr $80b8		jsr	AssembleGroup2
>9e92	c2					.byte $c2
>9e93	55					.byte $55
.9e94					Assemble_inc:
.9e94	20 b8 80	jsr $80b8		jsr	AssembleGroup2
>9e97	e2					.byte $e2
>9e98	55					.byte $55
.9e99					Assemble_stz:
.9e99	20 b8 80	jsr $80b8		jsr	AssembleGroup2
>9e9c	60					.byte $60
>9e9d	44					.byte $44
.9e9e					Assemble_bit:
.9e9e	20 b8 80	jsr $80b8		jsr	AssembleGroup2
>9ea1	20					.byte $20
>9ea2	55					.byte $55
.9ea3					Assemble_sty:
.9ea3	20 b8 80	jsr $80b8		jsr	AssembleGroup2
>9ea6	80					.byte $80
>9ea7	54					.byte $54
.9ea8					Assemble_ldy:
.9ea8	20 b8 80	jsr $80b8		jsr	AssembleGroup2
>9eab	a0					.byte $a0
>9eac	d5					.byte $d5
.9ead					Assemble_cpy:
.9ead	20 b8 80	jsr $80b8		jsr	AssembleGroup2
>9eb0	c0					.byte $c0
>9eb1	d4					.byte $d4
.9eb2					Assemble_cpx:
.9eb2	20 b8 80	jsr $80b8		jsr	AssembleGroup2
>9eb5	e0					.byte $e0
>9eb6	d0					.byte $d0
.9eb7					Assemble_tsb:
.9eb7	20 b8 80	jsr $80b8		jsr	AssembleGroup2
>9eba	00					.byte $00
>9ebb	50					.byte $50
.9ebc					Assemble_trb:
.9ebc	20 b8 80	jsr $80b8		jsr	AssembleGroup2
>9ebf	10					.byte $10
>9ec0	50					.byte $50
.9ec1					Assemble_jsr:
.9ec1	20 b8 80	jsr $80b8		jsr	AssembleGroup2
>9ec4	14					.byte $14
>9ec5	10					.byte $10
.9ec6					Assemble_jmp:
.9ec6	20 b8 80	jsr $80b8		jsr	AssembleGroup2
>9ec9	40					.byte $40
>9eca	10					.byte $10
.9ecb					Assemble_bpl:
.9ecb	20 09 81	jsr $8109		jsr	AssembleGroup3
>9ece	10					.byte $10
.9ecf					Assemble_bmi:
.9ecf	20 09 81	jsr $8109		jsr	AssembleGroup3
>9ed2	30					.byte $30
.9ed3					Assemble_bvc:
.9ed3	20 09 81	jsr $8109		jsr	AssembleGroup3
>9ed6	50					.byte $50
.9ed7					Assemble_bvs:
.9ed7	20 09 81	jsr $8109		jsr	AssembleGroup3
>9eda	70					.byte $70
.9edb					Assemble_bcc:
.9edb	20 09 81	jsr $8109		jsr	AssembleGroup3
>9ede	90					.byte $90
.9edf					Assemble_bcs:
.9edf	20 09 81	jsr $8109		jsr	AssembleGroup3
>9ee2	b0					.byte $b0
.9ee3					Assemble_bne:
.9ee3	20 09 81	jsr $8109		jsr	AssembleGroup3
>9ee6	d0					.byte $d0
.9ee7					Assemble_beq:
.9ee7	20 09 81	jsr $8109		jsr	AssembleGroup3
>9eea	f0					.byte $f0
.9eeb					Assemble_bra:
.9eeb	20 09 81	jsr $8109		jsr	AssembleGroup3
>9eee	80					.byte $80
.9eef					Assemble_brk:
.9eef	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9ef2	00					.byte $00
.9ef3					Assemble_php:
.9ef3	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9ef6	08					.byte $08
.9ef7					Assemble_clc:
.9ef7	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9efa	18					.byte $18
.9efb					Assemble_plp:
.9efb	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9efe	28					.byte $28
.9eff					Assemble_sec:
.9eff	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f02	38					.byte $38
.9f03					Assemble_rti:
.9f03	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f06	40					.byte $40
.9f07					Assemble_pha:
.9f07	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f0a	48					.byte $48
.9f0b					Assemble_cli:
.9f0b	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f0e	58					.byte $58
.9f0f					Assemble_phy:
.9f0f	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f12	5a					.byte $5a
.9f13					Assemble_rts:
.9f13	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f16	60					.byte $60
.9f17					Assemble_pla:
.9f17	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f1a	68					.byte $68
.9f1b					Assemble_sei:
.9f1b	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f1e	78					.byte $78
.9f1f					Assemble_ply:
.9f1f	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f22	7a					.byte $7a
.9f23					Assemble_dey:
.9f23	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f26	88					.byte $88
.9f27					Assemble_txa:
.9f27	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f2a	8a					.byte $8a
.9f2b					Assemble_tya:
.9f2b	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f2e	98					.byte $98
.9f2f					Assemble_txs:
.9f2f	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f32	9a					.byte $9a
.9f33					Assemble_tay:
.9f33	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f36	a8					.byte $a8
.9f37					Assemble_tax:
.9f37	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f3a	aa					.byte $aa
.9f3b					Assemble_clv:
.9f3b	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f3e	b8					.byte $b8
.9f3f					Assemble_tsx:
.9f3f	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f42	ba					.byte $ba
.9f43					Assemble_iny:
.9f43	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f46	c8					.byte $c8
.9f47					Assemble_dex:
.9f47	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f4a	ca					.byte $ca
.9f4b					Assemble_cld:
.9f4b	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f4e	d8					.byte $d8
.9f4f					Assemble_phx:
.9f4f	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f52	da					.byte $da
.9f53					Assemble_stp:
.9f53	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f56	db					.byte $db
.9f57					Assemble_inx:
.9f57	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f5a	e8					.byte $e8
.9f5b					Assemble_nop:
.9f5b	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f5e	ea					.byte $ea
.9f5f					Assemble_sed:
.9f5f	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f62	f8					.byte $f8
.9f63					Assemble_plx:
.9f63	20 3d 81	jsr $813d		jsr	AssembleGroup4
>9f66	fa					.byte $fa

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/constants.asm

.9f67					DecimalScalarTable:
>9f67	66 66 66 66				.dword $66666666 ; 0.1
>9f6b	de					.byte $de
>9f6c	1f 85 eb 51				.dword $51eb851f ; 0.01
>9f70	db					.byte $db
>9f71	4c 37 89 41				.dword $4189374c ; 0.001
>9f75	d8					.byte $d8
>9f76	ac 8b db 68				.dword $68db8bac ; 0.0001
>9f7a	d4					.byte $d4
>9f7b	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>9f7f	d1					.byte $d1
>9f80	83 de 1b 43				.dword $431bde83 ; 1e-06
>9f84	ce					.byte $ce
>9f85	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>9f89	ca					.byte $ca
>9f8a	89 3b e6 55				.dword $55e63b89 ; 1e-08
>9f8e	c7					.byte $c7
>9f8f	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>9f93	c4					.byte $c4
>9f94	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>9f98	c0					.byte $c0
>9f99	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>9f9d	bd					.byte $bd

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.asm

.9f9e					SyntaxError:
.9f9e	a9 02		lda #$02		lda	#2
.9fa0	4c f9 8e	jmp $8ef9		jmp	ErrorHandler
.9fa3					RangeError:
.9fa3	a9 04		lda #$04		lda	#4
.9fa5	4c f9 8e	jmp $8ef9		jmp	ErrorHandler
.9fa8					TypeError:
.9fa8	a9 05		lda #$05		lda	#5
.9faa	4c f9 8e	jmp $8ef9		jmp	ErrorHandler
.9fad					ArgumentError:
.9fad	a9 07		lda #$07		lda	#7
.9faf	4c f9 8e	jmp $8ef9		jmp	ErrorHandler
.9fb2					NotDoneError:
.9fb2	a9 0c		lda #$0c		lda	#12
.9fb4	4c f9 8e	jmp $8ef9		jmp	ErrorHandler
.9fb7					ErrorText:
>9fb7	42 72 65 61 6b 00			.text	"Break",0
>9fbd	53 79 6e 74 61 78 20 65			.text	"Syntax error",0
>9fc5	72 72 6f 72 00
>9fca	44 69 76 69 73 69 6f 6e			.text	"Division by zero",0
>9fd2	20 62 79 20 7a 65 72 6f 00
>9fdb	4f 75 74 20 6f 66 20 52			.text	"Out of Range",0
>9fe3	61 6e 67 65 00
>9fe8	54 79 70 65 20 6d 69 73			.text	"Type mismatch",0
>9ff0	6d 61 74 63 68 00
>9ff6	4f 75 74 20 6f 66 20 6d			.text	"Out of memory",0
>9ffe	65 6d 6f 72 79 00
>a004	49 6c 6c 65 67 61 6c 20			.text	"Illegal argument",0
>a00c	61 72 67 75 6d 65 6e 74 00
>a015	53 74 6f 70 00				.text	"Stop",0
>a01a	53 74 72 69 6e 67 20 74			.text	"String too long",0
>a022	6f 6f 20 6c 6f 6e 67 00
>a02a	41 73 73 65 72 74 69 6f			.text	"Assertion failed",0
>a032	6e 20 66 61 69 6c 65 64 00
>a03b	4f 75 74 20 6f 66 20 64			.text	"Out of data",0
>a043	61 74 61 00
>a047	55 6e 69 6d 70 6c 65 6d			.text	"Unimplemented",0
>a04f	65 6e 74 65 64 00
>a055	4e 6f 20 73 75 63 68 20			.text	"No such line number",0
>a05d	6c 69 6e 65 20 6e 75 6d 62 65 72 00
>a069	52 65 74 75 72 6e 20 77			.text	"Return without Gosub",0
>a071	69 74 68 6f 75 74 20 47 6f 73 75 62 00
>a07e	55 6e 74 69 6c 20 77 69			.text	"Until without Repeat",0
>a086	74 68 6f 75 74 20 52 65 70 65 61 74 00
>a093	57 65 6e 64 20 77 69 74			.text	"Wend without While",0
>a09b	68 6f 75 74 20 57 68 69 6c 65 00
>a0a6	4e 65 78 74 20 77 69 74			.text	"Next without For",0
>a0ae	68 6f 75 74 20 46 6f 72 00
>a0b7	42 41 53 49 43 20 53 74			.text	"BASIC Stack full",0
>a0bf	61 63 6b 20 66 75 6c 6c 00
>a0c8	4f 70 65 6e 20 53 74 72			.text	"Open Structure",0
>a0d0	75 63 74 75 72 65 00
>a0d7	45 6e 64 50 72 6f 63 20			.text	"EndProc without call",0
>a0df	77 69 74 68 6f 75 74 20 63 61 6c 6c 00
>a0ec	41 72 72 61 79 20 61 6c			.text	"Array already defined",0
>a0f4	72 65 61 64 79 20 64 65 66 69 6e 65 64 00
>a102	41 72 72 61 79 20 73 69			.text	"Array size",0
>a10a	7a 65 00
>a10d	42 61 64 20 61 72 72 61			.text	"Bad array index",0
>a115	79 20 69 6e 64 65 78 00
>a11d	41 72 72 61 79 20 6e 6f			.text	"Array not declared",0
>a125	74 20 64 65 63 6c 61 72 65 64 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/timestamp.asm

>a130	41 6c 70 68 61 20 31 32			.text "Alpha 12 built 06-Dec-22. "
>a138	20 62 75 69 6c 74 20 30 36 2d 44 65 63 2d 32 32
>a148	2e 20

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcommand.asm

.a14a					RectangleCommand:
.a14a	a9 44		lda #$44			lda 	#GCMD_FrameRect				; frame rectangle
.a14c	80 02		bra $a150			bra 	ShapeDrawCmd
.a14e					CircleCommand:
.a14e	a9 48		lda #$48			lda 	#GCMD_FrameCircle 				; framed circle
.a150					ShapeDrawCmd:
.a150	20 da a1	jsr $a1da			jsr 	RunGraphicsCommand
.a153					ShapeDraw:
.a153	0d 5e 06	ora $065e			ora 	gxFillSolid  				; adjust AXY for solid fill.
.a156	4c ce a1	jmp $a1ce			jmp 	ExecuteGraphicCommand	 	; and complete
.a159					SpriteCommand:
.a159	a2 00		ldx #$00			ldx 	#0
.a15b	20 bb 9d	jsr $9dbb			jsr 	Evaluate8BitInteger 		; get image number.
.a15e	5a		phy				phy
.a15f	a9 0e		lda #$0e			lda 	#GCMD_SpriteUse 			; use that image.
.a161	a6 58		ldx $58				ldx 	NSMantissa0
.a163	e0 40		cpx #$40			cpx 	#64 						; 0-63 only
.a165	b0 0d		bcs $a174			bcs 	_SCRange
.a167	a0 ff		ldy #$ff			ldy 	#255
.a169	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a16c	a9 52		lda #$52			lda 	#GCMD_SpriteMove
.a16e	7a		ply				ply
.a16f	20 da a1	jsr $a1da			jsr 	RunGraphicsCommand
.a172	80 5a		bra $a1ce			bra 	ExecuteGraphicCommand
.a174					_SCRange:
.a174	4c a3 9f	jmp $9fa3			jmp 	RangeError
.a177					ImageCommand:
.a177	a2 00		ldx #$00			ldx 	#0
.a179	20 bb 9d	jsr $9dbb			jsr 	Evaluate8BitInteger 		; get image number.
.a17c	20 da a1	jsr $a1da			jsr 	RunGraphicsCommand
.a17f					ImageRunDraw:
.a17f	09 40		ora #$40			ora 	#GCMD_Move					; move cursor
.a181	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a184	ad 64 06	lda $0664			lda 	gxDrawScale
.a187	0a		asl a				asl 	a
.a188	0a		asl a				asl 	a
.a189	0a		asl a				asl 	a
.a18a	a8		tay				tay
.a18b	a9 0c		lda #$0c			lda 	#GCMD_DrawSprite 			; image drawing
.a18d	a6 58		ldx $58				ldx 	NSMantissa0
.a18f	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a192	60		rts				rts
.a193					TextCommand:
.a193	a2 00		ldx #$00			ldx 	#0
.a195	20 78 9d	jsr $9d78			jsr 	EvaluateString 				; get text
.a198	20 da a1	jsr $a1da			jsr 	RunGraphicsCommand
.a19b					TextRunDraw:
.a19b	09 40		ora #$40			ora 	#GCMD_Move 					; move cursor
.a19d	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a1a0	a0 00		ldy #$00			ldy 	#0
.a1a2					_IRDLoop:
.a1a2	a5 60		lda $60				lda 	NSMantissa1 				; access character
.a1a4	85 37		sta $37				sta 	zTemp0+1
.a1a6	a5 58		lda $58				lda 	NSMantissa0
.a1a8	85 36		sta $36				sta 	zTemp0
.a1aa	b1 36		lda ($36),y			lda 	(zTemp0),y
.a1ac	f0 13		beq $a1c1			beq 	_IRDExit
.a1ae	5a		phy				phy									; save string pos
.a1af	48		pha				pha 								; save char
.a1b0	ad 64 06	lda $0664			lda 	gxDrawScale 				; get scale
.a1b3	0a		asl a				asl 	a
.a1b4	0a		asl a				asl 	a
.a1b5	0a		asl a				asl 	a
.a1b6	a8		tay				tay
.a1b7	a9 0a		lda #$0a			lda 	#GCMD_DrawFont 				; char drawing
.a1b9	fa		plx				plx 								; char to draw
.a1ba	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a1bd	7a		ply				ply 								; restore string pos
.a1be	c8		iny				iny
.a1bf	90 e1		bcc $a1a2			bcc 	_IRDLoop 					; go back if no error.
.a1c1					_IRDExit:
.a1c1	60		rts				rts
.a1c2					PlotCommand:
.a1c2	a9 50		lda #$50			lda 	#GCMD_Plot 					; command ID to use
.a1c4	20 da a1	jsr $a1da			jsr 	RunGraphicsCommand
.a1c7	80 05		bra $a1ce			bra 	ExecuteGraphicCommand
.a1c9					LineCommand:
.a1c9	a9 42		lda #$42			lda 	#GCMD_Line 						; command ID to use
.a1cb	20 da a1	jsr $a1da			jsr 	RunGraphicsCommand
.a1ce					ExecuteGraphicCommand:
.a1ce	0d 5d 06	ora $065d			ora 	gxCommandID 				; make a full command
.a1d1	20 15 80	jsr $8015			jsr 	GXGraphicDraw 				; draw it and exit
.a1d4	b0 01		bcs $a1d7			bcs 	_EGCError
.a1d6	60		rts				rts
.a1d7					_EGCError:
.a1d7	4c 9e 9f	jmp $9f9e			jmp 	SyntaxError
.a1da					RunGraphicsCommand:
.a1da	8d 5d 06	sta $065d			sta 	gxCommandID					; save TODO graphics command.
.a1dd	68		pla				pla 								; pop handler address
.a1de	fa		plx				plx
.a1df	1a		inc a				inc 	a
.a1e0	d0 01		bne $a1e3			bne 	_RGINoCarry
.a1e2	e8		inx				inx
.a1e3					_RGINoCarry:
.a1e3	8d 62 06	sta $0662			sta 	GXHandler
.a1e6	8e 63 06	stx $0663			stx 	GXHandler+1
.a1e9					_RGICommandLoop:
.a1e9	b1 30		lda ($30),y			lda 	(codePtr),y
.a1eb	c8		iny				iny
.a1ec	c9 d2		cmp #$d2			cmp 	#KWD_TO						; is it TO x,y
.a1ee	f0 53		beq $a243			beq 	_RGI_To
.a1f0	c9 bd		cmp #$bd			cmp 	#KWD_HERE 					; do it here.
.a1f2	f0 55		beq $a249			beq 	_RGI_Here
.a1f4	c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL or : , exit
.a1f6	f0 3d		beq $a235			beq 	_RGI_Exit
.a1f8	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.a1fa	f0 39		beq $a235			beq 	_RGI_Exit
.a1fc	c9 c5		cmp #$c5			cmp 	#KWD_OUTLINE 				; solid or outline
.a1fe	f0 3e		beq $a23e			beq 	_RGI_Frame
.a200	c9 ce		cmp #$ce			cmp 	#KWD_SOLID
.a202	f0 33		beq $a237			beq 	_RGI_Solid
.a204	c9 ad		cmp #$ad			cmp 	#KWD_BY 					; by offset
.a206	f0 4b		beq $a253			beq 	_RGI_By
.a208	c9 b9		cmp #$b9			cmp 	#KWD_FROM 					; from
.a20a	f0 17		beq $a223			beq 	_RGI_Move2
.a20c	c9 b5		cmp #$b5			cmp 	#KWD_DIM 					; dim (set scale)
.a20e	f0 62		beq $a272			beq 	_RGI_Dim
.a210	c9 b3		cmp #$b3			cmp 	#KWD_COLOUR 				; colour or Color
.a212	f0 74		beq $a288			beq 	_RGI_Colour
.a214	c9 b2		cmp #$b2			cmp 	#KWD_COLOR
.a216	f0 70		beq $a288			beq 	_RGI_Colour
.a218	ae 5d 06	ldx $065d			ldx 	gxCommandID
.a21b	e0 52		cpx #$52			cpx 	#GCMD_SpriteMove 			; if not sprite
.a21d	d0 03		bne $a222			bne 	_RGI_Move 					; move
.a21f	4c b0 a2	jmp $a2b0			jmp		_RGI_SpriteInstructions
.a222					_RGI_Move:
.a222	88		dey				dey 								; unpick get.
.a223					_RGI_Move2:
.a223	20 d6 a2	jsr $a2d6			jsr 	GCGetCoordinatePair 		; move to here
.a226	20 fd a2	jsr $a2fd			jsr 	GCCopyPairToStore 			; save
.a229	5a		phy				phy
.a22a	20 f3 a2	jsr $a2f3			jsr 	GCLoadAXY 					; load in
.a22d	09 40		ora #$40			ora 	#GCMD_Move 					; move there
.a22f	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a232	7a		ply				ply
.a233	80 b4		bra $a1e9			bra 	_RGICommandLoop 			; and go round
.a235					_RGI_Exit:
.a235	88		dey				dey 								; unpick : / EOL
.a236	60		rts				rts
.a237					_RGI_Solid:
.a237	a9 02		lda #$02			lda 	#2
.a239	8d 5e 06	sta $065e			sta 	gxFillSolid
.a23c	80 ab		bra $a1e9			bra 	_RGICommandLoop
.a23e					_RGI_Frame:
.a23e	9c 5e 06	stz $065e			stz 	gxFillSolid
.a241	80 a6		bra $a1e9			bra 	_RGICommandLoop
.a243					_RGI_To:
.a243	20 d6 a2	jsr $a2d6			jsr 	GCGetCoordinatePair 		; get coordinate pair into slot #1,#2
.a246	20 fd a2	jsr $a2fd			jsr 	GCCopyPairToStore
.a249					_RGI_Here:
.a249	5a		phy				phy
.a24a	20 f3 a2	jsr $a2f3			jsr 	GCLoadAXY 					; load it into AXY
.a24d	20 ad a2	jsr $a2ad			jsr 	_RGICallHandler 			; go do whatever it is.
.a250	7a		ply				ply
.a251	80 96		bra $a1e9			bra 	_RGICommandLoop 			; and go round
.a253					_RGI_By:
.a253	20 e3 a2	jsr $a2e3			jsr 	GCSignedCoordinatePair 		; get coordinate pair into slot #1,#2
.a256	18		clc				clc
.a257	a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.a259	6d 5f 06	adc $065f			adc 	gxxPos
.a25c	8d 5f 06	sta $065f			sta 	gxXPos
.a25f	a5 61		lda $61				lda 	NSMantissa1+1
.a261	6d 60 06	adc $0660			adc 	gxxPos+1
.a264	8d 60 06	sta $0660			sta 	gxXPos+1
.a267	a5 5a		lda $5a				lda 	NSMantissa0+2
.a269	18		clc				clc
.a26a	6d 61 06	adc $0661			adc 	gxYPos
.a26d	8d 61 06	sta $0661			sta 	gxYPos
.a270	80 d7		bra $a249			bra 	_RGI_Here
.a272					_RGI_Dim:
.a272	a2 01		ldx #$01			ldx	 	#1
.a274	20 bb 9d	jsr $9dbb			jsr 	Evaluate8BitInteger
.a277	a5 59		lda $59				lda 	NSMantissa0+1
.a279	c9 00		cmp #$00			cmp 	#0
.a27b	f0 2d		beq $a2aa			beq 	_RGIRange
.a27d	c9 09		cmp #$09			cmp 	#8+1
.a27f	b0 29		bcs $a2aa			bcs		_RGIRange
.a281	3a		dec a				dec 	a
.a282	8d 64 06	sta $0664			sta 	gxDrawScale
.a285	4c e9 a1	jmp $a1e9			jmp 	_RGICommandLoop
.a288					_RGI_Colour:
.a288	a2 01		ldx #$01			ldx 	#1 							; colour
.a28a	20 bb 9d	jsr $9dbb			jsr 	Evaluate8BitInteger
.a28d	a2 02		ldx #$02			ldx 	#2 							; default zero for 2nd parameter
.a28f	20 20 9e	jsr $9e20			jsr 	NSMSetZero
.a292	b1 30		lda ($30),y			lda 	(codePtr),y
.a294	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; check , => mode.
.a296	d0 04		bne $a29c			bne 	_RGICDefaultMode
.a298	c8		iny				iny
.a299	20 bb 9d	jsr $9dbb			jsr 	Evaluate8BitInteger
.a29c					_RGICDefaultMode:
.a29c	5a		phy				phy
.a29d	a9 08		lda #$08			lda 	#GCMD_Colour 				; set colour.
.a29f	a6 59		ldx $59				ldx 	NSMantissa0+1
.a2a1	a4 5a		ldy $5a				ldy 	NSMantissa0+2
.a2a3	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a2a6	7a		ply				ply
.a2a7	4c e9 a1	jmp $a1e9			jmp 	_RGICommandLoop 			; and go round
.a2aa					_RGIRange:
.a2aa	4c a3 9f	jmp $9fa3			jmp 	RangeError
.a2ad					_RGICallHandler:
.a2ad	6c 62 06	jmp ($0662)			jmp 	(GXHandler)
.a2b0					_RGI_SpriteInstructions:
.a2b0	c9 c3		cmp #$c3			cmp 	#KWD_OFF
.a2b2	f0 07		beq $a2bb			beq 	_RGISpriteOff
.a2b4	c9 be		cmp #$be			cmp 	#KWD_IMAGE
.a2b6	f0 13		beq $a2cb			beq 	_RGISetImage
.a2b8	4c 22 a2	jmp $a222			jmp 	_RGI_Move
.a2bb					_RGISpriteOff:
.a2bb	5a		phy				phy
.a2bc	a0 01		ldy #$01			ldy 	#1
.a2be	a2 00		ldx #$00			ldx 	#0
.a2c0					_RGIDoCommandLoop:
.a2c0	a9 10		lda #$10			lda 	#GCMD_SpriteImage
.a2c2	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a2c5	7a		ply				ply
.a2c6	b0 e2		bcs $a2aa			bcs 	_RGIRange
.a2c8	4c e9 a1	jmp $a1e9			jmp 	_RGICommandLoop
.a2cb					_RGISetImage:
.a2cb	a2 01		ldx #$01			ldx 	#1
.a2cd	20 bb 9d	jsr $9dbb			jsr 	Evaluate8BitInteger
.a2d0	5a		phy				phy
.a2d1	aa		tax				tax
.a2d2	a0 00		ldy #$00			ldy 	#0
.a2d4	80 ea		bra $a2c0			bra 	_RGIDoCommandLoop
.a2d6					GCGetCoordinatePair:
.a2d6	a2 01		ldx #$01			ldx 	#1
.a2d8	20 a0 9d	jsr $9da0			jsr 	Evaluate16BitInteger
.a2db	20 e8 8e	jsr $8ee8			jsr 	CheckComma
.a2de	e8		inx				inx
.a2df	20 a0 9d	jsr $9da0			jsr 	Evaluate16BitInteger
.a2e2	60		rts				rts
.a2e3					GCSignedCoordinatePair:
.a2e3	a2 01		ldx #$01			ldx 	#1
.a2e5	20 aa 9d	jsr $9daa			jsr 	Evaluate16BitIntegerSigned
.a2e8	20 e8 8e	jsr $8ee8			jsr 	CheckComma
.a2eb	e8		inx				inx
.a2ec	20 aa 9d	jsr $9daa			jsr 	Evaluate16BitIntegerSigned
.a2ef	60		rts				rts
.a2f0					_GCCPRange:
.a2f0	4c a3 9f	jmp $9fa3			jmp 	RangeError
.a2f3					GCLoadAXY:
.a2f3	ad 60 06	lda $0660			lda 	gxXPos+1
.a2f6	ae 5f 06	ldx $065f			ldx 	gxXPos
.a2f9	ac 61 06	ldy $0661			ldy 	gxYPos
.a2fc	60		rts				rts
.a2fd					GCCopyPairToStore:
.a2fd	a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.a2ff	8d 5f 06	sta $065f			sta 	gxXPos
.a302	a5 61		lda $61				lda 	NSMantissa1+1
.a304	8d 60 06	sta $0660			sta 	gxXPos+1
.a307	a5 5a		lda $5a				lda 	NSMantissa0+2
.a309	8d 61 06	sta $0661			sta 	gxYPos
.a30c	60		rts				rts
.065d					gxCommandID:
>065d							.fill 	1
.065e					gxFillSolid:
>065e							.fill 	1
.065f					gxXPos:
>065f							.fill 	2
.0661					gxYPos:
>0661							.fill 	1
.0662					gxHandler:
>0662							.fill 	2
.0664					gxDrawScale:
>0664							.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcontrol.asm

.a30d					BitmapCtrl:
.a30d	b1 30		lda ($30),y			lda 	(codePtr),y
.a30f	c8		iny				iny
.a310	a2 01		ldx #$01			ldx 	#1
.a312	c9 c4		cmp #$c4			cmp 	#KWD_ON
.a314	f0 11		beq $a327			beq 	BitmapSwitch
.a316	ca		dex				dex
.a317	c9 c3		cmp #$c3			cmp 	#KWD_OFF
.a319	f0 0c		beq $a327			beq 	BitmapSwitch
.a31b	20 bb 9d	jsr $9dbb			jsr 	Evaluate8BitInteger 		; get the colour
.a31e	5a		phy				phy
.a31f	aa		tax				tax
.a320	a9 06		lda #$06			lda 	#GCMD_Clear					; clear to that colour
.a322	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a325	7a		ply				ply
.a326	60		rts				rts
.a327					BitmapSwitch:
.a327	5a		phy				phy
.a328	a0 00		ldy #$00			ldy 	#0 							; gfx 1,on/off,0
.a32a	a9 02		lda #$02			lda 	#GCMD_BitmapCtl
.a32c	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a32f	a9 08		lda #$08			lda 	#GCMD_Colour				; set colour to $FF
.a331	a0 00		ldy #$00			ldy 	#0
.a333	a2 ff		ldx #$ff			ldx 	#$FF
.a335	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a338	9c 5e 06	stz $065e			stz 	gxFillSolid
.a33b	9c 5f 06	stz $065f			stz 	gxXPos
.a33e	9c 60 06	stz $0660			stz 	gxXPos+1
.a341	9c 61 06	stz $0661			stz 	gxYPos
.a344	9c 64 06	stz $0664			stz 	gxDrawScale
.a347	a9 40		lda #$40			lda 	#GCMD_Move 						; home cursor
.a349	a2 00		ldx #$00			ldx 	#0
.a34b	a0 00		ldy #$00			ldy 	#0
.a34d	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a350	7a		ply				ply
.a351	60		rts				rts
.a352					SpritesCtrl:
.a352	b1 30		lda ($30),y			lda 	(codePtr),y
.a354	c8		iny				iny
.a355	a2 01		ldx #$01			ldx 	#1
.a357	c9 c4		cmp #$c4			cmp 	#KWD_ON
.a359	f0 08		beq $a363			beq 	SpriteSwitch
.a35b	ca		dex				dex
.a35c	c9 c3		cmp #$c3			cmp 	#KWD_OFF
.a35e	f0 03		beq $a363			beq 	SpriteSwitch
.a360	4c 9e 9f	jmp $9f9e			jmp 	SyntaxError
.a363					SpriteSwitch:
.a363	5a		phy				phy
.a364	a0 00		ldy #$00			ldy 	#0 							; gfx 2,on/off,0
.a366	a9 04		lda #$04			lda 	#GCMD_SpriteCtl
.a368	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a36b	7a		ply				ply
.a36c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gfx.asm

.a36d					GfxCommand:
.a36d	a2 00		ldx #$00			ldx 	#0
.a36f	20 bb 9d	jsr $9dbb			jsr 	Evaluate8BitInteger 		; command
.a372	20 e8 8e	jsr $8ee8			jsr 	CheckComma
.a375	e8		inx				inx
.a376	20 a0 9d	jsr $9da0			jsr 	Evaluate16BitInteger 		; X
.a379	20 e8 8e	jsr $8ee8			jsr 	CheckComma
.a37c	e8		inx				inx
.a37d	20 bb 9d	jsr $9dbb			jsr 	Evaluate8BitInteger 		; Y
.a380	a5 61		lda $61				lda 	NSMantissa1+1  				; shift bit 0 of X into CS, should now be zero
.a382	4a		lsr a				lsr 	a
.a383	d0 12		bne $a397			bne 	_GfxError
.a385	26 58		rol $58				rol 	NSMantissa0 				; rotate into command
.a387	b0 0e		bcs $a397			bcs 	_GfxError 					; bit 7 should have been zero
.a389	5a		phy				phy 								; save pos
.a38a	a5 58		lda $58				lda 	NSMantissa0 				; do the command
.a38c	a6 59		ldx $59				ldx 	NSMantissa0+1
.a38e	a4 5a		ldy $5a				ldy 	NSMantissa0+2
.a390	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a393	b0 02		bcs $a397			bcs 	_GfxError
.a395	7a		ply				ply 								; restore pos and exit.
.a396	60		rts				rts
.a397					_GfxError:
.a397	4c a3 9f	jmp $9fa3			jmp 	RangeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/hit.asm

.a39a					UnaryHit:
.a39a	fa		plx				plx
.a39b	a9 36		lda #$36			lda 	#zTemp0
.a39d	20 bb 9d	jsr $9dbb			jsr 	Evaluate8BitInteger 		; get sprite number 0
.a3a0	20 e8 8e	jsr $8ee8			jsr 	CheckComma
.a3a3	e8		inx				inx
.a3a4	20 bb 9d	jsr $9dbb			jsr 	Evaluate8BitInteger 		; get sprite number 1
.a3a7	20 e0 8e	jsr $8ee0			jsr		CheckRightBracket
.a3aa	ca		dex				dex 								; fix back up again.
.a3ab	da		phx				phx 								; save X/Y
.a3ac	5a		phy				phy
.a3ad	b4 59		ldy $59,x			ldy 	NSMantissa0+1,x 			; get the sprite numbers into X/Y
.a3af	b5 58		lda $58,x			lda 	NSMantissa0,x
.a3b1	aa		tax				tax
.a3b2	a9 12		lda #$12			lda 	#GCMD_SpriteCollide 		; command check collision.
.a3b4	20 15 80	jsr $8015			jsr 	GXGraphicDraw 				; calculate result
.a3b7	1a		inc a				inc 	a 							; so 255 (fail) -> 0, otherwise 1,2,3,4 pixels etc.
.a3b8	7a		ply				ply 								; restore XY
.a3b9	fa		plx				plx
.a3ba	20 22 9e	jsr $9e22			jsr 	NSMSetByte 					; return the hit result
.a3bd	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/palette.asm

.a3be					PaletteCommand:
.a3be	a2 00		ldx #$00			ldx 	#0
.a3c0	20 bb 9d	jsr $9dbb			jsr 	Evaluate8BitInteger 		; colour
.a3c3	20 e8 8e	jsr $8ee8			jsr 	CheckComma
.a3c6	e8		inx				inx
.a3c7	20 a0 9d	jsr $9da0			jsr 	Evaluate16BitInteger 		; r
.a3ca	20 e8 8e	jsr $8ee8			jsr 	CheckComma
.a3cd	e8		inx				inx
.a3ce	20 bb 9d	jsr $9dbb			jsr 	Evaluate8BitInteger 		; g
.a3d1	20 e8 8e	jsr $8ee8			jsr 	CheckComma
.a3d4	e8		inx				inx
.a3d5	20 bb 9d	jsr $9dbb			jsr 	Evaluate8BitInteger 		; b
.a3d8	a5 58		lda $58				lda 	NSMantissa0 				; get colour #
.a3da	85 36		sta $36				sta 	zTemp0
.a3dc	a9 34		lda #$34			lda 	#$D0 >> 2 					; MSB = D0/4
.a3de	85 37		sta $37				sta 	zTemp0+1
.a3e0	06 36		asl $36				asl 	zTemp0 						; zTemp = $D000+Colour x 4
.a3e2	26 37		rol $37				rol	 	zTemp0+1
.a3e4	06 36		asl $36				asl 	zTemp0
.a3e6	26 37		rol $37				rol	 	zTemp0+1
.a3e8	a9 01		lda #$01			lda 	#1 							; I/O Page 2
.a3ea	85 01		sta $01				sta 	1
.a3ec	5a		phy				phy
.a3ed	a5 5b		lda $5b				lda 	NSMantissa0+3 				; fix to r,g,b
.a3ef	92 36		sta ($36)			sta 	(zTemp0)
.a3f1	a0 01		ldy #$01			ldy 	#1
.a3f3	a5 5a		lda $5a				lda 	NSMantissa0+2
.a3f5	91 36		sta ($36),y			sta 	(zTemp0),y
.a3f7	a5 59		lda $59				lda 	NSMantissa0+1
.a3f9	c8		iny				iny
.a3fa	91 36		sta ($36),y			sta 	(zTemp0),y
.a3fc	7a		ply				ply
.a3fd	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/event.asm

.a3fe					UnaryEvent:
.a3fe	fa		plx				plx
.a3ff	20 ac a4	jsr $a4ac			jsr 	TimerToStackX 				; timer in +0
.a402	e8		inx				inx  								; put reference into +1
.a403	20 47 98	jsr $9847			jsr 	EvaluateTerm
.a406	b5 50		lda $50,x			lda 	NSStatus,x 					; check if is integer reference
.a408	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.a40a	d0 4c		bne $a458			bne 	_UEType
.a40c	e8		inx				inx 								; put the step in +2
.a40d	20 e8 8e	jsr $8ee8			jsr 	CheckComma
.a410	20 a0 9d	jsr $9da0			jsr 	Evaluate16BitInteger
.a413	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket
.a416	ca		dex				dex
.a417	ca		dex				dex
.a418	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy reference to zTemp0
.a41a	85 36		sta $36				sta 	zTemp0
.a41c	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.a41e	85 37		sta $37				sta 	zTemp0+1
.a420	5a		phy				phy
.a421	a0 03		ldy #$03			ldy 	#3 							; check bit 7 of last bit, the packed sign bit
.a423	b1 36		lda ($36),y			lda 	(zTemp0),y
.a425	30 2d		bmi $a454			bmi 	_UEFalse 					; exit if signed.
.a427	a0 00		ldy #$00			ldy 	#0 							; has it timed out (24 bit)
.a429	b5 58		lda $58,x			lda 	NSMantissa0,x
.a42b	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.a42d	c8		iny				iny
.a42e	b5 60		lda $60,x			lda 	NSMantissa1,x
.a430	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a432	c8		iny				iny
.a433	b5 68		lda $68,x			lda 	NSMantissa2,x
.a435	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a437	90 1b		bcc $a454			bcc 	_UEFalse 					; no, return FALSE.
.a439	18		clc				clc
.a43a	a0 00		ldy #$00			ldy 	#0 							; work out new value as timer() + step
.a43c	b5 58		lda $58,x			lda 	NSMantissa0,x
.a43e	75 5a		adc $5a,x			adc 	NSMantissa0+2,x
.a440	91 36		sta ($36),y			sta 	(zTemp0),y
.a442	c8		iny				iny
.a443	b5 60		lda $60,x			lda 	NSMantissa1,x
.a445	75 62		adc $62,x			adc 	NSMantissa1+2,x
.a447	91 36		sta ($36),y			sta 	(zTemp0),y
.a449	c8		iny				iny
.a44a	b5 68		lda $68,x			lda 	NSMantissa2,x
.a44c	75 6a		adc $6a,x			adc 	NSMantissa2+2,x
.a44e	91 36		sta ($36),y			sta 	(zTemp0),y
.a450	7a		ply				ply
.a451	4c 66 8f	jmp $8f66			jmp 	ReturnTrue
.a454					_UEFalse:
.a454	7a		ply				ply 								; restore Y
.a455	4c 71 8f	jmp $8f71			jmp 	ReturnFalse 				; and return False
.a458					_UEType:
.a458	4c a8 9f	jmp $9fa8			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/joy.asm

.a45b					UnaryJoyX:
.a45b	18		clc				clc
.a45c	80 01		bra $a45f			bra 	JoyMain
.a45e					UnaryJoyY:
.a45e	38		sec				sec
.a45f					JoyMain:
.a45f	fa		plx				plx 								; get pos
.a460	08		php				php 								; save carry (set for Y)
.a461	20 bb 9d	jsr $9dbb			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a464	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket
.a467	20 0f 80	jsr $800f			jsr 	EXTReadController 			; read the controller.
.a46a	28		plp				plp
.a46b	90 02		bcc $a46f			bcc 	_JMNoShift 					; if Y then shift bits 3,2 -> 1,0
.a46d	4a		lsr a				lsr 	a
.a46e	4a		lsr a				lsr 	a
.a46f					_JMNoShift:
.a46f	4a		lsr a				lsr 	a 							; if bit 0 set then right/down e.g. +1
.a470	b0 0a		bcs $a47c			bcs 	_JMIsRight
.a472	4a		lsr a				lsr 	a 							; if bit 1 set then left/up e.g. -1
.a473	b0 04		bcs $a479			bcs 	_JMIsLeft
.a475	20 20 9e	jsr $9e20			jsr 	NSMSetZero 					; zero result
.a478	60		rts				rts
.a479					_JMIsLeft:
.a479	4c 66 8f	jmp $8f66			jmp 	ReturnTrue
.a47c					_JMIsRight:
.a47c	a9 01		lda #$01			lda 	#1
.a47e	20 22 9e	jsr $9e22			jsr 	NSMSetByte
.a481	60		rts				rts
.a482					UnaryJoyB:
.a482	fa		plx				plx 								; get pos
.a483	20 bb 9d	jsr $9dbb			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a486	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket
.a489	20 0f 80	jsr $800f			jsr 	EXTReadController 			; read the controller.
.a48c	4a		lsr a				lsr 	a
.a48d	4a		lsr a				lsr 	a
.a48e	4a		lsr a				lsr 	a
.a48f	4a		lsr a				lsr 	a
.a490	29 01		and #$01			and 	#1
.a492	20 22 9e	jsr $9e22			jsr 	NSMSetByte
.a495	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/load.asm

.a496					LoadCommand:
.a496	20 2e 8a	jsr $8a2e			jsr 	NewProgram
.a499	20 20 83	jsr $8320			jsr 	BackLoadProgram
.a49c	4c d7 83	jmp $83d7			jmp 	WarmStart
.a49f					GoCommand:
.a49f	20 2e 8a	jsr $8a2e			jsr 	NewProgram
.a4a2	20 20 83	jsr $8320			jsr 	BackLoadProgram
.a4a5	4c 6f 8b	jmp $8b6f			jmp 	CommandRun

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/timer.asm

.a4a8					UnaryTimer:
.a4a8	fa		plx				plx
.a4a9	20 e0 8e	jsr $8ee0			jsr 	CheckRightBracket
.a4ac					TimerToStackX:
.a4ac	20 20 9e	jsr $9e20			jsr 	NSMSetZero 					; zero result
.a4af	64 01		stz $01				stz 	1 							; access I/O
.a4b1	ad 59 d6	lda $d659			lda 	$D659 						; copy timer in
.a4b4	95 58		sta $58,x			sta 	NSMantissa0,x
.a4b6	ad 5a d6	lda $d65a			lda 	$D65A
.a4b9	95 60		sta $60,x			sta 	NSMantissa1,x
.a4bb	ad 5b d6	lda $d65b			lda 	$D65B
.a4be	95 68		sta $68,x			sta 	NSMantissa2,x
.a4c0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/delete.asm

.a4c1					MemoryDeleteLine:
.a4c1	20 e0 a4	jsr $a4e0			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a4c4	b2 30		lda ($30)			lda 	(codePtr) 					; size to delete => y
.a4c6	a8		tay				tay
.a4c7					_MDDLLoop:
.a4c7	b1 30		lda ($30),y			lda 	(codePtr),y 				; copy down
.a4c9	92 30		sta ($30)			sta 	(codePtr)
.a4cb	a5 30		lda $30				lda 	codePtr 					; check done the lot.
.a4cd	c5 3a		cmp $3a				cmp 	zTemp2
.a4cf	d0 07		bne $a4d8			bne 	_MDLDLNext
.a4d1	a5 31		lda $31				lda 	codePtr+1
.a4d3	c5 3b		cmp $3b				cmp 	zTemp2+1
.a4d5	d0 01		bne $a4d8			bne 	_MDLDLNext
.a4d7					_MDDLExit:
.a4d7	60		rts				rts
.a4d8					_MDLDLNext:
.a4d8	e6 30		inc $30				inc 	codePtr						; next byte
.a4da	d0 eb		bne $a4c7			bne 	_MDDLLoop
.a4dc	e6 31		inc $31				inc 	codePtr+1
.a4de	80 e7		bra $a4c7			bra 	_MDDLLoop
.a4e0					IMemoryFindEnd:
.a4e0	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a4e2	85 3a		sta $3a				sta 	0+zTemp2
.a4e4	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a4e6	85 3b		sta $3b				sta 	1+zTemp2
.a4e8					_MDLFELoop:
.a4e8	b2 3a		lda ($3a)			lda 	(zTemp2)
.a4ea	f0 0b		beq $a4f7			beq 	_MDLFEExit
.a4ec	18		clc				clc
.a4ed	65 3a		adc $3a				adc 	zTemp2
.a4ef	85 3a		sta $3a				sta 	zTemp2
.a4f1	90 f5		bcc $a4e8			bcc 	_MDLFELoop
.a4f3	e6 3b		inc $3b				inc 	zTemp2+1
.a4f5	80 f1		bra $a4e8			bra 	_MDLFELoop
.a4f7					_MDLFEExit:
.a4f7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/insert.asm

.a4f8					MemoryInsertLine:
.a4f8	08		php				php
.a4f9	20 e0 a4	jsr $a4e0			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a4fc	a5 3b		lda $3b				lda 	zTemp2+1 					; space ?
.a4fe	1a		inc a				inc 	a
.a4ff	c9 7f		cmp #$7f			cmp 	#(BasicEnd >> 8)-1
.a501	b0 36		bcs $a539			bcs 	_MDLIError
.a503	28		plp				plp
.a504	90 08		bcc $a50e			bcc 	_MDLIFound
.a506	a5 3a		lda $3a				lda 	zTemp2 						; if CS on entry append.
.a508	85 30		sta $30				sta 	codePtr
.a50a	a5 3b		lda $3b				lda 	zTemp2+1
.a50c	85 31		sta $31				sta 	codePtr+1
.a50e					_MDLIFound:
.a50e	ad 2a 04	lda $042a			lda 	tokenOffset 				; insert gap in Y, the offset, e.g. length of the new line
.a511	a8		tay				tay
.a512					_MDLIInsert:
.a512	b2 3a		lda ($3a)			lda 	(zTemp2) 					; shift one byte up , at least one covers end case.
.a514	91 3a		sta ($3a),y			sta 	(zTemp2),y 					; work from top down.
.a516	a5 30		lda $30				lda 	codePtr 					; done insert point ?
.a518	c5 3a		cmp $3a				cmp 	zTemp2
.a51a	d0 06		bne $a522			bne 	_MDLINext
.a51c	a5 31		lda $31				lda 	codePtr+1
.a51e	c5 3b		cmp $3b				cmp 	zTemp2+1
.a520	f0 0a		beq $a52c			beq 	_MDLIHaveSpace
.a522					_MDLINext:
.a522	a5 3a		lda $3a				lda 	zTemp2 						; if no, keep zTemp2 going backwards
.a524	d0 02		bne $a528			bne 	_MDLINoBorrow
.a526	c6 3b		dec $3b				dec 	zTemp2+1
.a528					_MDLINoBorrow:
.a528	c6 3a		dec $3a				dec 	zTemp2
.a52a	80 e6		bra $a512			bra 	_MDLIInsert
.a52c					_MDLIHaveSpace:
.a52c	ac 2a 04	ldy $042a			ldy 	tokenOffset 				; bytes to copy
.a52f	88		dey				dey 								; from offset-1 to 0
.a530					_MDLICopy:
.a530	b9 2a 04	lda $042a,y			lda 	tokenOffset,y
.a533	91 30		sta ($30),y			sta 	(codePtr),y
.a535	88		dey				dey
.a536	10 f8		bpl $a530			bpl 	_MDLICopy
.a538	60		rts				rts
.a539					_MDLIError:
.a539	a9 06		lda #$06		lda	#6
.a53b	4c f9 8e	jmp $8ef9		jmp	ErrorHandler
.a53e					MDLAppendLine:
.a53e	86 37		stx $37				stx 	zTemp0+1 					; save new line at zTemp0
.a540	85 36		sta $36				sta 	zTemp0
.a542	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a544	85 38		sta $38				sta 	0+zTemp1
.a546	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a548	85 39		sta $39				sta 	1+zTemp1
.a54a	b2 38		lda ($38)			lda 	(zTemp1)
.a54c	d0 0a		bne $a558			bne 	_MDLANoInitialise
.a54e	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a550	8d 65 06	sta $0665			sta 	0+AppendPointer
.a553	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a555	8d 66 06	sta $0666			sta 	1+AppendPointer
.a558					_MDLANoInitialise:
.a558	18		clc				clc
.a559	ad 65 06	lda $0665			lda 	AppendPointer 				; copy append pointer to zTemp1 adding the offset as you go
.a55c	85 38		sta $38				sta 	zTemp1
.a55e	72 36		adc ($36)			adc 	(zTemp0)
.a560	8d 65 06	sta $0665			sta 	AppendPointer
.a563	ad 66 06	lda $0666			lda 	AppendPointer+1
.a566	85 39		sta $39				sta 	zTemp1+1
.a568	69 00		adc #$00			adc 	#0
.a56a	8d 66 06	sta $0666			sta 	AppendPointer+1
.a56d	a0 00		ldy #$00			ldy 	#0
.a56f					_MDLACopy:
.a56f	b1 36		lda ($36),y			lda 	(zTemp0),y 					; copy new line in
.a571	91 38		sta ($38),y			sta 	(zTemp1),y
.a573	c8		iny				iny
.a574	98		tya				tya
.a575	d2 36		cmp ($36)			cmp 	(zTemp0) 					; done whole line
.a577	d0 f6		bne $a56f			bne 	_MDLACopy
.a579	a9 00		lda #$00			lda 	#0 							; end of program.
.a57b	91 38		sta ($38),y			sta 	(zTemp1),y
.a57d	60		rts				rts
.0665					AppendPointer:
>0665							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/memory.asm

.a57e					MemoryNew:
.a57e	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a580	85 30		sta $30				sta 	codePtr
.a582	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a584	85 31		sta $31				sta 	codePtr+1
.a586	a9 00		lda #$00			lda 	#0 							; write zero there erasing the program.
.a588	92 30		sta ($30)			sta 	(codePtr)
.a58a	60		rts				rts
.a58b					MemoryInline:
.a58b	98		tya				tya 								; put address into stack,x
.a58c	18		clc				clc  								; get the offset, add codePtr
.a58d	65 30		adc $30				adc 	codePtr
.a58f	95 58		sta $58,x			sta 	NSMantissa0,x 				; store the result in the mantissa.
.a591	a5 31		lda $31				lda 	codePtr+1
.a593	69 00		adc #$00			adc 	#0
.a595	95 60		sta $60,x			sta 	NSMantissa1,x
.a597	74 68		stz $68,x			stz 	NSMantissa2,x
.a599	74 70		stz $70,x			stz 	NSMantissa3,x
.a59b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/search.asm

.a59c					MemorySearch:
.a59c	85 36		sta $36				sta 	zTemp0 						; save line number in zTemp0
.a59e	86 37		stx $37				stx 	zTemp0+1
.a5a0	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a5a2	85 30		sta $30				sta 	codePtr
.a5a4	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a5a6	85 31		sta $31				sta 	codePtr+1
.a5a8					_MTAXLoop:
.a5a8	b2 30		lda ($30)			lda 	(codePtr)
.a5aa	18		clc				clc
.a5ab	f0 21		beq $a5ce			beq 	_MTAXExit 					; reached end, exit with CC.
.a5ad	a0 01		ldy #$01			ldy 	#1 							; calculate current line# - requested line#
.a5af	b1 30		lda ($30),y			lda 	(codePtr),y
.a5b1	38		sec				sec
.a5b2	e5 36		sbc $36				sbc 	zTemp0
.a5b4	85 38		sta $38				sta 	zTemp1 						; save interim to set Z
.a5b6	c8		iny				iny 								; do the MSB
.a5b7	b1 30		lda ($30),y			lda 	(codePtr),y
.a5b9	e5 37		sbc $37				sbc 	zTemp0+1
.a5bb	05 38		ora $38				ora 	zTemp1 						; will set Z if result is zero, doesn't affect carry flag
.a5bd	f0 0f		beq $a5ce			beq 	_MTAXExit	 				; found so exit (CS will be set)
.a5bf	b0 0d		bcs $a5ce			bcs 	_MTAXExit 					; current < required exit
.a5c1	18		clc				clc
.a5c2	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.a5c4	65 30		adc $30				adc 	codePtr
.a5c6	85 30		sta $30				sta 	codePtr
.a5c8	90 02		bcc $a5cc			bcc 	_CREExit
.a5ca	e6 31		inc $31				inc 	codePtr+1 					; carry
.a5cc					_CREExit:
.a5cc	80 da		bra $a5a8			bra 	_MTAXLoop
.a5ce					_MTAXExit:
.a5ce	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/effects.asm

.a5cf					PingCommand:
.a5cf	5a		phy				phy 								; save pos
.a5d0	a9 01		lda #$01			lda 	#1 						; push channel.
.a5d2	48		pha				pha
.a5d3	a9 c8		lda #$c8			lda 	#200 						; pitch LSB
.a5d5	a2 03		ldx #$03			ldx 	#3 						; length
.a5d7	a0 00		ldy #$00			ldy 	#0 						; slide LSB
.a5d9	80 24		bra $a5ff			bra 	SoundEffectCommand
.a5db					ZapCommand:
.a5db	5a		phy				phy 								; save pos
.a5dc	a9 01		lda #$01			lda 	#1 						; push channel.
.a5de	48		pha				pha
.a5df	a9 ff		lda #$ff			lda 	#255 						; pitch LSB
.a5e1	a2 05		ldx #$05			ldx 	#5 						; length
.a5e3	a0 14		ldy #$14			ldy 	#20 						; slide LSB
.a5e5	80 18		bra $a5ff			bra 	SoundEffectCommand
.a5e7					ShootCommand:
.a5e7	5a		phy				phy 								; save pos
.a5e8	a9 03		lda #$03			lda 	#3 						; push channel.
.a5ea	48		pha				pha
.a5eb	a9 20		lda #$20			lda 	#32 						; pitch LSB
.a5ed	a2 02		ldx #$02			ldx 	#2 						; length
.a5ef	a0 00		ldy #$00			ldy 	#0 						; slide LSB
.a5f1	80 0c		bra $a5ff			bra 	SoundEffectCommand
.a5f3					Explode:
.a5f3	5a		phy				phy 								; save pos
.a5f4	a9 03		lda #$03			lda 	#3 						; push channel.
.a5f6	48		pha				pha
.a5f7	a9 50		lda #$50			lda 	#80 						; pitch LSB
.a5f9	a2 05		ldx #$05			ldx 	#5 						; length
.a5fb	a0 00		ldy #$00			ldy 	#0 						; slide LSB
.a5fd	80 00		bra $a5ff			bra 	SoundEffectCommand
.a5ff					SoundEffectCommand:
.a5ff	8d 67 06	sta $0667			sta 	SoundCommandBlock 			; set up the command block in sound.asm
.a602	9c 68 06	stz $0668			stz 	SoundCommandBlock+1
.a605	a9 0f		lda #$0f			lda 	#15
.a607	8d 69 06	sta $0669			sta 	SoundCommandBlock+2
.a60a	8e 6a 06	stx $066a			stx 	SoundCommandBlock+3
.a60d	8c 6b 06	sty $066b			sty 	SoundCommandBlock+4
.a610	9c 6c 06	stz $066c			stz 	SoundCommandBlock+5
.a613	68		pla				pla
.a614	09 10		ora #$10			ora 	#$10  						; execute command $11
.a616	a2 67		ldx #$67			ldx 	#(SoundCommandBlock & $FF)
.a618	a0 06		ldy #$06			ldy 	#(SoundCommandBlock >> 8)
.a61a	20 18 80	jsr $8018			jsr 	SNDCommand
.a61d	7a		ply				ply
.a61e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/playing.asm

.a61f					UnaryPlaying:
.a61f	fa		plx				plx
.a620	20 bb 9d	jsr $9dbb			jsr 	Evaluate8BitInteger 		; get channel #
.a623	48		pha				pha
.a624	20 e0 8e	jsr $8ee0			jsr		CheckRightBracket
.a627	68		pla				pla
.a628	c9 04		cmp #$04			cmp 	#4
.a62a	b0 0c		bcs $a638			bcs 	_UPNotPlaying
.a62c	09 20		ora #$20			ora 	#$20 						; query playing ?
.a62e	20 18 80	jsr $8018			jsr 	SNDCommand
.a631	c9 00		cmp #$00			cmp 	#0
.a633	f0 03		beq $a638			beq 	_UPNotPlaying
.a635	4c 66 8f	jmp $8f66			jmp 	ReturnTrue
.a638					_UPNotPlaying:
.a638	4c 71 8f	jmp $8f71			jmp 	ReturnFalse

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/sound.asm

.a63b					SoundCommand:
.a63b	b1 30		lda ($30),y			lda 	(codePtr),y
.a63d	c9 c3		cmp #$c3			cmp 	#KWD_OFF 					; SOUND OFF ?
.a63f	d0 09		bne $a64a			bne 	_SNDMain
.a641	c8		iny				iny 								; skip OFF
.a642	a9 3f		lda #$3f			lda 	#$3F 						; call command $3F (silence)
.a644	5a		phy				phy
.a645	20 18 80	jsr $8018			jsr 	SNDCommand
.a648	7a		ply				ply
.a649	60		rts				rts
.a64a					_SNDMain:
.a64a	a2 00		ldx #$00			ldx 	#0
.a64c	20 bb 9d	jsr $9dbb			jsr 	Evaluate8BitInteger 		; channel
.a64f	c9 04		cmp #$04			cmp 	#4 							; must be 0-3
.a651	b0 4b		bcs $a69e			bcs 	_SndError
.a653	e8		inx				inx 								; do the rest in slot 1.
.a654	20 e8 8e	jsr $8ee8			jsr 	CheckComma
.a657	20 a0 9d	jsr $9da0			jsr 	Evaluate16BitInteger 		; Pitch
.a65a	b5 60		lda $60,x			lda 	NSMantissa1,x 				; must be 10 bit
.a65c	c9 10		cmp #$10			cmp 	#16
.a65e	b0 3e		bcs $a69e			bcs 	_SndError
.a660	8d 68 06	sta $0668			sta 	SoundCommandBlock+1 		; Pitch (2 bytes + 0)
.a663	b5 58		lda $58,x			lda 	NSMantissa0,x
.a665	8d 67 06	sta $0667			sta 	SoundCommandBlock
.a668	20 e8 8e	jsr $8ee8			jsr 	CheckComma
.a66b	20 bb 9d	jsr $9dbb			jsr 	Evaluate8BitInteger 		; Length (1 byte + 3)
.a66e	8d 6a 06	sta $066a			sta 	SoundCommandBlock+3
.a671	a9 0f		lda #$0f			lda 	#15
.a673	8d 69 06	sta $0669			sta 	SoundCommandBlock+2 		; Volume (1 byte + 2)
.a676	9c 6b 06	stz $066b			stz 	SoundCommandBlock+4 		; default slide (2 bytes +4)
.a679	9c 6c 06	stz $066c			stz 	SoundCommandBlock+5
.a67c	b1 30		lda ($30),y			lda 	(codePtr),y
.a67e	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.a680	d0 0e		bne $a690			bne 	_SNDPlay
.a682	c8		iny				iny
.a683	20 aa 9d	jsr $9daa			jsr 	Evaluate16BitIntegerSigned 	; Slide
.a686	b5 58		lda $58,x			lda 	NSMantissa0,x 				; Slide (2 bytes + 4)
.a688	8d 6b 06	sta $066b			sta 	SoundCommandBlock+4
.a68b	b5 60		lda $60,x			lda 	NSMantissa1,x
.a68d	8d 6c 06	sta $066c			sta 	SoundCommandBlock+5
.a690					_SNDPlay:
.a690	5a		phy				phy
.a691	a5 58		lda $58				lda 	NSMantissa0 				; channel.
.a693	09 10		ora #$10			ora 	#$10 						; 1x = Queue sound
.a695	a2 67		ldx #$67			ldx 	#(SoundCommandBlock & $FF)
.a697	a0 06		ldy #$06			ldy 	#(SoundCommandBlock >> 8)
.a699	20 18 80	jsr $8018			jsr 	SNDCommand
.a69c	7a		ply				ply
.a69d	60		rts				rts
.a69e					_SndError:
.a69e	4c a3 9f	jmp $9fa3			jmp 	RangeError
.0667					SoundCommandBlock:
>0667							.fill 	6

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/bytes.asm

.a6a1					StackPushByte:
.a6a1	48		pha				pha 								; save byte on stack
.a6a2	a5 34		lda $34				lda 	BasicStack 					; decrement basic stack pointer
.a6a4	d0 08		bne $a6ae			bne 	_SPBNoBorrow
.a6a6	c6 35		dec $35				dec 	BasicStack+1 				; borrow
.a6a8	a5 35		lda $35				lda 	BasicStack+1 				; check range.
.a6aa	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a6ac	90 06		bcc $a6b4			bcc 	_SPBMemory
.a6ae					_SPBNoBorrow:
.a6ae	c6 34		dec $34				dec 	BasicStack
.a6b0	68		pla				pla 								; get back and write
.a6b1	92 34		sta ($34)			sta 	(BasicStack)
.a6b3	60		rts				rts
.a6b4					_SPBMemory:
.a6b4	a9 12		lda #$12		lda	#18
.a6b6	4c f9 8e	jmp $8ef9		jmp	ErrorHandler
.a6b9					StackPopByte:
.a6b9	b2 34		lda ($34)			lda 	(BasicStack) 				; bump the stack pointer.
.a6bb	e6 34		inc $34				inc 	BasicStack
.a6bd	d0 02		bne $a6c1			bne 	_SPBNoCarry
.a6bf	e6 35		inc $35				inc 	BasicStack+1
.a6c1					_SPBNoCarry:
.a6c1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/frames.asm

.a6c2					StackOpen:
.a6c2	48		pha				pha 								; save frame byte
.a6c3	29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.a6c5	0a		asl a				asl 	a 							; claim twice this for storage
.a6c6	49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.a6c8	38		sec				sec 								; so basically subtracting from
.a6c9	65 34		adc $34				adc 	basicStack 	 				; basicStack
.a6cb	85 34		sta $34				sta 	basicStack
.a6cd	b0 09		bcs $a6d8			bcs 	_SONoBorrow
>a6cf	db						.byte 	$DB 						; causes a break in the emulator
.a6d0	c6 35		dec $35				dec 	basicStack+1
.a6d2	a5 35		lda $35				lda 	basicStack+1 				; have we reached stack overflow
.a6d4	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a6d6	90 04		bcc $a6dc			bcc 	_SOMemory
.a6d8					_SONoBorrow:
.a6d8	68		pla				pla 								; get marker back and write at TOS
.a6d9	92 34		sta ($34)			sta 	(basicStack)
.a6db	60		rts				rts
.a6dc					_SOMemory:
.a6dc	a9 12		lda #$12		lda	#18
.a6de	4c f9 8e	jmp $8ef9		jmp	ErrorHandler
.a6e1					StackClose:
.a6e1	b2 34		lda ($34)			lda 	(basicStack) 				; get TOS marker
.a6e3	29 0f		and #$0f			and 	#$0F 						; bytes to add back
.a6e5	0a		asl a				asl 	a 							; claim twice this.
.a6e6	65 34		adc $34				adc 	basicStack 					; add to the stack pointer.
.a6e8	85 34		sta $34				sta 	basicStack
.a6ea	90 02		bcc $a6ee			bcc 	_SCExit
.a6ec	e6 35		inc $35				inc 	basicStack+1
.a6ee					_SCExit:
.a6ee	60		rts				rts
.a6ef					StackCheckFrame:
.a6ef	48		pha				pha
.a6f0					_StackRemoveLocals:
.a6f0	b2 34		lda ($34)			lda 	(basicStack) 				; check for local, keep popping them
.a6f2	c9 03		cmp #$03			cmp 	#STK_LOCALS+1 				; is the frame a local ? S or N are 1/0
.a6f4	b0 05		bcs $a6fb			bcs 	_SCNoLocal
.a6f6	20 dd 89	jsr $89dd			jsr 	LocalPopValue 				; restore the local value
.a6f9	80 f5		bra $a6f0			bra 	_StackRemoveLocals 			; gr round again
.a6fb					_SCNoLocal:
.a6fb	68		pla				pla 								; get the frame check.
.a6fc	52 34		eor ($34)			eor 	(basicStack) 				; xor with toS marker
.a6fe	29 f0		and #$f0			and 	#$F0 						; check type bits
.a700	d0 01		bne $a703			bne 	_SCFError 					; different, we have structures mixed up
.a702	60		rts				rts
.a703					_SCFError:
.a703	8a		txa				txa 								; report error X
.a704	4c f9 8e	jmp $8ef9			jmp 	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/location.asm

.a707					STKSaveCodePosition:
.a707	5a		phy				phy
.a708	98		tya				tya 								; save Y
.a709	a0 05		ldy #$05			ldy 	#5
.a70b	91 34		sta ($34),y			sta 	(basicStack),y
.a70d	88		dey				dey 								; save Code Pointer
.a70e					_STKSaveLoop:
.a70e	b9 2f 00	lda $002f,y			lda 	safePtr-1,y 				; allows us to access the pointer w/out issues.
.a711	91 34		sta ($34),y			sta 	(basicStack),y
.a713	88		dey				dey
.a714	d0 f8		bne $a70e			bne 	_STKSaveLoop
.a716	7a		ply				ply
.a717	60		rts				rts
.a718					STKLoadCodePosition:
.a718	a0 01		ldy #$01			ldy 	#1 							; load code pointer back
.a71a					_STKLoadLoop:
.a71a	b1 34		lda ($34),y			lda 	(basicStack),y
.a71c	99 2f 00	sta $002f,y			sta 	safePtr-1,y
.a71f	c8		iny				iny
.a720	c0 05		cpy #$05			cpy 	#5
.a722	d0 f6		bne $a71a			bne 	_STKLoadLoop
.a724	b1 34		lda ($34),y			lda 	(basicStack),y 				; get Y offset
.a726	a8		tay				tay
.a727	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/setup.asm

.a728					StackReset:
.a728	a9 ff		lda #$ff			lda 	#((BasicStackBase+BasicStackSize-1) & $FF)
.a72a	85 34		sta $34				sta 	0+basicStack
.a72c	a9 0f		lda #$0f			lda 	#((BasicStackBase+BasicStackSize-1) >> 8)
.a72e	85 35		sta $35				sta 	1+basicStack
.a730	a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.a732	92 34		sta ($34)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.a734	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/concrete.asm

.a735					StringConcrete:
.a735	5a		phy				phy 								; save position on stack
.a736	20 33 9a	jsr $9a33			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a739	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy target string to zTemp1
.a73b	85 38		sta $38				sta 	zTemp1
.a73d	b5 60		lda $60,x			lda 	NSMantissa1,x
.a73f	85 39		sta $39				sta 	zTemp1+1
.a741	a0 ff		ldy #$ff			ldy 	#$FF	 					; calculate string length
.a743					_SALength:
.a743	c8		iny				iny
.a744	b1 38		lda ($38),y			lda 	(zTemp1),y
.a746	d0 fb		bne $a743			bne 	_SALength
.a748	c0 fd		cpy #$fd			cpy 	#253 						; string too long - cannot concrete.
.a74a	b0 3d		bcs $a789			bcs 	_SALengthError
.a74c	98		tya				tya 				 				; length of the new string
.a74d	18		clc				clc
.a74e	69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.a750	90 02		bcc $a754			bcc 	_SAHaveLength
.a752	a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.a754					_SAHaveLength:
.a754	48		pha				pha 								; save length.
.a755	38		sec				sec
.a756	49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.a758	6d 0e 04	adc $040e			adc 	StringMemory
.a75b	8d 0e 04	sta $040e			sta 	StringMemory
.a75e	85 3a		sta $3a				sta 	zTemp2 						; update storage address
.a760	95 58		sta $58,x			sta 	NSMantissa0,x 				; update mantissa address
.a762	a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.a764	6d 0f 04	adc $040f			adc 	StringMemory+1
.a767	8d 0f 04	sta $040f			sta 	StringMemory+1
.a76a	85 3b		sta $3b				sta 	zTemp2+1
.a76c	95 60		sta $60,x			sta 	NSMantissa1,x
.a76e	68		pla				pla 								; save length-3 (chars allowed) in first byte
.a76f	38		sec				sec
.a770	e9 03		sbc #$03			sbc 	#3
.a772	92 3a		sta ($3a)			sta 	(zTemp2)
.a774	a9 00		lda #$00			lda 	#0 							; clear the status byte.
.a776	a0 01		ldy #$01			ldy 	#1
.a778	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a77a					_SACopyNewString:
.a77a	a0 00		ldy #$00			ldy 	#0
.a77c					_SACopyNSLoop:
.a77c	b1 38		lda ($38),y			lda 	(zTemp1),y 					; get character
.a77e	c8		iny				iny 								; write two on in string storage
.a77f	c8		iny				iny
.a780	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a782	88		dey				dey 								; this makes it one one.
.a783	c9 00		cmp #$00			cmp 	#0 							; until EOS copied
.a785	d0 f5		bne $a77c			bne 	_SACopyNSLoop
.a787	7a		ply				ply
.a788	60		rts				rts
.a789					_SALengthError:
.a789	a9 09		lda #$09		lda	#9
.a78b	4c f9 8e	jmp $8ef9		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/stringalloc.asm

.a78e					StringSystemInitialise:
.a78e	a9 ff		lda #$ff			lda 	#((EndVariableSpace-1) & $FF)
.a790	8d 0e 04	sta $040e			sta 	0+StringMemory
.a793	a9 1f		lda #$1f			lda 	#((EndVariableSpace-1) >> 8)
.a795	8d 0f 04	sta $040f			sta 	1+StringMemory
.a798	9c ff 1f	stz $1fff			stz 	EndVariableSpace-1 			; put a zero at the end, so know end of string memory.
.a79b	60		rts				rts
.a79c					StringSpaceInitialise:
.a79c	20 33 9a	jsr $9a33			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a79f	a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.a7a1	8d 10 04	sta $0410			sta 	StringInitialised
.a7a4	ad 0e 04	lda $040e			lda 	StringMemory 				; allocate 256 bytes for one concreted string
.a7a7	8d 11 04	sta $0411			sta 	StringTempPointer 			; so temporary string space is allocated below that.
.a7aa	ad 0f 04	lda $040f			lda 	StringMemory+1
.a7ad	3a		dec a				dec 	a
.a7ae	8d 12 04	sta $0412			sta 	StringTempPointer+1
.a7b1	60		rts				rts
.a7b2					StringTempAllocate:
.a7b2	c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.a7b4	b0 30		bcs $a7e6			bcs 	_STALength
.a7b6	2c 10 04	bit $0410			bit 	StringInitialised 			; already initialised
.a7b9	30 05		bmi $a7c0			bmi 	_STAAllocate
.a7bb	48		pha				pha 								; save value to subtract.
.a7bc	20 9c a7	jsr $a79c			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.a7bf	68		pla				pla 								; restore it
.a7c0					_STAAllocate:
.a7c0	49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.a7c2	18		clc				clc  								; deliberate allows one more
.a7c3	6d 11 04	adc $0411			adc 	StringTempPointer 			; subtract from temp pointer
.a7c6	8d 11 04	sta $0411			sta 	StringTempPointer
.a7c9	95 58		sta $58,x			sta 	NSMantissa0,x 				; address in mantissa
.a7cb	85 3c		sta $3c				sta 	zsTemp 						; and zsTemp
.a7cd	ad 12 04	lda $0412			lda 	StringTempPointer+1
.a7d0	69 ff		adc #$ff			adc 	#$FF
.a7d2	8d 12 04	sta $0412			sta 	StringTempPointer+1
.a7d5	85 3d		sta $3d				sta 	zsTemp+1
.a7d7	95 60		sta $60,x			sta 	NSMantissa1,x
.a7d9	74 68		stz $68,x			stz 	NSMantissa2,x 				; set the typing data and the upper address bytes.
.a7db	74 70		stz $70,x			stz 	NSMantissa3,x
.a7dd	a9 10		lda #$10			lda 	#NSTString
.a7df	95 50		sta $50,x			sta 	NSStatus,x
.a7e1	a9 00		lda #$00			lda 	#0 							; clear the target string
.a7e3	92 3c		sta ($3c)			sta 	(zsTemp)
.a7e5	60		rts				rts
.a7e6					_STALength:
.a7e6	a9 09		lda #$09		lda	#9
.a7e8	4c f9 8e	jmp $8ef9		jmp	ErrorHandler
.a7eb					StringTempWrite:
.a7eb	48		pha				pha
.a7ec	92 3c		sta ($3c)			sta 	(zsTemp) 					; write byte
.a7ee	e6 3c		inc $3c				inc 	zsTemp 						; bump pointer
.a7f0	d0 02		bne $a7f4			bne 	_STWNoCarry
.a7f2	e6 3d		inc $3d				inc 	zsTemp+1
.a7f4					_STWNoCarry:
.a7f4	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.a7f6	92 3c		sta ($3c)			sta 	(zsTemp)
.a7f8	68		pla				pla
.a7f9	60		rts				rts

;******  Return to file: _basic.asm

.a7fa					StartModuleCode:

;******  Processing file: ../modules/_build/_hardware.module

=1					hardwareIntegrated=1
=0					CONBlack = 0
=1					CONWhite = 1
=2					CONRed = 2
=3					CONCyan = 3
=4					CONPurple = 4
=5					CONGreen = 5
=6					CONBlue = 6
=7					CONYellow = 7
=8					CONOrange = 8
=9					CONBrown = 9
=10					CONYellowGreen = 10
=11					CONRosa = 11
=12					CONBlueGreen = 12
=13					CONLightBlue = 13
=14					CONPink = 14
=15					CONLightGreen = 15
=7					CONForeground = CONYellow
=6					CONBackground = CONBlue
=5					CLICommandLine = CONGreen
=0					CLIFComment = CONBlack
=7					CLIBComment = CONYellow
=9					CLILineNumber = CONBrown
=3					CLIToken = CONCyan
=13					CLIConstant = CONLightBlue
=7					CLIIdentifier = CONYellow
=10					CLIPunctuation = CONYellowGreen
=1					CLIData = CONWhite
.a7fa					Export_EXTPrintCharacter:
.a7fa					PAGEDPrintCharacter:
.a7fa	48		pha				pha
.a7fb	da		phx				phx
.a7fc	5a		phy				phy
.a7fd	a6 01		ldx $01				ldx 	1
.a7ff	da		phx				phx
.a800	ac 6e 06	ldy $066e			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.a803	09 00		ora #$00			ora 	#$00 						; check $80-$FF
.a805	30 48		bmi $a84f			bmi 	_EXPCColour
.a807	c9 20		cmp #$20			cmp 	#$20 						; check $00-$1F
.a809	90 4d		bcc $a858			bcc 	_EXPCControl
.a80b	a2 02		ldx #$02			ldx 	#2 							; select char memory
.a80d	86 01		stx $01				stx 	1
.a80f	91 40		sta ($40),y			sta 	(EXTAddress),y
.a811	e6 01		inc $01				inc 	1 							; select colour memory
.a813	ad 6f 06	lda $066f			lda 	EXTTextColour
.a816	91 40		sta ($40),y			sta 	(EXTAddress),y
.a818	c8		iny				iny 								; advance horizontal position
.a819	8c 6e 06	sty $066e			sty 	EXTColumn
.a81c	cc 70 06	cpy $0670			cpy 	EXTScreenWidth 				; reached RHS ?
.a81f	90 63		bcc $a884			bcc 	_EXPCExit 					; no, then exit.
.a821					_EXPCCRLF:
.a821	ee 6d 06	inc $066d			inc 	EXTRow  					; bump row
.a824	9c 6e 06	stz $066e			stz 	EXTColumn 					; back to column 0
.a827	ad 6d 06	lda $066d			lda 	EXTRow 						; check if reached the bottom ?
.a82a	cd 71 06	cmp $0671			cmp 	EXTScreenHeight 			; if so, then scroll.
.a82d	f0 18		beq $a847			beq 	_EXPCScroll
.a82f	18		clc				clc 								; add width to address.
.a830	a5 40		lda $40				lda 	EXTAddress
.a832	6d 70 06	adc $0670			adc 	EXTScreenWidth
.a835	85 40		sta $40				sta 	EXTAddress
.a837	90 4b		bcc $a884			bcc 	_EXPCExit
.a839	e6 41		inc $41				inc 	EXTAddress+1
.a83b	80 47		bra $a884			bra 	_EXPCExit
.a83d					_EXPCLeft:
.a83d	ce 6e 06	dec $066e			dec 	EXTColumn
.a840	10 42		bpl $a884			bpl 	_EXPCExit
.a842					_EXPCBegin:
.a842	9c 6e 06	stz $066e			stz 	EXTColumn
.a845	80 3d		bra $a884			bra 	_EXPCExit
.a847					_EXPCScroll:
.a847	ce 6d 06	dec $066d			dec 	EXTRow 						; the height-1 th line.
.a84a	20 35 a9	jsr $a935			jsr 	EXTScreenScroll 			; scroll the screen
.a84d	80 35		bra $a884			bra 	_EXPCExit
.a84f					_EXPCColour:
.a84f	c9 a0		cmp #$a0			cmp 	#$A0						; 80-9F set foreground/background
.a851	b0 31		bcs $a884			bcs 	_EXPCExit
.a853	20 15 a9	jsr $a915			jsr 	_EXPCHandleColour
.a856	80 2c		bra $a884			bra 	_EXPCExit
.a858					_EXPCControl:
.a858	c9 11		cmp #$11			cmp 	#$11 						; only handle 00-10.
.a85a	b0 28		bcs $a884			bcs 	_EXPCExit
.a85c	0a		asl a				asl 	a 							; double into X
.a85d	aa		tax				tax
.a85e	7c f3 a8	jmp ($a8f3,x)			jmp 	(_EXPCActionTable,x) 		; and execute code.
.a861					_EXPCUp:
.a861	ad 6d 06	lda $066d			lda 	EXTRow 						; already at top ?
.a864	f0 1e		beq $a884			beq 	_EXPCExit
.a866	ce 6d 06	dec $066d			dec 	EXTRow 						; up one in position/address
.a869	38		sec				sec
.a86a	a5 40		lda $40				lda 	EXTAddress
.a86c	ed 70 06	sbc $0670			sbc 	EXTScreenWidth
.a86f	85 40		sta $40				sta 	EXTAddress
.a871	b0 11		bcs $a884			bcs 	_EXPCExit
.a873	c6 41		dec $41				dec 	EXTAddress+1
.a875	80 0d		bra $a884			bra 	_EXPCExit
.a877					_EXPCRight:
.a877	c8		iny				iny
.a878	8c 6e 06	sty $066e			sty 	EXTColumn
.a87b	cc 70 06	cpy $0670			cpy 	EXTScreenWidth
.a87e	d0 04		bne $a884			bne 	_EXPCExit
.a880	88		dey				dey
.a881					_EXPCSetColumnY:
.a881	8c 6e 06	sty $066e			sty 	EXTColumn
.a884					_EXPCExit:
.a884	20 8a a9	jsr $a98a			jsr 	EXTSetHardwareCursor 		; place the physical cursor.
.a887	68		pla				pla
.a888	85 01		sta $01				sta 	1
.a88a	7a		ply				ply
.a88b	fa		plx				plx
.a88c	68		pla				pla
.a88d	60		rts				rts
.a88e					_EXPCClearScreen:
.a88e	20 47 a9	jsr $a947			jsr		EXTClearScreenCode
.a891	80 f1		bra $a884			bra 	_EXPCExit
.a893					_EXPCDown:
.a893	ad 71 06	lda $0671			lda 	EXTScreenHeight 			; at the bottom
.a896	3a		dec a				dec 	a
.a897	cd 6d 06	cmp $066d			cmp 	EXTRow
.a89a	f0 e8		beq $a884			beq 	_EXPCExit
.a89c	ee 6d 06	inc $066d			inc 	EXTRow 						; down one in position/address
.a89f	18		clc				clc
.a8a0	a5 40		lda $40				lda 	EXTAddress
.a8a2	6d 70 06	adc $0670			adc 	EXTScreenWidth
.a8a5	85 40		sta $40				sta 	EXTAddress
.a8a7	90 db		bcc $a884			bcc 	_EXPCExit
.a8a9	e6 41		inc $41				inc 	EXTAddress+1
.a8ab	80 d7		bra $a884			bra 	_EXPCExit
.a8ad					_EXPCTab:
.a8ad	ad 6e 06	lda $066e			lda 	EXTColumn 					; next tab stop
.a8b0	29 f8		and #$f8			and 	#$F8
.a8b2	18		clc				clc
.a8b3	69 08		adc #$08			adc 	#8
.a8b5	8d 6e 06	sta $066e			sta 	EXTColumn
.a8b8	cd 70 06	cmp $0670			cmp 	EXTScreenWidth 				; too far, stick end of line.
.a8bb	90 c7		bcc $a884			bcc 	_EXPCExit
.a8bd	80 10		bra $a8cf			bra 	_EXPCEnd
.a8bf					_EXPCBackSpace:
.a8bf	88		dey				dey
.a8c0	30 c2		bmi $a884			bmi 	_EXPCExit
.a8c2	ce 6e 06	dec $066e			dec 	EXTColumn
.a8c5	a9 02		lda #$02			lda 	#2
.a8c7	85 01		sta $01				sta 	1
.a8c9	a9 20		lda #$20			lda 	#32
.a8cb	91 40		sta ($40),y			sta 	(EXTAddress),y
.a8cd	80 b5		bra $a884			bra 	_EXPCExit
.a8cf					_EXPCEnd:
.a8cf	a9 02		lda #$02			lda 	#2 							; access text screen
.a8d1	85 01		sta $01				sta 	1
.a8d3	ac 70 06	ldy $0670			ldy 	EXTScreenWidth 				; point to last character
.a8d6	88		dey				dey
.a8d7					_EXPCEndSearch:
.a8d7	88		dey				dey 								; if past start, move to col 0.
.a8d8	30 06		bmi $a8e0			bmi 	_EXPCFound
.a8da	b1 40		lda ($40),y			lda 	(EXTAddress),y 				; keep going back till non space found
.a8dc	c9 20		cmp #$20			cmp 	#' '
.a8de	f0 f7		beq $a8d7			beq 	_EXPCEndSearch
.a8e0					_EXPCFound:
.a8e0	c8		iny				iny 								; move to following cell.
.a8e1	80 9e		bra $a881			bra 	_EXPCSetColumnY
.a8e3					_EXPCClearEOL:
.a8e3	a9 02		lda #$02			lda 	#2 							; access character RAM
.a8e5	85 01		sta $01				sta 	1
.a8e7	a9 20		lda #$20			lda 	#' ' 						; write space
.a8e9	91 40		sta ($40),y			sta 	(EXTAddress),y
.a8eb	c8		iny				iny
.a8ec	cc 70 06	cpy $0670			cpy 	EXTScreenWidth 				; until RHS of screen.
.a8ef	90 f2		bcc $a8e3			bcc 	_EXPCClearEOL
.a8f1	80 91		bra $a884			bra 	_EXPCExit
.a8f3					_EXPCActionTable:
>a8f3	84 a8						.word 	_EXPCExit 					; 00
>a8f5	42 a8						.word 	_EXPCBegin 					; 01 A Start of Line
>a8f7	3d a8						.word 	_EXPCLeft 					; 02 B Left
>a8f9	84 a8						.word 	_EXPCExit 					; 03 <Break>
>a8fb	84 a8						.word 	_EXPCExit 					; 04
>a8fd	cf a8						.word 	_EXPCEnd 					; 05 E End of Line
>a8ff	77 a8						.word 	_EXPCRight 					; 06 F Right
>a901	84 a8						.word 	_EXPCExit 					; 07
>a903	bf a8						.word 	_EXPCBackspace 				; 08 H Backspace
>a905	ad a8						.word 	_EXPCTab 					; 09 I Tab
>a907	84 a8						.word 	_EXPCExit 					; 0A
>a909	e3 a8						.word 	_EXPCClearEOL 				; 0B K Clear to EOL
>a90b	8e a8						.word 	_EXPCClearScreen			; 0C L CLS
>a90d	21 a8						.word 	_EXPCCRLF 					; 0D M CR/LF
>a90f	93 a8						.word 	_EXPCDown 					; 0E N Down
>a911	84 a8						.word 	_EXPCExit 					; 0F
>a913	61 a8						.word 	_EXPCUp 					; 10 P Up
.a915					_EXPCHandleColour
.a915	c9 90		cmp #$90			cmp 	#$90 						; 8x foreground 9x background
.a917	b0 16		bcs $a92f			bcs 	_EXPCBackground
.a919	0a		asl a				asl 	a 							; shift it 4 bits to the right.
.a91a	0a		asl a				asl 	a
.a91b	0a		asl a				asl 	a
.a91c	0a		asl a				asl 	a
.a91d	a2 0f		ldx #$0f			ldx 	#$0F 						; Mask in X
.a91f					_EXPCUpdate:
.a91f	48		pha				pha 								; save new colour
.a920	8a		txa				txa 								; get mask
.a921	2d 6f 06	and $066f			and 	EXTTextColour 				; mask out old.
.a924	8d 6f 06	sta $066f			sta 	EXTTextColour
.a927	68		pla				pla 								; or in new colour
.a928	0d 6f 06	ora $066f			ora 	EXTTextColour
.a92b	8d 6f 06	sta $066f			sta 	EXTTextColour
.a92e	60		rts				rts
.a92f					_EXPCBackground:
.a92f	29 0f		and #$0f			and 	#$0F 						; get the colour
.a931	a2 f0		ldx #$f0			ldx 	#$F0 						; mask
.a933	80 ea		bra $a91f			bra 	_EXPCUpdate
.a935					EXTScreenScroll:
.a935	a9 02		lda #$02			lda 	#2 							; select text page
.a937	85 01		sta $01				sta 	1
.a939	a9 20		lda #$20			lda		#32 						; fill with space
.a93b	20 4e aa	jsr $aa4e			jsr 	EXTScrollFill
.a93e	e6 01		inc $01				inc 	1 							; select colour page
.a940	ad 6f 06	lda $066f			lda 	EXTTextColour
.a943	20 4e aa	jsr $aa4e			jsr 	EXTScrollFill
.a946	60		rts				rts
.a947					EXTClearScreenCode:
.a947	a9 02		lda #$02			lda 	#2 							; select text page
.a949	85 01		sta $01				sta 	1
.a94b	a9 20		lda #$20			lda		#32 						; fill with space
.a94d	20 5a a9	jsr $a95a			jsr 	_EXTCSFill
.a950	e6 01		inc $01				inc 	1 							; select colour page
.a952	ad 6f 06	lda $066f			lda 	EXTTextColour
.a955	20 5a a9	jsr $a95a			jsr 	_EXTCSFill
.a958	80 22		bra $a97c			bra 	EXTHomeCursor
.a95a					_EXTCSFill:
.a95a	aa		tax				tax
.a95b	a9 00		lda #$00			lda 	#EXTMemory & $FF
.a95d	85 40		sta $40				sta 	EXTAddress
.a95f	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a961	85 41		sta $41				sta 	EXTAddress+1
.a963					_EXTCSFill1:
.a963	a0 00		ldy #$00			ldy 	#0
.a965	8a		txa				txa
.a966					_EXTCSFill2:
.a966	91 40		sta ($40),y			sta 	(EXTAddress),y
.a968	c8		iny				iny
.a969	d0 fb		bne $a966			bne 	_EXTCSFill2
.a96b	e6 41		inc $41				inc 	EXTAddress+1
.a96d	a5 41		lda $41				lda 	EXTAddress+1
.a96f	c9 d2		cmp #$d2			cmp 	#$D2
.a971	d0 f0		bne $a963			bne 	_EXTCSFill1
.a973	8a		txa				txa
.a974					_EXTCSFill3:
.a974	91 40		sta ($40),y			sta 	(EXTAddress),y
.a976	c8		iny				iny
.a977	c0 c0		cpy #$c0			cpy 	#$C0
.a979	d0 f9		bne $a974			bne 	_EXTCSFill3
.a97b	60		rts				rts
.a97c					EXTHomeCursor:
.a97c	9c 6d 06	stz $066d			stz 	EXTRow 						; reset row & column
.a97f	9c 6e 06	stz $066e			stz 	EXTColumn
.a982	a9 00		lda #$00			lda 	#EXTMemory & $FF 			; set address
.a984	85 40		sta $40				sta 	EXTAddress
.a986	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a988	85 41		sta $41				sta 	EXTAddress+1
.a98a					EXTSetHardwareCursor:
.a98a	64 01		stz $01				stz 	1 							; I/O Page zero
.a98c	a9 05		lda #$05			lda 	#1+4 						; enable cursor
.a98e	8d 10 d0	sta $d010			sta 	$D010
.a991	a9 b1		lda #$b1			lda 	#$B1
.a993	8d 12 d0	sta $d012			sta 	$D012
.a996	ad 6e 06	lda $066e			lda 	EXTColumn
.a999	8d 14 d0	sta $d014			sta 	$D014 						; set cursor position
.a99c	9c 15 d0	stz $d015			stz 	$D015
.a99f	ad 6d 06	lda $066d			lda 	EXTRow
.a9a2	8d 16 d0	sta $d016			sta 	$D016
.a9a5	9c 17 d0	stz $d017			stz 	$D017
.a9a8	60		rts				rts
.a9a9					Export_EXTInputLine:
.a9a9	48		pha				pha
.a9aa	da		phx				phx
.a9ab	5a		phy				phy
.a9ac	a5 01		lda $01				lda 	1 							; save I/O page
.a9ae	48		pha				pha
.a9af					_EILLoop:
.a9af	20 c9 aa	jsr $aac9			jsr 	PagedInputSingleCharacter
.a9b2	c9 0d		cmp #$0d			cmp 	#13 						; scrape line if exit.
.a9b4	f0 44		beq $a9fa			beq 	_EILExit
.a9b6	c9 04		cmp #$04			cmp 	#4 							; Ctrl+D delete at cursor
.a9b8	f0 2a		beq $a9e4			beq 	_EILDelete
.a9ba	c9 08		cmp #$08			cmp 	#8 							; Ctrl+H backspace
.a9bc	f0 1c		beq $a9da			beq 	_EILBackspace
.a9be	c9 20		cmp #$20			cmp 	#' '						; < space, print it
.a9c0	90 12		bcc $a9d4			bcc 	_EILPrintLoop
.a9c2	c9 7f		cmp #$7f			cmp 	#$7F 						; if -ve print it
.a9c4	b0 0e		bcs $a9d4			bcs 	_EILPrintLoop
.a9c6	48		pha				pha 								; save character
.a9c7	a9 02		lda #$02			lda 	#2  						; insert a space
.a9c9	85 01		sta $01				sta 	1
.a9cb	20 3c aa	jsr $aa3c			jsr 	EXTILInsert 				; insert in text screen
.a9ce	e6 01		inc $01				inc 	1
.a9d0	20 3c aa	jsr $aa3c			jsr 	EXTILInsert 				; insert in colour screen
.a9d3	68		pla				pla 								; get character back.
.a9d4					_EILPrintLoop:
.a9d4	20 fa a7	jsr $a7fa			jsr 	PagedPrintCharacter
.a9d7	80 d6		bra $a9af			bra 	_EILLoop
.a9d9	60		rts				rts
.a9da					_EILBackspace:
.a9da	ad 6e 06	lda $066e			lda 	EXTColumn					; can we backspace ?
.a9dd	f0 d0		beq $a9af			beq 	_EILLoop
.a9df	a9 02		lda #$02			lda 	#2 							; move cursor left
.a9e1	20 fa a7	jsr $a7fa			jsr 	PagedPrintCharacter
.a9e4					_EILDelete
.a9e4	a9 02		lda #$02			lda 	#2 							; text block
.a9e6	85 01		sta $01				sta 	1
.a9e8	a9 20		lda #$20			lda 	#' ' 						; backspace text.
.a9ea	20 27 aa	jsr $aa27			jsr 	EXTILDelete
.a9ed	e6 01		inc $01				inc 	1 							; colour block
.a9ef	ac 6e 06	ldy $066e			ldy 	EXTColumn 					; get attribute of last character
.a9f2	88		dey				dey
.a9f3	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a9f5	20 27 aa	jsr $aa27			jsr 	EXTILDelete 				; backspace attribute
.a9f8	80 b5		bra $a9af			bra 	_EILLoop 					; and go round.
.a9fa					_EILExit:
.a9fa	a9 02		lda #$02			lda 	#2 							; switch to page 2
.a9fc	85 01		sta $01				sta 	1
.a9fe	a0 00		ldy #$00			ldy 	#0 							; copy current line into buffer.
.aa00					_EILScrapeLine:
.aa00	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa02	99 2a 05	sta $052a,y			sta 	lineBuffer,y
.aa05	c8		iny				iny
.aa06	cc 70 06	cpy $0670			cpy 	EXTScreenWidth
.aa09	d0 f5		bne $aa00			bne 	_EILScrapeLine
.aa0b					_EILTrimSpaces:
.aa0b	88		dey				dey
.aa0c	f0 08		beq $aa16			beq 	_EILEndTrim
.aa0e	b9 2a 05	lda $052a,y			lda 	lineBuffer,y
.aa11	c9 20		cmp #$20			cmp 	#' '
.aa13	f0 f6		beq $aa0b			beq 	_EILTrimSpaces
.aa15	c8		iny				iny 								; trim after non space character.
.aa16					_EILEndTrim:
.aa16	a9 00		lda #$00			lda 	#0 							; trim here.
.aa18	99 2a 05	sta $052a,y			sta 	lineBuffer,y
.aa1b	a9 0d		lda #$0d			lda 	#13 						; echo the RETURN
.aa1d	20 fa a7	jsr $a7fa			jsr 	PagedPrintCharacter
.aa20	68		pla				pla 								; reset I/O page
.aa21	85 01		sta $01				sta 	1
.aa23	7a		ply				ply
.aa24	fa		plx				plx
.aa25	68		pla				pla
.aa26	60		rts				rts
.aa27					EXTILDelete:
.aa27	48		pha				pha 								; save the new character
.aa28	ac 6e 06	ldy $066e			ldy 	EXTColumn 					; start copying from here.
.aa2b					_EXTDLoop:
.aa2b	c8		iny				iny 								; copy one byte down.
.aa2c	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa2e	88		dey				dey
.aa2f	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa31	c8		iny				iny 								; do till end of line.
.aa32	cc 70 06	cpy $0670			cpy 	EXTScreenWidth
.aa35	90 f4		bcc $aa2b			bcc 	_EXTDLoop
.aa37	88		dey				dey 	 							; write in last slot.
.aa38	68		pla				pla
.aa39	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa3b	60		rts				rts
.aa3c					EXTILInsert:
.aa3c	ac 70 06	ldy $0670			ldy 	EXTScreenWidth 				; end position
.aa3f					_EXTILoop:
.aa3f	88		dey				dey 								; back one
.aa40	cc 6e 06	cpy $066e			cpy 	EXTColumn 					; exit if reached insert point.
.aa43	f0 08		beq $aa4d			beq 	_EXTIExit
.aa45	88		dey				dey 								; copy one byte up.
.aa46	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa48	c8		iny				iny
.aa49	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa4b	80 f2		bra $aa3f			bra 	_EXTILoop
.aa4d					_EXTIExit:
.aa4d	60		rts				rts
.aa4e					EXTScrollFill:
.aa4e	aa		tax				tax									; save value to fill with
.aa4f	a5 36		lda $36				lda 	zTemp0 						; save zTemp0 (dest) zTemp1 (src)
.aa51	48		pha				pha
.aa52	a5 37		lda $37				lda 	zTemp0+1
.aa54	48		pha				pha
.aa55	a5 38		lda $38				lda 	zTemp1
.aa57	48		pha				pha
.aa58	a5 39		lda $39				lda 	zTemp1+1
.aa5a	48		pha				pha
.aa5b	a9 c0		lda #$c0			lda 	#$C0 						; copy from C000+length to C000
.aa5d	85 37		sta $37				sta 	zTemp0+1
.aa5f	85 39		sta $39				sta 	zTemp1+1
.aa61	64 36		stz $36				stz 	zTemp0
.aa63	ad 70 06	lda $0670			lda 	EXTScreenWidth
.aa66	85 38		sta $38				sta 	zTemp1
.aa68	a0 00		ldy #$00			ldy 	#0
.aa6a					_EXSFCopy1:
.aa6a	b1 38		lda ($38),y			lda 	(zTemp1),y
.aa6c	91 36		sta ($36),y			sta 	(zTemp0),y
.aa6e	c8		iny				iny
.aa6f	d0 f9		bne $aa6a			bne 	_EXSFCopy1
.aa71	e6 37		inc $37				inc 	zTemp0+1 					; next page
.aa73	e6 39		inc $39				inc 	zTemp1+1
.aa75	a5 39		lda $39				lda 	zTemp1+1
.aa77	c9 d3		cmp #$d3			cmp 	#$D3
.aa79	d0 ef		bne $aa6a			bne 	_EXSFCopy1
.aa7b	ac 70 06	ldy $0670			ldy 	EXTScreenWidth 				; blank the bottom line.
.aa7e	8a		txa				txa
.aa7f					_EXSFFill1:
.aa7f	88		dey				dey
.aa80	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa82	c0 00		cpy #$00			cpy 	#0
.aa84	10 f9		bpl $aa7f			bpl 	_EXSFFill1
.aa86	68		pla				pla
.aa87	85 39		sta $39				sta 	zTemp1+1
.aa89	68		pla				pla
.aa8a	85 38		sta $38				sta 	zTemp1
.aa8c	68		pla				pla
.aa8d	85 37		sta $37				sta 	zTemp0+1
.aa8f	68		pla				pla
.aa90	85 36		sta $36				sta 	zTemp0
.aa92	60		rts				rts
=$c000					EXTMemory = $C000
=$02					EXTTextPage = $02
=$03					EXTColourPage = $03
=1					EXTDummySpace = 1 							; fake-space for CR character.
=0					EXTCBlack = 0
.066d					EXTRow:
>066d							.fill 	1
.066e					EXTColumn:
>066e							.fill 	1
.066f					EXTTextColour:
>066f							.fill 	1
.0670					EXTScreenWidth:
>0670							.fill 	1
.0671					EXTScreenHeight:
>0671							.fill 	1
.0040					EXTAddress:
>0040							.fill 	2
.aa93					Export_EXTInitialise:
.aa93	64 01		stz $01				stz 	1 							; Access I/O page 0
.aa95	9c 04 d0	stz $d004			stz 	$D004 						; Disable border
.aa98	9c 08 d0	stz $d008			stz 	$D008
.aa9b	9c 09 d0	stz $d009			stz 	$D009
.aa9e	a9 09		lda #$09			lda 	#1+8						; Timer On at 70Hz counting up.
.aaa0	8d 58 d6	sta $d658			sta 	$D658
.aaa3	a9 03		lda #$03			lda 	#3 							; get current text colour from whatever the kernel
.aaa5	85 01		sta $01				sta 	1 							; has set it to, looking at top left character
.aaa7	ad 00 c0	lda $c000			lda 	$C000
.aaaa	8d 6f 06	sta $066f			sta 	EXTTextColour
.aaad	a9 50		lda #$50			lda 	#80 						; set screen dimensions.
.aaaf	8d 70 06	sta $0670			sta 	EXTScreenWidth
.aab2	a9 3c		lda #$3c			lda 	#60
.aab4	8d 71 06	sta $0671			sta 	EXTScreenHeight
.aab7	20 7c a9	jsr $a97c			jsr 	EXTHomeCursor 				; home cursor
.aaba					_EXMoveDown:
.aaba	a9 0d		lda #$0d			lda 	#13
.aabc	20 fa a7	jsr $a7fa			jsr 	PAGEDPrintCharacter
.aabf	ad 6d 06	lda $066d			lda 	EXTRow
.aac2	c9 08		cmp #$08			cmp 	#8
.aac4	d0 f4		bne $aaba			bne 	_EXMoveDown
.aac6	64 01		stz $01				stz 	1
.aac8	60		rts				rts
.aac9					Export_EXTInputSingleCharacter:
.aac9					PagedInputSingleCharacter:
.aac9	da		phx				phx
.aaca	5a		phy				phy
.aacb					_EISCWait:
.aacb	a5 01		lda $01				lda 	1 							; save I/O 0
.aacd	48		pha				pha
.aace	64 01		stz $01				stz 	1 							; access I/O Page 0
.aad0	38		sec				sec 								; calculate timer - LastTick
.aad1	ad 59 d6	lda $d659			lda 	$D659
.aad4	aa		tax				tax 								; saving timer in X
.aad5	ed 5c 06	sbc $065c			sbc 	LastTick
.aad8	c9 03		cmp #$03			cmp 	#3
.aada	90 06		bcc $aae2			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.aadc	8e 5c 06	stx $065c			stx 	LastTick 					; update last timer
.aadf	20 a5 be	jsr $bea5			jsr 	PagedSNDUpdate 							; go do the code.
.aae2					_NoFireTick:
.aae2	68		pla				pla 								; restore I/O 0
.aae3	85 01		sta $01				sta 	1
.aae5	20 e4 ff	jsr $ffe4			jsr 	$FFE4 						; get a key
.aae8	c9 00		cmp #$00			cmp 	#0 							; loop back if none pressed.
.aaea	f0 df		beq $aacb			beq 	_EISCWait
.aaec	7a		ply				ply
.aaed	fa		plx				plx
.aaee	60		rts				rts
.aaef					Export_EXTBreakCheck:
.aaef	4c e1 ff	jmp $ffe1			jmp		$FFE1
.aaf2					Export_EXTReadController:
.aaf2	da		phx				phx
.aaf3	a2 00		ldx #$00			ldx 	#0
.aaf5	a9 05		lda #$05			lda 	#(($2D) >> 3)
.aaf7	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aafa	29 20		and #$20			and 	#($01 << (($2D) & 7))
.aafc	f0 04		beq $ab02			beq 	_NoSet1
.aafe	8a		txa				txa
.aaff	09 01		ora #$01			ora 	#1
.ab01	aa		tax				tax
.ab02					_NoSet1:
.ab02	a9 05		lda #$05			lda 	#(($2C) >> 3)
.ab04	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab07	29 10		and #$10			and 	#($01 << (($2C) & 7))
.ab09	f0 04		beq $ab0f			beq 	_NoSet1
.ab0b	8a		txa				txa
.ab0c	09 02		ora #$02			ora 	#2
.ab0e	aa		tax				tax
.ab0f					_NoSet1:
.ab0f	a9 06		lda #$06			lda 	#(($32) >> 3)
.ab11	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab14	29 04		and #$04			and 	#($01 << (($32) & 7))
.ab16	f0 04		beq $ab1c			beq 	_NoSet1
.ab18	8a		txa				txa
.ab19	09 04		ora #$04			ora 	#4
.ab1b	aa		tax				tax
.ab1c					_NoSet1:
.ab1c	a9 04		lda #$04			lda 	#(($25) >> 3)
.ab1e	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab21	29 20		and #$20			and 	#($01 << (($25) & 7))
.ab23	f0 04		beq $ab29			beq 	_NoSet1
.ab25	8a		txa				txa
.ab26	09 08		ora #$08			ora 	#8
.ab28	aa		tax				tax
.ab29					_NoSet1:
.ab29	a9 04		lda #$04			lda 	#(($26) >> 3)
.ab2b	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab2e	29 40		and #$40			and 	#($01 << (($26) & 7))
.ab30	f0 04		beq $ab36			beq 	_NoSet1
.ab32	8a		txa				txa
.ab33	09 10		ora #$10			ora 	#16
.ab35	aa		tax				tax
.ab36					_NoSet1:
.ab36	8a		txa				txa
.ab37	fa		plx				plx
.ab38	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_graphics.module

=1					graphicsIntegrated=1
=0					GCMD_Initialise = 0*2
=2					GCMD_BitmapCtl = 1*2
=4					GCMD_SpriteCtl = 2*2
=6					GCMD_Clear = 3*2
=8					GCMD_Colour = 4*2
=10					GCMD_DrawFont = 5*2
=12					GCMD_DrawSprite = 6*2
=14					GCMD_SpriteUse = 7*2
=16					GCMD_SpriteImage = 8*2
=18					GCMD_SpriteCollide = 9*2
=64					GCMD_Move = 32*2
=66					GCMD_Line = 33*2
=68					GCMD_FrameRect = 34*2
=70					GCMD_FillRect = 35*2
=72					GCMD_FrameCircle = 36*2
=74					GCMD_FillCircle = 37*2
=80					GCMD_Plot = 40*2
=82					GCMD_SpriteMove = 41*2
=42					GRFirstFreeCode = 42
.ab39					GRVectorTable:
>ab39	88 ad					.word	GXInitialise             ; $00 Initialise
>ab3b	a2 ad					.word	GXControlBitmap          ; $01 BitmapCtl
>ab3d	ea ad					.word	GXControlSprite          ; $02 SpriteCtl
>ab3f	3a ad					.word	GXClearBitmap            ; $03 Clear
>ab41	79 af					.word	GXSetColourMode          ; $04 Colour
>ab43	41 b1					.word	GXFontHandler            ; $05 DrawFont
>ab45	89 b1					.word	GXSpriteHandler          ; $06 DrawSprite
>ab47	fa b1					.word	GXSelect                 ; $07 SpriteUse
>ab49	23 b2					.word	GXSelectImage            ; $08 SpriteImage
>ab4b	aa b3					.word	GXCollide                ; $09 SpriteCollide
>ab4d	ec ab					.word	GRUndefined              ; $0a
>ab4f	ec ab					.word	GRUndefined              ; $0b
>ab51	ec ab					.word	GRUndefined              ; $0c
>ab53	ec ab					.word	GRUndefined              ; $0d
>ab55	ec ab					.word	GRUndefined              ; $0e
>ab57	ec ab					.word	GRUndefined              ; $0f
>ab59	ec ab					.word	GRUndefined              ; $10
>ab5b	ec ab					.word	GRUndefined              ; $11
>ab5d	ec ab					.word	GRUndefined              ; $12
>ab5f	ec ab					.word	GRUndefined              ; $13
>ab61	ec ab					.word	GRUndefined              ; $14
>ab63	ec ab					.word	GRUndefined              ; $15
>ab65	ec ab					.word	GRUndefined              ; $16
>ab67	ec ab					.word	GRUndefined              ; $17
>ab69	ec ab					.word	GRUndefined              ; $18
>ab6b	ec ab					.word	GRUndefined              ; $19
>ab6d	ec ab					.word	GRUndefined              ; $1a
>ab6f	ec ab					.word	GRUndefined              ; $1b
>ab71	ec ab					.word	GRUndefined              ; $1c
>ab73	ec ab					.word	GRUndefined              ; $1d
>ab75	ec ab					.word	GRUndefined              ; $1e
>ab77	ec ab					.word	GRUndefined              ; $1f
>ab79	ea ab					.word	GXMove                   ; $20 Move
>ab7b	47 ae					.word	GXLine                   ; $21 Line
>ab7d	c2 af					.word	GXFrameRectangle         ; $22 FrameRect
>ab7f	bf af					.word	GXFillRectangle          ; $23 FillRect
>ab81	f1 ab					.word	GXFrameCircle            ; $24 FrameCircle
>ab83	ed ab					.word	GXFillCircle             ; $25 FillCircle
>ab85	ec ab					.word	GRUndefined              ; $26
>ab87	ec ab					.word	GRUndefined              ; $27
>ab89	a7 af					.word	GXPlotPoint              ; $28 Plot
>ab8b	b9 b2					.word	GXMoveSprite             ; $29 SpriteMove
=3					GXMappingPage = 3
=24576					GXMappingAddress = ($2000 * GXMappingPage)
=11					GXEditSlot = 8 + GXMappingPage
=$36					gxzTemp0 = zTemp0
=$38					gxzTemp1 = zTemp1
=$3a					gxzTemp2 = zTemp2
=$3c					gxzScreen = zsTemp
=$627					gxPixelBuffer = numberBuffer
.0672					gxCurrentX:
>0672							.fill 	2
.0674					gxCurrentY:
>0674							.fill 	2
.0676					gxLastX:
>0676							.fill 	2
.0678					gxLastY:
>0678							.fill 	2
.067a					gxX0:
>067a							.fill 	2
.067c					gxY0:
>067c							.fill 	2
.067e					gxX1:
>067e							.fill 	2
.0680					gxY1:
>0680							.fill 	2
.0682					gxSpritesOn:
>0682							.fill 	1
.0683					gxBitmapsOn:
>0683							.fill 	1
.0684					gxBasePage:
>0684							.fill 	1
.0685					gxSpritePage:
>0685							.fill 	1
.0686					gxHeight:
>0686							.fill 	1
.0687					gxMode:
>0687							.fill 	1
.0688					gxColour:
>0688							.fill 	1
.0689					gxEORValue:
>0689							.fill 	1
.068a					gxANDValue:
>068a							.fill 	1
.068b					gxOriginalLUTValue:
>068b							.fill 	1
.068c					gsOffset:
>068c							.fill 	1
.068d					GSCurrentSpriteID:
>068d							.fill 	1
.068e					GSCurrentSpriteAddr:
>068e							.fill 	2
.0690					GXSpriteOffsetBase:
>0690							.fill 	2
.0692					GXSpriteLow:
>0692							.fill 	64
.06d2					GXSpriteHigh:
>06d2							.fill 	64
.ab8d					Export_GXGraphicDraw:
.ab8d	c9 40		cmp #$40			cmp 	#GCMD_Move					; low instructions don't use coordinates
.ab8f	b0 06		bcs $ab97			bcs 	_GDCoordinate
.ab91	86 36		stx $36				stx 	gxzTemp0 					; save X/Y
.ab93	84 37		sty $37				sty 	gxzTemp0+1
.ab95	80 4b		bra $abe2			bra 	_GDExecuteA 				; and execute
.ab97					_GDCoordinate:
.ab97	48		pha				pha 								; save AXY
.ab98	da		phx				phx
.ab99	5a		phy				phy
.ab9a	a2 03		ldx #$03			ldx 	#3 							; copy currentX to lastX
.ab9c					_GDCopy1:
.ab9c	bd 72 06	lda $0672,x			lda 	gxCurrentX,x
.ab9f	9d 76 06	sta $0676,x			sta 	gxLastX,x
.aba2	ca		dex				dex
.aba3	10 f7		bpl $ab9c			bpl 	_GDCopy1
.aba5	68		pla				pla 								; update Y
.aba6	8d 74 06	sta $0674			sta 	gxCurrentY
.aba9	9c 75 06	stz $0675			stz 	gxCurrentY+1
.abac	68		pla				pla
.abad	8d 72 06	sta $0672			sta 	gxCurrentX
.abb0	68		pla				pla 								; get A (command+X.1) back
.abb1	48		pha				pha
.abb2	29 01		and #$01			and 	#1 							; put LSB as MSB of Current.X
.abb4	8d 73 06	sta $0673			sta 	gxCurrentX+1
.abb7	68		pla				pla 								; get command back
.abb8	29 fe		and #$fe			and 	#$FE 						; lose LSB, chuck the stray X bit
.abba	48		pha				pha 								; push back.
.abbb	c9 52		cmp #$52			cmp 	#GCMD_SpriteMove 			; move sprite does not clip.
.abbd	f0 17		beq $abd6			beq 	_GDCopyToWorkArea
.abbf	ad 73 06	lda $0673			lda 	gxCurrentX+1 				; X < 256 X okay
.abc2	f0 07		beq $abcb			beq 	_GDCheckY
.abc4	ad 72 06	lda $0672			lda 	gxCurrentX 					; otherwise X < 320 = 256 + 64
.abc7	c9 40		cmp #$40			cmp 	#64
.abc9	b0 08		bcs $abd3			bcs 	_GDError1
.abcb					_GDCheckY:
.abcb	ad 74 06	lda $0674			lda 	gxCurrentY 					; check Y < Height.
.abce	cd 86 06	cmp $0686			cmp 	gxHeight
.abd1	90 03		bcc $abd6			bcc 	_GDCopyToWorkArea
.abd3					_GDError1:
.abd3	68		pla				pla
.abd4					_GDError2:
.abd4	38		sec				sec
.abd5	60		rts				rts
.abd6					_GDCopyToWorkArea:
.abd6	a2 07		ldx #$07			ldx 	#7 							; copy current and last to gxXY/12 work area
.abd8					_GDCopy2:
.abd8	bd 72 06	lda $0672,x			lda 	gxCurrentX,x
.abdb	9d 7a 06	sta $067a,x			sta 	gxX0,x
.abde	ca		dex				dex
.abdf	10 f7		bpl $abd8			bpl 	_GDCopy2
.abe1	68		pla				pla 								; get command
.abe2					_GDExecuteA:
.abe2	c9 54		cmp #$54			cmp 	#GRFirstFreeCode*2 			; bad ?
.abe4	b0 ee		bcs $abd4			bcs 	_GDError2
.abe6	aa		tax				tax
.abe7	7c 39 ab	jmp ($ab39,x)			jmp 	(GRVectorTable,x)
.abea					GXMove:
.abea	18		clc				clc
.abeb	60		rts				rts
.abec					GRUndefined:
>abec	db						.byte 	$DB 						; causes a break in the emulator
.abed					GXFillCircle:
.abed	a9 ff		lda #$ff			lda 	#255
.abef	80 02		bra $abf3			bra 	GXCircle
.abf1					GXFrameCircle:
.abf1	a9 00		lda #$00			lda 	#0
.abf3					GXCircle:
.abf3	8d 15 07	sta $0715			sta 	gxIsFillMode					; save Fill flag
.abf6	ad 83 06	lda $0683			lda 	gxBitmapsOn
.abf9	f0 26		beq $ac21			beq 	_GXCFail
.abfb	20 51 b4	jsr $b451			jsr 	GXSortXY 					; topleft/bottomright
.abfe	20 29 b3	jsr $b329			jsr 	GXOpenBitmap 				; start drawing
.ac01	20 f3 ac	jsr $acf3			jsr 	GXCircleSetup 				; set up for drawing
.ac04	9c 16 07	stz $0716			stz 	gxYChanged
.ac07					_GXCircleDraw:
.ac07	ad 13 07	lda $0713			lda 	gXCentre					; while x <= y
.ac0a	cd 14 07	cmp $0714			cmp 	gYCentre
.ac0d	90 0a		bcc $ac19			bcc 	_GXCircleContinue
.ac0f	d0 03		bne $ac14			bne 	_GXNoLast
.ac11	20 26 ac	jsr $ac26			jsr 	GXPlot1
.ac14					_GXNoLast:
.ac14	20 31 b3	jsr $b331			jsr 	GXCloseBitmap 				; close the bitmap
.ac17	18		clc				clc
.ac18	60		rts				rts
.ac19					_GXCircleContinue:
.ac19	20 23 ac	jsr $ac23			jsr 	GXPlot2 					; draw it
.ac1c	20 a0 ac	jsr $aca0			jsr 	GXCircleMove 				; adjust the coordinates
.ac1f	80 e6		bra $ac07			bra 	_GXCircleDraw
.ac21					_GXCFail:
.ac21	38		sec				sec
.ac22	60		rts				rts
.ac23					GXPlot2:
.ac23	20 26 ac	jsr $ac26			jsr 	GXPlot1 						; plot and swap, fall through does twice
.ac26					GXPlot1:
.ac26	ad 14 07	lda $0714			lda 	gYCentre 						; if y = 0, don't do it twice (xor)
.ac29	f0 03		beq $ac2e			beq 	_GXPlot1Only
.ac2b	20 4a ac	jsr $ac4a			jsr 	GXPlot0 						; plot and negate
.ac2e					_GXPlot1Only:
.ac2e	20 4a ac	jsr $ac4a			jsr 	GXPlot0 						; twice, undoing negation
.ac31	ad 13 07	lda $0713			lda 	gXCentre 						; swap X and Y
.ac34	ae 14 07	ldx $0714			ldx	 	gYCentre
.ac37	8d 14 07	sta $0714			sta 	gYCentre
.ac3a	8e 13 07	stx $0713			stx 	gXCentre
.ac3d	ad 16 07	lda $0716			lda 	gxYChanged 						; toggle Y Changed flag
.ac40	a9 ff		lda #$ff			lda 	#$FF
.ac42	8d 16 07	sta $0716			sta 	gxYChanged
.ac45	60		rts				rts
.ac46	20 4a ac	jsr $ac4a			jsr 	GXPlot0 						; do once
.ac49	60		rts				rts
.ac4a	ad 15 07	lda $0715	GXPlot0:lda 	gxIsFillMode 					; outline mode, always draw as X or Y will change
.ac4d	f0 05		beq $ac54			beq 	_GXPlot0Always
.ac4f	ad 16 07	lda $0716			lda 	gxYChanged						; fill mode, only draw if changed.
.ac52	f0 2d		beq $ac81			beq 	GXPlot0Exit
.ac54					_GXPlot0Always:
.ac54	a2 02		ldx #$02			ldx 	#2 								; copy Y1-A => Y0
.ac56	ad 14 07	lda $0714			lda 	gYCentre
.ac59	20 82 ac	jsr $ac82			jsr 	GXSubCopy
.ac5c	a2 00		ldx #$00			ldx 	#0 								; copy X1-A => X0,
.ac5e	ad 13 07	lda $0713			lda 	gXCentre
.ac61	20 82 ac	jsr $ac82			jsr 	GXSubCopy
.ac64	48		pha				pha 									; save last offset X
.ac65	20 39 b3	jsr $b339			jsr 	GXPositionCalc 					; calculate position/offset.
.ac68	68		pla				pla
.ac69	0a		asl a				asl 	a 								; store 2 x last offset in gxzTemp0
.ac6a	85 36		sta $36				sta 	gxzTemp0
.ac6c	64 37		stz $37				stz 	gxzTemp0+1
.ac6e	26 37		rol $37				rol 	gxzTemp0+1
.ac70	ad 15 07	lda $0715			lda 	gxIsFillMode
.ac73	69 80		adc #$80			adc 	#128
.ac75	20 12 b0	jsr $b012			jsr 	GXDrawLineTemp0 				; routine from Rectangle.
.ac78	38		sec				sec 									; GY = -GY
.ac79	a9 00		lda #$00			lda 	#0
.ac7b	ed 14 07	sbc $0714			sbc 	gYCentre
.ac7e	8d 14 07	sta $0714			sta 	gYCentre
.ac81					GXPlot0Exit:
.ac81	60		rts				rts
.ac82					GXSubCopy:
.ac82	85 36		sta $36				sta 	gxzTemp0
.ac84	64 37		stz $37				stz 	gxzTemp0+1
.ac86	29 80		and #$80			and 	#$80
.ac88	f0 02		beq $ac8c			beq 	_GXNoSx
.ac8a	c6 37		dec $37				dec 	gxzTemp0+1
.ac8c					_GXNoSx:
.ac8c	38		sec				sec
.ac8d	bd 7e 06	lda $067e,x			lda 	gXX1,x
.ac90	e5 36		sbc $36				sbc 	gxzTemp0
.ac92	9d 7a 06	sta $067a,x			sta 	gXX0,x
.ac95	bd 7f 06	lda $067f,x			lda 	gXX1+1,x
.ac98	e5 37		sbc $37				sbc 	gxzTemp0+1
.ac9a	9d 7b 06	sta $067b,x			sta 	gXX0+1,x
.ac9d	a5 36		lda $36				lda 	gxzTemp0 						; return A
.ac9f	60		rts				rts
.aca0					GXCircleMove:
.aca0	9c 16 07	stz $0716			stz 	gxYChanged 					; clear Y changed flag
.aca3	a5 39		lda $39				lda 	gxzTemp1+1 					; check sign of D
.aca5	10 0d		bpl $acb4			bpl 	_GXEMPositive
.aca7	ee 13 07	inc $0713			inc 	gXCentre 					; X++
.acaa	ad 13 07	lda $0713			lda 	gXCentre
.acad	20 d3 ac	jsr $acd3			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.acb0	a9 06		lda #$06			lda 	#6  						; and add 6
.acb2	80 15		bra $acc9			bra 	_GXEMAddD
.acb4					_GXEMPositive:
.acb4	ee 13 07	inc $0713			inc 	gXCentre					; X++
.acb7	ce 14 07	dec $0714			dec 	gyCentre 					; Y--
.acba	38		sec				sec 								; calculate X-Y
.acbb	ad 13 07	lda $0713			lda 	gXCentre
.acbe	ed 14 07	sbc $0714			sbc 	gYCentre
.acc1	20 d3 ac	jsr $acd3			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.acc4	a9 0a		lda #$0a			lda 	#10  						; and add 10
.acc6	ce 16 07	dec $0716			dec 	gxYChanged
.acc9					_GXEMAddD:
.acc9	18		clc				clc
.acca	65 38		adc $38				adc 	gxzTemp1
.accc	85 38		sta $38				sta 	gxzTemp1
.acce	90 02		bcc $acd2			bcc 	_GXEMNoCarry
.acd0	e6 39		inc $39				inc 	gxzTemp1+1
.acd2					_GXEMNoCarry:
.acd2	60		rts				rts
.acd3					_GXAdd4TimesToD:
.acd3	85 36		sta $36				sta 	gxzTemp0 					; make 16 bit signed.
.acd5	29 80		and #$80			and 	#$80
.acd7	f0 02		beq $acdb			beq 	_GXA4Unsigned
.acd9	a9 ff		lda #$ff			lda 	#$FF
.acdb					_GXA4Unsigned:
.acdb	85 37		sta $37				sta 	gxzTemp0+1
.acdd	06 36		asl $36				asl 	gxzTemp0  					; x 4
.acdf	26 37		rol $37				rol 	gxzTemp0+1
.ace1	06 36		asl $36				asl 	gxzTemp0
.ace3	26 37		rol $37				rol 	gxzTemp0+1
.ace5	18		clc				clc 								; add
.ace6	a5 36		lda $36				lda		gxzTemp0
.ace8	65 38		adc $38				adc 	gxzTemp1
.acea	85 38		sta $38				sta 	gxzTemp1
.acec	a5 37		lda $37				lda		gxzTemp0+1
.acee	65 39		adc $39				adc 	gxzTemp1+1
.acf0	85 39		sta $39				sta 	gxzTemp1+1
.acf2	60		rts				rts
.acf3					GXCircleSetup:
.acf3	38		sec				sec
.acf4	ad 80 06	lda $0680			lda 	gxY1
.acf7	ed 7c 06	sbc $067c			sbc 	gxY0
.acfa	4a		lsr a				lsr 	a
.acfb	8d 12 07	sta $0712			sta 	gxRadius
.acfe	a2 00		ldx #$00			ldx 	#0
.ad00	20 22 ad	jsr $ad22			jsr 	_GXCalculateCentre
.ad03	a2 02		ldx #$02			ldx 	#2
.ad05	20 22 ad	jsr $ad22			jsr 	_GXCalculateCentre
.ad08	9c 13 07	stz $0713			stz 	gXCentre
.ad0b	ad 12 07	lda $0712			lda 	gxRadius
.ad0e	8d 14 07	sta $0714			sta 	gYCentre
.ad11	0a		asl a				asl 	a 							; R x 2
.ad12	85 36		sta $36				sta 	gxzTemp0
.ad14	38		sec				sec
.ad15	a9 03		lda #$03			lda 	#3
.ad17	e5 36		sbc $36				sbc 	gxzTemp0
.ad19	85 38		sta $38				sta 	gxzTemp1
.ad1b	a9 00		lda #$00			lda 	#0
.ad1d	e9 00		sbc #$00			sbc 	#0
.ad1f	85 39		sta $39				sta 	gxzTemp1+1
.ad21	60		rts				rts
.ad22					_GXCalculateCentre:
.ad22	38		sec				sec
.ad23	bd 7e 06	lda $067e,x			lda 	gxX1,x
.ad26	7d 7a 06	adc $067a,x			adc 	gXX0,x
.ad29	9d 7e 06	sta $067e,x			sta 	gXX1,x
.ad2c	bd 7f 06	lda $067f,x			lda 	gXX1+1,x
.ad2f	7d 7b 06	adc $067b,x			adc 	gXX0+1,x
.ad32	4a		lsr a				lsr 	a
.ad33	9d 7f 06	sta $067f,x			sta 	gXX1+1,x
.ad36	7e 7e 06	ror $067e,x			ror 	gXX1,x
.ad39	60		rts				rts
.0712					gxRadius:
>0712							.fill 	1
.0713					gXCentre:
>0713							.fill 	1
.0714					gYCentre:
>0714							.fill 	1
.0715					gxIsFillMode:
>0715							.fill 	1
.0716					gxYChanged:
>0716							.fill  	1
=64000					ScreenSize200 = 320 * 200
=76800					ScreenSize240 = 320 * 240
.ad3a					GXClearBitmap:
.ad3a	ad 83 06	lda $0683			lda 	gxBitmapsOn 				; check BMP running.
.ad3d	f0 24		beq $ad63			beq 	_GXCBFail
.ad3f	20 29 b3	jsr $b329			jsr 	GXOpenBitmap 				; start access
.ad42	a0 07		ldy #$07			ldy 	#ScreenSize200 / 8192 		; X is pages to clear
.ad44	ad 86 06	lda $0686			lda 	gxHeight
.ad47	c9 c8		cmp #$c8			cmp 	#200 						; 200 ?
.ad49	a0 09		ldy #$09			ldy 	#ScreenSize240 / 8192
.ad4b					_GXCalcLastPage:
.ad4b	98		tya				tya 								; add to base page
.ad4c	18		clc				clc
.ad4d	6d 84 06	adc $0684			adc 	gxBasePage
.ad50	85 0b		sta $0b				sta 	GXEditSlot  				; clear from this page back
.ad52					_GXClearAll:
.ad52	20 65 ad	jsr $ad65			jsr 	_GXClearBlock 				; clear 8k block
.ad55	c6 0b		dec $0b				dec 	GXEditSlot  				; back to previous
.ad57	a5 0b		lda $0b				lda 	GXEditSlot
.ad59	cd 84 06	cmp $0684			cmp 	gxBasePage 					; until before base page
.ad5c	b0 f4		bcs $ad52			bcs 	_GXClearAll
.ad5e	20 31 b3	jsr $b331			jsr 	GXCloseBitmap	 			; stop access
.ad61	18		clc				clc
.ad62	60		rts				rts
.ad63					_GXCBFail:
.ad63	38		sec				sec
.ad64	60		rts				rts
.ad65					_GXClearBlock:
.ad65	a9 00		lda #$00			lda 	#((GXMappingAddress) & $FF)
.ad67	85 38		sta $38				sta 	0+gxzTemp1
.ad69	a9 60		lda #$60			lda 	#((GXMappingAddress) >> 8)
.ad6b	85 39		sta $39				sta 	1+gxzTemp1
.ad6d					_GXCB0:
.ad6d	a5 36		lda $36				lda 	gxzTemp0
.ad6f	a0 00		ldy #$00			ldy 	#0
.ad71					_GXCB1:
.ad71	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad73	c8		iny				iny
.ad74	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad76	c8		iny				iny
.ad77	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad79	c8		iny				iny
.ad7a	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad7c	c8		iny				iny
.ad7d	d0 f2		bne $ad71			bne 	_GXCB1
.ad7f	e6 39		inc $39				inc 	gxzTemp1+1
.ad81	a5 39		lda $39				lda 	gxzTemp1+1
.ad83	c9 80		cmp #$80			cmp	 	#(GXMappingAddress >> 8)+$20
.ad85	d0 e6		bne $ad6d			bne 	_GXCB0
.ad87	60		rts				rts
.ad88					GXInitialise:
.ad88	64 01		stz $01				stz 	1
.ad8a	a9 01		lda #$01			lda 	#1
.ad8c	8d 00 d0	sta $d000			sta 	$D000
.ad8f	18		clc				clc
.ad90	9c 82 06	stz $0682			stz 	GXSpritesOn
.ad93	9c 83 06	stz $0683			stz 	GXBitmapsOn
.ad96	a2 0f		ldx #$0f			ldx 	#15
.ad98					_GXIClear:
.ad98	9e 72 06	stz $0672,x			stz 	gxCurrentX,x
.ad9b	ca		dex				dex
.ad9c	10 fa		bpl $ad98			bpl 	_GXIClear
.ad9e	20 39 ae	jsr $ae39			jsr 	GXClearSpriteStore
.ada1	60		rts				rts
.ada2					GXControlBitmap:
.ada2	64 01		stz $01				stz 	1
.ada4	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.ada6	29 01		and #$01			and 	#1 							; set bitmap flag
.ada8	8d 83 06	sta $0683			sta 	gxBitmapsOn
.adab	4a		lsr a				lsr 	a 							; bit 0 into carry.
.adac	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.adaf	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.adb1	29 f7		and #$f7			and 	#$F7 						; clear bitmap bit
.adb3	90 02		bcc $adb7			bcc 	_CBNotOn
.adb5	09 08		ora #$08			ora 	#$08 						; bitmap on if 1 on 0 off
.adb7					_CBNotOn:
.adb7	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.adba	a5 36		lda $36				lda 	gxzTemp0 					; get control settings (bits 0-2)
.adbc	29 07		and #$07			and 	#7
.adbe	8d 00 d1	sta $d100			sta 	$D100 						; write in Vicky Bitmap Control Register #0
.adc1	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.adc3	d0 02		bne $adc7			bne 	_CBNotDefault
.adc5	a9 08		lda #$08			lda 	#8  						; if zero, use 8 e.g. bitmap at $10000
.adc7					_CBNotDefault:
.adc7	8d 84 06	sta $0684			sta 	gxBasePage
.adca	20 2b ae	jsr $ae2b			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.adcd	a5 37		lda $37				lda 	gxzTemp0+1 					; copy address into Bitmap address registers
.adcf	8d 03 d1	sta $d103			sta 	$D103
.add2	a5 36		lda $36				lda 	gxzTemp0
.add4	8d 02 d1	sta $d102			sta 	$D102
.add7	9c 01 d1	stz $d101			stz 	$D101
.adda	a2 f0		ldx #$f0			ldx 	#240 						; height is 240
.addc	ad 01 d0	lda $d001			lda 	$D001 						; read MCR bit 0
.addf	29 01		and #$01			and 	#1
.ade1	f0 02		beq $ade5			beq 	_CBHaveHeight
.ade3	a2 c8		ldx #$c8			ldx 	#200 						; if bit 0 set 320x200
.ade5					_CBHaveHeight
.ade5	8e 86 06	stx $0686			stx 	gxHeight
.ade8	18		clc				clc
.ade9	60		rts				rts
.adea					GXControlSprite:
.adea	64 01		stz $01				stz 	1
.adec	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.adee	29 01		and #$01			and 	#1 							; set sprites flag
.adf0	8d 82 06	sta $0682			sta 	gxSpritesOn
.adf3	4a		lsr a				lsr 	a 							; bit 0 into carry.
.adf4	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.adf7	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.adf9	29 df		and #$df			and 	#$DF 						; clear sprite bit
.adfb	90 02		bcc $adff			bcc 	_CSNotOn
.adfd	09 20		ora #$20			ora 	#$20 						; sprite on if 1 on 0 off
.adff					_CSNotOn:
.adff	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.ae02	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.ae04	d0 02		bne $ae08			bne 	_CSNotDefault
.ae06	a9 18		lda #$18			lda 	#24  						; if zero, use 24 e.g. sprites at $30000
.ae08					_CSNotDefault:
.ae08	8d 85 06	sta $0685			sta 	gxSpritePage
.ae0b	20 2b ae	jsr $ae2b			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.ae0e	a5 36		lda $36				lda 	zTemp0
.ae10	8d 90 06	sta $0690			sta 	GXSpriteOffsetBase
.ae13	a5 37		lda $37				lda 	zTemp0+1
.ae15	8d 91 06	sta $0691			sta 	GXSpriteOffsetBase+1
.ae18	a2 00		ldx #$00			ldx 	#0 							; disable all sprites, clears all sprite memory.
.ae1a					_CSClear:
.ae1a	9e 00 d9	stz $d900,x			stz 	$D900,x
.ae1d	9e 00 da	stz $da00,x			stz 	$DA00,x
.ae20	ca		dex				dex
.ae21	d0 f7		bne $ae1a			bne 	_CSClear
.ae23	9c 8f 06	stz $068f			stz 	GSCurrentSpriteAddr+1 		; no sprite selected.
.ae26	20 39 ae	jsr $ae39			jsr 	GXClearSpriteStore
.ae29	18		clc				clc
.ae2a	60		rts				rts
.ae2b					GXCalculateBaseAddress:
.ae2b	85 36		sta $36				sta 	gxzTemp0
.ae2d	64 37		stz $37				stz 	gxzTemp0+1
.ae2f	a9 05		lda #$05			lda 	#5
.ae31					_GXShift:
.ae31	06 36		asl $36				asl 	gxzTemp0
.ae33	26 37		rol $37				rol 	gxzTemp0+1
.ae35	3a		dec a				dec		a
.ae36	d0 f9		bne $ae31			bne 	_GXShift
.ae38	60		rts				rts
.ae39					GXClearSpriteStore:
.ae39	a2 3f		ldx #$3f			ldx 	#63 						; erase 64 sprite store elements
.ae3b					_GXCSSLoop:
.ae3b	9e d2 06	stz $06d2,x			stz 	GXSpriteHigh,x
.ae3e	a9 80		lda #$80			lda 	#$80 						; set the 'hidden' bit.
.ae40	9d 92 06	sta $0692,x			sta 	GXSpriteLow,x
.ae43	ca		dex				dex
.ae44	10 f5		bpl $ae3b			bpl 	_GXCSSLoop
.ae46	60		rts				rts
.ae47					GXLine:
.ae47	ad 83 06	lda $0683			lda 	GXBitmapsOn
.ae4a	f0 28		beq $ae74			beq 	_GXLFail
.ae4c	20 29 b3	jsr $b329			jsr 	GXOpenBitmap
.ae4f	20 6f b4	jsr $b46f			jsr 	GXSortY						; sort pairs so Y1 >= Y0 e.g. top to bottom.
.ae52	20 1a af	jsr $af1a			jsr 	GXLineSetup 				; the calculations in the linescanner constructor
.ae55	20 39 b3	jsr $b339			jsr 	GXPositionCalc 				; calculate position/offset.
.ae58					_GXDrawLoop:
.ae58	ac 8c 06	ldy $068c			ldy 	gsOffset 					; draw the pixel
.ae5b	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.ae5d	2d 8a 06	and $068a			and 	gxANDValue
.ae60	4d 89 06	eor $0689			eor 	gxEORValue
.ae63	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.ae65	20 76 ae	jsr $ae76			jsr 	GXLineIsComplete 			; is the line complete ?
.ae68	f0 05		beq $ae6f			beq 	_GXLExit
.ae6a	20 91 ae	jsr $ae91			jsr 	GXLineAdvance 				; code as per advance method
.ae6d	80 e9		bra $ae58			bra 	_GXDrawLoop
.ae6f					_GXLExit:
.ae6f	20 31 b3	jsr $b331			jsr 	GXCloseBitmap
.ae72	18		clc				clc
.ae73	60		rts				rts
.ae74					_GXLFail:
.ae74	38		sec				sec
.ae75	60		rts				rts
.ae76					GXLineIsComplete:
.ae76	ad 19 07	lda $0719			lda 	GXIsDiffYLarger 			; is dy larger
.ae79	d0 0f		bne $ae8a			bne 	_GXLICCompareY 				; if so compare Y1/Y0
.ae7b	ad 7a 06	lda $067a			lda 	GXX0 						; compare X, LSB and MSB
.ae7e	4d 7e 06	eor $067e			eor 	GXX1
.ae81	d0 06		bne $ae89			bne 	_GXLICExit
.ae83	ad 7b 06	lda $067b			lda 	GXX0+1
.ae86	4d 7f 06	eor $067f			eor 	GXX1+1
.ae89					_GXLICExit:
.ae89	60		rts				rts
.ae8a					_GXLICCompareY:
.ae8a	ad 80 06	lda $0680			lda 	GXY1
.ae8d	4d 7c 06	eor $067c			eor 	GXY0
.ae90	60		rts				rts
.ae91					GXLineAdvance:
.ae91	18		clc				clc 								; add adjust to position
.ae92	ad 1b 07	lda $071b			lda 	GXPosition
.ae95	6d 1c 07	adc $071c			adc 	GXAdjust
.ae98	8d 1b 07	sta $071b			sta 	GXPosition
.ae9b	9c 1e 07	stz $071e			stz 	GXAddSelect 				; clear add select flag
.ae9e	b0 05		bcs $aea5			bcs 	_GXLAOverflow 				; if carry out, overflowed.
.aea0	cd 1d 07	cmp $071d			cmp 	GXTotal 					; if exceeded total
.aea3	90 0a		bcc $aeaf			bcc 	_GXLANoExtra
.aea5					_GXLAOverflow:
.aea5	ce 1e 07	dec $071e			dec 	GXAddSelect 				; set addselect to $FF
.aea8	38		sec				sec 								; subtract total and write back
.aea9	ed 1d 07	sbc $071d			sbc 	GXTotal
.aeac	8d 1b 07	sta $071b			sta 	GXPosition
.aeaf					_GXLANoExtra:
.aeaf	ad 19 07	lda $0719			lda 	GXIsDiffYLarger
.aeb2	f0 0d		beq $aec1			beq 	_GXDXLarger
.aeb4	20 13 af	jsr $af13			jsr 	GXIncrementY
.aeb7	ad 1e 07	lda $071e			lda 	GXAddSelect
.aeba	f0 10		beq $aecc			beq 	_GXLAExit
.aebc	20 cd ae	jsr $aecd			jsr 	GXAdjustX
.aebf	80 0b		bra $aecc			bra 	_GXLAExit
.aec1					_GXDXLarger:
.aec1	20 cd ae	jsr $aecd			jsr 	GXAdjustX
.aec4	ad 1e 07	lda $071e			lda 	GXAddSelect
.aec7	f0 03		beq $aecc			beq 	_GXLAExit
.aec9	20 13 af	jsr $af13			jsr 	GXIncrementY
.aecc					_GXLAExit:
.aecc	60		rts				rts
.aecd					GXAdjustX:
.aecd	ad 1a 07	lda $071a			lda 	GXDXNegative
.aed0	10 25		bpl $aef7			bpl 	_GXAXRight
.aed2	ad 7a 06	lda $067a			lda 	GXX0
.aed5	d0 03		bne $aeda			bne 	_GXAXNoBorrow
.aed7	ce 7b 06	dec $067b			dec 	GXX0+1
.aeda					_GXAXNoBorrow:
.aeda	ce 7a 06	dec $067a			dec 	GXX0
.aedd	ce 8c 06	dec $068c			dec 	gsOffset 					; pixel left
.aee0	ad 8c 06	lda $068c			lda 	gsOffset
.aee3	c9 ff		cmp #$ff			cmp 	#$FF
.aee5	d0 0f		bne $aef6			bne 	_GXAYExit 					; underflow
.aee7	c6 3d		dec $3d				dec 	gxzScreen+1 					; borrow
.aee9	a5 3d		lda $3d				lda 	gxzScreen+1 					; gone off page
.aeeb	c9 60		cmp #$60			cmp 	#GXMappingAddress >> 8
.aeed	b0 07		bcs $aef6			bcs 	_GXAYExit
.aeef	18		clc				clc
.aef0	69 20		adc #$20			adc 	#$20 						; fix up
.aef2	85 3d		sta $3d				sta 	gxzScreen+1
.aef4	c6 0b		dec $0b				dec 	GXEditSlot 				; back one page
.aef6					_GXAYExit:
.aef6	60		rts				rts
.aef7					_GXAXRight:
.aef7	ee 7a 06	inc $067a			inc 	GXX0
.aefa	d0 03		bne $aeff			bne 	_GXAXNoCarry
.aefc	ee 7b 06	inc $067b			inc 	GXX0+1
.aeff					_GXAXNoCarry:
.aeff	ee 8c 06	inc $068c			inc 	gsOffset 					; pixel right
.af02	d0 0e		bne $af12			bne 	_GXAXExit 					; if not overflowed, exit.
.af04	e6 3d		inc $3d				inc 	gxzScreen+1 					; next line
.af06	a5 3d		lda $3d				lda 	gxzScreen+1
.af08	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.af0a	90 06		bcc $af12			bcc 	_GXAXExit
.af0c	e9 20		sbc #$20			sbc 	#$20 						; fix up
.af0e	85 3d		sta $3d				sta 	gxzScreen+1
.af10	e6 0b		inc $0b				inc 	GXEditSlot 				; next page
.af12					_GXAXExit:
.af12	60		rts				rts
.af13					GXIncrementY:
.af13	ee 7c 06	inc $067c			inc 	GXY0
.af16	20 8f b3	jsr $b38f			jsr 	GXMovePositionDown
.af19	60		rts				rts
.af1a					GXLineSetup:
.af1a	ad 80 06	lda $0680			lda 	GXY1
.af1d	38		sec				sec
.af1e	ed 7c 06	sbc $067c			sbc 	GXY0
.af21	4a		lsr a				lsr 	a
.af22	8d 18 07	sta $0718			sta 	GXDiffY
.af25	9c 1a 07	stz $071a			stz 	GXDXNegative 				; clear -ve flag
.af28	38		sec				sec
.af29	ad 7e 06	lda $067e			lda 	GXX1
.af2c	ed 7a 06	sbc $067a			sbc 	GXX0
.af2f	8d 17 07	sta $0717			sta 	GXDiffX
.af32	ad 7f 06	lda $067f			lda 	GXX1+1 						; calculate MSB
.af35	ed 7b 06	sbc $067b			sbc 	GXX0+1
.af38	6a		ror a				ror 	a 							; rotate bit into DiffX halving it
.af39	6e 17 07	ror $0717			ror 	GXDiffX
.af3c	0a		asl a				asl 	a
.af3d	10 0c		bpl $af4b			bpl 	_GDXNotNegative
.af3f	a9 00		lda #$00			lda 	#0 							; make absolute value of |dx|
.af41	38		sec				sec
.af42	ed 17 07	sbc $0717			sbc 	GXDiffX
.af45	8d 17 07	sta $0717			sta 	GXDiffX
.af48	ce 1a 07	dec $071a			dec 	GXDXNegative 				; -ve flag = $FF.
.af4b					_GDXNotNegative:
.af4b	9c 19 07	stz $0719			stz 	GXIsDiffYLarger 			; clear larger flag
.af4e	ad 18 07	lda $0718			lda 	GXDiffY 					; set adjust and total.
.af51	8d 1c 07	sta $071c			sta 	GXAdjust
.af54	ad 17 07	lda $0717			lda 	GXDiffX
.af57	8d 1d 07	sta $071d			sta 	GXTotal
.af5a	ad 18 07	lda $0718			lda 	GXDiffY 					; if dy > dx
.af5d	cd 17 07	cmp $0717			cmp 	GXDiffX
.af60	90 0f		bcc $af71			bcc 	_GDXNotLarger
.af62	ce 19 07	dec $0719			dec 	GXIsDiffYLarger 			; set the dy larger flag
.af65	ad 17 07	lda $0717			lda 	GXDiffX 					; set adjust and total other way round
.af68	8d 1c 07	sta $071c			sta 	GXAdjust
.af6b	ad 18 07	lda $0718			lda 	GXDiffY
.af6e	8d 1d 07	sta $071d			sta 	GXTotal
.af71					_GDXNotLarger:
.af71	ad 1d 07	lda $071d			lda 	GXTotal
.af74	4a		lsr a				lsr 	a
.af75	8d 1b 07	sta $071b			sta 	GXPosition
.af78	60		rts				rts
.0717					GXDiffX:
>0717							.fill 	1
.0718					GXDiffY:
>0718							.fill 	1
.0719					GXIsDiffYLarger:
>0719							.fill 	1
.071a					GXDXNegative:
>071a							.fill 	1
.071b					GXPosition:
>071b							.fill 	1
.071c					GXAdjust:
>071c							.fill 	1
.071d					GXTotal:
>071d							.fill 	1
.071e					GXAddSelect:
>071e							.fill 	1
.af79					GXSetColourMode:
.af79	a6 36		ldx $36				ldx 	gxzTemp0
.af7b	8e 88 06	stx $0688			stx 	gxColour 								; set colour
.af7e	a5 37		lda $37				lda 	gxzTemp0+1 								;
.af80	8d 87 06	sta $0687			sta 	gxMode 									; set mode
.af83	29 03		and #$03			and 	#3 										; only interested in bits 0-3
.af85	9c 8a 06	stz $068a			stz 	gxANDValue 								; initially AND with 0, and EOR with Colour
.af88	ae 88 06	ldx $0688			ldx 	gxColour
.af8b	8e 89 06	stx $0689			stx 	gxEORValue
.af8e	c9 02		cmp #$02			cmp 	#2 										; if mode 2/3 And with colour
.af90	90 03		bcc $af95			bcc 	_GXSDCNotAndColour
.af92	8e 8a 06	stx $068a			stx 	gxANDValue
.af95					_GXSDCNotAndColour:
.af95	d0 03		bne $af9a			bne 	_GXSDCNotAnd 							; mode 2, Don't EOR with colour
.af97	9c 89 06	stz $0689			stz 	gxEORValue
.af9a					_GXSDCNotAnd:
.af9a	4a		lsr a				lsr 	a 										; if bit 0 set, 1's complement AND value
.af9b	90 08		bcc $afa5			bcc 	_GXSDCNoFlip
.af9d	ad 8a 06	lda $068a			lda	 	gxANDValue
.afa0	49 ff		eor #$ff			eor 	#$FF
.afa2	8d 8a 06	sta $068a			sta 	gxANDValue
.afa5					_GXSDCNoFlip:
.afa5	18		clc				clc
.afa6	60		rts				rts
.afa7					GXPlotPoint:
.afa7	20 29 b3	jsr $b329			jsr 	GXOpenBitmap 				; start drawing
.afaa	20 39 b3	jsr $b339			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.afad	ac 8c 06	ldy $068c			ldy 	gsOffset
.afb0	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.afb2	2d 8a 06	and $068a			and 	gxANDValue
.afb5	4d 89 06	eor $0689			eor 	gxEORValue
.afb8	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.afba	20 31 b3	jsr $b331			jsr 	GXCloseBitmap 				; stop drawing and exit
.afbd	18		clc				clc
.afbe	60		rts				rts
.afbf					GXFillRectangle:
.afbf	38		sec				sec
.afc0	80 01		bra $afc3			bra 	GXRectangle
.afc2					GXFrameRectangle:
.afc2	18		clc				clc
.afc3					GXRectangle:
.afc3	ad 83 06	lda $0683			lda 	gxBitmapsOn
.afc6	f0 35		beq $affd			beq 	_GXRFail
.afc8	08		php				php 								; save Fill flag (CS)
.afc9	20 29 b3	jsr $b329			jsr 	GXOpenBitmap 				; start drawing
.afcc	20 51 b4	jsr $b451			jsr 	GXSortXY 					; sort both X and Y so top left/bottom right
.afcf	20 39 b3	jsr $b339			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.afd2	38		sec				sec 								; sec = Draw line
.afd3	20 ff af	jsr $afff			jsr 	GXDrawLineX1X0 				; draw a line length X1-X0
.afd6	ad 7c 06	lda $067c			lda 	gxY0 						; reached end of rectangle ?
.afd9	cd 80 06	cmp $0680			cmp 	gxY1
.afdc	f0 19		beq $aff7			beq 	_GXRectangleExit
.afde					_GXRectLoop:
.afde	20 8f b3	jsr $b38f			jsr 	GXMovePositionDown 			; down one.
.afe1	ee 7c 06	inc $067c			inc 	gxY0 						; change Y pos
.afe4	ad 7c 06	lda $067c			lda 	gxY0 						; reached last line
.afe7	cd 80 06	cmp $0680			cmp 	gXY1
.afea	f0 07		beq $aff3			beq 	_GXLastLine
.afec	28		plp				plp 								; get flag back
.afed	08		php				php
.afee	20 ff af	jsr $afff			jsr 	GXDrawLineX1X0 				; draw horizontal line
.aff1	80 eb		bra $afde			bra 	_GXRectLoop
.aff3					_GXLastLine:
.aff3	38		sec				sec
.aff4	20 ff af	jsr $afff			jsr 	GXDrawLineX1X0
.aff7					_GXRectangleExit:
.aff7	68		pla				pla 								; throw fill flag.
.aff8	20 31 b3	jsr $b331			jsr 	GXCloseBitmap 				; stop drawing and exit
.affb	18		clc				clc
.affc	60		rts				rts
.affd					_GXRFail:
.affd	38		sec				sec
.affe	60		rts				rts
.afff					GXDrawLineX1X0:
.afff	08		php				php 								; save solid/either-end
.b000	38		sec				sec
.b001	ad 7e 06	lda $067e			lda		gXX1
.b004	ed 7a 06	sbc $067a			sbc 	gXX0
.b007	85 36		sta $36				sta 	gxzTemp0
.b009	ad 7f 06	lda $067f			lda 	gXX1+1
.b00c	ed 7b 06	sbc $067b			sbc 	gXX0+1
.b00f	85 37		sta $37				sta 	gxzTemp0+1
.b011	28		plp				plp
.b012					GXDrawLineTemp0:
.b012	a5 3c		lda $3c				lda 	gxzScreen 						; push gxzScreen, gsOffset and GXEditSlot on stack
.b014	48		pha				pha
.b015	a5 3d		lda $3d				lda 	gxzScreen+1
.b017	48		pha				pha
.b018	ad 8c 06	lda $068c			lda 	gsOffset
.b01b	48		pha				pha
.b01c	a5 0b		lda $0b				lda 	GXEditSlot
.b01e	48		pha				pha
.b01f	ac 8c 06	ldy $068c			ldy 	gsOffset 					; Y offset
.b022	90 1e		bcc $b042			bcc 	_GXDLTEndPoints 			; if CC draw end points only.
.b024					_GXDLTLine:
.b024	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.b026	2d 8a 06	and $068a			and 	gxANDValue
.b029	4d 89 06	eor $0689			eor 	gxEORValue
.b02c	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b02e	a5 36		lda $36				lda 	gxzTemp0 					; decrement counter
.b030	d0 04		bne $b036			bne 	_GXDLTNoBorrow
.b032	c6 37		dec $37				dec 	gxzTemp0+1 					; borrow, if goes -ve then exit
.b034	30 2e		bmi $b064			bmi 	_GXDLTExit
.b036					_GXDLTNoBorrow:
.b036	c6 36		dec $36				dec 	gxzTemp0
.b038	c8		iny				iny 								; next slot.
.b039	d0 e9		bne $b024			bne 	_GXDLTLine
.b03b	e6 3d		inc $3d				inc 	gxzScreen+1 					; carry to next
.b03d	20 72 b0	jsr $b072			jsr 	GXDLTCheckWrap				; check for new page.
.b040	80 e2		bra $b024			bra 	_GXDLTLine
.b042					_GXDLTEndPoints:
.b042	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.b044	2d 8a 06	and $068a			and 	gxANDValue
.b047	4d 89 06	eor $0689			eor 	gxEORValue
.b04a	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b04c	98		tya				tya 								; advance to right side
.b04d	18		clc				clc
.b04e	65 36		adc $36				adc 	gxzTemp0
.b050	a8		tay				tay
.b051	a5 3d		lda $3d				lda 	gxzScreen+1
.b053	65 37		adc $37				adc 	gxzTemp0+1
.b055	85 3d		sta $3d				sta 	gxzScreen+1
.b057	20 72 b0	jsr $b072			jsr 	GXDLTCheckWrap 			; fix up.
.b05a	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.b05c	2d 8a 06	and $068a			and 	gxANDValue
.b05f	4d 89 06	eor $0689			eor 	gxEORValue
.b062	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b064					_GXDLTExit:
.b064	68		pla				pla
.b065	85 0b		sta $0b				sta 	GXEditSlot
.b067	68		pla				pla
.b068	8d 8c 06	sta $068c			sta 	gsOffset
.b06b	68		pla				pla
.b06c	85 3d		sta $3d				sta 	gxzScreen+1
.b06e	68		pla				pla
.b06f	85 3c		sta $3c				sta 	gxzScreen
.b071	60		rts				rts
.b072					GXDLTCheckWrap:
.b072	a5 3d		lda $3d				lda 	gxzScreen+1 					; check end of page
.b074	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8)
.b076	90 06		bcc $b07e			bcc 	_GXDLTCWExit
.b078	e9 20		sbc #$20			sbc 	#$20 						; fix up
.b07a	85 3d		sta $3d				sta 	gxzScreen+1
.b07c	e6 0b		inc $0b				inc 	GXEditSlot
.b07e					_GXDLTCWExit:
.b07e	60		rts				rts
.b07f					GXDrawGraphicElement:
.b07f	8d 1f 07	sta $071f			sta 	gxSize 						; save size
.b082	3a		dec a				dec 	a
.b083	8d 20 07	sta $0720			sta 	gxMask 						; and mask
.b086	ad 83 06	lda $0683			lda 	gxBitmapsOn 				; check BMP on
.b089	f0 67		beq $b0f2			beq 	_GXSLFail
.b08b	ad 7c 06	lda $067c			lda 	gxY0 						; push Y on stack
.b08e	48		pha				pha
.b08f	8c 22 07	sty $0722			sty 	gxAcquireVector+1 			; and acquisition vector
.b092	8e 21 07	stx $0721			stx 	gxAcquireVector
.b095	20 29 b3	jsr $b329			jsr 	gxOpenBitmap 				; open the bitmap.
.b098	ad 24 07	lda $0724			lda 	gxUseMode 					; scale bits
.b09b	4a		lsr a				lsr 	a
.b09c	4a		lsr a				lsr 	a
.b09d	4a		lsr a				lsr 	a
.b09e	29 07		and #$07			and		#7
.b0a0	1a		inc a				inc 	a
.b0a1	8d 23 07	sta $0723			sta 	gxScale
.b0a4	64 38		stz $38				stz 	gxzTemp1					; start first line
.b0a6					_GXGELoop:
.b0a6	a5 38		lda $38				lda 	gxzTemp1 					; current line number to read.
.b0a8	2c 24 07	bit $0724			bit 	gxUseMode 					; check for flip.
.b0ab	10 06		bpl $b0b3			bpl		_GXNoVFlip
.b0ad	ad 20 07	lda $0720			lda 	gxMask
.b0b0	38		sec				sec
.b0b1	e5 38		sbc $38				sbc 	gxzTemp1
.b0b3					_GXNoVFlip:
.b0b3	aa		tax				tax 								; get the Xth line.
.b0b4	20 f4 b0	jsr $b0f4			jsr 	_GXCallAcquire 				; get that data.
.b0b7	ad 23 07	lda $0723			lda 	gxScale 					; do scale identical copies of that line.
.b0ba	85 39		sta $39				sta 	gxzTemp1+1
.b0bc					_GXGELoop2:
.b0bc	ad 7c 06	lda $067c			lda 	gxY0 						; off screen
.b0bf	cd 86 06	cmp $0686			cmp 	gxHeight
.b0c2	b0 10		bcs $b0d4			bcs 	_GXDGEExit
.b0c4	20 f7 b0	jsr $b0f7			jsr 	GXRenderOneLine 			; render line
.b0c7	c6 39		dec $39				dec 	gxzTemp1+1 					; scale times.
.b0c9	d0 f1		bne $b0bc			bne 	_GXGELoop2
.b0cb	e6 38		inc $38				inc 	gxzTemp1 					; done all lines.
.b0cd	a5 38		lda $38				lda 	gxzTemp1
.b0cf	cd 1f 07	cmp $071f			cmp 	gxSize
.b0d2	d0 d2		bne $b0a6			bne 	_GXGELoop
.b0d4					_GXDGEExit:
.b0d4	68		pla				pla 								; restore Y for next time
.b0d5	8d 7c 06	sta $067c			sta 	gxY0
.b0d8	ae 23 07	ldx $0723			ldx 	gxScale 					; get scale (1-8)
.b0db					_GXShiftLeft:
.b0db	18		clc				clc
.b0dc	ad 1f 07	lda $071f			lda 	gxSize
.b0df	6d 7a 06	adc $067a			adc 	gxX0
.b0e2	8d 7a 06	sta $067a			sta 	gxX0
.b0e5	90 03		bcc $b0ea			bcc 	_GXSLNoCarry
.b0e7	ee 7b 06	inc $067b			inc 	gxX0+1
.b0ea					_GXSLNoCarry:
.b0ea	ca		dex				dex
.b0eb	d0 ee		bne $b0db			bne 	_GXShiftLeft
.b0ed	20 31 b3	jsr $b331			jsr 	GXCloseBitmap
.b0f0	18		clc				clc
.b0f1	60		rts				rts
.b0f2					_GXSLFail:
.b0f2	38		sec				sec
.b0f3	60		rts				rts
.b0f4					_GXCallAcquire:
.b0f4	6c 21 07	jmp ($0721)			jmp 	(gxAcquireVector)
.b0f7					GXRenderOneLine:
.b0f7	20 39 b3	jsr $b339			jsr 	GXPositionCalc 				; calculate position/offset.
.b0fa	ac 8c 06	ldy $068c			ldy 	gsOffset 					; Y contains position.
.b0fd	64 3a		stz $3a				stz 	gxzTemp2 					; do size pixels
.b0ff					_GXROLLoop1:
.b0ff	ad 23 07	lda $0723			lda 	gxScale 					; set to do 'scale' times
.b102	85 3b		sta $3b				sta 	gxzTemp2+1
.b104					_GXROLLoop2:
.b104	a5 3a		lda $3a				lda 	gxzTemp2 					; get current pixel
.b106	2c 87 06	bit $0687			bit 	gxMode 						; check H Flip
.b109	50 06		bvc $b111			bvc 	_GXNoHFlip
.b10b	ad 20 07	lda $0720			lda 	gxMask
.b10e	38		sec				sec
.b10f	e5 3a		sbc $3a				sbc 	gxzTemp2
.b111					_GXNoHFlip:
.b111	aa		tax				tax 								; read from the pixel buffer
.b112	bd 27 06	lda $0627,x			lda 	gxPixelBuffer,x
.b115	d0 07		bne $b11e			bne 	_GXDraw 					; draw if non zero
.b117	ad 24 07	lda $0724			lda 	gxUseMode 					; check to see if solid background
.b11a	29 04		and #$04			and 	#4
.b11c	f0 0a		beq $b128			beq 	_GXZeroPixel
.b11e					_GXDraw:
.b11e	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.b120	2d 8a 06	and $068a			and 	gxANDValue
.b123	5d 27 06	eor $0627,x			eor 	gxPixelBuffer,x
.b126	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b128					_GXZeroPixel:
.b128	c8		iny				iny 								; advance pointer
.b129	d0 05		bne $b130			bne 	_GXNoShift
.b12b	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.b12d	20 72 b0	jsr $b072			jsr 	GXDLTCheckWrap				; check for new page.
.b130					_GXNoShift:
.b130	c6 3b		dec $3b				dec 	gxzTemp2+1 					; do the inner loop gxScale times.
.b132	d0 d0		bne $b104			bne 	_GXROLLoop2
.b134	e6 3a		inc $3a				inc 	gxzTemp2 					; next pixel.
.b136	a5 3a		lda $3a				lda 	gxzTemp2
.b138	cd 1f 07	cmp $071f			cmp 	gxSize
.b13b	d0 c2		bne $b0ff			bne 	_GXROLLoop1
.b13d	ee 7c 06	inc $067c			inc 	gxY0
.b140	60		rts				rts
.071f					gxSize:
>071f							.fill 	1
.0720					gxMask:
>0720							.fill 	1
.0721					gxAcquireVector:
>0721							.fill 	2
.0723					gxScale:
>0723							.fill 	1
.0724					gxUseMode:
>0724							.fill 	1
.b141					GXFontHandler:
.b141	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b143	4d 87 06	eor $0687			eor 	gxMode
.b146	8d 24 07	sta $0724			sta 	gxUseMode
.b149	64 37		stz $37				stz 	gxzTemp0+1 					; gxzTemp0 is font #
.b14b	06 36		asl $36				asl	 	gxzTemp0 					; x 2
.b14d	26 37		rol $37				rol	 	gxzTemp0+1
.b14f	06 36		asl $36				asl	 	gxzTemp0 					; x 4
.b151	26 37		rol $37				rol	 	gxzTemp0+1
.b153	06 36		asl $36				asl	 	gxzTemp0 					; x 8
.b155	26 37		rol $37				rol	 	gxzTemp0+1
.b157	a5 37		lda $37				lda 	gxzTemp0+1 					; put in page C0
.b159	09 c0		ora #$c0			ora 	#$C0
.b15b	85 37		sta $37				sta 	gxzTemp0+1
.b15d	a9 08		lda #$08			lda 	#8 							; size 8x8
.b15f	a2 67		ldx #$67			ldx 	#GXGetGraphicDataFont & $FF ; XY = Graphic Data retrieval routine
.b161	a0 b1		ldy #$b1			ldy 	#GXGetGraphicDataFont >> 8
.b163	20 7f b0	jsr $b07f			jsr 	GXDrawGraphicElement
.b166	60		rts				rts
.b167					GXGetGraphicDataFont:
.b167	8a		txa				txa 								; X->Y
.b168	a8		tay				tay
.b169	a6 01		ldx $01				ldx 	1 							; preserve old value
.b16b	a9 01		lda #$01			lda 	#1 							; access page 1 (font memory)
.b16d	85 01		sta $01				sta 	1
.b16f	b1 36		lda ($36),y			lda 	(gxzTemp0),y 				; read the font element.
.b171	86 01		stx $01				stx 	1 							; put old value back.
.b173	a2 00		ldx #$00			ldx 	#0 							; do 8 times
.b175					_GXExpand:
.b175	9e 27 06	stz $0627,x			stz 	gxPixelBuffer,x 			; zero in pixel buffer
.b178	0a		asl a				asl 	a 							; shift bit 7 into C
.b179	90 08		bcc $b183			bcc 	_GXNoPixel
.b17b	48		pha				pha 								; if set, set pixel buffer to current colour.
.b17c	ad 88 06	lda $0688			lda 	gxColour
.b17f	9d 27 06	sta $0627,x			sta 	gxPixelBuffer,x
.b182	68		pla				pla
.b183					_GXNoPixel:
.b183	e8		inx				inx 								; do the whole byte.
.b184	e0 08		cpx #$08			cpx 	#8
.b186	d0 ed		bne $b175			bne 	_GXExpand
.b188	60		rts				rts
.b189					GXSpriteHandler:
.b189	ad 82 06	lda $0682			lda 	gxSpritesOn 				; sprites on ?
.b18c	f0 23		beq $b1b1			beq 	_GXSHExit
.b18e	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b190	4d 87 06	eor $0687			eor 	gxMode
.b193	8d 24 07	sta $0724			sta 	gxUseMode
.b196	a6 36		ldx $36				ldx 	gxzTemp0 					; sprite #
.b198	da		phx				phx
.b199	20 29 b3	jsr $b329			jsr 	GXOpenBitmap 				; can access sprite information
.b19c	68		pla				pla
.b19d	20 0a b4	jsr $b40a			jsr 	GXFindSprite 				; get the sprite address
.b1a0	08		php				php
.b1a1	20 31 b3	jsr $b331			jsr 	GXCloseBitmap
.b1a4	28		plp				plp
.b1a5	b0 0a		bcs $b1b1			bcs		_GXSHExit 					; exit if find failed.
.b1a7	ad 25 07	lda $0725			lda 	GXSizePixels 				; return size
.b1aa	a2 b2		ldx #$b2			ldx 	#GXSpriteAcquire & $FF
.b1ac	a0 b1		ldy #$b1			ldy 	#GXSpriteAcquire >> 8
.b1ae	20 7f b0	jsr $b07f			jsr 	GXDrawGraphicElement
.b1b1					_GXSHExit:
.b1b1	60		rts				rts
.b1b2					GXSpriteAcquire:
.b1b2	ad 85 06	lda $0685			lda 	GXSpritePage				; point to base page
.b1b5	85 0b		sta $0b				sta 	GXEditSlot
.b1b7	86 36		stx $36				stx 	zTemp0 						; row number x 1,2,3,4
.b1b9	a9 00		lda #$00			lda 	#0
.b1bb	ae 26 07	ldx $0726			ldx 	GXSizeBits
.b1be					_GXTimesRowNumber:
.b1be	18		clc				clc
.b1bf	65 36		adc $36				adc 	zTemp0
.b1c1	ca		dex				dex
.b1c2	10 fa		bpl $b1be			bpl 	_GXTimesRowNumber
.b1c4	64 37		stz $37				stz 	gxzTemp0+1
.b1c6	0a		asl a				asl 	a 							; row x 2,4,6,8
.b1c7	26 37		rol $37				rol 	gxzTemp0+1
.b1c9	0a		asl a				asl 	a 							; row x 4,8,12,16
.b1ca	26 37		rol $37				rol 	gxzTemp0+1
.b1cc	0a		asl a				asl 	a 							; row x 8,16,24,32
.b1cd	26 37		rol $37				rol 	gxzTemp0+1
.b1cf	85 36		sta $36				sta 	gxzTemp0
.b1d1	18		clc				clc 								; add base address.
.b1d2	a5 36		lda $36				lda 	gxzTemp0
.b1d4	6d 28 07	adc $0728			adc 	GXSpriteOffset
.b1d7	85 36		sta $36				sta 	gxzTemp0
.b1d9	a5 37		lda $37				lda 	gxzTemp0+1
.b1db	6d 29 07	adc $0729			adc 	GXSpriteOffset+1
.b1de					_GXSAFindPage:
.b1de	c9 20		cmp #$20			cmp 	#$20 						; on this page
.b1e0	90 06		bcc $b1e8			bcc 	_GXSAFoundPage
.b1e2	e9 20		sbc #$20			sbc 	#$20 						; forward one page
.b1e4	e6 0b		inc $0b				inc 	GXEditSlot
.b1e6	80 f6		bra $b1de			bra 	_GXSAFindPage
.b1e8					_GXSAFoundPage:
.b1e8	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; physical address of page.
.b1ea	85 37		sta $37				sta 	gxzTemp0+1 					; gxzTemp0 now points to the page
.b1ec	a0 00		ldy #$00			ldy 	#0
.b1ee					_GXSACopyLoop:
.b1ee	b1 36		lda ($36),y			lda 	(gxzTemp0),y
.b1f0	99 27 06	sta $0627,y			sta 	gxPixelBuffer,y
.b1f3	c8		iny				iny
.b1f4	cc 25 07	cpy $0725			cpy 	GXSizePixels
.b1f7	d0 f5		bne $b1ee			bne 	_GXSACopyLoop
.b1f9	60		rts				rts
.b1fa					GXSelect:
.b1fa	ad 82 06	lda $0682			lda 	gxSpritesOn
.b1fd	f0 22		beq $b221			beq 	_GXSFail
.b1ff	a5 36		lda $36				lda 	gxzTemp0 					; illegal sprite #
.b201	c9 40		cmp #$40			cmp 	#64
.b203	b0 1c		bcs $b221			bcs 	_GXSFail
.b205	8d 8d 06	sta $068d			sta 	GSCurrentSpriteID
.b208	a4 37		ldy $37				ldy 	gxzTemp0+1 					; control value.
.b20a	a9 00		lda #$00			lda  	#0 							; multiply sprite # x 8 => A
.b20c	06 36		asl $36				asl 	gxzTemp0
.b20e	06 36		asl $36				asl 	gxzTemp0
.b210	06 36		asl $36				asl 	gxzTemp0
.b212	2a		rol a				rol 	a
.b213	69 d9		adc #$d9			adc 	#$D9 						; sprite area
.b215	8d 8f 06	sta $068f			sta 	GSCurrentSpriteAddr+1 		; address to GSCurrentSprite and gxzTemp
.b218	85 37		sta $37				sta 	gxzTemp0+1
.b21a	a5 36		lda $36				lda 	gxzTemp0
.b21c	8d 8e 06	sta $068e			sta 	GSCurrentSpriteAddr
.b21f	18		clc				clc
.b220	60		rts				rts
.b221					_GXSFail:
.b221	38		sec				sec
.b222	60		rts				rts
.b223					GXSelectImage:
.b223	ad 82 06	lda $0682			lda 	gxSpritesOn
.b226	f0 74		beq $b29c			beq 	_GXSIFail
.b228	ad 8f 06	lda $068f			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b22b	f0 6f		beq $b29c			beq 	_GXSIFail 					; (checking the MSB)
.b22d	64 01		stz $01				stz 	1
.b22f	a5 37		lda $37				lda 	gxzTemp0+1 					; push show/hide on the stack.
.b231	d0 6b		bne $b29e			bne 	_GXSIHide
.b233	a5 36		lda $36				lda 	gxzTemp0 					; sprite image
.b235	48		pha				pha
.b236	20 29 b3	jsr $b329			jsr 	GXOpenBitmap
.b239	68		pla				pla
.b23a	20 0a b4	jsr $b40a			jsr 	GXFindSprite
.b23d	b0 5a		bcs $b299			bcs 	_GXSICloseFail 				; no image
.b23f	a0 01		ldy #$01			ldy 	#1
.b241	ad 8e 06	lda $068e			lda 	GSCurrentSpriteAddr
.b244	85 36		sta $36				sta 	gxzTemp0
.b246	ad 8f 06	lda $068f			lda 	GSCurrentSpriteAddr+1
.b249	85 37		sta $37				sta 	gxzTemp0+1
.b24b	ad 28 07	lda $0728			lda 	GXSpriteOffset
.b24e	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b250	18		clc				clc
.b251	ad 29 07	lda $0729			lda 	GXSpriteOffset+1
.b254	6d 90 06	adc $0690			adc 	GXSpriteOffsetBase
.b257	c8		iny				iny
.b258	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b25a	ad 91 06	lda $0691			lda 	GXSpriteOffsetBase+1
.b25d	69 00		adc #$00			adc 	#0
.b25f	c8		iny				iny
.b260	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b262	ad 26 07	lda $0726			lda 	GXSizeBits 					; get raw size
.b265	49 03		eor #$03			eor 	#3 							; make it right (00=32 etc.)
.b267	2a		rol a				rol 	a 							; x 2
.b268	0a		asl a				asl 	a 							; x 4
.b269	0a		asl a				asl 	a 							; x 8
.b26a	0a		asl a				asl 	a 							; x 16
.b26b	0d 27 07	ora $0727			ora 	GXSpriteLUT 				; Or with LUT
.b26e	0a		asl a				asl 	a 							; 1 shift
.b26f	09 01		ora #$01			ora 	#1 							; enable sprite.
.b271	92 36		sta ($36)			sta 	(gxzTemp0) 					; and write back
.b273	20 31 b3	jsr $b331			jsr 	GXCloseBitmap
.b276	ae 8d 06	ldx $068d			ldx 	GSCurrentSpriteID 			; point to sprite entries.
.b279	bd d2 06	lda $06d2,x			lda 	GXSpriteHigh,x 				; clear upper two bits of size
.b27c	29 3f		and #$3f			and 	#$3F
.b27e	9d d2 06	sta $06d2,x			sta 	GXSpriteHigh,x
.b281	ad 26 07	lda $0726			lda 	GXSizeBits 					; get bit size
.b284	6a		ror a				ror 	a 							; shift into bits 6/7
.b285	6a		ror a				ror 	a
.b286	6a		ror a				ror 	a
.b287	29 c0		and #$c0			and 	#$C0
.b289	1d d2 06	ora $06d2,x			ora 	GXSpriteHigh,x 				; put in  upper 2 bits of sprite data
.b28c	9d d2 06	sta $06d2,x			sta 	GXSpriteHigh,x
.b28f	bd 92 06	lda $0692,x			lda 	GXSpriteLow,x 				; clear hidden flag.
.b292	29 7f		and #$7f			and 	#$7F
.b294	9d 92 06	sta $0692,x			sta 	GXSpriteLow,x
.b297	18		clc				clc
.b298	60		rts				rts
.b299					_GXSICloseFail:
.b299	20 31 b3	jsr $b331			jsr 	GXCloseBitmap
.b29c					_GXSIFail:
.b29c	38		sec				sec
.b29d	60		rts				rts
.b29e					_GXSIHide:
.b29e	ad 8e 06	lda $068e			lda 	GSCurrentSpriteAddr  		; get Sprite h/w address and write there
.b2a1	85 36		sta $36				sta 	gxzTemp0
.b2a3	ad 8f 06	lda $068f			lda 	GSCurrentSpriteAddr+1
.b2a6	85 37		sta $37				sta 	gxzTemp0+1
.b2a8	a9 00		lda #$00			lda 	#0
.b2aa	92 36		sta ($36)			sta 	(gxzTemp0)
.b2ac	ae 8d 06	ldx $068d			ldx 	GSCurrentSpriteID 			; get sprite ID
.b2af	bd 92 06	lda $0692,x			lda 	GXSpriteLow,x 				; set the hidden bit.
.b2b2	09 80		ora #$80			ora 	#$80
.b2b4	9d 92 06	sta $0692,x			sta 	GXSpriteLow,x
.b2b7	18		clc				clc
.b2b8	60		rts				rts
.b2b9					GXMoveSprite:
.b2b9	ad 82 06	lda $0682			lda 	gxSpritesOn
.b2bc	f0 65		beq $b323			beq 	_GXSIFail
.b2be	ad 8f 06	lda $068f			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b2c1	f0 60		beq $b323			beq 	_GXSIFail
.b2c3	85 37		sta $37				sta 	gxzTemp0+1
.b2c5	a0 04		ldy #$04			ldy 	#4
.b2c7	ad 8e 06	lda $068e			lda 	GSCurrentSpriteAddr
.b2ca	85 36		sta $36				sta 	gxzTemp0
.b2cc	ae 8d 06	ldx $068d			ldx 	GSCurrentSpriteID 			; get the size from the upper two bits
.b2cf	bd d2 06	lda $06d2,x			lda 	GXSpriteHigh,x
.b2d2	2a		rol a				rol 	a	 						; into bits 0,1.
.b2d3	2a		rol a				rol 	a
.b2d4	2a		rol a				rol 	a
.b2d5	29 03		and #$03			and 	#3
.b2d7	aa		tax				tax
.b2d8	bd 25 b3	lda $b325,x			lda 	_GXMSOffset,x 				; get 32-SpriteSize/2
.b2db	48		pha				pha
.b2dc	18		clc				clc
.b2dd	6d 7a 06	adc $067a			adc 	gxX0						; copy position.
.b2e0	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2e2	c8		iny				iny
.b2e3	ad 7b 06	lda $067b			lda 	gxX0+1
.b2e6	69 00		adc #$00			adc 	#0
.b2e8	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2ea	c8		iny				iny
.b2eb	68		pla				pla
.b2ec	18		clc				clc
.b2ed	6d 7c 06	adc $067c			adc 	gxY0
.b2f0	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2f2	a9 00		lda #$00			lda 	#0
.b2f4	69 00		adc #$00			adc 	#0
.b2f6	c8		iny				iny
.b2f7	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2f9	4e 7b 06	lsr $067b			lsr 	gxX0+1 						; divide X by 4
.b2fc	6e 7a 06	ror $067a			ror 	gxX0
.b2ff	4e 7a 06	lsr $067a			lsr 	gxX0
.b302	4e 7c 06	lsr $067c			lsr 	gxY0 						; divide Y by 4
.b305	4e 7c 06	lsr $067c			lsr 	gxY0
.b308	ae 8d 06	ldx $068d			ldx 	GSCurrentSpriteID 			; copy X/4 and Y/4 into the status bytes
.b30b	bd 92 06	lda $0692,x			lda 	GXSpriteLow,x
.b30e	29 80		and #$80			and 	#$80
.b310	0d 7a 06	ora $067a			ora 	gxX0
.b313	9d 92 06	sta $0692,x			sta 	GXSpriteLow,x
.b316	bd d2 06	lda $06d2,x			lda 	GXSpriteHigh,x
.b319	29 c0		and #$c0			and 	#$C0
.b31b	0d 7c 06	ora $067c			ora 	gxY0
.b31e	9d d2 06	sta $06d2,x			sta 	GXSpriteHigh,x
.b321	18		clc				clc
.b322	60		rts				rts
.b323					_GXSIFail:
.b323	38		sec				sec
.b324	60		rts				rts
.b325					_GXMSOffset:
>b325	1c						.byte 	32-8/2
>b326	18						.byte 	32-16/2
>b327	14						.byte 	32-24/2
>b328	10						.byte 	32-32/2
.b329					GXOpenBitmap:
.b329	78		sei				sei 								; no interrupts here
.b32a	a5 0b		lda $0b				lda 	GXEditSlot 					; Save the original LUT slot value
.b32c	8d 8b 06	sta $068b			sta 	gxOriginalLUTValue
.b32f	58		cli				cli
.b330	60		rts				rts
.b331					GXCloseBitmap:
.b331	78		sei				sei
.b332	ad 8b 06	lda $068b			lda 	gxOriginalLUTValue 			; restore LUT slot value
.b335	85 0b		sta $0b				sta 	GXEditSlot
.b337	58		cli				cli
.b338	60		rts				rts
.b339					GXPositionCalc:
.b339	a5 36		lda $36				lda 	gxzTemp0 					; save temp memory slot
.b33b	48		pha				pha
.b33c	ad 7c 06	lda $067c			lda 	GXY0 						; gxzScreen = Y0
.b33f	85 3c		sta $3c				sta 	gxzScreen
.b341	64 3d		stz $3d				stz 	gxzScreen+1
.b343	06 3c		asl $3c				asl 	gxzScreen 						; gxzScreen = Y0 * 4
.b345	26 3d		rol $3d				rol 	gxzScreen+1
.b347	06 3c		asl $3c				asl 	gxzScreen
.b349	26 3d		rol $3d				rol 	gxzScreen+1
.b34b	18		clc				clc 								; gxzScreen = Y0 * 5, as it's still in A
.b34c	65 3c		adc $3c				adc 	gxzScreen
.b34e	85 3c		sta $3c				sta 	gxzScreen
.b350	90 02		bcc $b354			bcc 	_GXPCNoCarry
.b352	e6 3d		inc $3d				inc 	gxzScreen+1
.b354					_GXPCNoCarry:
.b354	06 3c		asl $3c				asl 	gxzScreen 						; now Y0 * 10. Needs to be multiplied by another
.b356	26 3d		rol $3d				rol 	gxzScreen+1 					; 32. At this point the MSB contains the offset
.b358	a5 3d		lda $3d				lda	 	gxzScreen+1 					; so save this in zTemp0 and zero it.
.b35a	85 36		sta $36				sta 	gxzTemp0
.b35c	64 3d		stz $3d				stz 	gxzScreen+1
.b35e	a9 05		lda #$05			lda 	#5 							; now multiply by 32, this puts this in the range 0..8191
.b360					_GXPCMultiply32:
.b360	06 3c		asl $3c				asl 	gxzScreen
.b362	26 3d		rol $3d				rol 	gxzScreen+1
.b364	3a		dec a				dec 	a
.b365	d0 f9		bne $b360			bne 	_GXPCMultiply32
.b367	18		clc				clc
.b368	ad 7a 06	lda $067a			lda 	GXX0 						; add X to this value, put the result in gsOffset, gxzScreen has to be on a page boundary
.b36b	65 3c		adc $3c				adc 	gxzScreen
.b36d	8d 8c 06	sta $068c			sta 	gsOffset
.b370	ad 7b 06	lda $067b			lda 	GXX0+1
.b373	65 3d		adc $3d				adc 	gxzScreen+1
.b375	c9 20		cmp #$20			cmp 	#$20 						; has it overflowed into the next one ?
.b377	90 04		bcc $b37d			bcc 	_GXPCNoOverflow
.b379	29 1f		and #$1f			and 	#$1F 						; fix it up
.b37b	e6 36		inc $36				inc 	gxzTemp0 					; add 1 to the page number
.b37d					_GXPCNoOverflow:
.b37d	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; make it the address mapped in.
.b37f	85 3d		sta $3d				sta 	gxzScreen+1
.b381	64 3c		stz $3c				stz 	gxzScreen
.b383	18		clc				clc
.b384	a5 36		lda $36				lda 	gxzTemp0 					; get the page number
.b386	6d 84 06	adc $0684			adc 	gxBasePage 					; by adding the base page
.b389	85 0b		sta $0b				sta 	GXEditSlot 				; and map it into memory.
.b38b	68		pla				pla
.b38c	85 36		sta $36				sta 	gxzTemp0
.b38e	60		rts				rts
.b38f					GXMovePositionDown:
.b38f	18		clc				clc 								; add 320 to offset/temp+1
.b390	ad 8c 06	lda $068c			lda 	gsOffset
.b393	69 40		adc #$40			adc 	#64
.b395	8d 8c 06	sta $068c			sta 	gsOffset
.b398	a5 3d		lda $3d				lda 	gxzScreen+1
.b39a	69 01		adc #$01			adc 	#1
.b39c	85 3d		sta $3d				sta 	gxzScreen+1
.b39e	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page
.b3a0	90 07		bcc $b3a9			bcc 	_GXMPDExit
.b3a2	38		sec				sec  								; next page
.b3a3	e9 20		sbc #$20			sbc 	#$20
.b3a5	85 3d		sta $3d				sta 	gxzScreen+1
.b3a7	e6 0b		inc $0b				inc 	GXEditSlot
.b3a9					_GXMPDExit:
.b3a9	60		rts				rts
.b3aa					GXCollide:
.b3aa	a5 36		lda $36				lda 	gxzTemp0 					; check if sprite numbers are legal.
.b3ac	aa		tax				tax
.b3ad	05 37		ora $37				ora 	gxzTemp0+1
.b3af	29 c0		and #$c0			and 	#$C0
.b3b1	38		sec				sec
.b3b2	d0 53		bne $b407			bne 	_GXCollideFail 				; if either >= 64, fail.
.b3b4	a4 37		ldy $37				ldy 	gxzTemp0+1 					; at this point X is 1st sprite and Y is 2nd sprite.
.b3b6	b9 92 06	lda $0692,y			lda 	GXSpriteLow,y 				; check if either hidden bit is set
.b3b9	1d 92 06	ora $0692,x			ora 	GXSpriteLow,x
.b3bc	30 48		bmi $b406			bmi 	_GXOkayFail 				; if either hidden, then they cannot collide.
.b3be	18		clc				clc 								; need to calculate sum of sizes.
.b3bf	b9 d2 06	lda $06d2,y			lda 	GXSpriteHigh,y
.b3c2	7d d2 06	adc $06d2,x			adc 	GXSpriteHigh,x 				; at this point, CS, Bit 6 and 7 contain that sum.
.b3c5	29 c0		and #$c0			and 	#$C0 					 	; mask off
.b3c7	6a		ror a				ror 	a 							; 5/6/7
.b3c8	4a		lsr a				lsr 	a 							; 4/5/6
.b3c9	4a		lsr a				lsr 	a 							; 3/4/5
.b3ca	4a		lsr a				lsr 	a 							; 2/3/4
.b3cb	18		clc				clc
.b3cc	69 08		adc #$08			adc 	#$08
.b3ce	4a		lsr a				lsr 	a 							; adjust because all coordinates are divided by 4 to store.
.b3cf	4a		lsr a				lsr 	a
.b3d0	85 38		sta $38				sta 	gxzTemp1 					; so the difference between the centres has to be less than this.
.b3d2	b9 d2 06	lda $06d2,y			lda 	GXSpriteHigh,y 				; calculate y1-y0
.b3d5	29 3f		and #$3f			and 	#$3F
.b3d7	85 39		sta $39				sta 	gxzTemp1+1
.b3d9	38		sec				sec
.b3da	bd d2 06	lda $06d2,x			lda 	GXSpriteHigh,x
.b3dd	29 3f		and #$3f			and 	#$3F
.b3df	e5 39		sbc $39				sbc 	gxzTemp1+1
.b3e1	b0 03		bcs $b3e6			bcs 	_GXCAbs1 					; calculate |y1-y0|
.b3e3	49 ff		eor #$ff			eor 	#$FF
.b3e5	1a		inc a				inc 	a
.b3e6					_GXCAbs1:
.b3e6	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b3e8	b0 1c		bcs $b406			bcs 	_GXOkayFail
.b3ea	85 39		sta $39				sta 	gxzTemp1+1 					; save |y1-y0|
.b3ec	38		sec				sec 								; calculate |x1-x0|
.b3ed	b9 92 06	lda $0692,y			lda 	GXSpriteLow,y
.b3f0	fd 92 06	sbc $0692,x			sbc 	GXSpriteLow,x
.b3f3	b0 03		bcs $b3f8			bcs 	_GXCAbs2
.b3f5	49 ff		eor #$ff			eor 	#$FF
.b3f7	1a		inc a				inc 	a
.b3f8					_GXCAbs2:
.b3f8	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b3fa	b0 0a		bcs $b406			bcs 	_GXOkayFail
.b3fc	c5 39		cmp $39				cmp 	gxzTemp1+1 					; is it less than the previous one.
.b3fe	90 02		bcc $b402			bcc 	_GXCHaveLowest
.b400	a5 39		lda $39				lda 	gxzTemp1+1 					; if not, that's the smallest difference.
.b402					_GXCHaveLowest:
.b402	0a		asl a				asl 	a 							; scale to allow for >> 2
.b403	0a		asl a				asl 	a
.b404	18		clc				clc
.b405	60		rts				rts
.b406					_GXOkayFail:
.b406	18		clc				clc
.b407					_GXCollideFail:
.b407	a9 ff		lda #$ff			lda 	#$FF
.b409	60		rts				rts
.b40a					GXFindSprite:
.b40a	aa		tax				tax
.b40b	ad 85 06	lda $0685			lda 	GXSpritePage 				; access the base page of the sprite
.b40e	85 0b		sta $0b				sta 	GXEditSlot
.b410	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; check a valid sprite
.b413	1d 00 60	ora $6000,x			ora 	GXMappingAddress,x
.b416	f0 33		beq $b44b			beq 	_GXFSFail
.b418	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; MSB
.b41b	8d 29 07	sta $0729			sta 	GXSpriteOffset+1
.b41e	bd 00 60	lda $6000,x			lda 	GXMappingAddress,x 			; LSB
.b421	48		pha				pha 								; save twice
.b422	48		pha				pha
.b423	29 03		and #$03			and 	#3 							; get sprite size
.b425	8d 26 07	sta $0726			sta 	GXSizeBits 					; save raw (0-3)
.b428	aa		tax				tax
.b429	bd 4d b4	lda $b44d,x			lda 	_GXFXSSTTable,x 			; read sprite size
.b42c	8d 25 07	sta $0725			sta 	GXSizePixels 					; save (8/16/24/32)
.b42f	68		pla				pla 								; get LUT
.b430	4a		lsr a				lsr		a
.b431	4a		lsr a				lsr		a
.b432	29 03		and #$03			and 	#3
.b434	8d 27 07	sta $0727			sta 	GXSpriteLUT
.b437	68		pla				pla 								; address, neeeds to be x 4
.b438	29 f0		and #$f0			and 	#$F0
.b43a	8d 28 07	sta $0728			sta 	GXSpriteOffset
.b43d	0e 28 07	asl $0728			asl 	GXSpriteOffset
.b440	2e 29 07	rol $0729			rol 	GXSpriteOffset+1
.b443	0e 28 07	asl $0728			asl 	GXSpriteOffset
.b446	2e 29 07	rol $0729			rol 	GXSpriteOffset+1
.b449	18		clc				clc
.b44a	60		rts				rts
.b44b					_GXFSFail:
.b44b	38		sec				sec
.b44c	60		rts				rts
.b44d					_GXFXSSTTable:
>b44d	08 10 18 20					.byte 	8,16,24,32
.0725					GXSizePixels:
>0725							.fill 	1
.0726					GXSizeBits:
>0726							.fill 	1
.0727					GXSpriteLUT:
>0727							.fill 	1
.0728					GXSpriteOffset:
>0728							.fill 	2
.b451					GXSortXY:
.b451	20 6f b4	jsr $b46f			jsr 	GXSortY 					; will be sorted on Y now
.b454	ad 7a 06	lda $067a			lda 	gxX0 						; compare X0 v X1
.b457	cd 7e 06	cmp $067e			cmp 	gxX1
.b45a	ad 7b 06	lda $067b			lda 	gXX0+1
.b45d	ed 7f 06	sbc $067f			sbc 	gXX1+1
.b460	90 0c		bcc $b46e			bcc 	_GXSXYExit 					; X0 < X1 exit
.b462	a2 00		ldx #$00			ldx 	#0 							; swap them over
.b464	a0 04		ldy #$04			ldy 	#4
.b466	20 83 b4	jsr $b483			jsr 	GXSwapXY
.b469	e8		inx				inx
.b46a	c8		iny				iny
.b46b	20 83 b4	jsr $b483			jsr 	GXSwapXY
.b46e					_GXSXYExit:
.b46e	60		rts				rts
.b46f					GXSortY:
.b46f	ad 7c 06	lda $067c			lda 	gxY0 						; if Y0 >= Y1
.b472	cd 80 06	cmp $0680			cmp 	gxY1
.b475	90 0b		bcc $b482			bcc 	_GXSYSorted
.b477	a2 03		ldx #$03			ldx 	#3 							; swap 3-0
.b479	a0 07		ldy #$07			ldy 	#7 							; with 4-7
.b47b					_GXSwap1:
.b47b	20 83 b4	jsr $b483			jsr 	GXSwapXY
.b47e	88		dey				dey
.b47f	ca		dex				dex
.b480	10 f9		bpl $b47b			bpl 	_GXSwap1
.b482					_GXSYSorted:
.b482	60		rts				rts
.b483					GXSwapXY:
.b483	bd 7a 06	lda $067a,x			lda 	gxX0,x
.b486	48		pha				pha
.b487	b9 7a 06	lda $067a,y			lda 	gxX0,y
.b48a	9d 7a 06	sta $067a,x			sta 	gxX0,x
.b48d	68		pla				pla
.b48e	99 7a 06	sta $067a,y			sta 	gxX0,y
.b491	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_tokeniser.module

=1					tokeniserIntegrated=1
.b492					KeywordSet0:
>b492	00 65					.text	0,$65,""               ; $80 !0:EOF
>b494	00 58					.text	0,$58,""               ; $81 !1:SH1
>b496	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b498	04 fe 41 42 53 28			.text	4,$fe,"ABS("           ; $83 ABS(
>b49e	06 93 41 4c 4c 4f 43 28			.text	6,$93,"ALLOC("         ; $84 ALLOC(
>b4a6	04 ff 41 53 43 28			.text	4,$ff,"ASC("           ; $85 ASC(
>b4ac	05 29 43 48 52 24 28			.text	5,$29,"CHR$("          ; $86 CHR$(
>b4b3	05 41 44 45 45 4b 28			.text	5,$41,"DEEK("          ; $87 DEEK(
>b4ba	06 aa 45 56 45 4e 54 28			.text	6,$aa,"EVENT("         ; $88 EVENT(
>b4c2	05 6b 46 41 4c 53 45			.text	5,$6b,"FALSE"          ; $89 FALSE
>b4c9	05 44 46 52 41 43 28			.text	5,$44,"FRAC("          ; $8a FRAC(
>b4d0	04 0d 48 49 54 28			.text	4,$0d,"HIT("           ; $8b HIT(
>b4d6	04 13 49 4e 54 28			.text	4,$13,"INT("           ; $8c INT(
>b4dc	06 a7 49 53 56 41 4c 28			.text	6,$a7,"ISVAL("         ; $8d ISVAL(
>b4e4	05 5c 4a 4f 59 42 28			.text	5,$5c,"JOYB("          ; $8e JOYB(
>b4eb	05 72 4a 4f 59 58 28			.text	5,$72,"JOYX("          ; $8f JOYX(
>b4f2	05 73 4a 4f 59 59 28			.text	5,$73,"JOYY("          ; $90 JOYY(
>b4f9	06 77 4c 45 46 54 24 28			.text	6,$77,"LEFT$("         ; $91 LEFT$(
>b501	04 07 4c 45 4e 28			.text	4,$07,"LEN("           ; $92 LEN(
>b507	04 0e 4d 41 58 28			.text	4,$0e,"MAX("           ; $93 MAX(
>b50d	05 26 4d 49 44 24 28			.text	5,$26,"MID$("          ; $94 MID$(
>b514	04 0c 4d 49 4e 28			.text	4,$0c,"MIN("           ; $95 MIN(
>b51a	04 19 4e 4f 54 28			.text	4,$19,"NOT("           ; $96 NOT(
>b520	05 4d 50 45 45 4b 28			.text	5,$4d,"PEEK("          ; $97 PEEK(
>b527	08 3c 50 4c 41 59 49 4e			.text	8,$3c,"PLAYING("       ; $98 PLAYING(
>b52f	47 28
>b531	07 e9 52 41 4e 44 4f 4d			.text	7,$e9,"RANDOM("        ; $99 RANDOM(
>b539	28
>b53a	07 ca 52 49 47 48 54 24			.text	7,$ca,"RIGHT$("        ; $9a RIGHT$(
>b542	28
>b543	04 0c 52 4e 44 28			.text	4,$0c,"RND("           ; $9b RND(
>b549	04 10 53 47 4e 28			.text	4,$10,"SGN("           ; $9c SGN(
>b54f	04 0e 53 50 43 28			.text	4,$0e,"SPC("           ; $9d SPC(
>b555	05 45 53 54 52 24 28			.text	5,$45,"STR$("          ; $9e STR$(
>b55c	06 a9 54 49 4d 45 52 28			.text	6,$a9,"TIMER("         ; $9f TIMER(
>b564	04 40 54 52 55 45			.text	4,$40,"TRUE"           ; $a0 TRUE
>b56a	04 0b 56 41 4c 28			.text	4,$0b,"VAL("           ; $a1 VAL(
>b570	03 e7 46 4f 52				.text	3,$e7,"FOR"            ; $a2 FOR
>b575	02 8f 49 46				.text	2,$8f,"IF"             ; $a3 IF
>b579	04 34 50 52 4f 43			.text	4,$34,"PROC"           ; $a4 PROC
>b57f	06 c1 52 45 50 45 41 54			.text	6,$c1,"REPEAT"         ; $a5 REPEAT
>b587	05 79 57 48 49 4c 45			.text	5,$79,"WHILE"          ; $a6 WHILE
>b58e	05 66 45 4e 44 49 46			.text	5,$66,"ENDIF"          ; $a7 ENDIF
>b595	07 0b 45 4e 44 50 52 4f			.text	7,$0b,"ENDPROC"        ; $a8 ENDPROC
>b59d	43
>b59e	04 3f 4e 45 58 54			.text	4,$3f,"NEXT"           ; $a9 NEXT
>b5a4	04 2f 54 48 45 4e			.text	4,$2f,"THEN"           ; $aa THEN
>b5aa	05 8c 55 4e 54 49 4c			.text	5,$8c,"UNTIL"          ; $ab UNTIL
>b5b1	04 2e 57 45 4e 44			.text	4,$2e,"WEND"           ; $ac WEND
>b5b7	02 9b 42 59				.text	2,$9b,"BY"             ; $ad BY
>b5bb	04 1c 43 41 4c 4c			.text	4,$1c,"CALL"           ; $ae CALL
>b5c1	06 b2 43 49 52 43 4c 45			.text	6,$b2,"CIRCLE"         ; $af CIRCLE
>b5c9	05 67 43 4c 45 41 52			.text	5,$67,"CLEAR"          ; $b0 CLEAR
>b5d0	03 e2 43 4c 53				.text	3,$e2,"CLS"            ; $b1 CLS
>b5d5	05 7f 43 4f 4c 4f 52			.text	5,$7f,"COLOR"          ; $b2 COLOR
>b5dc	06 d4 43 4f 4c 4f 55 52			.text	6,$d4,"COLOUR"         ; $b3 COLOUR
>b5e4	04 1a 44 41 54 41			.text	4,$1a,"DATA"           ; $b4 DATA
>b5ea	03 da 44 49 4d				.text	3,$da,"DIM"            ; $b5 DIM
>b5ef	04 23 44 4f 4b 45			.text	4,$23,"DOKE"           ; $b6 DOKE
>b5f5	06 db 44 4f 57 4e 54 4f			.text	6,$db,"DOWNTO"         ; $b7 DOWNTO
>b5fd	04 29 45 4c 53 45			.text	4,$29,"ELSE"           ; $b8 ELSE
>b603	04 34 46 52 4f 4d			.text	4,$34,"FROM"           ; $b9 FROM
>b609	03 e5 47 46 58				.text	3,$e5,"GFX"            ; $ba GFX
>b60e	05 80 47 4f 53 55 42			.text	5,$80,"GOSUB"          ; $bb GOSUB
>b615	04 39 47 4f 54 4f			.text	4,$39,"GOTO"           ; $bc GOTO
>b61b	04 24 48 45 52 45			.text	4,$24,"HERE"           ; $bd HERE
>b621	05 63 49 4d 41 47 45			.text	5,$63,"IMAGE"          ; $be IMAGE
>b628	05 90 49 4e 50 55 54			.text	5,$90,"INPUT"          ; $bf INPUT
>b62f	03 e5 4c 45 54				.text	3,$e5,"LET"            ; $c0 LET
>b634	04 28 4c 49 4e 45			.text	4,$28,"LINE"           ; $c1 LINE
>b63a	05 6b 4c 4f 43 41 4c			.text	5,$6b,"LOCAL"          ; $c2 LOCAL
>b641	03 db 4f 46 46				.text	3,$db,"OFF"            ; $c3 OFF
>b646	02 9d 4f 4e				.text	2,$9d,"ON"             ; $c4 ON
>b64a	07 20 4f 55 54 4c 49 4e			.text	7,$20,"OUTLINE"        ; $c5 OUTLINE
>b652	45
>b653	07 0f 50 41 4c 45 54 54			.text	7,$0f,"PALETTE"        ; $c6 PALETTE
>b65b	45
>b65c	04 3f 50 4c 4f 54			.text	4,$3f,"PLOT"           ; $c7 PLOT
>b662	04 2f 50 4f 4b 45			.text	4,$2f,"POKE"           ; $c8 POKE
>b668	05 8d 50 52 49 4e 54			.text	5,$8d,"PRINT"          ; $c9 PRINT
>b66f	04 1c 52 45 41 44			.text	4,$1c,"READ"           ; $ca READ
>b675	04 2e 52 45 43 54			.text	4,$2e,"RECT"           ; $cb RECT
>b67b	03 e4 52 45 4d				.text	3,$e4,"REM"            ; $cc REM
>b680	06 e0 52 45 54 55 52 4e			.text	6,$e0,"RETURN"         ; $cd RETURN
>b688	05 7b 53 4f 4c 49 44			.text	5,$7b,"SOLID"          ; $ce SOLID
>b68f	05 89 53 4f 55 4e 44			.text	5,$89,"SOUND"          ; $cf SOUND
>b696	06 d7 53 50 52 49 54 45			.text	6,$d7,"SPRITE"         ; $d0 SPRITE
>b69e	04 45 54 45 58 54			.text	4,$45,"TEXT"           ; $d1 TEXT
>b6a4	02 a3 54 4f				.text	2,$a3,"TO"             ; $d2 TO
>b6a8	ff					.text	$FF
.b6a9					KeywordSet1:
>b6a9	00 65					.text	0,$65,""               ; $80 !0:EOF
>b6ab	00 58					.text	0,$58,""               ; $81 !1:SH1
>b6ad	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b6af	08 4c 41 53 53 45 4d 42			.text	8,$4c,"ASSEMBLE"       ; $83 ASSEMBLE
>b6b7	4c 45
>b6b9	06 d2 41 53 53 45 52 54			.text	6,$d2,"ASSERT"         ; $84 ASSERT
>b6c1	06 bd 42 49 54 4d 41 50			.text	6,$bd,"BITMAP"         ; $85 BITMAP
>b6c9	03 d7 45 4e 44				.text	3,$d7,"END"            ; $86 END
>b6ce	07 11 45 58 50 4c 4f 44			.text	7,$11,"EXPLODE"        ; $87 EXPLODE
>b6d6	45
>b6d7	02 96 47 4f				.text	2,$96,"GO"             ; $88 GO
>b6db	04 3c 4c 49 53 54			.text	4,$3c,"LIST"           ; $89 LIST
>b6e1	04 20 4c 4f 41 44			.text	4,$20,"LOAD"           ; $8a LOAD
>b6e7	03 ea 4e 45 57				.text	3,$ea,"NEW"            ; $8b NEW
>b6ec	04 2e 50 49 4e 47			.text	4,$2e,"PING"           ; $8c PING
>b6f2	07 24 52 45 53 54 4f 52			.text	7,$24,"RESTORE"        ; $8d RESTORE
>b6fa	45
>b6fb	03 f5 52 55 4e				.text	3,$f5,"RUN"            ; $8e RUN
>b700	05 8d 53 48 4f 4f 54			.text	5,$8d,"SHOOT"          ; $8f SHOOT
>b707	07 2a 53 50 52 49 54 45			.text	7,$2a,"SPRITES"        ; $90 SPRITES
>b70f	53
>b710	04 46 53 54 4f 50			.text	4,$46,"STOP"           ; $91 STOP
>b716	03 eb 5a 41 50				.text	3,$eb,"ZAP"            ; $92 ZAP
>b71b	ff					.text	$FF
.b71c					KeywordSet2:
>b71c	00 65					.text	0,$65,""               ; $80 !0:EOF
>b71e	00 58					.text	0,$58,""               ; $81 !1:SH1
>b720	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b722	03 c8 41 44 43				.text	3,$c8,"ADC"            ; $83 ADC
>b727	03 d3 41 4e 44				.text	3,$d3,"AND"            ; $84 AND
>b72c	03 e0 41 53 4c				.text	3,$e0,"ASL"            ; $85 ASL
>b731	03 c8 42 43 43				.text	3,$c8,"BCC"            ; $86 BCC
>b736	03 d8 42 43 53				.text	3,$d8,"BCS"            ; $87 BCS
>b73b	03 d8 42 45 51				.text	3,$d8,"BEQ"            ; $88 BEQ
>b740	03 df 42 49 54				.text	3,$df,"BIT"            ; $89 BIT
>b745	03 d8 42 4d 49				.text	3,$d8,"BMI"            ; $8a BMI
>b74a	03 d5 42 4e 45				.text	3,$d5,"BNE"            ; $8b BNE
>b74f	03 de 42 50 4c				.text	3,$de,"BPL"            ; $8c BPL
>b754	03 d5 42 52 41				.text	3,$d5,"BRA"            ; $8d BRA
>b759	03 df 42 52 4b				.text	3,$df,"BRK"            ; $8e BRK
>b75e	03 db 42 56 43				.text	3,$db,"BVC"            ; $8f BVC
>b763	03 eb 42 56 53				.text	3,$eb,"BVS"            ; $90 BVS
>b768	03 d2 43 4c 43				.text	3,$d2,"CLC"            ; $91 CLC
>b76d	03 d3 43 4c 44				.text	3,$d3,"CLD"            ; $92 CLD
>b772	03 d8 43 4c 49				.text	3,$d8,"CLI"            ; $93 CLI
>b777	03 e5 43 4c 56				.text	3,$e5,"CLV"            ; $94 CLV
>b77c	03 e0 43 4d 50				.text	3,$e0,"CMP"            ; $95 CMP
>b781	03 eb 43 50 58				.text	3,$eb,"CPX"            ; $96 CPX
>b786	03 ec 43 50 59				.text	3,$ec,"CPY"            ; $97 CPY
>b78b	03 cc 44 45 43				.text	3,$cc,"DEC"            ; $98 DEC
>b790	03 e1 44 45 58				.text	3,$e1,"DEX"            ; $99 DEX
>b795	03 e2 44 45 59				.text	3,$e2,"DEY"            ; $9a DEY
>b79a	03 e6 45 4f 52				.text	3,$e6,"EOR"            ; $9b EOR
>b79f	03 da 49 4e 43				.text	3,$da,"INC"            ; $9c INC
>b7a4	03 ef 49 4e 58				.text	3,$ef,"INX"            ; $9d INX
>b7a9	03 f0 49 4e 59				.text	3,$f0,"INY"            ; $9e INY
>b7ae	03 e7 4a 4d 50				.text	3,$e7,"JMP"            ; $9f JMP
>b7b3	03 ef 4a 53 52				.text	3,$ef,"JSR"            ; $a0 JSR
>b7b8	03 d1 4c 44 41				.text	3,$d1,"LDA"            ; $a1 LDA
>b7bd	03 e8 4c 44 58				.text	3,$e8,"LDX"            ; $a2 LDX
>b7c2	03 e9 4c 44 59				.text	3,$e9,"LDY"            ; $a3 LDY
>b7c7	03 f1 4c 53 52				.text	3,$f1,"LSR"            ; $a4 LSR
>b7cc	03 ed 4e 4f 50				.text	3,$ed,"NOP"            ; $a5 NOP
>b7d1	03 e2 4f 52 41				.text	3,$e2,"ORA"            ; $a6 ORA
>b7d6	03 d9 50 48 41				.text	3,$d9,"PHA"            ; $a7 PHA
>b7db	03 e8 50 48 50				.text	3,$e8,"PHP"            ; $a8 PHP
>b7e0	03 f0 50 48 58				.text	3,$f0,"PHX"            ; $a9 PHX
>b7e5	03 f1 50 48 59				.text	3,$f1,"PHY"            ; $aa PHY
>b7ea	03 dd 50 4c 41				.text	3,$dd,"PLA"            ; $ab PLA
>b7ef	03 ec 50 4c 50				.text	3,$ec,"PLP"            ; $ac PLP
>b7f4	03 f4 50 4c 58				.text	3,$f4,"PLX"            ; $ad PLX
>b7f9	03 f5 50 4c 59				.text	3,$f5,"PLY"            ; $ae PLY
>b7fe	03 ed 52 4f 4c				.text	3,$ed,"ROL"            ; $af ROL
>b803	03 f3 52 4f 52				.text	3,$f3,"ROR"            ; $b0 ROR
>b808	03 ef 52 54 49				.text	3,$ef,"RTI"            ; $b1 RTI
>b80d	03 f9 52 54 53				.text	3,$f9,"RTS"            ; $b2 RTS
>b812	03 d8 53 42 43				.text	3,$d8,"SBC"            ; $b3 SBC
>b817	03 db 53 45 43				.text	3,$db,"SEC"            ; $b4 SEC
>b81c	03 dc 53 45 44				.text	3,$dc,"SED"            ; $b5 SED
>b821	03 e1 53 45 49				.text	3,$e1,"SEI"            ; $b6 SEI
>b826	03 e8 53 54 41				.text	3,$e8,"STA"            ; $b7 STA
>b82b	03 f7 53 54 50				.text	3,$f7,"STP"            ; $b8 STP
>b830	03 ff 53 54 58				.text	3,$ff,"STX"            ; $b9 STX
>b835	03 00 53 54 59				.text	3,$00,"STY"            ; $ba STY
>b83a	03 01 53 54 5a				.text	3,$01,"STZ"            ; $bb STZ
>b83f	03 ed 54 41 58				.text	3,$ed,"TAX"            ; $bc TAX
>b844	03 ee 54 41 59				.text	3,$ee,"TAY"            ; $bd TAY
>b849	03 e8 54 52 42				.text	3,$e8,"TRB"            ; $be TRB
>b84e	03 e9 54 53 42				.text	3,$e9,"TSB"            ; $bf TSB
>b853	03 ff 54 53 58				.text	3,$ff,"TSX"            ; $c0 TSX
>b858	03 ed 54 58 41				.text	3,$ed,"TXA"            ; $c1 TXA
>b85d	03 ff 54 58 53				.text	3,$ff,"TXS"            ; $c2 TXS
>b862	03 ee 54 59 41				.text	3,$ee,"TYA"            ; $c3 TYA
>b867	ff					.text	$FF
.b868					Export_TKListConvertLine:
.b868	48		pha				pha 								; save indent on the stack
.b869	9c 1d 04	stz $041d			stz 	tbOffset
.b86c	9c 2d 04	stz $042d			stz 	tokenBuffer
.b86f	9c 29 04	stz $0429			stz 	currentListColour
.b872	a9 89		lda #$89			lda 	#CLILineNumber+$80
.b874	20 f1 b9	jsr $b9f1			jsr 	LCLWriteColour
.b877	a0 02		ldy #$02			ldy 	#2 							; convert line number to string
.b879	b1 30		lda ($30),y			lda 	(codePtr),y
.b87b	aa		tax				tax
.b87c	88		dey				dey
.b87d	b1 30		lda ($30),y			lda 	(codePtr),y
.b87f	20 62 ba	jsr $ba62			jsr 	LCLWriteNumberXA
.b882	68		pla				pla 								; adjustment to indent
.b883	48		pha				pha 								; save on stack
.b884	10 0c		bpl $b892			bpl 	_LCNoAdjust 				; don't adjust indent if +ve, do after.
.b886	18		clc				clc 								; add to list indent and make 0 if goes -ve.
.b887	6d 26 04	adc $0426			adc 	listIndent
.b88a	8d 26 04	sta $0426			sta 	listIndent
.b88d	10 03		bpl $b892			bpl 	_LCNoAdjust
.b88f	9c 26 04	stz $0426			stz 	listIndent
.b892					_LCNoAdjust:
.b892	18		clc				clc		 							; work out actual indent.
.b893	ad 26 04	lda $0426			lda 	listIndent
.b896	0a		asl a				asl 	a
.b897	69 07		adc #$07			adc 	#7
.b899	85 36		sta $36				sta 	zTemp0
.b89b					_LCPadOut:
.b89b	a9 20		lda #$20			lda 	#' '						; pad out to 6+indent characters
.b89d	20 fa b9	jsr $b9fa			jsr 	LCLWrite
.b8a0	ad 1d 04	lda $041d			lda 	tbOffset
.b8a3	c5 36		cmp $36				cmp 	zTemp0
.b8a5	d0 f4		bne $b89b			bne 	_LCPadOut
.b8a7	a0 03		ldy #$03			ldy 	#3 							; start position.
.b8a9					_LCMainLoop:
.b8a9	a9 8a		lda #$8a			lda 	#CLIPunctuation+$80
.b8ab	20 f1 b9	jsr $b9f1			jsr 	LCLWriteColour
.b8ae	b1 30		lda ($30),y			lda 	(codePtr),y
.b8b0	c9 80		cmp #$80			cmp 	#KWC_EOL 					; end of line ?
.b8b2	f0 17		beq $b8cb			beq 	_LCExit
.b8b4	c9 10		cmp #$10			cmp 	#16 						; 0-5 are the double punctuations
.b8b6	90 1e		bcc $b8d6			bcc 	_LCDoubles
.b8b8	c9 20		cmp #$20			cmp 	#32 						; 16-31 are shifted punctuation from 64-91
.b8ba	90 2a		bcc $b8e6			bcc 	_LCShiftPunc
.b8bc	c9 40		cmp #$40			cmp 	#64 						; 32-64 are as stored, punc and digits
.b8be	90 35		bcc $b8f5			bcc 	_LCPunctuation
.b8c0	c9 80		cmp #$80			cmp 	#128 						; 64-127 are variable identifiers.
.b8c2	90 51		bcc $b915			bcc 	_LCIdentifiers
.b8c4	c9 fe		cmp #$fe			cmp 	#254 						; 128-253 are tokenised words
.b8c6	90 73		bcc $b93b			bcc 	_LCTokens
.b8c8	4c 9b b9	jmp $b99b			jmp 	_LCData 					; 254-5 are data objects
.b8cb					_LCExit:
.b8cb	68		pla				pla 								; get old indent adjust
.b8cc	30 07		bmi $b8d5			bmi 	_LCExit2
.b8ce	18		clc				clc 								; add to indent if +ve
.b8cf	6d 26 04	adc $0426			adc 	listIndent
.b8d2	8d 26 04	sta $0426			sta 	listIndent
.b8d5					_LCExit2:
.b8d5	60		rts				rts
.b8d6					_LCDoubles:
.b8d6	48		pha				pha
.b8d7	4a		lsr a				lsr 	a 							; put bit 2 into bit 1
.b8d8	29 02		and #$02			and 	#2
.b8da	09 3c		ora #$3c			ora 	#60 						; make < >
.b8dc	20 fa b9	jsr $b9fa			jsr 	LCLWrite
.b8df	68		pla				pla 								; restore, do lower bit
.b8e0	29 03		and #$03			and 	#3
.b8e2	09 3c		ora #$3c			ora 	#60
.b8e4	80 0f		bra $b8f5			bra		_LCPunctuation 				; print, increment, loop
.b8e6					_LCShiftPunc:
.b8e6	aa		tax				tax 								; save in X
.b8e7	29 07		and #$07			and 	#7 							; lower 3 bits
.b8e9	f0 02		beq $b8ed			beq 	_LCNoAdd
.b8eb	09 18		ora #$18			ora 	#24 						; adds $18 to it.
.b8ed					_LCNoAdd:
.b8ed	e0 18		cpx #$18			cpx 	#24 						; if >= 24 add $20
.b8ef	90 02		bcc $b8f3			bcc 	_LCNoAdd2
.b8f1	09 20		ora #$20			ora 	#32 						; adds $20
.b8f3					_LCNoAdd2:
.b8f3	09 40		ora #$40			ora 	#$40 						; shift into 64-127 range and fall through.
.b8f5					_LCPunctuation:
.b8f5	c9 3a		cmp #$3a			cmp 	#':' 						; check if :
.b8f7	d0 03		bne $b8fc			bne 	_LCPContinue
.b8f9	20 10 ba	jsr $ba10			jsr 	LCLDeleteLastSpace 			; if so delete any preceding spaces
.b8fc					_LCPContinue:
.b8fc	c9 2e		cmp #$2e			cmp 	#'.'
.b8fe	f0 08		beq $b908			beq 	_LCPIsConstant
.b900	c9 30		cmp #$30			cmp 	#'0'
.b902	90 0b		bcc $b90f			bcc 	_LCPNotConstant
.b904	c9 3a		cmp #$3a			cmp 	#'9'+1
.b906	b0 07		bcs $b90f			bcs 	_LCPNotConstant
.b908					_LCPIsConstant:
.b908	48		pha				pha
.b909	a9 8d		lda #$8d			lda 	#CLIConstant+$80
.b90b	20 f1 b9	jsr $b9f1			jsr 	LCLWriteColour
.b90e	68		pla				pla
.b90f					_LCPNotConstant:
.b90f	c8		iny				iny 								; consume character
.b910	20 fa b9	jsr $b9fa			jsr 	LCLWrite 					; write it out.
.b913	80 94		bra $b8a9			bra 	_LCMainLoop 				; go round again.
.b915					_LCIdentifiers:
.b915	18		clc				clc 								; convert to physical address
.b916	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.b918	85 37		sta $37				sta 	zTemp0+1
.b91a	c8		iny				iny
.b91b	b1 30		lda ($30),y			lda 	(codePtr),y
.b91d	85 36		sta $36				sta 	zTemp0
.b91f	c8		iny				iny
.b920	5a		phy				phy 								; save position
.b921	a9 87		lda #$87			lda 	#CLIIdentifier+$80
.b923	20 f1 b9	jsr $b9f1			jsr 	LCLWriteColour
.b926	a0 07		ldy #$07			ldy 	#7 							; output the identifier at +8
.b928					_LCOutIdentifier:
.b928	c8		iny				iny
.b929	b1 36		lda ($36),y			lda 	(zTemp0),y					; bit 7 set = end.
.b92b	29 7f		and #$7f			and 	#$7F
.b92d	20 4c ba	jsr $ba4c			jsr 	LCLLowerCase
.b930	20 fa b9	jsr $b9fa			jsr 	LCLWrite
.b933	b1 36		lda ($36),y			lda 	(zTemp0),y				 	; ends when bit 7 set.
.b935	10 f1		bpl $b928			bpl 	_LCOutIdentifier
.b937	7a		ply				ply 								; restore position
.b938	4c a9 b8	jmp $b8a9			jmp 	_LCMainLoop
.b93b					_LCTokens:
.b93b	aa		tax				tax 								; token in X
.b93c	a9 1c		lda #$1c			lda 	#((KeywordSet2) & $FF)
.b93e	85 36		sta $36				sta 	0+zTemp0
.b940	a9 b7		lda #$b7			lda 	#((KeywordSet2) >> 8)
.b942	85 37		sta $37				sta 	1+zTemp0
.b944	e0 82		cpx #$82			cpx 	#$82
.b946	f0 16		beq $b95e			beq 	_LCUseShift
.b948	a9 a9		lda #$a9			lda 	#((KeywordSet1) & $FF)
.b94a	85 36		sta $36				sta 	0+zTemp0
.b94c	a9 b6		lda #$b6			lda 	#((KeywordSet1) >> 8)
.b94e	85 37		sta $37				sta 	1+zTemp0
.b950	e0 81		cpx #$81			cpx 	#$81
.b952	f0 0a		beq $b95e			beq 	_LCUseShift
.b954	a9 92		lda #$92			lda 	#((KeywordSet0) & $FF)
.b956	85 36		sta $36				sta 	0+zTemp0
.b958	a9 b4		lda #$b4			lda 	#((KeywordSet0) >> 8)
.b95a	85 37		sta $37				sta 	1+zTemp0
.b95c	80 01		bra $b95f			bra 	_LCNoShift
.b95e					_LCUseShift:
.b95e	c8		iny				iny
.b95f					_LCNoShift:
.b95f	20 24 ba	jsr $ba24			jsr 	LCLCheckSpaceRequired 		; do we need a space ?
.b962	b1 30		lda ($30),y			lda 	(codePtr),y
.b964	aa		tax				tax 								; into X
.b965					_LCFindText:
.b965	ca		dex				dex
.b966	10 0e		bpl $b976			bpl 	_LCFoundText 				; found text.
.b968	b2 36		lda ($36)			lda 	(zTemp0) 					; length of text
.b96a	1a		inc a				inc 	a 							; one extra for size
.b96b	38		sec				sec 								; one extra for checksum
.b96c	65 36		adc $36				adc 	zTemp0 						; go to next token
.b96e	85 36		sta $36				sta 	zTemp0
.b970	90 f3		bcc $b965			bcc 	_LCFindText
.b972	e6 37		inc $37				inc 	zTemp0+1
.b974	80 ef		bra $b965			bra 	_LCFindText
.b976					_LCFoundText:
.b976	5a		phy				phy 								; save List position
.b977	b2 36		lda ($36)			lda 	(zTemp0)					; count to print
.b979	aa		tax				tax
.b97a	a9 83		lda #$83			lda 	#CLIToken+$80
.b97c	20 f1 b9	jsr $b9f1			jsr 	LCLWriteColour
.b97f	a0 02		ldy #$02			ldy 	#2
.b981					_LCCopyToken:
.b981	b1 36		lda ($36),y			lda 	(zTemp0),y
.b983	20 4c ba	jsr $ba4c			jsr 	LCLLowerCase
.b986	20 fa b9	jsr $b9fa			jsr 	LCLWrite
.b989	c8		iny				iny
.b98a	ca		dex				dex
.b98b	d0 f4		bne $b981			bne 	_LCCopyToken
.b98d	c9 28		cmp #$28			cmp 	#"(" 						; if last char not ( print a space
.b98f	f0 05		beq $b996			beq 	_LCNoSpace
.b991	a9 20		lda #$20			lda 	#' '
.b993	20 fa b9	jsr $b9fa			jsr 	LCLWrite
.b996					_LCNoSpace:
.b996	7a		ply				ply 								; restore position.
.b997	c8		iny				iny 								; consume token
.b998	4c a9 b8	jmp $b8a9			jmp 	_LCMainLoop 				; and go around again.
.b99b					_LCData:
.b99b	48		pha				pha 								; save type $FE/$FF
.b99c	a2 24		ldx #$24			ldx 	#'$' 						; figure out $ or "
.b99e	c9 fe		cmp #$fe			cmp 	#$FE
.b9a0	f0 22		beq $b9c4			beq 	_LCHaveOpener
.b9a2	a2 22		ldx #$22			ldx 	#'"'
.b9a4	a9 81		lda #$81			lda 	#CLIData+$80
.b9a6	20 f1 b9	jsr $b9f1			jsr 	LCLWriteColour
.b9a9	c0 04		cpy #$04			cpy 	#4 							; must be 2nd thing on line
.b9ab	d0 17		bne $b9c4			bne 	_LCHaveOpener
.b9ad	88		dey				dey 								; what precedes it ?
.b9ae	b1 30		lda ($30),y			lda 	(codePtr),y
.b9b0	c8		iny				iny
.b9b1	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; if quote
.b9b3	d0 0f		bne $b9c4			bne 	_LCHaveOpener
.b9b5	a9 09		lda #$09			lda 	#9 							; tab
.b9b7	20 fa b9	jsr $b9fa			jsr 	LCLWrite
.b9ba	a9 97		lda #$97			lda 	#$90+CLIBComment
.b9bc	20 fa b9	jsr $b9fa			jsr 	LCLWrite
.b9bf	a9 80		lda #$80			lda 	#CLIFComment+$80
.b9c1	20 f1 b9	jsr $b9f1			jsr 	LCLWriteColour
.b9c4					_LCHaveOpener:
.b9c4	8a		txa				txa 								; output prefix (# or ")
.b9c5	20 fa b9	jsr $b9fa			jsr 	LCLWrite
.b9c8	c8		iny				iny 								; get count
.b9c9	b1 30		lda ($30),y			lda 	(codePtr),y
.b9cb	aa		tax				tax
.b9cc	c8		iny				iny 								; point at first character
.b9cd					_LCOutData:
.b9cd	b1 30		lda ($30),y			lda 	(codePtr),y
.b9cf	c9 00		cmp #$00			cmp 	#0
.b9d1	f0 03		beq $b9d6			beq 	_LCNoPrint
.b9d3	20 fa b9	jsr $b9fa			jsr 	LCLWrite
.b9d6					_LCNoPrint:
.b9d6	c8		iny				iny
.b9d7	ca		dex				dex
.b9d8	d0 f3		bne $b9cd			bne 	_LCOutData
.b9da	68		pla				pla 								; closing " required ?
.b9db	c9 ff		cmp #$ff			cmp 	#$FF 						; not required for hex constant.
.b9dd	d0 0f		bne $b9ee			bne 	_LCNoQuote
.b9df	a9 22		lda #$22			lda 	#'"'
.b9e1	20 fa b9	jsr $b9fa			jsr 	LCLWrite
.b9e4	ad 6f 06	lda $066f			lda 	EXTTextColour
.b9e7	29 0f		and #$0f			and 	#$0F
.b9e9	09 90		ora #$90			ora 	#$90
.b9eb	20 fa b9	jsr $b9fa			jsr 	LCLWrite
.b9ee					_LCNoQuote:
.b9ee	4c a9 b8	jmp $b8a9			jmp 	_LCMainLoop
.b9f1					LCLWriteColour:
.b9f1	cd 29 04	cmp $0429			cmp 	currentListColour 			; has the colour changed
.b9f4	8d 29 04	sta $0429			sta 	currentListColour 			; (update it anyway)
.b9f7	d0 01		bne $b9fa			bne 	LCLWrite 					; if different, output it
.b9f9	60		rts				rts
.b9fa					LCLWrite:
.b9fa	da		phx				phx
.b9fb	ae 1d 04	ldx $041d			ldx 	tbOffset 					; write out make ASCIIZ
.b9fe	9d 2d 04	sta $042d,x			sta 	tokenBuffer,x
.ba01	9e 2e 04	stz $042e,x			stz 	tokenBuffer+1,x
.ba04	ee 1d 04	inc $041d			inc 	tbOffset 					; bump the position
.ba07	09 00		ora #$00			ora 	#0 							; don't update last character if colour data
.ba09	30 03		bmi $ba0e			bmi 	_LCLNoColour
.ba0b	8d 27 04	sta $0427			sta 	LCLastCharacter
.ba0e					_LCLNoColour:
.ba0e	fa		plx				plx
.ba0f	60		rts				rts
.ba10					LCLDeleteLastSpace:
.ba10	48		pha				pha
.ba11	da		phx				phx
.ba12	ae 1d 04	ldx $041d			ldx 	tbOffset
.ba15	f0 0a		beq $ba21			beq 	_LCDLSExit
.ba17	bd 2c 04	lda $042c,x			lda 	tokenBuffer-1,x
.ba1a	c9 20		cmp #$20			cmp 	#' '
.ba1c	d0 03		bne $ba21			bne 	_LCDLSExit
.ba1e	ce 1d 04	dec $041d			dec 	tbOffset
.ba21					_LCDLSExit:
.ba21	fa		plx				plx
.ba22	68		pla				pla
.ba23	60		rts				rts
.ba24					LCLCheckSpaceRequired:
.ba24	ad 27 04	lda $0427			lda 	LCLastCharacter 			; check last character
.ba27	c9 24		cmp #$24			cmp 	#'$' 						; $ # and ) require that token space.
.ba29	f0 1b		beq $ba46			beq 	_LCCSRSpace
.ba2b	c9 29		cmp #$29			cmp 	#')'
.ba2d	f0 17		beq $ba46			beq 	_LCCSRSpace
.ba2f	c9 23		cmp #$23			cmp 	#'#'
.ba31	f0 13		beq $ba46			beq 	_LCCSRSpace
.ba33	20 4c ba	jsr $ba4c			jsr 	LCLLowerCase 				; saves a little effort
.ba36	c9 30		cmp #$30			cmp 	#"0" 						; check if it was 0-9 A-Z a-z if so need space.
.ba38	90 11		bcc $ba4b			bcc 	_LCCSRExit
.ba3a	c9 3a		cmp #$3a			cmp 	#"9"+1
.ba3c	90 08		bcc $ba46			bcc 	_LCCSRSpace
.ba3e	c9 61		cmp #$61			cmp 	#"a"
.ba40	90 09		bcc $ba4b			bcc 	_LCCSRExit
.ba42	c9 7b		cmp #$7b			cmp 	#"z"+1
.ba44	b0 05		bcs $ba4b			bcs 	_LCCSRExit
.ba46					_LCCSRSpace:
.ba46	a9 20		lda #$20			lda 	#' '
.ba48	20 fa b9	jsr $b9fa			jsr 	LCLWrite
.ba4b					_LCCSRExit:
.ba4b	60		rts				rts
.ba4c					LCLLowerCase:
.ba4c	c9 41		cmp #$41			cmp 	#"A"
.ba4e	90 06		bcc $ba56			bcc 	_LCLLCOut
.ba50	c9 5b		cmp #$5b			cmp 	#"Z"+1
.ba52	b0 02		bcs $ba56			bcs 	_LCLLCOut
.ba54	69 20		adc #$20			adc 	#$20
.ba56					_LCLLCOut:
.ba56	60		rts				rts
.ba57					LCLUpperCase:
.ba57	c9 61		cmp #$61			cmp 	#"a"
.ba59	90 06		bcc $ba61			bcc 	_LCLUCOut
.ba5b	c9 7b		cmp #$7b			cmp 	#"z"+1
.ba5d	b0 02		bcs $ba61			bcs 	_LCLUCOut
.ba5f	e9 1f		sbc #$1f			sbc 	#$1F
.ba61					_LCLUCOut:
.ba61	60		rts				rts
.ba62					LCLWriteNumberXA:
.ba62	64 37		stz $37				stz 	zTemp0+1 					; index into digit table.
.ba64					_LCLWNLoop1:
.ba64	64 36		stz $36				stz 	zTemp0 						; subtraction count.
.ba66					_LCLWNLoop2:
.ba66	48		pha				pha 								; save initial LSB
.ba67	38		sec				sec
.ba68	a4 37		ldy $37				ldy 	zTemp0+1 					; position in table.
.ba6a	f9 9b ba	sbc $ba9b,y			sbc 	_LCLWNTable,y
.ba6d	48		pha				pha
.ba6e	8a		txa				txa
.ba6f	f9 9c ba	sbc $ba9c,y			sbc 	_LCLWNTable+1,y
.ba72	90 07		bcc $ba7b			bcc 	_LCLWNUnderflow
.ba74	e6 36		inc $36				inc 	zTemp0  					; subtracted one without borrow.
.ba76	aa		tax				tax 								; update X
.ba77	68		pla				pla 								; restore A
.ba78	7a		ply				ply 								; throw original
.ba79	80 eb		bra $ba66			bra 	_LCLWNLoop2 				; try again.
.ba7b					_LCLWNUnderflow:
.ba7b	a4 36		ldy $36				ldy 	zTemp0 						; count of subtractions.
.ba7d	d0 06		bne $ba85			bne 	_LCLWNOut
.ba7f	ad 1d 04	lda $041d			lda 	tbOffset 					; suppress leading zeroes
.ba82	3a		dec a				dec 	a
.ba83	f0 04		beq $ba89			beq 	_LCLWNNext
.ba85					_LCLWNOut:
.ba85	98		tya				tya
.ba86	20 95 ba	jsr $ba95			jsr 	_LCLWNOutDigit
.ba89					_LCLWNNext:
.ba89	7a		ply				ply 							 	; restore original value.
.ba8a	68		pla				pla
.ba8b	a4 37		ldy $37				ldy 	zTemp0+1  					; bump the index
.ba8d	c8		iny				iny
.ba8e	c8		iny				iny
.ba8f	84 37		sty $37				sty 	zTemp0+1
.ba91	c0 08		cpy #$08			cpy 	#8 							; done all 4
.ba93	d0 cf		bne $ba64			bne 	_LCLWNLoop1
.ba95					_LCLWNOutDigit:
.ba95	09 30		ora #$30			ora 	#'0'
.ba97	20 fa b9	jsr $b9fa			jsr 	LCLWrite
.ba9a	60		rts				rts
.ba9b					_LCLWNTable:
>ba9b	10 27						.word 	10000
>ba9d	e8 03						.word 	1000
>ba9f	64 00						.word 	100
>baa1	0a 00						.word 	10
.baa3					TOKSearchTable:
.baa3	84 37		sty $37				sty 	zTemp0+1 					; (zTemp0),y points to current token being tested.
.baa5	85 36		sta $36				sta 	zTemp0
.baa7	a0 00		ldy #$00			ldy 	#0
.baa9	a9 80		lda #$80			lda 	#$80 						; token # so we know which one we are looking at
.baab	85 38		sta $38				sta 	zTemp1
.baad					_TSTLoop:
.baad	b1 36		lda ($36),y			lda 	(zTemp0),y 					; length, 0 (skip) -ve (end)
.baaf	30 49		bmi $bafa			bmi 	_TSTFail 					; -ve = end of table, so fail.
.bab1	f0 2e		beq $bae1			beq 	_TSTNext 					; zero, check next as it's a dummy (e.g. EOL, SHIFT)
.bab3	c8		iny				iny 								; get the hash
.bab4	b1 36		lda ($36),y			lda 	(zTemp0),y
.bab6	88		dey				dey
.bab7	cd 03 04	cmp $0403			cmp 	identHash 					; check they match with the identifier hash, if not go to next
.baba	d0 25		bne $bae1			bne 	_TSTNext
.babc	ad 02 04	lda $0402			lda 	identTypeEnd 				; get length of identifier from end-start
.babf	38		sec				sec
.bac0	ed 00 04	sbc $0400			sbc 	identStart
.bac3	d1 36		cmp ($36),y			cmp 	(zTemp0),y 					; compare against the length in the table, no match, then return.
.bac5	d0 1a		bne $bae1			bne 	_TSTNext
.bac7	5a		phy				phy 								; save Y , we might fail to match.
.bac8	c8		iny				iny 								; point to text
.bac9	c8		iny				iny
.baca	ae 00 04	ldx $0400			ldx 	identStart 					; offset in line buffer in X
.bacd					_TSTCompareName:
.bacd	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; compare text.
.bad0	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.bad2	d0 0c		bne $bae0			bne 	_TSTNextPullY 				; fail, pullY and do next
.bad4	e8		inx				inx
.bad5	c8		iny				iny
.bad6	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; complete match.
.bad9	d0 f2		bne $bacd			bne 	_TSTCompareName
.badb	7a		ply				ply 								; throw Y
.badc	a5 38		lda $38				lda 	zTemp1 						; get token #
.bade	38		sec				sec 								; return with CS = passed.
.badf	60		rts				rts
.bae0					_TSTNextPullY:
.bae0	7a		ply				ply 								; restore current, fall through.
.bae1					_TSTNext:
.bae1	e6 38		inc $38				inc 	zTemp1 						; token counter
.bae3	98		tya				tya
.bae4	18		clc				clc
.bae5	71 36		adc ($36),y			adc 	(zTemp0),y 					; add [Length] + 2 to Y
.bae7	1a		inc a				inc 	a 							; +1
.bae8	1a		inc a				inc 	a 							; +2
.bae9	a8		tay				tay
.baea	10 c1		bpl $baad			bpl 	_TSTLoop 					; if Y < $80 loop back
.baec	98		tya				tya 								; add Y to zTemp0 and reset Y
.baed	a0 00		ldy #$00			ldy 	#0   						; so we can use Y to search fast
.baef	18		clc				clc  								; but have tables > 255 bytes
.baf0	65 36		adc $36				adc 	zTemp0 						; when Y gets >= 128 we reset Y
.baf2	85 36		sta $36				sta 	zTemp0 						; and adjust the table pointer/
.baf4	90 b7		bcc $baad			bcc 	_TSTLoop
.baf6	e6 37		inc $37				inc 	zTemp0+1
.baf8	80 b3		bra $baad			bra 	_TSTLoop
.bafa					_TSTFail:
.bafa	18		clc				clc
.bafb	60		rts				rts
.bafc					Export_TKTokeniseLine:
.bafc	20 84 bc	jsr $bc84			jsr 	LCLFixLineBufferCase 		; fix line case
.baff	a9 03		lda #$03			lda 	#3 							; reset the token buffer to empty
.bb01	8d 2a 04	sta $042a			sta 	tokenOffset 				; (3 bytes for line number & offset)
.bb04	9c 2b 04	stz $042b			stz 	tokenLineNumber
.bb07	9c 2c 04	stz $042c			stz 	tokenLineNumber+1
.bb0a	a2 ff		ldx #$ff			ldx 	#$FF
.bb0c					_TKFindFirst:
.bb0c	e8		inx				inx
.bb0d	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.bb10	f0 79		beq $bb8b			beq 	_TKExit
.bb12	c9 20		cmp #$20			cmp 	#' '
.bb14	90 f6		bcc $bb0c			bcc 	_TKFindFirst
.bb16	c9 30		cmp #$30			cmp 	#'0'
.bb18	90 07		bcc $bb21			bcc 	_TKNoLineNumber
.bb1a	c9 3a		cmp #$3a			cmp 	#'9'+1
.bb1c	b0 03		bcs $bb21			bcs 	_TKNoLineNumber
.bb1e	20 ae bc	jsr $bcae			jsr 	TOKExtractLineNumber
.bb21					_TKNoLineNumber:
.bb21					_TKTokeniseLoop:
.bb21	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; next character, exit if zero EOL.
.bb24	f0 65		beq $bb8b			beq 	_TKExit
.bb26	e8		inx				inx
.bb27	c9 20		cmp #$20			cmp 	#' '
.bb29	f0 f6		beq $bb21			beq 	_TKTokeniseLoop 			; keep looping if space found.
.bb2b	ca		dex				dex 								; undo last get, A contains character, X is position.
.bb2c	c9 5f		cmp #$5f			cmp 	#'_'						; _ A-Z is identifier *or* token
.bb2e	f0 61		beq $bb91			beq 	_TKTokeniseIdentifier 		; (already case converted outside string constants)
.bb30	c9 41		cmp #$41			cmp 	#'A'
.bb32	90 04		bcc $bb38			bcc 	_TKTokenisePunctuation
.bb34	c9 5b		cmp #$5b			cmp 	#'Z'+1
.bb36	90 59		bcc $bb91			bcc 	_TKTokeniseIdentifier
.bb38					_TKTokenisePunctuation:
.bb38	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.bb3a	f0 27		beq $bb63			beq 	_TKString
.bb3c	c9 24		cmp #$24			cmp 	#'$'						; hexadecimal constant ($ only appears at end of identifiers)
.bb3e	f0 28		beq $bb68			beq 	_TKHexConstant
.bb40	c9 3c		cmp #$3c			cmp 	#'<' 						; check for < > handlers - these are for <> <= >= >> <<
.bb42	f0 29		beq $bb6d			beq 	_TKCheckDouble
.bb44	c9 3e		cmp #$3e			cmp 	#'>'
.bb46	f0 25		beq $bb6d			beq 	_TKCheckDouble
.bb48					_TKStandardPunctuation:
.bb48	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get the punctuation token back.
.bb4b	c9 40		cmp #$40			cmp 	#64 						; are we >= 64
.bb4d	90 0e		bcc $bb5d			bcc 	_TKNoShift
.bb4f	48		pha				pha 								; save. we are about to convert this punctuation token from
.bb50	29 07		and #$07			and 	#7 							; lower 3 bits in zTemp0
.bb52	85 36		sta $36				sta 	zTemp0
.bb54	68		pla				pla
.bb55	29 20		and #$20			and 	#32 						; bit 5
.bb57	4a		lsr a				lsr 	a 							; shift into bit 3
.bb58	4a		lsr a				lsr 	a
.bb59	05 36		ora $36				ora 	zTemp0
.bb5b	09 10		ora #$10			ora 	#$10						; now in the range 16-31
.bb5d					_TKNoShift:
.bb5d	20 f3 bc	jsr $bcf3			jsr 	TOKWriteByte 				; write the punctuation character
.bb60	e8		inx				inx 								; consume the character
.bb61	80 be		bra $bb21			bra 	_TKTokeniseLoop 			; and loop round again.
.bb63					_TKString:
.bb63	20 13 bc	jsr $bc13			jsr 	TOKTokenString
.bb66	80 b9		bra $bb21			bra 	_TKTokeniseLoop
.bb68					_TKHexConstant:
.bb68	20 4e bc	jsr $bc4e			jsr 	TOKHexConstant
.bb6b	80 b4		bra $bb21			bra 	_TKTokeniseLoop
.bb6d					_TKCheckDouble:
.bb6d	bd 2b 05	lda $052b,x			lda 	lineBuffer+1,x 				; get next character
.bb70	c9 3c		cmp #$3c			cmp 	#'<'						; if not < = > which are ASCII consecutive go back
.bb72	90 d4		bcc $bb48			bcc 	_TKStandardPunctuation 		; and do the normal punctuation handler.
.bb74	c9 3f		cmp #$3f			cmp 	#'>'+1
.bb76	b0 d0		bcs $bb48			bcs 	_TKStandardPunctuation
.bb78	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; this is < (60) or > (62)
.bb7b	29 02		and #$02			and 	#2 							; now < (0) or > (2)
.bb7d	0a		asl a				asl 	a 							; now < (0) or > (4), CC also
.bb7e	7d 2b 05	adc $052b,x			adc 	lineBuffer+1,x 				; add < = > codes - < code
.bb81	38		sec				sec
.bb82	e9 3c		sbc #$3c			sbc 	#'<'
.bb84	20 f3 bc	jsr $bcf3			jsr 	TOKWriteByte 				; this is in the range 0-7
.bb87	e8		inx				inx 								; consume both
.bb88	e8		inx				inx
.bb89	80 96		bra $bb21			bra 	_TKTokeniseLoop
.bb8b	a9 80		lda #$80	_TKExit:lda 	#KWC_EOL 					; write end of line byte
.bb8d	20 f3 bc	jsr $bcf3			jsr 	TOKWriteByte
.bb90	60		rts				rts
.bb91					_TKTokeniseIdentifier:
.bb91	8e 00 04	stx $0400			stx 	identStart 					; save start
.bb94	9c 04 04	stz $0404			stz 	identTypeByte 				; zero the type byte
.bb97					_TKCheckLoop:
.bb97	e8		inx				inx 								; look at next, we know first is identifier already.
.bb98	bd 2a 05	lda $052a,x			lda  	lineBuffer,x
.bb9b	c9 5f		cmp #$5f			cmp 	#"_" 						; legal char _ 0-9 A-Z
.bb9d	f0 f8		beq $bb97			beq 	_TKCheckLoop
.bb9f	c9 30		cmp #$30			cmp	 	#"0"
.bba1	90 0c		bcc $bbaf			bcc 	_TKEndIdentifier
.bba3	c9 3a		cmp #$3a			cmp 	#"9"+1
.bba5	90 f0		bcc $bb97			bcc 	_TKCheckLoop
.bba7	c9 41		cmp #$41			cmp	 	#"A"
.bba9	90 04		bcc $bbaf			bcc 	_TKEndIdentifier
.bbab	c9 5b		cmp #$5b			cmp 	#"Z"+1
.bbad	90 e8		bcc $bb97			bcc 	_TKCheckLoop
.bbaf					_TKEndIdentifier:
.bbaf	8e 01 04	stx $0401			stx 	identTypeStart 				; save start of type text (if any !)
.bbb2	a0 08		ldy #$08			ldy 	#$08 						; this is the identifier type byte for #
.bbb4	c9 23		cmp #$23			cmp 	#"#"						; followed by #
.bbb6	f0 06		beq $bbbe			beq 	_TKHasTypeCharacter
.bbb8	a0 10		ldy #$10			ldy 	#$10 						; this is the identifier type byte for $
.bbba	c9 24		cmp #$24			cmp 	#"$"						; followed by $ or #
.bbbc	d0 07		bne $bbc5			bne 	_TKNoTypeCharacter
.bbbe					_TKHasTypeCharacter:
.bbbe	8c 04 04	sty $0404			sty 	identTypeByte 				; has # or $, save the type
.bbc1	e8		inx				inx 								; consume the type character
.bbc2	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.bbc5					_TKNoTypeCharacter:
.bbc5	c9 28		cmp #$28			cmp 	#"("						; is it open parenthesis (e.g. array)
.bbc7	d0 09		bne $bbd2			bne 	_TKNoArray
.bbc9	e8		inx				inx 								; skip the (
.bbca	ad 04 04	lda $0404			lda 	identTypeByte 				; set bit 2 (e.g. array) in type byte
.bbcd	09 04		ora #$04			ora 	#$04
.bbcf	8d 04 04	sta $0404			sta 	identTypeByte
.bbd2					_TKNoArray:
.bbd2	8e 02 04	stx $0402			stx 	identTypeEnd 				; save end marker, e.g. continue from here.
.bbd5	20 6f bc	jsr $bc6f			jsr 	TOKCalculateHash 			; calculate the has for those tokens
.bbd8	a0 b4		ldy #$b4			ldy 	#(KeywordSet0) >> 8
.bbda	a9 92		lda #$92			lda 	#(KeywordSet0) & $FF
.bbdc	20 a3 ba	jsr $baa3			jsr 	TOKSearchTable
.bbdf	a2 00		ldx #$00			ldx 	#0
.bbe1	b0 1f		bcs $bc02			bcs 	_TKFoundToken
.bbe3	a0 b6		ldy #$b6			ldy 	#(KeywordSet1) >> 8
.bbe5	a9 a9		lda #$a9			lda 	#(KeywordSet1) & $FF
.bbe7	20 a3 ba	jsr $baa3			jsr 	TOKSearchTable
.bbea	a2 81		ldx #$81			ldx 	#$81
.bbec	b0 14		bcs $bc02			bcs 	_TKFoundToken
.bbee	a0 b7		ldy #$b7			ldy 	#(KeywordSet2) >> 8
.bbf0	a9 1c		lda #$1c			lda 	#(KeywordSet2) & $FF
.bbf2	20 a3 ba	jsr $baa3			jsr 	TOKSearchTable
.bbf5	a2 82		ldx #$82			ldx 	#$82
.bbf7	b0 09		bcs $bc02			bcs 	_TKFoundToken
.bbf9	20 ff bc	jsr $bcff			jsr 	TOKCheckCreateVariableRecord ; failed all, it's a variable, create record if does not exist.
.bbfc	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.bbff	4c 21 bb	jmp $bb21			jmp 	_TKTokeniseLoop 			; and go round again.
.bc02					_TKFoundToken:
.bc02	48		pha				pha 								; save token
.bc03	8a		txa				txa 								; shift in X, is there one ?
.bc04	f0 03		beq $bc09			beq 	_TKNoTShift
.bc06	20 f3 bc	jsr $bcf3			jsr 	TOKWriteByte 				; if so, write it out
.bc09					_TKNoTShift:
.bc09	68		pla				pla 								; restore and write token
.bc0a	20 f3 bc	jsr $bcf3			jsr 	TOKWriteByte
.bc0d	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.bc10	4c 21 bb	jmp $bb21			jmp 	_TKTokeniseLoop 			; and go round again.
.bc13					TOKTokenString:
.bc13	a9 ff		lda #$ff			lda 	#KWC_STRING 				; string token.
.bc15	20 f3 bc	jsr $bcf3			jsr 	TOKWriteByte
.bc18	e8		inx				inx									; start of quoted string.
.bc19	da		phx				phx 								; push start of string on top
.bc1a	ca		dex				dex 								; because we pre-increment
.bc1b					_TSFindEnd:
.bc1b	e8		inx				inx
.bc1c	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; next character
.bc1f	f0 04		beq $bc25			beq 	_TSEndOfString 				; no matching quote, we don't mind.
.bc21	c9 22		cmp #$22			cmp 	#'"' 						; go back if quote not found
.bc23	d0 f6		bne $bc1b			bne 	_TSFindEnd
.bc25					_TSEndOfString:
.bc25	7a		ply				ply  								; so now Y is first character, X is character after end.
.bc26	48		pha				pha 								; save terminating character
.bc27	20 2f bc	jsr $bc2f			jsr 	TOKWriteBlockXY 			; write X to Y as a data block
.bc2a	68		pla				pla 								; terminating character
.bc2b	f0 01		beq $bc2e			beq 	_TSNotQuote					; if it wasn't EOS skip it
.bc2d	e8		inx				inx
.bc2e					_TSNotQuote:
.bc2e	60		rts				rts
.bc2f					TOKWriteBlockXY:
.bc2f	86 36		stx $36				stx 	zTemp0 						; save end character
.bc31	98		tya				tya 								; use 2's complement to work out the byte size
.bc32	49 ff		eor #$ff			eor 	#$FF
.bc34	38		sec				sec
.bc35	65 36		adc $36				adc 	zTemp0
.bc37	1a		inc a				inc 	a 							; one extra for NULL
.bc38	20 f3 bc	jsr $bcf3			jsr 	TOKWriteByte
.bc3b					_TOBlockLoop:
.bc3b	c4 36		cpy $36				cpy 	zTemp0 						; exit if reached the end
.bc3d	f0 09		beq $bc48			beq 	_TOBlockExit
.bc3f	b9 2a 05	lda $052a,y			lda 	lineBuffer,y 				; write byte out.
.bc42	20 f3 bc	jsr $bcf3			jsr 	TOKWriteByte
.bc45	c8		iny				iny
.bc46	80 f3		bra $bc3b			bra 	_TOBlockLoop
.bc48					_TOBlockExit:
.bc48	a9 00		lda #$00			lda 	#0 							; add NULL.
.bc4a	20 f3 bc	jsr $bcf3			jsr 	TOKWriteByte
.bc4d	60		rts				rts
.bc4e					TOKHexConstant:
.bc4e	a9 fe		lda #$fe			lda 	#KWC_HEXCONST 				; hex constant token.
.bc50	20 f3 bc	jsr $bcf3			jsr 	TOKWriteByte
.bc53	e8		inx				inx									; start of quoted string.
.bc54	da		phx				phx 								; push start of constant on top
.bc55	ca		dex				dex
.bc56					_THFindLoop:
.bc56	e8		inx				inx 	 							; this is stored in a block, so find out how long
.bc57	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; the hex constant is.
.bc5a	c9 30		cmp #$30			cmp 	#"0"
.bc5c	90 0c		bcc $bc6a			bcc 	_THFoundEnd
.bc5e	c9 3a		cmp #$3a			cmp 	#"9"+1
.bc60	90 f4		bcc $bc56			bcc 	_THFindLoop
.bc62	c9 41		cmp #$41			cmp 	#"A"
.bc64	90 04		bcc $bc6a			bcc 	_THFoundEnd
.bc66	c9 47		cmp #$47			cmp 	#"F"+1
.bc68	90 ec		bcc $bc56			bcc 	_THFindLoop
.bc6a					_THFoundEnd:
.bc6a	7a		ply				ply 								; restore start
.bc6b	20 2f bc	jsr $bc2f			jsr 	TOKWriteBlockXY 			; output the block
.bc6e	60		rts				rts
.bc6f					TOKCalculateHash:
.bc6f	da		phx				phx
.bc70	ae 00 04	ldx $0400			ldx 	identStart 					; needs to be same as in tokens.py - simple sum at present.
.bc73	a9 00		lda #$00			lda 	#0
.bc75					_TCHLoop:
.bc75	18		clc				clc
.bc76	7d 2a 05	adc $052a,x			adc 	lineBuffer,x
.bc79	e8		inx				inx
.bc7a	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; do the whole thing including type and array markers.
.bc7d	d0 f6		bne $bc75			bne 	_TCHLoop
.bc7f	8d 03 04	sta $0403			sta 	identHash 					; save the hash
.bc82	fa		plx				plx
.bc83	60		rts				rts
.bc84					LCLFixLineBufferCase:
.bc84	a2 00		ldx #$00			ldx 	#0
.bc86					_FLBCLoop:
.bc86	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get next character
.bc89	f0 22		beq $bcad			beq 	_FLBCExit 					; end of string.
.bc8b	c9 22		cmp #$22			cmp 	#'"'						; quote, go to in quotes
.bc8d	f0 11		beq $bca0			beq 	_FLBCInQuotes
.bc8f	e8		inx				inx
.bc90	c9 61		cmp #$61			cmp 	#'a'						; needs capitalising ?
.bc92	90 f2		bcc $bc86			bcc 	_FLBCLoop
.bc94	c9 7b		cmp #$7b			cmp 	#'z'+1
.bc96	b0 ee		bcs $bc86			bcs 	_FLBCLoop
.bc98	38		sec				sec 								; make U/C
.bc99	e9 20		sbc #$20			sbc 	#32
.bc9b	9d 29 05	sta $0529,x			sta	 	lineBuffer-1,x 				; write back
.bc9e	80 e6		bra $bc86			bra 	_FLBCLoop
.bca0					_FLBCInQuotes:
.bca0	e8		inx				inx 								; advance
.bca1	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get next
.bca4	f0 07		beq $bcad			beq 	_FLBCExit 					; exit on EOS
.bca6	c9 22		cmp #$22			cmp 	#'"' 				 		; until " found
.bca8	d0 f6		bne $bca0			bne 	_FLBCInQuotes
.bcaa	e8		inx				inx 								; skip over it
.bcab	80 d9		bra $bc86			bra 	_FLBCLoop
.bcad					_FLBCExit:
.bcad	60		rts				rts
.bcae					TOKExtractLineNumber:
.bcae	ad 2c 04	lda $042c			lda 	tokenLineNumber+1 			; push current value on stack
.bcb1	48		pha				pha
.bcb2	ad 2b 04	lda $042b			lda 	tokenLineNumber
.bcb5	48		pha				pha
.bcb6	20 ec bc	jsr $bcec			jsr 	_LCLNTimes2 				; line # x 2
.bcb9	20 ec bc	jsr $bcec			jsr 	_LCLNTimes2 				; line # x 4
.bcbc	18		clc				clc 								; add stacked value
.bcbd	68		pla				pla
.bcbe	6d 2b 04	adc $042b			adc 	tokenLineNumber
.bcc1	8d 2b 04	sta $042b			sta 	tokenLineNumber
.bcc4	68		pla				pla
.bcc5	6d 2c 04	adc $042c			adc 	tokenLineNumber+1
.bcc8	8d 2c 04	sta $042c			sta 	tokenLineNumber+1 			; line # x 5
.bccb	20 ec bc	jsr $bcec			jsr 	_LCLNTimes2 				; line # x 10
.bcce	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get and consume character
.bcd1	e8		inx				inx
.bcd2	29 0f		and #$0f			and 	#15 						; add to line #
.bcd4	18		clc				clc
.bcd5	6d 2b 04	adc $042b			adc 	tokenLineNumber
.bcd8	8d 2b 04	sta $042b			sta 	tokenLineNumber
.bcdb	90 03		bcc $bce0			bcc 	_TLENNoCarry
.bcdd	ee 2c 04	inc $042c			inc 	tokenLineNumber+1
.bce0					_TLENNoCarry:
.bce0	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; more digits ?
.bce3	c9 30		cmp #$30			cmp 	#'0'
.bce5	90 04		bcc $bceb			bcc 	_TLENExit
.bce7	c9 3a		cmp #$3a			cmp 	#'9'+1
.bce9	90 c3		bcc $bcae			bcc 	TOKExtractLineNumber
.bceb					_TLENExit:
.bceb	60		rts				rts
.bcec					_LCLNTimes2:
.bcec	0e 2b 04	asl $042b			asl 	tokenLineNumber 			; doubles tokenLineNumber.
.bcef	2e 2c 04	rol $042c			rol 	tokenLineNumber+1
.bcf2	60		rts				rts
.bcf3					TOKWriteByte:
.bcf3	da		phx				phx
.bcf4	ae 2a 04	ldx $042a			ldx 	tokenOffset 				; next slot to write to
.bcf7	9d 2a 04	sta $042a,x			sta 	tokenOffset,x 				; write byte out
.bcfa	ee 2a 04	inc $042a			inc 	tokenOffset 				; advance slot.
.bcfd	fa		plx				plx
.bcfe	60		rts				rts
.bcff					TOKCheckCreateVariableRecord:
.bcff	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.bd01	85 36		sta $36				sta 	0+zTemp0
.bd03	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.bd05	85 37		sta $37				sta 	1+zTemp0
.bd07					_CCVSearch:
.bd07	b2 36		lda ($36)			lda 	(zTemp0) 					; end of list
.bd09	f0 2c		beq $bd37			beq 	_CCVFail
.bd0b	a0 01		ldy #$01			ldy 	#1 							; read the hash
.bd0d	b1 36		lda ($36),y			lda 	(zTemp0),y 					; does it match ?
.bd0f	cd 03 04	cmp $0403			cmp 	identHash 	  				; if not, try the next.
.bd12	d0 16		bne $bd2a			bne 	_CCVNext
.bd14	a0 08		ldy #$08			ldy 	#8 							; name in variable record
.bd16	ae 00 04	ldx $0400			ldx 	identStart
.bd19					_CCVCompare:
.bd19	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; xor them. zero if the same, except
.bd1c	51 36		eor ($36),y			eor 	(zTemp0),y 					; bit 7 is used for EOS.
.bd1e	e8		inx				inx 								; advance pointers
.bd1f	c8		iny				iny
.bd20	0a		asl a				asl 	a 							; A = 0 if they match, CS if end.
.bd21	d0 07		bne $bd2a			bne 	_CCVNext  					; didn't match go to next.
.bd23	90 f4		bcc $bd19			bcc 	_CCVCompare 				; not finished yet.
.bd25	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; matched whole thing ?
.bd28	f0 41		beq $bd6b			beq 	_CCVFound 					; yes, we were successful
.bd2a					_CCVNext:
.bd2a	18		clc				clc 								; go to next record.
.bd2b	b2 36		lda ($36)			lda 	(zTemp0) 					; add offset to pointer
.bd2d	65 36		adc $36				adc 	zTemp0
.bd2f	85 36		sta $36				sta 	zTemp0
.bd31	90 d4		bcc $bd07			bcc 	_CCVSearch
.bd33	e6 37		inc $37				inc 	zTemp0+1
.bd35	80 d0		bra $bd07			bra 	_CCVSearch
.bd37					_CCVFail:
.bd37	a0 01		ldy #$01			ldy 	#1 							; create the new record. Offset 1 is hash
.bd39	ad 03 04	lda $0403			lda 	identHash
.bd3c	91 36		sta ($36),y			sta 	(zTemp0),y
.bd3e	c8		iny				iny 								; offset 2 is the type byte
.bd3f	ad 04 04	lda $0404			lda 	identTypeByte
.bd42	91 36		sta ($36),y			sta 	(zTemp0),y
.bd44	c8		iny				iny
.bd45					_CCVData:
.bd45	a9 00		lda #$00			lda 	#0 							; erase data 3-7 (the 5 value bytes)
.bd47	91 36		sta ($36),y			sta 	(zTemp0),y
.bd49	c8		iny				iny
.bd4a	c0 08		cpy #$08			cpy 	#8
.bd4c	90 f7		bcc $bd45			bcc 	_CCVData
.bd4e	ae 00 04	ldx $0400			ldx 	identStart 					; copy name into 8 on.
.bd51					_CCVCopyName:
.bd51	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.bd54	91 36		sta ($36),y			sta 	(zTemp0),y
.bd56	e8		inx				inx
.bd57	c8		iny				iny
.bd58	ec 02 04	cpx $0402			cpx 	identTypeEnd
.bd5b	d0 f4		bne $bd51			bne 	_CCVCopyName
.bd5d	98		tya				tya 								; patch offset
.bd5e	92 36		sta ($36)			sta 	(zTemp0)
.bd60	a9 00		lda #$00			lda 	#0 							; offset for next is zero.
.bd62	91 36		sta ($36),y			sta 	(zTemp0),y
.bd64	88		dey				dey
.bd65	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set bit 7 of last bit
.bd67	09 80		ora #$80			ora 	#$80
.bd69	91 36		sta ($36),y			sta 	(zTemp0),y
.bd6b					_CCVFound:
.bd6b	a5 37		lda $37				lda 	zTemp0+1 					; write out MSB
.bd6d	38		sec				sec
.bd6e	e9 10		sbc #$10			sbc 	#(VariableSpace >> 8) 		; offset from the start of the variable token
.bd70	09 40		ora #$40			ora 	#$40 						; make it a writeable token $4000-$7FFF
.bd72	20 f3 bc	jsr $bcf3			jsr 	TOKWriteByte
.bd75	a5 36		lda $36				lda 	zTemp0 						; write out LSB
.bd77	20 f3 bc	jsr $bcf3			jsr 	TOKWriteByte
.bd7a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_sound.module

=1					soundIntegrated=1
.bd7b					SNDCheckChannel:
.bd7b	aa		tax				tax
.bd7c	bd 38 08	lda $0838,x			lda 	SNDTimeLeft,x 				; currently playing a note
.bd7f	d0 38		bne $bdb9			bne 	_SNDCCExit
.bd81	da		phx				phx 								; save current channel
.bd82	8a		txa				txa 								; put in A
.bd83	20 ff bd	jsr $bdff			jsr 	SNDFindNextNoteForA 		; is there a note for A in the queue ?
.bd86	68		pla				pla 								; channel # in A
.bd87	90 30		bcc $bdb9			bcc 	_SNDCCExit  				; nothing in the queue for this channel, exit.
.bd89	a8		tay				tay 								; Y is the channel #
.bd8a	bd 2d 07	lda $072d,x			lda 	SNDQueue+1,x 				; copy data into the slot.
.bd8d	99 2c 08	sta $082c,y			sta 	SNDPitchLow,y
.bd90	bd 2e 07	lda $072e,x			lda 	SNDQueue+2,x
.bd93	99 30 08	sta $0830,y			sta 	SNDPitchHigh,y
.bd96	bd 2f 07	lda $072f,x			lda 	SNDQueue+3,x
.bd99	99 34 08	sta $0834,y			sta 	SNDVolume,y
.bd9c	bd 30 07	lda $0730,x			lda 	SNDQueue+4,x
.bd9f	99 38 08	sta $0838,y			sta 	SNDTimeLeft,y
.bda2	bd 31 07	lda $0731,x			lda 	SNDQueue+5,x
.bda5	99 3c 08	sta $083c,y			sta 	SNDAdjustLow,y
.bda8	bd 32 07	lda $0732,x			lda 	SNDQueue+6,x
.bdab	99 40 08	sta $0840,y			sta 	SNDAdjustHigh,y
.bdae	5a		phy				phy 								; save channel #
.bdaf	20 19 be	jsr $be19			jsr 	SNDDeleteXFromQueue 		; delete record at X from queue
.bdb2	ce 2b 07	dec $072b			dec 	SNDLength 					; reduce the queue length.
.bdb5	68		pla				pla
.bdb6	20 ba bd	jsr $bdba			jsr 	SNDUpdateNote 				; update channel A
.bdb9					_SNDCCExit:
.bdb9	60		rts				rts
.bdba					SNDUpdateNote:
.bdba	aa		tax				tax 								; so we can access records
.bdbb	0a		asl a				asl 	a 							; convert it to a channel bit pair in 5,6
.bdbc	0a		asl a				asl 	a
.bdbd	0a		asl a				asl 	a
.bdbe	0a		asl a				asl 	a
.bdbf	0a		asl a				asl 	a
.bdc0	8d 2a 07	sta $072a			sta 	SNDChannelBits
.bdc3	bd 38 08	lda $0838,x			lda 	SNDTimeLeft,x 				; are we silent
.bdc6	f0 2e		beq $bdf6			beq 	_SNDUNIsSilent
.bdc8	ad 2a 07	lda $072a			lda 	SNDChannelBits 				; push channel bits on stack
.bdcb	48		pha				pha
.bdcc	bd 2c 08	lda $082c,x			lda 	SNDPitchLow,x 				; get 4 lowest bits of pitch.
.bdcf	29 0f		and #$0f			and 	#$0F
.bdd1	0d 2a 07	ora $072a			ora 	SNDChannelBits 				; set channel bits
.bdd4	09 80		ora #$80			ora 	#$80 						; write to pitch register
.bdd6	20 63 be	jsr $be63			jsr 	SNDWritePorts
.bdd9	bd 30 08	lda $0830,x			lda 	SNDPitchHigh,x 				; pitch high => channel temp.
.bddc	8d 2a 07	sta $072a			sta 	SNDChannelBits
.bddf	bd 2c 08	lda $082c,x			lda 	SNDPitchLow,x
.bde2	4e 2a 07	lsr $072a			lsr 	SNDChannelBits 				; shift 2 LSBs into MSB of A
.bde5	6a		ror a				ror 	a
.bde6	4e 2a 07	lsr $072a			lsr 	SNDChannelBits
.bde9	6a		ror a				ror 	a
.bdea	4a		lsr a				lsr 	a 							; put in bits 0-5
.bdeb	4a		lsr a				lsr 	a
.bdec	20 63 be	jsr $be63			jsr 	SNDWritePorts 				; write as rest of pitch register
.bdef	68		pla				pla
.bdf0	09 90		ora #$90			ora 	#$90 						; set to write minimum attentuation.
.bdf2	20 63 be	jsr $be63			jsr 	SNDWritePorts
.bdf5	60		rts				rts
.bdf6					_SNDUNIsSilent:
.bdf6	ad 2a 07	lda $072a			lda 	SNDChannelBits 				; channel bits
.bdf9	09 9f		ora #$9f			ora 	#$9F 						; maximum attenuation
.bdfb	20 63 be	jsr $be63			jsr 	SNDWritePorts 				; write to the ports
.bdfe	60		rts				rts
.bdff					SNDFindNextNoteForA:
.bdff	ac 2b 07	ldy $072b			ldy 	SNDLength 					; queue size into Y
.be02	f0 13		beq $be17			beq 	_SNDFNNFail 				; queue empty.
.be04	a2 00		ldx #$00			ldx 	#0
.be06					_SNDFNNSearch:
.be06	dd 2c 07	cmp $072c,x			cmp 	SNDQueue,x 					; does it match the channel
.be09	38		sec				sec
.be0a	f0 0c		beq $be18			beq 	_SNDFNNExit 				; if so exit with CS.
.be0c	e8		inx				inx 								; next queue slot.
.be0d	e8		inx				inx
.be0e	e8		inx				inx
.be0f	e8		inx				inx
.be10	e8		inx				inx
.be11	e8		inx				inx
.be12	e8		inx				inx
.be13	e8		inx				inx
.be14	88		dey				dey 								; done the whole queue
.be15	d0 ef		bne $be06			bne 	_SNDFNNSearch 				; no, go back.
.be17					_SNDFNNFail:
.be17	18		clc				clc
.be18					_SNDFNNexit:
.be18	60		rts				rts
.be19					SNDDeleteXFromQueue:
.be19	e0 f8		cpx #$f8			cpx 	#SNDQueueSize*8-8 			; reached the end.
.be1b	f0 09		beq $be26			beq 	_SNDDXExit
.be1d	bd 34 07	lda $0734,x			lda 	SNDQueue+8,x
.be20	9d 2c 07	sta $072c,x			sta 	SNDQueue,x
.be23	e8		inx				inx
.be24	80 f3		bra $be19			bra 	SNDDeleteXFromQueue
.be26					_SNDDXExit:
.be26	60		rts				rts
.072a					SNDChannelBits:
>072a							.fill 	1
.be27					SNDQueueRequest:
.be27	86 36		stx $36				stx 	zTemp0						; save queue address
.be29	84 37		sty $37				sty 	zTemp0+1
.be2b	ae 2b 07	ldx $072b			ldx 	SNDLength 					; queue is full, can't take any more.
.be2e	e0 20		cpx #$20			cpx 	#SNDQueueSize
.be30	f0 21		beq $be53			beq 	_SNDQRExit
.be32	29 03		and #$03			and 	#3	 						; channel # and push on stack
.be34	48		pha				pha
.be35	8a		txa				txa  								; get offset in queue buffer/
.be36	0a		asl a				asl 	a
.be37	0a		asl a				asl 	a
.be38	0a		asl a				asl 	a
.be39	aa		tax				tax
.be3a	68		pla				pla 								; get back and push again
.be3b	48		pha				pha
.be3c	9d 2c 07	sta $072c,x			sta 	SNDQueue+0,x 				; save the channel #
.be3f	a0 00		ldy #$00			ldy 	#0 							; copy the rest in.
.be41					_SNDQCopy:
.be41	b1 36		lda ($36),y			lda 	(zTemp0),y
.be43	e8		inx				inx
.be44	c8		iny				iny
.be45	9d 2c 07	sta $072c,x			sta 	SNDQueue,x
.be48	c0 06		cpy #$06			cpy 	#6
.be4a	d0 f5		bne $be41			bne 	_SNDQCopy
.be4c	ee 2b 07	inc $072b			inc 	SNDLength 					; bump queue length.
.be4f	68		pla				pla 								; get channel # back
.be50	20 7b bd	jsr $bd7b			jsr 	SNDCheckChannel 			; check if channel needs refreshing.
.be53					_SNDQRExit:
.be53	60		rts				rts
.be54					SNDSilenceChannel:
.be54	aa		tax				tax 								; zero time left.
.be55	9e 38 08	stz $0838,x			stz 	SNDTimeLeft,x
.be58	0a		asl a				asl 	a 							; shift into position
.be59	0a		asl a				asl 	a
.be5a	0a		asl a				asl 	a
.be5b	0a		asl a				asl 	a
.be5c	0a		asl a				asl 	a
.be5d	09 9f		ora #$9f			ora 	#$9F 						; write register attenuation $F
.be5f	20 63 be	jsr $be63			jsr 	SNDWritePorts
.be62	60		rts				rts
.be63					SNDWritePorts:
.be63	da		phx				phx 								; save X
.be64	a6 01		ldx $01				ldx 	1 							; save I/O status
.be66	64 01		stz $01				stz 	1 							; access I/O page 0
.be68	8d 00 d6	sta $d600			sta 	$D600 						; write to both
.be6b	8d 10 d6	sta $d610			sta 	$D610
.be6e	86 01		stx $01				stx 	1 							; restore I/O
.be70	fa		plx				plx 								; restore X
.be71	60		rts				rts
.be72					Export_SNDCommand:
.be72	da		phx				phx 								; save XY
.be73	5a		phy				phy
.be74	c9 0f		cmp #$0f			cmp 	#$0F 						; $0F is initialise
.be76	f0 1d		beq $be95			beq 	_SNDInitialise
.be78	90 28		bcc $bea2			bcc 	_SNDExit
.be7a	c9 3f		cmp #$3f			cmp 	#$3F 						; $3F is silence all
.be7c	f0 17		beq $be95			beq 	_SNDSilence
.be7e	b0 22		bcs $bea2			bcs 	_SNDExit
.be80	c9 20		cmp #$20			cmp 	#$20 						; $2x is check playing => A
.be82	b0 09		bcs $be8d			bcs 	_SNDQueryPlay
.be84	c9 14		cmp #$14			cmp 	#$14 						; $10-$13 is queue sound
.be86	b0 1a		bcs $bea2			bcs 	_SNDExit
.be88	20 27 be	jsr $be27			jsr 	SNDQueueRequest
.be8b	80 15		bra $bea2			bra 	_SNDExit
.be8d					_SNDQueryPlay:
.be8d	29 03		and #$03			and 	#3 							; get channel #
.be8f	aa		tax				tax
.be90	bd 38 08	lda $0838,x			lda 	SNDTimeLeft,x 				; read time left, if zero then silent
.be93	80 0d		bra $bea2			bra 	_SNDExit
.be95					_SNDInitialise:
.be95					_SNDSilence:
.be95	9c 2b 07	stz $072b			stz 	SNDLength 					; empty the queue.
.be98	a9 03		lda #$03			lda 	#$3 						; silence channel 0-3.
.be9a					_SNDSilenceLoop:
.be9a	48		pha				pha
.be9b	20 54 be	jsr $be54			jsr 	SNDSilenceChannel
.be9e	68		pla				pla
.be9f	3a		dec a				dec 	a
.bea0	10 f8		bpl $be9a			bpl 	_SNDSilenceLoop
.bea2					_SNDExit:
.bea2	7a		ply				ply
.bea3	fa		plx				plx
.bea4	60		rts				rts
=32					SNDQueueSize = 32 							; number of queue entries
.072b					SNDLength:
>072b							.fill 	1
.072c					SNDQueue:
>072c							.fill 	SNDQueueSize * 8
.082c					SNDPitchLow:
>082c							.fill 	4
.0830					SNDPitchHigh:
>0830							.fill 	4
.0834					SNDVolume:
>0834							.fill 	4
.0838					SNDTimeLeft:
>0838							.fill 	4
.083c					SNDAdjustLow:
>083c							.fill 	4
.0840					SNDAdjustHigh:
>0840							.fill 	4
.bea5					Export_SNDUpdate:
.bea5					PagedSNDUpdate:
.bea5	ad 38 08	lda $0838			lda 	SNDTimeLeft+0 				; look at time remaining
.bea8	f0 05		beq $beaf			beq 	_SNDUNot0 					; not playing
.beaa	a2 00		ldx #$00			ldx 	#0 							; so we know which channel to update
.beac	20 ce be	jsr $bece			jsr 	SNDUpdateChannel 			; update it.
.beaf					_SNDUNot0:
.beaf	ad 39 08	lda $0839			lda 	SNDTimeLeft+1
.beb2	f0 05		beq $beb9			beq 	_SNDUNot1
.beb4	a2 01		ldx #$01			ldx 	#1
.beb6	20 ce be	jsr $bece			jsr 	SNDUpdateChannel
.beb9					_SNDUNot1:
.beb9	ad 3a 08	lda $083a			lda 	SNDTimeLeft+2
.bebc	f0 05		beq $bec3			beq 	_SNDUNot2
.bebe	a2 02		ldx #$02			ldx 	#2
.bec0	20 ce be	jsr $bece			jsr 	SNDUpdateChannel
.bec3					_SNDUNot2:
.bec3	ad 3b 08	lda $083b			lda 	SNDTimeLeft+3
.bec6	f0 05		beq $becd			beq 	_SNDUNot3
.bec8	a2 03		ldx #$03			ldx 	#3
.beca	20 ce be	jsr $bece			jsr 	SNDUpdateChannel
.becd					_SNDUNot3:
.becd	60		rts				rts
.bece					SNDUpdateChannel:
.bece	c9 ff		cmp #$ff			cmp 	#$FF 						; sound $FF play forever until turned off manually
.bed0	f0 2c		beq $befe			beq 	_SNDUCExit
.bed2	3a		dec a				dec 	a 							; decrement and update timer
.bed3	9d 38 08	sta $0838,x			sta 	SNDTimeLeft,x
.bed6	f0 1d		beq $bef5			beq 	_SNDUCUpdate 				; if zero, silence channel
.bed8	bd 3c 08	lda $083c,x			lda 	SNDAdjustLow,x 				; adjust ?
.bedb	1d 40 08	ora $0840,x			ora 	SNDAdjustHigh,x
.bede	f0 1e		beq $befe			beq 	_SNDUCExit 					; if zero carry on at current tone.
.bee0	18		clc				clc 								; add adjust, forcing into a 10 bit range
.bee1	bd 2c 08	lda $082c,x			lda 	SNDPitchLow,x
.bee4	7d 3c 08	adc $083c,x			adc 	SNDAdjustLow,x
.bee7	9d 2c 08	sta $082c,x			sta 	SNDPitchLow,x
.beea	bd 30 08	lda $0830,x			lda 	SNDPitchHigh,x
.beed	7d 40 08	adc $0840,x			adc 	SNDAdjustHigh,x
.bef0	29 03		and #$03			and 	#3
.bef2	9d 30 08	sta $0830,x			sta 	SNDPitchHigh,x
.bef5					_SNDUCUpdate:
.bef5	8a		txa				txa 								; which channel.
.bef6	48		pha				pha
.bef7	20 ba bd	jsr $bdba			jsr 	SNDUpdateNote 				; update the current note
.befa	68		pla				pla
.befb	20 7b bd	jsr $bd7b			jsr 	SNDCheckChannel 			; more to do ?
.befe					_SNDUCExit:
.befe	60		rts				rts

;******  Return to file: _basic.asm


;******  End of listing
