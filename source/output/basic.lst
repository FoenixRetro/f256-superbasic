
; 64tass Turbo Assembler Macro V1.57.2900 listing file
; 64tass -D AUTORUN=1 "-D MONITOR_ADDRESS=\$E000" "-D LOCKOUT_ADDRESS=\$F000" "-D BASIC_ADDRESS=\$38000" "-D SOURCE_ADDRESS=\$3000" "-D SPRITE_ADDRESS=\$30000" -q -b -Wall -c -D "HARDWARE=0 $'\x9'$'\x9'$'\x9'$'\x9'$'\x9'$'\x9'" -L output/basic.lst -l output/basic.lbl -Wall -o basic.rom _basic.asm
; Tue Nov 22 09:32:39 2022

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=1					AUTORUN=1
=$e000					 MONITOR_ADDRESS=$E000
=$f000					 LOCKOUT_ADDRESS=$F000
=$38000					 BASIC_ADDRESS=$38000
=$3000					 SOURCE_ADDRESS=$3000
=$30000					 SPRITE_ADDRESS=$30000
=0					HARDWARE=0

;******  Processing input file: _basic.asm


;******  Processing file: ./common/aa.system/01common.inc

=$30					ZeroPageMandatory = $30
=$400					ZeroPagePreference = $400
=$480					MemoryStorage = $480
=$2000					BasicStart = $2000
=$8000					BasicEnd = $8000
=$8000					CodeStart = $8000
=$1000					VariableSpace = $1000
=$2000					EndVariableSpace = $2000
=8					MathStackSize = 8
=512					BasicStackSize = 512
=3584					BasicStackBase = $1000-BasicStackSize
=80					MaxLineSize = 80

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/02macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/04data.inc

.0030					codePtr:
>0030							.fill 	4
.0034					basicStack:
>0034							.fill 	2
.0036					zTemp0:
>0036							.fill 	2
.0038					zTemp1:
>0038							.fill 	2
.003a					zTemp2:
>003a							.fill 	2
.003c					zsTemp:
>003c							.fill 	2
.003e					zaTemp:
>003e							.fill 	2
=$30					safePtr = codePtr 							; minimise direct tinkering
=$80					NSBIsNegative = $80 						; bit 7 : sign of mantissa (where numeric)
=$20					NSBIsReference = $20 						; bit 5 : is a reference
=$10					NSBIsString = $10 							; bit 4 : set if string (procedures don't go on the stack)
=$18					NSBTypeMask = $18 							; bits 4,3 : 00 int 01 float 10 string 11 procedure
=$03					NSBRefMask = $03 							; bits 0,1 : Bytes of reference, -1 (e.g. 00 = 1 byte, 11 = 4 bytes)
=$04					NSBIsArray = $04
=$00					NSTInteger = $00 							; base types for bits 3..4
=$08					NSTFloat = $08
=$10					NSTString = $10
=$18					NSTProcedure = $18
.0400					NSStatus:
>0400							.fill 	MathStackSize
.0408					NSMantissa0:
>0408							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0410					NSMantissa1:
>0410							.fill 	MathStackSize
.0418					NSMantissa2:
>0418							.fill 	MathStackSize
.0420					NSMantissa3:
>0420							.fill 	MathStackSize
.0428					NSExponent:
>0428							.fill 	MathStackSize
.0480					identStart:
>0480							.fill 	1
.0481					identTypeStart:
>0481							.fill 	1
.0482					identTypeEnd:
>0482							.fill 	1
.0483					identHash:
>0483							.fill 	1
.0484					identTypeByte:
>0484							.fill 	1	 						; (see tokenising.pdf)
.0485					encodeState:
>0485							.fill 	1
.0486					digitTemp:
>0486							.fill 	1
.0487					decimalCount:
>0487							.fill 	1
.0488					randomSeed:
>0488							.fill 	4
.048c					lowMemPtr:
>048c							.fill 	2
.048e					stringMemory:
>048e							.fill 	2
.0490					stringInitialised:
>0490							.fill 	1
.0491					stringTempPointer:
>0491							.fill 	2
.0493					breakCheck:
>0493							.fill 	1
.0494					decimalPlaces:
>0494							.fill 	1
.0495					dbOffset:
>0495							.fill 	1
.0496					lastParameter:
>0496							.fill 	1
.0497					dataPointer:
>0497							.fill 	5
.049c					inDataStatement:
>049c							.fill 	1
.049d					tbOffset:
>049d							.fill 	1
.049e					AssemblerAddress:
>049e							.fill 	2
.04a0					AssemblerControl:
>04a0							.fill 	1
.04a1					ParamStart:
>04a1							.fill 	2
.04a3					IsGroup1:
>04a3							.fill 	1
.04a4					BaseOpcode:
>04a4							.fill 	1
.04a5					ModeMask:
>04a5							.fill 	1
.04a6					listIndent:
>04a6							.fill 	1
.04a7					lcLastCharacter:
>04a7							.fill 	1
.04a8					tokenOffset:
>04a8							.fill 	1
.04a9					tokenLineNumber:
>04a9							.fill 	2
.04ab					tokenBuffer:
>04ab							.fill 	253
.05a8					lineBuffer:
>05a8							.fill 	MaxLineSize+1
.05f9					numberBuffer:
>05f9							.fill 	34
.061b					decimalBuffer:
>061b							.fill 	16

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/constants.inc

=$80					AM_ISZP = $80
=$40					AM_ISG1 = $40
=$20					AM_ISG2 = $20
=224					AM_IMMEDIATE = AM_ISZP+AM_ISG1+AM_ISG2+$00
=228					AM_ZEROPAGE = AM_ISZP+AM_ISG1+AM_ISG2+$04
=40					AM_ACC = AM_ISG2+$08
=108					AM_ABS = AM_ISG1+AM_ISG2+$0C
=208					AM_INDY = AM_ISZP+AM_ISG1+$10
=244					AM_ZEROX = AM_ISZP+AM_ISG1+AM_ISG2+$14
=120					AM_ABSY = AM_ISG1+AM_ISG2+$18
=124					AM_ABSX = AM_ISG1+AM_ISG2+$1C
=209					AM_IND = AM_ISZP+AM_ISG1+$11
=$80					AM_ZEROY = AM_ISZP
=$01					AM_INDABS = $01
=$02					AM_INDABSX = $02
=192					AM_INDX = AM_ISZP+AM_ISG1+$00

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/handlers.inc


;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.inc

=1					ERRID_BREAK = 1
=2					ERRID_SYNTAX = 2
=3					ERRID_DIVZERO = 3
=4					ERRID_RANGE = 4
=5					ERRID_TYPE = 5
=6					ERRID_MEMORY = 6
=7					ERRID_ARGUMENT = 7
=8					ERRID_STOP = 8
=9					ERRID_STRING = 9
=10					ERRID_ASSERT = 10
=11					ERRID_DATA = 11
=12					ERRID_NOTDONE = 12
=13					ERRID_LINE = 13
=14					ERRID_GOSUB = 14
=15					ERRID_REPEAT = 15
=16					ERRID_WHILE = 16
=17					ERRID_FOR = 17
=18					ERRID_STACK = 18
=19					ERRID_STRUCT = 19
=20					ERRID_PROC = 20
=21					ERRID_REDEFINE = 21
=22					ERRID_ARRAYSIZE = 22
=23					ERRID_ARRAYIDX = 23

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst.inc

=$00					KWD_LESSLESS                         = $00; $00 <<
=$01					KWD_LESSEQUAL                        = $01; $01 <=
=$02					KWD_LESSGREATER                      = $02; $02 <>
=$03					KWD_PLINGPLING3                      = $03; $03 !!3
=$04					KWD_GREATERLESS                      = $04; $04 ><
=$05					KWD_GREATEREQUAL                     = $05; $05 >=
=$06					KWD_GREATERGREATER                   = $06; $06 >>
=$07					KWD_PLINGPLING7                      = $07; $07 !!7
=$08					KWD_PLINGPLING8                      = $08; $08 !!8
=$09					KWD_PLINGPLING9                      = $09; $09 !!9
=$0a					KWD_PLINGPLING10                     = $0a; $0a !!10
=$0b					KWD_PLINGPLING11                     = $0b; $0b !!11
=$0c					KWD_PLINGPLING12                     = $0c; $0c !!12
=$0d					KWD_PLINGPLING13                     = $0d; $0d !!13
=$0e					KWD_PLINGPLING14                     = $0e; $0e !!14
=$0f					KWD_PLINGPLING15                     = $0f; $0f !!15
=$10					KWD_AT                               = $10; $10 @
=$11					KWD_PLINGPLING17                     = $11; $11 !!17
=$12					KWD_PLINGPLING18                     = $12; $12 !!18
=$13					KWD_LSQPAREN                         = $13; $13 [
=$14					KWD_BACKSLASH                        = $14; $14 \
=$15					KWD_RSQPAREN                         = $15; $15 ]
=$16					KWD_HAT                              = $16; $16 ^
=$17					KWD_UNDERSCORE                       = $17; $17 _
=$18					KWD_BQUOTE                           = $18; $18 `
=$19					KWD_PLINGPLING25                     = $19; $19 !!25
=$1a					KWD_PLINGPLING26                     = $1a; $1a !!26
=$1b					KWD_LCURLY                           = $1b; $1b {
=$1c					KWD_BAR                              = $1c; $1c |
=$1d					KWD_RCURLY                           = $1d; $1d }
=$1e					KWD_TILDE                            = $1e; $1e ~
=$21					KWD_PLING                            = $21; $21 !
=$22					KWD_DQUOTE                           = $22; $22 "
=$23					KWD_HASH                             = $23; $23 #
=$24					KWD_DOLLAR                           = $24; $24 $
=$25					KWD_PERCENT                          = $25; $25 %
=$26					KWD_AMPERSAND                        = $26; $26 &
=$27					KWD_QUOTE                            = $27; $27 '
=$28					KWD_LPAREN                           = $28; $28 (
=$29					KWD_RPAREN                           = $29; $29 )
=$2a					KWD_STAR                             = $2a; $2a *
=$2b					KWD_PLUS                             = $2b; $2b +
=$2c					KWD_COMMA                            = $2c; $2c ,
=$2d					KWD_MINUS                            = $2d; $2d -
=$2e					KWD_PERIOD                           = $2e; $2e .
=$2f					KWD_SLASH                            = $2f; $2f /
=$30					KWD_0                                = $30; $30 0
=$31					KWD_1                                = $31; $31 1
=$32					KWD_2                                = $32; $32 2
=$33					KWD_3                                = $33; $33 3
=$34					KWD_4                                = $34; $34 4
=$35					KWD_5                                = $35; $35 5
=$36					KWD_6                                = $36; $36 6
=$37					KWD_7                                = $37; $37 7
=$38					KWD_8                                = $38; $38 8
=$39					KWD_9                                = $39; $39 9
=$3a					KWD_COLON                            = $3a; $3a :
=$3b					KWD_SEMICOLON                        = $3b; $3b ;
=$3c					KWD_LESS                             = $3c; $3c <
=$3d					KWD_EQUAL                            = $3d; $3d =
=$3e					KWD_GREATER                          = $3e; $3e >
=$3f					KWD_QMARK                            = $3f; $3f ?
=$83					KWD_ABSLPAREN                        = $83; $83 ABS(
=$84					KWD_ALLOCLPAREN                      = $84; $84 ALLOC(
=$85					KWD_ASCLPAREN                        = $85; $85 ASC(
=$86					KWD_CHRDOLLARLPAREN                  = $86; $86 CHR$(
=$87					KWD_EVENTLPAREN                      = $87; $87 EVENT(
=$88					KWD_FALSE                            = $88; $88 FALSE
=$89					KWD_FRACLPAREN                       = $89; $89 FRAC(
=$8a					KWD_HITLPAREN                        = $8a; $8a HIT(
=$8b					KWD_INTLPAREN                        = $8b; $8b INT(
=$8c					KWD_ISVALLPAREN                      = $8c; $8c ISVAL(
=$8d					KWD_JOYBLPAREN                       = $8d; $8d JOYB(
=$8e					KWD_JOYXLPAREN                       = $8e; $8e JOYX(
=$8f					KWD_JOYYLPAREN                       = $8f; $8f JOYY(
=$90					KWD_LEFTDOLLARLPAREN                 = $90; $90 LEFT$(
=$91					KWD_LENLPAREN                        = $91; $91 LEN(
=$92					KWD_MAXLPAREN                        = $92; $92 MAX(
=$93					KWD_MIDDOLLARLPAREN                  = $93; $93 MID$(
=$94					KWD_MINLPAREN                        = $94; $94 MIN(
=$95					KWD_NOTLPAREN                        = $95; $95 NOT(
=$96					KWD_PLAYINGLPAREN                    = $96; $96 PLAYING(
=$97					KWD_RANDOMLPAREN                     = $97; $97 RANDOM(
=$98					KWD_RIGHTDOLLARLPAREN                = $98; $98 RIGHT$(
=$99					KWD_RNDLPAREN                        = $99; $99 RND(
=$9a					KWD_SGNLPAREN                        = $9a; $9a SGN(
=$9b					KWD_SPCLPAREN                        = $9b; $9b SPC(
=$9c					KWD_STRDOLLARLPAREN                  = $9c; $9c STR$(
=$9d					KWD_TIMERLPAREN                      = $9d; $9d TIMER(
=$9e					KWD_TRUE                             = $9e; $9e TRUE
=$9f					KWD_VALLPAREN                        = $9f; $9f VAL(
=$a0					KWD_FOR                              = $a0; $a0 FOR
=$a1					KWD_IF                               = $a1; $a1 IF
=$a2					KWD_PROC                             = $a2; $a2 PROC
=$a3					KWD_REPEAT                           = $a3; $a3 REPEAT
=$a4					KWD_WHILE                            = $a4; $a4 WHILE
=$a5					KWD_ENDIF                            = $a5; $a5 ENDIF
=$a6					KWD_ENDPROC                          = $a6; $a6 ENDPROC
=$a7					KWD_NEXT                             = $a7; $a7 NEXT
=$a8					KWD_THEN                             = $a8; $a8 THEN
=$a9					KWD_UNTIL                            = $a9; $a9 UNTIL
=$aa					KWD_WEND                             = $aa; $aa WEND
=$ab					KWD_BY                               = $ab; $ab BY
=$ac					KWD_CALL                             = $ac; $ac CALL
=$ad					KWD_CIRCLE                           = $ad; $ad CIRCLE
=$ae					KWD_CLEAR                            = $ae; $ae CLEAR
=$af					KWD_CLS                              = $af; $af CLS
=$b0					KWD_COLOR                            = $b0; $b0 COLOR
=$b1					KWD_COLOUR                           = $b1; $b1 COLOUR
=$b2					KWD_DATA                             = $b2; $b2 DATA
=$b3					KWD_DIM                              = $b3; $b3 DIM
=$b4					KWD_DOWNTO                           = $b4; $b4 DOWNTO
=$b5					KWD_ELSE                             = $b5; $b5 ELSE
=$b6					KWD_FROM                             = $b6; $b6 FROM
=$b7					KWD_GFX                              = $b7; $b7 GFX
=$b8					KWD_GOSUB                            = $b8; $b8 GOSUB
=$b9					KWD_GOTO                             = $b9; $b9 GOTO
=$ba					KWD_HERE                             = $ba; $ba HERE
=$bb					KWD_IMAGE                            = $bb; $bb IMAGE
=$bc					KWD_LET                              = $bc; $bc LET
=$bd					KWD_LINE                             = $bd; $bd LINE
=$be					KWD_LOCAL                            = $be; $be LOCAL
=$bf					KWD_OFF                              = $bf; $bf OFF
=$c0					KWD_ON                               = $c0; $c0 ON
=$c1					KWD_OUTLINE                          = $c1; $c1 OUTLINE
=$c2					KWD_PALETTE                          = $c2; $c2 PALETTE
=$c3					KWD_PLOT                             = $c3; $c3 PLOT
=$c4					KWD_PRINT                            = $c4; $c4 PRINT
=$c5					KWD_READ                             = $c5; $c5 READ
=$c6					KWD_RECT                             = $c6; $c6 RECT
=$c7					KWD_REM                              = $c7; $c7 REM
=$c8					KWD_RETURN                           = $c8; $c8 RETURN
=$c9					KWD_SOLID                            = $c9; $c9 SOLID
=$ca					KWD_SOUND                            = $ca; $ca SOUND
=$cb					KWD_SPRITE                           = $cb; $cb SPRITE
=$cc					KWD_TEXT                             = $cc; $cc TEXT
=$cd					KWD_TO                               = $cd; $cd TO

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst0.inc

=$80					KWC_EOL = $80
=$ff					KWC_STRING = $FF
=$fe					KWC_HEXCONST = $FE
=$a0					KWC_FIRST_STRUCTURE = $a0
=$a5					KWC_FIRST_STRUCTURE_DEC = $a5
=$aa					KWC_LAST_STRUCTURE = $aa
=$83					KWC_FIRST_UNARY = $83
=$9f					KWC_LAST_UNARY = $9f

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/access.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/stack.inc

=$e0					STK_GOSUB = $E0
=$d0					STK_FOR = $D0
=$c0					STK_REPEAT = $C0
=$b0					STK_PROC = $B0
=$a0					STK_WHILE = $A0
=$01					STK_LOCALN = $01
=$02					STK_LOCALS = $02

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/00start.asm

.8000	a2 ff		ldx #$ff	Start:	ldx 	#$FF 						; stack reset
.8002	9a		txs				txs
.8003	20 58 aa	jsr $aa58			jsr 	EXTInitialise 				; hardware initialise
.8006	a2 80		ldx #$80			ldx 	#(Prompt >> 8) 				; prompt
.8008	a9 22		lda #$22			lda 	#(Prompt & $FF)
.800a	20 c4 8d	jsr $8dc4			jsr 	PrintStringXA
.800d	a9 00		lda #$00			lda 	#0 							; graphics system initialise.
.800f	aa		tax				tax
.8010	a8		tay				tay
.8011	20 e4 aa	jsr $aae4			jsr 	GXGraphicDraw
.8014	a9 0f		lda #$0f			lda 	#$0F 						; initialise sound system
.8016	20 72 b9	jsr $b972			jsr 	SNDCommand
.8019	20 54 88	jsr $8854			jsr 	NewProgram 					; erase current program
.801c	20 e4 82	jsr $82e4			jsr 	BackloadProgram
.801f	4c 00 8a	jmp $8a00			jmp 	CommandRun
>8022	0c 2a 2a 2a 20 46 32 35		Prompt:	.text 	12,"*** F256 Junior SuperBASIC ***",13,13
>802a	36 20 4a 75 6e 69 6f 72 20 53 75 70 65 72 42 41
>803a	53 49 43 20 2a 2a 2a 0d 0d

;******  Processing file: ./common/aa.system/../generated/timestamp.asm

>8043	42 75 69 6c 74 20 54 75			.text "Built Tuesday 22-Nov-2022. Build 3502."
>804b	65 73 64 61 79 20 32 32 2d 4e 6f 76 2d 32 30 32
>805b	32 2e 20 42 75 69 6c 64 20 33 35 30 32 2e

;******  Return to file: ./common/aa.system/00start.asm

>8069	0d 0d 00					.byte 	13,13,0

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/assembler.asm

.806c					AssembleGroup1:
.806c	a9 ff		lda #$ff			lda 	#$FF
.806e	8d a5 04	sta $04a5			sta 	ModeMask 					; initialise the mode mask - all for all
.8071	80 02		bra $8075			bra 	AsmGroup12
.8073					AssembleGroup2:
.8073	a9 00		lda #$00			lda 	#$00
.8075					AsmGroup12:
.8075	8d a3 04	sta $04a3			sta 	IsGroup1 					; save the 'group 1' flag
.8078	68		pla				pla 								; pop the return address to access the information following.
.8079	fa		plx				plx
.807a	20 03 81	jsr $8103			jsr 	AccessParameters 			; get opcode and save as base
.807d	8d a4 04	sta $04a4			sta 	BaseOpcode
.8080	ad a3 04	lda $04a3			lda 	IsGroup1 					; skip if group 1 as we don't have a complex mask.
.8083	d0 08		bne $808d			bne 	_AG12HaveMask
.8085	a9 02		lda #$02			lda 	#2 							; if group 2 the second parameter is the mask
.8087	20 0b 81	jsr $810b			jsr 	GetParameter		 		; e.g. which modes are supported for this operand
.808a	8d a5 04	sta $04a5			sta 	ModeMask
.808d					_AG12HaveMask:
.808d	20 46 82	jsr $8246			jsr 	TypeAndCalculateOperand 	; get zero page type
.8090	da		phx				phx 								; save found address mode
.8091	20 6f 81	jsr $816f			jsr 	AssembleModeX
.8094	fa		plx				plx  								; restore address mode
.8095	b0 0b		bcs $80a2			bcs 	_AG12Exit
.8097	20 a3 80	jsr $80a3			jsr 	PromoteToAbsolute  			; promote ZP to ABS and try that
.809a	20 6f 81	jsr $816f			jsr 	AssembleModeX
.809d	b0 03		bcs $80a2			bcs 	_AG12Exit
.809f	4c b8 9f	jmp $9fb8			jmp 	SyntaxError 				; can't do either, so must be wrong mode/operand.
.80a2					_AG12Exit:
.80a2	60		rts				rts
.80a3					PromoteToAbsolute:
.80a3	a9 6c		lda #$6c			lda 	#AM_ABS 					; lda xx
.80a5	e0 e4		cpx #$e4			cpx 	#AM_ZEROPAGE
.80a7	f0 19		beq $80c2			beq 	_PTADo
.80a9	a9 7c		lda #$7c			lda 	#AM_ABSX 					; lda xx,X
.80ab	e0 f4		cpx #$f4			cpx 	#AM_ZEROX
.80ad	f0 13		beq $80c2			beq 	_PTADo
.80af	a9 78		lda #$78			lda 	#AM_ABSY 					; lda xx,Y
.80b1	e0 80		cpx #$80			cpx 	#AM_ZEROY
.80b3	f0 0d		beq $80c2			beq 	_PTADo
.80b5	a9 01		lda #$01			lda 	#AM_INDABS 					; lda (xx) (jump)
.80b7	e0 d1		cpx #$d1			cpx 	#AM_IND
.80b9	f0 07		beq $80c2			beq 	_PTADo
.80bb	a9 02		lda #$02			lda 	#AM_INDABSX 				; lda (xx,x) (jump)
.80bd	e0 c0		cpx #$c0			cpx 	#AM_INDX
.80bf	f0 01		beq $80c2			beq 	_PTADo
.80c1	60		rts				rts
.80c2					_PTADo:
.80c2	aa		tax				tax
.80c3	60		rts				rts
.80c4					AssembleGroup3:
.80c4	68		pla				pla 								; get parameters, which is just the opcode.
.80c5	fa		plx				plx
.80c6	20 03 81	jsr $8103			jsr 	AccessParameters 			; get and output opcode
.80c9	20 1b 81	jsr $811b			jsr 	AssemblerWriteByte
.80cc	20 aa 82	jsr $82aa			jsr 	CalculateOperand 			; get a 16 bit operand
.80cf	ad 08 04	lda $0408			lda 	NSMantissa0 				; calculate the offset
.80d2	38		sec				sec
.80d3	ed 9e 04	sbc $049e			sbc 	AssemblerAddress
.80d6	48		pha				pha 								; LSB in A
.80d7	ad 10 04	lda $0410			lda 	NSMantissa1
.80da	ed 9f 04	sbc $049f			sbc 	AssemblerAddress+1
.80dd	aa		tax				tax 								; MSB in X
.80de	68		pla				pla
.80df	18		clc				clc 								; $80 to easy check $80-$7F, plus 1 for offset error
.80e0	69 7f		adc #$7f			adc 	#$7F
.80e2	90 01		bcc $80e5			bcc 	_AG3NoCarry
.80e4	e8		inx				inx
.80e5					_AG3NoCarry:
.80e5	38		sec				sec 								; fix back and write out anyways.
.80e6	e9 80		sbc #$80			sbc 	#$80
.80e8	20 1b 81	jsr $811b			jsr 	AssemblerWriteByte
.80eb	e0 00		cpx #$00			cpx 	#0 							; was it in range
.80ed	f0 0a		beq $80f9			beq 	_AG3Exit
.80ef	ad a0 04	lda $04a0			lda 	AssemblerControl 			; are we allowing bad values ?
.80f2	29 01		and #$01			and 	#1
.80f4	f0 03		beq $80f9			beq 	_AG3Exit
.80f6	4c bd 9f	jmp $9fbd			jmp 	RangeError 					; no, branch is out of range
.80f9					_AG3Exit:
.80f9	60		rts				rts
.80fa					AssembleGroup4:
.80fa	68		pla				pla 								; pop address
.80fb	fa		plx				plx
.80fc	20 03 81	jsr $8103			jsr 	AccessParameters 			; access and get first
.80ff	20 1b 81	jsr $811b			jsr 	AssemblerWriteByte 			; output it.
.8102	60		rts				rts
.8103					AccessParameters:
.8103	8d a1 04	sta $04a1			sta 	ParamStart
.8106	8e a2 04	stx $04a2			stx 	ParamStart+1
.8109	a9 01		lda #$01			lda 	#1
.810b					GetParameter:
.810b	5a		phy				phy
.810c	a8		tay				tay
.810d	ad a1 04	lda $04a1			lda 	ParamStart
.8110	85 36		sta $36				sta 	zTemp0
.8112	ad a2 04	lda $04a2			lda 	ParamStart+1
.8115	85 37		sta $37				sta 	zTemp0+1
.8117	b1 36		lda ($36),y			lda 	(zTemp0),y
.8119	7a		ply				ply
.811a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/aswrite.asm

.811b					AssemblerWriteByte:
.811b	48		pha			pha
.811c	ad a0 04	lda $04a0		lda 	AssemblerControl 				; check printing bytes ?
.811f	29 02		and #$02		and 	#2
.8121	f0 1b		beq $813e		beq 	_AWBNoPrint
.8123	ad 9f 04	lda $049f		lda		AssemblerAddress+1 				; print address
.8126	20 59 81	jsr $8159		jsr 	PrintHex
.8129	ad 9e 04	lda $049e		lda		AssemblerAddress
.812c	20 59 81	jsr $8159		jsr 	PrintHex
.812f	a9 20		lda #$20		lda 	#' '
.8131	20 e4 a7	jsr $a7e4		jsr 	EXTPrintCharacter
.8134	68		pla			pla 									; print byte
.8135	48		pha			pha
.8136	20 59 81	jsr $8159		jsr 	PrintHex
.8139	a9 0d		lda #$0d		lda 	#13
.813b	20 e4 a7	jsr $a7e4		jsr 	EXTPrintCharacter
.813e					_AWBNoPrint:
.813e	ad 9e 04	lda $049e		lda		AssemblerAddress				; copy address to zTemp0
.8141	85 36		sta $36			sta 	zTemp0
.8143	ad 9f 04	lda $049f		lda		AssemblerAddress+1
.8146	f0 0e		beq $8156		beq 	_AWBRange
.8148	85 37		sta $37			sta 	zTemp0+1
.814a	68		pla			pla 									; write byte out
.814b	92 36		sta ($36)		sta 	(zTemp0)
.814d	ee 9e 04	inc $049e		inc 	AssemblerAddress 				; bump address
.8150	d0 03		bne $8155		bne 	_AWBNoCarry
.8152	ee 9f 04	inc $049f		inc 	AssemblerAddress+1
.8155					_AWBNoCarry:
.8155	60		rts			rts
.8156					_AWBRange:
.8156	4c bd 9f	jmp $9fbd		jmp 	RangeError
.8159					PrintHex:
.8159	48		pha				pha
.815a	4a		lsr a				lsr 	a
.815b	4a		lsr a				lsr 	a
.815c	4a		lsr a				lsr 	a
.815d	4a		lsr a				lsr 	a
.815e	20 62 81	jsr $8162			jsr 	_PrintNibble
.8161	68		pla				pla
.8162					_PrintNibble:
.8162	29 0f		and #$0f			and 	#15
.8164	c9 0a		cmp #$0a			cmp 	#10
.8166	90 02		bcc $816a			bcc 	_NoShift
.8168	69 06		adc #$06			adc 	#6
.816a					_NoShift:
.816a	69 30		adc #$30			adc 	#48
.816c	4c e4 a7	jmp $a7e4			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/instruction.asm

.816f					AssembleModeX:
.816f	5a		phy				phy
.8170	ad a3 04	lda $04a3			lda 	IsGroup1
.8173	f0 17		beq $818c			beq 	_AMXGroup2
.8175	8a		txa				txa 							; is it in group # 1
.8176	29 40		and #$40			and 	#AM_ISG1
.8178	f0 50		beq $81ca			beq 	_AMXFail 				; no, give up.
.817a	8a		txa				txa 							; get back.
.817b	29 1f		and #$1f			and 	#$1F 					; this is now the offset.
.817d	e0 e0		cpx #$e0			cpx 	#AM_IMMEDIATE 			; if not immediate, we can continue.
.817f	d0 22		bne $81a3			bne 	_AMXHaveInfo
.8181	ad a4 04	lda $04a4			lda 	BaseOpcode 				; cannot store immediate.
.8184	c9 81		cmp #$81			cmp 	#$81
.8186	f0 42		beq $81ca			beq 	_AMXFail
.8188	a9 08		lda #$08			lda 	#8 						; if immediate we use offset 8.
.818a	80 17		bra $81a3			bra 	_AMXHaveInfo 			; odd design decision there.
.818c					_AMXGroup2:
.818c	8a		txa				txa 							; is it in group 2 ?
.818d	29 20		and #$20			and 	#AM_ISG2
.818f	f0 39		beq $81ca			beq 	_AMXFail 				; no, give up.
.8191	8a		txa				txa 							; get the offset into Y
.8192	29 1f		and #$1f			and 	#$1F
.8194	4a		lsr a				lsr 	a 						; make it 0-7.
.8195	4a		lsr a				lsr  	a
.8196	a8		tay				tay
.8197	ad a5 04	lda $04a5			lda 	ModeMask 				; shift the modemask left so you can check it against the requested offset
.819a					_AMXCheckOkay:
.819a	0a		asl a				asl 	a 						; shift modemask left enough times to check legitimate.
.819b	88		dey				dey
.819c	10 fc		bpl $819a			bpl 	_AMXCheckOkay
.819e	90 2a		bcc $81ca			bcc 	_AMXFail 				; not allowed.
.81a0	8a		txa				txa  							; get mask back
.81a1	29 1f		and #$1f			and 	#$1F
.81a3					_AMXHaveInfo:
.81a3	e0 00		cpx #$00			cpx 	#$00 					; does it *require* an 8 bit operand
.81a5	10 05		bpl $81ac			bpl 	_AMXAnySize 			; checking bit 7, the zero page opcode flag.
.81a7	ac 10 04	ldy $0410			ldy 	NSMantissa1 			; fail if it is outside range, e.g. the MSB is set.
.81aa	d0 1e		bne $81ca			bne 	_AMXFail
.81ac					_AMXAnySize:
.81ac	18		clc				clc 							; add offset to the base opcode
.81ad	6d a4 04	adc $04a4			adc 	BaseOpcode
.81b0					_AMXOutputCode:
.81b0	20 1b 81	jsr $811b			jsr 	AssemblerWriteByte 		; write the opcode out.
.81b3	e0 28		cpx #$28			cpx 	#AM_ACC 				; A mode (e.g. ASL A)
.81b5	f0 10		beq $81c7			beq 	_AMXExit
.81b7	ad 08 04	lda $0408			lda 	NSMantissa0 				; write LSB operand
.81ba	20 1b 81	jsr $811b			jsr 	AssemblerWriteByte
.81bd	e0 00		cpx #$00			cpx 	#$00 					; zeropage ?
.81bf	30 06		bmi $81c7			bmi 	_AMXExit
.81c1	ad 10 04	lda $0410			lda 	NSMantissa1 			; write MSB operand
.81c4	20 1b 81	jsr $811b			jsr 	AssemblerWriteByte
.81c7					_AMXExit:
.81c7	7a		ply				ply
.81c8	38		sec				sec
.81c9	60		rts				rts
.81ca					_AMXFail:
.81ca	a0 00		ldy #$00			ldy 	#0
.81cc					_AMXCheckOddities:
.81cc	8a		txa				txa
.81cd	d9 f5 81	cmp $81f5,y			cmp 	ExtraOpcode+2,y 		; match address mode
.81d0	d0 16		bne $81e8			bne 	_AMXCONext
.81d2	b9 f3 81	lda $81f3,y			lda 	ExtraOpcode+0,y 		; do the base opcodes match
.81d5	cd a4 04	cmp $04a4			cmp 	BaseOpcode
.81d8	d0 0e		bne $81e8			bne 	_AMXCONext
.81da	e0 00		cpx #$00			cpx 	#$00 					; requires zero page ?
.81dc	10 05		bpl $81e3			bpl 	_AMXCONotZero
.81de	ad 10 04	lda $0410			lda 	NSMantissa1
.81e1	d0 05		bne $81e8			bne 	_AMXCONext
.81e3					_AMXCONotZero:
.81e3	b9 f4 81	lda $81f4,y			lda 	ExtraOpcode+1,y 		; get new opcode
.81e6	80 c8		bra $81b0			bra 	_AMXOutputCode 			; and assemble it
.81e8					_AMXCONext:
.81e8	c8		iny				iny
.81e9	c8		iny				iny
.81ea	c8		iny				iny
.81eb	b9 f3 81	lda $81f3,y			lda 	ExtraOpcode+0,y 		; end of table
.81ee	d0 dc		bne $81cc			bne 	_AMXCheckOddities
.81f0					_AMXCOFail:
.81f0	7a		ply				ply
.81f1	18		clc				clc
.81f2	60		rts				rts
.81f3					ExtraOpcode:
>81f3	40 6c 01					.byte $40,$6c,AM_INDABS 	; jmp
>81f6	40 7c 02					.byte $40,$7C,AM_INDABSX 	; jmp
>81f9	a2 be 78					.byte $a2,$BE,AM_ABSY 		; ldx
>81fc	a2 b6 80					.byte $a2,$B6,AM_ZEROY 		; ldx
>81ff	82 96 80					.byte $82,$96,AM_ZEROY 		; stx
>8202	e2 1a 28					.byte $e2,$1a,AM_ACC 		; inc
>8205	c2 3a 28					.byte $c2,$3a,AM_ACC 		; dec
>8208	20 89 e0					.byte $20,$89,AM_IMMEDIATE 	; bit
>820b	60 9c 6c					.byte $60,$9c,AM_ABS 		; stz
>820e	60 9e 7c					.byte $60,$9e,AM_ABSX 		; stz
>8211	00						.byte $00

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/label.asm

.8212					LabelHere:
.8212	c8		iny				iny 								; skip .
.8213	a2 00		ldx #$00			ldx 	#0 							; get a term
.8215	20 f4 97	jsr $97f4			jsr 	EvaluateTerm 				; get a term
.8218	ad 00 04	lda $0400			lda 	NSStatus 					; needs to be an integer reference.
.821b	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.821d	d0 24		bne $8243			bne 	_ALType
.821f	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy reference address to zTemp0
.8222	85 36		sta $36				sta 	zTemp0
.8224	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.8227	85 37		sta $37				sta 	zTemp0+1
.8229	5a		phy				phy 								; copy address in.
.822a	a0 01		ldy #$01			ldy 	#1
.822c	ad 9e 04	lda $049e			lda	 	AssemblerAddress
.822f	92 36		sta ($36)			sta 	(zTemp0)
.8231	ad 9f 04	lda $049f			lda	 	AssemblerAddress+1
.8234	91 36		sta ($36),y			sta 	(zTemp0),y
.8236	c8		iny				iny
.8237	a9 00		lda #$00			lda 	#0
.8239	91 36		sta ($36),y			sta 	(zTemp0),y
.823b	c8		iny				iny
.823c	91 36		sta ($36),y			sta 	(zTemp0),y
.823e	c8		iny				iny
.823f	91 36		sta ($36),y			sta 	(zTemp0),y
.8241	7a		ply				ply
.8242	60		rts				rts
.8243					_ALType:
.8243	4c c2 9f	jmp $9fc2			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/operands.asm

.8246					TypeAndCalculateOperand:
.8246	b1 30		lda ($30),y			lda 	(codePtr),y
.8248	a2 28		ldx #$28			ldx 	#AM_ACC 					; ACC if : or EOL
.824a	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.824c	f0 5b		beq $82a9			beq 	_TACOExit
.824e	c9 80		cmp #$80			cmp 	#KWC_EOL
.8250	f0 57		beq $82a9			beq 	_TACOExit
.8252	c8		iny				iny
.8253	a2 e0		ldx #$e0			ldx 	#AM_IMMEDIATE
.8255	c9 23		cmp #$23			cmp 	#KWD_HASH 					; if hash, then immediate - constant.
.8257	f0 51		beq $82aa			beq 	CalculateOperand
.8259	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; if ( then check for indirection
.825b	f0 1f		beq $827c			beq 	_TACOIndirect
.825d	88		dey				dey 								; undo get of first character
.825e	20 aa 82	jsr $82aa			jsr 	CalculateOperand 			; get operand
.8261	b1 30		lda ($30),y			lda 	(codePtr),y
.8263	a2 e4		ldx #$e4			ldx 	#AM_ZEROPAGE 				; if not, try zero page (then absolute)
.8265	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8267	d0 40		bne $82a9			bne 	_TACOExit
.8269	c8		iny				iny
.826a	20 b4 82	jsr $82b4			jsr 	TACOCheckXY 				; extract X,Y or 0 (neither) from the variable.
.826d	a2 f4		ldx #$f4			ldx 	#AM_ZEROX 					; check for X
.826f	c9 58		cmp #$58			cmp 	#'X'
.8271	f0 36		beq $82a9			beq 	_TACOExit
.8273	a2 80		ldx #$80			ldx 	#AM_ZEROY 					; check for Y
.8275	c9 59		cmp #$59			cmp 	#'Y'
.8277	f0 30		beq $82a9			beq 	_TACOExit
.8279					_TACOSyntax:
.8279	4c b8 9f	jmp $9fb8			jmp 	SyntaxError
.827c					_TACOIndirect:
.827c	20 aa 82	jsr $82aa			jsr 	CalculateOperand 			; get the operand
.827f	b1 30		lda ($30),y			lda 	(codePtr),y
.8281	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if , then it must be ,X)
.8283	f0 17		beq $829c			beq 	_TACOIndX
.8285	20 52 8d	jsr $8d52			jsr 	CheckRightBracket  			; otherwise must be ) or ),Y
.8288	b1 30		lda ($30),y			lda 	(codePtr),y
.828a	a2 d1		ldx #$d1			ldx 	#AM_IND
.828c	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not comma then exit with (xx)
.828e	d0 19		bne $82a9			bne 	_TACOExit
.8290	c8		iny				iny
.8291	20 b4 82	jsr $82b4			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.8294	c9 59		cmp #$59			cmp 	#'Y' 						; check Y
.8296	d0 e1		bne $8279			bne 	_TACOSyntax
.8298	a2 d0		ldx #$d0			ldx 	#AM_INDY
.829a	80 0d		bra $82a9			bra 	_TACOExit
.829c					_TACOIndX:
.829c	c8		iny				iny
.829d	20 b4 82	jsr $82b4			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.82a0	c9 58		cmp #$58			cmp 	#'X' 						; check X
.82a2	d0 d5		bne $8279			bne 	_TACOSyntax
.82a4	20 52 8d	jsr $8d52			jsr 	CheckRightBracket			; check )
.82a7	a2 c0		ldx #$c0			ldx 	#AM_INDX
.82a9					_TACOExit:
.82a9	60		rts				rts
.82aa					CalculateOperand:
.82aa	48		pha				pha
.82ab	da		phx				phx
.82ac	a2 00		ldx #$00			ldx 	#0 							; get 16 bit integer in Slot 0
.82ae	20 8f 9d	jsr $9d8f			jsr 	Evaluate16BitInteger
.82b1	fa		plx				plx
.82b2	68		pla				pla
.82b3	60		rts				rts
.82b4					TACOCheckXY:
.82b4	b1 30		lda ($30),y			lda 	(codePtr),y
.82b6	29 c0		and #$c0			and 	#$C0 						; check it is an identifier reference.
.82b8	c9 40		cmp #$40			cmp 	#$40
.82ba	d0 21		bne $82dd			bne 	_TCXYFail
.82bc	b1 30		lda ($30),y			lda 	(codePtr),y
.82be	18		clc				clc
.82bf	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.82c1	85 37		sta $37				sta 	zTemp0+1
.82c3	c8		iny				iny
.82c4	b1 30		lda ($30),y			lda 	(codePtr),y
.82c6	c8		iny				iny
.82c7	85 36		sta $36				sta 	zTemp0
.82c9	5a		phy				phy 								; save position
.82ca	a0 02		ldy #$02			ldy 	#2 							; type is integer ?
.82cc	b1 36		lda ($36),y			lda 	(zTemp0),y
.82ce	d0 0c		bne $82dc			bne 	_TCXYPopFail
.82d0	a0 08		ldy #$08			ldy 	#8 							; get first character, should have bit 7 set as also last.
.82d2	b1 36		lda ($36),y			lda 	(zTemp0),y
.82d4	c9 d8		cmp #$d8			cmp 	#'X'+$80 					; should be X or Y
.82d6	f0 08		beq $82e0			beq 	_TCXYFound
.82d8	c9 d9		cmp #$d9			cmp 	#'Y'+$80
.82da	f0 04		beq $82e0			beq 	_TCXYFound
.82dc					_TCXYPopFail:
.82dc	7a		ply				ply
.82dd					_TCXYFail:
.82dd	a9 00		lda #$00			lda 	#0
.82df	60		rts				rts
.82e0					_TCXYFound:
.82e0	7a		ply				ply 								; restore position
.82e1	29 7f		and #$7f			and 	#$7F 						; throw bit 7
.82e3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/backload.asm

.82e4					BackloadProgram:
.82e4	a9 00		lda #$00			lda 	#((SOURCE_ADDRESS) & $FF)
.82e6	8d 2b 06	sta $062b			sta 	0+BackLoadPointer
.82e9	a9 30		lda #$30			lda 	#((SOURCE_ADDRESS) >> 8)
.82eb	8d 2c 06	sta $062c			sta 	1+BackLoadPointer
.82ee					_BPLoop:
.82ee	a2 ff		ldx #$ff			ldx 	#$FF
.82f0	8e fa ff	stx $fffa			stx 	$FFFA 						; fast mode (autorun only)
.82f3	20 1d 83	jsr $831d			jsr 	BLReadByte
.82f6	30 1e		bmi $8316			bmi 	_BPExit
.82f8					_BPCopy:
.82f8	e8		inx				inx  								; copy byte in
.82f9	9d a8 05	sta $05a8,x			sta 	lineBuffer,x
.82fc	9e a9 05	stz $05a9,x			stz 	lineBuffer+1,x
.82ff	20 1d 83	jsr $831d			jsr 	BLReadByte 					; read next byte
.8302	30 0a		bmi $830e			bmi 	_BPEndLine 					; -ve = EOL
.8304	c9 09		cmp #$09			cmp 	#9 							; handle TAB
.8306	d0 02		bne $830a			bne 	_BPNotTab
.8308	a9 20		lda #$20			lda 	#' '
.830a					_BPNotTab:
.830a	c9 20		cmp #$20			cmp 	#' ' 						; < ' ' = EOL
.830c	b0 ea		bcs $82f8			bcs 	_BPCopy
.830e					_BPEndLine:
.830e	20 02 b6	jsr $b602			jsr 	TokeniseLine 				; tokenise the line.
.8311	20 34 83	jsr $8334			jsr 	EditProgramCode
.8314	80 d8		bra $82ee			bra 	_BPLoop
.8316					_BPExit:
.8316	9c fa ff	stz $fffa			stz 	$FFFA 						; clear fast mode (autorun only)
.8319	20 f2 83	jsr $83f2			jsr 	ClearCommand 				; clear variables etc.
.831c	60		rts				rts
.831d					BLReadByte:
.831d	ad 2b 06	lda $062b			lda 	BackLoadPointer
.8320	85 36		sta $36				sta 	zTemp0
.8322	ad 2c 06	lda $062c			lda 	BackLoadPointer+1
.8325	85 37		sta $37				sta 	zTemp0+1
.8327	b2 36		lda ($36)			lda 	(zTemp0)
.8329	ee 2b 06	inc $062b			inc 	BackLoadPointer
.832c	d0 03		bne $8331			bne 	_BLNoCarry
.832e	ee 2c 06	inc $062c			inc 	BackLoadPointer+1
.8331					_BLNoCarry:
.8331	c9 00		cmp #$00			cmp 	#0
.8333	60		rts				rts
.062b					BackLoadPointer:
>062b							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/editor.asm

.8334					EditProgramCode:
.8334	ad a9 04	lda $04a9			lda 	TokenLineNumber 			; find the line.
.8337	ae aa 04	ldx $04aa			ldx 	TokenLineNumber+1
.833a	20 c8 a5	jsr $a5c8			jsr 	MemorySearch
.833d	90 05		bcc $8344			bcc 	_EPCNoDelete 				; reached the end don't delete
.833f	d0 03		bne $8344			bne 	_EPCNoDelete 				; found slot but didn't match, no delete
.8341	20 e9 a4	jsr $a4e9			jsr 	MemoryDeleteLine 			; delete the line
.8344					_EPCNoDelete:
.8344	ad ab 04	lda $04ab			lda 	TokenBuffer 				; buffer empty
.8347	c9 80		cmp #$80			cmp 	#KWC_EOL
.8349	f0 0d		beq $8358			beq 	_EPCNoInsert
.834b	ad a9 04	lda $04a9			lda 	TokenLineNumber 			; find the line - it cannot exist.
.834e	ae aa 04	ldx $04aa			ldx 	TokenLineNumber+1 			; so this can't fail, it returns some point in the code.
.8351	20 c8 a5	jsr $a5c8			jsr 	MemorySearch
.8354	18		clc				clc 								; insert at this point.
.8355	20 20 a5	jsr $a520			jsr 	MemoryInsertLine 			; insert the line
.8358					_EPCNoInsert:
.8358	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/warmstart.asm

.8359					WarmStart:
.8359	a2 ff		ldx #$ff			ldx 	#$FF
.835b	9a		txs				txs
.835c	20 72 a9	jsr $a972			jsr 	EXTInputLine 				; get line to lineBuffer
.835f	20 02 b6	jsr $b602			jsr 	TokeniseLine 				; tokenise the line
.8362	ad a9 04	lda $04a9			lda 	TokenLineNumber 			; line number ?
.8365	0d aa 04	ora $04aa			ora 	TokenLineNumber+1
.8368	d0 17		bne $8381			bne 	_WSEditCode 				; if so,edit code.
.836a	9c a8 04	stz $04a8			stz 	TokenOffset 				; zero offset, meaning it only runs one line.
.836d	a9 a8		lda #$a8			lda 	#((TokenOffset) & $FF)
.836f	85 30		sta $30				sta 	codePtr
.8371	a9 04		lda #$04			lda 	#((TokenOffset) >> 8)
.8373	85 31		sta $31				sta 	codePtr+1
.8375	ad ab 04	lda $04ab			lda 	TokenBuffer 				; nothing to run
.8378	c9 80		cmp #$80			cmp 	#KWC_EOL
.837a	f0 dd		beq $8359			beq 	WarmStart
.837c	20 12 8a	jsr $8a12			jsr 	RUNCodePointerLine 			; execute that line.
.837f	80 d8		bra $8359			bra 	WarmStart
.8381					_WSEditCode:
.8381	20 34 83	jsr $8334			jsr 	EditProgramCode
.8384	20 f2 83	jsr $83f2			jsr 	ClearCommand
.8387	80 d0		bra $8359			bra 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assemble.asm

.8389					AssembleCommand:
.8389	a2 00		ldx #$00			ldx 	#0
.838b	20 8f 9d	jsr $9d8f			jsr 	Evaluate16BitInteger 		; start address
.838e	ad 08 04	lda $0408			lda 	NSMantissa0
.8391	8d 9e 04	sta $049e			sta 	AssemblerAddress
.8394	ad 10 04	lda $0410			lda 	NSMantissa1
.8397	8d 9f 04	sta $049f			sta 	AssemblerAddress+1
.839a	20 5a 8d	jsr $8d5a			jsr 	CheckComma
.839d	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger 		; options
.83a0	ad 08 04	lda $0408			lda 	NSMantissa0
.83a3	8d a0 04	sta $04a0			sta 	AssemblerControl
.83a6	60		rts				rts
.83a7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assert.asm

.83a8					AssertCommand:
.83a8	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.83aa	20 7a 9d	jsr $9d7a			jsr 	EvaluateInteger 			; the assert test
.83ad	20 5e 9e	jsr $9e5e			jsr 	NSMIsZero 					; exit if result is non zero.
.83b0	d0 05		bne $83b7			bne 	_ACExit
.83b2	a9 0a		lda #$0a		lda	#10
.83b4	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler
.83b7					_ACExit:
.83b7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/call.asm

.83b8					CallCommand:
.83b8	a2 00		ldx #$00			ldx 	#0
.83ba	20 8f 9d	jsr $9d8f			jsr 	Evaluate16BitInteger
.83bd					_CCClear
.83bd	e8		inx				inx  								; clear 1,2 and 3 (for A X Y)
.83be	20 2e 9e	jsr $9e2e			jsr 	NSMSetZero
.83c1	e0 04		cpx #$04			cpx 	#4
.83c3	d0 f8		bne $83bd			bne 	_CCClear
.83c5	a2 00		ldx #$00			ldx 	#0 							; and keep trying
.83c7					_CCCParam:
.83c7	b1 30		lda ($30),y			lda 	(codePtr),y
.83c9	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.83cb	d0 09		bne $83d6			bne 	_CCCRun6502
.83cd	c8		iny				iny 								; skip comma
.83ce	e8		inx				inx	 								; next level
.83cf	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger 		; get A/X/Y
.83d2	e0 03		cpx #$03			cpx 	#3
.83d4	90 f1		bcc $83c7			bcc 	_CCCParam 					; done all 3 ?
.83d6					_CCCRun6502:
.83d6	5a		phy				phy 								; save position
.83d7	ad 10 04	lda $0410			lda 	NSMantissa1 				; put address in zTemp0
.83da	85 37		sta $37				sta 	zTemp0+1
.83dc	ad 08 04	lda $0408			lda 	NSMantissa0
.83df	85 36		sta $36				sta 	zTemp0
.83e1	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; get registers
.83e4	ae 0a 04	ldx $040a			ldx 	NSMantissa0+2
.83e7	ac 0b 04	ldy $040b			ldy 	NSMantissa0+3
.83ea	20 ef 83	jsr $83ef			jsr 	_CCCZTemp0 					; call zTemp0
.83ed	7a		ply				ply 								; restore position and exit
.83ee	60		rts				rts
.83ef					_CCCZTemp0:
.83ef	6c 36 00	jmp ($0036)			jmp 	(zTemp0)

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/clear.asm

.83f2					ClearCommand:
.83f2	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.83f4	85 36		sta $36				sta 	0+zTemp0
.83f6	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.83f8	85 37		sta $37				sta 	1+zTemp0
.83fa					_ClearZeroLoop:
.83fa	b2 36		lda ($36)			lda 	(zTemp0) 					; end of variables
.83fc	f0 24		beq $8422			beq 	_ClearZeroEnd
.83fe	a0 03		ldy #$03			ldy 	#3 							; erase the variables
.8400	a9 00		lda #$00			lda 	#0
.8402					_ClearOneVariable:
.8402	91 36		sta ($36),y			sta 	(zTemp0),y
.8404	c8		iny				iny
.8405	c0 08		cpy #$08			cpy 	#8
.8407	d0 f9		bne $8402			bne 	_ClearOneVariable
.8409	a0 02		ldy #$02			ldy 	#2 							; has it been marked procedure
.840b	b1 36		lda ($36),y			lda 	(zTemp0),y
.840d	c9 18		cmp #$18			cmp 	#NSTProcedure
.840f	d0 04		bne $8415			bne 	_ClearNotProcedure
.8411	a9 04		lda #$04			lda 	#NSTInteger+NSBIsArray 		; set it back to an integer array
.8413	91 36		sta ($36),y			sta 	(zTemp0),y
.8415					_ClearNotProcedure:
.8415	18		clc				clc 								; go to the next variable
.8416	b2 36		lda ($36)			lda 	(zTemp0)
.8418	65 36		adc $36				adc 	zTemp0
.841a	85 36		sta $36				sta 	zTemp0
.841c	90 dc		bcc $83fa			bcc 	_ClearZeroLoop
.841e	e6 37		inc $37				inc 	zTemp0+1
.8420	80 d8		bra $83fa			bra 	_ClearZeroLoop
.8422					_ClearZeroEnd:
.8422	18		clc				clc
.8423	a5 36		lda $36				lda 	zTemp0
.8425	69 01		adc #$01			adc 	#1
.8427	8d 8c 04	sta $048c			sta 	lowMemPtr
.842a	a5 37		lda $37				lda 	zTemp0+1
.842c	69 00		adc #$00			adc 	#0
.842e	8d 8d 04	sta $048d			sta 	lowMemPtr+1
.8431	20 09 a7	jsr $a709			jsr 	StackReset
.8434	20 73 a7	jsr $a773			jsr 	StringSystemInitialise
.8437	20 5b 8c	jsr $8c5b			jsr 	ProcedureScan
.843a	20 c1 89	jsr $89c1			jsr 	Command_Restore
.843d	9c 9e 04	stz $049e			stz 	AssemblerAddress
.8440	9c 9f 04	stz $049f			stz 	AssemblerAddress+1
.8443	9c a0 04	stz $04a0			stz 	AssemblerControl
.8446	20 f7 99	jsr $99f7			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.8449	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/cls.asm

.844a					ClearScreen:
.844a	5a		phy				phy
.844b	a9 0c		lda #$0c			lda 	#12 						; char code 12 clears the screen.
.844d	20 e4 a7	jsr $a7e4			jsr 	EXTPrintCharacter
.8450	7a		ply				ply
.8451	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/data.asm

.8452					Command_Data:
.8452	a9 3a		lda #$3a			lda 	#KWD_COLON 					; advance to colon/EOL
.8454	a2 80		ldx #$80			ldx 	#KWC_EOL
.8456	20 ad 8c	jsr $8cad			jsr 	ScanForward
.8459	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dim.asm

.845a					DimCommand:
.845a	b1 30		lda ($30),y			lda 	(codePtr),y
.845c	29 c0		and #$c0			and 	#$C0
.845e	c9 40		cmp #$40			cmp 	#$40
.8460	d0 7a		bne $84dc			bne 	_DCSyntax
.8462	b1 30		lda ($30),y			lda 	(codePtr),y
.8464	18		clc				clc
.8465	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8467	85 3f		sta $3f				sta 	zaTemp+1
.8469	c8		iny				iny
.846a	b1 30		lda ($30),y			lda 	(codePtr),y
.846c	c8		iny				iny
.846d	85 3e		sta $3e				sta 	zaTemp
.846f	5a		phy				phy
.8470	a0 02		ldy #$02			ldy 	#2 						; read type byte
.8472	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8474	29 18		and #$18			and 	#NSBTypeMask 			; check it's not a procedure
.8476	c9 18		cmp #$18			cmp 	#NSTProcedure
.8478	f0 62		beq $84dc			beq 	_DCSyntax
.847a	b1 3e		lda ($3e),y			lda 	(zaTemp),y 				; check it's an array
.847c	29 04		and #$04			and 	#NSBIsArray
.847e	f0 64		beq $84e4			beq 	_DCType
.8480	a0 04		ldy #$04			ldy 	#4 						; check not already defined
.8482	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8484	d0 59		bne $84df			bne 	_DCRedefine
.8486	7a		ply				ply
.8487	20 e7 84	jsr $84e7			jsr 	_DCGetSize 				; get array size, check it.
.848a	5a		phy				phy
.848b	a0 05		ldy #$05			ldy 	#5 						; store in first array size slot
.848d	91 3e		sta ($3e),y			sta 	(zaTemp),y 				; second will be zero.
.848f	7a		ply				ply 							; is there a second (e.g. ,x)
.8490	b1 30		lda ($30),y			lda 	(codePtr),y
.8492	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8494	d0 0a		bne $84a0			bne 	_DCOneDimension
.8496	c8		iny				iny 							; skip comma
.8497	20 e7 84	jsr $84e7			jsr 	_DCGetSize 				; get 2nd array size
.849a	5a		phy				phy
.849b	a0 06		ldy #$06			ldy 	#6 						; store in 2nd array size
.849d	91 3e		sta ($3e),y			sta 	(zaTemp),y
.849f	7a		ply				ply
.84a0					_DCOneDimension:
.84a0	5a		phy				phy 							; save position
.84a1	a0 05		ldy #$05			ldy 	#5 						; dimensions + 1 in AX (as zero based)
.84a3	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84a5	aa		tax				tax
.84a6	c8		iny				iny
.84a7	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84a9	e8		inx				inx 							; bump them.
.84aa	1a		inc a				inc 	a
.84ab	20 c3 9d	jsr $9dc3			jsr 	Multiply8x8 			; work out the total number of elements -> zTemp0
.84ae	a5 37		lda $37				lda 	zTemp0+1 				; don't allow more than 8192 elements whatever
.84b0	29 e0		and #$e0			and 	#$E0
.84b2	d0 23		bne $84d7			bne 	_DCSize
.84b4	a0 02		ldy #$02			ldy 	#2 						; get base type
.84b6	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84b8	20 f5 84	jsr $84f5			jsr 	ScaleByBaseType 		; scale by base type
.84bb	a5 36		lda $36				lda 	zTemp0
.84bd	a6 37		ldx $37				ldx 	zTemp0+1
.84bf	20 b9 99	jsr $99b9			jsr 	AllocateXABytes 		; allocate memory
.84c2	a0 03		ldy #$03			ldy 	#3 						; copy into the address.
.84c4	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84c6	c8		iny				iny
.84c7	8a		txa				txa
.84c8	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84ca	7a		ply				ply 							; get position back
.84cb	20 52 8d	jsr $8d52			jsr 	CheckRightBracket 		; check )
.84ce	b1 30		lda ($30),y			lda 	(codePtr),y
.84d0	c8		iny				iny 							; consume in case
.84d1	c9 2c		cmp #$2c			cmp 	#KWD_COMMA		 		; if so do another DIM.
.84d3	f0 85		beq $845a			beq 	DimCommand
.84d5	88		dey				dey 							; undo consume
.84d6	60		rts				rts
.84d7					_DCSize:
.84d7	a9 16		lda #$16		lda	#22
.84d9	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler
.84dc					_DCSyntax:
.84dc	4c b8 9f	jmp $9fb8			jmp 	SyntaxError
.84df					_DCRedefine:
.84df	a9 15		lda #$15		lda	#21
.84e1	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler
.84e4					_DCType:
.84e4	4c c2 9f	jmp $9fc2			jmp 	TypeError
.84e7					_DCGetSize:
.84e7	a2 00		ldx #$00			ldx 	#0 						; get first index.
.84e9	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger 	; get array dimension
.84ec	c9 00		cmp #$00			cmp 	#0 						; must be 1-254
.84ee	f0 e7		beq $84d7			beq 	_DCSize
.84f0	c9 fe		cmp #$fe			cmp 	#254
.84f2	f0 e3		beq $84d7			beq 	_DCSize
.84f4	60		rts				rts
.84f5					ScaleByBaseType:
.84f5	29 10		and #$10			and 	#NSBIsString 			; is it string
.84f7	d0 19		bne $8512			bne 	_SBBTString
.84f9	a5 37		lda $37				lda 	zTemp0+1 				; push value on stack
.84fb	48		pha				pha
.84fc	a5 36		lda $36				lda 	zTemp0
.84fe	48		pha				pha
.84ff	06 36		asl $36				asl 	zTemp0 					; x 2
.8501	26 37		rol $37				rol 	zTemp0+1
.8503	06 36		asl $36				asl 	zTemp0 					; x 4
.8505	26 37		rol $37				rol 	zTemp0+1
.8507	68		pla				pla 							; add stacked value = x 5
.8508	65 36		adc $36				adc 	zTemp0
.850a	85 36		sta $36				sta 	zTemp0
.850c	68		pla				pla
.850d	65 37		adc $37				adc 	zTemp0+1
.850f	85 37		sta $37				sta 	zTemp0+1
.8511	60		rts				rts
.8512					_SBBTString:
.8512	06 36		asl $36				asl 	zTemp0
.8514	26 37		rol $37				rol 	zTemp0+1
.8516	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/end.asm

.8517					EndCommand:
.8517	4c 59 83	jmp $8359			jmp 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/for.asm

.851a					ForCommand:
.851a	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; allocate 18 bytes on the return stack.
.851c	20 a4 a6	jsr $a6a4			jsr 	StackOpen
.851f	a2 00		ldx #$00			ldx 	#0
.8521	20 f4 97	jsr $97f4			jsr 	EvaluateTerm
.8524	bd 00 04	lda $0400,x			lda 	NSStatus,x
.8527	c9 20		cmp #$20			cmp 	#NSBIsReference+NSTInteger 	; do we have an integer 4 byte reference.
.8529	d0 49		bne $8574			bne		_FCError
.852b	a9 3d		lda #$3d			lda 	#KWD_EQUAL 					; =
.852d	20 62 8d	jsr $8d62			jsr 	CheckNextA
.8530	e8		inx				inx
.8531	20 7a 9d	jsr $9d7a			jsr 	EvaluateInteger 			; <from> in +1
.8534	b1 30		lda ($30),y			lda 	(codePtr),y
.8536	c8		iny				iny 								; consume it
.8537	48		pha				pha 								; save on stack for later
.8538	c9 b4		cmp #$b4			cmp 	#KWD_DOWNTO
.853a	f0 04		beq $8540			beq 	_FCNoSyntax
.853c	c9 cd		cmp #$cd			cmp 	#KWD_TO
.853e	d0 37		bne $8577			bne 	_FCSyntaxError
.8540					_FCNoSyntax:
.8540	e8		inx				inx
.8541	20 7a 9d	jsr $9d7a			jsr 	EvaluateInteger
.8544	20 e8 a6	jsr $a6e8			jsr 	STKSaveCodePosition 		; save loop back position
.8547	68		pla				pla 								; restore DOWNTO or TO
.8548	5a		phy				phy 								; save Y on the stack
.8549	49 b4		eor #$b4			eor 	#KWD_DOWNTO 				; 0 if DOWNTO, #0 if TO
.854b	f0 02		beq $854f			beq 	_FCNotDownTo
.854d	a9 02		lda #$02			lda 	#2
.854f					_FCNotDownTo:
.854f	3a		dec a				dec 	a 							; 255 if DOWNTO, 1 if TO
.8550	a0 10		ldy #$10			ldy 	#16
.8552	91 34		sta ($34),y			sta 	(basicStack),y 				; copy that out to the Basic Stack.
.8554	a0 06		ldy #$06			ldy 	#6
.8556	ad 08 04	lda $0408			lda 	NSMantissa0
.8559	91 34		sta ($34),y			sta 	(basicStack),y
.855b	ad 10 04	lda $0410			lda 	NSMantissa1
.855e	c8		iny				iny
.855f	91 34		sta ($34),y			sta 	(basicStack),y
.8561	a0 08		ldy #$08			ldy 	#8 							; set initial index value
.8563	a2 01		ldx #$01			ldx 	#1
.8565	20 7a 85	jsr $857a			jsr 	FCIntegerToStack
.8568	a0 0c		ldy #$0c			ldy 	#12 						; set the terminal value
.856a	a2 02		ldx #$02			ldx 	#2
.856c	20 7a 85	jsr $857a			jsr 	FCIntegerToStack
.856f	20 9a 85	jsr $859a			jsr 	CopyIndexToReference
.8572	7a		ply				ply 								; restore position
.8573	60		rts				rts
.8574					_FCError:
.8574	4c c2 9f	jmp $9fc2			jmp 	TypeError
.8577					_FCSyntaxError:
.8577	4c b8 9f	jmp $9fb8			jmp 	SyntaxError
.857a					FCIntegerToStack:
.857a	3c 00 04	bit $0400,x			bit 	NSStatus,x 					; is the value negative
.857d	10 03		bpl $8582			bpl	 	_FCNotNegative
.857f	20 e3 9d	jsr $9de3			jsr 	NSMNegateMantissa 			; if so 2's complement the mantissa
.8582					_FCNotNegative:
.8582	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy out to the basic stack
.8585	91 34		sta ($34),y			sta 	(basicStack),y
.8587	c8		iny				iny
.8588	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.858b	91 34		sta ($34),y			sta 	(basicStack),y
.858d	c8		iny				iny
.858e	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.8591	91 34		sta ($34),y			sta 	(basicStack),y
.8593	c8		iny				iny
.8594	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.8597	91 34		sta ($34),y			sta 	(basicStack),y
.8599	60		rts				rts
.859a					CopyIndexToReference:
.859a	5a		phy				phy
.859b	a0 06		ldy #$06			ldy 	#6 							; copy address-8 to write to zTemp0
.859d	38		sec				sec 								; (because we copy from offset 8)
.859e	b1 34		lda ($34),y			lda 	(basicStack),y
.85a0	e9 08		sbc #$08			sbc 	#8
.85a2	85 36		sta $36				sta 	zTemp0
.85a4	c8		iny				iny
.85a5	b1 34		lda ($34),y			lda 	(basicStack),y
.85a7	e9 00		sbc #$00			sbc 	#0
.85a9	85 37		sta $37				sta 	zTemp0+1
.85ab	a2 04		ldx #$04			ldx 	#4 							; this is the copy counter/
.85ad	a0 0b		ldy #$0b			ldy 	#8+3 		 				; the MSB of the mantissa
.85af	b1 34		lda ($34),y			lda 	(basicStack),y
.85b1	0a		asl a				asl 	a 							; into carry
.85b2	a0 08		ldy #$08			ldy 	#8 							; where to copy from.
.85b4	90 14		bcc $85ca			bcc 	_CITRNormal
.85b6	38		sec				sec
.85b7					_CITRNegative:
.85b7	a9 00		lda #$00			lda 	#0
.85b9	f1 34		sbc ($34),y			sbc 	(basicStack),y
.85bb	91 36		sta ($36),y			sta 	(zTemp0),y
.85bd	c8		iny				iny
.85be	ca		dex				dex
.85bf	d0 f6		bne $85b7			bne 	_CITRNegative
.85c1	88		dey				dey 								; look at MSB of mantissa
.85c2	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set the MSB as negative packed.
.85c4	09 80		ora #$80			ora 	#$80
.85c6	91 36		sta ($36),y			sta 	(zTemp0),y
.85c8	7a		ply				ply
.85c9	60		rts				rts
.85ca					_CITRNormal:
.85ca	b1 34		lda ($34),y			lda 	(basicStack),y 				; copy without negation.
.85cc	91 36		sta ($36),y			sta 	(zTemp0),y
.85ce	c8		iny				iny
.85cf	ca		dex				dex
.85d0	d0 f8		bne $85ca			bne 	_CITRNormal
.85d2	7a		ply				ply 								; and exit.
.85d3	60		rts				rts
.85d4					NextCommand:
.85d4	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; check FOR is TOS
.85d6	a2 11		ldx #$11			ldx 	#ERRID_FOR 					; this error
.85d8	20 d0 a6	jsr $a6d0			jsr 	StackCheckFrame
.85db	5a		phy				phy
.85dc	a0 10		ldy #$10			ldy 	#16 						; get the step count
.85de	b1 34		lda ($34),y			lda 	(basicStack),y
.85e0	85 36		sta $36				sta 	zTemp0 						; this is the sign extend
.85e2	30 02		bmi $85e6			bmi 	_NCStepNeg
.85e4	64 36		stz $36				stz 	zTemp0 						; which is 0 or 255
.85e6					_NCStepNeg:
.85e6	a0 08		ldy #$08			ldy 	#8 							; offset to bump
.85e8	a2 04		ldx #$04			ldx 	#4 							; count to bump
.85ea	18		clc				clc
.85eb					_NCBump:
.85eb	71 34		adc ($34),y			adc 	(basicStack),y 				; add it
.85ed	91 34		sta ($34),y			sta 	(basicStack),y
.85ef	a5 36		lda $36				lda 	zTemp0 						; get sign extend for next time.
.85f1	c8		iny				iny 								; next byte
.85f2	ca		dex				dex 								; do four times
.85f3	d0 f6		bne $85eb			bne 	_NCBump
.85f5	20 9a 85	jsr $859a			jsr		CopyIndexToReference		; copy it to the reference variable.
.85f8	a0 10		ldy #$10			ldy 	#16 						; get step count again
.85fa	b1 34		lda ($34),y			lda 	(basicStack),y
.85fc	0a		asl a				asl 	a 							; sign bit to carry
.85fd	a9 0c		lda #$0c			lda 	#12 						; offset of LHS = terminal offset
.85ff	85 38		sta $38				sta 	zTemp1
.8601	90 02		bcc $8605			bcc 	_NCCompRev 					; use if step is +ve
.8603	a9 08		lda #$08			lda 	#8 							; now the LHS = index value
.8605					_NCCompRev:
.8605	85 38		sta $38				sta 	zTemp1 						; so zTemp0 is the index for LHS
.8607	49 04		eor #$04			eor 	#(8^12) 					; and zTemp0+1 is the index for RHS
.8609	85 39		sta $39				sta 	zTemp1+1
.860b	a2 04		ldx #$04			ldx 	#4 							; bytes to compare
.860d	38		sec				sec
.860e					_NCCompare:
.860e	a4 38		ldy $38				ldy 	zTemp1 						; do compare using the two indices
.8610	b1 34		lda ($34),y			lda 	(basicStack),y
.8612	a4 39		ldy $39				ldy 	zTemp1+1
.8614	f1 34		sbc ($34),y			sbc 	(basicStack),y
.8616	e6 38		inc $38				inc 	zTemp1 						; bump the indices (inc,dex do not change C or V)
.8618	e6 39		inc $39				inc 	zTemp1+1
.861a	ca		dex				dex 								; do it 4 times.
.861b	d0 f1		bne $860e			bne 	_NCCompare
.861d	50 02		bvc $8621			bvc 	_NCNoOverflow 				; convert to signed comparison
.861f	49 80		eor #$80			eor 	#$80
.8621					_NCNoOverflow:
.8621	7a		ply				ply 								; restore Y position
.8622	0a		asl a				asl 	a 							; is bit 7 set.
.8623	90 04		bcc $8629			bcc 	_NCLoopback 				; if no , >= so loop back
.8625	20 c2 a6	jsr $a6c2			jsr 	StackClose 					; exit the loop
.8628	60		rts				rts
.8629					_NCLoopBack:
.8629	20 f9 a6	jsr $a6f9			jsr 	STKLoadCodePosition 		; loop back
.862c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/gosub.asm

.862d					Command_GOSUB:
.862d	a2 00		ldx #$00			ldx 	#0
.862f	20 8f 9d	jsr $9d8f			jsr 	Evaluate16BitInteger 		; line number in Stack.0
.8632	a9 e3		lda #$e3			lda 	#STK_GOSUB+3
.8634	20 a4 a6	jsr $a6a4			jsr 	StackOpen 					; create frame
.8637	20 e8 a6	jsr $a6e8			jsr 	STKSaveCodePosition 		; save current position
.863a	4c 50 86	jmp $8650			jmp 	GotoStackX
.863d					Command_RETURN:
.863d	a9 e0		lda #$e0			lda 	#STK_GOSUB 					; check TOS is this
.863f	a2 0e		ldx #$0e			ldx 	#ERRID_GOSUB 				; this error
.8641	20 d0 a6	jsr $a6d0			jsr 	StackCheckFrame
.8644	20 f9 a6	jsr $a6f9			jsr 	STKLoadCodePosition 		; restore code position
.8647	20 c2 a6	jsr $a6c2			jsr 	StackClose
.864a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/goto.asm

.864b					GotoCommand:
.864b	a2 00		ldx #$00			ldx 	#0 							; GOTO where
.864d	20 8f 9d	jsr $9d8f			jsr 	Evaluate16BitInteger
.8650					GotoStackX:
.8650	bd 10 04	lda $0410,x			lda  	NSMantissa1,x 				; put line # in XA. I'll keep this even though
.8653	48		pha				pha 								; it is slightly inefficient, just in cases.
.8654	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.8657	fa		plx				plx
.8658	20 c8 a5	jsr $a5c8			jsr 	MemorySearch 				; transfer to line number AX.
.865b	90 05		bcc $8662			bcc 	_GotoError 					; not found, off end.
.865d	d0 03		bne $8662			bne 	_GotoError 					; not found exactly
.865f	4c 0b 8a	jmp $8a0b			jmp 	RunNewLine 					; and go straight to new line code.
.8662					_GotoError:
.8662	a9 0d		lda #$0d		lda	#13
.8664	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/if.asm

.8667					IfCommand:
.8667	a2 00		ldx #$00			ldx 	#0 							; If what.
.8669	20 57 9d	jsr $9d57			jsr 	EvaluateNumber
.866c	b1 30		lda ($30),y			lda 	(codePtr),y
.866e	c9 a8		cmp #$a8			cmp 	#KWD_THEN  					; could be THEN <stuff> or GOTO
.8670	d0 0a		bne $867c			bne 	_IFStructured
.8672	c8		iny				iny 								; consume THEN
.8673	20 5e 9e	jsr $9e5e			jsr 	NSMIsZero 					; is it zero
.8676	f0 01		beq $8679			beq 	_IfFail 					; if fail, go to next line
.8678	60		rts				rts 								; if THEN just continue
.8679					_IfFail:
.8679	4c f3 89	jmp $89f3			jmp 	EOLCommand
.867c					_IfStructured:
.867c	20 5e 9e	jsr $9e5e			jsr 	NSMIsZero 					; is it zero
.867f	d0 07		bne $8688			bne 	_IfExit 					; if not, then continue normally.
.8681	a9 b5		lda #$b5			lda 	#KWD_ELSE 					; look for else/endif
.8683	a2 a5		ldx #$a5			ldx 	#KWD_ENDIF
.8685	20 ad 8c	jsr $8cad			jsr 	ScanForward 				; and run from there/
.8688					_IfExit:
.8688	60		rts				rts
.8689					ElseCode:
.8689	a9 a5		lda #$a5			lda 	#KWD_ENDIF 					; else is only run after the if clause succeeds
.868b	aa		tax				tax 								; so just go to the structure exit
.868c	20 ad 8c	jsr $8cad			jsr 	ScanForward
.868f	60		rts				rts
.8690					EndIf:
.8690	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/let.asm

.8691					LetCommand:
.8691	a2 00		ldx #$00			ldx 	#0
.8693	b1 30		lda ($30),y			lda 	(codePtr),y
.8695	c9 10		cmp #$10			cmp 	#KWD_AT
.8697	d0 16		bne $86af			bne 	_LCStandard
.8699	c8		iny				iny 								; skip equal
.869a	20 f4 97	jsr $97f4			jsr 	EvaluateTerm 				; get a number
.869d	20 38 96	jsr $9638			jsr 	Dereference 				; dereference it
.86a0	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check integer
.86a3	49 20		eor #$20			eor 	#NSBIsReference	 			; toggle reference
.86a5	9d 00 04	sta $0400,x			sta 	NSStatus,x
.86a8	29 20		and #$20			and 	#NSBIsReference 			; if it is now a reference, continue
.86aa	d0 10		bne $86bc			bne 	_LCMain
.86ac	4c c2 9f	jmp $9fc2			jmp 	TypeError 					; was a reference before.
.86af					_LCStandard:
.86af	ad 02 93	lda $9302			lda 	PrecedenceLevel+"*"			; precedence > this
.86b2	20 1c 93	jsr $931c			jsr 	EvaluateExpressionAtPrecedence
.86b5	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; is it a reference to an array
.86b8	c9 38		cmp #$38			cmp		#NSTProcedure+NSBIsReference
.86ba	f0 0e		beq $86ca			beq 	_LetGoProc 					; it's a procedure call.
.86bc					_LCMain:
.86bc	a9 3d		lda #$3d			lda 	#"=" 						; check =
.86be	20 62 8d	jsr $8d62			jsr 	CheckNextA
.86c1	e8		inx				inx 								; RHS
.86c2	20 4e 9d	jsr $9d4e			jsr 	EvaluateValue
.86c5	ca		dex				dex
.86c6	20 cd 86	jsr $86cd			jsr 	AssignVariable
.86c9	60		rts				rts
.86ca					_LetGoProc:
.86ca	4c cb 88	jmp $88cb			jmp 	CallProcedure
.86cd					AssignVariable:
.86cd	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check the string/number type bits match
.86d0	48		pha				pha 								; save a copy
.86d1	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.86d4	29 10		and #$10			and 	#NSBIsString
.86d6	d0 0b		bne $86e3			bne 	_ASError
.86d8	68		pla				pla 								; get back
.86d9	29 10		and #$10			and 	#NSBIsString 				; check type
.86db	d0 03		bne $86e0			bne 	_ASString
.86dd	4c 60 95	jmp $9560			jmp 	AssignNumber
.86e0					_ASString:
.86e0	4c ce 95	jmp $95ce			jmp 	AssignString
.86e3					_ASError:
.86e3	4c c2 9f	jmp $9fc2			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/list.asm

.86e6					Command_List:
.86e6	9c a6 04	stz $04a6			stz 	listIndent 					; reset indent.
.86e9	9c 0c 04	stz $040c			stz		NSMantissa0+4				; set the lower (slot 4) to 0 and upper (slot 7) to $FFFF
.86ec	9c 14 04	stz $0414			stz 	NSMantissa1+4
.86ef	a9 ff		lda #$ff			lda 	#$FF
.86f1	8d 0f 04	sta $040f			sta 	NSMantissa0+7
.86f4	8d 17 04	sta $0417			sta 	NSMantissa1+7
.86f7	b1 30		lda ($30),y			lda 	(codePtr),y
.86f9	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.86fb	f0 1e		beq $871b			beq 	_CLSecond
.86fd	20 7c 87	jsr $877c			jsr 	CLIsDigit 					; if not digit, list all
.8700	b0 24		bcs $8726			bcs 	_CLStart
.8702	a2 04		ldx #$04			ldx 	#4 							; get 1st range into slot 4
.8704	20 8f 9d	jsr $9d8f			jsr 	Evaluate16BitInteger
.8707	b1 30		lda ($30),y			lda 	(codePtr),y
.8709	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.870b	f0 0e		beq $871b			beq 	_CLSecond 					; if so go get it
.870d	ad 0c 04	lda $040c			lda 	NSMantissa0+4 				; copy 4->7
.8710	8d 0f 04	sta $040f			sta 	NSMantissa0+7
.8713	ad 14 04	lda $0414			lda 	NSMantissa1+4
.8716	8d 17 04	sta $0417			sta 	NSMantissa1+7
.8719	80 0b		bra $8726			bra 	_CLStart
.871b					_CLSecond:
.871b	c8		iny				iny 								; consume comma
.871c	20 7c 87	jsr $877c			jsr 	CLIsDigit 					; digit found
.871f	b0 05		bcs $8726			bcs 	_CLStart 					; if not, continue listing
.8721	a2 07		ldx #$07			ldx 	#7 							; load 2nd range into slot 7
.8723	20 8f 9d	jsr $9d8f			jsr 	Evaluate16BitInteger
.8726					_CLStart
.8726	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8728	85 30		sta $30				sta 	codePtr
.872a	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.872c	85 31		sta $31				sta 	codePtr+1
.872e					_CLLoop:
.872e	20 9a aa	jsr $aa9a			jsr 	EXTBreakCheck 				; break check
.8731	f0 33		beq $8766			beq 	_CLExit
.8733	b2 30		lda ($30)			lda 	(codePtr)
.8735	f0 2f		beq $8766			beq 	_CLExit
.8737	a2 04		ldx #$04			ldx 	#4 							; check range every time, line numbers aren't in order.
.8739	20 69 87	jsr $8769			jsr 	CLCompareLineNo
.873c	90 1b		bcc $8759			bcc 	_CLNext
.873e	a2 07		ldx #$07			ldx 	#7
.8740	20 69 87	jsr $8769			jsr 	CLCompareLineNo
.8743	f0 02		beq $8747			beq 	_CLDoThisOne
.8745	b0 12		bcs $8759			bcs 	_CLNext
.8747					_CLDoThisOne:
.8747	20 10 8d	jsr $8d10			jsr 	ScanGetCurrentLineStep 		; get indent adjust.
.874a	20 e4 b3	jsr $b3e4			jsr 	ListConvertLine 			; convert line into token Buffer
.874d	a2 04		ldx #$04			ldx 	#(tokenBuffer >> 8) 		; print that line
.874f	a9 ab		lda #$ab			lda 	#(tokenBuffer & $FF)
.8751	20 c4 8d	jsr $8dc4			jsr 	PrintStringXA
.8754	a9 0d		lda #$0d			lda 	#13 						; new line
.8756	20 e4 a7	jsr $a7e4			jsr 	EXTPrintCharacter
.8759					_CLNext:
.8759	18		clc				clc
.875a	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.875c	65 30		adc $30				adc 	codePtr
.875e	85 30		sta $30				sta 	codePtr
.8760	90 02		bcc $8764			bcc 	_CREExit
.8762	e6 31		inc $31				inc 	codePtr+1
.8764					_CREExit:
.8764	80 c8		bra $872e			bra 	_CLLoop
.8766					_CLExit:
.8766	4c 59 83	jmp $8359			jmp 	WarmStart
.8769					CLCompareLineNo:
.8769	38		sec				sec
.876a	a0 01		ldy #$01			ldy 	#1
.876c	b1 30		lda ($30),y			lda 	(codePtr),y
.876e	fd 08 04	sbc $0408,x			sbc 	NSMantissa0,x
.8771	85 36		sta $36				sta 	zTemp0
.8773	c8		iny				iny
.8774	b1 30		lda ($30),y			lda 	(codePtr),y
.8776	fd 10 04	sbc $0410,x			sbc 	NSMantissa1,x
.8779	05 36		ora $36				ora 	zTemp0
.877b	60		rts				rts
.877c					CLIsDigit:
.877c	b1 30		lda ($30),y			lda 	(codePtr),y
.877e	c9 30		cmp #$30			cmp 	#"0"
.8780	90 03		bcc $8785			bcc	 	_CLIDExitFalse
.8782	c9 3a		cmp #$3a			cmp 	#"9"+1
.8784	60		rts				rts
.8785					_CLIDExitFalse:
.8785	38		sec				sec
.8786	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/local.asm

.8787					Command_LOCAL:
.8787	a2 00		ldx #$00			ldx 	#0 							; at level 0
.8789	20 95 87	jsr $8795			jsr 	LocaliseNextTerm 			; convert term to a local.
.878c	b1 30		lda ($30),y			lda 	(codePtr),y
.878e	c8		iny				iny
.878f	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8791	f0 f4		beq $8787			beq 	Command_LOCAL
.8793	88		dey				dey 								; unpick pre-get
.8794	60		rts				rts
.8795					LocaliseNextTerm:
.8795	20 f4 97	jsr $97f4			jsr 	EvaluateTerm 				; evaluate the term
.8798	bd 00 04	lda $0400,x			lda 	NSStatus,x
.879b	29 20		and #$20			and 	#NSBIsReference 			; check it is a reference
.879d	f0 61		beq $8800			beq		_LNTError
.879f	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address of variable to zTemp0
.87a2	85 36		sta $36				sta 	zTemp0
.87a4	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.87a7	85 37		sta $37				sta  	zTemp0+1
.87a9	bd 00 04	lda $0400,x			lda 	NSStatus,x
.87ac	29 10		and #$10			and 	#NSBIsString
.87ae	d0 1e		bne $87ce			bne 	_LNTPushString
.87b0	5a		phy				phy
.87b1	a0 00		ldy #$00			ldy 	#0 							; push 0 to 4 inclusive, the number values, on the stack, and zero them as you go.
.87b3					_LNTPushNumLoop:
.87b3	b1 36		lda ($36),y			lda		(zTemp0),y
.87b5	20 82 a6	jsr $a682			jsr 	StackPushByte
.87b8	c8		iny				iny
.87b9	c0 05		cpy #$05			cpy 	#5
.87bb	d0 f6		bne $87b3			bne 	_LNTPushNumLoop
.87bd	a5 36		lda $36				lda 	zTemp0 						; push the actual target address to write on the stack
.87bf	20 82 a6	jsr $a682			jsr 	StackPushByte
.87c2	a5 37		lda $37				lda 	zTemp0+1
.87c4	20 82 a6	jsr $a682			jsr 	StackPushByte
.87c7	a9 01		lda #$01			lda 	#STK_LOCALN 				; push local-number marker.
.87c9	20 82 a6	jsr $a682			jsr 	StackPushByte
.87cc	7a		ply				ply
.87cd	60		rts				rts
.87ce					_LNTPushString:
.87ce	5a		phy				phy
.87cf	b2 36		lda ($36)			lda 	(zTemp0) 					; put address of string in zTemp1
.87d1	85 38		sta $38				sta 	zTemp1
.87d3	a0 01		ldy #$01			ldy 	#1
.87d5	b1 36		lda ($36),y			lda 	(zTemp0),y
.87d7	85 39		sta $39				sta 	zTemp1+1
.87d9	a0 00		ldy #$00			ldy 	#0 							; output string
.87db	c9 00		cmp #$00			cmp 	#0 							; if not assigned strin
.87dd	f0 0a		beq $87e9			beq 	_LNTStringOut
.87df					_LNTPushStrLoop:
.87df	b1 38		lda ($38),y			lda 	(zTemp1),y
.87e1	f0 06		beq $87e9			beq 	_LNTStringOut
.87e3	20 82 a6	jsr $a682			jsr 	StackPushByte
.87e6	c8		iny				iny
.87e7	80 f6		bra $87df			bra 	_LNTPushStrLoop
.87e9					_LNTStringOut:
.87e9	98		tya				tya									; output length
.87ea	20 82 a6	jsr $a682			jsr 	StackPushByte
.87ed	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; output address of the string record *not* the string itself
.87f0	20 82 a6	jsr $a682			jsr 	StackPushByte
.87f3	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.87f6	20 82 a6	jsr $a682			jsr 	StackPushByte
.87f9	a9 02		lda #$02			lda 	#STK_LOCALS 				; push local-string marker.
.87fb	20 82 a6	jsr $a682			jsr 	StackPushByte
.87fe	7a		ply				ply
.87ff	60		rts				rts
.8800					_LNTError:
.8800	4c b8 9f	jmp $9fb8			jmp 	SyntaxError
.8803					LocalPopValue:
.8803	20 9b a6	jsr $a69b			jsr 	StackPopByte
.8806	c9 01		cmp #$01			cmp 	#STK_LOCALN 				; if not local-N
.8808	d0 17		bne $8821			bne 	_LPVString
.880a	20 9b a6	jsr $a69b			jsr 	StackPopByte 				; address
.880d	85 37		sta $37				sta 	zTemp0+1
.880f	20 9b a6	jsr $a69b			jsr 	StackPopByte
.8812	85 36		sta $36				sta 	zTemp0
.8814	5a		phy				phy
.8815	a0 04		ldy #$04			ldy 	#4 							; copy back
.8817					_LPVNumberCopy:
.8817	20 9b a6	jsr $a69b			jsr 	StackPopByte
.881a	91 36		sta ($36),y			sta 	(zTemp0),y
.881c	88		dey				dey
.881d	10 f8		bpl $8817			bpl 	_LPVNumberCopy
.881f	7a		ply				ply 								; and complete
.8820	60		rts				rts
.8821					_LPVString:
.8821	20 9b a6	jsr $a69b			jsr 	StackPopByte 				; address of record => zTemp0
.8824	85 37		sta $37				sta 	zTemp0+1
.8826	20 9b a6	jsr $a69b			jsr 	StackPopByte
.8829	85 36		sta $36				sta 	zTemp0
.882b	5a		phy				phy
.882c	b2 36		lda ($36)			lda 	(zTemp0) 					; address to write string to => zTemp1
.882e	85 38		sta $38				sta 	zTemp1
.8830	a0 01		ldy #$01			ldy 	#1
.8832	b1 36		lda ($36),y			lda 	(zTemp0),y
.8834	85 39		sta $39				sta 	zTemp1+1
.8836	20 9b a6	jsr $a69b			jsr 	StackPopByte 				; # to get => y
.8839	a8		tay				tay
.883a	a5 39		lda $39				lda 	zTemp1+1 					; if no target (e.g. was "" originally) exit
.883c	f0 0e		beq $884c			beq 	_LPVStringCopied
.883e	a9 00		lda #$00			lda 	#0 							; NULL on end
.8840	91 38		sta ($38),y			sta 	(zTemp1),y
.8842					_LPVStringCopy:
.8842	88		dey				dey
.8843	30 07		bmi $884c			bmi 	_LPVStringCopied
.8845	20 9b a6	jsr $a69b			jsr 	StackPopByte
.8848	91 38		sta ($38),y			sta 	(zTemp1),y
.884a	80 f6		bra $8842			bra 	_LPVStringCopy
.884c					_LPVStringCopied:
.884c	fa		plx				plx
.884d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/new.asm

.884e					NewCommand:
.884e	20 54 88	jsr $8854			jsr 	NewProgram
.8851	4c 59 83	jmp $8359			jmp 	WarmStart
.8854					NewProgram:
.8854	20 a6 a5	jsr $a5a6			jsr 	MemoryNew
.8857	9c 00 10	stz $1000			stz 	VariableSpace 				; erase all variables.
.885a	20 f2 83	jsr $83f2			jsr 	ClearCommand 				; clear everything.
.885d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/print.asm

.885e					Command_Print:
.885e	18		clc				clc 								; carry being clear means last print wasn't comma/semicolon
.885f					_CPLoop:
.885f	08		php				php 								; save last action flag
.8860	b1 30		lda ($30),y			lda 	(codePtr),y
.8862	c9 80		cmp #$80			cmp  	#KWC_EOL 					; end of line or colon, exit now.
.8864	f0 46		beq $88ac			beq 	_CPExit
.8866	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.8868	f0 42		beq $88ac			beq 	_CPExit
.886a	68		pla				pla 								; throw last action flag
.886b	b1 30		lda ($30),y			lda 	(codePtr),y
.886d	c8		iny				iny
.886e	c9 3b		cmp #$3b			cmp 	#KWD_SEMICOLON				; is it a semicolon
.8870	f0 37		beq $88a9			beq 	_CPContinueWithSameLine
.8872	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; comma
.8874	f0 2e		beq $88a4			beq 	_CPTab
.8876	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; apostrophe (new line)
.8878	f0 26		beq $88a0			beq 	_CPNewLine
.887a	88		dey				dey 								; undo the get.
.887b	a2 00		ldx #$00			ldx 	#0
.887d	20 4e 9d	jsr $9d4e			jsr 	EvaluateValue 				; get a value into slot 0
.8880	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; is it a number
.8883	29 10		and #$10			and 	#NSBIsString
.8885	f0 0b		beq $8892			beq 	_CPNumber
.8887	ae 10 04	ldx $0410			ldx 	NSMantissa1 				; string, print the text.
.888a	ad 08 04	lda $0408			lda 	NSMantissa0
.888d	20 b5 88	jsr $88b5			jsr 	CPPrintStringXA
.8890	80 cc		bra $885e			bra 	Command_Print 				; loop round clearing carry so NL if end
.8892					_CPNumber:
.8892	a9 05		lda #$05			lda 	#5 							; maximum decimals
.8894	20 24 9c	jsr $9c24			jsr 	ConvertNumberToString 		; convert to string
.8897	a2 06		ldx #$06			ldx 	#DecimalBuffer >> 8
.8899	a9 1b		lda #$1b			lda 	#DecimalBuffer & $FF
.889b	20 b5 88	jsr $88b5			jsr 	CPPrintStringXA
.889e	80 be		bra $885e			bra 	Command_Print 				; loop round clearing carry so NL if end
.88a0					_CPNewLine:
.88a0	a9 0d		lda #$0d			lda 	#13
.88a2	80 02		bra $88a6			bra 	_CPPrintChar
.88a4					_CPTab:
.88a4	a9 09		lda #$09			lda 	#9 							; print TAB
.88a6					_CPPrintChar:
.88a6	20 c8 88	jsr $88c8			jsr 	CPPrintVector
.88a9					_CPContinueWithSameLine:
.88a9	38		sec				sec 								; loop round with carry set, which
.88aa	80 b3		bra $885f			bra 	_CPLoop 					; will inhibit final CR
.88ac					_CPExit:
.88ac	28		plp				plp 								; get last action flag
.88ad	b0 05		bcs $88b4			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.88af	a9 0d		lda #$0d			lda 	#13 						; print new line
.88b1	20 c8 88	jsr $88c8			jsr 	CPPrintVector
.88b4					_CPExit2:
.88b4	60		rts				rts
.88b5					CPPrintStringXA:
.88b5	5a		phy				phy
.88b6	86 37		stx $37				stx 	zTemp0+1
.88b8	85 36		sta $36				sta 	zTemp0
.88ba	a0 00		ldy #$00			ldy 	#0
.88bc					_PSXALoop:
.88bc	b1 36		lda ($36),y			lda 	(zTemp0),y
.88be	f0 06		beq $88c6			beq 	_PSXAExit
.88c0	20 c8 88	jsr $88c8			jsr 	CPPrintVector
.88c3	c8		iny				iny
.88c4	80 f6		bra $88bc			bra 	_PSXALoop
.88c6					_PSXAExit:
.88c6	7a		ply				ply
.88c7	60		rts				rts
.88c8					CPPrintVector:
.88c8	4c e4 a7	jmp $a7e4			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/procedure.asm

=2					ParameterStackPos = 2
.88cb					CallProcedure:
.88cb	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start storing parameters at 2.
.88cd	b1 30		lda ($30),y			lda 	(codePtr),y
.88cf	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.88d1	f0 0c		beq $88df			beq 	_CPEndParam
.88d3					_CPParamLoop:
.88d3	20 4e 9d	jsr $9d4e			jsr 	EvaluateValue 				; get parameter onto stack
.88d6	e8		inx				inx 								; bump next stack
.88d7	b1 30		lda ($30),y			lda 	(codePtr),y
.88d9	c8		iny				iny
.88da	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if comma, go back and try again.
.88dc	f0 f5		beq $88d3			beq 	_CPParamLoop
.88de	88		dey				dey 								; unpick.
.88df					_CPEndParam:
.88df	8e 96 04	stx $0496			stx 	LastParameter 				; save the last parameters index.
.88e2	c8		iny				iny									; skip right bracket
.88e3	a9 b3		lda #$b3			lda 	#STK_PROC+3 				; allocate 6 bytes on the return stack.
.88e5	20 a4 a6	jsr $a6a4			jsr 	StackOpen
.88e8	20 e8 a6	jsr $a6e8			jsr 	STKSaveCodePosition 		; save loop position
.88eb	ad 08 04	lda $0408			lda 	NSMantissa0 				; copy variable (e.g. procedure) address to zTemp0
.88ee	85 36		sta $36				sta 	zTemp0 						; this is the DATA not the RECORD
.88f0	ad 10 04	lda $0410			lda 	NSMantissa1
.88f3	85 37		sta $37				sta 	zTemp0+1
.88f5	a0 01		ldy #$01			ldy 	#1 							; copy code address back.
.88f7	b2 36		lda ($36)			lda 	(zTemp0)
.88f9	85 30		sta $30				sta 	safePtr
.88fb	b1 36		lda ($36),y			lda 	(zTemp0),y
.88fd	85 31		sta $31				sta 	safePtr+1
.88ff	c8		iny				iny
.8900	b1 36		lda ($36),y			lda 	(zTemp0),y
.8902	85 32		sta $32				sta 	safePtr+2
.8904	c8		iny				iny
.8905	b1 36		lda ($36),y			lda 	(zTemp0),y
.8907	85 33		sta $33				sta 	safePtr+3
.8909	c8		iny				iny 								; get Y offset -> Y
.890a	b1 36		lda ($36),y			lda 	(zTemp0),y
.890c	a8		tay				tay
.890d	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start position of parameters
.890f	ec 96 04	cpx $0496			cpx	 	LastParameter 				; check no parameters at the start
.8912	f0 13		beq $8927			beq 	_ParamExit 					; if so, exit.
.8914					_ParamExtract:
.8914	ca		dex				dex 								; put a local term on the level before
.8915	20 95 87	jsr $8795			jsr 	LocaliseNextTerm			; also pushes original param value to basic stack
.8918	20 cd 86	jsr $86cd			jsr 	AssignVariable 				; assign stacked value to the variable.
.891b	e8		inx				inx 								; advance to next parameter to do.
.891c	e8		inx				inx
.891d	ec 96 04	cpx $0496			cpx 	LastParameter 				; are we done ?
.8920	f0 05		beq $8927			beq 	_ParamExit
.8922	20 5a 8d	jsr $8d5a			jsr 	CheckComma 					; comma seperating parameters
.8925	80 ed		bra $8914			bra 	_ParamExtract
.8927					_ParamExit:
.8927	20 52 8d	jsr $8d52			jsr 	CheckRightBracket 			; check )
.892a	60		rts				rts 								; and continue from here
.892b					Command_ENDPROC:
.892b	a9 b0		lda #$b0			lda 	#STK_PROC 					; check TOS is this
.892d	a2 14		ldx #$14			ldx 	#ERRID_PROC
.892f	20 d0 a6	jsr $a6d0			jsr 	StackCheckFrame
.8932	20 f9 a6	jsr $a6f9			jsr 	STKLoadCodePosition 		; restore code position
.8935	20 c2 a6	jsr $a6c2			jsr 	StackClose
.8938	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/read.asm

.8939					Command_Read:
.8939	a2 00		ldx #$00			ldx 	#0 							; evaluate the term which is the var/array element to assign
.893b	20 f4 97	jsr $97f4			jsr 	EvaluateTerm
.893e	bd 00 04	lda $0400,x			lda 	NSStatus,x
.8941	29 20		and #$20			and 	#NSBIsReference				; get status byte on stack, identifies int, float, string.
.8943	f0 4a		beq $898f			beq 	_CRSyntax 					; check reference (bit 0)
.8945	20 d8 89	jsr $89d8			jsr 	SwapDataCodePtrs 			; swap code and data
.8948	ad 9c 04	lda $049c			lda 	inDataStatement 			; if in a data statement, we don't need to search
.894b	d0 20		bne $896d			bne 	_CRContinueData
.894d					_CRKeepSearching:
.894d	a9 b2		lda #$b2			lda 	#KWD_DATA 					; scan for instruction
.894f	aa		tax				tax
.8950	20 ad 8c	jsr $8cad			jsr 	ScanForward
.8953	c9 b2		cmp #$b2			cmp 	#KWD_DATA 					; found data ?
.8955	f0 16		beq $896d			beq 	_CRHaveData 				; found it
.8957	18		clc				clc
.8958	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.895a	65 30		adc $30				adc 	codePtr
.895c	85 30		sta $30				sta 	codePtr
.895e	90 02		bcc $8962			bcc 	_CREExit
.8960	e6 31		inc $31				inc 	codePtr+1
.8962					_CREExit:
.8962	a0 03		ldy #$03			ldy 	#3 							; start of line.
.8964	b2 30		lda ($30)			lda 	(codePtr)
.8966	d0 e5		bne $894d			bne 	_CRKeepSearching
.8968	a9 0b		lda #$0b		lda	#11
.896a	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler
.896d					_CRHaveData:
.896d					_CRContinueData:
.896d	a2 01		ldx #$01			ldx 	#1
.896f	20 4e 9d	jsr $9d4e			jsr 	EvaluateValue 				; evaluate value into slot # 1
.8972	ca		dex				dex
.8973	20 cd 86	jsr $86cd			jsr		AssignVariable 				; do the assignment
.8976	9c 9c 04	stz $049c			stz 	inDataStatement 			; clear in data
.8979	b1 30		lda ($30),y			lda 	(codePtr),y
.897b	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not, end of data statement
.897d	d0 04		bne $8983			bne 	_CRSwapBack
.897f	c8		iny				iny 								; consume comma
.8980	ee 9c 04	inc $049c			inc 	inDataStatement 			; set in data statement currently.
.8983					_CRSwapBack:
.8983	20 d8 89	jsr $89d8			jsr 	SwapDataCodePtrs			; swap them back.
.8986	b1 30		lda ($30),y			lda 	(codePtr),y
.8988	c8		iny				iny
.8989	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.898b	f0 ac		beq $8939			beq 	Command_Read 				; if so go round again.
.898d	88		dey				dey 								; unpick get.
.898e	60		rts				rts
.898f					_CRSyntax:
.898f	4c b8 9f	jmp $9fb8			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/rem.asm

.8992					RemCommand:
.8992	b1 30		lda ($30),y			lda 	(codePtr),y
.8994	c9 ff		cmp #$ff			cmp 	#KWC_STRING
.8996	d0 06		bne $899e			bne 	_RMExit
.8998	c8		iny				iny
.8999	98		tya				tya
.899a	38		sec				sec
.899b	71 30		adc ($30),y			adc 	(codePtr),y
.899d	a8		tay				tay
.899e					_RMExit:
.899e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/repeat.asm

.899f					Command_REPEAT:
.899f	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; allocate 6 bytes on the return stack.
.89a1	20 a4 a6	jsr $a6a4			jsr 	StackOpen
.89a4	20 e8 a6	jsr $a6e8			jsr 	STKSaveCodePosition 		; save loop position
.89a7	60		rts				rts
.89a8					Command_UNTIL:
.89a8	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; check REPEAT is TOS
.89aa	a2 0f		ldx #$0f			ldx 	#ERRID_REPEAT 				; this error
.89ac	20 d0 a6	jsr $a6d0			jsr 	StackCheckFrame
.89af	a2 00		ldx #$00			ldx 	#0
.89b1	20 57 9d	jsr $9d57			jsr 	EvaluateNumber 				; work out the number
.89b4	20 5e 9e	jsr $9e5e			jsr 	NSMIsZero 					; check if zero
.89b7	f0 04		beq $89bd			beq 	_CULoopBack 				; if so keep looping
.89b9	20 c2 a6	jsr $a6c2			jsr 	StackClose		 			; return
.89bc	60		rts				rts
.89bd					_CULoopBack:
.89bd	20 f9 a6	jsr $a6f9			jsr 	STKLoadCodePosition 		; loop back
.89c0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/restore.asm

.89c1					Command_Restore:
.89c1	20 d8 89	jsr $89d8			jsr 	SwapDataCodePtrs 			; swap code and data
.89c4	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.89c6	85 30		sta $30				sta 	codePtr
.89c8	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.89ca	85 31		sta $31				sta 	codePtr+1
.89cc	20 d8 89	jsr $89d8			jsr 	SwapDataCodePtrs 			; put them back
.89cf	a9 03		lda #$03			lda 	#3 							; start at offset 3, e.g. first instruction of first line.
.89d1	8d 9b 04	sta $049b			sta 	dataPointer+4
.89d4	9c 9c 04	stz $049c			stz 	inDataStatement 			; not in data statement
.89d7	60		rts				rts
.89d8					SwapDataCodePtrs:
.89d8	da		phx				phx
.89d9	a2 03		ldx #$03			ldx 	#3 							; swap 32 bit code pointer over
.89db					_SDCPLoop:
.89db	b5 30		lda $30,x			lda 	safePtr,x
.89dd	48		pha				pha
.89de	bd 97 04	lda $0497,x			lda 	dataPointer,x
.89e1	95 30		sta $30,x			sta 	safePtr,x
.89e3	68		pla				pla
.89e4	9d 97 04	sta $0497,x			sta 	dataPointer,x
.89e7	ca		dex				dex
.89e8	10 f1		bpl $89db			bpl 	_SDCPLoop
.89ea	ad 9b 04	lda $049b			lda 	dataPointer+4 				; swap Y position over.
.89ed	8c 9b 04	sty $049b			sty 	dataPointer+4
.89f0	a8		tay				tay
.89f1	fa		plx				plx
.89f2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/run.asm

.89f3					EOLCommand:
.89f3	18		clc				clc
.89f4	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.89f6	65 30		adc $30				adc 	codePtr
.89f8	85 30		sta $30				sta 	codePtr
.89fa	90 02		bcc $89fe			bcc 	_CREExit
.89fc	e6 31		inc $31				inc 	codePtr+1
.89fe					_CREExit:
.89fe	80 0b		bra $8a0b			bra 	RunNewLine
.8a00					CommandRUN:
.8a00	20 f2 83	jsr $83f2			jsr 	ClearCommand 				; clear variable/stacks/etc.
.8a03	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8a05	85 30		sta $30				sta 	codePtr
.8a07	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8a09	85 31		sta $31				sta 	codePtr+1
.8a0b					RUNNewLine:
.8a0b	b2 30		lda ($30)			lda 	(codePtr)
.8a0d	f0 72		beq $8a81			beq 	CRNoProgram         		; no then END.
.8a0f	a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack
.8a11	9a		txs				txs
.8a12					RUNCodePointerLine:
.8a12	a0 02		ldy #$02			ldy 	#2 							; start of program
.8a14					_CRIncMainLoop:
.8a14	0e 93 04	asl $0493			asl 	breakCheck 					; clears 1 time in 8
.8a17	d0 19		bne $8a32			bne 	_CRNoBreakCheck
.8a19	20 9a aa	jsr $aa9a			jsr 	EXTBreakCheck 				; break check
.8a1c	f0 5e		beq $8a7c			beq 	_CRBreak
.8a1e	64 01		stz $01				stz 	1 							; access I/O Page 0
.8a20	38		sec				sec 								; calculate timer - LastTick
.8a21	ad 59 d6	lda $d659			lda 	$D659
.8a24	aa		tax				tax 								; saving timer in X
.8a25	ed 2d 06	sbc $062d			sbc 	LastTick
.8a28	c9 03		cmp #$03			cmp 	#3
.8a2a	90 06		bcc $8a32			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.8a2c	8e 2d 06	stx $062d			stx 	LastTick 					; update last timer
.8a2f	20 ff b9	jsr $b9ff			jsr 	TickHandler 				; go do the code.
.8a32					_NoFireTick:
.8a32					_CRNoBreakCheck:
.8a32	c8		iny				iny
.8a33					_CRMainLoop:
.8a33	9c 90 04	stz $0490			stz 	stringInitialised 			; clear the temporary string initialised flag.
.8a36	b1 30		lda ($30),y			lda 	(codePtr),y
.8a38	10 10		bpl $8a4a			bpl 	_CRNotKeyword
.8a3a	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1 			; if after unary, legitimate command
.8a3c	b0 04		bcs $8a42			bcs 	_CRIsKeyword
.8a3e	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if unary, syntax error.
.8a40	b0 34		bcs $8a76			bcs		_CRSyntaxError
.8a42					_CRIsKeyword:
.8a42	c8		iny				iny 								; consume command
.8a43	0a		asl a				asl 	a 							; double losing the MSB which is '1' as tokens are $80-$FF
.8a44	aa		tax				tax 								; put in X for vector jump
.8a45	20 79 8a	jsr $8a79			jsr 	_CRCallVector0 				; call the vector - effectively jsr (vectortable,X)
.8a48	80 e9		bra $8a33			bra 	_CRMainLoop 				; and loop round
.8a4a					_CRNotKeyword:
.8a4a	c9 3a		cmp #$3a			cmp 	#KWD_COLON 					; if a :, consume it and go round.
.8a4c	f0 c6		beq $8a14			beq 	_CRIncMainLoop
.8a4e	c9 40		cmp #$40			cmp 	#$40 						; variable/call reference
.8a50	90 05		bcc $8a57			bcc 	_CRNotVariable
.8a52					_CRGoLet:
.8a52	20 91 86	jsr $8691			jsr 	LetCommand
.8a55	80 dc		bra $8a33			bra 	_CRMainLoop
.8a57					_CRNotVariable:
.8a57	c9 10		cmp #$10			cmp 	#KWD_AT 					; handle @
.8a59	f0 f7		beq $8a52			beq 	_CRGoLet
.8a5b	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; handle ? !
.8a5d	f0 f3		beq $8a52			beq 	_CRGoLet
.8a5f	c9 21		cmp #$21			cmp 	#KWD_PLING
.8a61	f0 ef		beq $8a52			beq 	_CRGoLet
.8a63	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; handle ' (comment)
.8a65	f0 09		beq $8a70			beq 	_CRGoRem
.8a67	c9 2e		cmp #$2e			cmp 	#KWD_PERIOD 				; handle . (assembler label)
.8a69	d0 0b		bne $8a76			bne 	_CRSyntaxError
.8a6b	20 12 82	jsr $8212			jsr 	LabelHere
.8a6e	80 c3		bra $8a33			bra 	_CRMainLoop
.8a70					_CRGoRem:
.8a70	c8		iny				iny
.8a71	20 92 89	jsr $8992			jsr 	RemCommand
.8a74	80 bd		bra $8a33			bra 	_CRMainLoop
.8a76					_CRSyntaxError:
.8a76	4c b8 9f	jmp $9fb8			jmp 	SyntaxError
.8a79					_CRCallVector0:
.8a79	7c 18 8b	jmp ($8b18,x)			jmp 	(VectorSet0,x)
.8a7c					_CRBreak:
.8a7c	a9 01		lda #$01		lda	#1
.8a7e	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler
.8a81					CRNoProgram:
.8a81	4c 17 85	jmp $8517			jmp 	EndCommand
.8a84					Shift1Command:
.8a84	b1 30		lda ($30),y			lda 	(codePtr),y
.8a86	c8		iny				iny
.8a87	0a		asl a				asl 	a
.8a88	aa		tax				tax
.8a89	7c b4 8b	jmp ($8bb4,x)			jmp 	(VectorSet1,x)
.8a8c					Shift2Command:
.8a8c	b1 30		lda ($30),y			lda 	(codePtr),y
.8a8e	c8		iny				iny
.8a8f	0a		asl a				asl 	a
.8a90	aa		tax				tax
.8a91	7c ce 8b	jmp ($8bce,x)			jmp 	(VectorSet2,x)
.8a94					Unused1:
.8a94					Unused2:
.8a94					Unused3:
.8a94					Unused4:
.8a94	4c b8 9f	jmp $9fb8			jmp 	SyntaxError
>8a97							.align 2

;******  Processing file: ./common/commands/../generated/vectors.dat

.8a98					VectorSetPunc:
>8a98	58 90					.word	ShiftLeft                        ; $00 <<
>8a9a	0f 8e					.word	BinaryCompareLessEqual           ; $01 <=
>8a9c	05 8e					.word	BinaryCompareNotEqual            ; $02 <>
>8a9e	b8 9f					.word	SyntaxError                      ; $03 !!3
>8aa0	b8 9f					.word	SyntaxError                      ; $04 ><
>8aa2	19 8e					.word	BinaryCompareGreaterEqual        ; $05 >=
>8aa4	5b 90					.word	ShiftRight                       ; $06 >>
>8aa6	b8 9f					.word	SyntaxError                      ; $07 !!7
>8aa8	b8 9f					.word	SyntaxError                      ; $08 !!8
>8aaa	b8 9f					.word	SyntaxError                      ; $09 !!9
>8aac	b8 9f					.word	SyntaxError                      ; $0a !!10
>8aae	b8 9f					.word	SyntaxError                      ; $0b !!11
>8ab0	b8 9f					.word	SyntaxError                      ; $0c !!12
>8ab2	b8 9f					.word	SyntaxError                      ; $0d !!13
>8ab4	b8 9f					.word	SyntaxError                      ; $0e !!14
>8ab6	b8 9f					.word	SyntaxError                      ; $0f !!15
>8ab8	b8 9f					.word	SyntaxError                      ; $10 @
>8aba	b8 9f					.word	SyntaxError                      ; $11 !!17
>8abc	b8 9f					.word	SyntaxError                      ; $12 !!18
>8abe	b8 9f					.word	SyntaxError                      ; $13 [
>8ac0	dc 8e					.word	IntegerDivide                    ; $14 \
>8ac2	b8 9f					.word	SyntaxError                      ; $15 ]
>8ac4	e9 91					.word	EorInteger                       ; $16 ^
>8ac6	b8 9f					.word	SyntaxError                      ; $17 _
>8ac8	b8 9f					.word	SyntaxError                      ; $18 `
>8aca	b8 9f					.word	SyntaxError                      ; $19 !!25
>8acc	b8 9f					.word	SyntaxError                      ; $1a !!26
>8ace	b8 9f					.word	SyntaxError                      ; $1b {
>8ad0	a3 91					.word	OraInteger                       ; $1c |
>8ad2	b8 9f					.word	SyntaxError                      ; $1d }
>8ad4	b8 9f					.word	SyntaxError                      ; $1e ~
>8ad6	b8 9f					.word	SyntaxError                      ; $1f [7m<7F>[m
>8ad8	b8 9f					.word	SyntaxError                      ; $20
>8ada	2f 92					.word	WordIndirect                     ; $21 !
>8adc	b8 9f					.word	SyntaxError                      ; $22 "
>8ade	b8 9f					.word	SyntaxError                      ; $23 #
>8ae0	b8 9f					.word	SyntaxError                      ; $24 $
>8ae2	29 8f					.word	IntegerModulus                   ; $25 %
>8ae4	5d 91					.word	AndInteger                       ; $26 &
>8ae6	b8 9f					.word	SyntaxError                      ; $27 '
>8ae8	b8 9f					.word	SyntaxError                      ; $28 (
>8aea	b8 9f					.word	SyntaxError                      ; $29 )
>8aec	9e 8f					.word	MulInteger                       ; $2a *
>8aee	ef 90					.word	AddInteger                       ; $2b +
>8af0	b8 9f					.word	SyntaxError                      ; $2c ,
>8af2	32 91					.word	SubInteger                       ; $2d -
>8af4	b8 9f					.word	SyntaxError                      ; $2e .
>8af6	1a 94					.word	FDivideCommand                   ; $2f /
>8af8	b8 9f					.word	SyntaxError                      ; $30 0
>8afa	b8 9f					.word	SyntaxError                      ; $31 1
>8afc	b8 9f					.word	SyntaxError                      ; $32 2
>8afe	b8 9f					.word	SyntaxError                      ; $33 3
>8b00	b8 9f					.word	SyntaxError                      ; $34 4
>8b02	b8 9f					.word	SyntaxError                      ; $35 5
>8b04	b8 9f					.word	SyntaxError                      ; $36 6
>8b06	b8 9f					.word	SyntaxError                      ; $37 7
>8b08	b8 9f					.word	SyntaxError                      ; $38 8
>8b0a	b8 9f					.word	SyntaxError                      ; $39 9
>8b0c	b8 9f					.word	SyntaxError                      ; $3a :
>8b0e	b8 9f					.word	SyntaxError                      ; $3b ;
>8b10	f1 8d					.word	BinaryCompareLess                ; $3c <
>8b12	e7 8d					.word	BinaryCompareEqual               ; $3d =
>8b14	fb 8d					.word	BinaryCompareGreater             ; $3e >
>8b16	56 92					.word	ByteIndirect                     ; $3f ?
.8b18					VectorSet0:
>8b18	f3 89					.word	EOLCommand                       ; $80 !0:EOF
>8b1a	84 8a					.word	Shift1Command                    ; $81 !1:SH1
>8b1c	8c 8a					.word	Shift2Command                    ; $82 !2:SH2
>8b1e	8a 99					.word	AbsUnary                         ; $83 ABS(
>8b20	9a 99					.word	AllocUnary                       ; $84 ALLOC(
>8b22	0a 9a					.word	AscUnary                         ; $85 ASC(
>8b24	d5 9b					.word	ChrUnary                         ; $86 CHR$(
>8b26	29 a4					.word	UnaryEvent                       ; $87 EVENT(
>8b28	e3 8d					.word	UnaryFalse                       ; $88 FALSE
>8b2a	17 9a					.word	FracUnary                        ; $89 FRAC(
>8b2c	bf a3					.word	UnaryHit                         ; $8a HIT(
>8b2e	2d 9a					.word	IntUnary                         ; $8b INT(
>8b30	94 9b					.word	IsValUnary                       ; $8c ISVAL(
>8b32	b9 a4					.word	UnaryJoyB                        ; $8d JOYB(
>8b34	92 a4					.word	UnaryJoyX                        ; $8e JOYX(
>8b36	95 a4					.word	UnaryJoyY                        ; $8f JOYY(
>8b38	af 9c					.word	Unary_Left                       ; $90 LEFT$(
>8b3a	3f 9a					.word	LenUnary                         ; $91 LEN(
>8b3c	5d 9a					.word	Unary_Max                        ; $92 MAX(
>8b3e	d9 9c					.word	Unary_Mid                        ; $93 MID$(
>8b40	59 9a					.word	Unary_Min                        ; $94 MIN(
>8b42	b4 9a					.word	Unary_Not                        ; $95 NOT(
>8b44	fb a5					.word	UnaryPlaying                     ; $96 PLAYING(
>8b46	ca 9a					.word	Unary_Random                     ; $97 RANDOM(
>8b48	bf 9c					.word	Unary_Right                      ; $98 RIGHT$(
>8b4a	e9 9a					.word	Unary_Rnd                        ; $99 RND(
>8b4c	6a 9b					.word	SgnUnary                         ; $9a SGN(
>8b4e	e7 9b					.word	SpcUnary                         ; $9b SPC(
>8b50	02 9c					.word	Unary_Str                        ; $9c STR$(
>8b52	cd a4					.word	UnaryTimer                       ; $9d TIMER(
>8b54	d7 8d					.word	UnaryTrue                        ; $9e TRUE
>8b56	8a 9b					.word	ValUnary                         ; $9f VAL(
>8b58	1a 85					.word	ForCommand                       ; $a0 FOR
>8b5a	67 86					.word	IfCommand                        ; $a1 IF
>8b5c	94 8a					.word	Unused1                          ; $a2 PROC
>8b5e	9f 89					.word	Command_REPEAT                   ; $a3 REPEAT
>8b60	23 8d					.word	Command_WHILE                    ; $a4 WHILE
>8b62	90 86					.word	EndIf                            ; $a5 ENDIF
>8b64	2b 89					.word	Command_ENDPROC                  ; $a6 ENDPROC
>8b66	d4 85					.word	NextCommand                      ; $a7 NEXT
>8b68	94 8a					.word	Unused4                          ; $a8 THEN
>8b6a	a8 89					.word	Command_UNTIL                    ; $a9 UNTIL
>8b6c	44 8d					.word	Command_WEND                     ; $aa WEND
>8b6e	b8 9f					.word	SyntaxError                      ; $ab BY
>8b70	b8 83					.word	CallCommand                      ; $ac CALL
>8b72	61 a1					.word	CircleCommand                    ; $ad CIRCLE
>8b74	f2 83					.word	ClearCommand                     ; $ae CLEAR
>8b76	4a 84					.word	ClearScreen                      ; $af CLS
>8b78	b8 9f					.word	SyntaxError                      ; $b0 COLOR
>8b7a	b8 9f					.word	SyntaxError                      ; $b1 COLOUR
>8b7c	52 84					.word	Command_Data                     ; $b2 DATA
>8b7e	5a 84					.word	DimCommand                       ; $b3 DIM
>8b80	94 8a					.word	Unused3                          ; $b4 DOWNTO
>8b82	89 86					.word	ElseCode                         ; $b5 ELSE
>8b84	b8 9f					.word	SyntaxError                      ; $b6 FROM
>8b86	8d a3					.word	GfxCommand                       ; $b7 GFX
>8b88	2d 86					.word	Command_GOSUB                    ; $b8 GOSUB
>8b8a	4b 86					.word	GotoCommand                      ; $b9 GOTO
>8b8c	b8 9f					.word	SyntaxError                      ; $ba HERE
>8b8e	8b a1					.word	ImageCommand                     ; $bb IMAGE
>8b90	91 86					.word	LetCommand                       ; $bc LET
>8b92	e0 a1					.word	LineCommand                      ; $bd LINE
>8b94	87 87					.word	Command_LOCAL                    ; $be LOCAL
>8b96	b8 9f					.word	SyntaxError                      ; $bf OFF
>8b98	b8 9f					.word	SyntaxError                      ; $c0 ON
>8b9a	b8 9f					.word	SyntaxError                      ; $c1 OUTLINE
>8b9c	e5 a3					.word	PaletteCommand                   ; $c2 PALETTE
>8b9e	d9 a1					.word	PlotCommand                      ; $c3 PLOT
>8ba0	5e 88					.word	Command_Print                    ; $c4 PRINT
>8ba2	39 89					.word	Command_Read                     ; $c5 READ
>8ba4	5d a1					.word	RectangleCommand                 ; $c6 RECT
>8ba6	92 89					.word	RemCommand                       ; $c7 REM
>8ba8	3d 86					.word	Command_RETURN                   ; $c8 RETURN
>8baa	b8 9f					.word	SyntaxError                      ; $c9 SOLID
>8bac	17 a6					.word	SoundCommand                     ; $ca SOUND
>8bae	6c a1					.word	SpriteCommand                    ; $cb SPRITE
>8bb0	a8 a1					.word	TextCommand                      ; $cc TEXT
>8bb2	94 8a					.word	Unused2                          ; $cd TO
.8bb4					VectorSet1:
>8bb4	b8 9f					.word	SyntaxError                      ; $80 !0:EOF
>8bb6	b8 9f					.word	SyntaxError                      ; $81 !1:SH1
>8bb8	b8 9f					.word	SyntaxError                      ; $82 !2:SH2
>8bba	89 83					.word	AssembleCommand                  ; $83 ASSEMBLE
>8bbc	a8 83					.word	AssertCommand                    ; $84 ASSERT
>8bbe	2d a3					.word	BitmapCtrl                       ; $85 BITMAP
>8bc0	17 85					.word	EndCommand                       ; $86 END
>8bc2	e6 86					.word	Command_List                     ; $87 LIST
>8bc4	4e 88					.word	NewCommand                       ; $88 NEW
>8bc6	c1 89					.word	Command_Restore                  ; $89 RESTORE
>8bc8	00 8a					.word	CommandRUN                       ; $8a RUN
>8bca	72 a3					.word	SpritesCtrl                      ; $8b SPRITES
>8bcc	56 8c					.word	StopCommand                      ; $8c STOP
.8bce					VectorSet2:
>8bce	b8 9f					.word	SyntaxError                      ; $80 !0:EOF
>8bd0	b8 9f					.word	SyntaxError                      ; $81 !1:SH1
>8bd2	b8 9f					.word	SyntaxError                      ; $82 !2:SH2
>8bd4	77 9e					.word	Assemble_adc                     ; $83 ADC
>8bd6	6f 9e					.word	Assemble_and                     ; $84 AND
>8bd8	8b 9e					.word	Assemble_asl                     ; $85 ASL
>8bda	f5 9e					.word	Assemble_bcc                     ; $86 BCC
>8bdc	f9 9e					.word	Assemble_bcs                     ; $87 BCS
>8bde	01 9f					.word	Assemble_beq                     ; $88 BEQ
>8be0	b8 9e					.word	Assemble_bit                     ; $89 BIT
>8be2	e9 9e					.word	Assemble_bmi                     ; $8a BMI
>8be4	fd 9e					.word	Assemble_bne                     ; $8b BNE
>8be6	e5 9e					.word	Assemble_bpl                     ; $8c BPL
>8be8	05 9f					.word	Assemble_bra                     ; $8d BRA
>8bea	09 9f					.word	Assemble_brk                     ; $8e BRK
>8bec	ed 9e					.word	Assemble_bvc                     ; $8f BVC
>8bee	f1 9e					.word	Assemble_bvs                     ; $90 BVS
>8bf0	11 9f					.word	Assemble_clc                     ; $91 CLC
>8bf2	65 9f					.word	Assemble_cld                     ; $92 CLD
>8bf4	25 9f					.word	Assemble_cli                     ; $93 CLI
>8bf6	55 9f					.word	Assemble_clv                     ; $94 CLV
>8bf8	83 9e					.word	Assemble_cmp                     ; $95 CMP
>8bfa	cc 9e					.word	Assemble_cpx                     ; $96 CPX
>8bfc	c7 9e					.word	Assemble_cpy                     ; $97 CPY
>8bfe	a9 9e					.word	Assemble_dec                     ; $98 DEC
>8c00	61 9f					.word	Assemble_dex                     ; $99 DEX
>8c02	3d 9f					.word	Assemble_dey                     ; $9a DEY
>8c04	73 9e					.word	Assemble_eor                     ; $9b EOR
>8c06	ae 9e					.word	Assemble_inc                     ; $9c INC
>8c08	71 9f					.word	Assemble_inx                     ; $9d INX
>8c0a	5d 9f					.word	Assemble_iny                     ; $9e INY
>8c0c	e0 9e					.word	Assemble_jmp                     ; $9f JMP
>8c0e	db 9e					.word	Assemble_jsr                     ; $a0 JSR
>8c10	7f 9e					.word	Assemble_lda                     ; $a1 LDA
>8c12	a4 9e					.word	Assemble_ldx                     ; $a2 LDX
>8c14	c2 9e					.word	Assemble_ldy                     ; $a3 LDY
>8c16	95 9e					.word	Assemble_lsr                     ; $a4 LSR
>8c18	75 9f					.word	Assemble_nop                     ; $a5 NOP
>8c1a	6b 9e					.word	Assemble_ora                     ; $a6 ORA
>8c1c	21 9f					.word	Assemble_pha                     ; $a7 PHA
>8c1e	0d 9f					.word	Assemble_php                     ; $a8 PHP
>8c20	69 9f					.word	Assemble_phx                     ; $a9 PHX
>8c22	29 9f					.word	Assemble_phy                     ; $aa PHY
>8c24	31 9f					.word	Assemble_pla                     ; $ab PLA
>8c26	15 9f					.word	Assemble_plp                     ; $ac PLP
>8c28	7d 9f					.word	Assemble_plx                     ; $ad PLX
>8c2a	39 9f					.word	Assemble_ply                     ; $ae PLY
>8c2c	90 9e					.word	Assemble_rol                     ; $af ROL
>8c2e	9a 9e					.word	Assemble_ror                     ; $b0 ROR
>8c30	1d 9f					.word	Assemble_rti                     ; $b1 RTI
>8c32	2d 9f					.word	Assemble_rts                     ; $b2 RTS
>8c34	87 9e					.word	Assemble_sbc                     ; $b3 SBC
>8c36	19 9f					.word	Assemble_sec                     ; $b4 SEC
>8c38	79 9f					.word	Assemble_sed                     ; $b5 SED
>8c3a	35 9f					.word	Assemble_sei                     ; $b6 SEI
>8c3c	7b 9e					.word	Assemble_sta                     ; $b7 STA
>8c3e	6d 9f					.word	Assemble_stp                     ; $b8 STP
>8c40	9f 9e					.word	Assemble_stx                     ; $b9 STX
>8c42	bd 9e					.word	Assemble_sty                     ; $ba STY
>8c44	b3 9e					.word	Assemble_stz                     ; $bb STZ
>8c46	51 9f					.word	Assemble_tax                     ; $bc TAX
>8c48	4d 9f					.word	Assemble_tay                     ; $bd TAY
>8c4a	d6 9e					.word	Assemble_trb                     ; $be TRB
>8c4c	d1 9e					.word	Assemble_tsb                     ; $bf TSB
>8c4e	59 9f					.word	Assemble_tsx                     ; $c0 TSX
>8c50	41 9f					.word	Assemble_txa                     ; $c1 TXA
>8c52	49 9f					.word	Assemble_txs                     ; $c2 TXS
>8c54	45 9f					.word	Assemble_tya                     ; $c3 TYA

;******  Return to file: ./common/commands/run.asm


;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/stop.asm

.8c56					StopCommand:
.8c56	a9 08		lda #$08		lda	#8
.8c58	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/procscan.asm

.8c5b					ProcedureScan:
.8c5b	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8c5d	85 30		sta $30				sta 	codePtr
.8c5f	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8c61	85 31		sta $31				sta 	codePtr+1
.8c63					_PSLoop:
.8c63	b2 30		lda ($30)			lda 	(codePtr)
.8c65	f0 42		beq $8ca9			beq 	_PSExit
.8c67	a0 03		ldy #$03			ldy 	#3 							; is it PROC ?
.8c69	b1 30		lda ($30),y			lda 	(codePtr),y
.8c6b	c9 a2		cmp #$a2			cmp 	#KWD_PROC
.8c6d	d0 2d		bne $8c9c			bne 	_PSNext
.8c6f	c8		iny				iny 								; get the address of the record to zTemp0 and
.8c70	b1 30		lda ($30),y			lda 	(codePtr),y
.8c72	29 c0		and #$c0			and 	#$C0
.8c74	c9 40		cmp #$40			cmp 	#$40
.8c76	d0 32		bne $8caa			bne 	_PSSyntax
.8c78	b1 30		lda ($30),y			lda 	(codePtr),y
.8c7a	18		clc				clc
.8c7b	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8c7d	85 37		sta $37				sta 	zTemp0+1
.8c7f	c8		iny				iny 								; LSB
.8c80	b1 30		lda ($30),y			lda 	(codePtr),y
.8c82	85 36		sta $36				sta 	zTemp0
.8c84	c8		iny				iny 								; character after variable call.
.8c85	98		tya				tya 								; save Y offset at +7
.8c86	a0 07		ldy #$07			ldy 	#7
.8c88	91 36		sta ($36),y			sta 	(zTemp0),y
.8c8a	a9 18		lda #$18			lda 	#NSTProcedure 				; mark it as procedure
.8c8c	a0 02		ldy #$02			ldy 	#2
.8c8e	91 36		sta ($36),y			sta 	(zTemp0),y
.8c90	a2 00		ldx #$00			ldx 	#0 							; copy code-Ptr in
.8c92					_PSCopy:
.8c92	b5 30		lda $30,x			lda 	safePtr,x
.8c94	c8		iny				iny
.8c95	91 36		sta ($36),y			sta 	(zTemp0),y
.8c97	e8		inx				inx
.8c98	e0 04		cpx #$04			cpx 	#4
.8c9a	d0 f6		bne $8c92			bne 	_PSCopy
.8c9c					_PSNext:
.8c9c	18		clc				clc
.8c9d	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.8c9f	65 30		adc $30				adc 	codePtr
.8ca1	85 30		sta $30				sta 	codePtr
.8ca3	90 02		bcc $8ca7			bcc 	_CREExit
.8ca5	e6 31		inc $31				inc 	codePtr+1
.8ca7					_CREExit:
.8ca7	80 ba		bra $8c63			bra 	_PSLoop
.8ca9					_PSExit:
.8ca9	60		rts				rts
.8caa					_PSSyntax:
.8caa	4c b8 9f	jmp $9fb8			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/scanforward.asm

.8cad					ScanForward:
.8cad	64 38		stz $38				stz 	zTemp1 						; this is the structure count - goes up with WHILE/FOR
.8caf	86 37		stx $37				stx 	zTemp0+1
.8cb1	85 36		sta $36				sta 	zTemp0 						; save XA as the two possible matches.
.8cb3					_ScanLoop:
.8cb3	b1 30		lda ($30),y			lda 	(codePtr),y
.8cb5	c8		iny				iny
.8cb6	a6 38		ldx $38				ldx 	zTemp1 						; if the count is > 0 cannot match as in substructure
.8cb8	d0 0e		bne $8cc8			bne 	_ScanGoNext
.8cba	c5 36		cmp $36				cmp 	zTemp0 						; see if either matches
.8cbc	f0 04		beq $8cc2			beq 	_ScanMatch
.8cbe	c5 37		cmp $37				cmp 	zTemp0+1
.8cc0	d0 06		bne $8cc8			bne 	_ScanGoNext
.8cc2					_ScanMatch:
.8cc2	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if asked for EOL, backtrack.
.8cc4	d0 01		bne $8cc7			bne 	_ScanNotEndEOL
.8cc6	88		dey				dey
.8cc7					_ScanNotEndEOL:
.8cc7	60		rts				rts
.8cc8					_ScanGoNext:
.8cc8	20 cd 8c	jsr $8ccd			jsr  	ScanForwardOne
.8ccb	80 e6		bra $8cb3			bra 	_ScanLoop
.8ccd					ScanForwardOne:
.8ccd	c9 40		cmp #$40			cmp 	#$40 						; if 00-3F, punctuation characters, loop back
.8ccf	90 3e		bcc $8d0f			bcc 	_SFWExit
.8cd1	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if 40-82, skip one extra.
.8cd3	90 18		bcc $8ced			bcc 	_ScanSkipOne
.8cd5	c9 fc		cmp #$fc			cmp 	#$FC 						; FC-FF are data skips
.8cd7	b0 2f		bcs $8d08			bcs 	_ScanSkipData
.8cd9	c9 a0		cmp #$a0			cmp 	#KWC_FIRST_STRUCTURE 		; structure keyword ?
.8cdb	90 32		bcc $8d0f			bcc 	_SFWExit 					; if not, ordinary keywords.
.8cdd	c9 ab		cmp #$ab			cmp 	#KWC_LAST_STRUCTURE+1
.8cdf	b0 2e		bcs $8d0f			bcs 	_SFWExit
.8ce1	c6 38		dec $38				dec 	zTemp1 						; decrement the sructure count
.8ce3	c9 a5		cmp #$a5			cmp 	#KWC_FIRST_STRUCTURE_DEC 	; back if it is a dec structure (e.g. WEND/NEXT)
.8ce5	b0 28		bcs $8d0f			bcs 	_SFWExit
.8ce7	e6 38		inc $38				inc 	zTemp1 						; so it's an increment structure
.8ce9	e6 38		inc $38				inc 	zTemp1 						; twice to undo the dec
.8ceb	80 22		bra $8d0f			bra 	_SFWExit
.8ced					_ScanSkipOne:
.8ced	c8		iny				iny 								; consume the extra one.
.8cee	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if not EOL loop back
.8cf0	d0 1d		bne $8d0f			bne 	_SFWExit
.8cf2	18		clc				clc
.8cf3	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.8cf5	65 30		adc $30				adc 	codePtr
.8cf7	85 30		sta $30				sta 	codePtr
.8cf9	90 02		bcc $8cfd			bcc 	_CREExit
.8cfb	e6 31		inc $31				inc 	codePtr+1
.8cfd					_CREExit:
.8cfd	a0 03		ldy #$03			ldy 	#3 							; scan start position.
.8cff	b2 30		lda ($30)			lda 	(codePtr)
.8d01	d0 0c		bne $8d0f			bne 	_SFWExit 					; if not zero, more to scan
.8d03	a9 13		lda #$13		lda	#19
.8d05	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler
.8d08					_ScanSkipData:
.8d08	88		dey				dey 								; point at data token
.8d09	c8		iny				iny
.8d0a	98		tya				tya
.8d0b	38		sec				sec
.8d0c	71 30		adc ($30),y			adc 	(codePtr),y
.8d0e	a8		tay				tay
.8d0f					_SFWExit:
.8d0f	60		rts				rts
.8d10					ScanGetCurrentLineStep:
.8d10	64 38		stz $38				stz 	zTemp1
.8d12	a0 03		ldy #$03			ldy 	#3
.8d14					_SGCLSLoop:
.8d14	b1 30		lda ($30),y			lda 	(codePtr),y
.8d16	c8		iny				iny
.8d17	c9 80		cmp #$80			cmp 	#KWC_EOL	 				; if EOL exit
.8d19	f0 05		beq $8d20			beq 	_SGCLSExit
.8d1b	20 cd 8c	jsr $8ccd			jsr 	ScanForwardOne
.8d1e	80 f4		bra $8d14			bra 	_SGCLSLoop
.8d20					_SGCLSExit:
.8d20	a5 38		lda $38				lda 	zTemp1
.8d22	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/while.asm

.8d23					Command_WHILE:
.8d23	5a		phy				phy 								; save position of the test
.8d24	a2 00		ldx #$00			ldx 	#0
.8d26	20 57 9d	jsr $9d57			jsr 	EvaluateNumber 				; work out the number
.8d29	20 5e 9e	jsr $9e5e			jsr 	NSMIsZero 					; check if zero
.8d2c	f0 0e		beq $8d3c			beq 	_WHExitLoop 				; if so exit the loop
.8d2e	98		tya				tya 								; position *after* test.
.8d2f	7a		ply				ply 								; restore position before test, at WHILE
.8d30	88		dey				dey
.8d31	48		pha				pha 								; push after test on the stack
.8d32	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; allocate 6 bytes on the return stack.
.8d34	20 a4 a6	jsr $a6a4			jsr 	StackOpen
.8d37	20 e8 a6	jsr $a6e8			jsr 	STKSaveCodePosition 		; save loop position - where the test value is.
.8d3a	7a		ply				ply 								; restore the position *after* the test
.8d3b	60		rts				rts
.8d3c					_WHExitLoop:
.8d3c	68		pla				pla 								; throw post loop position
.8d3d	a9 aa		lda #$aa			lda 	#KWD_WEND 					; scan forward past WEND
.8d3f	aa		tax				tax
.8d40	20 ad 8c	jsr $8cad			jsr 	ScanForward
.8d43	60		rts				rts
.8d44					Command_WEND:
.8d44	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; check WHILE is TOS
.8d46	a2 10		ldx #$10			ldx 	#ERRID_WHILE 				; this error
.8d48	20 d0 a6	jsr $a6d0			jsr 	StackCheckFrame
.8d4b	20 f9 a6	jsr $a6f9			jsr 	STKLoadCodePosition 		; loop back
.8d4e	20 c2 a6	jsr $a6c2			jsr 	StackClose		 			; erase the frame
.8d51	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/charcheck.asm

.8d52					CheckRightBracket:
.8d52	b1 30		lda ($30),y			lda 	(codePtr),y
.8d54	c8		iny				iny
.8d55	c9 29		cmp #$29			cmp 	#KWD_RPAREN 						; exit if matches
.8d57	d0 0f		bne $8d68			bne 	CNAFail
.8d59	60		rts				rts
.8d5a					CheckComma:
.8d5a	b1 30		lda ($30),y			lda 	(codePtr),y
.8d5c	c8		iny				iny
.8d5d	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 						; exit if matches
.8d5f	d0 07		bne $8d68			bne 	CNAFail
.8d61	60		rts				rts
.8d62					CheckNextA:
.8d62	d1 30		cmp ($30),y			cmp 	(codePtr),y
.8d64	d0 02		bne $8d68			bne 	CNAFail
.8d66	c8		iny				iny 								; skip character
.8d67	60		rts				rts 								; and exit
.8d68					CNAFail:
.8d68	4c b8 9f	jmp $9fb8			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/errors.asm

.8d6b					ErrorHandler:
.8d6b	a8		tay				tay 								; find the error text
.8d6c	f0 49		beq $8db7			beq 	_EHEnd
.8d6e	a2 00		ldx #$00			ldx 	#0
.8d70	a9 d1		lda #$d1			lda 	#((ErrorText) & $FF)
.8d72	85 36		sta $36				sta 	0+zTemp0
.8d74	a9 9f		lda #$9f			lda 	#((ErrorText) >> 8)
.8d76	85 37		sta $37				sta 	1+zTemp0
.8d78					_EHFind:
.8d78	88		dey				dey 								; found the error text ?
.8d79	f0 0e		beq $8d89			beq 	_EHFound
.8d7b					_EHFindZero:
.8d7b	b2 36		lda ($36)			lda 	(zTemp0) 					; find the next error
.8d7d	e6 36		inc $36				inc 	zTemp0
.8d7f	d0 02		bne $8d83			bne 	_EHFNoCarry
.8d81	e6 37		inc $37				inc 	zTemp0+1
.8d83					_EHFNoCarry:
.8d83	c9 00		cmp #$00			cmp 	#0
.8d85	d0 f4		bne $8d7b			bne 	_EHFindZero
.8d87	80 ef		bra $8d78			bra 	_EHFind
.8d89					_EHFound:
.8d89	a5 36		lda $36				lda 	zTemp0 						; print message
.8d8b	a6 37		ldx $37				ldx 	zTemp0+1
.8d8d	20 c4 8d	jsr $8dc4			jsr 	PrintStringXA
.8d90	a0 01		ldy #$01			ldy 	#1 							; if line number zero don't print i
.8d92	b1 30		lda ($30),y			lda 	(codePtr),y
.8d94	d0 05		bne $8d9b			bne 	_EHAtMsg
.8d96	c8		iny				iny
.8d97	b1 30		lda ($30),y			lda 	(codePtr),y
.8d99	f0 17		beq $8db2			beq 	_EHCREnd
.8d9b					_EHAtMsg:
.8d9b	a2 8d		ldx #$8d			ldx 	#_AtMsg >> 8 				; print " at "
.8d9d	a9 ba		lda #$ba			lda 	#_AtMsg & $FF
.8d9f	20 c4 8d	jsr $8dc4			jsr 	PrintStringXA
.8da2	a0 01		ldy #$01			ldy 	#1 							; line number into XA
.8da4	b1 30		lda ($30),y			lda 	(codePtr),y
.8da6	48		pha				pha
.8da7	c8		iny				iny
.8da8	b1 30		lda ($30),y			lda 	(codePtr),y
.8daa	aa		tax				tax
.8dab	68		pla				pla
.8dac	20 7d 92	jsr $927d			jsr 	LCLConvertInt16 				; convert XA to string
.8daf	20 c4 8d	jsr $8dc4			jsr 	PrintStringXA 				; and print it.
.8db2					_EHCREnd:
.8db2	a9 0d		lda #$0d			lda 	#13 						; new line
.8db4	20 e4 a7	jsr $a7e4			jsr 	EXTPrintCharacter
.8db7					_EHEnd:
.8db7	4c 59 83	jmp $8359			jmp 	WarmStart
>8dba	20 61 74 20 6c 69 6e 65		_AtMsg:	.text 	" at line ",0
>8dc2	20 00
.8dc4					PrintStringXA:
.8dc4	5a		phy				phy
.8dc5	86 37		stx $37				stx 	zTemp0+1
.8dc7	85 36		sta $36				sta 	zTemp0
.8dc9	a0 00		ldy #$00			ldy 	#0
.8dcb					_PSXALoop:
.8dcb	b1 36		lda ($36),y			lda 	(zTemp0),y
.8dcd	f0 06		beq $8dd5			beq 	_PSXAExit
.8dcf	20 e4 a7	jsr $a7e4			jsr 	EXTPrintCharacter
.8dd2	c8		iny				iny
.8dd3	80 f6		bra $8dcb			bra 	_PSXALoop
.8dd5					_PSXAExit:
.8dd5	7a		ply				ply
.8dd6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/compare.asm

.8dd7					UnaryTrue:
.8dd7	fa		plx				plx
.8dd8					ReturnTrue:
.8dd8	a9 01		lda #$01			lda 	#1  						; set to 1
.8dda	20 30 9e	jsr $9e30			jsr 	NSMSetByte
.8ddd	a9 80		lda #$80			lda 	#$80 						; set sign flag, so it is -1
.8ddf	9d 00 04	sta $0400,x			sta 	NSStatus,x
.8de2	60		rts				rts
.8de3					UnaryFalse:
.8de3	fa		plx				plx
.8de4					ReturnFalse:
.8de4	4c 2e 9e	jmp $9e2e			jmp 	NSMSetZero 					; set it all to zero
.8de7					BinaryCompareEqual:
.8de7	fa		plx				plx
.8de8	20 23 8e	jsr $8e23			jsr 	CompareBaseCode
.8deb	c9 00		cmp #$00			cmp 	#0
.8ded	f0 e9		beq $8dd8			beq 	ReturnTrue
.8def	80 f3		bra $8de4			bra 	ReturnFalse
.8df1					BinaryCompareLess:
.8df1	fa		plx				plx
.8df2	20 23 8e	jsr $8e23			jsr 	CompareBaseCode
.8df5	c9 ff		cmp #$ff			cmp 	#$FF
.8df7	f0 df		beq $8dd8			beq 	ReturnTrue
.8df9	80 e9		bra $8de4			bra 	ReturnFalse
.8dfb					BinaryCompareGreater:
.8dfb	fa		plx				plx
.8dfc	20 23 8e	jsr $8e23			jsr 	CompareBaseCode
.8dff	c9 01		cmp #$01			cmp 	#1
.8e01	f0 d5		beq $8dd8			beq 	ReturnTrue
.8e03	80 df		bra $8de4			bra 	ReturnFalse
.8e05					BinaryCompareNotEqual:
.8e05	fa		plx				plx
.8e06	20 23 8e	jsr $8e23			jsr 	CompareBaseCode
.8e09	c9 00		cmp #$00			cmp 	#0
.8e0b	d0 cb		bne $8dd8			bne 	ReturnTrue
.8e0d	80 d5		bra $8de4			bra 	ReturnFalse
.8e0f					BinaryCompareLessEqual:
.8e0f	fa		plx				plx
.8e10	20 23 8e	jsr $8e23			jsr 	CompareBaseCode
.8e13	c9 01		cmp #$01			cmp 	#1
.8e15	d0 c1		bne $8dd8			bne 	ReturnTrue
.8e17	80 cb		bra $8de4			bra 	ReturnFalse
.8e19					BinaryCompareGreaterEqual:
.8e19	fa		plx				plx
.8e1a	20 23 8e	jsr $8e23			jsr 	CompareBaseCode
.8e1d	c9 ff		cmp #$ff			cmp 	#$FF
.8e1f	d0 b7		bne $8dd8			bne 	ReturnTrue
.8e21	80 c1		bra $8de4			bra 	ReturnFalse
.8e23					CompareBaseCode:
.8e23	20 33 96	jsr $9633			jsr 	DereferenceTopTwo 			; make both values if references.
.8e26	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if either is a string.
.8e29	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8e2c	29 10		and #$10			and 	#NSTString
.8e2e	d0 40		bne $8e70			bne 	_CBCString
.8e30	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check both are integers
.8e33	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8e36	d0 3b		bne $8e73			bne 	_CBCFloat
.8e38	bd 00 04	lda $0400,x			lda 	NSStatus,x
.8e3b	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8e3e	29 08		and #$08			and 	#NSTFloat
.8e40	d0 31		bne $8e73			bne 	_CBCFloat
.8e42	20 76 8e	jsr $8e76			jsr 	CompareFixMinusZero
.8e45	e8		inx				inx
.8e46	20 76 8e	jsr $8e76			jsr 	CompareFixMinusZero
.8e49	ca		dex				dex
.8e4a	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; are the signs different ?
.8e4d	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.8e50	10 0b		bpl $8e5d			bpl 	_CDCSameSign
.8e52	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; if first one is -ve
.8e55	30 16		bmi $8e6d			bmi 	_CBCLess 					; return $FF
.8e57					_CBCGreater:
.8e57	a9 01		lda #$01			lda 	#1
.8e59	60		rts				rts
.8e5a					_CBCEqual:
.8e5a	a9 00		lda #$00			lda 	#0
.8e5c	60		rts				rts
.8e5d					_CDCSameSign:
.8e5d	20 c9 90	jsr $90c9			jsr 	SubTopTwoStack 				; unsigned subtract
.8e60	20 5e 9e	jsr $9e5e			jsr 	NSMIsZero 					; or the mantissa together
.8e63	f0 f5		beq $8e5a			beq 	_CBCEqual 					; -0 == 0
.8e65	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; sign of the result. if +ve return $01 else return $FF
.8e68	5d 01 04	eor $0401,x			eor 	NSStatus+1,x 				; however if both were -ve this is inverted
.8e6b	10 ea		bpl $8e57			bpl 	_CBCGreater
.8e6d					_CBCLess:
.8e6d	a9 ff		lda #$ff			lda 	#$FF
.8e6f	60		rts				rts
.8e70					_CBCString:
.8e70	4c 1f 90	jmp $901f			jmp 	CompareStrings
.8e73					_CBCFloat:
.8e73	4c 00 94	jmp $9400			jmp 	CompareFloat
.8e76					CompareFixMinusZero:
.8e76	20 5e 9e	jsr $9e5e			jsr 	NSMIsZero
.8e79	d0 03		bne $8e7e			bne 	_CFXMZNotZero
.8e7b	9e 00 04	stz $0400,x			stz 	NSStatus,x
.8e7e					_CFXMZNotZero:
.8e7e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/concat.asm

.8e7f					StringConcat:
.8e7f	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check both strings
.8e82	3d 01 04	and $0401,x			and 	NSStatus+1,x
.8e85	29 18		and #$18			and 	#NSBTypeMask
.8e87	c9 10		cmp #$10			cmp 	#NSTString
.8e89	d0 4e		bne $8ed9			bne		_SCType
.8e8b	64 38		stz $38				stz 	zTemp1 						; counting total length
.8e8d	e8		inx				inx
.8e8e	20 ac 8e	jsr $8eac			jsr 	_SCSetupZ0 					; setup for second
.8e91	20 b7 8e	jsr $8eb7			jsr 	_SCLengthZ0 				; length for second
.8e94	ca		dex				dex
.8e95	20 ac 8e	jsr $8eac			jsr 	_SCSetupZ0 					; setup for first
.8e98	20 b7 8e	jsr $8eb7			jsr 	_SCLengthZ0 				; length for first
.8e9b	a5 38		lda $38				lda 	zTemp1 						; allocate memory
.8e9d	20 97 a7	jsr $a797			jsr 	StringTempAllocate
.8ea0	20 ca 8e	jsr $8eca			jsr 	_SCCopy 					; copy first out, using zTemp0 from above
.8ea3	e8		inx				inx
.8ea4	20 ac 8e	jsr $8eac			jsr 	_SCSetupZ0 					; copy second out
.8ea7	20 ca 8e	jsr $8eca			jsr 	_SCCopy
.8eaa	ca		dex				dex
.8eab	60		rts				rts
.8eac					_SCSetupZ0:
.8eac	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.8eaf	85 36		sta $36				sta 	zTemp0
.8eb1	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.8eb4	85 37		sta $37				sta 	zTemp0+1
.8eb6	60		rts				rts
.8eb7					_SCLengthZ0:
.8eb7	5a		phy				phy
.8eb8	a0 00		ldy #$00			ldy 	#0
.8eba					_SCLenLoop:
.8eba	b1 36		lda ($36),y			lda 	(zTemp0),y
.8ebc	f0 0a		beq $8ec8			beq 	_SCLExit
.8ebe	c8		iny				iny
.8ebf	e6 38		inc $38				inc 	zTemp1
.8ec1	10 f7		bpl $8eba			bpl		_SCLenLoop
.8ec3	a9 09		lda #$09		lda	#9
.8ec5	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler
.8ec8					_SCLExit:
.8ec8	7a		ply				ply
.8ec9	60		rts				rts
.8eca					_SCCopy:
.8eca	5a		phy				phy
.8ecb	a0 00		ldy #$00			ldy 	#0
.8ecd					_SCCopyLoop:
.8ecd	b1 36		lda ($36),y			lda 	(zTemp0),y
.8ecf	f0 06		beq $8ed7			beq 	_SCCExit
.8ed1	20 d5 a7	jsr $a7d5			jsr 	StringTempWrite
.8ed4	c8		iny				iny
.8ed5	80 f6		bra $8ecd			bra 	_SCCopyLoop
.8ed7					_SCCExit:
.8ed7	7a		ply				ply
.8ed8	60		rts				rts
.8ed9					_SCType:
.8ed9	4c c2 9f	jmp $9fc2			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/divide.asm

.8edc					IntegerDivide:
.8edc	fa		plx				plx
.8edd	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.8ee0	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8ee3	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8ee4	0a		asl a				asl 	a
.8ee5	10 05		bpl $8eec			bpl 	_NotRef
.8ee7	48		pha				pha
.8ee8	20 33 96	jsr $9633			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8eeb	68		pla				pla
.8eec					_NotRef:
.8eec	0a		asl a				asl 	a
.8eed	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.8eef	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8ef2	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8ef5	f0 03		beq $8efa			beq 	_IntegerCode 				; if clear, then we have two integers
.8ef7	4c c2 9f	jmp $9fc2			jmp 	TypeError 					; anything else, type mismatch.
.8efa					_IntegerCode:
.8efa	20 1c 8f	jsr $8f1c			jsr 	CheckDivideZero 			; do div zero check
.8efd	20 54 8f	jsr $8f54			jsr 	Int32Divide 				; do the division
.8f00	20 11 90	jsr $9011			jsr 	CalculateSign 				; calculate result sign
.8f03					NSMCopyPlusTwoToZero:
.8f03	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.8f06	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.8f09	bd 12 04	lda $0412,x			lda 	NSMantissa1+2,x
.8f0c	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.8f0f	bd 1a 04	lda $041a,x			lda 	NSMantissa2+2,x
.8f12	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.8f15	bd 22 04	lda $0422,x			lda 	NSMantissa3+2,x
.8f18	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.8f1b	60		rts				rts
.8f1c					CheckDivideZero:
.8f1c	e8		inx				inx
.8f1d	20 5e 9e	jsr $9e5e			jsr 	NSMIsZero
.8f20	f0 02		beq $8f24			beq 	_CDVError
.8f22	ca		dex				dex
.8f23	60		rts				rts
.8f24					_CDVError:
.8f24	a9 03		lda #$03		lda	#3
.8f26	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler
.8f29					IntegerModulus:
.8f29	fa		plx				plx
.8f2a	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.8f2d	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8f30	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8f31	0a		asl a				asl 	a
.8f32	10 05		bpl $8f39			bpl 	_NotRef
.8f34	48		pha				pha
.8f35	20 33 96	jsr $9633			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8f38	68		pla				pla
.8f39					_NotRef:
.8f39	0a		asl a				asl 	a
.8f3a	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.8f3c	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8f3f	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8f42	f0 03		beq $8f47			beq 	_IntegerCode 				; if clear, then we have two integers
.8f44	4c c2 9f	jmp $9fc2			jmp 	TypeError 					; anything else, type mismatch.
.8f47					_IntegerCode:
.8f47					IntegerModulusNoCheck:
.8f47	20 1c 8f	jsr $8f1c			jsr 	CheckDivideZero 			; do div zero check
.8f4a	20 54 8f	jsr $8f54			jsr 	Int32Divide 				; do the division
.8f4d	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; clear the sign bit.
.8f50	5e 00 04	lsr $0400,x			lsr 	NSStatus,x
.8f53	60		rts				rts
.8f54					Int32Divide:
.8f54	48		pha				pha 								; save AXY
.8f55	5a		phy				phy
.8f56	20 05 9e	jsr $9e05			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.8f59	20 2a 9e	jsr $9e2a			jsr 	NSMSetZeroMantissaOnly 		; set S[X] to zero
.8f5c	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.8f5e					_I32DivideLoop:
.8f5e	e8		inx				inx
.8f5f	e8		inx				inx
.8f60	20 43 9e	jsr $9e43			jsr 	NSMShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.8f63	ca		dex				dex
.8f64	ca		dex				dex
.8f65	20 44 9e	jsr $9e44			jsr 	NSMRotateLeft
.8f68	20 94 8f	jsr $8f94			jsr 	DivideCheckSubtract 		; check if subtract possible
.8f6b	90 03		bcc $8f70			bcc 	_I32DivideNoCarryIn
.8f6d	fe 0a 04	inc $040a,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.8f70					_I32DivideNoCarryIn:
.8f70	88		dey				dey 								; loop round till division completed.
.8f71	d0 eb		bne $8f5e			bne 	_I32DivideLoop
.8f73	7a		ply				ply 								; restore AXY and exit
.8f74	68		pla				pla
.8f75	60		rts				rts
.8f76					Int32ShiftDivide:
.8f76	48		pha				pha 								; save AY
.8f77	5a		phy				phy
.8f78	e8		inx				inx 								; clear S[X+2]
.8f79	e8		inx				inx
.8f7a	20 2e 9e	jsr $9e2e			jsr 	NSMSetZero
.8f7d	ca		dex				dex
.8f7e	ca		dex				dex
.8f7f	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.8f81					_I32SDLoop:
.8f81	20 94 8f	jsr $8f94			jsr 	DivideCheckSubtract 		; check if subtract possible
.8f84	e8		inx				inx
.8f85	e8		inx				inx
.8f86	20 44 9e	jsr $9e44			jsr 	NSMRotateLeft				; shift 64 bit FPA left, rotating carry in
.8f89	ca		dex				dex
.8f8a	ca		dex				dex
.8f8b	20 44 9e	jsr $9e44			jsr 	NSMRotateLeft
.8f8e	88		dey				dey 	 							; do 31 times
.8f8f	d0 f0		bne $8f81			bne 	_I32SDLoop
.8f91	7a		ply				ply 								; restore AY and exit
.8f92	68		pla				pla
.8f93	60		rts				rts
.8f94					DivideCheckSubtract:
.8f94	20 c9 90	jsr $90c9			jsr 	SubTopTwoStack 				; subtract Stack[X+1] from Stack[X+0]
.8f97	b0 04		bcs $8f9d			bcs 	_DCSExit 					; if carry set, then could do, exit
.8f99	20 a3 90	jsr $90a3			jsr 	AddTopTwoStack 				; add it back in
.8f9c	18		clc				clc 								; and return False
.8f9d					_DCSExit:
.8f9d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/multiply.asm

.8f9e					MulInteger:
.8f9e	fa		plx				plx
.8f9f	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.8fa2	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8fa5	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8fa6	0a		asl a				asl 	a
.8fa7	10 05		bpl $8fae			bpl 	_NotRef
.8fa9	48		pha				pha
.8faa	20 33 96	jsr $9633			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8fad	68		pla				pla
.8fae					_NotRef:
.8fae	0a		asl a				asl 	a 							; put MSB of type into A:7
.8faf	30 0b		bmi $8fbc			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.8fb1	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8fb4	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8fb7	f0 06		beq $8fbf			beq 	_IntegerCode 				; if clear, then we have two integers
.8fb9	4c d7 94	jmp $94d7			jmp 	FloatingPointMultiply 							; otherwise at least one float.
.8fbc					_StringData:
.8fbc	4c cc 9f	jmp $9fcc			jmp 	NotDoneError							; at least one string - don't know both are strings.
.8fbf					_IntegerCode:
.8fbf	20 cc 8f	jsr $8fcc			jsr 	MultiplyShort
.8fc2	c9 00		cmp #$00			cmp 	#0
.8fc4	f0 05		beq $8fcb			beq 	_MIExit
.8fc6	a9 04		lda #$04		lda	#4
.8fc8	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler
.8fcb					_MIExit:
.8fcb	60		rts				rts
.8fcc					MultiplyShort:
.8fcc	5a		phy				phy 								; save Y
.8fcd	20 05 9e	jsr $9e05			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.8fd0	20 2a 9e	jsr $9e2a			jsr 	NSMSetZeroMantissaOnly 		; set mantissa S[X] to zero
.8fd3	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.8fd5					_I32MLoop:
.8fd5	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.8fd8	1d 12 04	ora $0412,x			ora 	NSMantissa1+2,x
.8fdb	1d 1a 04	ora $041a,x			ora 	NSMantissa2+2,x
.8fde	1d 22 04	ora $0422,x			ora 	NSMantissa3+2,x
.8fe1	f0 28		beq $900b			beq 	_I32MExit 					; exit if zero
.8fe3	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.8fe6	29 01		and #$01			and 	#1
.8fe8	f0 0e		beq $8ff8			beq 	_I32MNoAdd
.8fea	20 a3 90	jsr $90a3			jsr 	AddTopTwoStack 				; if so add S[X+1] to S[X+0]
.8fed	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.8ff0	10 06		bpl $8ff8			bpl 	_I32MNoAdd
.8ff2					_I32ShiftRight:
.8ff2	20 51 9e	jsr $9e51			jsr 	NSMShiftRight 				; shift S[X] right
.8ff5	c8		iny				iny 								; increment shift count
.8ff6	80 0a		bra $9002			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.8ff8					_I32MNoAdd:
.8ff8	3c 21 04	bit $0421,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.8ffb	70 f5		bvs $8ff2			bvs 	_I32ShiftRight 				; instead.
.8ffd	e8		inx				inx
.8ffe	20 43 9e	jsr $9e43			jsr 	NSMShiftLeft 				; shift additive S[X+1] left
.9001	ca		dex				dex
.9002					_I32MShiftUpper:
.9002	e8		inx				inx 								; shift S[X+2] right
.9003	e8		inx				inx
.9004	20 51 9e	jsr $9e51			jsr 	NSMShiftRight
.9007	ca		dex				dex
.9008	ca		dex				dex
.9009	80 ca		bra $8fd5			bra 	_I32MLoop 					; try again.
.900b					_I32MExit:
.900b	20 11 90	jsr $9011			jsr 	CalculateSign
.900e	98		tya				tya 								; shift in A
.900f	7a		ply				ply 								; restore Y and exit
.9010	60		rts				rts
.9011					CalculateSign:
.9011	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.9014	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; shift result left
.9017	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.901a	0a		asl a				asl 	a 							; shift bit 7 into carry
.901b	7e 00 04	ror $0400,x			ror 	NSStatus,x 					; shift right into status byte.
.901e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/scompare.asm

.901f					CompareStrings:
.901f	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check both are strings
.9022	3d 01 04	and $0401,x			and 	NSStatus+1,x
.9025	29 10		and #$10			and 	#NSBIsString
.9027	f0 2c		beq $9055			beq 	_CSTypeError
.9029	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy string addresses to zTemp0/1
.902c	85 36		sta $36				sta 	zTemp0
.902e	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9031	85 37		sta $37				sta 	zTemp0+1
.9033	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.9036	85 38		sta $38				sta 	zTemp1
.9038	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.903b	85 39		sta $39				sta 	zTemp1+1
.903d	5a		phy				phy 								; save Y so we can access strings
.903e	a0 ff		ldy #$ff			ldy 	#$FF 						; -1 for pre increment.
.9040					_CSLoop:
.9040	c8		iny				iny
.9041	b1 36		lda ($36),y			lda 	(zTemp0),y 					; check if they are the same
.9043	d1 38		cmp ($38),y			cmp 	(zTemp1),y
.9045	d0 06		bne $904d			bne 	_CSDifferent
.9047	c9 00		cmp #$00			cmp 	#0 							; reached end ?
.9049	d0 f5		bne $9040			bne 	_CSLoop 					; still comparing
.904b					_CSExit:
.904b	7a		ply				ply 								; reached end, return zero in A from EOS
.904c	60		rts				rts
.904d					_CSDifferent:
.904d	a9 ff		lda #$ff			lda 	#255 						; if < return $FF
.904f	90 fa		bcc $904b			bcc		_CSExit
.9051	a9 01		lda #$01			lda 	#1 							; otherwise return 1.
.9053	80 f6		bra $904b			bra 	_CSExit
.9055					_CSTypeError:
.9055	4c c2 9f	jmp $9fc2			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/shifts.asm

.9058					ShiftLeft:
.9058	38		sec				sec
.9059	80 01		bra $905c			bra 	ShiftMain
.905b					ShiftRight:
.905b	18		clc				clc
.905c					ShiftMain:
.905c	fa		plx				plx 								; restore X
.905d	08		php				php 								; save direction
.905e	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9061	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9064	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9065	0a		asl a				asl 	a
.9066	10 05		bpl $906d			bpl 	_NotRef
.9068	48		pha				pha
.9069	20 33 96	jsr $9633			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.906c	68		pla				pla
.906d					_NotRef:
.906d	0a		asl a				asl 	a
.906e	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9070	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9073	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9076	f0 03		beq $907b			beq 	_IntegerCode 				; if clear, then we have two integers
.9078	4c c2 9f	jmp $9fc2			jmp 	TypeError 					; anything else, type mismatch.
.907b					_IntegerCode:
.907b	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; check number < 32
.907e	29 e0		and #$e0			and 	#$E0
.9080	1d 11 04	ora $0411,x			ora 	NSMantissa1+1,x
.9083	1d 19 04	ora $0419,x			ora 	NSMantissa2+1,x
.9086	1d 21 04	ora $0421,x			ora 	NSMantissa3+1,x
.9089	d0 13		bne $909e			bne 	_SMExit0 					; if >= 32 it will always return zero.
.908b					_SMLoop:
.908b	de 09 04	dec $0409,x			dec 	NSMantissa0+1,x 			; predecrement, could do << 0
.908e	30 11		bmi $90a1			bmi 	_SMExit 					; exit if done.
.9090	28		plp				plp 								; restore direcition setting
.9091	08		php				php
.9092	90 05		bcc $9099			bcc 	_SMRight
.9094	20 43 9e	jsr $9e43			jsr 	NSMShiftLeft 				; shift left if CS
.9097	80 f2		bra $908b			bra 	_SMLoop
.9099					_SMRight:
.9099	20 51 9e	jsr $9e51			jsr 	NSMShiftRight 				; shift right if CC
.909c	80 ed		bra $908b			bra 	_SMLoop
.909e					_SMExit0:
.909e	20 2e 9e	jsr $9e2e			jsr 	NSMSetZero 					; return zero.
.90a1					_SMExit:
.90a1	28		plp				plp 								; throw direction
.90a2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/simple.asm

.90a3					AddTopTwoStack:
.90a3	18		clc				clc
.90a4	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.90a7	7d 09 04	adc $0409,x			adc 		NSMantissa0+1,x
.90aa	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.90ad	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.90b0	7d 11 04	adc $0411,x			adc 		NSMantissa1+1,x
.90b3	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.90b6	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.90b9	7d 19 04	adc $0419,x			adc 		NSMantissa2+1,x
.90bc	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.90bf	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.90c2	7d 21 04	adc $0421,x			adc 		NSMantissa3+1,x
.90c5	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.90c8	60		rts				rts
.90c9					SubTopTwoStack:
.90c9	38		sec				sec
.90ca	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.90cd	fd 09 04	sbc $0409,x			sbc 		NSMantissa0+1,x
.90d0	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.90d3	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.90d6	fd 11 04	sbc $0411,x			sbc 		NSMantissa1+1,x
.90d9	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.90dc	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.90df	fd 19 04	sbc $0419,x			sbc 		NSMantissa2+1,x
.90e2	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.90e5	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.90e8	fd 21 04	sbc $0421,x			sbc 		NSMantissa3+1,x
.90eb	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.90ee	60		rts				rts
.90ef					AddInteger:
.90ef	fa		plx				plx
.90f0	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.90f3	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.90f6	0a		asl a				asl 	a 							; shift reference bit into sign bit
.90f7	0a		asl a				asl 	a
.90f8	10 05		bpl $90ff			bpl 	_NotRef
.90fa	48		pha				pha
.90fb	20 33 96	jsr $9633			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.90fe	68		pla				pla
.90ff					_NotRef:
.90ff	0a		asl a				asl 	a 							; put MSB of type into A:7
.9100	30 0b		bmi $910d			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9102	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9105	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9108	f0 06		beq $9110			beq 	_IntegerCode 				; if clear, then we have two integers
.910a	4c 57 93	jmp $9357			jmp 	FloatingPointAdd 							; otherwise at least one float.
.910d					_StringData:
.910d	4c 7f 8e	jmp $8e7f			jmp 	StringConcat							; at least one string - don't know both are strings.
.9110					_IntegerCode:
.9110					AddCode:
.9110	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.9113	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.9116	10 8b		bpl $90a3			bpl 	AddTopTwoStack
.9118	20 c9 90	jsr $90c9			jsr 	SubTopTwoStack 				; do a physical subtraction
.911b	3c 20 04	bit $0420,x			bit 	NSMantissa3,x 				; result is +ve, okay
.911e	10 09		bpl $9129			bpl 	_AddExit
.9120	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; sign is that of 2nd value
.9123	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9126	20 e3 9d	jsr $9de3			jsr 	NSMNegateMantissa 			; negate the mantissa and exit
.9129					_AddExit:
.9129	20 5e 9e	jsr $9e5e			jsr 	NSMIsZero 					; check for -0
.912c	d0 03		bne $9131			bne 	_AddNonZero
.912e	9e 00 04	stz $0400,x			stz 	NSStatus,x
.9131					_AddNonZero:
.9131	60		rts				rts
.9132					SubInteger:
.9132	fa		plx				plx
.9133	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9136	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9139	0a		asl a				asl 	a 							; shift reference bit into sign bit
.913a	0a		asl a				asl 	a
.913b	10 05		bpl $9142			bpl 	_NotRef
.913d	48		pha				pha
.913e	20 33 96	jsr $9633			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9141	68		pla				pla
.9142					_NotRef:
.9142	0a		asl a				asl 	a 							; put MSB of type into A:7
.9143	30 0b		bmi $9150			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9145	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9148	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.914b	f0 06		beq $9153			beq 	_IntegerCode 				; if clear, then we have two integers
.914d	4c 5c 93	jmp $935c			jmp 	FloatingPointSub 							; otherwise at least one float.
.9150					_StringData:
.9150	4c cc 9f	jmp $9fcc			jmp 	NotDoneError							; at least one string - don't know both are strings.
.9153					_IntegerCode:
.9153	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; negate the second value.
.9156	49 80		eor #$80			eor 	#$80
.9158	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.915b	80 b3		bra $9110			bra 	AddCode 					; and do the same code as add.
.915d					AndInteger:
.915d	fa		plx				plx
.915e	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9161	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9164	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9165	0a		asl a				asl 	a
.9166	10 05		bpl $916d			bpl 	_NotRef
.9168	48		pha				pha
.9169	20 33 96	jsr $9633			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.916c	68		pla				pla
.916d					_NotRef:
.916d	0a		asl a				asl 	a
.916e	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9170	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9173	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9176	f0 03		beq $917b			beq 	_IntegerCode 				; if clear, then we have two integers
.9178	4c c2 9f	jmp $9fc2			jmp 	TypeError 					; anything else, type mismatch.
.917b					_IntegerCode:
.917b	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.917e	3d 09 04	and $0409,x			and 		NSMantissa0+1,x
.9181	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9184	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.9187	3d 11 04	and $0411,x			and 		NSMantissa1+1,x
.918a	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.918d	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.9190	3d 19 04	and $0419,x			and 		NSMantissa2+1,x
.9193	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9196	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.9199	3d 21 04	and $0421,x			and 		NSMantissa3+1,x
.919c	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.919f	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.91a2	60		rts				rts
.91a3					OraInteger:
.91a3	fa		plx				plx
.91a4	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.91a7	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.91aa	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91ab	0a		asl a				asl 	a
.91ac	10 05		bpl $91b3			bpl 	_NotRef
.91ae	48		pha				pha
.91af	20 33 96	jsr $9633			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91b2	68		pla				pla
.91b3					_NotRef:
.91b3	0a		asl a				asl 	a
.91b4	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.91b6	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91b9	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.91bc	f0 03		beq $91c1			beq 	_IntegerCode 				; if clear, then we have two integers
.91be	4c c2 9f	jmp $9fc2			jmp 	TypeError 					; anything else, type mismatch.
.91c1					_IntegerCode:
.91c1	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.91c4	1d 09 04	ora $0409,x			ora 		NSMantissa0+1,x
.91c7	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.91ca	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.91cd	1d 11 04	ora $0411,x			ora 		NSMantissa1+1,x
.91d0	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.91d3	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.91d6	1d 19 04	ora $0419,x			ora 		NSMantissa2+1,x
.91d9	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.91dc	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.91df	1d 21 04	ora $0421,x			ora 		NSMantissa3+1,x
.91e2	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.91e5	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.91e8	60		rts				rts
.91e9					EorInteger:
.91e9	fa		plx				plx
.91ea	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.91ed	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.91f0	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91f1	0a		asl a				asl 	a
.91f2	10 05		bpl $91f9			bpl 	_NotRef
.91f4	48		pha				pha
.91f5	20 33 96	jsr $9633			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91f8	68		pla				pla
.91f9					_NotRef:
.91f9	0a		asl a				asl 	a
.91fa	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.91fc	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91ff	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9202	f0 03		beq $9207			beq 	_IntegerCode 				; if clear, then we have two integers
.9204	4c c2 9f	jmp $9fc2			jmp 	TypeError 					; anything else, type mismatch.
.9207					_IntegerCode:
.9207	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.920a	5d 09 04	eor $0409,x			eor 		NSMantissa0+1,x
.920d	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9210	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.9213	5d 11 04	eor $0411,x			eor 		NSMantissa1+1,x
.9216	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9219	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.921c	5d 19 04	eor $0419,x			eor 		NSMantissa2+1,x
.921f	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9222	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.9225	5d 21 04	eor $0421,x			eor 		NSMantissa3+1,x
.9228	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.922b	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.922e	60		rts				rts
.922f					WordIndirect:
.922f	fa		plx				plx
.9230	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9233	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9236	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9237	0a		asl a				asl 	a
.9238	10 05		bpl $923f			bpl 	_NotRef
.923a	48		pha				pha
.923b	20 33 96	jsr $9633			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.923e	68		pla				pla
.923f					_NotRef:
.923f	0a		asl a				asl 	a
.9240	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9242	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9245	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9248	f0 03		beq $924d			beq 	_IntegerCode 				; if clear, then we have two integers
.924a	4c c2 9f	jmp $9fc2			jmp 	TypeError 					; anything else, type mismatch.
.924d					_IntegerCode:
.924d	20 10 91	jsr $9110			jsr 	AddCode 					; add the two values
.9250	a9 22		lda #$22			lda 	#NSBIsReference+2 			; make a 2 byte reference
.9252	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9255	60		rts				rts
.9256					ByteIndirect:
.9256	fa		plx				plx
.9257	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.925a	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.925d	0a		asl a				asl 	a 							; shift reference bit into sign bit
.925e	0a		asl a				asl 	a
.925f	10 05		bpl $9266			bpl 	_NotRef
.9261	48		pha				pha
.9262	20 33 96	jsr $9633			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9265	68		pla				pla
.9266					_NotRef:
.9266	0a		asl a				asl 	a
.9267	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9269	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.926c	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.926f	f0 03		beq $9274			beq 	_IntegerCode 				; if clear, then we have two integers
.9271	4c c2 9f	jmp $9fc2			jmp 	TypeError 					; anything else, type mismatch.
.9274					_IntegerCode:
.9274	20 10 91	jsr $9110			jsr 	AddCode 					; add the two values
.9277	a9 21		lda #$21			lda 	#NSBIsReference+1 			; make a 1 byte reference
.9279	9d 00 04	sta $0400,x			sta 	NSStatus,x
.927c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/tostring.asm

.927d					LCLConvertInt16:
.927d	8d 08 04	sta $0408			sta 	NSMantissa0 				; set up as 32 bit conversion
.9280	8e 10 04	stx $0410			stx 	NSMantissa1
.9283	9c 18 04	stz $0418			stz 	NSMantissa2
.9286	9c 20 04	stz $0420			stz 	NSMantissa3
.9289	9c 00 04	stz $0400			stz 	NSStatus 					; positive integer
.928c	a2 00		ldx #$00			ldx 	#0 							; stack level
.928e	a9 0a		lda #$0a			lda 	#10 						; base
.9290	80 00		bra $9292			bra 	ConvertInt32
.9292					ConvertInt32:
.9292	5a		phy				phy
.9293	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.9295	2c 00 04	bit $0400			bit 	NSStatus 					; output a - if not negative.
.9298	10 08		bpl $92a2			bpl 	_CI32NotNeg
.929a	48		pha				pha
.929b	a9 2d		lda #$2d			lda 	#'-'
.929d	99 f9 05	sta $05f9,y			sta 	NumberBuffer,y
.92a0	c8		iny				iny
.92a1	68		pla				pla
.92a2					_CI32NotNeg:
.92a2	20 b0 92	jsr $92b0			jsr 	_CI32DivideConvert 			; recursive conversion
.92a5	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.92a7	99 f9 05	sta $05f9,y			sta 	NumberBuffer,y
.92aa	7a		ply				ply
.92ab	a2 05		ldx #$05			ldx 	#NumberBuffer >> 8
.92ad	a9 f9		lda #$f9			lda 	#NumberBuffer & $FF
.92af	60		rts				rts
.92b0					_CI32DivideConvert:
.92b0	e8		inx				inx 								; write to next slot up
.92b1	20 30 9e	jsr $9e30			jsr 	NSMSetByte
.92b4	ca		dex				dex
.92b5	20 54 8f	jsr $8f54			jsr 	Int32Divide 				; divide
.92b8	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; save remainder
.92bb	48		pha				pha
.92bc	20 03 8f	jsr $8f03			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.92bf	20 5e 9e	jsr $9e5e			jsr 	NSMIsZero 					; is it zero ?
.92c2	f0 06		beq $92ca			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.92c4	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.92c7	20 b0 92	jsr $92b0			jsr 	_CI32DivideConvert 			; and recusrively call.
.92ca					_CI32NoRecurse:
.92ca	68		pla				pla 								; remainder
.92cb	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.92cd	90 02		bcc $92d1			bcc 	_CI32NotHex
.92cf	69 26		adc #$26			adc 	#6+32
.92d1					_CI32NotHex:
.92d1	69 30		adc #$30			adc 	#48
.92d3	99 f9 05	sta $05f9,y			sta 	NumberBuffer,y 				; write out and exit
.92d6	c8		iny				iny
.92d7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/expression.asm


;******  Processing file: ./common/expressions/../generated/precedence.dat

.92d8					PrecedenceLevel:
>92d8	04					.byte	 4	; $00 <<
>92d9	02					.byte	 2	; $01 <=
>92da	02					.byte	 2	; $02 <>
>92db	00					.byte	 0	; $03 !!3
>92dc	00					.byte	 0	; $04 ><
>92dd	02					.byte	 2	; $05 >=
>92de	04					.byte	 4	; $06 >>
>92df	00					.byte	 0	; $07 !!7
>92e0	00					.byte	 0	; $08 !!8
>92e1	00					.byte	 0	; $09 !!9
>92e2	00					.byte	 0	; $0a !!10
>92e3	00					.byte	 0	; $0b !!11
>92e4	00					.byte	 0	; $0c !!12
>92e5	00					.byte	 0	; $0d !!13
>92e6	00					.byte	 0	; $0e !!14
>92e7	00					.byte	 0	; $0f !!15
>92e8	00					.byte	 0	; $10 @
>92e9	00					.byte	 0	; $11 !!17
>92ea	00					.byte	 0	; $12 !!18
>92eb	00					.byte	 0	; $13 [
>92ec	04					.byte	 4	; $14 \
>92ed	00					.byte	 0	; $15 ]
>92ee	01					.byte	 1	; $16 ^
>92ef	00					.byte	 0	; $17 _
>92f0	00					.byte	 0	; $18 `
>92f1	00					.byte	 0	; $19 !!25
>92f2	00					.byte	 0	; $1a !!26
>92f3	00					.byte	 0	; $1b {
>92f4	01					.byte	 1	; $1c |
>92f5	00					.byte	 0	; $1d }
>92f6	00					.byte	 0	; $1e ~
>92f7	00					.byte	 0	; $1f [7m<7F>[m
>92f8	00					.byte	 0	; $20
>92f9	05					.byte	 5	; $21 !
>92fa	00					.byte	 0	; $22 "
>92fb	00					.byte	 0	; $23 #
>92fc	05					.byte	 5	; $24 $
>92fd	04					.byte	 4	; $25 %
>92fe	01					.byte	 1	; $26 &
>92ff	00					.byte	 0	; $27 '
>9300	00					.byte	 0	; $28 (
>9301	00					.byte	 0	; $29 )
>9302	04					.byte	 4	; $2a *
>9303	03					.byte	 3	; $2b +
>9304	00					.byte	 0	; $2c ,
>9305	03					.byte	 3	; $2d -
>9306	00					.byte	 0	; $2e .
>9307	04					.byte	 4	; $2f /
>9308	00					.byte	 0	; $30 0
>9309	00					.byte	 0	; $31 1
>930a	00					.byte	 0	; $32 2
>930b	00					.byte	 0	; $33 3
>930c	00					.byte	 0	; $34 4
>930d	00					.byte	 0	; $35 5
>930e	00					.byte	 0	; $36 6
>930f	00					.byte	 0	; $37 7
>9310	00					.byte	 0	; $38 8
>9311	00					.byte	 0	; $39 9
>9312	00					.byte	 0	; $3a :
>9313	00					.byte	 0	; $3b ;
>9314	02					.byte	 2	; $3c <
>9315	02					.byte	 2	; $3d =
>9316	02					.byte	 2	; $3e >
>9317	05					.byte	 5	; $3f ?

;******  Return to file: ./common/expressions/expression.asm

.9318					EvaluateExpressionAt0:
.9318	a2 00		ldx #$00			ldx 	#0 							; bottom stack level
.931a					EvaluateExpression:
.931a	a9 00		lda #$00			lda 	#0 							; lowest precedence level
.931c					EvaluateExpressionAtPrecedence:
.931c	48		pha				pha 								; save precedence level
.931d	20 f4 97	jsr $97f4			jsr 	EvaluateTerm 				; evaluate term into level X.
.9320	68		pla				pla 								; restore precedence level.
.9321					_EXPRLoop:
.9321	85 36		sta $36				sta 	zTemp0 						; save current precedence level.
.9323	b1 30		lda ($30),y			lda 	(codePtr),y
.9325	c9 40		cmp #$40			cmp		#$40 						; if >= $40 cannot be an operator
.9327	b0 25		bcs $934e			bcs 	_EXPRExit
.9329	da		phx				phx 								; read the operator precedence
.932a	aa		tax				tax
.932b	bd d8 92	lda $92d8,x			lda 	PrecedenceLevel,x
.932e	fa		plx				plx
.932f	c9 00		cmp #$00			cmp 	#0							; if zero exit (not an operator)
.9331	f0 1b		beq $934e			beq 	_EXPRExit
.9333	85 37		sta $37				sta 	zTemp0+1 					; save operator precedence level.
.9335	a5 36		lda $36				lda 	zTemp0 						; compare current precedence vs. operator precedence
.9337	c5 37		cmp $37				cmp 	zTemp0+1
.9339	b0 13		bcs $934e			bcs		_EXPRExit 					; if current >= operator exit
.933b	48		pha				pha 								; save current precedence.
.933c	b1 30		lda ($30),y			lda 	(codePtr),y
.933e	c8		iny				iny
.933f	48		pha				pha
.9340	a5 37		lda $37				lda 	zTemp0+1 					; get operator precedence level
.9342	e8		inx				inx 								; work out the right hand side.
.9343	20 1c 93	jsr $931c			jsr 	EvaluateExpressionAtPrecedence
.9346	ca		dex				dex
.9347	68		pla				pla 								; get operator, call the code.
.9348	20 51 93	jsr $9351			jsr 	_EXPRCaller
.934b	68		pla				pla 								; restore precedence level
.934c	80 d3		bra $9321			bra 	_EXPRLoop 					; and go round.
.934e					_EXPRExit:
.934e	a5 36		lda $36				lda 	zTemp0 						; A = current precedence level.
.9350	60		rts				rts
.9351					_EXPRCaller:
.9351	da		phx				phx 								; save on stack, first thing is to restore it
.9352	0a		asl a				asl 	a 							; double so can use vectors into X
.9353	aa		tax				tax
.9354	7c 98 8a	jmp ($8a98,x)			jmp 	(VectorSetPunc,x) 			; and go to the code.

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/addsub.asm

.9357					FloatingPointAdd:
.9357	20 00 95	jsr $9500			jsr 	FloatPrepare 				; prepare for floats
.935a	80 0b		bra $9367			bra 	FloatAdd
.935c					FloatingPointSub:
.935c	20 00 95	jsr $9500			jsr 	FloatPrepare 				; prepare for floats
.935f					FloatSubtract:
.935f	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; negate FPB
.9362	49 80		eor #$80			eor 	#$80
.9364	9d 01 04	sta $0401,x			sta 	NSStatus+1,x				; and fall through.
.9367					FloatAdd:
.9367	48		pha				pha
.9368	5a		phy				phy
.9369	20 11 95	jsr $9511			jsr 	NSNormalise 				; normalise S[X]
.936c	f0 5c		beq $93ca			beq 	_FAReturn1
.936e	e8		inx				inx 								; normalise S[X+1]
.936f	20 11 95	jsr $9511			jsr 	NSNormalise
.9372	ca		dex				dex
.9373	c9 00		cmp #$00			cmp 	#0
.9375	f0 77		beq $93ee			beq 	_FAExit 					; if so, just return A
.9377	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; are the exponents the same ?
.937a	dd 29 04	cmp $0429,x			cmp 	NSExponent+1,x
.937d	f0 1b		beq $939a			beq 	_FAExponentsEqual
.937f	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; work out the larger exponent
.9382	a8		tay				tay
.9383	38		sec				sec 								; do a signed comparison of the exponents.
.9384	fd 29 04	sbc $0429,x			sbc 	NSExponent+1,x
.9387	50 02		bvc $938b			bvc 	_FANoSignedChange
.9389	49 80		eor #$80			eor 	#$80
.938b					_FANoSignedChange:
.938b	29 80		and #$80			and 	#$80
.938d	10 03		bpl $9392			bpl 	_FAHaveMax
.938f	bc 29 04	ldy $0429,x			ldy 	NSExponent+1,x
.9392					_FAHaveMax:
.9392	20 f1 93	jsr $93f1			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.9395	e8		inx				inx
.9396	20 f1 93	jsr $93f1			jsr 	_FAShiftToExponent
.9399	ca		dex				dex
.939a					_FAExponentsEqual:
.939a	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; are the signs the same
.939d	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.93a0	30 10		bmi $93b2			bmi 	_FADifferentSigns
.93a2	20 a3 90	jsr $90a3			jsr 	AddTopTwoStack 				; do the add of the mantissae
.93a5	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.93a8	10 44		bpl $93ee			bpl 	_FAExit 					; if no, we are done.
.93aa	20 51 9e	jsr $9e51			jsr 	NSMShiftRight 				; shift A right, renormalising it.
.93ad	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; bump the exponent and exit
.93b0	80 3c		bra $93ee			bra 	_FAExit
.93b2					_FADifferentSigns:
.93b2	20 c9 90	jsr $90c9			jsr 	SubTopTwoStack 				; subtract mantissa B from A
.93b5	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; is the result negative ?
.93b8	10 06		bpl $93c0			bpl 	_FACheckZero 				; if no, check for -0
.93ba	20 da 9d	jsr $9dda			jsr 	NSMNegate 					; netate result
.93bd	20 e3 9d	jsr $9de3			jsr 	NSMNegateMantissa 			; negate (2'c) the mantissa
.93c0					_FACheckZero:
.93c0	20 5e 9e	jsr $9e5e			jsr 	NSMIsZero	 				; check for -0
.93c3	d0 29		bne $93ee			bne 	_FAExit
.93c5	9e 00 04	stz $0400,x			stz 	NSStatus,x
.93c8	80 24		bra $93ee			bra 	_FAExit
.93ca					_FAReturn1:
.93ca	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.93cd	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.93d0	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.93d3	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.93d6	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.93d9	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.93dc	bd 21 04	lda $0421,x			lda 	NSMantissa3+1,x
.93df	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.93e2	bd 29 04	lda $0429,x			lda 	NSExponent+1,x
.93e5	9d 28 04	sta $0428,x			sta 	NSExponent,x
.93e8	bd 01 04	lda $0401,x			lda 	NSStatus+1,x
.93eb	9d 00 04	sta $0400,x			sta 	NSStatus,x
.93ee					_FAExit:
.93ee	7a		ply				ply
.93ef	68		pla				pla
.93f0	60		rts				rts
.93f1					_FAShiftToExponent:
.93f1					_FAShiftToExponent2:
.93f1	98		tya				tya 								; compare Y to exponent
.93f2	dd 28 04	cmp $0428,x			cmp 	NSExponent,x 				; reached the exponent required ?
.93f5	f0 08		beq $93ff			beq 	_FASEExit 					; exit if so.
.93f7	20 51 9e	jsr $9e51			jsr 	NSMShiftRight	 			; shift the mantissa right
.93fa	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; increment exponent
.93fd	80 f2		bra $93f1			bra 	_FAShiftToExponent2
.93ff					_FASEExit:
.93ff	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/compare.asm

.9400					CompareFloat:
.9400	20 5f 93	jsr $935f			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.9403	bd 10 04	lda $0410,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.9406	29 f8		and #$f8			and 	#$F8
.9408	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.940b	1d 20 04	ora $0420,x			ora 	NSMantissa3,x
.940e	f0 09		beq $9419			beq 	_FCExit 					; zero, so approximately identical
.9410	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.9412	3c 00 04	bit $0400,x			bit 	NSStatus,x
.9415	10 02		bpl $9419			bpl 	_FCExit
.9417					_FCNegative:
.9417	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.9419					_FCExit:
.9419	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/divide.asm

.941a					FDivideCommand:
.941a	fa		plx				plx	 								; restore stack position
.941b	20 00 95	jsr $9500			jsr 	FloatPrepare 				; prepare for floats
.941e					FloatDivide:
.941e	48		pha				pha
.941f	e8		inx				inx
.9420	20 11 95	jsr $9511			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.9423	ca		dex				dex
.9424	c9 00		cmp #$00			cmp 	#0
.9426	f0 20		beq $9448			beq 	_FDZero
.9428	20 11 95	jsr $9511			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.942b	f0 19		beq $9446			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.942d	20 76 8f	jsr $8f76			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.9430	20 03 8f	jsr $8f03			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.9433	20 11 95	jsr $9511			jsr		NSNormalise 				; renormalise
.9436	20 11 90	jsr $9011			jsr 	CalculateSign 				; calculate result sign
.9439	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; calculate exponent
.943c	38		sec				sec
.943d	fd 29 04	sbc $0429,x			sbc 	NSExponent+1,x
.9440	38		sec				sec
.9441	e9 1e		sbc #$1e			sbc 	#30
.9443	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9446					_FDExit:
.9446	68		pla				pla
.9447	60		rts				rts
.9448					_FDZero:
.9448	a9 03		lda #$03		lda	#3
.944a	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/fractional.asm

.944d					FloatFractionalPart:
.944d	5a		phy				phy
.944e	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; take absolute value
.9451	29 7f		and #$7f			and 	#$7F
.9453	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9456	20 11 95	jsr $9511			jsr 	NSNormalise
.9459	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.945c	38		sec				sec
.945d	e9 e0		sbc #$e0			sbc 	#$E0
.945f	90 31		bcc $9492			bcc 	_FFPExit 					; already fractional
.9461	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.9463	b0 2a		bcs $948f			bcs 	_FFPZero
.9465	a8		tay				tay 								; put count to do in Y
.9466	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; do each in turn.
.9469	20 94 94	jsr $9494			jsr 	_FFPPartial
.946c	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.946f	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9472	20 94 94	jsr $9494			jsr 	_FFPPartial
.9475	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9478	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.947b	20 94 94	jsr $9494			jsr 	_FFPPartial
.947e	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9481	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9484	20 94 94	jsr $9494			jsr 	_FFPPartial
.9487	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.948a	20 5e 9e	jsr $9e5e			jsr 	NSMIsZero 					; zeroed check.
.948d	d0 03		bne $9492			bne 	_FFPExit
.948f					_FFPZero:
.948f	20 2e 9e	jsr $9e2e			jsr 	NSMSetZero
.9492					_FFPExit:
.9492	7a		ply				ply
.9493	60		rts				rts
.9494					_FFPPartial:
.9494	c0 00		cpy #$00			cpy 	#0 							; no more to do
.9496	f0 17		beq $94af			beq 	_FFFPPExit
.9498	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.949a	b0 0c		bcs $94a8			bcs 	_FFFPPWholeByte
.949c	5a		phy				phy
.949d					_FFFPPLeft:
.949d	0a		asl a				asl 	a
.949e	88		dey				dey
.949f	d0 fc		bne $949d			bne 	_FFFPPLeft
.94a1	7a		ply				ply
.94a2					_FFFPPRight:
.94a2	4a		lsr a				lsr 	a
.94a3	88		dey				dey
.94a4	d0 fc		bne $94a2			bne 	_FFFPPRight
.94a6	80 07		bra $94af			bra 	_FFFPPExit
.94a8					_FFFPPWholeByte:
.94a8	98		tya				tya 								; subtract 8 from count
.94a9	38		sec				sec
.94aa	e9 08		sbc #$08			sbc 	#8
.94ac	a8		tay				tay
.94ad	a9 00		lda #$00			lda 	#0 							; and clear all
.94af					_FFFPPExit:
.94af	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/integer.asm

.94b0					FloatIntegerPart:
.94b0	48		pha				pha
.94b1	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; is it integer already ?
.94b4	f0 1f		beq $94d5			beq 	_FIPExit 					; if so do nothing
.94b6	20 5e 9e	jsr $9e5e			jsr 	NSMIsZero 					; is it zero ?
.94b9	f0 17		beq $94d2			beq 	_FIPZero 					; if so return zero.
.94bb	20 11 95	jsr $9511			jsr 	NSNormalise 				; normalise
.94be	f0 12		beq $94d2			beq 	_FIPZero 					; normalised to zero, exit zero
.94c0					_FIPShift:
.94c0	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.94c3	10 08		bpl $94cd			bpl 	_FIPCheckZero
.94c5	20 51 9e	jsr $9e51			jsr 	NSMShiftRight 				; shift mantissa right
.94c8	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; bump exponent
.94cb	80 f3		bra $94c0			bra 	_FIPShift
.94cd					_FIPCheckZero:
.94cd	20 5e 9e	jsr $9e5e			jsr 	NSMIsZero 					; avoid -0 problem
.94d0	d0 03		bne $94d5			bne 	_FIPExit 					; set to zero if mantissa zero.
.94d2					_FIPZero:
.94d2	20 2e 9e	jsr $9e2e			jsr 	NSMSetZero
.94d5					_FIPExit:
.94d5	68		pla				pla
.94d6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/multiply.asm

.94d7					FloatingPointMultiply:
.94d7	20 00 95	jsr $9500			jsr 	FloatPrepare 				; prepare for floats
.94da					FloatMultiply:
.94da	48		pha				pha
.94db	20 11 95	jsr $9511			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.94de	f0 1b		beq $94fb			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.94e0	e8		inx				inx
.94e1	20 11 95	jsr $9511			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.94e4	ca		dex				dex
.94e5	c9 00		cmp #$00			cmp 	#0
.94e7	f0 0f		beq $94f8			beq 	_FDSetZero
.94e9	20 cc 8f	jsr $8fcc			jsr 	MultiplyShort 				; calculate the result.
.94ec	7d 28 04	adc $0428,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.94ef	18		clc				clc
.94f0	7d 29 04	adc $0429,x			adc 	NSExponent+1,x
.94f3	9d 28 04	sta $0428,x			sta 	NSExponent,x
.94f6	80 03		bra $94fb			bra 	_FDExit
.94f8					_FDSetZero:
.94f8	20 2e 9e	jsr $9e2e			jsr 	NSMSetZero 					; return 0
.94fb					_FDExit:
.94fb	20 11 95	jsr $9511			jsr 	NSNormalise 				; normalise the result
.94fe	68		pla				pla
.94ff	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/utility.asm

.9500					FloatPrepare:
.9500	20 33 96	jsr $9633			jsr 	DereferenceTopTwo 			; dereference the top two values
.9503	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check ints/floats
.9506	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9509	29 10		and #$10			and 	#NSBIsString
.950b	d0 01		bne $950e			bne 	_FDType
.950d	60		rts				rts
.950e					_FDType:
.950e	4c c2 9f	jmp $9fc2			jmp 	TypeError
.9511					NSNormalise:
.9511	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; make float, keep sign
.9514	29 80		and #$80			and 	#$80
.9516	09 08		ora #$08			ora 	#NSTFloat
.9518	9d 00 04	sta $0400,x			sta 	NSStatus,x
.951b	20 5e 9e	jsr $9e5e			jsr 	NSMIsZero 					; if zero exit
.951e	d0 09		bne $9529			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.9520	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; clear the sign bit.
.9523	7e 00 04	ror $0400,x			ror 	NSStatus,x 					; (no -0)
.9526	a9 00		lda #$00			lda 	#0 							; set Z flag
.9528	60		rts				rts
.9529					_NSNormaliseOptimise:
.9529	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; upper byte zero ?
.952c	d0 22		bne $9550			bne 	_NSNormaliseLoop
.952e	bd 18 04	lda $0418,x			lda 	NSMantissa2,x 				; byte normalise
.9531	30 1d		bmi $9550			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.9533	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9536	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9539	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.953c	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.953f	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9542	9e 08 04	stz $0408,x			stz 	NSMantissa0,x
.9545	bd 28 04	lda $0428,x			lda 	NSExponent,x
.9548	38		sec				sec
.9549	e9 08		sbc #$08			sbc 	#8
.954b	9d 28 04	sta $0428,x			sta 	NSExponent,x
.954e	80 d9		bra $9529			bra 	_NSNormaliseOptimise
.9550					_NSNormaliseLoop:
.9550	3c 20 04	bit $0420,x			bit 	NSMantissa3,x 				; bit 30 set ?
.9553	70 08		bvs $955d			bvs 	_NSNExit 					; exit if so with Z flag clear
.9555	20 43 9e	jsr $9e43			jsr 	NSMShiftLeft 				; shift mantissa left
.9558	de 28 04	dec $0428,x			dec 	NSExponent,x 				; adjust exponent
.955b	80 f3		bra $9550			bra 	_NSNormaliseLoop
.955d					_NSNExit:
.955d	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.955f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignnumber.asm

.9560					AssignNumber:
.9560	5a		phy				phy
.9561	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy mantissa0/1 to zTemp0
.9564	85 36		sta $36				sta 	zTemp0
.9566	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9569	85 37		sta $37				sta 	zTemp0+1
.956b	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; clear reference bits
.956e	29 df		and #$df			and 	#(NSBIsReference ^ $FF)
.9570	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9573	29 18		and #$18			and 	#NSBTypeMask				; assigning to a float ?
.9575	c9 08		cmp #$08			cmp 	#NSTFloat
.9577	f0 2a		beq $95a3			beq 	_ANFloat
.9579	bd 29 04	lda $0429,x			lda		NSExponent+1,x 				; is it a float
.957c	f0 05		beq $9583			beq		_ANNotFloat
.957e	e8		inx				inx
.957f	20 b0 94	jsr $94b0			jsr 	FloatIntegerPart 			; make it an integer
.9582	ca		dex				dex
.9583					_ANNotFloat:
.9583	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if byte/word reference.
.9586	29 03		and #$03			and 	#3
.9588	d0 05		bne $958f			bne 	_ANByteWord
.958a	20 af 95	jsr $95af			jsr 	_ANCopy4PackSign 			; copy all 4 bytes and sign
.958d	80 1e		bra $95ad			bra 	_ANExit
.958f					_ANByteWord:
.958f	48		pha				pha 								; save count
.9590	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; do byte
.9593	92 36		sta ($36)			sta 	(zTemp0)
.9595	68		pla				pla
.9596	c9 01		cmp #$01			cmp	 	#1
.9598	f0 13		beq $95ad			beq 	_ANExit
.959a	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x 			; do word
.959d	a0 01		ldy #$01			ldy 	#1
.959f	91 36		sta ($36),y			sta 	(zTemp0),y
.95a1	80 0a		bra $95ad			bra 	_ANExit
.95a3					_ANFloat:
.95a3	20 af 95	jsr $95af			jsr 	_ANCopy4PackSign 			; write all 4 bytes and packed sign
.95a6	bd 29 04	lda $0429,x			lda 	NSExponent+1,x 				; copy exponent to slot 4
.95a9	a0 04		ldy #$04			ldy 	#4
.95ab	91 36		sta ($36),y			sta 	(zTemp0),y
.95ad					_ANExit:
.95ad	7a		ply				ply
.95ae	60		rts				rts
.95af					_ANCopy4PackSign:
.95af	a0 03		ldy #$03			ldy 	#3
.95b1	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; sign bit into status
.95b4	29 80		and #$80			and 	#$80 						; put into high bit of mantissa 3
.95b6	1d 21 04	ora $0421,x			ora 	NSMantissa3+1,x
.95b9	91 36		sta ($36),y			sta 	(zTemp0),y
.95bb	88		dey				dey
.95bc	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.95bf	91 36		sta ($36),y			sta 	(zTemp0),y
.95c1	88		dey				dey
.95c2	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.95c5	91 36		sta ($36),y			sta 	(zTemp0),y
.95c7	88		dey				dey
.95c8	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.95cb	91 36		sta ($36),y			sta 	(zTemp0),y
.95cd	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignstring.asm

.95ce					AssignString:
.95ce	5a		phy				phy
.95cf	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.95d2	85 38		sta $38				sta 	zTemp1
.95d4	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.95d7	85 39		sta $39				sta 	zTemp1+1
.95d9	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.95dc	85 36		sta $36				sta 	zTemp0
.95de	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.95e1	85 37		sta $37				sta 	zTemp0+1
.95e3	a0 01		ldy #$01			ldy 	#1 							; the high byte of the target address
.95e5	b1 36		lda ($36),y			lda 	(zTemp0),y
.95e7	f0 23		beq $960c			beq 	_ASNewStringRequired 		; if zero, a new string is required.
.95e9	38		sec				sec 								; put Address-2 in zsTemp - this is the size/status/string record
.95ea	b2 36		lda ($36)			lda 	(zTemp0) 					; of concreted strings
.95ec	e9 02		sbc #$02			sbc 	#2
.95ee	85 3c		sta $3c				sta 	zsTemp
.95f0	a0 01		ldy #$01			ldy 	#1
.95f2	b1 36		lda ($36),y			lda 	(zTemp0),y
.95f4	e9 00		sbc #$00			sbc 	#0
.95f6	85 3d		sta $3d				sta 	zsTemp+1
.95f8	a0 ff		ldy #$ff			ldy 	#$FF 						; get length of new string
.95fa					_ASGetLength:
.95fa	c8		iny				iny
.95fb	b1 38		lda ($38),y			lda 	(zTemp1),y
.95fd	d0 fb		bne $95fa			bne 	_ASGetLength
.95ff	98		tya				tya 								; is this length <= current length
.9600	d2 3c		cmp ($3c)			cmp 	(zsTemp)
.9602	90 20		bcc $9624			bcc 	_ASCopyString
.9604	f0 1e		beq $9624			beq 	_ASCopyString
.9606	a9 80		lda #$80			lda 	#$80 						; mark as unused.
.9608	a0 01		ldy #$01			ldy 	#1
.960a	91 3c		sta ($3c),y			sta 	(zsTemp),y
.960c					_ASNewStringRequired:
.960c	e8		inx				inx 								; concrete the new string.
.960d	20 16 a7	jsr $a716			jsr 	StringConcrete				; (breaks zTemp1/2, not zTemp0 and zsTemp)
.9610	ca		dex				dex
.9611	18		clc				clc
.9612	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; copy that new address to the reference.
.9615	69 02		adc #$02			adc 	#2 							; add two to point at the data.
.9617	92 36		sta ($36)			sta 	(zTemp0)
.9619	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.961c	69 00		adc #$00			adc 	#0
.961e	a0 01		ldy #$01			ldy 	#1
.9620	91 36		sta ($36),y			sta 	(zTemp0),y
.9622	80 0d		bra $9631			bra 	_ASExit
.9624					_ASCopyString:
.9624	a0 00		ldy #$00			ldy 	#0
.9626					_ASCopyLoop:
.9626	b1 38		lda ($38),y			lda 	(zTemp1),y
.9628	c8		iny				iny
.9629	c8		iny				iny
.962a	91 3c		sta ($3c),y			sta 	(zsTemp),y
.962c	88		dey				dey
.962d	c9 00		cmp #$00			cmp 	#0
.962f	d0 f5		bne $9626			bne 	_ASCopyLoop
.9631					_ASExit:
.9631	7a		ply				ply
.9632	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/dereference.asm

.9633					DereferenceTopTwo:
.9633	e8		inx				inx
.9634	20 38 96	jsr $9638			jsr 	Dereference 				; deref x+1
.9637	ca		dex				dex  								; falls through to deref x
.9638					Dereference:
.9638	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get the status byte
.963b	29 20		and #$20			and 	#NSBIsReference 			; shift sign bit to carry, reference to bit 7
.963d	f0 57		beq $9696			beq 	_DRFExit 					; not a reference
.963f	5a		phy				phy
.9640	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address to dereference into zTemp0
.9643	85 36		sta $36				sta 	zTemp0
.9645	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9648	85 37		sta $37				sta 	zTemp0+1
.964a	9e 10 04	stz $0410,x			stz 	NSMantissa1,x 				; clear second byte.
.964d	b2 36		lda ($36)			lda 	(zTemp0) 					; do the first byte
.964f	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9652	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get status byte.
.9655	29 18		and #$18			and 	#NSBTypeMask 				; what type is it ?
.9657	c9 10		cmp #$10			cmp 	#NSTString 					; if string, dereference two
.9659	f0 0f		beq $966a			beq 	_DRFDereferenceTwo
.965b	c9 08		cmp #$08			cmp 	#NSTFloat 					; if float, do full dereference.
.965d	f0 39		beq $9698			beq 	_DRFFull
.965f	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be integer - how many bytes ?
.9662	29 03		and #$03			and 	#3
.9664	f0 32		beq $9698			beq 	_DRFFull 					; the whole word
.9666	c9 01		cmp #$01			cmp 	#1 							; is it 10 (e.g. 2 bytes)
.9668	f0 07		beq $9671			beq		_DRFClear23 				; no, one byte, clear 2 & 3 and exit
.966a					_DRFDereferenceTwo:
.966a	a0 01		ldy #$01			ldy 	#1
.966c	b1 36		lda ($36),y			lda 	(zTemp0),y
.966e	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9671					_DRFClear23:
.9671	9e 18 04	stz $0418,x			stz 	NSMantissa2,x 				; clear upper bytes, only read 1 or 2 bytes
.9674	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.9677	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; make it a value of that type.
.967a	29 18		and #$18			and 	#NSBTypeMask
.967c	9d 00 04	sta $0400,x			sta 	NSStatus,x
.967f	c9 10		cmp #$10			cmp 	#NSTString  				; is it a string
.9681	d0 12		bne $9695			bne 	_DRFNotString
.9683	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; check address is zero
.9686	1d 10 04	ora $0410,x			ora 	NSMantissa1,x
.9689	d0 0a		bne $9695			bne 	_DRFNotString
.968b	a9 97		lda #$97			lda 	#_DRFNullString & $FF 		; if so, return reference to ""
.968d	9d 08 04	sta $0408,x			sta 	NSMantissa0,X
.9690	a9 96		lda #$96			lda 	#_DRFNullString >> 8
.9692	9d 10 04	sta $0410,x			sta 	NSMantissa1,X
.9695					_DRFNotString
.9695	7a		ply				ply 								; restore Y and exit
.9696					_DRFExit:
.9696	60		rts				rts
.9697					_DRFNullString:
>9697	00						.byte 	0
.9698					_DRFFull:
.9698	a0 01		ldy #$01			ldy 	#1 							; get remaining 3 bytes.
.969a	b1 36		lda ($36),y			lda 	(zTemp0),y
.969c	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.969f	c8		iny				iny
.96a0	b1 36		lda ($36),y			lda 	(zTemp0),y
.96a2	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.96a5	c8		iny				iny
.96a6	b1 36		lda ($36),y			lda 	(zTemp0),y
.96a8	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.96ab	9e 28 04	stz $0428,x			stz 	NSExponent,x 				; clear exponent.
.96ae	bd 00 04	lda $0400,x			lda		NSStatus,x 					; see if type is integer
.96b1	29 18		and #$18			and 	#NSBTypeMask  				; type information only
.96b3	9d 00 04	sta $0400,x			sta 	NSStatus,x 					; update it back.
.96b6	f0 06		beq $96be			beq 	_DRFNoExponent
.96b8	c8		iny				iny 								; if not, read the exponent as well.
.96b9	b1 36		lda ($36),y			lda 	(zTemp0),y
.96bb	9d 28 04	sta $0428,x			sta 	NSExponent,x
.96be					_DRFNoExponent:
.96be	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; is the most significant bit set ?
.96c1	10 0d		bpl $96d0			bpl 	_DRFExit2 					; if not, then exit.
.96c3	29 7f		and #$7f			and 	#$7F 						; clear that bit.
.96c5	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.96c8	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; set the sign flag
.96cb	09 80		ora #$80			ora 	#NSBIsNegative
.96cd	9d 00 04	sta $0400,x			sta 	NSStatus,x
.96d0					_DRFExit2:
.96d0	7a		ply				ply
.96d1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/number.asm

=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.96d2					EncodeNumberStart:
.96d2	38		sec				sec
.96d3	80 01		bra $96d6			bra 	EncodeNumberContinue+1
.96d5					EncodeNumberContinue:
.96d5	18		clc				clc
.96d6					EncodeNumber:
.96d6	08		php				php 								; save reset.
.96d7	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.96d9	f0 12		beq $96ed			beq 	_ENIsOkay
.96db	c9 30		cmp #$30			cmp 	#"0"
.96dd	90 04		bcc $96e3			bcc 	_ENBadNumber
.96df	c9 3a		cmp #$3a			cmp 	#"9"+1
.96e1	90 0a		bcc $96ed			bcc 	_ENIsOkay
.96e3					_ENBadNumber:
.96e3	28		plp				plp 								; throw saved reset
.96e4	ad 85 04	lda $0485			lda 	EncodeState 				; decimal mode, construct final number
.96e7	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.96e9	f0 7e		beq $9769			beq 	_ENConstructFinal
.96eb					_ENFail:
.96eb	18		clc				clc 								; not allowed
.96ec	60		rts				rts
.96ed					_ENIsOkay:
.96ed	28		plp				plp 								; are we restarting
.96ee	90 15		bcc $9705			bcc 	_ENNoRestart
.96f0					_ENStartEncode:
.96f0	c9 2e		cmp #$2e			cmp 	#'.'						; first is DP
.96f2	f0 0c		beq $9700			beq 	_ENFirstDP
.96f4	29 0f		and #$0f			and 	#15 						; put digit in mantissa
.96f6	20 30 9e	jsr $9e30			jsr 	NSMSetByte
.96f9	a9 01		lda #$01			lda 	#ESTA_Low
.96fb					_ENExitChange:
.96fb	8d 85 04	sta $0485			sta 	EncodeState 				; save new state
.96fe	38		sec				sec
.96ff	60		rts				rts
.9700					_ENFirstDP:
.9700	20 2e 9e	jsr $9e2e			jsr 	NSMSetZero 					; clear integer part
.9703	80 3f		bra $9744			bra 	_ESTASwitchFloat			; go straight to float and exi
.9705					_ENNoRestart:
.9705	48		pha				pha 								; save on stack.
.9706	ad 85 04	lda $0485			lda 	EncodeState 				; get current state
.9709	c9 01		cmp #$01			cmp 	#ESTA_Low
.970b	f0 09		beq $9716			beq  	_ESTALowState
.970d	c9 02		cmp #$02			cmp 	#ESTA_High
.970f	f0 29		beq $973a			beq 	_ESTAHighState
.9711	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.9713	f0 3b		beq $9750			beq 	_ESTADecimalState
>9715	db						.byte 	$DB 						; causes a break in the emulator
.9716					_ESTALowState:
.9716	68		pla				pla 								; get value back
.9717	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.9719	f0 29		beq $9744			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.971b	29 0f		and #$0f			and 	#15 						; make digit
.971d	8d 86 04	sta $0486			sta 	DigitTemp 					; save it.
.9720	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.9723	0a		asl a				asl 	a
.9724	0a		asl a				asl 	a
.9725	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.9728	0a		asl a				asl 	a
.9729	6d 86 04	adc $0486			adc 	DigitTemp
.972c	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.972f	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.9731	90 05		bcc $9738			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.9733	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.9735	8d 85 04	sta $0485			sta 	EncodeState
.9738					_ESTANoSwitch:
.9738	38		sec				sec
.9739	60		rts				rts
.973a					_ESTAHighState:
.973a	68		pla				pla 								; get value back
.973b	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.973d	f0 05		beq $9744			beq 	_ESTASwitchFloat
.973f	20 a3 97	jsr $97a3			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.9742	38		sec				sec
.9743	60		rts				rts
.9744					_ESTASwitchFloat:
.9744	9c 87 04	stz $0487			stz 	DecimalCount
.9747	e8		inx				inx 								; zero the decimal additive.
.9748	20 2e 9e	jsr $9e2e			jsr 	NSMSetZero
.974b	ca		dex				dex
.974c	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.974e	80 ab		bra $96fb			bra 	_ENExitChange
.9750					_ESTADecimalState:
.9750	68		pla				pla 								; digit.
.9751	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 2nd decimal point.
.9753	f0 96		beq $96eb			beq 	_ENFail
.9755	e8		inx				inx 								; put digit into fractional part of X+1
.9756	20 a3 97	jsr $97a3			jsr 	ESTAShiftDigitIntoMantissa
.9759	ca		dex				dex
.975a	ee 87 04	inc $0487			inc 	DecimalCount 				; bump the count of decimals
.975d	ad 87 04	lda $0487			lda 	DecimalCount
.9760	c9 0b		cmp #$0b			cmp 	#11
.9762	f0 02		beq $9766			beq 	_ESTADSFail
.9764	38		sec				sec
.9765	60		rts				rts
.9766					_ESTADSFail:
.9766	4c bd 9f	jmp $9fbd			jmp 	RangeError
.9769					_ENConstructFinal:
.9769	ad 87 04	lda $0487			lda 	DecimalCount 				; get decimal count
.976c	f0 33		beq $97a1			beq 	_ENCFExit 					; no decimals
.976e	5a		phy				phy
.976f	0a		asl a				asl 	a 							; x 4 and CLC
.9770	0a		asl a				asl 	a
.9771	6d 87 04	adc $0487			adc 	DecimalCount
.9774	a8		tay				tay
.9775	b9 7c 9f	lda $9f7c,y			lda 	DecimalScalarTable-5,y 		; copy decimal scalar to X+2
.9778	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.977b	b9 7d 9f	lda $9f7d,y			lda 	DecimalScalarTable-5+1,y
.977e	9d 12 04	sta $0412,x			sta 	NSMantissa1+2,x
.9781	b9 7e 9f	lda $9f7e,y			lda 	DecimalScalarTable-5+2,y
.9784	9d 1a 04	sta $041a,x			sta 	NSMantissa2+2,x
.9787	b9 7f 9f	lda $9f7f,y			lda 	DecimalScalarTable-5+3,y
.978a	9d 22 04	sta $0422,x			sta 	NSMantissa3+2,x
.978d	b9 80 9f	lda $9f80,y			lda 	DecimalScalarTable-5+4,y
.9790	9d 2a 04	sta $042a,x			sta 	NSExponent+2,x
.9793	a9 08		lda #$08			lda 	#NSTFloat
.9795	9d 02 04	sta $0402,x			sta 	NSStatus+2,x
.9798	7a		ply				ply
.9799	e8		inx				inx 								; multiply decimal const by decimal scalar
.979a	20 da 94	jsr $94da			jsr 	FloatMultiply
.979d	ca		dex				dex
.979e	20 67 93	jsr $9367			jsr 	FloatAdd 					; add to integer part.
.97a1					_ENCFExit:
.97a1	18		clc				clc 								; reject the digit.
.97a2	60		rts				rts
.97a3					ESTAShiftDigitIntoMantissa:
.97a3	29 0f		and #$0f			and 	#15 						; save digit
.97a5	48		pha				pha
.97a6	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; push mantissa on stack
.97a9	48		pha				pha
.97aa	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.97ad	48		pha				pha
.97ae	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.97b1	48		pha				pha
.97b2	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.97b5	48		pha				pha
.97b6	20 43 9e	jsr $9e43			jsr 	NSMShiftLeft 				; x 2
.97b9	20 43 9e	jsr $9e43			jsr 	NSMShiftLeft 				; x 4
.97bc	18		clc				clc 								; pop mantissa and add
.97bd	68		pla				pla
.97be	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.97c1	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.97c4	68		pla				pla
.97c5	7d 10 04	adc $0410,x			adc 	NSMantissa1,x
.97c8	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.97cb	68		pla				pla
.97cc	7d 18 04	adc $0418,x			adc 	NSMantissa2,x
.97cf	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.97d2	68		pla				pla
.97d3	7d 20 04	adc $0420,x			adc 	NSMantissa3,x
.97d6	9d 20 04	sta $0420,x			sta 	NSMantissa3,x 				; x 5
.97d9	20 43 9e	jsr $9e43			jsr 	NSMShiftLeft 				; x 10
.97dc	68		pla				pla 								; add digit
.97dd	18		clc				clc
.97de	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.97e1	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.97e4	90 0d		bcc $97f3			bcc 	_ESTASDExit
.97e6	fe 10 04	inc $0410,x			inc 	NSMantissa1,x
.97e9	d0 08		bne $97f3			bne 	_ESTASDExit
.97eb	fe 18 04	inc $0418,x			inc 	NSMantissa2,x
.97ee	d0 03		bne $97f3			bne 	_ESTASDExit
.97f0	fe 20 04	inc $0420,x			inc 	NSMantissa3,x
.97f3					_ESTASDExit:
.97f3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/term.asm

.97f4					EvaluateTerm:
.97f4	b1 30		lda ($30),y			lda 	(codePtr),y
.97f6	30 18		bmi $9810			bmi 	_ETCheckUnary 				; unary function ? (text ones)
.97f8	c9 40		cmp #$40			cmp 	#$40 						; 40-7F => identifier reference
.97fa	b0 6f		bcs $986b			bcs 	_ETVariable
.97fc	c9 30		cmp #$30			cmp 	#'0' 						; is it a number
.97fe	90 6e		bcc $986e			bcc 	_ETPuncUnary 				; if not it might be a punctuation unary.
.9800	c9 3a		cmp #$3a			cmp 	#'9'+1
.9802	b0 6a		bcs $986e			bcs 	_ETPuncUnary
.9804	20 d2 96	jsr $96d2			jsr 	EncodeNumberStart 			; can't fail as it's 0-9 !
.9807					_ETNumber:
.9807	c8		iny				iny 								; keep encoding until we have the numbers
.9808	b1 30		lda ($30),y			lda 	(codePtr),y
.980a	20 d5 96	jsr $96d5			jsr 	EncodeNumberContinue
.980d	b0 f8		bcs $9807			bcs 	_ETNumber 					; go back if accepted.
.980f	60		rts				rts
.9810					_ETCheckUnary:
.9810	c9 ff		cmp #$ff			cmp 	#KWC_STRING 				; string token
.9812	f0 41		beq $9855			beq 	_ETString
.9814	c9 fe		cmp #$fe			cmp 	#KWC_HEXCONST 				; hex constant.
.9816	f0 12		beq $982a			beq 	_ETHexConstant
.9818	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; check it actually is a unary function
.981a	90 0b		bcc $9827			bcc 	_ETSyntaxError
.981c	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1
.981e	b0 07		bcs $9827			bcs 	_ETSyntaxError
.9820	da		phx				phx 								; push X on the stack
.9821	0a		asl a				asl 	a 							; put vector x 2 into X
.9822	aa		tax				tax
.9823	c8		iny				iny 								; consume unary function token
.9824	7c 18 8b	jmp ($8b18,x)			jmp 	(VectorSet0,x) 				; and do it.
.9827					_ETSyntaxError:
.9827	4c b8 9f	jmp $9fb8			jmp 	SyntaxError
.982a					_ETHexConstant:
.982a	c8		iny				iny 								; skip #
.982b	c8		iny				iny 								; skip count
.982c	20 2e 9e	jsr $9e2e			jsr 	NSMSetZero 					; clear result
.982f					_ETHLoop:
.982f	b1 30		lda ($30),y			lda 	(codePtr),y
.9831	c8		iny				iny 								; and consume
.9832	c9 00		cmp #$00			cmp 	#0 							; exit if zero
.9834	f0 1e		beq $9854			beq 	_ETHExit
.9836	48		pha				pha 								; save on stack.
.9837	20 43 9e	jsr $9e43			jsr 	NSMShiftLeft 				; x 2
.983a	20 43 9e	jsr $9e43			jsr 	NSMShiftLeft 				; x 4
.983d	20 43 9e	jsr $9e43			jsr 	NSMShiftLeft 				; x 8
.9840	20 43 9e	jsr $9e43			jsr 	NSMShiftLeft 				; x 16
.9843	68		pla				pla 								; ASCII
.9844	c9 41		cmp #$41			cmp 	#'A'
.9846	90 02		bcc $984a			bcc 	_ETHNotChar
.9848	e9 07		sbc #$07			sbc 	#7
.984a					_ETHNotChar:
.984a	29 0f		and #$0f			and 	#15 						; digit now
.984c	1d 08 04	ora $0408,x			ora 	NSMantissa0,x 				; put in LS Nibble
.984f	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9852	80 db		bra $982f			bra 	_ETHLoop 					; go round.
.9854					_ETHExit:
.9854	60		rts				rts
.9855					_ETString:
.9855	c8		iny				iny 								; look at length
.9856	b1 30		lda ($30),y			lda 	(codePtr),y
.9858	48		pha				pha
.9859	c8		iny				iny 								; first character
.985a	20 b3 a5	jsr $a5b3			jsr 	MemoryInline 				; put address of string at (code-Ptr),y on stack
.985d	68		pla				pla 								; restore count and save
.985e	85 36		sta $36				sta 	zTemp0
.9860	98		tya				tya 								; add length to Y to skip it.
.9861	18		clc				clc
.9862	65 36		adc $36				adc 	zTemp0
.9864	a8		tay				tay
.9865	a9 10		lda #$10			lda 	#NSTString 					; mark as string
.9867	9d 00 04	sta $0400,x			sta 	NSStatus,x
.986a	60		rts				rts
.986b					_ETVariable:
.986b	4c c5 98	jmp $98c5			jmp 	VariableHandler
.986e					_ETPuncUnary:
.986e	c8		iny				iny 								; consume the unary character
.986f	c9 2d		cmp #$2d			cmp 	#KWD_MINUS 					; unary minus
.9871	f0 2d		beq $98a0			beq 	_ETUnaryNegate
.9873	c9 10		cmp #$10			cmp 	#KWD_AT 					; @ reference -> constant
.9875	f0 39		beq $98b0			beq 	_ETDereference
.9877	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; parenthesis
.9879	f0 43		beq $98be			beq 	_ETParenthesis
.987b	64 36		stz $36				stz 	zTemp0 						; zTemp0 is the indirection level.
.987d	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; byte indirection (0) ?
.987f	f0 06		beq $9887			beq 	_ETIndirection
.9881	e6 36		inc $36				inc 	zTemp0
.9883	c9 21		cmp #$21			cmp 	#KWD_PLING					; word indirection (1) \
.9885	d0 a0		bne $9827			bne 	_ETSyntaxError
.9887					_ETIndirection:
.9887	a5 36		lda $36				lda 	zTemp0 						; push indirection amount (0-1) => (1-2) on the stack
.9889	1a		inc a				inc 	a
.988a	48		pha				pha
.988b	20 f4 97	jsr $97f4			jsr 	EvaluateTerm				; evaluate the term
.988e	20 38 96	jsr $9638			jsr 	Dereference 				; dereference it.
.9891	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a +ve integer.
.9894	d0 07		bne $989d			bne 	_ETTypeMismatch
.9896	68		pla				pla 								; indirection 1-2
.9897	09 20		ora #$20			ora 	#NSBIsReference 			; make it a reference.
.9899	9d 00 04	sta $0400,x			sta 	NSStatus,x
.989c	60		rts				rts
.989d					_ETTypeMismatch:
.989d	4c c2 9f	jmp $9fc2			jmp 	TypeError
.98a0					_ETUnaryNegate:
.98a0	20 f4 97	jsr $97f4			jsr 	EvaluateTerm				; evaluate the term
.98a3	20 38 96	jsr $9638			jsr 	Dereference 				; dereference it.
.98a6	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a number
.98a9	29 10		and #$10			and 	#NSTString
.98ab	d0 f0		bne $989d			bne 	_ETTypeMismatch
.98ad	4c da 9d	jmp $9dda			jmp 	NSMNegate  					; just toggles the sign bit.
.98b0					_ETDereference:
.98b0	20 f4 97	jsr $97f4			jsr 	EvaluateTerm				; evaluate the term
.98b3	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a reference
.98b6	29 20		and #$20			and 	#NSBIsReference
.98b8	f0 e3		beq $989d			beq 	_ETTypeMismatch
.98ba	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; make it an integer address
.98bd	60		rts				rts
.98be					_ETParenthesis:
.98be	20 1a 93	jsr $931a			jsr 	EvaluateExpression 			; evaluate here, from lowest precedence
.98c1	20 52 8d	jsr $8d52			jsr 	CheckRightBracket 			; check for )
.98c4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/variable.asm

.98c5					VariableHandler:
.98c5	b1 30		lda ($30),y			lda 	(codePtr),y
.98c7	18		clc				clc
.98c8	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.98ca	85 37		sta $37				sta 	zTemp0+1
.98cc	c8		iny				iny
.98cd	b1 30		lda ($30),y			lda 	(codePtr),y
.98cf	85 36		sta $36				sta 	zTemp0
.98d1	c8		iny				iny
.98d2	18		clc				clc									; copy variable address+3 to mantissa
.98d3	69 03		adc #$03			adc 	#3
.98d5	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.98d8	a5 37		lda $37				lda 	zTemp0+1
.98da	69 00		adc #$00			adc 	#0
.98dc	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.98df	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.98e2	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.98e5	9e 28 04	stz $0428,x			stz 	NSExponent,x
.98e8	5a		phy				phy
.98e9	a0 02		ldy #$02			ldy 	#2 							; read type
.98eb	b1 36		lda ($36),y			lda 	(zTemp0),y
.98ed	7a		ply				ply
.98ee	29 1c		and #$1c			and 	#NSBTypeMask+NSBIsArray 	; get type information
.98f0	09 20		ora #$20			ora 	#NSBIsReference 			; make a reference.
.98f2	9d 00 04	sta $0400,x			sta 	NSStatus,x
.98f5	29 04		and #$04			and 	#NSBIsArray
.98f7	d0 01		bne $98fa			bne 	_VHArray
.98f9	60		rts				rts
.98fa					_VHArray:
.98fa	e8		inx				inx
.98fb	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger 		; get the 1st index.
.98fe	a9 ff		lda #$ff			lda 	#$FF 						; set Status of X+2 to a duff value so we know if we picked it up.
.9900	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.9903	b1 30		lda ($30),y			lda 	(codePtr),y
.9905	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.9907	d0 06		bne $990f			bne 	_VHNoSecondIndex
.9909	c8		iny				iny 								; skip the comma
.990a	e8		inx				inx
.990b	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger 		; get the 2nd index.
.990e	ca		dex				dex
.990f					_VHNoSecondIndex:
.990f	ca		dex				dex 								; set X back.
.9910	20 52 8d	jsr $8d52			jsr 	CheckRightBracket 			; and check the right bracket.
.9913	5a		phy				phy 								; save position
.9914	a0 02		ldy #$02			ldy 	#2 							; check first index is not-zero, e.g. array defined
.9916	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9918	f0 6b		beq $9985			beq 	_VHBadIndex
.991a	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy record address to zaTemp
.991d	85 3e		sta $3e				sta 	zaTemp
.991f	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9922	85 3f		sta $3f				sta 	zaTemp+1
.9924	a0 03		ldy #$03			ldy 	#3 							; get the second index - which is 0 if there is one index.
.9926	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9928	f0 02		beq $992c			beq 	_VHHas2Mask
.992a	a9 ff		lda #$ff			lda 	#$FF
.992c					_VHHas2Mask:
.992c	dd 02 04	cmp $0402,x			cmp 	NSStatus+2,x 				; so if they are the same there are the wrong number of indices
.992f	f0 54		beq $9985			beq 	_VHBadIndex
.9931	0a		asl a				asl 	a 							; carry will be set if a second index
.9932	90 09		bcc $993d			bcc 	_VHCheckFirstIndex
.9934	a0 03		ldy #$03			ldy 	#3 			 				; check the 2nd size >= 2nd index
.9936	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9938	dd 0a 04	cmp $040a,x			cmp 	NSMantissa0+2,x
.993b	90 48		bcc $9985			bcc 	_VHBadIndex
.993d					_VHCheckFirstIndex:
.993d	a0 02		ldy #$02			ldy 	#2 			 				; check the 2nd size >= 2nd index
.993f	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9941	dd 09 04	cmp $0409,x			cmp 	NSMantissa0+1,x
.9944	90 3f		bcc $9985			bcc 	_VHBadIndex
.9946	64 36		stz $36				stz 	zTemp0 						; clear zTemp0 (if 1 index)
.9948	64 37		stz $37				stz 	zTemp0+1
.994a	bd 02 04	lda $0402,x			lda 	NSStatus+2,x 				; if only one index provided, don't need to multiply
.994d	30 0f		bmi $995e			bmi 	_VHNoMultiply
.994f	da		phx				phx
.9950	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; get 2nd index on stack
.9953	48		pha				pha
.9954	a0 02		ldy #$02			ldy 	#2 							; get 1st size in A
.9956	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9958	1a		inc a				inc 	a 							; add 1 for zero base
.9959	fa		plx				plx
.995a	20 c3 9d	jsr $9dc3			jsr 	Multiply8x8 				; calculate -> Z0
.995d	fa		plx				plx
.995e					_VHNoMultiply:
.995e	18		clc				clc
.995f	a5 36		lda $36				lda 	zTemp0
.9961	7d 09 04	adc $0409,x			adc 	NSMantissa0+1,x
.9964	85 36		sta $36				sta 	zTemp0
.9966	a5 37		lda $37				lda 	zTemp0+1
.9968	69 00		adc #$00			adc 	#0
.996a	85 37		sta $37				sta 	zTemp0+1
.996c	bd 00 04	lda $0400,x			lda 	NSStatus,x
.996f	20 f5 84	jsr $84f5			jsr 	ScaleByBaseType
.9972	18		clc				clc
.9973	b2 3e		lda ($3e)			lda 	(zaTemp)
.9975	65 36		adc $36				adc 	zTemp0
.9977	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.997a	a0 01		ldy #$01			ldy 	#1
.997c	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.997e	65 37		adc $37				adc 	zTemp0+1
.9980	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9983	7a		ply				ply 								; restore position
.9984	60		rts				rts
.9985					_VHBadIndex:
.9985	a9 17		lda #$17		lda	#23
.9987	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/abs.asm

.998a					AbsUnary:
.998a	fa		plx				plx 								; restore stack pos
.998b	20 57 9d	jsr $9d57			jsr 	EvaluateNumber 				; get a float or int
.998e	20 52 8d	jsr $8d52			jsr 	CheckRightBracket
.9991	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; clear the sign bit
.9994	29 7f		and #$7f			and 	#$7F
.9996	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9999	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/alloc.asm

.999a					AllocUnary:
.999a	fa		plx				plx 								; restore stack pos
.999b	20 8f 9d	jsr $9d8f			jsr 	Evaluate16BitInteger		; get bytes required.
.999e	20 52 8d	jsr $8d52			jsr 	CheckRightBracket
.99a1	da		phx				phx 								; save X/Y
.99a2	5a		phy				phy
.99a3	8a		txa				txa 								; copy X into Y
.99a4	a8		tay				tay
.99a5	b9 10 04	lda $0410,y			lda		NSMantissa1,y 				; get size
.99a8	aa		tax				tax
.99a9	b9 08 04	lda $0408,y			lda 	NSMantissa0,y
.99ac	20 b9 99	jsr $99b9			jsr 	AllocateXABytes 			; allocate memory
.99af	99 08 04	sta $0408,y			sta 	NSMantissa0,y 				; write address out.
.99b2	8a		txa				txa
.99b3	99 10 04	sta $0410,y			sta 	NSMantissa1,y
.99b6	7a		ply				ply
.99b7	fa		plx				plx
.99b8	60		rts				rts
.99b9					AllocateXABytes:
.99b9	5a		phy				phy
.99ba	ac 8c 04	ldy $048c			ldy 	lowMemPtr 					; push current address on stack and to zTemp0
.99bd	84 36		sty $36				sty 	zTemp0
.99bf	5a		phy				phy
.99c0	ac 8d 04	ldy $048d			ldy 	lowMemPtr+1
.99c3	84 37		sty $37				sty 	zTemp0+1
.99c5	5a		phy				phy
.99c6	18		clc				clc 								; add to low memory pointer
.99c7	6d 8c 04	adc $048c			adc 	lowMemPtr
.99ca	8d 8c 04	sta $048c			sta 	lowMemPtr
.99cd	8a		txa				txa
.99ce	6d 8d 04	adc $048d			adc 	lowMemPtr+1
.99d1	8d 8d 04	sta $048d			sta 	lowMemPtr+1
.99d4	b0 2f		bcs $9a05			bcs 	CISSMemory
.99d6	20 f7 99	jsr $99f7			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.99d9					_ClearMemory:
.99d9	ad 8c 04	lda $048c			lda 	lowMemPtr 					; cleared all memory allocated
.99dc	c5 36		cmp $36				cmp 	zTemp0
.99de	d0 07		bne $99e7			bne 	_CMClearNext
.99e0	ad 8d 04	lda $048d			lda 	lowMemPtr+1
.99e3	c5 37		cmp $37				cmp 	zTemp0+1
.99e5	f0 0c		beq $99f3			beq 	_CMExit
.99e7					_CMClearNext:
.99e7	a9 00		lda #$00			lda 	#0 							; clear byte, advance to next.
.99e9	92 36		sta ($36)			sta 	(zTemp0)
.99eb	e6 36		inc $36				inc 	zTemp0
.99ed	d0 ea		bne $99d9			bne 	_ClearMemory
.99ef	e6 37		inc $37				inc		zTemp0+1
.99f1	80 e6		bra $99d9			bra 	_ClearMemory
.99f3					_CMExit:
.99f3	fa		plx				plx
.99f4	68		pla				pla
.99f5	7a		ply				ply
.99f6	60		rts				rts
.99f7					CheckIdentifierStringSpace:
.99f7	48		pha				pha
.99f8	ad 8d 04	lda $048d			lda 	lowMemPtr+1 				; get low memory pointer
.99fb	18		clc				clc
.99fc	69 02		adc #$02			adc 	#2 							; need at least 2 256 byte pages
.99fe	cd 8f 04	cmp $048f			cmp 	StringMemory+1 				; is it >= StringMemory
.9a01	b0 02		bcs $9a05			bcs 	CISSMemory
.9a03	68		pla				pla
.9a04	60		rts				rts
.9a05					CISSMemory:
.9a05	a9 06		lda #$06		lda	#6
.9a07	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/asc.asm

.9a0a					AscUnary:
.9a0a	fa		plx				plx 								; restore stack pos
.9a0b	20 62 9d	jsr $9d62			jsr 	EvaluateString 				; get a string
.9a0e	b2 36		lda ($36)			lda 	(zTemp0)					; get/return firs character
.9a10	20 30 9e	jsr $9e30			jsr 	NSMSetByte
.9a13	20 52 8d	jsr $8d52			jsr 	CheckRightBracket
.9a16	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/frac.asm

.9a17					FracUnary:
.9a17	fa		plx				plx 								; restore stack pos
.9a18	20 57 9d	jsr $9d57			jsr 	EvaluateNumber 				; get a float or int
.9a1b	20 52 8d	jsr $8d52			jsr 	CheckRightBracket
.9a1e	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9a21	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9a23	f0 04		beq $9a29			beq 	_IUZero
.9a25	20 4d 94	jsr $944d			jsr 	FloatFractionalPart
.9a28	60		rts				rts
.9a29					_IUZero:
.9a29	20 2e 9e	jsr $9e2e			jsr 	NSMSetZero
.9a2c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/int.asm

.9a2d					IntUnary:
.9a2d	fa		plx				plx 								; restore stack pos
.9a2e	20 57 9d	jsr $9d57			jsr 	EvaluateNumber 				; get a float or int
.9a31	20 52 8d	jsr $8d52			jsr 	CheckRightBracket
.9a34	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9a37	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9a39	f0 03		beq $9a3e			beq 	_IUExit
.9a3b	20 b0 94	jsr $94b0			jsr 	FloatIntegerPart
.9a3e					_IUExit:
.9a3e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/len.asm

.9a3f					LenUnary:
.9a3f	fa		plx				plx 								; restore stack pos
.9a40	20 62 9d	jsr $9d62			jsr 	EvaluateString 				; get a string
.9a43	5a		phy				phy
.9a44	a0 00		ldy #$00			ldy 	#0 							; find length
.9a46					_LenFind:
.9a46	b1 36		lda ($36),y			lda 	(zTemp0),y
.9a48	f0 06		beq $9a50			beq 	_LenExit
.9a4a	c8		iny				iny
.9a4b	d0 f9		bne $9a46			bne 	_LenFind
.9a4d	4c bd 9f	jmp $9fbd			jmp 	RangeError 					; string > 255
.9a50					_LenExit:
.9a50	98		tya				tya
.9a51	20 30 9e	jsr $9e30			jsr 	NSMSetByte
.9a54	7a		ply				ply
.9a55	20 52 8d	jsr $8d52			jsr 	CheckRightBracket
.9a58	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/minmax.asm

.9a59					Unary_Min:
.9a59	a9 01		lda #$01			lda 	#1
.9a5b	80 02		bra $9a5f			bra 	UnaryMinMaxMain
.9a5d					Unary_Max:
.9a5d	a9 ff		lda #$ff			lda 	#$FF 						; value from comparator to cause a write
.9a5f					UnaryMinMaxMain:
.9a5f	fa		plx				plx 								; get index on number stack
.9a60	48		pha				pha 								; save comparator
.9a61	20 4e 9d	jsr $9d4e			jsr 	EvaluateValue 				; get the first value.
.9a64					_UMMMLoop:
.9a64	b1 30		lda ($30),y			lda 	(codePtr),y
.9a66	c9 29		cmp #$29			cmp 	#KWD_RPAREN 				; if right bracket then done.
.9a68	f0 22		beq $9a8c			beq 	_UMMMDone
.9a6a	20 5a 8d	jsr $8d5a			jsr 	CheckComma 					; must be a comma
.9a6d	e8		inx				inx
.9a6e	20 4e 9d	jsr $9d4e			jsr 	EvaluateValue
.9a71	ca		dex				dex
.9a72	20 05 9e	jsr $9e05			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] (Compare is destructive)
.9a75	e8		inx				inx
.9a76	20 05 9e	jsr $9e05			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2], original
.9a79	e8		inx				inx
.9a7a	20 23 8e	jsr $8e23			jsr 	CompareBaseCode 			; part of > = < etc. code, returns 255,0 or 1
.9a7d	ca		dex				dex
.9a7e	ca		dex				dex
.9a7f	85 36		sta $36				sta 	zTemp0 						; save required result
.9a81	68		pla				pla 								; get and save comparator
.9a82	48		pha				pha
.9a83	c5 36		cmp $36				cmp 	zTemp0 						; if the comparator
.9a85	d0 dd		bne $9a64			bne 	_UMMMLoop
.9a87	20 8f 9a	jsr $9a8f			jsr 	ExpCopyAboveDown 			; copy next up slot down
.9a8a	80 d8		bra $9a64			bra 	_UMMMLoop
.9a8c					_UMMMDone:
.9a8c	68		pla				pla 								; throw the comparator
.9a8d	c8		iny				iny 								; skip )
.9a8e	60		rts				rts
.9a8f					ExpCopyAboveDown:
.9a8f	bd 01 04	lda $0401,x			lda 	NSStatus+1,x
.9a92	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9a95	bd 29 04	lda $0429,x			lda 	NSExponent+1,x
.9a98	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9a9b	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.9a9e	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9aa1	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.9aa4	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9aa7	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.9aaa	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9aad	bd 21 04	lda $0421,x			lda 	NSMantissa3+1,x
.9ab0	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9ab3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/not.asm

.9ab4					Unary_Not:
.9ab4	fa		plx				plx
.9ab5	20 7a 9d	jsr $9d7a			jsr 	EvaluateInteger 			; get integer
.9ab8	20 52 8d	jsr $8d52			jsr 	CheckRightBracket
.9abb	20 5e 9e	jsr $9e5e			jsr 	NSMIsZero 					; zero mantissa ?
.9abe	f0 04		beq $9ac4			beq 	_NotZero
.9ac0	20 2e 9e	jsr $9e2e			jsr 	NSMSetZero
.9ac3	60		rts				rts
.9ac4					_NotZero:
.9ac4	4c d8 8d	jmp $8dd8			jmp 	ReturnTrue
.9ac7					_UNBad:
.9ac7	4c c7 9f	jmp $9fc7			jmp 	ArgumentError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/rnd.asm

.9aca					Unary_Random:
.9aca	fa		plx				plx
.9acb	20 49 9b	jsr $9b49			jsr 	Random32Bit 				; get a random number
.9ace	20 2e 9b	jsr $9b2e			jsr 	URCopyToMantissa  			; put in mantissa
.9ad1	b1 30		lda ($30),y			lda 	(codePtr),y
.9ad3	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.9ad5	f0 08		beq $9adf			beq 	_URNoModulus
.9ad7	e8		inx				inx
.9ad8	20 8f 9d	jsr $9d8f			jsr 	Evaluate16BitInteger 		; put modulus value in +1
.9adb	ca		dex				dex
.9adc	20 47 8f	jsr $8f47			jsr 	IntegerModulusNoCheck 		; calculate modulus
.9adf					_URNoModulus:
.9adf	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; make it an integer positive
.9ae2	9e 28 04	stz $0428,x			stz 	NSExponent,x
.9ae5	20 52 8d	jsr $8d52			jsr 	CheckRightBracket
.9ae8	60		rts				rts
.9ae9					Unary_Rnd:
.9ae9	fa		plx				plx
.9aea	20 57 9d	jsr $9d57			jsr 	EvaluateNumber 				; number to use.
.9aed	20 52 8d	jsr $8d52			jsr 	CheckRightBracket 			; closing bracket
.9af0	20 5e 9e	jsr $9e5e			jsr 	NSMIsZero 					; if zero, then don't generate a new number
.9af3	f0 2b		beq $9b20			beq 	_URCopySeed
.9af5	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; if -ve, then seed using parameter
.9af8	10 23		bpl $9b1d			bpl 	_URDontSeed
.9afa	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy - value to seed butchering it.
.9afd	49 17		eor #$17			eor 	#$17
.9aff	8d 88 04	sta $0488			sta 	RandomSeed+0
.9b02	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9b05	49 a5		eor #$a5			eor 	#$A5
.9b07	8d 89 04	sta $0489			sta 	RandomSeed+1
.9b0a	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9b0d	49 c2		eor #$c2			eor 	#$C2
.9b0f	8d 8a 04	sta $048a			sta 	RandomSeed+2
.9b12	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9b15	49 9d		eor #$9d			eor 	#$9D
.9b17	8d 8b 04	sta $048b			sta 	RandomSeed+3
.9b1a	20 49 9b	jsr $9b49			jsr 	Random32Bit
.9b1d					_URDontSeed:
.9b1d	20 49 9b	jsr $9b49			jsr 	Random32Bit 				; generate a number.
.9b20					_URCopySeed:
.9b20	20 2e 9b	jsr $9b2e			jsr 	URCopyToMantissa 			; copy into mantissa
.9b23	a9 e2		lda #$e2			lda 	#-30 						; force into 0-1 range
.9b25	8d 28 04	sta $0428			sta 	NSExponent
.9b28	a9 08		lda #$08			lda 	#NSTFloat
.9b2a	8d 00 04	sta $0400			sta 	NSStatus 					; positive.
.9b2d	60		rts				rts
.9b2e					URCopyToMantissa:
.9b2e	ad 88 04	lda $0488			lda 	RandomSeed+0
.9b31	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9b34	ad 89 04	lda $0489			lda 	RandomSeed+1
.9b37	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9b3a	ad 8a 04	lda $048a			lda 	RandomSeed+2
.9b3d	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9b40	ad 8b 04	lda $048b			lda 	RandomSeed+3
.9b43	29 3f		and #$3f			and 	#$3F 						; make legal mantissa
.9b45	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9b48	60		rts				rts
.9b49					Random32Bit:
.9b49	5a		phy				phy
.9b4a	a0 07		ldy #$07			ldy 	#7 							; do it 7 times
.9b4c	ad 88 04	lda $0488			lda 	RandomSeed+0 				; check the seed isn't zero
.9b4f	d0 03		bne $9b54			bne 	_Random1
.9b51	a8		tay				tay 								; if so do it 256 times
.9b52	a9 aa		lda #$aa			lda		#$AA 						; and use this to seed the seed....
.9b54					_Random1:
.9b54	0a		asl a				asl 	a 							; LSFR RNG
.9b55	2e 89 04	rol $0489			rol 	RandomSeed+1
.9b58	2e 8a 04	rol $048a			rol 	RandomSeed+2
.9b5b	2e 8b 04	rol $048b			rol 	RandomSeed+3
.9b5e	90 02		bcc $9b62			bcc 	_Random2
.9b60	49 c5		eor #$c5			eor 	#$C5
.9b62					_Random2:
.9b62	88		dey				dey
.9b63	d0 ef		bne $9b54			bne 	_Random1
.9b65	8d 88 04	sta $0488			sta 	RandomSeed+0
.9b68	7a		ply				ply
.9b69	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/sgn.asm

.9b6a					SgnUnary:
.9b6a	fa		plx				plx 								; restore stack pos
.9b6b	20 57 9d	jsr $9d57			jsr 	EvaluateNumber 				; get a float or int
.9b6e	20 52 8d	jsr $8d52			jsr 	CheckRightBracket
.9b71	20 5e 9e	jsr $9e5e			jsr 	NSMIsZero 					; if zero
.9b74	f0 10		beq $9b86			beq 	_SGZero  					; return Int Zero
.9b76	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get status w/sign
.9b79	48		pha				pha
.9b7a	a9 01		lda #$01			lda 	#1 							; set to 1
.9b7c	20 30 9e	jsr $9e30			jsr 	NSMSetByte
.9b7f	68		pla				pla
.9b80	29 80		and #$80			and		#$80 						; copy the sign byte out
.9b82	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9b85	60		rts				rts
.9b86	20 2e 9e	jsr $9e2e	_SGZero:jsr 	NSMSetZero
.9b89	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/val.asm

.9b8a					ValUnary:
.9b8a	fa		plx				plx 								; restore stack pos
.9b8b	20 a0 9b	jsr $9ba0			jsr 	ValMainCode 				; do the main val() code
.9b8e	b0 01		bcs $9b91			bcs 	_VUError 					; couldn't convert
.9b90	60		rts				rts
.9b91					_VUError:
.9b91	4c c2 9f	jmp $9fc2			jmp 	TypeError
.9b94					IsValUnary:
.9b94	fa		plx				plx 								; restore stack pos
.9b95	20 a0 9b	jsr $9ba0			jsr 	ValMainCode 				; do the main val() code
.9b98	b0 03		bcs $9b9d			bcs 	_VUBad
.9b9a	4c d8 8d	jmp $8dd8			jmp 	ReturnTrue
.9b9d					_VUBad:
.9b9d	4c e4 8d	jmp $8de4			jmp 	ReturnFalse
.9ba0					ValMainCode:
.9ba0	20 62 9d	jsr $9d62			jsr 	EvaluateString 				; get a string
.9ba3	20 52 8d	jsr $8d52			jsr 	CheckRightBracket 			; check right bracket present
.9ba6	5a		phy				phy
.9ba7	b2 36		lda ($36)			lda 	(zTemp0) 					; check not empty string
.9ba9	f0 17		beq $9bc2			beq 	_VMCFail2
.9bab	a0 ff		ldy #$ff			ldy 	#$FF 						; start position
.9bad	48		pha				pha 								; save first character
.9bae	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it -
.9bb0	d0 01		bne $9bb3			bne 	_VMCStart
.9bb2	c8		iny				iny 								; skip over -
.9bb3					_VMCStart:
.9bb3	38		sec				sec 								; initialise first time round.
.9bb4					_VMCNext:
.9bb4	c8		iny				iny 								; pre-increment
.9bb5	b1 36		lda ($36),y			lda 	(zTemp0),y 					; next character
.9bb7	f0 0c		beq $9bc5			beq 	_VMCSuccess 				; successful.
.9bb9	20 d6 96	jsr $96d6			jsr 	EncodeNumber 				; send it to the number-builder
.9bbc	90 03		bcc $9bc1			bcc 	_VMCFail 					; if failed, give up.
.9bbe	18		clc				clc 								; next time round, countinue
.9bbf	80 f3		bra $9bb4			bra 	_VMCNext
.9bc1					_VMCFail:
.9bc1	68		pla				pla
.9bc2					_VMCFail2:
.9bc2	7a		ply				ply
.9bc3	38		sec				sec
.9bc4	60		rts				rts
.9bc5					_VMCSuccess:
.9bc5	a9 00		lda #$00			lda 	#0 							; construct final
.9bc7	20 d6 96	jsr $96d6			jsr 	EncodeNumber
.9bca	68		pla				pla
.9bcb	c9 2d		cmp #$2d			cmp 	#"-"
.9bcd	d0 03		bne $9bd2			bne 	_VMCNotNegative
.9bcf	20 da 9d	jsr $9dda			jsr		NSMNegate
.9bd2					_VMCNotNegative:
.9bd2	7a		ply				ply
.9bd3	18		clc				clc
.9bd4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/chr.asm

.9bd5					ChrUnary:
.9bd5	fa		plx				plx 								; restore stack pos
.9bd6	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger			; get value
.9bd9	48		pha				pha
.9bda	20 52 8d	jsr $8d52			jsr 	CheckRightBracket
.9bdd	a9 01		lda #$01			lda 	#1 							; allocate space for one char
.9bdf	20 97 a7	jsr $a797			jsr 	StringTempAllocate
.9be2	68		pla				pla 								; write number to it
.9be3	20 d5 a7	jsr $a7d5			jsr 	StringTempWrite
.9be6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/spc.asm

.9be7					SpcUnary:
.9be7	fa		plx				plx 								; restore stack pos
.9be8	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger			; get value
.9beb	5a		phy				phy
.9bec	48		pha				pha 								; save count
.9bed	20 97 a7	jsr $a797			jsr 	StringTempAllocate
.9bf0	7a		ply				ply 								; to do count in Y
.9bf1					_SpcLoop:
.9bf1	c0 00		cpy #$00			cpy 	#0
.9bf3	f0 08		beq $9bfd			beq 	_SpcExit
.9bf5	a9 20		lda #$20			lda 	#32
.9bf7	20 d5 a7	jsr $a7d5			jsr 	StringTempWrite
.9bfa	88		dey				dey
.9bfb	80 f4		bra $9bf1			bra 	_SPCLoop
.9bfd					_SpcExit:
.9bfd	7a		ply				ply
.9bfe	20 52 8d	jsr $8d52			jsr 	CheckRightBracket
.9c01	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/str.asm

.9c02					Unary_Str:
.9c02	fa		plx				plx
.9c03	20 57 9d	jsr $9d57			jsr 	EvaluateNumber  			; get number
.9c06	20 52 8d	jsr $8d52			jsr 	CheckRightBracket 			; closing bracket
.9c09	a9 05		lda #$05			lda 	#5 							; maximum decimals, from Basic816
.9c0b	20 24 9c	jsr $9c24			jsr 	ConvertNumberToString 		; do the conversion.
.9c0e	a9 21		lda #$21			lda		#33 						; create buffer
.9c10	20 97 a7	jsr $a797			jsr 	StringTempAllocate 			; allocate memory
.9c13	da		phx				phx
.9c14	a2 00		ldx #$00			ldx 	#0
.9c16					_USCopy:
.9c16	bd 1b 06	lda $061b,x			lda 	DecimalBuffer,x
.9c19	20 d5 a7	jsr $a7d5			jsr 	StringTempWrite
.9c1c	e8		inx				inx
.9c1d	bd 1b 06	lda $061b,x			lda 	DecimalBuffer,x
.9c20	d0 f4		bne $9c16			bne 	_USCopy
.9c22	fa		plx				plx
.9c23	60		rts				rts
.9c24					ConvertNumberToString:
.9c24	5a		phy				phy 								; save code position
.9c25	8d 94 04	sta $0494			sta 	DecimalPlaces	 			; save number of DPs.
.9c28	9c 95 04	stz $0495			stz 	dbOffset 					; offset into decimal buffer = start.
.9c2b	bd 00 04	lda $0400,x			lda 	NSStatus,x  				; is it -ve.
.9c2e	10 0a		bpl $9c3a			bpl 	_CNTSNotNegative
.9c30	29 7f		and #$7f			and 	#$7F 						; make +ve
.9c32	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9c35	a9 2d		lda #$2d			lda 	#"-"
.9c37	20 a0 9c	jsr $9ca0			jsr 	WriteDecimalBuffer
.9c3a					_CNTSNotNegative:
.9c3a	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if decimal
.9c3d	f0 15		beq $9c54			beq 	_CNTSNotFloat
.9c3f	e8		inx				inx 								; round up
.9c40	a9 01		lda #$01			lda 	#1
.9c42	20 30 9e	jsr $9e30			jsr 	NSMSetByte
.9c45	ca		dex				dex
.9c46	bd 28 04	lda $0428,x			lda		NSExponent,x
.9c49	9d 29 04	sta $0429,x			sta 	NSExponent+1,x
.9c4c	a9 08		lda #$08			lda 	#NSTFloat
.9c4e	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.9c51	20 67 93	jsr $9367			jsr 	FloatAdd
.9c54					_CNTSNotFloat:
.9c54	20 82 9c	jsr $9c82			jsr 	MakePlusTwoString
.9c57	20 4d 94	jsr $944d			jsr 	FloatFractionalPart 		; get the fractional part
.9c5a	20 11 95	jsr $9511			jsr 	NSNormalise					; normalise , exit if zero
.9c5d	f0 21		beq $9c80			beq 	_CNTSExit
.9c5f	a9 2e		lda #$2e			lda 	#"."
.9c61	20 a0 9c	jsr $9ca0			jsr 	WriteDecimalBuffer 			; write decimal place
.9c64					_CNTSDecimal:
.9c64	ce 94 04	dec $0494			dec 	DecimalPlaces 				; done all the decimals
.9c67	30 17		bmi $9c80			bmi 	_CNTSExit
.9c69	e8		inx				inx 								; x 10.0
.9c6a	a9 0a		lda #$0a			lda 	#10
.9c6c	20 30 9e	jsr $9e30			jsr 	NSMSetByte
.9c6f	a9 08		lda #$08			lda 	#NSTFloat
.9c71	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9c74	ca		dex				dex
.9c75	20 da 94	jsr $94da			jsr 	FloatMultiply
.9c78	20 82 9c	jsr $9c82			jsr 	MakePlusTwoString
.9c7b	20 4d 94	jsr $944d			jsr 	FloatFractionalPart 		; get the fractional part
.9c7e	80 e4		bra $9c64			bra 	_CNTSDecimal 				; keep going.
.9c80					_CNTSExit:
.9c80	7a		ply				ply
.9c81	60		rts				rts
.9c82					MakePlusTwoString:
.9c82	da		phx				phx
.9c83	20 05 9e	jsr $9e05			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.9c86	e8		inx				inx 								; access it
.9c87	e8		inx				inx
.9c88	20 b0 94	jsr $94b0			jsr 	FloatIntegerPart 			; make it an integer
.9c8b	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.9c8d	20 92 92	jsr $9292			jsr 	ConvertInt32
.9c90	a2 00		ldx #$00			ldx	 	#0
.9c92					_MPTSCopy:
.9c92	bd f9 05	lda $05f9,x			lda 	NumberBuffer,x
.9c95	20 a0 9c	jsr $9ca0			jsr 	WriteDecimalBuffer
.9c98	e8		inx				inx
.9c99	bd f9 05	lda $05f9,x			lda 	NumberBuffer,x
.9c9c	d0 f4		bne $9c92			bne 	_MPTSCopy
.9c9e	fa		plx				plx
.9c9f	60		rts				rts
.9ca0					WriteDecimalBuffer:
.9ca0	da		phx				phx
.9ca1	ae 95 04	ldx $0495			ldx 	dbOffset
.9ca4	9d 1b 06	sta $061b,x			sta 	DecimalBuffer,x
.9ca7	9e 1c 06	stz $061c,x			stz 	DecimalBuffer+1,x
.9caa	ee 95 04	inc $0495			inc 	dbOffset
.9cad	fa		plx				plx
.9cae	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/substring.asm

.9caf					Unary_Left:
.9caf	fa		plx				plx
.9cb0	18		clc				clc 								; only one parameter
.9cb1	20 26 9d	jsr $9d26			jsr 	SubstringInitial 			; set up.
.9cb4	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; Param #1 is the length
.9cb7	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9cba	9e 09 04	stz $0409,x			stz 	NSMantissa0+1,x 			; Start is zero.
.9cbd	80 2c		bra $9ceb			bra 	SubstringMain
.9cbf					Unary_Right:
.9cbf	fa		plx				plx
.9cc0	18		clc				clc 								; only one parameter
.9cc1	20 26 9d	jsr $9d26			jsr 	SubstringInitial 			; set up.
.9cc4	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; length => param 2
.9cc7	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9cca	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; total length
.9ccd	fd 09 04	sbc $0409,x			sbc 	NSMantissa0+1,x 			; length - required.
.9cd0	b0 02		bcs $9cd4			bcs 	_URNotUnderflow
.9cd2	a9 00		lda #$00			lda 	#0 							; start from the beginning, as something like right$("AB",3)
.9cd4					_URNotUnderFlow:
.9cd4	9d 09 04	sta $0409,x			sta 	NSMantissa0+1,x 			; this is the start position
.9cd7	80 12		bra $9ceb			bra 	SubStringMain
.9cd9					Unary_Mid:
.9cd9	fa		plx				plx
.9cda	38		sec				sec 								; two parameters
.9cdb	20 26 9d	jsr $9d26			jsr 	SubstringInitial 			; set up.
.9cde	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; first parameter is zero ?
.9ce1	f0 05		beq $9ce8			beq 	_UMError
.9ce3	de 09 04	dec $0409,x			dec 	NSMantissa0+1,x				; reduce initial offset by 1 as MID$(a$,1..) is actually the first character
.9ce6	80 03		bra $9ceb			bra 	SubStringMain
.9ce8					_UMError:
.9ce8	4c c7 9f	jmp $9fc7			jmp 	ArgumentError
.9ceb					SubStringMain:
.9ceb	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; is the initial offset >= the length
.9cee	dd 28 04	cmp $0428,x			cmp 	NSExponent,x
.9cf1	b0 2d		bcs $9d20			bcs 	_SSMNull 					; if so, return an empty string.
.9cf3	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; if copy count is zero
.9cf6	f0 28		beq $9d20			beq 	_SSMNull 					; return empty string.
.9cf8	18		clc				clc 								; add the offset +1 to the address and
.9cf9	bd 08 04	lda $0408,x			lda	 	NSMantissa0,x 				; put in zTemp
.9cfc	7d 09 04	adc $0409,x			adc 	NSMantissa0+1,x
.9cff	85 36		sta $36				sta 	zTemp0
.9d01	bd 10 04	lda $0410,x			lda	 	NSMantissa1,x
.9d04	69 00		adc #$00			adc 	#0
.9d06	85 37		sta $37				sta 	zTemp0+1
.9d08					_SSMNoCarry:
.9d08	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; characters required.
.9d0b	20 97 a7	jsr $a797			jsr 	StringTempAllocate 			; allocate that many characters
.9d0e	5a		phy				phy 								; save Y
.9d0f	a0 00		ldy #$00			ldy 	#0 							; start copying in.
.9d11					_SSMCopy:
.9d11	b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next character
.9d13	f0 09		beq $9d1e			beq 	_SSMEString 				; no more to copy
.9d15	20 d5 a7	jsr $a7d5			jsr 	StringTempWrite 			; and write it out.
.9d18	c8		iny				iny
.9d19	de 0a 04	dec $040a,x			dec 	NSMantissa0+2,x
.9d1c	d0 f3		bne $9d11			bne 	_SSMCopy
.9d1e					_SSMEString:
.9d1e	7a		ply				ply
.9d1f					_SSMExit:
.9d1f	60		rts				rts
.9d20					_SSMNull:
.9d20	a9 00		lda #$00			lda 	#0
.9d22	20 97 a7	jsr $a797			jsr 	StringTempAllocate
.9d25	60		rts				rts
.9d26					SubstringInitial:
.9d26	da		phx				phx 								; save initial stack position
.9d27	08		php				php 								; save carry on stack indicating 2 parameters
.9d28	20 62 9d	jsr $9d62			jsr 	EvaluateString 				; get a string
.9d2b	5a		phy				phy 								; calculate length to exponent.
.9d2c	a0 ff		ldy #$ff			ldy 	#$FF
.9d2e					_SIFindLength:
.9d2e	c8		iny				iny
.9d2f	b1 36		lda ($36),y			lda 	(zTemp0),y
.9d31	d0 fb		bne $9d2e			bne 	_SIFindLength
.9d33	98		tya				tya
.9d34	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9d37	7a		ply				ply
.9d38	e8		inx				inx
.9d39	20 5a 8d	jsr $8d5a			jsr 	CheckComma 					; comma next
.9d3c	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger 		; get next parameter
.9d3f	28		plp				plp 								; is it the last parameter ?
.9d40	90 07		bcc $9d49			bcc 	_SSIExit 					; if so, exit.
.9d42	e8		inx				inx
.9d43	20 5a 8d	jsr $8d5a			jsr 	CheckComma 					; comma next
.9d46	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger 		; get last parameter
.9d49					_SSIExit:
.9d49	fa		plx				plx
.9d4a	20 52 8d	jsr $8d52			jsr 	CheckRightBracket 			; check closing bracket
.9d4d	60		rts				rts 								; exit

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/exprhelper.asm

.9d4e					EvaluateValue:
.9d4e	48		pha				pha
.9d4f	20 1a 93	jsr $931a			jsr		EvaluateExpression 			; expression
.9d52	20 38 96	jsr $9638			jsr 	Dereference					; derefernce it
.9d55	68		pla				pla
.9d56	60		rts				rts
.9d57					EvaluateNumber:
.9d57	20 4e 9d	jsr $9d4e			jsr 	EvaluateValue 				; get a value
.9d5a	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if string.
.9d5d	29 10		and #$10			and 	#NSBIsString
.9d5f	d0 16		bne $9d77			bne 	HelperTypeError
.9d61	60		rts				rts
.9d62					EvaluateString:
.9d62	20 4e 9d	jsr $9d4e			jsr 	EvaluateValue 				; get a value
.9d65	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if string.
.9d68	29 10		and #$10			and 	#NSBIsString
.9d6a	f0 0b		beq $9d77			beq 	HelperTypeError
.9d6c					CopyAddressToTemp0:
.9d6c	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address -> zTemp0
.9d6f	85 36		sta $36				sta 	zTemp0
.9d71	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9d74	85 37		sta $37				sta 	zTemp0+1
.9d76	60		rts				rts
.9d77					HelperTypeError:
.9d77	4c c2 9f	jmp $9fc2			jmp 	TypeError
.9d7a					EvaluateInteger:
.9d7a	20 57 9d	jsr $9d57			jsr 	EvaluateNumber
.9d7d	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check exponent is zero
.9d80	d0 0a		bne $9d8c			bne 	HelperValueError 			; if not, it's a float.
.9d82	60		rts				rts
.9d83					EvaluateUnsignedInteger:
.9d83	20 7a 9d	jsr $9d7a			jsr 	EvaluateInteger 			; check integer is +ve
.9d86	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9d89	30 01		bmi $9d8c			bmi 	HelperValueError
.9d8b	60		rts				rts
.9d8c					HelperValueError:
.9d8c	4c c7 9f	jmp $9fc7			jmp 	ArgumentError
.9d8f					Evaluate16BitInteger:
.9d8f	20 83 9d	jsr $9d83			jsr	 	EvaluateUnsignedInteger		; get integer
.9d92	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9d95	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9d98	d0 f2		bne $9d8c			bne 	HelperValueError
.9d9a	60		rts				rts
.9d9b					Evaluate16BitIntegerSigned:
.9d9b	20 7a 9d	jsr $9d7a			jsr	 	EvaluateInteger				; get integer
.9d9e	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9da1	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9da4	d0 e6		bne $9d8c			bne 	HelperValueError
.9da6	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; signed ?
.9da9	10 03		bpl $9dae			bpl 	_EISNotSigned
.9dab	20 e3 9d	jsr $9de3			jsr 	NSMNegateMantissa
.9dae					_EISNotSigned:
.9dae	60		rts				rts
.9daf					Evaluate8BitInteger:
.9daf	20 83 9d	jsr $9d83			jsr	 	EvaluateUnsignedInteger 	; get an integer
.9db2	d0 d8		bne $9d8c			bne 	HelperValueError
.9db4	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 1, 2 & 3 must be zero
.9db7	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9dba	1d 10 04	ora $0410,x			ora 	NSMantissa1,x
.9dbd	d0 cd		bne $9d8c			bne 	HelperValueError
.9dbf	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9dc2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/mult8x8.asm

.9dc3					Multiply8x8:
.9dc3	4a		lsr a		  		lsr 	a  							; prime the carry bit for the loop
.9dc4	85 36		sta $36			  	sta 	zTemp0
.9dc6	86 37		stx $37				stx 	zTemp0+1
.9dc8	a9 00		lda #$00			lda 	#0
.9dca	a2 08		ldx #$08			ldx 	#8
.9dcc					_M88Loop:
.9dcc	90 03		bcc $9dd1			bcc 	_M88NoAdd
.9dce	18		clc				clc
.9dcf	65 37		adc $37				adc 	zTemp0+1
.9dd1					_M88NoAdd:
.9dd1	6a		ror a				ror 	a
.9dd2	66 36		ror $36				ror 	zTemp0  					; pull another bit out for the next iteration
.9dd4	ca		dex				dex         						; inc/dec don't modify carry; only shifts and adds do
.9dd5	d0 f5		bne $9dcc			bne 	_M88Loop
.9dd7	85 37		sta $37				sta 	zTemp0+1 					; store high 8 bits.
.9dd9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/utility.asm

.9dda					NSMNegate:
.9dda	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9ddd	49 80		eor #$80			eor 	#NSBIsNegative
.9ddf	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9de2	60		rts				rts
.9de3					NSMNegateMantissa:
.9de3	38		sec				sec
.9de4	a9 00		lda #$00			lda 	#0
.9de6	fd 08 04	sbc $0408,x			sbc 	NSMantissa0,x
.9de9	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9dec	a9 00		lda #$00			lda 	#0
.9dee	fd 10 04	sbc $0410,x			sbc 	NSMantissa1,x
.9df1	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9df4	a9 00		lda #$00			lda 	#0
.9df6	fd 18 04	sbc $0418,x			sbc 	NSMantissa2,x
.9df9	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9dfc	a9 00		lda #$00			lda 	#0
.9dfe	fd 20 04	sbc $0420,x			sbc 	NSMantissa3,x
.9e01	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9e04	60		rts				rts
.9e05					NSMShiftUpTwo:
.9e05	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9e08	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9e0b	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9e0e	9d 12 04	sta $0412,x			sta 	NSMantissa1+2,x
.9e11	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9e14	9d 1a 04	sta $041a,x			sta 	NSMantissa2+2,x
.9e17	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9e1a	9d 22 04	sta $0422,x			sta 	NSMantissa3+2,x
.9e1d	bd 28 04	lda $0428,x			lda 	NSExponent,x
.9e20	9d 2a 04	sta $042a,x			sta 	NSExponent+2,x
.9e23	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9e26	9d 02 04	sta $0402,x			sta 	NSStatus+2,x
.9e29	60		rts				rts
.9e2a					NSMSetZeroMantissaOnly:
.9e2a	a9 00		lda #$00			lda 	#0
.9e2c	80 08		bra $9e36			bra 	NSMSetMantissa
.9e2e					NSMSetZero:
.9e2e	a9 00		lda #$00			lda 	#0
.9e30					NSMSetByte:
.9e30	9e 28 04	stz $0428,x			stz 	NSExponent,x 				; zero exponent, as integer.
.9e33	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; status zero (integer)
.9e36					NSMSetMantissa:
.9e36	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; mantissa
.9e39	9e 10 04	stz $0410,x			stz 	NSMantissa1,x
.9e3c	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.9e3f	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.9e42	60		rts				rts
.9e43					NSMShiftLeft:
.9e43	18		clc				clc
.9e44					NSMRotateLeft:
.9e44	3e 08 04	rol $0408,x			rol 	NSMantissa0,x
.9e47	3e 10 04	rol $0410,x			rol		NSMantissa1,x
.9e4a	3e 18 04	rol $0418,x			rol		NSMantissa2,x
.9e4d	3e 20 04	rol $0420,x			rol		NSMantissa3,x
.9e50	60		rts				rts
.9e51					NSMShiftRight:
.9e51	5e 20 04	lsr $0420,x			lsr 	NSMantissa3,x
.9e54	7e 18 04	ror $0418,x			ror		NSMantissa2,x
.9e57	7e 10 04	ror $0410,x			ror		NSMantissa1,x
.9e5a	7e 08 04	ror $0408,x			ror		NSMantissa0,x
.9e5d	60		rts				rts
.9e5e					NSMIsZero:
.9e5e	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9e61	1d 18 04	ora $0418,x			ora		NSMantissa2,x
.9e64	1d 10 04	ora $0410,x			ora		NSMantissa1,x
.9e67	1d 08 04	ora $0408,x			ora		NSMantissa0,x
.9e6a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.asm

.b9ff					TickHandler:
.b9ff	5a		phy				phy 								; need to preserve Y
.ba00	20 a5 b9	jsr $b9a5			jsr 	SNDUpdate 					; update sound
.ba03	7a		ply				ply
.ba04	60		rts				rts
.062d					LastTick:
>062d							.fill 		1

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/asmcore.asm

.9e6b					Assemble_ora:
.9e6b	20 6c 80	jsr $806c		jsr	AssembleGroup1
>9e6e	01					.byte $01
.9e6f					Assemble_and:
.9e6f	20 6c 80	jsr $806c		jsr	AssembleGroup1
>9e72	21					.byte $21
.9e73					Assemble_eor:
.9e73	20 6c 80	jsr $806c		jsr	AssembleGroup1
>9e76	41					.byte $41
.9e77					Assemble_adc:
.9e77	20 6c 80	jsr $806c		jsr	AssembleGroup1
>9e7a	61					.byte $61
.9e7b					Assemble_sta:
.9e7b	20 6c 80	jsr $806c		jsr	AssembleGroup1
>9e7e	81					.byte $81
.9e7f					Assemble_lda:
.9e7f	20 6c 80	jsr $806c		jsr	AssembleGroup1
>9e82	a1					.byte $a1
.9e83					Assemble_cmp:
.9e83	20 6c 80	jsr $806c		jsr	AssembleGroup1
>9e86	c1					.byte $c1
.9e87					Assemble_sbc:
.9e87	20 6c 80	jsr $806c		jsr	AssembleGroup1
>9e8a	e1					.byte $e1
.9e8b					Assemble_asl:
.9e8b	20 73 80	jsr $8073		jsr	AssembleGroup2
>9e8e	02					.byte $02
>9e8f	75					.byte $75
.9e90					Assemble_rol:
.9e90	20 73 80	jsr $8073		jsr	AssembleGroup2
>9e93	22					.byte $22
>9e94	75					.byte $75
.9e95					Assemble_lsr:
.9e95	20 73 80	jsr $8073		jsr	AssembleGroup2
>9e98	42					.byte $42
>9e99	75					.byte $75
.9e9a					Assemble_ror:
.9e9a	20 73 80	jsr $8073		jsr	AssembleGroup2
>9e9d	62					.byte $62
>9e9e	75					.byte $75
.9e9f					Assemble_stx:
.9e9f	20 73 80	jsr $8073		jsr	AssembleGroup2
>9ea2	82					.byte $82
>9ea3	50					.byte $50
.9ea4					Assemble_ldx:
.9ea4	20 73 80	jsr $8073		jsr	AssembleGroup2
>9ea7	a2					.byte $a2
>9ea8	d0					.byte $d0
.9ea9					Assemble_dec:
.9ea9	20 73 80	jsr $8073		jsr	AssembleGroup2
>9eac	c2					.byte $c2
>9ead	55					.byte $55
.9eae					Assemble_inc:
.9eae	20 73 80	jsr $8073		jsr	AssembleGroup2
>9eb1	e2					.byte $e2
>9eb2	55					.byte $55
.9eb3					Assemble_stz:
.9eb3	20 73 80	jsr $8073		jsr	AssembleGroup2
>9eb6	60					.byte $60
>9eb7	44					.byte $44
.9eb8					Assemble_bit:
.9eb8	20 73 80	jsr $8073		jsr	AssembleGroup2
>9ebb	20					.byte $20
>9ebc	55					.byte $55
.9ebd					Assemble_sty:
.9ebd	20 73 80	jsr $8073		jsr	AssembleGroup2
>9ec0	80					.byte $80
>9ec1	54					.byte $54
.9ec2					Assemble_ldy:
.9ec2	20 73 80	jsr $8073		jsr	AssembleGroup2
>9ec5	a0					.byte $a0
>9ec6	d5					.byte $d5
.9ec7					Assemble_cpy:
.9ec7	20 73 80	jsr $8073		jsr	AssembleGroup2
>9eca	c0					.byte $c0
>9ecb	d4					.byte $d4
.9ecc					Assemble_cpx:
.9ecc	20 73 80	jsr $8073		jsr	AssembleGroup2
>9ecf	e0					.byte $e0
>9ed0	d0					.byte $d0
.9ed1					Assemble_tsb:
.9ed1	20 73 80	jsr $8073		jsr	AssembleGroup2
>9ed4	00					.byte $00
>9ed5	50					.byte $50
.9ed6					Assemble_trb:
.9ed6	20 73 80	jsr $8073		jsr	AssembleGroup2
>9ed9	10					.byte $10
>9eda	50					.byte $50
.9edb					Assemble_jsr:
.9edb	20 73 80	jsr $8073		jsr	AssembleGroup2
>9ede	14					.byte $14
>9edf	10					.byte $10
.9ee0					Assemble_jmp:
.9ee0	20 73 80	jsr $8073		jsr	AssembleGroup2
>9ee3	40					.byte $40
>9ee4	10					.byte $10
.9ee5					Assemble_bpl:
.9ee5	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9ee8	10					.byte $10
.9ee9					Assemble_bmi:
.9ee9	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9eec	30					.byte $30
.9eed					Assemble_bvc:
.9eed	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9ef0	50					.byte $50
.9ef1					Assemble_bvs:
.9ef1	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9ef4	70					.byte $70
.9ef5					Assemble_bcc:
.9ef5	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9ef8	90					.byte $90
.9ef9					Assemble_bcs:
.9ef9	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9efc	b0					.byte $b0
.9efd					Assemble_bne:
.9efd	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9f00	d0					.byte $d0
.9f01					Assemble_beq:
.9f01	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9f04	f0					.byte $f0
.9f05					Assemble_bra:
.9f05	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9f08	80					.byte $80
.9f09					Assemble_brk:
.9f09	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f0c	00					.byte $00
.9f0d					Assemble_php:
.9f0d	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f10	08					.byte $08
.9f11					Assemble_clc:
.9f11	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f14	18					.byte $18
.9f15					Assemble_plp:
.9f15	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f18	28					.byte $28
.9f19					Assemble_sec:
.9f19	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f1c	38					.byte $38
.9f1d					Assemble_rti:
.9f1d	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f20	40					.byte $40
.9f21					Assemble_pha:
.9f21	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f24	48					.byte $48
.9f25					Assemble_cli:
.9f25	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f28	58					.byte $58
.9f29					Assemble_phy:
.9f29	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f2c	5a					.byte $5a
.9f2d					Assemble_rts:
.9f2d	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f30	60					.byte $60
.9f31					Assemble_pla:
.9f31	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f34	68					.byte $68
.9f35					Assemble_sei:
.9f35	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f38	78					.byte $78
.9f39					Assemble_ply:
.9f39	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f3c	7a					.byte $7a
.9f3d					Assemble_dey:
.9f3d	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f40	88					.byte $88
.9f41					Assemble_txa:
.9f41	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f44	8a					.byte $8a
.9f45					Assemble_tya:
.9f45	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f48	98					.byte $98
.9f49					Assemble_txs:
.9f49	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f4c	9a					.byte $9a
.9f4d					Assemble_tay:
.9f4d	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f50	a8					.byte $a8
.9f51					Assemble_tax:
.9f51	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f54	aa					.byte $aa
.9f55					Assemble_clv:
.9f55	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f58	b8					.byte $b8
.9f59					Assemble_tsx:
.9f59	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f5c	ba					.byte $ba
.9f5d					Assemble_iny:
.9f5d	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f60	c8					.byte $c8
.9f61					Assemble_dex:
.9f61	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f64	ca					.byte $ca
.9f65					Assemble_cld:
.9f65	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f68	d8					.byte $d8
.9f69					Assemble_phx:
.9f69	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f6c	da					.byte $da
.9f6d					Assemble_stp:
.9f6d	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f70	db					.byte $db
.9f71					Assemble_inx:
.9f71	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f74	e8					.byte $e8
.9f75					Assemble_nop:
.9f75	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f78	ea					.byte $ea
.9f79					Assemble_sed:
.9f79	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f7c	f8					.byte $f8
.9f7d					Assemble_plx:
.9f7d	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f80	fa					.byte $fa

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/constants.asm

.9f81					DecimalScalarTable:
>9f81	66 66 66 66				.dword $66666666 ; 0.1
>9f85	de					.byte $de
>9f86	1f 85 eb 51				.dword $51eb851f ; 0.01
>9f8a	db					.byte $db
>9f8b	4c 37 89 41				.dword $4189374c ; 0.001
>9f8f	d8					.byte $d8
>9f90	ac 8b db 68				.dword $68db8bac ; 0.0001
>9f94	d4					.byte $d4
>9f95	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>9f99	d1					.byte $d1
>9f9a	83 de 1b 43				.dword $431bde83 ; 1e-06
>9f9e	ce					.byte $ce
>9f9f	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>9fa3	ca					.byte $ca
>9fa4	89 3b e6 55				.dword $55e63b89 ; 1e-08
>9fa8	c7					.byte $c7
>9fa9	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>9fad	c4					.byte $c4
>9fae	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>9fb2	c0					.byte $c0
>9fb3	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>9fb7	bd					.byte $bd

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.asm

.9fb8					SyntaxError:
.9fb8	a9 02		lda #$02		lda	#2
.9fba	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler
.9fbd					RangeError:
.9fbd	a9 04		lda #$04		lda	#4
.9fbf	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler
.9fc2					TypeError:
.9fc2	a9 05		lda #$05		lda	#5
.9fc4	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler
.9fc7					ArgumentError:
.9fc7	a9 07		lda #$07		lda	#7
.9fc9	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler
.9fcc					NotDoneError:
.9fcc	a9 0c		lda #$0c		lda	#12
.9fce	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler
.9fd1					ErrorText:
>9fd1	42 72 65 61 6b 00			.text	"Break",0
>9fd7	53 79 6e 74 61 78 20 65			.text	"Syntax error",0
>9fdf	72 72 6f 72 00
>9fe4	44 69 76 69 73 69 6f 6e			.text	"Division by zero",0
>9fec	20 62 79 20 7a 65 72 6f 00
>9ff5	4f 75 74 20 6f 66 20 52			.text	"Out of Range",0
>9ffd	61 6e 67 65 00
>a002	54 79 70 65 20 6d 69 73			.text	"Type mismatch",0
>a00a	6d 61 74 63 68 00
>a010	4f 75 74 20 6f 66 20 6d			.text	"Out of memory",0
>a018	65 6d 6f 72 79 00
>a01e	49 6c 6c 65 67 61 6c 20			.text	"Illegal argument",0
>a026	61 72 67 75 6d 65 6e 74 00
>a02f	53 74 6f 70 00				.text	"Stop",0
>a034	53 74 72 69 6e 67 20 74			.text	"String too long",0
>a03c	6f 6f 20 6c 6f 6e 67 00
>a044	41 73 73 65 72 74 69 6f			.text	"Assertion failed",0
>a04c	6e 20 66 61 69 6c 65 64 00
>a055	4f 75 74 20 6f 66 20 64			.text	"Out of data",0
>a05d	61 74 61 00
>a061	55 6e 69 6d 70 6c 65 6d			.text	"Unimplemented",0
>a069	65 6e 74 65 64 00
>a06f	4e 6f 20 73 75 63 68 20			.text	"No such line number",0
>a077	6c 69 6e 65 20 6e 75 6d 62 65 72 00
>a083	52 65 74 75 72 6e 20 77			.text	"Return without Gosub",0
>a08b	69 74 68 6f 75 74 20 47 6f 73 75 62 00
>a098	55 6e 74 69 6c 20 77 69			.text	"Until without Repeat",0
>a0a0	74 68 6f 75 74 20 52 65 70 65 61 74 00
>a0ad	57 65 6e 64 20 77 69 74			.text	"Wend without While",0
>a0b5	68 6f 75 74 20 57 68 69 6c 65 00
>a0c0	4e 65 78 74 20 77 69 74			.text	"Next without For",0
>a0c8	68 6f 75 74 20 46 6f 72 00
>a0d1	42 41 53 49 43 20 53 74			.text	"BASIC Stack full",0
>a0d9	61 63 6b 20 66 75 6c 6c 00
>a0e2	4f 70 65 6e 20 53 74 72			.text	"Open Structure",0
>a0ea	75 63 74 75 72 65 00
>a0f1	45 6e 64 50 72 6f 63 20			.text	"EndProc without call",0
>a0f9	77 69 74 68 6f 75 74 20 63 61 6c 6c 00
>a106	41 72 72 61 79 20 61 6c			.text	"Array already defined",0
>a10e	72 65 61 64 79 20 64 65 66 69 6e 65 64 00
>a11c	41 72 72 61 79 20 73 69			.text	"Array size",0
>a124	7a 65 00
>a127	42 61 64 20 61 72 72 61			.text	"Bad array index",0
>a12f	79 20 69 6e 64 65 78 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/timestamp.asm

>a137	42 75 69 6c 74 20 54 75			.text "Built Tuesday 22-Nov-2022. Build 3502."
>a13f	65 73 64 61 79 20 32 32 2d 4e 6f 76 2d 32 30 32
>a14f	32 2e 20 42 75 69 6c 64 20 33 35 30 32 2e

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcommand.asm

.a15d					RectangleCommand:
.a15d	a9 44		lda #$44			lda 	#GCMD_FrameRect				; frame rectangle
.a15f	80 02		bra $a163			bra 	ShapeDrawCmd
.a161					CircleCommand:
.a161	a9 48		lda #$48			lda 	#GCMD_FrameCircle 				; framed circle
.a163					ShapeDrawCmd:
.a163	20 f1 a1	jsr $a1f1			jsr 	RunGraphicsCommand
.a166					ShapeDraw:
.a166	0d 2f 06	ora $062f			ora 	gxFillSolid  				; adjust AXY for solid fill.
.a169	4c e5 a1	jmp $a1e5			jmp 	ExecuteGraphicCommand	 	; and complete
.a16c					SpriteCommand:
.a16c	a2 00		ldx #$00			ldx 	#0
.a16e	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger 		; get image number.
.a171	5a		phy				phy
.a172	a9 0e		lda #$0e			lda 	#GCMD_SpriteUse 			; use that image.
.a174	ae 08 04	ldx $0408			ldx 	NSMantissa0
.a177	e0 40		cpx #$40			cpx 	#64 						; 0-63 only
.a179	b0 0d		bcs $a188			bcs 	_SCRange
.a17b	a0 ff		ldy #$ff			ldy 	#255
.a17d	20 e4 aa	jsr $aae4			jsr 	GXGraphicDraw
.a180	a9 52		lda #$52			lda 	#GCMD_SpriteMove
.a182	7a		ply				ply
.a183	20 f1 a1	jsr $a1f1			jsr 	RunGraphicsCommand
.a186	80 5d		bra $a1e5			bra 	ExecuteGraphicCommand
.a188					_SCRange:
.a188	4c bd 9f	jmp $9fbd			jmp 	RangeError
.a18b					ImageCommand:
.a18b	a2 00		ldx #$00			ldx 	#0
.a18d	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger 		; get image number.
.a190	20 f1 a1	jsr $a1f1			jsr 	RunGraphicsCommand
.a193					ImageRunDraw:
.a193	09 40		ora #$40			ora 	#GCMD_Move					; move cursor
.a195	20 e4 aa	jsr $aae4			jsr 	GXGraphicDraw
.a198	ad 35 06	lda $0635			lda 	gxDrawScale
.a19b	0a		asl a				asl 	a
.a19c	0a		asl a				asl 	a
.a19d	0a		asl a				asl 	a
.a19e	a8		tay				tay
.a19f	a9 0c		lda #$0c			lda 	#GCMD_DrawSprite 			; image drawing
.a1a1	ae 08 04	ldx $0408			ldx 	NSMantissa0
.a1a4	20 e4 aa	jsr $aae4			jsr 	GXGraphicDraw
.a1a7	60		rts				rts
.a1a8					TextCommand:
.a1a8	a2 00		ldx #$00			ldx 	#0
.a1aa	20 62 9d	jsr $9d62			jsr 	EvaluateString 				; get text
.a1ad	20 f1 a1	jsr $a1f1			jsr 	RunGraphicsCommand
.a1b0					TextRunDraw:
.a1b0	09 40		ora #$40			ora 	#GCMD_Move 					; move cursor
.a1b2	20 e4 aa	jsr $aae4			jsr 	GXGraphicDraw
.a1b5	a0 00		ldy #$00			ldy 	#0
.a1b7					_IRDLoop:
.a1b7	ad 10 04	lda $0410			lda 	NSMantissa1 				; access character
.a1ba	85 37		sta $37				sta 	zTemp0+1
.a1bc	ad 08 04	lda $0408			lda 	NSMantissa0
.a1bf	85 36		sta $36				sta 	zTemp0
.a1c1	b1 36		lda ($36),y			lda 	(zTemp0),y
.a1c3	f0 13		beq $a1d8			beq 	_IRDExit
.a1c5	5a		phy				phy									; save string pos
.a1c6	48		pha				pha 								; save char
.a1c7	ad 35 06	lda $0635			lda 	gxDrawScale 				; get scale
.a1ca	0a		asl a				asl 	a
.a1cb	0a		asl a				asl 	a
.a1cc	0a		asl a				asl 	a
.a1cd	a8		tay				tay
.a1ce	a9 0a		lda #$0a			lda 	#GCMD_DrawFont 				; char drawing
.a1d0	fa		plx				plx 								; char to draw
.a1d1	20 e4 aa	jsr $aae4			jsr 	GXGraphicDraw
.a1d4	7a		ply				ply 								; restore string pos
.a1d5	c8		iny				iny
.a1d6	90 df		bcc $a1b7			bcc 	_IRDLoop 					; go back if no error.
.a1d8					_IRDExit:
.a1d8	60		rts				rts
.a1d9					PlotCommand:
.a1d9	a9 50		lda #$50			lda 	#GCMD_Plot 					; command ID to use
.a1db	20 f1 a1	jsr $a1f1			jsr 	RunGraphicsCommand
.a1de	80 05		bra $a1e5			bra 	ExecuteGraphicCommand
.a1e0					LineCommand:
.a1e0	a9 42		lda #$42			lda 	#GCMD_Line 						; command ID to use
.a1e2	20 f1 a1	jsr $a1f1			jsr 	RunGraphicsCommand
.a1e5					ExecuteGraphicCommand:
.a1e5	0d 2e 06	ora $062e			ora 	gxCommandID 				; make a full command
.a1e8	20 e4 aa	jsr $aae4			jsr 	GXGraphicDraw 				; draw it and exit
.a1eb	b0 01		bcs $a1ee			bcs 	_EGCError
.a1ed	60		rts				rts
.a1ee					_EGCError:
.a1ee	4c b8 9f	jmp $9fb8			jmp 	SyntaxError
.a1f1					RunGraphicsCommand:
.a1f1	8d 2e 06	sta $062e			sta 	gxCommandID					; save TODO graphics command.
.a1f4	68		pla				pla 								; pop handler address
.a1f5	fa		plx				plx
.a1f6	1a		inc a				inc 	a
.a1f7	d0 01		bne $a1fa			bne 	_RGINoCarry
.a1f9	e8		inx				inx
.a1fa					_RGINoCarry:
.a1fa	8d 33 06	sta $0633			sta 	GXHandler
.a1fd	8e 34 06	stx $0634			stx 	GXHandler+1
.a200					_RGICommandLoop:
.a200	b1 30		lda ($30),y			lda 	(codePtr),y
.a202	c8		iny				iny
.a203	c9 cd		cmp #$cd			cmp 	#KWD_TO						; is it TO x,y
.a205	f0 53		beq $a25a			beq 	_RGI_To
.a207	c9 ba		cmp #$ba			cmp 	#KWD_HERE 					; do it here.
.a209	f0 55		beq $a260			beq 	_RGI_Here
.a20b	c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL or : , exit
.a20d	f0 3d		beq $a24c			beq 	_RGI_Exit
.a20f	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.a211	f0 39		beq $a24c			beq 	_RGI_Exit
.a213	c9 c1		cmp #$c1			cmp 	#KWD_OUTLINE 				; solid or outline
.a215	f0 3e		beq $a255			beq 	_RGI_Frame
.a217	c9 c9		cmp #$c9			cmp 	#KWD_SOLID
.a219	f0 33		beq $a24e			beq 	_RGI_Solid
.a21b	c9 ab		cmp #$ab			cmp 	#KWD_BY 					; by offset
.a21d	f0 4b		beq $a26a			beq 	_RGI_By
.a21f	c9 b6		cmp #$b6			cmp 	#KWD_FROM 					; from
.a221	f0 17		beq $a23a			beq 	_RGI_Move2
.a223	c9 b3		cmp #$b3			cmp 	#KWD_DIM 					; dim (set scale)
.a225	f0 65		beq $a28c			beq 	_RGI_Dim
.a227	c9 b1		cmp #$b1			cmp 	#KWD_COLOUR 				; colour or Color
.a229	f0 78		beq $a2a3			beq 	_RGI_Colour
.a22b	c9 b0		cmp #$b0			cmp 	#KWD_COLOR
.a22d	f0 74		beq $a2a3			beq 	_RGI_Colour
.a22f	ae 2e 06	ldx $062e			ldx 	gxCommandID
.a232	e0 52		cpx #$52			cpx 	#GCMD_SpriteMove 			; if not sprite
.a234	d0 03		bne $a239			bne 	_RGI_Move 					; move
.a236	4c cd a2	jmp $a2cd			jmp		_RGI_SpriteInstructions
.a239					_RGI_Move:
.a239	88		dey				dey 								; unpick get.
.a23a					_RGI_Move2:
.a23a	20 f3 a2	jsr $a2f3			jsr 	GCGetCoordinatePair 		; move to here
.a23d	20 1a a3	jsr $a31a			jsr 	GCCopyPairToStore 			; save
.a240	5a		phy				phy
.a241	20 10 a3	jsr $a310			jsr 	GCLoadAXY 					; load in
.a244	09 40		ora #$40			ora 	#GCMD_Move 					; move there
.a246	20 e4 aa	jsr $aae4			jsr 	GXGraphicDraw
.a249	7a		ply				ply
.a24a	80 b4		bra $a200			bra 	_RGICommandLoop 			; and go round
.a24c					_RGI_Exit:
.a24c	88		dey				dey 								; unpick : / EOL
.a24d	60		rts				rts
.a24e					_RGI_Solid:
.a24e	a9 02		lda #$02			lda 	#2
.a250	8d 2f 06	sta $062f			sta 	gxFillSolid
.a253	80 ab		bra $a200			bra 	_RGICommandLoop
.a255					_RGI_Frame:
.a255	9c 2f 06	stz $062f			stz 	gxFillSolid
.a258	80 a6		bra $a200			bra 	_RGICommandLoop
.a25a					_RGI_To:
.a25a	20 f3 a2	jsr $a2f3			jsr 	GCGetCoordinatePair 		; get coordinate pair into slot #1,#2
.a25d	20 1a a3	jsr $a31a			jsr 	GCCopyPairToStore
.a260					_RGI_Here:
.a260	5a		phy				phy
.a261	20 10 a3	jsr $a310			jsr 	GCLoadAXY 					; load it into AXY
.a264	20 ca a2	jsr $a2ca			jsr 	_RGICallHandler 			; go do whatever it is.
.a267	7a		ply				ply
.a268	80 96		bra $a200			bra 	_RGICommandLoop 			; and go round
.a26a					_RGI_By:
.a26a	20 00 a3	jsr $a300			jsr 	GCSignedCoordinatePair 		; get coordinate pair into slot #1,#2
.a26d	18		clc				clc
.a26e	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; copy it into space.
.a271	6d 30 06	adc $0630			adc 	gxxPos
.a274	8d 30 06	sta $0630			sta 	gxXPos
.a277	ad 11 04	lda $0411			lda 	NSMantissa1+1
.a27a	6d 31 06	adc $0631			adc 	gxxPos+1
.a27d	8d 31 06	sta $0631			sta 	gxXPos+1
.a280	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a283	18		clc				clc
.a284	6d 32 06	adc $0632			adc 	gxYPos
.a287	8d 32 06	sta $0632			sta 	gxYPos
.a28a	80 d4		bra $a260			bra 	_RGI_Here
.a28c					_RGI_Dim:
.a28c	a2 01		ldx #$01			ldx	 	#1
.a28e	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger
.a291	ad 09 04	lda $0409			lda 	NSMantissa0+1
.a294	c9 00		cmp #$00			cmp 	#0
.a296	f0 2f		beq $a2c7			beq 	_RGIRange
.a298	c9 09		cmp #$09			cmp 	#8+1
.a29a	b0 2b		bcs $a2c7			bcs		_RGIRange
.a29c	3a		dec a				dec 	a
.a29d	8d 35 06	sta $0635			sta 	gxDrawScale
.a2a0	4c 00 a2	jmp $a200			jmp 	_RGICommandLoop
.a2a3					_RGI_Colour:
.a2a3	a2 01		ldx #$01			ldx 	#1 							; colour
.a2a5	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger
.a2a8	a2 02		ldx #$02			ldx 	#2 							; default zero for 2nd parameter
.a2aa	20 2e 9e	jsr $9e2e			jsr 	NSMSetZero
.a2ad	b1 30		lda ($30),y			lda 	(codePtr),y
.a2af	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; check , => mode.
.a2b1	d0 04		bne $a2b7			bne 	_RGICDefaultMode
.a2b3	c8		iny				iny
.a2b4	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger
.a2b7					_RGICDefaultMode:
.a2b7	5a		phy				phy
.a2b8	a9 08		lda #$08			lda 	#GCMD_Colour 				; set colour.
.a2ba	ae 09 04	ldx $0409			ldx 	NSMantissa0+1
.a2bd	ac 0a 04	ldy $040a			ldy 	NSMantissa0+2
.a2c0	20 e4 aa	jsr $aae4			jsr 	GXGraphicDraw
.a2c3	7a		ply				ply
.a2c4	4c 00 a2	jmp $a200			jmp 	_RGICommandLoop 			; and go round
.a2c7					_RGIRange:
.a2c7	4c bd 9f	jmp $9fbd			jmp 	RangeError
.a2ca					_RGICallHandler:
.a2ca	6c 33 06	jmp ($0633)			jmp 	(GXHandler)
.a2cd					_RGI_SpriteInstructions:
.a2cd	c9 bf		cmp #$bf			cmp 	#KWD_OFF
.a2cf	f0 07		beq $a2d8			beq 	_RGISpriteOff
.a2d1	c9 bb		cmp #$bb			cmp 	#KWD_IMAGE
.a2d3	f0 13		beq $a2e8			beq 	_RGISetImage
.a2d5	4c 39 a2	jmp $a239			jmp 	_RGI_Move
.a2d8					_RGISpriteOff:
.a2d8	5a		phy				phy
.a2d9	a0 01		ldy #$01			ldy 	#1
.a2db	a2 00		ldx #$00			ldx 	#0
.a2dd					_RGIDoCommandLoop:
.a2dd	a9 10		lda #$10			lda 	#GCMD_SpriteImage
.a2df	20 e4 aa	jsr $aae4			jsr 	GXGraphicDraw
.a2e2	7a		ply				ply
.a2e3	b0 e2		bcs $a2c7			bcs 	_RGIRange
.a2e5	4c 00 a2	jmp $a200			jmp 	_RGICommandLoop
.a2e8					_RGISetImage:
.a2e8	a2 01		ldx #$01			ldx 	#1
.a2ea	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger
.a2ed	5a		phy				phy
.a2ee	aa		tax				tax
.a2ef	a0 00		ldy #$00			ldy 	#0
.a2f1	80 ea		bra $a2dd			bra 	_RGIDoCommandLoop
.a2f3					GCGetCoordinatePair:
.a2f3	a2 01		ldx #$01			ldx 	#1
.a2f5	20 8f 9d	jsr $9d8f			jsr 	Evaluate16BitInteger
.a2f8	20 5a 8d	jsr $8d5a			jsr 	CheckComma
.a2fb	e8		inx				inx
.a2fc	20 8f 9d	jsr $9d8f			jsr 	Evaluate16BitInteger
.a2ff	60		rts				rts
.a300					GCSignedCoordinatePair:
.a300	a2 01		ldx #$01			ldx 	#1
.a302	20 9b 9d	jsr $9d9b			jsr 	Evaluate16BitIntegerSigned
.a305	20 5a 8d	jsr $8d5a			jsr 	CheckComma
.a308	e8		inx				inx
.a309	20 9b 9d	jsr $9d9b			jsr 	Evaluate16BitIntegerSigned
.a30c	60		rts				rts
.a30d					_GCCPRange:
.a30d	4c bd 9f	jmp $9fbd			jmp 	RangeError
.a310					GCLoadAXY:
.a310	ad 31 06	lda $0631			lda 	gxXPos+1
.a313	ae 30 06	ldx $0630			ldx 	gxXPos
.a316	ac 32 06	ldy $0632			ldy 	gxYPos
.a319	60		rts				rts
.a31a					GCCopyPairToStore:
.a31a	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; copy it into space.
.a31d	8d 30 06	sta $0630			sta 	gxXPos
.a320	ad 11 04	lda $0411			lda 	NSMantissa1+1
.a323	8d 31 06	sta $0631			sta 	gxXPos+1
.a326	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a329	8d 32 06	sta $0632			sta 	gxYPos
.a32c	60		rts				rts
.062e					gxCommandID:
>062e							.fill 	1
.062f					gxFillSolid:
>062f							.fill 	1
.0630					gxXPos:
>0630							.fill 	2
.0632					gxYPos:
>0632							.fill 	1
.0633					gxHandler:
>0633							.fill 	2
.0635					gxDrawScale:
>0635							.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcontrol.asm

.a32d					BitmapCtrl:
.a32d	b1 30		lda ($30),y			lda 	(codePtr),y
.a32f	c8		iny				iny
.a330	a2 01		ldx #$01			ldx 	#1
.a332	c9 c0		cmp #$c0			cmp 	#KWD_ON
.a334	f0 11		beq $a347			beq 	BitmapSwitch
.a336	ca		dex				dex
.a337	c9 bf		cmp #$bf			cmp 	#KWD_OFF
.a339	f0 0c		beq $a347			beq 	BitmapSwitch
.a33b	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger 		; get the colour
.a33e	5a		phy				phy
.a33f	aa		tax				tax
.a340	a9 06		lda #$06			lda 	#GCMD_Clear					; clear to that colour
.a342	20 e4 aa	jsr $aae4			jsr 	GXGraphicDraw
.a345	7a		ply				ply
.a346	60		rts				rts
.a347					BitmapSwitch:
.a347	5a		phy				phy
.a348	a0 00		ldy #$00			ldy 	#0 							; gfx 1,on/off,0
.a34a	a9 02		lda #$02			lda 	#GCMD_BitmapCtl
.a34c	20 e4 aa	jsr $aae4			jsr 	GXGraphicDraw
.a34f	a9 08		lda #$08			lda 	#GCMD_Colour				; set colour to $FF
.a351	a0 00		ldy #$00			ldy 	#0
.a353	a2 ff		ldx #$ff			ldx 	#$FF
.a355	20 e4 aa	jsr $aae4			jsr 	GXGraphicDraw
.a358	9c 2f 06	stz $062f			stz 	gxFillSolid
.a35b	9c 30 06	stz $0630			stz 	gxXPos
.a35e	9c 31 06	stz $0631			stz 	gxXPos+1
.a361	9c 32 06	stz $0632			stz 	gxYPos
.a364	9c 35 06	stz $0635			stz 	gxDrawScale
.a367	a9 40		lda #$40			lda 	#GCMD_Move 						; home cursor
.a369	a2 00		ldx #$00			ldx 	#0
.a36b	a0 00		ldy #$00			ldy 	#0
.a36d	20 e4 aa	jsr $aae4			jsr 	GXGraphicDraw
.a370	7a		ply				ply
.a371	60		rts				rts
.a372					SpritesCtrl:
.a372	b1 30		lda ($30),y			lda 	(codePtr),y
.a374	c8		iny				iny
.a375	a2 01		ldx #$01			ldx 	#1
.a377	c9 c0		cmp #$c0			cmp 	#KWD_ON
.a379	f0 08		beq $a383			beq 	SpriteSwitch
.a37b	ca		dex				dex
.a37c	c9 bf		cmp #$bf			cmp 	#KWD_OFF
.a37e	f0 03		beq $a383			beq 	SpriteSwitch
.a380	4c b8 9f	jmp $9fb8			jmp 	SyntaxError
.a383					SpriteSwitch:
.a383	5a		phy				phy
.a384	a0 00		ldy #$00			ldy 	#0 							; gfx 2,on/off,0
.a386	a9 04		lda #$04			lda 	#GCMD_SpriteCtl
.a388	20 e4 aa	jsr $aae4			jsr 	GXGraphicDraw
.a38b	7a		ply				ply
.a38c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gfx.asm

.a38d					GfxCommand:
.a38d	a2 00		ldx #$00			ldx 	#0
.a38f	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger 		; command
.a392	20 5a 8d	jsr $8d5a			jsr 	CheckComma
.a395	e8		inx				inx
.a396	20 8f 9d	jsr $9d8f			jsr 	Evaluate16BitInteger 		; X
.a399	20 5a 8d	jsr $8d5a			jsr 	CheckComma
.a39c	e8		inx				inx
.a39d	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger 		; Y
.a3a0	ad 11 04	lda $0411			lda 	NSMantissa1+1  				; shift bit 0 of X into CS, should now be zero
.a3a3	4a		lsr a				lsr 	a
.a3a4	d0 16		bne $a3bc			bne 	_GfxError
.a3a6	2e 08 04	rol $0408			rol 	NSMantissa0 				; rotate into command
.a3a9	b0 11		bcs $a3bc			bcs 	_GfxError 					; bit 7 should have been zero
.a3ab	5a		phy				phy 								; save pos
.a3ac	ad 08 04	lda $0408			lda 	NSMantissa0 				; do the command
.a3af	ae 09 04	ldx $0409			ldx 	NSMantissa0+1
.a3b2	ac 0a 04	ldy $040a			ldy 	NSMantissa0+2
.a3b5	20 e4 aa	jsr $aae4			jsr 	GXGraphicDraw
.a3b8	b0 02		bcs $a3bc			bcs 	_GfxError
.a3ba	7a		ply				ply 								; restore pos and exit.
.a3bb	60		rts				rts
.a3bc					_GfxError:
.a3bc	4c bd 9f	jmp $9fbd			jmp 	RangeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/hit.asm

.a3bf					UnaryHit:
.a3bf	fa		plx				plx
.a3c0	a9 36		lda #$36			lda 	#zTemp0
.a3c2	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger 		; get sprite number 0
.a3c5	20 5a 8d	jsr $8d5a			jsr 	CheckComma
.a3c8	e8		inx				inx
.a3c9	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger 		; get sprite number 1
.a3cc	20 52 8d	jsr $8d52			jsr		CheckRightBracket
.a3cf	ca		dex				dex 								; fix back up again.
.a3d0	da		phx				phx 								; save X/Y
.a3d1	5a		phy				phy
.a3d2	bc 09 04	ldy $0409,x			ldy 	NSMantissa0+1,x 			; get the sprite numbers into X/Y
.a3d5	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a3d8	aa		tax				tax
.a3d9	a9 12		lda #$12			lda 	#GCMD_SpriteCollide 		; command check collision.
.a3db	20 e4 aa	jsr $aae4			jsr 	GXGraphicDraw 				; calculate result
.a3de	1a		inc a				inc 	a 							; so 255 (fail) -> 0, otherwise 1,2,3,4 pixels etc.
.a3df	7a		ply				ply 								; restore XY
.a3e0	fa		plx				plx
.a3e1	20 30 9e	jsr $9e30			jsr 	NSMSetByte 					; return the hit result
.a3e4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/palette.asm

.a3e5					PaletteCommand:
.a3e5	a2 00		ldx #$00			ldx 	#0
.a3e7	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger 		; colour
.a3ea	20 5a 8d	jsr $8d5a			jsr 	CheckComma
.a3ed	e8		inx				inx
.a3ee	20 8f 9d	jsr $9d8f			jsr 	Evaluate16BitInteger 		; r
.a3f1	20 5a 8d	jsr $8d5a			jsr 	CheckComma
.a3f4	e8		inx				inx
.a3f5	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger 		; g
.a3f8	20 5a 8d	jsr $8d5a			jsr 	CheckComma
.a3fb	e8		inx				inx
.a3fc	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger 		; b
.a3ff	ad 08 04	lda $0408			lda 	NSMantissa0 				; get colour #
.a402	85 36		sta $36				sta 	zTemp0
.a404	a9 34		lda #$34			lda 	#$D0 >> 2 					; MSB = D0/4
.a406	85 37		sta $37				sta 	zTemp0+1
.a408	06 36		asl $36				asl 	zTemp0 						; zTemp = $D000+Colour x 4
.a40a	26 37		rol $37				rol	 	zTemp0+1
.a40c	06 36		asl $36				asl 	zTemp0
.a40e	26 37		rol $37				rol	 	zTemp0+1
.a410	a9 01		lda #$01			lda 	#1 							; I/O Page 2
.a412	85 01		sta $01				sta 	1
.a414	5a		phy				phy
.a415	ad 0b 04	lda $040b			lda 	NSMantissa0+3 				; fix to r,g,b
.a418	92 36		sta ($36)			sta 	(zTemp0)
.a41a	a0 01		ldy #$01			ldy 	#1
.a41c	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a41f	91 36		sta ($36),y			sta 	(zTemp0),y
.a421	ad 09 04	lda $0409			lda 	NSMantissa0+1
.a424	c8		iny				iny
.a425	91 36		sta ($36),y			sta 	(zTemp0),y
.a427	7a		ply				ply
.a428	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/event.asm

.a429					UnaryEvent:
.a429	fa		plx				plx
.a42a	20 d1 a4	jsr $a4d1			jsr 	TimerToStackX 				; timer in +0
.a42d	e8		inx				inx  								; put reference into +1
.a42e	20 f4 97	jsr $97f4			jsr 	EvaluateTerm
.a431	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if is integer reference
.a434	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.a436	d0 57		bne $a48f			bne 	_UEType
.a438	e8		inx				inx 								; put the step in +2
.a439	20 5a 8d	jsr $8d5a			jsr 	CheckComma
.a43c	20 8f 9d	jsr $9d8f			jsr 	Evaluate16BitInteger
.a43f	20 52 8d	jsr $8d52			jsr 	CheckRightBracket
.a442	ca		dex				dex
.a443	ca		dex				dex
.a444	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; copy reference to zTemp0
.a447	85 36		sta $36				sta 	zTemp0
.a449	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.a44c	85 37		sta $37				sta 	zTemp0+1
.a44e	5a		phy				phy
.a44f	a0 03		ldy #$03			ldy 	#3 							; check bit 7 of last bit, the packed sign bit
.a451	b1 36		lda ($36),y			lda 	(zTemp0),y
.a453	30 36		bmi $a48b			bmi 	_UEFalse 					; exit if signed.
.a455	a0 00		ldy #$00			ldy 	#0 							; has it timed out (24 bit)
.a457	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a45a	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.a45c	c8		iny				iny
.a45d	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a460	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a462	c8		iny				iny
.a463	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.a466	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a468	90 21		bcc $a48b			bcc 	_UEFalse 					; no, return FALSE.
.a46a	18		clc				clc
.a46b	a0 00		ldy #$00			ldy 	#0 							; work out new value as timer() + step
.a46d	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a470	7d 0a 04	adc $040a,x			adc 	NSMantissa0+2,x
.a473	91 36		sta ($36),y			sta 	(zTemp0),y
.a475	c8		iny				iny
.a476	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a479	7d 12 04	adc $0412,x			adc 	NSMantissa1+2,x
.a47c	91 36		sta ($36),y			sta 	(zTemp0),y
.a47e	c8		iny				iny
.a47f	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.a482	7d 1a 04	adc $041a,x			adc 	NSMantissa2+2,x
.a485	91 36		sta ($36),y			sta 	(zTemp0),y
.a487	7a		ply				ply
.a488	4c d8 8d	jmp $8dd8			jmp 	ReturnTrue
.a48b					_UEFalse:
.a48b	7a		ply				ply 								; restore Y
.a48c	4c e4 8d	jmp $8de4			jmp 	ReturnFalse 				; and return False
.a48f					_UEType:
.a48f	4c c2 9f	jmp $9fc2			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/joy.asm

.a492					UnaryJoyX:
.a492	18		clc				clc
.a493	80 01		bra $a496			bra 	JoyMain
.a495					UnaryJoyY:
.a495	38		sec				sec
.a496					JoyMain:
.a496	fa		plx				plx 								; get pos
.a497	08		php				php 								; save carry (set for Y)
.a498	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a49b	20 52 8d	jsr $8d52			jsr 	CheckRightBracket
.a49e	20 9d aa	jsr $aa9d			jsr 	EXTReadController 			; read the controller.
.a4a1	28		plp				plp
.a4a2	90 02		bcc $a4a6			bcc 	_JMNoShift 					; if Y then shift bits 3,2 -> 1,0
.a4a4	4a		lsr a				lsr 	a
.a4a5	4a		lsr a				lsr 	a
.a4a6					_JMNoShift:
.a4a6	4a		lsr a				lsr 	a 							; if bit 0 set then right/down e.g. +1
.a4a7	b0 0a		bcs $a4b3			bcs 	_JMIsRight
.a4a9	4a		lsr a				lsr 	a 							; if bit 1 set then left/up e.g. -1
.a4aa	b0 04		bcs $a4b0			bcs 	_JMIsLeft
.a4ac	20 2e 9e	jsr $9e2e			jsr 	NSMSetZero 					; zero result
.a4af	60		rts				rts
.a4b0					_JMIsLeft:
.a4b0	4c d8 8d	jmp $8dd8			jmp 	ReturnTrue
.a4b3					_JMIsRight:
.a4b3	a9 01		lda #$01			lda 	#1
.a4b5	20 30 9e	jsr $9e30			jsr 	NSMSetByte
.a4b8	60		rts				rts
.a4b9					UnaryJoyB:
.a4b9	fa		plx				plx 								; get pos
.a4ba	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a4bd	20 52 8d	jsr $8d52			jsr 	CheckRightBracket
.a4c0	20 9d aa	jsr $aa9d			jsr 	EXTReadController 			; read the controller.
.a4c3	4a		lsr a				lsr 	a
.a4c4	4a		lsr a				lsr 	a
.a4c5	4a		lsr a				lsr 	a
.a4c6	4a		lsr a				lsr 	a
.a4c7	29 01		and #$01			and 	#1
.a4c9	20 30 9e	jsr $9e30			jsr 	NSMSetByte
.a4cc	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/timer.asm

.a4cd					UnaryTimer:
.a4cd	fa		plx				plx
.a4ce	20 52 8d	jsr $8d52			jsr 	CheckRightBracket
.a4d1					TimerToStackX:
.a4d1	20 2e 9e	jsr $9e2e			jsr 	NSMSetZero 					; zero result
.a4d4	64 01		stz $01				stz 	1 							; access I/O
.a4d6	ad 59 d6	lda $d659			lda 	$D659 						; copy timer in
.a4d9	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.a4dc	ad 5a d6	lda $d65a			lda 	$D65A
.a4df	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a4e2	ad 5b d6	lda $d65b			lda 	$D65B
.a4e5	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.a4e8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/delete.asm

.a4e9					MemoryDeleteLine:
.a4e9	20 08 a5	jsr $a508			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a4ec	b2 30		lda ($30)			lda 	(codePtr) 					; size to delete => y
.a4ee	a8		tay				tay
.a4ef					_MDDLLoop:
.a4ef	b1 30		lda ($30),y			lda 	(codePtr),y 				; copy down
.a4f1	92 30		sta ($30)			sta 	(codePtr)
.a4f3	a5 30		lda $30				lda 	codePtr 					; check done the lot.
.a4f5	c5 3a		cmp $3a				cmp 	zTemp2
.a4f7	d0 07		bne $a500			bne 	_MDLDLNext
.a4f9	a5 31		lda $31				lda 	codePtr+1
.a4fb	c5 3b		cmp $3b				cmp 	zTemp2+1
.a4fd	d0 01		bne $a500			bne 	_MDLDLNext
.a4ff					_MDDLExit:
.a4ff	60		rts				rts
.a500					_MDLDLNext:
.a500	e6 30		inc $30				inc 	codePtr						; next byte
.a502	d0 eb		bne $a4ef			bne 	_MDDLLoop
.a504	e6 31		inc $31				inc 	codePtr+1
.a506	80 e7		bra $a4ef			bra 	_MDDLLoop
.a508					IMemoryFindEnd:
.a508	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a50a	85 3a		sta $3a				sta 	0+zTemp2
.a50c	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a50e	85 3b		sta $3b				sta 	1+zTemp2
.a510					_MDLFELoop:
.a510	b2 3a		lda ($3a)			lda 	(zTemp2)
.a512	f0 0b		beq $a51f			beq 	_MDLFEExit
.a514	18		clc				clc
.a515	65 3a		adc $3a				adc 	zTemp2
.a517	85 3a		sta $3a				sta 	zTemp2
.a519	90 f5		bcc $a510			bcc 	_MDLFELoop
.a51b	e6 3b		inc $3b				inc 	zTemp2+1
.a51d	80 f1		bra $a510			bra 	_MDLFELoop
.a51f					_MDLFEExit:
.a51f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/insert.asm

.a520					MemoryInsertLine:
.a520	08		php				php
.a521	20 08 a5	jsr $a508			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a524	a5 3b		lda $3b				lda 	zTemp2+1 					; space ?
.a526	1a		inc a				inc 	a
.a527	c9 7f		cmp #$7f			cmp 	#(BasicEnd >> 8)-1
.a529	b0 36		bcs $a561			bcs 	_MDLIError
.a52b	28		plp				plp
.a52c	90 08		bcc $a536			bcc 	_MDLIFound
.a52e	a5 3a		lda $3a				lda 	zTemp2 						; if CS on entry append.
.a530	85 30		sta $30				sta 	codePtr
.a532	a5 3b		lda $3b				lda 	zTemp2+1
.a534	85 31		sta $31				sta 	codePtr+1
.a536					_MDLIFound:
.a536	ad a8 04	lda $04a8			lda 	tokenOffset 				; insert gap in Y, the offset, e.g. length of the new line
.a539	a8		tay				tay
.a53a					_MDLIInsert:
.a53a	b2 3a		lda ($3a)			lda 	(zTemp2) 					; shift one byte up , at least one covers end case.
.a53c	91 3a		sta ($3a),y			sta 	(zTemp2),y 					; work from top down.
.a53e	a5 30		lda $30				lda 	codePtr 					; done insert point ?
.a540	c5 3a		cmp $3a				cmp 	zTemp2
.a542	d0 06		bne $a54a			bne 	_MDLINext
.a544	a5 31		lda $31				lda 	codePtr+1
.a546	c5 3b		cmp $3b				cmp 	zTemp2+1
.a548	f0 0a		beq $a554			beq 	_MDLIHaveSpace
.a54a					_MDLINext:
.a54a	a5 3a		lda $3a				lda 	zTemp2 						; if no, keep zTemp2 going backwards
.a54c	d0 02		bne $a550			bne 	_MDLINoBorrow
.a54e	c6 3b		dec $3b				dec 	zTemp2+1
.a550					_MDLINoBorrow:
.a550	c6 3a		dec $3a				dec 	zTemp2
.a552	80 e6		bra $a53a			bra 	_MDLIInsert
.a554					_MDLIHaveSpace:
.a554	ac a8 04	ldy $04a8			ldy 	tokenOffset 				; bytes to copy
.a557	88		dey				dey 								; from offset-1 to 0
.a558					_MDLICopy:
.a558	b9 a8 04	lda $04a8,y			lda 	tokenOffset,y
.a55b	91 30		sta ($30),y			sta 	(codePtr),y
.a55d	88		dey				dey
.a55e	10 f8		bpl $a558			bpl 	_MDLICopy
.a560	60		rts				rts
.a561					_MDLIError:
.a561	a9 06		lda #$06		lda	#6
.a563	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler
.a566					MDLAppendLine:
.a566	86 37		stx $37				stx 	zTemp0+1 					; save new line at zTemp0
.a568	85 36		sta $36				sta 	zTemp0
.a56a	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a56c	85 38		sta $38				sta 	0+zTemp1
.a56e	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a570	85 39		sta $39				sta 	1+zTemp1
.a572	b2 38		lda ($38)			lda 	(zTemp1)
.a574	d0 0a		bne $a580			bne 	_MDLANoInitialise
.a576	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a578	8d 36 06	sta $0636			sta 	0+AppendPointer
.a57b	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a57d	8d 37 06	sta $0637			sta 	1+AppendPointer
.a580					_MDLANoInitialise:
.a580	18		clc				clc
.a581	ad 36 06	lda $0636			lda 	AppendPointer 				; copy append pointer to zTemp1 adding the offset as you go
.a584	85 38		sta $38				sta 	zTemp1
.a586	72 36		adc ($36)			adc 	(zTemp0)
.a588	8d 36 06	sta $0636			sta 	AppendPointer
.a58b	ad 37 06	lda $0637			lda 	AppendPointer+1
.a58e	85 39		sta $39				sta 	zTemp1+1
.a590	69 00		adc #$00			adc 	#0
.a592	8d 37 06	sta $0637			sta 	AppendPointer+1
.a595	a0 00		ldy #$00			ldy 	#0
.a597					_MDLACopy:
.a597	b1 36		lda ($36),y			lda 	(zTemp0),y 					; copy new line in
.a599	91 38		sta ($38),y			sta 	(zTemp1),y
.a59b	c8		iny				iny
.a59c	98		tya				tya
.a59d	d2 36		cmp ($36)			cmp 	(zTemp0) 					; done whole line
.a59f	d0 f6		bne $a597			bne 	_MDLACopy
.a5a1	a9 00		lda #$00			lda 	#0 							; end of program.
.a5a3	91 38		sta ($38),y			sta 	(zTemp1),y
.a5a5	60		rts				rts
.0636					AppendPointer:
>0636							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/memory.asm

.a5a6					MemoryNew:
.a5a6	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a5a8	85 30		sta $30				sta 	codePtr
.a5aa	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a5ac	85 31		sta $31				sta 	codePtr+1
.a5ae	a9 00		lda #$00			lda 	#0 							; write zero there erasing the program.
.a5b0	92 30		sta ($30)			sta 	(codePtr)
.a5b2	60		rts				rts
.a5b3					MemoryInline:
.a5b3	98		tya				tya 								; put address into stack,x
.a5b4	18		clc				clc
.a5b5	65 30		adc $30				adc 	codePtr
.a5b7	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.a5ba	a5 31		lda $31				lda 	codePtr+1
.a5bc	69 00		adc #$00			adc 	#0
.a5be	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a5c1	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.a5c4	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.a5c7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/search.asm

.a5c8					MemorySearch:
.a5c8	85 36		sta $36				sta 	zTemp0 						; save line number zTemp0
.a5ca	86 37		stx $37				stx 	zTemp0+1
.a5cc	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a5ce	85 30		sta $30				sta 	codePtr
.a5d0	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a5d2	85 31		sta $31				sta 	codePtr+1
.a5d4					_MTAXLoop:
.a5d4	b2 30		lda ($30)			lda 	(codePtr)
.a5d6	18		clc				clc
.a5d7	f0 21		beq $a5fa			beq 	_MTAXExit 					; reached end, exit with CC.
.a5d9	a0 01		ldy #$01			ldy 	#1 							; calculate current line# - requested line#
.a5db	b1 30		lda ($30),y			lda 	(codePtr),y
.a5dd	38		sec				sec
.a5de	e5 36		sbc $36				sbc 	zTemp0
.a5e0	85 38		sta $38				sta 	zTemp1 						; save interim to set Z
.a5e2	c8		iny				iny 								; do the MSB
.a5e3	b1 30		lda ($30),y			lda 	(codePtr),y
.a5e5	e5 37		sbc $37				sbc 	zTemp0+1
.a5e7	05 38		ora $38				ora 	zTemp1
.a5e9	f0 0f		beq $a5fa			beq 	_MTAXExit	 				; found
.a5eb	b0 0d		bcs $a5fa			bcs 	_MTAXExit 					; current < required exit
.a5ed	18		clc				clc
.a5ee	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.a5f0	65 30		adc $30				adc 	codePtr
.a5f2	85 30		sta $30				sta 	codePtr
.a5f4	90 02		bcc $a5f8			bcc 	_CREExit
.a5f6	e6 31		inc $31				inc 	codePtr+1
.a5f8					_CREExit:
.a5f8	80 da		bra $a5d4			bra 	_MTAXLoop
.a5fa					_MTAXExit:
.a5fa	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/playing.asm

.a5fb					UnaryPlaying:
.a5fb	fa		plx				plx
.a5fc	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger 		; get channel #
.a5ff	48		pha				pha
.a600	20 52 8d	jsr $8d52			jsr		CheckRightBracket
.a603	68		pla				pla
.a604	c9 04		cmp #$04			cmp 	#4
.a606	b0 0c		bcs $a614			bcs 	_UPNotPlaying
.a608	09 20		ora #$20			ora 	#$20 						; query playing ?
.a60a	20 72 b9	jsr $b972			jsr 	SNDCommand
.a60d	c9 00		cmp #$00			cmp 	#0
.a60f	f0 03		beq $a614			beq 	_UPNotPlaying
.a611	4c d8 8d	jmp $8dd8			jmp 	ReturnTrue
.a614					_UPNotPlaying:
.a614	4c e4 8d	jmp $8de4			jmp 	ReturnFalse

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/sound.asm

.a617					SoundCommand:
.a617	b1 30		lda ($30),y			lda 	(codePtr),y
.a619	c9 bf		cmp #$bf			cmp 	#KWD_OFF 					; SOUND OFF ?
.a61b	d0 09		bne $a626			bne 	_SNDMain
.a61d	c8		iny				iny 								; skip OFF
.a61e	a9 3f		lda #$3f			lda 	#$3F 						; call command $3F (silence)
.a620	5a		phy				phy
.a621	20 72 b9	jsr $b972			jsr 	SNDCommand
.a624	7a		ply				ply
.a625	60		rts				rts
.a626					_SNDMain:
.a626	a2 00		ldx #$00			ldx 	#0
.a628	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger 		; channel
.a62b	c9 04		cmp #$04			cmp 	#4 							; must be 0-3
.a62d	b0 50		bcs $a67f			bcs 	_SndError
.a62f	e8		inx				inx 								; do the rest in slot 1.
.a630	20 5a 8d	jsr $8d5a			jsr 	CheckComma
.a633	20 8f 9d	jsr $9d8f			jsr 	Evaluate16BitInteger 		; Pitch
.a636	bd 10 04	lda $0410,x			lda 	NSMantissa1,x 				; must be 10 bit
.a639	c9 10		cmp #$10			cmp 	#16
.a63b	b0 42		bcs $a67f			bcs 	_SndError
.a63d	8d 39 06	sta $0639			sta 	SoundCommandBlock+1 		; Pitch (2 bytes + 0)
.a640	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a643	8d 38 06	sta $0638			sta 	SoundCommandBlock
.a646	20 5a 8d	jsr $8d5a			jsr 	CheckComma
.a649	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger 		; Length (1 byte + 3)
.a64c	8d 3b 06	sta $063b			sta 	SoundCommandBlock+3
.a64f	a9 0f		lda #$0f			lda 	#15
.a651	8d 3a 06	sta $063a			sta 	SoundCommandBlock+2 		; Volume (1 byte + 2)
.a654	9c 3c 06	stz $063c			stz 	SoundCommandBlock+4 		; default slide (2 bytes +4)
.a657	9c 3d 06	stz $063d			stz 	SoundCommandBlock+5
.a65a	b1 30		lda ($30),y			lda 	(codePtr),y
.a65c	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.a65e	d0 10		bne $a670			bne 	_SNDPlay
.a660	c8		iny				iny
.a661	20 9b 9d	jsr $9d9b			jsr 	Evaluate16BitIntegerSigned 	; Slide
.a664	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; Slide (2 bytes + 4)
.a667	8d 3c 06	sta $063c			sta 	SoundCommandBlock+4
.a66a	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a66d	8d 3d 06	sta $063d			sta 	SoundCommandBlock+5
.a670					_SNDPlay:
.a670	5a		phy				phy
.a671	ad 08 04	lda $0408			lda 	NSMantissa0 				; channel.
.a674	09 10		ora #$10			ora 	#$10 						; 1x = Queue sound
.a676	a2 38		ldx #$38			ldx 	#(SoundCommandBlock & $FF)
.a678	a0 06		ldy #$06			ldy 	#(SoundCommandBlock >> 8)
.a67a	20 72 b9	jsr $b972			jsr 	SNDCommand
.a67d	7a		ply				ply
.a67e	60		rts				rts
.a67f					_SndError:
.a67f	4c bd 9f	jmp $9fbd			jmp 	RangeError
.0638					SoundCommandBlock:
>0638							.fill 	6

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/bytes.asm

.a682					StackPushByte:
.a682	48		pha				pha 								; save byte
.a683	a5 34		lda $34				lda 	BasicStack
.a685	d0 09		bne $a690			bne 	_SPBNoBorrow
.a687	c6 35		dec $35				dec 	BasicStack+1
.a689	48		pha				pha
.a68a	a5 35		lda $35				lda 	BasicStack+1
.a68c	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a68e	90 06		bcc $a696			bcc 	_SPBMemory
.a690					_SPBNoBorrow:
.a690	c6 34		dec $34				dec 	BasicStack
.a692	68		pla				pla 								; get back and write
.a693	92 34		sta ($34)			sta 	(BasicStack)
.a695	60		rts				rts
.a696					_SPBMemory:
.a696	a9 12		lda #$12		lda	#18
.a698	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler
.a69b					StackPopByte:
.a69b	b2 34		lda ($34)			lda 	(BasicStack)
.a69d	e6 34		inc $34				inc 	BasicStack
.a69f	d0 02		bne $a6a3			bne 	_SPBNoCarry
.a6a1	e6 35		inc $35				inc 	BasicStack+1
.a6a3					_SPBNoCarry:
.a6a3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/frames.asm

.a6a4					StackOpen:
.a6a4	48		pha				pha 								; save frame byte
.a6a5	29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.a6a7	0a		asl a				asl 	a 							; claim twice this for storage
.a6a8	49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.a6aa	38		sec				sec 								; so basically subtracting from
.a6ab	65 34		adc $34				adc 	basicStack 	 				; basicStack
.a6ad	85 34		sta $34				sta 	basicStack
.a6af	b0 08		bcs $a6b9			bcs 	_SONoBorrow
.a6b1	c6 35		dec $35				dec 	basicStack+1
.a6b3	a5 35		lda $35				lda 	basicStack+1 				; have we reached stack overflow
.a6b5	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a6b7	90 04		bcc $a6bd			bcc 	_SOMemory
.a6b9					_SONoBorrow:
.a6b9	68		pla				pla 								; get marker back and write at TOS
.a6ba	92 34		sta ($34)			sta 	(basicStack)
.a6bc	60		rts				rts
.a6bd					_SOMemory:
.a6bd	a9 12		lda #$12		lda	#18
.a6bf	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler
.a6c2					StackClose:
.a6c2	b2 34		lda ($34)			lda 	(basicStack) 				; get TOS marker
.a6c4	29 0f		and #$0f			and 	#$0F 						; bytes to add back
.a6c6	0a		asl a				asl 	a 							; claim twice this.
.a6c7	65 34		adc $34				adc 	basicStack 					; add to the stack pointer.
.a6c9	85 34		sta $34				sta 	basicStack
.a6cb	90 02		bcc $a6cf			bcc 	_SCExit
.a6cd	e6 35		inc $35				inc 	basicStack+1
.a6cf					_SCExit:
.a6cf	60		rts				rts
.a6d0					StackCheckFrame:
.a6d0	48		pha				pha
.a6d1					_StackRemoveLocals:
.a6d1	b2 34		lda ($34)			lda 	(basicStack) 				; check for local, keep popping them
.a6d3	c9 03		cmp #$03			cmp 	#STK_LOCALS+1
.a6d5	b0 05		bcs $a6dc			bcs 	_SCNoLocal
.a6d7	20 03 88	jsr $8803			jsr 	LocalPopValue
.a6da	80 f5		bra $a6d1			bra 	_StackRemoveLocals
.a6dc					_SCNoLocal:
.a6dc	68		pla				pla
.a6dd	52 34		eor ($34)			eor 	(basicStack) 				; xor with toS marker
.a6df	29 f0		and #$f0			and 	#$F0 						; check type bits
.a6e1	d0 01		bne $a6e4			bne 	_SCFError 					; different, we have structures mixed up
.a6e3	60		rts				rts
.a6e4					_SCFError:
.a6e4	8a		txa				txa 								; report error X
.a6e5	4c 6b 8d	jmp $8d6b			jmp 	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/location.asm

.a6e8					STKSaveCodePosition:
.a6e8	5a		phy				phy
.a6e9	98		tya				tya 								; save Y
.a6ea	a0 05		ldy #$05			ldy 	#5
.a6ec	91 34		sta ($34),y			sta 	(basicStack),y
.a6ee	88		dey				dey 								; save Code Pointer
.a6ef					_STKSaveLoop:
.a6ef	b9 2f 00	lda $002f,y			lda 	safePtr-1,y 				; allows us to access the pointer w/out issues.
.a6f2	91 34		sta ($34),y			sta 	(basicStack),y
.a6f4	88		dey				dey
.a6f5	d0 f8		bne $a6ef			bne 	_STKSaveLoop
.a6f7	7a		ply				ply
.a6f8	60		rts				rts
.a6f9					STKLoadCodePosition:
.a6f9	a0 01		ldy #$01			ldy 	#1 							; load code pointer back
.a6fb					_STKLoadLoop:
.a6fb	b1 34		lda ($34),y			lda 	(basicStack),y
.a6fd	99 2f 00	sta $002f,y			sta 	safePtr-1,y
.a700	c8		iny				iny
.a701	c0 05		cpy #$05			cpy 	#5
.a703	d0 f6		bne $a6fb			bne 	_STKLoadLoop
.a705	b1 34		lda ($34),y			lda 	(basicStack),y 				; get Y offset
.a707	a8		tay				tay
.a708	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/setup.asm

.a709					StackReset:
.a709	a9 ff		lda #$ff			lda 	#((BasicStackBase+BasicStackSize-1) & $FF)
.a70b	85 34		sta $34				sta 	0+basicStack
.a70d	a9 0f		lda #$0f			lda 	#((BasicStackBase+BasicStackSize-1) >> 8)
.a70f	85 35		sta $35				sta 	1+basicStack
.a711	a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.a713	92 34		sta ($34)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.a715	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/concrete.asm

.a716					StringConcrete:
.a716	5a		phy				phy 								; save position on stack
.a717	20 f7 99	jsr $99f7			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a71a	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy target string to zTemp1
.a71d	85 38		sta $38				sta 	zTemp1
.a71f	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a722	85 39		sta $39				sta 	zTemp1+1
.a724	a0 ff		ldy #$ff			ldy 	#$FF	 					; calculate string length
.a726					_SALength:
.a726	c8		iny				iny
.a727	b1 38		lda ($38),y			lda 	(zTemp1),y
.a729	d0 fb		bne $a726			bne 	_SALength
.a72b	c0 fd		cpy #$fd			cpy 	#253 						; string too long
.a72d	b0 3f		bcs $a76e			bcs 	_SALengthError
.a72f	98		tya				tya 				 				; length of the new string
.a730	18		clc				clc
.a731	69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.a733	90 02		bcc $a737			bcc 	_SAHaveLength
.a735	a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.a737					_SAHaveLength:
.a737	48		pha				pha 								; save length.
.a738	38		sec				sec
.a739	49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.a73b	6d 8e 04	adc $048e			adc 	StringMemory
.a73e	8d 8e 04	sta $048e			sta 	StringMemory
.a741	85 3a		sta $3a				sta 	zTemp2 						; update storage address
.a743	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; update mantissa address
.a746	a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.a748	6d 8f 04	adc $048f			adc 	StringMemory+1
.a74b	8d 8f 04	sta $048f			sta 	StringMemory+1
.a74e	85 3b		sta $3b				sta 	zTemp2+1
.a750	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a753	68		pla				pla 								; save length-3 (chars allowed) in first byte
.a754	38		sec				sec
.a755	e9 03		sbc #$03			sbc 	#3
.a757	92 3a		sta ($3a)			sta 	(zTemp2)
.a759	a9 00		lda #$00			lda 	#0 							; clear the status byte.
.a75b	a0 01		ldy #$01			ldy 	#1
.a75d	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a75f					_SACopyNewString:
.a75f	a0 00		ldy #$00			ldy 	#0
.a761					_SACopyNSLoop:
.a761	b1 38		lda ($38),y			lda 	(zTemp1),y 					; get character
.a763	c8		iny				iny 								; write two on in string storage
.a764	c8		iny				iny
.a765	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a767	88		dey				dey 								; this makes it one one.
.a768	c9 00		cmp #$00			cmp 	#0 							; until EOS copied
.a76a	d0 f5		bne $a761			bne 	_SACopyNSLoop
.a76c	7a		ply				ply
.a76d	60		rts				rts
.a76e					_SALengthError:
.a76e	a9 09		lda #$09		lda	#9
.a770	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/stringalloc.asm

.a773					StringSystemInitialise:
.a773	a9 ff		lda #$ff			lda 	#((EndVariableSpace-1) & $FF)
.a775	8d 8e 04	sta $048e			sta 	0+StringMemory
.a778	a9 1f		lda #$1f			lda 	#((EndVariableSpace-1) >> 8)
.a77a	8d 8f 04	sta $048f			sta 	1+StringMemory
.a77d	9c ff 1f	stz $1fff			stz 	EndVariableSpace-1 			; put a zero at the end, so know end of string memory.
.a780	60		rts				rts
.a781					StringSpaceInitialise:
.a781	20 f7 99	jsr $99f7			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a784	a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.a786	8d 90 04	sta $0490			sta 	StringInitialised
.a789	ad 8e 04	lda $048e			lda 	StringMemory 				; allocate 256 bytes for one concreted string
.a78c	8d 91 04	sta $0491			sta 	StringTempPointer
.a78f	ad 8f 04	lda $048f			lda 	StringMemory+1
.a792	3a		dec a				dec 	a
.a793	8d 92 04	sta $0492			sta 	StringTempPointer+1
.a796	60		rts				rts
.a797					StringTempAllocate:
.a797	c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.a799	b0 35		bcs $a7d0			bcs 	_STALength
.a79b	2c 90 04	bit $0490			bit 	StringInitialised 			; already initialised
.a79e	30 05		bmi $a7a5			bmi 	_STAAllocate
.a7a0	48		pha				pha 								; save value to subtract.
.a7a1	20 81 a7	jsr $a781			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.a7a4	68		pla				pla 								; restore it
.a7a5					_STAAllocate:
.a7a5	49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.a7a7	18		clc				clc  								; deliberate allows one more
.a7a8	6d 91 04	adc $0491			adc 	StringTempPointer 			; subtract from temp pointer
.a7ab	8d 91 04	sta $0491			sta 	StringTempPointer
.a7ae	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; address in mantissa
.a7b1	85 3c		sta $3c				sta 	zsTemp 						; and zsTemp
.a7b3	ad 92 04	lda $0492			lda 	StringTempPointer+1
.a7b6	69 ff		adc #$ff			adc 	#$FF
.a7b8	8d 92 04	sta $0492			sta 	StringTempPointer+1
.a7bb	85 3d		sta $3d				sta 	zsTemp+1
.a7bd	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a7c0	9e 18 04	stz $0418,x			stz 	NSMantissa2,x 				; set the typing data
.a7c3	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.a7c6	a9 10		lda #$10			lda 	#NSTString
.a7c8	9d 00 04	sta $0400,x			sta 	NSStatus,x
.a7cb	a9 00		lda #$00			lda 	#0 							; clear the target string
.a7cd	92 3c		sta ($3c)			sta 	(zsTemp)
.a7cf	60		rts				rts
.a7d0					_STALength:
.a7d0	a9 09		lda #$09		lda	#9
.a7d2	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler
.a7d5					StringTempWrite:
.a7d5	48		pha				pha
.a7d6	92 3c		sta ($3c)			sta 	(zsTemp)
.a7d8	e6 3c		inc $3c				inc 	zsTemp
.a7da	d0 02		bne $a7de			bne 	_STWNoCarry
.a7dc	e6 3d		inc $3d				inc 	zsTemp+1
.a7de					_STWNoCarry:
.a7de	a9 00		lda #$00			lda 	#0
.a7e0	92 3c		sta ($3c)			sta 	(zsTemp)
.a7e2	68		pla				pla
.a7e3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_hardware.module

=1					hardwareIntegrated=1
=0					CONBlack = 0
=1					CONWhite = 1
=2					CONRed = 2
=3					CONCyan = 3
=4					CONPurple = 4
=5					CONGreen = 5
=6					CONBlue = 6
=7					CONYellow = 7
=8					CONOrange = 8
=9					CONBrown = 9
=10					CONYellowGreen = 10
=11					CONRosa = 11
=12					CONBlueGreen = 12
=13					CONLightBlue = 13
=14					CONPink = 14
=15					CONLightGreen = 15
=7					CONForeground = CONYellow
=6					CONBackground = CONBlue
=12					CLINumber = CONBlueGreen
=3					CLIToken = CONCyan
=13					CLIConstant = CONLightBlue
=7					CLIIdentifier = CONYellow
=10					CLIPunctuation = CONYellowGreen
=1					CLIData = CONWhite
.a7e4					EXTPrintCharacter:
.a7e4	48		pha				pha
.a7e5	da		phx				phx
.a7e6	5a		phy				phy
.a7e7	a6 01		ldx $01				ldx 	1
.a7e9	da		phx				phx
.a7ea	ac 3f 06	ldy $063f			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.a7ed	09 00		ora #$00			ora 	#$00 						; check $80-$FF
.a7ef	30 48		bmi $a839			bmi 	_EXPCColour
.a7f1	c9 20		cmp #$20			cmp 	#$20 						; check $00-$1F
.a7f3	90 4d		bcc $a842			bcc 	_EXPCControl
.a7f5	a2 02		ldx #$02			ldx 	#2 							; select char memory
.a7f7	86 01		stx $01				stx 	1
.a7f9	91 40		sta ($40),y			sta 	(EXTAddress),y
.a7fb	e6 01		inc $01				inc 	1 							; select colour memory
.a7fd	ad 40 06	lda $0640			lda 	EXTTextColour
.a800	91 40		sta ($40),y			sta 	(EXTAddress),y
.a802	c8		iny				iny 								; advance horizontal position
.a803	8c 3f 06	sty $063f			sty 	EXTColumn
.a806	cc 41 06	cpy $0641			cpy 	EXTScreenWidth 				; reached RHS ?
.a809	90 66		bcc $a871			bcc 	_EXPCExit 					; no, then exit.
.a80b					_EXPCCRLF:
.a80b	ee 3e 06	inc $063e			inc 	EXTRow  					; bump row
.a80e	9c 3f 06	stz $063f			stz 	EXTColumn 					; back to column 0
.a811	ad 3e 06	lda $063e			lda 	EXTRow 						; check if reached the bottom ?
.a814	cd 42 06	cmp $0642			cmp 	EXTScreenHeight 			; if so, then scroll.
.a817	f0 18		beq $a831			beq 	_EXPCScroll
.a819	18		clc				clc 								; add width to address.
.a81a	a5 40		lda $40				lda 	EXTAddress
.a81c	6d 41 06	adc $0641			adc 	EXTScreenWidth
.a81f	85 40		sta $40				sta 	EXTAddress
.a821	90 4e		bcc $a871			bcc 	_EXPCExit
.a823	e6 41		inc $41				inc 	EXTAddress+1
.a825	80 4a		bra $a871			bra 	_EXPCExit
.a827					_EXPCLeft:
.a827	ce 3f 06	dec $063f			dec 	EXTColumn
.a82a	10 45		bpl $a871			bpl 	_EXPCExit
.a82c					_EXPCBegin:
.a82c	9c 3f 06	stz $063f			stz 	EXTColumn
.a82f	80 40		bra $a871			bra 	_EXPCExit
.a831					_EXPCScroll:
.a831	ce 3e 06	dec $063e			dec 	EXTRow 						; the height-1 th line.
.a834	20 fe a8	jsr $a8fe			jsr 	EXTScreenScroll 			; scroll the screen
.a837	80 38		bra $a871			bra 	_EXPCExit
.a839					_EXPCColour:
.a839	c9 a0		cmp #$a0			cmp 	#$A0						; 80-9F set foreground/background
.a83b	b0 34		bcs $a871			bcs 	_EXPCExit
.a83d	20 de a8	jsr $a8de			jsr 	_EXPCHandleColour
.a840	80 2f		bra $a871			bra 	_EXPCExit
.a842					_EXPCControl:
.a842	c9 11		cmp #$11			cmp 	#$11 						; only handle 00-10.
.a844	b0 2b		bcs $a871			bcs 	_EXPCExit
.a846	0a		asl a				asl 	a 							; double into X
.a847	aa		tax				tax
.a848	7c bc a8	jmp ($a8bc,x)			jmp 	(_EXPCActionTable,x) 		; and execute code.
.a84b					_EXPCUp:
.a84b	ad 3e 06	lda $063e			lda 	EXTRow 						; already at top ?
.a84e	f0 21		beq $a871			beq 	_EXPCExit
.a850	ce 3e 06	dec $063e			dec 	EXTRow 						; up one in position/address
.a853	38		sec				sec
.a854	a5 40		lda $40				lda 	EXTAddress
.a856	ed 41 06	sbc $0641			sbc 	EXTScreenWidth
.a859	85 40		sta $40				sta 	EXTAddress
.a85b	b0 14		bcs $a871			bcs 	_EXPCExit
.a85d	c6 41		dec $41				dec 	EXTAddress+1
.a85f	80 10		bra $a871			bra 	_EXPCExit
.a861					_EXPCRight:
.a861	c8		iny				iny
.a862	8c 3f 06	sty $063f			sty 	EXTColumn
.a865	cc 41 06	cpy $0641			cpy 	EXTScreenWidth
.a868	d0 07		bne $a871			bne 	_EXPCExit
.a86a					_EXPCEnd:
.a86a	ad 41 06	lda $0641			lda 	EXTScreenWidth
.a86d	3a		dec a				dec 	a
.a86e	8d 3f 06	sta $063f			sta 	EXTColumn
.a871					_EXPCExit:
.a871	20 53 a9	jsr $a953			jsr 	EXTSetHardwareCursor 		; place the physical cursor.
.a874	68		pla				pla
.a875	85 01		sta $01				sta 	1
.a877	7a		ply				ply
.a878	fa		plx				plx
.a879	68		pla				pla
.a87a	60		rts				rts
.a87b					_EXPCClearScreen:
.a87b	20 10 a9	jsr $a910			jsr		EXTClearScreenCode
.a87e	80 f1		bra $a871			bra 	_EXPCExit
.a880					_EXPCDown:
.a880	ad 42 06	lda $0642			lda 	EXTScreenHeight 			; at the bottom
.a883	3a		dec a				dec 	a
.a884	cd 3e 06	cmp $063e			cmp 	EXTRow
.a887	f0 e8		beq $a871			beq 	_EXPCExit
.a889	ee 3e 06	inc $063e			inc 	EXTRow 						; down one in position/address
.a88c	18		clc				clc
.a88d	a5 40		lda $40				lda 	EXTAddress
.a88f	6d 41 06	adc $0641			adc 	EXTScreenWidth
.a892	85 40		sta $40				sta 	EXTAddress
.a894	90 db		bcc $a871			bcc 	_EXPCExit
.a896	e6 41		inc $41				inc 	EXTAddress+1
.a898	80 d7		bra $a871			bra 	_EXPCExit
.a89a					_EXPCTab:
.a89a	ad 3f 06	lda $063f			lda 	EXTColumn 					; next tab stop
.a89d	29 f8		and #$f8			and 	#$F8
.a89f	18		clc				clc
.a8a0	69 08		adc #$08			adc 	#8
.a8a2	8d 3f 06	sta $063f			sta 	EXTColumn
.a8a5	cd 41 06	cmp $0641			cmp 	EXTScreenWidth 				; too far, stick end of line.
.a8a8	90 c7		bcc $a871			bcc 	_EXPCExit
.a8aa	80 be		bra $a86a			bra 	_EXPCEnd
.a8ac					_EXPCBackSpace:
.a8ac	88		dey				dey
.a8ad	30 c2		bmi $a871			bmi 	_EXPCExit
.a8af	ce 3f 06	dec $063f			dec 	EXTColumn
.a8b2	a9 02		lda #$02			lda 	#2
.a8b4	85 01		sta $01				sta 	1
.a8b6	a9 20		lda #$20			lda 	#32
.a8b8	91 40		sta ($40),y			sta 	(EXTAddress),y
.a8ba	80 b5		bra $a871			bra 	_EXPCExit
.a8bc					_EXPCActionTable:
>a8bc	71 a8						.word 	_EXPCExit 					; 00
>a8be	2c a8						.word 	_EXPCBegin 					; 01 A Start of Line
>a8c0	27 a8						.word 	_EXPCLeft 					; 02 B Left
>a8c2	71 a8						.word 	_EXPCExit 					; 03 <Break>
>a8c4	71 a8						.word 	_EXPCExit 					; 04
>a8c6	6a a8						.word 	_EXPCEnd 					; 05 E End of Line
>a8c8	61 a8						.word 	_EXPCRight 					; 06 F Right
>a8ca	71 a8						.word 	_EXPCExit 					; 07
>a8cc	ac a8						.word 	_EXPCBackspace 				; 08 H Backspace
>a8ce	9a a8						.word 	_EXPCTab 					; 09 I Tab
>a8d0	71 a8						.word 	_EXPCExit 					; 0A
>a8d2	71 a8						.word 	_EXPCExit 					; 0B
>a8d4	7b a8						.word 	_EXPCClearScreen			; 0C L CLS
>a8d6	0b a8						.word 	_EXPCCRLF 					; 0D M CR/LF
>a8d8	80 a8						.word 	_EXPCDown 					; 0E N Down
>a8da	71 a8						.word 	_EXPCExit 					; 0F
>a8dc	4b a8						.word 	_EXPCUp 					; 10 P Up
.a8de					_EXPCHandleColour
.a8de	c9 90		cmp #$90			cmp 	#$90 						; 8x foreground 9x background
.a8e0	b0 16		bcs $a8f8			bcs 	_EXPCBackground
.a8e2	0a		asl a				asl 	a 							; shift it 4 bits to the right.
.a8e3	0a		asl a				asl 	a
.a8e4	0a		asl a				asl 	a
.a8e5	0a		asl a				asl 	a
.a8e6	a2 0f		ldx #$0f			ldx 	#$0F 						; Mask in X
.a8e8					_EXPCUpdate:
.a8e8	48		pha				pha 								; save new colour
.a8e9	8a		txa				txa 								; get mask
.a8ea	2d 40 06	and $0640			and 	EXTTextColour 				; mask out old.
.a8ed	8d 40 06	sta $0640			sta 	EXTTextColour
.a8f0	68		pla				pla 								; or in new colour
.a8f1	0d 40 06	ora $0640			ora 	EXTTextColour
.a8f4	8d 40 06	sta $0640			sta 	EXTTextColour
.a8f7	60		rts				rts
.a8f8					_EXPCBackground:
.a8f8	29 0f		and #$0f			and 	#$0F 						; get the colour
.a8fa	a2 f0		ldx #$f0			ldx 	#$F0 						; mask
.a8fc	80 ea		bra $a8e8			bra 	_EXPCUpdate
.a8fe					EXTScreenScroll:
.a8fe	a9 02		lda #$02			lda 	#2 							; select text page
.a900	85 01		sta $01				sta 	1
.a902	a9 20		lda #$20			lda		#32 						; fill with space
.a904	20 13 aa	jsr $aa13			jsr 	EXTScrollFill
.a907	e6 01		inc $01				inc 	1 							; select colour page
.a909	ad 40 06	lda $0640			lda 	EXTTextColour
.a90c	20 13 aa	jsr $aa13			jsr 	EXTScrollFill
.a90f	60		rts				rts
.a910					EXTClearScreenCode:
.a910	a9 02		lda #$02			lda 	#2 							; select text page
.a912	85 01		sta $01				sta 	1
.a914	a9 20		lda #$20			lda		#32 						; fill with space
.a916	20 23 a9	jsr $a923			jsr 	_EXTCSFill
.a919	e6 01		inc $01				inc 	1 							; select colour page
.a91b	ad 40 06	lda $0640			lda 	EXTTextColour
.a91e	20 23 a9	jsr $a923			jsr 	_EXTCSFill
.a921	80 22		bra $a945			bra 	EXTHomeCursor
.a923					_EXTCSFill:
.a923	aa		tax				tax
.a924	a9 00		lda #$00			lda 	#EXTMemory & $FF
.a926	85 40		sta $40				sta 	EXTAddress
.a928	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a92a	85 41		sta $41				sta 	EXTAddress+1
.a92c					_EXTCSFill1:
.a92c	a0 00		ldy #$00			ldy 	#0
.a92e	8a		txa				txa
.a92f					_EXTCSFill2:
.a92f	91 40		sta ($40),y			sta 	(EXTAddress),y
.a931	c8		iny				iny
.a932	d0 fb		bne $a92f			bne 	_EXTCSFill2
.a934	e6 41		inc $41				inc 	EXTAddress+1
.a936	a5 41		lda $41				lda 	EXTAddress+1
.a938	c9 d2		cmp #$d2			cmp 	#$D2
.a93a	d0 f0		bne $a92c			bne 	_EXTCSFill1
.a93c	8a		txa				txa
.a93d					_EXTCSFill3:
.a93d	91 40		sta ($40),y			sta 	(EXTAddress),y
.a93f	c8		iny				iny
.a940	c0 c0		cpy #$c0			cpy 	#$C0
.a942	d0 f9		bne $a93d			bne 	_EXTCSFill3
.a944	60		rts				rts
.a945					EXTHomeCursor:
.a945	9c 3e 06	stz $063e			stz 	EXTRow 						; reset row & column
.a948	9c 3f 06	stz $063f			stz 	EXTColumn
.a94b	a9 00		lda #$00			lda 	#EXTMemory & $FF 			; set address
.a94d	85 40		sta $40				sta 	EXTAddress
.a94f	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a951	85 41		sta $41				sta 	EXTAddress+1
.a953					EXTSetHardwareCursor:
.a953	64 01		stz $01				stz 	1 							; I/O Page zero
.a955	a9 05		lda #$05			lda 	#1+4 						; enable cursor
.a957	8d 10 d0	sta $d010			sta 	$D010
.a95a	a9 b1		lda #$b1			lda 	#$B1
.a95c	8d 12 d0	sta $d012			sta 	$D012
.a95f	ad 3f 06	lda $063f			lda 	EXTColumn
.a962	8d 14 d0	sta $d014			sta 	$D014 						; set cursor position
.a965	9c 15 d0	stz $d015			stz 	$D015
.a968	ad 3e 06	lda $063e			lda 	EXTRow
.a96b	8d 16 d0	sta $d016			sta 	$D016
.a96e	9c 17 d0	stz $d017			stz 	$D017
.a971	60		rts				rts
.a972					EXTInputLine:
.a972	48		pha				pha
.a973	da		phx				phx
.a974	5a		phy				phy
.a975	a5 01		lda $01				lda 	1 							; save I/O page
.a977	48		pha				pha
.a978					_EILLoop:
.a978	20 7a aa	jsr $aa7a			jsr 	ExtInputSingleCharacter
.a97b	c9 0d		cmp #$0d			cmp 	#13 						; scrape line if exit.
.a97d	f0 40		beq $a9bf			beq 	_EILExit
.a97f	c9 08		cmp #$08			cmp 	#8 							; handle backspace
.a981	f0 1c		beq $a99f			beq 	_EILBackspace
.a983	c9 20		cmp #$20			cmp 	#' '						; < space, print it
.a985	90 12		bcc $a999			bcc 	_EILPrintLoop
.a987	c9 7f		cmp #$7f			cmp 	#$7F 						; if -ve print it
.a989	b0 0e		bcs $a999			bcs 	_EILPrintLoop
.a98b	48		pha				pha 								; save character
.a98c	a9 02		lda #$02			lda 	#2  						; insert a space
.a98e	85 01		sta $01				sta 	1
.a990	20 01 aa	jsr $aa01			jsr 	EXTILInsert 				; insert in text screen
.a993	e6 01		inc $01				inc 	1
.a995	20 01 aa	jsr $aa01			jsr 	EXTILInsert 				; insert in colour screen
.a998	68		pla				pla 								; get character back.
.a999					_EILPrintLoop:
.a999	20 e4 a7	jsr $a7e4			jsr 	ExtPrintCharacter
.a99c	80 da		bra $a978			bra 	_EILLoop
.a99e	60		rts				rts
.a99f					_EILBackspace:
.a99f	ad 3f 06	lda $063f			lda 	EXTColumn					; can we backspace ?
.a9a2	f0 d4		beq $a978			beq 	_EILLoop
.a9a4	a9 02		lda #$02			lda 	#2 							; move cursor left
.a9a6	20 e4 a7	jsr $a7e4			jsr 	EXTPrintCharacter
.a9a9	a9 02		lda #$02			lda 	#2 							; text block
.a9ab	85 01		sta $01				sta 	1
.a9ad	a9 20		lda #$20			lda 	#' ' 						; backspace text.
.a9af	20 ec a9	jsr $a9ec			jsr 	EXTILDelete
.a9b2	e6 01		inc $01				inc 	1 							; colour block
.a9b4	ac 3f 06	ldy $063f			ldy 	EXTColumn 					; get attribute of last character
.a9b7	88		dey				dey
.a9b8	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a9ba	20 ec a9	jsr $a9ec			jsr 	EXTILDelete 				; backspace attribute
.a9bd	80 b9		bra $a978			bra 	_EILLoop 					; and go round.
.a9bf					_EILExit:
.a9bf	a9 02		lda #$02			lda 	#2 							; switch to page 2
.a9c1	85 01		sta $01				sta 	1
.a9c3	a0 00		ldy #$00			ldy 	#0 							; copy current line into buffer.
.a9c5					_EILScrapeLine:
.a9c5	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a9c7	99 a8 05	sta $05a8,y			sta 	lineBuffer,y
.a9ca	c8		iny				iny
.a9cb	cc 41 06	cpy $0641			cpy 	EXTScreenWidth
.a9ce	d0 f5		bne $a9c5			bne 	_EILScrapeLine
.a9d0					_EILTrimSpaces:
.a9d0	88		dey				dey
.a9d1	f0 08		beq $a9db			beq 	_EILEndTrim
.a9d3	b9 a8 05	lda $05a8,y			lda 	lineBuffer,y
.a9d6	c9 20		cmp #$20			cmp 	#' '
.a9d8	f0 f6		beq $a9d0			beq 	_EILTrimSpaces
.a9da	c8		iny				iny 								; trim after non space character.
.a9db					_EILEndTrim:
.a9db	a9 00		lda #$00			lda 	#0 							; trim here.
.a9dd	99 a8 05	sta $05a8,y			sta 	lineBuffer,y
.a9e0	a9 0d		lda #$0d			lda 	#13 						; echo the RETURN
.a9e2	20 e4 a7	jsr $a7e4			jsr 	ExtPrintCharacter
.a9e5	68		pla				pla 								; reset I/O page
.a9e6	85 01		sta $01				sta 	1
.a9e8	7a		ply				ply
.a9e9	fa		plx				plx
.a9ea	68		pla				pla
.a9eb	60		rts				rts
.a9ec					EXTILDelete:
.a9ec	48		pha				pha 								; save the new character
.a9ed	ac 3f 06	ldy $063f			ldy 	EXTColumn 					; start copying from here.
.a9f0					_EXTDLoop:
.a9f0	c8		iny				iny 								; copy one byte down.
.a9f1	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a9f3	88		dey				dey
.a9f4	91 40		sta ($40),y			sta 	(EXTAddress),y
.a9f6	c8		iny				iny 								; do till end of line.
.a9f7	cc 41 06	cpy $0641			cpy 	EXTScreenWidth
.a9fa	90 f4		bcc $a9f0			bcc 	_EXTDLoop
.a9fc	88		dey				dey 	 							; write in last slot.
.a9fd	68		pla				pla
.a9fe	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa00	60		rts				rts
.aa01					EXTILInsert:
.aa01	ac 41 06	ldy $0641			ldy 	EXTScreenWidth 				; end position
.aa04					_EXTILoop:
.aa04	88		dey				dey 								; back one
.aa05	cc 3f 06	cpy $063f			cpy 	EXTColumn 					; exit if reached insert point.
.aa08	f0 08		beq $aa12			beq 	_EXTIExit
.aa0a	88		dey				dey 								; copy one byte up.
.aa0b	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa0d	c8		iny				iny
.aa0e	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa10	80 f2		bra $aa04			bra 	_EXTILoop
.aa12					_EXTIExit:
.aa12	60		rts				rts
.aa13					EXTScrollFill:
.aa13	aa		tax				tax									; save value to fill with
.aa14	a5 36		lda $36				lda 	zTemp0 						; save zTemp0 (dest) zTemp1 (src)
.aa16	48		pha				pha
.aa17	a5 37		lda $37				lda 	zTemp0+1
.aa19	48		pha				pha
.aa1a	a5 38		lda $38				lda 	zTemp1
.aa1c	48		pha				pha
.aa1d	a5 39		lda $39				lda 	zTemp1+1
.aa1f	48		pha				pha
.aa20	a9 c0		lda #$c0			lda 	#$C0 						; copy from C000+length to C000
.aa22	85 37		sta $37				sta 	zTemp0+1
.aa24	85 39		sta $39				sta 	zTemp1+1
.aa26	64 36		stz $36				stz 	zTemp0
.aa28	ad 41 06	lda $0641			lda 	EXTScreenWidth
.aa2b	85 38		sta $38				sta 	zTemp1
.aa2d	a0 00		ldy #$00			ldy 	#0
.aa2f					_EXSFCopy1:
.aa2f	b1 38		lda ($38),y			lda 	(zTemp1),y
.aa31	91 36		sta ($36),y			sta 	(zTemp0),y
.aa33	c8		iny				iny
.aa34	d0 f9		bne $aa2f			bne 	_EXSFCopy1
.aa36	e6 37		inc $37				inc 	zTemp0+1 					; next page
.aa38	e6 39		inc $39				inc 	zTemp1+1
.aa3a	a5 39		lda $39				lda 	zTemp1+1
.aa3c	c9 d3		cmp #$d3			cmp 	#$D3
.aa3e	d0 ef		bne $aa2f			bne 	_EXSFCopy1
.aa40	ac 41 06	ldy $0641			ldy 	EXTScreenWidth 				; blank the bottom line.
.aa43	8a		txa				txa
.aa44					_EXSFFill1:
.aa44	88		dey				dey
.aa45	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa47	c0 00		cpy #$00			cpy 	#0
.aa49	10 f9		bpl $aa44			bpl 	_EXSFFill1
.aa4b	68		pla				pla
.aa4c	85 39		sta $39				sta 	zTemp1+1
.aa4e	68		pla				pla
.aa4f	85 38		sta $38				sta 	zTemp1
.aa51	68		pla				pla
.aa52	85 37		sta $37				sta 	zTemp0+1
.aa54	68		pla				pla
.aa55	85 36		sta $36				sta 	zTemp0
.aa57	60		rts				rts
=$c000					EXTMemory = $C000
=$02					EXTTextPage = $02
=$03					EXTColourPage = $03
=1					EXTDummySpace = 1 							; fake-space for CR character.
=0					EXTCBlack = 0
.063e					EXTRow:
>063e							.fill 	1
.063f					EXTColumn:
>063f							.fill 	1
.0640					EXTTextColour:
>0640							.fill 	1
.0641					EXTScreenWidth:
>0641							.fill 	1
.0642					EXTScreenHeight:
>0642							.fill 	1
.0040					EXTAddress:
>0040							.fill 	2
.aa58					EXTInitialise:
.aa58	64 01		stz $01				stz 	1 							; Access I/O
.aa5a	9c 04 d0	stz $d004			stz 	$D004 						; Disable border
.aa5d	9c 08 d0	stz $d008			stz 	$D008
.aa60	9c 09 d0	stz $d009			stz 	$D009
.aa63	a9 09		lda #$09			lda 	#1+8						; Timer On at 70Hz counting up.
.aa65	8d 58 d6	sta $d658			sta 	$D658
.aa68	a9 76		lda #$76			lda 	#CONForeground * 16 + CONBackground
.aa6a	8d 40 06	sta $0640			sta 	EXTTextColour
.aa6d	a9 50		lda #$50			lda 	#80 						; set screen dimensions.
.aa6f	8d 41 06	sta $0641			sta 	EXTScreenWidth
.aa72	a9 3c		lda #$3c			lda 	#60
.aa74	8d 42 06	sta $0642			sta 	EXTScreenHeight
.aa77	64 01		stz $01				stz 	1
.aa79	60		rts				rts
.aa7a					EXTInputSingleCharacter:
.aa7a	da		phx				phx
.aa7b	5a		phy				phy
.aa7c					_EISCWait:
.aa7c	64 01		stz $01				stz 	1 							; access I/O Page 0
.aa7e	38		sec				sec 								; calculate timer - LastTick
.aa7f	ad 59 d6	lda $d659			lda 	$D659
.aa82	aa		tax				tax 								; saving timer in X
.aa83	ed 2d 06	sbc $062d			sbc 	LastTick
.aa86	c9 03		cmp #$03			cmp 	#3
.aa88	90 06		bcc $aa90			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.aa8a	8e 2d 06	stx $062d			stx 	LastTick 					; update last timer
.aa8d	20 ff b9	jsr $b9ff			jsr 	TickHandler 				; go do the code.
.aa90					_NoFireTick:
.aa90	20 e4 ff	jsr $ffe4			jsr 	$FFE4
.aa93	c9 00		cmp #$00			cmp 	#0
.aa95	f0 e5		beq $aa7c			beq 	_EISCWait
.aa97	7a		ply				ply
.aa98	fa		plx				plx
.aa99	60		rts				rts
.aa9a					EXTBreakCheck:
.aa9a	4c e1 ff	jmp $ffe1			jmp		$FFE1
.aa9d					EXTReadController:
.aa9d	da		phx				phx
.aa9e	a2 00		ldx #$00			ldx 	#0
.aaa0	a9 05		lda #$05			lda 	#(($2D) >> 3)
.aaa2	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aaa5	29 20		and #$20			and 	#($01 << (($2D) & 7))
.aaa7	f0 04		beq $aaad			beq 	_NoSet1
.aaa9	8a		txa				txa
.aaaa	09 01		ora #$01			ora 	#1
.aaac	aa		tax				tax
.aaad					_NoSet1:
.aaad	a9 05		lda #$05			lda 	#(($2C) >> 3)
.aaaf	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aab2	29 10		and #$10			and 	#($01 << (($2C) & 7))
.aab4	f0 04		beq $aaba			beq 	_NoSet1
.aab6	8a		txa				txa
.aab7	09 02		ora #$02			ora 	#2
.aab9	aa		tax				tax
.aaba					_NoSet1:
.aaba	a9 06		lda #$06			lda 	#(($32) >> 3)
.aabc	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aabf	29 04		and #$04			and 	#($01 << (($32) & 7))
.aac1	f0 04		beq $aac7			beq 	_NoSet1
.aac3	8a		txa				txa
.aac4	09 04		ora #$04			ora 	#4
.aac6	aa		tax				tax
.aac7					_NoSet1:
.aac7	a9 04		lda #$04			lda 	#(($25) >> 3)
.aac9	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aacc	29 20		and #$20			and 	#($01 << (($25) & 7))
.aace	f0 04		beq $aad4			beq 	_NoSet1
.aad0	8a		txa				txa
.aad1	09 08		ora #$08			ora 	#8
.aad3	aa		tax				tax
.aad4					_NoSet1:
.aad4	a9 04		lda #$04			lda 	#(($26) >> 3)
.aad6	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aad9	29 40		and #$40			and 	#($01 << (($26) & 7))
.aadb	f0 04		beq $aae1			beq 	_NoSet1
.aadd	8a		txa				txa
.aade	09 10		ora #$10			ora 	#16
.aae0	aa		tax				tax
.aae1					_NoSet1:
.aae1	8a		txa				txa
.aae2	fa		plx				plx
.aae3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_graphics.module

=1					graphicsIntegrated=1
=0					GCMD_Initialise = 0*2
=2					GCMD_BitmapCtl = 1*2
=4					GCMD_SpriteCtl = 2*2
=6					GCMD_Clear = 3*2
=8					GCMD_Colour = 4*2
=10					GCMD_DrawFont = 5*2
=12					GCMD_DrawSprite = 6*2
=14					GCMD_SpriteUse = 7*2
=16					GCMD_SpriteImage = 8*2
=18					GCMD_SpriteCollide = 9*2
=64					GCMD_Move = 32*2
=66					GCMD_Line = 33*2
=68					GCMD_FrameRect = 34*2
=70					GCMD_FillRect = 35*2
=72					GCMD_FrameCircle = 36*2
=74					GCMD_FillCircle = 37*2
=80					GCMD_Plot = 40*2
=82					GCMD_SpriteMove = 41*2
=42					GRFirstFreeCode = 42
.ba05					GRVectorTable:
>ba05	df ac					.word	GXInitialise             ; $00 Initialise
>ba07	f9 ac					.word	GXControlBitmap          ; $01 BitmapCtl
>ba09	41 ad					.word	GXControlSprite          ; $02 SpriteCtl
>ba0b	91 ac					.word	GXClearBitmap            ; $03 Clear
>ba0d	d0 ae					.word	GXSetColourMode          ; $04 Colour
>ba0f	98 b0					.word	GXFontHandler            ; $05 DrawFont
>ba11	e0 b0					.word	GXSpriteHandler          ; $06 DrawSprite
>ba13	4c b1					.word	GXSelect                 ; $07 SpriteUse
>ba15	75 b1					.word	GXSelectImage            ; $08 SpriteImage
>ba17	fc b2					.word	GXCollide                ; $09 SpriteCollide
>ba19	43 ab					.word	GRUndefined              ; $0a
>ba1b	43 ab					.word	GRUndefined              ; $0b
>ba1d	43 ab					.word	GRUndefined              ; $0c
>ba1f	43 ab					.word	GRUndefined              ; $0d
>ba21	43 ab					.word	GRUndefined              ; $0e
>ba23	43 ab					.word	GRUndefined              ; $0f
>ba25	43 ab					.word	GRUndefined              ; $10
>ba27	43 ab					.word	GRUndefined              ; $11
>ba29	43 ab					.word	GRUndefined              ; $12
>ba2b	43 ab					.word	GRUndefined              ; $13
>ba2d	43 ab					.word	GRUndefined              ; $14
>ba2f	43 ab					.word	GRUndefined              ; $15
>ba31	43 ab					.word	GRUndefined              ; $16
>ba33	43 ab					.word	GRUndefined              ; $17
>ba35	43 ab					.word	GRUndefined              ; $18
>ba37	43 ab					.word	GRUndefined              ; $19
>ba39	43 ab					.word	GRUndefined              ; $1a
>ba3b	43 ab					.word	GRUndefined              ; $1b
>ba3d	43 ab					.word	GRUndefined              ; $1c
>ba3f	43 ab					.word	GRUndefined              ; $1d
>ba41	43 ab					.word	GRUndefined              ; $1e
>ba43	43 ab					.word	GRUndefined              ; $1f
>ba45	41 ab					.word	GXMove                   ; $20 Move
>ba47	9e ad					.word	GXLine                   ; $21 Line
>ba49	19 af					.word	GXFrameRectangle         ; $22 FrameRect
>ba4b	16 af					.word	GXFillRectangle          ; $23 FillRect
>ba4d	48 ab					.word	GXFrameCircle            ; $24 FrameCircle
>ba4f	44 ab					.word	GXFillCircle             ; $25 FillCircle
>ba51	43 ab					.word	GRUndefined              ; $26
>ba53	43 ab					.word	GRUndefined              ; $27
>ba55	fe ae					.word	GXPlotPoint              ; $28 Plot
>ba57	0b b2					.word	GXMoveSprite             ; $29 SpriteMove
=3					GXMappingPage = 3
=24576					GXMappingAddress = ($2000 * GXMappingPage)
=11					GXEditSlot = 8 + GXMappingPage
=$36					gxzTemp0 = zTemp0
=$38					gxzTemp1 = zTemp1
=$3a					gxzTemp2 = zTemp2
=$3c					gxzScreen = zsTemp
=$5f9					gxPixelBuffer = numberBuffer
.0643					gxCurrentX:
>0643							.fill 	2
.0645					gxCurrentY:
>0645							.fill 	2
.0647					gxLastX:
>0647							.fill 	2
.0649					gxLastY:
>0649							.fill 	2
.064b					gxX0:
>064b							.fill 	2
.064d					gxY0:
>064d							.fill 	2
.064f					gxX1:
>064f							.fill 	2
.0651					gxY1:
>0651							.fill 	2
.0653					gxSpritesOn:
>0653							.fill 	1
.0654					gxBitmapsOn:
>0654							.fill 	1
.0655					gxBasePage:
>0655							.fill 	1
.0656					gxSpritePage:
>0656							.fill 	1
.0657					gxHeight:
>0657							.fill 	1
.0658					gxMode:
>0658							.fill 	1
.0659					gxColour:
>0659							.fill 	1
.065a					gxEORValue:
>065a							.fill 	1
.065b					gxANDValue:
>065b							.fill 	1
.065c					gxOriginalLUTValue:
>065c							.fill 	1
.065d					gsOffset:
>065d							.fill 	1
.065e					GSCurrentSpriteID:
>065e							.fill 	1
.065f					GSCurrentSpriteAddr:
>065f							.fill 	2
.0661					GXSpriteOffsetBase:
>0661							.fill 	2
.0663					GXSpriteLow:
>0663							.fill 	64
.06a3					GXSpriteHigh:
>06a3							.fill 	64
.aae4					GXGraphicDraw:
.aae4	c9 40		cmp #$40			cmp 	#GCMD_Move					; low instructions don't use coordinates
.aae6	b0 06		bcs $aaee			bcs 	_GDCoordinate
.aae8	86 36		stx $36				stx 	gxzTemp0 					; save X/Y
.aaea	84 37		sty $37				sty 	gxzTemp0+1
.aaec	80 4b		bra $ab39			bra 	_GDExecuteA 				; and execute
.aaee					_GDCoordinate:
.aaee	48		pha				pha 								; save AXY
.aaef	da		phx				phx
.aaf0	5a		phy				phy
.aaf1	a2 03		ldx #$03			ldx 	#3 							; copy currentX to lastX
.aaf3					_GDCopy1:
.aaf3	bd 43 06	lda $0643,x			lda 	gxCurrentX,x
.aaf6	9d 47 06	sta $0647,x			sta 	gxLastX,x
.aaf9	ca		dex				dex
.aafa	10 f7		bpl $aaf3			bpl 	_GDCopy1
.aafc	68		pla				pla 								; update Y
.aafd	8d 45 06	sta $0645			sta 	gxCurrentY
.ab00	9c 46 06	stz $0646			stz 	gxCurrentY+1
.ab03	68		pla				pla
.ab04	8d 43 06	sta $0643			sta 	gxCurrentX
.ab07	68		pla				pla 								; get A (command+X.1) back
.ab08	48		pha				pha
.ab09	29 01		and #$01			and 	#1 							; put LSB as MSB of Current.X
.ab0b	8d 44 06	sta $0644			sta 	gxCurrentX+1
.ab0e	68		pla				pla 								; get command back
.ab0f	29 fe		and #$fe			and 	#$FE 						; lose LSB, chuck the stray X bit
.ab11	48		pha				pha 								; push back.
.ab12	c9 52		cmp #$52			cmp 	#GCMD_SpriteMove 			; move sprite does not clip.
.ab14	f0 17		beq $ab2d			beq 	_GDCopyToWorkArea
.ab16	ad 44 06	lda $0644			lda 	gxCurrentX+1 				; X < 256 X okay
.ab19	f0 07		beq $ab22			beq 	_GDCheckY
.ab1b	ad 43 06	lda $0643			lda 	gxCurrentX 					; otherwise X < 320 = 256 + 64
.ab1e	c9 40		cmp #$40			cmp 	#64
.ab20	b0 08		bcs $ab2a			bcs 	_GDError1
.ab22					_GDCheckY:
.ab22	ad 45 06	lda $0645			lda 	gxCurrentY 					; check Y < Height.
.ab25	cd 57 06	cmp $0657			cmp 	gxHeight
.ab28	90 03		bcc $ab2d			bcc 	_GDCopyToWorkArea
.ab2a					_GDError1:
.ab2a	68		pla				pla
.ab2b					_GDError2:
.ab2b	38		sec				sec
.ab2c	60		rts				rts
.ab2d					_GDCopyToWorkArea:
.ab2d	a2 07		ldx #$07			ldx 	#7 							; copy current and last to gxXY/12 work area
.ab2f					_GDCopy2:
.ab2f	bd 43 06	lda $0643,x			lda 	gxCurrentX,x
.ab32	9d 4b 06	sta $064b,x			sta 	gxX0,x
.ab35	ca		dex				dex
.ab36	10 f7		bpl $ab2f			bpl 	_GDCopy2
.ab38	68		pla				pla 								; get command
.ab39					_GDExecuteA:
.ab39	c9 54		cmp #$54			cmp 	#GRFirstFreeCode*2 			; bad ?
.ab3b	b0 ee		bcs $ab2b			bcs 	_GDError2
.ab3d	aa		tax				tax
.ab3e	7c 05 ba	jmp ($ba05,x)			jmp 	(GRVectorTable,x)
.ab41					GXMove:
.ab41	18		clc				clc
.ab42	60		rts				rts
.ab43					GRUndefined:
>ab43	db						.byte 	$DB 						; causes a break in the emulator
.ab44					GXFillCircle:
.ab44	a9 ff		lda #$ff			lda 	#255
.ab46	80 02		bra $ab4a			bra 	GXCircle
.ab48					GXFrameCircle:
.ab48	a9 00		lda #$00			lda 	#0
.ab4a					GXCircle:
.ab4a	8d e6 06	sta $06e6			sta 	gxIsFillMode					; save Fill flag
.ab4d	ad 54 06	lda $0654			lda 	gxBitmapsOn
.ab50	f0 26		beq $ab78			beq 	_GXCFail
.ab52	20 a3 b3	jsr $b3a3			jsr 	GXSortXY 					; topleft/bottomright
.ab55	20 7b b2	jsr $b27b			jsr 	GXOpenBitmap 				; start drawing
.ab58	20 4a ac	jsr $ac4a			jsr 	GXCircleSetup 				; set up for drawing
.ab5b	9c e7 06	stz $06e7			stz 	gxYChanged
.ab5e					_GXCircleDraw:
.ab5e	ad e4 06	lda $06e4			lda 	gXCentre					; while x <= y
.ab61	cd e5 06	cmp $06e5			cmp 	gYCentre
.ab64	90 0a		bcc $ab70			bcc 	_GXCircleContinue
.ab66	d0 03		bne $ab6b			bne 	_GXNoLast
.ab68	20 7d ab	jsr $ab7d			jsr 	GXPlot1
.ab6b					_GXNoLast:
.ab6b	20 83 b2	jsr $b283			jsr 	GXCloseBitmap 				; close the bitmap
.ab6e	18		clc				clc
.ab6f	60		rts				rts
.ab70					_GXCircleContinue:
.ab70	20 7a ab	jsr $ab7a			jsr 	GXPlot2 					; draw it
.ab73	20 f7 ab	jsr $abf7			jsr 	GXCircleMove 				; adjust the coordinates
.ab76	80 e6		bra $ab5e			bra 	_GXCircleDraw
.ab78					_GXCFail:
.ab78	38		sec				sec
.ab79	60		rts				rts
.ab7a					GXPlot2:
.ab7a	20 7d ab	jsr $ab7d			jsr 	GXPlot1 						; plot and swap, fall through does twice
.ab7d					GXPlot1:
.ab7d	ad e5 06	lda $06e5			lda 	gYCentre 						; if y = 0, don't do it twice (xor)
.ab80	f0 03		beq $ab85			beq 	_GXPlot1Only
.ab82	20 a1 ab	jsr $aba1			jsr 	GXPlot0 						; plot and negate
.ab85					_GXPlot1Only:
.ab85	20 a1 ab	jsr $aba1			jsr 	GXPlot0 						; twice, undoing negation
.ab88	ad e4 06	lda $06e4			lda 	gXCentre 						; swap X and Y
.ab8b	ae e5 06	ldx $06e5			ldx	 	gYCentre
.ab8e	8d e5 06	sta $06e5			sta 	gYCentre
.ab91	8e e4 06	stx $06e4			stx 	gXCentre
.ab94	ad e7 06	lda $06e7			lda 	gxYChanged 						; toggle Y Changed flag
.ab97	a9 ff		lda #$ff			lda 	#$FF
.ab99	8d e7 06	sta $06e7			sta 	gxYChanged
.ab9c	60		rts				rts
.ab9d	20 a1 ab	jsr $aba1			jsr 	GXPlot0 						; do once
.aba0	60		rts				rts
.aba1	ad e6 06	lda $06e6	GXPlot0:lda 	gxIsFillMode 					; outline mode, always draw as X or Y will change
.aba4	f0 05		beq $abab			beq 	_GXPlot0Always
.aba6	ad e7 06	lda $06e7			lda 	gxYChanged						; fill mode, only draw if changed.
.aba9	f0 2d		beq $abd8			beq 	GXPlot0Exit
.abab					_GXPlot0Always:
.abab	a2 02		ldx #$02			ldx 	#2 								; copy Y1-A => Y0
.abad	ad e5 06	lda $06e5			lda 	gYCentre
.abb0	20 d9 ab	jsr $abd9			jsr 	GXSubCopy
.abb3	a2 00		ldx #$00			ldx 	#0 								; copy X1-A => X0,
.abb5	ad e4 06	lda $06e4			lda 	gXCentre
.abb8	20 d9 ab	jsr $abd9			jsr 	GXSubCopy
.abbb	48		pha				pha 									; save last offset X
.abbc	20 8b b2	jsr $b28b			jsr 	GXPositionCalc 					; calculate position/offset.
.abbf	68		pla				pla
.abc0	0a		asl a				asl 	a 								; store 2 x last offset in gxzTemp0
.abc1	85 36		sta $36				sta 	gxzTemp0
.abc3	64 37		stz $37				stz 	gxzTemp0+1
.abc5	26 37		rol $37				rol 	gxzTemp0+1
.abc7	ad e6 06	lda $06e6			lda 	gxIsFillMode
.abca	69 80		adc #$80			adc 	#128
.abcc	20 69 af	jsr $af69			jsr 	GXDrawLineTemp0 				; routine from Rectangle.
.abcf	38		sec				sec 									; GY = -GY
.abd0	a9 00		lda #$00			lda 	#0
.abd2	ed e5 06	sbc $06e5			sbc 	gYCentre
.abd5	8d e5 06	sta $06e5			sta 	gYCentre
.abd8					GXPlot0Exit:
.abd8	60		rts				rts
.abd9					GXSubCopy:
.abd9	85 36		sta $36				sta 	gxzTemp0
.abdb	64 37		stz $37				stz 	gxzTemp0+1
.abdd	29 80		and #$80			and 	#$80
.abdf	f0 02		beq $abe3			beq 	_GXNoSx
.abe1	c6 37		dec $37				dec 	gxzTemp0+1
.abe3					_GXNoSx:
.abe3	38		sec				sec
.abe4	bd 4f 06	lda $064f,x			lda 	gXX1,x
.abe7	e5 36		sbc $36				sbc 	gxzTemp0
.abe9	9d 4b 06	sta $064b,x			sta 	gXX0,x
.abec	bd 50 06	lda $0650,x			lda 	gXX1+1,x
.abef	e5 37		sbc $37				sbc 	gxzTemp0+1
.abf1	9d 4c 06	sta $064c,x			sta 	gXX0+1,x
.abf4	a5 36		lda $36				lda 	gxzTemp0 						; return A
.abf6	60		rts				rts
.abf7					GXCircleMove:
.abf7	9c e7 06	stz $06e7			stz 	gxYChanged 					; clear Y changed flag
.abfa	a5 39		lda $39				lda 	gxzTemp1+1 					; check sign of D
.abfc	10 0d		bpl $ac0b			bpl 	_GXEMPositive
.abfe	ee e4 06	inc $06e4			inc 	gXCentre 					; X++
.ac01	ad e4 06	lda $06e4			lda 	gXCentre
.ac04	20 2a ac	jsr $ac2a			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.ac07	a9 06		lda #$06			lda 	#6  						; and add 6
.ac09	80 15		bra $ac20			bra 	_GXEMAddD
.ac0b					_GXEMPositive:
.ac0b	ee e4 06	inc $06e4			inc 	gXCentre					; X++
.ac0e	ce e5 06	dec $06e5			dec 	gyCentre 					; Y--
.ac11	38		sec				sec 								; calculate X-Y
.ac12	ad e4 06	lda $06e4			lda 	gXCentre
.ac15	ed e5 06	sbc $06e5			sbc 	gYCentre
.ac18	20 2a ac	jsr $ac2a			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.ac1b	a9 0a		lda #$0a			lda 	#10  						; and add 10
.ac1d	ce e7 06	dec $06e7			dec 	gxYChanged
.ac20					_GXEMAddD:
.ac20	18		clc				clc
.ac21	65 38		adc $38				adc 	gxzTemp1
.ac23	85 38		sta $38				sta 	gxzTemp1
.ac25	90 02		bcc $ac29			bcc 	_GXEMNoCarry
.ac27	e6 39		inc $39				inc 	gxzTemp1+1
.ac29					_GXEMNoCarry:
.ac29	60		rts				rts
.ac2a					_GXAdd4TimesToD:
.ac2a	85 36		sta $36				sta 	gxzTemp0 					; make 16 bit signed.
.ac2c	29 80		and #$80			and 	#$80
.ac2e	f0 02		beq $ac32			beq 	_GXA4Unsigned
.ac30	a9 ff		lda #$ff			lda 	#$FF
.ac32					_GXA4Unsigned:
.ac32	85 37		sta $37				sta 	gxzTemp0+1
.ac34	06 36		asl $36				asl 	gxzTemp0  					; x 4
.ac36	26 37		rol $37				rol 	gxzTemp0+1
.ac38	06 36		asl $36				asl 	gxzTemp0
.ac3a	26 37		rol $37				rol 	gxzTemp0+1
.ac3c	18		clc				clc 								; add
.ac3d	a5 36		lda $36				lda		gxzTemp0
.ac3f	65 38		adc $38				adc 	gxzTemp1
.ac41	85 38		sta $38				sta 	gxzTemp1
.ac43	a5 37		lda $37				lda		gxzTemp0+1
.ac45	65 39		adc $39				adc 	gxzTemp1+1
.ac47	85 39		sta $39				sta 	gxzTemp1+1
.ac49	60		rts				rts
.ac4a					GXCircleSetup:
.ac4a	38		sec				sec
.ac4b	ad 51 06	lda $0651			lda 	gxY1
.ac4e	ed 4d 06	sbc $064d			sbc 	gxY0
.ac51	4a		lsr a				lsr 	a
.ac52	8d e3 06	sta $06e3			sta 	gxRadius
.ac55	a2 00		ldx #$00			ldx 	#0
.ac57	20 79 ac	jsr $ac79			jsr 	_GXCalculateCentre
.ac5a	a2 02		ldx #$02			ldx 	#2
.ac5c	20 79 ac	jsr $ac79			jsr 	_GXCalculateCentre
.ac5f	9c e4 06	stz $06e4			stz 	gXCentre
.ac62	ad e3 06	lda $06e3			lda 	gxRadius
.ac65	8d e5 06	sta $06e5			sta 	gYCentre
.ac68	0a		asl a				asl 	a 							; R x 2
.ac69	85 36		sta $36				sta 	gxzTemp0
.ac6b	38		sec				sec
.ac6c	a9 03		lda #$03			lda 	#3
.ac6e	e5 36		sbc $36				sbc 	gxzTemp0
.ac70	85 38		sta $38				sta 	gxzTemp1
.ac72	a9 00		lda #$00			lda 	#0
.ac74	e9 00		sbc #$00			sbc 	#0
.ac76	85 39		sta $39				sta 	gxzTemp1+1
.ac78	60		rts				rts
.ac79					_GXCalculateCentre:
.ac79	38		sec				sec
.ac7a	bd 4f 06	lda $064f,x			lda 	gxX1,x
.ac7d	7d 4b 06	adc $064b,x			adc 	gXX0,x
.ac80	9d 4f 06	sta $064f,x			sta 	gXX1,x
.ac83	bd 50 06	lda $0650,x			lda 	gXX1+1,x
.ac86	7d 4c 06	adc $064c,x			adc 	gXX0+1,x
.ac89	4a		lsr a				lsr 	a
.ac8a	9d 50 06	sta $0650,x			sta 	gXX1+1,x
.ac8d	7e 4f 06	ror $064f,x			ror 	gXX1,x
.ac90	60		rts				rts
.06e3					gxRadius:
>06e3							.fill 	1
.06e4					gXCentre:
>06e4							.fill 	1
.06e5					gYCentre:
>06e5							.fill 	1
.06e6					gxIsFillMode:
>06e6							.fill 	1
.06e7					gxYChanged:
>06e7							.fill  	1
=64000					ScreenSize200 = 320 * 200
=76800					ScreenSize240 = 320 * 240
.ac91					GXClearBitmap:
.ac91	ad 54 06	lda $0654			lda 	gxBitmapsOn 				; check BMP running.
.ac94	f0 24		beq $acba			beq 	_GXCBFail
.ac96	20 7b b2	jsr $b27b			jsr 	GXOpenBitmap 				; start access
.ac99	a0 07		ldy #$07			ldy 	#ScreenSize200 / 8192 		; X is pages to clear
.ac9b	ad 57 06	lda $0657			lda 	gxHeight
.ac9e	c9 c8		cmp #$c8			cmp 	#200 						; 200 ?
.aca0	a0 09		ldy #$09			ldy 	#ScreenSize240 / 8192
.aca2					_GXCalcLastPage:
.aca2	98		tya				tya 								; add to base page
.aca3	18		clc				clc
.aca4	6d 55 06	adc $0655			adc 	gxBasePage
.aca7	85 0b		sta $0b				sta 	GXEditSlot  				; clear from this page back
.aca9					_GXClearAll:
.aca9	20 bc ac	jsr $acbc			jsr 	_GXClearBlock 				; clear 8k block
.acac	c6 0b		dec $0b				dec 	GXEditSlot  				; back to previous
.acae	a5 0b		lda $0b				lda 	GXEditSlot
.acb0	cd 55 06	cmp $0655			cmp 	gxBasePage 					; until before base page
.acb3	b0 f4		bcs $aca9			bcs 	_GXClearAll
.acb5	20 83 b2	jsr $b283			jsr 	GXCloseBitmap	 			; stop access
.acb8	18		clc				clc
.acb9	60		rts				rts
.acba					_GXCBFail:
.acba	38		sec				sec
.acbb	60		rts				rts
.acbc					_GXClearBlock:
.acbc	a9 00		lda #$00			lda 	#((GXMappingAddress) & $FF)
.acbe	85 38		sta $38				sta 	0+gxzTemp1
.acc0	a9 60		lda #$60			lda 	#((GXMappingAddress) >> 8)
.acc2	85 39		sta $39				sta 	1+gxzTemp1
.acc4					_GXCB0:
.acc4	a5 36		lda $36				lda 	gxzTemp0
.acc6	a0 00		ldy #$00			ldy 	#0
.acc8					_GXCB1:
.acc8	91 38		sta ($38),y			sta 	(gxzTemp1),y
.acca	c8		iny				iny
.accb	91 38		sta ($38),y			sta 	(gxzTemp1),y
.accd	c8		iny				iny
.acce	91 38		sta ($38),y			sta 	(gxzTemp1),y
.acd0	c8		iny				iny
.acd1	91 38		sta ($38),y			sta 	(gxzTemp1),y
.acd3	c8		iny				iny
.acd4	d0 f2		bne $acc8			bne 	_GXCB1
.acd6	e6 39		inc $39				inc 	gxzTemp1+1
.acd8	a5 39		lda $39				lda 	gxzTemp1+1
.acda	c9 80		cmp #$80			cmp	 	#(GXMappingAddress >> 8)+$20
.acdc	d0 e6		bne $acc4			bne 	_GXCB0
.acde	60		rts				rts
.acdf					GXInitialise:
.acdf	64 01		stz $01				stz 	1
.ace1	a9 01		lda #$01			lda 	#1
.ace3	8d 00 d0	sta $d000			sta 	$D000
.ace6	18		clc				clc
.ace7	9c 53 06	stz $0653			stz 	GXSpritesOn
.acea	9c 54 06	stz $0654			stz 	GXBitmapsOn
.aced	a2 0f		ldx #$0f			ldx 	#15
.acef					_GXIClear:
.acef	9e 43 06	stz $0643,x			stz 	gxCurrentX,x
.acf2	ca		dex				dex
.acf3	10 fa		bpl $acef			bpl 	_GXIClear
.acf5	20 90 ad	jsr $ad90			jsr 	GXClearSpriteStore
.acf8	60		rts				rts
.acf9					GXControlBitmap:
.acf9	64 01		stz $01				stz 	1
.acfb	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.acfd	29 01		and #$01			and 	#1 							; set bitmap flag
.acff	8d 54 06	sta $0654			sta 	gxBitmapsOn
.ad02	4a		lsr a				lsr 	a 							; bit 0 into carry.
.ad03	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.ad06	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.ad08	29 f7		and #$f7			and 	#$F7 						; clear bitmap bit
.ad0a	90 02		bcc $ad0e			bcc 	_CBNotOn
.ad0c	09 08		ora #$08			ora 	#$08 						; bitmap on if 1 on 0 off
.ad0e					_CBNotOn:
.ad0e	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.ad11	a5 36		lda $36				lda 	gxzTemp0 					; get control settings (bits 0-2)
.ad13	29 07		and #$07			and 	#7
.ad15	8d 00 d1	sta $d100			sta 	$D100 						; write in Vicky Bitmap Control Register #0
.ad18	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.ad1a	d0 02		bne $ad1e			bne 	_CBNotDefault
.ad1c	a9 08		lda #$08			lda 	#8  						; if zero, use 8 e.g. bitmap at $10000
.ad1e					_CBNotDefault:
.ad1e	8d 55 06	sta $0655			sta 	gxBasePage
.ad21	20 82 ad	jsr $ad82			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.ad24	a5 37		lda $37				lda 	gxzTemp0+1 					; copy address into Bitmap address registers
.ad26	8d 03 d1	sta $d103			sta 	$D103
.ad29	a5 36		lda $36				lda 	gxzTemp0
.ad2b	8d 02 d1	sta $d102			sta 	$D102
.ad2e	9c 01 d1	stz $d101			stz 	$D101
.ad31	a2 f0		ldx #$f0			ldx 	#240 						; height is 240
.ad33	ad 01 d0	lda $d001			lda 	$D001 						; read MCR bit 0
.ad36	29 01		and #$01			and 	#1
.ad38	f0 02		beq $ad3c			beq 	_CBHaveHeight
.ad3a	a2 c8		ldx #$c8			ldx 	#200 						; if bit 0 set 320x200
.ad3c					_CBHaveHeight
.ad3c	8e 57 06	stx $0657			stx 	gxHeight
.ad3f	18		clc				clc
.ad40	60		rts				rts
.ad41					GXControlSprite:
.ad41	64 01		stz $01				stz 	1
.ad43	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.ad45	29 01		and #$01			and 	#1 							; set sprites flag
.ad47	8d 53 06	sta $0653			sta 	gxSpritesOn
.ad4a	4a		lsr a				lsr 	a 							; bit 0 into carry.
.ad4b	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.ad4e	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.ad50	29 df		and #$df			and 	#$DF 						; clear sprite bit
.ad52	90 02		bcc $ad56			bcc 	_CSNotOn
.ad54	09 20		ora #$20			ora 	#$20 						; sprite on if 1 on 0 off
.ad56					_CSNotOn:
.ad56	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.ad59	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.ad5b	d0 02		bne $ad5f			bne 	_CSNotDefault
.ad5d	a9 18		lda #$18			lda 	#24  						; if zero, use 24 e.g. sprites at $30000
.ad5f					_CSNotDefault:
.ad5f	8d 56 06	sta $0656			sta 	gxSpritePage
.ad62	20 82 ad	jsr $ad82			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.ad65	a5 36		lda $36				lda 	zTemp0
.ad67	8d 61 06	sta $0661			sta 	GXSpriteOffsetBase
.ad6a	a5 37		lda $37				lda 	zTemp0+1
.ad6c	8d 62 06	sta $0662			sta 	GXSpriteOffsetBase+1
.ad6f	a2 00		ldx #$00			ldx 	#0 							; disable all sprites, clears all sprite memory.
.ad71					_CSClear:
.ad71	9e 00 d9	stz $d900,x			stz 	$D900,x
.ad74	9e 00 da	stz $da00,x			stz 	$DA00,x
.ad77	ca		dex				dex
.ad78	d0 f7		bne $ad71			bne 	_CSClear
.ad7a	9c 60 06	stz $0660			stz 	GSCurrentSpriteAddr+1 		; no sprite selected.
.ad7d	20 90 ad	jsr $ad90			jsr 	GXClearSpriteStore
.ad80	18		clc				clc
.ad81	60		rts				rts
.ad82					GXCalculateBaseAddress:
.ad82	85 36		sta $36				sta 	gxzTemp0
.ad84	64 37		stz $37				stz 	gxzTemp0+1
.ad86	a9 05		lda #$05			lda 	#5
.ad88					_GXShift:
.ad88	06 36		asl $36				asl 	gxzTemp0
.ad8a	26 37		rol $37				rol 	gxzTemp0+1
.ad8c	3a		dec a				dec		a
.ad8d	d0 f9		bne $ad88			bne 	_GXShift
.ad8f	60		rts				rts
.ad90					GXClearSpriteStore:
.ad90	a2 3f		ldx #$3f			ldx 	#63 						; erase 64 sprite store elements
.ad92					_GXCSSLoop:
.ad92	9e a3 06	stz $06a3,x			stz 	GXSpriteHigh,x
.ad95	a9 80		lda #$80			lda 	#$80 						; set the 'hidden' bit.
.ad97	9d 63 06	sta $0663,x			sta 	GXSpriteLow,x
.ad9a	ca		dex				dex
.ad9b	10 f5		bpl $ad92			bpl 	_GXCSSLoop
.ad9d	60		rts				rts
.ad9e					GXLine:
.ad9e	ad 54 06	lda $0654			lda 	GXBitmapsOn
.ada1	f0 28		beq $adcb			beq 	_GXLFail
.ada3	20 7b b2	jsr $b27b			jsr 	GXOpenBitmap
.ada6	20 c1 b3	jsr $b3c1			jsr 	GXSortY						; sort pairs so Y1 >= Y0 e.g. top to bottom.
.ada9	20 71 ae	jsr $ae71			jsr 	GXLineSetup 				; the calculations in the linescanner constructor
.adac	20 8b b2	jsr $b28b			jsr 	GXPositionCalc 				; calculate position/offset.
.adaf					_GXDrawLoop:
.adaf	ac 5d 06	ldy $065d			ldy 	gsOffset 					; draw the pixel
.adb2	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.adb4	2d 5b 06	and $065b			and 	gxANDValue
.adb7	4d 5a 06	eor $065a			eor 	gxEORValue
.adba	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.adbc	20 cd ad	jsr $adcd			jsr 	GXLineIsComplete 			; is the line complete ?
.adbf	f0 05		beq $adc6			beq 	_GXLExit
.adc1	20 e8 ad	jsr $ade8			jsr 	GXLineAdvance 				; code as per advance method
.adc4	80 e9		bra $adaf			bra 	_GXDrawLoop
.adc6					_GXLExit:
.adc6	20 83 b2	jsr $b283			jsr 	GXCloseBitmap
.adc9	18		clc				clc
.adca	60		rts				rts
.adcb					_GXLFail:
.adcb	38		sec				sec
.adcc	60		rts				rts
.adcd					GXLineIsComplete:
.adcd	ad ea 06	lda $06ea			lda 	GXIsDiffYLarger 			; is dy larger
.add0	d0 0f		bne $ade1			bne 	_GXLICCompareY 				; if so compare Y1/Y0
.add2	ad 4b 06	lda $064b			lda 	GXX0 						; compare X, LSB and MSB
.add5	4d 4f 06	eor $064f			eor 	GXX1
.add8	d0 06		bne $ade0			bne 	_GXLICExit
.adda	ad 4c 06	lda $064c			lda 	GXX0+1
.addd	4d 50 06	eor $0650			eor 	GXX1+1
.ade0					_GXLICExit:
.ade0	60		rts				rts
.ade1					_GXLICCompareY:
.ade1	ad 51 06	lda $0651			lda 	GXY1
.ade4	4d 4d 06	eor $064d			eor 	GXY0
.ade7	60		rts				rts
.ade8					GXLineAdvance:
.ade8	18		clc				clc 								; add adjust to position
.ade9	ad ec 06	lda $06ec			lda 	GXPosition
.adec	6d ed 06	adc $06ed			adc 	GXAdjust
.adef	8d ec 06	sta $06ec			sta 	GXPosition
.adf2	9c ef 06	stz $06ef			stz 	GXAddSelect 				; clear add select flag
.adf5	b0 05		bcs $adfc			bcs 	_GXLAOverflow 				; if carry out, overflowed.
.adf7	cd ee 06	cmp $06ee			cmp 	GXTotal 					; if exceeded total
.adfa	90 0a		bcc $ae06			bcc 	_GXLANoExtra
.adfc					_GXLAOverflow:
.adfc	ce ef 06	dec $06ef			dec 	GXAddSelect 				; set addselect to $FF
.adff	38		sec				sec 								; subtract total and write back
.ae00	ed ee 06	sbc $06ee			sbc 	GXTotal
.ae03	8d ec 06	sta $06ec			sta 	GXPosition
.ae06					_GXLANoExtra:
.ae06	ad ea 06	lda $06ea			lda 	GXIsDiffYLarger
.ae09	f0 0d		beq $ae18			beq 	_GXDXLarger
.ae0b	20 6a ae	jsr $ae6a			jsr 	GXIncrementY
.ae0e	ad ef 06	lda $06ef			lda 	GXAddSelect
.ae11	f0 10		beq $ae23			beq 	_GXLAExit
.ae13	20 24 ae	jsr $ae24			jsr 	GXAdjustX
.ae16	80 0b		bra $ae23			bra 	_GXLAExit
.ae18					_GXDXLarger:
.ae18	20 24 ae	jsr $ae24			jsr 	GXAdjustX
.ae1b	ad ef 06	lda $06ef			lda 	GXAddSelect
.ae1e	f0 03		beq $ae23			beq 	_GXLAExit
.ae20	20 6a ae	jsr $ae6a			jsr 	GXIncrementY
.ae23					_GXLAExit:
.ae23	60		rts				rts
.ae24					GXAdjustX:
.ae24	ad eb 06	lda $06eb			lda 	GXDXNegative
.ae27	10 25		bpl $ae4e			bpl 	_GXAXRight
.ae29	ad 4b 06	lda $064b			lda 	GXX0
.ae2c	d0 03		bne $ae31			bne 	_GXAXNoBorrow
.ae2e	ce 4c 06	dec $064c			dec 	GXX0+1
.ae31					_GXAXNoBorrow:
.ae31	ce 4b 06	dec $064b			dec 	GXX0
.ae34	ce 5d 06	dec $065d			dec 	gsOffset 					; pixel left
.ae37	ad 5d 06	lda $065d			lda 	gsOffset
.ae3a	c9 ff		cmp #$ff			cmp 	#$FF
.ae3c	d0 0f		bne $ae4d			bne 	_GXAYExit 					; underflow
.ae3e	c6 3d		dec $3d				dec 	gxzScreen+1 					; borrow
.ae40	a5 3d		lda $3d				lda 	gxzScreen+1 					; gone off page
.ae42	c9 60		cmp #$60			cmp 	#GXMappingAddress >> 8
.ae44	b0 07		bcs $ae4d			bcs 	_GXAYExit
.ae46	18		clc				clc
.ae47	69 20		adc #$20			adc 	#$20 						; fix up
.ae49	85 3d		sta $3d				sta 	gxzScreen+1
.ae4b	c6 0b		dec $0b				dec 	GXEditSlot 				; back one page
.ae4d					_GXAYExit:
.ae4d	60		rts				rts
.ae4e					_GXAXRight:
.ae4e	ee 4b 06	inc $064b			inc 	GXX0
.ae51	d0 03		bne $ae56			bne 	_GXAXNoCarry
.ae53	ee 4c 06	inc $064c			inc 	GXX0+1
.ae56					_GXAXNoCarry:
.ae56	ee 5d 06	inc $065d			inc 	gsOffset 					; pixel right
.ae59	d0 0e		bne $ae69			bne 	_GXAXExit 					; if not overflowed, exit.
.ae5b	e6 3d		inc $3d				inc 	gxzScreen+1 					; next line
.ae5d	a5 3d		lda $3d				lda 	gxzScreen+1
.ae5f	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.ae61	90 06		bcc $ae69			bcc 	_GXAXExit
.ae63	e9 20		sbc #$20			sbc 	#$20 						; fix up
.ae65	85 3d		sta $3d				sta 	gxzScreen+1
.ae67	e6 0b		inc $0b				inc 	GXEditSlot 				; next page
.ae69					_GXAXExit:
.ae69	60		rts				rts
.ae6a					GXIncrementY:
.ae6a	ee 4d 06	inc $064d			inc 	GXY0
.ae6d	20 e1 b2	jsr $b2e1			jsr 	GXMovePositionDown
.ae70	60		rts				rts
.ae71					GXLineSetup:
.ae71	ad 51 06	lda $0651			lda 	GXY1
.ae74	38		sec				sec
.ae75	ed 4d 06	sbc $064d			sbc 	GXY0
.ae78	4a		lsr a				lsr 	a
.ae79	8d e9 06	sta $06e9			sta 	GXDiffY
.ae7c	9c eb 06	stz $06eb			stz 	GXDXNegative 				; clear -ve flag
.ae7f	38		sec				sec
.ae80	ad 4f 06	lda $064f			lda 	GXX1
.ae83	ed 4b 06	sbc $064b			sbc 	GXX0
.ae86	8d e8 06	sta $06e8			sta 	GXDiffX
.ae89	ad 50 06	lda $0650			lda 	GXX1+1 						; calculate MSB
.ae8c	ed 4c 06	sbc $064c			sbc 	GXX0+1
.ae8f	6a		ror a				ror 	a 							; rotate bit into DiffX halving it
.ae90	6e e8 06	ror $06e8			ror 	GXDiffX
.ae93	0a		asl a				asl 	a
.ae94	10 0c		bpl $aea2			bpl 	_GDXNotNegative
.ae96	a9 00		lda #$00			lda 	#0 							; make absolute value of |dx|
.ae98	38		sec				sec
.ae99	ed e8 06	sbc $06e8			sbc 	GXDiffX
.ae9c	8d e8 06	sta $06e8			sta 	GXDiffX
.ae9f	ce eb 06	dec $06eb			dec 	GXDXNegative 				; -ve flag = $FF.
.aea2					_GDXNotNegative:
.aea2	9c ea 06	stz $06ea			stz 	GXIsDiffYLarger 			; clear larger flag
.aea5	ad e9 06	lda $06e9			lda 	GXDiffY 					; set adjust and total.
.aea8	8d ed 06	sta $06ed			sta 	GXAdjust
.aeab	ad e8 06	lda $06e8			lda 	GXDiffX
.aeae	8d ee 06	sta $06ee			sta 	GXTotal
.aeb1	ad e9 06	lda $06e9			lda 	GXDiffY 					; if dy > dx
.aeb4	cd e8 06	cmp $06e8			cmp 	GXDiffX
.aeb7	90 0f		bcc $aec8			bcc 	_GDXNotLarger
.aeb9	ce ea 06	dec $06ea			dec 	GXIsDiffYLarger 			; set the dy larger flag
.aebc	ad e8 06	lda $06e8			lda 	GXDiffX 					; set adjust and total other way round
.aebf	8d ed 06	sta $06ed			sta 	GXAdjust
.aec2	ad e9 06	lda $06e9			lda 	GXDiffY
.aec5	8d ee 06	sta $06ee			sta 	GXTotal
.aec8					_GDXNotLarger:
.aec8	ad ee 06	lda $06ee			lda 	GXTotal
.aecb	4a		lsr a				lsr 	a
.aecc	8d ec 06	sta $06ec			sta 	GXPosition
.aecf	60		rts				rts
.06e8					GXDiffX:
>06e8							.fill 	1
.06e9					GXDiffY:
>06e9							.fill 	1
.06ea					GXIsDiffYLarger:
>06ea							.fill 	1
.06eb					GXDXNegative:
>06eb							.fill 	1
.06ec					GXPosition:
>06ec							.fill 	1
.06ed					GXAdjust:
>06ed							.fill 	1
.06ee					GXTotal:
>06ee							.fill 	1
.06ef					GXAddSelect:
>06ef							.fill 	1
.aed0					GXSetColourMode:
.aed0	a6 36		ldx $36				ldx 	gxzTemp0
.aed2	8e 59 06	stx $0659			stx 	gxColour 								; set colour
.aed5	a5 37		lda $37				lda 	gxzTemp0+1 								;
.aed7	8d 58 06	sta $0658			sta 	gxMode 									; set mode
.aeda	29 03		and #$03			and 	#3 										; only interested in bits 0-3
.aedc	9c 5b 06	stz $065b			stz 	gxANDValue 								; initially AND with 0, and EOR with Colour
.aedf	ae 59 06	ldx $0659			ldx 	gxColour
.aee2	8e 5a 06	stx $065a			stx 	gxEORValue
.aee5	c9 02		cmp #$02			cmp 	#2 										; if mode 2/3 And with colour
.aee7	90 03		bcc $aeec			bcc 	_GXSDCNotAndColour
.aee9	8e 5b 06	stx $065b			stx 	gxANDValue
.aeec					_GXSDCNotAndColour:
.aeec	d0 03		bne $aef1			bne 	_GXSDCNotAnd 							; mode 2, Don't EOR with colour
.aeee	9c 5a 06	stz $065a			stz 	gxEORValue
.aef1					_GXSDCNotAnd:
.aef1	4a		lsr a				lsr 	a 										; if bit 0 set, 1's complement AND value
.aef2	90 08		bcc $aefc			bcc 	_GXSDCNoFlip
.aef4	ad 5b 06	lda $065b			lda	 	gxANDValue
.aef7	49 ff		eor #$ff			eor 	#$FF
.aef9	8d 5b 06	sta $065b			sta 	gxANDValue
.aefc					_GXSDCNoFlip:
.aefc	18		clc				clc
.aefd	60		rts				rts
.aefe					GXPlotPoint:
.aefe	20 7b b2	jsr $b27b			jsr 	GXOpenBitmap 				; start drawing
.af01	20 8b b2	jsr $b28b			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.af04	ac 5d 06	ldy $065d			ldy 	gsOffset
.af07	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.af09	2d 5b 06	and $065b			and 	gxANDValue
.af0c	4d 5a 06	eor $065a			eor 	gxEORValue
.af0f	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.af11	20 83 b2	jsr $b283			jsr 	GXCloseBitmap 				; stop drawing and exit
.af14	18		clc				clc
.af15	60		rts				rts
.af16					GXFillRectangle:
.af16	38		sec				sec
.af17	80 01		bra $af1a			bra 	GXRectangle
.af19					GXFrameRectangle:
.af19	18		clc				clc
.af1a					GXRectangle:
.af1a	ad 54 06	lda $0654			lda 	gxBitmapsOn
.af1d	f0 35		beq $af54			beq 	_GXRFail
.af1f	08		php				php 								; save Fill flag (CS)
.af20	20 7b b2	jsr $b27b			jsr 	GXOpenBitmap 				; start drawing
.af23	20 a3 b3	jsr $b3a3			jsr 	GXSortXY 					; sort both X and Y so top left/bottom right
.af26	20 8b b2	jsr $b28b			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.af29	38		sec				sec 								; sec = Draw line
.af2a	20 56 af	jsr $af56			jsr 	GXDrawLineX1X0 				; draw a line length X1-X0
.af2d	ad 4d 06	lda $064d			lda 	gxY0 						; reached end of rectangle ?
.af30	cd 51 06	cmp $0651			cmp 	gxY1
.af33	f0 19		beq $af4e			beq 	_GXRectangleExit
.af35					_GXRectLoop:
.af35	20 e1 b2	jsr $b2e1			jsr 	GXMovePositionDown 			; down one.
.af38	ee 4d 06	inc $064d			inc 	gxY0 						; change Y pos
.af3b	ad 4d 06	lda $064d			lda 	gxY0 						; reached last line
.af3e	cd 51 06	cmp $0651			cmp 	gXY1
.af41	f0 07		beq $af4a			beq 	_GXLastLine
.af43	28		plp				plp 								; get flag back
.af44	08		php				php
.af45	20 56 af	jsr $af56			jsr 	GXDrawLineX1X0 				; draw horizontal line
.af48	80 eb		bra $af35			bra 	_GXRectLoop
.af4a					_GXLastLine:
.af4a	38		sec				sec
.af4b	20 56 af	jsr $af56			jsr 	GXDrawLineX1X0
.af4e					_GXRectangleExit:
.af4e	68		pla				pla 								; throw fill flag.
.af4f	20 83 b2	jsr $b283			jsr 	GXCloseBitmap 				; stop drawing and exit
.af52	18		clc				clc
.af53	60		rts				rts
.af54					_GXRFail:
.af54	38		sec				sec
.af55	60		rts				rts
.af56					GXDrawLineX1X0:
.af56	08		php				php 								; save solid/either-end
.af57	38		sec				sec
.af58	ad 4f 06	lda $064f			lda		gXX1
.af5b	ed 4b 06	sbc $064b			sbc 	gXX0
.af5e	85 36		sta $36				sta 	gxzTemp0
.af60	ad 50 06	lda $0650			lda 	gXX1+1
.af63	ed 4c 06	sbc $064c			sbc 	gXX0+1
.af66	85 37		sta $37				sta 	gxzTemp0+1
.af68	28		plp				plp
.af69					GXDrawLineTemp0:
.af69	a5 3c		lda $3c				lda 	gxzScreen 						; push gxzScreen, gsOffset and GXEditSlot on stack
.af6b	48		pha				pha
.af6c	a5 3d		lda $3d				lda 	gxzScreen+1
.af6e	48		pha				pha
.af6f	ad 5d 06	lda $065d			lda 	gsOffset
.af72	48		pha				pha
.af73	a5 0b		lda $0b				lda 	GXEditSlot
.af75	48		pha				pha
.af76	ac 5d 06	ldy $065d			ldy 	gsOffset 					; Y offset
.af79	90 1e		bcc $af99			bcc 	_GXDLTEndPoints 			; if CC draw end points only.
.af7b					_GXDLTLine:
.af7b	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.af7d	2d 5b 06	and $065b			and 	gxANDValue
.af80	4d 5a 06	eor $065a			eor 	gxEORValue
.af83	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.af85	a5 36		lda $36				lda 	gxzTemp0 					; decrement counter
.af87	d0 04		bne $af8d			bne 	_GXDLTNoBorrow
.af89	c6 37		dec $37				dec 	gxzTemp0+1 					; borrow, if goes -ve then exit
.af8b	30 2e		bmi $afbb			bmi 	_GXDLTExit
.af8d					_GXDLTNoBorrow:
.af8d	c6 36		dec $36				dec 	gxzTemp0
.af8f	c8		iny				iny 								; next slot.
.af90	d0 e9		bne $af7b			bne 	_GXDLTLine
.af92	e6 3d		inc $3d				inc 	gxzScreen+1 					; carry to next
.af94	20 c9 af	jsr $afc9			jsr 	GXDLTCheckWrap				; check for new page.
.af97	80 e2		bra $af7b			bra 	_GXDLTLine
.af99					_GXDLTEndPoints:
.af99	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.af9b	2d 5b 06	and $065b			and 	gxANDValue
.af9e	4d 5a 06	eor $065a			eor 	gxEORValue
.afa1	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.afa3	98		tya				tya 								; advance to right side
.afa4	18		clc				clc
.afa5	65 36		adc $36				adc 	gxzTemp0
.afa7	a8		tay				tay
.afa8	a5 3d		lda $3d				lda 	gxzScreen+1
.afaa	65 37		adc $37				adc 	gxzTemp0+1
.afac	85 3d		sta $3d				sta 	gxzScreen+1
.afae	20 c9 af	jsr $afc9			jsr 	GXDLTCheckWrap 			; fix up.
.afb1	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.afb3	2d 5b 06	and $065b			and 	gxANDValue
.afb6	4d 5a 06	eor $065a			eor 	gxEORValue
.afb9	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.afbb					_GXDLTExit:
.afbb	68		pla				pla
.afbc	85 0b		sta $0b				sta 	GXEditSlot
.afbe	68		pla				pla
.afbf	8d 5d 06	sta $065d			sta 	gsOffset
.afc2	68		pla				pla
.afc3	85 3d		sta $3d				sta 	gxzScreen+1
.afc5	68		pla				pla
.afc6	85 3c		sta $3c				sta 	gxzScreen
.afc8	60		rts				rts
.afc9					GXDLTCheckWrap:
.afc9	a5 3d		lda $3d				lda 	gxzScreen+1 					; check end of page
.afcb	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8)
.afcd	90 06		bcc $afd5			bcc 	_GXDLTCWExit
.afcf	e9 20		sbc #$20			sbc 	#$20 						; fix up
.afd1	85 3d		sta $3d				sta 	gxzScreen+1
.afd3	e6 0b		inc $0b				inc 	GXEditSlot
.afd5					_GXDLTCWExit:
.afd5	60		rts				rts
.afd6					GXDrawGraphicElement:
.afd6	8d f0 06	sta $06f0			sta 	gxSize 						; save size
.afd9	3a		dec a				dec 	a
.afda	8d f1 06	sta $06f1			sta 	gxMask 						; and mask
.afdd	ad 54 06	lda $0654			lda 	gxBitmapsOn 				; check BMP on
.afe0	f0 67		beq $b049			beq 	_GXSLFail
.afe2	ad 4d 06	lda $064d			lda 	gxY0 						; push Y on stack
.afe5	48		pha				pha
.afe6	8c f3 06	sty $06f3			sty 	gxAcquireVector+1 			; and acquisition vector
.afe9	8e f2 06	stx $06f2			stx 	gxAcquireVector
.afec	20 7b b2	jsr $b27b			jsr 	gxOpenBitmap 				; open the bitmap.
.afef	ad f5 06	lda $06f5			lda 	gxUseMode 					; scale bits
.aff2	4a		lsr a				lsr 	a
.aff3	4a		lsr a				lsr 	a
.aff4	4a		lsr a				lsr 	a
.aff5	29 07		and #$07			and		#7
.aff7	1a		inc a				inc 	a
.aff8	8d f4 06	sta $06f4			sta 	gxScale
.affb	64 38		stz $38				stz 	gxzTemp1					; start first line
.affd					_GXGELoop:
.affd	a5 38		lda $38				lda 	gxzTemp1 					; current line number to read.
.afff	2c f5 06	bit $06f5			bit 	gxUseMode 					; check for flip.
.b002	10 06		bpl $b00a			bpl		_GXNoVFlip
.b004	ad f1 06	lda $06f1			lda 	gxMask
.b007	38		sec				sec
.b008	e5 38		sbc $38				sbc 	gxzTemp1
.b00a					_GXNoVFlip:
.b00a	aa		tax				tax 								; get the Xth line.
.b00b	20 4b b0	jsr $b04b			jsr 	_GXCallAcquire 				; get that data.
.b00e	ad f4 06	lda $06f4			lda 	gxScale 					; do scale identical copies of that line.
.b011	85 39		sta $39				sta 	gxzTemp1+1
.b013					_GXGELoop2:
.b013	ad 4d 06	lda $064d			lda 	gxY0 						; off screen
.b016	cd 57 06	cmp $0657			cmp 	gxHeight
.b019	b0 10		bcs $b02b			bcs 	_GXDGEExit
.b01b	20 4e b0	jsr $b04e			jsr 	GXRenderOneLine 			; render line
.b01e	c6 39		dec $39				dec 	gxzTemp1+1 					; scale times.
.b020	d0 f1		bne $b013			bne 	_GXGELoop2
.b022	e6 38		inc $38				inc 	gxzTemp1 					; done all lines.
.b024	a5 38		lda $38				lda 	gxzTemp1
.b026	cd f0 06	cmp $06f0			cmp 	gxSize
.b029	d0 d2		bne $affd			bne 	_GXGELoop
.b02b					_GXDGEExit:
.b02b	68		pla				pla 								; restore Y for next time
.b02c	8d 4d 06	sta $064d			sta 	gxY0
.b02f	ae f4 06	ldx $06f4			ldx 	gxScale 					; get scale (1-8)
.b032					_GXShiftLeft:
.b032	18		clc				clc
.b033	ad f0 06	lda $06f0			lda 	gxSize
.b036	6d 4b 06	adc $064b			adc 	gxX0
.b039	8d 4b 06	sta $064b			sta 	gxX0
.b03c	90 03		bcc $b041			bcc 	_GXSLNoCarry
.b03e	ee 4c 06	inc $064c			inc 	gxX0+1
.b041					_GXSLNoCarry:
.b041	ca		dex				dex
.b042	d0 ee		bne $b032			bne 	_GXShiftLeft
.b044	20 83 b2	jsr $b283			jsr 	GXCloseBitmap
.b047	18		clc				clc
.b048	60		rts				rts
.b049					_GXSLFail:
.b049	38		sec				sec
.b04a	60		rts				rts
.b04b					_GXCallAcquire:
.b04b	6c f2 06	jmp ($06f2)			jmp 	(gxAcquireVector)
.b04e					GXRenderOneLine:
.b04e	20 8b b2	jsr $b28b			jsr 	GXPositionCalc 				; calculate position/offset.
.b051	ac 5d 06	ldy $065d			ldy 	gsOffset 					; Y contains position.
.b054	64 3a		stz $3a				stz 	gxzTemp2 					; do size pixels
.b056					_GXROLLoop1:
.b056	ad f4 06	lda $06f4			lda 	gxScale 					; set to do 'scale' times
.b059	85 3b		sta $3b				sta 	gxzTemp2+1
.b05b					_GXROLLoop2:
.b05b	a5 3a		lda $3a				lda 	gxzTemp2 					; get current pixel
.b05d	2c 58 06	bit $0658			bit 	gxMode 						; check H Flip
.b060	50 06		bvc $b068			bvc 	_GXNoHFlip
.b062	ad f1 06	lda $06f1			lda 	gxMask
.b065	38		sec				sec
.b066	e5 3a		sbc $3a				sbc 	gxzTemp2
.b068					_GXNoHFlip:
.b068	aa		tax				tax 								; read from the pixel buffer
.b069	bd f9 05	lda $05f9,x			lda 	gxPixelBuffer,x
.b06c	d0 07		bne $b075			bne 	_GXDraw 					; draw if non zero
.b06e	ad f5 06	lda $06f5			lda 	gxUseMode 					; check to see if solid background
.b071	29 04		and #$04			and 	#4
.b073	f0 0a		beq $b07f			beq 	_GXZeroPixel
.b075					_GXDraw:
.b075	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.b077	2d 5b 06	and $065b			and 	gxANDValue
.b07a	5d f9 05	eor $05f9,x			eor 	gxPixelBuffer,x
.b07d	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b07f					_GXZeroPixel:
.b07f	c8		iny				iny 								; advance pointer
.b080	d0 05		bne $b087			bne 	_GXNoShift
.b082	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.b084	20 c9 af	jsr $afc9			jsr 	GXDLTCheckWrap				; check for new page.
.b087					_GXNoShift:
.b087	c6 3b		dec $3b				dec 	gxzTemp2+1 					; do the inner loop gxScale times.
.b089	d0 d0		bne $b05b			bne 	_GXROLLoop2
.b08b	e6 3a		inc $3a				inc 	gxzTemp2 					; next pixel.
.b08d	a5 3a		lda $3a				lda 	gxzTemp2
.b08f	cd f0 06	cmp $06f0			cmp 	gxSize
.b092	d0 c2		bne $b056			bne 	_GXROLLoop1
.b094	ee 4d 06	inc $064d			inc 	gxY0
.b097	60		rts				rts
.06f0					gxSize:
>06f0							.fill 	1
.06f1					gxMask:
>06f1							.fill 	1
.06f2					gxAcquireVector:
>06f2							.fill 	2
.06f4					gxScale:
>06f4							.fill 	1
.06f5					gxUseMode:
>06f5							.fill 	1
.b098					GXFontHandler:
.b098	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b09a	4d 58 06	eor $0658			eor 	gxMode
.b09d	8d f5 06	sta $06f5			sta 	gxUseMode
.b0a0	64 37		stz $37				stz 	gxzTemp0+1 					; gxzTemp0 is font #
.b0a2	06 36		asl $36				asl	 	gxzTemp0 					; x 2
.b0a4	26 37		rol $37				rol	 	gxzTemp0+1
.b0a6	06 36		asl $36				asl	 	gxzTemp0 					; x 4
.b0a8	26 37		rol $37				rol	 	gxzTemp0+1
.b0aa	06 36		asl $36				asl	 	gxzTemp0 					; x 8
.b0ac	26 37		rol $37				rol	 	gxzTemp0+1
.b0ae	a5 37		lda $37				lda 	gxzTemp0+1 					; put in page C0
.b0b0	09 c0		ora #$c0			ora 	#$C0
.b0b2	85 37		sta $37				sta 	gxzTemp0+1
.b0b4	a9 08		lda #$08			lda 	#8 							; size 8x8
.b0b6	a2 be		ldx #$be			ldx 	#GXGetGraphicDataFont & $FF ; XY = Graphic Data retrieval routine
.b0b8	a0 b0		ldy #$b0			ldy 	#GXGetGraphicDataFont >> 8
.b0ba	20 d6 af	jsr $afd6			jsr 	GXDrawGraphicElement
.b0bd	60		rts				rts
.b0be					GXGetGraphicDataFont:
.b0be	8a		txa				txa 								; X->Y
.b0bf	a8		tay				tay
.b0c0	a6 01		ldx $01				ldx 	1 							; preserve old value
.b0c2	a9 01		lda #$01			lda 	#1 							; access page 1 (font memory)
.b0c4	85 01		sta $01				sta 	1
.b0c6	b1 36		lda ($36),y			lda 	(gxzTemp0),y 				; read the font element.
.b0c8	86 01		stx $01				stx 	1 							; put old value back.
.b0ca	a2 00		ldx #$00			ldx 	#0 							; do 8 times
.b0cc					_GXExpand:
.b0cc	9e f9 05	stz $05f9,x			stz 	gxPixelBuffer,x 			; zero in pixel buffer
.b0cf	0a		asl a				asl 	a 							; shift bit 7 into C
.b0d0	90 08		bcc $b0da			bcc 	_GXNoPixel
.b0d2	48		pha				pha 								; if set, set pixel buffer to current colour.
.b0d3	ad 59 06	lda $0659			lda 	gxColour
.b0d6	9d f9 05	sta $05f9,x			sta 	gxPixelBuffer,x
.b0d9	68		pla				pla
.b0da					_GXNoPixel:
.b0da	e8		inx				inx 								; do the whole byte.
.b0db	e0 08		cpx #$08			cpx 	#8
.b0dd	d0 ed		bne $b0cc			bne 	_GXExpand
.b0df	60		rts				rts
.b0e0					GXSpriteHandler:
.b0e0	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b0e2	4d 58 06	eor $0658			eor 	gxMode
.b0e5	8d f5 06	sta $06f5			sta 	gxUseMode
.b0e8	a6 36		ldx $36				ldx 	gxzTemp0 					; sprite #
.b0ea	da		phx				phx
.b0eb	20 7b b2	jsr $b27b			jsr 	GXOpenBitmap 				; can access sprite information
.b0ee	68		pla				pla
.b0ef	20 5c b3	jsr $b35c			jsr 	GXFindSprite 				; get the sprite address
.b0f2	08		php				php
.b0f3	20 83 b2	jsr $b283			jsr 	GXCloseBitmap
.b0f6	28		plp				plp
.b0f7	b0 0a		bcs $b103			bcs		_GXSHExit 					; exit if find failed.
.b0f9	ad f6 06	lda $06f6			lda 	GXSizePixels 				; return size
.b0fc	a2 04		ldx #$04			ldx 	#GXSpriteAcquire & $FF
.b0fe	a0 b1		ldy #$b1			ldy 	#GXSpriteAcquire >> 8
.b100	20 d6 af	jsr $afd6			jsr 	GXDrawGraphicElement
.b103					_GXSHExit:
.b103	60		rts				rts
.b104					GXSpriteAcquire:
.b104	ad 56 06	lda $0656			lda 	GXSpritePage				; point to base page
.b107	85 0b		sta $0b				sta 	GXEditSlot
.b109	86 36		stx $36				stx 	zTemp0 						; row number x 1,2,3,4
.b10b	a9 00		lda #$00			lda 	#0
.b10d	ae f7 06	ldx $06f7			ldx 	GXSizeBits
.b110					_GXTimesRowNumber:
.b110	18		clc				clc
.b111	65 36		adc $36				adc 	zTemp0
.b113	ca		dex				dex
.b114	10 fa		bpl $b110			bpl 	_GXTimesRowNumber
.b116	64 37		stz $37				stz 	gxzTemp0+1
.b118	0a		asl a				asl 	a 							; row x 2,4,6,8
.b119	26 37		rol $37				rol 	gxzTemp0+1
.b11b	0a		asl a				asl 	a 							; row x 4,8,12,16
.b11c	26 37		rol $37				rol 	gxzTemp0+1
.b11e	0a		asl a				asl 	a 							; row x 8,16,24,32
.b11f	26 37		rol $37				rol 	gxzTemp0+1
.b121	85 36		sta $36				sta 	gxzTemp0
.b123	18		clc				clc 								; add base address.
.b124	a5 36		lda $36				lda 	gxzTemp0
.b126	6d f9 06	adc $06f9			adc 	GXSpriteOffset
.b129	85 36		sta $36				sta 	gxzTemp0
.b12b	a5 37		lda $37				lda 	gxzTemp0+1
.b12d	6d fa 06	adc $06fa			adc 	GXSpriteOffset+1
.b130					_GXSAFindPage:
.b130	c9 20		cmp #$20			cmp 	#$20 						; on this page
.b132	90 06		bcc $b13a			bcc 	_GXSAFoundPage
.b134	e9 20		sbc #$20			sbc 	#$20 						; forward one page
.b136	e6 0b		inc $0b				inc 	GXEditSlot
.b138	80 f6		bra $b130			bra 	_GXSAFindPage
.b13a					_GXSAFoundPage:
.b13a	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; physical address of page.
.b13c	85 37		sta $37				sta 	gxzTemp0+1 					; gxzTemp0 now points to the page
.b13e	a0 00		ldy #$00			ldy 	#0
.b140					_GXSACopyLoop:
.b140	b1 36		lda ($36),y			lda 	(gxzTemp0),y
.b142	99 f9 05	sta $05f9,y			sta 	gxPixelBuffer,y
.b145	c8		iny				iny
.b146	cc f6 06	cpy $06f6			cpy 	GXSizePixels
.b149	d0 f5		bne $b140			bne 	_GXSACopyLoop
.b14b	60		rts				rts
.b14c					GXSelect:
.b14c	ad 53 06	lda $0653			lda 	gxSpritesOn
.b14f	f0 22		beq $b173			beq 	_GXSFail
.b151	a5 36		lda $36				lda 	gxzTemp0 					; illegal sprite #
.b153	c9 40		cmp #$40			cmp 	#64
.b155	b0 1c		bcs $b173			bcs 	_GXSFail
.b157	8d 5e 06	sta $065e			sta 	GSCurrentSpriteID
.b15a	a4 37		ldy $37				ldy 	gxzTemp0+1 					; control value.
.b15c	a9 00		lda #$00			lda  	#0 							; multiply sprite # x 8 => A
.b15e	06 36		asl $36				asl 	gxzTemp0
.b160	06 36		asl $36				asl 	gxzTemp0
.b162	06 36		asl $36				asl 	gxzTemp0
.b164	2a		rol a				rol 	a
.b165	69 d9		adc #$d9			adc 	#$D9 						; sprite area
.b167	8d 60 06	sta $0660			sta 	GSCurrentSpriteAddr+1 		; address to GSCurrentSprite and gxzTemp
.b16a	85 37		sta $37				sta 	gxzTemp0+1
.b16c	a5 36		lda $36				lda 	gxzTemp0
.b16e	8d 5f 06	sta $065f			sta 	GSCurrentSpriteAddr
.b171	18		clc				clc
.b172	60		rts				rts
.b173					_GXSFail:
.b173	38		sec				sec
.b174	60		rts				rts
.b175					GXSelectImage:
.b175	ad 53 06	lda $0653			lda 	gxSpritesOn
.b178	f0 74		beq $b1ee			beq 	_GXSIFail
.b17a	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b17d	f0 6f		beq $b1ee			beq 	_GXSIFail 					; (checking the MSB)
.b17f	64 01		stz $01				stz 	1
.b181	a5 37		lda $37				lda 	gxzTemp0+1 					; push show/hide on the stack.
.b183	d0 6b		bne $b1f0			bne 	_GXSIHide
.b185	a5 36		lda $36				lda 	gxzTemp0 					; sprite image
.b187	48		pha				pha
.b188	20 7b b2	jsr $b27b			jsr 	GXOpenBitmap
.b18b	68		pla				pla
.b18c	20 5c b3	jsr $b35c			jsr 	GXFindSprite
.b18f	b0 5a		bcs $b1eb			bcs 	_GXSICloseFail 				; no image
.b191	a0 01		ldy #$01			ldy 	#1
.b193	ad 5f 06	lda $065f			lda 	GSCurrentSpriteAddr
.b196	85 36		sta $36				sta 	gxzTemp0
.b198	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr+1
.b19b	85 37		sta $37				sta 	gxzTemp0+1
.b19d	ad f9 06	lda $06f9			lda 	GXSpriteOffset
.b1a0	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b1a2	18		clc				clc
.b1a3	ad fa 06	lda $06fa			lda 	GXSpriteOffset+1
.b1a6	6d 61 06	adc $0661			adc 	GXSpriteOffsetBase
.b1a9	c8		iny				iny
.b1aa	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b1ac	ad 62 06	lda $0662			lda 	GXSpriteOffsetBase+1
.b1af	69 00		adc #$00			adc 	#0
.b1b1	c8		iny				iny
.b1b2	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b1b4	ad f7 06	lda $06f7			lda 	GXSizeBits 					; get raw size
.b1b7	49 03		eor #$03			eor 	#3 							; make it right (00=32 etc.)
.b1b9	2a		rol a				rol 	a 							; x 2
.b1ba	0a		asl a				asl 	a 							; x 4
.b1bb	0a		asl a				asl 	a 							; x 8
.b1bc	0a		asl a				asl 	a 							; x 16
.b1bd	0d f8 06	ora $06f8			ora 	GXSpriteLUT 				; Or with LUT
.b1c0	0a		asl a				asl 	a 							; 1 shift
.b1c1	09 01		ora #$01			ora 	#1 							; enable sprite.
.b1c3	92 36		sta ($36)			sta 	(gxzTemp0) 					; and write back
.b1c5	20 83 b2	jsr $b283			jsr 	GXCloseBitmap
.b1c8	ae 5e 06	ldx $065e			ldx 	GSCurrentSpriteID 			; point to sprite entries.
.b1cb	bd a3 06	lda $06a3,x			lda 	GXSpriteHigh,x 				; clear upper two bits of size
.b1ce	29 3f		and #$3f			and 	#$3F
.b1d0	9d a3 06	sta $06a3,x			sta 	GXSpriteHigh,x
.b1d3	ad f7 06	lda $06f7			lda 	GXSizeBits 					; get bit size
.b1d6	6a		ror a				ror 	a 							; shift into bits 6/7
.b1d7	6a		ror a				ror 	a
.b1d8	6a		ror a				ror 	a
.b1d9	29 c0		and #$c0			and 	#$C0
.b1db	1d a3 06	ora $06a3,x			ora 	GXSpriteHigh,x 				; put in  upper 2 bits of sprite data
.b1de	9d a3 06	sta $06a3,x			sta 	GXSpriteHigh,x
.b1e1	bd 63 06	lda $0663,x			lda 	GXSpriteLow,x 				; clear hidden flag.
.b1e4	29 7f		and #$7f			and 	#$7F
.b1e6	9d 63 06	sta $0663,x			sta 	GXSpriteLow,x
.b1e9	18		clc				clc
.b1ea	60		rts				rts
.b1eb					_GXSICloseFail:
.b1eb	20 83 b2	jsr $b283			jsr 	GXCloseBitmap
.b1ee					_GXSIFail:
.b1ee	38		sec				sec
.b1ef	60		rts				rts
.b1f0					_GXSIHide:
.b1f0	ad 5f 06	lda $065f			lda 	GSCurrentSpriteAddr  		; get Sprite h/w address and write there
.b1f3	85 36		sta $36				sta 	gxzTemp0
.b1f5	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr+1
.b1f8	85 37		sta $37				sta 	gxzTemp0+1
.b1fa	a9 00		lda #$00			lda 	#0
.b1fc	92 36		sta ($36)			sta 	(gxzTemp0)
.b1fe	ae 5e 06	ldx $065e			ldx 	GSCurrentSpriteID 			; get sprite ID
.b201	bd 63 06	lda $0663,x			lda 	GXSpriteLow,x 				; set the hidden bit.
.b204	09 80		ora #$80			ora 	#$80
.b206	9d 63 06	sta $0663,x			sta 	GXSpriteLow,x
.b209	18		clc				clc
.b20a	60		rts				rts
.b20b					GXMoveSprite:
.b20b	ad 53 06	lda $0653			lda 	gxSpritesOn
.b20e	f0 65		beq $b275			beq 	_GXSIFail
.b210	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b213	f0 60		beq $b275			beq 	_GXSIFail
.b215	85 37		sta $37				sta 	gxzTemp0+1
.b217	a0 04		ldy #$04			ldy 	#4
.b219	ad 5f 06	lda $065f			lda 	GSCurrentSpriteAddr
.b21c	85 36		sta $36				sta 	gxzTemp0
.b21e	ae 5e 06	ldx $065e			ldx 	GSCurrentSpriteID 			; get the size from the upper two bits
.b221	bd a3 06	lda $06a3,x			lda 	GXSpriteHigh,x
.b224	2a		rol a				rol 	a	 						; into bits 0,1.
.b225	2a		rol a				rol 	a
.b226	2a		rol a				rol 	a
.b227	29 03		and #$03			and 	#3
.b229	aa		tax				tax
.b22a	bd 77 b2	lda $b277,x			lda 	_GXMSOffset,x 				; get 32-SpriteSize/2
.b22d	48		pha				pha
.b22e	18		clc				clc
.b22f	6d 4b 06	adc $064b			adc 	gxX0						; copy position.
.b232	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b234	c8		iny				iny
.b235	ad 4c 06	lda $064c			lda 	gxX0+1
.b238	69 00		adc #$00			adc 	#0
.b23a	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b23c	c8		iny				iny
.b23d	68		pla				pla
.b23e	18		clc				clc
.b23f	6d 4d 06	adc $064d			adc 	gxY0
.b242	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b244	a9 00		lda #$00			lda 	#0
.b246	69 00		adc #$00			adc 	#0
.b248	c8		iny				iny
.b249	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b24b	4e 4c 06	lsr $064c			lsr 	gxX0+1 						; divide X by 4
.b24e	6e 4b 06	ror $064b			ror 	gxX0
.b251	4e 4b 06	lsr $064b			lsr 	gxX0
.b254	4e 4d 06	lsr $064d			lsr 	gxY0 						; divide Y by 4
.b257	4e 4d 06	lsr $064d			lsr 	gxY0
.b25a	ae 5e 06	ldx $065e			ldx 	GSCurrentSpriteID 			; copy X/4 and Y/4 into the status bytes
.b25d	bd 63 06	lda $0663,x			lda 	GXSpriteLow,x
.b260	29 80		and #$80			and 	#$80
.b262	0d 4b 06	ora $064b			ora 	gxX0
.b265	9d 63 06	sta $0663,x			sta 	GXSpriteLow,x
.b268	bd a3 06	lda $06a3,x			lda 	GXSpriteHigh,x
.b26b	29 c0		and #$c0			and 	#$C0
.b26d	0d 4d 06	ora $064d			ora 	gxY0
.b270	9d a3 06	sta $06a3,x			sta 	GXSpriteHigh,x
.b273	18		clc				clc
.b274	60		rts				rts
.b275					_GXSIFail:
.b275	38		sec				sec
.b276	60		rts				rts
.b277					_GXMSOffset:
>b277	1c						.byte 	32-8/2
>b278	18						.byte 	32-16/2
>b279	14						.byte 	32-24/2
>b27a	10						.byte 	32-32/2
.b27b					GXOpenBitmap:
.b27b	78		sei				sei 								; no interrupts here
.b27c	a5 0b		lda $0b				lda 	GXEditSlot 					; Save the original LUT slot value
.b27e	8d 5c 06	sta $065c			sta 	gxOriginalLUTValue
.b281	58		cli				cli
.b282	60		rts				rts
.b283					GXCloseBitmap:
.b283	78		sei				sei
.b284	ad 5c 06	lda $065c			lda 	gxOriginalLUTValue 			; restore LUT slot value
.b287	85 0b		sta $0b				sta 	GXEditSlot
.b289	58		cli				cli
.b28a	60		rts				rts
.b28b					GXPositionCalc:
.b28b	a5 36		lda $36				lda 	gxzTemp0 					; save temp memory slot
.b28d	48		pha				pha
.b28e	ad 4d 06	lda $064d			lda 	GXY0 						; gxzScreen = Y0
.b291	85 3c		sta $3c				sta 	gxzScreen
.b293	64 3d		stz $3d				stz 	gxzScreen+1
.b295	06 3c		asl $3c				asl 	gxzScreen 						; gxzScreen = Y0 * 4
.b297	26 3d		rol $3d				rol 	gxzScreen+1
.b299	06 3c		asl $3c				asl 	gxzScreen
.b29b	26 3d		rol $3d				rol 	gxzScreen+1
.b29d	18		clc				clc 								; gxzScreen = Y0 * 5, as it's still in A
.b29e	65 3c		adc $3c				adc 	gxzScreen
.b2a0	85 3c		sta $3c				sta 	gxzScreen
.b2a2	90 02		bcc $b2a6			bcc 	_GXPCNoCarry
.b2a4	e6 3d		inc $3d				inc 	gxzScreen+1
.b2a6					_GXPCNoCarry:
.b2a6	06 3c		asl $3c				asl 	gxzScreen 						; now Y0 * 10. Needs to be multiplied by another
.b2a8	26 3d		rol $3d				rol 	gxzScreen+1 					; 32. At this point the MSB contains the offset
.b2aa	a5 3d		lda $3d				lda	 	gxzScreen+1 					; so save this in zTemp0 and zero it.
.b2ac	85 36		sta $36				sta 	gxzTemp0
.b2ae	64 3d		stz $3d				stz 	gxzScreen+1
.b2b0	a9 05		lda #$05			lda 	#5 							; now multiply by 32, this puts this in the range 0..8191
.b2b2					_GXPCMultiply32:
.b2b2	06 3c		asl $3c				asl 	gxzScreen
.b2b4	26 3d		rol $3d				rol 	gxzScreen+1
.b2b6	3a		dec a				dec 	a
.b2b7	d0 f9		bne $b2b2			bne 	_GXPCMultiply32
.b2b9	18		clc				clc
.b2ba	ad 4b 06	lda $064b			lda 	GXX0 						; add X to this value, put the result in gsOffset, gxzScreen has to be on a page boundary
.b2bd	65 3c		adc $3c				adc 	gxzScreen
.b2bf	8d 5d 06	sta $065d			sta 	gsOffset
.b2c2	ad 4c 06	lda $064c			lda 	GXX0+1
.b2c5	65 3d		adc $3d				adc 	gxzScreen+1
.b2c7	c9 20		cmp #$20			cmp 	#$20 						; has it overflowed into the next one ?
.b2c9	90 04		bcc $b2cf			bcc 	_GXPCNoOverflow
.b2cb	29 1f		and #$1f			and 	#$1F 						; fix it up
.b2cd	e6 36		inc $36				inc 	gxzTemp0 					; add 1 to the page number
.b2cf					_GXPCNoOverflow:
.b2cf	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; make it the address mapped in.
.b2d1	85 3d		sta $3d				sta 	gxzScreen+1
.b2d3	64 3c		stz $3c				stz 	gxzScreen
.b2d5	18		clc				clc
.b2d6	a5 36		lda $36				lda 	gxzTemp0 					; get the page number
.b2d8	6d 55 06	adc $0655			adc 	gxBasePage 					; by adding the base page
.b2db	85 0b		sta $0b				sta 	GXEditSlot 				; and map it into memory.
.b2dd	68		pla				pla
.b2de	85 36		sta $36				sta 	gxzTemp0
.b2e0	60		rts				rts
.b2e1					GXMovePositionDown:
.b2e1	18		clc				clc 								; add 320 to offset/temp+1
.b2e2	ad 5d 06	lda $065d			lda 	gsOffset
.b2e5	69 40		adc #$40			adc 	#64
.b2e7	8d 5d 06	sta $065d			sta 	gsOffset
.b2ea	a5 3d		lda $3d				lda 	gxzScreen+1
.b2ec	69 01		adc #$01			adc 	#1
.b2ee	85 3d		sta $3d				sta 	gxzScreen+1
.b2f0	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page
.b2f2	90 07		bcc $b2fb			bcc 	_GXMPDExit
.b2f4	38		sec				sec  								; next page
.b2f5	e9 20		sbc #$20			sbc 	#$20
.b2f7	85 3d		sta $3d				sta 	gxzScreen+1
.b2f9	e6 0b		inc $0b				inc 	GXEditSlot
.b2fb					_GXMPDExit:
.b2fb	60		rts				rts
.b2fc					GXCollide:
.b2fc	a5 36		lda $36				lda 	gxzTemp0 					; check if sprite numbers are legal.
.b2fe	aa		tax				tax
.b2ff	05 37		ora $37				ora 	gxzTemp0+1
.b301	29 c0		and #$c0			and 	#$C0
.b303	38		sec				sec
.b304	d0 53		bne $b359			bne 	_GXCollideFail 				; if either >= 64, fail.
.b306	a4 37		ldy $37				ldy 	gxzTemp0+1 					; at this point X is 1st sprite and Y is 2nd sprite.
.b308	b9 63 06	lda $0663,y			lda 	GXSpriteLow,y 				; check if either hidden bit is set
.b30b	1d 63 06	ora $0663,x			ora 	GXSpriteLow,x
.b30e	30 48		bmi $b358			bmi 	_GXOkayFail 				; if either hidden, then they cannot collide.
.b310	18		clc				clc 								; need to calculate sum of sizes.
.b311	b9 a3 06	lda $06a3,y			lda 	GXSpriteHigh,y
.b314	7d a3 06	adc $06a3,x			adc 	GXSpriteHigh,x 				; at this point, CS, Bit 6 and 7 contain that sum.
.b317	29 c0		and #$c0			and 	#$C0 					 	; mask off
.b319	6a		ror a				ror 	a 							; 5/6/7
.b31a	4a		lsr a				lsr 	a 							; 4/5/6
.b31b	4a		lsr a				lsr 	a 							; 3/4/5
.b31c	4a		lsr a				lsr 	a 							; 2/3/4
.b31d	18		clc				clc
.b31e	69 08		adc #$08			adc 	#$08
.b320	4a		lsr a				lsr 	a 							; adjust because all coordinates are divided by 4 to store.
.b321	4a		lsr a				lsr 	a
.b322	85 38		sta $38				sta 	gxzTemp1 					; so the difference between the centres has to be less than this.
.b324	b9 a3 06	lda $06a3,y			lda 	GXSpriteHigh,y 				; calculate y1-y0
.b327	29 3f		and #$3f			and 	#$3F
.b329	85 39		sta $39				sta 	gxzTemp1+1
.b32b	38		sec				sec
.b32c	bd a3 06	lda $06a3,x			lda 	GXSpriteHigh,x
.b32f	29 3f		and #$3f			and 	#$3F
.b331	e5 39		sbc $39				sbc 	gxzTemp1+1
.b333	b0 03		bcs $b338			bcs 	_GXCAbs1 					; calculate |y1-y0|
.b335	49 ff		eor #$ff			eor 	#$FF
.b337	1a		inc a				inc 	a
.b338					_GXCAbs1:
.b338	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b33a	b0 1c		bcs $b358			bcs 	_GXOkayFail
.b33c	85 39		sta $39				sta 	gxzTemp1+1 					; save |y1-y0|
.b33e	38		sec				sec 								; calculate |x1-x0|
.b33f	b9 63 06	lda $0663,y			lda 	GXSpriteLow,y
.b342	fd 63 06	sbc $0663,x			sbc 	GXSpriteLow,x
.b345	b0 03		bcs $b34a			bcs 	_GXCAbs2
.b347	49 ff		eor #$ff			eor 	#$FF
.b349	1a		inc a				inc 	a
.b34a					_GXCAbs2:
.b34a	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b34c	b0 0a		bcs $b358			bcs 	_GXOkayFail
.b34e	c5 39		cmp $39				cmp 	gxzTemp1+1 					; is it less than the previous one.
.b350	90 02		bcc $b354			bcc 	_GXCHaveLowest
.b352	a5 39		lda $39				lda 	gxzTemp1+1 					; if not, that's the smallest difference.
.b354					_GXCHaveLowest:
.b354	0a		asl a				asl 	a 							; scale to allow for >> 2
.b355	0a		asl a				asl 	a
.b356	18		clc				clc
.b357	60		rts				rts
.b358					_GXOkayFail:
.b358	18		clc				clc
.b359					_GXCollideFail:
.b359	a9 ff		lda #$ff			lda 	#$FF
.b35b	60		rts				rts
.b35c					GXFindSprite:
.b35c	aa		tax				tax
.b35d	ad 56 06	lda $0656			lda 	GXSpritePage 				; access the base page of the sprite
.b360	85 0b		sta $0b				sta 	GXEditSlot
.b362	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; check a valid sprite
.b365	1d 00 60	ora $6000,x			ora 	GXMappingAddress,x
.b368	f0 33		beq $b39d			beq 	_GXFSFail
.b36a	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; MSB
.b36d	8d fa 06	sta $06fa			sta 	GXSpriteOffset+1
.b370	bd 00 60	lda $6000,x			lda 	GXMappingAddress,x 			; LSB
.b373	48		pha				pha 								; save twice
.b374	48		pha				pha
.b375	29 03		and #$03			and 	#3 							; get sprite size
.b377	8d f7 06	sta $06f7			sta 	GXSizeBits 					; save raw (0-3)
.b37a	aa		tax				tax
.b37b	bd 9f b3	lda $b39f,x			lda 	_GXFXSSTTable,x 			; read sprite size
.b37e	8d f6 06	sta $06f6			sta 	GXSizePixels 					; save (8/16/24/32)
.b381	68		pla				pla 								; get LUT
.b382	4a		lsr a				lsr		a
.b383	4a		lsr a				lsr		a
.b384	29 03		and #$03			and 	#3
.b386	8d f8 06	sta $06f8			sta 	GXSpriteLUT
.b389	68		pla				pla 								; address, neeeds to be x 4
.b38a	29 f0		and #$f0			and 	#$F0
.b38c	8d f9 06	sta $06f9			sta 	GXSpriteOffset
.b38f	0e f9 06	asl $06f9			asl 	GXSpriteOffset
.b392	2e fa 06	rol $06fa			rol 	GXSpriteOffset+1
.b395	0e f9 06	asl $06f9			asl 	GXSpriteOffset
.b398	2e fa 06	rol $06fa			rol 	GXSpriteOffset+1
.b39b	18		clc				clc
.b39c	60		rts				rts
.b39d					_GXFSFail:
.b39d	38		sec				sec
.b39e	60		rts				rts
.b39f					_GXFXSSTTable:
>b39f	08 10 18 20					.byte 	8,16,24,32
.06f6					GXSizePixels:
>06f6							.fill 	1
.06f7					GXSizeBits:
>06f7							.fill 	1
.06f8					GXSpriteLUT:
>06f8							.fill 	1
.06f9					GXSpriteOffset:
>06f9							.fill 	2
.b3a3					GXSortXY:
.b3a3	20 c1 b3	jsr $b3c1			jsr 	GXSortY 					; will be sorted on Y now
.b3a6	ad 4b 06	lda $064b			lda 	gxX0 						; compare X0 v X1
.b3a9	cd 4f 06	cmp $064f			cmp 	gxX1
.b3ac	ad 4c 06	lda $064c			lda 	gXX0+1
.b3af	ed 50 06	sbc $0650			sbc 	gXX1+1
.b3b2	90 0c		bcc $b3c0			bcc 	_GXSXYExit 					; X0 < X1 exit
.b3b4	a2 00		ldx #$00			ldx 	#0 							; swap them over
.b3b6	a0 04		ldy #$04			ldy 	#4
.b3b8	20 d5 b3	jsr $b3d5			jsr 	GXSwapXY
.b3bb	e8		inx				inx
.b3bc	c8		iny				iny
.b3bd	20 d5 b3	jsr $b3d5			jsr 	GXSwapXY
.b3c0					_GXSXYExit:
.b3c0	60		rts				rts
.b3c1					GXSortY:
.b3c1	ad 4d 06	lda $064d			lda 	gxY0 						; if Y0 >= Y1
.b3c4	cd 51 06	cmp $0651			cmp 	gxY1
.b3c7	90 0b		bcc $b3d4			bcc 	_GXSYSorted
.b3c9	a2 03		ldx #$03			ldx 	#3 							; swap 3-0
.b3cb	a0 07		ldy #$07			ldy 	#7 							; with 4-7
.b3cd					_GXSwap1:
.b3cd	20 d5 b3	jsr $b3d5			jsr 	GXSwapXY
.b3d0	88		dey				dey
.b3d1	ca		dex				dex
.b3d2	10 f9		bpl $b3cd			bpl 	_GXSwap1
.b3d4					_GXSYSorted:
.b3d4	60		rts				rts
.b3d5					GXSwapXY:
.b3d5	bd 4b 06	lda $064b,x			lda 	gxX0,x
.b3d8	48		pha				pha
.b3d9	b9 4b 06	lda $064b,y			lda 	gxX0,y
.b3dc	9d 4b 06	sta $064b,x			sta 	gxX0,x
.b3df	68		pla				pla
.b3e0	99 4b 06	sta $064b,y			sta 	gxX0,y
.b3e3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_tokeniser.module

=1					tokeniserIntegrated=1
.ba59					KeywordSet0:
>ba59	00 65					.text	0,$65,""               ; $80 !0:EOF
>ba5b	00 58					.text	0,$58,""               ; $81 !1:SH1
>ba5d	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>ba5f	04 fe 41 42 53 28			.text	4,$fe,"ABS("           ; $83 ABS(
>ba65	06 93 41 4c 4c 4f 43 28			.text	6,$93,"ALLOC("         ; $84 ALLOC(
>ba6d	04 ff 41 53 43 28			.text	4,$ff,"ASC("           ; $85 ASC(
>ba73	05 29 43 48 52 24 28			.text	5,$29,"CHR$("          ; $86 CHR$(
>ba7a	06 aa 45 56 45 4e 54 28			.text	6,$aa,"EVENT("         ; $87 EVENT(
>ba82	05 6b 46 41 4c 53 45			.text	5,$6b,"FALSE"          ; $88 FALSE
>ba89	05 44 46 52 41 43 28			.text	5,$44,"FRAC("          ; $89 FRAC(
>ba90	04 0d 48 49 54 28			.text	4,$0d,"HIT("           ; $8a HIT(
>ba96	04 13 49 4e 54 28			.text	4,$13,"INT("           ; $8b INT(
>ba9c	06 a7 49 53 56 41 4c 28			.text	6,$a7,"ISVAL("         ; $8c ISVAL(
>baa4	05 5c 4a 4f 59 42 28			.text	5,$5c,"JOYB("          ; $8d JOYB(
>baab	05 72 4a 4f 59 58 28			.text	5,$72,"JOYX("          ; $8e JOYX(
>bab2	05 73 4a 4f 59 59 28			.text	5,$73,"JOYY("          ; $8f JOYY(
>bab9	06 77 4c 45 46 54 24 28			.text	6,$77,"LEFT$("         ; $90 LEFT$(
>bac1	04 07 4c 45 4e 28			.text	4,$07,"LEN("           ; $91 LEN(
>bac7	04 0e 4d 41 58 28			.text	4,$0e,"MAX("           ; $92 MAX(
>bacd	05 26 4d 49 44 24 28			.text	5,$26,"MID$("          ; $93 MID$(
>bad4	04 0c 4d 49 4e 28			.text	4,$0c,"MIN("           ; $94 MIN(
>bada	04 19 4e 4f 54 28			.text	4,$19,"NOT("           ; $95 NOT(
>bae0	08 3c 50 4c 41 59 49 4e			.text	8,$3c,"PLAYING("       ; $96 PLAYING(
>bae8	47 28
>baea	07 e9 52 41 4e 44 4f 4d			.text	7,$e9,"RANDOM("        ; $97 RANDOM(
>baf2	28
>baf3	07 ca 52 49 47 48 54 24			.text	7,$ca,"RIGHT$("        ; $98 RIGHT$(
>bafb	28
>bafc	04 0c 52 4e 44 28			.text	4,$0c,"RND("           ; $99 RND(
>bb02	04 10 53 47 4e 28			.text	4,$10,"SGN("           ; $9a SGN(
>bb08	04 0e 53 50 43 28			.text	4,$0e,"SPC("           ; $9b SPC(
>bb0e	05 45 53 54 52 24 28			.text	5,$45,"STR$("          ; $9c STR$(
>bb15	06 a9 54 49 4d 45 52 28			.text	6,$a9,"TIMER("         ; $9d TIMER(
>bb1d	04 40 54 52 55 45			.text	4,$40,"TRUE"           ; $9e TRUE
>bb23	04 0b 56 41 4c 28			.text	4,$0b,"VAL("           ; $9f VAL(
>bb29	03 e7 46 4f 52				.text	3,$e7,"FOR"            ; $a0 FOR
>bb2e	02 8f 49 46				.text	2,$8f,"IF"             ; $a1 IF
>bb32	04 34 50 52 4f 43			.text	4,$34,"PROC"           ; $a2 PROC
>bb38	06 c1 52 45 50 45 41 54			.text	6,$c1,"REPEAT"         ; $a3 REPEAT
>bb40	05 79 57 48 49 4c 45			.text	5,$79,"WHILE"          ; $a4 WHILE
>bb47	05 66 45 4e 44 49 46			.text	5,$66,"ENDIF"          ; $a5 ENDIF
>bb4e	07 0b 45 4e 44 50 52 4f			.text	7,$0b,"ENDPROC"        ; $a6 ENDPROC
>bb56	43
>bb57	04 3f 4e 45 58 54			.text	4,$3f,"NEXT"           ; $a7 NEXT
>bb5d	04 2f 54 48 45 4e			.text	4,$2f,"THEN"           ; $a8 THEN
>bb63	05 8c 55 4e 54 49 4c			.text	5,$8c,"UNTIL"          ; $a9 UNTIL
>bb6a	04 2e 57 45 4e 44			.text	4,$2e,"WEND"           ; $aa WEND
>bb70	02 9b 42 59				.text	2,$9b,"BY"             ; $ab BY
>bb74	04 1c 43 41 4c 4c			.text	4,$1c,"CALL"           ; $ac CALL
>bb7a	06 b2 43 49 52 43 4c 45			.text	6,$b2,"CIRCLE"         ; $ad CIRCLE
>bb82	05 67 43 4c 45 41 52			.text	5,$67,"CLEAR"          ; $ae CLEAR
>bb89	03 e2 43 4c 53				.text	3,$e2,"CLS"            ; $af CLS
>bb8e	05 7f 43 4f 4c 4f 52			.text	5,$7f,"COLOR"          ; $b0 COLOR
>bb95	06 d4 43 4f 4c 4f 55 52			.text	6,$d4,"COLOUR"         ; $b1 COLOUR
>bb9d	04 1a 44 41 54 41			.text	4,$1a,"DATA"           ; $b2 DATA
>bba3	03 da 44 49 4d				.text	3,$da,"DIM"            ; $b3 DIM
>bba8	06 db 44 4f 57 4e 54 4f			.text	6,$db,"DOWNTO"         ; $b4 DOWNTO
>bbb0	04 29 45 4c 53 45			.text	4,$29,"ELSE"           ; $b5 ELSE
>bbb6	04 34 46 52 4f 4d			.text	4,$34,"FROM"           ; $b6 FROM
>bbbc	03 e5 47 46 58				.text	3,$e5,"GFX"            ; $b7 GFX
>bbc1	05 80 47 4f 53 55 42			.text	5,$80,"GOSUB"          ; $b8 GOSUB
>bbc8	04 39 47 4f 54 4f			.text	4,$39,"GOTO"           ; $b9 GOTO
>bbce	04 24 48 45 52 45			.text	4,$24,"HERE"           ; $ba HERE
>bbd4	05 63 49 4d 41 47 45			.text	5,$63,"IMAGE"          ; $bb IMAGE
>bbdb	03 e5 4c 45 54				.text	3,$e5,"LET"            ; $bc LET
>bbe0	04 28 4c 49 4e 45			.text	4,$28,"LINE"           ; $bd LINE
>bbe6	05 6b 4c 4f 43 41 4c			.text	5,$6b,"LOCAL"          ; $be LOCAL
>bbed	03 db 4f 46 46				.text	3,$db,"OFF"            ; $bf OFF
>bbf2	02 9d 4f 4e				.text	2,$9d,"ON"             ; $c0 ON
>bbf6	07 20 4f 55 54 4c 49 4e			.text	7,$20,"OUTLINE"        ; $c1 OUTLINE
>bbfe	45
>bbff	07 0f 50 41 4c 45 54 54			.text	7,$0f,"PALETTE"        ; $c2 PALETTE
>bc07	45
>bc08	04 3f 50 4c 4f 54			.text	4,$3f,"PLOT"           ; $c3 PLOT
>bc0e	05 8d 50 52 49 4e 54			.text	5,$8d,"PRINT"          ; $c4 PRINT
>bc15	04 1c 52 45 41 44			.text	4,$1c,"READ"           ; $c5 READ
>bc1b	04 2e 52 45 43 54			.text	4,$2e,"RECT"           ; $c6 RECT
>bc21	03 e4 52 45 4d				.text	3,$e4,"REM"            ; $c7 REM
>bc26	06 e0 52 45 54 55 52 4e			.text	6,$e0,"RETURN"         ; $c8 RETURN
>bc2e	05 7b 53 4f 4c 49 44			.text	5,$7b,"SOLID"          ; $c9 SOLID
>bc35	05 89 53 4f 55 4e 44			.text	5,$89,"SOUND"          ; $ca SOUND
>bc3c	06 d7 53 50 52 49 54 45			.text	6,$d7,"SPRITE"         ; $cb SPRITE
>bc44	04 45 54 45 58 54			.text	4,$45,"TEXT"           ; $cc TEXT
>bc4a	02 a3 54 4f				.text	2,$a3,"TO"             ; $cd TO
>bc4e	ff					.text	$FF
.bc4f					KeywordSet1:
>bc4f	00 65					.text	0,$65,""               ; $80 !0:EOF
>bc51	00 58					.text	0,$58,""               ; $81 !1:SH1
>bc53	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bc55	08 4c 41 53 53 45 4d 42			.text	8,$4c,"ASSEMBLE"       ; $83 ASSEMBLE
>bc5d	4c 45
>bc5f	06 d2 41 53 53 45 52 54			.text	6,$d2,"ASSERT"         ; $84 ASSERT
>bc67	06 bd 42 49 54 4d 41 50			.text	6,$bd,"BITMAP"         ; $85 BITMAP
>bc6f	03 d7 45 4e 44				.text	3,$d7,"END"            ; $86 END
>bc74	04 3c 4c 49 53 54			.text	4,$3c,"LIST"           ; $87 LIST
>bc7a	03 ea 4e 45 57				.text	3,$ea,"NEW"            ; $88 NEW
>bc7f	07 24 52 45 53 54 4f 52			.text	7,$24,"RESTORE"        ; $89 RESTORE
>bc87	45
>bc88	03 f5 52 55 4e				.text	3,$f5,"RUN"            ; $8a RUN
>bc8d	07 2a 53 50 52 49 54 45			.text	7,$2a,"SPRITES"        ; $8b SPRITES
>bc95	53
>bc96	04 46 53 54 4f 50			.text	4,$46,"STOP"           ; $8c STOP
>bc9c	ff					.text	$FF
.bc9d					KeywordSet2:
>bc9d	00 65					.text	0,$65,""               ; $80 !0:EOF
>bc9f	00 58					.text	0,$58,""               ; $81 !1:SH1
>bca1	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bca3	03 c8 41 44 43				.text	3,$c8,"ADC"            ; $83 ADC
>bca8	03 d3 41 4e 44				.text	3,$d3,"AND"            ; $84 AND
>bcad	03 e0 41 53 4c				.text	3,$e0,"ASL"            ; $85 ASL
>bcb2	03 c8 42 43 43				.text	3,$c8,"BCC"            ; $86 BCC
>bcb7	03 d8 42 43 53				.text	3,$d8,"BCS"            ; $87 BCS
>bcbc	03 d8 42 45 51				.text	3,$d8,"BEQ"            ; $88 BEQ
>bcc1	03 df 42 49 54				.text	3,$df,"BIT"            ; $89 BIT
>bcc6	03 d8 42 4d 49				.text	3,$d8,"BMI"            ; $8a BMI
>bccb	03 d5 42 4e 45				.text	3,$d5,"BNE"            ; $8b BNE
>bcd0	03 de 42 50 4c				.text	3,$de,"BPL"            ; $8c BPL
>bcd5	03 d5 42 52 41				.text	3,$d5,"BRA"            ; $8d BRA
>bcda	03 df 42 52 4b				.text	3,$df,"BRK"            ; $8e BRK
>bcdf	03 db 42 56 43				.text	3,$db,"BVC"            ; $8f BVC
>bce4	03 eb 42 56 53				.text	3,$eb,"BVS"            ; $90 BVS
>bce9	03 d2 43 4c 43				.text	3,$d2,"CLC"            ; $91 CLC
>bcee	03 d3 43 4c 44				.text	3,$d3,"CLD"            ; $92 CLD
>bcf3	03 d8 43 4c 49				.text	3,$d8,"CLI"            ; $93 CLI
>bcf8	03 e5 43 4c 56				.text	3,$e5,"CLV"            ; $94 CLV
>bcfd	03 e0 43 4d 50				.text	3,$e0,"CMP"            ; $95 CMP
>bd02	03 eb 43 50 58				.text	3,$eb,"CPX"            ; $96 CPX
>bd07	03 ec 43 50 59				.text	3,$ec,"CPY"            ; $97 CPY
>bd0c	03 cc 44 45 43				.text	3,$cc,"DEC"            ; $98 DEC
>bd11	03 e1 44 45 58				.text	3,$e1,"DEX"            ; $99 DEX
>bd16	03 e2 44 45 59				.text	3,$e2,"DEY"            ; $9a DEY
>bd1b	03 e6 45 4f 52				.text	3,$e6,"EOR"            ; $9b EOR
>bd20	03 da 49 4e 43				.text	3,$da,"INC"            ; $9c INC
>bd25	03 ef 49 4e 58				.text	3,$ef,"INX"            ; $9d INX
>bd2a	03 f0 49 4e 59				.text	3,$f0,"INY"            ; $9e INY
>bd2f	03 e7 4a 4d 50				.text	3,$e7,"JMP"            ; $9f JMP
>bd34	03 ef 4a 53 52				.text	3,$ef,"JSR"            ; $a0 JSR
>bd39	03 d1 4c 44 41				.text	3,$d1,"LDA"            ; $a1 LDA
>bd3e	03 e8 4c 44 58				.text	3,$e8,"LDX"            ; $a2 LDX
>bd43	03 e9 4c 44 59				.text	3,$e9,"LDY"            ; $a3 LDY
>bd48	03 f1 4c 53 52				.text	3,$f1,"LSR"            ; $a4 LSR
>bd4d	03 ed 4e 4f 50				.text	3,$ed,"NOP"            ; $a5 NOP
>bd52	03 e2 4f 52 41				.text	3,$e2,"ORA"            ; $a6 ORA
>bd57	03 d9 50 48 41				.text	3,$d9,"PHA"            ; $a7 PHA
>bd5c	03 e8 50 48 50				.text	3,$e8,"PHP"            ; $a8 PHP
>bd61	03 f0 50 48 58				.text	3,$f0,"PHX"            ; $a9 PHX
>bd66	03 f1 50 48 59				.text	3,$f1,"PHY"            ; $aa PHY
>bd6b	03 dd 50 4c 41				.text	3,$dd,"PLA"            ; $ab PLA
>bd70	03 ec 50 4c 50				.text	3,$ec,"PLP"            ; $ac PLP
>bd75	03 f4 50 4c 58				.text	3,$f4,"PLX"            ; $ad PLX
>bd7a	03 f5 50 4c 59				.text	3,$f5,"PLY"            ; $ae PLY
>bd7f	03 ed 52 4f 4c				.text	3,$ed,"ROL"            ; $af ROL
>bd84	03 f3 52 4f 52				.text	3,$f3,"ROR"            ; $b0 ROR
>bd89	03 ef 52 54 49				.text	3,$ef,"RTI"            ; $b1 RTI
>bd8e	03 f9 52 54 53				.text	3,$f9,"RTS"            ; $b2 RTS
>bd93	03 d8 53 42 43				.text	3,$d8,"SBC"            ; $b3 SBC
>bd98	03 db 53 45 43				.text	3,$db,"SEC"            ; $b4 SEC
>bd9d	03 dc 53 45 44				.text	3,$dc,"SED"            ; $b5 SED
>bda2	03 e1 53 45 49				.text	3,$e1,"SEI"            ; $b6 SEI
>bda7	03 e8 53 54 41				.text	3,$e8,"STA"            ; $b7 STA
>bdac	03 f7 53 54 50				.text	3,$f7,"STP"            ; $b8 STP
>bdb1	03 ff 53 54 58				.text	3,$ff,"STX"            ; $b9 STX
>bdb6	03 00 53 54 59				.text	3,$00,"STY"            ; $ba STY
>bdbb	03 01 53 54 5a				.text	3,$01,"STZ"            ; $bb STZ
>bdc0	03 ed 54 41 58				.text	3,$ed,"TAX"            ; $bc TAX
>bdc5	03 ee 54 41 59				.text	3,$ee,"TAY"            ; $bd TAY
>bdca	03 e8 54 52 42				.text	3,$e8,"TRB"            ; $be TRB
>bdcf	03 e9 54 53 42				.text	3,$e9,"TSB"            ; $bf TSB
>bdd4	03 ff 54 53 58				.text	3,$ff,"TSX"            ; $c0 TSX
>bdd9	03 ed 54 58 41				.text	3,$ed,"TXA"            ; $c1 TXA
>bdde	03 ff 54 58 53				.text	3,$ff,"TXS"            ; $c2 TXS
>bde3	03 ee 54 59 41				.text	3,$ee,"TYA"            ; $c3 TYA
>bde8	ff					.text	$FF
.b3e4					ListConvertLine:
.b3e4	48		pha				pha 								; save indent on the stack
.b3e5	9c 9d 04	stz $049d			stz 	tbOffset
.b3e8	9c ab 04	stz $04ab			stz 	tokenBuffer
.b3eb	a0 02		ldy #$02			ldy 	#2 							; convert line number to string
.b3ed	b1 30		lda ($30),y			lda 	(codePtr),y
.b3ef	aa		tax				tax
.b3f0	88		dey				dey
.b3f1	b1 30		lda ($30),y			lda 	(codePtr),y
.b3f3	20 7d 92	jsr $927d			jsr 	LCLConvertInt16
.b3f6	85 36		sta $36				sta 	zTemp0 						; copy number into buffer
.b3f8	86 37		stx $37				stx 	zTemp0+1
.b3fa	a9 8c		lda #$8c			lda 	#CLINumber+$80
.b3fc	20 41 b5	jsr $b541			jsr 	LCLWrite
.b3ff	a0 00		ldy #$00			ldy 	#0
.b401					_LCCopyNumber:
.b401	b1 36		lda ($36),y			lda 	(zTemp0),y
.b403	20 41 b5	jsr $b541			jsr 	LCLWrite
.b406	c8		iny				iny
.b407	b1 36		lda ($36),y			lda 	(zTemp0),y
.b409	d0 f6		bne $b401			bne 	_LCCopyNumber
.b40b	68		pla				pla 								; adjustment to indent
.b40c	48		pha				pha 								; save on stack
.b40d	10 0c		bpl $b41b			bpl 	_LCNoAdjust 				; don't adjust indent if +ve, do after.
.b40f	18		clc				clc 								; add to list indent and make 0 if goes -ve.
.b410	6d a6 04	adc $04a6			adc 	listIndent
.b413	8d a6 04	sta $04a6			sta 	listIndent
.b416	10 03		bpl $b41b			bpl 	_LCNoAdjust
.b418	9c a6 04	stz $04a6			stz 	listIndent
.b41b					_LCNoAdjust:
.b41b	18		clc				clc		 							; work out actual indent.
.b41c	ad a6 04	lda $04a6			lda 	listIndent
.b41f	0a		asl a				asl 	a
.b420	69 06		adc #$06			adc 	#6
.b422	85 36		sta $36				sta 	zTemp0
.b424					_LCPadOut:
.b424	a9 20		lda #$20			lda 	#' '						; pad out to 6 characters
.b426	20 41 b5	jsr $b541			jsr 	LCLWrite
.b429	ad 9d 04	lda $049d			lda 	tbOffset
.b42c	c5 36		cmp $36				cmp 	zTemp0
.b42e	d0 f4		bne $b424			bne 	_LCPadOut
.b430	a0 03		ldy #$03			ldy 	#3 							; start position.
.b432					_LCMainLoop:
.b432	a9 8a		lda #$8a			lda 	#CLIPunctuation+$80
.b434	20 41 b5	jsr $b541			jsr 	LCLWrite
.b437	b1 30		lda ($30),y			lda 	(codePtr),y
.b439	c9 80		cmp #$80			cmp 	#KWC_EOL 					; end of line ?
.b43b	f0 17		beq $b454			beq 	_LCExit
.b43d	c9 10		cmp #$10			cmp 	#16 						; 0-5 are the double punctuations
.b43f	90 1e		bcc $b45f			bcc 	_LCDoubles
.b441	c9 20		cmp #$20			cmp 	#32 						; 16-31 are shifted punctuation from 64-91
.b443	90 2a		bcc $b46f			bcc 	_LCShiftPunc
.b445	c9 40		cmp #$40			cmp 	#64 						; 32-64 are as stored, punc and digits
.b447	90 35		bcc $b47e			bcc 	_LCPunctuation
.b449	c9 80		cmp #$80			cmp 	#128 						; 64-127 are variable identifiers.
.b44b	90 3e		bcc $b48b			bcc 	_LCIdentifiers
.b44d	c9 fe		cmp #$fe			cmp 	#254 						; 128-253 are tokenised words
.b44f	90 5f		bcc $b4b0			bcc 	_LCTokens
.b451	4c 10 b5	jmp $b510			jmp 	_LCData 					; 254-5 are data objects
.b454					_LCExit:
.b454	68		pla				pla 								; get old indent adjust
.b455	30 07		bmi $b45e			bmi 	_LCExit2
.b457	18		clc				clc 								; add to indent if +ve
.b458	6d a6 04	adc $04a6			adc 	listIndent
.b45b	8d a6 04	sta $04a6			sta 	listIndent
.b45e					_LCExit2:
.b45e	60		rts				rts
.b45f					_LCDoubles:
.b45f	48		pha				pha
.b460	4a		lsr a				lsr 	a 							; put bit 2 into bit 1
.b461	29 02		and #$02			and 	#2
.b463	09 3c		ora #$3c			ora 	#60 						; make < >
.b465	20 41 b5	jsr $b541			jsr 	LCLWrite
.b468	68		pla				pla 								; restore, do lower bit
.b469	29 03		and #$03			and 	#3
.b46b	09 3c		ora #$3c			ora 	#60
.b46d	80 0f		bra $b47e			bra		_LCPunctuation 				; print, increment, loop
.b46f					_LCShiftPunc:
.b46f	aa		tax				tax 								; save in X
.b470	29 07		and #$07			and 	#7 							; lower 3 bits
.b472	f0 02		beq $b476			beq 	_LCNoAdd
.b474	09 18		ora #$18			ora 	#24 						; adds $18 to it.
.b476					_LCNoAdd:
.b476	e0 18		cpx #$18			cpx 	#24 						; if >= 24 add $20
.b478	90 02		bcc $b47c			bcc 	_LCNoAdd2
.b47a	09 20		ora #$20			ora 	#32 						; adds $20
.b47c					_LCNoAdd2:
.b47c	09 40		ora #$40			ora 	#$40 						; shift into 64-127 range and fall through.
.b47e					_LCPunctuation:
.b47e	c9 3a		cmp #$3a			cmp 	#':' 						; check if :
.b480	d0 03		bne $b485			bne 	_LCPContinue
.b482	20 57 b5	jsr $b557			jsr 	LCLDeleteLastSpace
.b485					_LCPContinue:
.b485	c8		iny				iny 								; consume character
.b486	20 41 b5	jsr $b541			jsr 	LCLWrite 					; write it out.
.b489	80 a7		bra $b432			bra 	_LCMainLoop 				; go round again.
.b48b					_LCIdentifiers:
.b48b	18		clc				clc 								; convert to physical address
.b48c	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.b48e	85 37		sta $37				sta 	zTemp0+1
.b490	c8		iny				iny
.b491	b1 30		lda ($30),y			lda 	(codePtr),y
.b493	85 36		sta $36				sta 	zTemp0
.b495	c8		iny				iny
.b496	5a		phy				phy 								; save position
.b497	a9 87		lda #$87			lda 	#CLIIdentifier+$80
.b499	20 41 b5	jsr $b541			jsr 	LCLWrite
.b49c	a0 07		ldy #$07			ldy 	#7 							; output the identifier.
.b49e					_LCOutIdentifier:
.b49e	c8		iny				iny
.b49f	b1 36		lda ($36),y			lda 	(zTemp0),y
.b4a1	29 7f		and #$7f			and 	#$7F
.b4a3	20 93 b5	jsr $b593			jsr 	LCLLowerCase
.b4a6	20 41 b5	jsr $b541			jsr 	LCLWrite
.b4a9	b1 36		lda ($36),y			lda 	(zTemp0),y				 	; ends when bit 7 set.
.b4ab	10 f1		bpl $b49e			bpl 	_LCOutIdentifier
.b4ad	7a		ply				ply 								; restore position
.b4ae	80 82		bra $b432			bra 	_LCMainLoop
.b4b0					_LCTokens:
.b4b0	aa		tax				tax 								; token in X
.b4b1	a9 9d		lda #$9d			lda 	#((KeywordSet2) & $FF)
.b4b3	85 36		sta $36				sta 	0+zTemp0
.b4b5	a9 bc		lda #$bc			lda 	#((KeywordSet2) >> 8)
.b4b7	85 37		sta $37				sta 	1+zTemp0
.b4b9	e0 82		cpx #$82			cpx 	#$82
.b4bb	f0 16		beq $b4d3			beq 	_LCUseShift
.b4bd	a9 4f		lda #$4f			lda 	#((KeywordSet1) & $FF)
.b4bf	85 36		sta $36				sta 	0+zTemp0
.b4c1	a9 bc		lda #$bc			lda 	#((KeywordSet1) >> 8)
.b4c3	85 37		sta $37				sta 	1+zTemp0
.b4c5	e0 81		cpx #$81			cpx 	#$81
.b4c7	f0 0a		beq $b4d3			beq 	_LCUseShift
.b4c9	a9 59		lda #$59			lda 	#((KeywordSet0) & $FF)
.b4cb	85 36		sta $36				sta 	0+zTemp0
.b4cd	a9 ba		lda #$ba			lda 	#((KeywordSet0) >> 8)
.b4cf	85 37		sta $37				sta 	1+zTemp0
.b4d1	80 01		bra $b4d4			bra 	_LCNoShift
.b4d3					_LCUseShift:
.b4d3	c8		iny				iny
.b4d4					_LCNoShift:
.b4d4	20 6b b5	jsr $b56b			jsr 	LCLCheckSpaceRequired 		; do we need a space ?
.b4d7	b1 30		lda ($30),y			lda 	(codePtr),y
.b4d9	aa		tax				tax 								; into X
.b4da					_LCFindText:
.b4da	ca		dex				dex
.b4db	10 0e		bpl $b4eb			bpl 	_LCFoundText 				; found text.
.b4dd	b2 36		lda ($36)			lda 	(zTemp0) 					; length of text
.b4df	1a		inc a				inc 	a 							; one extra for size
.b4e0	38		sec				sec 								; one extra for checksum
.b4e1	65 36		adc $36				adc 	zTemp0 						; go to next token
.b4e3	85 36		sta $36				sta 	zTemp0
.b4e5	90 f3		bcc $b4da			bcc 	_LCFindText
.b4e7	e6 37		inc $37				inc 	zTemp0+1
.b4e9	80 ef		bra $b4da			bra 	_LCFindText
.b4eb					_LCFoundText:
.b4eb	5a		phy				phy 								; save List position
.b4ec	b2 36		lda ($36)			lda 	(zTemp0)					; count to print
.b4ee	aa		tax				tax
.b4ef	a9 83		lda #$83			lda 	#CLIToken+$80
.b4f1	20 41 b5	jsr $b541			jsr 	LCLWrite
.b4f4	a0 02		ldy #$02			ldy 	#2
.b4f6					_LCCopyToken:
.b4f6	b1 36		lda ($36),y			lda 	(zTemp0),y
.b4f8	20 93 b5	jsr $b593			jsr 	LCLLowerCase
.b4fb	20 41 b5	jsr $b541			jsr 	LCLWrite
.b4fe	c8		iny				iny
.b4ff	ca		dex				dex
.b500	d0 f4		bne $b4f6			bne 	_LCCopyToken
.b502	c9 28		cmp #$28			cmp 	#"(" 						; if last char not ( print a space
.b504	f0 05		beq $b50b			beq 	_LCNoSpace
.b506	a9 20		lda #$20			lda 	#' '
.b508	20 41 b5	jsr $b541			jsr 	LCLWrite
.b50b					_LCNoSpace:
.b50b	7a		ply				ply 								; restore position.
.b50c	c8		iny				iny 								; consume token
.b50d	4c 32 b4	jmp $b432			jmp 	_LCMainLoop 				; and go around again.
.b510					_LCData:
.b510	48		pha				pha 								; save type $FE/$FF
.b511	a2 24		ldx #$24			ldx 	#'$' 						; figure out $ or "
.b513	c9 fe		cmp #$fe			cmp 	#$FE
.b515	f0 07		beq $b51e			beq 	_LCHaveOpener
.b517	a2 22		ldx #$22			ldx 	#'"'
.b519	a9 81		lda #$81			lda 	#CLIData+$80
.b51b	20 41 b5	jsr $b541			jsr 	LCLWrite
.b51e					_LCHaveOpener:
.b51e	8a		txa				txa 								; output prefix (# or ")
.b51f	20 41 b5	jsr $b541			jsr 	LCLWrite
.b522	c8		iny				iny 								; get count
.b523	b1 30		lda ($30),y			lda 	(codePtr),y
.b525	aa		tax				tax
.b526	c8		iny				iny 								; point at first character
.b527					_LCOutData:
.b527	b1 30		lda ($30),y			lda 	(codePtr),y
.b529	c9 00		cmp #$00			cmp 	#0
.b52b	f0 03		beq $b530			beq 	_LCNoPrint
.b52d	20 41 b5	jsr $b541			jsr 	LCLWrite
.b530					_LCNoPrint:
.b530	c8		iny				iny
.b531	ca		dex				dex
.b532	d0 f3		bne $b527			bne 	_LCOutData
.b534	68		pla				pla 								; closing " required ?
.b535	c9 ff		cmp #$ff			cmp 	#$FF
.b537	d0 05		bne $b53e			bne 	_LCNoQuote
.b539	a9 22		lda #$22			lda 	#'"'
.b53b	20 41 b5	jsr $b541			jsr 	LCLWrite
.b53e					_LCNoQuote:
.b53e	4c 32 b4	jmp $b432			jmp 	_LCMainLoop
.b541					LCLWrite:
.b541	da		phx				phx
.b542	ae 9d 04	ldx $049d			ldx 	tbOffset
.b545	9d ab 04	sta $04ab,x			sta 	tokenBuffer,x
.b548	9e ac 04	stz $04ac,x			stz 	tokenBuffer+1,x
.b54b	ee 9d 04	inc $049d			inc 	tbOffset
.b54e	09 00		ora #$00			ora 	#0 							; don't update if colour data
.b550	30 03		bmi $b555			bmi 	_LCLNoColour
.b552	8d a7 04	sta $04a7			sta 	LCLastCharacter
.b555					_LCLNoColour:
.b555	fa		plx				plx
.b556	60		rts				rts
.b557					LCLDeleteLastSpace:
.b557	48		pha				pha
.b558	da		phx				phx
.b559	ae 9d 04	ldx $049d			ldx 	tbOffset
.b55c	f0 0a		beq $b568			beq 	_LCDLSExit
.b55e	bd aa 04	lda $04aa,x			lda 	tokenBuffer-1,x
.b561	c9 20		cmp #$20			cmp 	#' '
.b563	d0 03		bne $b568			bne 	_LCDLSExit
.b565	ce 9d 04	dec $049d			dec 	tbOffset
.b568					_LCDLSExit:
.b568	fa		plx				plx
.b569	68		pla				pla
.b56a	60		rts				rts
.b56b					LCLCheckSpaceRequired:
.b56b	ad a7 04	lda $04a7			lda 	LCLastCharacter 			; check last character
.b56e	c9 24		cmp #$24			cmp 	#'$' 						; $ # and ) require that token space.
.b570	f0 1b		beq $b58d			beq 	_LCCSRSpace
.b572	c9 29		cmp #$29			cmp 	#')'
.b574	f0 17		beq $b58d			beq 	_LCCSRSpace
.b576	c9 23		cmp #$23			cmp 	#'#'
.b578	f0 13		beq $b58d			beq 	_LCCSRSpace
.b57a	20 93 b5	jsr $b593			jsr 	LCLLowerCase 				; saves a little effort
.b57d	c9 30		cmp #$30			cmp 	#"0" 						; check if it was 0-9 A-Z a-z if so need space.
.b57f	90 11		bcc $b592			bcc 	_LCCSRExit
.b581	c9 3a		cmp #$3a			cmp 	#"9"+1
.b583	90 08		bcc $b58d			bcc 	_LCCSRSpace
.b585	c9 61		cmp #$61			cmp 	#"a"
.b587	90 09		bcc $b592			bcc 	_LCCSRExit
.b589	c9 7b		cmp #$7b			cmp 	#"z"+1
.b58b	b0 05		bcs $b592			bcs 	_LCCSRExit
.b58d					_LCCSRSpace:
.b58d	a9 20		lda #$20			lda 	#' '
.b58f	20 41 b5	jsr $b541			jsr 	LCLWrite
.b592					_LCCSRExit:
.b592	60		rts				rts
.b593					LCLLowerCase:
.b593	c9 41		cmp #$41			cmp 	#"A"
.b595	90 06		bcc $b59d			bcc 	_LCLLCOut
.b597	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b599	b0 02		bcs $b59d			bcs 	_LCLLCOut
.b59b	69 20		adc #$20			adc 	#$20
.b59d					_LCLLCOut:
.b59d	60		rts				rts
.b59e					LCLUpperCase:
.b59e	c9 61		cmp #$61			cmp 	#"a"
.b5a0	90 06		bcc $b5a8			bcc 	_LCLUCOut
.b5a2	c9 7b		cmp #$7b			cmp 	#"z"+1
.b5a4	b0 02		bcs $b5a8			bcs 	_LCLUCOut
.b5a6	e9 1f		sbc #$1f			sbc 	#$1F
.b5a8					_LCLUCOut:
.b5a8	60		rts				rts
.b5a9					TOKSearchTable:
.b5a9	84 37		sty $37				sty 	zTemp0+1 					; (zTemp0),y points to current token.
.b5ab	85 36		sta $36				sta 	zTemp0
.b5ad	a0 00		ldy #$00			ldy 	#0
.b5af	a9 80		lda #$80			lda 	#$80 						; token #
.b5b1	85 38		sta $38				sta 	zTemp1
.b5b3					_TSTLoop:
.b5b3	b1 36		lda ($36),y			lda 	(zTemp0),y 					; length, 0 (skip) -ve (end)
.b5b5	30 49		bmi $b600			bmi 	_TSTFail 					; -ve = end of table
.b5b7	f0 2e		beq $b5e7			beq 	_TSTNext 					; zero, check next it's a dummy
.b5b9	c8		iny				iny 								; get the hash
.b5ba	b1 36		lda ($36),y			lda 	(zTemp0),y
.b5bc	88		dey				dey
.b5bd	cd 83 04	cmp $0483			cmp 	identHash 					; check they match, if not go to next
.b5c0	d0 25		bne $b5e7			bne 	_TSTNext
.b5c2	ad 82 04	lda $0482			lda 	identTypeEnd 				; length of identifier
.b5c5	38		sec				sec
.b5c6	ed 80 04	sbc $0480			sbc 	identStart
.b5c9	d1 36		cmp ($36),y			cmp 	(zTemp0),y 					; no match, then return.
.b5cb	d0 1a		bne $b5e7			bne 	_TSTNext
.b5cd	5a		phy				phy 								; save Y , we might fail
.b5ce	c8		iny				iny 								; point to text
.b5cf	c8		iny				iny
.b5d0	ae 80 04	ldx $0480			ldx 	identStart 					; offset in line buffer in X
.b5d3					_TSTCompareName:
.b5d3	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; compare text.
.b5d6	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.b5d8	d0 0c		bne $b5e6			bne 	_TSTNextPullY 				; fail, pullY and do next
.b5da	e8		inx				inx
.b5db	c8		iny				iny
.b5dc	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; complete match.
.b5df	d0 f2		bne $b5d3			bne 	_TSTCompareName
.b5e1	7a		ply				ply 								; throw Y
.b5e2	a5 38		lda $38				lda 	zTemp1 						; get token #
.b5e4	38		sec				sec 								; return with CS = passed.
.b5e5	60		rts				rts
.b5e6					_TSTNextPullY:
.b5e6	7a		ply				ply 								; restore current, fall through.
.b5e7					_TSTNext:
.b5e7	e6 38		inc $38				inc 	zTemp1 						; token counter
.b5e9	98		tya				tya
.b5ea	18		clc				clc
.b5eb	71 36		adc ($36),y			adc 	(zTemp0),y 					; add [Length] + 2 to Y
.b5ed	1a		inc a				inc 	a 							; +1
.b5ee	1a		inc a				inc 	a 							; +2
.b5ef	a8		tay				tay
.b5f0	10 c1		bpl $b5b3			bpl 	_TSTLoop 					; if Y < $80 loop back
.b5f2	98		tya				tya 								; add Y to zTemp0 and reset Y
.b5f3	a0 00		ldy #$00			ldy 	#0   						; so we can use Y to search fast
.b5f5	18		clc				clc  								; but have tables > 255 bytes
.b5f6	65 36		adc $36				adc 	zTemp0 						; when Y gets >= 128 we reset Y
.b5f8	85 36		sta $36				sta 	zTemp0 						; and adjust the table pointer/
.b5fa	90 b7		bcc $b5b3			bcc 	_TSTLoop
.b5fc	e6 37		inc $37				inc 	zTemp0+1
.b5fe	80 b3		bra $b5b3			bra 	_TSTLoop
.b600					_TSTFail:
.b600	18		clc				clc
.b601	60		rts				rts
.b602					TokeniseLine:
.b602	20 8a b7	jsr $b78a			jsr 	LCLFixLineBufferCase 		; fix line case
.b605	a9 03		lda #$03			lda 	#3 							; reset the token buffer to empty
.b607	8d a8 04	sta $04a8			sta 	tokenOffset
.b60a	9c a9 04	stz $04a9			stz 	tokenLineNumber
.b60d	9c aa 04	stz $04aa			stz 	tokenLineNumber+1
.b610	a2 ff		ldx #$ff			ldx 	#$FF
.b612					_TKFindFirst:
.b612	e8		inx				inx
.b613	bd a8 05	lda $05a8,x			lda 	lineBuffer,x
.b616	f0 79		beq $b691			beq 	_TKExit
.b618	c9 20		cmp #$20			cmp 	#' '
.b61a	90 f6		bcc $b612			bcc 	_TKFindFirst
.b61c	c9 30		cmp #$30			cmp 	#'0'
.b61e	90 07		bcc $b627			bcc 	_TKNoLineNumber
.b620	c9 3a		cmp #$3a			cmp 	#'9'+1
.b622	b0 03		bcs $b627			bcs 	_TKNoLineNumber
.b624	20 b4 b7	jsr $b7b4			jsr 	TOKExtractLineNumber
.b627					_TKNoLineNumber:
.b627					_TKTokeniseLoop:
.b627	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; next character, exit if zero EOL.
.b62a	f0 65		beq $b691			beq 	_TKExit
.b62c	e8		inx				inx
.b62d	c9 20		cmp #$20			cmp 	#' '
.b62f	f0 f6		beq $b627			beq 	_TKTokeniseLoop 			; keep looping if space found.
.b631	ca		dex				dex 								; undo last get, A contains character, X is position.
.b632	c9 5f		cmp #$5f			cmp 	#'_'						; _ A-Z is identifier *or* token
.b634	f0 61		beq $b697			beq 	_TKTokeniseIdentifier
.b636	c9 41		cmp #$41			cmp 	#'A'
.b638	90 04		bcc $b63e			bcc 	_TKTokenisePunctuation
.b63a	c9 5b		cmp #$5b			cmp 	#'Z'+1
.b63c	90 59		bcc $b697			bcc 	_TKTokeniseIdentifier
.b63e					_TKTokenisePunctuation:
.b63e	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.b640	f0 27		beq $b669			beq 	_TKString
.b642	c9 24		cmp #$24			cmp 	#'$'						; hexadecimal constant (# only appears at end of identifiers)
.b644	f0 28		beq $b66e			beq 	_TKHexConstant
.b646	c9 3c		cmp #$3c			cmp 	#'<' 						; check for < > handlers.
.b648	f0 29		beq $b673			beq 	_TKCheckDouble
.b64a	c9 3e		cmp #$3e			cmp 	#'>'
.b64c	f0 25		beq $b673			beq 	_TKCheckDouble
.b64e					_TKStandardPunctuation:
.b64e	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; get it back.
.b651	c9 40		cmp #$40			cmp 	#64 						; are we >= 64
.b653	90 0e		bcc $b663			bcc 	_TKNoShift
.b655	48		pha				pha 								; save
.b656	29 07		and #$07			and 	#7 							; lower 3 bits in zTemp0
.b658	85 36		sta $36				sta 	zTemp0
.b65a	68		pla				pla
.b65b	29 20		and #$20			and 	#32 						; bit 5
.b65d	4a		lsr a				lsr 	a 							; shift into bit 3
.b65e	4a		lsr a				lsr 	a
.b65f	05 36		ora $36				ora 	zTemp0
.b661	09 10		ora #$10			ora 	#$10						; now in the range 16-31
.b663					_TKNoShift:
.b663	20 f9 b7	jsr $b7f9			jsr 	TOKWriteByte 				; write the punctuation character
.b666	e8		inx				inx 								; consume the character
.b667	80 be		bra $b627			bra 	_TKTokeniseLoop 			; and loop round again.
.b669					_TKString:
.b669	20 19 b7	jsr $b719			jsr 	TOKTokenString
.b66c	80 b9		bra $b627			bra 	_TKTokeniseLoop
.b66e					_TKHexConstant:
.b66e	20 54 b7	jsr $b754			jsr 	TOKHexConstant
.b671	80 b4		bra $b627			bra 	_TKTokeniseLoop
.b673					_TKCheckDouble:
.b673	bd a9 05	lda $05a9,x			lda 	lineBuffer+1,x 				; get next character
.b676	c9 3c		cmp #$3c			cmp 	#'<'						; if not < = > which are ASCII consecutive go back
.b678	90 d4		bcc $b64e			bcc 	_TKStandardPunctuation
.b67a	c9 3f		cmp #$3f			cmp 	#'>'+1
.b67c	b0 d0		bcs $b64e			bcs 	_TKStandardPunctuation
.b67e	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; this is < (60) or > (62)
.b681	29 02		and #$02			and 	#2 							; now < (0) or > (2)
.b683	0a		asl a				asl 	a 							; now < (0) or > (4), CC also
.b684	7d a9 05	adc $05a9,x			adc 	lineBuffer+1,x 				; add < = > codes - < code
.b687	38		sec				sec
.b688	e9 3c		sbc #$3c			sbc 	#'<'
.b68a	20 f9 b7	jsr $b7f9			jsr 	TOKWriteByte 				; this is in the range 0-7
.b68d	e8		inx				inx 								; consume both
.b68e	e8		inx				inx
.b68f	80 96		bra $b627			bra 	_TKTokeniseLoop
.b691	a9 80		lda #$80	_TKExit:lda 	#KWC_EOL 					; write end of line byte
.b693	20 f9 b7	jsr $b7f9			jsr 	TOKWriteByte
.b696	60		rts				rts
.b697					_TKTokeniseIdentifier:
.b697	8e 80 04	stx $0480			stx 	identStart 					; save start
.b69a	9c 84 04	stz $0484			stz 	identTypeByte 				; zero the type byte
.b69d					_TKCheckLoop:
.b69d	e8		inx				inx 								; look at next, we know first is identifier.
.b69e	bd a8 05	lda $05a8,x			lda  	lineBuffer,x
.b6a1	c9 5f		cmp #$5f			cmp 	#"_" 						; legal char _ 0-9 A-Z
.b6a3	f0 f8		beq $b69d			beq 	_TKCheckLoop
.b6a5	c9 30		cmp #$30			cmp	 	#"0"
.b6a7	90 0c		bcc $b6b5			bcc 	_TKEndIdentifier
.b6a9	c9 3a		cmp #$3a			cmp 	#"9"+1
.b6ab	90 f0		bcc $b69d			bcc 	_TKCheckLoop
.b6ad	c9 41		cmp #$41			cmp	 	#"A"
.b6af	90 04		bcc $b6b5			bcc 	_TKEndIdentifier
.b6b1	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b6b3	90 e8		bcc $b69d			bcc 	_TKCheckLoop
.b6b5					_TKEndIdentifier:
.b6b5	8e 81 04	stx $0481			stx 	identTypeStart 				; save start of type text (if any !)
.b6b8	a0 08		ldy #$08			ldy 	#$08 						; this is the identifier type byte for #
.b6ba	c9 23		cmp #$23			cmp 	#"#"						; followed by #
.b6bc	f0 06		beq $b6c4			beq 	_TKHasTypeCharacter
.b6be	a0 10		ldy #$10			ldy 	#$10 						; this is the identifier type byte for $
.b6c0	c9 24		cmp #$24			cmp 	#"$"						; followed by $ or #
.b6c2	d0 07		bne $b6cb			bne 	_TKNoTypeCharacter
.b6c4					_TKHasTypeCharacter:
.b6c4	8c 84 04	sty $0484			sty 	identTypeByte 				; has # or $, save the type
.b6c7	e8		inx				inx 								; read next
.b6c8	bd a8 05	lda $05a8,x			lda 	lineBuffer,x
.b6cb					_TKNoTypeCharacter:
.b6cb	c9 28		cmp #$28			cmp 	#"("						; is it open parenthesis (e.g. array)
.b6cd	d0 09		bne $b6d8			bne 	_TKNoArray
.b6cf	e8		inx				inx 								; skip the (
.b6d0	ad 84 04	lda $0484			lda 	identTypeByte 				; set bit 2 (e.g. array)
.b6d3	09 04		ora #$04			ora 	#$04
.b6d5	8d 84 04	sta $0484			sta 	identTypeByte
.b6d8					_TKNoArray:
.b6d8	8e 82 04	stx $0482			stx 	identTypeEnd 				; save end marker, e.g. continue from here.
.b6db	20 75 b7	jsr $b775			jsr 	TOKCalculateHash 			; calculate the has for those tokens
.b6de	a0 ba		ldy #$ba			ldy 	#(KeywordSet0) >> 8
.b6e0	a9 59		lda #$59			lda 	#(KeywordSet0) & $FF
.b6e2	20 a9 b5	jsr $b5a9			jsr 	TOKSearchTable
.b6e5	a2 00		ldx #$00			ldx 	#0
.b6e7	b0 1f		bcs $b708			bcs 	_TKFoundToken
.b6e9	a0 bc		ldy #$bc			ldy 	#(KeywordSet1) >> 8
.b6eb	a9 4f		lda #$4f			lda 	#(KeywordSet1) & $FF
.b6ed	20 a9 b5	jsr $b5a9			jsr 	TOKSearchTable
.b6f0	a2 81		ldx #$81			ldx 	#$81
.b6f2	b0 14		bcs $b708			bcs 	_TKFoundToken
.b6f4	a0 bc		ldy #$bc			ldy 	#(KeywordSet2) >> 8
.b6f6	a9 9d		lda #$9d			lda 	#(KeywordSet2) & $FF
.b6f8	20 a9 b5	jsr $b5a9			jsr 	TOKSearchTable
.b6fb	a2 82		ldx #$82			ldx 	#$82
.b6fd	b0 09		bcs $b708			bcs 	_TKFoundToken
.b6ff	20 05 b8	jsr $b805			jsr 	TOKCheckCreateVariableRecord ; failed all, it's a variable, create record if does not exist.
.b702	ae 82 04	ldx $0482			ldx 	identTypeEnd 				; X points to following byte
.b705	4c 27 b6	jmp $b627			jmp 	_TKTokeniseLoop 			; and go round again.
.b708					_TKFoundToken:
.b708	48		pha				pha 								; save token
.b709	8a		txa				txa 								; shift in X, is there one ?
.b70a	f0 03		beq $b70f			beq 	_TKNoTShift
.b70c	20 f9 b7	jsr $b7f9			jsr 	TOKWriteByte 				; if so, write it out
.b70f					_TKNoTShift:
.b70f	68		pla				pla 								; restore and write token
.b710	20 f9 b7	jsr $b7f9			jsr 	TOKWriteByte
.b713	ae 82 04	ldx $0482			ldx 	identTypeEnd 				; X points to following byte
.b716	4c 27 b6	jmp $b627			jmp 	_TKTokeniseLoop 			; and go round again.
.b719					TOKTokenString:
.b719	a9 ff		lda #$ff			lda 	#KWC_STRING 				; string token.
.b71b	20 f9 b7	jsr $b7f9			jsr 	TOKWriteByte
.b71e	e8		inx				inx									; start of quoted string.
.b71f	da		phx				phx 								; push start of string on top
.b720	ca		dex				dex
.b721					_TSFindEnd:
.b721	e8		inx				inx
.b722	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; next character
.b725	f0 04		beq $b72b			beq 	_TSEndOfString
.b727	c9 22		cmp #$22			cmp 	#'"'
.b729	d0 f6		bne $b721			bne 	_TSFindEnd
.b72b					_TSEndOfString:
.b72b	7a		ply				ply  								; so now Y is first character, X is character after end.
.b72c	48		pha				pha 								; save terminating character
.b72d	20 35 b7	jsr $b735			jsr 	TOKWriteBlockXY 			; write X to Y as a data block
.b730	68		pla				pla 								; terminating character
.b731	f0 01		beq $b734			beq 	_TSNotQuote					; if it wasn't EOS skip it
.b733	e8		inx				inx
.b734					_TSNotQuote:
.b734	60		rts				rts
.b735					TOKWriteBlockXY:
.b735	86 36		stx $36				stx 	zTemp0 						; write end character
.b737	98		tya				tya
.b738	49 ff		eor #$ff			eor 	#$FF
.b73a	38		sec				sec
.b73b	65 36		adc $36				adc 	zTemp0
.b73d	1a		inc a				inc 	a 							; one extra for NULL
.b73e	20 f9 b7	jsr $b7f9			jsr 	TOKWriteByte
.b741					_TOBlockLoop:
.b741	c4 36		cpy $36				cpy 	zTemp0
.b743	f0 09		beq $b74e			beq 	_TOBlockExit
.b745	b9 a8 05	lda $05a8,y			lda 	lineBuffer,y
.b748	20 f9 b7	jsr $b7f9			jsr 	TOKWriteByte
.b74b	c8		iny				iny
.b74c	80 f3		bra $b741			bra 	_TOBlockLoop
.b74e					_TOBlockExit:
.b74e	a9 00		lda #$00			lda 	#0
.b750	20 f9 b7	jsr $b7f9			jsr 	TOKWriteByte
.b753	60		rts				rts
.b754					TOKHexConstant:
.b754	a9 fe		lda #$fe			lda 	#KWC_HEXCONST 				; hex constant token.
.b756	20 f9 b7	jsr $b7f9			jsr 	TOKWriteByte
.b759	e8		inx				inx									; start of quoted string.
.b75a	da		phx				phx 								; push start of constant on top
.b75b	ca		dex				dex
.b75c					_THFindLoop:
.b75c	e8		inx				inx
.b75d	bd a8 05	lda $05a8,x			lda 	lineBuffer,x
.b760	c9 30		cmp #$30			cmp 	#"0"
.b762	90 0c		bcc $b770			bcc 	_THFoundEnd
.b764	c9 3a		cmp #$3a			cmp 	#"9"+1
.b766	90 f4		bcc $b75c			bcc 	_THFindLoop
.b768	c9 41		cmp #$41			cmp 	#"A"
.b76a	90 04		bcc $b770			bcc 	_THFoundEnd
.b76c	c9 47		cmp #$47			cmp 	#"F"+1
.b76e	90 ec		bcc $b75c			bcc 	_THFindLoop
.b770					_THFoundEnd:
.b770	7a		ply				ply 								; restore start
.b771	20 35 b7	jsr $b735			jsr 	TOKWriteBlockXY 			; output the block
.b774	60		rts				rts
.b775					TOKCalculateHash:
.b775	da		phx				phx
.b776	ae 80 04	ldx $0480			ldx 	identStart 					; needs to be same as in tokens.py - simple sum
.b779	a9 00		lda #$00			lda 	#0
.b77b					_TCHLoop:
.b77b	18		clc				clc
.b77c	7d a8 05	adc $05a8,x			adc 	lineBuffer,x
.b77f	e8		inx				inx
.b780	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; do the whole thing including type and array markers.
.b783	d0 f6		bne $b77b			bne 	_TCHLoop
.b785	8d 83 04	sta $0483			sta 	identHash 					; save the hash
.b788	fa		plx				plx
.b789	60		rts				rts
.b78a					LCLFixLineBufferCase:
.b78a	a2 00		ldx #$00			ldx 	#0
.b78c					_FLBCLoop:
.b78c	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; get next character
.b78f	f0 22		beq $b7b3			beq 	_FLBCExit 					; end of string.
.b791	c9 22		cmp #$22			cmp 	#'"'						; quote, go to in quotes
.b793	f0 11		beq $b7a6			beq 	_FLBCInQuotes
.b795	e8		inx				inx
.b796	c9 61		cmp #$61			cmp 	#'a'						; needs capitalising ?
.b798	90 f2		bcc $b78c			bcc 	_FLBCLoop
.b79a	c9 7b		cmp #$7b			cmp 	#'z'+1
.b79c	b0 ee		bcs $b78c			bcs 	_FLBCLoop
.b79e	38		sec				sec 								; make U/C
.b79f	e9 20		sbc #$20			sbc 	#32
.b7a1	9d a7 05	sta $05a7,x			sta	 	lineBuffer-1,x 				; write back
.b7a4	80 e6		bra $b78c			bra 	_FLBCLoop
.b7a6					_FLBCInQuotes:
.b7a6	e8		inx				inx 								; advance
.b7a7	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; get next
.b7aa	f0 07		beq $b7b3			beq 	_FLBCExit 					; exit on EOS
.b7ac	c9 22		cmp #$22			cmp 	#'"' 				 		; until " found
.b7ae	d0 f6		bne $b7a6			bne 	_FLBCInQuotes
.b7b0	e8		inx				inx 								; skip over it
.b7b1	80 d9		bra $b78c			bra 	_FLBCLoop
.b7b3					_FLBCExit:
.b7b3	60		rts				rts
.b7b4					TOKExtractLineNumber:
.b7b4	ad aa 04	lda $04aa			lda 	tokenLineNumber+1 			; push current value on stack
.b7b7	48		pha				pha
.b7b8	ad a9 04	lda $04a9			lda 	tokenLineNumber
.b7bb	48		pha				pha
.b7bc	20 f2 b7	jsr $b7f2			jsr 	_LCLNTimes2 				; line # x 4
.b7bf	20 f2 b7	jsr $b7f2			jsr 	_LCLNTimes2 				; line # x 2
.b7c2	18		clc				clc 								; add stacked value
.b7c3	68		pla				pla
.b7c4	6d a9 04	adc $04a9			adc 	tokenLineNumber
.b7c7	8d a9 04	sta $04a9			sta 	tokenLineNumber
.b7ca	68		pla				pla
.b7cb	6d aa 04	adc $04aa			adc 	tokenLineNumber+1
.b7ce	8d aa 04	sta $04aa			sta 	tokenLineNumber+1 			; line # x 5
.b7d1	20 f2 b7	jsr $b7f2			jsr 	_LCLNTimes2 				; line # x 10
.b7d4	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; get and consume character
.b7d7	e8		inx				inx
.b7d8	29 0f		and #$0f			and 	#15 						; add to line #
.b7da	18		clc				clc
.b7db	6d a9 04	adc $04a9			adc 	tokenLineNumber
.b7de	8d a9 04	sta $04a9			sta 	tokenLineNumber
.b7e1	90 03		bcc $b7e6			bcc 	_TLENNoCarry
.b7e3	ee aa 04	inc $04aa			inc 	tokenLineNumber+1
.b7e6					_TLENNoCarry:
.b7e6	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; more digits ?
.b7e9	c9 30		cmp #$30			cmp 	#'0'
.b7eb	90 04		bcc $b7f1			bcc 	_TLENExit
.b7ed	c9 3a		cmp #$3a			cmp 	#'9'+1
.b7ef	90 c3		bcc $b7b4			bcc 	TOKExtractLineNumber
.b7f1					_TLENExit:
.b7f1	60		rts				rts
.b7f2					_LCLNTimes2:
.b7f2	0e a9 04	asl $04a9			asl 	tokenLineNumber
.b7f5	2e aa 04	rol $04aa			rol 	tokenLineNumber+1
.b7f8	60		rts				rts
.b7f9					TOKWriteByte:
.b7f9	da		phx				phx
.b7fa	ae a8 04	ldx $04a8			ldx 	tokenOffset 				; next slot to write to
.b7fd	9d a8 04	sta $04a8,x			sta 	tokenOffset,x 				; write byte out
.b800	ee a8 04	inc $04a8			inc 	tokenOffset 				; advance slot.
.b803	fa		plx				plx
.b804	60		rts				rts
.b805					TOKCheckCreateVariableRecord:
.b805	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.b807	85 36		sta $36				sta 	0+zTemp0
.b809	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.b80b	85 37		sta $37				sta 	1+zTemp0
.b80d					_CCVSearch:
.b80d	b2 36		lda ($36)			lda 	(zTemp0) 					; end of list
.b80f	f0 2c		beq $b83d			beq 	_CCVFail
.b811	a0 01		ldy #$01			ldy 	#1 							; read the hash
.b813	b1 36		lda ($36),y			lda 	(zTemp0),y 					; does it match ?
.b815	cd 83 04	cmp $0483			cmp 	identHash
.b818	d0 16		bne $b830			bne 	_CCVNext
.b81a	a0 08		ldy #$08			ldy 	#8 							; name in variable record
.b81c	ae 80 04	ldx $0480			ldx 	identStart
.b81f					_CCVCompare:
.b81f	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; xor them. zero if the same, except
.b822	51 36		eor ($36),y			eor 	(zTemp0),y 					; bit 7 is used for EOS.
.b824	e8		inx				inx 								; advance pointers
.b825	c8		iny				iny
.b826	0a		asl a				asl 	a 							; A = 0 if they match, CS if end.
.b827	d0 07		bne $b830			bne 	_CCVNext  					; didn't match go to next.
.b829	90 f4		bcc $b81f			bcc 	_CCVCompare 				; not finished yet.
.b82b	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; matched whole thing ?
.b82e	f0 41		beq $b871			beq 	_CCVFound 					; yes, we were successful
.b830					_CCVNext:
.b830	18		clc				clc
.b831	b2 36		lda ($36)			lda 	(zTemp0) 					; add offset to pointer
.b833	65 36		adc $36				adc 	zTemp0
.b835	85 36		sta $36				sta 	zTemp0
.b837	90 d4		bcc $b80d			bcc 	_CCVSearch
.b839	e6 37		inc $37				inc 	zTemp0+1
.b83b	80 d0		bra $b80d			bra 	_CCVSearch
.b83d					_CCVFail:
.b83d	a0 01		ldy #$01			ldy 	#1 							; create the new record. Offset 1 is hash
.b83f	ad 83 04	lda $0483			lda 	identHash
.b842	91 36		sta ($36),y			sta 	(zTemp0),y
.b844	c8		iny				iny 								; offset 2 is the type byte
.b845	ad 84 04	lda $0484			lda 	identTypeByte
.b848	91 36		sta ($36),y			sta 	(zTemp0),y
.b84a	c8		iny				iny
.b84b					_CCVData:
.b84b	a9 00		lda #$00			lda 	#0 							; erase data 3-7
.b84d	91 36		sta ($36),y			sta 	(zTemp0),y
.b84f	c8		iny				iny
.b850	c0 08		cpy #$08			cpy 	#8
.b852	90 f7		bcc $b84b			bcc 	_CCVData
.b854	ae 80 04	ldx $0480			ldx 	identStart 					; copy name into 8 on.
.b857					_CCVCopyName:
.b857	bd a8 05	lda $05a8,x			lda 	lineBuffer,x
.b85a	91 36		sta ($36),y			sta 	(zTemp0),y
.b85c	e8		inx				inx
.b85d	c8		iny				iny
.b85e	ec 82 04	cpx $0482			cpx 	identTypeEnd
.b861	d0 f4		bne $b857			bne 	_CCVCopyName
.b863	98		tya				tya 								; patch offset
.b864	92 36		sta ($36)			sta 	(zTemp0)
.b866	a9 00		lda #$00			lda 	#0 							; offset for next is zero.
.b868	91 36		sta ($36),y			sta 	(zTemp0),y
.b86a	88		dey				dey
.b86b	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set bit 7 of last bit
.b86d	09 80		ora #$80			ora 	#$80
.b86f	91 36		sta ($36),y			sta 	(zTemp0),y
.b871					_CCVFound:
.b871	a5 37		lda $37				lda 	zTemp0+1 					; write out MSB
.b873	38		sec				sec
.b874	e9 10		sbc #$10			sbc 	#(VariableSpace >> 8) 		; offset from the start
.b876	09 40		ora #$40			ora 	#$40 						; make it a writeable token
.b878	20 f9 b7	jsr $b7f9			jsr 	TOKWriteByte
.b87b	a5 36		lda $36				lda 	zTemp0 						; write out LSB
.b87d	20 f9 b7	jsr $b7f9			jsr 	TOKWriteByte
.b880	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_sound.module

=1					soundIntegrated=1
.b881					SNDCheckChannel:
.b881	aa		tax				tax
.b882	bd 09 08	lda $0809,x			lda 	SNDTimeLeft,x 				; currently playing a note
.b885	d0 38		bne $b8bf			bne 	_SNDCCExit
.b887	da		phx				phx 								; save current channel
.b888	8a		txa				txa 								; put in A
.b889	20 05 b9	jsr $b905			jsr 	SNDFindNextNoteForA 		; is there a note for A in the queue ?
.b88c	68		pla				pla 								; channel # in A
.b88d	90 30		bcc $b8bf			bcc 	_SNDCCExit  				; nothing in the queue for this channel, exit.
.b88f	a8		tay				tay 								; Y is the channel #
.b890	bd fe 06	lda $06fe,x			lda 	SNDQueue+1,x 				; copy data into the slot.
.b893	99 fd 07	sta $07fd,y			sta 	SNDPitchLow,y
.b896	bd ff 06	lda $06ff,x			lda 	SNDQueue+2,x
.b899	99 01 08	sta $0801,y			sta 	SNDPitchHigh,y
.b89c	bd 00 07	lda $0700,x			lda 	SNDQueue+3,x
.b89f	99 05 08	sta $0805,y			sta 	SNDVolume,y
.b8a2	bd 01 07	lda $0701,x			lda 	SNDQueue+4,x
.b8a5	99 09 08	sta $0809,y			sta 	SNDTimeLeft,y
.b8a8	bd 02 07	lda $0702,x			lda 	SNDQueue+5,x
.b8ab	99 0d 08	sta $080d,y			sta 	SNDAdjustLow,y
.b8ae	bd 03 07	lda $0703,x			lda 	SNDQueue+6,x
.b8b1	99 11 08	sta $0811,y			sta 	SNDAdjustHigh,y
.b8b4	5a		phy				phy 								; save channel #
.b8b5	20 1f b9	jsr $b91f			jsr 	SNDDeleteXFromQueue 		; delete record at X from queue
.b8b8	ce fc 06	dec $06fc			dec 	SNDLength 					; reduce the queue length.
.b8bb	68		pla				pla
.b8bc	20 c0 b8	jsr $b8c0			jsr 	SNDUpdateNote 				; update channel A
.b8bf					_SNDCCExit:
.b8bf	60		rts				rts
.b8c0					SNDUpdateNote:
.b8c0	aa		tax				tax 								; so we can access records
.b8c1	0a		asl a				asl 	a 							; convert it to a channel bit pair in 5,6
.b8c2	0a		asl a				asl 	a
.b8c3	0a		asl a				asl 	a
.b8c4	0a		asl a				asl 	a
.b8c5	0a		asl a				asl 	a
.b8c6	8d fb 06	sta $06fb			sta 	SNDChannelBits
.b8c9	bd 09 08	lda $0809,x			lda 	SNDTimeLeft,x 				; are we silent
.b8cc	f0 2e		beq $b8fc			beq 	_SNDUNIsSilent
.b8ce	ad fb 06	lda $06fb			lda 	SNDChannelBits 				; push channel bits on stack
.b8d1	48		pha				pha
.b8d2	bd fd 07	lda $07fd,x			lda 	SNDPitchLow,x 				; get 4 lowest bits of pitch.
.b8d5	29 0f		and #$0f			and 	#$0F
.b8d7	0d fb 06	ora $06fb			ora 	SNDChannelBits 				; set channel bits
.b8da	09 80		ora #$80			ora 	#$80 						; write to pitch register
.b8dc	20 69 b9	jsr $b969			jsr 	SNDWritePorts
.b8df	bd 01 08	lda $0801,x			lda 	SNDPitchHigh,x 				; pitch high => channel temp.
.b8e2	8d fb 06	sta $06fb			sta 	SNDChannelBits
.b8e5	bd fd 07	lda $07fd,x			lda 	SNDPitchLow,x
.b8e8	4e fb 06	lsr $06fb			lsr 	SNDChannelBits 				; shift 2 LSBs into MSB of A
.b8eb	6a		ror a				ror 	a
.b8ec	4e fb 06	lsr $06fb			lsr 	SNDChannelBits
.b8ef	6a		ror a				ror 	a
.b8f0	4a		lsr a				lsr 	a 							; put in bits 0-5
.b8f1	4a		lsr a				lsr 	a
.b8f2	20 69 b9	jsr $b969			jsr 	SNDWritePorts 				; write as rest of pitch register
.b8f5	68		pla				pla
.b8f6	09 90		ora #$90			ora 	#$90 						; set to write minimum attentuation.
.b8f8	20 69 b9	jsr $b969			jsr 	SNDWritePorts
.b8fb	60		rts				rts
.b8fc					_SNDUNIsSilent:
.b8fc	ad fb 06	lda $06fb			lda 	SNDChannelBits 				; channel bits
.b8ff	09 9f		ora #$9f			ora 	#$9F 						; maximum attenuation
.b901	20 69 b9	jsr $b969			jsr 	SNDWritePorts 				; write to the ports
.b904	60		rts				rts
.b905					SNDFindNextNoteForA:
.b905	ac fc 06	ldy $06fc			ldy 	SNDLength 					; queue size into Y
.b908	f0 13		beq $b91d			beq 	_SNDFNNFail 				; queue empty.
.b90a	a2 00		ldx #$00			ldx 	#0
.b90c					_SNDFNNSearch:
.b90c	dd fd 06	cmp $06fd,x			cmp 	SNDQueue,x 					; does it match the channel
.b90f	38		sec				sec
.b910	f0 0c		beq $b91e			beq 	_SNDFNNExit 				; if so exit with CS.
.b912	e8		inx				inx 								; next queue slot.
.b913	e8		inx				inx
.b914	e8		inx				inx
.b915	e8		inx				inx
.b916	e8		inx				inx
.b917	e8		inx				inx
.b918	e8		inx				inx
.b919	e8		inx				inx
.b91a	88		dey				dey 								; done the whole queue
.b91b	d0 ef		bne $b90c			bne 	_SNDFNNSearch 				; no, go back.
.b91d					_SNDFNNFail:
.b91d	18		clc				clc
.b91e					_SNDFNNexit:
.b91e	60		rts				rts
.b91f					SNDDeleteXFromQueue:
.b91f	e0 f8		cpx #$f8			cpx 	#SNDQueueSize*8-8 			; reached the end.
.b921	f0 09		beq $b92c			beq 	_SNDDXExit
.b923	bd 05 07	lda $0705,x			lda 	SNDQueue+8,x
.b926	9d fd 06	sta $06fd,x			sta 	SNDQueue,x
.b929	e8		inx				inx
.b92a	80 f3		bra $b91f			bra 	SNDDeleteXFromQueue
.b92c					_SNDDXExit:
.b92c	60		rts				rts
.06fb					SNDChannelBits:
>06fb							.fill 	1
.b92d					SNDQueueRequest:
.b92d	86 36		stx $36				stx 	zTemp0						; save queue address
.b92f	84 37		sty $37				sty 	zTemp0+1
.b931	ae fc 06	ldx $06fc			ldx 	SNDLength 					; queue is full, can't take any more.
.b934	e0 20		cpx #$20			cpx 	#SNDQueueSize
.b936	f0 21		beq $b959			beq 	_SNDQRExit
.b938	29 03		and #$03			and 	#3	 						; channel # and push on stack
.b93a	48		pha				pha
.b93b	8a		txa				txa  								; get offset in queue buffer/
.b93c	0a		asl a				asl 	a
.b93d	0a		asl a				asl 	a
.b93e	0a		asl a				asl 	a
.b93f	aa		tax				tax
.b940	68		pla				pla 								; get back and push again
.b941	48		pha				pha
.b942	9d fd 06	sta $06fd,x			sta 	SNDQueue+0,x 				; save the channel #
.b945	a0 00		ldy #$00			ldy 	#0 							; copy the rest in.
.b947					_SNDQCopy:
.b947	b1 36		lda ($36),y			lda 	(zTemp0),y
.b949	e8		inx				inx
.b94a	c8		iny				iny
.b94b	9d fd 06	sta $06fd,x			sta 	SNDQueue,x
.b94e	c0 06		cpy #$06			cpy 	#6
.b950	d0 f5		bne $b947			bne 	_SNDQCopy
.b952	ee fc 06	inc $06fc			inc 	SNDLength 					; bump queue length.
.b955	68		pla				pla 								; get channel # back
.b956	20 81 b8	jsr $b881			jsr 	SNDCheckChannel 			; check if channel needs refreshing.
.b959					_SNDQRExit:
.b959	60		rts				rts
.b95a					SNDSilenceChannel:
.b95a	aa		tax				tax 								; zero time left.
.b95b	9e 09 08	stz $0809,x			stz 	SNDTimeLeft,x
.b95e	0a		asl a				asl 	a 							; shift into position
.b95f	0a		asl a				asl 	a
.b960	0a		asl a				asl 	a
.b961	0a		asl a				asl 	a
.b962	0a		asl a				asl 	a
.b963	09 9f		ora #$9f			ora 	#$9F 						; write register attenuation $F
.b965	20 69 b9	jsr $b969			jsr 	SNDWritePorts
.b968	60		rts				rts
.b969					SNDWritePorts:
.b969	64 01		stz $01				stz 	1
.b96b	8d 00 d6	sta $d600			sta 	$D600
.b96e	8d 10 d6	sta $d610			sta 	$D610
.b971	60		rts				rts
.b972					SNDCommand:
.b972	da		phx				phx
.b973	5a		phy				phy
.b974	c9 0f		cmp #$0f			cmp 	#$0F 						; $0F is initialise
.b976	f0 1d		beq $b995			beq 	_SNDInitialise
.b978	90 28		bcc $b9a2			bcc 	_SNDExit
.b97a	c9 3f		cmp #$3f			cmp 	#$3F 						; $3F is silence all
.b97c	f0 17		beq $b995			beq 	_SNDSilence
.b97e	b0 22		bcs $b9a2			bcs 	_SNDExit
.b980	c9 20		cmp #$20			cmp 	#$20 						; $2x is check playing => A
.b982	b0 09		bcs $b98d			bcs 	_SNDQueryPlay
.b984	c9 14		cmp #$14			cmp 	#$14 						; $10-$13 is queue sound
.b986	b0 1a		bcs $b9a2			bcs 	_SNDExit
.b988	20 2d b9	jsr $b92d			jsr 	SNDQueueRequest
.b98b	80 15		bra $b9a2			bra 	_SNDExit
.b98d					_SNDQueryPlay:
.b98d	29 03		and #$03			and 	#3 							; get channel #
.b98f	aa		tax				tax
.b990	bd 09 08	lda $0809,x			lda 	SNDTimeLeft,x 				; read time left, if zero then silent
.b993	80 0d		bra $b9a2			bra 	_SNDExit
.b995					_SNDInitialise:
.b995					_SNDSilence:
.b995	9c fc 06	stz $06fc			stz 	SNDLength 					; empty the queue.
.b998	a9 03		lda #$03			lda 	#$3 						; silence channel 0-3.
.b99a					_SNDSilenceLoop:
.b99a	48		pha				pha
.b99b	20 5a b9	jsr $b95a			jsr 	SNDSilenceChannel
.b99e	68		pla				pla
.b99f	3a		dec a				dec 	a
.b9a0	10 f8		bpl $b99a			bpl 	_SNDSilenceLoop
.b9a2					_SNDExit:
.b9a2	7a		ply				ply
.b9a3	fa		plx				plx
.b9a4	60		rts				rts
=32					SNDQueueSize = 32 							; number of queue entries
.06fc					SNDLength:
>06fc							.fill 	1
.06fd					SNDQueue:
>06fd							.fill 	SNDQueueSize * 8
.07fd					SNDPitchLow:
>07fd							.fill 	4
.0801					SNDPitchHigh:
>0801							.fill 	4
.0805					SNDVolume:
>0805							.fill 	4
.0809					SNDTimeLeft:
>0809							.fill 	4
.080d					SNDAdjustLow:
>080d							.fill 	4
.0811					SNDAdjustHigh:
>0811							.fill 	4
.b9a5					SNDUpdate:
.b9a5	ad 09 08	lda $0809			lda 	SNDTimeLeft+0 				; look at time remaining
.b9a8	f0 05		beq $b9af			beq 	_SNDUNot0 					; not playing
.b9aa	a2 00		ldx #$00			ldx 	#0 							; so we know which channel to update
.b9ac	20 ce b9	jsr $b9ce			jsr 	SNDUpdateChannel 			; update it.
.b9af					_SNDUNot0:
.b9af	ad 0a 08	lda $080a			lda 	SNDTimeLeft+1
.b9b2	f0 05		beq $b9b9			beq 	_SNDUNot1
.b9b4	a2 01		ldx #$01			ldx 	#1
.b9b6	20 ce b9	jsr $b9ce			jsr 	SNDUpdateChannel
.b9b9					_SNDUNot1:
.b9b9	ad 0b 08	lda $080b			lda 	SNDTimeLeft+2
.b9bc	f0 05		beq $b9c3			beq 	_SNDUNot2
.b9be	a2 02		ldx #$02			ldx 	#2
.b9c0	20 ce b9	jsr $b9ce			jsr 	SNDUpdateChannel
.b9c3					_SNDUNot2:
.b9c3	ad 0c 08	lda $080c			lda 	SNDTimeLeft+3
.b9c6	f0 05		beq $b9cd			beq 	_SNDUNot3
.b9c8	a2 03		ldx #$03			ldx 	#3
.b9ca	20 ce b9	jsr $b9ce			jsr 	SNDUpdateChannel
.b9cd					_SNDUNot3:
.b9cd	60		rts				rts
.b9ce					SNDUpdateChannel:
.b9ce	c9 ff		cmp #$ff			cmp 	#$FF 						; sound $FF play forever until turned off manually
.b9d0	f0 2c		beq $b9fe			beq 	_SNDUCExit
.b9d2	3a		dec a				dec 	a 							; decrement and update timer
.b9d3	9d 09 08	sta $0809,x			sta 	SNDTimeLeft,x
.b9d6	f0 1d		beq $b9f5			beq 	_SNDUCUpdate 				; if zero, silence channel
.b9d8	bd 0d 08	lda $080d,x			lda 	SNDAdjustLow,x 				; adjust ?
.b9db	1d 11 08	ora $0811,x			ora 	SNDAdjustHigh,x
.b9de	f0 1e		beq $b9fe			beq 	_SNDUCExit 					; if zero carry on at current tone.
.b9e0	18		clc				clc 								; add adjust, forcing into a 10 bit range
.b9e1	bd fd 07	lda $07fd,x			lda 	SNDPitchLow,x
.b9e4	7d 0d 08	adc $080d,x			adc 	SNDAdjustLow,x
.b9e7	9d fd 07	sta $07fd,x			sta 	SNDPitchLow,x
.b9ea	bd 01 08	lda $0801,x			lda 	SNDPitchHigh,x
.b9ed	7d 11 08	adc $0811,x			adc 	SNDAdjustHigh,x
.b9f0	29 03		and #$03			and 	#3
.b9f2	9d 01 08	sta $0801,x			sta 	SNDPitchHigh,x
.b9f5					_SNDUCUpdate:
.b9f5	8a		txa				txa 								; which channel.
.b9f6	48		pha				pha
.b9f7	20 c0 b8	jsr $b8c0			jsr 	SNDUpdateNote 				; update the current note
.b9fa	68		pla				pla
.b9fb	20 81 b8	jsr $b881			jsr 	SNDCheckChannel 			; more to do ?
.b9fe					_SNDUCExit:
.b9fe	60		rts				rts

;******  Return to file: _basic.asm


;******  End of listing
