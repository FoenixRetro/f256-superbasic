
; 64tass Turbo Assembler Macro V1.57.2900 listing file
; 64tass -D AUTORUN=0 "-D MONITOR_ADDRESS=\$E000" "-D LOCKOUT_ADDRESS=\$F000" "-D BASIC_ADDRESS=\$38000" "-D SOURCE_ADDRESS=\$3000" "-D SPRITE_ADDRESS=\$30000" -q -b -Wall -c -D "HARDWARE=0 $'\x9'$'\x9'$'\x9'$'\x9'$'\x9'$'\x9'" -L output/basic.lst -l output/basic.lbl -Wall -o basic.rom _basic.asm
; Sat Nov 26 12:48:26 2022

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=0					AUTORUN=0
=$e000					 MONITOR_ADDRESS=$E000
=$f000					 LOCKOUT_ADDRESS=$F000
=$38000					 BASIC_ADDRESS=$38000
=$3000					 SOURCE_ADDRESS=$3000
=$30000					 SPRITE_ADDRESS=$30000
=0					HARDWARE=0

;******  Processing input file: _basic.asm


;******  Processing file: ./common/aa.system/01common.inc

=$30					ZeroPageMandatory = $30
=$50					ZeroPagePreference = $50
=$400					MemoryStorage = $400
=$2000					BasicStart = $2000
=$8000					BasicEnd = $8000
=$8000					CodeStart = $8000
=$1000					VariableSpace = $1000
=$2000					EndVariableSpace = $2000
=8					MathStackSize = 8
=512					BasicStackSize = 512
=3584					BasicStackBase = $1000-BasicStackSize
=80					MaxLineSize = 80

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/02macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/04data.inc

.0030					codePtr:
>0030							.fill 	4
.0034					basicStack:
>0034							.fill 	2
.0036					zTemp0:
>0036							.fill 	2
.0038					zTemp1:
>0038							.fill 	2
.003a					zTemp2:
>003a							.fill 	2
.003c					zsTemp:
>003c							.fill 	2
.003e					zaTemp:
>003e							.fill 	2
=$30					safePtr = codePtr 							; minimise direct tinkering
=$80					NSBIsNegative = $80 						; bit 7 : sign of mantissa (where numeric)
=$20					NSBIsReference = $20 						; bit 5 : is a reference
=$10					NSBIsString = $10 							; bit 4 : set if string (procedures don't go on the stack)
=$18					NSBTypeMask = $18 							; bits 4,3 : 00 int 01 float 10 string 11 procedure
=$03					NSBRefMask = $03 							; bits 0,1 : Bytes of reference, -1 (e.g. 00 = 1 byte, 11 = 4 bytes)
=$04					NSBIsArray = $04
=$00					NSTInteger = $00 							; base types for bits 3..4
=$08					NSTFloat = $08
=$10					NSTString = $10
=$18					NSTProcedure = $18
.0050					NSStatus:
>0050							.fill 	MathStackSize
.0058					NSMantissa0:
>0058							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0060					NSMantissa1:
>0060							.fill 	MathStackSize
.0068					NSMantissa2:
>0068							.fill 	MathStackSize
.0070					NSMantissa3:
>0070							.fill 	MathStackSize
.0078					NSExponent:
>0078							.fill 	MathStackSize
.0400					identStart:
>0400							.fill 	1
.0401					identTypeStart:
>0401							.fill 	1
.0402					identTypeEnd:
>0402							.fill 	1
.0403					identHash:
>0403							.fill 	1
.0404					identTypeByte:
>0404							.fill 	1	 						; (see tokenising.pdf)
.0405					encodeState:
>0405							.fill 	1
.0406					digitTemp:
>0406							.fill 	1
.0407					decimalCount:
>0407							.fill 	1
.0408					randomSeed:
>0408							.fill 	4
.040c					lowMemPtr:
>040c							.fill 	2
.040e					stringMemory:
>040e							.fill 	2
.0410					stringInitialised:
>0410							.fill 	1
.0411					stringTempPointer:
>0411							.fill 	2
.0413					breakCheck:
>0413							.fill 	1
.0414					decimalPlaces:
>0414							.fill 	1
.0415					dbOffset:
>0415							.fill 	1
.0416					lastParameter:
>0416							.fill 	1
.0417					dataPointer:
>0417							.fill 	5
.041c					inDataStatement:
>041c							.fill 	1
.041d					tbOffset:
>041d							.fill 	1
.041e					AssemblerAddress:
>041e							.fill 	2
.0420					AssemblerControl:
>0420							.fill 	1
.0421					ParamStart:
>0421							.fill 	2
.0423					IsGroup1:
>0423							.fill 	1
.0424					BaseOpcode:
>0424							.fill 	1
.0425					ModeMask:
>0425							.fill 	1
.0426					listIndent:
>0426							.fill 	1
.0427					lcLastCharacter:
>0427							.fill 	1
.0428					isInputFlag:
>0428							.fill 	1
.0429					currentListColour:
>0429							.fill 	1
.042a					tokenOffset:
>042a							.fill 	1
.042b					tokenLineNumber:
>042b							.fill 	2
.042d					tokenBuffer:
>042d							.fill 	253
.052a					lineBuffer:
>052a							.fill 	MaxLineSize+1
.057b					numberBuffer:
>057b							.fill 	34
.059d					decimalBuffer:
>059d							.fill 	16

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/constants.inc

=$80					AM_ISZP = $80
=$40					AM_ISG1 = $40
=$20					AM_ISG2 = $20
=224					AM_IMMEDIATE = AM_ISZP+AM_ISG1+AM_ISG2+$00
=228					AM_ZEROPAGE = AM_ISZP+AM_ISG1+AM_ISG2+$04
=40					AM_ACC = AM_ISG2+$08
=108					AM_ABS = AM_ISG1+AM_ISG2+$0C
=208					AM_INDY = AM_ISZP+AM_ISG1+$10
=244					AM_ZEROX = AM_ISZP+AM_ISG1+AM_ISG2+$14
=120					AM_ABSY = AM_ISG1+AM_ISG2+$18
=124					AM_ABSX = AM_ISG1+AM_ISG2+$1C
=209					AM_IND = AM_ISZP+AM_ISG1+$11
=$80					AM_ZEROY = AM_ISZP
=$01					AM_INDABS = $01
=$02					AM_INDABSX = $02
=192					AM_INDX = AM_ISZP+AM_ISG1+$00

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/handlers.inc


;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.inc

=1					ERRID_BREAK = 1
=2					ERRID_SYNTAX = 2
=3					ERRID_DIVZERO = 3
=4					ERRID_RANGE = 4
=5					ERRID_TYPE = 5
=6					ERRID_MEMORY = 6
=7					ERRID_ARGUMENT = 7
=8					ERRID_STOP = 8
=9					ERRID_STRING = 9
=10					ERRID_ASSERT = 10
=11					ERRID_DATA = 11
=12					ERRID_NOTDONE = 12
=13					ERRID_LINE = 13
=14					ERRID_GOSUB = 14
=15					ERRID_REPEAT = 15
=16					ERRID_WHILE = 16
=17					ERRID_FOR = 17
=18					ERRID_STACK = 18
=19					ERRID_STRUCT = 19
=20					ERRID_PROC = 20
=21					ERRID_REDEFINE = 21
=22					ERRID_ARRAYSIZE = 22
=23					ERRID_ARRAYIDX = 23

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst.inc

=$00					KWD_LESSLESS                         = $00; $00 <<
=$01					KWD_LESSEQUAL                        = $01; $01 <=
=$02					KWD_LESSGREATER                      = $02; $02 <>
=$03					KWD_PLINGPLING3                      = $03; $03 !!3
=$04					KWD_GREATERLESS                      = $04; $04 ><
=$05					KWD_GREATEREQUAL                     = $05; $05 >=
=$06					KWD_GREATERGREATER                   = $06; $06 >>
=$07					KWD_PLINGPLING7                      = $07; $07 !!7
=$08					KWD_PLINGPLING8                      = $08; $08 !!8
=$09					KWD_PLINGPLING9                      = $09; $09 !!9
=$0a					KWD_PLINGPLING10                     = $0a; $0a !!10
=$0b					KWD_PLINGPLING11                     = $0b; $0b !!11
=$0c					KWD_PLINGPLING12                     = $0c; $0c !!12
=$0d					KWD_PLINGPLING13                     = $0d; $0d !!13
=$0e					KWD_PLINGPLING14                     = $0e; $0e !!14
=$0f					KWD_PLINGPLING15                     = $0f; $0f !!15
=$10					KWD_AT                               = $10; $10 @
=$11					KWD_PLINGPLING17                     = $11; $11 !!17
=$12					KWD_PLINGPLING18                     = $12; $12 !!18
=$13					KWD_LSQPAREN                         = $13; $13 [
=$14					KWD_BACKSLASH                        = $14; $14 \
=$15					KWD_RSQPAREN                         = $15; $15 ]
=$16					KWD_HAT                              = $16; $16 ^
=$17					KWD_UNDERSCORE                       = $17; $17 _
=$18					KWD_BQUOTE                           = $18; $18 `
=$19					KWD_PLINGPLING25                     = $19; $19 !!25
=$1a					KWD_PLINGPLING26                     = $1a; $1a !!26
=$1b					KWD_LCURLY                           = $1b; $1b {
=$1c					KWD_BAR                              = $1c; $1c |
=$1d					KWD_RCURLY                           = $1d; $1d }
=$1e					KWD_TILDE                            = $1e; $1e ~
=$21					KWD_PLING                            = $21; $21 !
=$22					KWD_DQUOTE                           = $22; $22 "
=$23					KWD_HASH                             = $23; $23 #
=$24					KWD_DOLLAR                           = $24; $24 $
=$25					KWD_PERCENT                          = $25; $25 %
=$26					KWD_AMPERSAND                        = $26; $26 &
=$27					KWD_QUOTE                            = $27; $27 '
=$28					KWD_LPAREN                           = $28; $28 (
=$29					KWD_RPAREN                           = $29; $29 )
=$2a					KWD_STAR                             = $2a; $2a *
=$2b					KWD_PLUS                             = $2b; $2b +
=$2c					KWD_COMMA                            = $2c; $2c ,
=$2d					KWD_MINUS                            = $2d; $2d -
=$2e					KWD_PERIOD                           = $2e; $2e .
=$2f					KWD_SLASH                            = $2f; $2f /
=$30					KWD_0                                = $30; $30 0
=$31					KWD_1                                = $31; $31 1
=$32					KWD_2                                = $32; $32 2
=$33					KWD_3                                = $33; $33 3
=$34					KWD_4                                = $34; $34 4
=$35					KWD_5                                = $35; $35 5
=$36					KWD_6                                = $36; $36 6
=$37					KWD_7                                = $37; $37 7
=$38					KWD_8                                = $38; $38 8
=$39					KWD_9                                = $39; $39 9
=$3a					KWD_COLON                            = $3a; $3a :
=$3b					KWD_SEMICOLON                        = $3b; $3b ;
=$3c					KWD_LESS                             = $3c; $3c <
=$3d					KWD_EQUAL                            = $3d; $3d =
=$3e					KWD_GREATER                          = $3e; $3e >
=$3f					KWD_QMARK                            = $3f; $3f ?
=$83					KWD_ABSLPAREN                        = $83; $83 ABS(
=$84					KWD_ALLOCLPAREN                      = $84; $84 ALLOC(
=$85					KWD_ASCLPAREN                        = $85; $85 ASC(
=$86					KWD_CHRDOLLARLPAREN                  = $86; $86 CHR$(
=$87					KWD_EVENTLPAREN                      = $87; $87 EVENT(
=$88					KWD_FALSE                            = $88; $88 FALSE
=$89					KWD_FRACLPAREN                       = $89; $89 FRAC(
=$8a					KWD_HITLPAREN                        = $8a; $8a HIT(
=$8b					KWD_INTLPAREN                        = $8b; $8b INT(
=$8c					KWD_ISVALLPAREN                      = $8c; $8c ISVAL(
=$8d					KWD_JOYBLPAREN                       = $8d; $8d JOYB(
=$8e					KWD_JOYXLPAREN                       = $8e; $8e JOYX(
=$8f					KWD_JOYYLPAREN                       = $8f; $8f JOYY(
=$90					KWD_LEFTDOLLARLPAREN                 = $90; $90 LEFT$(
=$91					KWD_LENLPAREN                        = $91; $91 LEN(
=$92					KWD_MAXLPAREN                        = $92; $92 MAX(
=$93					KWD_MIDDOLLARLPAREN                  = $93; $93 MID$(
=$94					KWD_MINLPAREN                        = $94; $94 MIN(
=$95					KWD_NOTLPAREN                        = $95; $95 NOT(
=$96					KWD_PLAYINGLPAREN                    = $96; $96 PLAYING(
=$97					KWD_RANDOMLPAREN                     = $97; $97 RANDOM(
=$98					KWD_RIGHTDOLLARLPAREN                = $98; $98 RIGHT$(
=$99					KWD_RNDLPAREN                        = $99; $99 RND(
=$9a					KWD_SGNLPAREN                        = $9a; $9a SGN(
=$9b					KWD_SPCLPAREN                        = $9b; $9b SPC(
=$9c					KWD_STRDOLLARLPAREN                  = $9c; $9c STR$(
=$9d					KWD_TIMERLPAREN                      = $9d; $9d TIMER(
=$9e					KWD_TRUE                             = $9e; $9e TRUE
=$9f					KWD_VALLPAREN                        = $9f; $9f VAL(
=$a0					KWD_FOR                              = $a0; $a0 FOR
=$a1					KWD_IF                               = $a1; $a1 IF
=$a2					KWD_PROC                             = $a2; $a2 PROC
=$a3					KWD_REPEAT                           = $a3; $a3 REPEAT
=$a4					KWD_WHILE                            = $a4; $a4 WHILE
=$a5					KWD_ENDIF                            = $a5; $a5 ENDIF
=$a6					KWD_ENDPROC                          = $a6; $a6 ENDPROC
=$a7					KWD_NEXT                             = $a7; $a7 NEXT
=$a8					KWD_THEN                             = $a8; $a8 THEN
=$a9					KWD_UNTIL                            = $a9; $a9 UNTIL
=$aa					KWD_WEND                             = $aa; $aa WEND
=$ab					KWD_BY                               = $ab; $ab BY
=$ac					KWD_CALL                             = $ac; $ac CALL
=$ad					KWD_CIRCLE                           = $ad; $ad CIRCLE
=$ae					KWD_CLEAR                            = $ae; $ae CLEAR
=$af					KWD_CLS                              = $af; $af CLS
=$b0					KWD_COLOR                            = $b0; $b0 COLOR
=$b1					KWD_COLOUR                           = $b1; $b1 COLOUR
=$b2					KWD_DATA                             = $b2; $b2 DATA
=$b3					KWD_DIM                              = $b3; $b3 DIM
=$b4					KWD_DOWNTO                           = $b4; $b4 DOWNTO
=$b5					KWD_ELSE                             = $b5; $b5 ELSE
=$b6					KWD_FROM                             = $b6; $b6 FROM
=$b7					KWD_GFX                              = $b7; $b7 GFX
=$b8					KWD_GOSUB                            = $b8; $b8 GOSUB
=$b9					KWD_GOTO                             = $b9; $b9 GOTO
=$ba					KWD_HERE                             = $ba; $ba HERE
=$bb					KWD_IMAGE                            = $bb; $bb IMAGE
=$bc					KWD_INPUT                            = $bc; $bc INPUT
=$bd					KWD_LET                              = $bd; $bd LET
=$be					KWD_LINE                             = $be; $be LINE
=$bf					KWD_LOCAL                            = $bf; $bf LOCAL
=$c0					KWD_OFF                              = $c0; $c0 OFF
=$c1					KWD_ON                               = $c1; $c1 ON
=$c2					KWD_OUTLINE                          = $c2; $c2 OUTLINE
=$c3					KWD_PALETTE                          = $c3; $c3 PALETTE
=$c4					KWD_PLOT                             = $c4; $c4 PLOT
=$c5					KWD_PRINT                            = $c5; $c5 PRINT
=$c6					KWD_READ                             = $c6; $c6 READ
=$c7					KWD_RECT                             = $c7; $c7 RECT
=$c8					KWD_REM                              = $c8; $c8 REM
=$c9					KWD_RETURN                           = $c9; $c9 RETURN
=$ca					KWD_SOLID                            = $ca; $ca SOLID
=$cb					KWD_SOUND                            = $cb; $cb SOUND
=$cc					KWD_SPRITE                           = $cc; $cc SPRITE
=$cd					KWD_TEXT                             = $cd; $cd TEXT
=$ce					KWD_TO                               = $ce; $ce TO

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst0.inc

=$80					KWC_EOL = $80
=$ff					KWC_STRING = $FF
=$fe					KWC_HEXCONST = $FE
=$a0					KWC_FIRST_STRUCTURE = $a0
=$a5					KWC_FIRST_STRUCTURE_DEC = $a5
=$aa					KWC_LAST_STRUCTURE = $aa
=$83					KWC_FIRST_UNARY = $83
=$9f					KWC_LAST_UNARY = $9f

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/access.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/stack.inc

=$e0					STK_GOSUB = $E0
=$d0					STK_FOR = $D0
=$c0					STK_REPEAT = $C0
=$b0					STK_PROC = $B0
=$a0					STK_WHILE = $A0
=$01					STK_LOCALN = $01
=$02					STK_LOCALS = $02

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/00start.asm

.8000	a2 ff		ldx #$ff	Start:	ldx 	#$FF 						; stack reset
.8002	9a		txs				txs
.8003	20 c5 a8	jsr $a8c5			jsr 	EXTInitialise 				; hardware initialise
.8006	a2 80		ldx #$80			ldx 	#(Prompt >> 8) 				; prompt display
.8008	a9 22		lda #$22			lda 	#(Prompt & $FF)
.800a	20 26 8e	jsr $8e26			jsr 	PrintStringXA
.800d	a9 00		lda #$00			lda 	#0 							; graphics system initialise.
.800f	aa		tax				tax
.8010	a8		tay				tay
.8011	20 51 a9	jsr $a951			jsr 	GXGraphicDraw
.8014	a9 0f		lda #$0f			lda 	#$0F 						; initialise sound system
.8016	20 f1 b7	jsr $b7f1			jsr 	SNDCommand
.8019	20 21 89	jsr $8921			jsr 	NewProgram 					; erase current program
.801c	4c 62 83	jmp $8362			jmp 	WarmStart					; make same size.
.801f	4c 62 83	jmp $8362			jmp 	WarmStart
>8022	0c 2a 2a 2a 20 46 32 35		Prompt:	.text 	12,"*** F256 Junior SuperBASIC ***",13,13
>802a	36 20 4a 75 6e 69 6f 72 20 53 75 70 65 72 42 41
>803a	53 49 43 20 2a 2a 2a 0d 0d

;******  Processing file: ./common/aa.system/../generated/timestamp.asm

>8043	52 65 6c 65 61 73 65 20			.text "Release Alpha 5 (26-Nov-22). "
>804b	41 6c 70 68 61 20 35 20 28 32 36 2d 4e 6f 76 2d
>805b	32 32 29 2e 20

;******  Return to file: ./common/aa.system/00start.asm

>8060	0d 0d 00					.byte 	13,13,0

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/assembler.asm

.8063					AssembleGroup1:
.8063	a9 ff		lda #$ff			lda 	#$FF
.8065	8d 25 04	sta $0425			sta 	ModeMask 					; initialise the mode mask - all for all
.8068	80 02		bra $806c			bra 	AsmGroup12
.806a					AssembleGroup2:
.806a	a9 00		lda #$00			lda 	#$00
.806c					AsmGroup12:
.806c	8d 23 04	sta $0423			sta 	IsGroup1 					; save the 'group 1' flag
.806f	68		pla				pla 								; pop the return address to access the information following.
.8070	fa		plx				plx
.8071	20 f8 80	jsr $80f8			jsr 	AccessParameters 			; get opcode and save as base
.8074	8d 24 04	sta $0424			sta 	BaseOpcode
.8077	ad 23 04	lda $0423			lda 	IsGroup1 					; skip if group 1 as we don't have a complex mask.
.807a	d0 08		bne $8084			bne 	_AG12HaveMask
.807c	a9 02		lda #$02			lda 	#2 							; if group 2 the second parameter is the mask
.807e	20 00 81	jsr $8100			jsr 	GetParameter		 		; e.g. which modes are supported for this operand
.8081	8d 25 04	sta $0425			sta 	ModeMask
.8084					_AG12HaveMask:
.8084	20 34 82	jsr $8234			jsr 	TypeAndCalculateOperand 	; get zero page type
.8087	da		phx				phx 								; save found address mode
.8088	20 64 81	jsr $8164			jsr 	AssembleModeX
.808b	fa		plx				plx  								; restore address mode
.808c	b0 0b		bcs $8099			bcs 	_AG12Exit
.808e	20 9a 80	jsr $809a			jsr 	PromoteToAbsolute  			; promote ZP to ABS and try that
.8091	20 64 81	jsr $8164			jsr 	AssembleModeX
.8094	b0 03		bcs $8099			bcs 	_AG12Exit
.8096	4c 55 9e	jmp $9e55			jmp 	SyntaxError 				; can't do either, so must be wrong mode/operand.
.8099					_AG12Exit:
.8099	60		rts				rts
.809a					PromoteToAbsolute:
.809a	a9 6c		lda #$6c			lda 	#AM_ABS 					; lda xx
.809c	e0 e4		cpx #$e4			cpx 	#AM_ZEROPAGE
.809e	f0 19		beq $80b9			beq 	_PTADo
.80a0	a9 7c		lda #$7c			lda 	#AM_ABSX 					; lda xx,X
.80a2	e0 f4		cpx #$f4			cpx 	#AM_ZEROX
.80a4	f0 13		beq $80b9			beq 	_PTADo
.80a6	a9 78		lda #$78			lda 	#AM_ABSY 					; lda xx,Y
.80a8	e0 80		cpx #$80			cpx 	#AM_ZEROY
.80aa	f0 0d		beq $80b9			beq 	_PTADo
.80ac	a9 01		lda #$01			lda 	#AM_INDABS 					; lda (xx) (jump)
.80ae	e0 d1		cpx #$d1			cpx 	#AM_IND
.80b0	f0 07		beq $80b9			beq 	_PTADo
.80b2	a9 02		lda #$02			lda 	#AM_INDABSX 				; lda (xx,x) (jump)
.80b4	e0 c0		cpx #$c0			cpx 	#AM_INDX
.80b6	f0 01		beq $80b9			beq 	_PTADo
.80b8	60		rts				rts
.80b9					_PTADo:
.80b9	aa		tax				tax
.80ba	60		rts				rts
.80bb					AssembleGroup3:
.80bb	68		pla				pla 								; get parameters, which is just the opcode.
.80bc	fa		plx				plx
.80bd	20 f8 80	jsr $80f8			jsr 	AccessParameters 			; get and output opcode
.80c0	20 10 81	jsr $8110			jsr 	AssemblerWriteByte
.80c3	20 98 82	jsr $8298			jsr 	CalculateOperand 			; get a 16 bit operand
.80c6	a5 58		lda $58				lda 	NSMantissa0 				; calculate the offset
.80c8	38		sec				sec
.80c9	ed 1e 04	sbc $041e			sbc 	AssemblerAddress
.80cc	48		pha				pha 								; LSB in A
.80cd	a5 60		lda $60				lda 	NSMantissa1
.80cf	ed 1f 04	sbc $041f			sbc 	AssemblerAddress+1
.80d2	aa		tax				tax 								; MSB in X
.80d3	68		pla				pla
.80d4	18		clc				clc 								; $80 to easy check $80-$7F, plus 1 for offset error
.80d5	69 7f		adc #$7f			adc 	#$7F
.80d7	90 01		bcc $80da			bcc 	_AG3NoCarry
.80d9	e8		inx				inx
.80da					_AG3NoCarry:
.80da	38		sec				sec 								; fix back and write out anyways.
.80db	e9 80		sbc #$80			sbc 	#$80
.80dd	20 10 81	jsr $8110			jsr 	AssemblerWriteByte
.80e0	e0 00		cpx #$00			cpx 	#0 							; was it in range
.80e2	f0 0a		beq $80ee			beq 	_AG3Exit
.80e4	ad 20 04	lda $0420			lda 	AssemblerControl 			; are we allowing bad values ?
.80e7	29 01		and #$01			and 	#1
.80e9	f0 03		beq $80ee			beq 	_AG3Exit
.80eb	4c 5a 9e	jmp $9e5a			jmp 	RangeError 					; no, branch is out of range
.80ee					_AG3Exit:
.80ee	60		rts				rts
.80ef					AssembleGroup4:
.80ef	68		pla				pla 								; pop address
.80f0	fa		plx				plx
.80f1	20 f8 80	jsr $80f8			jsr 	AccessParameters 			; access and get first
.80f4	20 10 81	jsr $8110			jsr 	AssemblerWriteByte 			; output it.
.80f7	60		rts				rts
.80f8					AccessParameters:
.80f8	8d 21 04	sta $0421			sta 	ParamStart
.80fb	8e 22 04	stx $0422			stx 	ParamStart+1
.80fe	a9 01		lda #$01			lda 	#1
.8100					GetParameter:
.8100	5a		phy				phy
.8101	a8		tay				tay
.8102	ad 21 04	lda $0421			lda 	ParamStart
.8105	85 36		sta $36				sta 	zTemp0
.8107	ad 22 04	lda $0422			lda 	ParamStart+1
.810a	85 37		sta $37				sta 	zTemp0+1
.810c	b1 36		lda ($36),y			lda 	(zTemp0),y
.810e	7a		ply				ply
.810f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/aswrite.asm

.8110					AssemblerWriteByte:
.8110	48		pha			pha
.8111	ad 20 04	lda $0420		lda 	AssemblerControl 				; check printing bytes ?
.8114	29 02		and #$02		and 	#2
.8116	f0 1b		beq $8133		beq 	_AWBNoPrint
.8118	ad 1f 04	lda $041f		lda		AssemblerAddress+1 				; print address
.811b	20 4e 81	jsr $814e		jsr 	PrintHex
.811e	ad 1e 04	lda $041e		lda		AssemblerAddress
.8121	20 4e 81	jsr $814e		jsr 	PrintHex
.8124	a9 20		lda #$20		lda 	#' '
.8126	20 51 a6	jsr $a651		jsr 	EXTPrintCharacter
.8129	68		pla			pla 									; print byte
.812a	48		pha			pha
.812b	20 4e 81	jsr $814e		jsr 	PrintHex
.812e	a9 0d		lda #$0d		lda 	#13
.8130	20 51 a6	jsr $a651		jsr 	EXTPrintCharacter
.8133					_AWBNoPrint:
.8133	ad 1e 04	lda $041e		lda		AssemblerAddress				; copy address to zTemp0
.8136	85 36		sta $36			sta 	zTemp0
.8138	ad 1f 04	lda $041f		lda		AssemblerAddress+1
.813b	f0 0e		beq $814b		beq 	_AWBRange
.813d	85 37		sta $37			sta 	zTemp0+1
.813f	68		pla			pla 									; write byte out
.8140	92 36		sta ($36)		sta 	(zTemp0)
.8142	ee 1e 04	inc $041e		inc 	AssemblerAddress 				; bump address
.8145	d0 03		bne $814a		bne 	_AWBNoCarry
.8147	ee 1f 04	inc $041f		inc 	AssemblerAddress+1
.814a					_AWBNoCarry:
.814a	60		rts			rts
.814b					_AWBRange:
.814b	4c 5a 9e	jmp $9e5a		jmp 	RangeError
.814e					PrintHex:
.814e	48		pha				pha
.814f	4a		lsr a				lsr 	a
.8150	4a		lsr a				lsr 	a
.8151	4a		lsr a				lsr 	a
.8152	4a		lsr a				lsr 	a
.8153	20 57 81	jsr $8157			jsr 	_PrintNibble
.8156	68		pla				pla
.8157					_PrintNibble:
.8157	29 0f		and #$0f			and 	#15
.8159	c9 0a		cmp #$0a			cmp 	#10
.815b	90 02		bcc $815f			bcc 	_NoShift
.815d	69 06		adc #$06			adc 	#6
.815f					_NoShift:
.815f	69 30		adc #$30			adc 	#48
.8161	4c 51 a6	jmp $a651			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/instruction.asm

.8164					AssembleModeX:
.8164	5a		phy				phy
.8165	ad 23 04	lda $0423			lda 	IsGroup1
.8168	f0 17		beq $8181			beq 	_AMXGroup2
.816a	8a		txa				txa 							; is it in group # 1
.816b	29 40		and #$40			and 	#AM_ISG1
.816d	f0 4d		beq $81bc			beq 	_AMXFail 				; no, give up.
.816f	8a		txa				txa 							; get back.
.8170	29 1f		and #$1f			and 	#$1F 					; this is now the offset.
.8172	e0 e0		cpx #$e0			cpx 	#AM_IMMEDIATE 			; if not immediate, we can continue.
.8174	d0 22		bne $8198			bne 	_AMXHaveInfo
.8176	ad 24 04	lda $0424			lda 	BaseOpcode 				; cannot store immediate.
.8179	c9 81		cmp #$81			cmp 	#$81
.817b	f0 3f		beq $81bc			beq 	_AMXFail
.817d	a9 08		lda #$08			lda 	#8 						; if immediate we use offset 8.
.817f	80 17		bra $8198			bra 	_AMXHaveInfo 			; odd design decision there.
.8181					_AMXGroup2:
.8181	8a		txa				txa 							; is it in group 2 ?
.8182	29 20		and #$20			and 	#AM_ISG2
.8184	f0 36		beq $81bc			beq 	_AMXFail 				; no, give up.
.8186	8a		txa				txa 							; get the offset into Y
.8187	29 1f		and #$1f			and 	#$1F
.8189	4a		lsr a				lsr 	a 						; make it 0-7.
.818a	4a		lsr a				lsr  	a
.818b	a8		tay				tay
.818c	ad 25 04	lda $0425			lda 	ModeMask 				; shift the modemask left so you can check it against the requested offset
.818f					_AMXCheckOkay:
.818f	0a		asl a				asl 	a 						; shift modemask left enough times to check legitimate.
.8190	88		dey				dey
.8191	10 fc		bpl $818f			bpl 	_AMXCheckOkay
.8193	90 27		bcc $81bc			bcc 	_AMXFail 				; not allowed.
.8195	8a		txa				txa  							; get mask back
.8196	29 1f		and #$1f			and 	#$1F
.8198					_AMXHaveInfo:
.8198	e0 00		cpx #$00			cpx 	#$00 					; does it *require* an 8 bit operand
.819a	10 04		bpl $81a0			bpl 	_AMXAnySize 			; checking bit 7, the zero page opcode flag.
.819c	a4 60		ldy $60				ldy 	NSMantissa1 			; fail if it is outside range, e.g. the MSB is set.
.819e	d0 1c		bne $81bc			bne 	_AMXFail
.81a0					_AMXAnySize:
.81a0	18		clc				clc 							; add offset to the base opcode
.81a1	6d 24 04	adc $0424			adc 	BaseOpcode
.81a4					_AMXOutputCode:
.81a4	20 10 81	jsr $8110			jsr 	AssemblerWriteByte 		; write the opcode out.
.81a7	e0 28		cpx #$28			cpx 	#AM_ACC 				; A mode (e.g. ASL A)
.81a9	f0 0e		beq $81b9			beq 	_AMXExit
.81ab	a5 58		lda $58				lda 	NSMantissa0 				; write LSB operand
.81ad	20 10 81	jsr $8110			jsr 	AssemblerWriteByte
.81b0	e0 00		cpx #$00			cpx 	#$00 					; zeropage ?
.81b2	30 05		bmi $81b9			bmi 	_AMXExit
.81b4	a5 60		lda $60				lda 	NSMantissa1 			; write MSB operand
.81b6	20 10 81	jsr $8110			jsr 	AssemblerWriteByte
.81b9					_AMXExit:
.81b9	7a		ply				ply
.81ba	38		sec				sec
.81bb	60		rts				rts
.81bc					_AMXFail:
.81bc	a0 00		ldy #$00			ldy 	#0
.81be					_AMXCheckOddities:
.81be	8a		txa				txa
.81bf	d9 e6 81	cmp $81e6,y			cmp 	ExtraOpcode+2,y 		; match address mode
.81c2	d0 15		bne $81d9			bne 	_AMXCONext
.81c4	b9 e4 81	lda $81e4,y			lda 	ExtraOpcode+0,y 		; do the base opcodes match
.81c7	cd 24 04	cmp $0424			cmp 	BaseOpcode
.81ca	d0 0d		bne $81d9			bne 	_AMXCONext
.81cc	e0 00		cpx #$00			cpx 	#$00 					; requires zero page ?
.81ce	10 04		bpl $81d4			bpl 	_AMXCONotZero
.81d0	a5 60		lda $60				lda 	NSMantissa1
.81d2	d0 05		bne $81d9			bne 	_AMXCONext
.81d4					_AMXCONotZero:
.81d4	b9 e5 81	lda $81e5,y			lda 	ExtraOpcode+1,y 		; get new opcode
.81d7	80 cb		bra $81a4			bra 	_AMXOutputCode 			; and assemble it
.81d9					_AMXCONext:
.81d9	c8		iny				iny
.81da	c8		iny				iny
.81db	c8		iny				iny
.81dc	b9 e4 81	lda $81e4,y			lda 	ExtraOpcode+0,y 		; end of table
.81df	d0 dd		bne $81be			bne 	_AMXCheckOddities
.81e1					_AMXCOFail:
.81e1	7a		ply				ply
.81e2	18		clc				clc
.81e3	60		rts				rts
.81e4					ExtraOpcode:
>81e4	40 6c 01					.byte $40,$6c,AM_INDABS 	; jmp
>81e7	40 7c 02					.byte $40,$7C,AM_INDABSX 	; jmp
>81ea	a2 be 78					.byte $a2,$BE,AM_ABSY 		; ldx
>81ed	a2 b6 80					.byte $a2,$B6,AM_ZEROY 		; ldx
>81f0	82 96 80					.byte $82,$96,AM_ZEROY 		; stx
>81f3	e2 1a 28					.byte $e2,$1a,AM_ACC 		; inc
>81f6	c2 3a 28					.byte $c2,$3a,AM_ACC 		; dec
>81f9	20 89 e0					.byte $20,$89,AM_IMMEDIATE 	; bit
>81fc	60 9c 6c					.byte $60,$9c,AM_ABS 		; stz
>81ff	60 9e 7c					.byte $60,$9e,AM_ABSX 		; stz
>8202	00						.byte $00

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/label.asm

.8203					LabelHere:
.8203	c8		iny				iny 								; skip .
.8204	a2 00		ldx #$00			ldx 	#0 							; get a term
.8206	20 1b 97	jsr $971b			jsr 	EvaluateTerm 				; get a term
.8209	a5 50		lda $50				lda 	NSStatus 					; needs to be an integer reference.
.820b	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.820d	d0 22		bne $8231			bne 	_ALType
.820f	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy reference address to zTemp0
.8211	85 36		sta $36				sta 	zTemp0
.8213	b5 60		lda $60,x			lda 	NSMantissa1,x
.8215	85 37		sta $37				sta 	zTemp0+1
.8217	5a		phy				phy 								; copy address in.
.8218	a0 01		ldy #$01			ldy 	#1
.821a	ad 1e 04	lda $041e			lda	 	AssemblerAddress
.821d	92 36		sta ($36)			sta 	(zTemp0)
.821f	ad 1f 04	lda $041f			lda	 	AssemblerAddress+1
.8222	91 36		sta ($36),y			sta 	(zTemp0),y
.8224	c8		iny				iny
.8225	a9 00		lda #$00			lda 	#0
.8227	91 36		sta ($36),y			sta 	(zTemp0),y
.8229	c8		iny				iny
.822a	91 36		sta ($36),y			sta 	(zTemp0),y
.822c	c8		iny				iny
.822d	91 36		sta ($36),y			sta 	(zTemp0),y
.822f	7a		ply				ply
.8230	60		rts				rts
.8231					_ALType:
.8231	4c 5f 9e	jmp $9e5f			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/operands.asm

.8234					TypeAndCalculateOperand:
.8234	b1 30		lda ($30),y			lda 	(codePtr),y
.8236	a2 28		ldx #$28			ldx 	#AM_ACC 					; ACC if : or EOL
.8238	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.823a	f0 5b		beq $8297			beq 	_TACOExit
.823c	c9 80		cmp #$80			cmp 	#KWC_EOL
.823e	f0 57		beq $8297			beq 	_TACOExit
.8240	c8		iny				iny
.8241	a2 e0		ldx #$e0			ldx 	#AM_IMMEDIATE
.8243	c9 23		cmp #$23			cmp 	#KWD_HASH 					; if hash, then immediate - constant.
.8245	f0 51		beq $8298			beq 	CalculateOperand
.8247	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; if ( then check for indirection
.8249	f0 1f		beq $826a			beq 	_TACOIndirect
.824b	88		dey				dey 								; undo get of first character
.824c	20 98 82	jsr $8298			jsr 	CalculateOperand 			; get operand
.824f	b1 30		lda ($30),y			lda 	(codePtr),y
.8251	a2 e4		ldx #$e4			ldx 	#AM_ZEROPAGE 				; if not, try zero page (then absolute)
.8253	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8255	d0 40		bne $8297			bne 	_TACOExit
.8257	c8		iny				iny
.8258	20 a2 82	jsr $82a2			jsr 	TACOCheckXY 				; extract X,Y or 0 (neither) from the variable.
.825b	a2 f4		ldx #$f4			ldx 	#AM_ZEROX 					; check for X
.825d	c9 58		cmp #$58			cmp 	#'X'
.825f	f0 36		beq $8297			beq 	_TACOExit
.8261	a2 80		ldx #$80			ldx 	#AM_ZEROY 					; check for Y
.8263	c9 59		cmp #$59			cmp 	#'Y'
.8265	f0 30		beq $8297			beq 	_TACOExit
.8267					_TACOSyntax:
.8267	4c 55 9e	jmp $9e55			jmp 	SyntaxError
.826a					_TACOIndirect:
.826a	20 98 82	jsr $8298			jsr 	CalculateOperand 			; get the operand
.826d	b1 30		lda ($30),y			lda 	(codePtr),y
.826f	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if , then it must be ,X)
.8271	f0 17		beq $828a			beq 	_TACOIndX
.8273	20 b4 8d	jsr $8db4			jsr 	CheckRightBracket  			; otherwise must be ) or ),Y
.8276	b1 30		lda ($30),y			lda 	(codePtr),y
.8278	a2 d1		ldx #$d1			ldx 	#AM_IND
.827a	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not comma then exit with (xx)
.827c	d0 19		bne $8297			bne 	_TACOExit
.827e	c8		iny				iny
.827f	20 a2 82	jsr $82a2			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.8282	c9 59		cmp #$59			cmp 	#'Y' 						; check Y
.8284	d0 e1		bne $8267			bne 	_TACOSyntax
.8286	a2 d0		ldx #$d0			ldx 	#AM_INDY
.8288	80 0d		bra $8297			bra 	_TACOExit
.828a					_TACOIndX:
.828a	c8		iny				iny
.828b	20 a2 82	jsr $82a2			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.828e	c9 58		cmp #$58			cmp 	#'X' 						; check X
.8290	d0 d5		bne $8267			bne 	_TACOSyntax
.8292	20 b4 8d	jsr $8db4			jsr 	CheckRightBracket			; check )
.8295	a2 c0		ldx #$c0			ldx 	#AM_INDX
.8297					_TACOExit:
.8297	60		rts				rts
.8298					CalculateOperand:
.8298	48		pha				pha
.8299	da		phx				phx
.829a	a2 00		ldx #$00			ldx 	#0 							; get 16 bit integer in Slot 0
.829c	20 5d 9c	jsr $9c5d			jsr 	Evaluate16BitInteger
.829f	fa		plx				plx
.82a0	68		pla				pla
.82a1	60		rts				rts
.82a2					TACOCheckXY:
.82a2	b1 30		lda ($30),y			lda 	(codePtr),y
.82a4	29 c0		and #$c0			and 	#$C0 						; check it is an identifier reference.
.82a6	c9 40		cmp #$40			cmp 	#$40
.82a8	d0 21		bne $82cb			bne 	_TCXYFail
.82aa	b1 30		lda ($30),y			lda 	(codePtr),y
.82ac	18		clc				clc
.82ad	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.82af	85 37		sta $37				sta 	zTemp0+1
.82b1	c8		iny				iny
.82b2	b1 30		lda ($30),y			lda 	(codePtr),y
.82b4	c8		iny				iny
.82b5	85 36		sta $36				sta 	zTemp0
.82b7	5a		phy				phy 								; save position
.82b8	a0 02		ldy #$02			ldy 	#2 							; type is integer ?
.82ba	b1 36		lda ($36),y			lda 	(zTemp0),y
.82bc	d0 0c		bne $82ca			bne 	_TCXYPopFail
.82be	a0 08		ldy #$08			ldy 	#8 							; get first character, should have bit 7 set as also last.
.82c0	b1 36		lda ($36),y			lda 	(zTemp0),y
.82c2	c9 d8		cmp #$d8			cmp 	#'X'+$80 					; should be X or Y
.82c4	f0 08		beq $82ce			beq 	_TCXYFound
.82c6	c9 d9		cmp #$d9			cmp 	#'Y'+$80
.82c8	f0 04		beq $82ce			beq 	_TCXYFound
.82ca					_TCXYPopFail:
.82ca	7a		ply				ply
.82cb					_TCXYFail:
.82cb	a9 00		lda #$00			lda 	#0
.82cd	60		rts				rts
.82ce					_TCXYFound:
.82ce	7a		ply				ply 								; restore position
.82cf	29 7f		and #$7f			and 	#$7F 						; throw bit 7
.82d1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/backload.asm

.82d2					BackloadProgram:
.82d2	a2 83		ldx #$83			ldx 	#_BLLoad >> 8
.82d4	a9 11		lda #$11			lda 	#_BLLoad & $FF
.82d6	20 26 8e	jsr $8e26			jsr 	PrintStringXA
.82d9	a9 00		lda #$00			lda 	#((SOURCE_ADDRESS) & $FF)
.82db	8d ad 05	sta $05ad			sta 	0+BackLoadPointer
.82de	a9 30		lda #$30			lda 	#((SOURCE_ADDRESS) >> 8)
.82e0	8d ae 05	sta $05ae			sta 	1+BackLoadPointer
.82e3					_BPLoop:
.82e3	a2 ff		ldx #$ff			ldx 	#$FF
.82e5	20 26 83	jsr $8326			jsr 	BLReadByte 					; read a byte
.82e8	c9 00		cmp #$00			cmp 	#0
.82ea	f0 21		beq $830d			beq 	_BPExit 					; if 0 exit
.82ec	30 1f		bmi $830d			bmi 	_BPExit 					; if -ve exit
.82ee					_BPCopy:
.82ee	e8		inx				inx  								; copy byte into the lineBuffer
.82ef	9d 2a 05	sta $052a,x			sta 	lineBuffer,x
.82f2	9e 2b 05	stz $052b,x			stz 	lineBuffer+1,x
.82f5	20 26 83	jsr $8326			jsr 	BLReadByte 					; read next byte
.82f8	30 0a		bmi $8304			bmi 	_BPEndLine 					; -ve = EOL
.82fa	c9 09		cmp #$09			cmp 	#9 							; handle TAB, make it space.
.82fc	d0 02		bne $8300			bne 	_BPNotTab
.82fe	a9 20		lda #$20			lda 	#' '
.8300					_BPNotTab:
.8300	c9 20		cmp #$20			cmp 	#' ' 						; < ' ' = EOL
.8302	b0 ea		bcs $82ee			bcs 	_BPCopy 					; until a control character, should be 13 received.
.8304					_BPEndLine:
.8304	20 7b b4	jsr $b47b			jsr 	TokeniseLine 				; tokenise the line.
.8307	38		sec				sec 								; append not insert
.8308	20 9f a3	jsr $a39f			jsr 	MemoryInsertLine 			; append to current program
.830b	80 d6		bra $82e3			bra 	_BPLoop
.830d					_BPExit:
.830d	20 f3 83	jsr $83f3			jsr 	ClearCommand 				; clear variables etc.
.8310	60		rts				rts
.8311					_BLLoad:
>8311	4c 6f 61 64 69 6e 67 20				.text 	"Loading from Memory",13,0
>8319	66 72 6f 6d 20 4d 65 6d 6f 72 79 0d 00
.8326					BLReadByte:
.8326	ad ad 05	lda $05ad			lda 	BackLoadPointer 			; copy pointer to zTemp0
.8329	85 36		sta $36				sta 	zTemp0
.832b	ad ae 05	lda $05ae			lda 	BackLoadPointer+1
.832e	85 37		sta $37				sta 	zTemp0+1
.8330	b2 36		lda ($36)			lda 	(zTemp0) 					; read next byte
.8332	ee ad 05	inc $05ad			inc 	BackLoadPointer 			; bump pointer
.8335	d0 03		bne $833a			bne 	_BLNoCarry
.8337	ee ae 05	inc $05ae			inc 	BackLoadPointer+1
.833a					_BLNoCarry:
.833a	c9 00		cmp #$00			cmp 	#0
.833c	60		rts				rts
.05ad					BackLoadPointer:
>05ad							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/editor.asm

.833d					EditProgramCode:
.833d	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; find the line.
.8340	ae 2c 04	ldx $042c			ldx 	TokenLineNumber+1
.8343	20 43 a4	jsr $a443			jsr 	MemorySearch
.8346	90 05		bcc $834d			bcc 	_EPCNoDelete 				; reached the end don't delete
.8348	d0 03		bne $834d			bne 	_EPCNoDelete 				; found slot but didn't match, no delete
.834a	20 68 a3	jsr $a368			jsr 	MemoryDeleteLine 			; delete the line
.834d					_EPCNoDelete:
.834d	ad 2d 04	lda $042d			lda 	TokenBuffer 				; buffer empty
.8350	c9 80		cmp #$80			cmp 	#KWC_EOL
.8352	f0 0d		beq $8361			beq 	_EPCNoInsert
.8354	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; find the line - it cannot exist.
.8357	ae 2c 04	ldx $042c			ldx 	TokenLineNumber+1 			; so this can't fail, it returns some point in the code.
.835a	20 43 a4	jsr $a443			jsr 	MemorySearch
.835d	18		clc				clc 								; insert at this point.
.835e	20 9f a3	jsr $a39f			jsr 	MemoryInsertLine 			; insert the line
.8361					_EPCNoInsert:
.8361	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/warmstart.asm

.8362					WarmStart:
.8362	a2 ff		ldx #$ff			ldx 	#$FF
.8364	9a		txs				txs
.8365	20 df a7	jsr $a7df			jsr 	EXTInputLine 				; get line to lineBuffer
.8368	20 7b b4	jsr $b47b			jsr 	TokeniseLine 				; tokenise the line
.836b	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; line number ?
.836e	0d 2c 04	ora $042c			ora 	TokenLineNumber+1
.8371	d0 17		bne $838a			bne 	_WSEditCode 				; if so,edit code.
.8373	9c 2a 04	stz $042a			stz 	TokenOffset 				; zero offset, meaning it only runs one line.
.8376	a9 2a		lda #$2a			lda 	#((TokenOffset) & $FF)
.8378	85 30		sta $30				sta 	codePtr
.837a	a9 04		lda #$04			lda 	#((TokenOffset) >> 8)
.837c	85 31		sta $31				sta 	codePtr+1
.837e	ad 2d 04	lda $042d			lda 	TokenBuffer 				; nothing to run
.8381	c9 80		cmp #$80			cmp 	#KWC_EOL
.8383	f0 dd		beq $8362			beq 	WarmStart
.8385	20 6f 8a	jsr $8a6f			jsr 	RUNCodePointerLine 			; execute that line.
.8388	80 d8		bra $8362			bra 	WarmStart
.838a					_WSEditCode:
.838a	20 3d 83	jsr $833d			jsr 	EditProgramCode
.838d	20 f3 83	jsr $83f3			jsr 	ClearCommand
.8390	80 d0		bra $8362			bra 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assemble.asm

.8392					AssembleCommand:
.8392	a2 00		ldx #$00			ldx 	#0
.8394	20 5d 9c	jsr $9c5d			jsr 	Evaluate16BitInteger 		; start address
.8397	a5 58		lda $58				lda 	NSMantissa0
.8399	8d 1e 04	sta $041e			sta 	AssemblerAddress
.839c	a5 60		lda $60				lda 	NSMantissa1
.839e	8d 1f 04	sta $041f			sta 	AssemblerAddress+1
.83a1	20 bc 8d	jsr $8dbc			jsr 	CheckComma
.83a4	20 78 9c	jsr $9c78			jsr 	Evaluate8BitInteger 		; options
.83a7	a5 58		lda $58				lda 	NSMantissa0
.83a9	8d 20 04	sta $0420			sta 	AssemblerControl
.83ac	60		rts				rts
.83ad	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assert.asm

.83ae					AssertCommand:
.83ae	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.83b0	20 4a 9c	jsr $9c4a			jsr 	EvaluateInteger 			; the assert test
.83b3	20 ff 9c	jsr $9cff			jsr 	NSMIsZero 					; exit if result is non zero.
.83b6	d0 05		bne $83bd			bne 	_ACExit
.83b8	a9 0a		lda #$0a		lda	#10
.83ba	4c cd 8d	jmp $8dcd		jmp	ErrorHandler
.83bd					_ACExit:
.83bd	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/call.asm

.83be					CallCommand:
.83be	a2 00		ldx #$00			ldx 	#0 							; get the routine address to level 0
.83c0	20 5d 9c	jsr $9c5d			jsr 	Evaluate16BitInteger
.83c3					_CCClear
.83c3	e8		inx				inx  								; clear 1,2 and 3 (for A X Y)
.83c4	20 dd 9c	jsr $9cdd			jsr 	NSMSetZero 					; these are optional sequentially.
.83c7	e0 04		cpx #$04			cpx 	#4
.83c9	d0 f8		bne $83c3			bne 	_CCClear
.83cb	a2 00		ldx #$00			ldx 	#0 							; and keep trying while there are more values.
.83cd					_CCCParam:
.83cd	b1 30		lda ($30),y			lda 	(codePtr),y
.83cf	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.83d1	d0 09		bne $83dc			bne 	_CCCRun6502
.83d3	c8		iny				iny 								; skip comma
.83d4	e8		inx				inx	 								; next level
.83d5	20 78 9c	jsr $9c78			jsr 	Evaluate8BitInteger 		; get A/X/Y
.83d8	e0 03		cpx #$03			cpx 	#3
.83da	90 f1		bcc $83cd			bcc 	_CCCParam 					; done all 3 ?
.83dc					_CCCRun6502:
.83dc	5a		phy				phy 								; save position
.83dd	a5 60		lda $60				lda 	NSMantissa1 				; put address in zTemp0
.83df	85 37		sta $37				sta 	zTemp0+1
.83e1	a5 58		lda $58				lda 	NSMantissa0
.83e3	85 36		sta $36				sta 	zTemp0
.83e5	a5 59		lda $59				lda 	NSMantissa0+1 				; get registers into A X Y
.83e7	a6 5a		ldx $5a				ldx 	NSMantissa0+2
.83e9	a4 5b		ldy $5b				ldy 	NSMantissa0+3
.83eb	20 f0 83	jsr $83f0			jsr 	_CCCZTemp0 					; call zTemp0
.83ee	7a		ply				ply 								; restore position and exit
.83ef	60		rts				rts
.83f0					_CCCZTemp0:
.83f0	6c 36 00	jmp ($0036)			jmp 	(zTemp0)

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/clear.asm

.83f3					ClearCommand:
.83f3	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.83f5	85 36		sta $36				sta 	0+zTemp0
.83f7	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.83f9	85 37		sta $37				sta 	1+zTemp0
.83fb					_ClearZeroLoop:
.83fb	b2 36		lda ($36)			lda 	(zTemp0) 					; end of variables if offset is zero.
.83fd	f0 24		beq $8423			beq 	_ClearZeroEnd
.83ff	a0 03		ldy #$03			ldy 	#3 							; erase the variables
.8401	a9 00		lda #$00			lda 	#0 							; set all the data to zero.
.8403					_ClearOneVariable:
.8403	91 36		sta ($36),y			sta 	(zTemp0),y
.8405	c8		iny				iny
.8406	c0 08		cpy #$08			cpy 	#8
.8408	d0 f9		bne $8403			bne 	_ClearOneVariable
.840a	a0 02		ldy #$02			ldy 	#2 							; has it been marked procedure
.840c	b1 36		lda ($36),y			lda 	(zTemp0),y
.840e	c9 18		cmp #$18			cmp 	#NSTProcedure
.8410	d0 04		bne $8416			bne 	_ClearNotProcedure
.8412	a9 04		lda #$04			lda 	#NSTInteger+NSBIsArray 		; if so set it back to an integer array
.8414	91 36		sta ($36),y			sta 	(zTemp0),y 					; will be fixed on the pre-run scan.
.8416					_ClearNotProcedure:
.8416	18		clc				clc 								; go to the next variable
.8417	b2 36		lda ($36)			lda 	(zTemp0) 					; offset to next, add to zTemp0
.8419	65 36		adc $36				adc 	zTemp0
.841b	85 36		sta $36				sta 	zTemp0
.841d	90 dc		bcc $83fb			bcc 	_ClearZeroLoop
.841f	e6 37		inc $37				inc 	zTemp0+1
.8421	80 d8		bra $83fb			bra 	_ClearZeroLoop
.8423					_ClearZeroEnd:
.8423	18		clc				clc
.8424	a5 36		lda $36				lda 	zTemp0
.8426	69 01		adc #$01			adc 	#1
.8428	8d 0c 04	sta $040c			sta 	lowMemPtr
.842b	a5 37		lda $37				lda 	zTemp0+1
.842d	69 00		adc #$00			adc 	#0
.842f	8d 0d 04	sta $040d			sta 	lowMemPtr+1
.8432	20 7f a5	jsr $a57f			jsr 	StackReset
.8435	20 e5 a5	jsr $a5e5			jsr 	StringSystemInitialise
.8438	20 bd 8c	jsr $8cbd			jsr 	ProcedureScan
.843b	20 1e 8a	jsr $8a1e			jsr 	Command_Restore
.843e	9c 1e 04	stz $041e			stz 	AssemblerAddress
.8441	9c 1f 04	stz $041f			stz 	AssemblerAddress+1
.8444	9c 20 04	stz $0420			stz 	AssemblerControl
.8447	20 02 99	jsr $9902			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.844a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/cls.asm

.844b					ClearScreen:
.844b	5a		phy				phy
.844c	a9 0c		lda #$0c			lda 	#12 						; char code 12 clears the screen.
.844e	20 51 a6	jsr $a651			jsr 	EXTPrintCharacter
.8451	7a		ply				ply
.8452	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/data.asm

.8453					Command_Data:
.8453	a9 3a		lda #$3a			lda 	#KWD_COLON 					; advance to colon/EOL
.8455	a2 80		ldx #$80			ldx 	#KWC_EOL
.8457	20 0f 8d	jsr $8d0f			jsr 	ScanForward
.845a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dim.asm

.845b					DimCommand:
.845b	b1 30		lda ($30),y			lda 	(codePtr),y
.845d	29 c0		and #$c0			and 	#$C0
.845f	c9 40		cmp #$40			cmp 	#$40
.8461	d0 7a		bne $84dd			bne 	_DCSyntax
.8463	b1 30		lda ($30),y			lda 	(codePtr),y
.8465	18		clc				clc
.8466	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8468	85 3f		sta $3f				sta 	zaTemp+1
.846a	c8		iny				iny
.846b	b1 30		lda ($30),y			lda 	(codePtr),y
.846d	c8		iny				iny
.846e	85 3e		sta $3e				sta 	zaTemp
.8470	5a		phy				phy
.8471	a0 02		ldy #$02			ldy 	#2 						; read type byte
.8473	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8475	29 18		and #$18			and 	#NSBTypeMask 			; check it's not a procedure
.8477	c9 18		cmp #$18			cmp 	#NSTProcedure
.8479	f0 62		beq $84dd			beq 	_DCSyntax
.847b	b1 3e		lda ($3e),y			lda 	(zaTemp),y 				; check it's an array
.847d	29 04		and #$04			and 	#NSBIsArray
.847f	f0 64		beq $84e5			beq 	_DCType
.8481	a0 04		ldy #$04			ldy 	#4 						; check not already defined
.8483	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8485	d0 59		bne $84e0			bne 	_DCRedefine
.8487	7a		ply				ply
.8488	20 e8 84	jsr $84e8			jsr 	_DCGetSize 				; get array size, check it.
.848b	5a		phy				phy
.848c	a0 05		ldy #$05			ldy 	#5 						; store in first array size slot
.848e	91 3e		sta ($3e),y			sta 	(zaTemp),y 				; second will be zero.
.8490	7a		ply				ply 							; is there a second (e.g. ,x)
.8491	b1 30		lda ($30),y			lda 	(codePtr),y
.8493	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8495	d0 0a		bne $84a1			bne 	_DCOneDimension
.8497	c8		iny				iny 							; skip comma
.8498	20 e8 84	jsr $84e8			jsr 	_DCGetSize 				; get 2nd array size
.849b	5a		phy				phy
.849c	a0 06		ldy #$06			ldy 	#6 						; store in 2nd array size
.849e	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84a0	7a		ply				ply
.84a1					_DCOneDimension:
.84a1	5a		phy				phy 							; save position
.84a2	a0 05		ldy #$05			ldy 	#5 						; dimensions + 1 in AX (as zero based)
.84a4	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84a6	aa		tax				tax
.84a7	c8		iny				iny
.84a8	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84aa	e8		inx				inx 							; bump them.
.84ab	1a		inc a				inc 	a
.84ac	20 88 9c	jsr $9c88			jsr 	Multiply8x8 			; work out the total number of elements -> zTemp0
.84af	a5 37		lda $37				lda 	zTemp0+1 				; don't allow more than 8192 elements whatever
.84b1	29 e0		and #$e0			and 	#$E0
.84b3	d0 23		bne $84d8			bne 	_DCSize
.84b5	a0 02		ldy #$02			ldy 	#2 						; get base type
.84b7	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84b9	20 f6 84	jsr $84f6			jsr 	ScaleByBaseType 		; scale by base type
.84bc	a5 36		lda $36				lda 	zTemp0
.84be	a6 37		ldx $37				ldx 	zTemp0+1
.84c0	20 c4 98	jsr $98c4			jsr 	AllocateXABytes 		; allocate memory
.84c3	a0 03		ldy #$03			ldy 	#3 						; copy into the address.
.84c5	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84c7	c8		iny				iny
.84c8	8a		txa				txa
.84c9	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84cb	7a		ply				ply 							; get position back
.84cc	20 b4 8d	jsr $8db4			jsr 	CheckRightBracket 		; check )
.84cf	b1 30		lda ($30),y			lda 	(codePtr),y
.84d1	c8		iny				iny 							; consume in case
.84d2	c9 2c		cmp #$2c			cmp 	#KWD_COMMA		 		; if so do another DIM.
.84d4	f0 85		beq $845b			beq 	DimCommand
.84d6	88		dey				dey 							; undo consume
.84d7	60		rts				rts
.84d8					_DCSize:
.84d8	a9 16		lda #$16		lda	#22
.84da	4c cd 8d	jmp $8dcd		jmp	ErrorHandler
.84dd					_DCSyntax:
.84dd	4c 55 9e	jmp $9e55			jmp 	SyntaxError
.84e0					_DCRedefine:
.84e0	a9 15		lda #$15		lda	#21
.84e2	4c cd 8d	jmp $8dcd		jmp	ErrorHandler
.84e5					_DCType:
.84e5	4c 5f 9e	jmp $9e5f			jmp 	TypeError
.84e8					_DCGetSize:
.84e8	a2 00		ldx #$00			ldx 	#0 						; get first index.
.84ea	20 78 9c	jsr $9c78			jsr 	Evaluate8BitInteger 	; get array dimension
.84ed	c9 00		cmp #$00			cmp 	#0 						; must be 1-254
.84ef	f0 e7		beq $84d8			beq 	_DCSize
.84f1	c9 fe		cmp #$fe			cmp 	#254
.84f3	f0 e3		beq $84d8			beq 	_DCSize
.84f5	60		rts				rts
.84f6					ScaleByBaseType:
.84f6	29 10		and #$10			and 	#NSBIsString 			; is it string
.84f8	d0 19		bne $8513			bne 	_SBBTString
.84fa	a5 37		lda $37				lda 	zTemp0+1 				; push value on stack
.84fc	48		pha				pha
.84fd	a5 36		lda $36				lda 	zTemp0
.84ff	48		pha				pha
.8500	06 36		asl $36				asl 	zTemp0 					; x 2
.8502	26 37		rol $37				rol 	zTemp0+1
.8504	06 36		asl $36				asl 	zTemp0 					; x 4
.8506	26 37		rol $37				rol 	zTemp0+1
.8508	68		pla				pla 							; add stacked value = x 5
.8509	65 36		adc $36				adc 	zTemp0
.850b	85 36		sta $36				sta 	zTemp0
.850d	68		pla				pla
.850e	65 37		adc $37				adc 	zTemp0+1
.8510	85 37		sta $37				sta 	zTemp0+1
.8512	60		rts				rts
.8513					_SBBTString:
.8513	06 36		asl $36				asl 	zTemp0
.8515	26 37		rol $37				rol 	zTemp0+1
.8517	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/end.asm

.8518					EndCommand:
.8518	4c 62 83	jmp $8362			jmp 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/for.asm

.851b					ForCommand:
.851b	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; allocate 18 bytes on the return stack.
.851d	20 1a a5	jsr $a51a			jsr 	StackOpen
.8520	a2 00		ldx #$00			ldx 	#0
.8522	20 1b 97	jsr $971b			jsr 	EvaluateTerm
.8525	b5 50		lda $50,x			lda 	NSStatus,x
.8527	c9 20		cmp #$20			cmp 	#NSBIsReference+NSTInteger 	; do we have an integer 4 byte reference.
.8529	d0 47		bne $8572			bne		_FCError
.852b	a9 3d		lda #$3d			lda 	#KWD_EQUAL 					; =
.852d	20 c4 8d	jsr $8dc4			jsr 	CheckNextA
.8530	e8		inx				inx
.8531	20 4a 9c	jsr $9c4a			jsr 	EvaluateInteger 			; <from> in +1
.8534	b1 30		lda ($30),y			lda 	(codePtr),y
.8536	c8		iny				iny 								; consume it
.8537	48		pha				pha 								; save on stack for later
.8538	c9 b4		cmp #$b4			cmp 	#KWD_DOWNTO
.853a	f0 04		beq $8540			beq 	_FCNoSyntax
.853c	c9 ce		cmp #$ce			cmp 	#KWD_TO
.853e	d0 35		bne $8575			bne 	_FCSyntaxError
.8540					_FCNoSyntax:
.8540	e8		inx				inx
.8541	20 4a 9c	jsr $9c4a			jsr 	EvaluateInteger
.8544	20 5e a5	jsr $a55e			jsr 	STKSaveCodePosition 		; save loop back position
.8547	68		pla				pla 								; restore DOWNTO or TO
.8548	5a		phy				phy 								; save Y on the stack
.8549	49 b4		eor #$b4			eor 	#KWD_DOWNTO 				; 0 if DOWNTO, #0 if TO
.854b	f0 02		beq $854f			beq 	_FCNotDownTo
.854d	a9 02		lda #$02			lda 	#2
.854f					_FCNotDownTo:
.854f	3a		dec a				dec 	a 							; 255 if DOWNTO, 1 if TO
.8550	a0 10		ldy #$10			ldy 	#16
.8552	91 34		sta ($34),y			sta 	(basicStack),y 				; copy that out to the Basic Stack.
.8554	a0 06		ldy #$06			ldy 	#6
.8556	a5 58		lda $58				lda 	NSMantissa0
.8558	91 34		sta ($34),y			sta 	(basicStack),y
.855a	a5 60		lda $60				lda 	NSMantissa1
.855c	c8		iny				iny
.855d	91 34		sta ($34),y			sta 	(basicStack),y
.855f	a0 08		ldy #$08			ldy 	#8 							; set initial index value
.8561	a2 01		ldx #$01			ldx 	#1
.8563	20 78 85	jsr $8578			jsr 	FCIntegerToStack
.8566	a0 0c		ldy #$0c			ldy 	#12 						; set the terminal value
.8568	a2 02		ldx #$02			ldx 	#2
.856a	20 78 85	jsr $8578			jsr 	FCIntegerToStack
.856d	20 93 85	jsr $8593			jsr 	CopyIndexToReference
.8570	7a		ply				ply 								; restore position
.8571	60		rts				rts
.8572					_FCError:
.8572	4c 5f 9e	jmp $9e5f			jmp 	TypeError
.8575					_FCSyntaxError:
.8575	4c 55 9e	jmp $9e55			jmp 	SyntaxError
.8578					FCIntegerToStack:
.8578	34 50		bit $50,x			bit 	NSStatus,x 					; is the value negative
.857a	10 03		bpl $857f			bpl	 	_FCNotNegative
.857c	20 a6 9c	jsr $9ca6			jsr 	NSMNegateMantissa 			; if so 2's complement the mantissa
.857f					_FCNotNegative:
.857f	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy out to the basic stack
.8581	91 34		sta ($34),y			sta 	(basicStack),y
.8583	c8		iny				iny
.8584	b5 60		lda $60,x			lda 	NSMantissa1,x
.8586	91 34		sta ($34),y			sta 	(basicStack),y
.8588	c8		iny				iny
.8589	b5 68		lda $68,x			lda 	NSMantissa2,x
.858b	91 34		sta ($34),y			sta 	(basicStack),y
.858d	c8		iny				iny
.858e	b5 70		lda $70,x			lda 	NSMantissa3,x
.8590	91 34		sta ($34),y			sta 	(basicStack),y
.8592	60		rts				rts
.8593					CopyIndexToReference:
.8593	5a		phy				phy
.8594	a0 06		ldy #$06			ldy 	#6 							; copy address-8 to write to zTemp0
.8596	38		sec				sec 								; (because we copy from offset 8)
.8597	b1 34		lda ($34),y			lda 	(basicStack),y
.8599	e9 08		sbc #$08			sbc 	#8
.859b	85 36		sta $36				sta 	zTemp0
.859d	c8		iny				iny
.859e	b1 34		lda ($34),y			lda 	(basicStack),y
.85a0	e9 00		sbc #$00			sbc 	#0
.85a2	85 37		sta $37				sta 	zTemp0+1
.85a4	a2 04		ldx #$04			ldx 	#4 							; this is the copy counter/
.85a6	a0 0b		ldy #$0b			ldy 	#8+3 		 				; the MSB of the mantissa
.85a8	b1 34		lda ($34),y			lda 	(basicStack),y
.85aa	0a		asl a				asl 	a 							; into carry
.85ab	a0 08		ldy #$08			ldy 	#8 							; where to copy from.
.85ad	90 14		bcc $85c3			bcc 	_CITRNormal
.85af	38		sec				sec
.85b0					_CITRNegative:
.85b0	a9 00		lda #$00			lda 	#0
.85b2	f1 34		sbc ($34),y			sbc 	(basicStack),y
.85b4	91 36		sta ($36),y			sta 	(zTemp0),y
.85b6	c8		iny				iny
.85b7	ca		dex				dex
.85b8	d0 f6		bne $85b0			bne 	_CITRNegative
.85ba	88		dey				dey 								; look at MSB of mantissa
.85bb	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set the MSB as negative packed.
.85bd	09 80		ora #$80			ora 	#$80
.85bf	91 36		sta ($36),y			sta 	(zTemp0),y
.85c1	7a		ply				ply
.85c2	60		rts				rts
.85c3					_CITRNormal:
.85c3	b1 34		lda ($34),y			lda 	(basicStack),y 				; copy without negation.
.85c5	91 36		sta ($36),y			sta 	(zTemp0),y
.85c7	c8		iny				iny
.85c8	ca		dex				dex
.85c9	d0 f8		bne $85c3			bne 	_CITRNormal
.85cb	7a		ply				ply 								; and exit.
.85cc	60		rts				rts
.85cd					NextCommand:
.85cd	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; check FOR is TOS
.85cf	a2 11		ldx #$11			ldx 	#ERRID_FOR 					; this error
.85d1	20 46 a5	jsr $a546			jsr 	StackCheckFrame
.85d4	5a		phy				phy
.85d5	a0 10		ldy #$10			ldy 	#16 						; get the step count
.85d7	b1 34		lda ($34),y			lda 	(basicStack),y
.85d9	85 36		sta $36				sta 	zTemp0 						; this is the sign extend
.85db	30 02		bmi $85df			bmi 	_NCStepNeg
.85dd	64 36		stz $36				stz 	zTemp0 						; which is 0 or 255
.85df					_NCStepNeg:
.85df	a0 08		ldy #$08			ldy 	#8 							; offset to bump
.85e1	a2 04		ldx #$04			ldx 	#4 							; count to bump
.85e3	18		clc				clc
.85e4					_NCBump:
.85e4	71 34		adc ($34),y			adc 	(basicStack),y 				; add it
.85e6	91 34		sta ($34),y			sta 	(basicStack),y
.85e8	a5 36		lda $36				lda 	zTemp0 						; get sign extend for next time.
.85ea	c8		iny				iny 								; next byte
.85eb	ca		dex				dex 								; do four times
.85ec	d0 f6		bne $85e4			bne 	_NCBump
.85ee	20 93 85	jsr $8593			jsr		CopyIndexToReference		; copy it to the reference variable.
.85f1	a0 10		ldy #$10			ldy 	#16 						; get step count again
.85f3	b1 34		lda ($34),y			lda 	(basicStack),y
.85f5	0a		asl a				asl 	a 							; sign bit to carry
.85f6	a9 0c		lda #$0c			lda 	#12 						; offset of LHS = terminal offset
.85f8	85 38		sta $38				sta 	zTemp1
.85fa	90 02		bcc $85fe			bcc 	_NCCompRev 					; use if step is +ve
.85fc	a9 08		lda #$08			lda 	#8 							; now the LHS = index value
.85fe					_NCCompRev:
.85fe	85 38		sta $38				sta 	zTemp1 						; so zTemp0 is the index for LHS
.8600	49 04		eor #$04			eor 	#(8^12) 					; and zTemp0+1 is the index for RHS
.8602	85 39		sta $39				sta 	zTemp1+1
.8604	a2 04		ldx #$04			ldx 	#4 							; bytes to compare
.8606	38		sec				sec
.8607					_NCCompare:
.8607	a4 38		ldy $38				ldy 	zTemp1 						; do compare using the two indices
.8609	b1 34		lda ($34),y			lda 	(basicStack),y
.860b	a4 39		ldy $39				ldy 	zTemp1+1
.860d	f1 34		sbc ($34),y			sbc 	(basicStack),y
.860f	e6 38		inc $38				inc 	zTemp1 						; bump the indices (inc,dex do not change C or V)
.8611	e6 39		inc $39				inc 	zTemp1+1
.8613	ca		dex				dex 								; do it 4 times.
.8614	d0 f1		bne $8607			bne 	_NCCompare
.8616	50 02		bvc $861a			bvc 	_NCNoOverflow 				; convert to signed comparison
.8618	49 80		eor #$80			eor 	#$80
.861a					_NCNoOverflow:
.861a	7a		ply				ply 								; restore Y position
.861b	0a		asl a				asl 	a 							; is bit 7 set.
.861c	90 04		bcc $8622			bcc 	_NCLoopback 				; if no , >= so loop back
.861e	20 38 a5	jsr $a538			jsr 	StackClose 					; exit the loop
.8621	60		rts				rts
.8622					_NCLoopBack:
.8622	20 6f a5	jsr $a56f			jsr 	STKLoadCodePosition 		; loop back
.8625	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/gosub.asm

.8626					Command_GOSUB:
.8626	a2 00		ldx #$00			ldx 	#0
.8628	20 5d 9c	jsr $9c5d			jsr 	Evaluate16BitInteger 		; line number in Stack.0
.862b	a9 e3		lda #$e3			lda 	#STK_GOSUB+3
.862d	20 1a a5	jsr $a51a			jsr 	StackOpen 					; create frame
.8630	20 5e a5	jsr $a55e			jsr 	STKSaveCodePosition 		; save current position
.8633	4c 49 86	jmp $8649			jmp 	GotoStackX
.8636					Command_RETURN:
.8636	a9 e0		lda #$e0			lda 	#STK_GOSUB 					; check TOS is this
.8638	a2 0e		ldx #$0e			ldx 	#ERRID_GOSUB 				; this error
.863a	20 46 a5	jsr $a546			jsr 	StackCheckFrame
.863d	20 6f a5	jsr $a56f			jsr 	STKLoadCodePosition 		; restore code position
.8640	20 38 a5	jsr $a538			jsr 	StackClose
.8643	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/goto.asm

.8644					GotoCommand:
.8644	a2 00		ldx #$00			ldx 	#0 							; GOTO where
.8646	20 5d 9c	jsr $9c5d			jsr 	Evaluate16BitInteger
.8649					GotoStackX:
.8649	b5 60		lda $60,x			lda  	NSMantissa1,x 				; put line # in XA. I'll keep this even though
.864b	48		pha				pha 								; it is slightly inefficient, just in cases.
.864c	b5 58		lda $58,x			lda 	NSMantissa0,x
.864e	fa		plx				plx
.864f	20 43 a4	jsr $a443			jsr 	MemorySearch 				; transfer to line number AX.
.8652	90 05		bcc $8659			bcc 	_GotoError 					; not found, off end.
.8654	d0 03		bne $8659			bne 	_GotoError 					; not found exactly
.8656	4c 68 8a	jmp $8a68			jmp 	RunNewLine 					; and go straight to new line code.
.8659					_GotoError:
.8659	a9 0d		lda #$0d		lda	#13
.865b	4c cd 8d	jmp $8dcd		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/if.asm

.865e					IfCommand:
.865e	a2 00		ldx #$00			ldx 	#0 							; If what.
.8660	20 2b 9c	jsr $9c2b			jsr 	EvaluateNumber
.8663	b1 30		lda ($30),y			lda 	(codePtr),y
.8665	c9 a8		cmp #$a8			cmp 	#KWD_THEN  					; could be THEN <stuff> or GOTO
.8667	d0 0a		bne $8673			bne 	_IFStructured
.8669	c8		iny				iny 								; consume THEN
.866a	20 ff 9c	jsr $9cff			jsr 	NSMIsZero 					; is it zero
.866d	f0 01		beq $8670			beq 	_IfFail 					; if fail, go to next line
.866f	60		rts				rts 								; if THEN just continue
.8670					_IfFail:
.8670	4c 50 8a	jmp $8a50			jmp 	EOLCommand
.8673					_IfStructured:
.8673	20 ff 9c	jsr $9cff			jsr 	NSMIsZero 					; is it zero
.8676	d0 07		bne $867f			bne 	_IfExit 					; if not, then continue normally.
.8678	a9 b5		lda #$b5			lda 	#KWD_ELSE 					; look for else/endif
.867a	a2 a5		ldx #$a5			ldx 	#KWD_ENDIF
.867c	20 0f 8d	jsr $8d0f			jsr 	ScanForward 				; and run from there/
.867f					_IfExit:
.867f	60		rts				rts
.8680					ElseCode:
.8680	a9 a5		lda #$a5			lda 	#KWD_ENDIF 					; else is only run after the if clause succeeds
.8682	aa		tax				tax 								; so just go to the structure exit
.8683	20 0f 8d	jsr $8d0f			jsr 	ScanForward
.8686	60		rts				rts
.8687					EndIf:
.8687	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/inputprint.asm

.8688					Command_Input:
.8688	a9 ff		lda #$ff			lda 	#$FF
.868a	8d 28 04	sta $0428			sta 	IsInputFlag
.868d	80 03		bra $8692			bra 	Command_IP_Main
.868f					Command_Print:
.868f	9c 28 04	stz $0428			stz 	IsInputFlag
.8692					Command_IP_Main:
.8692	18		clc				clc 								; carry being clear means last print wasn't comma/semicolon
.8693					_CPLoop:
.8693	08		php				php 								; save last action flag
.8694	b1 30		lda ($30),y			lda 	(codePtr),y
.8696	c9 80		cmp #$80			cmp  	#KWC_EOL 					; end of line or colon, exit now.
.8698	f0 54		beq $86ee			beq 	_CPExit
.869a	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.869c	f0 50		beq $86ee			beq 	_CPExit
.869e	68		pla				pla 								; throw last action flag
.869f	b1 30		lda ($30),y			lda 	(codePtr),y
.86a1	c8		iny				iny
.86a2	c9 3b		cmp #$3b			cmp 	#KWD_SEMICOLON				; is it a semicolon
.86a4	f0 45		beq $86eb			beq 	_CPContinueWithSameLine
.86a6	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; comma
.86a8	f0 3c		beq $86e6			beq 	_CPTab
.86aa	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; apostrophe (new line)
.86ac	f0 34		beq $86e2			beq 	_CPNewLine
.86ae	88		dey				dey 								; undo the get.
.86af	20 cf 92	jsr $92cf			jsr 	EvaluateExpressionAt0 		; evaluate expression at 0.
.86b2	b5 50		lda $50,x			lda 	NSStatus,x 					; read the status
.86b4	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.86b6	f0 0d		beq $86c5			beq 	_CPIsValue
.86b8	ad 28 04	lda $0428			lda 	IsInputFlag 				; if print, dereference and print.
.86bb	f0 05		beq $86c2			beq 	_CPIsPrint
.86bd	20 f7 86	jsr $86f7			jsr 	CIInputValue 				; input a value to the reference
.86c0	80 20		bra $86e2			bra 	_CPNewLine
.86c2					_CPIsPrint:
.86c2	20 94 95	jsr $9594			jsr 	Dereference
.86c5					_CPIsValue:
.86c5	b5 50		lda $50,x			lda 	NSStatus,x 					; is it a number
.86c7	29 10		and #$10			and 	#NSBIsString
.86c9	f0 09		beq $86d4			beq 	_CPNumber
.86cb	a6 60		ldx $60				ldx 	NSMantissa1 				; string, print the text.
.86cd	a5 58		lda $58				lda 	NSMantissa0
.86cf	20 5a 87	jsr $875a			jsr 	CPPrintStringXA
.86d2	80 be		bra $8692			bra 	Command_IP_Main 			; loop round clearing carry so NL if end
.86d4					_CPNumber:
.86d4	a9 05		lda #$05			lda 	#5 							; maximum decimals
.86d6	20 12 9b	jsr $9b12			jsr 	ConvertNumberToString 		; convert to string
.86d9	a2 05		ldx #$05			ldx 	#DecimalBuffer >> 8
.86db	a9 9d		lda #$9d			lda 	#DecimalBuffer & $FF
.86dd	20 5a 87	jsr $875a			jsr 	CPPrintStringXA
.86e0	80 b0		bra $8692			bra 	Command_IP_Main				; loop round clearing carry so NL if end
.86e2					_CPNewLine:
.86e2	a9 0d		lda #$0d			lda 	#13
.86e4	80 02		bra $86e8			bra 	_CPPrintChar
.86e6					_CPTab:
.86e6	a9 09		lda #$09			lda 	#9 							; print TAB
.86e8					_CPPrintChar:
.86e8	20 6d 87	jsr $876d			jsr 	CPPrintVector
.86eb					_CPContinueWithSameLine:
.86eb	38		sec				sec 								; loop round with carry set, which
.86ec	80 a5		bra $8693			bra 	_CPLoop 					; will inhibit final CR
.86ee					_CPExit:
.86ee	28		plp				plp 								; get last action flag
.86ef	b0 05		bcs $86f6			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.86f1	a9 0d		lda #$0d			lda 	#13 						; print new line
.86f3	20 6d 87	jsr $876d			jsr 	CPPrintVector
.86f6					_CPExit2:
.86f6	60		rts				rts
.86f7					CIInputValue:
.86f7	a2 00		ldx #$00			ldx 	#0 							; input a line.
.86f9					_CIInputLine:
.86f9	20 70 87	jsr $8770			jsr 	CPInputVector 				; get key
.86fc	c9 0d		cmp #$0d			cmp 	#13 						; 13 = End
.86fe	f0 1f		beq $871f			beq 	_CIHaveValue
.8700	c9 08		cmp #$08			cmp 	#8 							; 8 = BS
.8702	f0 11		beq $8715			beq 	_CIBackspace
.8704	c9 20		cmp #$20			cmp 	#32 						; ignore other control characters
.8706	90 f1		bcc $86f9			bcc 	_CIInputLine
.8708	e0 50		cpx #$50			cpx 	#80 						; max length
.870a	b0 ed		bcs $86f9			bcs 	_CIInputLine
.870c	9d 2a 05	sta $052a,x			sta 	lineBuffer,x
.870f	e8		inx				inx
.8710	20 6d 87	jsr $876d			jsr 	CPPrintVector 				; echo it.
.8713	80 e4		bra $86f9			bra 	_CIInputLine
.8715					_CIBackSpace:
.8715	e0 00		cpx #$00			cpx 	#0 							; nothing to delete
.8717	f0 e0		beq $86f9			beq 	_CIInputLine
.8719	20 6d 87	jsr $876d			jsr 	CPPrintVector 				; echo it.
.871c	ca		dex				dex
.871d	80 da		bra $86f9			bra 	_CIInputLine
.871f					_CIHaveValue:
.871f	9e 2a 05	stz $052a,x			stz 	LineBuffer,x 				; ASCIIZ string now in line buffer.
.8722	a5 50		lda $50				lda 	NSStatus 					; was it a string assignment
.8724	29 10		and #$10			and 	#NSBIsString
.8726	f0 17		beq $873f			beq 	_CIAssignNumber 			; assign a number
.8728	a2 01		ldx #$01			ldx 	#1
.872a	a9 2a		lda #$2a			lda 	#lineBuffer & $FF 			; set up to point to new string
.872c	95 58		sta $58,x			sta 	NSMantissa0,x
.872e	a9 05		lda #$05			lda 	#lineBuffer >> 8
.8730	95 60		sta $60,x			sta 	NSMantissa1,x
.8732	74 68		stz $68,x			stz 	NSMantissa2,x
.8734	74 70		stz $70,x			stz 	NSMantissa3,x
.8736	a9 10		lda #$10			lda 	#NSBIsString 				; so it becomes a string value
.8738	95 50		sta $50,x			sta  	NSStatus,x
.873a	ca		dex				dex 								; X = 0
.873b	20 ac 87	jsr $87ac			jsr 	AssignVariable
.873e	60		rts				rts
.873f					_CIAssignNumber:
.873f	a9 2a		lda #$2a			lda 	#lineBuffer & $FF 			; set up to point to new string
.8741	85 36		sta $36				sta 	zTemp0
.8743	a9 05		lda #$05			lda 	#lineBuffer >> 8
.8745	85 37		sta $37				sta 	zTemp0+1
.8747	a2 01		ldx #$01			ldx 	#1 							; put in slot 1
.8749	20 94 9a	jsr $9a94			jsr 	ValEvaluateZTemp0 			; use the VAL() code
.874c	90 07		bcc $8755			bcc 	_CIIsOkay
.874e	a9 3f		lda #$3f			lda 	#"?" 						; error ?
.8750	20 6d 87	jsr $876d			jsr 	CPPrintVector
.8753	80 a2		bra $86f7			bra 	CIInputValue
.8755					_CIIsOkay:
.8755	ca		dex				dex 								; X = 0
.8756	20 ac 87	jsr $87ac			jsr 	AssignVariable
.8759	60		rts				rts
.875a					CPPrintStringXA:
.875a	5a		phy				phy
.875b	86 37		stx $37				stx 	zTemp0+1
.875d	85 36		sta $36				sta 	zTemp0
.875f	a0 00		ldy #$00			ldy 	#0
.8761					_PSXALoop:
.8761	b1 36		lda ($36),y			lda 	(zTemp0),y
.8763	f0 06		beq $876b			beq 	_PSXAExit
.8765	20 6d 87	jsr $876d			jsr 	CPPrintVector
.8768	c8		iny				iny
.8769	80 f6		bra $8761			bra 	_PSXALoop
.876b					_PSXAExit:
.876b	7a		ply				ply
.876c	60		rts				rts
.876d					CPPrintVector:
.876d	4c 51 a6	jmp $a651			jmp 	EXTPrintCharacter
.8770					CPInputVector:
.8770	4c e7 a8	jmp $a8e7			jmp 	EXTInputSingleCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/let.asm

.8773					LetCommand:
.8773	a2 00		ldx #$00			ldx 	#0
.8775	b1 30		lda ($30),y			lda 	(codePtr),y
.8777	c9 10		cmp #$10			cmp 	#KWD_AT
.8779	d0 14		bne $878f			bne 	_LCStandard
.877b	c8		iny				iny 								; skip equal
.877c	20 1b 97	jsr $971b			jsr 	EvaluateTerm 				; get a number
.877f	20 94 95	jsr $9594			jsr 	Dereference 				; dereference it
.8782	b5 50		lda $50,x			lda 	NSStatus,x 					; check integer
.8784	49 20		eor #$20			eor 	#NSBIsReference	 			; toggle reference
.8786	95 50		sta $50,x			sta 	NSStatus,x
.8788	29 20		and #$20			and 	#NSBIsReference 			; if it is now a reference, continue
.878a	d0 0f		bne $879b			bne 	_LCMain
.878c	4c 5f 9e	jmp $9e5f			jmp 	TypeError 					; was a reference before.
.878f					_LCStandard:
.878f	ad b9 92	lda $92b9			lda 	PrecedenceLevel+"*"			; precedence > this
.8792	20 d3 92	jsr $92d3			jsr 	EvaluateExpressionAtPrecedence
.8795	b5 50		lda $50,x			lda 	NSStatus,x 					; is it a reference to an array
.8797	c9 38		cmp #$38			cmp		#NSTProcedure+NSBIsReference
.8799	f0 0e		beq $87a9			beq 	_LetGoProc 					; it's a procedure call.
.879b					_LCMain:
.879b	a9 3d		lda #$3d			lda 	#"=" 						; check =
.879d	20 c4 8d	jsr $8dc4			jsr 	CheckNextA
.87a0	e8		inx				inx 								; RHS
.87a1	20 22 9c	jsr $9c22			jsr 	EvaluateValue
.87a4	ca		dex				dex
.87a5	20 ac 87	jsr $87ac			jsr 	AssignVariable
.87a8	60		rts				rts
.87a9					_LetGoProc:
.87a9	4c 2b 89	jmp $892b			jmp 	CallProcedure
.87ac					AssignVariable:
.87ac	b5 50		lda $50,x			lda 	NSStatus,x 					; check the string/number type bits match
.87ae	48		pha				pha 								; save a copy
.87af	55 51		eor $51,x			eor 	NSStatus+1,x
.87b1	29 10		and #$10			and 	#NSBIsString
.87b3	d0 0b		bne $87c0			bne 	_ASError
.87b5	68		pla				pla 								; get back
.87b6	29 10		and #$10			and 	#NSBIsString 				; check type
.87b8	d0 03		bne $87bd			bne 	_ASString
.87ba	4c d2 94	jmp $94d2			jmp 	AssignNumber
.87bd					_ASString:
.87bd	4c 30 95	jmp $9530			jmp 	AssignString
.87c0					_ASError:
.87c0	4c 5f 9e	jmp $9e5f			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/list.asm

.87c3					Command_List:
.87c3	9c 26 04	stz $0426			stz 	listIndent 					; reset indent.
.87c6	64 5c		stz $5c				stz		NSMantissa0+4				; set the lower (slot 4) to 0 and upper (slot 7) to $FFFF
.87c8	64 64		stz $64				stz 	NSMantissa1+4
.87ca	a9 ff		lda #$ff			lda 	#$FF
.87cc	85 5f		sta $5f				sta 	NSMantissa0+7
.87ce	85 67		sta $67				sta 	NSMantissa1+7
.87d0	b1 30		lda ($30),y			lda 	(codePtr),y
.87d2	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.87d4	f0 1a		beq $87f0			beq 	_CLSecond
.87d6	20 4f 88	jsr $884f			jsr 	CLIsDigit 					; if not digit, list all
.87d9	b0 20		bcs $87fb			bcs 	_CLStart
.87db	a2 04		ldx #$04			ldx 	#4 							; get 1st range into slot 4
.87dd	20 5d 9c	jsr $9c5d			jsr 	Evaluate16BitInteger
.87e0	b1 30		lda ($30),y			lda 	(codePtr),y
.87e2	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.87e4	f0 0a		beq $87f0			beq 	_CLSecond 					; if so go get it
.87e6	a5 5c		lda $5c				lda 	NSMantissa0+4 				; copy 4->7
.87e8	85 5f		sta $5f				sta 	NSMantissa0+7
.87ea	a5 64		lda $64				lda 	NSMantissa1+4
.87ec	85 67		sta $67				sta 	NSMantissa1+7
.87ee	80 0b		bra $87fb			bra 	_CLStart
.87f0					_CLSecond:
.87f0	c8		iny				iny 								; consume comma
.87f1	20 4f 88	jsr $884f			jsr 	CLIsDigit 					; digit found
.87f4	b0 05		bcs $87fb			bcs 	_CLStart 					; if not, continue listing
.87f6	a2 07		ldx #$07			ldx 	#7 							; load 2nd range into slot 7
.87f8	20 5d 9c	jsr $9c5d			jsr 	Evaluate16BitInteger
.87fb					_CLStart
.87fb	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.87fd	85 30		sta $30				sta 	codePtr
.87ff	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8801	85 31		sta $31				sta 	codePtr+1
.8803					_CLLoop:
.8803	20 07 a9	jsr $a907			jsr 	EXTBreakCheck 				; break check
.8806	f0 33		beq $883b			beq 	_CLExit
.8808	b2 30		lda ($30)			lda 	(codePtr)
.880a	f0 2f		beq $883b			beq 	_CLExit
.880c	a2 04		ldx #$04			ldx 	#4 							; check range every time, line numbers aren't in order.
.880e	20 3e 88	jsr $883e			jsr 	CLCompareLineNo
.8811	90 1b		bcc $882e			bcc 	_CLNext
.8813	a2 07		ldx #$07			ldx 	#7
.8815	20 3e 88	jsr $883e			jsr 	CLCompareLineNo
.8818	f0 02		beq $881c			beq 	_CLDoThisOne
.881a	b0 12		bcs $882e			bcs 	_CLNext
.881c					_CLDoThisOne:
.881c	20 72 8d	jsr $8d72			jsr 	ScanGetCurrentLineStep 		; get indent adjust.
.881f	20 51 b2	jsr $b251			jsr 	ListConvertLine 			; convert line into token Buffer
.8822	a2 04		ldx #$04			ldx 	#(tokenBuffer >> 8) 		; print that line
.8824	a9 2d		lda #$2d			lda 	#(tokenBuffer & $FF)
.8826	20 26 8e	jsr $8e26			jsr 	PrintStringXA
.8829	a9 0d		lda #$0d			lda 	#13 						; new line
.882b	20 51 a6	jsr $a651			jsr 	EXTPrintCharacter
.882e					_CLNext:
.882e	18		clc				clc
.882f	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8831	65 30		adc $30				adc 	codePtr
.8833	85 30		sta $30				sta 	codePtr
.8835	90 02		bcc $8839			bcc 	_CREExit
.8837	e6 31		inc $31				inc 	codePtr+1 					; carry
.8839					_CREExit:
.8839	80 c8		bra $8803			bra 	_CLLoop
.883b					_CLExit:
.883b	4c 62 83	jmp $8362			jmp 	WarmStart
.883e					CLCompareLineNo:
.883e	38		sec				sec
.883f	a0 01		ldy #$01			ldy 	#1
.8841	b1 30		lda ($30),y			lda 	(codePtr),y
.8843	f5 58		sbc $58,x			sbc 	NSMantissa0,x
.8845	85 36		sta $36				sta 	zTemp0
.8847	c8		iny				iny
.8848	b1 30		lda ($30),y			lda 	(codePtr),y
.884a	f5 60		sbc $60,x			sbc 	NSMantissa1,x
.884c	05 36		ora $36				ora 	zTemp0
.884e	60		rts				rts
.884f					CLIsDigit:
.884f	b1 30		lda ($30),y			lda 	(codePtr),y
.8851	c9 30		cmp #$30			cmp 	#"0"
.8853	90 03		bcc $8858			bcc	 	_CLIDExitFalse
.8855	c9 3a		cmp #$3a			cmp 	#"9"+1
.8857	60		rts				rts
.8858					_CLIDExitFalse:
.8858	38		sec				sec
.8859	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/local.asm

.885a					Command_LOCAL:
.885a	a2 00		ldx #$00			ldx 	#0 							; at level 0
.885c	20 68 88	jsr $8868			jsr 	LocaliseNextTerm 			; convert term to a local.
.885f	b1 30		lda ($30),y			lda 	(codePtr),y
.8861	c8		iny				iny
.8862	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8864	f0 f4		beq $885a			beq 	Command_LOCAL
.8866	88		dey				dey 								; unpick pre-get
.8867	60		rts				rts
.8868					LocaliseNextTerm:
.8868	20 1b 97	jsr $971b			jsr 	EvaluateTerm 				; evaluate the term
.886b	b5 50		lda $50,x			lda 	NSStatus,x
.886d	29 20		and #$20			and 	#NSBIsReference 			; check it is a reference
.886f	f0 5c		beq $88cd			beq		_LNTError
.8871	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address of variable to zTemp0
.8873	85 36		sta $36				sta 	zTemp0
.8875	b5 60		lda $60,x			lda 	NSMantissa1,x
.8877	85 37		sta $37				sta  	zTemp0+1
.8879	b5 50		lda $50,x			lda 	NSStatus,x
.887b	29 10		and #$10			and 	#NSBIsString
.887d	d0 1e		bne $889d			bne 	_LNTPushString
.887f	5a		phy				phy
.8880	a0 00		ldy #$00			ldy 	#0 							; push 0 to 4 inclusive, the number values, on the stack, and zero them as you go.
.8882					_LNTPushNumLoop:
.8882	b1 36		lda ($36),y			lda		(zTemp0),y
.8884	20 f8 a4	jsr $a4f8			jsr 	StackPushByte
.8887	c8		iny				iny
.8888	c0 05		cpy #$05			cpy 	#5
.888a	d0 f6		bne $8882			bne 	_LNTPushNumLoop
.888c	a5 36		lda $36				lda 	zTemp0 						; push the actual target address to write on the stack
.888e	20 f8 a4	jsr $a4f8			jsr 	StackPushByte
.8891	a5 37		lda $37				lda 	zTemp0+1
.8893	20 f8 a4	jsr $a4f8			jsr 	StackPushByte
.8896	a9 01		lda #$01			lda 	#STK_LOCALN 				; push local-number marker.
.8898	20 f8 a4	jsr $a4f8			jsr 	StackPushByte
.889b	7a		ply				ply
.889c	60		rts				rts
.889d					_LNTPushString:
.889d	5a		phy				phy
.889e	b2 36		lda ($36)			lda 	(zTemp0) 					; put address of string in zTemp1
.88a0	85 38		sta $38				sta 	zTemp1
.88a2	a0 01		ldy #$01			ldy 	#1
.88a4	b1 36		lda ($36),y			lda 	(zTemp0),y
.88a6	85 39		sta $39				sta 	zTemp1+1
.88a8	a0 00		ldy #$00			ldy 	#0 							; output string
.88aa	c9 00		cmp #$00			cmp 	#0 							; if not assigned strin
.88ac	f0 0a		beq $88b8			beq 	_LNTStringOut
.88ae					_LNTPushStrLoop:
.88ae	b1 38		lda ($38),y			lda 	(zTemp1),y
.88b0	f0 06		beq $88b8			beq 	_LNTStringOut
.88b2	20 f8 a4	jsr $a4f8			jsr 	StackPushByte
.88b5	c8		iny				iny
.88b6	80 f6		bra $88ae			bra 	_LNTPushStrLoop
.88b8					_LNTStringOut:
.88b8	98		tya				tya									; output length
.88b9	20 f8 a4	jsr $a4f8			jsr 	StackPushByte
.88bc	b5 58		lda $58,x			lda 	NSMantissa0,x 				; output address of the string record *not* the string itself
.88be	20 f8 a4	jsr $a4f8			jsr 	StackPushByte
.88c1	b5 60		lda $60,x			lda 	NSMantissa1,x
.88c3	20 f8 a4	jsr $a4f8			jsr 	StackPushByte
.88c6	a9 02		lda #$02			lda 	#STK_LOCALS 				; push local-string marker.
.88c8	20 f8 a4	jsr $a4f8			jsr 	StackPushByte
.88cb	7a		ply				ply
.88cc	60		rts				rts
.88cd					_LNTError:
.88cd	4c 55 9e	jmp $9e55			jmp 	SyntaxError
.88d0					LocalPopValue:
.88d0	20 11 a5	jsr $a511			jsr 	StackPopByte
.88d3	c9 01		cmp #$01			cmp 	#STK_LOCALN 				; if not local-N
.88d5	d0 17		bne $88ee			bne 	_LPVString
.88d7	20 11 a5	jsr $a511			jsr 	StackPopByte 				; address
.88da	85 37		sta $37				sta 	zTemp0+1
.88dc	20 11 a5	jsr $a511			jsr 	StackPopByte
.88df	85 36		sta $36				sta 	zTemp0
.88e1	5a		phy				phy
.88e2	a0 04		ldy #$04			ldy 	#4 							; copy back
.88e4					_LPVNumberCopy:
.88e4	20 11 a5	jsr $a511			jsr 	StackPopByte
.88e7	91 36		sta ($36),y			sta 	(zTemp0),y
.88e9	88		dey				dey
.88ea	10 f8		bpl $88e4			bpl 	_LPVNumberCopy
.88ec	7a		ply				ply 								; and complete
.88ed	60		rts				rts
.88ee					_LPVString:
.88ee	20 11 a5	jsr $a511			jsr 	StackPopByte 				; address of record => zTemp0
.88f1	85 37		sta $37				sta 	zTemp0+1
.88f3	20 11 a5	jsr $a511			jsr 	StackPopByte
.88f6	85 36		sta $36				sta 	zTemp0
.88f8	5a		phy				phy
.88f9	b2 36		lda ($36)			lda 	(zTemp0) 					; address to write string to => zTemp1
.88fb	85 38		sta $38				sta 	zTemp1
.88fd	a0 01		ldy #$01			ldy 	#1
.88ff	b1 36		lda ($36),y			lda 	(zTemp0),y
.8901	85 39		sta $39				sta 	zTemp1+1
.8903	20 11 a5	jsr $a511			jsr 	StackPopByte 				; # to get => y
.8906	a8		tay				tay
.8907	a5 39		lda $39				lda 	zTemp1+1 					; if no target (e.g. was "" originally) exit
.8909	f0 0e		beq $8919			beq 	_LPVStringCopied
.890b	a9 00		lda #$00			lda 	#0 							; NULL on end
.890d	91 38		sta ($38),y			sta 	(zTemp1),y
.890f					_LPVStringCopy:
.890f	88		dey				dey
.8910	30 07		bmi $8919			bmi 	_LPVStringCopied
.8912	20 11 a5	jsr $a511			jsr 	StackPopByte
.8915	91 38		sta ($38),y			sta 	(zTemp1),y
.8917	80 f6		bra $890f			bra 	_LPVStringCopy
.8919					_LPVStringCopied:
.8919	fa		plx				plx
.891a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/new.asm

.891b					NewCommand:
.891b	20 21 89	jsr $8921			jsr 	NewProgram 					; does the actual NEW.
.891e	4c 62 83	jmp $8362			jmp 	WarmStart 					; and warm starts straight away.
.8921					NewProgram:
.8921	20 25 a4	jsr $a425			jsr 	MemoryNew
.8924	9c 00 10	stz $1000			stz 	VariableSpace 				; erase all variables.
.8927	20 f3 83	jsr $83f3			jsr 	ClearCommand 				; clear everything.
.892a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/procedure.asm

=2					ParameterStackPos = 2
.892b					CallProcedure:
.892b	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start storing parameters at 2.
.892d	b1 30		lda ($30),y			lda 	(codePtr),y
.892f	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.8931	f0 0c		beq $893f			beq 	_CPEndParam
.8933					_CPParamLoop:
.8933	20 22 9c	jsr $9c22			jsr 	EvaluateValue 				; get parameter onto stack
.8936	e8		inx				inx 								; bump next stack
.8937	b1 30		lda ($30),y			lda 	(codePtr),y
.8939	c8		iny				iny
.893a	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if comma, go back and try again.
.893c	f0 f5		beq $8933			beq 	_CPParamLoop
.893e	88		dey				dey 								; unpick.
.893f					_CPEndParam:
.893f	8e 16 04	stx $0416			stx 	LastParameter 				; save the last parameters index.
.8942	c8		iny				iny									; skip right bracket
.8943	a9 b3		lda #$b3			lda 	#STK_PROC+3 				; allocate 6 bytes on the return stack.
.8945	20 1a a5	jsr $a51a			jsr 	StackOpen
.8948	20 5e a5	jsr $a55e			jsr 	STKSaveCodePosition 		; save loop position
.894b	a5 58		lda $58				lda 	NSMantissa0 				; copy variable (e.g. procedure) address to zTemp0
.894d	85 36		sta $36				sta 	zTemp0 						; this is the DATA not the RECORD
.894f	a5 60		lda $60				lda 	NSMantissa1
.8951	85 37		sta $37				sta 	zTemp0+1
.8953	a0 01		ldy #$01			ldy 	#1 							; copy code address back.
.8955	b2 36		lda ($36)			lda 	(zTemp0)
.8957	85 30		sta $30				sta 	safePtr
.8959	b1 36		lda ($36),y			lda 	(zTemp0),y
.895b	85 31		sta $31				sta 	safePtr+1
.895d	c8		iny				iny
.895e	b1 36		lda ($36),y			lda 	(zTemp0),y
.8960	85 32		sta $32				sta 	safePtr+2
.8962	c8		iny				iny
.8963	b1 36		lda ($36),y			lda 	(zTemp0),y
.8965	85 33		sta $33				sta 	safePtr+3
.8967	c8		iny				iny 								; get Y offset -> Y
.8968	b1 36		lda ($36),y			lda 	(zTemp0),y
.896a	a8		tay				tay
.896b	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start position of parameters
.896d	ec 16 04	cpx $0416			cpx	 	LastParameter 				; check no parameters at the start
.8970	f0 13		beq $8985			beq 	_ParamExit 					; if so, exit.
.8972					_ParamExtract:
.8972	ca		dex				dex 								; put a local term on the level before
.8973	20 68 88	jsr $8868			jsr 	LocaliseNextTerm			; also pushes original param value to basic stack
.8976	20 ac 87	jsr $87ac			jsr 	AssignVariable 				; assign stacked value to the variable.
.8979	e8		inx				inx 								; advance to next parameter to do.
.897a	e8		inx				inx
.897b	ec 16 04	cpx $0416			cpx 	LastParameter 				; are we done ?
.897e	f0 05		beq $8985			beq 	_ParamExit
.8980	20 bc 8d	jsr $8dbc			jsr 	CheckComma 					; comma seperating parameters
.8983	80 ed		bra $8972			bra 	_ParamExtract
.8985					_ParamExit:
.8985	20 b4 8d	jsr $8db4			jsr 	CheckRightBracket 			; check )
.8988	60		rts				rts 								; and continue from here
.8989					Command_ENDPROC:
.8989	a9 b0		lda #$b0			lda 	#STK_PROC 					; check TOS is this
.898b	a2 14		ldx #$14			ldx 	#ERRID_PROC
.898d	20 46 a5	jsr $a546			jsr 	StackCheckFrame
.8990	20 6f a5	jsr $a56f			jsr 	STKLoadCodePosition 		; restore code position
.8993	20 38 a5	jsr $a538			jsr 	StackClose
.8996	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/read.asm

.8997					Command_Read:
.8997	a2 00		ldx #$00			ldx 	#0 							; evaluate the term which is the var/array element to assign
.8999	20 1b 97	jsr $971b			jsr 	EvaluateTerm
.899c	b5 50		lda $50,x			lda 	NSStatus,x
.899e	29 20		and #$20			and 	#NSBIsReference				; get status byte on stack, identifies int, float, string.
.89a0	f0 4a		beq $89ec			beq 	_CRSyntax 					; check reference (bit 0)
.89a2	20 35 8a	jsr $8a35			jsr 	SwapDataCodePtrs 			; swap code and data
.89a5	ad 1c 04	lda $041c			lda 	inDataStatement 			; if in a data statement, we don't need to search
.89a8	d0 20		bne $89ca			bne 	_CRContinueData
.89aa					_CRKeepSearching:
.89aa	a9 b2		lda #$b2			lda 	#KWD_DATA 					; scan for instruction
.89ac	aa		tax				tax
.89ad	20 0f 8d	jsr $8d0f			jsr 	ScanForward
.89b0	c9 b2		cmp #$b2			cmp 	#KWD_DATA 					; found data ?
.89b2	f0 16		beq $89ca			beq 	_CRHaveData 				; found it
.89b4	18		clc				clc
.89b5	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.89b7	65 30		adc $30				adc 	codePtr
.89b9	85 30		sta $30				sta 	codePtr
.89bb	90 02		bcc $89bf			bcc 	_CREExit
.89bd	e6 31		inc $31				inc 	codePtr+1 					; carry
.89bf					_CREExit:
.89bf	a0 03		ldy #$03			ldy 	#3 							; start of line.
.89c1	b2 30		lda ($30)			lda 	(codePtr)
.89c3	d0 e5		bne $89aa			bne 	_CRKeepSearching
.89c5	a9 0b		lda #$0b		lda	#11
.89c7	4c cd 8d	jmp $8dcd		jmp	ErrorHandler
.89ca					_CRHaveData:
.89ca					_CRContinueData:
.89ca	a2 01		ldx #$01			ldx 	#1
.89cc	20 22 9c	jsr $9c22			jsr 	EvaluateValue 				; evaluate value into slot # 1
.89cf	ca		dex				dex
.89d0	20 ac 87	jsr $87ac			jsr		AssignVariable 				; do the assignment
.89d3	9c 1c 04	stz $041c			stz 	inDataStatement 			; clear in data
.89d6	b1 30		lda ($30),y			lda 	(codePtr),y
.89d8	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not, end of data statement
.89da	d0 04		bne $89e0			bne 	_CRSwapBack
.89dc	c8		iny				iny 								; consume comma
.89dd	ee 1c 04	inc $041c			inc 	inDataStatement 			; set in data statement currently.
.89e0					_CRSwapBack:
.89e0	20 35 8a	jsr $8a35			jsr 	SwapDataCodePtrs			; swap them back.
.89e3	b1 30		lda ($30),y			lda 	(codePtr),y
.89e5	c8		iny				iny
.89e6	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.89e8	f0 ad		beq $8997			beq 	Command_Read 				; if so go round again.
.89ea	88		dey				dey 								; unpick get.
.89eb	60		rts				rts
.89ec					_CRSyntax:
.89ec	4c 55 9e	jmp $9e55			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/rem.asm

.89ef					RemCommand:
.89ef	b1 30		lda ($30),y			lda 	(codePtr),y
.89f1	c9 ff		cmp #$ff			cmp 	#KWC_STRING
.89f3	d0 06		bne $89fb			bne 	_RMExit
.89f5	c8		iny				iny 								; point to offset
.89f6	98		tya				tya 								; A = offset position
.89f7	38		sec				sec 								; add size +1 hence SEC
.89f8	71 30		adc ($30),y			adc 	(codePtr),y
.89fa	a8		tay				tay 								; make current position.
.89fb					_RMExit:
.89fb	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/repeat.asm

.89fc					Command_REPEAT:
.89fc	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; allocate 6 bytes on the return stack.
.89fe	20 1a a5	jsr $a51a			jsr 	StackOpen
.8a01	20 5e a5	jsr $a55e			jsr 	STKSaveCodePosition 		; save loop position
.8a04	60		rts				rts
.8a05					Command_UNTIL:
.8a05	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; check REPEAT is TOS
.8a07	a2 0f		ldx #$0f			ldx 	#ERRID_REPEAT 				; this error
.8a09	20 46 a5	jsr $a546			jsr 	StackCheckFrame
.8a0c	a2 00		ldx #$00			ldx 	#0
.8a0e	20 2b 9c	jsr $9c2b			jsr 	EvaluateNumber 				; work out the number
.8a11	20 ff 9c	jsr $9cff			jsr 	NSMIsZero 					; check if zero
.8a14	f0 04		beq $8a1a			beq 	_CULoopBack 				; if so keep looping
.8a16	20 38 a5	jsr $a538			jsr 	StackClose		 			; return
.8a19	60		rts				rts
.8a1a					_CULoopBack:
.8a1a	20 6f a5	jsr $a56f			jsr 	STKLoadCodePosition 		; loop back
.8a1d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/restore.asm

.8a1e					Command_Restore:
.8a1e	20 35 8a	jsr $8a35			jsr 	SwapDataCodePtrs 			; swap code and data
.8a21	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8a23	85 30		sta $30				sta 	codePtr
.8a25	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8a27	85 31		sta $31				sta 	codePtr+1
.8a29	20 35 8a	jsr $8a35			jsr 	SwapDataCodePtrs 			; put them back
.8a2c	a9 03		lda #$03			lda 	#3 							; start at offset 3, e.g. first instruction of first line.
.8a2e	8d 1b 04	sta $041b			sta 	dataPointer+4
.8a31	9c 1c 04	stz $041c			stz 	inDataStatement 			; not in data statement
.8a34	60		rts				rts
.8a35					SwapDataCodePtrs:
.8a35	da		phx				phx
.8a36	a2 03		ldx #$03			ldx 	#3 							; swap 32 bit code pointer over
.8a38					_SDCPLoop:
.8a38	b5 30		lda $30,x			lda 	safePtr,x
.8a3a	48		pha				pha
.8a3b	bd 17 04	lda $0417,x			lda 	dataPointer,x
.8a3e	95 30		sta $30,x			sta 	safePtr,x
.8a40	68		pla				pla
.8a41	9d 17 04	sta $0417,x			sta 	dataPointer,x
.8a44	ca		dex				dex
.8a45	10 f1		bpl $8a38			bpl 	_SDCPLoop
.8a47	ad 1b 04	lda $041b			lda 	dataPointer+4 				; swap Y position over.
.8a4a	8c 1b 04	sty $041b			sty 	dataPointer+4
.8a4d	a8		tay				tay
.8a4e	fa		plx				plx
.8a4f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/run.asm

.8a50					EOLCommand:
.8a50	18		clc				clc
.8a51	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8a53	65 30		adc $30				adc 	codePtr
.8a55	85 30		sta $30				sta 	codePtr
.8a57	90 02		bcc $8a5b			bcc 	_CREExit
.8a59	e6 31		inc $31				inc 	codePtr+1 					; carry
.8a5b					_CREExit:
.8a5b	80 0b		bra $8a68			bra 	RunNewLine
.8a5d					CommandRUN:
.8a5d	20 f3 83	jsr $83f3			jsr 	ClearCommand 				; clear variable/stacks/etc.
.8a60	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8a62	85 30		sta $30				sta 	codePtr
.8a64	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8a66	85 31		sta $31				sta 	codePtr+1
.8a68					RUNNewLine:
.8a68	b2 30		lda ($30)			lda 	(codePtr)
.8a6a	f0 72		beq $8ade			beq 	CRNoProgram         		; no then END.
.8a6c	a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack
.8a6e	9a		txs				txs
.8a6f					RUNCodePointerLine:
.8a6f	a0 02		ldy #$02			ldy 	#2 							; start of program
.8a71					_CRIncMainLoop:
.8a71	0e 13 04	asl $0413			asl 	breakCheck 					; clears 1 time in 8
.8a74	d0 19		bne $8a8f			bne 	_CRNoBreakCheck
.8a76	20 07 a9	jsr $a907			jsr 	EXTBreakCheck 				; break check
.8a79	f0 5e		beq $8ad9			beq 	_CRBreak
.8a7b	64 01		stz $01				stz 	1 							; access I/O Page 0
.8a7d	38		sec				sec 								; calculate timer - LastTick
.8a7e	ad 59 d6	lda $d659			lda 	$D659
.8a81	aa		tax				tax 								; saving timer in X
.8a82	ed af 05	sbc $05af			sbc 	LastTick
.8a85	c9 03		cmp #$03			cmp 	#3
.8a87	90 06		bcc $8a8f			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.8a89	8e af 05	stx $05af			stx 	LastTick 					; update last timer
.8a8c	20 7e b8	jsr $b87e			jsr 	TickHandler 				; go do the code.
.8a8f					_NoFireTick:
.8a8f					_CRNoBreakCheck:
.8a8f	c8		iny				iny
.8a90					_CRMainLoop:
.8a90	9c 10 04	stz $0410			stz 	stringInitialised 			; clear the temporary string initialised flag.
.8a93	b1 30		lda ($30),y			lda 	(codePtr),y
.8a95	10 10		bpl $8aa7			bpl 	_CRNotKeyword
.8a97	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1 			; if after unary, legitimate command
.8a99	b0 04		bcs $8a9f			bcs 	_CRIsKeyword
.8a9b	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if unary, syntax error.
.8a9d	b0 34		bcs $8ad3			bcs		_CRSyntaxError
.8a9f					_CRIsKeyword:
.8a9f	c8		iny				iny 								; consume command
.8aa0	0a		asl a				asl 	a 							; double losing the MSB which is '1' as tokens are $80-$FF
.8aa1	aa		tax				tax 								; put in X for vector jump
.8aa2	20 d6 8a	jsr $8ad6			jsr 	_CRCallVector0 				; call the vector - effectively jsr (vectortable,X)
.8aa5	80 e9		bra $8a90			bra 	_CRMainLoop 				; and loop round
.8aa7					_CRNotKeyword:
.8aa7	c9 3a		cmp #$3a			cmp 	#KWD_COLON 					; if a :, consume it and go round.
.8aa9	f0 c6		beq $8a71			beq 	_CRIncMainLoop
.8aab	c9 40		cmp #$40			cmp 	#$40 						; variable/call reference
.8aad	90 05		bcc $8ab4			bcc 	_CRNotVariable
.8aaf					_CRGoLet:
.8aaf	20 73 87	jsr $8773			jsr 	LetCommand
.8ab2	80 dc		bra $8a90			bra 	_CRMainLoop
.8ab4					_CRNotVariable:
.8ab4	c9 10		cmp #$10			cmp 	#KWD_AT 					; handle @
.8ab6	f0 f7		beq $8aaf			beq 	_CRGoLet
.8ab8	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; handle ? !
.8aba	f0 f3		beq $8aaf			beq 	_CRGoLet
.8abc	c9 21		cmp #$21			cmp 	#KWD_PLING
.8abe	f0 ef		beq $8aaf			beq 	_CRGoLet
.8ac0	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; handle ' (comment)
.8ac2	f0 09		beq $8acd			beq 	_CRGoRem
.8ac4	c9 2e		cmp #$2e			cmp 	#KWD_PERIOD 				; handle . (assembler label)
.8ac6	d0 0b		bne $8ad3			bne 	_CRSyntaxError
.8ac8	20 03 82	jsr $8203			jsr 	LabelHere
.8acb	80 c3		bra $8a90			bra 	_CRMainLoop
.8acd					_CRGoRem:
.8acd	c8		iny				iny
.8ace	20 ef 89	jsr $89ef			jsr 	RemCommand
.8ad1	80 bd		bra $8a90			bra 	_CRMainLoop
.8ad3					_CRSyntaxError:
.8ad3	4c 55 9e	jmp $9e55			jmp 	SyntaxError
.8ad6					_CRCallVector0:
.8ad6	7c 74 8b	jmp ($8b74,x)			jmp 	(VectorSet0,x)
.8ad9					_CRBreak:
.8ad9	a9 01		lda #$01		lda	#1
.8adb	4c cd 8d	jmp $8dcd		jmp	ErrorHandler
.8ade					CRNoProgram:
.8ade	4c 18 85	jmp $8518			jmp 	EndCommand
.8ae1					Shift1Command:
.8ae1	b1 30		lda ($30),y			lda 	(codePtr),y
.8ae3	c8		iny				iny
.8ae4	0a		asl a				asl 	a
.8ae5	aa		tax				tax
.8ae6	7c 12 8c	jmp ($8c12,x)			jmp 	(VectorSet1,x)
.8ae9					Shift2Command:
.8ae9	b1 30		lda ($30),y			lda 	(codePtr),y
.8aeb	c8		iny				iny
.8aec	0a		asl a				asl 	a
.8aed	aa		tax				tax
.8aee	7c 30 8c	jmp ($8c30,x)			jmp 	(VectorSet2,x)
.8af1					Unused1:
.8af1					Unused2:
.8af1					Unused3:
.8af1					Unused4:
.8af1	4c 55 9e	jmp $9e55			jmp 	SyntaxError
>8af4							.align 2

;******  Processing file: ./common/commands/../generated/vectors.dat

.8af4					VectorSetPunc:
>8af4	85 90					.word	ShiftLeft                        ; $00 <<
>8af6	70 8e					.word	BinaryCompareLessEqual           ; $01 <=
>8af8	66 8e					.word	BinaryCompareNotEqual            ; $02 <>
>8afa	55 9e					.word	SyntaxError                      ; $03 !!3
>8afc	55 9e					.word	SyntaxError                      ; $04 ><
>8afe	7a 8e					.word	BinaryCompareGreaterEqual        ; $05 >=
>8b00	88 90					.word	ShiftRight                       ; $06 >>
>8b02	55 9e					.word	SyntaxError                      ; $07 !!7
>8b04	55 9e					.word	SyntaxError                      ; $08 !!8
>8b06	55 9e					.word	SyntaxError                      ; $09 !!9
>8b08	55 9e					.word	SyntaxError                      ; $0a !!10
>8b0a	55 9e					.word	SyntaxError                      ; $0b !!11
>8b0c	55 9e					.word	SyntaxError                      ; $0c !!12
>8b0e	55 9e					.word	SyntaxError                      ; $0d !!13
>8b10	55 9e					.word	SyntaxError                      ; $0e !!14
>8b12	55 9e					.word	SyntaxError                      ; $0f !!15
>8b14	55 9e					.word	SyntaxError                      ; $10 @
>8b16	55 9e					.word	SyntaxError                      ; $11 !!17
>8b18	55 9e					.word	SyntaxError                      ; $12 !!18
>8b1a	55 9e					.word	SyntaxError                      ; $13 [
>8b1c	31 8f					.word	IntegerDivide                    ; $14 \
>8b1e	55 9e					.word	SyntaxError                      ; $15 ]
>8b20	c3 91					.word	EorInteger                       ; $16 ^
>8b22	55 9e					.word	SyntaxError                      ; $17 _
>8b24	55 9e					.word	SyntaxError                      ; $18 `
>8b26	55 9e					.word	SyntaxError                      ; $19 !!25
>8b28	55 9e					.word	SyntaxError                      ; $1a !!26
>8b2a	55 9e					.word	SyntaxError                      ; $1b {
>8b2c	8e 91					.word	OraInteger                       ; $1c |
>8b2e	55 9e					.word	SyntaxError                      ; $1d }
>8b30	55 9e					.word	SyntaxError                      ; $1e ~
>8b32	55 9e					.word	SyntaxError                      ; $1f [7m<7F>[m
>8b34	55 9e					.word	SyntaxError                      ; $20
>8b36	f8 91					.word	WordIndirect                     ; $21 !
>8b38	55 9e					.word	SyntaxError                      ; $22 "
>8b3a	55 9e					.word	SyntaxError                      ; $23 #
>8b3c	55 9e					.word	SyntaxError                      ; $24 $
>8b3e	72 8f					.word	IntegerModulus                   ; $25 %
>8b40	59 91					.word	AndInteger                       ; $26 &
>8b42	55 9e					.word	SyntaxError                      ; $27 '
>8b44	55 9e					.word	SyntaxError                      ; $28 (
>8b46	55 9e					.word	SyntaxError                      ; $29 )
>8b48	e0 8f					.word	MulInteger                       ; $2a *
>8b4a	fb 90					.word	AddInteger                       ; $2b +
>8b4c	55 9e					.word	SyntaxError                      ; $2c ,
>8b4e	34 91					.word	SubInteger                       ; $2d -
>8b50	55 9e					.word	SyntaxError                      ; $2e .
>8b52	b2 93					.word	FDivideCommand                   ; $2f /
>8b54	55 9e					.word	SyntaxError                      ; $30 0
>8b56	55 9e					.word	SyntaxError                      ; $31 1
>8b58	55 9e					.word	SyntaxError                      ; $32 2
>8b5a	55 9e					.word	SyntaxError                      ; $33 3
>8b5c	55 9e					.word	SyntaxError                      ; $34 4
>8b5e	55 9e					.word	SyntaxError                      ; $35 5
>8b60	55 9e					.word	SyntaxError                      ; $36 6
>8b62	55 9e					.word	SyntaxError                      ; $37 7
>8b64	55 9e					.word	SyntaxError                      ; $38 8
>8b66	55 9e					.word	SyntaxError                      ; $39 9
>8b68	55 9e					.word	SyntaxError                      ; $3a :
>8b6a	55 9e					.word	SyntaxError                      ; $3b ;
>8b6c	52 8e					.word	BinaryCompareLess                ; $3c <
>8b6e	48 8e					.word	BinaryCompareEqual               ; $3d =
>8b70	5c 8e					.word	BinaryCompareGreater             ; $3e >
>8b72	1a 92					.word	ByteIndirect                     ; $3f ?
.8b74					VectorSet0:
>8b74	50 8a					.word	EOLCommand                       ; $80 !0:EOF
>8b76	e1 8a					.word	Shift1Command                    ; $81 !1:SH1
>8b78	e9 8a					.word	Shift2Command                    ; $82 !2:SH2
>8b7a	97 98					.word	AbsUnary                         ; $83 ABS(
>8b7c	a5 98					.word	AllocUnary                       ; $84 ALLOC(
>8b7e	15 99					.word	AscUnary                         ; $85 ASC(
>8b80	c3 9a					.word	ChrUnary                         ; $86 CHR$(
>8b82	a5 a2					.word	UnaryEvent                       ; $87 EVENT(
>8b84	44 8e					.word	UnaryFalse                       ; $88 FALSE
>8b86	22 99					.word	FracUnary                        ; $89 FRAC(
>8b88	41 a2					.word	UnaryHit                         ; $8a HIT(
>8b8a	37 99					.word	IntUnary                         ; $8b INT(
>8b8c	82 9a					.word	IsValUnary                       ; $8c ISVAL(
>8b8e	29 a3					.word	UnaryJoyB                        ; $8d JOYB(
>8b90	02 a3					.word	UnaryJoyX                        ; $8e JOYX(
>8b92	05 a3					.word	UnaryJoyY                        ; $8f JOYY(
>8b94	96 9b					.word	Unary_Left                       ; $90 LEFT$(
>8b96	48 99					.word	LenUnary                         ; $91 LEN(
>8b98	66 99					.word	Unary_Max                        ; $92 MAX(
>8b9a	b8 9b					.word	Unary_Mid                        ; $93 MID$(
>8b9c	62 99					.word	Unary_Min                        ; $94 MIN(
>8b9e	b1 99					.word	Unary_Not                        ; $95 NOT(
>8ba0	76 a4					.word	UnaryPlaying                     ; $96 PLAYING(
>8ba2	c7 99					.word	Unary_Random                     ; $97 RANDOM(
>8ba4	a3 9b					.word	Unary_Right                      ; $98 RIGHT$(
>8ba6	e4 99					.word	Unary_Rnd                        ; $99 RND(
>8ba8	5a 9a					.word	SgnUnary                         ; $9a SGN(
>8baa	d5 9a					.word	SpcUnary                         ; $9b SPC(
>8bac	f0 9a					.word	Unary_Str                        ; $9c STR$(
>8bae	4f a3					.word	UnaryTimer                       ; $9d TIMER(
>8bb0	39 8e					.word	UnaryTrue                        ; $9e TRUE
>8bb2	78 9a					.word	ValUnary                         ; $9f VAL(
>8bb4	1b 85					.word	ForCommand                       ; $a0 FOR
>8bb6	5e 86					.word	IfCommand                        ; $a1 IF
>8bb8	f1 8a					.word	Unused1                          ; $a2 PROC
>8bba	fc 89					.word	Command_REPEAT                   ; $a3 REPEAT
>8bbc	85 8d					.word	Command_WHILE                    ; $a4 WHILE
>8bbe	87 86					.word	EndIf                            ; $a5 ENDIF
>8bc0	89 89					.word	Command_ENDPROC                  ; $a6 ENDPROC
>8bc2	cd 85					.word	NextCommand                      ; $a7 NEXT
>8bc4	f1 8a					.word	Unused4                          ; $a8 THEN
>8bc6	05 8a					.word	Command_UNTIL                    ; $a9 UNTIL
>8bc8	a6 8d					.word	Command_WEND                     ; $aa WEND
>8bca	55 9e					.word	SyntaxError                      ; $ab BY
>8bcc	be 83					.word	CallCommand                      ; $ac CALL
>8bce	f5 9f					.word	CircleCommand                    ; $ad CIRCLE
>8bd0	f3 83					.word	ClearCommand                     ; $ae CLEAR
>8bd2	4b 84					.word	ClearScreen                      ; $af CLS
>8bd4	55 9e					.word	SyntaxError                      ; $b0 COLOR
>8bd6	55 9e					.word	SyntaxError                      ; $b1 COLOUR
>8bd8	53 84					.word	Command_Data                     ; $b2 DATA
>8bda	5b 84					.word	DimCommand                       ; $b3 DIM
>8bdc	f1 8a					.word	Unused3                          ; $b4 DOWNTO
>8bde	80 86					.word	ElseCode                         ; $b5 ELSE
>8be0	55 9e					.word	SyntaxError                      ; $b6 FROM
>8be2	14 a2					.word	GfxCommand                       ; $b7 GFX
>8be4	26 86					.word	Command_GOSUB                    ; $b8 GOSUB
>8be6	44 86					.word	GotoCommand                      ; $b9 GOTO
>8be8	55 9e					.word	SyntaxError                      ; $ba HERE
>8bea	1e a0					.word	ImageCommand                     ; $bb IMAGE
>8bec	88 86					.word	Command_Input                    ; $bc INPUT
>8bee	73 87					.word	LetCommand                       ; $bd LET
>8bf0	70 a0					.word	LineCommand                      ; $be LINE
>8bf2	5a 88					.word	Command_LOCAL                    ; $bf LOCAL
>8bf4	55 9e					.word	SyntaxError                      ; $c0 OFF
>8bf6	55 9e					.word	SyntaxError                      ; $c1 ON
>8bf8	55 9e					.word	SyntaxError                      ; $c2 OUTLINE
>8bfa	65 a2					.word	PaletteCommand                   ; $c3 PALETTE
>8bfc	69 a0					.word	PlotCommand                      ; $c4 PLOT
>8bfe	8f 86					.word	Command_Print                    ; $c5 PRINT
>8c00	97 89					.word	Command_Read                     ; $c6 READ
>8c02	f1 9f					.word	RectangleCommand                 ; $c7 RECT
>8c04	ef 89					.word	RemCommand                       ; $c8 REM
>8c06	36 86					.word	Command_RETURN                   ; $c9 RETURN
>8c08	55 9e					.word	SyntaxError                      ; $ca SOLID
>8c0a	92 a4					.word	SoundCommand                     ; $cb SOUND
>8c0c	00 a0					.word	SpriteCommand                    ; $cc SPRITE
>8c0e	3a a0					.word	TextCommand                      ; $cd TEXT
>8c10	f1 8a					.word	Unused2                          ; $ce TO
.8c12					VectorSet1:
>8c12	55 9e					.word	SyntaxError                      ; $80 !0:EOF
>8c14	55 9e					.word	SyntaxError                      ; $81 !1:SH1
>8c16	55 9e					.word	SyntaxError                      ; $82 !2:SH2
>8c18	92 83					.word	AssembleCommand                  ; $83 ASSEMBLE
>8c1a	ae 83					.word	AssertCommand                    ; $84 ASSERT
>8c1c	b4 a1					.word	BitmapCtrl                       ; $85 BITMAP
>8c1e	18 85					.word	EndCommand                       ; $86 END
>8c20	46 a3					.word	GoCommand                        ; $87 GO
>8c22	c3 87					.word	Command_List                     ; $88 LIST
>8c24	3d a3					.word	LoadCommand                      ; $89 LOAD
>8c26	1b 89					.word	NewCommand                       ; $8a NEW
>8c28	1e 8a					.word	Command_Restore                  ; $8b RESTORE
>8c2a	5d 8a					.word	CommandRUN                       ; $8c RUN
>8c2c	f9 a1					.word	SpritesCtrl                      ; $8d SPRITES
>8c2e	b8 8c					.word	StopCommand                      ; $8e STOP
.8c30					VectorSet2:
>8c30	55 9e					.word	SyntaxError                      ; $80 !0:EOF
>8c32	55 9e					.word	SyntaxError                      ; $81 !1:SH1
>8c34	55 9e					.word	SyntaxError                      ; $82 !2:SH2
>8c36	14 9d					.word	Assemble_adc                     ; $83 ADC
>8c38	0c 9d					.word	Assemble_and                     ; $84 AND
>8c3a	28 9d					.word	Assemble_asl                     ; $85 ASL
>8c3c	92 9d					.word	Assemble_bcc                     ; $86 BCC
>8c3e	96 9d					.word	Assemble_bcs                     ; $87 BCS
>8c40	9e 9d					.word	Assemble_beq                     ; $88 BEQ
>8c42	55 9d					.word	Assemble_bit                     ; $89 BIT
>8c44	86 9d					.word	Assemble_bmi                     ; $8a BMI
>8c46	9a 9d					.word	Assemble_bne                     ; $8b BNE
>8c48	82 9d					.word	Assemble_bpl                     ; $8c BPL
>8c4a	a2 9d					.word	Assemble_bra                     ; $8d BRA
>8c4c	a6 9d					.word	Assemble_brk                     ; $8e BRK
>8c4e	8a 9d					.word	Assemble_bvc                     ; $8f BVC
>8c50	8e 9d					.word	Assemble_bvs                     ; $90 BVS
>8c52	ae 9d					.word	Assemble_clc                     ; $91 CLC
>8c54	02 9e					.word	Assemble_cld                     ; $92 CLD
>8c56	c2 9d					.word	Assemble_cli                     ; $93 CLI
>8c58	f2 9d					.word	Assemble_clv                     ; $94 CLV
>8c5a	20 9d					.word	Assemble_cmp                     ; $95 CMP
>8c5c	69 9d					.word	Assemble_cpx                     ; $96 CPX
>8c5e	64 9d					.word	Assemble_cpy                     ; $97 CPY
>8c60	46 9d					.word	Assemble_dec                     ; $98 DEC
>8c62	fe 9d					.word	Assemble_dex                     ; $99 DEX
>8c64	da 9d					.word	Assemble_dey                     ; $9a DEY
>8c66	10 9d					.word	Assemble_eor                     ; $9b EOR
>8c68	4b 9d					.word	Assemble_inc                     ; $9c INC
>8c6a	0e 9e					.word	Assemble_inx                     ; $9d INX
>8c6c	fa 9d					.word	Assemble_iny                     ; $9e INY
>8c6e	7d 9d					.word	Assemble_jmp                     ; $9f JMP
>8c70	78 9d					.word	Assemble_jsr                     ; $a0 JSR
>8c72	1c 9d					.word	Assemble_lda                     ; $a1 LDA
>8c74	41 9d					.word	Assemble_ldx                     ; $a2 LDX
>8c76	5f 9d					.word	Assemble_ldy                     ; $a3 LDY
>8c78	32 9d					.word	Assemble_lsr                     ; $a4 LSR
>8c7a	12 9e					.word	Assemble_nop                     ; $a5 NOP
>8c7c	08 9d					.word	Assemble_ora                     ; $a6 ORA
>8c7e	be 9d					.word	Assemble_pha                     ; $a7 PHA
>8c80	aa 9d					.word	Assemble_php                     ; $a8 PHP
>8c82	06 9e					.word	Assemble_phx                     ; $a9 PHX
>8c84	c6 9d					.word	Assemble_phy                     ; $aa PHY
>8c86	ce 9d					.word	Assemble_pla                     ; $ab PLA
>8c88	b2 9d					.word	Assemble_plp                     ; $ac PLP
>8c8a	1a 9e					.word	Assemble_plx                     ; $ad PLX
>8c8c	d6 9d					.word	Assemble_ply                     ; $ae PLY
>8c8e	2d 9d					.word	Assemble_rol                     ; $af ROL
>8c90	37 9d					.word	Assemble_ror                     ; $b0 ROR
>8c92	ba 9d					.word	Assemble_rti                     ; $b1 RTI
>8c94	ca 9d					.word	Assemble_rts                     ; $b2 RTS
>8c96	24 9d					.word	Assemble_sbc                     ; $b3 SBC
>8c98	b6 9d					.word	Assemble_sec                     ; $b4 SEC
>8c9a	16 9e					.word	Assemble_sed                     ; $b5 SED
>8c9c	d2 9d					.word	Assemble_sei                     ; $b6 SEI
>8c9e	18 9d					.word	Assemble_sta                     ; $b7 STA
>8ca0	0a 9e					.word	Assemble_stp                     ; $b8 STP
>8ca2	3c 9d					.word	Assemble_stx                     ; $b9 STX
>8ca4	5a 9d					.word	Assemble_sty                     ; $ba STY
>8ca6	50 9d					.word	Assemble_stz                     ; $bb STZ
>8ca8	ee 9d					.word	Assemble_tax                     ; $bc TAX
>8caa	ea 9d					.word	Assemble_tay                     ; $bd TAY
>8cac	73 9d					.word	Assemble_trb                     ; $be TRB
>8cae	6e 9d					.word	Assemble_tsb                     ; $bf TSB
>8cb0	f6 9d					.word	Assemble_tsx                     ; $c0 TSX
>8cb2	de 9d					.word	Assemble_txa                     ; $c1 TXA
>8cb4	e6 9d					.word	Assemble_txs                     ; $c2 TXS
>8cb6	e2 9d					.word	Assemble_tya                     ; $c3 TYA

;******  Return to file: ./common/commands/run.asm


;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/stop.asm

.8cb8					StopCommand:
.8cb8	a9 08		lda #$08		lda	#8
.8cba	4c cd 8d	jmp $8dcd		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/procscan.asm

.8cbd					ProcedureScan:
.8cbd	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8cbf	85 30		sta $30				sta 	codePtr
.8cc1	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8cc3	85 31		sta $31				sta 	codePtr+1
.8cc5					_PSLoop:
.8cc5	b2 30		lda ($30)			lda 	(codePtr)
.8cc7	f0 42		beq $8d0b			beq 	_PSExit
.8cc9	a0 03		ldy #$03			ldy 	#3 							; is it PROC ?
.8ccb	b1 30		lda ($30),y			lda 	(codePtr),y
.8ccd	c9 a2		cmp #$a2			cmp 	#KWD_PROC
.8ccf	d0 2d		bne $8cfe			bne 	_PSNext
.8cd1	c8		iny				iny 								; get the address of the record to zTemp0 and
.8cd2	b1 30		lda ($30),y			lda 	(codePtr),y
.8cd4	29 c0		and #$c0			and 	#$C0
.8cd6	c9 40		cmp #$40			cmp 	#$40
.8cd8	d0 32		bne $8d0c			bne 	_PSSyntax
.8cda	b1 30		lda ($30),y			lda 	(codePtr),y
.8cdc	18		clc				clc
.8cdd	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8cdf	85 37		sta $37				sta 	zTemp0+1
.8ce1	c8		iny				iny 								; LSB
.8ce2	b1 30		lda ($30),y			lda 	(codePtr),y
.8ce4	85 36		sta $36				sta 	zTemp0
.8ce6	c8		iny				iny 								; character after variable call.
.8ce7	98		tya				tya 								; save Y offset at +7
.8ce8	a0 07		ldy #$07			ldy 	#7
.8cea	91 36		sta ($36),y			sta 	(zTemp0),y
.8cec	a9 18		lda #$18			lda 	#NSTProcedure 				; mark it as procedure
.8cee	a0 02		ldy #$02			ldy 	#2
.8cf0	91 36		sta ($36),y			sta 	(zTemp0),y
.8cf2	a2 00		ldx #$00			ldx 	#0 							; copy code-Ptr in
.8cf4					_PSCopy:
.8cf4	b5 30		lda $30,x			lda 	safePtr,x
.8cf6	c8		iny				iny
.8cf7	91 36		sta ($36),y			sta 	(zTemp0),y
.8cf9	e8		inx				inx
.8cfa	e0 04		cpx #$04			cpx 	#4
.8cfc	d0 f6		bne $8cf4			bne 	_PSCopy
.8cfe					_PSNext:
.8cfe	18		clc				clc
.8cff	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8d01	65 30		adc $30				adc 	codePtr
.8d03	85 30		sta $30				sta 	codePtr
.8d05	90 02		bcc $8d09			bcc 	_CREExit
.8d07	e6 31		inc $31				inc 	codePtr+1 					; carry
.8d09					_CREExit:
.8d09	80 ba		bra $8cc5			bra 	_PSLoop
.8d0b					_PSExit:
.8d0b	60		rts				rts
.8d0c					_PSSyntax:
.8d0c	4c 55 9e	jmp $9e55			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/scanforward.asm

.8d0f					ScanForward:
.8d0f	64 38		stz $38				stz 	zTemp1 						; this is the structure count - goes up with WHILE/FOR
.8d11	86 37		stx $37				stx 	zTemp0+1
.8d13	85 36		sta $36				sta 	zTemp0 						; save XA as the two possible matches.
.8d15					_ScanLoop:
.8d15	b1 30		lda ($30),y			lda 	(codePtr),y
.8d17	c8		iny				iny
.8d18	a6 38		ldx $38				ldx 	zTemp1 						; if the count is > 0 cannot match as in substructure
.8d1a	d0 0e		bne $8d2a			bne 	_ScanGoNext
.8d1c	c5 36		cmp $36				cmp 	zTemp0 						; see if either matches
.8d1e	f0 04		beq $8d24			beq 	_ScanMatch
.8d20	c5 37		cmp $37				cmp 	zTemp0+1
.8d22	d0 06		bne $8d2a			bne 	_ScanGoNext
.8d24					_ScanMatch:
.8d24	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if asked for EOL, backtrack.
.8d26	d0 01		bne $8d29			bne 	_ScanNotEndEOL
.8d28	88		dey				dey
.8d29					_ScanNotEndEOL:
.8d29	60		rts				rts
.8d2a					_ScanGoNext:
.8d2a	20 2f 8d	jsr $8d2f			jsr  	ScanForwardOne
.8d2d	80 e6		bra $8d15			bra 	_ScanLoop
.8d2f					ScanForwardOne:
.8d2f	c9 40		cmp #$40			cmp 	#$40 						; if 00-3F, punctuation characters, loop back
.8d31	90 3e		bcc $8d71			bcc 	_SFWExit
.8d33	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if 40-82, skip one extra.
.8d35	90 18		bcc $8d4f			bcc 	_ScanSkipOne
.8d37	c9 fc		cmp #$fc			cmp 	#$FC 						; FC-FF are data skips
.8d39	b0 2f		bcs $8d6a			bcs 	_ScanSkipData
.8d3b	c9 a0		cmp #$a0			cmp 	#KWC_FIRST_STRUCTURE 		; structure keyword ?
.8d3d	90 32		bcc $8d71			bcc 	_SFWExit 					; if not, ordinary keywords.
.8d3f	c9 ab		cmp #$ab			cmp 	#KWC_LAST_STRUCTURE+1
.8d41	b0 2e		bcs $8d71			bcs 	_SFWExit
.8d43	c6 38		dec $38				dec 	zTemp1 						; decrement the sructure count
.8d45	c9 a5		cmp #$a5			cmp 	#KWC_FIRST_STRUCTURE_DEC 	; back if it is a dec structure (e.g. WEND/NEXT)
.8d47	b0 28		bcs $8d71			bcs 	_SFWExit
.8d49	e6 38		inc $38				inc 	zTemp1 						; so it's an increment structure
.8d4b	e6 38		inc $38				inc 	zTemp1 						; twice to undo the dec
.8d4d	80 22		bra $8d71			bra 	_SFWExit
.8d4f					_ScanSkipOne:
.8d4f	c8		iny				iny 								; consume the extra one.
.8d50	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if not EOL loop back
.8d52	d0 1d		bne $8d71			bne 	_SFWExit
.8d54	18		clc				clc
.8d55	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8d57	65 30		adc $30				adc 	codePtr
.8d59	85 30		sta $30				sta 	codePtr
.8d5b	90 02		bcc $8d5f			bcc 	_CREExit
.8d5d	e6 31		inc $31				inc 	codePtr+1 					; carry
.8d5f					_CREExit:
.8d5f	a0 03		ldy #$03			ldy 	#3 							; scan start position.
.8d61	b2 30		lda ($30)			lda 	(codePtr)
.8d63	d0 0c		bne $8d71			bne 	_SFWExit 					; if not zero, more to scan
.8d65	a9 13		lda #$13		lda	#19
.8d67	4c cd 8d	jmp $8dcd		jmp	ErrorHandler
.8d6a					_ScanSkipData:
.8d6a	88		dey				dey 								; point at data token
.8d6b	c8		iny				iny 								; point to offset
.8d6c	98		tya				tya 								; A = offset position
.8d6d	38		sec				sec 								; add size +1 hence SEC
.8d6e	71 30		adc ($30),y			adc 	(codePtr),y
.8d70	a8		tay				tay 								; make current position.
.8d71					_SFWExit:
.8d71	60		rts				rts
.8d72					ScanGetCurrentLineStep:
.8d72	64 38		stz $38				stz 	zTemp1
.8d74	a0 03		ldy #$03			ldy 	#3
.8d76					_SGCLSLoop:
.8d76	b1 30		lda ($30),y			lda 	(codePtr),y
.8d78	c8		iny				iny
.8d79	c9 80		cmp #$80			cmp 	#KWC_EOL	 				; if EOL exit
.8d7b	f0 05		beq $8d82			beq 	_SGCLSExit
.8d7d	20 2f 8d	jsr $8d2f			jsr 	ScanForwardOne
.8d80	80 f4		bra $8d76			bra 	_SGCLSLoop
.8d82					_SGCLSExit:
.8d82	a5 38		lda $38				lda 	zTemp1
.8d84	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/while.asm

.8d85					Command_WHILE:
.8d85	5a		phy				phy 								; save position of the test
.8d86	a2 00		ldx #$00			ldx 	#0
.8d88	20 2b 9c	jsr $9c2b			jsr 	EvaluateNumber 				; work out the number
.8d8b	20 ff 9c	jsr $9cff			jsr 	NSMIsZero 					; check if zero
.8d8e	f0 0e		beq $8d9e			beq 	_WHExitLoop 				; if so exit the loop
.8d90	98		tya				tya 								; position *after* test.
.8d91	7a		ply				ply 								; restore position before test, at WHILE
.8d92	88		dey				dey
.8d93	48		pha				pha 								; push after test on the stack
.8d94	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; allocate 6 bytes on the return stack.
.8d96	20 1a a5	jsr $a51a			jsr 	StackOpen
.8d99	20 5e a5	jsr $a55e			jsr 	STKSaveCodePosition 		; save loop position - where the test value is.
.8d9c	7a		ply				ply 								; restore the position *after* the test
.8d9d	60		rts				rts
.8d9e					_WHExitLoop:
.8d9e	68		pla				pla 								; throw post loop position
.8d9f	a9 aa		lda #$aa			lda 	#KWD_WEND 					; scan forward past WEND
.8da1	aa		tax				tax
.8da2	20 0f 8d	jsr $8d0f			jsr 	ScanForward
.8da5	60		rts				rts
.8da6					Command_WEND:
.8da6	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; check WHILE is TOS
.8da8	a2 10		ldx #$10			ldx 	#ERRID_WHILE 				; this error
.8daa	20 46 a5	jsr $a546			jsr 	StackCheckFrame
.8dad	20 6f a5	jsr $a56f			jsr 	STKLoadCodePosition 		; loop back
.8db0	20 38 a5	jsr $a538			jsr 	StackClose		 			; erase the frame
.8db3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/charcheck.asm

.8db4					CheckRightBracket:
.8db4	b1 30		lda ($30),y			lda 	(codePtr),y
.8db6	c8		iny				iny
.8db7	c9 29		cmp #$29			cmp 	#KWD_RPAREN 						; exit if matches
.8db9	d0 0f		bne $8dca			bne 	CNAFail
.8dbb	60		rts				rts
.8dbc					CheckComma:
.8dbc	b1 30		lda ($30),y			lda 	(codePtr),y
.8dbe	c8		iny				iny
.8dbf	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 						; exit if matches
.8dc1	d0 07		bne $8dca			bne 	CNAFail
.8dc3	60		rts				rts
.8dc4					CheckNextA:
.8dc4	d1 30		cmp ($30),y			cmp 	(codePtr),y
.8dc6	d0 02		bne $8dca			bne 	CNAFail
.8dc8	c8		iny				iny 								; skip character
.8dc9	60		rts				rts 								; and exit
.8dca					CNAFail:
.8dca	4c 55 9e	jmp $9e55			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/errors.asm

.8dcd					ErrorHandler:
.8dcd	a8		tay				tay 								; find the error text
.8dce	f0 49		beq $8e19			beq 	_EHEnd
.8dd0	a2 00		ldx #$00			ldx 	#0
.8dd2	a9 6e		lda #$6e			lda 	#((ErrorText) & $FF)
.8dd4	85 36		sta $36				sta 	0+zTemp0
.8dd6	a9 9e		lda #$9e			lda 	#((ErrorText) >> 8)
.8dd8	85 37		sta $37				sta 	1+zTemp0
.8dda					_EHFind:
.8dda	88		dey				dey 								; found the error text ?
.8ddb	f0 0e		beq $8deb			beq 	_EHFound
.8ddd					_EHFindZero:
.8ddd	b2 36		lda ($36)			lda 	(zTemp0) 					; find the next error
.8ddf	e6 36		inc $36				inc 	zTemp0
.8de1	d0 02		bne $8de5			bne 	_EHFNoCarry
.8de3	e6 37		inc $37				inc 	zTemp0+1
.8de5					_EHFNoCarry:
.8de5	c9 00		cmp #$00			cmp 	#0
.8de7	d0 f4		bne $8ddd			bne 	_EHFindZero
.8de9	80 ef		bra $8dda			bra 	_EHFind
.8deb					_EHFound:
.8deb	a5 36		lda $36				lda 	zTemp0 						; print message
.8ded	a6 37		ldx $37				ldx 	zTemp0+1
.8def	20 26 8e	jsr $8e26			jsr 	PrintStringXA
.8df2	a0 01		ldy #$01			ldy 	#1 							; if line number zero don't print i
.8df4	b1 30		lda ($30),y			lda 	(codePtr),y
.8df6	d0 05		bne $8dfd			bne 	_EHAtMsg
.8df8	c8		iny				iny
.8df9	b1 30		lda ($30),y			lda 	(codePtr),y
.8dfb	f0 17		beq $8e14			beq 	_EHCREnd
.8dfd					_EHAtMsg:
.8dfd	a2 8e		ldx #$8e			ldx 	#_AtMsg >> 8 				; print " at "
.8dff	a9 1c		lda #$1c			lda 	#_AtMsg & $FF
.8e01	20 26 8e	jsr $8e26			jsr 	PrintStringXA
.8e04	a0 01		ldy #$01			ldy 	#1 							; line number into XA
.8e06	b1 30		lda ($30),y			lda 	(codePtr),y
.8e08	48		pha				pha
.8e09	c8		iny				iny
.8e0a	b1 30		lda ($30),y			lda 	(codePtr),y
.8e0c	aa		tax				tax
.8e0d	68		pla				pla
.8e0e	20 3c 92	jsr $923c			jsr 	LCLConvertInt16 				; convert XA to string
.8e11	20 26 8e	jsr $8e26			jsr 	PrintStringXA 				; and print it.
.8e14					_EHCREnd:
.8e14	a9 0d		lda #$0d			lda 	#13 						; new line
.8e16	20 51 a6	jsr $a651			jsr 	EXTPrintCharacter
.8e19					_EHEnd:
.8e19	4c 62 83	jmp $8362			jmp 	WarmStart
>8e1c	20 61 74 20 6c 69 6e 65		_AtMsg:	.text 	" at line ",0
>8e24	20 00
.8e26					PrintStringXA:
.8e26	5a		phy				phy
.8e27	86 37		stx $37				stx 	zTemp0+1
.8e29	85 36		sta $36				sta 	zTemp0
.8e2b	a0 00		ldy #$00			ldy 	#0
.8e2d					_PSXALoop:
.8e2d	b1 36		lda ($36),y			lda 	(zTemp0),y
.8e2f	f0 06		beq $8e37			beq 	_PSXAExit
.8e31	20 51 a6	jsr $a651			jsr 	EXTPrintCharacter
.8e34	c8		iny				iny
.8e35	80 f6		bra $8e2d			bra 	_PSXALoop
.8e37					_PSXAExit:
.8e37	7a		ply				ply
.8e38	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/compare.asm

.8e39					UnaryTrue:
.8e39	fa		plx				plx
.8e3a					ReturnTrue:
.8e3a	a9 01		lda #$01			lda 	#1  						; set to 1
.8e3c	20 df 9c	jsr $9cdf			jsr 	NSMSetByte
.8e3f	a9 80		lda #$80			lda 	#$80 						; set sign flag, so it is -1
.8e41	95 50		sta $50,x			sta 	NSStatus,x
.8e43	60		rts				rts
.8e44					UnaryFalse:
.8e44	fa		plx				plx
.8e45					ReturnFalse:
.8e45	4c dd 9c	jmp $9cdd			jmp 	NSMSetZero 					; set it all to zero
.8e48					BinaryCompareEqual:
.8e48	fa		plx				plx
.8e49	20 84 8e	jsr $8e84			jsr 	CompareBaseCode
.8e4c	c9 00		cmp #$00			cmp 	#0
.8e4e	f0 ea		beq $8e3a			beq 	ReturnTrue
.8e50	80 f3		bra $8e45			bra 	ReturnFalse
.8e52					BinaryCompareLess:
.8e52	fa		plx				plx
.8e53	20 84 8e	jsr $8e84			jsr 	CompareBaseCode
.8e56	c9 ff		cmp #$ff			cmp 	#$FF
.8e58	f0 e0		beq $8e3a			beq 	ReturnTrue
.8e5a	80 e9		bra $8e45			bra 	ReturnFalse
.8e5c					BinaryCompareGreater:
.8e5c	fa		plx				plx
.8e5d	20 84 8e	jsr $8e84			jsr 	CompareBaseCode
.8e60	c9 01		cmp #$01			cmp 	#1
.8e62	f0 d6		beq $8e3a			beq 	ReturnTrue
.8e64	80 df		bra $8e45			bra 	ReturnFalse
.8e66					BinaryCompareNotEqual:
.8e66	fa		plx				plx
.8e67	20 84 8e	jsr $8e84			jsr 	CompareBaseCode
.8e6a	c9 00		cmp #$00			cmp 	#0
.8e6c	d0 cc		bne $8e3a			bne 	ReturnTrue
.8e6e	80 d5		bra $8e45			bra 	ReturnFalse
.8e70					BinaryCompareLessEqual:
.8e70	fa		plx				plx
.8e71	20 84 8e	jsr $8e84			jsr 	CompareBaseCode
.8e74	c9 01		cmp #$01			cmp 	#1
.8e76	d0 c2		bne $8e3a			bne 	ReturnTrue
.8e78	80 cb		bra $8e45			bra 	ReturnFalse
.8e7a					BinaryCompareGreaterEqual:
.8e7a	fa		plx				plx
.8e7b	20 84 8e	jsr $8e84			jsr 	CompareBaseCode
.8e7e	c9 ff		cmp #$ff			cmp 	#$FF
.8e80	d0 b8		bne $8e3a			bne 	ReturnTrue
.8e82	80 c1		bra $8e45			bra 	ReturnFalse
.8e84					CompareBaseCode:
.8e84	20 8f 95	jsr $958f			jsr 	DereferenceTopTwo 			; make both values if references.
.8e87	b5 50		lda $50,x			lda 	NSStatus,x 					; check if either is a string.
.8e89	15 51		ora $51,x			ora 	NSStatus+1,x
.8e8b	29 10		and #$10			and 	#NSTString
.8e8d	d0 37		bne $8ec6			bne 	_CBCString 					; if so do string code, which will check if both.
.8e8f	b5 78		lda $78,x			lda 	NSExponent,x 				; check both are integers
.8e91	15 79		ora $79,x			ora 	NSExponent+1,x
.8e93	d0 34		bne $8ec9			bne 	_CBCFloat
.8e95	b5 50		lda $50,x			lda 	NSStatus,x
.8e97	15 51		ora $51,x			ora 	NSStatus+1,x
.8e99	29 08		and #$08			and 	#NSTFloat
.8e9b	d0 2c		bne $8ec9			bne 	_CBCFloat
.8e9d	20 cc 8e	jsr $8ecc			jsr 	CompareFixMinusZero 		; fix up -0 just in cases.
.8ea0	e8		inx				inx
.8ea1	20 cc 8e	jsr $8ecc			jsr 	CompareFixMinusZero
.8ea4	ca		dex				dex
.8ea5	b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs different ?
.8ea7	55 51		eor $51,x			eor 	NSStatus+1,x
.8ea9	10 0a		bpl $8eb5			bpl 	_CDCSameSign
.8eab	b5 50		lda $50,x			lda 	NSStatus,x 					; if first one is -ve
.8ead	30 14		bmi $8ec3			bmi 	_CBCLess 					; return $FF
.8eaf					_CBCGreater:
.8eaf	a9 01		lda #$01			lda 	#1
.8eb1	60		rts				rts
.8eb2					_CBCEqual:
.8eb2	a9 00		lda #$00			lda 	#0
.8eb4	60		rts				rts
.8eb5					_CDCSameSign:
.8eb5	20 e1 90	jsr $90e1			jsr 	SubTopTwoStack 				; unsigned subtract
.8eb8	20 ff 9c	jsr $9cff			jsr 	NSMIsZero 					; or the mantissa together
.8ebb	f0 f5		beq $8eb2			beq 	_CBCEqual 					; -0 == 0
.8ebd	b5 70		lda $70,x			lda 	NSMantissa3,x 				; sign of the result. if +ve return $01 else return $FF
.8ebf	55 51		eor $51,x			eor 	NSStatus+1,x 				; however if both were -ve this is inverted
.8ec1	10 ec		bpl $8eaf			bpl 	_CBCGreater
.8ec3					_CBCLess:
.8ec3	a9 ff		lda #$ff			lda 	#$FF
.8ec5	60		rts				rts
.8ec6					_CBCString:
.8ec6	4c 52 90	jmp $9052			jmp 	CompareStrings
.8ec9					_CBCFloat:
.8ec9	4c 9c 93	jmp $939c			jmp 	CompareFloat
.8ecc					CompareFixMinusZero:
.8ecc	20 ff 9c	jsr $9cff			jsr 	NSMIsZero
.8ecf	d0 02		bne $8ed3			bne 	_CFXMZNotZero
.8ed1	74 50		stz $50,x			stz 	NSStatus,x
.8ed3					_CFXMZNotZero:
.8ed3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/concat.asm

.8ed4					StringConcat:
.8ed4	b5 50		lda $50,x			lda 	NSStatus,x 					; check both strings
.8ed6	35 51		and $51,x			and 	NSStatus+1,x
.8ed8	29 18		and #$18			and 	#NSBTypeMask
.8eda	c9 10		cmp #$10			cmp 	#NSTString
.8edc	d0 50		bne $8f2e			bne		_SCType
.8ede	64 38		stz $38				stz 	zTemp1 						; counting total length
.8ee0	e8		inx				inx
.8ee1	20 ff 8e	jsr $8eff			jsr 	_SCSetupZ0 					; setup for second
.8ee4	20 08 8f	jsr $8f08			jsr 	_SCLengthZ0 				; length for second
.8ee7	ca		dex				dex
.8ee8	20 ff 8e	jsr $8eff			jsr 	_SCSetupZ0 					; setup for first
.8eeb	20 08 8f	jsr $8f08			jsr 	_SCLengthZ0 				; length for first
.8eee	a5 38		lda $38				lda 	zTemp1 						; allocate memory using total.
.8ef0	20 09 a6	jsr $a609			jsr 	StringTempAllocate
.8ef3	20 1f 8f	jsr $8f1f			jsr 	_SCCopy 					; copy first out, using zTemp0 from above
.8ef6	e8		inx				inx
.8ef7	20 ff 8e	jsr $8eff			jsr 	_SCSetupZ0 					; copy second out
.8efa	20 1f 8f	jsr $8f1f			jsr 	_SCCopy
.8efd	ca		dex				dex
.8efe	60		rts				rts
.8eff					_SCSetupZ0:
.8eff	b5 58		lda $58,x			lda 	NSMantissa0,x
.8f01	85 36		sta $36				sta 	zTemp0
.8f03	b5 60		lda $60,x			lda 	NSMantissa1,x
.8f05	85 37		sta $37				sta 	zTemp0+1
.8f07	60		rts				rts
.8f08					_SCLengthZ0:
.8f08	5a		phy				phy
.8f09	a0 00		ldy #$00			ldy 	#0
.8f0b					_SCLenLoop:
.8f0b	b1 36		lda ($36),y			lda 	(zTemp0),y
.8f0d	f0 0e		beq $8f1d			beq 	_SCLExit
.8f0f	c8		iny				iny
.8f10	e6 38		inc $38				inc 	zTemp1
.8f12	a5 38		lda $38				lda	 	zTemp1 						; check string too long.
.8f14	c9 fd		cmp #$fd			cmp 	#253
.8f16	d0 f3		bne $8f0b			bne		_SCLenLoop
.8f18	a9 09		lda #$09		lda	#9
.8f1a	4c cd 8d	jmp $8dcd		jmp	ErrorHandler
.8f1d					_SCLExit:
.8f1d	7a		ply				ply
.8f1e	60		rts				rts
.8f1f					_SCCopy:
.8f1f	5a		phy				phy
.8f20	a0 00		ldy #$00			ldy 	#0
.8f22					_SCCopyLoop:
.8f22	b1 36		lda ($36),y			lda 	(zTemp0),y
.8f24	f0 06		beq $8f2c			beq 	_SCCExit
.8f26	20 42 a6	jsr $a642			jsr 	StringTempWrite
.8f29	c8		iny				iny
.8f2a	80 f6		bra $8f22			bra 	_SCCopyLoop
.8f2c					_SCCExit:
.8f2c	7a		ply				ply
.8f2d	60		rts				rts
.8f2e					_SCType:
.8f2e	4c 5f 9e	jmp $9e5f			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/divide.asm

.8f31					IntegerDivide:
.8f31	fa		plx				plx
.8f32	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.8f34	15 51		ora $51,x			ora 	NSStatus+1,x
.8f36	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8f37	0a		asl a				asl 	a
.8f38	10 05		bpl $8f3f			bpl 	_NotRef
.8f3a	48		pha				pha
.8f3b	20 8f 95	jsr $958f			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8f3e	68		pla				pla
.8f3f					_NotRef:
.8f3f	0a		asl a				asl 	a
.8f40	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.8f42	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8f44	15 79		ora $79,x			ora 	NSExponent+1,x
.8f46	f0 03		beq $8f4b			beq 	_IntegerCode 				; if clear, then we have two integers
.8f48	4c 5f 9e	jmp $9e5f			jmp 	TypeError 					; anything else, type mismatch.
.8f4b					_IntegerCode:
.8f4b	20 65 8f	jsr $8f65			jsr 	CheckDivideZero 			; do div zero check
.8f4e	20 97 8f	jsr $8f97			jsr 	Int32Divide 				; do the division
.8f51	20 48 90	jsr $9048			jsr 	CalculateSign 				; calculate result sign
.8f54					NSMCopyPlusTwoToZero:
.8f54	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.8f56	95 58		sta $58,x			sta 	NSMantissa0,x
.8f58	b5 62		lda $62,x			lda 	NSMantissa1+2,x
.8f5a	95 60		sta $60,x			sta 	NSMantissa1,x
.8f5c	b5 6a		lda $6a,x			lda 	NSMantissa2+2,x
.8f5e	95 68		sta $68,x			sta 	NSMantissa2,x
.8f60	b5 72		lda $72,x			lda 	NSMantissa3+2,x
.8f62	95 70		sta $70,x			sta 	NSMantissa3,x
.8f64	60		rts				rts
.8f65					CheckDivideZero:
.8f65	e8		inx				inx
.8f66	20 ff 9c	jsr $9cff			jsr 	NSMIsZero
.8f69	f0 02		beq $8f6d			beq 	_CDVError
.8f6b	ca		dex				dex
.8f6c	60		rts				rts
.8f6d					_CDVError:
.8f6d	a9 03		lda #$03		lda	#3
.8f6f	4c cd 8d	jmp $8dcd		jmp	ErrorHandler
.8f72					IntegerModulus:
.8f72	fa		plx				plx
.8f73	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.8f75	15 51		ora $51,x			ora 	NSStatus+1,x
.8f77	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8f78	0a		asl a				asl 	a
.8f79	10 05		bpl $8f80			bpl 	_NotRef
.8f7b	48		pha				pha
.8f7c	20 8f 95	jsr $958f			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8f7f	68		pla				pla
.8f80					_NotRef:
.8f80	0a		asl a				asl 	a
.8f81	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.8f83	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8f85	15 79		ora $79,x			ora 	NSExponent+1,x
.8f87	f0 03		beq $8f8c			beq 	_IntegerCode 				; if clear, then we have two integers
.8f89	4c 5f 9e	jmp $9e5f			jmp 	TypeError 					; anything else, type mismatch.
.8f8c					_IntegerCode:
.8f8c					IntegerModulusNoCheck:
.8f8c	20 65 8f	jsr $8f65			jsr 	CheckDivideZero 			; do div zero check
.8f8f	20 97 8f	jsr $8f97			jsr 	Int32Divide 				; do the division
.8f92	16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.8f94	56 50		lsr $50,x			lsr 	NSStatus,x
.8f96	60		rts				rts
.8f97					Int32Divide:
.8f97	48		pha				pha 								; save AXY
.8f98	5a		phy				phy
.8f99	20 c0 9c	jsr $9cc0			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.8f9c	20 d9 9c	jsr $9cd9			jsr 	NSMSetZeroMantissaOnly 		; set S[X] to zero
.8f9f	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.8fa1					_I32DivideLoop:
.8fa1	e8		inx				inx
.8fa2	e8		inx				inx
.8fa3	20 ec 9c	jsr $9cec			jsr 	NSMShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.8fa6	ca		dex				dex
.8fa7	ca		dex				dex
.8fa8	20 ed 9c	jsr $9ced			jsr 	NSMRotateLeft
.8fab	20 d6 8f	jsr $8fd6			jsr 	DivideCheckSubtract 		; check if subtract possible
.8fae	90 02		bcc $8fb2			bcc 	_I32DivideNoCarryIn
.8fb0	f6 5a		inc $5a,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.8fb2					_I32DivideNoCarryIn:
.8fb2	88		dey				dey 								; loop round till division completed.
.8fb3	d0 ec		bne $8fa1			bne 	_I32DivideLoop
.8fb5	7a		ply				ply 								; restore AXY and exit
.8fb6	68		pla				pla
.8fb7	60		rts				rts
.8fb8					Int32ShiftDivide:
.8fb8	48		pha				pha 								; save AY
.8fb9	5a		phy				phy
.8fba	e8		inx				inx 								; clear S[X+2]
.8fbb	e8		inx				inx
.8fbc	20 dd 9c	jsr $9cdd			jsr 	NSMSetZero
.8fbf	ca		dex				dex
.8fc0	ca		dex				dex
.8fc1	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.8fc3					_I32SDLoop:
.8fc3	20 d6 8f	jsr $8fd6			jsr 	DivideCheckSubtract 		; check if subtract possible
.8fc6	e8		inx				inx
.8fc7	e8		inx				inx
.8fc8	20 ed 9c	jsr $9ced			jsr 	NSMRotateLeft				; shift 64 bit FPA left, rotating carry in
.8fcb	ca		dex				dex
.8fcc	ca		dex				dex
.8fcd	20 ed 9c	jsr $9ced			jsr 	NSMRotateLeft
.8fd0	88		dey				dey 	 							; do 31 times
.8fd1	d0 f0		bne $8fc3			bne 	_I32SDLoop
.8fd3	7a		ply				ply 								; restore AY and exit
.8fd4	68		pla				pla
.8fd5	60		rts				rts
.8fd6					DivideCheckSubtract:
.8fd6	20 e1 90	jsr $90e1			jsr 	SubTopTwoStack 				; subtract Stack[X+1] from Stack[X+0]
.8fd9	b0 04		bcs $8fdf			bcs 	_DCSExit 					; if carry set, then could do, exit
.8fdb	20 c7 90	jsr $90c7			jsr 	AddTopTwoStack 				; add it back in
.8fde	18		clc				clc 								; and return False
.8fdf					_DCSExit:
.8fdf	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/multiply.asm

.8fe0					MulInteger:
.8fe0	fa		plx				plx
.8fe1	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.8fe3	15 51		ora $51,x			ora 	NSStatus+1,x
.8fe5	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8fe6	0a		asl a				asl 	a
.8fe7	10 05		bpl $8fee			bpl 	_NotRef
.8fe9	48		pha				pha
.8fea	20 8f 95	jsr $958f			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8fed	68		pla				pla
.8fee					_NotRef:
.8fee	0a		asl a				asl 	a 							; put MSB of type into A:7
.8fef	30 09		bmi $8ffa			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.8ff1	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8ff3	15 79		ora $79,x			ora 	NSExponent+1,x
.8ff5	f0 06		beq $8ffd			beq 	_IntegerCode 				; if clear, then we have two integers
.8ff7	4c 5e 94	jmp $945e			jmp 	FloatingPointMultiply 							; otherwise at least one float.
.8ffa					_StringData:
.8ffa	4c 69 9e	jmp $9e69			jmp 	NotDoneError							; at least one string - don't know both are strings.
.8ffd					_IntegerCode:
.8ffd	20 0a 90	jsr $900a			jsr 	MultiplyShort
.9000	c9 00		cmp #$00			cmp 	#0
.9002	f0 05		beq $9009			beq 	_MIExit
.9004	a9 04		lda #$04		lda	#4
.9006	4c cd 8d	jmp $8dcd		jmp	ErrorHandler
.9009					_MIExit:
.9009	60		rts				rts
.900a					MultiplyShort:
.900a	5a		phy				phy 								; save Y
.900b	20 c0 9c	jsr $9cc0			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.900e	20 d9 9c	jsr $9cd9			jsr 	NSMSetZeroMantissaOnly 		; set mantissa S[X] to zero
.9011	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.9013					_I32MLoop:
.9013	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.9015	15 62		ora $62,x			ora 	NSMantissa1+2,x
.9017	15 6a		ora $6a,x			ora 	NSMantissa2+2,x
.9019	15 72		ora $72,x			ora 	NSMantissa3+2,x
.901b	f0 25		beq $9042			beq 	_I32MExit 					; exit if zero
.901d	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.901f	29 01		and #$01			and 	#1
.9021	f0 0d		beq $9030			beq 	_I32MNoAdd
.9023	20 c7 90	jsr $90c7			jsr 	AddTopTwoStack 				; if so add S[X+1] to S[X+0]
.9026	b5 70		lda $70,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.9028	10 06		bpl $9030			bpl 	_I32MNoAdd
.902a					_I32ShiftRight:
.902a	20 f6 9c	jsr $9cf6			jsr 	NSMShiftRight 				; shift S[X] right
.902d	c8		iny				iny 								; increment shift count
.902e	80 09		bra $9039			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.9030					_I32MNoAdd:
.9030	34 71		bit $71,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.9032	70 f6		bvs $902a			bvs 	_I32ShiftRight 				; instead.
.9034	e8		inx				inx
.9035	20 ec 9c	jsr $9cec			jsr 	NSMShiftLeft 				; shift additive S[X+1] left
.9038	ca		dex				dex
.9039					_I32MShiftUpper:
.9039	e8		inx				inx 								; shift S[X+2] right
.903a	e8		inx				inx
.903b	20 f6 9c	jsr $9cf6			jsr 	NSMShiftRight
.903e	ca		dex				dex
.903f	ca		dex				dex
.9040	80 d1		bra $9013			bra 	_I32MLoop 					; try again.
.9042					_I32MExit:
.9042	20 48 90	jsr $9048			jsr 	CalculateSign
.9045	98		tya				tya 								; shift in A
.9046	7a		ply				ply 								; restore Y and exit
.9047	60		rts				rts
.9048					CalculateSign:
.9048	b5 50		lda $50,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.904a	16 50		asl $50,x			asl 	NSStatus,x 					; shift result left
.904c	55 51		eor $51,x			eor 	NSStatus+1,x
.904e	0a		asl a				asl 	a 							; shift bit 7 into carry
.904f	76 50		ror $50,x			ror 	NSStatus,x 					; shift right into status byte.
.9051	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/scompare.asm

.9052					CompareStrings:
.9052	b5 50		lda $50,x			lda 	NSStatus,x 					; check both are strings
.9054	35 51		and $51,x			and 	NSStatus+1,x
.9056	29 10		and #$10			and 	#NSBIsString
.9058	f0 28		beq $9082			beq 	_CSTypeError
.905a	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy string addresses to zTemp0/1
.905c	85 36		sta $36				sta 	zTemp0
.905e	b5 60		lda $60,x			lda 	NSMantissa1,x
.9060	85 37		sta $37				sta 	zTemp0+1
.9062	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9064	85 38		sta $38				sta 	zTemp1
.9066	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9068	85 39		sta $39				sta 	zTemp1+1
.906a	5a		phy				phy 								; save Y so we can access strings
.906b	a0 ff		ldy #$ff			ldy 	#$FF 						; -1 for pre increment.
.906d					_CSLoop:
.906d	c8		iny				iny
.906e	b1 36		lda ($36),y			lda 	(zTemp0),y 					; check if they are the same
.9070	d1 38		cmp ($38),y			cmp 	(zTemp1),y
.9072	d0 06		bne $907a			bne 	_CSDifferent
.9074	c9 00		cmp #$00			cmp 	#0 							; reached end ?
.9076	d0 f5		bne $906d			bne 	_CSLoop 					; still comparing
.9078					_CSExit:
.9078	7a		ply				ply 								; reached end, return zero in A from EOS
.9079	60		rts				rts
.907a					_CSDifferent:
.907a	a9 ff		lda #$ff			lda 	#255 						; if < return $FF
.907c	90 fa		bcc $9078			bcc		_CSExit
.907e	a9 01		lda #$01			lda 	#1 							; otherwise return 1.
.9080	80 f6		bra $9078			bra 	_CSExit
.9082					_CSTypeError:
.9082	4c 5f 9e	jmp $9e5f			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/shifts.asm

.9085					ShiftLeft:
.9085	38		sec				sec 								; common code, carry determines which way.
.9086	80 01		bra $9089			bra 	ShiftMain
.9088					ShiftRight:
.9088	18		clc				clc
.9089					ShiftMain:
.9089	fa		plx				plx 								; restore X
.908a	08		php				php 								; save direction
.908b	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.908d	15 51		ora $51,x			ora 	NSStatus+1,x
.908f	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9090	0a		asl a				asl 	a
.9091	10 05		bpl $9098			bpl 	_NotRef
.9093	48		pha				pha
.9094	20 8f 95	jsr $958f			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9097	68		pla				pla
.9098					_NotRef:
.9098	0a		asl a				asl 	a
.9099	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.909b	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.909d	15 79		ora $79,x			ora 	NSExponent+1,x
.909f	f0 03		beq $90a4			beq 	_IntegerCode 				; if clear, then we have two integers
.90a1	4c 5f 9e	jmp $9e5f			jmp 	TypeError 					; anything else, type mismatch.
.90a4					_IntegerCode:
.90a4	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; check number < 32
.90a6	29 e0		and #$e0			and 	#$E0
.90a8	15 61		ora $61,x			ora 	NSMantissa1+1,x
.90aa	15 69		ora $69,x			ora 	NSMantissa2+1,x
.90ac	15 71		ora $71,x			ora 	NSMantissa3+1,x
.90ae	d0 12		bne $90c2			bne 	_SMExit0 					; if >= 32 it will always return zero.
.90b0					_SMLoop:
.90b0	d6 59		dec $59,x			dec 	NSMantissa0+1,x 			; predecrement, could do << 0
.90b2	30 11		bmi $90c5			bmi 	_SMExit 					; exit if done.
.90b4	28		plp				plp 								; restore direction setting
.90b5	08		php				php
.90b6	90 05		bcc $90bd			bcc 	_SMRight
.90b8	20 ec 9c	jsr $9cec			jsr 	NSMShiftLeft 				; shift left if CS
.90bb	80 f3		bra $90b0			bra 	_SMLoop
.90bd					_SMRight:
.90bd	20 f6 9c	jsr $9cf6			jsr 	NSMShiftRight 				; shift right if CC
.90c0	80 ee		bra $90b0			bra 	_SMLoop
.90c2					_SMExit0:
.90c2	20 dd 9c	jsr $9cdd			jsr 	NSMSetZero 					; return zero.
.90c5					_SMExit:
.90c5	28		plp				plp 								; throw direction
.90c6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/simple.asm

.90c7					AddTopTwoStack:
.90c7	18		clc				clc
.90c8	b5 58		lda $58,x			lda		NSMantissa0,x
.90ca	75 59		adc $59,x			adc 		NSMantissa0+1,x
.90cc	95 58		sta $58,x			sta 	NSMantissa0,x
.90ce	b5 60		lda $60,x			lda		NSMantissa1,x
.90d0	75 61		adc $61,x			adc 		NSMantissa1+1,x
.90d2	95 60		sta $60,x			sta 	NSMantissa1,x
.90d4	b5 68		lda $68,x			lda		NSMantissa2,x
.90d6	75 69		adc $69,x			adc 		NSMantissa2+1,x
.90d8	95 68		sta $68,x			sta 	NSMantissa2,x
.90da	b5 70		lda $70,x			lda		NSMantissa3,x
.90dc	75 71		adc $71,x			adc 		NSMantissa3+1,x
.90de	95 70		sta $70,x			sta 	NSMantissa3,x
.90e0	60		rts				rts
.90e1					SubTopTwoStack:
.90e1	38		sec				sec
.90e2	b5 58		lda $58,x			lda		NSMantissa0,x
.90e4	f5 59		sbc $59,x			sbc 		NSMantissa0+1,x
.90e6	95 58		sta $58,x			sta 	NSMantissa0,x
.90e8	b5 60		lda $60,x			lda		NSMantissa1,x
.90ea	f5 61		sbc $61,x			sbc 		NSMantissa1+1,x
.90ec	95 60		sta $60,x			sta 	NSMantissa1,x
.90ee	b5 68		lda $68,x			lda		NSMantissa2,x
.90f0	f5 69		sbc $69,x			sbc 		NSMantissa2+1,x
.90f2	95 68		sta $68,x			sta 	NSMantissa2,x
.90f4	b5 70		lda $70,x			lda		NSMantissa3,x
.90f6	f5 71		sbc $71,x			sbc 		NSMantissa3+1,x
.90f8	95 70		sta $70,x			sta 	NSMantissa3,x
.90fa	60		rts				rts
.90fb					AddInteger:
.90fb	fa		plx				plx
.90fc	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.90fe	15 51		ora $51,x			ora 	NSStatus+1,x
.9100	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9101	0a		asl a				asl 	a
.9102	10 05		bpl $9109			bpl 	_NotRef
.9104	48		pha				pha
.9105	20 8f 95	jsr $958f			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9108	68		pla				pla
.9109					_NotRef:
.9109	0a		asl a				asl 	a 							; put MSB of type into A:7
.910a	30 09		bmi $9115			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.910c	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.910e	15 79		ora $79,x			ora 	NSExponent+1,x
.9110	f0 06		beq $9118			beq 	_IntegerCode 				; if clear, then we have two integers
.9112	4c 0e 93	jmp $930e			jmp 	FloatingPointAdd 							; otherwise at least one float.
.9115					_StringData:
.9115	4c d4 8e	jmp $8ed4			jmp 	StringConcat							; at least one string - don't know both are strings.
.9118					_IntegerCode:
.9118					AddCode:
.9118	b5 50		lda $50,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.911a	55 51		eor $51,x			eor 	NSStatus+1,x
.911c	10 a9		bpl $90c7			bpl 	AddTopTwoStack
.911e	20 e1 90	jsr $90e1			jsr 	SubTopTwoStack 				; do a physical subtraction
.9121	34 70		bit $70,x			bit 	NSMantissa3,x 				; result is +ve, okay
.9123	10 07		bpl $912c			bpl 	_AddExit
.9125	b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign is that of 2nd value
.9127	95 50		sta $50,x			sta 	NSStatus,x
.9129	20 a6 9c	jsr $9ca6			jsr 	NSMNegateMantissa 			; negate the mantissa and exit
.912c					_AddExit:
.912c	20 ff 9c	jsr $9cff			jsr 	NSMIsZero 					; check for -0
.912f	d0 02		bne $9133			bne 	_AddNonZero
.9131	74 50		stz $50,x			stz 	NSStatus,x
.9133					_AddNonZero:
.9133	60		rts				rts
.9134					SubInteger:
.9134	fa		plx				plx
.9135	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9137	15 51		ora $51,x			ora 	NSStatus+1,x
.9139	0a		asl a				asl 	a 							; shift reference bit into sign bit
.913a	0a		asl a				asl 	a
.913b	10 05		bpl $9142			bpl 	_NotRef
.913d	48		pha				pha
.913e	20 8f 95	jsr $958f			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9141	68		pla				pla
.9142					_NotRef:
.9142	0a		asl a				asl 	a 							; put MSB of type into A:7
.9143	30 09		bmi $914e			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9145	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9147	15 79		ora $79,x			ora 	NSExponent+1,x
.9149	f0 06		beq $9151			beq 	_IntegerCode 				; if clear, then we have two integers
.914b	4c 13 93	jmp $9313			jmp 	FloatingPointSub 							; otherwise at least one float.
.914e					_StringData:
.914e	4c 69 9e	jmp $9e69			jmp 	NotDoneError							; at least one string - don't know both are strings.
.9151					_IntegerCode:
.9151	b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate the second value.
.9153	49 80		eor #$80			eor 	#$80
.9155	95 51		sta $51,x			sta 	NSStatus+1,x
.9157	80 bf		bra $9118			bra 	AddCode 					; and do the same code as add.
.9159					AndInteger:
.9159	fa		plx				plx
.915a	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.915c	15 51		ora $51,x			ora 	NSStatus+1,x
.915e	0a		asl a				asl 	a 							; shift reference bit into sign bit
.915f	0a		asl a				asl 	a
.9160	10 05		bpl $9167			bpl 	_NotRef
.9162	48		pha				pha
.9163	20 8f 95	jsr $958f			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9166	68		pla				pla
.9167					_NotRef:
.9167	0a		asl a				asl 	a
.9168	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.916a	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.916c	15 79		ora $79,x			ora 	NSExponent+1,x
.916e	f0 03		beq $9173			beq 	_IntegerCode 				; if clear, then we have two integers
.9170	4c 5f 9e	jmp $9e5f			jmp 	TypeError 					; anything else, type mismatch.
.9173					_IntegerCode:
.9173	b5 58		lda $58,x			lda		NSMantissa0,x
.9175	35 59		and $59,x			and 		NSMantissa0+1,x
.9177	95 58		sta $58,x			sta 	NSMantissa0,x
.9179	b5 60		lda $60,x			lda		NSMantissa1,x
.917b	35 61		and $61,x			and 		NSMantissa1+1,x
.917d	95 60		sta $60,x			sta 	NSMantissa1,x
.917f	b5 68		lda $68,x			lda		NSMantissa2,x
.9181	35 69		and $69,x			and 		NSMantissa2+1,x
.9183	95 68		sta $68,x			sta 	NSMantissa2,x
.9185	b5 70		lda $70,x			lda		NSMantissa3,x
.9187	35 71		and $71,x			and 		NSMantissa3+1,x
.9189	95 70		sta $70,x			sta 	NSMantissa3,x
.918b	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.918d	60		rts				rts
.918e					OraInteger:
.918e	fa		plx				plx
.918f	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9191	15 51		ora $51,x			ora 	NSStatus+1,x
.9193	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9194	0a		asl a				asl 	a
.9195	10 05		bpl $919c			bpl 	_NotRef
.9197	48		pha				pha
.9198	20 8f 95	jsr $958f			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.919b	68		pla				pla
.919c					_NotRef:
.919c	0a		asl a				asl 	a
.919d	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.919f	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91a1	15 79		ora $79,x			ora 	NSExponent+1,x
.91a3	f0 03		beq $91a8			beq 	_IntegerCode 				; if clear, then we have two integers
.91a5	4c 5f 9e	jmp $9e5f			jmp 	TypeError 					; anything else, type mismatch.
.91a8					_IntegerCode:
.91a8	b5 58		lda $58,x			lda		NSMantissa0,x
.91aa	15 59		ora $59,x			ora 		NSMantissa0+1,x
.91ac	95 58		sta $58,x			sta 	NSMantissa0,x
.91ae	b5 60		lda $60,x			lda		NSMantissa1,x
.91b0	15 61		ora $61,x			ora 		NSMantissa1+1,x
.91b2	95 60		sta $60,x			sta 	NSMantissa1,x
.91b4	b5 68		lda $68,x			lda		NSMantissa2,x
.91b6	15 69		ora $69,x			ora 		NSMantissa2+1,x
.91b8	95 68		sta $68,x			sta 	NSMantissa2,x
.91ba	b5 70		lda $70,x			lda		NSMantissa3,x
.91bc	15 71		ora $71,x			ora 		NSMantissa3+1,x
.91be	95 70		sta $70,x			sta 	NSMantissa3,x
.91c0	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.91c2	60		rts				rts
.91c3					EorInteger:
.91c3	fa		plx				plx
.91c4	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.91c6	15 51		ora $51,x			ora 	NSStatus+1,x
.91c8	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91c9	0a		asl a				asl 	a
.91ca	10 05		bpl $91d1			bpl 	_NotRef
.91cc	48		pha				pha
.91cd	20 8f 95	jsr $958f			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91d0	68		pla				pla
.91d1					_NotRef:
.91d1	0a		asl a				asl 	a
.91d2	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.91d4	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91d6	15 79		ora $79,x			ora 	NSExponent+1,x
.91d8	f0 03		beq $91dd			beq 	_IntegerCode 				; if clear, then we have two integers
.91da	4c 5f 9e	jmp $9e5f			jmp 	TypeError 					; anything else, type mismatch.
.91dd					_IntegerCode:
.91dd	b5 58		lda $58,x			lda		NSMantissa0,x
.91df	55 59		eor $59,x			eor 		NSMantissa0+1,x
.91e1	95 58		sta $58,x			sta 	NSMantissa0,x
.91e3	b5 60		lda $60,x			lda		NSMantissa1,x
.91e5	55 61		eor $61,x			eor 		NSMantissa1+1,x
.91e7	95 60		sta $60,x			sta 	NSMantissa1,x
.91e9	b5 68		lda $68,x			lda		NSMantissa2,x
.91eb	55 69		eor $69,x			eor 		NSMantissa2+1,x
.91ed	95 68		sta $68,x			sta 	NSMantissa2,x
.91ef	b5 70		lda $70,x			lda		NSMantissa3,x
.91f1	55 71		eor $71,x			eor 		NSMantissa3+1,x
.91f3	95 70		sta $70,x			sta 	NSMantissa3,x
.91f5	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.91f7	60		rts				rts
.91f8					WordIndirect:
.91f8	fa		plx				plx
.91f9	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.91fb	15 51		ora $51,x			ora 	NSStatus+1,x
.91fd	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91fe	0a		asl a				asl 	a
.91ff	10 05		bpl $9206			bpl 	_NotRef
.9201	48		pha				pha
.9202	20 8f 95	jsr $958f			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9205	68		pla				pla
.9206					_NotRef:
.9206	0a		asl a				asl 	a
.9207	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9209	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.920b	15 79		ora $79,x			ora 	NSExponent+1,x
.920d	f0 03		beq $9212			beq 	_IntegerCode 				; if clear, then we have two integers
.920f	4c 5f 9e	jmp $9e5f			jmp 	TypeError 					; anything else, type mismatch.
.9212					_IntegerCode:
.9212	20 18 91	jsr $9118			jsr 	AddCode 					; add the two values
.9215	a9 22		lda #$22			lda 	#NSBIsReference+2 			; make a 2 byte reference
.9217	95 50		sta $50,x			sta 	NSStatus,x
.9219	60		rts				rts
.921a					ByteIndirect:
.921a	fa		plx				plx
.921b	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.921d	15 51		ora $51,x			ora 	NSStatus+1,x
.921f	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9220	0a		asl a				asl 	a
.9221	10 05		bpl $9228			bpl 	_NotRef
.9223	48		pha				pha
.9224	20 8f 95	jsr $958f			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9227	68		pla				pla
.9228					_NotRef:
.9228	0a		asl a				asl 	a
.9229	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.922b	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.922d	15 79		ora $79,x			ora 	NSExponent+1,x
.922f	f0 03		beq $9234			beq 	_IntegerCode 				; if clear, then we have two integers
.9231	4c 5f 9e	jmp $9e5f			jmp 	TypeError 					; anything else, type mismatch.
.9234					_IntegerCode:
.9234	20 18 91	jsr $9118			jsr 	AddCode 					; add the two values
.9237	a9 21		lda #$21			lda 	#NSBIsReference+1 			; make a 1 byte reference
.9239	95 50		sta $50,x			sta 	NSStatus,x
.923b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/tostring.asm

.923c					LCLConvertInt16:
.923c	85 58		sta $58				sta 	NSMantissa0 				; set up as 32 bit conversion
.923e	86 60		stx $60				stx 	NSMantissa1
.9240	64 68		stz $68				stz 	NSMantissa2
.9242	64 70		stz $70				stz 	NSMantissa3
.9244	64 50		stz $50				stz 	NSStatus 					; positive integer
.9246	a2 00		ldx #$00			ldx 	#0 							; stack level
.9248	a9 0a		lda #$0a			lda 	#10 						; base
.924a	80 00		bra $924c			bra 	ConvertInt32
.924c					ConvertInt32:
.924c	5a		phy				phy
.924d	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.924f	24 50		bit $50				bit 	NSStatus 					; output a - if not negative.
.9251	10 08		bpl $925b			bpl 	_CI32NotNeg
.9253	48		pha				pha
.9254	a9 2d		lda #$2d			lda 	#'-'
.9256	99 7b 05	sta $057b,y			sta 	NumberBuffer,y
.9259	c8		iny				iny
.925a	68		pla				pla
.925b					_CI32NotNeg:
.925b	20 69 92	jsr $9269			jsr 	_CI32DivideConvert 			; recursive conversion
.925e	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.9260	99 7b 05	sta $057b,y			sta 	NumberBuffer,y
.9263	7a		ply				ply
.9264	a2 05		ldx #$05			ldx 	#NumberBuffer >> 8
.9266	a9 7b		lda #$7b			lda 	#NumberBuffer & $FF
.9268	60		rts				rts
.9269					_CI32DivideConvert:
.9269	e8		inx				inx 								; write to next slot up
.926a	20 df 9c	jsr $9cdf			jsr 	NSMSetByte
.926d	ca		dex				dex
.926e	20 97 8f	jsr $8f97			jsr 	Int32Divide 				; divide
.9271	b5 58		lda $58,x			lda 	NSMantissa0,x 				; save remainder
.9273	48		pha				pha
.9274	20 54 8f	jsr $8f54			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.9277	20 ff 9c	jsr $9cff			jsr 	NSMIsZero 					; is it zero ?
.927a	f0 05		beq $9281			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.927c	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.927e	20 69 92	jsr $9269			jsr 	_CI32DivideConvert 			; and recusrively call.
.9281					_CI32NoRecurse:
.9281	68		pla				pla 								; remainder
.9282	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.9284	90 02		bcc $9288			bcc 	_CI32NotHex
.9286	69 26		adc #$26			adc 	#6+32
.9288					_CI32NotHex:
.9288	69 30		adc #$30			adc 	#48
.928a	99 7b 05	sta $057b,y			sta 	NumberBuffer,y 				; write out and exit
.928d	c8		iny				iny
.928e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/expression.asm


;******  Processing file: ./common/expressions/../generated/precedence.dat

.928f					PrecedenceLevel:
>928f	04					.byte	 4	; $00 <<
>9290	02					.byte	 2	; $01 <=
>9291	02					.byte	 2	; $02 <>
>9292	00					.byte	 0	; $03 !!3
>9293	00					.byte	 0	; $04 ><
>9294	02					.byte	 2	; $05 >=
>9295	04					.byte	 4	; $06 >>
>9296	00					.byte	 0	; $07 !!7
>9297	00					.byte	 0	; $08 !!8
>9298	00					.byte	 0	; $09 !!9
>9299	00					.byte	 0	; $0a !!10
>929a	00					.byte	 0	; $0b !!11
>929b	00					.byte	 0	; $0c !!12
>929c	00					.byte	 0	; $0d !!13
>929d	00					.byte	 0	; $0e !!14
>929e	00					.byte	 0	; $0f !!15
>929f	00					.byte	 0	; $10 @
>92a0	00					.byte	 0	; $11 !!17
>92a1	00					.byte	 0	; $12 !!18
>92a2	00					.byte	 0	; $13 [
>92a3	04					.byte	 4	; $14 \
>92a4	00					.byte	 0	; $15 ]
>92a5	01					.byte	 1	; $16 ^
>92a6	00					.byte	 0	; $17 _
>92a7	00					.byte	 0	; $18 `
>92a8	00					.byte	 0	; $19 !!25
>92a9	00					.byte	 0	; $1a !!26
>92aa	00					.byte	 0	; $1b {
>92ab	01					.byte	 1	; $1c |
>92ac	00					.byte	 0	; $1d }
>92ad	00					.byte	 0	; $1e ~
>92ae	00					.byte	 0	; $1f [7m<7F>[m
>92af	00					.byte	 0	; $20
>92b0	05					.byte	 5	; $21 !
>92b1	00					.byte	 0	; $22 "
>92b2	00					.byte	 0	; $23 #
>92b3	05					.byte	 5	; $24 $
>92b4	04					.byte	 4	; $25 %
>92b5	01					.byte	 1	; $26 &
>92b6	00					.byte	 0	; $27 '
>92b7	00					.byte	 0	; $28 (
>92b8	00					.byte	 0	; $29 )
>92b9	04					.byte	 4	; $2a *
>92ba	03					.byte	 3	; $2b +
>92bb	00					.byte	 0	; $2c ,
>92bc	03					.byte	 3	; $2d -
>92bd	00					.byte	 0	; $2e .
>92be	04					.byte	 4	; $2f /
>92bf	00					.byte	 0	; $30 0
>92c0	00					.byte	 0	; $31 1
>92c1	00					.byte	 0	; $32 2
>92c2	00					.byte	 0	; $33 3
>92c3	00					.byte	 0	; $34 4
>92c4	00					.byte	 0	; $35 5
>92c5	00					.byte	 0	; $36 6
>92c6	00					.byte	 0	; $37 7
>92c7	00					.byte	 0	; $38 8
>92c8	00					.byte	 0	; $39 9
>92c9	00					.byte	 0	; $3a :
>92ca	00					.byte	 0	; $3b ;
>92cb	02					.byte	 2	; $3c <
>92cc	02					.byte	 2	; $3d =
>92cd	02					.byte	 2	; $3e >
>92ce	05					.byte	 5	; $3f ?

;******  Return to file: ./common/expressions/expression.asm

.92cf					EvaluateExpressionAt0:
.92cf	a2 00		ldx #$00			ldx 	#0 							; bottom stack level
.92d1					EvaluateExpression:
.92d1	a9 00		lda #$00			lda 	#0 							; lowest precedence level
.92d3					EvaluateExpressionAtPrecedence:
.92d3	48		pha				pha 								; save precedence level
.92d4	20 1b 97	jsr $971b			jsr 	EvaluateTerm 				; evaluate term into level X.
.92d7	68		pla				pla 								; restore precedence level.
.92d8					_EXPRLoop:
.92d8	85 36		sta $36				sta 	zTemp0 						; save current precedence level.
.92da	b1 30		lda ($30),y			lda 	(codePtr),y
.92dc	c9 40		cmp #$40			cmp		#$40 						; if >= $40 cannot be an operator
.92de	b0 25		bcs $9305			bcs 	_EXPRExit
.92e0	da		phx				phx 								; read the operator precedence
.92e1	aa		tax				tax
.92e2	bd 8f 92	lda $928f,x			lda 	PrecedenceLevel,x
.92e5	fa		plx				plx
.92e6	c9 00		cmp #$00			cmp 	#0							; if zero exit (not an operator)
.92e8	f0 1b		beq $9305			beq 	_EXPRExit
.92ea	85 37		sta $37				sta 	zTemp0+1 					; save operator precedence level.
.92ec	a5 36		lda $36				lda 	zTemp0 						; compare current precedence vs. operator precedence
.92ee	c5 37		cmp $37				cmp 	zTemp0+1
.92f0	b0 13		bcs $9305			bcs		_EXPRExit 					; if current >= operator exit
.92f2	48		pha				pha 								; save current precedence.
.92f3	b1 30		lda ($30),y			lda 	(codePtr),y
.92f5	c8		iny				iny
.92f6	48		pha				pha
.92f7	a5 37		lda $37				lda 	zTemp0+1 					; get operator precedence level
.92f9	e8		inx				inx 								; work out the right hand side.
.92fa	20 d3 92	jsr $92d3			jsr 	EvaluateExpressionAtPrecedence
.92fd	ca		dex				dex
.92fe	68		pla				pla 								; get operator, call the code.
.92ff	20 08 93	jsr $9308			jsr 	_EXPRCaller
.9302	68		pla				pla 								; restore precedence level
.9303	80 d3		bra $92d8			bra 	_EXPRLoop 					; and go round.
.9305					_EXPRExit:
.9305	a5 36		lda $36				lda 	zTemp0 						; A = current precedence level.
.9307	60		rts				rts
.9308					_EXPRCaller:
.9308	da		phx				phx 								; save on stack, first thing is to restore it
.9309	0a		asl a				asl 	a 							; double so can use vectors into X
.930a	aa		tax				tax
.930b	7c f4 8a	jmp ($8af4,x)			jmp 	(VectorSetPunc,x) 			; and go to the code.

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/addsub.asm

.930e					FloatingPointAdd:
.930e	20 84 94	jsr $9484			jsr 	FloatPrepare 				; prepare for floats
.9311	80 09		bra $931c			bra 	FloatAdd
.9313					FloatingPointSub:
.9313	20 84 94	jsr $9484			jsr 	FloatPrepare 				; prepare for floats
.9316					FloatSubtract:
.9316	b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate FPB
.9318	49 80		eor #$80			eor 	#$80
.931a	95 51		sta $51,x			sta 	NSStatus+1,x				; and fall through.
.931c					FloatAdd:
.931c	48		pha				pha
.931d	5a		phy				phy
.931e	20 93 94	jsr $9493			jsr 	NSNormalise 				; normalise S[X]
.9321	f0 51		beq $9374			beq 	_FAReturn1
.9323	e8		inx				inx 								; normalise S[X+1]
.9324	20 93 94	jsr $9493			jsr 	NSNormalise
.9327	ca		dex				dex
.9328	c9 00		cmp #$00			cmp 	#0
.932a	f0 60		beq $938c			beq 	_FAExit 					; if so, just return A
.932c	b5 78		lda $78,x			lda 	NSExponent,x 				; are the exponents the same ?
.932e	d5 79		cmp $79,x			cmp 	NSExponent+1,x
.9330	f0 18		beq $934a			beq 	_FAExponentsEqual
.9332	b5 78		lda $78,x			lda 	NSExponent,x 				; work out the larger exponent
.9334	a8		tay				tay
.9335	38		sec				sec 								; do a signed comparison of the exponents.
.9336	f5 79		sbc $79,x			sbc 	NSExponent+1,x
.9338	50 02		bvc $933c			bvc 	_FANoSignedChange
.933a	49 80		eor #$80			eor 	#$80
.933c					_FANoSignedChange:
.933c	29 80		and #$80			and 	#$80
.933e	10 02		bpl $9342			bpl 	_FAHaveMax
.9340	b4 79		ldy $79,x			ldy 	NSExponent+1,x
.9342					_FAHaveMax:
.9342	20 8f 93	jsr $938f			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.9345	e8		inx				inx
.9346	20 8f 93	jsr $938f			jsr 	_FAShiftToExponent
.9349	ca		dex				dex
.934a					_FAExponentsEqual:
.934a	b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs the same
.934c	55 51		eor $51,x			eor 	NSStatus+1,x
.934e	30 0e		bmi $935e			bmi 	_FADifferentSigns
.9350	20 c7 90	jsr $90c7			jsr 	AddTopTwoStack 				; do the add of the mantissae
.9353	b5 70		lda $70,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.9355	10 35		bpl $938c			bpl 	_FAExit 					; if no, we are done.
.9357	20 f6 9c	jsr $9cf6			jsr 	NSMShiftRight 				; shift A right, renormalising it.
.935a	f6 78		inc $78,x			inc 	NSExponent,x 				; bump the exponent and exit
.935c	80 2e		bra $938c			bra 	_FAExit
.935e					_FADifferentSigns:
.935e	20 e1 90	jsr $90e1			jsr 	SubTopTwoStack 				; subtract mantissa B from A
.9361	b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the result negative ?
.9363	10 06		bpl $936b			bpl 	_FACheckZero 				; if no, check for -0
.9365	20 9f 9c	jsr $9c9f			jsr 	NSMNegate 					; netate result
.9368	20 a6 9c	jsr $9ca6			jsr 	NSMNegateMantissa 			; negate (2'c) the mantissa
.936b					_FACheckZero:
.936b	20 ff 9c	jsr $9cff			jsr 	NSMIsZero	 				; check for -0
.936e	d0 1c		bne $938c			bne 	_FAExit
.9370	74 50		stz $50,x			stz 	NSStatus,x
.9372	80 18		bra $938c			bra 	_FAExit
.9374					_FAReturn1:
.9374	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9376	95 58		sta $58,x			sta 	NSMantissa0,x
.9378	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.937a	95 60		sta $60,x			sta 	NSMantissa1,x
.937c	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.937e	95 68		sta $68,x			sta 	NSMantissa2,x
.9380	b5 71		lda $71,x			lda 	NSMantissa3+1,x
.9382	95 70		sta $70,x			sta 	NSMantissa3,x
.9384	b5 79		lda $79,x			lda 	NSExponent+1,x
.9386	95 78		sta $78,x			sta 	NSExponent,x
.9388	b5 51		lda $51,x			lda 	NSStatus+1,x
.938a	95 50		sta $50,x			sta 	NSStatus,x
.938c					_FAExit:
.938c	7a		ply				ply
.938d	68		pla				pla
.938e	60		rts				rts
.938f					_FAShiftToExponent:
.938f					_FAShiftToExponent2:
.938f	98		tya				tya 								; compare Y to exponent
.9390	d5 78		cmp $78,x			cmp 	NSExponent,x 				; reached the exponent required ?
.9392	f0 07		beq $939b			beq 	_FASEExit 					; exit if so.
.9394	20 f6 9c	jsr $9cf6			jsr 	NSMShiftRight	 			; shift the mantissa right
.9397	f6 78		inc $78,x			inc 	NSExponent,x 				; increment exponent
.9399	80 f4		bra $938f			bra 	_FAShiftToExponent2
.939b					_FASEExit:
.939b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/compare.asm

.939c					CompareFloat:
.939c	20 16 93	jsr $9316			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.939f	b5 60		lda $60,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.93a1	29 f8		and #$f8			and 	#$F8
.93a3	15 68		ora $68,x			ora 	NSMantissa2,x
.93a5	15 70		ora $70,x			ora 	NSMantissa3,x
.93a7	f0 08		beq $93b1			beq 	_FCExit 					; zero, so approximately identical
.93a9	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.93ab	34 50		bit $50,x			bit 	NSStatus,x
.93ad	10 02		bpl $93b1			bpl 	_FCExit
.93af					_FCNegative:
.93af	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.93b1					_FCExit:
.93b1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/divide.asm

.93b2					FDivideCommand:
.93b2	fa		plx				plx	 								; restore stack position
.93b3	20 84 94	jsr $9484			jsr 	FloatPrepare 				; prepare for floats
.93b6					FloatDivide:
.93b6	48		pha				pha
.93b7	e8		inx				inx
.93b8	20 93 94	jsr $9493			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.93bb	ca		dex				dex
.93bc	c9 00		cmp #$00			cmp 	#0
.93be	f0 1d		beq $93dd			beq 	_FDZero
.93c0	20 93 94	jsr $9493			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.93c3	f0 16		beq $93db			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.93c5	20 b8 8f	jsr $8fb8			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.93c8	20 54 8f	jsr $8f54			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.93cb	20 93 94	jsr $9493			jsr		NSNormalise 				; renormalise
.93ce	20 48 90	jsr $9048			jsr 	CalculateSign 				; calculate result sign
.93d1	b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent
.93d3	38		sec				sec
.93d4	f5 79		sbc $79,x			sbc 	NSExponent+1,x
.93d6	38		sec				sec
.93d7	e9 1e		sbc #$1e			sbc 	#30
.93d9	95 78		sta $78,x			sta 	NSExponent,x
.93db					_FDExit:
.93db	68		pla				pla
.93dc	60		rts				rts
.93dd					_FDZero:
.93dd	a9 03		lda #$03		lda	#3
.93df	4c cd 8d	jmp $8dcd		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/fractional.asm

.93e2					FloatFractionalPart:
.93e2	5a		phy				phy
.93e3	b5 50		lda $50,x			lda 	NSStatus,x 					; take absolute value
.93e5	29 7f		and #$7f			and 	#$7F
.93e7	95 50		sta $50,x			sta 	NSStatus,x
.93e9	20 93 94	jsr $9493			jsr 	NSNormalise
.93ec	b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.93ee	38		sec				sec
.93ef	e9 e0		sbc #$e0			sbc 	#$E0
.93f1	90 29		bcc $941c			bcc 	_FFPExit 					; already fractional
.93f3	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.93f5	b0 22		bcs $9419			bcs 	_FFPZero
.93f7	a8		tay				tay 								; put count to do in Y
.93f8	b5 70		lda $70,x			lda 	NSMantissa3,x 				; do each in turn.
.93fa	20 1e 94	jsr $941e			jsr 	_FFPPartial
.93fd	95 70		sta $70,x			sta 	NSMantissa3,x
.93ff	b5 68		lda $68,x			lda 	NSMantissa2,x
.9401	20 1e 94	jsr $941e			jsr 	_FFPPartial
.9404	95 68		sta $68,x			sta 	NSMantissa2,x
.9406	b5 60		lda $60,x			lda 	NSMantissa1,x
.9408	20 1e 94	jsr $941e			jsr 	_FFPPartial
.940b	95 60		sta $60,x			sta 	NSMantissa1,x
.940d	b5 58		lda $58,x			lda 	NSMantissa0,x
.940f	20 1e 94	jsr $941e			jsr 	_FFPPartial
.9412	95 58		sta $58,x			sta 	NSMantissa0,x
.9414	20 ff 9c	jsr $9cff			jsr 	NSMIsZero 					; zeroed check.
.9417	d0 03		bne $941c			bne 	_FFPExit
.9419					_FFPZero:
.9419	20 dd 9c	jsr $9cdd			jsr 	NSMSetZero
.941c					_FFPExit:
.941c	7a		ply				ply
.941d	60		rts				rts
.941e					_FFPPartial:
.941e	c0 00		cpy #$00			cpy 	#0 							; no more to do
.9420	f0 17		beq $9439			beq 	_FFFPPExit
.9422	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.9424	b0 0c		bcs $9432			bcs 	_FFFPPWholeByte
.9426	5a		phy				phy
.9427					_FFFPPLeft:
.9427	0a		asl a				asl 	a
.9428	88		dey				dey
.9429	d0 fc		bne $9427			bne 	_FFFPPLeft
.942b	7a		ply				ply
.942c					_FFFPPRight:
.942c	4a		lsr a				lsr 	a
.942d	88		dey				dey
.942e	d0 fc		bne $942c			bne 	_FFFPPRight
.9430	80 07		bra $9439			bra 	_FFFPPExit
.9432					_FFFPPWholeByte:
.9432	98		tya				tya 								; subtract 8 from count
.9433	38		sec				sec
.9434	e9 08		sbc #$08			sbc 	#8
.9436	a8		tay				tay
.9437	a9 00		lda #$00			lda 	#0 							; and clear all
.9439					_FFFPPExit:
.9439	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/integer.asm

.943a					FloatIntegerPart:
.943a	48		pha				pha
.943b	b5 78		lda $78,x			lda 	NSExponent,x 				; is it integer already ?
.943d	f0 1d		beq $945c			beq 	_FIPExit 					; if so do nothing
.943f	20 ff 9c	jsr $9cff			jsr 	NSMIsZero 					; is it zero ?
.9442	f0 15		beq $9459			beq 	_FIPZero 					; if so return zero.
.9444	20 93 94	jsr $9493			jsr 	NSNormalise 				; normalise
.9447	f0 10		beq $9459			beq 	_FIPZero 					; normalised to zero, exit zero
.9449					_FIPShift:
.9449	b5 78		lda $78,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.944b	10 07		bpl $9454			bpl 	_FIPCheckZero
.944d	20 f6 9c	jsr $9cf6			jsr 	NSMShiftRight 				; shift mantissa right
.9450	f6 78		inc $78,x			inc 	NSExponent,x 				; bump exponent
.9452	80 f5		bra $9449			bra 	_FIPShift
.9454					_FIPCheckZero:
.9454	20 ff 9c	jsr $9cff			jsr 	NSMIsZero 					; avoid -0 problem
.9457	d0 03		bne $945c			bne 	_FIPExit 					; set to zero if mantissa zero.
.9459					_FIPZero:
.9459	20 dd 9c	jsr $9cdd			jsr 	NSMSetZero
.945c					_FIPExit:
.945c	68		pla				pla
.945d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/multiply.asm

.945e					FloatingPointMultiply:
.945e	20 84 94	jsr $9484			jsr 	FloatPrepare 				; prepare for floats
.9461					FloatMultiply:
.9461	48		pha				pha
.9462	20 93 94	jsr $9493			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.9465	f0 18		beq $947f			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.9467	e8		inx				inx
.9468	20 93 94	jsr $9493			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.946b	ca		dex				dex
.946c	c9 00		cmp #$00			cmp 	#0
.946e	f0 0c		beq $947c			beq 	_FDSetZero
.9470	20 0a 90	jsr $900a			jsr 	MultiplyShort 				; calculate the result.
.9473	75 78		adc $78,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.9475	18		clc				clc
.9476	75 79		adc $79,x			adc 	NSExponent+1,x
.9478	95 78		sta $78,x			sta 	NSExponent,x
.947a	80 03		bra $947f			bra 	_FDExit
.947c					_FDSetZero:
.947c	20 dd 9c	jsr $9cdd			jsr 	NSMSetZero 					; return 0
.947f					_FDExit:
.947f	20 93 94	jsr $9493			jsr 	NSNormalise 				; normalise the result
.9482	68		pla				pla
.9483	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/utility.asm

.9484					FloatPrepare:
.9484	20 8f 95	jsr $958f			jsr 	DereferenceTopTwo 			; dereference the top two values
.9487	b5 50		lda $50,x			lda 	NSStatus,x 					; check ints/floats
.9489	15 51		ora $51,x			ora 	NSStatus+1,x
.948b	29 10		and #$10			and 	#NSBIsString
.948d	d0 01		bne $9490			bne 	_FDType
.948f	60		rts				rts
.9490					_FDType:
.9490	4c 5f 9e	jmp $9e5f			jmp 	TypeError
.9493					NSNormalise:
.9493	b5 50		lda $50,x			lda 	NSStatus,x 					; make float, keep sign
.9495	29 80		and #$80			and 	#$80
.9497	09 08		ora #$08			ora 	#NSTFloat
.9499	95 50		sta $50,x			sta 	NSStatus,x
.949b	20 ff 9c	jsr $9cff			jsr 	NSMIsZero 					; if zero exit
.949e	d0 07		bne $94a7			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.94a0	16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.94a2	76 50		ror $50,x			ror 	NSStatus,x 					; (no -0)
.94a4	a9 00		lda #$00			lda 	#0 							; set Z flag
.94a6	60		rts				rts
.94a7					_NSNormaliseOptimise:
.94a7	b5 70		lda $70,x			lda 	NSMantissa3,x 				; upper byte zero ?
.94a9	d0 19		bne $94c4			bne 	_NSNormaliseLoop
.94ab	b5 68		lda $68,x			lda 	NSMantissa2,x 				; byte normalise
.94ad	30 15		bmi $94c4			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.94af	95 70		sta $70,x			sta 	NSMantissa3,x
.94b1	b5 60		lda $60,x			lda 	NSMantissa1,x
.94b3	95 68		sta $68,x			sta 	NSMantissa2,x
.94b5	b5 58		lda $58,x			lda 	NSMantissa0,x
.94b7	95 60		sta $60,x			sta 	NSMantissa1,x
.94b9	74 58		stz $58,x			stz 	NSMantissa0,x
.94bb	b5 78		lda $78,x			lda 	NSExponent,x
.94bd	38		sec				sec
.94be	e9 08		sbc #$08			sbc 	#8
.94c0	95 78		sta $78,x			sta 	NSExponent,x
.94c2	80 e3		bra $94a7			bra 	_NSNormaliseOptimise
.94c4					_NSNormaliseLoop:
.94c4	34 70		bit $70,x			bit 	NSMantissa3,x 				; bit 30 set ?
.94c6	70 07		bvs $94cf			bvs 	_NSNExit 					; exit if so with Z flag clear
.94c8	20 ec 9c	jsr $9cec			jsr 	NSMShiftLeft 				; shift mantissa left
.94cb	d6 78		dec $78,x			dec 	NSExponent,x 				; adjust exponent
.94cd	80 f5		bra $94c4			bra 	_NSNormaliseLoop
.94cf					_NSNExit:
.94cf	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.94d1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignnumber.asm

.94d2					AssignNumber:
.94d2	5a		phy				phy
.94d3	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy mantissa0/1 to zTemp0
.94d5	85 36		sta $36				sta 	zTemp0
.94d7	b5 60		lda $60,x			lda 	NSMantissa1,x
.94d9	85 37		sta $37				sta 	zTemp0+1
.94db	b5 50		lda $50,x			lda 	NSStatus,x 					; clear reference bits
.94dd	29 df		and #$df			and 	#(NSBIsReference ^ $FF)
.94df	95 50		sta $50,x			sta 	NSStatus,x
.94e1	29 18		and #$18			and 	#NSBTypeMask				; assigning to a float ?
.94e3	c9 08		cmp #$08			cmp 	#NSTFloat
.94e5	f0 24		beq $950b			beq 	_ANFloat
.94e7	b5 79		lda $79,x			lda		NSExponent+1,x 				; is it a float
.94e9	f0 03		beq $94ee			beq		_ANNotFloat
.94eb	4c 5a 9e	jmp $9e5a			jmp 	RangeError
.94ee					_ANNotFloat:
.94ee	b5 50		lda $50,x			lda 	NSStatus,x 					; check if byte/word reference.
.94f0	29 03		and #$03			and 	#3
.94f2	d0 05		bne $94f9			bne 	_ANByteWord
.94f4	20 16 95	jsr $9516			jsr 	_ANCopy4PackSign 			; copy all 4 bytes and sign
.94f7	80 1b		bra $9514			bra 	_ANExit
.94f9					_ANByteWord:
.94f9	48		pha				pha 								; save count
.94fa	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; do byte
.94fc	92 36		sta ($36)			sta 	(zTemp0)
.94fe	68		pla				pla
.94ff	c9 01		cmp #$01			cmp	 	#1
.9501	f0 11		beq $9514			beq 	_ANExit
.9503	b5 61		lda $61,x			lda 	NSMantissa1+1,x 			; do word
.9505	a0 01		ldy #$01			ldy 	#1
.9507	91 36		sta ($36),y			sta 	(zTemp0),y
.9509	80 09		bra $9514			bra 	_ANExit
.950b					_ANFloat:
.950b	20 16 95	jsr $9516			jsr 	_ANCopy4PackSign 			; write all 4 bytes and packed sign
.950e	b5 79		lda $79,x			lda 	NSExponent+1,x 				; copy exponent to slot 4
.9510	a0 04		ldy #$04			ldy 	#4
.9512	91 36		sta ($36),y			sta 	(zTemp0),y
.9514					_ANExit:
.9514	7a		ply				ply
.9515	60		rts				rts
.9516					_ANCopy4PackSign:
.9516	a0 03		ldy #$03			ldy 	#3
.9518	b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign bit into status
.951a	29 80		and #$80			and 	#$80 						; put into high bit of mantissa 3
.951c	15 71		ora $71,x			ora 	NSMantissa3+1,x
.951e	91 36		sta ($36),y			sta 	(zTemp0),y
.9520	88		dey				dey
.9521	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.9523	91 36		sta ($36),y			sta 	(zTemp0),y
.9525	88		dey				dey
.9526	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9528	91 36		sta ($36),y			sta 	(zTemp0),y
.952a	88		dey				dey
.952b	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.952d	91 36		sta ($36),y			sta 	(zTemp0),y
.952f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignstring.asm

.9530					AssignString:
.9530	5a		phy				phy
.9531	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9533	85 38		sta $38				sta 	zTemp1
.9535	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9537	85 39		sta $39				sta 	zTemp1+1
.9539	b5 58		lda $58,x			lda 	NSMantissa0,x
.953b	85 36		sta $36				sta 	zTemp0
.953d	b5 60		lda $60,x			lda 	NSMantissa1,x
.953f	85 37		sta $37				sta 	zTemp0+1
.9541	a0 01		ldy #$01			ldy 	#1 							; the high byte of the target address
.9543	b1 36		lda ($36),y			lda 	(zTemp0),y
.9545	f0 23		beq $956a			beq 	_ASNewStringRequired 		; if zero, a new string is required.
.9547	38		sec				sec 								; put Address-2 in zsTemp - this is the size/status/string record
.9548	b2 36		lda ($36)			lda 	(zTemp0) 					; of concreted strings
.954a	e9 02		sbc #$02			sbc 	#2
.954c	85 3c		sta $3c				sta 	zsTemp
.954e	a0 01		ldy #$01			ldy 	#1
.9550	b1 36		lda ($36),y			lda 	(zTemp0),y
.9552	e9 00		sbc #$00			sbc 	#0
.9554	85 3d		sta $3d				sta 	zsTemp+1
.9556	a0 ff		ldy #$ff			ldy 	#$FF 						; get length of new string
.9558					_ASGetLength:
.9558	c8		iny				iny
.9559	b1 38		lda ($38),y			lda 	(zTemp1),y
.955b	d0 fb		bne $9558			bne 	_ASGetLength
.955d	98		tya				tya 								; is this length <= current length
.955e	d2 3c		cmp ($3c)			cmp 	(zsTemp)
.9560	90 1e		bcc $9580			bcc 	_ASCopyString
.9562	f0 1c		beq $9580			beq 	_ASCopyString
.9564	a9 80		lda #$80			lda 	#$80 						; mark as unused.
.9566	a0 01		ldy #$01			ldy 	#1
.9568	91 3c		sta ($3c),y			sta 	(zsTemp),y
.956a					_ASNewStringRequired:
.956a	e8		inx				inx 								; concrete the new string.
.956b	20 8c a5	jsr $a58c			jsr 	StringConcrete				; (breaks zTemp1/2, not zTemp0 and zsTemp)
.956e	ca		dex				dex
.956f	18		clc				clc
.9570	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy that new address to the reference.
.9572	69 02		adc #$02			adc 	#2 							; add two to point at the data.
.9574	92 36		sta ($36)			sta 	(zTemp0)
.9576	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9578	69 00		adc #$00			adc 	#0
.957a	a0 01		ldy #$01			ldy 	#1
.957c	91 36		sta ($36),y			sta 	(zTemp0),y
.957e	80 0d		bra $958d			bra 	_ASExit
.9580					_ASCopyString:
.9580	a0 00		ldy #$00			ldy 	#0
.9582					_ASCopyLoop:
.9582	b1 38		lda ($38),y			lda 	(zTemp1),y
.9584	c8		iny				iny
.9585	c8		iny				iny
.9586	91 3c		sta ($3c),y			sta 	(zsTemp),y
.9588	88		dey				dey
.9589	c9 00		cmp #$00			cmp 	#0
.958b	d0 f5		bne $9582			bne 	_ASCopyLoop
.958d					_ASExit:
.958d	7a		ply				ply
.958e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/dereference.asm

.958f					DereferenceTopTwo:
.958f	e8		inx				inx
.9590	20 94 95	jsr $9594			jsr 	Dereference 				; deref x+1
.9593	ca		dex				dex  								; falls through to deref x
.9594					Dereference:
.9594	b5 50		lda $50,x			lda 	NSStatus,x 					; get the status byte
.9596	29 20		and #$20			and 	#NSBIsReference 			; shift sign bit to carry, reference to bit 7
.9598	f0 48		beq $95e2			beq 	_DRFExit 					; not a reference
.959a	5a		phy				phy
.959b	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address to dereference into zTemp0
.959d	85 36		sta $36				sta 	zTemp0
.959f	b5 60		lda $60,x			lda 	NSMantissa1,x
.95a1	85 37		sta $37				sta 	zTemp0+1
.95a3	74 60		stz $60,x			stz 	NSMantissa1,x 				; clear second byte.
.95a5	b2 36		lda ($36)			lda 	(zTemp0) 					; do the first byte
.95a7	95 58		sta $58,x			sta 	NSMantissa0,x
.95a9	b5 50		lda $50,x			lda 	NSStatus,x 					; get status byte.
.95ab	29 18		and #$18			and 	#NSBTypeMask 				; what type is it ?
.95ad	c9 10		cmp #$10			cmp 	#NSTString 					; if string, dereference two
.95af	f0 0e		beq $95bf			beq 	_DRFDereferenceTwo
.95b1	c9 08		cmp #$08			cmp 	#NSTFloat 					; if float, do full dereference.
.95b3	f0 2f		beq $95e4			beq 	_DRFFull
.95b5	b5 50		lda $50,x			lda 	NSStatus,x 					; must be integer - how many bytes ?
.95b7	29 03		and #$03			and 	#3
.95b9	f0 29		beq $95e4			beq 	_DRFFull 					; the whole word
.95bb	c9 01		cmp #$01			cmp 	#1 							; is it 10 (e.g. 2 bytes)
.95bd	f0 06		beq $95c5			beq		_DRFClear23 				; no, one byte, clear 2 & 3 and exit
.95bf					_DRFDereferenceTwo:
.95bf	a0 01		ldy #$01			ldy 	#1
.95c1	b1 36		lda ($36),y			lda 	(zTemp0),y
.95c3	95 60		sta $60,x			sta 	NSMantissa1,x
.95c5					_DRFClear23:
.95c5	74 68		stz $68,x			stz 	NSMantissa2,x 				; clear upper bytes, only read 1 or 2 bytes
.95c7	74 70		stz $70,x			stz 	NSMantissa3,x
.95c9	b5 50		lda $50,x			lda 	NSStatus,x 					; make it a value of that type.
.95cb	29 18		and #$18			and 	#NSBTypeMask
.95cd	95 50		sta $50,x			sta 	NSStatus,x
.95cf	c9 10		cmp #$10			cmp 	#NSTString  				; is it a string
.95d1	d0 0e		bne $95e1			bne 	_DRFNotString
.95d3	b5 58		lda $58,x			lda 	NSMantissa0,x 				; check address is zero
.95d5	15 60		ora $60,x			ora 	NSMantissa1,x
.95d7	d0 08		bne $95e1			bne 	_DRFNotString
.95d9	a9 e3		lda #$e3			lda 	#_DRFNullString & $FF 		; if so, return reference to ""
.95db	95 58		sta $58,x			sta 	NSMantissa0,X
.95dd	a9 95		lda #$95			lda 	#_DRFNullString >> 8
.95df	95 60		sta $60,x			sta 	NSMantissa1,X
.95e1					_DRFNotString
.95e1	7a		ply				ply 								; restore Y and exit
.95e2					_DRFExit:
.95e2	60		rts				rts
.95e3					_DRFNullString:
>95e3	00						.byte 	0
.95e4					_DRFFull:
.95e4	a0 01		ldy #$01			ldy 	#1 							; get remaining 3 bytes.
.95e6	b1 36		lda ($36),y			lda 	(zTemp0),y
.95e8	95 60		sta $60,x			sta 	NSMantissa1,x
.95ea	c8		iny				iny
.95eb	b1 36		lda ($36),y			lda 	(zTemp0),y
.95ed	95 68		sta $68,x			sta 	NSMantissa2,x
.95ef	c8		iny				iny
.95f0	b1 36		lda ($36),y			lda 	(zTemp0),y
.95f2	95 70		sta $70,x			sta 	NSMantissa3,x
.95f4	74 78		stz $78,x			stz 	NSExponent,x 				; clear exponent.
.95f6	b5 50		lda $50,x			lda		NSStatus,x 					; see if type is integer
.95f8	29 18		and #$18			and 	#NSBTypeMask  				; type information only
.95fa	95 50		sta $50,x			sta 	NSStatus,x 					; update it back.
.95fc	f0 05		beq $9603			beq 	_DRFNoExponent
.95fe	c8		iny				iny 								; if not, read the exponent as well.
.95ff	b1 36		lda ($36),y			lda 	(zTemp0),y
.9601	95 78		sta $78,x			sta 	NSExponent,x
.9603					_DRFNoExponent:
.9603	b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the most significant bit set ?
.9605	10 0a		bpl $9611			bpl 	_DRFExit2 					; if not, then exit.
.9607	29 7f		and #$7f			and 	#$7F 						; clear that bit.
.9609	95 70		sta $70,x			sta 	NSMantissa3,x
.960b	b5 50		lda $50,x			lda 	NSStatus,x 					; set the sign flag
.960d	09 80		ora #$80			ora 	#NSBIsNegative
.960f	95 50		sta $50,x			sta 	NSStatus,x
.9611					_DRFExit2:
.9611	7a		ply				ply
.9612	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/number.asm

=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.9613					EncodeNumberStart:
.9613	38		sec				sec
.9614	80 01		bra $9617			bra 	EncodeNumberContinue+1
.9616					EncodeNumberContinue:
.9616	18		clc				clc
.9617					EncodeNumber:
.9617	08		php				php 								; save reset.
.9618	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.961a	f0 12		beq $962e			beq 	_ENIsOkay
.961c	c9 30		cmp #$30			cmp 	#"0"
.961e	90 04		bcc $9624			bcc 	_ENBadNumber
.9620	c9 3a		cmp #$3a			cmp 	#"9"+1
.9622	90 0a		bcc $962e			bcc 	_ENIsOkay
.9624					_ENBadNumber:
.9624	28		plp				plp 								; throw saved reset
.9625	ad 05 04	lda $0405			lda 	EncodeState 				; decimal mode, construct final number
.9628	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.962a	f0 7b		beq $96a7			beq 	_ENConstructFinal
.962c					_ENFail:
.962c	18		clc				clc 								; not allowed
.962d	60		rts				rts
.962e					_ENIsOkay:
.962e	28		plp				plp 								; are we restarting
.962f	90 15		bcc $9646			bcc 	_ENNoRestart
.9631					_ENStartEncode:
.9631	c9 2e		cmp #$2e			cmp 	#'.'						; first is DP
.9633	f0 0c		beq $9641			beq 	_ENFirstDP
.9635	29 0f		and #$0f			and 	#15 						; put digit in mantissa
.9637	20 df 9c	jsr $9cdf			jsr 	NSMSetByte
.963a	a9 01		lda #$01			lda 	#ESTA_Low
.963c					_ENExitChange:
.963c	8d 05 04	sta $0405			sta 	EncodeState 				; save new state
.963f	38		sec				sec
.9640	60		rts				rts
.9641					_ENFirstDP:
.9641	20 dd 9c	jsr $9cdd			jsr 	NSMSetZero 					; clear integer part
.9644	80 3c		bra $9682			bra 	_ESTASwitchFloat			; go straight to float and exi
.9646					_ENNoRestart:
.9646	48		pha				pha 								; save on stack.
.9647	ad 05 04	lda $0405			lda 	EncodeState 				; get current state
.964a	c9 01		cmp #$01			cmp 	#ESTA_Low
.964c	f0 09		beq $9657			beq  	_ESTALowState
.964e	c9 02		cmp #$02			cmp 	#ESTA_High
.9650	f0 26		beq $9678			beq 	_ESTAHighState
.9652	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.9654	f0 38		beq $968e			beq 	_ESTADecimalState
>9656	db						.byte 	$DB 						; causes a break in the emulator
.9657					_ESTALowState:
.9657	68		pla				pla 								; get value back
.9658	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.965a	f0 26		beq $9682			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.965c	29 0f		and #$0f			and 	#15 						; make digit
.965e	8d 06 04	sta $0406			sta 	DigitTemp 					; save it.
.9661	b5 58		lda $58,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.9663	0a		asl a				asl 	a
.9664	0a		asl a				asl 	a
.9665	75 58		adc $58,x			adc 	NSMantissa0,x
.9667	0a		asl a				asl 	a
.9668	6d 06 04	adc $0406			adc 	DigitTemp
.966b	95 58		sta $58,x			sta 	NSMantissa0,x
.966d	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.966f	90 05		bcc $9676			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.9671	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.9673	8d 05 04	sta $0405			sta 	EncodeState
.9676					_ESTANoSwitch:
.9676	38		sec				sec
.9677	60		rts				rts
.9678					_ESTAHighState:
.9678	68		pla				pla 								; get value back
.9679	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.967b	f0 05		beq $9682			beq 	_ESTASwitchFloat
.967d	20 db 96	jsr $96db			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.9680	38		sec				sec
.9681	60		rts				rts
.9682					_ESTASwitchFloat:
.9682	9c 07 04	stz $0407			stz 	DecimalCount
.9685	e8		inx				inx 								; zero the decimal additive.
.9686	20 dd 9c	jsr $9cdd			jsr 	NSMSetZero
.9689	ca		dex				dex
.968a	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.968c	80 ae		bra $963c			bra 	_ENExitChange
.968e					_ESTADecimalState:
.968e	68		pla				pla 								; digit.
.968f	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 2nd decimal point.
.9691	f0 99		beq $962c			beq 	_ENFail
.9693	e8		inx				inx 								; put digit into fractional part of X+1
.9694	20 db 96	jsr $96db			jsr 	ESTAShiftDigitIntoMantissa
.9697	ca		dex				dex
.9698	ee 07 04	inc $0407			inc 	DecimalCount 				; bump the count of decimals
.969b	ad 07 04	lda $0407			lda 	DecimalCount
.969e	c9 0b		cmp #$0b			cmp 	#11
.96a0	f0 02		beq $96a4			beq 	_ESTADSFail
.96a2	38		sec				sec
.96a3	60		rts				rts
.96a4					_ESTADSFail:
.96a4	4c 5a 9e	jmp $9e5a			jmp 	RangeError
.96a7					_ENConstructFinal:
.96a7	ad 07 04	lda $0407			lda 	DecimalCount 				; get decimal count
.96aa	f0 2d		beq $96d9			beq 	_ENCFExit 					; no decimals
.96ac	5a		phy				phy
.96ad	0a		asl a				asl 	a 							; x 4 and CLC
.96ae	0a		asl a				asl 	a
.96af	6d 07 04	adc $0407			adc 	DecimalCount
.96b2	a8		tay				tay
.96b3	b9 19 9e	lda $9e19,y			lda 	DecimalScalarTable-5,y 		; copy decimal scalar to X+2
.96b6	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.96b8	b9 1a 9e	lda $9e1a,y			lda 	DecimalScalarTable-5+1,y
.96bb	95 62		sta $62,x			sta 	NSMantissa1+2,x
.96bd	b9 1b 9e	lda $9e1b,y			lda 	DecimalScalarTable-5+2,y
.96c0	95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.96c2	b9 1c 9e	lda $9e1c,y			lda 	DecimalScalarTable-5+3,y
.96c5	95 72		sta $72,x			sta 	NSMantissa3+2,x
.96c7	b9 1d 9e	lda $9e1d,y			lda 	DecimalScalarTable-5+4,y
.96ca	95 7a		sta $7a,x			sta 	NSExponent+2,x
.96cc	a9 08		lda #$08			lda 	#NSTFloat
.96ce	95 52		sta $52,x			sta 	NSStatus+2,x
.96d0	7a		ply				ply
.96d1	e8		inx				inx 								; multiply decimal const by decimal scalar
.96d2	20 61 94	jsr $9461			jsr 	FloatMultiply
.96d5	ca		dex				dex
.96d6	20 1c 93	jsr $931c			jsr 	FloatAdd 					; add to integer part.
.96d9					_ENCFExit:
.96d9	18		clc				clc 								; reject the digit.
.96da	60		rts				rts
.96db					ESTAShiftDigitIntoMantissa:
.96db	29 0f		and #$0f			and 	#15 						; save digit
.96dd	48		pha				pha
.96de	b5 70		lda $70,x			lda 	NSMantissa3,x 				; push mantissa on stack
.96e0	48		pha				pha
.96e1	b5 68		lda $68,x			lda 	NSMantissa2,x
.96e3	48		pha				pha
.96e4	b5 60		lda $60,x			lda 	NSMantissa1,x
.96e6	48		pha				pha
.96e7	b5 58		lda $58,x			lda 	NSMantissa0,x
.96e9	48		pha				pha
.96ea	20 ec 9c	jsr $9cec			jsr 	NSMShiftLeft 				; x 2
.96ed	20 ec 9c	jsr $9cec			jsr 	NSMShiftLeft 				; x 4
.96f0	18		clc				clc 								; pop mantissa and add
.96f1	68		pla				pla
.96f2	75 58		adc $58,x			adc 	NSMantissa0,x
.96f4	95 58		sta $58,x			sta 	NSMantissa0,x
.96f6	68		pla				pla
.96f7	75 60		adc $60,x			adc 	NSMantissa1,x
.96f9	95 60		sta $60,x			sta 	NSMantissa1,x
.96fb	68		pla				pla
.96fc	75 68		adc $68,x			adc 	NSMantissa2,x
.96fe	95 68		sta $68,x			sta 	NSMantissa2,x
.9700	68		pla				pla
.9701	75 70		adc $70,x			adc 	NSMantissa3,x
.9703	95 70		sta $70,x			sta 	NSMantissa3,x 				; x 5
.9705	20 ec 9c	jsr $9cec			jsr 	NSMShiftLeft 				; x 10
.9708	68		pla				pla 								; add digit
.9709	18		clc				clc
.970a	75 58		adc $58,x			adc 	NSMantissa0,x
.970c	95 58		sta $58,x			sta 	NSMantissa0,x
.970e	90 0a		bcc $971a			bcc 	_ESTASDExit
.9710	f6 60		inc $60,x			inc 	NSMantissa1,x
.9712	d0 06		bne $971a			bne 	_ESTASDExit
.9714	f6 68		inc $68,x			inc 	NSMantissa2,x
.9716	d0 02		bne $971a			bne 	_ESTASDExit
.9718	f6 70		inc $70,x			inc 	NSMantissa3,x
.971a					_ESTASDExit:
.971a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/term.asm

.971b					EvaluateTerm:
.971b	b1 30		lda ($30),y			lda 	(codePtr),y
.971d	30 18		bmi $9737			bmi 	_ETCheckUnary 				; unary function ? (text ones)
.971f	c9 40		cmp #$40			cmp 	#$40 						; 40-7F => identifier reference
.9721	b0 6c		bcs $978f			bcs 	_ETVariable
.9723	c9 30		cmp #$30			cmp 	#'0' 						; is it a number
.9725	90 6b		bcc $9792			bcc 	_ETPuncUnary 				; if not it might be a punctuation unary.
.9727	c9 3a		cmp #$3a			cmp 	#'9'+1
.9729	b0 67		bcs $9792			bcs 	_ETPuncUnary
.972b	20 13 96	jsr $9613			jsr 	EncodeNumberStart 			; can't fail as it's 0-9 !
.972e					_ETNumber:
.972e	c8		iny				iny 								; keep encoding until we have the numbers
.972f	b1 30		lda ($30),y			lda 	(codePtr),y
.9731	20 16 96	jsr $9616			jsr 	EncodeNumberContinue
.9734	b0 f8		bcs $972e			bcs 	_ETNumber 					; go back if accepted.
.9736	60		rts				rts
.9737					_ETCheckUnary:
.9737	c9 ff		cmp #$ff			cmp 	#KWC_STRING 				; string token
.9739	f0 3f		beq $977a			beq 	_ETString
.973b	c9 fe		cmp #$fe			cmp 	#KWC_HEXCONST 				; hex constant.
.973d	f0 12		beq $9751			beq 	_ETHexConstant
.973f	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; check it actually is a unary function
.9741	90 0b		bcc $974e			bcc 	_ETSyntaxError
.9743	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1
.9745	b0 07		bcs $974e			bcs 	_ETSyntaxError
.9747	da		phx				phx 								; push X on the stack
.9748	0a		asl a				asl 	a 							; put vector x 2 into X
.9749	aa		tax				tax
.974a	c8		iny				iny 								; consume unary function token
.974b	7c 74 8b	jmp ($8b74,x)			jmp 	(VectorSet0,x) 				; and do it.
.974e					_ETSyntaxError:
.974e	4c 55 9e	jmp $9e55			jmp 	SyntaxError
.9751					_ETHexConstant:
.9751	c8		iny				iny 								; skip #
.9752	c8		iny				iny 								; skip count
.9753	20 dd 9c	jsr $9cdd			jsr 	NSMSetZero 					; clear result
.9756					_ETHLoop:
.9756	b1 30		lda ($30),y			lda 	(codePtr),y
.9758	c8		iny				iny 								; and consume
.9759	c9 00		cmp #$00			cmp 	#0 							; exit if zero
.975b	f0 1c		beq $9779			beq 	_ETHExit
.975d	48		pha				pha 								; save on stack.
.975e	20 ec 9c	jsr $9cec			jsr 	NSMShiftLeft 				; x 2
.9761	20 ec 9c	jsr $9cec			jsr 	NSMShiftLeft 				; x 4
.9764	20 ec 9c	jsr $9cec			jsr 	NSMShiftLeft 				; x 8
.9767	20 ec 9c	jsr $9cec			jsr 	NSMShiftLeft 				; x 16
.976a	68		pla				pla 								; ASCII
.976b	c9 41		cmp #$41			cmp 	#'A'
.976d	90 02		bcc $9771			bcc 	_ETHNotChar
.976f	e9 07		sbc #$07			sbc 	#7
.9771					_ETHNotChar:
.9771	29 0f		and #$0f			and 	#15 						; digit now
.9773	15 58		ora $58,x			ora 	NSMantissa0,x 				; put in LS Nibble
.9775	95 58		sta $58,x			sta 	NSMantissa0,x
.9777	80 dd		bra $9756			bra 	_ETHLoop 					; go round.
.9779					_ETHExit:
.9779	60		rts				rts
.977a					_ETString:
.977a	c8		iny				iny 								; look at length
.977b	b1 30		lda ($30),y			lda 	(codePtr),y
.977d	48		pha				pha
.977e	c8		iny				iny 								; first character
.977f	20 32 a4	jsr $a432			jsr 	MemoryInline 				; put address of string at (code-Ptr),y on stack
.9782	68		pla				pla 								; restore count and save
.9783	85 36		sta $36				sta 	zTemp0
.9785	98		tya				tya 								; add length to Y to skip it.
.9786	18		clc				clc
.9787	65 36		adc $36				adc 	zTemp0
.9789	a8		tay				tay
.978a	a9 10		lda #$10			lda 	#NSTString 					; mark as string
.978c	95 50		sta $50,x			sta 	NSStatus,x
.978e	60		rts				rts
.978f					_ETVariable:
.978f	4c e4 97	jmp $97e4			jmp 	VariableHandler
.9792					_ETPuncUnary:
.9792	c8		iny				iny 								; consume the unary character
.9793	c9 2d		cmp #$2d			cmp 	#KWD_MINUS 					; unary minus
.9795	f0 2b		beq $97c2			beq 	_ETUnaryNegate
.9797	c9 10		cmp #$10			cmp 	#KWD_AT 					; @ reference -> constant
.9799	f0 36		beq $97d1			beq 	_ETDereference
.979b	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; parenthesis
.979d	f0 3e		beq $97dd			beq 	_ETParenthesis
.979f	64 36		stz $36				stz 	zTemp0 						; zTemp0 is the indirection level.
.97a1	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; byte indirection (0) ?
.97a3	f0 06		beq $97ab			beq 	_ETIndirection
.97a5	e6 36		inc $36				inc 	zTemp0
.97a7	c9 21		cmp #$21			cmp 	#KWD_PLING					; word indirection (1) \
.97a9	d0 a3		bne $974e			bne 	_ETSyntaxError
.97ab					_ETIndirection:
.97ab	a5 36		lda $36				lda 	zTemp0 						; push indirection amount (0-1) => (1-2) on the stack
.97ad	1a		inc a				inc 	a
.97ae	48		pha				pha
.97af	20 1b 97	jsr $971b			jsr 	EvaluateTerm				; evaluate the term
.97b2	20 94 95	jsr $9594			jsr 	Dereference 				; dereference it.
.97b5	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a +ve integer.
.97b7	d0 06		bne $97bf			bne 	_ETTypeMismatch
.97b9	68		pla				pla 								; indirection 1-2
.97ba	09 20		ora #$20			ora 	#NSBIsReference 			; make it a reference.
.97bc	95 50		sta $50,x			sta 	NSStatus,x
.97be	60		rts				rts
.97bf					_ETTypeMismatch:
.97bf	4c 5f 9e	jmp $9e5f			jmp 	TypeError
.97c2					_ETUnaryNegate:
.97c2	20 1b 97	jsr $971b			jsr 	EvaluateTerm				; evaluate the term
.97c5	20 94 95	jsr $9594			jsr 	Dereference 				; dereference it.
.97c8	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a number
.97ca	29 10		and #$10			and 	#NSTString
.97cc	d0 f1		bne $97bf			bne 	_ETTypeMismatch
.97ce	4c 9f 9c	jmp $9c9f			jmp 	NSMNegate  					; just toggles the sign bit.
.97d1					_ETDereference:
.97d1	20 1b 97	jsr $971b			jsr 	EvaluateTerm				; evaluate the term
.97d4	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a reference
.97d6	29 20		and #$20			and 	#NSBIsReference
.97d8	f0 e5		beq $97bf			beq 	_ETTypeMismatch
.97da	74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer address
.97dc	60		rts				rts
.97dd					_ETParenthesis:
.97dd	20 d1 92	jsr $92d1			jsr 	EvaluateExpression 			; evaluate here, from lowest precedence
.97e0	20 b4 8d	jsr $8db4			jsr 	CheckRightBracket 			; check for )
.97e3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/variable.asm

.97e4					VariableHandler:
.97e4	b1 30		lda ($30),y			lda 	(codePtr),y
.97e6	18		clc				clc
.97e7	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.97e9	85 37		sta $37				sta 	zTemp0+1
.97eb	c8		iny				iny
.97ec	b1 30		lda ($30),y			lda 	(codePtr),y
.97ee	85 36		sta $36				sta 	zTemp0
.97f0	c8		iny				iny
.97f1	18		clc				clc									; copy variable address+3 to mantissa
.97f2	69 03		adc #$03			adc 	#3
.97f4	95 58		sta $58,x			sta 	NSMantissa0,x
.97f6	a5 37		lda $37				lda 	zTemp0+1
.97f8	69 00		adc #$00			adc 	#0
.97fa	95 60		sta $60,x			sta 	NSMantissa1,x
.97fc	74 68		stz $68,x			stz 	NSMantissa2,x
.97fe	74 70		stz $70,x			stz 	NSMantissa3,x
.9800	74 78		stz $78,x			stz 	NSExponent,x
.9802	5a		phy				phy
.9803	a0 02		ldy #$02			ldy 	#2 							; read type
.9805	b1 36		lda ($36),y			lda 	(zTemp0),y
.9807	7a		ply				ply
.9808	29 1c		and #$1c			and 	#NSBTypeMask+NSBIsArray 	; get type information
.980a	09 20		ora #$20			ora 	#NSBIsReference 			; make a reference.
.980c	95 50		sta $50,x			sta 	NSStatus,x
.980e	29 04		and #$04			and 	#NSBIsArray
.9810	d0 01		bne $9813			bne 	_VHArray
.9812	60		rts				rts
.9813					_VHArray:
.9813	e8		inx				inx
.9814	20 78 9c	jsr $9c78			jsr 	Evaluate8BitInteger 		; get the 1st index.
.9817	a9 ff		lda #$ff			lda 	#$FF 						; set Status of X+2 to a duff value so we know if we picked it up.
.9819	95 51		sta $51,x			sta 	NSStatus+1,x
.981b	b1 30		lda ($30),y			lda 	(codePtr),y
.981d	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.981f	d0 06		bne $9827			bne 	_VHNoSecondIndex
.9821	c8		iny				iny 								; skip the comma
.9822	e8		inx				inx
.9823	20 78 9c	jsr $9c78			jsr 	Evaluate8BitInteger 		; get the 2nd index.
.9826	ca		dex				dex
.9827					_VHNoSecondIndex:
.9827	ca		dex				dex 								; set X back.
.9828	20 b4 8d	jsr $8db4			jsr 	CheckRightBracket 			; and check the right bracket.
.982b	5a		phy				phy 								; save position
.982c	a0 02		ldy #$02			ldy 	#2 							; check first index is not-zero, e.g. array defined
.982e	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9830	f0 60		beq $9892			beq 	_VHBadIndex
.9832	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy record address to zaTemp
.9834	85 3e		sta $3e				sta 	zaTemp
.9836	b5 60		lda $60,x			lda 	NSMantissa1,x
.9838	85 3f		sta $3f				sta 	zaTemp+1
.983a	a0 03		ldy #$03			ldy 	#3 							; get the second index - which is 0 if there is one index.
.983c	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.983e	f0 02		beq $9842			beq 	_VHHas2Mask
.9840	a9 ff		lda #$ff			lda 	#$FF
.9842					_VHHas2Mask:
.9842	d5 52		cmp $52,x			cmp 	NSStatus+2,x 				; so if they are the same there are the wrong number of indices
.9844	f0 4c		beq $9892			beq 	_VHBadIndex
.9846	0a		asl a				asl 	a 							; carry will be set if a second index
.9847	90 08		bcc $9851			bcc 	_VHCheckFirstIndex
.9849	a0 03		ldy #$03			ldy 	#3 			 				; check the 2nd size >= 2nd index
.984b	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.984d	d5 5a		cmp $5a,x			cmp 	NSMantissa0+2,x
.984f	90 41		bcc $9892			bcc 	_VHBadIndex
.9851					_VHCheckFirstIndex:
.9851	a0 02		ldy #$02			ldy 	#2 			 				; check the 2nd size >= 2nd index
.9853	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9855	d5 59		cmp $59,x			cmp 	NSMantissa0+1,x
.9857	90 39		bcc $9892			bcc 	_VHBadIndex
.9859	64 36		stz $36				stz 	zTemp0 						; clear zTemp0 (if 1 index)
.985b	64 37		stz $37				stz 	zTemp0+1
.985d	b5 52		lda $52,x			lda 	NSStatus+2,x 				; if only one index provided, don't need to multiply
.985f	30 0e		bmi $986f			bmi 	_VHNoMultiply
.9861	da		phx				phx
.9862	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; get 2nd index on stack
.9864	48		pha				pha
.9865	a0 02		ldy #$02			ldy 	#2 							; get 1st size in A
.9867	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9869	1a		inc a				inc 	a 							; add 1 for zero base
.986a	fa		plx				plx
.986b	20 88 9c	jsr $9c88			jsr 	Multiply8x8 				; calculate -> Z0
.986e	fa		plx				plx
.986f					_VHNoMultiply:
.986f	18		clc				clc
.9870	a5 36		lda $36				lda 	zTemp0
.9872	75 59		adc $59,x			adc 	NSMantissa0+1,x
.9874	85 36		sta $36				sta 	zTemp0
.9876	a5 37		lda $37				lda 	zTemp0+1
.9878	69 00		adc #$00			adc 	#0
.987a	85 37		sta $37				sta 	zTemp0+1
.987c	b5 50		lda $50,x			lda 	NSStatus,x
.987e	20 f6 84	jsr $84f6			jsr 	ScaleByBaseType
.9881	18		clc				clc
.9882	b2 3e		lda ($3e)			lda 	(zaTemp)
.9884	65 36		adc $36				adc 	zTemp0
.9886	95 58		sta $58,x			sta 	NSMantissa0,x
.9888	a0 01		ldy #$01			ldy 	#1
.988a	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.988c	65 37		adc $37				adc 	zTemp0+1
.988e	95 60		sta $60,x			sta 	NSMantissa1,x
.9890	7a		ply				ply 								; restore position
.9891	60		rts				rts
.9892					_VHBadIndex:
.9892	a9 17		lda #$17		lda	#23
.9894	4c cd 8d	jmp $8dcd		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/abs.asm

.9897					AbsUnary:
.9897	fa		plx				plx 								; restore stack pos
.9898	20 2b 9c	jsr $9c2b			jsr 	EvaluateNumber 				; get a float or int
.989b	20 b4 8d	jsr $8db4			jsr 	CheckRightBracket
.989e	b5 50		lda $50,x			lda 	NSStatus,x 					; clear the sign bit
.98a0	29 7f		and #$7f			and 	#$7F
.98a2	95 50		sta $50,x			sta 	NSStatus,x
.98a4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/alloc.asm

.98a5					AllocUnary:
.98a5	fa		plx				plx 								; restore stack pos
.98a6	20 5d 9c	jsr $9c5d			jsr 	Evaluate16BitInteger		; get bytes required.
.98a9	20 b4 8d	jsr $8db4			jsr 	CheckRightBracket
.98ac	da		phx				phx 								; save X/Y
.98ad	5a		phy				phy
.98ae	8a		txa				txa 								; copy X into Y
.98af	a8		tay				tay
.98b0	b9 60 00	lda $0060,y			lda		NSMantissa1,y 				; get size
.98b3	aa		tax				tax
.98b4	b9 58 00	lda $0058,y			lda 	NSMantissa0,y
.98b7	20 c4 98	jsr $98c4			jsr 	AllocateXABytes 			; allocate memory
.98ba	99 58 00	sta $0058,y			sta 	NSMantissa0,y 				; write address out.
.98bd	8a		txa				txa
.98be	99 60 00	sta $0060,y			sta 	NSMantissa1,y
.98c1	7a		ply				ply
.98c2	fa		plx				plx
.98c3	60		rts				rts
.98c4					AllocateXABytes:
.98c4	5a		phy				phy
.98c5	ac 0c 04	ldy $040c			ldy 	lowMemPtr 					; push current address on stack and to zTemp0
.98c8	84 36		sty $36				sty 	zTemp0
.98ca	5a		phy				phy
.98cb	ac 0d 04	ldy $040d			ldy 	lowMemPtr+1
.98ce	84 37		sty $37				sty 	zTemp0+1
.98d0	5a		phy				phy
.98d1	18		clc				clc 								; add to low memory pointer
.98d2	6d 0c 04	adc $040c			adc 	lowMemPtr
.98d5	8d 0c 04	sta $040c			sta 	lowMemPtr
.98d8	8a		txa				txa
.98d9	6d 0d 04	adc $040d			adc 	lowMemPtr+1
.98dc	8d 0d 04	sta $040d			sta 	lowMemPtr+1
.98df	b0 2f		bcs $9910			bcs 	CISSMemory
.98e1	20 02 99	jsr $9902			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.98e4					_ClearMemory:
.98e4	ad 0c 04	lda $040c			lda 	lowMemPtr 					; cleared all memory allocated
.98e7	c5 36		cmp $36				cmp 	zTemp0
.98e9	d0 07		bne $98f2			bne 	_CMClearNext
.98eb	ad 0d 04	lda $040d			lda 	lowMemPtr+1
.98ee	c5 37		cmp $37				cmp 	zTemp0+1
.98f0	f0 0c		beq $98fe			beq 	_CMExit
.98f2					_CMClearNext:
.98f2	a9 00		lda #$00			lda 	#0 							; clear byte, advance to next.
.98f4	92 36		sta ($36)			sta 	(zTemp0)
.98f6	e6 36		inc $36				inc 	zTemp0
.98f8	d0 ea		bne $98e4			bne 	_ClearMemory
.98fa	e6 37		inc $37				inc		zTemp0+1
.98fc	80 e6		bra $98e4			bra 	_ClearMemory
.98fe					_CMExit:
.98fe	fa		plx				plx
.98ff	68		pla				pla
.9900	7a		ply				ply
.9901	60		rts				rts
.9902					CheckIdentifierStringSpace:
.9902	48		pha				pha
.9903	ad 0d 04	lda $040d			lda 	lowMemPtr+1 				; get low memory pointer
.9906	18		clc				clc
.9907	69 02		adc #$02			adc 	#2 							; need at least 2 256 byte pages
.9909	cd 0f 04	cmp $040f			cmp 	StringMemory+1 				; is it >= StringMemory
.990c	b0 02		bcs $9910			bcs 	CISSMemory
.990e	68		pla				pla
.990f	60		rts				rts
.9910					CISSMemory:
.9910	a9 06		lda #$06		lda	#6
.9912	4c cd 8d	jmp $8dcd		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/asc.asm

.9915					AscUnary:
.9915	fa		plx				plx 								; restore stack pos
.9916	20 35 9c	jsr $9c35			jsr 	EvaluateString 				; get a string
.9919	b2 36		lda ($36)			lda 	(zTemp0)					; get/return first character
.991b	20 df 9c	jsr $9cdf			jsr 	NSMSetByte 					; ASC("") will return zero.
.991e	20 b4 8d	jsr $8db4			jsr 	CheckRightBracket
.9921	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/frac.asm

.9922					FracUnary:
.9922	fa		plx				plx 								; restore stack pos
.9923	20 2b 9c	jsr $9c2b			jsr 	EvaluateNumber 				; get a float or int
.9926	20 b4 8d	jsr $8db4			jsr 	CheckRightBracket
.9929	b5 50		lda $50,x			lda 	NSStatus,x
.992b	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.992d	f0 04		beq $9933			beq 	_IUZero
.992f	20 e2 93	jsr $93e2			jsr 	FloatFractionalPart
.9932	60		rts				rts
.9933					_IUZero:
.9933	20 dd 9c	jsr $9cdd			jsr 	NSMSetZero
.9936	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/int.asm

.9937					IntUnary:
.9937	fa		plx				plx 								; restore stack pos
.9938	20 2b 9c	jsr $9c2b			jsr 	EvaluateNumber 				; get a float or int
.993b	20 b4 8d	jsr $8db4			jsr 	CheckRightBracket
.993e	b5 50		lda $50,x			lda 	NSStatus,x
.9940	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9942	f0 03		beq $9947			beq 	_IUExit
.9944	20 3a 94	jsr $943a			jsr 	FloatIntegerPart
.9947					_IUExit:
.9947	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/len.asm

.9948					LenUnary:
.9948	fa		plx				plx 								; restore stack pos
.9949	20 35 9c	jsr $9c35			jsr 	EvaluateString 				; get a string
.994c	5a		phy				phy
.994d	a0 00		ldy #$00			ldy 	#0 							; find length
.994f					_LenFind:
.994f	b1 36		lda ($36),y			lda 	(zTemp0),y 					; look for trailing NULL.
.9951	f0 06		beq $9959			beq 	_LenExit
.9953	c8		iny				iny
.9954	d0 f9		bne $994f			bne 	_LenFind
.9956	4c 5a 9e	jmp $9e5a			jmp 	RangeError 					; string > 255 - no trailing NULL.
.9959					_LenExit:
.9959	98		tya				tya		 							; return length
.995a	20 df 9c	jsr $9cdf			jsr 	NSMSetByte
.995d	7a		ply				ply
.995e	20 b4 8d	jsr $8db4			jsr 	CheckRightBracket
.9961	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/minmax.asm

.9962					Unary_Min:
.9962	a9 01		lda #$01			lda 	#1
.9964	80 02		bra $9968			bra 	UnaryMinMaxMain
.9966					Unary_Max:
.9966	a9 ff		lda #$ff			lda 	#$FF 						; value from comparator to cause a write
.9968					UnaryMinMaxMain:
.9968	fa		plx				plx 								; get index on number stack
.9969	48		pha				pha 								; save comparator
.996a	20 22 9c	jsr $9c22			jsr 	EvaluateValue 				; get the first value.
.996d					_UMMMLoop:
.996d	b1 30		lda ($30),y			lda 	(codePtr),y
.996f	c9 29		cmp #$29			cmp 	#KWD_RPAREN 				; if right bracket then done.
.9971	f0 22		beq $9995			beq 	_UMMMDone
.9973	20 bc 8d	jsr $8dbc			jsr 	CheckComma 					; must be a comma
.9976	e8		inx				inx
.9977	20 22 9c	jsr $9c22			jsr 	EvaluateValue
.997a	ca		dex				dex
.997b	20 c0 9c	jsr $9cc0			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] (Compare is destructive)
.997e	e8		inx				inx
.997f	20 c0 9c	jsr $9cc0			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2], original
.9982	e8		inx				inx
.9983	20 84 8e	jsr $8e84			jsr 	CompareBaseCode 			; part of > = < etc. code, returns 255,0 or 1
.9986	ca		dex				dex
.9987	ca		dex				dex
.9988	85 36		sta $36				sta 	zTemp0 						; save required result
.998a	68		pla				pla 								; get and save comparator
.998b	48		pha				pha
.998c	c5 36		cmp $36				cmp 	zTemp0 						; if the comparator
.998e	d0 dd		bne $996d			bne 	_UMMMLoop
.9990	20 98 99	jsr $9998			jsr 	ExpCopyAboveDown 			; copy next up slot down
.9993	80 d8		bra $996d			bra 	_UMMMLoop
.9995					_UMMMDone:
.9995	68		pla				pla 								; throw the comparator
.9996	c8		iny				iny 								; skip )
.9997	60		rts				rts
.9998					ExpCopyAboveDown:
.9998	b5 51		lda $51,x			lda 	NSStatus+1,x
.999a	95 50		sta $50,x			sta 	NSStatus,x
.999c	b5 79		lda $79,x			lda 	NSExponent+1,x
.999e	95 78		sta $78,x			sta 	NSExponent,x
.99a0	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.99a2	95 58		sta $58,x			sta 	NSMantissa0,x
.99a4	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.99a6	95 60		sta $60,x			sta 	NSMantissa1,x
.99a8	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.99aa	95 68		sta $68,x			sta 	NSMantissa2,x
.99ac	b5 71		lda $71,x			lda 	NSMantissa3+1,x
.99ae	95 70		sta $70,x			sta 	NSMantissa3,x
.99b0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/not.asm

.99b1					Unary_Not:
.99b1	fa		plx				plx
.99b2	20 4a 9c	jsr $9c4a			jsr 	EvaluateInteger 			; get integer
.99b5	20 b4 8d	jsr $8db4			jsr 	CheckRightBracket
.99b8	20 ff 9c	jsr $9cff			jsr 	NSMIsZero 					; zero mantissa ?
.99bb	f0 04		beq $99c1			beq 	_NotZero
.99bd	20 dd 9c	jsr $9cdd			jsr 	NSMSetZero
.99c0	60		rts				rts
.99c1					_NotZero:
.99c1	4c 3a 8e	jmp $8e3a			jmp 	ReturnTrue
.99c4					_UNBad:
.99c4	4c 64 9e	jmp $9e64			jmp 	ArgumentError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/rnd.asm

.99c7					Unary_Random:
.99c7	fa		plx				plx
.99c8	20 39 9a	jsr $9a39			jsr 	Random32Bit 				; get a random number
.99cb	20 22 9a	jsr $9a22			jsr 	URCopyToMantissa  			; put in mantissa
.99ce	b1 30		lda ($30),y			lda 	(codePtr),y
.99d0	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.99d2	f0 08		beq $99dc			beq 	_URNoModulus
.99d4	e8		inx				inx
.99d5	20 5d 9c	jsr $9c5d			jsr 	Evaluate16BitInteger 		; put modulus value in +1
.99d8	ca		dex				dex
.99d9	20 8c 8f	jsr $8f8c			jsr 	IntegerModulusNoCheck 		; calculate modulus
.99dc					_URNoModulus:
.99dc	74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer positive
.99de	74 78		stz $78,x			stz 	NSExponent,x
.99e0	20 b4 8d	jsr $8db4			jsr 	CheckRightBracket
.99e3	60		rts				rts
.99e4					Unary_Rnd:
.99e4	fa		plx				plx
.99e5	20 2b 9c	jsr $9c2b			jsr 	EvaluateNumber 				; number to use.
.99e8	20 b4 8d	jsr $8db4			jsr 	CheckRightBracket 			; closing bracket
.99eb	20 ff 9c	jsr $9cff			jsr 	NSMIsZero 					; if zero, then don't generate a new number
.99ee	f0 26		beq $9a16			beq 	_URCopySeed
.99f0	b5 50		lda $50,x			lda 	NSStatus,x 					; if -ve, then seed using parameter
.99f2	10 1f		bpl $9a13			bpl 	_URDontSeed
.99f4	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy - value to seed butchering it.
.99f6	49 17		eor #$17			eor 	#$17
.99f8	8d 08 04	sta $0408			sta 	RandomSeed+0
.99fb	b5 60		lda $60,x			lda 	NSMantissa1,x
.99fd	49 a5		eor #$a5			eor 	#$A5
.99ff	8d 09 04	sta $0409			sta 	RandomSeed+1
.9a02	b5 68		lda $68,x			lda 	NSMantissa2,x
.9a04	49 c2		eor #$c2			eor 	#$C2
.9a06	8d 0a 04	sta $040a			sta 	RandomSeed+2
.9a09	b5 70		lda $70,x			lda 	NSMantissa3,x
.9a0b	49 9d		eor #$9d			eor 	#$9D
.9a0d	8d 0b 04	sta $040b			sta 	RandomSeed+3
.9a10	20 39 9a	jsr $9a39			jsr 	Random32Bit
.9a13					_URDontSeed:
.9a13	20 39 9a	jsr $9a39			jsr 	Random32Bit 				; generate a number.
.9a16					_URCopySeed:
.9a16	20 22 9a	jsr $9a22			jsr 	URCopyToMantissa 			; copy into mantissa
.9a19	a9 e2		lda #$e2			lda 	#-30 						; force into 0-1 range
.9a1b	95 78		sta $78,x			sta 	NSExponent,x
.9a1d	a9 08		lda #$08			lda 	#NSTFloat
.9a1f	95 50		sta $50,x			sta 	NSStatus,x 					; positive.
.9a21	60		rts				rts
.9a22					URCopyToMantissa:
.9a22	ad 08 04	lda $0408			lda 	RandomSeed+0
.9a25	95 58		sta $58,x			sta 	NSMantissa0,x
.9a27	ad 09 04	lda $0409			lda 	RandomSeed+1
.9a2a	95 60		sta $60,x			sta 	NSMantissa1,x
.9a2c	ad 0a 04	lda $040a			lda 	RandomSeed+2
.9a2f	95 68		sta $68,x			sta 	NSMantissa2,x
.9a31	ad 0b 04	lda $040b			lda 	RandomSeed+3
.9a34	29 3f		and #$3f			and 	#$3F 						; make legal mantissa
.9a36	95 70		sta $70,x			sta 	NSMantissa3,x
.9a38	60		rts				rts
.9a39					Random32Bit:
.9a39	5a		phy				phy
.9a3a	a0 07		ldy #$07			ldy 	#7 							; do it 7 times
.9a3c	ad 08 04	lda $0408			lda 	RandomSeed+0 				; check the seed isn't zero
.9a3f	d0 03		bne $9a44			bne 	_Random1
.9a41	a8		tay				tay 								; if so do it 256 times
.9a42	a9 aa		lda #$aa			lda		#$AA 						; and use this to seed the seed....
.9a44					_Random1:
.9a44	0a		asl a				asl 	a 							; LSFR RNG
.9a45	2e 09 04	rol $0409			rol 	RandomSeed+1
.9a48	2e 0a 04	rol $040a			rol 	RandomSeed+2
.9a4b	2e 0b 04	rol $040b			rol 	RandomSeed+3
.9a4e	90 02		bcc $9a52			bcc 	_Random2
.9a50	49 c5		eor #$c5			eor 	#$C5
.9a52					_Random2:
.9a52	88		dey				dey
.9a53	d0 ef		bne $9a44			bne 	_Random1
.9a55	8d 08 04	sta $0408			sta 	RandomSeed+0
.9a58	7a		ply				ply
.9a59	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/sgn.asm

.9a5a					SgnUnary:
.9a5a	fa		plx				plx 								; restore stack pos
.9a5b	20 2b 9c	jsr $9c2b			jsr 	EvaluateNumber 				; get a float or int
.9a5e	20 b4 8d	jsr $8db4			jsr 	CheckRightBracket
.9a61	20 ff 9c	jsr $9cff			jsr 	NSMIsZero 					; if zero
.9a64	f0 0e		beq $9a74			beq 	_SGZero  					; return Int Zero
.9a66	b5 50		lda $50,x			lda 	NSStatus,x 					; get status w/sign
.9a68	48		pha				pha
.9a69	a9 01		lda #$01			lda 	#1 							; set to 1
.9a6b	20 df 9c	jsr $9cdf			jsr 	NSMSetByte
.9a6e	68		pla				pla
.9a6f	29 80		and #$80			and		#$80 						; copy the sign byte out
.9a71	95 50		sta $50,x			sta 	NSStatus,x
.9a73	60		rts				rts
.9a74	20 dd 9c	jsr $9cdd	_SGZero:jsr 	NSMSetZero
.9a77	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/val.asm

.9a78					ValUnary:
.9a78	fa		plx				plx 								; restore stack pos
.9a79	20 8e 9a	jsr $9a8e			jsr 	ValMainCode 				; do the main val() code
.9a7c	b0 01		bcs $9a7f			bcs 	_VUError 					; couldn't convert
.9a7e	60		rts				rts
.9a7f					_VUError:
.9a7f	4c 5f 9e	jmp $9e5f			jmp 	TypeError
.9a82					IsValUnary:
.9a82	fa		plx				plx 								; restore stack pos
.9a83	20 8e 9a	jsr $9a8e			jsr 	ValMainCode 				; do the main val() code
.9a86	b0 03		bcs $9a8b			bcs 	_VUBad
.9a88	4c 3a 8e	jmp $8e3a			jmp 	ReturnTrue
.9a8b					_VUBad:
.9a8b	4c 45 8e	jmp $8e45			jmp 	ReturnFalse
.9a8e					ValMainCode:
.9a8e	20 35 9c	jsr $9c35			jsr 	EvaluateString 				; get a string
.9a91	20 b4 8d	jsr $8db4			jsr 	CheckRightBracket 			; check right bracket present
.9a94					ValEvaluateZTemp0:
.9a94	5a		phy				phy
.9a95	b2 36		lda ($36)			lda 	(zTemp0) 					; check not empty string
.9a97	f0 17		beq $9ab0			beq 	_VMCFail2
.9a99	a0 ff		ldy #$ff			ldy 	#$FF 						; start position
.9a9b	48		pha				pha 								; save first character
.9a9c	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it -
.9a9e	d0 01		bne $9aa1			bne 	_VMCStart
.9aa0	c8		iny				iny 								; skip over -
.9aa1					_VMCStart:
.9aa1	38		sec				sec 								; initialise first time round.
.9aa2					_VMCNext:
.9aa2	c8		iny				iny 								; pre-increment
.9aa3	b1 36		lda ($36),y			lda 	(zTemp0),y 					; next character
.9aa5	f0 0c		beq $9ab3			beq 	_VMCSuccess 				; successful.
.9aa7	20 17 96	jsr $9617			jsr 	EncodeNumber 				; send it to the number-builder
.9aaa	90 03		bcc $9aaf			bcc 	_VMCFail 					; if failed, give up.
.9aac	18		clc				clc 								; next time round, countinue
.9aad	80 f3		bra $9aa2			bra 	_VMCNext
.9aaf					_VMCFail:
.9aaf	68		pla				pla
.9ab0					_VMCFail2:
.9ab0	7a		ply				ply
.9ab1	38		sec				sec
.9ab2	60		rts				rts
.9ab3					_VMCSuccess:
.9ab3	a9 00		lda #$00			lda 	#0 							; construct final
.9ab5	20 17 96	jsr $9617			jsr 	EncodeNumber
.9ab8	68		pla				pla
.9ab9	c9 2d		cmp #$2d			cmp 	#"-"
.9abb	d0 03		bne $9ac0			bne 	_VMCNotNegative
.9abd	20 9f 9c	jsr $9c9f			jsr		NSMNegate
.9ac0					_VMCNotNegative:
.9ac0	7a		ply				ply
.9ac1	18		clc				clc
.9ac2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/chr.asm

.9ac3					ChrUnary:
.9ac3	fa		plx				plx 								; restore stack pos
.9ac4	20 78 9c	jsr $9c78			jsr 	Evaluate8BitInteger			; get value
.9ac7	48		pha				pha
.9ac8	20 b4 8d	jsr $8db4			jsr 	CheckRightBracket
.9acb	a9 01		lda #$01			lda 	#1 							; allocate space for one char
.9acd	20 09 a6	jsr $a609			jsr 	StringTempAllocate
.9ad0	68		pla				pla 								; write number to it
.9ad1	20 42 a6	jsr $a642			jsr 	StringTempWrite
.9ad4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/spc.asm

.9ad5					SpcUnary:
.9ad5	fa		plx				plx 								; restore stack pos
.9ad6	20 78 9c	jsr $9c78			jsr 	Evaluate8BitInteger			; get value
.9ad9	5a		phy				phy
.9ada	48		pha				pha 								; save count
.9adb	20 09 a6	jsr $a609			jsr 	StringTempAllocate
.9ade	7a		ply				ply 								; to do count in Y
.9adf					_SpcLoop:
.9adf	c0 00		cpy #$00			cpy 	#0
.9ae1	f0 08		beq $9aeb			beq 	_SpcExit
.9ae3	a9 20		lda #$20			lda 	#32
.9ae5	20 42 a6	jsr $a642			jsr 	StringTempWrite
.9ae8	88		dey				dey
.9ae9	80 f4		bra $9adf			bra 	_SPCLoop
.9aeb					_SpcExit:
.9aeb	7a		ply				ply
.9aec	20 b4 8d	jsr $8db4			jsr 	CheckRightBracket
.9aef	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/str.asm

.9af0					Unary_Str:
.9af0	fa		plx				plx
.9af1	20 2b 9c	jsr $9c2b			jsr 	EvaluateNumber  			; get number
.9af4	20 b4 8d	jsr $8db4			jsr 	CheckRightBracket 			; closing bracket
.9af7	a9 05		lda #$05			lda 	#5 							; maximum decimals, from Basic816
.9af9	20 12 9b	jsr $9b12			jsr 	ConvertNumberToString 		; do the conversion.
.9afc	a9 21		lda #$21			lda		#33 						; create buffer
.9afe	20 09 a6	jsr $a609			jsr 	StringTempAllocate 			; allocate memory
.9b01	da		phx				phx
.9b02	a2 00		ldx #$00			ldx 	#0
.9b04					_USCopy:
.9b04	bd 9d 05	lda $059d,x			lda 	DecimalBuffer,x
.9b07	20 42 a6	jsr $a642			jsr 	StringTempWrite
.9b0a	e8		inx				inx
.9b0b	bd 9d 05	lda $059d,x			lda 	DecimalBuffer,x
.9b0e	d0 f4		bne $9b04			bne 	_USCopy
.9b10	fa		plx				plx
.9b11	60		rts				rts
.9b12					ConvertNumberToString:
.9b12	5a		phy				phy 								; save code position
.9b13	8d 14 04	sta $0414			sta 	DecimalPlaces	 			; save number of DPs.
.9b16	9c 15 04	stz $0415			stz 	dbOffset 					; offset into decimal buffer = start.
.9b19	b5 50		lda $50,x			lda 	NSStatus,x  				; is it -ve.
.9b1b	10 09		bpl $9b26			bpl 	_CNTSNotNegative
.9b1d	29 7f		and #$7f			and 	#$7F 						; make +ve
.9b1f	95 50		sta $50,x			sta 	NSStatus,x
.9b21	a9 2d		lda #$2d			lda 	#"-"
.9b23	20 87 9b	jsr $9b87			jsr 	WriteDecimalBuffer
.9b26					_CNTSNotNegative:
.9b26	b5 78		lda $78,x			lda 	NSExponent,x 				; check if decimal
.9b28	f0 12		beq $9b3c			beq 	_CNTSNotFloat
.9b2a	e8		inx				inx 								; round up
.9b2b	a9 01		lda #$01			lda 	#1
.9b2d	20 df 9c	jsr $9cdf			jsr 	NSMSetByte
.9b30	ca		dex				dex
.9b31	b5 78		lda $78,x			lda		NSExponent,x
.9b33	95 79		sta $79,x			sta 	NSExponent+1,x
.9b35	a9 08		lda #$08			lda 	#NSTFloat
.9b37	95 51		sta $51,x			sta 	NSStatus+1,x
.9b39	20 1c 93	jsr $931c			jsr 	FloatAdd
.9b3c					_CNTSNotFloat:
.9b3c	20 69 9b	jsr $9b69			jsr 	MakePlusTwoString
.9b3f	20 e2 93	jsr $93e2			jsr 	FloatFractionalPart 		; get the fractional part
.9b42	20 93 94	jsr $9493			jsr 	NSNormalise					; normalise , exit if zero
.9b45	f0 20		beq $9b67			beq 	_CNTSExit
.9b47	a9 2e		lda #$2e			lda 	#"."
.9b49	20 87 9b	jsr $9b87			jsr 	WriteDecimalBuffer 			; write decimal place
.9b4c					_CNTSDecimal:
.9b4c	ce 14 04	dec $0414			dec 	DecimalPlaces 				; done all the decimals
.9b4f	30 16		bmi $9b67			bmi 	_CNTSExit
.9b51	e8		inx				inx 								; x 10.0
.9b52	a9 0a		lda #$0a			lda 	#10
.9b54	20 df 9c	jsr $9cdf			jsr 	NSMSetByte
.9b57	a9 08		lda #$08			lda 	#NSTFloat
.9b59	95 50		sta $50,x			sta 	NSStatus,x
.9b5b	ca		dex				dex
.9b5c	20 61 94	jsr $9461			jsr 	FloatMultiply
.9b5f	20 69 9b	jsr $9b69			jsr 	MakePlusTwoString
.9b62	20 e2 93	jsr $93e2			jsr 	FloatFractionalPart 		; get the fractional part
.9b65	80 e5		bra $9b4c			bra 	_CNTSDecimal 				; keep going.
.9b67					_CNTSExit:
.9b67	7a		ply				ply
.9b68	60		rts				rts
.9b69					MakePlusTwoString:
.9b69	da		phx				phx
.9b6a	20 c0 9c	jsr $9cc0			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.9b6d	e8		inx				inx 								; access it
.9b6e	e8		inx				inx
.9b6f	20 3a 94	jsr $943a			jsr 	FloatIntegerPart 			; make it an integer
.9b72	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.9b74	20 4c 92	jsr $924c			jsr 	ConvertInt32
.9b77	a2 00		ldx #$00			ldx	 	#0
.9b79					_MPTSCopy:
.9b79	bd 7b 05	lda $057b,x			lda 	NumberBuffer,x
.9b7c	20 87 9b	jsr $9b87			jsr 	WriteDecimalBuffer
.9b7f	e8		inx				inx
.9b80	bd 7b 05	lda $057b,x			lda 	NumberBuffer,x
.9b83	d0 f4		bne $9b79			bne 	_MPTSCopy
.9b85	fa		plx				plx
.9b86	60		rts				rts
.9b87					WriteDecimalBuffer:
.9b87	da		phx				phx
.9b88	ae 15 04	ldx $0415			ldx 	dbOffset
.9b8b	9d 9d 05	sta $059d,x			sta 	DecimalBuffer,x
.9b8e	9e 9e 05	stz $059e,x			stz 	DecimalBuffer+1,x
.9b91	ee 15 04	inc $0415			inc 	dbOffset
.9b94	fa		plx				plx
.9b95	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/substring.asm

.9b96					Unary_Left:
.9b96	fa		plx				plx
.9b97	18		clc				clc 								; only one parameter
.9b98	20 fb 9b	jsr $9bfb			jsr 	SubstringInitial 			; set up.
.9b9b	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; Param #1 is the length
.9b9d	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9b9f	74 59		stz $59,x			stz 	NSMantissa0+1,x 			; Start is zero.
.9ba1	80 25		bra $9bc8			bra 	SubstringMain
.9ba3					Unary_Right:
.9ba3	fa		plx				plx
.9ba4	18		clc				clc 								; only one parameter
.9ba5	20 fb 9b	jsr $9bfb			jsr 	SubstringInitial 			; set up.
.9ba8	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; length => param 2
.9baa	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9bac	b5 78		lda $78,x			lda 	NSExponent,x 				; total length
.9bae	f5 59		sbc $59,x			sbc 	NSMantissa0+1,x 			; length - required.
.9bb0	b0 02		bcs $9bb4			bcs 	_URNotUnderflow
.9bb2	a9 00		lda #$00			lda 	#0 							; start from the beginning, as something like right$("AB",3)
.9bb4					_URNotUnderFlow:
.9bb4	95 59		sta $59,x			sta 	NSMantissa0+1,x 			; this is the start position
.9bb6	80 10		bra $9bc8			bra 	SubStringMain
.9bb8					Unary_Mid:
.9bb8	fa		plx				plx
.9bb9	38		sec				sec 								; two parameters
.9bba	20 fb 9b	jsr $9bfb			jsr 	SubstringInitial 			; set up.
.9bbd	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; first parameter is zero ?
.9bbf	f0 04		beq $9bc5			beq 	_UMError
.9bc1	d6 59		dec $59,x			dec 	NSMantissa0+1,x				; reduce initial offset by 1 as MID$(a$,1..) is actually the first character
.9bc3	80 03		bra $9bc8			bra 	SubStringMain
.9bc5					_UMError:
.9bc5	4c 64 9e	jmp $9e64			jmp 	ArgumentError
.9bc8					SubStringMain:
.9bc8	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; is the initial offset >= the length
.9bca	d5 78		cmp $78,x			cmp 	NSExponent,x
.9bcc	b0 27		bcs $9bf5			bcs 	_SSMNull 					; if so, return an empty string.
.9bce	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; if copy count is zero
.9bd0	f0 23		beq $9bf5			beq 	_SSMNull 					; return empty string.
.9bd2	18		clc				clc 								; add the offset +1 to the address and
.9bd3	b5 58		lda $58,x			lda	 	NSMantissa0,x 				; put in zTemp
.9bd5	75 59		adc $59,x			adc 	NSMantissa0+1,x
.9bd7	85 36		sta $36				sta 	zTemp0
.9bd9	b5 60		lda $60,x			lda	 	NSMantissa1,x
.9bdb	69 00		adc #$00			adc 	#0
.9bdd	85 37		sta $37				sta 	zTemp0+1
.9bdf					_SSMNoCarry:
.9bdf	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; characters required.
.9be1	20 09 a6	jsr $a609			jsr 	StringTempAllocate 			; allocate that many characters
.9be4	5a		phy				phy 								; save Y
.9be5	a0 00		ldy #$00			ldy 	#0 							; start copying in.
.9be7					_SSMCopy:
.9be7	b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next character
.9be9	f0 08		beq $9bf3			beq 	_SSMEString 				; no more to copy
.9beb	20 42 a6	jsr $a642			jsr 	StringTempWrite 			; and write it out.
.9bee	c8		iny				iny
.9bef	d6 5a		dec $5a,x			dec 	NSMantissa0+2,x
.9bf1	d0 f4		bne $9be7			bne 	_SSMCopy
.9bf3					_SSMEString:
.9bf3	7a		ply				ply
.9bf4					_SSMExit:
.9bf4	60		rts				rts
.9bf5					_SSMNull:
.9bf5	a9 00		lda #$00			lda 	#0
.9bf7	20 09 a6	jsr $a609			jsr 	StringTempAllocate
.9bfa	60		rts				rts
.9bfb					SubstringInitial:
.9bfb	da		phx				phx 								; save initial stack position
.9bfc	08		php				php 								; save carry on stack indicating 2 parameters
.9bfd	20 35 9c	jsr $9c35			jsr 	EvaluateString 				; get a string
.9c00	5a		phy				phy 								; calculate length to exponent.
.9c01	a0 ff		ldy #$ff			ldy 	#$FF
.9c03					_SIFindLength:
.9c03	c8		iny				iny
.9c04	b1 36		lda ($36),y			lda 	(zTemp0),y
.9c06	d0 fb		bne $9c03			bne 	_SIFindLength
.9c08	98		tya				tya
.9c09	95 78		sta $78,x			sta 	NSExponent,x
.9c0b	7a		ply				ply
.9c0c	e8		inx				inx
.9c0d	20 bc 8d	jsr $8dbc			jsr 	CheckComma 					; comma next
.9c10	20 78 9c	jsr $9c78			jsr 	Evaluate8BitInteger 		; get next parameter
.9c13	28		plp				plp 								; is it the last parameter ?
.9c14	90 07		bcc $9c1d			bcc 	_SSIExit 					; if so, exit.
.9c16	e8		inx				inx
.9c17	20 bc 8d	jsr $8dbc			jsr 	CheckComma 					; comma next
.9c1a	20 78 9c	jsr $9c78			jsr 	Evaluate8BitInteger 		; get last parameter
.9c1d					_SSIExit:
.9c1d	fa		plx				plx
.9c1e	20 b4 8d	jsr $8db4			jsr 	CheckRightBracket 			; check closing bracket
.9c21	60		rts				rts 								; exit

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/exprhelper.asm

.9c22					EvaluateValue:
.9c22	48		pha				pha
.9c23	20 d1 92	jsr $92d1			jsr		EvaluateExpression 			; expression
.9c26	20 94 95	jsr $9594			jsr 	Dereference					; derefernce it
.9c29	68		pla				pla
.9c2a	60		rts				rts
.9c2b					EvaluateNumber:
.9c2b	20 22 9c	jsr $9c22			jsr 	EvaluateValue 				; get a value
.9c2e	b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.9c30	29 10		and #$10			and 	#NSBIsString
.9c32	d0 13		bne $9c47			bne 	HelperTypeError
.9c34	60		rts				rts
.9c35					EvaluateString:
.9c35	20 22 9c	jsr $9c22			jsr 	EvaluateValue 				; get a value
.9c38	b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.9c3a	29 10		and #$10			and 	#NSBIsString
.9c3c	f0 09		beq $9c47			beq 	HelperTypeError
.9c3e					CopyAddressToTemp0:
.9c3e	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address -> zTemp0
.9c40	85 36		sta $36				sta 	zTemp0 						; (so we can do something with it)
.9c42	b5 60		lda $60,x			lda 	NSMantissa1,x
.9c44	85 37		sta $37				sta 	zTemp0+1
.9c46	60		rts				rts
.9c47					HelperTypeError:
.9c47	4c 5f 9e	jmp $9e5f			jmp 	TypeError
.9c4a					EvaluateInteger:
.9c4a	20 2b 9c	jsr $9c2b			jsr 	EvaluateNumber
.9c4d	b5 78		lda $78,x			lda 	NSExponent,x 				; check exponent is zero
.9c4f	d0 09		bne $9c5a			bne 	HelperValueError 			; if not, it's a float.
.9c51	60		rts				rts
.9c52					EvaluateUnsignedInteger:
.9c52	20 4a 9c	jsr $9c4a			jsr 	EvaluateInteger 			; check integer is +ve
.9c55	b5 50		lda $50,x			lda 	NSStatus,x
.9c57	30 01		bmi $9c5a			bmi 	HelperValueError
.9c59	60		rts				rts
.9c5a					HelperValueError:
.9c5a	4c 64 9e	jmp $9e64			jmp 	ArgumentError
.9c5d						Evaluate16BitInteger:
.9c5d	20 52 9c	jsr $9c52			jsr	 	EvaluateUnsignedInteger		; get integer
.9c60	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9c62	15 68		ora $68,x			ora 	NSMantissa2,x
.9c64	d0 f4		bne $9c5a			bne 	HelperValueError
.9c66	60		rts				rts
.9c67					Evaluate16BitIntegerSigned:
.9c67	20 4a 9c	jsr $9c4a			jsr	 	EvaluateInteger				; get integer
.9c6a	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9c6c	15 68		ora $68,x			ora 	NSMantissa2,x
.9c6e	d0 ea		bne $9c5a			bne 	HelperValueError
.9c70	b5 50		lda $50,x			lda 	NSStatus,x 					; signed ?
.9c72	10 03		bpl $9c77			bpl 	_EISNotSigned
.9c74	20 a6 9c	jsr $9ca6			jsr 	NSMNegateMantissa 			; makes it an actual 2's complement value.
.9c77					_EISNotSigned:
.9c77	60		rts				rts
.9c78					Evaluate8BitInteger:
.9c78	20 52 9c	jsr $9c52			jsr	 	EvaluateUnsignedInteger 	; get an integer
.9c7b	d0 dd		bne $9c5a			bne 	HelperValueError
.9c7d	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 1, 2 & 3 must be zero
.9c7f	15 68		ora $68,x			ora 	NSMantissa2,x
.9c81	15 60		ora $60,x			ora 	NSMantissa1,x
.9c83	d0 d5		bne $9c5a			bne 	HelperValueError
.9c85	b5 58		lda $58,x			lda 	NSMantissa0,x
.9c87	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/mult8x8.asm

.9c88					Multiply8x8:
.9c88	4a		lsr a		  		lsr 	a  							; prime the carry bit for the loop
.9c89	85 36		sta $36			  	sta 	zTemp0
.9c8b	86 37		stx $37				stx 	zTemp0+1
.9c8d	a9 00		lda #$00			lda 	#0
.9c8f	a2 08		ldx #$08			ldx 	#8
.9c91					_M88Loop:
.9c91	90 03		bcc $9c96			bcc 	_M88NoAdd
.9c93	18		clc				clc
.9c94	65 37		adc $37				adc 	zTemp0+1
.9c96					_M88NoAdd:
.9c96	6a		ror a				ror 	a
.9c97	66 36		ror $36				ror 	zTemp0  					; pull another bit out for the next iteration
.9c99	ca		dex				dex         						; inc/dec don't modify carry; only shifts and adds do
.9c9a	d0 f5		bne $9c91			bne 	_M88Loop
.9c9c	85 37		sta $37				sta 	zTemp0+1 					; store high 8 bits.
.9c9e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/utility.asm

.9c9f					NSMNegate:
.9c9f	b5 50		lda $50,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.9ca1	49 80		eor #$80			eor 	#NSBIsNegative  			; toggle the negative flag
.9ca3	95 50		sta $50,x			sta 	NSStatus,x
.9ca5	60		rts				rts
.9ca6					NSMNegateMantissa:
.9ca6	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.9ca7	a9 00		lda #$00			lda 	#0
.9ca9	f5 58		sbc $58,x			sbc 	NSMantissa0,x
.9cab	95 58		sta $58,x			sta 	NSMantissa0,x
.9cad	a9 00		lda #$00			lda 	#0
.9caf	f5 60		sbc $60,x			sbc 	NSMantissa1,x
.9cb1	95 60		sta $60,x			sta 	NSMantissa1,x
.9cb3	a9 00		lda #$00			lda 	#0
.9cb5	f5 68		sbc $68,x			sbc 	NSMantissa2,x
.9cb7	95 68		sta $68,x			sta 	NSMantissa2,x
.9cb9	a9 00		lda #$00			lda 	#0
.9cbb	f5 70		sbc $70,x			sbc 	NSMantissa3,x
.9cbd	95 70		sta $70,x			sta 	NSMantissa3,x
.9cbf	60		rts				rts
.9cc0					NSMShiftUpTwo:
.9cc0	b5 58		lda $58,x			lda 	NSMantissa0,x
.9cc2	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9cc4	b5 60		lda $60,x			lda 	NSMantissa1,x
.9cc6	95 62		sta $62,x			sta 	NSMantissa1+2,x
.9cc8	b5 68		lda $68,x			lda 	NSMantissa2,x
.9cca	95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.9ccc	b5 70		lda $70,x			lda 	NSMantissa3,x
.9cce	95 72		sta $72,x			sta 	NSMantissa3+2,x
.9cd0	b5 78		lda $78,x			lda 	NSExponent,x
.9cd2	95 7a		sta $7a,x			sta 	NSExponent+2,x
.9cd4	b5 50		lda $50,x			lda 	NSStatus,x
.9cd6	95 52		sta $52,x			sta 	NSStatus+2,x
.9cd8	60		rts				rts
.9cd9					NSMSetZeroMantissaOnly:
.9cd9	a9 00		lda #$00			lda 	#0
.9cdb	80 06		bra $9ce3			bra 	NSMSetMantissa
.9cdd					NSMSetZero:
.9cdd	a9 00		lda #$00			lda 	#0
.9cdf					NSMSetByte:
.9cdf	74 78		stz $78,x			stz 	NSExponent,x 				; zero exponent, as integer.
.9ce1	74 50		stz $50,x			stz 	NSStatus,x 					; status zero (integer)
.9ce3					NSMSetMantissa:
.9ce3	95 58		sta $58,x			sta 	NSMantissa0,x 				; mantissa
.9ce5	74 60		stz $60,x			stz 	NSMantissa1,x
.9ce7	74 68		stz $68,x			stz 	NSMantissa2,x
.9ce9	74 70		stz $70,x			stz 	NSMantissa3,x
.9ceb	60		rts				rts
.9cec					NSMShiftLeft:
.9cec	18		clc				clc
.9ced					NSMRotateLeft:
.9ced	36 58		rol $58,x			rol 	NSMantissa0,x
.9cef	36 60		rol $60,x			rol		NSMantissa1,x
.9cf1	36 68		rol $68,x			rol		NSMantissa2,x
.9cf3	36 70		rol $70,x			rol		NSMantissa3,x
.9cf5	60		rts				rts
.9cf6					NSMShiftRight:
.9cf6	56 70		lsr $70,x			lsr 	NSMantissa3,x
.9cf8	76 68		ror $68,x			ror		NSMantissa2,x
.9cfa	76 60		ror $60,x			ror		NSMantissa1,x
.9cfc	76 58		ror $58,x			ror		NSMantissa0,x
.9cfe	60		rts				rts
.9cff					NSMIsZero:
.9cff	b5 70		lda $70,x			lda 	NSMantissa3,x
.9d01	15 68		ora $68,x			ora		NSMantissa2,x
.9d03	15 60		ora $60,x			ora		NSMantissa1,x
.9d05	15 58		ora $58,x			ora		NSMantissa0,x
.9d07	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.asm

.b87e					TickHandler:
.b87e	5a		phy				phy 								; need to preserve Y
.b87f	20 24 b8	jsr $b824			jsr 	SNDUpdate 					; update sound
.b882	7a		ply				ply
.b883	60		rts				rts
.05af					LastTick:
>05af							.fill 		1

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/asmcore.asm

.9d08					Assemble_ora:
.9d08	20 63 80	jsr $8063		jsr	AssembleGroup1
>9d0b	01					.byte $01
.9d0c					Assemble_and:
.9d0c	20 63 80	jsr $8063		jsr	AssembleGroup1
>9d0f	21					.byte $21
.9d10					Assemble_eor:
.9d10	20 63 80	jsr $8063		jsr	AssembleGroup1
>9d13	41					.byte $41
.9d14					Assemble_adc:
.9d14	20 63 80	jsr $8063		jsr	AssembleGroup1
>9d17	61					.byte $61
.9d18					Assemble_sta:
.9d18	20 63 80	jsr $8063		jsr	AssembleGroup1
>9d1b	81					.byte $81
.9d1c					Assemble_lda:
.9d1c	20 63 80	jsr $8063		jsr	AssembleGroup1
>9d1f	a1					.byte $a1
.9d20					Assemble_cmp:
.9d20	20 63 80	jsr $8063		jsr	AssembleGroup1
>9d23	c1					.byte $c1
.9d24					Assemble_sbc:
.9d24	20 63 80	jsr $8063		jsr	AssembleGroup1
>9d27	e1					.byte $e1
.9d28					Assemble_asl:
.9d28	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9d2b	02					.byte $02
>9d2c	75					.byte $75
.9d2d					Assemble_rol:
.9d2d	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9d30	22					.byte $22
>9d31	75					.byte $75
.9d32					Assemble_lsr:
.9d32	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9d35	42					.byte $42
>9d36	75					.byte $75
.9d37					Assemble_ror:
.9d37	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9d3a	62					.byte $62
>9d3b	75					.byte $75
.9d3c					Assemble_stx:
.9d3c	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9d3f	82					.byte $82
>9d40	50					.byte $50
.9d41					Assemble_ldx:
.9d41	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9d44	a2					.byte $a2
>9d45	d0					.byte $d0
.9d46					Assemble_dec:
.9d46	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9d49	c2					.byte $c2
>9d4a	55					.byte $55
.9d4b					Assemble_inc:
.9d4b	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9d4e	e2					.byte $e2
>9d4f	55					.byte $55
.9d50					Assemble_stz:
.9d50	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9d53	60					.byte $60
>9d54	44					.byte $44
.9d55					Assemble_bit:
.9d55	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9d58	20					.byte $20
>9d59	55					.byte $55
.9d5a					Assemble_sty:
.9d5a	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9d5d	80					.byte $80
>9d5e	54					.byte $54
.9d5f					Assemble_ldy:
.9d5f	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9d62	a0					.byte $a0
>9d63	d5					.byte $d5
.9d64					Assemble_cpy:
.9d64	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9d67	c0					.byte $c0
>9d68	d4					.byte $d4
.9d69					Assemble_cpx:
.9d69	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9d6c	e0					.byte $e0
>9d6d	d0					.byte $d0
.9d6e					Assemble_tsb:
.9d6e	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9d71	00					.byte $00
>9d72	50					.byte $50
.9d73					Assemble_trb:
.9d73	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9d76	10					.byte $10
>9d77	50					.byte $50
.9d78					Assemble_jsr:
.9d78	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9d7b	14					.byte $14
>9d7c	10					.byte $10
.9d7d					Assemble_jmp:
.9d7d	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9d80	40					.byte $40
>9d81	10					.byte $10
.9d82					Assemble_bpl:
.9d82	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9d85	10					.byte $10
.9d86					Assemble_bmi:
.9d86	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9d89	30					.byte $30
.9d8a					Assemble_bvc:
.9d8a	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9d8d	50					.byte $50
.9d8e					Assemble_bvs:
.9d8e	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9d91	70					.byte $70
.9d92					Assemble_bcc:
.9d92	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9d95	90					.byte $90
.9d96					Assemble_bcs:
.9d96	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9d99	b0					.byte $b0
.9d9a					Assemble_bne:
.9d9a	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9d9d	d0					.byte $d0
.9d9e					Assemble_beq:
.9d9e	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9da1	f0					.byte $f0
.9da2					Assemble_bra:
.9da2	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9da5	80					.byte $80
.9da6					Assemble_brk:
.9da6	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9da9	00					.byte $00
.9daa					Assemble_php:
.9daa	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9dad	08					.byte $08
.9dae					Assemble_clc:
.9dae	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9db1	18					.byte $18
.9db2					Assemble_plp:
.9db2	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9db5	28					.byte $28
.9db6					Assemble_sec:
.9db6	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9db9	38					.byte $38
.9dba					Assemble_rti:
.9dba	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9dbd	40					.byte $40
.9dbe					Assemble_pha:
.9dbe	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9dc1	48					.byte $48
.9dc2					Assemble_cli:
.9dc2	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9dc5	58					.byte $58
.9dc6					Assemble_phy:
.9dc6	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9dc9	5a					.byte $5a
.9dca					Assemble_rts:
.9dca	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9dcd	60					.byte $60
.9dce					Assemble_pla:
.9dce	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9dd1	68					.byte $68
.9dd2					Assemble_sei:
.9dd2	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9dd5	78					.byte $78
.9dd6					Assemble_ply:
.9dd6	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9dd9	7a					.byte $7a
.9dda					Assemble_dey:
.9dda	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9ddd	88					.byte $88
.9dde					Assemble_txa:
.9dde	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9de1	8a					.byte $8a
.9de2					Assemble_tya:
.9de2	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9de5	98					.byte $98
.9de6					Assemble_txs:
.9de6	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9de9	9a					.byte $9a
.9dea					Assemble_tay:
.9dea	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9ded	a8					.byte $a8
.9dee					Assemble_tax:
.9dee	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9df1	aa					.byte $aa
.9df2					Assemble_clv:
.9df2	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9df5	b8					.byte $b8
.9df6					Assemble_tsx:
.9df6	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9df9	ba					.byte $ba
.9dfa					Assemble_iny:
.9dfa	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9dfd	c8					.byte $c8
.9dfe					Assemble_dex:
.9dfe	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e01	ca					.byte $ca
.9e02					Assemble_cld:
.9e02	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e05	d8					.byte $d8
.9e06					Assemble_phx:
.9e06	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e09	da					.byte $da
.9e0a					Assemble_stp:
.9e0a	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e0d	db					.byte $db
.9e0e					Assemble_inx:
.9e0e	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e11	e8					.byte $e8
.9e12					Assemble_nop:
.9e12	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e15	ea					.byte $ea
.9e16					Assemble_sed:
.9e16	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e19	f8					.byte $f8
.9e1a					Assemble_plx:
.9e1a	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e1d	fa					.byte $fa

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/constants.asm

.9e1e					DecimalScalarTable:
>9e1e	66 66 66 66				.dword $66666666 ; 0.1
>9e22	de					.byte $de
>9e23	1f 85 eb 51				.dword $51eb851f ; 0.01
>9e27	db					.byte $db
>9e28	4c 37 89 41				.dword $4189374c ; 0.001
>9e2c	d8					.byte $d8
>9e2d	ac 8b db 68				.dword $68db8bac ; 0.0001
>9e31	d4					.byte $d4
>9e32	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>9e36	d1					.byte $d1
>9e37	83 de 1b 43				.dword $431bde83 ; 1e-06
>9e3b	ce					.byte $ce
>9e3c	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>9e40	ca					.byte $ca
>9e41	89 3b e6 55				.dword $55e63b89 ; 1e-08
>9e45	c7					.byte $c7
>9e46	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>9e4a	c4					.byte $c4
>9e4b	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>9e4f	c0					.byte $c0
>9e50	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>9e54	bd					.byte $bd

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.asm

.9e55					SyntaxError:
.9e55	a9 02		lda #$02		lda	#2
.9e57	4c cd 8d	jmp $8dcd		jmp	ErrorHandler
.9e5a					RangeError:
.9e5a	a9 04		lda #$04		lda	#4
.9e5c	4c cd 8d	jmp $8dcd		jmp	ErrorHandler
.9e5f					TypeError:
.9e5f	a9 05		lda #$05		lda	#5
.9e61	4c cd 8d	jmp $8dcd		jmp	ErrorHandler
.9e64					ArgumentError:
.9e64	a9 07		lda #$07		lda	#7
.9e66	4c cd 8d	jmp $8dcd		jmp	ErrorHandler
.9e69					NotDoneError:
.9e69	a9 0c		lda #$0c		lda	#12
.9e6b	4c cd 8d	jmp $8dcd		jmp	ErrorHandler
.9e6e					ErrorText:
>9e6e	42 72 65 61 6b 00			.text	"Break",0
>9e74	53 79 6e 74 61 78 20 65			.text	"Syntax error",0
>9e7c	72 72 6f 72 00
>9e81	44 69 76 69 73 69 6f 6e			.text	"Division by zero",0
>9e89	20 62 79 20 7a 65 72 6f 00
>9e92	4f 75 74 20 6f 66 20 52			.text	"Out of Range",0
>9e9a	61 6e 67 65 00
>9e9f	54 79 70 65 20 6d 69 73			.text	"Type mismatch",0
>9ea7	6d 61 74 63 68 00
>9ead	4f 75 74 20 6f 66 20 6d			.text	"Out of memory",0
>9eb5	65 6d 6f 72 79 00
>9ebb	49 6c 6c 65 67 61 6c 20			.text	"Illegal argument",0
>9ec3	61 72 67 75 6d 65 6e 74 00
>9ecc	53 74 6f 70 00				.text	"Stop",0
>9ed1	53 74 72 69 6e 67 20 74			.text	"String too long",0
>9ed9	6f 6f 20 6c 6f 6e 67 00
>9ee1	41 73 73 65 72 74 69 6f			.text	"Assertion failed",0
>9ee9	6e 20 66 61 69 6c 65 64 00
>9ef2	4f 75 74 20 6f 66 20 64			.text	"Out of data",0
>9efa	61 74 61 00
>9efe	55 6e 69 6d 70 6c 65 6d			.text	"Unimplemented",0
>9f06	65 6e 74 65 64 00
>9f0c	4e 6f 20 73 75 63 68 20			.text	"No such line number",0
>9f14	6c 69 6e 65 20 6e 75 6d 62 65 72 00
>9f20	52 65 74 75 72 6e 20 77			.text	"Return without Gosub",0
>9f28	69 74 68 6f 75 74 20 47 6f 73 75 62 00
>9f35	55 6e 74 69 6c 20 77 69			.text	"Until without Repeat",0
>9f3d	74 68 6f 75 74 20 52 65 70 65 61 74 00
>9f4a	57 65 6e 64 20 77 69 74			.text	"Wend without While",0
>9f52	68 6f 75 74 20 57 68 69 6c 65 00
>9f5d	4e 65 78 74 20 77 69 74			.text	"Next without For",0
>9f65	68 6f 75 74 20 46 6f 72 00
>9f6e	42 41 53 49 43 20 53 74			.text	"BASIC Stack full",0
>9f76	61 63 6b 20 66 75 6c 6c 00
>9f7f	4f 70 65 6e 20 53 74 72			.text	"Open Structure",0
>9f87	75 63 74 75 72 65 00
>9f8e	45 6e 64 50 72 6f 63 20			.text	"EndProc without call",0
>9f96	77 69 74 68 6f 75 74 20 63 61 6c 6c 00
>9fa3	41 72 72 61 79 20 61 6c			.text	"Array already defined",0
>9fab	72 65 61 64 79 20 64 65 66 69 6e 65 64 00
>9fb9	41 72 72 61 79 20 73 69			.text	"Array size",0
>9fc1	7a 65 00
>9fc4	42 61 64 20 61 72 72 61			.text	"Bad array index",0
>9fcc	79 20 69 6e 64 65 78 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/timestamp.asm

>9fd4	52 65 6c 65 61 73 65 20			.text "Release Alpha 5 (26-Nov-22). "
>9fdc	41 6c 70 68 61 20 35 20 28 32 36 2d 4e 6f 76 2d
>9fec	32 32 29 2e 20

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcommand.asm

.9ff1					RectangleCommand:
.9ff1	a9 44		lda #$44			lda 	#GCMD_FrameRect				; frame rectangle
.9ff3	80 02		bra $9ff7			bra 	ShapeDrawCmd
.9ff5					CircleCommand:
.9ff5	a9 48		lda #$48			lda 	#GCMD_FrameCircle 				; framed circle
.9ff7					ShapeDrawCmd:
.9ff7	20 81 a0	jsr $a081			jsr 	RunGraphicsCommand
.9ffa					ShapeDraw:
.9ffa	0d b1 05	ora $05b1			ora 	gxFillSolid  				; adjust AXY for solid fill.
.9ffd	4c 75 a0	jmp $a075			jmp 	ExecuteGraphicCommand	 	; and complete
.a000					SpriteCommand:
.a000	a2 00		ldx #$00			ldx 	#0
.a002	20 78 9c	jsr $9c78			jsr 	Evaluate8BitInteger 		; get image number.
.a005	5a		phy				phy
.a006	a9 0e		lda #$0e			lda 	#GCMD_SpriteUse 			; use that image.
.a008	a6 58		ldx $58				ldx 	NSMantissa0
.a00a	e0 40		cpx #$40			cpx 	#64 						; 0-63 only
.a00c	b0 0d		bcs $a01b			bcs 	_SCRange
.a00e	a0 ff		ldy #$ff			ldy 	#255
.a010	20 51 a9	jsr $a951			jsr 	GXGraphicDraw
.a013	a9 52		lda #$52			lda 	#GCMD_SpriteMove
.a015	7a		ply				ply
.a016	20 81 a0	jsr $a081			jsr 	RunGraphicsCommand
.a019	80 5a		bra $a075			bra 	ExecuteGraphicCommand
.a01b					_SCRange:
.a01b	4c 5a 9e	jmp $9e5a			jmp 	RangeError
.a01e					ImageCommand:
.a01e	a2 00		ldx #$00			ldx 	#0
.a020	20 78 9c	jsr $9c78			jsr 	Evaluate8BitInteger 		; get image number.
.a023	20 81 a0	jsr $a081			jsr 	RunGraphicsCommand
.a026					ImageRunDraw:
.a026	09 40		ora #$40			ora 	#GCMD_Move					; move cursor
.a028	20 51 a9	jsr $a951			jsr 	GXGraphicDraw
.a02b	ad b7 05	lda $05b7			lda 	gxDrawScale
.a02e	0a		asl a				asl 	a
.a02f	0a		asl a				asl 	a
.a030	0a		asl a				asl 	a
.a031	a8		tay				tay
.a032	a9 0c		lda #$0c			lda 	#GCMD_DrawSprite 			; image drawing
.a034	a6 58		ldx $58				ldx 	NSMantissa0
.a036	20 51 a9	jsr $a951			jsr 	GXGraphicDraw
.a039	60		rts				rts
.a03a					TextCommand:
.a03a	a2 00		ldx #$00			ldx 	#0
.a03c	20 35 9c	jsr $9c35			jsr 	EvaluateString 				; get text
.a03f	20 81 a0	jsr $a081			jsr 	RunGraphicsCommand
.a042					TextRunDraw:
.a042	09 40		ora #$40			ora 	#GCMD_Move 					; move cursor
.a044	20 51 a9	jsr $a951			jsr 	GXGraphicDraw
.a047	a0 00		ldy #$00			ldy 	#0
.a049					_IRDLoop:
.a049	a5 60		lda $60				lda 	NSMantissa1 				; access character
.a04b	85 37		sta $37				sta 	zTemp0+1
.a04d	a5 58		lda $58				lda 	NSMantissa0
.a04f	85 36		sta $36				sta 	zTemp0
.a051	b1 36		lda ($36),y			lda 	(zTemp0),y
.a053	f0 13		beq $a068			beq 	_IRDExit
.a055	5a		phy				phy									; save string pos
.a056	48		pha				pha 								; save char
.a057	ad b7 05	lda $05b7			lda 	gxDrawScale 				; get scale
.a05a	0a		asl a				asl 	a
.a05b	0a		asl a				asl 	a
.a05c	0a		asl a				asl 	a
.a05d	a8		tay				tay
.a05e	a9 0a		lda #$0a			lda 	#GCMD_DrawFont 				; char drawing
.a060	fa		plx				plx 								; char to draw
.a061	20 51 a9	jsr $a951			jsr 	GXGraphicDraw
.a064	7a		ply				ply 								; restore string pos
.a065	c8		iny				iny
.a066	90 e1		bcc $a049			bcc 	_IRDLoop 					; go back if no error.
.a068					_IRDExit:
.a068	60		rts				rts
.a069					PlotCommand:
.a069	a9 50		lda #$50			lda 	#GCMD_Plot 					; command ID to use
.a06b	20 81 a0	jsr $a081			jsr 	RunGraphicsCommand
.a06e	80 05		bra $a075			bra 	ExecuteGraphicCommand
.a070					LineCommand:
.a070	a9 42		lda #$42			lda 	#GCMD_Line 						; command ID to use
.a072	20 81 a0	jsr $a081			jsr 	RunGraphicsCommand
.a075					ExecuteGraphicCommand:
.a075	0d b0 05	ora $05b0			ora 	gxCommandID 				; make a full command
.a078	20 51 a9	jsr $a951			jsr 	GXGraphicDraw 				; draw it and exit
.a07b	b0 01		bcs $a07e			bcs 	_EGCError
.a07d	60		rts				rts
.a07e					_EGCError:
.a07e	4c 55 9e	jmp $9e55			jmp 	SyntaxError
.a081					RunGraphicsCommand:
.a081	8d b0 05	sta $05b0			sta 	gxCommandID					; save TODO graphics command.
.a084	68		pla				pla 								; pop handler address
.a085	fa		plx				plx
.a086	1a		inc a				inc 	a
.a087	d0 01		bne $a08a			bne 	_RGINoCarry
.a089	e8		inx				inx
.a08a					_RGINoCarry:
.a08a	8d b5 05	sta $05b5			sta 	GXHandler
.a08d	8e b6 05	stx $05b6			stx 	GXHandler+1
.a090					_RGICommandLoop:
.a090	b1 30		lda ($30),y			lda 	(codePtr),y
.a092	c8		iny				iny
.a093	c9 ce		cmp #$ce			cmp 	#KWD_TO						; is it TO x,y
.a095	f0 53		beq $a0ea			beq 	_RGI_To
.a097	c9 ba		cmp #$ba			cmp 	#KWD_HERE 					; do it here.
.a099	f0 55		beq $a0f0			beq 	_RGI_Here
.a09b	c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL or : , exit
.a09d	f0 3d		beq $a0dc			beq 	_RGI_Exit
.a09f	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.a0a1	f0 39		beq $a0dc			beq 	_RGI_Exit
.a0a3	c9 c2		cmp #$c2			cmp 	#KWD_OUTLINE 				; solid or outline
.a0a5	f0 3e		beq $a0e5			beq 	_RGI_Frame
.a0a7	c9 ca		cmp #$ca			cmp 	#KWD_SOLID
.a0a9	f0 33		beq $a0de			beq 	_RGI_Solid
.a0ab	c9 ab		cmp #$ab			cmp 	#KWD_BY 					; by offset
.a0ad	f0 4b		beq $a0fa			beq 	_RGI_By
.a0af	c9 b6		cmp #$b6			cmp 	#KWD_FROM 					; from
.a0b1	f0 17		beq $a0ca			beq 	_RGI_Move2
.a0b3	c9 b3		cmp #$b3			cmp 	#KWD_DIM 					; dim (set scale)
.a0b5	f0 62		beq $a119			beq 	_RGI_Dim
.a0b7	c9 b1		cmp #$b1			cmp 	#KWD_COLOUR 				; colour or Color
.a0b9	f0 74		beq $a12f			beq 	_RGI_Colour
.a0bb	c9 b0		cmp #$b0			cmp 	#KWD_COLOR
.a0bd	f0 70		beq $a12f			beq 	_RGI_Colour
.a0bf	ae b0 05	ldx $05b0			ldx 	gxCommandID
.a0c2	e0 52		cpx #$52			cpx 	#GCMD_SpriteMove 			; if not sprite
.a0c4	d0 03		bne $a0c9			bne 	_RGI_Move 					; move
.a0c6	4c 57 a1	jmp $a157			jmp		_RGI_SpriteInstructions
.a0c9					_RGI_Move:
.a0c9	88		dey				dey 								; unpick get.
.a0ca					_RGI_Move2:
.a0ca	20 7d a1	jsr $a17d			jsr 	GCGetCoordinatePair 		; move to here
.a0cd	20 a4 a1	jsr $a1a4			jsr 	GCCopyPairToStore 			; save
.a0d0	5a		phy				phy
.a0d1	20 9a a1	jsr $a19a			jsr 	GCLoadAXY 					; load in
.a0d4	09 40		ora #$40			ora 	#GCMD_Move 					; move there
.a0d6	20 51 a9	jsr $a951			jsr 	GXGraphicDraw
.a0d9	7a		ply				ply
.a0da	80 b4		bra $a090			bra 	_RGICommandLoop 			; and go round
.a0dc					_RGI_Exit:
.a0dc	88		dey				dey 								; unpick : / EOL
.a0dd	60		rts				rts
.a0de					_RGI_Solid:
.a0de	a9 02		lda #$02			lda 	#2
.a0e0	8d b1 05	sta $05b1			sta 	gxFillSolid
.a0e3	80 ab		bra $a090			bra 	_RGICommandLoop
.a0e5					_RGI_Frame:
.a0e5	9c b1 05	stz $05b1			stz 	gxFillSolid
.a0e8	80 a6		bra $a090			bra 	_RGICommandLoop
.a0ea					_RGI_To:
.a0ea	20 7d a1	jsr $a17d			jsr 	GCGetCoordinatePair 		; get coordinate pair into slot #1,#2
.a0ed	20 a4 a1	jsr $a1a4			jsr 	GCCopyPairToStore
.a0f0					_RGI_Here:
.a0f0	5a		phy				phy
.a0f1	20 9a a1	jsr $a19a			jsr 	GCLoadAXY 					; load it into AXY
.a0f4	20 54 a1	jsr $a154			jsr 	_RGICallHandler 			; go do whatever it is.
.a0f7	7a		ply				ply
.a0f8	80 96		bra $a090			bra 	_RGICommandLoop 			; and go round
.a0fa					_RGI_By:
.a0fa	20 8a a1	jsr $a18a			jsr 	GCSignedCoordinatePair 		; get coordinate pair into slot #1,#2
.a0fd	18		clc				clc
.a0fe	a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.a100	6d b2 05	adc $05b2			adc 	gxxPos
.a103	8d b2 05	sta $05b2			sta 	gxXPos
.a106	a5 61		lda $61				lda 	NSMantissa1+1
.a108	6d b3 05	adc $05b3			adc 	gxxPos+1
.a10b	8d b3 05	sta $05b3			sta 	gxXPos+1
.a10e	a5 5a		lda $5a				lda 	NSMantissa0+2
.a110	18		clc				clc
.a111	6d b4 05	adc $05b4			adc 	gxYPos
.a114	8d b4 05	sta $05b4			sta 	gxYPos
.a117	80 d7		bra $a0f0			bra 	_RGI_Here
.a119					_RGI_Dim:
.a119	a2 01		ldx #$01			ldx	 	#1
.a11b	20 78 9c	jsr $9c78			jsr 	Evaluate8BitInteger
.a11e	a5 59		lda $59				lda 	NSMantissa0+1
.a120	c9 00		cmp #$00			cmp 	#0
.a122	f0 2d		beq $a151			beq 	_RGIRange
.a124	c9 09		cmp #$09			cmp 	#8+1
.a126	b0 29		bcs $a151			bcs		_RGIRange
.a128	3a		dec a				dec 	a
.a129	8d b7 05	sta $05b7			sta 	gxDrawScale
.a12c	4c 90 a0	jmp $a090			jmp 	_RGICommandLoop
.a12f					_RGI_Colour:
.a12f	a2 01		ldx #$01			ldx 	#1 							; colour
.a131	20 78 9c	jsr $9c78			jsr 	Evaluate8BitInteger
.a134	a2 02		ldx #$02			ldx 	#2 							; default zero for 2nd parameter
.a136	20 dd 9c	jsr $9cdd			jsr 	NSMSetZero
.a139	b1 30		lda ($30),y			lda 	(codePtr),y
.a13b	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; check , => mode.
.a13d	d0 04		bne $a143			bne 	_RGICDefaultMode
.a13f	c8		iny				iny
.a140	20 78 9c	jsr $9c78			jsr 	Evaluate8BitInteger
.a143					_RGICDefaultMode:
.a143	5a		phy				phy
.a144	a9 08		lda #$08			lda 	#GCMD_Colour 				; set colour.
.a146	a6 59		ldx $59				ldx 	NSMantissa0+1
.a148	a4 5a		ldy $5a				ldy 	NSMantissa0+2
.a14a	20 51 a9	jsr $a951			jsr 	GXGraphicDraw
.a14d	7a		ply				ply
.a14e	4c 90 a0	jmp $a090			jmp 	_RGICommandLoop 			; and go round
.a151					_RGIRange:
.a151	4c 5a 9e	jmp $9e5a			jmp 	RangeError
.a154					_RGICallHandler:
.a154	6c b5 05	jmp ($05b5)			jmp 	(GXHandler)
.a157					_RGI_SpriteInstructions:
.a157	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a159	f0 07		beq $a162			beq 	_RGISpriteOff
.a15b	c9 bb		cmp #$bb			cmp 	#KWD_IMAGE
.a15d	f0 13		beq $a172			beq 	_RGISetImage
.a15f	4c c9 a0	jmp $a0c9			jmp 	_RGI_Move
.a162					_RGISpriteOff:
.a162	5a		phy				phy
.a163	a0 01		ldy #$01			ldy 	#1
.a165	a2 00		ldx #$00			ldx 	#0
.a167					_RGIDoCommandLoop:
.a167	a9 10		lda #$10			lda 	#GCMD_SpriteImage
.a169	20 51 a9	jsr $a951			jsr 	GXGraphicDraw
.a16c	7a		ply				ply
.a16d	b0 e2		bcs $a151			bcs 	_RGIRange
.a16f	4c 90 a0	jmp $a090			jmp 	_RGICommandLoop
.a172					_RGISetImage:
.a172	a2 01		ldx #$01			ldx 	#1
.a174	20 78 9c	jsr $9c78			jsr 	Evaluate8BitInteger
.a177	5a		phy				phy
.a178	aa		tax				tax
.a179	a0 00		ldy #$00			ldy 	#0
.a17b	80 ea		bra $a167			bra 	_RGIDoCommandLoop
.a17d					GCGetCoordinatePair:
.a17d	a2 01		ldx #$01			ldx 	#1
.a17f	20 5d 9c	jsr $9c5d			jsr 	Evaluate16BitInteger
.a182	20 bc 8d	jsr $8dbc			jsr 	CheckComma
.a185	e8		inx				inx
.a186	20 5d 9c	jsr $9c5d			jsr 	Evaluate16BitInteger
.a189	60		rts				rts
.a18a					GCSignedCoordinatePair:
.a18a	a2 01		ldx #$01			ldx 	#1
.a18c	20 67 9c	jsr $9c67			jsr 	Evaluate16BitIntegerSigned
.a18f	20 bc 8d	jsr $8dbc			jsr 	CheckComma
.a192	e8		inx				inx
.a193	20 67 9c	jsr $9c67			jsr 	Evaluate16BitIntegerSigned
.a196	60		rts				rts
.a197					_GCCPRange:
.a197	4c 5a 9e	jmp $9e5a			jmp 	RangeError
.a19a					GCLoadAXY:
.a19a	ad b3 05	lda $05b3			lda 	gxXPos+1
.a19d	ae b2 05	ldx $05b2			ldx 	gxXPos
.a1a0	ac b4 05	ldy $05b4			ldy 	gxYPos
.a1a3	60		rts				rts
.a1a4					GCCopyPairToStore:
.a1a4	a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.a1a6	8d b2 05	sta $05b2			sta 	gxXPos
.a1a9	a5 61		lda $61				lda 	NSMantissa1+1
.a1ab	8d b3 05	sta $05b3			sta 	gxXPos+1
.a1ae	a5 5a		lda $5a				lda 	NSMantissa0+2
.a1b0	8d b4 05	sta $05b4			sta 	gxYPos
.a1b3	60		rts				rts
.05b0					gxCommandID:
>05b0							.fill 	1
.05b1					gxFillSolid:
>05b1							.fill 	1
.05b2					gxXPos:
>05b2							.fill 	2
.05b4					gxYPos:
>05b4							.fill 	1
.05b5					gxHandler:
>05b5							.fill 	2
.05b7					gxDrawScale:
>05b7							.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcontrol.asm

.a1b4					BitmapCtrl:
.a1b4	b1 30		lda ($30),y			lda 	(codePtr),y
.a1b6	c8		iny				iny
.a1b7	a2 01		ldx #$01			ldx 	#1
.a1b9	c9 c1		cmp #$c1			cmp 	#KWD_ON
.a1bb	f0 11		beq $a1ce			beq 	BitmapSwitch
.a1bd	ca		dex				dex
.a1be	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a1c0	f0 0c		beq $a1ce			beq 	BitmapSwitch
.a1c2	20 78 9c	jsr $9c78			jsr 	Evaluate8BitInteger 		; get the colour
.a1c5	5a		phy				phy
.a1c6	aa		tax				tax
.a1c7	a9 06		lda #$06			lda 	#GCMD_Clear					; clear to that colour
.a1c9	20 51 a9	jsr $a951			jsr 	GXGraphicDraw
.a1cc	7a		ply				ply
.a1cd	60		rts				rts
.a1ce					BitmapSwitch:
.a1ce	5a		phy				phy
.a1cf	a0 00		ldy #$00			ldy 	#0 							; gfx 1,on/off,0
.a1d1	a9 02		lda #$02			lda 	#GCMD_BitmapCtl
.a1d3	20 51 a9	jsr $a951			jsr 	GXGraphicDraw
.a1d6	a9 08		lda #$08			lda 	#GCMD_Colour				; set colour to $FF
.a1d8	a0 00		ldy #$00			ldy 	#0
.a1da	a2 ff		ldx #$ff			ldx 	#$FF
.a1dc	20 51 a9	jsr $a951			jsr 	GXGraphicDraw
.a1df	9c b1 05	stz $05b1			stz 	gxFillSolid
.a1e2	9c b2 05	stz $05b2			stz 	gxXPos
.a1e5	9c b3 05	stz $05b3			stz 	gxXPos+1
.a1e8	9c b4 05	stz $05b4			stz 	gxYPos
.a1eb	9c b7 05	stz $05b7			stz 	gxDrawScale
.a1ee	a9 40		lda #$40			lda 	#GCMD_Move 						; home cursor
.a1f0	a2 00		ldx #$00			ldx 	#0
.a1f2	a0 00		ldy #$00			ldy 	#0
.a1f4	20 51 a9	jsr $a951			jsr 	GXGraphicDraw
.a1f7	7a		ply				ply
.a1f8	60		rts				rts
.a1f9					SpritesCtrl:
.a1f9	b1 30		lda ($30),y			lda 	(codePtr),y
.a1fb	c8		iny				iny
.a1fc	a2 01		ldx #$01			ldx 	#1
.a1fe	c9 c1		cmp #$c1			cmp 	#KWD_ON
.a200	f0 08		beq $a20a			beq 	SpriteSwitch
.a202	ca		dex				dex
.a203	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a205	f0 03		beq $a20a			beq 	SpriteSwitch
.a207	4c 55 9e	jmp $9e55			jmp 	SyntaxError
.a20a					SpriteSwitch:
.a20a	5a		phy				phy
.a20b	a0 00		ldy #$00			ldy 	#0 							; gfx 2,on/off,0
.a20d	a9 04		lda #$04			lda 	#GCMD_SpriteCtl
.a20f	20 51 a9	jsr $a951			jsr 	GXGraphicDraw
.a212	7a		ply				ply
.a213	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gfx.asm

.a214					GfxCommand:
.a214	a2 00		ldx #$00			ldx 	#0
.a216	20 78 9c	jsr $9c78			jsr 	Evaluate8BitInteger 		; command
.a219	20 bc 8d	jsr $8dbc			jsr 	CheckComma
.a21c	e8		inx				inx
.a21d	20 5d 9c	jsr $9c5d			jsr 	Evaluate16BitInteger 		; X
.a220	20 bc 8d	jsr $8dbc			jsr 	CheckComma
.a223	e8		inx				inx
.a224	20 78 9c	jsr $9c78			jsr 	Evaluate8BitInteger 		; Y
.a227	a5 61		lda $61				lda 	NSMantissa1+1  				; shift bit 0 of X into CS, should now be zero
.a229	4a		lsr a				lsr 	a
.a22a	d0 12		bne $a23e			bne 	_GfxError
.a22c	26 58		rol $58				rol 	NSMantissa0 				; rotate into command
.a22e	b0 0e		bcs $a23e			bcs 	_GfxError 					; bit 7 should have been zero
.a230	5a		phy				phy 								; save pos
.a231	a5 58		lda $58				lda 	NSMantissa0 				; do the command
.a233	a6 59		ldx $59				ldx 	NSMantissa0+1
.a235	a4 5a		ldy $5a				ldy 	NSMantissa0+2
.a237	20 51 a9	jsr $a951			jsr 	GXGraphicDraw
.a23a	b0 02		bcs $a23e			bcs 	_GfxError
.a23c	7a		ply				ply 								; restore pos and exit.
.a23d	60		rts				rts
.a23e					_GfxError:
.a23e	4c 5a 9e	jmp $9e5a			jmp 	RangeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/hit.asm

.a241					UnaryHit:
.a241	fa		plx				plx
.a242	a9 36		lda #$36			lda 	#zTemp0
.a244	20 78 9c	jsr $9c78			jsr 	Evaluate8BitInteger 		; get sprite number 0
.a247	20 bc 8d	jsr $8dbc			jsr 	CheckComma
.a24a	e8		inx				inx
.a24b	20 78 9c	jsr $9c78			jsr 	Evaluate8BitInteger 		; get sprite number 1
.a24e	20 b4 8d	jsr $8db4			jsr		CheckRightBracket
.a251	ca		dex				dex 								; fix back up again.
.a252	da		phx				phx 								; save X/Y
.a253	5a		phy				phy
.a254	b4 59		ldy $59,x			ldy 	NSMantissa0+1,x 			; get the sprite numbers into X/Y
.a256	b5 58		lda $58,x			lda 	NSMantissa0,x
.a258	aa		tax				tax
.a259	a9 12		lda #$12			lda 	#GCMD_SpriteCollide 		; command check collision.
.a25b	20 51 a9	jsr $a951			jsr 	GXGraphicDraw 				; calculate result
.a25e	1a		inc a				inc 	a 							; so 255 (fail) -> 0, otherwise 1,2,3,4 pixels etc.
.a25f	7a		ply				ply 								; restore XY
.a260	fa		plx				plx
.a261	20 df 9c	jsr $9cdf			jsr 	NSMSetByte 					; return the hit result
.a264	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/palette.asm

.a265					PaletteCommand:
.a265	a2 00		ldx #$00			ldx 	#0
.a267	20 78 9c	jsr $9c78			jsr 	Evaluate8BitInteger 		; colour
.a26a	20 bc 8d	jsr $8dbc			jsr 	CheckComma
.a26d	e8		inx				inx
.a26e	20 5d 9c	jsr $9c5d			jsr 	Evaluate16BitInteger 		; r
.a271	20 bc 8d	jsr $8dbc			jsr 	CheckComma
.a274	e8		inx				inx
.a275	20 78 9c	jsr $9c78			jsr 	Evaluate8BitInteger 		; g
.a278	20 bc 8d	jsr $8dbc			jsr 	CheckComma
.a27b	e8		inx				inx
.a27c	20 78 9c	jsr $9c78			jsr 	Evaluate8BitInteger 		; b
.a27f	a5 58		lda $58				lda 	NSMantissa0 				; get colour #
.a281	85 36		sta $36				sta 	zTemp0
.a283	a9 34		lda #$34			lda 	#$D0 >> 2 					; MSB = D0/4
.a285	85 37		sta $37				sta 	zTemp0+1
.a287	06 36		asl $36				asl 	zTemp0 						; zTemp = $D000+Colour x 4
.a289	26 37		rol $37				rol	 	zTemp0+1
.a28b	06 36		asl $36				asl 	zTemp0
.a28d	26 37		rol $37				rol	 	zTemp0+1
.a28f	a9 01		lda #$01			lda 	#1 							; I/O Page 2
.a291	85 01		sta $01				sta 	1
.a293	5a		phy				phy
.a294	a5 5b		lda $5b				lda 	NSMantissa0+3 				; fix to r,g,b
.a296	92 36		sta ($36)			sta 	(zTemp0)
.a298	a0 01		ldy #$01			ldy 	#1
.a29a	a5 5a		lda $5a				lda 	NSMantissa0+2
.a29c	91 36		sta ($36),y			sta 	(zTemp0),y
.a29e	a5 59		lda $59				lda 	NSMantissa0+1
.a2a0	c8		iny				iny
.a2a1	91 36		sta ($36),y			sta 	(zTemp0),y
.a2a3	7a		ply				ply
.a2a4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/event.asm

.a2a5					UnaryEvent:
.a2a5	fa		plx				plx
.a2a6	20 53 a3	jsr $a353			jsr 	TimerToStackX 				; timer in +0
.a2a9	e8		inx				inx  								; put reference into +1
.a2aa	20 1b 97	jsr $971b			jsr 	EvaluateTerm
.a2ad	b5 50		lda $50,x			lda 	NSStatus,x 					; check if is integer reference
.a2af	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.a2b1	d0 4c		bne $a2ff			bne 	_UEType
.a2b3	e8		inx				inx 								; put the step in +2
.a2b4	20 bc 8d	jsr $8dbc			jsr 	CheckComma
.a2b7	20 5d 9c	jsr $9c5d			jsr 	Evaluate16BitInteger
.a2ba	20 b4 8d	jsr $8db4			jsr 	CheckRightBracket
.a2bd	ca		dex				dex
.a2be	ca		dex				dex
.a2bf	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy reference to zTemp0
.a2c1	85 36		sta $36				sta 	zTemp0
.a2c3	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.a2c5	85 37		sta $37				sta 	zTemp0+1
.a2c7	5a		phy				phy
.a2c8	a0 03		ldy #$03			ldy 	#3 							; check bit 7 of last bit, the packed sign bit
.a2ca	b1 36		lda ($36),y			lda 	(zTemp0),y
.a2cc	30 2d		bmi $a2fb			bmi 	_UEFalse 					; exit if signed.
.a2ce	a0 00		ldy #$00			ldy 	#0 							; has it timed out (24 bit)
.a2d0	b5 58		lda $58,x			lda 	NSMantissa0,x
.a2d2	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.a2d4	c8		iny				iny
.a2d5	b5 60		lda $60,x			lda 	NSMantissa1,x
.a2d7	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a2d9	c8		iny				iny
.a2da	b5 68		lda $68,x			lda 	NSMantissa2,x
.a2dc	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a2de	90 1b		bcc $a2fb			bcc 	_UEFalse 					; no, return FALSE.
.a2e0	18		clc				clc
.a2e1	a0 00		ldy #$00			ldy 	#0 							; work out new value as timer() + step
.a2e3	b5 58		lda $58,x			lda 	NSMantissa0,x
.a2e5	75 5a		adc $5a,x			adc 	NSMantissa0+2,x
.a2e7	91 36		sta ($36),y			sta 	(zTemp0),y
.a2e9	c8		iny				iny
.a2ea	b5 60		lda $60,x			lda 	NSMantissa1,x
.a2ec	75 62		adc $62,x			adc 	NSMantissa1+2,x
.a2ee	91 36		sta ($36),y			sta 	(zTemp0),y
.a2f0	c8		iny				iny
.a2f1	b5 68		lda $68,x			lda 	NSMantissa2,x
.a2f3	75 6a		adc $6a,x			adc 	NSMantissa2+2,x
.a2f5	91 36		sta ($36),y			sta 	(zTemp0),y
.a2f7	7a		ply				ply
.a2f8	4c 3a 8e	jmp $8e3a			jmp 	ReturnTrue
.a2fb					_UEFalse:
.a2fb	7a		ply				ply 								; restore Y
.a2fc	4c 45 8e	jmp $8e45			jmp 	ReturnFalse 				; and return False
.a2ff					_UEType:
.a2ff	4c 5f 9e	jmp $9e5f			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/joy.asm

.a302					UnaryJoyX:
.a302	18		clc				clc
.a303	80 01		bra $a306			bra 	JoyMain
.a305					UnaryJoyY:
.a305	38		sec				sec
.a306					JoyMain:
.a306	fa		plx				plx 								; get pos
.a307	08		php				php 								; save carry (set for Y)
.a308	20 78 9c	jsr $9c78			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a30b	20 b4 8d	jsr $8db4			jsr 	CheckRightBracket
.a30e	20 0a a9	jsr $a90a			jsr 	EXTReadController 			; read the controller.
.a311	28		plp				plp
.a312	90 02		bcc $a316			bcc 	_JMNoShift 					; if Y then shift bits 3,2 -> 1,0
.a314	4a		lsr a				lsr 	a
.a315	4a		lsr a				lsr 	a
.a316					_JMNoShift:
.a316	4a		lsr a				lsr 	a 							; if bit 0 set then right/down e.g. +1
.a317	b0 0a		bcs $a323			bcs 	_JMIsRight
.a319	4a		lsr a				lsr 	a 							; if bit 1 set then left/up e.g. -1
.a31a	b0 04		bcs $a320			bcs 	_JMIsLeft
.a31c	20 dd 9c	jsr $9cdd			jsr 	NSMSetZero 					; zero result
.a31f	60		rts				rts
.a320					_JMIsLeft:
.a320	4c 3a 8e	jmp $8e3a			jmp 	ReturnTrue
.a323					_JMIsRight:
.a323	a9 01		lda #$01			lda 	#1
.a325	20 df 9c	jsr $9cdf			jsr 	NSMSetByte
.a328	60		rts				rts
.a329					UnaryJoyB:
.a329	fa		plx				plx 								; get pos
.a32a	20 78 9c	jsr $9c78			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a32d	20 b4 8d	jsr $8db4			jsr 	CheckRightBracket
.a330	20 0a a9	jsr $a90a			jsr 	EXTReadController 			; read the controller.
.a333	4a		lsr a				lsr 	a
.a334	4a		lsr a				lsr 	a
.a335	4a		lsr a				lsr 	a
.a336	4a		lsr a				lsr 	a
.a337	29 01		and #$01			and 	#1
.a339	20 df 9c	jsr $9cdf			jsr 	NSMSetByte
.a33c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/load.asm

.a33d					LoadCommand:
.a33d	20 21 89	jsr $8921			jsr 	NewProgram
.a340	20 d2 82	jsr $82d2			jsr 	BackLoadProgram
.a343	4c 62 83	jmp $8362			jmp 	WarmStart
.a346					GoCommand:
.a346	20 21 89	jsr $8921			jsr 	NewProgram
.a349	20 d2 82	jsr $82d2			jsr 	BackLoadProgram
.a34c	4c 5d 8a	jmp $8a5d			jmp 	CommandRun

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/timer.asm

.a34f					UnaryTimer:
.a34f	fa		plx				plx
.a350	20 b4 8d	jsr $8db4			jsr 	CheckRightBracket
.a353					TimerToStackX:
.a353	20 dd 9c	jsr $9cdd			jsr 	NSMSetZero 					; zero result
.a356	64 01		stz $01				stz 	1 							; access I/O
.a358	ad 59 d6	lda $d659			lda 	$D659 						; copy timer in
.a35b	95 58		sta $58,x			sta 	NSMantissa0,x
.a35d	ad 5a d6	lda $d65a			lda 	$D65A
.a360	95 60		sta $60,x			sta 	NSMantissa1,x
.a362	ad 5b d6	lda $d65b			lda 	$D65B
.a365	95 68		sta $68,x			sta 	NSMantissa2,x
.a367	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/delete.asm

.a368					MemoryDeleteLine:
.a368	20 87 a3	jsr $a387			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a36b	b2 30		lda ($30)			lda 	(codePtr) 					; size to delete => y
.a36d	a8		tay				tay
.a36e					_MDDLLoop:
.a36e	b1 30		lda ($30),y			lda 	(codePtr),y 				; copy down
.a370	92 30		sta ($30)			sta 	(codePtr)
.a372	a5 30		lda $30				lda 	codePtr 					; check done the lot.
.a374	c5 3a		cmp $3a				cmp 	zTemp2
.a376	d0 07		bne $a37f			bne 	_MDLDLNext
.a378	a5 31		lda $31				lda 	codePtr+1
.a37a	c5 3b		cmp $3b				cmp 	zTemp2+1
.a37c	d0 01		bne $a37f			bne 	_MDLDLNext
.a37e					_MDDLExit:
.a37e	60		rts				rts
.a37f					_MDLDLNext:
.a37f	e6 30		inc $30				inc 	codePtr						; next byte
.a381	d0 eb		bne $a36e			bne 	_MDDLLoop
.a383	e6 31		inc $31				inc 	codePtr+1
.a385	80 e7		bra $a36e			bra 	_MDDLLoop
.a387					IMemoryFindEnd:
.a387	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a389	85 3a		sta $3a				sta 	0+zTemp2
.a38b	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a38d	85 3b		sta $3b				sta 	1+zTemp2
.a38f					_MDLFELoop:
.a38f	b2 3a		lda ($3a)			lda 	(zTemp2)
.a391	f0 0b		beq $a39e			beq 	_MDLFEExit
.a393	18		clc				clc
.a394	65 3a		adc $3a				adc 	zTemp2
.a396	85 3a		sta $3a				sta 	zTemp2
.a398	90 f5		bcc $a38f			bcc 	_MDLFELoop
.a39a	e6 3b		inc $3b				inc 	zTemp2+1
.a39c	80 f1		bra $a38f			bra 	_MDLFELoop
.a39e					_MDLFEExit:
.a39e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/insert.asm

.a39f					MemoryInsertLine:
.a39f	08		php				php
.a3a0	20 87 a3	jsr $a387			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a3a3	a5 3b		lda $3b				lda 	zTemp2+1 					; space ?
.a3a5	1a		inc a				inc 	a
.a3a6	c9 7f		cmp #$7f			cmp 	#(BasicEnd >> 8)-1
.a3a8	b0 36		bcs $a3e0			bcs 	_MDLIError
.a3aa	28		plp				plp
.a3ab	90 08		bcc $a3b5			bcc 	_MDLIFound
.a3ad	a5 3a		lda $3a				lda 	zTemp2 						; if CS on entry append.
.a3af	85 30		sta $30				sta 	codePtr
.a3b1	a5 3b		lda $3b				lda 	zTemp2+1
.a3b3	85 31		sta $31				sta 	codePtr+1
.a3b5					_MDLIFound:
.a3b5	ad 2a 04	lda $042a			lda 	tokenOffset 				; insert gap in Y, the offset, e.g. length of the new line
.a3b8	a8		tay				tay
.a3b9					_MDLIInsert:
.a3b9	b2 3a		lda ($3a)			lda 	(zTemp2) 					; shift one byte up , at least one covers end case.
.a3bb	91 3a		sta ($3a),y			sta 	(zTemp2),y 					; work from top down.
.a3bd	a5 30		lda $30				lda 	codePtr 					; done insert point ?
.a3bf	c5 3a		cmp $3a				cmp 	zTemp2
.a3c1	d0 06		bne $a3c9			bne 	_MDLINext
.a3c3	a5 31		lda $31				lda 	codePtr+1
.a3c5	c5 3b		cmp $3b				cmp 	zTemp2+1
.a3c7	f0 0a		beq $a3d3			beq 	_MDLIHaveSpace
.a3c9					_MDLINext:
.a3c9	a5 3a		lda $3a				lda 	zTemp2 						; if no, keep zTemp2 going backwards
.a3cb	d0 02		bne $a3cf			bne 	_MDLINoBorrow
.a3cd	c6 3b		dec $3b				dec 	zTemp2+1
.a3cf					_MDLINoBorrow:
.a3cf	c6 3a		dec $3a				dec 	zTemp2
.a3d1	80 e6		bra $a3b9			bra 	_MDLIInsert
.a3d3					_MDLIHaveSpace:
.a3d3	ac 2a 04	ldy $042a			ldy 	tokenOffset 				; bytes to copy
.a3d6	88		dey				dey 								; from offset-1 to 0
.a3d7					_MDLICopy:
.a3d7	b9 2a 04	lda $042a,y			lda 	tokenOffset,y
.a3da	91 30		sta ($30),y			sta 	(codePtr),y
.a3dc	88		dey				dey
.a3dd	10 f8		bpl $a3d7			bpl 	_MDLICopy
.a3df	60		rts				rts
.a3e0					_MDLIError:
.a3e0	a9 06		lda #$06		lda	#6
.a3e2	4c cd 8d	jmp $8dcd		jmp	ErrorHandler
.a3e5					MDLAppendLine:
.a3e5	86 37		stx $37				stx 	zTemp0+1 					; save new line at zTemp0
.a3e7	85 36		sta $36				sta 	zTemp0
.a3e9	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a3eb	85 38		sta $38				sta 	0+zTemp1
.a3ed	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a3ef	85 39		sta $39				sta 	1+zTemp1
.a3f1	b2 38		lda ($38)			lda 	(zTemp1)
.a3f3	d0 0a		bne $a3ff			bne 	_MDLANoInitialise
.a3f5	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a3f7	8d b8 05	sta $05b8			sta 	0+AppendPointer
.a3fa	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a3fc	8d b9 05	sta $05b9			sta 	1+AppendPointer
.a3ff					_MDLANoInitialise:
.a3ff	18		clc				clc
.a400	ad b8 05	lda $05b8			lda 	AppendPointer 				; copy append pointer to zTemp1 adding the offset as you go
.a403	85 38		sta $38				sta 	zTemp1
.a405	72 36		adc ($36)			adc 	(zTemp0)
.a407	8d b8 05	sta $05b8			sta 	AppendPointer
.a40a	ad b9 05	lda $05b9			lda 	AppendPointer+1
.a40d	85 39		sta $39				sta 	zTemp1+1
.a40f	69 00		adc #$00			adc 	#0
.a411	8d b9 05	sta $05b9			sta 	AppendPointer+1
.a414	a0 00		ldy #$00			ldy 	#0
.a416					_MDLACopy:
.a416	b1 36		lda ($36),y			lda 	(zTemp0),y 					; copy new line in
.a418	91 38		sta ($38),y			sta 	(zTemp1),y
.a41a	c8		iny				iny
.a41b	98		tya				tya
.a41c	d2 36		cmp ($36)			cmp 	(zTemp0) 					; done whole line
.a41e	d0 f6		bne $a416			bne 	_MDLACopy
.a420	a9 00		lda #$00			lda 	#0 							; end of program.
.a422	91 38		sta ($38),y			sta 	(zTemp1),y
.a424	60		rts				rts
.05b8					AppendPointer:
>05b8							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/memory.asm

.a425					MemoryNew:
.a425	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a427	85 30		sta $30				sta 	codePtr
.a429	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a42b	85 31		sta $31				sta 	codePtr+1
.a42d	a9 00		lda #$00			lda 	#0 							; write zero there erasing the program.
.a42f	92 30		sta ($30)			sta 	(codePtr)
.a431	60		rts				rts
.a432					MemoryInline:
.a432	98		tya				tya 								; put address into stack,x
.a433	18		clc				clc  								; get the offset, add codePtr
.a434	65 30		adc $30				adc 	codePtr
.a436	95 58		sta $58,x			sta 	NSMantissa0,x 				; store the result in the mantissa.
.a438	a5 31		lda $31				lda 	codePtr+1
.a43a	69 00		adc #$00			adc 	#0
.a43c	95 60		sta $60,x			sta 	NSMantissa1,x
.a43e	74 68		stz $68,x			stz 	NSMantissa2,x
.a440	74 70		stz $70,x			stz 	NSMantissa3,x
.a442	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/search.asm

.a443					MemorySearch:
.a443	85 36		sta $36				sta 	zTemp0 						; save line number in zTemp0
.a445	86 37		stx $37				stx 	zTemp0+1
.a447	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a449	85 30		sta $30				sta 	codePtr
.a44b	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a44d	85 31		sta $31				sta 	codePtr+1
.a44f					_MTAXLoop:
.a44f	b2 30		lda ($30)			lda 	(codePtr)
.a451	18		clc				clc
.a452	f0 21		beq $a475			beq 	_MTAXExit 					; reached end, exit with CC.
.a454	a0 01		ldy #$01			ldy 	#1 							; calculate current line# - requested line#
.a456	b1 30		lda ($30),y			lda 	(codePtr),y
.a458	38		sec				sec
.a459	e5 36		sbc $36				sbc 	zTemp0
.a45b	85 38		sta $38				sta 	zTemp1 						; save interim to set Z
.a45d	c8		iny				iny 								; do the MSB
.a45e	b1 30		lda ($30),y			lda 	(codePtr),y
.a460	e5 37		sbc $37				sbc 	zTemp0+1
.a462	05 38		ora $38				ora 	zTemp1 						; will set Z if result is zero, doesn't affect carry flag
.a464	f0 0f		beq $a475			beq 	_MTAXExit	 				; found so exit (CS will be set)
.a466	b0 0d		bcs $a475			bcs 	_MTAXExit 					; current < required exit
.a468	18		clc				clc
.a469	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.a46b	65 30		adc $30				adc 	codePtr
.a46d	85 30		sta $30				sta 	codePtr
.a46f	90 02		bcc $a473			bcc 	_CREExit
.a471	e6 31		inc $31				inc 	codePtr+1 					; carry
.a473					_CREExit:
.a473	80 da		bra $a44f			bra 	_MTAXLoop
.a475					_MTAXExit:
.a475	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/playing.asm

.a476					UnaryPlaying:
.a476	fa		plx				plx
.a477	20 78 9c	jsr $9c78			jsr 	Evaluate8BitInteger 		; get channel #
.a47a	48		pha				pha
.a47b	20 b4 8d	jsr $8db4			jsr		CheckRightBracket
.a47e	68		pla				pla
.a47f	c9 04		cmp #$04			cmp 	#4
.a481	b0 0c		bcs $a48f			bcs 	_UPNotPlaying
.a483	09 20		ora #$20			ora 	#$20 						; query playing ?
.a485	20 f1 b7	jsr $b7f1			jsr 	SNDCommand
.a488	c9 00		cmp #$00			cmp 	#0
.a48a	f0 03		beq $a48f			beq 	_UPNotPlaying
.a48c	4c 3a 8e	jmp $8e3a			jmp 	ReturnTrue
.a48f					_UPNotPlaying:
.a48f	4c 45 8e	jmp $8e45			jmp 	ReturnFalse

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/sound.asm

.a492					SoundCommand:
.a492	b1 30		lda ($30),y			lda 	(codePtr),y
.a494	c9 c0		cmp #$c0			cmp 	#KWD_OFF 					; SOUND OFF ?
.a496	d0 09		bne $a4a1			bne 	_SNDMain
.a498	c8		iny				iny 								; skip OFF
.a499	a9 3f		lda #$3f			lda 	#$3F 						; call command $3F (silence)
.a49b	5a		phy				phy
.a49c	20 f1 b7	jsr $b7f1			jsr 	SNDCommand
.a49f	7a		ply				ply
.a4a0	60		rts				rts
.a4a1					_SNDMain:
.a4a1	a2 00		ldx #$00			ldx 	#0
.a4a3	20 78 9c	jsr $9c78			jsr 	Evaluate8BitInteger 		; channel
.a4a6	c9 04		cmp #$04			cmp 	#4 							; must be 0-3
.a4a8	b0 4b		bcs $a4f5			bcs 	_SndError
.a4aa	e8		inx				inx 								; do the rest in slot 1.
.a4ab	20 bc 8d	jsr $8dbc			jsr 	CheckComma
.a4ae	20 5d 9c	jsr $9c5d			jsr 	Evaluate16BitInteger 		; Pitch
.a4b1	b5 60		lda $60,x			lda 	NSMantissa1,x 				; must be 10 bit
.a4b3	c9 10		cmp #$10			cmp 	#16
.a4b5	b0 3e		bcs $a4f5			bcs 	_SndError
.a4b7	8d bb 05	sta $05bb			sta 	SoundCommandBlock+1 		; Pitch (2 bytes + 0)
.a4ba	b5 58		lda $58,x			lda 	NSMantissa0,x
.a4bc	8d ba 05	sta $05ba			sta 	SoundCommandBlock
.a4bf	20 bc 8d	jsr $8dbc			jsr 	CheckComma
.a4c2	20 78 9c	jsr $9c78			jsr 	Evaluate8BitInteger 		; Length (1 byte + 3)
.a4c5	8d bd 05	sta $05bd			sta 	SoundCommandBlock+3
.a4c8	a9 0f		lda #$0f			lda 	#15
.a4ca	8d bc 05	sta $05bc			sta 	SoundCommandBlock+2 		; Volume (1 byte + 2)
.a4cd	9c be 05	stz $05be			stz 	SoundCommandBlock+4 		; default slide (2 bytes +4)
.a4d0	9c bf 05	stz $05bf			stz 	SoundCommandBlock+5
.a4d3	b1 30		lda ($30),y			lda 	(codePtr),y
.a4d5	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.a4d7	d0 0e		bne $a4e7			bne 	_SNDPlay
.a4d9	c8		iny				iny
.a4da	20 67 9c	jsr $9c67			jsr 	Evaluate16BitIntegerSigned 	; Slide
.a4dd	b5 58		lda $58,x			lda 	NSMantissa0,x 				; Slide (2 bytes + 4)
.a4df	8d be 05	sta $05be			sta 	SoundCommandBlock+4
.a4e2	b5 60		lda $60,x			lda 	NSMantissa1,x
.a4e4	8d bf 05	sta $05bf			sta 	SoundCommandBlock+5
.a4e7					_SNDPlay:
.a4e7	5a		phy				phy
.a4e8	a5 58		lda $58				lda 	NSMantissa0 				; channel.
.a4ea	09 10		ora #$10			ora 	#$10 						; 1x = Queue sound
.a4ec	a2 ba		ldx #$ba			ldx 	#(SoundCommandBlock & $FF)
.a4ee	a0 05		ldy #$05			ldy 	#(SoundCommandBlock >> 8)
.a4f0	20 f1 b7	jsr $b7f1			jsr 	SNDCommand
.a4f3	7a		ply				ply
.a4f4	60		rts				rts
.a4f5					_SndError:
.a4f5	4c 5a 9e	jmp $9e5a			jmp 	RangeError
.05ba					SoundCommandBlock:
>05ba							.fill 	6

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/bytes.asm

.a4f8					StackPushByte:
.a4f8	48		pha				pha 								; save byte
.a4f9	a5 34		lda $34				lda 	BasicStack
.a4fb	d0 09		bne $a506			bne 	_SPBNoBorrow
.a4fd	c6 35		dec $35				dec 	BasicStack+1
.a4ff	48		pha				pha
.a500	a5 35		lda $35				lda 	BasicStack+1
.a502	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a504	90 06		bcc $a50c			bcc 	_SPBMemory
.a506					_SPBNoBorrow:
.a506	c6 34		dec $34				dec 	BasicStack
.a508	68		pla				pla 								; get back and write
.a509	92 34		sta ($34)			sta 	(BasicStack)
.a50b	60		rts				rts
.a50c					_SPBMemory:
.a50c	a9 12		lda #$12		lda	#18
.a50e	4c cd 8d	jmp $8dcd		jmp	ErrorHandler
.a511					StackPopByte:
.a511	b2 34		lda ($34)			lda 	(BasicStack)
.a513	e6 34		inc $34				inc 	BasicStack
.a515	d0 02		bne $a519			bne 	_SPBNoCarry
.a517	e6 35		inc $35				inc 	BasicStack+1
.a519					_SPBNoCarry:
.a519	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/frames.asm

.a51a					StackOpen:
.a51a	48		pha				pha 								; save frame byte
.a51b	29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.a51d	0a		asl a				asl 	a 							; claim twice this for storage
.a51e	49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.a520	38		sec				sec 								; so basically subtracting from
.a521	65 34		adc $34				adc 	basicStack 	 				; basicStack
.a523	85 34		sta $34				sta 	basicStack
.a525	b0 08		bcs $a52f			bcs 	_SONoBorrow
.a527	c6 35		dec $35				dec 	basicStack+1
.a529	a5 35		lda $35				lda 	basicStack+1 				; have we reached stack overflow
.a52b	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a52d	90 04		bcc $a533			bcc 	_SOMemory
.a52f					_SONoBorrow:
.a52f	68		pla				pla 								; get marker back and write at TOS
.a530	92 34		sta ($34)			sta 	(basicStack)
.a532	60		rts				rts
.a533					_SOMemory:
.a533	a9 12		lda #$12		lda	#18
.a535	4c cd 8d	jmp $8dcd		jmp	ErrorHandler
.a538					StackClose:
.a538	b2 34		lda ($34)			lda 	(basicStack) 				; get TOS marker
.a53a	29 0f		and #$0f			and 	#$0F 						; bytes to add back
.a53c	0a		asl a				asl 	a 							; claim twice this.
.a53d	65 34		adc $34				adc 	basicStack 					; add to the stack pointer.
.a53f	85 34		sta $34				sta 	basicStack
.a541	90 02		bcc $a545			bcc 	_SCExit
.a543	e6 35		inc $35				inc 	basicStack+1
.a545					_SCExit:
.a545	60		rts				rts
.a546					StackCheckFrame:
.a546	48		pha				pha
.a547					_StackRemoveLocals:
.a547	b2 34		lda ($34)			lda 	(basicStack) 				; check for local, keep popping them
.a549	c9 03		cmp #$03			cmp 	#STK_LOCALS+1
.a54b	b0 05		bcs $a552			bcs 	_SCNoLocal
.a54d	20 d0 88	jsr $88d0			jsr 	LocalPopValue
.a550	80 f5		bra $a547			bra 	_StackRemoveLocals
.a552					_SCNoLocal:
.a552	68		pla				pla
.a553	52 34		eor ($34)			eor 	(basicStack) 				; xor with toS marker
.a555	29 f0		and #$f0			and 	#$F0 						; check type bits
.a557	d0 01		bne $a55a			bne 	_SCFError 					; different, we have structures mixed up
.a559	60		rts				rts
.a55a					_SCFError:
.a55a	8a		txa				txa 								; report error X
.a55b	4c cd 8d	jmp $8dcd			jmp 	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/location.asm

.a55e					STKSaveCodePosition:
.a55e	5a		phy				phy
.a55f	98		tya				tya 								; save Y
.a560	a0 05		ldy #$05			ldy 	#5
.a562	91 34		sta ($34),y			sta 	(basicStack),y
.a564	88		dey				dey 								; save Code Pointer
.a565					_STKSaveLoop:
.a565	b9 2f 00	lda $002f,y			lda 	safePtr-1,y 				; allows us to access the pointer w/out issues.
.a568	91 34		sta ($34),y			sta 	(basicStack),y
.a56a	88		dey				dey
.a56b	d0 f8		bne $a565			bne 	_STKSaveLoop
.a56d	7a		ply				ply
.a56e	60		rts				rts
.a56f					STKLoadCodePosition:
.a56f	a0 01		ldy #$01			ldy 	#1 							; load code pointer back
.a571					_STKLoadLoop:
.a571	b1 34		lda ($34),y			lda 	(basicStack),y
.a573	99 2f 00	sta $002f,y			sta 	safePtr-1,y
.a576	c8		iny				iny
.a577	c0 05		cpy #$05			cpy 	#5
.a579	d0 f6		bne $a571			bne 	_STKLoadLoop
.a57b	b1 34		lda ($34),y			lda 	(basicStack),y 				; get Y offset
.a57d	a8		tay				tay
.a57e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/setup.asm

.a57f					StackReset:
.a57f	a9 ff		lda #$ff			lda 	#((BasicStackBase+BasicStackSize-1) & $FF)
.a581	85 34		sta $34				sta 	0+basicStack
.a583	a9 0f		lda #$0f			lda 	#((BasicStackBase+BasicStackSize-1) >> 8)
.a585	85 35		sta $35				sta 	1+basicStack
.a587	a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.a589	92 34		sta ($34)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.a58b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/concrete.asm

.a58c					StringConcrete:
.a58c	5a		phy				phy 								; save position on stack
.a58d	20 02 99	jsr $9902			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a590	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy target string to zTemp1
.a592	85 38		sta $38				sta 	zTemp1
.a594	b5 60		lda $60,x			lda 	NSMantissa1,x
.a596	85 39		sta $39				sta 	zTemp1+1
.a598	a0 ff		ldy #$ff			ldy 	#$FF	 					; calculate string length
.a59a					_SALength:
.a59a	c8		iny				iny
.a59b	b1 38		lda ($38),y			lda 	(zTemp1),y
.a59d	d0 fb		bne $a59a			bne 	_SALength
.a59f	c0 fd		cpy #$fd			cpy 	#253 						; string too long
.a5a1	b0 3d		bcs $a5e0			bcs 	_SALengthError
.a5a3	98		tya				tya 				 				; length of the new string
.a5a4	18		clc				clc
.a5a5	69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.a5a7	90 02		bcc $a5ab			bcc 	_SAHaveLength
.a5a9	a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.a5ab					_SAHaveLength:
.a5ab	48		pha				pha 								; save length.
.a5ac	38		sec				sec
.a5ad	49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.a5af	6d 0e 04	adc $040e			adc 	StringMemory
.a5b2	8d 0e 04	sta $040e			sta 	StringMemory
.a5b5	85 3a		sta $3a				sta 	zTemp2 						; update storage address
.a5b7	95 58		sta $58,x			sta 	NSMantissa0,x 				; update mantissa address
.a5b9	a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.a5bb	6d 0f 04	adc $040f			adc 	StringMemory+1
.a5be	8d 0f 04	sta $040f			sta 	StringMemory+1
.a5c1	85 3b		sta $3b				sta 	zTemp2+1
.a5c3	95 60		sta $60,x			sta 	NSMantissa1,x
.a5c5	68		pla				pla 								; save length-3 (chars allowed) in first byte
.a5c6	38		sec				sec
.a5c7	e9 03		sbc #$03			sbc 	#3
.a5c9	92 3a		sta ($3a)			sta 	(zTemp2)
.a5cb	a9 00		lda #$00			lda 	#0 							; clear the status byte.
.a5cd	a0 01		ldy #$01			ldy 	#1
.a5cf	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a5d1					_SACopyNewString:
.a5d1	a0 00		ldy #$00			ldy 	#0
.a5d3					_SACopyNSLoop:
.a5d3	b1 38		lda ($38),y			lda 	(zTemp1),y 					; get character
.a5d5	c8		iny				iny 								; write two on in string storage
.a5d6	c8		iny				iny
.a5d7	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a5d9	88		dey				dey 								; this makes it one one.
.a5da	c9 00		cmp #$00			cmp 	#0 							; until EOS copied
.a5dc	d0 f5		bne $a5d3			bne 	_SACopyNSLoop
.a5de	7a		ply				ply
.a5df	60		rts				rts
.a5e0					_SALengthError:
.a5e0	a9 09		lda #$09		lda	#9
.a5e2	4c cd 8d	jmp $8dcd		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/stringalloc.asm

.a5e5					StringSystemInitialise:
.a5e5	a9 ff		lda #$ff			lda 	#((EndVariableSpace-1) & $FF)
.a5e7	8d 0e 04	sta $040e			sta 	0+StringMemory
.a5ea	a9 1f		lda #$1f			lda 	#((EndVariableSpace-1) >> 8)
.a5ec	8d 0f 04	sta $040f			sta 	1+StringMemory
.a5ef	9c ff 1f	stz $1fff			stz 	EndVariableSpace-1 			; put a zero at the end, so know end of string memory.
.a5f2	60		rts				rts
.a5f3					StringSpaceInitialise:
.a5f3	20 02 99	jsr $9902			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a5f6	a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.a5f8	8d 10 04	sta $0410			sta 	StringInitialised
.a5fb	ad 0e 04	lda $040e			lda 	StringMemory 				; allocate 256 bytes for one concreted string
.a5fe	8d 11 04	sta $0411			sta 	StringTempPointer
.a601	ad 0f 04	lda $040f			lda 	StringMemory+1
.a604	3a		dec a				dec 	a
.a605	8d 12 04	sta $0412			sta 	StringTempPointer+1
.a608	60		rts				rts
.a609					StringTempAllocate:
.a609	c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.a60b	b0 30		bcs $a63d			bcs 	_STALength
.a60d	2c 10 04	bit $0410			bit 	StringInitialised 			; already initialised
.a610	30 05		bmi $a617			bmi 	_STAAllocate
.a612	48		pha				pha 								; save value to subtract.
.a613	20 f3 a5	jsr $a5f3			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.a616	68		pla				pla 								; restore it
.a617					_STAAllocate:
.a617	49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.a619	18		clc				clc  								; deliberate allows one more
.a61a	6d 11 04	adc $0411			adc 	StringTempPointer 			; subtract from temp pointer
.a61d	8d 11 04	sta $0411			sta 	StringTempPointer
.a620	95 58		sta $58,x			sta 	NSMantissa0,x 				; address in mantissa
.a622	85 3c		sta $3c				sta 	zsTemp 						; and zsTemp
.a624	ad 12 04	lda $0412			lda 	StringTempPointer+1
.a627	69 ff		adc #$ff			adc 	#$FF
.a629	8d 12 04	sta $0412			sta 	StringTempPointer+1
.a62c	85 3d		sta $3d				sta 	zsTemp+1
.a62e	95 60		sta $60,x			sta 	NSMantissa1,x
.a630	74 68		stz $68,x			stz 	NSMantissa2,x 				; set the typing data
.a632	74 70		stz $70,x			stz 	NSMantissa3,x
.a634	a9 10		lda #$10			lda 	#NSTString
.a636	95 50		sta $50,x			sta 	NSStatus,x
.a638	a9 00		lda #$00			lda 	#0 							; clear the target string
.a63a	92 3c		sta ($3c)			sta 	(zsTemp)
.a63c	60		rts				rts
.a63d					_STALength:
.a63d	a9 09		lda #$09		lda	#9
.a63f	4c cd 8d	jmp $8dcd		jmp	ErrorHandler
.a642					StringTempWrite:
.a642	48		pha				pha
.a643	92 3c		sta ($3c)			sta 	(zsTemp)
.a645	e6 3c		inc $3c				inc 	zsTemp
.a647	d0 02		bne $a64b			bne 	_STWNoCarry
.a649	e6 3d		inc $3d				inc 	zsTemp+1
.a64b					_STWNoCarry:
.a64b	a9 00		lda #$00			lda 	#0
.a64d	92 3c		sta ($3c)			sta 	(zsTemp)
.a64f	68		pla				pla
.a650	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_hardware.module

=1					hardwareIntegrated=1
=0					CONBlack = 0
=1					CONWhite = 1
=2					CONRed = 2
=3					CONCyan = 3
=4					CONPurple = 4
=5					CONGreen = 5
=6					CONBlue = 6
=7					CONYellow = 7
=8					CONOrange = 8
=9					CONBrown = 9
=10					CONYellowGreen = 10
=11					CONRosa = 11
=12					CONBlueGreen = 12
=13					CONLightBlue = 13
=14					CONPink = 14
=15					CONLightGreen = 15
=7					CONForeground = CONYellow
=6					CONBackground = CONBlue
=12					CLINumber = CONBlueGreen
=3					CLIToken = CONCyan
=13					CLIConstant = CONLightBlue
=7					CLIIdentifier = CONYellow
=10					CLIPunctuation = CONYellowGreen
=1					CLIData = CONWhite
.a651					EXTPrintCharacter:
.a651	48		pha				pha
.a652	da		phx				phx
.a653	5a		phy				phy
.a654	a6 01		ldx $01				ldx 	1
.a656	da		phx				phx
.a657	ac c1 05	ldy $05c1			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.a65a	09 00		ora #$00			ora 	#$00 						; check $80-$FF
.a65c	30 48		bmi $a6a6			bmi 	_EXPCColour
.a65e	c9 20		cmp #$20			cmp 	#$20 						; check $00-$1F
.a660	90 4d		bcc $a6af			bcc 	_EXPCControl
.a662	a2 02		ldx #$02			ldx 	#2 							; select char memory
.a664	86 01		stx $01				stx 	1
.a666	91 40		sta ($40),y			sta 	(EXTAddress),y
.a668	e6 01		inc $01				inc 	1 							; select colour memory
.a66a	ad c2 05	lda $05c2			lda 	EXTTextColour
.a66d	91 40		sta ($40),y			sta 	(EXTAddress),y
.a66f	c8		iny				iny 								; advance horizontal position
.a670	8c c1 05	sty $05c1			sty 	EXTColumn
.a673	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth 				; reached RHS ?
.a676	90 66		bcc $a6de			bcc 	_EXPCExit 					; no, then exit.
.a678					_EXPCCRLF:
.a678	ee c0 05	inc $05c0			inc 	EXTRow  					; bump row
.a67b	9c c1 05	stz $05c1			stz 	EXTColumn 					; back to column 0
.a67e	ad c0 05	lda $05c0			lda 	EXTRow 						; check if reached the bottom ?
.a681	cd c4 05	cmp $05c4			cmp 	EXTScreenHeight 			; if so, then scroll.
.a684	f0 18		beq $a69e			beq 	_EXPCScroll
.a686	18		clc				clc 								; add width to address.
.a687	a5 40		lda $40				lda 	EXTAddress
.a689	6d c3 05	adc $05c3			adc 	EXTScreenWidth
.a68c	85 40		sta $40				sta 	EXTAddress
.a68e	90 4e		bcc $a6de			bcc 	_EXPCExit
.a690	e6 41		inc $41				inc 	EXTAddress+1
.a692	80 4a		bra $a6de			bra 	_EXPCExit
.a694					_EXPCLeft:
.a694	ce c1 05	dec $05c1			dec 	EXTColumn
.a697	10 45		bpl $a6de			bpl 	_EXPCExit
.a699					_EXPCBegin:
.a699	9c c1 05	stz $05c1			stz 	EXTColumn
.a69c	80 40		bra $a6de			bra 	_EXPCExit
.a69e					_EXPCScroll:
.a69e	ce c0 05	dec $05c0			dec 	EXTRow 						; the height-1 th line.
.a6a1	20 6b a7	jsr $a76b			jsr 	EXTScreenScroll 			; scroll the screen
.a6a4	80 38		bra $a6de			bra 	_EXPCExit
.a6a6					_EXPCColour:
.a6a6	c9 a0		cmp #$a0			cmp 	#$A0						; 80-9F set foreground/background
.a6a8	b0 34		bcs $a6de			bcs 	_EXPCExit
.a6aa	20 4b a7	jsr $a74b			jsr 	_EXPCHandleColour
.a6ad	80 2f		bra $a6de			bra 	_EXPCExit
.a6af					_EXPCControl:
.a6af	c9 11		cmp #$11			cmp 	#$11 						; only handle 00-10.
.a6b1	b0 2b		bcs $a6de			bcs 	_EXPCExit
.a6b3	0a		asl a				asl 	a 							; double into X
.a6b4	aa		tax				tax
.a6b5	7c 29 a7	jmp ($a729,x)			jmp 	(_EXPCActionTable,x) 		; and execute code.
.a6b8					_EXPCUp:
.a6b8	ad c0 05	lda $05c0			lda 	EXTRow 						; already at top ?
.a6bb	f0 21		beq $a6de			beq 	_EXPCExit
.a6bd	ce c0 05	dec $05c0			dec 	EXTRow 						; up one in position/address
.a6c0	38		sec				sec
.a6c1	a5 40		lda $40				lda 	EXTAddress
.a6c3	ed c3 05	sbc $05c3			sbc 	EXTScreenWidth
.a6c6	85 40		sta $40				sta 	EXTAddress
.a6c8	b0 14		bcs $a6de			bcs 	_EXPCExit
.a6ca	c6 41		dec $41				dec 	EXTAddress+1
.a6cc	80 10		bra $a6de			bra 	_EXPCExit
.a6ce					_EXPCRight:
.a6ce	c8		iny				iny
.a6cf	8c c1 05	sty $05c1			sty 	EXTColumn
.a6d2	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth
.a6d5	d0 07		bne $a6de			bne 	_EXPCExit
.a6d7					_EXPCEnd:
.a6d7	ad c3 05	lda $05c3			lda 	EXTScreenWidth
.a6da	3a		dec a				dec 	a
.a6db	8d c1 05	sta $05c1			sta 	EXTColumn
.a6de					_EXPCExit:
.a6de	20 c0 a7	jsr $a7c0			jsr 	EXTSetHardwareCursor 		; place the physical cursor.
.a6e1	68		pla				pla
.a6e2	85 01		sta $01				sta 	1
.a6e4	7a		ply				ply
.a6e5	fa		plx				plx
.a6e6	68		pla				pla
.a6e7	60		rts				rts
.a6e8					_EXPCClearScreen:
.a6e8	20 7d a7	jsr $a77d			jsr		EXTClearScreenCode
.a6eb	80 f1		bra $a6de			bra 	_EXPCExit
.a6ed					_EXPCDown:
.a6ed	ad c4 05	lda $05c4			lda 	EXTScreenHeight 			; at the bottom
.a6f0	3a		dec a				dec 	a
.a6f1	cd c0 05	cmp $05c0			cmp 	EXTRow
.a6f4	f0 e8		beq $a6de			beq 	_EXPCExit
.a6f6	ee c0 05	inc $05c0			inc 	EXTRow 						; down one in position/address
.a6f9	18		clc				clc
.a6fa	a5 40		lda $40				lda 	EXTAddress
.a6fc	6d c3 05	adc $05c3			adc 	EXTScreenWidth
.a6ff	85 40		sta $40				sta 	EXTAddress
.a701	90 db		bcc $a6de			bcc 	_EXPCExit
.a703	e6 41		inc $41				inc 	EXTAddress+1
.a705	80 d7		bra $a6de			bra 	_EXPCExit
.a707					_EXPCTab:
.a707	ad c1 05	lda $05c1			lda 	EXTColumn 					; next tab stop
.a70a	29 f8		and #$f8			and 	#$F8
.a70c	18		clc				clc
.a70d	69 08		adc #$08			adc 	#8
.a70f	8d c1 05	sta $05c1			sta 	EXTColumn
.a712	cd c3 05	cmp $05c3			cmp 	EXTScreenWidth 				; too far, stick end of line.
.a715	90 c7		bcc $a6de			bcc 	_EXPCExit
.a717	80 be		bra $a6d7			bra 	_EXPCEnd
.a719					_EXPCBackSpace:
.a719	88		dey				dey
.a71a	30 c2		bmi $a6de			bmi 	_EXPCExit
.a71c	ce c1 05	dec $05c1			dec 	EXTColumn
.a71f	a9 02		lda #$02			lda 	#2
.a721	85 01		sta $01				sta 	1
.a723	a9 20		lda #$20			lda 	#32
.a725	91 40		sta ($40),y			sta 	(EXTAddress),y
.a727	80 b5		bra $a6de			bra 	_EXPCExit
.a729					_EXPCActionTable:
>a729	de a6						.word 	_EXPCExit 					; 00
>a72b	99 a6						.word 	_EXPCBegin 					; 01 A Start of Line
>a72d	94 a6						.word 	_EXPCLeft 					; 02 B Left
>a72f	de a6						.word 	_EXPCExit 					; 03 <Break>
>a731	de a6						.word 	_EXPCExit 					; 04
>a733	d7 a6						.word 	_EXPCEnd 					; 05 E End of Line
>a735	ce a6						.word 	_EXPCRight 					; 06 F Right
>a737	de a6						.word 	_EXPCExit 					; 07
>a739	19 a7						.word 	_EXPCBackspace 				; 08 H Backspace
>a73b	07 a7						.word 	_EXPCTab 					; 09 I Tab
>a73d	de a6						.word 	_EXPCExit 					; 0A
>a73f	de a6						.word 	_EXPCExit 					; 0B
>a741	e8 a6						.word 	_EXPCClearScreen			; 0C L CLS
>a743	78 a6						.word 	_EXPCCRLF 					; 0D M CR/LF
>a745	ed a6						.word 	_EXPCDown 					; 0E N Down
>a747	de a6						.word 	_EXPCExit 					; 0F
>a749	b8 a6						.word 	_EXPCUp 					; 10 P Up
.a74b					_EXPCHandleColour
.a74b	c9 90		cmp #$90			cmp 	#$90 						; 8x foreground 9x background
.a74d	b0 16		bcs $a765			bcs 	_EXPCBackground
.a74f	0a		asl a				asl 	a 							; shift it 4 bits to the right.
.a750	0a		asl a				asl 	a
.a751	0a		asl a				asl 	a
.a752	0a		asl a				asl 	a
.a753	a2 0f		ldx #$0f			ldx 	#$0F 						; Mask in X
.a755					_EXPCUpdate:
.a755	48		pha				pha 								; save new colour
.a756	8a		txa				txa 								; get mask
.a757	2d c2 05	and $05c2			and 	EXTTextColour 				; mask out old.
.a75a	8d c2 05	sta $05c2			sta 	EXTTextColour
.a75d	68		pla				pla 								; or in new colour
.a75e	0d c2 05	ora $05c2			ora 	EXTTextColour
.a761	8d c2 05	sta $05c2			sta 	EXTTextColour
.a764	60		rts				rts
.a765					_EXPCBackground:
.a765	29 0f		and #$0f			and 	#$0F 						; get the colour
.a767	a2 f0		ldx #$f0			ldx 	#$F0 						; mask
.a769	80 ea		bra $a755			bra 	_EXPCUpdate
.a76b					EXTScreenScroll:
.a76b	a9 02		lda #$02			lda 	#2 							; select text page
.a76d	85 01		sta $01				sta 	1
.a76f	a9 20		lda #$20			lda		#32 						; fill with space
.a771	20 80 a8	jsr $a880			jsr 	EXTScrollFill
.a774	e6 01		inc $01				inc 	1 							; select colour page
.a776	ad c2 05	lda $05c2			lda 	EXTTextColour
.a779	20 80 a8	jsr $a880			jsr 	EXTScrollFill
.a77c	60		rts				rts
.a77d					EXTClearScreenCode:
.a77d	a9 02		lda #$02			lda 	#2 							; select text page
.a77f	85 01		sta $01				sta 	1
.a781	a9 20		lda #$20			lda		#32 						; fill with space
.a783	20 90 a7	jsr $a790			jsr 	_EXTCSFill
.a786	e6 01		inc $01				inc 	1 							; select colour page
.a788	ad c2 05	lda $05c2			lda 	EXTTextColour
.a78b	20 90 a7	jsr $a790			jsr 	_EXTCSFill
.a78e	80 22		bra $a7b2			bra 	EXTHomeCursor
.a790					_EXTCSFill:
.a790	aa		tax				tax
.a791	a9 00		lda #$00			lda 	#EXTMemory & $FF
.a793	85 40		sta $40				sta 	EXTAddress
.a795	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a797	85 41		sta $41				sta 	EXTAddress+1
.a799					_EXTCSFill1:
.a799	a0 00		ldy #$00			ldy 	#0
.a79b	8a		txa				txa
.a79c					_EXTCSFill2:
.a79c	91 40		sta ($40),y			sta 	(EXTAddress),y
.a79e	c8		iny				iny
.a79f	d0 fb		bne $a79c			bne 	_EXTCSFill2
.a7a1	e6 41		inc $41				inc 	EXTAddress+1
.a7a3	a5 41		lda $41				lda 	EXTAddress+1
.a7a5	c9 d2		cmp #$d2			cmp 	#$D2
.a7a7	d0 f0		bne $a799			bne 	_EXTCSFill1
.a7a9	8a		txa				txa
.a7aa					_EXTCSFill3:
.a7aa	91 40		sta ($40),y			sta 	(EXTAddress),y
.a7ac	c8		iny				iny
.a7ad	c0 c0		cpy #$c0			cpy 	#$C0
.a7af	d0 f9		bne $a7aa			bne 	_EXTCSFill3
.a7b1	60		rts				rts
.a7b2					EXTHomeCursor:
.a7b2	9c c0 05	stz $05c0			stz 	EXTRow 						; reset row & column
.a7b5	9c c1 05	stz $05c1			stz 	EXTColumn
.a7b8	a9 00		lda #$00			lda 	#EXTMemory & $FF 			; set address
.a7ba	85 40		sta $40				sta 	EXTAddress
.a7bc	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a7be	85 41		sta $41				sta 	EXTAddress+1
.a7c0					EXTSetHardwareCursor:
.a7c0	64 01		stz $01				stz 	1 							; I/O Page zero
.a7c2	a9 05		lda #$05			lda 	#1+4 						; enable cursor
.a7c4	8d 10 d0	sta $d010			sta 	$D010
.a7c7	a9 b1		lda #$b1			lda 	#$B1
.a7c9	8d 12 d0	sta $d012			sta 	$D012
.a7cc	ad c1 05	lda $05c1			lda 	EXTColumn
.a7cf	8d 14 d0	sta $d014			sta 	$D014 						; set cursor position
.a7d2	9c 15 d0	stz $d015			stz 	$D015
.a7d5	ad c0 05	lda $05c0			lda 	EXTRow
.a7d8	8d 16 d0	sta $d016			sta 	$D016
.a7db	9c 17 d0	stz $d017			stz 	$D017
.a7de	60		rts				rts
.a7df					EXTInputLine:
.a7df	48		pha				pha
.a7e0	da		phx				phx
.a7e1	5a		phy				phy
.a7e2	a5 01		lda $01				lda 	1 							; save I/O page
.a7e4	48		pha				pha
.a7e5					_EILLoop:
.a7e5	20 e7 a8	jsr $a8e7			jsr 	ExtInputSingleCharacter
.a7e8	c9 0d		cmp #$0d			cmp 	#13 						; scrape line if exit.
.a7ea	f0 40		beq $a82c			beq 	_EILExit
.a7ec	c9 08		cmp #$08			cmp 	#8 							; handle backspace
.a7ee	f0 1c		beq $a80c			beq 	_EILBackspace
.a7f0	c9 20		cmp #$20			cmp 	#' '						; < space, print it
.a7f2	90 12		bcc $a806			bcc 	_EILPrintLoop
.a7f4	c9 7f		cmp #$7f			cmp 	#$7F 						; if -ve print it
.a7f6	b0 0e		bcs $a806			bcs 	_EILPrintLoop
.a7f8	48		pha				pha 								; save character
.a7f9	a9 02		lda #$02			lda 	#2  						; insert a space
.a7fb	85 01		sta $01				sta 	1
.a7fd	20 6e a8	jsr $a86e			jsr 	EXTILInsert 				; insert in text screen
.a800	e6 01		inc $01				inc 	1
.a802	20 6e a8	jsr $a86e			jsr 	EXTILInsert 				; insert in colour screen
.a805	68		pla				pla 								; get character back.
.a806					_EILPrintLoop:
.a806	20 51 a6	jsr $a651			jsr 	ExtPrintCharacter
.a809	80 da		bra $a7e5			bra 	_EILLoop
.a80b	60		rts				rts
.a80c					_EILBackspace:
.a80c	ad c1 05	lda $05c1			lda 	EXTColumn					; can we backspace ?
.a80f	f0 d4		beq $a7e5			beq 	_EILLoop
.a811	a9 02		lda #$02			lda 	#2 							; move cursor left
.a813	20 51 a6	jsr $a651			jsr 	EXTPrintCharacter
.a816	a9 02		lda #$02			lda 	#2 							; text block
.a818	85 01		sta $01				sta 	1
.a81a	a9 20		lda #$20			lda 	#' ' 						; backspace text.
.a81c	20 59 a8	jsr $a859			jsr 	EXTILDelete
.a81f	e6 01		inc $01				inc 	1 							; colour block
.a821	ac c1 05	ldy $05c1			ldy 	EXTColumn 					; get attribute of last character
.a824	88		dey				dey
.a825	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a827	20 59 a8	jsr $a859			jsr 	EXTILDelete 				; backspace attribute
.a82a	80 b9		bra $a7e5			bra 	_EILLoop 					; and go round.
.a82c					_EILExit:
.a82c	a9 02		lda #$02			lda 	#2 							; switch to page 2
.a82e	85 01		sta $01				sta 	1
.a830	a0 00		ldy #$00			ldy 	#0 							; copy current line into buffer.
.a832					_EILScrapeLine:
.a832	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a834	99 2a 05	sta $052a,y			sta 	lineBuffer,y
.a837	c8		iny				iny
.a838	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth
.a83b	d0 f5		bne $a832			bne 	_EILScrapeLine
.a83d					_EILTrimSpaces:
.a83d	88		dey				dey
.a83e	f0 08		beq $a848			beq 	_EILEndTrim
.a840	b9 2a 05	lda $052a,y			lda 	lineBuffer,y
.a843	c9 20		cmp #$20			cmp 	#' '
.a845	f0 f6		beq $a83d			beq 	_EILTrimSpaces
.a847	c8		iny				iny 								; trim after non space character.
.a848					_EILEndTrim:
.a848	a9 00		lda #$00			lda 	#0 							; trim here.
.a84a	99 2a 05	sta $052a,y			sta 	lineBuffer,y
.a84d	a9 0d		lda #$0d			lda 	#13 						; echo the RETURN
.a84f	20 51 a6	jsr $a651			jsr 	ExtPrintCharacter
.a852	68		pla				pla 								; reset I/O page
.a853	85 01		sta $01				sta 	1
.a855	7a		ply				ply
.a856	fa		plx				plx
.a857	68		pla				pla
.a858	60		rts				rts
.a859					EXTILDelete:
.a859	48		pha				pha 								; save the new character
.a85a	ac c1 05	ldy $05c1			ldy 	EXTColumn 					; start copying from here.
.a85d					_EXTDLoop:
.a85d	c8		iny				iny 								; copy one byte down.
.a85e	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a860	88		dey				dey
.a861	91 40		sta ($40),y			sta 	(EXTAddress),y
.a863	c8		iny				iny 								; do till end of line.
.a864	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth
.a867	90 f4		bcc $a85d			bcc 	_EXTDLoop
.a869	88		dey				dey 	 							; write in last slot.
.a86a	68		pla				pla
.a86b	91 40		sta ($40),y			sta 	(EXTAddress),y
.a86d	60		rts				rts
.a86e					EXTILInsert:
.a86e	ac c3 05	ldy $05c3			ldy 	EXTScreenWidth 				; end position
.a871					_EXTILoop:
.a871	88		dey				dey 								; back one
.a872	cc c1 05	cpy $05c1			cpy 	EXTColumn 					; exit if reached insert point.
.a875	f0 08		beq $a87f			beq 	_EXTIExit
.a877	88		dey				dey 								; copy one byte up.
.a878	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a87a	c8		iny				iny
.a87b	91 40		sta ($40),y			sta 	(EXTAddress),y
.a87d	80 f2		bra $a871			bra 	_EXTILoop
.a87f					_EXTIExit:
.a87f	60		rts				rts
.a880					EXTScrollFill:
.a880	aa		tax				tax									; save value to fill with
.a881	a5 36		lda $36				lda 	zTemp0 						; save zTemp0 (dest) zTemp1 (src)
.a883	48		pha				pha
.a884	a5 37		lda $37				lda 	zTemp0+1
.a886	48		pha				pha
.a887	a5 38		lda $38				lda 	zTemp1
.a889	48		pha				pha
.a88a	a5 39		lda $39				lda 	zTemp1+1
.a88c	48		pha				pha
.a88d	a9 c0		lda #$c0			lda 	#$C0 						; copy from C000+length to C000
.a88f	85 37		sta $37				sta 	zTemp0+1
.a891	85 39		sta $39				sta 	zTemp1+1
.a893	64 36		stz $36				stz 	zTemp0
.a895	ad c3 05	lda $05c3			lda 	EXTScreenWidth
.a898	85 38		sta $38				sta 	zTemp1
.a89a	a0 00		ldy #$00			ldy 	#0
.a89c					_EXSFCopy1:
.a89c	b1 38		lda ($38),y			lda 	(zTemp1),y
.a89e	91 36		sta ($36),y			sta 	(zTemp0),y
.a8a0	c8		iny				iny
.a8a1	d0 f9		bne $a89c			bne 	_EXSFCopy1
.a8a3	e6 37		inc $37				inc 	zTemp0+1 					; next page
.a8a5	e6 39		inc $39				inc 	zTemp1+1
.a8a7	a5 39		lda $39				lda 	zTemp1+1
.a8a9	c9 d3		cmp #$d3			cmp 	#$D3
.a8ab	d0 ef		bne $a89c			bne 	_EXSFCopy1
.a8ad	ac c3 05	ldy $05c3			ldy 	EXTScreenWidth 				; blank the bottom line.
.a8b0	8a		txa				txa
.a8b1					_EXSFFill1:
.a8b1	88		dey				dey
.a8b2	91 40		sta ($40),y			sta 	(EXTAddress),y
.a8b4	c0 00		cpy #$00			cpy 	#0
.a8b6	10 f9		bpl $a8b1			bpl 	_EXSFFill1
.a8b8	68		pla				pla
.a8b9	85 39		sta $39				sta 	zTemp1+1
.a8bb	68		pla				pla
.a8bc	85 38		sta $38				sta 	zTemp1
.a8be	68		pla				pla
.a8bf	85 37		sta $37				sta 	zTemp0+1
.a8c1	68		pla				pla
.a8c2	85 36		sta $36				sta 	zTemp0
.a8c4	60		rts				rts
=$c000					EXTMemory = $C000
=$02					EXTTextPage = $02
=$03					EXTColourPage = $03
=1					EXTDummySpace = 1 							; fake-space for CR character.
=0					EXTCBlack = 0
.05c0					EXTRow:
>05c0							.fill 	1
.05c1					EXTColumn:
>05c1							.fill 	1
.05c2					EXTTextColour:
>05c2							.fill 	1
.05c3					EXTScreenWidth:
>05c3							.fill 	1
.05c4					EXTScreenHeight:
>05c4							.fill 	1
.0040					EXTAddress:
>0040							.fill 	2
.a8c5					EXTInitialise:
.a8c5	64 01		stz $01				stz 	1 							; Access I/O
.a8c7	9c 04 d0	stz $d004			stz 	$D004 						; Disable border
.a8ca	9c 08 d0	stz $d008			stz 	$D008
.a8cd	9c 09 d0	stz $d009			stz 	$D009
.a8d0	a9 09		lda #$09			lda 	#1+8						; Timer On at 70Hz counting up.
.a8d2	8d 58 d6	sta $d658			sta 	$D658
.a8d5	a9 76		lda #$76			lda 	#CONForeground * 16 + CONBackground
.a8d7	8d c2 05	sta $05c2			sta 	EXTTextColour
.a8da	a9 50		lda #$50			lda 	#80 						; set screen dimensions.
.a8dc	8d c3 05	sta $05c3			sta 	EXTScreenWidth
.a8df	a9 3c		lda #$3c			lda 	#60
.a8e1	8d c4 05	sta $05c4			sta 	EXTScreenHeight
.a8e4	64 01		stz $01				stz 	1
.a8e6	60		rts				rts
.a8e7					EXTInputSingleCharacter:
.a8e7	da		phx				phx
.a8e8	5a		phy				phy
.a8e9					_EISCWait:
.a8e9	64 01		stz $01				stz 	1 							; access I/O Page 0
.a8eb	38		sec				sec 								; calculate timer - LastTick
.a8ec	ad 59 d6	lda $d659			lda 	$D659
.a8ef	aa		tax				tax 								; saving timer in X
.a8f0	ed af 05	sbc $05af			sbc 	LastTick
.a8f3	c9 03		cmp #$03			cmp 	#3
.a8f5	90 06		bcc $a8fd			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.a8f7	8e af 05	stx $05af			stx 	LastTick 					; update last timer
.a8fa	20 7e b8	jsr $b87e			jsr 	TickHandler 				; go do the code.
.a8fd					_NoFireTick:
.a8fd	20 e4 ff	jsr $ffe4			jsr 	$FFE4
.a900	c9 00		cmp #$00			cmp 	#0
.a902	f0 e5		beq $a8e9			beq 	_EISCWait
.a904	7a		ply				ply
.a905	fa		plx				plx
.a906	60		rts				rts
.a907					EXTBreakCheck:
.a907	4c e1 ff	jmp $ffe1			jmp		$FFE1
.a90a					EXTReadController:
.a90a	da		phx				phx
.a90b	a2 00		ldx #$00			ldx 	#0
.a90d	a9 05		lda #$05			lda 	#(($2D) >> 3)
.a90f	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.a912	29 20		and #$20			and 	#($01 << (($2D) & 7))
.a914	f0 04		beq $a91a			beq 	_NoSet1
.a916	8a		txa				txa
.a917	09 01		ora #$01			ora 	#1
.a919	aa		tax				tax
.a91a					_NoSet1:
.a91a	a9 05		lda #$05			lda 	#(($2C) >> 3)
.a91c	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.a91f	29 10		and #$10			and 	#($01 << (($2C) & 7))
.a921	f0 04		beq $a927			beq 	_NoSet1
.a923	8a		txa				txa
.a924	09 02		ora #$02			ora 	#2
.a926	aa		tax				tax
.a927					_NoSet1:
.a927	a9 06		lda #$06			lda 	#(($32) >> 3)
.a929	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.a92c	29 04		and #$04			and 	#($01 << (($32) & 7))
.a92e	f0 04		beq $a934			beq 	_NoSet1
.a930	8a		txa				txa
.a931	09 04		ora #$04			ora 	#4
.a933	aa		tax				tax
.a934					_NoSet1:
.a934	a9 04		lda #$04			lda 	#(($25) >> 3)
.a936	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.a939	29 20		and #$20			and 	#($01 << (($25) & 7))
.a93b	f0 04		beq $a941			beq 	_NoSet1
.a93d	8a		txa				txa
.a93e	09 08		ora #$08			ora 	#8
.a940	aa		tax				tax
.a941					_NoSet1:
.a941	a9 04		lda #$04			lda 	#(($26) >> 3)
.a943	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.a946	29 40		and #$40			and 	#($01 << (($26) & 7))
.a948	f0 04		beq $a94e			beq 	_NoSet1
.a94a	8a		txa				txa
.a94b	09 10		ora #$10			ora 	#16
.a94d	aa		tax				tax
.a94e					_NoSet1:
.a94e	8a		txa				txa
.a94f	fa		plx				plx
.a950	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_graphics.module

=1					graphicsIntegrated=1
=0					GCMD_Initialise = 0*2
=2					GCMD_BitmapCtl = 1*2
=4					GCMD_SpriteCtl = 2*2
=6					GCMD_Clear = 3*2
=8					GCMD_Colour = 4*2
=10					GCMD_DrawFont = 5*2
=12					GCMD_DrawSprite = 6*2
=14					GCMD_SpriteUse = 7*2
=16					GCMD_SpriteImage = 8*2
=18					GCMD_SpriteCollide = 9*2
=64					GCMD_Move = 32*2
=66					GCMD_Line = 33*2
=68					GCMD_FrameRect = 34*2
=70					GCMD_FillRect = 35*2
=72					GCMD_FrameCircle = 36*2
=74					GCMD_FillCircle = 37*2
=80					GCMD_Plot = 40*2
=82					GCMD_SpriteMove = 41*2
=42					GRFirstFreeCode = 42
.b884					GRVectorTable:
>b884	4c ab					.word	GXInitialise             ; $00 Initialise
>b886	66 ab					.word	GXControlBitmap          ; $01 BitmapCtl
>b888	ae ab					.word	GXControlSprite          ; $02 SpriteCtl
>b88a	fe aa					.word	GXClearBitmap            ; $03 Clear
>b88c	3d ad					.word	GXSetColourMode          ; $04 Colour
>b88e	05 af					.word	GXFontHandler            ; $05 DrawFont
>b890	4d af					.word	GXSpriteHandler          ; $06 DrawSprite
>b892	b9 af					.word	GXSelect                 ; $07 SpriteUse
>b894	e2 af					.word	GXSelectImage            ; $08 SpriteImage
>b896	69 b1					.word	GXCollide                ; $09 SpriteCollide
>b898	b0 a9					.word	GRUndefined              ; $0a
>b89a	b0 a9					.word	GRUndefined              ; $0b
>b89c	b0 a9					.word	GRUndefined              ; $0c
>b89e	b0 a9					.word	GRUndefined              ; $0d
>b8a0	b0 a9					.word	GRUndefined              ; $0e
>b8a2	b0 a9					.word	GRUndefined              ; $0f
>b8a4	b0 a9					.word	GRUndefined              ; $10
>b8a6	b0 a9					.word	GRUndefined              ; $11
>b8a8	b0 a9					.word	GRUndefined              ; $12
>b8aa	b0 a9					.word	GRUndefined              ; $13
>b8ac	b0 a9					.word	GRUndefined              ; $14
>b8ae	b0 a9					.word	GRUndefined              ; $15
>b8b0	b0 a9					.word	GRUndefined              ; $16
>b8b2	b0 a9					.word	GRUndefined              ; $17
>b8b4	b0 a9					.word	GRUndefined              ; $18
>b8b6	b0 a9					.word	GRUndefined              ; $19
>b8b8	b0 a9					.word	GRUndefined              ; $1a
>b8ba	b0 a9					.word	GRUndefined              ; $1b
>b8bc	b0 a9					.word	GRUndefined              ; $1c
>b8be	b0 a9					.word	GRUndefined              ; $1d
>b8c0	b0 a9					.word	GRUndefined              ; $1e
>b8c2	b0 a9					.word	GRUndefined              ; $1f
>b8c4	ae a9					.word	GXMove                   ; $20 Move
>b8c6	0b ac					.word	GXLine                   ; $21 Line
>b8c8	86 ad					.word	GXFrameRectangle         ; $22 FrameRect
>b8ca	83 ad					.word	GXFillRectangle          ; $23 FillRect
>b8cc	b5 a9					.word	GXFrameCircle            ; $24 FrameCircle
>b8ce	b1 a9					.word	GXFillCircle             ; $25 FillCircle
>b8d0	b0 a9					.word	GRUndefined              ; $26
>b8d2	b0 a9					.word	GRUndefined              ; $27
>b8d4	6b ad					.word	GXPlotPoint              ; $28 Plot
>b8d6	78 b0					.word	GXMoveSprite             ; $29 SpriteMove
=3					GXMappingPage = 3
=24576					GXMappingAddress = ($2000 * GXMappingPage)
=11					GXEditSlot = 8 + GXMappingPage
=$36					gxzTemp0 = zTemp0
=$38					gxzTemp1 = zTemp1
=$3a					gxzTemp2 = zTemp2
=$3c					gxzScreen = zsTemp
=$57b					gxPixelBuffer = numberBuffer
.05c5					gxCurrentX:
>05c5							.fill 	2
.05c7					gxCurrentY:
>05c7							.fill 	2
.05c9					gxLastX:
>05c9							.fill 	2
.05cb					gxLastY:
>05cb							.fill 	2
.05cd					gxX0:
>05cd							.fill 	2
.05cf					gxY0:
>05cf							.fill 	2
.05d1					gxX1:
>05d1							.fill 	2
.05d3					gxY1:
>05d3							.fill 	2
.05d5					gxSpritesOn:
>05d5							.fill 	1
.05d6					gxBitmapsOn:
>05d6							.fill 	1
.05d7					gxBasePage:
>05d7							.fill 	1
.05d8					gxSpritePage:
>05d8							.fill 	1
.05d9					gxHeight:
>05d9							.fill 	1
.05da					gxMode:
>05da							.fill 	1
.05db					gxColour:
>05db							.fill 	1
.05dc					gxEORValue:
>05dc							.fill 	1
.05dd					gxANDValue:
>05dd							.fill 	1
.05de					gxOriginalLUTValue:
>05de							.fill 	1
.05df					gsOffset:
>05df							.fill 	1
.05e0					GSCurrentSpriteID:
>05e0							.fill 	1
.05e1					GSCurrentSpriteAddr:
>05e1							.fill 	2
.05e3					GXSpriteOffsetBase:
>05e3							.fill 	2
.05e5					GXSpriteLow:
>05e5							.fill 	64
.0625					GXSpriteHigh:
>0625							.fill 	64
.a951					GXGraphicDraw:
.a951	c9 40		cmp #$40			cmp 	#GCMD_Move					; low instructions don't use coordinates
.a953	b0 06		bcs $a95b			bcs 	_GDCoordinate
.a955	86 36		stx $36				stx 	gxzTemp0 					; save X/Y
.a957	84 37		sty $37				sty 	gxzTemp0+1
.a959	80 4b		bra $a9a6			bra 	_GDExecuteA 				; and execute
.a95b					_GDCoordinate:
.a95b	48		pha				pha 								; save AXY
.a95c	da		phx				phx
.a95d	5a		phy				phy
.a95e	a2 03		ldx #$03			ldx 	#3 							; copy currentX to lastX
.a960					_GDCopy1:
.a960	bd c5 05	lda $05c5,x			lda 	gxCurrentX,x
.a963	9d c9 05	sta $05c9,x			sta 	gxLastX,x
.a966	ca		dex				dex
.a967	10 f7		bpl $a960			bpl 	_GDCopy1
.a969	68		pla				pla 								; update Y
.a96a	8d c7 05	sta $05c7			sta 	gxCurrentY
.a96d	9c c8 05	stz $05c8			stz 	gxCurrentY+1
.a970	68		pla				pla
.a971	8d c5 05	sta $05c5			sta 	gxCurrentX
.a974	68		pla				pla 								; get A (command+X.1) back
.a975	48		pha				pha
.a976	29 01		and #$01			and 	#1 							; put LSB as MSB of Current.X
.a978	8d c6 05	sta $05c6			sta 	gxCurrentX+1
.a97b	68		pla				pla 								; get command back
.a97c	29 fe		and #$fe			and 	#$FE 						; lose LSB, chuck the stray X bit
.a97e	48		pha				pha 								; push back.
.a97f	c9 52		cmp #$52			cmp 	#GCMD_SpriteMove 			; move sprite does not clip.
.a981	f0 17		beq $a99a			beq 	_GDCopyToWorkArea
.a983	ad c6 05	lda $05c6			lda 	gxCurrentX+1 				; X < 256 X okay
.a986	f0 07		beq $a98f			beq 	_GDCheckY
.a988	ad c5 05	lda $05c5			lda 	gxCurrentX 					; otherwise X < 320 = 256 + 64
.a98b	c9 40		cmp #$40			cmp 	#64
.a98d	b0 08		bcs $a997			bcs 	_GDError1
.a98f					_GDCheckY:
.a98f	ad c7 05	lda $05c7			lda 	gxCurrentY 					; check Y < Height.
.a992	cd d9 05	cmp $05d9			cmp 	gxHeight
.a995	90 03		bcc $a99a			bcc 	_GDCopyToWorkArea
.a997					_GDError1:
.a997	68		pla				pla
.a998					_GDError2:
.a998	38		sec				sec
.a999	60		rts				rts
.a99a					_GDCopyToWorkArea:
.a99a	a2 07		ldx #$07			ldx 	#7 							; copy current and last to gxXY/12 work area
.a99c					_GDCopy2:
.a99c	bd c5 05	lda $05c5,x			lda 	gxCurrentX,x
.a99f	9d cd 05	sta $05cd,x			sta 	gxX0,x
.a9a2	ca		dex				dex
.a9a3	10 f7		bpl $a99c			bpl 	_GDCopy2
.a9a5	68		pla				pla 								; get command
.a9a6					_GDExecuteA:
.a9a6	c9 54		cmp #$54			cmp 	#GRFirstFreeCode*2 			; bad ?
.a9a8	b0 ee		bcs $a998			bcs 	_GDError2
.a9aa	aa		tax				tax
.a9ab	7c 84 b8	jmp ($b884,x)			jmp 	(GRVectorTable,x)
.a9ae					GXMove:
.a9ae	18		clc				clc
.a9af	60		rts				rts
.a9b0					GRUndefined:
>a9b0	db						.byte 	$DB 						; causes a break in the emulator
.a9b1					GXFillCircle:
.a9b1	a9 ff		lda #$ff			lda 	#255
.a9b3	80 02		bra $a9b7			bra 	GXCircle
.a9b5					GXFrameCircle:
.a9b5	a9 00		lda #$00			lda 	#0
.a9b7					GXCircle:
.a9b7	8d 68 06	sta $0668			sta 	gxIsFillMode					; save Fill flag
.a9ba	ad d6 05	lda $05d6			lda 	gxBitmapsOn
.a9bd	f0 26		beq $a9e5			beq 	_GXCFail
.a9bf	20 10 b2	jsr $b210			jsr 	GXSortXY 					; topleft/bottomright
.a9c2	20 e8 b0	jsr $b0e8			jsr 	GXOpenBitmap 				; start drawing
.a9c5	20 b7 aa	jsr $aab7			jsr 	GXCircleSetup 				; set up for drawing
.a9c8	9c 69 06	stz $0669			stz 	gxYChanged
.a9cb					_GXCircleDraw:
.a9cb	ad 66 06	lda $0666			lda 	gXCentre					; while x <= y
.a9ce	cd 67 06	cmp $0667			cmp 	gYCentre
.a9d1	90 0a		bcc $a9dd			bcc 	_GXCircleContinue
.a9d3	d0 03		bne $a9d8			bne 	_GXNoLast
.a9d5	20 ea a9	jsr $a9ea			jsr 	GXPlot1
.a9d8					_GXNoLast:
.a9d8	20 f0 b0	jsr $b0f0			jsr 	GXCloseBitmap 				; close the bitmap
.a9db	18		clc				clc
.a9dc	60		rts				rts
.a9dd					_GXCircleContinue:
.a9dd	20 e7 a9	jsr $a9e7			jsr 	GXPlot2 					; draw it
.a9e0	20 64 aa	jsr $aa64			jsr 	GXCircleMove 				; adjust the coordinates
.a9e3	80 e6		bra $a9cb			bra 	_GXCircleDraw
.a9e5					_GXCFail:
.a9e5	38		sec				sec
.a9e6	60		rts				rts
.a9e7					GXPlot2:
.a9e7	20 ea a9	jsr $a9ea			jsr 	GXPlot1 						; plot and swap, fall through does twice
.a9ea					GXPlot1:
.a9ea	ad 67 06	lda $0667			lda 	gYCentre 						; if y = 0, don't do it twice (xor)
.a9ed	f0 03		beq $a9f2			beq 	_GXPlot1Only
.a9ef	20 0e aa	jsr $aa0e			jsr 	GXPlot0 						; plot and negate
.a9f2					_GXPlot1Only:
.a9f2	20 0e aa	jsr $aa0e			jsr 	GXPlot0 						; twice, undoing negation
.a9f5	ad 66 06	lda $0666			lda 	gXCentre 						; swap X and Y
.a9f8	ae 67 06	ldx $0667			ldx	 	gYCentre
.a9fb	8d 67 06	sta $0667			sta 	gYCentre
.a9fe	8e 66 06	stx $0666			stx 	gXCentre
.aa01	ad 69 06	lda $0669			lda 	gxYChanged 						; toggle Y Changed flag
.aa04	a9 ff		lda #$ff			lda 	#$FF
.aa06	8d 69 06	sta $0669			sta 	gxYChanged
.aa09	60		rts				rts
.aa0a	20 0e aa	jsr $aa0e			jsr 	GXPlot0 						; do once
.aa0d	60		rts				rts
.aa0e	ad 68 06	lda $0668	GXPlot0:lda 	gxIsFillMode 					; outline mode, always draw as X or Y will change
.aa11	f0 05		beq $aa18			beq 	_GXPlot0Always
.aa13	ad 69 06	lda $0669			lda 	gxYChanged						; fill mode, only draw if changed.
.aa16	f0 2d		beq $aa45			beq 	GXPlot0Exit
.aa18					_GXPlot0Always:
.aa18	a2 02		ldx #$02			ldx 	#2 								; copy Y1-A => Y0
.aa1a	ad 67 06	lda $0667			lda 	gYCentre
.aa1d	20 46 aa	jsr $aa46			jsr 	GXSubCopy
.aa20	a2 00		ldx #$00			ldx 	#0 								; copy X1-A => X0,
.aa22	ad 66 06	lda $0666			lda 	gXCentre
.aa25	20 46 aa	jsr $aa46			jsr 	GXSubCopy
.aa28	48		pha				pha 									; save last offset X
.aa29	20 f8 b0	jsr $b0f8			jsr 	GXPositionCalc 					; calculate position/offset.
.aa2c	68		pla				pla
.aa2d	0a		asl a				asl 	a 								; store 2 x last offset in gxzTemp0
.aa2e	85 36		sta $36				sta 	gxzTemp0
.aa30	64 37		stz $37				stz 	gxzTemp0+1
.aa32	26 37		rol $37				rol 	gxzTemp0+1
.aa34	ad 68 06	lda $0668			lda 	gxIsFillMode
.aa37	69 80		adc #$80			adc 	#128
.aa39	20 d6 ad	jsr $add6			jsr 	GXDrawLineTemp0 				; routine from Rectangle.
.aa3c	38		sec				sec 									; GY = -GY
.aa3d	a9 00		lda #$00			lda 	#0
.aa3f	ed 67 06	sbc $0667			sbc 	gYCentre
.aa42	8d 67 06	sta $0667			sta 	gYCentre
.aa45					GXPlot0Exit:
.aa45	60		rts				rts
.aa46					GXSubCopy:
.aa46	85 36		sta $36				sta 	gxzTemp0
.aa48	64 37		stz $37				stz 	gxzTemp0+1
.aa4a	29 80		and #$80			and 	#$80
.aa4c	f0 02		beq $aa50			beq 	_GXNoSx
.aa4e	c6 37		dec $37				dec 	gxzTemp0+1
.aa50					_GXNoSx:
.aa50	38		sec				sec
.aa51	bd d1 05	lda $05d1,x			lda 	gXX1,x
.aa54	e5 36		sbc $36				sbc 	gxzTemp0
.aa56	9d cd 05	sta $05cd,x			sta 	gXX0,x
.aa59	bd d2 05	lda $05d2,x			lda 	gXX1+1,x
.aa5c	e5 37		sbc $37				sbc 	gxzTemp0+1
.aa5e	9d ce 05	sta $05ce,x			sta 	gXX0+1,x
.aa61	a5 36		lda $36				lda 	gxzTemp0 						; return A
.aa63	60		rts				rts
.aa64					GXCircleMove:
.aa64	9c 69 06	stz $0669			stz 	gxYChanged 					; clear Y changed flag
.aa67	a5 39		lda $39				lda 	gxzTemp1+1 					; check sign of D
.aa69	10 0d		bpl $aa78			bpl 	_GXEMPositive
.aa6b	ee 66 06	inc $0666			inc 	gXCentre 					; X++
.aa6e	ad 66 06	lda $0666			lda 	gXCentre
.aa71	20 97 aa	jsr $aa97			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.aa74	a9 06		lda #$06			lda 	#6  						; and add 6
.aa76	80 15		bra $aa8d			bra 	_GXEMAddD
.aa78					_GXEMPositive:
.aa78	ee 66 06	inc $0666			inc 	gXCentre					; X++
.aa7b	ce 67 06	dec $0667			dec 	gyCentre 					; Y--
.aa7e	38		sec				sec 								; calculate X-Y
.aa7f	ad 66 06	lda $0666			lda 	gXCentre
.aa82	ed 67 06	sbc $0667			sbc 	gYCentre
.aa85	20 97 aa	jsr $aa97			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.aa88	a9 0a		lda #$0a			lda 	#10  						; and add 10
.aa8a	ce 69 06	dec $0669			dec 	gxYChanged
.aa8d					_GXEMAddD:
.aa8d	18		clc				clc
.aa8e	65 38		adc $38				adc 	gxzTemp1
.aa90	85 38		sta $38				sta 	gxzTemp1
.aa92	90 02		bcc $aa96			bcc 	_GXEMNoCarry
.aa94	e6 39		inc $39				inc 	gxzTemp1+1
.aa96					_GXEMNoCarry:
.aa96	60		rts				rts
.aa97					_GXAdd4TimesToD:
.aa97	85 36		sta $36				sta 	gxzTemp0 					; make 16 bit signed.
.aa99	29 80		and #$80			and 	#$80
.aa9b	f0 02		beq $aa9f			beq 	_GXA4Unsigned
.aa9d	a9 ff		lda #$ff			lda 	#$FF
.aa9f					_GXA4Unsigned:
.aa9f	85 37		sta $37				sta 	gxzTemp0+1
.aaa1	06 36		asl $36				asl 	gxzTemp0  					; x 4
.aaa3	26 37		rol $37				rol 	gxzTemp0+1
.aaa5	06 36		asl $36				asl 	gxzTemp0
.aaa7	26 37		rol $37				rol 	gxzTemp0+1
.aaa9	18		clc				clc 								; add
.aaaa	a5 36		lda $36				lda		gxzTemp0
.aaac	65 38		adc $38				adc 	gxzTemp1
.aaae	85 38		sta $38				sta 	gxzTemp1
.aab0	a5 37		lda $37				lda		gxzTemp0+1
.aab2	65 39		adc $39				adc 	gxzTemp1+1
.aab4	85 39		sta $39				sta 	gxzTemp1+1
.aab6	60		rts				rts
.aab7					GXCircleSetup:
.aab7	38		sec				sec
.aab8	ad d3 05	lda $05d3			lda 	gxY1
.aabb	ed cf 05	sbc $05cf			sbc 	gxY0
.aabe	4a		lsr a				lsr 	a
.aabf	8d 65 06	sta $0665			sta 	gxRadius
.aac2	a2 00		ldx #$00			ldx 	#0
.aac4	20 e6 aa	jsr $aae6			jsr 	_GXCalculateCentre
.aac7	a2 02		ldx #$02			ldx 	#2
.aac9	20 e6 aa	jsr $aae6			jsr 	_GXCalculateCentre
.aacc	9c 66 06	stz $0666			stz 	gXCentre
.aacf	ad 65 06	lda $0665			lda 	gxRadius
.aad2	8d 67 06	sta $0667			sta 	gYCentre
.aad5	0a		asl a				asl 	a 							; R x 2
.aad6	85 36		sta $36				sta 	gxzTemp0
.aad8	38		sec				sec
.aad9	a9 03		lda #$03			lda 	#3
.aadb	e5 36		sbc $36				sbc 	gxzTemp0
.aadd	85 38		sta $38				sta 	gxzTemp1
.aadf	a9 00		lda #$00			lda 	#0
.aae1	e9 00		sbc #$00			sbc 	#0
.aae3	85 39		sta $39				sta 	gxzTemp1+1
.aae5	60		rts				rts
.aae6					_GXCalculateCentre:
.aae6	38		sec				sec
.aae7	bd d1 05	lda $05d1,x			lda 	gxX1,x
.aaea	7d cd 05	adc $05cd,x			adc 	gXX0,x
.aaed	9d d1 05	sta $05d1,x			sta 	gXX1,x
.aaf0	bd d2 05	lda $05d2,x			lda 	gXX1+1,x
.aaf3	7d ce 05	adc $05ce,x			adc 	gXX0+1,x
.aaf6	4a		lsr a				lsr 	a
.aaf7	9d d2 05	sta $05d2,x			sta 	gXX1+1,x
.aafa	7e d1 05	ror $05d1,x			ror 	gXX1,x
.aafd	60		rts				rts
.0665					gxRadius:
>0665							.fill 	1
.0666					gXCentre:
>0666							.fill 	1
.0667					gYCentre:
>0667							.fill 	1
.0668					gxIsFillMode:
>0668							.fill 	1
.0669					gxYChanged:
>0669							.fill  	1
=64000					ScreenSize200 = 320 * 200
=76800					ScreenSize240 = 320 * 240
.aafe					GXClearBitmap:
.aafe	ad d6 05	lda $05d6			lda 	gxBitmapsOn 				; check BMP running.
.ab01	f0 24		beq $ab27			beq 	_GXCBFail
.ab03	20 e8 b0	jsr $b0e8			jsr 	GXOpenBitmap 				; start access
.ab06	a0 07		ldy #$07			ldy 	#ScreenSize200 / 8192 		; X is pages to clear
.ab08	ad d9 05	lda $05d9			lda 	gxHeight
.ab0b	c9 c8		cmp #$c8			cmp 	#200 						; 200 ?
.ab0d	a0 09		ldy #$09			ldy 	#ScreenSize240 / 8192
.ab0f					_GXCalcLastPage:
.ab0f	98		tya				tya 								; add to base page
.ab10	18		clc				clc
.ab11	6d d7 05	adc $05d7			adc 	gxBasePage
.ab14	85 0b		sta $0b				sta 	GXEditSlot  				; clear from this page back
.ab16					_GXClearAll:
.ab16	20 29 ab	jsr $ab29			jsr 	_GXClearBlock 				; clear 8k block
.ab19	c6 0b		dec $0b				dec 	GXEditSlot  				; back to previous
.ab1b	a5 0b		lda $0b				lda 	GXEditSlot
.ab1d	cd d7 05	cmp $05d7			cmp 	gxBasePage 					; until before base page
.ab20	b0 f4		bcs $ab16			bcs 	_GXClearAll
.ab22	20 f0 b0	jsr $b0f0			jsr 	GXCloseBitmap	 			; stop access
.ab25	18		clc				clc
.ab26	60		rts				rts
.ab27					_GXCBFail:
.ab27	38		sec				sec
.ab28	60		rts				rts
.ab29					_GXClearBlock:
.ab29	a9 00		lda #$00			lda 	#((GXMappingAddress) & $FF)
.ab2b	85 38		sta $38				sta 	0+gxzTemp1
.ab2d	a9 60		lda #$60			lda 	#((GXMappingAddress) >> 8)
.ab2f	85 39		sta $39				sta 	1+gxzTemp1
.ab31					_GXCB0:
.ab31	a5 36		lda $36				lda 	gxzTemp0
.ab33	a0 00		ldy #$00			ldy 	#0
.ab35					_GXCB1:
.ab35	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ab37	c8		iny				iny
.ab38	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ab3a	c8		iny				iny
.ab3b	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ab3d	c8		iny				iny
.ab3e	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ab40	c8		iny				iny
.ab41	d0 f2		bne $ab35			bne 	_GXCB1
.ab43	e6 39		inc $39				inc 	gxzTemp1+1
.ab45	a5 39		lda $39				lda 	gxzTemp1+1
.ab47	c9 80		cmp #$80			cmp	 	#(GXMappingAddress >> 8)+$20
.ab49	d0 e6		bne $ab31			bne 	_GXCB0
.ab4b	60		rts				rts
.ab4c					GXInitialise:
.ab4c	64 01		stz $01				stz 	1
.ab4e	a9 01		lda #$01			lda 	#1
.ab50	8d 00 d0	sta $d000			sta 	$D000
.ab53	18		clc				clc
.ab54	9c d5 05	stz $05d5			stz 	GXSpritesOn
.ab57	9c d6 05	stz $05d6			stz 	GXBitmapsOn
.ab5a	a2 0f		ldx #$0f			ldx 	#15
.ab5c					_GXIClear:
.ab5c	9e c5 05	stz $05c5,x			stz 	gxCurrentX,x
.ab5f	ca		dex				dex
.ab60	10 fa		bpl $ab5c			bpl 	_GXIClear
.ab62	20 fd ab	jsr $abfd			jsr 	GXClearSpriteStore
.ab65	60		rts				rts
.ab66					GXControlBitmap:
.ab66	64 01		stz $01				stz 	1
.ab68	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.ab6a	29 01		and #$01			and 	#1 							; set bitmap flag
.ab6c	8d d6 05	sta $05d6			sta 	gxBitmapsOn
.ab6f	4a		lsr a				lsr 	a 							; bit 0 into carry.
.ab70	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.ab73	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.ab75	29 f7		and #$f7			and 	#$F7 						; clear bitmap bit
.ab77	90 02		bcc $ab7b			bcc 	_CBNotOn
.ab79	09 08		ora #$08			ora 	#$08 						; bitmap on if 1 on 0 off
.ab7b					_CBNotOn:
.ab7b	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.ab7e	a5 36		lda $36				lda 	gxzTemp0 					; get control settings (bits 0-2)
.ab80	29 07		and #$07			and 	#7
.ab82	8d 00 d1	sta $d100			sta 	$D100 						; write in Vicky Bitmap Control Register #0
.ab85	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.ab87	d0 02		bne $ab8b			bne 	_CBNotDefault
.ab89	a9 08		lda #$08			lda 	#8  						; if zero, use 8 e.g. bitmap at $10000
.ab8b					_CBNotDefault:
.ab8b	8d d7 05	sta $05d7			sta 	gxBasePage
.ab8e	20 ef ab	jsr $abef			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.ab91	a5 37		lda $37				lda 	gxzTemp0+1 					; copy address into Bitmap address registers
.ab93	8d 03 d1	sta $d103			sta 	$D103
.ab96	a5 36		lda $36				lda 	gxzTemp0
.ab98	8d 02 d1	sta $d102			sta 	$D102
.ab9b	9c 01 d1	stz $d101			stz 	$D101
.ab9e	a2 f0		ldx #$f0			ldx 	#240 						; height is 240
.aba0	ad 01 d0	lda $d001			lda 	$D001 						; read MCR bit 0
.aba3	29 01		and #$01			and 	#1
.aba5	f0 02		beq $aba9			beq 	_CBHaveHeight
.aba7	a2 c8		ldx #$c8			ldx 	#200 						; if bit 0 set 320x200
.aba9					_CBHaveHeight
.aba9	8e d9 05	stx $05d9			stx 	gxHeight
.abac	18		clc				clc
.abad	60		rts				rts
.abae					GXControlSprite:
.abae	64 01		stz $01				stz 	1
.abb0	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.abb2	29 01		and #$01			and 	#1 							; set sprites flag
.abb4	8d d5 05	sta $05d5			sta 	gxSpritesOn
.abb7	4a		lsr a				lsr 	a 							; bit 0 into carry.
.abb8	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.abbb	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.abbd	29 df		and #$df			and 	#$DF 						; clear sprite bit
.abbf	90 02		bcc $abc3			bcc 	_CSNotOn
.abc1	09 20		ora #$20			ora 	#$20 						; sprite on if 1 on 0 off
.abc3					_CSNotOn:
.abc3	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.abc6	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.abc8	d0 02		bne $abcc			bne 	_CSNotDefault
.abca	a9 18		lda #$18			lda 	#24  						; if zero, use 24 e.g. sprites at $30000
.abcc					_CSNotDefault:
.abcc	8d d8 05	sta $05d8			sta 	gxSpritePage
.abcf	20 ef ab	jsr $abef			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.abd2	a5 36		lda $36				lda 	zTemp0
.abd4	8d e3 05	sta $05e3			sta 	GXSpriteOffsetBase
.abd7	a5 37		lda $37				lda 	zTemp0+1
.abd9	8d e4 05	sta $05e4			sta 	GXSpriteOffsetBase+1
.abdc	a2 00		ldx #$00			ldx 	#0 							; disable all sprites, clears all sprite memory.
.abde					_CSClear:
.abde	9e 00 d9	stz $d900,x			stz 	$D900,x
.abe1	9e 00 da	stz $da00,x			stz 	$DA00,x
.abe4	ca		dex				dex
.abe5	d0 f7		bne $abde			bne 	_CSClear
.abe7	9c e2 05	stz $05e2			stz 	GSCurrentSpriteAddr+1 		; no sprite selected.
.abea	20 fd ab	jsr $abfd			jsr 	GXClearSpriteStore
.abed	18		clc				clc
.abee	60		rts				rts
.abef					GXCalculateBaseAddress:
.abef	85 36		sta $36				sta 	gxzTemp0
.abf1	64 37		stz $37				stz 	gxzTemp0+1
.abf3	a9 05		lda #$05			lda 	#5
.abf5					_GXShift:
.abf5	06 36		asl $36				asl 	gxzTemp0
.abf7	26 37		rol $37				rol 	gxzTemp0+1
.abf9	3a		dec a				dec		a
.abfa	d0 f9		bne $abf5			bne 	_GXShift
.abfc	60		rts				rts
.abfd					GXClearSpriteStore:
.abfd	a2 3f		ldx #$3f			ldx 	#63 						; erase 64 sprite store elements
.abff					_GXCSSLoop:
.abff	9e 25 06	stz $0625,x			stz 	GXSpriteHigh,x
.ac02	a9 80		lda #$80			lda 	#$80 						; set the 'hidden' bit.
.ac04	9d e5 05	sta $05e5,x			sta 	GXSpriteLow,x
.ac07	ca		dex				dex
.ac08	10 f5		bpl $abff			bpl 	_GXCSSLoop
.ac0a	60		rts				rts
.ac0b					GXLine:
.ac0b	ad d6 05	lda $05d6			lda 	GXBitmapsOn
.ac0e	f0 28		beq $ac38			beq 	_GXLFail
.ac10	20 e8 b0	jsr $b0e8			jsr 	GXOpenBitmap
.ac13	20 2e b2	jsr $b22e			jsr 	GXSortY						; sort pairs so Y1 >= Y0 e.g. top to bottom.
.ac16	20 de ac	jsr $acde			jsr 	GXLineSetup 				; the calculations in the linescanner constructor
.ac19	20 f8 b0	jsr $b0f8			jsr 	GXPositionCalc 				; calculate position/offset.
.ac1c					_GXDrawLoop:
.ac1c	ac df 05	ldy $05df			ldy 	gsOffset 					; draw the pixel
.ac1f	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.ac21	2d dd 05	and $05dd			and 	gxANDValue
.ac24	4d dc 05	eor $05dc			eor 	gxEORValue
.ac27	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.ac29	20 3a ac	jsr $ac3a			jsr 	GXLineIsComplete 			; is the line complete ?
.ac2c	f0 05		beq $ac33			beq 	_GXLExit
.ac2e	20 55 ac	jsr $ac55			jsr 	GXLineAdvance 				; code as per advance method
.ac31	80 e9		bra $ac1c			bra 	_GXDrawLoop
.ac33					_GXLExit:
.ac33	20 f0 b0	jsr $b0f0			jsr 	GXCloseBitmap
.ac36	18		clc				clc
.ac37	60		rts				rts
.ac38					_GXLFail:
.ac38	38		sec				sec
.ac39	60		rts				rts
.ac3a					GXLineIsComplete:
.ac3a	ad 6c 06	lda $066c			lda 	GXIsDiffYLarger 			; is dy larger
.ac3d	d0 0f		bne $ac4e			bne 	_GXLICCompareY 				; if so compare Y1/Y0
.ac3f	ad cd 05	lda $05cd			lda 	GXX0 						; compare X, LSB and MSB
.ac42	4d d1 05	eor $05d1			eor 	GXX1
.ac45	d0 06		bne $ac4d			bne 	_GXLICExit
.ac47	ad ce 05	lda $05ce			lda 	GXX0+1
.ac4a	4d d2 05	eor $05d2			eor 	GXX1+1
.ac4d					_GXLICExit:
.ac4d	60		rts				rts
.ac4e					_GXLICCompareY:
.ac4e	ad d3 05	lda $05d3			lda 	GXY1
.ac51	4d cf 05	eor $05cf			eor 	GXY0
.ac54	60		rts				rts
.ac55					GXLineAdvance:
.ac55	18		clc				clc 								; add adjust to position
.ac56	ad 6e 06	lda $066e			lda 	GXPosition
.ac59	6d 6f 06	adc $066f			adc 	GXAdjust
.ac5c	8d 6e 06	sta $066e			sta 	GXPosition
.ac5f	9c 71 06	stz $0671			stz 	GXAddSelect 				; clear add select flag
.ac62	b0 05		bcs $ac69			bcs 	_GXLAOverflow 				; if carry out, overflowed.
.ac64	cd 70 06	cmp $0670			cmp 	GXTotal 					; if exceeded total
.ac67	90 0a		bcc $ac73			bcc 	_GXLANoExtra
.ac69					_GXLAOverflow:
.ac69	ce 71 06	dec $0671			dec 	GXAddSelect 				; set addselect to $FF
.ac6c	38		sec				sec 								; subtract total and write back
.ac6d	ed 70 06	sbc $0670			sbc 	GXTotal
.ac70	8d 6e 06	sta $066e			sta 	GXPosition
.ac73					_GXLANoExtra:
.ac73	ad 6c 06	lda $066c			lda 	GXIsDiffYLarger
.ac76	f0 0d		beq $ac85			beq 	_GXDXLarger
.ac78	20 d7 ac	jsr $acd7			jsr 	GXIncrementY
.ac7b	ad 71 06	lda $0671			lda 	GXAddSelect
.ac7e	f0 10		beq $ac90			beq 	_GXLAExit
.ac80	20 91 ac	jsr $ac91			jsr 	GXAdjustX
.ac83	80 0b		bra $ac90			bra 	_GXLAExit
.ac85					_GXDXLarger:
.ac85	20 91 ac	jsr $ac91			jsr 	GXAdjustX
.ac88	ad 71 06	lda $0671			lda 	GXAddSelect
.ac8b	f0 03		beq $ac90			beq 	_GXLAExit
.ac8d	20 d7 ac	jsr $acd7			jsr 	GXIncrementY
.ac90					_GXLAExit:
.ac90	60		rts				rts
.ac91					GXAdjustX:
.ac91	ad 6d 06	lda $066d			lda 	GXDXNegative
.ac94	10 25		bpl $acbb			bpl 	_GXAXRight
.ac96	ad cd 05	lda $05cd			lda 	GXX0
.ac99	d0 03		bne $ac9e			bne 	_GXAXNoBorrow
.ac9b	ce ce 05	dec $05ce			dec 	GXX0+1
.ac9e					_GXAXNoBorrow:
.ac9e	ce cd 05	dec $05cd			dec 	GXX0
.aca1	ce df 05	dec $05df			dec 	gsOffset 					; pixel left
.aca4	ad df 05	lda $05df			lda 	gsOffset
.aca7	c9 ff		cmp #$ff			cmp 	#$FF
.aca9	d0 0f		bne $acba			bne 	_GXAYExit 					; underflow
.acab	c6 3d		dec $3d				dec 	gxzScreen+1 					; borrow
.acad	a5 3d		lda $3d				lda 	gxzScreen+1 					; gone off page
.acaf	c9 60		cmp #$60			cmp 	#GXMappingAddress >> 8
.acb1	b0 07		bcs $acba			bcs 	_GXAYExit
.acb3	18		clc				clc
.acb4	69 20		adc #$20			adc 	#$20 						; fix up
.acb6	85 3d		sta $3d				sta 	gxzScreen+1
.acb8	c6 0b		dec $0b				dec 	GXEditSlot 				; back one page
.acba					_GXAYExit:
.acba	60		rts				rts
.acbb					_GXAXRight:
.acbb	ee cd 05	inc $05cd			inc 	GXX0
.acbe	d0 03		bne $acc3			bne 	_GXAXNoCarry
.acc0	ee ce 05	inc $05ce			inc 	GXX0+1
.acc3					_GXAXNoCarry:
.acc3	ee df 05	inc $05df			inc 	gsOffset 					; pixel right
.acc6	d0 0e		bne $acd6			bne 	_GXAXExit 					; if not overflowed, exit.
.acc8	e6 3d		inc $3d				inc 	gxzScreen+1 					; next line
.acca	a5 3d		lda $3d				lda 	gxzScreen+1
.accc	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.acce	90 06		bcc $acd6			bcc 	_GXAXExit
.acd0	e9 20		sbc #$20			sbc 	#$20 						; fix up
.acd2	85 3d		sta $3d				sta 	gxzScreen+1
.acd4	e6 0b		inc $0b				inc 	GXEditSlot 				; next page
.acd6					_GXAXExit:
.acd6	60		rts				rts
.acd7					GXIncrementY:
.acd7	ee cf 05	inc $05cf			inc 	GXY0
.acda	20 4e b1	jsr $b14e			jsr 	GXMovePositionDown
.acdd	60		rts				rts
.acde					GXLineSetup:
.acde	ad d3 05	lda $05d3			lda 	GXY1
.ace1	38		sec				sec
.ace2	ed cf 05	sbc $05cf			sbc 	GXY0
.ace5	4a		lsr a				lsr 	a
.ace6	8d 6b 06	sta $066b			sta 	GXDiffY
.ace9	9c 6d 06	stz $066d			stz 	GXDXNegative 				; clear -ve flag
.acec	38		sec				sec
.aced	ad d1 05	lda $05d1			lda 	GXX1
.acf0	ed cd 05	sbc $05cd			sbc 	GXX0
.acf3	8d 6a 06	sta $066a			sta 	GXDiffX
.acf6	ad d2 05	lda $05d2			lda 	GXX1+1 						; calculate MSB
.acf9	ed ce 05	sbc $05ce			sbc 	GXX0+1
.acfc	6a		ror a				ror 	a 							; rotate bit into DiffX halving it
.acfd	6e 6a 06	ror $066a			ror 	GXDiffX
.ad00	0a		asl a				asl 	a
.ad01	10 0c		bpl $ad0f			bpl 	_GDXNotNegative
.ad03	a9 00		lda #$00			lda 	#0 							; make absolute value of |dx|
.ad05	38		sec				sec
.ad06	ed 6a 06	sbc $066a			sbc 	GXDiffX
.ad09	8d 6a 06	sta $066a			sta 	GXDiffX
.ad0c	ce 6d 06	dec $066d			dec 	GXDXNegative 				; -ve flag = $FF.
.ad0f					_GDXNotNegative:
.ad0f	9c 6c 06	stz $066c			stz 	GXIsDiffYLarger 			; clear larger flag
.ad12	ad 6b 06	lda $066b			lda 	GXDiffY 					; set adjust and total.
.ad15	8d 6f 06	sta $066f			sta 	GXAdjust
.ad18	ad 6a 06	lda $066a			lda 	GXDiffX
.ad1b	8d 70 06	sta $0670			sta 	GXTotal
.ad1e	ad 6b 06	lda $066b			lda 	GXDiffY 					; if dy > dx
.ad21	cd 6a 06	cmp $066a			cmp 	GXDiffX
.ad24	90 0f		bcc $ad35			bcc 	_GDXNotLarger
.ad26	ce 6c 06	dec $066c			dec 	GXIsDiffYLarger 			; set the dy larger flag
.ad29	ad 6a 06	lda $066a			lda 	GXDiffX 					; set adjust and total other way round
.ad2c	8d 6f 06	sta $066f			sta 	GXAdjust
.ad2f	ad 6b 06	lda $066b			lda 	GXDiffY
.ad32	8d 70 06	sta $0670			sta 	GXTotal
.ad35					_GDXNotLarger:
.ad35	ad 70 06	lda $0670			lda 	GXTotal
.ad38	4a		lsr a				lsr 	a
.ad39	8d 6e 06	sta $066e			sta 	GXPosition
.ad3c	60		rts				rts
.066a					GXDiffX:
>066a							.fill 	1
.066b					GXDiffY:
>066b							.fill 	1
.066c					GXIsDiffYLarger:
>066c							.fill 	1
.066d					GXDXNegative:
>066d							.fill 	1
.066e					GXPosition:
>066e							.fill 	1
.066f					GXAdjust:
>066f							.fill 	1
.0670					GXTotal:
>0670							.fill 	1
.0671					GXAddSelect:
>0671							.fill 	1
.ad3d					GXSetColourMode:
.ad3d	a6 36		ldx $36				ldx 	gxzTemp0
.ad3f	8e db 05	stx $05db			stx 	gxColour 								; set colour
.ad42	a5 37		lda $37				lda 	gxzTemp0+1 								;
.ad44	8d da 05	sta $05da			sta 	gxMode 									; set mode
.ad47	29 03		and #$03			and 	#3 										; only interested in bits 0-3
.ad49	9c dd 05	stz $05dd			stz 	gxANDValue 								; initially AND with 0, and EOR with Colour
.ad4c	ae db 05	ldx $05db			ldx 	gxColour
.ad4f	8e dc 05	stx $05dc			stx 	gxEORValue
.ad52	c9 02		cmp #$02			cmp 	#2 										; if mode 2/3 And with colour
.ad54	90 03		bcc $ad59			bcc 	_GXSDCNotAndColour
.ad56	8e dd 05	stx $05dd			stx 	gxANDValue
.ad59					_GXSDCNotAndColour:
.ad59	d0 03		bne $ad5e			bne 	_GXSDCNotAnd 							; mode 2, Don't EOR with colour
.ad5b	9c dc 05	stz $05dc			stz 	gxEORValue
.ad5e					_GXSDCNotAnd:
.ad5e	4a		lsr a				lsr 	a 										; if bit 0 set, 1's complement AND value
.ad5f	90 08		bcc $ad69			bcc 	_GXSDCNoFlip
.ad61	ad dd 05	lda $05dd			lda	 	gxANDValue
.ad64	49 ff		eor #$ff			eor 	#$FF
.ad66	8d dd 05	sta $05dd			sta 	gxANDValue
.ad69					_GXSDCNoFlip:
.ad69	18		clc				clc
.ad6a	60		rts				rts
.ad6b					GXPlotPoint:
.ad6b	20 e8 b0	jsr $b0e8			jsr 	GXOpenBitmap 				; start drawing
.ad6e	20 f8 b0	jsr $b0f8			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.ad71	ac df 05	ldy $05df			ldy 	gsOffset
.ad74	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.ad76	2d dd 05	and $05dd			and 	gxANDValue
.ad79	4d dc 05	eor $05dc			eor 	gxEORValue
.ad7c	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.ad7e	20 f0 b0	jsr $b0f0			jsr 	GXCloseBitmap 				; stop drawing and exit
.ad81	18		clc				clc
.ad82	60		rts				rts
.ad83					GXFillRectangle:
.ad83	38		sec				sec
.ad84	80 01		bra $ad87			bra 	GXRectangle
.ad86					GXFrameRectangle:
.ad86	18		clc				clc
.ad87					GXRectangle:
.ad87	ad d6 05	lda $05d6			lda 	gxBitmapsOn
.ad8a	f0 35		beq $adc1			beq 	_GXRFail
.ad8c	08		php				php 								; save Fill flag (CS)
.ad8d	20 e8 b0	jsr $b0e8			jsr 	GXOpenBitmap 				; start drawing
.ad90	20 10 b2	jsr $b210			jsr 	GXSortXY 					; sort both X and Y so top left/bottom right
.ad93	20 f8 b0	jsr $b0f8			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.ad96	38		sec				sec 								; sec = Draw line
.ad97	20 c3 ad	jsr $adc3			jsr 	GXDrawLineX1X0 				; draw a line length X1-X0
.ad9a	ad cf 05	lda $05cf			lda 	gxY0 						; reached end of rectangle ?
.ad9d	cd d3 05	cmp $05d3			cmp 	gxY1
.ada0	f0 19		beq $adbb			beq 	_GXRectangleExit
.ada2					_GXRectLoop:
.ada2	20 4e b1	jsr $b14e			jsr 	GXMovePositionDown 			; down one.
.ada5	ee cf 05	inc $05cf			inc 	gxY0 						; change Y pos
.ada8	ad cf 05	lda $05cf			lda 	gxY0 						; reached last line
.adab	cd d3 05	cmp $05d3			cmp 	gXY1
.adae	f0 07		beq $adb7			beq 	_GXLastLine
.adb0	28		plp				plp 								; get flag back
.adb1	08		php				php
.adb2	20 c3 ad	jsr $adc3			jsr 	GXDrawLineX1X0 				; draw horizontal line
.adb5	80 eb		bra $ada2			bra 	_GXRectLoop
.adb7					_GXLastLine:
.adb7	38		sec				sec
.adb8	20 c3 ad	jsr $adc3			jsr 	GXDrawLineX1X0
.adbb					_GXRectangleExit:
.adbb	68		pla				pla 								; throw fill flag.
.adbc	20 f0 b0	jsr $b0f0			jsr 	GXCloseBitmap 				; stop drawing and exit
.adbf	18		clc				clc
.adc0	60		rts				rts
.adc1					_GXRFail:
.adc1	38		sec				sec
.adc2	60		rts				rts
.adc3					GXDrawLineX1X0:
.adc3	08		php				php 								; save solid/either-end
.adc4	38		sec				sec
.adc5	ad d1 05	lda $05d1			lda		gXX1
.adc8	ed cd 05	sbc $05cd			sbc 	gXX0
.adcb	85 36		sta $36				sta 	gxzTemp0
.adcd	ad d2 05	lda $05d2			lda 	gXX1+1
.add0	ed ce 05	sbc $05ce			sbc 	gXX0+1
.add3	85 37		sta $37				sta 	gxzTemp0+1
.add5	28		plp				plp
.add6					GXDrawLineTemp0:
.add6	a5 3c		lda $3c				lda 	gxzScreen 						; push gxzScreen, gsOffset and GXEditSlot on stack
.add8	48		pha				pha
.add9	a5 3d		lda $3d				lda 	gxzScreen+1
.addb	48		pha				pha
.addc	ad df 05	lda $05df			lda 	gsOffset
.addf	48		pha				pha
.ade0	a5 0b		lda $0b				lda 	GXEditSlot
.ade2	48		pha				pha
.ade3	ac df 05	ldy $05df			ldy 	gsOffset 					; Y offset
.ade6	90 1e		bcc $ae06			bcc 	_GXDLTEndPoints 			; if CC draw end points only.
.ade8					_GXDLTLine:
.ade8	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.adea	2d dd 05	and $05dd			and 	gxANDValue
.aded	4d dc 05	eor $05dc			eor 	gxEORValue
.adf0	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.adf2	a5 36		lda $36				lda 	gxzTemp0 					; decrement counter
.adf4	d0 04		bne $adfa			bne 	_GXDLTNoBorrow
.adf6	c6 37		dec $37				dec 	gxzTemp0+1 					; borrow, if goes -ve then exit
.adf8	30 2e		bmi $ae28			bmi 	_GXDLTExit
.adfa					_GXDLTNoBorrow:
.adfa	c6 36		dec $36				dec 	gxzTemp0
.adfc	c8		iny				iny 								; next slot.
.adfd	d0 e9		bne $ade8			bne 	_GXDLTLine
.adff	e6 3d		inc $3d				inc 	gxzScreen+1 					; carry to next
.ae01	20 36 ae	jsr $ae36			jsr 	GXDLTCheckWrap				; check for new page.
.ae04	80 e2		bra $ade8			bra 	_GXDLTLine
.ae06					_GXDLTEndPoints:
.ae06	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.ae08	2d dd 05	and $05dd			and 	gxANDValue
.ae0b	4d dc 05	eor $05dc			eor 	gxEORValue
.ae0e	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.ae10	98		tya				tya 								; advance to right side
.ae11	18		clc				clc
.ae12	65 36		adc $36				adc 	gxzTemp0
.ae14	a8		tay				tay
.ae15	a5 3d		lda $3d				lda 	gxzScreen+1
.ae17	65 37		adc $37				adc 	gxzTemp0+1
.ae19	85 3d		sta $3d				sta 	gxzScreen+1
.ae1b	20 36 ae	jsr $ae36			jsr 	GXDLTCheckWrap 			; fix up.
.ae1e	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.ae20	2d dd 05	and $05dd			and 	gxANDValue
.ae23	4d dc 05	eor $05dc			eor 	gxEORValue
.ae26	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.ae28					_GXDLTExit:
.ae28	68		pla				pla
.ae29	85 0b		sta $0b				sta 	GXEditSlot
.ae2b	68		pla				pla
.ae2c	8d df 05	sta $05df			sta 	gsOffset
.ae2f	68		pla				pla
.ae30	85 3d		sta $3d				sta 	gxzScreen+1
.ae32	68		pla				pla
.ae33	85 3c		sta $3c				sta 	gxzScreen
.ae35	60		rts				rts
.ae36					GXDLTCheckWrap:
.ae36	a5 3d		lda $3d				lda 	gxzScreen+1 					; check end of page
.ae38	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8)
.ae3a	90 06		bcc $ae42			bcc 	_GXDLTCWExit
.ae3c	e9 20		sbc #$20			sbc 	#$20 						; fix up
.ae3e	85 3d		sta $3d				sta 	gxzScreen+1
.ae40	e6 0b		inc $0b				inc 	GXEditSlot
.ae42					_GXDLTCWExit:
.ae42	60		rts				rts
.ae43					GXDrawGraphicElement:
.ae43	8d 72 06	sta $0672			sta 	gxSize 						; save size
.ae46	3a		dec a				dec 	a
.ae47	8d 73 06	sta $0673			sta 	gxMask 						; and mask
.ae4a	ad d6 05	lda $05d6			lda 	gxBitmapsOn 				; check BMP on
.ae4d	f0 67		beq $aeb6			beq 	_GXSLFail
.ae4f	ad cf 05	lda $05cf			lda 	gxY0 						; push Y on stack
.ae52	48		pha				pha
.ae53	8c 75 06	sty $0675			sty 	gxAcquireVector+1 			; and acquisition vector
.ae56	8e 74 06	stx $0674			stx 	gxAcquireVector
.ae59	20 e8 b0	jsr $b0e8			jsr 	gxOpenBitmap 				; open the bitmap.
.ae5c	ad 77 06	lda $0677			lda 	gxUseMode 					; scale bits
.ae5f	4a		lsr a				lsr 	a
.ae60	4a		lsr a				lsr 	a
.ae61	4a		lsr a				lsr 	a
.ae62	29 07		and #$07			and		#7
.ae64	1a		inc a				inc 	a
.ae65	8d 76 06	sta $0676			sta 	gxScale
.ae68	64 38		stz $38				stz 	gxzTemp1					; start first line
.ae6a					_GXGELoop:
.ae6a	a5 38		lda $38				lda 	gxzTemp1 					; current line number to read.
.ae6c	2c 77 06	bit $0677			bit 	gxUseMode 					; check for flip.
.ae6f	10 06		bpl $ae77			bpl		_GXNoVFlip
.ae71	ad 73 06	lda $0673			lda 	gxMask
.ae74	38		sec				sec
.ae75	e5 38		sbc $38				sbc 	gxzTemp1
.ae77					_GXNoVFlip:
.ae77	aa		tax				tax 								; get the Xth line.
.ae78	20 b8 ae	jsr $aeb8			jsr 	_GXCallAcquire 				; get that data.
.ae7b	ad 76 06	lda $0676			lda 	gxScale 					; do scale identical copies of that line.
.ae7e	85 39		sta $39				sta 	gxzTemp1+1
.ae80					_GXGELoop2:
.ae80	ad cf 05	lda $05cf			lda 	gxY0 						; off screen
.ae83	cd d9 05	cmp $05d9			cmp 	gxHeight
.ae86	b0 10		bcs $ae98			bcs 	_GXDGEExit
.ae88	20 bb ae	jsr $aebb			jsr 	GXRenderOneLine 			; render line
.ae8b	c6 39		dec $39				dec 	gxzTemp1+1 					; scale times.
.ae8d	d0 f1		bne $ae80			bne 	_GXGELoop2
.ae8f	e6 38		inc $38				inc 	gxzTemp1 					; done all lines.
.ae91	a5 38		lda $38				lda 	gxzTemp1
.ae93	cd 72 06	cmp $0672			cmp 	gxSize
.ae96	d0 d2		bne $ae6a			bne 	_GXGELoop
.ae98					_GXDGEExit:
.ae98	68		pla				pla 								; restore Y for next time
.ae99	8d cf 05	sta $05cf			sta 	gxY0
.ae9c	ae 76 06	ldx $0676			ldx 	gxScale 					; get scale (1-8)
.ae9f					_GXShiftLeft:
.ae9f	18		clc				clc
.aea0	ad 72 06	lda $0672			lda 	gxSize
.aea3	6d cd 05	adc $05cd			adc 	gxX0
.aea6	8d cd 05	sta $05cd			sta 	gxX0
.aea9	90 03		bcc $aeae			bcc 	_GXSLNoCarry
.aeab	ee ce 05	inc $05ce			inc 	gxX0+1
.aeae					_GXSLNoCarry:
.aeae	ca		dex				dex
.aeaf	d0 ee		bne $ae9f			bne 	_GXShiftLeft
.aeb1	20 f0 b0	jsr $b0f0			jsr 	GXCloseBitmap
.aeb4	18		clc				clc
.aeb5	60		rts				rts
.aeb6					_GXSLFail:
.aeb6	38		sec				sec
.aeb7	60		rts				rts
.aeb8					_GXCallAcquire:
.aeb8	6c 74 06	jmp ($0674)			jmp 	(gxAcquireVector)
.aebb					GXRenderOneLine:
.aebb	20 f8 b0	jsr $b0f8			jsr 	GXPositionCalc 				; calculate position/offset.
.aebe	ac df 05	ldy $05df			ldy 	gsOffset 					; Y contains position.
.aec1	64 3a		stz $3a				stz 	gxzTemp2 					; do size pixels
.aec3					_GXROLLoop1:
.aec3	ad 76 06	lda $0676			lda 	gxScale 					; set to do 'scale' times
.aec6	85 3b		sta $3b				sta 	gxzTemp2+1
.aec8					_GXROLLoop2:
.aec8	a5 3a		lda $3a				lda 	gxzTemp2 					; get current pixel
.aeca	2c da 05	bit $05da			bit 	gxMode 						; check H Flip
.aecd	50 06		bvc $aed5			bvc 	_GXNoHFlip
.aecf	ad 73 06	lda $0673			lda 	gxMask
.aed2	38		sec				sec
.aed3	e5 3a		sbc $3a				sbc 	gxzTemp2
.aed5					_GXNoHFlip:
.aed5	aa		tax				tax 								; read from the pixel buffer
.aed6	bd 7b 05	lda $057b,x			lda 	gxPixelBuffer,x
.aed9	d0 07		bne $aee2			bne 	_GXDraw 					; draw if non zero
.aedb	ad 77 06	lda $0677			lda 	gxUseMode 					; check to see if solid background
.aede	29 04		and #$04			and 	#4
.aee0	f0 0a		beq $aeec			beq 	_GXZeroPixel
.aee2					_GXDraw:
.aee2	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.aee4	2d dd 05	and $05dd			and 	gxANDValue
.aee7	5d 7b 05	eor $057b,x			eor 	gxPixelBuffer,x
.aeea	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.aeec					_GXZeroPixel:
.aeec	c8		iny				iny 								; advance pointer
.aeed	d0 05		bne $aef4			bne 	_GXNoShift
.aeef	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.aef1	20 36 ae	jsr $ae36			jsr 	GXDLTCheckWrap				; check for new page.
.aef4					_GXNoShift:
.aef4	c6 3b		dec $3b				dec 	gxzTemp2+1 					; do the inner loop gxScale times.
.aef6	d0 d0		bne $aec8			bne 	_GXROLLoop2
.aef8	e6 3a		inc $3a				inc 	gxzTemp2 					; next pixel.
.aefa	a5 3a		lda $3a				lda 	gxzTemp2
.aefc	cd 72 06	cmp $0672			cmp 	gxSize
.aeff	d0 c2		bne $aec3			bne 	_GXROLLoop1
.af01	ee cf 05	inc $05cf			inc 	gxY0
.af04	60		rts				rts
.0672					gxSize:
>0672							.fill 	1
.0673					gxMask:
>0673							.fill 	1
.0674					gxAcquireVector:
>0674							.fill 	2
.0676					gxScale:
>0676							.fill 	1
.0677					gxUseMode:
>0677							.fill 	1
.af05					GXFontHandler:
.af05	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.af07	4d da 05	eor $05da			eor 	gxMode
.af0a	8d 77 06	sta $0677			sta 	gxUseMode
.af0d	64 37		stz $37				stz 	gxzTemp0+1 					; gxzTemp0 is font #
.af0f	06 36		asl $36				asl	 	gxzTemp0 					; x 2
.af11	26 37		rol $37				rol	 	gxzTemp0+1
.af13	06 36		asl $36				asl	 	gxzTemp0 					; x 4
.af15	26 37		rol $37				rol	 	gxzTemp0+1
.af17	06 36		asl $36				asl	 	gxzTemp0 					; x 8
.af19	26 37		rol $37				rol	 	gxzTemp0+1
.af1b	a5 37		lda $37				lda 	gxzTemp0+1 					; put in page C0
.af1d	09 c0		ora #$c0			ora 	#$C0
.af1f	85 37		sta $37				sta 	gxzTemp0+1
.af21	a9 08		lda #$08			lda 	#8 							; size 8x8
.af23	a2 2b		ldx #$2b			ldx 	#GXGetGraphicDataFont & $FF ; XY = Graphic Data retrieval routine
.af25	a0 af		ldy #$af			ldy 	#GXGetGraphicDataFont >> 8
.af27	20 43 ae	jsr $ae43			jsr 	GXDrawGraphicElement
.af2a	60		rts				rts
.af2b					GXGetGraphicDataFont:
.af2b	8a		txa				txa 								; X->Y
.af2c	a8		tay				tay
.af2d	a6 01		ldx $01				ldx 	1 							; preserve old value
.af2f	a9 01		lda #$01			lda 	#1 							; access page 1 (font memory)
.af31	85 01		sta $01				sta 	1
.af33	b1 36		lda ($36),y			lda 	(gxzTemp0),y 				; read the font element.
.af35	86 01		stx $01				stx 	1 							; put old value back.
.af37	a2 00		ldx #$00			ldx 	#0 							; do 8 times
.af39					_GXExpand:
.af39	9e 7b 05	stz $057b,x			stz 	gxPixelBuffer,x 			; zero in pixel buffer
.af3c	0a		asl a				asl 	a 							; shift bit 7 into C
.af3d	90 08		bcc $af47			bcc 	_GXNoPixel
.af3f	48		pha				pha 								; if set, set pixel buffer to current colour.
.af40	ad db 05	lda $05db			lda 	gxColour
.af43	9d 7b 05	sta $057b,x			sta 	gxPixelBuffer,x
.af46	68		pla				pla
.af47					_GXNoPixel:
.af47	e8		inx				inx 								; do the whole byte.
.af48	e0 08		cpx #$08			cpx 	#8
.af4a	d0 ed		bne $af39			bne 	_GXExpand
.af4c	60		rts				rts
.af4d					GXSpriteHandler:
.af4d	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.af4f	4d da 05	eor $05da			eor 	gxMode
.af52	8d 77 06	sta $0677			sta 	gxUseMode
.af55	a6 36		ldx $36				ldx 	gxzTemp0 					; sprite #
.af57	da		phx				phx
.af58	20 e8 b0	jsr $b0e8			jsr 	GXOpenBitmap 				; can access sprite information
.af5b	68		pla				pla
.af5c	20 c9 b1	jsr $b1c9			jsr 	GXFindSprite 				; get the sprite address
.af5f	08		php				php
.af60	20 f0 b0	jsr $b0f0			jsr 	GXCloseBitmap
.af63	28		plp				plp
.af64	b0 0a		bcs $af70			bcs		_GXSHExit 					; exit if find failed.
.af66	ad 78 06	lda $0678			lda 	GXSizePixels 				; return size
.af69	a2 71		ldx #$71			ldx 	#GXSpriteAcquire & $FF
.af6b	a0 af		ldy #$af			ldy 	#GXSpriteAcquire >> 8
.af6d	20 43 ae	jsr $ae43			jsr 	GXDrawGraphicElement
.af70					_GXSHExit:
.af70	60		rts				rts
.af71					GXSpriteAcquire:
.af71	ad d8 05	lda $05d8			lda 	GXSpritePage				; point to base page
.af74	85 0b		sta $0b				sta 	GXEditSlot
.af76	86 36		stx $36				stx 	zTemp0 						; row number x 1,2,3,4
.af78	a9 00		lda #$00			lda 	#0
.af7a	ae 79 06	ldx $0679			ldx 	GXSizeBits
.af7d					_GXTimesRowNumber:
.af7d	18		clc				clc
.af7e	65 36		adc $36				adc 	zTemp0
.af80	ca		dex				dex
.af81	10 fa		bpl $af7d			bpl 	_GXTimesRowNumber
.af83	64 37		stz $37				stz 	gxzTemp0+1
.af85	0a		asl a				asl 	a 							; row x 2,4,6,8
.af86	26 37		rol $37				rol 	gxzTemp0+1
.af88	0a		asl a				asl 	a 							; row x 4,8,12,16
.af89	26 37		rol $37				rol 	gxzTemp0+1
.af8b	0a		asl a				asl 	a 							; row x 8,16,24,32
.af8c	26 37		rol $37				rol 	gxzTemp0+1
.af8e	85 36		sta $36				sta 	gxzTemp0
.af90	18		clc				clc 								; add base address.
.af91	a5 36		lda $36				lda 	gxzTemp0
.af93	6d 7b 06	adc $067b			adc 	GXSpriteOffset
.af96	85 36		sta $36				sta 	gxzTemp0
.af98	a5 37		lda $37				lda 	gxzTemp0+1
.af9a	6d 7c 06	adc $067c			adc 	GXSpriteOffset+1
.af9d					_GXSAFindPage:
.af9d	c9 20		cmp #$20			cmp 	#$20 						; on this page
.af9f	90 06		bcc $afa7			bcc 	_GXSAFoundPage
.afa1	e9 20		sbc #$20			sbc 	#$20 						; forward one page
.afa3	e6 0b		inc $0b				inc 	GXEditSlot
.afa5	80 f6		bra $af9d			bra 	_GXSAFindPage
.afa7					_GXSAFoundPage:
.afa7	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; physical address of page.
.afa9	85 37		sta $37				sta 	gxzTemp0+1 					; gxzTemp0 now points to the page
.afab	a0 00		ldy #$00			ldy 	#0
.afad					_GXSACopyLoop:
.afad	b1 36		lda ($36),y			lda 	(gxzTemp0),y
.afaf	99 7b 05	sta $057b,y			sta 	gxPixelBuffer,y
.afb2	c8		iny				iny
.afb3	cc 78 06	cpy $0678			cpy 	GXSizePixels
.afb6	d0 f5		bne $afad			bne 	_GXSACopyLoop
.afb8	60		rts				rts
.afb9					GXSelect:
.afb9	ad d5 05	lda $05d5			lda 	gxSpritesOn
.afbc	f0 22		beq $afe0			beq 	_GXSFail
.afbe	a5 36		lda $36				lda 	gxzTemp0 					; illegal sprite #
.afc0	c9 40		cmp #$40			cmp 	#64
.afc2	b0 1c		bcs $afe0			bcs 	_GXSFail
.afc4	8d e0 05	sta $05e0			sta 	GSCurrentSpriteID
.afc7	a4 37		ldy $37				ldy 	gxzTemp0+1 					; control value.
.afc9	a9 00		lda #$00			lda  	#0 							; multiply sprite # x 8 => A
.afcb	06 36		asl $36				asl 	gxzTemp0
.afcd	06 36		asl $36				asl 	gxzTemp0
.afcf	06 36		asl $36				asl 	gxzTemp0
.afd1	2a		rol a				rol 	a
.afd2	69 d9		adc #$d9			adc 	#$D9 						; sprite area
.afd4	8d e2 05	sta $05e2			sta 	GSCurrentSpriteAddr+1 		; address to GSCurrentSprite and gxzTemp
.afd7	85 37		sta $37				sta 	gxzTemp0+1
.afd9	a5 36		lda $36				lda 	gxzTemp0
.afdb	8d e1 05	sta $05e1			sta 	GSCurrentSpriteAddr
.afde	18		clc				clc
.afdf	60		rts				rts
.afe0					_GXSFail:
.afe0	38		sec				sec
.afe1	60		rts				rts
.afe2					GXSelectImage:
.afe2	ad d5 05	lda $05d5			lda 	gxSpritesOn
.afe5	f0 74		beq $b05b			beq 	_GXSIFail
.afe7	ad e2 05	lda $05e2			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.afea	f0 6f		beq $b05b			beq 	_GXSIFail 					; (checking the MSB)
.afec	64 01		stz $01				stz 	1
.afee	a5 37		lda $37				lda 	gxzTemp0+1 					; push show/hide on the stack.
.aff0	d0 6b		bne $b05d			bne 	_GXSIHide
.aff2	a5 36		lda $36				lda 	gxzTemp0 					; sprite image
.aff4	48		pha				pha
.aff5	20 e8 b0	jsr $b0e8			jsr 	GXOpenBitmap
.aff8	68		pla				pla
.aff9	20 c9 b1	jsr $b1c9			jsr 	GXFindSprite
.affc	b0 5a		bcs $b058			bcs 	_GXSICloseFail 				; no image
.affe	a0 01		ldy #$01			ldy 	#1
.b000	ad e1 05	lda $05e1			lda 	GSCurrentSpriteAddr
.b003	85 36		sta $36				sta 	gxzTemp0
.b005	ad e2 05	lda $05e2			lda 	GSCurrentSpriteAddr+1
.b008	85 37		sta $37				sta 	gxzTemp0+1
.b00a	ad 7b 06	lda $067b			lda 	GXSpriteOffset
.b00d	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b00f	18		clc				clc
.b010	ad 7c 06	lda $067c			lda 	GXSpriteOffset+1
.b013	6d e3 05	adc $05e3			adc 	GXSpriteOffsetBase
.b016	c8		iny				iny
.b017	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b019	ad e4 05	lda $05e4			lda 	GXSpriteOffsetBase+1
.b01c	69 00		adc #$00			adc 	#0
.b01e	c8		iny				iny
.b01f	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b021	ad 79 06	lda $0679			lda 	GXSizeBits 					; get raw size
.b024	49 03		eor #$03			eor 	#3 							; make it right (00=32 etc.)
.b026	2a		rol a				rol 	a 							; x 2
.b027	0a		asl a				asl 	a 							; x 4
.b028	0a		asl a				asl 	a 							; x 8
.b029	0a		asl a				asl 	a 							; x 16
.b02a	0d 7a 06	ora $067a			ora 	GXSpriteLUT 				; Or with LUT
.b02d	0a		asl a				asl 	a 							; 1 shift
.b02e	09 01		ora #$01			ora 	#1 							; enable sprite.
.b030	92 36		sta ($36)			sta 	(gxzTemp0) 					; and write back
.b032	20 f0 b0	jsr $b0f0			jsr 	GXCloseBitmap
.b035	ae e0 05	ldx $05e0			ldx 	GSCurrentSpriteID 			; point to sprite entries.
.b038	bd 25 06	lda $0625,x			lda 	GXSpriteHigh,x 				; clear upper two bits of size
.b03b	29 3f		and #$3f			and 	#$3F
.b03d	9d 25 06	sta $0625,x			sta 	GXSpriteHigh,x
.b040	ad 79 06	lda $0679			lda 	GXSizeBits 					; get bit size
.b043	6a		ror a				ror 	a 							; shift into bits 6/7
.b044	6a		ror a				ror 	a
.b045	6a		ror a				ror 	a
.b046	29 c0		and #$c0			and 	#$C0
.b048	1d 25 06	ora $0625,x			ora 	GXSpriteHigh,x 				; put in  upper 2 bits of sprite data
.b04b	9d 25 06	sta $0625,x			sta 	GXSpriteHigh,x
.b04e	bd e5 05	lda $05e5,x			lda 	GXSpriteLow,x 				; clear hidden flag.
.b051	29 7f		and #$7f			and 	#$7F
.b053	9d e5 05	sta $05e5,x			sta 	GXSpriteLow,x
.b056	18		clc				clc
.b057	60		rts				rts
.b058					_GXSICloseFail:
.b058	20 f0 b0	jsr $b0f0			jsr 	GXCloseBitmap
.b05b					_GXSIFail:
.b05b	38		sec				sec
.b05c	60		rts				rts
.b05d					_GXSIHide:
.b05d	ad e1 05	lda $05e1			lda 	GSCurrentSpriteAddr  		; get Sprite h/w address and write there
.b060	85 36		sta $36				sta 	gxzTemp0
.b062	ad e2 05	lda $05e2			lda 	GSCurrentSpriteAddr+1
.b065	85 37		sta $37				sta 	gxzTemp0+1
.b067	a9 00		lda #$00			lda 	#0
.b069	92 36		sta ($36)			sta 	(gxzTemp0)
.b06b	ae e0 05	ldx $05e0			ldx 	GSCurrentSpriteID 			; get sprite ID
.b06e	bd e5 05	lda $05e5,x			lda 	GXSpriteLow,x 				; set the hidden bit.
.b071	09 80		ora #$80			ora 	#$80
.b073	9d e5 05	sta $05e5,x			sta 	GXSpriteLow,x
.b076	18		clc				clc
.b077	60		rts				rts
.b078					GXMoveSprite:
.b078	ad d5 05	lda $05d5			lda 	gxSpritesOn
.b07b	f0 65		beq $b0e2			beq 	_GXSIFail
.b07d	ad e2 05	lda $05e2			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b080	f0 60		beq $b0e2			beq 	_GXSIFail
.b082	85 37		sta $37				sta 	gxzTemp0+1
.b084	a0 04		ldy #$04			ldy 	#4
.b086	ad e1 05	lda $05e1			lda 	GSCurrentSpriteAddr
.b089	85 36		sta $36				sta 	gxzTemp0
.b08b	ae e0 05	ldx $05e0			ldx 	GSCurrentSpriteID 			; get the size from the upper two bits
.b08e	bd 25 06	lda $0625,x			lda 	GXSpriteHigh,x
.b091	2a		rol a				rol 	a	 						; into bits 0,1.
.b092	2a		rol a				rol 	a
.b093	2a		rol a				rol 	a
.b094	29 03		and #$03			and 	#3
.b096	aa		tax				tax
.b097	bd e4 b0	lda $b0e4,x			lda 	_GXMSOffset,x 				; get 32-SpriteSize/2
.b09a	48		pha				pha
.b09b	18		clc				clc
.b09c	6d cd 05	adc $05cd			adc 	gxX0						; copy position.
.b09f	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b0a1	c8		iny				iny
.b0a2	ad ce 05	lda $05ce			lda 	gxX0+1
.b0a5	69 00		adc #$00			adc 	#0
.b0a7	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b0a9	c8		iny				iny
.b0aa	68		pla				pla
.b0ab	18		clc				clc
.b0ac	6d cf 05	adc $05cf			adc 	gxY0
.b0af	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b0b1	a9 00		lda #$00			lda 	#0
.b0b3	69 00		adc #$00			adc 	#0
.b0b5	c8		iny				iny
.b0b6	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b0b8	4e ce 05	lsr $05ce			lsr 	gxX0+1 						; divide X by 4
.b0bb	6e cd 05	ror $05cd			ror 	gxX0
.b0be	4e cd 05	lsr $05cd			lsr 	gxX0
.b0c1	4e cf 05	lsr $05cf			lsr 	gxY0 						; divide Y by 4
.b0c4	4e cf 05	lsr $05cf			lsr 	gxY0
.b0c7	ae e0 05	ldx $05e0			ldx 	GSCurrentSpriteID 			; copy X/4 and Y/4 into the status bytes
.b0ca	bd e5 05	lda $05e5,x			lda 	GXSpriteLow,x
.b0cd	29 80		and #$80			and 	#$80
.b0cf	0d cd 05	ora $05cd			ora 	gxX0
.b0d2	9d e5 05	sta $05e5,x			sta 	GXSpriteLow,x
.b0d5	bd 25 06	lda $0625,x			lda 	GXSpriteHigh,x
.b0d8	29 c0		and #$c0			and 	#$C0
.b0da	0d cf 05	ora $05cf			ora 	gxY0
.b0dd	9d 25 06	sta $0625,x			sta 	GXSpriteHigh,x
.b0e0	18		clc				clc
.b0e1	60		rts				rts
.b0e2					_GXSIFail:
.b0e2	38		sec				sec
.b0e3	60		rts				rts
.b0e4					_GXMSOffset:
>b0e4	1c						.byte 	32-8/2
>b0e5	18						.byte 	32-16/2
>b0e6	14						.byte 	32-24/2
>b0e7	10						.byte 	32-32/2
.b0e8					GXOpenBitmap:
.b0e8	78		sei				sei 								; no interrupts here
.b0e9	a5 0b		lda $0b				lda 	GXEditSlot 					; Save the original LUT slot value
.b0eb	8d de 05	sta $05de			sta 	gxOriginalLUTValue
.b0ee	58		cli				cli
.b0ef	60		rts				rts
.b0f0					GXCloseBitmap:
.b0f0	78		sei				sei
.b0f1	ad de 05	lda $05de			lda 	gxOriginalLUTValue 			; restore LUT slot value
.b0f4	85 0b		sta $0b				sta 	GXEditSlot
.b0f6	58		cli				cli
.b0f7	60		rts				rts
.b0f8					GXPositionCalc:
.b0f8	a5 36		lda $36				lda 	gxzTemp0 					; save temp memory slot
.b0fa	48		pha				pha
.b0fb	ad cf 05	lda $05cf			lda 	GXY0 						; gxzScreen = Y0
.b0fe	85 3c		sta $3c				sta 	gxzScreen
.b100	64 3d		stz $3d				stz 	gxzScreen+1
.b102	06 3c		asl $3c				asl 	gxzScreen 						; gxzScreen = Y0 * 4
.b104	26 3d		rol $3d				rol 	gxzScreen+1
.b106	06 3c		asl $3c				asl 	gxzScreen
.b108	26 3d		rol $3d				rol 	gxzScreen+1
.b10a	18		clc				clc 								; gxzScreen = Y0 * 5, as it's still in A
.b10b	65 3c		adc $3c				adc 	gxzScreen
.b10d	85 3c		sta $3c				sta 	gxzScreen
.b10f	90 02		bcc $b113			bcc 	_GXPCNoCarry
.b111	e6 3d		inc $3d				inc 	gxzScreen+1
.b113					_GXPCNoCarry:
.b113	06 3c		asl $3c				asl 	gxzScreen 						; now Y0 * 10. Needs to be multiplied by another
.b115	26 3d		rol $3d				rol 	gxzScreen+1 					; 32. At this point the MSB contains the offset
.b117	a5 3d		lda $3d				lda	 	gxzScreen+1 					; so save this in zTemp0 and zero it.
.b119	85 36		sta $36				sta 	gxzTemp0
.b11b	64 3d		stz $3d				stz 	gxzScreen+1
.b11d	a9 05		lda #$05			lda 	#5 							; now multiply by 32, this puts this in the range 0..8191
.b11f					_GXPCMultiply32:
.b11f	06 3c		asl $3c				asl 	gxzScreen
.b121	26 3d		rol $3d				rol 	gxzScreen+1
.b123	3a		dec a				dec 	a
.b124	d0 f9		bne $b11f			bne 	_GXPCMultiply32
.b126	18		clc				clc
.b127	ad cd 05	lda $05cd			lda 	GXX0 						; add X to this value, put the result in gsOffset, gxzScreen has to be on a page boundary
.b12a	65 3c		adc $3c				adc 	gxzScreen
.b12c	8d df 05	sta $05df			sta 	gsOffset
.b12f	ad ce 05	lda $05ce			lda 	GXX0+1
.b132	65 3d		adc $3d				adc 	gxzScreen+1
.b134	c9 20		cmp #$20			cmp 	#$20 						; has it overflowed into the next one ?
.b136	90 04		bcc $b13c			bcc 	_GXPCNoOverflow
.b138	29 1f		and #$1f			and 	#$1F 						; fix it up
.b13a	e6 36		inc $36				inc 	gxzTemp0 					; add 1 to the page number
.b13c					_GXPCNoOverflow:
.b13c	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; make it the address mapped in.
.b13e	85 3d		sta $3d				sta 	gxzScreen+1
.b140	64 3c		stz $3c				stz 	gxzScreen
.b142	18		clc				clc
.b143	a5 36		lda $36				lda 	gxzTemp0 					; get the page number
.b145	6d d7 05	adc $05d7			adc 	gxBasePage 					; by adding the base page
.b148	85 0b		sta $0b				sta 	GXEditSlot 				; and map it into memory.
.b14a	68		pla				pla
.b14b	85 36		sta $36				sta 	gxzTemp0
.b14d	60		rts				rts
.b14e					GXMovePositionDown:
.b14e	18		clc				clc 								; add 320 to offset/temp+1
.b14f	ad df 05	lda $05df			lda 	gsOffset
.b152	69 40		adc #$40			adc 	#64
.b154	8d df 05	sta $05df			sta 	gsOffset
.b157	a5 3d		lda $3d				lda 	gxzScreen+1
.b159	69 01		adc #$01			adc 	#1
.b15b	85 3d		sta $3d				sta 	gxzScreen+1
.b15d	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page
.b15f	90 07		bcc $b168			bcc 	_GXMPDExit
.b161	38		sec				sec  								; next page
.b162	e9 20		sbc #$20			sbc 	#$20
.b164	85 3d		sta $3d				sta 	gxzScreen+1
.b166	e6 0b		inc $0b				inc 	GXEditSlot
.b168					_GXMPDExit:
.b168	60		rts				rts
.b169					GXCollide:
.b169	a5 36		lda $36				lda 	gxzTemp0 					; check if sprite numbers are legal.
.b16b	aa		tax				tax
.b16c	05 37		ora $37				ora 	gxzTemp0+1
.b16e	29 c0		and #$c0			and 	#$C0
.b170	38		sec				sec
.b171	d0 53		bne $b1c6			bne 	_GXCollideFail 				; if either >= 64, fail.
.b173	a4 37		ldy $37				ldy 	gxzTemp0+1 					; at this point X is 1st sprite and Y is 2nd sprite.
.b175	b9 e5 05	lda $05e5,y			lda 	GXSpriteLow,y 				; check if either hidden bit is set
.b178	1d e5 05	ora $05e5,x			ora 	GXSpriteLow,x
.b17b	30 48		bmi $b1c5			bmi 	_GXOkayFail 				; if either hidden, then they cannot collide.
.b17d	18		clc				clc 								; need to calculate sum of sizes.
.b17e	b9 25 06	lda $0625,y			lda 	GXSpriteHigh,y
.b181	7d 25 06	adc $0625,x			adc 	GXSpriteHigh,x 				; at this point, CS, Bit 6 and 7 contain that sum.
.b184	29 c0		and #$c0			and 	#$C0 					 	; mask off
.b186	6a		ror a				ror 	a 							; 5/6/7
.b187	4a		lsr a				lsr 	a 							; 4/5/6
.b188	4a		lsr a				lsr 	a 							; 3/4/5
.b189	4a		lsr a				lsr 	a 							; 2/3/4
.b18a	18		clc				clc
.b18b	69 08		adc #$08			adc 	#$08
.b18d	4a		lsr a				lsr 	a 							; adjust because all coordinates are divided by 4 to store.
.b18e	4a		lsr a				lsr 	a
.b18f	85 38		sta $38				sta 	gxzTemp1 					; so the difference between the centres has to be less than this.
.b191	b9 25 06	lda $0625,y			lda 	GXSpriteHigh,y 				; calculate y1-y0
.b194	29 3f		and #$3f			and 	#$3F
.b196	85 39		sta $39				sta 	gxzTemp1+1
.b198	38		sec				sec
.b199	bd 25 06	lda $0625,x			lda 	GXSpriteHigh,x
.b19c	29 3f		and #$3f			and 	#$3F
.b19e	e5 39		sbc $39				sbc 	gxzTemp1+1
.b1a0	b0 03		bcs $b1a5			bcs 	_GXCAbs1 					; calculate |y1-y0|
.b1a2	49 ff		eor #$ff			eor 	#$FF
.b1a4	1a		inc a				inc 	a
.b1a5					_GXCAbs1:
.b1a5	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b1a7	b0 1c		bcs $b1c5			bcs 	_GXOkayFail
.b1a9	85 39		sta $39				sta 	gxzTemp1+1 					; save |y1-y0|
.b1ab	38		sec				sec 								; calculate |x1-x0|
.b1ac	b9 e5 05	lda $05e5,y			lda 	GXSpriteLow,y
.b1af	fd e5 05	sbc $05e5,x			sbc 	GXSpriteLow,x
.b1b2	b0 03		bcs $b1b7			bcs 	_GXCAbs2
.b1b4	49 ff		eor #$ff			eor 	#$FF
.b1b6	1a		inc a				inc 	a
.b1b7					_GXCAbs2:
.b1b7	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b1b9	b0 0a		bcs $b1c5			bcs 	_GXOkayFail
.b1bb	c5 39		cmp $39				cmp 	gxzTemp1+1 					; is it less than the previous one.
.b1bd	90 02		bcc $b1c1			bcc 	_GXCHaveLowest
.b1bf	a5 39		lda $39				lda 	gxzTemp1+1 					; if not, that's the smallest difference.
.b1c1					_GXCHaveLowest:
.b1c1	0a		asl a				asl 	a 							; scale to allow for >> 2
.b1c2	0a		asl a				asl 	a
.b1c3	18		clc				clc
.b1c4	60		rts				rts
.b1c5					_GXOkayFail:
.b1c5	18		clc				clc
.b1c6					_GXCollideFail:
.b1c6	a9 ff		lda #$ff			lda 	#$FF
.b1c8	60		rts				rts
.b1c9					GXFindSprite:
.b1c9	aa		tax				tax
.b1ca	ad d8 05	lda $05d8			lda 	GXSpritePage 				; access the base page of the sprite
.b1cd	85 0b		sta $0b				sta 	GXEditSlot
.b1cf	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; check a valid sprite
.b1d2	1d 00 60	ora $6000,x			ora 	GXMappingAddress,x
.b1d5	f0 33		beq $b20a			beq 	_GXFSFail
.b1d7	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; MSB
.b1da	8d 7c 06	sta $067c			sta 	GXSpriteOffset+1
.b1dd	bd 00 60	lda $6000,x			lda 	GXMappingAddress,x 			; LSB
.b1e0	48		pha				pha 								; save twice
.b1e1	48		pha				pha
.b1e2	29 03		and #$03			and 	#3 							; get sprite size
.b1e4	8d 79 06	sta $0679			sta 	GXSizeBits 					; save raw (0-3)
.b1e7	aa		tax				tax
.b1e8	bd 0c b2	lda $b20c,x			lda 	_GXFXSSTTable,x 			; read sprite size
.b1eb	8d 78 06	sta $0678			sta 	GXSizePixels 					; save (8/16/24/32)
.b1ee	68		pla				pla 								; get LUT
.b1ef	4a		lsr a				lsr		a
.b1f0	4a		lsr a				lsr		a
.b1f1	29 03		and #$03			and 	#3
.b1f3	8d 7a 06	sta $067a			sta 	GXSpriteLUT
.b1f6	68		pla				pla 								; address, neeeds to be x 4
.b1f7	29 f0		and #$f0			and 	#$F0
.b1f9	8d 7b 06	sta $067b			sta 	GXSpriteOffset
.b1fc	0e 7b 06	asl $067b			asl 	GXSpriteOffset
.b1ff	2e 7c 06	rol $067c			rol 	GXSpriteOffset+1
.b202	0e 7b 06	asl $067b			asl 	GXSpriteOffset
.b205	2e 7c 06	rol $067c			rol 	GXSpriteOffset+1
.b208	18		clc				clc
.b209	60		rts				rts
.b20a					_GXFSFail:
.b20a	38		sec				sec
.b20b	60		rts				rts
.b20c					_GXFXSSTTable:
>b20c	08 10 18 20					.byte 	8,16,24,32
.0678					GXSizePixels:
>0678							.fill 	1
.0679					GXSizeBits:
>0679							.fill 	1
.067a					GXSpriteLUT:
>067a							.fill 	1
.067b					GXSpriteOffset:
>067b							.fill 	2
.b210					GXSortXY:
.b210	20 2e b2	jsr $b22e			jsr 	GXSortY 					; will be sorted on Y now
.b213	ad cd 05	lda $05cd			lda 	gxX0 						; compare X0 v X1
.b216	cd d1 05	cmp $05d1			cmp 	gxX1
.b219	ad ce 05	lda $05ce			lda 	gXX0+1
.b21c	ed d2 05	sbc $05d2			sbc 	gXX1+1
.b21f	90 0c		bcc $b22d			bcc 	_GXSXYExit 					; X0 < X1 exit
.b221	a2 00		ldx #$00			ldx 	#0 							; swap them over
.b223	a0 04		ldy #$04			ldy 	#4
.b225	20 42 b2	jsr $b242			jsr 	GXSwapXY
.b228	e8		inx				inx
.b229	c8		iny				iny
.b22a	20 42 b2	jsr $b242			jsr 	GXSwapXY
.b22d					_GXSXYExit:
.b22d	60		rts				rts
.b22e					GXSortY:
.b22e	ad cf 05	lda $05cf			lda 	gxY0 						; if Y0 >= Y1
.b231	cd d3 05	cmp $05d3			cmp 	gxY1
.b234	90 0b		bcc $b241			bcc 	_GXSYSorted
.b236	a2 03		ldx #$03			ldx 	#3 							; swap 3-0
.b238	a0 07		ldy #$07			ldy 	#7 							; with 4-7
.b23a					_GXSwap1:
.b23a	20 42 b2	jsr $b242			jsr 	GXSwapXY
.b23d	88		dey				dey
.b23e	ca		dex				dex
.b23f	10 f9		bpl $b23a			bpl 	_GXSwap1
.b241					_GXSYSorted:
.b241	60		rts				rts
.b242					GXSwapXY:
.b242	bd cd 05	lda $05cd,x			lda 	gxX0,x
.b245	48		pha				pha
.b246	b9 cd 05	lda $05cd,y			lda 	gxX0,y
.b249	9d cd 05	sta $05cd,x			sta 	gxX0,x
.b24c	68		pla				pla
.b24d	99 cd 05	sta $05cd,y			sta 	gxX0,y
.b250	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_tokeniser.module

=1					tokeniserIntegrated=1
.b8d8					KeywordSet0:
>b8d8	00 65					.text	0,$65,""               ; $80 !0:EOF
>b8da	00 58					.text	0,$58,""               ; $81 !1:SH1
>b8dc	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b8de	04 fe 41 42 53 28			.text	4,$fe,"ABS("           ; $83 ABS(
>b8e4	06 93 41 4c 4c 4f 43 28			.text	6,$93,"ALLOC("         ; $84 ALLOC(
>b8ec	04 ff 41 53 43 28			.text	4,$ff,"ASC("           ; $85 ASC(
>b8f2	05 29 43 48 52 24 28			.text	5,$29,"CHR$("          ; $86 CHR$(
>b8f9	06 aa 45 56 45 4e 54 28			.text	6,$aa,"EVENT("         ; $87 EVENT(
>b901	05 6b 46 41 4c 53 45			.text	5,$6b,"FALSE"          ; $88 FALSE
>b908	05 44 46 52 41 43 28			.text	5,$44,"FRAC("          ; $89 FRAC(
>b90f	04 0d 48 49 54 28			.text	4,$0d,"HIT("           ; $8a HIT(
>b915	04 13 49 4e 54 28			.text	4,$13,"INT("           ; $8b INT(
>b91b	06 a7 49 53 56 41 4c 28			.text	6,$a7,"ISVAL("         ; $8c ISVAL(
>b923	05 5c 4a 4f 59 42 28			.text	5,$5c,"JOYB("          ; $8d JOYB(
>b92a	05 72 4a 4f 59 58 28			.text	5,$72,"JOYX("          ; $8e JOYX(
>b931	05 73 4a 4f 59 59 28			.text	5,$73,"JOYY("          ; $8f JOYY(
>b938	06 77 4c 45 46 54 24 28			.text	6,$77,"LEFT$("         ; $90 LEFT$(
>b940	04 07 4c 45 4e 28			.text	4,$07,"LEN("           ; $91 LEN(
>b946	04 0e 4d 41 58 28			.text	4,$0e,"MAX("           ; $92 MAX(
>b94c	05 26 4d 49 44 24 28			.text	5,$26,"MID$("          ; $93 MID$(
>b953	04 0c 4d 49 4e 28			.text	4,$0c,"MIN("           ; $94 MIN(
>b959	04 19 4e 4f 54 28			.text	4,$19,"NOT("           ; $95 NOT(
>b95f	08 3c 50 4c 41 59 49 4e			.text	8,$3c,"PLAYING("       ; $96 PLAYING(
>b967	47 28
>b969	07 e9 52 41 4e 44 4f 4d			.text	7,$e9,"RANDOM("        ; $97 RANDOM(
>b971	28
>b972	07 ca 52 49 47 48 54 24			.text	7,$ca,"RIGHT$("        ; $98 RIGHT$(
>b97a	28
>b97b	04 0c 52 4e 44 28			.text	4,$0c,"RND("           ; $99 RND(
>b981	04 10 53 47 4e 28			.text	4,$10,"SGN("           ; $9a SGN(
>b987	04 0e 53 50 43 28			.text	4,$0e,"SPC("           ; $9b SPC(
>b98d	05 45 53 54 52 24 28			.text	5,$45,"STR$("          ; $9c STR$(
>b994	06 a9 54 49 4d 45 52 28			.text	6,$a9,"TIMER("         ; $9d TIMER(
>b99c	04 40 54 52 55 45			.text	4,$40,"TRUE"           ; $9e TRUE
>b9a2	04 0b 56 41 4c 28			.text	4,$0b,"VAL("           ; $9f VAL(
>b9a8	03 e7 46 4f 52				.text	3,$e7,"FOR"            ; $a0 FOR
>b9ad	02 8f 49 46				.text	2,$8f,"IF"             ; $a1 IF
>b9b1	04 34 50 52 4f 43			.text	4,$34,"PROC"           ; $a2 PROC
>b9b7	06 c1 52 45 50 45 41 54			.text	6,$c1,"REPEAT"         ; $a3 REPEAT
>b9bf	05 79 57 48 49 4c 45			.text	5,$79,"WHILE"          ; $a4 WHILE
>b9c6	05 66 45 4e 44 49 46			.text	5,$66,"ENDIF"          ; $a5 ENDIF
>b9cd	07 0b 45 4e 44 50 52 4f			.text	7,$0b,"ENDPROC"        ; $a6 ENDPROC
>b9d5	43
>b9d6	04 3f 4e 45 58 54			.text	4,$3f,"NEXT"           ; $a7 NEXT
>b9dc	04 2f 54 48 45 4e			.text	4,$2f,"THEN"           ; $a8 THEN
>b9e2	05 8c 55 4e 54 49 4c			.text	5,$8c,"UNTIL"          ; $a9 UNTIL
>b9e9	04 2e 57 45 4e 44			.text	4,$2e,"WEND"           ; $aa WEND
>b9ef	02 9b 42 59				.text	2,$9b,"BY"             ; $ab BY
>b9f3	04 1c 43 41 4c 4c			.text	4,$1c,"CALL"           ; $ac CALL
>b9f9	06 b2 43 49 52 43 4c 45			.text	6,$b2,"CIRCLE"         ; $ad CIRCLE
>ba01	05 67 43 4c 45 41 52			.text	5,$67,"CLEAR"          ; $ae CLEAR
>ba08	03 e2 43 4c 53				.text	3,$e2,"CLS"            ; $af CLS
>ba0d	05 7f 43 4f 4c 4f 52			.text	5,$7f,"COLOR"          ; $b0 COLOR
>ba14	06 d4 43 4f 4c 4f 55 52			.text	6,$d4,"COLOUR"         ; $b1 COLOUR
>ba1c	04 1a 44 41 54 41			.text	4,$1a,"DATA"           ; $b2 DATA
>ba22	03 da 44 49 4d				.text	3,$da,"DIM"            ; $b3 DIM
>ba27	06 db 44 4f 57 4e 54 4f			.text	6,$db,"DOWNTO"         ; $b4 DOWNTO
>ba2f	04 29 45 4c 53 45			.text	4,$29,"ELSE"           ; $b5 ELSE
>ba35	04 34 46 52 4f 4d			.text	4,$34,"FROM"           ; $b6 FROM
>ba3b	03 e5 47 46 58				.text	3,$e5,"GFX"            ; $b7 GFX
>ba40	05 80 47 4f 53 55 42			.text	5,$80,"GOSUB"          ; $b8 GOSUB
>ba47	04 39 47 4f 54 4f			.text	4,$39,"GOTO"           ; $b9 GOTO
>ba4d	04 24 48 45 52 45			.text	4,$24,"HERE"           ; $ba HERE
>ba53	05 63 49 4d 41 47 45			.text	5,$63,"IMAGE"          ; $bb IMAGE
>ba5a	05 90 49 4e 50 55 54			.text	5,$90,"INPUT"          ; $bc INPUT
>ba61	03 e5 4c 45 54				.text	3,$e5,"LET"            ; $bd LET
>ba66	04 28 4c 49 4e 45			.text	4,$28,"LINE"           ; $be LINE
>ba6c	05 6b 4c 4f 43 41 4c			.text	5,$6b,"LOCAL"          ; $bf LOCAL
>ba73	03 db 4f 46 46				.text	3,$db,"OFF"            ; $c0 OFF
>ba78	02 9d 4f 4e				.text	2,$9d,"ON"             ; $c1 ON
>ba7c	07 20 4f 55 54 4c 49 4e			.text	7,$20,"OUTLINE"        ; $c2 OUTLINE
>ba84	45
>ba85	07 0f 50 41 4c 45 54 54			.text	7,$0f,"PALETTE"        ; $c3 PALETTE
>ba8d	45
>ba8e	04 3f 50 4c 4f 54			.text	4,$3f,"PLOT"           ; $c4 PLOT
>ba94	05 8d 50 52 49 4e 54			.text	5,$8d,"PRINT"          ; $c5 PRINT
>ba9b	04 1c 52 45 41 44			.text	4,$1c,"READ"           ; $c6 READ
>baa1	04 2e 52 45 43 54			.text	4,$2e,"RECT"           ; $c7 RECT
>baa7	03 e4 52 45 4d				.text	3,$e4,"REM"            ; $c8 REM
>baac	06 e0 52 45 54 55 52 4e			.text	6,$e0,"RETURN"         ; $c9 RETURN
>bab4	05 7b 53 4f 4c 49 44			.text	5,$7b,"SOLID"          ; $ca SOLID
>babb	05 89 53 4f 55 4e 44			.text	5,$89,"SOUND"          ; $cb SOUND
>bac2	06 d7 53 50 52 49 54 45			.text	6,$d7,"SPRITE"         ; $cc SPRITE
>baca	04 45 54 45 58 54			.text	4,$45,"TEXT"           ; $cd TEXT
>bad0	02 a3 54 4f				.text	2,$a3,"TO"             ; $ce TO
>bad4	ff					.text	$FF
.bad5					KeywordSet1:
>bad5	00 65					.text	0,$65,""               ; $80 !0:EOF
>bad7	00 58					.text	0,$58,""               ; $81 !1:SH1
>bad9	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>badb	08 4c 41 53 53 45 4d 42			.text	8,$4c,"ASSEMBLE"       ; $83 ASSEMBLE
>bae3	4c 45
>bae5	06 d2 41 53 53 45 52 54			.text	6,$d2,"ASSERT"         ; $84 ASSERT
>baed	06 bd 42 49 54 4d 41 50			.text	6,$bd,"BITMAP"         ; $85 BITMAP
>baf5	03 d7 45 4e 44				.text	3,$d7,"END"            ; $86 END
>bafa	02 96 47 4f				.text	2,$96,"GO"             ; $87 GO
>bafe	04 3c 4c 49 53 54			.text	4,$3c,"LIST"           ; $88 LIST
>bb04	04 20 4c 4f 41 44			.text	4,$20,"LOAD"           ; $89 LOAD
>bb0a	03 ea 4e 45 57				.text	3,$ea,"NEW"            ; $8a NEW
>bb0f	07 24 52 45 53 54 4f 52			.text	7,$24,"RESTORE"        ; $8b RESTORE
>bb17	45
>bb18	03 f5 52 55 4e				.text	3,$f5,"RUN"            ; $8c RUN
>bb1d	07 2a 53 50 52 49 54 45			.text	7,$2a,"SPRITES"        ; $8d SPRITES
>bb25	53
>bb26	04 46 53 54 4f 50			.text	4,$46,"STOP"           ; $8e STOP
>bb2c	ff					.text	$FF
.bb2d					KeywordSet2:
>bb2d	00 65					.text	0,$65,""               ; $80 !0:EOF
>bb2f	00 58					.text	0,$58,""               ; $81 !1:SH1
>bb31	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bb33	03 c8 41 44 43				.text	3,$c8,"ADC"            ; $83 ADC
>bb38	03 d3 41 4e 44				.text	3,$d3,"AND"            ; $84 AND
>bb3d	03 e0 41 53 4c				.text	3,$e0,"ASL"            ; $85 ASL
>bb42	03 c8 42 43 43				.text	3,$c8,"BCC"            ; $86 BCC
>bb47	03 d8 42 43 53				.text	3,$d8,"BCS"            ; $87 BCS
>bb4c	03 d8 42 45 51				.text	3,$d8,"BEQ"            ; $88 BEQ
>bb51	03 df 42 49 54				.text	3,$df,"BIT"            ; $89 BIT
>bb56	03 d8 42 4d 49				.text	3,$d8,"BMI"            ; $8a BMI
>bb5b	03 d5 42 4e 45				.text	3,$d5,"BNE"            ; $8b BNE
>bb60	03 de 42 50 4c				.text	3,$de,"BPL"            ; $8c BPL
>bb65	03 d5 42 52 41				.text	3,$d5,"BRA"            ; $8d BRA
>bb6a	03 df 42 52 4b				.text	3,$df,"BRK"            ; $8e BRK
>bb6f	03 db 42 56 43				.text	3,$db,"BVC"            ; $8f BVC
>bb74	03 eb 42 56 53				.text	3,$eb,"BVS"            ; $90 BVS
>bb79	03 d2 43 4c 43				.text	3,$d2,"CLC"            ; $91 CLC
>bb7e	03 d3 43 4c 44				.text	3,$d3,"CLD"            ; $92 CLD
>bb83	03 d8 43 4c 49				.text	3,$d8,"CLI"            ; $93 CLI
>bb88	03 e5 43 4c 56				.text	3,$e5,"CLV"            ; $94 CLV
>bb8d	03 e0 43 4d 50				.text	3,$e0,"CMP"            ; $95 CMP
>bb92	03 eb 43 50 58				.text	3,$eb,"CPX"            ; $96 CPX
>bb97	03 ec 43 50 59				.text	3,$ec,"CPY"            ; $97 CPY
>bb9c	03 cc 44 45 43				.text	3,$cc,"DEC"            ; $98 DEC
>bba1	03 e1 44 45 58				.text	3,$e1,"DEX"            ; $99 DEX
>bba6	03 e2 44 45 59				.text	3,$e2,"DEY"            ; $9a DEY
>bbab	03 e6 45 4f 52				.text	3,$e6,"EOR"            ; $9b EOR
>bbb0	03 da 49 4e 43				.text	3,$da,"INC"            ; $9c INC
>bbb5	03 ef 49 4e 58				.text	3,$ef,"INX"            ; $9d INX
>bbba	03 f0 49 4e 59				.text	3,$f0,"INY"            ; $9e INY
>bbbf	03 e7 4a 4d 50				.text	3,$e7,"JMP"            ; $9f JMP
>bbc4	03 ef 4a 53 52				.text	3,$ef,"JSR"            ; $a0 JSR
>bbc9	03 d1 4c 44 41				.text	3,$d1,"LDA"            ; $a1 LDA
>bbce	03 e8 4c 44 58				.text	3,$e8,"LDX"            ; $a2 LDX
>bbd3	03 e9 4c 44 59				.text	3,$e9,"LDY"            ; $a3 LDY
>bbd8	03 f1 4c 53 52				.text	3,$f1,"LSR"            ; $a4 LSR
>bbdd	03 ed 4e 4f 50				.text	3,$ed,"NOP"            ; $a5 NOP
>bbe2	03 e2 4f 52 41				.text	3,$e2,"ORA"            ; $a6 ORA
>bbe7	03 d9 50 48 41				.text	3,$d9,"PHA"            ; $a7 PHA
>bbec	03 e8 50 48 50				.text	3,$e8,"PHP"            ; $a8 PHP
>bbf1	03 f0 50 48 58				.text	3,$f0,"PHX"            ; $a9 PHX
>bbf6	03 f1 50 48 59				.text	3,$f1,"PHY"            ; $aa PHY
>bbfb	03 dd 50 4c 41				.text	3,$dd,"PLA"            ; $ab PLA
>bc00	03 ec 50 4c 50				.text	3,$ec,"PLP"            ; $ac PLP
>bc05	03 f4 50 4c 58				.text	3,$f4,"PLX"            ; $ad PLX
>bc0a	03 f5 50 4c 59				.text	3,$f5,"PLY"            ; $ae PLY
>bc0f	03 ed 52 4f 4c				.text	3,$ed,"ROL"            ; $af ROL
>bc14	03 f3 52 4f 52				.text	3,$f3,"ROR"            ; $b0 ROR
>bc19	03 ef 52 54 49				.text	3,$ef,"RTI"            ; $b1 RTI
>bc1e	03 f9 52 54 53				.text	3,$f9,"RTS"            ; $b2 RTS
>bc23	03 d8 53 42 43				.text	3,$d8,"SBC"            ; $b3 SBC
>bc28	03 db 53 45 43				.text	3,$db,"SEC"            ; $b4 SEC
>bc2d	03 dc 53 45 44				.text	3,$dc,"SED"            ; $b5 SED
>bc32	03 e1 53 45 49				.text	3,$e1,"SEI"            ; $b6 SEI
>bc37	03 e8 53 54 41				.text	3,$e8,"STA"            ; $b7 STA
>bc3c	03 f7 53 54 50				.text	3,$f7,"STP"            ; $b8 STP
>bc41	03 ff 53 54 58				.text	3,$ff,"STX"            ; $b9 STX
>bc46	03 00 53 54 59				.text	3,$00,"STY"            ; $ba STY
>bc4b	03 01 53 54 5a				.text	3,$01,"STZ"            ; $bb STZ
>bc50	03 ed 54 41 58				.text	3,$ed,"TAX"            ; $bc TAX
>bc55	03 ee 54 41 59				.text	3,$ee,"TAY"            ; $bd TAY
>bc5a	03 e8 54 52 42				.text	3,$e8,"TRB"            ; $be TRB
>bc5f	03 e9 54 53 42				.text	3,$e9,"TSB"            ; $bf TSB
>bc64	03 ff 54 53 58				.text	3,$ff,"TSX"            ; $c0 TSX
>bc69	03 ed 54 58 41				.text	3,$ed,"TXA"            ; $c1 TXA
>bc6e	03 ff 54 58 53				.text	3,$ff,"TXS"            ; $c2 TXS
>bc73	03 ee 54 59 41				.text	3,$ee,"TYA"            ; $c3 TYA
>bc78	ff					.text	$FF
.b251					ListConvertLine:
.b251	48		pha				pha 								; save indent on the stack
.b252	9c 1d 04	stz $041d			stz 	tbOffset
.b255	9c 2d 04	stz $042d			stz 	tokenBuffer
.b258	9c 29 04	stz $0429			stz 	currentListColour
.b25b	a0 02		ldy #$02			ldy 	#2 							; convert line number to string
.b25d	b1 30		lda ($30),y			lda 	(codePtr),y
.b25f	aa		tax				tax
.b260	88		dey				dey
.b261	b1 30		lda ($30),y			lda 	(codePtr),y
.b263	20 3c 92	jsr $923c			jsr 	LCLConvertInt16
.b266	85 36		sta $36				sta 	zTemp0 						; copy number into buffer
.b268	86 37		stx $37				stx 	zTemp0+1
.b26a	a9 8c		lda #$8c			lda 	#CLINumber+$80
.b26c	20 b1 b3	jsr $b3b1			jsr 	LCLWriteColour
.b26f	a0 00		ldy #$00			ldy 	#0
.b271					_LCCopyNumber:
.b271	b1 36		lda ($36),y			lda 	(zTemp0),y
.b273	20 ba b3	jsr $b3ba			jsr 	LCLWrite
.b276	c8		iny				iny
.b277	b1 36		lda ($36),y			lda 	(zTemp0),y
.b279	d0 f6		bne $b271			bne 	_LCCopyNumber
.b27b	68		pla				pla 								; adjustment to indent
.b27c	48		pha				pha 								; save on stack
.b27d	10 0c		bpl $b28b			bpl 	_LCNoAdjust 				; don't adjust indent if +ve, do after.
.b27f	18		clc				clc 								; add to list indent and make 0 if goes -ve.
.b280	6d 26 04	adc $0426			adc 	listIndent
.b283	8d 26 04	sta $0426			sta 	listIndent
.b286	10 03		bpl $b28b			bpl 	_LCNoAdjust
.b288	9c 26 04	stz $0426			stz 	listIndent
.b28b					_LCNoAdjust:
.b28b	18		clc				clc		 							; work out actual indent.
.b28c	ad 26 04	lda $0426			lda 	listIndent
.b28f	0a		asl a				asl 	a
.b290	69 06		adc #$06			adc 	#6
.b292	85 36		sta $36				sta 	zTemp0
.b294					_LCPadOut:
.b294	a9 20		lda #$20			lda 	#' '						; pad out to 6+indent characters
.b296	20 ba b3	jsr $b3ba			jsr 	LCLWrite
.b299	ad 1d 04	lda $041d			lda 	tbOffset
.b29c	c5 36		cmp $36				cmp 	zTemp0
.b29e	d0 f4		bne $b294			bne 	_LCPadOut
.b2a0	a0 03		ldy #$03			ldy 	#3 							; start position.
.b2a2					_LCMainLoop:
.b2a2	a9 8a		lda #$8a			lda 	#CLIPunctuation+$80
.b2a4	20 b1 b3	jsr $b3b1			jsr 	LCLWriteColour
.b2a7	b1 30		lda ($30),y			lda 	(codePtr),y
.b2a9	c9 80		cmp #$80			cmp 	#KWC_EOL 					; end of line ?
.b2ab	f0 17		beq $b2c4			beq 	_LCExit
.b2ad	c9 10		cmp #$10			cmp 	#16 						; 0-5 are the double punctuations
.b2af	90 1e		bcc $b2cf			bcc 	_LCDoubles
.b2b1	c9 20		cmp #$20			cmp 	#32 						; 16-31 are shifted punctuation from 64-91
.b2b3	90 2a		bcc $b2df			bcc 	_LCShiftPunc
.b2b5	c9 40		cmp #$40			cmp 	#64 						; 32-64 are as stored, punc and digits
.b2b7	90 35		bcc $b2ee			bcc 	_LCPunctuation
.b2b9	c9 80		cmp #$80			cmp 	#128 						; 64-127 are variable identifiers.
.b2bb	90 3e		bcc $b2fb			bcc 	_LCIdentifiers
.b2bd	c9 fe		cmp #$fe			cmp 	#254 						; 128-253 are tokenised words
.b2bf	90 5f		bcc $b320			bcc 	_LCTokens
.b2c1	4c 80 b3	jmp $b380			jmp 	_LCData 					; 254-5 are data objects
.b2c4					_LCExit:
.b2c4	68		pla				pla 								; get old indent adjust
.b2c5	30 07		bmi $b2ce			bmi 	_LCExit2
.b2c7	18		clc				clc 								; add to indent if +ve
.b2c8	6d 26 04	adc $0426			adc 	listIndent
.b2cb	8d 26 04	sta $0426			sta 	listIndent
.b2ce					_LCExit2:
.b2ce	60		rts				rts
.b2cf					_LCDoubles:
.b2cf	48		pha				pha
.b2d0	4a		lsr a				lsr 	a 							; put bit 2 into bit 1
.b2d1	29 02		and #$02			and 	#2
.b2d3	09 3c		ora #$3c			ora 	#60 						; make < >
.b2d5	20 ba b3	jsr $b3ba			jsr 	LCLWrite
.b2d8	68		pla				pla 								; restore, do lower bit
.b2d9	29 03		and #$03			and 	#3
.b2db	09 3c		ora #$3c			ora 	#60
.b2dd	80 0f		bra $b2ee			bra		_LCPunctuation 				; print, increment, loop
.b2df					_LCShiftPunc:
.b2df	aa		tax				tax 								; save in X
.b2e0	29 07		and #$07			and 	#7 							; lower 3 bits
.b2e2	f0 02		beq $b2e6			beq 	_LCNoAdd
.b2e4	09 18		ora #$18			ora 	#24 						; adds $18 to it.
.b2e6					_LCNoAdd:
.b2e6	e0 18		cpx #$18			cpx 	#24 						; if >= 24 add $20
.b2e8	90 02		bcc $b2ec			bcc 	_LCNoAdd2
.b2ea	09 20		ora #$20			ora 	#32 						; adds $20
.b2ec					_LCNoAdd2:
.b2ec	09 40		ora #$40			ora 	#$40 						; shift into 64-127 range and fall through.
.b2ee					_LCPunctuation:
.b2ee	c9 3a		cmp #$3a			cmp 	#':' 						; check if :
.b2f0	d0 03		bne $b2f5			bne 	_LCPContinue
.b2f2	20 d0 b3	jsr $b3d0			jsr 	LCLDeleteLastSpace 			; if so delete any preceding spaces
.b2f5					_LCPContinue:
.b2f5	c8		iny				iny 								; consume character
.b2f6	20 ba b3	jsr $b3ba			jsr 	LCLWrite 					; write it out.
.b2f9	80 a7		bra $b2a2			bra 	_LCMainLoop 				; go round again.
.b2fb					_LCIdentifiers:
.b2fb	18		clc				clc 								; convert to physical address
.b2fc	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.b2fe	85 37		sta $37				sta 	zTemp0+1
.b300	c8		iny				iny
.b301	b1 30		lda ($30),y			lda 	(codePtr),y
.b303	85 36		sta $36				sta 	zTemp0
.b305	c8		iny				iny
.b306	5a		phy				phy 								; save position
.b307	a9 87		lda #$87			lda 	#CLIIdentifier+$80
.b309	20 b1 b3	jsr $b3b1			jsr 	LCLWriteColour
.b30c	a0 07		ldy #$07			ldy 	#7 							; output the identifier at +8
.b30e					_LCOutIdentifier:
.b30e	c8		iny				iny
.b30f	b1 36		lda ($36),y			lda 	(zTemp0),y					; bit 7 set = end.
.b311	29 7f		and #$7f			and 	#$7F
.b313	20 0c b4	jsr $b40c			jsr 	LCLLowerCase
.b316	20 ba b3	jsr $b3ba			jsr 	LCLWrite
.b319	b1 36		lda ($36),y			lda 	(zTemp0),y				 	; ends when bit 7 set.
.b31b	10 f1		bpl $b30e			bpl 	_LCOutIdentifier
.b31d	7a		ply				ply 								; restore position
.b31e	80 82		bra $b2a2			bra 	_LCMainLoop
.b320					_LCTokens:
.b320	aa		tax				tax 								; token in X
.b321	a9 2d		lda #$2d			lda 	#((KeywordSet2) & $FF)
.b323	85 36		sta $36				sta 	0+zTemp0
.b325	a9 bb		lda #$bb			lda 	#((KeywordSet2) >> 8)
.b327	85 37		sta $37				sta 	1+zTemp0
.b329	e0 82		cpx #$82			cpx 	#$82
.b32b	f0 16		beq $b343			beq 	_LCUseShift
.b32d	a9 d5		lda #$d5			lda 	#((KeywordSet1) & $FF)
.b32f	85 36		sta $36				sta 	0+zTemp0
.b331	a9 ba		lda #$ba			lda 	#((KeywordSet1) >> 8)
.b333	85 37		sta $37				sta 	1+zTemp0
.b335	e0 81		cpx #$81			cpx 	#$81
.b337	f0 0a		beq $b343			beq 	_LCUseShift
.b339	a9 d8		lda #$d8			lda 	#((KeywordSet0) & $FF)
.b33b	85 36		sta $36				sta 	0+zTemp0
.b33d	a9 b8		lda #$b8			lda 	#((KeywordSet0) >> 8)
.b33f	85 37		sta $37				sta 	1+zTemp0
.b341	80 01		bra $b344			bra 	_LCNoShift
.b343					_LCUseShift:
.b343	c8		iny				iny
.b344					_LCNoShift:
.b344	20 e4 b3	jsr $b3e4			jsr 	LCLCheckSpaceRequired 		; do we need a space ?
.b347	b1 30		lda ($30),y			lda 	(codePtr),y
.b349	aa		tax				tax 								; into X
.b34a					_LCFindText:
.b34a	ca		dex				dex
.b34b	10 0e		bpl $b35b			bpl 	_LCFoundText 				; found text.
.b34d	b2 36		lda ($36)			lda 	(zTemp0) 					; length of text
.b34f	1a		inc a				inc 	a 							; one extra for size
.b350	38		sec				sec 								; one extra for checksum
.b351	65 36		adc $36				adc 	zTemp0 						; go to next token
.b353	85 36		sta $36				sta 	zTemp0
.b355	90 f3		bcc $b34a			bcc 	_LCFindText
.b357	e6 37		inc $37				inc 	zTemp0+1
.b359	80 ef		bra $b34a			bra 	_LCFindText
.b35b					_LCFoundText:
.b35b	5a		phy				phy 								; save List position
.b35c	b2 36		lda ($36)			lda 	(zTemp0)					; count to print
.b35e	aa		tax				tax
.b35f	a9 83		lda #$83			lda 	#CLIToken+$80
.b361	20 b1 b3	jsr $b3b1			jsr 	LCLWriteColour
.b364	a0 02		ldy #$02			ldy 	#2
.b366					_LCCopyToken:
.b366	b1 36		lda ($36),y			lda 	(zTemp0),y
.b368	20 0c b4	jsr $b40c			jsr 	LCLLowerCase
.b36b	20 ba b3	jsr $b3ba			jsr 	LCLWrite
.b36e	c8		iny				iny
.b36f	ca		dex				dex
.b370	d0 f4		bne $b366			bne 	_LCCopyToken
.b372	c9 28		cmp #$28			cmp 	#"(" 						; if last char not ( print a space
.b374	f0 05		beq $b37b			beq 	_LCNoSpace
.b376	a9 20		lda #$20			lda 	#' '
.b378	20 ba b3	jsr $b3ba			jsr 	LCLWrite
.b37b					_LCNoSpace:
.b37b	7a		ply				ply 								; restore position.
.b37c	c8		iny				iny 								; consume token
.b37d	4c a2 b2	jmp $b2a2			jmp 	_LCMainLoop 				; and go around again.
.b380					_LCData:
.b380	48		pha				pha 								; save type $FE/$FF
.b381	a2 24		ldx #$24			ldx 	#'$' 						; figure out $ or "
.b383	c9 fe		cmp #$fe			cmp 	#$FE
.b385	f0 07		beq $b38e			beq 	_LCHaveOpener
.b387	a2 22		ldx #$22			ldx 	#'"'
.b389	a9 81		lda #$81			lda 	#CLIData+$80
.b38b	20 b1 b3	jsr $b3b1			jsr 	LCLWriteColour
.b38e					_LCHaveOpener:
.b38e	8a		txa				txa 								; output prefix (# or ")
.b38f	20 ba b3	jsr $b3ba			jsr 	LCLWrite
.b392	c8		iny				iny 								; get count
.b393	b1 30		lda ($30),y			lda 	(codePtr),y
.b395	aa		tax				tax
.b396	c8		iny				iny 								; point at first character
.b397					_LCOutData:
.b397	b1 30		lda ($30),y			lda 	(codePtr),y
.b399	c9 00		cmp #$00			cmp 	#0
.b39b	f0 03		beq $b3a0			beq 	_LCNoPrint
.b39d	20 ba b3	jsr $b3ba			jsr 	LCLWrite
.b3a0					_LCNoPrint:
.b3a0	c8		iny				iny
.b3a1	ca		dex				dex
.b3a2	d0 f3		bne $b397			bne 	_LCOutData
.b3a4	68		pla				pla 								; closing " required ?
.b3a5	c9 ff		cmp #$ff			cmp 	#$FF 						; not required for hex constant.
.b3a7	d0 05		bne $b3ae			bne 	_LCNoQuote
.b3a9	a9 22		lda #$22			lda 	#'"'
.b3ab	20 ba b3	jsr $b3ba			jsr 	LCLWrite
.b3ae					_LCNoQuote:
.b3ae	4c a2 b2	jmp $b2a2			jmp 	_LCMainLoop
.b3b1					LCLWriteColour:
.b3b1	cd 29 04	cmp $0429			cmp 	currentListColour 			; has the colour changed
.b3b4	8d 29 04	sta $0429			sta 	currentListColour 			; (update it anyway)
.b3b7	d0 01		bne $b3ba			bne 	LCLWrite 					; if different, output it
.b3b9	60		rts				rts
.b3ba					LCLWrite:
.b3ba	da		phx				phx
.b3bb	ae 1d 04	ldx $041d			ldx 	tbOffset 					; write out make ASCIIZ
.b3be	9d 2d 04	sta $042d,x			sta 	tokenBuffer,x
.b3c1	9e 2e 04	stz $042e,x			stz 	tokenBuffer+1,x
.b3c4	ee 1d 04	inc $041d			inc 	tbOffset 					; bump the position
.b3c7	09 00		ora #$00			ora 	#0 							; don't update last character if colour data
.b3c9	30 03		bmi $b3ce			bmi 	_LCLNoColour
.b3cb	8d 27 04	sta $0427			sta 	LCLastCharacter
.b3ce					_LCLNoColour:
.b3ce	fa		plx				plx
.b3cf	60		rts				rts
.b3d0					LCLDeleteLastSpace:
.b3d0	48		pha				pha
.b3d1	da		phx				phx
.b3d2	ae 1d 04	ldx $041d			ldx 	tbOffset
.b3d5	f0 0a		beq $b3e1			beq 	_LCDLSExit
.b3d7	bd 2c 04	lda $042c,x			lda 	tokenBuffer-1,x
.b3da	c9 20		cmp #$20			cmp 	#' '
.b3dc	d0 03		bne $b3e1			bne 	_LCDLSExit
.b3de	ce 1d 04	dec $041d			dec 	tbOffset
.b3e1					_LCDLSExit:
.b3e1	fa		plx				plx
.b3e2	68		pla				pla
.b3e3	60		rts				rts
.b3e4					LCLCheckSpaceRequired:
.b3e4	ad 27 04	lda $0427			lda 	LCLastCharacter 			; check last character
.b3e7	c9 24		cmp #$24			cmp 	#'$' 						; $ # and ) require that token space.
.b3e9	f0 1b		beq $b406			beq 	_LCCSRSpace
.b3eb	c9 29		cmp #$29			cmp 	#')'
.b3ed	f0 17		beq $b406			beq 	_LCCSRSpace
.b3ef	c9 23		cmp #$23			cmp 	#'#'
.b3f1	f0 13		beq $b406			beq 	_LCCSRSpace
.b3f3	20 0c b4	jsr $b40c			jsr 	LCLLowerCase 				; saves a little effort
.b3f6	c9 30		cmp #$30			cmp 	#"0" 						; check if it was 0-9 A-Z a-z if so need space.
.b3f8	90 11		bcc $b40b			bcc 	_LCCSRExit
.b3fa	c9 3a		cmp #$3a			cmp 	#"9"+1
.b3fc	90 08		bcc $b406			bcc 	_LCCSRSpace
.b3fe	c9 61		cmp #$61			cmp 	#"a"
.b400	90 09		bcc $b40b			bcc 	_LCCSRExit
.b402	c9 7b		cmp #$7b			cmp 	#"z"+1
.b404	b0 05		bcs $b40b			bcs 	_LCCSRExit
.b406					_LCCSRSpace:
.b406	a9 20		lda #$20			lda 	#' '
.b408	20 ba b3	jsr $b3ba			jsr 	LCLWrite
.b40b					_LCCSRExit:
.b40b	60		rts				rts
.b40c					LCLLowerCase:
.b40c	c9 41		cmp #$41			cmp 	#"A"
.b40e	90 06		bcc $b416			bcc 	_LCLLCOut
.b410	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b412	b0 02		bcs $b416			bcs 	_LCLLCOut
.b414	69 20		adc #$20			adc 	#$20
.b416					_LCLLCOut:
.b416	60		rts				rts
.b417					LCLUpperCase:
.b417	c9 61		cmp #$61			cmp 	#"a"
.b419	90 06		bcc $b421			bcc 	_LCLUCOut
.b41b	c9 7b		cmp #$7b			cmp 	#"z"+1
.b41d	b0 02		bcs $b421			bcs 	_LCLUCOut
.b41f	e9 1f		sbc #$1f			sbc 	#$1F
.b421					_LCLUCOut:
.b421	60		rts				rts
.b422					TOKSearchTable:
.b422	84 37		sty $37				sty 	zTemp0+1 					; (zTemp0),y points to current token being tested.
.b424	85 36		sta $36				sta 	zTemp0
.b426	a0 00		ldy #$00			ldy 	#0
.b428	a9 80		lda #$80			lda 	#$80 						; token # so we know which one we are looking at
.b42a	85 38		sta $38				sta 	zTemp1
.b42c					_TSTLoop:
.b42c	b1 36		lda ($36),y			lda 	(zTemp0),y 					; length, 0 (skip) -ve (end)
.b42e	30 49		bmi $b479			bmi 	_TSTFail 					; -ve = end of table, so fail.
.b430	f0 2e		beq $b460			beq 	_TSTNext 					; zero, check next as it's a dummy (e.g. EOL, SHIFT)
.b432	c8		iny				iny 								; get the hash
.b433	b1 36		lda ($36),y			lda 	(zTemp0),y
.b435	88		dey				dey
.b436	cd 03 04	cmp $0403			cmp 	identHash 					; check they match with the identifier hash, if not go to next
.b439	d0 25		bne $b460			bne 	_TSTNext
.b43b	ad 02 04	lda $0402			lda 	identTypeEnd 				; get length of identifier from end-start
.b43e	38		sec				sec
.b43f	ed 00 04	sbc $0400			sbc 	identStart
.b442	d1 36		cmp ($36),y			cmp 	(zTemp0),y 					; compare against the length in the table, no match, then return.
.b444	d0 1a		bne $b460			bne 	_TSTNext
.b446	5a		phy				phy 								; save Y , we might fail to match.
.b447	c8		iny				iny 								; point to text
.b448	c8		iny				iny
.b449	ae 00 04	ldx $0400			ldx 	identStart 					; offset in line buffer in X
.b44c					_TSTCompareName:
.b44c	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; compare text.
.b44f	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.b451	d0 0c		bne $b45f			bne 	_TSTNextPullY 				; fail, pullY and do next
.b453	e8		inx				inx
.b454	c8		iny				iny
.b455	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; complete match.
.b458	d0 f2		bne $b44c			bne 	_TSTCompareName
.b45a	7a		ply				ply 								; throw Y
.b45b	a5 38		lda $38				lda 	zTemp1 						; get token #
.b45d	38		sec				sec 								; return with CS = passed.
.b45e	60		rts				rts
.b45f					_TSTNextPullY:
.b45f	7a		ply				ply 								; restore current, fall through.
.b460					_TSTNext:
.b460	e6 38		inc $38				inc 	zTemp1 						; token counter
.b462	98		tya				tya
.b463	18		clc				clc
.b464	71 36		adc ($36),y			adc 	(zTemp0),y 					; add [Length] + 2 to Y
.b466	1a		inc a				inc 	a 							; +1
.b467	1a		inc a				inc 	a 							; +2
.b468	a8		tay				tay
.b469	10 c1		bpl $b42c			bpl 	_TSTLoop 					; if Y < $80 loop back
.b46b	98		tya				tya 								; add Y to zTemp0 and reset Y
.b46c	a0 00		ldy #$00			ldy 	#0   						; so we can use Y to search fast
.b46e	18		clc				clc  								; but have tables > 255 bytes
.b46f	65 36		adc $36				adc 	zTemp0 						; when Y gets >= 128 we reset Y
.b471	85 36		sta $36				sta 	zTemp0 						; and adjust the table pointer/
.b473	90 b7		bcc $b42c			bcc 	_TSTLoop
.b475	e6 37		inc $37				inc 	zTemp0+1
.b477	80 b3		bra $b42c			bra 	_TSTLoop
.b479					_TSTFail:
.b479	18		clc				clc
.b47a	60		rts				rts
.b47b					TokeniseLine:
.b47b	20 03 b6	jsr $b603			jsr 	LCLFixLineBufferCase 		; fix line case
.b47e	a9 03		lda #$03			lda 	#3 							; reset the token buffer to empty
.b480	8d 2a 04	sta $042a			sta 	tokenOffset 				; (3 bytes for line number & offset)
.b483	9c 2b 04	stz $042b			stz 	tokenLineNumber
.b486	9c 2c 04	stz $042c			stz 	tokenLineNumber+1
.b489	a2 ff		ldx #$ff			ldx 	#$FF
.b48b					_TKFindFirst:
.b48b	e8		inx				inx
.b48c	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.b48f	f0 79		beq $b50a			beq 	_TKExit
.b491	c9 20		cmp #$20			cmp 	#' '
.b493	90 f6		bcc $b48b			bcc 	_TKFindFirst
.b495	c9 30		cmp #$30			cmp 	#'0'
.b497	90 07		bcc $b4a0			bcc 	_TKNoLineNumber
.b499	c9 3a		cmp #$3a			cmp 	#'9'+1
.b49b	b0 03		bcs $b4a0			bcs 	_TKNoLineNumber
.b49d	20 2d b6	jsr $b62d			jsr 	TOKExtractLineNumber
.b4a0					_TKNoLineNumber:
.b4a0					_TKTokeniseLoop:
.b4a0	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; next character, exit if zero EOL.
.b4a3	f0 65		beq $b50a			beq 	_TKExit
.b4a5	e8		inx				inx
.b4a6	c9 20		cmp #$20			cmp 	#' '
.b4a8	f0 f6		beq $b4a0			beq 	_TKTokeniseLoop 			; keep looping if space found.
.b4aa	ca		dex				dex 								; undo last get, A contains character, X is position.
.b4ab	c9 5f		cmp #$5f			cmp 	#'_'						; _ A-Z is identifier *or* token
.b4ad	f0 61		beq $b510			beq 	_TKTokeniseIdentifier 		; (already case converted outside string constants)
.b4af	c9 41		cmp #$41			cmp 	#'A'
.b4b1	90 04		bcc $b4b7			bcc 	_TKTokenisePunctuation
.b4b3	c9 5b		cmp #$5b			cmp 	#'Z'+1
.b4b5	90 59		bcc $b510			bcc 	_TKTokeniseIdentifier
.b4b7					_TKTokenisePunctuation:
.b4b7	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.b4b9	f0 27		beq $b4e2			beq 	_TKString
.b4bb	c9 24		cmp #$24			cmp 	#'$'						; hexadecimal constant ($ only appears at end of identifiers)
.b4bd	f0 28		beq $b4e7			beq 	_TKHexConstant
.b4bf	c9 3c		cmp #$3c			cmp 	#'<' 						; check for < > handlers - these are for <> <= >= >> <<
.b4c1	f0 29		beq $b4ec			beq 	_TKCheckDouble
.b4c3	c9 3e		cmp #$3e			cmp 	#'>'
.b4c5	f0 25		beq $b4ec			beq 	_TKCheckDouble
.b4c7					_TKStandardPunctuation:
.b4c7	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get the punctuation token back.
.b4ca	c9 40		cmp #$40			cmp 	#64 						; are we >= 64
.b4cc	90 0e		bcc $b4dc			bcc 	_TKNoShift
.b4ce	48		pha				pha 								; save. we are about to convert this punctuation token from
.b4cf	29 07		and #$07			and 	#7 							; lower 3 bits in zTemp0
.b4d1	85 36		sta $36				sta 	zTemp0
.b4d3	68		pla				pla
.b4d4	29 20		and #$20			and 	#32 						; bit 5
.b4d6	4a		lsr a				lsr 	a 							; shift into bit 3
.b4d7	4a		lsr a				lsr 	a
.b4d8	05 36		ora $36				ora 	zTemp0
.b4da	09 10		ora #$10			ora 	#$10						; now in the range 16-31
.b4dc					_TKNoShift:
.b4dc	20 72 b6	jsr $b672			jsr 	TOKWriteByte 				; write the punctuation character
.b4df	e8		inx				inx 								; consume the character
.b4e0	80 be		bra $b4a0			bra 	_TKTokeniseLoop 			; and loop round again.
.b4e2					_TKString:
.b4e2	20 92 b5	jsr $b592			jsr 	TOKTokenString
.b4e5	80 b9		bra $b4a0			bra 	_TKTokeniseLoop
.b4e7					_TKHexConstant:
.b4e7	20 cd b5	jsr $b5cd			jsr 	TOKHexConstant
.b4ea	80 b4		bra $b4a0			bra 	_TKTokeniseLoop
.b4ec					_TKCheckDouble:
.b4ec	bd 2b 05	lda $052b,x			lda 	lineBuffer+1,x 				; get next character
.b4ef	c9 3c		cmp #$3c			cmp 	#'<'						; if not < = > which are ASCII consecutive go back
.b4f1	90 d4		bcc $b4c7			bcc 	_TKStandardPunctuation 		; and do the normal punctuation handler.
.b4f3	c9 3f		cmp #$3f			cmp 	#'>'+1
.b4f5	b0 d0		bcs $b4c7			bcs 	_TKStandardPunctuation
.b4f7	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; this is < (60) or > (62)
.b4fa	29 02		and #$02			and 	#2 							; now < (0) or > (2)
.b4fc	0a		asl a				asl 	a 							; now < (0) or > (4), CC also
.b4fd	7d 2b 05	adc $052b,x			adc 	lineBuffer+1,x 				; add < = > codes - < code
.b500	38		sec				sec
.b501	e9 3c		sbc #$3c			sbc 	#'<'
.b503	20 72 b6	jsr $b672			jsr 	TOKWriteByte 				; this is in the range 0-7
.b506	e8		inx				inx 								; consume both
.b507	e8		inx				inx
.b508	80 96		bra $b4a0			bra 	_TKTokeniseLoop
.b50a	a9 80		lda #$80	_TKExit:lda 	#KWC_EOL 					; write end of line byte
.b50c	20 72 b6	jsr $b672			jsr 	TOKWriteByte
.b50f	60		rts				rts
.b510					_TKTokeniseIdentifier:
.b510	8e 00 04	stx $0400			stx 	identStart 					; save start
.b513	9c 04 04	stz $0404			stz 	identTypeByte 				; zero the type byte
.b516					_TKCheckLoop:
.b516	e8		inx				inx 								; look at next, we know first is identifier already.
.b517	bd 2a 05	lda $052a,x			lda  	lineBuffer,x
.b51a	c9 5f		cmp #$5f			cmp 	#"_" 						; legal char _ 0-9 A-Z
.b51c	f0 f8		beq $b516			beq 	_TKCheckLoop
.b51e	c9 30		cmp #$30			cmp	 	#"0"
.b520	90 0c		bcc $b52e			bcc 	_TKEndIdentifier
.b522	c9 3a		cmp #$3a			cmp 	#"9"+1
.b524	90 f0		bcc $b516			bcc 	_TKCheckLoop
.b526	c9 41		cmp #$41			cmp	 	#"A"
.b528	90 04		bcc $b52e			bcc 	_TKEndIdentifier
.b52a	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b52c	90 e8		bcc $b516			bcc 	_TKCheckLoop
.b52e					_TKEndIdentifier:
.b52e	8e 01 04	stx $0401			stx 	identTypeStart 				; save start of type text (if any !)
.b531	a0 08		ldy #$08			ldy 	#$08 						; this is the identifier type byte for #
.b533	c9 23		cmp #$23			cmp 	#"#"						; followed by #
.b535	f0 06		beq $b53d			beq 	_TKHasTypeCharacter
.b537	a0 10		ldy #$10			ldy 	#$10 						; this is the identifier type byte for $
.b539	c9 24		cmp #$24			cmp 	#"$"						; followed by $ or #
.b53b	d0 07		bne $b544			bne 	_TKNoTypeCharacter
.b53d					_TKHasTypeCharacter:
.b53d	8c 04 04	sty $0404			sty 	identTypeByte 				; has # or $, save the type
.b540	e8		inx				inx 								; consume the type character
.b541	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.b544					_TKNoTypeCharacter:
.b544	c9 28		cmp #$28			cmp 	#"("						; is it open parenthesis (e.g. array)
.b546	d0 09		bne $b551			bne 	_TKNoArray
.b548	e8		inx				inx 								; skip the (
.b549	ad 04 04	lda $0404			lda 	identTypeByte 				; set bit 2 (e.g. array) in type byte
.b54c	09 04		ora #$04			ora 	#$04
.b54e	8d 04 04	sta $0404			sta 	identTypeByte
.b551					_TKNoArray:
.b551	8e 02 04	stx $0402			stx 	identTypeEnd 				; save end marker, e.g. continue from here.
.b554	20 ee b5	jsr $b5ee			jsr 	TOKCalculateHash 			; calculate the has for those tokens
.b557	a0 b8		ldy #$b8			ldy 	#(KeywordSet0) >> 8
.b559	a9 d8		lda #$d8			lda 	#(KeywordSet0) & $FF
.b55b	20 22 b4	jsr $b422			jsr 	TOKSearchTable
.b55e	a2 00		ldx #$00			ldx 	#0
.b560	b0 1f		bcs $b581			bcs 	_TKFoundToken
.b562	a0 ba		ldy #$ba			ldy 	#(KeywordSet1) >> 8
.b564	a9 d5		lda #$d5			lda 	#(KeywordSet1) & $FF
.b566	20 22 b4	jsr $b422			jsr 	TOKSearchTable
.b569	a2 81		ldx #$81			ldx 	#$81
.b56b	b0 14		bcs $b581			bcs 	_TKFoundToken
.b56d	a0 bb		ldy #$bb			ldy 	#(KeywordSet2) >> 8
.b56f	a9 2d		lda #$2d			lda 	#(KeywordSet2) & $FF
.b571	20 22 b4	jsr $b422			jsr 	TOKSearchTable
.b574	a2 82		ldx #$82			ldx 	#$82
.b576	b0 09		bcs $b581			bcs 	_TKFoundToken
.b578	20 7e b6	jsr $b67e			jsr 	TOKCheckCreateVariableRecord ; failed all, it's a variable, create record if does not exist.
.b57b	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.b57e	4c a0 b4	jmp $b4a0			jmp 	_TKTokeniseLoop 			; and go round again.
.b581					_TKFoundToken:
.b581	48		pha				pha 								; save token
.b582	8a		txa				txa 								; shift in X, is there one ?
.b583	f0 03		beq $b588			beq 	_TKNoTShift
.b585	20 72 b6	jsr $b672			jsr 	TOKWriteByte 				; if so, write it out
.b588					_TKNoTShift:
.b588	68		pla				pla 								; restore and write token
.b589	20 72 b6	jsr $b672			jsr 	TOKWriteByte
.b58c	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.b58f	4c a0 b4	jmp $b4a0			jmp 	_TKTokeniseLoop 			; and go round again.
.b592					TOKTokenString:
.b592	a9 ff		lda #$ff			lda 	#KWC_STRING 				; string token.
.b594	20 72 b6	jsr $b672			jsr 	TOKWriteByte
.b597	e8		inx				inx									; start of quoted string.
.b598	da		phx				phx 								; push start of string on top
.b599	ca		dex				dex 								; because we pre-increment
.b59a					_TSFindEnd:
.b59a	e8		inx				inx
.b59b	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; next character
.b59e	f0 04		beq $b5a4			beq 	_TSEndOfString 				; no matching quote, we don't mind.
.b5a0	c9 22		cmp #$22			cmp 	#'"' 						; go back if quote not found
.b5a2	d0 f6		bne $b59a			bne 	_TSFindEnd
.b5a4					_TSEndOfString:
.b5a4	7a		ply				ply  								; so now Y is first character, X is character after end.
.b5a5	48		pha				pha 								; save terminating character
.b5a6	20 ae b5	jsr $b5ae			jsr 	TOKWriteBlockXY 			; write X to Y as a data block
.b5a9	68		pla				pla 								; terminating character
.b5aa	f0 01		beq $b5ad			beq 	_TSNotQuote					; if it wasn't EOS skip it
.b5ac	e8		inx				inx
.b5ad					_TSNotQuote:
.b5ad	60		rts				rts
.b5ae					TOKWriteBlockXY:
.b5ae	86 36		stx $36				stx 	zTemp0 						; save end character
.b5b0	98		tya				tya 								; use 2's complement to work out the byte size
.b5b1	49 ff		eor #$ff			eor 	#$FF
.b5b3	38		sec				sec
.b5b4	65 36		adc $36				adc 	zTemp0
.b5b6	1a		inc a				inc 	a 							; one extra for NULL
.b5b7	20 72 b6	jsr $b672			jsr 	TOKWriteByte
.b5ba					_TOBlockLoop:
.b5ba	c4 36		cpy $36				cpy 	zTemp0 						; exit if reached the end
.b5bc	f0 09		beq $b5c7			beq 	_TOBlockExit
.b5be	b9 2a 05	lda $052a,y			lda 	lineBuffer,y 				; write byte out.
.b5c1	20 72 b6	jsr $b672			jsr 	TOKWriteByte
.b5c4	c8		iny				iny
.b5c5	80 f3		bra $b5ba			bra 	_TOBlockLoop
.b5c7					_TOBlockExit:
.b5c7	a9 00		lda #$00			lda 	#0 							; add NULL.
.b5c9	20 72 b6	jsr $b672			jsr 	TOKWriteByte
.b5cc	60		rts				rts
.b5cd					TOKHexConstant:
.b5cd	a9 fe		lda #$fe			lda 	#KWC_HEXCONST 				; hex constant token.
.b5cf	20 72 b6	jsr $b672			jsr 	TOKWriteByte
.b5d2	e8		inx				inx									; start of quoted string.
.b5d3	da		phx				phx 								; push start of constant on top
.b5d4	ca		dex				dex
.b5d5					_THFindLoop:
.b5d5	e8		inx				inx 	 							; this is stored in a block, so find out how long
.b5d6	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; the hex constant is.
.b5d9	c9 30		cmp #$30			cmp 	#"0"
.b5db	90 0c		bcc $b5e9			bcc 	_THFoundEnd
.b5dd	c9 3a		cmp #$3a			cmp 	#"9"+1
.b5df	90 f4		bcc $b5d5			bcc 	_THFindLoop
.b5e1	c9 41		cmp #$41			cmp 	#"A"
.b5e3	90 04		bcc $b5e9			bcc 	_THFoundEnd
.b5e5	c9 47		cmp #$47			cmp 	#"F"+1
.b5e7	90 ec		bcc $b5d5			bcc 	_THFindLoop
.b5e9					_THFoundEnd:
.b5e9	7a		ply				ply 								; restore start
.b5ea	20 ae b5	jsr $b5ae			jsr 	TOKWriteBlockXY 			; output the block
.b5ed	60		rts				rts
.b5ee					TOKCalculateHash:
.b5ee	da		phx				phx
.b5ef	ae 00 04	ldx $0400			ldx 	identStart 					; needs to be same as in tokens.py - simple sum at present.
.b5f2	a9 00		lda #$00			lda 	#0
.b5f4					_TCHLoop:
.b5f4	18		clc				clc
.b5f5	7d 2a 05	adc $052a,x			adc 	lineBuffer,x
.b5f8	e8		inx				inx
.b5f9	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; do the whole thing including type and array markers.
.b5fc	d0 f6		bne $b5f4			bne 	_TCHLoop
.b5fe	8d 03 04	sta $0403			sta 	identHash 					; save the hash
.b601	fa		plx				plx
.b602	60		rts				rts
.b603					LCLFixLineBufferCase:
.b603	a2 00		ldx #$00			ldx 	#0
.b605					_FLBCLoop:
.b605	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get next character
.b608	f0 22		beq $b62c			beq 	_FLBCExit 					; end of string.
.b60a	c9 22		cmp #$22			cmp 	#'"'						; quote, go to in quotes
.b60c	f0 11		beq $b61f			beq 	_FLBCInQuotes
.b60e	e8		inx				inx
.b60f	c9 61		cmp #$61			cmp 	#'a'						; needs capitalising ?
.b611	90 f2		bcc $b605			bcc 	_FLBCLoop
.b613	c9 7b		cmp #$7b			cmp 	#'z'+1
.b615	b0 ee		bcs $b605			bcs 	_FLBCLoop
.b617	38		sec				sec 								; make U/C
.b618	e9 20		sbc #$20			sbc 	#32
.b61a	9d 29 05	sta $0529,x			sta	 	lineBuffer-1,x 				; write back
.b61d	80 e6		bra $b605			bra 	_FLBCLoop
.b61f					_FLBCInQuotes:
.b61f	e8		inx				inx 								; advance
.b620	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get next
.b623	f0 07		beq $b62c			beq 	_FLBCExit 					; exit on EOS
.b625	c9 22		cmp #$22			cmp 	#'"' 				 		; until " found
.b627	d0 f6		bne $b61f			bne 	_FLBCInQuotes
.b629	e8		inx				inx 								; skip over it
.b62a	80 d9		bra $b605			bra 	_FLBCLoop
.b62c					_FLBCExit:
.b62c	60		rts				rts
.b62d					TOKExtractLineNumber:
.b62d	ad 2c 04	lda $042c			lda 	tokenLineNumber+1 			; push current value on stack
.b630	48		pha				pha
.b631	ad 2b 04	lda $042b			lda 	tokenLineNumber
.b634	48		pha				pha
.b635	20 6b b6	jsr $b66b			jsr 	_LCLNTimes2 				; line # x 2
.b638	20 6b b6	jsr $b66b			jsr 	_LCLNTimes2 				; line # x 4
.b63b	18		clc				clc 								; add stacked value
.b63c	68		pla				pla
.b63d	6d 2b 04	adc $042b			adc 	tokenLineNumber
.b640	8d 2b 04	sta $042b			sta 	tokenLineNumber
.b643	68		pla				pla
.b644	6d 2c 04	adc $042c			adc 	tokenLineNumber+1
.b647	8d 2c 04	sta $042c			sta 	tokenLineNumber+1 			; line # x 5
.b64a	20 6b b6	jsr $b66b			jsr 	_LCLNTimes2 				; line # x 10
.b64d	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get and consume character
.b650	e8		inx				inx
.b651	29 0f		and #$0f			and 	#15 						; add to line #
.b653	18		clc				clc
.b654	6d 2b 04	adc $042b			adc 	tokenLineNumber
.b657	8d 2b 04	sta $042b			sta 	tokenLineNumber
.b65a	90 03		bcc $b65f			bcc 	_TLENNoCarry
.b65c	ee 2c 04	inc $042c			inc 	tokenLineNumber+1
.b65f					_TLENNoCarry:
.b65f	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; more digits ?
.b662	c9 30		cmp #$30			cmp 	#'0'
.b664	90 04		bcc $b66a			bcc 	_TLENExit
.b666	c9 3a		cmp #$3a			cmp 	#'9'+1
.b668	90 c3		bcc $b62d			bcc 	TOKExtractLineNumber
.b66a					_TLENExit:
.b66a	60		rts				rts
.b66b					_LCLNTimes2:
.b66b	0e 2b 04	asl $042b			asl 	tokenLineNumber 			; doubles tokenLineNumber.
.b66e	2e 2c 04	rol $042c			rol 	tokenLineNumber+1
.b671	60		rts				rts
.b672					TOKWriteByte:
.b672	da		phx				phx
.b673	ae 2a 04	ldx $042a			ldx 	tokenOffset 				; next slot to write to
.b676	9d 2a 04	sta $042a,x			sta 	tokenOffset,x 				; write byte out
.b679	ee 2a 04	inc $042a			inc 	tokenOffset 				; advance slot.
.b67c	fa		plx				plx
.b67d	60		rts				rts
.b67e					TOKCheckCreateVariableRecord:
.b67e	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.b680	85 36		sta $36				sta 	0+zTemp0
.b682	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.b684	85 37		sta $37				sta 	1+zTemp0
.b686					_CCVSearch:
.b686	b2 36		lda ($36)			lda 	(zTemp0) 					; end of list
.b688	f0 2c		beq $b6b6			beq 	_CCVFail
.b68a	a0 01		ldy #$01			ldy 	#1 							; read the hash
.b68c	b1 36		lda ($36),y			lda 	(zTemp0),y 					; does it match ?
.b68e	cd 03 04	cmp $0403			cmp 	identHash 	  				; if not, try the next.
.b691	d0 16		bne $b6a9			bne 	_CCVNext
.b693	a0 08		ldy #$08			ldy 	#8 							; name in variable record
.b695	ae 00 04	ldx $0400			ldx 	identStart
.b698					_CCVCompare:
.b698	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; xor them. zero if the same, except
.b69b	51 36		eor ($36),y			eor 	(zTemp0),y 					; bit 7 is used for EOS.
.b69d	e8		inx				inx 								; advance pointers
.b69e	c8		iny				iny
.b69f	0a		asl a				asl 	a 							; A = 0 if they match, CS if end.
.b6a0	d0 07		bne $b6a9			bne 	_CCVNext  					; didn't match go to next.
.b6a2	90 f4		bcc $b698			bcc 	_CCVCompare 				; not finished yet.
.b6a4	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; matched whole thing ?
.b6a7	f0 41		beq $b6ea			beq 	_CCVFound 					; yes, we were successful
.b6a9					_CCVNext:
.b6a9	18		clc				clc 								; go to next record.
.b6aa	b2 36		lda ($36)			lda 	(zTemp0) 					; add offset to pointer
.b6ac	65 36		adc $36				adc 	zTemp0
.b6ae	85 36		sta $36				sta 	zTemp0
.b6b0	90 d4		bcc $b686			bcc 	_CCVSearch
.b6b2	e6 37		inc $37				inc 	zTemp0+1
.b6b4	80 d0		bra $b686			bra 	_CCVSearch
.b6b6					_CCVFail:
.b6b6	a0 01		ldy #$01			ldy 	#1 							; create the new record. Offset 1 is hash
.b6b8	ad 03 04	lda $0403			lda 	identHash
.b6bb	91 36		sta ($36),y			sta 	(zTemp0),y
.b6bd	c8		iny				iny 								; offset 2 is the type byte
.b6be	ad 04 04	lda $0404			lda 	identTypeByte
.b6c1	91 36		sta ($36),y			sta 	(zTemp0),y
.b6c3	c8		iny				iny
.b6c4					_CCVData:
.b6c4	a9 00		lda #$00			lda 	#0 							; erase data 3-7 (the 5 value bytes)
.b6c6	91 36		sta ($36),y			sta 	(zTemp0),y
.b6c8	c8		iny				iny
.b6c9	c0 08		cpy #$08			cpy 	#8
.b6cb	90 f7		bcc $b6c4			bcc 	_CCVData
.b6cd	ae 00 04	ldx $0400			ldx 	identStart 					; copy name into 8 on.
.b6d0					_CCVCopyName:
.b6d0	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.b6d3	91 36		sta ($36),y			sta 	(zTemp0),y
.b6d5	e8		inx				inx
.b6d6	c8		iny				iny
.b6d7	ec 02 04	cpx $0402			cpx 	identTypeEnd
.b6da	d0 f4		bne $b6d0			bne 	_CCVCopyName
.b6dc	98		tya				tya 								; patch offset
.b6dd	92 36		sta ($36)			sta 	(zTemp0)
.b6df	a9 00		lda #$00			lda 	#0 							; offset for next is zero.
.b6e1	91 36		sta ($36),y			sta 	(zTemp0),y
.b6e3	88		dey				dey
.b6e4	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set bit 7 of last bit
.b6e6	09 80		ora #$80			ora 	#$80
.b6e8	91 36		sta ($36),y			sta 	(zTemp0),y
.b6ea					_CCVFound:
.b6ea	a5 37		lda $37				lda 	zTemp0+1 					; write out MSB
.b6ec	38		sec				sec
.b6ed	e9 10		sbc #$10			sbc 	#(VariableSpace >> 8) 		; offset from the start of the variable token
.b6ef	09 40		ora #$40			ora 	#$40 						; make it a writeable token $4000-$7FFF
.b6f1	20 72 b6	jsr $b672			jsr 	TOKWriteByte
.b6f4	a5 36		lda $36				lda 	zTemp0 						; write out LSB
.b6f6	20 72 b6	jsr $b672			jsr 	TOKWriteByte
.b6f9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_sound.module

=1					soundIntegrated=1
.b6fa					SNDCheckChannel:
.b6fa	aa		tax				tax
.b6fb	bd 8b 07	lda $078b,x			lda 	SNDTimeLeft,x 				; currently playing a note
.b6fe	d0 38		bne $b738			bne 	_SNDCCExit
.b700	da		phx				phx 								; save current channel
.b701	8a		txa				txa 								; put in A
.b702	20 7e b7	jsr $b77e			jsr 	SNDFindNextNoteForA 		; is there a note for A in the queue ?
.b705	68		pla				pla 								; channel # in A
.b706	90 30		bcc $b738			bcc 	_SNDCCExit  				; nothing in the queue for this channel, exit.
.b708	a8		tay				tay 								; Y is the channel #
.b709	bd 80 06	lda $0680,x			lda 	SNDQueue+1,x 				; copy data into the slot.
.b70c	99 7f 07	sta $077f,y			sta 	SNDPitchLow,y
.b70f	bd 81 06	lda $0681,x			lda 	SNDQueue+2,x
.b712	99 83 07	sta $0783,y			sta 	SNDPitchHigh,y
.b715	bd 82 06	lda $0682,x			lda 	SNDQueue+3,x
.b718	99 87 07	sta $0787,y			sta 	SNDVolume,y
.b71b	bd 83 06	lda $0683,x			lda 	SNDQueue+4,x
.b71e	99 8b 07	sta $078b,y			sta 	SNDTimeLeft,y
.b721	bd 84 06	lda $0684,x			lda 	SNDQueue+5,x
.b724	99 8f 07	sta $078f,y			sta 	SNDAdjustLow,y
.b727	bd 85 06	lda $0685,x			lda 	SNDQueue+6,x
.b72a	99 93 07	sta $0793,y			sta 	SNDAdjustHigh,y
.b72d	5a		phy				phy 								; save channel #
.b72e	20 98 b7	jsr $b798			jsr 	SNDDeleteXFromQueue 		; delete record at X from queue
.b731	ce 7e 06	dec $067e			dec 	SNDLength 					; reduce the queue length.
.b734	68		pla				pla
.b735	20 39 b7	jsr $b739			jsr 	SNDUpdateNote 				; update channel A
.b738					_SNDCCExit:
.b738	60		rts				rts
.b739					SNDUpdateNote:
.b739	aa		tax				tax 								; so we can access records
.b73a	0a		asl a				asl 	a 							; convert it to a channel bit pair in 5,6
.b73b	0a		asl a				asl 	a
.b73c	0a		asl a				asl 	a
.b73d	0a		asl a				asl 	a
.b73e	0a		asl a				asl 	a
.b73f	8d 7d 06	sta $067d			sta 	SNDChannelBits
.b742	bd 8b 07	lda $078b,x			lda 	SNDTimeLeft,x 				; are we silent
.b745	f0 2e		beq $b775			beq 	_SNDUNIsSilent
.b747	ad 7d 06	lda $067d			lda 	SNDChannelBits 				; push channel bits on stack
.b74a	48		pha				pha
.b74b	bd 7f 07	lda $077f,x			lda 	SNDPitchLow,x 				; get 4 lowest bits of pitch.
.b74e	29 0f		and #$0f			and 	#$0F
.b750	0d 7d 06	ora $067d			ora 	SNDChannelBits 				; set channel bits
.b753	09 80		ora #$80			ora 	#$80 						; write to pitch register
.b755	20 e2 b7	jsr $b7e2			jsr 	SNDWritePorts
.b758	bd 83 07	lda $0783,x			lda 	SNDPitchHigh,x 				; pitch high => channel temp.
.b75b	8d 7d 06	sta $067d			sta 	SNDChannelBits
.b75e	bd 7f 07	lda $077f,x			lda 	SNDPitchLow,x
.b761	4e 7d 06	lsr $067d			lsr 	SNDChannelBits 				; shift 2 LSBs into MSB of A
.b764	6a		ror a				ror 	a
.b765	4e 7d 06	lsr $067d			lsr 	SNDChannelBits
.b768	6a		ror a				ror 	a
.b769	4a		lsr a				lsr 	a 							; put in bits 0-5
.b76a	4a		lsr a				lsr 	a
.b76b	20 e2 b7	jsr $b7e2			jsr 	SNDWritePorts 				; write as rest of pitch register
.b76e	68		pla				pla
.b76f	09 90		ora #$90			ora 	#$90 						; set to write minimum attentuation.
.b771	20 e2 b7	jsr $b7e2			jsr 	SNDWritePorts
.b774	60		rts				rts
.b775					_SNDUNIsSilent:
.b775	ad 7d 06	lda $067d			lda 	SNDChannelBits 				; channel bits
.b778	09 9f		ora #$9f			ora 	#$9F 						; maximum attenuation
.b77a	20 e2 b7	jsr $b7e2			jsr 	SNDWritePorts 				; write to the ports
.b77d	60		rts				rts
.b77e					SNDFindNextNoteForA:
.b77e	ac 7e 06	ldy $067e			ldy 	SNDLength 					; queue size into Y
.b781	f0 13		beq $b796			beq 	_SNDFNNFail 				; queue empty.
.b783	a2 00		ldx #$00			ldx 	#0
.b785					_SNDFNNSearch:
.b785	dd 7f 06	cmp $067f,x			cmp 	SNDQueue,x 					; does it match the channel
.b788	38		sec				sec
.b789	f0 0c		beq $b797			beq 	_SNDFNNExit 				; if so exit with CS.
.b78b	e8		inx				inx 								; next queue slot.
.b78c	e8		inx				inx
.b78d	e8		inx				inx
.b78e	e8		inx				inx
.b78f	e8		inx				inx
.b790	e8		inx				inx
.b791	e8		inx				inx
.b792	e8		inx				inx
.b793	88		dey				dey 								; done the whole queue
.b794	d0 ef		bne $b785			bne 	_SNDFNNSearch 				; no, go back.
.b796					_SNDFNNFail:
.b796	18		clc				clc
.b797					_SNDFNNexit:
.b797	60		rts				rts
.b798					SNDDeleteXFromQueue:
.b798	e0 f8		cpx #$f8			cpx 	#SNDQueueSize*8-8 			; reached the end.
.b79a	f0 09		beq $b7a5			beq 	_SNDDXExit
.b79c	bd 87 06	lda $0687,x			lda 	SNDQueue+8,x
.b79f	9d 7f 06	sta $067f,x			sta 	SNDQueue,x
.b7a2	e8		inx				inx
.b7a3	80 f3		bra $b798			bra 	SNDDeleteXFromQueue
.b7a5					_SNDDXExit:
.b7a5	60		rts				rts
.067d					SNDChannelBits:
>067d							.fill 	1
.b7a6					SNDQueueRequest:
.b7a6	86 36		stx $36				stx 	zTemp0						; save queue address
.b7a8	84 37		sty $37				sty 	zTemp0+1
.b7aa	ae 7e 06	ldx $067e			ldx 	SNDLength 					; queue is full, can't take any more.
.b7ad	e0 20		cpx #$20			cpx 	#SNDQueueSize
.b7af	f0 21		beq $b7d2			beq 	_SNDQRExit
.b7b1	29 03		and #$03			and 	#3	 						; channel # and push on stack
.b7b3	48		pha				pha
.b7b4	8a		txa				txa  								; get offset in queue buffer/
.b7b5	0a		asl a				asl 	a
.b7b6	0a		asl a				asl 	a
.b7b7	0a		asl a				asl 	a
.b7b8	aa		tax				tax
.b7b9	68		pla				pla 								; get back and push again
.b7ba	48		pha				pha
.b7bb	9d 7f 06	sta $067f,x			sta 	SNDQueue+0,x 				; save the channel #
.b7be	a0 00		ldy #$00			ldy 	#0 							; copy the rest in.
.b7c0					_SNDQCopy:
.b7c0	b1 36		lda ($36),y			lda 	(zTemp0),y
.b7c2	e8		inx				inx
.b7c3	c8		iny				iny
.b7c4	9d 7f 06	sta $067f,x			sta 	SNDQueue,x
.b7c7	c0 06		cpy #$06			cpy 	#6
.b7c9	d0 f5		bne $b7c0			bne 	_SNDQCopy
.b7cb	ee 7e 06	inc $067e			inc 	SNDLength 					; bump queue length.
.b7ce	68		pla				pla 								; get channel # back
.b7cf	20 fa b6	jsr $b6fa			jsr 	SNDCheckChannel 			; check if channel needs refreshing.
.b7d2					_SNDQRExit:
.b7d2	60		rts				rts
.b7d3					SNDSilenceChannel:
.b7d3	aa		tax				tax 								; zero time left.
.b7d4	9e 8b 07	stz $078b,x			stz 	SNDTimeLeft,x
.b7d7	0a		asl a				asl 	a 							; shift into position
.b7d8	0a		asl a				asl 	a
.b7d9	0a		asl a				asl 	a
.b7da	0a		asl a				asl 	a
.b7db	0a		asl a				asl 	a
.b7dc	09 9f		ora #$9f			ora 	#$9F 						; write register attenuation $F
.b7de	20 e2 b7	jsr $b7e2			jsr 	SNDWritePorts
.b7e1	60		rts				rts
.b7e2					SNDWritePorts:
.b7e2	da		phx				phx 								; save X
.b7e3	a6 01		ldx $01				ldx 	1 							; save I/O status
.b7e5	64 01		stz $01				stz 	1 							; access I/O page 0
.b7e7	8d 00 d6	sta $d600			sta 	$D600 						; write to both
.b7ea	8d 10 d6	sta $d610			sta 	$D610
.b7ed	86 01		stx $01				stx 	1 							; restore I/O
.b7ef	fa		plx				plx 								; restore X
.b7f0	60		rts				rts
.b7f1					SNDCommand:
.b7f1	da		phx				phx 								; save XY
.b7f2	5a		phy				phy
.b7f3	c9 0f		cmp #$0f			cmp 	#$0F 						; $0F is initialise
.b7f5	f0 1d		beq $b814			beq 	_SNDInitialise
.b7f7	90 28		bcc $b821			bcc 	_SNDExit
.b7f9	c9 3f		cmp #$3f			cmp 	#$3F 						; $3F is silence all
.b7fb	f0 17		beq $b814			beq 	_SNDSilence
.b7fd	b0 22		bcs $b821			bcs 	_SNDExit
.b7ff	c9 20		cmp #$20			cmp 	#$20 						; $2x is check playing => A
.b801	b0 09		bcs $b80c			bcs 	_SNDQueryPlay
.b803	c9 14		cmp #$14			cmp 	#$14 						; $10-$13 is queue sound
.b805	b0 1a		bcs $b821			bcs 	_SNDExit
.b807	20 a6 b7	jsr $b7a6			jsr 	SNDQueueRequest
.b80a	80 15		bra $b821			bra 	_SNDExit
.b80c					_SNDQueryPlay:
.b80c	29 03		and #$03			and 	#3 							; get channel #
.b80e	aa		tax				tax
.b80f	bd 8b 07	lda $078b,x			lda 	SNDTimeLeft,x 				; read time left, if zero then silent
.b812	80 0d		bra $b821			bra 	_SNDExit
.b814					_SNDInitialise:
.b814					_SNDSilence:
.b814	9c 7e 06	stz $067e			stz 	SNDLength 					; empty the queue.
.b817	a9 03		lda #$03			lda 	#$3 						; silence channel 0-3.
.b819					_SNDSilenceLoop:
.b819	48		pha				pha
.b81a	20 d3 b7	jsr $b7d3			jsr 	SNDSilenceChannel
.b81d	68		pla				pla
.b81e	3a		dec a				dec 	a
.b81f	10 f8		bpl $b819			bpl 	_SNDSilenceLoop
.b821					_SNDExit:
.b821	7a		ply				ply
.b822	fa		plx				plx
.b823	60		rts				rts
=32					SNDQueueSize = 32 							; number of queue entries
.067e					SNDLength:
>067e							.fill 	1
.067f					SNDQueue:
>067f							.fill 	SNDQueueSize * 8
.077f					SNDPitchLow:
>077f							.fill 	4
.0783					SNDPitchHigh:
>0783							.fill 	4
.0787					SNDVolume:
>0787							.fill 	4
.078b					SNDTimeLeft:
>078b							.fill 	4
.078f					SNDAdjustLow:
>078f							.fill 	4
.0793					SNDAdjustHigh:
>0793							.fill 	4
.b824					SNDUpdate:
.b824	ad 8b 07	lda $078b			lda 	SNDTimeLeft+0 				; look at time remaining
.b827	f0 05		beq $b82e			beq 	_SNDUNot0 					; not playing
.b829	a2 00		ldx #$00			ldx 	#0 							; so we know which channel to update
.b82b	20 4d b8	jsr $b84d			jsr 	SNDUpdateChannel 			; update it.
.b82e					_SNDUNot0:
.b82e	ad 8c 07	lda $078c			lda 	SNDTimeLeft+1
.b831	f0 05		beq $b838			beq 	_SNDUNot1
.b833	a2 01		ldx #$01			ldx 	#1
.b835	20 4d b8	jsr $b84d			jsr 	SNDUpdateChannel
.b838					_SNDUNot1:
.b838	ad 8d 07	lda $078d			lda 	SNDTimeLeft+2
.b83b	f0 05		beq $b842			beq 	_SNDUNot2
.b83d	a2 02		ldx #$02			ldx 	#2
.b83f	20 4d b8	jsr $b84d			jsr 	SNDUpdateChannel
.b842					_SNDUNot2:
.b842	ad 8e 07	lda $078e			lda 	SNDTimeLeft+3
.b845	f0 05		beq $b84c			beq 	_SNDUNot3
.b847	a2 03		ldx #$03			ldx 	#3
.b849	20 4d b8	jsr $b84d			jsr 	SNDUpdateChannel
.b84c					_SNDUNot3:
.b84c	60		rts				rts
.b84d					SNDUpdateChannel:
.b84d	c9 ff		cmp #$ff			cmp 	#$FF 						; sound $FF play forever until turned off manually
.b84f	f0 2c		beq $b87d			beq 	_SNDUCExit
.b851	3a		dec a				dec 	a 							; decrement and update timer
.b852	9d 8b 07	sta $078b,x			sta 	SNDTimeLeft,x
.b855	f0 1d		beq $b874			beq 	_SNDUCUpdate 				; if zero, silence channel
.b857	bd 8f 07	lda $078f,x			lda 	SNDAdjustLow,x 				; adjust ?
.b85a	1d 93 07	ora $0793,x			ora 	SNDAdjustHigh,x
.b85d	f0 1e		beq $b87d			beq 	_SNDUCExit 					; if zero carry on at current tone.
.b85f	18		clc				clc 								; add adjust, forcing into a 10 bit range
.b860	bd 7f 07	lda $077f,x			lda 	SNDPitchLow,x
.b863	7d 8f 07	adc $078f,x			adc 	SNDAdjustLow,x
.b866	9d 7f 07	sta $077f,x			sta 	SNDPitchLow,x
.b869	bd 83 07	lda $0783,x			lda 	SNDPitchHigh,x
.b86c	7d 93 07	adc $0793,x			adc 	SNDAdjustHigh,x
.b86f	29 03		and #$03			and 	#3
.b871	9d 83 07	sta $0783,x			sta 	SNDPitchHigh,x
.b874					_SNDUCUpdate:
.b874	8a		txa				txa 								; which channel.
.b875	48		pha				pha
.b876	20 39 b7	jsr $b739			jsr 	SNDUpdateNote 				; update the current note
.b879	68		pla				pla
.b87a	20 fa b6	jsr $b6fa			jsr 	SNDCheckChannel 			; more to do ?
.b87d					_SNDUCExit:
.b87d	60		rts				rts

;******  Return to file: _basic.asm


;******  End of listing
