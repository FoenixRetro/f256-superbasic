
; 64tass Turbo Assembler Macro V1.57.2900 listing file
; 64tass -D AUTORUN=0 "-D MONITOR_ADDRESS=\$E000" "-D LOCKOUT_ADDRESS=\$F000" "-D BASIC_ADDRESS=\$38000" "-D SOURCE_ADDRESS=\$3000" "-D SPRITE_ADDRESS=\$30000" -q -b -Wall -c -D "HARDWARE=0 $'\x9'$'\x9'$'\x9'$'\x9'$'\x9'$'\x9'" -L output/basic.lst -l output/basic.lbl -Wall -o basic.rom _basic.asm
; Thu Dec  1 10:43:40 2022

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=0					AUTORUN=0
=$e000					 MONITOR_ADDRESS=$E000
=$f000					 LOCKOUT_ADDRESS=$F000
=$38000					 BASIC_ADDRESS=$38000
=$3000					 SOURCE_ADDRESS=$3000
=$30000					 SPRITE_ADDRESS=$30000
=0					HARDWARE=0

;******  Processing input file: _basic.asm


;******  Processing file: ./common/aa.system/01common.inc

=$30					ZeroPageMandatory = $30
=$50					ZeroPagePreference = $50
=$400					MemoryStorage = $400
=$2000					BasicStart = $2000
=$8000					BasicEnd = $8000
=$8000					CodeStart = $8000
=$1000					VariableSpace = $1000
=$2000					EndVariableSpace = $2000
=8					MathStackSize = 8
=512					BasicStackSize = 512
=3584					BasicStackBase = $1000-BasicStackSize
=80					MaxLineSize = 80

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/02macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/04data.inc

.0030					codePtr:
>0030							.fill 	4
.0034					basicStack:
>0034							.fill 	2
.0036					zTemp0:
>0036							.fill 	2
.0038					zTemp1:
>0038							.fill 	2
.003a					zTemp2:
>003a							.fill 	2
.003c					zsTemp:
>003c							.fill 	2
.003e					zaTemp:
>003e							.fill 	2
=$30					safePtr = codePtr 							; minimise direct tinkering
=$80					NSBIsNegative = $80 						; bit 7 : sign of mantissa (where numeric)
=$20					NSBIsReference = $20 						; bit 5 : is a reference
=$10					NSBIsString = $10 							; bit 4 : set if string (procedures don't go on the stack)
=$18					NSBTypeMask = $18 							; bits 4,3 : 00 int 01 float 10 string 11 procedure
=$03					NSBRefMask = $03 							; bits 0,1 : Bytes of reference, -1 (e.g. 00 = 1 byte, 11 = 4 bytes)
=$04					NSBIsArray = $04
=$00					NSTInteger = $00 							; base types for bits 3..4
=$08					NSTFloat = $08
=$10					NSTString = $10
=$18					NSTProcedure = $18
.0050					NSStatus:
>0050							.fill 	MathStackSize
.0058					NSMantissa0:
>0058							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0060					NSMantissa1:
>0060							.fill 	MathStackSize
.0068					NSMantissa2:
>0068							.fill 	MathStackSize
.0070					NSMantissa3:
>0070							.fill 	MathStackSize
.0078					NSExponent:
>0078							.fill 	MathStackSize
.0400					identStart:
>0400							.fill 	1
.0401					identTypeStart:
>0401							.fill 	1
.0402					identTypeEnd:
>0402							.fill 	1
.0403					identHash:
>0403							.fill 	1
.0404					identTypeByte:
>0404							.fill 	1	 						; (see tokenising.pdf)
.0405					encodeState:
>0405							.fill 	1
.0406					digitTemp:
>0406							.fill 	1
.0407					decimalCount:
>0407							.fill 	1
.0408					randomSeed:
>0408							.fill 	4
.040c					lowMemPtr:
>040c							.fill 	2
.040e					stringMemory:
>040e							.fill 	2
.0410					stringInitialised:
>0410							.fill 	1
.0411					stringTempPointer:
>0411							.fill 	2
.0413					breakCheck:
>0413							.fill 	1
.0414					decimalPlaces:
>0414							.fill 	1
.0415					dbOffset:
>0415							.fill 	1
.0416					lastParameter:
>0416							.fill 	1
.0417					dataPointer:
>0417							.fill 	5
.041c					inDataStatement:
>041c							.fill 	1
.041d					tbOffset:
>041d							.fill 	1
.041e					AssemblerAddress:
>041e							.fill 	2
.0420					AssemblerControl:
>0420							.fill 	1
.0421					ParamStart:
>0421							.fill 	2
.0423					IsGroup1:
>0423							.fill 	1
.0424					BaseOpcode:
>0424							.fill 	1
.0425					ModeMask:
>0425							.fill 	1
.0426					listIndent:
>0426							.fill 	1
.0427					lcLastCharacter:
>0427							.fill 	1
.0428					isInputFlag:
>0428							.fill 	1
.0429					currentListColour:
>0429							.fill 	1
.042a					tokenOffset:
>042a							.fill 	1
.042b					tokenLineNumber:
>042b							.fill 	2
.042d					tokenBuffer:
>042d							.fill 	253
.052a					lineBuffer:
>052a							.fill 	MaxLineSize+1
.057b					numberBuffer:
>057b							.fill 	34
.059d					decimalBuffer:
>059d							.fill 	16

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/constants.inc

=$80					AM_ISZP = $80
=$40					AM_ISG1 = $40
=$20					AM_ISG2 = $20
=224					AM_IMMEDIATE = AM_ISZP+AM_ISG1+AM_ISG2+$00
=228					AM_ZEROPAGE = AM_ISZP+AM_ISG1+AM_ISG2+$04
=40					AM_ACC = AM_ISG2+$08
=108					AM_ABS = AM_ISG1+AM_ISG2+$0C
=208					AM_INDY = AM_ISZP+AM_ISG1+$10
=244					AM_ZEROX = AM_ISZP+AM_ISG1+AM_ISG2+$14
=120					AM_ABSY = AM_ISG1+AM_ISG2+$18
=124					AM_ABSX = AM_ISG1+AM_ISG2+$1C
=209					AM_IND = AM_ISZP+AM_ISG1+$11
=$80					AM_ZEROY = AM_ISZP
=$01					AM_INDABS = $01
=$02					AM_INDABSX = $02
=192					AM_INDX = AM_ISZP+AM_ISG1+$00

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/handlers.inc


;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.inc

=1					ERRID_BREAK = 1
=2					ERRID_SYNTAX = 2
=3					ERRID_DIVZERO = 3
=4					ERRID_RANGE = 4
=5					ERRID_TYPE = 5
=6					ERRID_MEMORY = 6
=7					ERRID_ARGUMENT = 7
=8					ERRID_STOP = 8
=9					ERRID_STRING = 9
=10					ERRID_ASSERT = 10
=11					ERRID_DATA = 11
=12					ERRID_NOTDONE = 12
=13					ERRID_LINE = 13
=14					ERRID_GOSUB = 14
=15					ERRID_REPEAT = 15
=16					ERRID_WHILE = 16
=17					ERRID_FOR = 17
=18					ERRID_STACK = 18
=19					ERRID_STRUCT = 19
=20					ERRID_PROC = 20
=21					ERRID_REDEFINE = 21
=22					ERRID_ARRAYSIZE = 22
=23					ERRID_ARRAYIDX = 23

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst.inc

=$00					KWD_LESSLESS                         = $00; $00 <<
=$01					KWD_LESSEQUAL                        = $01; $01 <=
=$02					KWD_LESSGREATER                      = $02; $02 <>
=$03					KWD_PLINGPLING3                      = $03; $03 !!3
=$04					KWD_GREATERLESS                      = $04; $04 ><
=$05					KWD_GREATEREQUAL                     = $05; $05 >=
=$06					KWD_GREATERGREATER                   = $06; $06 >>
=$07					KWD_PLINGPLING7                      = $07; $07 !!7
=$08					KWD_PLINGPLING8                      = $08; $08 !!8
=$09					KWD_PLINGPLING9                      = $09; $09 !!9
=$0a					KWD_PLINGPLING10                     = $0a; $0a !!10
=$0b					KWD_PLINGPLING11                     = $0b; $0b !!11
=$0c					KWD_PLINGPLING12                     = $0c; $0c !!12
=$0d					KWD_PLINGPLING13                     = $0d; $0d !!13
=$0e					KWD_PLINGPLING14                     = $0e; $0e !!14
=$0f					KWD_PLINGPLING15                     = $0f; $0f !!15
=$10					KWD_AT                               = $10; $10 @
=$11					KWD_PLINGPLING17                     = $11; $11 !!17
=$12					KWD_PLINGPLING18                     = $12; $12 !!18
=$13					KWD_LSQPAREN                         = $13; $13 [
=$14					KWD_BACKSLASH                        = $14; $14 \
=$15					KWD_RSQPAREN                         = $15; $15 ]
=$16					KWD_HAT                              = $16; $16 ^
=$17					KWD_UNDERSCORE                       = $17; $17 _
=$18					KWD_BQUOTE                           = $18; $18 `
=$19					KWD_PLINGPLING25                     = $19; $19 !!25
=$1a					KWD_PLINGPLING26                     = $1a; $1a !!26
=$1b					KWD_LCURLY                           = $1b; $1b {
=$1c					KWD_BAR                              = $1c; $1c |
=$1d					KWD_RCURLY                           = $1d; $1d }
=$1e					KWD_TILDE                            = $1e; $1e ~
=$21					KWD_PLING                            = $21; $21 !
=$22					KWD_DQUOTE                           = $22; $22 "
=$23					KWD_HASH                             = $23; $23 #
=$24					KWD_DOLLAR                           = $24; $24 $
=$25					KWD_PERCENT                          = $25; $25 %
=$26					KWD_AMPERSAND                        = $26; $26 &
=$27					KWD_QUOTE                            = $27; $27 '
=$28					KWD_LPAREN                           = $28; $28 (
=$29					KWD_RPAREN                           = $29; $29 )
=$2a					KWD_STAR                             = $2a; $2a *
=$2b					KWD_PLUS                             = $2b; $2b +
=$2c					KWD_COMMA                            = $2c; $2c ,
=$2d					KWD_MINUS                            = $2d; $2d -
=$2e					KWD_PERIOD                           = $2e; $2e .
=$2f					KWD_SLASH                            = $2f; $2f /
=$30					KWD_0                                = $30; $30 0
=$31					KWD_1                                = $31; $31 1
=$32					KWD_2                                = $32; $32 2
=$33					KWD_3                                = $33; $33 3
=$34					KWD_4                                = $34; $34 4
=$35					KWD_5                                = $35; $35 5
=$36					KWD_6                                = $36; $36 6
=$37					KWD_7                                = $37; $37 7
=$38					KWD_8                                = $38; $38 8
=$39					KWD_9                                = $39; $39 9
=$3a					KWD_COLON                            = $3a; $3a :
=$3b					KWD_SEMICOLON                        = $3b; $3b ;
=$3c					KWD_LESS                             = $3c; $3c <
=$3d					KWD_EQUAL                            = $3d; $3d =
=$3e					KWD_GREATER                          = $3e; $3e >
=$3f					KWD_QMARK                            = $3f; $3f ?
=$83					KWD_ABSLPAREN                        = $83; $83 ABS(
=$84					KWD_ALLOCLPAREN                      = $84; $84 ALLOC(
=$85					KWD_ASCLPAREN                        = $85; $85 ASC(
=$86					KWD_CHRDOLLARLPAREN                  = $86; $86 CHR$(
=$87					KWD_EVENTLPAREN                      = $87; $87 EVENT(
=$88					KWD_FALSE                            = $88; $88 FALSE
=$89					KWD_FRACLPAREN                       = $89; $89 FRAC(
=$8a					KWD_HITLPAREN                        = $8a; $8a HIT(
=$8b					KWD_INTLPAREN                        = $8b; $8b INT(
=$8c					KWD_ISVALLPAREN                      = $8c; $8c ISVAL(
=$8d					KWD_JOYBLPAREN                       = $8d; $8d JOYB(
=$8e					KWD_JOYXLPAREN                       = $8e; $8e JOYX(
=$8f					KWD_JOYYLPAREN                       = $8f; $8f JOYY(
=$90					KWD_LEFTDOLLARLPAREN                 = $90; $90 LEFT$(
=$91					KWD_LENLPAREN                        = $91; $91 LEN(
=$92					KWD_MAXLPAREN                        = $92; $92 MAX(
=$93					KWD_MIDDOLLARLPAREN                  = $93; $93 MID$(
=$94					KWD_MINLPAREN                        = $94; $94 MIN(
=$95					KWD_NOTLPAREN                        = $95; $95 NOT(
=$96					KWD_PLAYINGLPAREN                    = $96; $96 PLAYING(
=$97					KWD_RANDOMLPAREN                     = $97; $97 RANDOM(
=$98					KWD_RIGHTDOLLARLPAREN                = $98; $98 RIGHT$(
=$99					KWD_RNDLPAREN                        = $99; $99 RND(
=$9a					KWD_SGNLPAREN                        = $9a; $9a SGN(
=$9b					KWD_SPCLPAREN                        = $9b; $9b SPC(
=$9c					KWD_STRDOLLARLPAREN                  = $9c; $9c STR$(
=$9d					KWD_TIMERLPAREN                      = $9d; $9d TIMER(
=$9e					KWD_TRUE                             = $9e; $9e TRUE
=$9f					KWD_VALLPAREN                        = $9f; $9f VAL(
=$a0					KWD_FOR                              = $a0; $a0 FOR
=$a1					KWD_IF                               = $a1; $a1 IF
=$a2					KWD_PROC                             = $a2; $a2 PROC
=$a3					KWD_REPEAT                           = $a3; $a3 REPEAT
=$a4					KWD_WHILE                            = $a4; $a4 WHILE
=$a5					KWD_ENDIF                            = $a5; $a5 ENDIF
=$a6					KWD_ENDPROC                          = $a6; $a6 ENDPROC
=$a7					KWD_NEXT                             = $a7; $a7 NEXT
=$a8					KWD_THEN                             = $a8; $a8 THEN
=$a9					KWD_UNTIL                            = $a9; $a9 UNTIL
=$aa					KWD_WEND                             = $aa; $aa WEND
=$ab					KWD_BY                               = $ab; $ab BY
=$ac					KWD_CALL                             = $ac; $ac CALL
=$ad					KWD_CIRCLE                           = $ad; $ad CIRCLE
=$ae					KWD_CLEAR                            = $ae; $ae CLEAR
=$af					KWD_CLS                              = $af; $af CLS
=$b0					KWD_COLOR                            = $b0; $b0 COLOR
=$b1					KWD_COLOUR                           = $b1; $b1 COLOUR
=$b2					KWD_DATA                             = $b2; $b2 DATA
=$b3					KWD_DIM                              = $b3; $b3 DIM
=$b4					KWD_DOWNTO                           = $b4; $b4 DOWNTO
=$b5					KWD_ELSE                             = $b5; $b5 ELSE
=$b6					KWD_FROM                             = $b6; $b6 FROM
=$b7					KWD_GFX                              = $b7; $b7 GFX
=$b8					KWD_GOSUB                            = $b8; $b8 GOSUB
=$b9					KWD_GOTO                             = $b9; $b9 GOTO
=$ba					KWD_HERE                             = $ba; $ba HERE
=$bb					KWD_IMAGE                            = $bb; $bb IMAGE
=$bc					KWD_INPUT                            = $bc; $bc INPUT
=$bd					KWD_LET                              = $bd; $bd LET
=$be					KWD_LINE                             = $be; $be LINE
=$bf					KWD_LOCAL                            = $bf; $bf LOCAL
=$c0					KWD_OFF                              = $c0; $c0 OFF
=$c1					KWD_ON                               = $c1; $c1 ON
=$c2					KWD_OUTLINE                          = $c2; $c2 OUTLINE
=$c3					KWD_PALETTE                          = $c3; $c3 PALETTE
=$c4					KWD_PLOT                             = $c4; $c4 PLOT
=$c5					KWD_PRINT                            = $c5; $c5 PRINT
=$c6					KWD_READ                             = $c6; $c6 READ
=$c7					KWD_RECT                             = $c7; $c7 RECT
=$c8					KWD_REM                              = $c8; $c8 REM
=$c9					KWD_RETURN                           = $c9; $c9 RETURN
=$ca					KWD_SOLID                            = $ca; $ca SOLID
=$cb					KWD_SOUND                            = $cb; $cb SOUND
=$cc					KWD_SPRITE                           = $cc; $cc SPRITE
=$cd					KWD_TEXT                             = $cd; $cd TEXT
=$ce					KWD_TO                               = $ce; $ce TO

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst0.inc

=$80					KWC_EOL = $80
=$ff					KWC_STRING = $FF
=$fe					KWC_HEXCONST = $FE
=$a0					KWC_FIRST_STRUCTURE = $a0
=$a5					KWC_FIRST_STRUCTURE_DEC = $a5
=$aa					KWC_LAST_STRUCTURE = $aa
=$83					KWC_FIRST_UNARY = $83
=$9f					KWC_LAST_UNARY = $9f

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/access.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/stack.inc

=$e0					STK_GOSUB = $E0
=$d0					STK_FOR = $D0
=$c0					STK_REPEAT = $C0
=$b0					STK_PROC = $B0
=$a0					STK_WHILE = $A0
=$01					STK_LOCALN = $01
=$02					STK_LOCALS = $02

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/00start.asm

.8000	4c 24 80	jmp $8024	Boot:	jmp 	Start

;******  Processing file: ./common/aa.system/../../../modules/_build/_linker.module

=0					PagingEnabled = 0
.8003					EXTPrintCharacter:
.8003	4c 47 a7	jmp $a747		jmp	Export_EXTPrintCharacter
.8006					EXTInitialise:
.8006	4c e0 a9	jmp $a9e0		jmp	Export_EXTInitialise
.8009					EXTInputSingleCharacter:
.8009	4c 16 aa	jmp $aa16		jmp	Export_EXTInputSingleCharacter
.800c					EXTBreakCheck:
.800c	4c 3c aa	jmp $aa3c		jmp	Export_EXTBreakCheck
.800f					EXTReadController:
.800f	4c 3f aa	jmp $aa3f		jmp	Export_EXTReadController
.8012					EXTInputLine:
.8012	4c f6 a8	jmp $a8f6		jmp	Export_EXTInputLine
.8015					GXGraphicDraw:
.8015	4c da aa	jmp $aada		jmp	Export_GXGraphicDraw
.8018					SNDCommand:
.8018	4c 8f bd	jmp $bd8f		jmp	Export_SNDCommand
.801b					SNDUpdate:
.801b	4c c2 bd	jmp $bdc2		jmp	Export_SNDUpdate
.801e					TKListConvertLine:
.801e	4c 85 b7	jmp $b785		jmp	Export_TKListConvertLine
.8021					TKTokeniseLine:
.8021	4c 19 ba	jmp $ba19		jmp	Export_TKTokeniseLine

;******  Return to file: ./common/aa.system/00start.asm

.8024	a2 ff		ldx #$ff	Start:	ldx 	#$FF 						; stack reset
.8026	9a		txs				txs
.8027	20 06 80	jsr $8006			jsr 	EXTInitialise 				; hardware initialise
.802a	a9 00		lda #$00			lda 	#0 							; graphics system initialise.
.802c	aa		tax				tax
.802d	a8		tay				tay
.802e	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.8031	a9 0f		lda #$0f			lda 	#$0F 						; initialise sound system
.8033	20 18 80	jsr $8018			jsr 	SNDCommand
.8036	a2 80		ldx #$80			ldx 	#Prompt >> 8 				; display prompt
.8038	a9 46		lda #$46			lda 	#Prompt & $FF
.803a	20 19 8f	jsr $8f19			jsr 	PrintStringXA
.803d	20 a1 89	jsr $89a1			jsr 	NewProgram 					; erase current program
.8040	4c 78 83	jmp $8378			jmp 	WarmStart					; make same size.
.8043	4c 78 83	jmp $8378			jmp 	WarmStart
>8046	46 32 35 36 20 42 41 53		Prompt:	.text 	"F256 BASIC "
>804e	49 43 20

;******  Processing file: ./common/aa.system/../generated/timestamp.asm

>8051	52 65 6c 65 61 73 65 20			.text "Release Alpha 8 (01-Dec-22). "
>8059	41 6c 70 68 61 20 38 20 28 30 31 2d 44 65 63 2d
>8069	32 32 29 2e 20

;******  Return to file: ./common/aa.system/00start.asm

>806e	0d 0d 00					.text 	13,13,0

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/assembler.asm

.8071					AssembleGroup1:
.8071	a9 ff		lda #$ff			lda 	#$FF
.8073	8d 25 04	sta $0425			sta 	ModeMask 					; initialise the mode mask - all for all
.8076	80 02		bra $807a			bra 	AsmGroup12
.8078					AssembleGroup2:
.8078	a9 00		lda #$00			lda 	#$00
.807a					AsmGroup12:
.807a	8d 23 04	sta $0423			sta 	IsGroup1 					; save the 'group 1' flag
.807d	68		pla				pla 								; pop the return address to access the information following.
.807e	fa		plx				plx
.807f	20 06 81	jsr $8106			jsr 	AccessParameters 			; get opcode and save as base
.8082	8d 24 04	sta $0424			sta 	BaseOpcode
.8085	ad 23 04	lda $0423			lda 	IsGroup1 					; skip if group 1 as we don't have a complex mask.
.8088	d0 08		bne $8092			bne 	_AG12HaveMask
.808a	a9 02		lda #$02			lda 	#2 							; if group 2 the second parameter is the mask
.808c	20 0e 81	jsr $810e			jsr 	GetParameter		 		; e.g. which modes are supported for this operand
.808f	8d 25 04	sta $0425			sta 	ModeMask
.8092					_AG12HaveMask:
.8092	20 42 82	jsr $8242			jsr 	TypeAndCalculateOperand 	; get zero page type
.8095	da		phx				phx 								; save found address mode
.8096	20 72 81	jsr $8172			jsr 	AssembleModeX
.8099	fa		plx				plx  								; restore address mode
.809a	b0 0b		bcs $80a7			bcs 	_AG12Exit
.809c	20 a8 80	jsr $80a8			jsr 	PromoteToAbsolute  			; promote ZP to ABS and try that
.809f	20 72 81	jsr $8172			jsr 	AssembleModeX
.80a2	b0 03		bcs $80a7			bcs 	_AG12Exit
.80a4	4c 4b 9f	jmp $9f4b			jmp 	SyntaxError 				; can't do either, so must be wrong mode/operand.
.80a7					_AG12Exit:
.80a7	60		rts				rts
.80a8					PromoteToAbsolute:
.80a8	a9 6c		lda #$6c			lda 	#AM_ABS 					; lda xx
.80aa	e0 e4		cpx #$e4			cpx 	#AM_ZEROPAGE
.80ac	f0 19		beq $80c7			beq 	_PTADo
.80ae	a9 7c		lda #$7c			lda 	#AM_ABSX 					; lda xx,X
.80b0	e0 f4		cpx #$f4			cpx 	#AM_ZEROX
.80b2	f0 13		beq $80c7			beq 	_PTADo
.80b4	a9 78		lda #$78			lda 	#AM_ABSY 					; lda xx,Y
.80b6	e0 80		cpx #$80			cpx 	#AM_ZEROY
.80b8	f0 0d		beq $80c7			beq 	_PTADo
.80ba	a9 01		lda #$01			lda 	#AM_INDABS 					; lda (xx) (jump)
.80bc	e0 d1		cpx #$d1			cpx 	#AM_IND
.80be	f0 07		beq $80c7			beq 	_PTADo
.80c0	a9 02		lda #$02			lda 	#AM_INDABSX 				; lda (xx,x) (jump)
.80c2	e0 c0		cpx #$c0			cpx 	#AM_INDX
.80c4	f0 01		beq $80c7			beq 	_PTADo
.80c6	60		rts				rts
.80c7					_PTADo:
.80c7	aa		tax				tax
.80c8	60		rts				rts
.80c9					AssembleGroup3:
.80c9	68		pla				pla 								; get parameters, which is just the opcode.
.80ca	fa		plx				plx
.80cb	20 06 81	jsr $8106			jsr 	AccessParameters 			; get and output opcode
.80ce	20 1e 81	jsr $811e			jsr 	AssemblerWriteByte
.80d1	20 a6 82	jsr $82a6			jsr 	CalculateOperand 			; get a 16 bit operand
.80d4	a5 58		lda $58				lda 	NSMantissa0 				; calculate the offset
.80d6	38		sec				sec
.80d7	ed 1e 04	sbc $041e			sbc 	AssemblerAddress
.80da	48		pha				pha 								; LSB in A
.80db	a5 60		lda $60				lda 	NSMantissa1
.80dd	ed 1f 04	sbc $041f			sbc 	AssemblerAddress+1
.80e0	aa		tax				tax 								; MSB in X
.80e1	68		pla				pla
.80e2	18		clc				clc 								; $80 to easy check $80-$7F, plus 1 for offset error
.80e3	69 7f		adc #$7f			adc 	#$7F
.80e5	90 01		bcc $80e8			bcc 	_AG3NoCarry
.80e7	e8		inx				inx
.80e8					_AG3NoCarry:
.80e8	38		sec				sec 								; fix back and write out anyways.
.80e9	e9 80		sbc #$80			sbc 	#$80
.80eb	20 1e 81	jsr $811e			jsr 	AssemblerWriteByte
.80ee	e0 00		cpx #$00			cpx 	#0 							; was it in range
.80f0	f0 0a		beq $80fc			beq 	_AG3Exit
.80f2	ad 20 04	lda $0420			lda 	AssemblerControl 			; are we allowing bad values ?
.80f5	29 01		and #$01			and 	#1
.80f7	f0 03		beq $80fc			beq 	_AG3Exit
.80f9	4c 50 9f	jmp $9f50			jmp 	RangeError 					; no, branch is out of range
.80fc					_AG3Exit:
.80fc	60		rts				rts
.80fd					AssembleGroup4:
.80fd	68		pla				pla 								; pop address
.80fe	fa		plx				plx
.80ff	20 06 81	jsr $8106			jsr 	AccessParameters 			; access and get first
.8102	20 1e 81	jsr $811e			jsr 	AssemblerWriteByte 			; output it.
.8105	60		rts				rts
.8106					AccessParameters:
.8106	8d 21 04	sta $0421			sta 	ParamStart
.8109	8e 22 04	stx $0422			stx 	ParamStart+1
.810c	a9 01		lda #$01			lda 	#1
.810e					GetParameter:
.810e	5a		phy				phy
.810f	a8		tay				tay
.8110	ad 21 04	lda $0421			lda 	ParamStart
.8113	85 36		sta $36				sta 	zTemp0
.8115	ad 22 04	lda $0422			lda 	ParamStart+1
.8118	85 37		sta $37				sta 	zTemp0+1
.811a	b1 36		lda ($36),y			lda 	(zTemp0),y
.811c	7a		ply				ply
.811d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/aswrite.asm

.811e					AssemblerWriteByte:
.811e	48		pha			pha
.811f	ad 20 04	lda $0420		lda 	AssemblerControl 				; check printing bytes ?
.8122	29 02		and #$02		and 	#2
.8124	f0 1b		beq $8141		beq 	_AWBNoPrint
.8126	ad 1f 04	lda $041f		lda		AssemblerAddress+1 				; print address
.8129	20 5c 81	jsr $815c		jsr 	PrintHex
.812c	ad 1e 04	lda $041e		lda		AssemblerAddress
.812f	20 5c 81	jsr $815c		jsr 	PrintHex
.8132	a9 20		lda #$20		lda 	#' '
.8134	20 03 80	jsr $8003		jsr 	EXTPrintCharacter
.8137	68		pla			pla 									; print byte
.8138	48		pha			pha
.8139	20 5c 81	jsr $815c		jsr 	PrintHex
.813c	a9 0d		lda #$0d		lda 	#13
.813e	20 03 80	jsr $8003		jsr 	EXTPrintCharacter
.8141					_AWBNoPrint:
.8141	ad 1e 04	lda $041e		lda		AssemblerAddress				; copy address to zTemp0
.8144	85 36		sta $36			sta 	zTemp0
.8146	ad 1f 04	lda $041f		lda		AssemblerAddress+1
.8149	f0 0e		beq $8159		beq 	_AWBRange
.814b	85 37		sta $37			sta 	zTemp0+1
.814d	68		pla			pla 									; write byte out
.814e	92 36		sta ($36)		sta 	(zTemp0)
.8150	ee 1e 04	inc $041e		inc 	AssemblerAddress 				; bump address
.8153	d0 03		bne $8158		bne 	_AWBNoCarry
.8155	ee 1f 04	inc $041f		inc 	AssemblerAddress+1
.8158					_AWBNoCarry:
.8158	60		rts			rts
.8159					_AWBRange:
.8159	4c 50 9f	jmp $9f50		jmp 	RangeError
.815c					PrintHex:
.815c	48		pha				pha
.815d	4a		lsr a				lsr 	a
.815e	4a		lsr a				lsr 	a
.815f	4a		lsr a				lsr 	a
.8160	4a		lsr a				lsr 	a
.8161	20 65 81	jsr $8165			jsr 	_PrintNibble
.8164	68		pla				pla
.8165					_PrintNibble:
.8165	29 0f		and #$0f			and 	#15
.8167	c9 0a		cmp #$0a			cmp 	#10
.8169	90 02		bcc $816d			bcc 	_NoShift
.816b	69 06		adc #$06			adc 	#6
.816d					_NoShift:
.816d	69 30		adc #$30			adc 	#48
.816f	4c 03 80	jmp $8003			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/instruction.asm

.8172					AssembleModeX:
.8172	5a		phy				phy
.8173	ad 23 04	lda $0423			lda 	IsGroup1
.8176	f0 17		beq $818f			beq 	_AMXGroup2
.8178	8a		txa				txa 							; is it in group # 1
.8179	29 40		and #$40			and 	#AM_ISG1
.817b	f0 4d		beq $81ca			beq 	_AMXFail 				; no, give up.
.817d	8a		txa				txa 							; get back.
.817e	29 1f		and #$1f			and 	#$1F 					; this is now the offset.
.8180	e0 e0		cpx #$e0			cpx 	#AM_IMMEDIATE 			; if not immediate, we can continue.
.8182	d0 22		bne $81a6			bne 	_AMXHaveInfo
.8184	ad 24 04	lda $0424			lda 	BaseOpcode 				; cannot store immediate.
.8187	c9 81		cmp #$81			cmp 	#$81
.8189	f0 3f		beq $81ca			beq 	_AMXFail
.818b	a9 08		lda #$08			lda 	#8 						; if immediate we use offset 8.
.818d	80 17		bra $81a6			bra 	_AMXHaveInfo 			; odd design decision there.
.818f					_AMXGroup2:
.818f	8a		txa				txa 							; is it in group 2 ?
.8190	29 20		and #$20			and 	#AM_ISG2
.8192	f0 36		beq $81ca			beq 	_AMXFail 				; no, give up.
.8194	8a		txa				txa 							; get the offset into Y
.8195	29 1f		and #$1f			and 	#$1F
.8197	4a		lsr a				lsr 	a 						; make it 0-7.
.8198	4a		lsr a				lsr  	a
.8199	a8		tay				tay
.819a	ad 25 04	lda $0425			lda 	ModeMask 				; shift the modemask left so you can check it against the requested offset
.819d					_AMXCheckOkay:
.819d	0a		asl a				asl 	a 						; shift modemask left enough times to check legitimate.
.819e	88		dey				dey
.819f	10 fc		bpl $819d			bpl 	_AMXCheckOkay
.81a1	90 27		bcc $81ca			bcc 	_AMXFail 				; not allowed.
.81a3	8a		txa				txa  							; get mask back
.81a4	29 1f		and #$1f			and 	#$1F
.81a6					_AMXHaveInfo:
.81a6	e0 00		cpx #$00			cpx 	#$00 					; does it *require* an 8 bit operand
.81a8	10 04		bpl $81ae			bpl 	_AMXAnySize 			; checking bit 7, the zero page opcode flag.
.81aa	a4 60		ldy $60				ldy 	NSMantissa1 			; fail if it is outside range, e.g. the MSB is set.
.81ac	d0 1c		bne $81ca			bne 	_AMXFail
.81ae					_AMXAnySize:
.81ae	18		clc				clc 							; add offset to the base opcode
.81af	6d 24 04	adc $0424			adc 	BaseOpcode
.81b2					_AMXOutputCode:
.81b2	20 1e 81	jsr $811e			jsr 	AssemblerWriteByte 		; write the opcode out.
.81b5	e0 28		cpx #$28			cpx 	#AM_ACC 				; A mode (e.g. ASL A)
.81b7	f0 0e		beq $81c7			beq 	_AMXExit
.81b9	a5 58		lda $58				lda 	NSMantissa0 				; write LSB operand
.81bb	20 1e 81	jsr $811e			jsr 	AssemblerWriteByte
.81be	e0 00		cpx #$00			cpx 	#$00 					; zeropage ?
.81c0	30 05		bmi $81c7			bmi 	_AMXExit
.81c2	a5 60		lda $60				lda 	NSMantissa1 			; write MSB operand
.81c4	20 1e 81	jsr $811e			jsr 	AssemblerWriteByte
.81c7					_AMXExit:
.81c7	7a		ply				ply
.81c8	38		sec				sec
.81c9	60		rts				rts
.81ca					_AMXFail:
.81ca	a0 00		ldy #$00			ldy 	#0
.81cc					_AMXCheckOddities:
.81cc	8a		txa				txa
.81cd	d9 f4 81	cmp $81f4,y			cmp 	ExtraOpcode+2,y 		; match address mode
.81d0	d0 15		bne $81e7			bne 	_AMXCONext
.81d2	b9 f2 81	lda $81f2,y			lda 	ExtraOpcode+0,y 		; do the base opcodes match
.81d5	cd 24 04	cmp $0424			cmp 	BaseOpcode
.81d8	d0 0d		bne $81e7			bne 	_AMXCONext
.81da	e0 00		cpx #$00			cpx 	#$00 					; requires zero page ?
.81dc	10 04		bpl $81e2			bpl 	_AMXCONotZero
.81de	a5 60		lda $60				lda 	NSMantissa1
.81e0	d0 05		bne $81e7			bne 	_AMXCONext
.81e2					_AMXCONotZero:
.81e2	b9 f3 81	lda $81f3,y			lda 	ExtraOpcode+1,y 		; get new opcode
.81e5	80 cb		bra $81b2			bra 	_AMXOutputCode 			; and assemble it
.81e7					_AMXCONext:
.81e7	c8		iny				iny
.81e8	c8		iny				iny
.81e9	c8		iny				iny
.81ea	b9 f2 81	lda $81f2,y			lda 	ExtraOpcode+0,y 		; end of table
.81ed	d0 dd		bne $81cc			bne 	_AMXCheckOddities
.81ef					_AMXCOFail:
.81ef	7a		ply				ply
.81f0	18		clc				clc
.81f1	60		rts				rts
.81f2					ExtraOpcode:
>81f2	40 6c 01					.byte $40,$6c,AM_INDABS 	; jump
>81f5	40 7c 02					.byte $40,$7C,AM_INDABSX 	; jump
>81f8	a2 be 78					.byte $a2,$BE,AM_ABSY 		; ldx
>81fb	a2 b6 80					.byte $a2,$B6,AM_ZEROY 		; ldx
>81fe	82 96 80					.byte $82,$96,AM_ZEROY 		; stx
>8201	e2 1a 28					.byte $e2,$1a,AM_ACC 		; inc
>8204	c2 3a 28					.byte $c2,$3a,AM_ACC 		; dec
>8207	20 89 e0					.byte $20,$89,AM_IMMEDIATE 	; bit
>820a	60 9c 6c					.byte $60,$9c,AM_ABS 		; stz
>820d	60 9e 7c					.byte $60,$9e,AM_ABSX 		; stz
>8210	00						.byte $00

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/label.asm

.8211					LabelHere:
.8211	c8		iny				iny 								; skip .
.8212	a2 00		ldx #$00			ldx 	#0 							; get a term
.8214	20 0e 98	jsr $980e			jsr 	EvaluateTerm 				; get a term
.8217	a5 50		lda $50				lda 	NSStatus 					; needs to be an integer reference.
.8219	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.821b	d0 22		bne $823f			bne 	_ALType
.821d	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy reference address to zTemp0
.821f	85 36		sta $36				sta 	zTemp0
.8221	b5 60		lda $60,x			lda 	NSMantissa1,x
.8223	85 37		sta $37				sta 	zTemp0+1
.8225	5a		phy				phy 								; copy address in.
.8226	a0 01		ldy #$01			ldy 	#1
.8228	ad 1e 04	lda $041e			lda	 	AssemblerAddress
.822b	92 36		sta ($36)			sta 	(zTemp0)
.822d	ad 1f 04	lda $041f			lda	 	AssemblerAddress+1
.8230	91 36		sta ($36),y			sta 	(zTemp0),y
.8232	c8		iny				iny
.8233	a9 00		lda #$00			lda 	#0
.8235	91 36		sta ($36),y			sta 	(zTemp0),y
.8237	c8		iny				iny
.8238	91 36		sta ($36),y			sta 	(zTemp0),y
.823a	c8		iny				iny
.823b	91 36		sta ($36),y			sta 	(zTemp0),y
.823d	7a		ply				ply
.823e	60		rts				rts
.823f					_ALType:
.823f	4c 55 9f	jmp $9f55			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/operands.asm

.8242					TypeAndCalculateOperand:
.8242	b1 30		lda ($30),y			lda 	(codePtr),y
.8244	a2 28		ldx #$28			ldx 	#AM_ACC 					; ACC if : or EOL
.8246	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.8248	f0 5b		beq $82a5			beq 	_TACOExit
.824a	c9 80		cmp #$80			cmp 	#KWC_EOL
.824c	f0 57		beq $82a5			beq 	_TACOExit
.824e	c8		iny				iny
.824f	a2 e0		ldx #$e0			ldx 	#AM_IMMEDIATE
.8251	c9 23		cmp #$23			cmp 	#KWD_HASH 					; if hash, then immediate - constant.
.8253	f0 51		beq $82a6			beq 	CalculateOperand
.8255	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; if ( then check for indirection
.8257	f0 1f		beq $8278			beq 	_TACOIndirect
.8259	88		dey				dey 								; undo get of first character
.825a	20 a6 82	jsr $82a6			jsr 	CalculateOperand 			; get operand
.825d	b1 30		lda ($30),y			lda 	(codePtr),y
.825f	a2 e4		ldx #$e4			ldx 	#AM_ZEROPAGE 				; if not, try zero page (then absolute)
.8261	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8263	d0 40		bne $82a5			bne 	_TACOExit
.8265	c8		iny				iny
.8266	20 b0 82	jsr $82b0			jsr 	TACOCheckXY 				; extract X,Y or 0 (neither) from the variable.
.8269	a2 f4		ldx #$f4			ldx 	#AM_ZEROX 					; check for X
.826b	c9 58		cmp #$58			cmp 	#'X'
.826d	f0 36		beq $82a5			beq 	_TACOExit
.826f	a2 80		ldx #$80			ldx 	#AM_ZEROY 					; check for Y
.8271	c9 59		cmp #$59			cmp 	#'Y'
.8273	f0 30		beq $82a5			beq 	_TACOExit
.8275					_TACOSyntax:
.8275	4c 4b 9f	jmp $9f4b			jmp 	SyntaxError
.8278					_TACOIndirect:
.8278	20 a6 82	jsr $82a6			jsr 	CalculateOperand 			; get the operand
.827b	b1 30		lda ($30),y			lda 	(codePtr),y
.827d	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if , then it must be ,X)
.827f	f0 17		beq $8298			beq 	_TACOIndX
.8281	20 a7 8e	jsr $8ea7			jsr 	CheckRightBracket  			; otherwise must be ) or ),Y
.8284	b1 30		lda ($30),y			lda 	(codePtr),y
.8286	a2 d1		ldx #$d1			ldx 	#AM_IND
.8288	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not comma then exit with (xx)
.828a	d0 19		bne $82a5			bne 	_TACOExit
.828c	c8		iny				iny
.828d	20 b0 82	jsr $82b0			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.8290	c9 59		cmp #$59			cmp 	#'Y' 						; check Y
.8292	d0 e1		bne $8275			bne 	_TACOSyntax
.8294	a2 d0		ldx #$d0			ldx 	#AM_INDY
.8296	80 0d		bra $82a5			bra 	_TACOExit
.8298					_TACOIndX:
.8298	c8		iny				iny
.8299	20 b0 82	jsr $82b0			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.829c	c9 58		cmp #$58			cmp 	#'X' 						; check X
.829e	d0 d5		bne $8275			bne 	_TACOSyntax
.82a0	20 a7 8e	jsr $8ea7			jsr 	CheckRightBracket			; check )
.82a3	a2 c0		ldx #$c0			ldx 	#AM_INDX
.82a5					_TACOExit:
.82a5	60		rts				rts
.82a6					CalculateOperand:
.82a6	48		pha				pha
.82a7	da		phx				phx
.82a8	a2 00		ldx #$00			ldx 	#0 							; get 16 bit integer in Slot 0
.82aa	20 4d 9d	jsr $9d4d			jsr 	Evaluate16BitInteger
.82ad	fa		plx				plx
.82ae	68		pla				pla
.82af	60		rts				rts
.82b0					TACOCheckXY:
.82b0	b1 30		lda ($30),y			lda 	(codePtr),y
.82b2	29 c0		and #$c0			and 	#$C0 						; check it is an identifier reference.
.82b4	c9 40		cmp #$40			cmp 	#$40
.82b6	d0 21		bne $82d9			bne 	_TCXYFail
.82b8	b1 30		lda ($30),y			lda 	(codePtr),y
.82ba	18		clc				clc
.82bb	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.82bd	85 37		sta $37				sta 	zTemp0+1
.82bf	c8		iny				iny
.82c0	b1 30		lda ($30),y			lda 	(codePtr),y
.82c2	c8		iny				iny
.82c3	85 36		sta $36				sta 	zTemp0
.82c5	5a		phy				phy 								; save position
.82c6	a0 02		ldy #$02			ldy 	#2 							; type is integer ?
.82c8	b1 36		lda ($36),y			lda 	(zTemp0),y
.82ca	d0 0c		bne $82d8			bne 	_TCXYPopFail
.82cc	a0 08		ldy #$08			ldy 	#8 							; get first character, should have bit 7 set as also last.
.82ce	b1 36		lda ($36),y			lda 	(zTemp0),y
.82d0	c9 d8		cmp #$d8			cmp 	#'X'+$80 					; should be X or Y
.82d2	f0 08		beq $82dc			beq 	_TCXYFound
.82d4	c9 d9		cmp #$d9			cmp 	#'Y'+$80
.82d6	f0 04		beq $82dc			beq 	_TCXYFound
.82d8					_TCXYPopFail:
.82d8	7a		ply				ply
.82d9					_TCXYFail:
.82d9	a9 00		lda #$00			lda 	#0
.82db	60		rts				rts
.82dc					_TCXYFound:
.82dc	7a		ply				ply 								; restore position
.82dd	29 7f		and #$7f			and 	#$7F 						; throw bit 7
.82df	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/backload.asm

.82e0					BackloadProgram:
.82e0	a2 83		ldx #$83			ldx 	#_BLLoad >> 8
.82e2	a9 27		lda #$27			lda 	#_BLLoad & $FF
.82e4	20 19 8f	jsr $8f19			jsr 	PrintStringXA
.82e7	a9 00		lda #$00			lda 	#((SOURCE_ADDRESS) & $FF)
.82e9	8d ad 05	sta $05ad			sta 	0+BackLoadPointer
.82ec	a9 30		lda #$30			lda 	#((SOURCE_ADDRESS) >> 8)
.82ee	8d ae 05	sta $05ae			sta 	1+BackLoadPointer
.82f1	a9 ff		lda #$ff			lda 	#$FF
.82f3	8d fa ff	sta $fffa			sta 	$FFFA
.82f6					_BPLoop:
.82f6	a2 ff		ldx #$ff			ldx 	#$FF
.82f8	20 3c 83	jsr $833c			jsr 	BLReadByte 					; read a byte
.82fb	c9 00		cmp #$00			cmp 	#0
.82fd	f0 21		beq $8320			beq 	_BPExit 					; if 0 exit
.82ff	30 1f		bmi $8320			bmi 	_BPExit 					; if -ve exit
.8301					_BPCopy:
.8301	e8		inx				inx  								; copy byte into the lineBuffer
.8302	9d 2a 05	sta $052a,x			sta 	lineBuffer,x
.8305	9e 2b 05	stz $052b,x			stz 	lineBuffer+1,x
.8308	20 3c 83	jsr $833c			jsr 	BLReadByte 					; read next byte
.830b	30 0a		bmi $8317			bmi 	_BPEndLine 					; -ve = EOL
.830d	c9 09		cmp #$09			cmp 	#9 							; handle TAB, make it space.
.830f	d0 02		bne $8313			bne 	_BPNotTab
.8311	a9 20		lda #$20			lda 	#' '
.8313					_BPNotTab:
.8313	c9 20		cmp #$20			cmp 	#' ' 						; < ' ' = EOL
.8315	b0 ea		bcs $8301			bcs 	_BPCopy 					; until a control character, should be 13 received.
.8317					_BPEndLine:
.8317	20 21 80	jsr $8021			jsr 	TKTokeniseLine 				; tokenise the line.
.831a	38		sec				sec 								; append not insert
.831b	20 95 a4	jsr $a495			jsr 	MemoryInsertLine 			; append to current program
.831e	80 d6		bra $82f6			bra 	_BPLoop
.8320					_BPExit:
.8320	9c fa ff	stz $fffa			stz 	$FFFA
.8323	20 0e 84	jsr $840e			jsr 	ClearCommand 				; clear variables etc.
.8326	60		rts				rts
.8327					_BLLoad:
>8327	4c 6f 61 64 69 6e 67 20				.text 	"Loading from Memory",13,0
>832f	66 72 6f 6d 20 4d 65 6d 6f 72 79 0d 00
.833c					BLReadByte:
.833c	ad ad 05	lda $05ad			lda 	BackLoadPointer 			; copy pointer to zTemp0
.833f	85 36		sta $36				sta 	zTemp0
.8341	ad ae 05	lda $05ae			lda 	BackLoadPointer+1
.8344	85 37		sta $37				sta 	zTemp0+1
.8346	b2 36		lda ($36)			lda 	(zTemp0) 					; read next byte
.8348	ee ad 05	inc $05ad			inc 	BackLoadPointer 			; bump pointer
.834b	d0 03		bne $8350			bne 	_BLNoCarry
.834d	ee ae 05	inc $05ae			inc 	BackLoadPointer+1
.8350					_BLNoCarry:
.8350	c9 00		cmp #$00			cmp 	#0
.8352	60		rts				rts
.05ad					BackLoadPointer:
>05ad							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/editor.asm

.8353					EditProgramCode:
.8353	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; find the line.
.8356	ae 2c 04	ldx $042c			ldx 	TokenLineNumber+1
.8359	20 39 a5	jsr $a539			jsr 	MemorySearch
.835c	90 05		bcc $8363			bcc 	_EPCNoDelete 				; reached the end don't delete
.835e	d0 03		bne $8363			bne 	_EPCNoDelete 				; found slot but didn't match, no delete
.8360	20 5e a4	jsr $a45e			jsr 	MemoryDeleteLine 			; delete the line
.8363					_EPCNoDelete:
.8363	ad 2d 04	lda $042d			lda 	TokenBuffer 				; buffer empty
.8366	c9 80		cmp #$80			cmp 	#KWC_EOL
.8368	f0 0d		beq $8377			beq 	_EPCNoInsert
.836a	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; find the line - it cannot exist.
.836d	ae 2c 04	ldx $042c			ldx 	TokenLineNumber+1 			; so this can't fail, it returns some point in the code.
.8370	20 39 a5	jsr $a539			jsr 	MemorySearch
.8373	18		clc				clc 								; insert at this point.
.8374	20 95 a4	jsr $a495			jsr 	MemoryInsertLine 			; insert the line
.8377					_EPCNoInsert:
.8377	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/warmstart.asm

.8378					WarmStart:
.8378	a2 ff		ldx #$ff			ldx 	#$FF
.837a	9a		txs				txs
.837b	a9 85		lda #$85			lda 	#CLICommandLine+$80 		; set console colour
.837d	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8380	20 12 80	jsr $8012			jsr 	EXTInputLine 				; get line to lineBuffer
.8383	20 21 80	jsr $8021			jsr 	TKTokeniseLine 				; tokenise the line
.8386	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; line number ?
.8389	0d 2c 04	ora $042c			ora 	TokenLineNumber+1
.838c	d0 17		bne $83a5			bne 	_WSEditCode 				; if so,edit code.
.838e	9c 2a 04	stz $042a			stz 	TokenOffset 				; zero offset, meaning it only runs one line.
.8391	a9 2a		lda #$2a			lda 	#((TokenOffset) & $FF)
.8393	85 30		sta $30				sta 	codePtr
.8395	a9 04		lda #$04			lda 	#((TokenOffset) >> 8)
.8397	85 31		sta $31				sta 	codePtr+1
.8399	ad 2d 04	lda $042d			lda 	TokenBuffer 				; nothing to run
.839c	c9 80		cmp #$80			cmp 	#KWC_EOL
.839e	f0 d8		beq $8378			beq 	WarmStart
.83a0	20 f4 8a	jsr $8af4			jsr 	RUNCodePointerLine 			; execute that line.
.83a3	80 d3		bra $8378			bra 	WarmStart
.83a5					_WSEditCode:
.83a5	20 53 83	jsr $8353			jsr 	EditProgramCode
.83a8	20 0e 84	jsr $840e			jsr 	ClearCommand
.83ab	80 cb		bra $8378			bra 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assemble.asm

.83ad					AssembleCommand:
.83ad	a2 00		ldx #$00			ldx 	#0
.83af	20 4d 9d	jsr $9d4d			jsr 	Evaluate16BitInteger 		; start address
.83b2	a5 58		lda $58				lda 	NSMantissa0
.83b4	8d 1e 04	sta $041e			sta 	AssemblerAddress
.83b7	a5 60		lda $60				lda 	NSMantissa1
.83b9	8d 1f 04	sta $041f			sta 	AssemblerAddress+1
.83bc	20 af 8e	jsr $8eaf			jsr 	CheckComma
.83bf	20 68 9d	jsr $9d68			jsr 	Evaluate8BitInteger 		; options
.83c2	a5 58		lda $58				lda 	NSMantissa0
.83c4	8d 20 04	sta $0420			sta 	AssemblerControl
.83c7	60		rts				rts
.83c8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assert.asm

.83c9					AssertCommand:
.83c9	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.83cb	20 3a 9d	jsr $9d3a			jsr 	EvaluateInteger 			; the assert test
.83ce	20 ef 9d	jsr $9def			jsr 	NSMIsZero 					; exit if result is non zero.
.83d1	d0 05		bne $83d8			bne 	_ACExit
.83d3	a9 0a		lda #$0a		lda	#10
.83d5	4c c0 8e	jmp $8ec0		jmp	ErrorHandler
.83d8					_ACExit:
.83d8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/call.asm

.83d9					CallCommand:
.83d9	a2 00		ldx #$00			ldx 	#0 							; get the routine address to level 0
.83db	20 4d 9d	jsr $9d4d			jsr 	Evaluate16BitInteger
.83de					_CCClear
.83de	e8		inx				inx  								; clear 1,2 and 3 (for A X Y)
.83df	20 cd 9d	jsr $9dcd			jsr 	NSMSetZero 					; these are optional sequentially.
.83e2	e0 04		cpx #$04			cpx 	#4
.83e4	d0 f8		bne $83de			bne 	_CCClear
.83e6	a2 00		ldx #$00			ldx 	#0 							; and keep trying while there are more values.
.83e8					_CCCParam:
.83e8	b1 30		lda ($30),y			lda 	(codePtr),y
.83ea	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.83ec	d0 09		bne $83f7			bne 	_CCCRun6502
.83ee	c8		iny				iny 								; skip comma
.83ef	e8		inx				inx	 								; next level
.83f0	20 68 9d	jsr $9d68			jsr 	Evaluate8BitInteger 		; get A/X/Y
.83f3	e0 03		cpx #$03			cpx 	#3
.83f5	90 f1		bcc $83e8			bcc 	_CCCParam 					; done all 3 ?
.83f7					_CCCRun6502:
.83f7	5a		phy				phy 								; save position
.83f8	a5 60		lda $60				lda 	NSMantissa1 				; put address in zTemp0
.83fa	85 37		sta $37				sta 	zTemp0+1
.83fc	a5 58		lda $58				lda 	NSMantissa0
.83fe	85 36		sta $36				sta 	zTemp0
.8400	a5 59		lda $59				lda 	NSMantissa0+1 				; get registers into A X Y
.8402	a6 5a		ldx $5a				ldx 	NSMantissa0+2
.8404	a4 5b		ldy $5b				ldy 	NSMantissa0+3
.8406	20 0b 84	jsr $840b			jsr 	_CCCZTemp0 					; call zTemp0
.8409	7a		ply				ply 								; restore position and exit
.840a	60		rts				rts
.840b					_CCCZTemp0:
.840b	6c 36 00	jmp ($0036)			jmp 	(zTemp0)

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/clear.asm

.840e					ClearCommand:
.840e	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.8410	85 36		sta $36				sta 	0+zTemp0
.8412	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.8414	85 37		sta $37				sta 	1+zTemp0
.8416					_ClearZeroLoop:
.8416	b2 36		lda ($36)			lda 	(zTemp0) 					; end of variables if offset is zero.
.8418	f0 24		beq $843e			beq 	_ClearZeroEnd
.841a	a0 03		ldy #$03			ldy 	#3 							; erase the variables
.841c	a9 00		lda #$00			lda 	#0 							; set all the data to zero.
.841e					_ClearOneVariable:
.841e	91 36		sta ($36),y			sta 	(zTemp0),y
.8420	c8		iny				iny
.8421	c0 08		cpy #$08			cpy 	#8
.8423	d0 f9		bne $841e			bne 	_ClearOneVariable
.8425	a0 02		ldy #$02			ldy 	#2 							; has it been marked procedure
.8427	b1 36		lda ($36),y			lda 	(zTemp0),y
.8429	c9 18		cmp #$18			cmp 	#NSTProcedure
.842b	d0 04		bne $8431			bne 	_ClearNotProcedure
.842d	a9 04		lda #$04			lda 	#NSTInteger+NSBIsArray 		; if so set it back to an integer array
.842f	91 36		sta ($36),y			sta 	(zTemp0),y 					; will be fixed on the pre-run scan.
.8431					_ClearNotProcedure:
.8431	18		clc				clc 								; go to the next variable
.8432	b2 36		lda ($36)			lda 	(zTemp0) 					; offset to next, add to zTemp0
.8434	65 36		adc $36				adc 	zTemp0
.8436	85 36		sta $36				sta 	zTemp0
.8438	90 dc		bcc $8416			bcc 	_ClearZeroLoop
.843a	e6 37		inc $37				inc 	zTemp0+1
.843c	80 d8		bra $8416			bra 	_ClearZeroLoop
.843e					_ClearZeroEnd:
.843e	18		clc				clc
.843f	a5 36		lda $36				lda 	zTemp0
.8441	69 01		adc #$01			adc 	#1
.8443	8d 0c 04	sta $040c			sta 	lowMemPtr
.8446	a5 37		lda $37				lda 	zTemp0+1
.8448	69 00		adc #$00			adc 	#0
.844a	8d 0d 04	sta $040d			sta 	lowMemPtr+1
.844d	20 75 a6	jsr $a675			jsr 	StackReset
.8450	20 db a6	jsr $a6db			jsr 	StringSystemInitialise
.8453	20 4d 8d	jsr $8d4d			jsr 	ProcedureScan
.8456	20 a3 8a	jsr $8aa3			jsr 	Command_Restore
.8459	9c 1e 04	stz $041e			stz 	AssemblerAddress
.845c	9c 1f 04	stz $041f			stz 	AssemblerAddress+1
.845f	9c 20 04	stz $0420			stz 	AssemblerControl
.8462	20 f5 99	jsr $99f5			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.8465	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/cls.asm

.8466					ClearScreen:
.8466	5a		phy				phy
.8467	a9 0c		lda #$0c			lda 	#12 						; char code 12 clears the screen.
.8469	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.846c	7a		ply				ply
.846d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/data.asm

.846e					Command_Data:
.846e	a9 3a		lda #$3a			lda 	#KWD_COLON 					; advance to colon/EOL
.8470	a2 80		ldx #$80			ldx 	#KWC_EOL
.8472	20 9f 8d	jsr $8d9f			jsr 	ScanForward
.8475	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dim.asm

.8476					DimCommand:
.8476	b1 30		lda ($30),y			lda 	(codePtr),y
.8478	29 c0		and #$c0			and 	#$C0
.847a	c9 40		cmp #$40			cmp 	#$40
.847c	d0 7a		bne $84f8			bne 	_DCSyntax
.847e	b1 30		lda ($30),y			lda 	(codePtr),y
.8480	18		clc				clc
.8481	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8483	85 3f		sta $3f				sta 	zaTemp+1
.8485	c8		iny				iny
.8486	b1 30		lda ($30),y			lda 	(codePtr),y
.8488	c8		iny				iny
.8489	85 3e		sta $3e				sta 	zaTemp
.848b	5a		phy				phy
.848c	a0 02		ldy #$02			ldy 	#2 						; read type byte
.848e	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8490	29 18		and #$18			and 	#NSBTypeMask 			; check it's not a procedure
.8492	c9 18		cmp #$18			cmp 	#NSTProcedure
.8494	f0 62		beq $84f8			beq 	_DCSyntax
.8496	b1 3e		lda ($3e),y			lda 	(zaTemp),y 				; check it's an array
.8498	29 04		and #$04			and 	#NSBIsArray
.849a	f0 64		beq $8500			beq 	_DCType
.849c	a0 04		ldy #$04			ldy 	#4 						; check not already defined
.849e	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84a0	d0 59		bne $84fb			bne 	_DCRedefine
.84a2	7a		ply				ply
.84a3	20 03 85	jsr $8503			jsr 	_DCGetSize 				; get array size, check it.
.84a6	5a		phy				phy
.84a7	a0 05		ldy #$05			ldy 	#5 						; store in first array size slot
.84a9	91 3e		sta ($3e),y			sta 	(zaTemp),y 				; second will be zero.
.84ab	7a		ply				ply 							; is there a second (e.g. ,x)
.84ac	b1 30		lda ($30),y			lda 	(codePtr),y
.84ae	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.84b0	d0 0a		bne $84bc			bne 	_DCOneDimension
.84b2	c8		iny				iny 							; skip comma
.84b3	20 03 85	jsr $8503			jsr 	_DCGetSize 				; get 2nd array size
.84b6	5a		phy				phy
.84b7	a0 06		ldy #$06			ldy 	#6 						; store in 2nd array size
.84b9	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84bb	7a		ply				ply
.84bc					_DCOneDimension:
.84bc	5a		phy				phy 							; save position
.84bd	a0 05		ldy #$05			ldy 	#5 						; dimensions + 1 in AX (as zero based)
.84bf	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84c1	aa		tax				tax
.84c2	c8		iny				iny
.84c3	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84c5	e8		inx				inx 							; bump them.
.84c6	1a		inc a				inc 	a
.84c7	20 78 9d	jsr $9d78			jsr 	Multiply8x8 			; work out the total number of elements -> zTemp0
.84ca	a5 37		lda $37				lda 	zTemp0+1 				; don't allow more than 8192 elements whatever
.84cc	29 e0		and #$e0			and 	#$E0
.84ce	d0 23		bne $84f3			bne 	_DCSize
.84d0	a0 02		ldy #$02			ldy 	#2 						; get base type
.84d2	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84d4	20 11 85	jsr $8511			jsr 	ScaleByBaseType 		; scale by base type
.84d7	a5 36		lda $36				lda 	zTemp0
.84d9	a6 37		ldx $37				ldx 	zTemp0+1
.84db	20 b7 99	jsr $99b7			jsr 	AllocateXABytes 		; allocate memory
.84de	a0 03		ldy #$03			ldy 	#3 						; copy into the address.
.84e0	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84e2	c8		iny				iny
.84e3	8a		txa				txa
.84e4	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84e6	7a		ply				ply 							; get position back
.84e7	20 a7 8e	jsr $8ea7			jsr 	CheckRightBracket 		; check )
.84ea	b1 30		lda ($30),y			lda 	(codePtr),y
.84ec	c8		iny				iny 							; consume in case
.84ed	c9 2c		cmp #$2c			cmp 	#KWD_COMMA		 		; if so do another DIM.
.84ef	f0 85		beq $8476			beq 	DimCommand
.84f1	88		dey				dey 							; undo consume
.84f2	60		rts				rts
.84f3					_DCSize:
.84f3	a9 16		lda #$16		lda	#22
.84f5	4c c0 8e	jmp $8ec0		jmp	ErrorHandler
.84f8					_DCSyntax:
.84f8	4c 4b 9f	jmp $9f4b			jmp 	SyntaxError
.84fb					_DCRedefine:
.84fb	a9 15		lda #$15		lda	#21
.84fd	4c c0 8e	jmp $8ec0		jmp	ErrorHandler
.8500					_DCType:
.8500	4c 55 9f	jmp $9f55			jmp 	TypeError
.8503					_DCGetSize:
.8503	a2 00		ldx #$00			ldx 	#0 						; get first index.
.8505	20 68 9d	jsr $9d68			jsr 	Evaluate8BitInteger 	; get array dimension
.8508	c9 00		cmp #$00			cmp 	#0 						; must be 1-254
.850a	f0 e7		beq $84f3			beq 	_DCSize
.850c	c9 fe		cmp #$fe			cmp 	#254
.850e	f0 e3		beq $84f3			beq 	_DCSize
.8510	60		rts				rts
.8511					ScaleByBaseType:
.8511	29 10		and #$10			and 	#NSBIsString 			; is it string
.8513	d0 19		bne $852e			bne 	_SBBTString
.8515	a5 37		lda $37				lda 	zTemp0+1 				; push value on stack
.8517	48		pha				pha
.8518	a5 36		lda $36				lda 	zTemp0
.851a	48		pha				pha
.851b	06 36		asl $36				asl 	zTemp0 					; x 2
.851d	26 37		rol $37				rol 	zTemp0+1
.851f	06 36		asl $36				asl 	zTemp0 					; x 4
.8521	26 37		rol $37				rol 	zTemp0+1
.8523	68		pla				pla 							; add stacked value = x 5
.8524	65 36		adc $36				adc 	zTemp0
.8526	85 36		sta $36				sta 	zTemp0
.8528	68		pla				pla
.8529	65 37		adc $37				adc 	zTemp0+1
.852b	85 37		sta $37				sta 	zTemp0+1
.852d	60		rts				rts
.852e					_SBBTString:
.852e	06 36		asl $36				asl 	zTemp0
.8530	26 37		rol $37				rol 	zTemp0+1
.8532	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/end.asm

.8533					EndCommand:
.8533	4c 78 83	jmp $8378			jmp 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/for.asm

.8536					ForCommand:
.8536	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; allocate 18 bytes on the return stack.
.8538	20 0f a6	jsr $a60f			jsr 	StackOpen
.853b	a2 00		ldx #$00			ldx 	#0
.853d	20 0e 98	jsr $980e			jsr 	EvaluateTerm
.8540	b5 50		lda $50,x			lda 	NSStatus,x
.8542	c9 20		cmp #$20			cmp 	#NSBIsReference+NSTInteger 	; do we have an integer 4 byte reference.
.8544	d0 47		bne $858d			bne		_FCError
.8546	a9 3d		lda #$3d			lda 	#KWD_EQUAL 					; =
.8548	20 b7 8e	jsr $8eb7			jsr 	CheckNextA
.854b	e8		inx				inx
.854c	20 3a 9d	jsr $9d3a			jsr 	EvaluateInteger 			; <from> in +1
.854f	b1 30		lda ($30),y			lda 	(codePtr),y
.8551	c8		iny				iny 								; consume it
.8552	48		pha				pha 								; save on stack for later
.8553	c9 b4		cmp #$b4			cmp 	#KWD_DOWNTO
.8555	f0 04		beq $855b			beq 	_FCNoSyntax
.8557	c9 ce		cmp #$ce			cmp 	#KWD_TO
.8559	d0 35		bne $8590			bne 	_FCSyntaxError
.855b					_FCNoSyntax:
.855b	e8		inx				inx
.855c	20 3a 9d	jsr $9d3a			jsr 	EvaluateInteger
.855f	20 54 a6	jsr $a654			jsr 	STKSaveCodePosition 		; save loop back position
.8562	68		pla				pla 								; restore DOWNTO or TO
.8563	5a		phy				phy 								; save Y on the stack
.8564	49 b4		eor #$b4			eor 	#KWD_DOWNTO 				; 0 if DOWNTO, #0 if TO
.8566	f0 02		beq $856a			beq 	_FCNotDownTo
.8568	a9 02		lda #$02			lda 	#2
.856a					_FCNotDownTo:
.856a	3a		dec a				dec 	a 							; 255 if DOWNTO, 1 if TO
.856b	a0 10		ldy #$10			ldy 	#16
.856d	91 34		sta ($34),y			sta 	(basicStack),y 				; copy that out to the Basic Stack.
.856f	a0 06		ldy #$06			ldy 	#6
.8571	a5 58		lda $58				lda 	NSMantissa0
.8573	91 34		sta ($34),y			sta 	(basicStack),y
.8575	a5 60		lda $60				lda 	NSMantissa1
.8577	c8		iny				iny
.8578	91 34		sta ($34),y			sta 	(basicStack),y
.857a	a0 08		ldy #$08			ldy 	#8 							; set initial index value
.857c	a2 01		ldx #$01			ldx 	#1
.857e	20 93 85	jsr $8593			jsr 	FCIntegerToStack
.8581	a0 0c		ldy #$0c			ldy 	#12 						; set the terminal value
.8583	a2 02		ldx #$02			ldx 	#2
.8585	20 93 85	jsr $8593			jsr 	FCIntegerToStack
.8588	20 ae 85	jsr $85ae			jsr 	CopyIndexToReference
.858b	7a		ply				ply 								; restore position
.858c	60		rts				rts
.858d					_FCError:
.858d	4c 55 9f	jmp $9f55			jmp 	TypeError
.8590					_FCSyntaxError:
.8590	4c 4b 9f	jmp $9f4b			jmp 	SyntaxError
.8593					FCIntegerToStack:
.8593	34 50		bit $50,x			bit 	NSStatus,x 					; is the value negative
.8595	10 03		bpl $859a			bpl	 	_FCNotNegative
.8597	20 96 9d	jsr $9d96			jsr 	NSMNegateMantissa 			; if so 2's complement the mantissa
.859a					_FCNotNegative:
.859a	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy out to the basic stack
.859c	91 34		sta ($34),y			sta 	(basicStack),y
.859e	c8		iny				iny
.859f	b5 60		lda $60,x			lda 	NSMantissa1,x
.85a1	91 34		sta ($34),y			sta 	(basicStack),y
.85a3	c8		iny				iny
.85a4	b5 68		lda $68,x			lda 	NSMantissa2,x
.85a6	91 34		sta ($34),y			sta 	(basicStack),y
.85a8	c8		iny				iny
.85a9	b5 70		lda $70,x			lda 	NSMantissa3,x
.85ab	91 34		sta ($34),y			sta 	(basicStack),y
.85ad	60		rts				rts
.85ae					CopyIndexToReference:
.85ae	5a		phy				phy
.85af	a0 06		ldy #$06			ldy 	#6 							; copy address-8 to write to zTemp0
.85b1	38		sec				sec 								; (because we copy from offset 8)
.85b2	b1 34		lda ($34),y			lda 	(basicStack),y
.85b4	e9 08		sbc #$08			sbc 	#8
.85b6	85 36		sta $36				sta 	zTemp0
.85b8	c8		iny				iny
.85b9	b1 34		lda ($34),y			lda 	(basicStack),y
.85bb	e9 00		sbc #$00			sbc 	#0
.85bd	85 37		sta $37				sta 	zTemp0+1
.85bf	a2 04		ldx #$04			ldx 	#4 							; this is the copy counter/
.85c1	a0 0b		ldy #$0b			ldy 	#8+3 		 				; the MSB of the mantissa
.85c3	b1 34		lda ($34),y			lda 	(basicStack),y
.85c5	0a		asl a				asl 	a 							; into carry
.85c6	a0 08		ldy #$08			ldy 	#8 							; where to copy from.
.85c8	90 14		bcc $85de			bcc 	_CITRNormal
.85ca	38		sec				sec
.85cb					_CITRNegative:
.85cb	a9 00		lda #$00			lda 	#0
.85cd	f1 34		sbc ($34),y			sbc 	(basicStack),y
.85cf	91 36		sta ($36),y			sta 	(zTemp0),y
.85d1	c8		iny				iny
.85d2	ca		dex				dex
.85d3	d0 f6		bne $85cb			bne 	_CITRNegative
.85d5	88		dey				dey 								; look at MSB of mantissa
.85d6	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set the MSB as negative packed.
.85d8	09 80		ora #$80			ora 	#$80
.85da	91 36		sta ($36),y			sta 	(zTemp0),y
.85dc	7a		ply				ply
.85dd	60		rts				rts
.85de					_CITRNormal:
.85de	b1 34		lda ($34),y			lda 	(basicStack),y 				; copy without negation.
.85e0	91 36		sta ($36),y			sta 	(zTemp0),y
.85e2	c8		iny				iny
.85e3	ca		dex				dex
.85e4	d0 f8		bne $85de			bne 	_CITRNormal
.85e6	7a		ply				ply 								; and exit.
.85e7	60		rts				rts
.85e8					NextCommand:
.85e8	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; check FOR is TOS
.85ea	a2 11		ldx #$11			ldx 	#ERRID_FOR 					; this error
.85ec	20 3c a6	jsr $a63c			jsr 	StackCheckFrame
.85ef	5a		phy				phy
.85f0	a0 10		ldy #$10			ldy 	#16 						; get the step count
.85f2	b1 34		lda ($34),y			lda 	(basicStack),y
.85f4	85 36		sta $36				sta 	zTemp0 						; this is the sign extend
.85f6	30 02		bmi $85fa			bmi 	_NCStepNeg
.85f8	64 36		stz $36				stz 	zTemp0 						; which is 0 or 255
.85fa					_NCStepNeg:
.85fa	a0 08		ldy #$08			ldy 	#8 							; offset to bump
.85fc	a2 04		ldx #$04			ldx 	#4 							; count to bump
.85fe	18		clc				clc
.85ff					_NCBump:
.85ff	71 34		adc ($34),y			adc 	(basicStack),y 				; add it
.8601	91 34		sta ($34),y			sta 	(basicStack),y
.8603	a5 36		lda $36				lda 	zTemp0 						; get sign extend for next time.
.8605	c8		iny				iny 								; next byte
.8606	ca		dex				dex 								; do four times
.8607	d0 f6		bne $85ff			bne 	_NCBump
.8609	20 ae 85	jsr $85ae			jsr		CopyIndexToReference		; copy it to the reference variable.
.860c	a0 10		ldy #$10			ldy 	#16 						; get step count again
.860e	b1 34		lda ($34),y			lda 	(basicStack),y
.8610	0a		asl a				asl 	a 							; sign bit to carry
.8611	a9 0c		lda #$0c			lda 	#12 						; offset of LHS = terminal offset
.8613	85 38		sta $38				sta 	zTemp1
.8615	90 02		bcc $8619			bcc 	_NCCompRev 					; use if step is +ve
.8617	a9 08		lda #$08			lda 	#8 							; now the LHS = index value
.8619					_NCCompRev:
.8619	85 38		sta $38				sta 	zTemp1 						; so zTemp0 is the index for LHS
.861b	49 04		eor #$04			eor 	#(8^12) 					; and zTemp0+1 is the index for RHS
.861d	85 39		sta $39				sta 	zTemp1+1
.861f	a2 04		ldx #$04			ldx 	#4 							; bytes to compare
.8621	38		sec				sec
.8622					_NCCompare:
.8622	a4 38		ldy $38				ldy 	zTemp1 						; do compare using the two indices
.8624	b1 34		lda ($34),y			lda 	(basicStack),y
.8626	a4 39		ldy $39				ldy 	zTemp1+1
.8628	f1 34		sbc ($34),y			sbc 	(basicStack),y
.862a	e6 38		inc $38				inc 	zTemp1 						; bump the indices (inc,dex do not change C or V)
.862c	e6 39		inc $39				inc 	zTemp1+1
.862e	ca		dex				dex 								; do it 4 times.
.862f	d0 f1		bne $8622			bne 	_NCCompare
.8631	50 02		bvc $8635			bvc 	_NCNoOverflow 				; convert to signed comparison
.8633	49 80		eor #$80			eor 	#$80
.8635					_NCNoOverflow:
.8635	7a		ply				ply 								; restore Y position
.8636	0a		asl a				asl 	a 							; is bit 7 set.
.8637	90 04		bcc $863d			bcc 	_NCLoopback 				; if no , >= so loop back
.8639	20 2e a6	jsr $a62e			jsr 	StackClose 					; exit the loop
.863c	60		rts				rts
.863d					_NCLoopBack:
.863d	20 65 a6	jsr $a665			jsr 	STKLoadCodePosition 		; loop back
.8640	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/gosub.asm

.8641					Command_GOSUB:
.8641	a2 00		ldx #$00			ldx 	#0
.8643	20 4d 9d	jsr $9d4d			jsr 	Evaluate16BitInteger 		; line number in Stack.0
.8646	a9 e3		lda #$e3			lda 	#STK_GOSUB+3
.8648	20 0f a6	jsr $a60f			jsr 	StackOpen 					; create frame
.864b	20 54 a6	jsr $a654			jsr 	STKSaveCodePosition 		; save current position
.864e	4c 64 86	jmp $8664			jmp 	GotoStackX
.8651					Command_RETURN:
.8651	a9 e0		lda #$e0			lda 	#STK_GOSUB 					; check TOS is this
.8653	a2 0e		ldx #$0e			ldx 	#ERRID_GOSUB 				; this error
.8655	20 3c a6	jsr $a63c			jsr 	StackCheckFrame
.8658	20 65 a6	jsr $a665			jsr 	STKLoadCodePosition 		; restore code position
.865b	20 2e a6	jsr $a62e			jsr 	StackClose
.865e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/goto.asm

.865f					GotoCommand:
.865f	a2 00		ldx #$00			ldx 	#0 							; GOTO where
.8661	20 4d 9d	jsr $9d4d			jsr 	Evaluate16BitInteger
.8664					GotoStackX:
.8664	b5 60		lda $60,x			lda  	NSMantissa1,x 				; put line # in XA. I'll keep this even though
.8666	48		pha				pha 								; it is slightly inefficient, just in cases.
.8667	b5 58		lda $58,x			lda 	NSMantissa0,x
.8669	fa		plx				plx
.866a	20 39 a5	jsr $a539			jsr 	MemorySearch 				; transfer to line number AX.
.866d	90 05		bcc $8674			bcc 	_GotoError 					; not found, off end.
.866f	d0 03		bne $8674			bne 	_GotoError 					; not found exactly
.8671	4c ed 8a	jmp $8aed			jmp 	RunNewLine 					; and go straight to new line code.
.8674					_GotoError:
.8674	a9 0d		lda #$0d		lda	#13
.8676	4c c0 8e	jmp $8ec0		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/if.asm

.8679					IfCommand:
.8679	a2 00		ldx #$00			ldx 	#0 							; If what.
.867b	20 1b 9d	jsr $9d1b			jsr 	EvaluateNumber
.867e	b1 30		lda ($30),y			lda 	(codePtr),y
.8680	c9 a8		cmp #$a8			cmp 	#KWD_THEN  					; could be THEN <stuff> or GOTO
.8682	d0 0a		bne $868e			bne 	_IFStructured
.8684	c8		iny				iny 								; consume THEN
.8685	20 ef 9d	jsr $9def			jsr 	NSMIsZero 					; is it zero
.8688	f0 01		beq $868b			beq 	_IfFail 					; if fail, go to next line
.868a	60		rts				rts 								; if THEN just continue
.868b					_IfFail:
.868b	4c d5 8a	jmp $8ad5			jmp 	EOLCommand
.868e					_IfStructured:
.868e	20 ef 9d	jsr $9def			jsr 	NSMIsZero 					; is it zero
.8691	d0 07		bne $869a			bne 	_IfExit 					; if not, then continue normally.
.8693	a9 b5		lda #$b5			lda 	#KWD_ELSE 					; look for else/endif
.8695	a2 a5		ldx #$a5			ldx 	#KWD_ENDIF
.8697	20 9f 8d	jsr $8d9f			jsr 	ScanForward 				; and run from there/
.869a					_IfExit:
.869a	60		rts				rts
.869b					ElseCode:
.869b	a9 a5		lda #$a5			lda 	#KWD_ENDIF 					; else is only run after the if clause succeeds
.869d	aa		tax				tax 								; so just go to the structure exit
.869e	20 9f 8d	jsr $8d9f			jsr 	ScanForward
.86a1	60		rts				rts
.86a2					EndIf:
.86a2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/inputprint.asm

.86a3					Command_Input:
.86a3	a9 ff		lda #$ff			lda 	#$FF 						; set input flag
.86a5	8d 28 04	sta $0428			sta 	IsInputFlag
.86a8	80 03		bra $86ad			bra 	Command_IP_Main
.86aa					Command_Print:
.86aa	9c 28 04	stz $0428			stz 	IsInputFlag 				; clear input flag
.86ad					Command_IP_Main:
.86ad	18		clc				clc 								; carry being clear means last print wasn't comma/semicolon
.86ae					_CPLoop:
.86ae	08		php				php 								; save last action flag
.86af	b1 30		lda ($30),y			lda 	(codePtr),y
.86b1	c9 80		cmp #$80			cmp  	#KWC_EOL 					; end of line or colon, exit now.
.86b3	f0 54		beq $8709			beq 	_CPExit
.86b5	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.86b7	f0 50		beq $8709			beq 	_CPExit
.86b9	68		pla				pla 								; throw last action flag
.86ba	b1 30		lda ($30),y			lda 	(codePtr),y
.86bc	c8		iny				iny
.86bd	c9 3b		cmp #$3b			cmp 	#KWD_SEMICOLON				; is it a semicolon
.86bf	f0 45		beq $8706			beq 	_CPContinueWithSameLine
.86c1	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; comma
.86c3	f0 3c		beq $8701			beq 	_CPTab
.86c5	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; apostrophe (new line)
.86c7	f0 34		beq $86fd			beq 	_CPNewLine
.86c9	88		dey				dey 								; undo the get.
.86ca	20 c2 93	jsr $93c2			jsr 	EvaluateExpressionAt0 		; evaluate expression at 0.
.86cd	b5 50		lda $50,x			lda 	NSStatus,x 					; read the status
.86cf	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.86d1	f0 0d		beq $86e0			beq 	_CPIsValue 					; no, display it.
.86d3	ad 28 04	lda $0428			lda 	IsInputFlag 				; if print, dereference and print.
.86d6	f0 05		beq $86dd			beq 	_CPIsPrint 					; otherwise display.
.86d8	20 12 87	jsr $8712			jsr 	CIInputValue 				; input a value to the reference
.86db	80 20		bra $86fd			bra 	_CPNewLine
.86dd					_CPIsPrint:
.86dd	20 87 96	jsr $9687			jsr 	Dereference 				; dereference if required.
.86e0					_CPIsValue:
.86e0	b5 50		lda $50,x			lda 	NSStatus,x 					; is it a number
.86e2	29 10		and #$10			and 	#NSBIsString
.86e4	f0 09		beq $86ef			beq 	_CPNumber
.86e6	a6 60		ldx $60				ldx 	NSMantissa1 				; string, print the text.
.86e8	a5 58		lda $58				lda 	NSMantissa0
.86ea	20 75 87	jsr $8775			jsr 	CPPrintStringXA
.86ed	80 be		bra $86ad			bra 	Command_IP_Main 			; loop round clearing carry so NL if end
.86ef					_CPNumber:
.86ef	a9 05		lda #$05			lda 	#5 							; maximum decimals
.86f1	20 02 9c	jsr $9c02			jsr 	ConvertNumberToString 		; convert to string (in unary str$() function)
.86f4	a2 05		ldx #$05			ldx 	#DecimalBuffer >> 8
.86f6	a9 9d		lda #$9d			lda 	#DecimalBuffer & $FF
.86f8	20 75 87	jsr $8775			jsr 	CPPrintStringXA 			; print it.
.86fb	80 b0		bra $86ad			bra 	Command_IP_Main				; loop round clearing carry so NL if end
.86fd					_CPNewLine:
.86fd	a9 0d		lda #$0d			lda 	#13
.86ff	80 02		bra $8703			bra 	_CPPrintChar
.8701					_CPTab:
.8701	a9 09		lda #$09			lda 	#9 							; print TAB
.8703					_CPPrintChar:
.8703	20 88 87	jsr $8788			jsr 	CPPrintVector
.8706					_CPContinueWithSameLine:
.8706	38		sec				sec 								; loop round with carry set, which
.8707	80 a5		bra $86ae			bra 	_CPLoop 					; will inhibit final CR
.8709					_CPExit:
.8709	28		plp				plp 								; get last action flag
.870a	b0 05		bcs $8711			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.870c	a9 0d		lda #$0d			lda 	#13 						; print new line
.870e	20 88 87	jsr $8788			jsr 	CPPrintVector
.8711					_CPExit2:
.8711	60		rts				rts
.8712					CIInputValue:
.8712	a2 00		ldx #$00			ldx 	#0 							; input a line.
.8714					_CIInputLine:
.8714	20 8b 87	jsr $878b			jsr 	CPInputVector 				; get key
.8717	c9 0d		cmp #$0d			cmp 	#13 						; 13 = End
.8719	f0 1f		beq $873a			beq 	_CIHaveValue
.871b	c9 08		cmp #$08			cmp 	#8 							; 8 = BS
.871d	f0 11		beq $8730			beq 	_CIBackspace
.871f	c9 20		cmp #$20			cmp 	#32 						; ignore other control characters
.8721	90 f1		bcc $8714			bcc 	_CIInputLine
.8723	e0 50		cpx #$50			cpx 	#80 						; max length
.8725	b0 ed		bcs $8714			bcs 	_CIInputLine
.8727	9d 2a 05	sta $052a,x			sta 	lineBuffer,x
.872a	e8		inx				inx
.872b	20 88 87	jsr $8788			jsr 	CPPrintVector 				; echo it.
.872e	80 e4		bra $8714			bra 	_CIInputLine
.8730					_CIBackSpace:
.8730	e0 00		cpx #$00			cpx 	#0 							; nothing to delete
.8732	f0 e0		beq $8714			beq 	_CIInputLine
.8734	20 88 87	jsr $8788			jsr 	CPPrintVector 				; echo it.
.8737	ca		dex				dex
.8738	80 da		bra $8714			bra 	_CIInputLine
.873a					_CIHaveValue:
.873a	9e 2a 05	stz $052a,x			stz 	LineBuffer,x 				; ASCIIZ string now in line buffer.
.873d	a5 50		lda $50				lda 	NSStatus 					; was it a string assignment
.873f	29 10		and #$10			and 	#NSBIsString
.8741	f0 17		beq $875a			beq 	_CIAssignNumber 			; assign a number
.8743	a2 01		ldx #$01			ldx 	#1
.8745	a9 2a		lda #$2a			lda 	#lineBuffer & $FF 			; set up to point to new string
.8747	95 58		sta $58,x			sta 	NSMantissa0,x
.8749	a9 05		lda #$05			lda 	#lineBuffer >> 8
.874b	95 60		sta $60,x			sta 	NSMantissa1,x
.874d	74 68		stz $68,x			stz 	NSMantissa2,x
.874f	74 70		stz $70,x			stz 	NSMantissa3,x
.8751	a9 10		lda #$10			lda 	#NSBIsString 				; so it becomes a string value
.8753	95 50		sta $50,x			sta  	NSStatus,x
.8755	ca		dex				dex 								; X = 0
.8756	20 c7 87	jsr $87c7			jsr 	AssignVariable
.8759	60		rts				rts
.875a					_CIAssignNumber:
.875a	a9 2a		lda #$2a			lda 	#lineBuffer & $FF 			; set up to point to new string
.875c	85 36		sta $36				sta 	zTemp0
.875e	a9 05		lda #$05			lda 	#lineBuffer >> 8
.8760	85 37		sta $37				sta 	zTemp0+1
.8762	a2 01		ldx #$01			ldx 	#1 							; put in slot 1
.8764	20 84 9b	jsr $9b84			jsr 	ValEvaluateZTemp0 			; use the VAL() code
.8767	90 07		bcc $8770			bcc 	_CIIsOkay
.8769	a9 3f		lda #$3f			lda 	#"?" 						; error ?
.876b	20 88 87	jsr $8788			jsr 	CPPrintVector
.876e	80 a2		bra $8712			bra 	CIInputValue
.8770					_CIIsOkay:
.8770	ca		dex				dex 								; X = 0
.8771	20 c7 87	jsr $87c7			jsr 	AssignVariable
.8774	60		rts				rts
.8775					CPPrintStringXA:
.8775	5a		phy				phy
.8776	86 37		stx $37				stx 	zTemp0+1
.8778	85 36		sta $36				sta 	zTemp0
.877a	a0 00		ldy #$00			ldy 	#0
.877c					_PSXALoop:
.877c	b1 36		lda ($36),y			lda 	(zTemp0),y
.877e	f0 06		beq $8786			beq 	_PSXAExit
.8780	20 88 87	jsr $8788			jsr 	CPPrintVector
.8783	c8		iny				iny
.8784	80 f6		bra $877c			bra 	_PSXALoop
.8786					_PSXAExit:
.8786	7a		ply				ply
.8787	60		rts				rts
.8788					CPPrintVector:
.8788	4c 03 80	jmp $8003			jmp 	EXTPrintCharacter
.878b					CPInputVector:
.878b	4c 09 80	jmp $8009			jmp 	EXTInputSingleCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/let.asm

.878e					LetCommand:
.878e	a2 00		ldx #$00			ldx 	#0
.8790	b1 30		lda ($30),y			lda 	(codePtr),y
.8792	c9 10		cmp #$10			cmp 	#KWD_AT
.8794	d0 14		bne $87aa			bne 	_LCStandard
.8796	c8		iny				iny 								; skip equal
.8797	20 0e 98	jsr $980e			jsr 	EvaluateTerm 				; get a number (the address of the reference)
.879a	20 87 96	jsr $9687			jsr 	Dereference 				; dereference it to a value
.879d	b5 50		lda $50,x			lda 	NSStatus,x 					; check integer
.879f	49 20		eor #$20			eor 	#NSBIsReference	 			; toggle reference
.87a1	95 50		sta $50,x			sta 	NSStatus,x
.87a3	29 20		and #$20			and 	#NSBIsReference 			; if it is now a reference, continue
.87a5	d0 0f		bne $87b6			bne 	_LCMain
.87a7	4c 55 9f	jmp $9f55			jmp 	TypeError 					; was a reference before.
.87aa					_LCStandard:
.87aa	ad ac 93	lda $93ac			lda 	PrecedenceLevel+"*"			; precedence > this
.87ad	20 c6 93	jsr $93c6			jsr 	EvaluateExpressionAtPrecedence
.87b0	b5 50		lda $50,x			lda 	NSStatus,x 					; is it a reference to an array marked as procedure ?
.87b2	c9 38		cmp #$38			cmp		#NSTProcedure+NSBIsReference
.87b4	f0 0e		beq $87c4			beq 	_LetGoProc 					; it's a procedure call.
.87b6					_LCMain:
.87b6	a9 3d		lda #$3d			lda 	#"=" 						; check =
.87b8	20 b7 8e	jsr $8eb7			jsr 	CheckNextA
.87bb	e8		inx				inx 								; RHS
.87bc	20 12 9d	jsr $9d12			jsr 	EvaluateValue
.87bf	ca		dex				dex
.87c0	20 c7 87	jsr $87c7			jsr 	AssignVariable
.87c3	60		rts				rts
.87c4					_LetGoProc:
.87c4	4c ab 89	jmp $89ab			jmp 	CallProcedure
.87c7					AssignVariable:
.87c7	b5 50		lda $50,x			lda 	NSStatus,x 					; check the string/number type bits match
.87c9	48		pha				pha 								; save a copy
.87ca	55 51		eor $51,x			eor 	NSStatus+1,x
.87cc	29 10		and #$10			and 	#NSBIsString
.87ce	d0 0b		bne $87db			bne 	_ASError
.87d0	68		pla				pla 								; get back
.87d1	29 10		and #$10			and 	#NSBIsString 				; check type
.87d3	d0 03		bne $87d8			bne 	_ASString
.87d5	4c c5 95	jmp $95c5			jmp 	AssignNumber
.87d8					_ASString:
.87d8	4c 23 96	jmp $9623			jmp 	AssignString
.87db					_ASError:
.87db	4c 55 9f	jmp $9f55			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/list.asm

.87de					Command_List:
.87de	9c 26 04	stz $0426			stz 	listIndent 					; reset indent.
.87e1	b1 30		lda ($30),y			lda 	(codePtr),y
.87e3	29 c0		and #$c0			and 	#$C0
.87e5	c9 40		cmp #$40			cmp 	#$40
.87e7	f0 69		beq $8852			beq 	_CLListProcedure
.87e9	64 5c		stz $5c				stz		NSMantissa0+4				; set the lower (slot 4) to 0 and upper (slot 7) to $FFFF
.87eb	64 64		stz $64				stz 	NSMantissa1+4
.87ed	a9 ff		lda #$ff			lda 	#$FF
.87ef	85 5f		sta $5f				sta 	NSMantissa0+7
.87f1	85 67		sta $67				sta 	NSMantissa1+7
.87f3	b1 30		lda ($30),y			lda 	(codePtr),y
.87f5	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.87f7	f0 1a		beq $8813			beq 	_CLSecond
.87f9	20 cf 88	jsr $88cf			jsr 	CLIsDigit 					; if not digit, list all
.87fc	b0 20		bcs $881e			bcs 	_CLStart
.87fe	a2 04		ldx #$04			ldx 	#4 							; get 1st range into slot 4
.8800	20 4d 9d	jsr $9d4d			jsr 	Evaluate16BitInteger
.8803	b1 30		lda ($30),y			lda 	(codePtr),y
.8805	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8807	f0 0a		beq $8813			beq 	_CLSecond 					; if so go get it
.8809	a5 5c		lda $5c				lda 	NSMantissa0+4 				; copy 4->7
.880b	85 5f		sta $5f				sta 	NSMantissa0+7
.880d	a5 64		lda $64				lda 	NSMantissa1+4
.880f	85 67		sta $67				sta 	NSMantissa1+7
.8811	80 0b		bra $881e			bra 	_CLStart
.8813					_CLSecond:
.8813	c8		iny				iny 								; consume comma
.8814	20 cf 88	jsr $88cf			jsr 	CLIsDigit 					; digit found
.8817	b0 05		bcs $881e			bcs 	_CLStart 					; if not, continue listing
.8819	a2 07		ldx #$07			ldx 	#7 							; load 2nd range into slot 7
.881b	20 4d 9d	jsr $9d4d			jsr 	Evaluate16BitInteger
.881e					_CLStart
.881e	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8820	85 30		sta $30				sta 	codePtr
.8822	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8824	85 31		sta $31				sta 	codePtr+1
.8826					_CLLoop:
.8826	20 0c 80	jsr $800c			jsr 	EXTBreakCheck 				; break check
.8829	f0 24		beq $884f			beq 	_CLExit
.882b	b2 30		lda ($30)			lda 	(codePtr)
.882d	f0 20		beq $884f			beq 	_CLExit
.882f	a2 04		ldx #$04			ldx 	#4 							; check range every time, line numbers aren't in order.
.8831	20 be 88	jsr $88be			jsr 	CLCompareLineNo
.8834	90 0c		bcc $8842			bcc 	_CLNext
.8836	a2 07		ldx #$07			ldx 	#7
.8838	20 be 88	jsr $88be			jsr 	CLCompareLineNo
.883b	f0 02		beq $883f			beq 	_CLDoThisOne
.883d	b0 03		bcs $8842			bcs 	_CLNext
.883f					_CLDoThisOne:
.883f	20 ab 88	jsr $88ab			jsr 	CLListOneLine
.8842					_CLNext:
.8842	18		clc				clc
.8843	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8845	65 30		adc $30				adc 	codePtr
.8847	85 30		sta $30				sta 	codePtr
.8849	90 02		bcc $884d			bcc 	_CREExit
.884b	e6 31		inc $31				inc 	codePtr+1 					; carry
.884d					_CREExit:
.884d	80 d7		bra $8826			bra 	_CLLoop
.884f					_CLExit:
.884f	4c 78 83	jmp $8378			jmp 	WarmStart
.8852					_CLListProcedure:
.8852	b1 30		lda ($30),y			lda 	(codePtr),y
.8854	85 38		sta $38				sta 	zTemp1
.8856	c8		iny				iny
.8857	b1 30		lda ($30),y			lda 	(codePtr),y
.8859	85 39		sta $39				sta 	zTemp1+1
.885b	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.885d	85 30		sta $30				sta 	codePtr
.885f	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8861	85 31		sta $31				sta 	codePtr+1
.8863					_CLLPSearch:
.8863	b2 30		lda ($30)			lda 	(codePtr)
.8865	c9 00		cmp #$00			cmp 	#0 							; if zero, end
.8867	f0 e6		beq $884f			beq 	_CLExit
.8869	a0 03		ldy #$03			ldy 	#3 							; check if PROC something
.886b	b1 30		lda ($30),y			lda 	(codePtr),y
.886d	c9 a2		cmp #$a2			cmp 	#KWD_PROC
.886f	d0 0e		bne $887f			bne 	_CLLPNext
.8871	c8		iny				iny 								; check if PROC this.
.8872	b1 30		lda ($30),y			lda 	(codePtr),y
.8874	c5 38		cmp $38				cmp 	zTemp1 						; does it match ?
.8876	d0 07		bne $887f			bne 	_CLLPNext
.8878	c8		iny				iny
.8879	b1 30		lda ($30),y			lda 	(codePtr),y
.887b	c5 39		cmp $39				cmp 	zTemp1+1
.887d	f0 0d		beq $888c			beq 	_CLLPFound
.887f					_CLLPNext:
.887f	18		clc				clc
.8880	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8882	65 30		adc $30				adc 	codePtr
.8884	85 30		sta $30				sta 	codePtr
.8886	90 02		bcc $888a			bcc 	_CREExit
.8888	e6 31		inc $31				inc 	codePtr+1 					; carry
.888a					_CREExit:
.888a	80 d7		bra $8863			bra 	_CLLPSearch
.888c					_CLLPFound:
.888c	b2 30		lda ($30)			lda 	(codePtr)
.888e	f0 bf		beq $884f			beq 	_CLExit
.8890	a0 03		ldy #$03			ldy 	#3 							; get first keyword
.8892	b1 30		lda ($30),y			lda 	(codePtr),y
.8894	48		pha				pha
.8895	20 ab 88	jsr $88ab			jsr 	CLListOneLine 				; list line and go forward
.8898	18		clc				clc
.8899	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.889b	65 30		adc $30				adc 	codePtr
.889d	85 30		sta $30				sta 	codePtr
.889f	90 02		bcc $88a3			bcc 	_CREExit
.88a1	e6 31		inc $31				inc 	codePtr+1 					; carry
.88a3					_CREExit:
.88a3	68		pla				pla 								; reached ENDPROC ?
.88a4	c9 a6		cmp #$a6			cmp 	#KWD_ENDPROC
.88a6	d0 e4		bne $888c			bne 	_CLLPFound
.88a8	4c 78 83	jmp $8378			jmp 	WarmStart
.88ab					CLListOneLine:
.88ab	20 02 8e	jsr $8e02			jsr 	ScanGetCurrentLineStep 		; get indent adjust.
.88ae	20 1e 80	jsr $801e			jsr 	TKListConvertLine 			; convert line into token Buffer
.88b1	a2 04		ldx #$04			ldx 	#(tokenBuffer >> 8) 		; print that line
.88b3	a9 2d		lda #$2d			lda 	#(tokenBuffer & $FF)
.88b5	20 19 8f	jsr $8f19			jsr 	PrintStringXA
.88b8	a9 0d		lda #$0d			lda 	#13 						; new line
.88ba	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.88bd	60		rts				rts
.88be					CLCompareLineNo:
.88be	38		sec				sec
.88bf	a0 01		ldy #$01			ldy 	#1
.88c1	b1 30		lda ($30),y			lda 	(codePtr),y
.88c3	f5 58		sbc $58,x			sbc 	NSMantissa0,x
.88c5	85 36		sta $36				sta 	zTemp0
.88c7	c8		iny				iny
.88c8	b1 30		lda ($30),y			lda 	(codePtr),y
.88ca	f5 60		sbc $60,x			sbc 	NSMantissa1,x
.88cc	05 36		ora $36				ora 	zTemp0
.88ce	60		rts				rts
.88cf					CLIsDigit:
.88cf	b1 30		lda ($30),y			lda 	(codePtr),y
.88d1	c9 30		cmp #$30			cmp 	#"0"
.88d3	90 03		bcc $88d8			bcc	 	_CLIDExitFalse
.88d5	c9 3a		cmp #$3a			cmp 	#"9"+1
.88d7	60		rts				rts
.88d8					_CLIDExitFalse:
.88d8	38		sec				sec
.88d9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/local.asm

.88da					Command_LOCAL:
.88da	a2 00		ldx #$00			ldx 	#0 							; at level 0
.88dc	20 e8 88	jsr $88e8			jsr 	LocaliseNextTerm 			; convert term to a local.
.88df	b1 30		lda ($30),y			lda 	(codePtr),y
.88e1	c8		iny				iny
.88e2	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.88e4	f0 f4		beq $88da			beq 	Command_LOCAL
.88e6	88		dey				dey 								; unpick pre-get
.88e7	60		rts				rts
.88e8					LocaliseNextTerm:
.88e8	20 0e 98	jsr $980e			jsr 	EvaluateTerm 				; evaluate the term
.88eb	b5 50		lda $50,x			lda 	NSStatus,x
.88ed	29 20		and #$20			and 	#NSBIsReference 			; check it is a reference
.88ef	f0 5c		beq $894d			beq		_LNTError
.88f1	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address of variable to zTemp0
.88f3	85 36		sta $36				sta 	zTemp0
.88f5	b5 60		lda $60,x			lda 	NSMantissa1,x
.88f7	85 37		sta $37				sta  	zTemp0+1
.88f9	b5 50		lda $50,x			lda 	NSStatus,x
.88fb	29 10		and #$10			and 	#NSBIsString
.88fd	d0 1e		bne $891d			bne 	_LNTPushString
.88ff	5a		phy				phy
.8900	a0 00		ldy #$00			ldy 	#0 							; push 0 to 4 inclusive, the number values, on the stack, and zero them as you go.
.8902					_LNTPushNumLoop:
.8902	b1 36		lda ($36),y			lda		(zTemp0),y
.8904	20 ee a5	jsr $a5ee			jsr 	StackPushByte
.8907	c8		iny				iny
.8908	c0 05		cpy #$05			cpy 	#5
.890a	d0 f6		bne $8902			bne 	_LNTPushNumLoop
.890c	a5 36		lda $36				lda 	zTemp0 						; push the actual target address to write on the stack
.890e	20 ee a5	jsr $a5ee			jsr 	StackPushByte
.8911	a5 37		lda $37				lda 	zTemp0+1
.8913	20 ee a5	jsr $a5ee			jsr 	StackPushByte
.8916	a9 01		lda #$01			lda 	#STK_LOCALN 				; push local-number marker.
.8918	20 ee a5	jsr $a5ee			jsr 	StackPushByte
.891b	7a		ply				ply
.891c	60		rts				rts
.891d					_LNTPushString:
.891d	5a		phy				phy
.891e	b2 36		lda ($36)			lda 	(zTemp0) 					; put address of string in zTemp1
.8920	85 38		sta $38				sta 	zTemp1
.8922	a0 01		ldy #$01			ldy 	#1
.8924	b1 36		lda ($36),y			lda 	(zTemp0),y
.8926	85 39		sta $39				sta 	zTemp1+1
.8928	a0 00		ldy #$00			ldy 	#0 							; output string
.892a	c9 00		cmp #$00			cmp 	#0 							; if not assigned strin
.892c	f0 0a		beq $8938			beq 	_LNTStringOut
.892e					_LNTPushStrLoop:
.892e	b1 38		lda ($38),y			lda 	(zTemp1),y
.8930	f0 06		beq $8938			beq 	_LNTStringOut
.8932	20 ee a5	jsr $a5ee			jsr 	StackPushByte
.8935	c8		iny				iny
.8936	80 f6		bra $892e			bra 	_LNTPushStrLoop
.8938					_LNTStringOut:
.8938	98		tya				tya									; output length
.8939	20 ee a5	jsr $a5ee			jsr 	StackPushByte
.893c	b5 58		lda $58,x			lda 	NSMantissa0,x 				; output address of the string record *not* the string itself
.893e	20 ee a5	jsr $a5ee			jsr 	StackPushByte
.8941	b5 60		lda $60,x			lda 	NSMantissa1,x
.8943	20 ee a5	jsr $a5ee			jsr 	StackPushByte
.8946	a9 02		lda #$02			lda 	#STK_LOCALS 				; push local-string marker.
.8948	20 ee a5	jsr $a5ee			jsr 	StackPushByte
.894b	7a		ply				ply
.894c	60		rts				rts
.894d					_LNTError:
.894d	4c 4b 9f	jmp $9f4b			jmp 	SyntaxError
.8950					LocalPopValue:
.8950	20 06 a6	jsr $a606			jsr 	StackPopByte
.8953	c9 01		cmp #$01			cmp 	#STK_LOCALN 				; if not local-N
.8955	d0 17		bne $896e			bne 	_LPVString
.8957	20 06 a6	jsr $a606			jsr 	StackPopByte 				; address
.895a	85 37		sta $37				sta 	zTemp0+1
.895c	20 06 a6	jsr $a606			jsr 	StackPopByte
.895f	85 36		sta $36				sta 	zTemp0
.8961	5a		phy				phy
.8962	a0 04		ldy #$04			ldy 	#4 							; copy back
.8964					_LPVNumberCopy:
.8964	20 06 a6	jsr $a606			jsr 	StackPopByte
.8967	91 36		sta ($36),y			sta 	(zTemp0),y
.8969	88		dey				dey
.896a	10 f8		bpl $8964			bpl 	_LPVNumberCopy
.896c	7a		ply				ply 								; and complete
.896d	60		rts				rts
.896e					_LPVString:
.896e	20 06 a6	jsr $a606			jsr 	StackPopByte 				; address of record => zTemp0
.8971	85 37		sta $37				sta 	zTemp0+1
.8973	20 06 a6	jsr $a606			jsr 	StackPopByte
.8976	85 36		sta $36				sta 	zTemp0
.8978	5a		phy				phy
.8979	b2 36		lda ($36)			lda 	(zTemp0) 					; address to write string to => zTemp1
.897b	85 38		sta $38				sta 	zTemp1
.897d	a0 01		ldy #$01			ldy 	#1
.897f	b1 36		lda ($36),y			lda 	(zTemp0),y
.8981	85 39		sta $39				sta 	zTemp1+1
.8983	20 06 a6	jsr $a606			jsr 	StackPopByte 				; # to get => y
.8986	a8		tay				tay
.8987	a5 39		lda $39				lda 	zTemp1+1 					; if no target (e.g. was "" originally) exit
.8989	f0 0e		beq $8999			beq 	_LPVStringCopied
.898b	a9 00		lda #$00			lda 	#0 							; NULL on end
.898d	91 38		sta ($38),y			sta 	(zTemp1),y
.898f					_LPVStringCopy:
.898f	88		dey				dey
.8990	30 07		bmi $8999			bmi 	_LPVStringCopied
.8992	20 06 a6	jsr $a606			jsr 	StackPopByte
.8995	91 38		sta ($38),y			sta 	(zTemp1),y
.8997	80 f6		bra $898f			bra 	_LPVStringCopy
.8999					_LPVStringCopied:
.8999	fa		plx				plx
.899a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/new.asm

.899b					NewCommand:
.899b	20 a1 89	jsr $89a1			jsr 	NewProgram 					; does the actual NEW.
.899e	4c 78 83	jmp $8378			jmp 	WarmStart 					; and warm starts straight away.
.89a1					NewProgram:
.89a1	20 1b a5	jsr $a51b			jsr 	MemoryNew
.89a4	9c 00 10	stz $1000			stz 	VariableSpace 				; erase all variables.
.89a7	20 0e 84	jsr $840e			jsr 	ClearCommand 				; clear everything.
.89aa	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/procedure.asm

=2					ParameterStackPos = 2
.89ab					CallProcedure:
.89ab	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start storing parameters at 2.
.89ad	b1 30		lda ($30),y			lda 	(codePtr),y
.89af	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.89b1	f0 0c		beq $89bf			beq 	_CPEndParam
.89b3					_CPParamLoop:
.89b3	20 12 9d	jsr $9d12			jsr 	EvaluateValue 				; get parameter onto stack
.89b6	e8		inx				inx 								; bump next stack
.89b7	b1 30		lda ($30),y			lda 	(codePtr),y
.89b9	c8		iny				iny
.89ba	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if comma, go back and try again.
.89bc	f0 f5		beq $89b3			beq 	_CPParamLoop
.89be	88		dey				dey 								; unpick.
.89bf					_CPEndParam:
.89bf	8e 16 04	stx $0416			stx 	LastParameter 				; save the last parameters index.
.89c2	c8		iny				iny									; skip right bracket
.89c3	a9 b3		lda #$b3			lda 	#STK_PROC+3 				; allocate 6 bytes on the return stack.
.89c5	20 0f a6	jsr $a60f			jsr 	StackOpen
.89c8	20 54 a6	jsr $a654			jsr 	STKSaveCodePosition 		; save loop position
.89cb	a5 58		lda $58				lda 	NSMantissa0 				; copy variable (e.g. procedure) address to zTemp0
.89cd	85 36		sta $36				sta 	zTemp0 						; this is the DATA not the RECORD
.89cf	a5 60		lda $60				lda 	NSMantissa1
.89d1	85 37		sta $37				sta 	zTemp0+1
.89d3	a0 01		ldy #$01			ldy 	#1 							; copy code address back.
.89d5	b2 36		lda ($36)			lda 	(zTemp0)
.89d7	85 30		sta $30				sta 	safePtr
.89d9	b1 36		lda ($36),y			lda 	(zTemp0),y
.89db	85 31		sta $31				sta 	safePtr+1
.89dd	c8		iny				iny
.89de	b1 36		lda ($36),y			lda 	(zTemp0),y
.89e0	85 32		sta $32				sta 	safePtr+2
.89e2	c8		iny				iny
.89e3	b1 36		lda ($36),y			lda 	(zTemp0),y
.89e5	85 33		sta $33				sta 	safePtr+3
.89e7	c8		iny				iny 								; get Y offset -> Y
.89e8	b1 36		lda ($36),y			lda 	(zTemp0),y
.89ea	a8		tay				tay
.89eb	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start position of parameters
.89ed	ec 16 04	cpx $0416			cpx	 	LastParameter 				; check no parameters at the start
.89f0	f0 13		beq $8a05			beq 	_ParamExit 					; if so, exit.
.89f2					_ParamExtract:
.89f2	ca		dex				dex 								; put a local term on the level before
.89f3	20 e8 88	jsr $88e8			jsr 	LocaliseNextTerm			; also pushes original param value to basic stack
.89f6	20 c7 87	jsr $87c7			jsr 	AssignVariable 				; assign stacked value to the variable.
.89f9	e8		inx				inx 								; advance to next parameter to do.
.89fa	e8		inx				inx
.89fb	ec 16 04	cpx $0416			cpx 	LastParameter 				; are we done ?
.89fe	f0 05		beq $8a05			beq 	_ParamExit
.8a00	20 af 8e	jsr $8eaf			jsr 	CheckComma 					; comma seperating parameters
.8a03	80 ed		bra $89f2			bra 	_ParamExtract
.8a05					_ParamExit:
.8a05	20 a7 8e	jsr $8ea7			jsr 	CheckRightBracket 			; check )
.8a08	60		rts				rts 								; and continue from here
.8a09					Command_ENDPROC:
.8a09	a9 b0		lda #$b0			lda 	#STK_PROC 					; check TOS is this
.8a0b	a2 14		ldx #$14			ldx 	#ERRID_PROC
.8a0d	20 3c a6	jsr $a63c			jsr 	StackCheckFrame
.8a10	20 65 a6	jsr $a665			jsr 	STKLoadCodePosition 		; restore code position
.8a13	20 2e a6	jsr $a62e			jsr 	StackClose
.8a16	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/read.asm

.8a17					Command_Read:
.8a17	a2 00		ldx #$00			ldx 	#0 							; evaluate the term which is the var/array element to assign
.8a19	20 0e 98	jsr $980e			jsr 	EvaluateTerm
.8a1c	b5 50		lda $50,x			lda 	NSStatus,x
.8a1e	29 20		and #$20			and 	#NSBIsReference				; get status byte on stack, identifies int, float, string.
.8a20	f0 4f		beq $8a71			beq 	_CRSyntax 					; check reference (bit 0)
.8a22	20 ba 8a	jsr $8aba			jsr 	SwapDataCodePtrs 			; swap code and data
.8a25	ad 1c 04	lda $041c			lda 	inDataStatement 			; if in a data statement, we don't need to search
.8a28	d0 25		bne $8a4f			bne 	_CRContinueData
.8a2a	b2 30		lda ($30)			lda 	(codePtr)
.8a2c	f0 1c		beq $8a4a			beq 	_CRNoData
.8a2e					_CRKeepSearching:
.8a2e	a9 b2		lda #$b2			lda 	#KWD_DATA 					; scan for instruction
.8a30	a2 80		ldx #$80			ldx 	#KWC_EOL
.8a32	20 9f 8d	jsr $8d9f			jsr 	ScanForward
.8a35	c9 b2		cmp #$b2			cmp 	#KWD_DATA 					; found data ?
.8a37	f0 16		beq $8a4f			beq 	_CRHaveData 				; found it
.8a39	18		clc				clc
.8a3a	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8a3c	65 30		adc $30				adc 	codePtr
.8a3e	85 30		sta $30				sta 	codePtr
.8a40	90 02		bcc $8a44			bcc 	_CREExit
.8a42	e6 31		inc $31				inc 	codePtr+1 					; carry
.8a44					_CREExit:
.8a44	a0 03		ldy #$03			ldy 	#3 							; start of line.
.8a46	b2 30		lda ($30)			lda 	(codePtr)
.8a48	d0 e4		bne $8a2e			bne 	_CRKeepSearching
.8a4a					_CRNoData:
.8a4a	a9 0b		lda #$0b		lda	#11
.8a4c	4c c0 8e	jmp $8ec0		jmp	ErrorHandler
.8a4f					_CRHaveData:
.8a4f					_CRContinueData:
.8a4f	a2 01		ldx #$01			ldx 	#1
.8a51	20 12 9d	jsr $9d12			jsr 	EvaluateValue 				; evaluate value into slot # 1
.8a54	ca		dex				dex
.8a55	20 c7 87	jsr $87c7			jsr		AssignVariable 				; do the assignment
.8a58	9c 1c 04	stz $041c			stz 	inDataStatement 			; clear in data
.8a5b	b1 30		lda ($30),y			lda 	(codePtr),y
.8a5d	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not, end of data statement
.8a5f	d0 04		bne $8a65			bne 	_CRSwapBack
.8a61	c8		iny				iny 								; consume comma
.8a62	ee 1c 04	inc $041c			inc 	inDataStatement 			; set in data statement currently.
.8a65					_CRSwapBack:
.8a65	20 ba 8a	jsr $8aba			jsr 	SwapDataCodePtrs			; swap them back.
.8a68	b1 30		lda ($30),y			lda 	(codePtr),y
.8a6a	c8		iny				iny
.8a6b	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8a6d	f0 a8		beq $8a17			beq 	Command_Read 				; if so go round again.
.8a6f	88		dey				dey 								; unpick get.
.8a70	60		rts				rts
.8a71					_CRSyntax:
.8a71	4c 4b 9f	jmp $9f4b			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/rem.asm

.8a74					RemCommand:
.8a74	b1 30		lda ($30),y			lda 	(codePtr),y
.8a76	c9 ff		cmp #$ff			cmp 	#KWC_STRING
.8a78	d0 06		bne $8a80			bne 	_RMExit
.8a7a	c8		iny				iny 								; point to offset
.8a7b	98		tya				tya 								; A = offset position
.8a7c	38		sec				sec 								; add size +1 hence SEC
.8a7d	71 30		adc ($30),y			adc 	(codePtr),y
.8a7f	a8		tay				tay 								; make current position.
.8a80					_RMExit:
.8a80	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/repeat.asm

.8a81					Command_REPEAT:
.8a81	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; allocate 6 bytes on the return stack.
.8a83	20 0f a6	jsr $a60f			jsr 	StackOpen
.8a86	20 54 a6	jsr $a654			jsr 	STKSaveCodePosition 		; save loop position
.8a89	60		rts				rts
.8a8a					Command_UNTIL:
.8a8a	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; check REPEAT is TOS
.8a8c	a2 0f		ldx #$0f			ldx 	#ERRID_REPEAT 				; this error
.8a8e	20 3c a6	jsr $a63c			jsr 	StackCheckFrame
.8a91	a2 00		ldx #$00			ldx 	#0
.8a93	20 1b 9d	jsr $9d1b			jsr 	EvaluateNumber 				; work out the number
.8a96	20 ef 9d	jsr $9def			jsr 	NSMIsZero 					; check if zero
.8a99	f0 04		beq $8a9f			beq 	_CULoopBack 				; if so keep looping
.8a9b	20 2e a6	jsr $a62e			jsr 	StackClose		 			; return
.8a9e	60		rts				rts
.8a9f					_CULoopBack:
.8a9f	20 65 a6	jsr $a665			jsr 	STKLoadCodePosition 		; loop back
.8aa2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/restore.asm

.8aa3					Command_Restore:
.8aa3	20 ba 8a	jsr $8aba			jsr 	SwapDataCodePtrs 			; swap code and data
.8aa6	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8aa8	85 30		sta $30				sta 	codePtr
.8aaa	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8aac	85 31		sta $31				sta 	codePtr+1
.8aae	20 ba 8a	jsr $8aba			jsr 	SwapDataCodePtrs 			; put them back
.8ab1	a9 03		lda #$03			lda 	#3 							; start at offset 3, e.g. first instruction of first line.
.8ab3	8d 1b 04	sta $041b			sta 	dataPointer+4
.8ab6	9c 1c 04	stz $041c			stz 	inDataStatement 			; not in data statement
.8ab9	60		rts				rts
.8aba					SwapDataCodePtrs:
.8aba	da		phx				phx
.8abb	a2 03		ldx #$03			ldx 	#3 							; swap 32 bit code pointer over
.8abd					_SDCPLoop:
.8abd	b5 30		lda $30,x			lda 	safePtr,x
.8abf	48		pha				pha
.8ac0	bd 17 04	lda $0417,x			lda 	dataPointer,x
.8ac3	95 30		sta $30,x			sta 	safePtr,x
.8ac5	68		pla				pla
.8ac6	9d 17 04	sta $0417,x			sta 	dataPointer,x
.8ac9	ca		dex				dex
.8aca	10 f1		bpl $8abd			bpl 	_SDCPLoop
.8acc	ad 1b 04	lda $041b			lda 	dataPointer+4 				; swap Y position over.
.8acf	8c 1b 04	sty $041b			sty 	dataPointer+4
.8ad2	a8		tay				tay
.8ad3	fa		plx				plx
.8ad4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/run.asm

.8ad5					EOLCommand:
.8ad5	18		clc				clc
.8ad6	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8ad8	65 30		adc $30				adc 	codePtr
.8ada	85 30		sta $30				sta 	codePtr
.8adc	90 02		bcc $8ae0			bcc 	_CREExit
.8ade	e6 31		inc $31				inc 	codePtr+1 					; carry
.8ae0					_CREExit:
.8ae0	80 0b		bra $8aed			bra 	RunNewLine
.8ae2					CommandRUN:
.8ae2	20 0e 84	jsr $840e			jsr 	ClearCommand 				; clear variable/stacks/etc.
.8ae5	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8ae7	85 30		sta $30				sta 	codePtr
.8ae9	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8aeb	85 31		sta $31				sta 	codePtr+1
.8aed					RUNNewLine:
.8aed	b2 30		lda ($30)			lda 	(codePtr)
.8aef	f0 7b		beq $8b6c			beq 	CRNoProgram         		; no then END.
.8af1	a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack
.8af3	9a		txs				txs
.8af4					RUNCodePointerLine:
.8af4	a0 02		ldy #$02			ldy 	#2 							; start of program
.8af6					_CRIncMainLoop:
.8af6	0e 13 04	asl $0413			asl 	breakCheck 					; clears 1 time in 8
.8af9	d0 22		bne $8b1d			bne 	_CRNoBreakCheck
.8afb	ce 13 04	dec $0413			dec	 	breakCheck 					; set it back to $FF
.8afe	20 0c 80	jsr $800c			jsr 	EXTBreakCheck 				; break check
.8b01	f0 64		beq $8b67			beq 	_CRBreak
.8b03	a5 01		lda $01				lda 	1 							; save I/O 0
.8b05	48		pha				pha
.8b06	64 01		stz $01				stz 	1 							; access I/O Page 0
.8b08	38		sec				sec 								; calculate timer - LastTick
.8b09	ad 59 d6	lda $d659			lda 	$D659
.8b0c	aa		tax				tax 								; saving timer in X
.8b0d	ed af 05	sbc $05af			sbc 	LastTick
.8b10	c9 03		cmp #$03			cmp 	#3
.8b12	90 06		bcc $8b1a			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.8b14	8e af 05	stx $05af			stx 	LastTick 					; update last timer
.8b17	20 f8 9d	jsr $9df8			jsr 	TickHandler 							; go do the code.
.8b1a					_NoFireTick:
.8b1a	68		pla				pla 								; restore I/O 0
.8b1b	85 01		sta $01				sta 	1
.8b1d					_CRNoBreakCheck:
.8b1d	c8		iny				iny									; next token
.8b1e					_CRMainLoop:
.8b1e	9c 10 04	stz $0410			stz 	stringInitialised 			; clear the temporary string initialised flag.
.8b21	b1 30		lda ($30),y			lda 	(codePtr),y
.8b23	10 10		bpl $8b35			bpl 	_CRNotKeyword				; not a token.
.8b25	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1 			; if after unary, legitimate command
.8b27	b0 04		bcs $8b2d			bcs 	_CRIsKeyword
.8b29	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if unary, syntax error.
.8b2b	b0 34		bcs $8b61			bcs		_CRSyntaxError
.8b2d					_CRIsKeyword:
.8b2d	c8		iny				iny 								; consume command
.8b2e	0a		asl a				asl 	a 							; double losing the MSB which is '1' as tokens are $80-$FF
.8b2f	aa		tax				tax 								; put in X for vector jump
.8b30	20 64 8b	jsr $8b64			jsr 	_CRCallVector0 				; call the vector - effectively jsr (vectortable,X)
.8b33	80 e9		bra $8b1e			bra 	_CRMainLoop 				; and loop round
.8b35					_CRNotKeyword:
.8b35	c9 3a		cmp #$3a			cmp 	#KWD_COLON 					; if a :, consume it and go round.
.8b37	f0 bd		beq $8af6			beq 	_CRIncMainLoop
.8b39	c9 40		cmp #$40			cmp 	#$40 						; variable/call reference
.8b3b	90 05		bcc $8b42			bcc 	_CRNotVariable
.8b3d					_CRGoLet:
.8b3d	20 8e 87	jsr $878e			jsr 	LetCommand
.8b40	80 dc		bra $8b1e			bra 	_CRMainLoop
.8b42					_CRNotVariable:
.8b42	c9 10		cmp #$10			cmp 	#KWD_AT 					; handle @
.8b44	f0 f7		beq $8b3d			beq 	_CRGoLet
.8b46	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; handle ? !
.8b48	f0 f3		beq $8b3d			beq 	_CRGoLet
.8b4a	c9 21		cmp #$21			cmp 	#KWD_PLING
.8b4c	f0 ef		beq $8b3d			beq 	_CRGoLet
.8b4e	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; handle ' (comment)
.8b50	f0 09		beq $8b5b			beq 	_CRGoRem
.8b52	c9 2e		cmp #$2e			cmp 	#KWD_PERIOD 				; handle . (assembler label)
.8b54	d0 0b		bne $8b61			bne 	_CRSyntaxError
.8b56	20 11 82	jsr $8211			jsr 	LabelHere
.8b59	80 c3		bra $8b1e			bra 	_CRMainLoop
.8b5b					_CRGoRem:
.8b5b	c8		iny				iny
.8b5c	20 74 8a	jsr $8a74			jsr 	RemCommand
.8b5f	80 bd		bra $8b1e			bra 	_CRMainLoop
.8b61					_CRSyntaxError:
.8b61	4c 4b 9f	jmp $9f4b			jmp 	SyntaxError
.8b64					_CRCallVector0:
.8b64	7c 02 8c	jmp ($8c02,x)			jmp 	(VectorSet0,x)
.8b67					_CRBreak:
.8b67	a9 01		lda #$01		lda	#1
.8b69	4c c0 8e	jmp $8ec0		jmp	ErrorHandler
.8b6c					CRNoProgram:
.8b6c	4c 33 85	jmp $8533			jmp 	EndCommand
.8b6f					Shift1Command:
.8b6f	b1 30		lda ($30),y			lda 	(codePtr),y
.8b71	c8		iny				iny
.8b72	0a		asl a				asl 	a
.8b73	aa		tax				tax
.8b74	7c a0 8c	jmp ($8ca0,x)			jmp 	(VectorSet1,x)
.8b77					Shift2Command:
.8b77	b1 30		lda ($30),y			lda 	(codePtr),y
.8b79	c8		iny				iny
.8b7a	0a		asl a				asl 	a
.8b7b	aa		tax				tax
.8b7c	7c c0 8c	jmp ($8cc0,x)			jmp 	(VectorSet2,x)
.8b7f					Unused1:
.8b7f					Unused2:
.8b7f					Unused3:
.8b7f					Unused4:
.8b7f	4c 4b 9f	jmp $9f4b			jmp 	SyntaxError
>8b82							.align 2

;******  Processing file: ./common/commands/../generated/vectors.dat

.8b82					VectorSetPunc:
>8b82	78 91					.word	ShiftLeft                        ; $00 <<
>8b84	63 8f					.word	BinaryCompareLessEqual           ; $01 <=
>8b86	59 8f					.word	BinaryCompareNotEqual            ; $02 <>
>8b88	4b 9f					.word	SyntaxError                      ; $03 !!3
>8b8a	4b 9f					.word	SyntaxError                      ; $04 ><
>8b8c	6d 8f					.word	BinaryCompareGreaterEqual        ; $05 >=
>8b8e	7b 91					.word	ShiftRight                       ; $06 >>
>8b90	4b 9f					.word	SyntaxError                      ; $07 !!7
>8b92	4b 9f					.word	SyntaxError                      ; $08 !!8
>8b94	4b 9f					.word	SyntaxError                      ; $09 !!9
>8b96	4b 9f					.word	SyntaxError                      ; $0a !!10
>8b98	4b 9f					.word	SyntaxError                      ; $0b !!11
>8b9a	4b 9f					.word	SyntaxError                      ; $0c !!12
>8b9c	4b 9f					.word	SyntaxError                      ; $0d !!13
>8b9e	4b 9f					.word	SyntaxError                      ; $0e !!14
>8ba0	4b 9f					.word	SyntaxError                      ; $0f !!15
>8ba2	4b 9f					.word	SyntaxError                      ; $10 @
>8ba4	4b 9f					.word	SyntaxError                      ; $11 !!17
>8ba6	4b 9f					.word	SyntaxError                      ; $12 !!18
>8ba8	4b 9f					.word	SyntaxError                      ; $13 [
>8baa	24 90					.word	IntegerDivide                    ; $14 \
>8bac	4b 9f					.word	SyntaxError                      ; $15 ]
>8bae	b6 92					.word	EorInteger                       ; $16 ^
>8bb0	4b 9f					.word	SyntaxError                      ; $17 _
>8bb2	4b 9f					.word	SyntaxError                      ; $18 `
>8bb4	4b 9f					.word	SyntaxError                      ; $19 !!25
>8bb6	4b 9f					.word	SyntaxError                      ; $1a !!26
>8bb8	4b 9f					.word	SyntaxError                      ; $1b {
>8bba	81 92					.word	OraInteger                       ; $1c |
>8bbc	4b 9f					.word	SyntaxError                      ; $1d }
>8bbe	4b 9f					.word	SyntaxError                      ; $1e ~
>8bc0	4b 9f					.word	SyntaxError                      ; $1f [7m<7F>[m
>8bc2	4b 9f					.word	SyntaxError                      ; $20
>8bc4	eb 92					.word	WordIndirect                     ; $21 !
>8bc6	4b 9f					.word	SyntaxError                      ; $22 "
>8bc8	4b 9f					.word	SyntaxError                      ; $23 #
>8bca	4b 9f					.word	SyntaxError                      ; $24 $
>8bcc	65 90					.word	IntegerModulus                   ; $25 %
>8bce	4c 92					.word	AndInteger                       ; $26 &
>8bd0	4b 9f					.word	SyntaxError                      ; $27 '
>8bd2	4b 9f					.word	SyntaxError                      ; $28 (
>8bd4	4b 9f					.word	SyntaxError                      ; $29 )
>8bd6	d3 90					.word	MulInteger                       ; $2a *
>8bd8	ee 91					.word	AddInteger                       ; $2b +
>8bda	4b 9f					.word	SyntaxError                      ; $2c ,
>8bdc	27 92					.word	SubInteger                       ; $2d -
>8bde	4b 9f					.word	SyntaxError                      ; $2e .
>8be0	a5 94					.word	FDivideCommand                   ; $2f /
>8be2	4b 9f					.word	SyntaxError                      ; $30 0
>8be4	4b 9f					.word	SyntaxError                      ; $31 1
>8be6	4b 9f					.word	SyntaxError                      ; $32 2
>8be8	4b 9f					.word	SyntaxError                      ; $33 3
>8bea	4b 9f					.word	SyntaxError                      ; $34 4
>8bec	4b 9f					.word	SyntaxError                      ; $35 5
>8bee	4b 9f					.word	SyntaxError                      ; $36 6
>8bf0	4b 9f					.word	SyntaxError                      ; $37 7
>8bf2	4b 9f					.word	SyntaxError                      ; $38 8
>8bf4	4b 9f					.word	SyntaxError                      ; $39 9
>8bf6	4b 9f					.word	SyntaxError                      ; $3a :
>8bf8	4b 9f					.word	SyntaxError                      ; $3b ;
>8bfa	45 8f					.word	BinaryCompareLess                ; $3c <
>8bfc	3b 8f					.word	BinaryCompareEqual               ; $3d =
>8bfe	4f 8f					.word	BinaryCompareGreater             ; $3e >
>8c00	0d 93					.word	ByteIndirect                     ; $3f ?
.8c02					VectorSet0:
>8c02	d5 8a					.word	EOLCommand                       ; $80 !0:EOF
>8c04	6f 8b					.word	Shift1Command                    ; $81 !1:SH1
>8c06	77 8b					.word	Shift2Command                    ; $82 !2:SH2
>8c08	8a 99					.word	AbsUnary                         ; $83 ABS(
>8c0a	98 99					.word	AllocUnary                       ; $84 ALLOC(
>8c0c	08 9a					.word	AscUnary                         ; $85 ASC(
>8c0e	b3 9b					.word	ChrUnary                         ; $86 CHR$(
>8c10	9b a3					.word	UnaryEvent                       ; $87 EVENT(
>8c12	37 8f					.word	UnaryFalse                       ; $88 FALSE
>8c14	15 9a					.word	FracUnary                        ; $89 FRAC(
>8c16	37 a3					.word	UnaryHit                         ; $8a HIT(
>8c18	2a 9a					.word	IntUnary                         ; $8b INT(
>8c1a	72 9b					.word	IsValUnary                       ; $8c ISVAL(
>8c1c	1f a4					.word	UnaryJoyB                        ; $8d JOYB(
>8c1e	f8 a3					.word	UnaryJoyX                        ; $8e JOYX(
>8c20	fb a3					.word	UnaryJoyY                        ; $8f JOYY(
>8c22	86 9c					.word	Unary_Left                       ; $90 LEFT$(
>8c24	3b 9a					.word	LenUnary                         ; $91 LEN(
>8c26	59 9a					.word	Unary_Max                        ; $92 MAX(
>8c28	a8 9c					.word	Unary_Mid                        ; $93 MID$(
>8c2a	55 9a					.word	Unary_Min                        ; $94 MIN(
>8c2c	a4 9a					.word	Unary_Not                        ; $95 NOT(
>8c2e	6c a5					.word	UnaryPlaying                     ; $96 PLAYING(
>8c30	b7 9a					.word	Unary_Random                     ; $97 RANDOM(
>8c32	93 9c					.word	Unary_Right                      ; $98 RIGHT$(
>8c34	d4 9a					.word	Unary_Rnd                        ; $99 RND(
>8c36	4a 9b					.word	SgnUnary                         ; $9a SGN(
>8c38	c5 9b					.word	SpcUnary                         ; $9b SPC(
>8c3a	e0 9b					.word	Unary_Str                        ; $9c STR$(
>8c3c	45 a4					.word	UnaryTimer                       ; $9d TIMER(
>8c3e	2c 8f					.word	UnaryTrue                        ; $9e TRUE
>8c40	68 9b					.word	ValUnary                         ; $9f VAL(
>8c42	36 85					.word	ForCommand                       ; $a0 FOR
>8c44	79 86					.word	IfCommand                        ; $a1 IF
>8c46	7f 8b					.word	Unused1                          ; $a2 PROC
>8c48	81 8a					.word	Command_REPEAT                   ; $a3 REPEAT
>8c4a	15 8e					.word	Command_WHILE                    ; $a4 WHILE
>8c4c	a2 86					.word	EndIf                            ; $a5 ENDIF
>8c4e	09 8a					.word	Command_ENDPROC                  ; $a6 ENDPROC
>8c50	e8 85					.word	NextCommand                      ; $a7 NEXT
>8c52	7f 8b					.word	Unused4                          ; $a8 THEN
>8c54	8a 8a					.word	Command_UNTIL                    ; $a9 UNTIL
>8c56	36 8e					.word	Command_WEND                     ; $aa WEND
>8c58	4b 9f					.word	SyntaxError                      ; $ab BY
>8c5a	d9 83					.word	CallCommand                      ; $ac CALL
>8c5c	eb a0					.word	CircleCommand                    ; $ad CIRCLE
>8c5e	0e 84					.word	ClearCommand                     ; $ae CLEAR
>8c60	66 84					.word	ClearScreen                      ; $af CLS
>8c62	4b 9f					.word	SyntaxError                      ; $b0 COLOR
>8c64	4b 9f					.word	SyntaxError                      ; $b1 COLOUR
>8c66	6e 84					.word	Command_Data                     ; $b2 DATA
>8c68	76 84					.word	DimCommand                       ; $b3 DIM
>8c6a	7f 8b					.word	Unused3                          ; $b4 DOWNTO
>8c6c	9b 86					.word	ElseCode                         ; $b5 ELSE
>8c6e	4b 9f					.word	SyntaxError                      ; $b6 FROM
>8c70	0a a3					.word	GfxCommand                       ; $b7 GFX
>8c72	41 86					.word	Command_GOSUB                    ; $b8 GOSUB
>8c74	5f 86					.word	GotoCommand                      ; $b9 GOTO
>8c76	4b 9f					.word	SyntaxError                      ; $ba HERE
>8c78	14 a1					.word	ImageCommand                     ; $bb IMAGE
>8c7a	a3 86					.word	Command_Input                    ; $bc INPUT
>8c7c	8e 87					.word	LetCommand                       ; $bd LET
>8c7e	66 a1					.word	LineCommand                      ; $be LINE
>8c80	da 88					.word	Command_LOCAL                    ; $bf LOCAL
>8c82	4b 9f					.word	SyntaxError                      ; $c0 OFF
>8c84	4b 9f					.word	SyntaxError                      ; $c1 ON
>8c86	4b 9f					.word	SyntaxError                      ; $c2 OUTLINE
>8c88	5b a3					.word	PaletteCommand                   ; $c3 PALETTE
>8c8a	5f a1					.word	PlotCommand                      ; $c4 PLOT
>8c8c	aa 86					.word	Command_Print                    ; $c5 PRINT
>8c8e	17 8a					.word	Command_Read                     ; $c6 READ
>8c90	e7 a0					.word	RectangleCommand                 ; $c7 RECT
>8c92	74 8a					.word	RemCommand                       ; $c8 REM
>8c94	51 86					.word	Command_RETURN                   ; $c9 RETURN
>8c96	4b 9f					.word	SyntaxError                      ; $ca SOLID
>8c98	88 a5					.word	SoundCommand                     ; $cb SOUND
>8c9a	f6 a0					.word	SpriteCommand                    ; $cc SPRITE
>8c9c	30 a1					.word	TextCommand                      ; $cd TEXT
>8c9e	7f 8b					.word	Unused2                          ; $ce TO
.8ca0					VectorSet1:
>8ca0	4b 9f					.word	SyntaxError                      ; $80 !0:EOF
>8ca2	4b 9f					.word	SyntaxError                      ; $81 !1:SH1
>8ca4	4b 9f					.word	SyntaxError                      ; $82 !2:SH2
>8ca6	ad 83					.word	AssembleCommand                  ; $83 ASSEMBLE
>8ca8	c9 83					.word	AssertCommand                    ; $84 ASSERT
>8caa	aa a2					.word	BitmapCtrl                       ; $85 BITMAP
>8cac	33 85					.word	EndCommand                       ; $86 END
>8cae	3c a4					.word	GoCommand                        ; $87 GO
>8cb0	de 87					.word	Command_List                     ; $88 LIST
>8cb2	33 a4					.word	LoadCommand                      ; $89 LOAD
>8cb4	9b 89					.word	NewCommand                       ; $8a NEW
>8cb6	a3 8a					.word	Command_Restore                  ; $8b RESTORE
>8cb8	e2 8a					.word	CommandRUN                       ; $8c RUN
>8cba	ef a2					.word	SpritesCtrl                      ; $8d SPRITES
>8cbc	48 8d					.word	StopCommand                      ; $8e STOP
>8cbe	44 8e					.word	WhoCommand                       ; $8f WHO
.8cc0					VectorSet2:
>8cc0	4b 9f					.word	SyntaxError                      ; $80 !0:EOF
>8cc2	4b 9f					.word	SyntaxError                      ; $81 !1:SH1
>8cc4	4b 9f					.word	SyntaxError                      ; $82 !2:SH2
>8cc6	0a 9e					.word	Assemble_adc                     ; $83 ADC
>8cc8	02 9e					.word	Assemble_and                     ; $84 AND
>8cca	1e 9e					.word	Assemble_asl                     ; $85 ASL
>8ccc	88 9e					.word	Assemble_bcc                     ; $86 BCC
>8cce	8c 9e					.word	Assemble_bcs                     ; $87 BCS
>8cd0	94 9e					.word	Assemble_beq                     ; $88 BEQ
>8cd2	4b 9e					.word	Assemble_bit                     ; $89 BIT
>8cd4	7c 9e					.word	Assemble_bmi                     ; $8a BMI
>8cd6	90 9e					.word	Assemble_bne                     ; $8b BNE
>8cd8	78 9e					.word	Assemble_bpl                     ; $8c BPL
>8cda	98 9e					.word	Assemble_bra                     ; $8d BRA
>8cdc	9c 9e					.word	Assemble_brk                     ; $8e BRK
>8cde	80 9e					.word	Assemble_bvc                     ; $8f BVC
>8ce0	84 9e					.word	Assemble_bvs                     ; $90 BVS
>8ce2	a4 9e					.word	Assemble_clc                     ; $91 CLC
>8ce4	f8 9e					.word	Assemble_cld                     ; $92 CLD
>8ce6	b8 9e					.word	Assemble_cli                     ; $93 CLI
>8ce8	e8 9e					.word	Assemble_clv                     ; $94 CLV
>8cea	16 9e					.word	Assemble_cmp                     ; $95 CMP
>8cec	5f 9e					.word	Assemble_cpx                     ; $96 CPX
>8cee	5a 9e					.word	Assemble_cpy                     ; $97 CPY
>8cf0	3c 9e					.word	Assemble_dec                     ; $98 DEC
>8cf2	f4 9e					.word	Assemble_dex                     ; $99 DEX
>8cf4	d0 9e					.word	Assemble_dey                     ; $9a DEY
>8cf6	06 9e					.word	Assemble_eor                     ; $9b EOR
>8cf8	41 9e					.word	Assemble_inc                     ; $9c INC
>8cfa	04 9f					.word	Assemble_inx                     ; $9d INX
>8cfc	f0 9e					.word	Assemble_iny                     ; $9e INY
>8cfe	73 9e					.word	Assemble_jmp                     ; $9f JMP
>8d00	6e 9e					.word	Assemble_jsr                     ; $a0 JSR
>8d02	12 9e					.word	Assemble_lda                     ; $a1 LDA
>8d04	37 9e					.word	Assemble_ldx                     ; $a2 LDX
>8d06	55 9e					.word	Assemble_ldy                     ; $a3 LDY
>8d08	28 9e					.word	Assemble_lsr                     ; $a4 LSR
>8d0a	08 9f					.word	Assemble_nop                     ; $a5 NOP
>8d0c	fe 9d					.word	Assemble_ora                     ; $a6 ORA
>8d0e	b4 9e					.word	Assemble_pha                     ; $a7 PHA
>8d10	a0 9e					.word	Assemble_php                     ; $a8 PHP
>8d12	fc 9e					.word	Assemble_phx                     ; $a9 PHX
>8d14	bc 9e					.word	Assemble_phy                     ; $aa PHY
>8d16	c4 9e					.word	Assemble_pla                     ; $ab PLA
>8d18	a8 9e					.word	Assemble_plp                     ; $ac PLP
>8d1a	10 9f					.word	Assemble_plx                     ; $ad PLX
>8d1c	cc 9e					.word	Assemble_ply                     ; $ae PLY
>8d1e	23 9e					.word	Assemble_rol                     ; $af ROL
>8d20	2d 9e					.word	Assemble_ror                     ; $b0 ROR
>8d22	b0 9e					.word	Assemble_rti                     ; $b1 RTI
>8d24	c0 9e					.word	Assemble_rts                     ; $b2 RTS
>8d26	1a 9e					.word	Assemble_sbc                     ; $b3 SBC
>8d28	ac 9e					.word	Assemble_sec                     ; $b4 SEC
>8d2a	0c 9f					.word	Assemble_sed                     ; $b5 SED
>8d2c	c8 9e					.word	Assemble_sei                     ; $b6 SEI
>8d2e	0e 9e					.word	Assemble_sta                     ; $b7 STA
>8d30	00 9f					.word	Assemble_stp                     ; $b8 STP
>8d32	32 9e					.word	Assemble_stx                     ; $b9 STX
>8d34	50 9e					.word	Assemble_sty                     ; $ba STY
>8d36	46 9e					.word	Assemble_stz                     ; $bb STZ
>8d38	e4 9e					.word	Assemble_tax                     ; $bc TAX
>8d3a	e0 9e					.word	Assemble_tay                     ; $bd TAY
>8d3c	69 9e					.word	Assemble_trb                     ; $be TRB
>8d3e	64 9e					.word	Assemble_tsb                     ; $bf TSB
>8d40	ec 9e					.word	Assemble_tsx                     ; $c0 TSX
>8d42	d4 9e					.word	Assemble_txa                     ; $c1 TXA
>8d44	dc 9e					.word	Assemble_txs                     ; $c2 TXS
>8d46	d8 9e					.word	Assemble_tya                     ; $c3 TYA

;******  Return to file: ./common/commands/run.asm


;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/stop.asm

.8d48					StopCommand:
.8d48	a9 08		lda #$08		lda	#8
.8d4a	4c c0 8e	jmp $8ec0		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/procscan.asm

.8d4d					ProcedureScan:
.8d4d	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8d4f	85 30		sta $30				sta 	codePtr
.8d51	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8d53	85 31		sta $31				sta 	codePtr+1
.8d55					_PSLoop:
.8d55	b2 30		lda ($30)			lda 	(codePtr)
.8d57	f0 42		beq $8d9b			beq 	_PSExit
.8d59	a0 03		ldy #$03			ldy 	#3 							; is it PROC ?
.8d5b	b1 30		lda ($30),y			lda 	(codePtr),y
.8d5d	c9 a2		cmp #$a2			cmp 	#KWD_PROC
.8d5f	d0 2d		bne $8d8e			bne 	_PSNext
.8d61	c8		iny				iny 								; get the address of the record to zTemp0 and
.8d62	b1 30		lda ($30),y			lda 	(codePtr),y
.8d64	29 c0		and #$c0			and 	#$C0
.8d66	c9 40		cmp #$40			cmp 	#$40
.8d68	d0 32		bne $8d9c			bne 	_PSSyntax
.8d6a	b1 30		lda ($30),y			lda 	(codePtr),y
.8d6c	18		clc				clc
.8d6d	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8d6f	85 37		sta $37				sta 	zTemp0+1
.8d71	c8		iny				iny 								; LSB
.8d72	b1 30		lda ($30),y			lda 	(codePtr),y
.8d74	85 36		sta $36				sta 	zTemp0
.8d76	c8		iny				iny 								; character after variable call.
.8d77	98		tya				tya 								; save Y offset at +7
.8d78	a0 07		ldy #$07			ldy 	#7
.8d7a	91 36		sta ($36),y			sta 	(zTemp0),y
.8d7c	a9 18		lda #$18			lda 	#NSTProcedure 				; mark it as procedure
.8d7e	a0 02		ldy #$02			ldy 	#2
.8d80	91 36		sta ($36),y			sta 	(zTemp0),y
.8d82	a2 00		ldx #$00			ldx 	#0 							; copy code-Ptr in
.8d84					_PSCopy:
.8d84	b5 30		lda $30,x			lda 	safePtr,x
.8d86	c8		iny				iny
.8d87	91 36		sta ($36),y			sta 	(zTemp0),y
.8d89	e8		inx				inx
.8d8a	e0 04		cpx #$04			cpx 	#4
.8d8c	d0 f6		bne $8d84			bne 	_PSCopy
.8d8e					_PSNext:
.8d8e	18		clc				clc
.8d8f	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8d91	65 30		adc $30				adc 	codePtr
.8d93	85 30		sta $30				sta 	codePtr
.8d95	90 02		bcc $8d99			bcc 	_CREExit
.8d97	e6 31		inc $31				inc 	codePtr+1 					; carry
.8d99					_CREExit:
.8d99	80 ba		bra $8d55			bra 	_PSLoop
.8d9b					_PSExit:
.8d9b	60		rts				rts
.8d9c					_PSSyntax:
.8d9c	4c 4b 9f	jmp $9f4b			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/scanforward.asm

.8d9f					ScanForward:
.8d9f	64 38		stz $38				stz 	zTemp1 						; this is the structure count - goes up with WHILE/FOR
.8da1	86 37		stx $37				stx 	zTemp0+1
.8da3	85 36		sta $36				sta 	zTemp0 						; save XA as the two possible matches.
.8da5					_ScanLoop:
.8da5	b1 30		lda ($30),y			lda 	(codePtr),y
.8da7	c8		iny				iny
.8da8	a6 38		ldx $38				ldx 	zTemp1 						; if the count is > 0 cannot match as in substructure
.8daa	d0 0e		bne $8dba			bne 	_ScanGoNext
.8dac	c5 36		cmp $36				cmp 	zTemp0 						; see if either matches
.8dae	f0 04		beq $8db4			beq 	_ScanMatch
.8db0	c5 37		cmp $37				cmp 	zTemp0+1
.8db2	d0 06		bne $8dba			bne 	_ScanGoNext
.8db4					_ScanMatch:
.8db4	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if asked for EOL, backtrack.
.8db6	d0 01		bne $8db9			bne 	_ScanNotEndEOL
.8db8	88		dey				dey
.8db9					_ScanNotEndEOL:
.8db9	60		rts				rts
.8dba					_ScanGoNext:
.8dba	20 bf 8d	jsr $8dbf			jsr  	ScanForwardOne
.8dbd	80 e6		bra $8da5			bra 	_ScanLoop
.8dbf					ScanForwardOne:
.8dbf	c9 40		cmp #$40			cmp 	#$40 						; if 00-3F, punctuation characters, loop back
.8dc1	90 3e		bcc $8e01			bcc 	_SFWExit
.8dc3	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if 40-82, skip one extra.
.8dc5	90 18		bcc $8ddf			bcc 	_ScanSkipOne
.8dc7	c9 fc		cmp #$fc			cmp 	#$FC 						; FC-FF are data skips
.8dc9	b0 2f		bcs $8dfa			bcs 	_ScanSkipData
.8dcb	c9 a0		cmp #$a0			cmp 	#KWC_FIRST_STRUCTURE 		; structure keyword ?
.8dcd	90 32		bcc $8e01			bcc 	_SFWExit 					; if not, ordinary keywords.
.8dcf	c9 ab		cmp #$ab			cmp 	#KWC_LAST_STRUCTURE+1
.8dd1	b0 2e		bcs $8e01			bcs 	_SFWExit
.8dd3	c6 38		dec $38				dec 	zTemp1 						; decrement the sructure count
.8dd5	c9 a5		cmp #$a5			cmp 	#KWC_FIRST_STRUCTURE_DEC 	; back if it is a dec structure (e.g. WEND/NEXT)
.8dd7	b0 28		bcs $8e01			bcs 	_SFWExit
.8dd9	e6 38		inc $38				inc 	zTemp1 						; so it's an increment structure
.8ddb	e6 38		inc $38				inc 	zTemp1 						; twice to undo the dec
.8ddd	80 22		bra $8e01			bra 	_SFWExit
.8ddf					_ScanSkipOne:
.8ddf	c8		iny				iny 								; consume the extra one.
.8de0	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if not EOL loop back
.8de2	d0 1d		bne $8e01			bne 	_SFWExit
.8de4	18		clc				clc
.8de5	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8de7	65 30		adc $30				adc 	codePtr
.8de9	85 30		sta $30				sta 	codePtr
.8deb	90 02		bcc $8def			bcc 	_CREExit
.8ded	e6 31		inc $31				inc 	codePtr+1 					; carry
.8def					_CREExit:
.8def	a0 03		ldy #$03			ldy 	#3 							; scan start position.
.8df1	b2 30		lda ($30)			lda 	(codePtr)
.8df3	d0 0c		bne $8e01			bne 	_SFWExit 					; if not zero, more to scan
.8df5	a9 13		lda #$13		lda	#19
.8df7	4c c0 8e	jmp $8ec0		jmp	ErrorHandler
.8dfa					_ScanSkipData:
.8dfa	88		dey				dey 								; point at data token
.8dfb	c8		iny				iny 								; point to offset
.8dfc	98		tya				tya 								; A = offset position
.8dfd	38		sec				sec 								; add size +1 hence SEC
.8dfe	71 30		adc ($30),y			adc 	(codePtr),y
.8e00	a8		tay				tay 								; make current position.
.8e01					_SFWExit:
.8e01	60		rts				rts
.8e02					ScanGetCurrentLineStep:
.8e02	64 38		stz $38				stz 	zTemp1
.8e04	a0 03		ldy #$03			ldy 	#3
.8e06					_SGCLSLoop:
.8e06	b1 30		lda ($30),y			lda 	(codePtr),y
.8e08	c8		iny				iny
.8e09	c9 80		cmp #$80			cmp 	#KWC_EOL	 				; if EOL exit
.8e0b	f0 05		beq $8e12			beq 	_SGCLSExit
.8e0d	20 bf 8d	jsr $8dbf			jsr 	ScanForwardOne
.8e10	80 f4		bra $8e06			bra 	_SGCLSLoop
.8e12					_SGCLSExit:
.8e12	a5 38		lda $38				lda 	zTemp1
.8e14	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/while.asm

.8e15					Command_WHILE:
.8e15	5a		phy				phy 								; save position of the test
.8e16	a2 00		ldx #$00			ldx 	#0
.8e18	20 1b 9d	jsr $9d1b			jsr 	EvaluateNumber 				; work out the number
.8e1b	20 ef 9d	jsr $9def			jsr 	NSMIsZero 					; check if zero
.8e1e	f0 0e		beq $8e2e			beq 	_WHExitLoop 				; if so exit the loop
.8e20	98		tya				tya 								; position *after* test.
.8e21	7a		ply				ply 								; restore position before test, at WHILE
.8e22	88		dey				dey
.8e23	48		pha				pha 								; push after test on the stack
.8e24	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; allocate 6 bytes on the return stack.
.8e26	20 0f a6	jsr $a60f			jsr 	StackOpen
.8e29	20 54 a6	jsr $a654			jsr 	STKSaveCodePosition 		; save loop position - where the test value is.
.8e2c	7a		ply				ply 								; restore the position *after* the test
.8e2d	60		rts				rts
.8e2e					_WHExitLoop:
.8e2e	68		pla				pla 								; throw post loop position
.8e2f	a9 aa		lda #$aa			lda 	#KWD_WEND 					; scan forward past WEND
.8e31	aa		tax				tax
.8e32	20 9f 8d	jsr $8d9f			jsr 	ScanForward
.8e35	60		rts				rts
.8e36					Command_WEND:
.8e36	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; check WHILE is TOS
.8e38	a2 10		ldx #$10			ldx 	#ERRID_WHILE 				; this error
.8e3a	20 3c a6	jsr $a63c			jsr 	StackCheckFrame
.8e3d	20 65 a6	jsr $a665			jsr 	STKLoadCodePosition 		; loop back
.8e40	20 2e a6	jsr $a62e			jsr 	StackClose		 			; erase the frame
.8e43	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/who.asm

.8e44					WhoCommand:
.8e44	a2 8e		ldx #$8e			ldx 	#(_WHOMessage >> 8)
.8e46	a9 4c		lda #$4c			lda 	#(_WHOMessage & $FF)
.8e48	20 19 8f	jsr $8f19			jsr 	PrintStringXA
.8e4b	60		rts				rts
.8e4c					_WHOMessage:
>8e4c	81						.byte 	$81
>8e4d	42 72 6f 75 67 68 74 20				.text 	"Brought to you by :",13,13
>8e55	74 6f 20 79 6f 75 20 62 79 20 3a 0d 0d
>8e62	09 53 74 65 66 61 6e 79				.text 	9,"Stefany Allaire",13
>8e6a	20 41 6c 6c 61 69 72 65 0d
>8e73	09 4a 65 73 73 69 65 20				.text 	9,"Jessie Oberreuter",13
>8e7b	4f 62 65 72 72 65 75 74 65 72 0d
>8e86	09 50 61 75 6c 20 52 6f				.text 	9,"Paul Robson",13
>8e8e	62 73 6f 6e 0d
>8e93	09 50 65 74 65 72 20 57				.text 	9,"Peter Weingartner",13
>8e9b	65 69 6e 67 61 72 74 6e 65 72 0d
>8ea6	00						.byte 	0

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/charcheck.asm

.8ea7					CheckRightBracket:
.8ea7	b1 30		lda ($30),y			lda 	(codePtr),y
.8ea9	c8		iny				iny
.8eaa	c9 29		cmp #$29			cmp 	#KWD_RPAREN 						; exit if matches
.8eac	d0 0f		bne $8ebd			bne 	CNAFail
.8eae	60		rts				rts
.8eaf					CheckComma:
.8eaf	b1 30		lda ($30),y			lda 	(codePtr),y
.8eb1	c8		iny				iny
.8eb2	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 						; exit if matches
.8eb4	d0 07		bne $8ebd			bne 	CNAFail
.8eb6	60		rts				rts
.8eb7					CheckNextA:
.8eb7	d1 30		cmp ($30),y			cmp 	(codePtr),y
.8eb9	d0 02		bne $8ebd			bne 	CNAFail
.8ebb	c8		iny				iny 								; skip character
.8ebc	60		rts				rts 								; and exit
.8ebd					CNAFail:
.8ebd	4c 4b 9f	jmp $9f4b			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/errors.asm

.8ec0					ErrorHandler:
.8ec0	a8		tay				tay 								; find the error text
.8ec1	f0 49		beq $8f0c			beq 	_EHEnd
.8ec3	a2 00		ldx #$00			ldx 	#0
.8ec5	a9 64		lda #$64			lda 	#((ErrorText) & $FF)
.8ec7	85 36		sta $36				sta 	0+zTemp0
.8ec9	a9 9f		lda #$9f			lda 	#((ErrorText) >> 8)
.8ecb	85 37		sta $37				sta 	1+zTemp0
.8ecd					_EHFind:
.8ecd	88		dey				dey 								; keep looking through text
.8ece	f0 0e		beq $8ede			beq 	_EHFound
.8ed0					_EHFindZero:
.8ed0	b2 36		lda ($36)			lda 	(zTemp0) 					; find the next error
.8ed2	e6 36		inc $36				inc 	zTemp0
.8ed4	d0 02		bne $8ed8			bne 	_EHFNoCarry
.8ed6	e6 37		inc $37				inc 	zTemp0+1
.8ed8					_EHFNoCarry:
.8ed8	c9 00		cmp #$00			cmp 	#0
.8eda	d0 f4		bne $8ed0			bne 	_EHFindZero
.8edc	80 ef		bra $8ecd			bra 	_EHFind
.8ede					_EHFound:
.8ede	a5 36		lda $36				lda 	zTemp0 						; print message
.8ee0	a6 37		ldx $37				ldx 	zTemp0+1
.8ee2	20 19 8f	jsr $8f19			jsr 	PrintStringXA
.8ee5	a0 01		ldy #$01			ldy 	#1 							; if line number zero don't print it
.8ee7	b1 30		lda ($30),y			lda 	(codePtr),y
.8ee9	d0 05		bne $8ef0			bne 	_EHAtMsg
.8eeb	c8		iny				iny
.8eec	b1 30		lda ($30),y			lda 	(codePtr),y
.8eee	f0 17		beq $8f07			beq 	_EHCREnd
.8ef0					_EHAtMsg:
.8ef0	a2 8f		ldx #$8f			ldx 	#_AtMsg >> 8 				; print " at "
.8ef2	a9 0f		lda #$0f			lda 	#_AtMsg & $FF
.8ef4	20 19 8f	jsr $8f19			jsr 	PrintStringXA
.8ef7	a0 01		ldy #$01			ldy 	#1 							; line number into XA
.8ef9	b1 30		lda ($30),y			lda 	(codePtr),y
.8efb	48		pha				pha
.8efc	c8		iny				iny
.8efd	b1 30		lda ($30),y			lda 	(codePtr),y
.8eff	aa		tax				tax
.8f00	68		pla				pla
.8f01	20 2f 93	jsr $932f			jsr 	ConvertInt16 				; convert XA to string
.8f04	20 19 8f	jsr $8f19			jsr 	PrintStringXA 				; and print it.
.8f07					_EHCREnd:
.8f07	a9 0d		lda #$0d			lda 	#13 						; new line
.8f09	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8f0c					_EHEnd:
.8f0c	4c 78 83	jmp $8378			jmp 	WarmStart
>8f0f	20 61 74 20 6c 69 6e 65		_AtMsg:	.text 	" at line ",0
>8f17	20 00
.8f19					PrintStringXA:
.8f19	5a		phy				phy
.8f1a	86 37		stx $37				stx 	zTemp0+1
.8f1c	85 36		sta $36				sta 	zTemp0
.8f1e	a0 00		ldy #$00			ldy 	#0
.8f20					_PSXALoop:
.8f20	b1 36		lda ($36),y			lda 	(zTemp0),y
.8f22	f0 06		beq $8f2a			beq 	_PSXAExit
.8f24	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8f27	c8		iny				iny
.8f28	80 f6		bra $8f20			bra 	_PSXALoop
.8f2a					_PSXAExit:
.8f2a	7a		ply				ply
.8f2b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/compare.asm

.8f2c					UnaryTrue:
.8f2c	fa		plx				plx
.8f2d					ReturnTrue:
.8f2d	a9 01		lda #$01			lda 	#1  						; set to 1
.8f2f	20 cf 9d	jsr $9dcf			jsr 	NSMSetByte
.8f32	a9 80		lda #$80			lda 	#$80 						; set sign flag, so it is -1
.8f34	95 50		sta $50,x			sta 	NSStatus,x
.8f36	60		rts				rts
.8f37					UnaryFalse:
.8f37	fa		plx				plx
.8f38					ReturnFalse:
.8f38	4c cd 9d	jmp $9dcd			jmp 	NSMSetZero 					; set it all to zero
.8f3b					BinaryCompareEqual:
.8f3b	fa		plx				plx
.8f3c	20 77 8f	jsr $8f77			jsr 	CompareBaseCode
.8f3f	c9 00		cmp #$00			cmp 	#0
.8f41	f0 ea		beq $8f2d			beq 	ReturnTrue
.8f43	80 f3		bra $8f38			bra 	ReturnFalse
.8f45					BinaryCompareLess:
.8f45	fa		plx				plx
.8f46	20 77 8f	jsr $8f77			jsr 	CompareBaseCode
.8f49	c9 ff		cmp #$ff			cmp 	#$FF
.8f4b	f0 e0		beq $8f2d			beq 	ReturnTrue
.8f4d	80 e9		bra $8f38			bra 	ReturnFalse
.8f4f					BinaryCompareGreater:
.8f4f	fa		plx				plx
.8f50	20 77 8f	jsr $8f77			jsr 	CompareBaseCode
.8f53	c9 01		cmp #$01			cmp 	#1
.8f55	f0 d6		beq $8f2d			beq 	ReturnTrue
.8f57	80 df		bra $8f38			bra 	ReturnFalse
.8f59					BinaryCompareNotEqual:
.8f59	fa		plx				plx
.8f5a	20 77 8f	jsr $8f77			jsr 	CompareBaseCode
.8f5d	c9 00		cmp #$00			cmp 	#0
.8f5f	d0 cc		bne $8f2d			bne 	ReturnTrue
.8f61	80 d5		bra $8f38			bra 	ReturnFalse
.8f63					BinaryCompareLessEqual:
.8f63	fa		plx				plx
.8f64	20 77 8f	jsr $8f77			jsr 	CompareBaseCode
.8f67	c9 01		cmp #$01			cmp 	#1
.8f69	d0 c2		bne $8f2d			bne 	ReturnTrue
.8f6b	80 cb		bra $8f38			bra 	ReturnFalse
.8f6d					BinaryCompareGreaterEqual:
.8f6d	fa		plx				plx
.8f6e	20 77 8f	jsr $8f77			jsr 	CompareBaseCode
.8f71	c9 ff		cmp #$ff			cmp 	#$FF
.8f73	d0 b8		bne $8f2d			bne 	ReturnTrue
.8f75	80 c1		bra $8f38			bra 	ReturnFalse
.8f77					CompareBaseCode:
.8f77	20 82 96	jsr $9682			jsr 	DereferenceTopTwo 			; make both values if references.
.8f7a	b5 50		lda $50,x			lda 	NSStatus,x 					; check if either is a string.
.8f7c	15 51		ora $51,x			ora 	NSStatus+1,x
.8f7e	29 10		and #$10			and 	#NSTString
.8f80	d0 37		bne $8fb9			bne 	_CBCString 					; if so do string code, which will check if both.
.8f82	b5 78		lda $78,x			lda 	NSExponent,x 				; check both are integers
.8f84	15 79		ora $79,x			ora 	NSExponent+1,x
.8f86	d0 34		bne $8fbc			bne 	_CBCFloat
.8f88	b5 50		lda $50,x			lda 	NSStatus,x
.8f8a	15 51		ora $51,x			ora 	NSStatus+1,x
.8f8c	29 08		and #$08			and 	#NSTFloat
.8f8e	d0 2c		bne $8fbc			bne 	_CBCFloat
.8f90	20 bf 8f	jsr $8fbf			jsr 	CompareFixMinusZero 		; fix up -0 just in cases.
.8f93	e8		inx				inx
.8f94	20 bf 8f	jsr $8fbf			jsr 	CompareFixMinusZero
.8f97	ca		dex				dex
.8f98	b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs different ?
.8f9a	55 51		eor $51,x			eor 	NSStatus+1,x
.8f9c	10 0a		bpl $8fa8			bpl 	_CDCSameSign
.8f9e	b5 50		lda $50,x			lda 	NSStatus,x 					; if first one is -ve
.8fa0	30 14		bmi $8fb6			bmi 	_CBCLess 					; return $FF
.8fa2					_CBCGreater:
.8fa2	a9 01		lda #$01			lda 	#1
.8fa4	60		rts				rts
.8fa5					_CBCEqual:
.8fa5	a9 00		lda #$00			lda 	#0
.8fa7	60		rts				rts
.8fa8					_CDCSameSign:
.8fa8	20 d4 91	jsr $91d4			jsr 	SubTopTwoStack 				; unsigned subtract
.8fab	20 ef 9d	jsr $9def			jsr 	NSMIsZero 					; or the mantissa together
.8fae	f0 f5		beq $8fa5			beq 	_CBCEqual 					; -0 == 0
.8fb0	b5 70		lda $70,x			lda 	NSMantissa3,x 				; sign of the result. if +ve return $01 else return $FF
.8fb2	55 51		eor $51,x			eor 	NSStatus+1,x 				; however if both were -ve this is inverted
.8fb4	10 ec		bpl $8fa2			bpl 	_CBCGreater
.8fb6					_CBCLess:
.8fb6	a9 ff		lda #$ff			lda 	#$FF
.8fb8	60		rts				rts
.8fb9					_CBCString:
.8fb9	4c 45 91	jmp $9145			jmp 	CompareStrings
.8fbc					_CBCFloat:
.8fbc	4c 8f 94	jmp $948f			jmp 	CompareFloat
.8fbf					CompareFixMinusZero:
.8fbf	20 ef 9d	jsr $9def			jsr 	NSMIsZero
.8fc2	d0 02		bne $8fc6			bne 	_CFXMZNotZero
.8fc4	74 50		stz $50,x			stz 	NSStatus,x
.8fc6					_CFXMZNotZero:
.8fc6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/concat.asm

.8fc7					StringConcat:
.8fc7	b5 50		lda $50,x			lda 	NSStatus,x 					; check both strings
.8fc9	35 51		and $51,x			and 	NSStatus+1,x
.8fcb	29 18		and #$18			and 	#NSBTypeMask
.8fcd	c9 10		cmp #$10			cmp 	#NSTString
.8fcf	d0 50		bne $9021			bne		_SCType
.8fd1	64 38		stz $38				stz 	zTemp1 						; counting total length
.8fd3	e8		inx				inx
.8fd4	20 f2 8f	jsr $8ff2			jsr 	_SCSetupZ0 					; setup for second
.8fd7	20 fb 8f	jsr $8ffb			jsr 	_SCLengthZ0 				; length for second
.8fda	ca		dex				dex
.8fdb	20 f2 8f	jsr $8ff2			jsr 	_SCSetupZ0 					; setup for first
.8fde	20 fb 8f	jsr $8ffb			jsr 	_SCLengthZ0 				; length for first
.8fe1	a5 38		lda $38				lda 	zTemp1 						; allocate memory using total.
.8fe3	20 ff a6	jsr $a6ff			jsr 	StringTempAllocate
.8fe6	20 12 90	jsr $9012			jsr 	_SCCopy 					; copy first out, using zTemp0 from above
.8fe9	e8		inx				inx
.8fea	20 f2 8f	jsr $8ff2			jsr 	_SCSetupZ0 					; copy second out
.8fed	20 12 90	jsr $9012			jsr 	_SCCopy
.8ff0	ca		dex				dex
.8ff1	60		rts				rts
.8ff2					_SCSetupZ0:
.8ff2	b5 58		lda $58,x			lda 	NSMantissa0,x
.8ff4	85 36		sta $36				sta 	zTemp0
.8ff6	b5 60		lda $60,x			lda 	NSMantissa1,x
.8ff8	85 37		sta $37				sta 	zTemp0+1
.8ffa	60		rts				rts
.8ffb					_SCLengthZ0:
.8ffb	5a		phy				phy
.8ffc	a0 00		ldy #$00			ldy 	#0
.8ffe					_SCLenLoop:
.8ffe	b1 36		lda ($36),y			lda 	(zTemp0),y
.9000	f0 0e		beq $9010			beq 	_SCLExit
.9002	c8		iny				iny
.9003	e6 38		inc $38				inc 	zTemp1
.9005	a5 38		lda $38				lda	 	zTemp1 						; check string too long.
.9007	c9 fd		cmp #$fd			cmp 	#253
.9009	d0 f3		bne $8ffe			bne		_SCLenLoop
.900b	a9 09		lda #$09		lda	#9
.900d	4c c0 8e	jmp $8ec0		jmp	ErrorHandler
.9010					_SCLExit:
.9010	7a		ply				ply
.9011	60		rts				rts
.9012					_SCCopy:
.9012	5a		phy				phy
.9013	a0 00		ldy #$00			ldy 	#0
.9015					_SCCopyLoop:
.9015	b1 36		lda ($36),y			lda 	(zTemp0),y
.9017	f0 06		beq $901f			beq 	_SCCExit
.9019	20 38 a7	jsr $a738			jsr 	StringTempWrite
.901c	c8		iny				iny
.901d	80 f6		bra $9015			bra 	_SCCopyLoop
.901f					_SCCExit:
.901f	7a		ply				ply
.9020	60		rts				rts
.9021					_SCType:
.9021	4c 55 9f	jmp $9f55			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/divide.asm

.9024					IntegerDivide:
.9024	fa		plx				plx
.9025	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9027	15 51		ora $51,x			ora 	NSStatus+1,x
.9029	0a		asl a				asl 	a 							; shift reference bit into sign bit
.902a	0a		asl a				asl 	a
.902b	10 05		bpl $9032			bpl 	_NotRef
.902d	48		pha				pha
.902e	20 82 96	jsr $9682			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9031	68		pla				pla
.9032					_NotRef:
.9032	0a		asl a				asl 	a
.9033	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9035	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9037	15 79		ora $79,x			ora 	NSExponent+1,x
.9039	f0 03		beq $903e			beq 	_IntegerCode 				; if clear, then we have two integers
.903b	4c 55 9f	jmp $9f55			jmp 	TypeError 					; anything else, type mismatch.
.903e					_IntegerCode:
.903e	20 58 90	jsr $9058			jsr 	CheckDivideZero 			; do div zero check
.9041	20 8a 90	jsr $908a			jsr 	Int32Divide 				; do the division
.9044	20 3b 91	jsr $913b			jsr 	CalculateSign 				; calculate result sign
.9047					NSMCopyPlusTwoToZero:
.9047	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.9049	95 58		sta $58,x			sta 	NSMantissa0,x
.904b	b5 62		lda $62,x			lda 	NSMantissa1+2,x
.904d	95 60		sta $60,x			sta 	NSMantissa1,x
.904f	b5 6a		lda $6a,x			lda 	NSMantissa2+2,x
.9051	95 68		sta $68,x			sta 	NSMantissa2,x
.9053	b5 72		lda $72,x			lda 	NSMantissa3+2,x
.9055	95 70		sta $70,x			sta 	NSMantissa3,x
.9057	60		rts				rts
.9058					CheckDivideZero:
.9058	e8		inx				inx
.9059	20 ef 9d	jsr $9def			jsr 	NSMIsZero
.905c	f0 02		beq $9060			beq 	_CDVError
.905e	ca		dex				dex
.905f	60		rts				rts
.9060					_CDVError:
.9060	a9 03		lda #$03		lda	#3
.9062	4c c0 8e	jmp $8ec0		jmp	ErrorHandler
.9065					IntegerModulus:
.9065	fa		plx				plx
.9066	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9068	15 51		ora $51,x			ora 	NSStatus+1,x
.906a	0a		asl a				asl 	a 							; shift reference bit into sign bit
.906b	0a		asl a				asl 	a
.906c	10 05		bpl $9073			bpl 	_NotRef
.906e	48		pha				pha
.906f	20 82 96	jsr $9682			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9072	68		pla				pla
.9073					_NotRef:
.9073	0a		asl a				asl 	a
.9074	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9076	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9078	15 79		ora $79,x			ora 	NSExponent+1,x
.907a	f0 03		beq $907f			beq 	_IntegerCode 				; if clear, then we have two integers
.907c	4c 55 9f	jmp $9f55			jmp 	TypeError 					; anything else, type mismatch.
.907f					_IntegerCode:
.907f					IntegerModulusNoCheck:
.907f	20 58 90	jsr $9058			jsr 	CheckDivideZero 			; do div zero check
.9082	20 8a 90	jsr $908a			jsr 	Int32Divide 				; do the division
.9085	16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.9087	56 50		lsr $50,x			lsr 	NSStatus,x
.9089	60		rts				rts
.908a					Int32Divide:
.908a	48		pha				pha 								; save AXY
.908b	5a		phy				phy
.908c	20 b0 9d	jsr $9db0			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.908f	20 c9 9d	jsr $9dc9			jsr 	NSMSetZeroMantissaOnly 		; set S[X] to zero
.9092	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.9094					_I32DivideLoop:
.9094	e8		inx				inx
.9095	e8		inx				inx
.9096	20 dc 9d	jsr $9ddc			jsr 	NSMShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.9099	ca		dex				dex
.909a	ca		dex				dex
.909b	20 dd 9d	jsr $9ddd			jsr 	NSMRotateLeft
.909e	20 c9 90	jsr $90c9			jsr 	DivideCheckSubtract 		; check if subtract possible
.90a1	90 02		bcc $90a5			bcc 	_I32DivideNoCarryIn
.90a3	f6 5a		inc $5a,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.90a5					_I32DivideNoCarryIn:
.90a5	88		dey				dey 								; loop round till division completed.
.90a6	d0 ec		bne $9094			bne 	_I32DivideLoop
.90a8	7a		ply				ply 								; restore AXY and exit
.90a9	68		pla				pla
.90aa	60		rts				rts
.90ab					Int32ShiftDivide:
.90ab	48		pha				pha 								; save AY
.90ac	5a		phy				phy
.90ad	e8		inx				inx 								; clear S[X+2]
.90ae	e8		inx				inx
.90af	20 cd 9d	jsr $9dcd			jsr 	NSMSetZero
.90b2	ca		dex				dex
.90b3	ca		dex				dex
.90b4	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.90b6					_I32SDLoop:
.90b6	20 c9 90	jsr $90c9			jsr 	DivideCheckSubtract 		; check if subtract possible
.90b9	e8		inx				inx
.90ba	e8		inx				inx
.90bb	20 dd 9d	jsr $9ddd			jsr 	NSMRotateLeft				; shift 64 bit FPA left, rotating carry in
.90be	ca		dex				dex
.90bf	ca		dex				dex
.90c0	20 dd 9d	jsr $9ddd			jsr 	NSMRotateLeft
.90c3	88		dey				dey 	 							; do 31 times
.90c4	d0 f0		bne $90b6			bne 	_I32SDLoop
.90c6	7a		ply				ply 								; restore AY and exit
.90c7	68		pla				pla
.90c8	60		rts				rts
.90c9					DivideCheckSubtract:
.90c9	20 d4 91	jsr $91d4			jsr 	SubTopTwoStack 				; subtract Stack[X+1] from Stack[X+0]
.90cc	b0 04		bcs $90d2			bcs 	_DCSExit 					; if carry set, then could do, exit
.90ce	20 ba 91	jsr $91ba			jsr 	AddTopTwoStack 				; add it back in
.90d1	18		clc				clc 								; and return False
.90d2					_DCSExit:
.90d2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/multiply.asm

.90d3					MulInteger:
.90d3	fa		plx				plx
.90d4	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.90d6	15 51		ora $51,x			ora 	NSStatus+1,x
.90d8	0a		asl a				asl 	a 							; shift reference bit into sign bit
.90d9	0a		asl a				asl 	a
.90da	10 05		bpl $90e1			bpl 	_NotRef
.90dc	48		pha				pha
.90dd	20 82 96	jsr $9682			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.90e0	68		pla				pla
.90e1					_NotRef:
.90e1	0a		asl a				asl 	a 							; put MSB of type into A:7
.90e2	30 09		bmi $90ed			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.90e4	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.90e6	15 79		ora $79,x			ora 	NSExponent+1,x
.90e8	f0 06		beq $90f0			beq 	_IntegerCode 				; if clear, then we have two integers
.90ea	4c 51 95	jmp $9551			jmp 	FloatingPointMultiply 							; otherwise at least one float.
.90ed					_StringData:
.90ed	4c 5f 9f	jmp $9f5f			jmp 	NotDoneError							; at least one string - don't know both are strings.
.90f0					_IntegerCode:
.90f0	20 fd 90	jsr $90fd			jsr 	MultiplyShort
.90f3	c9 00		cmp #$00			cmp 	#0
.90f5	f0 05		beq $90fc			beq 	_MIExit
.90f7	a9 04		lda #$04		lda	#4
.90f9	4c c0 8e	jmp $8ec0		jmp	ErrorHandler
.90fc					_MIExit:
.90fc	60		rts				rts
.90fd					MultiplyShort:
.90fd	5a		phy				phy 								; save Y
.90fe	20 b0 9d	jsr $9db0			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.9101	20 c9 9d	jsr $9dc9			jsr 	NSMSetZeroMantissaOnly 		; set mantissa S[X] to zero
.9104	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.9106					_I32MLoop:
.9106	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.9108	15 62		ora $62,x			ora 	NSMantissa1+2,x
.910a	15 6a		ora $6a,x			ora 	NSMantissa2+2,x
.910c	15 72		ora $72,x			ora 	NSMantissa3+2,x
.910e	f0 25		beq $9135			beq 	_I32MExit 					; exit if zero
.9110	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.9112	29 01		and #$01			and 	#1
.9114	f0 0d		beq $9123			beq 	_I32MNoAdd
.9116	20 ba 91	jsr $91ba			jsr 	AddTopTwoStack 				; if so add S[X+1] to S[X+0]
.9119	b5 70		lda $70,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.911b	10 06		bpl $9123			bpl 	_I32MNoAdd
.911d					_I32ShiftRight:
.911d	20 e6 9d	jsr $9de6			jsr 	NSMShiftRight 				; shift S[X] right
.9120	c8		iny				iny 								; increment shift count
.9121	80 09		bra $912c			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.9123					_I32MNoAdd:
.9123	34 71		bit $71,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.9125	70 f6		bvs $911d			bvs 	_I32ShiftRight 				; instead.
.9127	e8		inx				inx
.9128	20 dc 9d	jsr $9ddc			jsr 	NSMShiftLeft 				; shift additive S[X+1] left
.912b	ca		dex				dex
.912c					_I32MShiftUpper:
.912c	e8		inx				inx 								; shift S[X+2] right
.912d	e8		inx				inx
.912e	20 e6 9d	jsr $9de6			jsr 	NSMShiftRight
.9131	ca		dex				dex
.9132	ca		dex				dex
.9133	80 d1		bra $9106			bra 	_I32MLoop 					; try again.
.9135					_I32MExit:
.9135	20 3b 91	jsr $913b			jsr 	CalculateSign
.9138	98		tya				tya 								; shift in A
.9139	7a		ply				ply 								; restore Y and exit
.913a	60		rts				rts
.913b					CalculateSign:
.913b	b5 50		lda $50,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.913d	16 50		asl $50,x			asl 	NSStatus,x 					; shift result left
.913f	55 51		eor $51,x			eor 	NSStatus+1,x
.9141	0a		asl a				asl 	a 							; shift bit 7 into carry
.9142	76 50		ror $50,x			ror 	NSStatus,x 					; shift right into status byte.
.9144	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/scompare.asm

.9145					CompareStrings:
.9145	b5 50		lda $50,x			lda 	NSStatus,x 					; check both are strings
.9147	35 51		and $51,x			and 	NSStatus+1,x
.9149	29 10		and #$10			and 	#NSBIsString
.914b	f0 28		beq $9175			beq 	_CSTypeError
.914d	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy string addresses to zTemp0/1
.914f	85 36		sta $36				sta 	zTemp0
.9151	b5 60		lda $60,x			lda 	NSMantissa1,x
.9153	85 37		sta $37				sta 	zTemp0+1
.9155	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9157	85 38		sta $38				sta 	zTemp1
.9159	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.915b	85 39		sta $39				sta 	zTemp1+1
.915d	5a		phy				phy 								; save Y so we can access strings
.915e	a0 ff		ldy #$ff			ldy 	#$FF 						; -1 for pre increment.
.9160					_CSLoop:
.9160	c8		iny				iny
.9161	b1 36		lda ($36),y			lda 	(zTemp0),y 					; check if they are the same
.9163	d1 38		cmp ($38),y			cmp 	(zTemp1),y
.9165	d0 06		bne $916d			bne 	_CSDifferent
.9167	c9 00		cmp #$00			cmp 	#0 							; reached end ?
.9169	d0 f5		bne $9160			bne 	_CSLoop 					; still comparing
.916b					_CSExit:
.916b	7a		ply				ply 								; reached end, return zero in A from EOS
.916c	60		rts				rts
.916d					_CSDifferent:
.916d	a9 ff		lda #$ff			lda 	#255 						; if < return $FF
.916f	90 fa		bcc $916b			bcc		_CSExit
.9171	a9 01		lda #$01			lda 	#1 							; otherwise return 1.
.9173	80 f6		bra $916b			bra 	_CSExit
.9175					_CSTypeError:
.9175	4c 55 9f	jmp $9f55			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/shifts.asm

.9178					ShiftLeft:
.9178	38		sec				sec 								; common code, carry determines which way.
.9179	80 01		bra $917c			bra 	ShiftMain
.917b					ShiftRight:
.917b	18		clc				clc
.917c					ShiftMain:
.917c	fa		plx				plx 								; restore X
.917d	08		php				php 								; save direction
.917e	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9180	15 51		ora $51,x			ora 	NSStatus+1,x
.9182	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9183	0a		asl a				asl 	a
.9184	10 05		bpl $918b			bpl 	_NotRef
.9186	48		pha				pha
.9187	20 82 96	jsr $9682			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.918a	68		pla				pla
.918b					_NotRef:
.918b	0a		asl a				asl 	a
.918c	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.918e	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9190	15 79		ora $79,x			ora 	NSExponent+1,x
.9192	f0 03		beq $9197			beq 	_IntegerCode 				; if clear, then we have two integers
.9194	4c 55 9f	jmp $9f55			jmp 	TypeError 					; anything else, type mismatch.
.9197					_IntegerCode:
.9197	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; check number < 32
.9199	29 e0		and #$e0			and 	#$E0
.919b	15 61		ora $61,x			ora 	NSMantissa1+1,x
.919d	15 69		ora $69,x			ora 	NSMantissa2+1,x
.919f	15 71		ora $71,x			ora 	NSMantissa3+1,x
.91a1	d0 12		bne $91b5			bne 	_SMExit0 					; if >= 32 it will always return zero.
.91a3					_SMLoop:
.91a3	d6 59		dec $59,x			dec 	NSMantissa0+1,x 			; predecrement, could do << 0
.91a5	30 11		bmi $91b8			bmi 	_SMExit 					; exit if done.
.91a7	28		plp				plp 								; restore direction setting
.91a8	08		php				php
.91a9	90 05		bcc $91b0			bcc 	_SMRight
.91ab	20 dc 9d	jsr $9ddc			jsr 	NSMShiftLeft 				; shift left if CS
.91ae	80 f3		bra $91a3			bra 	_SMLoop
.91b0					_SMRight:
.91b0	20 e6 9d	jsr $9de6			jsr 	NSMShiftRight 				; shift right if CC
.91b3	80 ee		bra $91a3			bra 	_SMLoop
.91b5					_SMExit0:
.91b5	20 cd 9d	jsr $9dcd			jsr 	NSMSetZero 					; return zero.
.91b8					_SMExit:
.91b8	28		plp				plp 								; throw direction
.91b9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/simple.asm

.91ba					AddTopTwoStack:
.91ba	18		clc				clc
.91bb	b5 58		lda $58,x			lda		NSMantissa0,x
.91bd	75 59		adc $59,x			adc 		NSMantissa0+1,x
.91bf	95 58		sta $58,x			sta 	NSMantissa0,x
.91c1	b5 60		lda $60,x			lda		NSMantissa1,x
.91c3	75 61		adc $61,x			adc 		NSMantissa1+1,x
.91c5	95 60		sta $60,x			sta 	NSMantissa1,x
.91c7	b5 68		lda $68,x			lda		NSMantissa2,x
.91c9	75 69		adc $69,x			adc 		NSMantissa2+1,x
.91cb	95 68		sta $68,x			sta 	NSMantissa2,x
.91cd	b5 70		lda $70,x			lda		NSMantissa3,x
.91cf	75 71		adc $71,x			adc 		NSMantissa3+1,x
.91d1	95 70		sta $70,x			sta 	NSMantissa3,x
.91d3	60		rts				rts
.91d4					SubTopTwoStack:
.91d4	38		sec				sec
.91d5	b5 58		lda $58,x			lda		NSMantissa0,x
.91d7	f5 59		sbc $59,x			sbc 		NSMantissa0+1,x
.91d9	95 58		sta $58,x			sta 	NSMantissa0,x
.91db	b5 60		lda $60,x			lda		NSMantissa1,x
.91dd	f5 61		sbc $61,x			sbc 		NSMantissa1+1,x
.91df	95 60		sta $60,x			sta 	NSMantissa1,x
.91e1	b5 68		lda $68,x			lda		NSMantissa2,x
.91e3	f5 69		sbc $69,x			sbc 		NSMantissa2+1,x
.91e5	95 68		sta $68,x			sta 	NSMantissa2,x
.91e7	b5 70		lda $70,x			lda		NSMantissa3,x
.91e9	f5 71		sbc $71,x			sbc 		NSMantissa3+1,x
.91eb	95 70		sta $70,x			sta 	NSMantissa3,x
.91ed	60		rts				rts
.91ee					AddInteger:
.91ee	fa		plx				plx
.91ef	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.91f1	15 51		ora $51,x			ora 	NSStatus+1,x
.91f3	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91f4	0a		asl a				asl 	a
.91f5	10 05		bpl $91fc			bpl 	_NotRef
.91f7	48		pha				pha
.91f8	20 82 96	jsr $9682			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91fb	68		pla				pla
.91fc					_NotRef:
.91fc	0a		asl a				asl 	a 							; put MSB of type into A:7
.91fd	30 09		bmi $9208			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.91ff	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9201	15 79		ora $79,x			ora 	NSExponent+1,x
.9203	f0 06		beq $920b			beq 	_IntegerCode 				; if clear, then we have two integers
.9205	4c 01 94	jmp $9401			jmp 	FloatingPointAdd 							; otherwise at least one float.
.9208					_StringData:
.9208	4c c7 8f	jmp $8fc7			jmp 	StringConcat							; at least one string - don't know both are strings.
.920b					_IntegerCode:
.920b					AddCode:
.920b	b5 50		lda $50,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.920d	55 51		eor $51,x			eor 	NSStatus+1,x
.920f	10 a9		bpl $91ba			bpl 	AddTopTwoStack
.9211	20 d4 91	jsr $91d4			jsr 	SubTopTwoStack 				; do a physical subtraction
.9214	34 70		bit $70,x			bit 	NSMantissa3,x 				; result is +ve, okay
.9216	10 07		bpl $921f			bpl 	_AddExit
.9218	b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign is that of 2nd value
.921a	95 50		sta $50,x			sta 	NSStatus,x
.921c	20 96 9d	jsr $9d96			jsr 	NSMNegateMantissa 			; negate the mantissa and exit
.921f					_AddExit:
.921f	20 ef 9d	jsr $9def			jsr 	NSMIsZero 					; check for -0
.9222	d0 02		bne $9226			bne 	_AddNonZero
.9224	74 50		stz $50,x			stz 	NSStatus,x
.9226					_AddNonZero:
.9226	60		rts				rts
.9227					SubInteger:
.9227	fa		plx				plx
.9228	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.922a	15 51		ora $51,x			ora 	NSStatus+1,x
.922c	0a		asl a				asl 	a 							; shift reference bit into sign bit
.922d	0a		asl a				asl 	a
.922e	10 05		bpl $9235			bpl 	_NotRef
.9230	48		pha				pha
.9231	20 82 96	jsr $9682			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9234	68		pla				pla
.9235					_NotRef:
.9235	0a		asl a				asl 	a 							; put MSB of type into A:7
.9236	30 09		bmi $9241			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9238	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.923a	15 79		ora $79,x			ora 	NSExponent+1,x
.923c	f0 06		beq $9244			beq 	_IntegerCode 				; if clear, then we have two integers
.923e	4c 06 94	jmp $9406			jmp 	FloatingPointSub 							; otherwise at least one float.
.9241					_StringData:
.9241	4c 5f 9f	jmp $9f5f			jmp 	NotDoneError							; at least one string - don't know both are strings.
.9244					_IntegerCode:
.9244	b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate the second value.
.9246	49 80		eor #$80			eor 	#$80
.9248	95 51		sta $51,x			sta 	NSStatus+1,x
.924a	80 bf		bra $920b			bra 	AddCode 					; and do the same code as add.
.924c					AndInteger:
.924c	fa		plx				plx
.924d	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.924f	15 51		ora $51,x			ora 	NSStatus+1,x
.9251	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9252	0a		asl a				asl 	a
.9253	10 05		bpl $925a			bpl 	_NotRef
.9255	48		pha				pha
.9256	20 82 96	jsr $9682			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9259	68		pla				pla
.925a					_NotRef:
.925a	0a		asl a				asl 	a
.925b	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.925d	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.925f	15 79		ora $79,x			ora 	NSExponent+1,x
.9261	f0 03		beq $9266			beq 	_IntegerCode 				; if clear, then we have two integers
.9263	4c 55 9f	jmp $9f55			jmp 	TypeError 					; anything else, type mismatch.
.9266					_IntegerCode:
.9266	b5 58		lda $58,x			lda		NSMantissa0,x
.9268	35 59		and $59,x			and 		NSMantissa0+1,x
.926a	95 58		sta $58,x			sta 	NSMantissa0,x
.926c	b5 60		lda $60,x			lda		NSMantissa1,x
.926e	35 61		and $61,x			and 		NSMantissa1+1,x
.9270	95 60		sta $60,x			sta 	NSMantissa1,x
.9272	b5 68		lda $68,x			lda		NSMantissa2,x
.9274	35 69		and $69,x			and 		NSMantissa2+1,x
.9276	95 68		sta $68,x			sta 	NSMantissa2,x
.9278	b5 70		lda $70,x			lda		NSMantissa3,x
.927a	35 71		and $71,x			and 		NSMantissa3+1,x
.927c	95 70		sta $70,x			sta 	NSMantissa3,x
.927e	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.9280	60		rts				rts
.9281					OraInteger:
.9281	fa		plx				plx
.9282	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9284	15 51		ora $51,x			ora 	NSStatus+1,x
.9286	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9287	0a		asl a				asl 	a
.9288	10 05		bpl $928f			bpl 	_NotRef
.928a	48		pha				pha
.928b	20 82 96	jsr $9682			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.928e	68		pla				pla
.928f					_NotRef:
.928f	0a		asl a				asl 	a
.9290	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9292	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9294	15 79		ora $79,x			ora 	NSExponent+1,x
.9296	f0 03		beq $929b			beq 	_IntegerCode 				; if clear, then we have two integers
.9298	4c 55 9f	jmp $9f55			jmp 	TypeError 					; anything else, type mismatch.
.929b					_IntegerCode:
.929b	b5 58		lda $58,x			lda		NSMantissa0,x
.929d	15 59		ora $59,x			ora 		NSMantissa0+1,x
.929f	95 58		sta $58,x			sta 	NSMantissa0,x
.92a1	b5 60		lda $60,x			lda		NSMantissa1,x
.92a3	15 61		ora $61,x			ora 		NSMantissa1+1,x
.92a5	95 60		sta $60,x			sta 	NSMantissa1,x
.92a7	b5 68		lda $68,x			lda		NSMantissa2,x
.92a9	15 69		ora $69,x			ora 		NSMantissa2+1,x
.92ab	95 68		sta $68,x			sta 	NSMantissa2,x
.92ad	b5 70		lda $70,x			lda		NSMantissa3,x
.92af	15 71		ora $71,x			ora 		NSMantissa3+1,x
.92b1	95 70		sta $70,x			sta 	NSMantissa3,x
.92b3	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.92b5	60		rts				rts
.92b6					EorInteger:
.92b6	fa		plx				plx
.92b7	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.92b9	15 51		ora $51,x			ora 	NSStatus+1,x
.92bb	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92bc	0a		asl a				asl 	a
.92bd	10 05		bpl $92c4			bpl 	_NotRef
.92bf	48		pha				pha
.92c0	20 82 96	jsr $9682			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92c3	68		pla				pla
.92c4					_NotRef:
.92c4	0a		asl a				asl 	a
.92c5	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.92c7	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92c9	15 79		ora $79,x			ora 	NSExponent+1,x
.92cb	f0 03		beq $92d0			beq 	_IntegerCode 				; if clear, then we have two integers
.92cd	4c 55 9f	jmp $9f55			jmp 	TypeError 					; anything else, type mismatch.
.92d0					_IntegerCode:
.92d0	b5 58		lda $58,x			lda		NSMantissa0,x
.92d2	55 59		eor $59,x			eor 		NSMantissa0+1,x
.92d4	95 58		sta $58,x			sta 	NSMantissa0,x
.92d6	b5 60		lda $60,x			lda		NSMantissa1,x
.92d8	55 61		eor $61,x			eor 		NSMantissa1+1,x
.92da	95 60		sta $60,x			sta 	NSMantissa1,x
.92dc	b5 68		lda $68,x			lda		NSMantissa2,x
.92de	55 69		eor $69,x			eor 		NSMantissa2+1,x
.92e0	95 68		sta $68,x			sta 	NSMantissa2,x
.92e2	b5 70		lda $70,x			lda		NSMantissa3,x
.92e4	55 71		eor $71,x			eor 		NSMantissa3+1,x
.92e6	95 70		sta $70,x			sta 	NSMantissa3,x
.92e8	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.92ea	60		rts				rts
.92eb					WordIndirect:
.92eb	fa		plx				plx
.92ec	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.92ee	15 51		ora $51,x			ora 	NSStatus+1,x
.92f0	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92f1	0a		asl a				asl 	a
.92f2	10 05		bpl $92f9			bpl 	_NotRef
.92f4	48		pha				pha
.92f5	20 82 96	jsr $9682			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92f8	68		pla				pla
.92f9					_NotRef:
.92f9	0a		asl a				asl 	a
.92fa	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.92fc	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92fe	15 79		ora $79,x			ora 	NSExponent+1,x
.9300	f0 03		beq $9305			beq 	_IntegerCode 				; if clear, then we have two integers
.9302	4c 55 9f	jmp $9f55			jmp 	TypeError 					; anything else, type mismatch.
.9305					_IntegerCode:
.9305	20 0b 92	jsr $920b			jsr 	AddCode 					; add the two values
.9308	a9 22		lda #$22			lda 	#NSBIsReference+2 			; make a 2 byte reference
.930a	95 50		sta $50,x			sta 	NSStatus,x
.930c	60		rts				rts
.930d					ByteIndirect:
.930d	fa		plx				plx
.930e	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9310	15 51		ora $51,x			ora 	NSStatus+1,x
.9312	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9313	0a		asl a				asl 	a
.9314	10 05		bpl $931b			bpl 	_NotRef
.9316	48		pha				pha
.9317	20 82 96	jsr $9682			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.931a	68		pla				pla
.931b					_NotRef:
.931b	0a		asl a				asl 	a
.931c	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.931e	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9320	15 79		ora $79,x			ora 	NSExponent+1,x
.9322	f0 03		beq $9327			beq 	_IntegerCode 				; if clear, then we have two integers
.9324	4c 55 9f	jmp $9f55			jmp 	TypeError 					; anything else, type mismatch.
.9327					_IntegerCode:
.9327	20 0b 92	jsr $920b			jsr 	AddCode 					; add the two values
.932a	a9 21		lda #$21			lda 	#NSBIsReference+1 			; make a 1 byte reference
.932c	95 50		sta $50,x			sta 	NSStatus,x
.932e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/tostring.asm

.932f					ConvertInt16:
.932f	85 58		sta $58				sta 	NSMantissa0 				; set up as 32 bit conversion
.9331	86 60		stx $60				stx 	NSMantissa1
.9333	64 68		stz $68				stz 	NSMantissa2
.9335	64 70		stz $70				stz 	NSMantissa3
.9337	64 50		stz $50				stz 	NSStatus 					; positive integer
.9339	a2 00		ldx #$00			ldx 	#0 							; stack level
.933b	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.933d	80 00		bra $933f			bra 	ConvertInt32
.933f					ConvertInt32:
.933f	5a		phy				phy
.9340	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.9342	24 50		bit $50				bit 	NSStatus 					; output a - if not negative.
.9344	10 08		bpl $934e			bpl 	_CI32NotNeg
.9346	48		pha				pha
.9347	a9 2d		lda #$2d			lda 	#'-'
.9349	99 7b 05	sta $057b,y			sta 	NumberBuffer,y
.934c	c8		iny				iny
.934d	68		pla				pla
.934e					_CI32NotNeg:
.934e	20 5c 93	jsr $935c			jsr 	_CI32DivideConvert 			; recursive conversion
.9351	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.9353	99 7b 05	sta $057b,y			sta 	NumberBuffer,y
.9356	7a		ply				ply
.9357	a2 05		ldx #$05			ldx 	#NumberBuffer >> 8 			; return address in XA
.9359	a9 7b		lda #$7b			lda 	#NumberBuffer & $FF
.935b	60		rts				rts
.935c					_CI32DivideConvert:
.935c	e8		inx				inx 								; write to next slot up
.935d	20 cf 9d	jsr $9dcf			jsr 	NSMSetByte 		 			; write the base out.
.9360	ca		dex				dex
.9361	20 8a 90	jsr $908a			jsr 	Int32Divide 				; divide
.9364	b5 58		lda $58,x			lda 	NSMantissa0,x 				; save remainder
.9366	48		pha				pha
.9367	20 47 90	jsr $9047			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.936a	20 ef 9d	jsr $9def			jsr 	NSMIsZero 					; is it zero ?
.936d	f0 05		beq $9374			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.936f	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.9371	20 5c 93	jsr $935c			jsr 	_CI32DivideConvert 			; and recusrively call.
.9374					_CI32NoRecurse:
.9374	68		pla				pla 								; remainder
.9375	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.9377	90 02		bcc $937b			bcc 	_CI32NotHex
.9379	69 26		adc #$26			adc 	#6+32
.937b					_CI32NotHex:
.937b	69 30		adc #$30			adc 	#48
.937d	99 7b 05	sta $057b,y			sta 	NumberBuffer,y 				; write out and exit
.9380	c8		iny				iny
.9381	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/expression.asm


;******  Processing file: ./common/expressions/../generated/precedence.dat

.9382					PrecedenceLevel:
>9382	04					.byte	 4	; $00 <<
>9383	02					.byte	 2	; $01 <=
>9384	02					.byte	 2	; $02 <>
>9385	00					.byte	 0	; $03 !!3
>9386	00					.byte	 0	; $04 ><
>9387	02					.byte	 2	; $05 >=
>9388	04					.byte	 4	; $06 >>
>9389	00					.byte	 0	; $07 !!7
>938a	00					.byte	 0	; $08 !!8
>938b	00					.byte	 0	; $09 !!9
>938c	00					.byte	 0	; $0a !!10
>938d	00					.byte	 0	; $0b !!11
>938e	00					.byte	 0	; $0c !!12
>938f	00					.byte	 0	; $0d !!13
>9390	00					.byte	 0	; $0e !!14
>9391	00					.byte	 0	; $0f !!15
>9392	00					.byte	 0	; $10 @
>9393	00					.byte	 0	; $11 !!17
>9394	00					.byte	 0	; $12 !!18
>9395	00					.byte	 0	; $13 [
>9396	04					.byte	 4	; $14 \
>9397	00					.byte	 0	; $15 ]
>9398	01					.byte	 1	; $16 ^
>9399	00					.byte	 0	; $17 _
>939a	00					.byte	 0	; $18 `
>939b	00					.byte	 0	; $19 !!25
>939c	00					.byte	 0	; $1a !!26
>939d	00					.byte	 0	; $1b {
>939e	01					.byte	 1	; $1c |
>939f	00					.byte	 0	; $1d }
>93a0	00					.byte	 0	; $1e ~
>93a1	00					.byte	 0	; $1f [7m<7F>[m
>93a2	00					.byte	 0	; $20
>93a3	05					.byte	 5	; $21 !
>93a4	00					.byte	 0	; $22 "
>93a5	00					.byte	 0	; $23 #
>93a6	05					.byte	 5	; $24 $
>93a7	04					.byte	 4	; $25 %
>93a8	01					.byte	 1	; $26 &
>93a9	00					.byte	 0	; $27 '
>93aa	00					.byte	 0	; $28 (
>93ab	00					.byte	 0	; $29 )
>93ac	04					.byte	 4	; $2a *
>93ad	03					.byte	 3	; $2b +
>93ae	00					.byte	 0	; $2c ,
>93af	03					.byte	 3	; $2d -
>93b0	00					.byte	 0	; $2e .
>93b1	04					.byte	 4	; $2f /
>93b2	00					.byte	 0	; $30 0
>93b3	00					.byte	 0	; $31 1
>93b4	00					.byte	 0	; $32 2
>93b5	00					.byte	 0	; $33 3
>93b6	00					.byte	 0	; $34 4
>93b7	00					.byte	 0	; $35 5
>93b8	00					.byte	 0	; $36 6
>93b9	00					.byte	 0	; $37 7
>93ba	00					.byte	 0	; $38 8
>93bb	00					.byte	 0	; $39 9
>93bc	00					.byte	 0	; $3a :
>93bd	00					.byte	 0	; $3b ;
>93be	02					.byte	 2	; $3c <
>93bf	02					.byte	 2	; $3d =
>93c0	02					.byte	 2	; $3e >
>93c1	05					.byte	 5	; $3f ?

;******  Return to file: ./common/expressions/expression.asm

.93c2					EvaluateExpressionAt0:
.93c2	a2 00		ldx #$00			ldx 	#0 							; bottom stack level
.93c4					EvaluateExpression:
.93c4	a9 00		lda #$00			lda 	#0 							; lowest precedence level
.93c6					EvaluateExpressionAtPrecedence:
.93c6	48		pha				pha 								; save precedence level
.93c7	20 0e 98	jsr $980e			jsr 	EvaluateTerm 				; evaluate term into level X.
.93ca	68		pla				pla 								; restore precedence level.
.93cb					_EXPRLoop:
.93cb	85 36		sta $36				sta 	zTemp0 						; save current precedence level.
.93cd	b1 30		lda ($30),y			lda 	(codePtr),y
.93cf	c9 40		cmp #$40			cmp		#$40 						; if >= $40 cannot be an operator
.93d1	b0 25		bcs $93f8			bcs 	_EXPRExit
.93d3	da		phx				phx 								; read the operator precedence
.93d4	aa		tax				tax
.93d5	bd 82 93	lda $9382,x			lda 	PrecedenceLevel,x
.93d8	fa		plx				plx
.93d9	c9 00		cmp #$00			cmp 	#0							; if zero exit (not an operator)
.93db	f0 1b		beq $93f8			beq 	_EXPRExit
.93dd	85 37		sta $37				sta 	zTemp0+1 					; save operator precedence level.
.93df	a5 36		lda $36				lda 	zTemp0 						; compare current precedence vs. operator precedence
.93e1	c5 37		cmp $37				cmp 	zTemp0+1
.93e3	b0 13		bcs $93f8			bcs		_EXPRExit 					; if current >= operator exit
.93e5	48		pha				pha 								; save current precedence.
.93e6	b1 30		lda ($30),y			lda 	(codePtr),y
.93e8	c8		iny				iny
.93e9	48		pha				pha
.93ea	a5 37		lda $37				lda 	zTemp0+1 					; get operator precedence level
.93ec	e8		inx				inx 								; work out the right hand side.
.93ed	20 c6 93	jsr $93c6			jsr 	EvaluateExpressionAtPrecedence
.93f0	ca		dex				dex
.93f1	68		pla				pla 								; get operator, call the code.
.93f2	20 fb 93	jsr $93fb			jsr 	_EXPRCaller
.93f5	68		pla				pla 								; restore precedence level
.93f6	80 d3		bra $93cb			bra 	_EXPRLoop 					; and go round.
.93f8					_EXPRExit:
.93f8	a5 36		lda $36				lda 	zTemp0 						; A = current precedence level.
.93fa	60		rts				rts
.93fb					_EXPRCaller:
.93fb	da		phx				phx 								; save on stack, first thing is to restore it
.93fc	0a		asl a				asl 	a 							; double so can use vectors into X
.93fd	aa		tax				tax
.93fe	7c 82 8b	jmp ($8b82,x)			jmp 	(VectorSetPunc,x) 			; and go to the code.

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/addsub.asm

.9401					FloatingPointAdd:
.9401	20 77 95	jsr $9577			jsr 	FloatPrepare 				; prepare for floats
.9404	80 09		bra $940f			bra 	FloatAdd
.9406					FloatingPointSub:
.9406	20 77 95	jsr $9577			jsr 	FloatPrepare 				; prepare for floats
.9409					FloatSubtract:
.9409	b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate FPB
.940b	49 80		eor #$80			eor 	#$80
.940d	95 51		sta $51,x			sta 	NSStatus+1,x				; and fall through.
.940f					FloatAdd:
.940f	48		pha				pha
.9410	5a		phy				phy
.9411	20 86 95	jsr $9586			jsr 	NSNormalise 				; normalise S[X]
.9414	f0 51		beq $9467			beq 	_FAReturn1
.9416	e8		inx				inx 								; normalise S[X+1]
.9417	20 86 95	jsr $9586			jsr 	NSNormalise
.941a	ca		dex				dex
.941b	c9 00		cmp #$00			cmp 	#0
.941d	f0 60		beq $947f			beq 	_FAExit 					; if so, just return A
.941f	b5 78		lda $78,x			lda 	NSExponent,x 				; are the exponents the same ?
.9421	d5 79		cmp $79,x			cmp 	NSExponent+1,x
.9423	f0 18		beq $943d			beq 	_FAExponentsEqual
.9425	b5 78		lda $78,x			lda 	NSExponent,x 				; work out the larger exponent
.9427	a8		tay				tay
.9428	38		sec				sec 								; do a signed comparison of the exponents.
.9429	f5 79		sbc $79,x			sbc 	NSExponent+1,x
.942b	50 02		bvc $942f			bvc 	_FANoSignedChange
.942d	49 80		eor #$80			eor 	#$80
.942f					_FANoSignedChange:
.942f	29 80		and #$80			and 	#$80
.9431	10 02		bpl $9435			bpl 	_FAHaveMax
.9433	b4 79		ldy $79,x			ldy 	NSExponent+1,x
.9435					_FAHaveMax:
.9435	20 82 94	jsr $9482			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.9438	e8		inx				inx
.9439	20 82 94	jsr $9482			jsr 	_FAShiftToExponent
.943c	ca		dex				dex
.943d					_FAExponentsEqual:
.943d	b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs the same
.943f	55 51		eor $51,x			eor 	NSStatus+1,x
.9441	30 0e		bmi $9451			bmi 	_FADifferentSigns
.9443	20 ba 91	jsr $91ba			jsr 	AddTopTwoStack 				; do the add of the mantissae
.9446	b5 70		lda $70,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.9448	10 35		bpl $947f			bpl 	_FAExit 					; if no, we are done.
.944a	20 e6 9d	jsr $9de6			jsr 	NSMShiftRight 				; shift A right, renormalising it.
.944d	f6 78		inc $78,x			inc 	NSExponent,x 				; bump the exponent and exit
.944f	80 2e		bra $947f			bra 	_FAExit
.9451					_FADifferentSigns:
.9451	20 d4 91	jsr $91d4			jsr 	SubTopTwoStack 				; subtract mantissa B from A
.9454	b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the result negative ?
.9456	10 06		bpl $945e			bpl 	_FACheckZero 				; if no, check for -0
.9458	20 8f 9d	jsr $9d8f			jsr 	NSMNegate 					; netate result
.945b	20 96 9d	jsr $9d96			jsr 	NSMNegateMantissa 			; negate (2'c) the mantissa
.945e					_FACheckZero:
.945e	20 ef 9d	jsr $9def			jsr 	NSMIsZero	 				; check for -0
.9461	d0 1c		bne $947f			bne 	_FAExit
.9463	74 50		stz $50,x			stz 	NSStatus,x
.9465	80 18		bra $947f			bra 	_FAExit
.9467					_FAReturn1:
.9467	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.9469	95 58		sta $58,x			sta 	NSMantissa0,x
.946b	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.946d	95 60		sta $60,x			sta 	NSMantissa1,x
.946f	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.9471	95 68		sta $68,x			sta 	NSMantissa2,x
.9473	b5 71		lda $71,x			lda 	NSMantissa3+1,x
.9475	95 70		sta $70,x			sta 	NSMantissa3,x
.9477	b5 79		lda $79,x			lda 	NSExponent+1,x
.9479	95 78		sta $78,x			sta 	NSExponent,x
.947b	b5 51		lda $51,x			lda 	NSStatus+1,x
.947d	95 50		sta $50,x			sta 	NSStatus,x
.947f					_FAExit:
.947f	7a		ply				ply
.9480	68		pla				pla
.9481	60		rts				rts
.9482					_FAShiftToExponent:
.9482					_FAShiftToExponent2:
.9482	98		tya				tya 								; compare Y to exponent
.9483	d5 78		cmp $78,x			cmp 	NSExponent,x 				; reached the exponent required ?
.9485	f0 07		beq $948e			beq 	_FASEExit 					; exit if so.
.9487	20 e6 9d	jsr $9de6			jsr 	NSMShiftRight	 			; shift the mantissa right
.948a	f6 78		inc $78,x			inc 	NSExponent,x 				; increment exponent
.948c	80 f4		bra $9482			bra 	_FAShiftToExponent2
.948e					_FASEExit:
.948e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/compare.asm

.948f					CompareFloat:
.948f	20 09 94	jsr $9409			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.9492	b5 60		lda $60,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.9494	29 f8		and #$f8			and 	#$F8
.9496	15 68		ora $68,x			ora 	NSMantissa2,x
.9498	15 70		ora $70,x			ora 	NSMantissa3,x
.949a	f0 08		beq $94a4			beq 	_FCExit 					; zero, so approximately identical
.949c	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.949e	34 50		bit $50,x			bit 	NSStatus,x
.94a0	10 02		bpl $94a4			bpl 	_FCExit
.94a2					_FCNegative:
.94a2	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.94a4					_FCExit:
.94a4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/divide.asm

.94a5					FDivideCommand:
.94a5	fa		plx				plx	 								; restore stack position
.94a6	20 77 95	jsr $9577			jsr 	FloatPrepare 				; prepare for floats
.94a9					FloatDivide:
.94a9	48		pha				pha
.94aa	e8		inx				inx
.94ab	20 86 95	jsr $9586			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.94ae	ca		dex				dex
.94af	c9 00		cmp #$00			cmp 	#0
.94b1	f0 1d		beq $94d0			beq 	_FDZero
.94b3	20 86 95	jsr $9586			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.94b6	f0 16		beq $94ce			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.94b8	20 ab 90	jsr $90ab			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.94bb	20 47 90	jsr $9047			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.94be	20 86 95	jsr $9586			jsr		NSNormalise 				; renormalise
.94c1	20 3b 91	jsr $913b			jsr 	CalculateSign 				; calculate result sign
.94c4	b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent
.94c6	38		sec				sec
.94c7	f5 79		sbc $79,x			sbc 	NSExponent+1,x
.94c9	38		sec				sec
.94ca	e9 1e		sbc #$1e			sbc 	#30
.94cc	95 78		sta $78,x			sta 	NSExponent,x
.94ce					_FDExit:
.94ce	68		pla				pla
.94cf	60		rts				rts
.94d0					_FDZero:
.94d0	a9 03		lda #$03		lda	#3
.94d2	4c c0 8e	jmp $8ec0		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/fractional.asm

.94d5					FloatFractionalPart:
.94d5	5a		phy				phy
.94d6	b5 50		lda $50,x			lda 	NSStatus,x 					; take absolute value
.94d8	29 7f		and #$7f			and 	#$7F
.94da	95 50		sta $50,x			sta 	NSStatus,x
.94dc	20 86 95	jsr $9586			jsr 	NSNormalise
.94df	b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.94e1	38		sec				sec
.94e2	e9 e0		sbc #$e0			sbc 	#$E0
.94e4	90 29		bcc $950f			bcc 	_FFPExit 					; already fractional
.94e6	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.94e8	b0 22		bcs $950c			bcs 	_FFPZero
.94ea	a8		tay				tay 								; put count to do in Y
.94eb	b5 70		lda $70,x			lda 	NSMantissa3,x 				; do each in turn.
.94ed	20 11 95	jsr $9511			jsr 	_FFPPartial
.94f0	95 70		sta $70,x			sta 	NSMantissa3,x
.94f2	b5 68		lda $68,x			lda 	NSMantissa2,x
.94f4	20 11 95	jsr $9511			jsr 	_FFPPartial
.94f7	95 68		sta $68,x			sta 	NSMantissa2,x
.94f9	b5 60		lda $60,x			lda 	NSMantissa1,x
.94fb	20 11 95	jsr $9511			jsr 	_FFPPartial
.94fe	95 60		sta $60,x			sta 	NSMantissa1,x
.9500	b5 58		lda $58,x			lda 	NSMantissa0,x
.9502	20 11 95	jsr $9511			jsr 	_FFPPartial
.9505	95 58		sta $58,x			sta 	NSMantissa0,x
.9507	20 ef 9d	jsr $9def			jsr 	NSMIsZero 					; zeroed check.
.950a	d0 03		bne $950f			bne 	_FFPExit
.950c					_FFPZero:
.950c	20 cd 9d	jsr $9dcd			jsr 	NSMSetZero
.950f					_FFPExit:
.950f	7a		ply				ply
.9510	60		rts				rts
.9511					_FFPPartial:
.9511	c0 00		cpy #$00			cpy 	#0 							; no more to do
.9513	f0 17		beq $952c			beq 	_FFFPPExit
.9515	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.9517	b0 0c		bcs $9525			bcs 	_FFFPPWholeByte
.9519	5a		phy				phy
.951a					_FFFPPLeft:
.951a	0a		asl a				asl 	a
.951b	88		dey				dey
.951c	d0 fc		bne $951a			bne 	_FFFPPLeft
.951e	7a		ply				ply
.951f					_FFFPPRight:
.951f	4a		lsr a				lsr 	a
.9520	88		dey				dey
.9521	d0 fc		bne $951f			bne 	_FFFPPRight
.9523	80 07		bra $952c			bra 	_FFFPPExit
.9525					_FFFPPWholeByte:
.9525	98		tya				tya 								; subtract 8 from count
.9526	38		sec				sec
.9527	e9 08		sbc #$08			sbc 	#8
.9529	a8		tay				tay
.952a	a9 00		lda #$00			lda 	#0 							; and clear all
.952c					_FFFPPExit:
.952c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/integer.asm

.952d					FloatIntegerPart:
.952d	48		pha				pha
.952e	b5 78		lda $78,x			lda 	NSExponent,x 				; is it integer already ?
.9530	f0 1d		beq $954f			beq 	_FIPExit 					; if so do nothing
.9532	20 ef 9d	jsr $9def			jsr 	NSMIsZero 					; is it zero ?
.9535	f0 15		beq $954c			beq 	_FIPZero 					; if so return zero.
.9537	20 86 95	jsr $9586			jsr 	NSNormalise 				; normalise
.953a	f0 10		beq $954c			beq 	_FIPZero 					; normalised to zero, exit zero
.953c					_FIPShift:
.953c	b5 78		lda $78,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.953e	10 07		bpl $9547			bpl 	_FIPCheckZero
.9540	20 e6 9d	jsr $9de6			jsr 	NSMShiftRight 				; shift mantissa right
.9543	f6 78		inc $78,x			inc 	NSExponent,x 				; bump exponent
.9545	80 f5		bra $953c			bra 	_FIPShift
.9547					_FIPCheckZero:
.9547	20 ef 9d	jsr $9def			jsr 	NSMIsZero 					; avoid -0 problem
.954a	d0 03		bne $954f			bne 	_FIPExit 					; set to zero if mantissa zero.
.954c					_FIPZero:
.954c	20 cd 9d	jsr $9dcd			jsr 	NSMSetZero
.954f					_FIPExit:
.954f	68		pla				pla
.9550	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/multiply.asm

.9551					FloatingPointMultiply:
.9551	20 77 95	jsr $9577			jsr 	FloatPrepare 				; prepare for floats
.9554					FloatMultiply:
.9554	48		pha				pha
.9555	20 86 95	jsr $9586			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.9558	f0 18		beq $9572			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.955a	e8		inx				inx
.955b	20 86 95	jsr $9586			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.955e	ca		dex				dex
.955f	c9 00		cmp #$00			cmp 	#0
.9561	f0 0c		beq $956f			beq 	_FDSetZero
.9563	20 fd 90	jsr $90fd			jsr 	MultiplyShort 				; calculate the result.
.9566	75 78		adc $78,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.9568	18		clc				clc
.9569	75 79		adc $79,x			adc 	NSExponent+1,x
.956b	95 78		sta $78,x			sta 	NSExponent,x
.956d	80 03		bra $9572			bra 	_FDExit
.956f					_FDSetZero:
.956f	20 cd 9d	jsr $9dcd			jsr 	NSMSetZero 					; return 0
.9572					_FDExit:
.9572	20 86 95	jsr $9586			jsr 	NSNormalise 				; normalise the result
.9575	68		pla				pla
.9576	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/utility.asm

.9577					FloatPrepare:
.9577	20 82 96	jsr $9682			jsr 	DereferenceTopTwo 			; dereference the top two values
.957a	b5 50		lda $50,x			lda 	NSStatus,x 					; check ints/floats, either will do.
.957c	15 51		ora $51,x			ora 	NSStatus+1,x
.957e	29 10		and #$10			and 	#NSBIsString
.9580	d0 01		bne $9583			bne 	_FDType
.9582	60		rts				rts
.9583					_FDType:
.9583	4c 55 9f	jmp $9f55			jmp 	TypeError
.9586					NSNormalise:
.9586	b5 50		lda $50,x			lda 	NSStatus,x 					; make float, keep sign
.9588	29 80		and #$80			and 	#$80
.958a	09 08		ora #$08			ora 	#NSTFloat
.958c	95 50		sta $50,x			sta 	NSStatus,x
.958e	20 ef 9d	jsr $9def			jsr 	NSMIsZero 					; if zero exit
.9591	d0 07		bne $959a			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.9593	16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.9595	76 50		ror $50,x			ror 	NSStatus,x 					; (no -0)
.9597	a9 00		lda #$00			lda 	#0 							; set Z flag
.9599	60		rts				rts
.959a					_NSNormaliseOptimise:
.959a	b5 70		lda $70,x			lda 	NSMantissa3,x 				; upper byte zero ?
.959c	d0 19		bne $95b7			bne 	_NSNormaliseLoop
.959e	b5 68		lda $68,x			lda 	NSMantissa2,x 				; byte normalise
.95a0	30 15		bmi $95b7			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.95a2	95 70		sta $70,x			sta 	NSMantissa3,x
.95a4	b5 60		lda $60,x			lda 	NSMantissa1,x
.95a6	95 68		sta $68,x			sta 	NSMantissa2,x
.95a8	b5 58		lda $58,x			lda 	NSMantissa0,x
.95aa	95 60		sta $60,x			sta 	NSMantissa1,x
.95ac	74 58		stz $58,x			stz 	NSMantissa0,x
.95ae	b5 78		lda $78,x			lda 	NSExponent,x
.95b0	38		sec				sec
.95b1	e9 08		sbc #$08			sbc 	#8
.95b3	95 78		sta $78,x			sta 	NSExponent,x
.95b5	80 e3		bra $959a			bra 	_NSNormaliseOptimise
.95b7					_NSNormaliseLoop:
.95b7	34 70		bit $70,x			bit 	NSMantissa3,x 				; bit 30 set ?
.95b9	70 07		bvs $95c2			bvs 	_NSNExit 					; exit if so with Z flag clear
.95bb	20 dc 9d	jsr $9ddc			jsr 	NSMShiftLeft 				; shift mantissa left
.95be	d6 78		dec $78,x			dec 	NSExponent,x 				; adjust exponent
.95c0	80 f5		bra $95b7			bra 	_NSNormaliseLoop
.95c2					_NSNExit:
.95c2	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.95c4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignnumber.asm

.95c5					AssignNumber:
.95c5	5a		phy				phy
.95c6	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy mantissa0/1 to zTemp0
.95c8	85 36		sta $36				sta 	zTemp0
.95ca	b5 60		lda $60,x			lda 	NSMantissa1,x
.95cc	85 37		sta $37				sta 	zTemp0+1
.95ce	b5 50		lda $50,x			lda 	NSStatus,x 					; clear reference bits
.95d0	29 df		and #$df			and 	#(NSBIsReference ^ $FF)
.95d2	95 50		sta $50,x			sta 	NSStatus,x
.95d4	29 18		and #$18			and 	#NSBTypeMask				; assigning to a float ?
.95d6	c9 08		cmp #$08			cmp 	#NSTFloat
.95d8	f0 24		beq $95fe			beq 	_ANFloat
.95da	b5 79		lda $79,x			lda		NSExponent+1,x 				; is it a float
.95dc	f0 03		beq $95e1			beq		_ANNotFloat
.95de	4c 50 9f	jmp $9f50			jmp 	RangeError					; if it is, report an error.
.95e1					_ANNotFloat:
.95e1	b5 50		lda $50,x			lda 	NSStatus,x 					; check if byte/word reference.
.95e3	29 03		and #$03			and 	#3
.95e5	d0 05		bne $95ec			bne 	_ANByteWord
.95e7	20 09 96	jsr $9609			jsr 	_ANCopy4PackSign 			; copy all 4 bytes and sign
.95ea	80 1b		bra $9607			bra 	_ANExit
.95ec					_ANByteWord:
.95ec	48		pha				pha 								; save count
.95ed	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; do byte
.95ef	92 36		sta ($36)			sta 	(zTemp0)
.95f1	68		pla				pla
.95f2	c9 01		cmp #$01			cmp	 	#1
.95f4	f0 11		beq $9607			beq 	_ANExit
.95f6	b5 61		lda $61,x			lda 	NSMantissa1+1,x 			; do word
.95f8	a0 01		ldy #$01			ldy 	#1
.95fa	91 36		sta ($36),y			sta 	(zTemp0),y
.95fc	80 09		bra $9607			bra 	_ANExit
.95fe					_ANFloat:
.95fe	20 09 96	jsr $9609			jsr 	_ANCopy4PackSign 			; write all 4 bytes and packed sign
.9601	b5 79		lda $79,x			lda 	NSExponent+1,x 				; copy exponent to slot 4
.9603	a0 04		ldy #$04			ldy 	#4
.9605	91 36		sta ($36),y			sta 	(zTemp0),y
.9607					_ANExit:
.9607	7a		ply				ply
.9608	60		rts				rts
.9609					_ANCopy4PackSign:
.9609	a0 03		ldy #$03			ldy 	#3
.960b	b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign bit into status
.960d	29 80		and #$80			and 	#$80 						; put into high bit of mantissa 3
.960f	15 71		ora $71,x			ora 	NSMantissa3+1,x
.9611	91 36		sta ($36),y			sta 	(zTemp0),y
.9613	88		dey				dey
.9614	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.9616	91 36		sta ($36),y			sta 	(zTemp0),y
.9618	88		dey				dey
.9619	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.961b	91 36		sta ($36),y			sta 	(zTemp0),y
.961d	88		dey				dey
.961e	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9620	91 36		sta ($36),y			sta 	(zTemp0),y
.9622	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignstring.asm

.9623					AssignString:
.9623	5a		phy				phy
.9624	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9626	85 38		sta $38				sta 	zTemp1
.9628	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.962a	85 39		sta $39				sta 	zTemp1+1
.962c	b5 58		lda $58,x			lda 	NSMantissa0,x
.962e	85 36		sta $36				sta 	zTemp0
.9630	b5 60		lda $60,x			lda 	NSMantissa1,x
.9632	85 37		sta $37				sta 	zTemp0+1
.9634	a0 01		ldy #$01			ldy 	#1 							; the high byte of the target address
.9636	b1 36		lda ($36),y			lda 	(zTemp0),y
.9638	f0 23		beq $965d			beq 	_ASNewStringRequired 		; if zero, a new string is required.
.963a	38		sec				sec 								; put Address-2 in zsTemp - this is the size/status/string record
.963b	b2 36		lda ($36)			lda 	(zTemp0) 					; of concreted strings
.963d	e9 02		sbc #$02			sbc 	#2
.963f	85 3c		sta $3c				sta 	zsTemp
.9641	a0 01		ldy #$01			ldy 	#1
.9643	b1 36		lda ($36),y			lda 	(zTemp0),y
.9645	e9 00		sbc #$00			sbc 	#0
.9647	85 3d		sta $3d				sta 	zsTemp+1
.9649	a0 ff		ldy #$ff			ldy 	#$FF 						; get length of new string
.964b					_ASGetLength:
.964b	c8		iny				iny
.964c	b1 38		lda ($38),y			lda 	(zTemp1),y
.964e	d0 fb		bne $964b			bne 	_ASGetLength
.9650	98		tya				tya 								; is this length <= current length
.9651	d2 3c		cmp ($3c)			cmp 	(zsTemp)
.9653	90 1e		bcc $9673			bcc 	_ASCopyString
.9655	f0 1c		beq $9673			beq 	_ASCopyString
.9657	a9 80		lda #$80			lda 	#$80 						; mark as unused.
.9659	a0 01		ldy #$01			ldy 	#1
.965b	91 3c		sta ($3c),y			sta 	(zsTemp),y
.965d					_ASNewStringRequired:
.965d	e8		inx				inx 								; concrete the new string.
.965e	20 82 a6	jsr $a682			jsr 	StringConcrete				; (breaks zTemp1/2, not zTemp0 and zsTemp)
.9661	ca		dex				dex
.9662	18		clc				clc
.9663	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy that new address to the reference.
.9665	69 02		adc #$02			adc 	#2 							; add two to point at the data.
.9667	92 36		sta ($36)			sta 	(zTemp0)
.9669	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.966b	69 00		adc #$00			adc 	#0
.966d	a0 01		ldy #$01			ldy 	#1
.966f	91 36		sta ($36),y			sta 	(zTemp0),y
.9671	80 0d		bra $9680			bra 	_ASExit
.9673					_ASCopyString:
.9673	a0 00		ldy #$00			ldy 	#0
.9675					_ASCopyLoop:
.9675	b1 38		lda ($38),y			lda 	(zTemp1),y
.9677	c8		iny				iny
.9678	c8		iny				iny
.9679	91 3c		sta ($3c),y			sta 	(zsTemp),y
.967b	88		dey				dey
.967c	c9 00		cmp #$00			cmp 	#0
.967e	d0 f5		bne $9675			bne 	_ASCopyLoop
.9680					_ASExit:
.9680	7a		ply				ply
.9681	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/dereference.asm

.9682					DereferenceTopTwo:
.9682	e8		inx				inx
.9683	20 87 96	jsr $9687			jsr 	Dereference 				; deref x+1
.9686	ca		dex				dex  								; falls through to deref x
.9687					Dereference:
.9687	b5 50		lda $50,x			lda 	NSStatus,x 					; get the status byte
.9689	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.968b	f0 48		beq $96d5			beq 	_DRFExit 					; not a reference, so exit.
.968d	5a		phy				phy
.968e	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address to dereference into zTemp0
.9690	85 36		sta $36				sta 	zTemp0
.9692	b5 60		lda $60,x			lda 	NSMantissa1,x
.9694	85 37		sta $37				sta 	zTemp0+1
.9696	74 60		stz $60,x			stz 	NSMantissa1,x 				; clear second byte.
.9698	b2 36		lda ($36)			lda 	(zTemp0) 					; do the first byte
.969a	95 58		sta $58,x			sta 	NSMantissa0,x
.969c	b5 50		lda $50,x			lda 	NSStatus,x 					; get status byte.
.969e	29 18		and #$18			and 	#NSBTypeMask 				; what type is it ?
.96a0	c9 10		cmp #$10			cmp 	#NSTString 					; if string, dereference two
.96a2	f0 0e		beq $96b2			beq 	_DRFDereferenceTwo
.96a4	c9 08		cmp #$08			cmp 	#NSTFloat 					; if float, do full dereference.
.96a6	f0 2f		beq $96d7			beq 	_DRFFull
.96a8	b5 50		lda $50,x			lda 	NSStatus,x 					; must be integer - how many bytes ?
.96aa	29 03		and #$03			and 	#3
.96ac	f0 29		beq $96d7			beq 	_DRFFull 					; the whole word
.96ae	c9 01		cmp #$01			cmp 	#1 							; is it 10 (e.g. 2 bytes)
.96b0	f0 06		beq $96b8			beq		_DRFClear23 				; no, one byte, clear 2 & 3 and exit
.96b2					_DRFDereferenceTwo:
.96b2	a0 01		ldy #$01			ldy 	#1
.96b4	b1 36		lda ($36),y			lda 	(zTemp0),y
.96b6	95 60		sta $60,x			sta 	NSMantissa1,x
.96b8					_DRFClear23:
.96b8	74 68		stz $68,x			stz 	NSMantissa2,x 				; clear upper bytes, only read 1 or 2 bytes
.96ba	74 70		stz $70,x			stz 	NSMantissa3,x
.96bc	b5 50		lda $50,x			lda 	NSStatus,x 					; make it a value of that type.
.96be	29 18		and #$18			and 	#NSBTypeMask
.96c0	95 50		sta $50,x			sta 	NSStatus,x 					; and fall through.
.96c2	c9 10		cmp #$10			cmp 	#NSTString  				; is it a string
.96c4	d0 0e		bne $96d4			bne 	_DRFNotString
.96c6	b5 58		lda $58,x			lda 	NSMantissa0,x 				; check address is zero
.96c8	15 60		ora $60,x			ora 	NSMantissa1,x
.96ca	d0 08		bne $96d4			bne 	_DRFNotString
.96cc	a9 d6		lda #$d6			lda 	#_DRFNullString & $FF 		; if so, return reference to ""
.96ce	95 58		sta $58,x			sta 	NSMantissa0,X
.96d0	a9 96		lda #$96			lda 	#_DRFNullString >> 8
.96d2	95 60		sta $60,x			sta 	NSMantissa1,X
.96d4					_DRFNotString
.96d4	7a		ply				ply 								; restore Y and exit
.96d5					_DRFExit:
.96d5	60		rts				rts
.96d6					_DRFNullString:
>96d6	00						.byte 	0
.96d7					_DRFFull:
.96d7	a0 01		ldy #$01			ldy 	#1 							; get remaining 3 bytes.
.96d9	b1 36		lda ($36),y			lda 	(zTemp0),y
.96db	95 60		sta $60,x			sta 	NSMantissa1,x
.96dd	c8		iny				iny
.96de	b1 36		lda ($36),y			lda 	(zTemp0),y
.96e0	95 68		sta $68,x			sta 	NSMantissa2,x
.96e2	c8		iny				iny
.96e3	b1 36		lda ($36),y			lda 	(zTemp0),y
.96e5	95 70		sta $70,x			sta 	NSMantissa3,x
.96e7	74 78		stz $78,x			stz 	NSExponent,x 				; clear exponent.
.96e9	b5 50		lda $50,x			lda		NSStatus,x 					; see if type is integer
.96eb	29 18		and #$18			and 	#NSBTypeMask  				; type information only
.96ed	95 50		sta $50,x			sta 	NSStatus,x 					; update it back.
.96ef	f0 05		beq $96f6			beq 	_DRFNoExponent
.96f1	c8		iny				iny 								; if not, read the exponent as well.
.96f2	b1 36		lda ($36),y			lda 	(zTemp0),y
.96f4	95 78		sta $78,x			sta 	NSExponent,x
.96f6					_DRFNoExponent:
.96f6	b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the most significant bit set ?
.96f8	10 0a		bpl $9704			bpl 	_DRFExit2 					; if not, then exit.
.96fa	29 7f		and #$7f			and 	#$7F 						; clear that bit.
.96fc	95 70		sta $70,x			sta 	NSMantissa3,x
.96fe	b5 50		lda $50,x			lda 	NSStatus,x 					; set the sign flag
.9700	09 80		ora #$80			ora 	#NSBIsNegative
.9702	95 50		sta $50,x			sta 	NSStatus,x
.9704					_DRFExit2:
.9704	7a		ply				ply
.9705	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/number.asm

=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.9706					EncodeNumberStart:
.9706	38		sec				sec
.9707	80 01		bra $970a			bra 	EncodeNumberContinue+1
.9709					EncodeNumberContinue:
.9709	18		clc				clc
.970a					EncodeNumber:
.970a	08		php				php 								; save reset flag.
.970b	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.970d	f0 12		beq $9721			beq 	_ENIsOkay
.970f	c9 30		cmp #$30			cmp 	#"0"
.9711	90 04		bcc $9717			bcc 	_ENBadNumber
.9713	c9 3a		cmp #$3a			cmp 	#"9"+1
.9715	90 0a		bcc $9721			bcc 	_ENIsOkay
.9717					_ENBadNumber:
.9717	28		plp				plp 								; throw saved reset
.9718	ad 05 04	lda $0405			lda 	EncodeState 				; if in decimal mode, construct final number
.971b	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.971d	f0 7b		beq $979a			beq 	_ENConstructFinal
.971f					_ENFail:
.971f	18		clc				clc 								; not allowed
.9720	60		rts				rts
.9721					_ENIsOkay:
.9721	28		plp				plp 								; are we restarting
.9722	90 15		bcc $9739			bcc 	_ENNoRestart
.9724					_ENStartEncode:
.9724	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.9726	f0 0c		beq $9734			beq 	_ENFirstDP
.9728	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.972a	20 cf 9d	jsr $9dcf			jsr 	NSMSetByte 					; in single byte mode.
.972d	a9 01		lda #$01			lda 	#ESTA_Low
.972f					_ENExitChange:
.972f	8d 05 04	sta $0405			sta 	EncodeState 				; save new state
.9732	38		sec				sec
.9733	60		rts				rts
.9734					_ENFirstDP:
.9734	20 cd 9d	jsr $9dcd			jsr 	NSMSetZero 					; clear integer part
.9737	80 3c		bra $9775			bra 	_ESTASwitchFloat			; go straight to float and exi
.9739					_ENNoRestart:
.9739	48		pha				pha 								; save digit or DP on stack.
.973a	ad 05 04	lda $0405			lda 	EncodeState 				; get current state
.973d	c9 01		cmp #$01			cmp 	#ESTA_Low
.973f	f0 09		beq $974a			beq  	_ESTALowState
.9741	c9 02		cmp #$02			cmp 	#ESTA_High
.9743	f0 26		beq $976b			beq 	_ESTAHighState
.9745	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.9747	f0 38		beq $9781			beq 	_ESTADecimalState
>9749	db						.byte 	$DB 						; causes a break in the emulator
.974a					_ESTALowState:
.974a	68		pla				pla 								; get value back
.974b	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.974d	f0 26		beq $9775			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.974f	29 0f		and #$0f			and 	#15 						; make digit
.9751	8d 06 04	sta $0406			sta 	DigitTemp 					; save it.
.9754	b5 58		lda $58,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.9756	0a		asl a				asl 	a
.9757	0a		asl a				asl 	a
.9758	75 58		adc $58,x			adc 	NSMantissa0,x
.975a	0a		asl a				asl 	a
.975b	6d 06 04	adc $0406			adc 	DigitTemp
.975e	95 58		sta $58,x			sta 	NSMantissa0,x
.9760	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.9762	90 05		bcc $9769			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.9764	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.9766	8d 05 04	sta $0405			sta 	EncodeState
.9769					_ESTANoSwitch:
.9769	38		sec				sec
.976a	60		rts				rts
.976b					_ESTAHighState:
.976b	68		pla				pla 								; get value back
.976c	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.976e	f0 05		beq $9775			beq 	_ESTASwitchFloat
.9770	20 ce 97	jsr $97ce			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.9773	38		sec				sec
.9774	60		rts				rts
.9775					_ESTASwitchFloat:
.9775	9c 07 04	stz $0407			stz 	DecimalCount 				; reset the count of digits - we divide by 10^n at the end.
.9778	e8		inx				inx 								; zero the decimal additive.
.9779	20 cd 9d	jsr $9dcd			jsr 	NSMSetZero
.977c	ca		dex				dex
.977d	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.977f	80 ae		bra $972f			bra 	_ENExitChange
.9781					_ESTADecimalState:
.9781	68		pla				pla 								; digit.
.9782	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 2nd decimal point.
.9784	f0 99		beq $971f			beq 	_ENFail
.9786	e8		inx				inx 								; put digit into fractional part of X+1
.9787	20 ce 97	jsr $97ce			jsr 	ESTAShiftDigitIntoMantissa
.978a	ca		dex				dex
.978b	ee 07 04	inc $0407			inc 	DecimalCount 				; bump the count of decimals
.978e	ad 07 04	lda $0407			lda 	DecimalCount 				; too many decimal digits.
.9791	c9 0b		cmp #$0b			cmp 	#11
.9793	f0 02		beq $9797			beq 	_ESTADSFail
.9795	38		sec				sec
.9796	60		rts				rts
.9797					_ESTADSFail:
.9797	4c 50 9f	jmp $9f50			jmp 	RangeError
.979a					_ENConstructFinal:
.979a	ad 07 04	lda $0407			lda 	DecimalCount 				; get decimal count
.979d	f0 2d		beq $97cc			beq 	_ENCFExit 					; no decimals
.979f	5a		phy				phy
.97a0	0a		asl a				asl 	a 							; x 4 and CLC
.97a1	0a		asl a				asl 	a
.97a2	6d 07 04	adc $0407			adc 	DecimalCount
.97a5	a8		tay				tay
.97a6	b9 0f 9f	lda $9f0f,y			lda 	DecimalScalarTable-5,y 		; copy decimal scalar to X+2
.97a9	95 5a		sta $5a,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.97ab	b9 10 9f	lda $9f10,y			lda 	DecimalScalarTable-5+1,y
.97ae	95 62		sta $62,x			sta 	NSMantissa1+2,x
.97b0	b9 11 9f	lda $9f11,y			lda 	DecimalScalarTable-5+2,y
.97b3	95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.97b5	b9 12 9f	lda $9f12,y			lda 	DecimalScalarTable-5+3,y
.97b8	95 72		sta $72,x			sta 	NSMantissa3+2,x
.97ba	b9 13 9f	lda $9f13,y			lda 	DecimalScalarTable-5+4,y
.97bd	95 7a		sta $7a,x			sta 	NSExponent+2,x
.97bf	a9 08		lda #$08			lda 	#NSTFloat
.97c1	95 52		sta $52,x			sta 	NSStatus+2,x
.97c3	7a		ply				ply
.97c4	e8		inx				inx 								; multiply decimal const by decimal scalar
.97c5	20 54 95	jsr $9554			jsr 	FloatMultiply
.97c8	ca		dex				dex
.97c9	20 0f 94	jsr $940f			jsr 	FloatAdd 					; add to integer part.
.97cc					_ENCFExit:
.97cc	18		clc				clc 								; reject the digit.
.97cd	60		rts				rts
.97ce					ESTAShiftDigitIntoMantissa:
.97ce	29 0f		and #$0f			and 	#15 						; save digit
.97d0	48		pha				pha
.97d1	b5 70		lda $70,x			lda 	NSMantissa3,x 				; push mantissa on stack
.97d3	48		pha				pha
.97d4	b5 68		lda $68,x			lda 	NSMantissa2,x
.97d6	48		pha				pha
.97d7	b5 60		lda $60,x			lda 	NSMantissa1,x
.97d9	48		pha				pha
.97da	b5 58		lda $58,x			lda 	NSMantissa0,x
.97dc	48		pha				pha
.97dd	20 dc 9d	jsr $9ddc			jsr 	NSMShiftLeft 				; x 2
.97e0	20 dc 9d	jsr $9ddc			jsr 	NSMShiftLeft 				; x 4
.97e3	18		clc				clc 								; pop mantissa and add
.97e4	68		pla				pla
.97e5	75 58		adc $58,x			adc 	NSMantissa0,x
.97e7	95 58		sta $58,x			sta 	NSMantissa0,x
.97e9	68		pla				pla
.97ea	75 60		adc $60,x			adc 	NSMantissa1,x
.97ec	95 60		sta $60,x			sta 	NSMantissa1,x
.97ee	68		pla				pla
.97ef	75 68		adc $68,x			adc 	NSMantissa2,x
.97f1	95 68		sta $68,x			sta 	NSMantissa2,x
.97f3	68		pla				pla
.97f4	75 70		adc $70,x			adc 	NSMantissa3,x
.97f6	95 70		sta $70,x			sta 	NSMantissa3,x 				; x 5
.97f8	20 dc 9d	jsr $9ddc			jsr 	NSMShiftLeft 				; x 10
.97fb	68		pla				pla 								; add digit
.97fc	18		clc				clc
.97fd	75 58		adc $58,x			adc 	NSMantissa0,x
.97ff	95 58		sta $58,x			sta 	NSMantissa0,x
.9801	90 0a		bcc $980d			bcc 	_ESTASDExit
.9803	f6 60		inc $60,x			inc 	NSMantissa1,x
.9805	d0 06		bne $980d			bne 	_ESTASDExit
.9807	f6 68		inc $68,x			inc 	NSMantissa2,x
.9809	d0 02		bne $980d			bne 	_ESTASDExit
.980b	f6 70		inc $70,x			inc 	NSMantissa3,x
.980d					_ESTASDExit:
.980d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/term.asm

.980e					EvaluateTerm:
.980e	b1 30		lda ($30),y			lda 	(codePtr),y
.9810	30 18		bmi $982a			bmi 	_ETCheckUnary 				; unary function ? (text ones)
.9812	c9 40		cmp #$40			cmp 	#$40 						; 40-7F => identifier reference
.9814	b0 6c		bcs $9882			bcs 	_ETVariable
.9816	c9 30		cmp #$30			cmp 	#'0' 						; is it a number
.9818	90 6b		bcc $9885			bcc 	_ETPuncUnary 				; if not it might be a punctuation unary.
.981a	c9 3a		cmp #$3a			cmp 	#'9'+1
.981c	b0 67		bcs $9885			bcs 	_ETPuncUnary
.981e	20 06 97	jsr $9706			jsr 	EncodeNumberStart 			; can't fail as it's 0-9 !
.9821					_ETNumber:
.9821	c8		iny				iny 								; keep encoding until we have the numbers
.9822	b1 30		lda ($30),y			lda 	(codePtr),y
.9824	20 09 97	jsr $9709			jsr 	EncodeNumberContinue
.9827	b0 f8		bcs $9821			bcs 	_ETNumber 					; go back if accepted.
.9829	60		rts				rts
.982a					_ETCheckUnary:
.982a	c9 ff		cmp #$ff			cmp 	#KWC_STRING 				; string token
.982c	f0 3f		beq $986d			beq 	_ETString
.982e	c9 fe		cmp #$fe			cmp 	#KWC_HEXCONST 				; hex constant.
.9830	f0 12		beq $9844			beq 	_ETHexConstant
.9832	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; check it actually is a unary function
.9834	90 0b		bcc $9841			bcc 	_ETSyntaxError
.9836	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1
.9838	b0 07		bcs $9841			bcs 	_ETSyntaxError
.983a	da		phx				phx 								; push X on the stack
.983b	0a		asl a				asl 	a 							; put vector x 2 into X
.983c	aa		tax				tax
.983d	c8		iny				iny 								; consume unary function token
.983e	7c 02 8c	jmp ($8c02,x)			jmp 	(VectorSet0,x) 				; and do it.
.9841					_ETSyntaxError:
.9841	4c 4b 9f	jmp $9f4b			jmp 	SyntaxError
.9844					_ETHexConstant:
.9844	c8		iny				iny 								; skip #
.9845	c8		iny				iny 								; skip count
.9846	20 cd 9d	jsr $9dcd			jsr 	NSMSetZero 					; clear result
.9849					_ETHLoop:
.9849	b1 30		lda ($30),y			lda 	(codePtr),y
.984b	c8		iny				iny 								; and consume
.984c	c9 00		cmp #$00			cmp 	#0 							; exit if zero
.984e	f0 1c		beq $986c			beq 	_ETHExit
.9850	48		pha				pha 								; save on stack.
.9851	20 dc 9d	jsr $9ddc			jsr 	NSMShiftLeft 				; x 2
.9854	20 dc 9d	jsr $9ddc			jsr 	NSMShiftLeft 				; x 4
.9857	20 dc 9d	jsr $9ddc			jsr 	NSMShiftLeft 				; x 8
.985a	20 dc 9d	jsr $9ddc			jsr 	NSMShiftLeft 				; x 16
.985d	68		pla				pla 								; ASCII
.985e	c9 41		cmp #$41			cmp 	#'A'
.9860	90 02		bcc $9864			bcc 	_ETHNotChar
.9862	e9 07		sbc #$07			sbc 	#7
.9864					_ETHNotChar:
.9864	29 0f		and #$0f			and 	#15 						; digit now
.9866	15 58		ora $58,x			ora 	NSMantissa0,x 				; put in LS Nibble
.9868	95 58		sta $58,x			sta 	NSMantissa0,x
.986a	80 dd		bra $9849			bra 	_ETHLoop 					; go round.
.986c					_ETHExit:
.986c	60		rts				rts
.986d					_ETString:
.986d	c8		iny				iny 								; look at length
.986e	b1 30		lda ($30),y			lda 	(codePtr),y
.9870	48		pha				pha
.9871	c8		iny				iny 								; first character
.9872	20 28 a5	jsr $a528			jsr 	MemoryInline 				; put address of string at (code-Ptr),y on stack
.9875	68		pla				pla 								; restore count and save
.9876	85 36		sta $36				sta 	zTemp0
.9878	98		tya				tya 								; add length to Y to skip it.
.9879	18		clc				clc
.987a	65 36		adc $36				adc 	zTemp0
.987c	a8		tay				tay
.987d	a9 10		lda #$10			lda 	#NSTString 					; mark as string
.987f	95 50		sta $50,x			sta 	NSStatus,x
.9881	60		rts				rts
.9882					_ETVariable:
.9882	4c d7 98	jmp $98d7			jmp 	VariableHandler
.9885					_ETPuncUnary:
.9885	c8		iny				iny 								; consume the unary character
.9886	c9 2d		cmp #$2d			cmp 	#KWD_MINUS 					; unary minus
.9888	f0 2b		beq $98b5			beq 	_ETUnaryNegate
.988a	c9 10		cmp #$10			cmp 	#KWD_AT 					; @ reference -> constant
.988c	f0 36		beq $98c4			beq 	_ETDereference
.988e	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; parenthesis
.9890	f0 3e		beq $98d0			beq 	_ETParenthesis
.9892	64 36		stz $36				stz 	zTemp0 						; zTemp0 is the indirection level.
.9894	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; byte indirection (0) ?
.9896	f0 06		beq $989e			beq 	_ETIndirection
.9898	e6 36		inc $36				inc 	zTemp0
.989a	c9 21		cmp #$21			cmp 	#KWD_PLING					; word indirection (1) \
.989c	d0 a3		bne $9841			bne 	_ETSyntaxError
.989e					_ETIndirection:
.989e	a5 36		lda $36				lda 	zTemp0 						; push indirection amount (0-1) => (1-2) on the stack
.98a0	1a		inc a				inc 	a
.98a1	48		pha				pha
.98a2	20 0e 98	jsr $980e			jsr 	EvaluateTerm				; evaluate the term
.98a5	20 87 96	jsr $9687			jsr 	Dereference 				; dereference it.
.98a8	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a +ve integer.
.98aa	d0 06		bne $98b2			bne 	_ETTypeMismatch
.98ac	68		pla				pla 								; indirection 1-2
.98ad	09 20		ora #$20			ora 	#NSBIsReference 			; make it a reference.
.98af	95 50		sta $50,x			sta 	NSStatus,x
.98b1	60		rts				rts
.98b2					_ETTypeMismatch:
.98b2	4c 55 9f	jmp $9f55			jmp 	TypeError
.98b5					_ETUnaryNegate:
.98b5	20 0e 98	jsr $980e			jsr 	EvaluateTerm				; evaluate the term
.98b8	20 87 96	jsr $9687			jsr 	Dereference 				; dereference it.
.98bb	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a number
.98bd	29 10		and #$10			and 	#NSTString
.98bf	d0 f1		bne $98b2			bne 	_ETTypeMismatch
.98c1	4c 8f 9d	jmp $9d8f			jmp 	NSMNegate  					; just toggles the sign bit.
.98c4					_ETDereference:
.98c4	20 0e 98	jsr $980e			jsr 	EvaluateTerm				; evaluate the term
.98c7	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a reference
.98c9	29 20		and #$20			and 	#NSBIsReference
.98cb	f0 e5		beq $98b2			beq 	_ETTypeMismatch
.98cd	74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer address
.98cf	60		rts				rts
.98d0					_ETParenthesis:
.98d0	20 c4 93	jsr $93c4			jsr 	EvaluateExpression 			; evaluate here, from lowest precedence
.98d3	20 a7 8e	jsr $8ea7			jsr 	CheckRightBracket 			; check for )
.98d6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/variable.asm

.98d7					VariableHandler:
.98d7	b1 30		lda ($30),y			lda 	(codePtr),y
.98d9	18		clc				clc
.98da	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.98dc	85 37		sta $37				sta 	zTemp0+1
.98de	c8		iny				iny
.98df	b1 30		lda ($30),y			lda 	(codePtr),y
.98e1	85 36		sta $36				sta 	zTemp0
.98e3	c8		iny				iny
.98e4	18		clc				clc									; copy variable address+3 to mantissa
.98e5	69 03		adc #$03			adc 	#3 							; this is the address of the data.
.98e7	95 58		sta $58,x			sta 	NSMantissa0,x
.98e9	a5 37		lda $37				lda 	zTemp0+1
.98eb	69 00		adc #$00			adc 	#0
.98ed	95 60		sta $60,x			sta 	NSMantissa1,x
.98ef	74 68		stz $68,x			stz 	NSMantissa2,x
.98f1	74 70		stz $70,x			stz 	NSMantissa3,x
.98f3	74 78		stz $78,x			stz 	NSExponent,x
.98f5	5a		phy				phy
.98f6	a0 02		ldy #$02			ldy 	#2 							; read type
.98f8	b1 36		lda ($36),y			lda 	(zTemp0),y
.98fa	7a		ply				ply
.98fb	29 1c		and #$1c			and 	#NSBTypeMask+NSBIsArray 	; get type information
.98fd	09 20		ora #$20			ora 	#NSBIsReference 			; make a reference.
.98ff	95 50		sta $50,x			sta 	NSStatus,x
.9901	29 04		and #$04			and 	#NSBIsArray
.9903	d0 01		bne $9906			bne 	_VHArray
.9905	60		rts				rts
.9906					_VHArray:
.9906	e8		inx				inx
.9907	20 68 9d	jsr $9d68			jsr 	Evaluate8BitInteger 		; get the 1st index.
.990a	a9 ff		lda #$ff			lda 	#$FF 						; set Status of X+2 to a duff value so we know if we picked it up.
.990c	95 51		sta $51,x			sta 	NSStatus+1,x
.990e	b1 30		lda ($30),y			lda 	(codePtr),y
.9910	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.9912	d0 06		bne $991a			bne 	_VHNoSecondIndex
.9914	c8		iny				iny 								; skip the comma
.9915	e8		inx				inx
.9916	20 68 9d	jsr $9d68			jsr 	Evaluate8BitInteger 		; get the 2nd index.
.9919	ca		dex				dex
.991a					_VHNoSecondIndex:
.991a	ca		dex				dex 								; set X back.
.991b	20 a7 8e	jsr $8ea7			jsr 	CheckRightBracket 			; and check the right bracket.
.991e	5a		phy				phy 								; save position
.991f	a0 02		ldy #$02			ldy 	#2 							; check first index is not-zero, e.g. array defined
.9921	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9923	f0 60		beq $9985			beq 	_VHBadIndex
.9925	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy record address to zaTemp
.9927	85 3e		sta $3e				sta 	zaTemp
.9929	b5 60		lda $60,x			lda 	NSMantissa1,x
.992b	85 3f		sta $3f				sta 	zaTemp+1
.992d	a0 03		ldy #$03			ldy 	#3 							; get the second index - which is 0 if there is one index.
.992f	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9931	f0 02		beq $9935			beq 	_VHHas2Mask
.9933	a9 ff		lda #$ff			lda 	#$FF
.9935					_VHHas2Mask:
.9935	d5 52		cmp $52,x			cmp 	NSStatus+2,x 				; so if they are the same there are the wrong number of indices
.9937	f0 4c		beq $9985			beq 	_VHBadIndex
.9939	0a		asl a				asl 	a 							; carry will be set if a second index
.993a	90 08		bcc $9944			bcc 	_VHCheckFirstIndex
.993c	a0 03		ldy #$03			ldy 	#3 			 				; check the 2nd size >= 2nd index
.993e	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9940	d5 5a		cmp $5a,x			cmp 	NSMantissa0+2,x
.9942	90 41		bcc $9985			bcc 	_VHBadIndex
.9944					_VHCheckFirstIndex:
.9944	a0 02		ldy #$02			ldy 	#2 			 				; check the 2nd size >= 2nd index
.9946	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9948	d5 59		cmp $59,x			cmp 	NSMantissa0+1,x
.994a	90 39		bcc $9985			bcc 	_VHBadIndex
.994c	64 36		stz $36				stz 	zTemp0 						; clear zTemp0 (if 1 index)
.994e	64 37		stz $37				stz 	zTemp0+1
.9950	b5 52		lda $52,x			lda 	NSStatus+2,x 				; if only one index provided, don't need to multiply
.9952	30 0e		bmi $9962			bmi 	_VHNoMultiply
.9954	da		phx				phx
.9955	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; get 2nd index on stack
.9957	48		pha				pha
.9958	a0 02		ldy #$02			ldy 	#2 							; get 1st size in A
.995a	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.995c	1a		inc a				inc 	a 							; add 1 for zero base
.995d	fa		plx				plx
.995e	20 78 9d	jsr $9d78			jsr 	Multiply8x8 				; calculate -> Z0
.9961	fa		plx				plx
.9962					_VHNoMultiply:
.9962	18		clc				clc
.9963	a5 36		lda $36				lda 	zTemp0
.9965	75 59		adc $59,x			adc 	NSMantissa0+1,x
.9967	85 36		sta $36				sta 	zTemp0
.9969	a5 37		lda $37				lda 	zTemp0+1
.996b	69 00		adc #$00			adc 	#0
.996d	85 37		sta $37				sta 	zTemp0+1
.996f	b5 50		lda $50,x			lda 	NSStatus,x
.9971	20 11 85	jsr $8511			jsr 	ScaleByBaseType
.9974	18		clc				clc
.9975	b2 3e		lda ($3e)			lda 	(zaTemp)
.9977	65 36		adc $36				adc 	zTemp0
.9979	95 58		sta $58,x			sta 	NSMantissa0,x
.997b	a0 01		ldy #$01			ldy 	#1
.997d	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.997f	65 37		adc $37				adc 	zTemp0+1
.9981	95 60		sta $60,x			sta 	NSMantissa1,x
.9983	7a		ply				ply 								; restore position
.9984	60		rts				rts
.9985					_VHBadIndex:
.9985	a9 17		lda #$17		lda	#23
.9987	4c c0 8e	jmp $8ec0		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/abs.asm

.998a					AbsUnary:
.998a	fa		plx				plx 								; restore stack pos
.998b	20 1b 9d	jsr $9d1b			jsr 	EvaluateNumber 				; get a float or int
.998e	20 a7 8e	jsr $8ea7			jsr 	CheckRightBracket
.9991	b5 50		lda $50,x			lda 	NSStatus,x 					; clear the sign bit
.9993	29 7f		and #$7f			and 	#$7F
.9995	95 50		sta $50,x			sta 	NSStatus,x
.9997	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/alloc.asm

.9998					AllocUnary:
.9998	fa		plx				plx 								; restore stack pos
.9999	20 4d 9d	jsr $9d4d			jsr 	Evaluate16BitInteger		; get bytes required.
.999c	20 a7 8e	jsr $8ea7			jsr 	CheckRightBracket
.999f	da		phx				phx 								; save X/Y
.99a0	5a		phy				phy
.99a1	8a		txa				txa 								; copy X into Y
.99a2	a8		tay				tay
.99a3	b9 60 00	lda $0060,y			lda		NSMantissa1,y 				; get size into XA
.99a6	aa		tax				tax
.99a7	b9 58 00	lda $0058,y			lda 	NSMantissa0,y
.99aa	20 b7 99	jsr $99b7			jsr 	AllocateXABytes 			; allocate memory
.99ad	99 58 00	sta $0058,y			sta 	NSMantissa0,y 				; write address out.
.99b0	8a		txa				txa 	 							; typing is 16 bit integer.
.99b1	99 60 00	sta $0060,y			sta 	NSMantissa1,y
.99b4	7a		ply				ply
.99b5	fa		plx				plx
.99b6	60		rts				rts
.99b7					AllocateXABytes:
.99b7	5a		phy				phy
.99b8	ac 0c 04	ldy $040c			ldy 	lowMemPtr 					; push current address on stack and to zTemp0
.99bb	84 36		sty $36				sty 	zTemp0
.99bd	5a		phy				phy
.99be	ac 0d 04	ldy $040d			ldy 	lowMemPtr+1
.99c1	84 37		sty $37				sty 	zTemp0+1
.99c3	5a		phy				phy
.99c4	18		clc				clc 								; add to low memory pointer
.99c5	6d 0c 04	adc $040c			adc 	lowMemPtr
.99c8	8d 0c 04	sta $040c			sta 	lowMemPtr
.99cb	8a		txa				txa
.99cc	6d 0d 04	adc $040d			adc 	lowMemPtr+1
.99cf	8d 0d 04	sta $040d			sta 	lowMemPtr+1
.99d2	b0 2f		bcs $9a03			bcs 	CISSMemory
.99d4	20 f5 99	jsr $99f5			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.99d7					_ClearMemory:
.99d7	ad 0c 04	lda $040c			lda 	lowMemPtr 					; cleared all memory allocated
.99da	c5 36		cmp $36				cmp 	zTemp0
.99dc	d0 07		bne $99e5			bne 	_CMClearNext
.99de	ad 0d 04	lda $040d			lda 	lowMemPtr+1
.99e1	c5 37		cmp $37				cmp 	zTemp0+1
.99e3	f0 0c		beq $99f1			beq 	_CMExit
.99e5					_CMClearNext:
.99e5	a9 00		lda #$00			lda 	#0 							; clear byte, advance to next.
.99e7	92 36		sta ($36)			sta 	(zTemp0)
.99e9	e6 36		inc $36				inc 	zTemp0
.99eb	d0 ea		bne $99d7			bne 	_ClearMemory
.99ed	e6 37		inc $37				inc		zTemp0+1
.99ef	80 e6		bra $99d7			bra 	_ClearMemory
.99f1					_CMExit:
.99f1	fa		plx				plx
.99f2	68		pla				pla
.99f3	7a		ply				ply
.99f4	60		rts				rts
.99f5					CheckIdentifierStringSpace:
.99f5	48		pha				pha
.99f6	ad 0d 04	lda $040d			lda 	lowMemPtr+1 				; get low memory pointer
.99f9	18		clc				clc
.99fa	69 02		adc #$02			adc 	#2 							; need at least 2 256 byte pages
.99fc	cd 0f 04	cmp $040f			cmp 	StringMemory+1 				; is it >= StringMemory
.99ff	b0 02		bcs $9a03			bcs 	CISSMemory
.9a01	68		pla				pla
.9a02	60		rts				rts
.9a03					CISSMemory:
.9a03	a9 06		lda #$06		lda	#6
.9a05	4c c0 8e	jmp $8ec0		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/asc.asm

.9a08					AscUnary:
.9a08	fa		plx				plx 								; restore stack pos
.9a09	20 25 9d	jsr $9d25			jsr 	EvaluateString 				; get a string
.9a0c	b2 36		lda ($36)			lda 	(zTemp0)					; get/return first character
.9a0e	20 cf 9d	jsr $9dcf			jsr 	NSMSetByte 					; ASC("") will return zero.
.9a11	20 a7 8e	jsr $8ea7			jsr 	CheckRightBracket
.9a14	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/frac.asm

.9a15					FracUnary:
.9a15	fa		plx				plx 								; restore stack pos
.9a16	20 1b 9d	jsr $9d1b			jsr 	EvaluateNumber 				; get a float or int
.9a19	20 a7 8e	jsr $8ea7			jsr 	CheckRightBracket
.9a1c	b5 50		lda $50,x			lda 	NSStatus,x
.9a1e	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9a20	f0 04		beq $9a26			beq 	_IUZero
.9a22	20 d5 94	jsr $94d5			jsr 	FloatFractionalPart 		; if so, get the fractional part.
.9a25	60		rts				rts
.9a26					_IUZero:
.9a26	20 cd 9d	jsr $9dcd			jsr 	NSMSetZero
.9a29	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/int.asm

.9a2a					IntUnary:
.9a2a	fa		plx				plx 								; restore stack pos
.9a2b	20 1b 9d	jsr $9d1b			jsr 	EvaluateNumber 				; get a float or int
.9a2e	20 a7 8e	jsr $8ea7			jsr 	CheckRightBracket
.9a31	b5 50		lda $50,x			lda 	NSStatus,x
.9a33	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9a35	f0 03		beq $9a3a			beq 	_IUExit
.9a37	20 2d 95	jsr $952d			jsr 	FloatIntegerPart 			; if it is get the integer part.
.9a3a					_IUExit:
.9a3a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/len.asm

.9a3b					LenUnary:
.9a3b	fa		plx				plx 								; restore stack pos
.9a3c	20 25 9d	jsr $9d25			jsr 	EvaluateString 				; get a string
.9a3f	5a		phy				phy
.9a40	a0 00		ldy #$00			ldy 	#0 							; find length
.9a42					_LenFind:
.9a42	b1 36		lda ($36),y			lda 	(zTemp0),y 					; look for trailing NULL.
.9a44	f0 06		beq $9a4c			beq 	_LenExit
.9a46	c8		iny				iny
.9a47	d0 f9		bne $9a42			bne 	_LenFind
.9a49	4c 50 9f	jmp $9f50			jmp 	RangeError 					; string > 255 - no trailing NULL.
.9a4c					_LenExit:
.9a4c	98		tya				tya		 							; return length
.9a4d	20 cf 9d	jsr $9dcf			jsr 	NSMSetByte
.9a50	7a		ply				ply
.9a51	20 a7 8e	jsr $8ea7			jsr 	CheckRightBracket
.9a54	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/minmax.asm

.9a55					Unary_Min:
.9a55	a9 01		lda #$01			lda 	#1
.9a57	80 02		bra $9a5b			bra 	UnaryMinMaxMain
.9a59					Unary_Max:
.9a59	a9 ff		lda #$ff			lda 	#$FF 						; value from comparator to cause a write
.9a5b					UnaryMinMaxMain:
.9a5b	fa		plx				plx 								; get index on number stack
.9a5c	48		pha				pha 								; save comparator
.9a5d	20 12 9d	jsr $9d12			jsr 	EvaluateValue 				; get the first value.
.9a60					_UMMMLoop:
.9a60	b1 30		lda ($30),y			lda 	(codePtr),y
.9a62	c9 29		cmp #$29			cmp 	#KWD_RPAREN 				; if right bracket then done.
.9a64	f0 22		beq $9a88			beq 	_UMMMDone
.9a66	20 af 8e	jsr $8eaf			jsr 	CheckComma 					; must be a comma
.9a69	e8		inx				inx
.9a6a	20 12 9d	jsr $9d12			jsr 	EvaluateValue
.9a6d	ca		dex				dex
.9a6e	20 b0 9d	jsr $9db0			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] (Compare is destructive)
.9a71	e8		inx				inx
.9a72	20 b0 9d	jsr $9db0			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2], original
.9a75	e8		inx				inx
.9a76	20 77 8f	jsr $8f77			jsr 	CompareBaseCode 			; part of > = < etc. code, returns 255,0 or 1
.9a79	ca		dex				dex
.9a7a	ca		dex				dex
.9a7b	85 36		sta $36				sta 	zTemp0 						; save required result
.9a7d	68		pla				pla 								; get and save comparator
.9a7e	48		pha				pha
.9a7f	c5 36		cmp $36				cmp 	zTemp0 						; if the comparator
.9a81	d0 dd		bne $9a60			bne 	_UMMMLoop
.9a83	20 8b 9a	jsr $9a8b			jsr 	ExpCopyAboveDown 			; copy next up slot down
.9a86	80 d8		bra $9a60			bra 	_UMMMLoop
.9a88					_UMMMDone:
.9a88	68		pla				pla 								; throw the comparator
.9a89	c8		iny				iny 								; skip )
.9a8a	60		rts				rts
.9a8b					ExpCopyAboveDown:
.9a8b	b5 51		lda $51,x			lda 	NSStatus+1,x
.9a8d	95 50		sta $50,x			sta 	NSStatus,x
.9a8f	b5 79		lda $79,x			lda 	NSExponent+1,x
.9a91	95 78		sta $78,x			sta 	NSExponent,x
.9a93	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9a95	95 58		sta $58,x			sta 	NSMantissa0,x
.9a97	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9a99	95 60		sta $60,x			sta 	NSMantissa1,x
.9a9b	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.9a9d	95 68		sta $68,x			sta 	NSMantissa2,x
.9a9f	b5 71		lda $71,x			lda 	NSMantissa3+1,x
.9aa1	95 70		sta $70,x			sta 	NSMantissa3,x
.9aa3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/not.asm

.9aa4					Unary_Not:
.9aa4	fa		plx				plx
.9aa5	20 3a 9d	jsr $9d3a			jsr 	EvaluateInteger 			; get integer
.9aa8	20 a7 8e	jsr $8ea7			jsr 	CheckRightBracket
.9aab	20 ef 9d	jsr $9def			jsr 	NSMIsZero 					; zero mantissa ?
.9aae	f0 04		beq $9ab4			beq 	_NotZero
.9ab0	20 cd 9d	jsr $9dcd			jsr 	NSMSetZero
.9ab3	60		rts				rts
.9ab4					_NotZero:
.9ab4	4c 2d 8f	jmp $8f2d			jmp 	ReturnTrue

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/rnd.asm

.9ab7					Unary_Random:
.9ab7	fa		plx				plx
.9ab8	20 29 9b	jsr $9b29			jsr 	Random32Bit 				; get a random number
.9abb	20 12 9b	jsr $9b12			jsr 	URCopyToMantissa  			; put in mantissa
.9abe	b1 30		lda ($30),y			lda 	(codePtr),y
.9ac0	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.9ac2	f0 08		beq $9acc			beq 	_URNoModulus 				; then we return a random 30 bit number.
.9ac4	e8		inx				inx
.9ac5	20 4d 9d	jsr $9d4d			jsr 	Evaluate16BitInteger 		; put modulus value in +1
.9ac8	ca		dex				dex
.9ac9	20 7f 90	jsr $907f			jsr 	IntegerModulusNoCheck 		; calculate modulus, so now 0 .. n-1
.9acc					_URNoModulus:
.9acc	74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer positive
.9ace	74 78		stz $78,x			stz 	NSExponent,x
.9ad0	20 a7 8e	jsr $8ea7			jsr 	CheckRightBracket
.9ad3	60		rts				rts
.9ad4					Unary_Rnd:
.9ad4	fa		plx				plx
.9ad5	20 1b 9d	jsr $9d1b			jsr 	EvaluateNumber 				; number to use.
.9ad8	20 a7 8e	jsr $8ea7			jsr 	CheckRightBracket 			; closing bracket
.9adb	20 ef 9d	jsr $9def			jsr 	NSMIsZero 					; if zero, then don't generate a new number
.9ade	f0 26		beq $9b06			beq 	_URCopySeed
.9ae0	b5 50		lda $50,x			lda 	NSStatus,x 					; if -ve, then seed using parameter
.9ae2	10 1f		bpl $9b03			bpl 	_URDontSeed
.9ae4	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy - value to seed butchering it.
.9ae6	49 17		eor #$17			eor 	#$17
.9ae8	8d 08 04	sta $0408			sta 	RandomSeed+0
.9aeb	b5 60		lda $60,x			lda 	NSMantissa1,x
.9aed	49 a5		eor #$a5			eor 	#$A5
.9aef	8d 09 04	sta $0409			sta 	RandomSeed+1
.9af2	b5 68		lda $68,x			lda 	NSMantissa2,x
.9af4	49 c2		eor #$c2			eor 	#$C2
.9af6	8d 0a 04	sta $040a			sta 	RandomSeed+2
.9af9	b5 70		lda $70,x			lda 	NSMantissa3,x
.9afb	49 9d		eor #$9d			eor 	#$9D
.9afd	8d 0b 04	sta $040b			sta 	RandomSeed+3
.9b00	20 29 9b	jsr $9b29			jsr 	Random32Bit
.9b03					_URDontSeed:
.9b03	20 29 9b	jsr $9b29			jsr 	Random32Bit 				; generate a number
.9b06					_URCopySeed:
.9b06	20 12 9b	jsr $9b12			jsr 	URCopyToMantissa 			; copy into mantissa
.9b09	a9 e2		lda #$e2			lda 	#-30 						; force into 0-1 range
.9b0b	95 78		sta $78,x			sta 	NSExponent,x
.9b0d	a9 08		lda #$08			lda 	#NSTFloat
.9b0f	95 50		sta $50,x			sta 	NSStatus,x 					; positive float
.9b11	60		rts				rts
.9b12					URCopyToMantissa:
.9b12	ad 08 04	lda $0408			lda 	RandomSeed+0
.9b15	95 58		sta $58,x			sta 	NSMantissa0,x
.9b17	ad 09 04	lda $0409			lda 	RandomSeed+1
.9b1a	95 60		sta $60,x			sta 	NSMantissa1,x
.9b1c	ad 0a 04	lda $040a			lda 	RandomSeed+2
.9b1f	95 68		sta $68,x			sta 	NSMantissa2,x
.9b21	ad 0b 04	lda $040b			lda 	RandomSeed+3
.9b24	29 3f		and #$3f			and 	#$3F 						; make legal mantissa
.9b26	95 70		sta $70,x			sta 	NSMantissa3,x
.9b28	60		rts				rts
.9b29					Random32Bit:
.9b29	5a		phy				phy
.9b2a	a0 07		ldy #$07			ldy 	#7 							; do it 7 times
.9b2c	ad 08 04	lda $0408			lda 	RandomSeed+0 				; check the seed isn't zero
.9b2f	d0 03		bne $9b34			bne 	_Random1
.9b31	a8		tay				tay 								; if so do it 256 times
.9b32	a9 aa		lda #$aa			lda		#$AA 						; and use this to seed the seed....
.9b34					_Random1:
.9b34	0a		asl a				asl 	a 							; LSFR RNG
.9b35	2e 09 04	rol $0409			rol 	RandomSeed+1
.9b38	2e 0a 04	rol $040a			rol 	RandomSeed+2
.9b3b	2e 0b 04	rol $040b			rol 	RandomSeed+3
.9b3e	90 02		bcc $9b42			bcc 	_Random2
.9b40	49 c5		eor #$c5			eor 	#$C5
.9b42					_Random2:
.9b42	88		dey				dey
.9b43	d0 ef		bne $9b34			bne 	_Random1
.9b45	8d 08 04	sta $0408			sta 	RandomSeed+0
.9b48	7a		ply				ply
.9b49	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/sgn.asm

.9b4a					SgnUnary:
.9b4a	fa		plx				plx 								; restore stack pos
.9b4b	20 1b 9d	jsr $9d1b			jsr 	EvaluateNumber 				; get a float or int
.9b4e	20 a7 8e	jsr $8ea7			jsr 	CheckRightBracket
.9b51	20 ef 9d	jsr $9def			jsr 	NSMIsZero 					; if zero
.9b54	f0 0e		beq $9b64			beq 	_SGZero  					; return Int Zero
.9b56	b5 50		lda $50,x			lda 	NSStatus,x 					; get status w/sign
.9b58	48		pha				pha
.9b59	a9 01		lda #$01			lda 	#1 							; set to 1
.9b5b	20 cf 9d	jsr $9dcf			jsr 	NSMSetByte
.9b5e	68		pla				pla
.9b5f	29 80		and #$80			and		#$80 						; copy the sign byte out
.9b61	95 50		sta $50,x			sta 	NSStatus,x  				; so it will be -1 or 1
.9b63	60		rts				rts
.9b64	20 cd 9d	jsr $9dcd	_SGZero:jsr 	NSMSetZero
.9b67	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/val.asm

.9b68					ValUnary:
.9b68	fa		plx				plx 								; restore stack pos
.9b69	20 7e 9b	jsr $9b7e			jsr 	ValMainCode 				; do the main val() code
.9b6c	b0 01		bcs $9b6f			bcs 	_VUError 					; couldn't convert
.9b6e	60		rts				rts
.9b6f					_VUError:
.9b6f	4c 55 9f	jmp $9f55			jmp 	TypeError
.9b72					IsValUnary:
.9b72	fa		plx				plx 								; restore stack pos
.9b73	20 7e 9b	jsr $9b7e			jsr 	ValMainCode 				; do the main val() code
.9b76	b0 03		bcs $9b7b			bcs 	_VUBad
.9b78	4c 2d 8f	jmp $8f2d			jmp 	ReturnTrue
.9b7b					_VUBad:
.9b7b	4c 38 8f	jmp $8f38			jmp 	ReturnFalse
.9b7e					ValMainCode:
.9b7e	20 25 9d	jsr $9d25			jsr 	EvaluateString 				; get a string
.9b81	20 a7 8e	jsr $8ea7			jsr 	CheckRightBracket 			; check right bracket present
.9b84					ValEvaluateZTemp0:
.9b84	5a		phy				phy
.9b85	b2 36		lda ($36)			lda 	(zTemp0) 					; check not empty string
.9b87	f0 17		beq $9ba0			beq 	_VMCFail2
.9b89	a0 ff		ldy #$ff			ldy 	#$FF 						; start position
.9b8b	48		pha				pha 								; save first character
.9b8c	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.9b8e	d0 01		bne $9b91			bne 	_VMCStart
.9b90	c8		iny				iny 								; skip over -
.9b91					_VMCStart:
.9b91	38		sec				sec 								; initialise first time round.
.9b92					_VMCNext:
.9b92	c8		iny				iny 								; pre-increment
.9b93	b1 36		lda ($36),y			lda 	(zTemp0),y 					; next character = EOS ?
.9b95	f0 0c		beq $9ba3			beq 	_VMCSuccess 				; successful.
.9b97	20 0a 97	jsr $970a			jsr 	EncodeNumber 				; send it to the number-builder
.9b9a	90 03		bcc $9b9f			bcc 	_VMCFail 					; if failed, give up.
.9b9c	18		clc				clc 								; next time round, countinue
.9b9d	80 f3		bra $9b92			bra 	_VMCNext
.9b9f					_VMCFail:
.9b9f	68		pla				pla
.9ba0					_VMCFail2:
.9ba0	7a		ply				ply
.9ba1	38		sec				sec
.9ba2	60		rts				rts
.9ba3					_VMCSuccess:
.9ba3	a9 00		lda #$00			lda 	#0 							; construct final
.9ba5	20 0a 97	jsr $970a			jsr 	EncodeNumber 				; by sending a duff value.
.9ba8	68		pla				pla 								; if it was -ve
.9ba9	c9 2d		cmp #$2d			cmp 	#"-"
.9bab	d0 03		bne $9bb0			bne 	_VMCNotNegative
.9bad	20 8f 9d	jsr $9d8f			jsr		NSMNegate 					; negate it.
.9bb0					_VMCNotNegative:
.9bb0	7a		ply				ply
.9bb1	18		clc				clc
.9bb2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/chr.asm

.9bb3					ChrUnary:
.9bb3	fa		plx				plx 								; restore stack pos
.9bb4	20 68 9d	jsr $9d68			jsr 	Evaluate8BitInteger			; get value (chr$(0) returns an empty string)
.9bb7	48		pha				pha
.9bb8	20 a7 8e	jsr $8ea7			jsr 	CheckRightBracket
.9bbb	a9 01		lda #$01			lda 	#1 							; allocate space for one char
.9bbd	20 ff a6	jsr $a6ff			jsr 	StringTempAllocate
.9bc0	68		pla				pla 								; write number to it
.9bc1	20 38 a7	jsr $a738			jsr 	StringTempWrite
.9bc4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/spc.asm

.9bc5					SpcUnary:
.9bc5	fa		plx				plx 								; restore stack pos
.9bc6	20 68 9d	jsr $9d68			jsr 	Evaluate8BitInteger			; get value
.9bc9	5a		phy				phy
.9bca	48		pha				pha 								; save count
.9bcb	20 ff a6	jsr $a6ff			jsr 	StringTempAllocate
.9bce	7a		ply				ply 								; to do count in Y
.9bcf					_SpcLoop:
.9bcf	c0 00		cpy #$00			cpy 	#0 							; copy Y spaces in.
.9bd1	f0 08		beq $9bdb			beq 	_SpcExit
.9bd3	a9 20		lda #$20			lda 	#32
.9bd5	20 38 a7	jsr $a738			jsr 	StringTempWrite
.9bd8	88		dey				dey
.9bd9	80 f4		bra $9bcf			bra 	_SPCLoop
.9bdb					_SpcExit:
.9bdb	7a		ply				ply
.9bdc	20 a7 8e	jsr $8ea7			jsr 	CheckRightBracket
.9bdf	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/str.asm

.9be0					Unary_Str:
.9be0	fa		plx				plx
.9be1	20 1b 9d	jsr $9d1b			jsr 	EvaluateNumber  			; get number
.9be4	20 a7 8e	jsr $8ea7			jsr 	CheckRightBracket 			; closing bracket
.9be7	a9 05		lda #$05			lda 	#5 							; maximum decimals, from Basic816
.9be9	20 02 9c	jsr $9c02			jsr 	ConvertNumberToString 		; do the conversion.
.9bec	a9 21		lda #$21			lda		#33 						; create buffer
.9bee	20 ff a6	jsr $a6ff			jsr 	StringTempAllocate 			; allocate memory
.9bf1	da		phx				phx  								; copy the converted string into the buffer.
.9bf2	a2 00		ldx #$00			ldx 	#0
.9bf4					_USCopy:
.9bf4	bd 9d 05	lda $059d,x			lda 	DecimalBuffer,x
.9bf7	20 38 a7	jsr $a738			jsr 	StringTempWrite
.9bfa	e8		inx				inx
.9bfb	bd 9d 05	lda $059d,x			lda 	DecimalBuffer,x
.9bfe	d0 f4		bne $9bf4			bne 	_USCopy
.9c00	fa		plx				plx
.9c01	60		rts				rts
.9c02					ConvertNumberToString:
.9c02	5a		phy				phy 								; save code position
.9c03	8d 14 04	sta $0414			sta 	DecimalPlaces	 			; save number of DPs.
.9c06	9c 15 04	stz $0415			stz 	dbOffset 					; offset into decimal buffer = start.
.9c09	b5 50		lda $50,x			lda 	NSStatus,x  				; is it -ve.
.9c0b	10 09		bpl $9c16			bpl 	_CNTSNotNegative
.9c0d	29 7f		and #$7f			and 	#$7F 						; make +ve
.9c0f	95 50		sta $50,x			sta 	NSStatus,x
.9c11	a9 2d		lda #$2d			lda 	#"-"
.9c13	20 77 9c	jsr $9c77			jsr 	WriteDecimalBuffer
.9c16					_CNTSNotNegative:
.9c16	b5 78		lda $78,x			lda 	NSExponent,x 				; check if decimal
.9c18	f0 12		beq $9c2c			beq 	_CNTSNotFloat
.9c1a	e8		inx				inx 								; round up so we don't get too many 6.999999
.9c1b	a9 01		lda #$01			lda 	#1
.9c1d	20 cf 9d	jsr $9dcf			jsr 	NSMSetByte
.9c20	ca		dex				dex
.9c21	b5 78		lda $78,x			lda		NSExponent,x
.9c23	95 79		sta $79,x			sta 	NSExponent+1,x
.9c25	a9 08		lda #$08			lda 	#NSTFloat
.9c27	95 51		sta $51,x			sta 	NSStatus+1,x
.9c29	20 0f 94	jsr $940f			jsr 	FloatAdd
.9c2c					_CNTSNotFloat:
.9c2c	20 59 9c	jsr $9c59			jsr 	MakePlusTwoString 			; do the integer part.
.9c2f	20 d5 94	jsr $94d5			jsr 	FloatFractionalPart 		; get the fractional part
.9c32	20 86 95	jsr $9586			jsr 	NSNormalise					; normalise , exit if zero
.9c35	f0 20		beq $9c57			beq 	_CNTSExit
.9c37	a9 2e		lda #$2e			lda 	#"."
.9c39	20 77 9c	jsr $9c77			jsr 	WriteDecimalBuffer 			; write decimal place
.9c3c					_CNTSDecimal:
.9c3c	ce 14 04	dec $0414			dec 	DecimalPlaces 				; done all the decimals
.9c3f	30 16		bmi $9c57			bmi 	_CNTSExit
.9c41	e8		inx				inx 								; x 10.0
.9c42	a9 0a		lda #$0a			lda 	#10
.9c44	20 cf 9d	jsr $9dcf			jsr 	NSMSetByte
.9c47	a9 08		lda #$08			lda 	#NSTFloat
.9c49	95 50		sta $50,x			sta 	NSStatus,x
.9c4b	ca		dex				dex
.9c4c	20 54 95	jsr $9554			jsr 	FloatMultiply
.9c4f	20 59 9c	jsr $9c59			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.9c52	20 d5 94	jsr $94d5			jsr 	FloatFractionalPart 		; get the fractional part
.9c55	80 e5		bra $9c3c			bra 	_CNTSDecimal 				; keep going.
.9c57					_CNTSExit:
.9c57	7a		ply				ply
.9c58	60		rts				rts
.9c59					MakePlusTwoString:
.9c59	da		phx				phx
.9c5a	20 b0 9d	jsr $9db0			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.9c5d	e8		inx				inx 								; access it
.9c5e	e8		inx				inx
.9c5f	20 2d 95	jsr $952d			jsr 	FloatIntegerPart 			; make it an integer
.9c62	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.9c64	20 3f 93	jsr $933f			jsr 	ConvertInt32
.9c67	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.9c69					_MPTSCopy:
.9c69	bd 7b 05	lda $057b,x			lda 	NumberBuffer,x
.9c6c	20 77 9c	jsr $9c77			jsr 	WriteDecimalBuffer
.9c6f	e8		inx				inx
.9c70	bd 7b 05	lda $057b,x			lda 	NumberBuffer,x
.9c73	d0 f4		bne $9c69			bne 	_MPTSCopy
.9c75	fa		plx				plx
.9c76	60		rts				rts
.9c77					WriteDecimalBuffer:
.9c77	da		phx				phx
.9c78	ae 15 04	ldx $0415			ldx 	dbOffset
.9c7b	9d 9d 05	sta $059d,x			sta 	DecimalBuffer,x
.9c7e	9e 9e 05	stz $059e,x			stz 	DecimalBuffer+1,x
.9c81	ee 15 04	inc $0415			inc 	dbOffset
.9c84	fa		plx				plx
.9c85	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/substring.asm

.9c86					Unary_Left:
.9c86	fa		plx				plx
.9c87	18		clc				clc 								; only one parameter
.9c88	20 eb 9c	jsr $9ceb			jsr 	SubstringInitial 			; set up.
.9c8b	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; Param #1 is the length
.9c8d	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9c8f	74 59		stz $59,x			stz 	NSMantissa0+1,x 			; Start is zero.
.9c91	80 25		bra $9cb8			bra 	SubstringMain
.9c93					Unary_Right:
.9c93	fa		plx				plx
.9c94	18		clc				clc 								; only one parameter
.9c95	20 eb 9c	jsr $9ceb			jsr 	SubstringInitial 			; set up.
.9c98	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; length => param 2
.9c9a	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9c9c	b5 78		lda $78,x			lda 	NSExponent,x 				; total length
.9c9e	f5 59		sbc $59,x			sbc 	NSMantissa0+1,x 			; length - required.
.9ca0	b0 02		bcs $9ca4			bcs 	_URNotUnderflow
.9ca2	a9 00		lda #$00			lda 	#0 							; start from the beginning, as something like right$("AB",3)
.9ca4					_URNotUnderFlow:
.9ca4	95 59		sta $59,x			sta 	NSMantissa0+1,x 			; this is the start position
.9ca6	80 10		bra $9cb8			bra 	SubStringMain
.9ca8					Unary_Mid:
.9ca8	fa		plx				plx
.9ca9	38		sec				sec 								; two parameters
.9caa	20 eb 9c	jsr $9ceb			jsr 	SubstringInitial 			; set up.
.9cad	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; first parameter is zero ?
.9caf	f0 04		beq $9cb5			beq 	_UMError
.9cb1	d6 59		dec $59,x			dec 	NSMantissa0+1,x				; reduce initial offset by 1 as MID$(a$,1..) is actually the first character
.9cb3	80 03		bra $9cb8			bra 	SubStringMain
.9cb5					_UMError:
.9cb5	4c 5a 9f	jmp $9f5a			jmp 	ArgumentError
.9cb8					SubStringMain:
.9cb8	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; is the initial offset >= the length
.9cba	d5 78		cmp $78,x			cmp 	NSExponent,x
.9cbc	b0 27		bcs $9ce5			bcs 	_SSMNull 					; if so, return an empty string.
.9cbe	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; if copy count is zero
.9cc0	f0 23		beq $9ce5			beq 	_SSMNull 					; return empty string.
.9cc2	18		clc				clc 								; add the offset +1 to the address and
.9cc3	b5 58		lda $58,x			lda	 	NSMantissa0,x 				; put in zTemp, this is the start of the substring to copy.
.9cc5	75 59		adc $59,x			adc 	NSMantissa0+1,x
.9cc7	85 36		sta $36				sta 	zTemp0
.9cc9	b5 60		lda $60,x			lda	 	NSMantissa1,x
.9ccb	69 00		adc #$00			adc 	#0
.9ccd	85 37		sta $37				sta 	zTemp0+1
.9ccf					_SSMNoCarry:
.9ccf	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; characters required.
.9cd1	20 ff a6	jsr $a6ff			jsr 	StringTempAllocate 			; allocate that many characters
.9cd4	5a		phy				phy 								; save Y
.9cd5	a0 00		ldy #$00			ldy 	#0 							; start copying in.
.9cd7					_SSMCopy:
.9cd7	b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next character
.9cd9	f0 08		beq $9ce3			beq 	_SSMEString 				; no more to copy
.9cdb	20 38 a7	jsr $a738			jsr 	StringTempWrite 			; and write it out.
.9cde	c8		iny				iny
.9cdf	d6 5a		dec $5a,x			dec 	NSMantissa0+2,x
.9ce1	d0 f4		bne $9cd7			bne 	_SSMCopy
.9ce3					_SSMEString:
.9ce3	7a		ply				ply
.9ce4					_SSMExit:
.9ce4	60		rts				rts
.9ce5					_SSMNull:
.9ce5	a9 00		lda #$00			lda 	#0
.9ce7	20 ff a6	jsr $a6ff			jsr 	StringTempAllocate
.9cea	60		rts				rts
.9ceb					SubstringInitial:
.9ceb	da		phx				phx 								; save initial stack position
.9cec	08		php				php 								; save carry on stack indicating 2 parameters
.9ced	20 25 9d	jsr $9d25			jsr 	EvaluateString 				; get a string
.9cf0	5a		phy				phy 								; calculate length to exponent.
.9cf1	a0 ff		ldy #$ff			ldy 	#$FF
.9cf3					_SIFindLength:
.9cf3	c8		iny				iny
.9cf4	b1 36		lda ($36),y			lda 	(zTemp0),y
.9cf6	d0 fb		bne $9cf3			bne 	_SIFindLength
.9cf8	98		tya				tya
.9cf9	95 78		sta $78,x			sta 	NSExponent,x
.9cfb	7a		ply				ply
.9cfc	e8		inx				inx
.9cfd	20 af 8e	jsr $8eaf			jsr 	CheckComma 					; comma next
.9d00	20 68 9d	jsr $9d68			jsr 	Evaluate8BitInteger 		; get next parameter
.9d03	28		plp				plp 								; is it the last parameter ?
.9d04	90 07		bcc $9d0d			bcc 	_SSIExit 					; if so, exit.
.9d06	e8		inx				inx
.9d07	20 af 8e	jsr $8eaf			jsr 	CheckComma 					; comma next
.9d0a	20 68 9d	jsr $9d68			jsr 	Evaluate8BitInteger 		; get last parameter
.9d0d					_SSIExit:
.9d0d	fa		plx				plx
.9d0e	20 a7 8e	jsr $8ea7			jsr 	CheckRightBracket 			; check closing bracket
.9d11	60		rts				rts 								; exit

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/exprhelper.asm

.9d12					EvaluateValue:
.9d12	48		pha				pha
.9d13	20 c4 93	jsr $93c4			jsr		EvaluateExpression 			; expression
.9d16	20 87 96	jsr $9687			jsr 	Dereference					; derefernce it
.9d19	68		pla				pla
.9d1a	60		rts				rts
.9d1b					EvaluateNumber:
.9d1b	20 12 9d	jsr $9d12			jsr 	EvaluateValue 				; get a value
.9d1e	b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.9d20	29 10		and #$10			and 	#NSBIsString
.9d22	d0 13		bne $9d37			bne 	HelperTypeError
.9d24	60		rts				rts
.9d25					EvaluateString:
.9d25	20 12 9d	jsr $9d12			jsr 	EvaluateValue 				; get a value
.9d28	b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.9d2a	29 10		and #$10			and 	#NSBIsString
.9d2c	f0 09		beq $9d37			beq 	HelperTypeError
.9d2e					CopyAddressToTemp0:
.9d2e	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address -> zTemp0
.9d30	85 36		sta $36				sta 	zTemp0 						; (so we can do something with it)
.9d32	b5 60		lda $60,x			lda 	NSMantissa1,x
.9d34	85 37		sta $37				sta 	zTemp0+1
.9d36	60		rts				rts
.9d37					HelperTypeError:
.9d37	4c 55 9f	jmp $9f55			jmp 	TypeError
.9d3a					EvaluateInteger:
.9d3a	20 1b 9d	jsr $9d1b			jsr 	EvaluateNumber
.9d3d	b5 78		lda $78,x			lda 	NSExponent,x 				; check exponent is zero
.9d3f	d0 09		bne $9d4a			bne 	HelperValueError 			; if not, it's a float.
.9d41	60		rts				rts
.9d42					EvaluateUnsignedInteger:
.9d42	20 3a 9d	jsr $9d3a			jsr 	EvaluateInteger 			; check integer is +ve
.9d45	b5 50		lda $50,x			lda 	NSStatus,x
.9d47	30 01		bmi $9d4a			bmi 	HelperValueError
.9d49	60		rts				rts
.9d4a					HelperValueError:
.9d4a	4c 5a 9f	jmp $9f5a			jmp 	ArgumentError
.9d4d						Evaluate16BitInteger:
.9d4d	20 42 9d	jsr $9d42			jsr	 	EvaluateUnsignedInteger		; get integer
.9d50	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9d52	15 68		ora $68,x			ora 	NSMantissa2,x
.9d54	d0 f4		bne $9d4a			bne 	HelperValueError
.9d56	60		rts				rts
.9d57					Evaluate16BitIntegerSigned:
.9d57	20 3a 9d	jsr $9d3a			jsr	 	EvaluateInteger				; get integer
.9d5a	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9d5c	15 68		ora $68,x			ora 	NSMantissa2,x
.9d5e	d0 ea		bne $9d4a			bne 	HelperValueError
.9d60	b5 50		lda $50,x			lda 	NSStatus,x 					; signed ?
.9d62	10 03		bpl $9d67			bpl 	_EISNotSigned
.9d64	20 96 9d	jsr $9d96			jsr 	NSMNegateMantissa 			; makes it an actual 2's complement value.
.9d67					_EISNotSigned:
.9d67	60		rts				rts
.9d68					Evaluate8BitInteger:
.9d68	20 42 9d	jsr $9d42			jsr	 	EvaluateUnsignedInteger 	; get an integer
.9d6b	d0 dd		bne $9d4a			bne 	HelperValueError
.9d6d	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 1, 2 & 3 must be zero
.9d6f	15 68		ora $68,x			ora 	NSMantissa2,x
.9d71	15 60		ora $60,x			ora 	NSMantissa1,x
.9d73	d0 d5		bne $9d4a			bne 	HelperValueError
.9d75	b5 58		lda $58,x			lda 	NSMantissa0,x
.9d77	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/mult8x8.asm

.9d78					Multiply8x8:
.9d78	4a		lsr a		  		lsr 	a  							; prime the carry bit for the loop
.9d79	85 36		sta $36			  	sta 	zTemp0
.9d7b	86 37		stx $37				stx 	zTemp0+1
.9d7d	a9 00		lda #$00			lda 	#0
.9d7f	a2 08		ldx #$08			ldx 	#8
.9d81					_M88Loop:
.9d81	90 03		bcc $9d86			bcc 	_M88NoAdd
.9d83	18		clc				clc
.9d84	65 37		adc $37				adc 	zTemp0+1
.9d86					_M88NoAdd:
.9d86	6a		ror a				ror 	a
.9d87	66 36		ror $36				ror 	zTemp0  					; pull another bit out for the next iteration
.9d89	ca		dex				dex         						; inc/dec don't modify carry; only shifts and adds do
.9d8a	d0 f5		bne $9d81			bne 	_M88Loop
.9d8c	85 37		sta $37				sta 	zTemp0+1 					; store high 8 bits.
.9d8e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/utility.asm

.9d8f					NSMNegate:
.9d8f	b5 50		lda $50,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.9d91	49 80		eor #$80			eor 	#NSBIsNegative  			; toggle the negative flag
.9d93	95 50		sta $50,x			sta 	NSStatus,x
.9d95	60		rts				rts
.9d96					NSMNegateMantissa:
.9d96	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.9d97	a9 00		lda #$00			lda 	#0
.9d99	f5 58		sbc $58,x			sbc 	NSMantissa0,x
.9d9b	95 58		sta $58,x			sta 	NSMantissa0,x
.9d9d	a9 00		lda #$00			lda 	#0
.9d9f	f5 60		sbc $60,x			sbc 	NSMantissa1,x
.9da1	95 60		sta $60,x			sta 	NSMantissa1,x
.9da3	a9 00		lda #$00			lda 	#0
.9da5	f5 68		sbc $68,x			sbc 	NSMantissa2,x
.9da7	95 68		sta $68,x			sta 	NSMantissa2,x
.9da9	a9 00		lda #$00			lda 	#0
.9dab	f5 70		sbc $70,x			sbc 	NSMantissa3,x
.9dad	95 70		sta $70,x			sta 	NSMantissa3,x
.9daf	60		rts				rts
.9db0					NSMShiftUpTwo:
.9db0	b5 58		lda $58,x			lda 	NSMantissa0,x
.9db2	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9db4	b5 60		lda $60,x			lda 	NSMantissa1,x
.9db6	95 62		sta $62,x			sta 	NSMantissa1+2,x
.9db8	b5 68		lda $68,x			lda 	NSMantissa2,x
.9dba	95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.9dbc	b5 70		lda $70,x			lda 	NSMantissa3,x
.9dbe	95 72		sta $72,x			sta 	NSMantissa3+2,x
.9dc0	b5 78		lda $78,x			lda 	NSExponent,x
.9dc2	95 7a		sta $7a,x			sta 	NSExponent+2,x
.9dc4	b5 50		lda $50,x			lda 	NSStatus,x
.9dc6	95 52		sta $52,x			sta 	NSStatus+2,x
.9dc8	60		rts				rts
.9dc9					NSMSetZeroMantissaOnly:
.9dc9	a9 00		lda #$00			lda 	#0
.9dcb	80 06		bra $9dd3			bra 	NSMSetMantissa
.9dcd					NSMSetZero:
.9dcd	a9 00		lda #$00			lda 	#0
.9dcf					NSMSetByte:
.9dcf	74 78		stz $78,x			stz 	NSExponent,x 				; zero exponent, as integer.
.9dd1	74 50		stz $50,x			stz 	NSStatus,x 					; status zero (integer)
.9dd3					NSMSetMantissa:
.9dd3	95 58		sta $58,x			sta 	NSMantissa0,x 				; mantissa
.9dd5	74 60		stz $60,x			stz 	NSMantissa1,x
.9dd7	74 68		stz $68,x			stz 	NSMantissa2,x
.9dd9	74 70		stz $70,x			stz 	NSMantissa3,x
.9ddb	60		rts				rts
.9ddc					NSMShiftLeft:
.9ddc	18		clc				clc
.9ddd					NSMRotateLeft:
.9ddd	36 58		rol $58,x			rol 	NSMantissa0,x
.9ddf	36 60		rol $60,x			rol		NSMantissa1,x
.9de1	36 68		rol $68,x			rol		NSMantissa2,x
.9de3	36 70		rol $70,x			rol		NSMantissa3,x
.9de5	60		rts				rts
.9de6					NSMShiftRight:
.9de6	56 70		lsr $70,x			lsr 	NSMantissa3,x
.9de8	76 68		ror $68,x			ror		NSMantissa2,x
.9dea	76 60		ror $60,x			ror		NSMantissa1,x
.9dec	76 58		ror $58,x			ror		NSMantissa0,x
.9dee	60		rts				rts
.9def					NSMIsZero:
.9def	b5 70		lda $70,x			lda 	NSMantissa3,x
.9df1	15 68		ora $68,x			ora		NSMantissa2,x
.9df3	15 60		ora $60,x			ora		NSMantissa1,x
.9df5	15 58		ora $58,x			ora		NSMantissa0,x
.9df7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.asm

.9df8					TickHandler:
.9df8	5a		phy				phy 								; need to preserve Y
.9df9	20 1b 80	jsr $801b			jsr 	SNDUpdate 					; update sound
.9dfc	7a		ply				ply
.9dfd	60		rts				rts
.05af					LastTick:
>05af							.fill 		1

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/asmcore.asm

.9dfe					Assemble_ora:
.9dfe	20 71 80	jsr $8071		jsr	AssembleGroup1
>9e01	01					.byte $01
.9e02					Assemble_and:
.9e02	20 71 80	jsr $8071		jsr	AssembleGroup1
>9e05	21					.byte $21
.9e06					Assemble_eor:
.9e06	20 71 80	jsr $8071		jsr	AssembleGroup1
>9e09	41					.byte $41
.9e0a					Assemble_adc:
.9e0a	20 71 80	jsr $8071		jsr	AssembleGroup1
>9e0d	61					.byte $61
.9e0e					Assemble_sta:
.9e0e	20 71 80	jsr $8071		jsr	AssembleGroup1
>9e11	81					.byte $81
.9e12					Assemble_lda:
.9e12	20 71 80	jsr $8071		jsr	AssembleGroup1
>9e15	a1					.byte $a1
.9e16					Assemble_cmp:
.9e16	20 71 80	jsr $8071		jsr	AssembleGroup1
>9e19	c1					.byte $c1
.9e1a					Assemble_sbc:
.9e1a	20 71 80	jsr $8071		jsr	AssembleGroup1
>9e1d	e1					.byte $e1
.9e1e					Assemble_asl:
.9e1e	20 78 80	jsr $8078		jsr	AssembleGroup2
>9e21	02					.byte $02
>9e22	75					.byte $75
.9e23					Assemble_rol:
.9e23	20 78 80	jsr $8078		jsr	AssembleGroup2
>9e26	22					.byte $22
>9e27	75					.byte $75
.9e28					Assemble_lsr:
.9e28	20 78 80	jsr $8078		jsr	AssembleGroup2
>9e2b	42					.byte $42
>9e2c	75					.byte $75
.9e2d					Assemble_ror:
.9e2d	20 78 80	jsr $8078		jsr	AssembleGroup2
>9e30	62					.byte $62
>9e31	75					.byte $75
.9e32					Assemble_stx:
.9e32	20 78 80	jsr $8078		jsr	AssembleGroup2
>9e35	82					.byte $82
>9e36	50					.byte $50
.9e37					Assemble_ldx:
.9e37	20 78 80	jsr $8078		jsr	AssembleGroup2
>9e3a	a2					.byte $a2
>9e3b	d0					.byte $d0
.9e3c					Assemble_dec:
.9e3c	20 78 80	jsr $8078		jsr	AssembleGroup2
>9e3f	c2					.byte $c2
>9e40	55					.byte $55
.9e41					Assemble_inc:
.9e41	20 78 80	jsr $8078		jsr	AssembleGroup2
>9e44	e2					.byte $e2
>9e45	55					.byte $55
.9e46					Assemble_stz:
.9e46	20 78 80	jsr $8078		jsr	AssembleGroup2
>9e49	60					.byte $60
>9e4a	44					.byte $44
.9e4b					Assemble_bit:
.9e4b	20 78 80	jsr $8078		jsr	AssembleGroup2
>9e4e	20					.byte $20
>9e4f	55					.byte $55
.9e50					Assemble_sty:
.9e50	20 78 80	jsr $8078		jsr	AssembleGroup2
>9e53	80					.byte $80
>9e54	54					.byte $54
.9e55					Assemble_ldy:
.9e55	20 78 80	jsr $8078		jsr	AssembleGroup2
>9e58	a0					.byte $a0
>9e59	d5					.byte $d5
.9e5a					Assemble_cpy:
.9e5a	20 78 80	jsr $8078		jsr	AssembleGroup2
>9e5d	c0					.byte $c0
>9e5e	d4					.byte $d4
.9e5f					Assemble_cpx:
.9e5f	20 78 80	jsr $8078		jsr	AssembleGroup2
>9e62	e0					.byte $e0
>9e63	d0					.byte $d0
.9e64					Assemble_tsb:
.9e64	20 78 80	jsr $8078		jsr	AssembleGroup2
>9e67	00					.byte $00
>9e68	50					.byte $50
.9e69					Assemble_trb:
.9e69	20 78 80	jsr $8078		jsr	AssembleGroup2
>9e6c	10					.byte $10
>9e6d	50					.byte $50
.9e6e					Assemble_jsr:
.9e6e	20 78 80	jsr $8078		jsr	AssembleGroup2
>9e71	14					.byte $14
>9e72	10					.byte $10
.9e73					Assemble_jmp:
.9e73	20 78 80	jsr $8078		jsr	AssembleGroup2
>9e76	40					.byte $40
>9e77	10					.byte $10
.9e78					Assemble_bpl:
.9e78	20 c9 80	jsr $80c9		jsr	AssembleGroup3
>9e7b	10					.byte $10
.9e7c					Assemble_bmi:
.9e7c	20 c9 80	jsr $80c9		jsr	AssembleGroup3
>9e7f	30					.byte $30
.9e80					Assemble_bvc:
.9e80	20 c9 80	jsr $80c9		jsr	AssembleGroup3
>9e83	50					.byte $50
.9e84					Assemble_bvs:
.9e84	20 c9 80	jsr $80c9		jsr	AssembleGroup3
>9e87	70					.byte $70
.9e88					Assemble_bcc:
.9e88	20 c9 80	jsr $80c9		jsr	AssembleGroup3
>9e8b	90					.byte $90
.9e8c					Assemble_bcs:
.9e8c	20 c9 80	jsr $80c9		jsr	AssembleGroup3
>9e8f	b0					.byte $b0
.9e90					Assemble_bne:
.9e90	20 c9 80	jsr $80c9		jsr	AssembleGroup3
>9e93	d0					.byte $d0
.9e94					Assemble_beq:
.9e94	20 c9 80	jsr $80c9		jsr	AssembleGroup3
>9e97	f0					.byte $f0
.9e98					Assemble_bra:
.9e98	20 c9 80	jsr $80c9		jsr	AssembleGroup3
>9e9b	80					.byte $80
.9e9c					Assemble_brk:
.9e9c	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9e9f	00					.byte $00
.9ea0					Assemble_php:
.9ea0	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9ea3	08					.byte $08
.9ea4					Assemble_clc:
.9ea4	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9ea7	18					.byte $18
.9ea8					Assemble_plp:
.9ea8	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9eab	28					.byte $28
.9eac					Assemble_sec:
.9eac	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9eaf	38					.byte $38
.9eb0					Assemble_rti:
.9eb0	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9eb3	40					.byte $40
.9eb4					Assemble_pha:
.9eb4	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9eb7	48					.byte $48
.9eb8					Assemble_cli:
.9eb8	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9ebb	58					.byte $58
.9ebc					Assemble_phy:
.9ebc	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9ebf	5a					.byte $5a
.9ec0					Assemble_rts:
.9ec0	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9ec3	60					.byte $60
.9ec4					Assemble_pla:
.9ec4	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9ec7	68					.byte $68
.9ec8					Assemble_sei:
.9ec8	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9ecb	78					.byte $78
.9ecc					Assemble_ply:
.9ecc	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9ecf	7a					.byte $7a
.9ed0					Assemble_dey:
.9ed0	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9ed3	88					.byte $88
.9ed4					Assemble_txa:
.9ed4	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9ed7	8a					.byte $8a
.9ed8					Assemble_tya:
.9ed8	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9edb	98					.byte $98
.9edc					Assemble_txs:
.9edc	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9edf	9a					.byte $9a
.9ee0					Assemble_tay:
.9ee0	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9ee3	a8					.byte $a8
.9ee4					Assemble_tax:
.9ee4	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9ee7	aa					.byte $aa
.9ee8					Assemble_clv:
.9ee8	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9eeb	b8					.byte $b8
.9eec					Assemble_tsx:
.9eec	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9eef	ba					.byte $ba
.9ef0					Assemble_iny:
.9ef0	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9ef3	c8					.byte $c8
.9ef4					Assemble_dex:
.9ef4	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9ef7	ca					.byte $ca
.9ef8					Assemble_cld:
.9ef8	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9efb	d8					.byte $d8
.9efc					Assemble_phx:
.9efc	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9eff	da					.byte $da
.9f00					Assemble_stp:
.9f00	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9f03	db					.byte $db
.9f04					Assemble_inx:
.9f04	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9f07	e8					.byte $e8
.9f08					Assemble_nop:
.9f08	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9f0b	ea					.byte $ea
.9f0c					Assemble_sed:
.9f0c	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9f0f	f8					.byte $f8
.9f10					Assemble_plx:
.9f10	20 fd 80	jsr $80fd		jsr	AssembleGroup4
>9f13	fa					.byte $fa

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/constants.asm

.9f14					DecimalScalarTable:
>9f14	66 66 66 66				.dword $66666666 ; 0.1
>9f18	de					.byte $de
>9f19	1f 85 eb 51				.dword $51eb851f ; 0.01
>9f1d	db					.byte $db
>9f1e	4c 37 89 41				.dword $4189374c ; 0.001
>9f22	d8					.byte $d8
>9f23	ac 8b db 68				.dword $68db8bac ; 0.0001
>9f27	d4					.byte $d4
>9f28	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>9f2c	d1					.byte $d1
>9f2d	83 de 1b 43				.dword $431bde83 ; 1e-06
>9f31	ce					.byte $ce
>9f32	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>9f36	ca					.byte $ca
>9f37	89 3b e6 55				.dword $55e63b89 ; 1e-08
>9f3b	c7					.byte $c7
>9f3c	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>9f40	c4					.byte $c4
>9f41	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>9f45	c0					.byte $c0
>9f46	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>9f4a	bd					.byte $bd

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.asm

.9f4b					SyntaxError:
.9f4b	a9 02		lda #$02		lda	#2
.9f4d	4c c0 8e	jmp $8ec0		jmp	ErrorHandler
.9f50					RangeError:
.9f50	a9 04		lda #$04		lda	#4
.9f52	4c c0 8e	jmp $8ec0		jmp	ErrorHandler
.9f55					TypeError:
.9f55	a9 05		lda #$05		lda	#5
.9f57	4c c0 8e	jmp $8ec0		jmp	ErrorHandler
.9f5a					ArgumentError:
.9f5a	a9 07		lda #$07		lda	#7
.9f5c	4c c0 8e	jmp $8ec0		jmp	ErrorHandler
.9f5f					NotDoneError:
.9f5f	a9 0c		lda #$0c		lda	#12
.9f61	4c c0 8e	jmp $8ec0		jmp	ErrorHandler
.9f64					ErrorText:
>9f64	42 72 65 61 6b 00			.text	"Break",0
>9f6a	53 79 6e 74 61 78 20 65			.text	"Syntax error",0
>9f72	72 72 6f 72 00
>9f77	44 69 76 69 73 69 6f 6e			.text	"Division by zero",0
>9f7f	20 62 79 20 7a 65 72 6f 00
>9f88	4f 75 74 20 6f 66 20 52			.text	"Out of Range",0
>9f90	61 6e 67 65 00
>9f95	54 79 70 65 20 6d 69 73			.text	"Type mismatch",0
>9f9d	6d 61 74 63 68 00
>9fa3	4f 75 74 20 6f 66 20 6d			.text	"Out of memory",0
>9fab	65 6d 6f 72 79 00
>9fb1	49 6c 6c 65 67 61 6c 20			.text	"Illegal argument",0
>9fb9	61 72 67 75 6d 65 6e 74 00
>9fc2	53 74 6f 70 00				.text	"Stop",0
>9fc7	53 74 72 69 6e 67 20 74			.text	"String too long",0
>9fcf	6f 6f 20 6c 6f 6e 67 00
>9fd7	41 73 73 65 72 74 69 6f			.text	"Assertion failed",0
>9fdf	6e 20 66 61 69 6c 65 64 00
>9fe8	4f 75 74 20 6f 66 20 64			.text	"Out of data",0
>9ff0	61 74 61 00
>9ff4	55 6e 69 6d 70 6c 65 6d			.text	"Unimplemented",0
>9ffc	65 6e 74 65 64 00
>a002	4e 6f 20 73 75 63 68 20			.text	"No such line number",0
>a00a	6c 69 6e 65 20 6e 75 6d 62 65 72 00
>a016	52 65 74 75 72 6e 20 77			.text	"Return without Gosub",0
>a01e	69 74 68 6f 75 74 20 47 6f 73 75 62 00
>a02b	55 6e 74 69 6c 20 77 69			.text	"Until without Repeat",0
>a033	74 68 6f 75 74 20 52 65 70 65 61 74 00
>a040	57 65 6e 64 20 77 69 74			.text	"Wend without While",0
>a048	68 6f 75 74 20 57 68 69 6c 65 00
>a053	4e 65 78 74 20 77 69 74			.text	"Next without For",0
>a05b	68 6f 75 74 20 46 6f 72 00
>a064	42 41 53 49 43 20 53 74			.text	"BASIC Stack full",0
>a06c	61 63 6b 20 66 75 6c 6c 00
>a075	4f 70 65 6e 20 53 74 72			.text	"Open Structure",0
>a07d	75 63 74 75 72 65 00
>a084	45 6e 64 50 72 6f 63 20			.text	"EndProc without call",0
>a08c	77 69 74 68 6f 75 74 20 63 61 6c 6c 00
>a099	41 72 72 61 79 20 61 6c			.text	"Array already defined",0
>a0a1	72 65 61 64 79 20 64 65 66 69 6e 65 64 00
>a0af	41 72 72 61 79 20 73 69			.text	"Array size",0
>a0b7	7a 65 00
>a0ba	42 61 64 20 61 72 72 61			.text	"Bad array index",0
>a0c2	79 20 69 6e 64 65 78 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/timestamp.asm

>a0ca	52 65 6c 65 61 73 65 20			.text "Release Alpha 8 (01-Dec-22). "
>a0d2	41 6c 70 68 61 20 38 20 28 30 31 2d 44 65 63 2d
>a0e2	32 32 29 2e 20

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcommand.asm

.a0e7					RectangleCommand:
.a0e7	a9 44		lda #$44			lda 	#GCMD_FrameRect				; frame rectangle
.a0e9	80 02		bra $a0ed			bra 	ShapeDrawCmd
.a0eb					CircleCommand:
.a0eb	a9 48		lda #$48			lda 	#GCMD_FrameCircle 				; framed circle
.a0ed					ShapeDrawCmd:
.a0ed	20 77 a1	jsr $a177			jsr 	RunGraphicsCommand
.a0f0					ShapeDraw:
.a0f0	0d b1 05	ora $05b1			ora 	gxFillSolid  				; adjust AXY for solid fill.
.a0f3	4c 6b a1	jmp $a16b			jmp 	ExecuteGraphicCommand	 	; and complete
.a0f6					SpriteCommand:
.a0f6	a2 00		ldx #$00			ldx 	#0
.a0f8	20 68 9d	jsr $9d68			jsr 	Evaluate8BitInteger 		; get image number.
.a0fb	5a		phy				phy
.a0fc	a9 0e		lda #$0e			lda 	#GCMD_SpriteUse 			; use that image.
.a0fe	a6 58		ldx $58				ldx 	NSMantissa0
.a100	e0 40		cpx #$40			cpx 	#64 						; 0-63 only
.a102	b0 0d		bcs $a111			bcs 	_SCRange
.a104	a0 ff		ldy #$ff			ldy 	#255
.a106	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a109	a9 52		lda #$52			lda 	#GCMD_SpriteMove
.a10b	7a		ply				ply
.a10c	20 77 a1	jsr $a177			jsr 	RunGraphicsCommand
.a10f	80 5a		bra $a16b			bra 	ExecuteGraphicCommand
.a111					_SCRange:
.a111	4c 50 9f	jmp $9f50			jmp 	RangeError
.a114					ImageCommand:
.a114	a2 00		ldx #$00			ldx 	#0
.a116	20 68 9d	jsr $9d68			jsr 	Evaluate8BitInteger 		; get image number.
.a119	20 77 a1	jsr $a177			jsr 	RunGraphicsCommand
.a11c					ImageRunDraw:
.a11c	09 40		ora #$40			ora 	#GCMD_Move					; move cursor
.a11e	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a121	ad b7 05	lda $05b7			lda 	gxDrawScale
.a124	0a		asl a				asl 	a
.a125	0a		asl a				asl 	a
.a126	0a		asl a				asl 	a
.a127	a8		tay				tay
.a128	a9 0c		lda #$0c			lda 	#GCMD_DrawSprite 			; image drawing
.a12a	a6 58		ldx $58				ldx 	NSMantissa0
.a12c	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a12f	60		rts				rts
.a130					TextCommand:
.a130	a2 00		ldx #$00			ldx 	#0
.a132	20 25 9d	jsr $9d25			jsr 	EvaluateString 				; get text
.a135	20 77 a1	jsr $a177			jsr 	RunGraphicsCommand
.a138					TextRunDraw:
.a138	09 40		ora #$40			ora 	#GCMD_Move 					; move cursor
.a13a	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a13d	a0 00		ldy #$00			ldy 	#0
.a13f					_IRDLoop:
.a13f	a5 60		lda $60				lda 	NSMantissa1 				; access character
.a141	85 37		sta $37				sta 	zTemp0+1
.a143	a5 58		lda $58				lda 	NSMantissa0
.a145	85 36		sta $36				sta 	zTemp0
.a147	b1 36		lda ($36),y			lda 	(zTemp0),y
.a149	f0 13		beq $a15e			beq 	_IRDExit
.a14b	5a		phy				phy									; save string pos
.a14c	48		pha				pha 								; save char
.a14d	ad b7 05	lda $05b7			lda 	gxDrawScale 				; get scale
.a150	0a		asl a				asl 	a
.a151	0a		asl a				asl 	a
.a152	0a		asl a				asl 	a
.a153	a8		tay				tay
.a154	a9 0a		lda #$0a			lda 	#GCMD_DrawFont 				; char drawing
.a156	fa		plx				plx 								; char to draw
.a157	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a15a	7a		ply				ply 								; restore string pos
.a15b	c8		iny				iny
.a15c	90 e1		bcc $a13f			bcc 	_IRDLoop 					; go back if no error.
.a15e					_IRDExit:
.a15e	60		rts				rts
.a15f					PlotCommand:
.a15f	a9 50		lda #$50			lda 	#GCMD_Plot 					; command ID to use
.a161	20 77 a1	jsr $a177			jsr 	RunGraphicsCommand
.a164	80 05		bra $a16b			bra 	ExecuteGraphicCommand
.a166					LineCommand:
.a166	a9 42		lda #$42			lda 	#GCMD_Line 						; command ID to use
.a168	20 77 a1	jsr $a177			jsr 	RunGraphicsCommand
.a16b					ExecuteGraphicCommand:
.a16b	0d b0 05	ora $05b0			ora 	gxCommandID 				; make a full command
.a16e	20 15 80	jsr $8015			jsr 	GXGraphicDraw 				; draw it and exit
.a171	b0 01		bcs $a174			bcs 	_EGCError
.a173	60		rts				rts
.a174					_EGCError:
.a174	4c 4b 9f	jmp $9f4b			jmp 	SyntaxError
.a177					RunGraphicsCommand:
.a177	8d b0 05	sta $05b0			sta 	gxCommandID					; save TODO graphics command.
.a17a	68		pla				pla 								; pop handler address
.a17b	fa		plx				plx
.a17c	1a		inc a				inc 	a
.a17d	d0 01		bne $a180			bne 	_RGINoCarry
.a17f	e8		inx				inx
.a180					_RGINoCarry:
.a180	8d b5 05	sta $05b5			sta 	GXHandler
.a183	8e b6 05	stx $05b6			stx 	GXHandler+1
.a186					_RGICommandLoop:
.a186	b1 30		lda ($30),y			lda 	(codePtr),y
.a188	c8		iny				iny
.a189	c9 ce		cmp #$ce			cmp 	#KWD_TO						; is it TO x,y
.a18b	f0 53		beq $a1e0			beq 	_RGI_To
.a18d	c9 ba		cmp #$ba			cmp 	#KWD_HERE 					; do it here.
.a18f	f0 55		beq $a1e6			beq 	_RGI_Here
.a191	c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL or : , exit
.a193	f0 3d		beq $a1d2			beq 	_RGI_Exit
.a195	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.a197	f0 39		beq $a1d2			beq 	_RGI_Exit
.a199	c9 c2		cmp #$c2			cmp 	#KWD_OUTLINE 				; solid or outline
.a19b	f0 3e		beq $a1db			beq 	_RGI_Frame
.a19d	c9 ca		cmp #$ca			cmp 	#KWD_SOLID
.a19f	f0 33		beq $a1d4			beq 	_RGI_Solid
.a1a1	c9 ab		cmp #$ab			cmp 	#KWD_BY 					; by offset
.a1a3	f0 4b		beq $a1f0			beq 	_RGI_By
.a1a5	c9 b6		cmp #$b6			cmp 	#KWD_FROM 					; from
.a1a7	f0 17		beq $a1c0			beq 	_RGI_Move2
.a1a9	c9 b3		cmp #$b3			cmp 	#KWD_DIM 					; dim (set scale)
.a1ab	f0 62		beq $a20f			beq 	_RGI_Dim
.a1ad	c9 b1		cmp #$b1			cmp 	#KWD_COLOUR 				; colour or Color
.a1af	f0 74		beq $a225			beq 	_RGI_Colour
.a1b1	c9 b0		cmp #$b0			cmp 	#KWD_COLOR
.a1b3	f0 70		beq $a225			beq 	_RGI_Colour
.a1b5	ae b0 05	ldx $05b0			ldx 	gxCommandID
.a1b8	e0 52		cpx #$52			cpx 	#GCMD_SpriteMove 			; if not sprite
.a1ba	d0 03		bne $a1bf			bne 	_RGI_Move 					; move
.a1bc	4c 4d a2	jmp $a24d			jmp		_RGI_SpriteInstructions
.a1bf					_RGI_Move:
.a1bf	88		dey				dey 								; unpick get.
.a1c0					_RGI_Move2:
.a1c0	20 73 a2	jsr $a273			jsr 	GCGetCoordinatePair 		; move to here
.a1c3	20 9a a2	jsr $a29a			jsr 	GCCopyPairToStore 			; save
.a1c6	5a		phy				phy
.a1c7	20 90 a2	jsr $a290			jsr 	GCLoadAXY 					; load in
.a1ca	09 40		ora #$40			ora 	#GCMD_Move 					; move there
.a1cc	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a1cf	7a		ply				ply
.a1d0	80 b4		bra $a186			bra 	_RGICommandLoop 			; and go round
.a1d2					_RGI_Exit:
.a1d2	88		dey				dey 								; unpick : / EOL
.a1d3	60		rts				rts
.a1d4					_RGI_Solid:
.a1d4	a9 02		lda #$02			lda 	#2
.a1d6	8d b1 05	sta $05b1			sta 	gxFillSolid
.a1d9	80 ab		bra $a186			bra 	_RGICommandLoop
.a1db					_RGI_Frame:
.a1db	9c b1 05	stz $05b1			stz 	gxFillSolid
.a1de	80 a6		bra $a186			bra 	_RGICommandLoop
.a1e0					_RGI_To:
.a1e0	20 73 a2	jsr $a273			jsr 	GCGetCoordinatePair 		; get coordinate pair into slot #1,#2
.a1e3	20 9a a2	jsr $a29a			jsr 	GCCopyPairToStore
.a1e6					_RGI_Here:
.a1e6	5a		phy				phy
.a1e7	20 90 a2	jsr $a290			jsr 	GCLoadAXY 					; load it into AXY
.a1ea	20 4a a2	jsr $a24a			jsr 	_RGICallHandler 			; go do whatever it is.
.a1ed	7a		ply				ply
.a1ee	80 96		bra $a186			bra 	_RGICommandLoop 			; and go round
.a1f0					_RGI_By:
.a1f0	20 80 a2	jsr $a280			jsr 	GCSignedCoordinatePair 		; get coordinate pair into slot #1,#2
.a1f3	18		clc				clc
.a1f4	a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.a1f6	6d b2 05	adc $05b2			adc 	gxxPos
.a1f9	8d b2 05	sta $05b2			sta 	gxXPos
.a1fc	a5 61		lda $61				lda 	NSMantissa1+1
.a1fe	6d b3 05	adc $05b3			adc 	gxxPos+1
.a201	8d b3 05	sta $05b3			sta 	gxXPos+1
.a204	a5 5a		lda $5a				lda 	NSMantissa0+2
.a206	18		clc				clc
.a207	6d b4 05	adc $05b4			adc 	gxYPos
.a20a	8d b4 05	sta $05b4			sta 	gxYPos
.a20d	80 d7		bra $a1e6			bra 	_RGI_Here
.a20f					_RGI_Dim:
.a20f	a2 01		ldx #$01			ldx	 	#1
.a211	20 68 9d	jsr $9d68			jsr 	Evaluate8BitInteger
.a214	a5 59		lda $59				lda 	NSMantissa0+1
.a216	c9 00		cmp #$00			cmp 	#0
.a218	f0 2d		beq $a247			beq 	_RGIRange
.a21a	c9 09		cmp #$09			cmp 	#8+1
.a21c	b0 29		bcs $a247			bcs		_RGIRange
.a21e	3a		dec a				dec 	a
.a21f	8d b7 05	sta $05b7			sta 	gxDrawScale
.a222	4c 86 a1	jmp $a186			jmp 	_RGICommandLoop
.a225					_RGI_Colour:
.a225	a2 01		ldx #$01			ldx 	#1 							; colour
.a227	20 68 9d	jsr $9d68			jsr 	Evaluate8BitInteger
.a22a	a2 02		ldx #$02			ldx 	#2 							; default zero for 2nd parameter
.a22c	20 cd 9d	jsr $9dcd			jsr 	NSMSetZero
.a22f	b1 30		lda ($30),y			lda 	(codePtr),y
.a231	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; check , => mode.
.a233	d0 04		bne $a239			bne 	_RGICDefaultMode
.a235	c8		iny				iny
.a236	20 68 9d	jsr $9d68			jsr 	Evaluate8BitInteger
.a239					_RGICDefaultMode:
.a239	5a		phy				phy
.a23a	a9 08		lda #$08			lda 	#GCMD_Colour 				; set colour.
.a23c	a6 59		ldx $59				ldx 	NSMantissa0+1
.a23e	a4 5a		ldy $5a				ldy 	NSMantissa0+2
.a240	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a243	7a		ply				ply
.a244	4c 86 a1	jmp $a186			jmp 	_RGICommandLoop 			; and go round
.a247					_RGIRange:
.a247	4c 50 9f	jmp $9f50			jmp 	RangeError
.a24a					_RGICallHandler:
.a24a	6c b5 05	jmp ($05b5)			jmp 	(GXHandler)
.a24d					_RGI_SpriteInstructions:
.a24d	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a24f	f0 07		beq $a258			beq 	_RGISpriteOff
.a251	c9 bb		cmp #$bb			cmp 	#KWD_IMAGE
.a253	f0 13		beq $a268			beq 	_RGISetImage
.a255	4c bf a1	jmp $a1bf			jmp 	_RGI_Move
.a258					_RGISpriteOff:
.a258	5a		phy				phy
.a259	a0 01		ldy #$01			ldy 	#1
.a25b	a2 00		ldx #$00			ldx 	#0
.a25d					_RGIDoCommandLoop:
.a25d	a9 10		lda #$10			lda 	#GCMD_SpriteImage
.a25f	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a262	7a		ply				ply
.a263	b0 e2		bcs $a247			bcs 	_RGIRange
.a265	4c 86 a1	jmp $a186			jmp 	_RGICommandLoop
.a268					_RGISetImage:
.a268	a2 01		ldx #$01			ldx 	#1
.a26a	20 68 9d	jsr $9d68			jsr 	Evaluate8BitInteger
.a26d	5a		phy				phy
.a26e	aa		tax				tax
.a26f	a0 00		ldy #$00			ldy 	#0
.a271	80 ea		bra $a25d			bra 	_RGIDoCommandLoop
.a273					GCGetCoordinatePair:
.a273	a2 01		ldx #$01			ldx 	#1
.a275	20 4d 9d	jsr $9d4d			jsr 	Evaluate16BitInteger
.a278	20 af 8e	jsr $8eaf			jsr 	CheckComma
.a27b	e8		inx				inx
.a27c	20 4d 9d	jsr $9d4d			jsr 	Evaluate16BitInteger
.a27f	60		rts				rts
.a280					GCSignedCoordinatePair:
.a280	a2 01		ldx #$01			ldx 	#1
.a282	20 57 9d	jsr $9d57			jsr 	Evaluate16BitIntegerSigned
.a285	20 af 8e	jsr $8eaf			jsr 	CheckComma
.a288	e8		inx				inx
.a289	20 57 9d	jsr $9d57			jsr 	Evaluate16BitIntegerSigned
.a28c	60		rts				rts
.a28d					_GCCPRange:
.a28d	4c 50 9f	jmp $9f50			jmp 	RangeError
.a290					GCLoadAXY:
.a290	ad b3 05	lda $05b3			lda 	gxXPos+1
.a293	ae b2 05	ldx $05b2			ldx 	gxXPos
.a296	ac b4 05	ldy $05b4			ldy 	gxYPos
.a299	60		rts				rts
.a29a					GCCopyPairToStore:
.a29a	a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.a29c	8d b2 05	sta $05b2			sta 	gxXPos
.a29f	a5 61		lda $61				lda 	NSMantissa1+1
.a2a1	8d b3 05	sta $05b3			sta 	gxXPos+1
.a2a4	a5 5a		lda $5a				lda 	NSMantissa0+2
.a2a6	8d b4 05	sta $05b4			sta 	gxYPos
.a2a9	60		rts				rts
.05b0					gxCommandID:
>05b0							.fill 	1
.05b1					gxFillSolid:
>05b1							.fill 	1
.05b2					gxXPos:
>05b2							.fill 	2
.05b4					gxYPos:
>05b4							.fill 	1
.05b5					gxHandler:
>05b5							.fill 	2
.05b7					gxDrawScale:
>05b7							.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcontrol.asm

.a2aa					BitmapCtrl:
.a2aa	b1 30		lda ($30),y			lda 	(codePtr),y
.a2ac	c8		iny				iny
.a2ad	a2 01		ldx #$01			ldx 	#1
.a2af	c9 c1		cmp #$c1			cmp 	#KWD_ON
.a2b1	f0 11		beq $a2c4			beq 	BitmapSwitch
.a2b3	ca		dex				dex
.a2b4	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a2b6	f0 0c		beq $a2c4			beq 	BitmapSwitch
.a2b8	20 68 9d	jsr $9d68			jsr 	Evaluate8BitInteger 		; get the colour
.a2bb	5a		phy				phy
.a2bc	aa		tax				tax
.a2bd	a9 06		lda #$06			lda 	#GCMD_Clear					; clear to that colour
.a2bf	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a2c2	7a		ply				ply
.a2c3	60		rts				rts
.a2c4					BitmapSwitch:
.a2c4	5a		phy				phy
.a2c5	a0 00		ldy #$00			ldy 	#0 							; gfx 1,on/off,0
.a2c7	a9 02		lda #$02			lda 	#GCMD_BitmapCtl
.a2c9	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a2cc	a9 08		lda #$08			lda 	#GCMD_Colour				; set colour to $FF
.a2ce	a0 00		ldy #$00			ldy 	#0
.a2d0	a2 ff		ldx #$ff			ldx 	#$FF
.a2d2	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a2d5	9c b1 05	stz $05b1			stz 	gxFillSolid
.a2d8	9c b2 05	stz $05b2			stz 	gxXPos
.a2db	9c b3 05	stz $05b3			stz 	gxXPos+1
.a2de	9c b4 05	stz $05b4			stz 	gxYPos
.a2e1	9c b7 05	stz $05b7			stz 	gxDrawScale
.a2e4	a9 40		lda #$40			lda 	#GCMD_Move 						; home cursor
.a2e6	a2 00		ldx #$00			ldx 	#0
.a2e8	a0 00		ldy #$00			ldy 	#0
.a2ea	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a2ed	7a		ply				ply
.a2ee	60		rts				rts
.a2ef					SpritesCtrl:
.a2ef	b1 30		lda ($30),y			lda 	(codePtr),y
.a2f1	c8		iny				iny
.a2f2	a2 01		ldx #$01			ldx 	#1
.a2f4	c9 c1		cmp #$c1			cmp 	#KWD_ON
.a2f6	f0 08		beq $a300			beq 	SpriteSwitch
.a2f8	ca		dex				dex
.a2f9	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a2fb	f0 03		beq $a300			beq 	SpriteSwitch
.a2fd	4c 4b 9f	jmp $9f4b			jmp 	SyntaxError
.a300					SpriteSwitch:
.a300	5a		phy				phy
.a301	a0 00		ldy #$00			ldy 	#0 							; gfx 2,on/off,0
.a303	a9 04		lda #$04			lda 	#GCMD_SpriteCtl
.a305	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a308	7a		ply				ply
.a309	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gfx.asm

.a30a					GfxCommand:
.a30a	a2 00		ldx #$00			ldx 	#0
.a30c	20 68 9d	jsr $9d68			jsr 	Evaluate8BitInteger 		; command
.a30f	20 af 8e	jsr $8eaf			jsr 	CheckComma
.a312	e8		inx				inx
.a313	20 4d 9d	jsr $9d4d			jsr 	Evaluate16BitInteger 		; X
.a316	20 af 8e	jsr $8eaf			jsr 	CheckComma
.a319	e8		inx				inx
.a31a	20 68 9d	jsr $9d68			jsr 	Evaluate8BitInteger 		; Y
.a31d	a5 61		lda $61				lda 	NSMantissa1+1  				; shift bit 0 of X into CS, should now be zero
.a31f	4a		lsr a				lsr 	a
.a320	d0 12		bne $a334			bne 	_GfxError
.a322	26 58		rol $58				rol 	NSMantissa0 				; rotate into command
.a324	b0 0e		bcs $a334			bcs 	_GfxError 					; bit 7 should have been zero
.a326	5a		phy				phy 								; save pos
.a327	a5 58		lda $58				lda 	NSMantissa0 				; do the command
.a329	a6 59		ldx $59				ldx 	NSMantissa0+1
.a32b	a4 5a		ldy $5a				ldy 	NSMantissa0+2
.a32d	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a330	b0 02		bcs $a334			bcs 	_GfxError
.a332	7a		ply				ply 								; restore pos and exit.
.a333	60		rts				rts
.a334					_GfxError:
.a334	4c 50 9f	jmp $9f50			jmp 	RangeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/hit.asm

.a337					UnaryHit:
.a337	fa		plx				plx
.a338	a9 36		lda #$36			lda 	#zTemp0
.a33a	20 68 9d	jsr $9d68			jsr 	Evaluate8BitInteger 		; get sprite number 0
.a33d	20 af 8e	jsr $8eaf			jsr 	CheckComma
.a340	e8		inx				inx
.a341	20 68 9d	jsr $9d68			jsr 	Evaluate8BitInteger 		; get sprite number 1
.a344	20 a7 8e	jsr $8ea7			jsr		CheckRightBracket
.a347	ca		dex				dex 								; fix back up again.
.a348	da		phx				phx 								; save X/Y
.a349	5a		phy				phy
.a34a	b4 59		ldy $59,x			ldy 	NSMantissa0+1,x 			; get the sprite numbers into X/Y
.a34c	b5 58		lda $58,x			lda 	NSMantissa0,x
.a34e	aa		tax				tax
.a34f	a9 12		lda #$12			lda 	#GCMD_SpriteCollide 		; command check collision.
.a351	20 15 80	jsr $8015			jsr 	GXGraphicDraw 				; calculate result
.a354	1a		inc a				inc 	a 							; so 255 (fail) -> 0, otherwise 1,2,3,4 pixels etc.
.a355	7a		ply				ply 								; restore XY
.a356	fa		plx				plx
.a357	20 cf 9d	jsr $9dcf			jsr 	NSMSetByte 					; return the hit result
.a35a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/palette.asm

.a35b					PaletteCommand:
.a35b	a2 00		ldx #$00			ldx 	#0
.a35d	20 68 9d	jsr $9d68			jsr 	Evaluate8BitInteger 		; colour
.a360	20 af 8e	jsr $8eaf			jsr 	CheckComma
.a363	e8		inx				inx
.a364	20 4d 9d	jsr $9d4d			jsr 	Evaluate16BitInteger 		; r
.a367	20 af 8e	jsr $8eaf			jsr 	CheckComma
.a36a	e8		inx				inx
.a36b	20 68 9d	jsr $9d68			jsr 	Evaluate8BitInteger 		; g
.a36e	20 af 8e	jsr $8eaf			jsr 	CheckComma
.a371	e8		inx				inx
.a372	20 68 9d	jsr $9d68			jsr 	Evaluate8BitInteger 		; b
.a375	a5 58		lda $58				lda 	NSMantissa0 				; get colour #
.a377	85 36		sta $36				sta 	zTemp0
.a379	a9 34		lda #$34			lda 	#$D0 >> 2 					; MSB = D0/4
.a37b	85 37		sta $37				sta 	zTemp0+1
.a37d	06 36		asl $36				asl 	zTemp0 						; zTemp = $D000+Colour x 4
.a37f	26 37		rol $37				rol	 	zTemp0+1
.a381	06 36		asl $36				asl 	zTemp0
.a383	26 37		rol $37				rol	 	zTemp0+1
.a385	a9 01		lda #$01			lda 	#1 							; I/O Page 2
.a387	85 01		sta $01				sta 	1
.a389	5a		phy				phy
.a38a	a5 5b		lda $5b				lda 	NSMantissa0+3 				; fix to r,g,b
.a38c	92 36		sta ($36)			sta 	(zTemp0)
.a38e	a0 01		ldy #$01			ldy 	#1
.a390	a5 5a		lda $5a				lda 	NSMantissa0+2
.a392	91 36		sta ($36),y			sta 	(zTemp0),y
.a394	a5 59		lda $59				lda 	NSMantissa0+1
.a396	c8		iny				iny
.a397	91 36		sta ($36),y			sta 	(zTemp0),y
.a399	7a		ply				ply
.a39a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/event.asm

.a39b					UnaryEvent:
.a39b	fa		plx				plx
.a39c	20 49 a4	jsr $a449			jsr 	TimerToStackX 				; timer in +0
.a39f	e8		inx				inx  								; put reference into +1
.a3a0	20 0e 98	jsr $980e			jsr 	EvaluateTerm
.a3a3	b5 50		lda $50,x			lda 	NSStatus,x 					; check if is integer reference
.a3a5	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.a3a7	d0 4c		bne $a3f5			bne 	_UEType
.a3a9	e8		inx				inx 								; put the step in +2
.a3aa	20 af 8e	jsr $8eaf			jsr 	CheckComma
.a3ad	20 4d 9d	jsr $9d4d			jsr 	Evaluate16BitInteger
.a3b0	20 a7 8e	jsr $8ea7			jsr 	CheckRightBracket
.a3b3	ca		dex				dex
.a3b4	ca		dex				dex
.a3b5	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy reference to zTemp0
.a3b7	85 36		sta $36				sta 	zTemp0
.a3b9	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.a3bb	85 37		sta $37				sta 	zTemp0+1
.a3bd	5a		phy				phy
.a3be	a0 03		ldy #$03			ldy 	#3 							; check bit 7 of last bit, the packed sign bit
.a3c0	b1 36		lda ($36),y			lda 	(zTemp0),y
.a3c2	30 2d		bmi $a3f1			bmi 	_UEFalse 					; exit if signed.
.a3c4	a0 00		ldy #$00			ldy 	#0 							; has it timed out (24 bit)
.a3c6	b5 58		lda $58,x			lda 	NSMantissa0,x
.a3c8	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.a3ca	c8		iny				iny
.a3cb	b5 60		lda $60,x			lda 	NSMantissa1,x
.a3cd	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a3cf	c8		iny				iny
.a3d0	b5 68		lda $68,x			lda 	NSMantissa2,x
.a3d2	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a3d4	90 1b		bcc $a3f1			bcc 	_UEFalse 					; no, return FALSE.
.a3d6	18		clc				clc
.a3d7	a0 00		ldy #$00			ldy 	#0 							; work out new value as timer() + step
.a3d9	b5 58		lda $58,x			lda 	NSMantissa0,x
.a3db	75 5a		adc $5a,x			adc 	NSMantissa0+2,x
.a3dd	91 36		sta ($36),y			sta 	(zTemp0),y
.a3df	c8		iny				iny
.a3e0	b5 60		lda $60,x			lda 	NSMantissa1,x
.a3e2	75 62		adc $62,x			adc 	NSMantissa1+2,x
.a3e4	91 36		sta ($36),y			sta 	(zTemp0),y
.a3e6	c8		iny				iny
.a3e7	b5 68		lda $68,x			lda 	NSMantissa2,x
.a3e9	75 6a		adc $6a,x			adc 	NSMantissa2+2,x
.a3eb	91 36		sta ($36),y			sta 	(zTemp0),y
.a3ed	7a		ply				ply
.a3ee	4c 2d 8f	jmp $8f2d			jmp 	ReturnTrue
.a3f1					_UEFalse:
.a3f1	7a		ply				ply 								; restore Y
.a3f2	4c 38 8f	jmp $8f38			jmp 	ReturnFalse 				; and return False
.a3f5					_UEType:
.a3f5	4c 55 9f	jmp $9f55			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/joy.asm

.a3f8					UnaryJoyX:
.a3f8	18		clc				clc
.a3f9	80 01		bra $a3fc			bra 	JoyMain
.a3fb					UnaryJoyY:
.a3fb	38		sec				sec
.a3fc					JoyMain:
.a3fc	fa		plx				plx 								; get pos
.a3fd	08		php				php 								; save carry (set for Y)
.a3fe	20 68 9d	jsr $9d68			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a401	20 a7 8e	jsr $8ea7			jsr 	CheckRightBracket
.a404	20 0f 80	jsr $800f			jsr 	EXTReadController 			; read the controller.
.a407	28		plp				plp
.a408	90 02		bcc $a40c			bcc 	_JMNoShift 					; if Y then shift bits 3,2 -> 1,0
.a40a	4a		lsr a				lsr 	a
.a40b	4a		lsr a				lsr 	a
.a40c					_JMNoShift:
.a40c	4a		lsr a				lsr 	a 							; if bit 0 set then right/down e.g. +1
.a40d	b0 0a		bcs $a419			bcs 	_JMIsRight
.a40f	4a		lsr a				lsr 	a 							; if bit 1 set then left/up e.g. -1
.a410	b0 04		bcs $a416			bcs 	_JMIsLeft
.a412	20 cd 9d	jsr $9dcd			jsr 	NSMSetZero 					; zero result
.a415	60		rts				rts
.a416					_JMIsLeft:
.a416	4c 2d 8f	jmp $8f2d			jmp 	ReturnTrue
.a419					_JMIsRight:
.a419	a9 01		lda #$01			lda 	#1
.a41b	20 cf 9d	jsr $9dcf			jsr 	NSMSetByte
.a41e	60		rts				rts
.a41f					UnaryJoyB:
.a41f	fa		plx				plx 								; get pos
.a420	20 68 9d	jsr $9d68			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a423	20 a7 8e	jsr $8ea7			jsr 	CheckRightBracket
.a426	20 0f 80	jsr $800f			jsr 	EXTReadController 			; read the controller.
.a429	4a		lsr a				lsr 	a
.a42a	4a		lsr a				lsr 	a
.a42b	4a		lsr a				lsr 	a
.a42c	4a		lsr a				lsr 	a
.a42d	29 01		and #$01			and 	#1
.a42f	20 cf 9d	jsr $9dcf			jsr 	NSMSetByte
.a432	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/load.asm

.a433					LoadCommand:
.a433	20 a1 89	jsr $89a1			jsr 	NewProgram
.a436	20 e0 82	jsr $82e0			jsr 	BackLoadProgram
.a439	4c 78 83	jmp $8378			jmp 	WarmStart
.a43c					GoCommand:
.a43c	20 a1 89	jsr $89a1			jsr 	NewProgram
.a43f	20 e0 82	jsr $82e0			jsr 	BackLoadProgram
.a442	4c e2 8a	jmp $8ae2			jmp 	CommandRun

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/timer.asm

.a445					UnaryTimer:
.a445	fa		plx				plx
.a446	20 a7 8e	jsr $8ea7			jsr 	CheckRightBracket
.a449					TimerToStackX:
.a449	20 cd 9d	jsr $9dcd			jsr 	NSMSetZero 					; zero result
.a44c	64 01		stz $01				stz 	1 							; access I/O
.a44e	ad 59 d6	lda $d659			lda 	$D659 						; copy timer in
.a451	95 58		sta $58,x			sta 	NSMantissa0,x
.a453	ad 5a d6	lda $d65a			lda 	$D65A
.a456	95 60		sta $60,x			sta 	NSMantissa1,x
.a458	ad 5b d6	lda $d65b			lda 	$D65B
.a45b	95 68		sta $68,x			sta 	NSMantissa2,x
.a45d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/delete.asm

.a45e					MemoryDeleteLine:
.a45e	20 7d a4	jsr $a47d			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a461	b2 30		lda ($30)			lda 	(codePtr) 					; size to delete => y
.a463	a8		tay				tay
.a464					_MDDLLoop:
.a464	b1 30		lda ($30),y			lda 	(codePtr),y 				; copy down
.a466	92 30		sta ($30)			sta 	(codePtr)
.a468	a5 30		lda $30				lda 	codePtr 					; check done the lot.
.a46a	c5 3a		cmp $3a				cmp 	zTemp2
.a46c	d0 07		bne $a475			bne 	_MDLDLNext
.a46e	a5 31		lda $31				lda 	codePtr+1
.a470	c5 3b		cmp $3b				cmp 	zTemp2+1
.a472	d0 01		bne $a475			bne 	_MDLDLNext
.a474					_MDDLExit:
.a474	60		rts				rts
.a475					_MDLDLNext:
.a475	e6 30		inc $30				inc 	codePtr						; next byte
.a477	d0 eb		bne $a464			bne 	_MDDLLoop
.a479	e6 31		inc $31				inc 	codePtr+1
.a47b	80 e7		bra $a464			bra 	_MDDLLoop
.a47d					IMemoryFindEnd:
.a47d	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a47f	85 3a		sta $3a				sta 	0+zTemp2
.a481	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a483	85 3b		sta $3b				sta 	1+zTemp2
.a485					_MDLFELoop:
.a485	b2 3a		lda ($3a)			lda 	(zTemp2)
.a487	f0 0b		beq $a494			beq 	_MDLFEExit
.a489	18		clc				clc
.a48a	65 3a		adc $3a				adc 	zTemp2
.a48c	85 3a		sta $3a				sta 	zTemp2
.a48e	90 f5		bcc $a485			bcc 	_MDLFELoop
.a490	e6 3b		inc $3b				inc 	zTemp2+1
.a492	80 f1		bra $a485			bra 	_MDLFELoop
.a494					_MDLFEExit:
.a494	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/insert.asm

.a495					MemoryInsertLine:
.a495	08		php				php
.a496	20 7d a4	jsr $a47d			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a499	a5 3b		lda $3b				lda 	zTemp2+1 					; space ?
.a49b	1a		inc a				inc 	a
.a49c	c9 7f		cmp #$7f			cmp 	#(BasicEnd >> 8)-1
.a49e	b0 36		bcs $a4d6			bcs 	_MDLIError
.a4a0	28		plp				plp
.a4a1	90 08		bcc $a4ab			bcc 	_MDLIFound
.a4a3	a5 3a		lda $3a				lda 	zTemp2 						; if CS on entry append.
.a4a5	85 30		sta $30				sta 	codePtr
.a4a7	a5 3b		lda $3b				lda 	zTemp2+1
.a4a9	85 31		sta $31				sta 	codePtr+1
.a4ab					_MDLIFound:
.a4ab	ad 2a 04	lda $042a			lda 	tokenOffset 				; insert gap in Y, the offset, e.g. length of the new line
.a4ae	a8		tay				tay
.a4af					_MDLIInsert:
.a4af	b2 3a		lda ($3a)			lda 	(zTemp2) 					; shift one byte up , at least one covers end case.
.a4b1	91 3a		sta ($3a),y			sta 	(zTemp2),y 					; work from top down.
.a4b3	a5 30		lda $30				lda 	codePtr 					; done insert point ?
.a4b5	c5 3a		cmp $3a				cmp 	zTemp2
.a4b7	d0 06		bne $a4bf			bne 	_MDLINext
.a4b9	a5 31		lda $31				lda 	codePtr+1
.a4bb	c5 3b		cmp $3b				cmp 	zTemp2+1
.a4bd	f0 0a		beq $a4c9			beq 	_MDLIHaveSpace
.a4bf					_MDLINext:
.a4bf	a5 3a		lda $3a				lda 	zTemp2 						; if no, keep zTemp2 going backwards
.a4c1	d0 02		bne $a4c5			bne 	_MDLINoBorrow
.a4c3	c6 3b		dec $3b				dec 	zTemp2+1
.a4c5					_MDLINoBorrow:
.a4c5	c6 3a		dec $3a				dec 	zTemp2
.a4c7	80 e6		bra $a4af			bra 	_MDLIInsert
.a4c9					_MDLIHaveSpace:
.a4c9	ac 2a 04	ldy $042a			ldy 	tokenOffset 				; bytes to copy
.a4cc	88		dey				dey 								; from offset-1 to 0
.a4cd					_MDLICopy:
.a4cd	b9 2a 04	lda $042a,y			lda 	tokenOffset,y
.a4d0	91 30		sta ($30),y			sta 	(codePtr),y
.a4d2	88		dey				dey
.a4d3	10 f8		bpl $a4cd			bpl 	_MDLICopy
.a4d5	60		rts				rts
.a4d6					_MDLIError:
.a4d6	a9 06		lda #$06		lda	#6
.a4d8	4c c0 8e	jmp $8ec0		jmp	ErrorHandler
.a4db					MDLAppendLine:
.a4db	86 37		stx $37				stx 	zTemp0+1 					; save new line at zTemp0
.a4dd	85 36		sta $36				sta 	zTemp0
.a4df	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a4e1	85 38		sta $38				sta 	0+zTemp1
.a4e3	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a4e5	85 39		sta $39				sta 	1+zTemp1
.a4e7	b2 38		lda ($38)			lda 	(zTemp1)
.a4e9	d0 0a		bne $a4f5			bne 	_MDLANoInitialise
.a4eb	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a4ed	8d b8 05	sta $05b8			sta 	0+AppendPointer
.a4f0	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a4f2	8d b9 05	sta $05b9			sta 	1+AppendPointer
.a4f5					_MDLANoInitialise:
.a4f5	18		clc				clc
.a4f6	ad b8 05	lda $05b8			lda 	AppendPointer 				; copy append pointer to zTemp1 adding the offset as you go
.a4f9	85 38		sta $38				sta 	zTemp1
.a4fb	72 36		adc ($36)			adc 	(zTemp0)
.a4fd	8d b8 05	sta $05b8			sta 	AppendPointer
.a500	ad b9 05	lda $05b9			lda 	AppendPointer+1
.a503	85 39		sta $39				sta 	zTemp1+1
.a505	69 00		adc #$00			adc 	#0
.a507	8d b9 05	sta $05b9			sta 	AppendPointer+1
.a50a	a0 00		ldy #$00			ldy 	#0
.a50c					_MDLACopy:
.a50c	b1 36		lda ($36),y			lda 	(zTemp0),y 					; copy new line in
.a50e	91 38		sta ($38),y			sta 	(zTemp1),y
.a510	c8		iny				iny
.a511	98		tya				tya
.a512	d2 36		cmp ($36)			cmp 	(zTemp0) 					; done whole line
.a514	d0 f6		bne $a50c			bne 	_MDLACopy
.a516	a9 00		lda #$00			lda 	#0 							; end of program.
.a518	91 38		sta ($38),y			sta 	(zTemp1),y
.a51a	60		rts				rts
.05b8					AppendPointer:
>05b8							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/memory.asm

.a51b					MemoryNew:
.a51b	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a51d	85 30		sta $30				sta 	codePtr
.a51f	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a521	85 31		sta $31				sta 	codePtr+1
.a523	a9 00		lda #$00			lda 	#0 							; write zero there erasing the program.
.a525	92 30		sta ($30)			sta 	(codePtr)
.a527	60		rts				rts
.a528					MemoryInline:
.a528	98		tya				tya 								; put address into stack,x
.a529	18		clc				clc  								; get the offset, add codePtr
.a52a	65 30		adc $30				adc 	codePtr
.a52c	95 58		sta $58,x			sta 	NSMantissa0,x 				; store the result in the mantissa.
.a52e	a5 31		lda $31				lda 	codePtr+1
.a530	69 00		adc #$00			adc 	#0
.a532	95 60		sta $60,x			sta 	NSMantissa1,x
.a534	74 68		stz $68,x			stz 	NSMantissa2,x
.a536	74 70		stz $70,x			stz 	NSMantissa3,x
.a538	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/search.asm

.a539					MemorySearch:
.a539	85 36		sta $36				sta 	zTemp0 						; save line number in zTemp0
.a53b	86 37		stx $37				stx 	zTemp0+1
.a53d	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a53f	85 30		sta $30				sta 	codePtr
.a541	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a543	85 31		sta $31				sta 	codePtr+1
.a545					_MTAXLoop:
.a545	b2 30		lda ($30)			lda 	(codePtr)
.a547	18		clc				clc
.a548	f0 21		beq $a56b			beq 	_MTAXExit 					; reached end, exit with CC.
.a54a	a0 01		ldy #$01			ldy 	#1 							; calculate current line# - requested line#
.a54c	b1 30		lda ($30),y			lda 	(codePtr),y
.a54e	38		sec				sec
.a54f	e5 36		sbc $36				sbc 	zTemp0
.a551	85 38		sta $38				sta 	zTemp1 						; save interim to set Z
.a553	c8		iny				iny 								; do the MSB
.a554	b1 30		lda ($30),y			lda 	(codePtr),y
.a556	e5 37		sbc $37				sbc 	zTemp0+1
.a558	05 38		ora $38				ora 	zTemp1 						; will set Z if result is zero, doesn't affect carry flag
.a55a	f0 0f		beq $a56b			beq 	_MTAXExit	 				; found so exit (CS will be set)
.a55c	b0 0d		bcs $a56b			bcs 	_MTAXExit 					; current < required exit
.a55e	18		clc				clc
.a55f	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.a561	65 30		adc $30				adc 	codePtr
.a563	85 30		sta $30				sta 	codePtr
.a565	90 02		bcc $a569			bcc 	_CREExit
.a567	e6 31		inc $31				inc 	codePtr+1 					; carry
.a569					_CREExit:
.a569	80 da		bra $a545			bra 	_MTAXLoop
.a56b					_MTAXExit:
.a56b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/playing.asm

.a56c					UnaryPlaying:
.a56c	fa		plx				plx
.a56d	20 68 9d	jsr $9d68			jsr 	Evaluate8BitInteger 		; get channel #
.a570	48		pha				pha
.a571	20 a7 8e	jsr $8ea7			jsr		CheckRightBracket
.a574	68		pla				pla
.a575	c9 04		cmp #$04			cmp 	#4
.a577	b0 0c		bcs $a585			bcs 	_UPNotPlaying
.a579	09 20		ora #$20			ora 	#$20 						; query playing ?
.a57b	20 18 80	jsr $8018			jsr 	SNDCommand
.a57e	c9 00		cmp #$00			cmp 	#0
.a580	f0 03		beq $a585			beq 	_UPNotPlaying
.a582	4c 2d 8f	jmp $8f2d			jmp 	ReturnTrue
.a585					_UPNotPlaying:
.a585	4c 38 8f	jmp $8f38			jmp 	ReturnFalse

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/sound.asm

.a588					SoundCommand:
.a588	b1 30		lda ($30),y			lda 	(codePtr),y
.a58a	c9 c0		cmp #$c0			cmp 	#KWD_OFF 					; SOUND OFF ?
.a58c	d0 09		bne $a597			bne 	_SNDMain
.a58e	c8		iny				iny 								; skip OFF
.a58f	a9 3f		lda #$3f			lda 	#$3F 						; call command $3F (silence)
.a591	5a		phy				phy
.a592	20 18 80	jsr $8018			jsr 	SNDCommand
.a595	7a		ply				ply
.a596	60		rts				rts
.a597					_SNDMain:
.a597	a2 00		ldx #$00			ldx 	#0
.a599	20 68 9d	jsr $9d68			jsr 	Evaluate8BitInteger 		; channel
.a59c	c9 04		cmp #$04			cmp 	#4 							; must be 0-3
.a59e	b0 4b		bcs $a5eb			bcs 	_SndError
.a5a0	e8		inx				inx 								; do the rest in slot 1.
.a5a1	20 af 8e	jsr $8eaf			jsr 	CheckComma
.a5a4	20 4d 9d	jsr $9d4d			jsr 	Evaluate16BitInteger 		; Pitch
.a5a7	b5 60		lda $60,x			lda 	NSMantissa1,x 				; must be 10 bit
.a5a9	c9 10		cmp #$10			cmp 	#16
.a5ab	b0 3e		bcs $a5eb			bcs 	_SndError
.a5ad	8d bb 05	sta $05bb			sta 	SoundCommandBlock+1 		; Pitch (2 bytes + 0)
.a5b0	b5 58		lda $58,x			lda 	NSMantissa0,x
.a5b2	8d ba 05	sta $05ba			sta 	SoundCommandBlock
.a5b5	20 af 8e	jsr $8eaf			jsr 	CheckComma
.a5b8	20 68 9d	jsr $9d68			jsr 	Evaluate8BitInteger 		; Length (1 byte + 3)
.a5bb	8d bd 05	sta $05bd			sta 	SoundCommandBlock+3
.a5be	a9 0f		lda #$0f			lda 	#15
.a5c0	8d bc 05	sta $05bc			sta 	SoundCommandBlock+2 		; Volume (1 byte + 2)
.a5c3	9c be 05	stz $05be			stz 	SoundCommandBlock+4 		; default slide (2 bytes +4)
.a5c6	9c bf 05	stz $05bf			stz 	SoundCommandBlock+5
.a5c9	b1 30		lda ($30),y			lda 	(codePtr),y
.a5cb	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.a5cd	d0 0e		bne $a5dd			bne 	_SNDPlay
.a5cf	c8		iny				iny
.a5d0	20 57 9d	jsr $9d57			jsr 	Evaluate16BitIntegerSigned 	; Slide
.a5d3	b5 58		lda $58,x			lda 	NSMantissa0,x 				; Slide (2 bytes + 4)
.a5d5	8d be 05	sta $05be			sta 	SoundCommandBlock+4
.a5d8	b5 60		lda $60,x			lda 	NSMantissa1,x
.a5da	8d bf 05	sta $05bf			sta 	SoundCommandBlock+5
.a5dd					_SNDPlay:
.a5dd	5a		phy				phy
.a5de	a5 58		lda $58				lda 	NSMantissa0 				; channel.
.a5e0	09 10		ora #$10			ora 	#$10 						; 1x = Queue sound
.a5e2	a2 ba		ldx #$ba			ldx 	#(SoundCommandBlock & $FF)
.a5e4	a0 05		ldy #$05			ldy 	#(SoundCommandBlock >> 8)
.a5e6	20 18 80	jsr $8018			jsr 	SNDCommand
.a5e9	7a		ply				ply
.a5ea	60		rts				rts
.a5eb					_SndError:
.a5eb	4c 50 9f	jmp $9f50			jmp 	RangeError
.05ba					SoundCommandBlock:
>05ba							.fill 	6

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/bytes.asm

.a5ee					StackPushByte:
.a5ee	48		pha				pha 								; save byte on stack
.a5ef	a5 34		lda $34				lda 	BasicStack 					; decrement basic stack pointer
.a5f1	d0 08		bne $a5fb			bne 	_SPBNoBorrow
.a5f3	c6 35		dec $35				dec 	BasicStack+1 				; borrow
.a5f5	a5 35		lda $35				lda 	BasicStack+1 				; check range.
.a5f7	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a5f9	90 06		bcc $a601			bcc 	_SPBMemory
.a5fb					_SPBNoBorrow:
.a5fb	c6 34		dec $34				dec 	BasicStack
.a5fd	68		pla				pla 								; get back and write
.a5fe	92 34		sta ($34)			sta 	(BasicStack)
.a600	60		rts				rts
.a601					_SPBMemory:
.a601	a9 12		lda #$12		lda	#18
.a603	4c c0 8e	jmp $8ec0		jmp	ErrorHandler
.a606					StackPopByte:
.a606	b2 34		lda ($34)			lda 	(BasicStack) 				; bump the stack pointer.
.a608	e6 34		inc $34				inc 	BasicStack
.a60a	d0 02		bne $a60e			bne 	_SPBNoCarry
.a60c	e6 35		inc $35				inc 	BasicStack+1
.a60e					_SPBNoCarry:
.a60e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/frames.asm

.a60f					StackOpen:
.a60f	48		pha				pha 								; save frame byte
.a610	29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.a612	0a		asl a				asl 	a 							; claim twice this for storage
.a613	49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.a615	38		sec				sec 								; so basically subtracting from
.a616	65 34		adc $34				adc 	basicStack 	 				; basicStack
.a618	85 34		sta $34				sta 	basicStack
.a61a	b0 09		bcs $a625			bcs 	_SONoBorrow
>a61c	db						.byte 	$DB 						; causes a break in the emulator
.a61d	c6 35		dec $35				dec 	basicStack+1
.a61f	a5 35		lda $35				lda 	basicStack+1 				; have we reached stack overflow
.a621	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a623	90 04		bcc $a629			bcc 	_SOMemory
.a625					_SONoBorrow:
.a625	68		pla				pla 								; get marker back and write at TOS
.a626	92 34		sta ($34)			sta 	(basicStack)
.a628	60		rts				rts
.a629					_SOMemory:
.a629	a9 12		lda #$12		lda	#18
.a62b	4c c0 8e	jmp $8ec0		jmp	ErrorHandler
.a62e					StackClose:
.a62e	b2 34		lda ($34)			lda 	(basicStack) 				; get TOS marker
.a630	29 0f		and #$0f			and 	#$0F 						; bytes to add back
.a632	0a		asl a				asl 	a 							; claim twice this.
.a633	65 34		adc $34				adc 	basicStack 					; add to the stack pointer.
.a635	85 34		sta $34				sta 	basicStack
.a637	90 02		bcc $a63b			bcc 	_SCExit
.a639	e6 35		inc $35				inc 	basicStack+1
.a63b					_SCExit:
.a63b	60		rts				rts
.a63c					StackCheckFrame:
.a63c	48		pha				pha
.a63d					_StackRemoveLocals:
.a63d	b2 34		lda ($34)			lda 	(basicStack) 				; check for local, keep popping them
.a63f	c9 03		cmp #$03			cmp 	#STK_LOCALS+1 				; is the frame a local ? S or N are 1/0
.a641	b0 05		bcs $a648			bcs 	_SCNoLocal
.a643	20 50 89	jsr $8950			jsr 	LocalPopValue 				; restore the local value
.a646	80 f5		bra $a63d			bra 	_StackRemoveLocals 			; gr round again
.a648					_SCNoLocal:
.a648	68		pla				pla 								; get the frame check.
.a649	52 34		eor ($34)			eor 	(basicStack) 				; xor with toS marker
.a64b	29 f0		and #$f0			and 	#$F0 						; check type bits
.a64d	d0 01		bne $a650			bne 	_SCFError 					; different, we have structures mixed up
.a64f	60		rts				rts
.a650					_SCFError:
.a650	8a		txa				txa 								; report error X
.a651	4c c0 8e	jmp $8ec0			jmp 	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/location.asm

.a654					STKSaveCodePosition:
.a654	5a		phy				phy
.a655	98		tya				tya 								; save Y
.a656	a0 05		ldy #$05			ldy 	#5
.a658	91 34		sta ($34),y			sta 	(basicStack),y
.a65a	88		dey				dey 								; save Code Pointer
.a65b					_STKSaveLoop:
.a65b	b9 2f 00	lda $002f,y			lda 	safePtr-1,y 				; allows us to access the pointer w/out issues.
.a65e	91 34		sta ($34),y			sta 	(basicStack),y
.a660	88		dey				dey
.a661	d0 f8		bne $a65b			bne 	_STKSaveLoop
.a663	7a		ply				ply
.a664	60		rts				rts
.a665					STKLoadCodePosition:
.a665	a0 01		ldy #$01			ldy 	#1 							; load code pointer back
.a667					_STKLoadLoop:
.a667	b1 34		lda ($34),y			lda 	(basicStack),y
.a669	99 2f 00	sta $002f,y			sta 	safePtr-1,y
.a66c	c8		iny				iny
.a66d	c0 05		cpy #$05			cpy 	#5
.a66f	d0 f6		bne $a667			bne 	_STKLoadLoop
.a671	b1 34		lda ($34),y			lda 	(basicStack),y 				; get Y offset
.a673	a8		tay				tay
.a674	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/setup.asm

.a675					StackReset:
.a675	a9 ff		lda #$ff			lda 	#((BasicStackBase+BasicStackSize-1) & $FF)
.a677	85 34		sta $34				sta 	0+basicStack
.a679	a9 0f		lda #$0f			lda 	#((BasicStackBase+BasicStackSize-1) >> 8)
.a67b	85 35		sta $35				sta 	1+basicStack
.a67d	a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.a67f	92 34		sta ($34)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.a681	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/concrete.asm

.a682					StringConcrete:
.a682	5a		phy				phy 								; save position on stack
.a683	20 f5 99	jsr $99f5			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a686	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy target string to zTemp1
.a688	85 38		sta $38				sta 	zTemp1
.a68a	b5 60		lda $60,x			lda 	NSMantissa1,x
.a68c	85 39		sta $39				sta 	zTemp1+1
.a68e	a0 ff		ldy #$ff			ldy 	#$FF	 					; calculate string length
.a690					_SALength:
.a690	c8		iny				iny
.a691	b1 38		lda ($38),y			lda 	(zTemp1),y
.a693	d0 fb		bne $a690			bne 	_SALength
.a695	c0 fd		cpy #$fd			cpy 	#253 						; string too long - cannot concrete.
.a697	b0 3d		bcs $a6d6			bcs 	_SALengthError
.a699	98		tya				tya 				 				; length of the new string
.a69a	18		clc				clc
.a69b	69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.a69d	90 02		bcc $a6a1			bcc 	_SAHaveLength
.a69f	a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.a6a1					_SAHaveLength:
.a6a1	48		pha				pha 								; save length.
.a6a2	38		sec				sec
.a6a3	49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.a6a5	6d 0e 04	adc $040e			adc 	StringMemory
.a6a8	8d 0e 04	sta $040e			sta 	StringMemory
.a6ab	85 3a		sta $3a				sta 	zTemp2 						; update storage address
.a6ad	95 58		sta $58,x			sta 	NSMantissa0,x 				; update mantissa address
.a6af	a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.a6b1	6d 0f 04	adc $040f			adc 	StringMemory+1
.a6b4	8d 0f 04	sta $040f			sta 	StringMemory+1
.a6b7	85 3b		sta $3b				sta 	zTemp2+1
.a6b9	95 60		sta $60,x			sta 	NSMantissa1,x
.a6bb	68		pla				pla 								; save length-3 (chars allowed) in first byte
.a6bc	38		sec				sec
.a6bd	e9 03		sbc #$03			sbc 	#3
.a6bf	92 3a		sta ($3a)			sta 	(zTemp2)
.a6c1	a9 00		lda #$00			lda 	#0 							; clear the status byte.
.a6c3	a0 01		ldy #$01			ldy 	#1
.a6c5	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a6c7					_SACopyNewString:
.a6c7	a0 00		ldy #$00			ldy 	#0
.a6c9					_SACopyNSLoop:
.a6c9	b1 38		lda ($38),y			lda 	(zTemp1),y 					; get character
.a6cb	c8		iny				iny 								; write two on in string storage
.a6cc	c8		iny				iny
.a6cd	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a6cf	88		dey				dey 								; this makes it one one.
.a6d0	c9 00		cmp #$00			cmp 	#0 							; until EOS copied
.a6d2	d0 f5		bne $a6c9			bne 	_SACopyNSLoop
.a6d4	7a		ply				ply
.a6d5	60		rts				rts
.a6d6					_SALengthError:
.a6d6	a9 09		lda #$09		lda	#9
.a6d8	4c c0 8e	jmp $8ec0		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/stringalloc.asm

.a6db					StringSystemInitialise:
.a6db	a9 ff		lda #$ff			lda 	#((EndVariableSpace-1) & $FF)
.a6dd	8d 0e 04	sta $040e			sta 	0+StringMemory
.a6e0	a9 1f		lda #$1f			lda 	#((EndVariableSpace-1) >> 8)
.a6e2	8d 0f 04	sta $040f			sta 	1+StringMemory
.a6e5	9c ff 1f	stz $1fff			stz 	EndVariableSpace-1 			; put a zero at the end, so know end of string memory.
.a6e8	60		rts				rts
.a6e9					StringSpaceInitialise:
.a6e9	20 f5 99	jsr $99f5			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a6ec	a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.a6ee	8d 10 04	sta $0410			sta 	StringInitialised
.a6f1	ad 0e 04	lda $040e			lda 	StringMemory 				; allocate 256 bytes for one concreted string
.a6f4	8d 11 04	sta $0411			sta 	StringTempPointer 			; so temporary string space is allocated below that.
.a6f7	ad 0f 04	lda $040f			lda 	StringMemory+1
.a6fa	3a		dec a				dec 	a
.a6fb	8d 12 04	sta $0412			sta 	StringTempPointer+1
.a6fe	60		rts				rts
.a6ff					StringTempAllocate:
.a6ff	c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.a701	b0 30		bcs $a733			bcs 	_STALength
.a703	2c 10 04	bit $0410			bit 	StringInitialised 			; already initialised
.a706	30 05		bmi $a70d			bmi 	_STAAllocate
.a708	48		pha				pha 								; save value to subtract.
.a709	20 e9 a6	jsr $a6e9			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.a70c	68		pla				pla 								; restore it
.a70d					_STAAllocate:
.a70d	49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.a70f	18		clc				clc  								; deliberate allows one more
.a710	6d 11 04	adc $0411			adc 	StringTempPointer 			; subtract from temp pointer
.a713	8d 11 04	sta $0411			sta 	StringTempPointer
.a716	95 58		sta $58,x			sta 	NSMantissa0,x 				; address in mantissa
.a718	85 3c		sta $3c				sta 	zsTemp 						; and zsTemp
.a71a	ad 12 04	lda $0412			lda 	StringTempPointer+1
.a71d	69 ff		adc #$ff			adc 	#$FF
.a71f	8d 12 04	sta $0412			sta 	StringTempPointer+1
.a722	85 3d		sta $3d				sta 	zsTemp+1
.a724	95 60		sta $60,x			sta 	NSMantissa1,x
.a726	74 68		stz $68,x			stz 	NSMantissa2,x 				; set the typing data and the upper address bytes.
.a728	74 70		stz $70,x			stz 	NSMantissa3,x
.a72a	a9 10		lda #$10			lda 	#NSTString
.a72c	95 50		sta $50,x			sta 	NSStatus,x
.a72e	a9 00		lda #$00			lda 	#0 							; clear the target string
.a730	92 3c		sta ($3c)			sta 	(zsTemp)
.a732	60		rts				rts
.a733					_STALength:
.a733	a9 09		lda #$09		lda	#9
.a735	4c c0 8e	jmp $8ec0		jmp	ErrorHandler
.a738					StringTempWrite:
.a738	48		pha				pha
.a739	92 3c		sta ($3c)			sta 	(zsTemp) 					; write byte
.a73b	e6 3c		inc $3c				inc 	zsTemp 						; bump pointer
.a73d	d0 02		bne $a741			bne 	_STWNoCarry
.a73f	e6 3d		inc $3d				inc 	zsTemp+1
.a741					_STWNoCarry:
.a741	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.a743	92 3c		sta ($3c)			sta 	(zsTemp)
.a745	68		pla				pla
.a746	60		rts				rts

;******  Return to file: _basic.asm

.a747					StartModuleCode:

;******  Processing file: ../modules/_build/_hardware.module

=1					hardwareIntegrated=1
=0					CONBlack = 0
=1					CONWhite = 1
=2					CONRed = 2
=3					CONCyan = 3
=4					CONPurple = 4
=5					CONGreen = 5
=6					CONBlue = 6
=7					CONYellow = 7
=8					CONOrange = 8
=9					CONBrown = 9
=10					CONYellowGreen = 10
=11					CONRosa = 11
=12					CONBlueGreen = 12
=13					CONLightBlue = 13
=14					CONPink = 14
=15					CONLightGreen = 15
=7					CONForeground = CONYellow
=6					CONBackground = CONBlue
=5					CLICommandLine = CONGreen
=0					CLIFComment = CONBlack
=7					CLIBComment = CONYellow
=9					CLILineNumber = CONBrown
=3					CLIToken = CONCyan
=13					CLIConstant = CONLightBlue
=7					CLIIdentifier = CONYellow
=10					CLIPunctuation = CONYellowGreen
=1					CLIData = CONWhite
.a747					Export_EXTPrintCharacter:
.a747					PAGEDPrintCharacter:
.a747	48		pha				pha
.a748	da		phx				phx
.a749	5a		phy				phy
.a74a	a6 01		ldx $01				ldx 	1
.a74c	da		phx				phx
.a74d	ac c1 05	ldy $05c1			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.a750	09 00		ora #$00			ora 	#$00 						; check $80-$FF
.a752	30 48		bmi $a79c			bmi 	_EXPCColour
.a754	c9 20		cmp #$20			cmp 	#$20 						; check $00-$1F
.a756	90 4d		bcc $a7a5			bcc 	_EXPCControl
.a758	a2 02		ldx #$02			ldx 	#2 							; select char memory
.a75a	86 01		stx $01				stx 	1
.a75c	91 40		sta ($40),y			sta 	(EXTAddress),y
.a75e	e6 01		inc $01				inc 	1 							; select colour memory
.a760	ad c2 05	lda $05c2			lda 	EXTTextColour
.a763	91 40		sta ($40),y			sta 	(EXTAddress),y
.a765	c8		iny				iny 								; advance horizontal position
.a766	8c c1 05	sty $05c1			sty 	EXTColumn
.a769	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth 				; reached RHS ?
.a76c	90 63		bcc $a7d1			bcc 	_EXPCExit 					; no, then exit.
.a76e					_EXPCCRLF:
.a76e	ee c0 05	inc $05c0			inc 	EXTRow  					; bump row
.a771	9c c1 05	stz $05c1			stz 	EXTColumn 					; back to column 0
.a774	ad c0 05	lda $05c0			lda 	EXTRow 						; check if reached the bottom ?
.a777	cd c4 05	cmp $05c4			cmp 	EXTScreenHeight 			; if so, then scroll.
.a77a	f0 18		beq $a794			beq 	_EXPCScroll
.a77c	18		clc				clc 								; add width to address.
.a77d	a5 40		lda $40				lda 	EXTAddress
.a77f	6d c3 05	adc $05c3			adc 	EXTScreenWidth
.a782	85 40		sta $40				sta 	EXTAddress
.a784	90 4b		bcc $a7d1			bcc 	_EXPCExit
.a786	e6 41		inc $41				inc 	EXTAddress+1
.a788	80 47		bra $a7d1			bra 	_EXPCExit
.a78a					_EXPCLeft:
.a78a	ce c1 05	dec $05c1			dec 	EXTColumn
.a78d	10 42		bpl $a7d1			bpl 	_EXPCExit
.a78f					_EXPCBegin:
.a78f	9c c1 05	stz $05c1			stz 	EXTColumn
.a792	80 3d		bra $a7d1			bra 	_EXPCExit
.a794					_EXPCScroll:
.a794	ce c0 05	dec $05c0			dec 	EXTRow 						; the height-1 th line.
.a797	20 82 a8	jsr $a882			jsr 	EXTScreenScroll 			; scroll the screen
.a79a	80 35		bra $a7d1			bra 	_EXPCExit
.a79c					_EXPCColour:
.a79c	c9 a0		cmp #$a0			cmp 	#$A0						; 80-9F set foreground/background
.a79e	b0 31		bcs $a7d1			bcs 	_EXPCExit
.a7a0	20 62 a8	jsr $a862			jsr 	_EXPCHandleColour
.a7a3	80 2c		bra $a7d1			bra 	_EXPCExit
.a7a5					_EXPCControl:
.a7a5	c9 11		cmp #$11			cmp 	#$11 						; only handle 00-10.
.a7a7	b0 28		bcs $a7d1			bcs 	_EXPCExit
.a7a9	0a		asl a				asl 	a 							; double into X
.a7aa	aa		tax				tax
.a7ab	7c 40 a8	jmp ($a840,x)			jmp 	(_EXPCActionTable,x) 		; and execute code.
.a7ae					_EXPCUp:
.a7ae	ad c0 05	lda $05c0			lda 	EXTRow 						; already at top ?
.a7b1	f0 1e		beq $a7d1			beq 	_EXPCExit
.a7b3	ce c0 05	dec $05c0			dec 	EXTRow 						; up one in position/address
.a7b6	38		sec				sec
.a7b7	a5 40		lda $40				lda 	EXTAddress
.a7b9	ed c3 05	sbc $05c3			sbc 	EXTScreenWidth
.a7bc	85 40		sta $40				sta 	EXTAddress
.a7be	b0 11		bcs $a7d1			bcs 	_EXPCExit
.a7c0	c6 41		dec $41				dec 	EXTAddress+1
.a7c2	80 0d		bra $a7d1			bra 	_EXPCExit
.a7c4					_EXPCRight:
.a7c4	c8		iny				iny
.a7c5	8c c1 05	sty $05c1			sty 	EXTColumn
.a7c8	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth
.a7cb	d0 04		bne $a7d1			bne 	_EXPCExit
.a7cd	88		dey				dey
.a7ce					_EXPCSetColumnY:
.a7ce	8c c1 05	sty $05c1			sty 	EXTColumn
.a7d1					_EXPCExit:
.a7d1	20 d7 a8	jsr $a8d7			jsr 	EXTSetHardwareCursor 		; place the physical cursor.
.a7d4	68		pla				pla
.a7d5	85 01		sta $01				sta 	1
.a7d7	7a		ply				ply
.a7d8	fa		plx				plx
.a7d9	68		pla				pla
.a7da	60		rts				rts
.a7db					_EXPCClearScreen:
.a7db	20 94 a8	jsr $a894			jsr		EXTClearScreenCode
.a7de	80 f1		bra $a7d1			bra 	_EXPCExit
.a7e0					_EXPCDown:
.a7e0	ad c4 05	lda $05c4			lda 	EXTScreenHeight 			; at the bottom
.a7e3	3a		dec a				dec 	a
.a7e4	cd c0 05	cmp $05c0			cmp 	EXTRow
.a7e7	f0 e8		beq $a7d1			beq 	_EXPCExit
.a7e9	ee c0 05	inc $05c0			inc 	EXTRow 						; down one in position/address
.a7ec	18		clc				clc
.a7ed	a5 40		lda $40				lda 	EXTAddress
.a7ef	6d c3 05	adc $05c3			adc 	EXTScreenWidth
.a7f2	85 40		sta $40				sta 	EXTAddress
.a7f4	90 db		bcc $a7d1			bcc 	_EXPCExit
.a7f6	e6 41		inc $41				inc 	EXTAddress+1
.a7f8	80 d7		bra $a7d1			bra 	_EXPCExit
.a7fa					_EXPCTab:
.a7fa	ad c1 05	lda $05c1			lda 	EXTColumn 					; next tab stop
.a7fd	29 f8		and #$f8			and 	#$F8
.a7ff	18		clc				clc
.a800	69 08		adc #$08			adc 	#8
.a802	8d c1 05	sta $05c1			sta 	EXTColumn
.a805	cd c3 05	cmp $05c3			cmp 	EXTScreenWidth 				; too far, stick end of line.
.a808	90 c7		bcc $a7d1			bcc 	_EXPCExit
.a80a	80 10		bra $a81c			bra 	_EXPCEnd
.a80c					_EXPCBackSpace:
.a80c	88		dey				dey
.a80d	30 c2		bmi $a7d1			bmi 	_EXPCExit
.a80f	ce c1 05	dec $05c1			dec 	EXTColumn
.a812	a9 02		lda #$02			lda 	#2
.a814	85 01		sta $01				sta 	1
.a816	a9 20		lda #$20			lda 	#32
.a818	91 40		sta ($40),y			sta 	(EXTAddress),y
.a81a	80 b5		bra $a7d1			bra 	_EXPCExit
.a81c					_EXPCEnd:
.a81c	a9 02		lda #$02			lda 	#2 							; access text screen
.a81e	85 01		sta $01				sta 	1
.a820	ac c3 05	ldy $05c3			ldy 	EXTScreenWidth 				; point to last character
.a823	88		dey				dey
.a824					_EXPCEndSearch:
.a824	88		dey				dey 								; if past start, move to col 0.
.a825	30 06		bmi $a82d			bmi 	_EXPCFound
.a827	b1 40		lda ($40),y			lda 	(EXTAddress),y 				; keep going back till non space found
.a829	c9 20		cmp #$20			cmp 	#' '
.a82b	f0 f7		beq $a824			beq 	_EXPCEndSearch
.a82d					_EXPCFound:
.a82d	c8		iny				iny 								; move to following cell.
.a82e	80 9e		bra $a7ce			bra 	_EXPCSetColumnY
.a830					_EXPCClearEOL:
.a830	a9 02		lda #$02			lda 	#2 							; access character RAM
.a832	85 01		sta $01				sta 	1
.a834	a9 20		lda #$20			lda 	#' ' 						; write space
.a836	91 40		sta ($40),y			sta 	(EXTAddress),y
.a838	c8		iny				iny
.a839	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth 				; until RHS of screen.
.a83c	90 f2		bcc $a830			bcc 	_EXPCClearEOL
.a83e	80 91		bra $a7d1			bra 	_EXPCExit
.a840					_EXPCActionTable:
>a840	d1 a7						.word 	_EXPCExit 					; 00
>a842	8f a7						.word 	_EXPCBegin 					; 01 A Start of Line
>a844	8a a7						.word 	_EXPCLeft 					; 02 B Left
>a846	d1 a7						.word 	_EXPCExit 					; 03 <Break>
>a848	d1 a7						.word 	_EXPCExit 					; 04
>a84a	1c a8						.word 	_EXPCEnd 					; 05 E End of Line
>a84c	c4 a7						.word 	_EXPCRight 					; 06 F Right
>a84e	d1 a7						.word 	_EXPCExit 					; 07
>a850	0c a8						.word 	_EXPCBackspace 				; 08 H Backspace
>a852	fa a7						.word 	_EXPCTab 					; 09 I Tab
>a854	d1 a7						.word 	_EXPCExit 					; 0A
>a856	30 a8						.word 	_EXPCClearEOL 				; 0B K Clear to EOL
>a858	db a7						.word 	_EXPCClearScreen			; 0C L CLS
>a85a	6e a7						.word 	_EXPCCRLF 					; 0D M CR/LF
>a85c	e0 a7						.word 	_EXPCDown 					; 0E N Down
>a85e	d1 a7						.word 	_EXPCExit 					; 0F
>a860	ae a7						.word 	_EXPCUp 					; 10 P Up
.a862					_EXPCHandleColour
.a862	c9 90		cmp #$90			cmp 	#$90 						; 8x foreground 9x background
.a864	b0 16		bcs $a87c			bcs 	_EXPCBackground
.a866	0a		asl a				asl 	a 							; shift it 4 bits to the right.
.a867	0a		asl a				asl 	a
.a868	0a		asl a				asl 	a
.a869	0a		asl a				asl 	a
.a86a	a2 0f		ldx #$0f			ldx 	#$0F 						; Mask in X
.a86c					_EXPCUpdate:
.a86c	48		pha				pha 								; save new colour
.a86d	8a		txa				txa 								; get mask
.a86e	2d c2 05	and $05c2			and 	EXTTextColour 				; mask out old.
.a871	8d c2 05	sta $05c2			sta 	EXTTextColour
.a874	68		pla				pla 								; or in new colour
.a875	0d c2 05	ora $05c2			ora 	EXTTextColour
.a878	8d c2 05	sta $05c2			sta 	EXTTextColour
.a87b	60		rts				rts
.a87c					_EXPCBackground:
.a87c	29 0f		and #$0f			and 	#$0F 						; get the colour
.a87e	a2 f0		ldx #$f0			ldx 	#$F0 						; mask
.a880	80 ea		bra $a86c			bra 	_EXPCUpdate
.a882					EXTScreenScroll:
.a882	a9 02		lda #$02			lda 	#2 							; select text page
.a884	85 01		sta $01				sta 	1
.a886	a9 20		lda #$20			lda		#32 						; fill with space
.a888	20 9b a9	jsr $a99b			jsr 	EXTScrollFill
.a88b	e6 01		inc $01				inc 	1 							; select colour page
.a88d	ad c2 05	lda $05c2			lda 	EXTTextColour
.a890	20 9b a9	jsr $a99b			jsr 	EXTScrollFill
.a893	60		rts				rts
.a894					EXTClearScreenCode:
.a894	a9 02		lda #$02			lda 	#2 							; select text page
.a896	85 01		sta $01				sta 	1
.a898	a9 20		lda #$20			lda		#32 						; fill with space
.a89a	20 a7 a8	jsr $a8a7			jsr 	_EXTCSFill
.a89d	e6 01		inc $01				inc 	1 							; select colour page
.a89f	ad c2 05	lda $05c2			lda 	EXTTextColour
.a8a2	20 a7 a8	jsr $a8a7			jsr 	_EXTCSFill
.a8a5	80 22		bra $a8c9			bra 	EXTHomeCursor
.a8a7					_EXTCSFill:
.a8a7	aa		tax				tax
.a8a8	a9 00		lda #$00			lda 	#EXTMemory & $FF
.a8aa	85 40		sta $40				sta 	EXTAddress
.a8ac	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a8ae	85 41		sta $41				sta 	EXTAddress+1
.a8b0					_EXTCSFill1:
.a8b0	a0 00		ldy #$00			ldy 	#0
.a8b2	8a		txa				txa
.a8b3					_EXTCSFill2:
.a8b3	91 40		sta ($40),y			sta 	(EXTAddress),y
.a8b5	c8		iny				iny
.a8b6	d0 fb		bne $a8b3			bne 	_EXTCSFill2
.a8b8	e6 41		inc $41				inc 	EXTAddress+1
.a8ba	a5 41		lda $41				lda 	EXTAddress+1
.a8bc	c9 d2		cmp #$d2			cmp 	#$D2
.a8be	d0 f0		bne $a8b0			bne 	_EXTCSFill1
.a8c0	8a		txa				txa
.a8c1					_EXTCSFill3:
.a8c1	91 40		sta ($40),y			sta 	(EXTAddress),y
.a8c3	c8		iny				iny
.a8c4	c0 c0		cpy #$c0			cpy 	#$C0
.a8c6	d0 f9		bne $a8c1			bne 	_EXTCSFill3
.a8c8	60		rts				rts
.a8c9					EXTHomeCursor:
.a8c9	9c c0 05	stz $05c0			stz 	EXTRow 						; reset row & column
.a8cc	9c c1 05	stz $05c1			stz 	EXTColumn
.a8cf	a9 00		lda #$00			lda 	#EXTMemory & $FF 			; set address
.a8d1	85 40		sta $40				sta 	EXTAddress
.a8d3	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a8d5	85 41		sta $41				sta 	EXTAddress+1
.a8d7					EXTSetHardwareCursor:
.a8d7	64 01		stz $01				stz 	1 							; I/O Page zero
.a8d9	a9 05		lda #$05			lda 	#1+4 						; enable cursor
.a8db	8d 10 d0	sta $d010			sta 	$D010
.a8de	a9 b1		lda #$b1			lda 	#$B1
.a8e0	8d 12 d0	sta $d012			sta 	$D012
.a8e3	ad c1 05	lda $05c1			lda 	EXTColumn
.a8e6	8d 14 d0	sta $d014			sta 	$D014 						; set cursor position
.a8e9	9c 15 d0	stz $d015			stz 	$D015
.a8ec	ad c0 05	lda $05c0			lda 	EXTRow
.a8ef	8d 16 d0	sta $d016			sta 	$D016
.a8f2	9c 17 d0	stz $d017			stz 	$D017
.a8f5	60		rts				rts
.a8f6					Export_EXTInputLine:
.a8f6	48		pha				pha
.a8f7	da		phx				phx
.a8f8	5a		phy				phy
.a8f9	a5 01		lda $01				lda 	1 							; save I/O page
.a8fb	48		pha				pha
.a8fc					_EILLoop:
.a8fc	20 16 aa	jsr $aa16			jsr 	PagedInputSingleCharacter
.a8ff	c9 0d		cmp #$0d			cmp 	#13 						; scrape line if exit.
.a901	f0 44		beq $a947			beq 	_EILExit
.a903	c9 04		cmp #$04			cmp 	#4 							; Ctrl+D delete at cursor
.a905	f0 2a		beq $a931			beq 	_EILDelete
.a907	c9 08		cmp #$08			cmp 	#8 							; Ctrl+H backspace
.a909	f0 1c		beq $a927			beq 	_EILBackspace
.a90b	c9 20		cmp #$20			cmp 	#' '						; < space, print it
.a90d	90 12		bcc $a921			bcc 	_EILPrintLoop
.a90f	c9 7f		cmp #$7f			cmp 	#$7F 						; if -ve print it
.a911	b0 0e		bcs $a921			bcs 	_EILPrintLoop
.a913	48		pha				pha 								; save character
.a914	a9 02		lda #$02			lda 	#2  						; insert a space
.a916	85 01		sta $01				sta 	1
.a918	20 89 a9	jsr $a989			jsr 	EXTILInsert 				; insert in text screen
.a91b	e6 01		inc $01				inc 	1
.a91d	20 89 a9	jsr $a989			jsr 	EXTILInsert 				; insert in colour screen
.a920	68		pla				pla 								; get character back.
.a921					_EILPrintLoop:
.a921	20 47 a7	jsr $a747			jsr 	PagedPrintCharacter
.a924	80 d6		bra $a8fc			bra 	_EILLoop
.a926	60		rts				rts
.a927					_EILBackspace:
.a927	ad c1 05	lda $05c1			lda 	EXTColumn					; can we backspace ?
.a92a	f0 d0		beq $a8fc			beq 	_EILLoop
.a92c	a9 02		lda #$02			lda 	#2 							; move cursor left
.a92e	20 47 a7	jsr $a747			jsr 	PagedPrintCharacter
.a931					_EILDelete
.a931	a9 02		lda #$02			lda 	#2 							; text block
.a933	85 01		sta $01				sta 	1
.a935	a9 20		lda #$20			lda 	#' ' 						; backspace text.
.a937	20 74 a9	jsr $a974			jsr 	EXTILDelete
.a93a	e6 01		inc $01				inc 	1 							; colour block
.a93c	ac c1 05	ldy $05c1			ldy 	EXTColumn 					; get attribute of last character
.a93f	88		dey				dey
.a940	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a942	20 74 a9	jsr $a974			jsr 	EXTILDelete 				; backspace attribute
.a945	80 b5		bra $a8fc			bra 	_EILLoop 					; and go round.
.a947					_EILExit:
.a947	a9 02		lda #$02			lda 	#2 							; switch to page 2
.a949	85 01		sta $01				sta 	1
.a94b	a0 00		ldy #$00			ldy 	#0 							; copy current line into buffer.
.a94d					_EILScrapeLine:
.a94d	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a94f	99 2a 05	sta $052a,y			sta 	lineBuffer,y
.a952	c8		iny				iny
.a953	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth
.a956	d0 f5		bne $a94d			bne 	_EILScrapeLine
.a958					_EILTrimSpaces:
.a958	88		dey				dey
.a959	f0 08		beq $a963			beq 	_EILEndTrim
.a95b	b9 2a 05	lda $052a,y			lda 	lineBuffer,y
.a95e	c9 20		cmp #$20			cmp 	#' '
.a960	f0 f6		beq $a958			beq 	_EILTrimSpaces
.a962	c8		iny				iny 								; trim after non space character.
.a963					_EILEndTrim:
.a963	a9 00		lda #$00			lda 	#0 							; trim here.
.a965	99 2a 05	sta $052a,y			sta 	lineBuffer,y
.a968	a9 0d		lda #$0d			lda 	#13 						; echo the RETURN
.a96a	20 47 a7	jsr $a747			jsr 	PagedPrintCharacter
.a96d	68		pla				pla 								; reset I/O page
.a96e	85 01		sta $01				sta 	1
.a970	7a		ply				ply
.a971	fa		plx				plx
.a972	68		pla				pla
.a973	60		rts				rts
.a974					EXTILDelete:
.a974	48		pha				pha 								; save the new character
.a975	ac c1 05	ldy $05c1			ldy 	EXTColumn 					; start copying from here.
.a978					_EXTDLoop:
.a978	c8		iny				iny 								; copy one byte down.
.a979	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a97b	88		dey				dey
.a97c	91 40		sta ($40),y			sta 	(EXTAddress),y
.a97e	c8		iny				iny 								; do till end of line.
.a97f	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth
.a982	90 f4		bcc $a978			bcc 	_EXTDLoop
.a984	88		dey				dey 	 							; write in last slot.
.a985	68		pla				pla
.a986	91 40		sta ($40),y			sta 	(EXTAddress),y
.a988	60		rts				rts
.a989					EXTILInsert:
.a989	ac c3 05	ldy $05c3			ldy 	EXTScreenWidth 				; end position
.a98c					_EXTILoop:
.a98c	88		dey				dey 								; back one
.a98d	cc c1 05	cpy $05c1			cpy 	EXTColumn 					; exit if reached insert point.
.a990	f0 08		beq $a99a			beq 	_EXTIExit
.a992	88		dey				dey 								; copy one byte up.
.a993	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a995	c8		iny				iny
.a996	91 40		sta ($40),y			sta 	(EXTAddress),y
.a998	80 f2		bra $a98c			bra 	_EXTILoop
.a99a					_EXTIExit:
.a99a	60		rts				rts
.a99b					EXTScrollFill:
.a99b	aa		tax				tax									; save value to fill with
.a99c	a5 36		lda $36				lda 	zTemp0 						; save zTemp0 (dest) zTemp1 (src)
.a99e	48		pha				pha
.a99f	a5 37		lda $37				lda 	zTemp0+1
.a9a1	48		pha				pha
.a9a2	a5 38		lda $38				lda 	zTemp1
.a9a4	48		pha				pha
.a9a5	a5 39		lda $39				lda 	zTemp1+1
.a9a7	48		pha				pha
.a9a8	a9 c0		lda #$c0			lda 	#$C0 						; copy from C000+length to C000
.a9aa	85 37		sta $37				sta 	zTemp0+1
.a9ac	85 39		sta $39				sta 	zTemp1+1
.a9ae	64 36		stz $36				stz 	zTemp0
.a9b0	ad c3 05	lda $05c3			lda 	EXTScreenWidth
.a9b3	85 38		sta $38				sta 	zTemp1
.a9b5	a0 00		ldy #$00			ldy 	#0
.a9b7					_EXSFCopy1:
.a9b7	b1 38		lda ($38),y			lda 	(zTemp1),y
.a9b9	91 36		sta ($36),y			sta 	(zTemp0),y
.a9bb	c8		iny				iny
.a9bc	d0 f9		bne $a9b7			bne 	_EXSFCopy1
.a9be	e6 37		inc $37				inc 	zTemp0+1 					; next page
.a9c0	e6 39		inc $39				inc 	zTemp1+1
.a9c2	a5 39		lda $39				lda 	zTemp1+1
.a9c4	c9 d3		cmp #$d3			cmp 	#$D3
.a9c6	d0 ef		bne $a9b7			bne 	_EXSFCopy1
.a9c8	ac c3 05	ldy $05c3			ldy 	EXTScreenWidth 				; blank the bottom line.
.a9cb	8a		txa				txa
.a9cc					_EXSFFill1:
.a9cc	88		dey				dey
.a9cd	91 40		sta ($40),y			sta 	(EXTAddress),y
.a9cf	c0 00		cpy #$00			cpy 	#0
.a9d1	10 f9		bpl $a9cc			bpl 	_EXSFFill1
.a9d3	68		pla				pla
.a9d4	85 39		sta $39				sta 	zTemp1+1
.a9d6	68		pla				pla
.a9d7	85 38		sta $38				sta 	zTemp1
.a9d9	68		pla				pla
.a9da	85 37		sta $37				sta 	zTemp0+1
.a9dc	68		pla				pla
.a9dd	85 36		sta $36				sta 	zTemp0
.a9df	60		rts				rts
=$c000					EXTMemory = $C000
=$02					EXTTextPage = $02
=$03					EXTColourPage = $03
=1					EXTDummySpace = 1 							; fake-space for CR character.
=0					EXTCBlack = 0
.05c0					EXTRow:
>05c0							.fill 	1
.05c1					EXTColumn:
>05c1							.fill 	1
.05c2					EXTTextColour:
>05c2							.fill 	1
.05c3					EXTScreenWidth:
>05c3							.fill 	1
.05c4					EXTScreenHeight:
>05c4							.fill 	1
.0040					EXTAddress:
>0040							.fill 	2
.a9e0					Export_EXTInitialise:
.a9e0	64 01		stz $01				stz 	1 							; Access I/O page 0
.a9e2	9c 04 d0	stz $d004			stz 	$D004 						; Disable border
.a9e5	9c 08 d0	stz $d008			stz 	$D008
.a9e8	9c 09 d0	stz $d009			stz 	$D009
.a9eb	a9 09		lda #$09			lda 	#1+8						; Timer On at 70Hz counting up.
.a9ed	8d 58 d6	sta $d658			sta 	$D658
.a9f0	a9 03		lda #$03			lda 	#3 							; get current text colour from whatever the kernel
.a9f2	85 01		sta $01				sta 	1 							; has set it to, looking at top left character
.a9f4	ad 00 c0	lda $c000			lda 	$C000
.a9f7	8d c2 05	sta $05c2			sta 	EXTTextColour
.a9fa	a9 50		lda #$50			lda 	#80 						; set screen dimensions.
.a9fc	8d c3 05	sta $05c3			sta 	EXTScreenWidth
.a9ff	a9 3c		lda #$3c			lda 	#60
.aa01	8d c4 05	sta $05c4			sta 	EXTScreenHeight
.aa04	20 c9 a8	jsr $a8c9			jsr 	EXTHomeCursor 				; home cursor
.aa07					_EXMoveDown:
.aa07	a9 0d		lda #$0d			lda 	#13
.aa09	20 47 a7	jsr $a747			jsr 	PAGEDPrintCharacter
.aa0c	ad c0 05	lda $05c0			lda 	EXTRow
.aa0f	c9 06		cmp #$06			cmp 	#6
.aa11	d0 f4		bne $aa07			bne 	_EXMoveDown
.aa13	64 01		stz $01				stz 	1
.aa15	60		rts				rts
.aa16					Export_EXTInputSingleCharacter:
.aa16					PagedInputSingleCharacter:
.aa16	da		phx				phx
.aa17	5a		phy				phy
.aa18					_EISCWait:
.aa18	a5 01		lda $01				lda 	1 							; save I/O 0
.aa1a	48		pha				pha
.aa1b	64 01		stz $01				stz 	1 							; access I/O Page 0
.aa1d	38		sec				sec 								; calculate timer - LastTick
.aa1e	ad 59 d6	lda $d659			lda 	$D659
.aa21	aa		tax				tax 								; saving timer in X
.aa22	ed af 05	sbc $05af			sbc 	LastTick
.aa25	c9 03		cmp #$03			cmp 	#3
.aa27	90 06		bcc $aa2f			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.aa29	8e af 05	stx $05af			stx 	LastTick 					; update last timer
.aa2c	20 c2 bd	jsr $bdc2			jsr 	PagedSNDUpdate 							; go do the code.
.aa2f					_NoFireTick:
.aa2f	68		pla				pla 								; restore I/O 0
.aa30	85 01		sta $01				sta 	1
.aa32	20 e4 ff	jsr $ffe4			jsr 	$FFE4 						; get a key
.aa35	c9 00		cmp #$00			cmp 	#0 							; loop back if none pressed.
.aa37	f0 df		beq $aa18			beq 	_EISCWait
.aa39	7a		ply				ply
.aa3a	fa		plx				plx
.aa3b	60		rts				rts
.aa3c					Export_EXTBreakCheck:
.aa3c	4c e1 ff	jmp $ffe1			jmp		$FFE1
.aa3f					Export_EXTReadController:
.aa3f	da		phx				phx
.aa40	a2 00		ldx #$00			ldx 	#0
.aa42	a9 05		lda #$05			lda 	#(($2D) >> 3)
.aa44	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa47	29 20		and #$20			and 	#($01 << (($2D) & 7))
.aa49	f0 04		beq $aa4f			beq 	_NoSet1
.aa4b	8a		txa				txa
.aa4c	09 01		ora #$01			ora 	#1
.aa4e	aa		tax				tax
.aa4f					_NoSet1:
.aa4f	a9 05		lda #$05			lda 	#(($2C) >> 3)
.aa51	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa54	29 10		and #$10			and 	#($01 << (($2C) & 7))
.aa56	f0 04		beq $aa5c			beq 	_NoSet1
.aa58	8a		txa				txa
.aa59	09 02		ora #$02			ora 	#2
.aa5b	aa		tax				tax
.aa5c					_NoSet1:
.aa5c	a9 06		lda #$06			lda 	#(($32) >> 3)
.aa5e	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa61	29 04		and #$04			and 	#($01 << (($32) & 7))
.aa63	f0 04		beq $aa69			beq 	_NoSet1
.aa65	8a		txa				txa
.aa66	09 04		ora #$04			ora 	#4
.aa68	aa		tax				tax
.aa69					_NoSet1:
.aa69	a9 04		lda #$04			lda 	#(($25) >> 3)
.aa6b	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa6e	29 20		and #$20			and 	#($01 << (($25) & 7))
.aa70	f0 04		beq $aa76			beq 	_NoSet1
.aa72	8a		txa				txa
.aa73	09 08		ora #$08			ora 	#8
.aa75	aa		tax				tax
.aa76					_NoSet1:
.aa76	a9 04		lda #$04			lda 	#(($26) >> 3)
.aa78	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa7b	29 40		and #$40			and 	#($01 << (($26) & 7))
.aa7d	f0 04		beq $aa83			beq 	_NoSet1
.aa7f	8a		txa				txa
.aa80	09 10		ora #$10			ora 	#16
.aa82	aa		tax				tax
.aa83					_NoSet1:
.aa83	8a		txa				txa
.aa84	fa		plx				plx
.aa85	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_graphics.module

=1					graphicsIntegrated=1
=0					GCMD_Initialise = 0*2
=2					GCMD_BitmapCtl = 1*2
=4					GCMD_SpriteCtl = 2*2
=6					GCMD_Clear = 3*2
=8					GCMD_Colour = 4*2
=10					GCMD_DrawFont = 5*2
=12					GCMD_DrawSprite = 6*2
=14					GCMD_SpriteUse = 7*2
=16					GCMD_SpriteImage = 8*2
=18					GCMD_SpriteCollide = 9*2
=64					GCMD_Move = 32*2
=66					GCMD_Line = 33*2
=68					GCMD_FrameRect = 34*2
=70					GCMD_FillRect = 35*2
=72					GCMD_FrameCircle = 36*2
=74					GCMD_FillCircle = 37*2
=80					GCMD_Plot = 40*2
=82					GCMD_SpriteMove = 41*2
=42					GRFirstFreeCode = 42
.aa86					GRVectorTable:
>aa86	d5 ac					.word	GXInitialise             ; $00 Initialise
>aa88	ef ac					.word	GXControlBitmap          ; $01 BitmapCtl
>aa8a	37 ad					.word	GXControlSprite          ; $02 SpriteCtl
>aa8c	87 ac					.word	GXClearBitmap            ; $03 Clear
>aa8e	c6 ae					.word	GXSetColourMode          ; $04 Colour
>aa90	8e b0					.word	GXFontHandler            ; $05 DrawFont
>aa92	d6 b0					.word	GXSpriteHandler          ; $06 DrawSprite
>aa94	47 b1					.word	GXSelect                 ; $07 SpriteUse
>aa96	70 b1					.word	GXSelectImage            ; $08 SpriteImage
>aa98	f7 b2					.word	GXCollide                ; $09 SpriteCollide
>aa9a	39 ab					.word	GRUndefined              ; $0a
>aa9c	39 ab					.word	GRUndefined              ; $0b
>aa9e	39 ab					.word	GRUndefined              ; $0c
>aaa0	39 ab					.word	GRUndefined              ; $0d
>aaa2	39 ab					.word	GRUndefined              ; $0e
>aaa4	39 ab					.word	GRUndefined              ; $0f
>aaa6	39 ab					.word	GRUndefined              ; $10
>aaa8	39 ab					.word	GRUndefined              ; $11
>aaaa	39 ab					.word	GRUndefined              ; $12
>aaac	39 ab					.word	GRUndefined              ; $13
>aaae	39 ab					.word	GRUndefined              ; $14
>aab0	39 ab					.word	GRUndefined              ; $15
>aab2	39 ab					.word	GRUndefined              ; $16
>aab4	39 ab					.word	GRUndefined              ; $17
>aab6	39 ab					.word	GRUndefined              ; $18
>aab8	39 ab					.word	GRUndefined              ; $19
>aaba	39 ab					.word	GRUndefined              ; $1a
>aabc	39 ab					.word	GRUndefined              ; $1b
>aabe	39 ab					.word	GRUndefined              ; $1c
>aac0	39 ab					.word	GRUndefined              ; $1d
>aac2	39 ab					.word	GRUndefined              ; $1e
>aac4	39 ab					.word	GRUndefined              ; $1f
>aac6	37 ab					.word	GXMove                   ; $20 Move
>aac8	94 ad					.word	GXLine                   ; $21 Line
>aaca	0f af					.word	GXFrameRectangle         ; $22 FrameRect
>aacc	0c af					.word	GXFillRectangle          ; $23 FillRect
>aace	3e ab					.word	GXFrameCircle            ; $24 FrameCircle
>aad0	3a ab					.word	GXFillCircle             ; $25 FillCircle
>aad2	39 ab					.word	GRUndefined              ; $26
>aad4	39 ab					.word	GRUndefined              ; $27
>aad6	f4 ae					.word	GXPlotPoint              ; $28 Plot
>aad8	06 b2					.word	GXMoveSprite             ; $29 SpriteMove
=3					GXMappingPage = 3
=24576					GXMappingAddress = ($2000 * GXMappingPage)
=11					GXEditSlot = 8 + GXMappingPage
=$36					gxzTemp0 = zTemp0
=$38					gxzTemp1 = zTemp1
=$3a					gxzTemp2 = zTemp2
=$3c					gxzScreen = zsTemp
=$57b					gxPixelBuffer = numberBuffer
.05c5					gxCurrentX:
>05c5							.fill 	2
.05c7					gxCurrentY:
>05c7							.fill 	2
.05c9					gxLastX:
>05c9							.fill 	2
.05cb					gxLastY:
>05cb							.fill 	2
.05cd					gxX0:
>05cd							.fill 	2
.05cf					gxY0:
>05cf							.fill 	2
.05d1					gxX1:
>05d1							.fill 	2
.05d3					gxY1:
>05d3							.fill 	2
.05d5					gxSpritesOn:
>05d5							.fill 	1
.05d6					gxBitmapsOn:
>05d6							.fill 	1
.05d7					gxBasePage:
>05d7							.fill 	1
.05d8					gxSpritePage:
>05d8							.fill 	1
.05d9					gxHeight:
>05d9							.fill 	1
.05da					gxMode:
>05da							.fill 	1
.05db					gxColour:
>05db							.fill 	1
.05dc					gxEORValue:
>05dc							.fill 	1
.05dd					gxANDValue:
>05dd							.fill 	1
.05de					gxOriginalLUTValue:
>05de							.fill 	1
.05df					gsOffset:
>05df							.fill 	1
.05e0					GSCurrentSpriteID:
>05e0							.fill 	1
.05e1					GSCurrentSpriteAddr:
>05e1							.fill 	2
.05e3					GXSpriteOffsetBase:
>05e3							.fill 	2
.05e5					GXSpriteLow:
>05e5							.fill 	64
.0625					GXSpriteHigh:
>0625							.fill 	64
.aada					Export_GXGraphicDraw:
.aada	c9 40		cmp #$40			cmp 	#GCMD_Move					; low instructions don't use coordinates
.aadc	b0 06		bcs $aae4			bcs 	_GDCoordinate
.aade	86 36		stx $36				stx 	gxzTemp0 					; save X/Y
.aae0	84 37		sty $37				sty 	gxzTemp0+1
.aae2	80 4b		bra $ab2f			bra 	_GDExecuteA 				; and execute
.aae4					_GDCoordinate:
.aae4	48		pha				pha 								; save AXY
.aae5	da		phx				phx
.aae6	5a		phy				phy
.aae7	a2 03		ldx #$03			ldx 	#3 							; copy currentX to lastX
.aae9					_GDCopy1:
.aae9	bd c5 05	lda $05c5,x			lda 	gxCurrentX,x
.aaec	9d c9 05	sta $05c9,x			sta 	gxLastX,x
.aaef	ca		dex				dex
.aaf0	10 f7		bpl $aae9			bpl 	_GDCopy1
.aaf2	68		pla				pla 								; update Y
.aaf3	8d c7 05	sta $05c7			sta 	gxCurrentY
.aaf6	9c c8 05	stz $05c8			stz 	gxCurrentY+1
.aaf9	68		pla				pla
.aafa	8d c5 05	sta $05c5			sta 	gxCurrentX
.aafd	68		pla				pla 								; get A (command+X.1) back
.aafe	48		pha				pha
.aaff	29 01		and #$01			and 	#1 							; put LSB as MSB of Current.X
.ab01	8d c6 05	sta $05c6			sta 	gxCurrentX+1
.ab04	68		pla				pla 								; get command back
.ab05	29 fe		and #$fe			and 	#$FE 						; lose LSB, chuck the stray X bit
.ab07	48		pha				pha 								; push back.
.ab08	c9 52		cmp #$52			cmp 	#GCMD_SpriteMove 			; move sprite does not clip.
.ab0a	f0 17		beq $ab23			beq 	_GDCopyToWorkArea
.ab0c	ad c6 05	lda $05c6			lda 	gxCurrentX+1 				; X < 256 X okay
.ab0f	f0 07		beq $ab18			beq 	_GDCheckY
.ab11	ad c5 05	lda $05c5			lda 	gxCurrentX 					; otherwise X < 320 = 256 + 64
.ab14	c9 40		cmp #$40			cmp 	#64
.ab16	b0 08		bcs $ab20			bcs 	_GDError1
.ab18					_GDCheckY:
.ab18	ad c7 05	lda $05c7			lda 	gxCurrentY 					; check Y < Height.
.ab1b	cd d9 05	cmp $05d9			cmp 	gxHeight
.ab1e	90 03		bcc $ab23			bcc 	_GDCopyToWorkArea
.ab20					_GDError1:
.ab20	68		pla				pla
.ab21					_GDError2:
.ab21	38		sec				sec
.ab22	60		rts				rts
.ab23					_GDCopyToWorkArea:
.ab23	a2 07		ldx #$07			ldx 	#7 							; copy current and last to gxXY/12 work area
.ab25					_GDCopy2:
.ab25	bd c5 05	lda $05c5,x			lda 	gxCurrentX,x
.ab28	9d cd 05	sta $05cd,x			sta 	gxX0,x
.ab2b	ca		dex				dex
.ab2c	10 f7		bpl $ab25			bpl 	_GDCopy2
.ab2e	68		pla				pla 								; get command
.ab2f					_GDExecuteA:
.ab2f	c9 54		cmp #$54			cmp 	#GRFirstFreeCode*2 			; bad ?
.ab31	b0 ee		bcs $ab21			bcs 	_GDError2
.ab33	aa		tax				tax
.ab34	7c 86 aa	jmp ($aa86,x)			jmp 	(GRVectorTable,x)
.ab37					GXMove:
.ab37	18		clc				clc
.ab38	60		rts				rts
.ab39					GRUndefined:
>ab39	db						.byte 	$DB 						; causes a break in the emulator
.ab3a					GXFillCircle:
.ab3a	a9 ff		lda #$ff			lda 	#255
.ab3c	80 02		bra $ab40			bra 	GXCircle
.ab3e					GXFrameCircle:
.ab3e	a9 00		lda #$00			lda 	#0
.ab40					GXCircle:
.ab40	8d 68 06	sta $0668			sta 	gxIsFillMode					; save Fill flag
.ab43	ad d6 05	lda $05d6			lda 	gxBitmapsOn
.ab46	f0 26		beq $ab6e			beq 	_GXCFail
.ab48	20 9e b3	jsr $b39e			jsr 	GXSortXY 					; topleft/bottomright
.ab4b	20 76 b2	jsr $b276			jsr 	GXOpenBitmap 				; start drawing
.ab4e	20 40 ac	jsr $ac40			jsr 	GXCircleSetup 				; set up for drawing
.ab51	9c 69 06	stz $0669			stz 	gxYChanged
.ab54					_GXCircleDraw:
.ab54	ad 66 06	lda $0666			lda 	gXCentre					; while x <= y
.ab57	cd 67 06	cmp $0667			cmp 	gYCentre
.ab5a	90 0a		bcc $ab66			bcc 	_GXCircleContinue
.ab5c	d0 03		bne $ab61			bne 	_GXNoLast
.ab5e	20 73 ab	jsr $ab73			jsr 	GXPlot1
.ab61					_GXNoLast:
.ab61	20 7e b2	jsr $b27e			jsr 	GXCloseBitmap 				; close the bitmap
.ab64	18		clc				clc
.ab65	60		rts				rts
.ab66					_GXCircleContinue:
.ab66	20 70 ab	jsr $ab70			jsr 	GXPlot2 					; draw it
.ab69	20 ed ab	jsr $abed			jsr 	GXCircleMove 				; adjust the coordinates
.ab6c	80 e6		bra $ab54			bra 	_GXCircleDraw
.ab6e					_GXCFail:
.ab6e	38		sec				sec
.ab6f	60		rts				rts
.ab70					GXPlot2:
.ab70	20 73 ab	jsr $ab73			jsr 	GXPlot1 						; plot and swap, fall through does twice
.ab73					GXPlot1:
.ab73	ad 67 06	lda $0667			lda 	gYCentre 						; if y = 0, don't do it twice (xor)
.ab76	f0 03		beq $ab7b			beq 	_GXPlot1Only
.ab78	20 97 ab	jsr $ab97			jsr 	GXPlot0 						; plot and negate
.ab7b					_GXPlot1Only:
.ab7b	20 97 ab	jsr $ab97			jsr 	GXPlot0 						; twice, undoing negation
.ab7e	ad 66 06	lda $0666			lda 	gXCentre 						; swap X and Y
.ab81	ae 67 06	ldx $0667			ldx	 	gYCentre
.ab84	8d 67 06	sta $0667			sta 	gYCentre
.ab87	8e 66 06	stx $0666			stx 	gXCentre
.ab8a	ad 69 06	lda $0669			lda 	gxYChanged 						; toggle Y Changed flag
.ab8d	a9 ff		lda #$ff			lda 	#$FF
.ab8f	8d 69 06	sta $0669			sta 	gxYChanged
.ab92	60		rts				rts
.ab93	20 97 ab	jsr $ab97			jsr 	GXPlot0 						; do once
.ab96	60		rts				rts
.ab97	ad 68 06	lda $0668	GXPlot0:lda 	gxIsFillMode 					; outline mode, always draw as X or Y will change
.ab9a	f0 05		beq $aba1			beq 	_GXPlot0Always
.ab9c	ad 69 06	lda $0669			lda 	gxYChanged						; fill mode, only draw if changed.
.ab9f	f0 2d		beq $abce			beq 	GXPlot0Exit
.aba1					_GXPlot0Always:
.aba1	a2 02		ldx #$02			ldx 	#2 								; copy Y1-A => Y0
.aba3	ad 67 06	lda $0667			lda 	gYCentre
.aba6	20 cf ab	jsr $abcf			jsr 	GXSubCopy
.aba9	a2 00		ldx #$00			ldx 	#0 								; copy X1-A => X0,
.abab	ad 66 06	lda $0666			lda 	gXCentre
.abae	20 cf ab	jsr $abcf			jsr 	GXSubCopy
.abb1	48		pha				pha 									; save last offset X
.abb2	20 86 b2	jsr $b286			jsr 	GXPositionCalc 					; calculate position/offset.
.abb5	68		pla				pla
.abb6	0a		asl a				asl 	a 								; store 2 x last offset in gxzTemp0
.abb7	85 36		sta $36				sta 	gxzTemp0
.abb9	64 37		stz $37				stz 	gxzTemp0+1
.abbb	26 37		rol $37				rol 	gxzTemp0+1
.abbd	ad 68 06	lda $0668			lda 	gxIsFillMode
.abc0	69 80		adc #$80			adc 	#128
.abc2	20 5f af	jsr $af5f			jsr 	GXDrawLineTemp0 				; routine from Rectangle.
.abc5	38		sec				sec 									; GY = -GY
.abc6	a9 00		lda #$00			lda 	#0
.abc8	ed 67 06	sbc $0667			sbc 	gYCentre
.abcb	8d 67 06	sta $0667			sta 	gYCentre
.abce					GXPlot0Exit:
.abce	60		rts				rts
.abcf					GXSubCopy:
.abcf	85 36		sta $36				sta 	gxzTemp0
.abd1	64 37		stz $37				stz 	gxzTemp0+1
.abd3	29 80		and #$80			and 	#$80
.abd5	f0 02		beq $abd9			beq 	_GXNoSx
.abd7	c6 37		dec $37				dec 	gxzTemp0+1
.abd9					_GXNoSx:
.abd9	38		sec				sec
.abda	bd d1 05	lda $05d1,x			lda 	gXX1,x
.abdd	e5 36		sbc $36				sbc 	gxzTemp0
.abdf	9d cd 05	sta $05cd,x			sta 	gXX0,x
.abe2	bd d2 05	lda $05d2,x			lda 	gXX1+1,x
.abe5	e5 37		sbc $37				sbc 	gxzTemp0+1
.abe7	9d ce 05	sta $05ce,x			sta 	gXX0+1,x
.abea	a5 36		lda $36				lda 	gxzTemp0 						; return A
.abec	60		rts				rts
.abed					GXCircleMove:
.abed	9c 69 06	stz $0669			stz 	gxYChanged 					; clear Y changed flag
.abf0	a5 39		lda $39				lda 	gxzTemp1+1 					; check sign of D
.abf2	10 0d		bpl $ac01			bpl 	_GXEMPositive
.abf4	ee 66 06	inc $0666			inc 	gXCentre 					; X++
.abf7	ad 66 06	lda $0666			lda 	gXCentre
.abfa	20 20 ac	jsr $ac20			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.abfd	a9 06		lda #$06			lda 	#6  						; and add 6
.abff	80 15		bra $ac16			bra 	_GXEMAddD
.ac01					_GXEMPositive:
.ac01	ee 66 06	inc $0666			inc 	gXCentre					; X++
.ac04	ce 67 06	dec $0667			dec 	gyCentre 					; Y--
.ac07	38		sec				sec 								; calculate X-Y
.ac08	ad 66 06	lda $0666			lda 	gXCentre
.ac0b	ed 67 06	sbc $0667			sbc 	gYCentre
.ac0e	20 20 ac	jsr $ac20			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.ac11	a9 0a		lda #$0a			lda 	#10  						; and add 10
.ac13	ce 69 06	dec $0669			dec 	gxYChanged
.ac16					_GXEMAddD:
.ac16	18		clc				clc
.ac17	65 38		adc $38				adc 	gxzTemp1
.ac19	85 38		sta $38				sta 	gxzTemp1
.ac1b	90 02		bcc $ac1f			bcc 	_GXEMNoCarry
.ac1d	e6 39		inc $39				inc 	gxzTemp1+1
.ac1f					_GXEMNoCarry:
.ac1f	60		rts				rts
.ac20					_GXAdd4TimesToD:
.ac20	85 36		sta $36				sta 	gxzTemp0 					; make 16 bit signed.
.ac22	29 80		and #$80			and 	#$80
.ac24	f0 02		beq $ac28			beq 	_GXA4Unsigned
.ac26	a9 ff		lda #$ff			lda 	#$FF
.ac28					_GXA4Unsigned:
.ac28	85 37		sta $37				sta 	gxzTemp0+1
.ac2a	06 36		asl $36				asl 	gxzTemp0  					; x 4
.ac2c	26 37		rol $37				rol 	gxzTemp0+1
.ac2e	06 36		asl $36				asl 	gxzTemp0
.ac30	26 37		rol $37				rol 	gxzTemp0+1
.ac32	18		clc				clc 								; add
.ac33	a5 36		lda $36				lda		gxzTemp0
.ac35	65 38		adc $38				adc 	gxzTemp1
.ac37	85 38		sta $38				sta 	gxzTemp1
.ac39	a5 37		lda $37				lda		gxzTemp0+1
.ac3b	65 39		adc $39				adc 	gxzTemp1+1
.ac3d	85 39		sta $39				sta 	gxzTemp1+1
.ac3f	60		rts				rts
.ac40					GXCircleSetup:
.ac40	38		sec				sec
.ac41	ad d3 05	lda $05d3			lda 	gxY1
.ac44	ed cf 05	sbc $05cf			sbc 	gxY0
.ac47	4a		lsr a				lsr 	a
.ac48	8d 65 06	sta $0665			sta 	gxRadius
.ac4b	a2 00		ldx #$00			ldx 	#0
.ac4d	20 6f ac	jsr $ac6f			jsr 	_GXCalculateCentre
.ac50	a2 02		ldx #$02			ldx 	#2
.ac52	20 6f ac	jsr $ac6f			jsr 	_GXCalculateCentre
.ac55	9c 66 06	stz $0666			stz 	gXCentre
.ac58	ad 65 06	lda $0665			lda 	gxRadius
.ac5b	8d 67 06	sta $0667			sta 	gYCentre
.ac5e	0a		asl a				asl 	a 							; R x 2
.ac5f	85 36		sta $36				sta 	gxzTemp0
.ac61	38		sec				sec
.ac62	a9 03		lda #$03			lda 	#3
.ac64	e5 36		sbc $36				sbc 	gxzTemp0
.ac66	85 38		sta $38				sta 	gxzTemp1
.ac68	a9 00		lda #$00			lda 	#0
.ac6a	e9 00		sbc #$00			sbc 	#0
.ac6c	85 39		sta $39				sta 	gxzTemp1+1
.ac6e	60		rts				rts
.ac6f					_GXCalculateCentre:
.ac6f	38		sec				sec
.ac70	bd d1 05	lda $05d1,x			lda 	gxX1,x
.ac73	7d cd 05	adc $05cd,x			adc 	gXX0,x
.ac76	9d d1 05	sta $05d1,x			sta 	gXX1,x
.ac79	bd d2 05	lda $05d2,x			lda 	gXX1+1,x
.ac7c	7d ce 05	adc $05ce,x			adc 	gXX0+1,x
.ac7f	4a		lsr a				lsr 	a
.ac80	9d d2 05	sta $05d2,x			sta 	gXX1+1,x
.ac83	7e d1 05	ror $05d1,x			ror 	gXX1,x
.ac86	60		rts				rts
.0665					gxRadius:
>0665							.fill 	1
.0666					gXCentre:
>0666							.fill 	1
.0667					gYCentre:
>0667							.fill 	1
.0668					gxIsFillMode:
>0668							.fill 	1
.0669					gxYChanged:
>0669							.fill  	1
=64000					ScreenSize200 = 320 * 200
=76800					ScreenSize240 = 320 * 240
.ac87					GXClearBitmap:
.ac87	ad d6 05	lda $05d6			lda 	gxBitmapsOn 				; check BMP running.
.ac8a	f0 24		beq $acb0			beq 	_GXCBFail
.ac8c	20 76 b2	jsr $b276			jsr 	GXOpenBitmap 				; start access
.ac8f	a0 07		ldy #$07			ldy 	#ScreenSize200 / 8192 		; X is pages to clear
.ac91	ad d9 05	lda $05d9			lda 	gxHeight
.ac94	c9 c8		cmp #$c8			cmp 	#200 						; 200 ?
.ac96	a0 09		ldy #$09			ldy 	#ScreenSize240 / 8192
.ac98					_GXCalcLastPage:
.ac98	98		tya				tya 								; add to base page
.ac99	18		clc				clc
.ac9a	6d d7 05	adc $05d7			adc 	gxBasePage
.ac9d	85 0b		sta $0b				sta 	GXEditSlot  				; clear from this page back
.ac9f					_GXClearAll:
.ac9f	20 b2 ac	jsr $acb2			jsr 	_GXClearBlock 				; clear 8k block
.aca2	c6 0b		dec $0b				dec 	GXEditSlot  				; back to previous
.aca4	a5 0b		lda $0b				lda 	GXEditSlot
.aca6	cd d7 05	cmp $05d7			cmp 	gxBasePage 					; until before base page
.aca9	b0 f4		bcs $ac9f			bcs 	_GXClearAll
.acab	20 7e b2	jsr $b27e			jsr 	GXCloseBitmap	 			; stop access
.acae	18		clc				clc
.acaf	60		rts				rts
.acb0					_GXCBFail:
.acb0	38		sec				sec
.acb1	60		rts				rts
.acb2					_GXClearBlock:
.acb2	a9 00		lda #$00			lda 	#((GXMappingAddress) & $FF)
.acb4	85 38		sta $38				sta 	0+gxzTemp1
.acb6	a9 60		lda #$60			lda 	#((GXMappingAddress) >> 8)
.acb8	85 39		sta $39				sta 	1+gxzTemp1
.acba					_GXCB0:
.acba	a5 36		lda $36				lda 	gxzTemp0
.acbc	a0 00		ldy #$00			ldy 	#0
.acbe					_GXCB1:
.acbe	91 38		sta ($38),y			sta 	(gxzTemp1),y
.acc0	c8		iny				iny
.acc1	91 38		sta ($38),y			sta 	(gxzTemp1),y
.acc3	c8		iny				iny
.acc4	91 38		sta ($38),y			sta 	(gxzTemp1),y
.acc6	c8		iny				iny
.acc7	91 38		sta ($38),y			sta 	(gxzTemp1),y
.acc9	c8		iny				iny
.acca	d0 f2		bne $acbe			bne 	_GXCB1
.accc	e6 39		inc $39				inc 	gxzTemp1+1
.acce	a5 39		lda $39				lda 	gxzTemp1+1
.acd0	c9 80		cmp #$80			cmp	 	#(GXMappingAddress >> 8)+$20
.acd2	d0 e6		bne $acba			bne 	_GXCB0
.acd4	60		rts				rts
.acd5					GXInitialise:
.acd5	64 01		stz $01				stz 	1
.acd7	a9 01		lda #$01			lda 	#1
.acd9	8d 00 d0	sta $d000			sta 	$D000
.acdc	18		clc				clc
.acdd	9c d5 05	stz $05d5			stz 	GXSpritesOn
.ace0	9c d6 05	stz $05d6			stz 	GXBitmapsOn
.ace3	a2 0f		ldx #$0f			ldx 	#15
.ace5					_GXIClear:
.ace5	9e c5 05	stz $05c5,x			stz 	gxCurrentX,x
.ace8	ca		dex				dex
.ace9	10 fa		bpl $ace5			bpl 	_GXIClear
.aceb	20 86 ad	jsr $ad86			jsr 	GXClearSpriteStore
.acee	60		rts				rts
.acef					GXControlBitmap:
.acef	64 01		stz $01				stz 	1
.acf1	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.acf3	29 01		and #$01			and 	#1 							; set bitmap flag
.acf5	8d d6 05	sta $05d6			sta 	gxBitmapsOn
.acf8	4a		lsr a				lsr 	a 							; bit 0 into carry.
.acf9	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.acfc	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.acfe	29 f7		and #$f7			and 	#$F7 						; clear bitmap bit
.ad00	90 02		bcc $ad04			bcc 	_CBNotOn
.ad02	09 08		ora #$08			ora 	#$08 						; bitmap on if 1 on 0 off
.ad04					_CBNotOn:
.ad04	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.ad07	a5 36		lda $36				lda 	gxzTemp0 					; get control settings (bits 0-2)
.ad09	29 07		and #$07			and 	#7
.ad0b	8d 00 d1	sta $d100			sta 	$D100 						; write in Vicky Bitmap Control Register #0
.ad0e	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.ad10	d0 02		bne $ad14			bne 	_CBNotDefault
.ad12	a9 08		lda #$08			lda 	#8  						; if zero, use 8 e.g. bitmap at $10000
.ad14					_CBNotDefault:
.ad14	8d d7 05	sta $05d7			sta 	gxBasePage
.ad17	20 78 ad	jsr $ad78			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.ad1a	a5 37		lda $37				lda 	gxzTemp0+1 					; copy address into Bitmap address registers
.ad1c	8d 03 d1	sta $d103			sta 	$D103
.ad1f	a5 36		lda $36				lda 	gxzTemp0
.ad21	8d 02 d1	sta $d102			sta 	$D102
.ad24	9c 01 d1	stz $d101			stz 	$D101
.ad27	a2 f0		ldx #$f0			ldx 	#240 						; height is 240
.ad29	ad 01 d0	lda $d001			lda 	$D001 						; read MCR bit 0
.ad2c	29 01		and #$01			and 	#1
.ad2e	f0 02		beq $ad32			beq 	_CBHaveHeight
.ad30	a2 c8		ldx #$c8			ldx 	#200 						; if bit 0 set 320x200
.ad32					_CBHaveHeight
.ad32	8e d9 05	stx $05d9			stx 	gxHeight
.ad35	18		clc				clc
.ad36	60		rts				rts
.ad37					GXControlSprite:
.ad37	64 01		stz $01				stz 	1
.ad39	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.ad3b	29 01		and #$01			and 	#1 							; set sprites flag
.ad3d	8d d5 05	sta $05d5			sta 	gxSpritesOn
.ad40	4a		lsr a				lsr 	a 							; bit 0 into carry.
.ad41	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.ad44	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.ad46	29 df		and #$df			and 	#$DF 						; clear sprite bit
.ad48	90 02		bcc $ad4c			bcc 	_CSNotOn
.ad4a	09 20		ora #$20			ora 	#$20 						; sprite on if 1 on 0 off
.ad4c					_CSNotOn:
.ad4c	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.ad4f	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.ad51	d0 02		bne $ad55			bne 	_CSNotDefault
.ad53	a9 18		lda #$18			lda 	#24  						; if zero, use 24 e.g. sprites at $30000
.ad55					_CSNotDefault:
.ad55	8d d8 05	sta $05d8			sta 	gxSpritePage
.ad58	20 78 ad	jsr $ad78			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.ad5b	a5 36		lda $36				lda 	zTemp0
.ad5d	8d e3 05	sta $05e3			sta 	GXSpriteOffsetBase
.ad60	a5 37		lda $37				lda 	zTemp0+1
.ad62	8d e4 05	sta $05e4			sta 	GXSpriteOffsetBase+1
.ad65	a2 00		ldx #$00			ldx 	#0 							; disable all sprites, clears all sprite memory.
.ad67					_CSClear:
.ad67	9e 00 d9	stz $d900,x			stz 	$D900,x
.ad6a	9e 00 da	stz $da00,x			stz 	$DA00,x
.ad6d	ca		dex				dex
.ad6e	d0 f7		bne $ad67			bne 	_CSClear
.ad70	9c e2 05	stz $05e2			stz 	GSCurrentSpriteAddr+1 		; no sprite selected.
.ad73	20 86 ad	jsr $ad86			jsr 	GXClearSpriteStore
.ad76	18		clc				clc
.ad77	60		rts				rts
.ad78					GXCalculateBaseAddress:
.ad78	85 36		sta $36				sta 	gxzTemp0
.ad7a	64 37		stz $37				stz 	gxzTemp0+1
.ad7c	a9 05		lda #$05			lda 	#5
.ad7e					_GXShift:
.ad7e	06 36		asl $36				asl 	gxzTemp0
.ad80	26 37		rol $37				rol 	gxzTemp0+1
.ad82	3a		dec a				dec		a
.ad83	d0 f9		bne $ad7e			bne 	_GXShift
.ad85	60		rts				rts
.ad86					GXClearSpriteStore:
.ad86	a2 3f		ldx #$3f			ldx 	#63 						; erase 64 sprite store elements
.ad88					_GXCSSLoop:
.ad88	9e 25 06	stz $0625,x			stz 	GXSpriteHigh,x
.ad8b	a9 80		lda #$80			lda 	#$80 						; set the 'hidden' bit.
.ad8d	9d e5 05	sta $05e5,x			sta 	GXSpriteLow,x
.ad90	ca		dex				dex
.ad91	10 f5		bpl $ad88			bpl 	_GXCSSLoop
.ad93	60		rts				rts
.ad94					GXLine:
.ad94	ad d6 05	lda $05d6			lda 	GXBitmapsOn
.ad97	f0 28		beq $adc1			beq 	_GXLFail
.ad99	20 76 b2	jsr $b276			jsr 	GXOpenBitmap
.ad9c	20 bc b3	jsr $b3bc			jsr 	GXSortY						; sort pairs so Y1 >= Y0 e.g. top to bottom.
.ad9f	20 67 ae	jsr $ae67			jsr 	GXLineSetup 				; the calculations in the linescanner constructor
.ada2	20 86 b2	jsr $b286			jsr 	GXPositionCalc 				; calculate position/offset.
.ada5					_GXDrawLoop:
.ada5	ac df 05	ldy $05df			ldy 	gsOffset 					; draw the pixel
.ada8	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.adaa	2d dd 05	and $05dd			and 	gxANDValue
.adad	4d dc 05	eor $05dc			eor 	gxEORValue
.adb0	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.adb2	20 c3 ad	jsr $adc3			jsr 	GXLineIsComplete 			; is the line complete ?
.adb5	f0 05		beq $adbc			beq 	_GXLExit
.adb7	20 de ad	jsr $adde			jsr 	GXLineAdvance 				; code as per advance method
.adba	80 e9		bra $ada5			bra 	_GXDrawLoop
.adbc					_GXLExit:
.adbc	20 7e b2	jsr $b27e			jsr 	GXCloseBitmap
.adbf	18		clc				clc
.adc0	60		rts				rts
.adc1					_GXLFail:
.adc1	38		sec				sec
.adc2	60		rts				rts
.adc3					GXLineIsComplete:
.adc3	ad 6c 06	lda $066c			lda 	GXIsDiffYLarger 			; is dy larger
.adc6	d0 0f		bne $add7			bne 	_GXLICCompareY 				; if so compare Y1/Y0
.adc8	ad cd 05	lda $05cd			lda 	GXX0 						; compare X, LSB and MSB
.adcb	4d d1 05	eor $05d1			eor 	GXX1
.adce	d0 06		bne $add6			bne 	_GXLICExit
.add0	ad ce 05	lda $05ce			lda 	GXX0+1
.add3	4d d2 05	eor $05d2			eor 	GXX1+1
.add6					_GXLICExit:
.add6	60		rts				rts
.add7					_GXLICCompareY:
.add7	ad d3 05	lda $05d3			lda 	GXY1
.adda	4d cf 05	eor $05cf			eor 	GXY0
.addd	60		rts				rts
.adde					GXLineAdvance:
.adde	18		clc				clc 								; add adjust to position
.addf	ad 6e 06	lda $066e			lda 	GXPosition
.ade2	6d 6f 06	adc $066f			adc 	GXAdjust
.ade5	8d 6e 06	sta $066e			sta 	GXPosition
.ade8	9c 71 06	stz $0671			stz 	GXAddSelect 				; clear add select flag
.adeb	b0 05		bcs $adf2			bcs 	_GXLAOverflow 				; if carry out, overflowed.
.aded	cd 70 06	cmp $0670			cmp 	GXTotal 					; if exceeded total
.adf0	90 0a		bcc $adfc			bcc 	_GXLANoExtra
.adf2					_GXLAOverflow:
.adf2	ce 71 06	dec $0671			dec 	GXAddSelect 				; set addselect to $FF
.adf5	38		sec				sec 								; subtract total and write back
.adf6	ed 70 06	sbc $0670			sbc 	GXTotal
.adf9	8d 6e 06	sta $066e			sta 	GXPosition
.adfc					_GXLANoExtra:
.adfc	ad 6c 06	lda $066c			lda 	GXIsDiffYLarger
.adff	f0 0d		beq $ae0e			beq 	_GXDXLarger
.ae01	20 60 ae	jsr $ae60			jsr 	GXIncrementY
.ae04	ad 71 06	lda $0671			lda 	GXAddSelect
.ae07	f0 10		beq $ae19			beq 	_GXLAExit
.ae09	20 1a ae	jsr $ae1a			jsr 	GXAdjustX
.ae0c	80 0b		bra $ae19			bra 	_GXLAExit
.ae0e					_GXDXLarger:
.ae0e	20 1a ae	jsr $ae1a			jsr 	GXAdjustX
.ae11	ad 71 06	lda $0671			lda 	GXAddSelect
.ae14	f0 03		beq $ae19			beq 	_GXLAExit
.ae16	20 60 ae	jsr $ae60			jsr 	GXIncrementY
.ae19					_GXLAExit:
.ae19	60		rts				rts
.ae1a					GXAdjustX:
.ae1a	ad 6d 06	lda $066d			lda 	GXDXNegative
.ae1d	10 25		bpl $ae44			bpl 	_GXAXRight
.ae1f	ad cd 05	lda $05cd			lda 	GXX0
.ae22	d0 03		bne $ae27			bne 	_GXAXNoBorrow
.ae24	ce ce 05	dec $05ce			dec 	GXX0+1
.ae27					_GXAXNoBorrow:
.ae27	ce cd 05	dec $05cd			dec 	GXX0
.ae2a	ce df 05	dec $05df			dec 	gsOffset 					; pixel left
.ae2d	ad df 05	lda $05df			lda 	gsOffset
.ae30	c9 ff		cmp #$ff			cmp 	#$FF
.ae32	d0 0f		bne $ae43			bne 	_GXAYExit 					; underflow
.ae34	c6 3d		dec $3d				dec 	gxzScreen+1 					; borrow
.ae36	a5 3d		lda $3d				lda 	gxzScreen+1 					; gone off page
.ae38	c9 60		cmp #$60			cmp 	#GXMappingAddress >> 8
.ae3a	b0 07		bcs $ae43			bcs 	_GXAYExit
.ae3c	18		clc				clc
.ae3d	69 20		adc #$20			adc 	#$20 						; fix up
.ae3f	85 3d		sta $3d				sta 	gxzScreen+1
.ae41	c6 0b		dec $0b				dec 	GXEditSlot 				; back one page
.ae43					_GXAYExit:
.ae43	60		rts				rts
.ae44					_GXAXRight:
.ae44	ee cd 05	inc $05cd			inc 	GXX0
.ae47	d0 03		bne $ae4c			bne 	_GXAXNoCarry
.ae49	ee ce 05	inc $05ce			inc 	GXX0+1
.ae4c					_GXAXNoCarry:
.ae4c	ee df 05	inc $05df			inc 	gsOffset 					; pixel right
.ae4f	d0 0e		bne $ae5f			bne 	_GXAXExit 					; if not overflowed, exit.
.ae51	e6 3d		inc $3d				inc 	gxzScreen+1 					; next line
.ae53	a5 3d		lda $3d				lda 	gxzScreen+1
.ae55	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.ae57	90 06		bcc $ae5f			bcc 	_GXAXExit
.ae59	e9 20		sbc #$20			sbc 	#$20 						; fix up
.ae5b	85 3d		sta $3d				sta 	gxzScreen+1
.ae5d	e6 0b		inc $0b				inc 	GXEditSlot 				; next page
.ae5f					_GXAXExit:
.ae5f	60		rts				rts
.ae60					GXIncrementY:
.ae60	ee cf 05	inc $05cf			inc 	GXY0
.ae63	20 dc b2	jsr $b2dc			jsr 	GXMovePositionDown
.ae66	60		rts				rts
.ae67					GXLineSetup:
.ae67	ad d3 05	lda $05d3			lda 	GXY1
.ae6a	38		sec				sec
.ae6b	ed cf 05	sbc $05cf			sbc 	GXY0
.ae6e	4a		lsr a				lsr 	a
.ae6f	8d 6b 06	sta $066b			sta 	GXDiffY
.ae72	9c 6d 06	stz $066d			stz 	GXDXNegative 				; clear -ve flag
.ae75	38		sec				sec
.ae76	ad d1 05	lda $05d1			lda 	GXX1
.ae79	ed cd 05	sbc $05cd			sbc 	GXX0
.ae7c	8d 6a 06	sta $066a			sta 	GXDiffX
.ae7f	ad d2 05	lda $05d2			lda 	GXX1+1 						; calculate MSB
.ae82	ed ce 05	sbc $05ce			sbc 	GXX0+1
.ae85	6a		ror a				ror 	a 							; rotate bit into DiffX halving it
.ae86	6e 6a 06	ror $066a			ror 	GXDiffX
.ae89	0a		asl a				asl 	a
.ae8a	10 0c		bpl $ae98			bpl 	_GDXNotNegative
.ae8c	a9 00		lda #$00			lda 	#0 							; make absolute value of |dx|
.ae8e	38		sec				sec
.ae8f	ed 6a 06	sbc $066a			sbc 	GXDiffX
.ae92	8d 6a 06	sta $066a			sta 	GXDiffX
.ae95	ce 6d 06	dec $066d			dec 	GXDXNegative 				; -ve flag = $FF.
.ae98					_GDXNotNegative:
.ae98	9c 6c 06	stz $066c			stz 	GXIsDiffYLarger 			; clear larger flag
.ae9b	ad 6b 06	lda $066b			lda 	GXDiffY 					; set adjust and total.
.ae9e	8d 6f 06	sta $066f			sta 	GXAdjust
.aea1	ad 6a 06	lda $066a			lda 	GXDiffX
.aea4	8d 70 06	sta $0670			sta 	GXTotal
.aea7	ad 6b 06	lda $066b			lda 	GXDiffY 					; if dy > dx
.aeaa	cd 6a 06	cmp $066a			cmp 	GXDiffX
.aead	90 0f		bcc $aebe			bcc 	_GDXNotLarger
.aeaf	ce 6c 06	dec $066c			dec 	GXIsDiffYLarger 			; set the dy larger flag
.aeb2	ad 6a 06	lda $066a			lda 	GXDiffX 					; set adjust and total other way round
.aeb5	8d 6f 06	sta $066f			sta 	GXAdjust
.aeb8	ad 6b 06	lda $066b			lda 	GXDiffY
.aebb	8d 70 06	sta $0670			sta 	GXTotal
.aebe					_GDXNotLarger:
.aebe	ad 70 06	lda $0670			lda 	GXTotal
.aec1	4a		lsr a				lsr 	a
.aec2	8d 6e 06	sta $066e			sta 	GXPosition
.aec5	60		rts				rts
.066a					GXDiffX:
>066a							.fill 	1
.066b					GXDiffY:
>066b							.fill 	1
.066c					GXIsDiffYLarger:
>066c							.fill 	1
.066d					GXDXNegative:
>066d							.fill 	1
.066e					GXPosition:
>066e							.fill 	1
.066f					GXAdjust:
>066f							.fill 	1
.0670					GXTotal:
>0670							.fill 	1
.0671					GXAddSelect:
>0671							.fill 	1
.aec6					GXSetColourMode:
.aec6	a6 36		ldx $36				ldx 	gxzTemp0
.aec8	8e db 05	stx $05db			stx 	gxColour 								; set colour
.aecb	a5 37		lda $37				lda 	gxzTemp0+1 								;
.aecd	8d da 05	sta $05da			sta 	gxMode 									; set mode
.aed0	29 03		and #$03			and 	#3 										; only interested in bits 0-3
.aed2	9c dd 05	stz $05dd			stz 	gxANDValue 								; initially AND with 0, and EOR with Colour
.aed5	ae db 05	ldx $05db			ldx 	gxColour
.aed8	8e dc 05	stx $05dc			stx 	gxEORValue
.aedb	c9 02		cmp #$02			cmp 	#2 										; if mode 2/3 And with colour
.aedd	90 03		bcc $aee2			bcc 	_GXSDCNotAndColour
.aedf	8e dd 05	stx $05dd			stx 	gxANDValue
.aee2					_GXSDCNotAndColour:
.aee2	d0 03		bne $aee7			bne 	_GXSDCNotAnd 							; mode 2, Don't EOR with colour
.aee4	9c dc 05	stz $05dc			stz 	gxEORValue
.aee7					_GXSDCNotAnd:
.aee7	4a		lsr a				lsr 	a 										; if bit 0 set, 1's complement AND value
.aee8	90 08		bcc $aef2			bcc 	_GXSDCNoFlip
.aeea	ad dd 05	lda $05dd			lda	 	gxANDValue
.aeed	49 ff		eor #$ff			eor 	#$FF
.aeef	8d dd 05	sta $05dd			sta 	gxANDValue
.aef2					_GXSDCNoFlip:
.aef2	18		clc				clc
.aef3	60		rts				rts
.aef4					GXPlotPoint:
.aef4	20 76 b2	jsr $b276			jsr 	GXOpenBitmap 				; start drawing
.aef7	20 86 b2	jsr $b286			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.aefa	ac df 05	ldy $05df			ldy 	gsOffset
.aefd	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.aeff	2d dd 05	and $05dd			and 	gxANDValue
.af02	4d dc 05	eor $05dc			eor 	gxEORValue
.af05	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.af07	20 7e b2	jsr $b27e			jsr 	GXCloseBitmap 				; stop drawing and exit
.af0a	18		clc				clc
.af0b	60		rts				rts
.af0c					GXFillRectangle:
.af0c	38		sec				sec
.af0d	80 01		bra $af10			bra 	GXRectangle
.af0f					GXFrameRectangle:
.af0f	18		clc				clc
.af10					GXRectangle:
.af10	ad d6 05	lda $05d6			lda 	gxBitmapsOn
.af13	f0 35		beq $af4a			beq 	_GXRFail
.af15	08		php				php 								; save Fill flag (CS)
.af16	20 76 b2	jsr $b276			jsr 	GXOpenBitmap 				; start drawing
.af19	20 9e b3	jsr $b39e			jsr 	GXSortXY 					; sort both X and Y so top left/bottom right
.af1c	20 86 b2	jsr $b286			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.af1f	38		sec				sec 								; sec = Draw line
.af20	20 4c af	jsr $af4c			jsr 	GXDrawLineX1X0 				; draw a line length X1-X0
.af23	ad cf 05	lda $05cf			lda 	gxY0 						; reached end of rectangle ?
.af26	cd d3 05	cmp $05d3			cmp 	gxY1
.af29	f0 19		beq $af44			beq 	_GXRectangleExit
.af2b					_GXRectLoop:
.af2b	20 dc b2	jsr $b2dc			jsr 	GXMovePositionDown 			; down one.
.af2e	ee cf 05	inc $05cf			inc 	gxY0 						; change Y pos
.af31	ad cf 05	lda $05cf			lda 	gxY0 						; reached last line
.af34	cd d3 05	cmp $05d3			cmp 	gXY1
.af37	f0 07		beq $af40			beq 	_GXLastLine
.af39	28		plp				plp 								; get flag back
.af3a	08		php				php
.af3b	20 4c af	jsr $af4c			jsr 	GXDrawLineX1X0 				; draw horizontal line
.af3e	80 eb		bra $af2b			bra 	_GXRectLoop
.af40					_GXLastLine:
.af40	38		sec				sec
.af41	20 4c af	jsr $af4c			jsr 	GXDrawLineX1X0
.af44					_GXRectangleExit:
.af44	68		pla				pla 								; throw fill flag.
.af45	20 7e b2	jsr $b27e			jsr 	GXCloseBitmap 				; stop drawing and exit
.af48	18		clc				clc
.af49	60		rts				rts
.af4a					_GXRFail:
.af4a	38		sec				sec
.af4b	60		rts				rts
.af4c					GXDrawLineX1X0:
.af4c	08		php				php 								; save solid/either-end
.af4d	38		sec				sec
.af4e	ad d1 05	lda $05d1			lda		gXX1
.af51	ed cd 05	sbc $05cd			sbc 	gXX0
.af54	85 36		sta $36				sta 	gxzTemp0
.af56	ad d2 05	lda $05d2			lda 	gXX1+1
.af59	ed ce 05	sbc $05ce			sbc 	gXX0+1
.af5c	85 37		sta $37				sta 	gxzTemp0+1
.af5e	28		plp				plp
.af5f					GXDrawLineTemp0:
.af5f	a5 3c		lda $3c				lda 	gxzScreen 						; push gxzScreen, gsOffset and GXEditSlot on stack
.af61	48		pha				pha
.af62	a5 3d		lda $3d				lda 	gxzScreen+1
.af64	48		pha				pha
.af65	ad df 05	lda $05df			lda 	gsOffset
.af68	48		pha				pha
.af69	a5 0b		lda $0b				lda 	GXEditSlot
.af6b	48		pha				pha
.af6c	ac df 05	ldy $05df			ldy 	gsOffset 					; Y offset
.af6f	90 1e		bcc $af8f			bcc 	_GXDLTEndPoints 			; if CC draw end points only.
.af71					_GXDLTLine:
.af71	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.af73	2d dd 05	and $05dd			and 	gxANDValue
.af76	4d dc 05	eor $05dc			eor 	gxEORValue
.af79	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.af7b	a5 36		lda $36				lda 	gxzTemp0 					; decrement counter
.af7d	d0 04		bne $af83			bne 	_GXDLTNoBorrow
.af7f	c6 37		dec $37				dec 	gxzTemp0+1 					; borrow, if goes -ve then exit
.af81	30 2e		bmi $afb1			bmi 	_GXDLTExit
.af83					_GXDLTNoBorrow:
.af83	c6 36		dec $36				dec 	gxzTemp0
.af85	c8		iny				iny 								; next slot.
.af86	d0 e9		bne $af71			bne 	_GXDLTLine
.af88	e6 3d		inc $3d				inc 	gxzScreen+1 					; carry to next
.af8a	20 bf af	jsr $afbf			jsr 	GXDLTCheckWrap				; check for new page.
.af8d	80 e2		bra $af71			bra 	_GXDLTLine
.af8f					_GXDLTEndPoints:
.af8f	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.af91	2d dd 05	and $05dd			and 	gxANDValue
.af94	4d dc 05	eor $05dc			eor 	gxEORValue
.af97	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.af99	98		tya				tya 								; advance to right side
.af9a	18		clc				clc
.af9b	65 36		adc $36				adc 	gxzTemp0
.af9d	a8		tay				tay
.af9e	a5 3d		lda $3d				lda 	gxzScreen+1
.afa0	65 37		adc $37				adc 	gxzTemp0+1
.afa2	85 3d		sta $3d				sta 	gxzScreen+1
.afa4	20 bf af	jsr $afbf			jsr 	GXDLTCheckWrap 			; fix up.
.afa7	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.afa9	2d dd 05	and $05dd			and 	gxANDValue
.afac	4d dc 05	eor $05dc			eor 	gxEORValue
.afaf	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.afb1					_GXDLTExit:
.afb1	68		pla				pla
.afb2	85 0b		sta $0b				sta 	GXEditSlot
.afb4	68		pla				pla
.afb5	8d df 05	sta $05df			sta 	gsOffset
.afb8	68		pla				pla
.afb9	85 3d		sta $3d				sta 	gxzScreen+1
.afbb	68		pla				pla
.afbc	85 3c		sta $3c				sta 	gxzScreen
.afbe	60		rts				rts
.afbf					GXDLTCheckWrap:
.afbf	a5 3d		lda $3d				lda 	gxzScreen+1 					; check end of page
.afc1	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8)
.afc3	90 06		bcc $afcb			bcc 	_GXDLTCWExit
.afc5	e9 20		sbc #$20			sbc 	#$20 						; fix up
.afc7	85 3d		sta $3d				sta 	gxzScreen+1
.afc9	e6 0b		inc $0b				inc 	GXEditSlot
.afcb					_GXDLTCWExit:
.afcb	60		rts				rts
.afcc					GXDrawGraphicElement:
.afcc	8d 72 06	sta $0672			sta 	gxSize 						; save size
.afcf	3a		dec a				dec 	a
.afd0	8d 73 06	sta $0673			sta 	gxMask 						; and mask
.afd3	ad d6 05	lda $05d6			lda 	gxBitmapsOn 				; check BMP on
.afd6	f0 67		beq $b03f			beq 	_GXSLFail
.afd8	ad cf 05	lda $05cf			lda 	gxY0 						; push Y on stack
.afdb	48		pha				pha
.afdc	8c 75 06	sty $0675			sty 	gxAcquireVector+1 			; and acquisition vector
.afdf	8e 74 06	stx $0674			stx 	gxAcquireVector
.afe2	20 76 b2	jsr $b276			jsr 	gxOpenBitmap 				; open the bitmap.
.afe5	ad 77 06	lda $0677			lda 	gxUseMode 					; scale bits
.afe8	4a		lsr a				lsr 	a
.afe9	4a		lsr a				lsr 	a
.afea	4a		lsr a				lsr 	a
.afeb	29 07		and #$07			and		#7
.afed	1a		inc a				inc 	a
.afee	8d 76 06	sta $0676			sta 	gxScale
.aff1	64 38		stz $38				stz 	gxzTemp1					; start first line
.aff3					_GXGELoop:
.aff3	a5 38		lda $38				lda 	gxzTemp1 					; current line number to read.
.aff5	2c 77 06	bit $0677			bit 	gxUseMode 					; check for flip.
.aff8	10 06		bpl $b000			bpl		_GXNoVFlip
.affa	ad 73 06	lda $0673			lda 	gxMask
.affd	38		sec				sec
.affe	e5 38		sbc $38				sbc 	gxzTemp1
.b000					_GXNoVFlip:
.b000	aa		tax				tax 								; get the Xth line.
.b001	20 41 b0	jsr $b041			jsr 	_GXCallAcquire 				; get that data.
.b004	ad 76 06	lda $0676			lda 	gxScale 					; do scale identical copies of that line.
.b007	85 39		sta $39				sta 	gxzTemp1+1
.b009					_GXGELoop2:
.b009	ad cf 05	lda $05cf			lda 	gxY0 						; off screen
.b00c	cd d9 05	cmp $05d9			cmp 	gxHeight
.b00f	b0 10		bcs $b021			bcs 	_GXDGEExit
.b011	20 44 b0	jsr $b044			jsr 	GXRenderOneLine 			; render line
.b014	c6 39		dec $39				dec 	gxzTemp1+1 					; scale times.
.b016	d0 f1		bne $b009			bne 	_GXGELoop2
.b018	e6 38		inc $38				inc 	gxzTemp1 					; done all lines.
.b01a	a5 38		lda $38				lda 	gxzTemp1
.b01c	cd 72 06	cmp $0672			cmp 	gxSize
.b01f	d0 d2		bne $aff3			bne 	_GXGELoop
.b021					_GXDGEExit:
.b021	68		pla				pla 								; restore Y for next time
.b022	8d cf 05	sta $05cf			sta 	gxY0
.b025	ae 76 06	ldx $0676			ldx 	gxScale 					; get scale (1-8)
.b028					_GXShiftLeft:
.b028	18		clc				clc
.b029	ad 72 06	lda $0672			lda 	gxSize
.b02c	6d cd 05	adc $05cd			adc 	gxX0
.b02f	8d cd 05	sta $05cd			sta 	gxX0
.b032	90 03		bcc $b037			bcc 	_GXSLNoCarry
.b034	ee ce 05	inc $05ce			inc 	gxX0+1
.b037					_GXSLNoCarry:
.b037	ca		dex				dex
.b038	d0 ee		bne $b028			bne 	_GXShiftLeft
.b03a	20 7e b2	jsr $b27e			jsr 	GXCloseBitmap
.b03d	18		clc				clc
.b03e	60		rts				rts
.b03f					_GXSLFail:
.b03f	38		sec				sec
.b040	60		rts				rts
.b041					_GXCallAcquire:
.b041	6c 74 06	jmp ($0674)			jmp 	(gxAcquireVector)
.b044					GXRenderOneLine:
.b044	20 86 b2	jsr $b286			jsr 	GXPositionCalc 				; calculate position/offset.
.b047	ac df 05	ldy $05df			ldy 	gsOffset 					; Y contains position.
.b04a	64 3a		stz $3a				stz 	gxzTemp2 					; do size pixels
.b04c					_GXROLLoop1:
.b04c	ad 76 06	lda $0676			lda 	gxScale 					; set to do 'scale' times
.b04f	85 3b		sta $3b				sta 	gxzTemp2+1
.b051					_GXROLLoop2:
.b051	a5 3a		lda $3a				lda 	gxzTemp2 					; get current pixel
.b053	2c da 05	bit $05da			bit 	gxMode 						; check H Flip
.b056	50 06		bvc $b05e			bvc 	_GXNoHFlip
.b058	ad 73 06	lda $0673			lda 	gxMask
.b05b	38		sec				sec
.b05c	e5 3a		sbc $3a				sbc 	gxzTemp2
.b05e					_GXNoHFlip:
.b05e	aa		tax				tax 								; read from the pixel buffer
.b05f	bd 7b 05	lda $057b,x			lda 	gxPixelBuffer,x
.b062	d0 07		bne $b06b			bne 	_GXDraw 					; draw if non zero
.b064	ad 77 06	lda $0677			lda 	gxUseMode 					; check to see if solid background
.b067	29 04		and #$04			and 	#4
.b069	f0 0a		beq $b075			beq 	_GXZeroPixel
.b06b					_GXDraw:
.b06b	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.b06d	2d dd 05	and $05dd			and 	gxANDValue
.b070	5d 7b 05	eor $057b,x			eor 	gxPixelBuffer,x
.b073	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b075					_GXZeroPixel:
.b075	c8		iny				iny 								; advance pointer
.b076	d0 05		bne $b07d			bne 	_GXNoShift
.b078	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.b07a	20 bf af	jsr $afbf			jsr 	GXDLTCheckWrap				; check for new page.
.b07d					_GXNoShift:
.b07d	c6 3b		dec $3b				dec 	gxzTemp2+1 					; do the inner loop gxScale times.
.b07f	d0 d0		bne $b051			bne 	_GXROLLoop2
.b081	e6 3a		inc $3a				inc 	gxzTemp2 					; next pixel.
.b083	a5 3a		lda $3a				lda 	gxzTemp2
.b085	cd 72 06	cmp $0672			cmp 	gxSize
.b088	d0 c2		bne $b04c			bne 	_GXROLLoop1
.b08a	ee cf 05	inc $05cf			inc 	gxY0
.b08d	60		rts				rts
.0672					gxSize:
>0672							.fill 	1
.0673					gxMask:
>0673							.fill 	1
.0674					gxAcquireVector:
>0674							.fill 	2
.0676					gxScale:
>0676							.fill 	1
.0677					gxUseMode:
>0677							.fill 	1
.b08e					GXFontHandler:
.b08e	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b090	4d da 05	eor $05da			eor 	gxMode
.b093	8d 77 06	sta $0677			sta 	gxUseMode
.b096	64 37		stz $37				stz 	gxzTemp0+1 					; gxzTemp0 is font #
.b098	06 36		asl $36				asl	 	gxzTemp0 					; x 2
.b09a	26 37		rol $37				rol	 	gxzTemp0+1
.b09c	06 36		asl $36				asl	 	gxzTemp0 					; x 4
.b09e	26 37		rol $37				rol	 	gxzTemp0+1
.b0a0	06 36		asl $36				asl	 	gxzTemp0 					; x 8
.b0a2	26 37		rol $37				rol	 	gxzTemp0+1
.b0a4	a5 37		lda $37				lda 	gxzTemp0+1 					; put in page C0
.b0a6	09 c0		ora #$c0			ora 	#$C0
.b0a8	85 37		sta $37				sta 	gxzTemp0+1
.b0aa	a9 08		lda #$08			lda 	#8 							; size 8x8
.b0ac	a2 b4		ldx #$b4			ldx 	#GXGetGraphicDataFont & $FF ; XY = Graphic Data retrieval routine
.b0ae	a0 b0		ldy #$b0			ldy 	#GXGetGraphicDataFont >> 8
.b0b0	20 cc af	jsr $afcc			jsr 	GXDrawGraphicElement
.b0b3	60		rts				rts
.b0b4					GXGetGraphicDataFont:
.b0b4	8a		txa				txa 								; X->Y
.b0b5	a8		tay				tay
.b0b6	a6 01		ldx $01				ldx 	1 							; preserve old value
.b0b8	a9 01		lda #$01			lda 	#1 							; access page 1 (font memory)
.b0ba	85 01		sta $01				sta 	1
.b0bc	b1 36		lda ($36),y			lda 	(gxzTemp0),y 				; read the font element.
.b0be	86 01		stx $01				stx 	1 							; put old value back.
.b0c0	a2 00		ldx #$00			ldx 	#0 							; do 8 times
.b0c2					_GXExpand:
.b0c2	9e 7b 05	stz $057b,x			stz 	gxPixelBuffer,x 			; zero in pixel buffer
.b0c5	0a		asl a				asl 	a 							; shift bit 7 into C
.b0c6	90 08		bcc $b0d0			bcc 	_GXNoPixel
.b0c8	48		pha				pha 								; if set, set pixel buffer to current colour.
.b0c9	ad db 05	lda $05db			lda 	gxColour
.b0cc	9d 7b 05	sta $057b,x			sta 	gxPixelBuffer,x
.b0cf	68		pla				pla
.b0d0					_GXNoPixel:
.b0d0	e8		inx				inx 								; do the whole byte.
.b0d1	e0 08		cpx #$08			cpx 	#8
.b0d3	d0 ed		bne $b0c2			bne 	_GXExpand
.b0d5	60		rts				rts
.b0d6					GXSpriteHandler:
.b0d6	ad d5 05	lda $05d5			lda 	gxSpritesOn 				; sprites on ?
.b0d9	f0 23		beq $b0fe			beq 	_GXSHExit
.b0db	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b0dd	4d da 05	eor $05da			eor 	gxMode
.b0e0	8d 77 06	sta $0677			sta 	gxUseMode
.b0e3	a6 36		ldx $36				ldx 	gxzTemp0 					; sprite #
.b0e5	da		phx				phx
.b0e6	20 76 b2	jsr $b276			jsr 	GXOpenBitmap 				; can access sprite information
.b0e9	68		pla				pla
.b0ea	20 57 b3	jsr $b357			jsr 	GXFindSprite 				; get the sprite address
.b0ed	08		php				php
.b0ee	20 7e b2	jsr $b27e			jsr 	GXCloseBitmap
.b0f1	28		plp				plp
.b0f2	b0 0a		bcs $b0fe			bcs		_GXSHExit 					; exit if find failed.
.b0f4	ad 78 06	lda $0678			lda 	GXSizePixels 				; return size
.b0f7	a2 ff		ldx #$ff			ldx 	#GXSpriteAcquire & $FF
.b0f9	a0 b0		ldy #$b0			ldy 	#GXSpriteAcquire >> 8
.b0fb	20 cc af	jsr $afcc			jsr 	GXDrawGraphicElement
.b0fe					_GXSHExit:
.b0fe	60		rts				rts
.b0ff					GXSpriteAcquire:
.b0ff	ad d8 05	lda $05d8			lda 	GXSpritePage				; point to base page
.b102	85 0b		sta $0b				sta 	GXEditSlot
.b104	86 36		stx $36				stx 	zTemp0 						; row number x 1,2,3,4
.b106	a9 00		lda #$00			lda 	#0
.b108	ae 79 06	ldx $0679			ldx 	GXSizeBits
.b10b					_GXTimesRowNumber:
.b10b	18		clc				clc
.b10c	65 36		adc $36				adc 	zTemp0
.b10e	ca		dex				dex
.b10f	10 fa		bpl $b10b			bpl 	_GXTimesRowNumber
.b111	64 37		stz $37				stz 	gxzTemp0+1
.b113	0a		asl a				asl 	a 							; row x 2,4,6,8
.b114	26 37		rol $37				rol 	gxzTemp0+1
.b116	0a		asl a				asl 	a 							; row x 4,8,12,16
.b117	26 37		rol $37				rol 	gxzTemp0+1
.b119	0a		asl a				asl 	a 							; row x 8,16,24,32
.b11a	26 37		rol $37				rol 	gxzTemp0+1
.b11c	85 36		sta $36				sta 	gxzTemp0
.b11e	18		clc				clc 								; add base address.
.b11f	a5 36		lda $36				lda 	gxzTemp0
.b121	6d 7b 06	adc $067b			adc 	GXSpriteOffset
.b124	85 36		sta $36				sta 	gxzTemp0
.b126	a5 37		lda $37				lda 	gxzTemp0+1
.b128	6d 7c 06	adc $067c			adc 	GXSpriteOffset+1
.b12b					_GXSAFindPage:
.b12b	c9 20		cmp #$20			cmp 	#$20 						; on this page
.b12d	90 06		bcc $b135			bcc 	_GXSAFoundPage
.b12f	e9 20		sbc #$20			sbc 	#$20 						; forward one page
.b131	e6 0b		inc $0b				inc 	GXEditSlot
.b133	80 f6		bra $b12b			bra 	_GXSAFindPage
.b135					_GXSAFoundPage:
.b135	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; physical address of page.
.b137	85 37		sta $37				sta 	gxzTemp0+1 					; gxzTemp0 now points to the page
.b139	a0 00		ldy #$00			ldy 	#0
.b13b					_GXSACopyLoop:
.b13b	b1 36		lda ($36),y			lda 	(gxzTemp0),y
.b13d	99 7b 05	sta $057b,y			sta 	gxPixelBuffer,y
.b140	c8		iny				iny
.b141	cc 78 06	cpy $0678			cpy 	GXSizePixels
.b144	d0 f5		bne $b13b			bne 	_GXSACopyLoop
.b146	60		rts				rts
.b147					GXSelect:
.b147	ad d5 05	lda $05d5			lda 	gxSpritesOn
.b14a	f0 22		beq $b16e			beq 	_GXSFail
.b14c	a5 36		lda $36				lda 	gxzTemp0 					; illegal sprite #
.b14e	c9 40		cmp #$40			cmp 	#64
.b150	b0 1c		bcs $b16e			bcs 	_GXSFail
.b152	8d e0 05	sta $05e0			sta 	GSCurrentSpriteID
.b155	a4 37		ldy $37				ldy 	gxzTemp0+1 					; control value.
.b157	a9 00		lda #$00			lda  	#0 							; multiply sprite # x 8 => A
.b159	06 36		asl $36				asl 	gxzTemp0
.b15b	06 36		asl $36				asl 	gxzTemp0
.b15d	06 36		asl $36				asl 	gxzTemp0
.b15f	2a		rol a				rol 	a
.b160	69 d9		adc #$d9			adc 	#$D9 						; sprite area
.b162	8d e2 05	sta $05e2			sta 	GSCurrentSpriteAddr+1 		; address to GSCurrentSprite and gxzTemp
.b165	85 37		sta $37				sta 	gxzTemp0+1
.b167	a5 36		lda $36				lda 	gxzTemp0
.b169	8d e1 05	sta $05e1			sta 	GSCurrentSpriteAddr
.b16c	18		clc				clc
.b16d	60		rts				rts
.b16e					_GXSFail:
.b16e	38		sec				sec
.b16f	60		rts				rts
.b170					GXSelectImage:
.b170	ad d5 05	lda $05d5			lda 	gxSpritesOn
.b173	f0 74		beq $b1e9			beq 	_GXSIFail
.b175	ad e2 05	lda $05e2			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b178	f0 6f		beq $b1e9			beq 	_GXSIFail 					; (checking the MSB)
.b17a	64 01		stz $01				stz 	1
.b17c	a5 37		lda $37				lda 	gxzTemp0+1 					; push show/hide on the stack.
.b17e	d0 6b		bne $b1eb			bne 	_GXSIHide
.b180	a5 36		lda $36				lda 	gxzTemp0 					; sprite image
.b182	48		pha				pha
.b183	20 76 b2	jsr $b276			jsr 	GXOpenBitmap
.b186	68		pla				pla
.b187	20 57 b3	jsr $b357			jsr 	GXFindSprite
.b18a	b0 5a		bcs $b1e6			bcs 	_GXSICloseFail 				; no image
.b18c	a0 01		ldy #$01			ldy 	#1
.b18e	ad e1 05	lda $05e1			lda 	GSCurrentSpriteAddr
.b191	85 36		sta $36				sta 	gxzTemp0
.b193	ad e2 05	lda $05e2			lda 	GSCurrentSpriteAddr+1
.b196	85 37		sta $37				sta 	gxzTemp0+1
.b198	ad 7b 06	lda $067b			lda 	GXSpriteOffset
.b19b	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b19d	18		clc				clc
.b19e	ad 7c 06	lda $067c			lda 	GXSpriteOffset+1
.b1a1	6d e3 05	adc $05e3			adc 	GXSpriteOffsetBase
.b1a4	c8		iny				iny
.b1a5	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b1a7	ad e4 05	lda $05e4			lda 	GXSpriteOffsetBase+1
.b1aa	69 00		adc #$00			adc 	#0
.b1ac	c8		iny				iny
.b1ad	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b1af	ad 79 06	lda $0679			lda 	GXSizeBits 					; get raw size
.b1b2	49 03		eor #$03			eor 	#3 							; make it right (00=32 etc.)
.b1b4	2a		rol a				rol 	a 							; x 2
.b1b5	0a		asl a				asl 	a 							; x 4
.b1b6	0a		asl a				asl 	a 							; x 8
.b1b7	0a		asl a				asl 	a 							; x 16
.b1b8	0d 7a 06	ora $067a			ora 	GXSpriteLUT 				; Or with LUT
.b1bb	0a		asl a				asl 	a 							; 1 shift
.b1bc	09 01		ora #$01			ora 	#1 							; enable sprite.
.b1be	92 36		sta ($36)			sta 	(gxzTemp0) 					; and write back
.b1c0	20 7e b2	jsr $b27e			jsr 	GXCloseBitmap
.b1c3	ae e0 05	ldx $05e0			ldx 	GSCurrentSpriteID 			; point to sprite entries.
.b1c6	bd 25 06	lda $0625,x			lda 	GXSpriteHigh,x 				; clear upper two bits of size
.b1c9	29 3f		and #$3f			and 	#$3F
.b1cb	9d 25 06	sta $0625,x			sta 	GXSpriteHigh,x
.b1ce	ad 79 06	lda $0679			lda 	GXSizeBits 					; get bit size
.b1d1	6a		ror a				ror 	a 							; shift into bits 6/7
.b1d2	6a		ror a				ror 	a
.b1d3	6a		ror a				ror 	a
.b1d4	29 c0		and #$c0			and 	#$C0
.b1d6	1d 25 06	ora $0625,x			ora 	GXSpriteHigh,x 				; put in  upper 2 bits of sprite data
.b1d9	9d 25 06	sta $0625,x			sta 	GXSpriteHigh,x
.b1dc	bd e5 05	lda $05e5,x			lda 	GXSpriteLow,x 				; clear hidden flag.
.b1df	29 7f		and #$7f			and 	#$7F
.b1e1	9d e5 05	sta $05e5,x			sta 	GXSpriteLow,x
.b1e4	18		clc				clc
.b1e5	60		rts				rts
.b1e6					_GXSICloseFail:
.b1e6	20 7e b2	jsr $b27e			jsr 	GXCloseBitmap
.b1e9					_GXSIFail:
.b1e9	38		sec				sec
.b1ea	60		rts				rts
.b1eb					_GXSIHide:
.b1eb	ad e1 05	lda $05e1			lda 	GSCurrentSpriteAddr  		; get Sprite h/w address and write there
.b1ee	85 36		sta $36				sta 	gxzTemp0
.b1f0	ad e2 05	lda $05e2			lda 	GSCurrentSpriteAddr+1
.b1f3	85 37		sta $37				sta 	gxzTemp0+1
.b1f5	a9 00		lda #$00			lda 	#0
.b1f7	92 36		sta ($36)			sta 	(gxzTemp0)
.b1f9	ae e0 05	ldx $05e0			ldx 	GSCurrentSpriteID 			; get sprite ID
.b1fc	bd e5 05	lda $05e5,x			lda 	GXSpriteLow,x 				; set the hidden bit.
.b1ff	09 80		ora #$80			ora 	#$80
.b201	9d e5 05	sta $05e5,x			sta 	GXSpriteLow,x
.b204	18		clc				clc
.b205	60		rts				rts
.b206					GXMoveSprite:
.b206	ad d5 05	lda $05d5			lda 	gxSpritesOn
.b209	f0 65		beq $b270			beq 	_GXSIFail
.b20b	ad e2 05	lda $05e2			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b20e	f0 60		beq $b270			beq 	_GXSIFail
.b210	85 37		sta $37				sta 	gxzTemp0+1
.b212	a0 04		ldy #$04			ldy 	#4
.b214	ad e1 05	lda $05e1			lda 	GSCurrentSpriteAddr
.b217	85 36		sta $36				sta 	gxzTemp0
.b219	ae e0 05	ldx $05e0			ldx 	GSCurrentSpriteID 			; get the size from the upper two bits
.b21c	bd 25 06	lda $0625,x			lda 	GXSpriteHigh,x
.b21f	2a		rol a				rol 	a	 						; into bits 0,1.
.b220	2a		rol a				rol 	a
.b221	2a		rol a				rol 	a
.b222	29 03		and #$03			and 	#3
.b224	aa		tax				tax
.b225	bd 72 b2	lda $b272,x			lda 	_GXMSOffset,x 				; get 32-SpriteSize/2
.b228	48		pha				pha
.b229	18		clc				clc
.b22a	6d cd 05	adc $05cd			adc 	gxX0						; copy position.
.b22d	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b22f	c8		iny				iny
.b230	ad ce 05	lda $05ce			lda 	gxX0+1
.b233	69 00		adc #$00			adc 	#0
.b235	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b237	c8		iny				iny
.b238	68		pla				pla
.b239	18		clc				clc
.b23a	6d cf 05	adc $05cf			adc 	gxY0
.b23d	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b23f	a9 00		lda #$00			lda 	#0
.b241	69 00		adc #$00			adc 	#0
.b243	c8		iny				iny
.b244	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b246	4e ce 05	lsr $05ce			lsr 	gxX0+1 						; divide X by 4
.b249	6e cd 05	ror $05cd			ror 	gxX0
.b24c	4e cd 05	lsr $05cd			lsr 	gxX0
.b24f	4e cf 05	lsr $05cf			lsr 	gxY0 						; divide Y by 4
.b252	4e cf 05	lsr $05cf			lsr 	gxY0
.b255	ae e0 05	ldx $05e0			ldx 	GSCurrentSpriteID 			; copy X/4 and Y/4 into the status bytes
.b258	bd e5 05	lda $05e5,x			lda 	GXSpriteLow,x
.b25b	29 80		and #$80			and 	#$80
.b25d	0d cd 05	ora $05cd			ora 	gxX0
.b260	9d e5 05	sta $05e5,x			sta 	GXSpriteLow,x
.b263	bd 25 06	lda $0625,x			lda 	GXSpriteHigh,x
.b266	29 c0		and #$c0			and 	#$C0
.b268	0d cf 05	ora $05cf			ora 	gxY0
.b26b	9d 25 06	sta $0625,x			sta 	GXSpriteHigh,x
.b26e	18		clc				clc
.b26f	60		rts				rts
.b270					_GXSIFail:
.b270	38		sec				sec
.b271	60		rts				rts
.b272					_GXMSOffset:
>b272	1c						.byte 	32-8/2
>b273	18						.byte 	32-16/2
>b274	14						.byte 	32-24/2
>b275	10						.byte 	32-32/2
.b276					GXOpenBitmap:
.b276	78		sei				sei 								; no interrupts here
.b277	a5 0b		lda $0b				lda 	GXEditSlot 					; Save the original LUT slot value
.b279	8d de 05	sta $05de			sta 	gxOriginalLUTValue
.b27c	58		cli				cli
.b27d	60		rts				rts
.b27e					GXCloseBitmap:
.b27e	78		sei				sei
.b27f	ad de 05	lda $05de			lda 	gxOriginalLUTValue 			; restore LUT slot value
.b282	85 0b		sta $0b				sta 	GXEditSlot
.b284	58		cli				cli
.b285	60		rts				rts
.b286					GXPositionCalc:
.b286	a5 36		lda $36				lda 	gxzTemp0 					; save temp memory slot
.b288	48		pha				pha
.b289	ad cf 05	lda $05cf			lda 	GXY0 						; gxzScreen = Y0
.b28c	85 3c		sta $3c				sta 	gxzScreen
.b28e	64 3d		stz $3d				stz 	gxzScreen+1
.b290	06 3c		asl $3c				asl 	gxzScreen 						; gxzScreen = Y0 * 4
.b292	26 3d		rol $3d				rol 	gxzScreen+1
.b294	06 3c		asl $3c				asl 	gxzScreen
.b296	26 3d		rol $3d				rol 	gxzScreen+1
.b298	18		clc				clc 								; gxzScreen = Y0 * 5, as it's still in A
.b299	65 3c		adc $3c				adc 	gxzScreen
.b29b	85 3c		sta $3c				sta 	gxzScreen
.b29d	90 02		bcc $b2a1			bcc 	_GXPCNoCarry
.b29f	e6 3d		inc $3d				inc 	gxzScreen+1
.b2a1					_GXPCNoCarry:
.b2a1	06 3c		asl $3c				asl 	gxzScreen 						; now Y0 * 10. Needs to be multiplied by another
.b2a3	26 3d		rol $3d				rol 	gxzScreen+1 					; 32. At this point the MSB contains the offset
.b2a5	a5 3d		lda $3d				lda	 	gxzScreen+1 					; so save this in zTemp0 and zero it.
.b2a7	85 36		sta $36				sta 	gxzTemp0
.b2a9	64 3d		stz $3d				stz 	gxzScreen+1
.b2ab	a9 05		lda #$05			lda 	#5 							; now multiply by 32, this puts this in the range 0..8191
.b2ad					_GXPCMultiply32:
.b2ad	06 3c		asl $3c				asl 	gxzScreen
.b2af	26 3d		rol $3d				rol 	gxzScreen+1
.b2b1	3a		dec a				dec 	a
.b2b2	d0 f9		bne $b2ad			bne 	_GXPCMultiply32
.b2b4	18		clc				clc
.b2b5	ad cd 05	lda $05cd			lda 	GXX0 						; add X to this value, put the result in gsOffset, gxzScreen has to be on a page boundary
.b2b8	65 3c		adc $3c				adc 	gxzScreen
.b2ba	8d df 05	sta $05df			sta 	gsOffset
.b2bd	ad ce 05	lda $05ce			lda 	GXX0+1
.b2c0	65 3d		adc $3d				adc 	gxzScreen+1
.b2c2	c9 20		cmp #$20			cmp 	#$20 						; has it overflowed into the next one ?
.b2c4	90 04		bcc $b2ca			bcc 	_GXPCNoOverflow
.b2c6	29 1f		and #$1f			and 	#$1F 						; fix it up
.b2c8	e6 36		inc $36				inc 	gxzTemp0 					; add 1 to the page number
.b2ca					_GXPCNoOverflow:
.b2ca	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; make it the address mapped in.
.b2cc	85 3d		sta $3d				sta 	gxzScreen+1
.b2ce	64 3c		stz $3c				stz 	gxzScreen
.b2d0	18		clc				clc
.b2d1	a5 36		lda $36				lda 	gxzTemp0 					; get the page number
.b2d3	6d d7 05	adc $05d7			adc 	gxBasePage 					; by adding the base page
.b2d6	85 0b		sta $0b				sta 	GXEditSlot 				; and map it into memory.
.b2d8	68		pla				pla
.b2d9	85 36		sta $36				sta 	gxzTemp0
.b2db	60		rts				rts
.b2dc					GXMovePositionDown:
.b2dc	18		clc				clc 								; add 320 to offset/temp+1
.b2dd	ad df 05	lda $05df			lda 	gsOffset
.b2e0	69 40		adc #$40			adc 	#64
.b2e2	8d df 05	sta $05df			sta 	gsOffset
.b2e5	a5 3d		lda $3d				lda 	gxzScreen+1
.b2e7	69 01		adc #$01			adc 	#1
.b2e9	85 3d		sta $3d				sta 	gxzScreen+1
.b2eb	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page
.b2ed	90 07		bcc $b2f6			bcc 	_GXMPDExit
.b2ef	38		sec				sec  								; next page
.b2f0	e9 20		sbc #$20			sbc 	#$20
.b2f2	85 3d		sta $3d				sta 	gxzScreen+1
.b2f4	e6 0b		inc $0b				inc 	GXEditSlot
.b2f6					_GXMPDExit:
.b2f6	60		rts				rts
.b2f7					GXCollide:
.b2f7	a5 36		lda $36				lda 	gxzTemp0 					; check if sprite numbers are legal.
.b2f9	aa		tax				tax
.b2fa	05 37		ora $37				ora 	gxzTemp0+1
.b2fc	29 c0		and #$c0			and 	#$C0
.b2fe	38		sec				sec
.b2ff	d0 53		bne $b354			bne 	_GXCollideFail 				; if either >= 64, fail.
.b301	a4 37		ldy $37				ldy 	gxzTemp0+1 					; at this point X is 1st sprite and Y is 2nd sprite.
.b303	b9 e5 05	lda $05e5,y			lda 	GXSpriteLow,y 				; check if either hidden bit is set
.b306	1d e5 05	ora $05e5,x			ora 	GXSpriteLow,x
.b309	30 48		bmi $b353			bmi 	_GXOkayFail 				; if either hidden, then they cannot collide.
.b30b	18		clc				clc 								; need to calculate sum of sizes.
.b30c	b9 25 06	lda $0625,y			lda 	GXSpriteHigh,y
.b30f	7d 25 06	adc $0625,x			adc 	GXSpriteHigh,x 				; at this point, CS, Bit 6 and 7 contain that sum.
.b312	29 c0		and #$c0			and 	#$C0 					 	; mask off
.b314	6a		ror a				ror 	a 							; 5/6/7
.b315	4a		lsr a				lsr 	a 							; 4/5/6
.b316	4a		lsr a				lsr 	a 							; 3/4/5
.b317	4a		lsr a				lsr 	a 							; 2/3/4
.b318	18		clc				clc
.b319	69 08		adc #$08			adc 	#$08
.b31b	4a		lsr a				lsr 	a 							; adjust because all coordinates are divided by 4 to store.
.b31c	4a		lsr a				lsr 	a
.b31d	85 38		sta $38				sta 	gxzTemp1 					; so the difference between the centres has to be less than this.
.b31f	b9 25 06	lda $0625,y			lda 	GXSpriteHigh,y 				; calculate y1-y0
.b322	29 3f		and #$3f			and 	#$3F
.b324	85 39		sta $39				sta 	gxzTemp1+1
.b326	38		sec				sec
.b327	bd 25 06	lda $0625,x			lda 	GXSpriteHigh,x
.b32a	29 3f		and #$3f			and 	#$3F
.b32c	e5 39		sbc $39				sbc 	gxzTemp1+1
.b32e	b0 03		bcs $b333			bcs 	_GXCAbs1 					; calculate |y1-y0|
.b330	49 ff		eor #$ff			eor 	#$FF
.b332	1a		inc a				inc 	a
.b333					_GXCAbs1:
.b333	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b335	b0 1c		bcs $b353			bcs 	_GXOkayFail
.b337	85 39		sta $39				sta 	gxzTemp1+1 					; save |y1-y0|
.b339	38		sec				sec 								; calculate |x1-x0|
.b33a	b9 e5 05	lda $05e5,y			lda 	GXSpriteLow,y
.b33d	fd e5 05	sbc $05e5,x			sbc 	GXSpriteLow,x
.b340	b0 03		bcs $b345			bcs 	_GXCAbs2
.b342	49 ff		eor #$ff			eor 	#$FF
.b344	1a		inc a				inc 	a
.b345					_GXCAbs2:
.b345	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b347	b0 0a		bcs $b353			bcs 	_GXOkayFail
.b349	c5 39		cmp $39				cmp 	gxzTemp1+1 					; is it less than the previous one.
.b34b	90 02		bcc $b34f			bcc 	_GXCHaveLowest
.b34d	a5 39		lda $39				lda 	gxzTemp1+1 					; if not, that's the smallest difference.
.b34f					_GXCHaveLowest:
.b34f	0a		asl a				asl 	a 							; scale to allow for >> 2
.b350	0a		asl a				asl 	a
.b351	18		clc				clc
.b352	60		rts				rts
.b353					_GXOkayFail:
.b353	18		clc				clc
.b354					_GXCollideFail:
.b354	a9 ff		lda #$ff			lda 	#$FF
.b356	60		rts				rts
.b357					GXFindSprite:
.b357	aa		tax				tax
.b358	ad d8 05	lda $05d8			lda 	GXSpritePage 				; access the base page of the sprite
.b35b	85 0b		sta $0b				sta 	GXEditSlot
.b35d	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; check a valid sprite
.b360	1d 00 60	ora $6000,x			ora 	GXMappingAddress,x
.b363	f0 33		beq $b398			beq 	_GXFSFail
.b365	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; MSB
.b368	8d 7c 06	sta $067c			sta 	GXSpriteOffset+1
.b36b	bd 00 60	lda $6000,x			lda 	GXMappingAddress,x 			; LSB
.b36e	48		pha				pha 								; save twice
.b36f	48		pha				pha
.b370	29 03		and #$03			and 	#3 							; get sprite size
.b372	8d 79 06	sta $0679			sta 	GXSizeBits 					; save raw (0-3)
.b375	aa		tax				tax
.b376	bd 9a b3	lda $b39a,x			lda 	_GXFXSSTTable,x 			; read sprite size
.b379	8d 78 06	sta $0678			sta 	GXSizePixels 					; save (8/16/24/32)
.b37c	68		pla				pla 								; get LUT
.b37d	4a		lsr a				lsr		a
.b37e	4a		lsr a				lsr		a
.b37f	29 03		and #$03			and 	#3
.b381	8d 7a 06	sta $067a			sta 	GXSpriteLUT
.b384	68		pla				pla 								; address, neeeds to be x 4
.b385	29 f0		and #$f0			and 	#$F0
.b387	8d 7b 06	sta $067b			sta 	GXSpriteOffset
.b38a	0e 7b 06	asl $067b			asl 	GXSpriteOffset
.b38d	2e 7c 06	rol $067c			rol 	GXSpriteOffset+1
.b390	0e 7b 06	asl $067b			asl 	GXSpriteOffset
.b393	2e 7c 06	rol $067c			rol 	GXSpriteOffset+1
.b396	18		clc				clc
.b397	60		rts				rts
.b398					_GXFSFail:
.b398	38		sec				sec
.b399	60		rts				rts
.b39a					_GXFXSSTTable:
>b39a	08 10 18 20					.byte 	8,16,24,32
.0678					GXSizePixels:
>0678							.fill 	1
.0679					GXSizeBits:
>0679							.fill 	1
.067a					GXSpriteLUT:
>067a							.fill 	1
.067b					GXSpriteOffset:
>067b							.fill 	2
.b39e					GXSortXY:
.b39e	20 bc b3	jsr $b3bc			jsr 	GXSortY 					; will be sorted on Y now
.b3a1	ad cd 05	lda $05cd			lda 	gxX0 						; compare X0 v X1
.b3a4	cd d1 05	cmp $05d1			cmp 	gxX1
.b3a7	ad ce 05	lda $05ce			lda 	gXX0+1
.b3aa	ed d2 05	sbc $05d2			sbc 	gXX1+1
.b3ad	90 0c		bcc $b3bb			bcc 	_GXSXYExit 					; X0 < X1 exit
.b3af	a2 00		ldx #$00			ldx 	#0 							; swap them over
.b3b1	a0 04		ldy #$04			ldy 	#4
.b3b3	20 d0 b3	jsr $b3d0			jsr 	GXSwapXY
.b3b6	e8		inx				inx
.b3b7	c8		iny				iny
.b3b8	20 d0 b3	jsr $b3d0			jsr 	GXSwapXY
.b3bb					_GXSXYExit:
.b3bb	60		rts				rts
.b3bc					GXSortY:
.b3bc	ad cf 05	lda $05cf			lda 	gxY0 						; if Y0 >= Y1
.b3bf	cd d3 05	cmp $05d3			cmp 	gxY1
.b3c2	90 0b		bcc $b3cf			bcc 	_GXSYSorted
.b3c4	a2 03		ldx #$03			ldx 	#3 							; swap 3-0
.b3c6	a0 07		ldy #$07			ldy 	#7 							; with 4-7
.b3c8					_GXSwap1:
.b3c8	20 d0 b3	jsr $b3d0			jsr 	GXSwapXY
.b3cb	88		dey				dey
.b3cc	ca		dex				dex
.b3cd	10 f9		bpl $b3c8			bpl 	_GXSwap1
.b3cf					_GXSYSorted:
.b3cf	60		rts				rts
.b3d0					GXSwapXY:
.b3d0	bd cd 05	lda $05cd,x			lda 	gxX0,x
.b3d3	48		pha				pha
.b3d4	b9 cd 05	lda $05cd,y			lda 	gxX0,y
.b3d7	9d cd 05	sta $05cd,x			sta 	gxX0,x
.b3da	68		pla				pla
.b3db	99 cd 05	sta $05cd,y			sta 	gxX0,y
.b3de	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_tokeniser.module

=1					tokeniserIntegrated=1
.b3df					KeywordSet0:
>b3df	00 65					.text	0,$65,""               ; $80 !0:EOF
>b3e1	00 58					.text	0,$58,""               ; $81 !1:SH1
>b3e3	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b3e5	04 fe 41 42 53 28			.text	4,$fe,"ABS("           ; $83 ABS(
>b3eb	06 93 41 4c 4c 4f 43 28			.text	6,$93,"ALLOC("         ; $84 ALLOC(
>b3f3	04 ff 41 53 43 28			.text	4,$ff,"ASC("           ; $85 ASC(
>b3f9	05 29 43 48 52 24 28			.text	5,$29,"CHR$("          ; $86 CHR$(
>b400	06 aa 45 56 45 4e 54 28			.text	6,$aa,"EVENT("         ; $87 EVENT(
>b408	05 6b 46 41 4c 53 45			.text	5,$6b,"FALSE"          ; $88 FALSE
>b40f	05 44 46 52 41 43 28			.text	5,$44,"FRAC("          ; $89 FRAC(
>b416	04 0d 48 49 54 28			.text	4,$0d,"HIT("           ; $8a HIT(
>b41c	04 13 49 4e 54 28			.text	4,$13,"INT("           ; $8b INT(
>b422	06 a7 49 53 56 41 4c 28			.text	6,$a7,"ISVAL("         ; $8c ISVAL(
>b42a	05 5c 4a 4f 59 42 28			.text	5,$5c,"JOYB("          ; $8d JOYB(
>b431	05 72 4a 4f 59 58 28			.text	5,$72,"JOYX("          ; $8e JOYX(
>b438	05 73 4a 4f 59 59 28			.text	5,$73,"JOYY("          ; $8f JOYY(
>b43f	06 77 4c 45 46 54 24 28			.text	6,$77,"LEFT$("         ; $90 LEFT$(
>b447	04 07 4c 45 4e 28			.text	4,$07,"LEN("           ; $91 LEN(
>b44d	04 0e 4d 41 58 28			.text	4,$0e,"MAX("           ; $92 MAX(
>b453	05 26 4d 49 44 24 28			.text	5,$26,"MID$("          ; $93 MID$(
>b45a	04 0c 4d 49 4e 28			.text	4,$0c,"MIN("           ; $94 MIN(
>b460	04 19 4e 4f 54 28			.text	4,$19,"NOT("           ; $95 NOT(
>b466	08 3c 50 4c 41 59 49 4e			.text	8,$3c,"PLAYING("       ; $96 PLAYING(
>b46e	47 28
>b470	07 e9 52 41 4e 44 4f 4d			.text	7,$e9,"RANDOM("        ; $97 RANDOM(
>b478	28
>b479	07 ca 52 49 47 48 54 24			.text	7,$ca,"RIGHT$("        ; $98 RIGHT$(
>b481	28
>b482	04 0c 52 4e 44 28			.text	4,$0c,"RND("           ; $99 RND(
>b488	04 10 53 47 4e 28			.text	4,$10,"SGN("           ; $9a SGN(
>b48e	04 0e 53 50 43 28			.text	4,$0e,"SPC("           ; $9b SPC(
>b494	05 45 53 54 52 24 28			.text	5,$45,"STR$("          ; $9c STR$(
>b49b	06 a9 54 49 4d 45 52 28			.text	6,$a9,"TIMER("         ; $9d TIMER(
>b4a3	04 40 54 52 55 45			.text	4,$40,"TRUE"           ; $9e TRUE
>b4a9	04 0b 56 41 4c 28			.text	4,$0b,"VAL("           ; $9f VAL(
>b4af	03 e7 46 4f 52				.text	3,$e7,"FOR"            ; $a0 FOR
>b4b4	02 8f 49 46				.text	2,$8f,"IF"             ; $a1 IF
>b4b8	04 34 50 52 4f 43			.text	4,$34,"PROC"           ; $a2 PROC
>b4be	06 c1 52 45 50 45 41 54			.text	6,$c1,"REPEAT"         ; $a3 REPEAT
>b4c6	05 79 57 48 49 4c 45			.text	5,$79,"WHILE"          ; $a4 WHILE
>b4cd	05 66 45 4e 44 49 46			.text	5,$66,"ENDIF"          ; $a5 ENDIF
>b4d4	07 0b 45 4e 44 50 52 4f			.text	7,$0b,"ENDPROC"        ; $a6 ENDPROC
>b4dc	43
>b4dd	04 3f 4e 45 58 54			.text	4,$3f,"NEXT"           ; $a7 NEXT
>b4e3	04 2f 54 48 45 4e			.text	4,$2f,"THEN"           ; $a8 THEN
>b4e9	05 8c 55 4e 54 49 4c			.text	5,$8c,"UNTIL"          ; $a9 UNTIL
>b4f0	04 2e 57 45 4e 44			.text	4,$2e,"WEND"           ; $aa WEND
>b4f6	02 9b 42 59				.text	2,$9b,"BY"             ; $ab BY
>b4fa	04 1c 43 41 4c 4c			.text	4,$1c,"CALL"           ; $ac CALL
>b500	06 b2 43 49 52 43 4c 45			.text	6,$b2,"CIRCLE"         ; $ad CIRCLE
>b508	05 67 43 4c 45 41 52			.text	5,$67,"CLEAR"          ; $ae CLEAR
>b50f	03 e2 43 4c 53				.text	3,$e2,"CLS"            ; $af CLS
>b514	05 7f 43 4f 4c 4f 52			.text	5,$7f,"COLOR"          ; $b0 COLOR
>b51b	06 d4 43 4f 4c 4f 55 52			.text	6,$d4,"COLOUR"         ; $b1 COLOUR
>b523	04 1a 44 41 54 41			.text	4,$1a,"DATA"           ; $b2 DATA
>b529	03 da 44 49 4d				.text	3,$da,"DIM"            ; $b3 DIM
>b52e	06 db 44 4f 57 4e 54 4f			.text	6,$db,"DOWNTO"         ; $b4 DOWNTO
>b536	04 29 45 4c 53 45			.text	4,$29,"ELSE"           ; $b5 ELSE
>b53c	04 34 46 52 4f 4d			.text	4,$34,"FROM"           ; $b6 FROM
>b542	03 e5 47 46 58				.text	3,$e5,"GFX"            ; $b7 GFX
>b547	05 80 47 4f 53 55 42			.text	5,$80,"GOSUB"          ; $b8 GOSUB
>b54e	04 39 47 4f 54 4f			.text	4,$39,"GOTO"           ; $b9 GOTO
>b554	04 24 48 45 52 45			.text	4,$24,"HERE"           ; $ba HERE
>b55a	05 63 49 4d 41 47 45			.text	5,$63,"IMAGE"          ; $bb IMAGE
>b561	05 90 49 4e 50 55 54			.text	5,$90,"INPUT"          ; $bc INPUT
>b568	03 e5 4c 45 54				.text	3,$e5,"LET"            ; $bd LET
>b56d	04 28 4c 49 4e 45			.text	4,$28,"LINE"           ; $be LINE
>b573	05 6b 4c 4f 43 41 4c			.text	5,$6b,"LOCAL"          ; $bf LOCAL
>b57a	03 db 4f 46 46				.text	3,$db,"OFF"            ; $c0 OFF
>b57f	02 9d 4f 4e				.text	2,$9d,"ON"             ; $c1 ON
>b583	07 20 4f 55 54 4c 49 4e			.text	7,$20,"OUTLINE"        ; $c2 OUTLINE
>b58b	45
>b58c	07 0f 50 41 4c 45 54 54			.text	7,$0f,"PALETTE"        ; $c3 PALETTE
>b594	45
>b595	04 3f 50 4c 4f 54			.text	4,$3f,"PLOT"           ; $c4 PLOT
>b59b	05 8d 50 52 49 4e 54			.text	5,$8d,"PRINT"          ; $c5 PRINT
>b5a2	04 1c 52 45 41 44			.text	4,$1c,"READ"           ; $c6 READ
>b5a8	04 2e 52 45 43 54			.text	4,$2e,"RECT"           ; $c7 RECT
>b5ae	03 e4 52 45 4d				.text	3,$e4,"REM"            ; $c8 REM
>b5b3	06 e0 52 45 54 55 52 4e			.text	6,$e0,"RETURN"         ; $c9 RETURN
>b5bb	05 7b 53 4f 4c 49 44			.text	5,$7b,"SOLID"          ; $ca SOLID
>b5c2	05 89 53 4f 55 4e 44			.text	5,$89,"SOUND"          ; $cb SOUND
>b5c9	06 d7 53 50 52 49 54 45			.text	6,$d7,"SPRITE"         ; $cc SPRITE
>b5d1	04 45 54 45 58 54			.text	4,$45,"TEXT"           ; $cd TEXT
>b5d7	02 a3 54 4f				.text	2,$a3,"TO"             ; $ce TO
>b5db	ff					.text	$FF
.b5dc					KeywordSet1:
>b5dc	00 65					.text	0,$65,""               ; $80 !0:EOF
>b5de	00 58					.text	0,$58,""               ; $81 !1:SH1
>b5e0	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b5e2	08 4c 41 53 53 45 4d 42			.text	8,$4c,"ASSEMBLE"       ; $83 ASSEMBLE
>b5ea	4c 45
>b5ec	06 d2 41 53 53 45 52 54			.text	6,$d2,"ASSERT"         ; $84 ASSERT
>b5f4	06 bd 42 49 54 4d 41 50			.text	6,$bd,"BITMAP"         ; $85 BITMAP
>b5fc	03 d7 45 4e 44				.text	3,$d7,"END"            ; $86 END
>b601	02 96 47 4f				.text	2,$96,"GO"             ; $87 GO
>b605	04 3c 4c 49 53 54			.text	4,$3c,"LIST"           ; $88 LIST
>b60b	04 20 4c 4f 41 44			.text	4,$20,"LOAD"           ; $89 LOAD
>b611	03 ea 4e 45 57				.text	3,$ea,"NEW"            ; $8a NEW
>b616	07 24 52 45 53 54 4f 52			.text	7,$24,"RESTORE"        ; $8b RESTORE
>b61e	45
>b61f	03 f5 52 55 4e				.text	3,$f5,"RUN"            ; $8c RUN
>b624	07 2a 53 50 52 49 54 45			.text	7,$2a,"SPRITES"        ; $8d SPRITES
>b62c	53
>b62d	04 46 53 54 4f 50			.text	4,$46,"STOP"           ; $8e STOP
>b633	03 ee 57 48 4f				.text	3,$ee,"WHO"            ; $8f WHO
>b638	ff					.text	$FF
.b639					KeywordSet2:
>b639	00 65					.text	0,$65,""               ; $80 !0:EOF
>b63b	00 58					.text	0,$58,""               ; $81 !1:SH1
>b63d	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b63f	03 c8 41 44 43				.text	3,$c8,"ADC"            ; $83 ADC
>b644	03 d3 41 4e 44				.text	3,$d3,"AND"            ; $84 AND
>b649	03 e0 41 53 4c				.text	3,$e0,"ASL"            ; $85 ASL
>b64e	03 c8 42 43 43				.text	3,$c8,"BCC"            ; $86 BCC
>b653	03 d8 42 43 53				.text	3,$d8,"BCS"            ; $87 BCS
>b658	03 d8 42 45 51				.text	3,$d8,"BEQ"            ; $88 BEQ
>b65d	03 df 42 49 54				.text	3,$df,"BIT"            ; $89 BIT
>b662	03 d8 42 4d 49				.text	3,$d8,"BMI"            ; $8a BMI
>b667	03 d5 42 4e 45				.text	3,$d5,"BNE"            ; $8b BNE
>b66c	03 de 42 50 4c				.text	3,$de,"BPL"            ; $8c BPL
>b671	03 d5 42 52 41				.text	3,$d5,"BRA"            ; $8d BRA
>b676	03 df 42 52 4b				.text	3,$df,"BRK"            ; $8e BRK
>b67b	03 db 42 56 43				.text	3,$db,"BVC"            ; $8f BVC
>b680	03 eb 42 56 53				.text	3,$eb,"BVS"            ; $90 BVS
>b685	03 d2 43 4c 43				.text	3,$d2,"CLC"            ; $91 CLC
>b68a	03 d3 43 4c 44				.text	3,$d3,"CLD"            ; $92 CLD
>b68f	03 d8 43 4c 49				.text	3,$d8,"CLI"            ; $93 CLI
>b694	03 e5 43 4c 56				.text	3,$e5,"CLV"            ; $94 CLV
>b699	03 e0 43 4d 50				.text	3,$e0,"CMP"            ; $95 CMP
>b69e	03 eb 43 50 58				.text	3,$eb,"CPX"            ; $96 CPX
>b6a3	03 ec 43 50 59				.text	3,$ec,"CPY"            ; $97 CPY
>b6a8	03 cc 44 45 43				.text	3,$cc,"DEC"            ; $98 DEC
>b6ad	03 e1 44 45 58				.text	3,$e1,"DEX"            ; $99 DEX
>b6b2	03 e2 44 45 59				.text	3,$e2,"DEY"            ; $9a DEY
>b6b7	03 e6 45 4f 52				.text	3,$e6,"EOR"            ; $9b EOR
>b6bc	03 da 49 4e 43				.text	3,$da,"INC"            ; $9c INC
>b6c1	03 ef 49 4e 58				.text	3,$ef,"INX"            ; $9d INX
>b6c6	03 f0 49 4e 59				.text	3,$f0,"INY"            ; $9e INY
>b6cb	03 e7 4a 4d 50				.text	3,$e7,"JMP"            ; $9f JMP
>b6d0	03 ef 4a 53 52				.text	3,$ef,"JSR"            ; $a0 JSR
>b6d5	03 d1 4c 44 41				.text	3,$d1,"LDA"            ; $a1 LDA
>b6da	03 e8 4c 44 58				.text	3,$e8,"LDX"            ; $a2 LDX
>b6df	03 e9 4c 44 59				.text	3,$e9,"LDY"            ; $a3 LDY
>b6e4	03 f1 4c 53 52				.text	3,$f1,"LSR"            ; $a4 LSR
>b6e9	03 ed 4e 4f 50				.text	3,$ed,"NOP"            ; $a5 NOP
>b6ee	03 e2 4f 52 41				.text	3,$e2,"ORA"            ; $a6 ORA
>b6f3	03 d9 50 48 41				.text	3,$d9,"PHA"            ; $a7 PHA
>b6f8	03 e8 50 48 50				.text	3,$e8,"PHP"            ; $a8 PHP
>b6fd	03 f0 50 48 58				.text	3,$f0,"PHX"            ; $a9 PHX
>b702	03 f1 50 48 59				.text	3,$f1,"PHY"            ; $aa PHY
>b707	03 dd 50 4c 41				.text	3,$dd,"PLA"            ; $ab PLA
>b70c	03 ec 50 4c 50				.text	3,$ec,"PLP"            ; $ac PLP
>b711	03 f4 50 4c 58				.text	3,$f4,"PLX"            ; $ad PLX
>b716	03 f5 50 4c 59				.text	3,$f5,"PLY"            ; $ae PLY
>b71b	03 ed 52 4f 4c				.text	3,$ed,"ROL"            ; $af ROL
>b720	03 f3 52 4f 52				.text	3,$f3,"ROR"            ; $b0 ROR
>b725	03 ef 52 54 49				.text	3,$ef,"RTI"            ; $b1 RTI
>b72a	03 f9 52 54 53				.text	3,$f9,"RTS"            ; $b2 RTS
>b72f	03 d8 53 42 43				.text	3,$d8,"SBC"            ; $b3 SBC
>b734	03 db 53 45 43				.text	3,$db,"SEC"            ; $b4 SEC
>b739	03 dc 53 45 44				.text	3,$dc,"SED"            ; $b5 SED
>b73e	03 e1 53 45 49				.text	3,$e1,"SEI"            ; $b6 SEI
>b743	03 e8 53 54 41				.text	3,$e8,"STA"            ; $b7 STA
>b748	03 f7 53 54 50				.text	3,$f7,"STP"            ; $b8 STP
>b74d	03 ff 53 54 58				.text	3,$ff,"STX"            ; $b9 STX
>b752	03 00 53 54 59				.text	3,$00,"STY"            ; $ba STY
>b757	03 01 53 54 5a				.text	3,$01,"STZ"            ; $bb STZ
>b75c	03 ed 54 41 58				.text	3,$ed,"TAX"            ; $bc TAX
>b761	03 ee 54 41 59				.text	3,$ee,"TAY"            ; $bd TAY
>b766	03 e8 54 52 42				.text	3,$e8,"TRB"            ; $be TRB
>b76b	03 e9 54 53 42				.text	3,$e9,"TSB"            ; $bf TSB
>b770	03 ff 54 53 58				.text	3,$ff,"TSX"            ; $c0 TSX
>b775	03 ed 54 58 41				.text	3,$ed,"TXA"            ; $c1 TXA
>b77a	03 ff 54 58 53				.text	3,$ff,"TXS"            ; $c2 TXS
>b77f	03 ee 54 59 41				.text	3,$ee,"TYA"            ; $c3 TYA
>b784	ff					.text	$FF
.b785					Export_TKListConvertLine:
.b785	48		pha				pha 								; save indent on the stack
.b786	9c 1d 04	stz $041d			stz 	tbOffset
.b789	9c 2d 04	stz $042d			stz 	tokenBuffer
.b78c	9c 29 04	stz $0429			stz 	currentListColour
.b78f	a9 89		lda #$89			lda 	#CLILineNumber+$80
.b791	20 0e b9	jsr $b90e			jsr 	LCLWriteColour
.b794	a0 02		ldy #$02			ldy 	#2 							; convert line number to string
.b796	b1 30		lda ($30),y			lda 	(codePtr),y
.b798	aa		tax				tax
.b799	88		dey				dey
.b79a	b1 30		lda ($30),y			lda 	(codePtr),y
.b79c	20 7f b9	jsr $b97f			jsr 	LCLWriteNumberXA
.b79f	68		pla				pla 								; adjustment to indent
.b7a0	48		pha				pha 								; save on stack
.b7a1	10 0c		bpl $b7af			bpl 	_LCNoAdjust 				; don't adjust indent if +ve, do after.
.b7a3	18		clc				clc 								; add to list indent and make 0 if goes -ve.
.b7a4	6d 26 04	adc $0426			adc 	listIndent
.b7a7	8d 26 04	sta $0426			sta 	listIndent
.b7aa	10 03		bpl $b7af			bpl 	_LCNoAdjust
.b7ac	9c 26 04	stz $0426			stz 	listIndent
.b7af					_LCNoAdjust:
.b7af	18		clc				clc		 							; work out actual indent.
.b7b0	ad 26 04	lda $0426			lda 	listIndent
.b7b3	0a		asl a				asl 	a
.b7b4	69 07		adc #$07			adc 	#7
.b7b6	85 36		sta $36				sta 	zTemp0
.b7b8					_LCPadOut:
.b7b8	a9 20		lda #$20			lda 	#' '						; pad out to 6+indent characters
.b7ba	20 17 b9	jsr $b917			jsr 	LCLWrite
.b7bd	ad 1d 04	lda $041d			lda 	tbOffset
.b7c0	c5 36		cmp $36				cmp 	zTemp0
.b7c2	d0 f4		bne $b7b8			bne 	_LCPadOut
.b7c4	a0 03		ldy #$03			ldy 	#3 							; start position.
.b7c6					_LCMainLoop:
.b7c6	a9 8a		lda #$8a			lda 	#CLIPunctuation+$80
.b7c8	20 0e b9	jsr $b90e			jsr 	LCLWriteColour
.b7cb	b1 30		lda ($30),y			lda 	(codePtr),y
.b7cd	c9 80		cmp #$80			cmp 	#KWC_EOL 					; end of line ?
.b7cf	f0 17		beq $b7e8			beq 	_LCExit
.b7d1	c9 10		cmp #$10			cmp 	#16 						; 0-5 are the double punctuations
.b7d3	90 1e		bcc $b7f3			bcc 	_LCDoubles
.b7d5	c9 20		cmp #$20			cmp 	#32 						; 16-31 are shifted punctuation from 64-91
.b7d7	90 2a		bcc $b803			bcc 	_LCShiftPunc
.b7d9	c9 40		cmp #$40			cmp 	#64 						; 32-64 are as stored, punc and digits
.b7db	90 35		bcc $b812			bcc 	_LCPunctuation
.b7dd	c9 80		cmp #$80			cmp 	#128 						; 64-127 are variable identifiers.
.b7df	90 51		bcc $b832			bcc 	_LCIdentifiers
.b7e1	c9 fe		cmp #$fe			cmp 	#254 						; 128-253 are tokenised words
.b7e3	90 73		bcc $b858			bcc 	_LCTokens
.b7e5	4c b8 b8	jmp $b8b8			jmp 	_LCData 					; 254-5 are data objects
.b7e8					_LCExit:
.b7e8	68		pla				pla 								; get old indent adjust
.b7e9	30 07		bmi $b7f2			bmi 	_LCExit2
.b7eb	18		clc				clc 								; add to indent if +ve
.b7ec	6d 26 04	adc $0426			adc 	listIndent
.b7ef	8d 26 04	sta $0426			sta 	listIndent
.b7f2					_LCExit2:
.b7f2	60		rts				rts
.b7f3					_LCDoubles:
.b7f3	48		pha				pha
.b7f4	4a		lsr a				lsr 	a 							; put bit 2 into bit 1
.b7f5	29 02		and #$02			and 	#2
.b7f7	09 3c		ora #$3c			ora 	#60 						; make < >
.b7f9	20 17 b9	jsr $b917			jsr 	LCLWrite
.b7fc	68		pla				pla 								; restore, do lower bit
.b7fd	29 03		and #$03			and 	#3
.b7ff	09 3c		ora #$3c			ora 	#60
.b801	80 0f		bra $b812			bra		_LCPunctuation 				; print, increment, loop
.b803					_LCShiftPunc:
.b803	aa		tax				tax 								; save in X
.b804	29 07		and #$07			and 	#7 							; lower 3 bits
.b806	f0 02		beq $b80a			beq 	_LCNoAdd
.b808	09 18		ora #$18			ora 	#24 						; adds $18 to it.
.b80a					_LCNoAdd:
.b80a	e0 18		cpx #$18			cpx 	#24 						; if >= 24 add $20
.b80c	90 02		bcc $b810			bcc 	_LCNoAdd2
.b80e	09 20		ora #$20			ora 	#32 						; adds $20
.b810					_LCNoAdd2:
.b810	09 40		ora #$40			ora 	#$40 						; shift into 64-127 range and fall through.
.b812					_LCPunctuation:
.b812	c9 3a		cmp #$3a			cmp 	#':' 						; check if :
.b814	d0 03		bne $b819			bne 	_LCPContinue
.b816	20 2d b9	jsr $b92d			jsr 	LCLDeleteLastSpace 			; if so delete any preceding spaces
.b819					_LCPContinue:
.b819	c9 2e		cmp #$2e			cmp 	#'.'
.b81b	f0 08		beq $b825			beq 	_LCPIsConstant
.b81d	c9 30		cmp #$30			cmp 	#'0'
.b81f	90 0b		bcc $b82c			bcc 	_LCPNotConstant
.b821	c9 3a		cmp #$3a			cmp 	#'9'+1
.b823	b0 07		bcs $b82c			bcs 	_LCPNotConstant
.b825					_LCPIsConstant:
.b825	48		pha				pha
.b826	a9 8d		lda #$8d			lda 	#CLIConstant+$80
.b828	20 0e b9	jsr $b90e			jsr 	LCLWriteColour
.b82b	68		pla				pla
.b82c					_LCPNotConstant:
.b82c	c8		iny				iny 								; consume character
.b82d	20 17 b9	jsr $b917			jsr 	LCLWrite 					; write it out.
.b830	80 94		bra $b7c6			bra 	_LCMainLoop 				; go round again.
.b832					_LCIdentifiers:
.b832	18		clc				clc 								; convert to physical address
.b833	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.b835	85 37		sta $37				sta 	zTemp0+1
.b837	c8		iny				iny
.b838	b1 30		lda ($30),y			lda 	(codePtr),y
.b83a	85 36		sta $36				sta 	zTemp0
.b83c	c8		iny				iny
.b83d	5a		phy				phy 								; save position
.b83e	a9 87		lda #$87			lda 	#CLIIdentifier+$80
.b840	20 0e b9	jsr $b90e			jsr 	LCLWriteColour
.b843	a0 07		ldy #$07			ldy 	#7 							; output the identifier at +8
.b845					_LCOutIdentifier:
.b845	c8		iny				iny
.b846	b1 36		lda ($36),y			lda 	(zTemp0),y					; bit 7 set = end.
.b848	29 7f		and #$7f			and 	#$7F
.b84a	20 69 b9	jsr $b969			jsr 	LCLLowerCase
.b84d	20 17 b9	jsr $b917			jsr 	LCLWrite
.b850	b1 36		lda ($36),y			lda 	(zTemp0),y				 	; ends when bit 7 set.
.b852	10 f1		bpl $b845			bpl 	_LCOutIdentifier
.b854	7a		ply				ply 								; restore position
.b855	4c c6 b7	jmp $b7c6			jmp 	_LCMainLoop
.b858					_LCTokens:
.b858	aa		tax				tax 								; token in X
.b859	a9 39		lda #$39			lda 	#((KeywordSet2) & $FF)
.b85b	85 36		sta $36				sta 	0+zTemp0
.b85d	a9 b6		lda #$b6			lda 	#((KeywordSet2) >> 8)
.b85f	85 37		sta $37				sta 	1+zTemp0
.b861	e0 82		cpx #$82			cpx 	#$82
.b863	f0 16		beq $b87b			beq 	_LCUseShift
.b865	a9 dc		lda #$dc			lda 	#((KeywordSet1) & $FF)
.b867	85 36		sta $36				sta 	0+zTemp0
.b869	a9 b5		lda #$b5			lda 	#((KeywordSet1) >> 8)
.b86b	85 37		sta $37				sta 	1+zTemp0
.b86d	e0 81		cpx #$81			cpx 	#$81
.b86f	f0 0a		beq $b87b			beq 	_LCUseShift
.b871	a9 df		lda #$df			lda 	#((KeywordSet0) & $FF)
.b873	85 36		sta $36				sta 	0+zTemp0
.b875	a9 b3		lda #$b3			lda 	#((KeywordSet0) >> 8)
.b877	85 37		sta $37				sta 	1+zTemp0
.b879	80 01		bra $b87c			bra 	_LCNoShift
.b87b					_LCUseShift:
.b87b	c8		iny				iny
.b87c					_LCNoShift:
.b87c	20 41 b9	jsr $b941			jsr 	LCLCheckSpaceRequired 		; do we need a space ?
.b87f	b1 30		lda ($30),y			lda 	(codePtr),y
.b881	aa		tax				tax 								; into X
.b882					_LCFindText:
.b882	ca		dex				dex
.b883	10 0e		bpl $b893			bpl 	_LCFoundText 				; found text.
.b885	b2 36		lda ($36)			lda 	(zTemp0) 					; length of text
.b887	1a		inc a				inc 	a 							; one extra for size
.b888	38		sec				sec 								; one extra for checksum
.b889	65 36		adc $36				adc 	zTemp0 						; go to next token
.b88b	85 36		sta $36				sta 	zTemp0
.b88d	90 f3		bcc $b882			bcc 	_LCFindText
.b88f	e6 37		inc $37				inc 	zTemp0+1
.b891	80 ef		bra $b882			bra 	_LCFindText
.b893					_LCFoundText:
.b893	5a		phy				phy 								; save List position
.b894	b2 36		lda ($36)			lda 	(zTemp0)					; count to print
.b896	aa		tax				tax
.b897	a9 83		lda #$83			lda 	#CLIToken+$80
.b899	20 0e b9	jsr $b90e			jsr 	LCLWriteColour
.b89c	a0 02		ldy #$02			ldy 	#2
.b89e					_LCCopyToken:
.b89e	b1 36		lda ($36),y			lda 	(zTemp0),y
.b8a0	20 69 b9	jsr $b969			jsr 	LCLLowerCase
.b8a3	20 17 b9	jsr $b917			jsr 	LCLWrite
.b8a6	c8		iny				iny
.b8a7	ca		dex				dex
.b8a8	d0 f4		bne $b89e			bne 	_LCCopyToken
.b8aa	c9 28		cmp #$28			cmp 	#"(" 						; if last char not ( print a space
.b8ac	f0 05		beq $b8b3			beq 	_LCNoSpace
.b8ae	a9 20		lda #$20			lda 	#' '
.b8b0	20 17 b9	jsr $b917			jsr 	LCLWrite
.b8b3					_LCNoSpace:
.b8b3	7a		ply				ply 								; restore position.
.b8b4	c8		iny				iny 								; consume token
.b8b5	4c c6 b7	jmp $b7c6			jmp 	_LCMainLoop 				; and go around again.
.b8b8					_LCData:
.b8b8	48		pha				pha 								; save type $FE/$FF
.b8b9	a2 24		ldx #$24			ldx 	#'$' 						; figure out $ or "
.b8bb	c9 fe		cmp #$fe			cmp 	#$FE
.b8bd	f0 22		beq $b8e1			beq 	_LCHaveOpener
.b8bf	a2 22		ldx #$22			ldx 	#'"'
.b8c1	a9 81		lda #$81			lda 	#CLIData+$80
.b8c3	20 0e b9	jsr $b90e			jsr 	LCLWriteColour
.b8c6	c0 04		cpy #$04			cpy 	#4 							; must be 2nd thing on line
.b8c8	d0 17		bne $b8e1			bne 	_LCHaveOpener
.b8ca	88		dey				dey 								; what precedes it ?
.b8cb	b1 30		lda ($30),y			lda 	(codePtr),y
.b8cd	c8		iny				iny
.b8ce	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; if quote
.b8d0	d0 0f		bne $b8e1			bne 	_LCHaveOpener
.b8d2	a9 09		lda #$09			lda 	#9 							; tab
.b8d4	20 17 b9	jsr $b917			jsr 	LCLWrite
.b8d7	a9 97		lda #$97			lda 	#$90+CLIBComment
.b8d9	20 17 b9	jsr $b917			jsr 	LCLWrite
.b8dc	a9 80		lda #$80			lda 	#CLIFComment+$80
.b8de	20 0e b9	jsr $b90e			jsr 	LCLWriteColour
.b8e1					_LCHaveOpener:
.b8e1	8a		txa				txa 								; output prefix (# or ")
.b8e2	20 17 b9	jsr $b917			jsr 	LCLWrite
.b8e5	c8		iny				iny 								; get count
.b8e6	b1 30		lda ($30),y			lda 	(codePtr),y
.b8e8	aa		tax				tax
.b8e9	c8		iny				iny 								; point at first character
.b8ea					_LCOutData:
.b8ea	b1 30		lda ($30),y			lda 	(codePtr),y
.b8ec	c9 00		cmp #$00			cmp 	#0
.b8ee	f0 03		beq $b8f3			beq 	_LCNoPrint
.b8f0	20 17 b9	jsr $b917			jsr 	LCLWrite
.b8f3					_LCNoPrint:
.b8f3	c8		iny				iny
.b8f4	ca		dex				dex
.b8f5	d0 f3		bne $b8ea			bne 	_LCOutData
.b8f7	68		pla				pla 								; closing " required ?
.b8f8	c9 ff		cmp #$ff			cmp 	#$FF 						; not required for hex constant.
.b8fa	d0 0f		bne $b90b			bne 	_LCNoQuote
.b8fc	a9 22		lda #$22			lda 	#'"'
.b8fe	20 17 b9	jsr $b917			jsr 	LCLWrite
.b901	ad c2 05	lda $05c2			lda 	EXTTextColour
.b904	29 0f		and #$0f			and 	#$0F
.b906	09 90		ora #$90			ora 	#$90
.b908	20 17 b9	jsr $b917			jsr 	LCLWrite
.b90b					_LCNoQuote:
.b90b	4c c6 b7	jmp $b7c6			jmp 	_LCMainLoop
.b90e					LCLWriteColour:
.b90e	cd 29 04	cmp $0429			cmp 	currentListColour 			; has the colour changed
.b911	8d 29 04	sta $0429			sta 	currentListColour 			; (update it anyway)
.b914	d0 01		bne $b917			bne 	LCLWrite 					; if different, output it
.b916	60		rts				rts
.b917					LCLWrite:
.b917	da		phx				phx
.b918	ae 1d 04	ldx $041d			ldx 	tbOffset 					; write out make ASCIIZ
.b91b	9d 2d 04	sta $042d,x			sta 	tokenBuffer,x
.b91e	9e 2e 04	stz $042e,x			stz 	tokenBuffer+1,x
.b921	ee 1d 04	inc $041d			inc 	tbOffset 					; bump the position
.b924	09 00		ora #$00			ora 	#0 							; don't update last character if colour data
.b926	30 03		bmi $b92b			bmi 	_LCLNoColour
.b928	8d 27 04	sta $0427			sta 	LCLastCharacter
.b92b					_LCLNoColour:
.b92b	fa		plx				plx
.b92c	60		rts				rts
.b92d					LCLDeleteLastSpace:
.b92d	48		pha				pha
.b92e	da		phx				phx
.b92f	ae 1d 04	ldx $041d			ldx 	tbOffset
.b932	f0 0a		beq $b93e			beq 	_LCDLSExit
.b934	bd 2c 04	lda $042c,x			lda 	tokenBuffer-1,x
.b937	c9 20		cmp #$20			cmp 	#' '
.b939	d0 03		bne $b93e			bne 	_LCDLSExit
.b93b	ce 1d 04	dec $041d			dec 	tbOffset
.b93e					_LCDLSExit:
.b93e	fa		plx				plx
.b93f	68		pla				pla
.b940	60		rts				rts
.b941					LCLCheckSpaceRequired:
.b941	ad 27 04	lda $0427			lda 	LCLastCharacter 			; check last character
.b944	c9 24		cmp #$24			cmp 	#'$' 						; $ # and ) require that token space.
.b946	f0 1b		beq $b963			beq 	_LCCSRSpace
.b948	c9 29		cmp #$29			cmp 	#')'
.b94a	f0 17		beq $b963			beq 	_LCCSRSpace
.b94c	c9 23		cmp #$23			cmp 	#'#'
.b94e	f0 13		beq $b963			beq 	_LCCSRSpace
.b950	20 69 b9	jsr $b969			jsr 	LCLLowerCase 				; saves a little effort
.b953	c9 30		cmp #$30			cmp 	#"0" 						; check if it was 0-9 A-Z a-z if so need space.
.b955	90 11		bcc $b968			bcc 	_LCCSRExit
.b957	c9 3a		cmp #$3a			cmp 	#"9"+1
.b959	90 08		bcc $b963			bcc 	_LCCSRSpace
.b95b	c9 61		cmp #$61			cmp 	#"a"
.b95d	90 09		bcc $b968			bcc 	_LCCSRExit
.b95f	c9 7b		cmp #$7b			cmp 	#"z"+1
.b961	b0 05		bcs $b968			bcs 	_LCCSRExit
.b963					_LCCSRSpace:
.b963	a9 20		lda #$20			lda 	#' '
.b965	20 17 b9	jsr $b917			jsr 	LCLWrite
.b968					_LCCSRExit:
.b968	60		rts				rts
.b969					LCLLowerCase:
.b969	c9 41		cmp #$41			cmp 	#"A"
.b96b	90 06		bcc $b973			bcc 	_LCLLCOut
.b96d	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b96f	b0 02		bcs $b973			bcs 	_LCLLCOut
.b971	69 20		adc #$20			adc 	#$20
.b973					_LCLLCOut:
.b973	60		rts				rts
.b974					LCLUpperCase:
.b974	c9 61		cmp #$61			cmp 	#"a"
.b976	90 06		bcc $b97e			bcc 	_LCLUCOut
.b978	c9 7b		cmp #$7b			cmp 	#"z"+1
.b97a	b0 02		bcs $b97e			bcs 	_LCLUCOut
.b97c	e9 1f		sbc #$1f			sbc 	#$1F
.b97e					_LCLUCOut:
.b97e	60		rts				rts
.b97f					LCLWriteNumberXA:
.b97f	64 37		stz $37				stz 	zTemp0+1 					; index into digit table.
.b981					_LCLWNLoop1:
.b981	64 36		stz $36				stz 	zTemp0 						; subtraction count.
.b983					_LCLWNLoop2:
.b983	48		pha				pha 								; save initial LSB
.b984	38		sec				sec
.b985	a4 37		ldy $37				ldy 	zTemp0+1 					; position in table.
.b987	f9 b8 b9	sbc $b9b8,y			sbc 	_LCLWNTable,y
.b98a	48		pha				pha
.b98b	8a		txa				txa
.b98c	f9 b9 b9	sbc $b9b9,y			sbc 	_LCLWNTable+1,y
.b98f	90 07		bcc $b998			bcc 	_LCLWNUnderflow
.b991	e6 36		inc $36				inc 	zTemp0  					; subtracted one without borrow.
.b993	aa		tax				tax 								; update X
.b994	68		pla				pla 								; restore A
.b995	7a		ply				ply 								; throw original
.b996	80 eb		bra $b983			bra 	_LCLWNLoop2 				; try again.
.b998					_LCLWNUnderflow:
.b998	a4 36		ldy $36				ldy 	zTemp0 						; count of subtractions.
.b99a	d0 06		bne $b9a2			bne 	_LCLWNOut
.b99c	ad 1d 04	lda $041d			lda 	tbOffset 					; suppress leading zeroes
.b99f	3a		dec a				dec 	a
.b9a0	f0 04		beq $b9a6			beq 	_LCLWNNext
.b9a2					_LCLWNOut:
.b9a2	98		tya				tya
.b9a3	20 b2 b9	jsr $b9b2			jsr 	_LCLWNOutDigit
.b9a6					_LCLWNNext:
.b9a6	7a		ply				ply 							 	; restore original value.
.b9a7	68		pla				pla
.b9a8	a4 37		ldy $37				ldy 	zTemp0+1  					; bump the index
.b9aa	c8		iny				iny
.b9ab	c8		iny				iny
.b9ac	84 37		sty $37				sty 	zTemp0+1
.b9ae	c0 08		cpy #$08			cpy 	#8 							; done all 4
.b9b0	d0 cf		bne $b981			bne 	_LCLWNLoop1
.b9b2					_LCLWNOutDigit:
.b9b2	09 30		ora #$30			ora 	#'0'
.b9b4	20 17 b9	jsr $b917			jsr 	LCLWrite
.b9b7	60		rts				rts
.b9b8					_LCLWNTable:
>b9b8	10 27						.word 	10000
>b9ba	e8 03						.word 	1000
>b9bc	64 00						.word 	100
>b9be	0a 00						.word 	10
.b9c0					TOKSearchTable:
.b9c0	84 37		sty $37				sty 	zTemp0+1 					; (zTemp0),y points to current token being tested.
.b9c2	85 36		sta $36				sta 	zTemp0
.b9c4	a0 00		ldy #$00			ldy 	#0
.b9c6	a9 80		lda #$80			lda 	#$80 						; token # so we know which one we are looking at
.b9c8	85 38		sta $38				sta 	zTemp1
.b9ca					_TSTLoop:
.b9ca	b1 36		lda ($36),y			lda 	(zTemp0),y 					; length, 0 (skip) -ve (end)
.b9cc	30 49		bmi $ba17			bmi 	_TSTFail 					; -ve = end of table, so fail.
.b9ce	f0 2e		beq $b9fe			beq 	_TSTNext 					; zero, check next as it's a dummy (e.g. EOL, SHIFT)
.b9d0	c8		iny				iny 								; get the hash
.b9d1	b1 36		lda ($36),y			lda 	(zTemp0),y
.b9d3	88		dey				dey
.b9d4	cd 03 04	cmp $0403			cmp 	identHash 					; check they match with the identifier hash, if not go to next
.b9d7	d0 25		bne $b9fe			bne 	_TSTNext
.b9d9	ad 02 04	lda $0402			lda 	identTypeEnd 				; get length of identifier from end-start
.b9dc	38		sec				sec
.b9dd	ed 00 04	sbc $0400			sbc 	identStart
.b9e0	d1 36		cmp ($36),y			cmp 	(zTemp0),y 					; compare against the length in the table, no match, then return.
.b9e2	d0 1a		bne $b9fe			bne 	_TSTNext
.b9e4	5a		phy				phy 								; save Y , we might fail to match.
.b9e5	c8		iny				iny 								; point to text
.b9e6	c8		iny				iny
.b9e7	ae 00 04	ldx $0400			ldx 	identStart 					; offset in line buffer in X
.b9ea					_TSTCompareName:
.b9ea	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; compare text.
.b9ed	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.b9ef	d0 0c		bne $b9fd			bne 	_TSTNextPullY 				; fail, pullY and do next
.b9f1	e8		inx				inx
.b9f2	c8		iny				iny
.b9f3	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; complete match.
.b9f6	d0 f2		bne $b9ea			bne 	_TSTCompareName
.b9f8	7a		ply				ply 								; throw Y
.b9f9	a5 38		lda $38				lda 	zTemp1 						; get token #
.b9fb	38		sec				sec 								; return with CS = passed.
.b9fc	60		rts				rts
.b9fd					_TSTNextPullY:
.b9fd	7a		ply				ply 								; restore current, fall through.
.b9fe					_TSTNext:
.b9fe	e6 38		inc $38				inc 	zTemp1 						; token counter
.ba00	98		tya				tya
.ba01	18		clc				clc
.ba02	71 36		adc ($36),y			adc 	(zTemp0),y 					; add [Length] + 2 to Y
.ba04	1a		inc a				inc 	a 							; +1
.ba05	1a		inc a				inc 	a 							; +2
.ba06	a8		tay				tay
.ba07	10 c1		bpl $b9ca			bpl 	_TSTLoop 					; if Y < $80 loop back
.ba09	98		tya				tya 								; add Y to zTemp0 and reset Y
.ba0a	a0 00		ldy #$00			ldy 	#0   						; so we can use Y to search fast
.ba0c	18		clc				clc  								; but have tables > 255 bytes
.ba0d	65 36		adc $36				adc 	zTemp0 						; when Y gets >= 128 we reset Y
.ba0f	85 36		sta $36				sta 	zTemp0 						; and adjust the table pointer/
.ba11	90 b7		bcc $b9ca			bcc 	_TSTLoop
.ba13	e6 37		inc $37				inc 	zTemp0+1
.ba15	80 b3		bra $b9ca			bra 	_TSTLoop
.ba17					_TSTFail:
.ba17	18		clc				clc
.ba18	60		rts				rts
.ba19					Export_TKTokeniseLine:
.ba19	20 a1 bb	jsr $bba1			jsr 	LCLFixLineBufferCase 		; fix line case
.ba1c	a9 03		lda #$03			lda 	#3 							; reset the token buffer to empty
.ba1e	8d 2a 04	sta $042a			sta 	tokenOffset 				; (3 bytes for line number & offset)
.ba21	9c 2b 04	stz $042b			stz 	tokenLineNumber
.ba24	9c 2c 04	stz $042c			stz 	tokenLineNumber+1
.ba27	a2 ff		ldx #$ff			ldx 	#$FF
.ba29					_TKFindFirst:
.ba29	e8		inx				inx
.ba2a	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.ba2d	f0 79		beq $baa8			beq 	_TKExit
.ba2f	c9 20		cmp #$20			cmp 	#' '
.ba31	90 f6		bcc $ba29			bcc 	_TKFindFirst
.ba33	c9 30		cmp #$30			cmp 	#'0'
.ba35	90 07		bcc $ba3e			bcc 	_TKNoLineNumber
.ba37	c9 3a		cmp #$3a			cmp 	#'9'+1
.ba39	b0 03		bcs $ba3e			bcs 	_TKNoLineNumber
.ba3b	20 cb bb	jsr $bbcb			jsr 	TOKExtractLineNumber
.ba3e					_TKNoLineNumber:
.ba3e					_TKTokeniseLoop:
.ba3e	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; next character, exit if zero EOL.
.ba41	f0 65		beq $baa8			beq 	_TKExit
.ba43	e8		inx				inx
.ba44	c9 20		cmp #$20			cmp 	#' '
.ba46	f0 f6		beq $ba3e			beq 	_TKTokeniseLoop 			; keep looping if space found.
.ba48	ca		dex				dex 								; undo last get, A contains character, X is position.
.ba49	c9 5f		cmp #$5f			cmp 	#'_'						; _ A-Z is identifier *or* token
.ba4b	f0 61		beq $baae			beq 	_TKTokeniseIdentifier 		; (already case converted outside string constants)
.ba4d	c9 41		cmp #$41			cmp 	#'A'
.ba4f	90 04		bcc $ba55			bcc 	_TKTokenisePunctuation
.ba51	c9 5b		cmp #$5b			cmp 	#'Z'+1
.ba53	90 59		bcc $baae			bcc 	_TKTokeniseIdentifier
.ba55					_TKTokenisePunctuation:
.ba55	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.ba57	f0 27		beq $ba80			beq 	_TKString
.ba59	c9 24		cmp #$24			cmp 	#'$'						; hexadecimal constant ($ only appears at end of identifiers)
.ba5b	f0 28		beq $ba85			beq 	_TKHexConstant
.ba5d	c9 3c		cmp #$3c			cmp 	#'<' 						; check for < > handlers - these are for <> <= >= >> <<
.ba5f	f0 29		beq $ba8a			beq 	_TKCheckDouble
.ba61	c9 3e		cmp #$3e			cmp 	#'>'
.ba63	f0 25		beq $ba8a			beq 	_TKCheckDouble
.ba65					_TKStandardPunctuation:
.ba65	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get the punctuation token back.
.ba68	c9 40		cmp #$40			cmp 	#64 						; are we >= 64
.ba6a	90 0e		bcc $ba7a			bcc 	_TKNoShift
.ba6c	48		pha				pha 								; save. we are about to convert this punctuation token from
.ba6d	29 07		and #$07			and 	#7 							; lower 3 bits in zTemp0
.ba6f	85 36		sta $36				sta 	zTemp0
.ba71	68		pla				pla
.ba72	29 20		and #$20			and 	#32 						; bit 5
.ba74	4a		lsr a				lsr 	a 							; shift into bit 3
.ba75	4a		lsr a				lsr 	a
.ba76	05 36		ora $36				ora 	zTemp0
.ba78	09 10		ora #$10			ora 	#$10						; now in the range 16-31
.ba7a					_TKNoShift:
.ba7a	20 10 bc	jsr $bc10			jsr 	TOKWriteByte 				; write the punctuation character
.ba7d	e8		inx				inx 								; consume the character
.ba7e	80 be		bra $ba3e			bra 	_TKTokeniseLoop 			; and loop round again.
.ba80					_TKString:
.ba80	20 30 bb	jsr $bb30			jsr 	TOKTokenString
.ba83	80 b9		bra $ba3e			bra 	_TKTokeniseLoop
.ba85					_TKHexConstant:
.ba85	20 6b bb	jsr $bb6b			jsr 	TOKHexConstant
.ba88	80 b4		bra $ba3e			bra 	_TKTokeniseLoop
.ba8a					_TKCheckDouble:
.ba8a	bd 2b 05	lda $052b,x			lda 	lineBuffer+1,x 				; get next character
.ba8d	c9 3c		cmp #$3c			cmp 	#'<'						; if not < = > which are ASCII consecutive go back
.ba8f	90 d4		bcc $ba65			bcc 	_TKStandardPunctuation 		; and do the normal punctuation handler.
.ba91	c9 3f		cmp #$3f			cmp 	#'>'+1
.ba93	b0 d0		bcs $ba65			bcs 	_TKStandardPunctuation
.ba95	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; this is < (60) or > (62)
.ba98	29 02		and #$02			and 	#2 							; now < (0) or > (2)
.ba9a	0a		asl a				asl 	a 							; now < (0) or > (4), CC also
.ba9b	7d 2b 05	adc $052b,x			adc 	lineBuffer+1,x 				; add < = > codes - < code
.ba9e	38		sec				sec
.ba9f	e9 3c		sbc #$3c			sbc 	#'<'
.baa1	20 10 bc	jsr $bc10			jsr 	TOKWriteByte 				; this is in the range 0-7
.baa4	e8		inx				inx 								; consume both
.baa5	e8		inx				inx
.baa6	80 96		bra $ba3e			bra 	_TKTokeniseLoop
.baa8	a9 80		lda #$80	_TKExit:lda 	#KWC_EOL 					; write end of line byte
.baaa	20 10 bc	jsr $bc10			jsr 	TOKWriteByte
.baad	60		rts				rts
.baae					_TKTokeniseIdentifier:
.baae	8e 00 04	stx $0400			stx 	identStart 					; save start
.bab1	9c 04 04	stz $0404			stz 	identTypeByte 				; zero the type byte
.bab4					_TKCheckLoop:
.bab4	e8		inx				inx 								; look at next, we know first is identifier already.
.bab5	bd 2a 05	lda $052a,x			lda  	lineBuffer,x
.bab8	c9 5f		cmp #$5f			cmp 	#"_" 						; legal char _ 0-9 A-Z
.baba	f0 f8		beq $bab4			beq 	_TKCheckLoop
.babc	c9 30		cmp #$30			cmp	 	#"0"
.babe	90 0c		bcc $bacc			bcc 	_TKEndIdentifier
.bac0	c9 3a		cmp #$3a			cmp 	#"9"+1
.bac2	90 f0		bcc $bab4			bcc 	_TKCheckLoop
.bac4	c9 41		cmp #$41			cmp	 	#"A"
.bac6	90 04		bcc $bacc			bcc 	_TKEndIdentifier
.bac8	c9 5b		cmp #$5b			cmp 	#"Z"+1
.baca	90 e8		bcc $bab4			bcc 	_TKCheckLoop
.bacc					_TKEndIdentifier:
.bacc	8e 01 04	stx $0401			stx 	identTypeStart 				; save start of type text (if any !)
.bacf	a0 08		ldy #$08			ldy 	#$08 						; this is the identifier type byte for #
.bad1	c9 23		cmp #$23			cmp 	#"#"						; followed by #
.bad3	f0 06		beq $badb			beq 	_TKHasTypeCharacter
.bad5	a0 10		ldy #$10			ldy 	#$10 						; this is the identifier type byte for $
.bad7	c9 24		cmp #$24			cmp 	#"$"						; followed by $ or #
.bad9	d0 07		bne $bae2			bne 	_TKNoTypeCharacter
.badb					_TKHasTypeCharacter:
.badb	8c 04 04	sty $0404			sty 	identTypeByte 				; has # or $, save the type
.bade	e8		inx				inx 								; consume the type character
.badf	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.bae2					_TKNoTypeCharacter:
.bae2	c9 28		cmp #$28			cmp 	#"("						; is it open parenthesis (e.g. array)
.bae4	d0 09		bne $baef			bne 	_TKNoArray
.bae6	e8		inx				inx 								; skip the (
.bae7	ad 04 04	lda $0404			lda 	identTypeByte 				; set bit 2 (e.g. array) in type byte
.baea	09 04		ora #$04			ora 	#$04
.baec	8d 04 04	sta $0404			sta 	identTypeByte
.baef					_TKNoArray:
.baef	8e 02 04	stx $0402			stx 	identTypeEnd 				; save end marker, e.g. continue from here.
.baf2	20 8c bb	jsr $bb8c			jsr 	TOKCalculateHash 			; calculate the has for those tokens
.baf5	a0 b3		ldy #$b3			ldy 	#(KeywordSet0) >> 8
.baf7	a9 df		lda #$df			lda 	#(KeywordSet0) & $FF
.baf9	20 c0 b9	jsr $b9c0			jsr 	TOKSearchTable
.bafc	a2 00		ldx #$00			ldx 	#0
.bafe	b0 1f		bcs $bb1f			bcs 	_TKFoundToken
.bb00	a0 b5		ldy #$b5			ldy 	#(KeywordSet1) >> 8
.bb02	a9 dc		lda #$dc			lda 	#(KeywordSet1) & $FF
.bb04	20 c0 b9	jsr $b9c0			jsr 	TOKSearchTable
.bb07	a2 81		ldx #$81			ldx 	#$81
.bb09	b0 14		bcs $bb1f			bcs 	_TKFoundToken
.bb0b	a0 b6		ldy #$b6			ldy 	#(KeywordSet2) >> 8
.bb0d	a9 39		lda #$39			lda 	#(KeywordSet2) & $FF
.bb0f	20 c0 b9	jsr $b9c0			jsr 	TOKSearchTable
.bb12	a2 82		ldx #$82			ldx 	#$82
.bb14	b0 09		bcs $bb1f			bcs 	_TKFoundToken
.bb16	20 1c bc	jsr $bc1c			jsr 	TOKCheckCreateVariableRecord ; failed all, it's a variable, create record if does not exist.
.bb19	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.bb1c	4c 3e ba	jmp $ba3e			jmp 	_TKTokeniseLoop 			; and go round again.
.bb1f					_TKFoundToken:
.bb1f	48		pha				pha 								; save token
.bb20	8a		txa				txa 								; shift in X, is there one ?
.bb21	f0 03		beq $bb26			beq 	_TKNoTShift
.bb23	20 10 bc	jsr $bc10			jsr 	TOKWriteByte 				; if so, write it out
.bb26					_TKNoTShift:
.bb26	68		pla				pla 								; restore and write token
.bb27	20 10 bc	jsr $bc10			jsr 	TOKWriteByte
.bb2a	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.bb2d	4c 3e ba	jmp $ba3e			jmp 	_TKTokeniseLoop 			; and go round again.
.bb30					TOKTokenString:
.bb30	a9 ff		lda #$ff			lda 	#KWC_STRING 				; string token.
.bb32	20 10 bc	jsr $bc10			jsr 	TOKWriteByte
.bb35	e8		inx				inx									; start of quoted string.
.bb36	da		phx				phx 								; push start of string on top
.bb37	ca		dex				dex 								; because we pre-increment
.bb38					_TSFindEnd:
.bb38	e8		inx				inx
.bb39	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; next character
.bb3c	f0 04		beq $bb42			beq 	_TSEndOfString 				; no matching quote, we don't mind.
.bb3e	c9 22		cmp #$22			cmp 	#'"' 						; go back if quote not found
.bb40	d0 f6		bne $bb38			bne 	_TSFindEnd
.bb42					_TSEndOfString:
.bb42	7a		ply				ply  								; so now Y is first character, X is character after end.
.bb43	48		pha				pha 								; save terminating character
.bb44	20 4c bb	jsr $bb4c			jsr 	TOKWriteBlockXY 			; write X to Y as a data block
.bb47	68		pla				pla 								; terminating character
.bb48	f0 01		beq $bb4b			beq 	_TSNotQuote					; if it wasn't EOS skip it
.bb4a	e8		inx				inx
.bb4b					_TSNotQuote:
.bb4b	60		rts				rts
.bb4c					TOKWriteBlockXY:
.bb4c	86 36		stx $36				stx 	zTemp0 						; save end character
.bb4e	98		tya				tya 								; use 2's complement to work out the byte size
.bb4f	49 ff		eor #$ff			eor 	#$FF
.bb51	38		sec				sec
.bb52	65 36		adc $36				adc 	zTemp0
.bb54	1a		inc a				inc 	a 							; one extra for NULL
.bb55	20 10 bc	jsr $bc10			jsr 	TOKWriteByte
.bb58					_TOBlockLoop:
.bb58	c4 36		cpy $36				cpy 	zTemp0 						; exit if reached the end
.bb5a	f0 09		beq $bb65			beq 	_TOBlockExit
.bb5c	b9 2a 05	lda $052a,y			lda 	lineBuffer,y 				; write byte out.
.bb5f	20 10 bc	jsr $bc10			jsr 	TOKWriteByte
.bb62	c8		iny				iny
.bb63	80 f3		bra $bb58			bra 	_TOBlockLoop
.bb65					_TOBlockExit:
.bb65	a9 00		lda #$00			lda 	#0 							; add NULL.
.bb67	20 10 bc	jsr $bc10			jsr 	TOKWriteByte
.bb6a	60		rts				rts
.bb6b					TOKHexConstant:
.bb6b	a9 fe		lda #$fe			lda 	#KWC_HEXCONST 				; hex constant token.
.bb6d	20 10 bc	jsr $bc10			jsr 	TOKWriteByte
.bb70	e8		inx				inx									; start of quoted string.
.bb71	da		phx				phx 								; push start of constant on top
.bb72	ca		dex				dex
.bb73					_THFindLoop:
.bb73	e8		inx				inx 	 							; this is stored in a block, so find out how long
.bb74	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; the hex constant is.
.bb77	c9 30		cmp #$30			cmp 	#"0"
.bb79	90 0c		bcc $bb87			bcc 	_THFoundEnd
.bb7b	c9 3a		cmp #$3a			cmp 	#"9"+1
.bb7d	90 f4		bcc $bb73			bcc 	_THFindLoop
.bb7f	c9 41		cmp #$41			cmp 	#"A"
.bb81	90 04		bcc $bb87			bcc 	_THFoundEnd
.bb83	c9 47		cmp #$47			cmp 	#"F"+1
.bb85	90 ec		bcc $bb73			bcc 	_THFindLoop
.bb87					_THFoundEnd:
.bb87	7a		ply				ply 								; restore start
.bb88	20 4c bb	jsr $bb4c			jsr 	TOKWriteBlockXY 			; output the block
.bb8b	60		rts				rts
.bb8c					TOKCalculateHash:
.bb8c	da		phx				phx
.bb8d	ae 00 04	ldx $0400			ldx 	identStart 					; needs to be same as in tokens.py - simple sum at present.
.bb90	a9 00		lda #$00			lda 	#0
.bb92					_TCHLoop:
.bb92	18		clc				clc
.bb93	7d 2a 05	adc $052a,x			adc 	lineBuffer,x
.bb96	e8		inx				inx
.bb97	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; do the whole thing including type and array markers.
.bb9a	d0 f6		bne $bb92			bne 	_TCHLoop
.bb9c	8d 03 04	sta $0403			sta 	identHash 					; save the hash
.bb9f	fa		plx				plx
.bba0	60		rts				rts
.bba1					LCLFixLineBufferCase:
.bba1	a2 00		ldx #$00			ldx 	#0
.bba3					_FLBCLoop:
.bba3	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get next character
.bba6	f0 22		beq $bbca			beq 	_FLBCExit 					; end of string.
.bba8	c9 22		cmp #$22			cmp 	#'"'						; quote, go to in quotes
.bbaa	f0 11		beq $bbbd			beq 	_FLBCInQuotes
.bbac	e8		inx				inx
.bbad	c9 61		cmp #$61			cmp 	#'a'						; needs capitalising ?
.bbaf	90 f2		bcc $bba3			bcc 	_FLBCLoop
.bbb1	c9 7b		cmp #$7b			cmp 	#'z'+1
.bbb3	b0 ee		bcs $bba3			bcs 	_FLBCLoop
.bbb5	38		sec				sec 								; make U/C
.bbb6	e9 20		sbc #$20			sbc 	#32
.bbb8	9d 29 05	sta $0529,x			sta	 	lineBuffer-1,x 				; write back
.bbbb	80 e6		bra $bba3			bra 	_FLBCLoop
.bbbd					_FLBCInQuotes:
.bbbd	e8		inx				inx 								; advance
.bbbe	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get next
.bbc1	f0 07		beq $bbca			beq 	_FLBCExit 					; exit on EOS
.bbc3	c9 22		cmp #$22			cmp 	#'"' 				 		; until " found
.bbc5	d0 f6		bne $bbbd			bne 	_FLBCInQuotes
.bbc7	e8		inx				inx 								; skip over it
.bbc8	80 d9		bra $bba3			bra 	_FLBCLoop
.bbca					_FLBCExit:
.bbca	60		rts				rts
.bbcb					TOKExtractLineNumber:
.bbcb	ad 2c 04	lda $042c			lda 	tokenLineNumber+1 			; push current value on stack
.bbce	48		pha				pha
.bbcf	ad 2b 04	lda $042b			lda 	tokenLineNumber
.bbd2	48		pha				pha
.bbd3	20 09 bc	jsr $bc09			jsr 	_LCLNTimes2 				; line # x 2
.bbd6	20 09 bc	jsr $bc09			jsr 	_LCLNTimes2 				; line # x 4
.bbd9	18		clc				clc 								; add stacked value
.bbda	68		pla				pla
.bbdb	6d 2b 04	adc $042b			adc 	tokenLineNumber
.bbde	8d 2b 04	sta $042b			sta 	tokenLineNumber
.bbe1	68		pla				pla
.bbe2	6d 2c 04	adc $042c			adc 	tokenLineNumber+1
.bbe5	8d 2c 04	sta $042c			sta 	tokenLineNumber+1 			; line # x 5
.bbe8	20 09 bc	jsr $bc09			jsr 	_LCLNTimes2 				; line # x 10
.bbeb	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get and consume character
.bbee	e8		inx				inx
.bbef	29 0f		and #$0f			and 	#15 						; add to line #
.bbf1	18		clc				clc
.bbf2	6d 2b 04	adc $042b			adc 	tokenLineNumber
.bbf5	8d 2b 04	sta $042b			sta 	tokenLineNumber
.bbf8	90 03		bcc $bbfd			bcc 	_TLENNoCarry
.bbfa	ee 2c 04	inc $042c			inc 	tokenLineNumber+1
.bbfd					_TLENNoCarry:
.bbfd	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; more digits ?
.bc00	c9 30		cmp #$30			cmp 	#'0'
.bc02	90 04		bcc $bc08			bcc 	_TLENExit
.bc04	c9 3a		cmp #$3a			cmp 	#'9'+1
.bc06	90 c3		bcc $bbcb			bcc 	TOKExtractLineNumber
.bc08					_TLENExit:
.bc08	60		rts				rts
.bc09					_LCLNTimes2:
.bc09	0e 2b 04	asl $042b			asl 	tokenLineNumber 			; doubles tokenLineNumber.
.bc0c	2e 2c 04	rol $042c			rol 	tokenLineNumber+1
.bc0f	60		rts				rts
.bc10					TOKWriteByte:
.bc10	da		phx				phx
.bc11	ae 2a 04	ldx $042a			ldx 	tokenOffset 				; next slot to write to
.bc14	9d 2a 04	sta $042a,x			sta 	tokenOffset,x 				; write byte out
.bc17	ee 2a 04	inc $042a			inc 	tokenOffset 				; advance slot.
.bc1a	fa		plx				plx
.bc1b	60		rts				rts
.bc1c					TOKCheckCreateVariableRecord:
.bc1c	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.bc1e	85 36		sta $36				sta 	0+zTemp0
.bc20	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.bc22	85 37		sta $37				sta 	1+zTemp0
.bc24					_CCVSearch:
.bc24	b2 36		lda ($36)			lda 	(zTemp0) 					; end of list
.bc26	f0 2c		beq $bc54			beq 	_CCVFail
.bc28	a0 01		ldy #$01			ldy 	#1 							; read the hash
.bc2a	b1 36		lda ($36),y			lda 	(zTemp0),y 					; does it match ?
.bc2c	cd 03 04	cmp $0403			cmp 	identHash 	  				; if not, try the next.
.bc2f	d0 16		bne $bc47			bne 	_CCVNext
.bc31	a0 08		ldy #$08			ldy 	#8 							; name in variable record
.bc33	ae 00 04	ldx $0400			ldx 	identStart
.bc36					_CCVCompare:
.bc36	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; xor them. zero if the same, except
.bc39	51 36		eor ($36),y			eor 	(zTemp0),y 					; bit 7 is used for EOS.
.bc3b	e8		inx				inx 								; advance pointers
.bc3c	c8		iny				iny
.bc3d	0a		asl a				asl 	a 							; A = 0 if they match, CS if end.
.bc3e	d0 07		bne $bc47			bne 	_CCVNext  					; didn't match go to next.
.bc40	90 f4		bcc $bc36			bcc 	_CCVCompare 				; not finished yet.
.bc42	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; matched whole thing ?
.bc45	f0 41		beq $bc88			beq 	_CCVFound 					; yes, we were successful
.bc47					_CCVNext:
.bc47	18		clc				clc 								; go to next record.
.bc48	b2 36		lda ($36)			lda 	(zTemp0) 					; add offset to pointer
.bc4a	65 36		adc $36				adc 	zTemp0
.bc4c	85 36		sta $36				sta 	zTemp0
.bc4e	90 d4		bcc $bc24			bcc 	_CCVSearch
.bc50	e6 37		inc $37				inc 	zTemp0+1
.bc52	80 d0		bra $bc24			bra 	_CCVSearch
.bc54					_CCVFail:
.bc54	a0 01		ldy #$01			ldy 	#1 							; create the new record. Offset 1 is hash
.bc56	ad 03 04	lda $0403			lda 	identHash
.bc59	91 36		sta ($36),y			sta 	(zTemp0),y
.bc5b	c8		iny				iny 								; offset 2 is the type byte
.bc5c	ad 04 04	lda $0404			lda 	identTypeByte
.bc5f	91 36		sta ($36),y			sta 	(zTemp0),y
.bc61	c8		iny				iny
.bc62					_CCVData:
.bc62	a9 00		lda #$00			lda 	#0 							; erase data 3-7 (the 5 value bytes)
.bc64	91 36		sta ($36),y			sta 	(zTemp0),y
.bc66	c8		iny				iny
.bc67	c0 08		cpy #$08			cpy 	#8
.bc69	90 f7		bcc $bc62			bcc 	_CCVData
.bc6b	ae 00 04	ldx $0400			ldx 	identStart 					; copy name into 8 on.
.bc6e					_CCVCopyName:
.bc6e	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.bc71	91 36		sta ($36),y			sta 	(zTemp0),y
.bc73	e8		inx				inx
.bc74	c8		iny				iny
.bc75	ec 02 04	cpx $0402			cpx 	identTypeEnd
.bc78	d0 f4		bne $bc6e			bne 	_CCVCopyName
.bc7a	98		tya				tya 								; patch offset
.bc7b	92 36		sta ($36)			sta 	(zTemp0)
.bc7d	a9 00		lda #$00			lda 	#0 							; offset for next is zero.
.bc7f	91 36		sta ($36),y			sta 	(zTemp0),y
.bc81	88		dey				dey
.bc82	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set bit 7 of last bit
.bc84	09 80		ora #$80			ora 	#$80
.bc86	91 36		sta ($36),y			sta 	(zTemp0),y
.bc88					_CCVFound:
.bc88	a5 37		lda $37				lda 	zTemp0+1 					; write out MSB
.bc8a	38		sec				sec
.bc8b	e9 10		sbc #$10			sbc 	#(VariableSpace >> 8) 		; offset from the start of the variable token
.bc8d	09 40		ora #$40			ora 	#$40 						; make it a writeable token $4000-$7FFF
.bc8f	20 10 bc	jsr $bc10			jsr 	TOKWriteByte
.bc92	a5 36		lda $36				lda 	zTemp0 						; write out LSB
.bc94	20 10 bc	jsr $bc10			jsr 	TOKWriteByte
.bc97	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_sound.module

=1					soundIntegrated=1
.bc98					SNDCheckChannel:
.bc98	aa		tax				tax
.bc99	bd 8b 07	lda $078b,x			lda 	SNDTimeLeft,x 				; currently playing a note
.bc9c	d0 38		bne $bcd6			bne 	_SNDCCExit
.bc9e	da		phx				phx 								; save current channel
.bc9f	8a		txa				txa 								; put in A
.bca0	20 1c bd	jsr $bd1c			jsr 	SNDFindNextNoteForA 		; is there a note for A in the queue ?
.bca3	68		pla				pla 								; channel # in A
.bca4	90 30		bcc $bcd6			bcc 	_SNDCCExit  				; nothing in the queue for this channel, exit.
.bca6	a8		tay				tay 								; Y is the channel #
.bca7	bd 80 06	lda $0680,x			lda 	SNDQueue+1,x 				; copy data into the slot.
.bcaa	99 7f 07	sta $077f,y			sta 	SNDPitchLow,y
.bcad	bd 81 06	lda $0681,x			lda 	SNDQueue+2,x
.bcb0	99 83 07	sta $0783,y			sta 	SNDPitchHigh,y
.bcb3	bd 82 06	lda $0682,x			lda 	SNDQueue+3,x
.bcb6	99 87 07	sta $0787,y			sta 	SNDVolume,y
.bcb9	bd 83 06	lda $0683,x			lda 	SNDQueue+4,x
.bcbc	99 8b 07	sta $078b,y			sta 	SNDTimeLeft,y
.bcbf	bd 84 06	lda $0684,x			lda 	SNDQueue+5,x
.bcc2	99 8f 07	sta $078f,y			sta 	SNDAdjustLow,y
.bcc5	bd 85 06	lda $0685,x			lda 	SNDQueue+6,x
.bcc8	99 93 07	sta $0793,y			sta 	SNDAdjustHigh,y
.bccb	5a		phy				phy 								; save channel #
.bccc	20 36 bd	jsr $bd36			jsr 	SNDDeleteXFromQueue 		; delete record at X from queue
.bccf	ce 7e 06	dec $067e			dec 	SNDLength 					; reduce the queue length.
.bcd2	68		pla				pla
.bcd3	20 d7 bc	jsr $bcd7			jsr 	SNDUpdateNote 				; update channel A
.bcd6					_SNDCCExit:
.bcd6	60		rts				rts
.bcd7					SNDUpdateNote:
.bcd7	aa		tax				tax 								; so we can access records
.bcd8	0a		asl a				asl 	a 							; convert it to a channel bit pair in 5,6
.bcd9	0a		asl a				asl 	a
.bcda	0a		asl a				asl 	a
.bcdb	0a		asl a				asl 	a
.bcdc	0a		asl a				asl 	a
.bcdd	8d 7d 06	sta $067d			sta 	SNDChannelBits
.bce0	bd 8b 07	lda $078b,x			lda 	SNDTimeLeft,x 				; are we silent
.bce3	f0 2e		beq $bd13			beq 	_SNDUNIsSilent
.bce5	ad 7d 06	lda $067d			lda 	SNDChannelBits 				; push channel bits on stack
.bce8	48		pha				pha
.bce9	bd 7f 07	lda $077f,x			lda 	SNDPitchLow,x 				; get 4 lowest bits of pitch.
.bcec	29 0f		and #$0f			and 	#$0F
.bcee	0d 7d 06	ora $067d			ora 	SNDChannelBits 				; set channel bits
.bcf1	09 80		ora #$80			ora 	#$80 						; write to pitch register
.bcf3	20 80 bd	jsr $bd80			jsr 	SNDWritePorts
.bcf6	bd 83 07	lda $0783,x			lda 	SNDPitchHigh,x 				; pitch high => channel temp.
.bcf9	8d 7d 06	sta $067d			sta 	SNDChannelBits
.bcfc	bd 7f 07	lda $077f,x			lda 	SNDPitchLow,x
.bcff	4e 7d 06	lsr $067d			lsr 	SNDChannelBits 				; shift 2 LSBs into MSB of A
.bd02	6a		ror a				ror 	a
.bd03	4e 7d 06	lsr $067d			lsr 	SNDChannelBits
.bd06	6a		ror a				ror 	a
.bd07	4a		lsr a				lsr 	a 							; put in bits 0-5
.bd08	4a		lsr a				lsr 	a
.bd09	20 80 bd	jsr $bd80			jsr 	SNDWritePorts 				; write as rest of pitch register
.bd0c	68		pla				pla
.bd0d	09 90		ora #$90			ora 	#$90 						; set to write minimum attentuation.
.bd0f	20 80 bd	jsr $bd80			jsr 	SNDWritePorts
.bd12	60		rts				rts
.bd13					_SNDUNIsSilent:
.bd13	ad 7d 06	lda $067d			lda 	SNDChannelBits 				; channel bits
.bd16	09 9f		ora #$9f			ora 	#$9F 						; maximum attenuation
.bd18	20 80 bd	jsr $bd80			jsr 	SNDWritePorts 				; write to the ports
.bd1b	60		rts				rts
.bd1c					SNDFindNextNoteForA:
.bd1c	ac 7e 06	ldy $067e			ldy 	SNDLength 					; queue size into Y
.bd1f	f0 13		beq $bd34			beq 	_SNDFNNFail 				; queue empty.
.bd21	a2 00		ldx #$00			ldx 	#0
.bd23					_SNDFNNSearch:
.bd23	dd 7f 06	cmp $067f,x			cmp 	SNDQueue,x 					; does it match the channel
.bd26	38		sec				sec
.bd27	f0 0c		beq $bd35			beq 	_SNDFNNExit 				; if so exit with CS.
.bd29	e8		inx				inx 								; next queue slot.
.bd2a	e8		inx				inx
.bd2b	e8		inx				inx
.bd2c	e8		inx				inx
.bd2d	e8		inx				inx
.bd2e	e8		inx				inx
.bd2f	e8		inx				inx
.bd30	e8		inx				inx
.bd31	88		dey				dey 								; done the whole queue
.bd32	d0 ef		bne $bd23			bne 	_SNDFNNSearch 				; no, go back.
.bd34					_SNDFNNFail:
.bd34	18		clc				clc
.bd35					_SNDFNNexit:
.bd35	60		rts				rts
.bd36					SNDDeleteXFromQueue:
.bd36	e0 f8		cpx #$f8			cpx 	#SNDQueueSize*8-8 			; reached the end.
.bd38	f0 09		beq $bd43			beq 	_SNDDXExit
.bd3a	bd 87 06	lda $0687,x			lda 	SNDQueue+8,x
.bd3d	9d 7f 06	sta $067f,x			sta 	SNDQueue,x
.bd40	e8		inx				inx
.bd41	80 f3		bra $bd36			bra 	SNDDeleteXFromQueue
.bd43					_SNDDXExit:
.bd43	60		rts				rts
.067d					SNDChannelBits:
>067d							.fill 	1
.bd44					SNDQueueRequest:
.bd44	86 36		stx $36				stx 	zTemp0						; save queue address
.bd46	84 37		sty $37				sty 	zTemp0+1
.bd48	ae 7e 06	ldx $067e			ldx 	SNDLength 					; queue is full, can't take any more.
.bd4b	e0 20		cpx #$20			cpx 	#SNDQueueSize
.bd4d	f0 21		beq $bd70			beq 	_SNDQRExit
.bd4f	29 03		and #$03			and 	#3	 						; channel # and push on stack
.bd51	48		pha				pha
.bd52	8a		txa				txa  								; get offset in queue buffer/
.bd53	0a		asl a				asl 	a
.bd54	0a		asl a				asl 	a
.bd55	0a		asl a				asl 	a
.bd56	aa		tax				tax
.bd57	68		pla				pla 								; get back and push again
.bd58	48		pha				pha
.bd59	9d 7f 06	sta $067f,x			sta 	SNDQueue+0,x 				; save the channel #
.bd5c	a0 00		ldy #$00			ldy 	#0 							; copy the rest in.
.bd5e					_SNDQCopy:
.bd5e	b1 36		lda ($36),y			lda 	(zTemp0),y
.bd60	e8		inx				inx
.bd61	c8		iny				iny
.bd62	9d 7f 06	sta $067f,x			sta 	SNDQueue,x
.bd65	c0 06		cpy #$06			cpy 	#6
.bd67	d0 f5		bne $bd5e			bne 	_SNDQCopy
.bd69	ee 7e 06	inc $067e			inc 	SNDLength 					; bump queue length.
.bd6c	68		pla				pla 								; get channel # back
.bd6d	20 98 bc	jsr $bc98			jsr 	SNDCheckChannel 			; check if channel needs refreshing.
.bd70					_SNDQRExit:
.bd70	60		rts				rts
.bd71					SNDSilenceChannel:
.bd71	aa		tax				tax 								; zero time left.
.bd72	9e 8b 07	stz $078b,x			stz 	SNDTimeLeft,x
.bd75	0a		asl a				asl 	a 							; shift into position
.bd76	0a		asl a				asl 	a
.bd77	0a		asl a				asl 	a
.bd78	0a		asl a				asl 	a
.bd79	0a		asl a				asl 	a
.bd7a	09 9f		ora #$9f			ora 	#$9F 						; write register attenuation $F
.bd7c	20 80 bd	jsr $bd80			jsr 	SNDWritePorts
.bd7f	60		rts				rts
.bd80					SNDWritePorts:
.bd80	da		phx				phx 								; save X
.bd81	a6 01		ldx $01				ldx 	1 							; save I/O status
.bd83	64 01		stz $01				stz 	1 							; access I/O page 0
.bd85	8d 00 d6	sta $d600			sta 	$D600 						; write to both
.bd88	8d 10 d6	sta $d610			sta 	$D610
.bd8b	86 01		stx $01				stx 	1 							; restore I/O
.bd8d	fa		plx				plx 								; restore X
.bd8e	60		rts				rts
.bd8f					Export_SNDCommand:
.bd8f	da		phx				phx 								; save XY
.bd90	5a		phy				phy
.bd91	c9 0f		cmp #$0f			cmp 	#$0F 						; $0F is initialise
.bd93	f0 1d		beq $bdb2			beq 	_SNDInitialise
.bd95	90 28		bcc $bdbf			bcc 	_SNDExit
.bd97	c9 3f		cmp #$3f			cmp 	#$3F 						; $3F is silence all
.bd99	f0 17		beq $bdb2			beq 	_SNDSilence
.bd9b	b0 22		bcs $bdbf			bcs 	_SNDExit
.bd9d	c9 20		cmp #$20			cmp 	#$20 						; $2x is check playing => A
.bd9f	b0 09		bcs $bdaa			bcs 	_SNDQueryPlay
.bda1	c9 14		cmp #$14			cmp 	#$14 						; $10-$13 is queue sound
.bda3	b0 1a		bcs $bdbf			bcs 	_SNDExit
.bda5	20 44 bd	jsr $bd44			jsr 	SNDQueueRequest
.bda8	80 15		bra $bdbf			bra 	_SNDExit
.bdaa					_SNDQueryPlay:
.bdaa	29 03		and #$03			and 	#3 							; get channel #
.bdac	aa		tax				tax
.bdad	bd 8b 07	lda $078b,x			lda 	SNDTimeLeft,x 				; read time left, if zero then silent
.bdb0	80 0d		bra $bdbf			bra 	_SNDExit
.bdb2					_SNDInitialise:
.bdb2					_SNDSilence:
.bdb2	9c 7e 06	stz $067e			stz 	SNDLength 					; empty the queue.
.bdb5	a9 03		lda #$03			lda 	#$3 						; silence channel 0-3.
.bdb7					_SNDSilenceLoop:
.bdb7	48		pha				pha
.bdb8	20 71 bd	jsr $bd71			jsr 	SNDSilenceChannel
.bdbb	68		pla				pla
.bdbc	3a		dec a				dec 	a
.bdbd	10 f8		bpl $bdb7			bpl 	_SNDSilenceLoop
.bdbf					_SNDExit:
.bdbf	7a		ply				ply
.bdc0	fa		plx				plx
.bdc1	60		rts				rts
=32					SNDQueueSize = 32 							; number of queue entries
.067e					SNDLength:
>067e							.fill 	1
.067f					SNDQueue:
>067f							.fill 	SNDQueueSize * 8
.077f					SNDPitchLow:
>077f							.fill 	4
.0783					SNDPitchHigh:
>0783							.fill 	4
.0787					SNDVolume:
>0787							.fill 	4
.078b					SNDTimeLeft:
>078b							.fill 	4
.078f					SNDAdjustLow:
>078f							.fill 	4
.0793					SNDAdjustHigh:
>0793							.fill 	4
.bdc2					Export_SNDUpdate:
.bdc2					PagedSNDUpdate:
.bdc2	ad 8b 07	lda $078b			lda 	SNDTimeLeft+0 				; look at time remaining
.bdc5	f0 05		beq $bdcc			beq 	_SNDUNot0 					; not playing
.bdc7	a2 00		ldx #$00			ldx 	#0 							; so we know which channel to update
.bdc9	20 eb bd	jsr $bdeb			jsr 	SNDUpdateChannel 			; update it.
.bdcc					_SNDUNot0:
.bdcc	ad 8c 07	lda $078c			lda 	SNDTimeLeft+1
.bdcf	f0 05		beq $bdd6			beq 	_SNDUNot1
.bdd1	a2 01		ldx #$01			ldx 	#1
.bdd3	20 eb bd	jsr $bdeb			jsr 	SNDUpdateChannel
.bdd6					_SNDUNot1:
.bdd6	ad 8d 07	lda $078d			lda 	SNDTimeLeft+2
.bdd9	f0 05		beq $bde0			beq 	_SNDUNot2
.bddb	a2 02		ldx #$02			ldx 	#2
.bddd	20 eb bd	jsr $bdeb			jsr 	SNDUpdateChannel
.bde0					_SNDUNot2:
.bde0	ad 8e 07	lda $078e			lda 	SNDTimeLeft+3
.bde3	f0 05		beq $bdea			beq 	_SNDUNot3
.bde5	a2 03		ldx #$03			ldx 	#3
.bde7	20 eb bd	jsr $bdeb			jsr 	SNDUpdateChannel
.bdea					_SNDUNot3:
.bdea	60		rts				rts
.bdeb					SNDUpdateChannel:
.bdeb	c9 ff		cmp #$ff			cmp 	#$FF 						; sound $FF play forever until turned off manually
.bded	f0 2c		beq $be1b			beq 	_SNDUCExit
.bdef	3a		dec a				dec 	a 							; decrement and update timer
.bdf0	9d 8b 07	sta $078b,x			sta 	SNDTimeLeft,x
.bdf3	f0 1d		beq $be12			beq 	_SNDUCUpdate 				; if zero, silence channel
.bdf5	bd 8f 07	lda $078f,x			lda 	SNDAdjustLow,x 				; adjust ?
.bdf8	1d 93 07	ora $0793,x			ora 	SNDAdjustHigh,x
.bdfb	f0 1e		beq $be1b			beq 	_SNDUCExit 					; if zero carry on at current tone.
.bdfd	18		clc				clc 								; add adjust, forcing into a 10 bit range
.bdfe	bd 7f 07	lda $077f,x			lda 	SNDPitchLow,x
.be01	7d 8f 07	adc $078f,x			adc 	SNDAdjustLow,x
.be04	9d 7f 07	sta $077f,x			sta 	SNDPitchLow,x
.be07	bd 83 07	lda $0783,x			lda 	SNDPitchHigh,x
.be0a	7d 93 07	adc $0793,x			adc 	SNDAdjustHigh,x
.be0d	29 03		and #$03			and 	#3
.be0f	9d 83 07	sta $0783,x			sta 	SNDPitchHigh,x
.be12					_SNDUCUpdate:
.be12	8a		txa				txa 								; which channel.
.be13	48		pha				pha
.be14	20 d7 bc	jsr $bcd7			jsr 	SNDUpdateNote 				; update the current note
.be17	68		pla				pla
.be18	20 98 bc	jsr $bc98			jsr 	SNDCheckChannel 			; more to do ?
.be1b					_SNDUCExit:
.be1b	60		rts				rts

;******  Return to file: _basic.asm


;******  End of listing
