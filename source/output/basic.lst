
; 64tass Turbo Assembler Macro V1.57.2900 listing file
; 64tass -D AUTORUN=0 "-D MONITOR_ADDRESS=\$E000" "-D LOCKOUT_ADDRESS=\$F000" "-D BASIC_ADDRESS=\$38000" "-D SOURCE_ADDRESS=\$3000" "-D SPRITE_ADDRESS=\$30000" -q -b -Wall -c -D "HARDWARE=0 $'\x9'$'\x9'$'\x9'$'\x9'$'\x9'$'\x9'" -L output/basic.lst -l output/basic.lbl -Wall -o basic.rom _basic.asm
; Tue Nov 22 10:57:35 2022

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=0					AUTORUN=0
=$e000					 MONITOR_ADDRESS=$E000
=$f000					 LOCKOUT_ADDRESS=$F000
=$38000					 BASIC_ADDRESS=$38000
=$3000					 SOURCE_ADDRESS=$3000
=$30000					 SPRITE_ADDRESS=$30000
=0					HARDWARE=0

;******  Processing input file: _basic.asm


;******  Processing file: ./common/aa.system/01common.inc

=$30					ZeroPageMandatory = $30
=$400					ZeroPagePreference = $400
=$480					MemoryStorage = $480
=$2000					BasicStart = $2000
=$8000					BasicEnd = $8000
=$8000					CodeStart = $8000
=$1000					VariableSpace = $1000
=$2000					EndVariableSpace = $2000
=8					MathStackSize = 8
=512					BasicStackSize = 512
=3584					BasicStackBase = $1000-BasicStackSize
=80					MaxLineSize = 80

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/02macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/04data.inc

.0030					codePtr:
>0030							.fill 	4
.0034					basicStack:
>0034							.fill 	2
.0036					zTemp0:
>0036							.fill 	2
.0038					zTemp1:
>0038							.fill 	2
.003a					zTemp2:
>003a							.fill 	2
.003c					zsTemp:
>003c							.fill 	2
.003e					zaTemp:
>003e							.fill 	2
=$30					safePtr = codePtr 							; minimise direct tinkering
=$80					NSBIsNegative = $80 						; bit 7 : sign of mantissa (where numeric)
=$20					NSBIsReference = $20 						; bit 5 : is a reference
=$10					NSBIsString = $10 							; bit 4 : set if string (procedures don't go on the stack)
=$18					NSBTypeMask = $18 							; bits 4,3 : 00 int 01 float 10 string 11 procedure
=$03					NSBRefMask = $03 							; bits 0,1 : Bytes of reference, -1 (e.g. 00 = 1 byte, 11 = 4 bytes)
=$04					NSBIsArray = $04
=$00					NSTInteger = $00 							; base types for bits 3..4
=$08					NSTFloat = $08
=$10					NSTString = $10
=$18					NSTProcedure = $18
.0400					NSStatus:
>0400							.fill 	MathStackSize
.0408					NSMantissa0:
>0408							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0410					NSMantissa1:
>0410							.fill 	MathStackSize
.0418					NSMantissa2:
>0418							.fill 	MathStackSize
.0420					NSMantissa3:
>0420							.fill 	MathStackSize
.0428					NSExponent:
>0428							.fill 	MathStackSize
.0480					identStart:
>0480							.fill 	1
.0481					identTypeStart:
>0481							.fill 	1
.0482					identTypeEnd:
>0482							.fill 	1
.0483					identHash:
>0483							.fill 	1
.0484					identTypeByte:
>0484							.fill 	1	 						; (see tokenising.pdf)
.0485					encodeState:
>0485							.fill 	1
.0486					digitTemp:
>0486							.fill 	1
.0487					decimalCount:
>0487							.fill 	1
.0488					randomSeed:
>0488							.fill 	4
.048c					lowMemPtr:
>048c							.fill 	2
.048e					stringMemory:
>048e							.fill 	2
.0490					stringInitialised:
>0490							.fill 	1
.0491					stringTempPointer:
>0491							.fill 	2
.0493					breakCheck:
>0493							.fill 	1
.0494					decimalPlaces:
>0494							.fill 	1
.0495					dbOffset:
>0495							.fill 	1
.0496					lastParameter:
>0496							.fill 	1
.0497					dataPointer:
>0497							.fill 	5
.049c					inDataStatement:
>049c							.fill 	1
.049d					tbOffset:
>049d							.fill 	1
.049e					AssemblerAddress:
>049e							.fill 	2
.04a0					AssemblerControl:
>04a0							.fill 	1
.04a1					ParamStart:
>04a1							.fill 	2
.04a3					IsGroup1:
>04a3							.fill 	1
.04a4					BaseOpcode:
>04a4							.fill 	1
.04a5					ModeMask:
>04a5							.fill 	1
.04a6					listIndent:
>04a6							.fill 	1
.04a7					lcLastCharacter:
>04a7							.fill 	1
.04a8					tokenOffset:
>04a8							.fill 	1
.04a9					tokenLineNumber:
>04a9							.fill 	2
.04ab					tokenBuffer:
>04ab							.fill 	253
.05a8					lineBuffer:
>05a8							.fill 	MaxLineSize+1
.05f9					numberBuffer:
>05f9							.fill 	34
.061b					decimalBuffer:
>061b							.fill 	16

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/constants.inc

=$80					AM_ISZP = $80
=$40					AM_ISG1 = $40
=$20					AM_ISG2 = $20
=224					AM_IMMEDIATE = AM_ISZP+AM_ISG1+AM_ISG2+$00
=228					AM_ZEROPAGE = AM_ISZP+AM_ISG1+AM_ISG2+$04
=40					AM_ACC = AM_ISG2+$08
=108					AM_ABS = AM_ISG1+AM_ISG2+$0C
=208					AM_INDY = AM_ISZP+AM_ISG1+$10
=244					AM_ZEROX = AM_ISZP+AM_ISG1+AM_ISG2+$14
=120					AM_ABSY = AM_ISG1+AM_ISG2+$18
=124					AM_ABSX = AM_ISG1+AM_ISG2+$1C
=209					AM_IND = AM_ISZP+AM_ISG1+$11
=$80					AM_ZEROY = AM_ISZP
=$01					AM_INDABS = $01
=$02					AM_INDABSX = $02
=192					AM_INDX = AM_ISZP+AM_ISG1+$00

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/handlers.inc


;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.inc

=1					ERRID_BREAK = 1
=2					ERRID_SYNTAX = 2
=3					ERRID_DIVZERO = 3
=4					ERRID_RANGE = 4
=5					ERRID_TYPE = 5
=6					ERRID_MEMORY = 6
=7					ERRID_ARGUMENT = 7
=8					ERRID_STOP = 8
=9					ERRID_STRING = 9
=10					ERRID_ASSERT = 10
=11					ERRID_DATA = 11
=12					ERRID_NOTDONE = 12
=13					ERRID_LINE = 13
=14					ERRID_GOSUB = 14
=15					ERRID_REPEAT = 15
=16					ERRID_WHILE = 16
=17					ERRID_FOR = 17
=18					ERRID_STACK = 18
=19					ERRID_STRUCT = 19
=20					ERRID_PROC = 20
=21					ERRID_REDEFINE = 21
=22					ERRID_ARRAYSIZE = 22
=23					ERRID_ARRAYIDX = 23

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst.inc

=$00					KWD_LESSLESS                         = $00; $00 <<
=$01					KWD_LESSEQUAL                        = $01; $01 <=
=$02					KWD_LESSGREATER                      = $02; $02 <>
=$03					KWD_PLINGPLING3                      = $03; $03 !!3
=$04					KWD_GREATERLESS                      = $04; $04 ><
=$05					KWD_GREATEREQUAL                     = $05; $05 >=
=$06					KWD_GREATERGREATER                   = $06; $06 >>
=$07					KWD_PLINGPLING7                      = $07; $07 !!7
=$08					KWD_PLINGPLING8                      = $08; $08 !!8
=$09					KWD_PLINGPLING9                      = $09; $09 !!9
=$0a					KWD_PLINGPLING10                     = $0a; $0a !!10
=$0b					KWD_PLINGPLING11                     = $0b; $0b !!11
=$0c					KWD_PLINGPLING12                     = $0c; $0c !!12
=$0d					KWD_PLINGPLING13                     = $0d; $0d !!13
=$0e					KWD_PLINGPLING14                     = $0e; $0e !!14
=$0f					KWD_PLINGPLING15                     = $0f; $0f !!15
=$10					KWD_AT                               = $10; $10 @
=$11					KWD_PLINGPLING17                     = $11; $11 !!17
=$12					KWD_PLINGPLING18                     = $12; $12 !!18
=$13					KWD_LSQPAREN                         = $13; $13 [
=$14					KWD_BACKSLASH                        = $14; $14 \
=$15					KWD_RSQPAREN                         = $15; $15 ]
=$16					KWD_HAT                              = $16; $16 ^
=$17					KWD_UNDERSCORE                       = $17; $17 _
=$18					KWD_BQUOTE                           = $18; $18 `
=$19					KWD_PLINGPLING25                     = $19; $19 !!25
=$1a					KWD_PLINGPLING26                     = $1a; $1a !!26
=$1b					KWD_LCURLY                           = $1b; $1b {
=$1c					KWD_BAR                              = $1c; $1c |
=$1d					KWD_RCURLY                           = $1d; $1d }
=$1e					KWD_TILDE                            = $1e; $1e ~
=$21					KWD_PLING                            = $21; $21 !
=$22					KWD_DQUOTE                           = $22; $22 "
=$23					KWD_HASH                             = $23; $23 #
=$24					KWD_DOLLAR                           = $24; $24 $
=$25					KWD_PERCENT                          = $25; $25 %
=$26					KWD_AMPERSAND                        = $26; $26 &
=$27					KWD_QUOTE                            = $27; $27 '
=$28					KWD_LPAREN                           = $28; $28 (
=$29					KWD_RPAREN                           = $29; $29 )
=$2a					KWD_STAR                             = $2a; $2a *
=$2b					KWD_PLUS                             = $2b; $2b +
=$2c					KWD_COMMA                            = $2c; $2c ,
=$2d					KWD_MINUS                            = $2d; $2d -
=$2e					KWD_PERIOD                           = $2e; $2e .
=$2f					KWD_SLASH                            = $2f; $2f /
=$30					KWD_0                                = $30; $30 0
=$31					KWD_1                                = $31; $31 1
=$32					KWD_2                                = $32; $32 2
=$33					KWD_3                                = $33; $33 3
=$34					KWD_4                                = $34; $34 4
=$35					KWD_5                                = $35; $35 5
=$36					KWD_6                                = $36; $36 6
=$37					KWD_7                                = $37; $37 7
=$38					KWD_8                                = $38; $38 8
=$39					KWD_9                                = $39; $39 9
=$3a					KWD_COLON                            = $3a; $3a :
=$3b					KWD_SEMICOLON                        = $3b; $3b ;
=$3c					KWD_LESS                             = $3c; $3c <
=$3d					KWD_EQUAL                            = $3d; $3d =
=$3e					KWD_GREATER                          = $3e; $3e >
=$3f					KWD_QMARK                            = $3f; $3f ?
=$83					KWD_ABSLPAREN                        = $83; $83 ABS(
=$84					KWD_ALLOCLPAREN                      = $84; $84 ALLOC(
=$85					KWD_ASCLPAREN                        = $85; $85 ASC(
=$86					KWD_CHRDOLLARLPAREN                  = $86; $86 CHR$(
=$87					KWD_EVENTLPAREN                      = $87; $87 EVENT(
=$88					KWD_FALSE                            = $88; $88 FALSE
=$89					KWD_FRACLPAREN                       = $89; $89 FRAC(
=$8a					KWD_HITLPAREN                        = $8a; $8a HIT(
=$8b					KWD_INTLPAREN                        = $8b; $8b INT(
=$8c					KWD_ISVALLPAREN                      = $8c; $8c ISVAL(
=$8d					KWD_JOYBLPAREN                       = $8d; $8d JOYB(
=$8e					KWD_JOYXLPAREN                       = $8e; $8e JOYX(
=$8f					KWD_JOYYLPAREN                       = $8f; $8f JOYY(
=$90					KWD_LEFTDOLLARLPAREN                 = $90; $90 LEFT$(
=$91					KWD_LENLPAREN                        = $91; $91 LEN(
=$92					KWD_MAXLPAREN                        = $92; $92 MAX(
=$93					KWD_MIDDOLLARLPAREN                  = $93; $93 MID$(
=$94					KWD_MINLPAREN                        = $94; $94 MIN(
=$95					KWD_NOTLPAREN                        = $95; $95 NOT(
=$96					KWD_PLAYINGLPAREN                    = $96; $96 PLAYING(
=$97					KWD_RANDOMLPAREN                     = $97; $97 RANDOM(
=$98					KWD_RIGHTDOLLARLPAREN                = $98; $98 RIGHT$(
=$99					KWD_RNDLPAREN                        = $99; $99 RND(
=$9a					KWD_SGNLPAREN                        = $9a; $9a SGN(
=$9b					KWD_SPCLPAREN                        = $9b; $9b SPC(
=$9c					KWD_STRDOLLARLPAREN                  = $9c; $9c STR$(
=$9d					KWD_TIMERLPAREN                      = $9d; $9d TIMER(
=$9e					KWD_TRUE                             = $9e; $9e TRUE
=$9f					KWD_VALLPAREN                        = $9f; $9f VAL(
=$a0					KWD_FOR                              = $a0; $a0 FOR
=$a1					KWD_IF                               = $a1; $a1 IF
=$a2					KWD_PROC                             = $a2; $a2 PROC
=$a3					KWD_REPEAT                           = $a3; $a3 REPEAT
=$a4					KWD_WHILE                            = $a4; $a4 WHILE
=$a5					KWD_ENDIF                            = $a5; $a5 ENDIF
=$a6					KWD_ENDPROC                          = $a6; $a6 ENDPROC
=$a7					KWD_NEXT                             = $a7; $a7 NEXT
=$a8					KWD_THEN                             = $a8; $a8 THEN
=$a9					KWD_UNTIL                            = $a9; $a9 UNTIL
=$aa					KWD_WEND                             = $aa; $aa WEND
=$ab					KWD_BY                               = $ab; $ab BY
=$ac					KWD_CALL                             = $ac; $ac CALL
=$ad					KWD_CIRCLE                           = $ad; $ad CIRCLE
=$ae					KWD_CLEAR                            = $ae; $ae CLEAR
=$af					KWD_CLS                              = $af; $af CLS
=$b0					KWD_COLOR                            = $b0; $b0 COLOR
=$b1					KWD_COLOUR                           = $b1; $b1 COLOUR
=$b2					KWD_DATA                             = $b2; $b2 DATA
=$b3					KWD_DIM                              = $b3; $b3 DIM
=$b4					KWD_DOWNTO                           = $b4; $b4 DOWNTO
=$b5					KWD_ELSE                             = $b5; $b5 ELSE
=$b6					KWD_FROM                             = $b6; $b6 FROM
=$b7					KWD_GFX                              = $b7; $b7 GFX
=$b8					KWD_GOSUB                            = $b8; $b8 GOSUB
=$b9					KWD_GOTO                             = $b9; $b9 GOTO
=$ba					KWD_HERE                             = $ba; $ba HERE
=$bb					KWD_IMAGE                            = $bb; $bb IMAGE
=$bc					KWD_LET                              = $bc; $bc LET
=$bd					KWD_LINE                             = $bd; $bd LINE
=$be					KWD_LOCAL                            = $be; $be LOCAL
=$bf					KWD_OFF                              = $bf; $bf OFF
=$c0					KWD_ON                               = $c0; $c0 ON
=$c1					KWD_OUTLINE                          = $c1; $c1 OUTLINE
=$c2					KWD_PALETTE                          = $c2; $c2 PALETTE
=$c3					KWD_PLOT                             = $c3; $c3 PLOT
=$c4					KWD_PRINT                            = $c4; $c4 PRINT
=$c5					KWD_READ                             = $c5; $c5 READ
=$c6					KWD_RECT                             = $c6; $c6 RECT
=$c7					KWD_REM                              = $c7; $c7 REM
=$c8					KWD_RETURN                           = $c8; $c8 RETURN
=$c9					KWD_SOLID                            = $c9; $c9 SOLID
=$ca					KWD_SOUND                            = $ca; $ca SOUND
=$cb					KWD_SPRITE                           = $cb; $cb SPRITE
=$cc					KWD_TEXT                             = $cc; $cc TEXT
=$cd					KWD_TO                               = $cd; $cd TO

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst0.inc

=$80					KWC_EOL = $80
=$ff					KWC_STRING = $FF
=$fe					KWC_HEXCONST = $FE
=$a0					KWC_FIRST_STRUCTURE = $a0
=$a5					KWC_FIRST_STRUCTURE_DEC = $a5
=$aa					KWC_LAST_STRUCTURE = $aa
=$83					KWC_FIRST_UNARY = $83
=$9f					KWC_LAST_UNARY = $9f

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/access.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/stack.inc

=$e0					STK_GOSUB = $E0
=$d0					STK_FOR = $D0
=$c0					STK_REPEAT = $C0
=$b0					STK_PROC = $B0
=$a0					STK_WHILE = $A0
=$01					STK_LOCALN = $01
=$02					STK_LOCALS = $02

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/00start.asm

.8000	a2 ff		ldx #$ff	Start:	ldx 	#$FF 						; stack reset
.8002	9a		txs				txs
.8003	20 52 aa	jsr $aa52			jsr 	EXTInitialise 				; hardware initialise
.8006	a2 80		ldx #$80			ldx 	#(Prompt >> 8) 				; prompt
.8008	a9 22		lda #$22			lda 	#(Prompt & $FF)
.800a	20 be 8d	jsr $8dbe			jsr 	PrintStringXA
.800d	a9 00		lda #$00			lda 	#0 							; graphics system initialise.
.800f	aa		tax				tax
.8010	a8		tay				tay
.8011	20 de aa	jsr $aade			jsr 	GXGraphicDraw
.8014	a9 0f		lda #$0f			lda 	#$0F 						; initialise sound system
.8016	20 6c b9	jsr $b96c			jsr 	SNDCommand
.8019	20 4f 88	jsr $884f			jsr 	NewProgram 					; erase current program
.801c	20 e4 82	jsr $82e4			jsr 	BackloadProgram
.801f	4c 54 83	jmp $8354			jmp 	WarmStart
>8022	0c 2a 2a 2a 20 46 32 35		Prompt:	.text 	12,"*** F256 Junior SuperBASIC ***",13,13
>802a	36 20 4a 75 6e 69 6f 72 20 53 75 70 65 72 42 41
>803a	53 49 43 20 2a 2a 2a 0d 0d

;******  Processing file: ./common/aa.system/../generated/timestamp.asm

>8043	42 75 69 6c 74 20 54 75			.text "Built Tuesday 22-Nov-2022. Build 3536."
>804b	65 73 64 61 79 20 32 32 2d 4e 6f 76 2d 32 30 32
>805b	32 2e 20 42 75 69 6c 64 20 33 35 33 36 2e

;******  Return to file: ./common/aa.system/00start.asm

>8069	0d 0d 00					.byte 	13,13,0

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/assembler.asm

.806c					AssembleGroup1:
.806c	a9 ff		lda #$ff			lda 	#$FF
.806e	8d a5 04	sta $04a5			sta 	ModeMask 					; initialise the mode mask - all for all
.8071	80 02		bra $8075			bra 	AsmGroup12
.8073					AssembleGroup2:
.8073	a9 00		lda #$00			lda 	#$00
.8075					AsmGroup12:
.8075	8d a3 04	sta $04a3			sta 	IsGroup1 					; save the 'group 1' flag
.8078	68		pla				pla 								; pop the return address to access the information following.
.8079	fa		plx				plx
.807a	20 03 81	jsr $8103			jsr 	AccessParameters 			; get opcode and save as base
.807d	8d a4 04	sta $04a4			sta 	BaseOpcode
.8080	ad a3 04	lda $04a3			lda 	IsGroup1 					; skip if group 1 as we don't have a complex mask.
.8083	d0 08		bne $808d			bne 	_AG12HaveMask
.8085	a9 02		lda #$02			lda 	#2 							; if group 2 the second parameter is the mask
.8087	20 0b 81	jsr $810b			jsr 	GetParameter		 		; e.g. which modes are supported for this operand
.808a	8d a5 04	sta $04a5			sta 	ModeMask
.808d					_AG12HaveMask:
.808d	20 46 82	jsr $8246			jsr 	TypeAndCalculateOperand 	; get zero page type
.8090	da		phx				phx 								; save found address mode
.8091	20 6f 81	jsr $816f			jsr 	AssembleModeX
.8094	fa		plx				plx  								; restore address mode
.8095	b0 0b		bcs $80a2			bcs 	_AG12Exit
.8097	20 a3 80	jsr $80a3			jsr 	PromoteToAbsolute  			; promote ZP to ABS and try that
.809a	20 6f 81	jsr $816f			jsr 	AssembleModeX
.809d	b0 03		bcs $80a2			bcs 	_AG12Exit
.809f	4c b2 9f	jmp $9fb2			jmp 	SyntaxError 				; can't do either, so must be wrong mode/operand.
.80a2					_AG12Exit:
.80a2	60		rts				rts
.80a3					PromoteToAbsolute:
.80a3	a9 6c		lda #$6c			lda 	#AM_ABS 					; lda xx
.80a5	e0 e4		cpx #$e4			cpx 	#AM_ZEROPAGE
.80a7	f0 19		beq $80c2			beq 	_PTADo
.80a9	a9 7c		lda #$7c			lda 	#AM_ABSX 					; lda xx,X
.80ab	e0 f4		cpx #$f4			cpx 	#AM_ZEROX
.80ad	f0 13		beq $80c2			beq 	_PTADo
.80af	a9 78		lda #$78			lda 	#AM_ABSY 					; lda xx,Y
.80b1	e0 80		cpx #$80			cpx 	#AM_ZEROY
.80b3	f0 0d		beq $80c2			beq 	_PTADo
.80b5	a9 01		lda #$01			lda 	#AM_INDABS 					; lda (xx) (jump)
.80b7	e0 d1		cpx #$d1			cpx 	#AM_IND
.80b9	f0 07		beq $80c2			beq 	_PTADo
.80bb	a9 02		lda #$02			lda 	#AM_INDABSX 				; lda (xx,x) (jump)
.80bd	e0 c0		cpx #$c0			cpx 	#AM_INDX
.80bf	f0 01		beq $80c2			beq 	_PTADo
.80c1	60		rts				rts
.80c2					_PTADo:
.80c2	aa		tax				tax
.80c3	60		rts				rts
.80c4					AssembleGroup3:
.80c4	68		pla				pla 								; get parameters, which is just the opcode.
.80c5	fa		plx				plx
.80c6	20 03 81	jsr $8103			jsr 	AccessParameters 			; get and output opcode
.80c9	20 1b 81	jsr $811b			jsr 	AssemblerWriteByte
.80cc	20 aa 82	jsr $82aa			jsr 	CalculateOperand 			; get a 16 bit operand
.80cf	ad 08 04	lda $0408			lda 	NSMantissa0 				; calculate the offset
.80d2	38		sec				sec
.80d3	ed 9e 04	sbc $049e			sbc 	AssemblerAddress
.80d6	48		pha				pha 								; LSB in A
.80d7	ad 10 04	lda $0410			lda 	NSMantissa1
.80da	ed 9f 04	sbc $049f			sbc 	AssemblerAddress+1
.80dd	aa		tax				tax 								; MSB in X
.80de	68		pla				pla
.80df	18		clc				clc 								; $80 to easy check $80-$7F, plus 1 for offset error
.80e0	69 7f		adc #$7f			adc 	#$7F
.80e2	90 01		bcc $80e5			bcc 	_AG3NoCarry
.80e4	e8		inx				inx
.80e5					_AG3NoCarry:
.80e5	38		sec				sec 								; fix back and write out anyways.
.80e6	e9 80		sbc #$80			sbc 	#$80
.80e8	20 1b 81	jsr $811b			jsr 	AssemblerWriteByte
.80eb	e0 00		cpx #$00			cpx 	#0 							; was it in range
.80ed	f0 0a		beq $80f9			beq 	_AG3Exit
.80ef	ad a0 04	lda $04a0			lda 	AssemblerControl 			; are we allowing bad values ?
.80f2	29 01		and #$01			and 	#1
.80f4	f0 03		beq $80f9			beq 	_AG3Exit
.80f6	4c b7 9f	jmp $9fb7			jmp 	RangeError 					; no, branch is out of range
.80f9					_AG3Exit:
.80f9	60		rts				rts
.80fa					AssembleGroup4:
.80fa	68		pla				pla 								; pop address
.80fb	fa		plx				plx
.80fc	20 03 81	jsr $8103			jsr 	AccessParameters 			; access and get first
.80ff	20 1b 81	jsr $811b			jsr 	AssemblerWriteByte 			; output it.
.8102	60		rts				rts
.8103					AccessParameters:
.8103	8d a1 04	sta $04a1			sta 	ParamStart
.8106	8e a2 04	stx $04a2			stx 	ParamStart+1
.8109	a9 01		lda #$01			lda 	#1
.810b					GetParameter:
.810b	5a		phy				phy
.810c	a8		tay				tay
.810d	ad a1 04	lda $04a1			lda 	ParamStart
.8110	85 36		sta $36				sta 	zTemp0
.8112	ad a2 04	lda $04a2			lda 	ParamStart+1
.8115	85 37		sta $37				sta 	zTemp0+1
.8117	b1 36		lda ($36),y			lda 	(zTemp0),y
.8119	7a		ply				ply
.811a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/aswrite.asm

.811b					AssemblerWriteByte:
.811b	48		pha			pha
.811c	ad a0 04	lda $04a0		lda 	AssemblerControl 				; check printing bytes ?
.811f	29 02		and #$02		and 	#2
.8121	f0 1b		beq $813e		beq 	_AWBNoPrint
.8123	ad 9f 04	lda $049f		lda		AssemblerAddress+1 				; print address
.8126	20 59 81	jsr $8159		jsr 	PrintHex
.8129	ad 9e 04	lda $049e		lda		AssemblerAddress
.812c	20 59 81	jsr $8159		jsr 	PrintHex
.812f	a9 20		lda #$20		lda 	#' '
.8131	20 de a7	jsr $a7de		jsr 	EXTPrintCharacter
.8134	68		pla			pla 									; print byte
.8135	48		pha			pha
.8136	20 59 81	jsr $8159		jsr 	PrintHex
.8139	a9 0d		lda #$0d		lda 	#13
.813b	20 de a7	jsr $a7de		jsr 	EXTPrintCharacter
.813e					_AWBNoPrint:
.813e	ad 9e 04	lda $049e		lda		AssemblerAddress				; copy address to zTemp0
.8141	85 36		sta $36			sta 	zTemp0
.8143	ad 9f 04	lda $049f		lda		AssemblerAddress+1
.8146	f0 0e		beq $8156		beq 	_AWBRange
.8148	85 37		sta $37			sta 	zTemp0+1
.814a	68		pla			pla 									; write byte out
.814b	92 36		sta ($36)		sta 	(zTemp0)
.814d	ee 9e 04	inc $049e		inc 	AssemblerAddress 				; bump address
.8150	d0 03		bne $8155		bne 	_AWBNoCarry
.8152	ee 9f 04	inc $049f		inc 	AssemblerAddress+1
.8155					_AWBNoCarry:
.8155	60		rts			rts
.8156					_AWBRange:
.8156	4c b7 9f	jmp $9fb7		jmp 	RangeError
.8159					PrintHex:
.8159	48		pha				pha
.815a	4a		lsr a				lsr 	a
.815b	4a		lsr a				lsr 	a
.815c	4a		lsr a				lsr 	a
.815d	4a		lsr a				lsr 	a
.815e	20 62 81	jsr $8162			jsr 	_PrintNibble
.8161	68		pla				pla
.8162					_PrintNibble:
.8162	29 0f		and #$0f			and 	#15
.8164	c9 0a		cmp #$0a			cmp 	#10
.8166	90 02		bcc $816a			bcc 	_NoShift
.8168	69 06		adc #$06			adc 	#6
.816a					_NoShift:
.816a	69 30		adc #$30			adc 	#48
.816c	4c de a7	jmp $a7de			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/instruction.asm

.816f					AssembleModeX:
.816f	5a		phy				phy
.8170	ad a3 04	lda $04a3			lda 	IsGroup1
.8173	f0 17		beq $818c			beq 	_AMXGroup2
.8175	8a		txa				txa 							; is it in group # 1
.8176	29 40		and #$40			and 	#AM_ISG1
.8178	f0 50		beq $81ca			beq 	_AMXFail 				; no, give up.
.817a	8a		txa				txa 							; get back.
.817b	29 1f		and #$1f			and 	#$1F 					; this is now the offset.
.817d	e0 e0		cpx #$e0			cpx 	#AM_IMMEDIATE 			; if not immediate, we can continue.
.817f	d0 22		bne $81a3			bne 	_AMXHaveInfo
.8181	ad a4 04	lda $04a4			lda 	BaseOpcode 				; cannot store immediate.
.8184	c9 81		cmp #$81			cmp 	#$81
.8186	f0 42		beq $81ca			beq 	_AMXFail
.8188	a9 08		lda #$08			lda 	#8 						; if immediate we use offset 8.
.818a	80 17		bra $81a3			bra 	_AMXHaveInfo 			; odd design decision there.
.818c					_AMXGroup2:
.818c	8a		txa				txa 							; is it in group 2 ?
.818d	29 20		and #$20			and 	#AM_ISG2
.818f	f0 39		beq $81ca			beq 	_AMXFail 				; no, give up.
.8191	8a		txa				txa 							; get the offset into Y
.8192	29 1f		and #$1f			and 	#$1F
.8194	4a		lsr a				lsr 	a 						; make it 0-7.
.8195	4a		lsr a				lsr  	a
.8196	a8		tay				tay
.8197	ad a5 04	lda $04a5			lda 	ModeMask 				; shift the modemask left so you can check it against the requested offset
.819a					_AMXCheckOkay:
.819a	0a		asl a				asl 	a 						; shift modemask left enough times to check legitimate.
.819b	88		dey				dey
.819c	10 fc		bpl $819a			bpl 	_AMXCheckOkay
.819e	90 2a		bcc $81ca			bcc 	_AMXFail 				; not allowed.
.81a0	8a		txa				txa  							; get mask back
.81a1	29 1f		and #$1f			and 	#$1F
.81a3					_AMXHaveInfo:
.81a3	e0 00		cpx #$00			cpx 	#$00 					; does it *require* an 8 bit operand
.81a5	10 05		bpl $81ac			bpl 	_AMXAnySize 			; checking bit 7, the zero page opcode flag.
.81a7	ac 10 04	ldy $0410			ldy 	NSMantissa1 			; fail if it is outside range, e.g. the MSB is set.
.81aa	d0 1e		bne $81ca			bne 	_AMXFail
.81ac					_AMXAnySize:
.81ac	18		clc				clc 							; add offset to the base opcode
.81ad	6d a4 04	adc $04a4			adc 	BaseOpcode
.81b0					_AMXOutputCode:
.81b0	20 1b 81	jsr $811b			jsr 	AssemblerWriteByte 		; write the opcode out.
.81b3	e0 28		cpx #$28			cpx 	#AM_ACC 				; A mode (e.g. ASL A)
.81b5	f0 10		beq $81c7			beq 	_AMXExit
.81b7	ad 08 04	lda $0408			lda 	NSMantissa0 				; write LSB operand
.81ba	20 1b 81	jsr $811b			jsr 	AssemblerWriteByte
.81bd	e0 00		cpx #$00			cpx 	#$00 					; zeropage ?
.81bf	30 06		bmi $81c7			bmi 	_AMXExit
.81c1	ad 10 04	lda $0410			lda 	NSMantissa1 			; write MSB operand
.81c4	20 1b 81	jsr $811b			jsr 	AssemblerWriteByte
.81c7					_AMXExit:
.81c7	7a		ply				ply
.81c8	38		sec				sec
.81c9	60		rts				rts
.81ca					_AMXFail:
.81ca	a0 00		ldy #$00			ldy 	#0
.81cc					_AMXCheckOddities:
.81cc	8a		txa				txa
.81cd	d9 f5 81	cmp $81f5,y			cmp 	ExtraOpcode+2,y 		; match address mode
.81d0	d0 16		bne $81e8			bne 	_AMXCONext
.81d2	b9 f3 81	lda $81f3,y			lda 	ExtraOpcode+0,y 		; do the base opcodes match
.81d5	cd a4 04	cmp $04a4			cmp 	BaseOpcode
.81d8	d0 0e		bne $81e8			bne 	_AMXCONext
.81da	e0 00		cpx #$00			cpx 	#$00 					; requires zero page ?
.81dc	10 05		bpl $81e3			bpl 	_AMXCONotZero
.81de	ad 10 04	lda $0410			lda 	NSMantissa1
.81e1	d0 05		bne $81e8			bne 	_AMXCONext
.81e3					_AMXCONotZero:
.81e3	b9 f4 81	lda $81f4,y			lda 	ExtraOpcode+1,y 		; get new opcode
.81e6	80 c8		bra $81b0			bra 	_AMXOutputCode 			; and assemble it
.81e8					_AMXCONext:
.81e8	c8		iny				iny
.81e9	c8		iny				iny
.81ea	c8		iny				iny
.81eb	b9 f3 81	lda $81f3,y			lda 	ExtraOpcode+0,y 		; end of table
.81ee	d0 dc		bne $81cc			bne 	_AMXCheckOddities
.81f0					_AMXCOFail:
.81f0	7a		ply				ply
.81f1	18		clc				clc
.81f2	60		rts				rts
.81f3					ExtraOpcode:
>81f3	40 6c 01					.byte $40,$6c,AM_INDABS 	; jmp
>81f6	40 7c 02					.byte $40,$7C,AM_INDABSX 	; jmp
>81f9	a2 be 78					.byte $a2,$BE,AM_ABSY 		; ldx
>81fc	a2 b6 80					.byte $a2,$B6,AM_ZEROY 		; ldx
>81ff	82 96 80					.byte $82,$96,AM_ZEROY 		; stx
>8202	e2 1a 28					.byte $e2,$1a,AM_ACC 		; inc
>8205	c2 3a 28					.byte $c2,$3a,AM_ACC 		; dec
>8208	20 89 e0					.byte $20,$89,AM_IMMEDIATE 	; bit
>820b	60 9c 6c					.byte $60,$9c,AM_ABS 		; stz
>820e	60 9e 7c					.byte $60,$9e,AM_ABSX 		; stz
>8211	00						.byte $00

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/label.asm

.8212					LabelHere:
.8212	c8		iny				iny 								; skip .
.8213	a2 00		ldx #$00			ldx 	#0 							; get a term
.8215	20 ee 97	jsr $97ee			jsr 	EvaluateTerm 				; get a term
.8218	ad 00 04	lda $0400			lda 	NSStatus 					; needs to be an integer reference.
.821b	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.821d	d0 24		bne $8243			bne 	_ALType
.821f	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy reference address to zTemp0
.8222	85 36		sta $36				sta 	zTemp0
.8224	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.8227	85 37		sta $37				sta 	zTemp0+1
.8229	5a		phy				phy 								; copy address in.
.822a	a0 01		ldy #$01			ldy 	#1
.822c	ad 9e 04	lda $049e			lda	 	AssemblerAddress
.822f	92 36		sta ($36)			sta 	(zTemp0)
.8231	ad 9f 04	lda $049f			lda	 	AssemblerAddress+1
.8234	91 36		sta ($36),y			sta 	(zTemp0),y
.8236	c8		iny				iny
.8237	a9 00		lda #$00			lda 	#0
.8239	91 36		sta ($36),y			sta 	(zTemp0),y
.823b	c8		iny				iny
.823c	91 36		sta ($36),y			sta 	(zTemp0),y
.823e	c8		iny				iny
.823f	91 36		sta ($36),y			sta 	(zTemp0),y
.8241	7a		ply				ply
.8242	60		rts				rts
.8243					_ALType:
.8243	4c bc 9f	jmp $9fbc			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/operands.asm

.8246					TypeAndCalculateOperand:
.8246	b1 30		lda ($30),y			lda 	(codePtr),y
.8248	a2 28		ldx #$28			ldx 	#AM_ACC 					; ACC if : or EOL
.824a	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.824c	f0 5b		beq $82a9			beq 	_TACOExit
.824e	c9 80		cmp #$80			cmp 	#KWC_EOL
.8250	f0 57		beq $82a9			beq 	_TACOExit
.8252	c8		iny				iny
.8253	a2 e0		ldx #$e0			ldx 	#AM_IMMEDIATE
.8255	c9 23		cmp #$23			cmp 	#KWD_HASH 					; if hash, then immediate - constant.
.8257	f0 51		beq $82aa			beq 	CalculateOperand
.8259	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; if ( then check for indirection
.825b	f0 1f		beq $827c			beq 	_TACOIndirect
.825d	88		dey				dey 								; undo get of first character
.825e	20 aa 82	jsr $82aa			jsr 	CalculateOperand 			; get operand
.8261	b1 30		lda ($30),y			lda 	(codePtr),y
.8263	a2 e4		ldx #$e4			ldx 	#AM_ZEROPAGE 				; if not, try zero page (then absolute)
.8265	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8267	d0 40		bne $82a9			bne 	_TACOExit
.8269	c8		iny				iny
.826a	20 b4 82	jsr $82b4			jsr 	TACOCheckXY 				; extract X,Y or 0 (neither) from the variable.
.826d	a2 f4		ldx #$f4			ldx 	#AM_ZEROX 					; check for X
.826f	c9 58		cmp #$58			cmp 	#'X'
.8271	f0 36		beq $82a9			beq 	_TACOExit
.8273	a2 80		ldx #$80			ldx 	#AM_ZEROY 					; check for Y
.8275	c9 59		cmp #$59			cmp 	#'Y'
.8277	f0 30		beq $82a9			beq 	_TACOExit
.8279					_TACOSyntax:
.8279	4c b2 9f	jmp $9fb2			jmp 	SyntaxError
.827c					_TACOIndirect:
.827c	20 aa 82	jsr $82aa			jsr 	CalculateOperand 			; get the operand
.827f	b1 30		lda ($30),y			lda 	(codePtr),y
.8281	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if , then it must be ,X)
.8283	f0 17		beq $829c			beq 	_TACOIndX
.8285	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket  			; otherwise must be ) or ),Y
.8288	b1 30		lda ($30),y			lda 	(codePtr),y
.828a	a2 d1		ldx #$d1			ldx 	#AM_IND
.828c	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not comma then exit with (xx)
.828e	d0 19		bne $82a9			bne 	_TACOExit
.8290	c8		iny				iny
.8291	20 b4 82	jsr $82b4			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.8294	c9 59		cmp #$59			cmp 	#'Y' 						; check Y
.8296	d0 e1		bne $8279			bne 	_TACOSyntax
.8298	a2 d0		ldx #$d0			ldx 	#AM_INDY
.829a	80 0d		bra $82a9			bra 	_TACOExit
.829c					_TACOIndX:
.829c	c8		iny				iny
.829d	20 b4 82	jsr $82b4			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.82a0	c9 58		cmp #$58			cmp 	#'X' 						; check X
.82a2	d0 d5		bne $8279			bne 	_TACOSyntax
.82a4	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket			; check )
.82a7	a2 c0		ldx #$c0			ldx 	#AM_INDX
.82a9					_TACOExit:
.82a9	60		rts				rts
.82aa					CalculateOperand:
.82aa	48		pha				pha
.82ab	da		phx				phx
.82ac	a2 00		ldx #$00			ldx 	#0 							; get 16 bit integer in Slot 0
.82ae	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger
.82b1	fa		plx				plx
.82b2	68		pla				pla
.82b3	60		rts				rts
.82b4					TACOCheckXY:
.82b4	b1 30		lda ($30),y			lda 	(codePtr),y
.82b6	29 c0		and #$c0			and 	#$C0 						; check it is an identifier reference.
.82b8	c9 40		cmp #$40			cmp 	#$40
.82ba	d0 21		bne $82dd			bne 	_TCXYFail
.82bc	b1 30		lda ($30),y			lda 	(codePtr),y
.82be	18		clc				clc
.82bf	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.82c1	85 37		sta $37				sta 	zTemp0+1
.82c3	c8		iny				iny
.82c4	b1 30		lda ($30),y			lda 	(codePtr),y
.82c6	c8		iny				iny
.82c7	85 36		sta $36				sta 	zTemp0
.82c9	5a		phy				phy 								; save position
.82ca	a0 02		ldy #$02			ldy 	#2 							; type is integer ?
.82cc	b1 36		lda ($36),y			lda 	(zTemp0),y
.82ce	d0 0c		bne $82dc			bne 	_TCXYPopFail
.82d0	a0 08		ldy #$08			ldy 	#8 							; get first character, should have bit 7 set as also last.
.82d2	b1 36		lda ($36),y			lda 	(zTemp0),y
.82d4	c9 d8		cmp #$d8			cmp 	#'X'+$80 					; should be X or Y
.82d6	f0 08		beq $82e0			beq 	_TCXYFound
.82d8	c9 d9		cmp #$d9			cmp 	#'Y'+$80
.82da	f0 04		beq $82e0			beq 	_TCXYFound
.82dc					_TCXYPopFail:
.82dc	7a		ply				ply
.82dd					_TCXYFail:
.82dd	a9 00		lda #$00			lda 	#0
.82df	60		rts				rts
.82e0					_TCXYFound:
.82e0	7a		ply				ply 								; restore position
.82e1	29 7f		and #$7f			and 	#$7F 						; throw bit 7
.82e3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/backload.asm

.82e4					BackloadProgram:
.82e4	a9 00		lda #$00			lda 	#((SOURCE_ADDRESS) & $FF)
.82e6	8d 2b 06	sta $062b			sta 	0+BackLoadPointer
.82e9	a9 30		lda #$30			lda 	#((SOURCE_ADDRESS) >> 8)
.82eb	8d 2c 06	sta $062c			sta 	1+BackLoadPointer
.82ee					_BPLoop:
.82ee	a2 ff		ldx #$ff			ldx 	#$FF
.82f0	20 18 83	jsr $8318			jsr 	BLReadByte
.82f3	30 1f		bmi $8314			bmi 	_BPExit
.82f5					_BPCopy:
.82f5	e8		inx				inx  								; copy byte in
.82f6	9d a8 05	sta $05a8,x			sta 	lineBuffer,x
.82f9	9e a9 05	stz $05a9,x			stz 	lineBuffer+1,x
.82fc	20 18 83	jsr $8318			jsr 	BLReadByte 					; read next byte
.82ff	30 0a		bmi $830b			bmi 	_BPEndLine 					; -ve = EOL
.8301	c9 09		cmp #$09			cmp 	#9 							; handle TAB
.8303	d0 02		bne $8307			bne 	_BPNotTab
.8305	a9 20		lda #$20			lda 	#' '
.8307					_BPNotTab:
.8307	c9 20		cmp #$20			cmp 	#' ' 						; < ' ' = EOL
.8309	b0 ea		bcs $82f5			bcs 	_BPCopy
.830b					_BPEndLine:
.830b	20 fc b5	jsr $b5fc			jsr 	TokeniseLine 				; tokenise the line.
.830e	38		sec				sec 								; append not insert
.830f	20 1a a5	jsr $a51a			jsr 	MemoryInsertLine 			; append to current program
.8312	80 da		bra $82ee			bra 	_BPLoop
.8314					_BPExit:
.8314	20 ed 83	jsr $83ed			jsr 	ClearCommand 				; clear variables etc.
.8317	60		rts				rts
.8318					BLReadByte:
.8318	ad 2b 06	lda $062b			lda 	BackLoadPointer
.831b	85 36		sta $36				sta 	zTemp0
.831d	ad 2c 06	lda $062c			lda 	BackLoadPointer+1
.8320	85 37		sta $37				sta 	zTemp0+1
.8322	b2 36		lda ($36)			lda 	(zTemp0)
.8324	ee 2b 06	inc $062b			inc 	BackLoadPointer
.8327	d0 03		bne $832c			bne 	_BLNoCarry
.8329	ee 2c 06	inc $062c			inc 	BackLoadPointer+1
.832c					_BLNoCarry:
.832c	c9 00		cmp #$00			cmp 	#0
.832e	60		rts				rts
.062b					BackLoadPointer:
>062b							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/editor.asm

.832f					EditProgramCode:
.832f	ad a9 04	lda $04a9			lda 	TokenLineNumber 			; find the line.
.8332	ae aa 04	ldx $04aa			ldx 	TokenLineNumber+1
.8335	20 c2 a5	jsr $a5c2			jsr 	MemorySearch
.8338	90 05		bcc $833f			bcc 	_EPCNoDelete 				; reached the end don't delete
.833a	d0 03		bne $833f			bne 	_EPCNoDelete 				; found slot but didn't match, no delete
.833c	20 e3 a4	jsr $a4e3			jsr 	MemoryDeleteLine 			; delete the line
.833f					_EPCNoDelete:
.833f	ad ab 04	lda $04ab			lda 	TokenBuffer 				; buffer empty
.8342	c9 80		cmp #$80			cmp 	#KWC_EOL
.8344	f0 0d		beq $8353			beq 	_EPCNoInsert
.8346	ad a9 04	lda $04a9			lda 	TokenLineNumber 			; find the line - it cannot exist.
.8349	ae aa 04	ldx $04aa			ldx 	TokenLineNumber+1 			; so this can't fail, it returns some point in the code.
.834c	20 c2 a5	jsr $a5c2			jsr 	MemorySearch
.834f	18		clc				clc 								; insert at this point.
.8350	20 1a a5	jsr $a51a			jsr 	MemoryInsertLine 			; insert the line
.8353					_EPCNoInsert:
.8353	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/warmstart.asm

.8354					WarmStart:
.8354	a2 ff		ldx #$ff			ldx 	#$FF
.8356	9a		txs				txs
.8357	20 6c a9	jsr $a96c			jsr 	EXTInputLine 				; get line to lineBuffer
.835a	20 fc b5	jsr $b5fc			jsr 	TokeniseLine 				; tokenise the line
.835d	ad a9 04	lda $04a9			lda 	TokenLineNumber 			; line number ?
.8360	0d aa 04	ora $04aa			ora 	TokenLineNumber+1
.8363	d0 17		bne $837c			bne 	_WSEditCode 				; if so,edit code.
.8365	9c a8 04	stz $04a8			stz 	TokenOffset 				; zero offset, meaning it only runs one line.
.8368	a9 a8		lda #$a8			lda 	#((TokenOffset) & $FF)
.836a	85 30		sta $30				sta 	codePtr
.836c	a9 04		lda #$04			lda 	#((TokenOffset) >> 8)
.836e	85 31		sta $31				sta 	codePtr+1
.8370	ad ab 04	lda $04ab			lda 	TokenBuffer 				; nothing to run
.8373	c9 80		cmp #$80			cmp 	#KWC_EOL
.8375	f0 dd		beq $8354			beq 	WarmStart
.8377	20 0d 8a	jsr $8a0d			jsr 	RUNCodePointerLine 			; execute that line.
.837a	80 d8		bra $8354			bra 	WarmStart
.837c					_WSEditCode:
.837c	20 2f 83	jsr $832f			jsr 	EditProgramCode
.837f	20 ed 83	jsr $83ed			jsr 	ClearCommand
.8382	80 d0		bra $8354			bra 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assemble.asm

.8384					AssembleCommand:
.8384	a2 00		ldx #$00			ldx 	#0
.8386	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger 		; start address
.8389	ad 08 04	lda $0408			lda 	NSMantissa0
.838c	8d 9e 04	sta $049e			sta 	AssemblerAddress
.838f	ad 10 04	lda $0410			lda 	NSMantissa1
.8392	8d 9f 04	sta $049f			sta 	AssemblerAddress+1
.8395	20 54 8d	jsr $8d54			jsr 	CheckComma
.8398	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; options
.839b	ad 08 04	lda $0408			lda 	NSMantissa0
.839e	8d a0 04	sta $04a0			sta 	AssemblerControl
.83a1	60		rts				rts
.83a2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assert.asm

.83a3					AssertCommand:
.83a3	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.83a5	20 74 9d	jsr $9d74			jsr 	EvaluateInteger 			; the assert test
.83a8	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; exit if result is non zero.
.83ab	d0 05		bne $83b2			bne 	_ACExit
.83ad	a9 0a		lda #$0a		lda	#10
.83af	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.83b2					_ACExit:
.83b2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/call.asm

.83b3					CallCommand:
.83b3	a2 00		ldx #$00			ldx 	#0
.83b5	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger
.83b8					_CCClear
.83b8	e8		inx				inx  								; clear 1,2 and 3 (for A X Y)
.83b9	20 28 9e	jsr $9e28			jsr 	NSMSetZero
.83bc	e0 04		cpx #$04			cpx 	#4
.83be	d0 f8		bne $83b8			bne 	_CCClear
.83c0	a2 00		ldx #$00			ldx 	#0 							; and keep trying
.83c2					_CCCParam:
.83c2	b1 30		lda ($30),y			lda 	(codePtr),y
.83c4	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.83c6	d0 09		bne $83d1			bne 	_CCCRun6502
.83c8	c8		iny				iny 								; skip comma
.83c9	e8		inx				inx	 								; next level
.83ca	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; get A/X/Y
.83cd	e0 03		cpx #$03			cpx 	#3
.83cf	90 f1		bcc $83c2			bcc 	_CCCParam 					; done all 3 ?
.83d1					_CCCRun6502:
.83d1	5a		phy				phy 								; save position
.83d2	ad 10 04	lda $0410			lda 	NSMantissa1 				; put address in zTemp0
.83d5	85 37		sta $37				sta 	zTemp0+1
.83d7	ad 08 04	lda $0408			lda 	NSMantissa0
.83da	85 36		sta $36				sta 	zTemp0
.83dc	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; get registers
.83df	ae 0a 04	ldx $040a			ldx 	NSMantissa0+2
.83e2	ac 0b 04	ldy $040b			ldy 	NSMantissa0+3
.83e5	20 ea 83	jsr $83ea			jsr 	_CCCZTemp0 					; call zTemp0
.83e8	7a		ply				ply 								; restore position and exit
.83e9	60		rts				rts
.83ea					_CCCZTemp0:
.83ea	6c 36 00	jmp ($0036)			jmp 	(zTemp0)

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/clear.asm

.83ed					ClearCommand:
.83ed	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.83ef	85 36		sta $36				sta 	0+zTemp0
.83f1	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.83f3	85 37		sta $37				sta 	1+zTemp0
.83f5					_ClearZeroLoop:
.83f5	b2 36		lda ($36)			lda 	(zTemp0) 					; end of variables
.83f7	f0 24		beq $841d			beq 	_ClearZeroEnd
.83f9	a0 03		ldy #$03			ldy 	#3 							; erase the variables
.83fb	a9 00		lda #$00			lda 	#0
.83fd					_ClearOneVariable:
.83fd	91 36		sta ($36),y			sta 	(zTemp0),y
.83ff	c8		iny				iny
.8400	c0 08		cpy #$08			cpy 	#8
.8402	d0 f9		bne $83fd			bne 	_ClearOneVariable
.8404	a0 02		ldy #$02			ldy 	#2 							; has it been marked procedure
.8406	b1 36		lda ($36),y			lda 	(zTemp0),y
.8408	c9 18		cmp #$18			cmp 	#NSTProcedure
.840a	d0 04		bne $8410			bne 	_ClearNotProcedure
.840c	a9 04		lda #$04			lda 	#NSTInteger+NSBIsArray 		; set it back to an integer array
.840e	91 36		sta ($36),y			sta 	(zTemp0),y
.8410					_ClearNotProcedure:
.8410	18		clc				clc 								; go to the next variable
.8411	b2 36		lda ($36)			lda 	(zTemp0)
.8413	65 36		adc $36				adc 	zTemp0
.8415	85 36		sta $36				sta 	zTemp0
.8417	90 dc		bcc $83f5			bcc 	_ClearZeroLoop
.8419	e6 37		inc $37				inc 	zTemp0+1
.841b	80 d8		bra $83f5			bra 	_ClearZeroLoop
.841d					_ClearZeroEnd:
.841d	18		clc				clc
.841e	a5 36		lda $36				lda 	zTemp0
.8420	69 01		adc #$01			adc 	#1
.8422	8d 8c 04	sta $048c			sta 	lowMemPtr
.8425	a5 37		lda $37				lda 	zTemp0+1
.8427	69 00		adc #$00			adc 	#0
.8429	8d 8d 04	sta $048d			sta 	lowMemPtr+1
.842c	20 03 a7	jsr $a703			jsr 	StackReset
.842f	20 6d a7	jsr $a76d			jsr 	StringSystemInitialise
.8432	20 55 8c	jsr $8c55			jsr 	ProcedureScan
.8435	20 bc 89	jsr $89bc			jsr 	Command_Restore
.8438	9c 9e 04	stz $049e			stz 	AssemblerAddress
.843b	9c 9f 04	stz $049f			stz 	AssemblerAddress+1
.843e	9c a0 04	stz $04a0			stz 	AssemblerControl
.8441	20 f1 99	jsr $99f1			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.8444	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/cls.asm

.8445					ClearScreen:
.8445	5a		phy				phy
.8446	a9 0c		lda #$0c			lda 	#12 						; char code 12 clears the screen.
.8448	20 de a7	jsr $a7de			jsr 	EXTPrintCharacter
.844b	7a		ply				ply
.844c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/data.asm

.844d					Command_Data:
.844d	a9 3a		lda #$3a			lda 	#KWD_COLON 					; advance to colon/EOL
.844f	a2 80		ldx #$80			ldx 	#KWC_EOL
.8451	20 a7 8c	jsr $8ca7			jsr 	ScanForward
.8454	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dim.asm

.8455					DimCommand:
.8455	b1 30		lda ($30),y			lda 	(codePtr),y
.8457	29 c0		and #$c0			and 	#$C0
.8459	c9 40		cmp #$40			cmp 	#$40
.845b	d0 7a		bne $84d7			bne 	_DCSyntax
.845d	b1 30		lda ($30),y			lda 	(codePtr),y
.845f	18		clc				clc
.8460	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8462	85 3f		sta $3f				sta 	zaTemp+1
.8464	c8		iny				iny
.8465	b1 30		lda ($30),y			lda 	(codePtr),y
.8467	c8		iny				iny
.8468	85 3e		sta $3e				sta 	zaTemp
.846a	5a		phy				phy
.846b	a0 02		ldy #$02			ldy 	#2 						; read type byte
.846d	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.846f	29 18		and #$18			and 	#NSBTypeMask 			; check it's not a procedure
.8471	c9 18		cmp #$18			cmp 	#NSTProcedure
.8473	f0 62		beq $84d7			beq 	_DCSyntax
.8475	b1 3e		lda ($3e),y			lda 	(zaTemp),y 				; check it's an array
.8477	29 04		and #$04			and 	#NSBIsArray
.8479	f0 64		beq $84df			beq 	_DCType
.847b	a0 04		ldy #$04			ldy 	#4 						; check not already defined
.847d	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.847f	d0 59		bne $84da			bne 	_DCRedefine
.8481	7a		ply				ply
.8482	20 e2 84	jsr $84e2			jsr 	_DCGetSize 				; get array size, check it.
.8485	5a		phy				phy
.8486	a0 05		ldy #$05			ldy 	#5 						; store in first array size slot
.8488	91 3e		sta ($3e),y			sta 	(zaTemp),y 				; second will be zero.
.848a	7a		ply				ply 							; is there a second (e.g. ,x)
.848b	b1 30		lda ($30),y			lda 	(codePtr),y
.848d	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.848f	d0 0a		bne $849b			bne 	_DCOneDimension
.8491	c8		iny				iny 							; skip comma
.8492	20 e2 84	jsr $84e2			jsr 	_DCGetSize 				; get 2nd array size
.8495	5a		phy				phy
.8496	a0 06		ldy #$06			ldy 	#6 						; store in 2nd array size
.8498	91 3e		sta ($3e),y			sta 	(zaTemp),y
.849a	7a		ply				ply
.849b					_DCOneDimension:
.849b	5a		phy				phy 							; save position
.849c	a0 05		ldy #$05			ldy 	#5 						; dimensions + 1 in AX (as zero based)
.849e	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84a0	aa		tax				tax
.84a1	c8		iny				iny
.84a2	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84a4	e8		inx				inx 							; bump them.
.84a5	1a		inc a				inc 	a
.84a6	20 bd 9d	jsr $9dbd			jsr 	Multiply8x8 			; work out the total number of elements -> zTemp0
.84a9	a5 37		lda $37				lda 	zTemp0+1 				; don't allow more than 8192 elements whatever
.84ab	29 e0		and #$e0			and 	#$E0
.84ad	d0 23		bne $84d2			bne 	_DCSize
.84af	a0 02		ldy #$02			ldy 	#2 						; get base type
.84b1	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84b3	20 f0 84	jsr $84f0			jsr 	ScaleByBaseType 		; scale by base type
.84b6	a5 36		lda $36				lda 	zTemp0
.84b8	a6 37		ldx $37				ldx 	zTemp0+1
.84ba	20 b3 99	jsr $99b3			jsr 	AllocateXABytes 		; allocate memory
.84bd	a0 03		ldy #$03			ldy 	#3 						; copy into the address.
.84bf	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84c1	c8		iny				iny
.84c2	8a		txa				txa
.84c3	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84c5	7a		ply				ply 							; get position back
.84c6	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket 		; check )
.84c9	b1 30		lda ($30),y			lda 	(codePtr),y
.84cb	c8		iny				iny 							; consume in case
.84cc	c9 2c		cmp #$2c			cmp 	#KWD_COMMA		 		; if so do another DIM.
.84ce	f0 85		beq $8455			beq 	DimCommand
.84d0	88		dey				dey 							; undo consume
.84d1	60		rts				rts
.84d2					_DCSize:
.84d2	a9 16		lda #$16		lda	#22
.84d4	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.84d7					_DCSyntax:
.84d7	4c b2 9f	jmp $9fb2			jmp 	SyntaxError
.84da					_DCRedefine:
.84da	a9 15		lda #$15		lda	#21
.84dc	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.84df					_DCType:
.84df	4c bc 9f	jmp $9fbc			jmp 	TypeError
.84e2					_DCGetSize:
.84e2	a2 00		ldx #$00			ldx 	#0 						; get first index.
.84e4	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 	; get array dimension
.84e7	c9 00		cmp #$00			cmp 	#0 						; must be 1-254
.84e9	f0 e7		beq $84d2			beq 	_DCSize
.84eb	c9 fe		cmp #$fe			cmp 	#254
.84ed	f0 e3		beq $84d2			beq 	_DCSize
.84ef	60		rts				rts
.84f0					ScaleByBaseType:
.84f0	29 10		and #$10			and 	#NSBIsString 			; is it string
.84f2	d0 19		bne $850d			bne 	_SBBTString
.84f4	a5 37		lda $37				lda 	zTemp0+1 				; push value on stack
.84f6	48		pha				pha
.84f7	a5 36		lda $36				lda 	zTemp0
.84f9	48		pha				pha
.84fa	06 36		asl $36				asl 	zTemp0 					; x 2
.84fc	26 37		rol $37				rol 	zTemp0+1
.84fe	06 36		asl $36				asl 	zTemp0 					; x 4
.8500	26 37		rol $37				rol 	zTemp0+1
.8502	68		pla				pla 							; add stacked value = x 5
.8503	65 36		adc $36				adc 	zTemp0
.8505	85 36		sta $36				sta 	zTemp0
.8507	68		pla				pla
.8508	65 37		adc $37				adc 	zTemp0+1
.850a	85 37		sta $37				sta 	zTemp0+1
.850c	60		rts				rts
.850d					_SBBTString:
.850d	06 36		asl $36				asl 	zTemp0
.850f	26 37		rol $37				rol 	zTemp0+1
.8511	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/end.asm

.8512					EndCommand:
.8512	4c 54 83	jmp $8354			jmp 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/for.asm

.8515					ForCommand:
.8515	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; allocate 18 bytes on the return stack.
.8517	20 9e a6	jsr $a69e			jsr 	StackOpen
.851a	a2 00		ldx #$00			ldx 	#0
.851c	20 ee 97	jsr $97ee			jsr 	EvaluateTerm
.851f	bd 00 04	lda $0400,x			lda 	NSStatus,x
.8522	c9 20		cmp #$20			cmp 	#NSBIsReference+NSTInteger 	; do we have an integer 4 byte reference.
.8524	d0 49		bne $856f			bne		_FCError
.8526	a9 3d		lda #$3d			lda 	#KWD_EQUAL 					; =
.8528	20 5c 8d	jsr $8d5c			jsr 	CheckNextA
.852b	e8		inx				inx
.852c	20 74 9d	jsr $9d74			jsr 	EvaluateInteger 			; <from> in +1
.852f	b1 30		lda ($30),y			lda 	(codePtr),y
.8531	c8		iny				iny 								; consume it
.8532	48		pha				pha 								; save on stack for later
.8533	c9 b4		cmp #$b4			cmp 	#KWD_DOWNTO
.8535	f0 04		beq $853b			beq 	_FCNoSyntax
.8537	c9 cd		cmp #$cd			cmp 	#KWD_TO
.8539	d0 37		bne $8572			bne 	_FCSyntaxError
.853b					_FCNoSyntax:
.853b	e8		inx				inx
.853c	20 74 9d	jsr $9d74			jsr 	EvaluateInteger
.853f	20 e2 a6	jsr $a6e2			jsr 	STKSaveCodePosition 		; save loop back position
.8542	68		pla				pla 								; restore DOWNTO or TO
.8543	5a		phy				phy 								; save Y on the stack
.8544	49 b4		eor #$b4			eor 	#KWD_DOWNTO 				; 0 if DOWNTO, #0 if TO
.8546	f0 02		beq $854a			beq 	_FCNotDownTo
.8548	a9 02		lda #$02			lda 	#2
.854a					_FCNotDownTo:
.854a	3a		dec a				dec 	a 							; 255 if DOWNTO, 1 if TO
.854b	a0 10		ldy #$10			ldy 	#16
.854d	91 34		sta ($34),y			sta 	(basicStack),y 				; copy that out to the Basic Stack.
.854f	a0 06		ldy #$06			ldy 	#6
.8551	ad 08 04	lda $0408			lda 	NSMantissa0
.8554	91 34		sta ($34),y			sta 	(basicStack),y
.8556	ad 10 04	lda $0410			lda 	NSMantissa1
.8559	c8		iny				iny
.855a	91 34		sta ($34),y			sta 	(basicStack),y
.855c	a0 08		ldy #$08			ldy 	#8 							; set initial index value
.855e	a2 01		ldx #$01			ldx 	#1
.8560	20 75 85	jsr $8575			jsr 	FCIntegerToStack
.8563	a0 0c		ldy #$0c			ldy 	#12 						; set the terminal value
.8565	a2 02		ldx #$02			ldx 	#2
.8567	20 75 85	jsr $8575			jsr 	FCIntegerToStack
.856a	20 95 85	jsr $8595			jsr 	CopyIndexToReference
.856d	7a		ply				ply 								; restore position
.856e	60		rts				rts
.856f					_FCError:
.856f	4c bc 9f	jmp $9fbc			jmp 	TypeError
.8572					_FCSyntaxError:
.8572	4c b2 9f	jmp $9fb2			jmp 	SyntaxError
.8575					FCIntegerToStack:
.8575	3c 00 04	bit $0400,x			bit 	NSStatus,x 					; is the value negative
.8578	10 03		bpl $857d			bpl	 	_FCNotNegative
.857a	20 dd 9d	jsr $9ddd			jsr 	NSMNegateMantissa 			; if so 2's complement the mantissa
.857d					_FCNotNegative:
.857d	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy out to the basic stack
.8580	91 34		sta ($34),y			sta 	(basicStack),y
.8582	c8		iny				iny
.8583	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.8586	91 34		sta ($34),y			sta 	(basicStack),y
.8588	c8		iny				iny
.8589	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.858c	91 34		sta ($34),y			sta 	(basicStack),y
.858e	c8		iny				iny
.858f	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.8592	91 34		sta ($34),y			sta 	(basicStack),y
.8594	60		rts				rts
.8595					CopyIndexToReference:
.8595	5a		phy				phy
.8596	a0 06		ldy #$06			ldy 	#6 							; copy address-8 to write to zTemp0
.8598	38		sec				sec 								; (because we copy from offset 8)
.8599	b1 34		lda ($34),y			lda 	(basicStack),y
.859b	e9 08		sbc #$08			sbc 	#8
.859d	85 36		sta $36				sta 	zTemp0
.859f	c8		iny				iny
.85a0	b1 34		lda ($34),y			lda 	(basicStack),y
.85a2	e9 00		sbc #$00			sbc 	#0
.85a4	85 37		sta $37				sta 	zTemp0+1
.85a6	a2 04		ldx #$04			ldx 	#4 							; this is the copy counter/
.85a8	a0 0b		ldy #$0b			ldy 	#8+3 		 				; the MSB of the mantissa
.85aa	b1 34		lda ($34),y			lda 	(basicStack),y
.85ac	0a		asl a				asl 	a 							; into carry
.85ad	a0 08		ldy #$08			ldy 	#8 							; where to copy from.
.85af	90 14		bcc $85c5			bcc 	_CITRNormal
.85b1	38		sec				sec
.85b2					_CITRNegative:
.85b2	a9 00		lda #$00			lda 	#0
.85b4	f1 34		sbc ($34),y			sbc 	(basicStack),y
.85b6	91 36		sta ($36),y			sta 	(zTemp0),y
.85b8	c8		iny				iny
.85b9	ca		dex				dex
.85ba	d0 f6		bne $85b2			bne 	_CITRNegative
.85bc	88		dey				dey 								; look at MSB of mantissa
.85bd	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set the MSB as negative packed.
.85bf	09 80		ora #$80			ora 	#$80
.85c1	91 36		sta ($36),y			sta 	(zTemp0),y
.85c3	7a		ply				ply
.85c4	60		rts				rts
.85c5					_CITRNormal:
.85c5	b1 34		lda ($34),y			lda 	(basicStack),y 				; copy without negation.
.85c7	91 36		sta ($36),y			sta 	(zTemp0),y
.85c9	c8		iny				iny
.85ca	ca		dex				dex
.85cb	d0 f8		bne $85c5			bne 	_CITRNormal
.85cd	7a		ply				ply 								; and exit.
.85ce	60		rts				rts
.85cf					NextCommand:
.85cf	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; check FOR is TOS
.85d1	a2 11		ldx #$11			ldx 	#ERRID_FOR 					; this error
.85d3	20 ca a6	jsr $a6ca			jsr 	StackCheckFrame
.85d6	5a		phy				phy
.85d7	a0 10		ldy #$10			ldy 	#16 						; get the step count
.85d9	b1 34		lda ($34),y			lda 	(basicStack),y
.85db	85 36		sta $36				sta 	zTemp0 						; this is the sign extend
.85dd	30 02		bmi $85e1			bmi 	_NCStepNeg
.85df	64 36		stz $36				stz 	zTemp0 						; which is 0 or 255
.85e1					_NCStepNeg:
.85e1	a0 08		ldy #$08			ldy 	#8 							; offset to bump
.85e3	a2 04		ldx #$04			ldx 	#4 							; count to bump
.85e5	18		clc				clc
.85e6					_NCBump:
.85e6	71 34		adc ($34),y			adc 	(basicStack),y 				; add it
.85e8	91 34		sta ($34),y			sta 	(basicStack),y
.85ea	a5 36		lda $36				lda 	zTemp0 						; get sign extend for next time.
.85ec	c8		iny				iny 								; next byte
.85ed	ca		dex				dex 								; do four times
.85ee	d0 f6		bne $85e6			bne 	_NCBump
.85f0	20 95 85	jsr $8595			jsr		CopyIndexToReference		; copy it to the reference variable.
.85f3	a0 10		ldy #$10			ldy 	#16 						; get step count again
.85f5	b1 34		lda ($34),y			lda 	(basicStack),y
.85f7	0a		asl a				asl 	a 							; sign bit to carry
.85f8	a9 0c		lda #$0c			lda 	#12 						; offset of LHS = terminal offset
.85fa	85 38		sta $38				sta 	zTemp1
.85fc	90 02		bcc $8600			bcc 	_NCCompRev 					; use if step is +ve
.85fe	a9 08		lda #$08			lda 	#8 							; now the LHS = index value
.8600					_NCCompRev:
.8600	85 38		sta $38				sta 	zTemp1 						; so zTemp0 is the index for LHS
.8602	49 04		eor #$04			eor 	#(8^12) 					; and zTemp0+1 is the index for RHS
.8604	85 39		sta $39				sta 	zTemp1+1
.8606	a2 04		ldx #$04			ldx 	#4 							; bytes to compare
.8608	38		sec				sec
.8609					_NCCompare:
.8609	a4 38		ldy $38				ldy 	zTemp1 						; do compare using the two indices
.860b	b1 34		lda ($34),y			lda 	(basicStack),y
.860d	a4 39		ldy $39				ldy 	zTemp1+1
.860f	f1 34		sbc ($34),y			sbc 	(basicStack),y
.8611	e6 38		inc $38				inc 	zTemp1 						; bump the indices (inc,dex do not change C or V)
.8613	e6 39		inc $39				inc 	zTemp1+1
.8615	ca		dex				dex 								; do it 4 times.
.8616	d0 f1		bne $8609			bne 	_NCCompare
.8618	50 02		bvc $861c			bvc 	_NCNoOverflow 				; convert to signed comparison
.861a	49 80		eor #$80			eor 	#$80
.861c					_NCNoOverflow:
.861c	7a		ply				ply 								; restore Y position
.861d	0a		asl a				asl 	a 							; is bit 7 set.
.861e	90 04		bcc $8624			bcc 	_NCLoopback 				; if no , >= so loop back
.8620	20 bc a6	jsr $a6bc			jsr 	StackClose 					; exit the loop
.8623	60		rts				rts
.8624					_NCLoopBack:
.8624	20 f3 a6	jsr $a6f3			jsr 	STKLoadCodePosition 		; loop back
.8627	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/gosub.asm

.8628					Command_GOSUB:
.8628	a2 00		ldx #$00			ldx 	#0
.862a	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger 		; line number in Stack.0
.862d	a9 e3		lda #$e3			lda 	#STK_GOSUB+3
.862f	20 9e a6	jsr $a69e			jsr 	StackOpen 					; create frame
.8632	20 e2 a6	jsr $a6e2			jsr 	STKSaveCodePosition 		; save current position
.8635	4c 4b 86	jmp $864b			jmp 	GotoStackX
.8638					Command_RETURN:
.8638	a9 e0		lda #$e0			lda 	#STK_GOSUB 					; check TOS is this
.863a	a2 0e		ldx #$0e			ldx 	#ERRID_GOSUB 				; this error
.863c	20 ca a6	jsr $a6ca			jsr 	StackCheckFrame
.863f	20 f3 a6	jsr $a6f3			jsr 	STKLoadCodePosition 		; restore code position
.8642	20 bc a6	jsr $a6bc			jsr 	StackClose
.8645	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/goto.asm

.8646					GotoCommand:
.8646	a2 00		ldx #$00			ldx 	#0 							; GOTO where
.8648	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger
.864b					GotoStackX:
.864b	bd 10 04	lda $0410,x			lda  	NSMantissa1,x 				; put line # in XA. I'll keep this even though
.864e	48		pha				pha 								; it is slightly inefficient, just in cases.
.864f	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.8652	fa		plx				plx
.8653	20 c2 a5	jsr $a5c2			jsr 	MemorySearch 				; transfer to line number AX.
.8656	90 05		bcc $865d			bcc 	_GotoError 					; not found, off end.
.8658	d0 03		bne $865d			bne 	_GotoError 					; not found exactly
.865a	4c 06 8a	jmp $8a06			jmp 	RunNewLine 					; and go straight to new line code.
.865d					_GotoError:
.865d	a9 0d		lda #$0d		lda	#13
.865f	4c 65 8d	jmp $8d65		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/if.asm

.8662					IfCommand:
.8662	a2 00		ldx #$00			ldx 	#0 							; If what.
.8664	20 51 9d	jsr $9d51			jsr 	EvaluateNumber
.8667	b1 30		lda ($30),y			lda 	(codePtr),y
.8669	c9 a8		cmp #$a8			cmp 	#KWD_THEN  					; could be THEN <stuff> or GOTO
.866b	d0 0a		bne $8677			bne 	_IFStructured
.866d	c8		iny				iny 								; consume THEN
.866e	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; is it zero
.8671	f0 01		beq $8674			beq 	_IfFail 					; if fail, go to next line
.8673	60		rts				rts 								; if THEN just continue
.8674					_IfFail:
.8674	4c ee 89	jmp $89ee			jmp 	EOLCommand
.8677					_IfStructured:
.8677	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; is it zero
.867a	d0 07		bne $8683			bne 	_IfExit 					; if not, then continue normally.
.867c	a9 b5		lda #$b5			lda 	#KWD_ELSE 					; look for else/endif
.867e	a2 a5		ldx #$a5			ldx 	#KWD_ENDIF
.8680	20 a7 8c	jsr $8ca7			jsr 	ScanForward 				; and run from there/
.8683					_IfExit:
.8683	60		rts				rts
.8684					ElseCode:
.8684	a9 a5		lda #$a5			lda 	#KWD_ENDIF 					; else is only run after the if clause succeeds
.8686	aa		tax				tax 								; so just go to the structure exit
.8687	20 a7 8c	jsr $8ca7			jsr 	ScanForward
.868a	60		rts				rts
.868b					EndIf:
.868b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/let.asm

.868c					LetCommand:
.868c	a2 00		ldx #$00			ldx 	#0
.868e	b1 30		lda ($30),y			lda 	(codePtr),y
.8690	c9 10		cmp #$10			cmp 	#KWD_AT
.8692	d0 16		bne $86aa			bne 	_LCStandard
.8694	c8		iny				iny 								; skip equal
.8695	20 ee 97	jsr $97ee			jsr 	EvaluateTerm 				; get a number
.8698	20 32 96	jsr $9632			jsr 	Dereference 				; dereference it
.869b	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check integer
.869e	49 20		eor #$20			eor 	#NSBIsReference	 			; toggle reference
.86a0	9d 00 04	sta $0400,x			sta 	NSStatus,x
.86a3	29 20		and #$20			and 	#NSBIsReference 			; if it is now a reference, continue
.86a5	d0 10		bne $86b7			bne 	_LCMain
.86a7	4c bc 9f	jmp $9fbc			jmp 	TypeError 					; was a reference before.
.86aa					_LCStandard:
.86aa	ad fc 92	lda $92fc			lda 	PrecedenceLevel+"*"			; precedence > this
.86ad	20 16 93	jsr $9316			jsr 	EvaluateExpressionAtPrecedence
.86b0	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; is it a reference to an array
.86b3	c9 38		cmp #$38			cmp		#NSTProcedure+NSBIsReference
.86b5	f0 0e		beq $86c5			beq 	_LetGoProc 					; it's a procedure call.
.86b7					_LCMain:
.86b7	a9 3d		lda #$3d			lda 	#"=" 						; check =
.86b9	20 5c 8d	jsr $8d5c			jsr 	CheckNextA
.86bc	e8		inx				inx 								; RHS
.86bd	20 48 9d	jsr $9d48			jsr 	EvaluateValue
.86c0	ca		dex				dex
.86c1	20 c8 86	jsr $86c8			jsr 	AssignVariable
.86c4	60		rts				rts
.86c5					_LetGoProc:
.86c5	4c c6 88	jmp $88c6			jmp 	CallProcedure
.86c8					AssignVariable:
.86c8	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check the string/number type bits match
.86cb	48		pha				pha 								; save a copy
.86cc	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.86cf	29 10		and #$10			and 	#NSBIsString
.86d1	d0 0b		bne $86de			bne 	_ASError
.86d3	68		pla				pla 								; get back
.86d4	29 10		and #$10			and 	#NSBIsString 				; check type
.86d6	d0 03		bne $86db			bne 	_ASString
.86d8	4c 5a 95	jmp $955a			jmp 	AssignNumber
.86db					_ASString:
.86db	4c c8 95	jmp $95c8			jmp 	AssignString
.86de					_ASError:
.86de	4c bc 9f	jmp $9fbc			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/list.asm

.86e1					Command_List:
.86e1	9c a6 04	stz $04a6			stz 	listIndent 					; reset indent.
.86e4	9c 0c 04	stz $040c			stz		NSMantissa0+4				; set the lower (slot 4) to 0 and upper (slot 7) to $FFFF
.86e7	9c 14 04	stz $0414			stz 	NSMantissa1+4
.86ea	a9 ff		lda #$ff			lda 	#$FF
.86ec	8d 0f 04	sta $040f			sta 	NSMantissa0+7
.86ef	8d 17 04	sta $0417			sta 	NSMantissa1+7
.86f2	b1 30		lda ($30),y			lda 	(codePtr),y
.86f4	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.86f6	f0 1e		beq $8716			beq 	_CLSecond
.86f8	20 77 87	jsr $8777			jsr 	CLIsDigit 					; if not digit, list all
.86fb	b0 24		bcs $8721			bcs 	_CLStart
.86fd	a2 04		ldx #$04			ldx 	#4 							; get 1st range into slot 4
.86ff	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger
.8702	b1 30		lda ($30),y			lda 	(codePtr),y
.8704	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8706	f0 0e		beq $8716			beq 	_CLSecond 					; if so go get it
.8708	ad 0c 04	lda $040c			lda 	NSMantissa0+4 				; copy 4->7
.870b	8d 0f 04	sta $040f			sta 	NSMantissa0+7
.870e	ad 14 04	lda $0414			lda 	NSMantissa1+4
.8711	8d 17 04	sta $0417			sta 	NSMantissa1+7
.8714	80 0b		bra $8721			bra 	_CLStart
.8716					_CLSecond:
.8716	c8		iny				iny 								; consume comma
.8717	20 77 87	jsr $8777			jsr 	CLIsDigit 					; digit found
.871a	b0 05		bcs $8721			bcs 	_CLStart 					; if not, continue listing
.871c	a2 07		ldx #$07			ldx 	#7 							; load 2nd range into slot 7
.871e	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger
.8721					_CLStart
.8721	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8723	85 30		sta $30				sta 	codePtr
.8725	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8727	85 31		sta $31				sta 	codePtr+1
.8729					_CLLoop:
.8729	20 94 aa	jsr $aa94			jsr 	EXTBreakCheck 				; break check
.872c	f0 33		beq $8761			beq 	_CLExit
.872e	b2 30		lda ($30)			lda 	(codePtr)
.8730	f0 2f		beq $8761			beq 	_CLExit
.8732	a2 04		ldx #$04			ldx 	#4 							; check range every time, line numbers aren't in order.
.8734	20 64 87	jsr $8764			jsr 	CLCompareLineNo
.8737	90 1b		bcc $8754			bcc 	_CLNext
.8739	a2 07		ldx #$07			ldx 	#7
.873b	20 64 87	jsr $8764			jsr 	CLCompareLineNo
.873e	f0 02		beq $8742			beq 	_CLDoThisOne
.8740	b0 12		bcs $8754			bcs 	_CLNext
.8742					_CLDoThisOne:
.8742	20 0a 8d	jsr $8d0a			jsr 	ScanGetCurrentLineStep 		; get indent adjust.
.8745	20 de b3	jsr $b3de			jsr 	ListConvertLine 			; convert line into token Buffer
.8748	a2 04		ldx #$04			ldx 	#(tokenBuffer >> 8) 		; print that line
.874a	a9 ab		lda #$ab			lda 	#(tokenBuffer & $FF)
.874c	20 be 8d	jsr $8dbe			jsr 	PrintStringXA
.874f	a9 0d		lda #$0d			lda 	#13 						; new line
.8751	20 de a7	jsr $a7de			jsr 	EXTPrintCharacter
.8754					_CLNext:
.8754	18		clc				clc
.8755	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.8757	65 30		adc $30				adc 	codePtr
.8759	85 30		sta $30				sta 	codePtr
.875b	90 02		bcc $875f			bcc 	_CREExit
.875d	e6 31		inc $31				inc 	codePtr+1
.875f					_CREExit:
.875f	80 c8		bra $8729			bra 	_CLLoop
.8761					_CLExit:
.8761	4c 54 83	jmp $8354			jmp 	WarmStart
.8764					CLCompareLineNo:
.8764	38		sec				sec
.8765	a0 01		ldy #$01			ldy 	#1
.8767	b1 30		lda ($30),y			lda 	(codePtr),y
.8769	fd 08 04	sbc $0408,x			sbc 	NSMantissa0,x
.876c	85 36		sta $36				sta 	zTemp0
.876e	c8		iny				iny
.876f	b1 30		lda ($30),y			lda 	(codePtr),y
.8771	fd 10 04	sbc $0410,x			sbc 	NSMantissa1,x
.8774	05 36		ora $36				ora 	zTemp0
.8776	60		rts				rts
.8777					CLIsDigit:
.8777	b1 30		lda ($30),y			lda 	(codePtr),y
.8779	c9 30		cmp #$30			cmp 	#"0"
.877b	90 03		bcc $8780			bcc	 	_CLIDExitFalse
.877d	c9 3a		cmp #$3a			cmp 	#"9"+1
.877f	60		rts				rts
.8780					_CLIDExitFalse:
.8780	38		sec				sec
.8781	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/local.asm

.8782					Command_LOCAL:
.8782	a2 00		ldx #$00			ldx 	#0 							; at level 0
.8784	20 90 87	jsr $8790			jsr 	LocaliseNextTerm 			; convert term to a local.
.8787	b1 30		lda ($30),y			lda 	(codePtr),y
.8789	c8		iny				iny
.878a	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.878c	f0 f4		beq $8782			beq 	Command_LOCAL
.878e	88		dey				dey 								; unpick pre-get
.878f	60		rts				rts
.8790					LocaliseNextTerm:
.8790	20 ee 97	jsr $97ee			jsr 	EvaluateTerm 				; evaluate the term
.8793	bd 00 04	lda $0400,x			lda 	NSStatus,x
.8796	29 20		and #$20			and 	#NSBIsReference 			; check it is a reference
.8798	f0 61		beq $87fb			beq		_LNTError
.879a	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address of variable to zTemp0
.879d	85 36		sta $36				sta 	zTemp0
.879f	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.87a2	85 37		sta $37				sta  	zTemp0+1
.87a4	bd 00 04	lda $0400,x			lda 	NSStatus,x
.87a7	29 10		and #$10			and 	#NSBIsString
.87a9	d0 1e		bne $87c9			bne 	_LNTPushString
.87ab	5a		phy				phy
.87ac	a0 00		ldy #$00			ldy 	#0 							; push 0 to 4 inclusive, the number values, on the stack, and zero them as you go.
.87ae					_LNTPushNumLoop:
.87ae	b1 36		lda ($36),y			lda		(zTemp0),y
.87b0	20 7c a6	jsr $a67c			jsr 	StackPushByte
.87b3	c8		iny				iny
.87b4	c0 05		cpy #$05			cpy 	#5
.87b6	d0 f6		bne $87ae			bne 	_LNTPushNumLoop
.87b8	a5 36		lda $36				lda 	zTemp0 						; push the actual target address to write on the stack
.87ba	20 7c a6	jsr $a67c			jsr 	StackPushByte
.87bd	a5 37		lda $37				lda 	zTemp0+1
.87bf	20 7c a6	jsr $a67c			jsr 	StackPushByte
.87c2	a9 01		lda #$01			lda 	#STK_LOCALN 				; push local-number marker.
.87c4	20 7c a6	jsr $a67c			jsr 	StackPushByte
.87c7	7a		ply				ply
.87c8	60		rts				rts
.87c9					_LNTPushString:
.87c9	5a		phy				phy
.87ca	b2 36		lda ($36)			lda 	(zTemp0) 					; put address of string in zTemp1
.87cc	85 38		sta $38				sta 	zTemp1
.87ce	a0 01		ldy #$01			ldy 	#1
.87d0	b1 36		lda ($36),y			lda 	(zTemp0),y
.87d2	85 39		sta $39				sta 	zTemp1+1
.87d4	a0 00		ldy #$00			ldy 	#0 							; output string
.87d6	c9 00		cmp #$00			cmp 	#0 							; if not assigned strin
.87d8	f0 0a		beq $87e4			beq 	_LNTStringOut
.87da					_LNTPushStrLoop:
.87da	b1 38		lda ($38),y			lda 	(zTemp1),y
.87dc	f0 06		beq $87e4			beq 	_LNTStringOut
.87de	20 7c a6	jsr $a67c			jsr 	StackPushByte
.87e1	c8		iny				iny
.87e2	80 f6		bra $87da			bra 	_LNTPushStrLoop
.87e4					_LNTStringOut:
.87e4	98		tya				tya									; output length
.87e5	20 7c a6	jsr $a67c			jsr 	StackPushByte
.87e8	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; output address of the string record *not* the string itself
.87eb	20 7c a6	jsr $a67c			jsr 	StackPushByte
.87ee	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.87f1	20 7c a6	jsr $a67c			jsr 	StackPushByte
.87f4	a9 02		lda #$02			lda 	#STK_LOCALS 				; push local-string marker.
.87f6	20 7c a6	jsr $a67c			jsr 	StackPushByte
.87f9	7a		ply				ply
.87fa	60		rts				rts
.87fb					_LNTError:
.87fb	4c b2 9f	jmp $9fb2			jmp 	SyntaxError
.87fe					LocalPopValue:
.87fe	20 95 a6	jsr $a695			jsr 	StackPopByte
.8801	c9 01		cmp #$01			cmp 	#STK_LOCALN 				; if not local-N
.8803	d0 17		bne $881c			bne 	_LPVString
.8805	20 95 a6	jsr $a695			jsr 	StackPopByte 				; address
.8808	85 37		sta $37				sta 	zTemp0+1
.880a	20 95 a6	jsr $a695			jsr 	StackPopByte
.880d	85 36		sta $36				sta 	zTemp0
.880f	5a		phy				phy
.8810	a0 04		ldy #$04			ldy 	#4 							; copy back
.8812					_LPVNumberCopy:
.8812	20 95 a6	jsr $a695			jsr 	StackPopByte
.8815	91 36		sta ($36),y			sta 	(zTemp0),y
.8817	88		dey				dey
.8818	10 f8		bpl $8812			bpl 	_LPVNumberCopy
.881a	7a		ply				ply 								; and complete
.881b	60		rts				rts
.881c					_LPVString:
.881c	20 95 a6	jsr $a695			jsr 	StackPopByte 				; address of record => zTemp0
.881f	85 37		sta $37				sta 	zTemp0+1
.8821	20 95 a6	jsr $a695			jsr 	StackPopByte
.8824	85 36		sta $36				sta 	zTemp0
.8826	5a		phy				phy
.8827	b2 36		lda ($36)			lda 	(zTemp0) 					; address to write string to => zTemp1
.8829	85 38		sta $38				sta 	zTemp1
.882b	a0 01		ldy #$01			ldy 	#1
.882d	b1 36		lda ($36),y			lda 	(zTemp0),y
.882f	85 39		sta $39				sta 	zTemp1+1
.8831	20 95 a6	jsr $a695			jsr 	StackPopByte 				; # to get => y
.8834	a8		tay				tay
.8835	a5 39		lda $39				lda 	zTemp1+1 					; if no target (e.g. was "" originally) exit
.8837	f0 0e		beq $8847			beq 	_LPVStringCopied
.8839	a9 00		lda #$00			lda 	#0 							; NULL on end
.883b	91 38		sta ($38),y			sta 	(zTemp1),y
.883d					_LPVStringCopy:
.883d	88		dey				dey
.883e	30 07		bmi $8847			bmi 	_LPVStringCopied
.8840	20 95 a6	jsr $a695			jsr 	StackPopByte
.8843	91 38		sta ($38),y			sta 	(zTemp1),y
.8845	80 f6		bra $883d			bra 	_LPVStringCopy
.8847					_LPVStringCopied:
.8847	fa		plx				plx
.8848	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/new.asm

.8849					NewCommand:
.8849	20 4f 88	jsr $884f			jsr 	NewProgram
.884c	4c 54 83	jmp $8354			jmp 	WarmStart
.884f					NewProgram:
.884f	20 a0 a5	jsr $a5a0			jsr 	MemoryNew
.8852	9c 00 10	stz $1000			stz 	VariableSpace 				; erase all variables.
.8855	20 ed 83	jsr $83ed			jsr 	ClearCommand 				; clear everything.
.8858	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/print.asm

.8859					Command_Print:
.8859	18		clc				clc 								; carry being clear means last print wasn't comma/semicolon
.885a					_CPLoop:
.885a	08		php				php 								; save last action flag
.885b	b1 30		lda ($30),y			lda 	(codePtr),y
.885d	c9 80		cmp #$80			cmp  	#KWC_EOL 					; end of line or colon, exit now.
.885f	f0 46		beq $88a7			beq 	_CPExit
.8861	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.8863	f0 42		beq $88a7			beq 	_CPExit
.8865	68		pla				pla 								; throw last action flag
.8866	b1 30		lda ($30),y			lda 	(codePtr),y
.8868	c8		iny				iny
.8869	c9 3b		cmp #$3b			cmp 	#KWD_SEMICOLON				; is it a semicolon
.886b	f0 37		beq $88a4			beq 	_CPContinueWithSameLine
.886d	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; comma
.886f	f0 2e		beq $889f			beq 	_CPTab
.8871	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; apostrophe (new line)
.8873	f0 26		beq $889b			beq 	_CPNewLine
.8875	88		dey				dey 								; undo the get.
.8876	a2 00		ldx #$00			ldx 	#0
.8878	20 48 9d	jsr $9d48			jsr 	EvaluateValue 				; get a value into slot 0
.887b	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; is it a number
.887e	29 10		and #$10			and 	#NSBIsString
.8880	f0 0b		beq $888d			beq 	_CPNumber
.8882	ae 10 04	ldx $0410			ldx 	NSMantissa1 				; string, print the text.
.8885	ad 08 04	lda $0408			lda 	NSMantissa0
.8888	20 b0 88	jsr $88b0			jsr 	CPPrintStringXA
.888b	80 cc		bra $8859			bra 	Command_Print 				; loop round clearing carry so NL if end
.888d					_CPNumber:
.888d	a9 05		lda #$05			lda 	#5 							; maximum decimals
.888f	20 1e 9c	jsr $9c1e			jsr 	ConvertNumberToString 		; convert to string
.8892	a2 06		ldx #$06			ldx 	#DecimalBuffer >> 8
.8894	a9 1b		lda #$1b			lda 	#DecimalBuffer & $FF
.8896	20 b0 88	jsr $88b0			jsr 	CPPrintStringXA
.8899	80 be		bra $8859			bra 	Command_Print 				; loop round clearing carry so NL if end
.889b					_CPNewLine:
.889b	a9 0d		lda #$0d			lda 	#13
.889d	80 02		bra $88a1			bra 	_CPPrintChar
.889f					_CPTab:
.889f	a9 09		lda #$09			lda 	#9 							; print TAB
.88a1					_CPPrintChar:
.88a1	20 c3 88	jsr $88c3			jsr 	CPPrintVector
.88a4					_CPContinueWithSameLine:
.88a4	38		sec				sec 								; loop round with carry set, which
.88a5	80 b3		bra $885a			bra 	_CPLoop 					; will inhibit final CR
.88a7					_CPExit:
.88a7	28		plp				plp 								; get last action flag
.88a8	b0 05		bcs $88af			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.88aa	a9 0d		lda #$0d			lda 	#13 						; print new line
.88ac	20 c3 88	jsr $88c3			jsr 	CPPrintVector
.88af					_CPExit2:
.88af	60		rts				rts
.88b0					CPPrintStringXA:
.88b0	5a		phy				phy
.88b1	86 37		stx $37				stx 	zTemp0+1
.88b3	85 36		sta $36				sta 	zTemp0
.88b5	a0 00		ldy #$00			ldy 	#0
.88b7					_PSXALoop:
.88b7	b1 36		lda ($36),y			lda 	(zTemp0),y
.88b9	f0 06		beq $88c1			beq 	_PSXAExit
.88bb	20 c3 88	jsr $88c3			jsr 	CPPrintVector
.88be	c8		iny				iny
.88bf	80 f6		bra $88b7			bra 	_PSXALoop
.88c1					_PSXAExit:
.88c1	7a		ply				ply
.88c2	60		rts				rts
.88c3					CPPrintVector:
.88c3	4c de a7	jmp $a7de			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/procedure.asm

=2					ParameterStackPos = 2
.88c6					CallProcedure:
.88c6	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start storing parameters at 2.
.88c8	b1 30		lda ($30),y			lda 	(codePtr),y
.88ca	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.88cc	f0 0c		beq $88da			beq 	_CPEndParam
.88ce					_CPParamLoop:
.88ce	20 48 9d	jsr $9d48			jsr 	EvaluateValue 				; get parameter onto stack
.88d1	e8		inx				inx 								; bump next stack
.88d2	b1 30		lda ($30),y			lda 	(codePtr),y
.88d4	c8		iny				iny
.88d5	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if comma, go back and try again.
.88d7	f0 f5		beq $88ce			beq 	_CPParamLoop
.88d9	88		dey				dey 								; unpick.
.88da					_CPEndParam:
.88da	8e 96 04	stx $0496			stx 	LastParameter 				; save the last parameters index.
.88dd	c8		iny				iny									; skip right bracket
.88de	a9 b3		lda #$b3			lda 	#STK_PROC+3 				; allocate 6 bytes on the return stack.
.88e0	20 9e a6	jsr $a69e			jsr 	StackOpen
.88e3	20 e2 a6	jsr $a6e2			jsr 	STKSaveCodePosition 		; save loop position
.88e6	ad 08 04	lda $0408			lda 	NSMantissa0 				; copy variable (e.g. procedure) address to zTemp0
.88e9	85 36		sta $36				sta 	zTemp0 						; this is the DATA not the RECORD
.88eb	ad 10 04	lda $0410			lda 	NSMantissa1
.88ee	85 37		sta $37				sta 	zTemp0+1
.88f0	a0 01		ldy #$01			ldy 	#1 							; copy code address back.
.88f2	b2 36		lda ($36)			lda 	(zTemp0)
.88f4	85 30		sta $30				sta 	safePtr
.88f6	b1 36		lda ($36),y			lda 	(zTemp0),y
.88f8	85 31		sta $31				sta 	safePtr+1
.88fa	c8		iny				iny
.88fb	b1 36		lda ($36),y			lda 	(zTemp0),y
.88fd	85 32		sta $32				sta 	safePtr+2
.88ff	c8		iny				iny
.8900	b1 36		lda ($36),y			lda 	(zTemp0),y
.8902	85 33		sta $33				sta 	safePtr+3
.8904	c8		iny				iny 								; get Y offset -> Y
.8905	b1 36		lda ($36),y			lda 	(zTemp0),y
.8907	a8		tay				tay
.8908	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start position of parameters
.890a	ec 96 04	cpx $0496			cpx	 	LastParameter 				; check no parameters at the start
.890d	f0 13		beq $8922			beq 	_ParamExit 					; if so, exit.
.890f					_ParamExtract:
.890f	ca		dex				dex 								; put a local term on the level before
.8910	20 90 87	jsr $8790			jsr 	LocaliseNextTerm			; also pushes original param value to basic stack
.8913	20 c8 86	jsr $86c8			jsr 	AssignVariable 				; assign stacked value to the variable.
.8916	e8		inx				inx 								; advance to next parameter to do.
.8917	e8		inx				inx
.8918	ec 96 04	cpx $0496			cpx 	LastParameter 				; are we done ?
.891b	f0 05		beq $8922			beq 	_ParamExit
.891d	20 54 8d	jsr $8d54			jsr 	CheckComma 					; comma seperating parameters
.8920	80 ed		bra $890f			bra 	_ParamExtract
.8922					_ParamExit:
.8922	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket 			; check )
.8925	60		rts				rts 								; and continue from here
.8926					Command_ENDPROC:
.8926	a9 b0		lda #$b0			lda 	#STK_PROC 					; check TOS is this
.8928	a2 14		ldx #$14			ldx 	#ERRID_PROC
.892a	20 ca a6	jsr $a6ca			jsr 	StackCheckFrame
.892d	20 f3 a6	jsr $a6f3			jsr 	STKLoadCodePosition 		; restore code position
.8930	20 bc a6	jsr $a6bc			jsr 	StackClose
.8933	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/read.asm

.8934					Command_Read:
.8934	a2 00		ldx #$00			ldx 	#0 							; evaluate the term which is the var/array element to assign
.8936	20 ee 97	jsr $97ee			jsr 	EvaluateTerm
.8939	bd 00 04	lda $0400,x			lda 	NSStatus,x
.893c	29 20		and #$20			and 	#NSBIsReference				; get status byte on stack, identifies int, float, string.
.893e	f0 4a		beq $898a			beq 	_CRSyntax 					; check reference (bit 0)
.8940	20 d3 89	jsr $89d3			jsr 	SwapDataCodePtrs 			; swap code and data
.8943	ad 9c 04	lda $049c			lda 	inDataStatement 			; if in a data statement, we don't need to search
.8946	d0 20		bne $8968			bne 	_CRContinueData
.8948					_CRKeepSearching:
.8948	a9 b2		lda #$b2			lda 	#KWD_DATA 					; scan for instruction
.894a	aa		tax				tax
.894b	20 a7 8c	jsr $8ca7			jsr 	ScanForward
.894e	c9 b2		cmp #$b2			cmp 	#KWD_DATA 					; found data ?
.8950	f0 16		beq $8968			beq 	_CRHaveData 				; found it
.8952	18		clc				clc
.8953	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.8955	65 30		adc $30				adc 	codePtr
.8957	85 30		sta $30				sta 	codePtr
.8959	90 02		bcc $895d			bcc 	_CREExit
.895b	e6 31		inc $31				inc 	codePtr+1
.895d					_CREExit:
.895d	a0 03		ldy #$03			ldy 	#3 							; start of line.
.895f	b2 30		lda ($30)			lda 	(codePtr)
.8961	d0 e5		bne $8948			bne 	_CRKeepSearching
.8963	a9 0b		lda #$0b		lda	#11
.8965	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.8968					_CRHaveData:
.8968					_CRContinueData:
.8968	a2 01		ldx #$01			ldx 	#1
.896a	20 48 9d	jsr $9d48			jsr 	EvaluateValue 				; evaluate value into slot # 1
.896d	ca		dex				dex
.896e	20 c8 86	jsr $86c8			jsr		AssignVariable 				; do the assignment
.8971	9c 9c 04	stz $049c			stz 	inDataStatement 			; clear in data
.8974	b1 30		lda ($30),y			lda 	(codePtr),y
.8976	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not, end of data statement
.8978	d0 04		bne $897e			bne 	_CRSwapBack
.897a	c8		iny				iny 								; consume comma
.897b	ee 9c 04	inc $049c			inc 	inDataStatement 			; set in data statement currently.
.897e					_CRSwapBack:
.897e	20 d3 89	jsr $89d3			jsr 	SwapDataCodePtrs			; swap them back.
.8981	b1 30		lda ($30),y			lda 	(codePtr),y
.8983	c8		iny				iny
.8984	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8986	f0 ac		beq $8934			beq 	Command_Read 				; if so go round again.
.8988	88		dey				dey 								; unpick get.
.8989	60		rts				rts
.898a					_CRSyntax:
.898a	4c b2 9f	jmp $9fb2			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/rem.asm

.898d					RemCommand:
.898d	b1 30		lda ($30),y			lda 	(codePtr),y
.898f	c9 ff		cmp #$ff			cmp 	#KWC_STRING
.8991	d0 06		bne $8999			bne 	_RMExit
.8993	c8		iny				iny
.8994	98		tya				tya
.8995	38		sec				sec
.8996	71 30		adc ($30),y			adc 	(codePtr),y
.8998	a8		tay				tay
.8999					_RMExit:
.8999	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/repeat.asm

.899a					Command_REPEAT:
.899a	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; allocate 6 bytes on the return stack.
.899c	20 9e a6	jsr $a69e			jsr 	StackOpen
.899f	20 e2 a6	jsr $a6e2			jsr 	STKSaveCodePosition 		; save loop position
.89a2	60		rts				rts
.89a3					Command_UNTIL:
.89a3	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; check REPEAT is TOS
.89a5	a2 0f		ldx #$0f			ldx 	#ERRID_REPEAT 				; this error
.89a7	20 ca a6	jsr $a6ca			jsr 	StackCheckFrame
.89aa	a2 00		ldx #$00			ldx 	#0
.89ac	20 51 9d	jsr $9d51			jsr 	EvaluateNumber 				; work out the number
.89af	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; check if zero
.89b2	f0 04		beq $89b8			beq 	_CULoopBack 				; if so keep looping
.89b4	20 bc a6	jsr $a6bc			jsr 	StackClose		 			; return
.89b7	60		rts				rts
.89b8					_CULoopBack:
.89b8	20 f3 a6	jsr $a6f3			jsr 	STKLoadCodePosition 		; loop back
.89bb	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/restore.asm

.89bc					Command_Restore:
.89bc	20 d3 89	jsr $89d3			jsr 	SwapDataCodePtrs 			; swap code and data
.89bf	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.89c1	85 30		sta $30				sta 	codePtr
.89c3	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.89c5	85 31		sta $31				sta 	codePtr+1
.89c7	20 d3 89	jsr $89d3			jsr 	SwapDataCodePtrs 			; put them back
.89ca	a9 03		lda #$03			lda 	#3 							; start at offset 3, e.g. first instruction of first line.
.89cc	8d 9b 04	sta $049b			sta 	dataPointer+4
.89cf	9c 9c 04	stz $049c			stz 	inDataStatement 			; not in data statement
.89d2	60		rts				rts
.89d3					SwapDataCodePtrs:
.89d3	da		phx				phx
.89d4	a2 03		ldx #$03			ldx 	#3 							; swap 32 bit code pointer over
.89d6					_SDCPLoop:
.89d6	b5 30		lda $30,x			lda 	safePtr,x
.89d8	48		pha				pha
.89d9	bd 97 04	lda $0497,x			lda 	dataPointer,x
.89dc	95 30		sta $30,x			sta 	safePtr,x
.89de	68		pla				pla
.89df	9d 97 04	sta $0497,x			sta 	dataPointer,x
.89e2	ca		dex				dex
.89e3	10 f1		bpl $89d6			bpl 	_SDCPLoop
.89e5	ad 9b 04	lda $049b			lda 	dataPointer+4 				; swap Y position over.
.89e8	8c 9b 04	sty $049b			sty 	dataPointer+4
.89eb	a8		tay				tay
.89ec	fa		plx				plx
.89ed	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/run.asm

.89ee					EOLCommand:
.89ee	18		clc				clc
.89ef	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.89f1	65 30		adc $30				adc 	codePtr
.89f3	85 30		sta $30				sta 	codePtr
.89f5	90 02		bcc $89f9			bcc 	_CREExit
.89f7	e6 31		inc $31				inc 	codePtr+1
.89f9					_CREExit:
.89f9	80 0b		bra $8a06			bra 	RunNewLine
.89fb					CommandRUN:
.89fb	20 ed 83	jsr $83ed			jsr 	ClearCommand 				; clear variable/stacks/etc.
.89fe	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8a00	85 30		sta $30				sta 	codePtr
.8a02	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8a04	85 31		sta $31				sta 	codePtr+1
.8a06					RUNNewLine:
.8a06	b2 30		lda ($30)			lda 	(codePtr)
.8a08	f0 72		beq $8a7c			beq 	CRNoProgram         		; no then END.
.8a0a	a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack
.8a0c	9a		txs				txs
.8a0d					RUNCodePointerLine:
.8a0d	a0 02		ldy #$02			ldy 	#2 							; start of program
.8a0f					_CRIncMainLoop:
.8a0f	0e 93 04	asl $0493			asl 	breakCheck 					; clears 1 time in 8
.8a12	d0 19		bne $8a2d			bne 	_CRNoBreakCheck
.8a14	20 94 aa	jsr $aa94			jsr 	EXTBreakCheck 				; break check
.8a17	f0 5e		beq $8a77			beq 	_CRBreak
.8a19	64 01		stz $01				stz 	1 							; access I/O Page 0
.8a1b	38		sec				sec 								; calculate timer - LastTick
.8a1c	ad 59 d6	lda $d659			lda 	$D659
.8a1f	aa		tax				tax 								; saving timer in X
.8a20	ed 2d 06	sbc $062d			sbc 	LastTick
.8a23	c9 03		cmp #$03			cmp 	#3
.8a25	90 06		bcc $8a2d			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.8a27	8e 2d 06	stx $062d			stx 	LastTick 					; update last timer
.8a2a	20 f9 b9	jsr $b9f9			jsr 	TickHandler 				; go do the code.
.8a2d					_NoFireTick:
.8a2d					_CRNoBreakCheck:
.8a2d	c8		iny				iny
.8a2e					_CRMainLoop:
.8a2e	9c 90 04	stz $0490			stz 	stringInitialised 			; clear the temporary string initialised flag.
.8a31	b1 30		lda ($30),y			lda 	(codePtr),y
.8a33	10 10		bpl $8a45			bpl 	_CRNotKeyword
.8a35	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1 			; if after unary, legitimate command
.8a37	b0 04		bcs $8a3d			bcs 	_CRIsKeyword
.8a39	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if unary, syntax error.
.8a3b	b0 34		bcs $8a71			bcs		_CRSyntaxError
.8a3d					_CRIsKeyword:
.8a3d	c8		iny				iny 								; consume command
.8a3e	0a		asl a				asl 	a 							; double losing the MSB which is '1' as tokens are $80-$FF
.8a3f	aa		tax				tax 								; put in X for vector jump
.8a40	20 74 8a	jsr $8a74			jsr 	_CRCallVector0 				; call the vector - effectively jsr (vectortable,X)
.8a43	80 e9		bra $8a2e			bra 	_CRMainLoop 				; and loop round
.8a45					_CRNotKeyword:
.8a45	c9 3a		cmp #$3a			cmp 	#KWD_COLON 					; if a :, consume it and go round.
.8a47	f0 c6		beq $8a0f			beq 	_CRIncMainLoop
.8a49	c9 40		cmp #$40			cmp 	#$40 						; variable/call reference
.8a4b	90 05		bcc $8a52			bcc 	_CRNotVariable
.8a4d					_CRGoLet:
.8a4d	20 8c 86	jsr $868c			jsr 	LetCommand
.8a50	80 dc		bra $8a2e			bra 	_CRMainLoop
.8a52					_CRNotVariable:
.8a52	c9 10		cmp #$10			cmp 	#KWD_AT 					; handle @
.8a54	f0 f7		beq $8a4d			beq 	_CRGoLet
.8a56	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; handle ? !
.8a58	f0 f3		beq $8a4d			beq 	_CRGoLet
.8a5a	c9 21		cmp #$21			cmp 	#KWD_PLING
.8a5c	f0 ef		beq $8a4d			beq 	_CRGoLet
.8a5e	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; handle ' (comment)
.8a60	f0 09		beq $8a6b			beq 	_CRGoRem
.8a62	c9 2e		cmp #$2e			cmp 	#KWD_PERIOD 				; handle . (assembler label)
.8a64	d0 0b		bne $8a71			bne 	_CRSyntaxError
.8a66	20 12 82	jsr $8212			jsr 	LabelHere
.8a69	80 c3		bra $8a2e			bra 	_CRMainLoop
.8a6b					_CRGoRem:
.8a6b	c8		iny				iny
.8a6c	20 8d 89	jsr $898d			jsr 	RemCommand
.8a6f	80 bd		bra $8a2e			bra 	_CRMainLoop
.8a71					_CRSyntaxError:
.8a71	4c b2 9f	jmp $9fb2			jmp 	SyntaxError
.8a74					_CRCallVector0:
.8a74	7c 12 8b	jmp ($8b12,x)			jmp 	(VectorSet0,x)
.8a77					_CRBreak:
.8a77	a9 01		lda #$01		lda	#1
.8a79	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.8a7c					CRNoProgram:
.8a7c	4c 12 85	jmp $8512			jmp 	EndCommand
.8a7f					Shift1Command:
.8a7f	b1 30		lda ($30),y			lda 	(codePtr),y
.8a81	c8		iny				iny
.8a82	0a		asl a				asl 	a
.8a83	aa		tax				tax
.8a84	7c ae 8b	jmp ($8bae,x)			jmp 	(VectorSet1,x)
.8a87					Shift2Command:
.8a87	b1 30		lda ($30),y			lda 	(codePtr),y
.8a89	c8		iny				iny
.8a8a	0a		asl a				asl 	a
.8a8b	aa		tax				tax
.8a8c	7c c8 8b	jmp ($8bc8,x)			jmp 	(VectorSet2,x)
.8a8f					Unused1:
.8a8f					Unused2:
.8a8f					Unused3:
.8a8f					Unused4:
.8a8f	4c b2 9f	jmp $9fb2			jmp 	SyntaxError
>8a92							.align 2

;******  Processing file: ./common/commands/../generated/vectors.dat

.8a92					VectorSetPunc:
>8a92	52 90					.word	ShiftLeft                        ; $00 <<
>8a94	09 8e					.word	BinaryCompareLessEqual           ; $01 <=
>8a96	ff 8d					.word	BinaryCompareNotEqual            ; $02 <>
>8a98	b2 9f					.word	SyntaxError                      ; $03 !!3
>8a9a	b2 9f					.word	SyntaxError                      ; $04 ><
>8a9c	13 8e					.word	BinaryCompareGreaterEqual        ; $05 >=
>8a9e	55 90					.word	ShiftRight                       ; $06 >>
>8aa0	b2 9f					.word	SyntaxError                      ; $07 !!7
>8aa2	b2 9f					.word	SyntaxError                      ; $08 !!8
>8aa4	b2 9f					.word	SyntaxError                      ; $09 !!9
>8aa6	b2 9f					.word	SyntaxError                      ; $0a !!10
>8aa8	b2 9f					.word	SyntaxError                      ; $0b !!11
>8aaa	b2 9f					.word	SyntaxError                      ; $0c !!12
>8aac	b2 9f					.word	SyntaxError                      ; $0d !!13
>8aae	b2 9f					.word	SyntaxError                      ; $0e !!14
>8ab0	b2 9f					.word	SyntaxError                      ; $0f !!15
>8ab2	b2 9f					.word	SyntaxError                      ; $10 @
>8ab4	b2 9f					.word	SyntaxError                      ; $11 !!17
>8ab6	b2 9f					.word	SyntaxError                      ; $12 !!18
>8ab8	b2 9f					.word	SyntaxError                      ; $13 [
>8aba	d6 8e					.word	IntegerDivide                    ; $14 \
>8abc	b2 9f					.word	SyntaxError                      ; $15 ]
>8abe	e3 91					.word	EorInteger                       ; $16 ^
>8ac0	b2 9f					.word	SyntaxError                      ; $17 _
>8ac2	b2 9f					.word	SyntaxError                      ; $18 `
>8ac4	b2 9f					.word	SyntaxError                      ; $19 !!25
>8ac6	b2 9f					.word	SyntaxError                      ; $1a !!26
>8ac8	b2 9f					.word	SyntaxError                      ; $1b {
>8aca	9d 91					.word	OraInteger                       ; $1c |
>8acc	b2 9f					.word	SyntaxError                      ; $1d }
>8ace	b2 9f					.word	SyntaxError                      ; $1e ~
>8ad0	b2 9f					.word	SyntaxError                      ; $1f [7m<7F>[m
>8ad2	b2 9f					.word	SyntaxError                      ; $20
>8ad4	29 92					.word	WordIndirect                     ; $21 !
>8ad6	b2 9f					.word	SyntaxError                      ; $22 "
>8ad8	b2 9f					.word	SyntaxError                      ; $23 #
>8ada	b2 9f					.word	SyntaxError                      ; $24 $
>8adc	23 8f					.word	IntegerModulus                   ; $25 %
>8ade	57 91					.word	AndInteger                       ; $26 &
>8ae0	b2 9f					.word	SyntaxError                      ; $27 '
>8ae2	b2 9f					.word	SyntaxError                      ; $28 (
>8ae4	b2 9f					.word	SyntaxError                      ; $29 )
>8ae6	98 8f					.word	MulInteger                       ; $2a *
>8ae8	e9 90					.word	AddInteger                       ; $2b +
>8aea	b2 9f					.word	SyntaxError                      ; $2c ,
>8aec	2c 91					.word	SubInteger                       ; $2d -
>8aee	b2 9f					.word	SyntaxError                      ; $2e .
>8af0	14 94					.word	FDivideCommand                   ; $2f /
>8af2	b2 9f					.word	SyntaxError                      ; $30 0
>8af4	b2 9f					.word	SyntaxError                      ; $31 1
>8af6	b2 9f					.word	SyntaxError                      ; $32 2
>8af8	b2 9f					.word	SyntaxError                      ; $33 3
>8afa	b2 9f					.word	SyntaxError                      ; $34 4
>8afc	b2 9f					.word	SyntaxError                      ; $35 5
>8afe	b2 9f					.word	SyntaxError                      ; $36 6
>8b00	b2 9f					.word	SyntaxError                      ; $37 7
>8b02	b2 9f					.word	SyntaxError                      ; $38 8
>8b04	b2 9f					.word	SyntaxError                      ; $39 9
>8b06	b2 9f					.word	SyntaxError                      ; $3a :
>8b08	b2 9f					.word	SyntaxError                      ; $3b ;
>8b0a	eb 8d					.word	BinaryCompareLess                ; $3c <
>8b0c	e1 8d					.word	BinaryCompareEqual               ; $3d =
>8b0e	f5 8d					.word	BinaryCompareGreater             ; $3e >
>8b10	50 92					.word	ByteIndirect                     ; $3f ?
.8b12					VectorSet0:
>8b12	ee 89					.word	EOLCommand                       ; $80 !0:EOF
>8b14	7f 8a					.word	Shift1Command                    ; $81 !1:SH1
>8b16	87 8a					.word	Shift2Command                    ; $82 !2:SH2
>8b18	84 99					.word	AbsUnary                         ; $83 ABS(
>8b1a	94 99					.word	AllocUnary                       ; $84 ALLOC(
>8b1c	04 9a					.word	AscUnary                         ; $85 ASC(
>8b1e	cf 9b					.word	ChrUnary                         ; $86 CHR$(
>8b20	23 a4					.word	UnaryEvent                       ; $87 EVENT(
>8b22	dd 8d					.word	UnaryFalse                       ; $88 FALSE
>8b24	11 9a					.word	FracUnary                        ; $89 FRAC(
>8b26	b9 a3					.word	UnaryHit                         ; $8a HIT(
>8b28	27 9a					.word	IntUnary                         ; $8b INT(
>8b2a	8e 9b					.word	IsValUnary                       ; $8c ISVAL(
>8b2c	b3 a4					.word	UnaryJoyB                        ; $8d JOYB(
>8b2e	8c a4					.word	UnaryJoyX                        ; $8e JOYX(
>8b30	8f a4					.word	UnaryJoyY                        ; $8f JOYY(
>8b32	a9 9c					.word	Unary_Left                       ; $90 LEFT$(
>8b34	39 9a					.word	LenUnary                         ; $91 LEN(
>8b36	57 9a					.word	Unary_Max                        ; $92 MAX(
>8b38	d3 9c					.word	Unary_Mid                        ; $93 MID$(
>8b3a	53 9a					.word	Unary_Min                        ; $94 MIN(
>8b3c	ae 9a					.word	Unary_Not                        ; $95 NOT(
>8b3e	f5 a5					.word	UnaryPlaying                     ; $96 PLAYING(
>8b40	c4 9a					.word	Unary_Random                     ; $97 RANDOM(
>8b42	b9 9c					.word	Unary_Right                      ; $98 RIGHT$(
>8b44	e3 9a					.word	Unary_Rnd                        ; $99 RND(
>8b46	64 9b					.word	SgnUnary                         ; $9a SGN(
>8b48	e1 9b					.word	SpcUnary                         ; $9b SPC(
>8b4a	fc 9b					.word	Unary_Str                        ; $9c STR$(
>8b4c	c7 a4					.word	UnaryTimer                       ; $9d TIMER(
>8b4e	d1 8d					.word	UnaryTrue                        ; $9e TRUE
>8b50	84 9b					.word	ValUnary                         ; $9f VAL(
>8b52	15 85					.word	ForCommand                       ; $a0 FOR
>8b54	62 86					.word	IfCommand                        ; $a1 IF
>8b56	8f 8a					.word	Unused1                          ; $a2 PROC
>8b58	9a 89					.word	Command_REPEAT                   ; $a3 REPEAT
>8b5a	1d 8d					.word	Command_WHILE                    ; $a4 WHILE
>8b5c	8b 86					.word	EndIf                            ; $a5 ENDIF
>8b5e	26 89					.word	Command_ENDPROC                  ; $a6 ENDPROC
>8b60	cf 85					.word	NextCommand                      ; $a7 NEXT
>8b62	8f 8a					.word	Unused4                          ; $a8 THEN
>8b64	a3 89					.word	Command_UNTIL                    ; $a9 UNTIL
>8b66	3e 8d					.word	Command_WEND                     ; $aa WEND
>8b68	b2 9f					.word	SyntaxError                      ; $ab BY
>8b6a	b3 83					.word	CallCommand                      ; $ac CALL
>8b6c	5b a1					.word	CircleCommand                    ; $ad CIRCLE
>8b6e	ed 83					.word	ClearCommand                     ; $ae CLEAR
>8b70	45 84					.word	ClearScreen                      ; $af CLS
>8b72	b2 9f					.word	SyntaxError                      ; $b0 COLOR
>8b74	b2 9f					.word	SyntaxError                      ; $b1 COLOUR
>8b76	4d 84					.word	Command_Data                     ; $b2 DATA
>8b78	55 84					.word	DimCommand                       ; $b3 DIM
>8b7a	8f 8a					.word	Unused3                          ; $b4 DOWNTO
>8b7c	84 86					.word	ElseCode                         ; $b5 ELSE
>8b7e	b2 9f					.word	SyntaxError                      ; $b6 FROM
>8b80	87 a3					.word	GfxCommand                       ; $b7 GFX
>8b82	28 86					.word	Command_GOSUB                    ; $b8 GOSUB
>8b84	46 86					.word	GotoCommand                      ; $b9 GOTO
>8b86	b2 9f					.word	SyntaxError                      ; $ba HERE
>8b88	85 a1					.word	ImageCommand                     ; $bb IMAGE
>8b8a	8c 86					.word	LetCommand                       ; $bc LET
>8b8c	da a1					.word	LineCommand                      ; $bd LINE
>8b8e	82 87					.word	Command_LOCAL                    ; $be LOCAL
>8b90	b2 9f					.word	SyntaxError                      ; $bf OFF
>8b92	b2 9f					.word	SyntaxError                      ; $c0 ON
>8b94	b2 9f					.word	SyntaxError                      ; $c1 OUTLINE
>8b96	df a3					.word	PaletteCommand                   ; $c2 PALETTE
>8b98	d3 a1					.word	PlotCommand                      ; $c3 PLOT
>8b9a	59 88					.word	Command_Print                    ; $c4 PRINT
>8b9c	34 89					.word	Command_Read                     ; $c5 READ
>8b9e	57 a1					.word	RectangleCommand                 ; $c6 RECT
>8ba0	8d 89					.word	RemCommand                       ; $c7 REM
>8ba2	38 86					.word	Command_RETURN                   ; $c8 RETURN
>8ba4	b2 9f					.word	SyntaxError                      ; $c9 SOLID
>8ba6	11 a6					.word	SoundCommand                     ; $ca SOUND
>8ba8	66 a1					.word	SpriteCommand                    ; $cb SPRITE
>8baa	a2 a1					.word	TextCommand                      ; $cc TEXT
>8bac	8f 8a					.word	Unused2                          ; $cd TO
.8bae					VectorSet1:
>8bae	b2 9f					.word	SyntaxError                      ; $80 !0:EOF
>8bb0	b2 9f					.word	SyntaxError                      ; $81 !1:SH1
>8bb2	b2 9f					.word	SyntaxError                      ; $82 !2:SH2
>8bb4	84 83					.word	AssembleCommand                  ; $83 ASSEMBLE
>8bb6	a3 83					.word	AssertCommand                    ; $84 ASSERT
>8bb8	27 a3					.word	BitmapCtrl                       ; $85 BITMAP
>8bba	12 85					.word	EndCommand                       ; $86 END
>8bbc	e1 86					.word	Command_List                     ; $87 LIST
>8bbe	49 88					.word	NewCommand                       ; $88 NEW
>8bc0	bc 89					.word	Command_Restore                  ; $89 RESTORE
>8bc2	fb 89					.word	CommandRUN                       ; $8a RUN
>8bc4	6c a3					.word	SpritesCtrl                      ; $8b SPRITES
>8bc6	50 8c					.word	StopCommand                      ; $8c STOP
.8bc8					VectorSet2:
>8bc8	b2 9f					.word	SyntaxError                      ; $80 !0:EOF
>8bca	b2 9f					.word	SyntaxError                      ; $81 !1:SH1
>8bcc	b2 9f					.word	SyntaxError                      ; $82 !2:SH2
>8bce	71 9e					.word	Assemble_adc                     ; $83 ADC
>8bd0	69 9e					.word	Assemble_and                     ; $84 AND
>8bd2	85 9e					.word	Assemble_asl                     ; $85 ASL
>8bd4	ef 9e					.word	Assemble_bcc                     ; $86 BCC
>8bd6	f3 9e					.word	Assemble_bcs                     ; $87 BCS
>8bd8	fb 9e					.word	Assemble_beq                     ; $88 BEQ
>8bda	b2 9e					.word	Assemble_bit                     ; $89 BIT
>8bdc	e3 9e					.word	Assemble_bmi                     ; $8a BMI
>8bde	f7 9e					.word	Assemble_bne                     ; $8b BNE
>8be0	df 9e					.word	Assemble_bpl                     ; $8c BPL
>8be2	ff 9e					.word	Assemble_bra                     ; $8d BRA
>8be4	03 9f					.word	Assemble_brk                     ; $8e BRK
>8be6	e7 9e					.word	Assemble_bvc                     ; $8f BVC
>8be8	eb 9e					.word	Assemble_bvs                     ; $90 BVS
>8bea	0b 9f					.word	Assemble_clc                     ; $91 CLC
>8bec	5f 9f					.word	Assemble_cld                     ; $92 CLD
>8bee	1f 9f					.word	Assemble_cli                     ; $93 CLI
>8bf0	4f 9f					.word	Assemble_clv                     ; $94 CLV
>8bf2	7d 9e					.word	Assemble_cmp                     ; $95 CMP
>8bf4	c6 9e					.word	Assemble_cpx                     ; $96 CPX
>8bf6	c1 9e					.word	Assemble_cpy                     ; $97 CPY
>8bf8	a3 9e					.word	Assemble_dec                     ; $98 DEC
>8bfa	5b 9f					.word	Assemble_dex                     ; $99 DEX
>8bfc	37 9f					.word	Assemble_dey                     ; $9a DEY
>8bfe	6d 9e					.word	Assemble_eor                     ; $9b EOR
>8c00	a8 9e					.word	Assemble_inc                     ; $9c INC
>8c02	6b 9f					.word	Assemble_inx                     ; $9d INX
>8c04	57 9f					.word	Assemble_iny                     ; $9e INY
>8c06	da 9e					.word	Assemble_jmp                     ; $9f JMP
>8c08	d5 9e					.word	Assemble_jsr                     ; $a0 JSR
>8c0a	79 9e					.word	Assemble_lda                     ; $a1 LDA
>8c0c	9e 9e					.word	Assemble_ldx                     ; $a2 LDX
>8c0e	bc 9e					.word	Assemble_ldy                     ; $a3 LDY
>8c10	8f 9e					.word	Assemble_lsr                     ; $a4 LSR
>8c12	6f 9f					.word	Assemble_nop                     ; $a5 NOP
>8c14	65 9e					.word	Assemble_ora                     ; $a6 ORA
>8c16	1b 9f					.word	Assemble_pha                     ; $a7 PHA
>8c18	07 9f					.word	Assemble_php                     ; $a8 PHP
>8c1a	63 9f					.word	Assemble_phx                     ; $a9 PHX
>8c1c	23 9f					.word	Assemble_phy                     ; $aa PHY
>8c1e	2b 9f					.word	Assemble_pla                     ; $ab PLA
>8c20	0f 9f					.word	Assemble_plp                     ; $ac PLP
>8c22	77 9f					.word	Assemble_plx                     ; $ad PLX
>8c24	33 9f					.word	Assemble_ply                     ; $ae PLY
>8c26	8a 9e					.word	Assemble_rol                     ; $af ROL
>8c28	94 9e					.word	Assemble_ror                     ; $b0 ROR
>8c2a	17 9f					.word	Assemble_rti                     ; $b1 RTI
>8c2c	27 9f					.word	Assemble_rts                     ; $b2 RTS
>8c2e	81 9e					.word	Assemble_sbc                     ; $b3 SBC
>8c30	13 9f					.word	Assemble_sec                     ; $b4 SEC
>8c32	73 9f					.word	Assemble_sed                     ; $b5 SED
>8c34	2f 9f					.word	Assemble_sei                     ; $b6 SEI
>8c36	75 9e					.word	Assemble_sta                     ; $b7 STA
>8c38	67 9f					.word	Assemble_stp                     ; $b8 STP
>8c3a	99 9e					.word	Assemble_stx                     ; $b9 STX
>8c3c	b7 9e					.word	Assemble_sty                     ; $ba STY
>8c3e	ad 9e					.word	Assemble_stz                     ; $bb STZ
>8c40	4b 9f					.word	Assemble_tax                     ; $bc TAX
>8c42	47 9f					.word	Assemble_tay                     ; $bd TAY
>8c44	d0 9e					.word	Assemble_trb                     ; $be TRB
>8c46	cb 9e					.word	Assemble_tsb                     ; $bf TSB
>8c48	53 9f					.word	Assemble_tsx                     ; $c0 TSX
>8c4a	3b 9f					.word	Assemble_txa                     ; $c1 TXA
>8c4c	43 9f					.word	Assemble_txs                     ; $c2 TXS
>8c4e	3f 9f					.word	Assemble_tya                     ; $c3 TYA

;******  Return to file: ./common/commands/run.asm


;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/stop.asm

.8c50					StopCommand:
.8c50	a9 08		lda #$08		lda	#8
.8c52	4c 65 8d	jmp $8d65		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/procscan.asm

.8c55					ProcedureScan:
.8c55	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8c57	85 30		sta $30				sta 	codePtr
.8c59	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8c5b	85 31		sta $31				sta 	codePtr+1
.8c5d					_PSLoop:
.8c5d	b2 30		lda ($30)			lda 	(codePtr)
.8c5f	f0 42		beq $8ca3			beq 	_PSExit
.8c61	a0 03		ldy #$03			ldy 	#3 							; is it PROC ?
.8c63	b1 30		lda ($30),y			lda 	(codePtr),y
.8c65	c9 a2		cmp #$a2			cmp 	#KWD_PROC
.8c67	d0 2d		bne $8c96			bne 	_PSNext
.8c69	c8		iny				iny 								; get the address of the record to zTemp0 and
.8c6a	b1 30		lda ($30),y			lda 	(codePtr),y
.8c6c	29 c0		and #$c0			and 	#$C0
.8c6e	c9 40		cmp #$40			cmp 	#$40
.8c70	d0 32		bne $8ca4			bne 	_PSSyntax
.8c72	b1 30		lda ($30),y			lda 	(codePtr),y
.8c74	18		clc				clc
.8c75	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8c77	85 37		sta $37				sta 	zTemp0+1
.8c79	c8		iny				iny 								; LSB
.8c7a	b1 30		lda ($30),y			lda 	(codePtr),y
.8c7c	85 36		sta $36				sta 	zTemp0
.8c7e	c8		iny				iny 								; character after variable call.
.8c7f	98		tya				tya 								; save Y offset at +7
.8c80	a0 07		ldy #$07			ldy 	#7
.8c82	91 36		sta ($36),y			sta 	(zTemp0),y
.8c84	a9 18		lda #$18			lda 	#NSTProcedure 				; mark it as procedure
.8c86	a0 02		ldy #$02			ldy 	#2
.8c88	91 36		sta ($36),y			sta 	(zTemp0),y
.8c8a	a2 00		ldx #$00			ldx 	#0 							; copy code-Ptr in
.8c8c					_PSCopy:
.8c8c	b5 30		lda $30,x			lda 	safePtr,x
.8c8e	c8		iny				iny
.8c8f	91 36		sta ($36),y			sta 	(zTemp0),y
.8c91	e8		inx				inx
.8c92	e0 04		cpx #$04			cpx 	#4
.8c94	d0 f6		bne $8c8c			bne 	_PSCopy
.8c96					_PSNext:
.8c96	18		clc				clc
.8c97	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.8c99	65 30		adc $30				adc 	codePtr
.8c9b	85 30		sta $30				sta 	codePtr
.8c9d	90 02		bcc $8ca1			bcc 	_CREExit
.8c9f	e6 31		inc $31				inc 	codePtr+1
.8ca1					_CREExit:
.8ca1	80 ba		bra $8c5d			bra 	_PSLoop
.8ca3					_PSExit:
.8ca3	60		rts				rts
.8ca4					_PSSyntax:
.8ca4	4c b2 9f	jmp $9fb2			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/scanforward.asm

.8ca7					ScanForward:
.8ca7	64 38		stz $38				stz 	zTemp1 						; this is the structure count - goes up with WHILE/FOR
.8ca9	86 37		stx $37				stx 	zTemp0+1
.8cab	85 36		sta $36				sta 	zTemp0 						; save XA as the two possible matches.
.8cad					_ScanLoop:
.8cad	b1 30		lda ($30),y			lda 	(codePtr),y
.8caf	c8		iny				iny
.8cb0	a6 38		ldx $38				ldx 	zTemp1 						; if the count is > 0 cannot match as in substructure
.8cb2	d0 0e		bne $8cc2			bne 	_ScanGoNext
.8cb4	c5 36		cmp $36				cmp 	zTemp0 						; see if either matches
.8cb6	f0 04		beq $8cbc			beq 	_ScanMatch
.8cb8	c5 37		cmp $37				cmp 	zTemp0+1
.8cba	d0 06		bne $8cc2			bne 	_ScanGoNext
.8cbc					_ScanMatch:
.8cbc	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if asked for EOL, backtrack.
.8cbe	d0 01		bne $8cc1			bne 	_ScanNotEndEOL
.8cc0	88		dey				dey
.8cc1					_ScanNotEndEOL:
.8cc1	60		rts				rts
.8cc2					_ScanGoNext:
.8cc2	20 c7 8c	jsr $8cc7			jsr  	ScanForwardOne
.8cc5	80 e6		bra $8cad			bra 	_ScanLoop
.8cc7					ScanForwardOne:
.8cc7	c9 40		cmp #$40			cmp 	#$40 						; if 00-3F, punctuation characters, loop back
.8cc9	90 3e		bcc $8d09			bcc 	_SFWExit
.8ccb	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if 40-82, skip one extra.
.8ccd	90 18		bcc $8ce7			bcc 	_ScanSkipOne
.8ccf	c9 fc		cmp #$fc			cmp 	#$FC 						; FC-FF are data skips
.8cd1	b0 2f		bcs $8d02			bcs 	_ScanSkipData
.8cd3	c9 a0		cmp #$a0			cmp 	#KWC_FIRST_STRUCTURE 		; structure keyword ?
.8cd5	90 32		bcc $8d09			bcc 	_SFWExit 					; if not, ordinary keywords.
.8cd7	c9 ab		cmp #$ab			cmp 	#KWC_LAST_STRUCTURE+1
.8cd9	b0 2e		bcs $8d09			bcs 	_SFWExit
.8cdb	c6 38		dec $38				dec 	zTemp1 						; decrement the sructure count
.8cdd	c9 a5		cmp #$a5			cmp 	#KWC_FIRST_STRUCTURE_DEC 	; back if it is a dec structure (e.g. WEND/NEXT)
.8cdf	b0 28		bcs $8d09			bcs 	_SFWExit
.8ce1	e6 38		inc $38				inc 	zTemp1 						; so it's an increment structure
.8ce3	e6 38		inc $38				inc 	zTemp1 						; twice to undo the dec
.8ce5	80 22		bra $8d09			bra 	_SFWExit
.8ce7					_ScanSkipOne:
.8ce7	c8		iny				iny 								; consume the extra one.
.8ce8	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if not EOL loop back
.8cea	d0 1d		bne $8d09			bne 	_SFWExit
.8cec	18		clc				clc
.8ced	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.8cef	65 30		adc $30				adc 	codePtr
.8cf1	85 30		sta $30				sta 	codePtr
.8cf3	90 02		bcc $8cf7			bcc 	_CREExit
.8cf5	e6 31		inc $31				inc 	codePtr+1
.8cf7					_CREExit:
.8cf7	a0 03		ldy #$03			ldy 	#3 							; scan start position.
.8cf9	b2 30		lda ($30)			lda 	(codePtr)
.8cfb	d0 0c		bne $8d09			bne 	_SFWExit 					; if not zero, more to scan
.8cfd	a9 13		lda #$13		lda	#19
.8cff	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.8d02					_ScanSkipData:
.8d02	88		dey				dey 								; point at data token
.8d03	c8		iny				iny
.8d04	98		tya				tya
.8d05	38		sec				sec
.8d06	71 30		adc ($30),y			adc 	(codePtr),y
.8d08	a8		tay				tay
.8d09					_SFWExit:
.8d09	60		rts				rts
.8d0a					ScanGetCurrentLineStep:
.8d0a	64 38		stz $38				stz 	zTemp1
.8d0c	a0 03		ldy #$03			ldy 	#3
.8d0e					_SGCLSLoop:
.8d0e	b1 30		lda ($30),y			lda 	(codePtr),y
.8d10	c8		iny				iny
.8d11	c9 80		cmp #$80			cmp 	#KWC_EOL	 				; if EOL exit
.8d13	f0 05		beq $8d1a			beq 	_SGCLSExit
.8d15	20 c7 8c	jsr $8cc7			jsr 	ScanForwardOne
.8d18	80 f4		bra $8d0e			bra 	_SGCLSLoop
.8d1a					_SGCLSExit:
.8d1a	a5 38		lda $38				lda 	zTemp1
.8d1c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/while.asm

.8d1d					Command_WHILE:
.8d1d	5a		phy				phy 								; save position of the test
.8d1e	a2 00		ldx #$00			ldx 	#0
.8d20	20 51 9d	jsr $9d51			jsr 	EvaluateNumber 				; work out the number
.8d23	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; check if zero
.8d26	f0 0e		beq $8d36			beq 	_WHExitLoop 				; if so exit the loop
.8d28	98		tya				tya 								; position *after* test.
.8d29	7a		ply				ply 								; restore position before test, at WHILE
.8d2a	88		dey				dey
.8d2b	48		pha				pha 								; push after test on the stack
.8d2c	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; allocate 6 bytes on the return stack.
.8d2e	20 9e a6	jsr $a69e			jsr 	StackOpen
.8d31	20 e2 a6	jsr $a6e2			jsr 	STKSaveCodePosition 		; save loop position - where the test value is.
.8d34	7a		ply				ply 								; restore the position *after* the test
.8d35	60		rts				rts
.8d36					_WHExitLoop:
.8d36	68		pla				pla 								; throw post loop position
.8d37	a9 aa		lda #$aa			lda 	#KWD_WEND 					; scan forward past WEND
.8d39	aa		tax				tax
.8d3a	20 a7 8c	jsr $8ca7			jsr 	ScanForward
.8d3d	60		rts				rts
.8d3e					Command_WEND:
.8d3e	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; check WHILE is TOS
.8d40	a2 10		ldx #$10			ldx 	#ERRID_WHILE 				; this error
.8d42	20 ca a6	jsr $a6ca			jsr 	StackCheckFrame
.8d45	20 f3 a6	jsr $a6f3			jsr 	STKLoadCodePosition 		; loop back
.8d48	20 bc a6	jsr $a6bc			jsr 	StackClose		 			; erase the frame
.8d4b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/charcheck.asm

.8d4c					CheckRightBracket:
.8d4c	b1 30		lda ($30),y			lda 	(codePtr),y
.8d4e	c8		iny				iny
.8d4f	c9 29		cmp #$29			cmp 	#KWD_RPAREN 						; exit if matches
.8d51	d0 0f		bne $8d62			bne 	CNAFail
.8d53	60		rts				rts
.8d54					CheckComma:
.8d54	b1 30		lda ($30),y			lda 	(codePtr),y
.8d56	c8		iny				iny
.8d57	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 						; exit if matches
.8d59	d0 07		bne $8d62			bne 	CNAFail
.8d5b	60		rts				rts
.8d5c					CheckNextA:
.8d5c	d1 30		cmp ($30),y			cmp 	(codePtr),y
.8d5e	d0 02		bne $8d62			bne 	CNAFail
.8d60	c8		iny				iny 								; skip character
.8d61	60		rts				rts 								; and exit
.8d62					CNAFail:
.8d62	4c b2 9f	jmp $9fb2			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/errors.asm

.8d65					ErrorHandler:
.8d65	a8		tay				tay 								; find the error text
.8d66	f0 49		beq $8db1			beq 	_EHEnd
.8d68	a2 00		ldx #$00			ldx 	#0
.8d6a	a9 cb		lda #$cb			lda 	#((ErrorText) & $FF)
.8d6c	85 36		sta $36				sta 	0+zTemp0
.8d6e	a9 9f		lda #$9f			lda 	#((ErrorText) >> 8)
.8d70	85 37		sta $37				sta 	1+zTemp0
.8d72					_EHFind:
.8d72	88		dey				dey 								; found the error text ?
.8d73	f0 0e		beq $8d83			beq 	_EHFound
.8d75					_EHFindZero:
.8d75	b2 36		lda ($36)			lda 	(zTemp0) 					; find the next error
.8d77	e6 36		inc $36				inc 	zTemp0
.8d79	d0 02		bne $8d7d			bne 	_EHFNoCarry
.8d7b	e6 37		inc $37				inc 	zTemp0+1
.8d7d					_EHFNoCarry:
.8d7d	c9 00		cmp #$00			cmp 	#0
.8d7f	d0 f4		bne $8d75			bne 	_EHFindZero
.8d81	80 ef		bra $8d72			bra 	_EHFind
.8d83					_EHFound:
.8d83	a5 36		lda $36				lda 	zTemp0 						; print message
.8d85	a6 37		ldx $37				ldx 	zTemp0+1
.8d87	20 be 8d	jsr $8dbe			jsr 	PrintStringXA
.8d8a	a0 01		ldy #$01			ldy 	#1 							; if line number zero don't print i
.8d8c	b1 30		lda ($30),y			lda 	(codePtr),y
.8d8e	d0 05		bne $8d95			bne 	_EHAtMsg
.8d90	c8		iny				iny
.8d91	b1 30		lda ($30),y			lda 	(codePtr),y
.8d93	f0 17		beq $8dac			beq 	_EHCREnd
.8d95					_EHAtMsg:
.8d95	a2 8d		ldx #$8d			ldx 	#_AtMsg >> 8 				; print " at "
.8d97	a9 b4		lda #$b4			lda 	#_AtMsg & $FF
.8d99	20 be 8d	jsr $8dbe			jsr 	PrintStringXA
.8d9c	a0 01		ldy #$01			ldy 	#1 							; line number into XA
.8d9e	b1 30		lda ($30),y			lda 	(codePtr),y
.8da0	48		pha				pha
.8da1	c8		iny				iny
.8da2	b1 30		lda ($30),y			lda 	(codePtr),y
.8da4	aa		tax				tax
.8da5	68		pla				pla
.8da6	20 77 92	jsr $9277			jsr 	LCLConvertInt16 				; convert XA to string
.8da9	20 be 8d	jsr $8dbe			jsr 	PrintStringXA 				; and print it.
.8dac					_EHCREnd:
.8dac	a9 0d		lda #$0d			lda 	#13 						; new line
.8dae	20 de a7	jsr $a7de			jsr 	EXTPrintCharacter
.8db1					_EHEnd:
.8db1	4c 54 83	jmp $8354			jmp 	WarmStart
>8db4	20 61 74 20 6c 69 6e 65		_AtMsg:	.text 	" at line ",0
>8dbc	20 00
.8dbe					PrintStringXA:
.8dbe	5a		phy				phy
.8dbf	86 37		stx $37				stx 	zTemp0+1
.8dc1	85 36		sta $36				sta 	zTemp0
.8dc3	a0 00		ldy #$00			ldy 	#0
.8dc5					_PSXALoop:
.8dc5	b1 36		lda ($36),y			lda 	(zTemp0),y
.8dc7	f0 06		beq $8dcf			beq 	_PSXAExit
.8dc9	20 de a7	jsr $a7de			jsr 	EXTPrintCharacter
.8dcc	c8		iny				iny
.8dcd	80 f6		bra $8dc5			bra 	_PSXALoop
.8dcf					_PSXAExit:
.8dcf	7a		ply				ply
.8dd0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/compare.asm

.8dd1					UnaryTrue:
.8dd1	fa		plx				plx
.8dd2					ReturnTrue:
.8dd2	a9 01		lda #$01			lda 	#1  						; set to 1
.8dd4	20 2a 9e	jsr $9e2a			jsr 	NSMSetByte
.8dd7	a9 80		lda #$80			lda 	#$80 						; set sign flag, so it is -1
.8dd9	9d 00 04	sta $0400,x			sta 	NSStatus,x
.8ddc	60		rts				rts
.8ddd					UnaryFalse:
.8ddd	fa		plx				plx
.8dde					ReturnFalse:
.8dde	4c 28 9e	jmp $9e28			jmp 	NSMSetZero 					; set it all to zero
.8de1					BinaryCompareEqual:
.8de1	fa		plx				plx
.8de2	20 1d 8e	jsr $8e1d			jsr 	CompareBaseCode
.8de5	c9 00		cmp #$00			cmp 	#0
.8de7	f0 e9		beq $8dd2			beq 	ReturnTrue
.8de9	80 f3		bra $8dde			bra 	ReturnFalse
.8deb					BinaryCompareLess:
.8deb	fa		plx				plx
.8dec	20 1d 8e	jsr $8e1d			jsr 	CompareBaseCode
.8def	c9 ff		cmp #$ff			cmp 	#$FF
.8df1	f0 df		beq $8dd2			beq 	ReturnTrue
.8df3	80 e9		bra $8dde			bra 	ReturnFalse
.8df5					BinaryCompareGreater:
.8df5	fa		plx				plx
.8df6	20 1d 8e	jsr $8e1d			jsr 	CompareBaseCode
.8df9	c9 01		cmp #$01			cmp 	#1
.8dfb	f0 d5		beq $8dd2			beq 	ReturnTrue
.8dfd	80 df		bra $8dde			bra 	ReturnFalse
.8dff					BinaryCompareNotEqual:
.8dff	fa		plx				plx
.8e00	20 1d 8e	jsr $8e1d			jsr 	CompareBaseCode
.8e03	c9 00		cmp #$00			cmp 	#0
.8e05	d0 cb		bne $8dd2			bne 	ReturnTrue
.8e07	80 d5		bra $8dde			bra 	ReturnFalse
.8e09					BinaryCompareLessEqual:
.8e09	fa		plx				plx
.8e0a	20 1d 8e	jsr $8e1d			jsr 	CompareBaseCode
.8e0d	c9 01		cmp #$01			cmp 	#1
.8e0f	d0 c1		bne $8dd2			bne 	ReturnTrue
.8e11	80 cb		bra $8dde			bra 	ReturnFalse
.8e13					BinaryCompareGreaterEqual:
.8e13	fa		plx				plx
.8e14	20 1d 8e	jsr $8e1d			jsr 	CompareBaseCode
.8e17	c9 ff		cmp #$ff			cmp 	#$FF
.8e19	d0 b7		bne $8dd2			bne 	ReturnTrue
.8e1b	80 c1		bra $8dde			bra 	ReturnFalse
.8e1d					CompareBaseCode:
.8e1d	20 2d 96	jsr $962d			jsr 	DereferenceTopTwo 			; make both values if references.
.8e20	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if either is a string.
.8e23	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8e26	29 10		and #$10			and 	#NSTString
.8e28	d0 40		bne $8e6a			bne 	_CBCString
.8e2a	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check both are integers
.8e2d	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8e30	d0 3b		bne $8e6d			bne 	_CBCFloat
.8e32	bd 00 04	lda $0400,x			lda 	NSStatus,x
.8e35	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8e38	29 08		and #$08			and 	#NSTFloat
.8e3a	d0 31		bne $8e6d			bne 	_CBCFloat
.8e3c	20 70 8e	jsr $8e70			jsr 	CompareFixMinusZero
.8e3f	e8		inx				inx
.8e40	20 70 8e	jsr $8e70			jsr 	CompareFixMinusZero
.8e43	ca		dex				dex
.8e44	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; are the signs different ?
.8e47	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.8e4a	10 0b		bpl $8e57			bpl 	_CDCSameSign
.8e4c	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; if first one is -ve
.8e4f	30 16		bmi $8e67			bmi 	_CBCLess 					; return $FF
.8e51					_CBCGreater:
.8e51	a9 01		lda #$01			lda 	#1
.8e53	60		rts				rts
.8e54					_CBCEqual:
.8e54	a9 00		lda #$00			lda 	#0
.8e56	60		rts				rts
.8e57					_CDCSameSign:
.8e57	20 c3 90	jsr $90c3			jsr 	SubTopTwoStack 				; unsigned subtract
.8e5a	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; or the mantissa together
.8e5d	f0 f5		beq $8e54			beq 	_CBCEqual 					; -0 == 0
.8e5f	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; sign of the result. if +ve return $01 else return $FF
.8e62	5d 01 04	eor $0401,x			eor 	NSStatus+1,x 				; however if both were -ve this is inverted
.8e65	10 ea		bpl $8e51			bpl 	_CBCGreater
.8e67					_CBCLess:
.8e67	a9 ff		lda #$ff			lda 	#$FF
.8e69	60		rts				rts
.8e6a					_CBCString:
.8e6a	4c 19 90	jmp $9019			jmp 	CompareStrings
.8e6d					_CBCFloat:
.8e6d	4c fa 93	jmp $93fa			jmp 	CompareFloat
.8e70					CompareFixMinusZero:
.8e70	20 58 9e	jsr $9e58			jsr 	NSMIsZero
.8e73	d0 03		bne $8e78			bne 	_CFXMZNotZero
.8e75	9e 00 04	stz $0400,x			stz 	NSStatus,x
.8e78					_CFXMZNotZero:
.8e78	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/concat.asm

.8e79					StringConcat:
.8e79	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check both strings
.8e7c	3d 01 04	and $0401,x			and 	NSStatus+1,x
.8e7f	29 18		and #$18			and 	#NSBTypeMask
.8e81	c9 10		cmp #$10			cmp 	#NSTString
.8e83	d0 4e		bne $8ed3			bne		_SCType
.8e85	64 38		stz $38				stz 	zTemp1 						; counting total length
.8e87	e8		inx				inx
.8e88	20 a6 8e	jsr $8ea6			jsr 	_SCSetupZ0 					; setup for second
.8e8b	20 b1 8e	jsr $8eb1			jsr 	_SCLengthZ0 				; length for second
.8e8e	ca		dex				dex
.8e8f	20 a6 8e	jsr $8ea6			jsr 	_SCSetupZ0 					; setup for first
.8e92	20 b1 8e	jsr $8eb1			jsr 	_SCLengthZ0 				; length for first
.8e95	a5 38		lda $38				lda 	zTemp1 						; allocate memory
.8e97	20 91 a7	jsr $a791			jsr 	StringTempAllocate
.8e9a	20 c4 8e	jsr $8ec4			jsr 	_SCCopy 					; copy first out, using zTemp0 from above
.8e9d	e8		inx				inx
.8e9e	20 a6 8e	jsr $8ea6			jsr 	_SCSetupZ0 					; copy second out
.8ea1	20 c4 8e	jsr $8ec4			jsr 	_SCCopy
.8ea4	ca		dex				dex
.8ea5	60		rts				rts
.8ea6					_SCSetupZ0:
.8ea6	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.8ea9	85 36		sta $36				sta 	zTemp0
.8eab	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.8eae	85 37		sta $37				sta 	zTemp0+1
.8eb0	60		rts				rts
.8eb1					_SCLengthZ0:
.8eb1	5a		phy				phy
.8eb2	a0 00		ldy #$00			ldy 	#0
.8eb4					_SCLenLoop:
.8eb4	b1 36		lda ($36),y			lda 	(zTemp0),y
.8eb6	f0 0a		beq $8ec2			beq 	_SCLExit
.8eb8	c8		iny				iny
.8eb9	e6 38		inc $38				inc 	zTemp1
.8ebb	10 f7		bpl $8eb4			bpl		_SCLenLoop
.8ebd	a9 09		lda #$09		lda	#9
.8ebf	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.8ec2					_SCLExit:
.8ec2	7a		ply				ply
.8ec3	60		rts				rts
.8ec4					_SCCopy:
.8ec4	5a		phy				phy
.8ec5	a0 00		ldy #$00			ldy 	#0
.8ec7					_SCCopyLoop:
.8ec7	b1 36		lda ($36),y			lda 	(zTemp0),y
.8ec9	f0 06		beq $8ed1			beq 	_SCCExit
.8ecb	20 cf a7	jsr $a7cf			jsr 	StringTempWrite
.8ece	c8		iny				iny
.8ecf	80 f6		bra $8ec7			bra 	_SCCopyLoop
.8ed1					_SCCExit:
.8ed1	7a		ply				ply
.8ed2	60		rts				rts
.8ed3					_SCType:
.8ed3	4c bc 9f	jmp $9fbc			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/divide.asm

.8ed6					IntegerDivide:
.8ed6	fa		plx				plx
.8ed7	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.8eda	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8edd	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8ede	0a		asl a				asl 	a
.8edf	10 05		bpl $8ee6			bpl 	_NotRef
.8ee1	48		pha				pha
.8ee2	20 2d 96	jsr $962d			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8ee5	68		pla				pla
.8ee6					_NotRef:
.8ee6	0a		asl a				asl 	a
.8ee7	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.8ee9	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8eec	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8eef	f0 03		beq $8ef4			beq 	_IntegerCode 				; if clear, then we have two integers
.8ef1	4c bc 9f	jmp $9fbc			jmp 	TypeError 					; anything else, type mismatch.
.8ef4					_IntegerCode:
.8ef4	20 16 8f	jsr $8f16			jsr 	CheckDivideZero 			; do div zero check
.8ef7	20 4e 8f	jsr $8f4e			jsr 	Int32Divide 				; do the division
.8efa	20 0b 90	jsr $900b			jsr 	CalculateSign 				; calculate result sign
.8efd					NSMCopyPlusTwoToZero:
.8efd	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.8f00	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.8f03	bd 12 04	lda $0412,x			lda 	NSMantissa1+2,x
.8f06	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.8f09	bd 1a 04	lda $041a,x			lda 	NSMantissa2+2,x
.8f0c	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.8f0f	bd 22 04	lda $0422,x			lda 	NSMantissa3+2,x
.8f12	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.8f15	60		rts				rts
.8f16					CheckDivideZero:
.8f16	e8		inx				inx
.8f17	20 58 9e	jsr $9e58			jsr 	NSMIsZero
.8f1a	f0 02		beq $8f1e			beq 	_CDVError
.8f1c	ca		dex				dex
.8f1d	60		rts				rts
.8f1e					_CDVError:
.8f1e	a9 03		lda #$03		lda	#3
.8f20	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.8f23					IntegerModulus:
.8f23	fa		plx				plx
.8f24	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.8f27	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8f2a	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8f2b	0a		asl a				asl 	a
.8f2c	10 05		bpl $8f33			bpl 	_NotRef
.8f2e	48		pha				pha
.8f2f	20 2d 96	jsr $962d			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8f32	68		pla				pla
.8f33					_NotRef:
.8f33	0a		asl a				asl 	a
.8f34	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.8f36	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8f39	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8f3c	f0 03		beq $8f41			beq 	_IntegerCode 				; if clear, then we have two integers
.8f3e	4c bc 9f	jmp $9fbc			jmp 	TypeError 					; anything else, type mismatch.
.8f41					_IntegerCode:
.8f41					IntegerModulusNoCheck:
.8f41	20 16 8f	jsr $8f16			jsr 	CheckDivideZero 			; do div zero check
.8f44	20 4e 8f	jsr $8f4e			jsr 	Int32Divide 				; do the division
.8f47	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; clear the sign bit.
.8f4a	5e 00 04	lsr $0400,x			lsr 	NSStatus,x
.8f4d	60		rts				rts
.8f4e					Int32Divide:
.8f4e	48		pha				pha 								; save AXY
.8f4f	5a		phy				phy
.8f50	20 ff 9d	jsr $9dff			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.8f53	20 24 9e	jsr $9e24			jsr 	NSMSetZeroMantissaOnly 		; set S[X] to zero
.8f56	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.8f58					_I32DivideLoop:
.8f58	e8		inx				inx
.8f59	e8		inx				inx
.8f5a	20 3d 9e	jsr $9e3d			jsr 	NSMShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.8f5d	ca		dex				dex
.8f5e	ca		dex				dex
.8f5f	20 3e 9e	jsr $9e3e			jsr 	NSMRotateLeft
.8f62	20 8e 8f	jsr $8f8e			jsr 	DivideCheckSubtract 		; check if subtract possible
.8f65	90 03		bcc $8f6a			bcc 	_I32DivideNoCarryIn
.8f67	fe 0a 04	inc $040a,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.8f6a					_I32DivideNoCarryIn:
.8f6a	88		dey				dey 								; loop round till division completed.
.8f6b	d0 eb		bne $8f58			bne 	_I32DivideLoop
.8f6d	7a		ply				ply 								; restore AXY and exit
.8f6e	68		pla				pla
.8f6f	60		rts				rts
.8f70					Int32ShiftDivide:
.8f70	48		pha				pha 								; save AY
.8f71	5a		phy				phy
.8f72	e8		inx				inx 								; clear S[X+2]
.8f73	e8		inx				inx
.8f74	20 28 9e	jsr $9e28			jsr 	NSMSetZero
.8f77	ca		dex				dex
.8f78	ca		dex				dex
.8f79	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.8f7b					_I32SDLoop:
.8f7b	20 8e 8f	jsr $8f8e			jsr 	DivideCheckSubtract 		; check if subtract possible
.8f7e	e8		inx				inx
.8f7f	e8		inx				inx
.8f80	20 3e 9e	jsr $9e3e			jsr 	NSMRotateLeft				; shift 64 bit FPA left, rotating carry in
.8f83	ca		dex				dex
.8f84	ca		dex				dex
.8f85	20 3e 9e	jsr $9e3e			jsr 	NSMRotateLeft
.8f88	88		dey				dey 	 							; do 31 times
.8f89	d0 f0		bne $8f7b			bne 	_I32SDLoop
.8f8b	7a		ply				ply 								; restore AY and exit
.8f8c	68		pla				pla
.8f8d	60		rts				rts
.8f8e					DivideCheckSubtract:
.8f8e	20 c3 90	jsr $90c3			jsr 	SubTopTwoStack 				; subtract Stack[X+1] from Stack[X+0]
.8f91	b0 04		bcs $8f97			bcs 	_DCSExit 					; if carry set, then could do, exit
.8f93	20 9d 90	jsr $909d			jsr 	AddTopTwoStack 				; add it back in
.8f96	18		clc				clc 								; and return False
.8f97					_DCSExit:
.8f97	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/multiply.asm

.8f98					MulInteger:
.8f98	fa		plx				plx
.8f99	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.8f9c	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8f9f	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8fa0	0a		asl a				asl 	a
.8fa1	10 05		bpl $8fa8			bpl 	_NotRef
.8fa3	48		pha				pha
.8fa4	20 2d 96	jsr $962d			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8fa7	68		pla				pla
.8fa8					_NotRef:
.8fa8	0a		asl a				asl 	a 							; put MSB of type into A:7
.8fa9	30 0b		bmi $8fb6			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.8fab	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8fae	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8fb1	f0 06		beq $8fb9			beq 	_IntegerCode 				; if clear, then we have two integers
.8fb3	4c d1 94	jmp $94d1			jmp 	FloatingPointMultiply 							; otherwise at least one float.
.8fb6					_StringData:
.8fb6	4c c6 9f	jmp $9fc6			jmp 	NotDoneError							; at least one string - don't know both are strings.
.8fb9					_IntegerCode:
.8fb9	20 c6 8f	jsr $8fc6			jsr 	MultiplyShort
.8fbc	c9 00		cmp #$00			cmp 	#0
.8fbe	f0 05		beq $8fc5			beq 	_MIExit
.8fc0	a9 04		lda #$04		lda	#4
.8fc2	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.8fc5					_MIExit:
.8fc5	60		rts				rts
.8fc6					MultiplyShort:
.8fc6	5a		phy				phy 								; save Y
.8fc7	20 ff 9d	jsr $9dff			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.8fca	20 24 9e	jsr $9e24			jsr 	NSMSetZeroMantissaOnly 		; set mantissa S[X] to zero
.8fcd	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.8fcf					_I32MLoop:
.8fcf	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.8fd2	1d 12 04	ora $0412,x			ora 	NSMantissa1+2,x
.8fd5	1d 1a 04	ora $041a,x			ora 	NSMantissa2+2,x
.8fd8	1d 22 04	ora $0422,x			ora 	NSMantissa3+2,x
.8fdb	f0 28		beq $9005			beq 	_I32MExit 					; exit if zero
.8fdd	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.8fe0	29 01		and #$01			and 	#1
.8fe2	f0 0e		beq $8ff2			beq 	_I32MNoAdd
.8fe4	20 9d 90	jsr $909d			jsr 	AddTopTwoStack 				; if so add S[X+1] to S[X+0]
.8fe7	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.8fea	10 06		bpl $8ff2			bpl 	_I32MNoAdd
.8fec					_I32ShiftRight:
.8fec	20 4b 9e	jsr $9e4b			jsr 	NSMShiftRight 				; shift S[X] right
.8fef	c8		iny				iny 								; increment shift count
.8ff0	80 0a		bra $8ffc			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.8ff2					_I32MNoAdd:
.8ff2	3c 21 04	bit $0421,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.8ff5	70 f5		bvs $8fec			bvs 	_I32ShiftRight 				; instead.
.8ff7	e8		inx				inx
.8ff8	20 3d 9e	jsr $9e3d			jsr 	NSMShiftLeft 				; shift additive S[X+1] left
.8ffb	ca		dex				dex
.8ffc					_I32MShiftUpper:
.8ffc	e8		inx				inx 								; shift S[X+2] right
.8ffd	e8		inx				inx
.8ffe	20 4b 9e	jsr $9e4b			jsr 	NSMShiftRight
.9001	ca		dex				dex
.9002	ca		dex				dex
.9003	80 ca		bra $8fcf			bra 	_I32MLoop 					; try again.
.9005					_I32MExit:
.9005	20 0b 90	jsr $900b			jsr 	CalculateSign
.9008	98		tya				tya 								; shift in A
.9009	7a		ply				ply 								; restore Y and exit
.900a	60		rts				rts
.900b					CalculateSign:
.900b	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.900e	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; shift result left
.9011	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.9014	0a		asl a				asl 	a 							; shift bit 7 into carry
.9015	7e 00 04	ror $0400,x			ror 	NSStatus,x 					; shift right into status byte.
.9018	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/scompare.asm

.9019					CompareStrings:
.9019	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check both are strings
.901c	3d 01 04	and $0401,x			and 	NSStatus+1,x
.901f	29 10		and #$10			and 	#NSBIsString
.9021	f0 2c		beq $904f			beq 	_CSTypeError
.9023	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy string addresses to zTemp0/1
.9026	85 36		sta $36				sta 	zTemp0
.9028	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.902b	85 37		sta $37				sta 	zTemp0+1
.902d	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.9030	85 38		sta $38				sta 	zTemp1
.9032	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.9035	85 39		sta $39				sta 	zTemp1+1
.9037	5a		phy				phy 								; save Y so we can access strings
.9038	a0 ff		ldy #$ff			ldy 	#$FF 						; -1 for pre increment.
.903a					_CSLoop:
.903a	c8		iny				iny
.903b	b1 36		lda ($36),y			lda 	(zTemp0),y 					; check if they are the same
.903d	d1 38		cmp ($38),y			cmp 	(zTemp1),y
.903f	d0 06		bne $9047			bne 	_CSDifferent
.9041	c9 00		cmp #$00			cmp 	#0 							; reached end ?
.9043	d0 f5		bne $903a			bne 	_CSLoop 					; still comparing
.9045					_CSExit:
.9045	7a		ply				ply 								; reached end, return zero in A from EOS
.9046	60		rts				rts
.9047					_CSDifferent:
.9047	a9 ff		lda #$ff			lda 	#255 						; if < return $FF
.9049	90 fa		bcc $9045			bcc		_CSExit
.904b	a9 01		lda #$01			lda 	#1 							; otherwise return 1.
.904d	80 f6		bra $9045			bra 	_CSExit
.904f					_CSTypeError:
.904f	4c bc 9f	jmp $9fbc			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/shifts.asm

.9052					ShiftLeft:
.9052	38		sec				sec
.9053	80 01		bra $9056			bra 	ShiftMain
.9055					ShiftRight:
.9055	18		clc				clc
.9056					ShiftMain:
.9056	fa		plx				plx 								; restore X
.9057	08		php				php 								; save direction
.9058	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.905b	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.905e	0a		asl a				asl 	a 							; shift reference bit into sign bit
.905f	0a		asl a				asl 	a
.9060	10 05		bpl $9067			bpl 	_NotRef
.9062	48		pha				pha
.9063	20 2d 96	jsr $962d			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9066	68		pla				pla
.9067					_NotRef:
.9067	0a		asl a				asl 	a
.9068	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.906a	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.906d	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9070	f0 03		beq $9075			beq 	_IntegerCode 				; if clear, then we have two integers
.9072	4c bc 9f	jmp $9fbc			jmp 	TypeError 					; anything else, type mismatch.
.9075					_IntegerCode:
.9075	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; check number < 32
.9078	29 e0		and #$e0			and 	#$E0
.907a	1d 11 04	ora $0411,x			ora 	NSMantissa1+1,x
.907d	1d 19 04	ora $0419,x			ora 	NSMantissa2+1,x
.9080	1d 21 04	ora $0421,x			ora 	NSMantissa3+1,x
.9083	d0 13		bne $9098			bne 	_SMExit0 					; if >= 32 it will always return zero.
.9085					_SMLoop:
.9085	de 09 04	dec $0409,x			dec 	NSMantissa0+1,x 			; predecrement, could do << 0
.9088	30 11		bmi $909b			bmi 	_SMExit 					; exit if done.
.908a	28		plp				plp 								; restore direcition setting
.908b	08		php				php
.908c	90 05		bcc $9093			bcc 	_SMRight
.908e	20 3d 9e	jsr $9e3d			jsr 	NSMShiftLeft 				; shift left if CS
.9091	80 f2		bra $9085			bra 	_SMLoop
.9093					_SMRight:
.9093	20 4b 9e	jsr $9e4b			jsr 	NSMShiftRight 				; shift right if CC
.9096	80 ed		bra $9085			bra 	_SMLoop
.9098					_SMExit0:
.9098	20 28 9e	jsr $9e28			jsr 	NSMSetZero 					; return zero.
.909b					_SMExit:
.909b	28		plp				plp 								; throw direction
.909c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/simple.asm

.909d					AddTopTwoStack:
.909d	18		clc				clc
.909e	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.90a1	7d 09 04	adc $0409,x			adc 		NSMantissa0+1,x
.90a4	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.90a7	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.90aa	7d 11 04	adc $0411,x			adc 		NSMantissa1+1,x
.90ad	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.90b0	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.90b3	7d 19 04	adc $0419,x			adc 		NSMantissa2+1,x
.90b6	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.90b9	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.90bc	7d 21 04	adc $0421,x			adc 		NSMantissa3+1,x
.90bf	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.90c2	60		rts				rts
.90c3					SubTopTwoStack:
.90c3	38		sec				sec
.90c4	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.90c7	fd 09 04	sbc $0409,x			sbc 		NSMantissa0+1,x
.90ca	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.90cd	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.90d0	fd 11 04	sbc $0411,x			sbc 		NSMantissa1+1,x
.90d3	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.90d6	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.90d9	fd 19 04	sbc $0419,x			sbc 		NSMantissa2+1,x
.90dc	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.90df	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.90e2	fd 21 04	sbc $0421,x			sbc 		NSMantissa3+1,x
.90e5	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.90e8	60		rts				rts
.90e9					AddInteger:
.90e9	fa		plx				plx
.90ea	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.90ed	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.90f0	0a		asl a				asl 	a 							; shift reference bit into sign bit
.90f1	0a		asl a				asl 	a
.90f2	10 05		bpl $90f9			bpl 	_NotRef
.90f4	48		pha				pha
.90f5	20 2d 96	jsr $962d			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.90f8	68		pla				pla
.90f9					_NotRef:
.90f9	0a		asl a				asl 	a 							; put MSB of type into A:7
.90fa	30 0b		bmi $9107			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.90fc	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.90ff	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9102	f0 06		beq $910a			beq 	_IntegerCode 				; if clear, then we have two integers
.9104	4c 51 93	jmp $9351			jmp 	FloatingPointAdd 							; otherwise at least one float.
.9107					_StringData:
.9107	4c 79 8e	jmp $8e79			jmp 	StringConcat							; at least one string - don't know both are strings.
.910a					_IntegerCode:
.910a					AddCode:
.910a	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.910d	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.9110	10 8b		bpl $909d			bpl 	AddTopTwoStack
.9112	20 c3 90	jsr $90c3			jsr 	SubTopTwoStack 				; do a physical subtraction
.9115	3c 20 04	bit $0420,x			bit 	NSMantissa3,x 				; result is +ve, okay
.9118	10 09		bpl $9123			bpl 	_AddExit
.911a	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; sign is that of 2nd value
.911d	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9120	20 dd 9d	jsr $9ddd			jsr 	NSMNegateMantissa 			; negate the mantissa and exit
.9123					_AddExit:
.9123	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; check for -0
.9126	d0 03		bne $912b			bne 	_AddNonZero
.9128	9e 00 04	stz $0400,x			stz 	NSStatus,x
.912b					_AddNonZero:
.912b	60		rts				rts
.912c					SubInteger:
.912c	fa		plx				plx
.912d	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9130	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9133	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9134	0a		asl a				asl 	a
.9135	10 05		bpl $913c			bpl 	_NotRef
.9137	48		pha				pha
.9138	20 2d 96	jsr $962d			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.913b	68		pla				pla
.913c					_NotRef:
.913c	0a		asl a				asl 	a 							; put MSB of type into A:7
.913d	30 0b		bmi $914a			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.913f	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9142	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9145	f0 06		beq $914d			beq 	_IntegerCode 				; if clear, then we have two integers
.9147	4c 56 93	jmp $9356			jmp 	FloatingPointSub 							; otherwise at least one float.
.914a					_StringData:
.914a	4c c6 9f	jmp $9fc6			jmp 	NotDoneError							; at least one string - don't know both are strings.
.914d					_IntegerCode:
.914d	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; negate the second value.
.9150	49 80		eor #$80			eor 	#$80
.9152	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.9155	80 b3		bra $910a			bra 	AddCode 					; and do the same code as add.
.9157					AndInteger:
.9157	fa		plx				plx
.9158	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.915b	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.915e	0a		asl a				asl 	a 							; shift reference bit into sign bit
.915f	0a		asl a				asl 	a
.9160	10 05		bpl $9167			bpl 	_NotRef
.9162	48		pha				pha
.9163	20 2d 96	jsr $962d			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9166	68		pla				pla
.9167					_NotRef:
.9167	0a		asl a				asl 	a
.9168	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.916a	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.916d	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9170	f0 03		beq $9175			beq 	_IntegerCode 				; if clear, then we have two integers
.9172	4c bc 9f	jmp $9fbc			jmp 	TypeError 					; anything else, type mismatch.
.9175					_IntegerCode:
.9175	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.9178	3d 09 04	and $0409,x			and 		NSMantissa0+1,x
.917b	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.917e	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.9181	3d 11 04	and $0411,x			and 		NSMantissa1+1,x
.9184	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9187	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.918a	3d 19 04	and $0419,x			and 		NSMantissa2+1,x
.918d	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9190	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.9193	3d 21 04	and $0421,x			and 		NSMantissa3+1,x
.9196	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9199	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.919c	60		rts				rts
.919d					OraInteger:
.919d	fa		plx				plx
.919e	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.91a1	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.91a4	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91a5	0a		asl a				asl 	a
.91a6	10 05		bpl $91ad			bpl 	_NotRef
.91a8	48		pha				pha
.91a9	20 2d 96	jsr $962d			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91ac	68		pla				pla
.91ad					_NotRef:
.91ad	0a		asl a				asl 	a
.91ae	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.91b0	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91b3	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.91b6	f0 03		beq $91bb			beq 	_IntegerCode 				; if clear, then we have two integers
.91b8	4c bc 9f	jmp $9fbc			jmp 	TypeError 					; anything else, type mismatch.
.91bb					_IntegerCode:
.91bb	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.91be	1d 09 04	ora $0409,x			ora 		NSMantissa0+1,x
.91c1	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.91c4	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.91c7	1d 11 04	ora $0411,x			ora 		NSMantissa1+1,x
.91ca	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.91cd	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.91d0	1d 19 04	ora $0419,x			ora 		NSMantissa2+1,x
.91d3	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.91d6	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.91d9	1d 21 04	ora $0421,x			ora 		NSMantissa3+1,x
.91dc	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.91df	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.91e2	60		rts				rts
.91e3					EorInteger:
.91e3	fa		plx				plx
.91e4	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.91e7	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.91ea	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91eb	0a		asl a				asl 	a
.91ec	10 05		bpl $91f3			bpl 	_NotRef
.91ee	48		pha				pha
.91ef	20 2d 96	jsr $962d			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91f2	68		pla				pla
.91f3					_NotRef:
.91f3	0a		asl a				asl 	a
.91f4	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.91f6	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91f9	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.91fc	f0 03		beq $9201			beq 	_IntegerCode 				; if clear, then we have two integers
.91fe	4c bc 9f	jmp $9fbc			jmp 	TypeError 					; anything else, type mismatch.
.9201					_IntegerCode:
.9201	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.9204	5d 09 04	eor $0409,x			eor 		NSMantissa0+1,x
.9207	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.920a	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.920d	5d 11 04	eor $0411,x			eor 		NSMantissa1+1,x
.9210	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9213	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.9216	5d 19 04	eor $0419,x			eor 		NSMantissa2+1,x
.9219	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.921c	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.921f	5d 21 04	eor $0421,x			eor 		NSMantissa3+1,x
.9222	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9225	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.9228	60		rts				rts
.9229					WordIndirect:
.9229	fa		plx				plx
.922a	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.922d	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9230	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9231	0a		asl a				asl 	a
.9232	10 05		bpl $9239			bpl 	_NotRef
.9234	48		pha				pha
.9235	20 2d 96	jsr $962d			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9238	68		pla				pla
.9239					_NotRef:
.9239	0a		asl a				asl 	a
.923a	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.923c	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.923f	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9242	f0 03		beq $9247			beq 	_IntegerCode 				; if clear, then we have two integers
.9244	4c bc 9f	jmp $9fbc			jmp 	TypeError 					; anything else, type mismatch.
.9247					_IntegerCode:
.9247	20 0a 91	jsr $910a			jsr 	AddCode 					; add the two values
.924a	a9 22		lda #$22			lda 	#NSBIsReference+2 			; make a 2 byte reference
.924c	9d 00 04	sta $0400,x			sta 	NSStatus,x
.924f	60		rts				rts
.9250					ByteIndirect:
.9250	fa		plx				plx
.9251	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9254	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9257	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9258	0a		asl a				asl 	a
.9259	10 05		bpl $9260			bpl 	_NotRef
.925b	48		pha				pha
.925c	20 2d 96	jsr $962d			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.925f	68		pla				pla
.9260					_NotRef:
.9260	0a		asl a				asl 	a
.9261	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9263	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9266	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9269	f0 03		beq $926e			beq 	_IntegerCode 				; if clear, then we have two integers
.926b	4c bc 9f	jmp $9fbc			jmp 	TypeError 					; anything else, type mismatch.
.926e					_IntegerCode:
.926e	20 0a 91	jsr $910a			jsr 	AddCode 					; add the two values
.9271	a9 21		lda #$21			lda 	#NSBIsReference+1 			; make a 1 byte reference
.9273	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9276	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/tostring.asm

.9277					LCLConvertInt16:
.9277	8d 08 04	sta $0408			sta 	NSMantissa0 				; set up as 32 bit conversion
.927a	8e 10 04	stx $0410			stx 	NSMantissa1
.927d	9c 18 04	stz $0418			stz 	NSMantissa2
.9280	9c 20 04	stz $0420			stz 	NSMantissa3
.9283	9c 00 04	stz $0400			stz 	NSStatus 					; positive integer
.9286	a2 00		ldx #$00			ldx 	#0 							; stack level
.9288	a9 0a		lda #$0a			lda 	#10 						; base
.928a	80 00		bra $928c			bra 	ConvertInt32
.928c					ConvertInt32:
.928c	5a		phy				phy
.928d	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.928f	2c 00 04	bit $0400			bit 	NSStatus 					; output a - if not negative.
.9292	10 08		bpl $929c			bpl 	_CI32NotNeg
.9294	48		pha				pha
.9295	a9 2d		lda #$2d			lda 	#'-'
.9297	99 f9 05	sta $05f9,y			sta 	NumberBuffer,y
.929a	c8		iny				iny
.929b	68		pla				pla
.929c					_CI32NotNeg:
.929c	20 aa 92	jsr $92aa			jsr 	_CI32DivideConvert 			; recursive conversion
.929f	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.92a1	99 f9 05	sta $05f9,y			sta 	NumberBuffer,y
.92a4	7a		ply				ply
.92a5	a2 05		ldx #$05			ldx 	#NumberBuffer >> 8
.92a7	a9 f9		lda #$f9			lda 	#NumberBuffer & $FF
.92a9	60		rts				rts
.92aa					_CI32DivideConvert:
.92aa	e8		inx				inx 								; write to next slot up
.92ab	20 2a 9e	jsr $9e2a			jsr 	NSMSetByte
.92ae	ca		dex				dex
.92af	20 4e 8f	jsr $8f4e			jsr 	Int32Divide 				; divide
.92b2	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; save remainder
.92b5	48		pha				pha
.92b6	20 fd 8e	jsr $8efd			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.92b9	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; is it zero ?
.92bc	f0 06		beq $92c4			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.92be	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.92c1	20 aa 92	jsr $92aa			jsr 	_CI32DivideConvert 			; and recusrively call.
.92c4					_CI32NoRecurse:
.92c4	68		pla				pla 								; remainder
.92c5	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.92c7	90 02		bcc $92cb			bcc 	_CI32NotHex
.92c9	69 26		adc #$26			adc 	#6+32
.92cb					_CI32NotHex:
.92cb	69 30		adc #$30			adc 	#48
.92cd	99 f9 05	sta $05f9,y			sta 	NumberBuffer,y 				; write out and exit
.92d0	c8		iny				iny
.92d1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/expression.asm


;******  Processing file: ./common/expressions/../generated/precedence.dat

.92d2					PrecedenceLevel:
>92d2	04					.byte	 4	; $00 <<
>92d3	02					.byte	 2	; $01 <=
>92d4	02					.byte	 2	; $02 <>
>92d5	00					.byte	 0	; $03 !!3
>92d6	00					.byte	 0	; $04 ><
>92d7	02					.byte	 2	; $05 >=
>92d8	04					.byte	 4	; $06 >>
>92d9	00					.byte	 0	; $07 !!7
>92da	00					.byte	 0	; $08 !!8
>92db	00					.byte	 0	; $09 !!9
>92dc	00					.byte	 0	; $0a !!10
>92dd	00					.byte	 0	; $0b !!11
>92de	00					.byte	 0	; $0c !!12
>92df	00					.byte	 0	; $0d !!13
>92e0	00					.byte	 0	; $0e !!14
>92e1	00					.byte	 0	; $0f !!15
>92e2	00					.byte	 0	; $10 @
>92e3	00					.byte	 0	; $11 !!17
>92e4	00					.byte	 0	; $12 !!18
>92e5	00					.byte	 0	; $13 [
>92e6	04					.byte	 4	; $14 \
>92e7	00					.byte	 0	; $15 ]
>92e8	01					.byte	 1	; $16 ^
>92e9	00					.byte	 0	; $17 _
>92ea	00					.byte	 0	; $18 `
>92eb	00					.byte	 0	; $19 !!25
>92ec	00					.byte	 0	; $1a !!26
>92ed	00					.byte	 0	; $1b {
>92ee	01					.byte	 1	; $1c |
>92ef	00					.byte	 0	; $1d }
>92f0	00					.byte	 0	; $1e ~
>92f1	00					.byte	 0	; $1f [7m<7F>[m
>92f2	00					.byte	 0	; $20
>92f3	05					.byte	 5	; $21 !
>92f4	00					.byte	 0	; $22 "
>92f5	00					.byte	 0	; $23 #
>92f6	05					.byte	 5	; $24 $
>92f7	04					.byte	 4	; $25 %
>92f8	01					.byte	 1	; $26 &
>92f9	00					.byte	 0	; $27 '
>92fa	00					.byte	 0	; $28 (
>92fb	00					.byte	 0	; $29 )
>92fc	04					.byte	 4	; $2a *
>92fd	03					.byte	 3	; $2b +
>92fe	00					.byte	 0	; $2c ,
>92ff	03					.byte	 3	; $2d -
>9300	00					.byte	 0	; $2e .
>9301	04					.byte	 4	; $2f /
>9302	00					.byte	 0	; $30 0
>9303	00					.byte	 0	; $31 1
>9304	00					.byte	 0	; $32 2
>9305	00					.byte	 0	; $33 3
>9306	00					.byte	 0	; $34 4
>9307	00					.byte	 0	; $35 5
>9308	00					.byte	 0	; $36 6
>9309	00					.byte	 0	; $37 7
>930a	00					.byte	 0	; $38 8
>930b	00					.byte	 0	; $39 9
>930c	00					.byte	 0	; $3a :
>930d	00					.byte	 0	; $3b ;
>930e	02					.byte	 2	; $3c <
>930f	02					.byte	 2	; $3d =
>9310	02					.byte	 2	; $3e >
>9311	05					.byte	 5	; $3f ?

;******  Return to file: ./common/expressions/expression.asm

.9312					EvaluateExpressionAt0:
.9312	a2 00		ldx #$00			ldx 	#0 							; bottom stack level
.9314					EvaluateExpression:
.9314	a9 00		lda #$00			lda 	#0 							; lowest precedence level
.9316					EvaluateExpressionAtPrecedence:
.9316	48		pha				pha 								; save precedence level
.9317	20 ee 97	jsr $97ee			jsr 	EvaluateTerm 				; evaluate term into level X.
.931a	68		pla				pla 								; restore precedence level.
.931b					_EXPRLoop:
.931b	85 36		sta $36				sta 	zTemp0 						; save current precedence level.
.931d	b1 30		lda ($30),y			lda 	(codePtr),y
.931f	c9 40		cmp #$40			cmp		#$40 						; if >= $40 cannot be an operator
.9321	b0 25		bcs $9348			bcs 	_EXPRExit
.9323	da		phx				phx 								; read the operator precedence
.9324	aa		tax				tax
.9325	bd d2 92	lda $92d2,x			lda 	PrecedenceLevel,x
.9328	fa		plx				plx
.9329	c9 00		cmp #$00			cmp 	#0							; if zero exit (not an operator)
.932b	f0 1b		beq $9348			beq 	_EXPRExit
.932d	85 37		sta $37				sta 	zTemp0+1 					; save operator precedence level.
.932f	a5 36		lda $36				lda 	zTemp0 						; compare current precedence vs. operator precedence
.9331	c5 37		cmp $37				cmp 	zTemp0+1
.9333	b0 13		bcs $9348			bcs		_EXPRExit 					; if current >= operator exit
.9335	48		pha				pha 								; save current precedence.
.9336	b1 30		lda ($30),y			lda 	(codePtr),y
.9338	c8		iny				iny
.9339	48		pha				pha
.933a	a5 37		lda $37				lda 	zTemp0+1 					; get operator precedence level
.933c	e8		inx				inx 								; work out the right hand side.
.933d	20 16 93	jsr $9316			jsr 	EvaluateExpressionAtPrecedence
.9340	ca		dex				dex
.9341	68		pla				pla 								; get operator, call the code.
.9342	20 4b 93	jsr $934b			jsr 	_EXPRCaller
.9345	68		pla				pla 								; restore precedence level
.9346	80 d3		bra $931b			bra 	_EXPRLoop 					; and go round.
.9348					_EXPRExit:
.9348	a5 36		lda $36				lda 	zTemp0 						; A = current precedence level.
.934a	60		rts				rts
.934b					_EXPRCaller:
.934b	da		phx				phx 								; save on stack, first thing is to restore it
.934c	0a		asl a				asl 	a 							; double so can use vectors into X
.934d	aa		tax				tax
.934e	7c 92 8a	jmp ($8a92,x)			jmp 	(VectorSetPunc,x) 			; and go to the code.

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/addsub.asm

.9351					FloatingPointAdd:
.9351	20 fa 94	jsr $94fa			jsr 	FloatPrepare 				; prepare for floats
.9354	80 0b		bra $9361			bra 	FloatAdd
.9356					FloatingPointSub:
.9356	20 fa 94	jsr $94fa			jsr 	FloatPrepare 				; prepare for floats
.9359					FloatSubtract:
.9359	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; negate FPB
.935c	49 80		eor #$80			eor 	#$80
.935e	9d 01 04	sta $0401,x			sta 	NSStatus+1,x				; and fall through.
.9361					FloatAdd:
.9361	48		pha				pha
.9362	5a		phy				phy
.9363	20 0b 95	jsr $950b			jsr 	NSNormalise 				; normalise S[X]
.9366	f0 5c		beq $93c4			beq 	_FAReturn1
.9368	e8		inx				inx 								; normalise S[X+1]
.9369	20 0b 95	jsr $950b			jsr 	NSNormalise
.936c	ca		dex				dex
.936d	c9 00		cmp #$00			cmp 	#0
.936f	f0 77		beq $93e8			beq 	_FAExit 					; if so, just return A
.9371	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; are the exponents the same ?
.9374	dd 29 04	cmp $0429,x			cmp 	NSExponent+1,x
.9377	f0 1b		beq $9394			beq 	_FAExponentsEqual
.9379	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; work out the larger exponent
.937c	a8		tay				tay
.937d	38		sec				sec 								; do a signed comparison of the exponents.
.937e	fd 29 04	sbc $0429,x			sbc 	NSExponent+1,x
.9381	50 02		bvc $9385			bvc 	_FANoSignedChange
.9383	49 80		eor #$80			eor 	#$80
.9385					_FANoSignedChange:
.9385	29 80		and #$80			and 	#$80
.9387	10 03		bpl $938c			bpl 	_FAHaveMax
.9389	bc 29 04	ldy $0429,x			ldy 	NSExponent+1,x
.938c					_FAHaveMax:
.938c	20 eb 93	jsr $93eb			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.938f	e8		inx				inx
.9390	20 eb 93	jsr $93eb			jsr 	_FAShiftToExponent
.9393	ca		dex				dex
.9394					_FAExponentsEqual:
.9394	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; are the signs the same
.9397	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.939a	30 10		bmi $93ac			bmi 	_FADifferentSigns
.939c	20 9d 90	jsr $909d			jsr 	AddTopTwoStack 				; do the add of the mantissae
.939f	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.93a2	10 44		bpl $93e8			bpl 	_FAExit 					; if no, we are done.
.93a4	20 4b 9e	jsr $9e4b			jsr 	NSMShiftRight 				; shift A right, renormalising it.
.93a7	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; bump the exponent and exit
.93aa	80 3c		bra $93e8			bra 	_FAExit
.93ac					_FADifferentSigns:
.93ac	20 c3 90	jsr $90c3			jsr 	SubTopTwoStack 				; subtract mantissa B from A
.93af	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; is the result negative ?
.93b2	10 06		bpl $93ba			bpl 	_FACheckZero 				; if no, check for -0
.93b4	20 d4 9d	jsr $9dd4			jsr 	NSMNegate 					; netate result
.93b7	20 dd 9d	jsr $9ddd			jsr 	NSMNegateMantissa 			; negate (2'c) the mantissa
.93ba					_FACheckZero:
.93ba	20 58 9e	jsr $9e58			jsr 	NSMIsZero	 				; check for -0
.93bd	d0 29		bne $93e8			bne 	_FAExit
.93bf	9e 00 04	stz $0400,x			stz 	NSStatus,x
.93c2	80 24		bra $93e8			bra 	_FAExit
.93c4					_FAReturn1:
.93c4	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.93c7	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.93ca	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.93cd	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.93d0	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.93d3	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.93d6	bd 21 04	lda $0421,x			lda 	NSMantissa3+1,x
.93d9	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.93dc	bd 29 04	lda $0429,x			lda 	NSExponent+1,x
.93df	9d 28 04	sta $0428,x			sta 	NSExponent,x
.93e2	bd 01 04	lda $0401,x			lda 	NSStatus+1,x
.93e5	9d 00 04	sta $0400,x			sta 	NSStatus,x
.93e8					_FAExit:
.93e8	7a		ply				ply
.93e9	68		pla				pla
.93ea	60		rts				rts
.93eb					_FAShiftToExponent:
.93eb					_FAShiftToExponent2:
.93eb	98		tya				tya 								; compare Y to exponent
.93ec	dd 28 04	cmp $0428,x			cmp 	NSExponent,x 				; reached the exponent required ?
.93ef	f0 08		beq $93f9			beq 	_FASEExit 					; exit if so.
.93f1	20 4b 9e	jsr $9e4b			jsr 	NSMShiftRight	 			; shift the mantissa right
.93f4	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; increment exponent
.93f7	80 f2		bra $93eb			bra 	_FAShiftToExponent2
.93f9					_FASEExit:
.93f9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/compare.asm

.93fa					CompareFloat:
.93fa	20 59 93	jsr $9359			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.93fd	bd 10 04	lda $0410,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.9400	29 f8		and #$f8			and 	#$F8
.9402	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9405	1d 20 04	ora $0420,x			ora 	NSMantissa3,x
.9408	f0 09		beq $9413			beq 	_FCExit 					; zero, so approximately identical
.940a	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.940c	3c 00 04	bit $0400,x			bit 	NSStatus,x
.940f	10 02		bpl $9413			bpl 	_FCExit
.9411					_FCNegative:
.9411	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.9413					_FCExit:
.9413	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/divide.asm

.9414					FDivideCommand:
.9414	fa		plx				plx	 								; restore stack position
.9415	20 fa 94	jsr $94fa			jsr 	FloatPrepare 				; prepare for floats
.9418					FloatDivide:
.9418	48		pha				pha
.9419	e8		inx				inx
.941a	20 0b 95	jsr $950b			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.941d	ca		dex				dex
.941e	c9 00		cmp #$00			cmp 	#0
.9420	f0 20		beq $9442			beq 	_FDZero
.9422	20 0b 95	jsr $950b			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.9425	f0 19		beq $9440			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.9427	20 70 8f	jsr $8f70			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.942a	20 fd 8e	jsr $8efd			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.942d	20 0b 95	jsr $950b			jsr		NSNormalise 				; renormalise
.9430	20 0b 90	jsr $900b			jsr 	CalculateSign 				; calculate result sign
.9433	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; calculate exponent
.9436	38		sec				sec
.9437	fd 29 04	sbc $0429,x			sbc 	NSExponent+1,x
.943a	38		sec				sec
.943b	e9 1e		sbc #$1e			sbc 	#30
.943d	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9440					_FDExit:
.9440	68		pla				pla
.9441	60		rts				rts
.9442					_FDZero:
.9442	a9 03		lda #$03		lda	#3
.9444	4c 65 8d	jmp $8d65		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/fractional.asm

.9447					FloatFractionalPart:
.9447	5a		phy				phy
.9448	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; take absolute value
.944b	29 7f		and #$7f			and 	#$7F
.944d	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9450	20 0b 95	jsr $950b			jsr 	NSNormalise
.9453	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.9456	38		sec				sec
.9457	e9 e0		sbc #$e0			sbc 	#$E0
.9459	90 31		bcc $948c			bcc 	_FFPExit 					; already fractional
.945b	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.945d	b0 2a		bcs $9489			bcs 	_FFPZero
.945f	a8		tay				tay 								; put count to do in Y
.9460	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; do each in turn.
.9463	20 8e 94	jsr $948e			jsr 	_FFPPartial
.9466	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9469	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.946c	20 8e 94	jsr $948e			jsr 	_FFPPartial
.946f	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9472	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9475	20 8e 94	jsr $948e			jsr 	_FFPPartial
.9478	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.947b	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.947e	20 8e 94	jsr $948e			jsr 	_FFPPartial
.9481	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9484	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; zeroed check.
.9487	d0 03		bne $948c			bne 	_FFPExit
.9489					_FFPZero:
.9489	20 28 9e	jsr $9e28			jsr 	NSMSetZero
.948c					_FFPExit:
.948c	7a		ply				ply
.948d	60		rts				rts
.948e					_FFPPartial:
.948e	c0 00		cpy #$00			cpy 	#0 							; no more to do
.9490	f0 17		beq $94a9			beq 	_FFFPPExit
.9492	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.9494	b0 0c		bcs $94a2			bcs 	_FFFPPWholeByte
.9496	5a		phy				phy
.9497					_FFFPPLeft:
.9497	0a		asl a				asl 	a
.9498	88		dey				dey
.9499	d0 fc		bne $9497			bne 	_FFFPPLeft
.949b	7a		ply				ply
.949c					_FFFPPRight:
.949c	4a		lsr a				lsr 	a
.949d	88		dey				dey
.949e	d0 fc		bne $949c			bne 	_FFFPPRight
.94a0	80 07		bra $94a9			bra 	_FFFPPExit
.94a2					_FFFPPWholeByte:
.94a2	98		tya				tya 								; subtract 8 from count
.94a3	38		sec				sec
.94a4	e9 08		sbc #$08			sbc 	#8
.94a6	a8		tay				tay
.94a7	a9 00		lda #$00			lda 	#0 							; and clear all
.94a9					_FFFPPExit:
.94a9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/integer.asm

.94aa					FloatIntegerPart:
.94aa	48		pha				pha
.94ab	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; is it integer already ?
.94ae	f0 1f		beq $94cf			beq 	_FIPExit 					; if so do nothing
.94b0	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; is it zero ?
.94b3	f0 17		beq $94cc			beq 	_FIPZero 					; if so return zero.
.94b5	20 0b 95	jsr $950b			jsr 	NSNormalise 				; normalise
.94b8	f0 12		beq $94cc			beq 	_FIPZero 					; normalised to zero, exit zero
.94ba					_FIPShift:
.94ba	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.94bd	10 08		bpl $94c7			bpl 	_FIPCheckZero
.94bf	20 4b 9e	jsr $9e4b			jsr 	NSMShiftRight 				; shift mantissa right
.94c2	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; bump exponent
.94c5	80 f3		bra $94ba			bra 	_FIPShift
.94c7					_FIPCheckZero:
.94c7	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; avoid -0 problem
.94ca	d0 03		bne $94cf			bne 	_FIPExit 					; set to zero if mantissa zero.
.94cc					_FIPZero:
.94cc	20 28 9e	jsr $9e28			jsr 	NSMSetZero
.94cf					_FIPExit:
.94cf	68		pla				pla
.94d0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/multiply.asm

.94d1					FloatingPointMultiply:
.94d1	20 fa 94	jsr $94fa			jsr 	FloatPrepare 				; prepare for floats
.94d4					FloatMultiply:
.94d4	48		pha				pha
.94d5	20 0b 95	jsr $950b			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.94d8	f0 1b		beq $94f5			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.94da	e8		inx				inx
.94db	20 0b 95	jsr $950b			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.94de	ca		dex				dex
.94df	c9 00		cmp #$00			cmp 	#0
.94e1	f0 0f		beq $94f2			beq 	_FDSetZero
.94e3	20 c6 8f	jsr $8fc6			jsr 	MultiplyShort 				; calculate the result.
.94e6	7d 28 04	adc $0428,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.94e9	18		clc				clc
.94ea	7d 29 04	adc $0429,x			adc 	NSExponent+1,x
.94ed	9d 28 04	sta $0428,x			sta 	NSExponent,x
.94f0	80 03		bra $94f5			bra 	_FDExit
.94f2					_FDSetZero:
.94f2	20 28 9e	jsr $9e28			jsr 	NSMSetZero 					; return 0
.94f5					_FDExit:
.94f5	20 0b 95	jsr $950b			jsr 	NSNormalise 				; normalise the result
.94f8	68		pla				pla
.94f9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/utility.asm

.94fa					FloatPrepare:
.94fa	20 2d 96	jsr $962d			jsr 	DereferenceTopTwo 			; dereference the top two values
.94fd	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check ints/floats
.9500	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9503	29 10		and #$10			and 	#NSBIsString
.9505	d0 01		bne $9508			bne 	_FDType
.9507	60		rts				rts
.9508					_FDType:
.9508	4c bc 9f	jmp $9fbc			jmp 	TypeError
.950b					NSNormalise:
.950b	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; make float, keep sign
.950e	29 80		and #$80			and 	#$80
.9510	09 08		ora #$08			ora 	#NSTFloat
.9512	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9515	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; if zero exit
.9518	d0 09		bne $9523			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.951a	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; clear the sign bit.
.951d	7e 00 04	ror $0400,x			ror 	NSStatus,x 					; (no -0)
.9520	a9 00		lda #$00			lda 	#0 							; set Z flag
.9522	60		rts				rts
.9523					_NSNormaliseOptimise:
.9523	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; upper byte zero ?
.9526	d0 22		bne $954a			bne 	_NSNormaliseLoop
.9528	bd 18 04	lda $0418,x			lda 	NSMantissa2,x 				; byte normalise
.952b	30 1d		bmi $954a			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.952d	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9530	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9533	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9536	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9539	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.953c	9e 08 04	stz $0408,x			stz 	NSMantissa0,x
.953f	bd 28 04	lda $0428,x			lda 	NSExponent,x
.9542	38		sec				sec
.9543	e9 08		sbc #$08			sbc 	#8
.9545	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9548	80 d9		bra $9523			bra 	_NSNormaliseOptimise
.954a					_NSNormaliseLoop:
.954a	3c 20 04	bit $0420,x			bit 	NSMantissa3,x 				; bit 30 set ?
.954d	70 08		bvs $9557			bvs 	_NSNExit 					; exit if so with Z flag clear
.954f	20 3d 9e	jsr $9e3d			jsr 	NSMShiftLeft 				; shift mantissa left
.9552	de 28 04	dec $0428,x			dec 	NSExponent,x 				; adjust exponent
.9555	80 f3		bra $954a			bra 	_NSNormaliseLoop
.9557					_NSNExit:
.9557	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.9559	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignnumber.asm

.955a					AssignNumber:
.955a	5a		phy				phy
.955b	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy mantissa0/1 to zTemp0
.955e	85 36		sta $36				sta 	zTemp0
.9560	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9563	85 37		sta $37				sta 	zTemp0+1
.9565	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; clear reference bits
.9568	29 df		and #$df			and 	#(NSBIsReference ^ $FF)
.956a	9d 00 04	sta $0400,x			sta 	NSStatus,x
.956d	29 18		and #$18			and 	#NSBTypeMask				; assigning to a float ?
.956f	c9 08		cmp #$08			cmp 	#NSTFloat
.9571	f0 2a		beq $959d			beq 	_ANFloat
.9573	bd 29 04	lda $0429,x			lda		NSExponent+1,x 				; is it a float
.9576	f0 05		beq $957d			beq		_ANNotFloat
.9578	e8		inx				inx
.9579	20 aa 94	jsr $94aa			jsr 	FloatIntegerPart 			; make it an integer
.957c	ca		dex				dex
.957d					_ANNotFloat:
.957d	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if byte/word reference.
.9580	29 03		and #$03			and 	#3
.9582	d0 05		bne $9589			bne 	_ANByteWord
.9584	20 a9 95	jsr $95a9			jsr 	_ANCopy4PackSign 			; copy all 4 bytes and sign
.9587	80 1e		bra $95a7			bra 	_ANExit
.9589					_ANByteWord:
.9589	48		pha				pha 								; save count
.958a	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; do byte
.958d	92 36		sta ($36)			sta 	(zTemp0)
.958f	68		pla				pla
.9590	c9 01		cmp #$01			cmp	 	#1
.9592	f0 13		beq $95a7			beq 	_ANExit
.9594	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x 			; do word
.9597	a0 01		ldy #$01			ldy 	#1
.9599	91 36		sta ($36),y			sta 	(zTemp0),y
.959b	80 0a		bra $95a7			bra 	_ANExit
.959d					_ANFloat:
.959d	20 a9 95	jsr $95a9			jsr 	_ANCopy4PackSign 			; write all 4 bytes and packed sign
.95a0	bd 29 04	lda $0429,x			lda 	NSExponent+1,x 				; copy exponent to slot 4
.95a3	a0 04		ldy #$04			ldy 	#4
.95a5	91 36		sta ($36),y			sta 	(zTemp0),y
.95a7					_ANExit:
.95a7	7a		ply				ply
.95a8	60		rts				rts
.95a9					_ANCopy4PackSign:
.95a9	a0 03		ldy #$03			ldy 	#3
.95ab	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; sign bit into status
.95ae	29 80		and #$80			and 	#$80 						; put into high bit of mantissa 3
.95b0	1d 21 04	ora $0421,x			ora 	NSMantissa3+1,x
.95b3	91 36		sta ($36),y			sta 	(zTemp0),y
.95b5	88		dey				dey
.95b6	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.95b9	91 36		sta ($36),y			sta 	(zTemp0),y
.95bb	88		dey				dey
.95bc	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.95bf	91 36		sta ($36),y			sta 	(zTemp0),y
.95c1	88		dey				dey
.95c2	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.95c5	91 36		sta ($36),y			sta 	(zTemp0),y
.95c7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignstring.asm

.95c8					AssignString:
.95c8	5a		phy				phy
.95c9	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.95cc	85 38		sta $38				sta 	zTemp1
.95ce	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.95d1	85 39		sta $39				sta 	zTemp1+1
.95d3	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.95d6	85 36		sta $36				sta 	zTemp0
.95d8	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.95db	85 37		sta $37				sta 	zTemp0+1
.95dd	a0 01		ldy #$01			ldy 	#1 							; the high byte of the target address
.95df	b1 36		lda ($36),y			lda 	(zTemp0),y
.95e1	f0 23		beq $9606			beq 	_ASNewStringRequired 		; if zero, a new string is required.
.95e3	38		sec				sec 								; put Address-2 in zsTemp - this is the size/status/string record
.95e4	b2 36		lda ($36)			lda 	(zTemp0) 					; of concreted strings
.95e6	e9 02		sbc #$02			sbc 	#2
.95e8	85 3c		sta $3c				sta 	zsTemp
.95ea	a0 01		ldy #$01			ldy 	#1
.95ec	b1 36		lda ($36),y			lda 	(zTemp0),y
.95ee	e9 00		sbc #$00			sbc 	#0
.95f0	85 3d		sta $3d				sta 	zsTemp+1
.95f2	a0 ff		ldy #$ff			ldy 	#$FF 						; get length of new string
.95f4					_ASGetLength:
.95f4	c8		iny				iny
.95f5	b1 38		lda ($38),y			lda 	(zTemp1),y
.95f7	d0 fb		bne $95f4			bne 	_ASGetLength
.95f9	98		tya				tya 								; is this length <= current length
.95fa	d2 3c		cmp ($3c)			cmp 	(zsTemp)
.95fc	90 20		bcc $961e			bcc 	_ASCopyString
.95fe	f0 1e		beq $961e			beq 	_ASCopyString
.9600	a9 80		lda #$80			lda 	#$80 						; mark as unused.
.9602	a0 01		ldy #$01			ldy 	#1
.9604	91 3c		sta ($3c),y			sta 	(zsTemp),y
.9606					_ASNewStringRequired:
.9606	e8		inx				inx 								; concrete the new string.
.9607	20 10 a7	jsr $a710			jsr 	StringConcrete				; (breaks zTemp1/2, not zTemp0 and zsTemp)
.960a	ca		dex				dex
.960b	18		clc				clc
.960c	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; copy that new address to the reference.
.960f	69 02		adc #$02			adc 	#2 							; add two to point at the data.
.9611	92 36		sta ($36)			sta 	(zTemp0)
.9613	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.9616	69 00		adc #$00			adc 	#0
.9618	a0 01		ldy #$01			ldy 	#1
.961a	91 36		sta ($36),y			sta 	(zTemp0),y
.961c	80 0d		bra $962b			bra 	_ASExit
.961e					_ASCopyString:
.961e	a0 00		ldy #$00			ldy 	#0
.9620					_ASCopyLoop:
.9620	b1 38		lda ($38),y			lda 	(zTemp1),y
.9622	c8		iny				iny
.9623	c8		iny				iny
.9624	91 3c		sta ($3c),y			sta 	(zsTemp),y
.9626	88		dey				dey
.9627	c9 00		cmp #$00			cmp 	#0
.9629	d0 f5		bne $9620			bne 	_ASCopyLoop
.962b					_ASExit:
.962b	7a		ply				ply
.962c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/dereference.asm

.962d					DereferenceTopTwo:
.962d	e8		inx				inx
.962e	20 32 96	jsr $9632			jsr 	Dereference 				; deref x+1
.9631	ca		dex				dex  								; falls through to deref x
.9632					Dereference:
.9632	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get the status byte
.9635	29 20		and #$20			and 	#NSBIsReference 			; shift sign bit to carry, reference to bit 7
.9637	f0 57		beq $9690			beq 	_DRFExit 					; not a reference
.9639	5a		phy				phy
.963a	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address to dereference into zTemp0
.963d	85 36		sta $36				sta 	zTemp0
.963f	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9642	85 37		sta $37				sta 	zTemp0+1
.9644	9e 10 04	stz $0410,x			stz 	NSMantissa1,x 				; clear second byte.
.9647	b2 36		lda ($36)			lda 	(zTemp0) 					; do the first byte
.9649	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.964c	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get status byte.
.964f	29 18		and #$18			and 	#NSBTypeMask 				; what type is it ?
.9651	c9 10		cmp #$10			cmp 	#NSTString 					; if string, dereference two
.9653	f0 0f		beq $9664			beq 	_DRFDereferenceTwo
.9655	c9 08		cmp #$08			cmp 	#NSTFloat 					; if float, do full dereference.
.9657	f0 39		beq $9692			beq 	_DRFFull
.9659	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be integer - how many bytes ?
.965c	29 03		and #$03			and 	#3
.965e	f0 32		beq $9692			beq 	_DRFFull 					; the whole word
.9660	c9 01		cmp #$01			cmp 	#1 							; is it 10 (e.g. 2 bytes)
.9662	f0 07		beq $966b			beq		_DRFClear23 				; no, one byte, clear 2 & 3 and exit
.9664					_DRFDereferenceTwo:
.9664	a0 01		ldy #$01			ldy 	#1
.9666	b1 36		lda ($36),y			lda 	(zTemp0),y
.9668	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.966b					_DRFClear23:
.966b	9e 18 04	stz $0418,x			stz 	NSMantissa2,x 				; clear upper bytes, only read 1 or 2 bytes
.966e	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.9671	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; make it a value of that type.
.9674	29 18		and #$18			and 	#NSBTypeMask
.9676	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9679	c9 10		cmp #$10			cmp 	#NSTString  				; is it a string
.967b	d0 12		bne $968f			bne 	_DRFNotString
.967d	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; check address is zero
.9680	1d 10 04	ora $0410,x			ora 	NSMantissa1,x
.9683	d0 0a		bne $968f			bne 	_DRFNotString
.9685	a9 91		lda #$91			lda 	#_DRFNullString & $FF 		; if so, return reference to ""
.9687	9d 08 04	sta $0408,x			sta 	NSMantissa0,X
.968a	a9 96		lda #$96			lda 	#_DRFNullString >> 8
.968c	9d 10 04	sta $0410,x			sta 	NSMantissa1,X
.968f					_DRFNotString
.968f	7a		ply				ply 								; restore Y and exit
.9690					_DRFExit:
.9690	60		rts				rts
.9691					_DRFNullString:
>9691	00						.byte 	0
.9692					_DRFFull:
.9692	a0 01		ldy #$01			ldy 	#1 							; get remaining 3 bytes.
.9694	b1 36		lda ($36),y			lda 	(zTemp0),y
.9696	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9699	c8		iny				iny
.969a	b1 36		lda ($36),y			lda 	(zTemp0),y
.969c	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.969f	c8		iny				iny
.96a0	b1 36		lda ($36),y			lda 	(zTemp0),y
.96a2	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.96a5	9e 28 04	stz $0428,x			stz 	NSExponent,x 				; clear exponent.
.96a8	bd 00 04	lda $0400,x			lda		NSStatus,x 					; see if type is integer
.96ab	29 18		and #$18			and 	#NSBTypeMask  				; type information only
.96ad	9d 00 04	sta $0400,x			sta 	NSStatus,x 					; update it back.
.96b0	f0 06		beq $96b8			beq 	_DRFNoExponent
.96b2	c8		iny				iny 								; if not, read the exponent as well.
.96b3	b1 36		lda ($36),y			lda 	(zTemp0),y
.96b5	9d 28 04	sta $0428,x			sta 	NSExponent,x
.96b8					_DRFNoExponent:
.96b8	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; is the most significant bit set ?
.96bb	10 0d		bpl $96ca			bpl 	_DRFExit2 					; if not, then exit.
.96bd	29 7f		and #$7f			and 	#$7F 						; clear that bit.
.96bf	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.96c2	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; set the sign flag
.96c5	09 80		ora #$80			ora 	#NSBIsNegative
.96c7	9d 00 04	sta $0400,x			sta 	NSStatus,x
.96ca					_DRFExit2:
.96ca	7a		ply				ply
.96cb	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/number.asm

=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.96cc					EncodeNumberStart:
.96cc	38		sec				sec
.96cd	80 01		bra $96d0			bra 	EncodeNumberContinue+1
.96cf					EncodeNumberContinue:
.96cf	18		clc				clc
.96d0					EncodeNumber:
.96d0	08		php				php 								; save reset.
.96d1	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.96d3	f0 12		beq $96e7			beq 	_ENIsOkay
.96d5	c9 30		cmp #$30			cmp 	#"0"
.96d7	90 04		bcc $96dd			bcc 	_ENBadNumber
.96d9	c9 3a		cmp #$3a			cmp 	#"9"+1
.96db	90 0a		bcc $96e7			bcc 	_ENIsOkay
.96dd					_ENBadNumber:
.96dd	28		plp				plp 								; throw saved reset
.96de	ad 85 04	lda $0485			lda 	EncodeState 				; decimal mode, construct final number
.96e1	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.96e3	f0 7e		beq $9763			beq 	_ENConstructFinal
.96e5					_ENFail:
.96e5	18		clc				clc 								; not allowed
.96e6	60		rts				rts
.96e7					_ENIsOkay:
.96e7	28		plp				plp 								; are we restarting
.96e8	90 15		bcc $96ff			bcc 	_ENNoRestart
.96ea					_ENStartEncode:
.96ea	c9 2e		cmp #$2e			cmp 	#'.'						; first is DP
.96ec	f0 0c		beq $96fa			beq 	_ENFirstDP
.96ee	29 0f		and #$0f			and 	#15 						; put digit in mantissa
.96f0	20 2a 9e	jsr $9e2a			jsr 	NSMSetByte
.96f3	a9 01		lda #$01			lda 	#ESTA_Low
.96f5					_ENExitChange:
.96f5	8d 85 04	sta $0485			sta 	EncodeState 				; save new state
.96f8	38		sec				sec
.96f9	60		rts				rts
.96fa					_ENFirstDP:
.96fa	20 28 9e	jsr $9e28			jsr 	NSMSetZero 					; clear integer part
.96fd	80 3f		bra $973e			bra 	_ESTASwitchFloat			; go straight to float and exi
.96ff					_ENNoRestart:
.96ff	48		pha				pha 								; save on stack.
.9700	ad 85 04	lda $0485			lda 	EncodeState 				; get current state
.9703	c9 01		cmp #$01			cmp 	#ESTA_Low
.9705	f0 09		beq $9710			beq  	_ESTALowState
.9707	c9 02		cmp #$02			cmp 	#ESTA_High
.9709	f0 29		beq $9734			beq 	_ESTAHighState
.970b	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.970d	f0 3b		beq $974a			beq 	_ESTADecimalState
>970f	db						.byte 	$DB 						; causes a break in the emulator
.9710					_ESTALowState:
.9710	68		pla				pla 								; get value back
.9711	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.9713	f0 29		beq $973e			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.9715	29 0f		and #$0f			and 	#15 						; make digit
.9717	8d 86 04	sta $0486			sta 	DigitTemp 					; save it.
.971a	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.971d	0a		asl a				asl 	a
.971e	0a		asl a				asl 	a
.971f	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.9722	0a		asl a				asl 	a
.9723	6d 86 04	adc $0486			adc 	DigitTemp
.9726	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9729	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.972b	90 05		bcc $9732			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.972d	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.972f	8d 85 04	sta $0485			sta 	EncodeState
.9732					_ESTANoSwitch:
.9732	38		sec				sec
.9733	60		rts				rts
.9734					_ESTAHighState:
.9734	68		pla				pla 								; get value back
.9735	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.9737	f0 05		beq $973e			beq 	_ESTASwitchFloat
.9739	20 9d 97	jsr $979d			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.973c	38		sec				sec
.973d	60		rts				rts
.973e					_ESTASwitchFloat:
.973e	9c 87 04	stz $0487			stz 	DecimalCount
.9741	e8		inx				inx 								; zero the decimal additive.
.9742	20 28 9e	jsr $9e28			jsr 	NSMSetZero
.9745	ca		dex				dex
.9746	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.9748	80 ab		bra $96f5			bra 	_ENExitChange
.974a					_ESTADecimalState:
.974a	68		pla				pla 								; digit.
.974b	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 2nd decimal point.
.974d	f0 96		beq $96e5			beq 	_ENFail
.974f	e8		inx				inx 								; put digit into fractional part of X+1
.9750	20 9d 97	jsr $979d			jsr 	ESTAShiftDigitIntoMantissa
.9753	ca		dex				dex
.9754	ee 87 04	inc $0487			inc 	DecimalCount 				; bump the count of decimals
.9757	ad 87 04	lda $0487			lda 	DecimalCount
.975a	c9 0b		cmp #$0b			cmp 	#11
.975c	f0 02		beq $9760			beq 	_ESTADSFail
.975e	38		sec				sec
.975f	60		rts				rts
.9760					_ESTADSFail:
.9760	4c b7 9f	jmp $9fb7			jmp 	RangeError
.9763					_ENConstructFinal:
.9763	ad 87 04	lda $0487			lda 	DecimalCount 				; get decimal count
.9766	f0 33		beq $979b			beq 	_ENCFExit 					; no decimals
.9768	5a		phy				phy
.9769	0a		asl a				asl 	a 							; x 4 and CLC
.976a	0a		asl a				asl 	a
.976b	6d 87 04	adc $0487			adc 	DecimalCount
.976e	a8		tay				tay
.976f	b9 76 9f	lda $9f76,y			lda 	DecimalScalarTable-5,y 		; copy decimal scalar to X+2
.9772	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9775	b9 77 9f	lda $9f77,y			lda 	DecimalScalarTable-5+1,y
.9778	9d 12 04	sta $0412,x			sta 	NSMantissa1+2,x
.977b	b9 78 9f	lda $9f78,y			lda 	DecimalScalarTable-5+2,y
.977e	9d 1a 04	sta $041a,x			sta 	NSMantissa2+2,x
.9781	b9 79 9f	lda $9f79,y			lda 	DecimalScalarTable-5+3,y
.9784	9d 22 04	sta $0422,x			sta 	NSMantissa3+2,x
.9787	b9 7a 9f	lda $9f7a,y			lda 	DecimalScalarTable-5+4,y
.978a	9d 2a 04	sta $042a,x			sta 	NSExponent+2,x
.978d	a9 08		lda #$08			lda 	#NSTFloat
.978f	9d 02 04	sta $0402,x			sta 	NSStatus+2,x
.9792	7a		ply				ply
.9793	e8		inx				inx 								; multiply decimal const by decimal scalar
.9794	20 d4 94	jsr $94d4			jsr 	FloatMultiply
.9797	ca		dex				dex
.9798	20 61 93	jsr $9361			jsr 	FloatAdd 					; add to integer part.
.979b					_ENCFExit:
.979b	18		clc				clc 								; reject the digit.
.979c	60		rts				rts
.979d					ESTAShiftDigitIntoMantissa:
.979d	29 0f		and #$0f			and 	#15 						; save digit
.979f	48		pha				pha
.97a0	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; push mantissa on stack
.97a3	48		pha				pha
.97a4	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.97a7	48		pha				pha
.97a8	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.97ab	48		pha				pha
.97ac	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.97af	48		pha				pha
.97b0	20 3d 9e	jsr $9e3d			jsr 	NSMShiftLeft 				; x 2
.97b3	20 3d 9e	jsr $9e3d			jsr 	NSMShiftLeft 				; x 4
.97b6	18		clc				clc 								; pop mantissa and add
.97b7	68		pla				pla
.97b8	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.97bb	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.97be	68		pla				pla
.97bf	7d 10 04	adc $0410,x			adc 	NSMantissa1,x
.97c2	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.97c5	68		pla				pla
.97c6	7d 18 04	adc $0418,x			adc 	NSMantissa2,x
.97c9	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.97cc	68		pla				pla
.97cd	7d 20 04	adc $0420,x			adc 	NSMantissa3,x
.97d0	9d 20 04	sta $0420,x			sta 	NSMantissa3,x 				; x 5
.97d3	20 3d 9e	jsr $9e3d			jsr 	NSMShiftLeft 				; x 10
.97d6	68		pla				pla 								; add digit
.97d7	18		clc				clc
.97d8	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.97db	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.97de	90 0d		bcc $97ed			bcc 	_ESTASDExit
.97e0	fe 10 04	inc $0410,x			inc 	NSMantissa1,x
.97e3	d0 08		bne $97ed			bne 	_ESTASDExit
.97e5	fe 18 04	inc $0418,x			inc 	NSMantissa2,x
.97e8	d0 03		bne $97ed			bne 	_ESTASDExit
.97ea	fe 20 04	inc $0420,x			inc 	NSMantissa3,x
.97ed					_ESTASDExit:
.97ed	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/term.asm

.97ee					EvaluateTerm:
.97ee	b1 30		lda ($30),y			lda 	(codePtr),y
.97f0	30 18		bmi $980a			bmi 	_ETCheckUnary 				; unary function ? (text ones)
.97f2	c9 40		cmp #$40			cmp 	#$40 						; 40-7F => identifier reference
.97f4	b0 6f		bcs $9865			bcs 	_ETVariable
.97f6	c9 30		cmp #$30			cmp 	#'0' 						; is it a number
.97f8	90 6e		bcc $9868			bcc 	_ETPuncUnary 				; if not it might be a punctuation unary.
.97fa	c9 3a		cmp #$3a			cmp 	#'9'+1
.97fc	b0 6a		bcs $9868			bcs 	_ETPuncUnary
.97fe	20 cc 96	jsr $96cc			jsr 	EncodeNumberStart 			; can't fail as it's 0-9 !
.9801					_ETNumber:
.9801	c8		iny				iny 								; keep encoding until we have the numbers
.9802	b1 30		lda ($30),y			lda 	(codePtr),y
.9804	20 cf 96	jsr $96cf			jsr 	EncodeNumberContinue
.9807	b0 f8		bcs $9801			bcs 	_ETNumber 					; go back if accepted.
.9809	60		rts				rts
.980a					_ETCheckUnary:
.980a	c9 ff		cmp #$ff			cmp 	#KWC_STRING 				; string token
.980c	f0 41		beq $984f			beq 	_ETString
.980e	c9 fe		cmp #$fe			cmp 	#KWC_HEXCONST 				; hex constant.
.9810	f0 12		beq $9824			beq 	_ETHexConstant
.9812	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; check it actually is a unary function
.9814	90 0b		bcc $9821			bcc 	_ETSyntaxError
.9816	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1
.9818	b0 07		bcs $9821			bcs 	_ETSyntaxError
.981a	da		phx				phx 								; push X on the stack
.981b	0a		asl a				asl 	a 							; put vector x 2 into X
.981c	aa		tax				tax
.981d	c8		iny				iny 								; consume unary function token
.981e	7c 12 8b	jmp ($8b12,x)			jmp 	(VectorSet0,x) 				; and do it.
.9821					_ETSyntaxError:
.9821	4c b2 9f	jmp $9fb2			jmp 	SyntaxError
.9824					_ETHexConstant:
.9824	c8		iny				iny 								; skip #
.9825	c8		iny				iny 								; skip count
.9826	20 28 9e	jsr $9e28			jsr 	NSMSetZero 					; clear result
.9829					_ETHLoop:
.9829	b1 30		lda ($30),y			lda 	(codePtr),y
.982b	c8		iny				iny 								; and consume
.982c	c9 00		cmp #$00			cmp 	#0 							; exit if zero
.982e	f0 1e		beq $984e			beq 	_ETHExit
.9830	48		pha				pha 								; save on stack.
.9831	20 3d 9e	jsr $9e3d			jsr 	NSMShiftLeft 				; x 2
.9834	20 3d 9e	jsr $9e3d			jsr 	NSMShiftLeft 				; x 4
.9837	20 3d 9e	jsr $9e3d			jsr 	NSMShiftLeft 				; x 8
.983a	20 3d 9e	jsr $9e3d			jsr 	NSMShiftLeft 				; x 16
.983d	68		pla				pla 								; ASCII
.983e	c9 41		cmp #$41			cmp 	#'A'
.9840	90 02		bcc $9844			bcc 	_ETHNotChar
.9842	e9 07		sbc #$07			sbc 	#7
.9844					_ETHNotChar:
.9844	29 0f		and #$0f			and 	#15 						; digit now
.9846	1d 08 04	ora $0408,x			ora 	NSMantissa0,x 				; put in LS Nibble
.9849	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.984c	80 db		bra $9829			bra 	_ETHLoop 					; go round.
.984e					_ETHExit:
.984e	60		rts				rts
.984f					_ETString:
.984f	c8		iny				iny 								; look at length
.9850	b1 30		lda ($30),y			lda 	(codePtr),y
.9852	48		pha				pha
.9853	c8		iny				iny 								; first character
.9854	20 ad a5	jsr $a5ad			jsr 	MemoryInline 				; put address of string at (code-Ptr),y on stack
.9857	68		pla				pla 								; restore count and save
.9858	85 36		sta $36				sta 	zTemp0
.985a	98		tya				tya 								; add length to Y to skip it.
.985b	18		clc				clc
.985c	65 36		adc $36				adc 	zTemp0
.985e	a8		tay				tay
.985f	a9 10		lda #$10			lda 	#NSTString 					; mark as string
.9861	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9864	60		rts				rts
.9865					_ETVariable:
.9865	4c bf 98	jmp $98bf			jmp 	VariableHandler
.9868					_ETPuncUnary:
.9868	c8		iny				iny 								; consume the unary character
.9869	c9 2d		cmp #$2d			cmp 	#KWD_MINUS 					; unary minus
.986b	f0 2d		beq $989a			beq 	_ETUnaryNegate
.986d	c9 10		cmp #$10			cmp 	#KWD_AT 					; @ reference -> constant
.986f	f0 39		beq $98aa			beq 	_ETDereference
.9871	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; parenthesis
.9873	f0 43		beq $98b8			beq 	_ETParenthesis
.9875	64 36		stz $36				stz 	zTemp0 						; zTemp0 is the indirection level.
.9877	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; byte indirection (0) ?
.9879	f0 06		beq $9881			beq 	_ETIndirection
.987b	e6 36		inc $36				inc 	zTemp0
.987d	c9 21		cmp #$21			cmp 	#KWD_PLING					; word indirection (1) \
.987f	d0 a0		bne $9821			bne 	_ETSyntaxError
.9881					_ETIndirection:
.9881	a5 36		lda $36				lda 	zTemp0 						; push indirection amount (0-1) => (1-2) on the stack
.9883	1a		inc a				inc 	a
.9884	48		pha				pha
.9885	20 ee 97	jsr $97ee			jsr 	EvaluateTerm				; evaluate the term
.9888	20 32 96	jsr $9632			jsr 	Dereference 				; dereference it.
.988b	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a +ve integer.
.988e	d0 07		bne $9897			bne 	_ETTypeMismatch
.9890	68		pla				pla 								; indirection 1-2
.9891	09 20		ora #$20			ora 	#NSBIsReference 			; make it a reference.
.9893	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9896	60		rts				rts
.9897					_ETTypeMismatch:
.9897	4c bc 9f	jmp $9fbc			jmp 	TypeError
.989a					_ETUnaryNegate:
.989a	20 ee 97	jsr $97ee			jsr 	EvaluateTerm				; evaluate the term
.989d	20 32 96	jsr $9632			jsr 	Dereference 				; dereference it.
.98a0	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a number
.98a3	29 10		and #$10			and 	#NSTString
.98a5	d0 f0		bne $9897			bne 	_ETTypeMismatch
.98a7	4c d4 9d	jmp $9dd4			jmp 	NSMNegate  					; just toggles the sign bit.
.98aa					_ETDereference:
.98aa	20 ee 97	jsr $97ee			jsr 	EvaluateTerm				; evaluate the term
.98ad	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a reference
.98b0	29 20		and #$20			and 	#NSBIsReference
.98b2	f0 e3		beq $9897			beq 	_ETTypeMismatch
.98b4	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; make it an integer address
.98b7	60		rts				rts
.98b8					_ETParenthesis:
.98b8	20 14 93	jsr $9314			jsr 	EvaluateExpression 			; evaluate here, from lowest precedence
.98bb	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket 			; check for )
.98be	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/variable.asm

.98bf					VariableHandler:
.98bf	b1 30		lda ($30),y			lda 	(codePtr),y
.98c1	18		clc				clc
.98c2	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.98c4	85 37		sta $37				sta 	zTemp0+1
.98c6	c8		iny				iny
.98c7	b1 30		lda ($30),y			lda 	(codePtr),y
.98c9	85 36		sta $36				sta 	zTemp0
.98cb	c8		iny				iny
.98cc	18		clc				clc									; copy variable address+3 to mantissa
.98cd	69 03		adc #$03			adc 	#3
.98cf	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.98d2	a5 37		lda $37				lda 	zTemp0+1
.98d4	69 00		adc #$00			adc 	#0
.98d6	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.98d9	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.98dc	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.98df	9e 28 04	stz $0428,x			stz 	NSExponent,x
.98e2	5a		phy				phy
.98e3	a0 02		ldy #$02			ldy 	#2 							; read type
.98e5	b1 36		lda ($36),y			lda 	(zTemp0),y
.98e7	7a		ply				ply
.98e8	29 1c		and #$1c			and 	#NSBTypeMask+NSBIsArray 	; get type information
.98ea	09 20		ora #$20			ora 	#NSBIsReference 			; make a reference.
.98ec	9d 00 04	sta $0400,x			sta 	NSStatus,x
.98ef	29 04		and #$04			and 	#NSBIsArray
.98f1	d0 01		bne $98f4			bne 	_VHArray
.98f3	60		rts				rts
.98f4					_VHArray:
.98f4	e8		inx				inx
.98f5	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; get the 1st index.
.98f8	a9 ff		lda #$ff			lda 	#$FF 						; set Status of X+2 to a duff value so we know if we picked it up.
.98fa	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.98fd	b1 30		lda ($30),y			lda 	(codePtr),y
.98ff	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.9901	d0 06		bne $9909			bne 	_VHNoSecondIndex
.9903	c8		iny				iny 								; skip the comma
.9904	e8		inx				inx
.9905	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; get the 2nd index.
.9908	ca		dex				dex
.9909					_VHNoSecondIndex:
.9909	ca		dex				dex 								; set X back.
.990a	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket 			; and check the right bracket.
.990d	5a		phy				phy 								; save position
.990e	a0 02		ldy #$02			ldy 	#2 							; check first index is not-zero, e.g. array defined
.9910	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9912	f0 6b		beq $997f			beq 	_VHBadIndex
.9914	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy record address to zaTemp
.9917	85 3e		sta $3e				sta 	zaTemp
.9919	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.991c	85 3f		sta $3f				sta 	zaTemp+1
.991e	a0 03		ldy #$03			ldy 	#3 							; get the second index - which is 0 if there is one index.
.9920	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9922	f0 02		beq $9926			beq 	_VHHas2Mask
.9924	a9 ff		lda #$ff			lda 	#$FF
.9926					_VHHas2Mask:
.9926	dd 02 04	cmp $0402,x			cmp 	NSStatus+2,x 				; so if they are the same there are the wrong number of indices
.9929	f0 54		beq $997f			beq 	_VHBadIndex
.992b	0a		asl a				asl 	a 							; carry will be set if a second index
.992c	90 09		bcc $9937			bcc 	_VHCheckFirstIndex
.992e	a0 03		ldy #$03			ldy 	#3 			 				; check the 2nd size >= 2nd index
.9930	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9932	dd 0a 04	cmp $040a,x			cmp 	NSMantissa0+2,x
.9935	90 48		bcc $997f			bcc 	_VHBadIndex
.9937					_VHCheckFirstIndex:
.9937	a0 02		ldy #$02			ldy 	#2 			 				; check the 2nd size >= 2nd index
.9939	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.993b	dd 09 04	cmp $0409,x			cmp 	NSMantissa0+1,x
.993e	90 3f		bcc $997f			bcc 	_VHBadIndex
.9940	64 36		stz $36				stz 	zTemp0 						; clear zTemp0 (if 1 index)
.9942	64 37		stz $37				stz 	zTemp0+1
.9944	bd 02 04	lda $0402,x			lda 	NSStatus+2,x 				; if only one index provided, don't need to multiply
.9947	30 0f		bmi $9958			bmi 	_VHNoMultiply
.9949	da		phx				phx
.994a	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; get 2nd index on stack
.994d	48		pha				pha
.994e	a0 02		ldy #$02			ldy 	#2 							; get 1st size in A
.9950	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9952	1a		inc a				inc 	a 							; add 1 for zero base
.9953	fa		plx				plx
.9954	20 bd 9d	jsr $9dbd			jsr 	Multiply8x8 				; calculate -> Z0
.9957	fa		plx				plx
.9958					_VHNoMultiply:
.9958	18		clc				clc
.9959	a5 36		lda $36				lda 	zTemp0
.995b	7d 09 04	adc $0409,x			adc 	NSMantissa0+1,x
.995e	85 36		sta $36				sta 	zTemp0
.9960	a5 37		lda $37				lda 	zTemp0+1
.9962	69 00		adc #$00			adc 	#0
.9964	85 37		sta $37				sta 	zTemp0+1
.9966	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9969	20 f0 84	jsr $84f0			jsr 	ScaleByBaseType
.996c	18		clc				clc
.996d	b2 3e		lda ($3e)			lda 	(zaTemp)
.996f	65 36		adc $36				adc 	zTemp0
.9971	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9974	a0 01		ldy #$01			ldy 	#1
.9976	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9978	65 37		adc $37				adc 	zTemp0+1
.997a	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.997d	7a		ply				ply 								; restore position
.997e	60		rts				rts
.997f					_VHBadIndex:
.997f	a9 17		lda #$17		lda	#23
.9981	4c 65 8d	jmp $8d65		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/abs.asm

.9984					AbsUnary:
.9984	fa		plx				plx 								; restore stack pos
.9985	20 51 9d	jsr $9d51			jsr 	EvaluateNumber 				; get a float or int
.9988	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.998b	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; clear the sign bit
.998e	29 7f		and #$7f			and 	#$7F
.9990	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9993	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/alloc.asm

.9994					AllocUnary:
.9994	fa		plx				plx 								; restore stack pos
.9995	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger		; get bytes required.
.9998	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.999b	da		phx				phx 								; save X/Y
.999c	5a		phy				phy
.999d	8a		txa				txa 								; copy X into Y
.999e	a8		tay				tay
.999f	b9 10 04	lda $0410,y			lda		NSMantissa1,y 				; get size
.99a2	aa		tax				tax
.99a3	b9 08 04	lda $0408,y			lda 	NSMantissa0,y
.99a6	20 b3 99	jsr $99b3			jsr 	AllocateXABytes 			; allocate memory
.99a9	99 08 04	sta $0408,y			sta 	NSMantissa0,y 				; write address out.
.99ac	8a		txa				txa
.99ad	99 10 04	sta $0410,y			sta 	NSMantissa1,y
.99b0	7a		ply				ply
.99b1	fa		plx				plx
.99b2	60		rts				rts
.99b3					AllocateXABytes:
.99b3	5a		phy				phy
.99b4	ac 8c 04	ldy $048c			ldy 	lowMemPtr 					; push current address on stack and to zTemp0
.99b7	84 36		sty $36				sty 	zTemp0
.99b9	5a		phy				phy
.99ba	ac 8d 04	ldy $048d			ldy 	lowMemPtr+1
.99bd	84 37		sty $37				sty 	zTemp0+1
.99bf	5a		phy				phy
.99c0	18		clc				clc 								; add to low memory pointer
.99c1	6d 8c 04	adc $048c			adc 	lowMemPtr
.99c4	8d 8c 04	sta $048c			sta 	lowMemPtr
.99c7	8a		txa				txa
.99c8	6d 8d 04	adc $048d			adc 	lowMemPtr+1
.99cb	8d 8d 04	sta $048d			sta 	lowMemPtr+1
.99ce	b0 2f		bcs $99ff			bcs 	CISSMemory
.99d0	20 f1 99	jsr $99f1			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.99d3					_ClearMemory:
.99d3	ad 8c 04	lda $048c			lda 	lowMemPtr 					; cleared all memory allocated
.99d6	c5 36		cmp $36				cmp 	zTemp0
.99d8	d0 07		bne $99e1			bne 	_CMClearNext
.99da	ad 8d 04	lda $048d			lda 	lowMemPtr+1
.99dd	c5 37		cmp $37				cmp 	zTemp0+1
.99df	f0 0c		beq $99ed			beq 	_CMExit
.99e1					_CMClearNext:
.99e1	a9 00		lda #$00			lda 	#0 							; clear byte, advance to next.
.99e3	92 36		sta ($36)			sta 	(zTemp0)
.99e5	e6 36		inc $36				inc 	zTemp0
.99e7	d0 ea		bne $99d3			bne 	_ClearMemory
.99e9	e6 37		inc $37				inc		zTemp0+1
.99eb	80 e6		bra $99d3			bra 	_ClearMemory
.99ed					_CMExit:
.99ed	fa		plx				plx
.99ee	68		pla				pla
.99ef	7a		ply				ply
.99f0	60		rts				rts
.99f1					CheckIdentifierStringSpace:
.99f1	48		pha				pha
.99f2	ad 8d 04	lda $048d			lda 	lowMemPtr+1 				; get low memory pointer
.99f5	18		clc				clc
.99f6	69 02		adc #$02			adc 	#2 							; need at least 2 256 byte pages
.99f8	cd 8f 04	cmp $048f			cmp 	StringMemory+1 				; is it >= StringMemory
.99fb	b0 02		bcs $99ff			bcs 	CISSMemory
.99fd	68		pla				pla
.99fe	60		rts				rts
.99ff					CISSMemory:
.99ff	a9 06		lda #$06		lda	#6
.9a01	4c 65 8d	jmp $8d65		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/asc.asm

.9a04					AscUnary:
.9a04	fa		plx				plx 								; restore stack pos
.9a05	20 5c 9d	jsr $9d5c			jsr 	EvaluateString 				; get a string
.9a08	b2 36		lda ($36)			lda 	(zTemp0)					; get/return firs character
.9a0a	20 2a 9e	jsr $9e2a			jsr 	NSMSetByte
.9a0d	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.9a10	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/frac.asm

.9a11					FracUnary:
.9a11	fa		plx				plx 								; restore stack pos
.9a12	20 51 9d	jsr $9d51			jsr 	EvaluateNumber 				; get a float or int
.9a15	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.9a18	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9a1b	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9a1d	f0 04		beq $9a23			beq 	_IUZero
.9a1f	20 47 94	jsr $9447			jsr 	FloatFractionalPart
.9a22	60		rts				rts
.9a23					_IUZero:
.9a23	20 28 9e	jsr $9e28			jsr 	NSMSetZero
.9a26	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/int.asm

.9a27					IntUnary:
.9a27	fa		plx				plx 								; restore stack pos
.9a28	20 51 9d	jsr $9d51			jsr 	EvaluateNumber 				; get a float or int
.9a2b	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.9a2e	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9a31	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9a33	f0 03		beq $9a38			beq 	_IUExit
.9a35	20 aa 94	jsr $94aa			jsr 	FloatIntegerPart
.9a38					_IUExit:
.9a38	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/len.asm

.9a39					LenUnary:
.9a39	fa		plx				plx 								; restore stack pos
.9a3a	20 5c 9d	jsr $9d5c			jsr 	EvaluateString 				; get a string
.9a3d	5a		phy				phy
.9a3e	a0 00		ldy #$00			ldy 	#0 							; find length
.9a40					_LenFind:
.9a40	b1 36		lda ($36),y			lda 	(zTemp0),y
.9a42	f0 06		beq $9a4a			beq 	_LenExit
.9a44	c8		iny				iny
.9a45	d0 f9		bne $9a40			bne 	_LenFind
.9a47	4c b7 9f	jmp $9fb7			jmp 	RangeError 					; string > 255
.9a4a					_LenExit:
.9a4a	98		tya				tya
.9a4b	20 2a 9e	jsr $9e2a			jsr 	NSMSetByte
.9a4e	7a		ply				ply
.9a4f	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.9a52	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/minmax.asm

.9a53					Unary_Min:
.9a53	a9 01		lda #$01			lda 	#1
.9a55	80 02		bra $9a59			bra 	UnaryMinMaxMain
.9a57					Unary_Max:
.9a57	a9 ff		lda #$ff			lda 	#$FF 						; value from comparator to cause a write
.9a59					UnaryMinMaxMain:
.9a59	fa		plx				plx 								; get index on number stack
.9a5a	48		pha				pha 								; save comparator
.9a5b	20 48 9d	jsr $9d48			jsr 	EvaluateValue 				; get the first value.
.9a5e					_UMMMLoop:
.9a5e	b1 30		lda ($30),y			lda 	(codePtr),y
.9a60	c9 29		cmp #$29			cmp 	#KWD_RPAREN 				; if right bracket then done.
.9a62	f0 22		beq $9a86			beq 	_UMMMDone
.9a64	20 54 8d	jsr $8d54			jsr 	CheckComma 					; must be a comma
.9a67	e8		inx				inx
.9a68	20 48 9d	jsr $9d48			jsr 	EvaluateValue
.9a6b	ca		dex				dex
.9a6c	20 ff 9d	jsr $9dff			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] (Compare is destructive)
.9a6f	e8		inx				inx
.9a70	20 ff 9d	jsr $9dff			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2], original
.9a73	e8		inx				inx
.9a74	20 1d 8e	jsr $8e1d			jsr 	CompareBaseCode 			; part of > = < etc. code, returns 255,0 or 1
.9a77	ca		dex				dex
.9a78	ca		dex				dex
.9a79	85 36		sta $36				sta 	zTemp0 						; save required result
.9a7b	68		pla				pla 								; get and save comparator
.9a7c	48		pha				pha
.9a7d	c5 36		cmp $36				cmp 	zTemp0 						; if the comparator
.9a7f	d0 dd		bne $9a5e			bne 	_UMMMLoop
.9a81	20 89 9a	jsr $9a89			jsr 	ExpCopyAboveDown 			; copy next up slot down
.9a84	80 d8		bra $9a5e			bra 	_UMMMLoop
.9a86					_UMMMDone:
.9a86	68		pla				pla 								; throw the comparator
.9a87	c8		iny				iny 								; skip )
.9a88	60		rts				rts
.9a89					ExpCopyAboveDown:
.9a89	bd 01 04	lda $0401,x			lda 	NSStatus+1,x
.9a8c	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9a8f	bd 29 04	lda $0429,x			lda 	NSExponent+1,x
.9a92	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9a95	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.9a98	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9a9b	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.9a9e	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9aa1	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.9aa4	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9aa7	bd 21 04	lda $0421,x			lda 	NSMantissa3+1,x
.9aaa	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9aad	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/not.asm

.9aae					Unary_Not:
.9aae	fa		plx				plx
.9aaf	20 74 9d	jsr $9d74			jsr 	EvaluateInteger 			; get integer
.9ab2	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.9ab5	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; zero mantissa ?
.9ab8	f0 04		beq $9abe			beq 	_NotZero
.9aba	20 28 9e	jsr $9e28			jsr 	NSMSetZero
.9abd	60		rts				rts
.9abe					_NotZero:
.9abe	4c d2 8d	jmp $8dd2			jmp 	ReturnTrue
.9ac1					_UNBad:
.9ac1	4c c1 9f	jmp $9fc1			jmp 	ArgumentError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/rnd.asm

.9ac4					Unary_Random:
.9ac4	fa		plx				plx
.9ac5	20 43 9b	jsr $9b43			jsr 	Random32Bit 				; get a random number
.9ac8	20 28 9b	jsr $9b28			jsr 	URCopyToMantissa  			; put in mantissa
.9acb	b1 30		lda ($30),y			lda 	(codePtr),y
.9acd	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.9acf	f0 08		beq $9ad9			beq 	_URNoModulus
.9ad1	e8		inx				inx
.9ad2	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger 		; put modulus value in +1
.9ad5	ca		dex				dex
.9ad6	20 41 8f	jsr $8f41			jsr 	IntegerModulusNoCheck 		; calculate modulus
.9ad9					_URNoModulus:
.9ad9	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; make it an integer positive
.9adc	9e 28 04	stz $0428,x			stz 	NSExponent,x
.9adf	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.9ae2	60		rts				rts
.9ae3					Unary_Rnd:
.9ae3	fa		plx				plx
.9ae4	20 51 9d	jsr $9d51			jsr 	EvaluateNumber 				; number to use.
.9ae7	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket 			; closing bracket
.9aea	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; if zero, then don't generate a new number
.9aed	f0 2b		beq $9b1a			beq 	_URCopySeed
.9aef	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; if -ve, then seed using parameter
.9af2	10 23		bpl $9b17			bpl 	_URDontSeed
.9af4	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy - value to seed butchering it.
.9af7	49 17		eor #$17			eor 	#$17
.9af9	8d 88 04	sta $0488			sta 	RandomSeed+0
.9afc	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9aff	49 a5		eor #$a5			eor 	#$A5
.9b01	8d 89 04	sta $0489			sta 	RandomSeed+1
.9b04	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9b07	49 c2		eor #$c2			eor 	#$C2
.9b09	8d 8a 04	sta $048a			sta 	RandomSeed+2
.9b0c	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9b0f	49 9d		eor #$9d			eor 	#$9D
.9b11	8d 8b 04	sta $048b			sta 	RandomSeed+3
.9b14	20 43 9b	jsr $9b43			jsr 	Random32Bit
.9b17					_URDontSeed:
.9b17	20 43 9b	jsr $9b43			jsr 	Random32Bit 				; generate a number.
.9b1a					_URCopySeed:
.9b1a	20 28 9b	jsr $9b28			jsr 	URCopyToMantissa 			; copy into mantissa
.9b1d	a9 e2		lda #$e2			lda 	#-30 						; force into 0-1 range
.9b1f	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9b22	a9 08		lda #$08			lda 	#NSTFloat
.9b24	9d 00 04	sta $0400,x			sta 	NSStatus,x 					; positive.
.9b27	60		rts				rts
.9b28					URCopyToMantissa:
.9b28	ad 88 04	lda $0488			lda 	RandomSeed+0
.9b2b	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9b2e	ad 89 04	lda $0489			lda 	RandomSeed+1
.9b31	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9b34	ad 8a 04	lda $048a			lda 	RandomSeed+2
.9b37	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9b3a	ad 8b 04	lda $048b			lda 	RandomSeed+3
.9b3d	29 3f		and #$3f			and 	#$3F 						; make legal mantissa
.9b3f	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9b42	60		rts				rts
.9b43					Random32Bit:
.9b43	5a		phy				phy
.9b44	a0 07		ldy #$07			ldy 	#7 							; do it 7 times
.9b46	ad 88 04	lda $0488			lda 	RandomSeed+0 				; check the seed isn't zero
.9b49	d0 03		bne $9b4e			bne 	_Random1
.9b4b	a8		tay				tay 								; if so do it 256 times
.9b4c	a9 aa		lda #$aa			lda		#$AA 						; and use this to seed the seed....
.9b4e					_Random1:
.9b4e	0a		asl a				asl 	a 							; LSFR RNG
.9b4f	2e 89 04	rol $0489			rol 	RandomSeed+1
.9b52	2e 8a 04	rol $048a			rol 	RandomSeed+2
.9b55	2e 8b 04	rol $048b			rol 	RandomSeed+3
.9b58	90 02		bcc $9b5c			bcc 	_Random2
.9b5a	49 c5		eor #$c5			eor 	#$C5
.9b5c					_Random2:
.9b5c	88		dey				dey
.9b5d	d0 ef		bne $9b4e			bne 	_Random1
.9b5f	8d 88 04	sta $0488			sta 	RandomSeed+0
.9b62	7a		ply				ply
.9b63	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/sgn.asm

.9b64					SgnUnary:
.9b64	fa		plx				plx 								; restore stack pos
.9b65	20 51 9d	jsr $9d51			jsr 	EvaluateNumber 				; get a float or int
.9b68	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.9b6b	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; if zero
.9b6e	f0 10		beq $9b80			beq 	_SGZero  					; return Int Zero
.9b70	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get status w/sign
.9b73	48		pha				pha
.9b74	a9 01		lda #$01			lda 	#1 							; set to 1
.9b76	20 2a 9e	jsr $9e2a			jsr 	NSMSetByte
.9b79	68		pla				pla
.9b7a	29 80		and #$80			and		#$80 						; copy the sign byte out
.9b7c	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9b7f	60		rts				rts
.9b80	20 28 9e	jsr $9e28	_SGZero:jsr 	NSMSetZero
.9b83	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/val.asm

.9b84					ValUnary:
.9b84	fa		plx				plx 								; restore stack pos
.9b85	20 9a 9b	jsr $9b9a			jsr 	ValMainCode 				; do the main val() code
.9b88	b0 01		bcs $9b8b			bcs 	_VUError 					; couldn't convert
.9b8a	60		rts				rts
.9b8b					_VUError:
.9b8b	4c bc 9f	jmp $9fbc			jmp 	TypeError
.9b8e					IsValUnary:
.9b8e	fa		plx				plx 								; restore stack pos
.9b8f	20 9a 9b	jsr $9b9a			jsr 	ValMainCode 				; do the main val() code
.9b92	b0 03		bcs $9b97			bcs 	_VUBad
.9b94	4c d2 8d	jmp $8dd2			jmp 	ReturnTrue
.9b97					_VUBad:
.9b97	4c de 8d	jmp $8dde			jmp 	ReturnFalse
.9b9a					ValMainCode:
.9b9a	20 5c 9d	jsr $9d5c			jsr 	EvaluateString 				; get a string
.9b9d	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket 			; check right bracket present
.9ba0	5a		phy				phy
.9ba1	b2 36		lda ($36)			lda 	(zTemp0) 					; check not empty string
.9ba3	f0 17		beq $9bbc			beq 	_VMCFail2
.9ba5	a0 ff		ldy #$ff			ldy 	#$FF 						; start position
.9ba7	48		pha				pha 								; save first character
.9ba8	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it -
.9baa	d0 01		bne $9bad			bne 	_VMCStart
.9bac	c8		iny				iny 								; skip over -
.9bad					_VMCStart:
.9bad	38		sec				sec 								; initialise first time round.
.9bae					_VMCNext:
.9bae	c8		iny				iny 								; pre-increment
.9baf	b1 36		lda ($36),y			lda 	(zTemp0),y 					; next character
.9bb1	f0 0c		beq $9bbf			beq 	_VMCSuccess 				; successful.
.9bb3	20 d0 96	jsr $96d0			jsr 	EncodeNumber 				; send it to the number-builder
.9bb6	90 03		bcc $9bbb			bcc 	_VMCFail 					; if failed, give up.
.9bb8	18		clc				clc 								; next time round, countinue
.9bb9	80 f3		bra $9bae			bra 	_VMCNext
.9bbb					_VMCFail:
.9bbb	68		pla				pla
.9bbc					_VMCFail2:
.9bbc	7a		ply				ply
.9bbd	38		sec				sec
.9bbe	60		rts				rts
.9bbf					_VMCSuccess:
.9bbf	a9 00		lda #$00			lda 	#0 							; construct final
.9bc1	20 d0 96	jsr $96d0			jsr 	EncodeNumber
.9bc4	68		pla				pla
.9bc5	c9 2d		cmp #$2d			cmp 	#"-"
.9bc7	d0 03		bne $9bcc			bne 	_VMCNotNegative
.9bc9	20 d4 9d	jsr $9dd4			jsr		NSMNegate
.9bcc					_VMCNotNegative:
.9bcc	7a		ply				ply
.9bcd	18		clc				clc
.9bce	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/chr.asm

.9bcf					ChrUnary:
.9bcf	fa		plx				plx 								; restore stack pos
.9bd0	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger			; get value
.9bd3	48		pha				pha
.9bd4	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.9bd7	a9 01		lda #$01			lda 	#1 							; allocate space for one char
.9bd9	20 91 a7	jsr $a791			jsr 	StringTempAllocate
.9bdc	68		pla				pla 								; write number to it
.9bdd	20 cf a7	jsr $a7cf			jsr 	StringTempWrite
.9be0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/spc.asm

.9be1					SpcUnary:
.9be1	fa		plx				plx 								; restore stack pos
.9be2	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger			; get value
.9be5	5a		phy				phy
.9be6	48		pha				pha 								; save count
.9be7	20 91 a7	jsr $a791			jsr 	StringTempAllocate
.9bea	7a		ply				ply 								; to do count in Y
.9beb					_SpcLoop:
.9beb	c0 00		cpy #$00			cpy 	#0
.9bed	f0 08		beq $9bf7			beq 	_SpcExit
.9bef	a9 20		lda #$20			lda 	#32
.9bf1	20 cf a7	jsr $a7cf			jsr 	StringTempWrite
.9bf4	88		dey				dey
.9bf5	80 f4		bra $9beb			bra 	_SPCLoop
.9bf7					_SpcExit:
.9bf7	7a		ply				ply
.9bf8	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.9bfb	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/str.asm

.9bfc					Unary_Str:
.9bfc	fa		plx				plx
.9bfd	20 51 9d	jsr $9d51			jsr 	EvaluateNumber  			; get number
.9c00	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket 			; closing bracket
.9c03	a9 05		lda #$05			lda 	#5 							; maximum decimals, from Basic816
.9c05	20 1e 9c	jsr $9c1e			jsr 	ConvertNumberToString 		; do the conversion.
.9c08	a9 21		lda #$21			lda		#33 						; create buffer
.9c0a	20 91 a7	jsr $a791			jsr 	StringTempAllocate 			; allocate memory
.9c0d	da		phx				phx
.9c0e	a2 00		ldx #$00			ldx 	#0
.9c10					_USCopy:
.9c10	bd 1b 06	lda $061b,x			lda 	DecimalBuffer,x
.9c13	20 cf a7	jsr $a7cf			jsr 	StringTempWrite
.9c16	e8		inx				inx
.9c17	bd 1b 06	lda $061b,x			lda 	DecimalBuffer,x
.9c1a	d0 f4		bne $9c10			bne 	_USCopy
.9c1c	fa		plx				plx
.9c1d	60		rts				rts
.9c1e					ConvertNumberToString:
.9c1e	5a		phy				phy 								; save code position
.9c1f	8d 94 04	sta $0494			sta 	DecimalPlaces	 			; save number of DPs.
.9c22	9c 95 04	stz $0495			stz 	dbOffset 					; offset into decimal buffer = start.
.9c25	bd 00 04	lda $0400,x			lda 	NSStatus,x  				; is it -ve.
.9c28	10 0a		bpl $9c34			bpl 	_CNTSNotNegative
.9c2a	29 7f		and #$7f			and 	#$7F 						; make +ve
.9c2c	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9c2f	a9 2d		lda #$2d			lda 	#"-"
.9c31	20 9a 9c	jsr $9c9a			jsr 	WriteDecimalBuffer
.9c34					_CNTSNotNegative:
.9c34	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if decimal
.9c37	f0 15		beq $9c4e			beq 	_CNTSNotFloat
.9c39	e8		inx				inx 								; round up
.9c3a	a9 01		lda #$01			lda 	#1
.9c3c	20 2a 9e	jsr $9e2a			jsr 	NSMSetByte
.9c3f	ca		dex				dex
.9c40	bd 28 04	lda $0428,x			lda		NSExponent,x
.9c43	9d 29 04	sta $0429,x			sta 	NSExponent+1,x
.9c46	a9 08		lda #$08			lda 	#NSTFloat
.9c48	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.9c4b	20 61 93	jsr $9361			jsr 	FloatAdd
.9c4e					_CNTSNotFloat:
.9c4e	20 7c 9c	jsr $9c7c			jsr 	MakePlusTwoString
.9c51	20 47 94	jsr $9447			jsr 	FloatFractionalPart 		; get the fractional part
.9c54	20 0b 95	jsr $950b			jsr 	NSNormalise					; normalise , exit if zero
.9c57	f0 21		beq $9c7a			beq 	_CNTSExit
.9c59	a9 2e		lda #$2e			lda 	#"."
.9c5b	20 9a 9c	jsr $9c9a			jsr 	WriteDecimalBuffer 			; write decimal place
.9c5e					_CNTSDecimal:
.9c5e	ce 94 04	dec $0494			dec 	DecimalPlaces 				; done all the decimals
.9c61	30 17		bmi $9c7a			bmi 	_CNTSExit
.9c63	e8		inx				inx 								; x 10.0
.9c64	a9 0a		lda #$0a			lda 	#10
.9c66	20 2a 9e	jsr $9e2a			jsr 	NSMSetByte
.9c69	a9 08		lda #$08			lda 	#NSTFloat
.9c6b	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9c6e	ca		dex				dex
.9c6f	20 d4 94	jsr $94d4			jsr 	FloatMultiply
.9c72	20 7c 9c	jsr $9c7c			jsr 	MakePlusTwoString
.9c75	20 47 94	jsr $9447			jsr 	FloatFractionalPart 		; get the fractional part
.9c78	80 e4		bra $9c5e			bra 	_CNTSDecimal 				; keep going.
.9c7a					_CNTSExit:
.9c7a	7a		ply				ply
.9c7b	60		rts				rts
.9c7c					MakePlusTwoString:
.9c7c	da		phx				phx
.9c7d	20 ff 9d	jsr $9dff			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.9c80	e8		inx				inx 								; access it
.9c81	e8		inx				inx
.9c82	20 aa 94	jsr $94aa			jsr 	FloatIntegerPart 			; make it an integer
.9c85	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.9c87	20 8c 92	jsr $928c			jsr 	ConvertInt32
.9c8a	a2 00		ldx #$00			ldx	 	#0
.9c8c					_MPTSCopy:
.9c8c	bd f9 05	lda $05f9,x			lda 	NumberBuffer,x
.9c8f	20 9a 9c	jsr $9c9a			jsr 	WriteDecimalBuffer
.9c92	e8		inx				inx
.9c93	bd f9 05	lda $05f9,x			lda 	NumberBuffer,x
.9c96	d0 f4		bne $9c8c			bne 	_MPTSCopy
.9c98	fa		plx				plx
.9c99	60		rts				rts
.9c9a					WriteDecimalBuffer:
.9c9a	da		phx				phx
.9c9b	ae 95 04	ldx $0495			ldx 	dbOffset
.9c9e	9d 1b 06	sta $061b,x			sta 	DecimalBuffer,x
.9ca1	9e 1c 06	stz $061c,x			stz 	DecimalBuffer+1,x
.9ca4	ee 95 04	inc $0495			inc 	dbOffset
.9ca7	fa		plx				plx
.9ca8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/substring.asm

.9ca9					Unary_Left:
.9ca9	fa		plx				plx
.9caa	18		clc				clc 								; only one parameter
.9cab	20 20 9d	jsr $9d20			jsr 	SubstringInitial 			; set up.
.9cae	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; Param #1 is the length
.9cb1	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9cb4	9e 09 04	stz $0409,x			stz 	NSMantissa0+1,x 			; Start is zero.
.9cb7	80 2c		bra $9ce5			bra 	SubstringMain
.9cb9					Unary_Right:
.9cb9	fa		plx				plx
.9cba	18		clc				clc 								; only one parameter
.9cbb	20 20 9d	jsr $9d20			jsr 	SubstringInitial 			; set up.
.9cbe	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; length => param 2
.9cc1	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9cc4	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; total length
.9cc7	fd 09 04	sbc $0409,x			sbc 	NSMantissa0+1,x 			; length - required.
.9cca	b0 02		bcs $9cce			bcs 	_URNotUnderflow
.9ccc	a9 00		lda #$00			lda 	#0 							; start from the beginning, as something like right$("AB",3)
.9cce					_URNotUnderFlow:
.9cce	9d 09 04	sta $0409,x			sta 	NSMantissa0+1,x 			; this is the start position
.9cd1	80 12		bra $9ce5			bra 	SubStringMain
.9cd3					Unary_Mid:
.9cd3	fa		plx				plx
.9cd4	38		sec				sec 								; two parameters
.9cd5	20 20 9d	jsr $9d20			jsr 	SubstringInitial 			; set up.
.9cd8	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; first parameter is zero ?
.9cdb	f0 05		beq $9ce2			beq 	_UMError
.9cdd	de 09 04	dec $0409,x			dec 	NSMantissa0+1,x				; reduce initial offset by 1 as MID$(a$,1..) is actually the first character
.9ce0	80 03		bra $9ce5			bra 	SubStringMain
.9ce2					_UMError:
.9ce2	4c c1 9f	jmp $9fc1			jmp 	ArgumentError
.9ce5					SubStringMain:
.9ce5	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; is the initial offset >= the length
.9ce8	dd 28 04	cmp $0428,x			cmp 	NSExponent,x
.9ceb	b0 2d		bcs $9d1a			bcs 	_SSMNull 					; if so, return an empty string.
.9ced	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; if copy count is zero
.9cf0	f0 28		beq $9d1a			beq 	_SSMNull 					; return empty string.
.9cf2	18		clc				clc 								; add the offset +1 to the address and
.9cf3	bd 08 04	lda $0408,x			lda	 	NSMantissa0,x 				; put in zTemp
.9cf6	7d 09 04	adc $0409,x			adc 	NSMantissa0+1,x
.9cf9	85 36		sta $36				sta 	zTemp0
.9cfb	bd 10 04	lda $0410,x			lda	 	NSMantissa1,x
.9cfe	69 00		adc #$00			adc 	#0
.9d00	85 37		sta $37				sta 	zTemp0+1
.9d02					_SSMNoCarry:
.9d02	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; characters required.
.9d05	20 91 a7	jsr $a791			jsr 	StringTempAllocate 			; allocate that many characters
.9d08	5a		phy				phy 								; save Y
.9d09	a0 00		ldy #$00			ldy 	#0 							; start copying in.
.9d0b					_SSMCopy:
.9d0b	b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next character
.9d0d	f0 09		beq $9d18			beq 	_SSMEString 				; no more to copy
.9d0f	20 cf a7	jsr $a7cf			jsr 	StringTempWrite 			; and write it out.
.9d12	c8		iny				iny
.9d13	de 0a 04	dec $040a,x			dec 	NSMantissa0+2,x
.9d16	d0 f3		bne $9d0b			bne 	_SSMCopy
.9d18					_SSMEString:
.9d18	7a		ply				ply
.9d19					_SSMExit:
.9d19	60		rts				rts
.9d1a					_SSMNull:
.9d1a	a9 00		lda #$00			lda 	#0
.9d1c	20 91 a7	jsr $a791			jsr 	StringTempAllocate
.9d1f	60		rts				rts
.9d20					SubstringInitial:
.9d20	da		phx				phx 								; save initial stack position
.9d21	08		php				php 								; save carry on stack indicating 2 parameters
.9d22	20 5c 9d	jsr $9d5c			jsr 	EvaluateString 				; get a string
.9d25	5a		phy				phy 								; calculate length to exponent.
.9d26	a0 ff		ldy #$ff			ldy 	#$FF
.9d28					_SIFindLength:
.9d28	c8		iny				iny
.9d29	b1 36		lda ($36),y			lda 	(zTemp0),y
.9d2b	d0 fb		bne $9d28			bne 	_SIFindLength
.9d2d	98		tya				tya
.9d2e	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9d31	7a		ply				ply
.9d32	e8		inx				inx
.9d33	20 54 8d	jsr $8d54			jsr 	CheckComma 					; comma next
.9d36	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; get next parameter
.9d39	28		plp				plp 								; is it the last parameter ?
.9d3a	90 07		bcc $9d43			bcc 	_SSIExit 					; if so, exit.
.9d3c	e8		inx				inx
.9d3d	20 54 8d	jsr $8d54			jsr 	CheckComma 					; comma next
.9d40	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; get last parameter
.9d43					_SSIExit:
.9d43	fa		plx				plx
.9d44	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket 			; check closing bracket
.9d47	60		rts				rts 								; exit

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/exprhelper.asm

.9d48					EvaluateValue:
.9d48	48		pha				pha
.9d49	20 14 93	jsr $9314			jsr		EvaluateExpression 			; expression
.9d4c	20 32 96	jsr $9632			jsr 	Dereference					; derefernce it
.9d4f	68		pla				pla
.9d50	60		rts				rts
.9d51					EvaluateNumber:
.9d51	20 48 9d	jsr $9d48			jsr 	EvaluateValue 				; get a value
.9d54	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if string.
.9d57	29 10		and #$10			and 	#NSBIsString
.9d59	d0 16		bne $9d71			bne 	HelperTypeError
.9d5b	60		rts				rts
.9d5c					EvaluateString:
.9d5c	20 48 9d	jsr $9d48			jsr 	EvaluateValue 				; get a value
.9d5f	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if string.
.9d62	29 10		and #$10			and 	#NSBIsString
.9d64	f0 0b		beq $9d71			beq 	HelperTypeError
.9d66					CopyAddressToTemp0:
.9d66	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address -> zTemp0
.9d69	85 36		sta $36				sta 	zTemp0
.9d6b	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9d6e	85 37		sta $37				sta 	zTemp0+1
.9d70	60		rts				rts
.9d71					HelperTypeError:
.9d71	4c bc 9f	jmp $9fbc			jmp 	TypeError
.9d74					EvaluateInteger:
.9d74	20 51 9d	jsr $9d51			jsr 	EvaluateNumber
.9d77	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check exponent is zero
.9d7a	d0 0a		bne $9d86			bne 	HelperValueError 			; if not, it's a float.
.9d7c	60		rts				rts
.9d7d					EvaluateUnsignedInteger:
.9d7d	20 74 9d	jsr $9d74			jsr 	EvaluateInteger 			; check integer is +ve
.9d80	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9d83	30 01		bmi $9d86			bmi 	HelperValueError
.9d85	60		rts				rts
.9d86					HelperValueError:
.9d86	4c c1 9f	jmp $9fc1			jmp 	ArgumentError
.9d89					Evaluate16BitInteger:
.9d89	20 7d 9d	jsr $9d7d			jsr	 	EvaluateUnsignedInteger		; get integer
.9d8c	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9d8f	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9d92	d0 f2		bne $9d86			bne 	HelperValueError
.9d94	60		rts				rts
.9d95					Evaluate16BitIntegerSigned:
.9d95	20 74 9d	jsr $9d74			jsr	 	EvaluateInteger				; get integer
.9d98	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9d9b	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9d9e	d0 e6		bne $9d86			bne 	HelperValueError
.9da0	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; signed ?
.9da3	10 03		bpl $9da8			bpl 	_EISNotSigned
.9da5	20 dd 9d	jsr $9ddd			jsr 	NSMNegateMantissa
.9da8					_EISNotSigned:
.9da8	60		rts				rts
.9da9					Evaluate8BitInteger:
.9da9	20 7d 9d	jsr $9d7d			jsr	 	EvaluateUnsignedInteger 	; get an integer
.9dac	d0 d8		bne $9d86			bne 	HelperValueError
.9dae	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 1, 2 & 3 must be zero
.9db1	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9db4	1d 10 04	ora $0410,x			ora 	NSMantissa1,x
.9db7	d0 cd		bne $9d86			bne 	HelperValueError
.9db9	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9dbc	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/mult8x8.asm

.9dbd					Multiply8x8:
.9dbd	4a		lsr a		  		lsr 	a  							; prime the carry bit for the loop
.9dbe	85 36		sta $36			  	sta 	zTemp0
.9dc0	86 37		stx $37				stx 	zTemp0+1
.9dc2	a9 00		lda #$00			lda 	#0
.9dc4	a2 08		ldx #$08			ldx 	#8
.9dc6					_M88Loop:
.9dc6	90 03		bcc $9dcb			bcc 	_M88NoAdd
.9dc8	18		clc				clc
.9dc9	65 37		adc $37				adc 	zTemp0+1
.9dcb					_M88NoAdd:
.9dcb	6a		ror a				ror 	a
.9dcc	66 36		ror $36				ror 	zTemp0  					; pull another bit out for the next iteration
.9dce	ca		dex				dex         						; inc/dec don't modify carry; only shifts and adds do
.9dcf	d0 f5		bne $9dc6			bne 	_M88Loop
.9dd1	85 37		sta $37				sta 	zTemp0+1 					; store high 8 bits.
.9dd3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/utility.asm

.9dd4					NSMNegate:
.9dd4	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9dd7	49 80		eor #$80			eor 	#NSBIsNegative
.9dd9	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9ddc	60		rts				rts
.9ddd					NSMNegateMantissa:
.9ddd	38		sec				sec
.9dde	a9 00		lda #$00			lda 	#0
.9de0	fd 08 04	sbc $0408,x			sbc 	NSMantissa0,x
.9de3	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9de6	a9 00		lda #$00			lda 	#0
.9de8	fd 10 04	sbc $0410,x			sbc 	NSMantissa1,x
.9deb	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9dee	a9 00		lda #$00			lda 	#0
.9df0	fd 18 04	sbc $0418,x			sbc 	NSMantissa2,x
.9df3	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9df6	a9 00		lda #$00			lda 	#0
.9df8	fd 20 04	sbc $0420,x			sbc 	NSMantissa3,x
.9dfb	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9dfe	60		rts				rts
.9dff					NSMShiftUpTwo:
.9dff	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9e02	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9e05	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9e08	9d 12 04	sta $0412,x			sta 	NSMantissa1+2,x
.9e0b	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9e0e	9d 1a 04	sta $041a,x			sta 	NSMantissa2+2,x
.9e11	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9e14	9d 22 04	sta $0422,x			sta 	NSMantissa3+2,x
.9e17	bd 28 04	lda $0428,x			lda 	NSExponent,x
.9e1a	9d 2a 04	sta $042a,x			sta 	NSExponent+2,x
.9e1d	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9e20	9d 02 04	sta $0402,x			sta 	NSStatus+2,x
.9e23	60		rts				rts
.9e24					NSMSetZeroMantissaOnly:
.9e24	a9 00		lda #$00			lda 	#0
.9e26	80 08		bra $9e30			bra 	NSMSetMantissa
.9e28					NSMSetZero:
.9e28	a9 00		lda #$00			lda 	#0
.9e2a					NSMSetByte:
.9e2a	9e 28 04	stz $0428,x			stz 	NSExponent,x 				; zero exponent, as integer.
.9e2d	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; status zero (integer)
.9e30					NSMSetMantissa:
.9e30	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; mantissa
.9e33	9e 10 04	stz $0410,x			stz 	NSMantissa1,x
.9e36	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.9e39	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.9e3c	60		rts				rts
.9e3d					NSMShiftLeft:
.9e3d	18		clc				clc
.9e3e					NSMRotateLeft:
.9e3e	3e 08 04	rol $0408,x			rol 	NSMantissa0,x
.9e41	3e 10 04	rol $0410,x			rol		NSMantissa1,x
.9e44	3e 18 04	rol $0418,x			rol		NSMantissa2,x
.9e47	3e 20 04	rol $0420,x			rol		NSMantissa3,x
.9e4a	60		rts				rts
.9e4b					NSMShiftRight:
.9e4b	5e 20 04	lsr $0420,x			lsr 	NSMantissa3,x
.9e4e	7e 18 04	ror $0418,x			ror		NSMantissa2,x
.9e51	7e 10 04	ror $0410,x			ror		NSMantissa1,x
.9e54	7e 08 04	ror $0408,x			ror		NSMantissa0,x
.9e57	60		rts				rts
.9e58					NSMIsZero:
.9e58	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9e5b	1d 18 04	ora $0418,x			ora		NSMantissa2,x
.9e5e	1d 10 04	ora $0410,x			ora		NSMantissa1,x
.9e61	1d 08 04	ora $0408,x			ora		NSMantissa0,x
.9e64	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.asm

.b9f9					TickHandler:
.b9f9	5a		phy				phy 								; need to preserve Y
.b9fa	20 9f b9	jsr $b99f			jsr 	SNDUpdate 					; update sound
.b9fd	7a		ply				ply
.b9fe	60		rts				rts
.062d					LastTick:
>062d							.fill 		1

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/asmcore.asm

.9e65					Assemble_ora:
.9e65	20 6c 80	jsr $806c		jsr	AssembleGroup1
>9e68	01					.byte $01
.9e69					Assemble_and:
.9e69	20 6c 80	jsr $806c		jsr	AssembleGroup1
>9e6c	21					.byte $21
.9e6d					Assemble_eor:
.9e6d	20 6c 80	jsr $806c		jsr	AssembleGroup1
>9e70	41					.byte $41
.9e71					Assemble_adc:
.9e71	20 6c 80	jsr $806c		jsr	AssembleGroup1
>9e74	61					.byte $61
.9e75					Assemble_sta:
.9e75	20 6c 80	jsr $806c		jsr	AssembleGroup1
>9e78	81					.byte $81
.9e79					Assemble_lda:
.9e79	20 6c 80	jsr $806c		jsr	AssembleGroup1
>9e7c	a1					.byte $a1
.9e7d					Assemble_cmp:
.9e7d	20 6c 80	jsr $806c		jsr	AssembleGroup1
>9e80	c1					.byte $c1
.9e81					Assemble_sbc:
.9e81	20 6c 80	jsr $806c		jsr	AssembleGroup1
>9e84	e1					.byte $e1
.9e85					Assemble_asl:
.9e85	20 73 80	jsr $8073		jsr	AssembleGroup2
>9e88	02					.byte $02
>9e89	75					.byte $75
.9e8a					Assemble_rol:
.9e8a	20 73 80	jsr $8073		jsr	AssembleGroup2
>9e8d	22					.byte $22
>9e8e	75					.byte $75
.9e8f					Assemble_lsr:
.9e8f	20 73 80	jsr $8073		jsr	AssembleGroup2
>9e92	42					.byte $42
>9e93	75					.byte $75
.9e94					Assemble_ror:
.9e94	20 73 80	jsr $8073		jsr	AssembleGroup2
>9e97	62					.byte $62
>9e98	75					.byte $75
.9e99					Assemble_stx:
.9e99	20 73 80	jsr $8073		jsr	AssembleGroup2
>9e9c	82					.byte $82
>9e9d	50					.byte $50
.9e9e					Assemble_ldx:
.9e9e	20 73 80	jsr $8073		jsr	AssembleGroup2
>9ea1	a2					.byte $a2
>9ea2	d0					.byte $d0
.9ea3					Assemble_dec:
.9ea3	20 73 80	jsr $8073		jsr	AssembleGroup2
>9ea6	c2					.byte $c2
>9ea7	55					.byte $55
.9ea8					Assemble_inc:
.9ea8	20 73 80	jsr $8073		jsr	AssembleGroup2
>9eab	e2					.byte $e2
>9eac	55					.byte $55
.9ead					Assemble_stz:
.9ead	20 73 80	jsr $8073		jsr	AssembleGroup2
>9eb0	60					.byte $60
>9eb1	44					.byte $44
.9eb2					Assemble_bit:
.9eb2	20 73 80	jsr $8073		jsr	AssembleGroup2
>9eb5	20					.byte $20
>9eb6	55					.byte $55
.9eb7					Assemble_sty:
.9eb7	20 73 80	jsr $8073		jsr	AssembleGroup2
>9eba	80					.byte $80
>9ebb	54					.byte $54
.9ebc					Assemble_ldy:
.9ebc	20 73 80	jsr $8073		jsr	AssembleGroup2
>9ebf	a0					.byte $a0
>9ec0	d5					.byte $d5
.9ec1					Assemble_cpy:
.9ec1	20 73 80	jsr $8073		jsr	AssembleGroup2
>9ec4	c0					.byte $c0
>9ec5	d4					.byte $d4
.9ec6					Assemble_cpx:
.9ec6	20 73 80	jsr $8073		jsr	AssembleGroup2
>9ec9	e0					.byte $e0
>9eca	d0					.byte $d0
.9ecb					Assemble_tsb:
.9ecb	20 73 80	jsr $8073		jsr	AssembleGroup2
>9ece	00					.byte $00
>9ecf	50					.byte $50
.9ed0					Assemble_trb:
.9ed0	20 73 80	jsr $8073		jsr	AssembleGroup2
>9ed3	10					.byte $10
>9ed4	50					.byte $50
.9ed5					Assemble_jsr:
.9ed5	20 73 80	jsr $8073		jsr	AssembleGroup2
>9ed8	14					.byte $14
>9ed9	10					.byte $10
.9eda					Assemble_jmp:
.9eda	20 73 80	jsr $8073		jsr	AssembleGroup2
>9edd	40					.byte $40
>9ede	10					.byte $10
.9edf					Assemble_bpl:
.9edf	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9ee2	10					.byte $10
.9ee3					Assemble_bmi:
.9ee3	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9ee6	30					.byte $30
.9ee7					Assemble_bvc:
.9ee7	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9eea	50					.byte $50
.9eeb					Assemble_bvs:
.9eeb	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9eee	70					.byte $70
.9eef					Assemble_bcc:
.9eef	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9ef2	90					.byte $90
.9ef3					Assemble_bcs:
.9ef3	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9ef6	b0					.byte $b0
.9ef7					Assemble_bne:
.9ef7	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9efa	d0					.byte $d0
.9efb					Assemble_beq:
.9efb	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9efe	f0					.byte $f0
.9eff					Assemble_bra:
.9eff	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9f02	80					.byte $80
.9f03					Assemble_brk:
.9f03	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f06	00					.byte $00
.9f07					Assemble_php:
.9f07	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f0a	08					.byte $08
.9f0b					Assemble_clc:
.9f0b	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f0e	18					.byte $18
.9f0f					Assemble_plp:
.9f0f	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f12	28					.byte $28
.9f13					Assemble_sec:
.9f13	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f16	38					.byte $38
.9f17					Assemble_rti:
.9f17	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f1a	40					.byte $40
.9f1b					Assemble_pha:
.9f1b	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f1e	48					.byte $48
.9f1f					Assemble_cli:
.9f1f	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f22	58					.byte $58
.9f23					Assemble_phy:
.9f23	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f26	5a					.byte $5a
.9f27					Assemble_rts:
.9f27	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f2a	60					.byte $60
.9f2b					Assemble_pla:
.9f2b	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f2e	68					.byte $68
.9f2f					Assemble_sei:
.9f2f	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f32	78					.byte $78
.9f33					Assemble_ply:
.9f33	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f36	7a					.byte $7a
.9f37					Assemble_dey:
.9f37	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f3a	88					.byte $88
.9f3b					Assemble_txa:
.9f3b	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f3e	8a					.byte $8a
.9f3f					Assemble_tya:
.9f3f	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f42	98					.byte $98
.9f43					Assemble_txs:
.9f43	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f46	9a					.byte $9a
.9f47					Assemble_tay:
.9f47	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f4a	a8					.byte $a8
.9f4b					Assemble_tax:
.9f4b	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f4e	aa					.byte $aa
.9f4f					Assemble_clv:
.9f4f	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f52	b8					.byte $b8
.9f53					Assemble_tsx:
.9f53	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f56	ba					.byte $ba
.9f57					Assemble_iny:
.9f57	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f5a	c8					.byte $c8
.9f5b					Assemble_dex:
.9f5b	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f5e	ca					.byte $ca
.9f5f					Assemble_cld:
.9f5f	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f62	d8					.byte $d8
.9f63					Assemble_phx:
.9f63	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f66	da					.byte $da
.9f67					Assemble_stp:
.9f67	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f6a	db					.byte $db
.9f6b					Assemble_inx:
.9f6b	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f6e	e8					.byte $e8
.9f6f					Assemble_nop:
.9f6f	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f72	ea					.byte $ea
.9f73					Assemble_sed:
.9f73	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f76	f8					.byte $f8
.9f77					Assemble_plx:
.9f77	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f7a	fa					.byte $fa

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/constants.asm

.9f7b					DecimalScalarTable:
>9f7b	66 66 66 66				.dword $66666666 ; 0.1
>9f7f	de					.byte $de
>9f80	1f 85 eb 51				.dword $51eb851f ; 0.01
>9f84	db					.byte $db
>9f85	4c 37 89 41				.dword $4189374c ; 0.001
>9f89	d8					.byte $d8
>9f8a	ac 8b db 68				.dword $68db8bac ; 0.0001
>9f8e	d4					.byte $d4
>9f8f	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>9f93	d1					.byte $d1
>9f94	83 de 1b 43				.dword $431bde83 ; 1e-06
>9f98	ce					.byte $ce
>9f99	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>9f9d	ca					.byte $ca
>9f9e	89 3b e6 55				.dword $55e63b89 ; 1e-08
>9fa2	c7					.byte $c7
>9fa3	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>9fa7	c4					.byte $c4
>9fa8	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>9fac	c0					.byte $c0
>9fad	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>9fb1	bd					.byte $bd

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.asm

.9fb2					SyntaxError:
.9fb2	a9 02		lda #$02		lda	#2
.9fb4	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.9fb7					RangeError:
.9fb7	a9 04		lda #$04		lda	#4
.9fb9	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.9fbc					TypeError:
.9fbc	a9 05		lda #$05		lda	#5
.9fbe	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.9fc1					ArgumentError:
.9fc1	a9 07		lda #$07		lda	#7
.9fc3	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.9fc6					NotDoneError:
.9fc6	a9 0c		lda #$0c		lda	#12
.9fc8	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.9fcb					ErrorText:
>9fcb	42 72 65 61 6b 00			.text	"Break",0
>9fd1	53 79 6e 74 61 78 20 65			.text	"Syntax error",0
>9fd9	72 72 6f 72 00
>9fde	44 69 76 69 73 69 6f 6e			.text	"Division by zero",0
>9fe6	20 62 79 20 7a 65 72 6f 00
>9fef	4f 75 74 20 6f 66 20 52			.text	"Out of Range",0
>9ff7	61 6e 67 65 00
>9ffc	54 79 70 65 20 6d 69 73			.text	"Type mismatch",0
>a004	6d 61 74 63 68 00
>a00a	4f 75 74 20 6f 66 20 6d			.text	"Out of memory",0
>a012	65 6d 6f 72 79 00
>a018	49 6c 6c 65 67 61 6c 20			.text	"Illegal argument",0
>a020	61 72 67 75 6d 65 6e 74 00
>a029	53 74 6f 70 00				.text	"Stop",0
>a02e	53 74 72 69 6e 67 20 74			.text	"String too long",0
>a036	6f 6f 20 6c 6f 6e 67 00
>a03e	41 73 73 65 72 74 69 6f			.text	"Assertion failed",0
>a046	6e 20 66 61 69 6c 65 64 00
>a04f	4f 75 74 20 6f 66 20 64			.text	"Out of data",0
>a057	61 74 61 00
>a05b	55 6e 69 6d 70 6c 65 6d			.text	"Unimplemented",0
>a063	65 6e 74 65 64 00
>a069	4e 6f 20 73 75 63 68 20			.text	"No such line number",0
>a071	6c 69 6e 65 20 6e 75 6d 62 65 72 00
>a07d	52 65 74 75 72 6e 20 77			.text	"Return without Gosub",0
>a085	69 74 68 6f 75 74 20 47 6f 73 75 62 00
>a092	55 6e 74 69 6c 20 77 69			.text	"Until without Repeat",0
>a09a	74 68 6f 75 74 20 52 65 70 65 61 74 00
>a0a7	57 65 6e 64 20 77 69 74			.text	"Wend without While",0
>a0af	68 6f 75 74 20 57 68 69 6c 65 00
>a0ba	4e 65 78 74 20 77 69 74			.text	"Next without For",0
>a0c2	68 6f 75 74 20 46 6f 72 00
>a0cb	42 41 53 49 43 20 53 74			.text	"BASIC Stack full",0
>a0d3	61 63 6b 20 66 75 6c 6c 00
>a0dc	4f 70 65 6e 20 53 74 72			.text	"Open Structure",0
>a0e4	75 63 74 75 72 65 00
>a0eb	45 6e 64 50 72 6f 63 20			.text	"EndProc without call",0
>a0f3	77 69 74 68 6f 75 74 20 63 61 6c 6c 00
>a100	41 72 72 61 79 20 61 6c			.text	"Array already defined",0
>a108	72 65 61 64 79 20 64 65 66 69 6e 65 64 00
>a116	41 72 72 61 79 20 73 69			.text	"Array size",0
>a11e	7a 65 00
>a121	42 61 64 20 61 72 72 61			.text	"Bad array index",0
>a129	79 20 69 6e 64 65 78 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/timestamp.asm

>a131	42 75 69 6c 74 20 54 75			.text "Built Tuesday 22-Nov-2022. Build 3536."
>a139	65 73 64 61 79 20 32 32 2d 4e 6f 76 2d 32 30 32
>a149	32 2e 20 42 75 69 6c 64 20 33 35 33 36 2e

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcommand.asm

.a157					RectangleCommand:
.a157	a9 44		lda #$44			lda 	#GCMD_FrameRect				; frame rectangle
.a159	80 02		bra $a15d			bra 	ShapeDrawCmd
.a15b					CircleCommand:
.a15b	a9 48		lda #$48			lda 	#GCMD_FrameCircle 				; framed circle
.a15d					ShapeDrawCmd:
.a15d	20 eb a1	jsr $a1eb			jsr 	RunGraphicsCommand
.a160					ShapeDraw:
.a160	0d 2f 06	ora $062f			ora 	gxFillSolid  				; adjust AXY for solid fill.
.a163	4c df a1	jmp $a1df			jmp 	ExecuteGraphicCommand	 	; and complete
.a166					SpriteCommand:
.a166	a2 00		ldx #$00			ldx 	#0
.a168	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; get image number.
.a16b	5a		phy				phy
.a16c	a9 0e		lda #$0e			lda 	#GCMD_SpriteUse 			; use that image.
.a16e	ae 08 04	ldx $0408			ldx 	NSMantissa0
.a171	e0 40		cpx #$40			cpx 	#64 						; 0-63 only
.a173	b0 0d		bcs $a182			bcs 	_SCRange
.a175	a0 ff		ldy #$ff			ldy 	#255
.a177	20 de aa	jsr $aade			jsr 	GXGraphicDraw
.a17a	a9 52		lda #$52			lda 	#GCMD_SpriteMove
.a17c	7a		ply				ply
.a17d	20 eb a1	jsr $a1eb			jsr 	RunGraphicsCommand
.a180	80 5d		bra $a1df			bra 	ExecuteGraphicCommand
.a182					_SCRange:
.a182	4c b7 9f	jmp $9fb7			jmp 	RangeError
.a185					ImageCommand:
.a185	a2 00		ldx #$00			ldx 	#0
.a187	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; get image number.
.a18a	20 eb a1	jsr $a1eb			jsr 	RunGraphicsCommand
.a18d					ImageRunDraw:
.a18d	09 40		ora #$40			ora 	#GCMD_Move					; move cursor
.a18f	20 de aa	jsr $aade			jsr 	GXGraphicDraw
.a192	ad 35 06	lda $0635			lda 	gxDrawScale
.a195	0a		asl a				asl 	a
.a196	0a		asl a				asl 	a
.a197	0a		asl a				asl 	a
.a198	a8		tay				tay
.a199	a9 0c		lda #$0c			lda 	#GCMD_DrawSprite 			; image drawing
.a19b	ae 08 04	ldx $0408			ldx 	NSMantissa0
.a19e	20 de aa	jsr $aade			jsr 	GXGraphicDraw
.a1a1	60		rts				rts
.a1a2					TextCommand:
.a1a2	a2 00		ldx #$00			ldx 	#0
.a1a4	20 5c 9d	jsr $9d5c			jsr 	EvaluateString 				; get text
.a1a7	20 eb a1	jsr $a1eb			jsr 	RunGraphicsCommand
.a1aa					TextRunDraw:
.a1aa	09 40		ora #$40			ora 	#GCMD_Move 					; move cursor
.a1ac	20 de aa	jsr $aade			jsr 	GXGraphicDraw
.a1af	a0 00		ldy #$00			ldy 	#0
.a1b1					_IRDLoop:
.a1b1	ad 10 04	lda $0410			lda 	NSMantissa1 				; access character
.a1b4	85 37		sta $37				sta 	zTemp0+1
.a1b6	ad 08 04	lda $0408			lda 	NSMantissa0
.a1b9	85 36		sta $36				sta 	zTemp0
.a1bb	b1 36		lda ($36),y			lda 	(zTemp0),y
.a1bd	f0 13		beq $a1d2			beq 	_IRDExit
.a1bf	5a		phy				phy									; save string pos
.a1c0	48		pha				pha 								; save char
.a1c1	ad 35 06	lda $0635			lda 	gxDrawScale 				; get scale
.a1c4	0a		asl a				asl 	a
.a1c5	0a		asl a				asl 	a
.a1c6	0a		asl a				asl 	a
.a1c7	a8		tay				tay
.a1c8	a9 0a		lda #$0a			lda 	#GCMD_DrawFont 				; char drawing
.a1ca	fa		plx				plx 								; char to draw
.a1cb	20 de aa	jsr $aade			jsr 	GXGraphicDraw
.a1ce	7a		ply				ply 								; restore string pos
.a1cf	c8		iny				iny
.a1d0	90 df		bcc $a1b1			bcc 	_IRDLoop 					; go back if no error.
.a1d2					_IRDExit:
.a1d2	60		rts				rts
.a1d3					PlotCommand:
.a1d3	a9 50		lda #$50			lda 	#GCMD_Plot 					; command ID to use
.a1d5	20 eb a1	jsr $a1eb			jsr 	RunGraphicsCommand
.a1d8	80 05		bra $a1df			bra 	ExecuteGraphicCommand
.a1da					LineCommand:
.a1da	a9 42		lda #$42			lda 	#GCMD_Line 						; command ID to use
.a1dc	20 eb a1	jsr $a1eb			jsr 	RunGraphicsCommand
.a1df					ExecuteGraphicCommand:
.a1df	0d 2e 06	ora $062e			ora 	gxCommandID 				; make a full command
.a1e2	20 de aa	jsr $aade			jsr 	GXGraphicDraw 				; draw it and exit
.a1e5	b0 01		bcs $a1e8			bcs 	_EGCError
.a1e7	60		rts				rts
.a1e8					_EGCError:
.a1e8	4c b2 9f	jmp $9fb2			jmp 	SyntaxError
.a1eb					RunGraphicsCommand:
.a1eb	8d 2e 06	sta $062e			sta 	gxCommandID					; save TODO graphics command.
.a1ee	68		pla				pla 								; pop handler address
.a1ef	fa		plx				plx
.a1f0	1a		inc a				inc 	a
.a1f1	d0 01		bne $a1f4			bne 	_RGINoCarry
.a1f3	e8		inx				inx
.a1f4					_RGINoCarry:
.a1f4	8d 33 06	sta $0633			sta 	GXHandler
.a1f7	8e 34 06	stx $0634			stx 	GXHandler+1
.a1fa					_RGICommandLoop:
.a1fa	b1 30		lda ($30),y			lda 	(codePtr),y
.a1fc	c8		iny				iny
.a1fd	c9 cd		cmp #$cd			cmp 	#KWD_TO						; is it TO x,y
.a1ff	f0 53		beq $a254			beq 	_RGI_To
.a201	c9 ba		cmp #$ba			cmp 	#KWD_HERE 					; do it here.
.a203	f0 55		beq $a25a			beq 	_RGI_Here
.a205	c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL or : , exit
.a207	f0 3d		beq $a246			beq 	_RGI_Exit
.a209	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.a20b	f0 39		beq $a246			beq 	_RGI_Exit
.a20d	c9 c1		cmp #$c1			cmp 	#KWD_OUTLINE 				; solid or outline
.a20f	f0 3e		beq $a24f			beq 	_RGI_Frame
.a211	c9 c9		cmp #$c9			cmp 	#KWD_SOLID
.a213	f0 33		beq $a248			beq 	_RGI_Solid
.a215	c9 ab		cmp #$ab			cmp 	#KWD_BY 					; by offset
.a217	f0 4b		beq $a264			beq 	_RGI_By
.a219	c9 b6		cmp #$b6			cmp 	#KWD_FROM 					; from
.a21b	f0 17		beq $a234			beq 	_RGI_Move2
.a21d	c9 b3		cmp #$b3			cmp 	#KWD_DIM 					; dim (set scale)
.a21f	f0 65		beq $a286			beq 	_RGI_Dim
.a221	c9 b1		cmp #$b1			cmp 	#KWD_COLOUR 				; colour or Color
.a223	f0 78		beq $a29d			beq 	_RGI_Colour
.a225	c9 b0		cmp #$b0			cmp 	#KWD_COLOR
.a227	f0 74		beq $a29d			beq 	_RGI_Colour
.a229	ae 2e 06	ldx $062e			ldx 	gxCommandID
.a22c	e0 52		cpx #$52			cpx 	#GCMD_SpriteMove 			; if not sprite
.a22e	d0 03		bne $a233			bne 	_RGI_Move 					; move
.a230	4c c7 a2	jmp $a2c7			jmp		_RGI_SpriteInstructions
.a233					_RGI_Move:
.a233	88		dey				dey 								; unpick get.
.a234					_RGI_Move2:
.a234	20 ed a2	jsr $a2ed			jsr 	GCGetCoordinatePair 		; move to here
.a237	20 14 a3	jsr $a314			jsr 	GCCopyPairToStore 			; save
.a23a	5a		phy				phy
.a23b	20 0a a3	jsr $a30a			jsr 	GCLoadAXY 					; load in
.a23e	09 40		ora #$40			ora 	#GCMD_Move 					; move there
.a240	20 de aa	jsr $aade			jsr 	GXGraphicDraw
.a243	7a		ply				ply
.a244	80 b4		bra $a1fa			bra 	_RGICommandLoop 			; and go round
.a246					_RGI_Exit:
.a246	88		dey				dey 								; unpick : / EOL
.a247	60		rts				rts
.a248					_RGI_Solid:
.a248	a9 02		lda #$02			lda 	#2
.a24a	8d 2f 06	sta $062f			sta 	gxFillSolid
.a24d	80 ab		bra $a1fa			bra 	_RGICommandLoop
.a24f					_RGI_Frame:
.a24f	9c 2f 06	stz $062f			stz 	gxFillSolid
.a252	80 a6		bra $a1fa			bra 	_RGICommandLoop
.a254					_RGI_To:
.a254	20 ed a2	jsr $a2ed			jsr 	GCGetCoordinatePair 		; get coordinate pair into slot #1,#2
.a257	20 14 a3	jsr $a314			jsr 	GCCopyPairToStore
.a25a					_RGI_Here:
.a25a	5a		phy				phy
.a25b	20 0a a3	jsr $a30a			jsr 	GCLoadAXY 					; load it into AXY
.a25e	20 c4 a2	jsr $a2c4			jsr 	_RGICallHandler 			; go do whatever it is.
.a261	7a		ply				ply
.a262	80 96		bra $a1fa			bra 	_RGICommandLoop 			; and go round
.a264					_RGI_By:
.a264	20 fa a2	jsr $a2fa			jsr 	GCSignedCoordinatePair 		; get coordinate pair into slot #1,#2
.a267	18		clc				clc
.a268	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; copy it into space.
.a26b	6d 30 06	adc $0630			adc 	gxxPos
.a26e	8d 30 06	sta $0630			sta 	gxXPos
.a271	ad 11 04	lda $0411			lda 	NSMantissa1+1
.a274	6d 31 06	adc $0631			adc 	gxxPos+1
.a277	8d 31 06	sta $0631			sta 	gxXPos+1
.a27a	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a27d	18		clc				clc
.a27e	6d 32 06	adc $0632			adc 	gxYPos
.a281	8d 32 06	sta $0632			sta 	gxYPos
.a284	80 d4		bra $a25a			bra 	_RGI_Here
.a286					_RGI_Dim:
.a286	a2 01		ldx #$01			ldx	 	#1
.a288	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger
.a28b	ad 09 04	lda $0409			lda 	NSMantissa0+1
.a28e	c9 00		cmp #$00			cmp 	#0
.a290	f0 2f		beq $a2c1			beq 	_RGIRange
.a292	c9 09		cmp #$09			cmp 	#8+1
.a294	b0 2b		bcs $a2c1			bcs		_RGIRange
.a296	3a		dec a				dec 	a
.a297	8d 35 06	sta $0635			sta 	gxDrawScale
.a29a	4c fa a1	jmp $a1fa			jmp 	_RGICommandLoop
.a29d					_RGI_Colour:
.a29d	a2 01		ldx #$01			ldx 	#1 							; colour
.a29f	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger
.a2a2	a2 02		ldx #$02			ldx 	#2 							; default zero for 2nd parameter
.a2a4	20 28 9e	jsr $9e28			jsr 	NSMSetZero
.a2a7	b1 30		lda ($30),y			lda 	(codePtr),y
.a2a9	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; check , => mode.
.a2ab	d0 04		bne $a2b1			bne 	_RGICDefaultMode
.a2ad	c8		iny				iny
.a2ae	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger
.a2b1					_RGICDefaultMode:
.a2b1	5a		phy				phy
.a2b2	a9 08		lda #$08			lda 	#GCMD_Colour 				; set colour.
.a2b4	ae 09 04	ldx $0409			ldx 	NSMantissa0+1
.a2b7	ac 0a 04	ldy $040a			ldy 	NSMantissa0+2
.a2ba	20 de aa	jsr $aade			jsr 	GXGraphicDraw
.a2bd	7a		ply				ply
.a2be	4c fa a1	jmp $a1fa			jmp 	_RGICommandLoop 			; and go round
.a2c1					_RGIRange:
.a2c1	4c b7 9f	jmp $9fb7			jmp 	RangeError
.a2c4					_RGICallHandler:
.a2c4	6c 33 06	jmp ($0633)			jmp 	(GXHandler)
.a2c7					_RGI_SpriteInstructions:
.a2c7	c9 bf		cmp #$bf			cmp 	#KWD_OFF
.a2c9	f0 07		beq $a2d2			beq 	_RGISpriteOff
.a2cb	c9 bb		cmp #$bb			cmp 	#KWD_IMAGE
.a2cd	f0 13		beq $a2e2			beq 	_RGISetImage
.a2cf	4c 33 a2	jmp $a233			jmp 	_RGI_Move
.a2d2					_RGISpriteOff:
.a2d2	5a		phy				phy
.a2d3	a0 01		ldy #$01			ldy 	#1
.a2d5	a2 00		ldx #$00			ldx 	#0
.a2d7					_RGIDoCommandLoop:
.a2d7	a9 10		lda #$10			lda 	#GCMD_SpriteImage
.a2d9	20 de aa	jsr $aade			jsr 	GXGraphicDraw
.a2dc	7a		ply				ply
.a2dd	b0 e2		bcs $a2c1			bcs 	_RGIRange
.a2df	4c fa a1	jmp $a1fa			jmp 	_RGICommandLoop
.a2e2					_RGISetImage:
.a2e2	a2 01		ldx #$01			ldx 	#1
.a2e4	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger
.a2e7	5a		phy				phy
.a2e8	aa		tax				tax
.a2e9	a0 00		ldy #$00			ldy 	#0
.a2eb	80 ea		bra $a2d7			bra 	_RGIDoCommandLoop
.a2ed					GCGetCoordinatePair:
.a2ed	a2 01		ldx #$01			ldx 	#1
.a2ef	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger
.a2f2	20 54 8d	jsr $8d54			jsr 	CheckComma
.a2f5	e8		inx				inx
.a2f6	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger
.a2f9	60		rts				rts
.a2fa					GCSignedCoordinatePair:
.a2fa	a2 01		ldx #$01			ldx 	#1
.a2fc	20 95 9d	jsr $9d95			jsr 	Evaluate16BitIntegerSigned
.a2ff	20 54 8d	jsr $8d54			jsr 	CheckComma
.a302	e8		inx				inx
.a303	20 95 9d	jsr $9d95			jsr 	Evaluate16BitIntegerSigned
.a306	60		rts				rts
.a307					_GCCPRange:
.a307	4c b7 9f	jmp $9fb7			jmp 	RangeError
.a30a					GCLoadAXY:
.a30a	ad 31 06	lda $0631			lda 	gxXPos+1
.a30d	ae 30 06	ldx $0630			ldx 	gxXPos
.a310	ac 32 06	ldy $0632			ldy 	gxYPos
.a313	60		rts				rts
.a314					GCCopyPairToStore:
.a314	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; copy it into space.
.a317	8d 30 06	sta $0630			sta 	gxXPos
.a31a	ad 11 04	lda $0411			lda 	NSMantissa1+1
.a31d	8d 31 06	sta $0631			sta 	gxXPos+1
.a320	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a323	8d 32 06	sta $0632			sta 	gxYPos
.a326	60		rts				rts
.062e					gxCommandID:
>062e							.fill 	1
.062f					gxFillSolid:
>062f							.fill 	1
.0630					gxXPos:
>0630							.fill 	2
.0632					gxYPos:
>0632							.fill 	1
.0633					gxHandler:
>0633							.fill 	2
.0635					gxDrawScale:
>0635							.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcontrol.asm

.a327					BitmapCtrl:
.a327	b1 30		lda ($30),y			lda 	(codePtr),y
.a329	c8		iny				iny
.a32a	a2 01		ldx #$01			ldx 	#1
.a32c	c9 c0		cmp #$c0			cmp 	#KWD_ON
.a32e	f0 11		beq $a341			beq 	BitmapSwitch
.a330	ca		dex				dex
.a331	c9 bf		cmp #$bf			cmp 	#KWD_OFF
.a333	f0 0c		beq $a341			beq 	BitmapSwitch
.a335	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; get the colour
.a338	5a		phy				phy
.a339	aa		tax				tax
.a33a	a9 06		lda #$06			lda 	#GCMD_Clear					; clear to that colour
.a33c	20 de aa	jsr $aade			jsr 	GXGraphicDraw
.a33f	7a		ply				ply
.a340	60		rts				rts
.a341					BitmapSwitch:
.a341	5a		phy				phy
.a342	a0 00		ldy #$00			ldy 	#0 							; gfx 1,on/off,0
.a344	a9 02		lda #$02			lda 	#GCMD_BitmapCtl
.a346	20 de aa	jsr $aade			jsr 	GXGraphicDraw
.a349	a9 08		lda #$08			lda 	#GCMD_Colour				; set colour to $FF
.a34b	a0 00		ldy #$00			ldy 	#0
.a34d	a2 ff		ldx #$ff			ldx 	#$FF
.a34f	20 de aa	jsr $aade			jsr 	GXGraphicDraw
.a352	9c 2f 06	stz $062f			stz 	gxFillSolid
.a355	9c 30 06	stz $0630			stz 	gxXPos
.a358	9c 31 06	stz $0631			stz 	gxXPos+1
.a35b	9c 32 06	stz $0632			stz 	gxYPos
.a35e	9c 35 06	stz $0635			stz 	gxDrawScale
.a361	a9 40		lda #$40			lda 	#GCMD_Move 						; home cursor
.a363	a2 00		ldx #$00			ldx 	#0
.a365	a0 00		ldy #$00			ldy 	#0
.a367	20 de aa	jsr $aade			jsr 	GXGraphicDraw
.a36a	7a		ply				ply
.a36b	60		rts				rts
.a36c					SpritesCtrl:
.a36c	b1 30		lda ($30),y			lda 	(codePtr),y
.a36e	c8		iny				iny
.a36f	a2 01		ldx #$01			ldx 	#1
.a371	c9 c0		cmp #$c0			cmp 	#KWD_ON
.a373	f0 08		beq $a37d			beq 	SpriteSwitch
.a375	ca		dex				dex
.a376	c9 bf		cmp #$bf			cmp 	#KWD_OFF
.a378	f0 03		beq $a37d			beq 	SpriteSwitch
.a37a	4c b2 9f	jmp $9fb2			jmp 	SyntaxError
.a37d					SpriteSwitch:
.a37d	5a		phy				phy
.a37e	a0 00		ldy #$00			ldy 	#0 							; gfx 2,on/off,0
.a380	a9 04		lda #$04			lda 	#GCMD_SpriteCtl
.a382	20 de aa	jsr $aade			jsr 	GXGraphicDraw
.a385	7a		ply				ply
.a386	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gfx.asm

.a387					GfxCommand:
.a387	a2 00		ldx #$00			ldx 	#0
.a389	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; command
.a38c	20 54 8d	jsr $8d54			jsr 	CheckComma
.a38f	e8		inx				inx
.a390	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger 		; X
.a393	20 54 8d	jsr $8d54			jsr 	CheckComma
.a396	e8		inx				inx
.a397	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; Y
.a39a	ad 11 04	lda $0411			lda 	NSMantissa1+1  				; shift bit 0 of X into CS, should now be zero
.a39d	4a		lsr a				lsr 	a
.a39e	d0 16		bne $a3b6			bne 	_GfxError
.a3a0	2e 08 04	rol $0408			rol 	NSMantissa0 				; rotate into command
.a3a3	b0 11		bcs $a3b6			bcs 	_GfxError 					; bit 7 should have been zero
.a3a5	5a		phy				phy 								; save pos
.a3a6	ad 08 04	lda $0408			lda 	NSMantissa0 				; do the command
.a3a9	ae 09 04	ldx $0409			ldx 	NSMantissa0+1
.a3ac	ac 0a 04	ldy $040a			ldy 	NSMantissa0+2
.a3af	20 de aa	jsr $aade			jsr 	GXGraphicDraw
.a3b2	b0 02		bcs $a3b6			bcs 	_GfxError
.a3b4	7a		ply				ply 								; restore pos and exit.
.a3b5	60		rts				rts
.a3b6					_GfxError:
.a3b6	4c b7 9f	jmp $9fb7			jmp 	RangeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/hit.asm

.a3b9					UnaryHit:
.a3b9	fa		plx				plx
.a3ba	a9 36		lda #$36			lda 	#zTemp0
.a3bc	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; get sprite number 0
.a3bf	20 54 8d	jsr $8d54			jsr 	CheckComma
.a3c2	e8		inx				inx
.a3c3	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; get sprite number 1
.a3c6	20 4c 8d	jsr $8d4c			jsr		CheckRightBracket
.a3c9	ca		dex				dex 								; fix back up again.
.a3ca	da		phx				phx 								; save X/Y
.a3cb	5a		phy				phy
.a3cc	bc 09 04	ldy $0409,x			ldy 	NSMantissa0+1,x 			; get the sprite numbers into X/Y
.a3cf	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a3d2	aa		tax				tax
.a3d3	a9 12		lda #$12			lda 	#GCMD_SpriteCollide 		; command check collision.
.a3d5	20 de aa	jsr $aade			jsr 	GXGraphicDraw 				; calculate result
.a3d8	1a		inc a				inc 	a 							; so 255 (fail) -> 0, otherwise 1,2,3,4 pixels etc.
.a3d9	7a		ply				ply 								; restore XY
.a3da	fa		plx				plx
.a3db	20 2a 9e	jsr $9e2a			jsr 	NSMSetByte 					; return the hit result
.a3de	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/palette.asm

.a3df					PaletteCommand:
.a3df	a2 00		ldx #$00			ldx 	#0
.a3e1	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; colour
.a3e4	20 54 8d	jsr $8d54			jsr 	CheckComma
.a3e7	e8		inx				inx
.a3e8	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger 		; r
.a3eb	20 54 8d	jsr $8d54			jsr 	CheckComma
.a3ee	e8		inx				inx
.a3ef	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; g
.a3f2	20 54 8d	jsr $8d54			jsr 	CheckComma
.a3f5	e8		inx				inx
.a3f6	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; b
.a3f9	ad 08 04	lda $0408			lda 	NSMantissa0 				; get colour #
.a3fc	85 36		sta $36				sta 	zTemp0
.a3fe	a9 34		lda #$34			lda 	#$D0 >> 2 					; MSB = D0/4
.a400	85 37		sta $37				sta 	zTemp0+1
.a402	06 36		asl $36				asl 	zTemp0 						; zTemp = $D000+Colour x 4
.a404	26 37		rol $37				rol	 	zTemp0+1
.a406	06 36		asl $36				asl 	zTemp0
.a408	26 37		rol $37				rol	 	zTemp0+1
.a40a	a9 01		lda #$01			lda 	#1 							; I/O Page 2
.a40c	85 01		sta $01				sta 	1
.a40e	5a		phy				phy
.a40f	ad 0b 04	lda $040b			lda 	NSMantissa0+3 				; fix to r,g,b
.a412	92 36		sta ($36)			sta 	(zTemp0)
.a414	a0 01		ldy #$01			ldy 	#1
.a416	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a419	91 36		sta ($36),y			sta 	(zTemp0),y
.a41b	ad 09 04	lda $0409			lda 	NSMantissa0+1
.a41e	c8		iny				iny
.a41f	91 36		sta ($36),y			sta 	(zTemp0),y
.a421	7a		ply				ply
.a422	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/event.asm

.a423					UnaryEvent:
.a423	fa		plx				plx
.a424	20 cb a4	jsr $a4cb			jsr 	TimerToStackX 				; timer in +0
.a427	e8		inx				inx  								; put reference into +1
.a428	20 ee 97	jsr $97ee			jsr 	EvaluateTerm
.a42b	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if is integer reference
.a42e	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.a430	d0 57		bne $a489			bne 	_UEType
.a432	e8		inx				inx 								; put the step in +2
.a433	20 54 8d	jsr $8d54			jsr 	CheckComma
.a436	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger
.a439	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.a43c	ca		dex				dex
.a43d	ca		dex				dex
.a43e	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; copy reference to zTemp0
.a441	85 36		sta $36				sta 	zTemp0
.a443	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.a446	85 37		sta $37				sta 	zTemp0+1
.a448	5a		phy				phy
.a449	a0 03		ldy #$03			ldy 	#3 							; check bit 7 of last bit, the packed sign bit
.a44b	b1 36		lda ($36),y			lda 	(zTemp0),y
.a44d	30 36		bmi $a485			bmi 	_UEFalse 					; exit if signed.
.a44f	a0 00		ldy #$00			ldy 	#0 							; has it timed out (24 bit)
.a451	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a454	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.a456	c8		iny				iny
.a457	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a45a	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a45c	c8		iny				iny
.a45d	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.a460	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a462	90 21		bcc $a485			bcc 	_UEFalse 					; no, return FALSE.
.a464	18		clc				clc
.a465	a0 00		ldy #$00			ldy 	#0 							; work out new value as timer() + step
.a467	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a46a	7d 0a 04	adc $040a,x			adc 	NSMantissa0+2,x
.a46d	91 36		sta ($36),y			sta 	(zTemp0),y
.a46f	c8		iny				iny
.a470	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a473	7d 12 04	adc $0412,x			adc 	NSMantissa1+2,x
.a476	91 36		sta ($36),y			sta 	(zTemp0),y
.a478	c8		iny				iny
.a479	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.a47c	7d 1a 04	adc $041a,x			adc 	NSMantissa2+2,x
.a47f	91 36		sta ($36),y			sta 	(zTemp0),y
.a481	7a		ply				ply
.a482	4c d2 8d	jmp $8dd2			jmp 	ReturnTrue
.a485					_UEFalse:
.a485	7a		ply				ply 								; restore Y
.a486	4c de 8d	jmp $8dde			jmp 	ReturnFalse 				; and return False
.a489					_UEType:
.a489	4c bc 9f	jmp $9fbc			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/joy.asm

.a48c					UnaryJoyX:
.a48c	18		clc				clc
.a48d	80 01		bra $a490			bra 	JoyMain
.a48f					UnaryJoyY:
.a48f	38		sec				sec
.a490					JoyMain:
.a490	fa		plx				plx 								; get pos
.a491	08		php				php 								; save carry (set for Y)
.a492	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a495	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.a498	20 97 aa	jsr $aa97			jsr 	EXTReadController 			; read the controller.
.a49b	28		plp				plp
.a49c	90 02		bcc $a4a0			bcc 	_JMNoShift 					; if Y then shift bits 3,2 -> 1,0
.a49e	4a		lsr a				lsr 	a
.a49f	4a		lsr a				lsr 	a
.a4a0					_JMNoShift:
.a4a0	4a		lsr a				lsr 	a 							; if bit 0 set then right/down e.g. +1
.a4a1	b0 0a		bcs $a4ad			bcs 	_JMIsRight
.a4a3	4a		lsr a				lsr 	a 							; if bit 1 set then left/up e.g. -1
.a4a4	b0 04		bcs $a4aa			bcs 	_JMIsLeft
.a4a6	20 28 9e	jsr $9e28			jsr 	NSMSetZero 					; zero result
.a4a9	60		rts				rts
.a4aa					_JMIsLeft:
.a4aa	4c d2 8d	jmp $8dd2			jmp 	ReturnTrue
.a4ad					_JMIsRight:
.a4ad	a9 01		lda #$01			lda 	#1
.a4af	20 2a 9e	jsr $9e2a			jsr 	NSMSetByte
.a4b2	60		rts				rts
.a4b3					UnaryJoyB:
.a4b3	fa		plx				plx 								; get pos
.a4b4	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a4b7	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.a4ba	20 97 aa	jsr $aa97			jsr 	EXTReadController 			; read the controller.
.a4bd	4a		lsr a				lsr 	a
.a4be	4a		lsr a				lsr 	a
.a4bf	4a		lsr a				lsr 	a
.a4c0	4a		lsr a				lsr 	a
.a4c1	29 01		and #$01			and 	#1
.a4c3	20 2a 9e	jsr $9e2a			jsr 	NSMSetByte
.a4c6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/timer.asm

.a4c7					UnaryTimer:
.a4c7	fa		plx				plx
.a4c8	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.a4cb					TimerToStackX:
.a4cb	20 28 9e	jsr $9e28			jsr 	NSMSetZero 					; zero result
.a4ce	64 01		stz $01				stz 	1 							; access I/O
.a4d0	ad 59 d6	lda $d659			lda 	$D659 						; copy timer in
.a4d3	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.a4d6	ad 5a d6	lda $d65a			lda 	$D65A
.a4d9	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a4dc	ad 5b d6	lda $d65b			lda 	$D65B
.a4df	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.a4e2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/delete.asm

.a4e3					MemoryDeleteLine:
.a4e3	20 02 a5	jsr $a502			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a4e6	b2 30		lda ($30)			lda 	(codePtr) 					; size to delete => y
.a4e8	a8		tay				tay
.a4e9					_MDDLLoop:
.a4e9	b1 30		lda ($30),y			lda 	(codePtr),y 				; copy down
.a4eb	92 30		sta ($30)			sta 	(codePtr)
.a4ed	a5 30		lda $30				lda 	codePtr 					; check done the lot.
.a4ef	c5 3a		cmp $3a				cmp 	zTemp2
.a4f1	d0 07		bne $a4fa			bne 	_MDLDLNext
.a4f3	a5 31		lda $31				lda 	codePtr+1
.a4f5	c5 3b		cmp $3b				cmp 	zTemp2+1
.a4f7	d0 01		bne $a4fa			bne 	_MDLDLNext
.a4f9					_MDDLExit:
.a4f9	60		rts				rts
.a4fa					_MDLDLNext:
.a4fa	e6 30		inc $30				inc 	codePtr						; next byte
.a4fc	d0 eb		bne $a4e9			bne 	_MDDLLoop
.a4fe	e6 31		inc $31				inc 	codePtr+1
.a500	80 e7		bra $a4e9			bra 	_MDDLLoop
.a502					IMemoryFindEnd:
.a502	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a504	85 3a		sta $3a				sta 	0+zTemp2
.a506	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a508	85 3b		sta $3b				sta 	1+zTemp2
.a50a					_MDLFELoop:
.a50a	b2 3a		lda ($3a)			lda 	(zTemp2)
.a50c	f0 0b		beq $a519			beq 	_MDLFEExit
.a50e	18		clc				clc
.a50f	65 3a		adc $3a				adc 	zTemp2
.a511	85 3a		sta $3a				sta 	zTemp2
.a513	90 f5		bcc $a50a			bcc 	_MDLFELoop
.a515	e6 3b		inc $3b				inc 	zTemp2+1
.a517	80 f1		bra $a50a			bra 	_MDLFELoop
.a519					_MDLFEExit:
.a519	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/insert.asm

.a51a					MemoryInsertLine:
.a51a	08		php				php
.a51b	20 02 a5	jsr $a502			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a51e	a5 3b		lda $3b				lda 	zTemp2+1 					; space ?
.a520	1a		inc a				inc 	a
.a521	c9 7f		cmp #$7f			cmp 	#(BasicEnd >> 8)-1
.a523	b0 36		bcs $a55b			bcs 	_MDLIError
.a525	28		plp				plp
.a526	90 08		bcc $a530			bcc 	_MDLIFound
.a528	a5 3a		lda $3a				lda 	zTemp2 						; if CS on entry append.
.a52a	85 30		sta $30				sta 	codePtr
.a52c	a5 3b		lda $3b				lda 	zTemp2+1
.a52e	85 31		sta $31				sta 	codePtr+1
.a530					_MDLIFound:
.a530	ad a8 04	lda $04a8			lda 	tokenOffset 				; insert gap in Y, the offset, e.g. length of the new line
.a533	a8		tay				tay
.a534					_MDLIInsert:
.a534	b2 3a		lda ($3a)			lda 	(zTemp2) 					; shift one byte up , at least one covers end case.
.a536	91 3a		sta ($3a),y			sta 	(zTemp2),y 					; work from top down.
.a538	a5 30		lda $30				lda 	codePtr 					; done insert point ?
.a53a	c5 3a		cmp $3a				cmp 	zTemp2
.a53c	d0 06		bne $a544			bne 	_MDLINext
.a53e	a5 31		lda $31				lda 	codePtr+1
.a540	c5 3b		cmp $3b				cmp 	zTemp2+1
.a542	f0 0a		beq $a54e			beq 	_MDLIHaveSpace
.a544					_MDLINext:
.a544	a5 3a		lda $3a				lda 	zTemp2 						; if no, keep zTemp2 going backwards
.a546	d0 02		bne $a54a			bne 	_MDLINoBorrow
.a548	c6 3b		dec $3b				dec 	zTemp2+1
.a54a					_MDLINoBorrow:
.a54a	c6 3a		dec $3a				dec 	zTemp2
.a54c	80 e6		bra $a534			bra 	_MDLIInsert
.a54e					_MDLIHaveSpace:
.a54e	ac a8 04	ldy $04a8			ldy 	tokenOffset 				; bytes to copy
.a551	88		dey				dey 								; from offset-1 to 0
.a552					_MDLICopy:
.a552	b9 a8 04	lda $04a8,y			lda 	tokenOffset,y
.a555	91 30		sta ($30),y			sta 	(codePtr),y
.a557	88		dey				dey
.a558	10 f8		bpl $a552			bpl 	_MDLICopy
.a55a	60		rts				rts
.a55b					_MDLIError:
.a55b	a9 06		lda #$06		lda	#6
.a55d	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.a560					MDLAppendLine:
.a560	86 37		stx $37				stx 	zTemp0+1 					; save new line at zTemp0
.a562	85 36		sta $36				sta 	zTemp0
.a564	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a566	85 38		sta $38				sta 	0+zTemp1
.a568	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a56a	85 39		sta $39				sta 	1+zTemp1
.a56c	b2 38		lda ($38)			lda 	(zTemp1)
.a56e	d0 0a		bne $a57a			bne 	_MDLANoInitialise
.a570	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a572	8d 36 06	sta $0636			sta 	0+AppendPointer
.a575	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a577	8d 37 06	sta $0637			sta 	1+AppendPointer
.a57a					_MDLANoInitialise:
.a57a	18		clc				clc
.a57b	ad 36 06	lda $0636			lda 	AppendPointer 				; copy append pointer to zTemp1 adding the offset as you go
.a57e	85 38		sta $38				sta 	zTemp1
.a580	72 36		adc ($36)			adc 	(zTemp0)
.a582	8d 36 06	sta $0636			sta 	AppendPointer
.a585	ad 37 06	lda $0637			lda 	AppendPointer+1
.a588	85 39		sta $39				sta 	zTemp1+1
.a58a	69 00		adc #$00			adc 	#0
.a58c	8d 37 06	sta $0637			sta 	AppendPointer+1
.a58f	a0 00		ldy #$00			ldy 	#0
.a591					_MDLACopy:
.a591	b1 36		lda ($36),y			lda 	(zTemp0),y 					; copy new line in
.a593	91 38		sta ($38),y			sta 	(zTemp1),y
.a595	c8		iny				iny
.a596	98		tya				tya
.a597	d2 36		cmp ($36)			cmp 	(zTemp0) 					; done whole line
.a599	d0 f6		bne $a591			bne 	_MDLACopy
.a59b	a9 00		lda #$00			lda 	#0 							; end of program.
.a59d	91 38		sta ($38),y			sta 	(zTemp1),y
.a59f	60		rts				rts
.0636					AppendPointer:
>0636							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/memory.asm

.a5a0					MemoryNew:
.a5a0	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a5a2	85 30		sta $30				sta 	codePtr
.a5a4	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a5a6	85 31		sta $31				sta 	codePtr+1
.a5a8	a9 00		lda #$00			lda 	#0 							; write zero there erasing the program.
.a5aa	92 30		sta ($30)			sta 	(codePtr)
.a5ac	60		rts				rts
.a5ad					MemoryInline:
.a5ad	98		tya				tya 								; put address into stack,x
.a5ae	18		clc				clc
.a5af	65 30		adc $30				adc 	codePtr
.a5b1	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.a5b4	a5 31		lda $31				lda 	codePtr+1
.a5b6	69 00		adc #$00			adc 	#0
.a5b8	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a5bb	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.a5be	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.a5c1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/search.asm

.a5c2					MemorySearch:
.a5c2	85 36		sta $36				sta 	zTemp0 						; save line number zTemp0
.a5c4	86 37		stx $37				stx 	zTemp0+1
.a5c6	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a5c8	85 30		sta $30				sta 	codePtr
.a5ca	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a5cc	85 31		sta $31				sta 	codePtr+1
.a5ce					_MTAXLoop:
.a5ce	b2 30		lda ($30)			lda 	(codePtr)
.a5d0	18		clc				clc
.a5d1	f0 21		beq $a5f4			beq 	_MTAXExit 					; reached end, exit with CC.
.a5d3	a0 01		ldy #$01			ldy 	#1 							; calculate current line# - requested line#
.a5d5	b1 30		lda ($30),y			lda 	(codePtr),y
.a5d7	38		sec				sec
.a5d8	e5 36		sbc $36				sbc 	zTemp0
.a5da	85 38		sta $38				sta 	zTemp1 						; save interim to set Z
.a5dc	c8		iny				iny 								; do the MSB
.a5dd	b1 30		lda ($30),y			lda 	(codePtr),y
.a5df	e5 37		sbc $37				sbc 	zTemp0+1
.a5e1	05 38		ora $38				ora 	zTemp1
.a5e3	f0 0f		beq $a5f4			beq 	_MTAXExit	 				; found
.a5e5	b0 0d		bcs $a5f4			bcs 	_MTAXExit 					; current < required exit
.a5e7	18		clc				clc
.a5e8	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.a5ea	65 30		adc $30				adc 	codePtr
.a5ec	85 30		sta $30				sta 	codePtr
.a5ee	90 02		bcc $a5f2			bcc 	_CREExit
.a5f0	e6 31		inc $31				inc 	codePtr+1
.a5f2					_CREExit:
.a5f2	80 da		bra $a5ce			bra 	_MTAXLoop
.a5f4					_MTAXExit:
.a5f4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/playing.asm

.a5f5					UnaryPlaying:
.a5f5	fa		plx				plx
.a5f6	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; get channel #
.a5f9	48		pha				pha
.a5fa	20 4c 8d	jsr $8d4c			jsr		CheckRightBracket
.a5fd	68		pla				pla
.a5fe	c9 04		cmp #$04			cmp 	#4
.a600	b0 0c		bcs $a60e			bcs 	_UPNotPlaying
.a602	09 20		ora #$20			ora 	#$20 						; query playing ?
.a604	20 6c b9	jsr $b96c			jsr 	SNDCommand
.a607	c9 00		cmp #$00			cmp 	#0
.a609	f0 03		beq $a60e			beq 	_UPNotPlaying
.a60b	4c d2 8d	jmp $8dd2			jmp 	ReturnTrue
.a60e					_UPNotPlaying:
.a60e	4c de 8d	jmp $8dde			jmp 	ReturnFalse

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/sound.asm

.a611					SoundCommand:
.a611	b1 30		lda ($30),y			lda 	(codePtr),y
.a613	c9 bf		cmp #$bf			cmp 	#KWD_OFF 					; SOUND OFF ?
.a615	d0 09		bne $a620			bne 	_SNDMain
.a617	c8		iny				iny 								; skip OFF
.a618	a9 3f		lda #$3f			lda 	#$3F 						; call command $3F (silence)
.a61a	5a		phy				phy
.a61b	20 6c b9	jsr $b96c			jsr 	SNDCommand
.a61e	7a		ply				ply
.a61f	60		rts				rts
.a620					_SNDMain:
.a620	a2 00		ldx #$00			ldx 	#0
.a622	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; channel
.a625	c9 04		cmp #$04			cmp 	#4 							; must be 0-3
.a627	b0 50		bcs $a679			bcs 	_SndError
.a629	e8		inx				inx 								; do the rest in slot 1.
.a62a	20 54 8d	jsr $8d54			jsr 	CheckComma
.a62d	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger 		; Pitch
.a630	bd 10 04	lda $0410,x			lda 	NSMantissa1,x 				; must be 10 bit
.a633	c9 10		cmp #$10			cmp 	#16
.a635	b0 42		bcs $a679			bcs 	_SndError
.a637	8d 39 06	sta $0639			sta 	SoundCommandBlock+1 		; Pitch (2 bytes + 0)
.a63a	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a63d	8d 38 06	sta $0638			sta 	SoundCommandBlock
.a640	20 54 8d	jsr $8d54			jsr 	CheckComma
.a643	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; Length (1 byte + 3)
.a646	8d 3b 06	sta $063b			sta 	SoundCommandBlock+3
.a649	a9 0f		lda #$0f			lda 	#15
.a64b	8d 3a 06	sta $063a			sta 	SoundCommandBlock+2 		; Volume (1 byte + 2)
.a64e	9c 3c 06	stz $063c			stz 	SoundCommandBlock+4 		; default slide (2 bytes +4)
.a651	9c 3d 06	stz $063d			stz 	SoundCommandBlock+5
.a654	b1 30		lda ($30),y			lda 	(codePtr),y
.a656	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.a658	d0 10		bne $a66a			bne 	_SNDPlay
.a65a	c8		iny				iny
.a65b	20 95 9d	jsr $9d95			jsr 	Evaluate16BitIntegerSigned 	; Slide
.a65e	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; Slide (2 bytes + 4)
.a661	8d 3c 06	sta $063c			sta 	SoundCommandBlock+4
.a664	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a667	8d 3d 06	sta $063d			sta 	SoundCommandBlock+5
.a66a					_SNDPlay:
.a66a	5a		phy				phy
.a66b	ad 08 04	lda $0408			lda 	NSMantissa0 				; channel.
.a66e	09 10		ora #$10			ora 	#$10 						; 1x = Queue sound
.a670	a2 38		ldx #$38			ldx 	#(SoundCommandBlock & $FF)
.a672	a0 06		ldy #$06			ldy 	#(SoundCommandBlock >> 8)
.a674	20 6c b9	jsr $b96c			jsr 	SNDCommand
.a677	7a		ply				ply
.a678	60		rts				rts
.a679					_SndError:
.a679	4c b7 9f	jmp $9fb7			jmp 	RangeError
.0638					SoundCommandBlock:
>0638							.fill 	6

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/bytes.asm

.a67c					StackPushByte:
.a67c	48		pha				pha 								; save byte
.a67d	a5 34		lda $34				lda 	BasicStack
.a67f	d0 09		bne $a68a			bne 	_SPBNoBorrow
.a681	c6 35		dec $35				dec 	BasicStack+1
.a683	48		pha				pha
.a684	a5 35		lda $35				lda 	BasicStack+1
.a686	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a688	90 06		bcc $a690			bcc 	_SPBMemory
.a68a					_SPBNoBorrow:
.a68a	c6 34		dec $34				dec 	BasicStack
.a68c	68		pla				pla 								; get back and write
.a68d	92 34		sta ($34)			sta 	(BasicStack)
.a68f	60		rts				rts
.a690					_SPBMemory:
.a690	a9 12		lda #$12		lda	#18
.a692	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.a695					StackPopByte:
.a695	b2 34		lda ($34)			lda 	(BasicStack)
.a697	e6 34		inc $34				inc 	BasicStack
.a699	d0 02		bne $a69d			bne 	_SPBNoCarry
.a69b	e6 35		inc $35				inc 	BasicStack+1
.a69d					_SPBNoCarry:
.a69d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/frames.asm

.a69e					StackOpen:
.a69e	48		pha				pha 								; save frame byte
.a69f	29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.a6a1	0a		asl a				asl 	a 							; claim twice this for storage
.a6a2	49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.a6a4	38		sec				sec 								; so basically subtracting from
.a6a5	65 34		adc $34				adc 	basicStack 	 				; basicStack
.a6a7	85 34		sta $34				sta 	basicStack
.a6a9	b0 08		bcs $a6b3			bcs 	_SONoBorrow
.a6ab	c6 35		dec $35				dec 	basicStack+1
.a6ad	a5 35		lda $35				lda 	basicStack+1 				; have we reached stack overflow
.a6af	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a6b1	90 04		bcc $a6b7			bcc 	_SOMemory
.a6b3					_SONoBorrow:
.a6b3	68		pla				pla 								; get marker back and write at TOS
.a6b4	92 34		sta ($34)			sta 	(basicStack)
.a6b6	60		rts				rts
.a6b7					_SOMemory:
.a6b7	a9 12		lda #$12		lda	#18
.a6b9	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.a6bc					StackClose:
.a6bc	b2 34		lda ($34)			lda 	(basicStack) 				; get TOS marker
.a6be	29 0f		and #$0f			and 	#$0F 						; bytes to add back
.a6c0	0a		asl a				asl 	a 							; claim twice this.
.a6c1	65 34		adc $34				adc 	basicStack 					; add to the stack pointer.
.a6c3	85 34		sta $34				sta 	basicStack
.a6c5	90 02		bcc $a6c9			bcc 	_SCExit
.a6c7	e6 35		inc $35				inc 	basicStack+1
.a6c9					_SCExit:
.a6c9	60		rts				rts
.a6ca					StackCheckFrame:
.a6ca	48		pha				pha
.a6cb					_StackRemoveLocals:
.a6cb	b2 34		lda ($34)			lda 	(basicStack) 				; check for local, keep popping them
.a6cd	c9 03		cmp #$03			cmp 	#STK_LOCALS+1
.a6cf	b0 05		bcs $a6d6			bcs 	_SCNoLocal
.a6d1	20 fe 87	jsr $87fe			jsr 	LocalPopValue
.a6d4	80 f5		bra $a6cb			bra 	_StackRemoveLocals
.a6d6					_SCNoLocal:
.a6d6	68		pla				pla
.a6d7	52 34		eor ($34)			eor 	(basicStack) 				; xor with toS marker
.a6d9	29 f0		and #$f0			and 	#$F0 						; check type bits
.a6db	d0 01		bne $a6de			bne 	_SCFError 					; different, we have structures mixed up
.a6dd	60		rts				rts
.a6de					_SCFError:
.a6de	8a		txa				txa 								; report error X
.a6df	4c 65 8d	jmp $8d65			jmp 	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/location.asm

.a6e2					STKSaveCodePosition:
.a6e2	5a		phy				phy
.a6e3	98		tya				tya 								; save Y
.a6e4	a0 05		ldy #$05			ldy 	#5
.a6e6	91 34		sta ($34),y			sta 	(basicStack),y
.a6e8	88		dey				dey 								; save Code Pointer
.a6e9					_STKSaveLoop:
.a6e9	b9 2f 00	lda $002f,y			lda 	safePtr-1,y 				; allows us to access the pointer w/out issues.
.a6ec	91 34		sta ($34),y			sta 	(basicStack),y
.a6ee	88		dey				dey
.a6ef	d0 f8		bne $a6e9			bne 	_STKSaveLoop
.a6f1	7a		ply				ply
.a6f2	60		rts				rts
.a6f3					STKLoadCodePosition:
.a6f3	a0 01		ldy #$01			ldy 	#1 							; load code pointer back
.a6f5					_STKLoadLoop:
.a6f5	b1 34		lda ($34),y			lda 	(basicStack),y
.a6f7	99 2f 00	sta $002f,y			sta 	safePtr-1,y
.a6fa	c8		iny				iny
.a6fb	c0 05		cpy #$05			cpy 	#5
.a6fd	d0 f6		bne $a6f5			bne 	_STKLoadLoop
.a6ff	b1 34		lda ($34),y			lda 	(basicStack),y 				; get Y offset
.a701	a8		tay				tay
.a702	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/setup.asm

.a703					StackReset:
.a703	a9 ff		lda #$ff			lda 	#((BasicStackBase+BasicStackSize-1) & $FF)
.a705	85 34		sta $34				sta 	0+basicStack
.a707	a9 0f		lda #$0f			lda 	#((BasicStackBase+BasicStackSize-1) >> 8)
.a709	85 35		sta $35				sta 	1+basicStack
.a70b	a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.a70d	92 34		sta ($34)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.a70f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/concrete.asm

.a710					StringConcrete:
.a710	5a		phy				phy 								; save position on stack
.a711	20 f1 99	jsr $99f1			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a714	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy target string to zTemp1
.a717	85 38		sta $38				sta 	zTemp1
.a719	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a71c	85 39		sta $39				sta 	zTemp1+1
.a71e	a0 ff		ldy #$ff			ldy 	#$FF	 					; calculate string length
.a720					_SALength:
.a720	c8		iny				iny
.a721	b1 38		lda ($38),y			lda 	(zTemp1),y
.a723	d0 fb		bne $a720			bne 	_SALength
.a725	c0 fd		cpy #$fd			cpy 	#253 						; string too long
.a727	b0 3f		bcs $a768			bcs 	_SALengthError
.a729	98		tya				tya 				 				; length of the new string
.a72a	18		clc				clc
.a72b	69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.a72d	90 02		bcc $a731			bcc 	_SAHaveLength
.a72f	a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.a731					_SAHaveLength:
.a731	48		pha				pha 								; save length.
.a732	38		sec				sec
.a733	49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.a735	6d 8e 04	adc $048e			adc 	StringMemory
.a738	8d 8e 04	sta $048e			sta 	StringMemory
.a73b	85 3a		sta $3a				sta 	zTemp2 						; update storage address
.a73d	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; update mantissa address
.a740	a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.a742	6d 8f 04	adc $048f			adc 	StringMemory+1
.a745	8d 8f 04	sta $048f			sta 	StringMemory+1
.a748	85 3b		sta $3b				sta 	zTemp2+1
.a74a	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a74d	68		pla				pla 								; save length-3 (chars allowed) in first byte
.a74e	38		sec				sec
.a74f	e9 03		sbc #$03			sbc 	#3
.a751	92 3a		sta ($3a)			sta 	(zTemp2)
.a753	a9 00		lda #$00			lda 	#0 							; clear the status byte.
.a755	a0 01		ldy #$01			ldy 	#1
.a757	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a759					_SACopyNewString:
.a759	a0 00		ldy #$00			ldy 	#0
.a75b					_SACopyNSLoop:
.a75b	b1 38		lda ($38),y			lda 	(zTemp1),y 					; get character
.a75d	c8		iny				iny 								; write two on in string storage
.a75e	c8		iny				iny
.a75f	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a761	88		dey				dey 								; this makes it one one.
.a762	c9 00		cmp #$00			cmp 	#0 							; until EOS copied
.a764	d0 f5		bne $a75b			bne 	_SACopyNSLoop
.a766	7a		ply				ply
.a767	60		rts				rts
.a768					_SALengthError:
.a768	a9 09		lda #$09		lda	#9
.a76a	4c 65 8d	jmp $8d65		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/stringalloc.asm

.a76d					StringSystemInitialise:
.a76d	a9 ff		lda #$ff			lda 	#((EndVariableSpace-1) & $FF)
.a76f	8d 8e 04	sta $048e			sta 	0+StringMemory
.a772	a9 1f		lda #$1f			lda 	#((EndVariableSpace-1) >> 8)
.a774	8d 8f 04	sta $048f			sta 	1+StringMemory
.a777	9c ff 1f	stz $1fff			stz 	EndVariableSpace-1 			; put a zero at the end, so know end of string memory.
.a77a	60		rts				rts
.a77b					StringSpaceInitialise:
.a77b	20 f1 99	jsr $99f1			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a77e	a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.a780	8d 90 04	sta $0490			sta 	StringInitialised
.a783	ad 8e 04	lda $048e			lda 	StringMemory 				; allocate 256 bytes for one concreted string
.a786	8d 91 04	sta $0491			sta 	StringTempPointer
.a789	ad 8f 04	lda $048f			lda 	StringMemory+1
.a78c	3a		dec a				dec 	a
.a78d	8d 92 04	sta $0492			sta 	StringTempPointer+1
.a790	60		rts				rts
.a791					StringTempAllocate:
.a791	c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.a793	b0 35		bcs $a7ca			bcs 	_STALength
.a795	2c 90 04	bit $0490			bit 	StringInitialised 			; already initialised
.a798	30 05		bmi $a79f			bmi 	_STAAllocate
.a79a	48		pha				pha 								; save value to subtract.
.a79b	20 7b a7	jsr $a77b			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.a79e	68		pla				pla 								; restore it
.a79f					_STAAllocate:
.a79f	49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.a7a1	18		clc				clc  								; deliberate allows one more
.a7a2	6d 91 04	adc $0491			adc 	StringTempPointer 			; subtract from temp pointer
.a7a5	8d 91 04	sta $0491			sta 	StringTempPointer
.a7a8	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; address in mantissa
.a7ab	85 3c		sta $3c				sta 	zsTemp 						; and zsTemp
.a7ad	ad 92 04	lda $0492			lda 	StringTempPointer+1
.a7b0	69 ff		adc #$ff			adc 	#$FF
.a7b2	8d 92 04	sta $0492			sta 	StringTempPointer+1
.a7b5	85 3d		sta $3d				sta 	zsTemp+1
.a7b7	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a7ba	9e 18 04	stz $0418,x			stz 	NSMantissa2,x 				; set the typing data
.a7bd	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.a7c0	a9 10		lda #$10			lda 	#NSTString
.a7c2	9d 00 04	sta $0400,x			sta 	NSStatus,x
.a7c5	a9 00		lda #$00			lda 	#0 							; clear the target string
.a7c7	92 3c		sta ($3c)			sta 	(zsTemp)
.a7c9	60		rts				rts
.a7ca					_STALength:
.a7ca	a9 09		lda #$09		lda	#9
.a7cc	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.a7cf					StringTempWrite:
.a7cf	48		pha				pha
.a7d0	92 3c		sta ($3c)			sta 	(zsTemp)
.a7d2	e6 3c		inc $3c				inc 	zsTemp
.a7d4	d0 02		bne $a7d8			bne 	_STWNoCarry
.a7d6	e6 3d		inc $3d				inc 	zsTemp+1
.a7d8					_STWNoCarry:
.a7d8	a9 00		lda #$00			lda 	#0
.a7da	92 3c		sta ($3c)			sta 	(zsTemp)
.a7dc	68		pla				pla
.a7dd	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_hardware.module

=1					hardwareIntegrated=1
=0					CONBlack = 0
=1					CONWhite = 1
=2					CONRed = 2
=3					CONCyan = 3
=4					CONPurple = 4
=5					CONGreen = 5
=6					CONBlue = 6
=7					CONYellow = 7
=8					CONOrange = 8
=9					CONBrown = 9
=10					CONYellowGreen = 10
=11					CONRosa = 11
=12					CONBlueGreen = 12
=13					CONLightBlue = 13
=14					CONPink = 14
=15					CONLightGreen = 15
=7					CONForeground = CONYellow
=6					CONBackground = CONBlue
=12					CLINumber = CONBlueGreen
=3					CLIToken = CONCyan
=13					CLIConstant = CONLightBlue
=7					CLIIdentifier = CONYellow
=10					CLIPunctuation = CONYellowGreen
=1					CLIData = CONWhite
.a7de					EXTPrintCharacter:
.a7de	48		pha				pha
.a7df	da		phx				phx
.a7e0	5a		phy				phy
.a7e1	a6 01		ldx $01				ldx 	1
.a7e3	da		phx				phx
.a7e4	ac 3f 06	ldy $063f			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.a7e7	09 00		ora #$00			ora 	#$00 						; check $80-$FF
.a7e9	30 48		bmi $a833			bmi 	_EXPCColour
.a7eb	c9 20		cmp #$20			cmp 	#$20 						; check $00-$1F
.a7ed	90 4d		bcc $a83c			bcc 	_EXPCControl
.a7ef	a2 02		ldx #$02			ldx 	#2 							; select char memory
.a7f1	86 01		stx $01				stx 	1
.a7f3	91 40		sta ($40),y			sta 	(EXTAddress),y
.a7f5	e6 01		inc $01				inc 	1 							; select colour memory
.a7f7	ad 40 06	lda $0640			lda 	EXTTextColour
.a7fa	91 40		sta ($40),y			sta 	(EXTAddress),y
.a7fc	c8		iny				iny 								; advance horizontal position
.a7fd	8c 3f 06	sty $063f			sty 	EXTColumn
.a800	cc 41 06	cpy $0641			cpy 	EXTScreenWidth 				; reached RHS ?
.a803	90 66		bcc $a86b			bcc 	_EXPCExit 					; no, then exit.
.a805					_EXPCCRLF:
.a805	ee 3e 06	inc $063e			inc 	EXTRow  					; bump row
.a808	9c 3f 06	stz $063f			stz 	EXTColumn 					; back to column 0
.a80b	ad 3e 06	lda $063e			lda 	EXTRow 						; check if reached the bottom ?
.a80e	cd 42 06	cmp $0642			cmp 	EXTScreenHeight 			; if so, then scroll.
.a811	f0 18		beq $a82b			beq 	_EXPCScroll
.a813	18		clc				clc 								; add width to address.
.a814	a5 40		lda $40				lda 	EXTAddress
.a816	6d 41 06	adc $0641			adc 	EXTScreenWidth
.a819	85 40		sta $40				sta 	EXTAddress
.a81b	90 4e		bcc $a86b			bcc 	_EXPCExit
.a81d	e6 41		inc $41				inc 	EXTAddress+1
.a81f	80 4a		bra $a86b			bra 	_EXPCExit
.a821					_EXPCLeft:
.a821	ce 3f 06	dec $063f			dec 	EXTColumn
.a824	10 45		bpl $a86b			bpl 	_EXPCExit
.a826					_EXPCBegin:
.a826	9c 3f 06	stz $063f			stz 	EXTColumn
.a829	80 40		bra $a86b			bra 	_EXPCExit
.a82b					_EXPCScroll:
.a82b	ce 3e 06	dec $063e			dec 	EXTRow 						; the height-1 th line.
.a82e	20 f8 a8	jsr $a8f8			jsr 	EXTScreenScroll 			; scroll the screen
.a831	80 38		bra $a86b			bra 	_EXPCExit
.a833					_EXPCColour:
.a833	c9 a0		cmp #$a0			cmp 	#$A0						; 80-9F set foreground/background
.a835	b0 34		bcs $a86b			bcs 	_EXPCExit
.a837	20 d8 a8	jsr $a8d8			jsr 	_EXPCHandleColour
.a83a	80 2f		bra $a86b			bra 	_EXPCExit
.a83c					_EXPCControl:
.a83c	c9 11		cmp #$11			cmp 	#$11 						; only handle 00-10.
.a83e	b0 2b		bcs $a86b			bcs 	_EXPCExit
.a840	0a		asl a				asl 	a 							; double into X
.a841	aa		tax				tax
.a842	7c b6 a8	jmp ($a8b6,x)			jmp 	(_EXPCActionTable,x) 		; and execute code.
.a845					_EXPCUp:
.a845	ad 3e 06	lda $063e			lda 	EXTRow 						; already at top ?
.a848	f0 21		beq $a86b			beq 	_EXPCExit
.a84a	ce 3e 06	dec $063e			dec 	EXTRow 						; up one in position/address
.a84d	38		sec				sec
.a84e	a5 40		lda $40				lda 	EXTAddress
.a850	ed 41 06	sbc $0641			sbc 	EXTScreenWidth
.a853	85 40		sta $40				sta 	EXTAddress
.a855	b0 14		bcs $a86b			bcs 	_EXPCExit
.a857	c6 41		dec $41				dec 	EXTAddress+1
.a859	80 10		bra $a86b			bra 	_EXPCExit
.a85b					_EXPCRight:
.a85b	c8		iny				iny
.a85c	8c 3f 06	sty $063f			sty 	EXTColumn
.a85f	cc 41 06	cpy $0641			cpy 	EXTScreenWidth
.a862	d0 07		bne $a86b			bne 	_EXPCExit
.a864					_EXPCEnd:
.a864	ad 41 06	lda $0641			lda 	EXTScreenWidth
.a867	3a		dec a				dec 	a
.a868	8d 3f 06	sta $063f			sta 	EXTColumn
.a86b					_EXPCExit:
.a86b	20 4d a9	jsr $a94d			jsr 	EXTSetHardwareCursor 		; place the physical cursor.
.a86e	68		pla				pla
.a86f	85 01		sta $01				sta 	1
.a871	7a		ply				ply
.a872	fa		plx				plx
.a873	68		pla				pla
.a874	60		rts				rts
.a875					_EXPCClearScreen:
.a875	20 0a a9	jsr $a90a			jsr		EXTClearScreenCode
.a878	80 f1		bra $a86b			bra 	_EXPCExit
.a87a					_EXPCDown:
.a87a	ad 42 06	lda $0642			lda 	EXTScreenHeight 			; at the bottom
.a87d	3a		dec a				dec 	a
.a87e	cd 3e 06	cmp $063e			cmp 	EXTRow
.a881	f0 e8		beq $a86b			beq 	_EXPCExit
.a883	ee 3e 06	inc $063e			inc 	EXTRow 						; down one in position/address
.a886	18		clc				clc
.a887	a5 40		lda $40				lda 	EXTAddress
.a889	6d 41 06	adc $0641			adc 	EXTScreenWidth
.a88c	85 40		sta $40				sta 	EXTAddress
.a88e	90 db		bcc $a86b			bcc 	_EXPCExit
.a890	e6 41		inc $41				inc 	EXTAddress+1
.a892	80 d7		bra $a86b			bra 	_EXPCExit
.a894					_EXPCTab:
.a894	ad 3f 06	lda $063f			lda 	EXTColumn 					; next tab stop
.a897	29 f8		and #$f8			and 	#$F8
.a899	18		clc				clc
.a89a	69 08		adc #$08			adc 	#8
.a89c	8d 3f 06	sta $063f			sta 	EXTColumn
.a89f	cd 41 06	cmp $0641			cmp 	EXTScreenWidth 				; too far, stick end of line.
.a8a2	90 c7		bcc $a86b			bcc 	_EXPCExit
.a8a4	80 be		bra $a864			bra 	_EXPCEnd
.a8a6					_EXPCBackSpace:
.a8a6	88		dey				dey
.a8a7	30 c2		bmi $a86b			bmi 	_EXPCExit
.a8a9	ce 3f 06	dec $063f			dec 	EXTColumn
.a8ac	a9 02		lda #$02			lda 	#2
.a8ae	85 01		sta $01				sta 	1
.a8b0	a9 20		lda #$20			lda 	#32
.a8b2	91 40		sta ($40),y			sta 	(EXTAddress),y
.a8b4	80 b5		bra $a86b			bra 	_EXPCExit
.a8b6					_EXPCActionTable:
>a8b6	6b a8						.word 	_EXPCExit 					; 00
>a8b8	26 a8						.word 	_EXPCBegin 					; 01 A Start of Line
>a8ba	21 a8						.word 	_EXPCLeft 					; 02 B Left
>a8bc	6b a8						.word 	_EXPCExit 					; 03 <Break>
>a8be	6b a8						.word 	_EXPCExit 					; 04
>a8c0	64 a8						.word 	_EXPCEnd 					; 05 E End of Line
>a8c2	5b a8						.word 	_EXPCRight 					; 06 F Right
>a8c4	6b a8						.word 	_EXPCExit 					; 07
>a8c6	a6 a8						.word 	_EXPCBackspace 				; 08 H Backspace
>a8c8	94 a8						.word 	_EXPCTab 					; 09 I Tab
>a8ca	6b a8						.word 	_EXPCExit 					; 0A
>a8cc	6b a8						.word 	_EXPCExit 					; 0B
>a8ce	75 a8						.word 	_EXPCClearScreen			; 0C L CLS
>a8d0	05 a8						.word 	_EXPCCRLF 					; 0D M CR/LF
>a8d2	7a a8						.word 	_EXPCDown 					; 0E N Down
>a8d4	6b a8						.word 	_EXPCExit 					; 0F
>a8d6	45 a8						.word 	_EXPCUp 					; 10 P Up
.a8d8					_EXPCHandleColour
.a8d8	c9 90		cmp #$90			cmp 	#$90 						; 8x foreground 9x background
.a8da	b0 16		bcs $a8f2			bcs 	_EXPCBackground
.a8dc	0a		asl a				asl 	a 							; shift it 4 bits to the right.
.a8dd	0a		asl a				asl 	a
.a8de	0a		asl a				asl 	a
.a8df	0a		asl a				asl 	a
.a8e0	a2 0f		ldx #$0f			ldx 	#$0F 						; Mask in X
.a8e2					_EXPCUpdate:
.a8e2	48		pha				pha 								; save new colour
.a8e3	8a		txa				txa 								; get mask
.a8e4	2d 40 06	and $0640			and 	EXTTextColour 				; mask out old.
.a8e7	8d 40 06	sta $0640			sta 	EXTTextColour
.a8ea	68		pla				pla 								; or in new colour
.a8eb	0d 40 06	ora $0640			ora 	EXTTextColour
.a8ee	8d 40 06	sta $0640			sta 	EXTTextColour
.a8f1	60		rts				rts
.a8f2					_EXPCBackground:
.a8f2	29 0f		and #$0f			and 	#$0F 						; get the colour
.a8f4	a2 f0		ldx #$f0			ldx 	#$F0 						; mask
.a8f6	80 ea		bra $a8e2			bra 	_EXPCUpdate
.a8f8					EXTScreenScroll:
.a8f8	a9 02		lda #$02			lda 	#2 							; select text page
.a8fa	85 01		sta $01				sta 	1
.a8fc	a9 20		lda #$20			lda		#32 						; fill with space
.a8fe	20 0d aa	jsr $aa0d			jsr 	EXTScrollFill
.a901	e6 01		inc $01				inc 	1 							; select colour page
.a903	ad 40 06	lda $0640			lda 	EXTTextColour
.a906	20 0d aa	jsr $aa0d			jsr 	EXTScrollFill
.a909	60		rts				rts
.a90a					EXTClearScreenCode:
.a90a	a9 02		lda #$02			lda 	#2 							; select text page
.a90c	85 01		sta $01				sta 	1
.a90e	a9 20		lda #$20			lda		#32 						; fill with space
.a910	20 1d a9	jsr $a91d			jsr 	_EXTCSFill
.a913	e6 01		inc $01				inc 	1 							; select colour page
.a915	ad 40 06	lda $0640			lda 	EXTTextColour
.a918	20 1d a9	jsr $a91d			jsr 	_EXTCSFill
.a91b	80 22		bra $a93f			bra 	EXTHomeCursor
.a91d					_EXTCSFill:
.a91d	aa		tax				tax
.a91e	a9 00		lda #$00			lda 	#EXTMemory & $FF
.a920	85 40		sta $40				sta 	EXTAddress
.a922	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a924	85 41		sta $41				sta 	EXTAddress+1
.a926					_EXTCSFill1:
.a926	a0 00		ldy #$00			ldy 	#0
.a928	8a		txa				txa
.a929					_EXTCSFill2:
.a929	91 40		sta ($40),y			sta 	(EXTAddress),y
.a92b	c8		iny				iny
.a92c	d0 fb		bne $a929			bne 	_EXTCSFill2
.a92e	e6 41		inc $41				inc 	EXTAddress+1
.a930	a5 41		lda $41				lda 	EXTAddress+1
.a932	c9 d2		cmp #$d2			cmp 	#$D2
.a934	d0 f0		bne $a926			bne 	_EXTCSFill1
.a936	8a		txa				txa
.a937					_EXTCSFill3:
.a937	91 40		sta ($40),y			sta 	(EXTAddress),y
.a939	c8		iny				iny
.a93a	c0 c0		cpy #$c0			cpy 	#$C0
.a93c	d0 f9		bne $a937			bne 	_EXTCSFill3
.a93e	60		rts				rts
.a93f					EXTHomeCursor:
.a93f	9c 3e 06	stz $063e			stz 	EXTRow 						; reset row & column
.a942	9c 3f 06	stz $063f			stz 	EXTColumn
.a945	a9 00		lda #$00			lda 	#EXTMemory & $FF 			; set address
.a947	85 40		sta $40				sta 	EXTAddress
.a949	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a94b	85 41		sta $41				sta 	EXTAddress+1
.a94d					EXTSetHardwareCursor:
.a94d	64 01		stz $01				stz 	1 							; I/O Page zero
.a94f	a9 05		lda #$05			lda 	#1+4 						; enable cursor
.a951	8d 10 d0	sta $d010			sta 	$D010
.a954	a9 b1		lda #$b1			lda 	#$B1
.a956	8d 12 d0	sta $d012			sta 	$D012
.a959	ad 3f 06	lda $063f			lda 	EXTColumn
.a95c	8d 14 d0	sta $d014			sta 	$D014 						; set cursor position
.a95f	9c 15 d0	stz $d015			stz 	$D015
.a962	ad 3e 06	lda $063e			lda 	EXTRow
.a965	8d 16 d0	sta $d016			sta 	$D016
.a968	9c 17 d0	stz $d017			stz 	$D017
.a96b	60		rts				rts
.a96c					EXTInputLine:
.a96c	48		pha				pha
.a96d	da		phx				phx
.a96e	5a		phy				phy
.a96f	a5 01		lda $01				lda 	1 							; save I/O page
.a971	48		pha				pha
.a972					_EILLoop:
.a972	20 74 aa	jsr $aa74			jsr 	ExtInputSingleCharacter
.a975	c9 0d		cmp #$0d			cmp 	#13 						; scrape line if exit.
.a977	f0 40		beq $a9b9			beq 	_EILExit
.a979	c9 08		cmp #$08			cmp 	#8 							; handle backspace
.a97b	f0 1c		beq $a999			beq 	_EILBackspace
.a97d	c9 20		cmp #$20			cmp 	#' '						; < space, print it
.a97f	90 12		bcc $a993			bcc 	_EILPrintLoop
.a981	c9 7f		cmp #$7f			cmp 	#$7F 						; if -ve print it
.a983	b0 0e		bcs $a993			bcs 	_EILPrintLoop
.a985	48		pha				pha 								; save character
.a986	a9 02		lda #$02			lda 	#2  						; insert a space
.a988	85 01		sta $01				sta 	1
.a98a	20 fb a9	jsr $a9fb			jsr 	EXTILInsert 				; insert in text screen
.a98d	e6 01		inc $01				inc 	1
.a98f	20 fb a9	jsr $a9fb			jsr 	EXTILInsert 				; insert in colour screen
.a992	68		pla				pla 								; get character back.
.a993					_EILPrintLoop:
.a993	20 de a7	jsr $a7de			jsr 	ExtPrintCharacter
.a996	80 da		bra $a972			bra 	_EILLoop
.a998	60		rts				rts
.a999					_EILBackspace:
.a999	ad 3f 06	lda $063f			lda 	EXTColumn					; can we backspace ?
.a99c	f0 d4		beq $a972			beq 	_EILLoop
.a99e	a9 02		lda #$02			lda 	#2 							; move cursor left
.a9a0	20 de a7	jsr $a7de			jsr 	EXTPrintCharacter
.a9a3	a9 02		lda #$02			lda 	#2 							; text block
.a9a5	85 01		sta $01				sta 	1
.a9a7	a9 20		lda #$20			lda 	#' ' 						; backspace text.
.a9a9	20 e6 a9	jsr $a9e6			jsr 	EXTILDelete
.a9ac	e6 01		inc $01				inc 	1 							; colour block
.a9ae	ac 3f 06	ldy $063f			ldy 	EXTColumn 					; get attribute of last character
.a9b1	88		dey				dey
.a9b2	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a9b4	20 e6 a9	jsr $a9e6			jsr 	EXTILDelete 				; backspace attribute
.a9b7	80 b9		bra $a972			bra 	_EILLoop 					; and go round.
.a9b9					_EILExit:
.a9b9	a9 02		lda #$02			lda 	#2 							; switch to page 2
.a9bb	85 01		sta $01				sta 	1
.a9bd	a0 00		ldy #$00			ldy 	#0 							; copy current line into buffer.
.a9bf					_EILScrapeLine:
.a9bf	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a9c1	99 a8 05	sta $05a8,y			sta 	lineBuffer,y
.a9c4	c8		iny				iny
.a9c5	cc 41 06	cpy $0641			cpy 	EXTScreenWidth
.a9c8	d0 f5		bne $a9bf			bne 	_EILScrapeLine
.a9ca					_EILTrimSpaces:
.a9ca	88		dey				dey
.a9cb	f0 08		beq $a9d5			beq 	_EILEndTrim
.a9cd	b9 a8 05	lda $05a8,y			lda 	lineBuffer,y
.a9d0	c9 20		cmp #$20			cmp 	#' '
.a9d2	f0 f6		beq $a9ca			beq 	_EILTrimSpaces
.a9d4	c8		iny				iny 								; trim after non space character.
.a9d5					_EILEndTrim:
.a9d5	a9 00		lda #$00			lda 	#0 							; trim here.
.a9d7	99 a8 05	sta $05a8,y			sta 	lineBuffer,y
.a9da	a9 0d		lda #$0d			lda 	#13 						; echo the RETURN
.a9dc	20 de a7	jsr $a7de			jsr 	ExtPrintCharacter
.a9df	68		pla				pla 								; reset I/O page
.a9e0	85 01		sta $01				sta 	1
.a9e2	7a		ply				ply
.a9e3	fa		plx				plx
.a9e4	68		pla				pla
.a9e5	60		rts				rts
.a9e6					EXTILDelete:
.a9e6	48		pha				pha 								; save the new character
.a9e7	ac 3f 06	ldy $063f			ldy 	EXTColumn 					; start copying from here.
.a9ea					_EXTDLoop:
.a9ea	c8		iny				iny 								; copy one byte down.
.a9eb	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a9ed	88		dey				dey
.a9ee	91 40		sta ($40),y			sta 	(EXTAddress),y
.a9f0	c8		iny				iny 								; do till end of line.
.a9f1	cc 41 06	cpy $0641			cpy 	EXTScreenWidth
.a9f4	90 f4		bcc $a9ea			bcc 	_EXTDLoop
.a9f6	88		dey				dey 	 							; write in last slot.
.a9f7	68		pla				pla
.a9f8	91 40		sta ($40),y			sta 	(EXTAddress),y
.a9fa	60		rts				rts
.a9fb					EXTILInsert:
.a9fb	ac 41 06	ldy $0641			ldy 	EXTScreenWidth 				; end position
.a9fe					_EXTILoop:
.a9fe	88		dey				dey 								; back one
.a9ff	cc 3f 06	cpy $063f			cpy 	EXTColumn 					; exit if reached insert point.
.aa02	f0 08		beq $aa0c			beq 	_EXTIExit
.aa04	88		dey				dey 								; copy one byte up.
.aa05	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa07	c8		iny				iny
.aa08	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa0a	80 f2		bra $a9fe			bra 	_EXTILoop
.aa0c					_EXTIExit:
.aa0c	60		rts				rts
.aa0d					EXTScrollFill:
.aa0d	aa		tax				tax									; save value to fill with
.aa0e	a5 36		lda $36				lda 	zTemp0 						; save zTemp0 (dest) zTemp1 (src)
.aa10	48		pha				pha
.aa11	a5 37		lda $37				lda 	zTemp0+1
.aa13	48		pha				pha
.aa14	a5 38		lda $38				lda 	zTemp1
.aa16	48		pha				pha
.aa17	a5 39		lda $39				lda 	zTemp1+1
.aa19	48		pha				pha
.aa1a	a9 c0		lda #$c0			lda 	#$C0 						; copy from C000+length to C000
.aa1c	85 37		sta $37				sta 	zTemp0+1
.aa1e	85 39		sta $39				sta 	zTemp1+1
.aa20	64 36		stz $36				stz 	zTemp0
.aa22	ad 41 06	lda $0641			lda 	EXTScreenWidth
.aa25	85 38		sta $38				sta 	zTemp1
.aa27	a0 00		ldy #$00			ldy 	#0
.aa29					_EXSFCopy1:
.aa29	b1 38		lda ($38),y			lda 	(zTemp1),y
.aa2b	91 36		sta ($36),y			sta 	(zTemp0),y
.aa2d	c8		iny				iny
.aa2e	d0 f9		bne $aa29			bne 	_EXSFCopy1
.aa30	e6 37		inc $37				inc 	zTemp0+1 					; next page
.aa32	e6 39		inc $39				inc 	zTemp1+1
.aa34	a5 39		lda $39				lda 	zTemp1+1
.aa36	c9 d3		cmp #$d3			cmp 	#$D3
.aa38	d0 ef		bne $aa29			bne 	_EXSFCopy1
.aa3a	ac 41 06	ldy $0641			ldy 	EXTScreenWidth 				; blank the bottom line.
.aa3d	8a		txa				txa
.aa3e					_EXSFFill1:
.aa3e	88		dey				dey
.aa3f	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa41	c0 00		cpy #$00			cpy 	#0
.aa43	10 f9		bpl $aa3e			bpl 	_EXSFFill1
.aa45	68		pla				pla
.aa46	85 39		sta $39				sta 	zTemp1+1
.aa48	68		pla				pla
.aa49	85 38		sta $38				sta 	zTemp1
.aa4b	68		pla				pla
.aa4c	85 37		sta $37				sta 	zTemp0+1
.aa4e	68		pla				pla
.aa4f	85 36		sta $36				sta 	zTemp0
.aa51	60		rts				rts
=$c000					EXTMemory = $C000
=$02					EXTTextPage = $02
=$03					EXTColourPage = $03
=1					EXTDummySpace = 1 							; fake-space for CR character.
=0					EXTCBlack = 0
.063e					EXTRow:
>063e							.fill 	1
.063f					EXTColumn:
>063f							.fill 	1
.0640					EXTTextColour:
>0640							.fill 	1
.0641					EXTScreenWidth:
>0641							.fill 	1
.0642					EXTScreenHeight:
>0642							.fill 	1
.0040					EXTAddress:
>0040							.fill 	2
.aa52					EXTInitialise:
.aa52	64 01		stz $01				stz 	1 							; Access I/O
.aa54	9c 04 d0	stz $d004			stz 	$D004 						; Disable border
.aa57	9c 08 d0	stz $d008			stz 	$D008
.aa5a	9c 09 d0	stz $d009			stz 	$D009
.aa5d	a9 09		lda #$09			lda 	#1+8						; Timer On at 70Hz counting up.
.aa5f	8d 58 d6	sta $d658			sta 	$D658
.aa62	a9 76		lda #$76			lda 	#CONForeground * 16 + CONBackground
.aa64	8d 40 06	sta $0640			sta 	EXTTextColour
.aa67	a9 50		lda #$50			lda 	#80 						; set screen dimensions.
.aa69	8d 41 06	sta $0641			sta 	EXTScreenWidth
.aa6c	a9 3c		lda #$3c			lda 	#60
.aa6e	8d 42 06	sta $0642			sta 	EXTScreenHeight
.aa71	64 01		stz $01				stz 	1
.aa73	60		rts				rts
.aa74					EXTInputSingleCharacter:
.aa74	da		phx				phx
.aa75	5a		phy				phy
.aa76					_EISCWait:
.aa76	64 01		stz $01				stz 	1 							; access I/O Page 0
.aa78	38		sec				sec 								; calculate timer - LastTick
.aa79	ad 59 d6	lda $d659			lda 	$D659
.aa7c	aa		tax				tax 								; saving timer in X
.aa7d	ed 2d 06	sbc $062d			sbc 	LastTick
.aa80	c9 03		cmp #$03			cmp 	#3
.aa82	90 06		bcc $aa8a			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.aa84	8e 2d 06	stx $062d			stx 	LastTick 					; update last timer
.aa87	20 f9 b9	jsr $b9f9			jsr 	TickHandler 				; go do the code.
.aa8a					_NoFireTick:
.aa8a	20 e4 ff	jsr $ffe4			jsr 	$FFE4
.aa8d	c9 00		cmp #$00			cmp 	#0
.aa8f	f0 e5		beq $aa76			beq 	_EISCWait
.aa91	7a		ply				ply
.aa92	fa		plx				plx
.aa93	60		rts				rts
.aa94					EXTBreakCheck:
.aa94	4c e1 ff	jmp $ffe1			jmp		$FFE1
.aa97					EXTReadController:
.aa97	da		phx				phx
.aa98	a2 00		ldx #$00			ldx 	#0
.aa9a	a9 05		lda #$05			lda 	#(($2D) >> 3)
.aa9c	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa9f	29 20		and #$20			and 	#($01 << (($2D) & 7))
.aaa1	f0 04		beq $aaa7			beq 	_NoSet1
.aaa3	8a		txa				txa
.aaa4	09 01		ora #$01			ora 	#1
.aaa6	aa		tax				tax
.aaa7					_NoSet1:
.aaa7	a9 05		lda #$05			lda 	#(($2C) >> 3)
.aaa9	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aaac	29 10		and #$10			and 	#($01 << (($2C) & 7))
.aaae	f0 04		beq $aab4			beq 	_NoSet1
.aab0	8a		txa				txa
.aab1	09 02		ora #$02			ora 	#2
.aab3	aa		tax				tax
.aab4					_NoSet1:
.aab4	a9 06		lda #$06			lda 	#(($32) >> 3)
.aab6	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aab9	29 04		and #$04			and 	#($01 << (($32) & 7))
.aabb	f0 04		beq $aac1			beq 	_NoSet1
.aabd	8a		txa				txa
.aabe	09 04		ora #$04			ora 	#4
.aac0	aa		tax				tax
.aac1					_NoSet1:
.aac1	a9 04		lda #$04			lda 	#(($25) >> 3)
.aac3	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aac6	29 20		and #$20			and 	#($01 << (($25) & 7))
.aac8	f0 04		beq $aace			beq 	_NoSet1
.aaca	8a		txa				txa
.aacb	09 08		ora #$08			ora 	#8
.aacd	aa		tax				tax
.aace					_NoSet1:
.aace	a9 04		lda #$04			lda 	#(($26) >> 3)
.aad0	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aad3	29 40		and #$40			and 	#($01 << (($26) & 7))
.aad5	f0 04		beq $aadb			beq 	_NoSet1
.aad7	8a		txa				txa
.aad8	09 10		ora #$10			ora 	#16
.aada	aa		tax				tax
.aadb					_NoSet1:
.aadb	8a		txa				txa
.aadc	fa		plx				plx
.aadd	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_graphics.module

=1					graphicsIntegrated=1
=0					GCMD_Initialise = 0*2
=2					GCMD_BitmapCtl = 1*2
=4					GCMD_SpriteCtl = 2*2
=6					GCMD_Clear = 3*2
=8					GCMD_Colour = 4*2
=10					GCMD_DrawFont = 5*2
=12					GCMD_DrawSprite = 6*2
=14					GCMD_SpriteUse = 7*2
=16					GCMD_SpriteImage = 8*2
=18					GCMD_SpriteCollide = 9*2
=64					GCMD_Move = 32*2
=66					GCMD_Line = 33*2
=68					GCMD_FrameRect = 34*2
=70					GCMD_FillRect = 35*2
=72					GCMD_FrameCircle = 36*2
=74					GCMD_FillCircle = 37*2
=80					GCMD_Plot = 40*2
=82					GCMD_SpriteMove = 41*2
=42					GRFirstFreeCode = 42
.b9ff					GRVectorTable:
>b9ff	d9 ac					.word	GXInitialise             ; $00 Initialise
>ba01	f3 ac					.word	GXControlBitmap          ; $01 BitmapCtl
>ba03	3b ad					.word	GXControlSprite          ; $02 SpriteCtl
>ba05	8b ac					.word	GXClearBitmap            ; $03 Clear
>ba07	ca ae					.word	GXSetColourMode          ; $04 Colour
>ba09	92 b0					.word	GXFontHandler            ; $05 DrawFont
>ba0b	da b0					.word	GXSpriteHandler          ; $06 DrawSprite
>ba0d	46 b1					.word	GXSelect                 ; $07 SpriteUse
>ba0f	6f b1					.word	GXSelectImage            ; $08 SpriteImage
>ba11	f6 b2					.word	GXCollide                ; $09 SpriteCollide
>ba13	3d ab					.word	GRUndefined              ; $0a
>ba15	3d ab					.word	GRUndefined              ; $0b
>ba17	3d ab					.word	GRUndefined              ; $0c
>ba19	3d ab					.word	GRUndefined              ; $0d
>ba1b	3d ab					.word	GRUndefined              ; $0e
>ba1d	3d ab					.word	GRUndefined              ; $0f
>ba1f	3d ab					.word	GRUndefined              ; $10
>ba21	3d ab					.word	GRUndefined              ; $11
>ba23	3d ab					.word	GRUndefined              ; $12
>ba25	3d ab					.word	GRUndefined              ; $13
>ba27	3d ab					.word	GRUndefined              ; $14
>ba29	3d ab					.word	GRUndefined              ; $15
>ba2b	3d ab					.word	GRUndefined              ; $16
>ba2d	3d ab					.word	GRUndefined              ; $17
>ba2f	3d ab					.word	GRUndefined              ; $18
>ba31	3d ab					.word	GRUndefined              ; $19
>ba33	3d ab					.word	GRUndefined              ; $1a
>ba35	3d ab					.word	GRUndefined              ; $1b
>ba37	3d ab					.word	GRUndefined              ; $1c
>ba39	3d ab					.word	GRUndefined              ; $1d
>ba3b	3d ab					.word	GRUndefined              ; $1e
>ba3d	3d ab					.word	GRUndefined              ; $1f
>ba3f	3b ab					.word	GXMove                   ; $20 Move
>ba41	98 ad					.word	GXLine                   ; $21 Line
>ba43	13 af					.word	GXFrameRectangle         ; $22 FrameRect
>ba45	10 af					.word	GXFillRectangle          ; $23 FillRect
>ba47	42 ab					.word	GXFrameCircle            ; $24 FrameCircle
>ba49	3e ab					.word	GXFillCircle             ; $25 FillCircle
>ba4b	3d ab					.word	GRUndefined              ; $26
>ba4d	3d ab					.word	GRUndefined              ; $27
>ba4f	f8 ae					.word	GXPlotPoint              ; $28 Plot
>ba51	05 b2					.word	GXMoveSprite             ; $29 SpriteMove
=3					GXMappingPage = 3
=24576					GXMappingAddress = ($2000 * GXMappingPage)
=11					GXEditSlot = 8 + GXMappingPage
=$36					gxzTemp0 = zTemp0
=$38					gxzTemp1 = zTemp1
=$3a					gxzTemp2 = zTemp2
=$3c					gxzScreen = zsTemp
=$5f9					gxPixelBuffer = numberBuffer
.0643					gxCurrentX:
>0643							.fill 	2
.0645					gxCurrentY:
>0645							.fill 	2
.0647					gxLastX:
>0647							.fill 	2
.0649					gxLastY:
>0649							.fill 	2
.064b					gxX0:
>064b							.fill 	2
.064d					gxY0:
>064d							.fill 	2
.064f					gxX1:
>064f							.fill 	2
.0651					gxY1:
>0651							.fill 	2
.0653					gxSpritesOn:
>0653							.fill 	1
.0654					gxBitmapsOn:
>0654							.fill 	1
.0655					gxBasePage:
>0655							.fill 	1
.0656					gxSpritePage:
>0656							.fill 	1
.0657					gxHeight:
>0657							.fill 	1
.0658					gxMode:
>0658							.fill 	1
.0659					gxColour:
>0659							.fill 	1
.065a					gxEORValue:
>065a							.fill 	1
.065b					gxANDValue:
>065b							.fill 	1
.065c					gxOriginalLUTValue:
>065c							.fill 	1
.065d					gsOffset:
>065d							.fill 	1
.065e					GSCurrentSpriteID:
>065e							.fill 	1
.065f					GSCurrentSpriteAddr:
>065f							.fill 	2
.0661					GXSpriteOffsetBase:
>0661							.fill 	2
.0663					GXSpriteLow:
>0663							.fill 	64
.06a3					GXSpriteHigh:
>06a3							.fill 	64
.aade					GXGraphicDraw:
.aade	c9 40		cmp #$40			cmp 	#GCMD_Move					; low instructions don't use coordinates
.aae0	b0 06		bcs $aae8			bcs 	_GDCoordinate
.aae2	86 36		stx $36				stx 	gxzTemp0 					; save X/Y
.aae4	84 37		sty $37				sty 	gxzTemp0+1
.aae6	80 4b		bra $ab33			bra 	_GDExecuteA 				; and execute
.aae8					_GDCoordinate:
.aae8	48		pha				pha 								; save AXY
.aae9	da		phx				phx
.aaea	5a		phy				phy
.aaeb	a2 03		ldx #$03			ldx 	#3 							; copy currentX to lastX
.aaed					_GDCopy1:
.aaed	bd 43 06	lda $0643,x			lda 	gxCurrentX,x
.aaf0	9d 47 06	sta $0647,x			sta 	gxLastX,x
.aaf3	ca		dex				dex
.aaf4	10 f7		bpl $aaed			bpl 	_GDCopy1
.aaf6	68		pla				pla 								; update Y
.aaf7	8d 45 06	sta $0645			sta 	gxCurrentY
.aafa	9c 46 06	stz $0646			stz 	gxCurrentY+1
.aafd	68		pla				pla
.aafe	8d 43 06	sta $0643			sta 	gxCurrentX
.ab01	68		pla				pla 								; get A (command+X.1) back
.ab02	48		pha				pha
.ab03	29 01		and #$01			and 	#1 							; put LSB as MSB of Current.X
.ab05	8d 44 06	sta $0644			sta 	gxCurrentX+1
.ab08	68		pla				pla 								; get command back
.ab09	29 fe		and #$fe			and 	#$FE 						; lose LSB, chuck the stray X bit
.ab0b	48		pha				pha 								; push back.
.ab0c	c9 52		cmp #$52			cmp 	#GCMD_SpriteMove 			; move sprite does not clip.
.ab0e	f0 17		beq $ab27			beq 	_GDCopyToWorkArea
.ab10	ad 44 06	lda $0644			lda 	gxCurrentX+1 				; X < 256 X okay
.ab13	f0 07		beq $ab1c			beq 	_GDCheckY
.ab15	ad 43 06	lda $0643			lda 	gxCurrentX 					; otherwise X < 320 = 256 + 64
.ab18	c9 40		cmp #$40			cmp 	#64
.ab1a	b0 08		bcs $ab24			bcs 	_GDError1
.ab1c					_GDCheckY:
.ab1c	ad 45 06	lda $0645			lda 	gxCurrentY 					; check Y < Height.
.ab1f	cd 57 06	cmp $0657			cmp 	gxHeight
.ab22	90 03		bcc $ab27			bcc 	_GDCopyToWorkArea
.ab24					_GDError1:
.ab24	68		pla				pla
.ab25					_GDError2:
.ab25	38		sec				sec
.ab26	60		rts				rts
.ab27					_GDCopyToWorkArea:
.ab27	a2 07		ldx #$07			ldx 	#7 							; copy current and last to gxXY/12 work area
.ab29					_GDCopy2:
.ab29	bd 43 06	lda $0643,x			lda 	gxCurrentX,x
.ab2c	9d 4b 06	sta $064b,x			sta 	gxX0,x
.ab2f	ca		dex				dex
.ab30	10 f7		bpl $ab29			bpl 	_GDCopy2
.ab32	68		pla				pla 								; get command
.ab33					_GDExecuteA:
.ab33	c9 54		cmp #$54			cmp 	#GRFirstFreeCode*2 			; bad ?
.ab35	b0 ee		bcs $ab25			bcs 	_GDError2
.ab37	aa		tax				tax
.ab38	7c ff b9	jmp ($b9ff,x)			jmp 	(GRVectorTable,x)
.ab3b					GXMove:
.ab3b	18		clc				clc
.ab3c	60		rts				rts
.ab3d					GRUndefined:
>ab3d	db						.byte 	$DB 						; causes a break in the emulator
.ab3e					GXFillCircle:
.ab3e	a9 ff		lda #$ff			lda 	#255
.ab40	80 02		bra $ab44			bra 	GXCircle
.ab42					GXFrameCircle:
.ab42	a9 00		lda #$00			lda 	#0
.ab44					GXCircle:
.ab44	8d e6 06	sta $06e6			sta 	gxIsFillMode					; save Fill flag
.ab47	ad 54 06	lda $0654			lda 	gxBitmapsOn
.ab4a	f0 26		beq $ab72			beq 	_GXCFail
.ab4c	20 9d b3	jsr $b39d			jsr 	GXSortXY 					; topleft/bottomright
.ab4f	20 75 b2	jsr $b275			jsr 	GXOpenBitmap 				; start drawing
.ab52	20 44 ac	jsr $ac44			jsr 	GXCircleSetup 				; set up for drawing
.ab55	9c e7 06	stz $06e7			stz 	gxYChanged
.ab58					_GXCircleDraw:
.ab58	ad e4 06	lda $06e4			lda 	gXCentre					; while x <= y
.ab5b	cd e5 06	cmp $06e5			cmp 	gYCentre
.ab5e	90 0a		bcc $ab6a			bcc 	_GXCircleContinue
.ab60	d0 03		bne $ab65			bne 	_GXNoLast
.ab62	20 77 ab	jsr $ab77			jsr 	GXPlot1
.ab65					_GXNoLast:
.ab65	20 7d b2	jsr $b27d			jsr 	GXCloseBitmap 				; close the bitmap
.ab68	18		clc				clc
.ab69	60		rts				rts
.ab6a					_GXCircleContinue:
.ab6a	20 74 ab	jsr $ab74			jsr 	GXPlot2 					; draw it
.ab6d	20 f1 ab	jsr $abf1			jsr 	GXCircleMove 				; adjust the coordinates
.ab70	80 e6		bra $ab58			bra 	_GXCircleDraw
.ab72					_GXCFail:
.ab72	38		sec				sec
.ab73	60		rts				rts
.ab74					GXPlot2:
.ab74	20 77 ab	jsr $ab77			jsr 	GXPlot1 						; plot and swap, fall through does twice
.ab77					GXPlot1:
.ab77	ad e5 06	lda $06e5			lda 	gYCentre 						; if y = 0, don't do it twice (xor)
.ab7a	f0 03		beq $ab7f			beq 	_GXPlot1Only
.ab7c	20 9b ab	jsr $ab9b			jsr 	GXPlot0 						; plot and negate
.ab7f					_GXPlot1Only:
.ab7f	20 9b ab	jsr $ab9b			jsr 	GXPlot0 						; twice, undoing negation
.ab82	ad e4 06	lda $06e4			lda 	gXCentre 						; swap X and Y
.ab85	ae e5 06	ldx $06e5			ldx	 	gYCentre
.ab88	8d e5 06	sta $06e5			sta 	gYCentre
.ab8b	8e e4 06	stx $06e4			stx 	gXCentre
.ab8e	ad e7 06	lda $06e7			lda 	gxYChanged 						; toggle Y Changed flag
.ab91	a9 ff		lda #$ff			lda 	#$FF
.ab93	8d e7 06	sta $06e7			sta 	gxYChanged
.ab96	60		rts				rts
.ab97	20 9b ab	jsr $ab9b			jsr 	GXPlot0 						; do once
.ab9a	60		rts				rts
.ab9b	ad e6 06	lda $06e6	GXPlot0:lda 	gxIsFillMode 					; outline mode, always draw as X or Y will change
.ab9e	f0 05		beq $aba5			beq 	_GXPlot0Always
.aba0	ad e7 06	lda $06e7			lda 	gxYChanged						; fill mode, only draw if changed.
.aba3	f0 2d		beq $abd2			beq 	GXPlot0Exit
.aba5					_GXPlot0Always:
.aba5	a2 02		ldx #$02			ldx 	#2 								; copy Y1-A => Y0
.aba7	ad e5 06	lda $06e5			lda 	gYCentre
.abaa	20 d3 ab	jsr $abd3			jsr 	GXSubCopy
.abad	a2 00		ldx #$00			ldx 	#0 								; copy X1-A => X0,
.abaf	ad e4 06	lda $06e4			lda 	gXCentre
.abb2	20 d3 ab	jsr $abd3			jsr 	GXSubCopy
.abb5	48		pha				pha 									; save last offset X
.abb6	20 85 b2	jsr $b285			jsr 	GXPositionCalc 					; calculate position/offset.
.abb9	68		pla				pla
.abba	0a		asl a				asl 	a 								; store 2 x last offset in gxzTemp0
.abbb	85 36		sta $36				sta 	gxzTemp0
.abbd	64 37		stz $37				stz 	gxzTemp0+1
.abbf	26 37		rol $37				rol 	gxzTemp0+1
.abc1	ad e6 06	lda $06e6			lda 	gxIsFillMode
.abc4	69 80		adc #$80			adc 	#128
.abc6	20 63 af	jsr $af63			jsr 	GXDrawLineTemp0 				; routine from Rectangle.
.abc9	38		sec				sec 									; GY = -GY
.abca	a9 00		lda #$00			lda 	#0
.abcc	ed e5 06	sbc $06e5			sbc 	gYCentre
.abcf	8d e5 06	sta $06e5			sta 	gYCentre
.abd2					GXPlot0Exit:
.abd2	60		rts				rts
.abd3					GXSubCopy:
.abd3	85 36		sta $36				sta 	gxzTemp0
.abd5	64 37		stz $37				stz 	gxzTemp0+1
.abd7	29 80		and #$80			and 	#$80
.abd9	f0 02		beq $abdd			beq 	_GXNoSx
.abdb	c6 37		dec $37				dec 	gxzTemp0+1
.abdd					_GXNoSx:
.abdd	38		sec				sec
.abde	bd 4f 06	lda $064f,x			lda 	gXX1,x
.abe1	e5 36		sbc $36				sbc 	gxzTemp0
.abe3	9d 4b 06	sta $064b,x			sta 	gXX0,x
.abe6	bd 50 06	lda $0650,x			lda 	gXX1+1,x
.abe9	e5 37		sbc $37				sbc 	gxzTemp0+1
.abeb	9d 4c 06	sta $064c,x			sta 	gXX0+1,x
.abee	a5 36		lda $36				lda 	gxzTemp0 						; return A
.abf0	60		rts				rts
.abf1					GXCircleMove:
.abf1	9c e7 06	stz $06e7			stz 	gxYChanged 					; clear Y changed flag
.abf4	a5 39		lda $39				lda 	gxzTemp1+1 					; check sign of D
.abf6	10 0d		bpl $ac05			bpl 	_GXEMPositive
.abf8	ee e4 06	inc $06e4			inc 	gXCentre 					; X++
.abfb	ad e4 06	lda $06e4			lda 	gXCentre
.abfe	20 24 ac	jsr $ac24			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.ac01	a9 06		lda #$06			lda 	#6  						; and add 6
.ac03	80 15		bra $ac1a			bra 	_GXEMAddD
.ac05					_GXEMPositive:
.ac05	ee e4 06	inc $06e4			inc 	gXCentre					; X++
.ac08	ce e5 06	dec $06e5			dec 	gyCentre 					; Y--
.ac0b	38		sec				sec 								; calculate X-Y
.ac0c	ad e4 06	lda $06e4			lda 	gXCentre
.ac0f	ed e5 06	sbc $06e5			sbc 	gYCentre
.ac12	20 24 ac	jsr $ac24			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.ac15	a9 0a		lda #$0a			lda 	#10  						; and add 10
.ac17	ce e7 06	dec $06e7			dec 	gxYChanged
.ac1a					_GXEMAddD:
.ac1a	18		clc				clc
.ac1b	65 38		adc $38				adc 	gxzTemp1
.ac1d	85 38		sta $38				sta 	gxzTemp1
.ac1f	90 02		bcc $ac23			bcc 	_GXEMNoCarry
.ac21	e6 39		inc $39				inc 	gxzTemp1+1
.ac23					_GXEMNoCarry:
.ac23	60		rts				rts
.ac24					_GXAdd4TimesToD:
.ac24	85 36		sta $36				sta 	gxzTemp0 					; make 16 bit signed.
.ac26	29 80		and #$80			and 	#$80
.ac28	f0 02		beq $ac2c			beq 	_GXA4Unsigned
.ac2a	a9 ff		lda #$ff			lda 	#$FF
.ac2c					_GXA4Unsigned:
.ac2c	85 37		sta $37				sta 	gxzTemp0+1
.ac2e	06 36		asl $36				asl 	gxzTemp0  					; x 4
.ac30	26 37		rol $37				rol 	gxzTemp0+1
.ac32	06 36		asl $36				asl 	gxzTemp0
.ac34	26 37		rol $37				rol 	gxzTemp0+1
.ac36	18		clc				clc 								; add
.ac37	a5 36		lda $36				lda		gxzTemp0
.ac39	65 38		adc $38				adc 	gxzTemp1
.ac3b	85 38		sta $38				sta 	gxzTemp1
.ac3d	a5 37		lda $37				lda		gxzTemp0+1
.ac3f	65 39		adc $39				adc 	gxzTemp1+1
.ac41	85 39		sta $39				sta 	gxzTemp1+1
.ac43	60		rts				rts
.ac44					GXCircleSetup:
.ac44	38		sec				sec
.ac45	ad 51 06	lda $0651			lda 	gxY1
.ac48	ed 4d 06	sbc $064d			sbc 	gxY0
.ac4b	4a		lsr a				lsr 	a
.ac4c	8d e3 06	sta $06e3			sta 	gxRadius
.ac4f	a2 00		ldx #$00			ldx 	#0
.ac51	20 73 ac	jsr $ac73			jsr 	_GXCalculateCentre
.ac54	a2 02		ldx #$02			ldx 	#2
.ac56	20 73 ac	jsr $ac73			jsr 	_GXCalculateCentre
.ac59	9c e4 06	stz $06e4			stz 	gXCentre
.ac5c	ad e3 06	lda $06e3			lda 	gxRadius
.ac5f	8d e5 06	sta $06e5			sta 	gYCentre
.ac62	0a		asl a				asl 	a 							; R x 2
.ac63	85 36		sta $36				sta 	gxzTemp0
.ac65	38		sec				sec
.ac66	a9 03		lda #$03			lda 	#3
.ac68	e5 36		sbc $36				sbc 	gxzTemp0
.ac6a	85 38		sta $38				sta 	gxzTemp1
.ac6c	a9 00		lda #$00			lda 	#0
.ac6e	e9 00		sbc #$00			sbc 	#0
.ac70	85 39		sta $39				sta 	gxzTemp1+1
.ac72	60		rts				rts
.ac73					_GXCalculateCentre:
.ac73	38		sec				sec
.ac74	bd 4f 06	lda $064f,x			lda 	gxX1,x
.ac77	7d 4b 06	adc $064b,x			adc 	gXX0,x
.ac7a	9d 4f 06	sta $064f,x			sta 	gXX1,x
.ac7d	bd 50 06	lda $0650,x			lda 	gXX1+1,x
.ac80	7d 4c 06	adc $064c,x			adc 	gXX0+1,x
.ac83	4a		lsr a				lsr 	a
.ac84	9d 50 06	sta $0650,x			sta 	gXX1+1,x
.ac87	7e 4f 06	ror $064f,x			ror 	gXX1,x
.ac8a	60		rts				rts
.06e3					gxRadius:
>06e3							.fill 	1
.06e4					gXCentre:
>06e4							.fill 	1
.06e5					gYCentre:
>06e5							.fill 	1
.06e6					gxIsFillMode:
>06e6							.fill 	1
.06e7					gxYChanged:
>06e7							.fill  	1
=64000					ScreenSize200 = 320 * 200
=76800					ScreenSize240 = 320 * 240
.ac8b					GXClearBitmap:
.ac8b	ad 54 06	lda $0654			lda 	gxBitmapsOn 				; check BMP running.
.ac8e	f0 24		beq $acb4			beq 	_GXCBFail
.ac90	20 75 b2	jsr $b275			jsr 	GXOpenBitmap 				; start access
.ac93	a0 07		ldy #$07			ldy 	#ScreenSize200 / 8192 		; X is pages to clear
.ac95	ad 57 06	lda $0657			lda 	gxHeight
.ac98	c9 c8		cmp #$c8			cmp 	#200 						; 200 ?
.ac9a	a0 09		ldy #$09			ldy 	#ScreenSize240 / 8192
.ac9c					_GXCalcLastPage:
.ac9c	98		tya				tya 								; add to base page
.ac9d	18		clc				clc
.ac9e	6d 55 06	adc $0655			adc 	gxBasePage
.aca1	85 0b		sta $0b				sta 	GXEditSlot  				; clear from this page back
.aca3					_GXClearAll:
.aca3	20 b6 ac	jsr $acb6			jsr 	_GXClearBlock 				; clear 8k block
.aca6	c6 0b		dec $0b				dec 	GXEditSlot  				; back to previous
.aca8	a5 0b		lda $0b				lda 	GXEditSlot
.acaa	cd 55 06	cmp $0655			cmp 	gxBasePage 					; until before base page
.acad	b0 f4		bcs $aca3			bcs 	_GXClearAll
.acaf	20 7d b2	jsr $b27d			jsr 	GXCloseBitmap	 			; stop access
.acb2	18		clc				clc
.acb3	60		rts				rts
.acb4					_GXCBFail:
.acb4	38		sec				sec
.acb5	60		rts				rts
.acb6					_GXClearBlock:
.acb6	a9 00		lda #$00			lda 	#((GXMappingAddress) & $FF)
.acb8	85 38		sta $38				sta 	0+gxzTemp1
.acba	a9 60		lda #$60			lda 	#((GXMappingAddress) >> 8)
.acbc	85 39		sta $39				sta 	1+gxzTemp1
.acbe					_GXCB0:
.acbe	a5 36		lda $36				lda 	gxzTemp0
.acc0	a0 00		ldy #$00			ldy 	#0
.acc2					_GXCB1:
.acc2	91 38		sta ($38),y			sta 	(gxzTemp1),y
.acc4	c8		iny				iny
.acc5	91 38		sta ($38),y			sta 	(gxzTemp1),y
.acc7	c8		iny				iny
.acc8	91 38		sta ($38),y			sta 	(gxzTemp1),y
.acca	c8		iny				iny
.accb	91 38		sta ($38),y			sta 	(gxzTemp1),y
.accd	c8		iny				iny
.acce	d0 f2		bne $acc2			bne 	_GXCB1
.acd0	e6 39		inc $39				inc 	gxzTemp1+1
.acd2	a5 39		lda $39				lda 	gxzTemp1+1
.acd4	c9 80		cmp #$80			cmp	 	#(GXMappingAddress >> 8)+$20
.acd6	d0 e6		bne $acbe			bne 	_GXCB0
.acd8	60		rts				rts
.acd9					GXInitialise:
.acd9	64 01		stz $01				stz 	1
.acdb	a9 01		lda #$01			lda 	#1
.acdd	8d 00 d0	sta $d000			sta 	$D000
.ace0	18		clc				clc
.ace1	9c 53 06	stz $0653			stz 	GXSpritesOn
.ace4	9c 54 06	stz $0654			stz 	GXBitmapsOn
.ace7	a2 0f		ldx #$0f			ldx 	#15
.ace9					_GXIClear:
.ace9	9e 43 06	stz $0643,x			stz 	gxCurrentX,x
.acec	ca		dex				dex
.aced	10 fa		bpl $ace9			bpl 	_GXIClear
.acef	20 8a ad	jsr $ad8a			jsr 	GXClearSpriteStore
.acf2	60		rts				rts
.acf3					GXControlBitmap:
.acf3	64 01		stz $01				stz 	1
.acf5	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.acf7	29 01		and #$01			and 	#1 							; set bitmap flag
.acf9	8d 54 06	sta $0654			sta 	gxBitmapsOn
.acfc	4a		lsr a				lsr 	a 							; bit 0 into carry.
.acfd	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.ad00	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.ad02	29 f7		and #$f7			and 	#$F7 						; clear bitmap bit
.ad04	90 02		bcc $ad08			bcc 	_CBNotOn
.ad06	09 08		ora #$08			ora 	#$08 						; bitmap on if 1 on 0 off
.ad08					_CBNotOn:
.ad08	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.ad0b	a5 36		lda $36				lda 	gxzTemp0 					; get control settings (bits 0-2)
.ad0d	29 07		and #$07			and 	#7
.ad0f	8d 00 d1	sta $d100			sta 	$D100 						; write in Vicky Bitmap Control Register #0
.ad12	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.ad14	d0 02		bne $ad18			bne 	_CBNotDefault
.ad16	a9 08		lda #$08			lda 	#8  						; if zero, use 8 e.g. bitmap at $10000
.ad18					_CBNotDefault:
.ad18	8d 55 06	sta $0655			sta 	gxBasePage
.ad1b	20 7c ad	jsr $ad7c			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.ad1e	a5 37		lda $37				lda 	gxzTemp0+1 					; copy address into Bitmap address registers
.ad20	8d 03 d1	sta $d103			sta 	$D103
.ad23	a5 36		lda $36				lda 	gxzTemp0
.ad25	8d 02 d1	sta $d102			sta 	$D102
.ad28	9c 01 d1	stz $d101			stz 	$D101
.ad2b	a2 f0		ldx #$f0			ldx 	#240 						; height is 240
.ad2d	ad 01 d0	lda $d001			lda 	$D001 						; read MCR bit 0
.ad30	29 01		and #$01			and 	#1
.ad32	f0 02		beq $ad36			beq 	_CBHaveHeight
.ad34	a2 c8		ldx #$c8			ldx 	#200 						; if bit 0 set 320x200
.ad36					_CBHaveHeight
.ad36	8e 57 06	stx $0657			stx 	gxHeight
.ad39	18		clc				clc
.ad3a	60		rts				rts
.ad3b					GXControlSprite:
.ad3b	64 01		stz $01				stz 	1
.ad3d	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.ad3f	29 01		and #$01			and 	#1 							; set sprites flag
.ad41	8d 53 06	sta $0653			sta 	gxSpritesOn
.ad44	4a		lsr a				lsr 	a 							; bit 0 into carry.
.ad45	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.ad48	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.ad4a	29 df		and #$df			and 	#$DF 						; clear sprite bit
.ad4c	90 02		bcc $ad50			bcc 	_CSNotOn
.ad4e	09 20		ora #$20			ora 	#$20 						; sprite on if 1 on 0 off
.ad50					_CSNotOn:
.ad50	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.ad53	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.ad55	d0 02		bne $ad59			bne 	_CSNotDefault
.ad57	a9 18		lda #$18			lda 	#24  						; if zero, use 24 e.g. sprites at $30000
.ad59					_CSNotDefault:
.ad59	8d 56 06	sta $0656			sta 	gxSpritePage
.ad5c	20 7c ad	jsr $ad7c			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.ad5f	a5 36		lda $36				lda 	zTemp0
.ad61	8d 61 06	sta $0661			sta 	GXSpriteOffsetBase
.ad64	a5 37		lda $37				lda 	zTemp0+1
.ad66	8d 62 06	sta $0662			sta 	GXSpriteOffsetBase+1
.ad69	a2 00		ldx #$00			ldx 	#0 							; disable all sprites, clears all sprite memory.
.ad6b					_CSClear:
.ad6b	9e 00 d9	stz $d900,x			stz 	$D900,x
.ad6e	9e 00 da	stz $da00,x			stz 	$DA00,x
.ad71	ca		dex				dex
.ad72	d0 f7		bne $ad6b			bne 	_CSClear
.ad74	9c 60 06	stz $0660			stz 	GSCurrentSpriteAddr+1 		; no sprite selected.
.ad77	20 8a ad	jsr $ad8a			jsr 	GXClearSpriteStore
.ad7a	18		clc				clc
.ad7b	60		rts				rts
.ad7c					GXCalculateBaseAddress:
.ad7c	85 36		sta $36				sta 	gxzTemp0
.ad7e	64 37		stz $37				stz 	gxzTemp0+1
.ad80	a9 05		lda #$05			lda 	#5
.ad82					_GXShift:
.ad82	06 36		asl $36				asl 	gxzTemp0
.ad84	26 37		rol $37				rol 	gxzTemp0+1
.ad86	3a		dec a				dec		a
.ad87	d0 f9		bne $ad82			bne 	_GXShift
.ad89	60		rts				rts
.ad8a					GXClearSpriteStore:
.ad8a	a2 3f		ldx #$3f			ldx 	#63 						; erase 64 sprite store elements
.ad8c					_GXCSSLoop:
.ad8c	9e a3 06	stz $06a3,x			stz 	GXSpriteHigh,x
.ad8f	a9 80		lda #$80			lda 	#$80 						; set the 'hidden' bit.
.ad91	9d 63 06	sta $0663,x			sta 	GXSpriteLow,x
.ad94	ca		dex				dex
.ad95	10 f5		bpl $ad8c			bpl 	_GXCSSLoop
.ad97	60		rts				rts
.ad98					GXLine:
.ad98	ad 54 06	lda $0654			lda 	GXBitmapsOn
.ad9b	f0 28		beq $adc5			beq 	_GXLFail
.ad9d	20 75 b2	jsr $b275			jsr 	GXOpenBitmap
.ada0	20 bb b3	jsr $b3bb			jsr 	GXSortY						; sort pairs so Y1 >= Y0 e.g. top to bottom.
.ada3	20 6b ae	jsr $ae6b			jsr 	GXLineSetup 				; the calculations in the linescanner constructor
.ada6	20 85 b2	jsr $b285			jsr 	GXPositionCalc 				; calculate position/offset.
.ada9					_GXDrawLoop:
.ada9	ac 5d 06	ldy $065d			ldy 	gsOffset 					; draw the pixel
.adac	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.adae	2d 5b 06	and $065b			and 	gxANDValue
.adb1	4d 5a 06	eor $065a			eor 	gxEORValue
.adb4	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.adb6	20 c7 ad	jsr $adc7			jsr 	GXLineIsComplete 			; is the line complete ?
.adb9	f0 05		beq $adc0			beq 	_GXLExit
.adbb	20 e2 ad	jsr $ade2			jsr 	GXLineAdvance 				; code as per advance method
.adbe	80 e9		bra $ada9			bra 	_GXDrawLoop
.adc0					_GXLExit:
.adc0	20 7d b2	jsr $b27d			jsr 	GXCloseBitmap
.adc3	18		clc				clc
.adc4	60		rts				rts
.adc5					_GXLFail:
.adc5	38		sec				sec
.adc6	60		rts				rts
.adc7					GXLineIsComplete:
.adc7	ad ea 06	lda $06ea			lda 	GXIsDiffYLarger 			; is dy larger
.adca	d0 0f		bne $addb			bne 	_GXLICCompareY 				; if so compare Y1/Y0
.adcc	ad 4b 06	lda $064b			lda 	GXX0 						; compare X, LSB and MSB
.adcf	4d 4f 06	eor $064f			eor 	GXX1
.add2	d0 06		bne $adda			bne 	_GXLICExit
.add4	ad 4c 06	lda $064c			lda 	GXX0+1
.add7	4d 50 06	eor $0650			eor 	GXX1+1
.adda					_GXLICExit:
.adda	60		rts				rts
.addb					_GXLICCompareY:
.addb	ad 51 06	lda $0651			lda 	GXY1
.adde	4d 4d 06	eor $064d			eor 	GXY0
.ade1	60		rts				rts
.ade2					GXLineAdvance:
.ade2	18		clc				clc 								; add adjust to position
.ade3	ad ec 06	lda $06ec			lda 	GXPosition
.ade6	6d ed 06	adc $06ed			adc 	GXAdjust
.ade9	8d ec 06	sta $06ec			sta 	GXPosition
.adec	9c ef 06	stz $06ef			stz 	GXAddSelect 				; clear add select flag
.adef	b0 05		bcs $adf6			bcs 	_GXLAOverflow 				; if carry out, overflowed.
.adf1	cd ee 06	cmp $06ee			cmp 	GXTotal 					; if exceeded total
.adf4	90 0a		bcc $ae00			bcc 	_GXLANoExtra
.adf6					_GXLAOverflow:
.adf6	ce ef 06	dec $06ef			dec 	GXAddSelect 				; set addselect to $FF
.adf9	38		sec				sec 								; subtract total and write back
.adfa	ed ee 06	sbc $06ee			sbc 	GXTotal
.adfd	8d ec 06	sta $06ec			sta 	GXPosition
.ae00					_GXLANoExtra:
.ae00	ad ea 06	lda $06ea			lda 	GXIsDiffYLarger
.ae03	f0 0d		beq $ae12			beq 	_GXDXLarger
.ae05	20 64 ae	jsr $ae64			jsr 	GXIncrementY
.ae08	ad ef 06	lda $06ef			lda 	GXAddSelect
.ae0b	f0 10		beq $ae1d			beq 	_GXLAExit
.ae0d	20 1e ae	jsr $ae1e			jsr 	GXAdjustX
.ae10	80 0b		bra $ae1d			bra 	_GXLAExit
.ae12					_GXDXLarger:
.ae12	20 1e ae	jsr $ae1e			jsr 	GXAdjustX
.ae15	ad ef 06	lda $06ef			lda 	GXAddSelect
.ae18	f0 03		beq $ae1d			beq 	_GXLAExit
.ae1a	20 64 ae	jsr $ae64			jsr 	GXIncrementY
.ae1d					_GXLAExit:
.ae1d	60		rts				rts
.ae1e					GXAdjustX:
.ae1e	ad eb 06	lda $06eb			lda 	GXDXNegative
.ae21	10 25		bpl $ae48			bpl 	_GXAXRight
.ae23	ad 4b 06	lda $064b			lda 	GXX0
.ae26	d0 03		bne $ae2b			bne 	_GXAXNoBorrow
.ae28	ce 4c 06	dec $064c			dec 	GXX0+1
.ae2b					_GXAXNoBorrow:
.ae2b	ce 4b 06	dec $064b			dec 	GXX0
.ae2e	ce 5d 06	dec $065d			dec 	gsOffset 					; pixel left
.ae31	ad 5d 06	lda $065d			lda 	gsOffset
.ae34	c9 ff		cmp #$ff			cmp 	#$FF
.ae36	d0 0f		bne $ae47			bne 	_GXAYExit 					; underflow
.ae38	c6 3d		dec $3d				dec 	gxzScreen+1 					; borrow
.ae3a	a5 3d		lda $3d				lda 	gxzScreen+1 					; gone off page
.ae3c	c9 60		cmp #$60			cmp 	#GXMappingAddress >> 8
.ae3e	b0 07		bcs $ae47			bcs 	_GXAYExit
.ae40	18		clc				clc
.ae41	69 20		adc #$20			adc 	#$20 						; fix up
.ae43	85 3d		sta $3d				sta 	gxzScreen+1
.ae45	c6 0b		dec $0b				dec 	GXEditSlot 				; back one page
.ae47					_GXAYExit:
.ae47	60		rts				rts
.ae48					_GXAXRight:
.ae48	ee 4b 06	inc $064b			inc 	GXX0
.ae4b	d0 03		bne $ae50			bne 	_GXAXNoCarry
.ae4d	ee 4c 06	inc $064c			inc 	GXX0+1
.ae50					_GXAXNoCarry:
.ae50	ee 5d 06	inc $065d			inc 	gsOffset 					; pixel right
.ae53	d0 0e		bne $ae63			bne 	_GXAXExit 					; if not overflowed, exit.
.ae55	e6 3d		inc $3d				inc 	gxzScreen+1 					; next line
.ae57	a5 3d		lda $3d				lda 	gxzScreen+1
.ae59	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.ae5b	90 06		bcc $ae63			bcc 	_GXAXExit
.ae5d	e9 20		sbc #$20			sbc 	#$20 						; fix up
.ae5f	85 3d		sta $3d				sta 	gxzScreen+1
.ae61	e6 0b		inc $0b				inc 	GXEditSlot 				; next page
.ae63					_GXAXExit:
.ae63	60		rts				rts
.ae64					GXIncrementY:
.ae64	ee 4d 06	inc $064d			inc 	GXY0
.ae67	20 db b2	jsr $b2db			jsr 	GXMovePositionDown
.ae6a	60		rts				rts
.ae6b					GXLineSetup:
.ae6b	ad 51 06	lda $0651			lda 	GXY1
.ae6e	38		sec				sec
.ae6f	ed 4d 06	sbc $064d			sbc 	GXY0
.ae72	4a		lsr a				lsr 	a
.ae73	8d e9 06	sta $06e9			sta 	GXDiffY
.ae76	9c eb 06	stz $06eb			stz 	GXDXNegative 				; clear -ve flag
.ae79	38		sec				sec
.ae7a	ad 4f 06	lda $064f			lda 	GXX1
.ae7d	ed 4b 06	sbc $064b			sbc 	GXX0
.ae80	8d e8 06	sta $06e8			sta 	GXDiffX
.ae83	ad 50 06	lda $0650			lda 	GXX1+1 						; calculate MSB
.ae86	ed 4c 06	sbc $064c			sbc 	GXX0+1
.ae89	6a		ror a				ror 	a 							; rotate bit into DiffX halving it
.ae8a	6e e8 06	ror $06e8			ror 	GXDiffX
.ae8d	0a		asl a				asl 	a
.ae8e	10 0c		bpl $ae9c			bpl 	_GDXNotNegative
.ae90	a9 00		lda #$00			lda 	#0 							; make absolute value of |dx|
.ae92	38		sec				sec
.ae93	ed e8 06	sbc $06e8			sbc 	GXDiffX
.ae96	8d e8 06	sta $06e8			sta 	GXDiffX
.ae99	ce eb 06	dec $06eb			dec 	GXDXNegative 				; -ve flag = $FF.
.ae9c					_GDXNotNegative:
.ae9c	9c ea 06	stz $06ea			stz 	GXIsDiffYLarger 			; clear larger flag
.ae9f	ad e9 06	lda $06e9			lda 	GXDiffY 					; set adjust and total.
.aea2	8d ed 06	sta $06ed			sta 	GXAdjust
.aea5	ad e8 06	lda $06e8			lda 	GXDiffX
.aea8	8d ee 06	sta $06ee			sta 	GXTotal
.aeab	ad e9 06	lda $06e9			lda 	GXDiffY 					; if dy > dx
.aeae	cd e8 06	cmp $06e8			cmp 	GXDiffX
.aeb1	90 0f		bcc $aec2			bcc 	_GDXNotLarger
.aeb3	ce ea 06	dec $06ea			dec 	GXIsDiffYLarger 			; set the dy larger flag
.aeb6	ad e8 06	lda $06e8			lda 	GXDiffX 					; set adjust and total other way round
.aeb9	8d ed 06	sta $06ed			sta 	GXAdjust
.aebc	ad e9 06	lda $06e9			lda 	GXDiffY
.aebf	8d ee 06	sta $06ee			sta 	GXTotal
.aec2					_GDXNotLarger:
.aec2	ad ee 06	lda $06ee			lda 	GXTotal
.aec5	4a		lsr a				lsr 	a
.aec6	8d ec 06	sta $06ec			sta 	GXPosition
.aec9	60		rts				rts
.06e8					GXDiffX:
>06e8							.fill 	1
.06e9					GXDiffY:
>06e9							.fill 	1
.06ea					GXIsDiffYLarger:
>06ea							.fill 	1
.06eb					GXDXNegative:
>06eb							.fill 	1
.06ec					GXPosition:
>06ec							.fill 	1
.06ed					GXAdjust:
>06ed							.fill 	1
.06ee					GXTotal:
>06ee							.fill 	1
.06ef					GXAddSelect:
>06ef							.fill 	1
.aeca					GXSetColourMode:
.aeca	a6 36		ldx $36				ldx 	gxzTemp0
.aecc	8e 59 06	stx $0659			stx 	gxColour 								; set colour
.aecf	a5 37		lda $37				lda 	gxzTemp0+1 								;
.aed1	8d 58 06	sta $0658			sta 	gxMode 									; set mode
.aed4	29 03		and #$03			and 	#3 										; only interested in bits 0-3
.aed6	9c 5b 06	stz $065b			stz 	gxANDValue 								; initially AND with 0, and EOR with Colour
.aed9	ae 59 06	ldx $0659			ldx 	gxColour
.aedc	8e 5a 06	stx $065a			stx 	gxEORValue
.aedf	c9 02		cmp #$02			cmp 	#2 										; if mode 2/3 And with colour
.aee1	90 03		bcc $aee6			bcc 	_GXSDCNotAndColour
.aee3	8e 5b 06	stx $065b			stx 	gxANDValue
.aee6					_GXSDCNotAndColour:
.aee6	d0 03		bne $aeeb			bne 	_GXSDCNotAnd 							; mode 2, Don't EOR with colour
.aee8	9c 5a 06	stz $065a			stz 	gxEORValue
.aeeb					_GXSDCNotAnd:
.aeeb	4a		lsr a				lsr 	a 										; if bit 0 set, 1's complement AND value
.aeec	90 08		bcc $aef6			bcc 	_GXSDCNoFlip
.aeee	ad 5b 06	lda $065b			lda	 	gxANDValue
.aef1	49 ff		eor #$ff			eor 	#$FF
.aef3	8d 5b 06	sta $065b			sta 	gxANDValue
.aef6					_GXSDCNoFlip:
.aef6	18		clc				clc
.aef7	60		rts				rts
.aef8					GXPlotPoint:
.aef8	20 75 b2	jsr $b275			jsr 	GXOpenBitmap 				; start drawing
.aefb	20 85 b2	jsr $b285			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.aefe	ac 5d 06	ldy $065d			ldy 	gsOffset
.af01	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.af03	2d 5b 06	and $065b			and 	gxANDValue
.af06	4d 5a 06	eor $065a			eor 	gxEORValue
.af09	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.af0b	20 7d b2	jsr $b27d			jsr 	GXCloseBitmap 				; stop drawing and exit
.af0e	18		clc				clc
.af0f	60		rts				rts
.af10					GXFillRectangle:
.af10	38		sec				sec
.af11	80 01		bra $af14			bra 	GXRectangle
.af13					GXFrameRectangle:
.af13	18		clc				clc
.af14					GXRectangle:
.af14	ad 54 06	lda $0654			lda 	gxBitmapsOn
.af17	f0 35		beq $af4e			beq 	_GXRFail
.af19	08		php				php 								; save Fill flag (CS)
.af1a	20 75 b2	jsr $b275			jsr 	GXOpenBitmap 				; start drawing
.af1d	20 9d b3	jsr $b39d			jsr 	GXSortXY 					; sort both X and Y so top left/bottom right
.af20	20 85 b2	jsr $b285			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.af23	38		sec				sec 								; sec = Draw line
.af24	20 50 af	jsr $af50			jsr 	GXDrawLineX1X0 				; draw a line length X1-X0
.af27	ad 4d 06	lda $064d			lda 	gxY0 						; reached end of rectangle ?
.af2a	cd 51 06	cmp $0651			cmp 	gxY1
.af2d	f0 19		beq $af48			beq 	_GXRectangleExit
.af2f					_GXRectLoop:
.af2f	20 db b2	jsr $b2db			jsr 	GXMovePositionDown 			; down one.
.af32	ee 4d 06	inc $064d			inc 	gxY0 						; change Y pos
.af35	ad 4d 06	lda $064d			lda 	gxY0 						; reached last line
.af38	cd 51 06	cmp $0651			cmp 	gXY1
.af3b	f0 07		beq $af44			beq 	_GXLastLine
.af3d	28		plp				plp 								; get flag back
.af3e	08		php				php
.af3f	20 50 af	jsr $af50			jsr 	GXDrawLineX1X0 				; draw horizontal line
.af42	80 eb		bra $af2f			bra 	_GXRectLoop
.af44					_GXLastLine:
.af44	38		sec				sec
.af45	20 50 af	jsr $af50			jsr 	GXDrawLineX1X0
.af48					_GXRectangleExit:
.af48	68		pla				pla 								; throw fill flag.
.af49	20 7d b2	jsr $b27d			jsr 	GXCloseBitmap 				; stop drawing and exit
.af4c	18		clc				clc
.af4d	60		rts				rts
.af4e					_GXRFail:
.af4e	38		sec				sec
.af4f	60		rts				rts
.af50					GXDrawLineX1X0:
.af50	08		php				php 								; save solid/either-end
.af51	38		sec				sec
.af52	ad 4f 06	lda $064f			lda		gXX1
.af55	ed 4b 06	sbc $064b			sbc 	gXX0
.af58	85 36		sta $36				sta 	gxzTemp0
.af5a	ad 50 06	lda $0650			lda 	gXX1+1
.af5d	ed 4c 06	sbc $064c			sbc 	gXX0+1
.af60	85 37		sta $37				sta 	gxzTemp0+1
.af62	28		plp				plp
.af63					GXDrawLineTemp0:
.af63	a5 3c		lda $3c				lda 	gxzScreen 						; push gxzScreen, gsOffset and GXEditSlot on stack
.af65	48		pha				pha
.af66	a5 3d		lda $3d				lda 	gxzScreen+1
.af68	48		pha				pha
.af69	ad 5d 06	lda $065d			lda 	gsOffset
.af6c	48		pha				pha
.af6d	a5 0b		lda $0b				lda 	GXEditSlot
.af6f	48		pha				pha
.af70	ac 5d 06	ldy $065d			ldy 	gsOffset 					; Y offset
.af73	90 1e		bcc $af93			bcc 	_GXDLTEndPoints 			; if CC draw end points only.
.af75					_GXDLTLine:
.af75	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.af77	2d 5b 06	and $065b			and 	gxANDValue
.af7a	4d 5a 06	eor $065a			eor 	gxEORValue
.af7d	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.af7f	a5 36		lda $36				lda 	gxzTemp0 					; decrement counter
.af81	d0 04		bne $af87			bne 	_GXDLTNoBorrow
.af83	c6 37		dec $37				dec 	gxzTemp0+1 					; borrow, if goes -ve then exit
.af85	30 2e		bmi $afb5			bmi 	_GXDLTExit
.af87					_GXDLTNoBorrow:
.af87	c6 36		dec $36				dec 	gxzTemp0
.af89	c8		iny				iny 								; next slot.
.af8a	d0 e9		bne $af75			bne 	_GXDLTLine
.af8c	e6 3d		inc $3d				inc 	gxzScreen+1 					; carry to next
.af8e	20 c3 af	jsr $afc3			jsr 	GXDLTCheckWrap				; check for new page.
.af91	80 e2		bra $af75			bra 	_GXDLTLine
.af93					_GXDLTEndPoints:
.af93	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.af95	2d 5b 06	and $065b			and 	gxANDValue
.af98	4d 5a 06	eor $065a			eor 	gxEORValue
.af9b	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.af9d	98		tya				tya 								; advance to right side
.af9e	18		clc				clc
.af9f	65 36		adc $36				adc 	gxzTemp0
.afa1	a8		tay				tay
.afa2	a5 3d		lda $3d				lda 	gxzScreen+1
.afa4	65 37		adc $37				adc 	gxzTemp0+1
.afa6	85 3d		sta $3d				sta 	gxzScreen+1
.afa8	20 c3 af	jsr $afc3			jsr 	GXDLTCheckWrap 			; fix up.
.afab	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.afad	2d 5b 06	and $065b			and 	gxANDValue
.afb0	4d 5a 06	eor $065a			eor 	gxEORValue
.afb3	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.afb5					_GXDLTExit:
.afb5	68		pla				pla
.afb6	85 0b		sta $0b				sta 	GXEditSlot
.afb8	68		pla				pla
.afb9	8d 5d 06	sta $065d			sta 	gsOffset
.afbc	68		pla				pla
.afbd	85 3d		sta $3d				sta 	gxzScreen+1
.afbf	68		pla				pla
.afc0	85 3c		sta $3c				sta 	gxzScreen
.afc2	60		rts				rts
.afc3					GXDLTCheckWrap:
.afc3	a5 3d		lda $3d				lda 	gxzScreen+1 					; check end of page
.afc5	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8)
.afc7	90 06		bcc $afcf			bcc 	_GXDLTCWExit
.afc9	e9 20		sbc #$20			sbc 	#$20 						; fix up
.afcb	85 3d		sta $3d				sta 	gxzScreen+1
.afcd	e6 0b		inc $0b				inc 	GXEditSlot
.afcf					_GXDLTCWExit:
.afcf	60		rts				rts
.afd0					GXDrawGraphicElement:
.afd0	8d f0 06	sta $06f0			sta 	gxSize 						; save size
.afd3	3a		dec a				dec 	a
.afd4	8d f1 06	sta $06f1			sta 	gxMask 						; and mask
.afd7	ad 54 06	lda $0654			lda 	gxBitmapsOn 				; check BMP on
.afda	f0 67		beq $b043			beq 	_GXSLFail
.afdc	ad 4d 06	lda $064d			lda 	gxY0 						; push Y on stack
.afdf	48		pha				pha
.afe0	8c f3 06	sty $06f3			sty 	gxAcquireVector+1 			; and acquisition vector
.afe3	8e f2 06	stx $06f2			stx 	gxAcquireVector
.afe6	20 75 b2	jsr $b275			jsr 	gxOpenBitmap 				; open the bitmap.
.afe9	ad f5 06	lda $06f5			lda 	gxUseMode 					; scale bits
.afec	4a		lsr a				lsr 	a
.afed	4a		lsr a				lsr 	a
.afee	4a		lsr a				lsr 	a
.afef	29 07		and #$07			and		#7
.aff1	1a		inc a				inc 	a
.aff2	8d f4 06	sta $06f4			sta 	gxScale
.aff5	64 38		stz $38				stz 	gxzTemp1					; start first line
.aff7					_GXGELoop:
.aff7	a5 38		lda $38				lda 	gxzTemp1 					; current line number to read.
.aff9	2c f5 06	bit $06f5			bit 	gxUseMode 					; check for flip.
.affc	10 06		bpl $b004			bpl		_GXNoVFlip
.affe	ad f1 06	lda $06f1			lda 	gxMask
.b001	38		sec				sec
.b002	e5 38		sbc $38				sbc 	gxzTemp1
.b004					_GXNoVFlip:
.b004	aa		tax				tax 								; get the Xth line.
.b005	20 45 b0	jsr $b045			jsr 	_GXCallAcquire 				; get that data.
.b008	ad f4 06	lda $06f4			lda 	gxScale 					; do scale identical copies of that line.
.b00b	85 39		sta $39				sta 	gxzTemp1+1
.b00d					_GXGELoop2:
.b00d	ad 4d 06	lda $064d			lda 	gxY0 						; off screen
.b010	cd 57 06	cmp $0657			cmp 	gxHeight
.b013	b0 10		bcs $b025			bcs 	_GXDGEExit
.b015	20 48 b0	jsr $b048			jsr 	GXRenderOneLine 			; render line
.b018	c6 39		dec $39				dec 	gxzTemp1+1 					; scale times.
.b01a	d0 f1		bne $b00d			bne 	_GXGELoop2
.b01c	e6 38		inc $38				inc 	gxzTemp1 					; done all lines.
.b01e	a5 38		lda $38				lda 	gxzTemp1
.b020	cd f0 06	cmp $06f0			cmp 	gxSize
.b023	d0 d2		bne $aff7			bne 	_GXGELoop
.b025					_GXDGEExit:
.b025	68		pla				pla 								; restore Y for next time
.b026	8d 4d 06	sta $064d			sta 	gxY0
.b029	ae f4 06	ldx $06f4			ldx 	gxScale 					; get scale (1-8)
.b02c					_GXShiftLeft:
.b02c	18		clc				clc
.b02d	ad f0 06	lda $06f0			lda 	gxSize
.b030	6d 4b 06	adc $064b			adc 	gxX0
.b033	8d 4b 06	sta $064b			sta 	gxX0
.b036	90 03		bcc $b03b			bcc 	_GXSLNoCarry
.b038	ee 4c 06	inc $064c			inc 	gxX0+1
.b03b					_GXSLNoCarry:
.b03b	ca		dex				dex
.b03c	d0 ee		bne $b02c			bne 	_GXShiftLeft
.b03e	20 7d b2	jsr $b27d			jsr 	GXCloseBitmap
.b041	18		clc				clc
.b042	60		rts				rts
.b043					_GXSLFail:
.b043	38		sec				sec
.b044	60		rts				rts
.b045					_GXCallAcquire:
.b045	6c f2 06	jmp ($06f2)			jmp 	(gxAcquireVector)
.b048					GXRenderOneLine:
.b048	20 85 b2	jsr $b285			jsr 	GXPositionCalc 				; calculate position/offset.
.b04b	ac 5d 06	ldy $065d			ldy 	gsOffset 					; Y contains position.
.b04e	64 3a		stz $3a				stz 	gxzTemp2 					; do size pixels
.b050					_GXROLLoop1:
.b050	ad f4 06	lda $06f4			lda 	gxScale 					; set to do 'scale' times
.b053	85 3b		sta $3b				sta 	gxzTemp2+1
.b055					_GXROLLoop2:
.b055	a5 3a		lda $3a				lda 	gxzTemp2 					; get current pixel
.b057	2c 58 06	bit $0658			bit 	gxMode 						; check H Flip
.b05a	50 06		bvc $b062			bvc 	_GXNoHFlip
.b05c	ad f1 06	lda $06f1			lda 	gxMask
.b05f	38		sec				sec
.b060	e5 3a		sbc $3a				sbc 	gxzTemp2
.b062					_GXNoHFlip:
.b062	aa		tax				tax 								; read from the pixel buffer
.b063	bd f9 05	lda $05f9,x			lda 	gxPixelBuffer,x
.b066	d0 07		bne $b06f			bne 	_GXDraw 					; draw if non zero
.b068	ad f5 06	lda $06f5			lda 	gxUseMode 					; check to see if solid background
.b06b	29 04		and #$04			and 	#4
.b06d	f0 0a		beq $b079			beq 	_GXZeroPixel
.b06f					_GXDraw:
.b06f	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.b071	2d 5b 06	and $065b			and 	gxANDValue
.b074	5d f9 05	eor $05f9,x			eor 	gxPixelBuffer,x
.b077	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b079					_GXZeroPixel:
.b079	c8		iny				iny 								; advance pointer
.b07a	d0 05		bne $b081			bne 	_GXNoShift
.b07c	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.b07e	20 c3 af	jsr $afc3			jsr 	GXDLTCheckWrap				; check for new page.
.b081					_GXNoShift:
.b081	c6 3b		dec $3b				dec 	gxzTemp2+1 					; do the inner loop gxScale times.
.b083	d0 d0		bne $b055			bne 	_GXROLLoop2
.b085	e6 3a		inc $3a				inc 	gxzTemp2 					; next pixel.
.b087	a5 3a		lda $3a				lda 	gxzTemp2
.b089	cd f0 06	cmp $06f0			cmp 	gxSize
.b08c	d0 c2		bne $b050			bne 	_GXROLLoop1
.b08e	ee 4d 06	inc $064d			inc 	gxY0
.b091	60		rts				rts
.06f0					gxSize:
>06f0							.fill 	1
.06f1					gxMask:
>06f1							.fill 	1
.06f2					gxAcquireVector:
>06f2							.fill 	2
.06f4					gxScale:
>06f4							.fill 	1
.06f5					gxUseMode:
>06f5							.fill 	1
.b092					GXFontHandler:
.b092	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b094	4d 58 06	eor $0658			eor 	gxMode
.b097	8d f5 06	sta $06f5			sta 	gxUseMode
.b09a	64 37		stz $37				stz 	gxzTemp0+1 					; gxzTemp0 is font #
.b09c	06 36		asl $36				asl	 	gxzTemp0 					; x 2
.b09e	26 37		rol $37				rol	 	gxzTemp0+1
.b0a0	06 36		asl $36				asl	 	gxzTemp0 					; x 4
.b0a2	26 37		rol $37				rol	 	gxzTemp0+1
.b0a4	06 36		asl $36				asl	 	gxzTemp0 					; x 8
.b0a6	26 37		rol $37				rol	 	gxzTemp0+1
.b0a8	a5 37		lda $37				lda 	gxzTemp0+1 					; put in page C0
.b0aa	09 c0		ora #$c0			ora 	#$C0
.b0ac	85 37		sta $37				sta 	gxzTemp0+1
.b0ae	a9 08		lda #$08			lda 	#8 							; size 8x8
.b0b0	a2 b8		ldx #$b8			ldx 	#GXGetGraphicDataFont & $FF ; XY = Graphic Data retrieval routine
.b0b2	a0 b0		ldy #$b0			ldy 	#GXGetGraphicDataFont >> 8
.b0b4	20 d0 af	jsr $afd0			jsr 	GXDrawGraphicElement
.b0b7	60		rts				rts
.b0b8					GXGetGraphicDataFont:
.b0b8	8a		txa				txa 								; X->Y
.b0b9	a8		tay				tay
.b0ba	a6 01		ldx $01				ldx 	1 							; preserve old value
.b0bc	a9 01		lda #$01			lda 	#1 							; access page 1 (font memory)
.b0be	85 01		sta $01				sta 	1
.b0c0	b1 36		lda ($36),y			lda 	(gxzTemp0),y 				; read the font element.
.b0c2	86 01		stx $01				stx 	1 							; put old value back.
.b0c4	a2 00		ldx #$00			ldx 	#0 							; do 8 times
.b0c6					_GXExpand:
.b0c6	9e f9 05	stz $05f9,x			stz 	gxPixelBuffer,x 			; zero in pixel buffer
.b0c9	0a		asl a				asl 	a 							; shift bit 7 into C
.b0ca	90 08		bcc $b0d4			bcc 	_GXNoPixel
.b0cc	48		pha				pha 								; if set, set pixel buffer to current colour.
.b0cd	ad 59 06	lda $0659			lda 	gxColour
.b0d0	9d f9 05	sta $05f9,x			sta 	gxPixelBuffer,x
.b0d3	68		pla				pla
.b0d4					_GXNoPixel:
.b0d4	e8		inx				inx 								; do the whole byte.
.b0d5	e0 08		cpx #$08			cpx 	#8
.b0d7	d0 ed		bne $b0c6			bne 	_GXExpand
.b0d9	60		rts				rts
.b0da					GXSpriteHandler:
.b0da	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b0dc	4d 58 06	eor $0658			eor 	gxMode
.b0df	8d f5 06	sta $06f5			sta 	gxUseMode
.b0e2	a6 36		ldx $36				ldx 	gxzTemp0 					; sprite #
.b0e4	da		phx				phx
.b0e5	20 75 b2	jsr $b275			jsr 	GXOpenBitmap 				; can access sprite information
.b0e8	68		pla				pla
.b0e9	20 56 b3	jsr $b356			jsr 	GXFindSprite 				; get the sprite address
.b0ec	08		php				php
.b0ed	20 7d b2	jsr $b27d			jsr 	GXCloseBitmap
.b0f0	28		plp				plp
.b0f1	b0 0a		bcs $b0fd			bcs		_GXSHExit 					; exit if find failed.
.b0f3	ad f6 06	lda $06f6			lda 	GXSizePixels 				; return size
.b0f6	a2 fe		ldx #$fe			ldx 	#GXSpriteAcquire & $FF
.b0f8	a0 b0		ldy #$b0			ldy 	#GXSpriteAcquire >> 8
.b0fa	20 d0 af	jsr $afd0			jsr 	GXDrawGraphicElement
.b0fd					_GXSHExit:
.b0fd	60		rts				rts
.b0fe					GXSpriteAcquire:
.b0fe	ad 56 06	lda $0656			lda 	GXSpritePage				; point to base page
.b101	85 0b		sta $0b				sta 	GXEditSlot
.b103	86 36		stx $36				stx 	zTemp0 						; row number x 1,2,3,4
.b105	a9 00		lda #$00			lda 	#0
.b107	ae f7 06	ldx $06f7			ldx 	GXSizeBits
.b10a					_GXTimesRowNumber:
.b10a	18		clc				clc
.b10b	65 36		adc $36				adc 	zTemp0
.b10d	ca		dex				dex
.b10e	10 fa		bpl $b10a			bpl 	_GXTimesRowNumber
.b110	64 37		stz $37				stz 	gxzTemp0+1
.b112	0a		asl a				asl 	a 							; row x 2,4,6,8
.b113	26 37		rol $37				rol 	gxzTemp0+1
.b115	0a		asl a				asl 	a 							; row x 4,8,12,16
.b116	26 37		rol $37				rol 	gxzTemp0+1
.b118	0a		asl a				asl 	a 							; row x 8,16,24,32
.b119	26 37		rol $37				rol 	gxzTemp0+1
.b11b	85 36		sta $36				sta 	gxzTemp0
.b11d	18		clc				clc 								; add base address.
.b11e	a5 36		lda $36				lda 	gxzTemp0
.b120	6d f9 06	adc $06f9			adc 	GXSpriteOffset
.b123	85 36		sta $36				sta 	gxzTemp0
.b125	a5 37		lda $37				lda 	gxzTemp0+1
.b127	6d fa 06	adc $06fa			adc 	GXSpriteOffset+1
.b12a					_GXSAFindPage:
.b12a	c9 20		cmp #$20			cmp 	#$20 						; on this page
.b12c	90 06		bcc $b134			bcc 	_GXSAFoundPage
.b12e	e9 20		sbc #$20			sbc 	#$20 						; forward one page
.b130	e6 0b		inc $0b				inc 	GXEditSlot
.b132	80 f6		bra $b12a			bra 	_GXSAFindPage
.b134					_GXSAFoundPage:
.b134	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; physical address of page.
.b136	85 37		sta $37				sta 	gxzTemp0+1 					; gxzTemp0 now points to the page
.b138	a0 00		ldy #$00			ldy 	#0
.b13a					_GXSACopyLoop:
.b13a	b1 36		lda ($36),y			lda 	(gxzTemp0),y
.b13c	99 f9 05	sta $05f9,y			sta 	gxPixelBuffer,y
.b13f	c8		iny				iny
.b140	cc f6 06	cpy $06f6			cpy 	GXSizePixels
.b143	d0 f5		bne $b13a			bne 	_GXSACopyLoop
.b145	60		rts				rts
.b146					GXSelect:
.b146	ad 53 06	lda $0653			lda 	gxSpritesOn
.b149	f0 22		beq $b16d			beq 	_GXSFail
.b14b	a5 36		lda $36				lda 	gxzTemp0 					; illegal sprite #
.b14d	c9 40		cmp #$40			cmp 	#64
.b14f	b0 1c		bcs $b16d			bcs 	_GXSFail
.b151	8d 5e 06	sta $065e			sta 	GSCurrentSpriteID
.b154	a4 37		ldy $37				ldy 	gxzTemp0+1 					; control value.
.b156	a9 00		lda #$00			lda  	#0 							; multiply sprite # x 8 => A
.b158	06 36		asl $36				asl 	gxzTemp0
.b15a	06 36		asl $36				asl 	gxzTemp0
.b15c	06 36		asl $36				asl 	gxzTemp0
.b15e	2a		rol a				rol 	a
.b15f	69 d9		adc #$d9			adc 	#$D9 						; sprite area
.b161	8d 60 06	sta $0660			sta 	GSCurrentSpriteAddr+1 		; address to GSCurrentSprite and gxzTemp
.b164	85 37		sta $37				sta 	gxzTemp0+1
.b166	a5 36		lda $36				lda 	gxzTemp0
.b168	8d 5f 06	sta $065f			sta 	GSCurrentSpriteAddr
.b16b	18		clc				clc
.b16c	60		rts				rts
.b16d					_GXSFail:
.b16d	38		sec				sec
.b16e	60		rts				rts
.b16f					GXSelectImage:
.b16f	ad 53 06	lda $0653			lda 	gxSpritesOn
.b172	f0 74		beq $b1e8			beq 	_GXSIFail
.b174	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b177	f0 6f		beq $b1e8			beq 	_GXSIFail 					; (checking the MSB)
.b179	64 01		stz $01				stz 	1
.b17b	a5 37		lda $37				lda 	gxzTemp0+1 					; push show/hide on the stack.
.b17d	d0 6b		bne $b1ea			bne 	_GXSIHide
.b17f	a5 36		lda $36				lda 	gxzTemp0 					; sprite image
.b181	48		pha				pha
.b182	20 75 b2	jsr $b275			jsr 	GXOpenBitmap
.b185	68		pla				pla
.b186	20 56 b3	jsr $b356			jsr 	GXFindSprite
.b189	b0 5a		bcs $b1e5			bcs 	_GXSICloseFail 				; no image
.b18b	a0 01		ldy #$01			ldy 	#1
.b18d	ad 5f 06	lda $065f			lda 	GSCurrentSpriteAddr
.b190	85 36		sta $36				sta 	gxzTemp0
.b192	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr+1
.b195	85 37		sta $37				sta 	gxzTemp0+1
.b197	ad f9 06	lda $06f9			lda 	GXSpriteOffset
.b19a	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b19c	18		clc				clc
.b19d	ad fa 06	lda $06fa			lda 	GXSpriteOffset+1
.b1a0	6d 61 06	adc $0661			adc 	GXSpriteOffsetBase
.b1a3	c8		iny				iny
.b1a4	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b1a6	ad 62 06	lda $0662			lda 	GXSpriteOffsetBase+1
.b1a9	69 00		adc #$00			adc 	#0
.b1ab	c8		iny				iny
.b1ac	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b1ae	ad f7 06	lda $06f7			lda 	GXSizeBits 					; get raw size
.b1b1	49 03		eor #$03			eor 	#3 							; make it right (00=32 etc.)
.b1b3	2a		rol a				rol 	a 							; x 2
.b1b4	0a		asl a				asl 	a 							; x 4
.b1b5	0a		asl a				asl 	a 							; x 8
.b1b6	0a		asl a				asl 	a 							; x 16
.b1b7	0d f8 06	ora $06f8			ora 	GXSpriteLUT 				; Or with LUT
.b1ba	0a		asl a				asl 	a 							; 1 shift
.b1bb	09 01		ora #$01			ora 	#1 							; enable sprite.
.b1bd	92 36		sta ($36)			sta 	(gxzTemp0) 					; and write back
.b1bf	20 7d b2	jsr $b27d			jsr 	GXCloseBitmap
.b1c2	ae 5e 06	ldx $065e			ldx 	GSCurrentSpriteID 			; point to sprite entries.
.b1c5	bd a3 06	lda $06a3,x			lda 	GXSpriteHigh,x 				; clear upper two bits of size
.b1c8	29 3f		and #$3f			and 	#$3F
.b1ca	9d a3 06	sta $06a3,x			sta 	GXSpriteHigh,x
.b1cd	ad f7 06	lda $06f7			lda 	GXSizeBits 					; get bit size
.b1d0	6a		ror a				ror 	a 							; shift into bits 6/7
.b1d1	6a		ror a				ror 	a
.b1d2	6a		ror a				ror 	a
.b1d3	29 c0		and #$c0			and 	#$C0
.b1d5	1d a3 06	ora $06a3,x			ora 	GXSpriteHigh,x 				; put in  upper 2 bits of sprite data
.b1d8	9d a3 06	sta $06a3,x			sta 	GXSpriteHigh,x
.b1db	bd 63 06	lda $0663,x			lda 	GXSpriteLow,x 				; clear hidden flag.
.b1de	29 7f		and #$7f			and 	#$7F
.b1e0	9d 63 06	sta $0663,x			sta 	GXSpriteLow,x
.b1e3	18		clc				clc
.b1e4	60		rts				rts
.b1e5					_GXSICloseFail:
.b1e5	20 7d b2	jsr $b27d			jsr 	GXCloseBitmap
.b1e8					_GXSIFail:
.b1e8	38		sec				sec
.b1e9	60		rts				rts
.b1ea					_GXSIHide:
.b1ea	ad 5f 06	lda $065f			lda 	GSCurrentSpriteAddr  		; get Sprite h/w address and write there
.b1ed	85 36		sta $36				sta 	gxzTemp0
.b1ef	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr+1
.b1f2	85 37		sta $37				sta 	gxzTemp0+1
.b1f4	a9 00		lda #$00			lda 	#0
.b1f6	92 36		sta ($36)			sta 	(gxzTemp0)
.b1f8	ae 5e 06	ldx $065e			ldx 	GSCurrentSpriteID 			; get sprite ID
.b1fb	bd 63 06	lda $0663,x			lda 	GXSpriteLow,x 				; set the hidden bit.
.b1fe	09 80		ora #$80			ora 	#$80
.b200	9d 63 06	sta $0663,x			sta 	GXSpriteLow,x
.b203	18		clc				clc
.b204	60		rts				rts
.b205					GXMoveSprite:
.b205	ad 53 06	lda $0653			lda 	gxSpritesOn
.b208	f0 65		beq $b26f			beq 	_GXSIFail
.b20a	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b20d	f0 60		beq $b26f			beq 	_GXSIFail
.b20f	85 37		sta $37				sta 	gxzTemp0+1
.b211	a0 04		ldy #$04			ldy 	#4
.b213	ad 5f 06	lda $065f			lda 	GSCurrentSpriteAddr
.b216	85 36		sta $36				sta 	gxzTemp0
.b218	ae 5e 06	ldx $065e			ldx 	GSCurrentSpriteID 			; get the size from the upper two bits
.b21b	bd a3 06	lda $06a3,x			lda 	GXSpriteHigh,x
.b21e	2a		rol a				rol 	a	 						; into bits 0,1.
.b21f	2a		rol a				rol 	a
.b220	2a		rol a				rol 	a
.b221	29 03		and #$03			and 	#3
.b223	aa		tax				tax
.b224	bd 71 b2	lda $b271,x			lda 	_GXMSOffset,x 				; get 32-SpriteSize/2
.b227	48		pha				pha
.b228	18		clc				clc
.b229	6d 4b 06	adc $064b			adc 	gxX0						; copy position.
.b22c	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b22e	c8		iny				iny
.b22f	ad 4c 06	lda $064c			lda 	gxX0+1
.b232	69 00		adc #$00			adc 	#0
.b234	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b236	c8		iny				iny
.b237	68		pla				pla
.b238	18		clc				clc
.b239	6d 4d 06	adc $064d			adc 	gxY0
.b23c	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b23e	a9 00		lda #$00			lda 	#0
.b240	69 00		adc #$00			adc 	#0
.b242	c8		iny				iny
.b243	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b245	4e 4c 06	lsr $064c			lsr 	gxX0+1 						; divide X by 4
.b248	6e 4b 06	ror $064b			ror 	gxX0
.b24b	4e 4b 06	lsr $064b			lsr 	gxX0
.b24e	4e 4d 06	lsr $064d			lsr 	gxY0 						; divide Y by 4
.b251	4e 4d 06	lsr $064d			lsr 	gxY0
.b254	ae 5e 06	ldx $065e			ldx 	GSCurrentSpriteID 			; copy X/4 and Y/4 into the status bytes
.b257	bd 63 06	lda $0663,x			lda 	GXSpriteLow,x
.b25a	29 80		and #$80			and 	#$80
.b25c	0d 4b 06	ora $064b			ora 	gxX0
.b25f	9d 63 06	sta $0663,x			sta 	GXSpriteLow,x
.b262	bd a3 06	lda $06a3,x			lda 	GXSpriteHigh,x
.b265	29 c0		and #$c0			and 	#$C0
.b267	0d 4d 06	ora $064d			ora 	gxY0
.b26a	9d a3 06	sta $06a3,x			sta 	GXSpriteHigh,x
.b26d	18		clc				clc
.b26e	60		rts				rts
.b26f					_GXSIFail:
.b26f	38		sec				sec
.b270	60		rts				rts
.b271					_GXMSOffset:
>b271	1c						.byte 	32-8/2
>b272	18						.byte 	32-16/2
>b273	14						.byte 	32-24/2
>b274	10						.byte 	32-32/2
.b275					GXOpenBitmap:
.b275	78		sei				sei 								; no interrupts here
.b276	a5 0b		lda $0b				lda 	GXEditSlot 					; Save the original LUT slot value
.b278	8d 5c 06	sta $065c			sta 	gxOriginalLUTValue
.b27b	58		cli				cli
.b27c	60		rts				rts
.b27d					GXCloseBitmap:
.b27d	78		sei				sei
.b27e	ad 5c 06	lda $065c			lda 	gxOriginalLUTValue 			; restore LUT slot value
.b281	85 0b		sta $0b				sta 	GXEditSlot
.b283	58		cli				cli
.b284	60		rts				rts
.b285					GXPositionCalc:
.b285	a5 36		lda $36				lda 	gxzTemp0 					; save temp memory slot
.b287	48		pha				pha
.b288	ad 4d 06	lda $064d			lda 	GXY0 						; gxzScreen = Y0
.b28b	85 3c		sta $3c				sta 	gxzScreen
.b28d	64 3d		stz $3d				stz 	gxzScreen+1
.b28f	06 3c		asl $3c				asl 	gxzScreen 						; gxzScreen = Y0 * 4
.b291	26 3d		rol $3d				rol 	gxzScreen+1
.b293	06 3c		asl $3c				asl 	gxzScreen
.b295	26 3d		rol $3d				rol 	gxzScreen+1
.b297	18		clc				clc 								; gxzScreen = Y0 * 5, as it's still in A
.b298	65 3c		adc $3c				adc 	gxzScreen
.b29a	85 3c		sta $3c				sta 	gxzScreen
.b29c	90 02		bcc $b2a0			bcc 	_GXPCNoCarry
.b29e	e6 3d		inc $3d				inc 	gxzScreen+1
.b2a0					_GXPCNoCarry:
.b2a0	06 3c		asl $3c				asl 	gxzScreen 						; now Y0 * 10. Needs to be multiplied by another
.b2a2	26 3d		rol $3d				rol 	gxzScreen+1 					; 32. At this point the MSB contains the offset
.b2a4	a5 3d		lda $3d				lda	 	gxzScreen+1 					; so save this in zTemp0 and zero it.
.b2a6	85 36		sta $36				sta 	gxzTemp0
.b2a8	64 3d		stz $3d				stz 	gxzScreen+1
.b2aa	a9 05		lda #$05			lda 	#5 							; now multiply by 32, this puts this in the range 0..8191
.b2ac					_GXPCMultiply32:
.b2ac	06 3c		asl $3c				asl 	gxzScreen
.b2ae	26 3d		rol $3d				rol 	gxzScreen+1
.b2b0	3a		dec a				dec 	a
.b2b1	d0 f9		bne $b2ac			bne 	_GXPCMultiply32
.b2b3	18		clc				clc
.b2b4	ad 4b 06	lda $064b			lda 	GXX0 						; add X to this value, put the result in gsOffset, gxzScreen has to be on a page boundary
.b2b7	65 3c		adc $3c				adc 	gxzScreen
.b2b9	8d 5d 06	sta $065d			sta 	gsOffset
.b2bc	ad 4c 06	lda $064c			lda 	GXX0+1
.b2bf	65 3d		adc $3d				adc 	gxzScreen+1
.b2c1	c9 20		cmp #$20			cmp 	#$20 						; has it overflowed into the next one ?
.b2c3	90 04		bcc $b2c9			bcc 	_GXPCNoOverflow
.b2c5	29 1f		and #$1f			and 	#$1F 						; fix it up
.b2c7	e6 36		inc $36				inc 	gxzTemp0 					; add 1 to the page number
.b2c9					_GXPCNoOverflow:
.b2c9	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; make it the address mapped in.
.b2cb	85 3d		sta $3d				sta 	gxzScreen+1
.b2cd	64 3c		stz $3c				stz 	gxzScreen
.b2cf	18		clc				clc
.b2d0	a5 36		lda $36				lda 	gxzTemp0 					; get the page number
.b2d2	6d 55 06	adc $0655			adc 	gxBasePage 					; by adding the base page
.b2d5	85 0b		sta $0b				sta 	GXEditSlot 				; and map it into memory.
.b2d7	68		pla				pla
.b2d8	85 36		sta $36				sta 	gxzTemp0
.b2da	60		rts				rts
.b2db					GXMovePositionDown:
.b2db	18		clc				clc 								; add 320 to offset/temp+1
.b2dc	ad 5d 06	lda $065d			lda 	gsOffset
.b2df	69 40		adc #$40			adc 	#64
.b2e1	8d 5d 06	sta $065d			sta 	gsOffset
.b2e4	a5 3d		lda $3d				lda 	gxzScreen+1
.b2e6	69 01		adc #$01			adc 	#1
.b2e8	85 3d		sta $3d				sta 	gxzScreen+1
.b2ea	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page
.b2ec	90 07		bcc $b2f5			bcc 	_GXMPDExit
.b2ee	38		sec				sec  								; next page
.b2ef	e9 20		sbc #$20			sbc 	#$20
.b2f1	85 3d		sta $3d				sta 	gxzScreen+1
.b2f3	e6 0b		inc $0b				inc 	GXEditSlot
.b2f5					_GXMPDExit:
.b2f5	60		rts				rts
.b2f6					GXCollide:
.b2f6	a5 36		lda $36				lda 	gxzTemp0 					; check if sprite numbers are legal.
.b2f8	aa		tax				tax
.b2f9	05 37		ora $37				ora 	gxzTemp0+1
.b2fb	29 c0		and #$c0			and 	#$C0
.b2fd	38		sec				sec
.b2fe	d0 53		bne $b353			bne 	_GXCollideFail 				; if either >= 64, fail.
.b300	a4 37		ldy $37				ldy 	gxzTemp0+1 					; at this point X is 1st sprite and Y is 2nd sprite.
.b302	b9 63 06	lda $0663,y			lda 	GXSpriteLow,y 				; check if either hidden bit is set
.b305	1d 63 06	ora $0663,x			ora 	GXSpriteLow,x
.b308	30 48		bmi $b352			bmi 	_GXOkayFail 				; if either hidden, then they cannot collide.
.b30a	18		clc				clc 								; need to calculate sum of sizes.
.b30b	b9 a3 06	lda $06a3,y			lda 	GXSpriteHigh,y
.b30e	7d a3 06	adc $06a3,x			adc 	GXSpriteHigh,x 				; at this point, CS, Bit 6 and 7 contain that sum.
.b311	29 c0		and #$c0			and 	#$C0 					 	; mask off
.b313	6a		ror a				ror 	a 							; 5/6/7
.b314	4a		lsr a				lsr 	a 							; 4/5/6
.b315	4a		lsr a				lsr 	a 							; 3/4/5
.b316	4a		lsr a				lsr 	a 							; 2/3/4
.b317	18		clc				clc
.b318	69 08		adc #$08			adc 	#$08
.b31a	4a		lsr a				lsr 	a 							; adjust because all coordinates are divided by 4 to store.
.b31b	4a		lsr a				lsr 	a
.b31c	85 38		sta $38				sta 	gxzTemp1 					; so the difference between the centres has to be less than this.
.b31e	b9 a3 06	lda $06a3,y			lda 	GXSpriteHigh,y 				; calculate y1-y0
.b321	29 3f		and #$3f			and 	#$3F
.b323	85 39		sta $39				sta 	gxzTemp1+1
.b325	38		sec				sec
.b326	bd a3 06	lda $06a3,x			lda 	GXSpriteHigh,x
.b329	29 3f		and #$3f			and 	#$3F
.b32b	e5 39		sbc $39				sbc 	gxzTemp1+1
.b32d	b0 03		bcs $b332			bcs 	_GXCAbs1 					; calculate |y1-y0|
.b32f	49 ff		eor #$ff			eor 	#$FF
.b331	1a		inc a				inc 	a
.b332					_GXCAbs1:
.b332	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b334	b0 1c		bcs $b352			bcs 	_GXOkayFail
.b336	85 39		sta $39				sta 	gxzTemp1+1 					; save |y1-y0|
.b338	38		sec				sec 								; calculate |x1-x0|
.b339	b9 63 06	lda $0663,y			lda 	GXSpriteLow,y
.b33c	fd 63 06	sbc $0663,x			sbc 	GXSpriteLow,x
.b33f	b0 03		bcs $b344			bcs 	_GXCAbs2
.b341	49 ff		eor #$ff			eor 	#$FF
.b343	1a		inc a				inc 	a
.b344					_GXCAbs2:
.b344	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b346	b0 0a		bcs $b352			bcs 	_GXOkayFail
.b348	c5 39		cmp $39				cmp 	gxzTemp1+1 					; is it less than the previous one.
.b34a	90 02		bcc $b34e			bcc 	_GXCHaveLowest
.b34c	a5 39		lda $39				lda 	gxzTemp1+1 					; if not, that's the smallest difference.
.b34e					_GXCHaveLowest:
.b34e	0a		asl a				asl 	a 							; scale to allow for >> 2
.b34f	0a		asl a				asl 	a
.b350	18		clc				clc
.b351	60		rts				rts
.b352					_GXOkayFail:
.b352	18		clc				clc
.b353					_GXCollideFail:
.b353	a9 ff		lda #$ff			lda 	#$FF
.b355	60		rts				rts
.b356					GXFindSprite:
.b356	aa		tax				tax
.b357	ad 56 06	lda $0656			lda 	GXSpritePage 				; access the base page of the sprite
.b35a	85 0b		sta $0b				sta 	GXEditSlot
.b35c	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; check a valid sprite
.b35f	1d 00 60	ora $6000,x			ora 	GXMappingAddress,x
.b362	f0 33		beq $b397			beq 	_GXFSFail
.b364	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; MSB
.b367	8d fa 06	sta $06fa			sta 	GXSpriteOffset+1
.b36a	bd 00 60	lda $6000,x			lda 	GXMappingAddress,x 			; LSB
.b36d	48		pha				pha 								; save twice
.b36e	48		pha				pha
.b36f	29 03		and #$03			and 	#3 							; get sprite size
.b371	8d f7 06	sta $06f7			sta 	GXSizeBits 					; save raw (0-3)
.b374	aa		tax				tax
.b375	bd 99 b3	lda $b399,x			lda 	_GXFXSSTTable,x 			; read sprite size
.b378	8d f6 06	sta $06f6			sta 	GXSizePixels 					; save (8/16/24/32)
.b37b	68		pla				pla 								; get LUT
.b37c	4a		lsr a				lsr		a
.b37d	4a		lsr a				lsr		a
.b37e	29 03		and #$03			and 	#3
.b380	8d f8 06	sta $06f8			sta 	GXSpriteLUT
.b383	68		pla				pla 								; address, neeeds to be x 4
.b384	29 f0		and #$f0			and 	#$F0
.b386	8d f9 06	sta $06f9			sta 	GXSpriteOffset
.b389	0e f9 06	asl $06f9			asl 	GXSpriteOffset
.b38c	2e fa 06	rol $06fa			rol 	GXSpriteOffset+1
.b38f	0e f9 06	asl $06f9			asl 	GXSpriteOffset
.b392	2e fa 06	rol $06fa			rol 	GXSpriteOffset+1
.b395	18		clc				clc
.b396	60		rts				rts
.b397					_GXFSFail:
.b397	38		sec				sec
.b398	60		rts				rts
.b399					_GXFXSSTTable:
>b399	08 10 18 20					.byte 	8,16,24,32
.06f6					GXSizePixels:
>06f6							.fill 	1
.06f7					GXSizeBits:
>06f7							.fill 	1
.06f8					GXSpriteLUT:
>06f8							.fill 	1
.06f9					GXSpriteOffset:
>06f9							.fill 	2
.b39d					GXSortXY:
.b39d	20 bb b3	jsr $b3bb			jsr 	GXSortY 					; will be sorted on Y now
.b3a0	ad 4b 06	lda $064b			lda 	gxX0 						; compare X0 v X1
.b3a3	cd 4f 06	cmp $064f			cmp 	gxX1
.b3a6	ad 4c 06	lda $064c			lda 	gXX0+1
.b3a9	ed 50 06	sbc $0650			sbc 	gXX1+1
.b3ac	90 0c		bcc $b3ba			bcc 	_GXSXYExit 					; X0 < X1 exit
.b3ae	a2 00		ldx #$00			ldx 	#0 							; swap them over
.b3b0	a0 04		ldy #$04			ldy 	#4
.b3b2	20 cf b3	jsr $b3cf			jsr 	GXSwapXY
.b3b5	e8		inx				inx
.b3b6	c8		iny				iny
.b3b7	20 cf b3	jsr $b3cf			jsr 	GXSwapXY
.b3ba					_GXSXYExit:
.b3ba	60		rts				rts
.b3bb					GXSortY:
.b3bb	ad 4d 06	lda $064d			lda 	gxY0 						; if Y0 >= Y1
.b3be	cd 51 06	cmp $0651			cmp 	gxY1
.b3c1	90 0b		bcc $b3ce			bcc 	_GXSYSorted
.b3c3	a2 03		ldx #$03			ldx 	#3 							; swap 3-0
.b3c5	a0 07		ldy #$07			ldy 	#7 							; with 4-7
.b3c7					_GXSwap1:
.b3c7	20 cf b3	jsr $b3cf			jsr 	GXSwapXY
.b3ca	88		dey				dey
.b3cb	ca		dex				dex
.b3cc	10 f9		bpl $b3c7			bpl 	_GXSwap1
.b3ce					_GXSYSorted:
.b3ce	60		rts				rts
.b3cf					GXSwapXY:
.b3cf	bd 4b 06	lda $064b,x			lda 	gxX0,x
.b3d2	48		pha				pha
.b3d3	b9 4b 06	lda $064b,y			lda 	gxX0,y
.b3d6	9d 4b 06	sta $064b,x			sta 	gxX0,x
.b3d9	68		pla				pla
.b3da	99 4b 06	sta $064b,y			sta 	gxX0,y
.b3dd	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_tokeniser.module

=1					tokeniserIntegrated=1
.ba53					KeywordSet0:
>ba53	00 65					.text	0,$65,""               ; $80 !0:EOF
>ba55	00 58					.text	0,$58,""               ; $81 !1:SH1
>ba57	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>ba59	04 fe 41 42 53 28			.text	4,$fe,"ABS("           ; $83 ABS(
>ba5f	06 93 41 4c 4c 4f 43 28			.text	6,$93,"ALLOC("         ; $84 ALLOC(
>ba67	04 ff 41 53 43 28			.text	4,$ff,"ASC("           ; $85 ASC(
>ba6d	05 29 43 48 52 24 28			.text	5,$29,"CHR$("          ; $86 CHR$(
>ba74	06 aa 45 56 45 4e 54 28			.text	6,$aa,"EVENT("         ; $87 EVENT(
>ba7c	05 6b 46 41 4c 53 45			.text	5,$6b,"FALSE"          ; $88 FALSE
>ba83	05 44 46 52 41 43 28			.text	5,$44,"FRAC("          ; $89 FRAC(
>ba8a	04 0d 48 49 54 28			.text	4,$0d,"HIT("           ; $8a HIT(
>ba90	04 13 49 4e 54 28			.text	4,$13,"INT("           ; $8b INT(
>ba96	06 a7 49 53 56 41 4c 28			.text	6,$a7,"ISVAL("         ; $8c ISVAL(
>ba9e	05 5c 4a 4f 59 42 28			.text	5,$5c,"JOYB("          ; $8d JOYB(
>baa5	05 72 4a 4f 59 58 28			.text	5,$72,"JOYX("          ; $8e JOYX(
>baac	05 73 4a 4f 59 59 28			.text	5,$73,"JOYY("          ; $8f JOYY(
>bab3	06 77 4c 45 46 54 24 28			.text	6,$77,"LEFT$("         ; $90 LEFT$(
>babb	04 07 4c 45 4e 28			.text	4,$07,"LEN("           ; $91 LEN(
>bac1	04 0e 4d 41 58 28			.text	4,$0e,"MAX("           ; $92 MAX(
>bac7	05 26 4d 49 44 24 28			.text	5,$26,"MID$("          ; $93 MID$(
>bace	04 0c 4d 49 4e 28			.text	4,$0c,"MIN("           ; $94 MIN(
>bad4	04 19 4e 4f 54 28			.text	4,$19,"NOT("           ; $95 NOT(
>bada	08 3c 50 4c 41 59 49 4e			.text	8,$3c,"PLAYING("       ; $96 PLAYING(
>bae2	47 28
>bae4	07 e9 52 41 4e 44 4f 4d			.text	7,$e9,"RANDOM("        ; $97 RANDOM(
>baec	28
>baed	07 ca 52 49 47 48 54 24			.text	7,$ca,"RIGHT$("        ; $98 RIGHT$(
>baf5	28
>baf6	04 0c 52 4e 44 28			.text	4,$0c,"RND("           ; $99 RND(
>bafc	04 10 53 47 4e 28			.text	4,$10,"SGN("           ; $9a SGN(
>bb02	04 0e 53 50 43 28			.text	4,$0e,"SPC("           ; $9b SPC(
>bb08	05 45 53 54 52 24 28			.text	5,$45,"STR$("          ; $9c STR$(
>bb0f	06 a9 54 49 4d 45 52 28			.text	6,$a9,"TIMER("         ; $9d TIMER(
>bb17	04 40 54 52 55 45			.text	4,$40,"TRUE"           ; $9e TRUE
>bb1d	04 0b 56 41 4c 28			.text	4,$0b,"VAL("           ; $9f VAL(
>bb23	03 e7 46 4f 52				.text	3,$e7,"FOR"            ; $a0 FOR
>bb28	02 8f 49 46				.text	2,$8f,"IF"             ; $a1 IF
>bb2c	04 34 50 52 4f 43			.text	4,$34,"PROC"           ; $a2 PROC
>bb32	06 c1 52 45 50 45 41 54			.text	6,$c1,"REPEAT"         ; $a3 REPEAT
>bb3a	05 79 57 48 49 4c 45			.text	5,$79,"WHILE"          ; $a4 WHILE
>bb41	05 66 45 4e 44 49 46			.text	5,$66,"ENDIF"          ; $a5 ENDIF
>bb48	07 0b 45 4e 44 50 52 4f			.text	7,$0b,"ENDPROC"        ; $a6 ENDPROC
>bb50	43
>bb51	04 3f 4e 45 58 54			.text	4,$3f,"NEXT"           ; $a7 NEXT
>bb57	04 2f 54 48 45 4e			.text	4,$2f,"THEN"           ; $a8 THEN
>bb5d	05 8c 55 4e 54 49 4c			.text	5,$8c,"UNTIL"          ; $a9 UNTIL
>bb64	04 2e 57 45 4e 44			.text	4,$2e,"WEND"           ; $aa WEND
>bb6a	02 9b 42 59				.text	2,$9b,"BY"             ; $ab BY
>bb6e	04 1c 43 41 4c 4c			.text	4,$1c,"CALL"           ; $ac CALL
>bb74	06 b2 43 49 52 43 4c 45			.text	6,$b2,"CIRCLE"         ; $ad CIRCLE
>bb7c	05 67 43 4c 45 41 52			.text	5,$67,"CLEAR"          ; $ae CLEAR
>bb83	03 e2 43 4c 53				.text	3,$e2,"CLS"            ; $af CLS
>bb88	05 7f 43 4f 4c 4f 52			.text	5,$7f,"COLOR"          ; $b0 COLOR
>bb8f	06 d4 43 4f 4c 4f 55 52			.text	6,$d4,"COLOUR"         ; $b1 COLOUR
>bb97	04 1a 44 41 54 41			.text	4,$1a,"DATA"           ; $b2 DATA
>bb9d	03 da 44 49 4d				.text	3,$da,"DIM"            ; $b3 DIM
>bba2	06 db 44 4f 57 4e 54 4f			.text	6,$db,"DOWNTO"         ; $b4 DOWNTO
>bbaa	04 29 45 4c 53 45			.text	4,$29,"ELSE"           ; $b5 ELSE
>bbb0	04 34 46 52 4f 4d			.text	4,$34,"FROM"           ; $b6 FROM
>bbb6	03 e5 47 46 58				.text	3,$e5,"GFX"            ; $b7 GFX
>bbbb	05 80 47 4f 53 55 42			.text	5,$80,"GOSUB"          ; $b8 GOSUB
>bbc2	04 39 47 4f 54 4f			.text	4,$39,"GOTO"           ; $b9 GOTO
>bbc8	04 24 48 45 52 45			.text	4,$24,"HERE"           ; $ba HERE
>bbce	05 63 49 4d 41 47 45			.text	5,$63,"IMAGE"          ; $bb IMAGE
>bbd5	03 e5 4c 45 54				.text	3,$e5,"LET"            ; $bc LET
>bbda	04 28 4c 49 4e 45			.text	4,$28,"LINE"           ; $bd LINE
>bbe0	05 6b 4c 4f 43 41 4c			.text	5,$6b,"LOCAL"          ; $be LOCAL
>bbe7	03 db 4f 46 46				.text	3,$db,"OFF"            ; $bf OFF
>bbec	02 9d 4f 4e				.text	2,$9d,"ON"             ; $c0 ON
>bbf0	07 20 4f 55 54 4c 49 4e			.text	7,$20,"OUTLINE"        ; $c1 OUTLINE
>bbf8	45
>bbf9	07 0f 50 41 4c 45 54 54			.text	7,$0f,"PALETTE"        ; $c2 PALETTE
>bc01	45
>bc02	04 3f 50 4c 4f 54			.text	4,$3f,"PLOT"           ; $c3 PLOT
>bc08	05 8d 50 52 49 4e 54			.text	5,$8d,"PRINT"          ; $c4 PRINT
>bc0f	04 1c 52 45 41 44			.text	4,$1c,"READ"           ; $c5 READ
>bc15	04 2e 52 45 43 54			.text	4,$2e,"RECT"           ; $c6 RECT
>bc1b	03 e4 52 45 4d				.text	3,$e4,"REM"            ; $c7 REM
>bc20	06 e0 52 45 54 55 52 4e			.text	6,$e0,"RETURN"         ; $c8 RETURN
>bc28	05 7b 53 4f 4c 49 44			.text	5,$7b,"SOLID"          ; $c9 SOLID
>bc2f	05 89 53 4f 55 4e 44			.text	5,$89,"SOUND"          ; $ca SOUND
>bc36	06 d7 53 50 52 49 54 45			.text	6,$d7,"SPRITE"         ; $cb SPRITE
>bc3e	04 45 54 45 58 54			.text	4,$45,"TEXT"           ; $cc TEXT
>bc44	02 a3 54 4f				.text	2,$a3,"TO"             ; $cd TO
>bc48	ff					.text	$FF
.bc49					KeywordSet1:
>bc49	00 65					.text	0,$65,""               ; $80 !0:EOF
>bc4b	00 58					.text	0,$58,""               ; $81 !1:SH1
>bc4d	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bc4f	08 4c 41 53 53 45 4d 42			.text	8,$4c,"ASSEMBLE"       ; $83 ASSEMBLE
>bc57	4c 45
>bc59	06 d2 41 53 53 45 52 54			.text	6,$d2,"ASSERT"         ; $84 ASSERT
>bc61	06 bd 42 49 54 4d 41 50			.text	6,$bd,"BITMAP"         ; $85 BITMAP
>bc69	03 d7 45 4e 44				.text	3,$d7,"END"            ; $86 END
>bc6e	04 3c 4c 49 53 54			.text	4,$3c,"LIST"           ; $87 LIST
>bc74	03 ea 4e 45 57				.text	3,$ea,"NEW"            ; $88 NEW
>bc79	07 24 52 45 53 54 4f 52			.text	7,$24,"RESTORE"        ; $89 RESTORE
>bc81	45
>bc82	03 f5 52 55 4e				.text	3,$f5,"RUN"            ; $8a RUN
>bc87	07 2a 53 50 52 49 54 45			.text	7,$2a,"SPRITES"        ; $8b SPRITES
>bc8f	53
>bc90	04 46 53 54 4f 50			.text	4,$46,"STOP"           ; $8c STOP
>bc96	ff					.text	$FF
.bc97					KeywordSet2:
>bc97	00 65					.text	0,$65,""               ; $80 !0:EOF
>bc99	00 58					.text	0,$58,""               ; $81 !1:SH1
>bc9b	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bc9d	03 c8 41 44 43				.text	3,$c8,"ADC"            ; $83 ADC
>bca2	03 d3 41 4e 44				.text	3,$d3,"AND"            ; $84 AND
>bca7	03 e0 41 53 4c				.text	3,$e0,"ASL"            ; $85 ASL
>bcac	03 c8 42 43 43				.text	3,$c8,"BCC"            ; $86 BCC
>bcb1	03 d8 42 43 53				.text	3,$d8,"BCS"            ; $87 BCS
>bcb6	03 d8 42 45 51				.text	3,$d8,"BEQ"            ; $88 BEQ
>bcbb	03 df 42 49 54				.text	3,$df,"BIT"            ; $89 BIT
>bcc0	03 d8 42 4d 49				.text	3,$d8,"BMI"            ; $8a BMI
>bcc5	03 d5 42 4e 45				.text	3,$d5,"BNE"            ; $8b BNE
>bcca	03 de 42 50 4c				.text	3,$de,"BPL"            ; $8c BPL
>bccf	03 d5 42 52 41				.text	3,$d5,"BRA"            ; $8d BRA
>bcd4	03 df 42 52 4b				.text	3,$df,"BRK"            ; $8e BRK
>bcd9	03 db 42 56 43				.text	3,$db,"BVC"            ; $8f BVC
>bcde	03 eb 42 56 53				.text	3,$eb,"BVS"            ; $90 BVS
>bce3	03 d2 43 4c 43				.text	3,$d2,"CLC"            ; $91 CLC
>bce8	03 d3 43 4c 44				.text	3,$d3,"CLD"            ; $92 CLD
>bced	03 d8 43 4c 49				.text	3,$d8,"CLI"            ; $93 CLI
>bcf2	03 e5 43 4c 56				.text	3,$e5,"CLV"            ; $94 CLV
>bcf7	03 e0 43 4d 50				.text	3,$e0,"CMP"            ; $95 CMP
>bcfc	03 eb 43 50 58				.text	3,$eb,"CPX"            ; $96 CPX
>bd01	03 ec 43 50 59				.text	3,$ec,"CPY"            ; $97 CPY
>bd06	03 cc 44 45 43				.text	3,$cc,"DEC"            ; $98 DEC
>bd0b	03 e1 44 45 58				.text	3,$e1,"DEX"            ; $99 DEX
>bd10	03 e2 44 45 59				.text	3,$e2,"DEY"            ; $9a DEY
>bd15	03 e6 45 4f 52				.text	3,$e6,"EOR"            ; $9b EOR
>bd1a	03 da 49 4e 43				.text	3,$da,"INC"            ; $9c INC
>bd1f	03 ef 49 4e 58				.text	3,$ef,"INX"            ; $9d INX
>bd24	03 f0 49 4e 59				.text	3,$f0,"INY"            ; $9e INY
>bd29	03 e7 4a 4d 50				.text	3,$e7,"JMP"            ; $9f JMP
>bd2e	03 ef 4a 53 52				.text	3,$ef,"JSR"            ; $a0 JSR
>bd33	03 d1 4c 44 41				.text	3,$d1,"LDA"            ; $a1 LDA
>bd38	03 e8 4c 44 58				.text	3,$e8,"LDX"            ; $a2 LDX
>bd3d	03 e9 4c 44 59				.text	3,$e9,"LDY"            ; $a3 LDY
>bd42	03 f1 4c 53 52				.text	3,$f1,"LSR"            ; $a4 LSR
>bd47	03 ed 4e 4f 50				.text	3,$ed,"NOP"            ; $a5 NOP
>bd4c	03 e2 4f 52 41				.text	3,$e2,"ORA"            ; $a6 ORA
>bd51	03 d9 50 48 41				.text	3,$d9,"PHA"            ; $a7 PHA
>bd56	03 e8 50 48 50				.text	3,$e8,"PHP"            ; $a8 PHP
>bd5b	03 f0 50 48 58				.text	3,$f0,"PHX"            ; $a9 PHX
>bd60	03 f1 50 48 59				.text	3,$f1,"PHY"            ; $aa PHY
>bd65	03 dd 50 4c 41				.text	3,$dd,"PLA"            ; $ab PLA
>bd6a	03 ec 50 4c 50				.text	3,$ec,"PLP"            ; $ac PLP
>bd6f	03 f4 50 4c 58				.text	3,$f4,"PLX"            ; $ad PLX
>bd74	03 f5 50 4c 59				.text	3,$f5,"PLY"            ; $ae PLY
>bd79	03 ed 52 4f 4c				.text	3,$ed,"ROL"            ; $af ROL
>bd7e	03 f3 52 4f 52				.text	3,$f3,"ROR"            ; $b0 ROR
>bd83	03 ef 52 54 49				.text	3,$ef,"RTI"            ; $b1 RTI
>bd88	03 f9 52 54 53				.text	3,$f9,"RTS"            ; $b2 RTS
>bd8d	03 d8 53 42 43				.text	3,$d8,"SBC"            ; $b3 SBC
>bd92	03 db 53 45 43				.text	3,$db,"SEC"            ; $b4 SEC
>bd97	03 dc 53 45 44				.text	3,$dc,"SED"            ; $b5 SED
>bd9c	03 e1 53 45 49				.text	3,$e1,"SEI"            ; $b6 SEI
>bda1	03 e8 53 54 41				.text	3,$e8,"STA"            ; $b7 STA
>bda6	03 f7 53 54 50				.text	3,$f7,"STP"            ; $b8 STP
>bdab	03 ff 53 54 58				.text	3,$ff,"STX"            ; $b9 STX
>bdb0	03 00 53 54 59				.text	3,$00,"STY"            ; $ba STY
>bdb5	03 01 53 54 5a				.text	3,$01,"STZ"            ; $bb STZ
>bdba	03 ed 54 41 58				.text	3,$ed,"TAX"            ; $bc TAX
>bdbf	03 ee 54 41 59				.text	3,$ee,"TAY"            ; $bd TAY
>bdc4	03 e8 54 52 42				.text	3,$e8,"TRB"            ; $be TRB
>bdc9	03 e9 54 53 42				.text	3,$e9,"TSB"            ; $bf TSB
>bdce	03 ff 54 53 58				.text	3,$ff,"TSX"            ; $c0 TSX
>bdd3	03 ed 54 58 41				.text	3,$ed,"TXA"            ; $c1 TXA
>bdd8	03 ff 54 58 53				.text	3,$ff,"TXS"            ; $c2 TXS
>bddd	03 ee 54 59 41				.text	3,$ee,"TYA"            ; $c3 TYA
>bde2	ff					.text	$FF
.b3de					ListConvertLine:
.b3de	48		pha				pha 								; save indent on the stack
.b3df	9c 9d 04	stz $049d			stz 	tbOffset
.b3e2	9c ab 04	stz $04ab			stz 	tokenBuffer
.b3e5	a0 02		ldy #$02			ldy 	#2 							; convert line number to string
.b3e7	b1 30		lda ($30),y			lda 	(codePtr),y
.b3e9	aa		tax				tax
.b3ea	88		dey				dey
.b3eb	b1 30		lda ($30),y			lda 	(codePtr),y
.b3ed	20 77 92	jsr $9277			jsr 	LCLConvertInt16
.b3f0	85 36		sta $36				sta 	zTemp0 						; copy number into buffer
.b3f2	86 37		stx $37				stx 	zTemp0+1
.b3f4	a9 8c		lda #$8c			lda 	#CLINumber+$80
.b3f6	20 3b b5	jsr $b53b			jsr 	LCLWrite
.b3f9	a0 00		ldy #$00			ldy 	#0
.b3fb					_LCCopyNumber:
.b3fb	b1 36		lda ($36),y			lda 	(zTemp0),y
.b3fd	20 3b b5	jsr $b53b			jsr 	LCLWrite
.b400	c8		iny				iny
.b401	b1 36		lda ($36),y			lda 	(zTemp0),y
.b403	d0 f6		bne $b3fb			bne 	_LCCopyNumber
.b405	68		pla				pla 								; adjustment to indent
.b406	48		pha				pha 								; save on stack
.b407	10 0c		bpl $b415			bpl 	_LCNoAdjust 				; don't adjust indent if +ve, do after.
.b409	18		clc				clc 								; add to list indent and make 0 if goes -ve.
.b40a	6d a6 04	adc $04a6			adc 	listIndent
.b40d	8d a6 04	sta $04a6			sta 	listIndent
.b410	10 03		bpl $b415			bpl 	_LCNoAdjust
.b412	9c a6 04	stz $04a6			stz 	listIndent
.b415					_LCNoAdjust:
.b415	18		clc				clc		 							; work out actual indent.
.b416	ad a6 04	lda $04a6			lda 	listIndent
.b419	0a		asl a				asl 	a
.b41a	69 06		adc #$06			adc 	#6
.b41c	85 36		sta $36				sta 	zTemp0
.b41e					_LCPadOut:
.b41e	a9 20		lda #$20			lda 	#' '						; pad out to 6 characters
.b420	20 3b b5	jsr $b53b			jsr 	LCLWrite
.b423	ad 9d 04	lda $049d			lda 	tbOffset
.b426	c5 36		cmp $36				cmp 	zTemp0
.b428	d0 f4		bne $b41e			bne 	_LCPadOut
.b42a	a0 03		ldy #$03			ldy 	#3 							; start position.
.b42c					_LCMainLoop:
.b42c	a9 8a		lda #$8a			lda 	#CLIPunctuation+$80
.b42e	20 3b b5	jsr $b53b			jsr 	LCLWrite
.b431	b1 30		lda ($30),y			lda 	(codePtr),y
.b433	c9 80		cmp #$80			cmp 	#KWC_EOL 					; end of line ?
.b435	f0 17		beq $b44e			beq 	_LCExit
.b437	c9 10		cmp #$10			cmp 	#16 						; 0-5 are the double punctuations
.b439	90 1e		bcc $b459			bcc 	_LCDoubles
.b43b	c9 20		cmp #$20			cmp 	#32 						; 16-31 are shifted punctuation from 64-91
.b43d	90 2a		bcc $b469			bcc 	_LCShiftPunc
.b43f	c9 40		cmp #$40			cmp 	#64 						; 32-64 are as stored, punc and digits
.b441	90 35		bcc $b478			bcc 	_LCPunctuation
.b443	c9 80		cmp #$80			cmp 	#128 						; 64-127 are variable identifiers.
.b445	90 3e		bcc $b485			bcc 	_LCIdentifiers
.b447	c9 fe		cmp #$fe			cmp 	#254 						; 128-253 are tokenised words
.b449	90 5f		bcc $b4aa			bcc 	_LCTokens
.b44b	4c 0a b5	jmp $b50a			jmp 	_LCData 					; 254-5 are data objects
.b44e					_LCExit:
.b44e	68		pla				pla 								; get old indent adjust
.b44f	30 07		bmi $b458			bmi 	_LCExit2
.b451	18		clc				clc 								; add to indent if +ve
.b452	6d a6 04	adc $04a6			adc 	listIndent
.b455	8d a6 04	sta $04a6			sta 	listIndent
.b458					_LCExit2:
.b458	60		rts				rts
.b459					_LCDoubles:
.b459	48		pha				pha
.b45a	4a		lsr a				lsr 	a 							; put bit 2 into bit 1
.b45b	29 02		and #$02			and 	#2
.b45d	09 3c		ora #$3c			ora 	#60 						; make < >
.b45f	20 3b b5	jsr $b53b			jsr 	LCLWrite
.b462	68		pla				pla 								; restore, do lower bit
.b463	29 03		and #$03			and 	#3
.b465	09 3c		ora #$3c			ora 	#60
.b467	80 0f		bra $b478			bra		_LCPunctuation 				; print, increment, loop
.b469					_LCShiftPunc:
.b469	aa		tax				tax 								; save in X
.b46a	29 07		and #$07			and 	#7 							; lower 3 bits
.b46c	f0 02		beq $b470			beq 	_LCNoAdd
.b46e	09 18		ora #$18			ora 	#24 						; adds $18 to it.
.b470					_LCNoAdd:
.b470	e0 18		cpx #$18			cpx 	#24 						; if >= 24 add $20
.b472	90 02		bcc $b476			bcc 	_LCNoAdd2
.b474	09 20		ora #$20			ora 	#32 						; adds $20
.b476					_LCNoAdd2:
.b476	09 40		ora #$40			ora 	#$40 						; shift into 64-127 range and fall through.
.b478					_LCPunctuation:
.b478	c9 3a		cmp #$3a			cmp 	#':' 						; check if :
.b47a	d0 03		bne $b47f			bne 	_LCPContinue
.b47c	20 51 b5	jsr $b551			jsr 	LCLDeleteLastSpace
.b47f					_LCPContinue:
.b47f	c8		iny				iny 								; consume character
.b480	20 3b b5	jsr $b53b			jsr 	LCLWrite 					; write it out.
.b483	80 a7		bra $b42c			bra 	_LCMainLoop 				; go round again.
.b485					_LCIdentifiers:
.b485	18		clc				clc 								; convert to physical address
.b486	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.b488	85 37		sta $37				sta 	zTemp0+1
.b48a	c8		iny				iny
.b48b	b1 30		lda ($30),y			lda 	(codePtr),y
.b48d	85 36		sta $36				sta 	zTemp0
.b48f	c8		iny				iny
.b490	5a		phy				phy 								; save position
.b491	a9 87		lda #$87			lda 	#CLIIdentifier+$80
.b493	20 3b b5	jsr $b53b			jsr 	LCLWrite
.b496	a0 07		ldy #$07			ldy 	#7 							; output the identifier.
.b498					_LCOutIdentifier:
.b498	c8		iny				iny
.b499	b1 36		lda ($36),y			lda 	(zTemp0),y
.b49b	29 7f		and #$7f			and 	#$7F
.b49d	20 8d b5	jsr $b58d			jsr 	LCLLowerCase
.b4a0	20 3b b5	jsr $b53b			jsr 	LCLWrite
.b4a3	b1 36		lda ($36),y			lda 	(zTemp0),y				 	; ends when bit 7 set.
.b4a5	10 f1		bpl $b498			bpl 	_LCOutIdentifier
.b4a7	7a		ply				ply 								; restore position
.b4a8	80 82		bra $b42c			bra 	_LCMainLoop
.b4aa					_LCTokens:
.b4aa	aa		tax				tax 								; token in X
.b4ab	a9 97		lda #$97			lda 	#((KeywordSet2) & $FF)
.b4ad	85 36		sta $36				sta 	0+zTemp0
.b4af	a9 bc		lda #$bc			lda 	#((KeywordSet2) >> 8)
.b4b1	85 37		sta $37				sta 	1+zTemp0
.b4b3	e0 82		cpx #$82			cpx 	#$82
.b4b5	f0 16		beq $b4cd			beq 	_LCUseShift
.b4b7	a9 49		lda #$49			lda 	#((KeywordSet1) & $FF)
.b4b9	85 36		sta $36				sta 	0+zTemp0
.b4bb	a9 bc		lda #$bc			lda 	#((KeywordSet1) >> 8)
.b4bd	85 37		sta $37				sta 	1+zTemp0
.b4bf	e0 81		cpx #$81			cpx 	#$81
.b4c1	f0 0a		beq $b4cd			beq 	_LCUseShift
.b4c3	a9 53		lda #$53			lda 	#((KeywordSet0) & $FF)
.b4c5	85 36		sta $36				sta 	0+zTemp0
.b4c7	a9 ba		lda #$ba			lda 	#((KeywordSet0) >> 8)
.b4c9	85 37		sta $37				sta 	1+zTemp0
.b4cb	80 01		bra $b4ce			bra 	_LCNoShift
.b4cd					_LCUseShift:
.b4cd	c8		iny				iny
.b4ce					_LCNoShift:
.b4ce	20 65 b5	jsr $b565			jsr 	LCLCheckSpaceRequired 		; do we need a space ?
.b4d1	b1 30		lda ($30),y			lda 	(codePtr),y
.b4d3	aa		tax				tax 								; into X
.b4d4					_LCFindText:
.b4d4	ca		dex				dex
.b4d5	10 0e		bpl $b4e5			bpl 	_LCFoundText 				; found text.
.b4d7	b2 36		lda ($36)			lda 	(zTemp0) 					; length of text
.b4d9	1a		inc a				inc 	a 							; one extra for size
.b4da	38		sec				sec 								; one extra for checksum
.b4db	65 36		adc $36				adc 	zTemp0 						; go to next token
.b4dd	85 36		sta $36				sta 	zTemp0
.b4df	90 f3		bcc $b4d4			bcc 	_LCFindText
.b4e1	e6 37		inc $37				inc 	zTemp0+1
.b4e3	80 ef		bra $b4d4			bra 	_LCFindText
.b4e5					_LCFoundText:
.b4e5	5a		phy				phy 								; save List position
.b4e6	b2 36		lda ($36)			lda 	(zTemp0)					; count to print
.b4e8	aa		tax				tax
.b4e9	a9 83		lda #$83			lda 	#CLIToken+$80
.b4eb	20 3b b5	jsr $b53b			jsr 	LCLWrite
.b4ee	a0 02		ldy #$02			ldy 	#2
.b4f0					_LCCopyToken:
.b4f0	b1 36		lda ($36),y			lda 	(zTemp0),y
.b4f2	20 8d b5	jsr $b58d			jsr 	LCLLowerCase
.b4f5	20 3b b5	jsr $b53b			jsr 	LCLWrite
.b4f8	c8		iny				iny
.b4f9	ca		dex				dex
.b4fa	d0 f4		bne $b4f0			bne 	_LCCopyToken
.b4fc	c9 28		cmp #$28			cmp 	#"(" 						; if last char not ( print a space
.b4fe	f0 05		beq $b505			beq 	_LCNoSpace
.b500	a9 20		lda #$20			lda 	#' '
.b502	20 3b b5	jsr $b53b			jsr 	LCLWrite
.b505					_LCNoSpace:
.b505	7a		ply				ply 								; restore position.
.b506	c8		iny				iny 								; consume token
.b507	4c 2c b4	jmp $b42c			jmp 	_LCMainLoop 				; and go around again.
.b50a					_LCData:
.b50a	48		pha				pha 								; save type $FE/$FF
.b50b	a2 24		ldx #$24			ldx 	#'$' 						; figure out $ or "
.b50d	c9 fe		cmp #$fe			cmp 	#$FE
.b50f	f0 07		beq $b518			beq 	_LCHaveOpener
.b511	a2 22		ldx #$22			ldx 	#'"'
.b513	a9 81		lda #$81			lda 	#CLIData+$80
.b515	20 3b b5	jsr $b53b			jsr 	LCLWrite
.b518					_LCHaveOpener:
.b518	8a		txa				txa 								; output prefix (# or ")
.b519	20 3b b5	jsr $b53b			jsr 	LCLWrite
.b51c	c8		iny				iny 								; get count
.b51d	b1 30		lda ($30),y			lda 	(codePtr),y
.b51f	aa		tax				tax
.b520	c8		iny				iny 								; point at first character
.b521					_LCOutData:
.b521	b1 30		lda ($30),y			lda 	(codePtr),y
.b523	c9 00		cmp #$00			cmp 	#0
.b525	f0 03		beq $b52a			beq 	_LCNoPrint
.b527	20 3b b5	jsr $b53b			jsr 	LCLWrite
.b52a					_LCNoPrint:
.b52a	c8		iny				iny
.b52b	ca		dex				dex
.b52c	d0 f3		bne $b521			bne 	_LCOutData
.b52e	68		pla				pla 								; closing " required ?
.b52f	c9 ff		cmp #$ff			cmp 	#$FF
.b531	d0 05		bne $b538			bne 	_LCNoQuote
.b533	a9 22		lda #$22			lda 	#'"'
.b535	20 3b b5	jsr $b53b			jsr 	LCLWrite
.b538					_LCNoQuote:
.b538	4c 2c b4	jmp $b42c			jmp 	_LCMainLoop
.b53b					LCLWrite:
.b53b	da		phx				phx
.b53c	ae 9d 04	ldx $049d			ldx 	tbOffset
.b53f	9d ab 04	sta $04ab,x			sta 	tokenBuffer,x
.b542	9e ac 04	stz $04ac,x			stz 	tokenBuffer+1,x
.b545	ee 9d 04	inc $049d			inc 	tbOffset
.b548	09 00		ora #$00			ora 	#0 							; don't update if colour data
.b54a	30 03		bmi $b54f			bmi 	_LCLNoColour
.b54c	8d a7 04	sta $04a7			sta 	LCLastCharacter
.b54f					_LCLNoColour:
.b54f	fa		plx				plx
.b550	60		rts				rts
.b551					LCLDeleteLastSpace:
.b551	48		pha				pha
.b552	da		phx				phx
.b553	ae 9d 04	ldx $049d			ldx 	tbOffset
.b556	f0 0a		beq $b562			beq 	_LCDLSExit
.b558	bd aa 04	lda $04aa,x			lda 	tokenBuffer-1,x
.b55b	c9 20		cmp #$20			cmp 	#' '
.b55d	d0 03		bne $b562			bne 	_LCDLSExit
.b55f	ce 9d 04	dec $049d			dec 	tbOffset
.b562					_LCDLSExit:
.b562	fa		plx				plx
.b563	68		pla				pla
.b564	60		rts				rts
.b565					LCLCheckSpaceRequired:
.b565	ad a7 04	lda $04a7			lda 	LCLastCharacter 			; check last character
.b568	c9 24		cmp #$24			cmp 	#'$' 						; $ # and ) require that token space.
.b56a	f0 1b		beq $b587			beq 	_LCCSRSpace
.b56c	c9 29		cmp #$29			cmp 	#')'
.b56e	f0 17		beq $b587			beq 	_LCCSRSpace
.b570	c9 23		cmp #$23			cmp 	#'#'
.b572	f0 13		beq $b587			beq 	_LCCSRSpace
.b574	20 8d b5	jsr $b58d			jsr 	LCLLowerCase 				; saves a little effort
.b577	c9 30		cmp #$30			cmp 	#"0" 						; check if it was 0-9 A-Z a-z if so need space.
.b579	90 11		bcc $b58c			bcc 	_LCCSRExit
.b57b	c9 3a		cmp #$3a			cmp 	#"9"+1
.b57d	90 08		bcc $b587			bcc 	_LCCSRSpace
.b57f	c9 61		cmp #$61			cmp 	#"a"
.b581	90 09		bcc $b58c			bcc 	_LCCSRExit
.b583	c9 7b		cmp #$7b			cmp 	#"z"+1
.b585	b0 05		bcs $b58c			bcs 	_LCCSRExit
.b587					_LCCSRSpace:
.b587	a9 20		lda #$20			lda 	#' '
.b589	20 3b b5	jsr $b53b			jsr 	LCLWrite
.b58c					_LCCSRExit:
.b58c	60		rts				rts
.b58d					LCLLowerCase:
.b58d	c9 41		cmp #$41			cmp 	#"A"
.b58f	90 06		bcc $b597			bcc 	_LCLLCOut
.b591	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b593	b0 02		bcs $b597			bcs 	_LCLLCOut
.b595	69 20		adc #$20			adc 	#$20
.b597					_LCLLCOut:
.b597	60		rts				rts
.b598					LCLUpperCase:
.b598	c9 61		cmp #$61			cmp 	#"a"
.b59a	90 06		bcc $b5a2			bcc 	_LCLUCOut
.b59c	c9 7b		cmp #$7b			cmp 	#"z"+1
.b59e	b0 02		bcs $b5a2			bcs 	_LCLUCOut
.b5a0	e9 1f		sbc #$1f			sbc 	#$1F
.b5a2					_LCLUCOut:
.b5a2	60		rts				rts
.b5a3					TOKSearchTable:
.b5a3	84 37		sty $37				sty 	zTemp0+1 					; (zTemp0),y points to current token.
.b5a5	85 36		sta $36				sta 	zTemp0
.b5a7	a0 00		ldy #$00			ldy 	#0
.b5a9	a9 80		lda #$80			lda 	#$80 						; token #
.b5ab	85 38		sta $38				sta 	zTemp1
.b5ad					_TSTLoop:
.b5ad	b1 36		lda ($36),y			lda 	(zTemp0),y 					; length, 0 (skip) -ve (end)
.b5af	30 49		bmi $b5fa			bmi 	_TSTFail 					; -ve = end of table
.b5b1	f0 2e		beq $b5e1			beq 	_TSTNext 					; zero, check next it's a dummy
.b5b3	c8		iny				iny 								; get the hash
.b5b4	b1 36		lda ($36),y			lda 	(zTemp0),y
.b5b6	88		dey				dey
.b5b7	cd 83 04	cmp $0483			cmp 	identHash 					; check they match, if not go to next
.b5ba	d0 25		bne $b5e1			bne 	_TSTNext
.b5bc	ad 82 04	lda $0482			lda 	identTypeEnd 				; length of identifier
.b5bf	38		sec				sec
.b5c0	ed 80 04	sbc $0480			sbc 	identStart
.b5c3	d1 36		cmp ($36),y			cmp 	(zTemp0),y 					; no match, then return.
.b5c5	d0 1a		bne $b5e1			bne 	_TSTNext
.b5c7	5a		phy				phy 								; save Y , we might fail
.b5c8	c8		iny				iny 								; point to text
.b5c9	c8		iny				iny
.b5ca	ae 80 04	ldx $0480			ldx 	identStart 					; offset in line buffer in X
.b5cd					_TSTCompareName:
.b5cd	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; compare text.
.b5d0	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.b5d2	d0 0c		bne $b5e0			bne 	_TSTNextPullY 				; fail, pullY and do next
.b5d4	e8		inx				inx
.b5d5	c8		iny				iny
.b5d6	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; complete match.
.b5d9	d0 f2		bne $b5cd			bne 	_TSTCompareName
.b5db	7a		ply				ply 								; throw Y
.b5dc	a5 38		lda $38				lda 	zTemp1 						; get token #
.b5de	38		sec				sec 								; return with CS = passed.
.b5df	60		rts				rts
.b5e0					_TSTNextPullY:
.b5e0	7a		ply				ply 								; restore current, fall through.
.b5e1					_TSTNext:
.b5e1	e6 38		inc $38				inc 	zTemp1 						; token counter
.b5e3	98		tya				tya
.b5e4	18		clc				clc
.b5e5	71 36		adc ($36),y			adc 	(zTemp0),y 					; add [Length] + 2 to Y
.b5e7	1a		inc a				inc 	a 							; +1
.b5e8	1a		inc a				inc 	a 							; +2
.b5e9	a8		tay				tay
.b5ea	10 c1		bpl $b5ad			bpl 	_TSTLoop 					; if Y < $80 loop back
.b5ec	98		tya				tya 								; add Y to zTemp0 and reset Y
.b5ed	a0 00		ldy #$00			ldy 	#0   						; so we can use Y to search fast
.b5ef	18		clc				clc  								; but have tables > 255 bytes
.b5f0	65 36		adc $36				adc 	zTemp0 						; when Y gets >= 128 we reset Y
.b5f2	85 36		sta $36				sta 	zTemp0 						; and adjust the table pointer/
.b5f4	90 b7		bcc $b5ad			bcc 	_TSTLoop
.b5f6	e6 37		inc $37				inc 	zTemp0+1
.b5f8	80 b3		bra $b5ad			bra 	_TSTLoop
.b5fa					_TSTFail:
.b5fa	18		clc				clc
.b5fb	60		rts				rts
.b5fc					TokeniseLine:
.b5fc	20 84 b7	jsr $b784			jsr 	LCLFixLineBufferCase 		; fix line case
.b5ff	a9 03		lda #$03			lda 	#3 							; reset the token buffer to empty
.b601	8d a8 04	sta $04a8			sta 	tokenOffset
.b604	9c a9 04	stz $04a9			stz 	tokenLineNumber
.b607	9c aa 04	stz $04aa			stz 	tokenLineNumber+1
.b60a	a2 ff		ldx #$ff			ldx 	#$FF
.b60c					_TKFindFirst:
.b60c	e8		inx				inx
.b60d	bd a8 05	lda $05a8,x			lda 	lineBuffer,x
.b610	f0 79		beq $b68b			beq 	_TKExit
.b612	c9 20		cmp #$20			cmp 	#' '
.b614	90 f6		bcc $b60c			bcc 	_TKFindFirst
.b616	c9 30		cmp #$30			cmp 	#'0'
.b618	90 07		bcc $b621			bcc 	_TKNoLineNumber
.b61a	c9 3a		cmp #$3a			cmp 	#'9'+1
.b61c	b0 03		bcs $b621			bcs 	_TKNoLineNumber
.b61e	20 ae b7	jsr $b7ae			jsr 	TOKExtractLineNumber
.b621					_TKNoLineNumber:
.b621					_TKTokeniseLoop:
.b621	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; next character, exit if zero EOL.
.b624	f0 65		beq $b68b			beq 	_TKExit
.b626	e8		inx				inx
.b627	c9 20		cmp #$20			cmp 	#' '
.b629	f0 f6		beq $b621			beq 	_TKTokeniseLoop 			; keep looping if space found.
.b62b	ca		dex				dex 								; undo last get, A contains character, X is position.
.b62c	c9 5f		cmp #$5f			cmp 	#'_'						; _ A-Z is identifier *or* token
.b62e	f0 61		beq $b691			beq 	_TKTokeniseIdentifier
.b630	c9 41		cmp #$41			cmp 	#'A'
.b632	90 04		bcc $b638			bcc 	_TKTokenisePunctuation
.b634	c9 5b		cmp #$5b			cmp 	#'Z'+1
.b636	90 59		bcc $b691			bcc 	_TKTokeniseIdentifier
.b638					_TKTokenisePunctuation:
.b638	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.b63a	f0 27		beq $b663			beq 	_TKString
.b63c	c9 24		cmp #$24			cmp 	#'$'						; hexadecimal constant (# only appears at end of identifiers)
.b63e	f0 28		beq $b668			beq 	_TKHexConstant
.b640	c9 3c		cmp #$3c			cmp 	#'<' 						; check for < > handlers.
.b642	f0 29		beq $b66d			beq 	_TKCheckDouble
.b644	c9 3e		cmp #$3e			cmp 	#'>'
.b646	f0 25		beq $b66d			beq 	_TKCheckDouble
.b648					_TKStandardPunctuation:
.b648	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; get it back.
.b64b	c9 40		cmp #$40			cmp 	#64 						; are we >= 64
.b64d	90 0e		bcc $b65d			bcc 	_TKNoShift
.b64f	48		pha				pha 								; save
.b650	29 07		and #$07			and 	#7 							; lower 3 bits in zTemp0
.b652	85 36		sta $36				sta 	zTemp0
.b654	68		pla				pla
.b655	29 20		and #$20			and 	#32 						; bit 5
.b657	4a		lsr a				lsr 	a 							; shift into bit 3
.b658	4a		lsr a				lsr 	a
.b659	05 36		ora $36				ora 	zTemp0
.b65b	09 10		ora #$10			ora 	#$10						; now in the range 16-31
.b65d					_TKNoShift:
.b65d	20 f3 b7	jsr $b7f3			jsr 	TOKWriteByte 				; write the punctuation character
.b660	e8		inx				inx 								; consume the character
.b661	80 be		bra $b621			bra 	_TKTokeniseLoop 			; and loop round again.
.b663					_TKString:
.b663	20 13 b7	jsr $b713			jsr 	TOKTokenString
.b666	80 b9		bra $b621			bra 	_TKTokeniseLoop
.b668					_TKHexConstant:
.b668	20 4e b7	jsr $b74e			jsr 	TOKHexConstant
.b66b	80 b4		bra $b621			bra 	_TKTokeniseLoop
.b66d					_TKCheckDouble:
.b66d	bd a9 05	lda $05a9,x			lda 	lineBuffer+1,x 				; get next character
.b670	c9 3c		cmp #$3c			cmp 	#'<'						; if not < = > which are ASCII consecutive go back
.b672	90 d4		bcc $b648			bcc 	_TKStandardPunctuation
.b674	c9 3f		cmp #$3f			cmp 	#'>'+1
.b676	b0 d0		bcs $b648			bcs 	_TKStandardPunctuation
.b678	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; this is < (60) or > (62)
.b67b	29 02		and #$02			and 	#2 							; now < (0) or > (2)
.b67d	0a		asl a				asl 	a 							; now < (0) or > (4), CC also
.b67e	7d a9 05	adc $05a9,x			adc 	lineBuffer+1,x 				; add < = > codes - < code
.b681	38		sec				sec
.b682	e9 3c		sbc #$3c			sbc 	#'<'
.b684	20 f3 b7	jsr $b7f3			jsr 	TOKWriteByte 				; this is in the range 0-7
.b687	e8		inx				inx 								; consume both
.b688	e8		inx				inx
.b689	80 96		bra $b621			bra 	_TKTokeniseLoop
.b68b	a9 80		lda #$80	_TKExit:lda 	#KWC_EOL 					; write end of line byte
.b68d	20 f3 b7	jsr $b7f3			jsr 	TOKWriteByte
.b690	60		rts				rts
.b691					_TKTokeniseIdentifier:
.b691	8e 80 04	stx $0480			stx 	identStart 					; save start
.b694	9c 84 04	stz $0484			stz 	identTypeByte 				; zero the type byte
.b697					_TKCheckLoop:
.b697	e8		inx				inx 								; look at next, we know first is identifier.
.b698	bd a8 05	lda $05a8,x			lda  	lineBuffer,x
.b69b	c9 5f		cmp #$5f			cmp 	#"_" 						; legal char _ 0-9 A-Z
.b69d	f0 f8		beq $b697			beq 	_TKCheckLoop
.b69f	c9 30		cmp #$30			cmp	 	#"0"
.b6a1	90 0c		bcc $b6af			bcc 	_TKEndIdentifier
.b6a3	c9 3a		cmp #$3a			cmp 	#"9"+1
.b6a5	90 f0		bcc $b697			bcc 	_TKCheckLoop
.b6a7	c9 41		cmp #$41			cmp	 	#"A"
.b6a9	90 04		bcc $b6af			bcc 	_TKEndIdentifier
.b6ab	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b6ad	90 e8		bcc $b697			bcc 	_TKCheckLoop
.b6af					_TKEndIdentifier:
.b6af	8e 81 04	stx $0481			stx 	identTypeStart 				; save start of type text (if any !)
.b6b2	a0 08		ldy #$08			ldy 	#$08 						; this is the identifier type byte for #
.b6b4	c9 23		cmp #$23			cmp 	#"#"						; followed by #
.b6b6	f0 06		beq $b6be			beq 	_TKHasTypeCharacter
.b6b8	a0 10		ldy #$10			ldy 	#$10 						; this is the identifier type byte for $
.b6ba	c9 24		cmp #$24			cmp 	#"$"						; followed by $ or #
.b6bc	d0 07		bne $b6c5			bne 	_TKNoTypeCharacter
.b6be					_TKHasTypeCharacter:
.b6be	8c 84 04	sty $0484			sty 	identTypeByte 				; has # or $, save the type
.b6c1	e8		inx				inx 								; read next
.b6c2	bd a8 05	lda $05a8,x			lda 	lineBuffer,x
.b6c5					_TKNoTypeCharacter:
.b6c5	c9 28		cmp #$28			cmp 	#"("						; is it open parenthesis (e.g. array)
.b6c7	d0 09		bne $b6d2			bne 	_TKNoArray
.b6c9	e8		inx				inx 								; skip the (
.b6ca	ad 84 04	lda $0484			lda 	identTypeByte 				; set bit 2 (e.g. array)
.b6cd	09 04		ora #$04			ora 	#$04
.b6cf	8d 84 04	sta $0484			sta 	identTypeByte
.b6d2					_TKNoArray:
.b6d2	8e 82 04	stx $0482			stx 	identTypeEnd 				; save end marker, e.g. continue from here.
.b6d5	20 6f b7	jsr $b76f			jsr 	TOKCalculateHash 			; calculate the has for those tokens
.b6d8	a0 ba		ldy #$ba			ldy 	#(KeywordSet0) >> 8
.b6da	a9 53		lda #$53			lda 	#(KeywordSet0) & $FF
.b6dc	20 a3 b5	jsr $b5a3			jsr 	TOKSearchTable
.b6df	a2 00		ldx #$00			ldx 	#0
.b6e1	b0 1f		bcs $b702			bcs 	_TKFoundToken
.b6e3	a0 bc		ldy #$bc			ldy 	#(KeywordSet1) >> 8
.b6e5	a9 49		lda #$49			lda 	#(KeywordSet1) & $FF
.b6e7	20 a3 b5	jsr $b5a3			jsr 	TOKSearchTable
.b6ea	a2 81		ldx #$81			ldx 	#$81
.b6ec	b0 14		bcs $b702			bcs 	_TKFoundToken
.b6ee	a0 bc		ldy #$bc			ldy 	#(KeywordSet2) >> 8
.b6f0	a9 97		lda #$97			lda 	#(KeywordSet2) & $FF
.b6f2	20 a3 b5	jsr $b5a3			jsr 	TOKSearchTable
.b6f5	a2 82		ldx #$82			ldx 	#$82
.b6f7	b0 09		bcs $b702			bcs 	_TKFoundToken
.b6f9	20 ff b7	jsr $b7ff			jsr 	TOKCheckCreateVariableRecord ; failed all, it's a variable, create record if does not exist.
.b6fc	ae 82 04	ldx $0482			ldx 	identTypeEnd 				; X points to following byte
.b6ff	4c 21 b6	jmp $b621			jmp 	_TKTokeniseLoop 			; and go round again.
.b702					_TKFoundToken:
.b702	48		pha				pha 								; save token
.b703	8a		txa				txa 								; shift in X, is there one ?
.b704	f0 03		beq $b709			beq 	_TKNoTShift
.b706	20 f3 b7	jsr $b7f3			jsr 	TOKWriteByte 				; if so, write it out
.b709					_TKNoTShift:
.b709	68		pla				pla 								; restore and write token
.b70a	20 f3 b7	jsr $b7f3			jsr 	TOKWriteByte
.b70d	ae 82 04	ldx $0482			ldx 	identTypeEnd 				; X points to following byte
.b710	4c 21 b6	jmp $b621			jmp 	_TKTokeniseLoop 			; and go round again.
.b713					TOKTokenString:
.b713	a9 ff		lda #$ff			lda 	#KWC_STRING 				; string token.
.b715	20 f3 b7	jsr $b7f3			jsr 	TOKWriteByte
.b718	e8		inx				inx									; start of quoted string.
.b719	da		phx				phx 								; push start of string on top
.b71a	ca		dex				dex
.b71b					_TSFindEnd:
.b71b	e8		inx				inx
.b71c	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; next character
.b71f	f0 04		beq $b725			beq 	_TSEndOfString
.b721	c9 22		cmp #$22			cmp 	#'"'
.b723	d0 f6		bne $b71b			bne 	_TSFindEnd
.b725					_TSEndOfString:
.b725	7a		ply				ply  								; so now Y is first character, X is character after end.
.b726	48		pha				pha 								; save terminating character
.b727	20 2f b7	jsr $b72f			jsr 	TOKWriteBlockXY 			; write X to Y as a data block
.b72a	68		pla				pla 								; terminating character
.b72b	f0 01		beq $b72e			beq 	_TSNotQuote					; if it wasn't EOS skip it
.b72d	e8		inx				inx
.b72e					_TSNotQuote:
.b72e	60		rts				rts
.b72f					TOKWriteBlockXY:
.b72f	86 36		stx $36				stx 	zTemp0 						; write end character
.b731	98		tya				tya
.b732	49 ff		eor #$ff			eor 	#$FF
.b734	38		sec				sec
.b735	65 36		adc $36				adc 	zTemp0
.b737	1a		inc a				inc 	a 							; one extra for NULL
.b738	20 f3 b7	jsr $b7f3			jsr 	TOKWriteByte
.b73b					_TOBlockLoop:
.b73b	c4 36		cpy $36				cpy 	zTemp0
.b73d	f0 09		beq $b748			beq 	_TOBlockExit
.b73f	b9 a8 05	lda $05a8,y			lda 	lineBuffer,y
.b742	20 f3 b7	jsr $b7f3			jsr 	TOKWriteByte
.b745	c8		iny				iny
.b746	80 f3		bra $b73b			bra 	_TOBlockLoop
.b748					_TOBlockExit:
.b748	a9 00		lda #$00			lda 	#0
.b74a	20 f3 b7	jsr $b7f3			jsr 	TOKWriteByte
.b74d	60		rts				rts
.b74e					TOKHexConstant:
.b74e	a9 fe		lda #$fe			lda 	#KWC_HEXCONST 				; hex constant token.
.b750	20 f3 b7	jsr $b7f3			jsr 	TOKWriteByte
.b753	e8		inx				inx									; start of quoted string.
.b754	da		phx				phx 								; push start of constant on top
.b755	ca		dex				dex
.b756					_THFindLoop:
.b756	e8		inx				inx
.b757	bd a8 05	lda $05a8,x			lda 	lineBuffer,x
.b75a	c9 30		cmp #$30			cmp 	#"0"
.b75c	90 0c		bcc $b76a			bcc 	_THFoundEnd
.b75e	c9 3a		cmp #$3a			cmp 	#"9"+1
.b760	90 f4		bcc $b756			bcc 	_THFindLoop
.b762	c9 41		cmp #$41			cmp 	#"A"
.b764	90 04		bcc $b76a			bcc 	_THFoundEnd
.b766	c9 47		cmp #$47			cmp 	#"F"+1
.b768	90 ec		bcc $b756			bcc 	_THFindLoop
.b76a					_THFoundEnd:
.b76a	7a		ply				ply 								; restore start
.b76b	20 2f b7	jsr $b72f			jsr 	TOKWriteBlockXY 			; output the block
.b76e	60		rts				rts
.b76f					TOKCalculateHash:
.b76f	da		phx				phx
.b770	ae 80 04	ldx $0480			ldx 	identStart 					; needs to be same as in tokens.py - simple sum
.b773	a9 00		lda #$00			lda 	#0
.b775					_TCHLoop:
.b775	18		clc				clc
.b776	7d a8 05	adc $05a8,x			adc 	lineBuffer,x
.b779	e8		inx				inx
.b77a	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; do the whole thing including type and array markers.
.b77d	d0 f6		bne $b775			bne 	_TCHLoop
.b77f	8d 83 04	sta $0483			sta 	identHash 					; save the hash
.b782	fa		plx				plx
.b783	60		rts				rts
.b784					LCLFixLineBufferCase:
.b784	a2 00		ldx #$00			ldx 	#0
.b786					_FLBCLoop:
.b786	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; get next character
.b789	f0 22		beq $b7ad			beq 	_FLBCExit 					; end of string.
.b78b	c9 22		cmp #$22			cmp 	#'"'						; quote, go to in quotes
.b78d	f0 11		beq $b7a0			beq 	_FLBCInQuotes
.b78f	e8		inx				inx
.b790	c9 61		cmp #$61			cmp 	#'a'						; needs capitalising ?
.b792	90 f2		bcc $b786			bcc 	_FLBCLoop
.b794	c9 7b		cmp #$7b			cmp 	#'z'+1
.b796	b0 ee		bcs $b786			bcs 	_FLBCLoop
.b798	38		sec				sec 								; make U/C
.b799	e9 20		sbc #$20			sbc 	#32
.b79b	9d a7 05	sta $05a7,x			sta	 	lineBuffer-1,x 				; write back
.b79e	80 e6		bra $b786			bra 	_FLBCLoop
.b7a0					_FLBCInQuotes:
.b7a0	e8		inx				inx 								; advance
.b7a1	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; get next
.b7a4	f0 07		beq $b7ad			beq 	_FLBCExit 					; exit on EOS
.b7a6	c9 22		cmp #$22			cmp 	#'"' 				 		; until " found
.b7a8	d0 f6		bne $b7a0			bne 	_FLBCInQuotes
.b7aa	e8		inx				inx 								; skip over it
.b7ab	80 d9		bra $b786			bra 	_FLBCLoop
.b7ad					_FLBCExit:
.b7ad	60		rts				rts
.b7ae					TOKExtractLineNumber:
.b7ae	ad aa 04	lda $04aa			lda 	tokenLineNumber+1 			; push current value on stack
.b7b1	48		pha				pha
.b7b2	ad a9 04	lda $04a9			lda 	tokenLineNumber
.b7b5	48		pha				pha
.b7b6	20 ec b7	jsr $b7ec			jsr 	_LCLNTimes2 				; line # x 4
.b7b9	20 ec b7	jsr $b7ec			jsr 	_LCLNTimes2 				; line # x 2
.b7bc	18		clc				clc 								; add stacked value
.b7bd	68		pla				pla
.b7be	6d a9 04	adc $04a9			adc 	tokenLineNumber
.b7c1	8d a9 04	sta $04a9			sta 	tokenLineNumber
.b7c4	68		pla				pla
.b7c5	6d aa 04	adc $04aa			adc 	tokenLineNumber+1
.b7c8	8d aa 04	sta $04aa			sta 	tokenLineNumber+1 			; line # x 5
.b7cb	20 ec b7	jsr $b7ec			jsr 	_LCLNTimes2 				; line # x 10
.b7ce	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; get and consume character
.b7d1	e8		inx				inx
.b7d2	29 0f		and #$0f			and 	#15 						; add to line #
.b7d4	18		clc				clc
.b7d5	6d a9 04	adc $04a9			adc 	tokenLineNumber
.b7d8	8d a9 04	sta $04a9			sta 	tokenLineNumber
.b7db	90 03		bcc $b7e0			bcc 	_TLENNoCarry
.b7dd	ee aa 04	inc $04aa			inc 	tokenLineNumber+1
.b7e0					_TLENNoCarry:
.b7e0	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; more digits ?
.b7e3	c9 30		cmp #$30			cmp 	#'0'
.b7e5	90 04		bcc $b7eb			bcc 	_TLENExit
.b7e7	c9 3a		cmp #$3a			cmp 	#'9'+1
.b7e9	90 c3		bcc $b7ae			bcc 	TOKExtractLineNumber
.b7eb					_TLENExit:
.b7eb	60		rts				rts
.b7ec					_LCLNTimes2:
.b7ec	0e a9 04	asl $04a9			asl 	tokenLineNumber
.b7ef	2e aa 04	rol $04aa			rol 	tokenLineNumber+1
.b7f2	60		rts				rts
.b7f3					TOKWriteByte:
.b7f3	da		phx				phx
.b7f4	ae a8 04	ldx $04a8			ldx 	tokenOffset 				; next slot to write to
.b7f7	9d a8 04	sta $04a8,x			sta 	tokenOffset,x 				; write byte out
.b7fa	ee a8 04	inc $04a8			inc 	tokenOffset 				; advance slot.
.b7fd	fa		plx				plx
.b7fe	60		rts				rts
.b7ff					TOKCheckCreateVariableRecord:
.b7ff	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.b801	85 36		sta $36				sta 	0+zTemp0
.b803	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.b805	85 37		sta $37				sta 	1+zTemp0
.b807					_CCVSearch:
.b807	b2 36		lda ($36)			lda 	(zTemp0) 					; end of list
.b809	f0 2c		beq $b837			beq 	_CCVFail
.b80b	a0 01		ldy #$01			ldy 	#1 							; read the hash
.b80d	b1 36		lda ($36),y			lda 	(zTemp0),y 					; does it match ?
.b80f	cd 83 04	cmp $0483			cmp 	identHash
.b812	d0 16		bne $b82a			bne 	_CCVNext
.b814	a0 08		ldy #$08			ldy 	#8 							; name in variable record
.b816	ae 80 04	ldx $0480			ldx 	identStart
.b819					_CCVCompare:
.b819	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; xor them. zero if the same, except
.b81c	51 36		eor ($36),y			eor 	(zTemp0),y 					; bit 7 is used for EOS.
.b81e	e8		inx				inx 								; advance pointers
.b81f	c8		iny				iny
.b820	0a		asl a				asl 	a 							; A = 0 if they match, CS if end.
.b821	d0 07		bne $b82a			bne 	_CCVNext  					; didn't match go to next.
.b823	90 f4		bcc $b819			bcc 	_CCVCompare 				; not finished yet.
.b825	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; matched whole thing ?
.b828	f0 41		beq $b86b			beq 	_CCVFound 					; yes, we were successful
.b82a					_CCVNext:
.b82a	18		clc				clc
.b82b	b2 36		lda ($36)			lda 	(zTemp0) 					; add offset to pointer
.b82d	65 36		adc $36				adc 	zTemp0
.b82f	85 36		sta $36				sta 	zTemp0
.b831	90 d4		bcc $b807			bcc 	_CCVSearch
.b833	e6 37		inc $37				inc 	zTemp0+1
.b835	80 d0		bra $b807			bra 	_CCVSearch
.b837					_CCVFail:
.b837	a0 01		ldy #$01			ldy 	#1 							; create the new record. Offset 1 is hash
.b839	ad 83 04	lda $0483			lda 	identHash
.b83c	91 36		sta ($36),y			sta 	(zTemp0),y
.b83e	c8		iny				iny 								; offset 2 is the type byte
.b83f	ad 84 04	lda $0484			lda 	identTypeByte
.b842	91 36		sta ($36),y			sta 	(zTemp0),y
.b844	c8		iny				iny
.b845					_CCVData:
.b845	a9 00		lda #$00			lda 	#0 							; erase data 3-7
.b847	91 36		sta ($36),y			sta 	(zTemp0),y
.b849	c8		iny				iny
.b84a	c0 08		cpy #$08			cpy 	#8
.b84c	90 f7		bcc $b845			bcc 	_CCVData
.b84e	ae 80 04	ldx $0480			ldx 	identStart 					; copy name into 8 on.
.b851					_CCVCopyName:
.b851	bd a8 05	lda $05a8,x			lda 	lineBuffer,x
.b854	91 36		sta ($36),y			sta 	(zTemp0),y
.b856	e8		inx				inx
.b857	c8		iny				iny
.b858	ec 82 04	cpx $0482			cpx 	identTypeEnd
.b85b	d0 f4		bne $b851			bne 	_CCVCopyName
.b85d	98		tya				tya 								; patch offset
.b85e	92 36		sta ($36)			sta 	(zTemp0)
.b860	a9 00		lda #$00			lda 	#0 							; offset for next is zero.
.b862	91 36		sta ($36),y			sta 	(zTemp0),y
.b864	88		dey				dey
.b865	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set bit 7 of last bit
.b867	09 80		ora #$80			ora 	#$80
.b869	91 36		sta ($36),y			sta 	(zTemp0),y
.b86b					_CCVFound:
.b86b	a5 37		lda $37				lda 	zTemp0+1 					; write out MSB
.b86d	38		sec				sec
.b86e	e9 10		sbc #$10			sbc 	#(VariableSpace >> 8) 		; offset from the start
.b870	09 40		ora #$40			ora 	#$40 						; make it a writeable token
.b872	20 f3 b7	jsr $b7f3			jsr 	TOKWriteByte
.b875	a5 36		lda $36				lda 	zTemp0 						; write out LSB
.b877	20 f3 b7	jsr $b7f3			jsr 	TOKWriteByte
.b87a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_sound.module

=1					soundIntegrated=1
.b87b					SNDCheckChannel:
.b87b	aa		tax				tax
.b87c	bd 09 08	lda $0809,x			lda 	SNDTimeLeft,x 				; currently playing a note
.b87f	d0 38		bne $b8b9			bne 	_SNDCCExit
.b881	da		phx				phx 								; save current channel
.b882	8a		txa				txa 								; put in A
.b883	20 ff b8	jsr $b8ff			jsr 	SNDFindNextNoteForA 		; is there a note for A in the queue ?
.b886	68		pla				pla 								; channel # in A
.b887	90 30		bcc $b8b9			bcc 	_SNDCCExit  				; nothing in the queue for this channel, exit.
.b889	a8		tay				tay 								; Y is the channel #
.b88a	bd fe 06	lda $06fe,x			lda 	SNDQueue+1,x 				; copy data into the slot.
.b88d	99 fd 07	sta $07fd,y			sta 	SNDPitchLow,y
.b890	bd ff 06	lda $06ff,x			lda 	SNDQueue+2,x
.b893	99 01 08	sta $0801,y			sta 	SNDPitchHigh,y
.b896	bd 00 07	lda $0700,x			lda 	SNDQueue+3,x
.b899	99 05 08	sta $0805,y			sta 	SNDVolume,y
.b89c	bd 01 07	lda $0701,x			lda 	SNDQueue+4,x
.b89f	99 09 08	sta $0809,y			sta 	SNDTimeLeft,y
.b8a2	bd 02 07	lda $0702,x			lda 	SNDQueue+5,x
.b8a5	99 0d 08	sta $080d,y			sta 	SNDAdjustLow,y
.b8a8	bd 03 07	lda $0703,x			lda 	SNDQueue+6,x
.b8ab	99 11 08	sta $0811,y			sta 	SNDAdjustHigh,y
.b8ae	5a		phy				phy 								; save channel #
.b8af	20 19 b9	jsr $b919			jsr 	SNDDeleteXFromQueue 		; delete record at X from queue
.b8b2	ce fc 06	dec $06fc			dec 	SNDLength 					; reduce the queue length.
.b8b5	68		pla				pla
.b8b6	20 ba b8	jsr $b8ba			jsr 	SNDUpdateNote 				; update channel A
.b8b9					_SNDCCExit:
.b8b9	60		rts				rts
.b8ba					SNDUpdateNote:
.b8ba	aa		tax				tax 								; so we can access records
.b8bb	0a		asl a				asl 	a 							; convert it to a channel bit pair in 5,6
.b8bc	0a		asl a				asl 	a
.b8bd	0a		asl a				asl 	a
.b8be	0a		asl a				asl 	a
.b8bf	0a		asl a				asl 	a
.b8c0	8d fb 06	sta $06fb			sta 	SNDChannelBits
.b8c3	bd 09 08	lda $0809,x			lda 	SNDTimeLeft,x 				; are we silent
.b8c6	f0 2e		beq $b8f6			beq 	_SNDUNIsSilent
.b8c8	ad fb 06	lda $06fb			lda 	SNDChannelBits 				; push channel bits on stack
.b8cb	48		pha				pha
.b8cc	bd fd 07	lda $07fd,x			lda 	SNDPitchLow,x 				; get 4 lowest bits of pitch.
.b8cf	29 0f		and #$0f			and 	#$0F
.b8d1	0d fb 06	ora $06fb			ora 	SNDChannelBits 				; set channel bits
.b8d4	09 80		ora #$80			ora 	#$80 						; write to pitch register
.b8d6	20 63 b9	jsr $b963			jsr 	SNDWritePorts
.b8d9	bd 01 08	lda $0801,x			lda 	SNDPitchHigh,x 				; pitch high => channel temp.
.b8dc	8d fb 06	sta $06fb			sta 	SNDChannelBits
.b8df	bd fd 07	lda $07fd,x			lda 	SNDPitchLow,x
.b8e2	4e fb 06	lsr $06fb			lsr 	SNDChannelBits 				; shift 2 LSBs into MSB of A
.b8e5	6a		ror a				ror 	a
.b8e6	4e fb 06	lsr $06fb			lsr 	SNDChannelBits
.b8e9	6a		ror a				ror 	a
.b8ea	4a		lsr a				lsr 	a 							; put in bits 0-5
.b8eb	4a		lsr a				lsr 	a
.b8ec	20 63 b9	jsr $b963			jsr 	SNDWritePorts 				; write as rest of pitch register
.b8ef	68		pla				pla
.b8f0	09 90		ora #$90			ora 	#$90 						; set to write minimum attentuation.
.b8f2	20 63 b9	jsr $b963			jsr 	SNDWritePorts
.b8f5	60		rts				rts
.b8f6					_SNDUNIsSilent:
.b8f6	ad fb 06	lda $06fb			lda 	SNDChannelBits 				; channel bits
.b8f9	09 9f		ora #$9f			ora 	#$9F 						; maximum attenuation
.b8fb	20 63 b9	jsr $b963			jsr 	SNDWritePorts 				; write to the ports
.b8fe	60		rts				rts
.b8ff					SNDFindNextNoteForA:
.b8ff	ac fc 06	ldy $06fc			ldy 	SNDLength 					; queue size into Y
.b902	f0 13		beq $b917			beq 	_SNDFNNFail 				; queue empty.
.b904	a2 00		ldx #$00			ldx 	#0
.b906					_SNDFNNSearch:
.b906	dd fd 06	cmp $06fd,x			cmp 	SNDQueue,x 					; does it match the channel
.b909	38		sec				sec
.b90a	f0 0c		beq $b918			beq 	_SNDFNNExit 				; if so exit with CS.
.b90c	e8		inx				inx 								; next queue slot.
.b90d	e8		inx				inx
.b90e	e8		inx				inx
.b90f	e8		inx				inx
.b910	e8		inx				inx
.b911	e8		inx				inx
.b912	e8		inx				inx
.b913	e8		inx				inx
.b914	88		dey				dey 								; done the whole queue
.b915	d0 ef		bne $b906			bne 	_SNDFNNSearch 				; no, go back.
.b917					_SNDFNNFail:
.b917	18		clc				clc
.b918					_SNDFNNexit:
.b918	60		rts				rts
.b919					SNDDeleteXFromQueue:
.b919	e0 f8		cpx #$f8			cpx 	#SNDQueueSize*8-8 			; reached the end.
.b91b	f0 09		beq $b926			beq 	_SNDDXExit
.b91d	bd 05 07	lda $0705,x			lda 	SNDQueue+8,x
.b920	9d fd 06	sta $06fd,x			sta 	SNDQueue,x
.b923	e8		inx				inx
.b924	80 f3		bra $b919			bra 	SNDDeleteXFromQueue
.b926					_SNDDXExit:
.b926	60		rts				rts
.06fb					SNDChannelBits:
>06fb							.fill 	1
.b927					SNDQueueRequest:
.b927	86 36		stx $36				stx 	zTemp0						; save queue address
.b929	84 37		sty $37				sty 	zTemp0+1
.b92b	ae fc 06	ldx $06fc			ldx 	SNDLength 					; queue is full, can't take any more.
.b92e	e0 20		cpx #$20			cpx 	#SNDQueueSize
.b930	f0 21		beq $b953			beq 	_SNDQRExit
.b932	29 03		and #$03			and 	#3	 						; channel # and push on stack
.b934	48		pha				pha
.b935	8a		txa				txa  								; get offset in queue buffer/
.b936	0a		asl a				asl 	a
.b937	0a		asl a				asl 	a
.b938	0a		asl a				asl 	a
.b939	aa		tax				tax
.b93a	68		pla				pla 								; get back and push again
.b93b	48		pha				pha
.b93c	9d fd 06	sta $06fd,x			sta 	SNDQueue+0,x 				; save the channel #
.b93f	a0 00		ldy #$00			ldy 	#0 							; copy the rest in.
.b941					_SNDQCopy:
.b941	b1 36		lda ($36),y			lda 	(zTemp0),y
.b943	e8		inx				inx
.b944	c8		iny				iny
.b945	9d fd 06	sta $06fd,x			sta 	SNDQueue,x
.b948	c0 06		cpy #$06			cpy 	#6
.b94a	d0 f5		bne $b941			bne 	_SNDQCopy
.b94c	ee fc 06	inc $06fc			inc 	SNDLength 					; bump queue length.
.b94f	68		pla				pla 								; get channel # back
.b950	20 7b b8	jsr $b87b			jsr 	SNDCheckChannel 			; check if channel needs refreshing.
.b953					_SNDQRExit:
.b953	60		rts				rts
.b954					SNDSilenceChannel:
.b954	aa		tax				tax 								; zero time left.
.b955	9e 09 08	stz $0809,x			stz 	SNDTimeLeft,x
.b958	0a		asl a				asl 	a 							; shift into position
.b959	0a		asl a				asl 	a
.b95a	0a		asl a				asl 	a
.b95b	0a		asl a				asl 	a
.b95c	0a		asl a				asl 	a
.b95d	09 9f		ora #$9f			ora 	#$9F 						; write register attenuation $F
.b95f	20 63 b9	jsr $b963			jsr 	SNDWritePorts
.b962	60		rts				rts
.b963					SNDWritePorts:
.b963	64 01		stz $01				stz 	1
.b965	8d 00 d6	sta $d600			sta 	$D600
.b968	8d 10 d6	sta $d610			sta 	$D610
.b96b	60		rts				rts
.b96c					SNDCommand:
.b96c	da		phx				phx
.b96d	5a		phy				phy
.b96e	c9 0f		cmp #$0f			cmp 	#$0F 						; $0F is initialise
.b970	f0 1d		beq $b98f			beq 	_SNDInitialise
.b972	90 28		bcc $b99c			bcc 	_SNDExit
.b974	c9 3f		cmp #$3f			cmp 	#$3F 						; $3F is silence all
.b976	f0 17		beq $b98f			beq 	_SNDSilence
.b978	b0 22		bcs $b99c			bcs 	_SNDExit
.b97a	c9 20		cmp #$20			cmp 	#$20 						; $2x is check playing => A
.b97c	b0 09		bcs $b987			bcs 	_SNDQueryPlay
.b97e	c9 14		cmp #$14			cmp 	#$14 						; $10-$13 is queue sound
.b980	b0 1a		bcs $b99c			bcs 	_SNDExit
.b982	20 27 b9	jsr $b927			jsr 	SNDQueueRequest
.b985	80 15		bra $b99c			bra 	_SNDExit
.b987					_SNDQueryPlay:
.b987	29 03		and #$03			and 	#3 							; get channel #
.b989	aa		tax				tax
.b98a	bd 09 08	lda $0809,x			lda 	SNDTimeLeft,x 				; read time left, if zero then silent
.b98d	80 0d		bra $b99c			bra 	_SNDExit
.b98f					_SNDInitialise:
.b98f					_SNDSilence:
.b98f	9c fc 06	stz $06fc			stz 	SNDLength 					; empty the queue.
.b992	a9 03		lda #$03			lda 	#$3 						; silence channel 0-3.
.b994					_SNDSilenceLoop:
.b994	48		pha				pha
.b995	20 54 b9	jsr $b954			jsr 	SNDSilenceChannel
.b998	68		pla				pla
.b999	3a		dec a				dec 	a
.b99a	10 f8		bpl $b994			bpl 	_SNDSilenceLoop
.b99c					_SNDExit:
.b99c	7a		ply				ply
.b99d	fa		plx				plx
.b99e	60		rts				rts
=32					SNDQueueSize = 32 							; number of queue entries
.06fc					SNDLength:
>06fc							.fill 	1
.06fd					SNDQueue:
>06fd							.fill 	SNDQueueSize * 8
.07fd					SNDPitchLow:
>07fd							.fill 	4
.0801					SNDPitchHigh:
>0801							.fill 	4
.0805					SNDVolume:
>0805							.fill 	4
.0809					SNDTimeLeft:
>0809							.fill 	4
.080d					SNDAdjustLow:
>080d							.fill 	4
.0811					SNDAdjustHigh:
>0811							.fill 	4
.b99f					SNDUpdate:
.b99f	ad 09 08	lda $0809			lda 	SNDTimeLeft+0 				; look at time remaining
.b9a2	f0 05		beq $b9a9			beq 	_SNDUNot0 					; not playing
.b9a4	a2 00		ldx #$00			ldx 	#0 							; so we know which channel to update
.b9a6	20 c8 b9	jsr $b9c8			jsr 	SNDUpdateChannel 			; update it.
.b9a9					_SNDUNot0:
.b9a9	ad 0a 08	lda $080a			lda 	SNDTimeLeft+1
.b9ac	f0 05		beq $b9b3			beq 	_SNDUNot1
.b9ae	a2 01		ldx #$01			ldx 	#1
.b9b0	20 c8 b9	jsr $b9c8			jsr 	SNDUpdateChannel
.b9b3					_SNDUNot1:
.b9b3	ad 0b 08	lda $080b			lda 	SNDTimeLeft+2
.b9b6	f0 05		beq $b9bd			beq 	_SNDUNot2
.b9b8	a2 02		ldx #$02			ldx 	#2
.b9ba	20 c8 b9	jsr $b9c8			jsr 	SNDUpdateChannel
.b9bd					_SNDUNot2:
.b9bd	ad 0c 08	lda $080c			lda 	SNDTimeLeft+3
.b9c0	f0 05		beq $b9c7			beq 	_SNDUNot3
.b9c2	a2 03		ldx #$03			ldx 	#3
.b9c4	20 c8 b9	jsr $b9c8			jsr 	SNDUpdateChannel
.b9c7					_SNDUNot3:
.b9c7	60		rts				rts
.b9c8					SNDUpdateChannel:
.b9c8	c9 ff		cmp #$ff			cmp 	#$FF 						; sound $FF play forever until turned off manually
.b9ca	f0 2c		beq $b9f8			beq 	_SNDUCExit
.b9cc	3a		dec a				dec 	a 							; decrement and update timer
.b9cd	9d 09 08	sta $0809,x			sta 	SNDTimeLeft,x
.b9d0	f0 1d		beq $b9ef			beq 	_SNDUCUpdate 				; if zero, silence channel
.b9d2	bd 0d 08	lda $080d,x			lda 	SNDAdjustLow,x 				; adjust ?
.b9d5	1d 11 08	ora $0811,x			ora 	SNDAdjustHigh,x
.b9d8	f0 1e		beq $b9f8			beq 	_SNDUCExit 					; if zero carry on at current tone.
.b9da	18		clc				clc 								; add adjust, forcing into a 10 bit range
.b9db	bd fd 07	lda $07fd,x			lda 	SNDPitchLow,x
.b9de	7d 0d 08	adc $080d,x			adc 	SNDAdjustLow,x
.b9e1	9d fd 07	sta $07fd,x			sta 	SNDPitchLow,x
.b9e4	bd 01 08	lda $0801,x			lda 	SNDPitchHigh,x
.b9e7	7d 11 08	adc $0811,x			adc 	SNDAdjustHigh,x
.b9ea	29 03		and #$03			and 	#3
.b9ec	9d 01 08	sta $0801,x			sta 	SNDPitchHigh,x
.b9ef					_SNDUCUpdate:
.b9ef	8a		txa				txa 								; which channel.
.b9f0	48		pha				pha
.b9f1	20 ba b8	jsr $b8ba			jsr 	SNDUpdateNote 				; update the current note
.b9f4	68		pla				pla
.b9f5	20 7b b8	jsr $b87b			jsr 	SNDCheckChannel 			; more to do ?
.b9f8					_SNDUCExit:
.b9f8	60		rts				rts

;******  Return to file: _basic.asm


;******  End of listing
