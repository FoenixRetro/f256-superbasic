
; 64tass Turbo Assembler Macro V1.57.2900 listing file
; 64tass -D AUTORUN=1 "-D MONITOR_ADDRESS=\$E000" "-D LOCKOUT_ADDRESS=\$F000" "-D BASIC_ADDRESS=\$38000" "-D SOURCE_ADDRESS=\$28000" "-D SPRITE_ADDRESS=\$30000" -q -b -Wall -c -D "HARDWARE=0 $'\x9'$'\x9'$'\x9'$'\x9'$'\x9'$'\x9'" -L output/basic.lst -l output/basic.lbl -Wall -o build/basic.rom _basic.asm
; Mon Dec  5 15:43:55 2022

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=1					AUTORUN=1
=$e000					 MONITOR_ADDRESS=$E000
=$f000					 LOCKOUT_ADDRESS=$F000
=$38000					 BASIC_ADDRESS=$38000
=$28000					 SOURCE_ADDRESS=$28000
=$30000					 SPRITE_ADDRESS=$30000
=0					HARDWARE=0

;******  Processing input file: _basic.asm


;******  Processing file: ./common/aa.system/01common.inc

=$30					ZeroPageMandatory = $30
=$50					ZeroPagePreference = $50
=$400					MemoryStorage = $400
=$2000					BasicStart = $2000
=$8000					BasicEnd = $8000
=$8000					CodeStart = $8000
=$1000					VariableSpace = $1000
=$2000					EndVariableSpace = $2000
=8					MathStackSize = 8
=512					BasicStackSize = 512
=3584					BasicStackBase = $1000-BasicStackSize
=80					MaxLineSize = 80

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/02macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/04data.inc

.0030					codePtr:
>0030							.fill 	4
.0034					basicStack:
>0034							.fill 	2
.0036					zTemp0:
>0036							.fill 	2
.0038					zTemp1:
>0038							.fill 	2
.003a					zTemp2:
>003a							.fill 	2
.003c					zsTemp:
>003c							.fill 	2
.003e					zaTemp:
>003e							.fill 	2
=$30					safePtr = codePtr 							; minimise direct tinkering
=$80					NSBIsNegative = $80 						; bit 7 : sign of mantissa (where numeric)
=$20					NSBIsReference = $20 						; bit 5 : is a reference
=$10					NSBIsString = $10 							; bit 4 : set if string (procedures don't go on the stack)
=$18					NSBTypeMask = $18 							; bits 4,3 : 00 int 01 float 10 string 11 procedure
=$03					NSBRefMask = $03 							; bits 0,1 : Bytes of reference, 00 = 4,01 = 1,10=2
=$04					NSBIsArray = $04
=$00					NSTInteger = $00 							; base types for bits 3..4
=$08					NSTFloat = $08
=$10					NSTString = $10
=$18					NSTProcedure = $18
.0050					NSStatus:
>0050							.fill 	MathStackSize
.0058					NSMantissa0:
>0058							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0060					NSMantissa1:
>0060							.fill 	MathStackSize
.0068					NSMantissa2:
>0068							.fill 	MathStackSize
.0070					NSMantissa3:
>0070							.fill 	MathStackSize
.0078					NSExponent:
>0078							.fill 	MathStackSize
.0400					identStart:
>0400							.fill 	1
.0401					identTypeStart:
>0401							.fill 	1
.0402					identTypeEnd:
>0402							.fill 	1
.0403					identHash:
>0403							.fill 	1
.0404					identTypeByte:
>0404							.fill 	1	 						; (see tokenising.pdf)
.0405					encodeState:
>0405							.fill 	1
.0406					digitTemp:
>0406							.fill 	1
.0407					decimalCount:
>0407							.fill 	1
.0408					randomSeed:
>0408							.fill 	4
.040c					lowMemPtr:
>040c							.fill 	2
.040e					stringMemory:
>040e							.fill 	2
.0410					stringInitialised:
>0410							.fill 	1
.0411					stringTempPointer:
>0411							.fill 	2
.0413					breakCheck:
>0413							.fill 	1
.0414					decimalPlaces:
>0414							.fill 	1
.0415					dbOffset:
>0415							.fill 	1
.0416					lastParameter:
>0416							.fill 	1
.0417					dataPointer:
>0417							.fill 	5
.041c					inDataStatement:
>041c							.fill 	1
.041d					tbOffset:
>041d							.fill 	1
.041e					AssemblerAddress:
>041e							.fill 	2
.0420					AssemblerControl:
>0420							.fill 	1
.0421					ParamStart:
>0421							.fill 	2
.0423					IsGroup1:
>0423							.fill 	1
.0424					BaseOpcode:
>0424							.fill 	1
.0425					ModeMask:
>0425							.fill 	1
.0426					listIndent:
>0426							.fill 	1
.0427					lcLastCharacter:
>0427							.fill 	1
.0428					isInputFlag:
>0428							.fill 	1
.0429					currentListColour:
>0429							.fill 	1
.042a					tokenOffset:
>042a							.fill 	1
.042b					tokenLineNumber:
>042b							.fill 	2
.042d					tokenBuffer:
>042d							.fill 	253
.052a					lineBuffer:
>052a							.fill 	253
.0627					numberBuffer:
>0627							.fill 	34
.0649					decimalBuffer:
>0649							.fill 	16

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/constants.inc

=$80					AM_ISZP = $80
=$40					AM_ISG1 = $40
=$20					AM_ISG2 = $20
=224					AM_IMMEDIATE = AM_ISZP+AM_ISG1+AM_ISG2+$00
=228					AM_ZEROPAGE = AM_ISZP+AM_ISG1+AM_ISG2+$04
=40					AM_ACC = AM_ISG2+$08
=108					AM_ABS = AM_ISG1+AM_ISG2+$0C
=208					AM_INDY = AM_ISZP+AM_ISG1+$10
=244					AM_ZEROX = AM_ISZP+AM_ISG1+AM_ISG2+$14
=120					AM_ABSY = AM_ISG1+AM_ISG2+$18
=124					AM_ABSX = AM_ISG1+AM_ISG2+$1C
=209					AM_IND = AM_ISZP+AM_ISG1+$11
=$80					AM_ZEROY = AM_ISZP
=$01					AM_INDABS = $01
=$02					AM_INDABSX = $02
=192					AM_INDX = AM_ISZP+AM_ISG1+$00

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/handlers.inc


;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.inc

=1					ERRID_BREAK = 1
=2					ERRID_SYNTAX = 2
=3					ERRID_DIVZERO = 3
=4					ERRID_RANGE = 4
=5					ERRID_TYPE = 5
=6					ERRID_MEMORY = 6
=7					ERRID_ARGUMENT = 7
=8					ERRID_STOP = 8
=9					ERRID_STRING = 9
=10					ERRID_ASSERT = 10
=11					ERRID_DATA = 11
=12					ERRID_NOTDONE = 12
=13					ERRID_LINE = 13
=14					ERRID_GOSUB = 14
=15					ERRID_REPEAT = 15
=16					ERRID_WHILE = 16
=17					ERRID_FOR = 17
=18					ERRID_STACK = 18
=19					ERRID_STRUCT = 19
=20					ERRID_PROC = 20
=21					ERRID_REDEFINE = 21
=22					ERRID_ARRAYSIZE = 22
=23					ERRID_ARRAYIDX = 23

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst.inc

=$00					KWD_LESSLESS                         = $00; $00 <<
=$01					KWD_LESSEQUAL                        = $01; $01 <=
=$02					KWD_LESSGREATER                      = $02; $02 <>
=$03					KWD_PLINGPLING3                      = $03; $03 !!3
=$04					KWD_GREATERLESS                      = $04; $04 ><
=$05					KWD_GREATEREQUAL                     = $05; $05 >=
=$06					KWD_GREATERGREATER                   = $06; $06 >>
=$07					KWD_PLINGPLING7                      = $07; $07 !!7
=$08					KWD_PLINGPLING8                      = $08; $08 !!8
=$09					KWD_PLINGPLING9                      = $09; $09 !!9
=$0a					KWD_PLINGPLING10                     = $0a; $0a !!10
=$0b					KWD_PLINGPLING11                     = $0b; $0b !!11
=$0c					KWD_PLINGPLING12                     = $0c; $0c !!12
=$0d					KWD_PLINGPLING13                     = $0d; $0d !!13
=$0e					KWD_PLINGPLING14                     = $0e; $0e !!14
=$0f					KWD_PLINGPLING15                     = $0f; $0f !!15
=$10					KWD_AT                               = $10; $10 @
=$11					KWD_PLINGPLING17                     = $11; $11 !!17
=$12					KWD_PLINGPLING18                     = $12; $12 !!18
=$13					KWD_LSQPAREN                         = $13; $13 [
=$14					KWD_BACKSLASH                        = $14; $14 \
=$15					KWD_RSQPAREN                         = $15; $15 ]
=$16					KWD_HAT                              = $16; $16 ^
=$17					KWD_UNDERSCORE                       = $17; $17 _
=$18					KWD_BQUOTE                           = $18; $18 `
=$19					KWD_PLINGPLING25                     = $19; $19 !!25
=$1a					KWD_PLINGPLING26                     = $1a; $1a !!26
=$1b					KWD_LCURLY                           = $1b; $1b {
=$1c					KWD_BAR                              = $1c; $1c |
=$1d					KWD_RCURLY                           = $1d; $1d }
=$1e					KWD_TILDE                            = $1e; $1e ~
=$21					KWD_PLING                            = $21; $21 !
=$22					KWD_DQUOTE                           = $22; $22 "
=$23					KWD_HASH                             = $23; $23 #
=$24					KWD_DOLLAR                           = $24; $24 $
=$25					KWD_PERCENT                          = $25; $25 %
=$26					KWD_AMPERSAND                        = $26; $26 &
=$27					KWD_QUOTE                            = $27; $27 '
=$28					KWD_LPAREN                           = $28; $28 (
=$29					KWD_RPAREN                           = $29; $29 )
=$2a					KWD_STAR                             = $2a; $2a *
=$2b					KWD_PLUS                             = $2b; $2b +
=$2c					KWD_COMMA                            = $2c; $2c ,
=$2d					KWD_MINUS                            = $2d; $2d -
=$2e					KWD_PERIOD                           = $2e; $2e .
=$2f					KWD_SLASH                            = $2f; $2f /
=$30					KWD_0                                = $30; $30 0
=$31					KWD_1                                = $31; $31 1
=$32					KWD_2                                = $32; $32 2
=$33					KWD_3                                = $33; $33 3
=$34					KWD_4                                = $34; $34 4
=$35					KWD_5                                = $35; $35 5
=$36					KWD_6                                = $36; $36 6
=$37					KWD_7                                = $37; $37 7
=$38					KWD_8                                = $38; $38 8
=$39					KWD_9                                = $39; $39 9
=$3a					KWD_COLON                            = $3a; $3a :
=$3b					KWD_SEMICOLON                        = $3b; $3b ;
=$3c					KWD_LESS                             = $3c; $3c <
=$3d					KWD_EQUAL                            = $3d; $3d =
=$3e					KWD_GREATER                          = $3e; $3e >
=$3f					KWD_QMARK                            = $3f; $3f ?
=$83					KWD_ABSLPAREN                        = $83; $83 ABS(
=$84					KWD_ALLOCLPAREN                      = $84; $84 ALLOC(
=$85					KWD_ASCLPAREN                        = $85; $85 ASC(
=$86					KWD_CHRDOLLARLPAREN                  = $86; $86 CHR$(
=$87					KWD_DEEKLPAREN                       = $87; $87 DEEK(
=$88					KWD_EVENTLPAREN                      = $88; $88 EVENT(
=$89					KWD_FALSE                            = $89; $89 FALSE
=$8a					KWD_FRACLPAREN                       = $8a; $8a FRAC(
=$8b					KWD_HITLPAREN                        = $8b; $8b HIT(
=$8c					KWD_INTLPAREN                        = $8c; $8c INT(
=$8d					KWD_ISVALLPAREN                      = $8d; $8d ISVAL(
=$8e					KWD_JOYBLPAREN                       = $8e; $8e JOYB(
=$8f					KWD_JOYXLPAREN                       = $8f; $8f JOYX(
=$90					KWD_JOYYLPAREN                       = $90; $90 JOYY(
=$91					KWD_LEFTDOLLARLPAREN                 = $91; $91 LEFT$(
=$92					KWD_LENLPAREN                        = $92; $92 LEN(
=$93					KWD_MAXLPAREN                        = $93; $93 MAX(
=$94					KWD_MIDDOLLARLPAREN                  = $94; $94 MID$(
=$95					KWD_MINLPAREN                        = $95; $95 MIN(
=$96					KWD_NOTLPAREN                        = $96; $96 NOT(
=$97					KWD_PEEKLPAREN                       = $97; $97 PEEK(
=$98					KWD_PLAYINGLPAREN                    = $98; $98 PLAYING(
=$99					KWD_RANDOMLPAREN                     = $99; $99 RANDOM(
=$9a					KWD_RIGHTDOLLARLPAREN                = $9a; $9a RIGHT$(
=$9b					KWD_RNDLPAREN                        = $9b; $9b RND(
=$9c					KWD_SGNLPAREN                        = $9c; $9c SGN(
=$9d					KWD_SPCLPAREN                        = $9d; $9d SPC(
=$9e					KWD_STRDOLLARLPAREN                  = $9e; $9e STR$(
=$9f					KWD_TIMERLPAREN                      = $9f; $9f TIMER(
=$a0					KWD_TRUE                             = $a0; $a0 TRUE
=$a1					KWD_VALLPAREN                        = $a1; $a1 VAL(
=$a2					KWD_FOR                              = $a2; $a2 FOR
=$a3					KWD_IF                               = $a3; $a3 IF
=$a4					KWD_PROC                             = $a4; $a4 PROC
=$a5					KWD_REPEAT                           = $a5; $a5 REPEAT
=$a6					KWD_WHILE                            = $a6; $a6 WHILE
=$a7					KWD_ENDIF                            = $a7; $a7 ENDIF
=$a8					KWD_ENDPROC                          = $a8; $a8 ENDPROC
=$a9					KWD_NEXT                             = $a9; $a9 NEXT
=$aa					KWD_THEN                             = $aa; $aa THEN
=$ab					KWD_UNTIL                            = $ab; $ab UNTIL
=$ac					KWD_WEND                             = $ac; $ac WEND
=$ad					KWD_BY                               = $ad; $ad BY
=$ae					KWD_CALL                             = $ae; $ae CALL
=$af					KWD_CIRCLE                           = $af; $af CIRCLE
=$b0					KWD_CLEAR                            = $b0; $b0 CLEAR
=$b1					KWD_CLS                              = $b1; $b1 CLS
=$b2					KWD_COLOR                            = $b2; $b2 COLOR
=$b3					KWD_COLOUR                           = $b3; $b3 COLOUR
=$b4					KWD_DATA                             = $b4; $b4 DATA
=$b5					KWD_DIM                              = $b5; $b5 DIM
=$b6					KWD_DOKE                             = $b6; $b6 DOKE
=$b7					KWD_DOWNTO                           = $b7; $b7 DOWNTO
=$b8					KWD_ELSE                             = $b8; $b8 ELSE
=$b9					KWD_FROM                             = $b9; $b9 FROM
=$ba					KWD_GFX                              = $ba; $ba GFX
=$bb					KWD_GOSUB                            = $bb; $bb GOSUB
=$bc					KWD_GOTO                             = $bc; $bc GOTO
=$bd					KWD_HERE                             = $bd; $bd HERE
=$be					KWD_IMAGE                            = $be; $be IMAGE
=$bf					KWD_INPUT                            = $bf; $bf INPUT
=$c0					KWD_LET                              = $c0; $c0 LET
=$c1					KWD_LINE                             = $c1; $c1 LINE
=$c2					KWD_LOCAL                            = $c2; $c2 LOCAL
=$c3					KWD_OFF                              = $c3; $c3 OFF
=$c4					KWD_ON                               = $c4; $c4 ON
=$c5					KWD_OUTLINE                          = $c5; $c5 OUTLINE
=$c6					KWD_PALETTE                          = $c6; $c6 PALETTE
=$c7					KWD_PLOT                             = $c7; $c7 PLOT
=$c8					KWD_POKE                             = $c8; $c8 POKE
=$c9					KWD_PRINT                            = $c9; $c9 PRINT
=$ca					KWD_READ                             = $ca; $ca READ
=$cb					KWD_RECT                             = $cb; $cb RECT
=$cc					KWD_REM                              = $cc; $cc REM
=$cd					KWD_RETURN                           = $cd; $cd RETURN
=$ce					KWD_SOLID                            = $ce; $ce SOLID
=$cf					KWD_SOUND                            = $cf; $cf SOUND
=$d0					KWD_SPRITE                           = $d0; $d0 SPRITE
=$d1					KWD_TEXT                             = $d1; $d1 TEXT
=$d2					KWD_TO                               = $d2; $d2 TO

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst0.inc

=$80					KWC_EOL = $80
=$ff					KWC_STRING = $FF
=$fe					KWC_HEXCONST = $FE
=$a2					KWC_FIRST_STRUCTURE = $a2
=$a7					KWC_FIRST_STRUCTURE_DEC = $a7
=$ac					KWC_LAST_STRUCTURE = $ac
=$83					KWC_FIRST_UNARY = $83
=$a1					KWC_LAST_UNARY = $a1

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/access.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/stack.inc

=$e0					STK_GOSUB = $E0
=$d0					STK_FOR = $D0
=$c0					STK_REPEAT = $C0
=$b0					STK_PROC = $B0
=$a0					STK_WHILE = $A0
=$01					STK_LOCALN = $01
=$02					STK_LOCALS = $02

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/00start.asm

.8000	4c 24 80	jmp $8024	Boot:	jmp 	Start

;******  Processing file: ./common/aa.system/../../../modules/_build/_linker.module

=0					PagingEnabled = 0
.8003					EXTPrintCharacter:
.8003	4c 0b a8	jmp $a80b		jmp	Export_EXTPrintCharacter
.8006					EXTInitialise:
.8006	4c a4 aa	jmp $aaa4		jmp	Export_EXTInitialise
.8009					EXTInputSingleCharacter:
.8009	4c da aa	jmp $aada		jmp	Export_EXTInputSingleCharacter
.800c					EXTBreakCheck:
.800c	4c 00 ab	jmp $ab00		jmp	Export_EXTBreakCheck
.800f					EXTReadController:
.800f	4c 03 ab	jmp $ab03		jmp	Export_EXTReadController
.8012					EXTInputLine:
.8012	4c ba a9	jmp $a9ba		jmp	Export_EXTInputLine
.8015					GXGraphicDraw:
.8015	4c 9e ab	jmp $ab9e		jmp	Export_GXGraphicDraw
.8018					SNDCommand:
.8018	4c 88 be	jmp $be88		jmp	Export_SNDCommand
.801b					SNDUpdate:
.801b	4c bb be	jmp $bebb		jmp	Export_SNDUpdate
.801e					TKListConvertLine:
.801e	4c 7e b8	jmp $b87e		jmp	Export_TKListConvertLine
.8021					TKTokeniseLine:
.8021	4c 12 bb	jmp $bb12		jmp	Export_TKTokeniseLine

;******  Return to file: ./common/aa.system/00start.asm

.8024	a2 ff		ldx #$ff	Start:	ldx 	#$FF 						; stack reset
.8026	9a		txs				txs
.8027	a5 00		lda $00				lda 	0  							; turn on editing of MMU LUT
.8029	09 80		ora #$80			ora 	#$80
.802b	85 00		sta $00				sta 	0
.802d	20 06 80	jsr $8006			jsr 	EXTInitialise 				; hardware initialise
.8030	a9 00		lda #$00			lda 	#0 							; graphics system initialise.
.8032	aa		tax				tax
.8033	a8		tay				tay
.8034	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.8037	a9 0f		lda #$0f			lda 	#$0F 						; initialise sound system
.8039	20 18 80	jsr $8018			jsr 	SNDCommand
.803c	a2 80		ldx #$80			ldx 	#Prompt >> 8 				; display prompt
.803e	a9 4c		lda #$4c			lda 	#Prompt & $FF
.8040	20 77 8f	jsr $8f77			jsr 	PrintStringXA
.8043	20 ee 89	jsr $89ee			jsr 	NewProgram 					; erase current program
.8046	20 e7 82	jsr $82e7			jsr 	BackloadProgram
.8049	4c 2f 8b	jmp $8b2f			jmp 	CommandRun
>804c	46 32 35 36 20 42 41 53		Prompt:	.text 	"F256 BASIC "
>8054	49 43 20

;******  Processing file: ./common/aa.system/../generated/timestamp.asm

>8057	52 65 6c 65 61 73 65 20			.text "Release Alpha 11 (05-Dec-22). "
>805f	41 6c 70 68 61 20 31 31 20 28 30 35 2d 44 65 63
>806f	2d 32 32 29 2e 20

;******  Return to file: ./common/aa.system/00start.asm

>8075	0d 0d 00					.text 	13,13,0

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/assembler.asm

.8078					AssembleGroup1:
.8078	a9 ff		lda #$ff			lda 	#$FF 						; flag for group 1 / mask.
.807a	8d 25 04	sta $0425			sta 	ModeMask 					; initialise the mode mask - all for all
.807d	80 02		bra $8081			bra 	AsmGroup12
.807f					AssembleGroup2:
.807f	a9 00		lda #$00			lda 	#$00 						; flag for group 2
.8081					AsmGroup12:
.8081	8d 23 04	sta $0423			sta 	IsGroup1 					; save the 'group 1' flag
.8084	68		pla				pla 								; pop the return address to access the information following.
.8085	fa		plx				plx
.8086	20 0d 81	jsr $810d			jsr 	AccessParameters 			; get opcode and save as base
.8089	8d 24 04	sta $0424			sta 	BaseOpcode
.808c	ad 23 04	lda $0423			lda 	IsGroup1 					; skip if group 1 as we don't have a complex mask.
.808f	d0 08		bne $8099			bne 	_AG12HaveMask
.8091	a9 02		lda #$02			lda 	#2 							; if group 2 the second parameter is the mask
.8093	20 15 81	jsr $8115			jsr 	GetParameter		 		; e.g. which modes are supported for this operand
.8096	8d 25 04	sta $0425			sta 	ModeMask
.8099					_AG12HaveMask:
.8099	20 49 82	jsr $8249			jsr 	TypeAndCalculateOperand 	; get zero page type
.809c	da		phx				phx 								; save found address mode
.809d	20 79 81	jsr $8179			jsr 	AssembleModeX
.80a0	fa		plx				plx  								; restore address mode
.80a1	b0 0b		bcs $80ae			bcs 	_AG12Exit
.80a3	20 af 80	jsr $80af			jsr 	PromoteToAbsolute  			; promote ZP to ABS and try that
.80a6	20 79 81	jsr $8179			jsr 	AssembleModeX
.80a9	b0 03		bcs $80ae			bcs 	_AG12Exit
.80ab	4c be 9f	jmp $9fbe			jmp 	SyntaxError 				; can't do either, so must be wrong mode/operand.
.80ae					_AG12Exit:
.80ae	60		rts				rts
.80af					PromoteToAbsolute:
.80af	a9 6c		lda #$6c			lda 	#AM_ABS 					; lda xx
.80b1	e0 e4		cpx #$e4			cpx 	#AM_ZEROPAGE
.80b3	f0 19		beq $80ce			beq 	_PTADo
.80b5	a9 7c		lda #$7c			lda 	#AM_ABSX 					; lda xx,X
.80b7	e0 f4		cpx #$f4			cpx 	#AM_ZEROX
.80b9	f0 13		beq $80ce			beq 	_PTADo
.80bb	a9 78		lda #$78			lda 	#AM_ABSY 					; lda xx,Y
.80bd	e0 80		cpx #$80			cpx 	#AM_ZEROY
.80bf	f0 0d		beq $80ce			beq 	_PTADo
.80c1	a9 01		lda #$01			lda 	#AM_INDABS 					; lda (xx) (jump)
.80c3	e0 d1		cpx #$d1			cpx 	#AM_IND
.80c5	f0 07		beq $80ce			beq 	_PTADo
.80c7	a9 02		lda #$02			lda 	#AM_INDABSX 				; lda (xx,x) (jump)
.80c9	e0 c0		cpx #$c0			cpx 	#AM_INDX
.80cb	f0 01		beq $80ce			beq 	_PTADo
.80cd	60		rts				rts
.80ce					_PTADo:
.80ce	aa		tax				tax
.80cf	60		rts				rts
.80d0					AssembleGroup3:
.80d0	68		pla				pla 								; get parameters, which is just the opcode.
.80d1	fa		plx				plx
.80d2	20 0d 81	jsr $810d			jsr 	AccessParameters 			; get and output opcode
.80d5	20 25 81	jsr $8125			jsr 	AssemblerWriteByte
.80d8	20 ad 82	jsr $82ad			jsr 	CalculateOperand 			; get a 16 bit operand
.80db	a5 58		lda $58				lda 	NSMantissa0 				; calculate the offset
.80dd	38		sec				sec
.80de	ed 1e 04	sbc $041e			sbc 	AssemblerAddress
.80e1	48		pha				pha 								; LSB in A
.80e2	a5 60		lda $60				lda 	NSMantissa1
.80e4	ed 1f 04	sbc $041f			sbc 	AssemblerAddress+1
.80e7	aa		tax				tax 								; MSB in X
.80e8	68		pla				pla
.80e9	18		clc				clc 								; $80 to easy check $80-$7F, plus 1 for offset error
.80ea	69 7f		adc #$7f			adc 	#$7F
.80ec	90 01		bcc $80ef			bcc 	_AG3NoCarry
.80ee	e8		inx				inx
.80ef					_AG3NoCarry:
.80ef	38		sec				sec 								; fix back and write out anyways.
.80f0	e9 80		sbc #$80			sbc 	#$80
.80f2	20 25 81	jsr $8125			jsr 	AssemblerWriteByte
.80f5	e0 00		cpx #$00			cpx 	#0 							; was it in range
.80f7	f0 0a		beq $8103			beq 	_AG3Exit
.80f9	ad 20 04	lda $0420			lda 	AssemblerControl 			; are we allowing bad values ?
.80fc	29 01		and #$01			and 	#1
.80fe	f0 03		beq $8103			beq 	_AG3Exit
.8100	4c c3 9f	jmp $9fc3			jmp 	RangeError 					; no, branch is out of range
.8103					_AG3Exit:
.8103	60		rts				rts
.8104					AssembleGroup4:
.8104	68		pla				pla 								; pop address
.8105	fa		plx				plx
.8106	20 0d 81	jsr $810d			jsr 	AccessParameters 			; access and get first
.8109	20 25 81	jsr $8125			jsr 	AssemblerWriteByte 			; output it.
.810c	60		rts				rts
.810d					AccessParameters:
.810d	8d 21 04	sta $0421			sta 	ParamStart
.8110	8e 22 04	stx $0422			stx 	ParamStart+1
.8113	a9 01		lda #$01			lda 	#1
.8115					GetParameter:
.8115	5a		phy				phy
.8116	a8		tay				tay
.8117	ad 21 04	lda $0421			lda 	ParamStart
.811a	85 36		sta $36				sta 	zTemp0
.811c	ad 22 04	lda $0422			lda 	ParamStart+1
.811f	85 37		sta $37				sta 	zTemp0+1
.8121	b1 36		lda ($36),y			lda 	(zTemp0),y
.8123	7a		ply				ply
.8124	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/aswrite.asm

.8125					AssemblerWriteByte:
.8125	48		pha			pha
.8126	ad 20 04	lda $0420		lda 	AssemblerControl 				; check printing bytes ?
.8129	29 02		and #$02		and 	#2
.812b	f0 1b		beq $8148		beq 	_AWBNoPrint
.812d	ad 1f 04	lda $041f		lda		AssemblerAddress+1 				; print address
.8130	20 63 81	jsr $8163		jsr 	PrintHex
.8133	ad 1e 04	lda $041e		lda		AssemblerAddress
.8136	20 63 81	jsr $8163		jsr 	PrintHex
.8139	a9 20		lda #$20		lda 	#' '
.813b	20 03 80	jsr $8003		jsr 	EXTPrintCharacter
.813e	68		pla			pla 									; print byte
.813f	48		pha			pha
.8140	20 63 81	jsr $8163		jsr 	PrintHex
.8143	a9 0d		lda #$0d		lda 	#13
.8145	20 03 80	jsr $8003		jsr 	EXTPrintCharacter
.8148					_AWBNoPrint:
.8148	ad 1e 04	lda $041e		lda		AssemblerAddress				; copy address to zTemp0
.814b	85 36		sta $36			sta 	zTemp0
.814d	ad 1f 04	lda $041f		lda		AssemblerAddress+1
.8150	f0 0e		beq $8160		beq 	_AWBRange
.8152	85 37		sta $37			sta 	zTemp0+1
.8154	68		pla			pla 									; write byte out
.8155	92 36		sta ($36)		sta 	(zTemp0)
.8157	ee 1e 04	inc $041e		inc 	AssemblerAddress 				; bump address
.815a	d0 03		bne $815f		bne 	_AWBNoCarry
.815c	ee 1f 04	inc $041f		inc 	AssemblerAddress+1
.815f					_AWBNoCarry:
.815f	60		rts			rts
.8160					_AWBRange:
.8160	4c c3 9f	jmp $9fc3		jmp 	RangeError
.8163					PrintHex:
.8163	48		pha				pha
.8164	4a		lsr a				lsr 	a
.8165	4a		lsr a				lsr 	a
.8166	4a		lsr a				lsr 	a
.8167	4a		lsr a				lsr 	a
.8168	20 6c 81	jsr $816c			jsr 	_PrintNibble
.816b	68		pla				pla
.816c					_PrintNibble:
.816c	29 0f		and #$0f			and 	#15
.816e	c9 0a		cmp #$0a			cmp 	#10
.8170	90 02		bcc $8174			bcc 	_NoShift
.8172	69 06		adc #$06			adc 	#6
.8174					_NoShift:
.8174	69 30		adc #$30			adc 	#48
.8176	4c 03 80	jmp $8003			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/instruction.asm

.8179					AssembleModeX:
.8179	5a		phy				phy
.817a	ad 23 04	lda $0423			lda 	IsGroup1
.817d	f0 17		beq $8196			beq 	_AMXGroup2
.817f	8a		txa				txa 							; is it in group # 1
.8180	29 40		and #$40			and 	#AM_ISG1
.8182	f0 4d		beq $81d1			beq 	_AMXFail 				; no, give up.
.8184	8a		txa				txa 							; get back.
.8185	29 1f		and #$1f			and 	#$1F 					; this is now the offset.
.8187	e0 e0		cpx #$e0			cpx 	#AM_IMMEDIATE 			; if not immediate, we can continue.
.8189	d0 22		bne $81ad			bne 	_AMXHaveInfo
.818b	ad 24 04	lda $0424			lda 	BaseOpcode 				; cannot store immediate.
.818e	c9 81		cmp #$81			cmp 	#$81
.8190	f0 3f		beq $81d1			beq 	_AMXFail
.8192	a9 08		lda #$08			lda 	#8 						; if immediate we use offset 8.
.8194	80 17		bra $81ad			bra 	_AMXHaveInfo 			; odd design decision there.
.8196					_AMXGroup2:
.8196	8a		txa				txa 							; is it in group 2 ?
.8197	29 20		and #$20			and 	#AM_ISG2
.8199	f0 36		beq $81d1			beq 	_AMXFail 				; no, give up.
.819b	8a		txa				txa 							; get the offset into Y
.819c	29 1f		and #$1f			and 	#$1F
.819e	4a		lsr a				lsr 	a 						; make it 0-7.
.819f	4a		lsr a				lsr  	a
.81a0	a8		tay				tay
.81a1	ad 25 04	lda $0425			lda 	ModeMask 				; shift the modemask left so you can check it against the requested offset
.81a4					_AMXCheckOkay:
.81a4	0a		asl a				asl 	a 						; shift modemask left enough times to check legitimate.
.81a5	88		dey				dey
.81a6	10 fc		bpl $81a4			bpl 	_AMXCheckOkay
.81a8	90 27		bcc $81d1			bcc 	_AMXFail 				; not allowed.
.81aa	8a		txa				txa  							; get mask back
.81ab	29 1f		and #$1f			and 	#$1F
.81ad					_AMXHaveInfo:
.81ad	e0 00		cpx #$00			cpx 	#$00 					; does it *require* an 8 bit operand
.81af	10 04		bpl $81b5			bpl 	_AMXAnySize 			; checking bit 7, the zero page opcode flag.
.81b1	a4 60		ldy $60				ldy 	NSMantissa1 			; fail if it is outside range, e.g. the MSB is set.
.81b3	d0 1c		bne $81d1			bne 	_AMXFail
.81b5					_AMXAnySize:
.81b5	18		clc				clc 							; add offset to the base opcode
.81b6	6d 24 04	adc $0424			adc 	BaseOpcode
.81b9					_AMXOutputCode:
.81b9	20 25 81	jsr $8125			jsr 	AssemblerWriteByte 		; write the opcode out.
.81bc	e0 28		cpx #$28			cpx 	#AM_ACC 				; A mode (e.g. ASL)
.81be	f0 0e		beq $81ce			beq 	_AMXExit
.81c0	a5 58		lda $58				lda 	NSMantissa0 			; write LSB operand
.81c2	20 25 81	jsr $8125			jsr 	AssemblerWriteByte
.81c5	e0 00		cpx #$00			cpx 	#$00 					; zeropage ?
.81c7	30 05		bmi $81ce			bmi 	_AMXExit
.81c9	a5 60		lda $60				lda 	NSMantissa1 			; write MSB operand
.81cb	20 25 81	jsr $8125			jsr 	AssemblerWriteByte
.81ce					_AMXExit:
.81ce	7a		ply				ply
.81cf	38		sec				sec
.81d0	60		rts				rts
.81d1					_AMXFail:
.81d1	a0 00		ldy #$00			ldy 	#0
.81d3					_AMXCheckOddities:
.81d3	8a		txa				txa
.81d4	d9 fb 81	cmp $81fb,y			cmp 	ExtraOpcode+2,y 		; match address mode
.81d7	d0 15		bne $81ee			bne 	_AMXCONext
.81d9	b9 f9 81	lda $81f9,y			lda 	ExtraOpcode+0,y 		; do the base opcodes match
.81dc	cd 24 04	cmp $0424			cmp 	BaseOpcode
.81df	d0 0d		bne $81ee			bne 	_AMXCONext
.81e1	e0 00		cpx #$00			cpx 	#$00 					; requires zero page ?
.81e3	10 04		bpl $81e9			bpl 	_AMXCONotZero
.81e5	a5 60		lda $60				lda 	NSMantissa1
.81e7	d0 05		bne $81ee			bne 	_AMXCONext
.81e9					_AMXCONotZero:
.81e9	b9 fa 81	lda $81fa,y			lda 	ExtraOpcode+1,y 		; get new opcode
.81ec	80 cb		bra $81b9			bra 	_AMXOutputCode 			; and assemble it
.81ee					_AMXCONext:
.81ee	c8		iny				iny
.81ef	c8		iny				iny
.81f0	c8		iny				iny
.81f1	b9 f9 81	lda $81f9,y			lda 	ExtraOpcode+0,y 		; end of table
.81f4	d0 dd		bne $81d3			bne 	_AMXCheckOddities
.81f6					_AMXCOFail:
.81f6	7a		ply				ply
.81f7	18		clc				clc
.81f8	60		rts				rts
.81f9					ExtraOpcode:
>81f9	40 6c 01					.byte $40,$6c,AM_INDABS 	; jump
>81fc	40 7c 02					.byte $40,$7C,AM_INDABSX 	; jump
>81ff	a2 be 78					.byte $a2,$BE,AM_ABSY 		; ldx
>8202	a2 b6 80					.byte $a2,$B6,AM_ZEROY 		; ldx
>8205	82 96 80					.byte $82,$96,AM_ZEROY 		; stx
>8208	e2 1a 28					.byte $e2,$1a,AM_ACC 		; inc
>820b	c2 3a 28					.byte $c2,$3a,AM_ACC 		; dec
>820e	20 89 e0					.byte $20,$89,AM_IMMEDIATE 	; bit
>8211	60 9c 6c					.byte $60,$9c,AM_ABS 		; stz
>8214	60 9e 7c					.byte $60,$9e,AM_ABSX 		; stz
>8217	00						.byte $00

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/label.asm

.8218					LabelHere:
.8218	c8		iny				iny 								; skip .
.8219	a2 00		ldx #$00			ldx 	#0 							; get a term
.821b	20 6c 98	jsr $986c			jsr 	EvaluateTerm
.821e	a5 50		lda $50				lda 	NSStatus 					; needs to be an integer reference.
.8220	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.8222	d0 22		bne $8246			bne 	_ALType 					; otherwise typing error
.8224	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy reference address to zTemp0
.8226	85 36		sta $36				sta 	zTemp0 						; (e.g. where we store the address)
.8228	b5 60		lda $60,x			lda 	NSMantissa1,x
.822a	85 37		sta $37				sta 	zTemp0+1
.822c	5a		phy				phy 								; copy address in (64k)
.822d	a0 01		ldy #$01			ldy 	#1
.822f	ad 1e 04	lda $041e			lda	 	AssemblerAddress
.8232	92 36		sta ($36)			sta 	(zTemp0)
.8234	ad 1f 04	lda $041f			lda	 	AssemblerAddress+1
.8237	91 36		sta ($36),y			sta 	(zTemp0),y
.8239	c8		iny				iny
.823a	a9 00		lda #$00			lda 	#0 							; zero the rest.
.823c	91 36		sta ($36),y			sta 	(zTemp0),y
.823e	c8		iny				iny
.823f	91 36		sta ($36),y			sta 	(zTemp0),y
.8241	c8		iny				iny
.8242	91 36		sta ($36),y			sta 	(zTemp0),y
.8244	7a		ply				ply
.8245	60		rts				rts
.8246					_ALType:
.8246	4c c8 9f	jmp $9fc8			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/operands.asm

.8249					TypeAndCalculateOperand:
.8249	b1 30		lda ($30),y			lda 	(codePtr),y
.824b	a2 28		ldx #$28			ldx 	#AM_ACC 					; ACC if : or EOL
.824d	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.824f	f0 5b		beq $82ac			beq 	_TACOExit
.8251	c9 80		cmp #$80			cmp 	#KWC_EOL
.8253	f0 57		beq $82ac			beq 	_TACOExit
.8255	c8		iny				iny
.8256	a2 e0		ldx #$e0			ldx 	#AM_IMMEDIATE
.8258	c9 23		cmp #$23			cmp 	#KWD_HASH 					; if hash, then immediate - constant.
.825a	f0 51		beq $82ad			beq 	CalculateOperand
.825c	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; if ( then check for indirection
.825e	f0 1f		beq $827f			beq 	_TACOIndirect
.8260	88		dey				dey 								; undo get of first character
.8261	20 ad 82	jsr $82ad			jsr 	CalculateOperand 			; get operand
.8264	b1 30		lda ($30),y			lda 	(codePtr),y
.8266	a2 e4		ldx #$e4			ldx 	#AM_ZEROPAGE 				; if not, try zero page (then absolute)
.8268	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.826a	d0 40		bne $82ac			bne 	_TACOExit
.826c	c8		iny				iny
.826d	20 b7 82	jsr $82b7			jsr 	TACOCheckXY 				; extract X,Y or 0 (neither) from the variable.
.8270	a2 f4		ldx #$f4			ldx 	#AM_ZEROX 					; check for X
.8272	c9 58		cmp #$58			cmp 	#'X'
.8274	f0 36		beq $82ac			beq 	_TACOExit
.8276	a2 80		ldx #$80			ldx 	#AM_ZEROY 					; check for Y
.8278	c9 59		cmp #$59			cmp 	#'Y'
.827a	f0 30		beq $82ac			beq 	_TACOExit
.827c					_TACOSyntax:
.827c	4c be 9f	jmp $9fbe			jmp 	SyntaxError
.827f					_TACOIndirect:
.827f	20 ad 82	jsr $82ad			jsr 	CalculateOperand 			; get the operand
.8282	b1 30		lda ($30),y			lda 	(codePtr),y
.8284	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if , then it must be ,X)
.8286	f0 17		beq $829f			beq 	_TACOIndX
.8288	20 05 8f	jsr $8f05			jsr 	CheckRightBracket  			; otherwise must be ) or ),Y
.828b	b1 30		lda ($30),y			lda 	(codePtr),y
.828d	a2 d1		ldx #$d1			ldx 	#AM_IND
.828f	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not comma then exit with (xx)
.8291	d0 19		bne $82ac			bne 	_TACOExit
.8293	c8		iny				iny
.8294	20 b7 82	jsr $82b7			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.8297	c9 59		cmp #$59			cmp 	#'Y' 						; check Y
.8299	d0 e1		bne $827c			bne 	_TACOSyntax
.829b	a2 d0		ldx #$d0			ldx 	#AM_INDY
.829d	80 0d		bra $82ac			bra 	_TACOExit
.829f					_TACOIndX:
.829f	c8		iny				iny
.82a0	20 b7 82	jsr $82b7			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.82a3	c9 58		cmp #$58			cmp 	#'X' 						; check X
.82a5	d0 d5		bne $827c			bne 	_TACOSyntax
.82a7	20 05 8f	jsr $8f05			jsr 	CheckRightBracket			; check )
.82aa	a2 c0		ldx #$c0			ldx 	#AM_INDX
.82ac					_TACOExit:
.82ac	60		rts				rts
.82ad					CalculateOperand:
.82ad	48		pha				pha
.82ae	da		phx				phx
.82af	a2 00		ldx #$00			ldx 	#0 							; get 16 bit integer in Slot 0
.82b1	20 c0 9d	jsr $9dc0			jsr 	Evaluate16BitInteger
.82b4	fa		plx				plx
.82b5	68		pla				pla
.82b6	60		rts				rts
.82b7					TACOCheckXY:
.82b7	b1 30		lda ($30),y			lda 	(codePtr),y
.82b9	29 c0		and #$c0			and 	#$C0 						; check it is an identifier reference.
.82bb	c9 40		cmp #$40			cmp 	#$40
.82bd	d0 21		bne $82e0			bne 	_TCXYFail
.82bf	b1 30		lda ($30),y			lda 	(codePtr),y
.82c1	18		clc				clc
.82c2	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.82c4	85 37		sta $37				sta 	zTemp0+1
.82c6	c8		iny				iny
.82c7	b1 30		lda ($30),y			lda 	(codePtr),y
.82c9	c8		iny				iny
.82ca	85 36		sta $36				sta 	zTemp0
.82cc	5a		phy				phy 								; save position
.82cd	a0 02		ldy #$02			ldy 	#2 							; type is integer ?
.82cf	b1 36		lda ($36),y			lda 	(zTemp0),y
.82d1	d0 0c		bne $82df			bne 	_TCXYPopFail
.82d3	a0 08		ldy #$08			ldy 	#8 							; get first character, should have bit 7 set as also last.
.82d5	b1 36		lda ($36),y			lda 	(zTemp0),y
.82d7	c9 d8		cmp #$d8			cmp 	#'X'+$80 					; should be X or Y
.82d9	f0 08		beq $82e3			beq 	_TCXYFound
.82db	c9 d9		cmp #$d9			cmp 	#'Y'+$80
.82dd	f0 04		beq $82e3			beq 	_TCXYFound
.82df					_TCXYPopFail:
.82df	7a		ply				ply
.82e0					_TCXYFail:
.82e0	a9 00		lda #$00			lda 	#0
.82e2	60		rts				rts
.82e3					_TCXYFound:
.82e3	7a		ply				ply 								; restore position
.82e4	29 7f		and #$7f			and 	#$7F 						; throw bit 7
.82e6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/backload.asm

.82e7					BackloadProgram:
.82e7	20 ee 89	jsr $89ee			jsr 	NewProgram 					; does the actual NEW.
.82ea	a2 83		ldx #$83			ldx 	#_BLLoad >> 8
.82ec	a9 3b		lda #$3b			lda 	#_BLLoad & $FF
.82ee	20 77 8f	jsr $8f77			jsr 	PrintStringXA
.82f1	a5 0b		lda $0b				lda 	8+3 						; save current mapping for $6000
.82f3	48		pha				pha
.82f4	a9 14		lda #$14			lda 	#SOURCE_ADDRESS >> 13 		; map source code in there.
.82f6	85 0b		sta $0b				sta 	8+3
.82f8	a9 00		lda #$00			lda 	#(($6000) & $FF)
.82fa	8d 59 06	sta $0659			sta 	0+BackLoadPointer
.82fd	a9 60		lda #$60			lda 	#(($6000) >> 8)
.82ff	8d 5a 06	sta $065a			sta 	1+BackLoadPointer
.8302	a9 ff		lda #$ff			lda 	#$FF
.8304	8d fa ff	sta $fffa			sta 	$FFFA
.8307					_BPLoop:
.8307	a2 ff		ldx #$ff			ldx 	#$FF
.8309	20 50 83	jsr $8350			jsr 	BLReadByte 					; read a byte
.830c	c9 00		cmp #$00			cmp 	#0
.830e	f0 21		beq $8331			beq 	_BPExit 					; if 0 exit
.8310	30 1f		bmi $8331			bmi 	_BPExit 					; if -ve exit
.8312					_BPCopy:
.8312	e8		inx				inx  								; copy byte into the lineBuffer
.8313	9d 2a 05	sta $052a,x			sta 	lineBuffer,x
.8316	9e 2b 05	stz $052b,x			stz 	lineBuffer+1,x
.8319	20 50 83	jsr $8350			jsr 	BLReadByte 					; read next byte
.831c	30 0a		bmi $8328			bmi 	_BPEndLine 					; -ve = EOL
.831e	c9 09		cmp #$09			cmp 	#9 							; handle TAB, make it space.
.8320	d0 02		bne $8324			bne 	_BPNotTab
.8322	a9 20		lda #$20			lda 	#' '
.8324					_BPNotTab:
.8324	c9 20		cmp #$20			cmp 	#' ' 						; < ' ' = EOL
.8326	b0 ea		bcs $8312			bcs 	_BPCopy 					; until a control character, should be 13 received.
.8328					_BPEndLine:
.8328	20 21 80	jsr $8021			jsr 	TKTokeniseLine 				; tokenise the line.
.832b	ea		nop				nop
.832c	20 72 83	jsr $8372			jsr 	EditProgramCode
.832f	80 d6		bra $8307			bra 	_BPLoop
.8331					_BPExit:
.8331	68		pla				pla 								; restore memory setup.
.8332	85 0b		sta $0b				sta 	8+3
.8334	9c fa ff	stz $fffa			stz 	$FFFA
.8337	20 2d 84	jsr $842d			jsr 	ClearCommand 				; clear variables etc.
.833a	60		rts				rts
.833b					_BLLoad:
>833b	4c 6f 61 64 69 6e 67 20				.text 	"Loading from Memory",13,0
>8343	66 72 6f 6d 20 4d 65 6d 6f 72 79 0d 00
.8350					BLReadByte:
.8350	ad 59 06	lda $0659			lda 	BackLoadPointer 			; copy pointer to zTemp0
.8353	85 36		sta $36				sta 	zTemp0
.8355	ad 5a 06	lda $065a			lda 	BackLoadPointer+1
.8358	85 37		sta $37				sta 	zTemp0+1
.835a	b2 36		lda ($36)			lda 	(zTemp0) 					; read next byte
.835c	ee 59 06	inc $0659			inc 	BackLoadPointer 			; bump pointer
.835f	d0 0e		bne $836f			bne 	_BLNoCarry
.8361	ee 5a 06	inc $065a			inc 	BackLoadPointer+1
.8364	10 09		bpl $836f			bpl 	_BLNoCarry 					; need a new page
.8366	48		pha				pha
.8367	a9 60		lda #$60			lda 	#$60 						; reset pointer
.8369	8d 5a 06	sta $065a			sta 	BackLoadPointer+1
.836c	e6 0b		inc $0b				inc 	8+3 						; next page from source.
.836e	68		pla				pla
.836f					_BLNoCarry:
.836f	c9 00		cmp #$00			cmp 	#0
.8371	60		rts				rts
.0659					BackLoadPointer:
>0659							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/editor.asm

.8372					EditProgramCode:
.8372	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; try to find the line.
.8375	ae 2c 04	ldx $042c			ldx 	TokenLineNumber+1
.8378	20 ad a5	jsr $a5ad			jsr 	MemorySearch
.837b	90 05		bcc $8382			bcc 	_EPCNoDelete 				; reached the end : don't delete
.837d	d0 03		bne $8382			bne 	_EPCNoDelete 				; found slot but didn't match : no delete
.837f	20 d2 a4	jsr $a4d2			jsr 	MemoryDeleteLine 			; delete the line
.8382					_EPCNoDelete:
.8382	ad 2d 04	lda $042d			lda 	TokenBuffer 				; buffer empty - we just want to delete a line.
.8385	c9 80		cmp #$80			cmp 	#KWC_EOL
.8387	f0 0d		beq $8396			beq 	_EPCNoInsert
.8389	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; find the line - it cannot exist as we've just deleted it.
.838c	ae 2c 04	ldx $042c			ldx 	TokenLineNumber+1 			; so this can't fail, it returns some point in the code.
.838f	20 ad a5	jsr $a5ad			jsr 	MemorySearch
.8392	18		clc				clc 								; insert at this point.
.8393	20 09 a5	jsr $a509			jsr 	MemoryInsertLine 			; insert the line
.8396					_EPCNoInsert:
.8396	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/warmstart.asm

.8397					WarmStart:
.8397	a2 ff		ldx #$ff			ldx 	#$FF
.8399	9a		txs				txs
.839a	a9 85		lda #$85			lda 	#CLICommandLine+$80 		; set console colour whatever the current colour is.
.839c	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.839f	20 12 80	jsr $8012			jsr 	EXTInputLine 				; get line to lineBuffer
.83a2	20 21 80	jsr $8021			jsr 	TKTokeniseLine 				; tokenise the line
.83a5	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; line number <> 0
.83a8	0d 2c 04	ora $042c			ora 	TokenLineNumber+1
.83ab	d0 17		bne $83c4			bne 	_WSEditCode 				; if so,edit code.
.83ad	9c 2a 04	stz $042a			stz 	TokenOffset 				; zero the "offset", meaning it only runs one line.
.83b0	a9 2a		lda #$2a			lda 	#((TokenOffset) & $FF)
.83b2	85 30		sta $30				sta 	codePtr
.83b4	a9 04		lda #$04			lda 	#((TokenOffset) >> 8)
.83b6	85 31		sta $31				sta 	codePtr+1
.83b8	ad 2d 04	lda $042d			lda 	TokenBuffer 				; nothing to run
.83bb	c9 80		cmp #$80			cmp 	#KWC_EOL
.83bd	f0 d8		beq $8397			beq 	WarmStart
.83bf	20 41 8b	jsr $8b41			jsr 	RUNCodePointerLine 			; execute that line.
.83c2	80 d3		bra $8397			bra 	WarmStart
.83c4					_WSEditCode:
.83c4	20 72 83	jsr $8372			jsr 	EditProgramCode 			; edit the program code
.83c7	20 2d 84	jsr $842d			jsr 	ClearCommand 				; clear all variables etc.
.83ca	80 cb		bra $8397			bra 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assemble.asm

.83cc					AssembleCommand:
.83cc	a2 00		ldx #$00			ldx 	#0
.83ce	20 c0 9d	jsr $9dc0			jsr 	Evaluate16BitInteger 		; start address
.83d1	a5 58		lda $58				lda 	NSMantissa0
.83d3	8d 1e 04	sta $041e			sta 	AssemblerAddress
.83d6	a5 60		lda $60				lda 	NSMantissa1
.83d8	8d 1f 04	sta $041f			sta 	AssemblerAddress+1
.83db	20 0d 8f	jsr $8f0d			jsr 	CheckComma
.83de	20 db 9d	jsr $9ddb			jsr 	Evaluate8BitInteger 		; options 0-3
.83e1	a5 58		lda $58				lda 	NSMantissa0
.83e3	8d 20 04	sta $0420			sta 	AssemblerControl
.83e6	60		rts				rts
.83e7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assert.asm

.83e8					AssertCommand:
.83e8	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.83ea	20 ad 9d	jsr $9dad			jsr 	EvaluateInteger 			; the assert test
.83ed	20 62 9e	jsr $9e62			jsr 	NSMIsZero 					; exit if result is non zero.
.83f0	d0 05		bne $83f7			bne 	_ACExit
.83f2	a9 0a		lda #$0a		lda	#10
.83f4	4c 1e 8f	jmp $8f1e		jmp	ErrorHandler
.83f7					_ACExit:
.83f7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/call.asm

.83f8					CallCommand:
.83f8	a2 00		ldx #$00			ldx 	#0 							; get the routine address to level 0
.83fa	20 c0 9d	jsr $9dc0			jsr 	Evaluate16BitInteger
.83fd					_CCClear
.83fd	e8		inx				inx  								; clear 1,2 and 3 (for A X Y)
.83fe	20 40 9e	jsr $9e40			jsr 	NSMSetZero 					; these are optional sequentially.
.8401	e0 04		cpx #$04			cpx 	#4
.8403	d0 f8		bne $83fd			bne 	_CCClear
.8405	a2 00		ldx #$00			ldx 	#0 							; and keep trying while there are more values.
.8407					_CCCParam:
.8407	b1 30		lda ($30),y			lda 	(codePtr),y
.8409	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.840b	d0 09		bne $8416			bne 	_CCCRun6502
.840d	c8		iny				iny 								; skip comma
.840e	e8		inx				inx	 								; next level
.840f	20 db 9d	jsr $9ddb			jsr 	Evaluate8BitInteger 		; get A/X/Y
.8412	e0 03		cpx #$03			cpx 	#3
.8414	90 f1		bcc $8407			bcc 	_CCCParam 					; done all 3 ?
.8416					_CCCRun6502:
.8416	5a		phy				phy 								; save position
.8417	a5 60		lda $60				lda 	NSMantissa1 				; put address in zTemp0
.8419	85 37		sta $37				sta 	zTemp0+1
.841b	a5 58		lda $58				lda 	NSMantissa0
.841d	85 36		sta $36				sta 	zTemp0
.841f	a5 59		lda $59				lda 	NSMantissa0+1 				; get registers into A X Y
.8421	a6 5a		ldx $5a				ldx 	NSMantissa0+2
.8423	a4 5b		ldy $5b				ldy 	NSMantissa0+3
.8425	20 2a 84	jsr $842a			jsr 	_CCCZTemp0 					; call zTemp0
.8428	7a		ply				ply 								; restore position and exit
.8429	60		rts				rts
.842a					_CCCZTemp0:
.842a	6c 36 00	jmp ($0036)			jmp 	(zTemp0)

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/clear.asm

.842d					ClearCommand:
.842d	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.842f	85 36		sta $36				sta 	0+zTemp0
.8431	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.8433	85 37		sta $37				sta 	1+zTemp0
.8435					_ClearZeroLoop:
.8435	b2 36		lda ($36)			lda 	(zTemp0) 					; end of variables if offset is zero.
.8437	f0 24		beq $845d			beq 	_ClearZeroEnd
.8439	a0 03		ldy #$03			ldy 	#3 							; erase the variables
.843b	a9 00		lda #$00			lda 	#0 							; set all the data to zero.
.843d					_ClearOneVariable:
.843d	91 36		sta ($36),y			sta 	(zTemp0),y
.843f	c8		iny				iny
.8440	c0 08		cpy #$08			cpy 	#8
.8442	d0 f9		bne $843d			bne 	_ClearOneVariable
.8444	a0 02		ldy #$02			ldy 	#2 							; has it been marked procedure
.8446	b1 36		lda ($36),y			lda 	(zTemp0),y
.8448	c9 18		cmp #$18			cmp 	#NSTProcedure
.844a	d0 04		bne $8450			bne 	_ClearNotProcedure
.844c	a9 04		lda #$04			lda 	#NSTInteger+NSBIsArray 		; if so set it back to an integer array
.844e	91 36		sta ($36),y			sta 	(zTemp0),y 					; will be fixed on the pre-run scan.
.8450					_ClearNotProcedure:
.8450	18		clc				clc 								; go to the next variable
.8451	b2 36		lda ($36)			lda 	(zTemp0) 					; offset to next, add to zTemp0
.8453	65 36		adc $36				adc 	zTemp0
.8455	85 36		sta $36				sta 	zTemp0
.8457	90 dc		bcc $8435			bcc 	_ClearZeroLoop
.8459	e6 37		inc $37				inc 	zTemp0+1
.845b	80 d8		bra $8435			bra 	_ClearZeroLoop
.845d					_ClearZeroEnd:
.845d	18		clc				clc
.845e	a5 36		lda $36				lda 	zTemp0
.8460	69 01		adc #$01			adc 	#1
.8462	8d 0c 04	sta $040c			sta 	lowMemPtr
.8465	a5 37		lda $37				lda 	zTemp0+1
.8467	69 00		adc #$00			adc 	#0
.8469	8d 0d 04	sta $040d			sta 	lowMemPtr+1
.846c	20 39 a7	jsr $a739			jsr 	StackReset
.846f	20 9f a7	jsr $a79f			jsr 	StringSystemInitialise
.8472	20 ab 8d	jsr $8dab			jsr 	ProcedureScan
.8475	20 f0 8a	jsr $8af0			jsr 	Command_Restore
.8478	9c 1e 04	stz $041e			stz 	AssemblerAddress
.847b	9c 1f 04	stz $041f			stz 	AssemblerAddress+1
.847e	9c 20 04	stz $0420			stz 	AssemblerControl
.8481	20 53 9a	jsr $9a53			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.8484	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/cls.asm

.8485					ClearScreen:
.8485	5a		phy				phy
.8486	a9 0c		lda #$0c			lda 	#12 						; char code 12 clears the screen.
.8488	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.848b	7a		ply				ply
.848c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/data.asm

.848d					Command_Data:
.848d	a9 3a		lda #$3a			lda 	#KWD_COLON 					; advance to colon/EOL, e.g. ignore anything till then.
.848f	a2 80		ldx #$80			ldx 	#KWC_EOL
.8491	20 fd 8d	jsr $8dfd			jsr 	ScanForward
.8494	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dim.asm

.8495					DimCommand:
.8495	b1 30		lda ($30),y			lda 	(codePtr),y
.8497	29 c0		and #$c0			and 	#$C0
.8499	c9 40		cmp #$40			cmp 	#$40
.849b	d0 7a		bne $8517			bne 	_DCSyntax 				; n o, error.
.849d	b1 30		lda ($30),y			lda 	(codePtr),y
.849f	18		clc				clc
.84a0	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.84a2	85 3f		sta $3f				sta 	zaTemp+1
.84a4	c8		iny				iny
.84a5	b1 30		lda ($30),y			lda 	(codePtr),y
.84a7	c8		iny				iny
.84a8	85 3e		sta $3e				sta 	zaTemp
.84aa	5a		phy				phy
.84ab	a0 02		ldy #$02			ldy 	#2 						; read type byte
.84ad	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84af	29 18		and #$18			and 	#NSBTypeMask 			; check it's not a procedure
.84b1	c9 18		cmp #$18			cmp 	#NSTProcedure
.84b3	f0 62		beq $8517			beq 	_DCSyntax
.84b5	b1 3e		lda ($3e),y			lda 	(zaTemp),y 				; check it's an array
.84b7	29 04		and #$04			and 	#NSBIsArray
.84b9	f0 64		beq $851f			beq 	_DCType
.84bb	a0 04		ldy #$04			ldy 	#4 						; check not already defined
.84bd	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84bf	d0 59		bne $851a			bne 	_DCRedefine
.84c1	7a		ply				ply
.84c2	20 22 85	jsr $8522			jsr 	_DCGetSize 				; get array size, check it.
.84c5	5a		phy				phy
.84c6	a0 05		ldy #$05			ldy 	#5 						; store in first array size slot
.84c8	91 3e		sta ($3e),y			sta 	(zaTemp),y 				; second will be zero.
.84ca	7a		ply				ply 							; is there a second (e.g. ,x)
.84cb	b1 30		lda ($30),y			lda 	(codePtr),y
.84cd	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.84cf	d0 0a		bne $84db			bne 	_DCOneDimension
.84d1	c8		iny				iny 							; skip comma
.84d2	20 22 85	jsr $8522			jsr 	_DCGetSize 				; get 2nd array size
.84d5	5a		phy				phy
.84d6	a0 06		ldy #$06			ldy 	#6 						; store in 2nd array size
.84d8	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84da	7a		ply				ply
.84db					_DCOneDimension:
.84db	5a		phy				phy 							; save position
.84dc	a0 05		ldy #$05			ldy 	#5 						; dimensions + 1 in AX (as zero based)
.84de	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84e0	aa		tax				tax
.84e1	c8		iny				iny
.84e2	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84e4	e8		inx				inx 							; bump them.
.84e5	1a		inc a				inc 	a
.84e6	20 eb 9d	jsr $9deb			jsr 	Multiply8x8 			; work out the total number of elements -> zTemp0
.84e9	a5 37		lda $37				lda 	zTemp0+1 				; don't allow more than 8192 elements whatever
.84eb	29 e0		and #$e0			and 	#$E0
.84ed	d0 23		bne $8512			bne 	_DCSize
.84ef	a0 02		ldy #$02			ldy 	#2 						; get base type
.84f1	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84f3	20 30 85	jsr $8530			jsr 	ScaleByBaseType 		; scale by base type
.84f6	a5 36		lda $36				lda 	zTemp0
.84f8	a6 37		ldx $37				ldx 	zTemp0+1
.84fa	20 15 9a	jsr $9a15			jsr 	AllocateXABytes 		; allocate memory
.84fd	a0 03		ldy #$03			ldy 	#3 						; copy into the address.
.84ff	91 3e		sta ($3e),y			sta 	(zaTemp),y
.8501	c8		iny				iny
.8502	8a		txa				txa
.8503	91 3e		sta ($3e),y			sta 	(zaTemp),y
.8505	7a		ply				ply 							; get position back
.8506	20 05 8f	jsr $8f05			jsr 	CheckRightBracket 		; check )
.8509	b1 30		lda ($30),y			lda 	(codePtr),y
.850b	c8		iny				iny 							; consume in case
.850c	c9 2c		cmp #$2c			cmp 	#KWD_COMMA		 		; if so do another DIM.
.850e	f0 85		beq $8495			beq 	DimCommand
.8510	88		dey				dey 							; undo consume
.8511	60		rts				rts
.8512					_DCSize:
.8512	a9 16		lda #$16		lda	#22
.8514	4c 1e 8f	jmp $8f1e		jmp	ErrorHandler
.8517					_DCSyntax:
.8517	4c be 9f	jmp $9fbe			jmp 	SyntaxError
.851a					_DCRedefine:
.851a	a9 15		lda #$15		lda	#21
.851c	4c 1e 8f	jmp $8f1e		jmp	ErrorHandler
.851f					_DCType:
.851f	4c c8 9f	jmp $9fc8			jmp 	TypeError
.8522					_DCGetSize:
.8522	a2 00		ldx #$00			ldx 	#0 						; get first index.
.8524	20 db 9d	jsr $9ddb			jsr 	Evaluate8BitInteger 	; get array dimension
.8527	c9 00		cmp #$00			cmp 	#0 						; must be 1-254
.8529	f0 e7		beq $8512			beq 	_DCSize
.852b	c9 fe		cmp #$fe			cmp 	#254
.852d	f0 e3		beq $8512			beq 	_DCSize
.852f	60		rts				rts
.8530					ScaleByBaseType:
.8530	29 10		and #$10			and 	#NSBIsString 			; is it string
.8532	d0 19		bne $854d			bne 	_SBBTString
.8534	a5 37		lda $37				lda 	zTemp0+1 				; push value on stack
.8536	48		pha				pha
.8537	a5 36		lda $36				lda 	zTemp0
.8539	48		pha				pha
.853a	06 36		asl $36				asl 	zTemp0 					; x 2
.853c	26 37		rol $37				rol 	zTemp0+1
.853e	06 36		asl $36				asl 	zTemp0 					; x 4
.8540	26 37		rol $37				rol 	zTemp0+1
.8542	68		pla				pla 							; add stacked value = x 5
.8543	65 36		adc $36				adc 	zTemp0
.8545	85 36		sta $36				sta 	zTemp0
.8547	68		pla				pla
.8548	65 37		adc $37				adc 	zTemp0+1
.854a	85 37		sta $37				sta 	zTemp0+1
.854c	60		rts				rts
.854d					_SBBTString:
.854d	06 36		asl $36				asl 	zTemp0
.854f	26 37		rol $37				rol 	zTemp0+1
.8551	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dokepoke.asm

.8552					PokeCommand:
.8552	18		clc				clc
.8553	80 01		bra $8556			bra 	DPCommand
.8555					DokeCommand:
.8555	38		sec				sec
.8556					DPCommand:
.8556	08		php				php									; save on stack, CS = Doke, CC = Poke
.8557	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.8559	20 c0 9d	jsr $9dc0			jsr		Evaluate16BitInteger 		; address
.855c	20 0d 8f	jsr $8f0d			jsr 	CheckComma
.855f	e8		inx				inx
.8560	20 c0 9d	jsr $9dc0			jsr		Evaluate16BitInteger 		; data
.8563	a5 58		lda $58				lda 	NSMantissa0 				; copy address
.8565	85 36		sta $36				sta 	zTemp0
.8567	a5 60		lda $60				lda 	NSMantissa1
.8569	85 37		sta $37				sta 	zTemp0+1
.856b	a5 59		lda $59				lda 	NSMantissa0+1 				; low byte
.856d	92 36		sta ($36)			sta 	(zTemp0)
.856f	28		plp				plp 								; done if POKE
.8570	90 08		bcc $857a			bcc 	_DPExit
.8572	5a		phy				phy 								; write high byte out.
.8573	a0 01		ldy #$01			ldy 	#1
.8575	a5 61		lda $61				lda 	NSMantissa1+1
.8577	91 36		sta ($36),y			sta 	(zTemp0),y
.8579	7a		ply				ply
.857a					_DPExit:
.857a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/end.asm

.857b					EndCommand:
.857b	4c 97 83	jmp $8397			jmp 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/for.asm

.857e					ForCommand:
.857e	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; allocate 18 bytes on the return stack (see above).
.8580	20 d3 a6	jsr $a6d3			jsr 	StackOpen
.8583	a2 00		ldx #$00			ldx 	#0
.8585	20 6c 98	jsr $986c			jsr 	EvaluateTerm
.8588	b5 50		lda $50,x			lda 	NSStatus,x
.858a	c9 20		cmp #$20			cmp 	#NSBIsReference+NSTInteger 	; do we have an integer 4 byte reference.
.858c	d0 47		bne $85d5			bne		_FCError
.858e	a9 3d		lda #$3d			lda 	#KWD_EQUAL 					; =
.8590	20 15 8f	jsr $8f15			jsr 	CheckNextA
.8593	e8		inx				inx
.8594	20 ad 9d	jsr $9dad			jsr 	EvaluateInteger 			; <from> in +1
.8597	b1 30		lda ($30),y			lda 	(codePtr),y
.8599	c8		iny				iny 								; consume it
.859a	48		pha				pha 								; save on stack for later
.859b	c9 b7		cmp #$b7			cmp 	#KWD_DOWNTO
.859d	f0 04		beq $85a3			beq 	_FCNoSyntax
.859f	c9 d2		cmp #$d2			cmp 	#KWD_TO
.85a1	d0 35		bne $85d8			bne 	_FCSyntaxError
.85a3					_FCNoSyntax:
.85a3	e8		inx				inx
.85a4	20 ad 9d	jsr $9dad			jsr 	EvaluateInteger
.85a7	20 18 a7	jsr $a718			jsr 	STKSaveCodePosition 		; save loop back position
.85aa	68		pla				pla 								; restore DOWNTO or TO
.85ab	5a		phy				phy 								; save Y on the stack
.85ac	49 b7		eor #$b7			eor 	#KWD_DOWNTO 				; 0 if DOWNTO, #0 if TO
.85ae	f0 02		beq $85b2			beq 	_FCNotDownTo
.85b0	a9 02		lda #$02			lda 	#2
.85b2					_FCNotDownTo:
.85b2	3a		dec a				dec 	a 							; 255 if DOWNTO, 1 if TO
.85b3	a0 10		ldy #$10			ldy 	#16
.85b5	91 34		sta ($34),y			sta 	(basicStack),y 				; copy that out to the Basic Stack.
.85b7	a0 06		ldy #$06			ldy 	#6 							; this is the address of the loop variable.
.85b9	a5 58		lda $58				lda 	NSMantissa0
.85bb	91 34		sta ($34),y			sta 	(basicStack),y
.85bd	a5 60		lda $60				lda 	NSMantissa1
.85bf	c8		iny				iny
.85c0	91 34		sta ($34),y			sta 	(basicStack),y
.85c2	a0 08		ldy #$08			ldy 	#8 							; set initial index value
.85c4	a2 01		ldx #$01			ldx 	#1
.85c6	20 db 85	jsr $85db			jsr 	FCIntegerToStack
.85c9	a0 0c		ldy #$0c			ldy 	#12 						; set the terminal value
.85cb	a2 02		ldx #$02			ldx 	#2
.85cd	20 db 85	jsr $85db			jsr 	FCIntegerToStack
.85d0	20 f6 85	jsr $85f6			jsr 	CopyIndexToReference
.85d3	7a		ply				ply 								; restore position
.85d4	60		rts				rts
.85d5					_FCError:
.85d5	4c c8 9f	jmp $9fc8			jmp 	TypeError
.85d8					_FCSyntaxError:
.85d8	4c be 9f	jmp $9fbe			jmp 	SyntaxError
.85db					FCIntegerToStack:
.85db	34 50		bit $50,x			bit 	NSStatus,x 					; is the value negative
.85dd	10 03		bpl $85e2			bpl	 	_FCNotNegative
.85df	20 09 9e	jsr $9e09			jsr 	NSMNegateMantissa 			; if so 2's complement the mantissa
.85e2					_FCNotNegative:
.85e2	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy out to the basic stack
.85e4	91 34		sta ($34),y			sta 	(basicStack),y
.85e6	c8		iny				iny
.85e7	b5 60		lda $60,x			lda 	NSMantissa1,x
.85e9	91 34		sta ($34),y			sta 	(basicStack),y
.85eb	c8		iny				iny
.85ec	b5 68		lda $68,x			lda 	NSMantissa2,x
.85ee	91 34		sta ($34),y			sta 	(basicStack),y
.85f0	c8		iny				iny
.85f1	b5 70		lda $70,x			lda 	NSMantissa3,x
.85f3	91 34		sta ($34),y			sta 	(basicStack),y
.85f5	60		rts				rts
.85f6					CopyIndexToReference:
.85f6	5a		phy				phy
.85f7	a0 06		ldy #$06			ldy 	#6 							; copy address-8 to write to zTemp0
.85f9	38		sec				sec 								; (because we copy from offset 8)
.85fa	b1 34		lda ($34),y			lda 	(basicStack),y
.85fc	e9 08		sbc #$08			sbc 	#8
.85fe	85 36		sta $36				sta 	zTemp0
.8600	c8		iny				iny
.8601	b1 34		lda ($34),y			lda 	(basicStack),y
.8603	e9 00		sbc #$00			sbc 	#0
.8605	85 37		sta $37				sta 	zTemp0+1
.8607	a2 04		ldx #$04			ldx 	#4 							; this is the copy counter/
.8609	a0 0b		ldy #$0b			ldy 	#8+3 		 				; the MSB of the mantissa
.860b	b1 34		lda ($34),y			lda 	(basicStack),y
.860d	0a		asl a				asl 	a 							; into carry
.860e	a0 08		ldy #$08			ldy 	#8 							; where to copy from.
.8610	90 14		bcc $8626			bcc 	_CITRNormal
.8612	38		sec				sec
.8613					_CITRNegative:
.8613	a9 00		lda #$00			lda 	#0
.8615	f1 34		sbc ($34),y			sbc 	(basicStack),y
.8617	91 36		sta ($36),y			sta 	(zTemp0),y
.8619	c8		iny				iny
.861a	ca		dex				dex
.861b	d0 f6		bne $8613			bne 	_CITRNegative
.861d	88		dey				dey 								; look at MSB of mantissa
.861e	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set the MSB as negative packed.
.8620	09 80		ora #$80			ora 	#$80
.8622	91 36		sta ($36),y			sta 	(zTemp0),y
.8624	7a		ply				ply
.8625	60		rts				rts
.8626					_CITRNormal:
.8626	b1 34		lda ($34),y			lda 	(basicStack),y 				; copy without negation.
.8628	91 36		sta ($36),y			sta 	(zTemp0),y
.862a	c8		iny				iny
.862b	ca		dex				dex
.862c	d0 f8		bne $8626			bne 	_CITRNormal
.862e	7a		ply				ply 								; and exit.
.862f	60		rts				rts
.8630					NextCommand:
.8630	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; check FOR is TOS
.8632	a2 11		ldx #$11			ldx 	#ERRID_FOR 					; this error
.8634	20 00 a7	jsr $a700			jsr 	StackCheckFrame
.8637	5a		phy				phy
.8638	a0 10		ldy #$10			ldy 	#16 						; get the step count
.863a	b1 34		lda ($34),y			lda 	(basicStack),y
.863c	85 36		sta $36				sta 	zTemp0 						; this is the sign extend
.863e	30 02		bmi $8642			bmi 	_NCStepNeg
.8640	64 36		stz $36				stz 	zTemp0 						; which is 0 or 255
.8642					_NCStepNeg:
.8642	a0 08		ldy #$08			ldy 	#8 							; offset to bump
.8644	a2 04		ldx #$04			ldx 	#4 							; count to bump
.8646	18		clc				clc
.8647					_NCBump:
.8647	71 34		adc ($34),y			adc 	(basicStack),y 				; add it
.8649	91 34		sta ($34),y			sta 	(basicStack),y
.864b	a5 36		lda $36				lda 	zTemp0 						; get sign extend for next time.
.864d	c8		iny				iny 								; next byte
.864e	ca		dex				dex 								; do four times
.864f	d0 f6		bne $8647			bne 	_NCBump
.8651	20 f6 85	jsr $85f6			jsr		CopyIndexToReference		; copy it to the reference variable.
.8654	a0 10		ldy #$10			ldy 	#16 						; get step count again
.8656	b1 34		lda ($34),y			lda 	(basicStack),y
.8658	0a		asl a				asl 	a 							; sign bit to carry
.8659	a9 0c		lda #$0c			lda 	#12 						; offset of LHS = terminal offset
.865b	85 38		sta $38				sta 	zTemp1
.865d	90 02		bcc $8661			bcc 	_NCCompRev 					; use if step is +ve
.865f	a9 08		lda #$08			lda 	#8 							; now the LHS = index value
.8661					_NCCompRev:
.8661	85 38		sta $38				sta 	zTemp1 						; so zTemp0 is the index for LHS
.8663	49 04		eor #$04			eor 	#(8^12) 					; and zTemp0+1 is the index for RHS
.8665	85 39		sta $39				sta 	zTemp1+1
.8667	a2 04		ldx #$04			ldx 	#4 							; bytes to compare
.8669	38		sec				sec
.866a					_NCCompare:
.866a	a4 38		ldy $38				ldy 	zTemp1 						; do compare using the two indices
.866c	b1 34		lda ($34),y			lda 	(basicStack),y
.866e	a4 39		ldy $39				ldy 	zTemp1+1
.8670	f1 34		sbc ($34),y			sbc 	(basicStack),y
.8672	e6 38		inc $38				inc 	zTemp1 						; bump the indices (inc,dex do not change C or V)
.8674	e6 39		inc $39				inc 	zTemp1+1
.8676	ca		dex				dex 								; do it 4 times.
.8677	d0 f1		bne $866a			bne 	_NCCompare
.8679	50 02		bvc $867d			bvc 	_NCNoOverflow 				; convert to signed comparison
.867b	49 80		eor #$80			eor 	#$80
.867d					_NCNoOverflow:
.867d	7a		ply				ply 								; restore Y position
.867e	0a		asl a				asl 	a 							; is bit 7 set.
.867f	90 04		bcc $8685			bcc 	_NCLoopback 				; if no , >= so loop back
.8681	20 f2 a6	jsr $a6f2			jsr 	StackClose 					; exit the loop
.8684	60		rts				rts
.8685					_NCLoopBack:
.8685	20 29 a7	jsr $a729			jsr 	STKLoadCodePosition 		; loop back
.8688	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/gosub.asm

.8689					Command_GOSUB:
.8689	a2 00		ldx #$00			ldx 	#0
.868b	20 c0 9d	jsr $9dc0			jsr 	Evaluate16BitInteger 		; line number in Stack.0
.868e	a9 e3		lda #$e3			lda 	#STK_GOSUB+3
.8690	20 d3 a6	jsr $a6d3			jsr 	StackOpen 					; create frame
.8693	20 18 a7	jsr $a718			jsr 	STKSaveCodePosition 		; save current position
.8696	4c ac 86	jmp $86ac			jmp 	GotoStackX
.8699					Command_RETURN:
.8699	a9 e0		lda #$e0			lda 	#STK_GOSUB 					; check TOS is this
.869b	a2 0e		ldx #$0e			ldx 	#ERRID_GOSUB 				; this error
.869d	20 00 a7	jsr $a700			jsr 	StackCheckFrame
.86a0	20 29 a7	jsr $a729			jsr 	STKLoadCodePosition 		; restore code position
.86a3	20 f2 a6	jsr $a6f2			jsr 	StackClose
.86a6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/goto.asm

.86a7					GotoCommand:
.86a7	a2 00		ldx #$00			ldx 	#0 							; GOTO where
.86a9	20 c0 9d	jsr $9dc0			jsr 	Evaluate16BitInteger
.86ac					GotoStackX:
.86ac	b5 60		lda $60,x			lda  	NSMantissa1,x 				; put line # in XA. I'll keep this even though
.86ae	48		pha				pha 								; it is slightly inefficient, just in cases.
.86af	b5 58		lda $58,x			lda 	NSMantissa0,x
.86b1	fa		plx				plx
.86b2	20 ad a5	jsr $a5ad			jsr 	MemorySearch 				; transfer to line number AX.
.86b5	90 05		bcc $86bc			bcc 	_GotoError 					; not found, off end.
.86b7	d0 03		bne $86bc			bne 	_GotoError 					; not found exactly
.86b9	4c 3a 8b	jmp $8b3a			jmp 	RunNewLine 					; and go straight to new line code.
.86bc					_GotoError:
.86bc	a9 0d		lda #$0d		lda	#13
.86be	4c 1e 8f	jmp $8f1e		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/if.asm

.86c1					IfCommand:
.86c1	a2 00		ldx #$00			ldx 	#0 							; Get the if test.
.86c3	20 8e 9d	jsr $9d8e			jsr 	EvaluateNumber
.86c6	b1 30		lda ($30),y			lda 	(codePtr),y
.86c8	c9 aa		cmp #$aa			cmp 	#KWD_THEN  					; could be THEN <stuff>
.86ca	d0 0a		bne $86d6			bne 	_IFStructured 				; we still support it.
.86cc	c8		iny				iny 								; consume THEN
.86cd	20 62 9e	jsr $9e62			jsr 	NSMIsZero 					; is it zero
.86d0	f0 01		beq $86d3			beq 	_IfFail 					; if fail, go to next line
.86d2	60		rts				rts 								; if THEN just continue
.86d3					_IfFail:
.86d3	4c 22 8b	jmp $8b22			jmp 	EOLCommand
.86d6					_IfStructured:
.86d6	20 62 9e	jsr $9e62			jsr 	NSMIsZero 					; is it zero
.86d9	d0 07		bne $86e2			bne 	_IfExit 					; if not, then continue normally.
.86db	a9 b8		lda #$b8			lda 	#KWD_ELSE 					; look for else/endif
.86dd	a2 a7		ldx #$a7			ldx 	#KWD_ENDIF
.86df	20 fd 8d	jsr $8dfd			jsr 	ScanForward 				; and run from there
.86e2					_IfExit:
.86e2	60		rts				rts
.86e3					ElseCode:
.86e3	a9 a7		lda #$a7			lda 	#KWD_ENDIF 					; else is only run after the if clause succeeds
.86e5	aa		tax				tax 								; so just go to the structure exit
.86e6	20 fd 8d	jsr $8dfd			jsr 	ScanForward
.86e9	60		rts				rts
.86ea					EndIf:
.86ea	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/inputprint.asm

.86eb					Command_Input:
.86eb	a9 ff		lda #$ff			lda 	#$FF 						; set input flag
.86ed	8d 28 04	sta $0428			sta 	IsInputFlag
.86f0	80 03		bra $86f5			bra 	Command_IP_Main
.86f2					Command_Print:
.86f2	9c 28 04	stz $0428			stz 	IsInputFlag 				; clear input flag
.86f5					Command_IP_Main:
.86f5	18		clc				clc 								; carry being clear means last print wasn't comma/semicolon
.86f6					_CPLoop:
.86f6	08		php				php 								; save last action flag
.86f7	b1 30		lda ($30),y			lda 	(codePtr),y
.86f9	c9 80		cmp #$80			cmp  	#KWC_EOL 					; end of line or colon, exit now.
.86fb	f0 54		beq $8751			beq 	_CPExit
.86fd	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.86ff	f0 50		beq $8751			beq 	_CPExit
.8701	68		pla				pla 								; throw last action flag
.8702	b1 30		lda ($30),y			lda 	(codePtr),y
.8704	c8		iny				iny
.8705	c9 3b		cmp #$3b			cmp 	#KWD_SEMICOLON				; is it a semicolon
.8707	f0 45		beq $874e			beq 	_CPContinueWithSameLine
.8709	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; comma
.870b	f0 3c		beq $8749			beq 	_CPTab
.870d	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; apostrophe (new line)
.870f	f0 34		beq $8745			beq 	_CPNewLine
.8711	88		dey				dey 								; undo the get.
.8712	20 20 94	jsr $9420			jsr 	EvaluateExpressionAt0 		; evaluate expression at 0.
.8715	b5 50		lda $50,x			lda 	NSStatus,x 					; read the status
.8717	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.8719	f0 0d		beq $8728			beq 	_CPIsValue 					; no, display it.
.871b	ad 28 04	lda $0428			lda 	IsInputFlag 				; if print, dereference and print.
.871e	f0 05		beq $8725			beq 	_CPIsPrint 					; otherwise display.
.8720	20 5a 87	jsr $875a			jsr 	CIInputValue 				; input a value to the reference
.8723	80 20		bra $8745			bra 	_CPNewLine
.8725					_CPIsPrint:
.8725	20 e5 96	jsr $96e5			jsr 	Dereference 				; dereference if required.
.8728					_CPIsValue:
.8728	b5 50		lda $50,x			lda 	NSStatus,x 					; is it a number
.872a	29 10		and #$10			and 	#NSBIsString
.872c	f0 09		beq $8737			beq 	_CPNumber
.872e	a6 60		ldx $60				ldx 	NSMantissa1 				; string, print the text.
.8730	a5 58		lda $58				lda 	NSMantissa0
.8732	20 bd 87	jsr $87bd			jsr 	CPPrintStringXA
.8735	80 be		bra $86f5			bra 	Command_IP_Main 			; loop round clearing carry so NL if end
.8737					_CPNumber:
.8737	a9 05		lda #$05			lda 	#5 							; maximum decimals
.8739	20 75 9c	jsr $9c75			jsr 	ConvertNumberToString 		; convert to string (in unary str$() function)
.873c	a2 06		ldx #$06			ldx 	#DecimalBuffer >> 8
.873e	a9 49		lda #$49			lda 	#DecimalBuffer & $FF
.8740	20 bd 87	jsr $87bd			jsr 	CPPrintStringXA 			; print it.
.8743	80 b0		bra $86f5			bra 	Command_IP_Main				; loop round clearing carry so NL if end
.8745					_CPNewLine:
.8745	a9 0d		lda #$0d			lda 	#13
.8747	80 02		bra $874b			bra 	_CPPrintChar
.8749					_CPTab:
.8749	a9 09		lda #$09			lda 	#9 							; print TAB
.874b					_CPPrintChar:
.874b	20 d0 87	jsr $87d0			jsr 	CPPrintVector
.874e					_CPContinueWithSameLine:
.874e	38		sec				sec 								; loop round with carry set, which
.874f	80 a5		bra $86f6			bra 	_CPLoop 					; will inhibit final CR
.8751					_CPExit:
.8751	28		plp				plp 								; get last action flag
.8752	b0 05		bcs $8759			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.8754	a9 0d		lda #$0d			lda 	#13 						; print new line
.8756	20 d0 87	jsr $87d0			jsr 	CPPrintVector
.8759					_CPExit2:
.8759	60		rts				rts
.875a					CIInputValue:
.875a	a2 00		ldx #$00			ldx 	#0 							; input a line.
.875c					_CIInputLine:
.875c	20 d3 87	jsr $87d3			jsr 	CPInputVector 				; get key
.875f	c9 0d		cmp #$0d			cmp 	#13 						; 13 = End
.8761	f0 1f		beq $8782			beq 	_CIHaveValue
.8763	c9 08		cmp #$08			cmp 	#8 							; 8 = BS
.8765	f0 11		beq $8778			beq 	_CIBackspace
.8767	c9 20		cmp #$20			cmp 	#32 						; ignore other control characters
.8769	90 f1		bcc $875c			bcc 	_CIInputLine
.876b	e0 50		cpx #$50			cpx 	#80 						; max length
.876d	b0 ed		bcs $875c			bcs 	_CIInputLine
.876f	9d 2a 05	sta $052a,x			sta 	lineBuffer,x
.8772	e8		inx				inx
.8773	20 d0 87	jsr $87d0			jsr 	CPPrintVector 				; echo it.
.8776	80 e4		bra $875c			bra 	_CIInputLine
.8778					_CIBackSpace:
.8778	e0 00		cpx #$00			cpx 	#0 							; nothing to delete
.877a	f0 e0		beq $875c			beq 	_CIInputLine
.877c	20 d0 87	jsr $87d0			jsr 	CPPrintVector 				; echo it.
.877f	ca		dex				dex
.8780	80 da		bra $875c			bra 	_CIInputLine
.8782					_CIHaveValue:
.8782	9e 2a 05	stz $052a,x			stz 	LineBuffer,x 				; ASCIIZ string now in line buffer.
.8785	a5 50		lda $50				lda 	NSStatus 					; was it a string assignment
.8787	29 10		and #$10			and 	#NSBIsString
.8789	f0 17		beq $87a2			beq 	_CIAssignNumber 			; assign a number
.878b	a2 01		ldx #$01			ldx 	#1
.878d	a9 2a		lda #$2a			lda 	#lineBuffer & $FF 			; set up to point to new string
.878f	95 58		sta $58,x			sta 	NSMantissa0,x
.8791	a9 05		lda #$05			lda 	#lineBuffer >> 8
.8793	95 60		sta $60,x			sta 	NSMantissa1,x
.8795	74 68		stz $68,x			stz 	NSMantissa2,x
.8797	74 70		stz $70,x			stz 	NSMantissa3,x
.8799	a9 10		lda #$10			lda 	#NSBIsString 				; so it becomes a string value
.879b	95 50		sta $50,x			sta  	NSStatus,x
.879d	ca		dex				dex 								; X = 0
.879e	20 0f 88	jsr $880f			jsr 	AssignVariable
.87a1	60		rts				rts
.87a2					_CIAssignNumber:
.87a2	a9 2a		lda #$2a			lda 	#lineBuffer & $FF 			; set up to point to new string
.87a4	85 36		sta $36				sta 	zTemp0
.87a6	a9 05		lda #$05			lda 	#lineBuffer >> 8
.87a8	85 37		sta $37				sta 	zTemp0+1
.87aa	a2 01		ldx #$01			ldx 	#1 							; put in slot 1
.87ac	20 f7 9b	jsr $9bf7			jsr 	ValEvaluateZTemp0 			; use the VAL() code
.87af	90 07		bcc $87b8			bcc 	_CIIsOkay
.87b1	a9 3f		lda #$3f			lda 	#"?" 						; error ?
.87b3	20 d0 87	jsr $87d0			jsr 	CPPrintVector
.87b6	80 a2		bra $875a			bra 	CIInputValue
.87b8					_CIIsOkay:
.87b8	ca		dex				dex 								; X = 0
.87b9	20 0f 88	jsr $880f			jsr 	AssignVariable
.87bc	60		rts				rts
.87bd					CPPrintStringXA:
.87bd	5a		phy				phy
.87be	86 37		stx $37				stx 	zTemp0+1
.87c0	85 36		sta $36				sta 	zTemp0
.87c2	a0 00		ldy #$00			ldy 	#0
.87c4					_PSXALoop:
.87c4	b1 36		lda ($36),y			lda 	(zTemp0),y
.87c6	f0 06		beq $87ce			beq 	_PSXAExit
.87c8	20 d0 87	jsr $87d0			jsr 	CPPrintVector
.87cb	c8		iny				iny
.87cc	80 f6		bra $87c4			bra 	_PSXALoop
.87ce					_PSXAExit:
.87ce	7a		ply				ply
.87cf	60		rts				rts
.87d0					CPPrintVector:
.87d0	4c 03 80	jmp $8003			jmp 	EXTPrintCharacter
.87d3					CPInputVector:
.87d3	4c 09 80	jmp $8009			jmp 	EXTInputSingleCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/let.asm

.87d6					LetCommand:
.87d6	a2 00		ldx #$00			ldx 	#0
.87d8	b1 30		lda ($30),y			lda 	(codePtr),y
.87da	c9 10		cmp #$10			cmp 	#KWD_AT
.87dc	d0 14		bne $87f2			bne 	_LCStandard
.87de	c8		iny				iny 								; skip equal
.87df	20 6c 98	jsr $986c			jsr 	EvaluateTerm 				; get a number (the address of the reference)
.87e2	20 e5 96	jsr $96e5			jsr 	Dereference 				; dereference it to a value
.87e5	b5 50		lda $50,x			lda 	NSStatus,x 					; check integer
.87e7	49 20		eor #$20			eor 	#NSBIsReference	 			; toggle reference
.87e9	95 50		sta $50,x			sta 	NSStatus,x
.87eb	29 20		and #$20			and 	#NSBIsReference 			; if it is now a reference, continue
.87ed	d0 0f		bne $87fe			bne 	_LCMain
.87ef	4c c8 9f	jmp $9fc8			jmp 	TypeError 					; was a reference before.
.87f2					_LCStandard:
.87f2	ad 0a 94	lda $940a			lda 	PrecedenceLevel+"*"			; precedence > this
.87f5	20 24 94	jsr $9424			jsr 	EvaluateExpressionAtPrecedence
.87f8	b5 50		lda $50,x			lda 	NSStatus,x 					; is it a reference to an array marked as procedure ?
.87fa	c9 38		cmp #$38			cmp		#NSTProcedure+NSBIsReference
.87fc	f0 0e		beq $880c			beq 	_LetGoProc 					; it's a procedure call.
.87fe					_LCMain:
.87fe	a9 3d		lda #$3d			lda 	#"=" 						; check =
.8800	20 15 8f	jsr $8f15			jsr 	CheckNextA
.8803	e8		inx				inx 								; RHS
.8804	20 85 9d	jsr $9d85			jsr 	EvaluateValue
.8807	ca		dex				dex
.8808	20 0f 88	jsr $880f			jsr 	AssignVariable
.880b	60		rts				rts
.880c					_LetGoProc:
.880c	4c f8 89	jmp $89f8			jmp 	CallProcedure
.880f					AssignVariable:
.880f	b5 50		lda $50,x			lda 	NSStatus,x 					; check the string/number type bits match
.8811	48		pha				pha 								; save a copy
.8812	55 51		eor $51,x			eor 	NSStatus+1,x
.8814	29 10		and #$10			and 	#NSBIsString
.8816	d0 0b		bne $8823			bne 	_ASError
.8818	68		pla				pla 								; get back
.8819	29 10		and #$10			and 	#NSBIsString 				; check type
.881b	d0 03		bne $8820			bne 	_ASString
.881d	4c 23 96	jmp $9623			jmp 	AssignNumber
.8820					_ASString:
.8820	4c 81 96	jmp $9681			jmp 	AssignString
.8823					_ASError:
.8823	4c c8 9f	jmp $9fc8			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/list.asm

.8826					Command_List:
.8826	9c 26 04	stz $0426			stz 	listIndent 					; reset indent.
.8829	b1 30		lda ($30),y			lda 	(codePtr),y
.882b	29 c0		and #$c0			and 	#$C0 				 		; if so, we are list procedure() which is a seperate block
.882d	c9 40		cmp #$40			cmp 	#$40  						; of code.
.882f	f0 6e		beq $889f			beq 	_CLListProcedure
.8831	64 5c		stz $5c				stz		NSMantissa0+4				; set the lower (slot 4) to 0 and upper (slot 7) to $FFFF
.8833	64 64		stz $64				stz 	NSMantissa1+4 				; these are the default top and bottom.
.8835	a9 ff		lda #$ff			lda 	#$FF
.8837	85 5f		sta $5f				sta 	NSMantissa0+7
.8839	85 67		sta $67				sta 	NSMantissa1+7
.883b	b1 30		lda ($30),y			lda 	(codePtr),y
.883d	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.883f	f0 1a		beq $885b			beq 	_CLSecond
.8841	20 1c 89	jsr $891c			jsr 	CLIsDigit 					; if not digit, list all
.8844	b0 20		bcs $8866			bcs 	_CLStart
.8846	a2 04		ldx #$04			ldx 	#4 							; get 1st range into slot 4
.8848	20 c0 9d	jsr $9dc0			jsr 	Evaluate16BitInteger
.884b	b1 30		lda ($30),y			lda 	(codePtr),y
.884d	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.884f	f0 0a		beq $885b			beq 	_CLSecond 					; if so go get it
.8851	a5 5c		lda $5c				lda 	NSMantissa0+4 				; copy 4->7
.8853	85 5f		sta $5f				sta 	NSMantissa0+7
.8855	a5 64		lda $64				lda 	NSMantissa1+4
.8857	85 67		sta $67				sta 	NSMantissa1+7
.8859	80 0b		bra $8866			bra 	_CLStart
.885b					_CLSecond:
.885b	c8		iny				iny 								; consume comma
.885c	20 1c 89	jsr $891c			jsr 	CLIsDigit 					; digit found
.885f	b0 05		bcs $8866			bcs 	_CLStart 					; if not, continue listing
.8861	a2 07		ldx #$07			ldx 	#7 							; load 2nd range into slot 7
.8863	20 c0 9d	jsr $9dc0			jsr 	Evaluate16BitInteger
.8866					_CLStart
.8866	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8868	85 30		sta $30				sta 	codePtr
.886a	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.886c	85 31		sta $31				sta 	codePtr+1
.886e					_CLLoop:
.886e	20 0c 80	jsr $800c			jsr 	EXTBreakCheck 				; break check here, as we want the option of breaking out of long lists.
.8871	f0 27		beq $889a			beq 	_CLBreak
.8873	b2 30		lda ($30)			lda 	(codePtr)
.8875	f0 20		beq $8897			beq 	_CLExit
.8877	a2 04		ldx #$04			ldx 	#4 							; check range every time, line numbers aren't in order.
.8879	20 0b 89	jsr $890b			jsr 	CLCompareLineNo
.887c	90 0c		bcc $888a			bcc 	_CLNext
.887e	a2 07		ldx #$07			ldx 	#7
.8880	20 0b 89	jsr $890b			jsr 	CLCompareLineNo
.8883	f0 02		beq $8887			beq 	_CLDoThisOne
.8885	b0 03		bcs $888a			bcs 	_CLNext
.8887					_CLDoThisOne:
.8887	20 f8 88	jsr $88f8			jsr 	CLListOneLine 				; routine to list the current line.
.888a					_CLNext:
.888a	18		clc				clc
.888b	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.888d	65 30		adc $30				adc 	codePtr
.888f	85 30		sta $30				sta 	codePtr
.8891	90 02		bcc $8895			bcc 	_CREExit
.8893	e6 31		inc $31				inc 	codePtr+1 					; carry
.8895					_CREExit:
.8895	80 d7		bra $886e			bra 	_CLLoop
.8897					_CLExit:
.8897	4c 97 83	jmp $8397			jmp 	WarmStart
.889a					_CLBreak:
.889a	a9 01		lda #$01		lda	#1
.889c	4c 1e 8f	jmp $8f1e		jmp	ErrorHandler
.889f					_CLListProcedure:
.889f	b1 30		lda ($30),y			lda 	(codePtr),y
.88a1	85 38		sta $38				sta 	zTemp1
.88a3	c8		iny				iny
.88a4	b1 30		lda ($30),y			lda 	(codePtr),y
.88a6	85 39		sta $39				sta 	zTemp1+1
.88a8	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.88aa	85 30		sta $30				sta 	codePtr
.88ac	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.88ae	85 31		sta $31				sta 	codePtr+1
.88b0					_CLLPSearch:
.88b0	b2 30		lda ($30)			lda 	(codePtr)
.88b2	c9 00		cmp #$00			cmp 	#0 							; if zero, end
.88b4	f0 e1		beq $8897			beq 	_CLExit
.88b6	a0 03		ldy #$03			ldy 	#3 							; check if PROC something
.88b8	b1 30		lda ($30),y			lda 	(codePtr),y
.88ba	c9 a4		cmp #$a4			cmp 	#KWD_PROC
.88bc	d0 0e		bne $88cc			bne 	_CLLPNext
.88be	c8		iny				iny 								; check if PROC this.
.88bf	b1 30		lda ($30),y			lda 	(codePtr),y
.88c1	c5 38		cmp $38				cmp 	zTemp1 						; does it match ?
.88c3	d0 07		bne $88cc			bne 	_CLLPNext
.88c5	c8		iny				iny
.88c6	b1 30		lda ($30),y			lda 	(codePtr),y
.88c8	c5 39		cmp $39				cmp 	zTemp1+1
.88ca	f0 0d		beq $88d9			beq 	_CLLPFound
.88cc					_CLLPNext:
.88cc	18		clc				clc
.88cd	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.88cf	65 30		adc $30				adc 	codePtr
.88d1	85 30		sta $30				sta 	codePtr
.88d3	90 02		bcc $88d7			bcc 	_CREExit
.88d5	e6 31		inc $31				inc 	codePtr+1 					; carry
.88d7					_CREExit:
.88d7	80 d7		bra $88b0			bra 	_CLLPSearch
.88d9					_CLLPFound:
.88d9	b2 30		lda ($30)			lda 	(codePtr)
.88db	f0 ba		beq $8897			beq 	_CLExit
.88dd	a0 03		ldy #$03			ldy 	#3 							; get first keyword
.88df	b1 30		lda ($30),y			lda 	(codePtr),y
.88e1	48		pha				pha
.88e2	20 f8 88	jsr $88f8			jsr 	CLListOneLine 				; list line and go forward
.88e5	18		clc				clc
.88e6	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.88e8	65 30		adc $30				adc 	codePtr
.88ea	85 30		sta $30				sta 	codePtr
.88ec	90 02		bcc $88f0			bcc 	_CREExit
.88ee	e6 31		inc $31				inc 	codePtr+1 					; carry
.88f0					_CREExit:
.88f0	68		pla				pla 								; reached ENDPROC ?
.88f1	c9 a8		cmp #$a8			cmp 	#KWD_ENDPROC
.88f3	d0 e4		bne $88d9			bne 	_CLLPFound
.88f5	4c 97 83	jmp $8397			jmp 	WarmStart
.88f8					CLListOneLine:
.88f8	20 60 8e	jsr $8e60			jsr 	ScanGetCurrentLineStep 		; get indent adjust.
.88fb	20 1e 80	jsr $801e			jsr 	TKListConvertLine 			; convert line into token Buffer
.88fe	a2 04		ldx #$04			ldx 	#(tokenBuffer >> 8) 		; print that line
.8900	a9 2d		lda #$2d			lda 	#(tokenBuffer & $FF)
.8902	20 77 8f	jsr $8f77			jsr 	PrintStringXA
.8905	a9 0d		lda #$0d			lda 	#13 						; new line
.8907	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.890a	60		rts				rts
.890b					CLCompareLineNo:
.890b	38		sec				sec
.890c	a0 01		ldy #$01			ldy 	#1
.890e	b1 30		lda ($30),y			lda 	(codePtr),y
.8910	f5 58		sbc $58,x			sbc 	NSMantissa0,x
.8912	85 36		sta $36				sta 	zTemp0
.8914	c8		iny				iny
.8915	b1 30		lda ($30),y			lda 	(codePtr),y
.8917	f5 60		sbc $60,x			sbc 	NSMantissa1,x
.8919	05 36		ora $36				ora 	zTemp0
.891b	60		rts				rts
.891c					CLIsDigit:
.891c	b1 30		lda ($30),y			lda 	(codePtr),y
.891e	c9 30		cmp #$30			cmp 	#"0"
.8920	90 03		bcc $8925			bcc	 	_CLIDExitFalse
.8922	c9 3a		cmp #$3a			cmp 	#"9"+1
.8924	60		rts				rts
.8925					_CLIDExitFalse:
.8925	38		sec				sec
.8926	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/local.asm

.8927					Command_LOCAL:
.8927	a2 00		ldx #$00			ldx 	#0 							; at level 0
.8929	20 35 89	jsr $8935			jsr 	LocaliseNextTerm 			; convert term to a local.
.892c	b1 30		lda ($30),y			lda 	(codePtr),y
.892e	c8		iny				iny
.892f	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8931	f0 f4		beq $8927			beq 	Command_LOCAL 				; if so, localise another variable.
.8933	88		dey				dey 								; unpick pre-get
.8934	60		rts				rts
.8935					LocaliseNextTerm:
.8935	20 6c 98	jsr $986c			jsr 	EvaluateTerm 				; evaluate the term
.8938	b5 50		lda $50,x			lda 	NSStatus,x
.893a	29 20		and #$20			and 	#NSBIsReference 			; check it is a reference, must be a variable.
.893c	f0 5c		beq $899a			beq		_LNTError
.893e	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address of variable to zTemp0
.8940	85 36		sta $36				sta 	zTemp0
.8942	b5 60		lda $60,x			lda 	NSMantissa1,x
.8944	85 37		sta $37				sta  	zTemp0+1
.8946	b5 50		lda $50,x			lda 	NSStatus,x 					; figure out what it is.
.8948	29 10		and #$10			and 	#NSBIsString
.894a	d0 1e		bne $896a			bne 	_LNTPushString
.894c	5a		phy				phy
.894d	a0 00		ldy #$00			ldy 	#0 							; push 0 to 4 inclusive, the number values, on the stack, and zero them as you go.
.894f					_LNTPushNumLoop:
.894f	b1 36		lda ($36),y			lda		(zTemp0),y
.8951	20 b2 a6	jsr $a6b2			jsr 	StackPushByte
.8954	c8		iny				iny
.8955	c0 05		cpy #$05			cpy 	#5
.8957	d0 f6		bne $894f			bne 	_LNTPushNumLoop
.8959	a5 36		lda $36				lda 	zTemp0 						; push the actual target address to write on the stack
.895b	20 b2 a6	jsr $a6b2			jsr 	StackPushByte
.895e	a5 37		lda $37				lda 	zTemp0+1
.8960	20 b2 a6	jsr $a6b2			jsr 	StackPushByte
.8963	a9 01		lda #$01			lda 	#STK_LOCALN 				; push local-number marker.
.8965	20 b2 a6	jsr $a6b2			jsr 	StackPushByte
.8968	7a		ply				ply
.8969	60		rts				rts
.896a					_LNTPushString:
.896a	5a		phy				phy
.896b	b2 36		lda ($36)			lda 	(zTemp0) 					; put address of string in zTemp1
.896d	85 38		sta $38				sta 	zTemp1
.896f	a0 01		ldy #$01			ldy 	#1
.8971	b1 36		lda ($36),y			lda 	(zTemp0),y
.8973	85 39		sta $39				sta 	zTemp1+1
.8975	a0 00		ldy #$00			ldy 	#0 							; output string
.8977	c9 00		cmp #$00			cmp 	#0 							; if not assigned string
.8979	f0 0a		beq $8985			beq 	_LNTStringOut
.897b					_LNTPushStrLoop:
.897b	b1 38		lda ($38),y			lda 	(zTemp1),y
.897d	f0 06		beq $8985			beq 	_LNTStringOut
.897f	20 b2 a6	jsr $a6b2			jsr 	StackPushByte
.8982	c8		iny				iny
.8983	80 f6		bra $897b			bra 	_LNTPushStrLoop
.8985					_LNTStringOut:
.8985	98		tya				tya									; output length (chars written).
.8986	20 b2 a6	jsr $a6b2			jsr 	StackPushByte
.8989	b5 58		lda $58,x			lda 	NSMantissa0,x 				; output address of the string record *not* the string itself
.898b	20 b2 a6	jsr $a6b2			jsr 	StackPushByte
.898e	b5 60		lda $60,x			lda 	NSMantissa1,x
.8990	20 b2 a6	jsr $a6b2			jsr 	StackPushByte
.8993	a9 02		lda #$02			lda 	#STK_LOCALS 				; push local-string marker.
.8995	20 b2 a6	jsr $a6b2			jsr 	StackPushByte
.8998	7a		ply				ply
.8999	60		rts				rts
.899a					_LNTError:
.899a	4c be 9f	jmp $9fbe			jmp 	SyntaxError
.899d					LocalPopValue:
.899d	20 ca a6	jsr $a6ca			jsr 	StackPopByte
.89a0	c9 01		cmp #$01			cmp 	#STK_LOCALN 				; if not local-N
.89a2	d0 17		bne $89bb			bne 	_LPVString
.89a4	20 ca a6	jsr $a6ca			jsr 	StackPopByte 				; address
.89a7	85 37		sta $37				sta 	zTemp0+1
.89a9	20 ca a6	jsr $a6ca			jsr 	StackPopByte
.89ac	85 36		sta $36				sta 	zTemp0
.89ae	5a		phy				phy
.89af	a0 04		ldy #$04			ldy 	#4 							; copy back
.89b1					_LPVNumberCopy:
.89b1	20 ca a6	jsr $a6ca			jsr 	StackPopByte
.89b4	91 36		sta ($36),y			sta 	(zTemp0),y
.89b6	88		dey				dey
.89b7	10 f8		bpl $89b1			bpl 	_LPVNumberCopy
.89b9	7a		ply				ply 								; and complete
.89ba	60		rts				rts
.89bb					_LPVString:
.89bb	20 ca a6	jsr $a6ca			jsr 	StackPopByte 				; address of record copied to zTemp0
.89be	85 37		sta $37				sta 	zTemp0+1
.89c0	20 ca a6	jsr $a6ca			jsr 	StackPopByte
.89c3	85 36		sta $36				sta 	zTemp0
.89c5	5a		phy				phy
.89c6	b2 36		lda ($36)			lda 	(zTemp0) 					; address to write string to copied to zTemp1
.89c8	85 38		sta $38				sta 	zTemp1
.89ca	a0 01		ldy #$01			ldy 	#1
.89cc	b1 36		lda ($36),y			lda 	(zTemp0),y
.89ce	85 39		sta $39				sta 	zTemp1+1
.89d0	20 ca a6	jsr $a6ca			jsr 	StackPopByte 				; # chars to get => y
.89d3	a8		tay				tay
.89d4	a5 39		lda $39				lda 	zTemp1+1 					; if no target (e.g. was "" originally) exit
.89d6	f0 0e		beq $89e6			beq 	_LPVStringCopied
.89d8	a9 00		lda #$00			lda 	#0 							; NULL on end
.89da	91 38		sta ($38),y			sta 	(zTemp1),y
.89dc					_LPVStringCopy:
.89dc	88		dey				dey
.89dd	30 07		bmi $89e6			bmi 	_LPVStringCopied
.89df	20 ca a6	jsr $a6ca			jsr 	StackPopByte
.89e2	91 38		sta ($38),y			sta 	(zTemp1),y
.89e4	80 f6		bra $89dc			bra 	_LPVStringCopy
.89e6					_LPVStringCopied:
.89e6	fa		plx				plx
.89e7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/new.asm

.89e8					NewCommand:
.89e8	20 ee 89	jsr $89ee			jsr 	NewProgram 					; does the actual NEW.
.89eb	4c 97 83	jmp $8397			jmp 	WarmStart 					; and warm starts straight away.
.89ee					NewProgram:
.89ee	20 8f a5	jsr $a58f			jsr 	MemoryNew
.89f1	9c 00 10	stz $1000			stz 	VariableSpace 				; erase all variables.
.89f4	20 2d 84	jsr $842d			jsr 	ClearCommand 				; clear everything.
.89f7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/procedure.asm

=2					ParameterStackPos = 2
.89f8					CallProcedure:
.89f8	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start storing parameters at 2.
.89fa	b1 30		lda ($30),y			lda 	(codePtr),y
.89fc	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.89fe	f0 0c		beq $8a0c			beq 	_CPEndParam
.8a00					_CPParamLoop:
.8a00	20 85 9d	jsr $9d85			jsr 	EvaluateValue 				; get parameter onto stack
.8a03	e8		inx				inx 								; bump next stack
.8a04	b1 30		lda ($30),y			lda 	(codePtr),y
.8a06	c8		iny				iny
.8a07	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if comma, go back and try again.
.8a09	f0 f5		beq $8a00			beq 	_CPParamLoop
.8a0b	88		dey				dey 								; unpick.
.8a0c					_CPEndParam:
.8a0c	8e 16 04	stx $0416			stx 	LastParameter 				; save the last parameters index.
.8a0f	c8		iny				iny									; skip right bracket
.8a10	a9 b3		lda #$b3			lda 	#STK_PROC+3 				; allocate 6 bytes on the return stack.
.8a12	20 d3 a6	jsr $a6d3			jsr 	StackOpen
.8a15	20 18 a7	jsr $a718			jsr 	STKSaveCodePosition 		; save loop position
.8a18	a5 58		lda $58				lda 	NSMantissa0 				; copy variable (e.g. procedure) address to zTemp0
.8a1a	85 36		sta $36				sta 	zTemp0 						; this is the DATA not the RECORD
.8a1c	a5 60		lda $60				lda 	NSMantissa1
.8a1e	85 37		sta $37				sta 	zTemp0+1
.8a20	a0 01		ldy #$01			ldy 	#1 							; copy code address back.
.8a22	b2 36		lda ($36)			lda 	(zTemp0)
.8a24	85 30		sta $30				sta 	safePtr
.8a26	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a28	85 31		sta $31				sta 	safePtr+1
.8a2a	c8		iny				iny
.8a2b	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a2d	85 32		sta $32				sta 	safePtr+2
.8a2f	c8		iny				iny
.8a30	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a32	85 33		sta $33				sta 	safePtr+3
.8a34	c8		iny				iny 								; get Y offset -> Y
.8a35	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a37	a8		tay				tay
.8a38	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start position of parameters
.8a3a	ec 16 04	cpx $0416			cpx	 	LastParameter 				; check zero parameters at the start
.8a3d	f0 13		beq $8a52			beq 	_ParamExit 					; if so, exit.
.8a3f					_ParamExtract:
.8a3f	ca		dex				dex 								; put a local term on the level before
.8a40	20 35 89	jsr $8935			jsr 	LocaliseNextTerm			; also pushes original param value to basic stack
.8a43	20 0f 88	jsr $880f			jsr 	AssignVariable 				; assign stacked value to the variable.
.8a46	e8		inx				inx 								; advance to next parameter to do.
.8a47	e8		inx				inx
.8a48	ec 16 04	cpx $0416			cpx 	LastParameter 				; are we done ?
.8a4b	f0 05		beq $8a52			beq 	_ParamExit
.8a4d	20 0d 8f	jsr $8f0d			jsr 	CheckComma 					; comma seperating parameters
.8a50	80 ed		bra $8a3f			bra 	_ParamExtract
.8a52					_ParamExit:
.8a52	20 05 8f	jsr $8f05			jsr 	CheckRightBracket 			; check )
.8a55	60		rts				rts 								; and continue from here
.8a56					Command_ENDPROC:
.8a56	a9 b0		lda #$b0			lda 	#STK_PROC 					; check TOS is this
.8a58	a2 14		ldx #$14			ldx 	#ERRID_PROC
.8a5a	20 00 a7	jsr $a700			jsr 	StackCheckFrame
.8a5d	20 29 a7	jsr $a729			jsr 	STKLoadCodePosition 		; restore code position
.8a60	20 f2 a6	jsr $a6f2			jsr 	StackClose
.8a63	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/read.asm

.8a64					Command_Read:
.8a64	a2 00		ldx #$00			ldx 	#0 							; evaluate the term which is the var/array element to assign
.8a66	20 6c 98	jsr $986c			jsr 	EvaluateTerm
.8a69	b5 50		lda $50,x			lda 	NSStatus,x
.8a6b	29 20		and #$20			and 	#NSBIsReference				; get status byte on stack, identifies int, float, string.
.8a6d	f0 4f		beq $8abe			beq 	_CRSyntax 					; check reference (bit 0) fail if not a reference.
.8a6f	20 07 8b	jsr $8b07			jsr 	SwapDataCodePtrs 			; swap code and data
.8a72	ad 1c 04	lda $041c			lda 	inDataStatement 			; if in a data statement, we don't need to search
.8a75	d0 25		bne $8a9c			bne 	_CRContinueData  			; forward for the next one.
.8a77	b2 30		lda ($30)			lda 	(codePtr)
.8a79	f0 1c		beq $8a97			beq 	_CRNoData
.8a7b					_CRKeepSearching:
.8a7b	a9 b4		lda #$b4			lda 	#KWD_DATA 					; scan for instruction
.8a7d	a2 80		ldx #$80			ldx 	#KWC_EOL
.8a7f	20 fd 8d	jsr $8dfd			jsr 	ScanForward
.8a82	c9 b4		cmp #$b4			cmp 	#KWD_DATA 					; found data ?
.8a84	f0 16		beq $8a9c			beq 	_CRHaveData 				; found it
.8a86	18		clc				clc
.8a87	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8a89	65 30		adc $30				adc 	codePtr
.8a8b	85 30		sta $30				sta 	codePtr
.8a8d	90 02		bcc $8a91			bcc 	_CREExit
.8a8f	e6 31		inc $31				inc 	codePtr+1 					; carry
.8a91					_CREExit:
.8a91	a0 03		ldy #$03			ldy 	#3 							; start of line.
.8a93	b2 30		lda ($30)			lda 	(codePtr)
.8a95	d0 e4		bne $8a7b			bne 	_CRKeepSearching
.8a97					_CRNoData:
.8a97	a9 0b		lda #$0b		lda	#11
.8a99	4c 1e 8f	jmp $8f1e		jmp	ErrorHandler
.8a9c					_CRHaveData:
.8a9c					_CRContinueData:
.8a9c	a2 01		ldx #$01			ldx 	#1
.8a9e	20 85 9d	jsr $9d85			jsr 	EvaluateValue 				; evaluate value into slot # 1
.8aa1	ca		dex				dex
.8aa2	20 0f 88	jsr $880f			jsr		AssignVariable 				; do the assignment
.8aa5	9c 1c 04	stz $041c			stz 	inDataStatement 			; clear in data flag
.8aa8	b1 30		lda ($30),y			lda 	(codePtr),y
.8aaa	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not, end of data statement and exit
.8aac	d0 04		bne $8ab2			bne 	_CRSwapBack
.8aae	c8		iny				iny 								; consume comma
.8aaf	ee 1c 04	inc $041c			inc 	inDataStatement 			; set in data statement currently.
.8ab2					_CRSwapBack:
.8ab2	20 07 8b	jsr $8b07			jsr 	SwapDataCodePtrs			; swap them back.
.8ab5	b1 30		lda ($30),y			lda 	(codePtr),y
.8ab7	c8		iny				iny
.8ab8	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8aba	f0 a8		beq $8a64			beq 	Command_Read 				; if so go round again.
.8abc	88		dey				dey 								; unpick get.
.8abd	60		rts				rts
.8abe					_CRSyntax:
.8abe	4c be 9f	jmp $9fbe			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/rem.asm

.8ac1					RemCommand:
.8ac1	b1 30		lda ($30),y			lda 	(codePtr),y
.8ac3	c9 ff		cmp #$ff			cmp 	#KWC_STRING
.8ac5	d0 06		bne $8acd			bne 	_RMExit
.8ac7	c8		iny				iny 								; point to offset
.8ac8	98		tya				tya 								; A = offset position
.8ac9	38		sec				sec 								; add size +1 hence SEC
.8aca	71 30		adc ($30),y			adc 	(codePtr),y
.8acc	a8		tay				tay 								; make current position.
.8acd					_RMExit:
.8acd	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/repeat.asm

.8ace					Command_REPEAT:
.8ace	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; allocate 6 bytes on the return stack.
.8ad0	20 d3 a6	jsr $a6d3			jsr 	StackOpen
.8ad3	20 18 a7	jsr $a718			jsr 	STKSaveCodePosition 		; save loop position
.8ad6	60		rts				rts
.8ad7					Command_UNTIL:
.8ad7	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; check REPEAT is TOS
.8ad9	a2 0f		ldx #$0f			ldx 	#ERRID_REPEAT 				; this error
.8adb	20 00 a7	jsr $a700			jsr 	StackCheckFrame
.8ade	a2 00		ldx #$00			ldx 	#0
.8ae0	20 8e 9d	jsr $9d8e			jsr 	EvaluateNumber 				; work out the number
.8ae3	20 62 9e	jsr $9e62			jsr 	NSMIsZero 					; check if zero
.8ae6	f0 04		beq $8aec			beq 	_CULoopBack 				; if so keep looping
.8ae8	20 f2 a6	jsr $a6f2			jsr 	StackClose		 			; return
.8aeb	60		rts				rts
.8aec					_CULoopBack:
.8aec	20 29 a7	jsr $a729			jsr 	STKLoadCodePosition 		; loop back
.8aef	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/restore.asm

.8af0					Command_Restore:
.8af0	20 07 8b	jsr $8b07			jsr 	SwapDataCodePtrs 			; swap code and data
.8af3	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8af5	85 30		sta $30				sta 	codePtr
.8af7	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8af9	85 31		sta $31				sta 	codePtr+1
.8afb	20 07 8b	jsr $8b07			jsr 	SwapDataCodePtrs 			; put them back
.8afe	a9 03		lda #$03			lda 	#3 							; start at offset 3, e.g. first instruction of first line.
.8b00	8d 1b 04	sta $041b			sta 	dataPointer+4   			; (read checks not EOF)
.8b03	9c 1c 04	stz $041c			stz 	inDataStatement 			; not in data statement
.8b06	60		rts				rts
.8b07					SwapDataCodePtrs:
.8b07	da		phx				phx
.8b08	a2 03		ldx #$03			ldx 	#3 							; swap 32 bit code pointer over
.8b0a					_SDCPLoop:
.8b0a	b5 30		lda $30,x			lda 	safePtr,x
.8b0c	48		pha				pha
.8b0d	bd 17 04	lda $0417,x			lda 	dataPointer,x
.8b10	95 30		sta $30,x			sta 	safePtr,x
.8b12	68		pla				pla
.8b13	9d 17 04	sta $0417,x			sta 	dataPointer,x
.8b16	ca		dex				dex
.8b17	10 f1		bpl $8b0a			bpl 	_SDCPLoop
.8b19	ad 1b 04	lda $041b			lda 	dataPointer+4 				; swap Y position over.
.8b1c	8c 1b 04	sty $041b			sty 	dataPointer+4
.8b1f	a8		tay				tay
.8b20	fa		plx				plx
.8b21	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/run.asm

.8b22					EOLCommand:
.8b22	18		clc				clc
.8b23	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8b25	65 30		adc $30				adc 	codePtr
.8b27	85 30		sta $30				sta 	codePtr
.8b29	90 02		bcc $8b2d			bcc 	_CREExit
.8b2b	e6 31		inc $31				inc 	codePtr+1 					; carry
.8b2d					_CREExit:
.8b2d	80 0b		bra $8b3a			bra 	RunNewLine
.8b2f					CommandRUN:
.8b2f	20 2d 84	jsr $842d			jsr 	ClearCommand 				; clear variable/stacks/etc.
.8b32	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8b34	85 30		sta $30				sta 	codePtr
.8b36	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8b38	85 31		sta $31				sta 	codePtr+1
.8b3a					RUNNewLine:
.8b3a	b2 30		lda ($30)			lda 	(codePtr)
.8b3c	f0 7b		beq $8bb9			beq 	CRNoProgram         		; no then END.
.8b3e	a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack
.8b40	9a		txs				txs
.8b41					RUNCodePointerLine:
.8b41	a0 02		ldy #$02			ldy 	#2 							; start of program
.8b43					_CRIncMainLoop:
.8b43	0e 13 04	asl $0413			asl 	breakCheck 					; clears 1 time in 8
.8b46	d0 22		bne $8b6a			bne 	_CRNoBreakCheck
.8b48	ce 13 04	dec $0413			dec	 	breakCheck 					; set it back to $FF
.8b4b	20 0c 80	jsr $800c			jsr 	EXTBreakCheck 				; break check
.8b4e	f0 64		beq $8bb4			beq 	_CRBreak
.8b50	a5 01		lda $01				lda 	1 							; save I/O 0
.8b52	48		pha				pha
.8b53	64 01		stz $01				stz 	1 							; access I/O Page 0
.8b55	38		sec				sec 								; calculate timer - LastTick
.8b56	ad 59 d6	lda $d659			lda 	$D659
.8b59	aa		tax				tax 								; saving timer in X
.8b5a	ed 5b 06	sbc $065b			sbc 	LastTick
.8b5d	c9 03		cmp #$03			cmp 	#3
.8b5f	90 06		bcc $8b67			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.8b61	8e 5b 06	stx $065b			stx 	LastTick 					; update last timer
.8b64	20 6b 9e	jsr $9e6b			jsr 	TickHandler 							; go do the code.
.8b67					_NoFireTick:
.8b67	68		pla				pla 								; restore I/O 0
.8b68	85 01		sta $01				sta 	1
.8b6a					_CRNoBreakCheck:
.8b6a	c8		iny				iny									; next token
.8b6b					_CRMainLoop:
.8b6b	9c 10 04	stz $0410			stz 	stringInitialised 			; clear the temporary string initialised flag.
.8b6e	b1 30		lda ($30),y			lda 	(codePtr),y
.8b70	10 10		bpl $8b82			bpl 	_CRNotKeyword				; not a token.
.8b72	c9 a2		cmp #$a2			cmp 	#KWC_LAST_UNARY+1 			; if after unary, legitimate command
.8b74	b0 04		bcs $8b7a			bcs 	_CRIsKeyword
.8b76	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if unary, syntax error.
.8b78	b0 34		bcs $8bae			bcs		_CRSyntaxError
.8b7a					_CRIsKeyword:
.8b7a	c8		iny				iny 								; consume command
.8b7b	0a		asl a				asl 	a 							; double losing the MSB which is '1' as tokens are $80-$FF
.8b7c	aa		tax				tax 								; put in X for vector jump
.8b7d	20 b1 8b	jsr $8bb1			jsr 	_CRCallVector0 				; call the vector - effectively jsr (vectortable,X)
.8b80	80 e9		bra $8b6b			bra 	_CRMainLoop 				; and loop round
.8b82					_CRNotKeyword:
.8b82	c9 3a		cmp #$3a			cmp 	#KWD_COLON 					; if a :, consume it and go round.
.8b84	f0 bd		beq $8b43			beq 	_CRIncMainLoop
.8b86	c9 40		cmp #$40			cmp 	#$40 						; variable/call reference
.8b88	90 05		bcc $8b8f			bcc 	_CRNotVariable
.8b8a					_CRGoLet:
.8b8a	20 d6 87	jsr $87d6			jsr 	LetCommand
.8b8d	80 dc		bra $8b6b			bra 	_CRMainLoop
.8b8f					_CRNotVariable:
.8b8f	c9 10		cmp #$10			cmp 	#KWD_AT 					; handle @
.8b91	f0 f7		beq $8b8a			beq 	_CRGoLet
.8b93	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; handle ? !
.8b95	f0 f3		beq $8b8a			beq 	_CRGoLet
.8b97	c9 21		cmp #$21			cmp 	#KWD_PLING
.8b99	f0 ef		beq $8b8a			beq 	_CRGoLet
.8b9b	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; handle ' (comment)
.8b9d	f0 09		beq $8ba8			beq 	_CRGoRem
.8b9f	c9 2e		cmp #$2e			cmp 	#KWD_PERIOD 				; handle . (assembler label)
.8ba1	d0 0b		bne $8bae			bne 	_CRSyntaxError
.8ba3	20 18 82	jsr $8218			jsr 	LabelHere
.8ba6	80 c3		bra $8b6b			bra 	_CRMainLoop
.8ba8					_CRGoRem:
.8ba8	c8		iny				iny
.8ba9	20 c1 8a	jsr $8ac1			jsr 	RemCommand
.8bac	80 bd		bra $8b6b			bra 	_CRMainLoop
.8bae					_CRSyntaxError:
.8bae	4c be 9f	jmp $9fbe			jmp 	SyntaxError
.8bb1					_CRCallVector0:
.8bb1	7c 50 8c	jmp ($8c50,x)			jmp 	(VectorSet0,x)
.8bb4					_CRBreak:
.8bb4	a9 01		lda #$01		lda	#1
.8bb6	4c 1e 8f	jmp $8f1e		jmp	ErrorHandler
.8bb9					CRNoProgram:
.8bb9	4c 7b 85	jmp $857b			jmp 	EndCommand
.8bbc					Shift1Command:
.8bbc	b1 30		lda ($30),y			lda 	(codePtr),y
.8bbe	c8		iny				iny
.8bbf	0a		asl a				asl 	a
.8bc0	aa		tax				tax
.8bc1	7c f6 8c	jmp ($8cf6,x)			jmp 	(VectorSet1,x)
.8bc4					Shift2Command:
.8bc4	b1 30		lda ($30),y			lda 	(codePtr),y
.8bc6	c8		iny				iny
.8bc7	0a		asl a				asl 	a
.8bc8	aa		tax				tax
.8bc9	7c 1e 8d	jmp ($8d1e,x)			jmp 	(VectorSet2,x)
.8bcc					Unused1:
.8bcc					Unused2:
.8bcc					Unused3:
.8bcc					Unused4:
.8bcc	4c be 9f	jmp $9fbe			jmp 	SyntaxError
>8bcf							.align 2

;******  Processing file: ./common/commands/../generated/vectors.dat

.8bd0					VectorSetPunc:
>8bd0	d6 91					.word	ShiftLeft                        ; $00 <<
>8bd2	c1 8f					.word	BinaryCompareLessEqual           ; $01 <=
>8bd4	b7 8f					.word	BinaryCompareNotEqual            ; $02 <>
>8bd6	be 9f					.word	SyntaxError                      ; $03 !!3
>8bd8	be 9f					.word	SyntaxError                      ; $04 ><
>8bda	cb 8f					.word	BinaryCompareGreaterEqual        ; $05 >=
>8bdc	d9 91					.word	ShiftRight                       ; $06 >>
>8bde	be 9f					.word	SyntaxError                      ; $07 !!7
>8be0	be 9f					.word	SyntaxError                      ; $08 !!8
>8be2	be 9f					.word	SyntaxError                      ; $09 !!9
>8be4	be 9f					.word	SyntaxError                      ; $0a !!10
>8be6	be 9f					.word	SyntaxError                      ; $0b !!11
>8be8	be 9f					.word	SyntaxError                      ; $0c !!12
>8bea	be 9f					.word	SyntaxError                      ; $0d !!13
>8bec	be 9f					.word	SyntaxError                      ; $0e !!14
>8bee	be 9f					.word	SyntaxError                      ; $0f !!15
>8bf0	be 9f					.word	SyntaxError                      ; $10 @
>8bf2	be 9f					.word	SyntaxError                      ; $11 !!17
>8bf4	be 9f					.word	SyntaxError                      ; $12 !!18
>8bf6	be 9f					.word	SyntaxError                      ; $13 [
>8bf8	82 90					.word	IntegerDivide                    ; $14 \
>8bfa	be 9f					.word	SyntaxError                      ; $15 ]
>8bfc	14 93					.word	EorInteger                       ; $16 ^
>8bfe	be 9f					.word	SyntaxError                      ; $17 _
>8c00	be 9f					.word	SyntaxError                      ; $18 `
>8c02	be 9f					.word	SyntaxError                      ; $19 !!25
>8c04	be 9f					.word	SyntaxError                      ; $1a !!26
>8c06	be 9f					.word	SyntaxError                      ; $1b {
>8c08	df 92					.word	OraInteger                       ; $1c |
>8c0a	be 9f					.word	SyntaxError                      ; $1d }
>8c0c	be 9f					.word	SyntaxError                      ; $1e ~
>8c0e	be 9f					.word	SyntaxError                      ; $1f [7m<7F>[m
>8c10	be 9f					.word	SyntaxError                      ; $20
>8c12	49 93					.word	WordIndirect                     ; $21 !
>8c14	be 9f					.word	SyntaxError                      ; $22 "
>8c16	be 9f					.word	SyntaxError                      ; $23 #
>8c18	be 9f					.word	SyntaxError                      ; $24 $
>8c1a	c3 90					.word	IntegerModulus                   ; $25 %
>8c1c	aa 92					.word	AndInteger                       ; $26 &
>8c1e	be 9f					.word	SyntaxError                      ; $27 '
>8c20	be 9f					.word	SyntaxError                      ; $28 (
>8c22	be 9f					.word	SyntaxError                      ; $29 )
>8c24	31 91					.word	MulInteger                       ; $2a *
>8c26	4c 92					.word	AddInteger                       ; $2b +
>8c28	be 9f					.word	SyntaxError                      ; $2c ,
>8c2a	85 92					.word	SubInteger                       ; $2d -
>8c2c	be 9f					.word	SyntaxError                      ; $2e .
>8c2e	03 95					.word	FDivideCommand                   ; $2f /
>8c30	be 9f					.word	SyntaxError                      ; $30 0
>8c32	be 9f					.word	SyntaxError                      ; $31 1
>8c34	be 9f					.word	SyntaxError                      ; $32 2
>8c36	be 9f					.word	SyntaxError                      ; $33 3
>8c38	be 9f					.word	SyntaxError                      ; $34 4
>8c3a	be 9f					.word	SyntaxError                      ; $35 5
>8c3c	be 9f					.word	SyntaxError                      ; $36 6
>8c3e	be 9f					.word	SyntaxError                      ; $37 7
>8c40	be 9f					.word	SyntaxError                      ; $38 8
>8c42	be 9f					.word	SyntaxError                      ; $39 9
>8c44	be 9f					.word	SyntaxError                      ; $3a :
>8c46	be 9f					.word	SyntaxError                      ; $3b ;
>8c48	a3 8f					.word	BinaryCompareLess                ; $3c <
>8c4a	99 8f					.word	BinaryCompareEqual               ; $3d =
>8c4c	ad 8f					.word	BinaryCompareGreater             ; $3e >
>8c4e	6b 93					.word	ByteIndirect                     ; $3f ?
.8c50					VectorSet0:
>8c50	22 8b					.word	EOLCommand                       ; $80 !0:EOF
>8c52	bc 8b					.word	Shift1Command                    ; $81 !1:SH1
>8c54	c4 8b					.word	Shift2Command                    ; $82 !2:SH2
>8c56	e8 99					.word	AbsUnary                         ; $83 ABS(
>8c58	f6 99					.word	AllocUnary                       ; $84 ALLOC(
>8c5a	66 9a					.word	AscUnary                         ; $85 ASC(
>8c5c	26 9c					.word	ChrUnary                         ; $86 CHR$(
>8c5e	76 9a					.word	DeekUnary                        ; $87 DEEK(
>8c60	0f a4					.word	UnaryEvent                       ; $88 EVENT(
>8c62	95 8f					.word	UnaryFalse                       ; $89 FALSE
>8c64	88 9a					.word	FracUnary                        ; $8a FRAC(
>8c66	ab a3					.word	UnaryHit                         ; $8b HIT(
>8c68	9d 9a					.word	IntUnary                         ; $8c INT(
>8c6a	e5 9b					.word	IsValUnary                       ; $8d ISVAL(
>8c6c	93 a4					.word	UnaryJoyB                        ; $8e JOYB(
>8c6e	6c a4					.word	UnaryJoyX                        ; $8f JOYX(
>8c70	6f a4					.word	UnaryJoyY                        ; $90 JOYY(
>8c72	f9 9c					.word	Unary_Left                       ; $91 LEFT$(
>8c74	ae 9a					.word	LenUnary                         ; $92 LEN(
>8c76	cc 9a					.word	Unary_Max                        ; $93 MAX(
>8c78	1b 9d					.word	Unary_Mid                        ; $94 MID$(
>8c7a	c8 9a					.word	Unary_Min                        ; $95 MIN(
>8c7c	17 9b					.word	Unary_Not                        ; $96 NOT(
>8c7e	73 9a					.word	PeekUnary                        ; $97 PEEK(
>8c80	30 a6					.word	UnaryPlaying                     ; $98 PLAYING(
>8c82	2a 9b					.word	Unary_Random                     ; $99 RANDOM(
>8c84	06 9d					.word	Unary_Right                      ; $9a RIGHT$(
>8c86	47 9b					.word	Unary_Rnd                        ; $9b RND(
>8c88	bd 9b					.word	SgnUnary                         ; $9c SGN(
>8c8a	38 9c					.word	SpcUnary                         ; $9d SPC(
>8c8c	53 9c					.word	Unary_Str                        ; $9e STR$(
>8c8e	b9 a4					.word	UnaryTimer                       ; $9f TIMER(
>8c90	8a 8f					.word	UnaryTrue                        ; $a0 TRUE
>8c92	db 9b					.word	ValUnary                         ; $a1 VAL(
>8c94	7e 85					.word	ForCommand                       ; $a2 FOR
>8c96	c1 86					.word	IfCommand                        ; $a3 IF
>8c98	cc 8b					.word	Unused1                          ; $a4 PROC
>8c9a	ce 8a					.word	Command_REPEAT                   ; $a5 REPEAT
>8c9c	73 8e					.word	Command_WHILE                    ; $a6 WHILE
>8c9e	ea 86					.word	EndIf                            ; $a7 ENDIF
>8ca0	56 8a					.word	Command_ENDPROC                  ; $a8 ENDPROC
>8ca2	30 86					.word	NextCommand                      ; $a9 NEXT
>8ca4	cc 8b					.word	Unused4                          ; $aa THEN
>8ca6	d7 8a					.word	Command_UNTIL                    ; $ab UNTIL
>8ca8	94 8e					.word	Command_WEND                     ; $ac WEND
>8caa	be 9f					.word	SyntaxError                      ; $ad BY
>8cac	f8 83					.word	CallCommand                      ; $ae CALL
>8cae	5f a1					.word	CircleCommand                    ; $af CIRCLE
>8cb0	2d 84					.word	ClearCommand                     ; $b0 CLEAR
>8cb2	85 84					.word	ClearScreen                      ; $b1 CLS
>8cb4	be 9f					.word	SyntaxError                      ; $b2 COLOR
>8cb6	be 9f					.word	SyntaxError                      ; $b3 COLOUR
>8cb8	8d 84					.word	Command_Data                     ; $b4 DATA
>8cba	95 84					.word	DimCommand                       ; $b5 DIM
>8cbc	55 85					.word	DokeCommand                      ; $b6 DOKE
>8cbe	cc 8b					.word	Unused3                          ; $b7 DOWNTO
>8cc0	e3 86					.word	ElseCode                         ; $b8 ELSE
>8cc2	be 9f					.word	SyntaxError                      ; $b9 FROM
>8cc4	7e a3					.word	GfxCommand                       ; $ba GFX
>8cc6	89 86					.word	Command_GOSUB                    ; $bb GOSUB
>8cc8	a7 86					.word	GotoCommand                      ; $bc GOTO
>8cca	be 9f					.word	SyntaxError                      ; $bd HERE
>8ccc	88 a1					.word	ImageCommand                     ; $be IMAGE
>8cce	eb 86					.word	Command_Input                    ; $bf INPUT
>8cd0	d6 87					.word	LetCommand                       ; $c0 LET
>8cd2	da a1					.word	LineCommand                      ; $c1 LINE
>8cd4	27 89					.word	Command_LOCAL                    ; $c2 LOCAL
>8cd6	be 9f					.word	SyntaxError                      ; $c3 OFF
>8cd8	be 9f					.word	SyntaxError                      ; $c4 ON
>8cda	be 9f					.word	SyntaxError                      ; $c5 OUTLINE
>8cdc	cf a3					.word	PaletteCommand                   ; $c6 PALETTE
>8cde	d3 a1					.word	PlotCommand                      ; $c7 PLOT
>8ce0	52 85					.word	PokeCommand                      ; $c8 POKE
>8ce2	f2 86					.word	Command_Print                    ; $c9 PRINT
>8ce4	64 8a					.word	Command_Read                     ; $ca READ
>8ce6	5b a1					.word	RectangleCommand                 ; $cb RECT
>8ce8	c1 8a					.word	RemCommand                       ; $cc REM
>8cea	99 86					.word	Command_RETURN                   ; $cd RETURN
>8cec	be 9f					.word	SyntaxError                      ; $ce SOLID
>8cee	4c a6					.word	SoundCommand                     ; $cf SOUND
>8cf0	6a a1					.word	SpriteCommand                    ; $d0 SPRITE
>8cf2	a4 a1					.word	TextCommand                      ; $d1 TEXT
>8cf4	cc 8b					.word	Unused2                          ; $d2 TO
.8cf6					VectorSet1:
>8cf6	be 9f					.word	SyntaxError                      ; $80 !0:EOF
>8cf8	be 9f					.word	SyntaxError                      ; $81 !1:SH1
>8cfa	be 9f					.word	SyntaxError                      ; $82 !2:SH2
>8cfc	cc 83					.word	AssembleCommand                  ; $83 ASSEMBLE
>8cfe	e8 83					.word	AssertCommand                    ; $84 ASSERT
>8d00	1e a3					.word	BitmapCtrl                       ; $85 BITMAP
>8d02	7b 85					.word	EndCommand                       ; $86 END
>8d04	04 a6					.word	Explode                          ; $87 EXPLODE
>8d06	b0 a4					.word	GoCommand                        ; $88 GO
>8d08	26 88					.word	Command_List                     ; $89 LIST
>8d0a	a7 a4					.word	LoadCommand                      ; $8a LOAD
>8d0c	e8 89					.word	NewCommand                       ; $8b NEW
>8d0e	e0 a5					.word	PingCommand                      ; $8c PING
>8d10	f0 8a					.word	Command_Restore                  ; $8d RESTORE
>8d12	2f 8b					.word	CommandRUN                       ; $8e RUN
>8d14	f8 a5					.word	ShootCommand                     ; $8f SHOOT
>8d16	63 a3					.word	SpritesCtrl                      ; $90 SPRITES
>8d18	a6 8d					.word	StopCommand                      ; $91 STOP
>8d1a	a2 8e					.word	WhoCommand                       ; $92 WHO
>8d1c	ec a5					.word	ZapCommand                       ; $93 ZAP
.8d1e					VectorSet2:
>8d1e	be 9f					.word	SyntaxError                      ; $80 !0:EOF
>8d20	be 9f					.word	SyntaxError                      ; $81 !1:SH1
>8d22	be 9f					.word	SyntaxError                      ; $82 !2:SH2
>8d24	7d 9e					.word	Assemble_adc                     ; $83 ADC
>8d26	75 9e					.word	Assemble_and                     ; $84 AND
>8d28	91 9e					.word	Assemble_asl                     ; $85 ASL
>8d2a	fb 9e					.word	Assemble_bcc                     ; $86 BCC
>8d2c	ff 9e					.word	Assemble_bcs                     ; $87 BCS
>8d2e	07 9f					.word	Assemble_beq                     ; $88 BEQ
>8d30	be 9e					.word	Assemble_bit                     ; $89 BIT
>8d32	ef 9e					.word	Assemble_bmi                     ; $8a BMI
>8d34	03 9f					.word	Assemble_bne                     ; $8b BNE
>8d36	eb 9e					.word	Assemble_bpl                     ; $8c BPL
>8d38	0b 9f					.word	Assemble_bra                     ; $8d BRA
>8d3a	0f 9f					.word	Assemble_brk                     ; $8e BRK
>8d3c	f3 9e					.word	Assemble_bvc                     ; $8f BVC
>8d3e	f7 9e					.word	Assemble_bvs                     ; $90 BVS
>8d40	17 9f					.word	Assemble_clc                     ; $91 CLC
>8d42	6b 9f					.word	Assemble_cld                     ; $92 CLD
>8d44	2b 9f					.word	Assemble_cli                     ; $93 CLI
>8d46	5b 9f					.word	Assemble_clv                     ; $94 CLV
>8d48	89 9e					.word	Assemble_cmp                     ; $95 CMP
>8d4a	d2 9e					.word	Assemble_cpx                     ; $96 CPX
>8d4c	cd 9e					.word	Assemble_cpy                     ; $97 CPY
>8d4e	af 9e					.word	Assemble_dec                     ; $98 DEC
>8d50	67 9f					.word	Assemble_dex                     ; $99 DEX
>8d52	43 9f					.word	Assemble_dey                     ; $9a DEY
>8d54	79 9e					.word	Assemble_eor                     ; $9b EOR
>8d56	b4 9e					.word	Assemble_inc                     ; $9c INC
>8d58	77 9f					.word	Assemble_inx                     ; $9d INX
>8d5a	63 9f					.word	Assemble_iny                     ; $9e INY
>8d5c	e6 9e					.word	Assemble_jmp                     ; $9f JMP
>8d5e	e1 9e					.word	Assemble_jsr                     ; $a0 JSR
>8d60	85 9e					.word	Assemble_lda                     ; $a1 LDA
>8d62	aa 9e					.word	Assemble_ldx                     ; $a2 LDX
>8d64	c8 9e					.word	Assemble_ldy                     ; $a3 LDY
>8d66	9b 9e					.word	Assemble_lsr                     ; $a4 LSR
>8d68	7b 9f					.word	Assemble_nop                     ; $a5 NOP
>8d6a	71 9e					.word	Assemble_ora                     ; $a6 ORA
>8d6c	27 9f					.word	Assemble_pha                     ; $a7 PHA
>8d6e	13 9f					.word	Assemble_php                     ; $a8 PHP
>8d70	6f 9f					.word	Assemble_phx                     ; $a9 PHX
>8d72	2f 9f					.word	Assemble_phy                     ; $aa PHY
>8d74	37 9f					.word	Assemble_pla                     ; $ab PLA
>8d76	1b 9f					.word	Assemble_plp                     ; $ac PLP
>8d78	83 9f					.word	Assemble_plx                     ; $ad PLX
>8d7a	3f 9f					.word	Assemble_ply                     ; $ae PLY
>8d7c	96 9e					.word	Assemble_rol                     ; $af ROL
>8d7e	a0 9e					.word	Assemble_ror                     ; $b0 ROR
>8d80	23 9f					.word	Assemble_rti                     ; $b1 RTI
>8d82	33 9f					.word	Assemble_rts                     ; $b2 RTS
>8d84	8d 9e					.word	Assemble_sbc                     ; $b3 SBC
>8d86	1f 9f					.word	Assemble_sec                     ; $b4 SEC
>8d88	7f 9f					.word	Assemble_sed                     ; $b5 SED
>8d8a	3b 9f					.word	Assemble_sei                     ; $b6 SEI
>8d8c	81 9e					.word	Assemble_sta                     ; $b7 STA
>8d8e	73 9f					.word	Assemble_stp                     ; $b8 STP
>8d90	a5 9e					.word	Assemble_stx                     ; $b9 STX
>8d92	c3 9e					.word	Assemble_sty                     ; $ba STY
>8d94	b9 9e					.word	Assemble_stz                     ; $bb STZ
>8d96	57 9f					.word	Assemble_tax                     ; $bc TAX
>8d98	53 9f					.word	Assemble_tay                     ; $bd TAY
>8d9a	dc 9e					.word	Assemble_trb                     ; $be TRB
>8d9c	d7 9e					.word	Assemble_tsb                     ; $bf TSB
>8d9e	5f 9f					.word	Assemble_tsx                     ; $c0 TSX
>8da0	47 9f					.word	Assemble_txa                     ; $c1 TXA
>8da2	4f 9f					.word	Assemble_txs                     ; $c2 TXS
>8da4	4b 9f					.word	Assemble_tya                     ; $c3 TYA

;******  Return to file: ./common/commands/run.asm


;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/stop.asm

.8da6					StopCommand:
.8da6	a9 08		lda #$08		lda	#8
.8da8	4c 1e 8f	jmp $8f1e		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/procscan.asm

.8dab					ProcedureScan:
.8dab	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8dad	85 30		sta $30				sta 	codePtr
.8daf	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8db1	85 31		sta $31				sta 	codePtr+1
.8db3					_PSLoop:
.8db3	b2 30		lda ($30)			lda 	(codePtr)
.8db5	f0 42		beq $8df9			beq 	_PSExit
.8db7	a0 03		ldy #$03			ldy 	#3 							; is it PROC at start of line ?
.8db9	b1 30		lda ($30),y			lda 	(codePtr),y
.8dbb	c9 a4		cmp #$a4			cmp 	#KWD_PROC
.8dbd	d0 2d		bne $8dec			bne 	_PSNext
.8dbf	c8		iny				iny 								; get the address of the record to zTemp0 and
.8dc0	b1 30		lda ($30),y			lda 	(codePtr),y
.8dc2	29 c0		and #$c0			and 	#$C0
.8dc4	c9 40		cmp #$40			cmp 	#$40
.8dc6	d0 32		bne $8dfa			bne 	_PSSyntax
.8dc8	b1 30		lda ($30),y			lda 	(codePtr),y
.8dca	18		clc				clc
.8dcb	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8dcd	85 37		sta $37				sta 	zTemp0+1
.8dcf	c8		iny				iny 								; LSB
.8dd0	b1 30		lda ($30),y			lda 	(codePtr),y
.8dd2	85 36		sta $36				sta 	zTemp0
.8dd4	c8		iny				iny 								; character after variable call.
.8dd5	98		tya				tya 								; save Y offset at +7 (exponent slot)
.8dd6	a0 07		ldy #$07			ldy 	#7
.8dd8	91 36		sta ($36),y			sta 	(zTemp0),y
.8dda	a9 18		lda #$18			lda 	#NSTProcedure 				; mark it as procedure
.8ddc	a0 02		ldy #$02			ldy 	#2
.8dde	91 36		sta ($36),y			sta 	(zTemp0),y
.8de0	a2 00		ldx #$00			ldx 	#0 							; copy code-Ptr into offset 3-6 (mantissa)
.8de2					_PSCopy:
.8de2	b5 30		lda $30,x			lda 	safePtr,x
.8de4	c8		iny				iny
.8de5	91 36		sta ($36),y			sta 	(zTemp0),y
.8de7	e8		inx				inx
.8de8	e0 04		cpx #$04			cpx 	#4
.8dea	d0 f6		bne $8de2			bne 	_PSCopy
.8dec					_PSNext:
.8dec	18		clc				clc
.8ded	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8def	65 30		adc $30				adc 	codePtr
.8df1	85 30		sta $30				sta 	codePtr
.8df3	90 02		bcc $8df7			bcc 	_CREExit
.8df5	e6 31		inc $31				inc 	codePtr+1 					; carry
.8df7					_CREExit:
.8df7	80 ba		bra $8db3			bra 	_PSLoop
.8df9					_PSExit:
.8df9	60		rts				rts
.8dfa					_PSSyntax:
.8dfa	4c be 9f	jmp $9fbe			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/scanforward.asm

.8dfd					ScanForward:
.8dfd	64 38		stz $38				stz 	zTemp1 						; zero the structure count - goes up with WHILE/FOR down with WEND/NEXT etc.
.8dff	86 37		stx $37				stx 	zTemp0+1
.8e01	85 36		sta $36				sta 	zTemp0 						; save X & A as the two possible matches.
.8e03					_ScanLoop:
.8e03	b1 30		lda ($30),y			lda 	(codePtr),y
.8e05	c8		iny				iny
.8e06	a6 38		ldx $38				ldx 	zTemp1 						; if the count is > 0 cannot match as in substructure
.8e08	d0 0e		bne $8e18			bne 	_ScanGoNext
.8e0a	c5 36		cmp $36				cmp 	zTemp0 						; see if either matches
.8e0c	f0 04		beq $8e12			beq 	_ScanMatch
.8e0e	c5 37		cmp $37				cmp 	zTemp0+1
.8e10	d0 06		bne $8e18			bne 	_ScanGoNext
.8e12					_ScanMatch:
.8e12	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if asked for EOL, backtrack.
.8e14	d0 01		bne $8e17			bne 	_ScanNotEndEOL
.8e16	88		dey				dey
.8e17					_ScanNotEndEOL:
.8e17	60		rts				rts
.8e18					_ScanGoNext:
.8e18	20 1d 8e	jsr $8e1d			jsr  	ScanForwardOne 				; allows for shifts and so on.
.8e1b	80 e6		bra $8e03			bra 	_ScanLoop
.8e1d					ScanForwardOne:
.8e1d	c9 40		cmp #$40			cmp 	#$40 						; if 00-3F, punctuation characters, already done.
.8e1f	90 3e		bcc $8e5f			bcc 	_SFWExit
.8e21	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if 40-82, skip one extra as these are 2 byte
.8e23	90 18		bcc $8e3d			bcc 	_ScanSkipOne	 			; offsets into the identifier table or shifts.
.8e25	c9 fc		cmp #$fc			cmp 	#$FC 						; FC-FF are data skips (hex consts, strings etc.)
.8e27	b0 2f		bcs $8e58			bcs 	_ScanSkipData
.8e29	c9 a2		cmp #$a2			cmp 	#KWC_FIRST_STRUCTURE 		; structure keyword ?
.8e2b	90 32		bcc $8e5f			bcc 	_SFWExit 					; if not, ordinary keywords.
.8e2d	c9 ad		cmp #$ad			cmp 	#KWC_LAST_STRUCTURE+1
.8e2f	b0 2e		bcs $8e5f			bcs 	_SFWExit
.8e31	c6 38		dec $38				dec 	zTemp1 						; decrement the sructure count
.8e33	c9 a7		cmp #$a7			cmp 	#KWC_FIRST_STRUCTURE_DEC 	; back if it is a dec structure (e.g. WEND/NEXT)
.8e35	b0 28		bcs $8e5f			bcs 	_SFWExit
.8e37	e6 38		inc $38				inc 	zTemp1 						; so it's an increment structure
.8e39	e6 38		inc $38				inc 	zTemp1 						; twice to undo the dec
.8e3b	80 22		bra $8e5f			bra 	_SFWExit
.8e3d					_ScanSkipOne:
.8e3d	c8		iny				iny 								; consume the extra one.
.8e3e	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if not EOL loop back
.8e40	d0 1d		bne $8e5f			bne 	_SFWExit
.8e42	18		clc				clc
.8e43	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8e45	65 30		adc $30				adc 	codePtr
.8e47	85 30		sta $30				sta 	codePtr
.8e49	90 02		bcc $8e4d			bcc 	_CREExit
.8e4b	e6 31		inc $31				inc 	codePtr+1 					; carry
.8e4d					_CREExit:
.8e4d	a0 03		ldy #$03			ldy 	#3 							; scan start position.
.8e4f	b2 30		lda ($30)			lda 	(codePtr)
.8e51	d0 0c		bne $8e5f			bne 	_SFWExit 					; if not zero, more to scan
.8e53	a9 13		lda #$13		lda	#19
.8e55	4c 1e 8f	jmp $8f1e		jmp	ErrorHandler
.8e58					_ScanSkipData:
.8e58	88		dey				dey 								; point at data token
.8e59	c8		iny				iny 								; point to offset
.8e5a	98		tya				tya 								; A = offset position
.8e5b	38		sec				sec 								; add size +1 hence SEC
.8e5c	71 30		adc ($30),y			adc 	(codePtr),y
.8e5e	a8		tay				tay 								; make current position.
.8e5f					_SFWExit:
.8e5f	60		rts				rts
.8e60					ScanGetCurrentLineStep:
.8e60	64 38		stz $38				stz 	zTemp1
.8e62	a0 03		ldy #$03			ldy 	#3
.8e64					_SGCLSLoop:
.8e64	b1 30		lda ($30),y			lda 	(codePtr),y
.8e66	c8		iny				iny
.8e67	c9 80		cmp #$80			cmp 	#KWC_EOL	 				; if EOL exit
.8e69	f0 05		beq $8e70			beq 	_SGCLSExit
.8e6b	20 1d 8e	jsr $8e1d			jsr 	ScanForwardOne
.8e6e	80 f4		bra $8e64			bra 	_SGCLSLoop
.8e70					_SGCLSExit:
.8e70	a5 38		lda $38				lda 	zTemp1 						; return the adjustment
.8e72	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/while.asm

.8e73					Command_WHILE:
.8e73	5a		phy				phy 								; save position of the test
.8e74	a2 00		ldx #$00			ldx 	#0 							; work out the while test.
.8e76	20 8e 9d	jsr $9d8e			jsr 	EvaluateNumber
.8e79	20 62 9e	jsr $9e62			jsr 	NSMIsZero 					; check if zero
.8e7c	f0 0e		beq $8e8c			beq 	_WHExitLoop 				; if so exit the loop, while has failed.
.8e7e	98		tya				tya 								; position *after* test.
.8e7f	7a		ply				ply 								; restore position before test, at WHILE
.8e80	88		dey				dey 								; so we execute the WHILE command again.
.8e81	48		pha				pha 								; push after test on the stack
.8e82	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; allocate 6 bytes on the return stack.
.8e84	20 d3 a6	jsr $a6d3			jsr 	StackOpen
.8e87	20 18 a7	jsr $a718			jsr 	STKSaveCodePosition 		; save loop position - where the test value expr is.
.8e8a	7a		ply				ply 								; restore the position *after* the test
.8e8b	60		rts				rts
.8e8c					_WHExitLoop:
.8e8c	68		pla				pla 								; throw post loop position
.8e8d	a9 ac		lda #$ac			lda 	#KWD_WEND 					; scan forward past WEND
.8e8f	aa		tax				tax
.8e90	20 fd 8d	jsr $8dfd			jsr 	ScanForward
.8e93	60		rts				rts
.8e94					Command_WEND:
.8e94	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; check WHILE is TOS e.g. in a while loop :)
.8e96	a2 10		ldx #$10			ldx 	#ERRID_WHILE 				; this error if not.
.8e98	20 00 a7	jsr $a700			jsr 	StackCheckFrame
.8e9b	20 29 a7	jsr $a729			jsr 	STKLoadCodePosition 		; loop back to the WHILE keyword.
.8e9e	20 f2 a6	jsr $a6f2			jsr 	StackClose		 			; erase the frame
.8ea1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/who.asm

.8ea2					WhoCommand:
.8ea2	a2 8e		ldx #$8e			ldx 	#(_WHOMessage >> 8)
.8ea4	a9 aa		lda #$aa			lda 	#(_WHOMessage & $FF)
.8ea6	20 77 8f	jsr $8f77			jsr 	PrintStringXA
.8ea9	60		rts				rts
.8eaa					_WHOMessage:
>8eaa	81						.byte 	$81
>8eab	42 72 6f 75 67 68 74 20				.text 	"Brought to you by :",13,13
>8eb3	74 6f 20 79 6f 75 20 62 79 20 3a 0d 0d
>8ec0	09 53 74 65 66 61 6e 79				.text 	9,"Stefany Allaire",13
>8ec8	20 41 6c 6c 61 69 72 65 0d
>8ed1	09 4a 65 73 73 69 65 20				.text 	9,"Jessie Oberreuter",13
>8ed9	4f 62 65 72 72 65 75 74 65 72 0d
>8ee4	09 50 61 75 6c 20 52 6f				.text 	9,"Paul Robson",13
>8eec	62 73 6f 6e 0d
>8ef1	09 50 65 74 65 72 20 57				.text 	9,"Peter Weingartner",13
>8ef9	65 69 6e 67 61 72 74 6e 65 72 0d
>8f04	00						.byte 	0

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/charcheck.asm

.8f05					CheckRightBracket:
.8f05	b1 30		lda ($30),y			lda 	(codePtr),y
.8f07	c8		iny				iny
.8f08	c9 29		cmp #$29			cmp 	#KWD_RPAREN 						; exit if matches
.8f0a	d0 0f		bne $8f1b			bne 	CNAFail
.8f0c	60		rts				rts
.8f0d					CheckComma:
.8f0d	b1 30		lda ($30),y			lda 	(codePtr),y
.8f0f	c8		iny				iny
.8f10	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 						; exit if matches
.8f12	d0 07		bne $8f1b			bne 	CNAFail
.8f14	60		rts				rts
.8f15					CheckNextA:
.8f15	d1 30		cmp ($30),y			cmp 	(codePtr),y
.8f17	d0 02		bne $8f1b			bne 	CNAFail
.8f19	c8		iny				iny 								; skip character
.8f1a	60		rts				rts 								; and exit
.8f1b					CNAFail:
.8f1b	4c be 9f	jmp $9fbe			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/errors.asm

.8f1e					ErrorHandler:
.8f1e	a8		tay				tay 								; find the error text
.8f1f	f0 49		beq $8f6a			beq 	_EHEnd
.8f21	a2 00		ldx #$00			ldx 	#0
.8f23	a9 d7		lda #$d7			lda 	#((ErrorText) & $FF)
.8f25	85 36		sta $36				sta 	0+zTemp0
.8f27	a9 9f		lda #$9f			lda 	#((ErrorText) >> 8)
.8f29	85 37		sta $37				sta 	1+zTemp0
.8f2b					_EHFind:
.8f2b	88		dey				dey 								; keep looking through text
.8f2c	f0 0e		beq $8f3c			beq 	_EHFound
.8f2e					_EHFindZero:
.8f2e	b2 36		lda ($36)			lda 	(zTemp0) 					; find the next error
.8f30	e6 36		inc $36				inc 	zTemp0
.8f32	d0 02		bne $8f36			bne 	_EHFNoCarry
.8f34	e6 37		inc $37				inc 	zTemp0+1
.8f36					_EHFNoCarry:
.8f36	c9 00		cmp #$00			cmp 	#0
.8f38	d0 f4		bne $8f2e			bne 	_EHFindZero
.8f3a	80 ef		bra $8f2b			bra 	_EHFind
.8f3c					_EHFound:
.8f3c	a5 36		lda $36				lda 	zTemp0 						; print message
.8f3e	a6 37		ldx $37				ldx 	zTemp0+1
.8f40	20 77 8f	jsr $8f77			jsr 	PrintStringXA
.8f43	a0 01		ldy #$01			ldy 	#1 							; if line number zero don't print it
.8f45	b1 30		lda ($30),y			lda 	(codePtr),y
.8f47	d0 05		bne $8f4e			bne 	_EHAtMsg
.8f49	c8		iny				iny
.8f4a	b1 30		lda ($30),y			lda 	(codePtr),y
.8f4c	f0 17		beq $8f65			beq 	_EHCREnd
.8f4e					_EHAtMsg:
.8f4e	a2 8f		ldx #$8f			ldx 	#_AtMsg >> 8 				; print " at "
.8f50	a9 6d		lda #$6d			lda 	#_AtMsg & $FF
.8f52	20 77 8f	jsr $8f77			jsr 	PrintStringXA
.8f55	a0 01		ldy #$01			ldy 	#1 							; line number into XA
.8f57	b1 30		lda ($30),y			lda 	(codePtr),y
.8f59	48		pha				pha
.8f5a	c8		iny				iny
.8f5b	b1 30		lda ($30),y			lda 	(codePtr),y
.8f5d	aa		tax				tax
.8f5e	68		pla				pla
.8f5f	20 8d 93	jsr $938d			jsr 	ConvertInt16 				; convert XA to string
.8f62	20 77 8f	jsr $8f77			jsr 	PrintStringXA 				; and print it.
.8f65					_EHCREnd:
.8f65	a9 0d		lda #$0d			lda 	#13 						; new line
.8f67	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8f6a					_EHEnd:
.8f6a	4c 97 83	jmp $8397			jmp 	WarmStart
>8f6d	20 61 74 20 6c 69 6e 65		_AtMsg:	.text 	" at line ",0
>8f75	20 00
.8f77					PrintStringXA:
.8f77	5a		phy				phy
.8f78	86 37		stx $37				stx 	zTemp0+1
.8f7a	85 36		sta $36				sta 	zTemp0
.8f7c	a0 00		ldy #$00			ldy 	#0
.8f7e					_PSXALoop:
.8f7e	b1 36		lda ($36),y			lda 	(zTemp0),y
.8f80	f0 06		beq $8f88			beq 	_PSXAExit
.8f82	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8f85	c8		iny				iny
.8f86	80 f6		bra $8f7e			bra 	_PSXALoop
.8f88					_PSXAExit:
.8f88	7a		ply				ply
.8f89	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/compare.asm

.8f8a					UnaryTrue:
.8f8a	fa		plx				plx
.8f8b					ReturnTrue:
.8f8b	a9 01		lda #$01			lda 	#1  						; set to 1
.8f8d	20 42 9e	jsr $9e42			jsr 	NSMSetByte
.8f90	a9 80		lda #$80			lda 	#$80 						; set sign flag, so it is -1
.8f92	95 50		sta $50,x			sta 	NSStatus,x
.8f94	60		rts				rts
.8f95					UnaryFalse:
.8f95	fa		plx				plx
.8f96					ReturnFalse:
.8f96	4c 40 9e	jmp $9e40			jmp 	NSMSetZero 					; set it all to zero
.8f99					BinaryCompareEqual:
.8f99	fa		plx				plx
.8f9a	20 d5 8f	jsr $8fd5			jsr 	CompareBaseCode
.8f9d	c9 00		cmp #$00			cmp 	#0
.8f9f	f0 ea		beq $8f8b			beq 	ReturnTrue
.8fa1	80 f3		bra $8f96			bra 	ReturnFalse
.8fa3					BinaryCompareLess:
.8fa3	fa		plx				plx
.8fa4	20 d5 8f	jsr $8fd5			jsr 	CompareBaseCode
.8fa7	c9 ff		cmp #$ff			cmp 	#$FF
.8fa9	f0 e0		beq $8f8b			beq 	ReturnTrue
.8fab	80 e9		bra $8f96			bra 	ReturnFalse
.8fad					BinaryCompareGreater:
.8fad	fa		plx				plx
.8fae	20 d5 8f	jsr $8fd5			jsr 	CompareBaseCode
.8fb1	c9 01		cmp #$01			cmp 	#1
.8fb3	f0 d6		beq $8f8b			beq 	ReturnTrue
.8fb5	80 df		bra $8f96			bra 	ReturnFalse
.8fb7					BinaryCompareNotEqual:
.8fb7	fa		plx				plx
.8fb8	20 d5 8f	jsr $8fd5			jsr 	CompareBaseCode
.8fbb	c9 00		cmp #$00			cmp 	#0
.8fbd	d0 cc		bne $8f8b			bne 	ReturnTrue
.8fbf	80 d5		bra $8f96			bra 	ReturnFalse
.8fc1					BinaryCompareLessEqual:
.8fc1	fa		plx				plx
.8fc2	20 d5 8f	jsr $8fd5			jsr 	CompareBaseCode
.8fc5	c9 01		cmp #$01			cmp 	#1
.8fc7	d0 c2		bne $8f8b			bne 	ReturnTrue
.8fc9	80 cb		bra $8f96			bra 	ReturnFalse
.8fcb					BinaryCompareGreaterEqual:
.8fcb	fa		plx				plx
.8fcc	20 d5 8f	jsr $8fd5			jsr 	CompareBaseCode
.8fcf	c9 ff		cmp #$ff			cmp 	#$FF
.8fd1	d0 b8		bne $8f8b			bne 	ReturnTrue
.8fd3	80 c1		bra $8f96			bra 	ReturnFalse
.8fd5					CompareBaseCode:
.8fd5	20 e0 96	jsr $96e0			jsr 	DereferenceTopTwo 			; make both values if references.
.8fd8	b5 50		lda $50,x			lda 	NSStatus,x 					; check if either is a string.
.8fda	15 51		ora $51,x			ora 	NSStatus+1,x
.8fdc	29 10		and #$10			and 	#NSTString
.8fde	d0 37		bne $9017			bne 	_CBCString 					; if so do string code, which will check if both.
.8fe0	b5 78		lda $78,x			lda 	NSExponent,x 				; check both are integers
.8fe2	15 79		ora $79,x			ora 	NSExponent+1,x
.8fe4	d0 34		bne $901a			bne 	_CBCFloat
.8fe6	b5 50		lda $50,x			lda 	NSStatus,x
.8fe8	15 51		ora $51,x			ora 	NSStatus+1,x
.8fea	29 08		and #$08			and 	#NSTFloat
.8fec	d0 2c		bne $901a			bne 	_CBCFloat
.8fee	20 1d 90	jsr $901d			jsr 	CompareFixMinusZero 		; fix up -0 just in cases.
.8ff1	e8		inx				inx
.8ff2	20 1d 90	jsr $901d			jsr 	CompareFixMinusZero
.8ff5	ca		dex				dex
.8ff6	b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs different ?
.8ff8	55 51		eor $51,x			eor 	NSStatus+1,x
.8ffa	10 0a		bpl $9006			bpl 	_CDCSameSign
.8ffc	b5 50		lda $50,x			lda 	NSStatus,x 					; if first one is -ve
.8ffe	30 14		bmi $9014			bmi 	_CBCLess 					; return $FF
.9000					_CBCGreater:
.9000	a9 01		lda #$01			lda 	#1
.9002	60		rts				rts
.9003					_CBCEqual:
.9003	a9 00		lda #$00			lda 	#0
.9005	60		rts				rts
.9006					_CDCSameSign:
.9006	20 32 92	jsr $9232			jsr 	SubTopTwoStack 				; unsigned subtract
.9009	20 62 9e	jsr $9e62			jsr 	NSMIsZero 					; or the mantissa together
.900c	f0 f5		beq $9003			beq 	_CBCEqual 					; -0 == 0
.900e	b5 70		lda $70,x			lda 	NSMantissa3,x 				; sign of the result. if +ve return $01 else return $FF
.9010	55 51		eor $51,x			eor 	NSStatus+1,x 				; however if both were -ve this is inverted
.9012	10 ec		bpl $9000			bpl 	_CBCGreater
.9014					_CBCLess:
.9014	a9 ff		lda #$ff			lda 	#$FF
.9016	60		rts				rts
.9017					_CBCString:
.9017	4c a3 91	jmp $91a3			jmp 	CompareStrings
.901a					_CBCFloat:
.901a	4c ed 94	jmp $94ed			jmp 	CompareFloat
.901d					CompareFixMinusZero:
.901d	20 62 9e	jsr $9e62			jsr 	NSMIsZero
.9020	d0 02		bne $9024			bne 	_CFXMZNotZero
.9022	74 50		stz $50,x			stz 	NSStatus,x
.9024					_CFXMZNotZero:
.9024	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/concat.asm

.9025					StringConcat:
.9025	b5 50		lda $50,x			lda 	NSStatus,x 					; check both strings
.9027	35 51		and $51,x			and 	NSStatus+1,x
.9029	29 18		and #$18			and 	#NSBTypeMask
.902b	c9 10		cmp #$10			cmp 	#NSTString
.902d	d0 50		bne $907f			bne		_SCType
.902f	64 38		stz $38				stz 	zTemp1 						; counting total length
.9031	e8		inx				inx
.9032	20 50 90	jsr $9050			jsr 	_SCSetupZ0 					; setup for second
.9035	20 59 90	jsr $9059			jsr 	_SCLengthZ0 				; length for second
.9038	ca		dex				dex
.9039	20 50 90	jsr $9050			jsr 	_SCSetupZ0 					; setup for first
.903c	20 59 90	jsr $9059			jsr 	_SCLengthZ0 				; length for first
.903f	a5 38		lda $38				lda 	zTemp1 						; allocate memory using total.
.9041	20 c3 a7	jsr $a7c3			jsr 	StringTempAllocate
.9044	20 70 90	jsr $9070			jsr 	_SCCopy 					; copy first out, using zTemp0 from above
.9047	e8		inx				inx
.9048	20 50 90	jsr $9050			jsr 	_SCSetupZ0 					; copy second out
.904b	20 70 90	jsr $9070			jsr 	_SCCopy
.904e	ca		dex				dex
.904f	60		rts				rts
.9050					_SCSetupZ0:
.9050	b5 58		lda $58,x			lda 	NSMantissa0,x
.9052	85 36		sta $36				sta 	zTemp0
.9054	b5 60		lda $60,x			lda 	NSMantissa1,x
.9056	85 37		sta $37				sta 	zTemp0+1
.9058	60		rts				rts
.9059					_SCLengthZ0:
.9059	5a		phy				phy
.905a	a0 00		ldy #$00			ldy 	#0
.905c					_SCLenLoop:
.905c	b1 36		lda ($36),y			lda 	(zTemp0),y
.905e	f0 0e		beq $906e			beq 	_SCLExit
.9060	c8		iny				iny
.9061	e6 38		inc $38				inc 	zTemp1
.9063	a5 38		lda $38				lda	 	zTemp1 						; check string too long.
.9065	c9 fd		cmp #$fd			cmp 	#253
.9067	d0 f3		bne $905c			bne		_SCLenLoop
.9069	a9 09		lda #$09		lda	#9
.906b	4c 1e 8f	jmp $8f1e		jmp	ErrorHandler
.906e					_SCLExit:
.906e	7a		ply				ply
.906f	60		rts				rts
.9070					_SCCopy:
.9070	5a		phy				phy
.9071	a0 00		ldy #$00			ldy 	#0
.9073					_SCCopyLoop:
.9073	b1 36		lda ($36),y			lda 	(zTemp0),y
.9075	f0 06		beq $907d			beq 	_SCCExit
.9077	20 fc a7	jsr $a7fc			jsr 	StringTempWrite
.907a	c8		iny				iny
.907b	80 f6		bra $9073			bra 	_SCCopyLoop
.907d					_SCCExit:
.907d	7a		ply				ply
.907e	60		rts				rts
.907f					_SCType:
.907f	4c c8 9f	jmp $9fc8			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/divide.asm

.9082					IntegerDivide:
.9082	fa		plx				plx
.9083	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9085	15 51		ora $51,x			ora 	NSStatus+1,x
.9087	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9088	0a		asl a				asl 	a
.9089	10 05		bpl $9090			bpl 	_NotRef
.908b	48		pha				pha
.908c	20 e0 96	jsr $96e0			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.908f	68		pla				pla
.9090					_NotRef:
.9090	0a		asl a				asl 	a
.9091	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9093	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9095	15 79		ora $79,x			ora 	NSExponent+1,x
.9097	f0 03		beq $909c			beq 	_IntegerCode 				; if clear, then we have two integers
.9099	4c c8 9f	jmp $9fc8			jmp 	TypeError 					; anything else, type mismatch.
.909c					_IntegerCode:
.909c	20 b6 90	jsr $90b6			jsr 	CheckDivideZero 			; do div zero check
.909f	20 e8 90	jsr $90e8			jsr 	Int32Divide 				; do the division
.90a2	20 99 91	jsr $9199			jsr 	CalculateSign 				; calculate result sign
.90a5					NSMCopyPlusTwoToZero:
.90a5	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.90a7	95 58		sta $58,x			sta 	NSMantissa0,x
.90a9	b5 62		lda $62,x			lda 	NSMantissa1+2,x
.90ab	95 60		sta $60,x			sta 	NSMantissa1,x
.90ad	b5 6a		lda $6a,x			lda 	NSMantissa2+2,x
.90af	95 68		sta $68,x			sta 	NSMantissa2,x
.90b1	b5 72		lda $72,x			lda 	NSMantissa3+2,x
.90b3	95 70		sta $70,x			sta 	NSMantissa3,x
.90b5	60		rts				rts
.90b6					CheckDivideZero:
.90b6	e8		inx				inx
.90b7	20 62 9e	jsr $9e62			jsr 	NSMIsZero
.90ba	f0 02		beq $90be			beq 	_CDVError
.90bc	ca		dex				dex
.90bd	60		rts				rts
.90be					_CDVError:
.90be	a9 03		lda #$03		lda	#3
.90c0	4c 1e 8f	jmp $8f1e		jmp	ErrorHandler
.90c3					IntegerModulus:
.90c3	fa		plx				plx
.90c4	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.90c6	15 51		ora $51,x			ora 	NSStatus+1,x
.90c8	0a		asl a				asl 	a 							; shift reference bit into sign bit
.90c9	0a		asl a				asl 	a
.90ca	10 05		bpl $90d1			bpl 	_NotRef
.90cc	48		pha				pha
.90cd	20 e0 96	jsr $96e0			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.90d0	68		pla				pla
.90d1					_NotRef:
.90d1	0a		asl a				asl 	a
.90d2	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.90d4	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.90d6	15 79		ora $79,x			ora 	NSExponent+1,x
.90d8	f0 03		beq $90dd			beq 	_IntegerCode 				; if clear, then we have two integers
.90da	4c c8 9f	jmp $9fc8			jmp 	TypeError 					; anything else, type mismatch.
.90dd					_IntegerCode:
.90dd					IntegerModulusNoCheck:
.90dd	20 b6 90	jsr $90b6			jsr 	CheckDivideZero 			; do div zero check
.90e0	20 e8 90	jsr $90e8			jsr 	Int32Divide 				; do the division
.90e3	16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.90e5	56 50		lsr $50,x			lsr 	NSStatus,x
.90e7	60		rts				rts
.90e8					Int32Divide:
.90e8	48		pha				pha 								; save AXY
.90e9	5a		phy				phy
.90ea	20 23 9e	jsr $9e23			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.90ed	20 3c 9e	jsr $9e3c			jsr 	NSMSetZeroMantissaOnly 		; set S[X] to zero
.90f0	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.90f2					_I32DivideLoop:
.90f2	e8		inx				inx
.90f3	e8		inx				inx
.90f4	20 4f 9e	jsr $9e4f			jsr 	NSMShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.90f7	ca		dex				dex
.90f8	ca		dex				dex
.90f9	20 50 9e	jsr $9e50			jsr 	NSMRotateLeft
.90fc	20 27 91	jsr $9127			jsr 	DivideCheckSubtract 		; check if subtract possible
.90ff	90 02		bcc $9103			bcc 	_I32DivideNoCarryIn
.9101	f6 5a		inc $5a,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.9103					_I32DivideNoCarryIn:
.9103	88		dey				dey 								; loop round till division completed.
.9104	d0 ec		bne $90f2			bne 	_I32DivideLoop
.9106	7a		ply				ply 								; restore AXY and exit
.9107	68		pla				pla
.9108	60		rts				rts
.9109					Int32ShiftDivide:
.9109	48		pha				pha 								; save AY
.910a	5a		phy				phy
.910b	e8		inx				inx 								; clear S[X+2]
.910c	e8		inx				inx
.910d	20 40 9e	jsr $9e40			jsr 	NSMSetZero
.9110	ca		dex				dex
.9111	ca		dex				dex
.9112	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.9114					_I32SDLoop:
.9114	20 27 91	jsr $9127			jsr 	DivideCheckSubtract 		; check if subtract possible
.9117	e8		inx				inx
.9118	e8		inx				inx
.9119	20 50 9e	jsr $9e50			jsr 	NSMRotateLeft				; shift 64 bit FPA left, rotating carry in
.911c	ca		dex				dex
.911d	ca		dex				dex
.911e	20 50 9e	jsr $9e50			jsr 	NSMRotateLeft
.9121	88		dey				dey 	 							; do 31 times
.9122	d0 f0		bne $9114			bne 	_I32SDLoop
.9124	7a		ply				ply 								; restore AY and exit
.9125	68		pla				pla
.9126	60		rts				rts
.9127					DivideCheckSubtract:
.9127	20 32 92	jsr $9232			jsr 	SubTopTwoStack 				; subtract Stack[X+1] from Stack[X+0]
.912a	b0 04		bcs $9130			bcs 	_DCSExit 					; if carry set, then could do, exit
.912c	20 18 92	jsr $9218			jsr 	AddTopTwoStack 				; add it back in
.912f	18		clc				clc 								; and return False
.9130					_DCSExit:
.9130	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/multiply.asm

.9131					MulInteger:
.9131	fa		plx				plx
.9132	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9134	15 51		ora $51,x			ora 	NSStatus+1,x
.9136	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9137	0a		asl a				asl 	a
.9138	10 05		bpl $913f			bpl 	_NotRef
.913a	48		pha				pha
.913b	20 e0 96	jsr $96e0			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.913e	68		pla				pla
.913f					_NotRef:
.913f	0a		asl a				asl 	a 							; put MSB of type into A:7
.9140	30 09		bmi $914b			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9142	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9144	15 79		ora $79,x			ora 	NSExponent+1,x
.9146	f0 06		beq $914e			beq 	_IntegerCode 				; if clear, then we have two integers
.9148	4c af 95	jmp $95af			jmp 	FloatingPointMultiply 							; otherwise at least one float.
.914b					_StringData:
.914b	4c d2 9f	jmp $9fd2			jmp 	NotDoneError							; at least one string - don't know both are strings.
.914e					_IntegerCode:
.914e	20 5b 91	jsr $915b			jsr 	MultiplyShort
.9151	c9 00		cmp #$00			cmp 	#0
.9153	f0 05		beq $915a			beq 	_MIExit
.9155	a9 04		lda #$04		lda	#4
.9157	4c 1e 8f	jmp $8f1e		jmp	ErrorHandler
.915a					_MIExit:
.915a	60		rts				rts
.915b					MultiplyShort:
.915b	5a		phy				phy 								; save Y
.915c	20 23 9e	jsr $9e23			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.915f	20 3c 9e	jsr $9e3c			jsr 	NSMSetZeroMantissaOnly 		; set mantissa S[X] to zero
.9162	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.9164					_I32MLoop:
.9164	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.9166	15 62		ora $62,x			ora 	NSMantissa1+2,x
.9168	15 6a		ora $6a,x			ora 	NSMantissa2+2,x
.916a	15 72		ora $72,x			ora 	NSMantissa3+2,x
.916c	f0 25		beq $9193			beq 	_I32MExit 					; exit if zero
.916e	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.9170	29 01		and #$01			and 	#1
.9172	f0 0d		beq $9181			beq 	_I32MNoAdd
.9174	20 18 92	jsr $9218			jsr 	AddTopTwoStack 				; if so add S[X+1] to S[X+0]
.9177	b5 70		lda $70,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.9179	10 06		bpl $9181			bpl 	_I32MNoAdd
.917b					_I32ShiftRight:
.917b	20 59 9e	jsr $9e59			jsr 	NSMShiftRight 				; shift S[X] right
.917e	c8		iny				iny 								; increment shift count
.917f	80 09		bra $918a			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.9181					_I32MNoAdd:
.9181	34 71		bit $71,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.9183	70 f6		bvs $917b			bvs 	_I32ShiftRight 				; instead.
.9185	e8		inx				inx
.9186	20 4f 9e	jsr $9e4f			jsr 	NSMShiftLeft 				; shift additive S[X+1] left
.9189	ca		dex				dex
.918a					_I32MShiftUpper:
.918a	e8		inx				inx 								; shift S[X+2] right
.918b	e8		inx				inx
.918c	20 59 9e	jsr $9e59			jsr 	NSMShiftRight
.918f	ca		dex				dex
.9190	ca		dex				dex
.9191	80 d1		bra $9164			bra 	_I32MLoop 					; try again.
.9193					_I32MExit:
.9193	20 99 91	jsr $9199			jsr 	CalculateSign
.9196	98		tya				tya 								; shift in A
.9197	7a		ply				ply 								; restore Y and exit
.9198	60		rts				rts
.9199					CalculateSign:
.9199	b5 50		lda $50,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.919b	16 50		asl $50,x			asl 	NSStatus,x 					; shift result left
.919d	55 51		eor $51,x			eor 	NSStatus+1,x
.919f	0a		asl a				asl 	a 							; shift bit 7 into carry
.91a0	76 50		ror $50,x			ror 	NSStatus,x 					; shift right into status byte.
.91a2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/scompare.asm

.91a3					CompareStrings:
.91a3	b5 50		lda $50,x			lda 	NSStatus,x 					; check both are strings
.91a5	35 51		and $51,x			and 	NSStatus+1,x
.91a7	29 10		and #$10			and 	#NSBIsString
.91a9	f0 28		beq $91d3			beq 	_CSTypeError
.91ab	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy string addresses to zTemp0/1
.91ad	85 36		sta $36				sta 	zTemp0
.91af	b5 60		lda $60,x			lda 	NSMantissa1,x
.91b1	85 37		sta $37				sta 	zTemp0+1
.91b3	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.91b5	85 38		sta $38				sta 	zTemp1
.91b7	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.91b9	85 39		sta $39				sta 	zTemp1+1
.91bb	5a		phy				phy 								; save Y so we can access strings
.91bc	a0 ff		ldy #$ff			ldy 	#$FF 						; -1 for pre increment.
.91be					_CSLoop:
.91be	c8		iny				iny
.91bf	b1 36		lda ($36),y			lda 	(zTemp0),y 					; check if they are the same
.91c1	d1 38		cmp ($38),y			cmp 	(zTemp1),y
.91c3	d0 06		bne $91cb			bne 	_CSDifferent
.91c5	c9 00		cmp #$00			cmp 	#0 							; reached end ?
.91c7	d0 f5		bne $91be			bne 	_CSLoop 					; still comparing
.91c9					_CSExit:
.91c9	7a		ply				ply 								; reached end, return zero in A from EOS
.91ca	60		rts				rts
.91cb					_CSDifferent:
.91cb	a9 ff		lda #$ff			lda 	#255 						; if < return $FF
.91cd	90 fa		bcc $91c9			bcc		_CSExit
.91cf	a9 01		lda #$01			lda 	#1 							; otherwise return 1.
.91d1	80 f6		bra $91c9			bra 	_CSExit
.91d3					_CSTypeError:
.91d3	4c c8 9f	jmp $9fc8			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/shifts.asm

.91d6					ShiftLeft:
.91d6	38		sec				sec 								; common code, carry determines which way.
.91d7	80 01		bra $91da			bra 	ShiftMain
.91d9					ShiftRight:
.91d9	18		clc				clc
.91da					ShiftMain:
.91da	fa		plx				plx 								; restore X
.91db	08		php				php 								; save direction
.91dc	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.91de	15 51		ora $51,x			ora 	NSStatus+1,x
.91e0	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91e1	0a		asl a				asl 	a
.91e2	10 05		bpl $91e9			bpl 	_NotRef
.91e4	48		pha				pha
.91e5	20 e0 96	jsr $96e0			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91e8	68		pla				pla
.91e9					_NotRef:
.91e9	0a		asl a				asl 	a
.91ea	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.91ec	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91ee	15 79		ora $79,x			ora 	NSExponent+1,x
.91f0	f0 03		beq $91f5			beq 	_IntegerCode 				; if clear, then we have two integers
.91f2	4c c8 9f	jmp $9fc8			jmp 	TypeError 					; anything else, type mismatch.
.91f5					_IntegerCode:
.91f5	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; check number < 32
.91f7	29 e0		and #$e0			and 	#$E0
.91f9	15 61		ora $61,x			ora 	NSMantissa1+1,x
.91fb	15 69		ora $69,x			ora 	NSMantissa2+1,x
.91fd	15 71		ora $71,x			ora 	NSMantissa3+1,x
.91ff	d0 12		bne $9213			bne 	_SMExit0 					; if >= 32 it will always return zero.
.9201					_SMLoop:
.9201	d6 59		dec $59,x			dec 	NSMantissa0+1,x 			; predecrement, could do << 0
.9203	30 11		bmi $9216			bmi 	_SMExit 					; exit if done.
.9205	28		plp				plp 								; restore direction setting
.9206	08		php				php
.9207	90 05		bcc $920e			bcc 	_SMRight
.9209	20 4f 9e	jsr $9e4f			jsr 	NSMShiftLeft 				; shift left if CS
.920c	80 f3		bra $9201			bra 	_SMLoop
.920e					_SMRight:
.920e	20 59 9e	jsr $9e59			jsr 	NSMShiftRight 				; shift right if CC
.9211	80 ee		bra $9201			bra 	_SMLoop
.9213					_SMExit0:
.9213	20 40 9e	jsr $9e40			jsr 	NSMSetZero 					; return zero.
.9216					_SMExit:
.9216	28		plp				plp 								; throw direction
.9217	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/simple.asm

.9218					AddTopTwoStack:
.9218	18		clc				clc
.9219	b5 58		lda $58,x			lda		NSMantissa0,x
.921b	75 59		adc $59,x			adc 		NSMantissa0+1,x
.921d	95 58		sta $58,x			sta 	NSMantissa0,x
.921f	b5 60		lda $60,x			lda		NSMantissa1,x
.9221	75 61		adc $61,x			adc 		NSMantissa1+1,x
.9223	95 60		sta $60,x			sta 	NSMantissa1,x
.9225	b5 68		lda $68,x			lda		NSMantissa2,x
.9227	75 69		adc $69,x			adc 		NSMantissa2+1,x
.9229	95 68		sta $68,x			sta 	NSMantissa2,x
.922b	b5 70		lda $70,x			lda		NSMantissa3,x
.922d	75 71		adc $71,x			adc 		NSMantissa3+1,x
.922f	95 70		sta $70,x			sta 	NSMantissa3,x
.9231	60		rts				rts
.9232					SubTopTwoStack:
.9232	38		sec				sec
.9233	b5 58		lda $58,x			lda		NSMantissa0,x
.9235	f5 59		sbc $59,x			sbc 		NSMantissa0+1,x
.9237	95 58		sta $58,x			sta 	NSMantissa0,x
.9239	b5 60		lda $60,x			lda		NSMantissa1,x
.923b	f5 61		sbc $61,x			sbc 		NSMantissa1+1,x
.923d	95 60		sta $60,x			sta 	NSMantissa1,x
.923f	b5 68		lda $68,x			lda		NSMantissa2,x
.9241	f5 69		sbc $69,x			sbc 		NSMantissa2+1,x
.9243	95 68		sta $68,x			sta 	NSMantissa2,x
.9245	b5 70		lda $70,x			lda		NSMantissa3,x
.9247	f5 71		sbc $71,x			sbc 		NSMantissa3+1,x
.9249	95 70		sta $70,x			sta 	NSMantissa3,x
.924b	60		rts				rts
.924c					AddInteger:
.924c	fa		plx				plx
.924d	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.924f	15 51		ora $51,x			ora 	NSStatus+1,x
.9251	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9252	0a		asl a				asl 	a
.9253	10 05		bpl $925a			bpl 	_NotRef
.9255	48		pha				pha
.9256	20 e0 96	jsr $96e0			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9259	68		pla				pla
.925a					_NotRef:
.925a	0a		asl a				asl 	a 							; put MSB of type into A:7
.925b	30 09		bmi $9266			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.925d	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.925f	15 79		ora $79,x			ora 	NSExponent+1,x
.9261	f0 06		beq $9269			beq 	_IntegerCode 				; if clear, then we have two integers
.9263	4c 5f 94	jmp $945f			jmp 	FloatingPointAdd 							; otherwise at least one float.
.9266					_StringData:
.9266	4c 25 90	jmp $9025			jmp 	StringConcat							; at least one string - don't know both are strings.
.9269					_IntegerCode:
.9269					AddCode:
.9269	b5 50		lda $50,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.926b	55 51		eor $51,x			eor 	NSStatus+1,x
.926d	10 a9		bpl $9218			bpl 	AddTopTwoStack
.926f	20 32 92	jsr $9232			jsr 	SubTopTwoStack 				; do a physical subtraction
.9272	34 70		bit $70,x			bit 	NSMantissa3,x 				; result is +ve, okay
.9274	10 07		bpl $927d			bpl 	_AddExit
.9276	b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign is that of 2nd value
.9278	95 50		sta $50,x			sta 	NSStatus,x
.927a	20 09 9e	jsr $9e09			jsr 	NSMNegateMantissa 			; negate the mantissa and exit
.927d					_AddExit:
.927d	20 62 9e	jsr $9e62			jsr 	NSMIsZero 					; check for -0
.9280	d0 02		bne $9284			bne 	_AddNonZero
.9282	74 50		stz $50,x			stz 	NSStatus,x
.9284					_AddNonZero:
.9284	60		rts				rts
.9285					SubInteger:
.9285	fa		plx				plx
.9286	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9288	15 51		ora $51,x			ora 	NSStatus+1,x
.928a	0a		asl a				asl 	a 							; shift reference bit into sign bit
.928b	0a		asl a				asl 	a
.928c	10 05		bpl $9293			bpl 	_NotRef
.928e	48		pha				pha
.928f	20 e0 96	jsr $96e0			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9292	68		pla				pla
.9293					_NotRef:
.9293	0a		asl a				asl 	a 							; put MSB of type into A:7
.9294	30 09		bmi $929f			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9296	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9298	15 79		ora $79,x			ora 	NSExponent+1,x
.929a	f0 06		beq $92a2			beq 	_IntegerCode 				; if clear, then we have two integers
.929c	4c 64 94	jmp $9464			jmp 	FloatingPointSub 							; otherwise at least one float.
.929f					_StringData:
.929f	4c d2 9f	jmp $9fd2			jmp 	NotDoneError							; at least one string - don't know both are strings.
.92a2					_IntegerCode:
.92a2	b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate the second value.
.92a4	49 80		eor #$80			eor 	#$80
.92a6	95 51		sta $51,x			sta 	NSStatus+1,x
.92a8	80 bf		bra $9269			bra 	AddCode 					; and do the same code as add.
.92aa					AndInteger:
.92aa	fa		plx				plx
.92ab	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.92ad	15 51		ora $51,x			ora 	NSStatus+1,x
.92af	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92b0	0a		asl a				asl 	a
.92b1	10 05		bpl $92b8			bpl 	_NotRef
.92b3	48		pha				pha
.92b4	20 e0 96	jsr $96e0			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92b7	68		pla				pla
.92b8					_NotRef:
.92b8	0a		asl a				asl 	a
.92b9	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.92bb	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92bd	15 79		ora $79,x			ora 	NSExponent+1,x
.92bf	f0 03		beq $92c4			beq 	_IntegerCode 				; if clear, then we have two integers
.92c1	4c c8 9f	jmp $9fc8			jmp 	TypeError 					; anything else, type mismatch.
.92c4					_IntegerCode:
.92c4	b5 58		lda $58,x			lda		NSMantissa0,x
.92c6	35 59		and $59,x			and 		NSMantissa0+1,x
.92c8	95 58		sta $58,x			sta 	NSMantissa0,x
.92ca	b5 60		lda $60,x			lda		NSMantissa1,x
.92cc	35 61		and $61,x			and 		NSMantissa1+1,x
.92ce	95 60		sta $60,x			sta 	NSMantissa1,x
.92d0	b5 68		lda $68,x			lda		NSMantissa2,x
.92d2	35 69		and $69,x			and 		NSMantissa2+1,x
.92d4	95 68		sta $68,x			sta 	NSMantissa2,x
.92d6	b5 70		lda $70,x			lda		NSMantissa3,x
.92d8	35 71		and $71,x			and 		NSMantissa3+1,x
.92da	95 70		sta $70,x			sta 	NSMantissa3,x
.92dc	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.92de	60		rts				rts
.92df					OraInteger:
.92df	fa		plx				plx
.92e0	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.92e2	15 51		ora $51,x			ora 	NSStatus+1,x
.92e4	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92e5	0a		asl a				asl 	a
.92e6	10 05		bpl $92ed			bpl 	_NotRef
.92e8	48		pha				pha
.92e9	20 e0 96	jsr $96e0			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92ec	68		pla				pla
.92ed					_NotRef:
.92ed	0a		asl a				asl 	a
.92ee	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.92f0	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92f2	15 79		ora $79,x			ora 	NSExponent+1,x
.92f4	f0 03		beq $92f9			beq 	_IntegerCode 				; if clear, then we have two integers
.92f6	4c c8 9f	jmp $9fc8			jmp 	TypeError 					; anything else, type mismatch.
.92f9					_IntegerCode:
.92f9	b5 58		lda $58,x			lda		NSMantissa0,x
.92fb	15 59		ora $59,x			ora 		NSMantissa0+1,x
.92fd	95 58		sta $58,x			sta 	NSMantissa0,x
.92ff	b5 60		lda $60,x			lda		NSMantissa1,x
.9301	15 61		ora $61,x			ora 		NSMantissa1+1,x
.9303	95 60		sta $60,x			sta 	NSMantissa1,x
.9305	b5 68		lda $68,x			lda		NSMantissa2,x
.9307	15 69		ora $69,x			ora 		NSMantissa2+1,x
.9309	95 68		sta $68,x			sta 	NSMantissa2,x
.930b	b5 70		lda $70,x			lda		NSMantissa3,x
.930d	15 71		ora $71,x			ora 		NSMantissa3+1,x
.930f	95 70		sta $70,x			sta 	NSMantissa3,x
.9311	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.9313	60		rts				rts
.9314					EorInteger:
.9314	fa		plx				plx
.9315	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9317	15 51		ora $51,x			ora 	NSStatus+1,x
.9319	0a		asl a				asl 	a 							; shift reference bit into sign bit
.931a	0a		asl a				asl 	a
.931b	10 05		bpl $9322			bpl 	_NotRef
.931d	48		pha				pha
.931e	20 e0 96	jsr $96e0			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9321	68		pla				pla
.9322					_NotRef:
.9322	0a		asl a				asl 	a
.9323	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9325	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9327	15 79		ora $79,x			ora 	NSExponent+1,x
.9329	f0 03		beq $932e			beq 	_IntegerCode 				; if clear, then we have two integers
.932b	4c c8 9f	jmp $9fc8			jmp 	TypeError 					; anything else, type mismatch.
.932e					_IntegerCode:
.932e	b5 58		lda $58,x			lda		NSMantissa0,x
.9330	55 59		eor $59,x			eor 		NSMantissa0+1,x
.9332	95 58		sta $58,x			sta 	NSMantissa0,x
.9334	b5 60		lda $60,x			lda		NSMantissa1,x
.9336	55 61		eor $61,x			eor 		NSMantissa1+1,x
.9338	95 60		sta $60,x			sta 	NSMantissa1,x
.933a	b5 68		lda $68,x			lda		NSMantissa2,x
.933c	55 69		eor $69,x			eor 		NSMantissa2+1,x
.933e	95 68		sta $68,x			sta 	NSMantissa2,x
.9340	b5 70		lda $70,x			lda		NSMantissa3,x
.9342	55 71		eor $71,x			eor 		NSMantissa3+1,x
.9344	95 70		sta $70,x			sta 	NSMantissa3,x
.9346	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.9348	60		rts				rts
.9349					WordIndirect:
.9349	fa		plx				plx
.934a	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.934c	15 51		ora $51,x			ora 	NSStatus+1,x
.934e	0a		asl a				asl 	a 							; shift reference bit into sign bit
.934f	0a		asl a				asl 	a
.9350	10 05		bpl $9357			bpl 	_NotRef
.9352	48		pha				pha
.9353	20 e0 96	jsr $96e0			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9356	68		pla				pla
.9357					_NotRef:
.9357	0a		asl a				asl 	a
.9358	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.935a	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.935c	15 79		ora $79,x			ora 	NSExponent+1,x
.935e	f0 03		beq $9363			beq 	_IntegerCode 				; if clear, then we have two integers
.9360	4c c8 9f	jmp $9fc8			jmp 	TypeError 					; anything else, type mismatch.
.9363					_IntegerCode:
.9363	20 69 92	jsr $9269			jsr 	AddCode 					; add the two values
.9366	a9 22		lda #$22			lda 	#NSBIsReference+2 			; make a 2 byte reference
.9368	95 50		sta $50,x			sta 	NSStatus,x
.936a	60		rts				rts
.936b					ByteIndirect:
.936b	fa		plx				plx
.936c	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.936e	15 51		ora $51,x			ora 	NSStatus+1,x
.9370	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9371	0a		asl a				asl 	a
.9372	10 05		bpl $9379			bpl 	_NotRef
.9374	48		pha				pha
.9375	20 e0 96	jsr $96e0			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9378	68		pla				pla
.9379					_NotRef:
.9379	0a		asl a				asl 	a
.937a	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.937c	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.937e	15 79		ora $79,x			ora 	NSExponent+1,x
.9380	f0 03		beq $9385			beq 	_IntegerCode 				; if clear, then we have two integers
.9382	4c c8 9f	jmp $9fc8			jmp 	TypeError 					; anything else, type mismatch.
.9385					_IntegerCode:
.9385	20 69 92	jsr $9269			jsr 	AddCode 					; add the two values
.9388	a9 21		lda #$21			lda 	#NSBIsReference+1 			; make a 1 byte reference
.938a	95 50		sta $50,x			sta 	NSStatus,x
.938c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/tostring.asm

.938d					ConvertInt16:
.938d	85 58		sta $58				sta 	NSMantissa0 				; set up as 32 bit conversion
.938f	86 60		stx $60				stx 	NSMantissa1
.9391	64 68		stz $68				stz 	NSMantissa2
.9393	64 70		stz $70				stz 	NSMantissa3
.9395	64 50		stz $50				stz 	NSStatus 					; positive integer
.9397	a2 00		ldx #$00			ldx 	#0 							; stack level
.9399	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.939b	80 00		bra $939d			bra 	ConvertInt32
.939d					ConvertInt32:
.939d	5a		phy				phy
.939e	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.93a0	24 50		bit $50				bit 	NSStatus 					; output a - if not negative.
.93a2	10 08		bpl $93ac			bpl 	_CI32NotNeg
.93a4	48		pha				pha
.93a5	a9 2d		lda #$2d			lda 	#'-'
.93a7	99 27 06	sta $0627,y			sta 	NumberBuffer,y
.93aa	c8		iny				iny
.93ab	68		pla				pla
.93ac					_CI32NotNeg:
.93ac	20 ba 93	jsr $93ba			jsr 	_CI32DivideConvert 			; recursive conversion
.93af	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.93b1	99 27 06	sta $0627,y			sta 	NumberBuffer,y
.93b4	7a		ply				ply
.93b5	a2 06		ldx #$06			ldx 	#NumberBuffer >> 8 			; return address in XA
.93b7	a9 27		lda #$27			lda 	#NumberBuffer & $FF
.93b9	60		rts				rts
.93ba					_CI32DivideConvert:
.93ba	e8		inx				inx 								; write to next slot up
.93bb	20 42 9e	jsr $9e42			jsr 	NSMSetByte 		 			; write the base out.
.93be	ca		dex				dex
.93bf	20 e8 90	jsr $90e8			jsr 	Int32Divide 				; divide
.93c2	b5 58		lda $58,x			lda 	NSMantissa0,x 				; save remainder
.93c4	48		pha				pha
.93c5	20 a5 90	jsr $90a5			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.93c8	20 62 9e	jsr $9e62			jsr 	NSMIsZero 					; is it zero ?
.93cb	f0 05		beq $93d2			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.93cd	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.93cf	20 ba 93	jsr $93ba			jsr 	_CI32DivideConvert 			; and recusrively call.
.93d2					_CI32NoRecurse:
.93d2	68		pla				pla 								; remainder
.93d3	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.93d5	90 02		bcc $93d9			bcc 	_CI32NotHex
.93d7	69 26		adc #$26			adc 	#6+32
.93d9					_CI32NotHex:
.93d9	69 30		adc #$30			adc 	#48
.93db	99 27 06	sta $0627,y			sta 	NumberBuffer,y 				; write out and exit
.93de	c8		iny				iny
.93df	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/expression.asm


;******  Processing file: ./common/expressions/../generated/precedence.dat

.93e0					PrecedenceLevel:
>93e0	04					.byte	 4	; $00 <<
>93e1	02					.byte	 2	; $01 <=
>93e2	02					.byte	 2	; $02 <>
>93e3	00					.byte	 0	; $03 !!3
>93e4	00					.byte	 0	; $04 ><
>93e5	02					.byte	 2	; $05 >=
>93e6	04					.byte	 4	; $06 >>
>93e7	00					.byte	 0	; $07 !!7
>93e8	00					.byte	 0	; $08 !!8
>93e9	00					.byte	 0	; $09 !!9
>93ea	00					.byte	 0	; $0a !!10
>93eb	00					.byte	 0	; $0b !!11
>93ec	00					.byte	 0	; $0c !!12
>93ed	00					.byte	 0	; $0d !!13
>93ee	00					.byte	 0	; $0e !!14
>93ef	00					.byte	 0	; $0f !!15
>93f0	00					.byte	 0	; $10 @
>93f1	00					.byte	 0	; $11 !!17
>93f2	00					.byte	 0	; $12 !!18
>93f3	00					.byte	 0	; $13 [
>93f4	04					.byte	 4	; $14 \
>93f5	00					.byte	 0	; $15 ]
>93f6	01					.byte	 1	; $16 ^
>93f7	00					.byte	 0	; $17 _
>93f8	00					.byte	 0	; $18 `
>93f9	00					.byte	 0	; $19 !!25
>93fa	00					.byte	 0	; $1a !!26
>93fb	00					.byte	 0	; $1b {
>93fc	01					.byte	 1	; $1c |
>93fd	00					.byte	 0	; $1d }
>93fe	00					.byte	 0	; $1e ~
>93ff	00					.byte	 0	; $1f [7m<7F>[m
>9400	00					.byte	 0	; $20
>9401	05					.byte	 5	; $21 !
>9402	00					.byte	 0	; $22 "
>9403	00					.byte	 0	; $23 #
>9404	05					.byte	 5	; $24 $
>9405	04					.byte	 4	; $25 %
>9406	01					.byte	 1	; $26 &
>9407	00					.byte	 0	; $27 '
>9408	00					.byte	 0	; $28 (
>9409	00					.byte	 0	; $29 )
>940a	04					.byte	 4	; $2a *
>940b	03					.byte	 3	; $2b +
>940c	00					.byte	 0	; $2c ,
>940d	03					.byte	 3	; $2d -
>940e	00					.byte	 0	; $2e .
>940f	04					.byte	 4	; $2f /
>9410	00					.byte	 0	; $30 0
>9411	00					.byte	 0	; $31 1
>9412	00					.byte	 0	; $32 2
>9413	00					.byte	 0	; $33 3
>9414	00					.byte	 0	; $34 4
>9415	00					.byte	 0	; $35 5
>9416	00					.byte	 0	; $36 6
>9417	00					.byte	 0	; $37 7
>9418	00					.byte	 0	; $38 8
>9419	00					.byte	 0	; $39 9
>941a	00					.byte	 0	; $3a :
>941b	00					.byte	 0	; $3b ;
>941c	02					.byte	 2	; $3c <
>941d	02					.byte	 2	; $3d =
>941e	02					.byte	 2	; $3e >
>941f	05					.byte	 5	; $3f ?

;******  Return to file: ./common/expressions/expression.asm

.9420					EvaluateExpressionAt0:
.9420	a2 00		ldx #$00			ldx 	#0 							; bottom stack level
.9422					EvaluateExpression:
.9422	a9 00		lda #$00			lda 	#0 							; lowest precedence level
.9424					EvaluateExpressionAtPrecedence:
.9424	48		pha				pha 								; save precedence level
.9425	20 6c 98	jsr $986c			jsr 	EvaluateTerm 				; evaluate term into level X.
.9428	68		pla				pla 								; restore precedence level.
.9429					_EXPRLoop:
.9429	85 36		sta $36				sta 	zTemp0 						; save current precedence level.
.942b	b1 30		lda ($30),y			lda 	(codePtr),y
.942d	c9 40		cmp #$40			cmp		#$40 						; if >= $40 cannot be an operator
.942f	b0 25		bcs $9456			bcs 	_EXPRExit
.9431	da		phx				phx 								; read the operator precedence
.9432	aa		tax				tax
.9433	bd e0 93	lda $93e0,x			lda 	PrecedenceLevel,x
.9436	fa		plx				plx
.9437	c9 00		cmp #$00			cmp 	#0							; if zero exit (not an operator)
.9439	f0 1b		beq $9456			beq 	_EXPRExit
.943b	85 37		sta $37				sta 	zTemp0+1 					; save operator precedence level.
.943d	a5 36		lda $36				lda 	zTemp0 						; compare current precedence vs. operator precedence
.943f	c5 37		cmp $37				cmp 	zTemp0+1
.9441	b0 13		bcs $9456			bcs		_EXPRExit 					; if current >= operator exit
.9443	48		pha				pha 								; save current precedence.
.9444	b1 30		lda ($30),y			lda 	(codePtr),y
.9446	c8		iny				iny
.9447	48		pha				pha
.9448	a5 37		lda $37				lda 	zTemp0+1 					; get operator precedence level
.944a	e8		inx				inx 								; work out the right hand side.
.944b	20 24 94	jsr $9424			jsr 	EvaluateExpressionAtPrecedence
.944e	ca		dex				dex
.944f	68		pla				pla 								; get operator, call the code.
.9450	20 59 94	jsr $9459			jsr 	_EXPRCaller
.9453	68		pla				pla 								; restore precedence level
.9454	80 d3		bra $9429			bra 	_EXPRLoop 					; and go round.
.9456					_EXPRExit:
.9456	a5 36		lda $36				lda 	zTemp0 						; A = current precedence level.
.9458	60		rts				rts
.9459					_EXPRCaller:
.9459	da		phx				phx 								; save on stack, first thing is to restore it
.945a	0a		asl a				asl 	a 							; double so can use vectors into X
.945b	aa		tax				tax
.945c	7c d0 8b	jmp ($8bd0,x)			jmp 	(VectorSetPunc,x) 			; and go to the code.

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/addsub.asm

.945f					FloatingPointAdd:
.945f	20 d5 95	jsr $95d5			jsr 	FloatPrepare 				; prepare for floats
.9462	80 09		bra $946d			bra 	FloatAdd
.9464					FloatingPointSub:
.9464	20 d5 95	jsr $95d5			jsr 	FloatPrepare 				; prepare for floats
.9467					FloatSubtract:
.9467	b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate FPB
.9469	49 80		eor #$80			eor 	#$80
.946b	95 51		sta $51,x			sta 	NSStatus+1,x				; and fall through.
.946d					FloatAdd:
.946d	48		pha				pha
.946e	5a		phy				phy
.946f	20 e4 95	jsr $95e4			jsr 	NSNormalise 				; normalise S[X]
.9472	f0 51		beq $94c5			beq 	_FAReturn1
.9474	e8		inx				inx 								; normalise S[X+1]
.9475	20 e4 95	jsr $95e4			jsr 	NSNormalise
.9478	ca		dex				dex
.9479	c9 00		cmp #$00			cmp 	#0
.947b	f0 60		beq $94dd			beq 	_FAExit 					; if so, just return A
.947d	b5 78		lda $78,x			lda 	NSExponent,x 				; are the exponents the same ?
.947f	d5 79		cmp $79,x			cmp 	NSExponent+1,x
.9481	f0 18		beq $949b			beq 	_FAExponentsEqual
.9483	b5 78		lda $78,x			lda 	NSExponent,x 				; work out the larger exponent
.9485	a8		tay				tay
.9486	38		sec				sec 								; do a signed comparison of the exponents.
.9487	f5 79		sbc $79,x			sbc 	NSExponent+1,x
.9489	50 02		bvc $948d			bvc 	_FANoSignedChange
.948b	49 80		eor #$80			eor 	#$80
.948d					_FANoSignedChange:
.948d	29 80		and #$80			and 	#$80
.948f	10 02		bpl $9493			bpl 	_FAHaveMax
.9491	b4 79		ldy $79,x			ldy 	NSExponent+1,x
.9493					_FAHaveMax:
.9493	20 e0 94	jsr $94e0			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.9496	e8		inx				inx
.9497	20 e0 94	jsr $94e0			jsr 	_FAShiftToExponent
.949a	ca		dex				dex
.949b					_FAExponentsEqual:
.949b	b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs the same
.949d	55 51		eor $51,x			eor 	NSStatus+1,x
.949f	30 0e		bmi $94af			bmi 	_FADifferentSigns
.94a1	20 18 92	jsr $9218			jsr 	AddTopTwoStack 				; do the add of the mantissae
.94a4	b5 70		lda $70,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.94a6	10 35		bpl $94dd			bpl 	_FAExit 					; if no, we are done.
.94a8	20 59 9e	jsr $9e59			jsr 	NSMShiftRight 				; shift A right, renormalising it.
.94ab	f6 78		inc $78,x			inc 	NSExponent,x 				; bump the exponent and exit
.94ad	80 2e		bra $94dd			bra 	_FAExit
.94af					_FADifferentSigns:
.94af	20 32 92	jsr $9232			jsr 	SubTopTwoStack 				; subtract mantissa B from A
.94b2	b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the result negative ?
.94b4	10 06		bpl $94bc			bpl 	_FACheckZero 				; if no, check for -0
.94b6	20 02 9e	jsr $9e02			jsr 	NSMNegate 					; netate result
.94b9	20 09 9e	jsr $9e09			jsr 	NSMNegateMantissa 			; negate (2'c) the mantissa
.94bc					_FACheckZero:
.94bc	20 62 9e	jsr $9e62			jsr 	NSMIsZero	 				; check for -0
.94bf	d0 1c		bne $94dd			bne 	_FAExit
.94c1	74 50		stz $50,x			stz 	NSStatus,x
.94c3	80 18		bra $94dd			bra 	_FAExit
.94c5					_FAReturn1:
.94c5	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.94c7	95 58		sta $58,x			sta 	NSMantissa0,x
.94c9	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.94cb	95 60		sta $60,x			sta 	NSMantissa1,x
.94cd	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.94cf	95 68		sta $68,x			sta 	NSMantissa2,x
.94d1	b5 71		lda $71,x			lda 	NSMantissa3+1,x
.94d3	95 70		sta $70,x			sta 	NSMantissa3,x
.94d5	b5 79		lda $79,x			lda 	NSExponent+1,x
.94d7	95 78		sta $78,x			sta 	NSExponent,x
.94d9	b5 51		lda $51,x			lda 	NSStatus+1,x
.94db	95 50		sta $50,x			sta 	NSStatus,x
.94dd					_FAExit:
.94dd	7a		ply				ply
.94de	68		pla				pla
.94df	60		rts				rts
.94e0					_FAShiftToExponent:
.94e0					_FAShiftToExponent2:
.94e0	98		tya				tya 								; compare Y to exponent
.94e1	d5 78		cmp $78,x			cmp 	NSExponent,x 				; reached the exponent required ?
.94e3	f0 07		beq $94ec			beq 	_FASEExit 					; exit if so.
.94e5	20 59 9e	jsr $9e59			jsr 	NSMShiftRight	 			; shift the mantissa right
.94e8	f6 78		inc $78,x			inc 	NSExponent,x 				; increment exponent
.94ea	80 f4		bra $94e0			bra 	_FAShiftToExponent2
.94ec					_FASEExit:
.94ec	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/compare.asm

.94ed					CompareFloat:
.94ed	20 67 94	jsr $9467			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.94f0	b5 60		lda $60,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.94f2	29 f8		and #$f8			and 	#$F8
.94f4	15 68		ora $68,x			ora 	NSMantissa2,x
.94f6	15 70		ora $70,x			ora 	NSMantissa3,x
.94f8	f0 08		beq $9502			beq 	_FCExit 					; zero, so approximately identical
.94fa	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.94fc	34 50		bit $50,x			bit 	NSStatus,x
.94fe	10 02		bpl $9502			bpl 	_FCExit
.9500					_FCNegative:
.9500	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.9502					_FCExit:
.9502	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/divide.asm

.9503					FDivideCommand:
.9503	fa		plx				plx	 								; restore stack position
.9504	20 d5 95	jsr $95d5			jsr 	FloatPrepare 				; prepare for floats
.9507					FloatDivide:
.9507	48		pha				pha
.9508	e8		inx				inx
.9509	20 e4 95	jsr $95e4			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.950c	ca		dex				dex
.950d	c9 00		cmp #$00			cmp 	#0
.950f	f0 1d		beq $952e			beq 	_FDZero
.9511	20 e4 95	jsr $95e4			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.9514	f0 16		beq $952c			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.9516	20 09 91	jsr $9109			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.9519	20 a5 90	jsr $90a5			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.951c	20 e4 95	jsr $95e4			jsr		NSNormalise 				; renormalise
.951f	20 99 91	jsr $9199			jsr 	CalculateSign 				; calculate result sign
.9522	b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent
.9524	38		sec				sec
.9525	f5 79		sbc $79,x			sbc 	NSExponent+1,x
.9527	38		sec				sec
.9528	e9 1e		sbc #$1e			sbc 	#30
.952a	95 78		sta $78,x			sta 	NSExponent,x
.952c					_FDExit:
.952c	68		pla				pla
.952d	60		rts				rts
.952e					_FDZero:
.952e	a9 03		lda #$03		lda	#3
.9530	4c 1e 8f	jmp $8f1e		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/fractional.asm

.9533					FloatFractionalPart:
.9533	5a		phy				phy
.9534	b5 50		lda $50,x			lda 	NSStatus,x 					; take absolute value
.9536	29 7f		and #$7f			and 	#$7F
.9538	95 50		sta $50,x			sta 	NSStatus,x
.953a	20 e4 95	jsr $95e4			jsr 	NSNormalise
.953d	b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.953f	38		sec				sec
.9540	e9 e0		sbc #$e0			sbc 	#$E0
.9542	90 29		bcc $956d			bcc 	_FFPExit 					; already fractional
.9544	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.9546	b0 22		bcs $956a			bcs 	_FFPZero
.9548	a8		tay				tay 								; put count to do in Y
.9549	b5 70		lda $70,x			lda 	NSMantissa3,x 				; do each in turn.
.954b	20 6f 95	jsr $956f			jsr 	_FFPPartial
.954e	95 70		sta $70,x			sta 	NSMantissa3,x
.9550	b5 68		lda $68,x			lda 	NSMantissa2,x
.9552	20 6f 95	jsr $956f			jsr 	_FFPPartial
.9555	95 68		sta $68,x			sta 	NSMantissa2,x
.9557	b5 60		lda $60,x			lda 	NSMantissa1,x
.9559	20 6f 95	jsr $956f			jsr 	_FFPPartial
.955c	95 60		sta $60,x			sta 	NSMantissa1,x
.955e	b5 58		lda $58,x			lda 	NSMantissa0,x
.9560	20 6f 95	jsr $956f			jsr 	_FFPPartial
.9563	95 58		sta $58,x			sta 	NSMantissa0,x
.9565	20 62 9e	jsr $9e62			jsr 	NSMIsZero 					; zeroed check.
.9568	d0 03		bne $956d			bne 	_FFPExit
.956a					_FFPZero:
.956a	20 40 9e	jsr $9e40			jsr 	NSMSetZero
.956d					_FFPExit:
.956d	7a		ply				ply
.956e	60		rts				rts
.956f					_FFPPartial:
.956f	c0 00		cpy #$00			cpy 	#0 							; no more to do
.9571	f0 17		beq $958a			beq 	_FFFPPExit
.9573	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.9575	b0 0c		bcs $9583			bcs 	_FFFPPWholeByte
.9577	5a		phy				phy
.9578					_FFFPPLeft:
.9578	0a		asl a				asl 	a
.9579	88		dey				dey
.957a	d0 fc		bne $9578			bne 	_FFFPPLeft
.957c	7a		ply				ply
.957d					_FFFPPRight:
.957d	4a		lsr a				lsr 	a
.957e	88		dey				dey
.957f	d0 fc		bne $957d			bne 	_FFFPPRight
.9581	80 07		bra $958a			bra 	_FFFPPExit
.9583					_FFFPPWholeByte:
.9583	98		tya				tya 								; subtract 8 from count
.9584	38		sec				sec
.9585	e9 08		sbc #$08			sbc 	#8
.9587	a8		tay				tay
.9588	a9 00		lda #$00			lda 	#0 							; and clear all
.958a					_FFFPPExit:
.958a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/integer.asm

.958b					FloatIntegerPart:
.958b	48		pha				pha
.958c	b5 78		lda $78,x			lda 	NSExponent,x 				; is it integer already ?
.958e	f0 1d		beq $95ad			beq 	_FIPExit 					; if so do nothing
.9590	20 62 9e	jsr $9e62			jsr 	NSMIsZero 					; is it zero ?
.9593	f0 15		beq $95aa			beq 	_FIPZero 					; if so return zero.
.9595	20 e4 95	jsr $95e4			jsr 	NSNormalise 				; normalise
.9598	f0 10		beq $95aa			beq 	_FIPZero 					; normalised to zero, exit zero
.959a					_FIPShift:
.959a	b5 78		lda $78,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.959c	10 07		bpl $95a5			bpl 	_FIPCheckZero
.959e	20 59 9e	jsr $9e59			jsr 	NSMShiftRight 				; shift mantissa right
.95a1	f6 78		inc $78,x			inc 	NSExponent,x 				; bump exponent
.95a3	80 f5		bra $959a			bra 	_FIPShift
.95a5					_FIPCheckZero:
.95a5	20 62 9e	jsr $9e62			jsr 	NSMIsZero 					; avoid -0 problem
.95a8	d0 03		bne $95ad			bne 	_FIPExit 					; set to zero if mantissa zero.
.95aa					_FIPZero:
.95aa	20 40 9e	jsr $9e40			jsr 	NSMSetZero
.95ad					_FIPExit:
.95ad	68		pla				pla
.95ae	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/multiply.asm

.95af					FloatingPointMultiply:
.95af	20 d5 95	jsr $95d5			jsr 	FloatPrepare 				; prepare for floats
.95b2					FloatMultiply:
.95b2	48		pha				pha
.95b3	20 e4 95	jsr $95e4			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.95b6	f0 18		beq $95d0			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.95b8	e8		inx				inx
.95b9	20 e4 95	jsr $95e4			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.95bc	ca		dex				dex
.95bd	c9 00		cmp #$00			cmp 	#0
.95bf	f0 0c		beq $95cd			beq 	_FDSetZero
.95c1	20 5b 91	jsr $915b			jsr 	MultiplyShort 				; calculate the result.
.95c4	75 78		adc $78,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.95c6	18		clc				clc
.95c7	75 79		adc $79,x			adc 	NSExponent+1,x
.95c9	95 78		sta $78,x			sta 	NSExponent,x
.95cb	80 03		bra $95d0			bra 	_FDExit
.95cd					_FDSetZero:
.95cd	20 40 9e	jsr $9e40			jsr 	NSMSetZero 					; return 0
.95d0					_FDExit:
.95d0	20 e4 95	jsr $95e4			jsr 	NSNormalise 				; normalise the result
.95d3	68		pla				pla
.95d4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/utility.asm

.95d5					FloatPrepare:
.95d5	20 e0 96	jsr $96e0			jsr 	DereferenceTopTwo 			; dereference the top two values
.95d8	b5 50		lda $50,x			lda 	NSStatus,x 					; check ints/floats, either will do.
.95da	15 51		ora $51,x			ora 	NSStatus+1,x
.95dc	29 10		and #$10			and 	#NSBIsString
.95de	d0 01		bne $95e1			bne 	_FDType
.95e0	60		rts				rts
.95e1					_FDType:
.95e1	4c c8 9f	jmp $9fc8			jmp 	TypeError
.95e4					NSNormalise:
.95e4	b5 50		lda $50,x			lda 	NSStatus,x 					; make float, keep sign
.95e6	29 80		and #$80			and 	#$80
.95e8	09 08		ora #$08			ora 	#NSTFloat
.95ea	95 50		sta $50,x			sta 	NSStatus,x
.95ec	20 62 9e	jsr $9e62			jsr 	NSMIsZero 					; if zero exit
.95ef	d0 07		bne $95f8			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.95f1	16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.95f3	76 50		ror $50,x			ror 	NSStatus,x 					; (no -0)
.95f5	a9 00		lda #$00			lda 	#0 							; set Z flag
.95f7	60		rts				rts
.95f8					_NSNormaliseOptimise:
.95f8	b5 70		lda $70,x			lda 	NSMantissa3,x 				; upper byte zero ?
.95fa	d0 19		bne $9615			bne 	_NSNormaliseLoop
.95fc	b5 68		lda $68,x			lda 	NSMantissa2,x 				; byte normalise
.95fe	30 15		bmi $9615			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.9600	95 70		sta $70,x			sta 	NSMantissa3,x
.9602	b5 60		lda $60,x			lda 	NSMantissa1,x
.9604	95 68		sta $68,x			sta 	NSMantissa2,x
.9606	b5 58		lda $58,x			lda 	NSMantissa0,x
.9608	95 60		sta $60,x			sta 	NSMantissa1,x
.960a	74 58		stz $58,x			stz 	NSMantissa0,x
.960c	b5 78		lda $78,x			lda 	NSExponent,x
.960e	38		sec				sec
.960f	e9 08		sbc #$08			sbc 	#8
.9611	95 78		sta $78,x			sta 	NSExponent,x
.9613	80 e3		bra $95f8			bra 	_NSNormaliseOptimise
.9615					_NSNormaliseLoop:
.9615	34 70		bit $70,x			bit 	NSMantissa3,x 				; bit 30 set ?
.9617	70 07		bvs $9620			bvs 	_NSNExit 					; exit if so with Z flag clear
.9619	20 4f 9e	jsr $9e4f			jsr 	NSMShiftLeft 				; shift mantissa left
.961c	d6 78		dec $78,x			dec 	NSExponent,x 				; adjust exponent
.961e	80 f5		bra $9615			bra 	_NSNormaliseLoop
.9620					_NSNExit:
.9620	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.9622	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignnumber.asm

.9623					AssignNumber:
.9623	5a		phy				phy
.9624	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy mantissa0/1 to zTemp0
.9626	85 36		sta $36				sta 	zTemp0
.9628	b5 60		lda $60,x			lda 	NSMantissa1,x
.962a	85 37		sta $37				sta 	zTemp0+1
.962c	b5 50		lda $50,x			lda 	NSStatus,x 					; clear reference bits
.962e	29 df		and #$df			and 	#(NSBIsReference ^ $FF)
.9630	95 50		sta $50,x			sta 	NSStatus,x
.9632	29 18		and #$18			and 	#NSBTypeMask				; assigning to a float ?
.9634	c9 08		cmp #$08			cmp 	#NSTFloat
.9636	f0 24		beq $965c			beq 	_ANFloat
.9638	b5 79		lda $79,x			lda		NSExponent+1,x 				; is it a float
.963a	f0 03		beq $963f			beq		_ANNotFloat
.963c	4c c3 9f	jmp $9fc3			jmp 	RangeError					; if it is, report an error.
.963f					_ANNotFloat:
.963f	b5 50		lda $50,x			lda 	NSStatus,x 					; check if byte/word reference.
.9641	29 03		and #$03			and 	#3
.9643	d0 05		bne $964a			bne 	_ANByteWord
.9645	20 67 96	jsr $9667			jsr 	_ANCopy4PackSign 			; copy all 4 bytes and sign
.9648	80 1b		bra $9665			bra 	_ANExit
.964a					_ANByteWord:
.964a	48		pha				pha 								; save count
.964b	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; do byte
.964d	92 36		sta ($36)			sta 	(zTemp0)
.964f	68		pla				pla
.9650	c9 01		cmp #$01			cmp	 	#1
.9652	f0 11		beq $9665			beq 	_ANExit
.9654	b5 61		lda $61,x			lda 	NSMantissa1+1,x 			; do word
.9656	a0 01		ldy #$01			ldy 	#1
.9658	91 36		sta ($36),y			sta 	(zTemp0),y
.965a	80 09		bra $9665			bra 	_ANExit
.965c					_ANFloat:
.965c	20 67 96	jsr $9667			jsr 	_ANCopy4PackSign 			; write all 4 bytes and packed sign
.965f	b5 79		lda $79,x			lda 	NSExponent+1,x 				; copy exponent to slot 4
.9661	a0 04		ldy #$04			ldy 	#4
.9663	91 36		sta ($36),y			sta 	(zTemp0),y
.9665					_ANExit:
.9665	7a		ply				ply
.9666	60		rts				rts
.9667					_ANCopy4PackSign:
.9667	a0 03		ldy #$03			ldy 	#3
.9669	b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign bit into status
.966b	29 80		and #$80			and 	#$80 						; put into high bit of mantissa 3
.966d	15 71		ora $71,x			ora 	NSMantissa3+1,x
.966f	91 36		sta ($36),y			sta 	(zTemp0),y
.9671	88		dey				dey
.9672	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.9674	91 36		sta ($36),y			sta 	(zTemp0),y
.9676	88		dey				dey
.9677	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9679	91 36		sta ($36),y			sta 	(zTemp0),y
.967b	88		dey				dey
.967c	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.967e	91 36		sta ($36),y			sta 	(zTemp0),y
.9680	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignstring.asm

.9681					AssignString:
.9681	5a		phy				phy
.9682	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9684	85 38		sta $38				sta 	zTemp1
.9686	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9688	85 39		sta $39				sta 	zTemp1+1
.968a	b5 58		lda $58,x			lda 	NSMantissa0,x
.968c	85 36		sta $36				sta 	zTemp0
.968e	b5 60		lda $60,x			lda 	NSMantissa1,x
.9690	85 37		sta $37				sta 	zTemp0+1
.9692	a0 01		ldy #$01			ldy 	#1 							; the high byte of the target address
.9694	b1 36		lda ($36),y			lda 	(zTemp0),y
.9696	f0 23		beq $96bb			beq 	_ASNewStringRequired 		; if zero, a new string is required.
.9698	38		sec				sec 								; put Address-2 in zsTemp - this is the size/status/string record
.9699	b2 36		lda ($36)			lda 	(zTemp0) 					; of concreted strings
.969b	e9 02		sbc #$02			sbc 	#2
.969d	85 3c		sta $3c				sta 	zsTemp
.969f	a0 01		ldy #$01			ldy 	#1
.96a1	b1 36		lda ($36),y			lda 	(zTemp0),y
.96a3	e9 00		sbc #$00			sbc 	#0
.96a5	85 3d		sta $3d				sta 	zsTemp+1
.96a7	a0 ff		ldy #$ff			ldy 	#$FF 						; get length of new string
.96a9					_ASGetLength:
.96a9	c8		iny				iny
.96aa	b1 38		lda ($38),y			lda 	(zTemp1),y
.96ac	d0 fb		bne $96a9			bne 	_ASGetLength
.96ae	98		tya				tya 								; is this length <= current length
.96af	d2 3c		cmp ($3c)			cmp 	(zsTemp)
.96b1	90 1e		bcc $96d1			bcc 	_ASCopyString
.96b3	f0 1c		beq $96d1			beq 	_ASCopyString
.96b5	a9 80		lda #$80			lda 	#$80 						; mark as unused.
.96b7	a0 01		ldy #$01			ldy 	#1
.96b9	91 3c		sta ($3c),y			sta 	(zsTemp),y
.96bb					_ASNewStringRequired:
.96bb	e8		inx				inx 								; concrete the new string.
.96bc	20 46 a7	jsr $a746			jsr 	StringConcrete				; (breaks zTemp1/2, not zTemp0 and zsTemp)
.96bf	ca		dex				dex
.96c0	18		clc				clc
.96c1	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy that new address to the reference.
.96c3	69 02		adc #$02			adc 	#2 							; add two to point at the data.
.96c5	92 36		sta ($36)			sta 	(zTemp0)
.96c7	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.96c9	69 00		adc #$00			adc 	#0
.96cb	a0 01		ldy #$01			ldy 	#1
.96cd	91 36		sta ($36),y			sta 	(zTemp0),y
.96cf	80 0d		bra $96de			bra 	_ASExit
.96d1					_ASCopyString:
.96d1	a0 00		ldy #$00			ldy 	#0
.96d3					_ASCopyLoop:
.96d3	b1 38		lda ($38),y			lda 	(zTemp1),y
.96d5	c8		iny				iny
.96d6	c8		iny				iny
.96d7	91 3c		sta ($3c),y			sta 	(zsTemp),y
.96d9	88		dey				dey
.96da	c9 00		cmp #$00			cmp 	#0
.96dc	d0 f5		bne $96d3			bne 	_ASCopyLoop
.96de					_ASExit:
.96de	7a		ply				ply
.96df	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/dereference.asm

.96e0					DereferenceTopTwo:
.96e0	e8		inx				inx
.96e1	20 e5 96	jsr $96e5			jsr 	Dereference 				; deref x+1
.96e4	ca		dex				dex  								; falls through to deref x
.96e5					Dereference:
.96e5	b5 50		lda $50,x			lda 	NSStatus,x 					; get the status byte
.96e7	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.96e9	f0 48		beq $9733			beq 	_DRFExit 					; not a reference, so exit.
.96eb	5a		phy				phy
.96ec	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address to dereference into zTemp0
.96ee	85 36		sta $36				sta 	zTemp0
.96f0	b5 60		lda $60,x			lda 	NSMantissa1,x
.96f2	85 37		sta $37				sta 	zTemp0+1
.96f4	74 60		stz $60,x			stz 	NSMantissa1,x 				; clear second byte.
.96f6	b2 36		lda ($36)			lda 	(zTemp0) 					; do the first byte
.96f8	95 58		sta $58,x			sta 	NSMantissa0,x
.96fa	b5 50		lda $50,x			lda 	NSStatus,x 					; get status byte.
.96fc	29 18		and #$18			and 	#NSBTypeMask 				; what type is it ?
.96fe	c9 10		cmp #$10			cmp 	#NSTString 					; if string, dereference two
.9700	f0 0e		beq $9710			beq 	_DRFDereferenceTwo
.9702	c9 08		cmp #$08			cmp 	#NSTFloat 					; if float, do full dereference.
.9704	f0 2f		beq $9735			beq 	_DRFFull
.9706	b5 50		lda $50,x			lda 	NSStatus,x 					; must be integer - how many bytes ?
.9708	29 03		and #$03			and 	#3
.970a	f0 29		beq $9735			beq 	_DRFFull 					; the whole word
.970c	c9 01		cmp #$01			cmp 	#1 							; is it 10 (e.g. 2 bytes)
.970e	f0 06		beq $9716			beq		_DRFClear23 				; no, one byte, clear 2 & 3 and exit
.9710					_DRFDereferenceTwo:
.9710	a0 01		ldy #$01			ldy 	#1
.9712	b1 36		lda ($36),y			lda 	(zTemp0),y
.9714	95 60		sta $60,x			sta 	NSMantissa1,x
.9716					_DRFClear23:
.9716	74 68		stz $68,x			stz 	NSMantissa2,x 				; clear upper bytes, only read 1 or 2 bytes
.9718	74 70		stz $70,x			stz 	NSMantissa3,x
.971a	b5 50		lda $50,x			lda 	NSStatus,x 					; make it a value of that type.
.971c	29 18		and #$18			and 	#NSBTypeMask
.971e	95 50		sta $50,x			sta 	NSStatus,x 					; and fall through.
.9720	c9 10		cmp #$10			cmp 	#NSTString  				; is it a string
.9722	d0 0e		bne $9732			bne 	_DRFNotString
.9724	b5 58		lda $58,x			lda 	NSMantissa0,x 				; check address is zero
.9726	15 60		ora $60,x			ora 	NSMantissa1,x
.9728	d0 08		bne $9732			bne 	_DRFNotString
.972a	a9 34		lda #$34			lda 	#_DRFNullString & $FF 		; if so, return reference to ""
.972c	95 58		sta $58,x			sta 	NSMantissa0,X
.972e	a9 97		lda #$97			lda 	#_DRFNullString >> 8
.9730	95 60		sta $60,x			sta 	NSMantissa1,X
.9732					_DRFNotString
.9732	7a		ply				ply 								; restore Y and exit
.9733					_DRFExit:
.9733	60		rts				rts
.9734					_DRFNullString:
>9734	00						.byte 	0
.9735					_DRFFull:
.9735	a0 01		ldy #$01			ldy 	#1 							; get remaining 3 bytes.
.9737	b1 36		lda ($36),y			lda 	(zTemp0),y
.9739	95 60		sta $60,x			sta 	NSMantissa1,x
.973b	c8		iny				iny
.973c	b1 36		lda ($36),y			lda 	(zTemp0),y
.973e	95 68		sta $68,x			sta 	NSMantissa2,x
.9740	c8		iny				iny
.9741	b1 36		lda ($36),y			lda 	(zTemp0),y
.9743	95 70		sta $70,x			sta 	NSMantissa3,x
.9745	74 78		stz $78,x			stz 	NSExponent,x 				; clear exponent.
.9747	b5 50		lda $50,x			lda		NSStatus,x 					; see if type is integer
.9749	29 18		and #$18			and 	#NSBTypeMask  				; type information only
.974b	95 50		sta $50,x			sta 	NSStatus,x 					; update it back.
.974d	f0 05		beq $9754			beq 	_DRFNoExponent
.974f	c8		iny				iny 								; if not, read the exponent as well.
.9750	b1 36		lda ($36),y			lda 	(zTemp0),y
.9752	95 78		sta $78,x			sta 	NSExponent,x
.9754					_DRFNoExponent:
.9754	b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the most significant bit set ?
.9756	10 0a		bpl $9762			bpl 	_DRFExit2 					; if not, then exit.
.9758	29 7f		and #$7f			and 	#$7F 						; clear that bit.
.975a	95 70		sta $70,x			sta 	NSMantissa3,x
.975c	b5 50		lda $50,x			lda 	NSStatus,x 					; set the sign flag
.975e	09 80		ora #$80			ora 	#NSBIsNegative
.9760	95 50		sta $50,x			sta 	NSStatus,x
.9762					_DRFExit2:
.9762	7a		ply				ply
.9763	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/number.asm

=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.9764					EncodeNumberStart:
.9764	38		sec				sec
.9765	80 01		bra $9768			bra 	EncodeNumberContinue+1
.9767					EncodeNumberContinue:
.9767	18		clc				clc
.9768					EncodeNumber:
.9768	08		php				php 								; save reset flag.
.9769	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.976b	f0 12		beq $977f			beq 	_ENIsOkay
.976d	c9 30		cmp #$30			cmp 	#"0"
.976f	90 04		bcc $9775			bcc 	_ENBadNumber
.9771	c9 3a		cmp #$3a			cmp 	#"9"+1
.9773	90 0a		bcc $977f			bcc 	_ENIsOkay
.9775					_ENBadNumber:
.9775	28		plp				plp 								; throw saved reset
.9776	ad 05 04	lda $0405			lda 	EncodeState 				; if in decimal mode, construct final number
.9779	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.977b	f0 7b		beq $97f8			beq 	_ENConstructFinal
.977d					_ENFail:
.977d	18		clc				clc 								; not allowed
.977e	60		rts				rts
.977f					_ENIsOkay:
.977f	28		plp				plp 								; are we restarting
.9780	90 15		bcc $9797			bcc 	_ENNoRestart
.9782					_ENStartEncode:
.9782	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.9784	f0 0c		beq $9792			beq 	_ENFirstDP
.9786	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.9788	20 42 9e	jsr $9e42			jsr 	NSMSetByte 					; in single byte mode.
.978b	a9 01		lda #$01			lda 	#ESTA_Low
.978d					_ENExitChange:
.978d	8d 05 04	sta $0405			sta 	EncodeState 				; save new state
.9790	38		sec				sec
.9791	60		rts				rts
.9792					_ENFirstDP:
.9792	20 40 9e	jsr $9e40			jsr 	NSMSetZero 					; clear integer part
.9795	80 3c		bra $97d3			bra 	_ESTASwitchFloat			; go straight to float and exi
.9797					_ENNoRestart:
.9797	48		pha				pha 								; save digit or DP on stack.
.9798	ad 05 04	lda $0405			lda 	EncodeState 				; get current state
.979b	c9 01		cmp #$01			cmp 	#ESTA_Low
.979d	f0 09		beq $97a8			beq  	_ESTALowState
.979f	c9 02		cmp #$02			cmp 	#ESTA_High
.97a1	f0 26		beq $97c9			beq 	_ESTAHighState
.97a3	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.97a5	f0 38		beq $97df			beq 	_ESTADecimalState
>97a7	db						.byte 	$DB 						; causes a break in the emulator
.97a8					_ESTALowState:
.97a8	68		pla				pla 								; get value back
.97a9	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.97ab	f0 26		beq $97d3			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.97ad	29 0f		and #$0f			and 	#15 						; make digit
.97af	8d 06 04	sta $0406			sta 	DigitTemp 					; save it.
.97b2	b5 58		lda $58,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.97b4	0a		asl a				asl 	a
.97b5	0a		asl a				asl 	a
.97b6	75 58		adc $58,x			adc 	NSMantissa0,x
.97b8	0a		asl a				asl 	a
.97b9	6d 06 04	adc $0406			adc 	DigitTemp
.97bc	95 58		sta $58,x			sta 	NSMantissa0,x
.97be	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.97c0	90 05		bcc $97c7			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.97c2	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.97c4	8d 05 04	sta $0405			sta 	EncodeState
.97c7					_ESTANoSwitch:
.97c7	38		sec				sec
.97c8	60		rts				rts
.97c9					_ESTAHighState:
.97c9	68		pla				pla 								; get value back
.97ca	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.97cc	f0 05		beq $97d3			beq 	_ESTASwitchFloat
.97ce	20 2c 98	jsr $982c			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.97d1	38		sec				sec
.97d2	60		rts				rts
.97d3					_ESTASwitchFloat:
.97d3	9c 07 04	stz $0407			stz 	DecimalCount 				; reset the count of digits - we divide by 10^n at the end.
.97d6	e8		inx				inx 								; zero the decimal additive.
.97d7	20 40 9e	jsr $9e40			jsr 	NSMSetZero
.97da	ca		dex				dex
.97db	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.97dd	80 ae		bra $978d			bra 	_ENExitChange
.97df					_ESTADecimalState:
.97df	68		pla				pla 								; digit.
.97e0	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 2nd decimal point.
.97e2	f0 99		beq $977d			beq 	_ENFail
.97e4	e8		inx				inx 								; put digit into fractional part of X+1
.97e5	20 2c 98	jsr $982c			jsr 	ESTAShiftDigitIntoMantissa
.97e8	ca		dex				dex
.97e9	ee 07 04	inc $0407			inc 	DecimalCount 				; bump the count of decimals
.97ec	ad 07 04	lda $0407			lda 	DecimalCount 				; too many decimal digits.
.97ef	c9 0b		cmp #$0b			cmp 	#11
.97f1	f0 02		beq $97f5			beq 	_ESTADSFail
.97f3	38		sec				sec
.97f4	60		rts				rts
.97f5					_ESTADSFail:
.97f5	4c c3 9f	jmp $9fc3			jmp 	RangeError
.97f8					_ENConstructFinal:
.97f8	ad 07 04	lda $0407			lda 	DecimalCount 				; get decimal count
.97fb	f0 2d		beq $982a			beq 	_ENCFExit 					; no decimals
.97fd	5a		phy				phy
.97fe	0a		asl a				asl 	a 							; x 4 and CLC
.97ff	0a		asl a				asl 	a
.9800	6d 07 04	adc $0407			adc 	DecimalCount
.9803	a8		tay				tay
.9804	b9 82 9f	lda $9f82,y			lda 	DecimalScalarTable-5,y 		; copy decimal scalar to X+2
.9807	95 5a		sta $5a,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.9809	b9 83 9f	lda $9f83,y			lda 	DecimalScalarTable-5+1,y
.980c	95 62		sta $62,x			sta 	NSMantissa1+2,x
.980e	b9 84 9f	lda $9f84,y			lda 	DecimalScalarTable-5+2,y
.9811	95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.9813	b9 85 9f	lda $9f85,y			lda 	DecimalScalarTable-5+3,y
.9816	95 72		sta $72,x			sta 	NSMantissa3+2,x
.9818	b9 86 9f	lda $9f86,y			lda 	DecimalScalarTable-5+4,y
.981b	95 7a		sta $7a,x			sta 	NSExponent+2,x
.981d	a9 08		lda #$08			lda 	#NSTFloat
.981f	95 52		sta $52,x			sta 	NSStatus+2,x
.9821	7a		ply				ply
.9822	e8		inx				inx 								; multiply decimal const by decimal scalar
.9823	20 b2 95	jsr $95b2			jsr 	FloatMultiply
.9826	ca		dex				dex
.9827	20 6d 94	jsr $946d			jsr 	FloatAdd 					; add to integer part.
.982a					_ENCFExit:
.982a	18		clc				clc 								; reject the digit.
.982b	60		rts				rts
.982c					ESTAShiftDigitIntoMantissa:
.982c	29 0f		and #$0f			and 	#15 						; save digit
.982e	48		pha				pha
.982f	b5 70		lda $70,x			lda 	NSMantissa3,x 				; push mantissa on stack
.9831	48		pha				pha
.9832	b5 68		lda $68,x			lda 	NSMantissa2,x
.9834	48		pha				pha
.9835	b5 60		lda $60,x			lda 	NSMantissa1,x
.9837	48		pha				pha
.9838	b5 58		lda $58,x			lda 	NSMantissa0,x
.983a	48		pha				pha
.983b	20 4f 9e	jsr $9e4f			jsr 	NSMShiftLeft 				; x 2
.983e	20 4f 9e	jsr $9e4f			jsr 	NSMShiftLeft 				; x 4
.9841	18		clc				clc 								; pop mantissa and add
.9842	68		pla				pla
.9843	75 58		adc $58,x			adc 	NSMantissa0,x
.9845	95 58		sta $58,x			sta 	NSMantissa0,x
.9847	68		pla				pla
.9848	75 60		adc $60,x			adc 	NSMantissa1,x
.984a	95 60		sta $60,x			sta 	NSMantissa1,x
.984c	68		pla				pla
.984d	75 68		adc $68,x			adc 	NSMantissa2,x
.984f	95 68		sta $68,x			sta 	NSMantissa2,x
.9851	68		pla				pla
.9852	75 70		adc $70,x			adc 	NSMantissa3,x
.9854	95 70		sta $70,x			sta 	NSMantissa3,x 				; x 5
.9856	20 4f 9e	jsr $9e4f			jsr 	NSMShiftLeft 				; x 10
.9859	68		pla				pla 								; add digit
.985a	18		clc				clc
.985b	75 58		adc $58,x			adc 	NSMantissa0,x
.985d	95 58		sta $58,x			sta 	NSMantissa0,x
.985f	90 0a		bcc $986b			bcc 	_ESTASDExit
.9861	f6 60		inc $60,x			inc 	NSMantissa1,x
.9863	d0 06		bne $986b			bne 	_ESTASDExit
.9865	f6 68		inc $68,x			inc 	NSMantissa2,x
.9867	d0 02		bne $986b			bne 	_ESTASDExit
.9869	f6 70		inc $70,x			inc 	NSMantissa3,x
.986b					_ESTASDExit:
.986b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/term.asm

.986c					EvaluateTerm:
.986c	b1 30		lda ($30),y			lda 	(codePtr),y
.986e	30 18		bmi $9888			bmi 	_ETCheckUnary 				; unary function ? (text ones)
.9870	c9 40		cmp #$40			cmp 	#$40 						; 40-7F => identifier reference
.9872	b0 6c		bcs $98e0			bcs 	_ETVariable
.9874	c9 30		cmp #$30			cmp 	#'0' 						; is it a number
.9876	90 6b		bcc $98e3			bcc 	_ETPuncUnary 				; if not it might be a punctuation unary.
.9878	c9 3a		cmp #$3a			cmp 	#'9'+1
.987a	b0 67		bcs $98e3			bcs 	_ETPuncUnary
.987c	20 64 97	jsr $9764			jsr 	EncodeNumberStart 			; can't fail as it's 0-9 !
.987f					_ETNumber:
.987f	c8		iny				iny 								; keep encoding until we have the numbers
.9880	b1 30		lda ($30),y			lda 	(codePtr),y
.9882	20 67 97	jsr $9767			jsr 	EncodeNumberContinue
.9885	b0 f8		bcs $987f			bcs 	_ETNumber 					; go back if accepted.
.9887	60		rts				rts
.9888					_ETCheckUnary:
.9888	c9 ff		cmp #$ff			cmp 	#KWC_STRING 				; string token
.988a	f0 3f		beq $98cb			beq 	_ETString
.988c	c9 fe		cmp #$fe			cmp 	#KWC_HEXCONST 				; hex constant.
.988e	f0 12		beq $98a2			beq 	_ETHexConstant
.9890	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; check it actually is a unary function
.9892	90 0b		bcc $989f			bcc 	_ETSyntaxError
.9894	c9 a2		cmp #$a2			cmp 	#KWC_LAST_UNARY+1
.9896	b0 07		bcs $989f			bcs 	_ETSyntaxError
.9898	da		phx				phx 								; push X on the stack
.9899	0a		asl a				asl 	a 							; put vector x 2 into X
.989a	aa		tax				tax
.989b	c8		iny				iny 								; consume unary function token
.989c	7c 50 8c	jmp ($8c50,x)			jmp 	(VectorSet0,x) 				; and do it.
.989f					_ETSyntaxError:
.989f	4c be 9f	jmp $9fbe			jmp 	SyntaxError
.98a2					_ETHexConstant:
.98a2	c8		iny				iny 								; skip #
.98a3	c8		iny				iny 								; skip count
.98a4	20 40 9e	jsr $9e40			jsr 	NSMSetZero 					; clear result
.98a7					_ETHLoop:
.98a7	b1 30		lda ($30),y			lda 	(codePtr),y
.98a9	c8		iny				iny 								; and consume
.98aa	c9 00		cmp #$00			cmp 	#0 							; exit if zero
.98ac	f0 1c		beq $98ca			beq 	_ETHExit
.98ae	48		pha				pha 								; save on stack.
.98af	20 4f 9e	jsr $9e4f			jsr 	NSMShiftLeft 				; x 2
.98b2	20 4f 9e	jsr $9e4f			jsr 	NSMShiftLeft 				; x 4
.98b5	20 4f 9e	jsr $9e4f			jsr 	NSMShiftLeft 				; x 8
.98b8	20 4f 9e	jsr $9e4f			jsr 	NSMShiftLeft 				; x 16
.98bb	68		pla				pla 								; ASCII
.98bc	c9 41		cmp #$41			cmp 	#'A'
.98be	90 02		bcc $98c2			bcc 	_ETHNotChar
.98c0	e9 07		sbc #$07			sbc 	#7
.98c2					_ETHNotChar:
.98c2	29 0f		and #$0f			and 	#15 						; digit now
.98c4	15 58		ora $58,x			ora 	NSMantissa0,x 				; put in LS Nibble
.98c6	95 58		sta $58,x			sta 	NSMantissa0,x
.98c8	80 dd		bra $98a7			bra 	_ETHLoop 					; go round.
.98ca					_ETHExit:
.98ca	60		rts				rts
.98cb					_ETString:
.98cb	c8		iny				iny 								; look at length
.98cc	b1 30		lda ($30),y			lda 	(codePtr),y
.98ce	48		pha				pha
.98cf	c8		iny				iny 								; first character
.98d0	20 9c a5	jsr $a59c			jsr 	MemoryInline 				; put address of string at (code-Ptr),y on stack
.98d3	68		pla				pla 								; restore count and save
.98d4	85 36		sta $36				sta 	zTemp0
.98d6	98		tya				tya 								; add length to Y to skip it.
.98d7	18		clc				clc
.98d8	65 36		adc $36				adc 	zTemp0
.98da	a8		tay				tay
.98db	a9 10		lda #$10			lda 	#NSTString 					; mark as string
.98dd	95 50		sta $50,x			sta 	NSStatus,x
.98df	60		rts				rts
.98e0					_ETVariable:
.98e0	4c 35 99	jmp $9935			jmp 	VariableHandler
.98e3					_ETPuncUnary:
.98e3	c8		iny				iny 								; consume the unary character
.98e4	c9 2d		cmp #$2d			cmp 	#KWD_MINUS 					; unary minus
.98e6	f0 2b		beq $9913			beq 	_ETUnaryNegate
.98e8	c9 10		cmp #$10			cmp 	#KWD_AT 					; @ reference -> constant
.98ea	f0 36		beq $9922			beq 	_ETDereference
.98ec	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; parenthesis
.98ee	f0 3e		beq $992e			beq 	_ETParenthesis
.98f0	64 36		stz $36				stz 	zTemp0 						; zTemp0 is the indirection level.
.98f2	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; byte indirection (0) ?
.98f4	f0 06		beq $98fc			beq 	_ETIndirection
.98f6	e6 36		inc $36				inc 	zTemp0
.98f8	c9 21		cmp #$21			cmp 	#KWD_PLING					; word indirection (1) \
.98fa	d0 a3		bne $989f			bne 	_ETSyntaxError
.98fc					_ETIndirection:
.98fc	a5 36		lda $36				lda 	zTemp0 						; push indirection amount (0-1) => (1-2) on the stack
.98fe	1a		inc a				inc 	a
.98ff	48		pha				pha
.9900	20 6c 98	jsr $986c			jsr 	EvaluateTerm				; evaluate the term
.9903	20 e5 96	jsr $96e5			jsr 	Dereference 				; dereference it.
.9906	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a +ve integer.
.9908	d0 06		bne $9910			bne 	_ETTypeMismatch
.990a	68		pla				pla 								; indirection 1-2
.990b	09 20		ora #$20			ora 	#NSBIsReference 			; make it a reference.
.990d	95 50		sta $50,x			sta 	NSStatus,x
.990f	60		rts				rts
.9910					_ETTypeMismatch:
.9910	4c c8 9f	jmp $9fc8			jmp 	TypeError
.9913					_ETUnaryNegate:
.9913	20 6c 98	jsr $986c			jsr 	EvaluateTerm				; evaluate the term
.9916	20 e5 96	jsr $96e5			jsr 	Dereference 				; dereference it.
.9919	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a number
.991b	29 10		and #$10			and 	#NSTString
.991d	d0 f1		bne $9910			bne 	_ETTypeMismatch
.991f	4c 02 9e	jmp $9e02			jmp 	NSMNegate  					; just toggles the sign bit.
.9922					_ETDereference:
.9922	20 6c 98	jsr $986c			jsr 	EvaluateTerm				; evaluate the term
.9925	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a reference
.9927	29 20		and #$20			and 	#NSBIsReference
.9929	f0 e5		beq $9910			beq 	_ETTypeMismatch
.992b	74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer address
.992d	60		rts				rts
.992e					_ETParenthesis:
.992e	20 22 94	jsr $9422			jsr 	EvaluateExpression 			; evaluate here, from lowest precedence
.9931	20 05 8f	jsr $8f05			jsr 	CheckRightBracket 			; check for )
.9934	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/variable.asm

.9935					VariableHandler:
.9935	b1 30		lda ($30),y			lda 	(codePtr),y
.9937	18		clc				clc
.9938	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.993a	85 37		sta $37				sta 	zTemp0+1
.993c	c8		iny				iny
.993d	b1 30		lda ($30),y			lda 	(codePtr),y
.993f	85 36		sta $36				sta 	zTemp0
.9941	c8		iny				iny
.9942	18		clc				clc									; copy variable address+3 to mantissa
.9943	69 03		adc #$03			adc 	#3 							; this is the address of the data.
.9945	95 58		sta $58,x			sta 	NSMantissa0,x
.9947	a5 37		lda $37				lda 	zTemp0+1
.9949	69 00		adc #$00			adc 	#0
.994b	95 60		sta $60,x			sta 	NSMantissa1,x
.994d	74 68		stz $68,x			stz 	NSMantissa2,x
.994f	74 70		stz $70,x			stz 	NSMantissa3,x
.9951	74 78		stz $78,x			stz 	NSExponent,x
.9953	5a		phy				phy
.9954	a0 02		ldy #$02			ldy 	#2 							; read type
.9956	b1 36		lda ($36),y			lda 	(zTemp0),y
.9958	7a		ply				ply
.9959	29 1c		and #$1c			and 	#NSBTypeMask+NSBIsArray 	; get type information
.995b	09 20		ora #$20			ora 	#NSBIsReference 			; make a reference.
.995d	95 50		sta $50,x			sta 	NSStatus,x
.995f	29 04		and #$04			and 	#NSBIsArray
.9961	d0 01		bne $9964			bne 	_VHArray
.9963	60		rts				rts
.9964					_VHArray:
.9964	e8		inx				inx
.9965	20 db 9d	jsr $9ddb			jsr 	Evaluate8BitInteger 		; get the 1st index.
.9968	a9 ff		lda #$ff			lda 	#$FF 						; set Status of X+2 to a duff value so we know if we picked it up.
.996a	95 51		sta $51,x			sta 	NSStatus+1,x
.996c	b1 30		lda ($30),y			lda 	(codePtr),y
.996e	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.9970	d0 06		bne $9978			bne 	_VHNoSecondIndex
.9972	c8		iny				iny 								; skip the comma
.9973	e8		inx				inx
.9974	20 db 9d	jsr $9ddb			jsr 	Evaluate8BitInteger 		; get the 2nd index.
.9977	ca		dex				dex
.9978					_VHNoSecondIndex:
.9978	ca		dex				dex 								; set X back.
.9979	20 05 8f	jsr $8f05			jsr 	CheckRightBracket 			; and check the right bracket.
.997c	5a		phy				phy 								; save position
.997d	a0 02		ldy #$02			ldy 	#2 							; check first index is not-zero, e.g. array defined
.997f	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9981	f0 60		beq $99e3			beq 	_VHBadIndex
.9983	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy record address to zaTemp
.9985	85 3e		sta $3e				sta 	zaTemp
.9987	b5 60		lda $60,x			lda 	NSMantissa1,x
.9989	85 3f		sta $3f				sta 	zaTemp+1
.998b	a0 03		ldy #$03			ldy 	#3 							; get the second index - which is 0 if there is one index.
.998d	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.998f	f0 02		beq $9993			beq 	_VHHas2Mask
.9991	a9 ff		lda #$ff			lda 	#$FF
.9993					_VHHas2Mask:
.9993	d5 52		cmp $52,x			cmp 	NSStatus+2,x 				; so if they are the same there are the wrong number of indices
.9995	f0 4c		beq $99e3			beq 	_VHBadIndex
.9997	0a		asl a				asl 	a 							; carry will be set if a second index
.9998	90 08		bcc $99a2			bcc 	_VHCheckFirstIndex
.999a	a0 03		ldy #$03			ldy 	#3 			 				; check the 2nd size >= 2nd index
.999c	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.999e	d5 5a		cmp $5a,x			cmp 	NSMantissa0+2,x
.99a0	90 41		bcc $99e3			bcc 	_VHBadIndex
.99a2					_VHCheckFirstIndex:
.99a2	a0 02		ldy #$02			ldy 	#2 			 				; check the 2nd size >= 2nd index
.99a4	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99a6	d5 59		cmp $59,x			cmp 	NSMantissa0+1,x
.99a8	90 39		bcc $99e3			bcc 	_VHBadIndex
.99aa	64 36		stz $36				stz 	zTemp0 						; clear zTemp0 (if 1 index)
.99ac	64 37		stz $37				stz 	zTemp0+1
.99ae	b5 52		lda $52,x			lda 	NSStatus+2,x 				; if only one index provided, don't need to multiply
.99b0	30 0e		bmi $99c0			bmi 	_VHNoMultiply
.99b2	da		phx				phx
.99b3	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; get 2nd index on stack
.99b5	48		pha				pha
.99b6	a0 02		ldy #$02			ldy 	#2 							; get 1st size in A
.99b8	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99ba	1a		inc a				inc 	a 							; add 1 for zero base
.99bb	fa		plx				plx
.99bc	20 eb 9d	jsr $9deb			jsr 	Multiply8x8 				; calculate -> Z0
.99bf	fa		plx				plx
.99c0					_VHNoMultiply:
.99c0	18		clc				clc
.99c1	a5 36		lda $36				lda 	zTemp0
.99c3	75 59		adc $59,x			adc 	NSMantissa0+1,x
.99c5	85 36		sta $36				sta 	zTemp0
.99c7	a5 37		lda $37				lda 	zTemp0+1
.99c9	69 00		adc #$00			adc 	#0
.99cb	85 37		sta $37				sta 	zTemp0+1
.99cd	b5 50		lda $50,x			lda 	NSStatus,x
.99cf	20 30 85	jsr $8530			jsr 	ScaleByBaseType
.99d2	18		clc				clc
.99d3	b2 3e		lda ($3e)			lda 	(zaTemp)
.99d5	65 36		adc $36				adc 	zTemp0
.99d7	95 58		sta $58,x			sta 	NSMantissa0,x
.99d9	a0 01		ldy #$01			ldy 	#1
.99db	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99dd	65 37		adc $37				adc 	zTemp0+1
.99df	95 60		sta $60,x			sta 	NSMantissa1,x
.99e1	7a		ply				ply 								; restore position
.99e2	60		rts				rts
.99e3					_VHBadIndex:
.99e3	a9 17		lda #$17		lda	#23
.99e5	4c 1e 8f	jmp $8f1e		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/abs.asm

.99e8					AbsUnary:
.99e8	fa		plx				plx 								; restore stack pos
.99e9	20 8e 9d	jsr $9d8e			jsr 	EvaluateNumber 				; get a float or int
.99ec	20 05 8f	jsr $8f05			jsr 	CheckRightBracket
.99ef	b5 50		lda $50,x			lda 	NSStatus,x 					; clear the sign bit
.99f1	29 7f		and #$7f			and 	#$7F
.99f3	95 50		sta $50,x			sta 	NSStatus,x
.99f5	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/alloc.asm

.99f6					AllocUnary:
.99f6	fa		plx				plx 								; restore stack pos
.99f7	20 c0 9d	jsr $9dc0			jsr 	Evaluate16BitInteger		; get bytes required.
.99fa	20 05 8f	jsr $8f05			jsr 	CheckRightBracket
.99fd	da		phx				phx 								; save X/Y
.99fe	5a		phy				phy
.99ff	8a		txa				txa 								; copy X into Y
.9a00	a8		tay				tay
.9a01	b9 60 00	lda $0060,y			lda		NSMantissa1,y 				; get size into XA
.9a04	aa		tax				tax
.9a05	b9 58 00	lda $0058,y			lda 	NSMantissa0,y
.9a08	20 15 9a	jsr $9a15			jsr 	AllocateXABytes 			; allocate memory
.9a0b	99 58 00	sta $0058,y			sta 	NSMantissa0,y 				; write address out.
.9a0e	8a		txa				txa 	 							; typing is 16 bit integer.
.9a0f	99 60 00	sta $0060,y			sta 	NSMantissa1,y
.9a12	7a		ply				ply
.9a13	fa		plx				plx
.9a14	60		rts				rts
.9a15					AllocateXABytes:
.9a15	5a		phy				phy
.9a16	ac 0c 04	ldy $040c			ldy 	lowMemPtr 					; push current address on stack and to zTemp0
.9a19	84 36		sty $36				sty 	zTemp0
.9a1b	5a		phy				phy
.9a1c	ac 0d 04	ldy $040d			ldy 	lowMemPtr+1
.9a1f	84 37		sty $37				sty 	zTemp0+1
.9a21	5a		phy				phy
.9a22	18		clc				clc 								; add to low memory pointer
.9a23	6d 0c 04	adc $040c			adc 	lowMemPtr
.9a26	8d 0c 04	sta $040c			sta 	lowMemPtr
.9a29	8a		txa				txa
.9a2a	6d 0d 04	adc $040d			adc 	lowMemPtr+1
.9a2d	8d 0d 04	sta $040d			sta 	lowMemPtr+1
.9a30	b0 2f		bcs $9a61			bcs 	CISSMemory
.9a32	20 53 9a	jsr $9a53			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.9a35					_ClearMemory:
.9a35	ad 0c 04	lda $040c			lda 	lowMemPtr 					; cleared all memory allocated
.9a38	c5 36		cmp $36				cmp 	zTemp0
.9a3a	d0 07		bne $9a43			bne 	_CMClearNext
.9a3c	ad 0d 04	lda $040d			lda 	lowMemPtr+1
.9a3f	c5 37		cmp $37				cmp 	zTemp0+1
.9a41	f0 0c		beq $9a4f			beq 	_CMExit
.9a43					_CMClearNext:
.9a43	a9 00		lda #$00			lda 	#0 							; clear byte, advance to next.
.9a45	92 36		sta ($36)			sta 	(zTemp0)
.9a47	e6 36		inc $36				inc 	zTemp0
.9a49	d0 ea		bne $9a35			bne 	_ClearMemory
.9a4b	e6 37		inc $37				inc		zTemp0+1
.9a4d	80 e6		bra $9a35			bra 	_ClearMemory
.9a4f					_CMExit:
.9a4f	fa		plx				plx
.9a50	68		pla				pla
.9a51	7a		ply				ply
.9a52	60		rts				rts
.9a53					CheckIdentifierStringSpace:
.9a53	48		pha				pha
.9a54	ad 0d 04	lda $040d			lda 	lowMemPtr+1 				; get low memory pointer
.9a57	18		clc				clc
.9a58	69 02		adc #$02			adc 	#2 							; need at least 2 256 byte pages
.9a5a	cd 0f 04	cmp $040f			cmp 	StringMemory+1 				; is it >= StringMemory
.9a5d	b0 02		bcs $9a61			bcs 	CISSMemory
.9a5f	68		pla				pla
.9a60	60		rts				rts
.9a61					CISSMemory:
.9a61	a9 06		lda #$06		lda	#6
.9a63	4c 1e 8f	jmp $8f1e		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/asc.asm

.9a66					AscUnary:
.9a66	fa		plx				plx 								; restore stack pos
.9a67	20 98 9d	jsr $9d98			jsr 	EvaluateString 				; get a string
.9a6a	b2 36		lda ($36)			lda 	(zTemp0)					; get/return first character
.9a6c	20 42 9e	jsr $9e42			jsr 	NSMSetByte 					; ASC("") will return zero.
.9a6f	20 05 8f	jsr $8f05			jsr 	CheckRightBracket
.9a72	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/deekpeek.asm

.9a73					PeekUnary:
.9a73	18		clc				clc
.9a74	80 01		bra $9a77			bra 	DPUnary
.9a76					DeekUnary:
.9a76	38		sec				sec
.9a77					DPUnary:
.9a77	fa		plx				plx 								; restore position.
.9a78	08		php				php									; save on stack, CS = Deek, CC = Peek
.9a79	20 c0 9d	jsr $9dc0			jsr		Evaluate16BitInteger 		; address as constant.
.9a7c	20 05 8f	jsr $8f05			jsr 	CheckRightBracket
.9a7f	28		plp				plp 								; function back.
.9a80	a9 21		lda #$21			lda 	#NSBIsReference+NSTInteger+1 ; 1 byte read
.9a82	90 01		bcc $9a85			bcc 	_DPUpdate
.9a84	1a		inc a				inc 	a 							; 2 byte read
.9a85					_DPUpdate:
.9a85	95 50		sta $50,x			sta 	NSStatus,x 					; set to 1/2 byte reference.
.9a87	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/frac.asm

.9a88					FracUnary:
.9a88	fa		plx				plx 								; restore stack pos
.9a89	20 8e 9d	jsr $9d8e			jsr 	EvaluateNumber 				; get a float or int
.9a8c	20 05 8f	jsr $8f05			jsr 	CheckRightBracket
.9a8f	b5 50		lda $50,x			lda 	NSStatus,x
.9a91	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9a93	f0 04		beq $9a99			beq 	_IUZero
.9a95	20 33 95	jsr $9533			jsr 	FloatFractionalPart 		; if so, get the fractional part.
.9a98	60		rts				rts
.9a99					_IUZero:
.9a99	20 40 9e	jsr $9e40			jsr 	NSMSetZero
.9a9c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/int.asm

.9a9d					IntUnary:
.9a9d	fa		plx				plx 								; restore stack pos
.9a9e	20 8e 9d	jsr $9d8e			jsr 	EvaluateNumber 				; get a float or int
.9aa1	20 05 8f	jsr $8f05			jsr 	CheckRightBracket
.9aa4	b5 50		lda $50,x			lda 	NSStatus,x
.9aa6	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9aa8	f0 03		beq $9aad			beq 	_IUExit
.9aaa	20 8b 95	jsr $958b			jsr 	FloatIntegerPart 			; if it is get the integer part.
.9aad					_IUExit:
.9aad	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/len.asm

.9aae					LenUnary:
.9aae	fa		plx				plx 								; restore stack pos
.9aaf	20 98 9d	jsr $9d98			jsr 	EvaluateString 				; get a string
.9ab2	5a		phy				phy
.9ab3	a0 00		ldy #$00			ldy 	#0 							; find length
.9ab5					_LenFind:
.9ab5	b1 36		lda ($36),y			lda 	(zTemp0),y 					; look for trailing NULL.
.9ab7	f0 06		beq $9abf			beq 	_LenExit
.9ab9	c8		iny				iny
.9aba	d0 f9		bne $9ab5			bne 	_LenFind
.9abc	4c c3 9f	jmp $9fc3			jmp 	RangeError 					; string > 255 - no trailing NULL.
.9abf					_LenExit:
.9abf	98		tya				tya		 							; return length
.9ac0	20 42 9e	jsr $9e42			jsr 	NSMSetByte
.9ac3	7a		ply				ply
.9ac4	20 05 8f	jsr $8f05			jsr 	CheckRightBracket
.9ac7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/minmax.asm

.9ac8					Unary_Min:
.9ac8	a9 01		lda #$01			lda 	#1
.9aca	80 02		bra $9ace			bra 	UnaryMinMaxMain
.9acc					Unary_Max:
.9acc	a9 ff		lda #$ff			lda 	#$FF 						; value from comparator to cause a write
.9ace					UnaryMinMaxMain:
.9ace	fa		plx				plx 								; get index on number stack
.9acf	48		pha				pha 								; save comparator
.9ad0	20 85 9d	jsr $9d85			jsr 	EvaluateValue 				; get the first value.
.9ad3					_UMMMLoop:
.9ad3	b1 30		lda ($30),y			lda 	(codePtr),y
.9ad5	c9 29		cmp #$29			cmp 	#KWD_RPAREN 				; if right bracket then done.
.9ad7	f0 22		beq $9afb			beq 	_UMMMDone
.9ad9	20 0d 8f	jsr $8f0d			jsr 	CheckComma 					; must be a comma
.9adc	e8		inx				inx
.9add	20 85 9d	jsr $9d85			jsr 	EvaluateValue
.9ae0	ca		dex				dex
.9ae1	20 23 9e	jsr $9e23			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] (Compare is destructive)
.9ae4	e8		inx				inx
.9ae5	20 23 9e	jsr $9e23			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2], original
.9ae8	e8		inx				inx
.9ae9	20 d5 8f	jsr $8fd5			jsr 	CompareBaseCode 			; part of > = < etc. code, returns 255,0 or 1
.9aec	ca		dex				dex
.9aed	ca		dex				dex
.9aee	85 36		sta $36				sta 	zTemp0 						; save required result
.9af0	68		pla				pla 								; get and save comparator
.9af1	48		pha				pha
.9af2	c5 36		cmp $36				cmp 	zTemp0 						; if the comparator
.9af4	d0 dd		bne $9ad3			bne 	_UMMMLoop
.9af6	20 fe 9a	jsr $9afe			jsr 	ExpCopyAboveDown 			; copy next up slot down
.9af9	80 d8		bra $9ad3			bra 	_UMMMLoop
.9afb					_UMMMDone:
.9afb	68		pla				pla 								; throw the comparator
.9afc	c8		iny				iny 								; skip )
.9afd	60		rts				rts
.9afe					ExpCopyAboveDown:
.9afe	b5 51		lda $51,x			lda 	NSStatus+1,x
.9b00	95 50		sta $50,x			sta 	NSStatus,x
.9b02	b5 79		lda $79,x			lda 	NSExponent+1,x
.9b04	95 78		sta $78,x			sta 	NSExponent,x
.9b06	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9b08	95 58		sta $58,x			sta 	NSMantissa0,x
.9b0a	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9b0c	95 60		sta $60,x			sta 	NSMantissa1,x
.9b0e	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.9b10	95 68		sta $68,x			sta 	NSMantissa2,x
.9b12	b5 71		lda $71,x			lda 	NSMantissa3+1,x
.9b14	95 70		sta $70,x			sta 	NSMantissa3,x
.9b16	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/not.asm

.9b17					Unary_Not:
.9b17	fa		plx				plx
.9b18	20 ad 9d	jsr $9dad			jsr 	EvaluateInteger 			; get integer
.9b1b	20 05 8f	jsr $8f05			jsr 	CheckRightBracket
.9b1e	20 62 9e	jsr $9e62			jsr 	NSMIsZero 					; zero mantissa ?
.9b21	f0 04		beq $9b27			beq 	_NotZero
.9b23	20 40 9e	jsr $9e40			jsr 	NSMSetZero
.9b26	60		rts				rts
.9b27					_NotZero:
.9b27	4c 8b 8f	jmp $8f8b			jmp 	ReturnTrue

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/rnd.asm

.9b2a					Unary_Random:
.9b2a	fa		plx				plx
.9b2b	20 9c 9b	jsr $9b9c			jsr 	Random32Bit 				; get a random number
.9b2e	20 85 9b	jsr $9b85			jsr 	URCopyToMantissa  			; put in mantissa
.9b31	b1 30		lda ($30),y			lda 	(codePtr),y
.9b33	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.9b35	f0 08		beq $9b3f			beq 	_URNoModulus 				; then we return a random 30 bit number.
.9b37	e8		inx				inx
.9b38	20 c0 9d	jsr $9dc0			jsr 	Evaluate16BitInteger 		; put modulus value in +1
.9b3b	ca		dex				dex
.9b3c	20 dd 90	jsr $90dd			jsr 	IntegerModulusNoCheck 		; calculate modulus, so now 0 .. n-1
.9b3f					_URNoModulus:
.9b3f	74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer positive
.9b41	74 78		stz $78,x			stz 	NSExponent,x
.9b43	20 05 8f	jsr $8f05			jsr 	CheckRightBracket
.9b46	60		rts				rts
.9b47					Unary_Rnd:
.9b47	fa		plx				plx
.9b48	20 8e 9d	jsr $9d8e			jsr 	EvaluateNumber 				; number to use.
.9b4b	20 05 8f	jsr $8f05			jsr 	CheckRightBracket 			; closing bracket
.9b4e	20 62 9e	jsr $9e62			jsr 	NSMIsZero 					; if zero, then don't generate a new number
.9b51	f0 26		beq $9b79			beq 	_URCopySeed
.9b53	b5 50		lda $50,x			lda 	NSStatus,x 					; if -ve, then seed using parameter
.9b55	10 1f		bpl $9b76			bpl 	_URDontSeed
.9b57	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy - value to seed butchering it.
.9b59	49 17		eor #$17			eor 	#$17
.9b5b	8d 08 04	sta $0408			sta 	RandomSeed+0
.9b5e	b5 60		lda $60,x			lda 	NSMantissa1,x
.9b60	49 a5		eor #$a5			eor 	#$A5
.9b62	8d 09 04	sta $0409			sta 	RandomSeed+1
.9b65	b5 68		lda $68,x			lda 	NSMantissa2,x
.9b67	49 c2		eor #$c2			eor 	#$C2
.9b69	8d 0a 04	sta $040a			sta 	RandomSeed+2
.9b6c	b5 70		lda $70,x			lda 	NSMantissa3,x
.9b6e	49 9d		eor #$9d			eor 	#$9D
.9b70	8d 0b 04	sta $040b			sta 	RandomSeed+3
.9b73	20 9c 9b	jsr $9b9c			jsr 	Random32Bit
.9b76					_URDontSeed:
.9b76	20 9c 9b	jsr $9b9c			jsr 	Random32Bit 				; generate a number
.9b79					_URCopySeed:
.9b79	20 85 9b	jsr $9b85			jsr 	URCopyToMantissa 			; copy into mantissa
.9b7c	a9 e2		lda #$e2			lda 	#-30 						; force into 0-1 range
.9b7e	95 78		sta $78,x			sta 	NSExponent,x
.9b80	a9 08		lda #$08			lda 	#NSTFloat
.9b82	95 50		sta $50,x			sta 	NSStatus,x 					; positive float
.9b84	60		rts				rts
.9b85					URCopyToMantissa:
.9b85	ad 08 04	lda $0408			lda 	RandomSeed+0
.9b88	95 58		sta $58,x			sta 	NSMantissa0,x
.9b8a	ad 09 04	lda $0409			lda 	RandomSeed+1
.9b8d	95 60		sta $60,x			sta 	NSMantissa1,x
.9b8f	ad 0a 04	lda $040a			lda 	RandomSeed+2
.9b92	95 68		sta $68,x			sta 	NSMantissa2,x
.9b94	ad 0b 04	lda $040b			lda 	RandomSeed+3
.9b97	29 3f		and #$3f			and 	#$3F 						; make legal mantissa
.9b99	95 70		sta $70,x			sta 	NSMantissa3,x
.9b9b	60		rts				rts
.9b9c					Random32Bit:
.9b9c	5a		phy				phy
.9b9d	a0 07		ldy #$07			ldy 	#7 							; do it 7 times
.9b9f	ad 08 04	lda $0408			lda 	RandomSeed+0 				; check the seed isn't zero
.9ba2	d0 03		bne $9ba7			bne 	_Random1
.9ba4	a8		tay				tay 								; if so do it 256 times
.9ba5	a9 aa		lda #$aa			lda		#$AA 						; and use this to seed the seed....
.9ba7					_Random1:
.9ba7	0a		asl a				asl 	a 							; LSFR RNG
.9ba8	2e 09 04	rol $0409			rol 	RandomSeed+1
.9bab	2e 0a 04	rol $040a			rol 	RandomSeed+2
.9bae	2e 0b 04	rol $040b			rol 	RandomSeed+3
.9bb1	90 02		bcc $9bb5			bcc 	_Random2
.9bb3	49 c5		eor #$c5			eor 	#$C5
.9bb5					_Random2:
.9bb5	88		dey				dey
.9bb6	d0 ef		bne $9ba7			bne 	_Random1
.9bb8	8d 08 04	sta $0408			sta 	RandomSeed+0
.9bbb	7a		ply				ply
.9bbc	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/sgn.asm

.9bbd					SgnUnary:
.9bbd	fa		plx				plx 								; restore stack pos
.9bbe	20 8e 9d	jsr $9d8e			jsr 	EvaluateNumber 				; get a float or int
.9bc1	20 05 8f	jsr $8f05			jsr 	CheckRightBracket
.9bc4	20 62 9e	jsr $9e62			jsr 	NSMIsZero 					; if zero
.9bc7	f0 0e		beq $9bd7			beq 	_SGZero  					; return Int Zero
.9bc9	b5 50		lda $50,x			lda 	NSStatus,x 					; get status w/sign
.9bcb	48		pha				pha
.9bcc	a9 01		lda #$01			lda 	#1 							; set to 1
.9bce	20 42 9e	jsr $9e42			jsr 	NSMSetByte
.9bd1	68		pla				pla
.9bd2	29 80		and #$80			and		#$80 						; copy the sign byte out
.9bd4	95 50		sta $50,x			sta 	NSStatus,x  				; so it will be -1 or 1
.9bd6	60		rts				rts
.9bd7	20 40 9e	jsr $9e40	_SGZero:jsr 	NSMSetZero
.9bda	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/val.asm

.9bdb					ValUnary:
.9bdb	fa		plx				plx 								; restore stack pos
.9bdc	20 f1 9b	jsr $9bf1			jsr 	ValMainCode 				; do the main val() code
.9bdf	b0 01		bcs $9be2			bcs 	_VUError 					; couldn't convert
.9be1	60		rts				rts
.9be2					_VUError:
.9be2	4c c8 9f	jmp $9fc8			jmp 	TypeError
.9be5					IsValUnary:
.9be5	fa		plx				plx 								; restore stack pos
.9be6	20 f1 9b	jsr $9bf1			jsr 	ValMainCode 				; do the main val() code
.9be9	b0 03		bcs $9bee			bcs 	_VUBad
.9beb	4c 8b 8f	jmp $8f8b			jmp 	ReturnTrue
.9bee					_VUBad:
.9bee	4c 96 8f	jmp $8f96			jmp 	ReturnFalse
.9bf1					ValMainCode:
.9bf1	20 98 9d	jsr $9d98			jsr 	EvaluateString 				; get a string
.9bf4	20 05 8f	jsr $8f05			jsr 	CheckRightBracket 			; check right bracket present
.9bf7					ValEvaluateZTemp0:
.9bf7	5a		phy				phy
.9bf8	b2 36		lda ($36)			lda 	(zTemp0) 					; check not empty string
.9bfa	f0 17		beq $9c13			beq 	_VMCFail2
.9bfc	a0 ff		ldy #$ff			ldy 	#$FF 						; start position
.9bfe	48		pha				pha 								; save first character
.9bff	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.9c01	d0 01		bne $9c04			bne 	_VMCStart
.9c03	c8		iny				iny 								; skip over -
.9c04					_VMCStart:
.9c04	38		sec				sec 								; initialise first time round.
.9c05					_VMCNext:
.9c05	c8		iny				iny 								; pre-increment
.9c06	b1 36		lda ($36),y			lda 	(zTemp0),y 					; next character = EOS ?
.9c08	f0 0c		beq $9c16			beq 	_VMCSuccess 				; successful.
.9c0a	20 68 97	jsr $9768			jsr 	EncodeNumber 				; send it to the number-builder
.9c0d	90 03		bcc $9c12			bcc 	_VMCFail 					; if failed, give up.
.9c0f	18		clc				clc 								; next time round, countinue
.9c10	80 f3		bra $9c05			bra 	_VMCNext
.9c12					_VMCFail:
.9c12	68		pla				pla
.9c13					_VMCFail2:
.9c13	7a		ply				ply
.9c14	38		sec				sec
.9c15	60		rts				rts
.9c16					_VMCSuccess:
.9c16	a9 00		lda #$00			lda 	#0 							; construct final
.9c18	20 68 97	jsr $9768			jsr 	EncodeNumber 				; by sending a duff value.
.9c1b	68		pla				pla 								; if it was -ve
.9c1c	c9 2d		cmp #$2d			cmp 	#"-"
.9c1e	d0 03		bne $9c23			bne 	_VMCNotNegative
.9c20	20 02 9e	jsr $9e02			jsr		NSMNegate 					; negate it.
.9c23					_VMCNotNegative:
.9c23	7a		ply				ply
.9c24	18		clc				clc
.9c25	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/chr.asm

.9c26					ChrUnary:
.9c26	fa		plx				plx 								; restore stack pos
.9c27	20 db 9d	jsr $9ddb			jsr 	Evaluate8BitInteger			; get value (chr$(0) returns an empty string)
.9c2a	48		pha				pha
.9c2b	20 05 8f	jsr $8f05			jsr 	CheckRightBracket
.9c2e	a9 01		lda #$01			lda 	#1 							; allocate space for one char
.9c30	20 c3 a7	jsr $a7c3			jsr 	StringTempAllocate
.9c33	68		pla				pla 								; write number to it
.9c34	20 fc a7	jsr $a7fc			jsr 	StringTempWrite
.9c37	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/spc.asm

.9c38					SpcUnary:
.9c38	fa		plx				plx 								; restore stack pos
.9c39	20 db 9d	jsr $9ddb			jsr 	Evaluate8BitInteger			; get value
.9c3c	5a		phy				phy
.9c3d	48		pha				pha 								; save count
.9c3e	20 c3 a7	jsr $a7c3			jsr 	StringTempAllocate
.9c41	7a		ply				ply 								; to do count in Y
.9c42					_SpcLoop:
.9c42	c0 00		cpy #$00			cpy 	#0 							; copy Y spaces in.
.9c44	f0 08		beq $9c4e			beq 	_SpcExit
.9c46	a9 20		lda #$20			lda 	#32
.9c48	20 fc a7	jsr $a7fc			jsr 	StringTempWrite
.9c4b	88		dey				dey
.9c4c	80 f4		bra $9c42			bra 	_SPCLoop
.9c4e					_SpcExit:
.9c4e	7a		ply				ply
.9c4f	20 05 8f	jsr $8f05			jsr 	CheckRightBracket
.9c52	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/str.asm

.9c53					Unary_Str:
.9c53	fa		plx				plx
.9c54	20 8e 9d	jsr $9d8e			jsr 	EvaluateNumber  			; get number
.9c57	20 05 8f	jsr $8f05			jsr 	CheckRightBracket 			; closing bracket
.9c5a	a9 05		lda #$05			lda 	#5 							; maximum decimals, from Basic816
.9c5c	20 75 9c	jsr $9c75			jsr 	ConvertNumberToString 		; do the conversion.
.9c5f	a9 21		lda #$21			lda		#33 						; create buffer
.9c61	20 c3 a7	jsr $a7c3			jsr 	StringTempAllocate 			; allocate memory
.9c64	da		phx				phx  								; copy the converted string into the buffer.
.9c65	a2 00		ldx #$00			ldx 	#0
.9c67					_USCopy:
.9c67	bd 49 06	lda $0649,x			lda 	DecimalBuffer,x
.9c6a	20 fc a7	jsr $a7fc			jsr 	StringTempWrite
.9c6d	e8		inx				inx
.9c6e	bd 49 06	lda $0649,x			lda 	DecimalBuffer,x
.9c71	d0 f4		bne $9c67			bne 	_USCopy
.9c73	fa		plx				plx
.9c74	60		rts				rts
.9c75					ConvertNumberToString:
.9c75	5a		phy				phy 								; save code position
.9c76	8d 14 04	sta $0414			sta 	DecimalPlaces	 			; save number of DPs.
.9c79	9c 15 04	stz $0415			stz 	dbOffset 					; offset into decimal buffer = start.
.9c7c	b5 50		lda $50,x			lda 	NSStatus,x  				; is it -ve.
.9c7e	10 09		bpl $9c89			bpl 	_CNTSNotNegative
.9c80	29 7f		and #$7f			and 	#$7F 						; make +ve
.9c82	95 50		sta $50,x			sta 	NSStatus,x
.9c84	a9 2d		lda #$2d			lda 	#"-"
.9c86	20 ea 9c	jsr $9cea			jsr 	WriteDecimalBuffer
.9c89					_CNTSNotNegative:
.9c89	b5 78		lda $78,x			lda 	NSExponent,x 				; check if decimal
.9c8b	f0 12		beq $9c9f			beq 	_CNTSNotFloat
.9c8d	e8		inx				inx 								; round up so we don't get too many 6.999999
.9c8e	a9 01		lda #$01			lda 	#1
.9c90	20 42 9e	jsr $9e42			jsr 	NSMSetByte
.9c93	ca		dex				dex
.9c94	b5 78		lda $78,x			lda		NSExponent,x
.9c96	95 79		sta $79,x			sta 	NSExponent+1,x
.9c98	a9 08		lda #$08			lda 	#NSTFloat
.9c9a	95 51		sta $51,x			sta 	NSStatus+1,x
.9c9c	20 6d 94	jsr $946d			jsr 	FloatAdd
.9c9f					_CNTSNotFloat:
.9c9f	20 cc 9c	jsr $9ccc			jsr 	MakePlusTwoString 			; do the integer part.
.9ca2	20 33 95	jsr $9533			jsr 	FloatFractionalPart 		; get the fractional part
.9ca5	20 e4 95	jsr $95e4			jsr 	NSNormalise					; normalise , exit if zero
.9ca8	f0 20		beq $9cca			beq 	_CNTSExit
.9caa	a9 2e		lda #$2e			lda 	#"."
.9cac	20 ea 9c	jsr $9cea			jsr 	WriteDecimalBuffer 			; write decimal place
.9caf					_CNTSDecimal:
.9caf	ce 14 04	dec $0414			dec 	DecimalPlaces 				; done all the decimals
.9cb2	30 16		bmi $9cca			bmi 	_CNTSExit
.9cb4	e8		inx				inx 								; x 10.0
.9cb5	a9 0a		lda #$0a			lda 	#10
.9cb7	20 42 9e	jsr $9e42			jsr 	NSMSetByte
.9cba	a9 08		lda #$08			lda 	#NSTFloat
.9cbc	95 50		sta $50,x			sta 	NSStatus,x
.9cbe	ca		dex				dex
.9cbf	20 b2 95	jsr $95b2			jsr 	FloatMultiply
.9cc2	20 cc 9c	jsr $9ccc			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.9cc5	20 33 95	jsr $9533			jsr 	FloatFractionalPart 		; get the fractional part
.9cc8	80 e5		bra $9caf			bra 	_CNTSDecimal 				; keep going.
.9cca					_CNTSExit:
.9cca	7a		ply				ply
.9ccb	60		rts				rts
.9ccc					MakePlusTwoString:
.9ccc	da		phx				phx
.9ccd	20 23 9e	jsr $9e23			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.9cd0	e8		inx				inx 								; access it
.9cd1	e8		inx				inx
.9cd2	20 8b 95	jsr $958b			jsr 	FloatIntegerPart 			; make it an integer
.9cd5	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.9cd7	20 9d 93	jsr $939d			jsr 	ConvertInt32
.9cda	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.9cdc					_MPTSCopy:
.9cdc	bd 27 06	lda $0627,x			lda 	NumberBuffer,x
.9cdf	20 ea 9c	jsr $9cea			jsr 	WriteDecimalBuffer
.9ce2	e8		inx				inx
.9ce3	bd 27 06	lda $0627,x			lda 	NumberBuffer,x
.9ce6	d0 f4		bne $9cdc			bne 	_MPTSCopy
.9ce8	fa		plx				plx
.9ce9	60		rts				rts
.9cea					WriteDecimalBuffer:
.9cea	da		phx				phx
.9ceb	ae 15 04	ldx $0415			ldx 	dbOffset
.9cee	9d 49 06	sta $0649,x			sta 	DecimalBuffer,x
.9cf1	9e 4a 06	stz $064a,x			stz 	DecimalBuffer+1,x
.9cf4	ee 15 04	inc $0415			inc 	dbOffset
.9cf7	fa		plx				plx
.9cf8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/substring.asm

.9cf9					Unary_Left:
.9cf9	fa		plx				plx
.9cfa	18		clc				clc 								; only one parameter
.9cfb	20 5e 9d	jsr $9d5e			jsr 	SubstringInitial 			; set up.
.9cfe	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; Param #1 is the length
.9d00	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9d02	74 59		stz $59,x			stz 	NSMantissa0+1,x 			; Start is zero.
.9d04	80 25		bra $9d2b			bra 	SubstringMain
.9d06					Unary_Right:
.9d06	fa		plx				plx
.9d07	18		clc				clc 								; only one parameter
.9d08	20 5e 9d	jsr $9d5e			jsr 	SubstringInitial 			; set up.
.9d0b	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; length => param 2
.9d0d	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9d0f	b5 78		lda $78,x			lda 	NSExponent,x 				; total length
.9d11	f5 59		sbc $59,x			sbc 	NSMantissa0+1,x 			; length - required.
.9d13	b0 02		bcs $9d17			bcs 	_URNotUnderflow
.9d15	a9 00		lda #$00			lda 	#0 							; start from the beginning, as something like right$("AB",3)
.9d17					_URNotUnderFlow:
.9d17	95 59		sta $59,x			sta 	NSMantissa0+1,x 			; this is the start position
.9d19	80 10		bra $9d2b			bra 	SubStringMain
.9d1b					Unary_Mid:
.9d1b	fa		plx				plx
.9d1c	38		sec				sec 								; two parameters
.9d1d	20 5e 9d	jsr $9d5e			jsr 	SubstringInitial 			; set up.
.9d20	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; first parameter is zero ?
.9d22	f0 04		beq $9d28			beq 	_UMError
.9d24	d6 59		dec $59,x			dec 	NSMantissa0+1,x				; reduce initial offset by 1 as MID$(a$,1..) is actually the first character
.9d26	80 03		bra $9d2b			bra 	SubStringMain
.9d28					_UMError:
.9d28	4c cd 9f	jmp $9fcd			jmp 	ArgumentError
.9d2b					SubStringMain:
.9d2b	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; is the initial offset >= the length
.9d2d	d5 78		cmp $78,x			cmp 	NSExponent,x
.9d2f	b0 27		bcs $9d58			bcs 	_SSMNull 					; if so, return an empty string.
.9d31	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; if copy count is zero
.9d33	f0 23		beq $9d58			beq 	_SSMNull 					; return empty string.
.9d35	18		clc				clc 								; add the offset +1 to the address and
.9d36	b5 58		lda $58,x			lda	 	NSMantissa0,x 				; put in zTemp, this is the start of the substring to copy.
.9d38	75 59		adc $59,x			adc 	NSMantissa0+1,x
.9d3a	85 36		sta $36				sta 	zTemp0
.9d3c	b5 60		lda $60,x			lda	 	NSMantissa1,x
.9d3e	69 00		adc #$00			adc 	#0
.9d40	85 37		sta $37				sta 	zTemp0+1
.9d42					_SSMNoCarry:
.9d42	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; characters required.
.9d44	20 c3 a7	jsr $a7c3			jsr 	StringTempAllocate 			; allocate that many characters
.9d47	5a		phy				phy 								; save Y
.9d48	a0 00		ldy #$00			ldy 	#0 							; start copying in.
.9d4a					_SSMCopy:
.9d4a	b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next character
.9d4c	f0 08		beq $9d56			beq 	_SSMEString 				; no more to copy
.9d4e	20 fc a7	jsr $a7fc			jsr 	StringTempWrite 			; and write it out.
.9d51	c8		iny				iny
.9d52	d6 5a		dec $5a,x			dec 	NSMantissa0+2,x
.9d54	d0 f4		bne $9d4a			bne 	_SSMCopy
.9d56					_SSMEString:
.9d56	7a		ply				ply
.9d57					_SSMExit:
.9d57	60		rts				rts
.9d58					_SSMNull:
.9d58	a9 00		lda #$00			lda 	#0
.9d5a	20 c3 a7	jsr $a7c3			jsr 	StringTempAllocate
.9d5d	60		rts				rts
.9d5e					SubstringInitial:
.9d5e	da		phx				phx 								; save initial stack position
.9d5f	08		php				php 								; save carry on stack indicating 2 parameters
.9d60	20 98 9d	jsr $9d98			jsr 	EvaluateString 				; get a string
.9d63	5a		phy				phy 								; calculate length to exponent.
.9d64	a0 ff		ldy #$ff			ldy 	#$FF
.9d66					_SIFindLength:
.9d66	c8		iny				iny
.9d67	b1 36		lda ($36),y			lda 	(zTemp0),y
.9d69	d0 fb		bne $9d66			bne 	_SIFindLength
.9d6b	98		tya				tya
.9d6c	95 78		sta $78,x			sta 	NSExponent,x
.9d6e	7a		ply				ply
.9d6f	e8		inx				inx
.9d70	20 0d 8f	jsr $8f0d			jsr 	CheckComma 					; comma next
.9d73	20 db 9d	jsr $9ddb			jsr 	Evaluate8BitInteger 		; get next parameter
.9d76	28		plp				plp 								; is it the last parameter ?
.9d77	90 07		bcc $9d80			bcc 	_SSIExit 					; if so, exit.
.9d79	e8		inx				inx
.9d7a	20 0d 8f	jsr $8f0d			jsr 	CheckComma 					; comma next
.9d7d	20 db 9d	jsr $9ddb			jsr 	Evaluate8BitInteger 		; get last parameter
.9d80					_SSIExit:
.9d80	fa		plx				plx
.9d81	20 05 8f	jsr $8f05			jsr 	CheckRightBracket 			; check closing bracket
.9d84	60		rts				rts 								; exit

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/exprhelper.asm

.9d85					EvaluateValue:
.9d85	48		pha				pha
.9d86	20 22 94	jsr $9422			jsr		EvaluateExpression 			; expression
.9d89	20 e5 96	jsr $96e5			jsr 	Dereference					; derefernce it
.9d8c	68		pla				pla
.9d8d	60		rts				rts
.9d8e					EvaluateNumber:
.9d8e	20 85 9d	jsr $9d85			jsr 	EvaluateValue 				; get a value
.9d91	b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.9d93	29 10		and #$10			and 	#NSBIsString
.9d95	d0 13		bne $9daa			bne 	HelperTypeError
.9d97	60		rts				rts
.9d98					EvaluateString:
.9d98	20 85 9d	jsr $9d85			jsr 	EvaluateValue 				; get a value
.9d9b	b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.9d9d	29 10		and #$10			and 	#NSBIsString
.9d9f	f0 09		beq $9daa			beq 	HelperTypeError
.9da1					CopyAddressToTemp0:
.9da1	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address -> zTemp0
.9da3	85 36		sta $36				sta 	zTemp0 						; (so we can do something with it)
.9da5	b5 60		lda $60,x			lda 	NSMantissa1,x
.9da7	85 37		sta $37				sta 	zTemp0+1
.9da9	60		rts				rts
.9daa					HelperTypeError:
.9daa	4c c8 9f	jmp $9fc8			jmp 	TypeError
.9dad					EvaluateInteger:
.9dad	20 8e 9d	jsr $9d8e			jsr 	EvaluateNumber
.9db0	b5 78		lda $78,x			lda 	NSExponent,x 				; check exponent is zero
.9db2	d0 09		bne $9dbd			bne 	HelperValueError 			; if not, it's a float.
.9db4	60		rts				rts
.9db5					EvaluateUnsignedInteger:
.9db5	20 ad 9d	jsr $9dad			jsr 	EvaluateInteger 			; check integer is +ve
.9db8	b5 50		lda $50,x			lda 	NSStatus,x
.9dba	30 01		bmi $9dbd			bmi 	HelperValueError
.9dbc	60		rts				rts
.9dbd					HelperValueError:
.9dbd	4c cd 9f	jmp $9fcd			jmp 	ArgumentError
.9dc0					Evaluate16BitInteger:
.9dc0	20 b5 9d	jsr $9db5			jsr	 	EvaluateUnsignedInteger		; get integer
.9dc3	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9dc5	15 68		ora $68,x			ora 	NSMantissa2,x
.9dc7	d0 f4		bne $9dbd			bne 	HelperValueError
.9dc9	60		rts				rts
.9dca					Evaluate16BitIntegerSigned:
.9dca	20 ad 9d	jsr $9dad			jsr	 	EvaluateInteger				; get integer
.9dcd	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9dcf	15 68		ora $68,x			ora 	NSMantissa2,x
.9dd1	d0 ea		bne $9dbd			bne 	HelperValueError
.9dd3	b5 50		lda $50,x			lda 	NSStatus,x 					; signed ?
.9dd5	10 03		bpl $9dda			bpl 	_EISNotSigned
.9dd7	20 09 9e	jsr $9e09			jsr 	NSMNegateMantissa 			; makes it an actual 2's complement value.
.9dda					_EISNotSigned:
.9dda	60		rts				rts
.9ddb					Evaluate8BitInteger:
.9ddb	20 b5 9d	jsr $9db5			jsr	 	EvaluateUnsignedInteger 	; get an integer
.9dde	d0 dd		bne $9dbd			bne 	HelperValueError
.9de0	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 1, 2 & 3 must be zero
.9de2	15 68		ora $68,x			ora 	NSMantissa2,x
.9de4	15 60		ora $60,x			ora 	NSMantissa1,x
.9de6	d0 d5		bne $9dbd			bne 	HelperValueError
.9de8	b5 58		lda $58,x			lda 	NSMantissa0,x
.9dea	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/mult8x8.asm

.9deb					Multiply8x8:
.9deb	4a		lsr a		  		lsr 	a  							; prime the carry bit for the loop
.9dec	85 36		sta $36			  	sta 	zTemp0
.9dee	86 37		stx $37				stx 	zTemp0+1
.9df0	a9 00		lda #$00			lda 	#0
.9df2	a2 08		ldx #$08			ldx 	#8
.9df4					_M88Loop:
.9df4	90 03		bcc $9df9			bcc 	_M88NoAdd
.9df6	18		clc				clc
.9df7	65 37		adc $37				adc 	zTemp0+1
.9df9					_M88NoAdd:
.9df9	6a		ror a				ror 	a
.9dfa	66 36		ror $36				ror 	zTemp0  					; pull another bit out for the next iteration
.9dfc	ca		dex				dex         						; inc/dec don't modify carry; only shifts and adds do
.9dfd	d0 f5		bne $9df4			bne 	_M88Loop
.9dff	85 37		sta $37				sta 	zTemp0+1 					; store high 8 bits.
.9e01	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/utility.asm

.9e02					NSMNegate:
.9e02	b5 50		lda $50,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.9e04	49 80		eor #$80			eor 	#NSBIsNegative  			; toggle the negative flag
.9e06	95 50		sta $50,x			sta 	NSStatus,x
.9e08	60		rts				rts
.9e09					NSMNegateMantissa:
.9e09	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.9e0a	a9 00		lda #$00			lda 	#0
.9e0c	f5 58		sbc $58,x			sbc 	NSMantissa0,x
.9e0e	95 58		sta $58,x			sta 	NSMantissa0,x
.9e10	a9 00		lda #$00			lda 	#0
.9e12	f5 60		sbc $60,x			sbc 	NSMantissa1,x
.9e14	95 60		sta $60,x			sta 	NSMantissa1,x
.9e16	a9 00		lda #$00			lda 	#0
.9e18	f5 68		sbc $68,x			sbc 	NSMantissa2,x
.9e1a	95 68		sta $68,x			sta 	NSMantissa2,x
.9e1c	a9 00		lda #$00			lda 	#0
.9e1e	f5 70		sbc $70,x			sbc 	NSMantissa3,x
.9e20	95 70		sta $70,x			sta 	NSMantissa3,x
.9e22	60		rts				rts
.9e23					NSMShiftUpTwo:
.9e23	b5 58		lda $58,x			lda 	NSMantissa0,x
.9e25	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9e27	b5 60		lda $60,x			lda 	NSMantissa1,x
.9e29	95 62		sta $62,x			sta 	NSMantissa1+2,x
.9e2b	b5 68		lda $68,x			lda 	NSMantissa2,x
.9e2d	95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.9e2f	b5 70		lda $70,x			lda 	NSMantissa3,x
.9e31	95 72		sta $72,x			sta 	NSMantissa3+2,x
.9e33	b5 78		lda $78,x			lda 	NSExponent,x
.9e35	95 7a		sta $7a,x			sta 	NSExponent+2,x
.9e37	b5 50		lda $50,x			lda 	NSStatus,x
.9e39	95 52		sta $52,x			sta 	NSStatus+2,x
.9e3b	60		rts				rts
.9e3c					NSMSetZeroMantissaOnly:
.9e3c	a9 00		lda #$00			lda 	#0
.9e3e	80 06		bra $9e46			bra 	NSMSetMantissa
.9e40					NSMSetZero:
.9e40	a9 00		lda #$00			lda 	#0
.9e42					NSMSetByte:
.9e42	74 78		stz $78,x			stz 	NSExponent,x 				; zero exponent, as integer.
.9e44	74 50		stz $50,x			stz 	NSStatus,x 					; status zero (integer)
.9e46					NSMSetMantissa:
.9e46	95 58		sta $58,x			sta 	NSMantissa0,x 				; mantissa
.9e48	74 60		stz $60,x			stz 	NSMantissa1,x
.9e4a	74 68		stz $68,x			stz 	NSMantissa2,x
.9e4c	74 70		stz $70,x			stz 	NSMantissa3,x
.9e4e	60		rts				rts
.9e4f					NSMShiftLeft:
.9e4f	18		clc				clc
.9e50					NSMRotateLeft:
.9e50	36 58		rol $58,x			rol 	NSMantissa0,x
.9e52	36 60		rol $60,x			rol		NSMantissa1,x
.9e54	36 68		rol $68,x			rol		NSMantissa2,x
.9e56	36 70		rol $70,x			rol		NSMantissa3,x
.9e58	60		rts				rts
.9e59					NSMShiftRight:
.9e59	56 70		lsr $70,x			lsr 	NSMantissa3,x
.9e5b	76 68		ror $68,x			ror		NSMantissa2,x
.9e5d	76 60		ror $60,x			ror		NSMantissa1,x
.9e5f	76 58		ror $58,x			ror		NSMantissa0,x
.9e61	60		rts				rts
.9e62					NSMIsZero:
.9e62	b5 70		lda $70,x			lda 	NSMantissa3,x
.9e64	15 68		ora $68,x			ora		NSMantissa2,x
.9e66	15 60		ora $60,x			ora		NSMantissa1,x
.9e68	15 58		ora $58,x			ora		NSMantissa0,x
.9e6a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.asm

.9e6b					TickHandler:
.9e6b	5a		phy				phy 								; need to preserve Y
.9e6c	20 1b 80	jsr $801b			jsr 	SNDUpdate 					; update sound
.9e6f	7a		ply				ply
.9e70	60		rts				rts
.065b					LastTick:
>065b							.fill 		1

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/asmcore.asm

.9e71					Assemble_ora:
.9e71	20 78 80	jsr $8078		jsr	AssembleGroup1
>9e74	01					.byte $01
.9e75					Assemble_and:
.9e75	20 78 80	jsr $8078		jsr	AssembleGroup1
>9e78	21					.byte $21
.9e79					Assemble_eor:
.9e79	20 78 80	jsr $8078		jsr	AssembleGroup1
>9e7c	41					.byte $41
.9e7d					Assemble_adc:
.9e7d	20 78 80	jsr $8078		jsr	AssembleGroup1
>9e80	61					.byte $61
.9e81					Assemble_sta:
.9e81	20 78 80	jsr $8078		jsr	AssembleGroup1
>9e84	81					.byte $81
.9e85					Assemble_lda:
.9e85	20 78 80	jsr $8078		jsr	AssembleGroup1
>9e88	a1					.byte $a1
.9e89					Assemble_cmp:
.9e89	20 78 80	jsr $8078		jsr	AssembleGroup1
>9e8c	c1					.byte $c1
.9e8d					Assemble_sbc:
.9e8d	20 78 80	jsr $8078		jsr	AssembleGroup1
>9e90	e1					.byte $e1
.9e91					Assemble_asl:
.9e91	20 7f 80	jsr $807f		jsr	AssembleGroup2
>9e94	02					.byte $02
>9e95	75					.byte $75
.9e96					Assemble_rol:
.9e96	20 7f 80	jsr $807f		jsr	AssembleGroup2
>9e99	22					.byte $22
>9e9a	75					.byte $75
.9e9b					Assemble_lsr:
.9e9b	20 7f 80	jsr $807f		jsr	AssembleGroup2
>9e9e	42					.byte $42
>9e9f	75					.byte $75
.9ea0					Assemble_ror:
.9ea0	20 7f 80	jsr $807f		jsr	AssembleGroup2
>9ea3	62					.byte $62
>9ea4	75					.byte $75
.9ea5					Assemble_stx:
.9ea5	20 7f 80	jsr $807f		jsr	AssembleGroup2
>9ea8	82					.byte $82
>9ea9	50					.byte $50
.9eaa					Assemble_ldx:
.9eaa	20 7f 80	jsr $807f		jsr	AssembleGroup2
>9ead	a2					.byte $a2
>9eae	d0					.byte $d0
.9eaf					Assemble_dec:
.9eaf	20 7f 80	jsr $807f		jsr	AssembleGroup2
>9eb2	c2					.byte $c2
>9eb3	55					.byte $55
.9eb4					Assemble_inc:
.9eb4	20 7f 80	jsr $807f		jsr	AssembleGroup2
>9eb7	e2					.byte $e2
>9eb8	55					.byte $55
.9eb9					Assemble_stz:
.9eb9	20 7f 80	jsr $807f		jsr	AssembleGroup2
>9ebc	60					.byte $60
>9ebd	44					.byte $44
.9ebe					Assemble_bit:
.9ebe	20 7f 80	jsr $807f		jsr	AssembleGroup2
>9ec1	20					.byte $20
>9ec2	55					.byte $55
.9ec3					Assemble_sty:
.9ec3	20 7f 80	jsr $807f		jsr	AssembleGroup2
>9ec6	80					.byte $80
>9ec7	54					.byte $54
.9ec8					Assemble_ldy:
.9ec8	20 7f 80	jsr $807f		jsr	AssembleGroup2
>9ecb	a0					.byte $a0
>9ecc	d5					.byte $d5
.9ecd					Assemble_cpy:
.9ecd	20 7f 80	jsr $807f		jsr	AssembleGroup2
>9ed0	c0					.byte $c0
>9ed1	d4					.byte $d4
.9ed2					Assemble_cpx:
.9ed2	20 7f 80	jsr $807f		jsr	AssembleGroup2
>9ed5	e0					.byte $e0
>9ed6	d0					.byte $d0
.9ed7					Assemble_tsb:
.9ed7	20 7f 80	jsr $807f		jsr	AssembleGroup2
>9eda	00					.byte $00
>9edb	50					.byte $50
.9edc					Assemble_trb:
.9edc	20 7f 80	jsr $807f		jsr	AssembleGroup2
>9edf	10					.byte $10
>9ee0	50					.byte $50
.9ee1					Assemble_jsr:
.9ee1	20 7f 80	jsr $807f		jsr	AssembleGroup2
>9ee4	14					.byte $14
>9ee5	10					.byte $10
.9ee6					Assemble_jmp:
.9ee6	20 7f 80	jsr $807f		jsr	AssembleGroup2
>9ee9	40					.byte $40
>9eea	10					.byte $10
.9eeb					Assemble_bpl:
.9eeb	20 d0 80	jsr $80d0		jsr	AssembleGroup3
>9eee	10					.byte $10
.9eef					Assemble_bmi:
.9eef	20 d0 80	jsr $80d0		jsr	AssembleGroup3
>9ef2	30					.byte $30
.9ef3					Assemble_bvc:
.9ef3	20 d0 80	jsr $80d0		jsr	AssembleGroup3
>9ef6	50					.byte $50
.9ef7					Assemble_bvs:
.9ef7	20 d0 80	jsr $80d0		jsr	AssembleGroup3
>9efa	70					.byte $70
.9efb					Assemble_bcc:
.9efb	20 d0 80	jsr $80d0		jsr	AssembleGroup3
>9efe	90					.byte $90
.9eff					Assemble_bcs:
.9eff	20 d0 80	jsr $80d0		jsr	AssembleGroup3
>9f02	b0					.byte $b0
.9f03					Assemble_bne:
.9f03	20 d0 80	jsr $80d0		jsr	AssembleGroup3
>9f06	d0					.byte $d0
.9f07					Assemble_beq:
.9f07	20 d0 80	jsr $80d0		jsr	AssembleGroup3
>9f0a	f0					.byte $f0
.9f0b					Assemble_bra:
.9f0b	20 d0 80	jsr $80d0		jsr	AssembleGroup3
>9f0e	80					.byte $80
.9f0f					Assemble_brk:
.9f0f	20 04 81	jsr $8104		jsr	AssembleGroup4
>9f12	00					.byte $00
.9f13					Assemble_php:
.9f13	20 04 81	jsr $8104		jsr	AssembleGroup4
>9f16	08					.byte $08
.9f17					Assemble_clc:
.9f17	20 04 81	jsr $8104		jsr	AssembleGroup4
>9f1a	18					.byte $18
.9f1b					Assemble_plp:
.9f1b	20 04 81	jsr $8104		jsr	AssembleGroup4
>9f1e	28					.byte $28
.9f1f					Assemble_sec:
.9f1f	20 04 81	jsr $8104		jsr	AssembleGroup4
>9f22	38					.byte $38
.9f23					Assemble_rti:
.9f23	20 04 81	jsr $8104		jsr	AssembleGroup4
>9f26	40					.byte $40
.9f27					Assemble_pha:
.9f27	20 04 81	jsr $8104		jsr	AssembleGroup4
>9f2a	48					.byte $48
.9f2b					Assemble_cli:
.9f2b	20 04 81	jsr $8104		jsr	AssembleGroup4
>9f2e	58					.byte $58
.9f2f					Assemble_phy:
.9f2f	20 04 81	jsr $8104		jsr	AssembleGroup4
>9f32	5a					.byte $5a
.9f33					Assemble_rts:
.9f33	20 04 81	jsr $8104		jsr	AssembleGroup4
>9f36	60					.byte $60
.9f37					Assemble_pla:
.9f37	20 04 81	jsr $8104		jsr	AssembleGroup4
>9f3a	68					.byte $68
.9f3b					Assemble_sei:
.9f3b	20 04 81	jsr $8104		jsr	AssembleGroup4
>9f3e	78					.byte $78
.9f3f					Assemble_ply:
.9f3f	20 04 81	jsr $8104		jsr	AssembleGroup4
>9f42	7a					.byte $7a
.9f43					Assemble_dey:
.9f43	20 04 81	jsr $8104		jsr	AssembleGroup4
>9f46	88					.byte $88
.9f47					Assemble_txa:
.9f47	20 04 81	jsr $8104		jsr	AssembleGroup4
>9f4a	8a					.byte $8a
.9f4b					Assemble_tya:
.9f4b	20 04 81	jsr $8104		jsr	AssembleGroup4
>9f4e	98					.byte $98
.9f4f					Assemble_txs:
.9f4f	20 04 81	jsr $8104		jsr	AssembleGroup4
>9f52	9a					.byte $9a
.9f53					Assemble_tay:
.9f53	20 04 81	jsr $8104		jsr	AssembleGroup4
>9f56	a8					.byte $a8
.9f57					Assemble_tax:
.9f57	20 04 81	jsr $8104		jsr	AssembleGroup4
>9f5a	aa					.byte $aa
.9f5b					Assemble_clv:
.9f5b	20 04 81	jsr $8104		jsr	AssembleGroup4
>9f5e	b8					.byte $b8
.9f5f					Assemble_tsx:
.9f5f	20 04 81	jsr $8104		jsr	AssembleGroup4
>9f62	ba					.byte $ba
.9f63					Assemble_iny:
.9f63	20 04 81	jsr $8104		jsr	AssembleGroup4
>9f66	c8					.byte $c8
.9f67					Assemble_dex:
.9f67	20 04 81	jsr $8104		jsr	AssembleGroup4
>9f6a	ca					.byte $ca
.9f6b					Assemble_cld:
.9f6b	20 04 81	jsr $8104		jsr	AssembleGroup4
>9f6e	d8					.byte $d8
.9f6f					Assemble_phx:
.9f6f	20 04 81	jsr $8104		jsr	AssembleGroup4
>9f72	da					.byte $da
.9f73					Assemble_stp:
.9f73	20 04 81	jsr $8104		jsr	AssembleGroup4
>9f76	db					.byte $db
.9f77					Assemble_inx:
.9f77	20 04 81	jsr $8104		jsr	AssembleGroup4
>9f7a	e8					.byte $e8
.9f7b					Assemble_nop:
.9f7b	20 04 81	jsr $8104		jsr	AssembleGroup4
>9f7e	ea					.byte $ea
.9f7f					Assemble_sed:
.9f7f	20 04 81	jsr $8104		jsr	AssembleGroup4
>9f82	f8					.byte $f8
.9f83					Assemble_plx:
.9f83	20 04 81	jsr $8104		jsr	AssembleGroup4
>9f86	fa					.byte $fa

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/constants.asm

.9f87					DecimalScalarTable:
>9f87	66 66 66 66				.dword $66666666 ; 0.1
>9f8b	de					.byte $de
>9f8c	1f 85 eb 51				.dword $51eb851f ; 0.01
>9f90	db					.byte $db
>9f91	4c 37 89 41				.dword $4189374c ; 0.001
>9f95	d8					.byte $d8
>9f96	ac 8b db 68				.dword $68db8bac ; 0.0001
>9f9a	d4					.byte $d4
>9f9b	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>9f9f	d1					.byte $d1
>9fa0	83 de 1b 43				.dword $431bde83 ; 1e-06
>9fa4	ce					.byte $ce
>9fa5	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>9fa9	ca					.byte $ca
>9faa	89 3b e6 55				.dword $55e63b89 ; 1e-08
>9fae	c7					.byte $c7
>9faf	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>9fb3	c4					.byte $c4
>9fb4	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>9fb8	c0					.byte $c0
>9fb9	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>9fbd	bd					.byte $bd

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.asm

.9fbe					SyntaxError:
.9fbe	a9 02		lda #$02		lda	#2
.9fc0	4c 1e 8f	jmp $8f1e		jmp	ErrorHandler
.9fc3					RangeError:
.9fc3	a9 04		lda #$04		lda	#4
.9fc5	4c 1e 8f	jmp $8f1e		jmp	ErrorHandler
.9fc8					TypeError:
.9fc8	a9 05		lda #$05		lda	#5
.9fca	4c 1e 8f	jmp $8f1e		jmp	ErrorHandler
.9fcd					ArgumentError:
.9fcd	a9 07		lda #$07		lda	#7
.9fcf	4c 1e 8f	jmp $8f1e		jmp	ErrorHandler
.9fd2					NotDoneError:
.9fd2	a9 0c		lda #$0c		lda	#12
.9fd4	4c 1e 8f	jmp $8f1e		jmp	ErrorHandler
.9fd7					ErrorText:
>9fd7	42 72 65 61 6b 00			.text	"Break",0
>9fdd	53 79 6e 74 61 78 20 65			.text	"Syntax error",0
>9fe5	72 72 6f 72 00
>9fea	44 69 76 69 73 69 6f 6e			.text	"Division by zero",0
>9ff2	20 62 79 20 7a 65 72 6f 00
>9ffb	4f 75 74 20 6f 66 20 52			.text	"Out of Range",0
>a003	61 6e 67 65 00
>a008	54 79 70 65 20 6d 69 73			.text	"Type mismatch",0
>a010	6d 61 74 63 68 00
>a016	4f 75 74 20 6f 66 20 6d			.text	"Out of memory",0
>a01e	65 6d 6f 72 79 00
>a024	49 6c 6c 65 67 61 6c 20			.text	"Illegal argument",0
>a02c	61 72 67 75 6d 65 6e 74 00
>a035	53 74 6f 70 00				.text	"Stop",0
>a03a	53 74 72 69 6e 67 20 74			.text	"String too long",0
>a042	6f 6f 20 6c 6f 6e 67 00
>a04a	41 73 73 65 72 74 69 6f			.text	"Assertion failed",0
>a052	6e 20 66 61 69 6c 65 64 00
>a05b	4f 75 74 20 6f 66 20 64			.text	"Out of data",0
>a063	61 74 61 00
>a067	55 6e 69 6d 70 6c 65 6d			.text	"Unimplemented",0
>a06f	65 6e 74 65 64 00
>a075	4e 6f 20 73 75 63 68 20			.text	"No such line number",0
>a07d	6c 69 6e 65 20 6e 75 6d 62 65 72 00
>a089	52 65 74 75 72 6e 20 77			.text	"Return without Gosub",0
>a091	69 74 68 6f 75 74 20 47 6f 73 75 62 00
>a09e	55 6e 74 69 6c 20 77 69			.text	"Until without Repeat",0
>a0a6	74 68 6f 75 74 20 52 65 70 65 61 74 00
>a0b3	57 65 6e 64 20 77 69 74			.text	"Wend without While",0
>a0bb	68 6f 75 74 20 57 68 69 6c 65 00
>a0c6	4e 65 78 74 20 77 69 74			.text	"Next without For",0
>a0ce	68 6f 75 74 20 46 6f 72 00
>a0d7	42 41 53 49 43 20 53 74			.text	"BASIC Stack full",0
>a0df	61 63 6b 20 66 75 6c 6c 00
>a0e8	4f 70 65 6e 20 53 74 72			.text	"Open Structure",0
>a0f0	75 63 74 75 72 65 00
>a0f7	45 6e 64 50 72 6f 63 20			.text	"EndProc without call",0
>a0ff	77 69 74 68 6f 75 74 20 63 61 6c 6c 00
>a10c	41 72 72 61 79 20 61 6c			.text	"Array already defined",0
>a114	72 65 61 64 79 20 64 65 66 69 6e 65 64 00
>a122	41 72 72 61 79 20 73 69			.text	"Array size",0
>a12a	7a 65 00
>a12d	42 61 64 20 61 72 72 61			.text	"Bad array index",0
>a135	79 20 69 6e 64 65 78 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/timestamp.asm

>a13d	52 65 6c 65 61 73 65 20			.text "Release Alpha 11 (05-Dec-22). "
>a145	41 6c 70 68 61 20 31 31 20 28 30 35 2d 44 65 63
>a155	2d 32 32 29 2e 20

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcommand.asm

.a15b					RectangleCommand:
.a15b	a9 44		lda #$44			lda 	#GCMD_FrameRect				; frame rectangle
.a15d	80 02		bra $a161			bra 	ShapeDrawCmd
.a15f					CircleCommand:
.a15f	a9 48		lda #$48			lda 	#GCMD_FrameCircle 				; framed circle
.a161					ShapeDrawCmd:
.a161	20 eb a1	jsr $a1eb			jsr 	RunGraphicsCommand
.a164					ShapeDraw:
.a164	0d 5d 06	ora $065d			ora 	gxFillSolid  				; adjust AXY for solid fill.
.a167	4c df a1	jmp $a1df			jmp 	ExecuteGraphicCommand	 	; and complete
.a16a					SpriteCommand:
.a16a	a2 00		ldx #$00			ldx 	#0
.a16c	20 db 9d	jsr $9ddb			jsr 	Evaluate8BitInteger 		; get image number.
.a16f	5a		phy				phy
.a170	a9 0e		lda #$0e			lda 	#GCMD_SpriteUse 			; use that image.
.a172	a6 58		ldx $58				ldx 	NSMantissa0
.a174	e0 40		cpx #$40			cpx 	#64 						; 0-63 only
.a176	b0 0d		bcs $a185			bcs 	_SCRange
.a178	a0 ff		ldy #$ff			ldy 	#255
.a17a	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a17d	a9 52		lda #$52			lda 	#GCMD_SpriteMove
.a17f	7a		ply				ply
.a180	20 eb a1	jsr $a1eb			jsr 	RunGraphicsCommand
.a183	80 5a		bra $a1df			bra 	ExecuteGraphicCommand
.a185					_SCRange:
.a185	4c c3 9f	jmp $9fc3			jmp 	RangeError
.a188					ImageCommand:
.a188	a2 00		ldx #$00			ldx 	#0
.a18a	20 db 9d	jsr $9ddb			jsr 	Evaluate8BitInteger 		; get image number.
.a18d	20 eb a1	jsr $a1eb			jsr 	RunGraphicsCommand
.a190					ImageRunDraw:
.a190	09 40		ora #$40			ora 	#GCMD_Move					; move cursor
.a192	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a195	ad 63 06	lda $0663			lda 	gxDrawScale
.a198	0a		asl a				asl 	a
.a199	0a		asl a				asl 	a
.a19a	0a		asl a				asl 	a
.a19b	a8		tay				tay
.a19c	a9 0c		lda #$0c			lda 	#GCMD_DrawSprite 			; image drawing
.a19e	a6 58		ldx $58				ldx 	NSMantissa0
.a1a0	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a1a3	60		rts				rts
.a1a4					TextCommand:
.a1a4	a2 00		ldx #$00			ldx 	#0
.a1a6	20 98 9d	jsr $9d98			jsr 	EvaluateString 				; get text
.a1a9	20 eb a1	jsr $a1eb			jsr 	RunGraphicsCommand
.a1ac					TextRunDraw:
.a1ac	09 40		ora #$40			ora 	#GCMD_Move 					; move cursor
.a1ae	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a1b1	a0 00		ldy #$00			ldy 	#0
.a1b3					_IRDLoop:
.a1b3	a5 60		lda $60				lda 	NSMantissa1 				; access character
.a1b5	85 37		sta $37				sta 	zTemp0+1
.a1b7	a5 58		lda $58				lda 	NSMantissa0
.a1b9	85 36		sta $36				sta 	zTemp0
.a1bb	b1 36		lda ($36),y			lda 	(zTemp0),y
.a1bd	f0 13		beq $a1d2			beq 	_IRDExit
.a1bf	5a		phy				phy									; save string pos
.a1c0	48		pha				pha 								; save char
.a1c1	ad 63 06	lda $0663			lda 	gxDrawScale 				; get scale
.a1c4	0a		asl a				asl 	a
.a1c5	0a		asl a				asl 	a
.a1c6	0a		asl a				asl 	a
.a1c7	a8		tay				tay
.a1c8	a9 0a		lda #$0a			lda 	#GCMD_DrawFont 				; char drawing
.a1ca	fa		plx				plx 								; char to draw
.a1cb	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a1ce	7a		ply				ply 								; restore string pos
.a1cf	c8		iny				iny
.a1d0	90 e1		bcc $a1b3			bcc 	_IRDLoop 					; go back if no error.
.a1d2					_IRDExit:
.a1d2	60		rts				rts
.a1d3					PlotCommand:
.a1d3	a9 50		lda #$50			lda 	#GCMD_Plot 					; command ID to use
.a1d5	20 eb a1	jsr $a1eb			jsr 	RunGraphicsCommand
.a1d8	80 05		bra $a1df			bra 	ExecuteGraphicCommand
.a1da					LineCommand:
.a1da	a9 42		lda #$42			lda 	#GCMD_Line 						; command ID to use
.a1dc	20 eb a1	jsr $a1eb			jsr 	RunGraphicsCommand
.a1df					ExecuteGraphicCommand:
.a1df	0d 5c 06	ora $065c			ora 	gxCommandID 				; make a full command
.a1e2	20 15 80	jsr $8015			jsr 	GXGraphicDraw 				; draw it and exit
.a1e5	b0 01		bcs $a1e8			bcs 	_EGCError
.a1e7	60		rts				rts
.a1e8					_EGCError:
.a1e8	4c be 9f	jmp $9fbe			jmp 	SyntaxError
.a1eb					RunGraphicsCommand:
.a1eb	8d 5c 06	sta $065c			sta 	gxCommandID					; save TODO graphics command.
.a1ee	68		pla				pla 								; pop handler address
.a1ef	fa		plx				plx
.a1f0	1a		inc a				inc 	a
.a1f1	d0 01		bne $a1f4			bne 	_RGINoCarry
.a1f3	e8		inx				inx
.a1f4					_RGINoCarry:
.a1f4	8d 61 06	sta $0661			sta 	GXHandler
.a1f7	8e 62 06	stx $0662			stx 	GXHandler+1
.a1fa					_RGICommandLoop:
.a1fa	b1 30		lda ($30),y			lda 	(codePtr),y
.a1fc	c8		iny				iny
.a1fd	c9 d2		cmp #$d2			cmp 	#KWD_TO						; is it TO x,y
.a1ff	f0 53		beq $a254			beq 	_RGI_To
.a201	c9 bd		cmp #$bd			cmp 	#KWD_HERE 					; do it here.
.a203	f0 55		beq $a25a			beq 	_RGI_Here
.a205	c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL or : , exit
.a207	f0 3d		beq $a246			beq 	_RGI_Exit
.a209	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.a20b	f0 39		beq $a246			beq 	_RGI_Exit
.a20d	c9 c5		cmp #$c5			cmp 	#KWD_OUTLINE 				; solid or outline
.a20f	f0 3e		beq $a24f			beq 	_RGI_Frame
.a211	c9 ce		cmp #$ce			cmp 	#KWD_SOLID
.a213	f0 33		beq $a248			beq 	_RGI_Solid
.a215	c9 ad		cmp #$ad			cmp 	#KWD_BY 					; by offset
.a217	f0 4b		beq $a264			beq 	_RGI_By
.a219	c9 b9		cmp #$b9			cmp 	#KWD_FROM 					; from
.a21b	f0 17		beq $a234			beq 	_RGI_Move2
.a21d	c9 b5		cmp #$b5			cmp 	#KWD_DIM 					; dim (set scale)
.a21f	f0 62		beq $a283			beq 	_RGI_Dim
.a221	c9 b3		cmp #$b3			cmp 	#KWD_COLOUR 				; colour or Color
.a223	f0 74		beq $a299			beq 	_RGI_Colour
.a225	c9 b2		cmp #$b2			cmp 	#KWD_COLOR
.a227	f0 70		beq $a299			beq 	_RGI_Colour
.a229	ae 5c 06	ldx $065c			ldx 	gxCommandID
.a22c	e0 52		cpx #$52			cpx 	#GCMD_SpriteMove 			; if not sprite
.a22e	d0 03		bne $a233			bne 	_RGI_Move 					; move
.a230	4c c1 a2	jmp $a2c1			jmp		_RGI_SpriteInstructions
.a233					_RGI_Move:
.a233	88		dey				dey 								; unpick get.
.a234					_RGI_Move2:
.a234	20 e7 a2	jsr $a2e7			jsr 	GCGetCoordinatePair 		; move to here
.a237	20 0e a3	jsr $a30e			jsr 	GCCopyPairToStore 			; save
.a23a	5a		phy				phy
.a23b	20 04 a3	jsr $a304			jsr 	GCLoadAXY 					; load in
.a23e	09 40		ora #$40			ora 	#GCMD_Move 					; move there
.a240	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a243	7a		ply				ply
.a244	80 b4		bra $a1fa			bra 	_RGICommandLoop 			; and go round
.a246					_RGI_Exit:
.a246	88		dey				dey 								; unpick : / EOL
.a247	60		rts				rts
.a248					_RGI_Solid:
.a248	a9 02		lda #$02			lda 	#2
.a24a	8d 5d 06	sta $065d			sta 	gxFillSolid
.a24d	80 ab		bra $a1fa			bra 	_RGICommandLoop
.a24f					_RGI_Frame:
.a24f	9c 5d 06	stz $065d			stz 	gxFillSolid
.a252	80 a6		bra $a1fa			bra 	_RGICommandLoop
.a254					_RGI_To:
.a254	20 e7 a2	jsr $a2e7			jsr 	GCGetCoordinatePair 		; get coordinate pair into slot #1,#2
.a257	20 0e a3	jsr $a30e			jsr 	GCCopyPairToStore
.a25a					_RGI_Here:
.a25a	5a		phy				phy
.a25b	20 04 a3	jsr $a304			jsr 	GCLoadAXY 					; load it into AXY
.a25e	20 be a2	jsr $a2be			jsr 	_RGICallHandler 			; go do whatever it is.
.a261	7a		ply				ply
.a262	80 96		bra $a1fa			bra 	_RGICommandLoop 			; and go round
.a264					_RGI_By:
.a264	20 f4 a2	jsr $a2f4			jsr 	GCSignedCoordinatePair 		; get coordinate pair into slot #1,#2
.a267	18		clc				clc
.a268	a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.a26a	6d 5e 06	adc $065e			adc 	gxxPos
.a26d	8d 5e 06	sta $065e			sta 	gxXPos
.a270	a5 61		lda $61				lda 	NSMantissa1+1
.a272	6d 5f 06	adc $065f			adc 	gxxPos+1
.a275	8d 5f 06	sta $065f			sta 	gxXPos+1
.a278	a5 5a		lda $5a				lda 	NSMantissa0+2
.a27a	18		clc				clc
.a27b	6d 60 06	adc $0660			adc 	gxYPos
.a27e	8d 60 06	sta $0660			sta 	gxYPos
.a281	80 d7		bra $a25a			bra 	_RGI_Here
.a283					_RGI_Dim:
.a283	a2 01		ldx #$01			ldx	 	#1
.a285	20 db 9d	jsr $9ddb			jsr 	Evaluate8BitInteger
.a288	a5 59		lda $59				lda 	NSMantissa0+1
.a28a	c9 00		cmp #$00			cmp 	#0
.a28c	f0 2d		beq $a2bb			beq 	_RGIRange
.a28e	c9 09		cmp #$09			cmp 	#8+1
.a290	b0 29		bcs $a2bb			bcs		_RGIRange
.a292	3a		dec a				dec 	a
.a293	8d 63 06	sta $0663			sta 	gxDrawScale
.a296	4c fa a1	jmp $a1fa			jmp 	_RGICommandLoop
.a299					_RGI_Colour:
.a299	a2 01		ldx #$01			ldx 	#1 							; colour
.a29b	20 db 9d	jsr $9ddb			jsr 	Evaluate8BitInteger
.a29e	a2 02		ldx #$02			ldx 	#2 							; default zero for 2nd parameter
.a2a0	20 40 9e	jsr $9e40			jsr 	NSMSetZero
.a2a3	b1 30		lda ($30),y			lda 	(codePtr),y
.a2a5	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; check , => mode.
.a2a7	d0 04		bne $a2ad			bne 	_RGICDefaultMode
.a2a9	c8		iny				iny
.a2aa	20 db 9d	jsr $9ddb			jsr 	Evaluate8BitInteger
.a2ad					_RGICDefaultMode:
.a2ad	5a		phy				phy
.a2ae	a9 08		lda #$08			lda 	#GCMD_Colour 				; set colour.
.a2b0	a6 59		ldx $59				ldx 	NSMantissa0+1
.a2b2	a4 5a		ldy $5a				ldy 	NSMantissa0+2
.a2b4	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a2b7	7a		ply				ply
.a2b8	4c fa a1	jmp $a1fa			jmp 	_RGICommandLoop 			; and go round
.a2bb					_RGIRange:
.a2bb	4c c3 9f	jmp $9fc3			jmp 	RangeError
.a2be					_RGICallHandler:
.a2be	6c 61 06	jmp ($0661)			jmp 	(GXHandler)
.a2c1					_RGI_SpriteInstructions:
.a2c1	c9 c3		cmp #$c3			cmp 	#KWD_OFF
.a2c3	f0 07		beq $a2cc			beq 	_RGISpriteOff
.a2c5	c9 be		cmp #$be			cmp 	#KWD_IMAGE
.a2c7	f0 13		beq $a2dc			beq 	_RGISetImage
.a2c9	4c 33 a2	jmp $a233			jmp 	_RGI_Move
.a2cc					_RGISpriteOff:
.a2cc	5a		phy				phy
.a2cd	a0 01		ldy #$01			ldy 	#1
.a2cf	a2 00		ldx #$00			ldx 	#0
.a2d1					_RGIDoCommandLoop:
.a2d1	a9 10		lda #$10			lda 	#GCMD_SpriteImage
.a2d3	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a2d6	7a		ply				ply
.a2d7	b0 e2		bcs $a2bb			bcs 	_RGIRange
.a2d9	4c fa a1	jmp $a1fa			jmp 	_RGICommandLoop
.a2dc					_RGISetImage:
.a2dc	a2 01		ldx #$01			ldx 	#1
.a2de	20 db 9d	jsr $9ddb			jsr 	Evaluate8BitInteger
.a2e1	5a		phy				phy
.a2e2	aa		tax				tax
.a2e3	a0 00		ldy #$00			ldy 	#0
.a2e5	80 ea		bra $a2d1			bra 	_RGIDoCommandLoop
.a2e7					GCGetCoordinatePair:
.a2e7	a2 01		ldx #$01			ldx 	#1
.a2e9	20 c0 9d	jsr $9dc0			jsr 	Evaluate16BitInteger
.a2ec	20 0d 8f	jsr $8f0d			jsr 	CheckComma
.a2ef	e8		inx				inx
.a2f0	20 c0 9d	jsr $9dc0			jsr 	Evaluate16BitInteger
.a2f3	60		rts				rts
.a2f4					GCSignedCoordinatePair:
.a2f4	a2 01		ldx #$01			ldx 	#1
.a2f6	20 ca 9d	jsr $9dca			jsr 	Evaluate16BitIntegerSigned
.a2f9	20 0d 8f	jsr $8f0d			jsr 	CheckComma
.a2fc	e8		inx				inx
.a2fd	20 ca 9d	jsr $9dca			jsr 	Evaluate16BitIntegerSigned
.a300	60		rts				rts
.a301					_GCCPRange:
.a301	4c c3 9f	jmp $9fc3			jmp 	RangeError
.a304					GCLoadAXY:
.a304	ad 5f 06	lda $065f			lda 	gxXPos+1
.a307	ae 5e 06	ldx $065e			ldx 	gxXPos
.a30a	ac 60 06	ldy $0660			ldy 	gxYPos
.a30d	60		rts				rts
.a30e					GCCopyPairToStore:
.a30e	a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.a310	8d 5e 06	sta $065e			sta 	gxXPos
.a313	a5 61		lda $61				lda 	NSMantissa1+1
.a315	8d 5f 06	sta $065f			sta 	gxXPos+1
.a318	a5 5a		lda $5a				lda 	NSMantissa0+2
.a31a	8d 60 06	sta $0660			sta 	gxYPos
.a31d	60		rts				rts
.065c					gxCommandID:
>065c							.fill 	1
.065d					gxFillSolid:
>065d							.fill 	1
.065e					gxXPos:
>065e							.fill 	2
.0660					gxYPos:
>0660							.fill 	1
.0661					gxHandler:
>0661							.fill 	2
.0663					gxDrawScale:
>0663							.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcontrol.asm

.a31e					BitmapCtrl:
.a31e	b1 30		lda ($30),y			lda 	(codePtr),y
.a320	c8		iny				iny
.a321	a2 01		ldx #$01			ldx 	#1
.a323	c9 c4		cmp #$c4			cmp 	#KWD_ON
.a325	f0 11		beq $a338			beq 	BitmapSwitch
.a327	ca		dex				dex
.a328	c9 c3		cmp #$c3			cmp 	#KWD_OFF
.a32a	f0 0c		beq $a338			beq 	BitmapSwitch
.a32c	20 db 9d	jsr $9ddb			jsr 	Evaluate8BitInteger 		; get the colour
.a32f	5a		phy				phy
.a330	aa		tax				tax
.a331	a9 06		lda #$06			lda 	#GCMD_Clear					; clear to that colour
.a333	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a336	7a		ply				ply
.a337	60		rts				rts
.a338					BitmapSwitch:
.a338	5a		phy				phy
.a339	a0 00		ldy #$00			ldy 	#0 							; gfx 1,on/off,0
.a33b	a9 02		lda #$02			lda 	#GCMD_BitmapCtl
.a33d	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a340	a9 08		lda #$08			lda 	#GCMD_Colour				; set colour to $FF
.a342	a0 00		ldy #$00			ldy 	#0
.a344	a2 ff		ldx #$ff			ldx 	#$FF
.a346	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a349	9c 5d 06	stz $065d			stz 	gxFillSolid
.a34c	9c 5e 06	stz $065e			stz 	gxXPos
.a34f	9c 5f 06	stz $065f			stz 	gxXPos+1
.a352	9c 60 06	stz $0660			stz 	gxYPos
.a355	9c 63 06	stz $0663			stz 	gxDrawScale
.a358	a9 40		lda #$40			lda 	#GCMD_Move 						; home cursor
.a35a	a2 00		ldx #$00			ldx 	#0
.a35c	a0 00		ldy #$00			ldy 	#0
.a35e	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a361	7a		ply				ply
.a362	60		rts				rts
.a363					SpritesCtrl:
.a363	b1 30		lda ($30),y			lda 	(codePtr),y
.a365	c8		iny				iny
.a366	a2 01		ldx #$01			ldx 	#1
.a368	c9 c4		cmp #$c4			cmp 	#KWD_ON
.a36a	f0 08		beq $a374			beq 	SpriteSwitch
.a36c	ca		dex				dex
.a36d	c9 c3		cmp #$c3			cmp 	#KWD_OFF
.a36f	f0 03		beq $a374			beq 	SpriteSwitch
.a371	4c be 9f	jmp $9fbe			jmp 	SyntaxError
.a374					SpriteSwitch:
.a374	5a		phy				phy
.a375	a0 00		ldy #$00			ldy 	#0 							; gfx 2,on/off,0
.a377	a9 04		lda #$04			lda 	#GCMD_SpriteCtl
.a379	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a37c	7a		ply				ply
.a37d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gfx.asm

.a37e					GfxCommand:
.a37e	a2 00		ldx #$00			ldx 	#0
.a380	20 db 9d	jsr $9ddb			jsr 	Evaluate8BitInteger 		; command
.a383	20 0d 8f	jsr $8f0d			jsr 	CheckComma
.a386	e8		inx				inx
.a387	20 c0 9d	jsr $9dc0			jsr 	Evaluate16BitInteger 		; X
.a38a	20 0d 8f	jsr $8f0d			jsr 	CheckComma
.a38d	e8		inx				inx
.a38e	20 db 9d	jsr $9ddb			jsr 	Evaluate8BitInteger 		; Y
.a391	a5 61		lda $61				lda 	NSMantissa1+1  				; shift bit 0 of X into CS, should now be zero
.a393	4a		lsr a				lsr 	a
.a394	d0 12		bne $a3a8			bne 	_GfxError
.a396	26 58		rol $58				rol 	NSMantissa0 				; rotate into command
.a398	b0 0e		bcs $a3a8			bcs 	_GfxError 					; bit 7 should have been zero
.a39a	5a		phy				phy 								; save pos
.a39b	a5 58		lda $58				lda 	NSMantissa0 				; do the command
.a39d	a6 59		ldx $59				ldx 	NSMantissa0+1
.a39f	a4 5a		ldy $5a				ldy 	NSMantissa0+2
.a3a1	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a3a4	b0 02		bcs $a3a8			bcs 	_GfxError
.a3a6	7a		ply				ply 								; restore pos and exit.
.a3a7	60		rts				rts
.a3a8					_GfxError:
.a3a8	4c c3 9f	jmp $9fc3			jmp 	RangeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/hit.asm

.a3ab					UnaryHit:
.a3ab	fa		plx				plx
.a3ac	a9 36		lda #$36			lda 	#zTemp0
.a3ae	20 db 9d	jsr $9ddb			jsr 	Evaluate8BitInteger 		; get sprite number 0
.a3b1	20 0d 8f	jsr $8f0d			jsr 	CheckComma
.a3b4	e8		inx				inx
.a3b5	20 db 9d	jsr $9ddb			jsr 	Evaluate8BitInteger 		; get sprite number 1
.a3b8	20 05 8f	jsr $8f05			jsr		CheckRightBracket
.a3bb	ca		dex				dex 								; fix back up again.
.a3bc	da		phx				phx 								; save X/Y
.a3bd	5a		phy				phy
.a3be	b4 59		ldy $59,x			ldy 	NSMantissa0+1,x 			; get the sprite numbers into X/Y
.a3c0	b5 58		lda $58,x			lda 	NSMantissa0,x
.a3c2	aa		tax				tax
.a3c3	a9 12		lda #$12			lda 	#GCMD_SpriteCollide 		; command check collision.
.a3c5	20 15 80	jsr $8015			jsr 	GXGraphicDraw 				; calculate result
.a3c8	1a		inc a				inc 	a 							; so 255 (fail) -> 0, otherwise 1,2,3,4 pixels etc.
.a3c9	7a		ply				ply 								; restore XY
.a3ca	fa		plx				plx
.a3cb	20 42 9e	jsr $9e42			jsr 	NSMSetByte 					; return the hit result
.a3ce	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/palette.asm

.a3cf					PaletteCommand:
.a3cf	a2 00		ldx #$00			ldx 	#0
.a3d1	20 db 9d	jsr $9ddb			jsr 	Evaluate8BitInteger 		; colour
.a3d4	20 0d 8f	jsr $8f0d			jsr 	CheckComma
.a3d7	e8		inx				inx
.a3d8	20 c0 9d	jsr $9dc0			jsr 	Evaluate16BitInteger 		; r
.a3db	20 0d 8f	jsr $8f0d			jsr 	CheckComma
.a3de	e8		inx				inx
.a3df	20 db 9d	jsr $9ddb			jsr 	Evaluate8BitInteger 		; g
.a3e2	20 0d 8f	jsr $8f0d			jsr 	CheckComma
.a3e5	e8		inx				inx
.a3e6	20 db 9d	jsr $9ddb			jsr 	Evaluate8BitInteger 		; b
.a3e9	a5 58		lda $58				lda 	NSMantissa0 				; get colour #
.a3eb	85 36		sta $36				sta 	zTemp0
.a3ed	a9 34		lda #$34			lda 	#$D0 >> 2 					; MSB = D0/4
.a3ef	85 37		sta $37				sta 	zTemp0+1
.a3f1	06 36		asl $36				asl 	zTemp0 						; zTemp = $D000+Colour x 4
.a3f3	26 37		rol $37				rol	 	zTemp0+1
.a3f5	06 36		asl $36				asl 	zTemp0
.a3f7	26 37		rol $37				rol	 	zTemp0+1
.a3f9	a9 01		lda #$01			lda 	#1 							; I/O Page 2
.a3fb	85 01		sta $01				sta 	1
.a3fd	5a		phy				phy
.a3fe	a5 5b		lda $5b				lda 	NSMantissa0+3 				; fix to r,g,b
.a400	92 36		sta ($36)			sta 	(zTemp0)
.a402	a0 01		ldy #$01			ldy 	#1
.a404	a5 5a		lda $5a				lda 	NSMantissa0+2
.a406	91 36		sta ($36),y			sta 	(zTemp0),y
.a408	a5 59		lda $59				lda 	NSMantissa0+1
.a40a	c8		iny				iny
.a40b	91 36		sta ($36),y			sta 	(zTemp0),y
.a40d	7a		ply				ply
.a40e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/event.asm

.a40f					UnaryEvent:
.a40f	fa		plx				plx
.a410	20 bd a4	jsr $a4bd			jsr 	TimerToStackX 				; timer in +0
.a413	e8		inx				inx  								; put reference into +1
.a414	20 6c 98	jsr $986c			jsr 	EvaluateTerm
.a417	b5 50		lda $50,x			lda 	NSStatus,x 					; check if is integer reference
.a419	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.a41b	d0 4c		bne $a469			bne 	_UEType
.a41d	e8		inx				inx 								; put the step in +2
.a41e	20 0d 8f	jsr $8f0d			jsr 	CheckComma
.a421	20 c0 9d	jsr $9dc0			jsr 	Evaluate16BitInteger
.a424	20 05 8f	jsr $8f05			jsr 	CheckRightBracket
.a427	ca		dex				dex
.a428	ca		dex				dex
.a429	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy reference to zTemp0
.a42b	85 36		sta $36				sta 	zTemp0
.a42d	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.a42f	85 37		sta $37				sta 	zTemp0+1
.a431	5a		phy				phy
.a432	a0 03		ldy #$03			ldy 	#3 							; check bit 7 of last bit, the packed sign bit
.a434	b1 36		lda ($36),y			lda 	(zTemp0),y
.a436	30 2d		bmi $a465			bmi 	_UEFalse 					; exit if signed.
.a438	a0 00		ldy #$00			ldy 	#0 							; has it timed out (24 bit)
.a43a	b5 58		lda $58,x			lda 	NSMantissa0,x
.a43c	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.a43e	c8		iny				iny
.a43f	b5 60		lda $60,x			lda 	NSMantissa1,x
.a441	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a443	c8		iny				iny
.a444	b5 68		lda $68,x			lda 	NSMantissa2,x
.a446	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a448	90 1b		bcc $a465			bcc 	_UEFalse 					; no, return FALSE.
.a44a	18		clc				clc
.a44b	a0 00		ldy #$00			ldy 	#0 							; work out new value as timer() + step
.a44d	b5 58		lda $58,x			lda 	NSMantissa0,x
.a44f	75 5a		adc $5a,x			adc 	NSMantissa0+2,x
.a451	91 36		sta ($36),y			sta 	(zTemp0),y
.a453	c8		iny				iny
.a454	b5 60		lda $60,x			lda 	NSMantissa1,x
.a456	75 62		adc $62,x			adc 	NSMantissa1+2,x
.a458	91 36		sta ($36),y			sta 	(zTemp0),y
.a45a	c8		iny				iny
.a45b	b5 68		lda $68,x			lda 	NSMantissa2,x
.a45d	75 6a		adc $6a,x			adc 	NSMantissa2+2,x
.a45f	91 36		sta ($36),y			sta 	(zTemp0),y
.a461	7a		ply				ply
.a462	4c 8b 8f	jmp $8f8b			jmp 	ReturnTrue
.a465					_UEFalse:
.a465	7a		ply				ply 								; restore Y
.a466	4c 96 8f	jmp $8f96			jmp 	ReturnFalse 				; and return False
.a469					_UEType:
.a469	4c c8 9f	jmp $9fc8			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/joy.asm

.a46c					UnaryJoyX:
.a46c	18		clc				clc
.a46d	80 01		bra $a470			bra 	JoyMain
.a46f					UnaryJoyY:
.a46f	38		sec				sec
.a470					JoyMain:
.a470	fa		plx				plx 								; get pos
.a471	08		php				php 								; save carry (set for Y)
.a472	20 db 9d	jsr $9ddb			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a475	20 05 8f	jsr $8f05			jsr 	CheckRightBracket
.a478	20 0f 80	jsr $800f			jsr 	EXTReadController 			; read the controller.
.a47b	28		plp				plp
.a47c	90 02		bcc $a480			bcc 	_JMNoShift 					; if Y then shift bits 3,2 -> 1,0
.a47e	4a		lsr a				lsr 	a
.a47f	4a		lsr a				lsr 	a
.a480					_JMNoShift:
.a480	4a		lsr a				lsr 	a 							; if bit 0 set then right/down e.g. +1
.a481	b0 0a		bcs $a48d			bcs 	_JMIsRight
.a483	4a		lsr a				lsr 	a 							; if bit 1 set then left/up e.g. -1
.a484	b0 04		bcs $a48a			bcs 	_JMIsLeft
.a486	20 40 9e	jsr $9e40			jsr 	NSMSetZero 					; zero result
.a489	60		rts				rts
.a48a					_JMIsLeft:
.a48a	4c 8b 8f	jmp $8f8b			jmp 	ReturnTrue
.a48d					_JMIsRight:
.a48d	a9 01		lda #$01			lda 	#1
.a48f	20 42 9e	jsr $9e42			jsr 	NSMSetByte
.a492	60		rts				rts
.a493					UnaryJoyB:
.a493	fa		plx				plx 								; get pos
.a494	20 db 9d	jsr $9ddb			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a497	20 05 8f	jsr $8f05			jsr 	CheckRightBracket
.a49a	20 0f 80	jsr $800f			jsr 	EXTReadController 			; read the controller.
.a49d	4a		lsr a				lsr 	a
.a49e	4a		lsr a				lsr 	a
.a49f	4a		lsr a				lsr 	a
.a4a0	4a		lsr a				lsr 	a
.a4a1	29 01		and #$01			and 	#1
.a4a3	20 42 9e	jsr $9e42			jsr 	NSMSetByte
.a4a6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/load.asm

.a4a7					LoadCommand:
.a4a7	20 ee 89	jsr $89ee			jsr 	NewProgram
.a4aa	20 e7 82	jsr $82e7			jsr 	BackLoadProgram
.a4ad	4c 97 83	jmp $8397			jmp 	WarmStart
.a4b0					GoCommand:
.a4b0	20 ee 89	jsr $89ee			jsr 	NewProgram
.a4b3	20 e7 82	jsr $82e7			jsr 	BackLoadProgram
.a4b6	4c 2f 8b	jmp $8b2f			jmp 	CommandRun

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/timer.asm

.a4b9					UnaryTimer:
.a4b9	fa		plx				plx
.a4ba	20 05 8f	jsr $8f05			jsr 	CheckRightBracket
.a4bd					TimerToStackX:
.a4bd	20 40 9e	jsr $9e40			jsr 	NSMSetZero 					; zero result
.a4c0	64 01		stz $01				stz 	1 							; access I/O
.a4c2	ad 59 d6	lda $d659			lda 	$D659 						; copy timer in
.a4c5	95 58		sta $58,x			sta 	NSMantissa0,x
.a4c7	ad 5a d6	lda $d65a			lda 	$D65A
.a4ca	95 60		sta $60,x			sta 	NSMantissa1,x
.a4cc	ad 5b d6	lda $d65b			lda 	$D65B
.a4cf	95 68		sta $68,x			sta 	NSMantissa2,x
.a4d1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/delete.asm

.a4d2					MemoryDeleteLine:
.a4d2	20 f1 a4	jsr $a4f1			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a4d5	b2 30		lda ($30)			lda 	(codePtr) 					; size to delete => y
.a4d7	a8		tay				tay
.a4d8					_MDDLLoop:
.a4d8	b1 30		lda ($30),y			lda 	(codePtr),y 				; copy down
.a4da	92 30		sta ($30)			sta 	(codePtr)
.a4dc	a5 30		lda $30				lda 	codePtr 					; check done the lot.
.a4de	c5 3a		cmp $3a				cmp 	zTemp2
.a4e0	d0 07		bne $a4e9			bne 	_MDLDLNext
.a4e2	a5 31		lda $31				lda 	codePtr+1
.a4e4	c5 3b		cmp $3b				cmp 	zTemp2+1
.a4e6	d0 01		bne $a4e9			bne 	_MDLDLNext
.a4e8					_MDDLExit:
.a4e8	60		rts				rts
.a4e9					_MDLDLNext:
.a4e9	e6 30		inc $30				inc 	codePtr						; next byte
.a4eb	d0 eb		bne $a4d8			bne 	_MDDLLoop
.a4ed	e6 31		inc $31				inc 	codePtr+1
.a4ef	80 e7		bra $a4d8			bra 	_MDDLLoop
.a4f1					IMemoryFindEnd:
.a4f1	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a4f3	85 3a		sta $3a				sta 	0+zTemp2
.a4f5	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a4f7	85 3b		sta $3b				sta 	1+zTemp2
.a4f9					_MDLFELoop:
.a4f9	b2 3a		lda ($3a)			lda 	(zTemp2)
.a4fb	f0 0b		beq $a508			beq 	_MDLFEExit
.a4fd	18		clc				clc
.a4fe	65 3a		adc $3a				adc 	zTemp2
.a500	85 3a		sta $3a				sta 	zTemp2
.a502	90 f5		bcc $a4f9			bcc 	_MDLFELoop
.a504	e6 3b		inc $3b				inc 	zTemp2+1
.a506	80 f1		bra $a4f9			bra 	_MDLFELoop
.a508					_MDLFEExit:
.a508	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/insert.asm

.a509					MemoryInsertLine:
.a509	08		php				php
.a50a	20 f1 a4	jsr $a4f1			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a50d	a5 3b		lda $3b				lda 	zTemp2+1 					; space ?
.a50f	1a		inc a				inc 	a
.a510	c9 7f		cmp #$7f			cmp 	#(BasicEnd >> 8)-1
.a512	b0 36		bcs $a54a			bcs 	_MDLIError
.a514	28		plp				plp
.a515	90 08		bcc $a51f			bcc 	_MDLIFound
.a517	a5 3a		lda $3a				lda 	zTemp2 						; if CS on entry append.
.a519	85 30		sta $30				sta 	codePtr
.a51b	a5 3b		lda $3b				lda 	zTemp2+1
.a51d	85 31		sta $31				sta 	codePtr+1
.a51f					_MDLIFound:
.a51f	ad 2a 04	lda $042a			lda 	tokenOffset 				; insert gap in Y, the offset, e.g. length of the new line
.a522	a8		tay				tay
.a523					_MDLIInsert:
.a523	b2 3a		lda ($3a)			lda 	(zTemp2) 					; shift one byte up , at least one covers end case.
.a525	91 3a		sta ($3a),y			sta 	(zTemp2),y 					; work from top down.
.a527	a5 30		lda $30				lda 	codePtr 					; done insert point ?
.a529	c5 3a		cmp $3a				cmp 	zTemp2
.a52b	d0 06		bne $a533			bne 	_MDLINext
.a52d	a5 31		lda $31				lda 	codePtr+1
.a52f	c5 3b		cmp $3b				cmp 	zTemp2+1
.a531	f0 0a		beq $a53d			beq 	_MDLIHaveSpace
.a533					_MDLINext:
.a533	a5 3a		lda $3a				lda 	zTemp2 						; if no, keep zTemp2 going backwards
.a535	d0 02		bne $a539			bne 	_MDLINoBorrow
.a537	c6 3b		dec $3b				dec 	zTemp2+1
.a539					_MDLINoBorrow:
.a539	c6 3a		dec $3a				dec 	zTemp2
.a53b	80 e6		bra $a523			bra 	_MDLIInsert
.a53d					_MDLIHaveSpace:
.a53d	ac 2a 04	ldy $042a			ldy 	tokenOffset 				; bytes to copy
.a540	88		dey				dey 								; from offset-1 to 0
.a541					_MDLICopy:
.a541	b9 2a 04	lda $042a,y			lda 	tokenOffset,y
.a544	91 30		sta ($30),y			sta 	(codePtr),y
.a546	88		dey				dey
.a547	10 f8		bpl $a541			bpl 	_MDLICopy
.a549	60		rts				rts
.a54a					_MDLIError:
.a54a	a9 06		lda #$06		lda	#6
.a54c	4c 1e 8f	jmp $8f1e		jmp	ErrorHandler
.a54f					MDLAppendLine:
.a54f	86 37		stx $37				stx 	zTemp0+1 					; save new line at zTemp0
.a551	85 36		sta $36				sta 	zTemp0
.a553	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a555	85 38		sta $38				sta 	0+zTemp1
.a557	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a559	85 39		sta $39				sta 	1+zTemp1
.a55b	b2 38		lda ($38)			lda 	(zTemp1)
.a55d	d0 0a		bne $a569			bne 	_MDLANoInitialise
.a55f	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a561	8d 64 06	sta $0664			sta 	0+AppendPointer
.a564	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a566	8d 65 06	sta $0665			sta 	1+AppendPointer
.a569					_MDLANoInitialise:
.a569	18		clc				clc
.a56a	ad 64 06	lda $0664			lda 	AppendPointer 				; copy append pointer to zTemp1 adding the offset as you go
.a56d	85 38		sta $38				sta 	zTemp1
.a56f	72 36		adc ($36)			adc 	(zTemp0)
.a571	8d 64 06	sta $0664			sta 	AppendPointer
.a574	ad 65 06	lda $0665			lda 	AppendPointer+1
.a577	85 39		sta $39				sta 	zTemp1+1
.a579	69 00		adc #$00			adc 	#0
.a57b	8d 65 06	sta $0665			sta 	AppendPointer+1
.a57e	a0 00		ldy #$00			ldy 	#0
.a580					_MDLACopy:
.a580	b1 36		lda ($36),y			lda 	(zTemp0),y 					; copy new line in
.a582	91 38		sta ($38),y			sta 	(zTemp1),y
.a584	c8		iny				iny
.a585	98		tya				tya
.a586	d2 36		cmp ($36)			cmp 	(zTemp0) 					; done whole line
.a588	d0 f6		bne $a580			bne 	_MDLACopy
.a58a	a9 00		lda #$00			lda 	#0 							; end of program.
.a58c	91 38		sta ($38),y			sta 	(zTemp1),y
.a58e	60		rts				rts
.0664					AppendPointer:
>0664							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/memory.asm

.a58f					MemoryNew:
.a58f	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a591	85 30		sta $30				sta 	codePtr
.a593	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a595	85 31		sta $31				sta 	codePtr+1
.a597	a9 00		lda #$00			lda 	#0 							; write zero there erasing the program.
.a599	92 30		sta ($30)			sta 	(codePtr)
.a59b	60		rts				rts
.a59c					MemoryInline:
.a59c	98		tya				tya 								; put address into stack,x
.a59d	18		clc				clc  								; get the offset, add codePtr
.a59e	65 30		adc $30				adc 	codePtr
.a5a0	95 58		sta $58,x			sta 	NSMantissa0,x 				; store the result in the mantissa.
.a5a2	a5 31		lda $31				lda 	codePtr+1
.a5a4	69 00		adc #$00			adc 	#0
.a5a6	95 60		sta $60,x			sta 	NSMantissa1,x
.a5a8	74 68		stz $68,x			stz 	NSMantissa2,x
.a5aa	74 70		stz $70,x			stz 	NSMantissa3,x
.a5ac	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/search.asm

.a5ad					MemorySearch:
.a5ad	85 36		sta $36				sta 	zTemp0 						; save line number in zTemp0
.a5af	86 37		stx $37				stx 	zTemp0+1
.a5b1	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a5b3	85 30		sta $30				sta 	codePtr
.a5b5	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a5b7	85 31		sta $31				sta 	codePtr+1
.a5b9					_MTAXLoop:
.a5b9	b2 30		lda ($30)			lda 	(codePtr)
.a5bb	18		clc				clc
.a5bc	f0 21		beq $a5df			beq 	_MTAXExit 					; reached end, exit with CC.
.a5be	a0 01		ldy #$01			ldy 	#1 							; calculate current line# - requested line#
.a5c0	b1 30		lda ($30),y			lda 	(codePtr),y
.a5c2	38		sec				sec
.a5c3	e5 36		sbc $36				sbc 	zTemp0
.a5c5	85 38		sta $38				sta 	zTemp1 						; save interim to set Z
.a5c7	c8		iny				iny 								; do the MSB
.a5c8	b1 30		lda ($30),y			lda 	(codePtr),y
.a5ca	e5 37		sbc $37				sbc 	zTemp0+1
.a5cc	05 38		ora $38				ora 	zTemp1 						; will set Z if result is zero, doesn't affect carry flag
.a5ce	f0 0f		beq $a5df			beq 	_MTAXExit	 				; found so exit (CS will be set)
.a5d0	b0 0d		bcs $a5df			bcs 	_MTAXExit 					; current < required exit
.a5d2	18		clc				clc
.a5d3	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.a5d5	65 30		adc $30				adc 	codePtr
.a5d7	85 30		sta $30				sta 	codePtr
.a5d9	90 02		bcc $a5dd			bcc 	_CREExit
.a5db	e6 31		inc $31				inc 	codePtr+1 					; carry
.a5dd					_CREExit:
.a5dd	80 da		bra $a5b9			bra 	_MTAXLoop
.a5df					_MTAXExit:
.a5df	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/effects.asm

.a5e0					PingCommand:
.a5e0	5a		phy				phy 								; save pos
.a5e1	a9 01		lda #$01			lda 	#1 						; push channel.
.a5e3	48		pha				pha
.a5e4	a9 c8		lda #$c8			lda 	#200 						; pitch LSB
.a5e6	a2 03		ldx #$03			ldx 	#3 						; length
.a5e8	a0 00		ldy #$00			ldy 	#0 						; slide LSB
.a5ea	80 24		bra $a610			bra 	SoundEffectCommand
.a5ec					ZapCommand:
.a5ec	5a		phy				phy 								; save pos
.a5ed	a9 01		lda #$01			lda 	#1 						; push channel.
.a5ef	48		pha				pha
.a5f0	a9 ff		lda #$ff			lda 	#255 						; pitch LSB
.a5f2	a2 05		ldx #$05			ldx 	#5 						; length
.a5f4	a0 14		ldy #$14			ldy 	#20 						; slide LSB
.a5f6	80 18		bra $a610			bra 	SoundEffectCommand
.a5f8					ShootCommand:
.a5f8	5a		phy				phy 								; save pos
.a5f9	a9 03		lda #$03			lda 	#3 						; push channel.
.a5fb	48		pha				pha
.a5fc	a9 20		lda #$20			lda 	#32 						; pitch LSB
.a5fe	a2 02		ldx #$02			ldx 	#2 						; length
.a600	a0 00		ldy #$00			ldy 	#0 						; slide LSB
.a602	80 0c		bra $a610			bra 	SoundEffectCommand
.a604					Explode:
.a604	5a		phy				phy 								; save pos
.a605	a9 03		lda #$03			lda 	#3 						; push channel.
.a607	48		pha				pha
.a608	a9 50		lda #$50			lda 	#80 						; pitch LSB
.a60a	a2 05		ldx #$05			ldx 	#5 						; length
.a60c	a0 00		ldy #$00			ldy 	#0 						; slide LSB
.a60e	80 00		bra $a610			bra 	SoundEffectCommand
.a610					SoundEffectCommand:
.a610	8d 66 06	sta $0666			sta 	SoundCommandBlock 			; set up the command block in sound.asm
.a613	9c 67 06	stz $0667			stz 	SoundCommandBlock+1
.a616	a9 0f		lda #$0f			lda 	#15
.a618	8d 68 06	sta $0668			sta 	SoundCommandBlock+2
.a61b	8e 69 06	stx $0669			stx 	SoundCommandBlock+3
.a61e	8c 6a 06	sty $066a			sty 	SoundCommandBlock+4
.a621	9c 6b 06	stz $066b			stz 	SoundCommandBlock+5
.a624	68		pla				pla
.a625	09 10		ora #$10			ora 	#$10  						; execute command $11
.a627	a2 66		ldx #$66			ldx 	#(SoundCommandBlock & $FF)
.a629	a0 06		ldy #$06			ldy 	#(SoundCommandBlock >> 8)
.a62b	20 18 80	jsr $8018			jsr 	SNDCommand
.a62e	7a		ply				ply
.a62f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/playing.asm

.a630					UnaryPlaying:
.a630	fa		plx				plx
.a631	20 db 9d	jsr $9ddb			jsr 	Evaluate8BitInteger 		; get channel #
.a634	48		pha				pha
.a635	20 05 8f	jsr $8f05			jsr		CheckRightBracket
.a638	68		pla				pla
.a639	c9 04		cmp #$04			cmp 	#4
.a63b	b0 0c		bcs $a649			bcs 	_UPNotPlaying
.a63d	09 20		ora #$20			ora 	#$20 						; query playing ?
.a63f	20 18 80	jsr $8018			jsr 	SNDCommand
.a642	c9 00		cmp #$00			cmp 	#0
.a644	f0 03		beq $a649			beq 	_UPNotPlaying
.a646	4c 8b 8f	jmp $8f8b			jmp 	ReturnTrue
.a649					_UPNotPlaying:
.a649	4c 96 8f	jmp $8f96			jmp 	ReturnFalse

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/sound.asm

.a64c					SoundCommand:
.a64c	b1 30		lda ($30),y			lda 	(codePtr),y
.a64e	c9 c3		cmp #$c3			cmp 	#KWD_OFF 					; SOUND OFF ?
.a650	d0 09		bne $a65b			bne 	_SNDMain
.a652	c8		iny				iny 								; skip OFF
.a653	a9 3f		lda #$3f			lda 	#$3F 						; call command $3F (silence)
.a655	5a		phy				phy
.a656	20 18 80	jsr $8018			jsr 	SNDCommand
.a659	7a		ply				ply
.a65a	60		rts				rts
.a65b					_SNDMain:
.a65b	a2 00		ldx #$00			ldx 	#0
.a65d	20 db 9d	jsr $9ddb			jsr 	Evaluate8BitInteger 		; channel
.a660	c9 04		cmp #$04			cmp 	#4 							; must be 0-3
.a662	b0 4b		bcs $a6af			bcs 	_SndError
.a664	e8		inx				inx 								; do the rest in slot 1.
.a665	20 0d 8f	jsr $8f0d			jsr 	CheckComma
.a668	20 c0 9d	jsr $9dc0			jsr 	Evaluate16BitInteger 		; Pitch
.a66b	b5 60		lda $60,x			lda 	NSMantissa1,x 				; must be 10 bit
.a66d	c9 10		cmp #$10			cmp 	#16
.a66f	b0 3e		bcs $a6af			bcs 	_SndError
.a671	8d 67 06	sta $0667			sta 	SoundCommandBlock+1 		; Pitch (2 bytes + 0)
.a674	b5 58		lda $58,x			lda 	NSMantissa0,x
.a676	8d 66 06	sta $0666			sta 	SoundCommandBlock
.a679	20 0d 8f	jsr $8f0d			jsr 	CheckComma
.a67c	20 db 9d	jsr $9ddb			jsr 	Evaluate8BitInteger 		; Length (1 byte + 3)
.a67f	8d 69 06	sta $0669			sta 	SoundCommandBlock+3
.a682	a9 0f		lda #$0f			lda 	#15
.a684	8d 68 06	sta $0668			sta 	SoundCommandBlock+2 		; Volume (1 byte + 2)
.a687	9c 6a 06	stz $066a			stz 	SoundCommandBlock+4 		; default slide (2 bytes +4)
.a68a	9c 6b 06	stz $066b			stz 	SoundCommandBlock+5
.a68d	b1 30		lda ($30),y			lda 	(codePtr),y
.a68f	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.a691	d0 0e		bne $a6a1			bne 	_SNDPlay
.a693	c8		iny				iny
.a694	20 ca 9d	jsr $9dca			jsr 	Evaluate16BitIntegerSigned 	; Slide
.a697	b5 58		lda $58,x			lda 	NSMantissa0,x 				; Slide (2 bytes + 4)
.a699	8d 6a 06	sta $066a			sta 	SoundCommandBlock+4
.a69c	b5 60		lda $60,x			lda 	NSMantissa1,x
.a69e	8d 6b 06	sta $066b			sta 	SoundCommandBlock+5
.a6a1					_SNDPlay:
.a6a1	5a		phy				phy
.a6a2	a5 58		lda $58				lda 	NSMantissa0 				; channel.
.a6a4	09 10		ora #$10			ora 	#$10 						; 1x = Queue sound
.a6a6	a2 66		ldx #$66			ldx 	#(SoundCommandBlock & $FF)
.a6a8	a0 06		ldy #$06			ldy 	#(SoundCommandBlock >> 8)
.a6aa	20 18 80	jsr $8018			jsr 	SNDCommand
.a6ad	7a		ply				ply
.a6ae	60		rts				rts
.a6af					_SndError:
.a6af	4c c3 9f	jmp $9fc3			jmp 	RangeError
.0666					SoundCommandBlock:
>0666							.fill 	6

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/bytes.asm

.a6b2					StackPushByte:
.a6b2	48		pha				pha 								; save byte on stack
.a6b3	a5 34		lda $34				lda 	BasicStack 					; decrement basic stack pointer
.a6b5	d0 08		bne $a6bf			bne 	_SPBNoBorrow
.a6b7	c6 35		dec $35				dec 	BasicStack+1 				; borrow
.a6b9	a5 35		lda $35				lda 	BasicStack+1 				; check range.
.a6bb	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a6bd	90 06		bcc $a6c5			bcc 	_SPBMemory
.a6bf					_SPBNoBorrow:
.a6bf	c6 34		dec $34				dec 	BasicStack
.a6c1	68		pla				pla 								; get back and write
.a6c2	92 34		sta ($34)			sta 	(BasicStack)
.a6c4	60		rts				rts
.a6c5					_SPBMemory:
.a6c5	a9 12		lda #$12		lda	#18
.a6c7	4c 1e 8f	jmp $8f1e		jmp	ErrorHandler
.a6ca					StackPopByte:
.a6ca	b2 34		lda ($34)			lda 	(BasicStack) 				; bump the stack pointer.
.a6cc	e6 34		inc $34				inc 	BasicStack
.a6ce	d0 02		bne $a6d2			bne 	_SPBNoCarry
.a6d0	e6 35		inc $35				inc 	BasicStack+1
.a6d2					_SPBNoCarry:
.a6d2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/frames.asm

.a6d3					StackOpen:
.a6d3	48		pha				pha 								; save frame byte
.a6d4	29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.a6d6	0a		asl a				asl 	a 							; claim twice this for storage
.a6d7	49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.a6d9	38		sec				sec 								; so basically subtracting from
.a6da	65 34		adc $34				adc 	basicStack 	 				; basicStack
.a6dc	85 34		sta $34				sta 	basicStack
.a6de	b0 09		bcs $a6e9			bcs 	_SONoBorrow
>a6e0	db						.byte 	$DB 						; causes a break in the emulator
.a6e1	c6 35		dec $35				dec 	basicStack+1
.a6e3	a5 35		lda $35				lda 	basicStack+1 				; have we reached stack overflow
.a6e5	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a6e7	90 04		bcc $a6ed			bcc 	_SOMemory
.a6e9					_SONoBorrow:
.a6e9	68		pla				pla 								; get marker back and write at TOS
.a6ea	92 34		sta ($34)			sta 	(basicStack)
.a6ec	60		rts				rts
.a6ed					_SOMemory:
.a6ed	a9 12		lda #$12		lda	#18
.a6ef	4c 1e 8f	jmp $8f1e		jmp	ErrorHandler
.a6f2					StackClose:
.a6f2	b2 34		lda ($34)			lda 	(basicStack) 				; get TOS marker
.a6f4	29 0f		and #$0f			and 	#$0F 						; bytes to add back
.a6f6	0a		asl a				asl 	a 							; claim twice this.
.a6f7	65 34		adc $34				adc 	basicStack 					; add to the stack pointer.
.a6f9	85 34		sta $34				sta 	basicStack
.a6fb	90 02		bcc $a6ff			bcc 	_SCExit
.a6fd	e6 35		inc $35				inc 	basicStack+1
.a6ff					_SCExit:
.a6ff	60		rts				rts
.a700					StackCheckFrame:
.a700	48		pha				pha
.a701					_StackRemoveLocals:
.a701	b2 34		lda ($34)			lda 	(basicStack) 				; check for local, keep popping them
.a703	c9 03		cmp #$03			cmp 	#STK_LOCALS+1 				; is the frame a local ? S or N are 1/0
.a705	b0 05		bcs $a70c			bcs 	_SCNoLocal
.a707	20 9d 89	jsr $899d			jsr 	LocalPopValue 				; restore the local value
.a70a	80 f5		bra $a701			bra 	_StackRemoveLocals 			; gr round again
.a70c					_SCNoLocal:
.a70c	68		pla				pla 								; get the frame check.
.a70d	52 34		eor ($34)			eor 	(basicStack) 				; xor with toS marker
.a70f	29 f0		and #$f0			and 	#$F0 						; check type bits
.a711	d0 01		bne $a714			bne 	_SCFError 					; different, we have structures mixed up
.a713	60		rts				rts
.a714					_SCFError:
.a714	8a		txa				txa 								; report error X
.a715	4c 1e 8f	jmp $8f1e			jmp 	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/location.asm

.a718					STKSaveCodePosition:
.a718	5a		phy				phy
.a719	98		tya				tya 								; save Y
.a71a	a0 05		ldy #$05			ldy 	#5
.a71c	91 34		sta ($34),y			sta 	(basicStack),y
.a71e	88		dey				dey 								; save Code Pointer
.a71f					_STKSaveLoop:
.a71f	b9 2f 00	lda $002f,y			lda 	safePtr-1,y 				; allows us to access the pointer w/out issues.
.a722	91 34		sta ($34),y			sta 	(basicStack),y
.a724	88		dey				dey
.a725	d0 f8		bne $a71f			bne 	_STKSaveLoop
.a727	7a		ply				ply
.a728	60		rts				rts
.a729					STKLoadCodePosition:
.a729	a0 01		ldy #$01			ldy 	#1 							; load code pointer back
.a72b					_STKLoadLoop:
.a72b	b1 34		lda ($34),y			lda 	(basicStack),y
.a72d	99 2f 00	sta $002f,y			sta 	safePtr-1,y
.a730	c8		iny				iny
.a731	c0 05		cpy #$05			cpy 	#5
.a733	d0 f6		bne $a72b			bne 	_STKLoadLoop
.a735	b1 34		lda ($34),y			lda 	(basicStack),y 				; get Y offset
.a737	a8		tay				tay
.a738	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/setup.asm

.a739					StackReset:
.a739	a9 ff		lda #$ff			lda 	#((BasicStackBase+BasicStackSize-1) & $FF)
.a73b	85 34		sta $34				sta 	0+basicStack
.a73d	a9 0f		lda #$0f			lda 	#((BasicStackBase+BasicStackSize-1) >> 8)
.a73f	85 35		sta $35				sta 	1+basicStack
.a741	a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.a743	92 34		sta ($34)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.a745	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/concrete.asm

.a746					StringConcrete:
.a746	5a		phy				phy 								; save position on stack
.a747	20 53 9a	jsr $9a53			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a74a	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy target string to zTemp1
.a74c	85 38		sta $38				sta 	zTemp1
.a74e	b5 60		lda $60,x			lda 	NSMantissa1,x
.a750	85 39		sta $39				sta 	zTemp1+1
.a752	a0 ff		ldy #$ff			ldy 	#$FF	 					; calculate string length
.a754					_SALength:
.a754	c8		iny				iny
.a755	b1 38		lda ($38),y			lda 	(zTemp1),y
.a757	d0 fb		bne $a754			bne 	_SALength
.a759	c0 fd		cpy #$fd			cpy 	#253 						; string too long - cannot concrete.
.a75b	b0 3d		bcs $a79a			bcs 	_SALengthError
.a75d	98		tya				tya 				 				; length of the new string
.a75e	18		clc				clc
.a75f	69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.a761	90 02		bcc $a765			bcc 	_SAHaveLength
.a763	a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.a765					_SAHaveLength:
.a765	48		pha				pha 								; save length.
.a766	38		sec				sec
.a767	49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.a769	6d 0e 04	adc $040e			adc 	StringMemory
.a76c	8d 0e 04	sta $040e			sta 	StringMemory
.a76f	85 3a		sta $3a				sta 	zTemp2 						; update storage address
.a771	95 58		sta $58,x			sta 	NSMantissa0,x 				; update mantissa address
.a773	a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.a775	6d 0f 04	adc $040f			adc 	StringMemory+1
.a778	8d 0f 04	sta $040f			sta 	StringMemory+1
.a77b	85 3b		sta $3b				sta 	zTemp2+1
.a77d	95 60		sta $60,x			sta 	NSMantissa1,x
.a77f	68		pla				pla 								; save length-3 (chars allowed) in first byte
.a780	38		sec				sec
.a781	e9 03		sbc #$03			sbc 	#3
.a783	92 3a		sta ($3a)			sta 	(zTemp2)
.a785	a9 00		lda #$00			lda 	#0 							; clear the status byte.
.a787	a0 01		ldy #$01			ldy 	#1
.a789	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a78b					_SACopyNewString:
.a78b	a0 00		ldy #$00			ldy 	#0
.a78d					_SACopyNSLoop:
.a78d	b1 38		lda ($38),y			lda 	(zTemp1),y 					; get character
.a78f	c8		iny				iny 								; write two on in string storage
.a790	c8		iny				iny
.a791	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a793	88		dey				dey 								; this makes it one one.
.a794	c9 00		cmp #$00			cmp 	#0 							; until EOS copied
.a796	d0 f5		bne $a78d			bne 	_SACopyNSLoop
.a798	7a		ply				ply
.a799	60		rts				rts
.a79a					_SALengthError:
.a79a	a9 09		lda #$09		lda	#9
.a79c	4c 1e 8f	jmp $8f1e		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/stringalloc.asm

.a79f					StringSystemInitialise:
.a79f	a9 ff		lda #$ff			lda 	#((EndVariableSpace-1) & $FF)
.a7a1	8d 0e 04	sta $040e			sta 	0+StringMemory
.a7a4	a9 1f		lda #$1f			lda 	#((EndVariableSpace-1) >> 8)
.a7a6	8d 0f 04	sta $040f			sta 	1+StringMemory
.a7a9	9c ff 1f	stz $1fff			stz 	EndVariableSpace-1 			; put a zero at the end, so know end of string memory.
.a7ac	60		rts				rts
.a7ad					StringSpaceInitialise:
.a7ad	20 53 9a	jsr $9a53			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a7b0	a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.a7b2	8d 10 04	sta $0410			sta 	StringInitialised
.a7b5	ad 0e 04	lda $040e			lda 	StringMemory 				; allocate 256 bytes for one concreted string
.a7b8	8d 11 04	sta $0411			sta 	StringTempPointer 			; so temporary string space is allocated below that.
.a7bb	ad 0f 04	lda $040f			lda 	StringMemory+1
.a7be	3a		dec a				dec 	a
.a7bf	8d 12 04	sta $0412			sta 	StringTempPointer+1
.a7c2	60		rts				rts
.a7c3					StringTempAllocate:
.a7c3	c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.a7c5	b0 30		bcs $a7f7			bcs 	_STALength
.a7c7	2c 10 04	bit $0410			bit 	StringInitialised 			; already initialised
.a7ca	30 05		bmi $a7d1			bmi 	_STAAllocate
.a7cc	48		pha				pha 								; save value to subtract.
.a7cd	20 ad a7	jsr $a7ad			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.a7d0	68		pla				pla 								; restore it
.a7d1					_STAAllocate:
.a7d1	49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.a7d3	18		clc				clc  								; deliberate allows one more
.a7d4	6d 11 04	adc $0411			adc 	StringTempPointer 			; subtract from temp pointer
.a7d7	8d 11 04	sta $0411			sta 	StringTempPointer
.a7da	95 58		sta $58,x			sta 	NSMantissa0,x 				; address in mantissa
.a7dc	85 3c		sta $3c				sta 	zsTemp 						; and zsTemp
.a7de	ad 12 04	lda $0412			lda 	StringTempPointer+1
.a7e1	69 ff		adc #$ff			adc 	#$FF
.a7e3	8d 12 04	sta $0412			sta 	StringTempPointer+1
.a7e6	85 3d		sta $3d				sta 	zsTemp+1
.a7e8	95 60		sta $60,x			sta 	NSMantissa1,x
.a7ea	74 68		stz $68,x			stz 	NSMantissa2,x 				; set the typing data and the upper address bytes.
.a7ec	74 70		stz $70,x			stz 	NSMantissa3,x
.a7ee	a9 10		lda #$10			lda 	#NSTString
.a7f0	95 50		sta $50,x			sta 	NSStatus,x
.a7f2	a9 00		lda #$00			lda 	#0 							; clear the target string
.a7f4	92 3c		sta ($3c)			sta 	(zsTemp)
.a7f6	60		rts				rts
.a7f7					_STALength:
.a7f7	a9 09		lda #$09		lda	#9
.a7f9	4c 1e 8f	jmp $8f1e		jmp	ErrorHandler
.a7fc					StringTempWrite:
.a7fc	48		pha				pha
.a7fd	92 3c		sta ($3c)			sta 	(zsTemp) 					; write byte
.a7ff	e6 3c		inc $3c				inc 	zsTemp 						; bump pointer
.a801	d0 02		bne $a805			bne 	_STWNoCarry
.a803	e6 3d		inc $3d				inc 	zsTemp+1
.a805					_STWNoCarry:
.a805	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.a807	92 3c		sta ($3c)			sta 	(zsTemp)
.a809	68		pla				pla
.a80a	60		rts				rts

;******  Return to file: _basic.asm

.a80b					StartModuleCode:

;******  Processing file: ../modules/_build/_hardware.module

=1					hardwareIntegrated=1
=0					CONBlack = 0
=1					CONWhite = 1
=2					CONRed = 2
=3					CONCyan = 3
=4					CONPurple = 4
=5					CONGreen = 5
=6					CONBlue = 6
=7					CONYellow = 7
=8					CONOrange = 8
=9					CONBrown = 9
=10					CONYellowGreen = 10
=11					CONRosa = 11
=12					CONBlueGreen = 12
=13					CONLightBlue = 13
=14					CONPink = 14
=15					CONLightGreen = 15
=7					CONForeground = CONYellow
=6					CONBackground = CONBlue
=5					CLICommandLine = CONGreen
=0					CLIFComment = CONBlack
=7					CLIBComment = CONYellow
=9					CLILineNumber = CONBrown
=3					CLIToken = CONCyan
=13					CLIConstant = CONLightBlue
=7					CLIIdentifier = CONYellow
=10					CLIPunctuation = CONYellowGreen
=1					CLIData = CONWhite
.a80b					Export_EXTPrintCharacter:
.a80b					PAGEDPrintCharacter:
.a80b	48		pha				pha
.a80c	da		phx				phx
.a80d	5a		phy				phy
.a80e	a6 01		ldx $01				ldx 	1
.a810	da		phx				phx
.a811	ac 6d 06	ldy $066d			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.a814	09 00		ora #$00			ora 	#$00 						; check $80-$FF
.a816	30 48		bmi $a860			bmi 	_EXPCColour
.a818	c9 20		cmp #$20			cmp 	#$20 						; check $00-$1F
.a81a	90 4d		bcc $a869			bcc 	_EXPCControl
.a81c	a2 02		ldx #$02			ldx 	#2 							; select char memory
.a81e	86 01		stx $01				stx 	1
.a820	91 40		sta ($40),y			sta 	(EXTAddress),y
.a822	e6 01		inc $01				inc 	1 							; select colour memory
.a824	ad 6e 06	lda $066e			lda 	EXTTextColour
.a827	91 40		sta ($40),y			sta 	(EXTAddress),y
.a829	c8		iny				iny 								; advance horizontal position
.a82a	8c 6d 06	sty $066d			sty 	EXTColumn
.a82d	cc 6f 06	cpy $066f			cpy 	EXTScreenWidth 				; reached RHS ?
.a830	90 63		bcc $a895			bcc 	_EXPCExit 					; no, then exit.
.a832					_EXPCCRLF:
.a832	ee 6c 06	inc $066c			inc 	EXTRow  					; bump row
.a835	9c 6d 06	stz $066d			stz 	EXTColumn 					; back to column 0
.a838	ad 6c 06	lda $066c			lda 	EXTRow 						; check if reached the bottom ?
.a83b	cd 70 06	cmp $0670			cmp 	EXTScreenHeight 			; if so, then scroll.
.a83e	f0 18		beq $a858			beq 	_EXPCScroll
.a840	18		clc				clc 								; add width to address.
.a841	a5 40		lda $40				lda 	EXTAddress
.a843	6d 6f 06	adc $066f			adc 	EXTScreenWidth
.a846	85 40		sta $40				sta 	EXTAddress
.a848	90 4b		bcc $a895			bcc 	_EXPCExit
.a84a	e6 41		inc $41				inc 	EXTAddress+1
.a84c	80 47		bra $a895			bra 	_EXPCExit
.a84e					_EXPCLeft:
.a84e	ce 6d 06	dec $066d			dec 	EXTColumn
.a851	10 42		bpl $a895			bpl 	_EXPCExit
.a853					_EXPCBegin:
.a853	9c 6d 06	stz $066d			stz 	EXTColumn
.a856	80 3d		bra $a895			bra 	_EXPCExit
.a858					_EXPCScroll:
.a858	ce 6c 06	dec $066c			dec 	EXTRow 						; the height-1 th line.
.a85b	20 46 a9	jsr $a946			jsr 	EXTScreenScroll 			; scroll the screen
.a85e	80 35		bra $a895			bra 	_EXPCExit
.a860					_EXPCColour:
.a860	c9 a0		cmp #$a0			cmp 	#$A0						; 80-9F set foreground/background
.a862	b0 31		bcs $a895			bcs 	_EXPCExit
.a864	20 26 a9	jsr $a926			jsr 	_EXPCHandleColour
.a867	80 2c		bra $a895			bra 	_EXPCExit
.a869					_EXPCControl:
.a869	c9 11		cmp #$11			cmp 	#$11 						; only handle 00-10.
.a86b	b0 28		bcs $a895			bcs 	_EXPCExit
.a86d	0a		asl a				asl 	a 							; double into X
.a86e	aa		tax				tax
.a86f	7c 04 a9	jmp ($a904,x)			jmp 	(_EXPCActionTable,x) 		; and execute code.
.a872					_EXPCUp:
.a872	ad 6c 06	lda $066c			lda 	EXTRow 						; already at top ?
.a875	f0 1e		beq $a895			beq 	_EXPCExit
.a877	ce 6c 06	dec $066c			dec 	EXTRow 						; up one in position/address
.a87a	38		sec				sec
.a87b	a5 40		lda $40				lda 	EXTAddress
.a87d	ed 6f 06	sbc $066f			sbc 	EXTScreenWidth
.a880	85 40		sta $40				sta 	EXTAddress
.a882	b0 11		bcs $a895			bcs 	_EXPCExit
.a884	c6 41		dec $41				dec 	EXTAddress+1
.a886	80 0d		bra $a895			bra 	_EXPCExit
.a888					_EXPCRight:
.a888	c8		iny				iny
.a889	8c 6d 06	sty $066d			sty 	EXTColumn
.a88c	cc 6f 06	cpy $066f			cpy 	EXTScreenWidth
.a88f	d0 04		bne $a895			bne 	_EXPCExit
.a891	88		dey				dey
.a892					_EXPCSetColumnY:
.a892	8c 6d 06	sty $066d			sty 	EXTColumn
.a895					_EXPCExit:
.a895	20 9b a9	jsr $a99b			jsr 	EXTSetHardwareCursor 		; place the physical cursor.
.a898	68		pla				pla
.a899	85 01		sta $01				sta 	1
.a89b	7a		ply				ply
.a89c	fa		plx				plx
.a89d	68		pla				pla
.a89e	60		rts				rts
.a89f					_EXPCClearScreen:
.a89f	20 58 a9	jsr $a958			jsr		EXTClearScreenCode
.a8a2	80 f1		bra $a895			bra 	_EXPCExit
.a8a4					_EXPCDown:
.a8a4	ad 70 06	lda $0670			lda 	EXTScreenHeight 			; at the bottom
.a8a7	3a		dec a				dec 	a
.a8a8	cd 6c 06	cmp $066c			cmp 	EXTRow
.a8ab	f0 e8		beq $a895			beq 	_EXPCExit
.a8ad	ee 6c 06	inc $066c			inc 	EXTRow 						; down one in position/address
.a8b0	18		clc				clc
.a8b1	a5 40		lda $40				lda 	EXTAddress
.a8b3	6d 6f 06	adc $066f			adc 	EXTScreenWidth
.a8b6	85 40		sta $40				sta 	EXTAddress
.a8b8	90 db		bcc $a895			bcc 	_EXPCExit
.a8ba	e6 41		inc $41				inc 	EXTAddress+1
.a8bc	80 d7		bra $a895			bra 	_EXPCExit
.a8be					_EXPCTab:
.a8be	ad 6d 06	lda $066d			lda 	EXTColumn 					; next tab stop
.a8c1	29 f8		and #$f8			and 	#$F8
.a8c3	18		clc				clc
.a8c4	69 08		adc #$08			adc 	#8
.a8c6	8d 6d 06	sta $066d			sta 	EXTColumn
.a8c9	cd 6f 06	cmp $066f			cmp 	EXTScreenWidth 				; too far, stick end of line.
.a8cc	90 c7		bcc $a895			bcc 	_EXPCExit
.a8ce	80 10		bra $a8e0			bra 	_EXPCEnd
.a8d0					_EXPCBackSpace:
.a8d0	88		dey				dey
.a8d1	30 c2		bmi $a895			bmi 	_EXPCExit
.a8d3	ce 6d 06	dec $066d			dec 	EXTColumn
.a8d6	a9 02		lda #$02			lda 	#2
.a8d8	85 01		sta $01				sta 	1
.a8da	a9 20		lda #$20			lda 	#32
.a8dc	91 40		sta ($40),y			sta 	(EXTAddress),y
.a8de	80 b5		bra $a895			bra 	_EXPCExit
.a8e0					_EXPCEnd:
.a8e0	a9 02		lda #$02			lda 	#2 							; access text screen
.a8e2	85 01		sta $01				sta 	1
.a8e4	ac 6f 06	ldy $066f			ldy 	EXTScreenWidth 				; point to last character
.a8e7	88		dey				dey
.a8e8					_EXPCEndSearch:
.a8e8	88		dey				dey 								; if past start, move to col 0.
.a8e9	30 06		bmi $a8f1			bmi 	_EXPCFound
.a8eb	b1 40		lda ($40),y			lda 	(EXTAddress),y 				; keep going back till non space found
.a8ed	c9 20		cmp #$20			cmp 	#' '
.a8ef	f0 f7		beq $a8e8			beq 	_EXPCEndSearch
.a8f1					_EXPCFound:
.a8f1	c8		iny				iny 								; move to following cell.
.a8f2	80 9e		bra $a892			bra 	_EXPCSetColumnY
.a8f4					_EXPCClearEOL:
.a8f4	a9 02		lda #$02			lda 	#2 							; access character RAM
.a8f6	85 01		sta $01				sta 	1
.a8f8	a9 20		lda #$20			lda 	#' ' 						; write space
.a8fa	91 40		sta ($40),y			sta 	(EXTAddress),y
.a8fc	c8		iny				iny
.a8fd	cc 6f 06	cpy $066f			cpy 	EXTScreenWidth 				; until RHS of screen.
.a900	90 f2		bcc $a8f4			bcc 	_EXPCClearEOL
.a902	80 91		bra $a895			bra 	_EXPCExit
.a904					_EXPCActionTable:
>a904	95 a8						.word 	_EXPCExit 					; 00
>a906	53 a8						.word 	_EXPCBegin 					; 01 A Start of Line
>a908	4e a8						.word 	_EXPCLeft 					; 02 B Left
>a90a	95 a8						.word 	_EXPCExit 					; 03 <Break>
>a90c	95 a8						.word 	_EXPCExit 					; 04
>a90e	e0 a8						.word 	_EXPCEnd 					; 05 E End of Line
>a910	88 a8						.word 	_EXPCRight 					; 06 F Right
>a912	95 a8						.word 	_EXPCExit 					; 07
>a914	d0 a8						.word 	_EXPCBackspace 				; 08 H Backspace
>a916	be a8						.word 	_EXPCTab 					; 09 I Tab
>a918	95 a8						.word 	_EXPCExit 					; 0A
>a91a	f4 a8						.word 	_EXPCClearEOL 				; 0B K Clear to EOL
>a91c	9f a8						.word 	_EXPCClearScreen			; 0C L CLS
>a91e	32 a8						.word 	_EXPCCRLF 					; 0D M CR/LF
>a920	a4 a8						.word 	_EXPCDown 					; 0E N Down
>a922	95 a8						.word 	_EXPCExit 					; 0F
>a924	72 a8						.word 	_EXPCUp 					; 10 P Up
.a926					_EXPCHandleColour
.a926	c9 90		cmp #$90			cmp 	#$90 						; 8x foreground 9x background
.a928	b0 16		bcs $a940			bcs 	_EXPCBackground
.a92a	0a		asl a				asl 	a 							; shift it 4 bits to the right.
.a92b	0a		asl a				asl 	a
.a92c	0a		asl a				asl 	a
.a92d	0a		asl a				asl 	a
.a92e	a2 0f		ldx #$0f			ldx 	#$0F 						; Mask in X
.a930					_EXPCUpdate:
.a930	48		pha				pha 								; save new colour
.a931	8a		txa				txa 								; get mask
.a932	2d 6e 06	and $066e			and 	EXTTextColour 				; mask out old.
.a935	8d 6e 06	sta $066e			sta 	EXTTextColour
.a938	68		pla				pla 								; or in new colour
.a939	0d 6e 06	ora $066e			ora 	EXTTextColour
.a93c	8d 6e 06	sta $066e			sta 	EXTTextColour
.a93f	60		rts				rts
.a940					_EXPCBackground:
.a940	29 0f		and #$0f			and 	#$0F 						; get the colour
.a942	a2 f0		ldx #$f0			ldx 	#$F0 						; mask
.a944	80 ea		bra $a930			bra 	_EXPCUpdate
.a946					EXTScreenScroll:
.a946	a9 02		lda #$02			lda 	#2 							; select text page
.a948	85 01		sta $01				sta 	1
.a94a	a9 20		lda #$20			lda		#32 						; fill with space
.a94c	20 5f aa	jsr $aa5f			jsr 	EXTScrollFill
.a94f	e6 01		inc $01				inc 	1 							; select colour page
.a951	ad 6e 06	lda $066e			lda 	EXTTextColour
.a954	20 5f aa	jsr $aa5f			jsr 	EXTScrollFill
.a957	60		rts				rts
.a958					EXTClearScreenCode:
.a958	a9 02		lda #$02			lda 	#2 							; select text page
.a95a	85 01		sta $01				sta 	1
.a95c	a9 20		lda #$20			lda		#32 						; fill with space
.a95e	20 6b a9	jsr $a96b			jsr 	_EXTCSFill
.a961	e6 01		inc $01				inc 	1 							; select colour page
.a963	ad 6e 06	lda $066e			lda 	EXTTextColour
.a966	20 6b a9	jsr $a96b			jsr 	_EXTCSFill
.a969	80 22		bra $a98d			bra 	EXTHomeCursor
.a96b					_EXTCSFill:
.a96b	aa		tax				tax
.a96c	a9 00		lda #$00			lda 	#EXTMemory & $FF
.a96e	85 40		sta $40				sta 	EXTAddress
.a970	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a972	85 41		sta $41				sta 	EXTAddress+1
.a974					_EXTCSFill1:
.a974	a0 00		ldy #$00			ldy 	#0
.a976	8a		txa				txa
.a977					_EXTCSFill2:
.a977	91 40		sta ($40),y			sta 	(EXTAddress),y
.a979	c8		iny				iny
.a97a	d0 fb		bne $a977			bne 	_EXTCSFill2
.a97c	e6 41		inc $41				inc 	EXTAddress+1
.a97e	a5 41		lda $41				lda 	EXTAddress+1
.a980	c9 d2		cmp #$d2			cmp 	#$D2
.a982	d0 f0		bne $a974			bne 	_EXTCSFill1
.a984	8a		txa				txa
.a985					_EXTCSFill3:
.a985	91 40		sta ($40),y			sta 	(EXTAddress),y
.a987	c8		iny				iny
.a988	c0 c0		cpy #$c0			cpy 	#$C0
.a98a	d0 f9		bne $a985			bne 	_EXTCSFill3
.a98c	60		rts				rts
.a98d					EXTHomeCursor:
.a98d	9c 6c 06	stz $066c			stz 	EXTRow 						; reset row & column
.a990	9c 6d 06	stz $066d			stz 	EXTColumn
.a993	a9 00		lda #$00			lda 	#EXTMemory & $FF 			; set address
.a995	85 40		sta $40				sta 	EXTAddress
.a997	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a999	85 41		sta $41				sta 	EXTAddress+1
.a99b					EXTSetHardwareCursor:
.a99b	64 01		stz $01				stz 	1 							; I/O Page zero
.a99d	a9 05		lda #$05			lda 	#1+4 						; enable cursor
.a99f	8d 10 d0	sta $d010			sta 	$D010
.a9a2	a9 b1		lda #$b1			lda 	#$B1
.a9a4	8d 12 d0	sta $d012			sta 	$D012
.a9a7	ad 6d 06	lda $066d			lda 	EXTColumn
.a9aa	8d 14 d0	sta $d014			sta 	$D014 						; set cursor position
.a9ad	9c 15 d0	stz $d015			stz 	$D015
.a9b0	ad 6c 06	lda $066c			lda 	EXTRow
.a9b3	8d 16 d0	sta $d016			sta 	$D016
.a9b6	9c 17 d0	stz $d017			stz 	$D017
.a9b9	60		rts				rts
.a9ba					Export_EXTInputLine:
.a9ba	48		pha				pha
.a9bb	da		phx				phx
.a9bc	5a		phy				phy
.a9bd	a5 01		lda $01				lda 	1 							; save I/O page
.a9bf	48		pha				pha
.a9c0					_EILLoop:
.a9c0	20 da aa	jsr $aada			jsr 	PagedInputSingleCharacter
.a9c3	c9 0d		cmp #$0d			cmp 	#13 						; scrape line if exit.
.a9c5	f0 44		beq $aa0b			beq 	_EILExit
.a9c7	c9 04		cmp #$04			cmp 	#4 							; Ctrl+D delete at cursor
.a9c9	f0 2a		beq $a9f5			beq 	_EILDelete
.a9cb	c9 08		cmp #$08			cmp 	#8 							; Ctrl+H backspace
.a9cd	f0 1c		beq $a9eb			beq 	_EILBackspace
.a9cf	c9 20		cmp #$20			cmp 	#' '						; < space, print it
.a9d1	90 12		bcc $a9e5			bcc 	_EILPrintLoop
.a9d3	c9 7f		cmp #$7f			cmp 	#$7F 						; if -ve print it
.a9d5	b0 0e		bcs $a9e5			bcs 	_EILPrintLoop
.a9d7	48		pha				pha 								; save character
.a9d8	a9 02		lda #$02			lda 	#2  						; insert a space
.a9da	85 01		sta $01				sta 	1
.a9dc	20 4d aa	jsr $aa4d			jsr 	EXTILInsert 				; insert in text screen
.a9df	e6 01		inc $01				inc 	1
.a9e1	20 4d aa	jsr $aa4d			jsr 	EXTILInsert 				; insert in colour screen
.a9e4	68		pla				pla 								; get character back.
.a9e5					_EILPrintLoop:
.a9e5	20 0b a8	jsr $a80b			jsr 	PagedPrintCharacter
.a9e8	80 d6		bra $a9c0			bra 	_EILLoop
.a9ea	60		rts				rts
.a9eb					_EILBackspace:
.a9eb	ad 6d 06	lda $066d			lda 	EXTColumn					; can we backspace ?
.a9ee	f0 d0		beq $a9c0			beq 	_EILLoop
.a9f0	a9 02		lda #$02			lda 	#2 							; move cursor left
.a9f2	20 0b a8	jsr $a80b			jsr 	PagedPrintCharacter
.a9f5					_EILDelete
.a9f5	a9 02		lda #$02			lda 	#2 							; text block
.a9f7	85 01		sta $01				sta 	1
.a9f9	a9 20		lda #$20			lda 	#' ' 						; backspace text.
.a9fb	20 38 aa	jsr $aa38			jsr 	EXTILDelete
.a9fe	e6 01		inc $01				inc 	1 							; colour block
.aa00	ac 6d 06	ldy $066d			ldy 	EXTColumn 					; get attribute of last character
.aa03	88		dey				dey
.aa04	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa06	20 38 aa	jsr $aa38			jsr 	EXTILDelete 				; backspace attribute
.aa09	80 b5		bra $a9c0			bra 	_EILLoop 					; and go round.
.aa0b					_EILExit:
.aa0b	a9 02		lda #$02			lda 	#2 							; switch to page 2
.aa0d	85 01		sta $01				sta 	1
.aa0f	a0 00		ldy #$00			ldy 	#0 							; copy current line into buffer.
.aa11					_EILScrapeLine:
.aa11	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa13	99 2a 05	sta $052a,y			sta 	lineBuffer,y
.aa16	c8		iny				iny
.aa17	cc 6f 06	cpy $066f			cpy 	EXTScreenWidth
.aa1a	d0 f5		bne $aa11			bne 	_EILScrapeLine
.aa1c					_EILTrimSpaces:
.aa1c	88		dey				dey
.aa1d	f0 08		beq $aa27			beq 	_EILEndTrim
.aa1f	b9 2a 05	lda $052a,y			lda 	lineBuffer,y
.aa22	c9 20		cmp #$20			cmp 	#' '
.aa24	f0 f6		beq $aa1c			beq 	_EILTrimSpaces
.aa26	c8		iny				iny 								; trim after non space character.
.aa27					_EILEndTrim:
.aa27	a9 00		lda #$00			lda 	#0 							; trim here.
.aa29	99 2a 05	sta $052a,y			sta 	lineBuffer,y
.aa2c	a9 0d		lda #$0d			lda 	#13 						; echo the RETURN
.aa2e	20 0b a8	jsr $a80b			jsr 	PagedPrintCharacter
.aa31	68		pla				pla 								; reset I/O page
.aa32	85 01		sta $01				sta 	1
.aa34	7a		ply				ply
.aa35	fa		plx				plx
.aa36	68		pla				pla
.aa37	60		rts				rts
.aa38					EXTILDelete:
.aa38	48		pha				pha 								; save the new character
.aa39	ac 6d 06	ldy $066d			ldy 	EXTColumn 					; start copying from here.
.aa3c					_EXTDLoop:
.aa3c	c8		iny				iny 								; copy one byte down.
.aa3d	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa3f	88		dey				dey
.aa40	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa42	c8		iny				iny 								; do till end of line.
.aa43	cc 6f 06	cpy $066f			cpy 	EXTScreenWidth
.aa46	90 f4		bcc $aa3c			bcc 	_EXTDLoop
.aa48	88		dey				dey 	 							; write in last slot.
.aa49	68		pla				pla
.aa4a	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa4c	60		rts				rts
.aa4d					EXTILInsert:
.aa4d	ac 6f 06	ldy $066f			ldy 	EXTScreenWidth 				; end position
.aa50					_EXTILoop:
.aa50	88		dey				dey 								; back one
.aa51	cc 6d 06	cpy $066d			cpy 	EXTColumn 					; exit if reached insert point.
.aa54	f0 08		beq $aa5e			beq 	_EXTIExit
.aa56	88		dey				dey 								; copy one byte up.
.aa57	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa59	c8		iny				iny
.aa5a	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa5c	80 f2		bra $aa50			bra 	_EXTILoop
.aa5e					_EXTIExit:
.aa5e	60		rts				rts
.aa5f					EXTScrollFill:
.aa5f	aa		tax				tax									; save value to fill with
.aa60	a5 36		lda $36				lda 	zTemp0 						; save zTemp0 (dest) zTemp1 (src)
.aa62	48		pha				pha
.aa63	a5 37		lda $37				lda 	zTemp0+1
.aa65	48		pha				pha
.aa66	a5 38		lda $38				lda 	zTemp1
.aa68	48		pha				pha
.aa69	a5 39		lda $39				lda 	zTemp1+1
.aa6b	48		pha				pha
.aa6c	a9 c0		lda #$c0			lda 	#$C0 						; copy from C000+length to C000
.aa6e	85 37		sta $37				sta 	zTemp0+1
.aa70	85 39		sta $39				sta 	zTemp1+1
.aa72	64 36		stz $36				stz 	zTemp0
.aa74	ad 6f 06	lda $066f			lda 	EXTScreenWidth
.aa77	85 38		sta $38				sta 	zTemp1
.aa79	a0 00		ldy #$00			ldy 	#0
.aa7b					_EXSFCopy1:
.aa7b	b1 38		lda ($38),y			lda 	(zTemp1),y
.aa7d	91 36		sta ($36),y			sta 	(zTemp0),y
.aa7f	c8		iny				iny
.aa80	d0 f9		bne $aa7b			bne 	_EXSFCopy1
.aa82	e6 37		inc $37				inc 	zTemp0+1 					; next page
.aa84	e6 39		inc $39				inc 	zTemp1+1
.aa86	a5 39		lda $39				lda 	zTemp1+1
.aa88	c9 d3		cmp #$d3			cmp 	#$D3
.aa8a	d0 ef		bne $aa7b			bne 	_EXSFCopy1
.aa8c	ac 6f 06	ldy $066f			ldy 	EXTScreenWidth 				; blank the bottom line.
.aa8f	8a		txa				txa
.aa90					_EXSFFill1:
.aa90	88		dey				dey
.aa91	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa93	c0 00		cpy #$00			cpy 	#0
.aa95	10 f9		bpl $aa90			bpl 	_EXSFFill1
.aa97	68		pla				pla
.aa98	85 39		sta $39				sta 	zTemp1+1
.aa9a	68		pla				pla
.aa9b	85 38		sta $38				sta 	zTemp1
.aa9d	68		pla				pla
.aa9e	85 37		sta $37				sta 	zTemp0+1
.aaa0	68		pla				pla
.aaa1	85 36		sta $36				sta 	zTemp0
.aaa3	60		rts				rts
=$c000					EXTMemory = $C000
=$02					EXTTextPage = $02
=$03					EXTColourPage = $03
=1					EXTDummySpace = 1 							; fake-space for CR character.
=0					EXTCBlack = 0
.066c					EXTRow:
>066c							.fill 	1
.066d					EXTColumn:
>066d							.fill 	1
.066e					EXTTextColour:
>066e							.fill 	1
.066f					EXTScreenWidth:
>066f							.fill 	1
.0670					EXTScreenHeight:
>0670							.fill 	1
.0040					EXTAddress:
>0040							.fill 	2
.aaa4					Export_EXTInitialise:
.aaa4	64 01		stz $01				stz 	1 							; Access I/O page 0
.aaa6	9c 04 d0	stz $d004			stz 	$D004 						; Disable border
.aaa9	9c 08 d0	stz $d008			stz 	$D008
.aaac	9c 09 d0	stz $d009			stz 	$D009
.aaaf	a9 09		lda #$09			lda 	#1+8						; Timer On at 70Hz counting up.
.aab1	8d 58 d6	sta $d658			sta 	$D658
.aab4	a9 03		lda #$03			lda 	#3 							; get current text colour from whatever the kernel
.aab6	85 01		sta $01				sta 	1 							; has set it to, looking at top left character
.aab8	ad 00 c0	lda $c000			lda 	$C000
.aabb	8d 6e 06	sta $066e			sta 	EXTTextColour
.aabe	a9 50		lda #$50			lda 	#80 						; set screen dimensions.
.aac0	8d 6f 06	sta $066f			sta 	EXTScreenWidth
.aac3	a9 3c		lda #$3c			lda 	#60
.aac5	8d 70 06	sta $0670			sta 	EXTScreenHeight
.aac8	20 8d a9	jsr $a98d			jsr 	EXTHomeCursor 				; home cursor
.aacb					_EXMoveDown:
.aacb	a9 0d		lda #$0d			lda 	#13
.aacd	20 0b a8	jsr $a80b			jsr 	PAGEDPrintCharacter
.aad0	ad 6c 06	lda $066c			lda 	EXTRow
.aad3	c9 06		cmp #$06			cmp 	#6
.aad5	d0 f4		bne $aacb			bne 	_EXMoveDown
.aad7	64 01		stz $01				stz 	1
.aad9	60		rts				rts
.aada					Export_EXTInputSingleCharacter:
.aada					PagedInputSingleCharacter:
.aada	da		phx				phx
.aadb	5a		phy				phy
.aadc					_EISCWait:
.aadc	a5 01		lda $01				lda 	1 							; save I/O 0
.aade	48		pha				pha
.aadf	64 01		stz $01				stz 	1 							; access I/O Page 0
.aae1	38		sec				sec 								; calculate timer - LastTick
.aae2	ad 59 d6	lda $d659			lda 	$D659
.aae5	aa		tax				tax 								; saving timer in X
.aae6	ed 5b 06	sbc $065b			sbc 	LastTick
.aae9	c9 03		cmp #$03			cmp 	#3
.aaeb	90 06		bcc $aaf3			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.aaed	8e 5b 06	stx $065b			stx 	LastTick 					; update last timer
.aaf0	20 bb be	jsr $bebb			jsr 	PagedSNDUpdate 							; go do the code.
.aaf3					_NoFireTick:
.aaf3	68		pla				pla 								; restore I/O 0
.aaf4	85 01		sta $01				sta 	1
.aaf6	20 e4 ff	jsr $ffe4			jsr 	$FFE4 						; get a key
.aaf9	c9 00		cmp #$00			cmp 	#0 							; loop back if none pressed.
.aafb	f0 df		beq $aadc			beq 	_EISCWait
.aafd	7a		ply				ply
.aafe	fa		plx				plx
.aaff	60		rts				rts
.ab00					Export_EXTBreakCheck:
.ab00	4c e1 ff	jmp $ffe1			jmp		$FFE1
.ab03					Export_EXTReadController:
.ab03	da		phx				phx
.ab04	a2 00		ldx #$00			ldx 	#0
.ab06	a9 05		lda #$05			lda 	#(($2D) >> 3)
.ab08	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab0b	29 20		and #$20			and 	#($01 << (($2D) & 7))
.ab0d	f0 04		beq $ab13			beq 	_NoSet1
.ab0f	8a		txa				txa
.ab10	09 01		ora #$01			ora 	#1
.ab12	aa		tax				tax
.ab13					_NoSet1:
.ab13	a9 05		lda #$05			lda 	#(($2C) >> 3)
.ab15	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab18	29 10		and #$10			and 	#($01 << (($2C) & 7))
.ab1a	f0 04		beq $ab20			beq 	_NoSet1
.ab1c	8a		txa				txa
.ab1d	09 02		ora #$02			ora 	#2
.ab1f	aa		tax				tax
.ab20					_NoSet1:
.ab20	a9 06		lda #$06			lda 	#(($32) >> 3)
.ab22	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab25	29 04		and #$04			and 	#($01 << (($32) & 7))
.ab27	f0 04		beq $ab2d			beq 	_NoSet1
.ab29	8a		txa				txa
.ab2a	09 04		ora #$04			ora 	#4
.ab2c	aa		tax				tax
.ab2d					_NoSet1:
.ab2d	a9 04		lda #$04			lda 	#(($25) >> 3)
.ab2f	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab32	29 20		and #$20			and 	#($01 << (($25) & 7))
.ab34	f0 04		beq $ab3a			beq 	_NoSet1
.ab36	8a		txa				txa
.ab37	09 08		ora #$08			ora 	#8
.ab39	aa		tax				tax
.ab3a					_NoSet1:
.ab3a	a9 04		lda #$04			lda 	#(($26) >> 3)
.ab3c	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab3f	29 40		and #$40			and 	#($01 << (($26) & 7))
.ab41	f0 04		beq $ab47			beq 	_NoSet1
.ab43	8a		txa				txa
.ab44	09 10		ora #$10			ora 	#16
.ab46	aa		tax				tax
.ab47					_NoSet1:
.ab47	8a		txa				txa
.ab48	fa		plx				plx
.ab49	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_graphics.module

=1					graphicsIntegrated=1
=0					GCMD_Initialise = 0*2
=2					GCMD_BitmapCtl = 1*2
=4					GCMD_SpriteCtl = 2*2
=6					GCMD_Clear = 3*2
=8					GCMD_Colour = 4*2
=10					GCMD_DrawFont = 5*2
=12					GCMD_DrawSprite = 6*2
=14					GCMD_SpriteUse = 7*2
=16					GCMD_SpriteImage = 8*2
=18					GCMD_SpriteCollide = 9*2
=64					GCMD_Move = 32*2
=66					GCMD_Line = 33*2
=68					GCMD_FrameRect = 34*2
=70					GCMD_FillRect = 35*2
=72					GCMD_FrameCircle = 36*2
=74					GCMD_FillCircle = 37*2
=80					GCMD_Plot = 40*2
=82					GCMD_SpriteMove = 41*2
=42					GRFirstFreeCode = 42
.ab4a					GRVectorTable:
>ab4a	99 ad					.word	GXInitialise             ; $00 Initialise
>ab4c	b3 ad					.word	GXControlBitmap          ; $01 BitmapCtl
>ab4e	fb ad					.word	GXControlSprite          ; $02 SpriteCtl
>ab50	4b ad					.word	GXClearBitmap            ; $03 Clear
>ab52	8a af					.word	GXSetColourMode          ; $04 Colour
>ab54	52 b1					.word	GXFontHandler            ; $05 DrawFont
>ab56	9a b1					.word	GXSpriteHandler          ; $06 DrawSprite
>ab58	0b b2					.word	GXSelect                 ; $07 SpriteUse
>ab5a	34 b2					.word	GXSelectImage            ; $08 SpriteImage
>ab5c	bb b3					.word	GXCollide                ; $09 SpriteCollide
>ab5e	fd ab					.word	GRUndefined              ; $0a
>ab60	fd ab					.word	GRUndefined              ; $0b
>ab62	fd ab					.word	GRUndefined              ; $0c
>ab64	fd ab					.word	GRUndefined              ; $0d
>ab66	fd ab					.word	GRUndefined              ; $0e
>ab68	fd ab					.word	GRUndefined              ; $0f
>ab6a	fd ab					.word	GRUndefined              ; $10
>ab6c	fd ab					.word	GRUndefined              ; $11
>ab6e	fd ab					.word	GRUndefined              ; $12
>ab70	fd ab					.word	GRUndefined              ; $13
>ab72	fd ab					.word	GRUndefined              ; $14
>ab74	fd ab					.word	GRUndefined              ; $15
>ab76	fd ab					.word	GRUndefined              ; $16
>ab78	fd ab					.word	GRUndefined              ; $17
>ab7a	fd ab					.word	GRUndefined              ; $18
>ab7c	fd ab					.word	GRUndefined              ; $19
>ab7e	fd ab					.word	GRUndefined              ; $1a
>ab80	fd ab					.word	GRUndefined              ; $1b
>ab82	fd ab					.word	GRUndefined              ; $1c
>ab84	fd ab					.word	GRUndefined              ; $1d
>ab86	fd ab					.word	GRUndefined              ; $1e
>ab88	fd ab					.word	GRUndefined              ; $1f
>ab8a	fb ab					.word	GXMove                   ; $20 Move
>ab8c	58 ae					.word	GXLine                   ; $21 Line
>ab8e	d3 af					.word	GXFrameRectangle         ; $22 FrameRect
>ab90	d0 af					.word	GXFillRectangle          ; $23 FillRect
>ab92	02 ac					.word	GXFrameCircle            ; $24 FrameCircle
>ab94	fe ab					.word	GXFillCircle             ; $25 FillCircle
>ab96	fd ab					.word	GRUndefined              ; $26
>ab98	fd ab					.word	GRUndefined              ; $27
>ab9a	b8 af					.word	GXPlotPoint              ; $28 Plot
>ab9c	ca b2					.word	GXMoveSprite             ; $29 SpriteMove
=3					GXMappingPage = 3
=24576					GXMappingAddress = ($2000 * GXMappingPage)
=11					GXEditSlot = 8 + GXMappingPage
=$36					gxzTemp0 = zTemp0
=$38					gxzTemp1 = zTemp1
=$3a					gxzTemp2 = zTemp2
=$3c					gxzScreen = zsTemp
=$627					gxPixelBuffer = numberBuffer
.0671					gxCurrentX:
>0671							.fill 	2
.0673					gxCurrentY:
>0673							.fill 	2
.0675					gxLastX:
>0675							.fill 	2
.0677					gxLastY:
>0677							.fill 	2
.0679					gxX0:
>0679							.fill 	2
.067b					gxY0:
>067b							.fill 	2
.067d					gxX1:
>067d							.fill 	2
.067f					gxY1:
>067f							.fill 	2
.0681					gxSpritesOn:
>0681							.fill 	1
.0682					gxBitmapsOn:
>0682							.fill 	1
.0683					gxBasePage:
>0683							.fill 	1
.0684					gxSpritePage:
>0684							.fill 	1
.0685					gxHeight:
>0685							.fill 	1
.0686					gxMode:
>0686							.fill 	1
.0687					gxColour:
>0687							.fill 	1
.0688					gxEORValue:
>0688							.fill 	1
.0689					gxANDValue:
>0689							.fill 	1
.068a					gxOriginalLUTValue:
>068a							.fill 	1
.068b					gsOffset:
>068b							.fill 	1
.068c					GSCurrentSpriteID:
>068c							.fill 	1
.068d					GSCurrentSpriteAddr:
>068d							.fill 	2
.068f					GXSpriteOffsetBase:
>068f							.fill 	2
.0691					GXSpriteLow:
>0691							.fill 	64
.06d1					GXSpriteHigh:
>06d1							.fill 	64
.ab9e					Export_GXGraphicDraw:
.ab9e	c9 40		cmp #$40			cmp 	#GCMD_Move					; low instructions don't use coordinates
.aba0	b0 06		bcs $aba8			bcs 	_GDCoordinate
.aba2	86 36		stx $36				stx 	gxzTemp0 					; save X/Y
.aba4	84 37		sty $37				sty 	gxzTemp0+1
.aba6	80 4b		bra $abf3			bra 	_GDExecuteA 				; and execute
.aba8					_GDCoordinate:
.aba8	48		pha				pha 								; save AXY
.aba9	da		phx				phx
.abaa	5a		phy				phy
.abab	a2 03		ldx #$03			ldx 	#3 							; copy currentX to lastX
.abad					_GDCopy1:
.abad	bd 71 06	lda $0671,x			lda 	gxCurrentX,x
.abb0	9d 75 06	sta $0675,x			sta 	gxLastX,x
.abb3	ca		dex				dex
.abb4	10 f7		bpl $abad			bpl 	_GDCopy1
.abb6	68		pla				pla 								; update Y
.abb7	8d 73 06	sta $0673			sta 	gxCurrentY
.abba	9c 74 06	stz $0674			stz 	gxCurrentY+1
.abbd	68		pla				pla
.abbe	8d 71 06	sta $0671			sta 	gxCurrentX
.abc1	68		pla				pla 								; get A (command+X.1) back
.abc2	48		pha				pha
.abc3	29 01		and #$01			and 	#1 							; put LSB as MSB of Current.X
.abc5	8d 72 06	sta $0672			sta 	gxCurrentX+1
.abc8	68		pla				pla 								; get command back
.abc9	29 fe		and #$fe			and 	#$FE 						; lose LSB, chuck the stray X bit
.abcb	48		pha				pha 								; push back.
.abcc	c9 52		cmp #$52			cmp 	#GCMD_SpriteMove 			; move sprite does not clip.
.abce	f0 17		beq $abe7			beq 	_GDCopyToWorkArea
.abd0	ad 72 06	lda $0672			lda 	gxCurrentX+1 				; X < 256 X okay
.abd3	f0 07		beq $abdc			beq 	_GDCheckY
.abd5	ad 71 06	lda $0671			lda 	gxCurrentX 					; otherwise X < 320 = 256 + 64
.abd8	c9 40		cmp #$40			cmp 	#64
.abda	b0 08		bcs $abe4			bcs 	_GDError1
.abdc					_GDCheckY:
.abdc	ad 73 06	lda $0673			lda 	gxCurrentY 					; check Y < Height.
.abdf	cd 85 06	cmp $0685			cmp 	gxHeight
.abe2	90 03		bcc $abe7			bcc 	_GDCopyToWorkArea
.abe4					_GDError1:
.abe4	68		pla				pla
.abe5					_GDError2:
.abe5	38		sec				sec
.abe6	60		rts				rts
.abe7					_GDCopyToWorkArea:
.abe7	a2 07		ldx #$07			ldx 	#7 							; copy current and last to gxXY/12 work area
.abe9					_GDCopy2:
.abe9	bd 71 06	lda $0671,x			lda 	gxCurrentX,x
.abec	9d 79 06	sta $0679,x			sta 	gxX0,x
.abef	ca		dex				dex
.abf0	10 f7		bpl $abe9			bpl 	_GDCopy2
.abf2	68		pla				pla 								; get command
.abf3					_GDExecuteA:
.abf3	c9 54		cmp #$54			cmp 	#GRFirstFreeCode*2 			; bad ?
.abf5	b0 ee		bcs $abe5			bcs 	_GDError2
.abf7	aa		tax				tax
.abf8	7c 4a ab	jmp ($ab4a,x)			jmp 	(GRVectorTable,x)
.abfb					GXMove:
.abfb	18		clc				clc
.abfc	60		rts				rts
.abfd					GRUndefined:
>abfd	db						.byte 	$DB 						; causes a break in the emulator
.abfe					GXFillCircle:
.abfe	a9 ff		lda #$ff			lda 	#255
.ac00	80 02		bra $ac04			bra 	GXCircle
.ac02					GXFrameCircle:
.ac02	a9 00		lda #$00			lda 	#0
.ac04					GXCircle:
.ac04	8d 14 07	sta $0714			sta 	gxIsFillMode					; save Fill flag
.ac07	ad 82 06	lda $0682			lda 	gxBitmapsOn
.ac0a	f0 26		beq $ac32			beq 	_GXCFail
.ac0c	20 62 b4	jsr $b462			jsr 	GXSortXY 					; topleft/bottomright
.ac0f	20 3a b3	jsr $b33a			jsr 	GXOpenBitmap 				; start drawing
.ac12	20 04 ad	jsr $ad04			jsr 	GXCircleSetup 				; set up for drawing
.ac15	9c 15 07	stz $0715			stz 	gxYChanged
.ac18					_GXCircleDraw:
.ac18	ad 12 07	lda $0712			lda 	gXCentre					; while x <= y
.ac1b	cd 13 07	cmp $0713			cmp 	gYCentre
.ac1e	90 0a		bcc $ac2a			bcc 	_GXCircleContinue
.ac20	d0 03		bne $ac25			bne 	_GXNoLast
.ac22	20 37 ac	jsr $ac37			jsr 	GXPlot1
.ac25					_GXNoLast:
.ac25	20 42 b3	jsr $b342			jsr 	GXCloseBitmap 				; close the bitmap
.ac28	18		clc				clc
.ac29	60		rts				rts
.ac2a					_GXCircleContinue:
.ac2a	20 34 ac	jsr $ac34			jsr 	GXPlot2 					; draw it
.ac2d	20 b1 ac	jsr $acb1			jsr 	GXCircleMove 				; adjust the coordinates
.ac30	80 e6		bra $ac18			bra 	_GXCircleDraw
.ac32					_GXCFail:
.ac32	38		sec				sec
.ac33	60		rts				rts
.ac34					GXPlot2:
.ac34	20 37 ac	jsr $ac37			jsr 	GXPlot1 						; plot and swap, fall through does twice
.ac37					GXPlot1:
.ac37	ad 13 07	lda $0713			lda 	gYCentre 						; if y = 0, don't do it twice (xor)
.ac3a	f0 03		beq $ac3f			beq 	_GXPlot1Only
.ac3c	20 5b ac	jsr $ac5b			jsr 	GXPlot0 						; plot and negate
.ac3f					_GXPlot1Only:
.ac3f	20 5b ac	jsr $ac5b			jsr 	GXPlot0 						; twice, undoing negation
.ac42	ad 12 07	lda $0712			lda 	gXCentre 						; swap X and Y
.ac45	ae 13 07	ldx $0713			ldx	 	gYCentre
.ac48	8d 13 07	sta $0713			sta 	gYCentre
.ac4b	8e 12 07	stx $0712			stx 	gXCentre
.ac4e	ad 15 07	lda $0715			lda 	gxYChanged 						; toggle Y Changed flag
.ac51	a9 ff		lda #$ff			lda 	#$FF
.ac53	8d 15 07	sta $0715			sta 	gxYChanged
.ac56	60		rts				rts
.ac57	20 5b ac	jsr $ac5b			jsr 	GXPlot0 						; do once
.ac5a	60		rts				rts
.ac5b	ad 14 07	lda $0714	GXPlot0:lda 	gxIsFillMode 					; outline mode, always draw as X or Y will change
.ac5e	f0 05		beq $ac65			beq 	_GXPlot0Always
.ac60	ad 15 07	lda $0715			lda 	gxYChanged						; fill mode, only draw if changed.
.ac63	f0 2d		beq $ac92			beq 	GXPlot0Exit
.ac65					_GXPlot0Always:
.ac65	a2 02		ldx #$02			ldx 	#2 								; copy Y1-A => Y0
.ac67	ad 13 07	lda $0713			lda 	gYCentre
.ac6a	20 93 ac	jsr $ac93			jsr 	GXSubCopy
.ac6d	a2 00		ldx #$00			ldx 	#0 								; copy X1-A => X0,
.ac6f	ad 12 07	lda $0712			lda 	gXCentre
.ac72	20 93 ac	jsr $ac93			jsr 	GXSubCopy
.ac75	48		pha				pha 									; save last offset X
.ac76	20 4a b3	jsr $b34a			jsr 	GXPositionCalc 					; calculate position/offset.
.ac79	68		pla				pla
.ac7a	0a		asl a				asl 	a 								; store 2 x last offset in gxzTemp0
.ac7b	85 36		sta $36				sta 	gxzTemp0
.ac7d	64 37		stz $37				stz 	gxzTemp0+1
.ac7f	26 37		rol $37				rol 	gxzTemp0+1
.ac81	ad 14 07	lda $0714			lda 	gxIsFillMode
.ac84	69 80		adc #$80			adc 	#128
.ac86	20 23 b0	jsr $b023			jsr 	GXDrawLineTemp0 				; routine from Rectangle.
.ac89	38		sec				sec 									; GY = -GY
.ac8a	a9 00		lda #$00			lda 	#0
.ac8c	ed 13 07	sbc $0713			sbc 	gYCentre
.ac8f	8d 13 07	sta $0713			sta 	gYCentre
.ac92					GXPlot0Exit:
.ac92	60		rts				rts
.ac93					GXSubCopy:
.ac93	85 36		sta $36				sta 	gxzTemp0
.ac95	64 37		stz $37				stz 	gxzTemp0+1
.ac97	29 80		and #$80			and 	#$80
.ac99	f0 02		beq $ac9d			beq 	_GXNoSx
.ac9b	c6 37		dec $37				dec 	gxzTemp0+1
.ac9d					_GXNoSx:
.ac9d	38		sec				sec
.ac9e	bd 7d 06	lda $067d,x			lda 	gXX1,x
.aca1	e5 36		sbc $36				sbc 	gxzTemp0
.aca3	9d 79 06	sta $0679,x			sta 	gXX0,x
.aca6	bd 7e 06	lda $067e,x			lda 	gXX1+1,x
.aca9	e5 37		sbc $37				sbc 	gxzTemp0+1
.acab	9d 7a 06	sta $067a,x			sta 	gXX0+1,x
.acae	a5 36		lda $36				lda 	gxzTemp0 						; return A
.acb0	60		rts				rts
.acb1					GXCircleMove:
.acb1	9c 15 07	stz $0715			stz 	gxYChanged 					; clear Y changed flag
.acb4	a5 39		lda $39				lda 	gxzTemp1+1 					; check sign of D
.acb6	10 0d		bpl $acc5			bpl 	_GXEMPositive
.acb8	ee 12 07	inc $0712			inc 	gXCentre 					; X++
.acbb	ad 12 07	lda $0712			lda 	gXCentre
.acbe	20 e4 ac	jsr $ace4			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.acc1	a9 06		lda #$06			lda 	#6  						; and add 6
.acc3	80 15		bra $acda			bra 	_GXEMAddD
.acc5					_GXEMPositive:
.acc5	ee 12 07	inc $0712			inc 	gXCentre					; X++
.acc8	ce 13 07	dec $0713			dec 	gyCentre 					; Y--
.accb	38		sec				sec 								; calculate X-Y
.accc	ad 12 07	lda $0712			lda 	gXCentre
.accf	ed 13 07	sbc $0713			sbc 	gYCentre
.acd2	20 e4 ac	jsr $ace4			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.acd5	a9 0a		lda #$0a			lda 	#10  						; and add 10
.acd7	ce 15 07	dec $0715			dec 	gxYChanged
.acda					_GXEMAddD:
.acda	18		clc				clc
.acdb	65 38		adc $38				adc 	gxzTemp1
.acdd	85 38		sta $38				sta 	gxzTemp1
.acdf	90 02		bcc $ace3			bcc 	_GXEMNoCarry
.ace1	e6 39		inc $39				inc 	gxzTemp1+1
.ace3					_GXEMNoCarry:
.ace3	60		rts				rts
.ace4					_GXAdd4TimesToD:
.ace4	85 36		sta $36				sta 	gxzTemp0 					; make 16 bit signed.
.ace6	29 80		and #$80			and 	#$80
.ace8	f0 02		beq $acec			beq 	_GXA4Unsigned
.acea	a9 ff		lda #$ff			lda 	#$FF
.acec					_GXA4Unsigned:
.acec	85 37		sta $37				sta 	gxzTemp0+1
.acee	06 36		asl $36				asl 	gxzTemp0  					; x 4
.acf0	26 37		rol $37				rol 	gxzTemp0+1
.acf2	06 36		asl $36				asl 	gxzTemp0
.acf4	26 37		rol $37				rol 	gxzTemp0+1
.acf6	18		clc				clc 								; add
.acf7	a5 36		lda $36				lda		gxzTemp0
.acf9	65 38		adc $38				adc 	gxzTemp1
.acfb	85 38		sta $38				sta 	gxzTemp1
.acfd	a5 37		lda $37				lda		gxzTemp0+1
.acff	65 39		adc $39				adc 	gxzTemp1+1
.ad01	85 39		sta $39				sta 	gxzTemp1+1
.ad03	60		rts				rts
.ad04					GXCircleSetup:
.ad04	38		sec				sec
.ad05	ad 7f 06	lda $067f			lda 	gxY1
.ad08	ed 7b 06	sbc $067b			sbc 	gxY0
.ad0b	4a		lsr a				lsr 	a
.ad0c	8d 11 07	sta $0711			sta 	gxRadius
.ad0f	a2 00		ldx #$00			ldx 	#0
.ad11	20 33 ad	jsr $ad33			jsr 	_GXCalculateCentre
.ad14	a2 02		ldx #$02			ldx 	#2
.ad16	20 33 ad	jsr $ad33			jsr 	_GXCalculateCentre
.ad19	9c 12 07	stz $0712			stz 	gXCentre
.ad1c	ad 11 07	lda $0711			lda 	gxRadius
.ad1f	8d 13 07	sta $0713			sta 	gYCentre
.ad22	0a		asl a				asl 	a 							; R x 2
.ad23	85 36		sta $36				sta 	gxzTemp0
.ad25	38		sec				sec
.ad26	a9 03		lda #$03			lda 	#3
.ad28	e5 36		sbc $36				sbc 	gxzTemp0
.ad2a	85 38		sta $38				sta 	gxzTemp1
.ad2c	a9 00		lda #$00			lda 	#0
.ad2e	e9 00		sbc #$00			sbc 	#0
.ad30	85 39		sta $39				sta 	gxzTemp1+1
.ad32	60		rts				rts
.ad33					_GXCalculateCentre:
.ad33	38		sec				sec
.ad34	bd 7d 06	lda $067d,x			lda 	gxX1,x
.ad37	7d 79 06	adc $0679,x			adc 	gXX0,x
.ad3a	9d 7d 06	sta $067d,x			sta 	gXX1,x
.ad3d	bd 7e 06	lda $067e,x			lda 	gXX1+1,x
.ad40	7d 7a 06	adc $067a,x			adc 	gXX0+1,x
.ad43	4a		lsr a				lsr 	a
.ad44	9d 7e 06	sta $067e,x			sta 	gXX1+1,x
.ad47	7e 7d 06	ror $067d,x			ror 	gXX1,x
.ad4a	60		rts				rts
.0711					gxRadius:
>0711							.fill 	1
.0712					gXCentre:
>0712							.fill 	1
.0713					gYCentre:
>0713							.fill 	1
.0714					gxIsFillMode:
>0714							.fill 	1
.0715					gxYChanged:
>0715							.fill  	1
=64000					ScreenSize200 = 320 * 200
=76800					ScreenSize240 = 320 * 240
.ad4b					GXClearBitmap:
.ad4b	ad 82 06	lda $0682			lda 	gxBitmapsOn 				; check BMP running.
.ad4e	f0 24		beq $ad74			beq 	_GXCBFail
.ad50	20 3a b3	jsr $b33a			jsr 	GXOpenBitmap 				; start access
.ad53	a0 07		ldy #$07			ldy 	#ScreenSize200 / 8192 		; X is pages to clear
.ad55	ad 85 06	lda $0685			lda 	gxHeight
.ad58	c9 c8		cmp #$c8			cmp 	#200 						; 200 ?
.ad5a	a0 09		ldy #$09			ldy 	#ScreenSize240 / 8192
.ad5c					_GXCalcLastPage:
.ad5c	98		tya				tya 								; add to base page
.ad5d	18		clc				clc
.ad5e	6d 83 06	adc $0683			adc 	gxBasePage
.ad61	85 0b		sta $0b				sta 	GXEditSlot  				; clear from this page back
.ad63					_GXClearAll:
.ad63	20 76 ad	jsr $ad76			jsr 	_GXClearBlock 				; clear 8k block
.ad66	c6 0b		dec $0b				dec 	GXEditSlot  				; back to previous
.ad68	a5 0b		lda $0b				lda 	GXEditSlot
.ad6a	cd 83 06	cmp $0683			cmp 	gxBasePage 					; until before base page
.ad6d	b0 f4		bcs $ad63			bcs 	_GXClearAll
.ad6f	20 42 b3	jsr $b342			jsr 	GXCloseBitmap	 			; stop access
.ad72	18		clc				clc
.ad73	60		rts				rts
.ad74					_GXCBFail:
.ad74	38		sec				sec
.ad75	60		rts				rts
.ad76					_GXClearBlock:
.ad76	a9 00		lda #$00			lda 	#((GXMappingAddress) & $FF)
.ad78	85 38		sta $38				sta 	0+gxzTemp1
.ad7a	a9 60		lda #$60			lda 	#((GXMappingAddress) >> 8)
.ad7c	85 39		sta $39				sta 	1+gxzTemp1
.ad7e					_GXCB0:
.ad7e	a5 36		lda $36				lda 	gxzTemp0
.ad80	a0 00		ldy #$00			ldy 	#0
.ad82					_GXCB1:
.ad82	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad84	c8		iny				iny
.ad85	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad87	c8		iny				iny
.ad88	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad8a	c8		iny				iny
.ad8b	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad8d	c8		iny				iny
.ad8e	d0 f2		bne $ad82			bne 	_GXCB1
.ad90	e6 39		inc $39				inc 	gxzTemp1+1
.ad92	a5 39		lda $39				lda 	gxzTemp1+1
.ad94	c9 80		cmp #$80			cmp	 	#(GXMappingAddress >> 8)+$20
.ad96	d0 e6		bne $ad7e			bne 	_GXCB0
.ad98	60		rts				rts
.ad99					GXInitialise:
.ad99	64 01		stz $01				stz 	1
.ad9b	a9 01		lda #$01			lda 	#1
.ad9d	8d 00 d0	sta $d000			sta 	$D000
.ada0	18		clc				clc
.ada1	9c 81 06	stz $0681			stz 	GXSpritesOn
.ada4	9c 82 06	stz $0682			stz 	GXBitmapsOn
.ada7	a2 0f		ldx #$0f			ldx 	#15
.ada9					_GXIClear:
.ada9	9e 71 06	stz $0671,x			stz 	gxCurrentX,x
.adac	ca		dex				dex
.adad	10 fa		bpl $ada9			bpl 	_GXIClear
.adaf	20 4a ae	jsr $ae4a			jsr 	GXClearSpriteStore
.adb2	60		rts				rts
.adb3					GXControlBitmap:
.adb3	64 01		stz $01				stz 	1
.adb5	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.adb7	29 01		and #$01			and 	#1 							; set bitmap flag
.adb9	8d 82 06	sta $0682			sta 	gxBitmapsOn
.adbc	4a		lsr a				lsr 	a 							; bit 0 into carry.
.adbd	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.adc0	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.adc2	29 f7		and #$f7			and 	#$F7 						; clear bitmap bit
.adc4	90 02		bcc $adc8			bcc 	_CBNotOn
.adc6	09 08		ora #$08			ora 	#$08 						; bitmap on if 1 on 0 off
.adc8					_CBNotOn:
.adc8	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.adcb	a5 36		lda $36				lda 	gxzTemp0 					; get control settings (bits 0-2)
.adcd	29 07		and #$07			and 	#7
.adcf	8d 00 d1	sta $d100			sta 	$D100 						; write in Vicky Bitmap Control Register #0
.add2	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.add4	d0 02		bne $add8			bne 	_CBNotDefault
.add6	a9 08		lda #$08			lda 	#8  						; if zero, use 8 e.g. bitmap at $10000
.add8					_CBNotDefault:
.add8	8d 83 06	sta $0683			sta 	gxBasePage
.addb	20 3c ae	jsr $ae3c			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.adde	a5 37		lda $37				lda 	gxzTemp0+1 					; copy address into Bitmap address registers
.ade0	8d 03 d1	sta $d103			sta 	$D103
.ade3	a5 36		lda $36				lda 	gxzTemp0
.ade5	8d 02 d1	sta $d102			sta 	$D102
.ade8	9c 01 d1	stz $d101			stz 	$D101
.adeb	a2 f0		ldx #$f0			ldx 	#240 						; height is 240
.aded	ad 01 d0	lda $d001			lda 	$D001 						; read MCR bit 0
.adf0	29 01		and #$01			and 	#1
.adf2	f0 02		beq $adf6			beq 	_CBHaveHeight
.adf4	a2 c8		ldx #$c8			ldx 	#200 						; if bit 0 set 320x200
.adf6					_CBHaveHeight
.adf6	8e 85 06	stx $0685			stx 	gxHeight
.adf9	18		clc				clc
.adfa	60		rts				rts
.adfb					GXControlSprite:
.adfb	64 01		stz $01				stz 	1
.adfd	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.adff	29 01		and #$01			and 	#1 							; set sprites flag
.ae01	8d 81 06	sta $0681			sta 	gxSpritesOn
.ae04	4a		lsr a				lsr 	a 							; bit 0 into carry.
.ae05	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.ae08	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.ae0a	29 df		and #$df			and 	#$DF 						; clear sprite bit
.ae0c	90 02		bcc $ae10			bcc 	_CSNotOn
.ae0e	09 20		ora #$20			ora 	#$20 						; sprite on if 1 on 0 off
.ae10					_CSNotOn:
.ae10	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.ae13	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.ae15	d0 02		bne $ae19			bne 	_CSNotDefault
.ae17	a9 18		lda #$18			lda 	#24  						; if zero, use 24 e.g. sprites at $30000
.ae19					_CSNotDefault:
.ae19	8d 84 06	sta $0684			sta 	gxSpritePage
.ae1c	20 3c ae	jsr $ae3c			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.ae1f	a5 36		lda $36				lda 	zTemp0
.ae21	8d 8f 06	sta $068f			sta 	GXSpriteOffsetBase
.ae24	a5 37		lda $37				lda 	zTemp0+1
.ae26	8d 90 06	sta $0690			sta 	GXSpriteOffsetBase+1
.ae29	a2 00		ldx #$00			ldx 	#0 							; disable all sprites, clears all sprite memory.
.ae2b					_CSClear:
.ae2b	9e 00 d9	stz $d900,x			stz 	$D900,x
.ae2e	9e 00 da	stz $da00,x			stz 	$DA00,x
.ae31	ca		dex				dex
.ae32	d0 f7		bne $ae2b			bne 	_CSClear
.ae34	9c 8e 06	stz $068e			stz 	GSCurrentSpriteAddr+1 		; no sprite selected.
.ae37	20 4a ae	jsr $ae4a			jsr 	GXClearSpriteStore
.ae3a	18		clc				clc
.ae3b	60		rts				rts
.ae3c					GXCalculateBaseAddress:
.ae3c	85 36		sta $36				sta 	gxzTemp0
.ae3e	64 37		stz $37				stz 	gxzTemp0+1
.ae40	a9 05		lda #$05			lda 	#5
.ae42					_GXShift:
.ae42	06 36		asl $36				asl 	gxzTemp0
.ae44	26 37		rol $37				rol 	gxzTemp0+1
.ae46	3a		dec a				dec		a
.ae47	d0 f9		bne $ae42			bne 	_GXShift
.ae49	60		rts				rts
.ae4a					GXClearSpriteStore:
.ae4a	a2 3f		ldx #$3f			ldx 	#63 						; erase 64 sprite store elements
.ae4c					_GXCSSLoop:
.ae4c	9e d1 06	stz $06d1,x			stz 	GXSpriteHigh,x
.ae4f	a9 80		lda #$80			lda 	#$80 						; set the 'hidden' bit.
.ae51	9d 91 06	sta $0691,x			sta 	GXSpriteLow,x
.ae54	ca		dex				dex
.ae55	10 f5		bpl $ae4c			bpl 	_GXCSSLoop
.ae57	60		rts				rts
.ae58					GXLine:
.ae58	ad 82 06	lda $0682			lda 	GXBitmapsOn
.ae5b	f0 28		beq $ae85			beq 	_GXLFail
.ae5d	20 3a b3	jsr $b33a			jsr 	GXOpenBitmap
.ae60	20 80 b4	jsr $b480			jsr 	GXSortY						; sort pairs so Y1 >= Y0 e.g. top to bottom.
.ae63	20 2b af	jsr $af2b			jsr 	GXLineSetup 				; the calculations in the linescanner constructor
.ae66	20 4a b3	jsr $b34a			jsr 	GXPositionCalc 				; calculate position/offset.
.ae69					_GXDrawLoop:
.ae69	ac 8b 06	ldy $068b			ldy 	gsOffset 					; draw the pixel
.ae6c	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.ae6e	2d 89 06	and $0689			and 	gxANDValue
.ae71	4d 88 06	eor $0688			eor 	gxEORValue
.ae74	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.ae76	20 87 ae	jsr $ae87			jsr 	GXLineIsComplete 			; is the line complete ?
.ae79	f0 05		beq $ae80			beq 	_GXLExit
.ae7b	20 a2 ae	jsr $aea2			jsr 	GXLineAdvance 				; code as per advance method
.ae7e	80 e9		bra $ae69			bra 	_GXDrawLoop
.ae80					_GXLExit:
.ae80	20 42 b3	jsr $b342			jsr 	GXCloseBitmap
.ae83	18		clc				clc
.ae84	60		rts				rts
.ae85					_GXLFail:
.ae85	38		sec				sec
.ae86	60		rts				rts
.ae87					GXLineIsComplete:
.ae87	ad 18 07	lda $0718			lda 	GXIsDiffYLarger 			; is dy larger
.ae8a	d0 0f		bne $ae9b			bne 	_GXLICCompareY 				; if so compare Y1/Y0
.ae8c	ad 79 06	lda $0679			lda 	GXX0 						; compare X, LSB and MSB
.ae8f	4d 7d 06	eor $067d			eor 	GXX1
.ae92	d0 06		bne $ae9a			bne 	_GXLICExit
.ae94	ad 7a 06	lda $067a			lda 	GXX0+1
.ae97	4d 7e 06	eor $067e			eor 	GXX1+1
.ae9a					_GXLICExit:
.ae9a	60		rts				rts
.ae9b					_GXLICCompareY:
.ae9b	ad 7f 06	lda $067f			lda 	GXY1
.ae9e	4d 7b 06	eor $067b			eor 	GXY0
.aea1	60		rts				rts
.aea2					GXLineAdvance:
.aea2	18		clc				clc 								; add adjust to position
.aea3	ad 1a 07	lda $071a			lda 	GXPosition
.aea6	6d 1b 07	adc $071b			adc 	GXAdjust
.aea9	8d 1a 07	sta $071a			sta 	GXPosition
.aeac	9c 1d 07	stz $071d			stz 	GXAddSelect 				; clear add select flag
.aeaf	b0 05		bcs $aeb6			bcs 	_GXLAOverflow 				; if carry out, overflowed.
.aeb1	cd 1c 07	cmp $071c			cmp 	GXTotal 					; if exceeded total
.aeb4	90 0a		bcc $aec0			bcc 	_GXLANoExtra
.aeb6					_GXLAOverflow:
.aeb6	ce 1d 07	dec $071d			dec 	GXAddSelect 				; set addselect to $FF
.aeb9	38		sec				sec 								; subtract total and write back
.aeba	ed 1c 07	sbc $071c			sbc 	GXTotal
.aebd	8d 1a 07	sta $071a			sta 	GXPosition
.aec0					_GXLANoExtra:
.aec0	ad 18 07	lda $0718			lda 	GXIsDiffYLarger
.aec3	f0 0d		beq $aed2			beq 	_GXDXLarger
.aec5	20 24 af	jsr $af24			jsr 	GXIncrementY
.aec8	ad 1d 07	lda $071d			lda 	GXAddSelect
.aecb	f0 10		beq $aedd			beq 	_GXLAExit
.aecd	20 de ae	jsr $aede			jsr 	GXAdjustX
.aed0	80 0b		bra $aedd			bra 	_GXLAExit
.aed2					_GXDXLarger:
.aed2	20 de ae	jsr $aede			jsr 	GXAdjustX
.aed5	ad 1d 07	lda $071d			lda 	GXAddSelect
.aed8	f0 03		beq $aedd			beq 	_GXLAExit
.aeda	20 24 af	jsr $af24			jsr 	GXIncrementY
.aedd					_GXLAExit:
.aedd	60		rts				rts
.aede					GXAdjustX:
.aede	ad 19 07	lda $0719			lda 	GXDXNegative
.aee1	10 25		bpl $af08			bpl 	_GXAXRight
.aee3	ad 79 06	lda $0679			lda 	GXX0
.aee6	d0 03		bne $aeeb			bne 	_GXAXNoBorrow
.aee8	ce 7a 06	dec $067a			dec 	GXX0+1
.aeeb					_GXAXNoBorrow:
.aeeb	ce 79 06	dec $0679			dec 	GXX0
.aeee	ce 8b 06	dec $068b			dec 	gsOffset 					; pixel left
.aef1	ad 8b 06	lda $068b			lda 	gsOffset
.aef4	c9 ff		cmp #$ff			cmp 	#$FF
.aef6	d0 0f		bne $af07			bne 	_GXAYExit 					; underflow
.aef8	c6 3d		dec $3d				dec 	gxzScreen+1 					; borrow
.aefa	a5 3d		lda $3d				lda 	gxzScreen+1 					; gone off page
.aefc	c9 60		cmp #$60			cmp 	#GXMappingAddress >> 8
.aefe	b0 07		bcs $af07			bcs 	_GXAYExit
.af00	18		clc				clc
.af01	69 20		adc #$20			adc 	#$20 						; fix up
.af03	85 3d		sta $3d				sta 	gxzScreen+1
.af05	c6 0b		dec $0b				dec 	GXEditSlot 				; back one page
.af07					_GXAYExit:
.af07	60		rts				rts
.af08					_GXAXRight:
.af08	ee 79 06	inc $0679			inc 	GXX0
.af0b	d0 03		bne $af10			bne 	_GXAXNoCarry
.af0d	ee 7a 06	inc $067a			inc 	GXX0+1
.af10					_GXAXNoCarry:
.af10	ee 8b 06	inc $068b			inc 	gsOffset 					; pixel right
.af13	d0 0e		bne $af23			bne 	_GXAXExit 					; if not overflowed, exit.
.af15	e6 3d		inc $3d				inc 	gxzScreen+1 					; next line
.af17	a5 3d		lda $3d				lda 	gxzScreen+1
.af19	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.af1b	90 06		bcc $af23			bcc 	_GXAXExit
.af1d	e9 20		sbc #$20			sbc 	#$20 						; fix up
.af1f	85 3d		sta $3d				sta 	gxzScreen+1
.af21	e6 0b		inc $0b				inc 	GXEditSlot 				; next page
.af23					_GXAXExit:
.af23	60		rts				rts
.af24					GXIncrementY:
.af24	ee 7b 06	inc $067b			inc 	GXY0
.af27	20 a0 b3	jsr $b3a0			jsr 	GXMovePositionDown
.af2a	60		rts				rts
.af2b					GXLineSetup:
.af2b	ad 7f 06	lda $067f			lda 	GXY1
.af2e	38		sec				sec
.af2f	ed 7b 06	sbc $067b			sbc 	GXY0
.af32	4a		lsr a				lsr 	a
.af33	8d 17 07	sta $0717			sta 	GXDiffY
.af36	9c 19 07	stz $0719			stz 	GXDXNegative 				; clear -ve flag
.af39	38		sec				sec
.af3a	ad 7d 06	lda $067d			lda 	GXX1
.af3d	ed 79 06	sbc $0679			sbc 	GXX0
.af40	8d 16 07	sta $0716			sta 	GXDiffX
.af43	ad 7e 06	lda $067e			lda 	GXX1+1 						; calculate MSB
.af46	ed 7a 06	sbc $067a			sbc 	GXX0+1
.af49	6a		ror a				ror 	a 							; rotate bit into DiffX halving it
.af4a	6e 16 07	ror $0716			ror 	GXDiffX
.af4d	0a		asl a				asl 	a
.af4e	10 0c		bpl $af5c			bpl 	_GDXNotNegative
.af50	a9 00		lda #$00			lda 	#0 							; make absolute value of |dx|
.af52	38		sec				sec
.af53	ed 16 07	sbc $0716			sbc 	GXDiffX
.af56	8d 16 07	sta $0716			sta 	GXDiffX
.af59	ce 19 07	dec $0719			dec 	GXDXNegative 				; -ve flag = $FF.
.af5c					_GDXNotNegative:
.af5c	9c 18 07	stz $0718			stz 	GXIsDiffYLarger 			; clear larger flag
.af5f	ad 17 07	lda $0717			lda 	GXDiffY 					; set adjust and total.
.af62	8d 1b 07	sta $071b			sta 	GXAdjust
.af65	ad 16 07	lda $0716			lda 	GXDiffX
.af68	8d 1c 07	sta $071c			sta 	GXTotal
.af6b	ad 17 07	lda $0717			lda 	GXDiffY 					; if dy > dx
.af6e	cd 16 07	cmp $0716			cmp 	GXDiffX
.af71	90 0f		bcc $af82			bcc 	_GDXNotLarger
.af73	ce 18 07	dec $0718			dec 	GXIsDiffYLarger 			; set the dy larger flag
.af76	ad 16 07	lda $0716			lda 	GXDiffX 					; set adjust and total other way round
.af79	8d 1b 07	sta $071b			sta 	GXAdjust
.af7c	ad 17 07	lda $0717			lda 	GXDiffY
.af7f	8d 1c 07	sta $071c			sta 	GXTotal
.af82					_GDXNotLarger:
.af82	ad 1c 07	lda $071c			lda 	GXTotal
.af85	4a		lsr a				lsr 	a
.af86	8d 1a 07	sta $071a			sta 	GXPosition
.af89	60		rts				rts
.0716					GXDiffX:
>0716							.fill 	1
.0717					GXDiffY:
>0717							.fill 	1
.0718					GXIsDiffYLarger:
>0718							.fill 	1
.0719					GXDXNegative:
>0719							.fill 	1
.071a					GXPosition:
>071a							.fill 	1
.071b					GXAdjust:
>071b							.fill 	1
.071c					GXTotal:
>071c							.fill 	1
.071d					GXAddSelect:
>071d							.fill 	1
.af8a					GXSetColourMode:
.af8a	a6 36		ldx $36				ldx 	gxzTemp0
.af8c	8e 87 06	stx $0687			stx 	gxColour 								; set colour
.af8f	a5 37		lda $37				lda 	gxzTemp0+1 								;
.af91	8d 86 06	sta $0686			sta 	gxMode 									; set mode
.af94	29 03		and #$03			and 	#3 										; only interested in bits 0-3
.af96	9c 89 06	stz $0689			stz 	gxANDValue 								; initially AND with 0, and EOR with Colour
.af99	ae 87 06	ldx $0687			ldx 	gxColour
.af9c	8e 88 06	stx $0688			stx 	gxEORValue
.af9f	c9 02		cmp #$02			cmp 	#2 										; if mode 2/3 And with colour
.afa1	90 03		bcc $afa6			bcc 	_GXSDCNotAndColour
.afa3	8e 89 06	stx $0689			stx 	gxANDValue
.afa6					_GXSDCNotAndColour:
.afa6	d0 03		bne $afab			bne 	_GXSDCNotAnd 							; mode 2, Don't EOR with colour
.afa8	9c 88 06	stz $0688			stz 	gxEORValue
.afab					_GXSDCNotAnd:
.afab	4a		lsr a				lsr 	a 										; if bit 0 set, 1's complement AND value
.afac	90 08		bcc $afb6			bcc 	_GXSDCNoFlip
.afae	ad 89 06	lda $0689			lda	 	gxANDValue
.afb1	49 ff		eor #$ff			eor 	#$FF
.afb3	8d 89 06	sta $0689			sta 	gxANDValue
.afb6					_GXSDCNoFlip:
.afb6	18		clc				clc
.afb7	60		rts				rts
.afb8					GXPlotPoint:
.afb8	20 3a b3	jsr $b33a			jsr 	GXOpenBitmap 				; start drawing
.afbb	20 4a b3	jsr $b34a			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.afbe	ac 8b 06	ldy $068b			ldy 	gsOffset
.afc1	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.afc3	2d 89 06	and $0689			and 	gxANDValue
.afc6	4d 88 06	eor $0688			eor 	gxEORValue
.afc9	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.afcb	20 42 b3	jsr $b342			jsr 	GXCloseBitmap 				; stop drawing and exit
.afce	18		clc				clc
.afcf	60		rts				rts
.afd0					GXFillRectangle:
.afd0	38		sec				sec
.afd1	80 01		bra $afd4			bra 	GXRectangle
.afd3					GXFrameRectangle:
.afd3	18		clc				clc
.afd4					GXRectangle:
.afd4	ad 82 06	lda $0682			lda 	gxBitmapsOn
.afd7	f0 35		beq $b00e			beq 	_GXRFail
.afd9	08		php				php 								; save Fill flag (CS)
.afda	20 3a b3	jsr $b33a			jsr 	GXOpenBitmap 				; start drawing
.afdd	20 62 b4	jsr $b462			jsr 	GXSortXY 					; sort both X and Y so top left/bottom right
.afe0	20 4a b3	jsr $b34a			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.afe3	38		sec				sec 								; sec = Draw line
.afe4	20 10 b0	jsr $b010			jsr 	GXDrawLineX1X0 				; draw a line length X1-X0
.afe7	ad 7b 06	lda $067b			lda 	gxY0 						; reached end of rectangle ?
.afea	cd 7f 06	cmp $067f			cmp 	gxY1
.afed	f0 19		beq $b008			beq 	_GXRectangleExit
.afef					_GXRectLoop:
.afef	20 a0 b3	jsr $b3a0			jsr 	GXMovePositionDown 			; down one.
.aff2	ee 7b 06	inc $067b			inc 	gxY0 						; change Y pos
.aff5	ad 7b 06	lda $067b			lda 	gxY0 						; reached last line
.aff8	cd 7f 06	cmp $067f			cmp 	gXY1
.affb	f0 07		beq $b004			beq 	_GXLastLine
.affd	28		plp				plp 								; get flag back
.affe	08		php				php
.afff	20 10 b0	jsr $b010			jsr 	GXDrawLineX1X0 				; draw horizontal line
.b002	80 eb		bra $afef			bra 	_GXRectLoop
.b004					_GXLastLine:
.b004	38		sec				sec
.b005	20 10 b0	jsr $b010			jsr 	GXDrawLineX1X0
.b008					_GXRectangleExit:
.b008	68		pla				pla 								; throw fill flag.
.b009	20 42 b3	jsr $b342			jsr 	GXCloseBitmap 				; stop drawing and exit
.b00c	18		clc				clc
.b00d	60		rts				rts
.b00e					_GXRFail:
.b00e	38		sec				sec
.b00f	60		rts				rts
.b010					GXDrawLineX1X0:
.b010	08		php				php 								; save solid/either-end
.b011	38		sec				sec
.b012	ad 7d 06	lda $067d			lda		gXX1
.b015	ed 79 06	sbc $0679			sbc 	gXX0
.b018	85 36		sta $36				sta 	gxzTemp0
.b01a	ad 7e 06	lda $067e			lda 	gXX1+1
.b01d	ed 7a 06	sbc $067a			sbc 	gXX0+1
.b020	85 37		sta $37				sta 	gxzTemp0+1
.b022	28		plp				plp
.b023					GXDrawLineTemp0:
.b023	a5 3c		lda $3c				lda 	gxzScreen 						; push gxzScreen, gsOffset and GXEditSlot on stack
.b025	48		pha				pha
.b026	a5 3d		lda $3d				lda 	gxzScreen+1
.b028	48		pha				pha
.b029	ad 8b 06	lda $068b			lda 	gsOffset
.b02c	48		pha				pha
.b02d	a5 0b		lda $0b				lda 	GXEditSlot
.b02f	48		pha				pha
.b030	ac 8b 06	ldy $068b			ldy 	gsOffset 					; Y offset
.b033	90 1e		bcc $b053			bcc 	_GXDLTEndPoints 			; if CC draw end points only.
.b035					_GXDLTLine:
.b035	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.b037	2d 89 06	and $0689			and 	gxANDValue
.b03a	4d 88 06	eor $0688			eor 	gxEORValue
.b03d	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b03f	a5 36		lda $36				lda 	gxzTemp0 					; decrement counter
.b041	d0 04		bne $b047			bne 	_GXDLTNoBorrow
.b043	c6 37		dec $37				dec 	gxzTemp0+1 					; borrow, if goes -ve then exit
.b045	30 2e		bmi $b075			bmi 	_GXDLTExit
.b047					_GXDLTNoBorrow:
.b047	c6 36		dec $36				dec 	gxzTemp0
.b049	c8		iny				iny 								; next slot.
.b04a	d0 e9		bne $b035			bne 	_GXDLTLine
.b04c	e6 3d		inc $3d				inc 	gxzScreen+1 					; carry to next
.b04e	20 83 b0	jsr $b083			jsr 	GXDLTCheckWrap				; check for new page.
.b051	80 e2		bra $b035			bra 	_GXDLTLine
.b053					_GXDLTEndPoints:
.b053	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.b055	2d 89 06	and $0689			and 	gxANDValue
.b058	4d 88 06	eor $0688			eor 	gxEORValue
.b05b	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b05d	98		tya				tya 								; advance to right side
.b05e	18		clc				clc
.b05f	65 36		adc $36				adc 	gxzTemp0
.b061	a8		tay				tay
.b062	a5 3d		lda $3d				lda 	gxzScreen+1
.b064	65 37		adc $37				adc 	gxzTemp0+1
.b066	85 3d		sta $3d				sta 	gxzScreen+1
.b068	20 83 b0	jsr $b083			jsr 	GXDLTCheckWrap 			; fix up.
.b06b	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.b06d	2d 89 06	and $0689			and 	gxANDValue
.b070	4d 88 06	eor $0688			eor 	gxEORValue
.b073	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b075					_GXDLTExit:
.b075	68		pla				pla
.b076	85 0b		sta $0b				sta 	GXEditSlot
.b078	68		pla				pla
.b079	8d 8b 06	sta $068b			sta 	gsOffset
.b07c	68		pla				pla
.b07d	85 3d		sta $3d				sta 	gxzScreen+1
.b07f	68		pla				pla
.b080	85 3c		sta $3c				sta 	gxzScreen
.b082	60		rts				rts
.b083					GXDLTCheckWrap:
.b083	a5 3d		lda $3d				lda 	gxzScreen+1 					; check end of page
.b085	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8)
.b087	90 06		bcc $b08f			bcc 	_GXDLTCWExit
.b089	e9 20		sbc #$20			sbc 	#$20 						; fix up
.b08b	85 3d		sta $3d				sta 	gxzScreen+1
.b08d	e6 0b		inc $0b				inc 	GXEditSlot
.b08f					_GXDLTCWExit:
.b08f	60		rts				rts
.b090					GXDrawGraphicElement:
.b090	8d 1e 07	sta $071e			sta 	gxSize 						; save size
.b093	3a		dec a				dec 	a
.b094	8d 1f 07	sta $071f			sta 	gxMask 						; and mask
.b097	ad 82 06	lda $0682			lda 	gxBitmapsOn 				; check BMP on
.b09a	f0 67		beq $b103			beq 	_GXSLFail
.b09c	ad 7b 06	lda $067b			lda 	gxY0 						; push Y on stack
.b09f	48		pha				pha
.b0a0	8c 21 07	sty $0721			sty 	gxAcquireVector+1 			; and acquisition vector
.b0a3	8e 20 07	stx $0720			stx 	gxAcquireVector
.b0a6	20 3a b3	jsr $b33a			jsr 	gxOpenBitmap 				; open the bitmap.
.b0a9	ad 23 07	lda $0723			lda 	gxUseMode 					; scale bits
.b0ac	4a		lsr a				lsr 	a
.b0ad	4a		lsr a				lsr 	a
.b0ae	4a		lsr a				lsr 	a
.b0af	29 07		and #$07			and		#7
.b0b1	1a		inc a				inc 	a
.b0b2	8d 22 07	sta $0722			sta 	gxScale
.b0b5	64 38		stz $38				stz 	gxzTemp1					; start first line
.b0b7					_GXGELoop:
.b0b7	a5 38		lda $38				lda 	gxzTemp1 					; current line number to read.
.b0b9	2c 23 07	bit $0723			bit 	gxUseMode 					; check for flip.
.b0bc	10 06		bpl $b0c4			bpl		_GXNoVFlip
.b0be	ad 1f 07	lda $071f			lda 	gxMask
.b0c1	38		sec				sec
.b0c2	e5 38		sbc $38				sbc 	gxzTemp1
.b0c4					_GXNoVFlip:
.b0c4	aa		tax				tax 								; get the Xth line.
.b0c5	20 05 b1	jsr $b105			jsr 	_GXCallAcquire 				; get that data.
.b0c8	ad 22 07	lda $0722			lda 	gxScale 					; do scale identical copies of that line.
.b0cb	85 39		sta $39				sta 	gxzTemp1+1
.b0cd					_GXGELoop2:
.b0cd	ad 7b 06	lda $067b			lda 	gxY0 						; off screen
.b0d0	cd 85 06	cmp $0685			cmp 	gxHeight
.b0d3	b0 10		bcs $b0e5			bcs 	_GXDGEExit
.b0d5	20 08 b1	jsr $b108			jsr 	GXRenderOneLine 			; render line
.b0d8	c6 39		dec $39				dec 	gxzTemp1+1 					; scale times.
.b0da	d0 f1		bne $b0cd			bne 	_GXGELoop2
.b0dc	e6 38		inc $38				inc 	gxzTemp1 					; done all lines.
.b0de	a5 38		lda $38				lda 	gxzTemp1
.b0e0	cd 1e 07	cmp $071e			cmp 	gxSize
.b0e3	d0 d2		bne $b0b7			bne 	_GXGELoop
.b0e5					_GXDGEExit:
.b0e5	68		pla				pla 								; restore Y for next time
.b0e6	8d 7b 06	sta $067b			sta 	gxY0
.b0e9	ae 22 07	ldx $0722			ldx 	gxScale 					; get scale (1-8)
.b0ec					_GXShiftLeft:
.b0ec	18		clc				clc
.b0ed	ad 1e 07	lda $071e			lda 	gxSize
.b0f0	6d 79 06	adc $0679			adc 	gxX0
.b0f3	8d 79 06	sta $0679			sta 	gxX0
.b0f6	90 03		bcc $b0fb			bcc 	_GXSLNoCarry
.b0f8	ee 7a 06	inc $067a			inc 	gxX0+1
.b0fb					_GXSLNoCarry:
.b0fb	ca		dex				dex
.b0fc	d0 ee		bne $b0ec			bne 	_GXShiftLeft
.b0fe	20 42 b3	jsr $b342			jsr 	GXCloseBitmap
.b101	18		clc				clc
.b102	60		rts				rts
.b103					_GXSLFail:
.b103	38		sec				sec
.b104	60		rts				rts
.b105					_GXCallAcquire:
.b105	6c 20 07	jmp ($0720)			jmp 	(gxAcquireVector)
.b108					GXRenderOneLine:
.b108	20 4a b3	jsr $b34a			jsr 	GXPositionCalc 				; calculate position/offset.
.b10b	ac 8b 06	ldy $068b			ldy 	gsOffset 					; Y contains position.
.b10e	64 3a		stz $3a				stz 	gxzTemp2 					; do size pixels
.b110					_GXROLLoop1:
.b110	ad 22 07	lda $0722			lda 	gxScale 					; set to do 'scale' times
.b113	85 3b		sta $3b				sta 	gxzTemp2+1
.b115					_GXROLLoop2:
.b115	a5 3a		lda $3a				lda 	gxzTemp2 					; get current pixel
.b117	2c 86 06	bit $0686			bit 	gxMode 						; check H Flip
.b11a	50 06		bvc $b122			bvc 	_GXNoHFlip
.b11c	ad 1f 07	lda $071f			lda 	gxMask
.b11f	38		sec				sec
.b120	e5 3a		sbc $3a				sbc 	gxzTemp2
.b122					_GXNoHFlip:
.b122	aa		tax				tax 								; read from the pixel buffer
.b123	bd 27 06	lda $0627,x			lda 	gxPixelBuffer,x
.b126	d0 07		bne $b12f			bne 	_GXDraw 					; draw if non zero
.b128	ad 23 07	lda $0723			lda 	gxUseMode 					; check to see if solid background
.b12b	29 04		and #$04			and 	#4
.b12d	f0 0a		beq $b139			beq 	_GXZeroPixel
.b12f					_GXDraw:
.b12f	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.b131	2d 89 06	and $0689			and 	gxANDValue
.b134	5d 27 06	eor $0627,x			eor 	gxPixelBuffer,x
.b137	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b139					_GXZeroPixel:
.b139	c8		iny				iny 								; advance pointer
.b13a	d0 05		bne $b141			bne 	_GXNoShift
.b13c	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.b13e	20 83 b0	jsr $b083			jsr 	GXDLTCheckWrap				; check for new page.
.b141					_GXNoShift:
.b141	c6 3b		dec $3b				dec 	gxzTemp2+1 					; do the inner loop gxScale times.
.b143	d0 d0		bne $b115			bne 	_GXROLLoop2
.b145	e6 3a		inc $3a				inc 	gxzTemp2 					; next pixel.
.b147	a5 3a		lda $3a				lda 	gxzTemp2
.b149	cd 1e 07	cmp $071e			cmp 	gxSize
.b14c	d0 c2		bne $b110			bne 	_GXROLLoop1
.b14e	ee 7b 06	inc $067b			inc 	gxY0
.b151	60		rts				rts
.071e					gxSize:
>071e							.fill 	1
.071f					gxMask:
>071f							.fill 	1
.0720					gxAcquireVector:
>0720							.fill 	2
.0722					gxScale:
>0722							.fill 	1
.0723					gxUseMode:
>0723							.fill 	1
.b152					GXFontHandler:
.b152	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b154	4d 86 06	eor $0686			eor 	gxMode
.b157	8d 23 07	sta $0723			sta 	gxUseMode
.b15a	64 37		stz $37				stz 	gxzTemp0+1 					; gxzTemp0 is font #
.b15c	06 36		asl $36				asl	 	gxzTemp0 					; x 2
.b15e	26 37		rol $37				rol	 	gxzTemp0+1
.b160	06 36		asl $36				asl	 	gxzTemp0 					; x 4
.b162	26 37		rol $37				rol	 	gxzTemp0+1
.b164	06 36		asl $36				asl	 	gxzTemp0 					; x 8
.b166	26 37		rol $37				rol	 	gxzTemp0+1
.b168	a5 37		lda $37				lda 	gxzTemp0+1 					; put in page C0
.b16a	09 c0		ora #$c0			ora 	#$C0
.b16c	85 37		sta $37				sta 	gxzTemp0+1
.b16e	a9 08		lda #$08			lda 	#8 							; size 8x8
.b170	a2 78		ldx #$78			ldx 	#GXGetGraphicDataFont & $FF ; XY = Graphic Data retrieval routine
.b172	a0 b1		ldy #$b1			ldy 	#GXGetGraphicDataFont >> 8
.b174	20 90 b0	jsr $b090			jsr 	GXDrawGraphicElement
.b177	60		rts				rts
.b178					GXGetGraphicDataFont:
.b178	8a		txa				txa 								; X->Y
.b179	a8		tay				tay
.b17a	a6 01		ldx $01				ldx 	1 							; preserve old value
.b17c	a9 01		lda #$01			lda 	#1 							; access page 1 (font memory)
.b17e	85 01		sta $01				sta 	1
.b180	b1 36		lda ($36),y			lda 	(gxzTemp0),y 				; read the font element.
.b182	86 01		stx $01				stx 	1 							; put old value back.
.b184	a2 00		ldx #$00			ldx 	#0 							; do 8 times
.b186					_GXExpand:
.b186	9e 27 06	stz $0627,x			stz 	gxPixelBuffer,x 			; zero in pixel buffer
.b189	0a		asl a				asl 	a 							; shift bit 7 into C
.b18a	90 08		bcc $b194			bcc 	_GXNoPixel
.b18c	48		pha				pha 								; if set, set pixel buffer to current colour.
.b18d	ad 87 06	lda $0687			lda 	gxColour
.b190	9d 27 06	sta $0627,x			sta 	gxPixelBuffer,x
.b193	68		pla				pla
.b194					_GXNoPixel:
.b194	e8		inx				inx 								; do the whole byte.
.b195	e0 08		cpx #$08			cpx 	#8
.b197	d0 ed		bne $b186			bne 	_GXExpand
.b199	60		rts				rts
.b19a					GXSpriteHandler:
.b19a	ad 81 06	lda $0681			lda 	gxSpritesOn 				; sprites on ?
.b19d	f0 23		beq $b1c2			beq 	_GXSHExit
.b19f	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b1a1	4d 86 06	eor $0686			eor 	gxMode
.b1a4	8d 23 07	sta $0723			sta 	gxUseMode
.b1a7	a6 36		ldx $36				ldx 	gxzTemp0 					; sprite #
.b1a9	da		phx				phx
.b1aa	20 3a b3	jsr $b33a			jsr 	GXOpenBitmap 				; can access sprite information
.b1ad	68		pla				pla
.b1ae	20 1b b4	jsr $b41b			jsr 	GXFindSprite 				; get the sprite address
.b1b1	08		php				php
.b1b2	20 42 b3	jsr $b342			jsr 	GXCloseBitmap
.b1b5	28		plp				plp
.b1b6	b0 0a		bcs $b1c2			bcs		_GXSHExit 					; exit if find failed.
.b1b8	ad 24 07	lda $0724			lda 	GXSizePixels 				; return size
.b1bb	a2 c3		ldx #$c3			ldx 	#GXSpriteAcquire & $FF
.b1bd	a0 b1		ldy #$b1			ldy 	#GXSpriteAcquire >> 8
.b1bf	20 90 b0	jsr $b090			jsr 	GXDrawGraphicElement
.b1c2					_GXSHExit:
.b1c2	60		rts				rts
.b1c3					GXSpriteAcquire:
.b1c3	ad 84 06	lda $0684			lda 	GXSpritePage				; point to base page
.b1c6	85 0b		sta $0b				sta 	GXEditSlot
.b1c8	86 36		stx $36				stx 	zTemp0 						; row number x 1,2,3,4
.b1ca	a9 00		lda #$00			lda 	#0
.b1cc	ae 25 07	ldx $0725			ldx 	GXSizeBits
.b1cf					_GXTimesRowNumber:
.b1cf	18		clc				clc
.b1d0	65 36		adc $36				adc 	zTemp0
.b1d2	ca		dex				dex
.b1d3	10 fa		bpl $b1cf			bpl 	_GXTimesRowNumber
.b1d5	64 37		stz $37				stz 	gxzTemp0+1
.b1d7	0a		asl a				asl 	a 							; row x 2,4,6,8
.b1d8	26 37		rol $37				rol 	gxzTemp0+1
.b1da	0a		asl a				asl 	a 							; row x 4,8,12,16
.b1db	26 37		rol $37				rol 	gxzTemp0+1
.b1dd	0a		asl a				asl 	a 							; row x 8,16,24,32
.b1de	26 37		rol $37				rol 	gxzTemp0+1
.b1e0	85 36		sta $36				sta 	gxzTemp0
.b1e2	18		clc				clc 								; add base address.
.b1e3	a5 36		lda $36				lda 	gxzTemp0
.b1e5	6d 27 07	adc $0727			adc 	GXSpriteOffset
.b1e8	85 36		sta $36				sta 	gxzTemp0
.b1ea	a5 37		lda $37				lda 	gxzTemp0+1
.b1ec	6d 28 07	adc $0728			adc 	GXSpriteOffset+1
.b1ef					_GXSAFindPage:
.b1ef	c9 20		cmp #$20			cmp 	#$20 						; on this page
.b1f1	90 06		bcc $b1f9			bcc 	_GXSAFoundPage
.b1f3	e9 20		sbc #$20			sbc 	#$20 						; forward one page
.b1f5	e6 0b		inc $0b				inc 	GXEditSlot
.b1f7	80 f6		bra $b1ef			bra 	_GXSAFindPage
.b1f9					_GXSAFoundPage:
.b1f9	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; physical address of page.
.b1fb	85 37		sta $37				sta 	gxzTemp0+1 					; gxzTemp0 now points to the page
.b1fd	a0 00		ldy #$00			ldy 	#0
.b1ff					_GXSACopyLoop:
.b1ff	b1 36		lda ($36),y			lda 	(gxzTemp0),y
.b201	99 27 06	sta $0627,y			sta 	gxPixelBuffer,y
.b204	c8		iny				iny
.b205	cc 24 07	cpy $0724			cpy 	GXSizePixels
.b208	d0 f5		bne $b1ff			bne 	_GXSACopyLoop
.b20a	60		rts				rts
.b20b					GXSelect:
.b20b	ad 81 06	lda $0681			lda 	gxSpritesOn
.b20e	f0 22		beq $b232			beq 	_GXSFail
.b210	a5 36		lda $36				lda 	gxzTemp0 					; illegal sprite #
.b212	c9 40		cmp #$40			cmp 	#64
.b214	b0 1c		bcs $b232			bcs 	_GXSFail
.b216	8d 8c 06	sta $068c			sta 	GSCurrentSpriteID
.b219	a4 37		ldy $37				ldy 	gxzTemp0+1 					; control value.
.b21b	a9 00		lda #$00			lda  	#0 							; multiply sprite # x 8 => A
.b21d	06 36		asl $36				asl 	gxzTemp0
.b21f	06 36		asl $36				asl 	gxzTemp0
.b221	06 36		asl $36				asl 	gxzTemp0
.b223	2a		rol a				rol 	a
.b224	69 d9		adc #$d9			adc 	#$D9 						; sprite area
.b226	8d 8e 06	sta $068e			sta 	GSCurrentSpriteAddr+1 		; address to GSCurrentSprite and gxzTemp
.b229	85 37		sta $37				sta 	gxzTemp0+1
.b22b	a5 36		lda $36				lda 	gxzTemp0
.b22d	8d 8d 06	sta $068d			sta 	GSCurrentSpriteAddr
.b230	18		clc				clc
.b231	60		rts				rts
.b232					_GXSFail:
.b232	38		sec				sec
.b233	60		rts				rts
.b234					GXSelectImage:
.b234	ad 81 06	lda $0681			lda 	gxSpritesOn
.b237	f0 74		beq $b2ad			beq 	_GXSIFail
.b239	ad 8e 06	lda $068e			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b23c	f0 6f		beq $b2ad			beq 	_GXSIFail 					; (checking the MSB)
.b23e	64 01		stz $01				stz 	1
.b240	a5 37		lda $37				lda 	gxzTemp0+1 					; push show/hide on the stack.
.b242	d0 6b		bne $b2af			bne 	_GXSIHide
.b244	a5 36		lda $36				lda 	gxzTemp0 					; sprite image
.b246	48		pha				pha
.b247	20 3a b3	jsr $b33a			jsr 	GXOpenBitmap
.b24a	68		pla				pla
.b24b	20 1b b4	jsr $b41b			jsr 	GXFindSprite
.b24e	b0 5a		bcs $b2aa			bcs 	_GXSICloseFail 				; no image
.b250	a0 01		ldy #$01			ldy 	#1
.b252	ad 8d 06	lda $068d			lda 	GSCurrentSpriteAddr
.b255	85 36		sta $36				sta 	gxzTemp0
.b257	ad 8e 06	lda $068e			lda 	GSCurrentSpriteAddr+1
.b25a	85 37		sta $37				sta 	gxzTemp0+1
.b25c	ad 27 07	lda $0727			lda 	GXSpriteOffset
.b25f	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b261	18		clc				clc
.b262	ad 28 07	lda $0728			lda 	GXSpriteOffset+1
.b265	6d 8f 06	adc $068f			adc 	GXSpriteOffsetBase
.b268	c8		iny				iny
.b269	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b26b	ad 90 06	lda $0690			lda 	GXSpriteOffsetBase+1
.b26e	69 00		adc #$00			adc 	#0
.b270	c8		iny				iny
.b271	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b273	ad 25 07	lda $0725			lda 	GXSizeBits 					; get raw size
.b276	49 03		eor #$03			eor 	#3 							; make it right (00=32 etc.)
.b278	2a		rol a				rol 	a 							; x 2
.b279	0a		asl a				asl 	a 							; x 4
.b27a	0a		asl a				asl 	a 							; x 8
.b27b	0a		asl a				asl 	a 							; x 16
.b27c	0d 26 07	ora $0726			ora 	GXSpriteLUT 				; Or with LUT
.b27f	0a		asl a				asl 	a 							; 1 shift
.b280	09 01		ora #$01			ora 	#1 							; enable sprite.
.b282	92 36		sta ($36)			sta 	(gxzTemp0) 					; and write back
.b284	20 42 b3	jsr $b342			jsr 	GXCloseBitmap
.b287	ae 8c 06	ldx $068c			ldx 	GSCurrentSpriteID 			; point to sprite entries.
.b28a	bd d1 06	lda $06d1,x			lda 	GXSpriteHigh,x 				; clear upper two bits of size
.b28d	29 3f		and #$3f			and 	#$3F
.b28f	9d d1 06	sta $06d1,x			sta 	GXSpriteHigh,x
.b292	ad 25 07	lda $0725			lda 	GXSizeBits 					; get bit size
.b295	6a		ror a				ror 	a 							; shift into bits 6/7
.b296	6a		ror a				ror 	a
.b297	6a		ror a				ror 	a
.b298	29 c0		and #$c0			and 	#$C0
.b29a	1d d1 06	ora $06d1,x			ora 	GXSpriteHigh,x 				; put in  upper 2 bits of sprite data
.b29d	9d d1 06	sta $06d1,x			sta 	GXSpriteHigh,x
.b2a0	bd 91 06	lda $0691,x			lda 	GXSpriteLow,x 				; clear hidden flag.
.b2a3	29 7f		and #$7f			and 	#$7F
.b2a5	9d 91 06	sta $0691,x			sta 	GXSpriteLow,x
.b2a8	18		clc				clc
.b2a9	60		rts				rts
.b2aa					_GXSICloseFail:
.b2aa	20 42 b3	jsr $b342			jsr 	GXCloseBitmap
.b2ad					_GXSIFail:
.b2ad	38		sec				sec
.b2ae	60		rts				rts
.b2af					_GXSIHide:
.b2af	ad 8d 06	lda $068d			lda 	GSCurrentSpriteAddr  		; get Sprite h/w address and write there
.b2b2	85 36		sta $36				sta 	gxzTemp0
.b2b4	ad 8e 06	lda $068e			lda 	GSCurrentSpriteAddr+1
.b2b7	85 37		sta $37				sta 	gxzTemp0+1
.b2b9	a9 00		lda #$00			lda 	#0
.b2bb	92 36		sta ($36)			sta 	(gxzTemp0)
.b2bd	ae 8c 06	ldx $068c			ldx 	GSCurrentSpriteID 			; get sprite ID
.b2c0	bd 91 06	lda $0691,x			lda 	GXSpriteLow,x 				; set the hidden bit.
.b2c3	09 80		ora #$80			ora 	#$80
.b2c5	9d 91 06	sta $0691,x			sta 	GXSpriteLow,x
.b2c8	18		clc				clc
.b2c9	60		rts				rts
.b2ca					GXMoveSprite:
.b2ca	ad 81 06	lda $0681			lda 	gxSpritesOn
.b2cd	f0 65		beq $b334			beq 	_GXSIFail
.b2cf	ad 8e 06	lda $068e			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b2d2	f0 60		beq $b334			beq 	_GXSIFail
.b2d4	85 37		sta $37				sta 	gxzTemp0+1
.b2d6	a0 04		ldy #$04			ldy 	#4
.b2d8	ad 8d 06	lda $068d			lda 	GSCurrentSpriteAddr
.b2db	85 36		sta $36				sta 	gxzTemp0
.b2dd	ae 8c 06	ldx $068c			ldx 	GSCurrentSpriteID 			; get the size from the upper two bits
.b2e0	bd d1 06	lda $06d1,x			lda 	GXSpriteHigh,x
.b2e3	2a		rol a				rol 	a	 						; into bits 0,1.
.b2e4	2a		rol a				rol 	a
.b2e5	2a		rol a				rol 	a
.b2e6	29 03		and #$03			and 	#3
.b2e8	aa		tax				tax
.b2e9	bd 36 b3	lda $b336,x			lda 	_GXMSOffset,x 				; get 32-SpriteSize/2
.b2ec	48		pha				pha
.b2ed	18		clc				clc
.b2ee	6d 79 06	adc $0679			adc 	gxX0						; copy position.
.b2f1	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2f3	c8		iny				iny
.b2f4	ad 7a 06	lda $067a			lda 	gxX0+1
.b2f7	69 00		adc #$00			adc 	#0
.b2f9	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2fb	c8		iny				iny
.b2fc	68		pla				pla
.b2fd	18		clc				clc
.b2fe	6d 7b 06	adc $067b			adc 	gxY0
.b301	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b303	a9 00		lda #$00			lda 	#0
.b305	69 00		adc #$00			adc 	#0
.b307	c8		iny				iny
.b308	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b30a	4e 7a 06	lsr $067a			lsr 	gxX0+1 						; divide X by 4
.b30d	6e 79 06	ror $0679			ror 	gxX0
.b310	4e 79 06	lsr $0679			lsr 	gxX0
.b313	4e 7b 06	lsr $067b			lsr 	gxY0 						; divide Y by 4
.b316	4e 7b 06	lsr $067b			lsr 	gxY0
.b319	ae 8c 06	ldx $068c			ldx 	GSCurrentSpriteID 			; copy X/4 and Y/4 into the status bytes
.b31c	bd 91 06	lda $0691,x			lda 	GXSpriteLow,x
.b31f	29 80		and #$80			and 	#$80
.b321	0d 79 06	ora $0679			ora 	gxX0
.b324	9d 91 06	sta $0691,x			sta 	GXSpriteLow,x
.b327	bd d1 06	lda $06d1,x			lda 	GXSpriteHigh,x
.b32a	29 c0		and #$c0			and 	#$C0
.b32c	0d 7b 06	ora $067b			ora 	gxY0
.b32f	9d d1 06	sta $06d1,x			sta 	GXSpriteHigh,x
.b332	18		clc				clc
.b333	60		rts				rts
.b334					_GXSIFail:
.b334	38		sec				sec
.b335	60		rts				rts
.b336					_GXMSOffset:
>b336	1c						.byte 	32-8/2
>b337	18						.byte 	32-16/2
>b338	14						.byte 	32-24/2
>b339	10						.byte 	32-32/2
.b33a					GXOpenBitmap:
.b33a	78		sei				sei 								; no interrupts here
.b33b	a5 0b		lda $0b				lda 	GXEditSlot 					; Save the original LUT slot value
.b33d	8d 8a 06	sta $068a			sta 	gxOriginalLUTValue
.b340	58		cli				cli
.b341	60		rts				rts
.b342					GXCloseBitmap:
.b342	78		sei				sei
.b343	ad 8a 06	lda $068a			lda 	gxOriginalLUTValue 			; restore LUT slot value
.b346	85 0b		sta $0b				sta 	GXEditSlot
.b348	58		cli				cli
.b349	60		rts				rts
.b34a					GXPositionCalc:
.b34a	a5 36		lda $36				lda 	gxzTemp0 					; save temp memory slot
.b34c	48		pha				pha
.b34d	ad 7b 06	lda $067b			lda 	GXY0 						; gxzScreen = Y0
.b350	85 3c		sta $3c				sta 	gxzScreen
.b352	64 3d		stz $3d				stz 	gxzScreen+1
.b354	06 3c		asl $3c				asl 	gxzScreen 						; gxzScreen = Y0 * 4
.b356	26 3d		rol $3d				rol 	gxzScreen+1
.b358	06 3c		asl $3c				asl 	gxzScreen
.b35a	26 3d		rol $3d				rol 	gxzScreen+1
.b35c	18		clc				clc 								; gxzScreen = Y0 * 5, as it's still in A
.b35d	65 3c		adc $3c				adc 	gxzScreen
.b35f	85 3c		sta $3c				sta 	gxzScreen
.b361	90 02		bcc $b365			bcc 	_GXPCNoCarry
.b363	e6 3d		inc $3d				inc 	gxzScreen+1
.b365					_GXPCNoCarry:
.b365	06 3c		asl $3c				asl 	gxzScreen 						; now Y0 * 10. Needs to be multiplied by another
.b367	26 3d		rol $3d				rol 	gxzScreen+1 					; 32. At this point the MSB contains the offset
.b369	a5 3d		lda $3d				lda	 	gxzScreen+1 					; so save this in zTemp0 and zero it.
.b36b	85 36		sta $36				sta 	gxzTemp0
.b36d	64 3d		stz $3d				stz 	gxzScreen+1
.b36f	a9 05		lda #$05			lda 	#5 							; now multiply by 32, this puts this in the range 0..8191
.b371					_GXPCMultiply32:
.b371	06 3c		asl $3c				asl 	gxzScreen
.b373	26 3d		rol $3d				rol 	gxzScreen+1
.b375	3a		dec a				dec 	a
.b376	d0 f9		bne $b371			bne 	_GXPCMultiply32
.b378	18		clc				clc
.b379	ad 79 06	lda $0679			lda 	GXX0 						; add X to this value, put the result in gsOffset, gxzScreen has to be on a page boundary
.b37c	65 3c		adc $3c				adc 	gxzScreen
.b37e	8d 8b 06	sta $068b			sta 	gsOffset
.b381	ad 7a 06	lda $067a			lda 	GXX0+1
.b384	65 3d		adc $3d				adc 	gxzScreen+1
.b386	c9 20		cmp #$20			cmp 	#$20 						; has it overflowed into the next one ?
.b388	90 04		bcc $b38e			bcc 	_GXPCNoOverflow
.b38a	29 1f		and #$1f			and 	#$1F 						; fix it up
.b38c	e6 36		inc $36				inc 	gxzTemp0 					; add 1 to the page number
.b38e					_GXPCNoOverflow:
.b38e	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; make it the address mapped in.
.b390	85 3d		sta $3d				sta 	gxzScreen+1
.b392	64 3c		stz $3c				stz 	gxzScreen
.b394	18		clc				clc
.b395	a5 36		lda $36				lda 	gxzTemp0 					; get the page number
.b397	6d 83 06	adc $0683			adc 	gxBasePage 					; by adding the base page
.b39a	85 0b		sta $0b				sta 	GXEditSlot 				; and map it into memory.
.b39c	68		pla				pla
.b39d	85 36		sta $36				sta 	gxzTemp0
.b39f	60		rts				rts
.b3a0					GXMovePositionDown:
.b3a0	18		clc				clc 								; add 320 to offset/temp+1
.b3a1	ad 8b 06	lda $068b			lda 	gsOffset
.b3a4	69 40		adc #$40			adc 	#64
.b3a6	8d 8b 06	sta $068b			sta 	gsOffset
.b3a9	a5 3d		lda $3d				lda 	gxzScreen+1
.b3ab	69 01		adc #$01			adc 	#1
.b3ad	85 3d		sta $3d				sta 	gxzScreen+1
.b3af	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page
.b3b1	90 07		bcc $b3ba			bcc 	_GXMPDExit
.b3b3	38		sec				sec  								; next page
.b3b4	e9 20		sbc #$20			sbc 	#$20
.b3b6	85 3d		sta $3d				sta 	gxzScreen+1
.b3b8	e6 0b		inc $0b				inc 	GXEditSlot
.b3ba					_GXMPDExit:
.b3ba	60		rts				rts
.b3bb					GXCollide:
.b3bb	a5 36		lda $36				lda 	gxzTemp0 					; check if sprite numbers are legal.
.b3bd	aa		tax				tax
.b3be	05 37		ora $37				ora 	gxzTemp0+1
.b3c0	29 c0		and #$c0			and 	#$C0
.b3c2	38		sec				sec
.b3c3	d0 53		bne $b418			bne 	_GXCollideFail 				; if either >= 64, fail.
.b3c5	a4 37		ldy $37				ldy 	gxzTemp0+1 					; at this point X is 1st sprite and Y is 2nd sprite.
.b3c7	b9 91 06	lda $0691,y			lda 	GXSpriteLow,y 				; check if either hidden bit is set
.b3ca	1d 91 06	ora $0691,x			ora 	GXSpriteLow,x
.b3cd	30 48		bmi $b417			bmi 	_GXOkayFail 				; if either hidden, then they cannot collide.
.b3cf	18		clc				clc 								; need to calculate sum of sizes.
.b3d0	b9 d1 06	lda $06d1,y			lda 	GXSpriteHigh,y
.b3d3	7d d1 06	adc $06d1,x			adc 	GXSpriteHigh,x 				; at this point, CS, Bit 6 and 7 contain that sum.
.b3d6	29 c0		and #$c0			and 	#$C0 					 	; mask off
.b3d8	6a		ror a				ror 	a 							; 5/6/7
.b3d9	4a		lsr a				lsr 	a 							; 4/5/6
.b3da	4a		lsr a				lsr 	a 							; 3/4/5
.b3db	4a		lsr a				lsr 	a 							; 2/3/4
.b3dc	18		clc				clc
.b3dd	69 08		adc #$08			adc 	#$08
.b3df	4a		lsr a				lsr 	a 							; adjust because all coordinates are divided by 4 to store.
.b3e0	4a		lsr a				lsr 	a
.b3e1	85 38		sta $38				sta 	gxzTemp1 					; so the difference between the centres has to be less than this.
.b3e3	b9 d1 06	lda $06d1,y			lda 	GXSpriteHigh,y 				; calculate y1-y0
.b3e6	29 3f		and #$3f			and 	#$3F
.b3e8	85 39		sta $39				sta 	gxzTemp1+1
.b3ea	38		sec				sec
.b3eb	bd d1 06	lda $06d1,x			lda 	GXSpriteHigh,x
.b3ee	29 3f		and #$3f			and 	#$3F
.b3f0	e5 39		sbc $39				sbc 	gxzTemp1+1
.b3f2	b0 03		bcs $b3f7			bcs 	_GXCAbs1 					; calculate |y1-y0|
.b3f4	49 ff		eor #$ff			eor 	#$FF
.b3f6	1a		inc a				inc 	a
.b3f7					_GXCAbs1:
.b3f7	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b3f9	b0 1c		bcs $b417			bcs 	_GXOkayFail
.b3fb	85 39		sta $39				sta 	gxzTemp1+1 					; save |y1-y0|
.b3fd	38		sec				sec 								; calculate |x1-x0|
.b3fe	b9 91 06	lda $0691,y			lda 	GXSpriteLow,y
.b401	fd 91 06	sbc $0691,x			sbc 	GXSpriteLow,x
.b404	b0 03		bcs $b409			bcs 	_GXCAbs2
.b406	49 ff		eor #$ff			eor 	#$FF
.b408	1a		inc a				inc 	a
.b409					_GXCAbs2:
.b409	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b40b	b0 0a		bcs $b417			bcs 	_GXOkayFail
.b40d	c5 39		cmp $39				cmp 	gxzTemp1+1 					; is it less than the previous one.
.b40f	90 02		bcc $b413			bcc 	_GXCHaveLowest
.b411	a5 39		lda $39				lda 	gxzTemp1+1 					; if not, that's the smallest difference.
.b413					_GXCHaveLowest:
.b413	0a		asl a				asl 	a 							; scale to allow for >> 2
.b414	0a		asl a				asl 	a
.b415	18		clc				clc
.b416	60		rts				rts
.b417					_GXOkayFail:
.b417	18		clc				clc
.b418					_GXCollideFail:
.b418	a9 ff		lda #$ff			lda 	#$FF
.b41a	60		rts				rts
.b41b					GXFindSprite:
.b41b	aa		tax				tax
.b41c	ad 84 06	lda $0684			lda 	GXSpritePage 				; access the base page of the sprite
.b41f	85 0b		sta $0b				sta 	GXEditSlot
.b421	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; check a valid sprite
.b424	1d 00 60	ora $6000,x			ora 	GXMappingAddress,x
.b427	f0 33		beq $b45c			beq 	_GXFSFail
.b429	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; MSB
.b42c	8d 28 07	sta $0728			sta 	GXSpriteOffset+1
.b42f	bd 00 60	lda $6000,x			lda 	GXMappingAddress,x 			; LSB
.b432	48		pha				pha 								; save twice
.b433	48		pha				pha
.b434	29 03		and #$03			and 	#3 							; get sprite size
.b436	8d 25 07	sta $0725			sta 	GXSizeBits 					; save raw (0-3)
.b439	aa		tax				tax
.b43a	bd 5e b4	lda $b45e,x			lda 	_GXFXSSTTable,x 			; read sprite size
.b43d	8d 24 07	sta $0724			sta 	GXSizePixels 					; save (8/16/24/32)
.b440	68		pla				pla 								; get LUT
.b441	4a		lsr a				lsr		a
.b442	4a		lsr a				lsr		a
.b443	29 03		and #$03			and 	#3
.b445	8d 26 07	sta $0726			sta 	GXSpriteLUT
.b448	68		pla				pla 								; address, neeeds to be x 4
.b449	29 f0		and #$f0			and 	#$F0
.b44b	8d 27 07	sta $0727			sta 	GXSpriteOffset
.b44e	0e 27 07	asl $0727			asl 	GXSpriteOffset
.b451	2e 28 07	rol $0728			rol 	GXSpriteOffset+1
.b454	0e 27 07	asl $0727			asl 	GXSpriteOffset
.b457	2e 28 07	rol $0728			rol 	GXSpriteOffset+1
.b45a	18		clc				clc
.b45b	60		rts				rts
.b45c					_GXFSFail:
.b45c	38		sec				sec
.b45d	60		rts				rts
.b45e					_GXFXSSTTable:
>b45e	08 10 18 20					.byte 	8,16,24,32
.0724					GXSizePixels:
>0724							.fill 	1
.0725					GXSizeBits:
>0725							.fill 	1
.0726					GXSpriteLUT:
>0726							.fill 	1
.0727					GXSpriteOffset:
>0727							.fill 	2
.b462					GXSortXY:
.b462	20 80 b4	jsr $b480			jsr 	GXSortY 					; will be sorted on Y now
.b465	ad 79 06	lda $0679			lda 	gxX0 						; compare X0 v X1
.b468	cd 7d 06	cmp $067d			cmp 	gxX1
.b46b	ad 7a 06	lda $067a			lda 	gXX0+1
.b46e	ed 7e 06	sbc $067e			sbc 	gXX1+1
.b471	90 0c		bcc $b47f			bcc 	_GXSXYExit 					; X0 < X1 exit
.b473	a2 00		ldx #$00			ldx 	#0 							; swap them over
.b475	a0 04		ldy #$04			ldy 	#4
.b477	20 94 b4	jsr $b494			jsr 	GXSwapXY
.b47a	e8		inx				inx
.b47b	c8		iny				iny
.b47c	20 94 b4	jsr $b494			jsr 	GXSwapXY
.b47f					_GXSXYExit:
.b47f	60		rts				rts
.b480					GXSortY:
.b480	ad 7b 06	lda $067b			lda 	gxY0 						; if Y0 >= Y1
.b483	cd 7f 06	cmp $067f			cmp 	gxY1
.b486	90 0b		bcc $b493			bcc 	_GXSYSorted
.b488	a2 03		ldx #$03			ldx 	#3 							; swap 3-0
.b48a	a0 07		ldy #$07			ldy 	#7 							; with 4-7
.b48c					_GXSwap1:
.b48c	20 94 b4	jsr $b494			jsr 	GXSwapXY
.b48f	88		dey				dey
.b490	ca		dex				dex
.b491	10 f9		bpl $b48c			bpl 	_GXSwap1
.b493					_GXSYSorted:
.b493	60		rts				rts
.b494					GXSwapXY:
.b494	bd 79 06	lda $0679,x			lda 	gxX0,x
.b497	48		pha				pha
.b498	b9 79 06	lda $0679,y			lda 	gxX0,y
.b49b	9d 79 06	sta $0679,x			sta 	gxX0,x
.b49e	68		pla				pla
.b49f	99 79 06	sta $0679,y			sta 	gxX0,y
.b4a2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_tokeniser.module

=1					tokeniserIntegrated=1
.b4a3					KeywordSet0:
>b4a3	00 65					.text	0,$65,""               ; $80 !0:EOF
>b4a5	00 58					.text	0,$58,""               ; $81 !1:SH1
>b4a7	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b4a9	04 fe 41 42 53 28			.text	4,$fe,"ABS("           ; $83 ABS(
>b4af	06 93 41 4c 4c 4f 43 28			.text	6,$93,"ALLOC("         ; $84 ALLOC(
>b4b7	04 ff 41 53 43 28			.text	4,$ff,"ASC("           ; $85 ASC(
>b4bd	05 29 43 48 52 24 28			.text	5,$29,"CHR$("          ; $86 CHR$(
>b4c4	05 41 44 45 45 4b 28			.text	5,$41,"DEEK("          ; $87 DEEK(
>b4cb	06 aa 45 56 45 4e 54 28			.text	6,$aa,"EVENT("         ; $88 EVENT(
>b4d3	05 6b 46 41 4c 53 45			.text	5,$6b,"FALSE"          ; $89 FALSE
>b4da	05 44 46 52 41 43 28			.text	5,$44,"FRAC("          ; $8a FRAC(
>b4e1	04 0d 48 49 54 28			.text	4,$0d,"HIT("           ; $8b HIT(
>b4e7	04 13 49 4e 54 28			.text	4,$13,"INT("           ; $8c INT(
>b4ed	06 a7 49 53 56 41 4c 28			.text	6,$a7,"ISVAL("         ; $8d ISVAL(
>b4f5	05 5c 4a 4f 59 42 28			.text	5,$5c,"JOYB("          ; $8e JOYB(
>b4fc	05 72 4a 4f 59 58 28			.text	5,$72,"JOYX("          ; $8f JOYX(
>b503	05 73 4a 4f 59 59 28			.text	5,$73,"JOYY("          ; $90 JOYY(
>b50a	06 77 4c 45 46 54 24 28			.text	6,$77,"LEFT$("         ; $91 LEFT$(
>b512	04 07 4c 45 4e 28			.text	4,$07,"LEN("           ; $92 LEN(
>b518	04 0e 4d 41 58 28			.text	4,$0e,"MAX("           ; $93 MAX(
>b51e	05 26 4d 49 44 24 28			.text	5,$26,"MID$("          ; $94 MID$(
>b525	04 0c 4d 49 4e 28			.text	4,$0c,"MIN("           ; $95 MIN(
>b52b	04 19 4e 4f 54 28			.text	4,$19,"NOT("           ; $96 NOT(
>b531	05 4d 50 45 45 4b 28			.text	5,$4d,"PEEK("          ; $97 PEEK(
>b538	08 3c 50 4c 41 59 49 4e			.text	8,$3c,"PLAYING("       ; $98 PLAYING(
>b540	47 28
>b542	07 e9 52 41 4e 44 4f 4d			.text	7,$e9,"RANDOM("        ; $99 RANDOM(
>b54a	28
>b54b	07 ca 52 49 47 48 54 24			.text	7,$ca,"RIGHT$("        ; $9a RIGHT$(
>b553	28
>b554	04 0c 52 4e 44 28			.text	4,$0c,"RND("           ; $9b RND(
>b55a	04 10 53 47 4e 28			.text	4,$10,"SGN("           ; $9c SGN(
>b560	04 0e 53 50 43 28			.text	4,$0e,"SPC("           ; $9d SPC(
>b566	05 45 53 54 52 24 28			.text	5,$45,"STR$("          ; $9e STR$(
>b56d	06 a9 54 49 4d 45 52 28			.text	6,$a9,"TIMER("         ; $9f TIMER(
>b575	04 40 54 52 55 45			.text	4,$40,"TRUE"           ; $a0 TRUE
>b57b	04 0b 56 41 4c 28			.text	4,$0b,"VAL("           ; $a1 VAL(
>b581	03 e7 46 4f 52				.text	3,$e7,"FOR"            ; $a2 FOR
>b586	02 8f 49 46				.text	2,$8f,"IF"             ; $a3 IF
>b58a	04 34 50 52 4f 43			.text	4,$34,"PROC"           ; $a4 PROC
>b590	06 c1 52 45 50 45 41 54			.text	6,$c1,"REPEAT"         ; $a5 REPEAT
>b598	05 79 57 48 49 4c 45			.text	5,$79,"WHILE"          ; $a6 WHILE
>b59f	05 66 45 4e 44 49 46			.text	5,$66,"ENDIF"          ; $a7 ENDIF
>b5a6	07 0b 45 4e 44 50 52 4f			.text	7,$0b,"ENDPROC"        ; $a8 ENDPROC
>b5ae	43
>b5af	04 3f 4e 45 58 54			.text	4,$3f,"NEXT"           ; $a9 NEXT
>b5b5	04 2f 54 48 45 4e			.text	4,$2f,"THEN"           ; $aa THEN
>b5bb	05 8c 55 4e 54 49 4c			.text	5,$8c,"UNTIL"          ; $ab UNTIL
>b5c2	04 2e 57 45 4e 44			.text	4,$2e,"WEND"           ; $ac WEND
>b5c8	02 9b 42 59				.text	2,$9b,"BY"             ; $ad BY
>b5cc	04 1c 43 41 4c 4c			.text	4,$1c,"CALL"           ; $ae CALL
>b5d2	06 b2 43 49 52 43 4c 45			.text	6,$b2,"CIRCLE"         ; $af CIRCLE
>b5da	05 67 43 4c 45 41 52			.text	5,$67,"CLEAR"          ; $b0 CLEAR
>b5e1	03 e2 43 4c 53				.text	3,$e2,"CLS"            ; $b1 CLS
>b5e6	05 7f 43 4f 4c 4f 52			.text	5,$7f,"COLOR"          ; $b2 COLOR
>b5ed	06 d4 43 4f 4c 4f 55 52			.text	6,$d4,"COLOUR"         ; $b3 COLOUR
>b5f5	04 1a 44 41 54 41			.text	4,$1a,"DATA"           ; $b4 DATA
>b5fb	03 da 44 49 4d				.text	3,$da,"DIM"            ; $b5 DIM
>b600	04 23 44 4f 4b 45			.text	4,$23,"DOKE"           ; $b6 DOKE
>b606	06 db 44 4f 57 4e 54 4f			.text	6,$db,"DOWNTO"         ; $b7 DOWNTO
>b60e	04 29 45 4c 53 45			.text	4,$29,"ELSE"           ; $b8 ELSE
>b614	04 34 46 52 4f 4d			.text	4,$34,"FROM"           ; $b9 FROM
>b61a	03 e5 47 46 58				.text	3,$e5,"GFX"            ; $ba GFX
>b61f	05 80 47 4f 53 55 42			.text	5,$80,"GOSUB"          ; $bb GOSUB
>b626	04 39 47 4f 54 4f			.text	4,$39,"GOTO"           ; $bc GOTO
>b62c	04 24 48 45 52 45			.text	4,$24,"HERE"           ; $bd HERE
>b632	05 63 49 4d 41 47 45			.text	5,$63,"IMAGE"          ; $be IMAGE
>b639	05 90 49 4e 50 55 54			.text	5,$90,"INPUT"          ; $bf INPUT
>b640	03 e5 4c 45 54				.text	3,$e5,"LET"            ; $c0 LET
>b645	04 28 4c 49 4e 45			.text	4,$28,"LINE"           ; $c1 LINE
>b64b	05 6b 4c 4f 43 41 4c			.text	5,$6b,"LOCAL"          ; $c2 LOCAL
>b652	03 db 4f 46 46				.text	3,$db,"OFF"            ; $c3 OFF
>b657	02 9d 4f 4e				.text	2,$9d,"ON"             ; $c4 ON
>b65b	07 20 4f 55 54 4c 49 4e			.text	7,$20,"OUTLINE"        ; $c5 OUTLINE
>b663	45
>b664	07 0f 50 41 4c 45 54 54			.text	7,$0f,"PALETTE"        ; $c6 PALETTE
>b66c	45
>b66d	04 3f 50 4c 4f 54			.text	4,$3f,"PLOT"           ; $c7 PLOT
>b673	04 2f 50 4f 4b 45			.text	4,$2f,"POKE"           ; $c8 POKE
>b679	05 8d 50 52 49 4e 54			.text	5,$8d,"PRINT"          ; $c9 PRINT
>b680	04 1c 52 45 41 44			.text	4,$1c,"READ"           ; $ca READ
>b686	04 2e 52 45 43 54			.text	4,$2e,"RECT"           ; $cb RECT
>b68c	03 e4 52 45 4d				.text	3,$e4,"REM"            ; $cc REM
>b691	06 e0 52 45 54 55 52 4e			.text	6,$e0,"RETURN"         ; $cd RETURN
>b699	05 7b 53 4f 4c 49 44			.text	5,$7b,"SOLID"          ; $ce SOLID
>b6a0	05 89 53 4f 55 4e 44			.text	5,$89,"SOUND"          ; $cf SOUND
>b6a7	06 d7 53 50 52 49 54 45			.text	6,$d7,"SPRITE"         ; $d0 SPRITE
>b6af	04 45 54 45 58 54			.text	4,$45,"TEXT"           ; $d1 TEXT
>b6b5	02 a3 54 4f				.text	2,$a3,"TO"             ; $d2 TO
>b6b9	ff					.text	$FF
.b6ba					KeywordSet1:
>b6ba	00 65					.text	0,$65,""               ; $80 !0:EOF
>b6bc	00 58					.text	0,$58,""               ; $81 !1:SH1
>b6be	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b6c0	08 4c 41 53 53 45 4d 42			.text	8,$4c,"ASSEMBLE"       ; $83 ASSEMBLE
>b6c8	4c 45
>b6ca	06 d2 41 53 53 45 52 54			.text	6,$d2,"ASSERT"         ; $84 ASSERT
>b6d2	06 bd 42 49 54 4d 41 50			.text	6,$bd,"BITMAP"         ; $85 BITMAP
>b6da	03 d7 45 4e 44				.text	3,$d7,"END"            ; $86 END
>b6df	07 11 45 58 50 4c 4f 44			.text	7,$11,"EXPLODE"        ; $87 EXPLODE
>b6e7	45
>b6e8	02 96 47 4f				.text	2,$96,"GO"             ; $88 GO
>b6ec	04 3c 4c 49 53 54			.text	4,$3c,"LIST"           ; $89 LIST
>b6f2	04 20 4c 4f 41 44			.text	4,$20,"LOAD"           ; $8a LOAD
>b6f8	03 ea 4e 45 57				.text	3,$ea,"NEW"            ; $8b NEW
>b6fd	04 2e 50 49 4e 47			.text	4,$2e,"PING"           ; $8c PING
>b703	07 24 52 45 53 54 4f 52			.text	7,$24,"RESTORE"        ; $8d RESTORE
>b70b	45
>b70c	03 f5 52 55 4e				.text	3,$f5,"RUN"            ; $8e RUN
>b711	05 8d 53 48 4f 4f 54			.text	5,$8d,"SHOOT"          ; $8f SHOOT
>b718	07 2a 53 50 52 49 54 45			.text	7,$2a,"SPRITES"        ; $90 SPRITES
>b720	53
>b721	04 46 53 54 4f 50			.text	4,$46,"STOP"           ; $91 STOP
>b727	03 ee 57 48 4f				.text	3,$ee,"WHO"            ; $92 WHO
>b72c	03 eb 5a 41 50				.text	3,$eb,"ZAP"            ; $93 ZAP
>b731	ff					.text	$FF
.b732					KeywordSet2:
>b732	00 65					.text	0,$65,""               ; $80 !0:EOF
>b734	00 58					.text	0,$58,""               ; $81 !1:SH1
>b736	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b738	03 c8 41 44 43				.text	3,$c8,"ADC"            ; $83 ADC
>b73d	03 d3 41 4e 44				.text	3,$d3,"AND"            ; $84 AND
>b742	03 e0 41 53 4c				.text	3,$e0,"ASL"            ; $85 ASL
>b747	03 c8 42 43 43				.text	3,$c8,"BCC"            ; $86 BCC
>b74c	03 d8 42 43 53				.text	3,$d8,"BCS"            ; $87 BCS
>b751	03 d8 42 45 51				.text	3,$d8,"BEQ"            ; $88 BEQ
>b756	03 df 42 49 54				.text	3,$df,"BIT"            ; $89 BIT
>b75b	03 d8 42 4d 49				.text	3,$d8,"BMI"            ; $8a BMI
>b760	03 d5 42 4e 45				.text	3,$d5,"BNE"            ; $8b BNE
>b765	03 de 42 50 4c				.text	3,$de,"BPL"            ; $8c BPL
>b76a	03 d5 42 52 41				.text	3,$d5,"BRA"            ; $8d BRA
>b76f	03 df 42 52 4b				.text	3,$df,"BRK"            ; $8e BRK
>b774	03 db 42 56 43				.text	3,$db,"BVC"            ; $8f BVC
>b779	03 eb 42 56 53				.text	3,$eb,"BVS"            ; $90 BVS
>b77e	03 d2 43 4c 43				.text	3,$d2,"CLC"            ; $91 CLC
>b783	03 d3 43 4c 44				.text	3,$d3,"CLD"            ; $92 CLD
>b788	03 d8 43 4c 49				.text	3,$d8,"CLI"            ; $93 CLI
>b78d	03 e5 43 4c 56				.text	3,$e5,"CLV"            ; $94 CLV
>b792	03 e0 43 4d 50				.text	3,$e0,"CMP"            ; $95 CMP
>b797	03 eb 43 50 58				.text	3,$eb,"CPX"            ; $96 CPX
>b79c	03 ec 43 50 59				.text	3,$ec,"CPY"            ; $97 CPY
>b7a1	03 cc 44 45 43				.text	3,$cc,"DEC"            ; $98 DEC
>b7a6	03 e1 44 45 58				.text	3,$e1,"DEX"            ; $99 DEX
>b7ab	03 e2 44 45 59				.text	3,$e2,"DEY"            ; $9a DEY
>b7b0	03 e6 45 4f 52				.text	3,$e6,"EOR"            ; $9b EOR
>b7b5	03 da 49 4e 43				.text	3,$da,"INC"            ; $9c INC
>b7ba	03 ef 49 4e 58				.text	3,$ef,"INX"            ; $9d INX
>b7bf	03 f0 49 4e 59				.text	3,$f0,"INY"            ; $9e INY
>b7c4	03 e7 4a 4d 50				.text	3,$e7,"JMP"            ; $9f JMP
>b7c9	03 ef 4a 53 52				.text	3,$ef,"JSR"            ; $a0 JSR
>b7ce	03 d1 4c 44 41				.text	3,$d1,"LDA"            ; $a1 LDA
>b7d3	03 e8 4c 44 58				.text	3,$e8,"LDX"            ; $a2 LDX
>b7d8	03 e9 4c 44 59				.text	3,$e9,"LDY"            ; $a3 LDY
>b7dd	03 f1 4c 53 52				.text	3,$f1,"LSR"            ; $a4 LSR
>b7e2	03 ed 4e 4f 50				.text	3,$ed,"NOP"            ; $a5 NOP
>b7e7	03 e2 4f 52 41				.text	3,$e2,"ORA"            ; $a6 ORA
>b7ec	03 d9 50 48 41				.text	3,$d9,"PHA"            ; $a7 PHA
>b7f1	03 e8 50 48 50				.text	3,$e8,"PHP"            ; $a8 PHP
>b7f6	03 f0 50 48 58				.text	3,$f0,"PHX"            ; $a9 PHX
>b7fb	03 f1 50 48 59				.text	3,$f1,"PHY"            ; $aa PHY
>b800	03 dd 50 4c 41				.text	3,$dd,"PLA"            ; $ab PLA
>b805	03 ec 50 4c 50				.text	3,$ec,"PLP"            ; $ac PLP
>b80a	03 f4 50 4c 58				.text	3,$f4,"PLX"            ; $ad PLX
>b80f	03 f5 50 4c 59				.text	3,$f5,"PLY"            ; $ae PLY
>b814	03 ed 52 4f 4c				.text	3,$ed,"ROL"            ; $af ROL
>b819	03 f3 52 4f 52				.text	3,$f3,"ROR"            ; $b0 ROR
>b81e	03 ef 52 54 49				.text	3,$ef,"RTI"            ; $b1 RTI
>b823	03 f9 52 54 53				.text	3,$f9,"RTS"            ; $b2 RTS
>b828	03 d8 53 42 43				.text	3,$d8,"SBC"            ; $b3 SBC
>b82d	03 db 53 45 43				.text	3,$db,"SEC"            ; $b4 SEC
>b832	03 dc 53 45 44				.text	3,$dc,"SED"            ; $b5 SED
>b837	03 e1 53 45 49				.text	3,$e1,"SEI"            ; $b6 SEI
>b83c	03 e8 53 54 41				.text	3,$e8,"STA"            ; $b7 STA
>b841	03 f7 53 54 50				.text	3,$f7,"STP"            ; $b8 STP
>b846	03 ff 53 54 58				.text	3,$ff,"STX"            ; $b9 STX
>b84b	03 00 53 54 59				.text	3,$00,"STY"            ; $ba STY
>b850	03 01 53 54 5a				.text	3,$01,"STZ"            ; $bb STZ
>b855	03 ed 54 41 58				.text	3,$ed,"TAX"            ; $bc TAX
>b85a	03 ee 54 41 59				.text	3,$ee,"TAY"            ; $bd TAY
>b85f	03 e8 54 52 42				.text	3,$e8,"TRB"            ; $be TRB
>b864	03 e9 54 53 42				.text	3,$e9,"TSB"            ; $bf TSB
>b869	03 ff 54 53 58				.text	3,$ff,"TSX"            ; $c0 TSX
>b86e	03 ed 54 58 41				.text	3,$ed,"TXA"            ; $c1 TXA
>b873	03 ff 54 58 53				.text	3,$ff,"TXS"            ; $c2 TXS
>b878	03 ee 54 59 41				.text	3,$ee,"TYA"            ; $c3 TYA
>b87d	ff					.text	$FF
.b87e					Export_TKListConvertLine:
.b87e	48		pha				pha 								; save indent on the stack
.b87f	9c 1d 04	stz $041d			stz 	tbOffset
.b882	9c 2d 04	stz $042d			stz 	tokenBuffer
.b885	9c 29 04	stz $0429			stz 	currentListColour
.b888	a9 89		lda #$89			lda 	#CLILineNumber+$80
.b88a	20 07 ba	jsr $ba07			jsr 	LCLWriteColour
.b88d	a0 02		ldy #$02			ldy 	#2 							; convert line number to string
.b88f	b1 30		lda ($30),y			lda 	(codePtr),y
.b891	aa		tax				tax
.b892	88		dey				dey
.b893	b1 30		lda ($30),y			lda 	(codePtr),y
.b895	20 78 ba	jsr $ba78			jsr 	LCLWriteNumberXA
.b898	68		pla				pla 								; adjustment to indent
.b899	48		pha				pha 								; save on stack
.b89a	10 0c		bpl $b8a8			bpl 	_LCNoAdjust 				; don't adjust indent if +ve, do after.
.b89c	18		clc				clc 								; add to list indent and make 0 if goes -ve.
.b89d	6d 26 04	adc $0426			adc 	listIndent
.b8a0	8d 26 04	sta $0426			sta 	listIndent
.b8a3	10 03		bpl $b8a8			bpl 	_LCNoAdjust
.b8a5	9c 26 04	stz $0426			stz 	listIndent
.b8a8					_LCNoAdjust:
.b8a8	18		clc				clc		 							; work out actual indent.
.b8a9	ad 26 04	lda $0426			lda 	listIndent
.b8ac	0a		asl a				asl 	a
.b8ad	69 07		adc #$07			adc 	#7
.b8af	85 36		sta $36				sta 	zTemp0
.b8b1					_LCPadOut:
.b8b1	a9 20		lda #$20			lda 	#' '						; pad out to 6+indent characters
.b8b3	20 10 ba	jsr $ba10			jsr 	LCLWrite
.b8b6	ad 1d 04	lda $041d			lda 	tbOffset
.b8b9	c5 36		cmp $36				cmp 	zTemp0
.b8bb	d0 f4		bne $b8b1			bne 	_LCPadOut
.b8bd	a0 03		ldy #$03			ldy 	#3 							; start position.
.b8bf					_LCMainLoop:
.b8bf	a9 8a		lda #$8a			lda 	#CLIPunctuation+$80
.b8c1	20 07 ba	jsr $ba07			jsr 	LCLWriteColour
.b8c4	b1 30		lda ($30),y			lda 	(codePtr),y
.b8c6	c9 80		cmp #$80			cmp 	#KWC_EOL 					; end of line ?
.b8c8	f0 17		beq $b8e1			beq 	_LCExit
.b8ca	c9 10		cmp #$10			cmp 	#16 						; 0-5 are the double punctuations
.b8cc	90 1e		bcc $b8ec			bcc 	_LCDoubles
.b8ce	c9 20		cmp #$20			cmp 	#32 						; 16-31 are shifted punctuation from 64-91
.b8d0	90 2a		bcc $b8fc			bcc 	_LCShiftPunc
.b8d2	c9 40		cmp #$40			cmp 	#64 						; 32-64 are as stored, punc and digits
.b8d4	90 35		bcc $b90b			bcc 	_LCPunctuation
.b8d6	c9 80		cmp #$80			cmp 	#128 						; 64-127 are variable identifiers.
.b8d8	90 51		bcc $b92b			bcc 	_LCIdentifiers
.b8da	c9 fe		cmp #$fe			cmp 	#254 						; 128-253 are tokenised words
.b8dc	90 73		bcc $b951			bcc 	_LCTokens
.b8de	4c b1 b9	jmp $b9b1			jmp 	_LCData 					; 254-5 are data objects
.b8e1					_LCExit:
.b8e1	68		pla				pla 								; get old indent adjust
.b8e2	30 07		bmi $b8eb			bmi 	_LCExit2
.b8e4	18		clc				clc 								; add to indent if +ve
.b8e5	6d 26 04	adc $0426			adc 	listIndent
.b8e8	8d 26 04	sta $0426			sta 	listIndent
.b8eb					_LCExit2:
.b8eb	60		rts				rts
.b8ec					_LCDoubles:
.b8ec	48		pha				pha
.b8ed	4a		lsr a				lsr 	a 							; put bit 2 into bit 1
.b8ee	29 02		and #$02			and 	#2
.b8f0	09 3c		ora #$3c			ora 	#60 						; make < >
.b8f2	20 10 ba	jsr $ba10			jsr 	LCLWrite
.b8f5	68		pla				pla 								; restore, do lower bit
.b8f6	29 03		and #$03			and 	#3
.b8f8	09 3c		ora #$3c			ora 	#60
.b8fa	80 0f		bra $b90b			bra		_LCPunctuation 				; print, increment, loop
.b8fc					_LCShiftPunc:
.b8fc	aa		tax				tax 								; save in X
.b8fd	29 07		and #$07			and 	#7 							; lower 3 bits
.b8ff	f0 02		beq $b903			beq 	_LCNoAdd
.b901	09 18		ora #$18			ora 	#24 						; adds $18 to it.
.b903					_LCNoAdd:
.b903	e0 18		cpx #$18			cpx 	#24 						; if >= 24 add $20
.b905	90 02		bcc $b909			bcc 	_LCNoAdd2
.b907	09 20		ora #$20			ora 	#32 						; adds $20
.b909					_LCNoAdd2:
.b909	09 40		ora #$40			ora 	#$40 						; shift into 64-127 range and fall through.
.b90b					_LCPunctuation:
.b90b	c9 3a		cmp #$3a			cmp 	#':' 						; check if :
.b90d	d0 03		bne $b912			bne 	_LCPContinue
.b90f	20 26 ba	jsr $ba26			jsr 	LCLDeleteLastSpace 			; if so delete any preceding spaces
.b912					_LCPContinue:
.b912	c9 2e		cmp #$2e			cmp 	#'.'
.b914	f0 08		beq $b91e			beq 	_LCPIsConstant
.b916	c9 30		cmp #$30			cmp 	#'0'
.b918	90 0b		bcc $b925			bcc 	_LCPNotConstant
.b91a	c9 3a		cmp #$3a			cmp 	#'9'+1
.b91c	b0 07		bcs $b925			bcs 	_LCPNotConstant
.b91e					_LCPIsConstant:
.b91e	48		pha				pha
.b91f	a9 8d		lda #$8d			lda 	#CLIConstant+$80
.b921	20 07 ba	jsr $ba07			jsr 	LCLWriteColour
.b924	68		pla				pla
.b925					_LCPNotConstant:
.b925	c8		iny				iny 								; consume character
.b926	20 10 ba	jsr $ba10			jsr 	LCLWrite 					; write it out.
.b929	80 94		bra $b8bf			bra 	_LCMainLoop 				; go round again.
.b92b					_LCIdentifiers:
.b92b	18		clc				clc 								; convert to physical address
.b92c	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.b92e	85 37		sta $37				sta 	zTemp0+1
.b930	c8		iny				iny
.b931	b1 30		lda ($30),y			lda 	(codePtr),y
.b933	85 36		sta $36				sta 	zTemp0
.b935	c8		iny				iny
.b936	5a		phy				phy 								; save position
.b937	a9 87		lda #$87			lda 	#CLIIdentifier+$80
.b939	20 07 ba	jsr $ba07			jsr 	LCLWriteColour
.b93c	a0 07		ldy #$07			ldy 	#7 							; output the identifier at +8
.b93e					_LCOutIdentifier:
.b93e	c8		iny				iny
.b93f	b1 36		lda ($36),y			lda 	(zTemp0),y					; bit 7 set = end.
.b941	29 7f		and #$7f			and 	#$7F
.b943	20 62 ba	jsr $ba62			jsr 	LCLLowerCase
.b946	20 10 ba	jsr $ba10			jsr 	LCLWrite
.b949	b1 36		lda ($36),y			lda 	(zTemp0),y				 	; ends when bit 7 set.
.b94b	10 f1		bpl $b93e			bpl 	_LCOutIdentifier
.b94d	7a		ply				ply 								; restore position
.b94e	4c bf b8	jmp $b8bf			jmp 	_LCMainLoop
.b951					_LCTokens:
.b951	aa		tax				tax 								; token in X
.b952	a9 32		lda #$32			lda 	#((KeywordSet2) & $FF)
.b954	85 36		sta $36				sta 	0+zTemp0
.b956	a9 b7		lda #$b7			lda 	#((KeywordSet2) >> 8)
.b958	85 37		sta $37				sta 	1+zTemp0
.b95a	e0 82		cpx #$82			cpx 	#$82
.b95c	f0 16		beq $b974			beq 	_LCUseShift
.b95e	a9 ba		lda #$ba			lda 	#((KeywordSet1) & $FF)
.b960	85 36		sta $36				sta 	0+zTemp0
.b962	a9 b6		lda #$b6			lda 	#((KeywordSet1) >> 8)
.b964	85 37		sta $37				sta 	1+zTemp0
.b966	e0 81		cpx #$81			cpx 	#$81
.b968	f0 0a		beq $b974			beq 	_LCUseShift
.b96a	a9 a3		lda #$a3			lda 	#((KeywordSet0) & $FF)
.b96c	85 36		sta $36				sta 	0+zTemp0
.b96e	a9 b4		lda #$b4			lda 	#((KeywordSet0) >> 8)
.b970	85 37		sta $37				sta 	1+zTemp0
.b972	80 01		bra $b975			bra 	_LCNoShift
.b974					_LCUseShift:
.b974	c8		iny				iny
.b975					_LCNoShift:
.b975	20 3a ba	jsr $ba3a			jsr 	LCLCheckSpaceRequired 		; do we need a space ?
.b978	b1 30		lda ($30),y			lda 	(codePtr),y
.b97a	aa		tax				tax 								; into X
.b97b					_LCFindText:
.b97b	ca		dex				dex
.b97c	10 0e		bpl $b98c			bpl 	_LCFoundText 				; found text.
.b97e	b2 36		lda ($36)			lda 	(zTemp0) 					; length of text
.b980	1a		inc a				inc 	a 							; one extra for size
.b981	38		sec				sec 								; one extra for checksum
.b982	65 36		adc $36				adc 	zTemp0 						; go to next token
.b984	85 36		sta $36				sta 	zTemp0
.b986	90 f3		bcc $b97b			bcc 	_LCFindText
.b988	e6 37		inc $37				inc 	zTemp0+1
.b98a	80 ef		bra $b97b			bra 	_LCFindText
.b98c					_LCFoundText:
.b98c	5a		phy				phy 								; save List position
.b98d	b2 36		lda ($36)			lda 	(zTemp0)					; count to print
.b98f	aa		tax				tax
.b990	a9 83		lda #$83			lda 	#CLIToken+$80
.b992	20 07 ba	jsr $ba07			jsr 	LCLWriteColour
.b995	a0 02		ldy #$02			ldy 	#2
.b997					_LCCopyToken:
.b997	b1 36		lda ($36),y			lda 	(zTemp0),y
.b999	20 62 ba	jsr $ba62			jsr 	LCLLowerCase
.b99c	20 10 ba	jsr $ba10			jsr 	LCLWrite
.b99f	c8		iny				iny
.b9a0	ca		dex				dex
.b9a1	d0 f4		bne $b997			bne 	_LCCopyToken
.b9a3	c9 28		cmp #$28			cmp 	#"(" 						; if last char not ( print a space
.b9a5	f0 05		beq $b9ac			beq 	_LCNoSpace
.b9a7	a9 20		lda #$20			lda 	#' '
.b9a9	20 10 ba	jsr $ba10			jsr 	LCLWrite
.b9ac					_LCNoSpace:
.b9ac	7a		ply				ply 								; restore position.
.b9ad	c8		iny				iny 								; consume token
.b9ae	4c bf b8	jmp $b8bf			jmp 	_LCMainLoop 				; and go around again.
.b9b1					_LCData:
.b9b1	48		pha				pha 								; save type $FE/$FF
.b9b2	a2 24		ldx #$24			ldx 	#'$' 						; figure out $ or "
.b9b4	c9 fe		cmp #$fe			cmp 	#$FE
.b9b6	f0 22		beq $b9da			beq 	_LCHaveOpener
.b9b8	a2 22		ldx #$22			ldx 	#'"'
.b9ba	a9 81		lda #$81			lda 	#CLIData+$80
.b9bc	20 07 ba	jsr $ba07			jsr 	LCLWriteColour
.b9bf	c0 04		cpy #$04			cpy 	#4 							; must be 2nd thing on line
.b9c1	d0 17		bne $b9da			bne 	_LCHaveOpener
.b9c3	88		dey				dey 								; what precedes it ?
.b9c4	b1 30		lda ($30),y			lda 	(codePtr),y
.b9c6	c8		iny				iny
.b9c7	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; if quote
.b9c9	d0 0f		bne $b9da			bne 	_LCHaveOpener
.b9cb	a9 09		lda #$09			lda 	#9 							; tab
.b9cd	20 10 ba	jsr $ba10			jsr 	LCLWrite
.b9d0	a9 97		lda #$97			lda 	#$90+CLIBComment
.b9d2	20 10 ba	jsr $ba10			jsr 	LCLWrite
.b9d5	a9 80		lda #$80			lda 	#CLIFComment+$80
.b9d7	20 07 ba	jsr $ba07			jsr 	LCLWriteColour
.b9da					_LCHaveOpener:
.b9da	8a		txa				txa 								; output prefix (# or ")
.b9db	20 10 ba	jsr $ba10			jsr 	LCLWrite
.b9de	c8		iny				iny 								; get count
.b9df	b1 30		lda ($30),y			lda 	(codePtr),y
.b9e1	aa		tax				tax
.b9e2	c8		iny				iny 								; point at first character
.b9e3					_LCOutData:
.b9e3	b1 30		lda ($30),y			lda 	(codePtr),y
.b9e5	c9 00		cmp #$00			cmp 	#0
.b9e7	f0 03		beq $b9ec			beq 	_LCNoPrint
.b9e9	20 10 ba	jsr $ba10			jsr 	LCLWrite
.b9ec					_LCNoPrint:
.b9ec	c8		iny				iny
.b9ed	ca		dex				dex
.b9ee	d0 f3		bne $b9e3			bne 	_LCOutData
.b9f0	68		pla				pla 								; closing " required ?
.b9f1	c9 ff		cmp #$ff			cmp 	#$FF 						; not required for hex constant.
.b9f3	d0 0f		bne $ba04			bne 	_LCNoQuote
.b9f5	a9 22		lda #$22			lda 	#'"'
.b9f7	20 10 ba	jsr $ba10			jsr 	LCLWrite
.b9fa	ad 6e 06	lda $066e			lda 	EXTTextColour
.b9fd	29 0f		and #$0f			and 	#$0F
.b9ff	09 90		ora #$90			ora 	#$90
.ba01	20 10 ba	jsr $ba10			jsr 	LCLWrite
.ba04					_LCNoQuote:
.ba04	4c bf b8	jmp $b8bf			jmp 	_LCMainLoop
.ba07					LCLWriteColour:
.ba07	cd 29 04	cmp $0429			cmp 	currentListColour 			; has the colour changed
.ba0a	8d 29 04	sta $0429			sta 	currentListColour 			; (update it anyway)
.ba0d	d0 01		bne $ba10			bne 	LCLWrite 					; if different, output it
.ba0f	60		rts				rts
.ba10					LCLWrite:
.ba10	da		phx				phx
.ba11	ae 1d 04	ldx $041d			ldx 	tbOffset 					; write out make ASCIIZ
.ba14	9d 2d 04	sta $042d,x			sta 	tokenBuffer,x
.ba17	9e 2e 04	stz $042e,x			stz 	tokenBuffer+1,x
.ba1a	ee 1d 04	inc $041d			inc 	tbOffset 					; bump the position
.ba1d	09 00		ora #$00			ora 	#0 							; don't update last character if colour data
.ba1f	30 03		bmi $ba24			bmi 	_LCLNoColour
.ba21	8d 27 04	sta $0427			sta 	LCLastCharacter
.ba24					_LCLNoColour:
.ba24	fa		plx				plx
.ba25	60		rts				rts
.ba26					LCLDeleteLastSpace:
.ba26	48		pha				pha
.ba27	da		phx				phx
.ba28	ae 1d 04	ldx $041d			ldx 	tbOffset
.ba2b	f0 0a		beq $ba37			beq 	_LCDLSExit
.ba2d	bd 2c 04	lda $042c,x			lda 	tokenBuffer-1,x
.ba30	c9 20		cmp #$20			cmp 	#' '
.ba32	d0 03		bne $ba37			bne 	_LCDLSExit
.ba34	ce 1d 04	dec $041d			dec 	tbOffset
.ba37					_LCDLSExit:
.ba37	fa		plx				plx
.ba38	68		pla				pla
.ba39	60		rts				rts
.ba3a					LCLCheckSpaceRequired:
.ba3a	ad 27 04	lda $0427			lda 	LCLastCharacter 			; check last character
.ba3d	c9 24		cmp #$24			cmp 	#'$' 						; $ # and ) require that token space.
.ba3f	f0 1b		beq $ba5c			beq 	_LCCSRSpace
.ba41	c9 29		cmp #$29			cmp 	#')'
.ba43	f0 17		beq $ba5c			beq 	_LCCSRSpace
.ba45	c9 23		cmp #$23			cmp 	#'#'
.ba47	f0 13		beq $ba5c			beq 	_LCCSRSpace
.ba49	20 62 ba	jsr $ba62			jsr 	LCLLowerCase 				; saves a little effort
.ba4c	c9 30		cmp #$30			cmp 	#"0" 						; check if it was 0-9 A-Z a-z if so need space.
.ba4e	90 11		bcc $ba61			bcc 	_LCCSRExit
.ba50	c9 3a		cmp #$3a			cmp 	#"9"+1
.ba52	90 08		bcc $ba5c			bcc 	_LCCSRSpace
.ba54	c9 61		cmp #$61			cmp 	#"a"
.ba56	90 09		bcc $ba61			bcc 	_LCCSRExit
.ba58	c9 7b		cmp #$7b			cmp 	#"z"+1
.ba5a	b0 05		bcs $ba61			bcs 	_LCCSRExit
.ba5c					_LCCSRSpace:
.ba5c	a9 20		lda #$20			lda 	#' '
.ba5e	20 10 ba	jsr $ba10			jsr 	LCLWrite
.ba61					_LCCSRExit:
.ba61	60		rts				rts
.ba62					LCLLowerCase:
.ba62	c9 41		cmp #$41			cmp 	#"A"
.ba64	90 06		bcc $ba6c			bcc 	_LCLLCOut
.ba66	c9 5b		cmp #$5b			cmp 	#"Z"+1
.ba68	b0 02		bcs $ba6c			bcs 	_LCLLCOut
.ba6a	69 20		adc #$20			adc 	#$20
.ba6c					_LCLLCOut:
.ba6c	60		rts				rts
.ba6d					LCLUpperCase:
.ba6d	c9 61		cmp #$61			cmp 	#"a"
.ba6f	90 06		bcc $ba77			bcc 	_LCLUCOut
.ba71	c9 7b		cmp #$7b			cmp 	#"z"+1
.ba73	b0 02		bcs $ba77			bcs 	_LCLUCOut
.ba75	e9 1f		sbc #$1f			sbc 	#$1F
.ba77					_LCLUCOut:
.ba77	60		rts				rts
.ba78					LCLWriteNumberXA:
.ba78	64 37		stz $37				stz 	zTemp0+1 					; index into digit table.
.ba7a					_LCLWNLoop1:
.ba7a	64 36		stz $36				stz 	zTemp0 						; subtraction count.
.ba7c					_LCLWNLoop2:
.ba7c	48		pha				pha 								; save initial LSB
.ba7d	38		sec				sec
.ba7e	a4 37		ldy $37				ldy 	zTemp0+1 					; position in table.
.ba80	f9 b1 ba	sbc $bab1,y			sbc 	_LCLWNTable,y
.ba83	48		pha				pha
.ba84	8a		txa				txa
.ba85	f9 b2 ba	sbc $bab2,y			sbc 	_LCLWNTable+1,y
.ba88	90 07		bcc $ba91			bcc 	_LCLWNUnderflow
.ba8a	e6 36		inc $36				inc 	zTemp0  					; subtracted one without borrow.
.ba8c	aa		tax				tax 								; update X
.ba8d	68		pla				pla 								; restore A
.ba8e	7a		ply				ply 								; throw original
.ba8f	80 eb		bra $ba7c			bra 	_LCLWNLoop2 				; try again.
.ba91					_LCLWNUnderflow:
.ba91	a4 36		ldy $36				ldy 	zTemp0 						; count of subtractions.
.ba93	d0 06		bne $ba9b			bne 	_LCLWNOut
.ba95	ad 1d 04	lda $041d			lda 	tbOffset 					; suppress leading zeroes
.ba98	3a		dec a				dec 	a
.ba99	f0 04		beq $ba9f			beq 	_LCLWNNext
.ba9b					_LCLWNOut:
.ba9b	98		tya				tya
.ba9c	20 ab ba	jsr $baab			jsr 	_LCLWNOutDigit
.ba9f					_LCLWNNext:
.ba9f	7a		ply				ply 							 	; restore original value.
.baa0	68		pla				pla
.baa1	a4 37		ldy $37				ldy 	zTemp0+1  					; bump the index
.baa3	c8		iny				iny
.baa4	c8		iny				iny
.baa5	84 37		sty $37				sty 	zTemp0+1
.baa7	c0 08		cpy #$08			cpy 	#8 							; done all 4
.baa9	d0 cf		bne $ba7a			bne 	_LCLWNLoop1
.baab					_LCLWNOutDigit:
.baab	09 30		ora #$30			ora 	#'0'
.baad	20 10 ba	jsr $ba10			jsr 	LCLWrite
.bab0	60		rts				rts
.bab1					_LCLWNTable:
>bab1	10 27						.word 	10000
>bab3	e8 03						.word 	1000
>bab5	64 00						.word 	100
>bab7	0a 00						.word 	10
.bab9					TOKSearchTable:
.bab9	84 37		sty $37				sty 	zTemp0+1 					; (zTemp0),y points to current token being tested.
.babb	85 36		sta $36				sta 	zTemp0
.babd	a0 00		ldy #$00			ldy 	#0
.babf	a9 80		lda #$80			lda 	#$80 						; token # so we know which one we are looking at
.bac1	85 38		sta $38				sta 	zTemp1
.bac3					_TSTLoop:
.bac3	b1 36		lda ($36),y			lda 	(zTemp0),y 					; length, 0 (skip) -ve (end)
.bac5	30 49		bmi $bb10			bmi 	_TSTFail 					; -ve = end of table, so fail.
.bac7	f0 2e		beq $baf7			beq 	_TSTNext 					; zero, check next as it's a dummy (e.g. EOL, SHIFT)
.bac9	c8		iny				iny 								; get the hash
.baca	b1 36		lda ($36),y			lda 	(zTemp0),y
.bacc	88		dey				dey
.bacd	cd 03 04	cmp $0403			cmp 	identHash 					; check they match with the identifier hash, if not go to next
.bad0	d0 25		bne $baf7			bne 	_TSTNext
.bad2	ad 02 04	lda $0402			lda 	identTypeEnd 				; get length of identifier from end-start
.bad5	38		sec				sec
.bad6	ed 00 04	sbc $0400			sbc 	identStart
.bad9	d1 36		cmp ($36),y			cmp 	(zTemp0),y 					; compare against the length in the table, no match, then return.
.badb	d0 1a		bne $baf7			bne 	_TSTNext
.badd	5a		phy				phy 								; save Y , we might fail to match.
.bade	c8		iny				iny 								; point to text
.badf	c8		iny				iny
.bae0	ae 00 04	ldx $0400			ldx 	identStart 					; offset in line buffer in X
.bae3					_TSTCompareName:
.bae3	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; compare text.
.bae6	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.bae8	d0 0c		bne $baf6			bne 	_TSTNextPullY 				; fail, pullY and do next
.baea	e8		inx				inx
.baeb	c8		iny				iny
.baec	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; complete match.
.baef	d0 f2		bne $bae3			bne 	_TSTCompareName
.baf1	7a		ply				ply 								; throw Y
.baf2	a5 38		lda $38				lda 	zTemp1 						; get token #
.baf4	38		sec				sec 								; return with CS = passed.
.baf5	60		rts				rts
.baf6					_TSTNextPullY:
.baf6	7a		ply				ply 								; restore current, fall through.
.baf7					_TSTNext:
.baf7	e6 38		inc $38				inc 	zTemp1 						; token counter
.baf9	98		tya				tya
.bafa	18		clc				clc
.bafb	71 36		adc ($36),y			adc 	(zTemp0),y 					; add [Length] + 2 to Y
.bafd	1a		inc a				inc 	a 							; +1
.bafe	1a		inc a				inc 	a 							; +2
.baff	a8		tay				tay
.bb00	10 c1		bpl $bac3			bpl 	_TSTLoop 					; if Y < $80 loop back
.bb02	98		tya				tya 								; add Y to zTemp0 and reset Y
.bb03	a0 00		ldy #$00			ldy 	#0   						; so we can use Y to search fast
.bb05	18		clc				clc  								; but have tables > 255 bytes
.bb06	65 36		adc $36				adc 	zTemp0 						; when Y gets >= 128 we reset Y
.bb08	85 36		sta $36				sta 	zTemp0 						; and adjust the table pointer/
.bb0a	90 b7		bcc $bac3			bcc 	_TSTLoop
.bb0c	e6 37		inc $37				inc 	zTemp0+1
.bb0e	80 b3		bra $bac3			bra 	_TSTLoop
.bb10					_TSTFail:
.bb10	18		clc				clc
.bb11	60		rts				rts
.bb12					Export_TKTokeniseLine:
.bb12	20 9a bc	jsr $bc9a			jsr 	LCLFixLineBufferCase 		; fix line case
.bb15	a9 03		lda #$03			lda 	#3 							; reset the token buffer to empty
.bb17	8d 2a 04	sta $042a			sta 	tokenOffset 				; (3 bytes for line number & offset)
.bb1a	9c 2b 04	stz $042b			stz 	tokenLineNumber
.bb1d	9c 2c 04	stz $042c			stz 	tokenLineNumber+1
.bb20	a2 ff		ldx #$ff			ldx 	#$FF
.bb22					_TKFindFirst:
.bb22	e8		inx				inx
.bb23	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.bb26	f0 79		beq $bba1			beq 	_TKExit
.bb28	c9 20		cmp #$20			cmp 	#' '
.bb2a	90 f6		bcc $bb22			bcc 	_TKFindFirst
.bb2c	c9 30		cmp #$30			cmp 	#'0'
.bb2e	90 07		bcc $bb37			bcc 	_TKNoLineNumber
.bb30	c9 3a		cmp #$3a			cmp 	#'9'+1
.bb32	b0 03		bcs $bb37			bcs 	_TKNoLineNumber
.bb34	20 c4 bc	jsr $bcc4			jsr 	TOKExtractLineNumber
.bb37					_TKNoLineNumber:
.bb37					_TKTokeniseLoop:
.bb37	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; next character, exit if zero EOL.
.bb3a	f0 65		beq $bba1			beq 	_TKExit
.bb3c	e8		inx				inx
.bb3d	c9 20		cmp #$20			cmp 	#' '
.bb3f	f0 f6		beq $bb37			beq 	_TKTokeniseLoop 			; keep looping if space found.
.bb41	ca		dex				dex 								; undo last get, A contains character, X is position.
.bb42	c9 5f		cmp #$5f			cmp 	#'_'						; _ A-Z is identifier *or* token
.bb44	f0 61		beq $bba7			beq 	_TKTokeniseIdentifier 		; (already case converted outside string constants)
.bb46	c9 41		cmp #$41			cmp 	#'A'
.bb48	90 04		bcc $bb4e			bcc 	_TKTokenisePunctuation
.bb4a	c9 5b		cmp #$5b			cmp 	#'Z'+1
.bb4c	90 59		bcc $bba7			bcc 	_TKTokeniseIdentifier
.bb4e					_TKTokenisePunctuation:
.bb4e	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.bb50	f0 27		beq $bb79			beq 	_TKString
.bb52	c9 24		cmp #$24			cmp 	#'$'						; hexadecimal constant ($ only appears at end of identifiers)
.bb54	f0 28		beq $bb7e			beq 	_TKHexConstant
.bb56	c9 3c		cmp #$3c			cmp 	#'<' 						; check for < > handlers - these are for <> <= >= >> <<
.bb58	f0 29		beq $bb83			beq 	_TKCheckDouble
.bb5a	c9 3e		cmp #$3e			cmp 	#'>'
.bb5c	f0 25		beq $bb83			beq 	_TKCheckDouble
.bb5e					_TKStandardPunctuation:
.bb5e	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get the punctuation token back.
.bb61	c9 40		cmp #$40			cmp 	#64 						; are we >= 64
.bb63	90 0e		bcc $bb73			bcc 	_TKNoShift
.bb65	48		pha				pha 								; save. we are about to convert this punctuation token from
.bb66	29 07		and #$07			and 	#7 							; lower 3 bits in zTemp0
.bb68	85 36		sta $36				sta 	zTemp0
.bb6a	68		pla				pla
.bb6b	29 20		and #$20			and 	#32 						; bit 5
.bb6d	4a		lsr a				lsr 	a 							; shift into bit 3
.bb6e	4a		lsr a				lsr 	a
.bb6f	05 36		ora $36				ora 	zTemp0
.bb71	09 10		ora #$10			ora 	#$10						; now in the range 16-31
.bb73					_TKNoShift:
.bb73	20 09 bd	jsr $bd09			jsr 	TOKWriteByte 				; write the punctuation character
.bb76	e8		inx				inx 								; consume the character
.bb77	80 be		bra $bb37			bra 	_TKTokeniseLoop 			; and loop round again.
.bb79					_TKString:
.bb79	20 29 bc	jsr $bc29			jsr 	TOKTokenString
.bb7c	80 b9		bra $bb37			bra 	_TKTokeniseLoop
.bb7e					_TKHexConstant:
.bb7e	20 64 bc	jsr $bc64			jsr 	TOKHexConstant
.bb81	80 b4		bra $bb37			bra 	_TKTokeniseLoop
.bb83					_TKCheckDouble:
.bb83	bd 2b 05	lda $052b,x			lda 	lineBuffer+1,x 				; get next character
.bb86	c9 3c		cmp #$3c			cmp 	#'<'						; if not < = > which are ASCII consecutive go back
.bb88	90 d4		bcc $bb5e			bcc 	_TKStandardPunctuation 		; and do the normal punctuation handler.
.bb8a	c9 3f		cmp #$3f			cmp 	#'>'+1
.bb8c	b0 d0		bcs $bb5e			bcs 	_TKStandardPunctuation
.bb8e	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; this is < (60) or > (62)
.bb91	29 02		and #$02			and 	#2 							; now < (0) or > (2)
.bb93	0a		asl a				asl 	a 							; now < (0) or > (4), CC also
.bb94	7d 2b 05	adc $052b,x			adc 	lineBuffer+1,x 				; add < = > codes - < code
.bb97	38		sec				sec
.bb98	e9 3c		sbc #$3c			sbc 	#'<'
.bb9a	20 09 bd	jsr $bd09			jsr 	TOKWriteByte 				; this is in the range 0-7
.bb9d	e8		inx				inx 								; consume both
.bb9e	e8		inx				inx
.bb9f	80 96		bra $bb37			bra 	_TKTokeniseLoop
.bba1	a9 80		lda #$80	_TKExit:lda 	#KWC_EOL 					; write end of line byte
.bba3	20 09 bd	jsr $bd09			jsr 	TOKWriteByte
.bba6	60		rts				rts
.bba7					_TKTokeniseIdentifier:
.bba7	8e 00 04	stx $0400			stx 	identStart 					; save start
.bbaa	9c 04 04	stz $0404			stz 	identTypeByte 				; zero the type byte
.bbad					_TKCheckLoop:
.bbad	e8		inx				inx 								; look at next, we know first is identifier already.
.bbae	bd 2a 05	lda $052a,x			lda  	lineBuffer,x
.bbb1	c9 5f		cmp #$5f			cmp 	#"_" 						; legal char _ 0-9 A-Z
.bbb3	f0 f8		beq $bbad			beq 	_TKCheckLoop
.bbb5	c9 30		cmp #$30			cmp	 	#"0"
.bbb7	90 0c		bcc $bbc5			bcc 	_TKEndIdentifier
.bbb9	c9 3a		cmp #$3a			cmp 	#"9"+1
.bbbb	90 f0		bcc $bbad			bcc 	_TKCheckLoop
.bbbd	c9 41		cmp #$41			cmp	 	#"A"
.bbbf	90 04		bcc $bbc5			bcc 	_TKEndIdentifier
.bbc1	c9 5b		cmp #$5b			cmp 	#"Z"+1
.bbc3	90 e8		bcc $bbad			bcc 	_TKCheckLoop
.bbc5					_TKEndIdentifier:
.bbc5	8e 01 04	stx $0401			stx 	identTypeStart 				; save start of type text (if any !)
.bbc8	a0 08		ldy #$08			ldy 	#$08 						; this is the identifier type byte for #
.bbca	c9 23		cmp #$23			cmp 	#"#"						; followed by #
.bbcc	f0 06		beq $bbd4			beq 	_TKHasTypeCharacter
.bbce	a0 10		ldy #$10			ldy 	#$10 						; this is the identifier type byte for $
.bbd0	c9 24		cmp #$24			cmp 	#"$"						; followed by $ or #
.bbd2	d0 07		bne $bbdb			bne 	_TKNoTypeCharacter
.bbd4					_TKHasTypeCharacter:
.bbd4	8c 04 04	sty $0404			sty 	identTypeByte 				; has # or $, save the type
.bbd7	e8		inx				inx 								; consume the type character
.bbd8	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.bbdb					_TKNoTypeCharacter:
.bbdb	c9 28		cmp #$28			cmp 	#"("						; is it open parenthesis (e.g. array)
.bbdd	d0 09		bne $bbe8			bne 	_TKNoArray
.bbdf	e8		inx				inx 								; skip the (
.bbe0	ad 04 04	lda $0404			lda 	identTypeByte 				; set bit 2 (e.g. array) in type byte
.bbe3	09 04		ora #$04			ora 	#$04
.bbe5	8d 04 04	sta $0404			sta 	identTypeByte
.bbe8					_TKNoArray:
.bbe8	8e 02 04	stx $0402			stx 	identTypeEnd 				; save end marker, e.g. continue from here.
.bbeb	20 85 bc	jsr $bc85			jsr 	TOKCalculateHash 			; calculate the has for those tokens
.bbee	a0 b4		ldy #$b4			ldy 	#(KeywordSet0) >> 8
.bbf0	a9 a3		lda #$a3			lda 	#(KeywordSet0) & $FF
.bbf2	20 b9 ba	jsr $bab9			jsr 	TOKSearchTable
.bbf5	a2 00		ldx #$00			ldx 	#0
.bbf7	b0 1f		bcs $bc18			bcs 	_TKFoundToken
.bbf9	a0 b6		ldy #$b6			ldy 	#(KeywordSet1) >> 8
.bbfb	a9 ba		lda #$ba			lda 	#(KeywordSet1) & $FF
.bbfd	20 b9 ba	jsr $bab9			jsr 	TOKSearchTable
.bc00	a2 81		ldx #$81			ldx 	#$81
.bc02	b0 14		bcs $bc18			bcs 	_TKFoundToken
.bc04	a0 b7		ldy #$b7			ldy 	#(KeywordSet2) >> 8
.bc06	a9 32		lda #$32			lda 	#(KeywordSet2) & $FF
.bc08	20 b9 ba	jsr $bab9			jsr 	TOKSearchTable
.bc0b	a2 82		ldx #$82			ldx 	#$82
.bc0d	b0 09		bcs $bc18			bcs 	_TKFoundToken
.bc0f	20 15 bd	jsr $bd15			jsr 	TOKCheckCreateVariableRecord ; failed all, it's a variable, create record if does not exist.
.bc12	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.bc15	4c 37 bb	jmp $bb37			jmp 	_TKTokeniseLoop 			; and go round again.
.bc18					_TKFoundToken:
.bc18	48		pha				pha 								; save token
.bc19	8a		txa				txa 								; shift in X, is there one ?
.bc1a	f0 03		beq $bc1f			beq 	_TKNoTShift
.bc1c	20 09 bd	jsr $bd09			jsr 	TOKWriteByte 				; if so, write it out
.bc1f					_TKNoTShift:
.bc1f	68		pla				pla 								; restore and write token
.bc20	20 09 bd	jsr $bd09			jsr 	TOKWriteByte
.bc23	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.bc26	4c 37 bb	jmp $bb37			jmp 	_TKTokeniseLoop 			; and go round again.
.bc29					TOKTokenString:
.bc29	a9 ff		lda #$ff			lda 	#KWC_STRING 				; string token.
.bc2b	20 09 bd	jsr $bd09			jsr 	TOKWriteByte
.bc2e	e8		inx				inx									; start of quoted string.
.bc2f	da		phx				phx 								; push start of string on top
.bc30	ca		dex				dex 								; because we pre-increment
.bc31					_TSFindEnd:
.bc31	e8		inx				inx
.bc32	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; next character
.bc35	f0 04		beq $bc3b			beq 	_TSEndOfString 				; no matching quote, we don't mind.
.bc37	c9 22		cmp #$22			cmp 	#'"' 						; go back if quote not found
.bc39	d0 f6		bne $bc31			bne 	_TSFindEnd
.bc3b					_TSEndOfString:
.bc3b	7a		ply				ply  								; so now Y is first character, X is character after end.
.bc3c	48		pha				pha 								; save terminating character
.bc3d	20 45 bc	jsr $bc45			jsr 	TOKWriteBlockXY 			; write X to Y as a data block
.bc40	68		pla				pla 								; terminating character
.bc41	f0 01		beq $bc44			beq 	_TSNotQuote					; if it wasn't EOS skip it
.bc43	e8		inx				inx
.bc44					_TSNotQuote:
.bc44	60		rts				rts
.bc45					TOKWriteBlockXY:
.bc45	86 36		stx $36				stx 	zTemp0 						; save end character
.bc47	98		tya				tya 								; use 2's complement to work out the byte size
.bc48	49 ff		eor #$ff			eor 	#$FF
.bc4a	38		sec				sec
.bc4b	65 36		adc $36				adc 	zTemp0
.bc4d	1a		inc a				inc 	a 							; one extra for NULL
.bc4e	20 09 bd	jsr $bd09			jsr 	TOKWriteByte
.bc51					_TOBlockLoop:
.bc51	c4 36		cpy $36				cpy 	zTemp0 						; exit if reached the end
.bc53	f0 09		beq $bc5e			beq 	_TOBlockExit
.bc55	b9 2a 05	lda $052a,y			lda 	lineBuffer,y 				; write byte out.
.bc58	20 09 bd	jsr $bd09			jsr 	TOKWriteByte
.bc5b	c8		iny				iny
.bc5c	80 f3		bra $bc51			bra 	_TOBlockLoop
.bc5e					_TOBlockExit:
.bc5e	a9 00		lda #$00			lda 	#0 							; add NULL.
.bc60	20 09 bd	jsr $bd09			jsr 	TOKWriteByte
.bc63	60		rts				rts
.bc64					TOKHexConstant:
.bc64	a9 fe		lda #$fe			lda 	#KWC_HEXCONST 				; hex constant token.
.bc66	20 09 bd	jsr $bd09			jsr 	TOKWriteByte
.bc69	e8		inx				inx									; start of quoted string.
.bc6a	da		phx				phx 								; push start of constant on top
.bc6b	ca		dex				dex
.bc6c					_THFindLoop:
.bc6c	e8		inx				inx 	 							; this is stored in a block, so find out how long
.bc6d	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; the hex constant is.
.bc70	c9 30		cmp #$30			cmp 	#"0"
.bc72	90 0c		bcc $bc80			bcc 	_THFoundEnd
.bc74	c9 3a		cmp #$3a			cmp 	#"9"+1
.bc76	90 f4		bcc $bc6c			bcc 	_THFindLoop
.bc78	c9 41		cmp #$41			cmp 	#"A"
.bc7a	90 04		bcc $bc80			bcc 	_THFoundEnd
.bc7c	c9 47		cmp #$47			cmp 	#"F"+1
.bc7e	90 ec		bcc $bc6c			bcc 	_THFindLoop
.bc80					_THFoundEnd:
.bc80	7a		ply				ply 								; restore start
.bc81	20 45 bc	jsr $bc45			jsr 	TOKWriteBlockXY 			; output the block
.bc84	60		rts				rts
.bc85					TOKCalculateHash:
.bc85	da		phx				phx
.bc86	ae 00 04	ldx $0400			ldx 	identStart 					; needs to be same as in tokens.py - simple sum at present.
.bc89	a9 00		lda #$00			lda 	#0
.bc8b					_TCHLoop:
.bc8b	18		clc				clc
.bc8c	7d 2a 05	adc $052a,x			adc 	lineBuffer,x
.bc8f	e8		inx				inx
.bc90	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; do the whole thing including type and array markers.
.bc93	d0 f6		bne $bc8b			bne 	_TCHLoop
.bc95	8d 03 04	sta $0403			sta 	identHash 					; save the hash
.bc98	fa		plx				plx
.bc99	60		rts				rts
.bc9a					LCLFixLineBufferCase:
.bc9a	a2 00		ldx #$00			ldx 	#0
.bc9c					_FLBCLoop:
.bc9c	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get next character
.bc9f	f0 22		beq $bcc3			beq 	_FLBCExit 					; end of string.
.bca1	c9 22		cmp #$22			cmp 	#'"'						; quote, go to in quotes
.bca3	f0 11		beq $bcb6			beq 	_FLBCInQuotes
.bca5	e8		inx				inx
.bca6	c9 61		cmp #$61			cmp 	#'a'						; needs capitalising ?
.bca8	90 f2		bcc $bc9c			bcc 	_FLBCLoop
.bcaa	c9 7b		cmp #$7b			cmp 	#'z'+1
.bcac	b0 ee		bcs $bc9c			bcs 	_FLBCLoop
.bcae	38		sec				sec 								; make U/C
.bcaf	e9 20		sbc #$20			sbc 	#32
.bcb1	9d 29 05	sta $0529,x			sta	 	lineBuffer-1,x 				; write back
.bcb4	80 e6		bra $bc9c			bra 	_FLBCLoop
.bcb6					_FLBCInQuotes:
.bcb6	e8		inx				inx 								; advance
.bcb7	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get next
.bcba	f0 07		beq $bcc3			beq 	_FLBCExit 					; exit on EOS
.bcbc	c9 22		cmp #$22			cmp 	#'"' 				 		; until " found
.bcbe	d0 f6		bne $bcb6			bne 	_FLBCInQuotes
.bcc0	e8		inx				inx 								; skip over it
.bcc1	80 d9		bra $bc9c			bra 	_FLBCLoop
.bcc3					_FLBCExit:
.bcc3	60		rts				rts
.bcc4					TOKExtractLineNumber:
.bcc4	ad 2c 04	lda $042c			lda 	tokenLineNumber+1 			; push current value on stack
.bcc7	48		pha				pha
.bcc8	ad 2b 04	lda $042b			lda 	tokenLineNumber
.bccb	48		pha				pha
.bccc	20 02 bd	jsr $bd02			jsr 	_LCLNTimes2 				; line # x 2
.bccf	20 02 bd	jsr $bd02			jsr 	_LCLNTimes2 				; line # x 4
.bcd2	18		clc				clc 								; add stacked value
.bcd3	68		pla				pla
.bcd4	6d 2b 04	adc $042b			adc 	tokenLineNumber
.bcd7	8d 2b 04	sta $042b			sta 	tokenLineNumber
.bcda	68		pla				pla
.bcdb	6d 2c 04	adc $042c			adc 	tokenLineNumber+1
.bcde	8d 2c 04	sta $042c			sta 	tokenLineNumber+1 			; line # x 5
.bce1	20 02 bd	jsr $bd02			jsr 	_LCLNTimes2 				; line # x 10
.bce4	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get and consume character
.bce7	e8		inx				inx
.bce8	29 0f		and #$0f			and 	#15 						; add to line #
.bcea	18		clc				clc
.bceb	6d 2b 04	adc $042b			adc 	tokenLineNumber
.bcee	8d 2b 04	sta $042b			sta 	tokenLineNumber
.bcf1	90 03		bcc $bcf6			bcc 	_TLENNoCarry
.bcf3	ee 2c 04	inc $042c			inc 	tokenLineNumber+1
.bcf6					_TLENNoCarry:
.bcf6	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; more digits ?
.bcf9	c9 30		cmp #$30			cmp 	#'0'
.bcfb	90 04		bcc $bd01			bcc 	_TLENExit
.bcfd	c9 3a		cmp #$3a			cmp 	#'9'+1
.bcff	90 c3		bcc $bcc4			bcc 	TOKExtractLineNumber
.bd01					_TLENExit:
.bd01	60		rts				rts
.bd02					_LCLNTimes2:
.bd02	0e 2b 04	asl $042b			asl 	tokenLineNumber 			; doubles tokenLineNumber.
.bd05	2e 2c 04	rol $042c			rol 	tokenLineNumber+1
.bd08	60		rts				rts
.bd09					TOKWriteByte:
.bd09	da		phx				phx
.bd0a	ae 2a 04	ldx $042a			ldx 	tokenOffset 				; next slot to write to
.bd0d	9d 2a 04	sta $042a,x			sta 	tokenOffset,x 				; write byte out
.bd10	ee 2a 04	inc $042a			inc 	tokenOffset 				; advance slot.
.bd13	fa		plx				plx
.bd14	60		rts				rts
.bd15					TOKCheckCreateVariableRecord:
.bd15	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.bd17	85 36		sta $36				sta 	0+zTemp0
.bd19	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.bd1b	85 37		sta $37				sta 	1+zTemp0
.bd1d					_CCVSearch:
.bd1d	b2 36		lda ($36)			lda 	(zTemp0) 					; end of list
.bd1f	f0 2c		beq $bd4d			beq 	_CCVFail
.bd21	a0 01		ldy #$01			ldy 	#1 							; read the hash
.bd23	b1 36		lda ($36),y			lda 	(zTemp0),y 					; does it match ?
.bd25	cd 03 04	cmp $0403			cmp 	identHash 	  				; if not, try the next.
.bd28	d0 16		bne $bd40			bne 	_CCVNext
.bd2a	a0 08		ldy #$08			ldy 	#8 							; name in variable record
.bd2c	ae 00 04	ldx $0400			ldx 	identStart
.bd2f					_CCVCompare:
.bd2f	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; xor them. zero if the same, except
.bd32	51 36		eor ($36),y			eor 	(zTemp0),y 					; bit 7 is used for EOS.
.bd34	e8		inx				inx 								; advance pointers
.bd35	c8		iny				iny
.bd36	0a		asl a				asl 	a 							; A = 0 if they match, CS if end.
.bd37	d0 07		bne $bd40			bne 	_CCVNext  					; didn't match go to next.
.bd39	90 f4		bcc $bd2f			bcc 	_CCVCompare 				; not finished yet.
.bd3b	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; matched whole thing ?
.bd3e	f0 41		beq $bd81			beq 	_CCVFound 					; yes, we were successful
.bd40					_CCVNext:
.bd40	18		clc				clc 								; go to next record.
.bd41	b2 36		lda ($36)			lda 	(zTemp0) 					; add offset to pointer
.bd43	65 36		adc $36				adc 	zTemp0
.bd45	85 36		sta $36				sta 	zTemp0
.bd47	90 d4		bcc $bd1d			bcc 	_CCVSearch
.bd49	e6 37		inc $37				inc 	zTemp0+1
.bd4b	80 d0		bra $bd1d			bra 	_CCVSearch
.bd4d					_CCVFail:
.bd4d	a0 01		ldy #$01			ldy 	#1 							; create the new record. Offset 1 is hash
.bd4f	ad 03 04	lda $0403			lda 	identHash
.bd52	91 36		sta ($36),y			sta 	(zTemp0),y
.bd54	c8		iny				iny 								; offset 2 is the type byte
.bd55	ad 04 04	lda $0404			lda 	identTypeByte
.bd58	91 36		sta ($36),y			sta 	(zTemp0),y
.bd5a	c8		iny				iny
.bd5b					_CCVData:
.bd5b	a9 00		lda #$00			lda 	#0 							; erase data 3-7 (the 5 value bytes)
.bd5d	91 36		sta ($36),y			sta 	(zTemp0),y
.bd5f	c8		iny				iny
.bd60	c0 08		cpy #$08			cpy 	#8
.bd62	90 f7		bcc $bd5b			bcc 	_CCVData
.bd64	ae 00 04	ldx $0400			ldx 	identStart 					; copy name into 8 on.
.bd67					_CCVCopyName:
.bd67	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.bd6a	91 36		sta ($36),y			sta 	(zTemp0),y
.bd6c	e8		inx				inx
.bd6d	c8		iny				iny
.bd6e	ec 02 04	cpx $0402			cpx 	identTypeEnd
.bd71	d0 f4		bne $bd67			bne 	_CCVCopyName
.bd73	98		tya				tya 								; patch offset
.bd74	92 36		sta ($36)			sta 	(zTemp0)
.bd76	a9 00		lda #$00			lda 	#0 							; offset for next is zero.
.bd78	91 36		sta ($36),y			sta 	(zTemp0),y
.bd7a	88		dey				dey
.bd7b	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set bit 7 of last bit
.bd7d	09 80		ora #$80			ora 	#$80
.bd7f	91 36		sta ($36),y			sta 	(zTemp0),y
.bd81					_CCVFound:
.bd81	a5 37		lda $37				lda 	zTemp0+1 					; write out MSB
.bd83	38		sec				sec
.bd84	e9 10		sbc #$10			sbc 	#(VariableSpace >> 8) 		; offset from the start of the variable token
.bd86	09 40		ora #$40			ora 	#$40 						; make it a writeable token $4000-$7FFF
.bd88	20 09 bd	jsr $bd09			jsr 	TOKWriteByte
.bd8b	a5 36		lda $36				lda 	zTemp0 						; write out LSB
.bd8d	20 09 bd	jsr $bd09			jsr 	TOKWriteByte
.bd90	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_sound.module

=1					soundIntegrated=1
.bd91					SNDCheckChannel:
.bd91	aa		tax				tax
.bd92	bd 37 08	lda $0837,x			lda 	SNDTimeLeft,x 				; currently playing a note
.bd95	d0 38		bne $bdcf			bne 	_SNDCCExit
.bd97	da		phx				phx 								; save current channel
.bd98	8a		txa				txa 								; put in A
.bd99	20 15 be	jsr $be15			jsr 	SNDFindNextNoteForA 		; is there a note for A in the queue ?
.bd9c	68		pla				pla 								; channel # in A
.bd9d	90 30		bcc $bdcf			bcc 	_SNDCCExit  				; nothing in the queue for this channel, exit.
.bd9f	a8		tay				tay 								; Y is the channel #
.bda0	bd 2c 07	lda $072c,x			lda 	SNDQueue+1,x 				; copy data into the slot.
.bda3	99 2b 08	sta $082b,y			sta 	SNDPitchLow,y
.bda6	bd 2d 07	lda $072d,x			lda 	SNDQueue+2,x
.bda9	99 2f 08	sta $082f,y			sta 	SNDPitchHigh,y
.bdac	bd 2e 07	lda $072e,x			lda 	SNDQueue+3,x
.bdaf	99 33 08	sta $0833,y			sta 	SNDVolume,y
.bdb2	bd 2f 07	lda $072f,x			lda 	SNDQueue+4,x
.bdb5	99 37 08	sta $0837,y			sta 	SNDTimeLeft,y
.bdb8	bd 30 07	lda $0730,x			lda 	SNDQueue+5,x
.bdbb	99 3b 08	sta $083b,y			sta 	SNDAdjustLow,y
.bdbe	bd 31 07	lda $0731,x			lda 	SNDQueue+6,x
.bdc1	99 3f 08	sta $083f,y			sta 	SNDAdjustHigh,y
.bdc4	5a		phy				phy 								; save channel #
.bdc5	20 2f be	jsr $be2f			jsr 	SNDDeleteXFromQueue 		; delete record at X from queue
.bdc8	ce 2a 07	dec $072a			dec 	SNDLength 					; reduce the queue length.
.bdcb	68		pla				pla
.bdcc	20 d0 bd	jsr $bdd0			jsr 	SNDUpdateNote 				; update channel A
.bdcf					_SNDCCExit:
.bdcf	60		rts				rts
.bdd0					SNDUpdateNote:
.bdd0	aa		tax				tax 								; so we can access records
.bdd1	0a		asl a				asl 	a 							; convert it to a channel bit pair in 5,6
.bdd2	0a		asl a				asl 	a
.bdd3	0a		asl a				asl 	a
.bdd4	0a		asl a				asl 	a
.bdd5	0a		asl a				asl 	a
.bdd6	8d 29 07	sta $0729			sta 	SNDChannelBits
.bdd9	bd 37 08	lda $0837,x			lda 	SNDTimeLeft,x 				; are we silent
.bddc	f0 2e		beq $be0c			beq 	_SNDUNIsSilent
.bdde	ad 29 07	lda $0729			lda 	SNDChannelBits 				; push channel bits on stack
.bde1	48		pha				pha
.bde2	bd 2b 08	lda $082b,x			lda 	SNDPitchLow,x 				; get 4 lowest bits of pitch.
.bde5	29 0f		and #$0f			and 	#$0F
.bde7	0d 29 07	ora $0729			ora 	SNDChannelBits 				; set channel bits
.bdea	09 80		ora #$80			ora 	#$80 						; write to pitch register
.bdec	20 79 be	jsr $be79			jsr 	SNDWritePorts
.bdef	bd 2f 08	lda $082f,x			lda 	SNDPitchHigh,x 				; pitch high => channel temp.
.bdf2	8d 29 07	sta $0729			sta 	SNDChannelBits
.bdf5	bd 2b 08	lda $082b,x			lda 	SNDPitchLow,x
.bdf8	4e 29 07	lsr $0729			lsr 	SNDChannelBits 				; shift 2 LSBs into MSB of A
.bdfb	6a		ror a				ror 	a
.bdfc	4e 29 07	lsr $0729			lsr 	SNDChannelBits
.bdff	6a		ror a				ror 	a
.be00	4a		lsr a				lsr 	a 							; put in bits 0-5
.be01	4a		lsr a				lsr 	a
.be02	20 79 be	jsr $be79			jsr 	SNDWritePorts 				; write as rest of pitch register
.be05	68		pla				pla
.be06	09 90		ora #$90			ora 	#$90 						; set to write minimum attentuation.
.be08	20 79 be	jsr $be79			jsr 	SNDWritePorts
.be0b	60		rts				rts
.be0c					_SNDUNIsSilent:
.be0c	ad 29 07	lda $0729			lda 	SNDChannelBits 				; channel bits
.be0f	09 9f		ora #$9f			ora 	#$9F 						; maximum attenuation
.be11	20 79 be	jsr $be79			jsr 	SNDWritePorts 				; write to the ports
.be14	60		rts				rts
.be15					SNDFindNextNoteForA:
.be15	ac 2a 07	ldy $072a			ldy 	SNDLength 					; queue size into Y
.be18	f0 13		beq $be2d			beq 	_SNDFNNFail 				; queue empty.
.be1a	a2 00		ldx #$00			ldx 	#0
.be1c					_SNDFNNSearch:
.be1c	dd 2b 07	cmp $072b,x			cmp 	SNDQueue,x 					; does it match the channel
.be1f	38		sec				sec
.be20	f0 0c		beq $be2e			beq 	_SNDFNNExit 				; if so exit with CS.
.be22	e8		inx				inx 								; next queue slot.
.be23	e8		inx				inx
.be24	e8		inx				inx
.be25	e8		inx				inx
.be26	e8		inx				inx
.be27	e8		inx				inx
.be28	e8		inx				inx
.be29	e8		inx				inx
.be2a	88		dey				dey 								; done the whole queue
.be2b	d0 ef		bne $be1c			bne 	_SNDFNNSearch 				; no, go back.
.be2d					_SNDFNNFail:
.be2d	18		clc				clc
.be2e					_SNDFNNexit:
.be2e	60		rts				rts
.be2f					SNDDeleteXFromQueue:
.be2f	e0 f8		cpx #$f8			cpx 	#SNDQueueSize*8-8 			; reached the end.
.be31	f0 09		beq $be3c			beq 	_SNDDXExit
.be33	bd 33 07	lda $0733,x			lda 	SNDQueue+8,x
.be36	9d 2b 07	sta $072b,x			sta 	SNDQueue,x
.be39	e8		inx				inx
.be3a	80 f3		bra $be2f			bra 	SNDDeleteXFromQueue
.be3c					_SNDDXExit:
.be3c	60		rts				rts
.0729					SNDChannelBits:
>0729							.fill 	1
.be3d					SNDQueueRequest:
.be3d	86 36		stx $36				stx 	zTemp0						; save queue address
.be3f	84 37		sty $37				sty 	zTemp0+1
.be41	ae 2a 07	ldx $072a			ldx 	SNDLength 					; queue is full, can't take any more.
.be44	e0 20		cpx #$20			cpx 	#SNDQueueSize
.be46	f0 21		beq $be69			beq 	_SNDQRExit
.be48	29 03		and #$03			and 	#3	 						; channel # and push on stack
.be4a	48		pha				pha
.be4b	8a		txa				txa  								; get offset in queue buffer/
.be4c	0a		asl a				asl 	a
.be4d	0a		asl a				asl 	a
.be4e	0a		asl a				asl 	a
.be4f	aa		tax				tax
.be50	68		pla				pla 								; get back and push again
.be51	48		pha				pha
.be52	9d 2b 07	sta $072b,x			sta 	SNDQueue+0,x 				; save the channel #
.be55	a0 00		ldy #$00			ldy 	#0 							; copy the rest in.
.be57					_SNDQCopy:
.be57	b1 36		lda ($36),y			lda 	(zTemp0),y
.be59	e8		inx				inx
.be5a	c8		iny				iny
.be5b	9d 2b 07	sta $072b,x			sta 	SNDQueue,x
.be5e	c0 06		cpy #$06			cpy 	#6
.be60	d0 f5		bne $be57			bne 	_SNDQCopy
.be62	ee 2a 07	inc $072a			inc 	SNDLength 					; bump queue length.
.be65	68		pla				pla 								; get channel # back
.be66	20 91 bd	jsr $bd91			jsr 	SNDCheckChannel 			; check if channel needs refreshing.
.be69					_SNDQRExit:
.be69	60		rts				rts
.be6a					SNDSilenceChannel:
.be6a	aa		tax				tax 								; zero time left.
.be6b	9e 37 08	stz $0837,x			stz 	SNDTimeLeft,x
.be6e	0a		asl a				asl 	a 							; shift into position
.be6f	0a		asl a				asl 	a
.be70	0a		asl a				asl 	a
.be71	0a		asl a				asl 	a
.be72	0a		asl a				asl 	a
.be73	09 9f		ora #$9f			ora 	#$9F 						; write register attenuation $F
.be75	20 79 be	jsr $be79			jsr 	SNDWritePorts
.be78	60		rts				rts
.be79					SNDWritePorts:
.be79	da		phx				phx 								; save X
.be7a	a6 01		ldx $01				ldx 	1 							; save I/O status
.be7c	64 01		stz $01				stz 	1 							; access I/O page 0
.be7e	8d 00 d6	sta $d600			sta 	$D600 						; write to both
.be81	8d 10 d6	sta $d610			sta 	$D610
.be84	86 01		stx $01				stx 	1 							; restore I/O
.be86	fa		plx				plx 								; restore X
.be87	60		rts				rts
.be88					Export_SNDCommand:
.be88	da		phx				phx 								; save XY
.be89	5a		phy				phy
.be8a	c9 0f		cmp #$0f			cmp 	#$0F 						; $0F is initialise
.be8c	f0 1d		beq $beab			beq 	_SNDInitialise
.be8e	90 28		bcc $beb8			bcc 	_SNDExit
.be90	c9 3f		cmp #$3f			cmp 	#$3F 						; $3F is silence all
.be92	f0 17		beq $beab			beq 	_SNDSilence
.be94	b0 22		bcs $beb8			bcs 	_SNDExit
.be96	c9 20		cmp #$20			cmp 	#$20 						; $2x is check playing => A
.be98	b0 09		bcs $bea3			bcs 	_SNDQueryPlay
.be9a	c9 14		cmp #$14			cmp 	#$14 						; $10-$13 is queue sound
.be9c	b0 1a		bcs $beb8			bcs 	_SNDExit
.be9e	20 3d be	jsr $be3d			jsr 	SNDQueueRequest
.bea1	80 15		bra $beb8			bra 	_SNDExit
.bea3					_SNDQueryPlay:
.bea3	29 03		and #$03			and 	#3 							; get channel #
.bea5	aa		tax				tax
.bea6	bd 37 08	lda $0837,x			lda 	SNDTimeLeft,x 				; read time left, if zero then silent
.bea9	80 0d		bra $beb8			bra 	_SNDExit
.beab					_SNDInitialise:
.beab					_SNDSilence:
.beab	9c 2a 07	stz $072a			stz 	SNDLength 					; empty the queue.
.beae	a9 03		lda #$03			lda 	#$3 						; silence channel 0-3.
.beb0					_SNDSilenceLoop:
.beb0	48		pha				pha
.beb1	20 6a be	jsr $be6a			jsr 	SNDSilenceChannel
.beb4	68		pla				pla
.beb5	3a		dec a				dec 	a
.beb6	10 f8		bpl $beb0			bpl 	_SNDSilenceLoop
.beb8					_SNDExit:
.beb8	7a		ply				ply
.beb9	fa		plx				plx
.beba	60		rts				rts
=32					SNDQueueSize = 32 							; number of queue entries
.072a					SNDLength:
>072a							.fill 	1
.072b					SNDQueue:
>072b							.fill 	SNDQueueSize * 8
.082b					SNDPitchLow:
>082b							.fill 	4
.082f					SNDPitchHigh:
>082f							.fill 	4
.0833					SNDVolume:
>0833							.fill 	4
.0837					SNDTimeLeft:
>0837							.fill 	4
.083b					SNDAdjustLow:
>083b							.fill 	4
.083f					SNDAdjustHigh:
>083f							.fill 	4
.bebb					Export_SNDUpdate:
.bebb					PagedSNDUpdate:
.bebb	ad 37 08	lda $0837			lda 	SNDTimeLeft+0 				; look at time remaining
.bebe	f0 05		beq $bec5			beq 	_SNDUNot0 					; not playing
.bec0	a2 00		ldx #$00			ldx 	#0 							; so we know which channel to update
.bec2	20 e4 be	jsr $bee4			jsr 	SNDUpdateChannel 			; update it.
.bec5					_SNDUNot0:
.bec5	ad 38 08	lda $0838			lda 	SNDTimeLeft+1
.bec8	f0 05		beq $becf			beq 	_SNDUNot1
.beca	a2 01		ldx #$01			ldx 	#1
.becc	20 e4 be	jsr $bee4			jsr 	SNDUpdateChannel
.becf					_SNDUNot1:
.becf	ad 39 08	lda $0839			lda 	SNDTimeLeft+2
.bed2	f0 05		beq $bed9			beq 	_SNDUNot2
.bed4	a2 02		ldx #$02			ldx 	#2
.bed6	20 e4 be	jsr $bee4			jsr 	SNDUpdateChannel
.bed9					_SNDUNot2:
.bed9	ad 3a 08	lda $083a			lda 	SNDTimeLeft+3
.bedc	f0 05		beq $bee3			beq 	_SNDUNot3
.bede	a2 03		ldx #$03			ldx 	#3
.bee0	20 e4 be	jsr $bee4			jsr 	SNDUpdateChannel
.bee3					_SNDUNot3:
.bee3	60		rts				rts
.bee4					SNDUpdateChannel:
.bee4	c9 ff		cmp #$ff			cmp 	#$FF 						; sound $FF play forever until turned off manually
.bee6	f0 2c		beq $bf14			beq 	_SNDUCExit
.bee8	3a		dec a				dec 	a 							; decrement and update timer
.bee9	9d 37 08	sta $0837,x			sta 	SNDTimeLeft,x
.beec	f0 1d		beq $bf0b			beq 	_SNDUCUpdate 				; if zero, silence channel
.beee	bd 3b 08	lda $083b,x			lda 	SNDAdjustLow,x 				; adjust ?
.bef1	1d 3f 08	ora $083f,x			ora 	SNDAdjustHigh,x
.bef4	f0 1e		beq $bf14			beq 	_SNDUCExit 					; if zero carry on at current tone.
.bef6	18		clc				clc 								; add adjust, forcing into a 10 bit range
.bef7	bd 2b 08	lda $082b,x			lda 	SNDPitchLow,x
.befa	7d 3b 08	adc $083b,x			adc 	SNDAdjustLow,x
.befd	9d 2b 08	sta $082b,x			sta 	SNDPitchLow,x
.bf00	bd 2f 08	lda $082f,x			lda 	SNDPitchHigh,x
.bf03	7d 3f 08	adc $083f,x			adc 	SNDAdjustHigh,x
.bf06	29 03		and #$03			and 	#3
.bf08	9d 2f 08	sta $082f,x			sta 	SNDPitchHigh,x
.bf0b					_SNDUCUpdate:
.bf0b	8a		txa				txa 								; which channel.
.bf0c	48		pha				pha
.bf0d	20 d0 bd	jsr $bdd0			jsr 	SNDUpdateNote 				; update the current note
.bf10	68		pla				pla
.bf11	20 91 bd	jsr $bd91			jsr 	SNDCheckChannel 			; more to do ?
.bf14					_SNDUCExit:
.bf14	60		rts				rts

;******  Return to file: _basic.asm


;******  End of listing
