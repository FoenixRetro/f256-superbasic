
; 64tass Turbo Assembler Macro V1.57.2900 listing file
; 64tass -D AUTORUN=1 "-D MONITOR_ADDRESS=\$E000" "-D LOCKOUT_ADDRESS=\$F000" "-D BASIC_ADDRESS=\$38000" "-D SOURCE_ADDRESS=\$3000" "-D SPRITE_ADDRESS=\$30000" -q -b -Wall -c -D "HARDWARE=0 $'\x9'$'\x9'$'\x9'$'\x9'$'\x9'$'\x9'" -L output/basic.lst -l output/basic.lbl -Wall -o basic.rom _basic.asm
; Mon Nov 21 16:00:05 2022

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=1					AUTORUN=1
=$e000					 MONITOR_ADDRESS=$E000
=$f000					 LOCKOUT_ADDRESS=$F000
=$38000					 BASIC_ADDRESS=$38000
=$3000					 SOURCE_ADDRESS=$3000
=$30000					 SPRITE_ADDRESS=$30000
=0					HARDWARE=0

;******  Processing input file: _basic.asm


;******  Processing file: ./common/aa.system/01common.inc

=$30					ZeroPageMandatory = $30
=$400					ZeroPagePreference = $400
=$480					MemoryStorage = $480
=$2000					BasicStart = $2000
=$8000					BasicEnd = $8000
=$8000					CodeStart = $8000
=$1000					VariableSpace = $1000
=$2000					EndVariableSpace = $2000
=8					MathStackSize = 8
=512					BasicStackSize = 512
=3584					BasicStackBase = $1000-BasicStackSize
=80					MaxLineSize = 80

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/02macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/04data.inc

.0030					codePtr:
>0030							.fill 	4
.0034					basicStack:
>0034							.fill 	2
.0036					zTemp0:
>0036							.fill 	2
.0038					zTemp1:
>0038							.fill 	2
.003a					zTemp2:
>003a							.fill 	2
.003c					zsTemp:
>003c							.fill 	2
.003e					zaTemp:
>003e							.fill 	2
=$30					safePtr = codePtr 							; minimise direct tinkering
=$80					NSBIsNegative = $80 						; bit 7 : sign of mantissa (where numeric)
=$20					NSBIsReference = $20 						; bit 5 : is a reference
=$10					NSBIsString = $10 							; bit 4 : set if string (procedures don't go on the stack)
=$18					NSBTypeMask = $18 							; bits 4,3 : 00 int 01 float 10 string 11 procedure
=$03					NSBRefMask = $03 							; bits 0,1 : Bytes of reference, -1 (e.g. 00 = 1 byte, 11 = 4 bytes)
=$04					NSBIsArray = $04
=$00					NSTInteger = $00 							; base types for bits 3..4
=$08					NSTFloat = $08
=$10					NSTString = $10
=$18					NSTProcedure = $18
.0400					NSStatus:
>0400							.fill 	MathStackSize
.0408					NSMantissa0:
>0408							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0410					NSMantissa1:
>0410							.fill 	MathStackSize
.0418					NSMantissa2:
>0418							.fill 	MathStackSize
.0420					NSMantissa3:
>0420							.fill 	MathStackSize
.0428					NSExponent:
>0428							.fill 	MathStackSize
.0480					identStart:
>0480							.fill 	1
.0481					identTypeStart:
>0481							.fill 	1
.0482					identTypeEnd:
>0482							.fill 	1
.0483					identHash:
>0483							.fill 	1
.0484					identTypeByte:
>0484							.fill 	1	 						; (see tokenising.pdf)
.0485					encodeState:
>0485							.fill 	1
.0486					digitTemp:
>0486							.fill 	1
.0487					decimalCount:
>0487							.fill 	1
.0488					randomSeed:
>0488							.fill 	4
.048c					lowMemPtr:
>048c							.fill 	2
.048e					stringMemory:
>048e							.fill 	2
.0490					stringInitialised:
>0490							.fill 	1
.0491					stringTempPointer:
>0491							.fill 	2
.0493					breakCheck:
>0493							.fill 	1
.0494					decimalPlaces:
>0494							.fill 	1
.0495					dbOffset:
>0495							.fill 	1
.0496					lastParameter:
>0496							.fill 	1
.0497					dataPointer:
>0497							.fill 	5
.049c					inDataStatement:
>049c							.fill 	1
.049d					tbOffset:
>049d							.fill 	1
.049e					AssemblerAddress:
>049e							.fill 	2
.04a0					AssemblerControl:
>04a0							.fill 	1
.04a1					ParamStart:
>04a1							.fill 	2
.04a3					IsGroup1:
>04a3							.fill 	1
.04a4					BaseOpcode:
>04a4							.fill 	1
.04a5					ModeMask:
>04a5							.fill 	1
.04a6					listIndent:
>04a6							.fill 	1
.04a7					lcLastCharacter:
>04a7							.fill 	1
.04a8					tokenOffset:
>04a8							.fill 	1
.04a9					tokenLineNumber:
>04a9							.fill 	2
.04ab					tokenBuffer:
>04ab							.fill 	253
.05a8					lineBuffer:
>05a8							.fill 	MaxLineSize+1
.05f9					numberBuffer:
>05f9							.fill 	34
.061b					decimalBuffer:
>061b							.fill 	16

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/constants.inc

=$80					AM_ISZP = $80
=$40					AM_ISG1 = $40
=$20					AM_ISG2 = $20
=224					AM_IMMEDIATE = AM_ISZP+AM_ISG1+AM_ISG2+$00
=228					AM_ZEROPAGE = AM_ISZP+AM_ISG1+AM_ISG2+$04
=40					AM_ACC = AM_ISG2+$08
=108					AM_ABS = AM_ISG1+AM_ISG2+$0C
=208					AM_INDY = AM_ISZP+AM_ISG1+$10
=244					AM_ZEROX = AM_ISZP+AM_ISG1+AM_ISG2+$14
=120					AM_ABSY = AM_ISG1+AM_ISG2+$18
=124					AM_ABSX = AM_ISG1+AM_ISG2+$1C
=209					AM_IND = AM_ISZP+AM_ISG1+$11
=$80					AM_ZEROY = AM_ISZP
=$01					AM_INDABS = $01
=$02					AM_INDABSX = $02
=192					AM_INDX = AM_ISZP+AM_ISG1+$00

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/handlers.inc


;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.inc

=1					ERRID_BREAK = 1
=2					ERRID_SYNTAX = 2
=3					ERRID_DIVZERO = 3
=4					ERRID_RANGE = 4
=5					ERRID_TYPE = 5
=6					ERRID_MEMORY = 6
=7					ERRID_ARGUMENT = 7
=8					ERRID_STOP = 8
=9					ERRID_STRING = 9
=10					ERRID_ASSERT = 10
=11					ERRID_DATA = 11
=12					ERRID_NOTDONE = 12
=13					ERRID_LINE = 13
=14					ERRID_GOSUB = 14
=15					ERRID_REPEAT = 15
=16					ERRID_WHILE = 16
=17					ERRID_FOR = 17
=18					ERRID_STACK = 18
=19					ERRID_STRUCT = 19
=20					ERRID_PROC = 20
=21					ERRID_REDEFINE = 21
=22					ERRID_ARRAYSIZE = 22
=23					ERRID_ARRAYIDX = 23

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst.inc

=$00					KWD_LESSLESS                         = $00; $00 <<
=$01					KWD_LESSEQUAL                        = $01; $01 <=
=$02					KWD_LESSGREATER                      = $02; $02 <>
=$03					KWD_PLINGPLING3                      = $03; $03 !!3
=$04					KWD_GREATERLESS                      = $04; $04 ><
=$05					KWD_GREATEREQUAL                     = $05; $05 >=
=$06					KWD_GREATERGREATER                   = $06; $06 >>
=$07					KWD_PLINGPLING7                      = $07; $07 !!7
=$08					KWD_PLINGPLING8                      = $08; $08 !!8
=$09					KWD_PLINGPLING9                      = $09; $09 !!9
=$0a					KWD_PLINGPLING10                     = $0a; $0a !!10
=$0b					KWD_PLINGPLING11                     = $0b; $0b !!11
=$0c					KWD_PLINGPLING12                     = $0c; $0c !!12
=$0d					KWD_PLINGPLING13                     = $0d; $0d !!13
=$0e					KWD_PLINGPLING14                     = $0e; $0e !!14
=$0f					KWD_PLINGPLING15                     = $0f; $0f !!15
=$10					KWD_AT                               = $10; $10 @
=$11					KWD_PLINGPLING17                     = $11; $11 !!17
=$12					KWD_PLINGPLING18                     = $12; $12 !!18
=$13					KWD_LSQPAREN                         = $13; $13 [
=$14					KWD_BACKSLASH                        = $14; $14 \
=$15					KWD_RSQPAREN                         = $15; $15 ]
=$16					KWD_HAT                              = $16; $16 ^
=$17					KWD_UNDERSCORE                       = $17; $17 _
=$18					KWD_BQUOTE                           = $18; $18 `
=$19					KWD_PLINGPLING25                     = $19; $19 !!25
=$1a					KWD_PLINGPLING26                     = $1a; $1a !!26
=$1b					KWD_LCURLY                           = $1b; $1b {
=$1c					KWD_BAR                              = $1c; $1c |
=$1d					KWD_RCURLY                           = $1d; $1d }
=$1e					KWD_TILDE                            = $1e; $1e ~
=$21					KWD_PLING                            = $21; $21 !
=$22					KWD_DQUOTE                           = $22; $22 "
=$23					KWD_HASH                             = $23; $23 #
=$24					KWD_DOLLAR                           = $24; $24 $
=$25					KWD_PERCENT                          = $25; $25 %
=$26					KWD_AMPERSAND                        = $26; $26 &
=$27					KWD_QUOTE                            = $27; $27 '
=$28					KWD_LPAREN                           = $28; $28 (
=$29					KWD_RPAREN                           = $29; $29 )
=$2a					KWD_STAR                             = $2a; $2a *
=$2b					KWD_PLUS                             = $2b; $2b +
=$2c					KWD_COMMA                            = $2c; $2c ,
=$2d					KWD_MINUS                            = $2d; $2d -
=$2e					KWD_PERIOD                           = $2e; $2e .
=$2f					KWD_SLASH                            = $2f; $2f /
=$30					KWD_0                                = $30; $30 0
=$31					KWD_1                                = $31; $31 1
=$32					KWD_2                                = $32; $32 2
=$33					KWD_3                                = $33; $33 3
=$34					KWD_4                                = $34; $34 4
=$35					KWD_5                                = $35; $35 5
=$36					KWD_6                                = $36; $36 6
=$37					KWD_7                                = $37; $37 7
=$38					KWD_8                                = $38; $38 8
=$39					KWD_9                                = $39; $39 9
=$3a					KWD_COLON                            = $3a; $3a :
=$3b					KWD_SEMICOLON                        = $3b; $3b ;
=$3c					KWD_LESS                             = $3c; $3c <
=$3d					KWD_EQUAL                            = $3d; $3d =
=$3e					KWD_GREATER                          = $3e; $3e >
=$3f					KWD_QMARK                            = $3f; $3f ?
=$83					KWD_ABSLPAREN                        = $83; $83 ABS(
=$84					KWD_ALLOCLPAREN                      = $84; $84 ALLOC(
=$85					KWD_ASCLPAREN                        = $85; $85 ASC(
=$86					KWD_CHRDOLLARLPAREN                  = $86; $86 CHR$(
=$87					KWD_EVENTLPAREN                      = $87; $87 EVENT(
=$88					KWD_FALSE                            = $88; $88 FALSE
=$89					KWD_FRACLPAREN                       = $89; $89 FRAC(
=$8a					KWD_HITLPAREN                        = $8a; $8a HIT(
=$8b					KWD_INTLPAREN                        = $8b; $8b INT(
=$8c					KWD_ISVALLPAREN                      = $8c; $8c ISVAL(
=$8d					KWD_JOYBLPAREN                       = $8d; $8d JOYB(
=$8e					KWD_JOYXLPAREN                       = $8e; $8e JOYX(
=$8f					KWD_JOYYLPAREN                       = $8f; $8f JOYY(
=$90					KWD_LEFTDOLLARLPAREN                 = $90; $90 LEFT$(
=$91					KWD_LENLPAREN                        = $91; $91 LEN(
=$92					KWD_MAXLPAREN                        = $92; $92 MAX(
=$93					KWD_MIDDOLLARLPAREN                  = $93; $93 MID$(
=$94					KWD_MINLPAREN                        = $94; $94 MIN(
=$95					KWD_NOTLPAREN                        = $95; $95 NOT(
=$96					KWD_PLAYINGLPAREN                    = $96; $96 PLAYING(
=$97					KWD_RANDOMLPAREN                     = $97; $97 RANDOM(
=$98					KWD_RIGHTDOLLARLPAREN                = $98; $98 RIGHT$(
=$99					KWD_RNDLPAREN                        = $99; $99 RND(
=$9a					KWD_SGNLPAREN                        = $9a; $9a SGN(
=$9b					KWD_SPCLPAREN                        = $9b; $9b SPC(
=$9c					KWD_STRDOLLARLPAREN                  = $9c; $9c STR$(
=$9d					KWD_TIMERLPAREN                      = $9d; $9d TIMER(
=$9e					KWD_TRUE                             = $9e; $9e TRUE
=$9f					KWD_VALLPAREN                        = $9f; $9f VAL(
=$a0					KWD_FOR                              = $a0; $a0 FOR
=$a1					KWD_IF                               = $a1; $a1 IF
=$a2					KWD_PROC                             = $a2; $a2 PROC
=$a3					KWD_REPEAT                           = $a3; $a3 REPEAT
=$a4					KWD_WHILE                            = $a4; $a4 WHILE
=$a5					KWD_ENDIF                            = $a5; $a5 ENDIF
=$a6					KWD_ENDPROC                          = $a6; $a6 ENDPROC
=$a7					KWD_NEXT                             = $a7; $a7 NEXT
=$a8					KWD_THEN                             = $a8; $a8 THEN
=$a9					KWD_UNTIL                            = $a9; $a9 UNTIL
=$aa					KWD_WEND                             = $aa; $aa WEND
=$ab					KWD_BY                               = $ab; $ab BY
=$ac					KWD_CALL                             = $ac; $ac CALL
=$ad					KWD_CIRCLE                           = $ad; $ad CIRCLE
=$ae					KWD_CLEAR                            = $ae; $ae CLEAR
=$af					KWD_CLS                              = $af; $af CLS
=$b0					KWD_COLOR                            = $b0; $b0 COLOR
=$b1					KWD_COLOUR                           = $b1; $b1 COLOUR
=$b2					KWD_DATA                             = $b2; $b2 DATA
=$b3					KWD_DIM                              = $b3; $b3 DIM
=$b4					KWD_DOWNTO                           = $b4; $b4 DOWNTO
=$b5					KWD_ELSE                             = $b5; $b5 ELSE
=$b6					KWD_FROM                             = $b6; $b6 FROM
=$b7					KWD_GFX                              = $b7; $b7 GFX
=$b8					KWD_GOSUB                            = $b8; $b8 GOSUB
=$b9					KWD_GOTO                             = $b9; $b9 GOTO
=$ba					KWD_HERE                             = $ba; $ba HERE
=$bb					KWD_IMAGE                            = $bb; $bb IMAGE
=$bc					KWD_LET                              = $bc; $bc LET
=$bd					KWD_LINE                             = $bd; $bd LINE
=$be					KWD_LOCAL                            = $be; $be LOCAL
=$bf					KWD_OFF                              = $bf; $bf OFF
=$c0					KWD_ON                               = $c0; $c0 ON
=$c1					KWD_OUTLINE                          = $c1; $c1 OUTLINE
=$c2					KWD_PALETTE                          = $c2; $c2 PALETTE
=$c3					KWD_PLOT                             = $c3; $c3 PLOT
=$c4					KWD_PRINT                            = $c4; $c4 PRINT
=$c5					KWD_READ                             = $c5; $c5 READ
=$c6					KWD_RECT                             = $c6; $c6 RECT
=$c7					KWD_REM                              = $c7; $c7 REM
=$c8					KWD_RETURN                           = $c8; $c8 RETURN
=$c9					KWD_SOLID                            = $c9; $c9 SOLID
=$ca					KWD_SOUND                            = $ca; $ca SOUND
=$cb					KWD_SPRITE                           = $cb; $cb SPRITE
=$cc					KWD_TEXT                             = $cc; $cc TEXT
=$cd					KWD_TO                               = $cd; $cd TO

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst0.inc

=$80					KWC_EOL = $80
=$ff					KWC_STRING = $FF
=$fe					KWC_HEXCONST = $FE
=$a0					KWC_FIRST_STRUCTURE = $a0
=$a5					KWC_FIRST_STRUCTURE_DEC = $a5
=$aa					KWC_LAST_STRUCTURE = $aa
=$83					KWC_FIRST_UNARY = $83
=$9f					KWC_LAST_UNARY = $9f

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/access.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/stack.inc

=$e0					STK_GOSUB = $E0
=$d0					STK_FOR = $D0
=$c0					STK_REPEAT = $C0
=$b0					STK_PROC = $B0
=$a0					STK_WHILE = $A0
=$01					STK_LOCALN = $01
=$02					STK_LOCALS = $02

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/00start.asm

.8000	a2 ff		ldx #$ff	Start:	ldx 	#$FF 						; stack reset
.8002	9a		txs				txs
.8003	20 39 aa	jsr $aa39			jsr 	EXTInitialise 				; hardware initialise
.8006	a2 80		ldx #$80			ldx 	#(Prompt >> 8) 				; prompt
.8008	a9 22		lda #$22			lda 	#(Prompt & $FF)
.800a	20 c2 8d	jsr $8dc2			jsr 	PrintStringXA
.800d	a9 00		lda #$00			lda 	#0 							; graphics system initialise.
.800f	aa		tax				tax
.8010	a8		tay				tay
.8011	20 c5 aa	jsr $aac5			jsr 	GXGraphicDraw
.8014	a9 0f		lda #$0f			lda 	#$0F 						; initialise sound system
.8016	20 53 b9	jsr $b953			jsr 	SNDCommand
.8019	20 53 88	jsr $8853			jsr 	NewProgram 					; erase current program
.801c	20 e3 82	jsr $82e3			jsr 	BackloadProgram
.801f	4c ff 89	jmp $89ff			jmp 	CommandRun
>8022	0c 2a 2a 2a 20 46 32 35		Prompt:	.text 	12,"*** F256 Junior SuperBASIC ***",13,13
>802a	36 20 4a 75 6e 69 6f 72 20 53 75 70 65 72 42 41
>803a	53 49 43 20 2a 2a 2a 0d 0d

;******  Processing file: ./common/aa.system/../generated/timestamp.asm

>8043	42 75 69 6c 74 20 4d 6f			.text "Built Monday 21-Nov-2022. Build 3478."
>804b	6e 64 61 79 20 32 31 2d 4e 6f 76 2d 32 30 32 32
>805b	2e 20 42 75 69 6c 64 20 33 34 37 38 2e

;******  Return to file: ./common/aa.system/00start.asm

>8068	0d 0d 00					.byte 	13,13,0

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/assembler.asm

.806b					AssembleGroup1:
.806b	a9 ff		lda #$ff			lda 	#$FF
.806d	8d a5 04	sta $04a5			sta 	ModeMask 					; initialise the mode mask - all for all
.8070	80 02		bra $8074			bra 	AsmGroup12
.8072					AssembleGroup2:
.8072	a9 00		lda #$00			lda 	#$00
.8074					AsmGroup12:
.8074	8d a3 04	sta $04a3			sta 	IsGroup1 					; save the 'group 1' flag
.8077	68		pla				pla 								; pop the return address to access the information following.
.8078	fa		plx				plx
.8079	20 02 81	jsr $8102			jsr 	AccessParameters 			; get opcode and save as base
.807c	8d a4 04	sta $04a4			sta 	BaseOpcode
.807f	ad a3 04	lda $04a3			lda 	IsGroup1 					; skip if group 1 as we don't have a complex mask.
.8082	d0 08		bne $808c			bne 	_AG12HaveMask
.8084	a9 02		lda #$02			lda 	#2 							; if group 2 the second parameter is the mask
.8086	20 0a 81	jsr $810a			jsr 	GetParameter		 		; e.g. which modes are supported for this operand
.8089	8d a5 04	sta $04a5			sta 	ModeMask
.808c					_AG12HaveMask:
.808c	20 45 82	jsr $8245			jsr 	TypeAndCalculateOperand 	; get zero page type
.808f	da		phx				phx 								; save found address mode
.8090	20 6e 81	jsr $816e			jsr 	AssembleModeX
.8093	fa		plx				plx  								; restore address mode
.8094	b0 0b		bcs $80a1			bcs 	_AG12Exit
.8096	20 a2 80	jsr $80a2			jsr 	PromoteToAbsolute  			; promote ZP to ABS and try that
.8099	20 6e 81	jsr $816e			jsr 	AssembleModeX
.809c	b0 03		bcs $80a1			bcs 	_AG12Exit
.809e	4c b6 9f	jmp $9fb6			jmp 	SyntaxError 				; can't do either, so must be wrong mode/operand.
.80a1					_AG12Exit:
.80a1	60		rts				rts
.80a2					PromoteToAbsolute:
.80a2	a9 6c		lda #$6c			lda 	#AM_ABS 					; lda xx
.80a4	e0 e4		cpx #$e4			cpx 	#AM_ZEROPAGE
.80a6	f0 19		beq $80c1			beq 	_PTADo
.80a8	a9 7c		lda #$7c			lda 	#AM_ABSX 					; lda xx,X
.80aa	e0 f4		cpx #$f4			cpx 	#AM_ZEROX
.80ac	f0 13		beq $80c1			beq 	_PTADo
.80ae	a9 78		lda #$78			lda 	#AM_ABSY 					; lda xx,Y
.80b0	e0 80		cpx #$80			cpx 	#AM_ZEROY
.80b2	f0 0d		beq $80c1			beq 	_PTADo
.80b4	a9 01		lda #$01			lda 	#AM_INDABS 					; lda (xx) (jump)
.80b6	e0 d1		cpx #$d1			cpx 	#AM_IND
.80b8	f0 07		beq $80c1			beq 	_PTADo
.80ba	a9 02		lda #$02			lda 	#AM_INDABSX 				; lda (xx,x) (jump)
.80bc	e0 c0		cpx #$c0			cpx 	#AM_INDX
.80be	f0 01		beq $80c1			beq 	_PTADo
.80c0	60		rts				rts
.80c1					_PTADo:
.80c1	aa		tax				tax
.80c2	60		rts				rts
.80c3					AssembleGroup3:
.80c3	68		pla				pla 								; get parameters, which is just the opcode.
.80c4	fa		plx				plx
.80c5	20 02 81	jsr $8102			jsr 	AccessParameters 			; get and output opcode
.80c8	20 1a 81	jsr $811a			jsr 	AssemblerWriteByte
.80cb	20 a9 82	jsr $82a9			jsr 	CalculateOperand 			; get a 16 bit operand
.80ce	ad 08 04	lda $0408			lda 	NSMantissa0 				; calculate the offset
.80d1	38		sec				sec
.80d2	ed 9e 04	sbc $049e			sbc 	AssemblerAddress
.80d5	48		pha				pha 								; LSB in A
.80d6	ad 10 04	lda $0410			lda 	NSMantissa1
.80d9	ed 9f 04	sbc $049f			sbc 	AssemblerAddress+1
.80dc	aa		tax				tax 								; MSB in X
.80dd	68		pla				pla
.80de	18		clc				clc 								; $80 to easy check $80-$7F, plus 1 for offset error
.80df	69 7f		adc #$7f			adc 	#$7F
.80e1	90 01		bcc $80e4			bcc 	_AG3NoCarry
.80e3	e8		inx				inx
.80e4					_AG3NoCarry:
.80e4	38		sec				sec 								; fix back and write out anyways.
.80e5	e9 80		sbc #$80			sbc 	#$80
.80e7	20 1a 81	jsr $811a			jsr 	AssemblerWriteByte
.80ea	e0 00		cpx #$00			cpx 	#0 							; was it in range
.80ec	f0 0a		beq $80f8			beq 	_AG3Exit
.80ee	ad a0 04	lda $04a0			lda 	AssemblerControl 			; are we allowing bad values ?
.80f1	29 01		and #$01			and 	#1
.80f3	f0 03		beq $80f8			beq 	_AG3Exit
.80f5	4c bb 9f	jmp $9fbb			jmp 	RangeError 					; no, branch is out of range
.80f8					_AG3Exit:
.80f8	60		rts				rts
.80f9					AssembleGroup4:
.80f9	68		pla				pla 								; pop address
.80fa	fa		plx				plx
.80fb	20 02 81	jsr $8102			jsr 	AccessParameters 			; access and get first
.80fe	20 1a 81	jsr $811a			jsr 	AssemblerWriteByte 			; output it.
.8101	60		rts				rts
.8102					AccessParameters:
.8102	8d a1 04	sta $04a1			sta 	ParamStart
.8105	8e a2 04	stx $04a2			stx 	ParamStart+1
.8108	a9 01		lda #$01			lda 	#1
.810a					GetParameter:
.810a	5a		phy				phy
.810b	a8		tay				tay
.810c	ad a1 04	lda $04a1			lda 	ParamStart
.810f	85 36		sta $36				sta 	zTemp0
.8111	ad a2 04	lda $04a2			lda 	ParamStart+1
.8114	85 37		sta $37				sta 	zTemp0+1
.8116	b1 36		lda ($36),y			lda 	(zTemp0),y
.8118	7a		ply				ply
.8119	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/aswrite.asm

.811a					AssemblerWriteByte:
.811a	48		pha			pha
.811b	ad a0 04	lda $04a0		lda 	AssemblerControl 				; check printing bytes ?
.811e	29 02		and #$02		and 	#2
.8120	f0 1b		beq $813d		beq 	_AWBNoPrint
.8122	ad 9f 04	lda $049f		lda		AssemblerAddress+1 				; print address
.8125	20 58 81	jsr $8158		jsr 	PrintHex
.8128	ad 9e 04	lda $049e		lda		AssemblerAddress
.812b	20 58 81	jsr $8158		jsr 	PrintHex
.812e	a9 20		lda #$20		lda 	#' '
.8130	20 c5 a7	jsr $a7c5		jsr 	EXTPrintCharacter
.8133	68		pla			pla 									; print byte
.8134	48		pha			pha
.8135	20 58 81	jsr $8158		jsr 	PrintHex
.8138	a9 0d		lda #$0d		lda 	#13
.813a	20 c5 a7	jsr $a7c5		jsr 	EXTPrintCharacter
.813d					_AWBNoPrint:
.813d	ad 9e 04	lda $049e		lda		AssemblerAddress				; copy address to zTemp0
.8140	85 36		sta $36			sta 	zTemp0
.8142	ad 9f 04	lda $049f		lda		AssemblerAddress+1
.8145	f0 0e		beq $8155		beq 	_AWBRange
.8147	85 37		sta $37			sta 	zTemp0+1
.8149	68		pla			pla 									; write byte out
.814a	92 36		sta ($36)		sta 	(zTemp0)
.814c	ee 9e 04	inc $049e		inc 	AssemblerAddress 				; bump address
.814f	d0 03		bne $8154		bne 	_AWBNoCarry
.8151	ee 9f 04	inc $049f		inc 	AssemblerAddress+1
.8154					_AWBNoCarry:
.8154	60		rts			rts
.8155					_AWBRange:
.8155	4c bb 9f	jmp $9fbb		jmp 	RangeError
.8158					PrintHex:
.8158	48		pha				pha
.8159	4a		lsr a				lsr 	a
.815a	4a		lsr a				lsr 	a
.815b	4a		lsr a				lsr 	a
.815c	4a		lsr a				lsr 	a
.815d	20 61 81	jsr $8161			jsr 	_PrintNibble
.8160	68		pla				pla
.8161					_PrintNibble:
.8161	29 0f		and #$0f			and 	#15
.8163	c9 0a		cmp #$0a			cmp 	#10
.8165	90 02		bcc $8169			bcc 	_NoShift
.8167	69 06		adc #$06			adc 	#6
.8169					_NoShift:
.8169	69 30		adc #$30			adc 	#48
.816b	4c c5 a7	jmp $a7c5			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/instruction.asm

.816e					AssembleModeX:
.816e	5a		phy				phy
.816f	ad a3 04	lda $04a3			lda 	IsGroup1
.8172	f0 17		beq $818b			beq 	_AMXGroup2
.8174	8a		txa				txa 							; is it in group # 1
.8175	29 40		and #$40			and 	#AM_ISG1
.8177	f0 50		beq $81c9			beq 	_AMXFail 				; no, give up.
.8179	8a		txa				txa 							; get back.
.817a	29 1f		and #$1f			and 	#$1F 					; this is now the offset.
.817c	e0 e0		cpx #$e0			cpx 	#AM_IMMEDIATE 			; if not immediate, we can continue.
.817e	d0 22		bne $81a2			bne 	_AMXHaveInfo
.8180	ad a4 04	lda $04a4			lda 	BaseOpcode 				; cannot store immediate.
.8183	c9 81		cmp #$81			cmp 	#$81
.8185	f0 42		beq $81c9			beq 	_AMXFail
.8187	a9 08		lda #$08			lda 	#8 						; if immediate we use offset 8.
.8189	80 17		bra $81a2			bra 	_AMXHaveInfo 			; odd design decision there.
.818b					_AMXGroup2:
.818b	8a		txa				txa 							; is it in group 2 ?
.818c	29 20		and #$20			and 	#AM_ISG2
.818e	f0 39		beq $81c9			beq 	_AMXFail 				; no, give up.
.8190	8a		txa				txa 							; get the offset into Y
.8191	29 1f		and #$1f			and 	#$1F
.8193	4a		lsr a				lsr 	a 						; make it 0-7.
.8194	4a		lsr a				lsr  	a
.8195	a8		tay				tay
.8196	ad a5 04	lda $04a5			lda 	ModeMask 				; shift the modemask left so you can check it against the requested offset
.8199					_AMXCheckOkay:
.8199	0a		asl a				asl 	a 						; shift modemask left enough times to check legitimate.
.819a	88		dey				dey
.819b	10 fc		bpl $8199			bpl 	_AMXCheckOkay
.819d	90 2a		bcc $81c9			bcc 	_AMXFail 				; not allowed.
.819f	8a		txa				txa  							; get mask back
.81a0	29 1f		and #$1f			and 	#$1F
.81a2					_AMXHaveInfo:
.81a2	e0 00		cpx #$00			cpx 	#$00 					; does it *require* an 8 bit operand
.81a4	10 05		bpl $81ab			bpl 	_AMXAnySize 			; checking bit 7, the zero page opcode flag.
.81a6	ac 10 04	ldy $0410			ldy 	NSMantissa1 			; fail if it is outside range, e.g. the MSB is set.
.81a9	d0 1e		bne $81c9			bne 	_AMXFail
.81ab					_AMXAnySize:
.81ab	18		clc				clc 							; add offset to the base opcode
.81ac	6d a4 04	adc $04a4			adc 	BaseOpcode
.81af					_AMXOutputCode:
.81af	20 1a 81	jsr $811a			jsr 	AssemblerWriteByte 		; write the opcode out.
.81b2	e0 28		cpx #$28			cpx 	#AM_ACC 				; A mode (e.g. ASL A)
.81b4	f0 10		beq $81c6			beq 	_AMXExit
.81b6	ad 08 04	lda $0408			lda 	NSMantissa0 				; write LSB operand
.81b9	20 1a 81	jsr $811a			jsr 	AssemblerWriteByte
.81bc	e0 00		cpx #$00			cpx 	#$00 					; zeropage ?
.81be	30 06		bmi $81c6			bmi 	_AMXExit
.81c0	ad 10 04	lda $0410			lda 	NSMantissa1 			; write MSB operand
.81c3	20 1a 81	jsr $811a			jsr 	AssemblerWriteByte
.81c6					_AMXExit:
.81c6	7a		ply				ply
.81c7	38		sec				sec
.81c8	60		rts				rts
.81c9					_AMXFail:
.81c9	a0 00		ldy #$00			ldy 	#0
.81cb					_AMXCheckOddities:
.81cb	8a		txa				txa
.81cc	d9 f4 81	cmp $81f4,y			cmp 	ExtraOpcode+2,y 		; match address mode
.81cf	d0 16		bne $81e7			bne 	_AMXCONext
.81d1	b9 f2 81	lda $81f2,y			lda 	ExtraOpcode+0,y 		; do the base opcodes match
.81d4	cd a4 04	cmp $04a4			cmp 	BaseOpcode
.81d7	d0 0e		bne $81e7			bne 	_AMXCONext
.81d9	e0 00		cpx #$00			cpx 	#$00 					; requires zero page ?
.81db	10 05		bpl $81e2			bpl 	_AMXCONotZero
.81dd	ad 10 04	lda $0410			lda 	NSMantissa1
.81e0	d0 05		bne $81e7			bne 	_AMXCONext
.81e2					_AMXCONotZero:
.81e2	b9 f3 81	lda $81f3,y			lda 	ExtraOpcode+1,y 		; get new opcode
.81e5	80 c8		bra $81af			bra 	_AMXOutputCode 			; and assemble it
.81e7					_AMXCONext:
.81e7	c8		iny				iny
.81e8	c8		iny				iny
.81e9	c8		iny				iny
.81ea	b9 f2 81	lda $81f2,y			lda 	ExtraOpcode+0,y 		; end of table
.81ed	d0 dc		bne $81cb			bne 	_AMXCheckOddities
.81ef					_AMXCOFail:
.81ef	7a		ply				ply
.81f0	18		clc				clc
.81f1	60		rts				rts
.81f2					ExtraOpcode:
>81f2	40 6c 01					.byte $40,$6c,AM_INDABS 	; jmp
>81f5	40 7c 02					.byte $40,$7C,AM_INDABSX 	; jmp
>81f8	a2 be 78					.byte $a2,$BE,AM_ABSY 		; ldx
>81fb	a2 b6 80					.byte $a2,$B6,AM_ZEROY 		; ldx
>81fe	82 96 80					.byte $82,$96,AM_ZEROY 		; stx
>8201	e2 1a 28					.byte $e2,$1a,AM_ACC 		; inc
>8204	c2 3a 28					.byte $c2,$3a,AM_ACC 		; dec
>8207	20 89 e0					.byte $20,$89,AM_IMMEDIATE 	; bit
>820a	60 9c 6c					.byte $60,$9c,AM_ABS 		; stz
>820d	60 9e 7c					.byte $60,$9e,AM_ABSX 		; stz
>8210	00						.byte $00

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/label.asm

.8211					LabelHere:
.8211	c8		iny				iny 								; skip .
.8212	a2 00		ldx #$00			ldx 	#0 							; get a term
.8214	20 f2 97	jsr $97f2			jsr 	EvaluateTerm 				; get a term
.8217	ad 00 04	lda $0400			lda 	NSStatus 					; needs to be an integer reference.
.821a	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.821c	d0 24		bne $8242			bne 	_ALType
.821e	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy reference address to zTemp0
.8221	85 36		sta $36				sta 	zTemp0
.8223	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.8226	85 37		sta $37				sta 	zTemp0+1
.8228	5a		phy				phy 								; copy address in.
.8229	a0 01		ldy #$01			ldy 	#1
.822b	ad 9e 04	lda $049e			lda	 	AssemblerAddress
.822e	92 36		sta ($36)			sta 	(zTemp0)
.8230	ad 9f 04	lda $049f			lda	 	AssemblerAddress+1
.8233	91 36		sta ($36),y			sta 	(zTemp0),y
.8235	c8		iny				iny
.8236	a9 00		lda #$00			lda 	#0
.8238	91 36		sta ($36),y			sta 	(zTemp0),y
.823a	c8		iny				iny
.823b	91 36		sta ($36),y			sta 	(zTemp0),y
.823d	c8		iny				iny
.823e	91 36		sta ($36),y			sta 	(zTemp0),y
.8240	7a		ply				ply
.8241	60		rts				rts
.8242					_ALType:
.8242	4c c0 9f	jmp $9fc0			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/operands.asm

.8245					TypeAndCalculateOperand:
.8245	b1 30		lda ($30),y			lda 	(codePtr),y
.8247	a2 28		ldx #$28			ldx 	#AM_ACC 					; ACC if : or EOL
.8249	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.824b	f0 5b		beq $82a8			beq 	_TACOExit
.824d	c9 80		cmp #$80			cmp 	#KWC_EOL
.824f	f0 57		beq $82a8			beq 	_TACOExit
.8251	c8		iny				iny
.8252	a2 e0		ldx #$e0			ldx 	#AM_IMMEDIATE
.8254	c9 23		cmp #$23			cmp 	#KWD_HASH 					; if hash, then immediate - constant.
.8256	f0 51		beq $82a9			beq 	CalculateOperand
.8258	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; if ( then check for indirection
.825a	f0 1f		beq $827b			beq 	_TACOIndirect
.825c	88		dey				dey 								; undo get of first character
.825d	20 a9 82	jsr $82a9			jsr 	CalculateOperand 			; get operand
.8260	b1 30		lda ($30),y			lda 	(codePtr),y
.8262	a2 e4		ldx #$e4			ldx 	#AM_ZEROPAGE 				; if not, try zero page (then absolute)
.8264	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8266	d0 40		bne $82a8			bne 	_TACOExit
.8268	c8		iny				iny
.8269	20 b3 82	jsr $82b3			jsr 	TACOCheckXY 				; extract X,Y or 0 (neither) from the variable.
.826c	a2 f4		ldx #$f4			ldx 	#AM_ZEROX 					; check for X
.826e	c9 58		cmp #$58			cmp 	#'X'
.8270	f0 36		beq $82a8			beq 	_TACOExit
.8272	a2 80		ldx #$80			ldx 	#AM_ZEROY 					; check for Y
.8274	c9 59		cmp #$59			cmp 	#'Y'
.8276	f0 30		beq $82a8			beq 	_TACOExit
.8278					_TACOSyntax:
.8278	4c b6 9f	jmp $9fb6			jmp 	SyntaxError
.827b					_TACOIndirect:
.827b	20 a9 82	jsr $82a9			jsr 	CalculateOperand 			; get the operand
.827e	b1 30		lda ($30),y			lda 	(codePtr),y
.8280	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if , then it must be ,X)
.8282	f0 17		beq $829b			beq 	_TACOIndX
.8284	20 50 8d	jsr $8d50			jsr 	CheckRightBracket  			; otherwise must be ) or ),Y
.8287	b1 30		lda ($30),y			lda 	(codePtr),y
.8289	a2 d1		ldx #$d1			ldx 	#AM_IND
.828b	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not comma then exit with (xx)
.828d	d0 19		bne $82a8			bne 	_TACOExit
.828f	c8		iny				iny
.8290	20 b3 82	jsr $82b3			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.8293	c9 59		cmp #$59			cmp 	#'Y' 						; check Y
.8295	d0 e1		bne $8278			bne 	_TACOSyntax
.8297	a2 d0		ldx #$d0			ldx 	#AM_INDY
.8299	80 0d		bra $82a8			bra 	_TACOExit
.829b					_TACOIndX:
.829b	c8		iny				iny
.829c	20 b3 82	jsr $82b3			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.829f	c9 58		cmp #$58			cmp 	#'X' 						; check X
.82a1	d0 d5		bne $8278			bne 	_TACOSyntax
.82a3	20 50 8d	jsr $8d50			jsr 	CheckRightBracket			; check )
.82a6	a2 c0		ldx #$c0			ldx 	#AM_INDX
.82a8					_TACOExit:
.82a8	60		rts				rts
.82a9					CalculateOperand:
.82a9	48		pha				pha
.82aa	da		phx				phx
.82ab	a2 00		ldx #$00			ldx 	#0 							; get 16 bit integer in Slot 0
.82ad	20 8d 9d	jsr $9d8d			jsr 	Evaluate16BitInteger
.82b0	fa		plx				plx
.82b1	68		pla				pla
.82b2	60		rts				rts
.82b3					TACOCheckXY:
.82b3	b1 30		lda ($30),y			lda 	(codePtr),y
.82b5	29 c0		and #$c0			and 	#$C0 						; check it is an identifier reference.
.82b7	c9 40		cmp #$40			cmp 	#$40
.82b9	d0 21		bne $82dc			bne 	_TCXYFail
.82bb	b1 30		lda ($30),y			lda 	(codePtr),y
.82bd	18		clc				clc
.82be	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.82c0	85 37		sta $37				sta 	zTemp0+1
.82c2	c8		iny				iny
.82c3	b1 30		lda ($30),y			lda 	(codePtr),y
.82c5	c8		iny				iny
.82c6	85 36		sta $36				sta 	zTemp0
.82c8	5a		phy				phy 								; save position
.82c9	a0 02		ldy #$02			ldy 	#2 							; type is integer ?
.82cb	b1 36		lda ($36),y			lda 	(zTemp0),y
.82cd	d0 0c		bne $82db			bne 	_TCXYPopFail
.82cf	a0 08		ldy #$08			ldy 	#8 							; get first character, should have bit 7 set as also last.
.82d1	b1 36		lda ($36),y			lda 	(zTemp0),y
.82d3	c9 d8		cmp #$d8			cmp 	#'X'+$80 					; should be X or Y
.82d5	f0 08		beq $82df			beq 	_TCXYFound
.82d7	c9 d9		cmp #$d9			cmp 	#'Y'+$80
.82d9	f0 04		beq $82df			beq 	_TCXYFound
.82db					_TCXYPopFail:
.82db	7a		ply				ply
.82dc					_TCXYFail:
.82dc	a9 00		lda #$00			lda 	#0
.82de	60		rts				rts
.82df					_TCXYFound:
.82df	7a		ply				ply 								; restore position
.82e0	29 7f		and #$7f			and 	#$7F 						; throw bit 7
.82e2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/backload.asm

.82e3					BackloadProgram:
.82e3	a9 00		lda #$00			lda 	#((SOURCE_ADDRESS) & $FF)
.82e5	8d 2b 06	sta $062b			sta 	0+BackLoadPointer
.82e8	a9 30		lda #$30			lda 	#((SOURCE_ADDRESS) >> 8)
.82ea	8d 2c 06	sta $062c			sta 	1+BackLoadPointer
.82ed					_BPLoop:
.82ed	a2 ff		ldx #$ff			ldx 	#$FF
.82ef	8e fa ff	stx $fffa			stx 	$FFFA 						; fast mode (autorun only)
.82f2	20 1c 83	jsr $831c			jsr 	BLReadByte
.82f5	30 1e		bmi $8315			bmi 	_BPExit
.82f7					_BPCopy:
.82f7	e8		inx				inx  								; copy byte in
.82f8	9d a8 05	sta $05a8,x			sta 	lineBuffer,x
.82fb	9e a9 05	stz $05a9,x			stz 	lineBuffer+1,x
.82fe	20 1c 83	jsr $831c			jsr 	BLReadByte 					; read next byte
.8301	30 0a		bmi $830d			bmi 	_BPEndLine 					; -ve = EOL
.8303	c9 09		cmp #$09			cmp 	#9 							; handle TAB
.8305	d0 02		bne $8309			bne 	_BPNotTab
.8307	a9 20		lda #$20			lda 	#' '
.8309					_BPNotTab:
.8309	c9 20		cmp #$20			cmp 	#' ' 						; < ' ' = EOL
.830b	b0 ea		bcs $82f7			bcs 	_BPCopy
.830d					_BPEndLine:
.830d	20 e3 b5	jsr $b5e3			jsr 	TokeniseLine 				; tokenise the line.
.8310	20 33 83	jsr $8333			jsr 	EditProgramCode
.8313	80 d8		bra $82ed			bra 	_BPLoop
.8315					_BPExit:
.8315	9c fa ff	stz $fffa			stz 	$FFFA 						; clear fast mode (autorun only)
.8318	20 f1 83	jsr $83f1			jsr 	ClearCommand 				; clear variables etc.
.831b	60		rts				rts
.831c					BLReadByte:
.831c	ad 2b 06	lda $062b			lda 	BackLoadPointer
.831f	85 36		sta $36				sta 	zTemp0
.8321	ad 2c 06	lda $062c			lda 	BackLoadPointer+1
.8324	85 37		sta $37				sta 	zTemp0+1
.8326	b2 36		lda ($36)			lda 	(zTemp0)
.8328	ee 2b 06	inc $062b			inc 	BackLoadPointer
.832b	d0 03		bne $8330			bne 	_BLNoCarry
.832d	ee 2c 06	inc $062c			inc 	BackLoadPointer+1
.8330					_BLNoCarry:
.8330	c9 00		cmp #$00			cmp 	#0
.8332	60		rts				rts
.062b					BackLoadPointer:
>062b							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/editor.asm

.8333					EditProgramCode:
.8333	ad a9 04	lda $04a9			lda 	TokenLineNumber 			; find the line.
.8336	ae aa 04	ldx $04aa			ldx 	TokenLineNumber+1
.8339	20 c5 a5	jsr $a5c5			jsr 	MemorySearch
.833c	90 05		bcc $8343			bcc 	_EPCNoDelete 				; reached the end don't delete
.833e	d0 03		bne $8343			bne 	_EPCNoDelete 				; found slot but didn't match, no delete
.8340	20 e6 a4	jsr $a4e6			jsr 	MemoryDeleteLine 			; delete the line
.8343					_EPCNoDelete:
.8343	ad ab 04	lda $04ab			lda 	TokenBuffer 				; buffer empty
.8346	c9 80		cmp #$80			cmp 	#KWC_EOL
.8348	f0 0d		beq $8357			beq 	_EPCNoInsert
.834a	ad a9 04	lda $04a9			lda 	TokenLineNumber 			; find the line - it cannot exist.
.834d	ae aa 04	ldx $04aa			ldx 	TokenLineNumber+1 			; so this can't fail, it returns some point in the code.
.8350	20 c5 a5	jsr $a5c5			jsr 	MemorySearch
.8353	18		clc				clc 								; insert at this point.
.8354	20 1d a5	jsr $a51d			jsr 	MemoryInsertLine 			; insert the line
.8357					_EPCNoInsert:
.8357	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/warmstart.asm

.8358					WarmStart:
.8358	a2 ff		ldx #$ff			ldx 	#$FF
.835a	9a		txs				txs
.835b	20 53 a9	jsr $a953			jsr 	EXTInputLine 				; get line to lineBuffer
.835e	20 e3 b5	jsr $b5e3			jsr 	TokeniseLine 				; tokenise the line
.8361	ad a9 04	lda $04a9			lda 	TokenLineNumber 			; line number ?
.8364	0d aa 04	ora $04aa			ora 	TokenLineNumber+1
.8367	d0 17		bne $8380			bne 	_WSEditCode 				; if so,edit code.
.8369	9c a8 04	stz $04a8			stz 	TokenOffset 				; zero offset, meaning it only runs one line.
.836c	a9 a8		lda #$a8			lda 	#((TokenOffset) & $FF)
.836e	85 30		sta $30				sta 	codePtr
.8370	a9 04		lda #$04			lda 	#((TokenOffset) >> 8)
.8372	85 31		sta $31				sta 	codePtr+1
.8374	ad ab 04	lda $04ab			lda 	TokenBuffer 				; nothing to run
.8377	c9 80		cmp #$80			cmp 	#KWC_EOL
.8379	f0 dd		beq $8358			beq 	WarmStart
.837b	20 11 8a	jsr $8a11			jsr 	RUNCodePointerLine 			; execute that line.
.837e	80 d8		bra $8358			bra 	WarmStart
.8380					_WSEditCode:
.8380	20 33 83	jsr $8333			jsr 	EditProgramCode
.8383	20 f1 83	jsr $83f1			jsr 	ClearCommand
.8386	80 d0		bra $8358			bra 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assemble.asm

.8388					AssembleCommand:
.8388	a2 00		ldx #$00			ldx 	#0
.838a	20 8d 9d	jsr $9d8d			jsr 	Evaluate16BitInteger 		; start address
.838d	ad 08 04	lda $0408			lda 	NSMantissa0
.8390	8d 9e 04	sta $049e			sta 	AssemblerAddress
.8393	ad 10 04	lda $0410			lda 	NSMantissa1
.8396	8d 9f 04	sta $049f			sta 	AssemblerAddress+1
.8399	20 58 8d	jsr $8d58			jsr 	CheckComma
.839c	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger 		; options
.839f	ad 08 04	lda $0408			lda 	NSMantissa0
.83a2	8d a0 04	sta $04a0			sta 	AssemblerControl
.83a5	60		rts				rts
.83a6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assert.asm

.83a7					AssertCommand:
.83a7	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.83a9	20 78 9d	jsr $9d78			jsr 	EvaluateInteger 			; the assert test
.83ac	20 5c 9e	jsr $9e5c			jsr 	NSMIsZero 					; exit if result is non zero.
.83af	d0 05		bne $83b6			bne 	_ACExit
.83b1	a9 0a		lda #$0a		lda	#10
.83b3	4c 69 8d	jmp $8d69		jmp	ErrorHandler
.83b6					_ACExit:
.83b6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/call.asm

.83b7					CallCommand:
.83b7	a2 00		ldx #$00			ldx 	#0
.83b9	20 8d 9d	jsr $9d8d			jsr 	Evaluate16BitInteger
.83bc					_CCClear
.83bc	e8		inx				inx  								; clear 1,2 and 3 (for A X Y)
.83bd	20 2c 9e	jsr $9e2c			jsr 	NSMSetZero
.83c0	e0 04		cpx #$04			cpx 	#4
.83c2	d0 f8		bne $83bc			bne 	_CCClear
.83c4	a2 00		ldx #$00			ldx 	#0 							; and keep trying
.83c6					_CCCParam:
.83c6	b1 30		lda ($30),y			lda 	(codePtr),y
.83c8	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.83ca	d0 09		bne $83d5			bne 	_CCCRun6502
.83cc	c8		iny				iny 								; skip comma
.83cd	e8		inx				inx	 								; next level
.83ce	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger 		; get A/X/Y
.83d1	e0 03		cpx #$03			cpx 	#3
.83d3	90 f1		bcc $83c6			bcc 	_CCCParam 					; done all 3 ?
.83d5					_CCCRun6502:
.83d5	5a		phy				phy 								; save position
.83d6	ad 10 04	lda $0410			lda 	NSMantissa1 				; put address in zTemp0
.83d9	85 37		sta $37				sta 	zTemp0+1
.83db	ad 08 04	lda $0408			lda 	NSMantissa0
.83de	85 36		sta $36				sta 	zTemp0
.83e0	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; get registers
.83e3	ae 0a 04	ldx $040a			ldx 	NSMantissa0+2
.83e6	ac 0b 04	ldy $040b			ldy 	NSMantissa0+3
.83e9	20 ee 83	jsr $83ee			jsr 	_CCCZTemp0 					; call zTemp0
.83ec	7a		ply				ply 								; restore position and exit
.83ed	60		rts				rts
.83ee					_CCCZTemp0:
.83ee	6c 36 00	jmp ($0036)			jmp 	(zTemp0)

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/clear.asm

.83f1					ClearCommand:
.83f1	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.83f3	85 36		sta $36				sta 	0+zTemp0
.83f5	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.83f7	85 37		sta $37				sta 	1+zTemp0
.83f9					_ClearZeroLoop:
.83f9	b2 36		lda ($36)			lda 	(zTemp0) 					; end of variables
.83fb	f0 24		beq $8421			beq 	_ClearZeroEnd
.83fd	a0 03		ldy #$03			ldy 	#3 							; erase the variables
.83ff	a9 00		lda #$00			lda 	#0
.8401					_ClearOneVariable:
.8401	91 36		sta ($36),y			sta 	(zTemp0),y
.8403	c8		iny				iny
.8404	c0 08		cpy #$08			cpy 	#8
.8406	d0 f9		bne $8401			bne 	_ClearOneVariable
.8408	a0 02		ldy #$02			ldy 	#2 							; has it been marked procedure
.840a	b1 36		lda ($36),y			lda 	(zTemp0),y
.840c	c9 18		cmp #$18			cmp 	#NSTProcedure
.840e	d0 04		bne $8414			bne 	_ClearNotProcedure
.8410	a9 04		lda #$04			lda 	#NSTInteger+NSBIsArray 		; set it back to an integer array
.8412	91 36		sta ($36),y			sta 	(zTemp0),y
.8414					_ClearNotProcedure:
.8414	18		clc				clc 								; go to the next variable
.8415	b2 36		lda ($36)			lda 	(zTemp0)
.8417	65 36		adc $36				adc 	zTemp0
.8419	85 36		sta $36				sta 	zTemp0
.841b	90 dc		bcc $83f9			bcc 	_ClearZeroLoop
.841d	e6 37		inc $37				inc 	zTemp0+1
.841f	80 d8		bra $83f9			bra 	_ClearZeroLoop
.8421					_ClearZeroEnd:
.8421	18		clc				clc
.8422	a5 36		lda $36				lda 	zTemp0
.8424	69 01		adc #$01			adc 	#1
.8426	8d 8c 04	sta $048c			sta 	lowMemPtr
.8429	a5 37		lda $37				lda 	zTemp0+1
.842b	69 00		adc #$00			adc 	#0
.842d	8d 8d 04	sta $048d			sta 	lowMemPtr+1
.8430	20 ea a6	jsr $a6ea			jsr 	StackReset
.8433	20 54 a7	jsr $a754			jsr 	StringSystemInitialise
.8436	20 59 8c	jsr $8c59			jsr 	ProcedureScan
.8439	20 c0 89	jsr $89c0			jsr 	Command_Restore
.843c	9c 9e 04	stz $049e			stz 	AssemblerAddress
.843f	9c 9f 04	stz $049f			stz 	AssemblerAddress+1
.8442	9c a0 04	stz $04a0			stz 	AssemblerControl
.8445	20 f5 99	jsr $99f5			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.8448	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/cls.asm

.8449					ClearScreen:
.8449	5a		phy				phy
.844a	a9 0c		lda #$0c			lda 	#12 						; char code 12 clears the screen.
.844c	20 c5 a7	jsr $a7c5			jsr 	EXTPrintCharacter
.844f	7a		ply				ply
.8450	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/data.asm

.8451					Command_Data:
.8451	a9 3a		lda #$3a			lda 	#KWD_COLON 					; advance to colon/EOL
.8453	a2 80		ldx #$80			ldx 	#KWC_EOL
.8455	20 ab 8c	jsr $8cab			jsr 	ScanForward
.8458	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dim.asm

.8459					DimCommand:
.8459	b1 30		lda ($30),y			lda 	(codePtr),y
.845b	29 c0		and #$c0			and 	#$C0
.845d	c9 40		cmp #$40			cmp 	#$40
.845f	d0 7a		bne $84db			bne 	_DCSyntax
.8461	b1 30		lda ($30),y			lda 	(codePtr),y
.8463	18		clc				clc
.8464	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8466	85 3f		sta $3f				sta 	zaTemp+1
.8468	c8		iny				iny
.8469	b1 30		lda ($30),y			lda 	(codePtr),y
.846b	c8		iny				iny
.846c	85 3e		sta $3e				sta 	zaTemp
.846e	5a		phy				phy
.846f	a0 02		ldy #$02			ldy 	#2 						; read type byte
.8471	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8473	29 18		and #$18			and 	#NSBTypeMask 			; check it's not a procedure
.8475	c9 18		cmp #$18			cmp 	#NSTProcedure
.8477	f0 62		beq $84db			beq 	_DCSyntax
.8479	b1 3e		lda ($3e),y			lda 	(zaTemp),y 				; check it's an array
.847b	29 04		and #$04			and 	#NSBIsArray
.847d	f0 64		beq $84e3			beq 	_DCType
.847f	a0 04		ldy #$04			ldy 	#4 						; check not already defined
.8481	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8483	d0 59		bne $84de			bne 	_DCRedefine
.8485	7a		ply				ply
.8486	20 e6 84	jsr $84e6			jsr 	_DCGetSize 				; get array size, check it.
.8489	5a		phy				phy
.848a	a0 05		ldy #$05			ldy 	#5 						; store in first array size slot
.848c	91 3e		sta ($3e),y			sta 	(zaTemp),y 				; second will be zero.
.848e	7a		ply				ply 							; is there a second (e.g. ,x)
.848f	b1 30		lda ($30),y			lda 	(codePtr),y
.8491	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8493	d0 0a		bne $849f			bne 	_DCOneDimension
.8495	c8		iny				iny 							; skip comma
.8496	20 e6 84	jsr $84e6			jsr 	_DCGetSize 				; get 2nd array size
.8499	5a		phy				phy
.849a	a0 06		ldy #$06			ldy 	#6 						; store in 2nd array size
.849c	91 3e		sta ($3e),y			sta 	(zaTemp),y
.849e	7a		ply				ply
.849f					_DCOneDimension:
.849f	5a		phy				phy 							; save position
.84a0	a0 05		ldy #$05			ldy 	#5 						; dimensions + 1 in AX (as zero based)
.84a2	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84a4	aa		tax				tax
.84a5	c8		iny				iny
.84a6	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84a8	e8		inx				inx 							; bump them.
.84a9	1a		inc a				inc 	a
.84aa	20 c1 9d	jsr $9dc1			jsr 	Multiply8x8 			; work out the total number of elements -> zTemp0
.84ad	a5 37		lda $37				lda 	zTemp0+1 				; don't allow more than 8192 elements whatever
.84af	29 e0		and #$e0			and 	#$E0
.84b1	d0 23		bne $84d6			bne 	_DCSize
.84b3	a0 02		ldy #$02			ldy 	#2 						; get base type
.84b5	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84b7	20 f4 84	jsr $84f4			jsr 	ScaleByBaseType 		; scale by base type
.84ba	a5 36		lda $36				lda 	zTemp0
.84bc	a6 37		ldx $37				ldx 	zTemp0+1
.84be	20 b7 99	jsr $99b7			jsr 	AllocateXABytes 		; allocate memory
.84c1	a0 03		ldy #$03			ldy 	#3 						; copy into the address.
.84c3	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84c5	c8		iny				iny
.84c6	8a		txa				txa
.84c7	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84c9	7a		ply				ply 							; get position back
.84ca	20 50 8d	jsr $8d50			jsr 	CheckRightBracket 		; check )
.84cd	b1 30		lda ($30),y			lda 	(codePtr),y
.84cf	c8		iny				iny 							; consume in case
.84d0	c9 2c		cmp #$2c			cmp 	#KWD_COMMA		 		; if so do another DIM.
.84d2	f0 85		beq $8459			beq 	DimCommand
.84d4	88		dey				dey 							; undo consume
.84d5	60		rts				rts
.84d6					_DCSize:
.84d6	a9 16		lda #$16		lda	#22
.84d8	4c 69 8d	jmp $8d69		jmp	ErrorHandler
.84db					_DCSyntax:
.84db	4c b6 9f	jmp $9fb6			jmp 	SyntaxError
.84de					_DCRedefine:
.84de	a9 15		lda #$15		lda	#21
.84e0	4c 69 8d	jmp $8d69		jmp	ErrorHandler
.84e3					_DCType:
.84e3	4c c0 9f	jmp $9fc0			jmp 	TypeError
.84e6					_DCGetSize:
.84e6	a2 00		ldx #$00			ldx 	#0 						; get first index.
.84e8	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger 	; get array dimension
.84eb	c9 00		cmp #$00			cmp 	#0 						; must be 1-254
.84ed	f0 e7		beq $84d6			beq 	_DCSize
.84ef	c9 fe		cmp #$fe			cmp 	#254
.84f1	f0 e3		beq $84d6			beq 	_DCSize
.84f3	60		rts				rts
.84f4					ScaleByBaseType:
.84f4	29 10		and #$10			and 	#NSBIsString 			; is it string
.84f6	d0 19		bne $8511			bne 	_SBBTString
.84f8	a5 37		lda $37				lda 	zTemp0+1 				; push value on stack
.84fa	48		pha				pha
.84fb	a5 36		lda $36				lda 	zTemp0
.84fd	48		pha				pha
.84fe	06 36		asl $36				asl 	zTemp0 					; x 2
.8500	26 37		rol $37				rol 	zTemp0+1
.8502	06 36		asl $36				asl 	zTemp0 					; x 4
.8504	26 37		rol $37				rol 	zTemp0+1
.8506	68		pla				pla 							; add stacked value = x 5
.8507	65 36		adc $36				adc 	zTemp0
.8509	85 36		sta $36				sta 	zTemp0
.850b	68		pla				pla
.850c	65 37		adc $37				adc 	zTemp0+1
.850e	85 37		sta $37				sta 	zTemp0+1
.8510	60		rts				rts
.8511					_SBBTString:
.8511	06 36		asl $36				asl 	zTemp0
.8513	26 37		rol $37				rol 	zTemp0+1
.8515	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/end.asm

.8516					EndCommand:
.8516	4c 58 83	jmp $8358			jmp 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/for.asm

.8519					ForCommand:
.8519	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; allocate 18 bytes on the return stack.
.851b	20 85 a6	jsr $a685			jsr 	StackOpen
.851e	a2 00		ldx #$00			ldx 	#0
.8520	20 f2 97	jsr $97f2			jsr 	EvaluateTerm
.8523	bd 00 04	lda $0400,x			lda 	NSStatus,x
.8526	c9 20		cmp #$20			cmp 	#NSBIsReference+NSTInteger 	; do we have an integer 4 byte reference.
.8528	d0 49		bne $8573			bne		_FCError
.852a	a9 3d		lda #$3d			lda 	#KWD_EQUAL 					; =
.852c	20 60 8d	jsr $8d60			jsr 	CheckNextA
.852f	e8		inx				inx
.8530	20 78 9d	jsr $9d78			jsr 	EvaluateInteger 			; <from> in +1
.8533	b1 30		lda ($30),y			lda 	(codePtr),y
.8535	c8		iny				iny 								; consume it
.8536	48		pha				pha 								; save on stack for later
.8537	c9 b4		cmp #$b4			cmp 	#KWD_DOWNTO
.8539	f0 04		beq $853f			beq 	_FCNoSyntax
.853b	c9 cd		cmp #$cd			cmp 	#KWD_TO
.853d	d0 37		bne $8576			bne 	_FCSyntaxError
.853f					_FCNoSyntax:
.853f	e8		inx				inx
.8540	20 78 9d	jsr $9d78			jsr 	EvaluateInteger
.8543	20 c9 a6	jsr $a6c9			jsr 	STKSaveCodePosition 		; save loop back position
.8546	68		pla				pla 								; restore DOWNTO or TO
.8547	5a		phy				phy 								; save Y on the stack
.8548	49 b4		eor #$b4			eor 	#KWD_DOWNTO 				; 0 if DOWNTO, #0 if TO
.854a	f0 02		beq $854e			beq 	_FCNotDownTo
.854c	a9 02		lda #$02			lda 	#2
.854e					_FCNotDownTo:
.854e	3a		dec a				dec 	a 							; 255 if DOWNTO, 1 if TO
.854f	a0 10		ldy #$10			ldy 	#16
.8551	91 34		sta ($34),y			sta 	(basicStack),y 				; copy that out to the Basic Stack.
.8553	a0 06		ldy #$06			ldy 	#6
.8555	ad 08 04	lda $0408			lda 	NSMantissa0
.8558	91 34		sta ($34),y			sta 	(basicStack),y
.855a	ad 10 04	lda $0410			lda 	NSMantissa1
.855d	c8		iny				iny
.855e	91 34		sta ($34),y			sta 	(basicStack),y
.8560	a0 08		ldy #$08			ldy 	#8 							; set initial index value
.8562	a2 01		ldx #$01			ldx 	#1
.8564	20 79 85	jsr $8579			jsr 	FCIntegerToStack
.8567	a0 0c		ldy #$0c			ldy 	#12 						; set the terminal value
.8569	a2 02		ldx #$02			ldx 	#2
.856b	20 79 85	jsr $8579			jsr 	FCIntegerToStack
.856e	20 99 85	jsr $8599			jsr 	CopyIndexToReference
.8571	7a		ply				ply 								; restore position
.8572	60		rts				rts
.8573					_FCError:
.8573	4c c0 9f	jmp $9fc0			jmp 	TypeError
.8576					_FCSyntaxError:
.8576	4c b6 9f	jmp $9fb6			jmp 	SyntaxError
.8579					FCIntegerToStack:
.8579	3c 00 04	bit $0400,x			bit 	NSStatus,x 					; is the value negative
.857c	10 03		bpl $8581			bpl	 	_FCNotNegative
.857e	20 e1 9d	jsr $9de1			jsr 	NSMNegateMantissa 			; if so 2's complement the mantissa
.8581					_FCNotNegative:
.8581	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy out to the basic stack
.8584	91 34		sta ($34),y			sta 	(basicStack),y
.8586	c8		iny				iny
.8587	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.858a	91 34		sta ($34),y			sta 	(basicStack),y
.858c	c8		iny				iny
.858d	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.8590	91 34		sta ($34),y			sta 	(basicStack),y
.8592	c8		iny				iny
.8593	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.8596	91 34		sta ($34),y			sta 	(basicStack),y
.8598	60		rts				rts
.8599					CopyIndexToReference:
.8599	5a		phy				phy
.859a	a0 06		ldy #$06			ldy 	#6 							; copy address-8 to write to zTemp0
.859c	38		sec				sec 								; (because we copy from offset 8)
.859d	b1 34		lda ($34),y			lda 	(basicStack),y
.859f	e9 08		sbc #$08			sbc 	#8
.85a1	85 36		sta $36				sta 	zTemp0
.85a3	c8		iny				iny
.85a4	b1 34		lda ($34),y			lda 	(basicStack),y
.85a6	e9 00		sbc #$00			sbc 	#0
.85a8	85 37		sta $37				sta 	zTemp0+1
.85aa	a2 04		ldx #$04			ldx 	#4 							; this is the copy counter/
.85ac	a0 0b		ldy #$0b			ldy 	#8+3 		 				; the MSB of the mantissa
.85ae	b1 34		lda ($34),y			lda 	(basicStack),y
.85b0	0a		asl a				asl 	a 							; into carry
.85b1	a0 08		ldy #$08			ldy 	#8 							; where to copy from.
.85b3	90 14		bcc $85c9			bcc 	_CITRNormal
.85b5	38		sec				sec
.85b6					_CITRNegative:
.85b6	a9 00		lda #$00			lda 	#0
.85b8	f1 34		sbc ($34),y			sbc 	(basicStack),y
.85ba	91 36		sta ($36),y			sta 	(zTemp0),y
.85bc	c8		iny				iny
.85bd	ca		dex				dex
.85be	d0 f6		bne $85b6			bne 	_CITRNegative
.85c0	88		dey				dey 								; look at MSB of mantissa
.85c1	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set the MSB as negative packed.
.85c3	09 80		ora #$80			ora 	#$80
.85c5	91 36		sta ($36),y			sta 	(zTemp0),y
.85c7	7a		ply				ply
.85c8	60		rts				rts
.85c9					_CITRNormal:
.85c9	b1 34		lda ($34),y			lda 	(basicStack),y 				; copy without negation.
.85cb	91 36		sta ($36),y			sta 	(zTemp0),y
.85cd	c8		iny				iny
.85ce	ca		dex				dex
.85cf	d0 f8		bne $85c9			bne 	_CITRNormal
.85d1	7a		ply				ply 								; and exit.
.85d2	60		rts				rts
.85d3					NextCommand:
.85d3	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; check FOR is TOS
.85d5	a2 11		ldx #$11			ldx 	#ERRID_FOR 					; this error
.85d7	20 b1 a6	jsr $a6b1			jsr 	StackCheckFrame
.85da	5a		phy				phy
.85db	a0 10		ldy #$10			ldy 	#16 						; get the step count
.85dd	b1 34		lda ($34),y			lda 	(basicStack),y
.85df	85 36		sta $36				sta 	zTemp0 						; this is the sign extend
.85e1	30 02		bmi $85e5			bmi 	_NCStepNeg
.85e3	64 36		stz $36				stz 	zTemp0 						; which is 0 or 255
.85e5					_NCStepNeg:
.85e5	a0 08		ldy #$08			ldy 	#8 							; offset to bump
.85e7	a2 04		ldx #$04			ldx 	#4 							; count to bump
.85e9	18		clc				clc
.85ea					_NCBump:
.85ea	71 34		adc ($34),y			adc 	(basicStack),y 				; add it
.85ec	91 34		sta ($34),y			sta 	(basicStack),y
.85ee	a5 36		lda $36				lda 	zTemp0 						; get sign extend for next time.
.85f0	c8		iny				iny 								; next byte
.85f1	ca		dex				dex 								; do four times
.85f2	d0 f6		bne $85ea			bne 	_NCBump
.85f4	20 99 85	jsr $8599			jsr		CopyIndexToReference		; copy it to the reference variable.
.85f7	a0 10		ldy #$10			ldy 	#16 						; get step count again
.85f9	b1 34		lda ($34),y			lda 	(basicStack),y
.85fb	0a		asl a				asl 	a 							; sign bit to carry
.85fc	a9 0c		lda #$0c			lda 	#12 						; offset of LHS = terminal offset
.85fe	85 38		sta $38				sta 	zTemp1
.8600	90 02		bcc $8604			bcc 	_NCCompRev 					; use if step is +ve
.8602	a9 08		lda #$08			lda 	#8 							; now the LHS = index value
.8604					_NCCompRev:
.8604	85 38		sta $38				sta 	zTemp1 						; so zTemp0 is the index for LHS
.8606	49 04		eor #$04			eor 	#(8^12) 					; and zTemp0+1 is the index for RHS
.8608	85 39		sta $39				sta 	zTemp1+1
.860a	a2 04		ldx #$04			ldx 	#4 							; bytes to compare
.860c	38		sec				sec
.860d					_NCCompare:
.860d	a4 38		ldy $38				ldy 	zTemp1 						; do compare using the two indices
.860f	b1 34		lda ($34),y			lda 	(basicStack),y
.8611	a4 39		ldy $39				ldy 	zTemp1+1
.8613	f1 34		sbc ($34),y			sbc 	(basicStack),y
.8615	e6 38		inc $38				inc 	zTemp1 						; bump the indices (inc,dex do not change C or V)
.8617	e6 39		inc $39				inc 	zTemp1+1
.8619	ca		dex				dex 								; do it 4 times.
.861a	d0 f1		bne $860d			bne 	_NCCompare
.861c	50 02		bvc $8620			bvc 	_NCNoOverflow 				; convert to signed comparison
.861e	49 80		eor #$80			eor 	#$80
.8620					_NCNoOverflow:
.8620	7a		ply				ply 								; restore Y position
.8621	0a		asl a				asl 	a 							; is bit 7 set.
.8622	90 04		bcc $8628			bcc 	_NCLoopback 				; if no , >= so loop back
.8624	20 a3 a6	jsr $a6a3			jsr 	StackClose 					; exit the loop
.8627	60		rts				rts
.8628					_NCLoopBack:
.8628	20 da a6	jsr $a6da			jsr 	STKLoadCodePosition 		; loop back
.862b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/gosub.asm

.862c					Command_GOSUB:
.862c	a2 00		ldx #$00			ldx 	#0
.862e	20 8d 9d	jsr $9d8d			jsr 	Evaluate16BitInteger 		; line number in Stack.0
.8631	a9 e3		lda #$e3			lda 	#STK_GOSUB+3
.8633	20 85 a6	jsr $a685			jsr 	StackOpen 					; create frame
.8636	20 c9 a6	jsr $a6c9			jsr 	STKSaveCodePosition 		; save current position
.8639	4c 4f 86	jmp $864f			jmp 	GotoStackX
.863c					Command_RETURN:
.863c	a9 e0		lda #$e0			lda 	#STK_GOSUB 					; check TOS is this
.863e	a2 0e		ldx #$0e			ldx 	#ERRID_GOSUB 				; this error
.8640	20 b1 a6	jsr $a6b1			jsr 	StackCheckFrame
.8643	20 da a6	jsr $a6da			jsr 	STKLoadCodePosition 		; restore code position
.8646	20 a3 a6	jsr $a6a3			jsr 	StackClose
.8649	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/goto.asm

.864a					GotoCommand:
.864a	a2 00		ldx #$00			ldx 	#0 							; GOTO where
.864c	20 8d 9d	jsr $9d8d			jsr 	Evaluate16BitInteger
.864f					GotoStackX:
.864f	bd 10 04	lda $0410,x			lda  	NSMantissa1,x 				; put line # in XA. I'll keep this even though
.8652	48		pha				pha 								; it is slightly inefficient, just in cases.
.8653	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.8656	fa		plx				plx
.8657	20 c5 a5	jsr $a5c5			jsr 	MemorySearch 				; transfer to line number AX.
.865a	90 05		bcc $8661			bcc 	_GotoError 					; not found, off end.
.865c	d0 03		bne $8661			bne 	_GotoError 					; not found exactly
.865e	4c 0a 8a	jmp $8a0a			jmp 	RunNewLine 					; and go straight to new line code.
.8661					_GotoError:
.8661	a9 0d		lda #$0d		lda	#13
.8663	4c 69 8d	jmp $8d69		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/if.asm

.8666					IfCommand:
.8666	a2 00		ldx #$00			ldx 	#0 							; If what.
.8668	20 55 9d	jsr $9d55			jsr 	EvaluateNumber
.866b	b1 30		lda ($30),y			lda 	(codePtr),y
.866d	c9 a8		cmp #$a8			cmp 	#KWD_THEN  					; could be THEN <stuff> or GOTO
.866f	d0 0a		bne $867b			bne 	_IFStructured
.8671	c8		iny				iny 								; consume THEN
.8672	20 5c 9e	jsr $9e5c			jsr 	NSMIsZero 					; is it zero
.8675	f0 01		beq $8678			beq 	_IfFail 					; if fail, go to next line
.8677	60		rts				rts 								; if THEN just continue
.8678					_IfFail:
.8678	4c f2 89	jmp $89f2			jmp 	EOLCommand
.867b					_IfStructured:
.867b	20 5c 9e	jsr $9e5c			jsr 	NSMIsZero 					; is it zero
.867e	d0 07		bne $8687			bne 	_IfExit 					; if not, then continue normally.
.8680	a9 b5		lda #$b5			lda 	#KWD_ELSE 					; look for else/endif
.8682	a2 a5		ldx #$a5			ldx 	#KWD_ENDIF
.8684	20 ab 8c	jsr $8cab			jsr 	ScanForward 				; and run from there/
.8687					_IfExit:
.8687	60		rts				rts
.8688					ElseCode:
.8688	a9 a5		lda #$a5			lda 	#KWD_ENDIF 					; else is only run after the if clause succeeds
.868a	aa		tax				tax 								; so just go to the structure exit
.868b	20 ab 8c	jsr $8cab			jsr 	ScanForward
.868e	60		rts				rts
.868f					EndIf:
.868f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/let.asm

.8690					LetCommand:
.8690	a2 00		ldx #$00			ldx 	#0
.8692	b1 30		lda ($30),y			lda 	(codePtr),y
.8694	c9 10		cmp #$10			cmp 	#KWD_AT
.8696	d0 16		bne $86ae			bne 	_LCStandard
.8698	c8		iny				iny 								; skip equal
.8699	20 f2 97	jsr $97f2			jsr 	EvaluateTerm 				; get a number
.869c	20 36 96	jsr $9636			jsr 	Dereference 				; dereference it
.869f	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check integer
.86a2	49 20		eor #$20			eor 	#NSBIsReference	 			; toggle reference
.86a4	9d 00 04	sta $0400,x			sta 	NSStatus,x
.86a7	29 20		and #$20			and 	#NSBIsReference 			; if it is now a reference, continue
.86a9	d0 10		bne $86bb			bne 	_LCMain
.86ab	4c c0 9f	jmp $9fc0			jmp 	TypeError 					; was a reference before.
.86ae					_LCStandard:
.86ae	ad 00 93	lda $9300			lda 	PrecedenceLevel+"*"			; precedence > this
.86b1	20 1a 93	jsr $931a			jsr 	EvaluateExpressionAtPrecedence
.86b4	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; is it a reference to an array
.86b7	c9 38		cmp #$38			cmp		#NSTProcedure+NSBIsReference
.86b9	f0 0e		beq $86c9			beq 	_LetGoProc 					; it's a procedure call.
.86bb					_LCMain:
.86bb	a9 3d		lda #$3d			lda 	#"=" 						; check =
.86bd	20 60 8d	jsr $8d60			jsr 	CheckNextA
.86c0	e8		inx				inx 								; RHS
.86c1	20 4c 9d	jsr $9d4c			jsr 	EvaluateValue
.86c4	ca		dex				dex
.86c5	20 cc 86	jsr $86cc			jsr 	AssignVariable
.86c8	60		rts				rts
.86c9					_LetGoProc:
.86c9	4c ca 88	jmp $88ca			jmp 	CallProcedure
.86cc					AssignVariable:
.86cc	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check the string/number type bits match
.86cf	48		pha				pha 								; save a copy
.86d0	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.86d3	29 10		and #$10			and 	#NSBIsString
.86d5	d0 0b		bne $86e2			bne 	_ASError
.86d7	68		pla				pla 								; get back
.86d8	29 10		and #$10			and 	#NSBIsString 				; check type
.86da	d0 03		bne $86df			bne 	_ASString
.86dc	4c 5e 95	jmp $955e			jmp 	AssignNumber
.86df					_ASString:
.86df	4c cc 95	jmp $95cc			jmp 	AssignString
.86e2					_ASError:
.86e2	4c c0 9f	jmp $9fc0			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/list.asm

.86e5					Command_List:
.86e5	9c a6 04	stz $04a6			stz 	listIndent 					; reset indent.
.86e8	9c 0c 04	stz $040c			stz		NSMantissa0+4				; set the lower (slot 4) to 0 and upper (slot 7) to $FFFF
.86eb	9c 14 04	stz $0414			stz 	NSMantissa1+4
.86ee	a9 ff		lda #$ff			lda 	#$FF
.86f0	8d 0f 04	sta $040f			sta 	NSMantissa0+7
.86f3	8d 17 04	sta $0417			sta 	NSMantissa1+7
.86f6	b1 30		lda ($30),y			lda 	(codePtr),y
.86f8	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.86fa	f0 1e		beq $871a			beq 	_CLSecond
.86fc	20 7b 87	jsr $877b			jsr 	CLIsDigit 					; if not digit, list all
.86ff	b0 24		bcs $8725			bcs 	_CLStart
.8701	a2 04		ldx #$04			ldx 	#4 							; get 1st range into slot 4
.8703	20 8d 9d	jsr $9d8d			jsr 	Evaluate16BitInteger
.8706	b1 30		lda ($30),y			lda 	(codePtr),y
.8708	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.870a	f0 0e		beq $871a			beq 	_CLSecond 					; if so go get it
.870c	ad 0c 04	lda $040c			lda 	NSMantissa0+4 				; copy 4->7
.870f	8d 0f 04	sta $040f			sta 	NSMantissa0+7
.8712	ad 14 04	lda $0414			lda 	NSMantissa1+4
.8715	8d 17 04	sta $0417			sta 	NSMantissa1+7
.8718	80 0b		bra $8725			bra 	_CLStart
.871a					_CLSecond:
.871a	c8		iny				iny 								; consume comma
.871b	20 7b 87	jsr $877b			jsr 	CLIsDigit 					; digit found
.871e	b0 05		bcs $8725			bcs 	_CLStart 					; if not, continue listing
.8720	a2 07		ldx #$07			ldx 	#7 							; load 2nd range into slot 7
.8722	20 8d 9d	jsr $9d8d			jsr 	Evaluate16BitInteger
.8725					_CLStart
.8725	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8727	85 30		sta $30				sta 	codePtr
.8729	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.872b	85 31		sta $31				sta 	codePtr+1
.872d					_CLLoop:
.872d	20 7b aa	jsr $aa7b			jsr 	EXTBreakCheck 				; break check
.8730	f0 33		beq $8765			beq 	_CLExit
.8732	b2 30		lda ($30)			lda 	(codePtr)
.8734	f0 2f		beq $8765			beq 	_CLExit
.8736	a2 04		ldx #$04			ldx 	#4 							; check range every time, line numbers aren't in order.
.8738	20 68 87	jsr $8768			jsr 	CLCompareLineNo
.873b	90 1b		bcc $8758			bcc 	_CLNext
.873d	a2 07		ldx #$07			ldx 	#7
.873f	20 68 87	jsr $8768			jsr 	CLCompareLineNo
.8742	f0 02		beq $8746			beq 	_CLDoThisOne
.8744	b0 12		bcs $8758			bcs 	_CLNext
.8746					_CLDoThisOne:
.8746	20 0e 8d	jsr $8d0e			jsr 	ScanGetCurrentLineStep 		; get indent adjust.
.8749	20 c5 b3	jsr $b3c5			jsr 	ListConvertLine 			; convert line into token Buffer
.874c	a2 04		ldx #$04			ldx 	#(tokenBuffer >> 8) 		; print that line
.874e	a9 ab		lda #$ab			lda 	#(tokenBuffer & $FF)
.8750	20 c2 8d	jsr $8dc2			jsr 	PrintStringXA
.8753	a9 0d		lda #$0d			lda 	#13 						; new line
.8755	20 c5 a7	jsr $a7c5			jsr 	EXTPrintCharacter
.8758					_CLNext:
.8758	18		clc				clc
.8759	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.875b	65 30		adc $30				adc 	codePtr
.875d	85 30		sta $30				sta 	codePtr
.875f	90 02		bcc $8763			bcc 	_CREExit
.8761	e6 31		inc $31				inc 	codePtr+1
.8763					_CREExit:
.8763	80 c8		bra $872d			bra 	_CLLoop
.8765					_CLExit:
.8765	4c 58 83	jmp $8358			jmp 	WarmStart
.8768					CLCompareLineNo:
.8768	38		sec				sec
.8769	a0 01		ldy #$01			ldy 	#1
.876b	b1 30		lda ($30),y			lda 	(codePtr),y
.876d	fd 08 04	sbc $0408,x			sbc 	NSMantissa0,x
.8770	85 36		sta $36				sta 	zTemp0
.8772	c8		iny				iny
.8773	b1 30		lda ($30),y			lda 	(codePtr),y
.8775	fd 10 04	sbc $0410,x			sbc 	NSMantissa1,x
.8778	05 36		ora $36				ora 	zTemp0
.877a	60		rts				rts
.877b					CLIsDigit:
.877b	b1 30		lda ($30),y			lda 	(codePtr),y
.877d	c9 30		cmp #$30			cmp 	#"0"
.877f	90 03		bcc $8784			bcc	 	_CLIDExitFalse
.8781	c9 3a		cmp #$3a			cmp 	#"9"+1
.8783	60		rts				rts
.8784					_CLIDExitFalse:
.8784	38		sec				sec
.8785	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/local.asm

.8786					Command_LOCAL:
.8786	a2 00		ldx #$00			ldx 	#0 							; at level 0
.8788	20 94 87	jsr $8794			jsr 	LocaliseNextTerm 			; convert term to a local.
.878b	b1 30		lda ($30),y			lda 	(codePtr),y
.878d	c8		iny				iny
.878e	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8790	f0 f4		beq $8786			beq 	Command_LOCAL
.8792	88		dey				dey 								; unpick pre-get
.8793	60		rts				rts
.8794					LocaliseNextTerm:
.8794	20 f2 97	jsr $97f2			jsr 	EvaluateTerm 				; evaluate the term
.8797	bd 00 04	lda $0400,x			lda 	NSStatus,x
.879a	29 20		and #$20			and 	#NSBIsReference 			; check it is a reference
.879c	f0 61		beq $87ff			beq		_LNTError
.879e	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address of variable to zTemp0
.87a1	85 36		sta $36				sta 	zTemp0
.87a3	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.87a6	85 37		sta $37				sta  	zTemp0+1
.87a8	bd 00 04	lda $0400,x			lda 	NSStatus,x
.87ab	29 10		and #$10			and 	#NSBIsString
.87ad	d0 1e		bne $87cd			bne 	_LNTPushString
.87af	5a		phy				phy
.87b0	a0 00		ldy #$00			ldy 	#0 							; push 0 to 4 inclusive, the number values, on the stack, and zero them as you go.
.87b2					_LNTPushNumLoop:
.87b2	b1 36		lda ($36),y			lda		(zTemp0),y
.87b4	20 63 a6	jsr $a663			jsr 	StackPushByte
.87b7	c8		iny				iny
.87b8	c0 05		cpy #$05			cpy 	#5
.87ba	d0 f6		bne $87b2			bne 	_LNTPushNumLoop
.87bc	a5 36		lda $36				lda 	zTemp0 						; push the actual target address to write on the stack
.87be	20 63 a6	jsr $a663			jsr 	StackPushByte
.87c1	a5 37		lda $37				lda 	zTemp0+1
.87c3	20 63 a6	jsr $a663			jsr 	StackPushByte
.87c6	a9 01		lda #$01			lda 	#STK_LOCALN 				; push local-number marker.
.87c8	20 63 a6	jsr $a663			jsr 	StackPushByte
.87cb	7a		ply				ply
.87cc	60		rts				rts
.87cd					_LNTPushString:
.87cd	5a		phy				phy
.87ce	b2 36		lda ($36)			lda 	(zTemp0) 					; put address of string in zTemp1
.87d0	85 38		sta $38				sta 	zTemp1
.87d2	a0 01		ldy #$01			ldy 	#1
.87d4	b1 36		lda ($36),y			lda 	(zTemp0),y
.87d6	85 39		sta $39				sta 	zTemp1+1
.87d8	a0 00		ldy #$00			ldy 	#0 							; output string
.87da	c9 00		cmp #$00			cmp 	#0 							; if not assigned strin
.87dc	f0 0a		beq $87e8			beq 	_LNTStringOut
.87de					_LNTPushStrLoop:
.87de	b1 38		lda ($38),y			lda 	(zTemp1),y
.87e0	f0 06		beq $87e8			beq 	_LNTStringOut
.87e2	20 63 a6	jsr $a663			jsr 	StackPushByte
.87e5	c8		iny				iny
.87e6	80 f6		bra $87de			bra 	_LNTPushStrLoop
.87e8					_LNTStringOut:
.87e8	98		tya				tya									; output length
.87e9	20 63 a6	jsr $a663			jsr 	StackPushByte
.87ec	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; output address of the string record *not* the string itself
.87ef	20 63 a6	jsr $a663			jsr 	StackPushByte
.87f2	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.87f5	20 63 a6	jsr $a663			jsr 	StackPushByte
.87f8	a9 02		lda #$02			lda 	#STK_LOCALS 				; push local-string marker.
.87fa	20 63 a6	jsr $a663			jsr 	StackPushByte
.87fd	7a		ply				ply
.87fe	60		rts				rts
.87ff					_LNTError:
.87ff	4c b6 9f	jmp $9fb6			jmp 	SyntaxError
.8802					LocalPopValue:
.8802	20 7c a6	jsr $a67c			jsr 	StackPopByte
.8805	c9 01		cmp #$01			cmp 	#STK_LOCALN 				; if not local-N
.8807	d0 17		bne $8820			bne 	_LPVString
.8809	20 7c a6	jsr $a67c			jsr 	StackPopByte 				; address
.880c	85 37		sta $37				sta 	zTemp0+1
.880e	20 7c a6	jsr $a67c			jsr 	StackPopByte
.8811	85 36		sta $36				sta 	zTemp0
.8813	5a		phy				phy
.8814	a0 04		ldy #$04			ldy 	#4 							; copy back
.8816					_LPVNumberCopy:
.8816	20 7c a6	jsr $a67c			jsr 	StackPopByte
.8819	91 36		sta ($36),y			sta 	(zTemp0),y
.881b	88		dey				dey
.881c	10 f8		bpl $8816			bpl 	_LPVNumberCopy
.881e	7a		ply				ply 								; and complete
.881f	60		rts				rts
.8820					_LPVString:
.8820	20 7c a6	jsr $a67c			jsr 	StackPopByte 				; address of record => zTemp0
.8823	85 37		sta $37				sta 	zTemp0+1
.8825	20 7c a6	jsr $a67c			jsr 	StackPopByte
.8828	85 36		sta $36				sta 	zTemp0
.882a	5a		phy				phy
.882b	b2 36		lda ($36)			lda 	(zTemp0) 					; address to write string to => zTemp1
.882d	85 38		sta $38				sta 	zTemp1
.882f	a0 01		ldy #$01			ldy 	#1
.8831	b1 36		lda ($36),y			lda 	(zTemp0),y
.8833	85 39		sta $39				sta 	zTemp1+1
.8835	20 7c a6	jsr $a67c			jsr 	StackPopByte 				; # to get => y
.8838	a8		tay				tay
.8839	a5 39		lda $39				lda 	zTemp1+1 					; if no target (e.g. was "" originally) exit
.883b	f0 0e		beq $884b			beq 	_LPVStringCopied
.883d	a9 00		lda #$00			lda 	#0 							; NULL on end
.883f	91 38		sta ($38),y			sta 	(zTemp1),y
.8841					_LPVStringCopy:
.8841	88		dey				dey
.8842	30 07		bmi $884b			bmi 	_LPVStringCopied
.8844	20 7c a6	jsr $a67c			jsr 	StackPopByte
.8847	91 38		sta ($38),y			sta 	(zTemp1),y
.8849	80 f6		bra $8841			bra 	_LPVStringCopy
.884b					_LPVStringCopied:
.884b	fa		plx				plx
.884c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/new.asm

.884d					NewCommand:
.884d	20 53 88	jsr $8853			jsr 	NewProgram
.8850	4c 58 83	jmp $8358			jmp 	WarmStart
.8853					NewProgram:
.8853	20 a3 a5	jsr $a5a3			jsr 	MemoryNew
.8856	9c 00 10	stz $1000			stz 	VariableSpace 				; erase all variables.
.8859	20 f1 83	jsr $83f1			jsr 	ClearCommand 				; clear everything.
.885c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/print.asm

.885d					Command_Print:
.885d	18		clc				clc 								; carry being clear means last print wasn't comma/semicolon
.885e					_CPLoop:
.885e	08		php				php 								; save last action flag
.885f	b1 30		lda ($30),y			lda 	(codePtr),y
.8861	c9 80		cmp #$80			cmp  	#KWC_EOL 					; end of line or colon, exit now.
.8863	f0 46		beq $88ab			beq 	_CPExit
.8865	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.8867	f0 42		beq $88ab			beq 	_CPExit
.8869	68		pla				pla 								; throw last action flag
.886a	b1 30		lda ($30),y			lda 	(codePtr),y
.886c	c8		iny				iny
.886d	c9 3b		cmp #$3b			cmp 	#KWD_SEMICOLON				; is it a semicolon
.886f	f0 37		beq $88a8			beq 	_CPContinueWithSameLine
.8871	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; comma
.8873	f0 2e		beq $88a3			beq 	_CPTab
.8875	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; apostrophe (new line)
.8877	f0 26		beq $889f			beq 	_CPNewLine
.8879	88		dey				dey 								; undo the get.
.887a	a2 00		ldx #$00			ldx 	#0
.887c	20 4c 9d	jsr $9d4c			jsr 	EvaluateValue 				; get a value into slot 0
.887f	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; is it a number
.8882	29 10		and #$10			and 	#NSBIsString
.8884	f0 0b		beq $8891			beq 	_CPNumber
.8886	ae 10 04	ldx $0410			ldx 	NSMantissa1 				; string, print the text.
.8889	ad 08 04	lda $0408			lda 	NSMantissa0
.888c	20 b4 88	jsr $88b4			jsr 	CPPrintStringXA
.888f	80 cc		bra $885d			bra 	Command_Print 				; loop round clearing carry so NL if end
.8891					_CPNumber:
.8891	a9 05		lda #$05			lda 	#5 							; maximum decimals
.8893	20 22 9c	jsr $9c22			jsr 	ConvertNumberToString 		; convert to string
.8896	a2 06		ldx #$06			ldx 	#DecimalBuffer >> 8
.8898	a9 1b		lda #$1b			lda 	#DecimalBuffer & $FF
.889a	20 b4 88	jsr $88b4			jsr 	CPPrintStringXA
.889d	80 be		bra $885d			bra 	Command_Print 				; loop round clearing carry so NL if end
.889f					_CPNewLine:
.889f	a9 0d		lda #$0d			lda 	#13
.88a1	80 02		bra $88a5			bra 	_CPPrintChar
.88a3					_CPTab:
.88a3	a9 09		lda #$09			lda 	#9 							; print TAB
.88a5					_CPPrintChar:
.88a5	20 c7 88	jsr $88c7			jsr 	CPPrintVector
.88a8					_CPContinueWithSameLine:
.88a8	38		sec				sec 								; loop round with carry set, which
.88a9	80 b3		bra $885e			bra 	_CPLoop 					; will inhibit final CR
.88ab					_CPExit:
.88ab	28		plp				plp 								; get last action flag
.88ac	b0 05		bcs $88b3			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.88ae	a9 0d		lda #$0d			lda 	#13 						; print new line
.88b0	20 c7 88	jsr $88c7			jsr 	CPPrintVector
.88b3					_CPExit2:
.88b3	60		rts				rts
.88b4					CPPrintStringXA:
.88b4	5a		phy				phy
.88b5	86 37		stx $37				stx 	zTemp0+1
.88b7	85 36		sta $36				sta 	zTemp0
.88b9	a0 00		ldy #$00			ldy 	#0
.88bb					_PSXALoop:
.88bb	b1 36		lda ($36),y			lda 	(zTemp0),y
.88bd	f0 06		beq $88c5			beq 	_PSXAExit
.88bf	20 c7 88	jsr $88c7			jsr 	CPPrintVector
.88c2	c8		iny				iny
.88c3	80 f6		bra $88bb			bra 	_PSXALoop
.88c5					_PSXAExit:
.88c5	7a		ply				ply
.88c6	60		rts				rts
.88c7					CPPrintVector:
.88c7	4c c5 a7	jmp $a7c5			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/procedure.asm

=2					ParameterStackPos = 2
.88ca					CallProcedure:
.88ca	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start storing parameters at 2.
.88cc	b1 30		lda ($30),y			lda 	(codePtr),y
.88ce	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.88d0	f0 0c		beq $88de			beq 	_CPEndParam
.88d2					_CPParamLoop:
.88d2	20 4c 9d	jsr $9d4c			jsr 	EvaluateValue 				; get parameter onto stack
.88d5	e8		inx				inx 								; bump next stack
.88d6	b1 30		lda ($30),y			lda 	(codePtr),y
.88d8	c8		iny				iny
.88d9	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if comma, go back and try again.
.88db	f0 f5		beq $88d2			beq 	_CPParamLoop
.88dd	88		dey				dey 								; unpick.
.88de					_CPEndParam:
.88de	8e 96 04	stx $0496			stx 	LastParameter 				; save the last parameters index.
.88e1	c8		iny				iny									; skip right bracket
.88e2	a9 b3		lda #$b3			lda 	#STK_PROC+3 				; allocate 6 bytes on the return stack.
.88e4	20 85 a6	jsr $a685			jsr 	StackOpen
.88e7	20 c9 a6	jsr $a6c9			jsr 	STKSaveCodePosition 		; save loop position
.88ea	ad 08 04	lda $0408			lda 	NSMantissa0 				; copy variable (e.g. procedure) address to zTemp0
.88ed	85 36		sta $36				sta 	zTemp0 						; this is the DATA not the RECORD
.88ef	ad 10 04	lda $0410			lda 	NSMantissa1
.88f2	85 37		sta $37				sta 	zTemp0+1
.88f4	a0 01		ldy #$01			ldy 	#1 							; copy code address back.
.88f6	b2 36		lda ($36)			lda 	(zTemp0)
.88f8	85 30		sta $30				sta 	safePtr
.88fa	b1 36		lda ($36),y			lda 	(zTemp0),y
.88fc	85 31		sta $31				sta 	safePtr+1
.88fe	c8		iny				iny
.88ff	b1 36		lda ($36),y			lda 	(zTemp0),y
.8901	85 32		sta $32				sta 	safePtr+2
.8903	c8		iny				iny
.8904	b1 36		lda ($36),y			lda 	(zTemp0),y
.8906	85 33		sta $33				sta 	safePtr+3
.8908	c8		iny				iny 								; get Y offset -> Y
.8909	b1 36		lda ($36),y			lda 	(zTemp0),y
.890b	a8		tay				tay
.890c	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start position of parameters
.890e	ec 96 04	cpx $0496			cpx	 	LastParameter 				; check no parameters at the start
.8911	f0 13		beq $8926			beq 	_ParamExit 					; if so, exit.
.8913					_ParamExtract:
.8913	ca		dex				dex 								; put a local term on the level before
.8914	20 94 87	jsr $8794			jsr 	LocaliseNextTerm			; also pushes original param value to basic stack
.8917	20 cc 86	jsr $86cc			jsr 	AssignVariable 				; assign stacked value to the variable.
.891a	e8		inx				inx 								; advance to next parameter to do.
.891b	e8		inx				inx
.891c	ec 96 04	cpx $0496			cpx 	LastParameter 				; are we done ?
.891f	f0 05		beq $8926			beq 	_ParamExit
.8921	20 58 8d	jsr $8d58			jsr 	CheckComma 					; comma seperating parameters
.8924	80 ed		bra $8913			bra 	_ParamExtract
.8926					_ParamExit:
.8926	20 50 8d	jsr $8d50			jsr 	CheckRightBracket 			; check )
.8929	60		rts				rts 								; and continue from here
.892a					Command_ENDPROC:
.892a	a9 b0		lda #$b0			lda 	#STK_PROC 					; check TOS is this
.892c	a2 14		ldx #$14			ldx 	#ERRID_PROC
.892e	20 b1 a6	jsr $a6b1			jsr 	StackCheckFrame
.8931	20 da a6	jsr $a6da			jsr 	STKLoadCodePosition 		; restore code position
.8934	20 a3 a6	jsr $a6a3			jsr 	StackClose
.8937	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/read.asm

.8938					Command_Read:
.8938	a2 00		ldx #$00			ldx 	#0 							; evaluate the term which is the var/array element to assign
.893a	20 f2 97	jsr $97f2			jsr 	EvaluateTerm
.893d	bd 00 04	lda $0400,x			lda 	NSStatus,x
.8940	29 20		and #$20			and 	#NSBIsReference				; get status byte on stack, identifies int, float, string.
.8942	f0 4a		beq $898e			beq 	_CRSyntax 					; check reference (bit 0)
.8944	20 d7 89	jsr $89d7			jsr 	SwapDataCodePtrs 			; swap code and data
.8947	ad 9c 04	lda $049c			lda 	inDataStatement 			; if in a data statement, we don't need to search
.894a	d0 20		bne $896c			bne 	_CRContinueData
.894c					_CRKeepSearching:
.894c	a9 b2		lda #$b2			lda 	#KWD_DATA 					; scan for instruction
.894e	aa		tax				tax
.894f	20 ab 8c	jsr $8cab			jsr 	ScanForward
.8952	c9 b2		cmp #$b2			cmp 	#KWD_DATA 					; found data ?
.8954	f0 16		beq $896c			beq 	_CRHaveData 				; found it
.8956	18		clc				clc
.8957	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.8959	65 30		adc $30				adc 	codePtr
.895b	85 30		sta $30				sta 	codePtr
.895d	90 02		bcc $8961			bcc 	_CREExit
.895f	e6 31		inc $31				inc 	codePtr+1
.8961					_CREExit:
.8961	a0 03		ldy #$03			ldy 	#3 							; start of line.
.8963	b2 30		lda ($30)			lda 	(codePtr)
.8965	d0 e5		bne $894c			bne 	_CRKeepSearching
.8967	a9 0b		lda #$0b		lda	#11
.8969	4c 69 8d	jmp $8d69		jmp	ErrorHandler
.896c					_CRHaveData:
.896c					_CRContinueData:
.896c	a2 01		ldx #$01			ldx 	#1
.896e	20 4c 9d	jsr $9d4c			jsr 	EvaluateValue 				; evaluate value into slot # 1
.8971	ca		dex				dex
.8972	20 cc 86	jsr $86cc			jsr		AssignVariable 				; do the assignment
.8975	9c 9c 04	stz $049c			stz 	inDataStatement 			; clear in data
.8978	b1 30		lda ($30),y			lda 	(codePtr),y
.897a	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not, end of data statement
.897c	d0 04		bne $8982			bne 	_CRSwapBack
.897e	c8		iny				iny 								; consume comma
.897f	ee 9c 04	inc $049c			inc 	inDataStatement 			; set in data statement currently.
.8982					_CRSwapBack:
.8982	20 d7 89	jsr $89d7			jsr 	SwapDataCodePtrs			; swap them back.
.8985	b1 30		lda ($30),y			lda 	(codePtr),y
.8987	c8		iny				iny
.8988	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.898a	f0 ac		beq $8938			beq 	Command_Read 				; if so go round again.
.898c	88		dey				dey 								; unpick get.
.898d	60		rts				rts
.898e					_CRSyntax:
.898e	4c b6 9f	jmp $9fb6			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/rem.asm

.8991					RemCommand:
.8991	b1 30		lda ($30),y			lda 	(codePtr),y
.8993	c9 ff		cmp #$ff			cmp 	#KWC_STRING
.8995	d0 06		bne $899d			bne 	_RMExit
.8997	c8		iny				iny
.8998	98		tya				tya
.8999	38		sec				sec
.899a	71 30		adc ($30),y			adc 	(codePtr),y
.899c	a8		tay				tay
.899d					_RMExit:
.899d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/repeat.asm

.899e					Command_REPEAT:
.899e	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; allocate 6 bytes on the return stack.
.89a0	20 85 a6	jsr $a685			jsr 	StackOpen
.89a3	20 c9 a6	jsr $a6c9			jsr 	STKSaveCodePosition 		; save loop position
.89a6	60		rts				rts
.89a7					Command_UNTIL:
.89a7	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; check REPEAT is TOS
.89a9	a2 0f		ldx #$0f			ldx 	#ERRID_REPEAT 				; this error
.89ab	20 b1 a6	jsr $a6b1			jsr 	StackCheckFrame
.89ae	a2 00		ldx #$00			ldx 	#0
.89b0	20 55 9d	jsr $9d55			jsr 	EvaluateNumber 				; work out the number
.89b3	20 5c 9e	jsr $9e5c			jsr 	NSMIsZero 					; check if zero
.89b6	f0 04		beq $89bc			beq 	_CULoopBack 				; if so keep looping
.89b8	20 a3 a6	jsr $a6a3			jsr 	StackClose		 			; return
.89bb	60		rts				rts
.89bc					_CULoopBack:
.89bc	20 da a6	jsr $a6da			jsr 	STKLoadCodePosition 		; loop back
.89bf	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/restore.asm

.89c0					Command_Restore:
.89c0	20 d7 89	jsr $89d7			jsr 	SwapDataCodePtrs 			; swap code and data
.89c3	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.89c5	85 30		sta $30				sta 	codePtr
.89c7	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.89c9	85 31		sta $31				sta 	codePtr+1
.89cb	20 d7 89	jsr $89d7			jsr 	SwapDataCodePtrs 			; put them back
.89ce	a9 03		lda #$03			lda 	#3 							; start at offset 3, e.g. first instruction of first line.
.89d0	8d 9b 04	sta $049b			sta 	dataPointer+4
.89d3	9c 9c 04	stz $049c			stz 	inDataStatement 			; not in data statement
.89d6	60		rts				rts
.89d7					SwapDataCodePtrs:
.89d7	da		phx				phx
.89d8	a2 03		ldx #$03			ldx 	#3 							; swap 32 bit code pointer over
.89da					_SDCPLoop:
.89da	b5 30		lda $30,x			lda 	safePtr,x
.89dc	48		pha				pha
.89dd	bd 97 04	lda $0497,x			lda 	dataPointer,x
.89e0	95 30		sta $30,x			sta 	safePtr,x
.89e2	68		pla				pla
.89e3	9d 97 04	sta $0497,x			sta 	dataPointer,x
.89e6	ca		dex				dex
.89e7	10 f1		bpl $89da			bpl 	_SDCPLoop
.89e9	ad 9b 04	lda $049b			lda 	dataPointer+4 				; swap Y position over.
.89ec	8c 9b 04	sty $049b			sty 	dataPointer+4
.89ef	a8		tay				tay
.89f0	fa		plx				plx
.89f1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/run.asm

.89f2					EOLCommand:
.89f2	18		clc				clc
.89f3	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.89f5	65 30		adc $30				adc 	codePtr
.89f7	85 30		sta $30				sta 	codePtr
.89f9	90 02		bcc $89fd			bcc 	_CREExit
.89fb	e6 31		inc $31				inc 	codePtr+1
.89fd					_CREExit:
.89fd	80 0b		bra $8a0a			bra 	RunNewLine
.89ff					CommandRUN:
.89ff	20 f1 83	jsr $83f1			jsr 	ClearCommand 				; clear variable/stacks/etc.
.8a02	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8a04	85 30		sta $30				sta 	codePtr
.8a06	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8a08	85 31		sta $31				sta 	codePtr+1
.8a0a					RUNNewLine:
.8a0a	b2 30		lda ($30)			lda 	(codePtr)
.8a0c	f0 72		beq $8a80			beq 	CRNoProgram         		; no then END.
.8a0e	a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack
.8a10	9a		txs				txs
.8a11					RUNCodePointerLine:
.8a11	a0 02		ldy #$02			ldy 	#2 							; start of program
.8a13					_CRIncMainLoop:
.8a13	0e 93 04	asl $0493			asl 	breakCheck 					; clears 1 time in 8
.8a16	d0 19		bne $8a31			bne 	_CRNoBreakCheck
.8a18	20 7b aa	jsr $aa7b			jsr 	EXTBreakCheck 				; break check
.8a1b	f0 5e		beq $8a7b			beq 	_CRBreak
.8a1d	64 01		stz $01				stz 	1 							; access I/O Page 0
.8a1f	38		sec				sec 								; calculate timer - LastTick
.8a20	ad 59 d6	lda $d659			lda 	$D659
.8a23	aa		tax				tax 								; saving timer in X
.8a24	ed 2d 06	sbc $062d			sbc 	LastTick
.8a27	c9 03		cmp #$03			cmp 	#3
.8a29	90 06		bcc $8a31			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.8a2b	8e 2d 06	stx $062d			stx 	LastTick 					; update last timer
.8a2e	20 db b9	jsr $b9db			jsr 	TickHandler 				; go do the code.
.8a31					_NoFireTick:
.8a31					_CRNoBreakCheck:
.8a31	c8		iny				iny
.8a32					_CRMainLoop:
.8a32	9c 90 04	stz $0490			stz 	stringInitialised 			; clear the temporary string initialised flag.
.8a35	b1 30		lda ($30),y			lda 	(codePtr),y
.8a37	10 10		bpl $8a49			bpl 	_CRNotKeyword
.8a39	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1 			; if after unary, legitimate command
.8a3b	b0 04		bcs $8a41			bcs 	_CRIsKeyword
.8a3d	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if unary, syntax error.
.8a3f	b0 34		bcs $8a75			bcs		_CRSyntaxError
.8a41					_CRIsKeyword:
.8a41	c8		iny				iny 								; consume command
.8a42	0a		asl a				asl 	a 							; double losing the MSB which is '1' as tokens are $80-$FF
.8a43	aa		tax				tax 								; put in X for vector jump
.8a44	20 78 8a	jsr $8a78			jsr 	_CRCallVector0 				; call the vector - effectively jsr (vectortable,X)
.8a47	80 e9		bra $8a32			bra 	_CRMainLoop 				; and loop round
.8a49					_CRNotKeyword:
.8a49	c9 3a		cmp #$3a			cmp 	#KWD_COLON 					; if a :, consume it and go round.
.8a4b	f0 c6		beq $8a13			beq 	_CRIncMainLoop
.8a4d	c9 40		cmp #$40			cmp 	#$40 						; variable/call reference
.8a4f	90 05		bcc $8a56			bcc 	_CRNotVariable
.8a51					_CRGoLet:
.8a51	20 90 86	jsr $8690			jsr 	LetCommand
.8a54	80 dc		bra $8a32			bra 	_CRMainLoop
.8a56					_CRNotVariable:
.8a56	c9 10		cmp #$10			cmp 	#KWD_AT 					; handle @
.8a58	f0 f7		beq $8a51			beq 	_CRGoLet
.8a5a	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; handle ? !
.8a5c	f0 f3		beq $8a51			beq 	_CRGoLet
.8a5e	c9 21		cmp #$21			cmp 	#KWD_PLING
.8a60	f0 ef		beq $8a51			beq 	_CRGoLet
.8a62	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; handle ' (comment)
.8a64	f0 09		beq $8a6f			beq 	_CRGoRem
.8a66	c9 2e		cmp #$2e			cmp 	#KWD_PERIOD 				; handle . (assembler label)
.8a68	d0 0b		bne $8a75			bne 	_CRSyntaxError
.8a6a	20 11 82	jsr $8211			jsr 	LabelHere
.8a6d	80 c3		bra $8a32			bra 	_CRMainLoop
.8a6f					_CRGoRem:
.8a6f	c8		iny				iny
.8a70	20 91 89	jsr $8991			jsr 	RemCommand
.8a73	80 bd		bra $8a32			bra 	_CRMainLoop
.8a75					_CRSyntaxError:
.8a75	4c b6 9f	jmp $9fb6			jmp 	SyntaxError
.8a78					_CRCallVector0:
.8a78	7c 16 8b	jmp ($8b16,x)			jmp 	(VectorSet0,x)
.8a7b					_CRBreak:
.8a7b	a9 01		lda #$01		lda	#1
.8a7d	4c 69 8d	jmp $8d69		jmp	ErrorHandler
.8a80					CRNoProgram:
.8a80	4c 16 85	jmp $8516			jmp 	EndCommand
.8a83					Shift1Command:
.8a83	b1 30		lda ($30),y			lda 	(codePtr),y
.8a85	c8		iny				iny
.8a86	0a		asl a				asl 	a
.8a87	aa		tax				tax
.8a88	7c b2 8b	jmp ($8bb2,x)			jmp 	(VectorSet1,x)
.8a8b					Shift2Command:
.8a8b	b1 30		lda ($30),y			lda 	(codePtr),y
.8a8d	c8		iny				iny
.8a8e	0a		asl a				asl 	a
.8a8f	aa		tax				tax
.8a90	7c cc 8b	jmp ($8bcc,x)			jmp 	(VectorSet2,x)
.8a93					Unused1:
.8a93					Unused2:
.8a93					Unused3:
.8a93					Unused4:
.8a93	4c b6 9f	jmp $9fb6			jmp 	SyntaxError
>8a96							.align 2

;******  Processing file: ./common/commands/../generated/vectors.dat

.8a96					VectorSetPunc:
>8a96	56 90					.word	ShiftLeft                        ; $00 <<
>8a98	0d 8e					.word	BinaryCompareLessEqual           ; $01 <=
>8a9a	03 8e					.word	BinaryCompareNotEqual            ; $02 <>
>8a9c	b6 9f					.word	SyntaxError                      ; $03 !!3
>8a9e	b6 9f					.word	SyntaxError                      ; $04 ><
>8aa0	17 8e					.word	BinaryCompareGreaterEqual        ; $05 >=
>8aa2	59 90					.word	ShiftRight                       ; $06 >>
>8aa4	b6 9f					.word	SyntaxError                      ; $07 !!7
>8aa6	b6 9f					.word	SyntaxError                      ; $08 !!8
>8aa8	b6 9f					.word	SyntaxError                      ; $09 !!9
>8aaa	b6 9f					.word	SyntaxError                      ; $0a !!10
>8aac	b6 9f					.word	SyntaxError                      ; $0b !!11
>8aae	b6 9f					.word	SyntaxError                      ; $0c !!12
>8ab0	b6 9f					.word	SyntaxError                      ; $0d !!13
>8ab2	b6 9f					.word	SyntaxError                      ; $0e !!14
>8ab4	b6 9f					.word	SyntaxError                      ; $0f !!15
>8ab6	b6 9f					.word	SyntaxError                      ; $10 @
>8ab8	b6 9f					.word	SyntaxError                      ; $11 !!17
>8aba	b6 9f					.word	SyntaxError                      ; $12 !!18
>8abc	b6 9f					.word	SyntaxError                      ; $13 [
>8abe	da 8e					.word	IntegerDivide                    ; $14 \
>8ac0	b6 9f					.word	SyntaxError                      ; $15 ]
>8ac2	e7 91					.word	EorInteger                       ; $16 ^
>8ac4	b6 9f					.word	SyntaxError                      ; $17 _
>8ac6	b6 9f					.word	SyntaxError                      ; $18 `
>8ac8	b6 9f					.word	SyntaxError                      ; $19 !!25
>8aca	b6 9f					.word	SyntaxError                      ; $1a !!26
>8acc	b6 9f					.word	SyntaxError                      ; $1b {
>8ace	a1 91					.word	OraInteger                       ; $1c |
>8ad0	b6 9f					.word	SyntaxError                      ; $1d }
>8ad2	b6 9f					.word	SyntaxError                      ; $1e ~
>8ad4	b6 9f					.word	SyntaxError                      ; $1f [7m<7F>[m
>8ad6	b6 9f					.word	SyntaxError                      ; $20
>8ad8	2d 92					.word	WordIndirect                     ; $21 !
>8ada	b6 9f					.word	SyntaxError                      ; $22 "
>8adc	b6 9f					.word	SyntaxError                      ; $23 #
>8ade	b6 9f					.word	SyntaxError                      ; $24 $
>8ae0	27 8f					.word	IntegerModulus                   ; $25 %
>8ae2	5b 91					.word	AndInteger                       ; $26 &
>8ae4	b6 9f					.word	SyntaxError                      ; $27 '
>8ae6	b6 9f					.word	SyntaxError                      ; $28 (
>8ae8	b6 9f					.word	SyntaxError                      ; $29 )
>8aea	9c 8f					.word	MulInteger                       ; $2a *
>8aec	ed 90					.word	AddInteger                       ; $2b +
>8aee	b6 9f					.word	SyntaxError                      ; $2c ,
>8af0	30 91					.word	SubInteger                       ; $2d -
>8af2	b6 9f					.word	SyntaxError                      ; $2e .
>8af4	18 94					.word	FDivideCommand                   ; $2f /
>8af6	b6 9f					.word	SyntaxError                      ; $30 0
>8af8	b6 9f					.word	SyntaxError                      ; $31 1
>8afa	b6 9f					.word	SyntaxError                      ; $32 2
>8afc	b6 9f					.word	SyntaxError                      ; $33 3
>8afe	b6 9f					.word	SyntaxError                      ; $34 4
>8b00	b6 9f					.word	SyntaxError                      ; $35 5
>8b02	b6 9f					.word	SyntaxError                      ; $36 6
>8b04	b6 9f					.word	SyntaxError                      ; $37 7
>8b06	b6 9f					.word	SyntaxError                      ; $38 8
>8b08	b6 9f					.word	SyntaxError                      ; $39 9
>8b0a	b6 9f					.word	SyntaxError                      ; $3a :
>8b0c	b6 9f					.word	SyntaxError                      ; $3b ;
>8b0e	ef 8d					.word	BinaryCompareLess                ; $3c <
>8b10	e5 8d					.word	BinaryCompareEqual               ; $3d =
>8b12	f9 8d					.word	BinaryCompareGreater             ; $3e >
>8b14	54 92					.word	ByteIndirect                     ; $3f ?
.8b16					VectorSet0:
>8b16	f2 89					.word	EOLCommand                       ; $80 !0:EOF
>8b18	83 8a					.word	Shift1Command                    ; $81 !1:SH1
>8b1a	8b 8a					.word	Shift2Command                    ; $82 !2:SH2
>8b1c	88 99					.word	AbsUnary                         ; $83 ABS(
>8b1e	98 99					.word	AllocUnary                       ; $84 ALLOC(
>8b20	08 9a					.word	AscUnary                         ; $85 ASC(
>8b22	d3 9b					.word	ChrUnary                         ; $86 CHR$(
>8b24	26 a4					.word	UnaryEvent                       ; $87 EVENT(
>8b26	e1 8d					.word	UnaryFalse                       ; $88 FALSE
>8b28	15 9a					.word	FracUnary                        ; $89 FRAC(
>8b2a	bc a3					.word	UnaryHit                         ; $8a HIT(
>8b2c	2b 9a					.word	IntUnary                         ; $8b INT(
>8b2e	92 9b					.word	IsValUnary                       ; $8c ISVAL(
>8b30	b6 a4					.word	UnaryJoyB                        ; $8d JOYB(
>8b32	8f a4					.word	UnaryJoyX                        ; $8e JOYX(
>8b34	92 a4					.word	UnaryJoyY                        ; $8f JOYY(
>8b36	ad 9c					.word	Unary_Left                       ; $90 LEFT$(
>8b38	3d 9a					.word	LenUnary                         ; $91 LEN(
>8b3a	5b 9a					.word	Unary_Max                        ; $92 MAX(
>8b3c	d7 9c					.word	Unary_Mid                        ; $93 MID$(
>8b3e	57 9a					.word	Unary_Min                        ; $94 MIN(
>8b40	b2 9a					.word	Unary_Not                        ; $95 NOT(
>8b42	b6 9f					.word	SyntaxError                      ; $96 PLAYING(
>8b44	c8 9a					.word	Unary_Random                     ; $97 RANDOM(
>8b46	bd 9c					.word	Unary_Right                      ; $98 RIGHT$(
>8b48	e7 9a					.word	Unary_Rnd                        ; $99 RND(
>8b4a	68 9b					.word	SgnUnary                         ; $9a SGN(
>8b4c	e5 9b					.word	SpcUnary                         ; $9b SPC(
>8b4e	00 9c					.word	Unary_Str                        ; $9c STR$(
>8b50	ca a4					.word	UnaryTimer                       ; $9d TIMER(
>8b52	d5 8d					.word	UnaryTrue                        ; $9e TRUE
>8b54	88 9b					.word	ValUnary                         ; $9f VAL(
>8b56	19 85					.word	ForCommand                       ; $a0 FOR
>8b58	66 86					.word	IfCommand                        ; $a1 IF
>8b5a	93 8a					.word	Unused1                          ; $a2 PROC
>8b5c	9e 89					.word	Command_REPEAT                   ; $a3 REPEAT
>8b5e	21 8d					.word	Command_WHILE                    ; $a4 WHILE
>8b60	8f 86					.word	EndIf                            ; $a5 ENDIF
>8b62	2a 89					.word	Command_ENDPROC                  ; $a6 ENDPROC
>8b64	d3 85					.word	NextCommand                      ; $a7 NEXT
>8b66	93 8a					.word	Unused4                          ; $a8 THEN
>8b68	a7 89					.word	Command_UNTIL                    ; $a9 UNTIL
>8b6a	42 8d					.word	Command_WEND                     ; $aa WEND
>8b6c	b6 9f					.word	SyntaxError                      ; $ab BY
>8b6e	b7 83					.word	CallCommand                      ; $ac CALL
>8b70	5e a1					.word	CircleCommand                    ; $ad CIRCLE
>8b72	f1 83					.word	ClearCommand                     ; $ae CLEAR
>8b74	49 84					.word	ClearScreen                      ; $af CLS
>8b76	b6 9f					.word	SyntaxError                      ; $b0 COLOR
>8b78	b6 9f					.word	SyntaxError                      ; $b1 COLOUR
>8b7a	51 84					.word	Command_Data                     ; $b2 DATA
>8b7c	59 84					.word	DimCommand                       ; $b3 DIM
>8b7e	93 8a					.word	Unused3                          ; $b4 DOWNTO
>8b80	88 86					.word	ElseCode                         ; $b5 ELSE
>8b82	b6 9f					.word	SyntaxError                      ; $b6 FROM
>8b84	8a a3					.word	GfxCommand                       ; $b7 GFX
>8b86	2c 86					.word	Command_GOSUB                    ; $b8 GOSUB
>8b88	4a 86					.word	GotoCommand                      ; $b9 GOTO
>8b8a	b6 9f					.word	SyntaxError                      ; $ba HERE
>8b8c	88 a1					.word	ImageCommand                     ; $bb IMAGE
>8b8e	90 86					.word	LetCommand                       ; $bc LET
>8b90	dd a1					.word	LineCommand                      ; $bd LINE
>8b92	86 87					.word	Command_LOCAL                    ; $be LOCAL
>8b94	b6 9f					.word	SyntaxError                      ; $bf OFF
>8b96	b6 9f					.word	SyntaxError                      ; $c0 ON
>8b98	b6 9f					.word	SyntaxError                      ; $c1 OUTLINE
>8b9a	e2 a3					.word	PaletteCommand                   ; $c2 PALETTE
>8b9c	d6 a1					.word	PlotCommand                      ; $c3 PLOT
>8b9e	5d 88					.word	Command_Print                    ; $c4 PRINT
>8ba0	38 89					.word	Command_Read                     ; $c5 READ
>8ba2	5a a1					.word	RectangleCommand                 ; $c6 RECT
>8ba4	91 89					.word	RemCommand                       ; $c7 REM
>8ba6	3c 86					.word	Command_RETURN                   ; $c8 RETURN
>8ba8	b6 9f					.word	SyntaxError                      ; $c9 SOLID
>8baa	f8 a5					.word	SoundCommand                     ; $ca SOUND
>8bac	69 a1					.word	SpriteCommand                    ; $cb SPRITE
>8bae	a5 a1					.word	TextCommand                      ; $cc TEXT
>8bb0	93 8a					.word	Unused2                          ; $cd TO
.8bb2					VectorSet1:
>8bb2	b6 9f					.word	SyntaxError                      ; $80 !0:EOF
>8bb4	b6 9f					.word	SyntaxError                      ; $81 !1:SH1
>8bb6	b6 9f					.word	SyntaxError                      ; $82 !2:SH2
>8bb8	88 83					.word	AssembleCommand                  ; $83 ASSEMBLE
>8bba	a7 83					.word	AssertCommand                    ; $84 ASSERT
>8bbc	2a a3					.word	BitmapCtrl                       ; $85 BITMAP
>8bbe	16 85					.word	EndCommand                       ; $86 END
>8bc0	e5 86					.word	Command_List                     ; $87 LIST
>8bc2	4d 88					.word	NewCommand                       ; $88 NEW
>8bc4	c0 89					.word	Command_Restore                  ; $89 RESTORE
>8bc6	ff 89					.word	CommandRUN                       ; $8a RUN
>8bc8	6f a3					.word	SpritesCtrl                      ; $8b SPRITES
>8bca	54 8c					.word	StopCommand                      ; $8c STOP
.8bcc					VectorSet2:
>8bcc	b6 9f					.word	SyntaxError                      ; $80 !0:EOF
>8bce	b6 9f					.word	SyntaxError                      ; $81 !1:SH1
>8bd0	b6 9f					.word	SyntaxError                      ; $82 !2:SH2
>8bd2	75 9e					.word	Assemble_adc                     ; $83 ADC
>8bd4	6d 9e					.word	Assemble_and                     ; $84 AND
>8bd6	89 9e					.word	Assemble_asl                     ; $85 ASL
>8bd8	f3 9e					.word	Assemble_bcc                     ; $86 BCC
>8bda	f7 9e					.word	Assemble_bcs                     ; $87 BCS
>8bdc	ff 9e					.word	Assemble_beq                     ; $88 BEQ
>8bde	b6 9e					.word	Assemble_bit                     ; $89 BIT
>8be0	e7 9e					.word	Assemble_bmi                     ; $8a BMI
>8be2	fb 9e					.word	Assemble_bne                     ; $8b BNE
>8be4	e3 9e					.word	Assemble_bpl                     ; $8c BPL
>8be6	03 9f					.word	Assemble_bra                     ; $8d BRA
>8be8	07 9f					.word	Assemble_brk                     ; $8e BRK
>8bea	eb 9e					.word	Assemble_bvc                     ; $8f BVC
>8bec	ef 9e					.word	Assemble_bvs                     ; $90 BVS
>8bee	0f 9f					.word	Assemble_clc                     ; $91 CLC
>8bf0	63 9f					.word	Assemble_cld                     ; $92 CLD
>8bf2	23 9f					.word	Assemble_cli                     ; $93 CLI
>8bf4	53 9f					.word	Assemble_clv                     ; $94 CLV
>8bf6	81 9e					.word	Assemble_cmp                     ; $95 CMP
>8bf8	ca 9e					.word	Assemble_cpx                     ; $96 CPX
>8bfa	c5 9e					.word	Assemble_cpy                     ; $97 CPY
>8bfc	a7 9e					.word	Assemble_dec                     ; $98 DEC
>8bfe	5f 9f					.word	Assemble_dex                     ; $99 DEX
>8c00	3b 9f					.word	Assemble_dey                     ; $9a DEY
>8c02	71 9e					.word	Assemble_eor                     ; $9b EOR
>8c04	ac 9e					.word	Assemble_inc                     ; $9c INC
>8c06	6f 9f					.word	Assemble_inx                     ; $9d INX
>8c08	5b 9f					.word	Assemble_iny                     ; $9e INY
>8c0a	de 9e					.word	Assemble_jmp                     ; $9f JMP
>8c0c	d9 9e					.word	Assemble_jsr                     ; $a0 JSR
>8c0e	7d 9e					.word	Assemble_lda                     ; $a1 LDA
>8c10	a2 9e					.word	Assemble_ldx                     ; $a2 LDX
>8c12	c0 9e					.word	Assemble_ldy                     ; $a3 LDY
>8c14	93 9e					.word	Assemble_lsr                     ; $a4 LSR
>8c16	73 9f					.word	Assemble_nop                     ; $a5 NOP
>8c18	69 9e					.word	Assemble_ora                     ; $a6 ORA
>8c1a	1f 9f					.word	Assemble_pha                     ; $a7 PHA
>8c1c	0b 9f					.word	Assemble_php                     ; $a8 PHP
>8c1e	67 9f					.word	Assemble_phx                     ; $a9 PHX
>8c20	27 9f					.word	Assemble_phy                     ; $aa PHY
>8c22	2f 9f					.word	Assemble_pla                     ; $ab PLA
>8c24	13 9f					.word	Assemble_plp                     ; $ac PLP
>8c26	7b 9f					.word	Assemble_plx                     ; $ad PLX
>8c28	37 9f					.word	Assemble_ply                     ; $ae PLY
>8c2a	8e 9e					.word	Assemble_rol                     ; $af ROL
>8c2c	98 9e					.word	Assemble_ror                     ; $b0 ROR
>8c2e	1b 9f					.word	Assemble_rti                     ; $b1 RTI
>8c30	2b 9f					.word	Assemble_rts                     ; $b2 RTS
>8c32	85 9e					.word	Assemble_sbc                     ; $b3 SBC
>8c34	17 9f					.word	Assemble_sec                     ; $b4 SEC
>8c36	77 9f					.word	Assemble_sed                     ; $b5 SED
>8c38	33 9f					.word	Assemble_sei                     ; $b6 SEI
>8c3a	79 9e					.word	Assemble_sta                     ; $b7 STA
>8c3c	6b 9f					.word	Assemble_stp                     ; $b8 STP
>8c3e	9d 9e					.word	Assemble_stx                     ; $b9 STX
>8c40	bb 9e					.word	Assemble_sty                     ; $ba STY
>8c42	b1 9e					.word	Assemble_stz                     ; $bb STZ
>8c44	4f 9f					.word	Assemble_tax                     ; $bc TAX
>8c46	4b 9f					.word	Assemble_tay                     ; $bd TAY
>8c48	d4 9e					.word	Assemble_trb                     ; $be TRB
>8c4a	cf 9e					.word	Assemble_tsb                     ; $bf TSB
>8c4c	57 9f					.word	Assemble_tsx                     ; $c0 TSX
>8c4e	3f 9f					.word	Assemble_txa                     ; $c1 TXA
>8c50	47 9f					.word	Assemble_txs                     ; $c2 TXS
>8c52	43 9f					.word	Assemble_tya                     ; $c3 TYA

;******  Return to file: ./common/commands/run.asm


;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/stop.asm

.8c54					StopCommand:
.8c54	a9 08		lda #$08		lda	#8
.8c56	4c 69 8d	jmp $8d69		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/procscan.asm

.8c59					ProcedureScan:
.8c59	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8c5b	85 30		sta $30				sta 	codePtr
.8c5d	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8c5f	85 31		sta $31				sta 	codePtr+1
.8c61					_PSLoop:
.8c61	b2 30		lda ($30)			lda 	(codePtr)
.8c63	f0 42		beq $8ca7			beq 	_PSExit
.8c65	a0 03		ldy #$03			ldy 	#3 							; is it PROC ?
.8c67	b1 30		lda ($30),y			lda 	(codePtr),y
.8c69	c9 a2		cmp #$a2			cmp 	#KWD_PROC
.8c6b	d0 2d		bne $8c9a			bne 	_PSNext
.8c6d	c8		iny				iny 								; get the address of the record to zTemp0 and
.8c6e	b1 30		lda ($30),y			lda 	(codePtr),y
.8c70	29 c0		and #$c0			and 	#$C0
.8c72	c9 40		cmp #$40			cmp 	#$40
.8c74	d0 32		bne $8ca8			bne 	_PSSyntax
.8c76	b1 30		lda ($30),y			lda 	(codePtr),y
.8c78	18		clc				clc
.8c79	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8c7b	85 37		sta $37				sta 	zTemp0+1
.8c7d	c8		iny				iny 								; LSB
.8c7e	b1 30		lda ($30),y			lda 	(codePtr),y
.8c80	85 36		sta $36				sta 	zTemp0
.8c82	c8		iny				iny 								; character after variable call.
.8c83	98		tya				tya 								; save Y offset at +7
.8c84	a0 07		ldy #$07			ldy 	#7
.8c86	91 36		sta ($36),y			sta 	(zTemp0),y
.8c88	a9 18		lda #$18			lda 	#NSTProcedure 				; mark it as procedure
.8c8a	a0 02		ldy #$02			ldy 	#2
.8c8c	91 36		sta ($36),y			sta 	(zTemp0),y
.8c8e	a2 00		ldx #$00			ldx 	#0 							; copy code-Ptr in
.8c90					_PSCopy:
.8c90	b5 30		lda $30,x			lda 	safePtr,x
.8c92	c8		iny				iny
.8c93	91 36		sta ($36),y			sta 	(zTemp0),y
.8c95	e8		inx				inx
.8c96	e0 04		cpx #$04			cpx 	#4
.8c98	d0 f6		bne $8c90			bne 	_PSCopy
.8c9a					_PSNext:
.8c9a	18		clc				clc
.8c9b	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.8c9d	65 30		adc $30				adc 	codePtr
.8c9f	85 30		sta $30				sta 	codePtr
.8ca1	90 02		bcc $8ca5			bcc 	_CREExit
.8ca3	e6 31		inc $31				inc 	codePtr+1
.8ca5					_CREExit:
.8ca5	80 ba		bra $8c61			bra 	_PSLoop
.8ca7					_PSExit:
.8ca7	60		rts				rts
.8ca8					_PSSyntax:
.8ca8	4c b6 9f	jmp $9fb6			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/scanforward.asm

.8cab					ScanForward:
.8cab	64 38		stz $38				stz 	zTemp1 						; this is the structure count - goes up with WHILE/FOR
.8cad	86 37		stx $37				stx 	zTemp0+1
.8caf	85 36		sta $36				sta 	zTemp0 						; save XA as the two possible matches.
.8cb1					_ScanLoop:
.8cb1	b1 30		lda ($30),y			lda 	(codePtr),y
.8cb3	c8		iny				iny
.8cb4	a6 38		ldx $38				ldx 	zTemp1 						; if the count is > 0 cannot match as in substructure
.8cb6	d0 0e		bne $8cc6			bne 	_ScanGoNext
.8cb8	c5 36		cmp $36				cmp 	zTemp0 						; see if either matches
.8cba	f0 04		beq $8cc0			beq 	_ScanMatch
.8cbc	c5 37		cmp $37				cmp 	zTemp0+1
.8cbe	d0 06		bne $8cc6			bne 	_ScanGoNext
.8cc0					_ScanMatch:
.8cc0	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if asked for EOL, backtrack.
.8cc2	d0 01		bne $8cc5			bne 	_ScanNotEndEOL
.8cc4	88		dey				dey
.8cc5					_ScanNotEndEOL:
.8cc5	60		rts				rts
.8cc6					_ScanGoNext:
.8cc6	20 cb 8c	jsr $8ccb			jsr  	ScanForwardOne
.8cc9	80 e6		bra $8cb1			bra 	_ScanLoop
.8ccb					ScanForwardOne:
.8ccb	c9 40		cmp #$40			cmp 	#$40 						; if 00-3F, punctuation characters, loop back
.8ccd	90 3e		bcc $8d0d			bcc 	_SFWExit
.8ccf	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if 40-82, skip one extra.
.8cd1	90 18		bcc $8ceb			bcc 	_ScanSkipOne
.8cd3	c9 fc		cmp #$fc			cmp 	#$FC 						; FC-FF are data skips
.8cd5	b0 2f		bcs $8d06			bcs 	_ScanSkipData
.8cd7	c9 a0		cmp #$a0			cmp 	#KWC_FIRST_STRUCTURE 		; structure keyword ?
.8cd9	90 32		bcc $8d0d			bcc 	_SFWExit 					; if not, ordinary keywords.
.8cdb	c9 ab		cmp #$ab			cmp 	#KWC_LAST_STRUCTURE+1
.8cdd	b0 2e		bcs $8d0d			bcs 	_SFWExit
.8cdf	c6 38		dec $38				dec 	zTemp1 						; decrement the sructure count
.8ce1	c9 a5		cmp #$a5			cmp 	#KWC_FIRST_STRUCTURE_DEC 	; back if it is a dec structure (e.g. WEND/NEXT)
.8ce3	b0 28		bcs $8d0d			bcs 	_SFWExit
.8ce5	e6 38		inc $38				inc 	zTemp1 						; so it's an increment structure
.8ce7	e6 38		inc $38				inc 	zTemp1 						; twice to undo the dec
.8ce9	80 22		bra $8d0d			bra 	_SFWExit
.8ceb					_ScanSkipOne:
.8ceb	c8		iny				iny 								; consume the extra one.
.8cec	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if not EOL loop back
.8cee	d0 1d		bne $8d0d			bne 	_SFWExit
.8cf0	18		clc				clc
.8cf1	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.8cf3	65 30		adc $30				adc 	codePtr
.8cf5	85 30		sta $30				sta 	codePtr
.8cf7	90 02		bcc $8cfb			bcc 	_CREExit
.8cf9	e6 31		inc $31				inc 	codePtr+1
.8cfb					_CREExit:
.8cfb	a0 03		ldy #$03			ldy 	#3 							; scan start position.
.8cfd	b2 30		lda ($30)			lda 	(codePtr)
.8cff	d0 0c		bne $8d0d			bne 	_SFWExit 					; if not zero, more to scan
.8d01	a9 13		lda #$13		lda	#19
.8d03	4c 69 8d	jmp $8d69		jmp	ErrorHandler
.8d06					_ScanSkipData:
.8d06	88		dey				dey 								; point at data token
.8d07	c8		iny				iny
.8d08	98		tya				tya
.8d09	38		sec				sec
.8d0a	71 30		adc ($30),y			adc 	(codePtr),y
.8d0c	a8		tay				tay
.8d0d					_SFWExit:
.8d0d	60		rts				rts
.8d0e					ScanGetCurrentLineStep:
.8d0e	64 38		stz $38				stz 	zTemp1
.8d10	a0 03		ldy #$03			ldy 	#3
.8d12					_SGCLSLoop:
.8d12	b1 30		lda ($30),y			lda 	(codePtr),y
.8d14	c8		iny				iny
.8d15	c9 80		cmp #$80			cmp 	#KWC_EOL	 				; if EOL exit
.8d17	f0 05		beq $8d1e			beq 	_SGCLSExit
.8d19	20 cb 8c	jsr $8ccb			jsr 	ScanForwardOne
.8d1c	80 f4		bra $8d12			bra 	_SGCLSLoop
.8d1e					_SGCLSExit:
.8d1e	a5 38		lda $38				lda 	zTemp1
.8d20	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/while.asm

.8d21					Command_WHILE:
.8d21	5a		phy				phy 								; save position of the test
.8d22	a2 00		ldx #$00			ldx 	#0
.8d24	20 55 9d	jsr $9d55			jsr 	EvaluateNumber 				; work out the number
.8d27	20 5c 9e	jsr $9e5c			jsr 	NSMIsZero 					; check if zero
.8d2a	f0 0e		beq $8d3a			beq 	_WHExitLoop 				; if so exit the loop
.8d2c	98		tya				tya 								; position *after* test.
.8d2d	7a		ply				ply 								; restore position before test, at WHILE
.8d2e	88		dey				dey
.8d2f	48		pha				pha 								; push after test on the stack
.8d30	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; allocate 6 bytes on the return stack.
.8d32	20 85 a6	jsr $a685			jsr 	StackOpen
.8d35	20 c9 a6	jsr $a6c9			jsr 	STKSaveCodePosition 		; save loop position - where the test value is.
.8d38	7a		ply				ply 								; restore the position *after* the test
.8d39	60		rts				rts
.8d3a					_WHExitLoop:
.8d3a	68		pla				pla 								; throw post loop position
.8d3b	a9 aa		lda #$aa			lda 	#KWD_WEND 					; scan forward past WEND
.8d3d	aa		tax				tax
.8d3e	20 ab 8c	jsr $8cab			jsr 	ScanForward
.8d41	60		rts				rts
.8d42					Command_WEND:
.8d42	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; check WHILE is TOS
.8d44	a2 10		ldx #$10			ldx 	#ERRID_WHILE 				; this error
.8d46	20 b1 a6	jsr $a6b1			jsr 	StackCheckFrame
.8d49	20 da a6	jsr $a6da			jsr 	STKLoadCodePosition 		; loop back
.8d4c	20 a3 a6	jsr $a6a3			jsr 	StackClose		 			; erase the frame
.8d4f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/charcheck.asm

.8d50					CheckRightBracket:
.8d50	b1 30		lda ($30),y			lda 	(codePtr),y
.8d52	c8		iny				iny
.8d53	c9 29		cmp #$29			cmp 	#KWD_RPAREN 						; exit if matches
.8d55	d0 0f		bne $8d66			bne 	CNAFail
.8d57	60		rts				rts
.8d58					CheckComma:
.8d58	b1 30		lda ($30),y			lda 	(codePtr),y
.8d5a	c8		iny				iny
.8d5b	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 						; exit if matches
.8d5d	d0 07		bne $8d66			bne 	CNAFail
.8d5f	60		rts				rts
.8d60					CheckNextA:
.8d60	d1 30		cmp ($30),y			cmp 	(codePtr),y
.8d62	d0 02		bne $8d66			bne 	CNAFail
.8d64	c8		iny				iny 								; skip character
.8d65	60		rts				rts 								; and exit
.8d66					CNAFail:
.8d66	4c b6 9f	jmp $9fb6			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/errors.asm

.8d69					ErrorHandler:
.8d69	a8		tay				tay 								; find the error text
.8d6a	f0 49		beq $8db5			beq 	_EHEnd
.8d6c	a2 00		ldx #$00			ldx 	#0
.8d6e	a9 cf		lda #$cf			lda 	#((ErrorText) & $FF)
.8d70	85 36		sta $36				sta 	0+zTemp0
.8d72	a9 9f		lda #$9f			lda 	#((ErrorText) >> 8)
.8d74	85 37		sta $37				sta 	1+zTemp0
.8d76					_EHFind:
.8d76	88		dey				dey 								; found the error text ?
.8d77	f0 0e		beq $8d87			beq 	_EHFound
.8d79					_EHFindZero:
.8d79	b2 36		lda ($36)			lda 	(zTemp0) 					; find the next error
.8d7b	e6 36		inc $36				inc 	zTemp0
.8d7d	d0 02		bne $8d81			bne 	_EHFNoCarry
.8d7f	e6 37		inc $37				inc 	zTemp0+1
.8d81					_EHFNoCarry:
.8d81	c9 00		cmp #$00			cmp 	#0
.8d83	d0 f4		bne $8d79			bne 	_EHFindZero
.8d85	80 ef		bra $8d76			bra 	_EHFind
.8d87					_EHFound:
.8d87	a5 36		lda $36				lda 	zTemp0 						; print message
.8d89	a6 37		ldx $37				ldx 	zTemp0+1
.8d8b	20 c2 8d	jsr $8dc2			jsr 	PrintStringXA
.8d8e	a0 01		ldy #$01			ldy 	#1 							; if line number zero don't print i
.8d90	b1 30		lda ($30),y			lda 	(codePtr),y
.8d92	d0 05		bne $8d99			bne 	_EHAtMsg
.8d94	c8		iny				iny
.8d95	b1 30		lda ($30),y			lda 	(codePtr),y
.8d97	f0 17		beq $8db0			beq 	_EHCREnd
.8d99					_EHAtMsg:
.8d99	a2 8d		ldx #$8d			ldx 	#_AtMsg >> 8 				; print " at "
.8d9b	a9 b8		lda #$b8			lda 	#_AtMsg & $FF
.8d9d	20 c2 8d	jsr $8dc2			jsr 	PrintStringXA
.8da0	a0 01		ldy #$01			ldy 	#1 							; line number into XA
.8da2	b1 30		lda ($30),y			lda 	(codePtr),y
.8da4	48		pha				pha
.8da5	c8		iny				iny
.8da6	b1 30		lda ($30),y			lda 	(codePtr),y
.8da8	aa		tax				tax
.8da9	68		pla				pla
.8daa	20 7b 92	jsr $927b			jsr 	LCLConvertInt16 				; convert XA to string
.8dad	20 c2 8d	jsr $8dc2			jsr 	PrintStringXA 				; and print it.
.8db0					_EHCREnd:
.8db0	a9 0d		lda #$0d			lda 	#13 						; new line
.8db2	20 c5 a7	jsr $a7c5			jsr 	EXTPrintCharacter
.8db5					_EHEnd:
.8db5	4c 58 83	jmp $8358			jmp 	WarmStart
>8db8	20 61 74 20 6c 69 6e 65		_AtMsg:	.text 	" at line ",0
>8dc0	20 00
.8dc2					PrintStringXA:
.8dc2	5a		phy				phy
.8dc3	86 37		stx $37				stx 	zTemp0+1
.8dc5	85 36		sta $36				sta 	zTemp0
.8dc7	a0 00		ldy #$00			ldy 	#0
.8dc9					_PSXALoop:
.8dc9	b1 36		lda ($36),y			lda 	(zTemp0),y
.8dcb	f0 06		beq $8dd3			beq 	_PSXAExit
.8dcd	20 c5 a7	jsr $a7c5			jsr 	EXTPrintCharacter
.8dd0	c8		iny				iny
.8dd1	80 f6		bra $8dc9			bra 	_PSXALoop
.8dd3					_PSXAExit:
.8dd3	7a		ply				ply
.8dd4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/compare.asm

.8dd5					UnaryTrue:
.8dd5	fa		plx				plx
.8dd6					ReturnTrue:
.8dd6	a9 01		lda #$01			lda 	#1  						; set to 1
.8dd8	20 2e 9e	jsr $9e2e			jsr 	NSMSetByte
.8ddb	a9 80		lda #$80			lda 	#$80 						; set sign flag, so it is -1
.8ddd	9d 00 04	sta $0400,x			sta 	NSStatus,x
.8de0	60		rts				rts
.8de1					UnaryFalse:
.8de1	fa		plx				plx
.8de2					ReturnFalse:
.8de2	4c 2c 9e	jmp $9e2c			jmp 	NSMSetZero 					; set it all to zero
.8de5					BinaryCompareEqual:
.8de5	fa		plx				plx
.8de6	20 21 8e	jsr $8e21			jsr 	CompareBaseCode
.8de9	c9 00		cmp #$00			cmp 	#0
.8deb	f0 e9		beq $8dd6			beq 	ReturnTrue
.8ded	80 f3		bra $8de2			bra 	ReturnFalse
.8def					BinaryCompareLess:
.8def	fa		plx				plx
.8df0	20 21 8e	jsr $8e21			jsr 	CompareBaseCode
.8df3	c9 ff		cmp #$ff			cmp 	#$FF
.8df5	f0 df		beq $8dd6			beq 	ReturnTrue
.8df7	80 e9		bra $8de2			bra 	ReturnFalse
.8df9					BinaryCompareGreater:
.8df9	fa		plx				plx
.8dfa	20 21 8e	jsr $8e21			jsr 	CompareBaseCode
.8dfd	c9 01		cmp #$01			cmp 	#1
.8dff	f0 d5		beq $8dd6			beq 	ReturnTrue
.8e01	80 df		bra $8de2			bra 	ReturnFalse
.8e03					BinaryCompareNotEqual:
.8e03	fa		plx				plx
.8e04	20 21 8e	jsr $8e21			jsr 	CompareBaseCode
.8e07	c9 00		cmp #$00			cmp 	#0
.8e09	d0 cb		bne $8dd6			bne 	ReturnTrue
.8e0b	80 d5		bra $8de2			bra 	ReturnFalse
.8e0d					BinaryCompareLessEqual:
.8e0d	fa		plx				plx
.8e0e	20 21 8e	jsr $8e21			jsr 	CompareBaseCode
.8e11	c9 01		cmp #$01			cmp 	#1
.8e13	d0 c1		bne $8dd6			bne 	ReturnTrue
.8e15	80 cb		bra $8de2			bra 	ReturnFalse
.8e17					BinaryCompareGreaterEqual:
.8e17	fa		plx				plx
.8e18	20 21 8e	jsr $8e21			jsr 	CompareBaseCode
.8e1b	c9 ff		cmp #$ff			cmp 	#$FF
.8e1d	d0 b7		bne $8dd6			bne 	ReturnTrue
.8e1f	80 c1		bra $8de2			bra 	ReturnFalse
.8e21					CompareBaseCode:
.8e21	20 31 96	jsr $9631			jsr 	DereferenceTopTwo 			; make both values if references.
.8e24	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if either is a string.
.8e27	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8e2a	29 10		and #$10			and 	#NSTString
.8e2c	d0 40		bne $8e6e			bne 	_CBCString
.8e2e	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check both are integers
.8e31	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8e34	d0 3b		bne $8e71			bne 	_CBCFloat
.8e36	bd 00 04	lda $0400,x			lda 	NSStatus,x
.8e39	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8e3c	29 08		and #$08			and 	#NSTFloat
.8e3e	d0 31		bne $8e71			bne 	_CBCFloat
.8e40	20 74 8e	jsr $8e74			jsr 	CompareFixMinusZero
.8e43	e8		inx				inx
.8e44	20 74 8e	jsr $8e74			jsr 	CompareFixMinusZero
.8e47	ca		dex				dex
.8e48	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; are the signs different ?
.8e4b	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.8e4e	10 0b		bpl $8e5b			bpl 	_CDCSameSign
.8e50	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; if first one is -ve
.8e53	30 16		bmi $8e6b			bmi 	_CBCLess 					; return $FF
.8e55					_CBCGreater:
.8e55	a9 01		lda #$01			lda 	#1
.8e57	60		rts				rts
.8e58					_CBCEqual:
.8e58	a9 00		lda #$00			lda 	#0
.8e5a	60		rts				rts
.8e5b					_CDCSameSign:
.8e5b	20 c7 90	jsr $90c7			jsr 	SubTopTwoStack 				; unsigned subtract
.8e5e	20 5c 9e	jsr $9e5c			jsr 	NSMIsZero 					; or the mantissa together
.8e61	f0 f5		beq $8e58			beq 	_CBCEqual 					; -0 == 0
.8e63	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; sign of the result. if +ve return $01 else return $FF
.8e66	5d 01 04	eor $0401,x			eor 	NSStatus+1,x 				; however if both were -ve this is inverted
.8e69	10 ea		bpl $8e55			bpl 	_CBCGreater
.8e6b					_CBCLess:
.8e6b	a9 ff		lda #$ff			lda 	#$FF
.8e6d	60		rts				rts
.8e6e					_CBCString:
.8e6e	4c 1d 90	jmp $901d			jmp 	CompareStrings
.8e71					_CBCFloat:
.8e71	4c fe 93	jmp $93fe			jmp 	CompareFloat
.8e74					CompareFixMinusZero:
.8e74	20 5c 9e	jsr $9e5c			jsr 	NSMIsZero
.8e77	d0 03		bne $8e7c			bne 	_CFXMZNotZero
.8e79	9e 00 04	stz $0400,x			stz 	NSStatus,x
.8e7c					_CFXMZNotZero:
.8e7c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/concat.asm

.8e7d					StringConcat:
.8e7d	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check both strings
.8e80	3d 01 04	and $0401,x			and 	NSStatus+1,x
.8e83	29 18		and #$18			and 	#NSBTypeMask
.8e85	c9 10		cmp #$10			cmp 	#NSTString
.8e87	d0 4e		bne $8ed7			bne		_SCType
.8e89	64 38		stz $38				stz 	zTemp1 						; counting total length
.8e8b	e8		inx				inx
.8e8c	20 aa 8e	jsr $8eaa			jsr 	_SCSetupZ0 					; setup for second
.8e8f	20 b5 8e	jsr $8eb5			jsr 	_SCLengthZ0 				; length for second
.8e92	ca		dex				dex
.8e93	20 aa 8e	jsr $8eaa			jsr 	_SCSetupZ0 					; setup for first
.8e96	20 b5 8e	jsr $8eb5			jsr 	_SCLengthZ0 				; length for first
.8e99	a5 38		lda $38				lda 	zTemp1 						; allocate memory
.8e9b	20 78 a7	jsr $a778			jsr 	StringTempAllocate
.8e9e	20 c8 8e	jsr $8ec8			jsr 	_SCCopy 					; copy first out, using zTemp0 from above
.8ea1	e8		inx				inx
.8ea2	20 aa 8e	jsr $8eaa			jsr 	_SCSetupZ0 					; copy second out
.8ea5	20 c8 8e	jsr $8ec8			jsr 	_SCCopy
.8ea8	ca		dex				dex
.8ea9	60		rts				rts
.8eaa					_SCSetupZ0:
.8eaa	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.8ead	85 36		sta $36				sta 	zTemp0
.8eaf	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.8eb2	85 37		sta $37				sta 	zTemp0+1
.8eb4	60		rts				rts
.8eb5					_SCLengthZ0:
.8eb5	5a		phy				phy
.8eb6	a0 00		ldy #$00			ldy 	#0
.8eb8					_SCLenLoop:
.8eb8	b1 36		lda ($36),y			lda 	(zTemp0),y
.8eba	f0 0a		beq $8ec6			beq 	_SCLExit
.8ebc	c8		iny				iny
.8ebd	e6 38		inc $38				inc 	zTemp1
.8ebf	10 f7		bpl $8eb8			bpl		_SCLenLoop
.8ec1	a9 09		lda #$09		lda	#9
.8ec3	4c 69 8d	jmp $8d69		jmp	ErrorHandler
.8ec6					_SCLExit:
.8ec6	7a		ply				ply
.8ec7	60		rts				rts
.8ec8					_SCCopy:
.8ec8	5a		phy				phy
.8ec9	a0 00		ldy #$00			ldy 	#0
.8ecb					_SCCopyLoop:
.8ecb	b1 36		lda ($36),y			lda 	(zTemp0),y
.8ecd	f0 06		beq $8ed5			beq 	_SCCExit
.8ecf	20 b6 a7	jsr $a7b6			jsr 	StringTempWrite
.8ed2	c8		iny				iny
.8ed3	80 f6		bra $8ecb			bra 	_SCCopyLoop
.8ed5					_SCCExit:
.8ed5	7a		ply				ply
.8ed6	60		rts				rts
.8ed7					_SCType:
.8ed7	4c c0 9f	jmp $9fc0			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/divide.asm

.8eda					IntegerDivide:
.8eda	fa		plx				plx
.8edb	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.8ede	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8ee1	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8ee2	0a		asl a				asl 	a
.8ee3	10 05		bpl $8eea			bpl 	_NotRef
.8ee5	48		pha				pha
.8ee6	20 31 96	jsr $9631			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8ee9	68		pla				pla
.8eea					_NotRef:
.8eea	0a		asl a				asl 	a
.8eeb	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.8eed	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8ef0	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8ef3	f0 03		beq $8ef8			beq 	_IntegerCode 				; if clear, then we have two integers
.8ef5	4c c0 9f	jmp $9fc0			jmp 	TypeError 					; anything else, type mismatch.
.8ef8					_IntegerCode:
.8ef8	20 1a 8f	jsr $8f1a			jsr 	CheckDivideZero 			; do div zero check
.8efb	20 52 8f	jsr $8f52			jsr 	Int32Divide 				; do the division
.8efe	20 0f 90	jsr $900f			jsr 	CalculateSign 				; calculate result sign
.8f01					NSMCopyPlusTwoToZero:
.8f01	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.8f04	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.8f07	bd 12 04	lda $0412,x			lda 	NSMantissa1+2,x
.8f0a	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.8f0d	bd 1a 04	lda $041a,x			lda 	NSMantissa2+2,x
.8f10	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.8f13	bd 22 04	lda $0422,x			lda 	NSMantissa3+2,x
.8f16	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.8f19	60		rts				rts
.8f1a					CheckDivideZero:
.8f1a	e8		inx				inx
.8f1b	20 5c 9e	jsr $9e5c			jsr 	NSMIsZero
.8f1e	f0 02		beq $8f22			beq 	_CDVError
.8f20	ca		dex				dex
.8f21	60		rts				rts
.8f22					_CDVError:
.8f22	a9 03		lda #$03		lda	#3
.8f24	4c 69 8d	jmp $8d69		jmp	ErrorHandler
.8f27					IntegerModulus:
.8f27	fa		plx				plx
.8f28	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.8f2b	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8f2e	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8f2f	0a		asl a				asl 	a
.8f30	10 05		bpl $8f37			bpl 	_NotRef
.8f32	48		pha				pha
.8f33	20 31 96	jsr $9631			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8f36	68		pla				pla
.8f37					_NotRef:
.8f37	0a		asl a				asl 	a
.8f38	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.8f3a	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8f3d	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8f40	f0 03		beq $8f45			beq 	_IntegerCode 				; if clear, then we have two integers
.8f42	4c c0 9f	jmp $9fc0			jmp 	TypeError 					; anything else, type mismatch.
.8f45					_IntegerCode:
.8f45					IntegerModulusNoCheck:
.8f45	20 1a 8f	jsr $8f1a			jsr 	CheckDivideZero 			; do div zero check
.8f48	20 52 8f	jsr $8f52			jsr 	Int32Divide 				; do the division
.8f4b	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; clear the sign bit.
.8f4e	5e 00 04	lsr $0400,x			lsr 	NSStatus,x
.8f51	60		rts				rts
.8f52					Int32Divide:
.8f52	48		pha				pha 								; save AXY
.8f53	5a		phy				phy
.8f54	20 03 9e	jsr $9e03			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.8f57	20 28 9e	jsr $9e28			jsr 	NSMSetZeroMantissaOnly 		; set S[X] to zero
.8f5a	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.8f5c					_I32DivideLoop:
.8f5c	e8		inx				inx
.8f5d	e8		inx				inx
.8f5e	20 41 9e	jsr $9e41			jsr 	NSMShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.8f61	ca		dex				dex
.8f62	ca		dex				dex
.8f63	20 42 9e	jsr $9e42			jsr 	NSMRotateLeft
.8f66	20 92 8f	jsr $8f92			jsr 	DivideCheckSubtract 		; check if subtract possible
.8f69	90 03		bcc $8f6e			bcc 	_I32DivideNoCarryIn
.8f6b	fe 0a 04	inc $040a,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.8f6e					_I32DivideNoCarryIn:
.8f6e	88		dey				dey 								; loop round till division completed.
.8f6f	d0 eb		bne $8f5c			bne 	_I32DivideLoop
.8f71	7a		ply				ply 								; restore AXY and exit
.8f72	68		pla				pla
.8f73	60		rts				rts
.8f74					Int32ShiftDivide:
.8f74	48		pha				pha 								; save AY
.8f75	5a		phy				phy
.8f76	e8		inx				inx 								; clear S[X+2]
.8f77	e8		inx				inx
.8f78	20 2c 9e	jsr $9e2c			jsr 	NSMSetZero
.8f7b	ca		dex				dex
.8f7c	ca		dex				dex
.8f7d	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.8f7f					_I32SDLoop:
.8f7f	20 92 8f	jsr $8f92			jsr 	DivideCheckSubtract 		; check if subtract possible
.8f82	e8		inx				inx
.8f83	e8		inx				inx
.8f84	20 42 9e	jsr $9e42			jsr 	NSMRotateLeft				; shift 64 bit FPA left, rotating carry in
.8f87	ca		dex				dex
.8f88	ca		dex				dex
.8f89	20 42 9e	jsr $9e42			jsr 	NSMRotateLeft
.8f8c	88		dey				dey 	 							; do 31 times
.8f8d	d0 f0		bne $8f7f			bne 	_I32SDLoop
.8f8f	7a		ply				ply 								; restore AY and exit
.8f90	68		pla				pla
.8f91	60		rts				rts
.8f92					DivideCheckSubtract:
.8f92	20 c7 90	jsr $90c7			jsr 	SubTopTwoStack 				; subtract Stack[X+1] from Stack[X+0]
.8f95	b0 04		bcs $8f9b			bcs 	_DCSExit 					; if carry set, then could do, exit
.8f97	20 a1 90	jsr $90a1			jsr 	AddTopTwoStack 				; add it back in
.8f9a	18		clc				clc 								; and return False
.8f9b					_DCSExit:
.8f9b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/multiply.asm

.8f9c					MulInteger:
.8f9c	fa		plx				plx
.8f9d	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.8fa0	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8fa3	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8fa4	0a		asl a				asl 	a
.8fa5	10 05		bpl $8fac			bpl 	_NotRef
.8fa7	48		pha				pha
.8fa8	20 31 96	jsr $9631			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8fab	68		pla				pla
.8fac					_NotRef:
.8fac	0a		asl a				asl 	a 							; put MSB of type into A:7
.8fad	30 0b		bmi $8fba			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.8faf	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8fb2	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8fb5	f0 06		beq $8fbd			beq 	_IntegerCode 				; if clear, then we have two integers
.8fb7	4c d5 94	jmp $94d5			jmp 	FloatingPointMultiply 							; otherwise at least one float.
.8fba					_StringData:
.8fba	4c ca 9f	jmp $9fca			jmp 	NotDoneError							; at least one string - don't know both are strings.
.8fbd					_IntegerCode:
.8fbd	20 ca 8f	jsr $8fca			jsr 	MultiplyShort
.8fc0	c9 00		cmp #$00			cmp 	#0
.8fc2	f0 05		beq $8fc9			beq 	_MIExit
.8fc4	a9 04		lda #$04		lda	#4
.8fc6	4c 69 8d	jmp $8d69		jmp	ErrorHandler
.8fc9					_MIExit:
.8fc9	60		rts				rts
.8fca					MultiplyShort:
.8fca	5a		phy				phy 								; save Y
.8fcb	20 03 9e	jsr $9e03			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.8fce	20 28 9e	jsr $9e28			jsr 	NSMSetZeroMantissaOnly 		; set mantissa S[X] to zero
.8fd1	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.8fd3					_I32MLoop:
.8fd3	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.8fd6	1d 12 04	ora $0412,x			ora 	NSMantissa1+2,x
.8fd9	1d 1a 04	ora $041a,x			ora 	NSMantissa2+2,x
.8fdc	1d 22 04	ora $0422,x			ora 	NSMantissa3+2,x
.8fdf	f0 28		beq $9009			beq 	_I32MExit 					; exit if zero
.8fe1	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.8fe4	29 01		and #$01			and 	#1
.8fe6	f0 0e		beq $8ff6			beq 	_I32MNoAdd
.8fe8	20 a1 90	jsr $90a1			jsr 	AddTopTwoStack 				; if so add S[X+1] to S[X+0]
.8feb	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.8fee	10 06		bpl $8ff6			bpl 	_I32MNoAdd
.8ff0					_I32ShiftRight:
.8ff0	20 4f 9e	jsr $9e4f			jsr 	NSMShiftRight 				; shift S[X] right
.8ff3	c8		iny				iny 								; increment shift count
.8ff4	80 0a		bra $9000			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.8ff6					_I32MNoAdd:
.8ff6	3c 21 04	bit $0421,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.8ff9	70 f5		bvs $8ff0			bvs 	_I32ShiftRight 				; instead.
.8ffb	e8		inx				inx
.8ffc	20 41 9e	jsr $9e41			jsr 	NSMShiftLeft 				; shift additive S[X+1] left
.8fff	ca		dex				dex
.9000					_I32MShiftUpper:
.9000	e8		inx				inx 								; shift S[X+2] right
.9001	e8		inx				inx
.9002	20 4f 9e	jsr $9e4f			jsr 	NSMShiftRight
.9005	ca		dex				dex
.9006	ca		dex				dex
.9007	80 ca		bra $8fd3			bra 	_I32MLoop 					; try again.
.9009					_I32MExit:
.9009	20 0f 90	jsr $900f			jsr 	CalculateSign
.900c	98		tya				tya 								; shift in A
.900d	7a		ply				ply 								; restore Y and exit
.900e	60		rts				rts
.900f					CalculateSign:
.900f	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.9012	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; shift result left
.9015	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.9018	0a		asl a				asl 	a 							; shift bit 7 into carry
.9019	7e 00 04	ror $0400,x			ror 	NSStatus,x 					; shift right into status byte.
.901c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/scompare.asm

.901d					CompareStrings:
.901d	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check both are strings
.9020	3d 01 04	and $0401,x			and 	NSStatus+1,x
.9023	29 10		and #$10			and 	#NSBIsString
.9025	f0 2c		beq $9053			beq 	_CSTypeError
.9027	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy string addresses to zTemp0/1
.902a	85 36		sta $36				sta 	zTemp0
.902c	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.902f	85 37		sta $37				sta 	zTemp0+1
.9031	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.9034	85 38		sta $38				sta 	zTemp1
.9036	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.9039	85 39		sta $39				sta 	zTemp1+1
.903b	5a		phy				phy 								; save Y so we can access strings
.903c	a0 ff		ldy #$ff			ldy 	#$FF 						; -1 for pre increment.
.903e					_CSLoop:
.903e	c8		iny				iny
.903f	b1 36		lda ($36),y			lda 	(zTemp0),y 					; check if they are the same
.9041	d1 38		cmp ($38),y			cmp 	(zTemp1),y
.9043	d0 06		bne $904b			bne 	_CSDifferent
.9045	c9 00		cmp #$00			cmp 	#0 							; reached end ?
.9047	d0 f5		bne $903e			bne 	_CSLoop 					; still comparing
.9049					_CSExit:
.9049	7a		ply				ply 								; reached end, return zero in A from EOS
.904a	60		rts				rts
.904b					_CSDifferent:
.904b	a9 ff		lda #$ff			lda 	#255 						; if < return $FF
.904d	90 fa		bcc $9049			bcc		_CSExit
.904f	a9 01		lda #$01			lda 	#1 							; otherwise return 1.
.9051	80 f6		bra $9049			bra 	_CSExit
.9053					_CSTypeError:
.9053	4c c0 9f	jmp $9fc0			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/shifts.asm

.9056					ShiftLeft:
.9056	38		sec				sec
.9057	80 01		bra $905a			bra 	ShiftMain
.9059					ShiftRight:
.9059	18		clc				clc
.905a					ShiftMain:
.905a	fa		plx				plx 								; restore X
.905b	08		php				php 								; save direction
.905c	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.905f	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9062	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9063	0a		asl a				asl 	a
.9064	10 05		bpl $906b			bpl 	_NotRef
.9066	48		pha				pha
.9067	20 31 96	jsr $9631			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.906a	68		pla				pla
.906b					_NotRef:
.906b	0a		asl a				asl 	a
.906c	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.906e	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9071	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9074	f0 03		beq $9079			beq 	_IntegerCode 				; if clear, then we have two integers
.9076	4c c0 9f	jmp $9fc0			jmp 	TypeError 					; anything else, type mismatch.
.9079					_IntegerCode:
.9079	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; check number < 32
.907c	29 e0		and #$e0			and 	#$E0
.907e	1d 11 04	ora $0411,x			ora 	NSMantissa1+1,x
.9081	1d 19 04	ora $0419,x			ora 	NSMantissa2+1,x
.9084	1d 21 04	ora $0421,x			ora 	NSMantissa3+1,x
.9087	d0 13		bne $909c			bne 	_SMExit0 					; if >= 32 it will always return zero.
.9089					_SMLoop:
.9089	de 09 04	dec $0409,x			dec 	NSMantissa0+1,x 			; predecrement, could do << 0
.908c	30 11		bmi $909f			bmi 	_SMExit 					; exit if done.
.908e	28		plp				plp 								; restore direcition setting
.908f	08		php				php
.9090	90 05		bcc $9097			bcc 	_SMRight
.9092	20 41 9e	jsr $9e41			jsr 	NSMShiftLeft 				; shift left if CS
.9095	80 f2		bra $9089			bra 	_SMLoop
.9097					_SMRight:
.9097	20 4f 9e	jsr $9e4f			jsr 	NSMShiftRight 				; shift right if CC
.909a	80 ed		bra $9089			bra 	_SMLoop
.909c					_SMExit0:
.909c	20 2c 9e	jsr $9e2c			jsr 	NSMSetZero 					; return zero.
.909f					_SMExit:
.909f	28		plp				plp 								; throw direction
.90a0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/simple.asm

.90a1					AddTopTwoStack:
.90a1	18		clc				clc
.90a2	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.90a5	7d 09 04	adc $0409,x			adc 		NSMantissa0+1,x
.90a8	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.90ab	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.90ae	7d 11 04	adc $0411,x			adc 		NSMantissa1+1,x
.90b1	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.90b4	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.90b7	7d 19 04	adc $0419,x			adc 		NSMantissa2+1,x
.90ba	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.90bd	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.90c0	7d 21 04	adc $0421,x			adc 		NSMantissa3+1,x
.90c3	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.90c6	60		rts				rts
.90c7					SubTopTwoStack:
.90c7	38		sec				sec
.90c8	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.90cb	fd 09 04	sbc $0409,x			sbc 		NSMantissa0+1,x
.90ce	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.90d1	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.90d4	fd 11 04	sbc $0411,x			sbc 		NSMantissa1+1,x
.90d7	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.90da	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.90dd	fd 19 04	sbc $0419,x			sbc 		NSMantissa2+1,x
.90e0	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.90e3	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.90e6	fd 21 04	sbc $0421,x			sbc 		NSMantissa3+1,x
.90e9	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.90ec	60		rts				rts
.90ed					AddInteger:
.90ed	fa		plx				plx
.90ee	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.90f1	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.90f4	0a		asl a				asl 	a 							; shift reference bit into sign bit
.90f5	0a		asl a				asl 	a
.90f6	10 05		bpl $90fd			bpl 	_NotRef
.90f8	48		pha				pha
.90f9	20 31 96	jsr $9631			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.90fc	68		pla				pla
.90fd					_NotRef:
.90fd	0a		asl a				asl 	a 							; put MSB of type into A:7
.90fe	30 0b		bmi $910b			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9100	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9103	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9106	f0 06		beq $910e			beq 	_IntegerCode 				; if clear, then we have two integers
.9108	4c 55 93	jmp $9355			jmp 	FloatingPointAdd 							; otherwise at least one float.
.910b					_StringData:
.910b	4c 7d 8e	jmp $8e7d			jmp 	StringConcat							; at least one string - don't know both are strings.
.910e					_IntegerCode:
.910e					AddCode:
.910e	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.9111	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.9114	10 8b		bpl $90a1			bpl 	AddTopTwoStack
.9116	20 c7 90	jsr $90c7			jsr 	SubTopTwoStack 				; do a physical subtraction
.9119	3c 20 04	bit $0420,x			bit 	NSMantissa3,x 				; result is +ve, okay
.911c	10 09		bpl $9127			bpl 	_AddExit
.911e	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; sign is that of 2nd value
.9121	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9124	20 e1 9d	jsr $9de1			jsr 	NSMNegateMantissa 			; negate the mantissa and exit
.9127					_AddExit:
.9127	20 5c 9e	jsr $9e5c			jsr 	NSMIsZero 					; check for -0
.912a	d0 03		bne $912f			bne 	_AddNonZero
.912c	9e 00 04	stz $0400,x			stz 	NSStatus,x
.912f					_AddNonZero:
.912f	60		rts				rts
.9130					SubInteger:
.9130	fa		plx				plx
.9131	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9134	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9137	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9138	0a		asl a				asl 	a
.9139	10 05		bpl $9140			bpl 	_NotRef
.913b	48		pha				pha
.913c	20 31 96	jsr $9631			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.913f	68		pla				pla
.9140					_NotRef:
.9140	0a		asl a				asl 	a 							; put MSB of type into A:7
.9141	30 0b		bmi $914e			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9143	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9146	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9149	f0 06		beq $9151			beq 	_IntegerCode 				; if clear, then we have two integers
.914b	4c 5a 93	jmp $935a			jmp 	FloatingPointSub 							; otherwise at least one float.
.914e					_StringData:
.914e	4c ca 9f	jmp $9fca			jmp 	NotDoneError							; at least one string - don't know both are strings.
.9151					_IntegerCode:
.9151	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; negate the second value.
.9154	49 80		eor #$80			eor 	#$80
.9156	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.9159	80 b3		bra $910e			bra 	AddCode 					; and do the same code as add.
.915b					AndInteger:
.915b	fa		plx				plx
.915c	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.915f	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9162	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9163	0a		asl a				asl 	a
.9164	10 05		bpl $916b			bpl 	_NotRef
.9166	48		pha				pha
.9167	20 31 96	jsr $9631			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.916a	68		pla				pla
.916b					_NotRef:
.916b	0a		asl a				asl 	a
.916c	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.916e	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9171	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9174	f0 03		beq $9179			beq 	_IntegerCode 				; if clear, then we have two integers
.9176	4c c0 9f	jmp $9fc0			jmp 	TypeError 					; anything else, type mismatch.
.9179					_IntegerCode:
.9179	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.917c	3d 09 04	and $0409,x			and 		NSMantissa0+1,x
.917f	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9182	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.9185	3d 11 04	and $0411,x			and 		NSMantissa1+1,x
.9188	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.918b	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.918e	3d 19 04	and $0419,x			and 		NSMantissa2+1,x
.9191	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9194	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.9197	3d 21 04	and $0421,x			and 		NSMantissa3+1,x
.919a	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.919d	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.91a0	60		rts				rts
.91a1					OraInteger:
.91a1	fa		plx				plx
.91a2	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.91a5	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.91a8	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91a9	0a		asl a				asl 	a
.91aa	10 05		bpl $91b1			bpl 	_NotRef
.91ac	48		pha				pha
.91ad	20 31 96	jsr $9631			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91b0	68		pla				pla
.91b1					_NotRef:
.91b1	0a		asl a				asl 	a
.91b2	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.91b4	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91b7	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.91ba	f0 03		beq $91bf			beq 	_IntegerCode 				; if clear, then we have two integers
.91bc	4c c0 9f	jmp $9fc0			jmp 	TypeError 					; anything else, type mismatch.
.91bf					_IntegerCode:
.91bf	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.91c2	1d 09 04	ora $0409,x			ora 		NSMantissa0+1,x
.91c5	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.91c8	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.91cb	1d 11 04	ora $0411,x			ora 		NSMantissa1+1,x
.91ce	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.91d1	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.91d4	1d 19 04	ora $0419,x			ora 		NSMantissa2+1,x
.91d7	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.91da	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.91dd	1d 21 04	ora $0421,x			ora 		NSMantissa3+1,x
.91e0	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.91e3	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.91e6	60		rts				rts
.91e7					EorInteger:
.91e7	fa		plx				plx
.91e8	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.91eb	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.91ee	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91ef	0a		asl a				asl 	a
.91f0	10 05		bpl $91f7			bpl 	_NotRef
.91f2	48		pha				pha
.91f3	20 31 96	jsr $9631			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91f6	68		pla				pla
.91f7					_NotRef:
.91f7	0a		asl a				asl 	a
.91f8	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.91fa	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91fd	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9200	f0 03		beq $9205			beq 	_IntegerCode 				; if clear, then we have two integers
.9202	4c c0 9f	jmp $9fc0			jmp 	TypeError 					; anything else, type mismatch.
.9205					_IntegerCode:
.9205	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.9208	5d 09 04	eor $0409,x			eor 		NSMantissa0+1,x
.920b	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.920e	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.9211	5d 11 04	eor $0411,x			eor 		NSMantissa1+1,x
.9214	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9217	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.921a	5d 19 04	eor $0419,x			eor 		NSMantissa2+1,x
.921d	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9220	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.9223	5d 21 04	eor $0421,x			eor 		NSMantissa3+1,x
.9226	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9229	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.922c	60		rts				rts
.922d					WordIndirect:
.922d	fa		plx				plx
.922e	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9231	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9234	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9235	0a		asl a				asl 	a
.9236	10 05		bpl $923d			bpl 	_NotRef
.9238	48		pha				pha
.9239	20 31 96	jsr $9631			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.923c	68		pla				pla
.923d					_NotRef:
.923d	0a		asl a				asl 	a
.923e	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9240	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9243	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9246	f0 03		beq $924b			beq 	_IntegerCode 				; if clear, then we have two integers
.9248	4c c0 9f	jmp $9fc0			jmp 	TypeError 					; anything else, type mismatch.
.924b					_IntegerCode:
.924b	20 0e 91	jsr $910e			jsr 	AddCode 					; add the two values
.924e	a9 22		lda #$22			lda 	#NSBIsReference+2 			; make a 2 byte reference
.9250	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9253	60		rts				rts
.9254					ByteIndirect:
.9254	fa		plx				plx
.9255	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9258	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.925b	0a		asl a				asl 	a 							; shift reference bit into sign bit
.925c	0a		asl a				asl 	a
.925d	10 05		bpl $9264			bpl 	_NotRef
.925f	48		pha				pha
.9260	20 31 96	jsr $9631			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9263	68		pla				pla
.9264					_NotRef:
.9264	0a		asl a				asl 	a
.9265	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9267	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.926a	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.926d	f0 03		beq $9272			beq 	_IntegerCode 				; if clear, then we have two integers
.926f	4c c0 9f	jmp $9fc0			jmp 	TypeError 					; anything else, type mismatch.
.9272					_IntegerCode:
.9272	20 0e 91	jsr $910e			jsr 	AddCode 					; add the two values
.9275	a9 21		lda #$21			lda 	#NSBIsReference+1 			; make a 1 byte reference
.9277	9d 00 04	sta $0400,x			sta 	NSStatus,x
.927a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/tostring.asm

.927b					LCLConvertInt16:
.927b	8d 08 04	sta $0408			sta 	NSMantissa0 				; set up as 32 bit conversion
.927e	8e 10 04	stx $0410			stx 	NSMantissa1
.9281	9c 18 04	stz $0418			stz 	NSMantissa2
.9284	9c 20 04	stz $0420			stz 	NSMantissa3
.9287	9c 00 04	stz $0400			stz 	NSStatus 					; positive integer
.928a	a2 00		ldx #$00			ldx 	#0 							; stack level
.928c	a9 0a		lda #$0a			lda 	#10 						; base
.928e	80 00		bra $9290			bra 	ConvertInt32
.9290					ConvertInt32:
.9290	5a		phy				phy
.9291	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.9293	2c 00 04	bit $0400			bit 	NSStatus 					; output a - if not negative.
.9296	10 08		bpl $92a0			bpl 	_CI32NotNeg
.9298	48		pha				pha
.9299	a9 2d		lda #$2d			lda 	#'-'
.929b	99 f9 05	sta $05f9,y			sta 	NumberBuffer,y
.929e	c8		iny				iny
.929f	68		pla				pla
.92a0					_CI32NotNeg:
.92a0	20 ae 92	jsr $92ae			jsr 	_CI32DivideConvert 			; recursive conversion
.92a3	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.92a5	99 f9 05	sta $05f9,y			sta 	NumberBuffer,y
.92a8	7a		ply				ply
.92a9	a2 05		ldx #$05			ldx 	#NumberBuffer >> 8
.92ab	a9 f9		lda #$f9			lda 	#NumberBuffer & $FF
.92ad	60		rts				rts
.92ae					_CI32DivideConvert:
.92ae	e8		inx				inx 								; write to next slot up
.92af	20 2e 9e	jsr $9e2e			jsr 	NSMSetByte
.92b2	ca		dex				dex
.92b3	20 52 8f	jsr $8f52			jsr 	Int32Divide 				; divide
.92b6	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; save remainder
.92b9	48		pha				pha
.92ba	20 01 8f	jsr $8f01			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.92bd	20 5c 9e	jsr $9e5c			jsr 	NSMIsZero 					; is it zero ?
.92c0	f0 06		beq $92c8			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.92c2	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.92c5	20 ae 92	jsr $92ae			jsr 	_CI32DivideConvert 			; and recusrively call.
.92c8					_CI32NoRecurse:
.92c8	68		pla				pla 								; remainder
.92c9	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.92cb	90 02		bcc $92cf			bcc 	_CI32NotHex
.92cd	69 26		adc #$26			adc 	#6+32
.92cf					_CI32NotHex:
.92cf	69 30		adc #$30			adc 	#48
.92d1	99 f9 05	sta $05f9,y			sta 	NumberBuffer,y 				; write out and exit
.92d4	c8		iny				iny
.92d5	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/expression.asm


;******  Processing file: ./common/expressions/../generated/precedence.dat

.92d6					PrecedenceLevel:
>92d6	04					.byte	 4	; $00 <<
>92d7	02					.byte	 2	; $01 <=
>92d8	02					.byte	 2	; $02 <>
>92d9	00					.byte	 0	; $03 !!3
>92da	00					.byte	 0	; $04 ><
>92db	02					.byte	 2	; $05 >=
>92dc	04					.byte	 4	; $06 >>
>92dd	00					.byte	 0	; $07 !!7
>92de	00					.byte	 0	; $08 !!8
>92df	00					.byte	 0	; $09 !!9
>92e0	00					.byte	 0	; $0a !!10
>92e1	00					.byte	 0	; $0b !!11
>92e2	00					.byte	 0	; $0c !!12
>92e3	00					.byte	 0	; $0d !!13
>92e4	00					.byte	 0	; $0e !!14
>92e5	00					.byte	 0	; $0f !!15
>92e6	00					.byte	 0	; $10 @
>92e7	00					.byte	 0	; $11 !!17
>92e8	00					.byte	 0	; $12 !!18
>92e9	00					.byte	 0	; $13 [
>92ea	04					.byte	 4	; $14 \
>92eb	00					.byte	 0	; $15 ]
>92ec	01					.byte	 1	; $16 ^
>92ed	00					.byte	 0	; $17 _
>92ee	00					.byte	 0	; $18 `
>92ef	00					.byte	 0	; $19 !!25
>92f0	00					.byte	 0	; $1a !!26
>92f1	00					.byte	 0	; $1b {
>92f2	01					.byte	 1	; $1c |
>92f3	00					.byte	 0	; $1d }
>92f4	00					.byte	 0	; $1e ~
>92f5	00					.byte	 0	; $1f [7m<7F>[m
>92f6	00					.byte	 0	; $20
>92f7	05					.byte	 5	; $21 !
>92f8	00					.byte	 0	; $22 "
>92f9	00					.byte	 0	; $23 #
>92fa	05					.byte	 5	; $24 $
>92fb	04					.byte	 4	; $25 %
>92fc	01					.byte	 1	; $26 &
>92fd	00					.byte	 0	; $27 '
>92fe	00					.byte	 0	; $28 (
>92ff	00					.byte	 0	; $29 )
>9300	04					.byte	 4	; $2a *
>9301	03					.byte	 3	; $2b +
>9302	00					.byte	 0	; $2c ,
>9303	03					.byte	 3	; $2d -
>9304	00					.byte	 0	; $2e .
>9305	04					.byte	 4	; $2f /
>9306	00					.byte	 0	; $30 0
>9307	00					.byte	 0	; $31 1
>9308	00					.byte	 0	; $32 2
>9309	00					.byte	 0	; $33 3
>930a	00					.byte	 0	; $34 4
>930b	00					.byte	 0	; $35 5
>930c	00					.byte	 0	; $36 6
>930d	00					.byte	 0	; $37 7
>930e	00					.byte	 0	; $38 8
>930f	00					.byte	 0	; $39 9
>9310	00					.byte	 0	; $3a :
>9311	00					.byte	 0	; $3b ;
>9312	02					.byte	 2	; $3c <
>9313	02					.byte	 2	; $3d =
>9314	02					.byte	 2	; $3e >
>9315	05					.byte	 5	; $3f ?

;******  Return to file: ./common/expressions/expression.asm

.9316					EvaluateExpressionAt0:
.9316	a2 00		ldx #$00			ldx 	#0 							; bottom stack level
.9318					EvaluateExpression:
.9318	a9 00		lda #$00			lda 	#0 							; lowest precedence level
.931a					EvaluateExpressionAtPrecedence:
.931a	48		pha				pha 								; save precedence level
.931b	20 f2 97	jsr $97f2			jsr 	EvaluateTerm 				; evaluate term into level X.
.931e	68		pla				pla 								; restore precedence level.
.931f					_EXPRLoop:
.931f	85 36		sta $36				sta 	zTemp0 						; save current precedence level.
.9321	b1 30		lda ($30),y			lda 	(codePtr),y
.9323	c9 40		cmp #$40			cmp		#$40 						; if >= $40 cannot be an operator
.9325	b0 25		bcs $934c			bcs 	_EXPRExit
.9327	da		phx				phx 								; read the operator precedence
.9328	aa		tax				tax
.9329	bd d6 92	lda $92d6,x			lda 	PrecedenceLevel,x
.932c	fa		plx				plx
.932d	c9 00		cmp #$00			cmp 	#0							; if zero exit (not an operator)
.932f	f0 1b		beq $934c			beq 	_EXPRExit
.9331	85 37		sta $37				sta 	zTemp0+1 					; save operator precedence level.
.9333	a5 36		lda $36				lda 	zTemp0 						; compare current precedence vs. operator precedence
.9335	c5 37		cmp $37				cmp 	zTemp0+1
.9337	b0 13		bcs $934c			bcs		_EXPRExit 					; if current >= operator exit
.9339	48		pha				pha 								; save current precedence.
.933a	b1 30		lda ($30),y			lda 	(codePtr),y
.933c	c8		iny				iny
.933d	48		pha				pha
.933e	a5 37		lda $37				lda 	zTemp0+1 					; get operator precedence level
.9340	e8		inx				inx 								; work out the right hand side.
.9341	20 1a 93	jsr $931a			jsr 	EvaluateExpressionAtPrecedence
.9344	ca		dex				dex
.9345	68		pla				pla 								; get operator, call the code.
.9346	20 4f 93	jsr $934f			jsr 	_EXPRCaller
.9349	68		pla				pla 								; restore precedence level
.934a	80 d3		bra $931f			bra 	_EXPRLoop 					; and go round.
.934c					_EXPRExit:
.934c	a5 36		lda $36				lda 	zTemp0 						; A = current precedence level.
.934e	60		rts				rts
.934f					_EXPRCaller:
.934f	da		phx				phx 								; save on stack, first thing is to restore it
.9350	0a		asl a				asl 	a 							; double so can use vectors into X
.9351	aa		tax				tax
.9352	7c 96 8a	jmp ($8a96,x)			jmp 	(VectorSetPunc,x) 			; and go to the code.

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/addsub.asm

.9355					FloatingPointAdd:
.9355	20 fe 94	jsr $94fe			jsr 	FloatPrepare 				; prepare for floats
.9358	80 0b		bra $9365			bra 	FloatAdd
.935a					FloatingPointSub:
.935a	20 fe 94	jsr $94fe			jsr 	FloatPrepare 				; prepare for floats
.935d					FloatSubtract:
.935d	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; negate FPB
.9360	49 80		eor #$80			eor 	#$80
.9362	9d 01 04	sta $0401,x			sta 	NSStatus+1,x				; and fall through.
.9365					FloatAdd:
.9365	48		pha				pha
.9366	5a		phy				phy
.9367	20 0f 95	jsr $950f			jsr 	NSNormalise 				; normalise S[X]
.936a	f0 5c		beq $93c8			beq 	_FAReturn1
.936c	e8		inx				inx 								; normalise S[X+1]
.936d	20 0f 95	jsr $950f			jsr 	NSNormalise
.9370	ca		dex				dex
.9371	c9 00		cmp #$00			cmp 	#0
.9373	f0 77		beq $93ec			beq 	_FAExit 					; if so, just return A
.9375	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; are the exponents the same ?
.9378	dd 29 04	cmp $0429,x			cmp 	NSExponent+1,x
.937b	f0 1b		beq $9398			beq 	_FAExponentsEqual
.937d	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; work out the larger exponent
.9380	a8		tay				tay
.9381	38		sec				sec 								; do a signed comparison of the exponents.
.9382	fd 29 04	sbc $0429,x			sbc 	NSExponent+1,x
.9385	50 02		bvc $9389			bvc 	_FANoSignedChange
.9387	49 80		eor #$80			eor 	#$80
.9389					_FANoSignedChange:
.9389	29 80		and #$80			and 	#$80
.938b	10 03		bpl $9390			bpl 	_FAHaveMax
.938d	bc 29 04	ldy $0429,x			ldy 	NSExponent+1,x
.9390					_FAHaveMax:
.9390	20 ef 93	jsr $93ef			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.9393	e8		inx				inx
.9394	20 ef 93	jsr $93ef			jsr 	_FAShiftToExponent
.9397	ca		dex				dex
.9398					_FAExponentsEqual:
.9398	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; are the signs the same
.939b	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.939e	30 10		bmi $93b0			bmi 	_FADifferentSigns
.93a0	20 a1 90	jsr $90a1			jsr 	AddTopTwoStack 				; do the add of the mantissae
.93a3	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.93a6	10 44		bpl $93ec			bpl 	_FAExit 					; if no, we are done.
.93a8	20 4f 9e	jsr $9e4f			jsr 	NSMShiftRight 				; shift A right, renormalising it.
.93ab	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; bump the exponent and exit
.93ae	80 3c		bra $93ec			bra 	_FAExit
.93b0					_FADifferentSigns:
.93b0	20 c7 90	jsr $90c7			jsr 	SubTopTwoStack 				; subtract mantissa B from A
.93b3	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; is the result negative ?
.93b6	10 06		bpl $93be			bpl 	_FACheckZero 				; if no, check for -0
.93b8	20 d8 9d	jsr $9dd8			jsr 	NSMNegate 					; netate result
.93bb	20 e1 9d	jsr $9de1			jsr 	NSMNegateMantissa 			; negate (2'c) the mantissa
.93be					_FACheckZero:
.93be	20 5c 9e	jsr $9e5c			jsr 	NSMIsZero	 				; check for -0
.93c1	d0 29		bne $93ec			bne 	_FAExit
.93c3	9e 00 04	stz $0400,x			stz 	NSStatus,x
.93c6	80 24		bra $93ec			bra 	_FAExit
.93c8					_FAReturn1:
.93c8	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.93cb	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.93ce	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.93d1	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.93d4	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.93d7	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.93da	bd 21 04	lda $0421,x			lda 	NSMantissa3+1,x
.93dd	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.93e0	bd 29 04	lda $0429,x			lda 	NSExponent+1,x
.93e3	9d 28 04	sta $0428,x			sta 	NSExponent,x
.93e6	bd 01 04	lda $0401,x			lda 	NSStatus+1,x
.93e9	9d 00 04	sta $0400,x			sta 	NSStatus,x
.93ec					_FAExit:
.93ec	7a		ply				ply
.93ed	68		pla				pla
.93ee	60		rts				rts
.93ef					_FAShiftToExponent:
.93ef					_FAShiftToExponent2:
.93ef	98		tya				tya 								; compare Y to exponent
.93f0	dd 28 04	cmp $0428,x			cmp 	NSExponent,x 				; reached the exponent required ?
.93f3	f0 08		beq $93fd			beq 	_FASEExit 					; exit if so.
.93f5	20 4f 9e	jsr $9e4f			jsr 	NSMShiftRight	 			; shift the mantissa right
.93f8	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; increment exponent
.93fb	80 f2		bra $93ef			bra 	_FAShiftToExponent2
.93fd					_FASEExit:
.93fd	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/compare.asm

.93fe					CompareFloat:
.93fe	20 5d 93	jsr $935d			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.9401	bd 10 04	lda $0410,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.9404	29 f8		and #$f8			and 	#$F8
.9406	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9409	1d 20 04	ora $0420,x			ora 	NSMantissa3,x
.940c	f0 09		beq $9417			beq 	_FCExit 					; zero, so approximately identical
.940e	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.9410	3c 00 04	bit $0400,x			bit 	NSStatus,x
.9413	10 02		bpl $9417			bpl 	_FCExit
.9415					_FCNegative:
.9415	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.9417					_FCExit:
.9417	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/divide.asm

.9418					FDivideCommand:
.9418	fa		plx				plx	 								; restore stack position
.9419	20 fe 94	jsr $94fe			jsr 	FloatPrepare 				; prepare for floats
.941c					FloatDivide:
.941c	48		pha				pha
.941d	e8		inx				inx
.941e	20 0f 95	jsr $950f			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.9421	ca		dex				dex
.9422	c9 00		cmp #$00			cmp 	#0
.9424	f0 20		beq $9446			beq 	_FDZero
.9426	20 0f 95	jsr $950f			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.9429	f0 19		beq $9444			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.942b	20 74 8f	jsr $8f74			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.942e	20 01 8f	jsr $8f01			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.9431	20 0f 95	jsr $950f			jsr		NSNormalise 				; renormalise
.9434	20 0f 90	jsr $900f			jsr 	CalculateSign 				; calculate result sign
.9437	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; calculate exponent
.943a	38		sec				sec
.943b	fd 29 04	sbc $0429,x			sbc 	NSExponent+1,x
.943e	38		sec				sec
.943f	e9 1e		sbc #$1e			sbc 	#30
.9441	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9444					_FDExit:
.9444	68		pla				pla
.9445	60		rts				rts
.9446					_FDZero:
.9446	a9 03		lda #$03		lda	#3
.9448	4c 69 8d	jmp $8d69		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/fractional.asm

.944b					FloatFractionalPart:
.944b	5a		phy				phy
.944c	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; take absolute value
.944f	29 7f		and #$7f			and 	#$7F
.9451	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9454	20 0f 95	jsr $950f			jsr 	NSNormalise
.9457	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.945a	38		sec				sec
.945b	e9 e0		sbc #$e0			sbc 	#$E0
.945d	90 31		bcc $9490			bcc 	_FFPExit 					; already fractional
.945f	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.9461	b0 2a		bcs $948d			bcs 	_FFPZero
.9463	a8		tay				tay 								; put count to do in Y
.9464	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; do each in turn.
.9467	20 92 94	jsr $9492			jsr 	_FFPPartial
.946a	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.946d	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9470	20 92 94	jsr $9492			jsr 	_FFPPartial
.9473	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9476	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9479	20 92 94	jsr $9492			jsr 	_FFPPartial
.947c	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.947f	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9482	20 92 94	jsr $9492			jsr 	_FFPPartial
.9485	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9488	20 5c 9e	jsr $9e5c			jsr 	NSMIsZero 					; zeroed check.
.948b	d0 03		bne $9490			bne 	_FFPExit
.948d					_FFPZero:
.948d	20 2c 9e	jsr $9e2c			jsr 	NSMSetZero
.9490					_FFPExit:
.9490	7a		ply				ply
.9491	60		rts				rts
.9492					_FFPPartial:
.9492	c0 00		cpy #$00			cpy 	#0 							; no more to do
.9494	f0 17		beq $94ad			beq 	_FFFPPExit
.9496	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.9498	b0 0c		bcs $94a6			bcs 	_FFFPPWholeByte
.949a	5a		phy				phy
.949b					_FFFPPLeft:
.949b	0a		asl a				asl 	a
.949c	88		dey				dey
.949d	d0 fc		bne $949b			bne 	_FFFPPLeft
.949f	7a		ply				ply
.94a0					_FFFPPRight:
.94a0	4a		lsr a				lsr 	a
.94a1	88		dey				dey
.94a2	d0 fc		bne $94a0			bne 	_FFFPPRight
.94a4	80 07		bra $94ad			bra 	_FFFPPExit
.94a6					_FFFPPWholeByte:
.94a6	98		tya				tya 								; subtract 8 from count
.94a7	38		sec				sec
.94a8	e9 08		sbc #$08			sbc 	#8
.94aa	a8		tay				tay
.94ab	a9 00		lda #$00			lda 	#0 							; and clear all
.94ad					_FFFPPExit:
.94ad	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/integer.asm

.94ae					FloatIntegerPart:
.94ae	48		pha				pha
.94af	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; is it integer already ?
.94b2	f0 1f		beq $94d3			beq 	_FIPExit 					; if so do nothing
.94b4	20 5c 9e	jsr $9e5c			jsr 	NSMIsZero 					; is it zero ?
.94b7	f0 17		beq $94d0			beq 	_FIPZero 					; if so return zero.
.94b9	20 0f 95	jsr $950f			jsr 	NSNormalise 				; normalise
.94bc	f0 12		beq $94d0			beq 	_FIPZero 					; normalised to zero, exit zero
.94be					_FIPShift:
.94be	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.94c1	10 08		bpl $94cb			bpl 	_FIPCheckZero
.94c3	20 4f 9e	jsr $9e4f			jsr 	NSMShiftRight 				; shift mantissa right
.94c6	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; bump exponent
.94c9	80 f3		bra $94be			bra 	_FIPShift
.94cb					_FIPCheckZero:
.94cb	20 5c 9e	jsr $9e5c			jsr 	NSMIsZero 					; avoid -0 problem
.94ce	d0 03		bne $94d3			bne 	_FIPExit 					; set to zero if mantissa zero.
.94d0					_FIPZero:
.94d0	20 2c 9e	jsr $9e2c			jsr 	NSMSetZero
.94d3					_FIPExit:
.94d3	68		pla				pla
.94d4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/multiply.asm

.94d5					FloatingPointMultiply:
.94d5	20 fe 94	jsr $94fe			jsr 	FloatPrepare 				; prepare for floats
.94d8					FloatMultiply:
.94d8	48		pha				pha
.94d9	20 0f 95	jsr $950f			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.94dc	f0 1b		beq $94f9			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.94de	e8		inx				inx
.94df	20 0f 95	jsr $950f			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.94e2	ca		dex				dex
.94e3	c9 00		cmp #$00			cmp 	#0
.94e5	f0 0f		beq $94f6			beq 	_FDSetZero
.94e7	20 ca 8f	jsr $8fca			jsr 	MultiplyShort 				; calculate the result.
.94ea	7d 28 04	adc $0428,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.94ed	18		clc				clc
.94ee	7d 29 04	adc $0429,x			adc 	NSExponent+1,x
.94f1	9d 28 04	sta $0428,x			sta 	NSExponent,x
.94f4	80 03		bra $94f9			bra 	_FDExit
.94f6					_FDSetZero:
.94f6	20 2c 9e	jsr $9e2c			jsr 	NSMSetZero 					; return 0
.94f9					_FDExit:
.94f9	20 0f 95	jsr $950f			jsr 	NSNormalise 				; normalise the result
.94fc	68		pla				pla
.94fd	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/utility.asm

.94fe					FloatPrepare:
.94fe	20 31 96	jsr $9631			jsr 	DereferenceTopTwo 			; dereference the top two values
.9501	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check ints/floats
.9504	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9507	29 10		and #$10			and 	#NSBIsString
.9509	d0 01		bne $950c			bne 	_FDType
.950b	60		rts				rts
.950c					_FDType:
.950c	4c c0 9f	jmp $9fc0			jmp 	TypeError
.950f					NSNormalise:
.950f	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; make float, keep sign
.9512	29 80		and #$80			and 	#$80
.9514	09 08		ora #$08			ora 	#NSTFloat
.9516	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9519	20 5c 9e	jsr $9e5c			jsr 	NSMIsZero 					; if zero exit
.951c	d0 09		bne $9527			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.951e	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; clear the sign bit.
.9521	7e 00 04	ror $0400,x			ror 	NSStatus,x 					; (no -0)
.9524	a9 00		lda #$00			lda 	#0 							; set Z flag
.9526	60		rts				rts
.9527					_NSNormaliseOptimise:
.9527	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; upper byte zero ?
.952a	d0 22		bne $954e			bne 	_NSNormaliseLoop
.952c	bd 18 04	lda $0418,x			lda 	NSMantissa2,x 				; byte normalise
.952f	30 1d		bmi $954e			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.9531	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9534	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9537	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.953a	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.953d	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9540	9e 08 04	stz $0408,x			stz 	NSMantissa0,x
.9543	bd 28 04	lda $0428,x			lda 	NSExponent,x
.9546	38		sec				sec
.9547	e9 08		sbc #$08			sbc 	#8
.9549	9d 28 04	sta $0428,x			sta 	NSExponent,x
.954c	80 d9		bra $9527			bra 	_NSNormaliseOptimise
.954e					_NSNormaliseLoop:
.954e	3c 20 04	bit $0420,x			bit 	NSMantissa3,x 				; bit 30 set ?
.9551	70 08		bvs $955b			bvs 	_NSNExit 					; exit if so with Z flag clear
.9553	20 41 9e	jsr $9e41			jsr 	NSMShiftLeft 				; shift mantissa left
.9556	de 28 04	dec $0428,x			dec 	NSExponent,x 				; adjust exponent
.9559	80 f3		bra $954e			bra 	_NSNormaliseLoop
.955b					_NSNExit:
.955b	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.955d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignnumber.asm

.955e					AssignNumber:
.955e	5a		phy				phy
.955f	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy mantissa0/1 to zTemp0
.9562	85 36		sta $36				sta 	zTemp0
.9564	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9567	85 37		sta $37				sta 	zTemp0+1
.9569	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; clear reference bits
.956c	29 df		and #$df			and 	#(NSBIsReference ^ $FF)
.956e	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9571	29 18		and #$18			and 	#NSBTypeMask				; assigning to a float ?
.9573	c9 08		cmp #$08			cmp 	#NSTFloat
.9575	f0 2a		beq $95a1			beq 	_ANFloat
.9577	bd 29 04	lda $0429,x			lda		NSExponent+1,x 				; is it a float
.957a	f0 05		beq $9581			beq		_ANNotFloat
.957c	e8		inx				inx
.957d	20 ae 94	jsr $94ae			jsr 	FloatIntegerPart 			; make it an integer
.9580	ca		dex				dex
.9581					_ANNotFloat:
.9581	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if byte/word reference.
.9584	29 03		and #$03			and 	#3
.9586	d0 05		bne $958d			bne 	_ANByteWord
.9588	20 ad 95	jsr $95ad			jsr 	_ANCopy4PackSign 			; copy all 4 bytes and sign
.958b	80 1e		bra $95ab			bra 	_ANExit
.958d					_ANByteWord:
.958d	48		pha				pha 								; save count
.958e	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; do byte
.9591	92 36		sta ($36)			sta 	(zTemp0)
.9593	68		pla				pla
.9594	c9 01		cmp #$01			cmp	 	#1
.9596	f0 13		beq $95ab			beq 	_ANExit
.9598	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x 			; do word
.959b	a0 01		ldy #$01			ldy 	#1
.959d	91 36		sta ($36),y			sta 	(zTemp0),y
.959f	80 0a		bra $95ab			bra 	_ANExit
.95a1					_ANFloat:
.95a1	20 ad 95	jsr $95ad			jsr 	_ANCopy4PackSign 			; write all 4 bytes and packed sign
.95a4	bd 29 04	lda $0429,x			lda 	NSExponent+1,x 				; copy exponent to slot 4
.95a7	a0 04		ldy #$04			ldy 	#4
.95a9	91 36		sta ($36),y			sta 	(zTemp0),y
.95ab					_ANExit:
.95ab	7a		ply				ply
.95ac	60		rts				rts
.95ad					_ANCopy4PackSign:
.95ad	a0 03		ldy #$03			ldy 	#3
.95af	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; sign bit into status
.95b2	29 80		and #$80			and 	#$80 						; put into high bit of mantissa 3
.95b4	1d 21 04	ora $0421,x			ora 	NSMantissa3+1,x
.95b7	91 36		sta ($36),y			sta 	(zTemp0),y
.95b9	88		dey				dey
.95ba	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.95bd	91 36		sta ($36),y			sta 	(zTemp0),y
.95bf	88		dey				dey
.95c0	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.95c3	91 36		sta ($36),y			sta 	(zTemp0),y
.95c5	88		dey				dey
.95c6	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.95c9	91 36		sta ($36),y			sta 	(zTemp0),y
.95cb	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignstring.asm

.95cc					AssignString:
.95cc	5a		phy				phy
.95cd	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.95d0	85 38		sta $38				sta 	zTemp1
.95d2	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.95d5	85 39		sta $39				sta 	zTemp1+1
.95d7	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.95da	85 36		sta $36				sta 	zTemp0
.95dc	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.95df	85 37		sta $37				sta 	zTemp0+1
.95e1	a0 01		ldy #$01			ldy 	#1 							; the high byte of the target address
.95e3	b1 36		lda ($36),y			lda 	(zTemp0),y
.95e5	f0 23		beq $960a			beq 	_ASNewStringRequired 		; if zero, a new string is required.
.95e7	38		sec				sec 								; put Address-2 in zsTemp - this is the size/status/string record
.95e8	b2 36		lda ($36)			lda 	(zTemp0) 					; of concreted strings
.95ea	e9 02		sbc #$02			sbc 	#2
.95ec	85 3c		sta $3c				sta 	zsTemp
.95ee	a0 01		ldy #$01			ldy 	#1
.95f0	b1 36		lda ($36),y			lda 	(zTemp0),y
.95f2	e9 00		sbc #$00			sbc 	#0
.95f4	85 3d		sta $3d				sta 	zsTemp+1
.95f6	a0 ff		ldy #$ff			ldy 	#$FF 						; get length of new string
.95f8					_ASGetLength:
.95f8	c8		iny				iny
.95f9	b1 38		lda ($38),y			lda 	(zTemp1),y
.95fb	d0 fb		bne $95f8			bne 	_ASGetLength
.95fd	98		tya				tya 								; is this length <= current length
.95fe	d2 3c		cmp ($3c)			cmp 	(zsTemp)
.9600	90 20		bcc $9622			bcc 	_ASCopyString
.9602	f0 1e		beq $9622			beq 	_ASCopyString
.9604	a9 80		lda #$80			lda 	#$80 						; mark as unused.
.9606	a0 01		ldy #$01			ldy 	#1
.9608	91 3c		sta ($3c),y			sta 	(zsTemp),y
.960a					_ASNewStringRequired:
.960a	e8		inx				inx 								; concrete the new string.
.960b	20 f7 a6	jsr $a6f7			jsr 	StringConcrete				; (breaks zTemp1/2, not zTemp0 and zsTemp)
.960e	ca		dex				dex
.960f	18		clc				clc
.9610	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; copy that new address to the reference.
.9613	69 02		adc #$02			adc 	#2 							; add two to point at the data.
.9615	92 36		sta ($36)			sta 	(zTemp0)
.9617	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.961a	69 00		adc #$00			adc 	#0
.961c	a0 01		ldy #$01			ldy 	#1
.961e	91 36		sta ($36),y			sta 	(zTemp0),y
.9620	80 0d		bra $962f			bra 	_ASExit
.9622					_ASCopyString:
.9622	a0 00		ldy #$00			ldy 	#0
.9624					_ASCopyLoop:
.9624	b1 38		lda ($38),y			lda 	(zTemp1),y
.9626	c8		iny				iny
.9627	c8		iny				iny
.9628	91 3c		sta ($3c),y			sta 	(zsTemp),y
.962a	88		dey				dey
.962b	c9 00		cmp #$00			cmp 	#0
.962d	d0 f5		bne $9624			bne 	_ASCopyLoop
.962f					_ASExit:
.962f	7a		ply				ply
.9630	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/dereference.asm

.9631					DereferenceTopTwo:
.9631	e8		inx				inx
.9632	20 36 96	jsr $9636			jsr 	Dereference 				; deref x+1
.9635	ca		dex				dex  								; falls through to deref x
.9636					Dereference:
.9636	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get the status byte
.9639	29 20		and #$20			and 	#NSBIsReference 			; shift sign bit to carry, reference to bit 7
.963b	f0 57		beq $9694			beq 	_DRFExit 					; not a reference
.963d	5a		phy				phy
.963e	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address to dereference into zTemp0
.9641	85 36		sta $36				sta 	zTemp0
.9643	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9646	85 37		sta $37				sta 	zTemp0+1
.9648	9e 10 04	stz $0410,x			stz 	NSMantissa1,x 				; clear second byte.
.964b	b2 36		lda ($36)			lda 	(zTemp0) 					; do the first byte
.964d	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9650	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get status byte.
.9653	29 18		and #$18			and 	#NSBTypeMask 				; what type is it ?
.9655	c9 10		cmp #$10			cmp 	#NSTString 					; if string, dereference two
.9657	f0 0f		beq $9668			beq 	_DRFDereferenceTwo
.9659	c9 08		cmp #$08			cmp 	#NSTFloat 					; if float, do full dereference.
.965b	f0 39		beq $9696			beq 	_DRFFull
.965d	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be integer - how many bytes ?
.9660	29 03		and #$03			and 	#3
.9662	f0 32		beq $9696			beq 	_DRFFull 					; the whole word
.9664	c9 01		cmp #$01			cmp 	#1 							; is it 10 (e.g. 2 bytes)
.9666	f0 07		beq $966f			beq		_DRFClear23 				; no, one byte, clear 2 & 3 and exit
.9668					_DRFDereferenceTwo:
.9668	a0 01		ldy #$01			ldy 	#1
.966a	b1 36		lda ($36),y			lda 	(zTemp0),y
.966c	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.966f					_DRFClear23:
.966f	9e 18 04	stz $0418,x			stz 	NSMantissa2,x 				; clear upper bytes, only read 1 or 2 bytes
.9672	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.9675	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; make it a value of that type.
.9678	29 18		and #$18			and 	#NSBTypeMask
.967a	9d 00 04	sta $0400,x			sta 	NSStatus,x
.967d	c9 10		cmp #$10			cmp 	#NSTString  				; is it a string
.967f	d0 12		bne $9693			bne 	_DRFNotString
.9681	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; check address is zero
.9684	1d 10 04	ora $0410,x			ora 	NSMantissa1,x
.9687	d0 0a		bne $9693			bne 	_DRFNotString
.9689	a9 95		lda #$95			lda 	#_DRFNullString & $FF 		; if so, return reference to ""
.968b	9d 08 04	sta $0408,x			sta 	NSMantissa0,X
.968e	a9 96		lda #$96			lda 	#_DRFNullString >> 8
.9690	9d 10 04	sta $0410,x			sta 	NSMantissa1,X
.9693					_DRFNotString
.9693	7a		ply				ply 								; restore Y and exit
.9694					_DRFExit:
.9694	60		rts				rts
.9695					_DRFNullString:
>9695	00						.byte 	0
.9696					_DRFFull:
.9696	a0 01		ldy #$01			ldy 	#1 							; get remaining 3 bytes.
.9698	b1 36		lda ($36),y			lda 	(zTemp0),y
.969a	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.969d	c8		iny				iny
.969e	b1 36		lda ($36),y			lda 	(zTemp0),y
.96a0	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.96a3	c8		iny				iny
.96a4	b1 36		lda ($36),y			lda 	(zTemp0),y
.96a6	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.96a9	9e 28 04	stz $0428,x			stz 	NSExponent,x 				; clear exponent.
.96ac	bd 00 04	lda $0400,x			lda		NSStatus,x 					; see if type is integer
.96af	29 18		and #$18			and 	#NSBTypeMask  				; type information only
.96b1	9d 00 04	sta $0400,x			sta 	NSStatus,x 					; update it back.
.96b4	f0 06		beq $96bc			beq 	_DRFNoExponent
.96b6	c8		iny				iny 								; if not, read the exponent as well.
.96b7	b1 36		lda ($36),y			lda 	(zTemp0),y
.96b9	9d 28 04	sta $0428,x			sta 	NSExponent,x
.96bc					_DRFNoExponent:
.96bc	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; is the most significant bit set ?
.96bf	10 0d		bpl $96ce			bpl 	_DRFExit2 					; if not, then exit.
.96c1	29 7f		and #$7f			and 	#$7F 						; clear that bit.
.96c3	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.96c6	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; set the sign flag
.96c9	09 80		ora #$80			ora 	#NSBIsNegative
.96cb	9d 00 04	sta $0400,x			sta 	NSStatus,x
.96ce					_DRFExit2:
.96ce	7a		ply				ply
.96cf	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/number.asm

=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.96d0					EncodeNumberStart:
.96d0	38		sec				sec
.96d1	80 01		bra $96d4			bra 	EncodeNumberContinue+1
.96d3					EncodeNumberContinue:
.96d3	18		clc				clc
.96d4					EncodeNumber:
.96d4	08		php				php 								; save reset.
.96d5	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.96d7	f0 12		beq $96eb			beq 	_ENIsOkay
.96d9	c9 30		cmp #$30			cmp 	#"0"
.96db	90 04		bcc $96e1			bcc 	_ENBadNumber
.96dd	c9 3a		cmp #$3a			cmp 	#"9"+1
.96df	90 0a		bcc $96eb			bcc 	_ENIsOkay
.96e1					_ENBadNumber:
.96e1	28		plp				plp 								; throw saved reset
.96e2	ad 85 04	lda $0485			lda 	EncodeState 				; decimal mode, construct final number
.96e5	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.96e7	f0 7e		beq $9767			beq 	_ENConstructFinal
.96e9					_ENFail:
.96e9	18		clc				clc 								; not allowed
.96ea	60		rts				rts
.96eb					_ENIsOkay:
.96eb	28		plp				plp 								; are we restarting
.96ec	90 15		bcc $9703			bcc 	_ENNoRestart
.96ee					_ENStartEncode:
.96ee	c9 2e		cmp #$2e			cmp 	#'.'						; first is DP
.96f0	f0 0c		beq $96fe			beq 	_ENFirstDP
.96f2	29 0f		and #$0f			and 	#15 						; put digit in mantissa
.96f4	20 2e 9e	jsr $9e2e			jsr 	NSMSetByte
.96f7	a9 01		lda #$01			lda 	#ESTA_Low
.96f9					_ENExitChange:
.96f9	8d 85 04	sta $0485			sta 	EncodeState 				; save new state
.96fc	38		sec				sec
.96fd	60		rts				rts
.96fe					_ENFirstDP:
.96fe	20 2c 9e	jsr $9e2c			jsr 	NSMSetZero 					; clear integer part
.9701	80 3f		bra $9742			bra 	_ESTASwitchFloat			; go straight to float and exi
.9703					_ENNoRestart:
.9703	48		pha				pha 								; save on stack.
.9704	ad 85 04	lda $0485			lda 	EncodeState 				; get current state
.9707	c9 01		cmp #$01			cmp 	#ESTA_Low
.9709	f0 09		beq $9714			beq  	_ESTALowState
.970b	c9 02		cmp #$02			cmp 	#ESTA_High
.970d	f0 29		beq $9738			beq 	_ESTAHighState
.970f	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.9711	f0 3b		beq $974e			beq 	_ESTADecimalState
>9713	db						.byte 	$DB 						; causes a break in the emulator
.9714					_ESTALowState:
.9714	68		pla				pla 								; get value back
.9715	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.9717	f0 29		beq $9742			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.9719	29 0f		and #$0f			and 	#15 						; make digit
.971b	8d 86 04	sta $0486			sta 	DigitTemp 					; save it.
.971e	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.9721	0a		asl a				asl 	a
.9722	0a		asl a				asl 	a
.9723	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.9726	0a		asl a				asl 	a
.9727	6d 86 04	adc $0486			adc 	DigitTemp
.972a	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.972d	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.972f	90 05		bcc $9736			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.9731	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.9733	8d 85 04	sta $0485			sta 	EncodeState
.9736					_ESTANoSwitch:
.9736	38		sec				sec
.9737	60		rts				rts
.9738					_ESTAHighState:
.9738	68		pla				pla 								; get value back
.9739	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.973b	f0 05		beq $9742			beq 	_ESTASwitchFloat
.973d	20 a1 97	jsr $97a1			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.9740	38		sec				sec
.9741	60		rts				rts
.9742					_ESTASwitchFloat:
.9742	9c 87 04	stz $0487			stz 	DecimalCount
.9745	e8		inx				inx 								; zero the decimal additive.
.9746	20 2c 9e	jsr $9e2c			jsr 	NSMSetZero
.9749	ca		dex				dex
.974a	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.974c	80 ab		bra $96f9			bra 	_ENExitChange
.974e					_ESTADecimalState:
.974e	68		pla				pla 								; digit.
.974f	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 2nd decimal point.
.9751	f0 96		beq $96e9			beq 	_ENFail
.9753	e8		inx				inx 								; put digit into fractional part of X+1
.9754	20 a1 97	jsr $97a1			jsr 	ESTAShiftDigitIntoMantissa
.9757	ca		dex				dex
.9758	ee 87 04	inc $0487			inc 	DecimalCount 				; bump the count of decimals
.975b	ad 87 04	lda $0487			lda 	DecimalCount
.975e	c9 0b		cmp #$0b			cmp 	#11
.9760	f0 02		beq $9764			beq 	_ESTADSFail
.9762	38		sec				sec
.9763	60		rts				rts
.9764					_ESTADSFail:
.9764	4c bb 9f	jmp $9fbb			jmp 	RangeError
.9767					_ENConstructFinal:
.9767	ad 87 04	lda $0487			lda 	DecimalCount 				; get decimal count
.976a	f0 33		beq $979f			beq 	_ENCFExit 					; no decimals
.976c	5a		phy				phy
.976d	0a		asl a				asl 	a 							; x 4 and CLC
.976e	0a		asl a				asl 	a
.976f	6d 87 04	adc $0487			adc 	DecimalCount
.9772	a8		tay				tay
.9773	b9 7a 9f	lda $9f7a,y			lda 	DecimalScalarTable-5,y 		; copy decimal scalar to X+2
.9776	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9779	b9 7b 9f	lda $9f7b,y			lda 	DecimalScalarTable-5+1,y
.977c	9d 12 04	sta $0412,x			sta 	NSMantissa1+2,x
.977f	b9 7c 9f	lda $9f7c,y			lda 	DecimalScalarTable-5+2,y
.9782	9d 1a 04	sta $041a,x			sta 	NSMantissa2+2,x
.9785	b9 7d 9f	lda $9f7d,y			lda 	DecimalScalarTable-5+3,y
.9788	9d 22 04	sta $0422,x			sta 	NSMantissa3+2,x
.978b	b9 7e 9f	lda $9f7e,y			lda 	DecimalScalarTable-5+4,y
.978e	9d 2a 04	sta $042a,x			sta 	NSExponent+2,x
.9791	a9 08		lda #$08			lda 	#NSTFloat
.9793	9d 02 04	sta $0402,x			sta 	NSStatus+2,x
.9796	7a		ply				ply
.9797	e8		inx				inx 								; multiply decimal const by decimal scalar
.9798	20 d8 94	jsr $94d8			jsr 	FloatMultiply
.979b	ca		dex				dex
.979c	20 65 93	jsr $9365			jsr 	FloatAdd 					; add to integer part.
.979f					_ENCFExit:
.979f	18		clc				clc 								; reject the digit.
.97a0	60		rts				rts
.97a1					ESTAShiftDigitIntoMantissa:
.97a1	29 0f		and #$0f			and 	#15 						; save digit
.97a3	48		pha				pha
.97a4	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; push mantissa on stack
.97a7	48		pha				pha
.97a8	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.97ab	48		pha				pha
.97ac	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.97af	48		pha				pha
.97b0	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.97b3	48		pha				pha
.97b4	20 41 9e	jsr $9e41			jsr 	NSMShiftLeft 				; x 2
.97b7	20 41 9e	jsr $9e41			jsr 	NSMShiftLeft 				; x 4
.97ba	18		clc				clc 								; pop mantissa and add
.97bb	68		pla				pla
.97bc	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.97bf	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.97c2	68		pla				pla
.97c3	7d 10 04	adc $0410,x			adc 	NSMantissa1,x
.97c6	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.97c9	68		pla				pla
.97ca	7d 18 04	adc $0418,x			adc 	NSMantissa2,x
.97cd	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.97d0	68		pla				pla
.97d1	7d 20 04	adc $0420,x			adc 	NSMantissa3,x
.97d4	9d 20 04	sta $0420,x			sta 	NSMantissa3,x 				; x 5
.97d7	20 41 9e	jsr $9e41			jsr 	NSMShiftLeft 				; x 10
.97da	68		pla				pla 								; add digit
.97db	18		clc				clc
.97dc	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.97df	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.97e2	90 0d		bcc $97f1			bcc 	_ESTASDExit
.97e4	fe 10 04	inc $0410,x			inc 	NSMantissa1,x
.97e7	d0 08		bne $97f1			bne 	_ESTASDExit
.97e9	fe 18 04	inc $0418,x			inc 	NSMantissa2,x
.97ec	d0 03		bne $97f1			bne 	_ESTASDExit
.97ee	fe 20 04	inc $0420,x			inc 	NSMantissa3,x
.97f1					_ESTASDExit:
.97f1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/term.asm

.97f2					EvaluateTerm:
.97f2	b1 30		lda ($30),y			lda 	(codePtr),y
.97f4	30 18		bmi $980e			bmi 	_ETCheckUnary 				; unary function ? (text ones)
.97f6	c9 40		cmp #$40			cmp 	#$40 						; 40-7F => identifier reference
.97f8	b0 6f		bcs $9869			bcs 	_ETVariable
.97fa	c9 30		cmp #$30			cmp 	#'0' 						; is it a number
.97fc	90 6e		bcc $986c			bcc 	_ETPuncUnary 				; if not it might be a punctuation unary.
.97fe	c9 3a		cmp #$3a			cmp 	#'9'+1
.9800	b0 6a		bcs $986c			bcs 	_ETPuncUnary
.9802	20 d0 96	jsr $96d0			jsr 	EncodeNumberStart 			; can't fail as it's 0-9 !
.9805					_ETNumber:
.9805	c8		iny				iny 								; keep encoding until we have the numbers
.9806	b1 30		lda ($30),y			lda 	(codePtr),y
.9808	20 d3 96	jsr $96d3			jsr 	EncodeNumberContinue
.980b	b0 f8		bcs $9805			bcs 	_ETNumber 					; go back if accepted.
.980d	60		rts				rts
.980e					_ETCheckUnary:
.980e	c9 ff		cmp #$ff			cmp 	#KWC_STRING 				; string token
.9810	f0 41		beq $9853			beq 	_ETString
.9812	c9 fe		cmp #$fe			cmp 	#KWC_HEXCONST 				; hex constant.
.9814	f0 12		beq $9828			beq 	_ETHexConstant
.9816	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; check it actually is a unary function
.9818	90 0b		bcc $9825			bcc 	_ETSyntaxError
.981a	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1
.981c	b0 07		bcs $9825			bcs 	_ETSyntaxError
.981e	da		phx				phx 								; push X on the stack
.981f	0a		asl a				asl 	a 							; put vector x 2 into X
.9820	aa		tax				tax
.9821	c8		iny				iny 								; consume unary function token
.9822	7c 16 8b	jmp ($8b16,x)			jmp 	(VectorSet0,x) 				; and do it.
.9825					_ETSyntaxError:
.9825	4c b6 9f	jmp $9fb6			jmp 	SyntaxError
.9828					_ETHexConstant:
.9828	c8		iny				iny 								; skip #
.9829	c8		iny				iny 								; skip count
.982a	20 2c 9e	jsr $9e2c			jsr 	NSMSetZero 					; clear result
.982d					_ETHLoop:
.982d	b1 30		lda ($30),y			lda 	(codePtr),y
.982f	c8		iny				iny 								; and consume
.9830	c9 00		cmp #$00			cmp 	#0 							; exit if zero
.9832	f0 1e		beq $9852			beq 	_ETHExit
.9834	48		pha				pha 								; save on stack.
.9835	20 41 9e	jsr $9e41			jsr 	NSMShiftLeft 				; x 2
.9838	20 41 9e	jsr $9e41			jsr 	NSMShiftLeft 				; x 4
.983b	20 41 9e	jsr $9e41			jsr 	NSMShiftLeft 				; x 8
.983e	20 41 9e	jsr $9e41			jsr 	NSMShiftLeft 				; x 16
.9841	68		pla				pla 								; ASCII
.9842	c9 41		cmp #$41			cmp 	#'A'
.9844	90 02		bcc $9848			bcc 	_ETHNotChar
.9846	e9 07		sbc #$07			sbc 	#7
.9848					_ETHNotChar:
.9848	29 0f		and #$0f			and 	#15 						; digit now
.984a	1d 08 04	ora $0408,x			ora 	NSMantissa0,x 				; put in LS Nibble
.984d	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9850	80 db		bra $982d			bra 	_ETHLoop 					; go round.
.9852					_ETHExit:
.9852	60		rts				rts
.9853					_ETString:
.9853	c8		iny				iny 								; look at length
.9854	b1 30		lda ($30),y			lda 	(codePtr),y
.9856	48		pha				pha
.9857	c8		iny				iny 								; first character
.9858	20 b0 a5	jsr $a5b0			jsr 	MemoryInline 				; put address of string at (code-Ptr),y on stack
.985b	68		pla				pla 								; restore count and save
.985c	85 36		sta $36				sta 	zTemp0
.985e	98		tya				tya 								; add length to Y to skip it.
.985f	18		clc				clc
.9860	65 36		adc $36				adc 	zTemp0
.9862	a8		tay				tay
.9863	a9 10		lda #$10			lda 	#NSTString 					; mark as string
.9865	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9868	60		rts				rts
.9869					_ETVariable:
.9869	4c c3 98	jmp $98c3			jmp 	VariableHandler
.986c					_ETPuncUnary:
.986c	c8		iny				iny 								; consume the unary character
.986d	c9 2d		cmp #$2d			cmp 	#KWD_MINUS 					; unary minus
.986f	f0 2d		beq $989e			beq 	_ETUnaryNegate
.9871	c9 10		cmp #$10			cmp 	#KWD_AT 					; @ reference -> constant
.9873	f0 39		beq $98ae			beq 	_ETDereference
.9875	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; parenthesis
.9877	f0 43		beq $98bc			beq 	_ETParenthesis
.9879	64 36		stz $36				stz 	zTemp0 						; zTemp0 is the indirection level.
.987b	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; byte indirection (0) ?
.987d	f0 06		beq $9885			beq 	_ETIndirection
.987f	e6 36		inc $36				inc 	zTemp0
.9881	c9 21		cmp #$21			cmp 	#KWD_PLING					; word indirection (1) \
.9883	d0 a0		bne $9825			bne 	_ETSyntaxError
.9885					_ETIndirection:
.9885	a5 36		lda $36				lda 	zTemp0 						; push indirection amount (0-1) => (1-2) on the stack
.9887	1a		inc a				inc 	a
.9888	48		pha				pha
.9889	20 f2 97	jsr $97f2			jsr 	EvaluateTerm				; evaluate the term
.988c	20 36 96	jsr $9636			jsr 	Dereference 				; dereference it.
.988f	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a +ve integer.
.9892	d0 07		bne $989b			bne 	_ETTypeMismatch
.9894	68		pla				pla 								; indirection 1-2
.9895	09 20		ora #$20			ora 	#NSBIsReference 			; make it a reference.
.9897	9d 00 04	sta $0400,x			sta 	NSStatus,x
.989a	60		rts				rts
.989b					_ETTypeMismatch:
.989b	4c c0 9f	jmp $9fc0			jmp 	TypeError
.989e					_ETUnaryNegate:
.989e	20 f2 97	jsr $97f2			jsr 	EvaluateTerm				; evaluate the term
.98a1	20 36 96	jsr $9636			jsr 	Dereference 				; dereference it.
.98a4	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a number
.98a7	29 10		and #$10			and 	#NSTString
.98a9	d0 f0		bne $989b			bne 	_ETTypeMismatch
.98ab	4c d8 9d	jmp $9dd8			jmp 	NSMNegate  					; just toggles the sign bit.
.98ae					_ETDereference:
.98ae	20 f2 97	jsr $97f2			jsr 	EvaluateTerm				; evaluate the term
.98b1	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a reference
.98b4	29 20		and #$20			and 	#NSBIsReference
.98b6	f0 e3		beq $989b			beq 	_ETTypeMismatch
.98b8	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; make it an integer address
.98bb	60		rts				rts
.98bc					_ETParenthesis:
.98bc	20 18 93	jsr $9318			jsr 	EvaluateExpression 			; evaluate here, from lowest precedence
.98bf	20 50 8d	jsr $8d50			jsr 	CheckRightBracket 			; check for )
.98c2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/variable.asm

.98c3					VariableHandler:
.98c3	b1 30		lda ($30),y			lda 	(codePtr),y
.98c5	18		clc				clc
.98c6	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.98c8	85 37		sta $37				sta 	zTemp0+1
.98ca	c8		iny				iny
.98cb	b1 30		lda ($30),y			lda 	(codePtr),y
.98cd	85 36		sta $36				sta 	zTemp0
.98cf	c8		iny				iny
.98d0	18		clc				clc									; copy variable address+3 to mantissa
.98d1	69 03		adc #$03			adc 	#3
.98d3	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.98d6	a5 37		lda $37				lda 	zTemp0+1
.98d8	69 00		adc #$00			adc 	#0
.98da	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.98dd	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.98e0	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.98e3	9e 28 04	stz $0428,x			stz 	NSExponent,x
.98e6	5a		phy				phy
.98e7	a0 02		ldy #$02			ldy 	#2 							; read type
.98e9	b1 36		lda ($36),y			lda 	(zTemp0),y
.98eb	7a		ply				ply
.98ec	29 1c		and #$1c			and 	#NSBTypeMask+NSBIsArray 	; get type information
.98ee	09 20		ora #$20			ora 	#NSBIsReference 			; make a reference.
.98f0	9d 00 04	sta $0400,x			sta 	NSStatus,x
.98f3	29 04		and #$04			and 	#NSBIsArray
.98f5	d0 01		bne $98f8			bne 	_VHArray
.98f7	60		rts				rts
.98f8					_VHArray:
.98f8	e8		inx				inx
.98f9	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger 		; get the 1st index.
.98fc	a9 ff		lda #$ff			lda 	#$FF 						; set Status of X+2 to a duff value so we know if we picked it up.
.98fe	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.9901	b1 30		lda ($30),y			lda 	(codePtr),y
.9903	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.9905	d0 06		bne $990d			bne 	_VHNoSecondIndex
.9907	c8		iny				iny 								; skip the comma
.9908	e8		inx				inx
.9909	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger 		; get the 2nd index.
.990c	ca		dex				dex
.990d					_VHNoSecondIndex:
.990d	ca		dex				dex 								; set X back.
.990e	20 50 8d	jsr $8d50			jsr 	CheckRightBracket 			; and check the right bracket.
.9911	5a		phy				phy 								; save position
.9912	a0 02		ldy #$02			ldy 	#2 							; check first index is not-zero, e.g. array defined
.9914	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9916	f0 6b		beq $9983			beq 	_VHBadIndex
.9918	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy record address to zaTemp
.991b	85 3e		sta $3e				sta 	zaTemp
.991d	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9920	85 3f		sta $3f				sta 	zaTemp+1
.9922	a0 03		ldy #$03			ldy 	#3 							; get the second index - which is 0 if there is one index.
.9924	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9926	f0 02		beq $992a			beq 	_VHHas2Mask
.9928	a9 ff		lda #$ff			lda 	#$FF
.992a					_VHHas2Mask:
.992a	dd 02 04	cmp $0402,x			cmp 	NSStatus+2,x 				; so if they are the same there are the wrong number of indices
.992d	f0 54		beq $9983			beq 	_VHBadIndex
.992f	0a		asl a				asl 	a 							; carry will be set if a second index
.9930	90 09		bcc $993b			bcc 	_VHCheckFirstIndex
.9932	a0 03		ldy #$03			ldy 	#3 			 				; check the 2nd size >= 2nd index
.9934	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9936	dd 0a 04	cmp $040a,x			cmp 	NSMantissa0+2,x
.9939	90 48		bcc $9983			bcc 	_VHBadIndex
.993b					_VHCheckFirstIndex:
.993b	a0 02		ldy #$02			ldy 	#2 			 				; check the 2nd size >= 2nd index
.993d	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.993f	dd 09 04	cmp $0409,x			cmp 	NSMantissa0+1,x
.9942	90 3f		bcc $9983			bcc 	_VHBadIndex
.9944	64 36		stz $36				stz 	zTemp0 						; clear zTemp0 (if 1 index)
.9946	64 37		stz $37				stz 	zTemp0+1
.9948	bd 02 04	lda $0402,x			lda 	NSStatus+2,x 				; if only one index provided, don't need to multiply
.994b	30 0f		bmi $995c			bmi 	_VHNoMultiply
.994d	da		phx				phx
.994e	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; get 2nd index on stack
.9951	48		pha				pha
.9952	a0 02		ldy #$02			ldy 	#2 							; get 1st size in A
.9954	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9956	1a		inc a				inc 	a 							; add 1 for zero base
.9957	fa		plx				plx
.9958	20 c1 9d	jsr $9dc1			jsr 	Multiply8x8 				; calculate -> Z0
.995b	fa		plx				plx
.995c					_VHNoMultiply:
.995c	18		clc				clc
.995d	a5 36		lda $36				lda 	zTemp0
.995f	7d 09 04	adc $0409,x			adc 	NSMantissa0+1,x
.9962	85 36		sta $36				sta 	zTemp0
.9964	a5 37		lda $37				lda 	zTemp0+1
.9966	69 00		adc #$00			adc 	#0
.9968	85 37		sta $37				sta 	zTemp0+1
.996a	bd 00 04	lda $0400,x			lda 	NSStatus,x
.996d	20 f4 84	jsr $84f4			jsr 	ScaleByBaseType
.9970	18		clc				clc
.9971	b2 3e		lda ($3e)			lda 	(zaTemp)
.9973	65 36		adc $36				adc 	zTemp0
.9975	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9978	a0 01		ldy #$01			ldy 	#1
.997a	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.997c	65 37		adc $37				adc 	zTemp0+1
.997e	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9981	7a		ply				ply 								; restore position
.9982	60		rts				rts
.9983					_VHBadIndex:
.9983	a9 17		lda #$17		lda	#23
.9985	4c 69 8d	jmp $8d69		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/abs.asm

.9988					AbsUnary:
.9988	fa		plx				plx 								; restore stack pos
.9989	20 55 9d	jsr $9d55			jsr 	EvaluateNumber 				; get a float or int
.998c	20 50 8d	jsr $8d50			jsr 	CheckRightBracket
.998f	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; clear the sign bit
.9992	29 7f		and #$7f			and 	#$7F
.9994	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9997	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/alloc.asm

.9998					AllocUnary:
.9998	fa		plx				plx 								; restore stack pos
.9999	20 8d 9d	jsr $9d8d			jsr 	Evaluate16BitInteger		; get bytes required.
.999c	20 50 8d	jsr $8d50			jsr 	CheckRightBracket
.999f	da		phx				phx 								; save X/Y
.99a0	5a		phy				phy
.99a1	8a		txa				txa 								; copy X into Y
.99a2	a8		tay				tay
.99a3	b9 10 04	lda $0410,y			lda		NSMantissa1,y 				; get size
.99a6	aa		tax				tax
.99a7	b9 08 04	lda $0408,y			lda 	NSMantissa0,y
.99aa	20 b7 99	jsr $99b7			jsr 	AllocateXABytes 			; allocate memory
.99ad	99 08 04	sta $0408,y			sta 	NSMantissa0,y 				; write address out.
.99b0	8a		txa				txa
.99b1	99 10 04	sta $0410,y			sta 	NSMantissa1,y
.99b4	7a		ply				ply
.99b5	fa		plx				plx
.99b6	60		rts				rts
.99b7					AllocateXABytes:
.99b7	5a		phy				phy
.99b8	ac 8c 04	ldy $048c			ldy 	lowMemPtr 					; push current address on stack and to zTemp0
.99bb	84 36		sty $36				sty 	zTemp0
.99bd	5a		phy				phy
.99be	ac 8d 04	ldy $048d			ldy 	lowMemPtr+1
.99c1	84 37		sty $37				sty 	zTemp0+1
.99c3	5a		phy				phy
.99c4	18		clc				clc 								; add to low memory pointer
.99c5	6d 8c 04	adc $048c			adc 	lowMemPtr
.99c8	8d 8c 04	sta $048c			sta 	lowMemPtr
.99cb	8a		txa				txa
.99cc	6d 8d 04	adc $048d			adc 	lowMemPtr+1
.99cf	8d 8d 04	sta $048d			sta 	lowMemPtr+1
.99d2	b0 2f		bcs $9a03			bcs 	CISSMemory
.99d4	20 f5 99	jsr $99f5			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.99d7					_ClearMemory:
.99d7	ad 8c 04	lda $048c			lda 	lowMemPtr 					; cleared all memory allocated
.99da	c5 36		cmp $36				cmp 	zTemp0
.99dc	d0 07		bne $99e5			bne 	_CMClearNext
.99de	ad 8d 04	lda $048d			lda 	lowMemPtr+1
.99e1	c5 37		cmp $37				cmp 	zTemp0+1
.99e3	f0 0c		beq $99f1			beq 	_CMExit
.99e5					_CMClearNext:
.99e5	a9 00		lda #$00			lda 	#0 							; clear byte, advance to next.
.99e7	92 36		sta ($36)			sta 	(zTemp0)
.99e9	e6 36		inc $36				inc 	zTemp0
.99eb	d0 ea		bne $99d7			bne 	_ClearMemory
.99ed	e6 37		inc $37				inc		zTemp0+1
.99ef	80 e6		bra $99d7			bra 	_ClearMemory
.99f1					_CMExit:
.99f1	fa		plx				plx
.99f2	68		pla				pla
.99f3	7a		ply				ply
.99f4	60		rts				rts
.99f5					CheckIdentifierStringSpace:
.99f5	48		pha				pha
.99f6	ad 8d 04	lda $048d			lda 	lowMemPtr+1 				; get low memory pointer
.99f9	18		clc				clc
.99fa	69 02		adc #$02			adc 	#2 							; need at least 2 256 byte pages
.99fc	cd 8f 04	cmp $048f			cmp 	StringMemory+1 				; is it >= StringMemory
.99ff	b0 02		bcs $9a03			bcs 	CISSMemory
.9a01	68		pla				pla
.9a02	60		rts				rts
.9a03					CISSMemory:
.9a03	a9 06		lda #$06		lda	#6
.9a05	4c 69 8d	jmp $8d69		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/asc.asm

.9a08					AscUnary:
.9a08	fa		plx				plx 								; restore stack pos
.9a09	20 60 9d	jsr $9d60			jsr 	EvaluateString 				; get a string
.9a0c	b2 36		lda ($36)			lda 	(zTemp0)					; get/return firs character
.9a0e	20 2e 9e	jsr $9e2e			jsr 	NSMSetByte
.9a11	20 50 8d	jsr $8d50			jsr 	CheckRightBracket
.9a14	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/frac.asm

.9a15					FracUnary:
.9a15	fa		plx				plx 								; restore stack pos
.9a16	20 55 9d	jsr $9d55			jsr 	EvaluateNumber 				; get a float or int
.9a19	20 50 8d	jsr $8d50			jsr 	CheckRightBracket
.9a1c	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9a1f	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9a21	f0 04		beq $9a27			beq 	_IUZero
.9a23	20 4b 94	jsr $944b			jsr 	FloatFractionalPart
.9a26	60		rts				rts
.9a27					_IUZero:
.9a27	20 2c 9e	jsr $9e2c			jsr 	NSMSetZero
.9a2a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/int.asm

.9a2b					IntUnary:
.9a2b	fa		plx				plx 								; restore stack pos
.9a2c	20 55 9d	jsr $9d55			jsr 	EvaluateNumber 				; get a float or int
.9a2f	20 50 8d	jsr $8d50			jsr 	CheckRightBracket
.9a32	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9a35	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9a37	f0 03		beq $9a3c			beq 	_IUExit
.9a39	20 ae 94	jsr $94ae			jsr 	FloatIntegerPart
.9a3c					_IUExit:
.9a3c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/len.asm

.9a3d					LenUnary:
.9a3d	fa		plx				plx 								; restore stack pos
.9a3e	20 60 9d	jsr $9d60			jsr 	EvaluateString 				; get a string
.9a41	5a		phy				phy
.9a42	a0 00		ldy #$00			ldy 	#0 							; find length
.9a44					_LenFind:
.9a44	b1 36		lda ($36),y			lda 	(zTemp0),y
.9a46	f0 06		beq $9a4e			beq 	_LenExit
.9a48	c8		iny				iny
.9a49	d0 f9		bne $9a44			bne 	_LenFind
.9a4b	4c bb 9f	jmp $9fbb			jmp 	RangeError 					; string > 255
.9a4e					_LenExit:
.9a4e	98		tya				tya
.9a4f	20 2e 9e	jsr $9e2e			jsr 	NSMSetByte
.9a52	7a		ply				ply
.9a53	20 50 8d	jsr $8d50			jsr 	CheckRightBracket
.9a56	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/minmax.asm

.9a57					Unary_Min:
.9a57	a9 01		lda #$01			lda 	#1
.9a59	80 02		bra $9a5d			bra 	UnaryMinMaxMain
.9a5b					Unary_Max:
.9a5b	a9 ff		lda #$ff			lda 	#$FF 						; value from comparator to cause a write
.9a5d					UnaryMinMaxMain:
.9a5d	fa		plx				plx 								; get index on number stack
.9a5e	48		pha				pha 								; save comparator
.9a5f	20 4c 9d	jsr $9d4c			jsr 	EvaluateValue 				; get the first value.
.9a62					_UMMMLoop:
.9a62	b1 30		lda ($30),y			lda 	(codePtr),y
.9a64	c9 29		cmp #$29			cmp 	#KWD_RPAREN 				; if right bracket then done.
.9a66	f0 22		beq $9a8a			beq 	_UMMMDone
.9a68	20 58 8d	jsr $8d58			jsr 	CheckComma 					; must be a comma
.9a6b	e8		inx				inx
.9a6c	20 4c 9d	jsr $9d4c			jsr 	EvaluateValue
.9a6f	ca		dex				dex
.9a70	20 03 9e	jsr $9e03			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] (Compare is destructive)
.9a73	e8		inx				inx
.9a74	20 03 9e	jsr $9e03			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2], original
.9a77	e8		inx				inx
.9a78	20 21 8e	jsr $8e21			jsr 	CompareBaseCode 			; part of > = < etc. code, returns 255,0 or 1
.9a7b	ca		dex				dex
.9a7c	ca		dex				dex
.9a7d	85 36		sta $36				sta 	zTemp0 						; save required result
.9a7f	68		pla				pla 								; get and save comparator
.9a80	48		pha				pha
.9a81	c5 36		cmp $36				cmp 	zTemp0 						; if the comparator
.9a83	d0 dd		bne $9a62			bne 	_UMMMLoop
.9a85	20 8d 9a	jsr $9a8d			jsr 	ExpCopyAboveDown 			; copy next up slot down
.9a88	80 d8		bra $9a62			bra 	_UMMMLoop
.9a8a					_UMMMDone:
.9a8a	68		pla				pla 								; throw the comparator
.9a8b	c8		iny				iny 								; skip )
.9a8c	60		rts				rts
.9a8d					ExpCopyAboveDown:
.9a8d	bd 01 04	lda $0401,x			lda 	NSStatus+1,x
.9a90	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9a93	bd 29 04	lda $0429,x			lda 	NSExponent+1,x
.9a96	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9a99	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.9a9c	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9a9f	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.9aa2	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9aa5	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.9aa8	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9aab	bd 21 04	lda $0421,x			lda 	NSMantissa3+1,x
.9aae	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9ab1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/not.asm

.9ab2					Unary_Not:
.9ab2	fa		plx				plx
.9ab3	20 78 9d	jsr $9d78			jsr 	EvaluateInteger 			; get integer
.9ab6	20 50 8d	jsr $8d50			jsr 	CheckRightBracket
.9ab9	20 5c 9e	jsr $9e5c			jsr 	NSMIsZero 					; zero mantissa ?
.9abc	f0 04		beq $9ac2			beq 	_NotZero
.9abe	20 2c 9e	jsr $9e2c			jsr 	NSMSetZero
.9ac1	60		rts				rts
.9ac2					_NotZero:
.9ac2	4c d6 8d	jmp $8dd6			jmp 	ReturnTrue
.9ac5					_UNBad:
.9ac5	4c c5 9f	jmp $9fc5			jmp 	ArgumentError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/rnd.asm

.9ac8					Unary_Random:
.9ac8	fa		plx				plx
.9ac9	20 47 9b	jsr $9b47			jsr 	Random32Bit 				; get a random number
.9acc	20 2c 9b	jsr $9b2c			jsr 	URCopyToMantissa  			; put in mantissa
.9acf	b1 30		lda ($30),y			lda 	(codePtr),y
.9ad1	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.9ad3	f0 08		beq $9add			beq 	_URNoModulus
.9ad5	e8		inx				inx
.9ad6	20 8d 9d	jsr $9d8d			jsr 	Evaluate16BitInteger 		; put modulus value in +1
.9ad9	ca		dex				dex
.9ada	20 45 8f	jsr $8f45			jsr 	IntegerModulusNoCheck 		; calculate modulus
.9add					_URNoModulus:
.9add	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; make it an integer positive
.9ae0	9e 28 04	stz $0428,x			stz 	NSExponent,x
.9ae3	20 50 8d	jsr $8d50			jsr 	CheckRightBracket
.9ae6	60		rts				rts
.9ae7					Unary_Rnd:
.9ae7	fa		plx				plx
.9ae8	20 55 9d	jsr $9d55			jsr 	EvaluateNumber 				; number to use.
.9aeb	20 50 8d	jsr $8d50			jsr 	CheckRightBracket 			; closing bracket
.9aee	20 5c 9e	jsr $9e5c			jsr 	NSMIsZero 					; if zero, then don't generate a new number
.9af1	f0 2b		beq $9b1e			beq 	_URCopySeed
.9af3	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; if -ve, then seed using parameter
.9af6	10 23		bpl $9b1b			bpl 	_URDontSeed
.9af8	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy - value to seed butchering it.
.9afb	49 17		eor #$17			eor 	#$17
.9afd	8d 88 04	sta $0488			sta 	RandomSeed+0
.9b00	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9b03	49 a5		eor #$a5			eor 	#$A5
.9b05	8d 89 04	sta $0489			sta 	RandomSeed+1
.9b08	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9b0b	49 c2		eor #$c2			eor 	#$C2
.9b0d	8d 8a 04	sta $048a			sta 	RandomSeed+2
.9b10	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9b13	49 9d		eor #$9d			eor 	#$9D
.9b15	8d 8b 04	sta $048b			sta 	RandomSeed+3
.9b18	20 47 9b	jsr $9b47			jsr 	Random32Bit
.9b1b					_URDontSeed:
.9b1b	20 47 9b	jsr $9b47			jsr 	Random32Bit 				; generate a number.
.9b1e					_URCopySeed:
.9b1e	20 2c 9b	jsr $9b2c			jsr 	URCopyToMantissa 			; copy into mantissa
.9b21	a9 e1		lda #$e1			lda 	#-31 						; force into 0-1 range
.9b23	8d 28 04	sta $0428			sta 	NSExponent
.9b26	a9 08		lda #$08			lda 	#NSTFloat
.9b28	8d 00 04	sta $0400			sta 	NSStatus 					; positive.
.9b2b	60		rts				rts
.9b2c					URCopyToMantissa:
.9b2c	ad 88 04	lda $0488			lda 	RandomSeed+0
.9b2f	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9b32	ad 89 04	lda $0489			lda 	RandomSeed+1
.9b35	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9b38	ad 8a 04	lda $048a			lda 	RandomSeed+2
.9b3b	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9b3e	ad 8b 04	lda $048b			lda 	RandomSeed+3
.9b41	29 3f		and #$3f			and 	#$3F 						; make legal mantissa
.9b43	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9b46	60		rts				rts
.9b47					Random32Bit:
.9b47	5a		phy				phy
.9b48	a0 07		ldy #$07			ldy 	#7 							; do it 7 times
.9b4a	ad 88 04	lda $0488			lda 	RandomSeed+0 				; check the seed isn't zero
.9b4d	d0 03		bne $9b52			bne 	_Random1
.9b4f	a8		tay				tay 								; if so do it 256 times
.9b50	a9 aa		lda #$aa			lda		#$AA 						; and use this to seed the seed....
.9b52					_Random1:
.9b52	0a		asl a				asl 	a 							; LSFR RNG
.9b53	2e 89 04	rol $0489			rol 	RandomSeed+1
.9b56	2e 8a 04	rol $048a			rol 	RandomSeed+2
.9b59	2e 8b 04	rol $048b			rol 	RandomSeed+3
.9b5c	90 02		bcc $9b60			bcc 	_Random2
.9b5e	49 c5		eor #$c5			eor 	#$C5
.9b60					_Random2:
.9b60	88		dey				dey
.9b61	d0 ef		bne $9b52			bne 	_Random1
.9b63	8d 88 04	sta $0488			sta 	RandomSeed+0
.9b66	7a		ply				ply
.9b67	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/sgn.asm

.9b68					SgnUnary:
.9b68	fa		plx				plx 								; restore stack pos
.9b69	20 55 9d	jsr $9d55			jsr 	EvaluateNumber 				; get a float or int
.9b6c	20 50 8d	jsr $8d50			jsr 	CheckRightBracket
.9b6f	20 5c 9e	jsr $9e5c			jsr 	NSMIsZero 					; if zero
.9b72	f0 10		beq $9b84			beq 	_SGZero  					; return Int Zero
.9b74	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get status w/sign
.9b77	48		pha				pha
.9b78	a9 01		lda #$01			lda 	#1 							; set to 1
.9b7a	20 2e 9e	jsr $9e2e			jsr 	NSMSetByte
.9b7d	68		pla				pla
.9b7e	29 80		and #$80			and		#$80 						; copy the sign byte out
.9b80	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9b83	60		rts				rts
.9b84	20 2c 9e	jsr $9e2c	_SGZero:jsr 	NSMSetZero
.9b87	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/val.asm

.9b88					ValUnary:
.9b88	fa		plx				plx 								; restore stack pos
.9b89	20 9e 9b	jsr $9b9e			jsr 	ValMainCode 				; do the main val() code
.9b8c	b0 01		bcs $9b8f			bcs 	_VUError 					; couldn't convert
.9b8e	60		rts				rts
.9b8f					_VUError:
.9b8f	4c c0 9f	jmp $9fc0			jmp 	TypeError
.9b92					IsValUnary:
.9b92	fa		plx				plx 								; restore stack pos
.9b93	20 9e 9b	jsr $9b9e			jsr 	ValMainCode 				; do the main val() code
.9b96	b0 03		bcs $9b9b			bcs 	_VUBad
.9b98	4c d6 8d	jmp $8dd6			jmp 	ReturnTrue
.9b9b					_VUBad:
.9b9b	4c e2 8d	jmp $8de2			jmp 	ReturnFalse
.9b9e					ValMainCode:
.9b9e	20 60 9d	jsr $9d60			jsr 	EvaluateString 				; get a string
.9ba1	20 50 8d	jsr $8d50			jsr 	CheckRightBracket 			; check right bracket present
.9ba4	5a		phy				phy
.9ba5	b2 36		lda ($36)			lda 	(zTemp0) 					; check not empty string
.9ba7	f0 17		beq $9bc0			beq 	_VMCFail2
.9ba9	a0 ff		ldy #$ff			ldy 	#$FF 						; start position
.9bab	48		pha				pha 								; save first character
.9bac	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it -
.9bae	d0 01		bne $9bb1			bne 	_VMCStart
.9bb0	c8		iny				iny 								; skip over -
.9bb1					_VMCStart:
.9bb1	38		sec				sec 								; initialise first time round.
.9bb2					_VMCNext:
.9bb2	c8		iny				iny 								; pre-increment
.9bb3	b1 36		lda ($36),y			lda 	(zTemp0),y 					; next character
.9bb5	f0 0c		beq $9bc3			beq 	_VMCSuccess 				; successful.
.9bb7	20 d4 96	jsr $96d4			jsr 	EncodeNumber 				; send it to the number-builder
.9bba	90 03		bcc $9bbf			bcc 	_VMCFail 					; if failed, give up.
.9bbc	18		clc				clc 								; next time round, countinue
.9bbd	80 f3		bra $9bb2			bra 	_VMCNext
.9bbf					_VMCFail:
.9bbf	68		pla				pla
.9bc0					_VMCFail2:
.9bc0	7a		ply				ply
.9bc1	38		sec				sec
.9bc2	60		rts				rts
.9bc3					_VMCSuccess:
.9bc3	a9 00		lda #$00			lda 	#0 							; construct final
.9bc5	20 d4 96	jsr $96d4			jsr 	EncodeNumber
.9bc8	68		pla				pla
.9bc9	c9 2d		cmp #$2d			cmp 	#"-"
.9bcb	d0 03		bne $9bd0			bne 	_VMCNotNegative
.9bcd	20 d8 9d	jsr $9dd8			jsr		NSMNegate
.9bd0					_VMCNotNegative:
.9bd0	7a		ply				ply
.9bd1	18		clc				clc
.9bd2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/chr.asm

.9bd3					ChrUnary:
.9bd3	fa		plx				plx 								; restore stack pos
.9bd4	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger			; get value
.9bd7	48		pha				pha
.9bd8	20 50 8d	jsr $8d50			jsr 	CheckRightBracket
.9bdb	a9 01		lda #$01			lda 	#1 							; allocate space for one char
.9bdd	20 78 a7	jsr $a778			jsr 	StringTempAllocate
.9be0	68		pla				pla 								; write number to it
.9be1	20 b6 a7	jsr $a7b6			jsr 	StringTempWrite
.9be4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/spc.asm

.9be5					SpcUnary:
.9be5	fa		plx				plx 								; restore stack pos
.9be6	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger			; get value
.9be9	5a		phy				phy
.9bea	48		pha				pha 								; save count
.9beb	20 78 a7	jsr $a778			jsr 	StringTempAllocate
.9bee	7a		ply				ply 								; to do count in Y
.9bef					_SpcLoop:
.9bef	c0 00		cpy #$00			cpy 	#0
.9bf1	f0 08		beq $9bfb			beq 	_SpcExit
.9bf3	a9 20		lda #$20			lda 	#32
.9bf5	20 b6 a7	jsr $a7b6			jsr 	StringTempWrite
.9bf8	88		dey				dey
.9bf9	80 f4		bra $9bef			bra 	_SPCLoop
.9bfb					_SpcExit:
.9bfb	7a		ply				ply
.9bfc	20 50 8d	jsr $8d50			jsr 	CheckRightBracket
.9bff	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/str.asm

.9c00					Unary_Str:
.9c00	fa		plx				plx
.9c01	20 55 9d	jsr $9d55			jsr 	EvaluateNumber  			; get number
.9c04	20 50 8d	jsr $8d50			jsr 	CheckRightBracket 			; closing bracket
.9c07	a9 05		lda #$05			lda 	#5 							; maximum decimals, from Basic816
.9c09	20 22 9c	jsr $9c22			jsr 	ConvertNumberToString 		; do the conversion.
.9c0c	a9 21		lda #$21			lda		#33 						; create buffer
.9c0e	20 78 a7	jsr $a778			jsr 	StringTempAllocate 			; allocate memory
.9c11	da		phx				phx
.9c12	a2 00		ldx #$00			ldx 	#0
.9c14					_USCopy:
.9c14	bd 1b 06	lda $061b,x			lda 	DecimalBuffer,x
.9c17	20 b6 a7	jsr $a7b6			jsr 	StringTempWrite
.9c1a	e8		inx				inx
.9c1b	bd 1b 06	lda $061b,x			lda 	DecimalBuffer,x
.9c1e	d0 f4		bne $9c14			bne 	_USCopy
.9c20	fa		plx				plx
.9c21	60		rts				rts
.9c22					ConvertNumberToString:
.9c22	5a		phy				phy 								; save code position
.9c23	8d 94 04	sta $0494			sta 	DecimalPlaces	 			; save number of DPs.
.9c26	9c 95 04	stz $0495			stz 	dbOffset 					; offset into decimal buffer = start.
.9c29	bd 00 04	lda $0400,x			lda 	NSStatus,x  				; is it -ve.
.9c2c	10 0a		bpl $9c38			bpl 	_CNTSNotNegative
.9c2e	29 7f		and #$7f			and 	#$7F 						; make +ve
.9c30	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9c33	a9 2d		lda #$2d			lda 	#"-"
.9c35	20 9e 9c	jsr $9c9e			jsr 	WriteDecimalBuffer
.9c38					_CNTSNotNegative:
.9c38	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if decimal
.9c3b	f0 15		beq $9c52			beq 	_CNTSNotFloat
.9c3d	e8		inx				inx 								; round up
.9c3e	a9 01		lda #$01			lda 	#1
.9c40	20 2e 9e	jsr $9e2e			jsr 	NSMSetByte
.9c43	ca		dex				dex
.9c44	bd 28 04	lda $0428,x			lda		NSExponent,x
.9c47	9d 29 04	sta $0429,x			sta 	NSExponent+1,x
.9c4a	a9 08		lda #$08			lda 	#NSTFloat
.9c4c	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.9c4f	20 65 93	jsr $9365			jsr 	FloatAdd
.9c52					_CNTSNotFloat:
.9c52	20 80 9c	jsr $9c80			jsr 	MakePlusTwoString
.9c55	20 4b 94	jsr $944b			jsr 	FloatFractionalPart 		; get the fractional part
.9c58	20 0f 95	jsr $950f			jsr 	NSNormalise					; normalise , exit if zero
.9c5b	f0 21		beq $9c7e			beq 	_CNTSExit
.9c5d	a9 2e		lda #$2e			lda 	#"."
.9c5f	20 9e 9c	jsr $9c9e			jsr 	WriteDecimalBuffer 			; write decimal place
.9c62					_CNTSDecimal:
.9c62	ce 94 04	dec $0494			dec 	DecimalPlaces 				; done all the decimals
.9c65	30 17		bmi $9c7e			bmi 	_CNTSExit
.9c67	e8		inx				inx 								; x 10.0
.9c68	a9 0a		lda #$0a			lda 	#10
.9c6a	20 2e 9e	jsr $9e2e			jsr 	NSMSetByte
.9c6d	a9 08		lda #$08			lda 	#NSTFloat
.9c6f	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9c72	ca		dex				dex
.9c73	20 d8 94	jsr $94d8			jsr 	FloatMultiply
.9c76	20 80 9c	jsr $9c80			jsr 	MakePlusTwoString
.9c79	20 4b 94	jsr $944b			jsr 	FloatFractionalPart 		; get the fractional part
.9c7c	80 e4		bra $9c62			bra 	_CNTSDecimal 				; keep going.
.9c7e					_CNTSExit:
.9c7e	7a		ply				ply
.9c7f	60		rts				rts
.9c80					MakePlusTwoString:
.9c80	da		phx				phx
.9c81	20 03 9e	jsr $9e03			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.9c84	e8		inx				inx 								; access it
.9c85	e8		inx				inx
.9c86	20 ae 94	jsr $94ae			jsr 	FloatIntegerPart 			; make it an integer
.9c89	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.9c8b	20 90 92	jsr $9290			jsr 	ConvertInt32
.9c8e	a2 00		ldx #$00			ldx	 	#0
.9c90					_MPTSCopy:
.9c90	bd f9 05	lda $05f9,x			lda 	NumberBuffer,x
.9c93	20 9e 9c	jsr $9c9e			jsr 	WriteDecimalBuffer
.9c96	e8		inx				inx
.9c97	bd f9 05	lda $05f9,x			lda 	NumberBuffer,x
.9c9a	d0 f4		bne $9c90			bne 	_MPTSCopy
.9c9c	fa		plx				plx
.9c9d	60		rts				rts
.9c9e					WriteDecimalBuffer:
.9c9e	da		phx				phx
.9c9f	ae 95 04	ldx $0495			ldx 	dbOffset
.9ca2	9d 1b 06	sta $061b,x			sta 	DecimalBuffer,x
.9ca5	9e 1c 06	stz $061c,x			stz 	DecimalBuffer+1,x
.9ca8	ee 95 04	inc $0495			inc 	dbOffset
.9cab	fa		plx				plx
.9cac	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/substring.asm

.9cad					Unary_Left:
.9cad	fa		plx				plx
.9cae	18		clc				clc 								; only one parameter
.9caf	20 24 9d	jsr $9d24			jsr 	SubstringInitial 			; set up.
.9cb2	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; Param #1 is the length
.9cb5	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9cb8	9e 09 04	stz $0409,x			stz 	NSMantissa0+1,x 			; Start is zero.
.9cbb	80 2c		bra $9ce9			bra 	SubstringMain
.9cbd					Unary_Right:
.9cbd	fa		plx				plx
.9cbe	18		clc				clc 								; only one parameter
.9cbf	20 24 9d	jsr $9d24			jsr 	SubstringInitial 			; set up.
.9cc2	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; length => param 2
.9cc5	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9cc8	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; total length
.9ccb	fd 09 04	sbc $0409,x			sbc 	NSMantissa0+1,x 			; length - required.
.9cce	b0 02		bcs $9cd2			bcs 	_URNotUnderflow
.9cd0	a9 00		lda #$00			lda 	#0 							; start from the beginning, as something like right$("AB",3)
.9cd2					_URNotUnderFlow:
.9cd2	9d 09 04	sta $0409,x			sta 	NSMantissa0+1,x 			; this is the start position
.9cd5	80 12		bra $9ce9			bra 	SubStringMain
.9cd7					Unary_Mid:
.9cd7	fa		plx				plx
.9cd8	38		sec				sec 								; two parameters
.9cd9	20 24 9d	jsr $9d24			jsr 	SubstringInitial 			; set up.
.9cdc	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; first parameter is zero ?
.9cdf	f0 05		beq $9ce6			beq 	_UMError
.9ce1	de 09 04	dec $0409,x			dec 	NSMantissa0+1,x				; reduce initial offset by 1 as MID$(a$,1..) is actually the first character
.9ce4	80 03		bra $9ce9			bra 	SubStringMain
.9ce6					_UMError:
.9ce6	4c c5 9f	jmp $9fc5			jmp 	ArgumentError
.9ce9					SubStringMain:
.9ce9	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; is the initial offset >= the length
.9cec	dd 28 04	cmp $0428,x			cmp 	NSExponent,x
.9cef	b0 2d		bcs $9d1e			bcs 	_SSMNull 					; if so, return an empty string.
.9cf1	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; if copy count is zero
.9cf4	f0 28		beq $9d1e			beq 	_SSMNull 					; return empty string.
.9cf6	18		clc				clc 								; add the offset +1 to the address and
.9cf7	bd 08 04	lda $0408,x			lda	 	NSMantissa0,x 				; put in zTemp
.9cfa	7d 09 04	adc $0409,x			adc 	NSMantissa0+1,x
.9cfd	85 36		sta $36				sta 	zTemp0
.9cff	bd 10 04	lda $0410,x			lda	 	NSMantissa1,x
.9d02	69 00		adc #$00			adc 	#0
.9d04	85 37		sta $37				sta 	zTemp0+1
.9d06					_SSMNoCarry:
.9d06	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; characters required.
.9d09	20 78 a7	jsr $a778			jsr 	StringTempAllocate 			; allocate that many characters
.9d0c	5a		phy				phy 								; save Y
.9d0d	a0 00		ldy #$00			ldy 	#0 							; start copying in.
.9d0f					_SSMCopy:
.9d0f	b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next character
.9d11	f0 09		beq $9d1c			beq 	_SSMEString 				; no more to copy
.9d13	20 b6 a7	jsr $a7b6			jsr 	StringTempWrite 			; and write it out.
.9d16	c8		iny				iny
.9d17	de 0a 04	dec $040a,x			dec 	NSMantissa0+2,x
.9d1a	d0 f3		bne $9d0f			bne 	_SSMCopy
.9d1c					_SSMEString:
.9d1c	7a		ply				ply
.9d1d					_SSMExit:
.9d1d	60		rts				rts
.9d1e					_SSMNull:
.9d1e	a9 00		lda #$00			lda 	#0
.9d20	20 78 a7	jsr $a778			jsr 	StringTempAllocate
.9d23	60		rts				rts
.9d24					SubstringInitial:
.9d24	da		phx				phx 								; save initial stack position
.9d25	08		php				php 								; save carry on stack indicating 2 parameters
.9d26	20 60 9d	jsr $9d60			jsr 	EvaluateString 				; get a string
.9d29	5a		phy				phy 								; calculate length to exponent.
.9d2a	a0 ff		ldy #$ff			ldy 	#$FF
.9d2c					_SIFindLength:
.9d2c	c8		iny				iny
.9d2d	b1 36		lda ($36),y			lda 	(zTemp0),y
.9d2f	d0 fb		bne $9d2c			bne 	_SIFindLength
.9d31	98		tya				tya
.9d32	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9d35	7a		ply				ply
.9d36	e8		inx				inx
.9d37	20 58 8d	jsr $8d58			jsr 	CheckComma 					; comma next
.9d3a	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger 		; get next parameter
.9d3d	28		plp				plp 								; is it the last parameter ?
.9d3e	90 07		bcc $9d47			bcc 	_SSIExit 					; if so, exit.
.9d40	e8		inx				inx
.9d41	20 58 8d	jsr $8d58			jsr 	CheckComma 					; comma next
.9d44	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger 		; get last parameter
.9d47					_SSIExit:
.9d47	fa		plx				plx
.9d48	20 50 8d	jsr $8d50			jsr 	CheckRightBracket 			; check closing bracket
.9d4b	60		rts				rts 								; exit

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/exprhelper.asm

.9d4c					EvaluateValue:
.9d4c	48		pha				pha
.9d4d	20 18 93	jsr $9318			jsr		EvaluateExpression 			; expression
.9d50	20 36 96	jsr $9636			jsr 	Dereference					; derefernce it
.9d53	68		pla				pla
.9d54	60		rts				rts
.9d55					EvaluateNumber:
.9d55	20 4c 9d	jsr $9d4c			jsr 	EvaluateValue 				; get a value
.9d58	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if string.
.9d5b	29 10		and #$10			and 	#NSBIsString
.9d5d	d0 16		bne $9d75			bne 	HelperTypeError
.9d5f	60		rts				rts
.9d60					EvaluateString:
.9d60	20 4c 9d	jsr $9d4c			jsr 	EvaluateValue 				; get a value
.9d63	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if string.
.9d66	29 10		and #$10			and 	#NSBIsString
.9d68	f0 0b		beq $9d75			beq 	HelperTypeError
.9d6a					CopyAddressToTemp0:
.9d6a	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address -> zTemp0
.9d6d	85 36		sta $36				sta 	zTemp0
.9d6f	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9d72	85 37		sta $37				sta 	zTemp0+1
.9d74	60		rts				rts
.9d75					HelperTypeError:
.9d75	4c c0 9f	jmp $9fc0			jmp 	TypeError
.9d78					EvaluateInteger:
.9d78	20 55 9d	jsr $9d55			jsr 	EvaluateNumber
.9d7b	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check exponent is zero
.9d7e	d0 0a		bne $9d8a			bne 	HelperValueError 			; if not, it's a float.
.9d80	60		rts				rts
.9d81					EvaluateUnsignedInteger:
.9d81	20 78 9d	jsr $9d78			jsr 	EvaluateInteger 			; check integer is +ve
.9d84	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9d87	30 01		bmi $9d8a			bmi 	HelperValueError
.9d89	60		rts				rts
.9d8a					HelperValueError:
.9d8a	4c c5 9f	jmp $9fc5			jmp 	ArgumentError
.9d8d					Evaluate16BitInteger:
.9d8d	20 81 9d	jsr $9d81			jsr	 	EvaluateUnsignedInteger		; get integer
.9d90	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9d93	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9d96	d0 f2		bne $9d8a			bne 	HelperValueError
.9d98	60		rts				rts
.9d99					Evaluate16BitIntegerSigned:
.9d99	20 78 9d	jsr $9d78			jsr	 	EvaluateInteger				; get integer
.9d9c	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9d9f	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9da2	d0 e6		bne $9d8a			bne 	HelperValueError
.9da4	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; signed ?
.9da7	10 03		bpl $9dac			bpl 	_EISNotSigned
.9da9	20 e1 9d	jsr $9de1			jsr 	NSMNegateMantissa
.9dac					_EISNotSigned:
.9dac	60		rts				rts
.9dad					Evaluate8BitInteger:
.9dad	20 81 9d	jsr $9d81			jsr	 	EvaluateUnsignedInteger 	; get an integer
.9db0	d0 d8		bne $9d8a			bne 	HelperValueError
.9db2	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 1, 2 & 3 must be zero
.9db5	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9db8	1d 10 04	ora $0410,x			ora 	NSMantissa1,x
.9dbb	d0 cd		bne $9d8a			bne 	HelperValueError
.9dbd	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9dc0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/mult8x8.asm

.9dc1					Multiply8x8:
.9dc1	4a		lsr a		  		lsr 	a  							; prime the carry bit for the loop
.9dc2	85 36		sta $36			  	sta 	zTemp0
.9dc4	86 37		stx $37				stx 	zTemp0+1
.9dc6	a9 00		lda #$00			lda 	#0
.9dc8	a2 08		ldx #$08			ldx 	#8
.9dca					_M88Loop:
.9dca	90 03		bcc $9dcf			bcc 	_M88NoAdd
.9dcc	18		clc				clc
.9dcd	65 37		adc $37				adc 	zTemp0+1
.9dcf					_M88NoAdd:
.9dcf	6a		ror a				ror 	a
.9dd0	66 36		ror $36				ror 	zTemp0  					; pull another bit out for the next iteration
.9dd2	ca		dex				dex         						; inc/dec don't modify carry; only shifts and adds do
.9dd3	d0 f5		bne $9dca			bne 	_M88Loop
.9dd5	85 37		sta $37				sta 	zTemp0+1 					; store high 8 bits.
.9dd7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/utility.asm

.9dd8					NSMNegate:
.9dd8	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9ddb	49 80		eor #$80			eor 	#NSBIsNegative
.9ddd	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9de0	60		rts				rts
.9de1					NSMNegateMantissa:
.9de1	38		sec				sec
.9de2	a9 00		lda #$00			lda 	#0
.9de4	fd 08 04	sbc $0408,x			sbc 	NSMantissa0,x
.9de7	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9dea	a9 00		lda #$00			lda 	#0
.9dec	fd 10 04	sbc $0410,x			sbc 	NSMantissa1,x
.9def	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9df2	a9 00		lda #$00			lda 	#0
.9df4	fd 18 04	sbc $0418,x			sbc 	NSMantissa2,x
.9df7	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9dfa	a9 00		lda #$00			lda 	#0
.9dfc	fd 20 04	sbc $0420,x			sbc 	NSMantissa3,x
.9dff	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9e02	60		rts				rts
.9e03					NSMShiftUpTwo:
.9e03	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9e06	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9e09	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9e0c	9d 12 04	sta $0412,x			sta 	NSMantissa1+2,x
.9e0f	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9e12	9d 1a 04	sta $041a,x			sta 	NSMantissa2+2,x
.9e15	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9e18	9d 22 04	sta $0422,x			sta 	NSMantissa3+2,x
.9e1b	bd 28 04	lda $0428,x			lda 	NSExponent,x
.9e1e	9d 2a 04	sta $042a,x			sta 	NSExponent+2,x
.9e21	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9e24	9d 02 04	sta $0402,x			sta 	NSStatus+2,x
.9e27	60		rts				rts
.9e28					NSMSetZeroMantissaOnly:
.9e28	a9 00		lda #$00			lda 	#0
.9e2a	80 08		bra $9e34			bra 	NSMSetMantissa
.9e2c					NSMSetZero:
.9e2c	a9 00		lda #$00			lda 	#0
.9e2e					NSMSetByte:
.9e2e	9e 28 04	stz $0428,x			stz 	NSExponent,x 				; zero exponent, as integer.
.9e31	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; status zero (integer)
.9e34					NSMSetMantissa:
.9e34	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; mantissa
.9e37	9e 10 04	stz $0410,x			stz 	NSMantissa1,x
.9e3a	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.9e3d	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.9e40	60		rts				rts
.9e41					NSMShiftLeft:
.9e41	18		clc				clc
.9e42					NSMRotateLeft:
.9e42	3e 08 04	rol $0408,x			rol 	NSMantissa0,x
.9e45	3e 10 04	rol $0410,x			rol		NSMantissa1,x
.9e48	3e 18 04	rol $0418,x			rol		NSMantissa2,x
.9e4b	3e 20 04	rol $0420,x			rol		NSMantissa3,x
.9e4e	60		rts				rts
.9e4f					NSMShiftRight:
.9e4f	5e 20 04	lsr $0420,x			lsr 	NSMantissa3,x
.9e52	7e 18 04	ror $0418,x			ror		NSMantissa2,x
.9e55	7e 10 04	ror $0410,x			ror		NSMantissa1,x
.9e58	7e 08 04	ror $0408,x			ror		NSMantissa0,x
.9e5b	60		rts				rts
.9e5c					NSMIsZero:
.9e5c	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9e5f	1d 18 04	ora $0418,x			ora		NSMantissa2,x
.9e62	1d 10 04	ora $0410,x			ora		NSMantissa1,x
.9e65	1d 08 04	ora $0408,x			ora		NSMantissa0,x
.9e68	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.asm

.b9db					TickHandler:
.b9db	5a		phy				phy 								; need to preserve Y
.b9dc	20 81 b9	jsr $b981			jsr 	SNDUpdate 					; update sound
.b9df	7a		ply				ply
.b9e0	60		rts				rts
.062d					LastTick:
>062d							.fill 		1

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/asmcore.asm

.9e69					Assemble_ora:
.9e69	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9e6c	01					.byte $01
.9e6d					Assemble_and:
.9e6d	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9e70	21					.byte $21
.9e71					Assemble_eor:
.9e71	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9e74	41					.byte $41
.9e75					Assemble_adc:
.9e75	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9e78	61					.byte $61
.9e79					Assemble_sta:
.9e79	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9e7c	81					.byte $81
.9e7d					Assemble_lda:
.9e7d	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9e80	a1					.byte $a1
.9e81					Assemble_cmp:
.9e81	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9e84	c1					.byte $c1
.9e85					Assemble_sbc:
.9e85	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9e88	e1					.byte $e1
.9e89					Assemble_asl:
.9e89	20 72 80	jsr $8072		jsr	AssembleGroup2
>9e8c	02					.byte $02
>9e8d	75					.byte $75
.9e8e					Assemble_rol:
.9e8e	20 72 80	jsr $8072		jsr	AssembleGroup2
>9e91	22					.byte $22
>9e92	75					.byte $75
.9e93					Assemble_lsr:
.9e93	20 72 80	jsr $8072		jsr	AssembleGroup2
>9e96	42					.byte $42
>9e97	75					.byte $75
.9e98					Assemble_ror:
.9e98	20 72 80	jsr $8072		jsr	AssembleGroup2
>9e9b	62					.byte $62
>9e9c	75					.byte $75
.9e9d					Assemble_stx:
.9e9d	20 72 80	jsr $8072		jsr	AssembleGroup2
>9ea0	82					.byte $82
>9ea1	50					.byte $50
.9ea2					Assemble_ldx:
.9ea2	20 72 80	jsr $8072		jsr	AssembleGroup2
>9ea5	a2					.byte $a2
>9ea6	d0					.byte $d0
.9ea7					Assemble_dec:
.9ea7	20 72 80	jsr $8072		jsr	AssembleGroup2
>9eaa	c2					.byte $c2
>9eab	55					.byte $55
.9eac					Assemble_inc:
.9eac	20 72 80	jsr $8072		jsr	AssembleGroup2
>9eaf	e2					.byte $e2
>9eb0	55					.byte $55
.9eb1					Assemble_stz:
.9eb1	20 72 80	jsr $8072		jsr	AssembleGroup2
>9eb4	60					.byte $60
>9eb5	44					.byte $44
.9eb6					Assemble_bit:
.9eb6	20 72 80	jsr $8072		jsr	AssembleGroup2
>9eb9	20					.byte $20
>9eba	55					.byte $55
.9ebb					Assemble_sty:
.9ebb	20 72 80	jsr $8072		jsr	AssembleGroup2
>9ebe	80					.byte $80
>9ebf	54					.byte $54
.9ec0					Assemble_ldy:
.9ec0	20 72 80	jsr $8072		jsr	AssembleGroup2
>9ec3	a0					.byte $a0
>9ec4	d5					.byte $d5
.9ec5					Assemble_cpy:
.9ec5	20 72 80	jsr $8072		jsr	AssembleGroup2
>9ec8	c0					.byte $c0
>9ec9	d4					.byte $d4
.9eca					Assemble_cpx:
.9eca	20 72 80	jsr $8072		jsr	AssembleGroup2
>9ecd	e0					.byte $e0
>9ece	d0					.byte $d0
.9ecf					Assemble_tsb:
.9ecf	20 72 80	jsr $8072		jsr	AssembleGroup2
>9ed2	00					.byte $00
>9ed3	50					.byte $50
.9ed4					Assemble_trb:
.9ed4	20 72 80	jsr $8072		jsr	AssembleGroup2
>9ed7	10					.byte $10
>9ed8	50					.byte $50
.9ed9					Assemble_jsr:
.9ed9	20 72 80	jsr $8072		jsr	AssembleGroup2
>9edc	14					.byte $14
>9edd	10					.byte $10
.9ede					Assemble_jmp:
.9ede	20 72 80	jsr $8072		jsr	AssembleGroup2
>9ee1	40					.byte $40
>9ee2	10					.byte $10
.9ee3					Assemble_bpl:
.9ee3	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9ee6	10					.byte $10
.9ee7					Assemble_bmi:
.9ee7	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9eea	30					.byte $30
.9eeb					Assemble_bvc:
.9eeb	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9eee	50					.byte $50
.9eef					Assemble_bvs:
.9eef	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9ef2	70					.byte $70
.9ef3					Assemble_bcc:
.9ef3	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9ef6	90					.byte $90
.9ef7					Assemble_bcs:
.9ef7	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9efa	b0					.byte $b0
.9efb					Assemble_bne:
.9efb	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9efe	d0					.byte $d0
.9eff					Assemble_beq:
.9eff	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9f02	f0					.byte $f0
.9f03					Assemble_bra:
.9f03	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9f06	80					.byte $80
.9f07					Assemble_brk:
.9f07	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f0a	00					.byte $00
.9f0b					Assemble_php:
.9f0b	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f0e	08					.byte $08
.9f0f					Assemble_clc:
.9f0f	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f12	18					.byte $18
.9f13					Assemble_plp:
.9f13	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f16	28					.byte $28
.9f17					Assemble_sec:
.9f17	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f1a	38					.byte $38
.9f1b					Assemble_rti:
.9f1b	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f1e	40					.byte $40
.9f1f					Assemble_pha:
.9f1f	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f22	48					.byte $48
.9f23					Assemble_cli:
.9f23	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f26	58					.byte $58
.9f27					Assemble_phy:
.9f27	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f2a	5a					.byte $5a
.9f2b					Assemble_rts:
.9f2b	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f2e	60					.byte $60
.9f2f					Assemble_pla:
.9f2f	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f32	68					.byte $68
.9f33					Assemble_sei:
.9f33	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f36	78					.byte $78
.9f37					Assemble_ply:
.9f37	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f3a	7a					.byte $7a
.9f3b					Assemble_dey:
.9f3b	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f3e	88					.byte $88
.9f3f					Assemble_txa:
.9f3f	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f42	8a					.byte $8a
.9f43					Assemble_tya:
.9f43	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f46	98					.byte $98
.9f47					Assemble_txs:
.9f47	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f4a	9a					.byte $9a
.9f4b					Assemble_tay:
.9f4b	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f4e	a8					.byte $a8
.9f4f					Assemble_tax:
.9f4f	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f52	aa					.byte $aa
.9f53					Assemble_clv:
.9f53	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f56	b8					.byte $b8
.9f57					Assemble_tsx:
.9f57	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f5a	ba					.byte $ba
.9f5b					Assemble_iny:
.9f5b	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f5e	c8					.byte $c8
.9f5f					Assemble_dex:
.9f5f	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f62	ca					.byte $ca
.9f63					Assemble_cld:
.9f63	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f66	d8					.byte $d8
.9f67					Assemble_phx:
.9f67	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f6a	da					.byte $da
.9f6b					Assemble_stp:
.9f6b	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f6e	db					.byte $db
.9f6f					Assemble_inx:
.9f6f	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f72	e8					.byte $e8
.9f73					Assemble_nop:
.9f73	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f76	ea					.byte $ea
.9f77					Assemble_sed:
.9f77	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f7a	f8					.byte $f8
.9f7b					Assemble_plx:
.9f7b	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f7e	fa					.byte $fa

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/constants.asm

.9f7f					DecimalScalarTable:
>9f7f	66 66 66 66				.dword $66666666 ; 0.1
>9f83	de					.byte $de
>9f84	1f 85 eb 51				.dword $51eb851f ; 0.01
>9f88	db					.byte $db
>9f89	4c 37 89 41				.dword $4189374c ; 0.001
>9f8d	d8					.byte $d8
>9f8e	ac 8b db 68				.dword $68db8bac ; 0.0001
>9f92	d4					.byte $d4
>9f93	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>9f97	d1					.byte $d1
>9f98	83 de 1b 43				.dword $431bde83 ; 1e-06
>9f9c	ce					.byte $ce
>9f9d	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>9fa1	ca					.byte $ca
>9fa2	89 3b e6 55				.dword $55e63b89 ; 1e-08
>9fa6	c7					.byte $c7
>9fa7	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>9fab	c4					.byte $c4
>9fac	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>9fb0	c0					.byte $c0
>9fb1	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>9fb5	bd					.byte $bd

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.asm

.9fb6					SyntaxError:
.9fb6	a9 02		lda #$02		lda	#2
.9fb8	4c 69 8d	jmp $8d69		jmp	ErrorHandler
.9fbb					RangeError:
.9fbb	a9 04		lda #$04		lda	#4
.9fbd	4c 69 8d	jmp $8d69		jmp	ErrorHandler
.9fc0					TypeError:
.9fc0	a9 05		lda #$05		lda	#5
.9fc2	4c 69 8d	jmp $8d69		jmp	ErrorHandler
.9fc5					ArgumentError:
.9fc5	a9 07		lda #$07		lda	#7
.9fc7	4c 69 8d	jmp $8d69		jmp	ErrorHandler
.9fca					NotDoneError:
.9fca	a9 0c		lda #$0c		lda	#12
.9fcc	4c 69 8d	jmp $8d69		jmp	ErrorHandler
.9fcf					ErrorText:
>9fcf	42 72 65 61 6b 00			.text	"Break",0
>9fd5	53 79 6e 74 61 78 20 65			.text	"Syntax error",0
>9fdd	72 72 6f 72 00
>9fe2	44 69 76 69 73 69 6f 6e			.text	"Division by zero",0
>9fea	20 62 79 20 7a 65 72 6f 00
>9ff3	4f 75 74 20 6f 66 20 52			.text	"Out of Range",0
>9ffb	61 6e 67 65 00
>a000	54 79 70 65 20 6d 69 73			.text	"Type mismatch",0
>a008	6d 61 74 63 68 00
>a00e	4f 75 74 20 6f 66 20 6d			.text	"Out of memory",0
>a016	65 6d 6f 72 79 00
>a01c	49 6c 6c 65 67 61 6c 20			.text	"Illegal argument",0
>a024	61 72 67 75 6d 65 6e 74 00
>a02d	53 74 6f 70 00				.text	"Stop",0
>a032	53 74 72 69 6e 67 20 74			.text	"String too long",0
>a03a	6f 6f 20 6c 6f 6e 67 00
>a042	41 73 73 65 72 74 69 6f			.text	"Assertion failed",0
>a04a	6e 20 66 61 69 6c 65 64 00
>a053	4f 75 74 20 6f 66 20 64			.text	"Out of data",0
>a05b	61 74 61 00
>a05f	55 6e 69 6d 70 6c 65 6d			.text	"Unimplemented",0
>a067	65 6e 74 65 64 00
>a06d	4e 6f 20 73 75 63 68 20			.text	"No such line number",0
>a075	6c 69 6e 65 20 6e 75 6d 62 65 72 00
>a081	52 65 74 75 72 6e 20 77			.text	"Return without Gosub",0
>a089	69 74 68 6f 75 74 20 47 6f 73 75 62 00
>a096	55 6e 74 69 6c 20 77 69			.text	"Until without Repeat",0
>a09e	74 68 6f 75 74 20 52 65 70 65 61 74 00
>a0ab	57 65 6e 64 20 77 69 74			.text	"Wend without While",0
>a0b3	68 6f 75 74 20 57 68 69 6c 65 00
>a0be	4e 65 78 74 20 77 69 74			.text	"Next without For",0
>a0c6	68 6f 75 74 20 46 6f 72 00
>a0cf	42 41 53 49 43 20 53 74			.text	"BASIC Stack full",0
>a0d7	61 63 6b 20 66 75 6c 6c 00
>a0e0	4f 70 65 6e 20 53 74 72			.text	"Open Structure",0
>a0e8	75 63 74 75 72 65 00
>a0ef	45 6e 64 50 72 6f 63 20			.text	"EndProc without call",0
>a0f7	77 69 74 68 6f 75 74 20 63 61 6c 6c 00
>a104	41 72 72 61 79 20 61 6c			.text	"Array already defined",0
>a10c	72 65 61 64 79 20 64 65 66 69 6e 65 64 00
>a11a	41 72 72 61 79 20 73 69			.text	"Array size",0
>a122	7a 65 00
>a125	42 61 64 20 61 72 72 61			.text	"Bad array index",0
>a12d	79 20 69 6e 64 65 78 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/timestamp.asm

>a135	42 75 69 6c 74 20 4d 6f			.text "Built Monday 21-Nov-2022. Build 3478."
>a13d	6e 64 61 79 20 32 31 2d 4e 6f 76 2d 32 30 32 32
>a14d	2e 20 42 75 69 6c 64 20 33 34 37 38 2e

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcommand.asm

.a15a					RectangleCommand:
.a15a	a9 44		lda #$44			lda 	#GCMD_FrameRect				; frame rectangle
.a15c	80 02		bra $a160			bra 	ShapeDrawCmd
.a15e					CircleCommand:
.a15e	a9 48		lda #$48			lda 	#GCMD_FrameCircle 				; framed circle
.a160					ShapeDrawCmd:
.a160	20 ee a1	jsr $a1ee			jsr 	RunGraphicsCommand
.a163					ShapeDraw:
.a163	0d 2f 06	ora $062f			ora 	gxFillSolid  				; adjust AXY for solid fill.
.a166	4c e2 a1	jmp $a1e2			jmp 	ExecuteGraphicCommand	 	; and complete
.a169					SpriteCommand:
.a169	a2 00		ldx #$00			ldx 	#0
.a16b	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger 		; get image number.
.a16e	5a		phy				phy
.a16f	a9 0e		lda #$0e			lda 	#GCMD_SpriteUse 			; use that image.
.a171	ae 08 04	ldx $0408			ldx 	NSMantissa0
.a174	e0 40		cpx #$40			cpx 	#64 						; 0-63 only
.a176	b0 0d		bcs $a185			bcs 	_SCRange
.a178	a0 ff		ldy #$ff			ldy 	#255
.a17a	20 c5 aa	jsr $aac5			jsr 	GXGraphicDraw
.a17d	a9 52		lda #$52			lda 	#GCMD_SpriteMove
.a17f	7a		ply				ply
.a180	20 ee a1	jsr $a1ee			jsr 	RunGraphicsCommand
.a183	80 5d		bra $a1e2			bra 	ExecuteGraphicCommand
.a185					_SCRange:
.a185	4c bb 9f	jmp $9fbb			jmp 	RangeError
.a188					ImageCommand:
.a188	a2 00		ldx #$00			ldx 	#0
.a18a	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger 		; get image number.
.a18d	20 ee a1	jsr $a1ee			jsr 	RunGraphicsCommand
.a190					ImageRunDraw:
.a190	09 40		ora #$40			ora 	#GCMD_Move					; move cursor
.a192	20 c5 aa	jsr $aac5			jsr 	GXGraphicDraw
.a195	ad 35 06	lda $0635			lda 	gxDrawScale
.a198	0a		asl a				asl 	a
.a199	0a		asl a				asl 	a
.a19a	0a		asl a				asl 	a
.a19b	a8		tay				tay
.a19c	a9 0c		lda #$0c			lda 	#GCMD_DrawSprite 			; image drawing
.a19e	ae 08 04	ldx $0408			ldx 	NSMantissa0
.a1a1	20 c5 aa	jsr $aac5			jsr 	GXGraphicDraw
.a1a4	60		rts				rts
.a1a5					TextCommand:
.a1a5	a2 00		ldx #$00			ldx 	#0
.a1a7	20 60 9d	jsr $9d60			jsr 	EvaluateString 				; get text
.a1aa	20 ee a1	jsr $a1ee			jsr 	RunGraphicsCommand
.a1ad					TextRunDraw:
.a1ad	09 40		ora #$40			ora 	#GCMD_Move 					; move cursor
.a1af	20 c5 aa	jsr $aac5			jsr 	GXGraphicDraw
.a1b2	a0 00		ldy #$00			ldy 	#0
.a1b4					_IRDLoop:
.a1b4	ad 10 04	lda $0410			lda 	NSMantissa1 				; access character
.a1b7	85 37		sta $37				sta 	zTemp0+1
.a1b9	ad 08 04	lda $0408			lda 	NSMantissa0
.a1bc	85 36		sta $36				sta 	zTemp0
.a1be	b1 36		lda ($36),y			lda 	(zTemp0),y
.a1c0	f0 13		beq $a1d5			beq 	_IRDExit
.a1c2	5a		phy				phy									; save string pos
.a1c3	48		pha				pha 								; save char
.a1c4	ad 35 06	lda $0635			lda 	gxDrawScale 				; get scale
.a1c7	0a		asl a				asl 	a
.a1c8	0a		asl a				asl 	a
.a1c9	0a		asl a				asl 	a
.a1ca	a8		tay				tay
.a1cb	a9 0a		lda #$0a			lda 	#GCMD_DrawFont 				; char drawing
.a1cd	fa		plx				plx 								; char to draw
.a1ce	20 c5 aa	jsr $aac5			jsr 	GXGraphicDraw
.a1d1	7a		ply				ply 								; restore string pos
.a1d2	c8		iny				iny
.a1d3	90 df		bcc $a1b4			bcc 	_IRDLoop 					; go back if no error.
.a1d5					_IRDExit:
.a1d5	60		rts				rts
.a1d6					PlotCommand:
.a1d6	a9 50		lda #$50			lda 	#GCMD_Plot 					; command ID to use
.a1d8	20 ee a1	jsr $a1ee			jsr 	RunGraphicsCommand
.a1db	80 05		bra $a1e2			bra 	ExecuteGraphicCommand
.a1dd					LineCommand:
.a1dd	a9 42		lda #$42			lda 	#GCMD_Line 						; command ID to use
.a1df	20 ee a1	jsr $a1ee			jsr 	RunGraphicsCommand
.a1e2					ExecuteGraphicCommand:
.a1e2	0d 2e 06	ora $062e			ora 	gxCommandID 				; make a full command
.a1e5	20 c5 aa	jsr $aac5			jsr 	GXGraphicDraw 				; draw it and exit
.a1e8	b0 01		bcs $a1eb			bcs 	_EGCError
.a1ea	60		rts				rts
.a1eb					_EGCError:
.a1eb	4c b6 9f	jmp $9fb6			jmp 	SyntaxError
.a1ee					RunGraphicsCommand:
.a1ee	8d 2e 06	sta $062e			sta 	gxCommandID					; save TODO graphics command.
.a1f1	68		pla				pla 								; pop handler address
.a1f2	fa		plx				plx
.a1f3	1a		inc a				inc 	a
.a1f4	d0 01		bne $a1f7			bne 	_RGINoCarry
.a1f6	e8		inx				inx
.a1f7					_RGINoCarry:
.a1f7	8d 33 06	sta $0633			sta 	GXHandler
.a1fa	8e 34 06	stx $0634			stx 	GXHandler+1
.a1fd					_RGICommandLoop:
.a1fd	b1 30		lda ($30),y			lda 	(codePtr),y
.a1ff	c8		iny				iny
.a200	c9 cd		cmp #$cd			cmp 	#KWD_TO						; is it TO x,y
.a202	f0 53		beq $a257			beq 	_RGI_To
.a204	c9 ba		cmp #$ba			cmp 	#KWD_HERE 					; do it here.
.a206	f0 55		beq $a25d			beq 	_RGI_Here
.a208	c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL or : , exit
.a20a	f0 3d		beq $a249			beq 	_RGI_Exit
.a20c	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.a20e	f0 39		beq $a249			beq 	_RGI_Exit
.a210	c9 c1		cmp #$c1			cmp 	#KWD_OUTLINE 				; solid or outline
.a212	f0 3e		beq $a252			beq 	_RGI_Frame
.a214	c9 c9		cmp #$c9			cmp 	#KWD_SOLID
.a216	f0 33		beq $a24b			beq 	_RGI_Solid
.a218	c9 ab		cmp #$ab			cmp 	#KWD_BY 					; by offset
.a21a	f0 4b		beq $a267			beq 	_RGI_By
.a21c	c9 b6		cmp #$b6			cmp 	#KWD_FROM 					; from
.a21e	f0 17		beq $a237			beq 	_RGI_Move2
.a220	c9 b3		cmp #$b3			cmp 	#KWD_DIM 					; dim (set scale)
.a222	f0 65		beq $a289			beq 	_RGI_Dim
.a224	c9 b1		cmp #$b1			cmp 	#KWD_COLOUR 				; colour or Color
.a226	f0 78		beq $a2a0			beq 	_RGI_Colour
.a228	c9 b0		cmp #$b0			cmp 	#KWD_COLOR
.a22a	f0 74		beq $a2a0			beq 	_RGI_Colour
.a22c	ae 2e 06	ldx $062e			ldx 	gxCommandID
.a22f	e0 52		cpx #$52			cpx 	#GCMD_SpriteMove 			; if not sprite
.a231	d0 03		bne $a236			bne 	_RGI_Move 					; move
.a233	4c ca a2	jmp $a2ca			jmp		_RGI_SpriteInstructions
.a236					_RGI_Move:
.a236	88		dey				dey 								; unpick get.
.a237					_RGI_Move2:
.a237	20 f0 a2	jsr $a2f0			jsr 	GCGetCoordinatePair 		; move to here
.a23a	20 17 a3	jsr $a317			jsr 	GCCopyPairToStore 			; save
.a23d	5a		phy				phy
.a23e	20 0d a3	jsr $a30d			jsr 	GCLoadAXY 					; load in
.a241	09 40		ora #$40			ora 	#GCMD_Move 					; move there
.a243	20 c5 aa	jsr $aac5			jsr 	GXGraphicDraw
.a246	7a		ply				ply
.a247	80 b4		bra $a1fd			bra 	_RGICommandLoop 			; and go round
.a249					_RGI_Exit:
.a249	88		dey				dey 								; unpick : / EOL
.a24a	60		rts				rts
.a24b					_RGI_Solid:
.a24b	a9 02		lda #$02			lda 	#2
.a24d	8d 2f 06	sta $062f			sta 	gxFillSolid
.a250	80 ab		bra $a1fd			bra 	_RGICommandLoop
.a252					_RGI_Frame:
.a252	9c 2f 06	stz $062f			stz 	gxFillSolid
.a255	80 a6		bra $a1fd			bra 	_RGICommandLoop
.a257					_RGI_To:
.a257	20 f0 a2	jsr $a2f0			jsr 	GCGetCoordinatePair 		; get coordinate pair into slot #1,#2
.a25a	20 17 a3	jsr $a317			jsr 	GCCopyPairToStore
.a25d					_RGI_Here:
.a25d	5a		phy				phy
.a25e	20 0d a3	jsr $a30d			jsr 	GCLoadAXY 					; load it into AXY
.a261	20 c7 a2	jsr $a2c7			jsr 	_RGICallHandler 			; go do whatever it is.
.a264	7a		ply				ply
.a265	80 96		bra $a1fd			bra 	_RGICommandLoop 			; and go round
.a267					_RGI_By:
.a267	20 fd a2	jsr $a2fd			jsr 	GCSignedCoordinatePair 		; get coordinate pair into slot #1,#2
.a26a	18		clc				clc
.a26b	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; copy it into space.
.a26e	6d 30 06	adc $0630			adc 	gxxPos
.a271	8d 30 06	sta $0630			sta 	gxXPos
.a274	ad 11 04	lda $0411			lda 	NSMantissa1+1
.a277	6d 31 06	adc $0631			adc 	gxxPos+1
.a27a	8d 31 06	sta $0631			sta 	gxXPos+1
.a27d	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a280	18		clc				clc
.a281	6d 32 06	adc $0632			adc 	gxYPos
.a284	8d 32 06	sta $0632			sta 	gxYPos
.a287	80 d4		bra $a25d			bra 	_RGI_Here
.a289					_RGI_Dim:
.a289	a2 01		ldx #$01			ldx	 	#1
.a28b	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger
.a28e	ad 09 04	lda $0409			lda 	NSMantissa0+1
.a291	c9 00		cmp #$00			cmp 	#0
.a293	f0 2f		beq $a2c4			beq 	_RGIRange
.a295	c9 09		cmp #$09			cmp 	#8+1
.a297	b0 2b		bcs $a2c4			bcs		_RGIRange
.a299	3a		dec a				dec 	a
.a29a	8d 35 06	sta $0635			sta 	gxDrawScale
.a29d	4c fd a1	jmp $a1fd			jmp 	_RGICommandLoop
.a2a0					_RGI_Colour:
.a2a0	a2 01		ldx #$01			ldx 	#1 							; colour
.a2a2	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger
.a2a5	a2 02		ldx #$02			ldx 	#2 							; default zero for 2nd parameter
.a2a7	20 2c 9e	jsr $9e2c			jsr 	NSMSetZero
.a2aa	b1 30		lda ($30),y			lda 	(codePtr),y
.a2ac	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; check , => mode.
.a2ae	d0 04		bne $a2b4			bne 	_RGICDefaultMode
.a2b0	c8		iny				iny
.a2b1	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger
.a2b4					_RGICDefaultMode:
.a2b4	5a		phy				phy
.a2b5	a9 08		lda #$08			lda 	#GCMD_Colour 				; set colour.
.a2b7	ae 09 04	ldx $0409			ldx 	NSMantissa0+1
.a2ba	ac 0a 04	ldy $040a			ldy 	NSMantissa0+2
.a2bd	20 c5 aa	jsr $aac5			jsr 	GXGraphicDraw
.a2c0	7a		ply				ply
.a2c1	4c fd a1	jmp $a1fd			jmp 	_RGICommandLoop 			; and go round
.a2c4					_RGIRange:
.a2c4	4c bb 9f	jmp $9fbb			jmp 	RangeError
.a2c7					_RGICallHandler:
.a2c7	6c 33 06	jmp ($0633)			jmp 	(GXHandler)
.a2ca					_RGI_SpriteInstructions:
.a2ca	c9 bf		cmp #$bf			cmp 	#KWD_OFF
.a2cc	f0 07		beq $a2d5			beq 	_RGISpriteOff
.a2ce	c9 bb		cmp #$bb			cmp 	#KWD_IMAGE
.a2d0	f0 13		beq $a2e5			beq 	_RGISetImage
.a2d2	4c 36 a2	jmp $a236			jmp 	_RGI_Move
.a2d5					_RGISpriteOff:
.a2d5	5a		phy				phy
.a2d6	a0 01		ldy #$01			ldy 	#1
.a2d8	a2 00		ldx #$00			ldx 	#0
.a2da					_RGIDoCommandLoop:
.a2da	a9 10		lda #$10			lda 	#GCMD_SpriteImage
.a2dc	20 c5 aa	jsr $aac5			jsr 	GXGraphicDraw
.a2df	7a		ply				ply
.a2e0	b0 e2		bcs $a2c4			bcs 	_RGIRange
.a2e2	4c fd a1	jmp $a1fd			jmp 	_RGICommandLoop
.a2e5					_RGISetImage:
.a2e5	a2 01		ldx #$01			ldx 	#1
.a2e7	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger
.a2ea	5a		phy				phy
.a2eb	aa		tax				tax
.a2ec	a0 00		ldy #$00			ldy 	#0
.a2ee	80 ea		bra $a2da			bra 	_RGIDoCommandLoop
.a2f0					GCGetCoordinatePair:
.a2f0	a2 01		ldx #$01			ldx 	#1
.a2f2	20 8d 9d	jsr $9d8d			jsr 	Evaluate16BitInteger
.a2f5	20 58 8d	jsr $8d58			jsr 	CheckComma
.a2f8	e8		inx				inx
.a2f9	20 8d 9d	jsr $9d8d			jsr 	Evaluate16BitInteger
.a2fc	60		rts				rts
.a2fd					GCSignedCoordinatePair:
.a2fd	a2 01		ldx #$01			ldx 	#1
.a2ff	20 99 9d	jsr $9d99			jsr 	Evaluate16BitIntegerSigned
.a302	20 58 8d	jsr $8d58			jsr 	CheckComma
.a305	e8		inx				inx
.a306	20 99 9d	jsr $9d99			jsr 	Evaluate16BitIntegerSigned
.a309	60		rts				rts
.a30a					_GCCPRange:
.a30a	4c bb 9f	jmp $9fbb			jmp 	RangeError
.a30d					GCLoadAXY:
.a30d	ad 31 06	lda $0631			lda 	gxXPos+1
.a310	ae 30 06	ldx $0630			ldx 	gxXPos
.a313	ac 32 06	ldy $0632			ldy 	gxYPos
.a316	60		rts				rts
.a317					GCCopyPairToStore:
.a317	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; copy it into space.
.a31a	8d 30 06	sta $0630			sta 	gxXPos
.a31d	ad 11 04	lda $0411			lda 	NSMantissa1+1
.a320	8d 31 06	sta $0631			sta 	gxXPos+1
.a323	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a326	8d 32 06	sta $0632			sta 	gxYPos
.a329	60		rts				rts
.062e					gxCommandID:
>062e							.fill 	1
.062f					gxFillSolid:
>062f							.fill 	1
.0630					gxXPos:
>0630							.fill 	2
.0632					gxYPos:
>0632							.fill 	1
.0633					gxHandler:
>0633							.fill 	2
.0635					gxDrawScale:
>0635							.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcontrol.asm

.a32a					BitmapCtrl:
.a32a	b1 30		lda ($30),y			lda 	(codePtr),y
.a32c	c8		iny				iny
.a32d	a2 01		ldx #$01			ldx 	#1
.a32f	c9 c0		cmp #$c0			cmp 	#KWD_ON
.a331	f0 11		beq $a344			beq 	BitmapSwitch
.a333	ca		dex				dex
.a334	c9 bf		cmp #$bf			cmp 	#KWD_OFF
.a336	f0 0c		beq $a344			beq 	BitmapSwitch
.a338	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger 		; get the colour
.a33b	5a		phy				phy
.a33c	aa		tax				tax
.a33d	a9 06		lda #$06			lda 	#GCMD_Clear					; clear to that colour
.a33f	20 c5 aa	jsr $aac5			jsr 	GXGraphicDraw
.a342	7a		ply				ply
.a343	60		rts				rts
.a344					BitmapSwitch:
.a344	5a		phy				phy
.a345	a0 00		ldy #$00			ldy 	#0 							; gfx 1,on/off,0
.a347	a9 02		lda #$02			lda 	#GCMD_BitmapCtl
.a349	20 c5 aa	jsr $aac5			jsr 	GXGraphicDraw
.a34c	a9 08		lda #$08			lda 	#GCMD_Colour				; set colour to $FF
.a34e	a0 00		ldy #$00			ldy 	#0
.a350	a2 ff		ldx #$ff			ldx 	#$FF
.a352	20 c5 aa	jsr $aac5			jsr 	GXGraphicDraw
.a355	9c 2f 06	stz $062f			stz 	gxFillSolid
.a358	9c 30 06	stz $0630			stz 	gxXPos
.a35b	9c 31 06	stz $0631			stz 	gxXPos+1
.a35e	9c 32 06	stz $0632			stz 	gxYPos
.a361	9c 35 06	stz $0635			stz 	gxDrawScale
.a364	a9 40		lda #$40			lda 	#GCMD_Move 						; home cursor
.a366	a2 00		ldx #$00			ldx 	#0
.a368	a0 00		ldy #$00			ldy 	#0
.a36a	20 c5 aa	jsr $aac5			jsr 	GXGraphicDraw
.a36d	7a		ply				ply
.a36e	60		rts				rts
.a36f					SpritesCtrl:
.a36f	b1 30		lda ($30),y			lda 	(codePtr),y
.a371	c8		iny				iny
.a372	a2 01		ldx #$01			ldx 	#1
.a374	c9 c0		cmp #$c0			cmp 	#KWD_ON
.a376	f0 08		beq $a380			beq 	SpriteSwitch
.a378	ca		dex				dex
.a379	c9 bf		cmp #$bf			cmp 	#KWD_OFF
.a37b	f0 03		beq $a380			beq 	SpriteSwitch
.a37d	4c b6 9f	jmp $9fb6			jmp 	SyntaxError
.a380					SpriteSwitch:
.a380	5a		phy				phy
.a381	a0 00		ldy #$00			ldy 	#0 							; gfx 2,on/off,0
.a383	a9 04		lda #$04			lda 	#GCMD_SpriteCtl
.a385	20 c5 aa	jsr $aac5			jsr 	GXGraphicDraw
.a388	7a		ply				ply
.a389	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gfx.asm

.a38a					GfxCommand:
.a38a	a2 00		ldx #$00			ldx 	#0
.a38c	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger 		; command
.a38f	20 58 8d	jsr $8d58			jsr 	CheckComma
.a392	e8		inx				inx
.a393	20 8d 9d	jsr $9d8d			jsr 	Evaluate16BitInteger 		; X
.a396	20 58 8d	jsr $8d58			jsr 	CheckComma
.a399	e8		inx				inx
.a39a	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger 		; Y
.a39d	ad 11 04	lda $0411			lda 	NSMantissa1+1  				; shift bit 0 of X into CS, should now be zero
.a3a0	4a		lsr a				lsr 	a
.a3a1	d0 16		bne $a3b9			bne 	_GfxError
.a3a3	2e 08 04	rol $0408			rol 	NSMantissa0 				; rotate into command
.a3a6	b0 11		bcs $a3b9			bcs 	_GfxError 					; bit 7 should have been zero
.a3a8	5a		phy				phy 								; save pos
.a3a9	ad 08 04	lda $0408			lda 	NSMantissa0 				; do the command
.a3ac	ae 09 04	ldx $0409			ldx 	NSMantissa0+1
.a3af	ac 0a 04	ldy $040a			ldy 	NSMantissa0+2
.a3b2	20 c5 aa	jsr $aac5			jsr 	GXGraphicDraw
.a3b5	b0 02		bcs $a3b9			bcs 	_GfxError
.a3b7	7a		ply				ply 								; restore pos and exit.
.a3b8	60		rts				rts
.a3b9					_GfxError:
.a3b9	4c bb 9f	jmp $9fbb			jmp 	RangeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/hit.asm

.a3bc					UnaryHit:
.a3bc	fa		plx				plx
.a3bd	a9 36		lda #$36			lda 	#zTemp0
.a3bf	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger 		; get sprite number 0
.a3c2	20 58 8d	jsr $8d58			jsr 	CheckComma
.a3c5	e8		inx				inx
.a3c6	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger 		; get sprite number 1
.a3c9	20 50 8d	jsr $8d50			jsr		CheckRightBracket
.a3cc	ca		dex				dex 								; fix back up again.
.a3cd	da		phx				phx 								; save X/Y
.a3ce	5a		phy				phy
.a3cf	bc 09 04	ldy $0409,x			ldy 	NSMantissa0+1,x 			; get the sprite numbers into X/Y
.a3d2	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a3d5	aa		tax				tax
.a3d6	a9 12		lda #$12			lda 	#GCMD_SpriteCollide 		; command check collision.
.a3d8	20 c5 aa	jsr $aac5			jsr 	GXGraphicDraw 				; calculate result
.a3db	1a		inc a				inc 	a 							; so 255 (fail) -> 0, otherwise 1,2,3,4 pixels etc.
.a3dc	7a		ply				ply 								; restore XY
.a3dd	fa		plx				plx
.a3de	20 2e 9e	jsr $9e2e			jsr 	NSMSetByte 					; return the hit result
.a3e1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/palette.asm

.a3e2					PaletteCommand:
.a3e2	a2 00		ldx #$00			ldx 	#0
.a3e4	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger 		; colour
.a3e7	20 58 8d	jsr $8d58			jsr 	CheckComma
.a3ea	e8		inx				inx
.a3eb	20 8d 9d	jsr $9d8d			jsr 	Evaluate16BitInteger 		; r
.a3ee	20 58 8d	jsr $8d58			jsr 	CheckComma
.a3f1	e8		inx				inx
.a3f2	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger 		; g
.a3f5	20 58 8d	jsr $8d58			jsr 	CheckComma
.a3f8	e8		inx				inx
.a3f9	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger 		; b
.a3fc	ad 08 04	lda $0408			lda 	NSMantissa0 				; get colour #
.a3ff	85 36		sta $36				sta 	zTemp0
.a401	a9 34		lda #$34			lda 	#$D0 >> 2 					; MSB = D0/4
.a403	85 37		sta $37				sta 	zTemp0+1
.a405	06 36		asl $36				asl 	zTemp0 						; zTemp = $D000+Colour x 4
.a407	26 37		rol $37				rol	 	zTemp0+1
.a409	06 36		asl $36				asl 	zTemp0
.a40b	26 37		rol $37				rol	 	zTemp0+1
.a40d	a9 01		lda #$01			lda 	#1 							; I/O Page 2
.a40f	85 01		sta $01				sta 	1
.a411	5a		phy				phy
.a412	ad 0b 04	lda $040b			lda 	NSMantissa0+3 				; fix to r,g,b
.a415	92 36		sta ($36)			sta 	(zTemp0)
.a417	a0 01		ldy #$01			ldy 	#1
.a419	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a41c	91 36		sta ($36),y			sta 	(zTemp0),y
.a41e	ad 09 04	lda $0409			lda 	NSMantissa0+1
.a421	c8		iny				iny
.a422	91 36		sta ($36),y			sta 	(zTemp0),y
.a424	7a		ply				ply
.a425	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/event.asm

.a426					UnaryEvent:
.a426	fa		plx				plx
.a427	20 ce a4	jsr $a4ce			jsr 	TimerToStackX 				; timer in +0
.a42a	e8		inx				inx  								; put reference into +1
.a42b	20 f2 97	jsr $97f2			jsr 	EvaluateTerm
.a42e	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if is integer reference
.a431	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.a433	d0 57		bne $a48c			bne 	_UEType
.a435	e8		inx				inx 								; put the step in +2
.a436	20 58 8d	jsr $8d58			jsr 	CheckComma
.a439	20 8d 9d	jsr $9d8d			jsr 	Evaluate16BitInteger
.a43c	20 50 8d	jsr $8d50			jsr 	CheckRightBracket
.a43f	ca		dex				dex
.a440	ca		dex				dex
.a441	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; copy reference to zTemp0
.a444	85 36		sta $36				sta 	zTemp0
.a446	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.a449	85 37		sta $37				sta 	zTemp0+1
.a44b	5a		phy				phy
.a44c	a0 03		ldy #$03			ldy 	#3 							; check bit 7 of last bit, the packed sign bit
.a44e	b1 36		lda ($36),y			lda 	(zTemp0),y
.a450	30 36		bmi $a488			bmi 	_UEFalse 					; exit if signed.
.a452	a0 00		ldy #$00			ldy 	#0 							; has it timed out (24 bit)
.a454	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a457	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.a459	c8		iny				iny
.a45a	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a45d	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a45f	c8		iny				iny
.a460	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.a463	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a465	90 21		bcc $a488			bcc 	_UEFalse 					; no, return FALSE.
.a467	18		clc				clc
.a468	a0 00		ldy #$00			ldy 	#0 							; work out new value as timer() + step
.a46a	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a46d	7d 0a 04	adc $040a,x			adc 	NSMantissa0+2,x
.a470	91 36		sta ($36),y			sta 	(zTemp0),y
.a472	c8		iny				iny
.a473	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a476	7d 12 04	adc $0412,x			adc 	NSMantissa1+2,x
.a479	91 36		sta ($36),y			sta 	(zTemp0),y
.a47b	c8		iny				iny
.a47c	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.a47f	7d 1a 04	adc $041a,x			adc 	NSMantissa2+2,x
.a482	91 36		sta ($36),y			sta 	(zTemp0),y
.a484	7a		ply				ply
.a485	4c d6 8d	jmp $8dd6			jmp 	ReturnTrue
.a488					_UEFalse:
.a488	7a		ply				ply 								; restore Y
.a489	4c e2 8d	jmp $8de2			jmp 	ReturnFalse 				; and return False
.a48c					_UEType:
.a48c	4c c0 9f	jmp $9fc0			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/joy.asm

.a48f					UnaryJoyX:
.a48f	18		clc				clc
.a490	80 01		bra $a493			bra 	JoyMain
.a492					UnaryJoyY:
.a492	38		sec				sec
.a493					JoyMain:
.a493	fa		plx				plx 								; get pos
.a494	08		php				php 								; save carry (set for Y)
.a495	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a498	20 50 8d	jsr $8d50			jsr 	CheckRightBracket
.a49b	20 7e aa	jsr $aa7e			jsr 	EXTReadController 			; read the controller.
.a49e	28		plp				plp
.a49f	90 02		bcc $a4a3			bcc 	_JMNoShift 					; if Y then shift bits 3,2 -> 1,0
.a4a1	4a		lsr a				lsr 	a
.a4a2	4a		lsr a				lsr 	a
.a4a3					_JMNoShift:
.a4a3	4a		lsr a				lsr 	a 							; if bit 0 set then right/down e.g. +1
.a4a4	b0 0a		bcs $a4b0			bcs 	_JMIsRight
.a4a6	4a		lsr a				lsr 	a 							; if bit 1 set then left/up e.g. -1
.a4a7	b0 04		bcs $a4ad			bcs 	_JMIsLeft
.a4a9	20 2c 9e	jsr $9e2c			jsr 	NSMSetZero 					; zero result
.a4ac	60		rts				rts
.a4ad					_JMIsLeft:
.a4ad	4c d6 8d	jmp $8dd6			jmp 	ReturnTrue
.a4b0					_JMIsRight:
.a4b0	a9 01		lda #$01			lda 	#1
.a4b2	20 2e 9e	jsr $9e2e			jsr 	NSMSetByte
.a4b5	60		rts				rts
.a4b6					UnaryJoyB:
.a4b6	fa		plx				plx 								; get pos
.a4b7	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a4ba	20 50 8d	jsr $8d50			jsr 	CheckRightBracket
.a4bd	20 7e aa	jsr $aa7e			jsr 	EXTReadController 			; read the controller.
.a4c0	4a		lsr a				lsr 	a
.a4c1	4a		lsr a				lsr 	a
.a4c2	4a		lsr a				lsr 	a
.a4c3	4a		lsr a				lsr 	a
.a4c4	29 01		and #$01			and 	#1
.a4c6	20 2e 9e	jsr $9e2e			jsr 	NSMSetByte
.a4c9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/timer.asm

.a4ca					UnaryTimer:
.a4ca	fa		plx				plx
.a4cb	20 50 8d	jsr $8d50			jsr 	CheckRightBracket
.a4ce					TimerToStackX:
.a4ce	20 2c 9e	jsr $9e2c			jsr 	NSMSetZero 					; zero result
.a4d1	64 01		stz $01				stz 	1 							; access I/O
.a4d3	ad 59 d6	lda $d659			lda 	$D659 						; copy timer in
.a4d6	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.a4d9	ad 5a d6	lda $d65a			lda 	$D65A
.a4dc	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a4df	ad 5b d6	lda $d65b			lda 	$D65B
.a4e2	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.a4e5	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/delete.asm

.a4e6					MemoryDeleteLine:
.a4e6	20 05 a5	jsr $a505			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a4e9	b2 30		lda ($30)			lda 	(codePtr) 					; size to delete => y
.a4eb	a8		tay				tay
.a4ec					_MDDLLoop:
.a4ec	b1 30		lda ($30),y			lda 	(codePtr),y 				; copy down
.a4ee	92 30		sta ($30)			sta 	(codePtr)
.a4f0	a5 30		lda $30				lda 	codePtr 					; check done the lot.
.a4f2	c5 3a		cmp $3a				cmp 	zTemp2
.a4f4	d0 07		bne $a4fd			bne 	_MDLDLNext
.a4f6	a5 31		lda $31				lda 	codePtr+1
.a4f8	c5 3b		cmp $3b				cmp 	zTemp2+1
.a4fa	d0 01		bne $a4fd			bne 	_MDLDLNext
.a4fc					_MDDLExit:
.a4fc	60		rts				rts
.a4fd					_MDLDLNext:
.a4fd	e6 30		inc $30				inc 	codePtr						; next byte
.a4ff	d0 eb		bne $a4ec			bne 	_MDDLLoop
.a501	e6 31		inc $31				inc 	codePtr+1
.a503	80 e7		bra $a4ec			bra 	_MDDLLoop
.a505					IMemoryFindEnd:
.a505	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a507	85 3a		sta $3a				sta 	0+zTemp2
.a509	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a50b	85 3b		sta $3b				sta 	1+zTemp2
.a50d					_MDLFELoop:
.a50d	b2 3a		lda ($3a)			lda 	(zTemp2)
.a50f	f0 0b		beq $a51c			beq 	_MDLFEExit
.a511	18		clc				clc
.a512	65 3a		adc $3a				adc 	zTemp2
.a514	85 3a		sta $3a				sta 	zTemp2
.a516	90 f5		bcc $a50d			bcc 	_MDLFELoop
.a518	e6 3b		inc $3b				inc 	zTemp2+1
.a51a	80 f1		bra $a50d			bra 	_MDLFELoop
.a51c					_MDLFEExit:
.a51c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/insert.asm

.a51d					MemoryInsertLine:
.a51d	08		php				php
.a51e	20 05 a5	jsr $a505			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a521	a5 3b		lda $3b				lda 	zTemp2+1 					; space ?
.a523	1a		inc a				inc 	a
.a524	c9 7f		cmp #$7f			cmp 	#(BasicEnd >> 8)-1
.a526	b0 36		bcs $a55e			bcs 	_MDLIError
.a528	28		plp				plp
.a529	90 08		bcc $a533			bcc 	_MDLIFound
.a52b	a5 3a		lda $3a				lda 	zTemp2 						; if CS on entry append.
.a52d	85 30		sta $30				sta 	codePtr
.a52f	a5 3b		lda $3b				lda 	zTemp2+1
.a531	85 31		sta $31				sta 	codePtr+1
.a533					_MDLIFound:
.a533	ad a8 04	lda $04a8			lda 	tokenOffset 				; insert gap in Y, the offset, e.g. length of the new line
.a536	a8		tay				tay
.a537					_MDLIInsert:
.a537	b2 3a		lda ($3a)			lda 	(zTemp2) 					; shift one byte up , at least one covers end case.
.a539	91 3a		sta ($3a),y			sta 	(zTemp2),y 					; work from top down.
.a53b	a5 30		lda $30				lda 	codePtr 					; done insert point ?
.a53d	c5 3a		cmp $3a				cmp 	zTemp2
.a53f	d0 06		bne $a547			bne 	_MDLINext
.a541	a5 31		lda $31				lda 	codePtr+1
.a543	c5 3b		cmp $3b				cmp 	zTemp2+1
.a545	f0 0a		beq $a551			beq 	_MDLIHaveSpace
.a547					_MDLINext:
.a547	a5 3a		lda $3a				lda 	zTemp2 						; if no, keep zTemp2 going backwards
.a549	d0 02		bne $a54d			bne 	_MDLINoBorrow
.a54b	c6 3b		dec $3b				dec 	zTemp2+1
.a54d					_MDLINoBorrow:
.a54d	c6 3a		dec $3a				dec 	zTemp2
.a54f	80 e6		bra $a537			bra 	_MDLIInsert
.a551					_MDLIHaveSpace:
.a551	ac a8 04	ldy $04a8			ldy 	tokenOffset 				; bytes to copy
.a554	88		dey				dey 								; from offset-1 to 0
.a555					_MDLICopy:
.a555	b9 a8 04	lda $04a8,y			lda 	tokenOffset,y
.a558	91 30		sta ($30),y			sta 	(codePtr),y
.a55a	88		dey				dey
.a55b	10 f8		bpl $a555			bpl 	_MDLICopy
.a55d	60		rts				rts
.a55e					_MDLIError:
.a55e	a9 06		lda #$06		lda	#6
.a560	4c 69 8d	jmp $8d69		jmp	ErrorHandler
.a563					MDLAppendLine:
.a563	86 37		stx $37				stx 	zTemp0+1 					; save new line at zTemp0
.a565	85 36		sta $36				sta 	zTemp0
.a567	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a569	85 38		sta $38				sta 	0+zTemp1
.a56b	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a56d	85 39		sta $39				sta 	1+zTemp1
.a56f	b2 38		lda ($38)			lda 	(zTemp1)
.a571	d0 0a		bne $a57d			bne 	_MDLANoInitialise
.a573	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a575	8d 36 06	sta $0636			sta 	0+AppendPointer
.a578	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a57a	8d 37 06	sta $0637			sta 	1+AppendPointer
.a57d					_MDLANoInitialise:
.a57d	18		clc				clc
.a57e	ad 36 06	lda $0636			lda 	AppendPointer 				; copy append pointer to zTemp1 adding the offset as you go
.a581	85 38		sta $38				sta 	zTemp1
.a583	72 36		adc ($36)			adc 	(zTemp0)
.a585	8d 36 06	sta $0636			sta 	AppendPointer
.a588	ad 37 06	lda $0637			lda 	AppendPointer+1
.a58b	85 39		sta $39				sta 	zTemp1+1
.a58d	69 00		adc #$00			adc 	#0
.a58f	8d 37 06	sta $0637			sta 	AppendPointer+1
.a592	a0 00		ldy #$00			ldy 	#0
.a594					_MDLACopy:
.a594	b1 36		lda ($36),y			lda 	(zTemp0),y 					; copy new line in
.a596	91 38		sta ($38),y			sta 	(zTemp1),y
.a598	c8		iny				iny
.a599	98		tya				tya
.a59a	d2 36		cmp ($36)			cmp 	(zTemp0) 					; done whole line
.a59c	d0 f6		bne $a594			bne 	_MDLACopy
.a59e	a9 00		lda #$00			lda 	#0 							; end of program.
.a5a0	91 38		sta ($38),y			sta 	(zTemp1),y
.a5a2	60		rts				rts
.0636					AppendPointer:
>0636							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/memory.asm

.a5a3					MemoryNew:
.a5a3	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a5a5	85 30		sta $30				sta 	codePtr
.a5a7	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a5a9	85 31		sta $31				sta 	codePtr+1
.a5ab	a9 00		lda #$00			lda 	#0 							; write zero there erasing the program.
.a5ad	92 30		sta ($30)			sta 	(codePtr)
.a5af	60		rts				rts
.a5b0					MemoryInline:
.a5b0	98		tya				tya 								; put address into stack,x
.a5b1	18		clc				clc
.a5b2	65 30		adc $30				adc 	codePtr
.a5b4	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.a5b7	a5 31		lda $31				lda 	codePtr+1
.a5b9	69 00		adc #$00			adc 	#0
.a5bb	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a5be	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.a5c1	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.a5c4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/search.asm

.a5c5					MemorySearch:
.a5c5	85 36		sta $36				sta 	zTemp0 						; save line number zTemp0
.a5c7	86 37		stx $37				stx 	zTemp0+1
.a5c9	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a5cb	85 30		sta $30				sta 	codePtr
.a5cd	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a5cf	85 31		sta $31				sta 	codePtr+1
.a5d1					_MTAXLoop:
.a5d1	b2 30		lda ($30)			lda 	(codePtr)
.a5d3	18		clc				clc
.a5d4	f0 21		beq $a5f7			beq 	_MTAXExit 					; reached end, exit with CC.
.a5d6	a0 01		ldy #$01			ldy 	#1 							; calculate current line# - requested line#
.a5d8	b1 30		lda ($30),y			lda 	(codePtr),y
.a5da	38		sec				sec
.a5db	e5 36		sbc $36				sbc 	zTemp0
.a5dd	85 38		sta $38				sta 	zTemp1 						; save interim to set Z
.a5df	c8		iny				iny 								; do the MSB
.a5e0	b1 30		lda ($30),y			lda 	(codePtr),y
.a5e2	e5 37		sbc $37				sbc 	zTemp0+1
.a5e4	05 38		ora $38				ora 	zTemp1
.a5e6	f0 0f		beq $a5f7			beq 	_MTAXExit	 				; found
.a5e8	b0 0d		bcs $a5f7			bcs 	_MTAXExit 					; current < required exit
.a5ea	18		clc				clc
.a5eb	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.a5ed	65 30		adc $30				adc 	codePtr
.a5ef	85 30		sta $30				sta 	codePtr
.a5f1	90 02		bcc $a5f5			bcc 	_CREExit
.a5f3	e6 31		inc $31				inc 	codePtr+1
.a5f5					_CREExit:
.a5f5	80 da		bra $a5d1			bra 	_MTAXLoop
.a5f7					_MTAXExit:
.a5f7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/sound.asm

.a5f8					SoundCommand:
.a5f8	b1 30		lda ($30),y			lda 	(codePtr),y
.a5fa	c9 bf		cmp #$bf			cmp 	#KWD_OFF 					; SOUND OFF ?
.a5fc	d0 09		bne $a607			bne 	_SNDMain
.a5fe	c8		iny				iny 								; skip OFF
.a5ff	a9 3f		lda #$3f			lda 	#$3F 						; call command $3F (silence)
.a601	5a		phy				phy
.a602	20 53 b9	jsr $b953			jsr 	SNDCommand
.a605	7a		ply				ply
.a606	60		rts				rts
.a607					_SNDMain:
.a607	a2 00		ldx #$00			ldx 	#0
.a609	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger 		; channel
.a60c	c9 04		cmp #$04			cmp 	#4 							; must be 0-3
.a60e	b0 50		bcs $a660			bcs 	_SndError
.a610	e8		inx				inx 								; do the rest in slot 1.
.a611	20 58 8d	jsr $8d58			jsr 	CheckComma
.a614	20 8d 9d	jsr $9d8d			jsr 	Evaluate16BitInteger 		; Pitch
.a617	bd 10 04	lda $0410,x			lda 	NSMantissa1,x 				; must be 10 bit
.a61a	c9 10		cmp #$10			cmp 	#16
.a61c	b0 42		bcs $a660			bcs 	_SndError
.a61e	8d 39 06	sta $0639			sta 	SoundCommandBlock+1 		; Pitch (2 bytes + 0)
.a621	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a624	8d 38 06	sta $0638			sta 	SoundCommandBlock
.a627	20 58 8d	jsr $8d58			jsr 	CheckComma
.a62a	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger 		; Length (1 byte + 3)
.a62d	8d 3b 06	sta $063b			sta 	SoundCommandBlock+3
.a630	a9 0f		lda #$0f			lda 	#15
.a632	8d 3a 06	sta $063a			sta 	SoundCommandBlock+2 		; Volume (1 byte + 2)
.a635	9c 3c 06	stz $063c			stz 	SoundCommandBlock+4 		; default slide (2 bytes +4)
.a638	9c 3d 06	stz $063d			stz 	SoundCommandBlock+5
.a63b	b1 30		lda ($30),y			lda 	(codePtr),y
.a63d	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.a63f	d0 10		bne $a651			bne 	_SNDPlay
.a641	c8		iny				iny
.a642	20 99 9d	jsr $9d99			jsr 	Evaluate16BitIntegerSigned 	; Slide
.a645	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; Slide (2 bytes + 4)
.a648	8d 3c 06	sta $063c			sta 	SoundCommandBlock+4
.a64b	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a64e	8d 3d 06	sta $063d			sta 	SoundCommandBlock+5
.a651					_SNDPlay:
.a651	5a		phy				phy
.a652	ad 08 04	lda $0408			lda 	NSMantissa0 				; channel.
.a655	09 10		ora #$10			ora 	#$10 						; 1x = Queue sound
.a657	a2 38		ldx #$38			ldx 	#(SoundCommandBlock & $FF)
.a659	a0 06		ldy #$06			ldy 	#(SoundCommandBlock >> 8)
.a65b	20 53 b9	jsr $b953			jsr 	SNDCommand
.a65e	7a		ply				ply
.a65f	60		rts				rts
.a660					_SndError:
.a660	4c bb 9f	jmp $9fbb			jmp 	RangeError
.0638					SoundCommandBlock:
>0638							.fill 	6

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/bytes.asm

.a663					StackPushByte:
.a663	48		pha				pha 								; save byte
.a664	a5 34		lda $34				lda 	BasicStack
.a666	d0 09		bne $a671			bne 	_SPBNoBorrow
.a668	c6 35		dec $35				dec 	BasicStack+1
.a66a	48		pha				pha
.a66b	a5 35		lda $35				lda 	BasicStack+1
.a66d	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a66f	90 06		bcc $a677			bcc 	_SPBMemory
.a671					_SPBNoBorrow:
.a671	c6 34		dec $34				dec 	BasicStack
.a673	68		pla				pla 								; get back and write
.a674	92 34		sta ($34)			sta 	(BasicStack)
.a676	60		rts				rts
.a677					_SPBMemory:
.a677	a9 12		lda #$12		lda	#18
.a679	4c 69 8d	jmp $8d69		jmp	ErrorHandler
.a67c					StackPopByte:
.a67c	b2 34		lda ($34)			lda 	(BasicStack)
.a67e	e6 34		inc $34				inc 	BasicStack
.a680	d0 02		bne $a684			bne 	_SPBNoCarry
.a682	e6 35		inc $35				inc 	BasicStack+1
.a684					_SPBNoCarry:
.a684	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/frames.asm

.a685					StackOpen:
.a685	48		pha				pha 								; save frame byte
.a686	29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.a688	0a		asl a				asl 	a 							; claim twice this for storage
.a689	49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.a68b	38		sec				sec 								; so basically subtracting from
.a68c	65 34		adc $34				adc 	basicStack 	 				; basicStack
.a68e	85 34		sta $34				sta 	basicStack
.a690	b0 08		bcs $a69a			bcs 	_SONoBorrow
.a692	c6 35		dec $35				dec 	basicStack+1
.a694	a5 35		lda $35				lda 	basicStack+1 				; have we reached stack overflow
.a696	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a698	90 04		bcc $a69e			bcc 	_SOMemory
.a69a					_SONoBorrow:
.a69a	68		pla				pla 								; get marker back and write at TOS
.a69b	92 34		sta ($34)			sta 	(basicStack)
.a69d	60		rts				rts
.a69e					_SOMemory:
.a69e	a9 12		lda #$12		lda	#18
.a6a0	4c 69 8d	jmp $8d69		jmp	ErrorHandler
.a6a3					StackClose:
.a6a3	b2 34		lda ($34)			lda 	(basicStack) 				; get TOS marker
.a6a5	29 0f		and #$0f			and 	#$0F 						; bytes to add back
.a6a7	0a		asl a				asl 	a 							; claim twice this.
.a6a8	65 34		adc $34				adc 	basicStack 					; add to the stack pointer.
.a6aa	85 34		sta $34				sta 	basicStack
.a6ac	90 02		bcc $a6b0			bcc 	_SCExit
.a6ae	e6 35		inc $35				inc 	basicStack+1
.a6b0					_SCExit:
.a6b0	60		rts				rts
.a6b1					StackCheckFrame:
.a6b1	48		pha				pha
.a6b2					_StackRemoveLocals:
.a6b2	b2 34		lda ($34)			lda 	(basicStack) 				; check for local, keep popping them
.a6b4	c9 03		cmp #$03			cmp 	#STK_LOCALS+1
.a6b6	b0 05		bcs $a6bd			bcs 	_SCNoLocal
.a6b8	20 02 88	jsr $8802			jsr 	LocalPopValue
.a6bb	80 f5		bra $a6b2			bra 	_StackRemoveLocals
.a6bd					_SCNoLocal:
.a6bd	68		pla				pla
.a6be	52 34		eor ($34)			eor 	(basicStack) 				; xor with toS marker
.a6c0	29 f0		and #$f0			and 	#$F0 						; check type bits
.a6c2	d0 01		bne $a6c5			bne 	_SCFError 					; different, we have structures mixed up
.a6c4	60		rts				rts
.a6c5					_SCFError:
.a6c5	8a		txa				txa 								; report error X
.a6c6	4c 69 8d	jmp $8d69			jmp 	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/location.asm

.a6c9					STKSaveCodePosition:
.a6c9	5a		phy				phy
.a6ca	98		tya				tya 								; save Y
.a6cb	a0 05		ldy #$05			ldy 	#5
.a6cd	91 34		sta ($34),y			sta 	(basicStack),y
.a6cf	88		dey				dey 								; save Code Pointer
.a6d0					_STKSaveLoop:
.a6d0	b9 2f 00	lda $002f,y			lda 	safePtr-1,y 				; allows us to access the pointer w/out issues.
.a6d3	91 34		sta ($34),y			sta 	(basicStack),y
.a6d5	88		dey				dey
.a6d6	d0 f8		bne $a6d0			bne 	_STKSaveLoop
.a6d8	7a		ply				ply
.a6d9	60		rts				rts
.a6da					STKLoadCodePosition:
.a6da	a0 01		ldy #$01			ldy 	#1 							; load code pointer back
.a6dc					_STKLoadLoop:
.a6dc	b1 34		lda ($34),y			lda 	(basicStack),y
.a6de	99 2f 00	sta $002f,y			sta 	safePtr-1,y
.a6e1	c8		iny				iny
.a6e2	c0 05		cpy #$05			cpy 	#5
.a6e4	d0 f6		bne $a6dc			bne 	_STKLoadLoop
.a6e6	b1 34		lda ($34),y			lda 	(basicStack),y 				; get Y offset
.a6e8	a8		tay				tay
.a6e9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/setup.asm

.a6ea					StackReset:
.a6ea	a9 ff		lda #$ff			lda 	#((BasicStackBase+BasicStackSize-1) & $FF)
.a6ec	85 34		sta $34				sta 	0+basicStack
.a6ee	a9 0f		lda #$0f			lda 	#((BasicStackBase+BasicStackSize-1) >> 8)
.a6f0	85 35		sta $35				sta 	1+basicStack
.a6f2	a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.a6f4	92 34		sta ($34)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.a6f6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/concrete.asm

.a6f7					StringConcrete:
.a6f7	5a		phy				phy 								; save position on stack
.a6f8	20 f5 99	jsr $99f5			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a6fb	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy target string to zTemp1
.a6fe	85 38		sta $38				sta 	zTemp1
.a700	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a703	85 39		sta $39				sta 	zTemp1+1
.a705	a0 ff		ldy #$ff			ldy 	#$FF	 					; calculate string length
.a707					_SALength:
.a707	c8		iny				iny
.a708	b1 38		lda ($38),y			lda 	(zTemp1),y
.a70a	d0 fb		bne $a707			bne 	_SALength
.a70c	c0 fd		cpy #$fd			cpy 	#253 						; string too long
.a70e	b0 3f		bcs $a74f			bcs 	_SALengthError
.a710	98		tya				tya 				 				; length of the new string
.a711	18		clc				clc
.a712	69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.a714	90 02		bcc $a718			bcc 	_SAHaveLength
.a716	a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.a718					_SAHaveLength:
.a718	48		pha				pha 								; save length.
.a719	38		sec				sec
.a71a	49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.a71c	6d 8e 04	adc $048e			adc 	StringMemory
.a71f	8d 8e 04	sta $048e			sta 	StringMemory
.a722	85 3a		sta $3a				sta 	zTemp2 						; update storage address
.a724	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; update mantissa address
.a727	a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.a729	6d 8f 04	adc $048f			adc 	StringMemory+1
.a72c	8d 8f 04	sta $048f			sta 	StringMemory+1
.a72f	85 3b		sta $3b				sta 	zTemp2+1
.a731	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a734	68		pla				pla 								; save length-3 (chars allowed) in first byte
.a735	38		sec				sec
.a736	e9 03		sbc #$03			sbc 	#3
.a738	92 3a		sta ($3a)			sta 	(zTemp2)
.a73a	a9 00		lda #$00			lda 	#0 							; clear the status byte.
.a73c	a0 01		ldy #$01			ldy 	#1
.a73e	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a740					_SACopyNewString:
.a740	a0 00		ldy #$00			ldy 	#0
.a742					_SACopyNSLoop:
.a742	b1 38		lda ($38),y			lda 	(zTemp1),y 					; get character
.a744	c8		iny				iny 								; write two on in string storage
.a745	c8		iny				iny
.a746	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a748	88		dey				dey 								; this makes it one one.
.a749	c9 00		cmp #$00			cmp 	#0 							; until EOS copied
.a74b	d0 f5		bne $a742			bne 	_SACopyNSLoop
.a74d	7a		ply				ply
.a74e	60		rts				rts
.a74f					_SALengthError:
.a74f	a9 09		lda #$09		lda	#9
.a751	4c 69 8d	jmp $8d69		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/stringalloc.asm

.a754					StringSystemInitialise:
.a754	a9 ff		lda #$ff			lda 	#((EndVariableSpace-1) & $FF)
.a756	8d 8e 04	sta $048e			sta 	0+StringMemory
.a759	a9 1f		lda #$1f			lda 	#((EndVariableSpace-1) >> 8)
.a75b	8d 8f 04	sta $048f			sta 	1+StringMemory
.a75e	9c ff 1f	stz $1fff			stz 	EndVariableSpace-1 			; put a zero at the end, so know end of string memory.
.a761	60		rts				rts
.a762					StringSpaceInitialise:
.a762	20 f5 99	jsr $99f5			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a765	a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.a767	8d 90 04	sta $0490			sta 	StringInitialised
.a76a	ad 8e 04	lda $048e			lda 	StringMemory 				; allocate 256 bytes for one concreted string
.a76d	8d 91 04	sta $0491			sta 	StringTempPointer
.a770	ad 8f 04	lda $048f			lda 	StringMemory+1
.a773	3a		dec a				dec 	a
.a774	8d 92 04	sta $0492			sta 	StringTempPointer+1
.a777	60		rts				rts
.a778					StringTempAllocate:
.a778	c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.a77a	b0 35		bcs $a7b1			bcs 	_STALength
.a77c	2c 90 04	bit $0490			bit 	StringInitialised 			; already initialised
.a77f	30 05		bmi $a786			bmi 	_STAAllocate
.a781	48		pha				pha 								; save value to subtract.
.a782	20 62 a7	jsr $a762			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.a785	68		pla				pla 								; restore it
.a786					_STAAllocate:
.a786	49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.a788	18		clc				clc  								; deliberate allows one more
.a789	6d 91 04	adc $0491			adc 	StringTempPointer 			; subtract from temp pointer
.a78c	8d 91 04	sta $0491			sta 	StringTempPointer
.a78f	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; address in mantissa
.a792	85 3c		sta $3c				sta 	zsTemp 						; and zsTemp
.a794	ad 92 04	lda $0492			lda 	StringTempPointer+1
.a797	69 ff		adc #$ff			adc 	#$FF
.a799	8d 92 04	sta $0492			sta 	StringTempPointer+1
.a79c	85 3d		sta $3d				sta 	zsTemp+1
.a79e	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a7a1	9e 18 04	stz $0418,x			stz 	NSMantissa2,x 				; set the typing data
.a7a4	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.a7a7	a9 10		lda #$10			lda 	#NSTString
.a7a9	9d 00 04	sta $0400,x			sta 	NSStatus,x
.a7ac	a9 00		lda #$00			lda 	#0 							; clear the target string
.a7ae	92 3c		sta ($3c)			sta 	(zsTemp)
.a7b0	60		rts				rts
.a7b1					_STALength:
.a7b1	a9 09		lda #$09		lda	#9
.a7b3	4c 69 8d	jmp $8d69		jmp	ErrorHandler
.a7b6					StringTempWrite:
.a7b6	48		pha				pha
.a7b7	92 3c		sta ($3c)			sta 	(zsTemp)
.a7b9	e6 3c		inc $3c				inc 	zsTemp
.a7bb	d0 02		bne $a7bf			bne 	_STWNoCarry
.a7bd	e6 3d		inc $3d				inc 	zsTemp+1
.a7bf					_STWNoCarry:
.a7bf	a9 00		lda #$00			lda 	#0
.a7c1	92 3c		sta ($3c)			sta 	(zsTemp)
.a7c3	68		pla				pla
.a7c4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_hardware.module

=1					hardwareIntegrated=1
=0					CONBlack = 0
=1					CONWhite = 1
=2					CONRed = 2
=3					CONCyan = 3
=4					CONPurple = 4
=5					CONGreen = 5
=6					CONBlue = 6
=7					CONYellow = 7
=8					CONOrange = 8
=9					CONBrown = 9
=10					CONYellowGreen = 10
=11					CONRosa = 11
=12					CONBlueGreen = 12
=13					CONLightBlue = 13
=14					CONPink = 14
=15					CONLightGreen = 15
=7					CONForeground = CONYellow
=6					CONBackground = CONBlue
=12					CLINumber = CONBlueGreen
=3					CLIToken = CONCyan
=13					CLIConstant = CONLightBlue
=7					CLIIdentifier = CONYellow
=10					CLIPunctuation = CONYellowGreen
=1					CLIData = CONWhite
.a7c5					EXTPrintCharacter:
.a7c5	48		pha				pha
.a7c6	da		phx				phx
.a7c7	5a		phy				phy
.a7c8	a6 01		ldx $01				ldx 	1
.a7ca	da		phx				phx
.a7cb	ac 3f 06	ldy $063f			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.a7ce	09 00		ora #$00			ora 	#$00 						; check $80-$FF
.a7d0	30 48		bmi $a81a			bmi 	_EXPCColour
.a7d2	c9 20		cmp #$20			cmp 	#$20 						; check $00-$1F
.a7d4	90 4d		bcc $a823			bcc 	_EXPCControl
.a7d6	a2 02		ldx #$02			ldx 	#2 							; select char memory
.a7d8	86 01		stx $01				stx 	1
.a7da	91 40		sta ($40),y			sta 	(EXTAddress),y
.a7dc	e6 01		inc $01				inc 	1 							; select colour memory
.a7de	ad 40 06	lda $0640			lda 	EXTTextColour
.a7e1	91 40		sta ($40),y			sta 	(EXTAddress),y
.a7e3	c8		iny				iny 								; advance horizontal position
.a7e4	8c 3f 06	sty $063f			sty 	EXTColumn
.a7e7	cc 41 06	cpy $0641			cpy 	EXTScreenWidth 				; reached RHS ?
.a7ea	90 66		bcc $a852			bcc 	_EXPCExit 					; no, then exit.
.a7ec					_EXPCCRLF:
.a7ec	ee 3e 06	inc $063e			inc 	EXTRow  					; bump row
.a7ef	9c 3f 06	stz $063f			stz 	EXTColumn 					; back to column 0
.a7f2	ad 3e 06	lda $063e			lda 	EXTRow 						; check if reached the bottom ?
.a7f5	cd 42 06	cmp $0642			cmp 	EXTScreenHeight 			; if so, then scroll.
.a7f8	f0 18		beq $a812			beq 	_EXPCScroll
.a7fa	18		clc				clc 								; add width to address.
.a7fb	a5 40		lda $40				lda 	EXTAddress
.a7fd	6d 41 06	adc $0641			adc 	EXTScreenWidth
.a800	85 40		sta $40				sta 	EXTAddress
.a802	90 4e		bcc $a852			bcc 	_EXPCExit
.a804	e6 41		inc $41				inc 	EXTAddress+1
.a806	80 4a		bra $a852			bra 	_EXPCExit
.a808					_EXPCLeft:
.a808	ce 3f 06	dec $063f			dec 	EXTColumn
.a80b	10 45		bpl $a852			bpl 	_EXPCExit
.a80d					_EXPCBegin:
.a80d	9c 3f 06	stz $063f			stz 	EXTColumn
.a810	80 40		bra $a852			bra 	_EXPCExit
.a812					_EXPCScroll:
.a812	ce 3e 06	dec $063e			dec 	EXTRow 						; the height-1 th line.
.a815	20 df a8	jsr $a8df			jsr 	EXTScreenScroll 			; scroll the screen
.a818	80 38		bra $a852			bra 	_EXPCExit
.a81a					_EXPCColour:
.a81a	c9 a0		cmp #$a0			cmp 	#$A0						; 80-9F set foreground/background
.a81c	b0 34		bcs $a852			bcs 	_EXPCExit
.a81e	20 bf a8	jsr $a8bf			jsr 	_EXPCHandleColour
.a821	80 2f		bra $a852			bra 	_EXPCExit
.a823					_EXPCControl:
.a823	c9 11		cmp #$11			cmp 	#$11 						; only handle 00-10.
.a825	b0 2b		bcs $a852			bcs 	_EXPCExit
.a827	0a		asl a				asl 	a 							; double into X
.a828	aa		tax				tax
.a829	7c 9d a8	jmp ($a89d,x)			jmp 	(_EXPCActionTable,x) 		; and execute code.
.a82c					_EXPCUp:
.a82c	ad 3e 06	lda $063e			lda 	EXTRow 						; already at top ?
.a82f	f0 21		beq $a852			beq 	_EXPCExit
.a831	ce 3e 06	dec $063e			dec 	EXTRow 						; up one in position/address
.a834	38		sec				sec
.a835	a5 40		lda $40				lda 	EXTAddress
.a837	ed 41 06	sbc $0641			sbc 	EXTScreenWidth
.a83a	85 40		sta $40				sta 	EXTAddress
.a83c	b0 14		bcs $a852			bcs 	_EXPCExit
.a83e	c6 41		dec $41				dec 	EXTAddress+1
.a840	80 10		bra $a852			bra 	_EXPCExit
.a842					_EXPCRight:
.a842	c8		iny				iny
.a843	8c 3f 06	sty $063f			sty 	EXTColumn
.a846	cc 41 06	cpy $0641			cpy 	EXTScreenWidth
.a849	d0 07		bne $a852			bne 	_EXPCExit
.a84b					_EXPCEnd:
.a84b	ad 41 06	lda $0641			lda 	EXTScreenWidth
.a84e	3a		dec a				dec 	a
.a84f	8d 3f 06	sta $063f			sta 	EXTColumn
.a852					_EXPCExit:
.a852	20 34 a9	jsr $a934			jsr 	EXTSetHardwareCursor 		; place the physical cursor.
.a855	68		pla				pla
.a856	85 01		sta $01				sta 	1
.a858	7a		ply				ply
.a859	fa		plx				plx
.a85a	68		pla				pla
.a85b	60		rts				rts
.a85c					_EXPCClearScreen:
.a85c	20 f1 a8	jsr $a8f1			jsr		EXTClearScreenCode
.a85f	80 f1		bra $a852			bra 	_EXPCExit
.a861					_EXPCDown:
.a861	ad 42 06	lda $0642			lda 	EXTScreenHeight 			; at the bottom
.a864	3a		dec a				dec 	a
.a865	cd 3e 06	cmp $063e			cmp 	EXTRow
.a868	f0 e8		beq $a852			beq 	_EXPCExit
.a86a	ee 3e 06	inc $063e			inc 	EXTRow 						; down one in position/address
.a86d	18		clc				clc
.a86e	a5 40		lda $40				lda 	EXTAddress
.a870	6d 41 06	adc $0641			adc 	EXTScreenWidth
.a873	85 40		sta $40				sta 	EXTAddress
.a875	90 db		bcc $a852			bcc 	_EXPCExit
.a877	e6 41		inc $41				inc 	EXTAddress+1
.a879	80 d7		bra $a852			bra 	_EXPCExit
.a87b					_EXPCTab:
.a87b	ad 3f 06	lda $063f			lda 	EXTColumn 					; next tab stop
.a87e	29 f8		and #$f8			and 	#$F8
.a880	18		clc				clc
.a881	69 08		adc #$08			adc 	#8
.a883	8d 3f 06	sta $063f			sta 	EXTColumn
.a886	cd 41 06	cmp $0641			cmp 	EXTScreenWidth 				; too far, stick end of line.
.a889	90 c7		bcc $a852			bcc 	_EXPCExit
.a88b	80 be		bra $a84b			bra 	_EXPCEnd
.a88d					_EXPCBackSpace:
.a88d	88		dey				dey
.a88e	30 c2		bmi $a852			bmi 	_EXPCExit
.a890	ce 3f 06	dec $063f			dec 	EXTColumn
.a893	a9 02		lda #$02			lda 	#2
.a895	85 01		sta $01				sta 	1
.a897	a9 20		lda #$20			lda 	#32
.a899	91 40		sta ($40),y			sta 	(EXTAddress),y
.a89b	80 b5		bra $a852			bra 	_EXPCExit
.a89d					_EXPCActionTable:
>a89d	52 a8						.word 	_EXPCExit 					; 00
>a89f	0d a8						.word 	_EXPCBegin 					; 01 A Start of Line
>a8a1	08 a8						.word 	_EXPCLeft 					; 02 B Left
>a8a3	52 a8						.word 	_EXPCExit 					; 03 <Break>
>a8a5	52 a8						.word 	_EXPCExit 					; 04
>a8a7	4b a8						.word 	_EXPCEnd 					; 05 E End of Line
>a8a9	42 a8						.word 	_EXPCRight 					; 06 F Right
>a8ab	52 a8						.word 	_EXPCExit 					; 07
>a8ad	8d a8						.word 	_EXPCBackspace 				; 08 H Backspace
>a8af	7b a8						.word 	_EXPCTab 					; 09 I Tab
>a8b1	52 a8						.word 	_EXPCExit 					; 0A
>a8b3	52 a8						.word 	_EXPCExit 					; 0B
>a8b5	5c a8						.word 	_EXPCClearScreen			; 0C L CLS
>a8b7	ec a7						.word 	_EXPCCRLF 					; 0D M CR/LF
>a8b9	61 a8						.word 	_EXPCDown 					; 0E N Down
>a8bb	52 a8						.word 	_EXPCExit 					; 0F
>a8bd	2c a8						.word 	_EXPCUp 					; 10 P Up
.a8bf					_EXPCHandleColour
.a8bf	c9 90		cmp #$90			cmp 	#$90 						; 8x foreground 9x background
.a8c1	b0 16		bcs $a8d9			bcs 	_EXPCBackground
.a8c3	0a		asl a				asl 	a 							; shift it 4 bits to the right.
.a8c4	0a		asl a				asl 	a
.a8c5	0a		asl a				asl 	a
.a8c6	0a		asl a				asl 	a
.a8c7	a2 0f		ldx #$0f			ldx 	#$0F 						; Mask in X
.a8c9					_EXPCUpdate:
.a8c9	48		pha				pha 								; save new colour
.a8ca	8a		txa				txa 								; get mask
.a8cb	2d 40 06	and $0640			and 	EXTTextColour 				; mask out old.
.a8ce	8d 40 06	sta $0640			sta 	EXTTextColour
.a8d1	68		pla				pla 								; or in new colour
.a8d2	0d 40 06	ora $0640			ora 	EXTTextColour
.a8d5	8d 40 06	sta $0640			sta 	EXTTextColour
.a8d8	60		rts				rts
.a8d9					_EXPCBackground:
.a8d9	29 0f		and #$0f			and 	#$0F 						; get the colour
.a8db	a2 f0		ldx #$f0			ldx 	#$F0 						; mask
.a8dd	80 ea		bra $a8c9			bra 	_EXPCUpdate
.a8df					EXTScreenScroll:
.a8df	a9 02		lda #$02			lda 	#2 							; select text page
.a8e1	85 01		sta $01				sta 	1
.a8e3	a9 20		lda #$20			lda		#32 						; fill with space
.a8e5	20 f4 a9	jsr $a9f4			jsr 	EXTScrollFill
.a8e8	e6 01		inc $01				inc 	1 							; select colour page
.a8ea	ad 40 06	lda $0640			lda 	EXTTextColour
.a8ed	20 f4 a9	jsr $a9f4			jsr 	EXTScrollFill
.a8f0	60		rts				rts
.a8f1					EXTClearScreenCode:
.a8f1	a9 02		lda #$02			lda 	#2 							; select text page
.a8f3	85 01		sta $01				sta 	1
.a8f5	a9 20		lda #$20			lda		#32 						; fill with space
.a8f7	20 04 a9	jsr $a904			jsr 	_EXTCSFill
.a8fa	e6 01		inc $01				inc 	1 							; select colour page
.a8fc	ad 40 06	lda $0640			lda 	EXTTextColour
.a8ff	20 04 a9	jsr $a904			jsr 	_EXTCSFill
.a902	80 22		bra $a926			bra 	EXTHomeCursor
.a904					_EXTCSFill:
.a904	aa		tax				tax
.a905	a9 00		lda #$00			lda 	#EXTMemory & $FF
.a907	85 40		sta $40				sta 	EXTAddress
.a909	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a90b	85 41		sta $41				sta 	EXTAddress+1
.a90d					_EXTCSFill1:
.a90d	a0 00		ldy #$00			ldy 	#0
.a90f	8a		txa				txa
.a910					_EXTCSFill2:
.a910	91 40		sta ($40),y			sta 	(EXTAddress),y
.a912	c8		iny				iny
.a913	d0 fb		bne $a910			bne 	_EXTCSFill2
.a915	e6 41		inc $41				inc 	EXTAddress+1
.a917	a5 41		lda $41				lda 	EXTAddress+1
.a919	c9 d2		cmp #$d2			cmp 	#$D2
.a91b	d0 f0		bne $a90d			bne 	_EXTCSFill1
.a91d	8a		txa				txa
.a91e					_EXTCSFill3:
.a91e	91 40		sta ($40),y			sta 	(EXTAddress),y
.a920	c8		iny				iny
.a921	c0 c0		cpy #$c0			cpy 	#$C0
.a923	d0 f9		bne $a91e			bne 	_EXTCSFill3
.a925	60		rts				rts
.a926					EXTHomeCursor:
.a926	9c 3e 06	stz $063e			stz 	EXTRow 						; reset row & column
.a929	9c 3f 06	stz $063f			stz 	EXTColumn
.a92c	a9 00		lda #$00			lda 	#EXTMemory & $FF 			; set address
.a92e	85 40		sta $40				sta 	EXTAddress
.a930	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a932	85 41		sta $41				sta 	EXTAddress+1
.a934					EXTSetHardwareCursor:
.a934	64 01		stz $01				stz 	1 							; I/O Page zero
.a936	a9 05		lda #$05			lda 	#1+4 						; enable cursor
.a938	8d 10 d0	sta $d010			sta 	$D010
.a93b	a9 b1		lda #$b1			lda 	#$B1
.a93d	8d 12 d0	sta $d012			sta 	$D012
.a940	ad 3f 06	lda $063f			lda 	EXTColumn
.a943	8d 14 d0	sta $d014			sta 	$D014 						; set cursor position
.a946	9c 15 d0	stz $d015			stz 	$D015
.a949	ad 3e 06	lda $063e			lda 	EXTRow
.a94c	8d 16 d0	sta $d016			sta 	$D016
.a94f	9c 17 d0	stz $d017			stz 	$D017
.a952	60		rts				rts
.a953					EXTInputLine:
.a953	48		pha				pha
.a954	da		phx				phx
.a955	5a		phy				phy
.a956	a5 01		lda $01				lda 	1 							; save I/O page
.a958	48		pha				pha
.a959					_EILLoop:
.a959	20 5b aa	jsr $aa5b			jsr 	ExtInputSingleCharacter
.a95c	c9 0d		cmp #$0d			cmp 	#13 						; scrape line if exit.
.a95e	f0 40		beq $a9a0			beq 	_EILExit
.a960	c9 08		cmp #$08			cmp 	#8 							; handle backspace
.a962	f0 1c		beq $a980			beq 	_EILBackspace
.a964	c9 20		cmp #$20			cmp 	#' '						; < space, print it
.a966	90 12		bcc $a97a			bcc 	_EILPrintLoop
.a968	c9 7f		cmp #$7f			cmp 	#$7F 						; if -ve print it
.a96a	b0 0e		bcs $a97a			bcs 	_EILPrintLoop
.a96c	48		pha				pha 								; save character
.a96d	a9 02		lda #$02			lda 	#2  						; insert a space
.a96f	85 01		sta $01				sta 	1
.a971	20 e2 a9	jsr $a9e2			jsr 	EXTILInsert 				; insert in text screen
.a974	e6 01		inc $01				inc 	1
.a976	20 e2 a9	jsr $a9e2			jsr 	EXTILInsert 				; insert in colour screen
.a979	68		pla				pla 								; get character back.
.a97a					_EILPrintLoop:
.a97a	20 c5 a7	jsr $a7c5			jsr 	ExtPrintCharacter
.a97d	80 da		bra $a959			bra 	_EILLoop
.a97f	60		rts				rts
.a980					_EILBackspace:
.a980	ad 3f 06	lda $063f			lda 	EXTColumn					; can we backspace ?
.a983	f0 d4		beq $a959			beq 	_EILLoop
.a985	a9 02		lda #$02			lda 	#2 							; move cursor left
.a987	20 c5 a7	jsr $a7c5			jsr 	EXTPrintCharacter
.a98a	a9 02		lda #$02			lda 	#2 							; text block
.a98c	85 01		sta $01				sta 	1
.a98e	a9 20		lda #$20			lda 	#' ' 						; backspace text.
.a990	20 cd a9	jsr $a9cd			jsr 	EXTILDelete
.a993	e6 01		inc $01				inc 	1 							; colour block
.a995	ac 3f 06	ldy $063f			ldy 	EXTColumn 					; get attribute of last character
.a998	88		dey				dey
.a999	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a99b	20 cd a9	jsr $a9cd			jsr 	EXTILDelete 				; backspace attribute
.a99e	80 b9		bra $a959			bra 	_EILLoop 					; and go round.
.a9a0					_EILExit:
.a9a0	a9 02		lda #$02			lda 	#2 							; switch to page 2
.a9a2	85 01		sta $01				sta 	1
.a9a4	a0 00		ldy #$00			ldy 	#0 							; copy current line into buffer.
.a9a6					_EILScrapeLine:
.a9a6	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a9a8	99 a8 05	sta $05a8,y			sta 	lineBuffer,y
.a9ab	c8		iny				iny
.a9ac	cc 41 06	cpy $0641			cpy 	EXTScreenWidth
.a9af	d0 f5		bne $a9a6			bne 	_EILScrapeLine
.a9b1					_EILTrimSpaces:
.a9b1	88		dey				dey
.a9b2	f0 08		beq $a9bc			beq 	_EILEndTrim
.a9b4	b9 a8 05	lda $05a8,y			lda 	lineBuffer,y
.a9b7	c9 20		cmp #$20			cmp 	#' '
.a9b9	f0 f6		beq $a9b1			beq 	_EILTrimSpaces
.a9bb	c8		iny				iny 								; trim after non space character.
.a9bc					_EILEndTrim:
.a9bc	a9 00		lda #$00			lda 	#0 							; trim here.
.a9be	99 a8 05	sta $05a8,y			sta 	lineBuffer,y
.a9c1	a9 0d		lda #$0d			lda 	#13 						; echo the RETURN
.a9c3	20 c5 a7	jsr $a7c5			jsr 	ExtPrintCharacter
.a9c6	68		pla				pla 								; reset I/O page
.a9c7	85 01		sta $01				sta 	1
.a9c9	7a		ply				ply
.a9ca	fa		plx				plx
.a9cb	68		pla				pla
.a9cc	60		rts				rts
.a9cd					EXTILDelete:
.a9cd	48		pha				pha 								; save the new character
.a9ce	ac 3f 06	ldy $063f			ldy 	EXTColumn 					; start copying from here.
.a9d1					_EXTDLoop:
.a9d1	c8		iny				iny 								; copy one byte down.
.a9d2	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a9d4	88		dey				dey
.a9d5	91 40		sta ($40),y			sta 	(EXTAddress),y
.a9d7	c8		iny				iny 								; do till end of line.
.a9d8	cc 41 06	cpy $0641			cpy 	EXTScreenWidth
.a9db	90 f4		bcc $a9d1			bcc 	_EXTDLoop
.a9dd	88		dey				dey 	 							; write in last slot.
.a9de	68		pla				pla
.a9df	91 40		sta ($40),y			sta 	(EXTAddress),y
.a9e1	60		rts				rts
.a9e2					EXTILInsert:
.a9e2	ac 41 06	ldy $0641			ldy 	EXTScreenWidth 				; end position
.a9e5					_EXTILoop:
.a9e5	88		dey				dey 								; back one
.a9e6	cc 3f 06	cpy $063f			cpy 	EXTColumn 					; exit if reached insert point.
.a9e9	f0 08		beq $a9f3			beq 	_EXTIExit
.a9eb	88		dey				dey 								; copy one byte up.
.a9ec	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a9ee	c8		iny				iny
.a9ef	91 40		sta ($40),y			sta 	(EXTAddress),y
.a9f1	80 f2		bra $a9e5			bra 	_EXTILoop
.a9f3					_EXTIExit:
.a9f3	60		rts				rts
.a9f4					EXTScrollFill:
.a9f4	aa		tax				tax									; save value to fill with
.a9f5	a5 36		lda $36				lda 	zTemp0 						; save zTemp0 (dest) zTemp1 (src)
.a9f7	48		pha				pha
.a9f8	a5 37		lda $37				lda 	zTemp0+1
.a9fa	48		pha				pha
.a9fb	a5 38		lda $38				lda 	zTemp1
.a9fd	48		pha				pha
.a9fe	a5 39		lda $39				lda 	zTemp1+1
.aa00	48		pha				pha
.aa01	a9 c0		lda #$c0			lda 	#$C0 						; copy from C000+length to C000
.aa03	85 37		sta $37				sta 	zTemp0+1
.aa05	85 39		sta $39				sta 	zTemp1+1
.aa07	64 36		stz $36				stz 	zTemp0
.aa09	ad 41 06	lda $0641			lda 	EXTScreenWidth
.aa0c	85 38		sta $38				sta 	zTemp1
.aa0e	a0 00		ldy #$00			ldy 	#0
.aa10					_EXSFCopy1:
.aa10	b1 38		lda ($38),y			lda 	(zTemp1),y
.aa12	91 36		sta ($36),y			sta 	(zTemp0),y
.aa14	c8		iny				iny
.aa15	d0 f9		bne $aa10			bne 	_EXSFCopy1
.aa17	e6 37		inc $37				inc 	zTemp0+1 					; next page
.aa19	e6 39		inc $39				inc 	zTemp1+1
.aa1b	a5 39		lda $39				lda 	zTemp1+1
.aa1d	c9 d3		cmp #$d3			cmp 	#$D3
.aa1f	d0 ef		bne $aa10			bne 	_EXSFCopy1
.aa21	ac 41 06	ldy $0641			ldy 	EXTScreenWidth 				; blank the bottom line.
.aa24	8a		txa				txa
.aa25					_EXSFFill1:
.aa25	88		dey				dey
.aa26	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa28	c0 00		cpy #$00			cpy 	#0
.aa2a	10 f9		bpl $aa25			bpl 	_EXSFFill1
.aa2c	68		pla				pla
.aa2d	85 39		sta $39				sta 	zTemp1+1
.aa2f	68		pla				pla
.aa30	85 38		sta $38				sta 	zTemp1
.aa32	68		pla				pla
.aa33	85 37		sta $37				sta 	zTemp0+1
.aa35	68		pla				pla
.aa36	85 36		sta $36				sta 	zTemp0
.aa38	60		rts				rts
=$c000					EXTMemory = $C000
=$02					EXTTextPage = $02
=$03					EXTColourPage = $03
=1					EXTDummySpace = 1 							; fake-space for CR character.
=0					EXTCBlack = 0
.063e					EXTRow:
>063e							.fill 	1
.063f					EXTColumn:
>063f							.fill 	1
.0640					EXTTextColour:
>0640							.fill 	1
.0641					EXTScreenWidth:
>0641							.fill 	1
.0642					EXTScreenHeight:
>0642							.fill 	1
.0040					EXTAddress:
>0040							.fill 	2
.aa39					EXTInitialise:
.aa39	64 01		stz $01				stz 	1 							; Access I/O
.aa3b	9c 04 d0	stz $d004			stz 	$D004 						; Disable border
.aa3e	9c 08 d0	stz $d008			stz 	$D008
.aa41	9c 09 d0	stz $d009			stz 	$D009
.aa44	a9 09		lda #$09			lda 	#1+8						; Timer On at 70Hz counting up.
.aa46	8d 58 d6	sta $d658			sta 	$D658
.aa49	a9 76		lda #$76			lda 	#CONForeground * 16 + CONBackground
.aa4b	8d 40 06	sta $0640			sta 	EXTTextColour
.aa4e	a9 50		lda #$50			lda 	#80 						; set screen dimensions.
.aa50	8d 41 06	sta $0641			sta 	EXTScreenWidth
.aa53	a9 3c		lda #$3c			lda 	#60
.aa55	8d 42 06	sta $0642			sta 	EXTScreenHeight
.aa58	64 01		stz $01				stz 	1
.aa5a	60		rts				rts
.aa5b					EXTInputSingleCharacter:
.aa5b	da		phx				phx
.aa5c	5a		phy				phy
.aa5d					_EISCWait:
.aa5d	64 01		stz $01				stz 	1 							; access I/O Page 0
.aa5f	38		sec				sec 								; calculate timer - LastTick
.aa60	ad 59 d6	lda $d659			lda 	$D659
.aa63	aa		tax				tax 								; saving timer in X
.aa64	ed 2d 06	sbc $062d			sbc 	LastTick
.aa67	c9 03		cmp #$03			cmp 	#3
.aa69	90 06		bcc $aa71			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.aa6b	8e 2d 06	stx $062d			stx 	LastTick 					; update last timer
.aa6e	20 db b9	jsr $b9db			jsr 	TickHandler 				; go do the code.
.aa71					_NoFireTick:
.aa71	20 e4 ff	jsr $ffe4			jsr 	$FFE4
.aa74	c9 00		cmp #$00			cmp 	#0
.aa76	f0 e5		beq $aa5d			beq 	_EISCWait
.aa78	7a		ply				ply
.aa79	fa		plx				plx
.aa7a	60		rts				rts
.aa7b					EXTBreakCheck:
.aa7b	4c e1 ff	jmp $ffe1			jmp		$FFE1
.aa7e					EXTReadController:
.aa7e	da		phx				phx
.aa7f	a2 00		ldx #$00			ldx 	#0
.aa81	a9 05		lda #$05			lda 	#(($2D) >> 3)
.aa83	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa86	29 20		and #$20			and 	#($01 << (($2D) & 7))
.aa88	f0 04		beq $aa8e			beq 	_NoSet1
.aa8a	8a		txa				txa
.aa8b	09 01		ora #$01			ora 	#1
.aa8d	aa		tax				tax
.aa8e					_NoSet1:
.aa8e	a9 05		lda #$05			lda 	#(($2C) >> 3)
.aa90	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa93	29 10		and #$10			and 	#($01 << (($2C) & 7))
.aa95	f0 04		beq $aa9b			beq 	_NoSet1
.aa97	8a		txa				txa
.aa98	09 02		ora #$02			ora 	#2
.aa9a	aa		tax				tax
.aa9b					_NoSet1:
.aa9b	a9 06		lda #$06			lda 	#(($32) >> 3)
.aa9d	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aaa0	29 04		and #$04			and 	#($01 << (($32) & 7))
.aaa2	f0 04		beq $aaa8			beq 	_NoSet1
.aaa4	8a		txa				txa
.aaa5	09 04		ora #$04			ora 	#4
.aaa7	aa		tax				tax
.aaa8					_NoSet1:
.aaa8	a9 04		lda #$04			lda 	#(($25) >> 3)
.aaaa	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aaad	29 20		and #$20			and 	#($01 << (($25) & 7))
.aaaf	f0 04		beq $aab5			beq 	_NoSet1
.aab1	8a		txa				txa
.aab2	09 08		ora #$08			ora 	#8
.aab4	aa		tax				tax
.aab5					_NoSet1:
.aab5	a9 04		lda #$04			lda 	#(($26) >> 3)
.aab7	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aaba	29 40		and #$40			and 	#($01 << (($26) & 7))
.aabc	f0 04		beq $aac2			beq 	_NoSet1
.aabe	8a		txa				txa
.aabf	09 10		ora #$10			ora 	#16
.aac1	aa		tax				tax
.aac2					_NoSet1:
.aac2	8a		txa				txa
.aac3	fa		plx				plx
.aac4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_graphics.module

=1					graphicsIntegrated=1
=0					GCMD_Initialise = 0*2
=2					GCMD_BitmapCtl = 1*2
=4					GCMD_SpriteCtl = 2*2
=6					GCMD_Clear = 3*2
=8					GCMD_Colour = 4*2
=10					GCMD_DrawFont = 5*2
=12					GCMD_DrawSprite = 6*2
=14					GCMD_SpriteUse = 7*2
=16					GCMD_SpriteImage = 8*2
=18					GCMD_SpriteCollide = 9*2
=64					GCMD_Move = 32*2
=66					GCMD_Line = 33*2
=68					GCMD_FrameRect = 34*2
=70					GCMD_FillRect = 35*2
=72					GCMD_FrameCircle = 36*2
=74					GCMD_FillCircle = 37*2
=80					GCMD_Plot = 40*2
=82					GCMD_SpriteMove = 41*2
=42					GRFirstFreeCode = 42
.b9e1					GRVectorTable:
>b9e1	c0 ac					.word	GXInitialise             ; $00 Initialise
>b9e3	da ac					.word	GXControlBitmap          ; $01 BitmapCtl
>b9e5	22 ad					.word	GXControlSprite          ; $02 SpriteCtl
>b9e7	72 ac					.word	GXClearBitmap            ; $03 Clear
>b9e9	b1 ae					.word	GXSetColourMode          ; $04 Colour
>b9eb	79 b0					.word	GXFontHandler            ; $05 DrawFont
>b9ed	c1 b0					.word	GXSpriteHandler          ; $06 DrawSprite
>b9ef	2d b1					.word	GXSelect                 ; $07 SpriteUse
>b9f1	56 b1					.word	GXSelectImage            ; $08 SpriteImage
>b9f3	dd b2					.word	GXCollide                ; $09 SpriteCollide
>b9f5	24 ab					.word	GRUndefined              ; $0a
>b9f7	24 ab					.word	GRUndefined              ; $0b
>b9f9	24 ab					.word	GRUndefined              ; $0c
>b9fb	24 ab					.word	GRUndefined              ; $0d
>b9fd	24 ab					.word	GRUndefined              ; $0e
>b9ff	24 ab					.word	GRUndefined              ; $0f
>ba01	24 ab					.word	GRUndefined              ; $10
>ba03	24 ab					.word	GRUndefined              ; $11
>ba05	24 ab					.word	GRUndefined              ; $12
>ba07	24 ab					.word	GRUndefined              ; $13
>ba09	24 ab					.word	GRUndefined              ; $14
>ba0b	24 ab					.word	GRUndefined              ; $15
>ba0d	24 ab					.word	GRUndefined              ; $16
>ba0f	24 ab					.word	GRUndefined              ; $17
>ba11	24 ab					.word	GRUndefined              ; $18
>ba13	24 ab					.word	GRUndefined              ; $19
>ba15	24 ab					.word	GRUndefined              ; $1a
>ba17	24 ab					.word	GRUndefined              ; $1b
>ba19	24 ab					.word	GRUndefined              ; $1c
>ba1b	24 ab					.word	GRUndefined              ; $1d
>ba1d	24 ab					.word	GRUndefined              ; $1e
>ba1f	24 ab					.word	GRUndefined              ; $1f
>ba21	22 ab					.word	GXMove                   ; $20 Move
>ba23	7f ad					.word	GXLine                   ; $21 Line
>ba25	fa ae					.word	GXFrameRectangle         ; $22 FrameRect
>ba27	f7 ae					.word	GXFillRectangle          ; $23 FillRect
>ba29	29 ab					.word	GXFrameCircle            ; $24 FrameCircle
>ba2b	25 ab					.word	GXFillCircle             ; $25 FillCircle
>ba2d	24 ab					.word	GRUndefined              ; $26
>ba2f	24 ab					.word	GRUndefined              ; $27
>ba31	df ae					.word	GXPlotPoint              ; $28 Plot
>ba33	ec b1					.word	GXMoveSprite             ; $29 SpriteMove
=3					GXMappingPage = 3
=24576					GXMappingAddress = ($2000 * GXMappingPage)
=11					GXEditSlot = 8 + GXMappingPage
=$36					gxzTemp0 = zTemp0
=$38					gxzTemp1 = zTemp1
=$3a					gxzTemp2 = zTemp2
=$3c					gxzScreen = zsTemp
=$5f9					gxPixelBuffer = numberBuffer
.0643					gxCurrentX:
>0643							.fill 	2
.0645					gxCurrentY:
>0645							.fill 	2
.0647					gxLastX:
>0647							.fill 	2
.0649					gxLastY:
>0649							.fill 	2
.064b					gxX0:
>064b							.fill 	2
.064d					gxY0:
>064d							.fill 	2
.064f					gxX1:
>064f							.fill 	2
.0651					gxY1:
>0651							.fill 	2
.0653					gxSpritesOn:
>0653							.fill 	1
.0654					gxBitmapsOn:
>0654							.fill 	1
.0655					gxBasePage:
>0655							.fill 	1
.0656					gxSpritePage:
>0656							.fill 	1
.0657					gxHeight:
>0657							.fill 	1
.0658					gxMode:
>0658							.fill 	1
.0659					gxColour:
>0659							.fill 	1
.065a					gxEORValue:
>065a							.fill 	1
.065b					gxANDValue:
>065b							.fill 	1
.065c					gxOriginalLUTValue:
>065c							.fill 	1
.065d					gsOffset:
>065d							.fill 	1
.065e					GSCurrentSpriteID:
>065e							.fill 	1
.065f					GSCurrentSpriteAddr:
>065f							.fill 	2
.0661					GXSpriteOffsetBase:
>0661							.fill 	2
.0663					GXSpriteLow:
>0663							.fill 	64
.06a3					GXSpriteHigh:
>06a3							.fill 	64
.aac5					GXGraphicDraw:
.aac5	c9 40		cmp #$40			cmp 	#GCMD_Move					; low instructions don't use coordinates
.aac7	b0 06		bcs $aacf			bcs 	_GDCoordinate
.aac9	86 36		stx $36				stx 	gxzTemp0 					; save X/Y
.aacb	84 37		sty $37				sty 	gxzTemp0+1
.aacd	80 4b		bra $ab1a			bra 	_GDExecuteA 				; and execute
.aacf					_GDCoordinate:
.aacf	48		pha				pha 								; save AXY
.aad0	da		phx				phx
.aad1	5a		phy				phy
.aad2	a2 03		ldx #$03			ldx 	#3 							; copy currentX to lastX
.aad4					_GDCopy1:
.aad4	bd 43 06	lda $0643,x			lda 	gxCurrentX,x
.aad7	9d 47 06	sta $0647,x			sta 	gxLastX,x
.aada	ca		dex				dex
.aadb	10 f7		bpl $aad4			bpl 	_GDCopy1
.aadd	68		pla				pla 								; update Y
.aade	8d 45 06	sta $0645			sta 	gxCurrentY
.aae1	9c 46 06	stz $0646			stz 	gxCurrentY+1
.aae4	68		pla				pla
.aae5	8d 43 06	sta $0643			sta 	gxCurrentX
.aae8	68		pla				pla 								; get A (command+X.1) back
.aae9	48		pha				pha
.aaea	29 01		and #$01			and 	#1 							; put LSB as MSB of Current.X
.aaec	8d 44 06	sta $0644			sta 	gxCurrentX+1
.aaef	68		pla				pla 								; get command back
.aaf0	29 fe		and #$fe			and 	#$FE 						; lose LSB, chuck the stray X bit
.aaf2	48		pha				pha 								; push back.
.aaf3	c9 52		cmp #$52			cmp 	#GCMD_SpriteMove 			; move sprite does not clip.
.aaf5	f0 17		beq $ab0e			beq 	_GDCopyToWorkArea
.aaf7	ad 44 06	lda $0644			lda 	gxCurrentX+1 				; X < 256 X okay
.aafa	f0 07		beq $ab03			beq 	_GDCheckY
.aafc	ad 43 06	lda $0643			lda 	gxCurrentX 					; otherwise X < 320 = 256 + 64
.aaff	c9 40		cmp #$40			cmp 	#64
.ab01	b0 08		bcs $ab0b			bcs 	_GDError1
.ab03					_GDCheckY:
.ab03	ad 45 06	lda $0645			lda 	gxCurrentY 					; check Y < Height.
.ab06	cd 57 06	cmp $0657			cmp 	gxHeight
.ab09	90 03		bcc $ab0e			bcc 	_GDCopyToWorkArea
.ab0b					_GDError1:
.ab0b	68		pla				pla
.ab0c					_GDError2:
.ab0c	38		sec				sec
.ab0d	60		rts				rts
.ab0e					_GDCopyToWorkArea:
.ab0e	a2 07		ldx #$07			ldx 	#7 							; copy current and last to gxXY/12 work area
.ab10					_GDCopy2:
.ab10	bd 43 06	lda $0643,x			lda 	gxCurrentX,x
.ab13	9d 4b 06	sta $064b,x			sta 	gxX0,x
.ab16	ca		dex				dex
.ab17	10 f7		bpl $ab10			bpl 	_GDCopy2
.ab19	68		pla				pla 								; get command
.ab1a					_GDExecuteA:
.ab1a	c9 54		cmp #$54			cmp 	#GRFirstFreeCode*2 			; bad ?
.ab1c	b0 ee		bcs $ab0c			bcs 	_GDError2
.ab1e	aa		tax				tax
.ab1f	7c e1 b9	jmp ($b9e1,x)			jmp 	(GRVectorTable,x)
.ab22					GXMove:
.ab22	18		clc				clc
.ab23	60		rts				rts
.ab24					GRUndefined:
>ab24	db						.byte 	$DB 						; causes a break in the emulator
.ab25					GXFillCircle:
.ab25	a9 ff		lda #$ff			lda 	#255
.ab27	80 02		bra $ab2b			bra 	GXCircle
.ab29					GXFrameCircle:
.ab29	a9 00		lda #$00			lda 	#0
.ab2b					GXCircle:
.ab2b	8d e6 06	sta $06e6			sta 	gxIsFillMode					; save Fill flag
.ab2e	ad 54 06	lda $0654			lda 	gxBitmapsOn
.ab31	f0 26		beq $ab59			beq 	_GXCFail
.ab33	20 84 b3	jsr $b384			jsr 	GXSortXY 					; topleft/bottomright
.ab36	20 5c b2	jsr $b25c			jsr 	GXOpenBitmap 				; start drawing
.ab39	20 2b ac	jsr $ac2b			jsr 	GXCircleSetup 				; set up for drawing
.ab3c	9c e7 06	stz $06e7			stz 	gxYChanged
.ab3f					_GXCircleDraw:
.ab3f	ad e4 06	lda $06e4			lda 	gXCentre					; while x <= y
.ab42	cd e5 06	cmp $06e5			cmp 	gYCentre
.ab45	90 0a		bcc $ab51			bcc 	_GXCircleContinue
.ab47	d0 03		bne $ab4c			bne 	_GXNoLast
.ab49	20 5e ab	jsr $ab5e			jsr 	GXPlot1
.ab4c					_GXNoLast:
.ab4c	20 64 b2	jsr $b264			jsr 	GXCloseBitmap 				; close the bitmap
.ab4f	18		clc				clc
.ab50	60		rts				rts
.ab51					_GXCircleContinue:
.ab51	20 5b ab	jsr $ab5b			jsr 	GXPlot2 					; draw it
.ab54	20 d8 ab	jsr $abd8			jsr 	GXCircleMove 				; adjust the coordinates
.ab57	80 e6		bra $ab3f			bra 	_GXCircleDraw
.ab59					_GXCFail:
.ab59	38		sec				sec
.ab5a	60		rts				rts
.ab5b					GXPlot2:
.ab5b	20 5e ab	jsr $ab5e			jsr 	GXPlot1 						; plot and swap, fall through does twice
.ab5e					GXPlot1:
.ab5e	ad e5 06	lda $06e5			lda 	gYCentre 						; if y = 0, don't do it twice (xor)
.ab61	f0 03		beq $ab66			beq 	_GXPlot1Only
.ab63	20 82 ab	jsr $ab82			jsr 	GXPlot0 						; plot and negate
.ab66					_GXPlot1Only:
.ab66	20 82 ab	jsr $ab82			jsr 	GXPlot0 						; twice, undoing negation
.ab69	ad e4 06	lda $06e4			lda 	gXCentre 						; swap X and Y
.ab6c	ae e5 06	ldx $06e5			ldx	 	gYCentre
.ab6f	8d e5 06	sta $06e5			sta 	gYCentre
.ab72	8e e4 06	stx $06e4			stx 	gXCentre
.ab75	ad e7 06	lda $06e7			lda 	gxYChanged 						; toggle Y Changed flag
.ab78	a9 ff		lda #$ff			lda 	#$FF
.ab7a	8d e7 06	sta $06e7			sta 	gxYChanged
.ab7d	60		rts				rts
.ab7e	20 82 ab	jsr $ab82			jsr 	GXPlot0 						; do once
.ab81	60		rts				rts
.ab82	ad e6 06	lda $06e6	GXPlot0:lda 	gxIsFillMode 					; outline mode, always draw as X or Y will change
.ab85	f0 05		beq $ab8c			beq 	_GXPlot0Always
.ab87	ad e7 06	lda $06e7			lda 	gxYChanged						; fill mode, only draw if changed.
.ab8a	f0 2d		beq $abb9			beq 	GXPlot0Exit
.ab8c					_GXPlot0Always:
.ab8c	a2 02		ldx #$02			ldx 	#2 								; copy Y1-A => Y0
.ab8e	ad e5 06	lda $06e5			lda 	gYCentre
.ab91	20 ba ab	jsr $abba			jsr 	GXSubCopy
.ab94	a2 00		ldx #$00			ldx 	#0 								; copy X1-A => X0,
.ab96	ad e4 06	lda $06e4			lda 	gXCentre
.ab99	20 ba ab	jsr $abba			jsr 	GXSubCopy
.ab9c	48		pha				pha 									; save last offset X
.ab9d	20 6c b2	jsr $b26c			jsr 	GXPositionCalc 					; calculate position/offset.
.aba0	68		pla				pla
.aba1	0a		asl a				asl 	a 								; store 2 x last offset in gxzTemp0
.aba2	85 36		sta $36				sta 	gxzTemp0
.aba4	64 37		stz $37				stz 	gxzTemp0+1
.aba6	26 37		rol $37				rol 	gxzTemp0+1
.aba8	ad e6 06	lda $06e6			lda 	gxIsFillMode
.abab	69 80		adc #$80			adc 	#128
.abad	20 4a af	jsr $af4a			jsr 	GXDrawLineTemp0 				; routine from Rectangle.
.abb0	38		sec				sec 									; GY = -GY
.abb1	a9 00		lda #$00			lda 	#0
.abb3	ed e5 06	sbc $06e5			sbc 	gYCentre
.abb6	8d e5 06	sta $06e5			sta 	gYCentre
.abb9					GXPlot0Exit:
.abb9	60		rts				rts
.abba					GXSubCopy:
.abba	85 36		sta $36				sta 	gxzTemp0
.abbc	64 37		stz $37				stz 	gxzTemp0+1
.abbe	29 80		and #$80			and 	#$80
.abc0	f0 02		beq $abc4			beq 	_GXNoSx
.abc2	c6 37		dec $37				dec 	gxzTemp0+1
.abc4					_GXNoSx:
.abc4	38		sec				sec
.abc5	bd 4f 06	lda $064f,x			lda 	gXX1,x
.abc8	e5 36		sbc $36				sbc 	gxzTemp0
.abca	9d 4b 06	sta $064b,x			sta 	gXX0,x
.abcd	bd 50 06	lda $0650,x			lda 	gXX1+1,x
.abd0	e5 37		sbc $37				sbc 	gxzTemp0+1
.abd2	9d 4c 06	sta $064c,x			sta 	gXX0+1,x
.abd5	a5 36		lda $36				lda 	gxzTemp0 						; return A
.abd7	60		rts				rts
.abd8					GXCircleMove:
.abd8	9c e7 06	stz $06e7			stz 	gxYChanged 					; clear Y changed flag
.abdb	a5 39		lda $39				lda 	gxzTemp1+1 					; check sign of D
.abdd	10 0d		bpl $abec			bpl 	_GXEMPositive
.abdf	ee e4 06	inc $06e4			inc 	gXCentre 					; X++
.abe2	ad e4 06	lda $06e4			lda 	gXCentre
.abe5	20 0b ac	jsr $ac0b			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.abe8	a9 06		lda #$06			lda 	#6  						; and add 6
.abea	80 15		bra $ac01			bra 	_GXEMAddD
.abec					_GXEMPositive:
.abec	ee e4 06	inc $06e4			inc 	gXCentre					; X++
.abef	ce e5 06	dec $06e5			dec 	gyCentre 					; Y--
.abf2	38		sec				sec 								; calculate X-Y
.abf3	ad e4 06	lda $06e4			lda 	gXCentre
.abf6	ed e5 06	sbc $06e5			sbc 	gYCentre
.abf9	20 0b ac	jsr $ac0b			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.abfc	a9 0a		lda #$0a			lda 	#10  						; and add 10
.abfe	ce e7 06	dec $06e7			dec 	gxYChanged
.ac01					_GXEMAddD:
.ac01	18		clc				clc
.ac02	65 38		adc $38				adc 	gxzTemp1
.ac04	85 38		sta $38				sta 	gxzTemp1
.ac06	90 02		bcc $ac0a			bcc 	_GXEMNoCarry
.ac08	e6 39		inc $39				inc 	gxzTemp1+1
.ac0a					_GXEMNoCarry:
.ac0a	60		rts				rts
.ac0b					_GXAdd4TimesToD:
.ac0b	85 36		sta $36				sta 	gxzTemp0 					; make 16 bit signed.
.ac0d	29 80		and #$80			and 	#$80
.ac0f	f0 02		beq $ac13			beq 	_GXA4Unsigned
.ac11	a9 ff		lda #$ff			lda 	#$FF
.ac13					_GXA4Unsigned:
.ac13	85 37		sta $37				sta 	gxzTemp0+1
.ac15	06 36		asl $36				asl 	gxzTemp0  					; x 4
.ac17	26 37		rol $37				rol 	gxzTemp0+1
.ac19	06 36		asl $36				asl 	gxzTemp0
.ac1b	26 37		rol $37				rol 	gxzTemp0+1
.ac1d	18		clc				clc 								; add
.ac1e	a5 36		lda $36				lda		gxzTemp0
.ac20	65 38		adc $38				adc 	gxzTemp1
.ac22	85 38		sta $38				sta 	gxzTemp1
.ac24	a5 37		lda $37				lda		gxzTemp0+1
.ac26	65 39		adc $39				adc 	gxzTemp1+1
.ac28	85 39		sta $39				sta 	gxzTemp1+1
.ac2a	60		rts				rts
.ac2b					GXCircleSetup:
.ac2b	38		sec				sec
.ac2c	ad 51 06	lda $0651			lda 	gxY1
.ac2f	ed 4d 06	sbc $064d			sbc 	gxY0
.ac32	4a		lsr a				lsr 	a
.ac33	8d e3 06	sta $06e3			sta 	gxRadius
.ac36	a2 00		ldx #$00			ldx 	#0
.ac38	20 5a ac	jsr $ac5a			jsr 	_GXCalculateCentre
.ac3b	a2 02		ldx #$02			ldx 	#2
.ac3d	20 5a ac	jsr $ac5a			jsr 	_GXCalculateCentre
.ac40	9c e4 06	stz $06e4			stz 	gXCentre
.ac43	ad e3 06	lda $06e3			lda 	gxRadius
.ac46	8d e5 06	sta $06e5			sta 	gYCentre
.ac49	0a		asl a				asl 	a 							; R x 2
.ac4a	85 36		sta $36				sta 	gxzTemp0
.ac4c	38		sec				sec
.ac4d	a9 03		lda #$03			lda 	#3
.ac4f	e5 36		sbc $36				sbc 	gxzTemp0
.ac51	85 38		sta $38				sta 	gxzTemp1
.ac53	a9 00		lda #$00			lda 	#0
.ac55	e9 00		sbc #$00			sbc 	#0
.ac57	85 39		sta $39				sta 	gxzTemp1+1
.ac59	60		rts				rts
.ac5a					_GXCalculateCentre:
.ac5a	38		sec				sec
.ac5b	bd 4f 06	lda $064f,x			lda 	gxX1,x
.ac5e	7d 4b 06	adc $064b,x			adc 	gXX0,x
.ac61	9d 4f 06	sta $064f,x			sta 	gXX1,x
.ac64	bd 50 06	lda $0650,x			lda 	gXX1+1,x
.ac67	7d 4c 06	adc $064c,x			adc 	gXX0+1,x
.ac6a	4a		lsr a				lsr 	a
.ac6b	9d 50 06	sta $0650,x			sta 	gXX1+1,x
.ac6e	7e 4f 06	ror $064f,x			ror 	gXX1,x
.ac71	60		rts				rts
.06e3					gxRadius:
>06e3							.fill 	1
.06e4					gXCentre:
>06e4							.fill 	1
.06e5					gYCentre:
>06e5							.fill 	1
.06e6					gxIsFillMode:
>06e6							.fill 	1
.06e7					gxYChanged:
>06e7							.fill  	1
=64000					ScreenSize200 = 320 * 200
=76800					ScreenSize240 = 320 * 240
.ac72					GXClearBitmap:
.ac72	ad 54 06	lda $0654			lda 	gxBitmapsOn 				; check BMP running.
.ac75	f0 24		beq $ac9b			beq 	_GXCBFail
.ac77	20 5c b2	jsr $b25c			jsr 	GXOpenBitmap 				; start access
.ac7a	a0 07		ldy #$07			ldy 	#ScreenSize200 / 8192 		; X is pages to clear
.ac7c	ad 57 06	lda $0657			lda 	gxHeight
.ac7f	c9 c8		cmp #$c8			cmp 	#200 						; 200 ?
.ac81	a0 09		ldy #$09			ldy 	#ScreenSize240 / 8192
.ac83					_GXCalcLastPage:
.ac83	98		tya				tya 								; add to base page
.ac84	18		clc				clc
.ac85	6d 55 06	adc $0655			adc 	gxBasePage
.ac88	85 0b		sta $0b				sta 	GXEditSlot  				; clear from this page back
.ac8a					_GXClearAll:
.ac8a	20 9d ac	jsr $ac9d			jsr 	_GXClearBlock 				; clear 8k block
.ac8d	c6 0b		dec $0b				dec 	GXEditSlot  				; back to previous
.ac8f	a5 0b		lda $0b				lda 	GXEditSlot
.ac91	cd 55 06	cmp $0655			cmp 	gxBasePage 					; until before base page
.ac94	b0 f4		bcs $ac8a			bcs 	_GXClearAll
.ac96	20 64 b2	jsr $b264			jsr 	GXCloseBitmap	 			; stop access
.ac99	18		clc				clc
.ac9a	60		rts				rts
.ac9b					_GXCBFail:
.ac9b	38		sec				sec
.ac9c	60		rts				rts
.ac9d					_GXClearBlock:
.ac9d	a9 00		lda #$00			lda 	#((GXMappingAddress) & $FF)
.ac9f	85 38		sta $38				sta 	0+gxzTemp1
.aca1	a9 60		lda #$60			lda 	#((GXMappingAddress) >> 8)
.aca3	85 39		sta $39				sta 	1+gxzTemp1
.aca5					_GXCB0:
.aca5	a5 36		lda $36				lda 	gxzTemp0
.aca7	a0 00		ldy #$00			ldy 	#0
.aca9					_GXCB1:
.aca9	91 38		sta ($38),y			sta 	(gxzTemp1),y
.acab	c8		iny				iny
.acac	91 38		sta ($38),y			sta 	(gxzTemp1),y
.acae	c8		iny				iny
.acaf	91 38		sta ($38),y			sta 	(gxzTemp1),y
.acb1	c8		iny				iny
.acb2	91 38		sta ($38),y			sta 	(gxzTemp1),y
.acb4	c8		iny				iny
.acb5	d0 f2		bne $aca9			bne 	_GXCB1
.acb7	e6 39		inc $39				inc 	gxzTemp1+1
.acb9	a5 39		lda $39				lda 	gxzTemp1+1
.acbb	c9 80		cmp #$80			cmp	 	#(GXMappingAddress >> 8)+$20
.acbd	d0 e6		bne $aca5			bne 	_GXCB0
.acbf	60		rts				rts
.acc0					GXInitialise:
.acc0	64 01		stz $01				stz 	1
.acc2	a9 01		lda #$01			lda 	#1
.acc4	8d 00 d0	sta $d000			sta 	$D000
.acc7	18		clc				clc
.acc8	9c 53 06	stz $0653			stz 	GXSpritesOn
.accb	9c 54 06	stz $0654			stz 	GXBitmapsOn
.acce	a2 0f		ldx #$0f			ldx 	#15
.acd0					_GXIClear:
.acd0	9e 43 06	stz $0643,x			stz 	gxCurrentX,x
.acd3	ca		dex				dex
.acd4	10 fa		bpl $acd0			bpl 	_GXIClear
.acd6	20 71 ad	jsr $ad71			jsr 	GXClearSpriteStore
.acd9	60		rts				rts
.acda					GXControlBitmap:
.acda	64 01		stz $01				stz 	1
.acdc	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.acde	29 01		and #$01			and 	#1 							; set bitmap flag
.ace0	8d 54 06	sta $0654			sta 	gxBitmapsOn
.ace3	4a		lsr a				lsr 	a 							; bit 0 into carry.
.ace4	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.ace7	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.ace9	29 f7		and #$f7			and 	#$F7 						; clear bitmap bit
.aceb	90 02		bcc $acef			bcc 	_CBNotOn
.aced	09 08		ora #$08			ora 	#$08 						; bitmap on if 1 on 0 off
.acef					_CBNotOn:
.acef	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.acf2	a5 36		lda $36				lda 	gxzTemp0 					; get control settings (bits 0-2)
.acf4	29 07		and #$07			and 	#7
.acf6	8d 00 d1	sta $d100			sta 	$D100 						; write in Vicky Bitmap Control Register #0
.acf9	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.acfb	d0 02		bne $acff			bne 	_CBNotDefault
.acfd	a9 08		lda #$08			lda 	#8  						; if zero, use 8 e.g. bitmap at $10000
.acff					_CBNotDefault:
.acff	8d 55 06	sta $0655			sta 	gxBasePage
.ad02	20 63 ad	jsr $ad63			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.ad05	a5 37		lda $37				lda 	gxzTemp0+1 					; copy address into Bitmap address registers
.ad07	8d 03 d1	sta $d103			sta 	$D103
.ad0a	a5 36		lda $36				lda 	gxzTemp0
.ad0c	8d 02 d1	sta $d102			sta 	$D102
.ad0f	9c 01 d1	stz $d101			stz 	$D101
.ad12	a2 f0		ldx #$f0			ldx 	#240 						; height is 240
.ad14	ad 01 d0	lda $d001			lda 	$D001 						; read MCR bit 0
.ad17	29 01		and #$01			and 	#1
.ad19	f0 02		beq $ad1d			beq 	_CBHaveHeight
.ad1b	a2 c8		ldx #$c8			ldx 	#200 						; if bit 0 set 320x200
.ad1d					_CBHaveHeight
.ad1d	8e 57 06	stx $0657			stx 	gxHeight
.ad20	18		clc				clc
.ad21	60		rts				rts
.ad22					GXControlSprite:
.ad22	64 01		stz $01				stz 	1
.ad24	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.ad26	29 01		and #$01			and 	#1 							; set sprites flag
.ad28	8d 53 06	sta $0653			sta 	gxSpritesOn
.ad2b	4a		lsr a				lsr 	a 							; bit 0 into carry.
.ad2c	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.ad2f	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.ad31	29 df		and #$df			and 	#$DF 						; clear sprite bit
.ad33	90 02		bcc $ad37			bcc 	_CSNotOn
.ad35	09 20		ora #$20			ora 	#$20 						; sprite on if 1 on 0 off
.ad37					_CSNotOn:
.ad37	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.ad3a	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.ad3c	d0 02		bne $ad40			bne 	_CSNotDefault
.ad3e	a9 18		lda #$18			lda 	#24  						; if zero, use 24 e.g. sprites at $30000
.ad40					_CSNotDefault:
.ad40	8d 56 06	sta $0656			sta 	gxSpritePage
.ad43	20 63 ad	jsr $ad63			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.ad46	a5 36		lda $36				lda 	zTemp0
.ad48	8d 61 06	sta $0661			sta 	GXSpriteOffsetBase
.ad4b	a5 37		lda $37				lda 	zTemp0+1
.ad4d	8d 62 06	sta $0662			sta 	GXSpriteOffsetBase+1
.ad50	a2 00		ldx #$00			ldx 	#0 							; disable all sprites, clears all sprite memory.
.ad52					_CSClear:
.ad52	9e 00 d9	stz $d900,x			stz 	$D900,x
.ad55	9e 00 da	stz $da00,x			stz 	$DA00,x
.ad58	ca		dex				dex
.ad59	d0 f7		bne $ad52			bne 	_CSClear
.ad5b	9c 60 06	stz $0660			stz 	GSCurrentSpriteAddr+1 		; no sprite selected.
.ad5e	20 71 ad	jsr $ad71			jsr 	GXClearSpriteStore
.ad61	18		clc				clc
.ad62	60		rts				rts
.ad63					GXCalculateBaseAddress:
.ad63	85 36		sta $36				sta 	gxzTemp0
.ad65	64 37		stz $37				stz 	gxzTemp0+1
.ad67	a9 05		lda #$05			lda 	#5
.ad69					_GXShift:
.ad69	06 36		asl $36				asl 	gxzTemp0
.ad6b	26 37		rol $37				rol 	gxzTemp0+1
.ad6d	3a		dec a				dec		a
.ad6e	d0 f9		bne $ad69			bne 	_GXShift
.ad70	60		rts				rts
.ad71					GXClearSpriteStore:
.ad71	a2 3f		ldx #$3f			ldx 	#63 						; erase 64 sprite store elements
.ad73					_GXCSSLoop:
.ad73	9e a3 06	stz $06a3,x			stz 	GXSpriteHigh,x
.ad76	a9 80		lda #$80			lda 	#$80 						; set the 'hidden' bit.
.ad78	9d 63 06	sta $0663,x			sta 	GXSpriteLow,x
.ad7b	ca		dex				dex
.ad7c	10 f5		bpl $ad73			bpl 	_GXCSSLoop
.ad7e	60		rts				rts
.ad7f					GXLine:
.ad7f	ad 54 06	lda $0654			lda 	GXBitmapsOn
.ad82	f0 28		beq $adac			beq 	_GXLFail
.ad84	20 5c b2	jsr $b25c			jsr 	GXOpenBitmap
.ad87	20 a2 b3	jsr $b3a2			jsr 	GXSortY						; sort pairs so Y1 >= Y0 e.g. top to bottom.
.ad8a	20 52 ae	jsr $ae52			jsr 	GXLineSetup 				; the calculations in the linescanner constructor
.ad8d	20 6c b2	jsr $b26c			jsr 	GXPositionCalc 				; calculate position/offset.
.ad90					_GXDrawLoop:
.ad90	ac 5d 06	ldy $065d			ldy 	gsOffset 					; draw the pixel
.ad93	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.ad95	2d 5b 06	and $065b			and 	gxANDValue
.ad98	4d 5a 06	eor $065a			eor 	gxEORValue
.ad9b	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.ad9d	20 ae ad	jsr $adae			jsr 	GXLineIsComplete 			; is the line complete ?
.ada0	f0 05		beq $ada7			beq 	_GXLExit
.ada2	20 c9 ad	jsr $adc9			jsr 	GXLineAdvance 				; code as per advance method
.ada5	80 e9		bra $ad90			bra 	_GXDrawLoop
.ada7					_GXLExit:
.ada7	20 64 b2	jsr $b264			jsr 	GXCloseBitmap
.adaa	18		clc				clc
.adab	60		rts				rts
.adac					_GXLFail:
.adac	38		sec				sec
.adad	60		rts				rts
.adae					GXLineIsComplete:
.adae	ad ea 06	lda $06ea			lda 	GXIsDiffYLarger 			; is dy larger
.adb1	d0 0f		bne $adc2			bne 	_GXLICCompareY 				; if so compare Y1/Y0
.adb3	ad 4b 06	lda $064b			lda 	GXX0 						; compare X, LSB and MSB
.adb6	4d 4f 06	eor $064f			eor 	GXX1
.adb9	d0 06		bne $adc1			bne 	_GXLICExit
.adbb	ad 4c 06	lda $064c			lda 	GXX0+1
.adbe	4d 50 06	eor $0650			eor 	GXX1+1
.adc1					_GXLICExit:
.adc1	60		rts				rts
.adc2					_GXLICCompareY:
.adc2	ad 51 06	lda $0651			lda 	GXY1
.adc5	4d 4d 06	eor $064d			eor 	GXY0
.adc8	60		rts				rts
.adc9					GXLineAdvance:
.adc9	18		clc				clc 								; add adjust to position
.adca	ad ec 06	lda $06ec			lda 	GXPosition
.adcd	6d ed 06	adc $06ed			adc 	GXAdjust
.add0	8d ec 06	sta $06ec			sta 	GXPosition
.add3	9c ef 06	stz $06ef			stz 	GXAddSelect 				; clear add select flag
.add6	b0 05		bcs $addd			bcs 	_GXLAOverflow 				; if carry out, overflowed.
.add8	cd ee 06	cmp $06ee			cmp 	GXTotal 					; if exceeded total
.addb	90 0a		bcc $ade7			bcc 	_GXLANoExtra
.addd					_GXLAOverflow:
.addd	ce ef 06	dec $06ef			dec 	GXAddSelect 				; set addselect to $FF
.ade0	38		sec				sec 								; subtract total and write back
.ade1	ed ee 06	sbc $06ee			sbc 	GXTotal
.ade4	8d ec 06	sta $06ec			sta 	GXPosition
.ade7					_GXLANoExtra:
.ade7	ad ea 06	lda $06ea			lda 	GXIsDiffYLarger
.adea	f0 0d		beq $adf9			beq 	_GXDXLarger
.adec	20 4b ae	jsr $ae4b			jsr 	GXIncrementY
.adef	ad ef 06	lda $06ef			lda 	GXAddSelect
.adf2	f0 10		beq $ae04			beq 	_GXLAExit
.adf4	20 05 ae	jsr $ae05			jsr 	GXAdjustX
.adf7	80 0b		bra $ae04			bra 	_GXLAExit
.adf9					_GXDXLarger:
.adf9	20 05 ae	jsr $ae05			jsr 	GXAdjustX
.adfc	ad ef 06	lda $06ef			lda 	GXAddSelect
.adff	f0 03		beq $ae04			beq 	_GXLAExit
.ae01	20 4b ae	jsr $ae4b			jsr 	GXIncrementY
.ae04					_GXLAExit:
.ae04	60		rts				rts
.ae05					GXAdjustX:
.ae05	ad eb 06	lda $06eb			lda 	GXDXNegative
.ae08	10 25		bpl $ae2f			bpl 	_GXAXRight
.ae0a	ad 4b 06	lda $064b			lda 	GXX0
.ae0d	d0 03		bne $ae12			bne 	_GXAXNoBorrow
.ae0f	ce 4c 06	dec $064c			dec 	GXX0+1
.ae12					_GXAXNoBorrow:
.ae12	ce 4b 06	dec $064b			dec 	GXX0
.ae15	ce 5d 06	dec $065d			dec 	gsOffset 					; pixel left
.ae18	ad 5d 06	lda $065d			lda 	gsOffset
.ae1b	c9 ff		cmp #$ff			cmp 	#$FF
.ae1d	d0 0f		bne $ae2e			bne 	_GXAYExit 					; underflow
.ae1f	c6 3d		dec $3d				dec 	gxzScreen+1 					; borrow
.ae21	a5 3d		lda $3d				lda 	gxzScreen+1 					; gone off page
.ae23	c9 60		cmp #$60			cmp 	#GXMappingAddress >> 8
.ae25	b0 07		bcs $ae2e			bcs 	_GXAYExit
.ae27	18		clc				clc
.ae28	69 20		adc #$20			adc 	#$20 						; fix up
.ae2a	85 3d		sta $3d				sta 	gxzScreen+1
.ae2c	c6 0b		dec $0b				dec 	GXEditSlot 				; back one page
.ae2e					_GXAYExit:
.ae2e	60		rts				rts
.ae2f					_GXAXRight:
.ae2f	ee 4b 06	inc $064b			inc 	GXX0
.ae32	d0 03		bne $ae37			bne 	_GXAXNoCarry
.ae34	ee 4c 06	inc $064c			inc 	GXX0+1
.ae37					_GXAXNoCarry:
.ae37	ee 5d 06	inc $065d			inc 	gsOffset 					; pixel right
.ae3a	d0 0e		bne $ae4a			bne 	_GXAXExit 					; if not overflowed, exit.
.ae3c	e6 3d		inc $3d				inc 	gxzScreen+1 					; next line
.ae3e	a5 3d		lda $3d				lda 	gxzScreen+1
.ae40	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.ae42	90 06		bcc $ae4a			bcc 	_GXAXExit
.ae44	e9 20		sbc #$20			sbc 	#$20 						; fix up
.ae46	85 3d		sta $3d				sta 	gxzScreen+1
.ae48	e6 0b		inc $0b				inc 	GXEditSlot 				; next page
.ae4a					_GXAXExit:
.ae4a	60		rts				rts
.ae4b					GXIncrementY:
.ae4b	ee 4d 06	inc $064d			inc 	GXY0
.ae4e	20 c2 b2	jsr $b2c2			jsr 	GXMovePositionDown
.ae51	60		rts				rts
.ae52					GXLineSetup:
.ae52	ad 51 06	lda $0651			lda 	GXY1
.ae55	38		sec				sec
.ae56	ed 4d 06	sbc $064d			sbc 	GXY0
.ae59	4a		lsr a				lsr 	a
.ae5a	8d e9 06	sta $06e9			sta 	GXDiffY
.ae5d	9c eb 06	stz $06eb			stz 	GXDXNegative 				; clear -ve flag
.ae60	38		sec				sec
.ae61	ad 4f 06	lda $064f			lda 	GXX1
.ae64	ed 4b 06	sbc $064b			sbc 	GXX0
.ae67	8d e8 06	sta $06e8			sta 	GXDiffX
.ae6a	ad 50 06	lda $0650			lda 	GXX1+1 						; calculate MSB
.ae6d	ed 4c 06	sbc $064c			sbc 	GXX0+1
.ae70	6a		ror a				ror 	a 							; rotate bit into DiffX halving it
.ae71	6e e8 06	ror $06e8			ror 	GXDiffX
.ae74	0a		asl a				asl 	a
.ae75	10 0c		bpl $ae83			bpl 	_GDXNotNegative
.ae77	a9 00		lda #$00			lda 	#0 							; make absolute value of |dx|
.ae79	38		sec				sec
.ae7a	ed e8 06	sbc $06e8			sbc 	GXDiffX
.ae7d	8d e8 06	sta $06e8			sta 	GXDiffX
.ae80	ce eb 06	dec $06eb			dec 	GXDXNegative 				; -ve flag = $FF.
.ae83					_GDXNotNegative:
.ae83	9c ea 06	stz $06ea			stz 	GXIsDiffYLarger 			; clear larger flag
.ae86	ad e9 06	lda $06e9			lda 	GXDiffY 					; set adjust and total.
.ae89	8d ed 06	sta $06ed			sta 	GXAdjust
.ae8c	ad e8 06	lda $06e8			lda 	GXDiffX
.ae8f	8d ee 06	sta $06ee			sta 	GXTotal
.ae92	ad e9 06	lda $06e9			lda 	GXDiffY 					; if dy > dx
.ae95	cd e8 06	cmp $06e8			cmp 	GXDiffX
.ae98	90 0f		bcc $aea9			bcc 	_GDXNotLarger
.ae9a	ce ea 06	dec $06ea			dec 	GXIsDiffYLarger 			; set the dy larger flag
.ae9d	ad e8 06	lda $06e8			lda 	GXDiffX 					; set adjust and total other way round
.aea0	8d ed 06	sta $06ed			sta 	GXAdjust
.aea3	ad e9 06	lda $06e9			lda 	GXDiffY
.aea6	8d ee 06	sta $06ee			sta 	GXTotal
.aea9					_GDXNotLarger:
.aea9	ad ee 06	lda $06ee			lda 	GXTotal
.aeac	4a		lsr a				lsr 	a
.aead	8d ec 06	sta $06ec			sta 	GXPosition
.aeb0	60		rts				rts
.06e8					GXDiffX:
>06e8							.fill 	1
.06e9					GXDiffY:
>06e9							.fill 	1
.06ea					GXIsDiffYLarger:
>06ea							.fill 	1
.06eb					GXDXNegative:
>06eb							.fill 	1
.06ec					GXPosition:
>06ec							.fill 	1
.06ed					GXAdjust:
>06ed							.fill 	1
.06ee					GXTotal:
>06ee							.fill 	1
.06ef					GXAddSelect:
>06ef							.fill 	1
.aeb1					GXSetColourMode:
.aeb1	a6 36		ldx $36				ldx 	gxzTemp0
.aeb3	8e 59 06	stx $0659			stx 	gxColour 								; set colour
.aeb6	a5 37		lda $37				lda 	gxzTemp0+1 								;
.aeb8	8d 58 06	sta $0658			sta 	gxMode 									; set mode
.aebb	29 03		and #$03			and 	#3 										; only interested in bits 0-3
.aebd	9c 5b 06	stz $065b			stz 	gxANDValue 								; initially AND with 0, and EOR with Colour
.aec0	ae 59 06	ldx $0659			ldx 	gxColour
.aec3	8e 5a 06	stx $065a			stx 	gxEORValue
.aec6	c9 02		cmp #$02			cmp 	#2 										; if mode 2/3 And with colour
.aec8	90 03		bcc $aecd			bcc 	_GXSDCNotAndColour
.aeca	8e 5b 06	stx $065b			stx 	gxANDValue
.aecd					_GXSDCNotAndColour:
.aecd	d0 03		bne $aed2			bne 	_GXSDCNotAnd 							; mode 2, Don't EOR with colour
.aecf	9c 5a 06	stz $065a			stz 	gxEORValue
.aed2					_GXSDCNotAnd:
.aed2	4a		lsr a				lsr 	a 										; if bit 0 set, 1's complement AND value
.aed3	90 08		bcc $aedd			bcc 	_GXSDCNoFlip
.aed5	ad 5b 06	lda $065b			lda	 	gxANDValue
.aed8	49 ff		eor #$ff			eor 	#$FF
.aeda	8d 5b 06	sta $065b			sta 	gxANDValue
.aedd					_GXSDCNoFlip:
.aedd	18		clc				clc
.aede	60		rts				rts
.aedf					GXPlotPoint:
.aedf	20 5c b2	jsr $b25c			jsr 	GXOpenBitmap 				; start drawing
.aee2	20 6c b2	jsr $b26c			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.aee5	ac 5d 06	ldy $065d			ldy 	gsOffset
.aee8	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.aeea	2d 5b 06	and $065b			and 	gxANDValue
.aeed	4d 5a 06	eor $065a			eor 	gxEORValue
.aef0	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.aef2	20 64 b2	jsr $b264			jsr 	GXCloseBitmap 				; stop drawing and exit
.aef5	18		clc				clc
.aef6	60		rts				rts
.aef7					GXFillRectangle:
.aef7	38		sec				sec
.aef8	80 01		bra $aefb			bra 	GXRectangle
.aefa					GXFrameRectangle:
.aefa	18		clc				clc
.aefb					GXRectangle:
.aefb	ad 54 06	lda $0654			lda 	gxBitmapsOn
.aefe	f0 35		beq $af35			beq 	_GXRFail
.af00	08		php				php 								; save Fill flag (CS)
.af01	20 5c b2	jsr $b25c			jsr 	GXOpenBitmap 				; start drawing
.af04	20 84 b3	jsr $b384			jsr 	GXSortXY 					; sort both X and Y so top left/bottom right
.af07	20 6c b2	jsr $b26c			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.af0a	38		sec				sec 								; sec = Draw line
.af0b	20 37 af	jsr $af37			jsr 	GXDrawLineX1X0 				; draw a line length X1-X0
.af0e	ad 4d 06	lda $064d			lda 	gxY0 						; reached end of rectangle ?
.af11	cd 51 06	cmp $0651			cmp 	gxY1
.af14	f0 19		beq $af2f			beq 	_GXRectangleExit
.af16					_GXRectLoop:
.af16	20 c2 b2	jsr $b2c2			jsr 	GXMovePositionDown 			; down one.
.af19	ee 4d 06	inc $064d			inc 	gxY0 						; change Y pos
.af1c	ad 4d 06	lda $064d			lda 	gxY0 						; reached last line
.af1f	cd 51 06	cmp $0651			cmp 	gXY1
.af22	f0 07		beq $af2b			beq 	_GXLastLine
.af24	28		plp				plp 								; get flag back
.af25	08		php				php
.af26	20 37 af	jsr $af37			jsr 	GXDrawLineX1X0 				; draw horizontal line
.af29	80 eb		bra $af16			bra 	_GXRectLoop
.af2b					_GXLastLine:
.af2b	38		sec				sec
.af2c	20 37 af	jsr $af37			jsr 	GXDrawLineX1X0
.af2f					_GXRectangleExit:
.af2f	68		pla				pla 								; throw fill flag.
.af30	20 64 b2	jsr $b264			jsr 	GXCloseBitmap 				; stop drawing and exit
.af33	18		clc				clc
.af34	60		rts				rts
.af35					_GXRFail:
.af35	38		sec				sec
.af36	60		rts				rts
.af37					GXDrawLineX1X0:
.af37	08		php				php 								; save solid/either-end
.af38	38		sec				sec
.af39	ad 4f 06	lda $064f			lda		gXX1
.af3c	ed 4b 06	sbc $064b			sbc 	gXX0
.af3f	85 36		sta $36				sta 	gxzTemp0
.af41	ad 50 06	lda $0650			lda 	gXX1+1
.af44	ed 4c 06	sbc $064c			sbc 	gXX0+1
.af47	85 37		sta $37				sta 	gxzTemp0+1
.af49	28		plp				plp
.af4a					GXDrawLineTemp0:
.af4a	a5 3c		lda $3c				lda 	gxzScreen 						; push gxzScreen, gsOffset and GXEditSlot on stack
.af4c	48		pha				pha
.af4d	a5 3d		lda $3d				lda 	gxzScreen+1
.af4f	48		pha				pha
.af50	ad 5d 06	lda $065d			lda 	gsOffset
.af53	48		pha				pha
.af54	a5 0b		lda $0b				lda 	GXEditSlot
.af56	48		pha				pha
.af57	ac 5d 06	ldy $065d			ldy 	gsOffset 					; Y offset
.af5a	90 1e		bcc $af7a			bcc 	_GXDLTEndPoints 			; if CC draw end points only.
.af5c					_GXDLTLine:
.af5c	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.af5e	2d 5b 06	and $065b			and 	gxANDValue
.af61	4d 5a 06	eor $065a			eor 	gxEORValue
.af64	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.af66	a5 36		lda $36				lda 	gxzTemp0 					; decrement counter
.af68	d0 04		bne $af6e			bne 	_GXDLTNoBorrow
.af6a	c6 37		dec $37				dec 	gxzTemp0+1 					; borrow, if goes -ve then exit
.af6c	30 2e		bmi $af9c			bmi 	_GXDLTExit
.af6e					_GXDLTNoBorrow:
.af6e	c6 36		dec $36				dec 	gxzTemp0
.af70	c8		iny				iny 								; next slot.
.af71	d0 e9		bne $af5c			bne 	_GXDLTLine
.af73	e6 3d		inc $3d				inc 	gxzScreen+1 					; carry to next
.af75	20 aa af	jsr $afaa			jsr 	GXDLTCheckWrap				; check for new page.
.af78	80 e2		bra $af5c			bra 	_GXDLTLine
.af7a					_GXDLTEndPoints:
.af7a	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.af7c	2d 5b 06	and $065b			and 	gxANDValue
.af7f	4d 5a 06	eor $065a			eor 	gxEORValue
.af82	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.af84	98		tya				tya 								; advance to right side
.af85	18		clc				clc
.af86	65 36		adc $36				adc 	gxzTemp0
.af88	a8		tay				tay
.af89	a5 3d		lda $3d				lda 	gxzScreen+1
.af8b	65 37		adc $37				adc 	gxzTemp0+1
.af8d	85 3d		sta $3d				sta 	gxzScreen+1
.af8f	20 aa af	jsr $afaa			jsr 	GXDLTCheckWrap 			; fix up.
.af92	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.af94	2d 5b 06	and $065b			and 	gxANDValue
.af97	4d 5a 06	eor $065a			eor 	gxEORValue
.af9a	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.af9c					_GXDLTExit:
.af9c	68		pla				pla
.af9d	85 0b		sta $0b				sta 	GXEditSlot
.af9f	68		pla				pla
.afa0	8d 5d 06	sta $065d			sta 	gsOffset
.afa3	68		pla				pla
.afa4	85 3d		sta $3d				sta 	gxzScreen+1
.afa6	68		pla				pla
.afa7	85 3c		sta $3c				sta 	gxzScreen
.afa9	60		rts				rts
.afaa					GXDLTCheckWrap:
.afaa	a5 3d		lda $3d				lda 	gxzScreen+1 					; check end of page
.afac	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8)
.afae	90 06		bcc $afb6			bcc 	_GXDLTCWExit
.afb0	e9 20		sbc #$20			sbc 	#$20 						; fix up
.afb2	85 3d		sta $3d				sta 	gxzScreen+1
.afb4	e6 0b		inc $0b				inc 	GXEditSlot
.afb6					_GXDLTCWExit:
.afb6	60		rts				rts
.afb7					GXDrawGraphicElement:
.afb7	8d f0 06	sta $06f0			sta 	gxSize 						; save size
.afba	3a		dec a				dec 	a
.afbb	8d f1 06	sta $06f1			sta 	gxMask 						; and mask
.afbe	ad 54 06	lda $0654			lda 	gxBitmapsOn 				; check BMP on
.afc1	f0 67		beq $b02a			beq 	_GXSLFail
.afc3	ad 4d 06	lda $064d			lda 	gxY0 						; push Y on stack
.afc6	48		pha				pha
.afc7	8c f3 06	sty $06f3			sty 	gxAcquireVector+1 			; and acquisition vector
.afca	8e f2 06	stx $06f2			stx 	gxAcquireVector
.afcd	20 5c b2	jsr $b25c			jsr 	gxOpenBitmap 				; open the bitmap.
.afd0	ad f5 06	lda $06f5			lda 	gxUseMode 					; scale bits
.afd3	4a		lsr a				lsr 	a
.afd4	4a		lsr a				lsr 	a
.afd5	4a		lsr a				lsr 	a
.afd6	29 07		and #$07			and		#7
.afd8	1a		inc a				inc 	a
.afd9	8d f4 06	sta $06f4			sta 	gxScale
.afdc	64 38		stz $38				stz 	gxzTemp1					; start first line
.afde					_GXGELoop:
.afde	a5 38		lda $38				lda 	gxzTemp1 					; current line number to read.
.afe0	2c f5 06	bit $06f5			bit 	gxUseMode 					; check for flip.
.afe3	10 06		bpl $afeb			bpl		_GXNoVFlip
.afe5	ad f1 06	lda $06f1			lda 	gxMask
.afe8	38		sec				sec
.afe9	e5 38		sbc $38				sbc 	gxzTemp1
.afeb					_GXNoVFlip:
.afeb	aa		tax				tax 								; get the Xth line.
.afec	20 2c b0	jsr $b02c			jsr 	_GXCallAcquire 				; get that data.
.afef	ad f4 06	lda $06f4			lda 	gxScale 					; do scale identical copies of that line.
.aff2	85 39		sta $39				sta 	gxzTemp1+1
.aff4					_GXGELoop2:
.aff4	ad 4d 06	lda $064d			lda 	gxY0 						; off screen
.aff7	cd 57 06	cmp $0657			cmp 	gxHeight
.affa	b0 10		bcs $b00c			bcs 	_GXDGEExit
.affc	20 2f b0	jsr $b02f			jsr 	GXRenderOneLine 			; render line
.afff	c6 39		dec $39				dec 	gxzTemp1+1 					; scale times.
.b001	d0 f1		bne $aff4			bne 	_GXGELoop2
.b003	e6 38		inc $38				inc 	gxzTemp1 					; done all lines.
.b005	a5 38		lda $38				lda 	gxzTemp1
.b007	cd f0 06	cmp $06f0			cmp 	gxSize
.b00a	d0 d2		bne $afde			bne 	_GXGELoop
.b00c					_GXDGEExit:
.b00c	68		pla				pla 								; restore Y for next time
.b00d	8d 4d 06	sta $064d			sta 	gxY0
.b010	ae f4 06	ldx $06f4			ldx 	gxScale 					; get scale (1-8)
.b013					_GXShiftLeft:
.b013	18		clc				clc
.b014	ad f0 06	lda $06f0			lda 	gxSize
.b017	6d 4b 06	adc $064b			adc 	gxX0
.b01a	8d 4b 06	sta $064b			sta 	gxX0
.b01d	90 03		bcc $b022			bcc 	_GXSLNoCarry
.b01f	ee 4c 06	inc $064c			inc 	gxX0+1
.b022					_GXSLNoCarry:
.b022	ca		dex				dex
.b023	d0 ee		bne $b013			bne 	_GXShiftLeft
.b025	20 64 b2	jsr $b264			jsr 	GXCloseBitmap
.b028	18		clc				clc
.b029	60		rts				rts
.b02a					_GXSLFail:
.b02a	38		sec				sec
.b02b	60		rts				rts
.b02c					_GXCallAcquire:
.b02c	6c f2 06	jmp ($06f2)			jmp 	(gxAcquireVector)
.b02f					GXRenderOneLine:
.b02f	20 6c b2	jsr $b26c			jsr 	GXPositionCalc 				; calculate position/offset.
.b032	ac 5d 06	ldy $065d			ldy 	gsOffset 					; Y contains position.
.b035	64 3a		stz $3a				stz 	gxzTemp2 					; do size pixels
.b037					_GXROLLoop1:
.b037	ad f4 06	lda $06f4			lda 	gxScale 					; set to do 'scale' times
.b03a	85 3b		sta $3b				sta 	gxzTemp2+1
.b03c					_GXROLLoop2:
.b03c	a5 3a		lda $3a				lda 	gxzTemp2 					; get current pixel
.b03e	2c 58 06	bit $0658			bit 	gxMode 						; check H Flip
.b041	50 06		bvc $b049			bvc 	_GXNoHFlip
.b043	ad f1 06	lda $06f1			lda 	gxMask
.b046	38		sec				sec
.b047	e5 3a		sbc $3a				sbc 	gxzTemp2
.b049					_GXNoHFlip:
.b049	aa		tax				tax 								; read from the pixel buffer
.b04a	bd f9 05	lda $05f9,x			lda 	gxPixelBuffer,x
.b04d	d0 07		bne $b056			bne 	_GXDraw 					; draw if non zero
.b04f	ad f5 06	lda $06f5			lda 	gxUseMode 					; check to see if solid background
.b052	29 04		and #$04			and 	#4
.b054	f0 0a		beq $b060			beq 	_GXZeroPixel
.b056					_GXDraw:
.b056	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.b058	2d 5b 06	and $065b			and 	gxANDValue
.b05b	5d f9 05	eor $05f9,x			eor 	gxPixelBuffer,x
.b05e	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b060					_GXZeroPixel:
.b060	c8		iny				iny 								; advance pointer
.b061	d0 05		bne $b068			bne 	_GXNoShift
.b063	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.b065	20 aa af	jsr $afaa			jsr 	GXDLTCheckWrap				; check for new page.
.b068					_GXNoShift:
.b068	c6 3b		dec $3b				dec 	gxzTemp2+1 					; do the inner loop gxScale times.
.b06a	d0 d0		bne $b03c			bne 	_GXROLLoop2
.b06c	e6 3a		inc $3a				inc 	gxzTemp2 					; next pixel.
.b06e	a5 3a		lda $3a				lda 	gxzTemp2
.b070	cd f0 06	cmp $06f0			cmp 	gxSize
.b073	d0 c2		bne $b037			bne 	_GXROLLoop1
.b075	ee 4d 06	inc $064d			inc 	gxY0
.b078	60		rts				rts
.06f0					gxSize:
>06f0							.fill 	1
.06f1					gxMask:
>06f1							.fill 	1
.06f2					gxAcquireVector:
>06f2							.fill 	2
.06f4					gxScale:
>06f4							.fill 	1
.06f5					gxUseMode:
>06f5							.fill 	1
.b079					GXFontHandler:
.b079	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b07b	4d 58 06	eor $0658			eor 	gxMode
.b07e	8d f5 06	sta $06f5			sta 	gxUseMode
.b081	64 37		stz $37				stz 	gxzTemp0+1 					; gxzTemp0 is font #
.b083	06 36		asl $36				asl	 	gxzTemp0 					; x 2
.b085	26 37		rol $37				rol	 	gxzTemp0+1
.b087	06 36		asl $36				asl	 	gxzTemp0 					; x 4
.b089	26 37		rol $37				rol	 	gxzTemp0+1
.b08b	06 36		asl $36				asl	 	gxzTemp0 					; x 8
.b08d	26 37		rol $37				rol	 	gxzTemp0+1
.b08f	a5 37		lda $37				lda 	gxzTemp0+1 					; put in page C0
.b091	09 c0		ora #$c0			ora 	#$C0
.b093	85 37		sta $37				sta 	gxzTemp0+1
.b095	a9 08		lda #$08			lda 	#8 							; size 8x8
.b097	a2 9f		ldx #$9f			ldx 	#GXGetGraphicDataFont & $FF ; XY = Graphic Data retrieval routine
.b099	a0 b0		ldy #$b0			ldy 	#GXGetGraphicDataFont >> 8
.b09b	20 b7 af	jsr $afb7			jsr 	GXDrawGraphicElement
.b09e	60		rts				rts
.b09f					GXGetGraphicDataFont:
.b09f	8a		txa				txa 								; X->Y
.b0a0	a8		tay				tay
.b0a1	a6 01		ldx $01				ldx 	1 							; preserve old value
.b0a3	a9 01		lda #$01			lda 	#1 							; access page 1 (font memory)
.b0a5	85 01		sta $01				sta 	1
.b0a7	b1 36		lda ($36),y			lda 	(gxzTemp0),y 				; read the font element.
.b0a9	86 01		stx $01				stx 	1 							; put old value back.
.b0ab	a2 00		ldx #$00			ldx 	#0 							; do 8 times
.b0ad					_GXExpand:
.b0ad	9e f9 05	stz $05f9,x			stz 	gxPixelBuffer,x 			; zero in pixel buffer
.b0b0	0a		asl a				asl 	a 							; shift bit 7 into C
.b0b1	90 08		bcc $b0bb			bcc 	_GXNoPixel
.b0b3	48		pha				pha 								; if set, set pixel buffer to current colour.
.b0b4	ad 59 06	lda $0659			lda 	gxColour
.b0b7	9d f9 05	sta $05f9,x			sta 	gxPixelBuffer,x
.b0ba	68		pla				pla
.b0bb					_GXNoPixel:
.b0bb	e8		inx				inx 								; do the whole byte.
.b0bc	e0 08		cpx #$08			cpx 	#8
.b0be	d0 ed		bne $b0ad			bne 	_GXExpand
.b0c0	60		rts				rts
.b0c1					GXSpriteHandler:
.b0c1	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b0c3	4d 58 06	eor $0658			eor 	gxMode
.b0c6	8d f5 06	sta $06f5			sta 	gxUseMode
.b0c9	a6 36		ldx $36				ldx 	gxzTemp0 					; sprite #
.b0cb	da		phx				phx
.b0cc	20 5c b2	jsr $b25c			jsr 	GXOpenBitmap 				; can access sprite information
.b0cf	68		pla				pla
.b0d0	20 3d b3	jsr $b33d			jsr 	GXFindSprite 				; get the sprite address
.b0d3	08		php				php
.b0d4	20 64 b2	jsr $b264			jsr 	GXCloseBitmap
.b0d7	28		plp				plp
.b0d8	b0 0a		bcs $b0e4			bcs		_GXSHExit 					; exit if find failed.
.b0da	ad f6 06	lda $06f6			lda 	GXSizePixels 				; return size
.b0dd	a2 e5		ldx #$e5			ldx 	#GXSpriteAcquire & $FF
.b0df	a0 b0		ldy #$b0			ldy 	#GXSpriteAcquire >> 8
.b0e1	20 b7 af	jsr $afb7			jsr 	GXDrawGraphicElement
.b0e4					_GXSHExit:
.b0e4	60		rts				rts
.b0e5					GXSpriteAcquire:
.b0e5	ad 56 06	lda $0656			lda 	GXSpritePage				; point to base page
.b0e8	85 0b		sta $0b				sta 	GXEditSlot
.b0ea	86 36		stx $36				stx 	zTemp0 						; row number x 1,2,3,4
.b0ec	a9 00		lda #$00			lda 	#0
.b0ee	ae f7 06	ldx $06f7			ldx 	GXSizeBits
.b0f1					_GXTimesRowNumber:
.b0f1	18		clc				clc
.b0f2	65 36		adc $36				adc 	zTemp0
.b0f4	ca		dex				dex
.b0f5	10 fa		bpl $b0f1			bpl 	_GXTimesRowNumber
.b0f7	64 37		stz $37				stz 	gxzTemp0+1
.b0f9	0a		asl a				asl 	a 							; row x 2,4,6,8
.b0fa	26 37		rol $37				rol 	gxzTemp0+1
.b0fc	0a		asl a				asl 	a 							; row x 4,8,12,16
.b0fd	26 37		rol $37				rol 	gxzTemp0+1
.b0ff	0a		asl a				asl 	a 							; row x 8,16,24,32
.b100	26 37		rol $37				rol 	gxzTemp0+1
.b102	85 36		sta $36				sta 	gxzTemp0
.b104	18		clc				clc 								; add base address.
.b105	a5 36		lda $36				lda 	gxzTemp0
.b107	6d f9 06	adc $06f9			adc 	GXSpriteOffset
.b10a	85 36		sta $36				sta 	gxzTemp0
.b10c	a5 37		lda $37				lda 	gxzTemp0+1
.b10e	6d fa 06	adc $06fa			adc 	GXSpriteOffset+1
.b111					_GXSAFindPage:
.b111	c9 20		cmp #$20			cmp 	#$20 						; on this page
.b113	90 06		bcc $b11b			bcc 	_GXSAFoundPage
.b115	e9 20		sbc #$20			sbc 	#$20 						; forward one page
.b117	e6 0b		inc $0b				inc 	GXEditSlot
.b119	80 f6		bra $b111			bra 	_GXSAFindPage
.b11b					_GXSAFoundPage:
.b11b	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; physical address of page.
.b11d	85 37		sta $37				sta 	gxzTemp0+1 					; gxzTemp0 now points to the page
.b11f	a0 00		ldy #$00			ldy 	#0
.b121					_GXSACopyLoop:
.b121	b1 36		lda ($36),y			lda 	(gxzTemp0),y
.b123	99 f9 05	sta $05f9,y			sta 	gxPixelBuffer,y
.b126	c8		iny				iny
.b127	cc f6 06	cpy $06f6			cpy 	GXSizePixels
.b12a	d0 f5		bne $b121			bne 	_GXSACopyLoop
.b12c	60		rts				rts
.b12d					GXSelect:
.b12d	ad 53 06	lda $0653			lda 	gxSpritesOn
.b130	f0 22		beq $b154			beq 	_GXSFail
.b132	a5 36		lda $36				lda 	gxzTemp0 					; illegal sprite #
.b134	c9 40		cmp #$40			cmp 	#64
.b136	b0 1c		bcs $b154			bcs 	_GXSFail
.b138	8d 5e 06	sta $065e			sta 	GSCurrentSpriteID
.b13b	a4 37		ldy $37				ldy 	gxzTemp0+1 					; control value.
.b13d	a9 00		lda #$00			lda  	#0 							; multiply sprite # x 8 => A
.b13f	06 36		asl $36				asl 	gxzTemp0
.b141	06 36		asl $36				asl 	gxzTemp0
.b143	06 36		asl $36				asl 	gxzTemp0
.b145	2a		rol a				rol 	a
.b146	69 d9		adc #$d9			adc 	#$D9 						; sprite area
.b148	8d 60 06	sta $0660			sta 	GSCurrentSpriteAddr+1 		; address to GSCurrentSprite and gxzTemp
.b14b	85 37		sta $37				sta 	gxzTemp0+1
.b14d	a5 36		lda $36				lda 	gxzTemp0
.b14f	8d 5f 06	sta $065f			sta 	GSCurrentSpriteAddr
.b152	18		clc				clc
.b153	60		rts				rts
.b154					_GXSFail:
.b154	38		sec				sec
.b155	60		rts				rts
.b156					GXSelectImage:
.b156	ad 53 06	lda $0653			lda 	gxSpritesOn
.b159	f0 74		beq $b1cf			beq 	_GXSIFail
.b15b	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b15e	f0 6f		beq $b1cf			beq 	_GXSIFail 					; (checking the MSB)
.b160	64 01		stz $01				stz 	1
.b162	a5 37		lda $37				lda 	gxzTemp0+1 					; push show/hide on the stack.
.b164	d0 6b		bne $b1d1			bne 	_GXSIHide
.b166	a5 36		lda $36				lda 	gxzTemp0 					; sprite image
.b168	48		pha				pha
.b169	20 5c b2	jsr $b25c			jsr 	GXOpenBitmap
.b16c	68		pla				pla
.b16d	20 3d b3	jsr $b33d			jsr 	GXFindSprite
.b170	b0 5a		bcs $b1cc			bcs 	_GXSICloseFail 				; no image
.b172	a0 01		ldy #$01			ldy 	#1
.b174	ad 5f 06	lda $065f			lda 	GSCurrentSpriteAddr
.b177	85 36		sta $36				sta 	gxzTemp0
.b179	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr+1
.b17c	85 37		sta $37				sta 	gxzTemp0+1
.b17e	ad f9 06	lda $06f9			lda 	GXSpriteOffset
.b181	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b183	18		clc				clc
.b184	ad fa 06	lda $06fa			lda 	GXSpriteOffset+1
.b187	6d 61 06	adc $0661			adc 	GXSpriteOffsetBase
.b18a	c8		iny				iny
.b18b	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b18d	ad 62 06	lda $0662			lda 	GXSpriteOffsetBase+1
.b190	69 00		adc #$00			adc 	#0
.b192	c8		iny				iny
.b193	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b195	ad f7 06	lda $06f7			lda 	GXSizeBits 					; get raw size
.b198	49 03		eor #$03			eor 	#3 							; make it right (00=32 etc.)
.b19a	2a		rol a				rol 	a 							; x 2
.b19b	0a		asl a				asl 	a 							; x 4
.b19c	0a		asl a				asl 	a 							; x 8
.b19d	0a		asl a				asl 	a 							; x 16
.b19e	0d f8 06	ora $06f8			ora 	GXSpriteLUT 				; Or with LUT
.b1a1	0a		asl a				asl 	a 							; 1 shift
.b1a2	09 01		ora #$01			ora 	#1 							; enable sprite.
.b1a4	92 36		sta ($36)			sta 	(gxzTemp0) 					; and write back
.b1a6	20 64 b2	jsr $b264			jsr 	GXCloseBitmap
.b1a9	ae 5e 06	ldx $065e			ldx 	GSCurrentSpriteID 			; point to sprite entries.
.b1ac	bd a3 06	lda $06a3,x			lda 	GXSpriteHigh,x 				; clear upper two bits of size
.b1af	29 3f		and #$3f			and 	#$3F
.b1b1	9d a3 06	sta $06a3,x			sta 	GXSpriteHigh,x
.b1b4	ad f7 06	lda $06f7			lda 	GXSizeBits 					; get bit size
.b1b7	6a		ror a				ror 	a 							; shift into bits 6/7
.b1b8	6a		ror a				ror 	a
.b1b9	6a		ror a				ror 	a
.b1ba	29 c0		and #$c0			and 	#$C0
.b1bc	1d a3 06	ora $06a3,x			ora 	GXSpriteHigh,x 				; put in  upper 2 bits of sprite data
.b1bf	9d a3 06	sta $06a3,x			sta 	GXSpriteHigh,x
.b1c2	bd 63 06	lda $0663,x			lda 	GXSpriteLow,x 				; clear hidden flag.
.b1c5	29 7f		and #$7f			and 	#$7F
.b1c7	9d 63 06	sta $0663,x			sta 	GXSpriteLow,x
.b1ca	18		clc				clc
.b1cb	60		rts				rts
.b1cc					_GXSICloseFail:
.b1cc	20 64 b2	jsr $b264			jsr 	GXCloseBitmap
.b1cf					_GXSIFail:
.b1cf	38		sec				sec
.b1d0	60		rts				rts
.b1d1					_GXSIHide:
.b1d1	ad 5f 06	lda $065f			lda 	GSCurrentSpriteAddr  		; get Sprite h/w address and write there
.b1d4	85 36		sta $36				sta 	gxzTemp0
.b1d6	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr+1
.b1d9	85 37		sta $37				sta 	gxzTemp0+1
.b1db	a9 00		lda #$00			lda 	#0
.b1dd	92 36		sta ($36)			sta 	(gxzTemp0)
.b1df	ae 5e 06	ldx $065e			ldx 	GSCurrentSpriteID 			; get sprite ID
.b1e2	bd 63 06	lda $0663,x			lda 	GXSpriteLow,x 				; set the hidden bit.
.b1e5	09 80		ora #$80			ora 	#$80
.b1e7	9d 63 06	sta $0663,x			sta 	GXSpriteLow,x
.b1ea	18		clc				clc
.b1eb	60		rts				rts
.b1ec					GXMoveSprite:
.b1ec	ad 53 06	lda $0653			lda 	gxSpritesOn
.b1ef	f0 65		beq $b256			beq 	_GXSIFail
.b1f1	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b1f4	f0 60		beq $b256			beq 	_GXSIFail
.b1f6	85 37		sta $37				sta 	gxzTemp0+1
.b1f8	a0 04		ldy #$04			ldy 	#4
.b1fa	ad 5f 06	lda $065f			lda 	GSCurrentSpriteAddr
.b1fd	85 36		sta $36				sta 	gxzTemp0
.b1ff	ae 5e 06	ldx $065e			ldx 	GSCurrentSpriteID 			; get the size from the upper two bits
.b202	bd a3 06	lda $06a3,x			lda 	GXSpriteHigh,x
.b205	2a		rol a				rol 	a	 						; into bits 0,1.
.b206	2a		rol a				rol 	a
.b207	2a		rol a				rol 	a
.b208	29 03		and #$03			and 	#3
.b20a	aa		tax				tax
.b20b	bd 58 b2	lda $b258,x			lda 	_GXMSOffset,x 				; get 32-SpriteSize/2
.b20e	48		pha				pha
.b20f	18		clc				clc
.b210	6d 4b 06	adc $064b			adc 	gxX0						; copy position.
.b213	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b215	c8		iny				iny
.b216	ad 4c 06	lda $064c			lda 	gxX0+1
.b219	69 00		adc #$00			adc 	#0
.b21b	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b21d	c8		iny				iny
.b21e	68		pla				pla
.b21f	18		clc				clc
.b220	6d 4d 06	adc $064d			adc 	gxY0
.b223	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b225	a9 00		lda #$00			lda 	#0
.b227	69 00		adc #$00			adc 	#0
.b229	c8		iny				iny
.b22a	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b22c	4e 4c 06	lsr $064c			lsr 	gxX0+1 						; divide X by 4
.b22f	6e 4b 06	ror $064b			ror 	gxX0
.b232	4e 4b 06	lsr $064b			lsr 	gxX0
.b235	4e 4d 06	lsr $064d			lsr 	gxY0 						; divide Y by 4
.b238	4e 4d 06	lsr $064d			lsr 	gxY0
.b23b	ae 5e 06	ldx $065e			ldx 	GSCurrentSpriteID 			; copy X/4 and Y/4 into the status bytes
.b23e	bd 63 06	lda $0663,x			lda 	GXSpriteLow,x
.b241	29 80		and #$80			and 	#$80
.b243	0d 4b 06	ora $064b			ora 	gxX0
.b246	9d 63 06	sta $0663,x			sta 	GXSpriteLow,x
.b249	bd a3 06	lda $06a3,x			lda 	GXSpriteHigh,x
.b24c	29 c0		and #$c0			and 	#$C0
.b24e	0d 4d 06	ora $064d			ora 	gxY0
.b251	9d a3 06	sta $06a3,x			sta 	GXSpriteHigh,x
.b254	18		clc				clc
.b255	60		rts				rts
.b256					_GXSIFail:
.b256	38		sec				sec
.b257	60		rts				rts
.b258					_GXMSOffset:
>b258	1c						.byte 	32-8/2
>b259	18						.byte 	32-16/2
>b25a	14						.byte 	32-24/2
>b25b	10						.byte 	32-32/2
.b25c					GXOpenBitmap:
.b25c	78		sei				sei 								; no interrupts here
.b25d	a5 0b		lda $0b				lda 	GXEditSlot 					; Save the original LUT slot value
.b25f	8d 5c 06	sta $065c			sta 	gxOriginalLUTValue
.b262	58		cli				cli
.b263	60		rts				rts
.b264					GXCloseBitmap:
.b264	78		sei				sei
.b265	ad 5c 06	lda $065c			lda 	gxOriginalLUTValue 			; restore LUT slot value
.b268	85 0b		sta $0b				sta 	GXEditSlot
.b26a	58		cli				cli
.b26b	60		rts				rts
.b26c					GXPositionCalc:
.b26c	a5 36		lda $36				lda 	gxzTemp0 					; save temp memory slot
.b26e	48		pha				pha
.b26f	ad 4d 06	lda $064d			lda 	GXY0 						; gxzScreen = Y0
.b272	85 3c		sta $3c				sta 	gxzScreen
.b274	64 3d		stz $3d				stz 	gxzScreen+1
.b276	06 3c		asl $3c				asl 	gxzScreen 						; gxzScreen = Y0 * 4
.b278	26 3d		rol $3d				rol 	gxzScreen+1
.b27a	06 3c		asl $3c				asl 	gxzScreen
.b27c	26 3d		rol $3d				rol 	gxzScreen+1
.b27e	18		clc				clc 								; gxzScreen = Y0 * 5, as it's still in A
.b27f	65 3c		adc $3c				adc 	gxzScreen
.b281	85 3c		sta $3c				sta 	gxzScreen
.b283	90 02		bcc $b287			bcc 	_GXPCNoCarry
.b285	e6 3d		inc $3d				inc 	gxzScreen+1
.b287					_GXPCNoCarry:
.b287	06 3c		asl $3c				asl 	gxzScreen 						; now Y0 * 10. Needs to be multiplied by another
.b289	26 3d		rol $3d				rol 	gxzScreen+1 					; 32. At this point the MSB contains the offset
.b28b	a5 3d		lda $3d				lda	 	gxzScreen+1 					; so save this in zTemp0 and zero it.
.b28d	85 36		sta $36				sta 	gxzTemp0
.b28f	64 3d		stz $3d				stz 	gxzScreen+1
.b291	a9 05		lda #$05			lda 	#5 							; now multiply by 32, this puts this in the range 0..8191
.b293					_GXPCMultiply32:
.b293	06 3c		asl $3c				asl 	gxzScreen
.b295	26 3d		rol $3d				rol 	gxzScreen+1
.b297	3a		dec a				dec 	a
.b298	d0 f9		bne $b293			bne 	_GXPCMultiply32
.b29a	18		clc				clc
.b29b	ad 4b 06	lda $064b			lda 	GXX0 						; add X to this value, put the result in gsOffset, gxzScreen has to be on a page boundary
.b29e	65 3c		adc $3c				adc 	gxzScreen
.b2a0	8d 5d 06	sta $065d			sta 	gsOffset
.b2a3	ad 4c 06	lda $064c			lda 	GXX0+1
.b2a6	65 3d		adc $3d				adc 	gxzScreen+1
.b2a8	c9 20		cmp #$20			cmp 	#$20 						; has it overflowed into the next one ?
.b2aa	90 04		bcc $b2b0			bcc 	_GXPCNoOverflow
.b2ac	29 1f		and #$1f			and 	#$1F 						; fix it up
.b2ae	e6 36		inc $36				inc 	gxzTemp0 					; add 1 to the page number
.b2b0					_GXPCNoOverflow:
.b2b0	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; make it the address mapped in.
.b2b2	85 3d		sta $3d				sta 	gxzScreen+1
.b2b4	64 3c		stz $3c				stz 	gxzScreen
.b2b6	18		clc				clc
.b2b7	a5 36		lda $36				lda 	gxzTemp0 					; get the page number
.b2b9	6d 55 06	adc $0655			adc 	gxBasePage 					; by adding the base page
.b2bc	85 0b		sta $0b				sta 	GXEditSlot 				; and map it into memory.
.b2be	68		pla				pla
.b2bf	85 36		sta $36				sta 	gxzTemp0
.b2c1	60		rts				rts
.b2c2					GXMovePositionDown:
.b2c2	18		clc				clc 								; add 320 to offset/temp+1
.b2c3	ad 5d 06	lda $065d			lda 	gsOffset
.b2c6	69 40		adc #$40			adc 	#64
.b2c8	8d 5d 06	sta $065d			sta 	gsOffset
.b2cb	a5 3d		lda $3d				lda 	gxzScreen+1
.b2cd	69 01		adc #$01			adc 	#1
.b2cf	85 3d		sta $3d				sta 	gxzScreen+1
.b2d1	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page
.b2d3	90 07		bcc $b2dc			bcc 	_GXMPDExit
.b2d5	38		sec				sec  								; next page
.b2d6	e9 20		sbc #$20			sbc 	#$20
.b2d8	85 3d		sta $3d				sta 	gxzScreen+1
.b2da	e6 0b		inc $0b				inc 	GXEditSlot
.b2dc					_GXMPDExit:
.b2dc	60		rts				rts
.b2dd					GXCollide:
.b2dd	a5 36		lda $36				lda 	gxzTemp0 					; check if sprite numbers are legal.
.b2df	aa		tax				tax
.b2e0	05 37		ora $37				ora 	gxzTemp0+1
.b2e2	29 c0		and #$c0			and 	#$C0
.b2e4	38		sec				sec
.b2e5	d0 53		bne $b33a			bne 	_GXCollideFail 				; if either >= 64, fail.
.b2e7	a4 37		ldy $37				ldy 	gxzTemp0+1 					; at this point X is 1st sprite and Y is 2nd sprite.
.b2e9	b9 63 06	lda $0663,y			lda 	GXSpriteLow,y 				; check if either hidden bit is set
.b2ec	1d 63 06	ora $0663,x			ora 	GXSpriteLow,x
.b2ef	30 48		bmi $b339			bmi 	_GXOkayFail 				; if either hidden, then they cannot collide.
.b2f1	18		clc				clc 								; need to calculate sum of sizes.
.b2f2	b9 a3 06	lda $06a3,y			lda 	GXSpriteHigh,y
.b2f5	7d a3 06	adc $06a3,x			adc 	GXSpriteHigh,x 				; at this point, CS, Bit 6 and 7 contain that sum.
.b2f8	29 c0		and #$c0			and 	#$C0 					 	; mask off
.b2fa	6a		ror a				ror 	a 							; 5/6/7
.b2fb	4a		lsr a				lsr 	a 							; 4/5/6
.b2fc	4a		lsr a				lsr 	a 							; 3/4/5
.b2fd	4a		lsr a				lsr 	a 							; 2/3/4
.b2fe	18		clc				clc
.b2ff	69 08		adc #$08			adc 	#$08
.b301	4a		lsr a				lsr 	a 							; adjust because all coordinates are divided by 4 to store.
.b302	4a		lsr a				lsr 	a
.b303	85 38		sta $38				sta 	gxzTemp1 					; so the difference between the centres has to be less than this.
.b305	b9 a3 06	lda $06a3,y			lda 	GXSpriteHigh,y 				; calculate y1-y0
.b308	29 3f		and #$3f			and 	#$3F
.b30a	85 39		sta $39				sta 	gxzTemp1+1
.b30c	38		sec				sec
.b30d	bd a3 06	lda $06a3,x			lda 	GXSpriteHigh,x
.b310	29 3f		and #$3f			and 	#$3F
.b312	e5 39		sbc $39				sbc 	gxzTemp1+1
.b314	b0 03		bcs $b319			bcs 	_GXCAbs1 					; calculate |y1-y0|
.b316	49 ff		eor #$ff			eor 	#$FF
.b318	1a		inc a				inc 	a
.b319					_GXCAbs1:
.b319	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b31b	b0 1c		bcs $b339			bcs 	_GXOkayFail
.b31d	85 39		sta $39				sta 	gxzTemp1+1 					; save |y1-y0|
.b31f	38		sec				sec 								; calculate |x1-x0|
.b320	b9 63 06	lda $0663,y			lda 	GXSpriteLow,y
.b323	fd 63 06	sbc $0663,x			sbc 	GXSpriteLow,x
.b326	b0 03		bcs $b32b			bcs 	_GXCAbs2
.b328	49 ff		eor #$ff			eor 	#$FF
.b32a	1a		inc a				inc 	a
.b32b					_GXCAbs2:
.b32b	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b32d	b0 0a		bcs $b339			bcs 	_GXOkayFail
.b32f	c5 39		cmp $39				cmp 	gxzTemp1+1 					; is it less than the previous one.
.b331	90 02		bcc $b335			bcc 	_GXCHaveLowest
.b333	a5 39		lda $39				lda 	gxzTemp1+1 					; if not, that's the smallest difference.
.b335					_GXCHaveLowest:
.b335	0a		asl a				asl 	a 							; scale to allow for >> 2
.b336	0a		asl a				asl 	a
.b337	18		clc				clc
.b338	60		rts				rts
.b339					_GXOkayFail:
.b339	18		clc				clc
.b33a					_GXCollideFail:
.b33a	a9 ff		lda #$ff			lda 	#$FF
.b33c	60		rts				rts
.b33d					GXFindSprite:
.b33d	aa		tax				tax
.b33e	ad 56 06	lda $0656			lda 	GXSpritePage 				; access the base page of the sprite
.b341	85 0b		sta $0b				sta 	GXEditSlot
.b343	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; check a valid sprite
.b346	1d 00 60	ora $6000,x			ora 	GXMappingAddress,x
.b349	f0 33		beq $b37e			beq 	_GXFSFail
.b34b	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; MSB
.b34e	8d fa 06	sta $06fa			sta 	GXSpriteOffset+1
.b351	bd 00 60	lda $6000,x			lda 	GXMappingAddress,x 			; LSB
.b354	48		pha				pha 								; save twice
.b355	48		pha				pha
.b356	29 03		and #$03			and 	#3 							; get sprite size
.b358	8d f7 06	sta $06f7			sta 	GXSizeBits 					; save raw (0-3)
.b35b	aa		tax				tax
.b35c	bd 80 b3	lda $b380,x			lda 	_GXFXSSTTable,x 			; read sprite size
.b35f	8d f6 06	sta $06f6			sta 	GXSizePixels 					; save (8/16/24/32)
.b362	68		pla				pla 								; get LUT
.b363	4a		lsr a				lsr		a
.b364	4a		lsr a				lsr		a
.b365	29 03		and #$03			and 	#3
.b367	8d f8 06	sta $06f8			sta 	GXSpriteLUT
.b36a	68		pla				pla 								; address, neeeds to be x 4
.b36b	29 f0		and #$f0			and 	#$F0
.b36d	8d f9 06	sta $06f9			sta 	GXSpriteOffset
.b370	0e f9 06	asl $06f9			asl 	GXSpriteOffset
.b373	2e fa 06	rol $06fa			rol 	GXSpriteOffset+1
.b376	0e f9 06	asl $06f9			asl 	GXSpriteOffset
.b379	2e fa 06	rol $06fa			rol 	GXSpriteOffset+1
.b37c	18		clc				clc
.b37d	60		rts				rts
.b37e					_GXFSFail:
.b37e	38		sec				sec
.b37f	60		rts				rts
.b380					_GXFXSSTTable:
>b380	08 10 18 20					.byte 	8,16,24,32
.06f6					GXSizePixels:
>06f6							.fill 	1
.06f7					GXSizeBits:
>06f7							.fill 	1
.06f8					GXSpriteLUT:
>06f8							.fill 	1
.06f9					GXSpriteOffset:
>06f9							.fill 	2
.b384					GXSortXY:
.b384	20 a2 b3	jsr $b3a2			jsr 	GXSortY 					; will be sorted on Y now
.b387	ad 4b 06	lda $064b			lda 	gxX0 						; compare X0 v X1
.b38a	cd 4f 06	cmp $064f			cmp 	gxX1
.b38d	ad 4c 06	lda $064c			lda 	gXX0+1
.b390	ed 50 06	sbc $0650			sbc 	gXX1+1
.b393	90 0c		bcc $b3a1			bcc 	_GXSXYExit 					; X0 < X1 exit
.b395	a2 00		ldx #$00			ldx 	#0 							; swap them over
.b397	a0 04		ldy #$04			ldy 	#4
.b399	20 b6 b3	jsr $b3b6			jsr 	GXSwapXY
.b39c	e8		inx				inx
.b39d	c8		iny				iny
.b39e	20 b6 b3	jsr $b3b6			jsr 	GXSwapXY
.b3a1					_GXSXYExit:
.b3a1	60		rts				rts
.b3a2					GXSortY:
.b3a2	ad 4d 06	lda $064d			lda 	gxY0 						; if Y0 >= Y1
.b3a5	cd 51 06	cmp $0651			cmp 	gxY1
.b3a8	90 0b		bcc $b3b5			bcc 	_GXSYSorted
.b3aa	a2 03		ldx #$03			ldx 	#3 							; swap 3-0
.b3ac	a0 07		ldy #$07			ldy 	#7 							; with 4-7
.b3ae					_GXSwap1:
.b3ae	20 b6 b3	jsr $b3b6			jsr 	GXSwapXY
.b3b1	88		dey				dey
.b3b2	ca		dex				dex
.b3b3	10 f9		bpl $b3ae			bpl 	_GXSwap1
.b3b5					_GXSYSorted:
.b3b5	60		rts				rts
.b3b6					GXSwapXY:
.b3b6	bd 4b 06	lda $064b,x			lda 	gxX0,x
.b3b9	48		pha				pha
.b3ba	b9 4b 06	lda $064b,y			lda 	gxX0,y
.b3bd	9d 4b 06	sta $064b,x			sta 	gxX0,x
.b3c0	68		pla				pla
.b3c1	99 4b 06	sta $064b,y			sta 	gxX0,y
.b3c4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_tokeniser.module

=1					tokeniserIntegrated=1
.ba35					KeywordSet0:
>ba35	00 65					.text	0,$65,""               ; $80 !0:EOF
>ba37	00 58					.text	0,$58,""               ; $81 !1:SH1
>ba39	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>ba3b	04 fe 41 42 53 28			.text	4,$fe,"ABS("           ; $83 ABS(
>ba41	06 93 41 4c 4c 4f 43 28			.text	6,$93,"ALLOC("         ; $84 ALLOC(
>ba49	04 ff 41 53 43 28			.text	4,$ff,"ASC("           ; $85 ASC(
>ba4f	05 29 43 48 52 24 28			.text	5,$29,"CHR$("          ; $86 CHR$(
>ba56	06 aa 45 56 45 4e 54 28			.text	6,$aa,"EVENT("         ; $87 EVENT(
>ba5e	05 6b 46 41 4c 53 45			.text	5,$6b,"FALSE"          ; $88 FALSE
>ba65	05 44 46 52 41 43 28			.text	5,$44,"FRAC("          ; $89 FRAC(
>ba6c	04 0d 48 49 54 28			.text	4,$0d,"HIT("           ; $8a HIT(
>ba72	04 13 49 4e 54 28			.text	4,$13,"INT("           ; $8b INT(
>ba78	06 a7 49 53 56 41 4c 28			.text	6,$a7,"ISVAL("         ; $8c ISVAL(
>ba80	05 5c 4a 4f 59 42 28			.text	5,$5c,"JOYB("          ; $8d JOYB(
>ba87	05 72 4a 4f 59 58 28			.text	5,$72,"JOYX("          ; $8e JOYX(
>ba8e	05 73 4a 4f 59 59 28			.text	5,$73,"JOYY("          ; $8f JOYY(
>ba95	06 77 4c 45 46 54 24 28			.text	6,$77,"LEFT$("         ; $90 LEFT$(
>ba9d	04 07 4c 45 4e 28			.text	4,$07,"LEN("           ; $91 LEN(
>baa3	04 0e 4d 41 58 28			.text	4,$0e,"MAX("           ; $92 MAX(
>baa9	05 26 4d 49 44 24 28			.text	5,$26,"MID$("          ; $93 MID$(
>bab0	04 0c 4d 49 4e 28			.text	4,$0c,"MIN("           ; $94 MIN(
>bab6	04 19 4e 4f 54 28			.text	4,$19,"NOT("           ; $95 NOT(
>babc	08 3c 50 4c 41 59 49 4e			.text	8,$3c,"PLAYING("       ; $96 PLAYING(
>bac4	47 28
>bac6	07 e9 52 41 4e 44 4f 4d			.text	7,$e9,"RANDOM("        ; $97 RANDOM(
>bace	28
>bacf	07 ca 52 49 47 48 54 24			.text	7,$ca,"RIGHT$("        ; $98 RIGHT$(
>bad7	28
>bad8	04 0c 52 4e 44 28			.text	4,$0c,"RND("           ; $99 RND(
>bade	04 10 53 47 4e 28			.text	4,$10,"SGN("           ; $9a SGN(
>bae4	04 0e 53 50 43 28			.text	4,$0e,"SPC("           ; $9b SPC(
>baea	05 45 53 54 52 24 28			.text	5,$45,"STR$("          ; $9c STR$(
>baf1	06 a9 54 49 4d 45 52 28			.text	6,$a9,"TIMER("         ; $9d TIMER(
>baf9	04 40 54 52 55 45			.text	4,$40,"TRUE"           ; $9e TRUE
>baff	04 0b 56 41 4c 28			.text	4,$0b,"VAL("           ; $9f VAL(
>bb05	03 e7 46 4f 52				.text	3,$e7,"FOR"            ; $a0 FOR
>bb0a	02 8f 49 46				.text	2,$8f,"IF"             ; $a1 IF
>bb0e	04 34 50 52 4f 43			.text	4,$34,"PROC"           ; $a2 PROC
>bb14	06 c1 52 45 50 45 41 54			.text	6,$c1,"REPEAT"         ; $a3 REPEAT
>bb1c	05 79 57 48 49 4c 45			.text	5,$79,"WHILE"          ; $a4 WHILE
>bb23	05 66 45 4e 44 49 46			.text	5,$66,"ENDIF"          ; $a5 ENDIF
>bb2a	07 0b 45 4e 44 50 52 4f			.text	7,$0b,"ENDPROC"        ; $a6 ENDPROC
>bb32	43
>bb33	04 3f 4e 45 58 54			.text	4,$3f,"NEXT"           ; $a7 NEXT
>bb39	04 2f 54 48 45 4e			.text	4,$2f,"THEN"           ; $a8 THEN
>bb3f	05 8c 55 4e 54 49 4c			.text	5,$8c,"UNTIL"          ; $a9 UNTIL
>bb46	04 2e 57 45 4e 44			.text	4,$2e,"WEND"           ; $aa WEND
>bb4c	02 9b 42 59				.text	2,$9b,"BY"             ; $ab BY
>bb50	04 1c 43 41 4c 4c			.text	4,$1c,"CALL"           ; $ac CALL
>bb56	06 b2 43 49 52 43 4c 45			.text	6,$b2,"CIRCLE"         ; $ad CIRCLE
>bb5e	05 67 43 4c 45 41 52			.text	5,$67,"CLEAR"          ; $ae CLEAR
>bb65	03 e2 43 4c 53				.text	3,$e2,"CLS"            ; $af CLS
>bb6a	05 7f 43 4f 4c 4f 52			.text	5,$7f,"COLOR"          ; $b0 COLOR
>bb71	06 d4 43 4f 4c 4f 55 52			.text	6,$d4,"COLOUR"         ; $b1 COLOUR
>bb79	04 1a 44 41 54 41			.text	4,$1a,"DATA"           ; $b2 DATA
>bb7f	03 da 44 49 4d				.text	3,$da,"DIM"            ; $b3 DIM
>bb84	06 db 44 4f 57 4e 54 4f			.text	6,$db,"DOWNTO"         ; $b4 DOWNTO
>bb8c	04 29 45 4c 53 45			.text	4,$29,"ELSE"           ; $b5 ELSE
>bb92	04 34 46 52 4f 4d			.text	4,$34,"FROM"           ; $b6 FROM
>bb98	03 e5 47 46 58				.text	3,$e5,"GFX"            ; $b7 GFX
>bb9d	05 80 47 4f 53 55 42			.text	5,$80,"GOSUB"          ; $b8 GOSUB
>bba4	04 39 47 4f 54 4f			.text	4,$39,"GOTO"           ; $b9 GOTO
>bbaa	04 24 48 45 52 45			.text	4,$24,"HERE"           ; $ba HERE
>bbb0	05 63 49 4d 41 47 45			.text	5,$63,"IMAGE"          ; $bb IMAGE
>bbb7	03 e5 4c 45 54				.text	3,$e5,"LET"            ; $bc LET
>bbbc	04 28 4c 49 4e 45			.text	4,$28,"LINE"           ; $bd LINE
>bbc2	05 6b 4c 4f 43 41 4c			.text	5,$6b,"LOCAL"          ; $be LOCAL
>bbc9	03 db 4f 46 46				.text	3,$db,"OFF"            ; $bf OFF
>bbce	02 9d 4f 4e				.text	2,$9d,"ON"             ; $c0 ON
>bbd2	07 20 4f 55 54 4c 49 4e			.text	7,$20,"OUTLINE"        ; $c1 OUTLINE
>bbda	45
>bbdb	07 0f 50 41 4c 45 54 54			.text	7,$0f,"PALETTE"        ; $c2 PALETTE
>bbe3	45
>bbe4	04 3f 50 4c 4f 54			.text	4,$3f,"PLOT"           ; $c3 PLOT
>bbea	05 8d 50 52 49 4e 54			.text	5,$8d,"PRINT"          ; $c4 PRINT
>bbf1	04 1c 52 45 41 44			.text	4,$1c,"READ"           ; $c5 READ
>bbf7	04 2e 52 45 43 54			.text	4,$2e,"RECT"           ; $c6 RECT
>bbfd	03 e4 52 45 4d				.text	3,$e4,"REM"            ; $c7 REM
>bc02	06 e0 52 45 54 55 52 4e			.text	6,$e0,"RETURN"         ; $c8 RETURN
>bc0a	05 7b 53 4f 4c 49 44			.text	5,$7b,"SOLID"          ; $c9 SOLID
>bc11	05 89 53 4f 55 4e 44			.text	5,$89,"SOUND"          ; $ca SOUND
>bc18	06 d7 53 50 52 49 54 45			.text	6,$d7,"SPRITE"         ; $cb SPRITE
>bc20	04 45 54 45 58 54			.text	4,$45,"TEXT"           ; $cc TEXT
>bc26	02 a3 54 4f				.text	2,$a3,"TO"             ; $cd TO
>bc2a	ff					.text	$FF
.bc2b					KeywordSet1:
>bc2b	00 65					.text	0,$65,""               ; $80 !0:EOF
>bc2d	00 58					.text	0,$58,""               ; $81 !1:SH1
>bc2f	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bc31	08 4c 41 53 53 45 4d 42			.text	8,$4c,"ASSEMBLE"       ; $83 ASSEMBLE
>bc39	4c 45
>bc3b	06 d2 41 53 53 45 52 54			.text	6,$d2,"ASSERT"         ; $84 ASSERT
>bc43	06 bd 42 49 54 4d 41 50			.text	6,$bd,"BITMAP"         ; $85 BITMAP
>bc4b	03 d7 45 4e 44				.text	3,$d7,"END"            ; $86 END
>bc50	04 3c 4c 49 53 54			.text	4,$3c,"LIST"           ; $87 LIST
>bc56	03 ea 4e 45 57				.text	3,$ea,"NEW"            ; $88 NEW
>bc5b	07 24 52 45 53 54 4f 52			.text	7,$24,"RESTORE"        ; $89 RESTORE
>bc63	45
>bc64	03 f5 52 55 4e				.text	3,$f5,"RUN"            ; $8a RUN
>bc69	07 2a 53 50 52 49 54 45			.text	7,$2a,"SPRITES"        ; $8b SPRITES
>bc71	53
>bc72	04 46 53 54 4f 50			.text	4,$46,"STOP"           ; $8c STOP
>bc78	ff					.text	$FF
.bc79					KeywordSet2:
>bc79	00 65					.text	0,$65,""               ; $80 !0:EOF
>bc7b	00 58					.text	0,$58,""               ; $81 !1:SH1
>bc7d	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bc7f	03 c8 41 44 43				.text	3,$c8,"ADC"            ; $83 ADC
>bc84	03 d3 41 4e 44				.text	3,$d3,"AND"            ; $84 AND
>bc89	03 e0 41 53 4c				.text	3,$e0,"ASL"            ; $85 ASL
>bc8e	03 c8 42 43 43				.text	3,$c8,"BCC"            ; $86 BCC
>bc93	03 d8 42 43 53				.text	3,$d8,"BCS"            ; $87 BCS
>bc98	03 d8 42 45 51				.text	3,$d8,"BEQ"            ; $88 BEQ
>bc9d	03 df 42 49 54				.text	3,$df,"BIT"            ; $89 BIT
>bca2	03 d8 42 4d 49				.text	3,$d8,"BMI"            ; $8a BMI
>bca7	03 d5 42 4e 45				.text	3,$d5,"BNE"            ; $8b BNE
>bcac	03 de 42 50 4c				.text	3,$de,"BPL"            ; $8c BPL
>bcb1	03 d5 42 52 41				.text	3,$d5,"BRA"            ; $8d BRA
>bcb6	03 df 42 52 4b				.text	3,$df,"BRK"            ; $8e BRK
>bcbb	03 db 42 56 43				.text	3,$db,"BVC"            ; $8f BVC
>bcc0	03 eb 42 56 53				.text	3,$eb,"BVS"            ; $90 BVS
>bcc5	03 d2 43 4c 43				.text	3,$d2,"CLC"            ; $91 CLC
>bcca	03 d3 43 4c 44				.text	3,$d3,"CLD"            ; $92 CLD
>bccf	03 d8 43 4c 49				.text	3,$d8,"CLI"            ; $93 CLI
>bcd4	03 e5 43 4c 56				.text	3,$e5,"CLV"            ; $94 CLV
>bcd9	03 e0 43 4d 50				.text	3,$e0,"CMP"            ; $95 CMP
>bcde	03 eb 43 50 58				.text	3,$eb,"CPX"            ; $96 CPX
>bce3	03 ec 43 50 59				.text	3,$ec,"CPY"            ; $97 CPY
>bce8	03 cc 44 45 43				.text	3,$cc,"DEC"            ; $98 DEC
>bced	03 e1 44 45 58				.text	3,$e1,"DEX"            ; $99 DEX
>bcf2	03 e2 44 45 59				.text	3,$e2,"DEY"            ; $9a DEY
>bcf7	03 e6 45 4f 52				.text	3,$e6,"EOR"            ; $9b EOR
>bcfc	03 da 49 4e 43				.text	3,$da,"INC"            ; $9c INC
>bd01	03 ef 49 4e 58				.text	3,$ef,"INX"            ; $9d INX
>bd06	03 f0 49 4e 59				.text	3,$f0,"INY"            ; $9e INY
>bd0b	03 e7 4a 4d 50				.text	3,$e7,"JMP"            ; $9f JMP
>bd10	03 ef 4a 53 52				.text	3,$ef,"JSR"            ; $a0 JSR
>bd15	03 d1 4c 44 41				.text	3,$d1,"LDA"            ; $a1 LDA
>bd1a	03 e8 4c 44 58				.text	3,$e8,"LDX"            ; $a2 LDX
>bd1f	03 e9 4c 44 59				.text	3,$e9,"LDY"            ; $a3 LDY
>bd24	03 f1 4c 53 52				.text	3,$f1,"LSR"            ; $a4 LSR
>bd29	03 ed 4e 4f 50				.text	3,$ed,"NOP"            ; $a5 NOP
>bd2e	03 e2 4f 52 41				.text	3,$e2,"ORA"            ; $a6 ORA
>bd33	03 d9 50 48 41				.text	3,$d9,"PHA"            ; $a7 PHA
>bd38	03 e8 50 48 50				.text	3,$e8,"PHP"            ; $a8 PHP
>bd3d	03 f0 50 48 58				.text	3,$f0,"PHX"            ; $a9 PHX
>bd42	03 f1 50 48 59				.text	3,$f1,"PHY"            ; $aa PHY
>bd47	03 dd 50 4c 41				.text	3,$dd,"PLA"            ; $ab PLA
>bd4c	03 ec 50 4c 50				.text	3,$ec,"PLP"            ; $ac PLP
>bd51	03 f4 50 4c 58				.text	3,$f4,"PLX"            ; $ad PLX
>bd56	03 f5 50 4c 59				.text	3,$f5,"PLY"            ; $ae PLY
>bd5b	03 ed 52 4f 4c				.text	3,$ed,"ROL"            ; $af ROL
>bd60	03 f3 52 4f 52				.text	3,$f3,"ROR"            ; $b0 ROR
>bd65	03 ef 52 54 49				.text	3,$ef,"RTI"            ; $b1 RTI
>bd6a	03 f9 52 54 53				.text	3,$f9,"RTS"            ; $b2 RTS
>bd6f	03 d8 53 42 43				.text	3,$d8,"SBC"            ; $b3 SBC
>bd74	03 db 53 45 43				.text	3,$db,"SEC"            ; $b4 SEC
>bd79	03 dc 53 45 44				.text	3,$dc,"SED"            ; $b5 SED
>bd7e	03 e1 53 45 49				.text	3,$e1,"SEI"            ; $b6 SEI
>bd83	03 e8 53 54 41				.text	3,$e8,"STA"            ; $b7 STA
>bd88	03 f7 53 54 50				.text	3,$f7,"STP"            ; $b8 STP
>bd8d	03 ff 53 54 58				.text	3,$ff,"STX"            ; $b9 STX
>bd92	03 00 53 54 59				.text	3,$00,"STY"            ; $ba STY
>bd97	03 01 53 54 5a				.text	3,$01,"STZ"            ; $bb STZ
>bd9c	03 ed 54 41 58				.text	3,$ed,"TAX"            ; $bc TAX
>bda1	03 ee 54 41 59				.text	3,$ee,"TAY"            ; $bd TAY
>bda6	03 e8 54 52 42				.text	3,$e8,"TRB"            ; $be TRB
>bdab	03 e9 54 53 42				.text	3,$e9,"TSB"            ; $bf TSB
>bdb0	03 ff 54 53 58				.text	3,$ff,"TSX"            ; $c0 TSX
>bdb5	03 ed 54 58 41				.text	3,$ed,"TXA"            ; $c1 TXA
>bdba	03 ff 54 58 53				.text	3,$ff,"TXS"            ; $c2 TXS
>bdbf	03 ee 54 59 41				.text	3,$ee,"TYA"            ; $c3 TYA
>bdc4	ff					.text	$FF
.b3c5					ListConvertLine:
.b3c5	48		pha				pha 								; save indent on the stack
.b3c6	9c 9d 04	stz $049d			stz 	tbOffset
.b3c9	9c ab 04	stz $04ab			stz 	tokenBuffer
.b3cc	a0 02		ldy #$02			ldy 	#2 							; convert line number to string
.b3ce	b1 30		lda ($30),y			lda 	(codePtr),y
.b3d0	aa		tax				tax
.b3d1	88		dey				dey
.b3d2	b1 30		lda ($30),y			lda 	(codePtr),y
.b3d4	20 7b 92	jsr $927b			jsr 	LCLConvertInt16
.b3d7	85 36		sta $36				sta 	zTemp0 						; copy number into buffer
.b3d9	86 37		stx $37				stx 	zTemp0+1
.b3db	a9 8c		lda #$8c			lda 	#CLINumber+$80
.b3dd	20 22 b5	jsr $b522			jsr 	LCLWrite
.b3e0	a0 00		ldy #$00			ldy 	#0
.b3e2					_LCCopyNumber:
.b3e2	b1 36		lda ($36),y			lda 	(zTemp0),y
.b3e4	20 22 b5	jsr $b522			jsr 	LCLWrite
.b3e7	c8		iny				iny
.b3e8	b1 36		lda ($36),y			lda 	(zTemp0),y
.b3ea	d0 f6		bne $b3e2			bne 	_LCCopyNumber
.b3ec	68		pla				pla 								; adjustment to indent
.b3ed	48		pha				pha 								; save on stack
.b3ee	10 0c		bpl $b3fc			bpl 	_LCNoAdjust 				; don't adjust indent if +ve, do after.
.b3f0	18		clc				clc 								; add to list indent and make 0 if goes -ve.
.b3f1	6d a6 04	adc $04a6			adc 	listIndent
.b3f4	8d a6 04	sta $04a6			sta 	listIndent
.b3f7	10 03		bpl $b3fc			bpl 	_LCNoAdjust
.b3f9	9c a6 04	stz $04a6			stz 	listIndent
.b3fc					_LCNoAdjust:
.b3fc	18		clc				clc		 							; work out actual indent.
.b3fd	ad a6 04	lda $04a6			lda 	listIndent
.b400	0a		asl a				asl 	a
.b401	69 06		adc #$06			adc 	#6
.b403	85 36		sta $36				sta 	zTemp0
.b405					_LCPadOut:
.b405	a9 20		lda #$20			lda 	#' '						; pad out to 6 characters
.b407	20 22 b5	jsr $b522			jsr 	LCLWrite
.b40a	ad 9d 04	lda $049d			lda 	tbOffset
.b40d	c5 36		cmp $36				cmp 	zTemp0
.b40f	d0 f4		bne $b405			bne 	_LCPadOut
.b411	a0 03		ldy #$03			ldy 	#3 							; start position.
.b413					_LCMainLoop:
.b413	a9 8a		lda #$8a			lda 	#CLIPunctuation+$80
.b415	20 22 b5	jsr $b522			jsr 	LCLWrite
.b418	b1 30		lda ($30),y			lda 	(codePtr),y
.b41a	c9 80		cmp #$80			cmp 	#KWC_EOL 					; end of line ?
.b41c	f0 17		beq $b435			beq 	_LCExit
.b41e	c9 10		cmp #$10			cmp 	#16 						; 0-5 are the double punctuations
.b420	90 1e		bcc $b440			bcc 	_LCDoubles
.b422	c9 20		cmp #$20			cmp 	#32 						; 16-31 are shifted punctuation from 64-91
.b424	90 2a		bcc $b450			bcc 	_LCShiftPunc
.b426	c9 40		cmp #$40			cmp 	#64 						; 32-64 are as stored, punc and digits
.b428	90 35		bcc $b45f			bcc 	_LCPunctuation
.b42a	c9 80		cmp #$80			cmp 	#128 						; 64-127 are variable identifiers.
.b42c	90 3e		bcc $b46c			bcc 	_LCIdentifiers
.b42e	c9 fe		cmp #$fe			cmp 	#254 						; 128-253 are tokenised words
.b430	90 5f		bcc $b491			bcc 	_LCTokens
.b432	4c f1 b4	jmp $b4f1			jmp 	_LCData 					; 254-5 are data objects
.b435					_LCExit:
.b435	68		pla				pla 								; get old indent adjust
.b436	30 07		bmi $b43f			bmi 	_LCExit2
.b438	18		clc				clc 								; add to indent if +ve
.b439	6d a6 04	adc $04a6			adc 	listIndent
.b43c	8d a6 04	sta $04a6			sta 	listIndent
.b43f					_LCExit2:
.b43f	60		rts				rts
.b440					_LCDoubles:
.b440	48		pha				pha
.b441	4a		lsr a				lsr 	a 							; put bit 2 into bit 1
.b442	29 02		and #$02			and 	#2
.b444	09 3c		ora #$3c			ora 	#60 						; make < >
.b446	20 22 b5	jsr $b522			jsr 	LCLWrite
.b449	68		pla				pla 								; restore, do lower bit
.b44a	29 03		and #$03			and 	#3
.b44c	09 3c		ora #$3c			ora 	#60
.b44e	80 0f		bra $b45f			bra		_LCPunctuation 				; print, increment, loop
.b450					_LCShiftPunc:
.b450	aa		tax				tax 								; save in X
.b451	29 07		and #$07			and 	#7 							; lower 3 bits
.b453	f0 02		beq $b457			beq 	_LCNoAdd
.b455	09 18		ora #$18			ora 	#24 						; adds $18 to it.
.b457					_LCNoAdd:
.b457	e0 18		cpx #$18			cpx 	#24 						; if >= 24 add $20
.b459	90 02		bcc $b45d			bcc 	_LCNoAdd2
.b45b	09 20		ora #$20			ora 	#32 						; adds $20
.b45d					_LCNoAdd2:
.b45d	09 40		ora #$40			ora 	#$40 						; shift into 64-127 range and fall through.
.b45f					_LCPunctuation:
.b45f	c9 3a		cmp #$3a			cmp 	#':' 						; check if :
.b461	d0 03		bne $b466			bne 	_LCPContinue
.b463	20 38 b5	jsr $b538			jsr 	LCLDeleteLastSpace
.b466					_LCPContinue:
.b466	c8		iny				iny 								; consume character
.b467	20 22 b5	jsr $b522			jsr 	LCLWrite 					; write it out.
.b46a	80 a7		bra $b413			bra 	_LCMainLoop 				; go round again.
.b46c					_LCIdentifiers:
.b46c	18		clc				clc 								; convert to physical address
.b46d	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.b46f	85 37		sta $37				sta 	zTemp0+1
.b471	c8		iny				iny
.b472	b1 30		lda ($30),y			lda 	(codePtr),y
.b474	85 36		sta $36				sta 	zTemp0
.b476	c8		iny				iny
.b477	5a		phy				phy 								; save position
.b478	a9 87		lda #$87			lda 	#CLIIdentifier+$80
.b47a	20 22 b5	jsr $b522			jsr 	LCLWrite
.b47d	a0 07		ldy #$07			ldy 	#7 							; output the identifier.
.b47f					_LCOutIdentifier:
.b47f	c8		iny				iny
.b480	b1 36		lda ($36),y			lda 	(zTemp0),y
.b482	29 7f		and #$7f			and 	#$7F
.b484	20 74 b5	jsr $b574			jsr 	LCLLowerCase
.b487	20 22 b5	jsr $b522			jsr 	LCLWrite
.b48a	b1 36		lda ($36),y			lda 	(zTemp0),y				 	; ends when bit 7 set.
.b48c	10 f1		bpl $b47f			bpl 	_LCOutIdentifier
.b48e	7a		ply				ply 								; restore position
.b48f	80 82		bra $b413			bra 	_LCMainLoop
.b491					_LCTokens:
.b491	aa		tax				tax 								; token in X
.b492	a9 79		lda #$79			lda 	#((KeywordSet2) & $FF)
.b494	85 36		sta $36				sta 	0+zTemp0
.b496	a9 bc		lda #$bc			lda 	#((KeywordSet2) >> 8)
.b498	85 37		sta $37				sta 	1+zTemp0
.b49a	e0 82		cpx #$82			cpx 	#$82
.b49c	f0 16		beq $b4b4			beq 	_LCUseShift
.b49e	a9 2b		lda #$2b			lda 	#((KeywordSet1) & $FF)
.b4a0	85 36		sta $36				sta 	0+zTemp0
.b4a2	a9 bc		lda #$bc			lda 	#((KeywordSet1) >> 8)
.b4a4	85 37		sta $37				sta 	1+zTemp0
.b4a6	e0 81		cpx #$81			cpx 	#$81
.b4a8	f0 0a		beq $b4b4			beq 	_LCUseShift
.b4aa	a9 35		lda #$35			lda 	#((KeywordSet0) & $FF)
.b4ac	85 36		sta $36				sta 	0+zTemp0
.b4ae	a9 ba		lda #$ba			lda 	#((KeywordSet0) >> 8)
.b4b0	85 37		sta $37				sta 	1+zTemp0
.b4b2	80 01		bra $b4b5			bra 	_LCNoShift
.b4b4					_LCUseShift:
.b4b4	c8		iny				iny
.b4b5					_LCNoShift:
.b4b5	20 4c b5	jsr $b54c			jsr 	LCLCheckSpaceRequired 		; do we need a space ?
.b4b8	b1 30		lda ($30),y			lda 	(codePtr),y
.b4ba	aa		tax				tax 								; into X
.b4bb					_LCFindText:
.b4bb	ca		dex				dex
.b4bc	10 0e		bpl $b4cc			bpl 	_LCFoundText 				; found text.
.b4be	b2 36		lda ($36)			lda 	(zTemp0) 					; length of text
.b4c0	1a		inc a				inc 	a 							; one extra for size
.b4c1	38		sec				sec 								; one extra for checksum
.b4c2	65 36		adc $36				adc 	zTemp0 						; go to next token
.b4c4	85 36		sta $36				sta 	zTemp0
.b4c6	90 f3		bcc $b4bb			bcc 	_LCFindText
.b4c8	e6 37		inc $37				inc 	zTemp0+1
.b4ca	80 ef		bra $b4bb			bra 	_LCFindText
.b4cc					_LCFoundText:
.b4cc	5a		phy				phy 								; save List position
.b4cd	b2 36		lda ($36)			lda 	(zTemp0)					; count to print
.b4cf	aa		tax				tax
.b4d0	a9 83		lda #$83			lda 	#CLIToken+$80
.b4d2	20 22 b5	jsr $b522			jsr 	LCLWrite
.b4d5	a0 02		ldy #$02			ldy 	#2
.b4d7					_LCCopyToken:
.b4d7	b1 36		lda ($36),y			lda 	(zTemp0),y
.b4d9	20 74 b5	jsr $b574			jsr 	LCLLowerCase
.b4dc	20 22 b5	jsr $b522			jsr 	LCLWrite
.b4df	c8		iny				iny
.b4e0	ca		dex				dex
.b4e1	d0 f4		bne $b4d7			bne 	_LCCopyToken
.b4e3	c9 28		cmp #$28			cmp 	#"(" 						; if last char not ( print a space
.b4e5	f0 05		beq $b4ec			beq 	_LCNoSpace
.b4e7	a9 20		lda #$20			lda 	#' '
.b4e9	20 22 b5	jsr $b522			jsr 	LCLWrite
.b4ec					_LCNoSpace:
.b4ec	7a		ply				ply 								; restore position.
.b4ed	c8		iny				iny 								; consume token
.b4ee	4c 13 b4	jmp $b413			jmp 	_LCMainLoop 				; and go around again.
.b4f1					_LCData:
.b4f1	48		pha				pha 								; save type $FE/$FF
.b4f2	a2 24		ldx #$24			ldx 	#'$' 						; figure out $ or "
.b4f4	c9 fe		cmp #$fe			cmp 	#$FE
.b4f6	f0 07		beq $b4ff			beq 	_LCHaveOpener
.b4f8	a2 22		ldx #$22			ldx 	#'"'
.b4fa	a9 81		lda #$81			lda 	#CLIData+$80
.b4fc	20 22 b5	jsr $b522			jsr 	LCLWrite
.b4ff					_LCHaveOpener:
.b4ff	8a		txa				txa 								; output prefix (# or ")
.b500	20 22 b5	jsr $b522			jsr 	LCLWrite
.b503	c8		iny				iny 								; get count
.b504	b1 30		lda ($30),y			lda 	(codePtr),y
.b506	aa		tax				tax
.b507	c8		iny				iny 								; point at first character
.b508					_LCOutData:
.b508	b1 30		lda ($30),y			lda 	(codePtr),y
.b50a	c9 00		cmp #$00			cmp 	#0
.b50c	f0 03		beq $b511			beq 	_LCNoPrint
.b50e	20 22 b5	jsr $b522			jsr 	LCLWrite
.b511					_LCNoPrint:
.b511	c8		iny				iny
.b512	ca		dex				dex
.b513	d0 f3		bne $b508			bne 	_LCOutData
.b515	68		pla				pla 								; closing " required ?
.b516	c9 ff		cmp #$ff			cmp 	#$FF
.b518	d0 05		bne $b51f			bne 	_LCNoQuote
.b51a	a9 22		lda #$22			lda 	#'"'
.b51c	20 22 b5	jsr $b522			jsr 	LCLWrite
.b51f					_LCNoQuote:
.b51f	4c 13 b4	jmp $b413			jmp 	_LCMainLoop
.b522					LCLWrite:
.b522	da		phx				phx
.b523	ae 9d 04	ldx $049d			ldx 	tbOffset
.b526	9d ab 04	sta $04ab,x			sta 	tokenBuffer,x
.b529	9e ac 04	stz $04ac,x			stz 	tokenBuffer+1,x
.b52c	ee 9d 04	inc $049d			inc 	tbOffset
.b52f	09 00		ora #$00			ora 	#0 							; don't update if colour data
.b531	30 03		bmi $b536			bmi 	_LCLNoColour
.b533	8d a7 04	sta $04a7			sta 	LCLastCharacter
.b536					_LCLNoColour:
.b536	fa		plx				plx
.b537	60		rts				rts
.b538					LCLDeleteLastSpace:
.b538	48		pha				pha
.b539	da		phx				phx
.b53a	ae 9d 04	ldx $049d			ldx 	tbOffset
.b53d	f0 0a		beq $b549			beq 	_LCDLSExit
.b53f	bd aa 04	lda $04aa,x			lda 	tokenBuffer-1,x
.b542	c9 20		cmp #$20			cmp 	#' '
.b544	d0 03		bne $b549			bne 	_LCDLSExit
.b546	ce 9d 04	dec $049d			dec 	tbOffset
.b549					_LCDLSExit:
.b549	fa		plx				plx
.b54a	68		pla				pla
.b54b	60		rts				rts
.b54c					LCLCheckSpaceRequired:
.b54c	ad a7 04	lda $04a7			lda 	LCLastCharacter 			; check last character
.b54f	c9 24		cmp #$24			cmp 	#'$' 						; $ # and ) require that token space.
.b551	f0 1b		beq $b56e			beq 	_LCCSRSpace
.b553	c9 29		cmp #$29			cmp 	#')'
.b555	f0 17		beq $b56e			beq 	_LCCSRSpace
.b557	c9 23		cmp #$23			cmp 	#'#'
.b559	f0 13		beq $b56e			beq 	_LCCSRSpace
.b55b	20 74 b5	jsr $b574			jsr 	LCLLowerCase 				; saves a little effort
.b55e	c9 30		cmp #$30			cmp 	#"0" 						; check if it was 0-9 A-Z a-z if so need space.
.b560	90 11		bcc $b573			bcc 	_LCCSRExit
.b562	c9 3a		cmp #$3a			cmp 	#"9"+1
.b564	90 08		bcc $b56e			bcc 	_LCCSRSpace
.b566	c9 61		cmp #$61			cmp 	#"a"
.b568	90 09		bcc $b573			bcc 	_LCCSRExit
.b56a	c9 7b		cmp #$7b			cmp 	#"z"+1
.b56c	b0 05		bcs $b573			bcs 	_LCCSRExit
.b56e					_LCCSRSpace:
.b56e	a9 20		lda #$20			lda 	#' '
.b570	20 22 b5	jsr $b522			jsr 	LCLWrite
.b573					_LCCSRExit:
.b573	60		rts				rts
.b574					LCLLowerCase:
.b574	c9 41		cmp #$41			cmp 	#"A"
.b576	90 06		bcc $b57e			bcc 	_LCLLCOut
.b578	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b57a	b0 02		bcs $b57e			bcs 	_LCLLCOut
.b57c	69 20		adc #$20			adc 	#$20
.b57e					_LCLLCOut:
.b57e	60		rts				rts
.b57f					LCLUpperCase:
.b57f	c9 61		cmp #$61			cmp 	#"a"
.b581	90 06		bcc $b589			bcc 	_LCLUCOut
.b583	c9 7b		cmp #$7b			cmp 	#"z"+1
.b585	b0 02		bcs $b589			bcs 	_LCLUCOut
.b587	e9 1f		sbc #$1f			sbc 	#$1F
.b589					_LCLUCOut:
.b589	60		rts				rts
.b58a					TOKSearchTable:
.b58a	84 37		sty $37				sty 	zTemp0+1 					; (zTemp0),y points to current token.
.b58c	85 36		sta $36				sta 	zTemp0
.b58e	a0 00		ldy #$00			ldy 	#0
.b590	a9 80		lda #$80			lda 	#$80 						; token #
.b592	85 38		sta $38				sta 	zTemp1
.b594					_TSTLoop:
.b594	b1 36		lda ($36),y			lda 	(zTemp0),y 					; length, 0 (skip) -ve (end)
.b596	30 49		bmi $b5e1			bmi 	_TSTFail 					; -ve = end of table
.b598	f0 2e		beq $b5c8			beq 	_TSTNext 					; zero, check next it's a dummy
.b59a	c8		iny				iny 								; get the hash
.b59b	b1 36		lda ($36),y			lda 	(zTemp0),y
.b59d	88		dey				dey
.b59e	cd 83 04	cmp $0483			cmp 	identHash 					; check they match, if not go to next
.b5a1	d0 25		bne $b5c8			bne 	_TSTNext
.b5a3	ad 82 04	lda $0482			lda 	identTypeEnd 				; length of identifier
.b5a6	38		sec				sec
.b5a7	ed 80 04	sbc $0480			sbc 	identStart
.b5aa	d1 36		cmp ($36),y			cmp 	(zTemp0),y 					; no match, then return.
.b5ac	d0 1a		bne $b5c8			bne 	_TSTNext
.b5ae	5a		phy				phy 								; save Y , we might fail
.b5af	c8		iny				iny 								; point to text
.b5b0	c8		iny				iny
.b5b1	ae 80 04	ldx $0480			ldx 	identStart 					; offset in line buffer in X
.b5b4					_TSTCompareName:
.b5b4	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; compare text.
.b5b7	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.b5b9	d0 0c		bne $b5c7			bne 	_TSTNextPullY 				; fail, pullY and do next
.b5bb	e8		inx				inx
.b5bc	c8		iny				iny
.b5bd	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; complete match.
.b5c0	d0 f2		bne $b5b4			bne 	_TSTCompareName
.b5c2	7a		ply				ply 								; throw Y
.b5c3	a5 38		lda $38				lda 	zTemp1 						; get token #
.b5c5	38		sec				sec 								; return with CS = passed.
.b5c6	60		rts				rts
.b5c7					_TSTNextPullY:
.b5c7	7a		ply				ply 								; restore current, fall through.
.b5c8					_TSTNext:
.b5c8	e6 38		inc $38				inc 	zTemp1 						; token counter
.b5ca	98		tya				tya
.b5cb	18		clc				clc
.b5cc	71 36		adc ($36),y			adc 	(zTemp0),y 					; add [Length] + 2 to Y
.b5ce	1a		inc a				inc 	a 							; +1
.b5cf	1a		inc a				inc 	a 							; +2
.b5d0	a8		tay				tay
.b5d1	10 c1		bpl $b594			bpl 	_TSTLoop 					; if Y < $80 loop back
.b5d3	98		tya				tya 								; add Y to zTemp0 and reset Y
.b5d4	a0 00		ldy #$00			ldy 	#0   						; so we can use Y to search fast
.b5d6	18		clc				clc  								; but have tables > 255 bytes
.b5d7	65 36		adc $36				adc 	zTemp0 						; when Y gets >= 128 we reset Y
.b5d9	85 36		sta $36				sta 	zTemp0 						; and adjust the table pointer/
.b5db	90 b7		bcc $b594			bcc 	_TSTLoop
.b5dd	e6 37		inc $37				inc 	zTemp0+1
.b5df	80 b3		bra $b594			bra 	_TSTLoop
.b5e1					_TSTFail:
.b5e1	18		clc				clc
.b5e2	60		rts				rts
.b5e3					TokeniseLine:
.b5e3	20 6b b7	jsr $b76b			jsr 	LCLFixLineBufferCase 		; fix line case
.b5e6	a9 03		lda #$03			lda 	#3 							; reset the token buffer to empty
.b5e8	8d a8 04	sta $04a8			sta 	tokenOffset
.b5eb	9c a9 04	stz $04a9			stz 	tokenLineNumber
.b5ee	9c aa 04	stz $04aa			stz 	tokenLineNumber+1
.b5f1	a2 ff		ldx #$ff			ldx 	#$FF
.b5f3					_TKFindFirst:
.b5f3	e8		inx				inx
.b5f4	bd a8 05	lda $05a8,x			lda 	lineBuffer,x
.b5f7	f0 79		beq $b672			beq 	_TKExit
.b5f9	c9 20		cmp #$20			cmp 	#' '
.b5fb	90 f6		bcc $b5f3			bcc 	_TKFindFirst
.b5fd	c9 30		cmp #$30			cmp 	#'0'
.b5ff	90 07		bcc $b608			bcc 	_TKNoLineNumber
.b601	c9 3a		cmp #$3a			cmp 	#'9'+1
.b603	b0 03		bcs $b608			bcs 	_TKNoLineNumber
.b605	20 95 b7	jsr $b795			jsr 	TOKExtractLineNumber
.b608					_TKNoLineNumber:
.b608					_TKTokeniseLoop:
.b608	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; next character, exit if zero EOL.
.b60b	f0 65		beq $b672			beq 	_TKExit
.b60d	e8		inx				inx
.b60e	c9 20		cmp #$20			cmp 	#' '
.b610	f0 f6		beq $b608			beq 	_TKTokeniseLoop 			; keep looping if space found.
.b612	ca		dex				dex 								; undo last get, A contains character, X is position.
.b613	c9 5f		cmp #$5f			cmp 	#'_'						; _ A-Z is identifier *or* token
.b615	f0 61		beq $b678			beq 	_TKTokeniseIdentifier
.b617	c9 41		cmp #$41			cmp 	#'A'
.b619	90 04		bcc $b61f			bcc 	_TKTokenisePunctuation
.b61b	c9 5b		cmp #$5b			cmp 	#'Z'+1
.b61d	90 59		bcc $b678			bcc 	_TKTokeniseIdentifier
.b61f					_TKTokenisePunctuation:
.b61f	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.b621	f0 27		beq $b64a			beq 	_TKString
.b623	c9 24		cmp #$24			cmp 	#'$'						; hexadecimal constant (# only appears at end of identifiers)
.b625	f0 28		beq $b64f			beq 	_TKHexConstant
.b627	c9 3c		cmp #$3c			cmp 	#'<' 						; check for < > handlers.
.b629	f0 29		beq $b654			beq 	_TKCheckDouble
.b62b	c9 3e		cmp #$3e			cmp 	#'>'
.b62d	f0 25		beq $b654			beq 	_TKCheckDouble
.b62f					_TKStandardPunctuation:
.b62f	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; get it back.
.b632	c9 40		cmp #$40			cmp 	#64 						; are we >= 64
.b634	90 0e		bcc $b644			bcc 	_TKNoShift
.b636	48		pha				pha 								; save
.b637	29 07		and #$07			and 	#7 							; lower 3 bits in zTemp0
.b639	85 36		sta $36				sta 	zTemp0
.b63b	68		pla				pla
.b63c	29 20		and #$20			and 	#32 						; bit 5
.b63e	4a		lsr a				lsr 	a 							; shift into bit 3
.b63f	4a		lsr a				lsr 	a
.b640	05 36		ora $36				ora 	zTemp0
.b642	09 10		ora #$10			ora 	#$10						; now in the range 16-31
.b644					_TKNoShift:
.b644	20 da b7	jsr $b7da			jsr 	TOKWriteByte 				; write the punctuation character
.b647	e8		inx				inx 								; consume the character
.b648	80 be		bra $b608			bra 	_TKTokeniseLoop 			; and loop round again.
.b64a					_TKString:
.b64a	20 fa b6	jsr $b6fa			jsr 	TOKTokenString
.b64d	80 b9		bra $b608			bra 	_TKTokeniseLoop
.b64f					_TKHexConstant:
.b64f	20 35 b7	jsr $b735			jsr 	TOKHexConstant
.b652	80 b4		bra $b608			bra 	_TKTokeniseLoop
.b654					_TKCheckDouble:
.b654	bd a9 05	lda $05a9,x			lda 	lineBuffer+1,x 				; get next character
.b657	c9 3c		cmp #$3c			cmp 	#'<'						; if not < = > which are ASCII consecutive go back
.b659	90 d4		bcc $b62f			bcc 	_TKStandardPunctuation
.b65b	c9 3f		cmp #$3f			cmp 	#'>'+1
.b65d	b0 d0		bcs $b62f			bcs 	_TKStandardPunctuation
.b65f	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; this is < (60) or > (62)
.b662	29 02		and #$02			and 	#2 							; now < (0) or > (2)
.b664	0a		asl a				asl 	a 							; now < (0) or > (4), CC also
.b665	7d a9 05	adc $05a9,x			adc 	lineBuffer+1,x 				; add < = > codes - < code
.b668	38		sec				sec
.b669	e9 3c		sbc #$3c			sbc 	#'<'
.b66b	20 da b7	jsr $b7da			jsr 	TOKWriteByte 				; this is in the range 0-7
.b66e	e8		inx				inx 								; consume both
.b66f	e8		inx				inx
.b670	80 96		bra $b608			bra 	_TKTokeniseLoop
.b672	a9 80		lda #$80	_TKExit:lda 	#KWC_EOL 					; write end of line byte
.b674	20 da b7	jsr $b7da			jsr 	TOKWriteByte
.b677	60		rts				rts
.b678					_TKTokeniseIdentifier:
.b678	8e 80 04	stx $0480			stx 	identStart 					; save start
.b67b	9c 84 04	stz $0484			stz 	identTypeByte 				; zero the type byte
.b67e					_TKCheckLoop:
.b67e	e8		inx				inx 								; look at next, we know first is identifier.
.b67f	bd a8 05	lda $05a8,x			lda  	lineBuffer,x
.b682	c9 5f		cmp #$5f			cmp 	#"_" 						; legal char _ 0-9 A-Z
.b684	f0 f8		beq $b67e			beq 	_TKCheckLoop
.b686	c9 30		cmp #$30			cmp	 	#"0"
.b688	90 0c		bcc $b696			bcc 	_TKEndIdentifier
.b68a	c9 3a		cmp #$3a			cmp 	#"9"+1
.b68c	90 f0		bcc $b67e			bcc 	_TKCheckLoop
.b68e	c9 41		cmp #$41			cmp	 	#"A"
.b690	90 04		bcc $b696			bcc 	_TKEndIdentifier
.b692	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b694	90 e8		bcc $b67e			bcc 	_TKCheckLoop
.b696					_TKEndIdentifier:
.b696	8e 81 04	stx $0481			stx 	identTypeStart 				; save start of type text (if any !)
.b699	a0 08		ldy #$08			ldy 	#$08 						; this is the identifier type byte for #
.b69b	c9 23		cmp #$23			cmp 	#"#"						; followed by #
.b69d	f0 06		beq $b6a5			beq 	_TKHasTypeCharacter
.b69f	a0 10		ldy #$10			ldy 	#$10 						; this is the identifier type byte for $
.b6a1	c9 24		cmp #$24			cmp 	#"$"						; followed by $ or #
.b6a3	d0 07		bne $b6ac			bne 	_TKNoTypeCharacter
.b6a5					_TKHasTypeCharacter:
.b6a5	8c 84 04	sty $0484			sty 	identTypeByte 				; has # or $, save the type
.b6a8	e8		inx				inx 								; read next
.b6a9	bd a8 05	lda $05a8,x			lda 	lineBuffer,x
.b6ac					_TKNoTypeCharacter:
.b6ac	c9 28		cmp #$28			cmp 	#"("						; is it open parenthesis (e.g. array)
.b6ae	d0 09		bne $b6b9			bne 	_TKNoArray
.b6b0	e8		inx				inx 								; skip the (
.b6b1	ad 84 04	lda $0484			lda 	identTypeByte 				; set bit 2 (e.g. array)
.b6b4	09 04		ora #$04			ora 	#$04
.b6b6	8d 84 04	sta $0484			sta 	identTypeByte
.b6b9					_TKNoArray:
.b6b9	8e 82 04	stx $0482			stx 	identTypeEnd 				; save end marker, e.g. continue from here.
.b6bc	20 56 b7	jsr $b756			jsr 	TOKCalculateHash 			; calculate the has for those tokens
.b6bf	a0 ba		ldy #$ba			ldy 	#(KeywordSet0) >> 8
.b6c1	a9 35		lda #$35			lda 	#(KeywordSet0) & $FF
.b6c3	20 8a b5	jsr $b58a			jsr 	TOKSearchTable
.b6c6	a2 00		ldx #$00			ldx 	#0
.b6c8	b0 1f		bcs $b6e9			bcs 	_TKFoundToken
.b6ca	a0 bc		ldy #$bc			ldy 	#(KeywordSet1) >> 8
.b6cc	a9 2b		lda #$2b			lda 	#(KeywordSet1) & $FF
.b6ce	20 8a b5	jsr $b58a			jsr 	TOKSearchTable
.b6d1	a2 81		ldx #$81			ldx 	#$81
.b6d3	b0 14		bcs $b6e9			bcs 	_TKFoundToken
.b6d5	a0 bc		ldy #$bc			ldy 	#(KeywordSet2) >> 8
.b6d7	a9 79		lda #$79			lda 	#(KeywordSet2) & $FF
.b6d9	20 8a b5	jsr $b58a			jsr 	TOKSearchTable
.b6dc	a2 82		ldx #$82			ldx 	#$82
.b6de	b0 09		bcs $b6e9			bcs 	_TKFoundToken
.b6e0	20 e6 b7	jsr $b7e6			jsr 	TOKCheckCreateVariableRecord ; failed all, it's a variable, create record if does not exist.
.b6e3	ae 82 04	ldx $0482			ldx 	identTypeEnd 				; X points to following byte
.b6e6	4c 08 b6	jmp $b608			jmp 	_TKTokeniseLoop 			; and go round again.
.b6e9					_TKFoundToken:
.b6e9	48		pha				pha 								; save token
.b6ea	8a		txa				txa 								; shift in X, is there one ?
.b6eb	f0 03		beq $b6f0			beq 	_TKNoTShift
.b6ed	20 da b7	jsr $b7da			jsr 	TOKWriteByte 				; if so, write it out
.b6f0					_TKNoTShift:
.b6f0	68		pla				pla 								; restore and write token
.b6f1	20 da b7	jsr $b7da			jsr 	TOKWriteByte
.b6f4	ae 82 04	ldx $0482			ldx 	identTypeEnd 				; X points to following byte
.b6f7	4c 08 b6	jmp $b608			jmp 	_TKTokeniseLoop 			; and go round again.
.b6fa					TOKTokenString:
.b6fa	a9 ff		lda #$ff			lda 	#KWC_STRING 				; string token.
.b6fc	20 da b7	jsr $b7da			jsr 	TOKWriteByte
.b6ff	e8		inx				inx									; start of quoted string.
.b700	da		phx				phx 								; push start of string on top
.b701	ca		dex				dex
.b702					_TSFindEnd:
.b702	e8		inx				inx
.b703	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; next character
.b706	f0 04		beq $b70c			beq 	_TSEndOfString
.b708	c9 22		cmp #$22			cmp 	#'"'
.b70a	d0 f6		bne $b702			bne 	_TSFindEnd
.b70c					_TSEndOfString:
.b70c	7a		ply				ply  								; so now Y is first character, X is character after end.
.b70d	48		pha				pha 								; save terminating character
.b70e	20 16 b7	jsr $b716			jsr 	TOKWriteBlockXY 			; write X to Y as a data block
.b711	68		pla				pla 								; terminating character
.b712	f0 01		beq $b715			beq 	_TSNotQuote					; if it wasn't EOS skip it
.b714	e8		inx				inx
.b715					_TSNotQuote:
.b715	60		rts				rts
.b716					TOKWriteBlockXY:
.b716	86 36		stx $36				stx 	zTemp0 						; write end character
.b718	98		tya				tya
.b719	49 ff		eor #$ff			eor 	#$FF
.b71b	38		sec				sec
.b71c	65 36		adc $36				adc 	zTemp0
.b71e	1a		inc a				inc 	a 							; one extra for NULL
.b71f	20 da b7	jsr $b7da			jsr 	TOKWriteByte
.b722					_TOBlockLoop:
.b722	c4 36		cpy $36				cpy 	zTemp0
.b724	f0 09		beq $b72f			beq 	_TOBlockExit
.b726	b9 a8 05	lda $05a8,y			lda 	lineBuffer,y
.b729	20 da b7	jsr $b7da			jsr 	TOKWriteByte
.b72c	c8		iny				iny
.b72d	80 f3		bra $b722			bra 	_TOBlockLoop
.b72f					_TOBlockExit:
.b72f	a9 00		lda #$00			lda 	#0
.b731	20 da b7	jsr $b7da			jsr 	TOKWriteByte
.b734	60		rts				rts
.b735					TOKHexConstant:
.b735	a9 fe		lda #$fe			lda 	#KWC_HEXCONST 				; hex constant token.
.b737	20 da b7	jsr $b7da			jsr 	TOKWriteByte
.b73a	e8		inx				inx									; start of quoted string.
.b73b	da		phx				phx 								; push start of constant on top
.b73c	ca		dex				dex
.b73d					_THFindLoop:
.b73d	e8		inx				inx
.b73e	bd a8 05	lda $05a8,x			lda 	lineBuffer,x
.b741	c9 30		cmp #$30			cmp 	#"0"
.b743	90 0c		bcc $b751			bcc 	_THFoundEnd
.b745	c9 3a		cmp #$3a			cmp 	#"9"+1
.b747	90 f4		bcc $b73d			bcc 	_THFindLoop
.b749	c9 41		cmp #$41			cmp 	#"A"
.b74b	90 04		bcc $b751			bcc 	_THFoundEnd
.b74d	c9 47		cmp #$47			cmp 	#"F"+1
.b74f	90 ec		bcc $b73d			bcc 	_THFindLoop
.b751					_THFoundEnd:
.b751	7a		ply				ply 								; restore start
.b752	20 16 b7	jsr $b716			jsr 	TOKWriteBlockXY 			; output the block
.b755	60		rts				rts
.b756					TOKCalculateHash:
.b756	da		phx				phx
.b757	ae 80 04	ldx $0480			ldx 	identStart 					; needs to be same as in tokens.py - simple sum
.b75a	a9 00		lda #$00			lda 	#0
.b75c					_TCHLoop:
.b75c	18		clc				clc
.b75d	7d a8 05	adc $05a8,x			adc 	lineBuffer,x
.b760	e8		inx				inx
.b761	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; do the whole thing including type and array markers.
.b764	d0 f6		bne $b75c			bne 	_TCHLoop
.b766	8d 83 04	sta $0483			sta 	identHash 					; save the hash
.b769	fa		plx				plx
.b76a	60		rts				rts
.b76b					LCLFixLineBufferCase:
.b76b	a2 00		ldx #$00			ldx 	#0
.b76d					_FLBCLoop:
.b76d	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; get next character
.b770	f0 22		beq $b794			beq 	_FLBCExit 					; end of string.
.b772	c9 22		cmp #$22			cmp 	#'"'						; quote, go to in quotes
.b774	f0 11		beq $b787			beq 	_FLBCInQuotes
.b776	e8		inx				inx
.b777	c9 61		cmp #$61			cmp 	#'a'						; needs capitalising ?
.b779	90 f2		bcc $b76d			bcc 	_FLBCLoop
.b77b	c9 7b		cmp #$7b			cmp 	#'z'+1
.b77d	b0 ee		bcs $b76d			bcs 	_FLBCLoop
.b77f	38		sec				sec 								; make U/C
.b780	e9 20		sbc #$20			sbc 	#32
.b782	9d a7 05	sta $05a7,x			sta	 	lineBuffer-1,x 				; write back
.b785	80 e6		bra $b76d			bra 	_FLBCLoop
.b787					_FLBCInQuotes:
.b787	e8		inx				inx 								; advance
.b788	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; get next
.b78b	f0 07		beq $b794			beq 	_FLBCExit 					; exit on EOS
.b78d	c9 22		cmp #$22			cmp 	#'"' 				 		; until " found
.b78f	d0 f6		bne $b787			bne 	_FLBCInQuotes
.b791	e8		inx				inx 								; skip over it
.b792	80 d9		bra $b76d			bra 	_FLBCLoop
.b794					_FLBCExit:
.b794	60		rts				rts
.b795					TOKExtractLineNumber:
.b795	ad aa 04	lda $04aa			lda 	tokenLineNumber+1 			; push current value on stack
.b798	48		pha				pha
.b799	ad a9 04	lda $04a9			lda 	tokenLineNumber
.b79c	48		pha				pha
.b79d	20 d3 b7	jsr $b7d3			jsr 	_LCLNTimes2 				; line # x 4
.b7a0	20 d3 b7	jsr $b7d3			jsr 	_LCLNTimes2 				; line # x 2
.b7a3	18		clc				clc 								; add stacked value
.b7a4	68		pla				pla
.b7a5	6d a9 04	adc $04a9			adc 	tokenLineNumber
.b7a8	8d a9 04	sta $04a9			sta 	tokenLineNumber
.b7ab	68		pla				pla
.b7ac	6d aa 04	adc $04aa			adc 	tokenLineNumber+1
.b7af	8d aa 04	sta $04aa			sta 	tokenLineNumber+1 			; line # x 5
.b7b2	20 d3 b7	jsr $b7d3			jsr 	_LCLNTimes2 				; line # x 10
.b7b5	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; get and consume character
.b7b8	e8		inx				inx
.b7b9	29 0f		and #$0f			and 	#15 						; add to line #
.b7bb	18		clc				clc
.b7bc	6d a9 04	adc $04a9			adc 	tokenLineNumber
.b7bf	8d a9 04	sta $04a9			sta 	tokenLineNumber
.b7c2	90 03		bcc $b7c7			bcc 	_TLENNoCarry
.b7c4	ee aa 04	inc $04aa			inc 	tokenLineNumber+1
.b7c7					_TLENNoCarry:
.b7c7	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; more digits ?
.b7ca	c9 30		cmp #$30			cmp 	#'0'
.b7cc	90 04		bcc $b7d2			bcc 	_TLENExit
.b7ce	c9 3a		cmp #$3a			cmp 	#'9'+1
.b7d0	90 c3		bcc $b795			bcc 	TOKExtractLineNumber
.b7d2					_TLENExit:
.b7d2	60		rts				rts
.b7d3					_LCLNTimes2:
.b7d3	0e a9 04	asl $04a9			asl 	tokenLineNumber
.b7d6	2e aa 04	rol $04aa			rol 	tokenLineNumber+1
.b7d9	60		rts				rts
.b7da					TOKWriteByte:
.b7da	da		phx				phx
.b7db	ae a8 04	ldx $04a8			ldx 	tokenOffset 				; next slot to write to
.b7de	9d a8 04	sta $04a8,x			sta 	tokenOffset,x 				; write byte out
.b7e1	ee a8 04	inc $04a8			inc 	tokenOffset 				; advance slot.
.b7e4	fa		plx				plx
.b7e5	60		rts				rts
.b7e6					TOKCheckCreateVariableRecord:
.b7e6	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.b7e8	85 36		sta $36				sta 	0+zTemp0
.b7ea	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.b7ec	85 37		sta $37				sta 	1+zTemp0
.b7ee					_CCVSearch:
.b7ee	b2 36		lda ($36)			lda 	(zTemp0) 					; end of list
.b7f0	f0 2c		beq $b81e			beq 	_CCVFail
.b7f2	a0 01		ldy #$01			ldy 	#1 							; read the hash
.b7f4	b1 36		lda ($36),y			lda 	(zTemp0),y 					; does it match ?
.b7f6	cd 83 04	cmp $0483			cmp 	identHash
.b7f9	d0 16		bne $b811			bne 	_CCVNext
.b7fb	a0 08		ldy #$08			ldy 	#8 							; name in variable record
.b7fd	ae 80 04	ldx $0480			ldx 	identStart
.b800					_CCVCompare:
.b800	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; xor them. zero if the same, except
.b803	51 36		eor ($36),y			eor 	(zTemp0),y 					; bit 7 is used for EOS.
.b805	e8		inx				inx 								; advance pointers
.b806	c8		iny				iny
.b807	0a		asl a				asl 	a 							; A = 0 if they match, CS if end.
.b808	d0 07		bne $b811			bne 	_CCVNext  					; didn't match go to next.
.b80a	90 f4		bcc $b800			bcc 	_CCVCompare 				; not finished yet.
.b80c	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; matched whole thing ?
.b80f	f0 41		beq $b852			beq 	_CCVFound 					; yes, we were successful
.b811					_CCVNext:
.b811	18		clc				clc
.b812	b2 36		lda ($36)			lda 	(zTemp0) 					; add offset to pointer
.b814	65 36		adc $36				adc 	zTemp0
.b816	85 36		sta $36				sta 	zTemp0
.b818	90 d4		bcc $b7ee			bcc 	_CCVSearch
.b81a	e6 37		inc $37				inc 	zTemp0+1
.b81c	80 d0		bra $b7ee			bra 	_CCVSearch
.b81e					_CCVFail:
.b81e	a0 01		ldy #$01			ldy 	#1 							; create the new record. Offset 1 is hash
.b820	ad 83 04	lda $0483			lda 	identHash
.b823	91 36		sta ($36),y			sta 	(zTemp0),y
.b825	c8		iny				iny 								; offset 2 is the type byte
.b826	ad 84 04	lda $0484			lda 	identTypeByte
.b829	91 36		sta ($36),y			sta 	(zTemp0),y
.b82b	c8		iny				iny
.b82c					_CCVData:
.b82c	a9 00		lda #$00			lda 	#0 							; erase data 3-7
.b82e	91 36		sta ($36),y			sta 	(zTemp0),y
.b830	c8		iny				iny
.b831	c0 08		cpy #$08			cpy 	#8
.b833	90 f7		bcc $b82c			bcc 	_CCVData
.b835	ae 80 04	ldx $0480			ldx 	identStart 					; copy name into 8 on.
.b838					_CCVCopyName:
.b838	bd a8 05	lda $05a8,x			lda 	lineBuffer,x
.b83b	91 36		sta ($36),y			sta 	(zTemp0),y
.b83d	e8		inx				inx
.b83e	c8		iny				iny
.b83f	ec 82 04	cpx $0482			cpx 	identTypeEnd
.b842	d0 f4		bne $b838			bne 	_CCVCopyName
.b844	98		tya				tya 								; patch offset
.b845	92 36		sta ($36)			sta 	(zTemp0)
.b847	a9 00		lda #$00			lda 	#0 							; offset for next is zero.
.b849	91 36		sta ($36),y			sta 	(zTemp0),y
.b84b	88		dey				dey
.b84c	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set bit 7 of last bit
.b84e	09 80		ora #$80			ora 	#$80
.b850	91 36		sta ($36),y			sta 	(zTemp0),y
.b852					_CCVFound:
.b852	a5 37		lda $37				lda 	zTemp0+1 					; write out MSB
.b854	38		sec				sec
.b855	e9 10		sbc #$10			sbc 	#(VariableSpace >> 8) 		; offset from the start
.b857	09 40		ora #$40			ora 	#$40 						; make it a writeable token
.b859	20 da b7	jsr $b7da			jsr 	TOKWriteByte
.b85c	a5 36		lda $36				lda 	zTemp0 						; write out LSB
.b85e	20 da b7	jsr $b7da			jsr 	TOKWriteByte
.b861	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_sound.module

=1					soundIntegrated=1
.b862					SNDCheckChannel:
.b862	aa		tax				tax
.b863	bd 09 08	lda $0809,x			lda 	SNDTimeLeft,x 				; currently playing a note
.b866	d0 38		bne $b8a0			bne 	_SNDCCExit
.b868	da		phx				phx 								; save current channel
.b869	8a		txa				txa 								; put in A
.b86a	20 e6 b8	jsr $b8e6			jsr 	SNDFindNextNoteForA 		; is there a note for A in the queue ?
.b86d	68		pla				pla 								; channel # in A
.b86e	90 30		bcc $b8a0			bcc 	_SNDCCExit  				; nothing in the queue for this channel, exit.
.b870	a8		tay				tay 								; Y is the channel #
.b871	bd fe 06	lda $06fe,x			lda 	SNDQueue+1,x 				; copy data into the slot.
.b874	99 fd 07	sta $07fd,y			sta 	SNDPitchLow,y
.b877	bd ff 06	lda $06ff,x			lda 	SNDQueue+2,x
.b87a	99 01 08	sta $0801,y			sta 	SNDPitchHigh,y
.b87d	bd 00 07	lda $0700,x			lda 	SNDQueue+3,x
.b880	99 05 08	sta $0805,y			sta 	SNDVolume,y
.b883	bd 01 07	lda $0701,x			lda 	SNDQueue+4,x
.b886	99 09 08	sta $0809,y			sta 	SNDTimeLeft,y
.b889	bd 02 07	lda $0702,x			lda 	SNDQueue+5,x
.b88c	99 0d 08	sta $080d,y			sta 	SNDAdjustLow,y
.b88f	bd 03 07	lda $0703,x			lda 	SNDQueue+6,x
.b892	99 11 08	sta $0811,y			sta 	SNDAdjustHigh,y
.b895	5a		phy				phy 								; save channel #
.b896	20 00 b9	jsr $b900			jsr 	SNDDeleteXFromQueue 		; delete record at X from queue
.b899	ce fc 06	dec $06fc			dec 	SNDLength 					; reduce the queue length.
.b89c	68		pla				pla
.b89d	20 a1 b8	jsr $b8a1			jsr 	SNDUpdateNote 				; update channel A
.b8a0					_SNDCCExit:
.b8a0	60		rts				rts
.b8a1					SNDUpdateNote:
.b8a1	aa		tax				tax 								; so we can access records
.b8a2	0a		asl a				asl 	a 							; convert it to a channel bit pair in 5,6
.b8a3	0a		asl a				asl 	a
.b8a4	0a		asl a				asl 	a
.b8a5	0a		asl a				asl 	a
.b8a6	0a		asl a				asl 	a
.b8a7	8d fb 06	sta $06fb			sta 	SNDChannelBits
.b8aa	bd 09 08	lda $0809,x			lda 	SNDTimeLeft,x 				; are we silent
.b8ad	f0 2e		beq $b8dd			beq 	_SNDUNIsSilent
.b8af	ad fb 06	lda $06fb			lda 	SNDChannelBits 				; push channel bits on stack
.b8b2	48		pha				pha
.b8b3	bd fd 07	lda $07fd,x			lda 	SNDPitchLow,x 				; get 4 lowest bits of pitch.
.b8b6	29 0f		and #$0f			and 	#$0F
.b8b8	0d fb 06	ora $06fb			ora 	SNDChannelBits 				; set channel bits
.b8bb	09 80		ora #$80			ora 	#$80 						; write to pitch register
.b8bd	20 4a b9	jsr $b94a			jsr 	SNDWritePorts
.b8c0	bd 01 08	lda $0801,x			lda 	SNDPitchHigh,x 				; pitch high => channel temp.
.b8c3	8d fb 06	sta $06fb			sta 	SNDChannelBits
.b8c6	bd fd 07	lda $07fd,x			lda 	SNDPitchLow,x
.b8c9	4e fb 06	lsr $06fb			lsr 	SNDChannelBits 				; shift 2 LSBs into MSB of A
.b8cc	6a		ror a				ror 	a
.b8cd	4e fb 06	lsr $06fb			lsr 	SNDChannelBits
.b8d0	6a		ror a				ror 	a
.b8d1	4a		lsr a				lsr 	a 							; put in bits 0-5
.b8d2	4a		lsr a				lsr 	a
.b8d3	20 4a b9	jsr $b94a			jsr 	SNDWritePorts 				; write as rest of pitch register
.b8d6	68		pla				pla
.b8d7	09 90		ora #$90			ora 	#$90 						; set to write minimum attentuation.
.b8d9	20 4a b9	jsr $b94a			jsr 	SNDWritePorts
.b8dc	60		rts				rts
.b8dd					_SNDUNIsSilent:
.b8dd	ad fb 06	lda $06fb			lda 	SNDChannelBits 				; channel bits
.b8e0	09 9f		ora #$9f			ora 	#$9F 						; maximum attenuation
.b8e2	20 4a b9	jsr $b94a			jsr 	SNDWritePorts 				; write to the ports
.b8e5	60		rts				rts
.b8e6					SNDFindNextNoteForA:
.b8e6	ac fc 06	ldy $06fc			ldy 	SNDLength 					; queue size into Y
.b8e9	f0 13		beq $b8fe			beq 	_SNDFNNFail 				; queue empty.
.b8eb	a2 00		ldx #$00			ldx 	#0
.b8ed					_SNDFNNSearch:
.b8ed	dd fd 06	cmp $06fd,x			cmp 	SNDQueue,x 					; does it match the channel
.b8f0	38		sec				sec
.b8f1	f0 0c		beq $b8ff			beq 	_SNDFNNExit 				; if so exit with CS.
.b8f3	e8		inx				inx 								; next queue slot.
.b8f4	e8		inx				inx
.b8f5	e8		inx				inx
.b8f6	e8		inx				inx
.b8f7	e8		inx				inx
.b8f8	e8		inx				inx
.b8f9	e8		inx				inx
.b8fa	e8		inx				inx
.b8fb	88		dey				dey 								; done the whole queue
.b8fc	d0 ef		bne $b8ed			bne 	_SNDFNNSearch 				; no, go back.
.b8fe					_SNDFNNFail:
.b8fe	18		clc				clc
.b8ff					_SNDFNNexit:
.b8ff	60		rts				rts
.b900					SNDDeleteXFromQueue:
.b900	e0 f8		cpx #$f8			cpx 	#SNDQueueSize*8-8 			; reached the end.
.b902	f0 09		beq $b90d			beq 	_SNDDXExit
.b904	bd 05 07	lda $0705,x			lda 	SNDQueue+8,x
.b907	9d fd 06	sta $06fd,x			sta 	SNDQueue,x
.b90a	e8		inx				inx
.b90b	80 f3		bra $b900			bra 	SNDDeleteXFromQueue
.b90d					_SNDDXExit:
.b90d	60		rts				rts
.06fb					SNDChannelBits:
>06fb							.fill 	1
.b90e					SNDQueueRequest:
.b90e	86 36		stx $36				stx 	zTemp0						; save queue address
.b910	84 37		sty $37				sty 	zTemp0+1
.b912	ae fc 06	ldx $06fc			ldx 	SNDLength 					; queue is full, can't take any more.
.b915	e0 20		cpx #$20			cpx 	#SNDQueueSize
.b917	f0 21		beq $b93a			beq 	_SNDQRExit
.b919	29 03		and #$03			and 	#3	 						; channel # and push on stack
.b91b	48		pha				pha
.b91c	8a		txa				txa  								; get offset in queue buffer/
.b91d	0a		asl a				asl 	a
.b91e	0a		asl a				asl 	a
.b91f	0a		asl a				asl 	a
.b920	aa		tax				tax
.b921	68		pla				pla 								; get back and push again
.b922	48		pha				pha
.b923	9d fd 06	sta $06fd,x			sta 	SNDQueue+0,x 				; save the channel #
.b926	a0 00		ldy #$00			ldy 	#0 							; copy the rest in.
.b928					_SNDQCopy:
.b928	b1 36		lda ($36),y			lda 	(zTemp0),y
.b92a	e8		inx				inx
.b92b	c8		iny				iny
.b92c	9d fd 06	sta $06fd,x			sta 	SNDQueue,x
.b92f	c0 06		cpy #$06			cpy 	#6
.b931	d0 f5		bne $b928			bne 	_SNDQCopy
.b933	ee fc 06	inc $06fc			inc 	SNDLength 					; bump queue length.
.b936	68		pla				pla 								; get channel # back
.b937	20 62 b8	jsr $b862			jsr 	SNDCheckChannel 			; check if channel needs refreshing.
.b93a					_SNDQRExit:
.b93a	60		rts				rts
.b93b					SNDSilenceChannel:
.b93b	aa		tax				tax 								; zero time left.
.b93c	9e 09 08	stz $0809,x			stz 	SNDTimeLeft,x
.b93f	0a		asl a				asl 	a 							; shift into position
.b940	0a		asl a				asl 	a
.b941	0a		asl a				asl 	a
.b942	0a		asl a				asl 	a
.b943	0a		asl a				asl 	a
.b944	09 9f		ora #$9f			ora 	#$9F 						; write register attenuation $F
.b946	20 4a b9	jsr $b94a			jsr 	SNDWritePorts
.b949	60		rts				rts
.b94a					SNDWritePorts:
.b94a	64 01		stz $01				stz 	1
.b94c	8d 00 d6	sta $d600			sta 	$D600
.b94f	8d 10 d6	sta $d610			sta 	$D610
.b952	60		rts				rts
.b953					SNDCommand:
.b953	c9 0f		cmp #$0f			cmp 	#$0F 						; $0F is initialise
.b955	f0 1c		beq $b973			beq 	_SNDInitialise
.b957	90 27		bcc $b980			bcc 	_SNDExit
.b959	c9 3f		cmp #$3f			cmp 	#$3F 						; $3F is silence all
.b95b	f0 16		beq $b973			beq 	_SNDSilence
.b95d	b0 21		bcs $b980			bcs 	_SNDExit
.b95f	c9 20		cmp #$20			cmp 	#$20 						; $2x is check playing => A
.b961	b0 09		bcs $b96c			bcs 	_SNDQueryPlay
.b963	c9 14		cmp #$14			cmp 	#$14 						; $10-$13 is queue sound
.b965	b0 19		bcs $b980			bcs 	_SNDExit
.b967	20 0e b9	jsr $b90e			jsr 	SNDQueueRequest
.b96a	80 14		bra $b980			bra 	_SNDExit
.b96c					_SNDQueryPlay:
.b96c	29 03		and #$03			and 	#3 							; get channel #
.b96e	bd 09 08	lda $0809,x			lda 	SNDTimeLeft,x 				; read time left, if zero then silent
.b971	80 0d		bra $b980			bra 	_SNDExit
.b973					_SNDInitialise:
.b973					_SNDSilence:
.b973	9c fc 06	stz $06fc			stz 	SNDLength 					; empty the queue.
.b976	a9 03		lda #$03			lda 	#$3 						; silence channel 0-3.
.b978					_SNDSilenceLoop:
.b978	48		pha				pha
.b979	20 3b b9	jsr $b93b			jsr 	SNDSilenceChannel
.b97c	68		pla				pla
.b97d	3a		dec a				dec 	a
.b97e	10 f8		bpl $b978			bpl 	_SNDSilenceLoop
.b980					_SNDExit:
.b980	60		rts				rts
=32					SNDQueueSize = 32 							; number of queue entries
.06fc					SNDLength:
>06fc							.fill 	1
.06fd					SNDQueue:
>06fd							.fill 	SNDQueueSize * 8
.07fd					SNDPitchLow:
>07fd							.fill 	4
.0801					SNDPitchHigh:
>0801							.fill 	4
.0805					SNDVolume:
>0805							.fill 	4
.0809					SNDTimeLeft:
>0809							.fill 	4
.080d					SNDAdjustLow:
>080d							.fill 	4
.0811					SNDAdjustHigh:
>0811							.fill 	4
.b981					SNDUpdate:
.b981	ad 09 08	lda $0809			lda 	SNDTimeLeft+0 				; look at time remaining
.b984	f0 05		beq $b98b			beq 	_SNDUNot0 					; not playing
.b986	a2 00		ldx #$00			ldx 	#0 							; so we know which channel to update
.b988	20 aa b9	jsr $b9aa			jsr 	SNDUpdateChannel 			; update it.
.b98b					_SNDUNot0:
.b98b	ad 0a 08	lda $080a			lda 	SNDTimeLeft+1
.b98e	f0 05		beq $b995			beq 	_SNDUNot1
.b990	a2 01		ldx #$01			ldx 	#1
.b992	20 aa b9	jsr $b9aa			jsr 	SNDUpdateChannel
.b995					_SNDUNot1:
.b995	ad 0b 08	lda $080b			lda 	SNDTimeLeft+2
.b998	f0 05		beq $b99f			beq 	_SNDUNot2
.b99a	a2 02		ldx #$02			ldx 	#2
.b99c	20 aa b9	jsr $b9aa			jsr 	SNDUpdateChannel
.b99f					_SNDUNot2:
.b99f	ad 0c 08	lda $080c			lda 	SNDTimeLeft+3
.b9a2	f0 05		beq $b9a9			beq 	_SNDUNot3
.b9a4	a2 03		ldx #$03			ldx 	#3
.b9a6	20 aa b9	jsr $b9aa			jsr 	SNDUpdateChannel
.b9a9					_SNDUNot3:
.b9a9	60		rts				rts
.b9aa					SNDUpdateChannel:
.b9aa	c9 ff		cmp #$ff			cmp 	#$FF 						; sound $FF play forever until turned off manually
.b9ac	f0 2c		beq $b9da			beq 	_SNDUCExit
.b9ae	3a		dec a				dec 	a 							; decrement and update timer
.b9af	9d 09 08	sta $0809,x			sta 	SNDTimeLeft,x
.b9b2	f0 1d		beq $b9d1			beq 	_SNDUCUpdate 				; if zero, silence channel
.b9b4	bd 0d 08	lda $080d,x			lda 	SNDAdjustLow,x 				; adjust ?
.b9b7	1d 11 08	ora $0811,x			ora 	SNDAdjustHigh,x
.b9ba	f0 1e		beq $b9da			beq 	_SNDUCExit 					; if zero carry on at current tone.
.b9bc	18		clc				clc 								; add adjust, forcing into a 10 bit range
.b9bd	bd fd 07	lda $07fd,x			lda 	SNDPitchLow,x
.b9c0	7d 0d 08	adc $080d,x			adc 	SNDAdjustLow,x
.b9c3	9d fd 07	sta $07fd,x			sta 	SNDPitchLow,x
.b9c6	bd 01 08	lda $0801,x			lda 	SNDPitchHigh,x
.b9c9	7d 11 08	adc $0811,x			adc 	SNDAdjustHigh,x
.b9cc	29 03		and #$03			and 	#3
.b9ce	9d 01 08	sta $0801,x			sta 	SNDPitchHigh,x
.b9d1					_SNDUCUpdate:
.b9d1	8a		txa				txa 								; which channel.
.b9d2	48		pha				pha
.b9d3	20 a1 b8	jsr $b8a1			jsr 	SNDUpdateNote 				; update the current note
.b9d6	68		pla				pla
.b9d7	20 62 b8	jsr $b862			jsr 	SNDCheckChannel 			; more to do ?
.b9da					_SNDUCExit:
.b9da	60		rts				rts

;******  Return to file: _basic.asm


;******  End of listing
